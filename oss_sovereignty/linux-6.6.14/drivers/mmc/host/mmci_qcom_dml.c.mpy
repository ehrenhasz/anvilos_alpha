{
  "module_name": "mmci_qcom_dml.c",
  "hash_id": "89871d93b3ac6e29f9e705cf7819d90e923d2c1541b9130da3dd216039ce621f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mmci_qcom_dml.c",
  "human_readable_source": "\n \n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/bitops.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include \"mmci.h\"\n\n \n#define DML_CONFIG\t\t\t0x00\n#define PRODUCER_CRCI_MSK\t\tGENMASK(1, 0)\n#define PRODUCER_CRCI_DISABLE\t\t0\n#define PRODUCER_CRCI_X_SEL\t\tBIT(0)\n#define PRODUCER_CRCI_Y_SEL\t\tBIT(1)\n#define CONSUMER_CRCI_MSK\t\tGENMASK(3, 2)\n#define CONSUMER_CRCI_DISABLE\t\t0\n#define CONSUMER_CRCI_X_SEL\t\tBIT(2)\n#define CONSUMER_CRCI_Y_SEL\t\tBIT(3)\n#define PRODUCER_TRANS_END_EN\t\tBIT(4)\n#define BYPASS\t\t\t\tBIT(16)\n#define DIRECT_MODE\t\t\tBIT(17)\n#define INFINITE_CONS_TRANS\t\tBIT(18)\n\n#define DML_SW_RESET\t\t\t0x08\n#define DML_PRODUCER_START\t\t0x0c\n#define DML_CONSUMER_START\t\t0x10\n#define DML_PRODUCER_PIPE_LOGICAL_SIZE\t0x14\n#define DML_CONSUMER_PIPE_LOGICAL_SIZE\t0x18\n#define DML_PIPE_ID\t\t\t0x1c\n#define PRODUCER_PIPE_ID_SHFT\t\t0\n#define PRODUCER_PIPE_ID_MSK\t\tGENMASK(4, 0)\n#define CONSUMER_PIPE_ID_SHFT\t\t16\n#define CONSUMER_PIPE_ID_MSK\t\tGENMASK(20, 16)\n\n#define DML_PRODUCER_BAM_BLOCK_SIZE\t0x24\n#define DML_PRODUCER_BAM_TRANS_SIZE\t0x28\n\n \n#define PRODUCER_PIPE_LOGICAL_SIZE\t4096\n#define CONSUMER_PIPE_LOGICAL_SIZE\t4096\n\n#define DML_OFFSET\t\t\t0x800\n\nstatic int qcom_dma_start(struct mmci_host *host, unsigned int *datactrl)\n{\n\tu32 config;\n\tvoid __iomem *base = host->base + DML_OFFSET;\n\tstruct mmc_data *data = host->data;\n\tint ret = mmci_dmae_start(host, datactrl);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\t \n\t\t \n\t\tconfig = readl_relaxed(base + DML_CONFIG);\n\t\tconfig = (config & ~PRODUCER_CRCI_MSK) | PRODUCER_CRCI_X_SEL;\n\t\tconfig = (config & ~CONSUMER_CRCI_MSK) | CONSUMER_CRCI_DISABLE;\n\t\twritel_relaxed(config, base + DML_CONFIG);\n\n\t\t \n\t\twritel_relaxed(data->blksz, base + DML_PRODUCER_BAM_BLOCK_SIZE);\n\n\t\t \n\t\twritel_relaxed(data->blocks * data->blksz,\n\t\t\t       base + DML_PRODUCER_BAM_TRANS_SIZE);\n\t\t \n\t\tconfig = readl_relaxed(base + DML_CONFIG);\n\t\tconfig |= PRODUCER_TRANS_END_EN;\n\t\twritel_relaxed(config, base + DML_CONFIG);\n\t\t \n\t\twritel_relaxed(1, base + DML_PRODUCER_START);\n\t} else {\n\t\t \n\t\t \n\t\tconfig = readl_relaxed(base + DML_CONFIG);\n\t\tconfig = (config & ~CONSUMER_CRCI_MSK) | CONSUMER_CRCI_X_SEL;\n\t\tconfig = (config & ~PRODUCER_CRCI_MSK) | PRODUCER_CRCI_DISABLE;\n\t\twritel_relaxed(config, base + DML_CONFIG);\n\t\t \n\t\tconfig = readl_relaxed(base + DML_CONFIG);\n\t\tconfig &= ~PRODUCER_TRANS_END_EN;\n\t\twritel_relaxed(config, base + DML_CONFIG);\n\t\t \n\t\twritel_relaxed(1, base + DML_CONSUMER_START);\n\t}\n\n\t \n\twmb();\n\treturn 0;\n}\n\nstatic int of_get_dml_pipe_index(struct device_node *np, const char *name)\n{\n\tint index;\n\tstruct of_phandle_args\tdma_spec;\n\n\tindex = of_property_match_string(np, \"dma-names\", name);\n\n\tif (index < 0)\n\t\treturn -ENODEV;\n\n\tif (of_parse_phandle_with_args(np, \"dmas\", \"#dma-cells\", index,\n\t\t\t\t       &dma_spec))\n\t\treturn -ENODEV;\n\n\tif (dma_spec.args_count)\n\t\treturn dma_spec.args[0];\n\n\treturn -ENODEV;\n}\n\n \nstatic int qcom_dma_setup(struct mmci_host *host)\n{\n\tu32 config;\n\tvoid __iomem *base;\n\tint consumer_id, producer_id;\n\tstruct device_node *np = host->mmc->parent->of_node;\n\n\tif (mmci_dmae_setup(host))\n\t\treturn -EINVAL;\n\n\tconsumer_id = of_get_dml_pipe_index(np, \"tx\");\n\tproducer_id = of_get_dml_pipe_index(np, \"rx\");\n\n\tif (producer_id < 0 || consumer_id < 0) {\n\t\tmmci_dmae_release(host);\n\t\treturn -EINVAL;\n\t}\n\n\tbase = host->base + DML_OFFSET;\n\n\t \n\twritel_relaxed(1, base + DML_SW_RESET);\n\n\t \n\tconfig = (PRODUCER_CRCI_DISABLE | CONSUMER_CRCI_DISABLE);\n\t \n\tconfig &= ~BYPASS;\n\t \n\tconfig &= ~DIRECT_MODE;\n\t \n\tconfig &= ~INFINITE_CONS_TRANS;\n\twritel_relaxed(config, base + DML_CONFIG);\n\n\t \n\twritel_relaxed(PRODUCER_PIPE_LOGICAL_SIZE,\n\t\t       base + DML_PRODUCER_PIPE_LOGICAL_SIZE);\n\twritel_relaxed(CONSUMER_PIPE_LOGICAL_SIZE,\n\t\t       base + DML_CONSUMER_PIPE_LOGICAL_SIZE);\n\n\t \n\twritel_relaxed(producer_id | (consumer_id << CONSUMER_PIPE_ID_SHFT),\n\t\t       base + DML_PIPE_ID);\n\n\t \n\tmb();\n\n\treturn 0;\n}\n\nstatic u32 qcom_get_dctrl_cfg(struct mmci_host *host)\n{\n\treturn MCI_DPSM_ENABLE | (host->data->blksz << 4);\n}\n\nstatic struct mmci_host_ops qcom_variant_ops = {\n\t.prep_data = mmci_dmae_prep_data,\n\t.unprep_data = mmci_dmae_unprep_data,\n\t.get_datactrl_cfg = qcom_get_dctrl_cfg,\n\t.get_next_data = mmci_dmae_get_next_data,\n\t.dma_setup = qcom_dma_setup,\n\t.dma_release = mmci_dmae_release,\n\t.dma_start = qcom_dma_start,\n\t.dma_finalize = mmci_dmae_finalize,\n\t.dma_error = mmci_dmae_error,\n};\n\nvoid qcom_variant_init(struct mmci_host *host)\n{\n\thost->ops = &qcom_variant_ops;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}