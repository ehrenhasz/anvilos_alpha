{
  "module_name": "mmc_spi.c",
  "hash_id": "f874b70441b5e4ac0f9cb634380819eada6e78f0f273eefaaab893f6efa45360",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mmc_spi.c",
  "human_readable_source": "\n \n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/bio.h>\n#include <linux/dma-mapping.h>\n#include <linux/crc7.h>\n#include <linux/crc-itu-t.h>\n#include <linux/scatterlist.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\t\t \n#include <linux/mmc/slot-gpio.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/mmc_spi.h>\n\n#include <asm/unaligned.h>\n\n\n \n\n\n \n\n \n#define SPI_MMC_RESPONSE_CODE(x)\t((x) & 0x1f)\n#define SPI_RESPONSE_ACCEPTED\t\t((2 << 1)|1)\n#define SPI_RESPONSE_CRC_ERR\t\t((5 << 1)|1)\n#define SPI_RESPONSE_WRITE_ERR\t\t((6 << 1)|1)\n\n \n#define SPI_TOKEN_SINGLE\t0xfe\t \n#define SPI_TOKEN_MULTI_WRITE\t0xfc\t \n#define SPI_TOKEN_STOP_TRAN\t0xfd\t \n\n#define MMC_SPI_BLOCKSIZE\t512\n\n#define MMC_SPI_R1B_TIMEOUT_MS\t3000\n#define MMC_SPI_INIT_TIMEOUT_MS\t3000\n\n \n#define MMC_SPI_BLOCKSATONCE\t128\n\n \n\n \n\n \nstruct scratch {\n\tu8\t\t\tstatus[29];\n\tu8\t\t\tdata_token;\n\t__be16\t\t\tcrc_val;\n};\n\nstruct mmc_spi_host {\n\tstruct mmc_host\t\t*mmc;\n\tstruct spi_device\t*spi;\n\n\tunsigned char\t\tpower_mode;\n\tu16\t\t\tpowerup_msecs;\n\n\tstruct mmc_spi_platform_data\t*pdata;\n\n\t \n\tstruct spi_transfer\ttoken, t, crc, early_status;\n\tstruct spi_message\tm;\n\n\t \n\tstruct spi_transfer\tstatus;\n\tstruct spi_message\treadback;\n\n\t \n\tstruct device\t\t*dma_dev;\n\n\t \n\tstruct scratch\t\t*data;\n\tdma_addr_t\t\tdata_dma;\n\n\t \n\tvoid\t\t\t*ones;\n\tdma_addr_t\t\tones_dma;\n};\n\n\n \n\n \n\nstatic inline int mmc_cs_off(struct mmc_spi_host *host)\n{\n\t \n\treturn spi_setup(host->spi);\n}\n\nstatic int\nmmc_spi_readbytes(struct mmc_spi_host *host, unsigned len)\n{\n\tint status;\n\n\tif (len > sizeof(*host->data)) {\n\t\tWARN_ON(1);\n\t\treturn -EIO;\n\t}\n\n\thost->status.len = len;\n\n\tif (host->dma_dev)\n\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*host->data),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tstatus = spi_sync_locked(host->spi, &host->readback);\n\n\tif (host->dma_dev)\n\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*host->data),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\treturn status;\n}\n\nstatic int mmc_spi_skip(struct mmc_spi_host *host, unsigned long timeout,\n\t\t\tunsigned n, u8 byte)\n{\n\tu8 *cp = host->data->status;\n\tunsigned long start = jiffies;\n\n\tdo {\n\t\tint\t\tstatus;\n\t\tunsigned\ti;\n\n\t\tstatus = mmc_spi_readbytes(host, n);\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (cp[i] != byte)\n\t\t\t\treturn cp[i];\n\t\t}\n\n\t\t \n\t\tcond_resched();\n\t} while (time_is_after_jiffies(start + timeout));\n\treturn -ETIMEDOUT;\n}\n\nstatic inline int\nmmc_spi_wait_unbusy(struct mmc_spi_host *host, unsigned long timeout)\n{\n\treturn mmc_spi_skip(host, timeout, sizeof(host->data->status), 0);\n}\n\nstatic int mmc_spi_readtoken(struct mmc_spi_host *host, unsigned long timeout)\n{\n\treturn mmc_spi_skip(host, timeout, 1, 0xff);\n}\n\n\n \n\nstatic char *maptype(struct mmc_command *cmd)\n{\n\tswitch (mmc_spi_resp_type(cmd)) {\n\tcase MMC_RSP_SPI_R1:\treturn \"R1\";\n\tcase MMC_RSP_SPI_R1B:\treturn \"R1B\";\n\tcase MMC_RSP_SPI_R2:\treturn \"R2/R5\";\n\tcase MMC_RSP_SPI_R3:\treturn \"R3/R4/R7\";\n\tdefault:\t\treturn \"?\";\n\t}\n}\n\n \nstatic int mmc_spi_response_get(struct mmc_spi_host *host,\n\t\tstruct mmc_command *cmd, int cs_on)\n{\n\tunsigned long timeout_ms;\n\tu8\t*cp = host->data->status;\n\tu8\t*end = cp + host->t.len;\n\tint\tvalue = 0;\n\tint\tbitshift;\n\tu8 \tleftover = 0;\n\tunsigned short rotator;\n\tint \ti;\n\tchar\ttag[32];\n\n\tsnprintf(tag, sizeof(tag), \"  ... CMD%d response SPI_%s\",\n\t\tcmd->opcode, maptype(cmd));\n\n\t \n\tcp += 8;\n\twhile (cp < end && *cp == 0xff)\n\t\tcp++;\n\n\t \n\tif (cp == end) {\n\t\tcp = host->data->status;\n\t\tend = cp+1;\n\n\t\t \n\t\tfor (i = 2; i < 16; i++) {\n\t\t\tvalue = mmc_spi_readbytes(host, 1);\n\t\t\tif (value < 0)\n\t\t\t\tgoto done;\n\t\t\tif (*cp != 0xff)\n\t\t\t\tgoto checkstatus;\n\t\t}\n\t\tvalue = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\ncheckstatus:\n\tbitshift = 0;\n\tif (*cp & 0x80)\t{\n\t\t \n\t\trotator = *cp++ << 8;\n\t\t \n\t\tif (cp == end) {\n\t\t\tvalue = mmc_spi_readbytes(host, 1);\n\t\t\tif (value < 0)\n\t\t\t\tgoto done;\n\t\t\tcp = host->data->status;\n\t\t\tend = cp+1;\n\t\t}\n\t\trotator |= *cp++;\n\t\twhile (rotator & 0x8000) {\n\t\t\tbitshift++;\n\t\t\trotator <<= 1;\n\t\t}\n\t\tcmd->resp[0] = rotator >> 8;\n\t\tleftover = rotator;\n\t} else {\n\t\tcmd->resp[0] = *cp++;\n\t}\n\tcmd->error = 0;\n\n\t \n\tif (cmd->resp[0] != 0) {\n\t\tif ((R1_SPI_PARAMETER | R1_SPI_ADDRESS)\n\t\t\t\t& cmd->resp[0])\n\t\t\tvalue = -EFAULT;  \n\t\telse if (R1_SPI_ILLEGAL_COMMAND & cmd->resp[0])\n\t\t\tvalue = -ENOSYS;  \n\t\telse if (R1_SPI_COM_CRC & cmd->resp[0])\n\t\t\tvalue = -EILSEQ;  \n\t\telse if ((R1_SPI_ERASE_SEQ | R1_SPI_ERASE_RESET)\n\t\t\t\t& cmd->resp[0])\n\t\t\tvalue = -EIO;     \n\t\t \n\t}\n\n\tswitch (mmc_spi_resp_type(cmd)) {\n\n\t \n\tcase MMC_RSP_SPI_R1B:\n\t\t \n\t\twhile (cp < end && *cp == 0)\n\t\t\tcp++;\n\t\tif (cp == end) {\n\t\t\ttimeout_ms = cmd->busy_timeout ? cmd->busy_timeout :\n\t\t\t\tMMC_SPI_R1B_TIMEOUT_MS;\n\t\t\tmmc_spi_wait_unbusy(host, msecs_to_jiffies(timeout_ms));\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MMC_RSP_SPI_R2:\n\t\t \n\t\tif (cp == end) {\n\t\t\tvalue = mmc_spi_readbytes(host, 1);\n\t\t\tif (value < 0)\n\t\t\t\tgoto done;\n\t\t\tcp = host->data->status;\n\t\t\tend = cp+1;\n\t\t}\n\t\tif (bitshift) {\n\t\t\trotator = leftover << 8;\n\t\t\trotator |= *cp << bitshift;\n\t\t\tcmd->resp[0] |= (rotator & 0xFF00);\n\t\t} else {\n\t\t\tcmd->resp[0] |= *cp << 8;\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MMC_RSP_SPI_R3:\n\t\trotator = leftover << 8;\n\t\tcmd->resp[1] = 0;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcmd->resp[1] <<= 8;\n\t\t\t \n\t\t\tif (cp == end) {\n\t\t\t\tvalue = mmc_spi_readbytes(host, 1);\n\t\t\t\tif (value < 0)\n\t\t\t\t\tgoto done;\n\t\t\t\tcp = host->data->status;\n\t\t\t\tend = cp+1;\n\t\t\t}\n\t\t\tif (bitshift) {\n\t\t\t\trotator |= *cp++ << bitshift;\n\t\t\t\tcmd->resp[1] |= (rotator >> 8);\n\t\t\t\trotator <<= 8;\n\t\t\t} else {\n\t\t\t\tcmd->resp[1] |= *cp++;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t \n\tcase MMC_RSP_SPI_R1:\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(&host->spi->dev, \"bad response type %04x\\n\",\n\t\t\tmmc_spi_resp_type(cmd));\n\t\tif (value >= 0)\n\t\t\tvalue = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (value < 0)\n\t\tdev_dbg(&host->spi->dev, \"%s: resp %04x %08x\\n\",\n\t\t\ttag, cmd->resp[0], cmd->resp[1]);\n\n\t \n\tif (value >= 0 && cs_on)\n\t\treturn value;\ndone:\n\tif (value < 0)\n\t\tcmd->error = value;\n\tmmc_cs_off(host);\n\treturn value;\n}\n\n \nstatic int\nmmc_spi_command_send(struct mmc_spi_host *host,\n\t\tstruct mmc_request *mrq,\n\t\tstruct mmc_command *cmd, int cs_on)\n{\n\tstruct scratch\t\t*data = host->data;\n\tu8\t\t\t*cp = data->status;\n\tint\t\t\tstatus;\n\tstruct spi_transfer\t*t;\n\n\t \n\tmemset(cp, 0xff, sizeof(data->status));\n\n\tcp[1] = 0x40 | cmd->opcode;\n\tput_unaligned_be32(cmd->arg, cp + 2);\n\tcp[6] = crc7_be(0, cp + 1, 5) | 0x01;\n\tcp += 7;\n\n\t \n\tif (cs_on && (mrq->data->flags & MMC_DATA_READ)) {\n\t\tcp += 2;\t \n\t\t \n\t} else {\n\t\tcp += 10;\t \n\t\tif (cmd->flags & MMC_RSP_SPI_S2)\t \n\t\t\tcp++;\n\t\telse if (cmd->flags & MMC_RSP_SPI_B4)\t \n\t\t\tcp += 4;\n\t\telse if (cmd->flags & MMC_RSP_BUSY)\t \n\t\t\tcp = data->status + sizeof(data->status);\n\t\t \n\t}\n\n\tdev_dbg(&host->spi->dev, \"  CMD%d, resp %s\\n\",\n\t\tcmd->opcode, maptype(cmd));\n\n\t \n\tspi_message_init(&host->m);\n\n\tt = &host->t;\n\tmemset(t, 0, sizeof(*t));\n\tt->tx_buf = t->rx_buf = data->status;\n\tt->tx_dma = t->rx_dma = host->data_dma;\n\tt->len = cp - data->status;\n\tt->cs_change = 1;\n\tspi_message_add_tail(t, &host->m);\n\n\tif (host->dma_dev) {\n\t\thost->m.is_dma_mapped = 1;\n\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*host->data),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\t}\n\tstatus = spi_sync_locked(host->spi, &host->m);\n\n\tif (host->dma_dev)\n\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*host->data),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (status < 0) {\n\t\tdev_dbg(&host->spi->dev, \"  ... write returned %d\\n\", status);\n\t\tcmd->error = status;\n\t\treturn status;\n\t}\n\n\t \n\treturn mmc_spi_response_get(host, cmd, cs_on);\n}\n\n \nstatic void\nmmc_spi_setup_data_message(\n\tstruct mmc_spi_host\t*host,\n\tbool\t\t\tmultiple,\n\tenum dma_data_direction\tdirection)\n{\n\tstruct spi_transfer\t*t;\n\tstruct scratch\t\t*scratch = host->data;\n\tdma_addr_t\t\tdma = host->data_dma;\n\n\tspi_message_init(&host->m);\n\tif (dma)\n\t\thost->m.is_dma_mapped = 1;\n\n\t \n\tif (direction == DMA_TO_DEVICE) {\n\t\tt = &host->token;\n\t\tmemset(t, 0, sizeof(*t));\n\t\tt->len = 1;\n\t\tif (multiple)\n\t\t\tscratch->data_token = SPI_TOKEN_MULTI_WRITE;\n\t\telse\n\t\t\tscratch->data_token = SPI_TOKEN_SINGLE;\n\t\tt->tx_buf = &scratch->data_token;\n\t\tif (dma)\n\t\t\tt->tx_dma = dma + offsetof(struct scratch, data_token);\n\t\tspi_message_add_tail(t, &host->m);\n\t}\n\n\t \n\tt = &host->t;\n\tmemset(t, 0, sizeof(*t));\n\tt->tx_buf = host->ones;\n\tt->tx_dma = host->ones_dma;\n\t \n\tspi_message_add_tail(t, &host->m);\n\n\tt = &host->crc;\n\tmemset(t, 0, sizeof(*t));\n\tt->len = 2;\n\tif (direction == DMA_TO_DEVICE) {\n\t\t \n\t\tt->tx_buf = &scratch->crc_val;\n\t\tif (dma)\n\t\t\tt->tx_dma = dma + offsetof(struct scratch, crc_val);\n\t} else {\n\t\tt->tx_buf = host->ones;\n\t\tt->tx_dma = host->ones_dma;\n\t\tt->rx_buf = &scratch->crc_val;\n\t\tif (dma)\n\t\t\tt->rx_dma = dma + offsetof(struct scratch, crc_val);\n\t}\n\tspi_message_add_tail(t, &host->m);\n\n\t \n\tif (multiple || direction == DMA_TO_DEVICE) {\n\t\tt = &host->early_status;\n\t\tmemset(t, 0, sizeof(*t));\n\t\tt->len = (direction == DMA_TO_DEVICE) ? sizeof(scratch->status) : 1;\n\t\tt->tx_buf = host->ones;\n\t\tt->tx_dma = host->ones_dma;\n\t\tt->rx_buf = scratch->status;\n\t\tif (dma)\n\t\t\tt->rx_dma = dma + offsetof(struct scratch, status);\n\t\tt->cs_change = 1;\n\t\tspi_message_add_tail(t, &host->m);\n\t}\n}\n\n \nstatic int\nmmc_spi_writeblock(struct mmc_spi_host *host, struct spi_transfer *t,\n\tunsigned long timeout)\n{\n\tstruct spi_device\t*spi = host->spi;\n\tint\t\t\tstatus, i;\n\tstruct scratch\t\t*scratch = host->data;\n\tu32\t\t\tpattern;\n\n\tif (host->mmc->use_spi_crc)\n\t\tscratch->crc_val = cpu_to_be16(crc_itu_t(0, t->tx_buf, t->len));\n\tif (host->dma_dev)\n\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\n\tstatus = spi_sync_locked(spi, &host->m);\n\n\tif (status != 0) {\n\t\tdev_dbg(&spi->dev, \"write error (%d)\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (host->dma_dev)\n\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\n\t \n\tpattern = get_unaligned_be32(scratch->status);\n\n\t \n\tpattern |= 0xE0000000;\n\n\t \n\twhile (pattern & 0x80000000)\n\t\tpattern <<= 1;\n\t \n\tpattern >>= 27;\n\n\tswitch (pattern) {\n\tcase SPI_RESPONSE_ACCEPTED:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase SPI_RESPONSE_CRC_ERR:\n\t\t \n\t\tstatus = -EILSEQ;\n\t\tbreak;\n\tcase SPI_RESPONSE_WRITE_ERR:\n\t\t \n\t\tstatus = -EIO;\n\t\tbreak;\n\tdefault:\n\t\tstatus = -EPROTO;\n\t\tbreak;\n\t}\n\tif (status != 0) {\n\t\tdev_dbg(&spi->dev, \"write error %02x (%d)\\n\",\n\t\t\tscratch->status[0], status);\n\t\treturn status;\n\t}\n\n\tt->tx_buf += t->len;\n\tif (host->dma_dev)\n\t\tt->tx_dma += t->len;\n\n\t \n\tfor (i = 4; i < sizeof(scratch->status); i++) {\n\t\t \n\t\tif (scratch->status[i] & 0x01)\n\t\t\treturn 0;\n\t}\n\treturn mmc_spi_wait_unbusy(host, timeout);\n}\n\n \nstatic int\nmmc_spi_readblock(struct mmc_spi_host *host, struct spi_transfer *t,\n\tunsigned long timeout)\n{\n\tstruct spi_device\t*spi = host->spi;\n\tint\t\t\tstatus;\n\tstruct scratch\t\t*scratch = host->data;\n\tunsigned int \t\tbitshift;\n\tu8\t\t\tleftover;\n\n\t \n\tstatus = mmc_spi_readbytes(host, 1);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = scratch->status[0];\n\tif (status == 0xff || status == 0)\n\t\tstatus = mmc_spi_readtoken(host, timeout);\n\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"read error %02x (%d)\\n\", status, status);\n\t\treturn status;\n\t}\n\n\t \n\tbitshift = 7;\n\twhile (status & 0x80) {\n\t\tstatus <<= 1;\n\t\tbitshift--;\n\t}\n\tleftover = status << 1;\n\n\tif (host->dma_dev) {\n\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\tt->rx_dma, t->len,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tstatus = spi_sync_locked(spi, &host->m);\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"read error %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tif (host->dma_dev) {\n\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\tt->rx_dma, t->len,\n\t\t\t\tDMA_FROM_DEVICE);\n\t}\n\n\tif (bitshift) {\n\t\t \n\t\tu8 *cp = t->rx_buf;\n\t\tunsigned int len;\n\t\tunsigned int bitright = 8 - bitshift;\n\t\tu8 temp;\n\t\tfor (len = t->len; len; len--) {\n\t\t\ttemp = *cp;\n\t\t\t*cp++ = leftover | (temp >> bitshift);\n\t\t\tleftover = temp << bitright;\n\t\t}\n\t\tcp = (u8 *) &scratch->crc_val;\n\t\ttemp = *cp;\n\t\t*cp++ = leftover | (temp >> bitshift);\n\t\tleftover = temp << bitright;\n\t\ttemp = *cp;\n\t\t*cp = leftover | (temp >> bitshift);\n\t}\n\n\tif (host->mmc->use_spi_crc) {\n\t\tu16 crc = crc_itu_t(0, t->rx_buf, t->len);\n\n\t\tbe16_to_cpus(&scratch->crc_val);\n\t\tif (scratch->crc_val != crc) {\n\t\t\tdev_dbg(&spi->dev,\n\t\t\t\t\"read - crc error: crc_val=0x%04x, computed=0x%04x len=%d\\n\",\n\t\t\t\tscratch->crc_val, crc, t->len);\n\t\t\treturn -EILSEQ;\n\t\t}\n\t}\n\n\tt->rx_buf += t->len;\n\tif (host->dma_dev)\n\t\tt->rx_dma += t->len;\n\n\treturn 0;\n}\n\n \nstatic void\nmmc_spi_data_do(struct mmc_spi_host *host, struct mmc_command *cmd,\n\t\tstruct mmc_data *data, u32 blk_size)\n{\n\tstruct spi_device\t*spi = host->spi;\n\tstruct device\t\t*dma_dev = host->dma_dev;\n\tstruct spi_transfer\t*t;\n\tenum dma_data_direction\tdirection = mmc_get_dma_dir(data);\n\tstruct scatterlist\t*sg;\n\tunsigned\t\tn_sg;\n\tbool\t\t\tmultiple = (data->blocks > 1);\n\tconst char\t\t*write_or_read = (direction == DMA_TO_DEVICE) ? \"write\" : \"read\";\n\tu32\t\t\tclock_rate;\n\tunsigned long\t\ttimeout;\n\n\tmmc_spi_setup_data_message(host, multiple, direction);\n\tt = &host->t;\n\n\tif (t->speed_hz)\n\t\tclock_rate = t->speed_hz;\n\telse\n\t\tclock_rate = spi->max_speed_hz;\n\n\ttimeout = data->timeout_ns / 1000 +\n\t\t  data->timeout_clks * 1000000 / clock_rate;\n\ttimeout = usecs_to_jiffies((unsigned int)timeout) + 1;\n\n\t \n\tfor_each_sg(data->sg, sg, data->sg_len, n_sg) {\n\t\tint\t\t\tstatus = 0;\n\t\tdma_addr_t\t\tdma_addr = 0;\n\t\tvoid\t\t\t*kmap_addr;\n\t\tunsigned\t\tlength = sg->length;\n\t\tenum dma_data_direction\tdir = direction;\n\n\t\t \n\t\tif (dma_dev) {\n\t\t\t \n\t\t\tif ((sg->offset != 0 || length != PAGE_SIZE)\n\t\t\t\t\t&& dir == DMA_FROM_DEVICE)\n\t\t\t\tdir = DMA_BIDIRECTIONAL;\n\n\t\t\tdma_addr = dma_map_page(dma_dev, sg_page(sg), 0,\n\t\t\t\t\t\tPAGE_SIZE, dir);\n\t\t\tif (dma_mapping_error(dma_dev, dma_addr)) {\n\t\t\t\tdata->error = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (direction == DMA_TO_DEVICE)\n\t\t\t\tt->tx_dma = dma_addr + sg->offset;\n\t\t\telse\n\t\t\t\tt->rx_dma = dma_addr + sg->offset;\n\t\t}\n\n\t\t \n\t\tkmap_addr = kmap(sg_page(sg));\n\t\tif (direction == DMA_TO_DEVICE)\n\t\t\tt->tx_buf = kmap_addr + sg->offset;\n\t\telse\n\t\t\tt->rx_buf = kmap_addr + sg->offset;\n\n\t\t \n\t\twhile (length) {\n\t\t\tt->len = min(length, blk_size);\n\n\t\t\tdev_dbg(&spi->dev, \"    %s block, %d bytes\\n\", write_or_read, t->len);\n\n\t\t\tif (direction == DMA_TO_DEVICE)\n\t\t\t\tstatus = mmc_spi_writeblock(host, t, timeout);\n\t\t\telse\n\t\t\t\tstatus = mmc_spi_readblock(host, t, timeout);\n\t\t\tif (status < 0)\n\t\t\t\tbreak;\n\n\t\t\tdata->bytes_xfered += t->len;\n\t\t\tlength -= t->len;\n\n\t\t\tif (!multiple)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (direction == DMA_FROM_DEVICE)\n\t\t\tflush_dcache_page(sg_page(sg));\n\t\tkunmap(sg_page(sg));\n\t\tif (dma_dev)\n\t\t\tdma_unmap_page(dma_dev, dma_addr, PAGE_SIZE, dir);\n\n\t\tif (status < 0) {\n\t\t\tdata->error = status;\n\t\t\tdev_dbg(&spi->dev, \"%s status %d\\n\", write_or_read, status);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (direction == DMA_TO_DEVICE && multiple) {\n\t\tstruct scratch\t*scratch = host->data;\n\t\tint\t\ttmp;\n\t\tconst unsigned\tstatlen = sizeof(scratch->status);\n\n\t\tdev_dbg(&spi->dev, \"    STOP_TRAN\\n\");\n\n\t\t \n\t\tINIT_LIST_HEAD(&host->m.transfers);\n\t\tlist_add(&host->early_status.transfer_list,\n\t\t\t\t&host->m.transfers);\n\n\t\tmemset(scratch->status, 0xff, statlen);\n\t\tscratch->status[0] = SPI_TOKEN_STOP_TRAN;\n\n\t\thost->early_status.tx_buf = host->early_status.rx_buf;\n\t\thost->early_status.tx_dma = host->early_status.rx_dma;\n\t\thost->early_status.len = statlen;\n\n\t\tif (host->dma_dev)\n\t\t\tdma_sync_single_for_device(host->dma_dev,\n\t\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\n\t\ttmp = spi_sync_locked(spi, &host->m);\n\n\t\tif (host->dma_dev)\n\t\t\tdma_sync_single_for_cpu(host->dma_dev,\n\t\t\t\t\thost->data_dma, sizeof(*scratch),\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\n\t\tif (tmp < 0) {\n\t\t\tif (!data->error)\n\t\t\t\tdata->error = tmp;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tfor (tmp = 2; tmp < statlen; tmp++) {\n\t\t\tif (scratch->status[tmp] != 0)\n\t\t\t\treturn;\n\t\t}\n\t\ttmp = mmc_spi_wait_unbusy(host, timeout);\n\t\tif (tmp < 0 && !data->error)\n\t\t\tdata->error = tmp;\n\t}\n}\n\n \n\n \n\nstatic void mmc_spi_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_spi_host\t*host = mmc_priv(mmc);\n\tint\t\t\tstatus = -EINVAL;\n\tint\t\t\tcrc_retry = 5;\n\tstruct mmc_command\tstop;\n\n#ifdef DEBUG\n\t \n\t{\n\t\tstruct mmc_command\t*cmd;\n\t\tint\t\t\tinvalid = 0;\n\n\t\tcmd = mrq->cmd;\n\t\tif (!mmc_spi_resp_type(cmd)) {\n\t\t\tdev_dbg(&host->spi->dev, \"bogus command\\n\");\n\t\t\tcmd->error = -EINVAL;\n\t\t\tinvalid = 1;\n\t\t}\n\n\t\tcmd = mrq->stop;\n\t\tif (cmd && !mmc_spi_resp_type(cmd)) {\n\t\t\tdev_dbg(&host->spi->dev, \"bogus STOP command\\n\");\n\t\t\tcmd->error = -EINVAL;\n\t\t\tinvalid = 1;\n\t\t}\n\n\t\tif (invalid) {\n\t\t\tdump_stack();\n\t\t\tmmc_request_done(host->mmc, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n#endif\n\n\t \n\tspi_bus_lock(host->spi->master);\n\ncrc_recover:\n\t \n\tstatus = mmc_spi_command_send(host, mrq, mrq->cmd, mrq->data != NULL);\n\tif (status == 0 && mrq->data) {\n\t\tmmc_spi_data_do(host, mrq->cmd, mrq->data, mrq->data->blksz);\n\n\t\t \n\t\tif (mrq->data->error == -EILSEQ && crc_retry) {\n\t\t\tstop.opcode = MMC_STOP_TRANSMISSION;\n\t\t\tstop.arg = 0;\n\t\t\tstop.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;\n\t\t\tstatus = mmc_spi_command_send(host, mrq, &stop, 0);\n\t\t\tcrc_retry--;\n\t\t\tmrq->data->error = 0;\n\t\t\tgoto crc_recover;\n\t\t}\n\n\t\tif (mrq->stop)\n\t\t\tstatus = mmc_spi_command_send(host, mrq, mrq->stop, 0);\n\t\telse\n\t\t\tmmc_cs_off(host);\n\t}\n\n\t \n\tspi_bus_unlock(host->spi->master);\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\n \nstatic void mmc_spi_initsequence(struct mmc_spi_host *host)\n{\n\t \n\tmmc_spi_wait_unbusy(host, msecs_to_jiffies(MMC_SPI_INIT_TIMEOUT_MS));\n\tmmc_spi_readbytes(host, 10);\n\n\t \n\thost->spi->mode ^= SPI_CS_HIGH;\n\tif (spi_setup(host->spi) != 0) {\n\t\t \n\t\tdev_warn(&host->spi->dev,\n\t\t\t\t\"can't change chip-select polarity\\n\");\n\t\thost->spi->mode ^= SPI_CS_HIGH;\n\t} else {\n\t\tmmc_spi_readbytes(host, 18);\n\n\t\thost->spi->mode ^= SPI_CS_HIGH;\n\t\tif (spi_setup(host->spi) != 0) {\n\t\t\t \n\t\t\tdev_err(&host->spi->dev,\n\t\t\t\t\t\"can't restore chip-select polarity\\n\");\n\t\t}\n\t}\n}\n\nstatic char *mmc_powerstring(u8 power_mode)\n{\n\tswitch (power_mode) {\n\tcase MMC_POWER_OFF: return \"off\";\n\tcase MMC_POWER_UP:  return \"up\";\n\tcase MMC_POWER_ON:  return \"on\";\n\t}\n\treturn \"?\";\n}\n\nstatic void mmc_spi_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmc_spi_host *host = mmc_priv(mmc);\n\n\tif (host->power_mode != ios->power_mode) {\n\t\tint\t\tcanpower;\n\n\t\tcanpower = host->pdata && host->pdata->setpower;\n\n\t\tdev_dbg(&host->spi->dev, \"power %s (%d)%s\\n\",\n\t\t\t\tmmc_powerstring(ios->power_mode),\n\t\t\t\tios->vdd,\n\t\t\t\tcanpower ? \", can switch\" : \"\");\n\n\t\t \n\t\tif (canpower) {\n\t\t\tswitch (ios->power_mode) {\n\t\t\tcase MMC_POWER_OFF:\n\t\t\tcase MMC_POWER_UP:\n\t\t\t\thost->pdata->setpower(&host->spi->dev,\n\t\t\t\t\t\tios->vdd);\n\t\t\t\tif (ios->power_mode == MMC_POWER_UP)\n\t\t\t\t\tmsleep(host->powerup_msecs);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ios->power_mode == MMC_POWER_ON)\n\t\t\tmmc_spi_initsequence(host);\n\n\t\t \n\t\tif (canpower && ios->power_mode == MMC_POWER_OFF) {\n\t\t\tint mres;\n\t\t\tu8 nullbyte = 0;\n\n\t\t\thost->spi->mode &= ~(SPI_CPOL|SPI_CPHA);\n\t\t\tmres = spi_setup(host->spi);\n\t\t\tif (mres < 0)\n\t\t\t\tdev_dbg(&host->spi->dev,\n\t\t\t\t\t\"switch to SPI mode 0 failed\\n\");\n\n\t\t\tif (spi_write(host->spi, &nullbyte, 1) < 0)\n\t\t\t\tdev_dbg(&host->spi->dev,\n\t\t\t\t\t\"put spi signals to low failed\\n\");\n\n\t\t\t \n\t\t\tmsleep(10);\n\t\t\tif (mres == 0) {\n\t\t\t\thost->spi->mode |= (SPI_CPOL|SPI_CPHA);\n\t\t\t\tmres = spi_setup(host->spi);\n\t\t\t\tif (mres < 0)\n\t\t\t\t\tdev_dbg(&host->spi->dev,\n\t\t\t\t\t\t\"switch back to SPI mode 3 failed\\n\");\n\t\t\t}\n\t\t}\n\n\t\thost->power_mode = ios->power_mode;\n\t}\n\n\tif (host->spi->max_speed_hz != ios->clock && ios->clock != 0) {\n\t\tint\t\tstatus;\n\n\t\thost->spi->max_speed_hz = ios->clock;\n\t\tstatus = spi_setup(host->spi);\n\t\tdev_dbg(&host->spi->dev, \"  clock to %d Hz, %d\\n\",\n\t\t\thost->spi->max_speed_hz, status);\n\t}\n}\n\nstatic const struct mmc_host_ops mmc_spi_ops = {\n\t.request\t= mmc_spi_request,\n\t.set_ios\t= mmc_spi_set_ios,\n\t.get_ro\t\t= mmc_gpio_get_ro,\n\t.get_cd\t\t= mmc_gpio_get_cd,\n};\n\n\n \n\n \n\nstatic irqreturn_t\nmmc_spi_detect_irq(int irq, void *mmc)\n{\n\tstruct mmc_spi_host *host = mmc_priv(mmc);\n\tu16 delay_msec = max(host->pdata->detect_delay, (u16)100);\n\n\tmmc_detect_change(mmc, msecs_to_jiffies(delay_msec));\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_HAS_DMA\nstatic int mmc_spi_dma_alloc(struct mmc_spi_host *host)\n{\n\tstruct spi_device *spi = host->spi;\n\tstruct device *dev;\n\n\tif (!spi->master->dev.parent->dma_mask)\n\t\treturn 0;\n\n\tdev = spi->master->dev.parent;\n\n\thost->ones_dma = dma_map_single(dev, host->ones, MMC_SPI_BLOCKSIZE,\n\t\t\t\t\tDMA_TO_DEVICE);\n\tif (dma_mapping_error(dev, host->ones_dma))\n\t\treturn -ENOMEM;\n\n\thost->data_dma = dma_map_single(dev, host->data, sizeof(*host->data),\n\t\t\t\t\tDMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(dev, host->data_dma)) {\n\t\tdma_unmap_single(dev, host->ones_dma, MMC_SPI_BLOCKSIZE,\n\t\t\t\t DMA_TO_DEVICE);\n\t\treturn -ENOMEM;\n\t}\n\n\tdma_sync_single_for_cpu(dev, host->data_dma, sizeof(*host->data),\n\t\t\t\tDMA_BIDIRECTIONAL);\n\n\thost->dma_dev = dev;\n\treturn 0;\n}\n\nstatic void mmc_spi_dma_free(struct mmc_spi_host *host)\n{\n\tif (!host->dma_dev)\n\t\treturn;\n\n\tdma_unmap_single(host->dma_dev, host->ones_dma, MMC_SPI_BLOCKSIZE,\n\t\t\t DMA_TO_DEVICE);\n\tdma_unmap_single(host->dma_dev, host->data_dma,\tsizeof(*host->data),\n\t\t\t DMA_BIDIRECTIONAL);\n}\n#else\nstatic inline int mmc_spi_dma_alloc(struct mmc_spi_host *host) { return 0; }\nstatic inline void mmc_spi_dma_free(struct mmc_spi_host *host) {}\n#endif\n\nstatic int mmc_spi_probe(struct spi_device *spi)\n{\n\tvoid\t\t\t*ones;\n\tstruct mmc_host\t\t*mmc;\n\tstruct mmc_spi_host\t*host;\n\tint\t\t\tstatus;\n\tbool\t\t\thas_ro = false;\n\n\t \n\tif (spi->master->flags & SPI_MASTER_HALF_DUPLEX)\n\t\treturn -EINVAL;\n\n\t \n\tif (spi->mode != SPI_MODE_3)\n\t\tspi->mode = SPI_MODE_0;\n\tspi->bits_per_word = 8;\n\n\tstatus = spi_setup(spi);\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"needs SPI mode %02x, %d KHz; %d\\n\",\n\t\t\t\tspi->mode, spi->max_speed_hz / 1000,\n\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = -ENOMEM;\n\tones = kmalloc(MMC_SPI_BLOCKSIZE, GFP_KERNEL);\n\tif (!ones)\n\t\tgoto nomem;\n\tmemset(ones, 0xff, MMC_SPI_BLOCKSIZE);\n\n\tmmc = mmc_alloc_host(sizeof(*host), &spi->dev);\n\tif (!mmc)\n\t\tgoto nomem;\n\n\tmmc->ops = &mmc_spi_ops;\n\tmmc->max_blk_size = MMC_SPI_BLOCKSIZE;\n\tmmc->max_segs = MMC_SPI_BLOCKSATONCE;\n\tmmc->max_req_size = MMC_SPI_BLOCKSATONCE * MMC_SPI_BLOCKSIZE;\n\tmmc->max_blk_count = MMC_SPI_BLOCKSATONCE;\n\n\tmmc->caps = MMC_CAP_SPI;\n\n\t \n\tmmc->f_min = 400000;\n\tmmc->f_max = spi->max_speed_hz;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->spi = spi;\n\n\thost->ones = ones;\n\n\tdev_set_drvdata(&spi->dev, mmc);\n\n\t \n\thost->pdata = mmc_spi_get_pdata(spi);\n\tif (host->pdata)\n\t\tmmc->ocr_avail = host->pdata->ocr_mask;\n\tif (!mmc->ocr_avail) {\n\t\tdev_warn(&spi->dev, \"ASSUMING 3.2-3.4 V slot power\\n\");\n\t\tmmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;\n\t}\n\tif (host->pdata && host->pdata->setpower) {\n\t\thost->powerup_msecs = host->pdata->powerup_msecs;\n\t\tif (!host->powerup_msecs || host->powerup_msecs > 250)\n\t\t\thost->powerup_msecs = 250;\n\t}\n\n\t \n\thost->data = kmalloc(sizeof(*host->data), GFP_KERNEL);\n\tif (!host->data)\n\t\tgoto fail_nobuf1;\n\n\tstatus = mmc_spi_dma_alloc(host);\n\tif (status)\n\t\tgoto fail_dma;\n\n\t \n\tspi_message_init(&host->readback);\n\thost->readback.is_dma_mapped = (host->dma_dev != NULL);\n\n\tspi_message_add_tail(&host->status, &host->readback);\n\thost->status.tx_buf = host->ones;\n\thost->status.tx_dma = host->ones_dma;\n\thost->status.rx_buf = &host->data->status;\n\thost->status.rx_dma = host->data_dma + offsetof(struct scratch, status);\n\thost->status.cs_change = 1;\n\n\t \n\tif (host->pdata && host->pdata->init) {\n\t\tstatus = host->pdata->init(&spi->dev, mmc_spi_detect_irq, mmc);\n\t\tif (status != 0)\n\t\t\tgoto fail_glue_init;\n\t}\n\n\t \n\tif (host->pdata) {\n\t\tmmc->caps |= host->pdata->caps;\n\t\tmmc->caps2 |= host->pdata->caps2;\n\t}\n\n\tstatus = mmc_add_host(mmc);\n\tif (status != 0)\n\t\tgoto fail_glue_init;\n\n\t \n\tstatus = mmc_gpiod_request_cd(mmc, NULL, 0, false, 1000);\n\tif (status == -EPROBE_DEFER)\n\t\tgoto fail_gpiod_request;\n\tif (!status) {\n\t\t \n\t\tmmc->caps &= ~MMC_CAP_NEEDS_POLL;\n\t\tmmc_gpiod_request_cd_irq(mmc);\n\t}\n\tmmc_detect_change(mmc, 0);\n\n\t \n\tstatus = mmc_gpiod_request_ro(mmc, NULL, 1, 0);\n\tif (status == -EPROBE_DEFER)\n\t\tgoto fail_gpiod_request;\n\tif (!status)\n\t\thas_ro = true;\n\n\tdev_info(&spi->dev, \"SD/MMC host %s%s%s%s%s\\n\",\n\t\t\tdev_name(&mmc->class_dev),\n\t\t\thost->dma_dev ? \"\" : \", no DMA\",\n\t\t\thas_ro ? \"\" : \", no WP\",\n\t\t\t(host->pdata && host->pdata->setpower)\n\t\t\t\t? \"\" : \", no poweroff\",\n\t\t\t(mmc->caps & MMC_CAP_NEEDS_POLL)\n\t\t\t\t? \", cd polling\" : \"\");\n\treturn 0;\n\nfail_gpiod_request:\n\tmmc_remove_host(mmc);\nfail_glue_init:\n\tmmc_spi_dma_free(host);\nfail_dma:\n\tkfree(host->data);\nfail_nobuf1:\n\tmmc_spi_put_pdata(spi);\n\tmmc_free_host(mmc);\nnomem:\n\tkfree(ones);\n\treturn status;\n}\n\n\nstatic void mmc_spi_remove(struct spi_device *spi)\n{\n\tstruct mmc_host\t\t*mmc = dev_get_drvdata(&spi->dev);\n\tstruct mmc_spi_host\t*host = mmc_priv(mmc);\n\n\t \n\tif (host->pdata && host->pdata->exit)\n\t\thost->pdata->exit(&spi->dev, mmc);\n\n\tmmc_remove_host(mmc);\n\n\tmmc_spi_dma_free(host);\n\tkfree(host->data);\n\tkfree(host->ones);\n\n\tspi->max_speed_hz = mmc->f_max;\n\tmmc_spi_put_pdata(spi);\n\tmmc_free_host(mmc);\n}\n\nstatic const struct spi_device_id mmc_spi_dev_ids[] = {\n\t{ \"mmc-spi-slot\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(spi, mmc_spi_dev_ids);\n\nstatic const struct of_device_id mmc_spi_of_match_table[] = {\n\t{ .compatible = \"mmc-spi-slot\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mmc_spi_of_match_table);\n\nstatic struct spi_driver mmc_spi_driver = {\n\t.driver = {\n\t\t.name =\t\t\"mmc_spi\",\n\t\t.of_match_table = mmc_spi_of_match_table,\n\t},\n\t.id_table =\tmmc_spi_dev_ids,\n\t.probe =\tmmc_spi_probe,\n\t.remove =\tmmc_spi_remove,\n};\n\nmodule_spi_driver(mmc_spi_driver);\n\nMODULE_AUTHOR(\"Mike Lavender, David Brownell, Hans-Peter Nilsson, Jan Nikitenko\");\nMODULE_DESCRIPTION(\"SPI SD/MMC host driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:mmc_spi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}