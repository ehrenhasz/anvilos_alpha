{
  "module_name": "au1xmmc.c",
  "hash_id": "e86cf3365f3d0c17acfbb46a4eebf7adfc0fb64f396d9d539eead54cadd2f11f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/au1xmmc.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/mm.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/highmem.h>\n#include <linux/leds.h>\n#include <linux/mmc/host.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <asm/mach-au1x00/au1000.h>\n#include <asm/mach-au1x00/au1xxx_dbdma.h>\n#include <asm/mach-au1x00/au1100_mmc.h>\n\n#define DRIVER_NAME \"au1xxx-mmc\"\n\n \n \n\n#ifdef DEBUG\n#define DBG(fmt, idx, args...)\t\\\n\tpr_debug(\"au1xmmc(%d): DEBUG: \" fmt, idx, ##args)\n#else\n#define DBG(fmt, idx, args...) do {} while (0)\n#endif\n\n \n#define AU1XMMC_DESCRIPTOR_COUNT 1\n\n \n#define AU1100_MMC_DESCRIPTOR_SIZE 0x0000ffff\n#define AU1200_MMC_DESCRIPTOR_SIZE 0x003fffff\n\n#define AU1XMMC_OCR (MMC_VDD_27_28 | MMC_VDD_28_29 | MMC_VDD_29_30 | \\\n\t\t     MMC_VDD_30_31 | MMC_VDD_31_32 | MMC_VDD_32_33 | \\\n\t\t     MMC_VDD_33_34 | MMC_VDD_34_35 | MMC_VDD_35_36)\n\n \n#define STOP_CMD\t\\\n\t(SD_CMD_RT_1B | SD_CMD_CT_7 | (0xC << SD_CMD_CI_SHIFT) | SD_CMD_GO)\n\n \n#define AU1XMMC_INTERRUPTS \t\t\t\t\\\n\t(SD_CONFIG_SC | SD_CONFIG_DT | SD_CONFIG_RAT |\t\\\n\t SD_CONFIG_CR | SD_CONFIG_I)\n\n \n#define AU1XMMC_DETECT_TIMEOUT (HZ/2)\n\nstruct au1xmmc_host {\n\tstruct mmc_host *mmc;\n\tstruct mmc_request *mrq;\n\n\tu32 flags;\n\tvoid __iomem *iobase;\n\tu32 clock;\n\tu32 bus_width;\n\tu32 power_mode;\n\n\tint status;\n\n\tstruct {\n\t\tint len;\n\t\tint dir;\n\t} dma;\n\n\tstruct {\n\t\tint index;\n\t\tint offset;\n\t\tint len;\n\t} pio;\n\n\tu32 tx_chan;\n\tu32 rx_chan;\n\n\tint irq;\n\n\tstruct tasklet_struct finish_task;\n\tstruct tasklet_struct data_task;\n\tstruct au1xmmc_platform_data *platdata;\n\tstruct platform_device *pdev;\n\tstruct resource *ioarea;\n\tstruct clk *clk;\n};\n\n \n#define HOST_F_XMIT\t0x0001\n#define HOST_F_RECV\t0x0002\n#define HOST_F_DMA\t0x0010\n#define HOST_F_DBDMA\t0x0020\n#define HOST_F_ACTIVE\t0x0100\n#define HOST_F_STOP\t0x1000\n\n#define HOST_S_IDLE\t0x0001\n#define HOST_S_CMD\t0x0002\n#define HOST_S_DATA\t0x0003\n#define HOST_S_STOP\t0x0004\n\n \n#define HOST_STATUS(h)\t((h)->iobase + SD_STATUS)\n#define HOST_CONFIG(h)\t((h)->iobase + SD_CONFIG)\n#define HOST_ENABLE(h)\t((h)->iobase + SD_ENABLE)\n#define HOST_TXPORT(h)\t((h)->iobase + SD_TXPORT)\n#define HOST_RXPORT(h)\t((h)->iobase + SD_RXPORT)\n#define HOST_CMDARG(h)\t((h)->iobase + SD_CMDARG)\n#define HOST_BLKSIZE(h)\t((h)->iobase + SD_BLKSIZE)\n#define HOST_CMD(h)\t((h)->iobase + SD_CMD)\n#define HOST_CONFIG2(h)\t((h)->iobase + SD_CONFIG2)\n#define HOST_TIMEOUT(h)\t((h)->iobase + SD_TIMEOUT)\n#define HOST_DEBUG(h)\t((h)->iobase + SD_DEBUG)\n\n#define DMA_CHANNEL(h)\t\\\n\t(((h)->flags & HOST_F_XMIT) ? (h)->tx_chan : (h)->rx_chan)\n\nstatic inline int has_dbdma(void)\n{\n\tswitch (alchemy_get_cputype()) {\n\tcase ALCHEMY_CPU_AU1200:\n\tcase ALCHEMY_CPU_AU1300:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic inline void IRQ_ON(struct au1xmmc_host *host, u32 mask)\n{\n\tu32 val = __raw_readl(HOST_CONFIG(host));\n\tval |= mask;\n\t__raw_writel(val, HOST_CONFIG(host));\n\twmb();  \n}\n\nstatic inline void FLUSH_FIFO(struct au1xmmc_host *host)\n{\n\tu32 val = __raw_readl(HOST_CONFIG2(host));\n\n\t__raw_writel(val | SD_CONFIG2_FF, HOST_CONFIG2(host));\n\twmb();  \n\tmdelay(1);\n\n\t \n\tval &= ~SD_CONFIG2_DF;\n\n\t__raw_writel(val, HOST_CONFIG2(host));\n\twmb();  \n}\n\nstatic inline void IRQ_OFF(struct au1xmmc_host *host, u32 mask)\n{\n\tu32 val = __raw_readl(HOST_CONFIG(host));\n\tval &= ~mask;\n\t__raw_writel(val, HOST_CONFIG(host));\n\twmb();  \n}\n\nstatic inline void SEND_STOP(struct au1xmmc_host *host)\n{\n\tu32 config2;\n\n\tWARN_ON(host->status != HOST_S_DATA);\n\thost->status = HOST_S_STOP;\n\n\tconfig2 = __raw_readl(HOST_CONFIG2(host));\n\t__raw_writel(config2 | SD_CONFIG2_DF, HOST_CONFIG2(host));\n\twmb();  \n\n\t \n\t__raw_writel(STOP_CMD, HOST_CMD(host));\n\twmb();  \n}\n\nstatic void au1xmmc_set_power(struct au1xmmc_host *host, int state)\n{\n\tif (host->platdata && host->platdata->set_power)\n\t\thost->platdata->set_power(host->mmc, state);\n}\n\nstatic int au1xmmc_card_inserted(struct mmc_host *mmc)\n{\n\tstruct au1xmmc_host *host = mmc_priv(mmc);\n\n\tif (host->platdata && host->platdata->card_inserted)\n\t\treturn !!host->platdata->card_inserted(host->mmc);\n\n\treturn -ENOSYS;\n}\n\nstatic int au1xmmc_card_readonly(struct mmc_host *mmc)\n{\n\tstruct au1xmmc_host *host = mmc_priv(mmc);\n\n\tif (host->platdata && host->platdata->card_readonly)\n\t\treturn !!host->platdata->card_readonly(mmc);\n\n\treturn -ENOSYS;\n}\n\nstatic void au1xmmc_finish_request(struct au1xmmc_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\n\thost->mrq = NULL;\n\thost->flags &= HOST_F_ACTIVE | HOST_F_DMA;\n\n\thost->dma.len = 0;\n\thost->dma.dir = 0;\n\n\thost->pio.index  = 0;\n\thost->pio.offset = 0;\n\thost->pio.len = 0;\n\n\thost->status = HOST_S_IDLE;\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void au1xmmc_tasklet_finish(struct tasklet_struct *t)\n{\n\tstruct au1xmmc_host *host = from_tasklet(host, t, finish_task);\n\tau1xmmc_finish_request(host);\n}\n\nstatic int au1xmmc_send_command(struct au1xmmc_host *host,\n\t\t\t\tstruct mmc_command *cmd, struct mmc_data *data)\n{\n\tu32 mmccmd = (cmd->opcode << SD_CMD_CI_SHIFT);\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\t\tmmccmd |= SD_CMD_RT_1;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tmmccmd |= SD_CMD_RT_1B;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tmmccmd |= SD_CMD_RT_2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tmmccmd |= SD_CMD_RT_3;\n\t\tbreak;\n\tdefault:\n\t\tpr_info(\"au1xmmc: unhandled response type %02x\\n\",\n\t\t\tmmc_resp_type(cmd));\n\t\treturn -EINVAL;\n\t}\n\n\tif (data) {\n\t\tif (data->flags & MMC_DATA_READ) {\n\t\t\tif (data->blocks > 1)\n\t\t\t\tmmccmd |= SD_CMD_CT_4;\n\t\t\telse\n\t\t\t\tmmccmd |= SD_CMD_CT_2;\n\t\t} else if (data->flags & MMC_DATA_WRITE) {\n\t\t\tif (data->blocks > 1)\n\t\t\t\tmmccmd |= SD_CMD_CT_3;\n\t\t\telse\n\t\t\t\tmmccmd |= SD_CMD_CT_1;\n\t\t}\n\t}\n\n\t__raw_writel(cmd->arg, HOST_CMDARG(host));\n\twmb();  \n\n\t__raw_writel((mmccmd | SD_CMD_GO), HOST_CMD(host));\n\twmb();  \n\n\t \n\twhile (__raw_readl(HOST_CMD(host)) & SD_CMD_GO)\n\t\t ;\n\n\treturn 0;\n}\n\nstatic void au1xmmc_data_complete(struct au1xmmc_host *host, u32 status)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_data *data;\n\tu32 crc;\n\n\tWARN_ON((host->status != HOST_S_DATA) && (host->status != HOST_S_STOP));\n\n\tif (host->mrq == NULL)\n\t\treturn;\n\n\tdata = mrq->cmd->data;\n\n\tif (status == 0)\n\t\tstatus = __raw_readl(HOST_STATUS(host));\n\n\t \n\twhile ((host->flags & HOST_F_XMIT) && (status & SD_STATUS_DB))\n\t\tstatus = __raw_readl(HOST_STATUS(host));\n\n\tdata->error = 0;\n\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, host->dma.dir);\n\n         \n\tcrc = (status & (SD_STATUS_WC | SD_STATUS_RC));\n\tif (host->flags & HOST_F_XMIT)\n\t\tcrc |= ((status & 0x07) == 0x02) ? 0 : 1;\n\n\tif (crc)\n\t\tdata->error = -EILSEQ;\n\n\t \n\t__raw_writel(SD_STATUS_WC | SD_STATUS_RC, HOST_STATUS(host));\n\n\tdata->bytes_xfered = 0;\n\n\tif (!data->error) {\n\t\tif (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {\n\t\t\tu32 chan = DMA_CHANNEL(host);\n\n\t\t\tchan_tab_t *c = *((chan_tab_t **)chan);\n\t\t\tau1x_dma_chan_t *cp = c->chan_ptr;\n\t\t\tdata->bytes_xfered = cp->ddma_bytecnt;\n\t\t} else\n\t\t\tdata->bytes_xfered =\n\t\t\t\t(data->blocks * data->blksz) - host->pio.len;\n\t}\n\n\tau1xmmc_finish_request(host);\n}\n\nstatic void au1xmmc_tasklet_data(struct tasklet_struct *t)\n{\n\tstruct au1xmmc_host *host = from_tasklet(host, t, data_task);\n\n\tu32 status = __raw_readl(HOST_STATUS(host));\n\tau1xmmc_data_complete(host, status);\n}\n\n#define AU1XMMC_MAX_TRANSFER 8\n\nstatic void au1xmmc_send_pio(struct au1xmmc_host *host)\n{\n\tstruct mmc_data *data;\n\tint sg_len, max, count;\n\tunsigned char *sg_ptr, val;\n\tu32 status;\n\tstruct scatterlist *sg;\n\n\tdata = host->mrq->data;\n\n\tif (!(host->flags & HOST_F_XMIT))\n\t\treturn;\n\n\t \n\tsg = &data->sg[host->pio.index];\n\tsg_ptr = kmap_local_page(sg_page(sg)) + sg->offset + host->pio.offset;\n\n\t \n\tsg_len = data->sg[host->pio.index].length - host->pio.offset;\n\n\t \n\tmax = (sg_len > host->pio.len) ? host->pio.len : sg_len;\n\tif (max > AU1XMMC_MAX_TRANSFER)\n\t\tmax = AU1XMMC_MAX_TRANSFER;\n\n\tfor (count = 0; count < max; count++) {\n\t\tstatus = __raw_readl(HOST_STATUS(host));\n\n\t\tif (!(status & SD_STATUS_TH))\n\t\t\tbreak;\n\n\t\tval = sg_ptr[count];\n\n\t\t__raw_writel((unsigned long)val, HOST_TXPORT(host));\n\t\twmb();  \n\t}\n\tkunmap_local(sg_ptr);\n\n\thost->pio.len -= count;\n\thost->pio.offset += count;\n\n\tif (count == sg_len) {\n\t\thost->pio.index++;\n\t\thost->pio.offset = 0;\n\t}\n\n\tif (host->pio.len == 0) {\n\t\tIRQ_OFF(host, SD_CONFIG_TH);\n\n\t\tif (host->flags & HOST_F_STOP)\n\t\t\tSEND_STOP(host);\n\n\t\ttasklet_schedule(&host->data_task);\n\t}\n}\n\nstatic void au1xmmc_receive_pio(struct au1xmmc_host *host)\n{\n\tstruct mmc_data *data;\n\tint max, count, sg_len = 0;\n\tunsigned char *sg_ptr = NULL;\n\tu32 status, val;\n\tstruct scatterlist *sg;\n\n\tdata = host->mrq->data;\n\n\tif (!(host->flags & HOST_F_RECV))\n\t\treturn;\n\n\tmax = host->pio.len;\n\n\tif (host->pio.index < host->dma.len) {\n\t\tsg = &data->sg[host->pio.index];\n\t\tsg_ptr = kmap_local_page(sg_page(sg)) + sg->offset + host->pio.offset;\n\n\t\t \n\t\tsg_len = sg_dma_len(&data->sg[host->pio.index]) - host->pio.offset;\n\n\t\t \n\t\tif (sg_len < max)\n\t\t\tmax = sg_len;\n\t}\n\n\tif (max > AU1XMMC_MAX_TRANSFER)\n\t\tmax = AU1XMMC_MAX_TRANSFER;\n\n\tfor (count = 0; count < max; count++) {\n\t\tstatus = __raw_readl(HOST_STATUS(host));\n\n\t\tif (!(status & SD_STATUS_NE))\n\t\t\tbreak;\n\n\t\tif (status & SD_STATUS_RC) {\n\t\t\tDBG(\"RX CRC Error [%d + %d].\\n\", host->pdev->id,\n\t\t\t\t\thost->pio.len, count);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (status & SD_STATUS_RO) {\n\t\t\tDBG(\"RX Overrun [%d + %d]\\n\", host->pdev->id,\n\t\t\t\t\thost->pio.len, count);\n\t\t\tbreak;\n\t\t}\n\t\telse if (status & SD_STATUS_RU) {\n\t\t\tDBG(\"RX Underrun [%d + %d]\\n\", host->pdev->id,\n\t\t\t\t\thost->pio.len,\tcount);\n\t\t\tbreak;\n\t\t}\n\n\t\tval = __raw_readl(HOST_RXPORT(host));\n\n\t\tif (sg_ptr)\n\t\t\tsg_ptr[count] = (unsigned char)(val & 0xFF);\n\t}\n\tif (sg_ptr)\n\t\tkunmap_local(sg_ptr);\n\n\thost->pio.len -= count;\n\thost->pio.offset += count;\n\n\tif (sg_len && count == sg_len) {\n\t\thost->pio.index++;\n\t\thost->pio.offset = 0;\n\t}\n\n\tif (host->pio.len == 0) {\n\t\t \n\t\tIRQ_OFF(host, SD_CONFIG_NE);\n\n\t\tif (host->flags & HOST_F_STOP)\n\t\t\tSEND_STOP(host);\n\n\t\ttasklet_schedule(&host->data_task);\n\t}\n}\n\n \nstatic void au1xmmc_cmd_complete(struct au1xmmc_host *host, u32 status)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_command *cmd;\n\tu32 r[4];\n\tint i, trans;\n\n\tif (!host->mrq)\n\t\treturn;\n\n\tcmd = mrq->cmd;\n\tcmd->error = 0;\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\tr[0] = __raw_readl(host->iobase + SD_RESP3);\n\t\t\tr[1] = __raw_readl(host->iobase + SD_RESP2);\n\t\t\tr[2] = __raw_readl(host->iobase + SD_RESP1);\n\t\t\tr[3] = __raw_readl(host->iobase + SD_RESP0);\n\n\t\t\t \n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tcmd->resp[i] = (r[i] & 0x00FFFFFF) << 8;\n\t\t\t\tif (i != 3)\n\t\t\t\t\tcmd->resp[i] |= (r[i + 1] & 0xFF000000) >> 24;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tcmd->resp[0] = __raw_readl(host->iobase + SD_RESP0);\n\t\t}\n\t}\n\n         \n\tif (status & (SD_STATUS_SC | SD_STATUS_WC | SD_STATUS_RC))\n\t\tcmd->error = -EILSEQ;\n\n\ttrans = host->flags & (HOST_F_XMIT | HOST_F_RECV);\n\n\tif (!trans || cmd->error) {\n\t\tIRQ_OFF(host, SD_CONFIG_TH | SD_CONFIG_RA | SD_CONFIG_RF);\n\t\ttasklet_schedule(&host->finish_task);\n\t\treturn;\n\t}\n\n\thost->status = HOST_S_DATA;\n\n\tif ((host->flags & (HOST_F_DMA | HOST_F_DBDMA))) {\n\t\tu32 channel = DMA_CHANNEL(host);\n\n\t\t \n\n\t\tif (host->flags & HOST_F_RECV) {\n\t\t\tu32 mask = SD_STATUS_DB | SD_STATUS_NE;\n\n\t\t\twhile((status & mask) != mask)\n\t\t\t\tstatus = __raw_readl(HOST_STATUS(host));\n\t\t}\n\n\t\tau1xxx_dbdma_start(channel);\n\t}\n}\n\nstatic void au1xmmc_set_clock(struct au1xmmc_host *host, int rate)\n{\n\tunsigned int pbus = clk_get_rate(host->clk);\n\tunsigned int divisor = ((pbus / rate) / 2) - 1;\n\tu32 config;\n\n\tconfig = __raw_readl(HOST_CONFIG(host));\n\n\tconfig &= ~(SD_CONFIG_DIV);\n\tconfig |= (divisor & SD_CONFIG_DIV) | SD_CONFIG_DE;\n\n\t__raw_writel(config, HOST_CONFIG(host));\n\twmb();  \n}\n\nstatic int au1xmmc_prepare_data(struct au1xmmc_host *host,\n\t\t\t\tstruct mmc_data *data)\n{\n\tint datalen = data->blocks * data->blksz;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\thost->flags |= HOST_F_RECV;\n\telse\n\t\thost->flags |= HOST_F_XMIT;\n\n\tif (host->mrq->stop)\n\t\thost->flags |= HOST_F_STOP;\n\n\thost->dma.dir = DMA_BIDIRECTIONAL;\n\n\thost->dma.len = dma_map_sg(mmc_dev(host->mmc), data->sg,\n\t\t\t\t   data->sg_len, host->dma.dir);\n\n\tif (host->dma.len == 0)\n\t\treturn -ETIMEDOUT;\n\n\t__raw_writel(data->blksz - 1, HOST_BLKSIZE(host));\n\n\tif (host->flags & (HOST_F_DMA | HOST_F_DBDMA)) {\n\t\tint i;\n\t\tu32 channel = DMA_CHANNEL(host);\n\n\t\tau1xxx_dbdma_stop(channel);\n\n\t\tfor (i = 0; i < host->dma.len; i++) {\n\t\t\tu32 ret = 0, flags = DDMA_FLAGS_NOIE;\n\t\t\tstruct scatterlist *sg = &data->sg[i];\n\t\t\tint sg_len = sg->length;\n\n\t\t\tint len = (datalen > sg_len) ? sg_len : datalen;\n\n\t\t\tif (i == host->dma.len - 1)\n\t\t\t\tflags = DDMA_FLAGS_IE;\n\n\t\t\tif (host->flags & HOST_F_XMIT) {\n\t\t\t\tret = au1xxx_dbdma_put_source(channel,\n\t\t\t\t\tsg_phys(sg), len, flags);\n\t\t\t} else {\n\t\t\t\tret = au1xxx_dbdma_put_dest(channel,\n\t\t\t\t\tsg_phys(sg), len, flags);\n\t\t\t}\n\n\t\t\tif (!ret)\n\t\t\t\tgoto dataerr;\n\n\t\t\tdatalen -= len;\n\t\t}\n\t} else {\n\t\thost->pio.index = 0;\n\t\thost->pio.offset = 0;\n\t\thost->pio.len = datalen;\n\n\t\tif (host->flags & HOST_F_XMIT)\n\t\t\tIRQ_ON(host, SD_CONFIG_TH);\n\t\telse\n\t\t\tIRQ_ON(host, SD_CONFIG_NE);\n\t\t\t \n\t}\n\n\treturn 0;\n\ndataerr:\n\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\thost->dma.dir);\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void au1xmmc_request(struct mmc_host* mmc, struct mmc_request* mrq)\n{\n\tstruct au1xmmc_host *host = mmc_priv(mmc);\n\tint ret = 0;\n\n\tWARN_ON(irqs_disabled());\n\tWARN_ON(host->status != HOST_S_IDLE);\n\n\thost->mrq = mrq;\n\thost->status = HOST_S_CMD;\n\n\t \n\tif (0 == au1xmmc_card_inserted(mmc)) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tau1xmmc_finish_request(host);\n\t\treturn;\n\t}\n\n\tif (mrq->data) {\n\t\tFLUSH_FIFO(host);\n\t\tret = au1xmmc_prepare_data(host, mrq->data);\n\t}\n\n\tif (!ret)\n\t\tret = au1xmmc_send_command(host, mrq->cmd, mrq->data);\n\n\tif (ret) {\n\t\tmrq->cmd->error = ret;\n\t\tau1xmmc_finish_request(host);\n\t}\n}\n\nstatic void au1xmmc_reset_controller(struct au1xmmc_host *host)\n{\n\t \n\t__raw_writel(SD_ENABLE_CE, HOST_ENABLE(host));\n\twmb();  \n\tmdelay(1);\n\n\t__raw_writel(SD_ENABLE_R | SD_ENABLE_CE, HOST_ENABLE(host));\n\twmb();  \n\tmdelay(5);\n\n\t__raw_writel(~0, HOST_STATUS(host));\n\twmb();  \n\n\t__raw_writel(0, HOST_BLKSIZE(host));\n\t__raw_writel(0x001fffff, HOST_TIMEOUT(host));\n\twmb();  \n\n\t__raw_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));\n\twmb();  \n\n\t__raw_writel(SD_CONFIG2_EN | SD_CONFIG2_FF, HOST_CONFIG2(host));\n\twmb();  \n\tmdelay(1);\n\n\t__raw_writel(SD_CONFIG2_EN, HOST_CONFIG2(host));\n\twmb();  \n\n\t \n\t__raw_writel(AU1XMMC_INTERRUPTS, HOST_CONFIG(host));\n\twmb();  \n}\n\n\nstatic void au1xmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct au1xmmc_host *host = mmc_priv(mmc);\n\tu32 config2;\n\n\tif (ios->power_mode == MMC_POWER_OFF)\n\t\tau1xmmc_set_power(host, 0);\n\telse if (ios->power_mode == MMC_POWER_ON) {\n\t\tau1xmmc_set_power(host, 1);\n\t}\n\n\tif (ios->clock && ios->clock != host->clock) {\n\t\tau1xmmc_set_clock(host, ios->clock);\n\t\thost->clock = ios->clock;\n\t}\n\n\tconfig2 = __raw_readl(HOST_CONFIG2(host));\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tconfig2 |= SD_CONFIG2_BB;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tconfig2 &= ~SD_CONFIG2_BB;\n\t\tconfig2 |= SD_CONFIG2_WB;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_1:\n\t\tconfig2 &= ~(SD_CONFIG2_WB | SD_CONFIG2_BB);\n\t\tbreak;\n\t}\n\t__raw_writel(config2, HOST_CONFIG2(host));\n\twmb();  \n}\n\n#define STATUS_TIMEOUT (SD_STATUS_RAT | SD_STATUS_DT)\n#define STATUS_DATA_IN  (SD_STATUS_NE)\n#define STATUS_DATA_OUT (SD_STATUS_TH)\n\nstatic irqreturn_t au1xmmc_irq(int irq, void *dev_id)\n{\n\tstruct au1xmmc_host *host = dev_id;\n\tu32 status;\n\n\tstatus = __raw_readl(HOST_STATUS(host));\n\n\tif (!(status & SD_STATUS_I))\n\t\treturn IRQ_NONE;\t \n\n\tif (status & SD_STATUS_SI)\t \n\t\tmmc_signal_sdio_irq(host->mmc);\n\n\tif (host->mrq && (status & STATUS_TIMEOUT)) {\n\t\tif (status & SD_STATUS_RAT)\n\t\t\thost->mrq->cmd->error = -ETIMEDOUT;\n\t\telse if (status & SD_STATUS_DT)\n\t\t\thost->mrq->data->error = -ETIMEDOUT;\n\n\t\t \n\t\tIRQ_OFF(host, SD_CONFIG_NE | SD_CONFIG_TH);\n\n\t\t \n\t\ttasklet_schedule(&host->finish_task);\n\t}\n#if 0\n\telse if (status & SD_STATUS_DD) {\n\t\t \n\t\tif (!(host->flags & HOST_F_DMA) && (status & SD_STATUS_NE))\n\t\t\tau1xmmc_receive_pio(host);\n\t\telse {\n\t\t\tau1xmmc_data_complete(host, status);\n\t\t\t \n\t\t}\n\t}\n#endif\n\telse if (status & SD_STATUS_CR) {\n\t\tif (host->status == HOST_S_CMD)\n\t\t\tau1xmmc_cmd_complete(host, status);\n\n\t} else if (!(host->flags & HOST_F_DMA)) {\n\t\tif ((host->flags & HOST_F_XMIT) && (status & STATUS_DATA_OUT))\n\t\t\tau1xmmc_send_pio(host);\n\t\telse if ((host->flags & HOST_F_RECV) && (status & STATUS_DATA_IN))\n\t\t\tau1xmmc_receive_pio(host);\n\n\t} else if (status & 0x203F3C70) {\n\t\t\tDBG(\"Unhandled status %8.8x\\n\", host->pdev->id,\n\t\t\t\tstatus);\n\t}\n\n\t__raw_writel(status, HOST_STATUS(host));\n\twmb();  \n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic dbdev_tab_t au1xmmc_mem_dbdev = {\n\t.dev_id\t\t= DSCR_CMD0_ALWAYS,\n\t.dev_flags\t= DEV_FLAGS_ANYUSE,\n\t.dev_tsize\t= 0,\n\t.dev_devwidth\t= 8,\n\t.dev_physaddr\t= 0x00000000,\n\t.dev_intlevel\t= 0,\n\t.dev_intpolarity = 0,\n};\nstatic int memid;\n\nstatic void au1xmmc_dbdma_callback(int irq, void *dev_id)\n{\n\tstruct au1xmmc_host *host = (struct au1xmmc_host *)dev_id;\n\n\t \n\tif (!host->mrq)\n\t\treturn;\n\n\tif (host->flags & HOST_F_STOP)\n\t\tSEND_STOP(host);\n\n\ttasklet_schedule(&host->data_task);\n}\n\nstatic int au1xmmc_dbdma_init(struct au1xmmc_host *host)\n{\n\tstruct resource *res;\n\tint txid, rxid;\n\n\tres = platform_get_resource(host->pdev, IORESOURCE_DMA, 0);\n\tif (!res)\n\t\treturn -ENODEV;\n\ttxid = res->start;\n\n\tres = platform_get_resource(host->pdev, IORESOURCE_DMA, 1);\n\tif (!res)\n\t\treturn -ENODEV;\n\trxid = res->start;\n\n\tif (!memid)\n\t\treturn -ENODEV;\n\n\thost->tx_chan = au1xxx_dbdma_chan_alloc(memid, txid,\n\t\t\t\tau1xmmc_dbdma_callback, (void *)host);\n\tif (!host->tx_chan) {\n\t\tdev_err(&host->pdev->dev, \"cannot allocate TX DMA\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thost->rx_chan = au1xxx_dbdma_chan_alloc(rxid, memid,\n\t\t\t\tau1xmmc_dbdma_callback, (void *)host);\n\tif (!host->rx_chan) {\n\t\tdev_err(&host->pdev->dev, \"cannot allocate RX DMA\\n\");\n\t\tau1xxx_dbdma_chan_free(host->tx_chan);\n\t\treturn -ENODEV;\n\t}\n\n\tau1xxx_dbdma_set_devwidth(host->tx_chan, 8);\n\tau1xxx_dbdma_set_devwidth(host->rx_chan, 8);\n\n\tau1xxx_dbdma_ring_alloc(host->tx_chan, AU1XMMC_DESCRIPTOR_COUNT);\n\tau1xxx_dbdma_ring_alloc(host->rx_chan, AU1XMMC_DESCRIPTOR_COUNT);\n\n\t \n\thost->flags |= HOST_F_DMA | HOST_F_DBDMA;\n\n\treturn 0;\n}\n\nstatic void au1xmmc_dbdma_shutdown(struct au1xmmc_host *host)\n{\n\tif (host->flags & HOST_F_DMA) {\n\t\thost->flags &= ~HOST_F_DMA;\n\t\tau1xxx_dbdma_chan_free(host->tx_chan);\n\t\tau1xxx_dbdma_chan_free(host->rx_chan);\n\t}\n}\n\nstatic void au1xmmc_enable_sdio_irq(struct mmc_host *mmc, int en)\n{\n\tstruct au1xmmc_host *host = mmc_priv(mmc);\n\n\tif (en)\n\t\tIRQ_ON(host, SD_CONFIG_SI);\n\telse\n\t\tIRQ_OFF(host, SD_CONFIG_SI);\n}\n\nstatic const struct mmc_host_ops au1xmmc_ops = {\n\t.request\t= au1xmmc_request,\n\t.set_ios\t= au1xmmc_set_ios,\n\t.get_ro\t\t= au1xmmc_card_readonly,\n\t.get_cd\t\t= au1xmmc_card_inserted,\n\t.enable_sdio_irq = au1xmmc_enable_sdio_irq,\n};\n\nstatic int au1xmmc_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct au1xmmc_host *host;\n\tstruct resource *r;\n\tint ret, iflag;\n\n\tmmc = mmc_alloc_host(sizeof(struct au1xmmc_host), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"no memory for mmc_host\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out0;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->platdata = pdev->dev.platform_data;\n\thost->pdev = pdev;\n\n\tret = -ENODEV;\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r) {\n\t\tdev_err(&pdev->dev, \"no mmio defined\\n\");\n\t\tgoto out1;\n\t}\n\n\thost->ioarea = request_mem_region(r->start, resource_size(r),\n\t\t\t\t\t   pdev->name);\n\tif (!host->ioarea) {\n\t\tdev_err(&pdev->dev, \"mmio already in use\\n\");\n\t\tgoto out1;\n\t}\n\n\thost->iobase = ioremap(r->start, 0x3c);\n\tif (!host->iobase) {\n\t\tdev_err(&pdev->dev, \"cannot remap mmio\\n\");\n\t\tgoto out2;\n\t}\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto out3;\n\t}\n\n\tmmc->ops = &au1xmmc_ops;\n\n\tmmc->f_min =   450000;\n\tmmc->f_max = 24000000;\n\n\tmmc->max_blk_size = 2048;\n\tmmc->max_blk_count = 512;\n\n\tmmc->ocr_avail = AU1XMMC_OCR;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\n\tmmc->max_segs = AU1XMMC_DESCRIPTOR_COUNT;\n\n\tiflag = IRQF_SHARED;\t \n\n\tswitch (alchemy_get_cputype()) {\n\tcase ALCHEMY_CPU_AU1100:\n\t\tmmc->max_seg_size = AU1100_MMC_DESCRIPTOR_SIZE;\n\t\tbreak;\n\tcase ALCHEMY_CPU_AU1200:\n\t\tmmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;\n\t\tbreak;\n\tcase ALCHEMY_CPU_AU1300:\n\t\tiflag = 0;\t \n\t\tmmc->max_seg_size = AU1200_MMC_DESCRIPTOR_SIZE;\n\t\tmmc->f_max = 52000000;\n\t\tif (host->ioarea->start == AU1100_SD0_PHYS_ADDR)\n\t\t\tmmc->caps |= MMC_CAP_8_BIT_DATA;\n\t\tbreak;\n\t}\n\n\tret = request_irq(host->irq, au1xmmc_irq, iflag, DRIVER_NAME, host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot grab IRQ\\n\");\n\t\tgoto out3;\n\t}\n\n\thost->clk = clk_get(&pdev->dev, ALCHEMY_PERIPH_CLK);\n\tif (IS_ERR(host->clk)) {\n\t\tdev_err(&pdev->dev, \"cannot find clock\\n\");\n\t\tret = PTR_ERR(host->clk);\n\t\tgoto out_irq;\n\t}\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot enable clock\\n\");\n\t\tgoto out_clk;\n\t}\n\n\thost->status = HOST_S_IDLE;\n\n\t \n\tif (host->platdata && host->platdata->cd_setup) {\n\t\tret = host->platdata->cd_setup(mmc, 1);\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"board CD setup failed\\n\");\n\t\t\tmmc->caps |= MMC_CAP_NEEDS_POLL;\n\t\t}\n\t} else\n\t\tmmc->caps |= MMC_CAP_NEEDS_POLL;\n\n\t \n\tif (host->platdata)\n\t\tmmc->caps &= ~(host->platdata->mask_host_caps);\n\n\ttasklet_setup(&host->data_task, au1xmmc_tasklet_data);\n\n\ttasklet_setup(&host->finish_task, au1xmmc_tasklet_finish);\n\n\tif (has_dbdma()) {\n\t\tret = au1xmmc_dbdma_init(host);\n\t\tif (ret)\n\t\t\tpr_info(DRIVER_NAME \": DBDMA init failed; using PIO\\n\");\n\t}\n\n#ifdef CONFIG_LEDS_CLASS\n\tif (host->platdata && host->platdata->led) {\n\t\tstruct led_classdev *led = host->platdata->led;\n\t\tled->name = mmc_hostname(mmc);\n\t\tled->brightness = LED_OFF;\n\t\tled->default_trigger = mmc_hostname(mmc);\n\t\tret = led_classdev_register(mmc_dev(mmc), led);\n\t\tif (ret)\n\t\t\tgoto out5;\n\t}\n#endif\n\n\tau1xmmc_reset_controller(host);\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot add mmc host\\n\");\n\t\tgoto out6;\n\t}\n\n\tplatform_set_drvdata(pdev, host);\n\n\tpr_info(DRIVER_NAME \": MMC Controller %d set up at %p\"\n\t\t\" (mode=%s)\\n\", pdev->id, host->iobase,\n\t\thost->flags & HOST_F_DMA ? \"dma\" : \"pio\");\n\n\treturn 0;\t \n\nout6:\n#ifdef CONFIG_LEDS_CLASS\n\tif (host->platdata && host->platdata->led)\n\t\tled_classdev_unregister(host->platdata->led);\nout5:\n#endif\n\t__raw_writel(0, HOST_ENABLE(host));\n\t__raw_writel(0, HOST_CONFIG(host));\n\t__raw_writel(0, HOST_CONFIG2(host));\n\twmb();  \n\n\tif (host->flags & HOST_F_DBDMA)\n\t\tau1xmmc_dbdma_shutdown(host);\n\n\ttasklet_kill(&host->data_task);\n\ttasklet_kill(&host->finish_task);\n\n\tif (host->platdata && host->platdata->cd_setup &&\n\t    !(mmc->caps & MMC_CAP_NEEDS_POLL))\n\t\thost->platdata->cd_setup(mmc, 0);\n\n\tclk_disable_unprepare(host->clk);\nout_clk:\n\tclk_put(host->clk);\nout_irq:\n\tfree_irq(host->irq, host);\nout3:\n\tiounmap((void *)host->iobase);\nout2:\n\trelease_resource(host->ioarea);\n\tkfree(host->ioarea);\nout1:\n\tmmc_free_host(mmc);\nout0:\n\treturn ret;\n}\n\nstatic void au1xmmc_remove(struct platform_device *pdev)\n{\n\tstruct au1xmmc_host *host = platform_get_drvdata(pdev);\n\n\tif (host) {\n\t\tmmc_remove_host(host->mmc);\n\n#ifdef CONFIG_LEDS_CLASS\n\t\tif (host->platdata && host->platdata->led)\n\t\t\tled_classdev_unregister(host->platdata->led);\n#endif\n\n\t\tif (host->platdata && host->platdata->cd_setup &&\n\t\t    !(host->mmc->caps & MMC_CAP_NEEDS_POLL))\n\t\t\thost->platdata->cd_setup(host->mmc, 0);\n\n\t\t__raw_writel(0, HOST_ENABLE(host));\n\t\t__raw_writel(0, HOST_CONFIG(host));\n\t\t__raw_writel(0, HOST_CONFIG2(host));\n\t\twmb();  \n\n\t\ttasklet_kill(&host->data_task);\n\t\ttasklet_kill(&host->finish_task);\n\n\t\tif (host->flags & HOST_F_DBDMA)\n\t\t\tau1xmmc_dbdma_shutdown(host);\n\n\t\tau1xmmc_set_power(host, 0);\n\n\t\tclk_disable_unprepare(host->clk);\n\t\tclk_put(host->clk);\n\n\t\tfree_irq(host->irq, host);\n\t\tiounmap((void *)host->iobase);\n\t\trelease_resource(host->ioarea);\n\t\tkfree(host->ioarea);\n\n\t\tmmc_free_host(host->mmc);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int au1xmmc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct au1xmmc_host *host = platform_get_drvdata(pdev);\n\n\t__raw_writel(0, HOST_CONFIG2(host));\n\t__raw_writel(0, HOST_CONFIG(host));\n\t__raw_writel(0xffffffff, HOST_STATUS(host));\n\t__raw_writel(0, HOST_ENABLE(host));\n\twmb();  \n\n\treturn 0;\n}\n\nstatic int au1xmmc_resume(struct platform_device *pdev)\n{\n\tstruct au1xmmc_host *host = platform_get_drvdata(pdev);\n\n\tau1xmmc_reset_controller(host);\n\n\treturn 0;\n}\n#else\n#define au1xmmc_suspend NULL\n#define au1xmmc_resume NULL\n#endif\n\nstatic struct platform_driver au1xmmc_driver = {\n\t.probe         = au1xmmc_probe,\n\t.remove_new    = au1xmmc_remove,\n\t.suspend       = au1xmmc_suspend,\n\t.resume        = au1xmmc_resume,\n\t.driver        = {\n\t\t.name  = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init au1xmmc_init(void)\n{\n\tif (has_dbdma()) {\n\t\t \n\t\tmemid = au1xxx_ddma_add_device(&au1xmmc_mem_dbdev);\n\t\tif (!memid)\n\t\t\tpr_err(\"au1xmmc: cannot add memory dbdma\\n\");\n\t}\n\treturn platform_driver_register(&au1xmmc_driver);\n}\n\nstatic void __exit au1xmmc_exit(void)\n{\n\tif (has_dbdma() && memid)\n\t\tau1xxx_ddma_del_device(memid);\n\n\tplatform_driver_unregister(&au1xmmc_driver);\n}\n\nmodule_init(au1xmmc_init);\nmodule_exit(au1xmmc_exit);\n\nMODULE_AUTHOR(\"Advanced Micro Devices, Inc\");\nMODULE_DESCRIPTION(\"MMC/SD driver for the Alchemy Au1XXX\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:au1xxx-mmc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}