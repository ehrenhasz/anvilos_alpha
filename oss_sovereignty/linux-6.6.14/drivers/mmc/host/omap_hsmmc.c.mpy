{
  "module_name": "omap_hsmmc.c",
  "hash_id": "891a2dfa1649ea459ac5252c07b5badf8211522a50f6a98c05046eab6b84ffd7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/omap_hsmmc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/dmaengine.h>\n#include <linux/seq_file.h>\n#include <linux/sizes.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/timer.h>\n#include <linux/clk.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/of_device.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/platform_data/hsmmc-omap.h>\n\n \n#define OMAP_HSMMC_SYSSTATUS\t0x0014\n#define OMAP_HSMMC_CON\t\t0x002C\n#define OMAP_HSMMC_SDMASA\t0x0100\n#define OMAP_HSMMC_BLK\t\t0x0104\n#define OMAP_HSMMC_ARG\t\t0x0108\n#define OMAP_HSMMC_CMD\t\t0x010C\n#define OMAP_HSMMC_RSP10\t0x0110\n#define OMAP_HSMMC_RSP32\t0x0114\n#define OMAP_HSMMC_RSP54\t0x0118\n#define OMAP_HSMMC_RSP76\t0x011C\n#define OMAP_HSMMC_DATA\t\t0x0120\n#define OMAP_HSMMC_PSTATE\t0x0124\n#define OMAP_HSMMC_HCTL\t\t0x0128\n#define OMAP_HSMMC_SYSCTL\t0x012C\n#define OMAP_HSMMC_STAT\t\t0x0130\n#define OMAP_HSMMC_IE\t\t0x0134\n#define OMAP_HSMMC_ISE\t\t0x0138\n#define OMAP_HSMMC_AC12\t\t0x013C\n#define OMAP_HSMMC_CAPA\t\t0x0140\n\n#define VS18\t\t\t(1 << 26)\n#define VS30\t\t\t(1 << 25)\n#define HSS\t\t\t(1 << 21)\n#define SDVS18\t\t\t(0x5 << 9)\n#define SDVS30\t\t\t(0x6 << 9)\n#define SDVS33\t\t\t(0x7 << 9)\n#define SDVS_MASK\t\t0x00000E00\n#define SDVSCLR\t\t\t0xFFFFF1FF\n#define SDVSDET\t\t\t0x00000400\n#define AUTOIDLE\t\t0x1\n#define SDBP\t\t\t(1 << 8)\n#define DTO\t\t\t0xe\n#define ICE\t\t\t0x1\n#define ICS\t\t\t0x2\n#define CEN\t\t\t(1 << 2)\n#define CLKD_MAX\t\t0x3FF\t\t \n#define CLKD_MASK\t\t0x0000FFC0\n#define CLKD_SHIFT\t\t6\n#define DTO_MASK\t\t0x000F0000\n#define DTO_SHIFT\t\t16\n#define INIT_STREAM\t\t(1 << 1)\n#define ACEN_ACMD23\t\t(2 << 2)\n#define DP_SELECT\t\t(1 << 21)\n#define DDIR\t\t\t(1 << 4)\n#define DMAE\t\t\t0x1\n#define MSBS\t\t\t(1 << 5)\n#define BCE\t\t\t(1 << 1)\n#define FOUR_BIT\t\t(1 << 1)\n#define HSPE\t\t\t(1 << 2)\n#define IWE\t\t\t(1 << 24)\n#define DDR\t\t\t(1 << 19)\n#define CLKEXTFREE\t\t(1 << 16)\n#define CTPL\t\t\t(1 << 11)\n#define DW8\t\t\t(1 << 5)\n#define OD\t\t\t0x1\n#define STAT_CLEAR\t\t0xFFFFFFFF\n#define INIT_STREAM_CMD\t\t0x00000000\n#define DUAL_VOLT_OCR_BIT\t7\n#define SRC\t\t\t(1 << 25)\n#define SRD\t\t\t(1 << 26)\n#define SOFTRESET\t\t(1 << 1)\n\n \n#define DLEV_DAT(x)\t\t(1 << (20 + (x)))\n\n \n#define CC_EN\t\t\t(1 << 0)\n#define TC_EN\t\t\t(1 << 1)\n#define BWR_EN\t\t\t(1 << 4)\n#define BRR_EN\t\t\t(1 << 5)\n#define CIRQ_EN\t\t\t(1 << 8)\n#define ERR_EN\t\t\t(1 << 15)\n#define CTO_EN\t\t\t(1 << 16)\n#define CCRC_EN\t\t\t(1 << 17)\n#define CEB_EN\t\t\t(1 << 18)\n#define CIE_EN\t\t\t(1 << 19)\n#define DTO_EN\t\t\t(1 << 20)\n#define DCRC_EN\t\t\t(1 << 21)\n#define DEB_EN\t\t\t(1 << 22)\n#define ACE_EN\t\t\t(1 << 24)\n#define CERR_EN\t\t\t(1 << 28)\n#define BADA_EN\t\t\t(1 << 29)\n\n#define INT_EN_MASK (BADA_EN | CERR_EN | ACE_EN | DEB_EN | DCRC_EN |\\\n\t\tDTO_EN | CIE_EN | CEB_EN | CCRC_EN | CTO_EN | \\\n\t\tBRR_EN | BWR_EN | TC_EN | CC_EN)\n\n#define CNI\t(1 << 7)\n#define ACIE\t(1 << 4)\n#define ACEB\t(1 << 3)\n#define ACCE\t(1 << 2)\n#define ACTO\t(1 << 1)\n#define ACNE\t(1 << 0)\n\n#define MMC_AUTOSUSPEND_DELAY\t100\n#define MMC_TIMEOUT_MS\t\t20\t\t \n#define MMC_TIMEOUT_US\t\t20000\t\t \n#define OMAP_MMC_MIN_CLOCK\t400000\n#define OMAP_MMC_MAX_CLOCK\t52000000\n#define DRIVER_NAME\t\t\"omap_hsmmc\"\n\n \n#define mmc_pdata(host)\t\thost->pdata\n\n \n#define OMAP_HSMMC_READ(base, reg)\t\\\n\t__raw_readl((base) + OMAP_HSMMC_##reg)\n\n#define OMAP_HSMMC_WRITE(base, reg, val) \\\n\t__raw_writel((val), (base) + OMAP_HSMMC_##reg)\n\nstruct omap_hsmmc_next {\n\tunsigned int\tdma_len;\n\ts32\t\tcookie;\n};\n\nstruct omap_hsmmc_host {\n\tstruct\tdevice\t\t*dev;\n\tstruct\tmmc_host\t*mmc;\n\tstruct\tmmc_request\t*mrq;\n\tstruct\tmmc_command\t*cmd;\n\tstruct\tmmc_data\t*data;\n\tstruct\tclk\t\t*fclk;\n\tstruct\tclk\t\t*dbclk;\n\tstruct\tregulator\t*pbias;\n\tbool\t\t\tpbias_enabled;\n\tvoid\t__iomem\t\t*base;\n\tbool\t\t\tvqmmc_enabled;\n\tresource_size_t\t\tmapbase;\n\tspinlock_t\t\tirq_lock;  \n\tunsigned int\t\tdma_len;\n\tunsigned int\t\tdma_sg_idx;\n\tunsigned char\t\tbus_mode;\n\tunsigned char\t\tpower_mode;\n\tint\t\t\tsuspended;\n\tu32\t\t\tcon;\n\tu32\t\t\thctl;\n\tu32\t\t\tsysctl;\n\tu32\t\t\tcapa;\n\tint\t\t\tirq;\n\tint\t\t\twake_irq;\n\tint\t\t\tuse_dma, dma_ch;\n\tstruct dma_chan\t\t*tx_chan;\n\tstruct dma_chan\t\t*rx_chan;\n\tint\t\t\tresponse_busy;\n\tint\t\t\tcontext_loss;\n\tint\t\t\treqs_blocked;\n\tint\t\t\treq_in_progress;\n\tunsigned long\t\tclk_rate;\n\tunsigned int\t\tflags;\n#define AUTO_CMD23\t\t(1 << 0)         \n#define HSMMC_SDIO_IRQ_ENABLED\t(1 << 1)         \n\tstruct omap_hsmmc_next\tnext_data;\n\tstruct\tomap_hsmmc_platform_data\t*pdata;\n};\n\nstruct omap_mmc_of_data {\n\tu32 reg_offset;\n\tu8 controller_flags;\n};\n\nstatic void omap_hsmmc_start_dma_transfer(struct omap_hsmmc_host *host);\n\nstatic int omap_hsmmc_enable_supply(struct mmc_host *mmc)\n{\n\tint ret;\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\tstruct mmc_ios *ios = &mmc->ios;\n\n\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\tret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {\n\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(mmc), \"vmmc_aux reg enable failed\\n\");\n\t\t\tgoto err_vqmmc;\n\t\t}\n\t\thost->vqmmc_enabled = true;\n\t}\n\n\treturn 0;\n\nerr_vqmmc:\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\treturn ret;\n}\n\nstatic int omap_hsmmc_disable_supply(struct mmc_host *mmc)\n{\n\tint ret;\n\tint status;\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\n\tif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {\n\t\tret = regulator_disable(mmc->supply.vqmmc);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(mmc), \"vmmc_aux reg disable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\thost->vqmmc_enabled = false;\n\t}\n\n\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\tret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\t\tif (ret)\n\t\t\tgoto err_set_ocr;\n\t}\n\n\treturn 0;\n\nerr_set_ocr:\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tstatus = regulator_enable(mmc->supply.vqmmc);\n\t\tif (status)\n\t\t\tdev_err(mmc_dev(mmc), \"vmmc_aux re-enable failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int omap_hsmmc_set_pbias(struct omap_hsmmc_host *host, bool power_on)\n{\n\tint ret;\n\n\tif (IS_ERR(host->pbias))\n\t\treturn 0;\n\n\tif (power_on) {\n\t\tif (!host->pbias_enabled) {\n\t\t\tret = regulator_enable(host->pbias);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(host->dev, \"pbias reg enable fail\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\thost->pbias_enabled = true;\n\t\t}\n\t} else {\n\t\tif (host->pbias_enabled) {\n\t\t\tret = regulator_disable(host->pbias);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(host->dev, \"pbias reg disable fail\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\thost->pbias_enabled = false;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_hsmmc_set_power(struct omap_hsmmc_host *host, int power_on)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret = 0;\n\n\t \n\tif (IS_ERR(mmc->supply.vmmc))\n\t\treturn 0;\n\n\tret = omap_hsmmc_set_pbias(host, false);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (power_on) {\n\t\tret = omap_hsmmc_enable_supply(mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = omap_hsmmc_set_pbias(host, true);\n\t\tif (ret)\n\t\t\tgoto err_set_voltage;\n\t} else {\n\t\tret = omap_hsmmc_disable_supply(mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n\nerr_set_voltage:\n\tomap_hsmmc_disable_supply(mmc);\n\n\treturn ret;\n}\n\nstatic int omap_hsmmc_disable_boot_regulator(struct regulator *reg)\n{\n\tint ret;\n\n\tif (IS_ERR(reg))\n\t\treturn 0;\n\n\tif (regulator_is_enabled(reg)) {\n\t\tret = regulator_enable(reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = regulator_disable(reg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_hsmmc_disable_boot_regulators(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret;\n\n\t \n\tret = omap_hsmmc_disable_boot_regulator(mmc->supply.vmmc);\n\tif (ret) {\n\t\tdev_err(host->dev, \"fail to disable boot enabled vmmc reg\\n\");\n\t\treturn ret;\n\t}\n\n\tret = omap_hsmmc_disable_boot_regulator(mmc->supply.vqmmc);\n\tif (ret) {\n\t\tdev_err(host->dev,\n\t\t\t\"fail to disable boot enabled vmmc_aux reg\\n\");\n\t\treturn ret;\n\t}\n\n\tret = omap_hsmmc_disable_boot_regulator(host->pbias);\n\tif (ret) {\n\t\tdev_err(host->dev,\n\t\t\t\"failed to disable boot enabled pbias reg\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_hsmmc_reg_get(struct omap_hsmmc_host *host)\n{\n\tint ret;\n\tstruct mmc_host *mmc = host->mmc;\n\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (IS_ERR(mmc->supply.vqmmc)) {\n\t\tmmc->supply.vqmmc = devm_regulator_get_optional(host->dev,\n\t\t\t\t\t\t\t\t\"vmmc_aux\");\n\t\tif (IS_ERR(mmc->supply.vqmmc)) {\n\t\t\tret = PTR_ERR(mmc->supply.vqmmc);\n\t\t\tif ((ret != -ENODEV) && host->dev->of_node)\n\t\t\t\treturn ret;\n\t\t\tdev_dbg(host->dev, \"unable to get vmmc_aux regulator %ld\\n\",\n\t\t\t\tPTR_ERR(mmc->supply.vqmmc));\n\t\t}\n\t}\n\n\thost->pbias = devm_regulator_get_optional(host->dev, \"pbias\");\n\tif (IS_ERR(host->pbias)) {\n\t\tret = PTR_ERR(host->pbias);\n\t\tif ((ret != -ENODEV) && host->dev->of_node) {\n\t\t\tdev_err(host->dev,\n\t\t\t\"SD card detect fail? enable CONFIG_REGULATOR_PBIAS\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tdev_dbg(host->dev, \"unable to get pbias regulator %ld\\n\",\n\t\t\tPTR_ERR(host->pbias));\n\t}\n\n\t \n\tif (mmc_pdata(host)->no_regulator_off_init)\n\t\treturn 0;\n\n\tret = omap_hsmmc_disable_boot_regulators(host);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic void omap_hsmmc_start_clock(struct omap_hsmmc_host *host)\n{\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL,\n\t\tOMAP_HSMMC_READ(host->base, SYSCTL) | CEN);\n}\n\n \nstatic void omap_hsmmc_stop_clock(struct omap_hsmmc_host *host)\n{\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL,\n\t\tOMAP_HSMMC_READ(host->base, SYSCTL) & ~CEN);\n\tif ((OMAP_HSMMC_READ(host->base, SYSCTL) & CEN) != 0x0)\n\t\tdev_dbg(mmc_dev(host->mmc), \"MMC Clock is not stopped\\n\");\n}\n\nstatic void omap_hsmmc_enable_irq(struct omap_hsmmc_host *host,\n\t\t\t\t  struct mmc_command *cmd)\n{\n\tu32 irq_mask = INT_EN_MASK;\n\tunsigned long flags;\n\n\tif (host->use_dma)\n\t\tirq_mask &= ~(BRR_EN | BWR_EN);\n\n\t \n\tif (cmd->opcode == MMC_ERASE)\n\t\tirq_mask &= ~DTO_EN;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\tOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\n\n\t \n\tif (host->flags & HSMMC_SDIO_IRQ_ENABLED)\n\t\tirq_mask |= CIRQ_EN;\n\tOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n}\n\nstatic void omap_hsmmc_disable_irq(struct omap_hsmmc_host *host)\n{\n\tu32 irq_mask = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\t \n\tif (host->flags & HSMMC_SDIO_IRQ_ENABLED)\n\t\tirq_mask |= CIRQ_EN;\n\tOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\n\tOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\n\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n}\n\n \nstatic u16 calc_divisor(struct omap_hsmmc_host *host, struct mmc_ios *ios)\n{\n\tu16 dsor = 0;\n\n\tif (ios->clock) {\n\t\tdsor = DIV_ROUND_UP(clk_get_rate(host->fclk), ios->clock);\n\t\tif (dsor > CLKD_MAX)\n\t\t\tdsor = CLKD_MAX;\n\t}\n\n\treturn dsor;\n}\n\nstatic void omap_hsmmc_set_clock(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\tunsigned long regval;\n\tunsigned long timeout;\n\tunsigned long clkdiv;\n\n\tdev_vdbg(mmc_dev(host->mmc), \"Set clock to %uHz\\n\", ios->clock);\n\n\tomap_hsmmc_stop_clock(host);\n\n\tregval = OMAP_HSMMC_READ(host->base, SYSCTL);\n\tregval = regval & ~(CLKD_MASK | DTO_MASK);\n\tclkdiv = calc_divisor(host, ios);\n\tregval = regval | (clkdiv << 6) | (DTO << 16);\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL, regval);\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL,\n\t\tOMAP_HSMMC_READ(host->base, SYSCTL) | ICE);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\n\twhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & ICS) != ICS\n\t\t&& time_before(jiffies, timeout))\n\t\tcpu_relax();\n\n\t \n\tif ((mmc_pdata(host)->features & HSMMC_HAS_HSPE_SUPPORT) &&\n\t    (ios->timing != MMC_TIMING_MMC_DDR52) &&\n\t    (ios->timing != MMC_TIMING_UHS_DDR50) &&\n\t    ((OMAP_HSMMC_READ(host->base, CAPA) & HSS) == HSS)) {\n\t\tregval = OMAP_HSMMC_READ(host->base, HCTL);\n\t\tif (clkdiv && (clk_get_rate(host->fclk)/clkdiv) > 25000000)\n\t\t\tregval |= HSPE;\n\t\telse\n\t\t\tregval &= ~HSPE;\n\n\t\tOMAP_HSMMC_WRITE(host->base, HCTL, regval);\n\t}\n\n\tomap_hsmmc_start_clock(host);\n}\n\nstatic void omap_hsmmc_set_bus_width(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\tu32 con;\n\n\tcon = OMAP_HSMMC_READ(host->base, CON);\n\tif (ios->timing == MMC_TIMING_MMC_DDR52 ||\n\t    ios->timing == MMC_TIMING_UHS_DDR50)\n\t\tcon |= DDR;\t \n\telse\n\t\tcon &= ~DDR;\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tOMAP_HSMMC_WRITE(host->base, CON, con | DW8);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\n\t\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\tOMAP_HSMMC_READ(host->base, HCTL) | FOUR_BIT);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_1:\n\t\tOMAP_HSMMC_WRITE(host->base, CON, con & ~DW8);\n\t\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\tOMAP_HSMMC_READ(host->base, HCTL) & ~FOUR_BIT);\n\t\tbreak;\n\t}\n}\n\nstatic void omap_hsmmc_set_bus_mode(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\tu32 con;\n\n\tcon = OMAP_HSMMC_READ(host->base, CON);\n\tif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\n\t\tOMAP_HSMMC_WRITE(host->base, CON, con | OD);\n\telse\n\t\tOMAP_HSMMC_WRITE(host->base, CON, con & ~OD);\n}\n\n#ifdef CONFIG_PM\n\n \nstatic int omap_hsmmc_context_restore(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\tu32 hctl, capa;\n\tunsigned long timeout;\n\n\tif (host->con == OMAP_HSMMC_READ(host->base, CON) &&\n\t    host->hctl == OMAP_HSMMC_READ(host->base, HCTL) &&\n\t    host->sysctl == OMAP_HSMMC_READ(host->base, SYSCTL) &&\n\t    host->capa == OMAP_HSMMC_READ(host->base, CAPA))\n\t\treturn 0;\n\n\thost->context_loss++;\n\n\tif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\n\t\tif (host->power_mode != MMC_POWER_OFF &&\n\t\t    (1 << ios->vdd) <= MMC_VDD_23_24)\n\t\t\thctl = SDVS18;\n\t\telse\n\t\t\thctl = SDVS30;\n\t\tcapa = VS30 | VS18;\n\t} else {\n\t\thctl = SDVS18;\n\t\tcapa = VS18;\n\t}\n\n\tif (host->mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\thctl |= IWE;\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\tOMAP_HSMMC_READ(host->base, HCTL) | hctl);\n\n\tOMAP_HSMMC_WRITE(host->base, CAPA,\n\t\t\tOMAP_HSMMC_READ(host->base, CAPA) | capa);\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\tOMAP_HSMMC_READ(host->base, HCTL) | SDBP);\n\n\ttimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\n\twhile ((OMAP_HSMMC_READ(host->base, HCTL) & SDBP) != SDBP\n\t\t&& time_before(jiffies, timeout))\n\t\t;\n\n\tOMAP_HSMMC_WRITE(host->base, ISE, 0);\n\tOMAP_HSMMC_WRITE(host->base, IE, 0);\n\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\n\t \n\tif (host->power_mode == MMC_POWER_OFF)\n\t\tgoto out;\n\n\tomap_hsmmc_set_bus_width(host);\n\n\tomap_hsmmc_set_clock(host);\n\n\tomap_hsmmc_set_bus_mode(host);\n\nout:\n\tdev_dbg(mmc_dev(host->mmc), \"context is restored: restore count %d\\n\",\n\t\thost->context_loss);\n\treturn 0;\n}\n\n \nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\n{\n\thost->con =  OMAP_HSMMC_READ(host->base, CON);\n\thost->hctl = OMAP_HSMMC_READ(host->base, HCTL);\n\thost->sysctl =  OMAP_HSMMC_READ(host->base, SYSCTL);\n\thost->capa = OMAP_HSMMC_READ(host->base, CAPA);\n}\n\n#else\n\nstatic void omap_hsmmc_context_save(struct omap_hsmmc_host *host)\n{\n}\n\n#endif\n\n \nstatic void send_init_stream(struct omap_hsmmc_host *host)\n{\n\tint reg = 0;\n\tunsigned long timeout;\n\n\tdisable_irq(host->irq);\n\n\tOMAP_HSMMC_WRITE(host->base, IE, INT_EN_MASK);\n\tOMAP_HSMMC_WRITE(host->base, CON,\n\t\tOMAP_HSMMC_READ(host->base, CON) | INIT_STREAM);\n\tOMAP_HSMMC_WRITE(host->base, CMD, INIT_STREAM_CMD);\n\n\ttimeout = jiffies + msecs_to_jiffies(MMC_TIMEOUT_MS);\n\twhile ((reg != CC_EN) && time_before(jiffies, timeout))\n\t\treg = OMAP_HSMMC_READ(host->base, STAT) & CC_EN;\n\n\tOMAP_HSMMC_WRITE(host->base, CON,\n\t\tOMAP_HSMMC_READ(host->base, CON) & ~INIT_STREAM);\n\n\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\tOMAP_HSMMC_READ(host->base, STAT);\n\n\tenable_irq(host->irq);\n}\n\nstatic ssize_t\nomap_hsmmc_show_slot_name(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\n\treturn sprintf(buf, \"%s\\n\", mmc_pdata(host)->name);\n}\n\nstatic DEVICE_ATTR(slot_name, S_IRUGO, omap_hsmmc_show_slot_name, NULL);\n\n \nstatic void\nomap_hsmmc_start_command(struct omap_hsmmc_host *host, struct mmc_command *cmd,\n\tstruct mmc_data *data)\n{\n\tint cmdreg = 0, resptype = 0, cmdtype = 0;\n\n\tdev_vdbg(mmc_dev(host->mmc), \"%s: CMD%d, argument 0x%08x\\n\",\n\t\tmmc_hostname(host->mmc), cmd->opcode, cmd->arg);\n\thost->cmd = cmd;\n\n\tomap_hsmmc_enable_irq(host, cmd);\n\n\thost->response_busy = 0;\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tresptype = 1;\n\t\telse if (cmd->flags & MMC_RSP_BUSY) {\n\t\t\tresptype = 3;\n\t\t\thost->response_busy = 1;\n\t\t} else\n\t\t\tresptype = 2;\n\t}\n\n\t \n\tif (cmd == host->mrq->stop)\n\t\tcmdtype = 0x3;\n\n\tcmdreg = (cmd->opcode << 24) | (resptype << 16) | (cmdtype << 22);\n\n\tif ((host->flags & AUTO_CMD23) && mmc_op_multi(cmd->opcode) &&\n\t    host->mrq->sbc) {\n\t\tcmdreg |= ACEN_ACMD23;\n\t\tOMAP_HSMMC_WRITE(host->base, SDMASA, host->mrq->sbc->arg);\n\t}\n\tif (data) {\n\t\tcmdreg |= DP_SELECT | MSBS | BCE;\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tcmdreg |= DDIR;\n\t\telse\n\t\t\tcmdreg &= ~(DDIR);\n\t}\n\n\tif (host->use_dma)\n\t\tcmdreg |= DMAE;\n\n\thost->req_in_progress = 1;\n\n\tOMAP_HSMMC_WRITE(host->base, ARG, cmd->arg);\n\tOMAP_HSMMC_WRITE(host->base, CMD, cmdreg);\n}\n\nstatic struct dma_chan *omap_hsmmc_get_dma_chan(struct omap_hsmmc_host *host,\n\tstruct mmc_data *data)\n{\n\treturn data->flags & MMC_DATA_WRITE ? host->tx_chan : host->rx_chan;\n}\n\nstatic void omap_hsmmc_request_done(struct omap_hsmmc_host *host, struct mmc_request *mrq)\n{\n\tint dma_ch;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\thost->req_in_progress = 0;\n\tdma_ch = host->dma_ch;\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n\n\tomap_hsmmc_disable_irq(host);\n\t \n\tif (mrq->data && host->use_dma && dma_ch != -1)\n\t\treturn;\n\thost->mrq = NULL;\n\tmmc_request_done(host->mmc, mrq);\n}\n\n \nstatic void\nomap_hsmmc_xfer_done(struct omap_hsmmc_host *host, struct mmc_data *data)\n{\n\tif (!data) {\n\t\tstruct mmc_request *mrq = host->mrq;\n\n\t\t \n\t\tif (host->cmd && host->cmd->opcode == 6 &&\n\t\t    host->response_busy) {\n\t\t\thost->response_busy = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tomap_hsmmc_request_done(host, mrq);\n\t\treturn;\n\t}\n\n\thost->data = NULL;\n\n\tif (!data->error)\n\t\tdata->bytes_xfered += data->blocks * (data->blksz);\n\telse\n\t\tdata->bytes_xfered = 0;\n\n\tif (data->stop && (data->error || !host->mrq->sbc))\n\t\tomap_hsmmc_start_command(host, data->stop, NULL);\n\telse\n\t\tomap_hsmmc_request_done(host, data->mrq);\n}\n\n \nstatic void\nomap_hsmmc_cmd_done(struct omap_hsmmc_host *host, struct mmc_command *cmd)\n{\n\tif (host->mrq->sbc && (host->cmd == host->mrq->sbc) &&\n\t    !host->mrq->sbc->error && !(host->flags & AUTO_CMD23)) {\n\t\thost->cmd = NULL;\n\t\tomap_hsmmc_start_dma_transfer(host);\n\t\tomap_hsmmc_start_command(host, host->mrq->cmd,\n\t\t\t\t\t\thost->mrq->data);\n\t\treturn;\n\t}\n\n\thost->cmd = NULL;\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\t \n\t\t\tcmd->resp[3] = OMAP_HSMMC_READ(host->base, RSP10);\n\t\t\tcmd->resp[2] = OMAP_HSMMC_READ(host->base, RSP32);\n\t\t\tcmd->resp[1] = OMAP_HSMMC_READ(host->base, RSP54);\n\t\t\tcmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP76);\n\t\t} else {\n\t\t\t \n\t\t\tcmd->resp[0] = OMAP_HSMMC_READ(host->base, RSP10);\n\t\t}\n\t}\n\tif ((host->data == NULL && !host->response_busy) || cmd->error)\n\t\tomap_hsmmc_request_done(host, host->mrq);\n}\n\n \nstatic void omap_hsmmc_dma_cleanup(struct omap_hsmmc_host *host, int errno)\n{\n\tint dma_ch;\n\tunsigned long flags;\n\n\thost->data->error = errno;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\tdma_ch = host->dma_ch;\n\thost->dma_ch = -1;\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n\n\tif (host->use_dma && dma_ch != -1) {\n\t\tstruct dma_chan *chan = omap_hsmmc_get_dma_chan(host, host->data);\n\n\t\tdmaengine_terminate_all(chan);\n\t\tdma_unmap_sg(chan->device->dev,\n\t\t\thost->data->sg, host->data->sg_len,\n\t\t\tmmc_get_dma_dir(host->data));\n\n\t\thost->data->host_cookie = 0;\n\t}\n\thost->data = NULL;\n}\n\n \n#ifdef CONFIG_MMC_DEBUG\nstatic void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host, u32 status)\n{\n\t \n\tstatic const char *omap_hsmmc_status_bits[] = {\n\t\t\"CC\"  , \"TC\"  , \"BGE\", \"---\", \"BWR\" , \"BRR\" , \"---\" , \"---\" ,\n\t\t\"CIRQ\",\t\"OBI\" , \"---\", \"---\", \"---\" , \"---\" , \"---\" , \"ERRI\",\n\t\t\"CTO\" , \"CCRC\", \"CEB\", \"CIE\", \"DTO\" , \"DCRC\", \"DEB\" , \"---\" ,\n\t\t\"ACE\" , \"---\" , \"---\", \"---\", \"CERR\", \"BADA\", \"---\" , \"---\"\n\t};\n\tchar res[256];\n\tchar *buf = res;\n\tint len, i;\n\n\tlen = sprintf(buf, \"MMC IRQ 0x%x :\", status);\n\tbuf += len;\n\n\tfor (i = 0; i < ARRAY_SIZE(omap_hsmmc_status_bits); i++)\n\t\tif (status & (1 << i)) {\n\t\t\tlen = sprintf(buf, \" %s\", omap_hsmmc_status_bits[i]);\n\t\t\tbuf += len;\n\t\t}\n\n\tdev_vdbg(mmc_dev(host->mmc), \"%s\\n\", res);\n}\n#else\nstatic inline void omap_hsmmc_dbg_report_irq(struct omap_hsmmc_host *host,\n\t\t\t\t\t     u32 status)\n{\n}\n#endif   \n\n \nstatic inline void omap_hsmmc_reset_controller_fsm(struct omap_hsmmc_host *host,\n\t\t\t\t\t\t   unsigned long bit)\n{\n\tunsigned long i = 0;\n\tunsigned long limit = MMC_TIMEOUT_US;\n\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL,\n\t\t\t OMAP_HSMMC_READ(host->base, SYSCTL) | bit);\n\n\t \n\tif (mmc_pdata(host)->features & HSMMC_HAS_UPDATED_RESET) {\n\t\twhile ((!(OMAP_HSMMC_READ(host->base, SYSCTL) & bit))\n\t\t\t\t\t&& (i++ < limit))\n\t\t\tudelay(1);\n\t}\n\ti = 0;\n\n\twhile ((OMAP_HSMMC_READ(host->base, SYSCTL) & bit) &&\n\t\t(i++ < limit))\n\t\tudelay(1);\n\n\tif (OMAP_HSMMC_READ(host->base, SYSCTL) & bit)\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"Timeout waiting on controller reset in %s\\n\",\n\t\t\t__func__);\n}\n\nstatic void hsmmc_command_incomplete(struct omap_hsmmc_host *host,\n\t\t\t\t\tint err, int end_cmd)\n{\n\tif (end_cmd) {\n\t\tomap_hsmmc_reset_controller_fsm(host, SRC);\n\t\tif (host->cmd)\n\t\t\thost->cmd->error = err;\n\t}\n\n\tif (host->data) {\n\t\tomap_hsmmc_reset_controller_fsm(host, SRD);\n\t\tomap_hsmmc_dma_cleanup(host, err);\n\t} else if (host->mrq && host->mrq->cmd)\n\t\thost->mrq->cmd->error = err;\n}\n\nstatic void omap_hsmmc_do_irq(struct omap_hsmmc_host *host, int status)\n{\n\tstruct mmc_data *data;\n\tint end_cmd = 0, end_trans = 0;\n\tint error = 0;\n\n\tdata = host->data;\n\tdev_vdbg(mmc_dev(host->mmc), \"IRQ Status is %x\\n\", status);\n\n\tif (status & ERR_EN) {\n\t\tomap_hsmmc_dbg_report_irq(host, status);\n\n\t\tif (status & (CTO_EN | CCRC_EN | CEB_EN))\n\t\t\tend_cmd = 1;\n\t\tif (host->data || host->response_busy) {\n\t\t\tend_trans = !end_cmd;\n\t\t\thost->response_busy = 0;\n\t\t}\n\t\tif (status & (CTO_EN | DTO_EN))\n\t\t\thsmmc_command_incomplete(host, -ETIMEDOUT, end_cmd);\n\t\telse if (status & (CCRC_EN | DCRC_EN | DEB_EN | CEB_EN |\n\t\t\t\t   BADA_EN))\n\t\t\thsmmc_command_incomplete(host, -EILSEQ, end_cmd);\n\n\t\tif (status & ACE_EN) {\n\t\t\tu32 ac12;\n\t\t\tac12 = OMAP_HSMMC_READ(host->base, AC12);\n\t\t\tif (!(ac12 & ACNE) && host->mrq->sbc) {\n\t\t\t\tend_cmd = 1;\n\t\t\t\tif (ac12 & ACTO)\n\t\t\t\t\terror =  -ETIMEDOUT;\n\t\t\t\telse if (ac12 & (ACCE | ACEB | ACIE))\n\t\t\t\t\terror = -EILSEQ;\n\t\t\t\thost->mrq->sbc->error = error;\n\t\t\t\thsmmc_command_incomplete(host, error, end_cmd);\n\t\t\t}\n\t\t\tdev_dbg(mmc_dev(host->mmc), \"AC12 err: 0x%x\\n\", ac12);\n\t\t}\n\t}\n\n\tOMAP_HSMMC_WRITE(host->base, STAT, status);\n\tif (end_cmd || ((status & CC_EN) && host->cmd))\n\t\tomap_hsmmc_cmd_done(host, host->cmd);\n\tif ((end_trans || (status & TC_EN)) && host->mrq)\n\t\tomap_hsmmc_xfer_done(host, data);\n}\n\n \nstatic irqreturn_t omap_hsmmc_irq(int irq, void *dev_id)\n{\n\tstruct omap_hsmmc_host *host = dev_id;\n\tint status;\n\n\tstatus = OMAP_HSMMC_READ(host->base, STAT);\n\twhile (status & (INT_EN_MASK | CIRQ_EN)) {\n\t\tif (host->req_in_progress)\n\t\t\tomap_hsmmc_do_irq(host, status);\n\n\t\tif (status & CIRQ_EN)\n\t\t\tmmc_signal_sdio_irq(host->mmc);\n\n\t\t \n\t\tstatus = OMAP_HSMMC_READ(host->base, STAT);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void set_sd_bus_power(struct omap_hsmmc_host *host)\n{\n\tunsigned long i;\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\t OMAP_HSMMC_READ(host->base, HCTL) | SDBP);\n\tfor (i = 0; i < loops_per_jiffy; i++) {\n\t\tif (OMAP_HSMMC_READ(host->base, HCTL) & SDBP)\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n}\n\n \nstatic int omap_hsmmc_switch_opcond(struct omap_hsmmc_host *host, int vdd)\n{\n\tu32 reg_val = 0;\n\tint ret;\n\n\t \n\tclk_disable_unprepare(host->dbclk);\n\n\t \n\tret = omap_hsmmc_set_power(host, 0);\n\n\t \n\tif (!ret)\n\t\tret = omap_hsmmc_set_power(host, 1);\n\tclk_prepare_enable(host->dbclk);\n\n\tif (ret != 0)\n\t\tgoto err;\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\tOMAP_HSMMC_READ(host->base, HCTL) & SDVSCLR);\n\treg_val = OMAP_HSMMC_READ(host->base, HCTL);\n\n\t \n\tif ((1 << vdd) <= MMC_VDD_23_24)\n\t\treg_val |= SDVS18;\n\telse\n\t\treg_val |= SDVS30;\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL, reg_val);\n\tset_sd_bus_power(host);\n\n\treturn 0;\nerr:\n\tdev_err(mmc_dev(host->mmc), \"Unable to switch operating voltage\\n\");\n\treturn ret;\n}\n\nstatic void omap_hsmmc_dma_callback(void *param)\n{\n\tstruct omap_hsmmc_host *host = param;\n\tstruct dma_chan *chan;\n\tstruct mmc_data *data;\n\tint req_in_progress;\n\n\tspin_lock_irq(&host->irq_lock);\n\tif (host->dma_ch < 0) {\n\t\tspin_unlock_irq(&host->irq_lock);\n\t\treturn;\n\t}\n\n\tdata = host->mrq->data;\n\tchan = omap_hsmmc_get_dma_chan(host, data);\n\tif (!data->host_cookie)\n\t\tdma_unmap_sg(chan->device->dev,\n\t\t\t     data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\n\treq_in_progress = host->req_in_progress;\n\thost->dma_ch = -1;\n\tspin_unlock_irq(&host->irq_lock);\n\n\t \n\tif (!req_in_progress) {\n\t\tstruct mmc_request *mrq = host->mrq;\n\n\t\thost->mrq = NULL;\n\t\tmmc_request_done(host->mmc, mrq);\n\t}\n}\n\nstatic int omap_hsmmc_pre_dma_transfer(struct omap_hsmmc_host *host,\n\t\t\t\t       struct mmc_data *data,\n\t\t\t\t       struct omap_hsmmc_next *next,\n\t\t\t\t       struct dma_chan *chan)\n{\n\tint dma_len;\n\n\tif (!next && data->host_cookie &&\n\t    data->host_cookie != host->next_data.cookie) {\n\t\tdev_warn(host->dev, \"[%s] invalid cookie: data->host_cookie %d\"\n\t\t       \" host->next_data.cookie %d\\n\",\n\t\t       __func__, data->host_cookie, host->next_data.cookie);\n\t\tdata->host_cookie = 0;\n\t}\n\n\t \n\tif (next || data->host_cookie != host->next_data.cookie) {\n\t\tdma_len = dma_map_sg(chan->device->dev, data->sg, data->sg_len,\n\t\t\t\t     mmc_get_dma_dir(data));\n\n\t} else {\n\t\tdma_len = host->next_data.dma_len;\n\t\thost->next_data.dma_len = 0;\n\t}\n\n\n\tif (dma_len == 0)\n\t\treturn -EINVAL;\n\n\tif (next) {\n\t\tnext->dma_len = dma_len;\n\t\tdata->host_cookie = ++next->cookie < 0 ? 1 : next->cookie;\n\t} else\n\t\thost->dma_len = dma_len;\n\n\treturn 0;\n}\n\n \nstatic int omap_hsmmc_setup_dma_transfer(struct omap_hsmmc_host *host,\n\t\t\t\t\tstruct mmc_request *req)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tint ret = 0, i;\n\tstruct mmc_data *data = req->data;\n\tstruct dma_chan *chan;\n\tstruct dma_slave_config cfg = {\n\t\t.src_addr = host->mapbase + OMAP_HSMMC_DATA,\n\t\t.dst_addr = host->mapbase + OMAP_HSMMC_DATA,\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.src_maxburst = data->blksz / 4,\n\t\t.dst_maxburst = data->blksz / 4,\n\t};\n\n\t \n\tfor (i = 0; i < data->sg_len; i++) {\n\t\tstruct scatterlist *sgl;\n\n\t\tsgl = data->sg + i;\n\t\tif (sgl->length % data->blksz)\n\t\t\treturn -EINVAL;\n\t}\n\tif ((data->blksz % 4) != 0)\n\t\t \n\t\treturn -EINVAL;\n\n\tBUG_ON(host->dma_ch != -1);\n\n\tchan = omap_hsmmc_get_dma_chan(host, data);\n\n\tret = dmaengine_slave_config(chan, &cfg);\n\tif (ret)\n\t\treturn ret;\n\n\tret = omap_hsmmc_pre_dma_transfer(host, data, NULL, chan);\n\tif (ret)\n\t\treturn ret;\n\n\ttx = dmaengine_prep_slave_sg(chan, data->sg, data->sg_len,\n\t\tdata->flags & MMC_DATA_WRITE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\n\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!tx) {\n\t\tdev_err(mmc_dev(host->mmc), \"prep_slave_sg() failed\\n\");\n\t\t \n\t\treturn -1;\n\t}\n\n\ttx->callback = omap_hsmmc_dma_callback;\n\ttx->callback_param = host;\n\n\t \n\tdmaengine_submit(tx);\n\n\thost->dma_ch = 1;\n\n\treturn 0;\n}\n\nstatic void set_data_timeout(struct omap_hsmmc_host *host,\n\t\t\t     unsigned long long timeout_ns,\n\t\t\t     unsigned int timeout_clks)\n{\n\tunsigned long long timeout = timeout_ns;\n\tunsigned int cycle_ns;\n\tuint32_t reg, clkd, dto = 0;\n\n\treg = OMAP_HSMMC_READ(host->base, SYSCTL);\n\tclkd = (reg & CLKD_MASK) >> CLKD_SHIFT;\n\tif (clkd == 0)\n\t\tclkd = 1;\n\n\tcycle_ns = 1000000000 / (host->clk_rate / clkd);\n\tdo_div(timeout, cycle_ns);\n\ttimeout += timeout_clks;\n\tif (timeout) {\n\t\twhile ((timeout & 0x80000000) == 0) {\n\t\t\tdto += 1;\n\t\t\ttimeout <<= 1;\n\t\t}\n\t\tdto = 31 - dto;\n\t\ttimeout <<= 1;\n\t\tif (timeout && dto)\n\t\t\tdto += 1;\n\t\tif (dto >= 13)\n\t\t\tdto -= 13;\n\t\telse\n\t\t\tdto = 0;\n\t\tif (dto > 14)\n\t\t\tdto = 14;\n\t}\n\n\treg &= ~DTO_MASK;\n\treg |= dto << DTO_SHIFT;\n\tOMAP_HSMMC_WRITE(host->base, SYSCTL, reg);\n}\n\nstatic void omap_hsmmc_start_dma_transfer(struct omap_hsmmc_host *host)\n{\n\tstruct mmc_request *req = host->mrq;\n\tstruct dma_chan *chan;\n\n\tif (!req->data)\n\t\treturn;\n\tOMAP_HSMMC_WRITE(host->base, BLK, (req->data->blksz)\n\t\t\t\t| (req->data->blocks << 16));\n\tset_data_timeout(host, req->data->timeout_ns,\n\t\t\t\treq->data->timeout_clks);\n\tchan = omap_hsmmc_get_dma_chan(host, req->data);\n\tdma_async_issue_pending(chan);\n}\n\n \nstatic int\nomap_hsmmc_prepare_data(struct omap_hsmmc_host *host, struct mmc_request *req)\n{\n\tint ret;\n\tunsigned long long timeout;\n\n\thost->data = req->data;\n\n\tif (req->data == NULL) {\n\t\tOMAP_HSMMC_WRITE(host->base, BLK, 0);\n\t\tif (req->cmd->flags & MMC_RSP_BUSY) {\n\t\t\ttimeout = req->cmd->busy_timeout * NSEC_PER_MSEC;\n\n\t\t\t \n\t\t\tif (!timeout)\n\t\t\t\ttimeout = 100000000U;\n\n\t\t\tset_data_timeout(host, timeout, 0);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (host->use_dma) {\n\t\tret = omap_hsmmc_setup_dma_transfer(host, req);\n\t\tif (ret != 0) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"MMC start dma failure\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void omap_hsmmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\t\t\tint err)\n{\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (host->use_dma && data->host_cookie) {\n\t\tstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, data);\n\n\t\tdma_unmap_sg(c->device->dev, data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t\tdata->host_cookie = 0;\n\t}\n}\n\nstatic void omap_hsmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\n\tif (mrq->data->host_cookie) {\n\t\tmrq->data->host_cookie = 0;\n\t\treturn ;\n\t}\n\n\tif (host->use_dma) {\n\t\tstruct dma_chan *c = omap_hsmmc_get_dma_chan(host, mrq->data);\n\n\t\tif (omap_hsmmc_pre_dma_transfer(host, mrq->data,\n\t\t\t\t\t\t&host->next_data, c))\n\t\t\tmrq->data->host_cookie = 0;\n\t}\n}\n\n \nstatic void omap_hsmmc_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\tint err;\n\n\tBUG_ON(host->req_in_progress);\n\tBUG_ON(host->dma_ch != -1);\n\tif (host->reqs_blocked)\n\t\thost->reqs_blocked = 0;\n\tWARN_ON(host->mrq != NULL);\n\thost->mrq = req;\n\thost->clk_rate = clk_get_rate(host->fclk);\n\terr = omap_hsmmc_prepare_data(host, req);\n\tif (err) {\n\t\treq->cmd->error = err;\n\t\tif (req->data)\n\t\t\treq->data->error = err;\n\t\thost->mrq = NULL;\n\t\tmmc_request_done(mmc, req);\n\t\treturn;\n\t}\n\tif (req->sbc && !(host->flags & AUTO_CMD23)) {\n\t\tomap_hsmmc_start_command(host, req->sbc, NULL);\n\t\treturn;\n\t}\n\n\tomap_hsmmc_start_dma_transfer(host);\n\tomap_hsmmc_start_command(host, req->cmd, req->data);\n}\n\n \nstatic void omap_hsmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\tint do_send_init_stream = 0;\n\n\tif (ios->power_mode != host->power_mode) {\n\t\tswitch (ios->power_mode) {\n\t\tcase MMC_POWER_OFF:\n\t\t\tomap_hsmmc_set_power(host, 0);\n\t\t\tbreak;\n\t\tcase MMC_POWER_UP:\n\t\t\tomap_hsmmc_set_power(host, 1);\n\t\t\tbreak;\n\t\tcase MMC_POWER_ON:\n\t\t\tdo_send_init_stream = 1;\n\t\t\tbreak;\n\t\t}\n\t\thost->power_mode = ios->power_mode;\n\t}\n\n\t \n\n\tomap_hsmmc_set_bus_width(host);\n\n\tif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\n\t\t \n\t\tif ((OMAP_HSMMC_READ(host->base, HCTL) & SDVSDET) &&\n\t\t\t(ios->vdd == DUAL_VOLT_OCR_BIT)) {\n\t\t\t\t \n\t\t\tif (omap_hsmmc_switch_opcond(host, ios->vdd) != 0)\n\t\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\t\t\"Switch operation failed\\n\");\n\t\t}\n\t}\n\n\tomap_hsmmc_set_clock(host);\n\n\tif (do_send_init_stream)\n\t\tsend_init_stream(host);\n\n\tomap_hsmmc_set_bus_mode(host);\n}\n\nstatic void omap_hsmmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\tu32 irq_mask, con;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\n\tcon = OMAP_HSMMC_READ(host->base, CON);\n\tirq_mask = OMAP_HSMMC_READ(host->base, ISE);\n\tif (enable) {\n\t\thost->flags |= HSMMC_SDIO_IRQ_ENABLED;\n\t\tirq_mask |= CIRQ_EN;\n\t\tcon |= CTPL | CLKEXTFREE;\n\t} else {\n\t\thost->flags &= ~HSMMC_SDIO_IRQ_ENABLED;\n\t\tirq_mask &= ~CIRQ_EN;\n\t\tcon &= ~(CTPL | CLKEXTFREE);\n\t}\n\tOMAP_HSMMC_WRITE(host->base, CON, con);\n\tOMAP_HSMMC_WRITE(host->base, IE, irq_mask);\n\n\t \n\tif (!host->req_in_progress || !enable)\n\t\tOMAP_HSMMC_WRITE(host->base, ISE, irq_mask);\n\n\t \n\tOMAP_HSMMC_READ(host->base, IE);\n\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n}\n\nstatic int omap_hsmmc_configure_wake_irq(struct omap_hsmmc_host *host)\n{\n\tint ret;\n\n\t \n\tif (!host->dev->of_node || !host->wake_irq)\n\t\treturn -ENODEV;\n\n\tret = dev_pm_set_dedicated_wake_irq(host->dev, host->wake_irq);\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"Unable to request wake IRQ\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tif (host->pdata->controller_flags & OMAP_HSMMC_SWAKEUP_MISSING) {\n\t\tstruct pinctrl *p = devm_pinctrl_get(host->dev);\n\t\tif (IS_ERR(p)) {\n\t\t\tret = PTR_ERR(p);\n\t\t\tgoto err_free_irq;\n\t\t}\n\n\t\tif (IS_ERR(pinctrl_lookup_state(p, PINCTRL_STATE_IDLE))) {\n\t\t\tdev_info(host->dev, \"missing idle pinctrl state\\n\");\n\t\t\tdevm_pinctrl_put(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_free_irq;\n\t\t}\n\t\tdevm_pinctrl_put(p);\n\t}\n\n\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\t OMAP_HSMMC_READ(host->base, HCTL) | IWE);\n\treturn 0;\n\nerr_free_irq:\n\tdev_pm_clear_wake_irq(host->dev);\nerr:\n\tdev_warn(host->dev, \"no SDIO IRQ support, falling back to polling\\n\");\n\thost->wake_irq = 0;\n\treturn ret;\n}\n\nstatic void omap_hsmmc_conf_bus_power(struct omap_hsmmc_host *host)\n{\n\tu32 hctl, capa, value;\n\n\t \n\tif (host->pdata->controller_flags & OMAP_HSMMC_SUPPORTS_DUAL_VOLT) {\n\t\thctl = SDVS30;\n\t\tcapa = VS30 | VS18;\n\t} else {\n\t\thctl = SDVS18;\n\t\tcapa = VS18;\n\t}\n\n\tvalue = OMAP_HSMMC_READ(host->base, HCTL) & ~SDVS_MASK;\n\tOMAP_HSMMC_WRITE(host->base, HCTL, value | hctl);\n\n\tvalue = OMAP_HSMMC_READ(host->base, CAPA);\n\tOMAP_HSMMC_WRITE(host->base, CAPA, value | capa);\n\n\t \n\tset_sd_bus_power(host);\n}\n\nstatic int omap_hsmmc_multi_io_quirk(struct mmc_card *card,\n\t\t\t\t     unsigned int direction, int blk_size)\n{\n\t \n\tif (direction == MMC_DATA_READ)\n\t\treturn 1;\n\n\treturn blk_size;\n}\n\nstatic struct mmc_host_ops omap_hsmmc_ops = {\n\t.post_req = omap_hsmmc_post_req,\n\t.pre_req = omap_hsmmc_pre_req,\n\t.request = omap_hsmmc_request,\n\t.set_ios = omap_hsmmc_set_ios,\n\t.get_cd = mmc_gpio_get_cd,\n\t.get_ro = mmc_gpio_get_ro,\n\t.enable_sdio_irq = omap_hsmmc_enable_sdio_irq,\n};\n\n#ifdef CONFIG_DEBUG_FS\n\nstatic int mmc_regs_show(struct seq_file *s, void *data)\n{\n\tstruct mmc_host *mmc = s->private;\n\tstruct omap_hsmmc_host *host = mmc_priv(mmc);\n\n\tseq_printf(s, \"mmc%d:\\n\", mmc->index);\n\tseq_printf(s, \"sdio irq mode\\t%s\\n\",\n\t\t   (mmc->caps & MMC_CAP_SDIO_IRQ) ? \"interrupt\" : \"polling\");\n\n\tif (mmc->caps & MMC_CAP_SDIO_IRQ) {\n\t\tseq_printf(s, \"sdio irq \\t%s\\n\",\n\t\t\t   (host->flags & HSMMC_SDIO_IRQ_ENABLED) ?  \"enabled\"\n\t\t\t   : \"disabled\");\n\t}\n\tseq_printf(s, \"ctx_loss:\\t%d\\n\", host->context_loss);\n\n\tpm_runtime_get_sync(host->dev);\n\tseq_puts(s, \"\\nregs:\\n\");\n\tseq_printf(s, \"CON:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, CON));\n\tseq_printf(s, \"PSTATE:\\t\\t0x%08x\\n\",\n\t\t   OMAP_HSMMC_READ(host->base, PSTATE));\n\tseq_printf(s, \"HCTL:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, HCTL));\n\tseq_printf(s, \"SYSCTL:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, SYSCTL));\n\tseq_printf(s, \"IE:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, IE));\n\tseq_printf(s, \"ISE:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, ISE));\n\tseq_printf(s, \"CAPA:\\t\\t0x%08x\\n\",\n\t\t\tOMAP_HSMMC_READ(host->base, CAPA));\n\n\tpm_runtime_mark_last_busy(host->dev);\n\tpm_runtime_put_autosuspend(host->dev);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mmc_regs);\n\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\n{\n\tif (mmc->debugfs_root)\n\t\tdebugfs_create_file(\"regs\", S_IRUSR, mmc->debugfs_root,\n\t\t\tmmc, &mmc_regs_fops);\n}\n\n#else\n\nstatic void omap_hsmmc_debugfs(struct mmc_host *mmc)\n{\n}\n\n#endif\n\n#ifdef CONFIG_OF\nstatic const struct omap_mmc_of_data omap3_pre_es3_mmc_of_data = {\n\t \n\t.controller_flags = OMAP_HSMMC_BROKEN_MULTIBLOCK_READ,\n};\n\nstatic const struct omap_mmc_of_data omap4_mmc_of_data = {\n\t.reg_offset = 0x100,\n};\nstatic const struct omap_mmc_of_data am33xx_mmc_of_data = {\n\t.reg_offset = 0x100,\n\t.controller_flags = OMAP_HSMMC_SWAKEUP_MISSING,\n};\n\nstatic const struct of_device_id omap_mmc_of_match[] = {\n\t{\n\t\t.compatible = \"ti,omap2-hsmmc\",\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-pre-es3-hsmmc\",\n\t\t.data = &omap3_pre_es3_mmc_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,omap3-hsmmc\",\n\t},\n\t{\n\t\t.compatible = \"ti,omap4-hsmmc\",\n\t\t.data = &omap4_mmc_of_data,\n\t},\n\t{\n\t\t.compatible = \"ti,am33xx-hsmmc\",\n\t\t.data = &am33xx_mmc_of_data,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_mmc_of_match);\n\nstatic struct omap_hsmmc_platform_data *of_get_hsmmc_pdata(struct device *dev)\n{\n\tstruct omap_hsmmc_platform_data *pdata, *legacy;\n\tstruct device_node *np = dev->of_node;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);  \n\n\tlegacy = dev_get_platdata(dev);\n\tif (legacy && legacy->name)\n\t\tpdata->name = legacy->name;\n\n\tif (of_property_read_bool(np, \"ti,dual-volt\"))\n\t\tpdata->controller_flags |= OMAP_HSMMC_SUPPORTS_DUAL_VOLT;\n\n\tif (of_property_read_bool(np, \"ti,non-removable\")) {\n\t\tpdata->nonremovable = true;\n\t\tpdata->no_regulator_off_init = true;\n\t}\n\n\tif (of_property_read_bool(np, \"ti,needs-special-reset\"))\n\t\tpdata->features |= HSMMC_HAS_UPDATED_RESET;\n\n\tif (of_property_read_bool(np, \"ti,needs-special-hs-handling\"))\n\t\tpdata->features |= HSMMC_HAS_HSPE_SUPPORT;\n\n\treturn pdata;\n}\n#else\nstatic inline struct omap_hsmmc_platform_data\n\t\t\t*of_get_hsmmc_pdata(struct device *dev)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\nstatic int omap_hsmmc_probe(struct platform_device *pdev)\n{\n\tstruct omap_hsmmc_platform_data *pdata = pdev->dev.platform_data;\n\tstruct mmc_host *mmc;\n\tstruct omap_hsmmc_host *host = NULL;\n\tstruct resource *res;\n\tint ret, irq;\n\tconst struct of_device_id *match;\n\tconst struct omap_mmc_of_data *data;\n\tvoid __iomem *base;\n\n\tmatch = of_match_device(of_match_ptr(omap_mmc_of_match), &pdev->dev);\n\tif (match) {\n\t\tpdata = of_get_hsmmc_pdata(&pdev->dev);\n\n\t\tif (IS_ERR(pdata))\n\t\t\treturn PTR_ERR(pdata);\n\n\t\tif (match->data) {\n\t\t\tdata = match->data;\n\t\t\tpdata->reg_offset = data->reg_offset;\n\t\t\tpdata->controller_flags |= data->controller_flags;\n\t\t}\n\t}\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"Platform Data is missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tmmc = mmc_alloc_host(sizeof(struct omap_hsmmc_host), &pdev->dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err1;\n\n\thost\t\t= mmc_priv(mmc);\n\thost->mmc\t= mmc;\n\thost->pdata\t= pdata;\n\thost->dev\t= &pdev->dev;\n\thost->use_dma\t= 1;\n\thost->dma_ch\t= -1;\n\thost->irq\t= irq;\n\thost->mapbase\t= res->start + pdata->reg_offset;\n\thost->base\t= base + pdata->reg_offset;\n\thost->power_mode = MMC_POWER_OFF;\n\thost->next_data.cookie = 1;\n\thost->pbias_enabled = false;\n\thost->vqmmc_enabled = false;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tif (pdev->dev.of_node)\n\t\thost->wake_irq = irq_of_parse_and_map(pdev->dev.of_node, 1);\n\n\tmmc->ops\t= &omap_hsmmc_ops;\n\n\tmmc->f_min = OMAP_MMC_MIN_CLOCK;\n\n\tif (pdata->max_freq > 0)\n\t\tmmc->f_max = pdata->max_freq;\n\telse if (mmc->f_max == 0)\n\t\tmmc->f_max = OMAP_MMC_MAX_CLOCK;\n\n\tspin_lock_init(&host->irq_lock);\n\n\thost->fclk = devm_clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(host->fclk)) {\n\t\tret = PTR_ERR(host->fclk);\n\t\thost->fclk = NULL;\n\t\tgoto err1;\n\t}\n\n\tif (host->pdata->controller_flags & OMAP_HSMMC_BROKEN_MULTIBLOCK_READ) {\n\t\tdev_info(&pdev->dev, \"multiblock reads disabled due to 35xx erratum 2.1.1.128; MMC read performance may suffer\\n\");\n\t\tomap_hsmmc_ops.multi_io_quirk = omap_hsmmc_multi_io_quirk;\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, true);\n\tpm_runtime_enable(host->dev);\n\tpm_runtime_get_sync(host->dev);\n\tpm_runtime_set_autosuspend_delay(host->dev, MMC_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(host->dev);\n\n\tomap_hsmmc_context_save(host);\n\n\thost->dbclk = devm_clk_get(&pdev->dev, \"mmchsdb_fck\");\n\t \n\tif (IS_ERR(host->dbclk)) {\n\t\thost->dbclk = NULL;\n\t} else if (clk_prepare_enable(host->dbclk) != 0) {\n\t\tdev_warn(mmc_dev(host->mmc), \"Failed to enable debounce clk\\n\");\n\t\thost->dbclk = NULL;\n\t}\n\n\t \n\tmmc->max_segs = 64;\n\n\tmmc->max_blk_size = 512;        \n\tmmc->max_blk_count = 0xFFFF;     \n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\n\tmmc->caps |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |\n\t\t     MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_CMD23;\n\n\tmmc->caps |= mmc_pdata(host)->caps;\n\tif (mmc->caps & MMC_CAP_8_BIT_DATA)\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\tif (mmc_pdata(host)->nonremovable)\n\t\tmmc->caps |= MMC_CAP_NONREMOVABLE;\n\n\tmmc->pm_caps |= mmc_pdata(host)->pm_caps;\n\n\tomap_hsmmc_conf_bus_power(host);\n\n\thost->rx_chan = dma_request_chan(&pdev->dev, \"rx\");\n\tif (IS_ERR(host->rx_chan)) {\n\t\tdev_err(mmc_dev(host->mmc), \"RX DMA channel request failed\\n\");\n\t\tret = PTR_ERR(host->rx_chan);\n\t\tgoto err_irq;\n\t}\n\n\thost->tx_chan = dma_request_chan(&pdev->dev, \"tx\");\n\tif (IS_ERR(host->tx_chan)) {\n\t\tdev_err(mmc_dev(host->mmc), \"TX DMA channel request failed\\n\");\n\t\tret = PTR_ERR(host->tx_chan);\n\t\tgoto err_irq;\n\t}\n\n\t \n\tmmc->max_seg_size = min3(mmc->max_req_size,\n\t\t\tdma_get_max_seg_size(host->rx_chan->device->dev),\n\t\t\tdma_get_max_seg_size(host->tx_chan->device->dev));\n\n\t \n\tret = devm_request_irq(&pdev->dev, host->irq, omap_hsmmc_irq, 0,\n\t\t\tmmc_hostname(mmc), host);\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"Unable to grab HSMMC IRQ\\n\");\n\t\tgoto err_irq;\n\t}\n\n\tret = omap_hsmmc_reg_get(host);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tif (!mmc->ocr_avail)\n\t\tmmc->ocr_avail = mmc_pdata(host)->ocr_mask;\n\n\tomap_hsmmc_disable_irq(host);\n\n\t \n\tret = omap_hsmmc_configure_wake_irq(host);\n\tif (!ret)\n\t\tmmc->caps |= MMC_CAP_SDIO_IRQ;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto err_irq;\n\n\tif (mmc_pdata(host)->name != NULL) {\n\t\tret = device_create_file(&mmc->class_dev, &dev_attr_slot_name);\n\t\tif (ret < 0)\n\t\t\tgoto err_slot_name;\n\t}\n\n\tomap_hsmmc_debugfs(mmc);\n\tpm_runtime_mark_last_busy(host->dev);\n\tpm_runtime_put_autosuspend(host->dev);\n\n\treturn 0;\n\nerr_slot_name:\n\tmmc_remove_host(mmc);\nerr_irq:\n\tdevice_init_wakeup(&pdev->dev, false);\n\tif (!IS_ERR_OR_NULL(host->tx_chan))\n\t\tdma_release_channel(host->tx_chan);\n\tif (!IS_ERR_OR_NULL(host->rx_chan))\n\t\tdma_release_channel(host->rx_chan);\n\tpm_runtime_dont_use_autosuspend(host->dev);\n\tpm_runtime_put_sync(host->dev);\n\tpm_runtime_disable(host->dev);\n\tclk_disable_unprepare(host->dbclk);\nerr1:\n\tmmc_free_host(mmc);\nerr:\n\treturn ret;\n}\n\nstatic void omap_hsmmc_remove(struct platform_device *pdev)\n{\n\tstruct omap_hsmmc_host *host = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(host->dev);\n\tmmc_remove_host(host->mmc);\n\n\tdma_release_channel(host->tx_chan);\n\tdma_release_channel(host->rx_chan);\n\n\tdev_pm_clear_wake_irq(host->dev);\n\tpm_runtime_dont_use_autosuspend(host->dev);\n\tpm_runtime_put_sync(host->dev);\n\tpm_runtime_disable(host->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n\tclk_disable_unprepare(host->dbclk);\n\n\tmmc_free_host(host->mmc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int omap_hsmmc_suspend(struct device *dev)\n{\n\tstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\n\n\tif (!host)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(host->dev);\n\n\tif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER)) {\n\t\tOMAP_HSMMC_WRITE(host->base, ISE, 0);\n\t\tOMAP_HSMMC_WRITE(host->base, IE, 0);\n\t\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\t\tOMAP_HSMMC_WRITE(host->base, HCTL,\n\t\t\t\tOMAP_HSMMC_READ(host->base, HCTL) & ~SDBP);\n\t}\n\n\tclk_disable_unprepare(host->dbclk);\n\n\tpm_runtime_put_sync(host->dev);\n\treturn 0;\n}\n\n \nstatic int omap_hsmmc_resume(struct device *dev)\n{\n\tstruct omap_hsmmc_host *host = dev_get_drvdata(dev);\n\n\tif (!host)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(host->dev);\n\n\tclk_prepare_enable(host->dbclk);\n\n\tif (!(host->mmc->pm_flags & MMC_PM_KEEP_POWER))\n\t\tomap_hsmmc_conf_bus_power(host);\n\n\tpm_runtime_mark_last_busy(host->dev);\n\tpm_runtime_put_autosuspend(host->dev);\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int omap_hsmmc_runtime_suspend(struct device *dev)\n{\n\tstruct omap_hsmmc_host *host;\n\tunsigned long flags;\n\tint ret = 0;\n\n\thost = dev_get_drvdata(dev);\n\tomap_hsmmc_context_save(host);\n\tdev_dbg(dev, \"disabled\\n\");\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\tif ((host->mmc->caps & MMC_CAP_SDIO_IRQ) &&\n\t    (host->flags & HSMMC_SDIO_IRQ_ENABLED)) {\n\t\t \n\t\tOMAP_HSMMC_WRITE(host->base, ISE, 0);\n\t\tOMAP_HSMMC_WRITE(host->base, IE, 0);\n\n\t\tif (!(OMAP_HSMMC_READ(host->base, PSTATE) & DLEV_DAT(1))) {\n\t\t\t \n\t\t\tdev_dbg(dev, \"pending sdio irq, abort suspend\\n\");\n\t\t\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\t\t\tOMAP_HSMMC_WRITE(host->base, ISE, CIRQ_EN);\n\t\t\tOMAP_HSMMC_WRITE(host->base, IE, CIRQ_EN);\n\t\t\tpm_runtime_mark_last_busy(dev);\n\t\t\tret = -EBUSY;\n\t\t\tgoto abort;\n\t\t}\n\n\t\tpinctrl_pm_select_idle_state(dev);\n\t} else {\n\t\tpinctrl_pm_select_idle_state(dev);\n\t}\n\nabort:\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n\treturn ret;\n}\n\nstatic int omap_hsmmc_runtime_resume(struct device *dev)\n{\n\tstruct omap_hsmmc_host *host;\n\tunsigned long flags;\n\n\thost = dev_get_drvdata(dev);\n\tomap_hsmmc_context_restore(host);\n\tdev_dbg(dev, \"enabled\\n\");\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\tif ((host->mmc->caps & MMC_CAP_SDIO_IRQ) &&\n\t    (host->flags & HSMMC_SDIO_IRQ_ENABLED)) {\n\n\t\tpinctrl_select_default_state(host->dev);\n\n\t\t \n\t\tOMAP_HSMMC_WRITE(host->base, STAT, STAT_CLEAR);\n\t\tOMAP_HSMMC_WRITE(host->base, ISE, CIRQ_EN);\n\t\tOMAP_HSMMC_WRITE(host->base, IE, CIRQ_EN);\n\t} else {\n\t\tpinctrl_select_default_state(host->dev);\n\t}\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops omap_hsmmc_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(omap_hsmmc_suspend, omap_hsmmc_resume)\n\tSET_RUNTIME_PM_OPS(omap_hsmmc_runtime_suspend, omap_hsmmc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver omap_hsmmc_driver = {\n\t.probe\t\t= omap_hsmmc_probe,\n\t.remove_new\t= omap_hsmmc_remove,\n\t.driver\t\t= {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = &omap_hsmmc_dev_pm_ops,\n\t\t.of_match_table = of_match_ptr(omap_mmc_of_match),\n\t},\n};\n\nmodule_platform_driver(omap_hsmmc_driver);\nMODULE_DESCRIPTION(\"OMAP High Speed Multimedia Card driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Texas Instruments Inc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}