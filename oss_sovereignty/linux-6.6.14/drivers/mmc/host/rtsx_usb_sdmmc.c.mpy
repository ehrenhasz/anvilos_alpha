{
  "module_name": "rtsx_usb_sdmmc.c",
  "hash_id": "8af673bca31a9b7a2c9984b43478ffd25bc83924d3db4915fd530843c43c42a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/rtsx_usb_sdmmc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/card.h>\n#include <linux/scatterlist.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/rtsx_usb.h>\n#include <asm/unaligned.h>\n\n#if defined(CONFIG_LEDS_CLASS) || (defined(CONFIG_LEDS_CLASS_MODULE) && \\\n\t\tdefined(CONFIG_MMC_REALTEK_USB_MODULE))\n#include <linux/leds.h>\n#include <linux/workqueue.h>\n#define RTSX_USB_USE_LEDS_CLASS\n#endif\n\nstruct rtsx_usb_sdmmc {\n\tstruct platform_device\t*pdev;\n\tstruct rtsx_ucr\t*ucr;\n\tstruct mmc_host\t\t*mmc;\n\tstruct mmc_request\t*mrq;\n\n\tstruct mutex\t\thost_mutex;\n\n\tu8\t\t\tssc_depth;\n\tunsigned int\t\tclock;\n\tbool\t\t\tvpclk;\n\tbool\t\t\tdouble_clk;\n\tbool\t\t\thost_removal;\n\tbool\t\t\tcard_exist;\n\tbool\t\t\tinitial_mode;\n\tbool\t\t\tddr_mode;\n\n\tunsigned char\t\tpower_mode;\n\n#ifdef RTSX_USB_USE_LEDS_CLASS\n\tstruct led_classdev\tled;\n\tchar\t\t\tled_name[32];\n\tstruct work_struct\tled_work;\n#endif\n};\n\nstatic inline struct device *sdmmc_dev(struct rtsx_usb_sdmmc *host)\n{\n\treturn &(host->pdev->dev);\n}\n\nstatic inline void sd_clear_error(struct rtsx_usb_sdmmc *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\trtsx_usb_ep0_write_register(ucr, CARD_STOP,\n\t\t\t\t  SD_STOP | SD_CLR_ERR,\n\t\t\t\t  SD_STOP | SD_CLR_ERR);\n\n\trtsx_usb_clear_dma_err(ucr);\n\trtsx_usb_clear_fsm_err(ucr);\n}\n\n#ifdef DEBUG\nstatic void sd_print_debug_regs(struct rtsx_usb_sdmmc *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tu8 val = 0;\n\n\trtsx_usb_ep0_read_register(ucr, SD_STAT1, &val);\n\tdev_dbg(sdmmc_dev(host), \"SD_STAT1: 0x%x\\n\", val);\n\trtsx_usb_ep0_read_register(ucr, SD_STAT2, &val);\n\tdev_dbg(sdmmc_dev(host), \"SD_STAT2: 0x%x\\n\", val);\n\trtsx_usb_ep0_read_register(ucr, SD_BUS_STAT, &val);\n\tdev_dbg(sdmmc_dev(host), \"SD_BUS_STAT: 0x%x\\n\", val);\n}\n#else\n#define sd_print_debug_regs(host)\n#endif  \n\nstatic int sd_read_data(struct rtsx_usb_sdmmc *host, struct mmc_command *cmd,\n\t       u16 byte_cnt, u8 *buf, int buf_len, int timeout)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu8 trans_mode;\n\n\tif (!buf)\n\t\tbuf_len = 0;\n\n\trtsx_usb_init_cmd(ucr);\n\tif (cmd != NULL) {\n\t\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD%d\\n\", __func__\n\t\t\t\t, cmd->opcode);\n\t\tif (cmd->opcode == MMC_SEND_TUNING_BLOCK)\n\t\t\ttrans_mode = SD_TM_AUTO_TUNING;\n\t\telse\n\t\t\ttrans_mode = SD_TM_NORMAL_READ;\n\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD0, 0xFF, (u8)(cmd->opcode) | 0x40);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD1, 0xFF, (u8)(cmd->arg >> 24));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD2, 0xFF, (u8)(cmd->arg >> 16));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD3, 0xFF, (u8)(cmd->arg >> 8));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD4, 0xFF, (u8)cmd->arg);\n\t} else {\n\t\ttrans_mode = SD_TM_AUTO_READ_3;\n\t}\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, (u8)byte_cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H,\n\t\t\t0xFF, (u8)(byte_cnt >> 8));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L, 0xFF, 1);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H, 0xFF, 0);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF,\n\t\t\tSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\t\tSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_6);\n\tif (trans_mode != SD_TM_AUTO_TUNING)\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tCARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER,\n\t\t\t0xFF, trans_mode | SD_TRANSFER_START);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\n\tif (cmd != NULL) {\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD1, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD2, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD3, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD4, 0, 0);\n\t}\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, timeout);\n\tif (err) {\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_usb_send_cmd failed (err = %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = rtsx_usb_get_rsp(ucr, !cmd ? 1 : 5, timeout);\n\tif (err || (ucr->rsp_buf[0] & SD_TRANSFER_ERR)) {\n\t\tsd_print_debug_regs(host);\n\n\t\tif (!err) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"Transfer failed (SD_TRANSFER = %02x)\\n\",\n\t\t\t\tucr->rsp_buf[0]);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_usb_get_rsp failed (err = %d)\\n\", err);\n\t\t}\n\n\t\treturn err;\n\t}\n\n\tif (cmd != NULL) {\n\t\tcmd->resp[0] = get_unaligned_be32(ucr->rsp_buf + 1);\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[0] = 0x%08x\\n\",\n\t\t\t\tcmd->resp[0]);\n\t}\n\n\tif (buf && buf_len) {\n\t\t \n\t\terr = rtsx_usb_read_ppbuf(ucr, buf, byte_cnt - (byte_cnt % 2));\n\t\tif (err) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_usb_read_ppbuf failed (err = %d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (byte_cnt % 2)\n\t\t\treturn rtsx_usb_read_register(ucr,\n\t\t\t\t\tPPBUF_BASE2 + byte_cnt,\n\t\t\t\t\tbuf + byte_cnt - 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int sd_write_data(struct rtsx_usb_sdmmc *host, struct mmc_command *cmd,\n\t\tu16 byte_cnt, u8 *buf, int buf_len, int timeout)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu8 trans_mode;\n\n\tif (!buf)\n\t\tbuf_len = 0;\n\n\tif (buf && buf_len) {\n\t\terr = rtsx_usb_write_ppbuf(ucr, buf, buf_len);\n\t\tif (err) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_usb_write_ppbuf failed (err = %d)\\n\",\n\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\ttrans_mode = (cmd != NULL) ? SD_TM_AUTO_WRITE_2 : SD_TM_AUTO_WRITE_3;\n\trtsx_usb_init_cmd(ucr);\n\n\tif (cmd != NULL) {\n\t\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD%d\\n\", __func__,\n\t\t\t\tcmd->opcode);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD0, 0xFF, (u8)(cmd->opcode) | 0x40);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD1, 0xFF, (u8)(cmd->arg >> 24));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD2, 0xFF, (u8)(cmd->arg >> 16));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD3, 0xFF, (u8)(cmd->arg >> 8));\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CMD4, 0xFF, (u8)cmd->arg);\n\t}\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, (u8)byte_cnt);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H,\n\t\t\t0xFF, (u8)(byte_cnt >> 8));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L, 0xFF, 1);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H, 0xFF, 0);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF,\n\t\tSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\tSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_6);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\tCARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\n\t\t\ttrans_mode | SD_TRANSFER_START);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\n\tif (cmd != NULL) {\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD1, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD2, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD3, 0, 0);\n\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_CMD4, 0, 0);\n\t}\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, timeout);\n\tif (err) {\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_usb_send_cmd failed (err = %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = rtsx_usb_get_rsp(ucr, !cmd ? 1 : 5, timeout);\n\tif (err) {\n\t\tsd_print_debug_regs(host);\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_usb_get_rsp failed (err = %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (cmd != NULL) {\n\t\tcmd->resp[0] = get_unaligned_be32(ucr->rsp_buf + 1);\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[0] = 0x%08x\\n\",\n\t\t\t\tcmd->resp[0]);\n\t}\n\n\treturn 0;\n}\n\nstatic void sd_send_cmd_get_rsp(struct rtsx_usb_sdmmc *host,\n\t\tstruct mmc_command *cmd)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tu8 cmd_idx = (u8)cmd->opcode;\n\tu32 arg = cmd->arg;\n\tint err = 0;\n\tint timeout = 100;\n\tint i;\n\tu8 *ptr;\n\tint stat_idx = 0;\n\tint len = 2;\n\tu8 rsp_type;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t\t__func__, cmd_idx, arg);\n\n\t \n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\trsp_type = SD_RSP_TYPE_R0;\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\t\trsp_type = SD_RSP_TYPE_R1;\n\t\tbreak;\n\tcase MMC_RSP_R1_NO_CRC:\n\t\trsp_type = SD_RSP_TYPE_R1 | SD_NO_CHECK_CRC7;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\trsp_type = SD_RSP_TYPE_R1b;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\trsp_type = SD_RSP_TYPE_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\trsp_type = SD_RSP_TYPE_R3;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->flag is not valid\\n\");\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (rsp_type == SD_RSP_TYPE_R1b)\n\t\ttimeout = cmd->busy_timeout ? cmd->busy_timeout : 3000;\n\n\tif (cmd->opcode == SD_SWITCH_VOLTAGE) {\n\t\terr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\n\t\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\n\t\t\t\tSD_CLK_TOGGLE_EN);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD0, 0xFF, 0x40 | cmd_idx);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD1, 0xFF, (u8)(arg >> 24));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD2, 0xFF, (u8)(arg >> 16));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD3, 0xFF, (u8)(arg >> 8));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CMD4, 0xFF, (u8)arg);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF, rsp_type);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER,\n\t\t\t0xFF, SD_TM_CMD_RSP | SD_TRANSFER_START);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t     SD_TRANSFER_END | SD_STAT_IDLE,\n\t\t     SD_TRANSFER_END | SD_STAT_IDLE);\n\n\tif (rsp_type == SD_RSP_TYPE_R2) {\n\t\t \n\t\tfor (i = PPBUF_BASE2; i < PPBUF_BASE2 + 16; i++)\n\t\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, (u16)i, 0, 0);\n\t\tstat_idx = 16;\n\t} else if (rsp_type != SD_RSP_TYPE_R0) {\n\t\t \n\t\tfor (i = SD_CMD0; i <= SD_CMD4; i++)\n\t\t\trtsx_usb_add_cmd(ucr, READ_REG_CMD, (u16)i, 0, 0);\n\t\tstat_idx = 5;\n\t}\n\tlen += stat_idx;\n\n\trtsx_usb_add_cmd(ucr, READ_REG_CMD, SD_STAT1, 0, 0);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_CR, 100);\n\tif (err) {\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_usb_send_cmd error (err = %d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = rtsx_usb_get_rsp(ucr, len, timeout);\n\tif (err || (ucr->rsp_buf[0] & SD_TRANSFER_ERR)) {\n\t\tsd_print_debug_regs(host);\n\t\tsd_clear_error(host);\n\n\t\tif (!err) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"Transfer failed (SD_TRANSFER = %02x)\\n\",\n\t\t\t\t\tucr->rsp_buf[0]);\n\t\t\terr = -EIO;\n\t\t} else {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_usb_get_rsp failed (err = %d)\\n\", err);\n\t\t}\n\n\t\tgoto out;\n\t}\n\n\tif (rsp_type == SD_RSP_TYPE_R0) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = ucr->rsp_buf + 1;\n\n\t \n\tif ((ptr[0] & 0xC0) != 0) {\n\t\terr = -EILSEQ;\n\t\tdev_dbg(sdmmc_dev(host), \"Invalid response bit\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(rsp_type & SD_NO_CHECK_CRC7)) {\n\t\tif (ptr[stat_idx] & SD_CRC7_ERR) {\n\t\t\terr = -EILSEQ;\n\t\t\tdev_dbg(sdmmc_dev(host), \"CRC7 error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rsp_type == SD_RSP_TYPE_R2) {\n\t\t \n\t\tptr[16] = 1;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcmd->resp[i] = get_unaligned_be32(ptr + 1 + i * 4);\n\t\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[%d] = 0x%08x\\n\",\n\t\t\t\t\ti, cmd->resp[i]);\n\t\t}\n\t} else {\n\t\tcmd->resp[0] = get_unaligned_be32(ptr + 1);\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[0] = 0x%08x\\n\",\n\t\t\t\tcmd->resp[0]);\n\t}\n\nout:\n\tcmd->error = err;\n}\n\nstatic int sd_rw_multi(struct rtsx_usb_sdmmc *host, struct mmc_request *mrq)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tstruct mmc_data *data = mrq->data;\n\tint read = (data->flags & MMC_DATA_READ) ? 1 : 0;\n\tu8 cfg2, trans_mode;\n\tint err;\n\tu8 flag;\n\tsize_t data_len = data->blksz * data->blocks;\n\tunsigned int pipe;\n\n\tif (read) {\n\t\tdev_dbg(sdmmc_dev(host), \"%s: read %zu bytes\\n\",\n\t\t\t\t__func__, data_len);\n\t\tcfg2 = SD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\t\tSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_0;\n\t\ttrans_mode = SD_TM_AUTO_READ_3;\n\t} else {\n\t\tdev_dbg(sdmmc_dev(host), \"%s: write %zu bytes\\n\",\n\t\t\t\t__func__, data_len);\n\t\tcfg2 = SD_NO_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\t\tSD_NO_WAIT_BUSY_END | SD_NO_CHECK_CRC7 | SD_RSP_LEN_0;\n\t\ttrans_mode = SD_TM_AUTO_WRITE_3;\n\t}\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, 0x00);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BYTE_CNT_H, 0xFF, 0x02);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_L,\n\t\t\t0xFF, (u8)data->blocks);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BLOCK_CNT_H,\n\t\t\t0xFF, (u8)(data->blocks >> 8));\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, RING_BUFFER);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC3,\n\t\t\t0xFF, (u8)(data_len >> 24));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC2,\n\t\t\t0xFF, (u8)(data_len >> 16));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC1,\n\t\t\t0xFF, (u8)(data_len >> 8));\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_TC0,\n\t\t\t0xFF, (u8)data_len);\n\tif (read) {\n\t\tflag = MODE_CDIR;\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\n\t\t\t\t0x03 | DMA_PACK_SIZE_MASK,\n\t\t\t\tDMA_DIR_FROM_CARD | DMA_EN | DMA_512);\n\t} else {\n\t\tflag = MODE_CDOR;\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, MC_DMA_CTL,\n\t\t\t\t0x03 | DMA_PACK_SIZE_MASK,\n\t\t\t\tDMA_DIR_TO_CARD | DMA_EN | DMA_512);\n\t}\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG2, 0xFF, cfg2);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\n\t\t\ttrans_mode | SD_TRANSFER_START);\n\trtsx_usb_add_cmd(ucr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\n\terr = rtsx_usb_send_cmd(ucr, flag, 100);\n\tif (err)\n\t\treturn err;\n\n\tif (read)\n\t\tpipe = usb_rcvbulkpipe(ucr->pusb_dev, EP_BULK_IN);\n\telse\n\t\tpipe = usb_sndbulkpipe(ucr->pusb_dev, EP_BULK_OUT);\n\n\terr = rtsx_usb_transfer_data(ucr, pipe, data->sg, data_len,\n\t\t\tdata->sg_len,  NULL, 10000);\n\tif (err) {\n\t\tdev_dbg(sdmmc_dev(host), \"rtsx_usb_transfer_data error %d\\n\"\n\t\t\t\t, err);\n\t\tsd_clear_error(host);\n\t\treturn err;\n\t}\n\n\treturn rtsx_usb_get_rsp(ucr, 1, 2000);\n}\n\nstatic inline void sd_enable_initial_mode(struct rtsx_usb_sdmmc *host)\n{\n\trtsx_usb_write_register(host->ucr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_128);\n}\n\nstatic inline void sd_disable_initial_mode(struct rtsx_usb_sdmmc *host)\n{\n\trtsx_usb_write_register(host->ucr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_0);\n}\n\nstatic void sd_normal_rw(struct rtsx_usb_sdmmc *host,\n\t\tstruct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tu8 *buf;\n\n\tbuf = kzalloc(data->blksz, GFP_NOIO);\n\tif (!buf) {\n\t\tcmd->error = -ENOMEM;\n\t\treturn;\n\t}\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tif (host->initial_mode)\n\t\t\tsd_disable_initial_mode(host);\n\n\t\tcmd->error = sd_read_data(host, cmd, (u16)data->blksz, buf,\n\t\t\t\tdata->blksz, 200);\n\n\t\tif (host->initial_mode)\n\t\t\tsd_enable_initial_mode(host);\n\n\t\tsg_copy_from_buffer(data->sg, data->sg_len, buf, data->blksz);\n\t} else {\n\t\tsg_copy_to_buffer(data->sg, data->sg_len, buf, data->blksz);\n\n\t\tcmd->error = sd_write_data(host, cmd, (u16)data->blksz, buf,\n\t\t\t\tdata->blksz, 200);\n\t}\n\n\tkfree(buf);\n}\n\nstatic int sd_change_phase(struct rtsx_usb_sdmmc *host, u8 sample_point, int tx)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: %s sample_point = %d\\n\",\n\t\t\t__func__, tx ? \"TX\" : \"RX\", sample_point);\n\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, CLK_CHANGE);\n\n\tif (tx)\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\t\t0x0F, sample_point);\n\telse\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK1_CTL,\n\t\t\t\t0x0F, sample_point);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL, PHASE_NOT_RESET, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_VPCLK0_CTL,\n\t\t\tPHASE_NOT_RESET, PHASE_NOT_RESET);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CLK_DIV, CLK_CHANGE, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1, SD_ASYNC_FIFO_RST, 0);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic inline u32 get_phase_point(u32 phase_map, unsigned int idx)\n{\n\tidx &= MAX_PHASE;\n\treturn phase_map & (1 << idx);\n}\n\nstatic int get_phase_len(u32 phase_map, unsigned int idx)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_PHASE + 1; i++) {\n\t\tif (get_phase_point(phase_map, idx + i) == 0)\n\t\t\treturn i;\n\t}\n\treturn MAX_PHASE + 1;\n}\n\nstatic u8 sd_search_final_phase(struct rtsx_usb_sdmmc *host, u32 phase_map)\n{\n\tint start = 0, len = 0;\n\tint start_final = 0, len_final = 0;\n\tu8 final_phase = 0xFF;\n\n\tif (phase_map == 0) {\n\t\tdev_dbg(sdmmc_dev(host), \"Phase: [map:%x]\\n\", phase_map);\n\t\treturn final_phase;\n\t}\n\n\twhile (start < MAX_PHASE + 1) {\n\t\tlen = get_phase_len(phase_map, start);\n\t\tif (len_final < len) {\n\t\t\tstart_final = start;\n\t\t\tlen_final = len;\n\t\t}\n\t\tstart += len ? len : 1;\n\t}\n\n\tfinal_phase = (start_final + len_final / 2) & MAX_PHASE;\n\tdev_dbg(sdmmc_dev(host), \"Phase: [map:%x] [maxlen:%d] [final:%d]\\n\",\n\t\tphase_map, len_final, final_phase);\n\n\treturn final_phase;\n}\n\nstatic void sd_wait_data_idle(struct rtsx_usb_sdmmc *host)\n{\n\tint i;\n\tu8 val = 0;\n\n\tfor (i = 0; i < 100; i++) {\n\t\trtsx_usb_ep0_read_register(host->ucr, SD_DATA_STATE, &val);\n\t\tif (val & SD_DATA_IDLE)\n\t\t\treturn;\n\n\t\tusleep_range(100, 1000);\n\t}\n}\n\nstatic int sd_tuning_rx_cmd(struct rtsx_usb_sdmmc *host,\n\t\tu8 opcode, u8 sample_point)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\terr = sd_change_phase(host, sample_point, 0);\n\tif (err)\n\t\treturn err;\n\n\tcmd.opcode = MMC_SEND_TUNING_BLOCK;\n\terr = sd_read_data(host, &cmd, 0x40, NULL, 0, 100);\n\tif (err) {\n\t\t \n\t\tsd_wait_data_idle(host);\n\t\tsd_clear_error(host);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void sd_tuning_phase(struct rtsx_usb_sdmmc *host,\n\t\tu8 opcode, u16 *phase_map)\n{\n\tint err, i;\n\tu16 raw_phase_map = 0;\n\n\tfor (i = MAX_PHASE; i >= 0; i--) {\n\t\terr = sd_tuning_rx_cmd(host, opcode, (u8)i);\n\t\tif (!err)\n\t\t\traw_phase_map |= 1 << i;\n\t}\n\n\tif (phase_map)\n\t\t*phase_map = raw_phase_map;\n}\n\nstatic int sd_tuning_rx(struct rtsx_usb_sdmmc *host, u8 opcode)\n{\n\tint err, i;\n\tu16 raw_phase_map[RX_TUNING_CNT] = {0}, phase_map;\n\tu8 final_phase;\n\n\t \n\terr = sd_change_phase(host, 0x01, 1);\n\tif (err) {\n\t\tdev_dbg(sdmmc_dev(host), \"TX phase setting failed\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tfor (i = 0; i < RX_TUNING_CNT; i++) {\n\t\tsd_tuning_phase(host, opcode, &(raw_phase_map[i]));\n\n\t\tif (raw_phase_map[i] == 0)\n\t\t\tbreak;\n\t}\n\n\tphase_map = 0xFFFF;\n\tfor (i = 0; i < RX_TUNING_CNT; i++) {\n\t\tdev_dbg(sdmmc_dev(host), \"RX raw_phase_map[%d] = 0x%04x\\n\",\n\t\t\t\ti, raw_phase_map[i]);\n\t\tphase_map &= raw_phase_map[i];\n\t}\n\tdev_dbg(sdmmc_dev(host), \"RX phase_map = 0x%04x\\n\", phase_map);\n\n\tif (phase_map) {\n\t\tfinal_phase = sd_search_final_phase(host, phase_map);\n\t\tif (final_phase == 0xFF)\n\t\t\treturn -EINVAL;\n\n\t\terr = sd_change_phase(host, final_phase, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdmmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu16 val;\n\n\tif (host->host_removal)\n\t\treturn -ENOMEDIUM;\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\t \n\terr = rtsx_usb_get_card_status(ucr, &val);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\n\n\t \n\tif (err)\n\t\treturn 0;\n\n\tif (val & SD_WP)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int sdmmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu16 val;\n\n\tif (host->host_removal)\n\t\treturn -ENOMEDIUM;\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\t \n\terr = rtsx_usb_get_card_status(ucr, &val);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\n\t \n\tif (err)\n\t\tgoto no_card;\n\n\tif (val & SD_CD) {\n\t\thost->card_exist = true;\n\t\treturn 1;\n\t}\n\nno_card:\n\thost->card_exist = false;\n\treturn 0;\n}\n\nstatic void sdmmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tunsigned int data_size = 0;\n\n\tdev_dbg(sdmmc_dev(host), \"%s\\n\", __func__);\n\n\tif (host->host_removal) {\n\t\tcmd->error = -ENOMEDIUM;\n\t\tgoto finish;\n\t}\n\n\tif ((!host->card_exist)) {\n\t\tcmd->error = -ENOMEDIUM;\n\t\tgoto finish_detect_card;\n\t}\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\tmutex_lock(&host->host_mutex);\n\thost->mrq = mrq;\n\tmutex_unlock(&host->host_mutex);\n\n\tif (mrq->data)\n\t\tdata_size = data->blocks * data->blksz;\n\n\tif (!data_size) {\n\t\tsd_send_cmd_get_rsp(host, cmd);\n\t} else if ((!(data_size % 512) && cmd->opcode != MMC_SEND_EXT_CSD) ||\n\t\t   mmc_op_multi(cmd->opcode)) {\n\t\tsd_send_cmd_get_rsp(host, cmd);\n\n\t\tif (!cmd->error) {\n\t\t\tsd_rw_multi(host, mrq);\n\n\t\t\tif (mmc_op_multi(cmd->opcode) && mrq->stop) {\n\t\t\t\tsd_send_cmd_get_rsp(host, mrq->stop);\n\t\t\t\trtsx_usb_write_register(ucr, MC_FIFO_CTL,\n\t\t\t\t\t\tFIFO_FLUSH, FIFO_FLUSH);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsd_normal_rw(host, mrq);\n\t}\n\n\tif (mrq->data) {\n\t\tif (cmd->error || data->error)\n\t\t\tdata->bytes_xfered = 0;\n\t\telse\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t}\n\n\tmutex_unlock(&ucr->dev_mutex);\n\nfinish_detect_card:\n\tif (cmd->error) {\n\t\t \n\t\tsdmmc_get_cd(mmc);\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->error = %d\\n\", cmd->error);\n\t}\n\nfinish:\n\tmutex_lock(&host->host_mutex);\n\thost->mrq = NULL;\n\tmutex_unlock(&host->host_mutex);\n\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic int sd_set_bus_width(struct rtsx_usb_sdmmc *host,\n\t\tunsigned char bus_width)\n{\n\tint err = 0;\n\tstatic const u8 width[] = {\n\t\t[MMC_BUS_WIDTH_1] = SD_BUS_WIDTH_1BIT,\n\t\t[MMC_BUS_WIDTH_4] = SD_BUS_WIDTH_4BIT,\n\t\t[MMC_BUS_WIDTH_8] = SD_BUS_WIDTH_8BIT,\n\t};\n\n\tif (bus_width <= MMC_BUS_WIDTH_8)\n\t\terr = rtsx_usb_write_register(host->ucr, SD_CFG1,\n\t\t\t\t0x03, width[bus_width]);\n\n\treturn err;\n}\n\nstatic int sd_pull_ctl_disable_lqfp48(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int sd_pull_ctl_disable_qfn24(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0x65);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0x95);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x56);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x59);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int sd_pull_ctl_enable_lqfp48(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xAA);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0xAA);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0xA9);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x55);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0xA5);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int sd_pull_ctl_enable_qfn24(struct rtsx_ucr *ucr)\n{\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL1, 0xFF, 0xA5);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL2, 0xFF, 0x9A);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL3, 0xFF, 0xA5);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL4, 0xFF, 0x9A);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL5, 0xFF, 0x65);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PULL_CTL6, 0xFF, 0x5A);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int sd_power_on(struct rtsx_usb_sdmmc *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\n\tdev_dbg(sdmmc_dev(host), \"%s\\n\", __func__);\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SELECT, 0x07, SD_MOD_SEL);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_SD);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN,\n\t\t\tSD_CLK_EN, SD_CLK_EN);\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (err)\n\t\treturn err;\n\n\tif (CHECK_PKG(ucr, LQFP48))\n\t\terr = sd_pull_ctl_enable_lqfp48(ucr);\n\telse\n\t\terr = sd_pull_ctl_enable_qfn24(ucr);\n\tif (err)\n\t\treturn err;\n\n\terr = rtsx_usb_write_register(ucr, CARD_PWR_CTL,\n\t\t\tPOWER_MASK, PARTIAL_POWER_ON);\n\tif (err)\n\t\treturn err;\n\n\tusleep_range(800, 1000);\n\n\trtsx_usb_init_cmd(ucr);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\tPOWER_MASK|LDO3318_PWR_MASK, POWER_ON|LDO_ON);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE,\n\t\t\tSD_OUTPUT_EN, SD_OUTPUT_EN);\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic int sd_power_off(struct rtsx_usb_sdmmc *host)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\n\tdev_dbg(sdmmc_dev(host), \"%s\\n\", __func__);\n\trtsx_usb_init_cmd(ucr);\n\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_EN, SD_CLK_EN, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_OE, SD_OUTPUT_EN, 0);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\tPOWER_MASK, POWER_OFF);\n\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_PWR_CTL,\n\t\t\tPOWER_MASK|LDO3318_PWR_MASK, POWER_OFF|LDO_SUSPEND);\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tif (err)\n\t\treturn err;\n\n\tif (CHECK_PKG(ucr, LQFP48))\n\t\t\treturn sd_pull_ctl_disable_lqfp48(ucr);\n\treturn sd_pull_ctl_disable_qfn24(ucr);\n}\n\nstatic int sd_set_power_mode(struct rtsx_usb_sdmmc *host,\n\t\tunsigned char power_mode)\n{\n\tint err;\n\n\tif (power_mode != MMC_POWER_OFF)\n\t\tpower_mode = MMC_POWER_ON;\n\n\tif (power_mode == host->power_mode)\n\t\treturn 0;\n\n\tif (power_mode == MMC_POWER_OFF) {\n\t\terr = sd_power_off(host);\n\t\tpm_runtime_put_noidle(sdmmc_dev(host));\n\t} else {\n\t\tpm_runtime_get_noresume(sdmmc_dev(host));\n\t\terr = sd_power_on(host);\n\t}\n\n\tif (!err)\n\t\thost->power_mode = power_mode;\n\n\treturn err;\n}\n\nstatic int sd_set_timing(struct rtsx_usb_sdmmc *host,\n\t\tunsigned char timing, bool *ddr_mode)\n{\n\tstruct rtsx_ucr *ucr = host->ucr;\n\n\t*ddr_mode = false;\n\n\trtsx_usb_init_cmd(ucr);\n\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_UHS_SDR50:\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C | SD_ASYNC_FIFO_RST,\n\t\t\t\tSD_30_MODE | SD_ASYNC_FIFO_RST);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\n\t\tbreak;\n\n\tcase MMC_TIMING_UHS_DDR50:\n\t\t*ddr_mode = true;\n\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C | SD_ASYNC_FIFO_RST,\n\t\t\t\tSD_DDR_MODE | SD_ASYNC_FIFO_RST);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\n\t\t\t\tDDR_VAR_TX_CMD_DAT, DDR_VAR_TX_CMD_DAT);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tDDR_VAR_RX_DAT | DDR_VAR_RX_CMD,\n\t\t\t\tDDR_VAR_RX_DAT | DDR_VAR_RX_CMD);\n\t\tbreak;\n\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C, SD_20_MODE);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\n\t\t\t\tSD20_TX_SEL_MASK, SD20_TX_14_AHEAD);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tSD20_RX_SEL_MASK, SD20_RX_14_DELAY);\n\t\tbreak;\n\n\tdefault:\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_CFG1, 0x0C, SD_20_MODE);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD,\n\t\t\t\tSD_PUSH_POINT_CTL, 0xFF, 0);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tSD20_RX_SEL_MASK, SD20_RX_POS_EDGE);\n\t\tbreak;\n\t}\n\n\treturn rtsx_usb_send_cmd(ucr, MODE_C, 100);\n}\n\nstatic void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\n\tdev_dbg(sdmmc_dev(host), \"%s\\n\", __func__);\n\tmutex_lock(&ucr->dev_mutex);\n\n\tsd_set_power_mode(host, ios->power_mode);\n\tsd_set_bus_width(host, ios->bus_width);\n\tsd_set_timing(host, ios->timing, &host->ddr_mode);\n\n\thost->vpclk = false;\n\thost->double_clk = true;\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_UHS_SDR50:\n\t\thost->ssc_depth = SSC_DEPTH_2M;\n\t\thost->vpclk = true;\n\t\thost->double_clk = false;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_UHS_SDR25:\n\t\thost->ssc_depth = SSC_DEPTH_1M;\n\t\tbreak;\n\tdefault:\n\t\thost->ssc_depth = SSC_DEPTH_512K;\n\t\tbreak;\n\t}\n\n\thost->initial_mode = (ios->clock <= 1000000) ? true : false;\n\thost->clock = ios->clock;\n\n\trtsx_usb_switch_clock(host->ucr, host->clock, host->ssc_depth,\n\t\t\thost->initial_mode, host->double_clk, host->vpclk);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\tdev_dbg(sdmmc_dev(host), \"%s end\\n\", __func__);\n}\n\nstatic int sdmmc_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err = 0;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: signal_voltage = %d\\n\",\n\t\t\t__func__, ios->signal_voltage);\n\n\tif (host->host_removal)\n\t\treturn -ENOMEDIUM;\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_120)\n\t\treturn -EPERM;\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\terr = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_SD_CARD);\n\tif (err) {\n\t\tmutex_unlock(&ucr->dev_mutex);\n\t\treturn err;\n\t}\n\n\t \n\trtsx_usb_init_cmd(ucr);\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PAD_CTL,\n\t\t\t\tSD_IO_USING_1V8, SD_IO_USING_3V3);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG,\n\t\t\t\tTUNE_SD18_MASK, TUNE_SD18_3V3);\n\t} else {\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_BUS_STAT,\n\t\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\n\t\t\t\tSD_CLK_FORCE_STOP);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, SD_PAD_CTL,\n\t\t\t\tSD_IO_USING_1V8, SD_IO_USING_1V8);\n\t\trtsx_usb_add_cmd(ucr, WRITE_REG_CMD, LDO_POWER_CFG,\n\t\t\t\tTUNE_SD18_MASK, TUNE_SD18_1V8);\n\t}\n\n\terr = rtsx_usb_send_cmd(ucr, MODE_C, 100);\n\tmutex_unlock(&ucr->dev_mutex);\n\n\treturn err;\n}\n\nstatic int sdmmc_card_busy(struct mmc_host *mmc)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err;\n\tu8 stat;\n\tu8 mask = SD_DAT3_STATUS | SD_DAT2_STATUS | SD_DAT1_STATUS\n\t\t| SD_DAT0_STATUS;\n\n\tdev_dbg(sdmmc_dev(host), \"%s\\n\", __func__);\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\terr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\n\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP,\n\t\t\tSD_CLK_TOGGLE_EN);\n\tif (err)\n\t\tgoto out;\n\n\tmdelay(1);\n\n\terr = rtsx_usb_read_register(ucr, SD_BUS_STAT, &stat);\n\tif (err)\n\t\tgoto out;\n\n\terr = rtsx_usb_write_register(ucr, SD_BUS_STAT,\n\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP, 0);\nout:\n\tmutex_unlock(&ucr->dev_mutex);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif ((stat & mask) != mask)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct rtsx_usb_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\tint err = 0;\n\n\tif (host->host_removal)\n\t\treturn -ENOMEDIUM;\n\n\tmutex_lock(&ucr->dev_mutex);\n\n\tif (!host->ddr_mode)\n\t\terr = sd_tuning_rx(host, MMC_SEND_TUNING_BLOCK);\n\n\tmutex_unlock(&ucr->dev_mutex);\n\n\treturn err;\n}\n\nstatic const struct mmc_host_ops rtsx_usb_sdmmc_ops = {\n\t.request = sdmmc_request,\n\t.set_ios = sdmmc_set_ios,\n\t.get_ro = sdmmc_get_ro,\n\t.get_cd = sdmmc_get_cd,\n\t.start_signal_voltage_switch = sdmmc_switch_voltage,\n\t.card_busy = sdmmc_card_busy,\n\t.execute_tuning = sdmmc_execute_tuning,\n};\n\n#ifdef RTSX_USB_USE_LEDS_CLASS\nstatic void rtsx_usb_led_control(struct led_classdev *led,\n\tenum led_brightness brightness)\n{\n\tstruct rtsx_usb_sdmmc *host = container_of(led,\n\t\t\tstruct rtsx_usb_sdmmc, led);\n\n\tif (host->host_removal)\n\t\treturn;\n\n\thost->led.brightness = brightness;\n\tschedule_work(&host->led_work);\n}\n\nstatic void rtsx_usb_update_led(struct work_struct *work)\n{\n\tstruct rtsx_usb_sdmmc *host =\n\t\tcontainer_of(work, struct rtsx_usb_sdmmc, led_work);\n\tstruct rtsx_ucr *ucr = host->ucr;\n\n\tpm_runtime_get_noresume(sdmmc_dev(host));\n\tmutex_lock(&ucr->dev_mutex);\n\n\tif (host->power_mode == MMC_POWER_OFF)\n\t\tgoto out;\n\n\tif (host->led.brightness == LED_OFF)\n\t\trtsx_usb_turn_off_led(ucr);\n\telse\n\t\trtsx_usb_turn_on_led(ucr);\n\nout:\n\tmutex_unlock(&ucr->dev_mutex);\n\tpm_runtime_put_sync_suspend(sdmmc_dev(host));\n}\n#endif\n\nstatic void rtsx_usb_init_host(struct rtsx_usb_sdmmc *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tmmc->f_min = 250000;\n\tmmc->f_max = 208000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED |\n\t\tMMC_CAP_MMC_HIGHSPEED | MMC_CAP_BUS_WIDTH_TEST |\n\t\tMMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50 |\n\t\tMMC_CAP_SYNC_RUNTIME_PM;\n\tmmc->caps2 = MMC_CAP2_NO_PRESCAN_POWERUP | MMC_CAP2_FULL_PWR_CYCLE |\n\t\tMMC_CAP2_NO_SDIO;\n\n\tmmc->max_current_330 = 400;\n\tmmc->max_current_180 = 800;\n\tmmc->ops = &rtsx_usb_sdmmc_ops;\n\tmmc->max_segs = 256;\n\tmmc->max_seg_size = 65536;\n\tmmc->max_blk_size = 512;\n\tmmc->max_blk_count = 65535;\n\tmmc->max_req_size = 524288;\n\n\thost->power_mode = MMC_POWER_OFF;\n}\n\nstatic int rtsx_usb_sdmmc_drv_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct rtsx_usb_sdmmc *host;\n\tstruct rtsx_ucr *ucr;\n#ifdef RTSX_USB_USE_LEDS_CLASS\n\tint err;\n#endif\n\tint ret;\n\n\tucr = usb_get_intfdata(to_usb_interface(pdev->dev.parent));\n\tif (!ucr)\n\t\treturn -ENXIO;\n\n\tdev_dbg(&(pdev->dev), \": Realtek USB SD/MMC controller found\\n\");\n\n\tmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->ucr = ucr;\n\thost->mmc = mmc;\n\thost->pdev = pdev;\n\tplatform_set_drvdata(pdev, host);\n\n\tmutex_init(&host->host_mutex);\n\trtsx_usb_init_host(host);\n\tpm_runtime_enable(&pdev->dev);\n\n#ifdef RTSX_USB_USE_LEDS_CLASS\n\tsnprintf(host->led_name, sizeof(host->led_name),\n\t\t\"%s::\", mmc_hostname(mmc));\n\thost->led.name = host->led_name;\n\thost->led.brightness = LED_OFF;\n\thost->led.default_trigger = mmc_hostname(mmc);\n\thost->led.brightness_set = rtsx_usb_led_control;\n\n\terr = led_classdev_register(mmc_dev(mmc), &host->led);\n\tif (err)\n\t\tdev_err(&(pdev->dev),\n\t\t\t\t\"Failed to register LED device: %d\\n\", err);\n\tINIT_WORK(&host->led_work, rtsx_usb_update_led);\n\n#endif\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n#ifdef RTSX_USB_USE_LEDS_CLASS\n\t\tled_classdev_unregister(&host->led);\n#endif\n\t\tmmc_free_host(mmc);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtsx_usb_sdmmc_drv_remove(struct platform_device *pdev)\n{\n\tstruct rtsx_usb_sdmmc *host = platform_get_drvdata(pdev);\n\tstruct mmc_host *mmc;\n\n\tif (!host)\n\t\treturn;\n\n\tmmc = host->mmc;\n\thost->host_removal = true;\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->mrq) {\n\t\tdev_dbg(&(pdev->dev),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tmmc_hostname(mmc));\n\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\tif (host->mrq->stop)\n\t\t\thost->mrq->stop->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, host->mrq);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\tmmc_remove_host(mmc);\n\n#ifdef RTSX_USB_USE_LEDS_CLASS\n\tcancel_work_sync(&host->led_work);\n\tled_classdev_unregister(&host->led);\n#endif\n\n\tmmc_free_host(mmc);\n\tpm_runtime_disable(&pdev->dev);\n\tplatform_set_drvdata(pdev, NULL);\n\n\tdev_dbg(&(pdev->dev),\n\t\t\": Realtek USB SD/MMC module has been removed\\n\");\n}\n\n#ifdef CONFIG_PM\nstatic int rtsx_usb_sdmmc_runtime_suspend(struct device *dev)\n{\n\tstruct rtsx_usb_sdmmc *host = dev_get_drvdata(dev);\n\n\thost->mmc->caps &= ~MMC_CAP_NEEDS_POLL;\n\treturn 0;\n}\n\nstatic int rtsx_usb_sdmmc_runtime_resume(struct device *dev)\n{\n\tstruct rtsx_usb_sdmmc *host = dev_get_drvdata(dev);\n\n\thost->mmc->caps |= MMC_CAP_NEEDS_POLL;\n\tif (sdmmc_get_cd(host->mmc) == 1)\n\t\tmmc_detect_change(host->mmc, 0);\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops rtsx_usb_sdmmc_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(rtsx_usb_sdmmc_runtime_suspend,\n\t\t\t   rtsx_usb_sdmmc_runtime_resume, NULL)\n};\n\nstatic const struct platform_device_id rtsx_usb_sdmmc_ids[] = {\n\t{\n\t\t.name = \"rtsx_usb_sdmmc\",\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, rtsx_usb_sdmmc_ids);\n\nstatic struct platform_driver rtsx_usb_sdmmc_driver = {\n\t.probe\t\t= rtsx_usb_sdmmc_drv_probe,\n\t.remove_new\t= rtsx_usb_sdmmc_drv_remove,\n\t.id_table       = rtsx_usb_sdmmc_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"rtsx_usb_sdmmc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &rtsx_usb_sdmmc_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(rtsx_usb_sdmmc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Roger Tseng <rogerable@realtek.com>\");\nMODULE_DESCRIPTION(\"Realtek USB SD/MMC Card Host Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}