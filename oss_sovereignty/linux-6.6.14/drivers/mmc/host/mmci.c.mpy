{
  "module_name": "mmci.c",
  "hash_id": "b738b235925de71fd687f083cca886bc33601af5f46cb6c432c45f18cad94ad2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mmci.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/highmem.h>\n#include <linux/log2.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/pm.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/amba/bus.h>\n#include <linux/clk.h>\n#include <linux/scatterlist.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/amba/mmci.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/reset.h>\n#include <linux/gpio/consumer.h>\n#include <linux/workqueue.h>\n\n#include <asm/div64.h>\n#include <asm/io.h>\n\n#include \"mmci.h\"\n\n#define DRIVER_NAME \"mmci-pl18x\"\n\nstatic void mmci_variant_init(struct mmci_host *host);\nstatic void ux500_variant_init(struct mmci_host *host);\nstatic void ux500v2_variant_init(struct mmci_host *host);\n\nstatic unsigned int fmax = 515633;\n\nstatic struct variant_data variant_arm = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 16,\n\t.datactrl_blocksz\t= 11,\n\t.pwrreg_powerup\t\t= MCI_PWR_UP,\n\t.f_max\t\t\t= 100000000,\n\t.reversed_irq_handling\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_ROD,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_arm_extended_fifo = {\n\t.fifosize\t\t= 128 * 4,\n\t.fifohalfsize\t\t= 64 * 4,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 16,\n\t.datactrl_blocksz\t= 11,\n\t.pwrreg_powerup\t\t= MCI_PWR_UP,\n\t.f_max\t\t\t= 100000000,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_ROD,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_arm_extended_fifo_hwfc = {\n\t.fifosize\t\t= 128 * 4,\n\t.fifohalfsize\t\t= 64 * 4,\n\t.clkreg_enable\t\t= MCI_ARM_HWFCEN,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 16,\n\t.datactrl_blocksz\t= 11,\n\t.pwrreg_powerup\t\t= MCI_PWR_UP,\n\t.f_max\t\t\t= 100000000,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_ROD,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_u300 = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg_enable\t\t= MCI_ST_U300_HWFCEN,\n\t.clkreg_8bit_bus_enable = MCI_ST_8BIT_BUS,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 16,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.st_sdio\t\t\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_ON,\n\t.f_max\t\t\t= 100000000,\n\t.signal_direction\t= true,\n\t.pwrreg_clkgate\t\t= true,\n\t.pwrreg_nopower\t\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_OD,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_nomadik = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg\t\t\t= MCI_CLK_ENABLE,\n\t.clkreg_8bit_bus_enable = MCI_ST_8BIT_BUS,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 24,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.st_sdio\t\t= true,\n\t.st_clkdiv\t\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_ON,\n\t.f_max\t\t\t= 100000000,\n\t.signal_direction\t= true,\n\t.pwrreg_clkgate\t\t= true,\n\t.pwrreg_nopower\t\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_OD,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_ux500 = {\n\t.fifosize\t\t= 30 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg\t\t\t= MCI_CLK_ENABLE,\n\t.clkreg_enable\t\t= MCI_ST_UX500_HWFCEN,\n\t.clkreg_8bit_bus_enable = MCI_ST_8BIT_BUS,\n\t.clkreg_neg_edge_enable\t= MCI_ST_UX500_NEG_EDGE,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datalength_bits\t= 24,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_any_blocksz\t= true,\n\t.dma_power_of_2\t\t= true,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.st_sdio\t\t= true,\n\t.st_clkdiv\t\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_ON,\n\t.f_max\t\t\t= 100000000,\n\t.signal_direction\t= true,\n\t.pwrreg_clkgate\t\t= true,\n\t.busy_detect\t\t= true,\n\t.busy_dpsm_flag\t\t= MCI_DPSM_ST_BUSYMODE,\n\t.busy_detect_flag\t= MCI_ST_CARDBUSY,\n\t.busy_detect_mask\t= MCI_ST_BUSYENDMASK,\n\t.pwrreg_nopower\t\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_OD,\n\t.init\t\t\t= ux500_variant_init,\n};\n\nstatic struct variant_data variant_ux500v2 = {\n\t.fifosize\t\t= 30 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg\t\t\t= MCI_CLK_ENABLE,\n\t.clkreg_enable\t\t= MCI_ST_UX500_HWFCEN,\n\t.clkreg_8bit_bus_enable = MCI_ST_8BIT_BUS,\n\t.clkreg_neg_edge_enable\t= MCI_ST_UX500_NEG_EDGE,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.datactrl_mask_ddrmode\t= MCI_DPSM_ST_DDRMODE,\n\t.datalength_bits\t= 24,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_any_blocksz\t= true,\n\t.dma_power_of_2\t\t= true,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.st_sdio\t\t= true,\n\t.st_clkdiv\t\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_ON,\n\t.f_max\t\t\t= 100000000,\n\t.signal_direction\t= true,\n\t.pwrreg_clkgate\t\t= true,\n\t.busy_detect\t\t= true,\n\t.busy_dpsm_flag\t\t= MCI_DPSM_ST_BUSYMODE,\n\t.busy_detect_flag\t= MCI_ST_CARDBUSY,\n\t.busy_detect_mask\t= MCI_ST_BUSYENDMASK,\n\t.pwrreg_nopower\t\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_OD,\n\t.init\t\t\t= ux500v2_variant_init,\n};\n\nstatic struct variant_data variant_stm32 = {\n\t.fifosize\t\t= 32 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg\t\t\t= MCI_CLK_ENABLE,\n\t.clkreg_enable\t\t= MCI_ST_UX500_HWFCEN,\n\t.clkreg_8bit_bus_enable = MCI_ST_8BIT_BUS,\n\t.clkreg_neg_edge_enable\t= MCI_ST_UX500_NEG_EDGE,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.datalength_bits\t= 24,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.st_sdio\t\t= true,\n\t.st_clkdiv\t\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_ON,\n\t.f_max\t\t\t= 48000000,\n\t.pwrreg_clkgate\t\t= true,\n\t.pwrreg_nopower\t\t= true,\n\t.init\t\t\t= mmci_variant_init,\n};\n\nstatic struct variant_data variant_stm32_sdmmc = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.f_max\t\t\t= 208000000,\n\t.stm32_clkdiv\t\t= true,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_STM32_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_STM32_LRSP_CRC,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_STM32_SRSP_CRC,\n\t.cmdreg_srsp\t\t= MCI_CPSM_STM32_SRSP,\n\t.cmdreg_stop\t\t= MCI_CPSM_STM32_CMDSTOP,\n\t.data_cmd_enable\t= MCI_CPSM_STM32_CMDTRANS,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_STM32_MASK,\n\t.datactrl_first\t\t= true,\n\t.datacnt_useless\t= true,\n\t.datalength_bits\t= 25,\n\t.datactrl_blocksz\t= 14,\n\t.datactrl_any_blocksz\t= true,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.stm32_idmabsize_mask\t= GENMASK(12, 5),\n\t.stm32_idmabsize_align\t= BIT(5),\n\t.busy_timeout\t\t= true,\n\t.busy_detect\t\t= true,\n\t.busy_detect_flag\t= MCI_STM32_BUSYD0,\n\t.busy_detect_mask\t= MCI_STM32_BUSYD0ENDMASK,\n\t.init\t\t\t= sdmmc_variant_init,\n};\n\nstatic struct variant_data variant_stm32_sdmmcv2 = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.f_max\t\t\t= 267000000,\n\t.stm32_clkdiv\t\t= true,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_STM32_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_STM32_LRSP_CRC,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_STM32_SRSP_CRC,\n\t.cmdreg_srsp\t\t= MCI_CPSM_STM32_SRSP,\n\t.cmdreg_stop\t\t= MCI_CPSM_STM32_CMDSTOP,\n\t.data_cmd_enable\t= MCI_CPSM_STM32_CMDTRANS,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_STM32_MASK,\n\t.datactrl_first\t\t= true,\n\t.datacnt_useless\t= true,\n\t.datalength_bits\t= 25,\n\t.datactrl_blocksz\t= 14,\n\t.datactrl_any_blocksz\t= true,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.stm32_idmabsize_mask\t= GENMASK(16, 5),\n\t.stm32_idmabsize_align\t= BIT(5),\n\t.dma_lli\t\t= true,\n\t.busy_timeout\t\t= true,\n\t.busy_detect\t\t= true,\n\t.busy_detect_flag\t= MCI_STM32_BUSYD0,\n\t.busy_detect_mask\t= MCI_STM32_BUSYD0ENDMASK,\n\t.init\t\t\t= sdmmc_variant_init,\n};\n\nstatic struct variant_data variant_stm32_sdmmcv3 = {\n\t.fifosize\t\t= 256 * 4,\n\t.fifohalfsize\t\t= 128 * 4,\n\t.f_max\t\t\t= 267000000,\n\t.stm32_clkdiv\t\t= true,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_STM32_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_STM32_LRSP_CRC,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_STM32_SRSP_CRC,\n\t.cmdreg_srsp\t\t= MCI_CPSM_STM32_SRSP,\n\t.cmdreg_stop\t\t= MCI_CPSM_STM32_CMDSTOP,\n\t.data_cmd_enable\t= MCI_CPSM_STM32_CMDTRANS,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_STM32_MASK,\n\t.datactrl_first\t\t= true,\n\t.datacnt_useless\t= true,\n\t.datalength_bits\t= 25,\n\t.datactrl_blocksz\t= 14,\n\t.datactrl_any_blocksz\t= true,\n\t.datactrl_mask_sdio\t= MCI_DPSM_ST_SDIOEN,\n\t.stm32_idmabsize_mask\t= GENMASK(16, 6),\n\t.stm32_idmabsize_align\t= BIT(6),\n\t.dma_lli\t\t= true,\n\t.busy_timeout\t\t= true,\n\t.busy_detect\t\t= true,\n\t.busy_detect_flag\t= MCI_STM32_BUSYD0,\n\t.busy_detect_mask\t= MCI_STM32_BUSYD0ENDMASK,\n\t.init\t\t\t= sdmmc_variant_init,\n};\n\nstatic struct variant_data variant_qcom = {\n\t.fifosize\t\t= 16 * 4,\n\t.fifohalfsize\t\t= 8 * 4,\n\t.clkreg\t\t\t= MCI_CLK_ENABLE,\n\t.clkreg_enable\t\t= MCI_QCOM_CLK_FLOWENA |\n\t\t\t\t  MCI_QCOM_CLK_SELECT_IN_FBCLK,\n\t.clkreg_8bit_bus_enable = MCI_QCOM_CLK_WIDEBUS_8,\n\t.datactrl_mask_ddrmode\t= MCI_QCOM_CLK_SELECT_IN_DDR_MODE,\n\t.cmdreg_cpsm_enable\t= MCI_CPSM_ENABLE,\n\t.cmdreg_lrsp_crc\t= MCI_CPSM_RESPONSE | MCI_CPSM_LONGRSP,\n\t.cmdreg_srsp_crc\t= MCI_CPSM_RESPONSE,\n\t.cmdreg_srsp\t\t= MCI_CPSM_RESPONSE,\n\t.data_cmd_enable\t= MCI_CPSM_QCOM_DATCMD,\n\t.datalength_bits\t= 24,\n\t.datactrl_blocksz\t= 11,\n\t.datactrl_any_blocksz\t= true,\n\t.pwrreg_powerup\t\t= MCI_PWR_UP,\n\t.f_max\t\t\t= 208000000,\n\t.explicit_mclk_control\t= true,\n\t.qcom_fifo\t\t= true,\n\t.qcom_dml\t\t= true,\n\t.mmcimask1\t\t= true,\n\t.irq_pio_mask\t\t= MCI_IRQ_PIO_MASK,\n\t.start_err\t\t= MCI_STARTBITERR,\n\t.opendrain\t\t= MCI_ROD,\n\t.init\t\t\t= qcom_variant_init,\n};\n\n \nstatic int mmci_card_busy(struct mmc_host *mmc)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tint busy = 0;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (readl(host->base + MMCISTATUS) & host->variant->busy_detect_flag)\n\t\tbusy = 1;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn busy;\n}\n\nstatic void mmci_reg_delay(struct mmci_host *host)\n{\n\t \n\tif (host->cclk < 25000000)\n\t\tudelay(30);\n\telse\n\t\tndelay(120);\n}\n\n \nvoid mmci_write_clkreg(struct mmci_host *host, u32 clk)\n{\n\tif (host->clk_reg != clk) {\n\t\thost->clk_reg = clk;\n\t\twritel(clk, host->base + MMCICLOCK);\n\t}\n}\n\n \nvoid mmci_write_pwrreg(struct mmci_host *host, u32 pwr)\n{\n\tif (host->pwr_reg != pwr) {\n\t\thost->pwr_reg = pwr;\n\t\twritel(pwr, host->base + MMCIPOWER);\n\t}\n}\n\n \nstatic void mmci_write_datactrlreg(struct mmci_host *host, u32 datactrl)\n{\n\t \n\tdatactrl |= host->datactrl_reg & host->variant->busy_dpsm_flag;\n\n\tif (host->datactrl_reg != datactrl) {\n\t\thost->datactrl_reg = datactrl;\n\t\twritel(datactrl, host->base + MMCIDATACTRL);\n\t}\n}\n\n \nstatic void mmci_set_clkreg(struct mmci_host *host, unsigned int desired)\n{\n\tstruct variant_data *variant = host->variant;\n\tu32 clk = variant->clkreg;\n\n\t \n\thost->cclk = 0;\n\n\tif (desired) {\n\t\tif (variant->explicit_mclk_control) {\n\t\t\thost->cclk = host->mclk;\n\t\t} else if (desired >= host->mclk) {\n\t\t\tclk = MCI_CLK_BYPASS;\n\t\t\tif (variant->st_clkdiv)\n\t\t\t\tclk |= MCI_ST_UX500_NEG_EDGE;\n\t\t\thost->cclk = host->mclk;\n\t\t} else if (variant->st_clkdiv) {\n\t\t\t \n\t\t\tclk = DIV_ROUND_UP(host->mclk, desired) - 2;\n\t\t\tif (clk >= 256)\n\t\t\t\tclk = 255;\n\t\t\thost->cclk = host->mclk / (clk + 2);\n\t\t} else {\n\t\t\t \n\t\t\tclk = host->mclk / (2 * desired) - 1;\n\t\t\tif (clk >= 256)\n\t\t\t\tclk = 255;\n\t\t\thost->cclk = host->mclk / (2 * (clk + 1));\n\t\t}\n\n\t\tclk |= variant->clkreg_enable;\n\t\tclk |= MCI_CLK_ENABLE;\n\t\t \n\t\t \n\t}\n\n\t \n\thost->mmc->actual_clock = host->cclk;\n\n\tif (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)\n\t\tclk |= MCI_4BIT_BUS;\n\tif (host->mmc->ios.bus_width == MMC_BUS_WIDTH_8)\n\t\tclk |= variant->clkreg_8bit_bus_enable;\n\n\tif (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50 ||\n\t    host->mmc->ios.timing == MMC_TIMING_MMC_DDR52)\n\t\tclk |= variant->clkreg_neg_edge_enable;\n\n\tmmci_write_clkreg(host, clk);\n}\n\nstatic void mmci_dma_release(struct mmci_host *host)\n{\n\tif (host->ops && host->ops->dma_release)\n\t\thost->ops->dma_release(host);\n\n\thost->use_dma = false;\n}\n\nstatic void mmci_dma_setup(struct mmci_host *host)\n{\n\tif (!host->ops || !host->ops->dma_setup)\n\t\treturn;\n\n\tif (host->ops->dma_setup(host))\n\t\treturn;\n\n\t \n\thost->next_cookie = 1;\n\n\thost->use_dma = true;\n}\n\n \nstatic int mmci_validate_data(struct mmci_host *host,\n\t\t\t      struct mmc_data *data)\n{\n\tstruct variant_data *variant = host->variant;\n\n\tif (!data)\n\t\treturn 0;\n\tif (!is_power_of_2(data->blksz) && !variant->datactrl_any_blocksz) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"unsupported block size (%d bytes)\\n\", data->blksz);\n\t\treturn -EINVAL;\n\t}\n\n\tif (host->ops && host->ops->validate_data)\n\t\treturn host->ops->validate_data(host, data);\n\n\treturn 0;\n}\n\nstatic int mmci_prep_data(struct mmci_host *host, struct mmc_data *data, bool next)\n{\n\tint err;\n\n\tif (!host->ops || !host->ops->prep_data)\n\t\treturn 0;\n\n\terr = host->ops->prep_data(host, data, next);\n\n\tif (next && !err)\n\t\tdata->host_cookie = ++host->next_cookie < 0 ?\n\t\t\t1 : host->next_cookie;\n\n\treturn err;\n}\n\nstatic void mmci_unprep_data(struct mmci_host *host, struct mmc_data *data,\n\t\t      int err)\n{\n\tif (host->ops && host->ops->unprep_data)\n\t\thost->ops->unprep_data(host, data, err);\n\n\tdata->host_cookie = 0;\n}\n\nstatic void mmci_get_next_data(struct mmci_host *host, struct mmc_data *data)\n{\n\tWARN_ON(data->host_cookie && data->host_cookie != host->next_cookie);\n\n\tif (host->ops && host->ops->get_next_data)\n\t\thost->ops->get_next_data(host, data);\n}\n\nstatic int mmci_dma_start(struct mmci_host *host, unsigned int datactrl)\n{\n\tstruct mmc_data *data = host->data;\n\tint ret;\n\n\tif (!host->use_dma)\n\t\treturn -EINVAL;\n\n\tret = mmci_prep_data(host, data, false);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!host->ops || !host->ops->dma_start)\n\t\treturn -EINVAL;\n\n\t \n\tdev_vdbg(mmc_dev(host->mmc),\n\t\t \"Submit MMCI DMA job, sglen %d blksz %04x blks %04x flags %08x\\n\",\n\t\t data->sg_len, data->blksz, data->blocks, data->flags);\n\n\tret = host->ops->dma_start(host, &datactrl);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmmci_write_datactrlreg(host, datactrl);\n\n\t \n\twritel(readl(host->base + MMCIMASK0) | MCI_DATAENDMASK,\n\t       host->base + MMCIMASK0);\n\treturn 0;\n}\n\nstatic void mmci_dma_finalize(struct mmci_host *host, struct mmc_data *data)\n{\n\tif (!host->use_dma)\n\t\treturn;\n\n\tif (host->ops && host->ops->dma_finalize)\n\t\thost->ops->dma_finalize(host, data);\n}\n\nstatic void mmci_dma_error(struct mmci_host *host)\n{\n\tif (!host->use_dma)\n\t\treturn;\n\n\tif (host->ops && host->ops->dma_error)\n\t\thost->ops->dma_error(host);\n}\n\nstatic void\nmmci_request_end(struct mmci_host *host, struct mmc_request *mrq)\n{\n\twritel(0, host->base + MMCICOMMAND);\n\n\tBUG_ON(host->data);\n\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void mmci_set_mask1(struct mmci_host *host, unsigned int mask)\n{\n\tvoid __iomem *base = host->base;\n\tstruct variant_data *variant = host->variant;\n\n\tif (host->singleirq) {\n\t\tunsigned int mask0 = readl(base + MMCIMASK0);\n\n\t\tmask0 &= ~variant->irq_pio_mask;\n\t\tmask0 |= mask;\n\n\t\twritel(mask0, base + MMCIMASK0);\n\t}\n\n\tif (variant->mmcimask1)\n\t\twritel(mask, base + MMCIMASK1);\n\n\thost->mask1_reg = mask;\n}\n\nstatic void mmci_stop_data(struct mmci_host *host)\n{\n\tmmci_write_datactrlreg(host, 0);\n\tmmci_set_mask1(host, 0);\n\thost->data = NULL;\n}\n\nstatic void mmci_init_sg(struct mmci_host *host, struct mmc_data *data)\n{\n\tunsigned int flags = SG_MITER_ATOMIC;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tflags |= SG_MITER_TO_SG;\n\telse\n\t\tflags |= SG_MITER_FROM_SG;\n\n\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n}\n\nstatic u32 mmci_get_dctrl_cfg(struct mmci_host *host)\n{\n\treturn MCI_DPSM_ENABLE | mmci_dctrl_blksz(host);\n}\n\nstatic u32 ux500v2_get_dctrl_cfg(struct mmci_host *host)\n{\n\treturn MCI_DPSM_ENABLE | (host->data->blksz << 16);\n}\n\nstatic void ux500_busy_clear_mask_done(struct mmci_host *host)\n{\n\tvoid __iomem *base = host->base;\n\n\twritel(host->variant->busy_detect_mask, base + MMCICLEAR);\n\twritel(readl(base + MMCIMASK0) &\n\t       ~host->variant->busy_detect_mask, base + MMCIMASK0);\n\thost->busy_state = MMCI_BUSY_DONE;\n\thost->busy_status = 0;\n}\n\n \nstatic bool ux500_busy_complete(struct mmci_host *host, struct mmc_command *cmd,\n\t\t\t\tu32 status, u32 err_msk)\n{\n\tvoid __iomem *base = host->base;\n\tint retries = 10;\n\n\tif (status & err_msk) {\n\t\t \n\t\tux500_busy_clear_mask_done(host);\n\t\tgoto out_ret_state;\n\t}\n\n\t \n\tswitch (host->busy_state) {\n\n\t \n\tcase MMCI_BUSY_DONE:\n\t\t \n\t\thost->busy_status = status & (MCI_CMDSENT | MCI_CMDRESPEND);\n\t\twhile (retries) {\n\t\t\tstatus = readl(base + MMCISTATUS);\n\t\t\t \n\t\t\thost->busy_status |= status & (MCI_CMDSENT | MCI_CMDRESPEND);\n\t\t\tif (status & host->variant->busy_detect_flag) {\n\t\t\t\twritel(readl(base + MMCIMASK0) |\n\t\t\t\t       host->variant->busy_detect_mask,\n\t\t\t\t       base + MMCIMASK0);\n\t\t\t\thost->busy_state = MMCI_BUSY_WAITING_FOR_START_IRQ;\n\t\t\t\tschedule_delayed_work(&host->ux500_busy_timeout_work,\n\t\t\t\t      msecs_to_jiffies(cmd->busy_timeout));\n\t\t\t\tgoto out_ret_state;\n\t\t\t}\n\t\t\tretries--;\n\t\t}\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"no busy signalling in time CMD%02x\\n\", cmd->opcode);\n\t\tux500_busy_clear_mask_done(host);\n\t\tbreak;\n\n\t \n\tcase MMCI_BUSY_WAITING_FOR_START_IRQ:\n\t\tif (status & host->variant->busy_detect_flag) {\n\t\t\thost->busy_status |= status & (MCI_CMDSENT | MCI_CMDRESPEND);\n\t\t\twritel(host->variant->busy_detect_mask, base + MMCICLEAR);\n\t\t\thost->busy_state = MMCI_BUSY_WAITING_FOR_END_IRQ;\n\t\t} else {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"lost busy status when waiting for busy start IRQ CMD%02x\\n\",\n\t\t\t\tcmd->opcode);\n\t\t\tcancel_delayed_work(&host->ux500_busy_timeout_work);\n\t\t\tux500_busy_clear_mask_done(host);\n\t\t}\n\t\tbreak;\n\n\tcase MMCI_BUSY_WAITING_FOR_END_IRQ:\n\t\tif (!(status & host->variant->busy_detect_flag)) {\n\t\t\thost->busy_status |= status & (MCI_CMDSENT | MCI_CMDRESPEND);\n\t\t\twritel(host->variant->busy_detect_mask, base + MMCICLEAR);\n\t\t\tcancel_delayed_work(&host->ux500_busy_timeout_work);\n\t\t\tux500_busy_clear_mask_done(host);\n\t\t} else {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"busy status still asserted when handling busy end IRQ - will keep waiting CMD%02x\\n\",\n\t\t\t\tcmd->opcode);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(mmc_dev(host->mmc), \"fell through on state %d, CMD%02x\\n\",\n\t\t\thost->busy_state, cmd->opcode);\n\t\tbreak;\n\t}\n\nout_ret_state:\n\treturn (host->busy_state == MMCI_BUSY_DONE);\n}\n\n \n#ifdef CONFIG_DMA_ENGINE\nstruct mmci_dmae_next {\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_chan\t*chan;\n};\n\nstruct mmci_dmae_priv {\n\tstruct dma_chan\t*cur;\n\tstruct dma_chan\t*rx_channel;\n\tstruct dma_chan\t*tx_channel;\n\tstruct dma_async_tx_descriptor\t*desc_current;\n\tstruct mmci_dmae_next next_data;\n};\n\nint mmci_dmae_setup(struct mmci_host *host)\n{\n\tconst char *rxname, *txname;\n\tstruct mmci_dmae_priv *dmae;\n\n\tdmae = devm_kzalloc(mmc_dev(host->mmc), sizeof(*dmae), GFP_KERNEL);\n\tif (!dmae)\n\t\treturn -ENOMEM;\n\n\thost->dma_priv = dmae;\n\n\tdmae->rx_channel = dma_request_chan(mmc_dev(host->mmc), \"rx\");\n\tif (IS_ERR(dmae->rx_channel)) {\n\t\tint ret = PTR_ERR(dmae->rx_channel);\n\t\tdmae->rx_channel = NULL;\n\t\treturn ret;\n\t}\n\n\tdmae->tx_channel = dma_request_chan(mmc_dev(host->mmc), \"tx\");\n\tif (IS_ERR(dmae->tx_channel)) {\n\t\tif (PTR_ERR(dmae->tx_channel) == -EPROBE_DEFER)\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"Deferred probe for TX channel ignored\\n\");\n\t\tdmae->tx_channel = NULL;\n\t}\n\n\t \n\tif (dmae->rx_channel && !dmae->tx_channel)\n\t\tdmae->tx_channel = dmae->rx_channel;\n\n\tif (dmae->rx_channel)\n\t\trxname = dma_chan_name(dmae->rx_channel);\n\telse\n\t\trxname = \"none\";\n\n\tif (dmae->tx_channel)\n\t\ttxname = dma_chan_name(dmae->tx_channel);\n\telse\n\t\ttxname = \"none\";\n\n\tdev_info(mmc_dev(host->mmc), \"DMA channels RX %s, TX %s\\n\",\n\t\t rxname, txname);\n\n\t \n\tif (dmae->tx_channel) {\n\t\tstruct device *dev = dmae->tx_channel->device->dev;\n\t\tunsigned int max_seg_size = dma_get_max_seg_size(dev);\n\n\t\tif (max_seg_size < host->mmc->max_seg_size)\n\t\t\thost->mmc->max_seg_size = max_seg_size;\n\t}\n\tif (dmae->rx_channel) {\n\t\tstruct device *dev = dmae->rx_channel->device->dev;\n\t\tunsigned int max_seg_size = dma_get_max_seg_size(dev);\n\n\t\tif (max_seg_size < host->mmc->max_seg_size)\n\t\t\thost->mmc->max_seg_size = max_seg_size;\n\t}\n\n\tif (!dmae->tx_channel || !dmae->rx_channel) {\n\t\tmmci_dmae_release(host);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nvoid mmci_dmae_release(struct mmci_host *host)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\n\tif (dmae->rx_channel)\n\t\tdma_release_channel(dmae->rx_channel);\n\tif (dmae->tx_channel)\n\t\tdma_release_channel(dmae->tx_channel);\n\tdmae->rx_channel = dmae->tx_channel = NULL;\n}\n\nstatic void mmci_dma_unmap(struct mmci_host *host, struct mmc_data *data)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tstruct dma_chan *chan;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tchan = dmae->rx_channel;\n\telse\n\t\tchan = dmae->tx_channel;\n\n\tdma_unmap_sg(chan->device->dev, data->sg, data->sg_len,\n\t\t     mmc_get_dma_dir(data));\n}\n\nvoid mmci_dmae_error(struct mmci_host *host)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\n\tif (!dma_inprogress(host))\n\t\treturn;\n\n\tdev_err(mmc_dev(host->mmc), \"error during DMA transfer!\\n\");\n\tdmaengine_terminate_all(dmae->cur);\n\thost->dma_in_progress = false;\n\tdmae->cur = NULL;\n\tdmae->desc_current = NULL;\n\thost->data->host_cookie = 0;\n\n\tmmci_dma_unmap(host, host->data);\n}\n\nvoid mmci_dmae_finalize(struct mmci_host *host, struct mmc_data *data)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tu32 status;\n\tint i;\n\n\tif (!dma_inprogress(host))\n\t\treturn;\n\n\t \n\tfor (i = 0; ; i++) {\n\t\tstatus = readl(host->base + MMCISTATUS);\n\t\tif (!(status & MCI_RXDATAAVLBLMASK) || i >= 100)\n\t\t\tbreak;\n\t\tudelay(10);\n\t}\n\n\t \n\tif (status & MCI_RXDATAAVLBLMASK) {\n\t\tmmci_dma_error(host);\n\t\tif (!data->error)\n\t\t\tdata->error = -EIO;\n\t} else if (!data->host_cookie) {\n\t\tmmci_dma_unmap(host, data);\n\t}\n\n\t \n\tif (status & MCI_RXDATAAVLBLMASK) {\n\t\tdev_err(mmc_dev(host->mmc), \"buggy DMA detected. Taking evasive action.\\n\");\n\t\tmmci_dma_release(host);\n\t}\n\n\thost->dma_in_progress = false;\n\tdmae->cur = NULL;\n\tdmae->desc_current = NULL;\n}\n\n \nstatic int _mmci_dmae_prep_data(struct mmci_host *host, struct mmc_data *data,\n\t\t\t\tstruct dma_chan **dma_chan,\n\t\t\t\tstruct dma_async_tx_descriptor **dma_desc)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tstruct variant_data *variant = host->variant;\n\tstruct dma_slave_config conf = {\n\t\t.src_addr = host->phybase + MMCIFIFO,\n\t\t.dst_addr = host->phybase + MMCIFIFO,\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.src_maxburst = variant->fifohalfsize >> 2,  \n\t\t.dst_maxburst = variant->fifohalfsize >> 2,  \n\t\t.device_fc = false,\n\t};\n\tstruct dma_chan *chan;\n\tstruct dma_device *device;\n\tstruct dma_async_tx_descriptor *desc;\n\tint nr_sg;\n\tunsigned long flags = DMA_CTRL_ACK;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tconf.direction = DMA_DEV_TO_MEM;\n\t\tchan = dmae->rx_channel;\n\t} else {\n\t\tconf.direction = DMA_MEM_TO_DEV;\n\t\tchan = dmae->tx_channel;\n\t}\n\n\t \n\tif (!chan)\n\t\treturn -EINVAL;\n\n\t \n\tif (data->blksz * data->blocks <= variant->fifosize)\n\t\treturn -EINVAL;\n\n\t \n\tif (host->variant->dma_power_of_2 && !is_power_of_2(data->blksz))\n\t\treturn -EINVAL;\n\n\tdevice = chan->device;\n\tnr_sg = dma_map_sg(device->dev, data->sg, data->sg_len,\n\t\t\t   mmc_get_dma_dir(data));\n\tif (nr_sg == 0)\n\t\treturn -EINVAL;\n\n\tif (host->variant->qcom_dml)\n\t\tflags |= DMA_PREP_INTERRUPT;\n\n\tdmaengine_slave_config(chan, &conf);\n\tdesc = dmaengine_prep_slave_sg(chan, data->sg, nr_sg,\n\t\t\t\t\t    conf.direction, flags);\n\tif (!desc)\n\t\tgoto unmap_exit;\n\n\t*dma_chan = chan;\n\t*dma_desc = desc;\n\n\treturn 0;\n\n unmap_exit:\n\tdma_unmap_sg(device->dev, data->sg, data->sg_len,\n\t\t     mmc_get_dma_dir(data));\n\treturn -ENOMEM;\n}\n\nint mmci_dmae_prep_data(struct mmci_host *host,\n\t\t\tstruct mmc_data *data,\n\t\t\tbool next)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tstruct mmci_dmae_next *nd = &dmae->next_data;\n\n\tif (!host->use_dma)\n\t\treturn -EINVAL;\n\n\tif (next)\n\t\treturn _mmci_dmae_prep_data(host, data, &nd->chan, &nd->desc);\n\t \n\tif (dmae->cur && dmae->desc_current)\n\t\treturn 0;\n\n\t \n\treturn _mmci_dmae_prep_data(host, data, &dmae->cur,\n\t\t\t\t    &dmae->desc_current);\n}\n\nint mmci_dmae_start(struct mmci_host *host, unsigned int *datactrl)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tint ret;\n\n\thost->dma_in_progress = true;\n\tret = dma_submit_error(dmaengine_submit(dmae->desc_current));\n\tif (ret < 0) {\n\t\thost->dma_in_progress = false;\n\t\treturn ret;\n\t}\n\tdma_async_issue_pending(dmae->cur);\n\n\t*datactrl |= MCI_DPSM_DMAENABLE;\n\n\treturn 0;\n}\n\nvoid mmci_dmae_get_next_data(struct mmci_host *host, struct mmc_data *data)\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\tstruct mmci_dmae_next *next = &dmae->next_data;\n\n\tif (!host->use_dma)\n\t\treturn;\n\n\tWARN_ON(!data->host_cookie && (next->desc || next->chan));\n\n\tdmae->desc_current = next->desc;\n\tdmae->cur = next->chan;\n\tnext->desc = NULL;\n\tnext->chan = NULL;\n}\n\nvoid mmci_dmae_unprep_data(struct mmci_host *host,\n\t\t\t   struct mmc_data *data, int err)\n\n{\n\tstruct mmci_dmae_priv *dmae = host->dma_priv;\n\n\tif (!host->use_dma)\n\t\treturn;\n\n\tmmci_dma_unmap(host, data);\n\n\tif (err) {\n\t\tstruct mmci_dmae_next *next = &dmae->next_data;\n\t\tstruct dma_chan *chan;\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tchan = dmae->rx_channel;\n\t\telse\n\t\t\tchan = dmae->tx_channel;\n\t\tdmaengine_terminate_all(chan);\n\n\t\tif (dmae->desc_current == next->desc)\n\t\t\tdmae->desc_current = NULL;\n\n\t\tif (dmae->cur == next->chan) {\n\t\t\thost->dma_in_progress = false;\n\t\t\tdmae->cur = NULL;\n\t\t}\n\n\t\tnext->desc = NULL;\n\t\tnext->chan = NULL;\n\t}\n}\n\nstatic struct mmci_host_ops mmci_variant_ops = {\n\t.prep_data = mmci_dmae_prep_data,\n\t.unprep_data = mmci_dmae_unprep_data,\n\t.get_datactrl_cfg = mmci_get_dctrl_cfg,\n\t.get_next_data = mmci_dmae_get_next_data,\n\t.dma_setup = mmci_dmae_setup,\n\t.dma_release = mmci_dmae_release,\n\t.dma_start = mmci_dmae_start,\n\t.dma_finalize = mmci_dmae_finalize,\n\t.dma_error = mmci_dmae_error,\n};\n#else\nstatic struct mmci_host_ops mmci_variant_ops = {\n\t.get_datactrl_cfg = mmci_get_dctrl_cfg,\n};\n#endif\n\nstatic void mmci_variant_init(struct mmci_host *host)\n{\n\thost->ops = &mmci_variant_ops;\n}\n\nstatic void ux500_variant_init(struct mmci_host *host)\n{\n\thost->ops = &mmci_variant_ops;\n\thost->ops->busy_complete = ux500_busy_complete;\n}\n\nstatic void ux500v2_variant_init(struct mmci_host *host)\n{\n\thost->ops = &mmci_variant_ops;\n\thost->ops->busy_complete = ux500_busy_complete;\n\thost->ops->get_datactrl_cfg = ux500v2_get_dctrl_cfg;\n}\n\nstatic void mmci_pre_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tWARN_ON(data->host_cookie);\n\n\tif (mmci_validate_data(host, data))\n\t\treturn;\n\n\tmmci_prep_data(host, data, true);\n}\n\nstatic void mmci_post_request(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\t\t      int err)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data || !data->host_cookie)\n\t\treturn;\n\n\tmmci_unprep_data(host, data, err);\n}\n\nstatic void mmci_start_data(struct mmci_host *host, struct mmc_data *data)\n{\n\tstruct variant_data *variant = host->variant;\n\tunsigned int datactrl, timeout, irqmask;\n\tunsigned long long clks;\n\tvoid __iomem *base;\n\n\tdev_dbg(mmc_dev(host->mmc), \"blksz %04x blks %04x flags %08x\\n\",\n\t\tdata->blksz, data->blocks, data->flags);\n\n\thost->data = data;\n\thost->size = data->blksz * data->blocks;\n\tdata->bytes_xfered = 0;\n\n\tclks = (unsigned long long)data->timeout_ns * host->cclk;\n\tdo_div(clks, NSEC_PER_SEC);\n\n\ttimeout = data->timeout_clks + (unsigned int)clks;\n\n\tbase = host->base;\n\twritel(timeout, base + MMCIDATATIMER);\n\twritel(host->size, base + MMCIDATALENGTH);\n\n\tdatactrl = host->ops->get_datactrl_cfg(host);\n\tdatactrl |= host->data->flags & MMC_DATA_READ ? MCI_DPSM_DIRECTION : 0;\n\n\tif (host->mmc->card && mmc_card_sdio(host->mmc->card)) {\n\t\tu32 clk;\n\n\t\tdatactrl |= variant->datactrl_mask_sdio;\n\n\t\t \n\t\tif (variant->st_sdio && data->flags & MMC_DATA_WRITE &&\n\t\t    (host->size < 8 ||\n\t\t     (host->size <= 8 && host->mclk > 50000000)))\n\t\t\tclk = host->clk_reg & ~variant->clkreg_enable;\n\t\telse\n\t\t\tclk = host->clk_reg | variant->clkreg_enable;\n\n\t\tmmci_write_clkreg(host, clk);\n\t}\n\n\tif (host->mmc->ios.timing == MMC_TIMING_UHS_DDR50 ||\n\t    host->mmc->ios.timing == MMC_TIMING_MMC_DDR52)\n\t\tdatactrl |= variant->datactrl_mask_ddrmode;\n\n\t \n\tif (!mmci_dma_start(host, datactrl))\n\t\treturn;\n\n\t \n\tmmci_init_sg(host, data);\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tirqmask = MCI_RXFIFOHALFFULLMASK;\n\n\t\t \n\t\tif (host->size < variant->fifohalfsize)\n\t\t\tirqmask |= MCI_RXDATAAVLBLMASK;\n\t} else {\n\t\t \n\t\tirqmask = MCI_TXFIFOHALFEMPTYMASK;\n\t}\n\n\tmmci_write_datactrlreg(host, datactrl);\n\twritel(readl(base + MMCIMASK0) & ~MCI_DATAENDMASK, base + MMCIMASK0);\n\tmmci_set_mask1(host, irqmask);\n}\n\nstatic void\nmmci_start_command(struct mmci_host *host, struct mmc_command *cmd, u32 c)\n{\n\tvoid __iomem *base = host->base;\n\tbool busy_resp = cmd->flags & MMC_RSP_BUSY;\n\tunsigned long long clks;\n\n\tdev_dbg(mmc_dev(host->mmc), \"op %02x arg %08x flags %08x\\n\",\n\t    cmd->opcode, cmd->arg, cmd->flags);\n\n\tif (readl(base + MMCICOMMAND) & host->variant->cmdreg_cpsm_enable) {\n\t\twritel(0, base + MMCICOMMAND);\n\t\tmmci_reg_delay(host);\n\t}\n\n\tif (host->variant->cmdreg_stop &&\n\t    cmd->opcode == MMC_STOP_TRANSMISSION)\n\t\tc |= host->variant->cmdreg_stop;\n\n\tc |= cmd->opcode | host->variant->cmdreg_cpsm_enable;\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tc |= host->variant->cmdreg_lrsp_crc;\n\t\telse if (cmd->flags & MMC_RSP_CRC)\n\t\t\tc |= host->variant->cmdreg_srsp_crc;\n\t\telse\n\t\t\tc |= host->variant->cmdreg_srsp;\n\t}\n\n\thost->busy_status = 0;\n\thost->busy_state = MMCI_BUSY_DONE;\n\n\t \n\tif (busy_resp && !cmd->busy_timeout)\n\t\tcmd->busy_timeout = 10 * MSEC_PER_SEC;\n\n\tif (busy_resp && host->variant->busy_timeout) {\n\t\tif (cmd->busy_timeout > host->mmc->max_busy_timeout)\n\t\t\tclks = (unsigned long long)host->mmc->max_busy_timeout * host->cclk;\n\t\telse\n\t\t\tclks = (unsigned long long)cmd->busy_timeout * host->cclk;\n\n\t\tdo_div(clks, MSEC_PER_SEC);\n\t\twritel_relaxed(clks, host->base + MMCIDATATIMER);\n\t}\n\n\tif (host->ops->pre_sig_volt_switch && cmd->opcode == SD_SWITCH_VOLTAGE)\n\t\thost->ops->pre_sig_volt_switch(host);\n\n\tif ( 0)\n\t\tc |= MCI_CPSM_INTERRUPT;\n\n\tif (mmc_cmd_type(cmd) == MMC_CMD_ADTC)\n\t\tc |= host->variant->data_cmd_enable;\n\n\thost->cmd = cmd;\n\n\twritel(cmd->arg, base + MMCIARGUMENT);\n\twritel(c, base + MMCICOMMAND);\n}\n\nstatic void mmci_stop_command(struct mmci_host *host)\n{\n\thost->stop_abort.error = 0;\n\tmmci_start_command(host, &host->stop_abort, 0);\n}\n\nstatic void\nmmci_data_irq(struct mmci_host *host, struct mmc_data *data,\n\t      unsigned int status)\n{\n\tunsigned int status_err;\n\n\t \n\tif (!data)\n\t\treturn;\n\n\t \n\tstatus_err = status & (host->variant->start_err |\n\t\t\t       MCI_DATACRCFAIL | MCI_DATATIMEOUT |\n\t\t\t       MCI_TXUNDERRUN | MCI_RXOVERRUN);\n\n\tif (status_err) {\n\t\tu32 remain, success;\n\n\t\t \n\t\tmmci_dma_error(host);\n\n\t\t \n\t\tif (!host->variant->datacnt_useless) {\n\t\t\tremain = readl(host->base + MMCIDATACNT);\n\t\t\tsuccess = data->blksz * data->blocks - remain;\n\t\t} else {\n\t\t\tsuccess = 0;\n\t\t}\n\n\t\tdev_dbg(mmc_dev(host->mmc), \"MCI ERROR IRQ, status 0x%08x at 0x%08x\\n\",\n\t\t\tstatus_err, success);\n\t\tif (status_err & MCI_DATACRCFAIL) {\n\t\t\t \n\t\t\tsuccess -= 1;\n\t\t\tdata->error = -EILSEQ;\n\t\t} else if (status_err & MCI_DATATIMEOUT) {\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t} else if (status_err & MCI_STARTBITERR) {\n\t\t\tdata->error = -ECOMM;\n\t\t} else if (status_err & MCI_TXUNDERRUN) {\n\t\t\tdata->error = -EIO;\n\t\t} else if (status_err & MCI_RXOVERRUN) {\n\t\t\tif (success > host->variant->fifosize)\n\t\t\t\tsuccess -= host->variant->fifosize;\n\t\t\telse\n\t\t\t\tsuccess = 0;\n\t\t\tdata->error = -EIO;\n\t\t}\n\t\tdata->bytes_xfered = round_down(success, data->blksz);\n\t}\n\n\tif (status & MCI_DATABLOCKEND)\n\t\tdev_err(mmc_dev(host->mmc), \"stray MCI_DATABLOCKEND interrupt\\n\");\n\n\tif (status & MCI_DATAEND || data->error) {\n\t\tmmci_dma_finalize(host, data);\n\n\t\tmmci_stop_data(host);\n\n\t\tif (!data->error)\n\t\t\t \n\t\t\tdata->bytes_xfered = data->blksz * data->blocks;\n\n\t\tif (!data->stop) {\n\t\t\tif (host->variant->cmdreg_stop && data->error)\n\t\t\t\tmmci_stop_command(host);\n\t\t\telse\n\t\t\t\tmmci_request_end(host, data->mrq);\n\t\t} else if (host->mrq->sbc && !data->error) {\n\t\t\tmmci_request_end(host, data->mrq);\n\t\t} else {\n\t\t\tmmci_start_command(host, data->stop, 0);\n\t\t}\n\t}\n}\n\nstatic void\nmmci_cmd_irq(struct mmci_host *host, struct mmc_command *cmd,\n\t     unsigned int status)\n{\n\tu32 err_msk = MCI_CMDCRCFAIL | MCI_CMDTIMEOUT;\n\tvoid __iomem *base = host->base;\n\tbool sbc, busy_resp;\n\n\tif (!cmd)\n\t\treturn;\n\n\tsbc = (cmd == host->mrq->sbc);\n\tbusy_resp = !!(cmd->flags & MMC_RSP_BUSY);\n\n\t \n\tif (host->variant->busy_timeout && busy_resp)\n\t\terr_msk |= MCI_DATATIMEOUT;\n\n\tif (!((status | host->busy_status) &\n\t      (err_msk | MCI_CMDSENT | MCI_CMDRESPEND)))\n\t\treturn;\n\n\t \n\tif (busy_resp && host->variant->busy_detect)\n\t\tif (!host->ops->busy_complete(host, cmd, status, err_msk))\n\t\t\treturn;\n\n\thost->cmd = NULL;\n\n\tif (status & MCI_CMDTIMEOUT) {\n\t\tcmd->error = -ETIMEDOUT;\n\t} else if (status & MCI_CMDCRCFAIL && cmd->flags & MMC_RSP_CRC) {\n\t\tcmd->error = -EILSEQ;\n\t} else if (host->variant->busy_timeout && busy_resp &&\n\t\t   status & MCI_DATATIMEOUT) {\n\t\tcmd->error = -ETIMEDOUT;\n\t\t \n\t\thost->irq_action = IRQ_WAKE_THREAD;\n\t} else {\n\t\tcmd->resp[0] = readl(base + MMCIRESPONSE0);\n\t\tcmd->resp[1] = readl(base + MMCIRESPONSE1);\n\t\tcmd->resp[2] = readl(base + MMCIRESPONSE2);\n\t\tcmd->resp[3] = readl(base + MMCIRESPONSE3);\n\t}\n\n\tif ((!sbc && !cmd->data) || cmd->error) {\n\t\tif (host->data) {\n\t\t\t \n\t\t\tmmci_dma_error(host);\n\n\t\t\tmmci_stop_data(host);\n\t\t\tif (host->variant->cmdreg_stop && cmd->error) {\n\t\t\t\tmmci_stop_command(host);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (host->irq_action != IRQ_WAKE_THREAD)\n\t\t\tmmci_request_end(host, host->mrq);\n\n\t} else if (sbc) {\n\t\tmmci_start_command(host, host->mrq->cmd, 0);\n\t} else if (!host->variant->datactrl_first &&\n\t\t   !(cmd->data->flags & MMC_DATA_READ)) {\n\t\tmmci_start_data(host, cmd->data);\n\t}\n}\n\nstatic char *ux500_state_str(struct mmci_host *host)\n{\n\tswitch (host->busy_state) {\n\tcase MMCI_BUSY_WAITING_FOR_START_IRQ:\n\t\treturn \"waiting for start IRQ\";\n\tcase MMCI_BUSY_WAITING_FOR_END_IRQ:\n\t\treturn \"waiting for end IRQ\";\n\tcase MMCI_BUSY_DONE:\n\t\treturn \"not waiting for IRQs\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic void ux500_busy_timeout_work(struct work_struct *work)\n{\n\tstruct mmci_host *host = container_of(work, struct mmci_host,\n\t\t\t\t\tux500_busy_timeout_work.work);\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (host->cmd) {\n\t\t \n\t\tstatus = readl(host->base + MMCISTATUS);\n\t\tif (status & host->variant->busy_detect_flag) {\n\t\t\tstatus |= MCI_CMDTIMEOUT;\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"timeout in state %s still busy with CMD%02x\\n\",\n\t\t\t\tux500_state_str(host), host->cmd->opcode);\n\t\t} else {\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"timeout in state %s waiting for busy CMD%02x\\n\",\n\t\t\t\tux500_state_str(host), host->cmd->opcode);\n\t\t}\n\n\t\tmmci_cmd_irq(host, host->cmd, status);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic int mmci_get_rx_fifocnt(struct mmci_host *host, u32 status, int remain)\n{\n\treturn remain - (readl(host->base + MMCIFIFOCNT) << 2);\n}\n\nstatic int mmci_qcom_get_rx_fifocnt(struct mmci_host *host, u32 status, int r)\n{\n\t \n\tif (status & MCI_RXFIFOHALFFULL)\n\t\treturn host->variant->fifohalfsize;\n\telse if (status & MCI_RXDATAAVLBL)\n\t\treturn 4;\n\n\treturn 0;\n}\n\nstatic int mmci_pio_read(struct mmci_host *host, char *buffer, unsigned int remain)\n{\n\tvoid __iomem *base = host->base;\n\tchar *ptr = buffer;\n\tu32 status = readl(host->base + MMCISTATUS);\n\tint host_remain = host->size;\n\n\tdo {\n\t\tint count = host->get_rx_fifocnt(host, status, host_remain);\n\n\t\tif (count > remain)\n\t\t\tcount = remain;\n\n\t\tif (count <= 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (unlikely(count & 0x3)) {\n\t\t\tif (count < 4) {\n\t\t\t\tunsigned char buf[4];\n\t\t\t\tioread32_rep(base + MMCIFIFO, buf, 1);\n\t\t\t\tmemcpy(ptr, buf, count);\n\t\t\t} else {\n\t\t\t\tioread32_rep(base + MMCIFIFO, ptr, count >> 2);\n\t\t\t\tcount &= ~0x3;\n\t\t\t}\n\t\t} else {\n\t\t\tioread32_rep(base + MMCIFIFO, ptr, count >> 2);\n\t\t}\n\n\t\tptr += count;\n\t\tremain -= count;\n\t\thost_remain -= count;\n\n\t\tif (remain == 0)\n\t\t\tbreak;\n\n\t\tstatus = readl(base + MMCISTATUS);\n\t} while (status & MCI_RXDATAAVLBL);\n\n\treturn ptr - buffer;\n}\n\nstatic int mmci_pio_write(struct mmci_host *host, char *buffer, unsigned int remain, u32 status)\n{\n\tstruct variant_data *variant = host->variant;\n\tvoid __iomem *base = host->base;\n\tchar *ptr = buffer;\n\n\tdo {\n\t\tunsigned int count, maxcnt;\n\n\t\tmaxcnt = status & MCI_TXFIFOEMPTY ?\n\t\t\t variant->fifosize : variant->fifohalfsize;\n\t\tcount = min(remain, maxcnt);\n\n\t\t \n\t\tiowrite32_rep(base + MMCIFIFO, ptr, (count + 3) >> 2);\n\n\t\tptr += count;\n\t\tremain -= count;\n\n\t\tif (remain == 0)\n\t\t\tbreak;\n\n\t\tstatus = readl(base + MMCISTATUS);\n\t} while (status & MCI_TXFIFOHALFEMPTY);\n\n\treturn ptr - buffer;\n}\n\n \nstatic irqreturn_t mmci_pio_irq(int irq, void *dev_id)\n{\n\tstruct mmci_host *host = dev_id;\n\tstruct sg_mapping_iter *sg_miter = &host->sg_miter;\n\tstruct variant_data *variant = host->variant;\n\tvoid __iomem *base = host->base;\n\tu32 status;\n\n\tstatus = readl(base + MMCISTATUS);\n\n\tdev_dbg(mmc_dev(host->mmc), \"irq1 (pio) %08x\\n\", status);\n\n\tdo {\n\t\tunsigned int remain, len;\n\t\tchar *buffer;\n\n\t\t \n\t\tif (!(status & (MCI_TXFIFOHALFEMPTY|MCI_RXDATAAVLBL)))\n\t\t\tbreak;\n\n\t\tif (!sg_miter_next(sg_miter))\n\t\t\tbreak;\n\n\t\tbuffer = sg_miter->addr;\n\t\tremain = sg_miter->length;\n\n\t\tlen = 0;\n\t\tif (status & MCI_RXACTIVE)\n\t\t\tlen = mmci_pio_read(host, buffer, remain);\n\t\tif (status & MCI_TXACTIVE)\n\t\t\tlen = mmci_pio_write(host, buffer, remain, status);\n\n\t\tsg_miter->consumed = len;\n\n\t\thost->size -= len;\n\t\tremain -= len;\n\n\t\tif (remain)\n\t\t\tbreak;\n\n\t\tstatus = readl(base + MMCISTATUS);\n\t} while (1);\n\n\tsg_miter_stop(sg_miter);\n\n\t \n\tif (status & MCI_RXACTIVE && host->size < variant->fifohalfsize)\n\t\tmmci_set_mask1(host, MCI_RXDATAAVLBLMASK);\n\n\t \n\tif (host->size == 0) {\n\t\tmmci_set_mask1(host, 0);\n\t\twritel(readl(base + MMCIMASK0) | MCI_DATAENDMASK, base + MMCIMASK0);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t mmci_irq(int irq, void *dev_id)\n{\n\tstruct mmci_host *host = dev_id;\n\tu32 status;\n\n\tspin_lock(&host->lock);\n\thost->irq_action = IRQ_HANDLED;\n\n\tdo {\n\t\tstatus = readl(host->base + MMCISTATUS);\n\t\tif (!status)\n\t\t\tbreak;\n\n\t\tif (host->singleirq) {\n\t\t\tif (status & host->mask1_reg)\n\t\t\t\tmmci_pio_irq(irq, dev_id);\n\n\t\t\tstatus &= ~host->variant->irq_pio_mask;\n\t\t}\n\n\t\t \n\t\tstatus &= readl(host->base + MMCIMASK0);\n\t\tif (host->variant->busy_detect)\n\t\t\twritel(status & ~host->variant->busy_detect_mask,\n\t\t\t       host->base + MMCICLEAR);\n\t\telse\n\t\t\twritel(status, host->base + MMCICLEAR);\n\n\t\tdev_dbg(mmc_dev(host->mmc), \"irq0 (data+cmd) %08x\\n\", status);\n\n\t\tif (host->variant->reversed_irq_handling) {\n\t\t\tmmci_data_irq(host, host->data, status);\n\t\t\tmmci_cmd_irq(host, host->cmd, status);\n\t\t} else {\n\t\t\tmmci_cmd_irq(host, host->cmd, status);\n\t\t\tmmci_data_irq(host, host->data, status);\n\t\t}\n\n\t\t \n\t\tif (host->variant->busy_detect_flag)\n\t\t\tstatus &= ~host->variant->busy_detect_flag;\n\n\t} while (status);\n\n\tspin_unlock(&host->lock);\n\n\treturn host->irq_action;\n}\n\n \nstatic irqreturn_t mmci_irq_thread(int irq, void *dev_id)\n{\n\tstruct mmci_host *host = dev_id;\n\tunsigned long flags;\n\n\tif (host->rst) {\n\t\treset_control_assert(host->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(host->rst);\n\t}\n\n\tspin_lock_irqsave(&host->lock, flags);\n\twritel(host->clk_reg, host->base + MMCICLOCK);\n\twritel(host->pwr_reg, host->base + MMCIPOWER);\n\twritel(MCI_IRQENABLE | host->variant->start_err,\n\t       host->base + MMCIMASK0);\n\n\thost->irq_action = IRQ_HANDLED;\n\tmmci_request_end(host, host->mrq);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn host->irq_action;\n}\n\nstatic void mmci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\tWARN_ON(host->mrq != NULL);\n\n\tmrq->cmd->error = mmci_validate_data(host, mrq->data);\n\tif (mrq->cmd->error) {\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\thost->mrq = mrq;\n\n\tif (mrq->data)\n\t\tmmci_get_next_data(host, mrq->data);\n\n\tif (mrq->data &&\n\t    (host->variant->datactrl_first || mrq->data->flags & MMC_DATA_READ))\n\t\tmmci_start_data(host, mrq->data);\n\n\tif (mrq->sbc)\n\t\tmmci_start_command(host, mrq->sbc, 0);\n\telse\n\t\tmmci_start_command(host, mrq->cmd, 0);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void mmci_set_max_busy_timeout(struct mmc_host *mmc)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tu32 max_busy_timeout = 0;\n\n\tif (!host->variant->busy_detect)\n\t\treturn;\n\n\tif (host->variant->busy_timeout && mmc->actual_clock)\n\t\tmax_busy_timeout = U32_MAX / DIV_ROUND_UP(mmc->actual_clock,\n\t\t\t\t\t\t\t  MSEC_PER_SEC);\n\n\tmmc->max_busy_timeout = max_busy_timeout;\n}\n\nstatic void mmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct variant_data *variant = host->variant;\n\tu32 pwr = 0;\n\tunsigned long flags;\n\tint ret;\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {\n\t\t\tregulator_disable(mmc->supply.vqmmc);\n\t\t\thost->vqmmc_enabled = false;\n\t\t}\n\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\n\n\t\t \n\t\tpwr |= variant->pwrreg_powerup;\n\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {\n\t\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(mmc_dev(mmc),\n\t\t\t\t\t\"failed to enable vqmmc regulator\\n\");\n\t\t\telse\n\t\t\t\thost->vqmmc_enabled = true;\n\t\t}\n\n\t\tpwr |= MCI_PWR_ON;\n\t\tbreak;\n\t}\n\n\tif (variant->signal_direction && ios->power_mode != MMC_POWER_OFF) {\n\t\t \n\t\tpwr |= host->pwr_reg_add;\n\n\t\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\t\tpwr &= ~MCI_ST_DATA74DIREN;\n\t\telse if (ios->bus_width == MMC_BUS_WIDTH_1)\n\t\t\tpwr &= (~MCI_ST_DATA74DIREN &\n\t\t\t\t~MCI_ST_DATA31DIREN &\n\t\t\t\t~MCI_ST_DATA2DIREN);\n\t}\n\n\tif (variant->opendrain) {\n\t\tif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\n\t\t\tpwr |= variant->opendrain;\n\t} else {\n\t\t \n\t\tif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN)\n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_opendrain);\n\t\telse\n\t\t\tpinctrl_select_default_state(mmc_dev(mmc));\n\t}\n\n\t \n\tif (!ios->clock && variant->pwrreg_clkgate)\n\t\tpwr &= ~MCI_PWR_ON;\n\n\tif (host->variant->explicit_mclk_control &&\n\t    ios->clock != host->clock_cache) {\n\t\tret = clk_set_rate(host->clk, ios->clock);\n\t\tif (ret < 0)\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"Error setting clock rate (%d)\\n\", ret);\n\t\telse\n\t\t\thost->mclk = clk_get_rate(host->clk);\n\t}\n\thost->clock_cache = ios->clock;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (host->ops && host->ops->set_clkreg)\n\t\thost->ops->set_clkreg(host, ios->clock);\n\telse\n\t\tmmci_set_clkreg(host, ios->clock);\n\n\tmmci_set_max_busy_timeout(mmc);\n\n\tif (host->ops && host->ops->set_pwrreg)\n\t\thost->ops->set_pwrreg(host, pwr);\n\telse\n\t\tmmci_write_pwrreg(host, pwr);\n\n\tmmci_reg_delay(host);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic int mmci_get_cd(struct mmc_host *mmc)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct mmci_platform_data *plat = host->plat;\n\tunsigned int status = mmc_gpio_get_cd(mmc);\n\n\tif (status == -ENOSYS) {\n\t\tif (!plat->status)\n\t\t\treturn 1;  \n\n\t\tstatus = plat->status(mmc_dev(host->mmc));\n\t}\n\treturn status;\n}\n\nstatic int mmci_sig_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\n\tif (!ret && host->ops && host->ops->post_sig_volt_switch)\n\t\tret = host->ops->post_sig_volt_switch(host, ios);\n\telse if (ret)\n\t\tret = 0;\n\n\tif (ret < 0)\n\t\tdev_warn(mmc_dev(mmc), \"Voltage switch failed\\n\");\n\n\treturn ret;\n}\n\nstatic struct mmc_host_ops mmci_ops = {\n\t.request\t= mmci_request,\n\t.pre_req\t= mmci_pre_request,\n\t.post_req\t= mmci_post_request,\n\t.set_ios\t= mmci_set_ios,\n\t.get_ro\t\t= mmc_gpio_get_ro,\n\t.get_cd\t\t= mmci_get_cd,\n\t.start_signal_voltage_switch = mmci_sig_volt_switch,\n};\n\nstatic void mmci_probe_level_translator(struct mmc_host *mmc)\n{\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct gpio_desc *cmd_gpio;\n\tstruct gpio_desc *ck_gpio;\n\tstruct gpio_desc *ckin_gpio;\n\tint clk_hi, clk_lo;\n\n\t \n\thost->clk_reg_add |= MCI_STM32_CLK_SELCKIN;\n\n\tcmd_gpio = gpiod_get(dev, \"st,cmd\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(cmd_gpio))\n\t\tgoto exit_cmd;\n\n\tck_gpio = gpiod_get(dev, \"st,ck\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(ck_gpio))\n\t\tgoto exit_ck;\n\n\tckin_gpio = gpiod_get(dev, \"st,ckin\", GPIOD_IN);\n\tif (IS_ERR(ckin_gpio))\n\t\tgoto exit_ckin;\n\n\t \n\n\t \n\tclk_hi = !!gpiod_get_value(ckin_gpio);\n\n\t \n\tgpiod_set_value(ck_gpio, 0);\n\n\t \n\tclk_lo = !!gpiod_get_value(ckin_gpio);\n\n\t \n\tgpiod_direction_input(cmd_gpio);\n\tgpiod_direction_input(ck_gpio);\n\n\t \n\tif (!clk_hi || clk_lo) {\n\t\thost->clk_reg_add &= ~MCI_STM32_CLK_SELCKIN;\n\t\tdev_warn(dev,\n\t\t\t \"Level translator inoperable, CK signal not detected on CKIN, disabling.\\n\");\n\t}\n\n\tgpiod_put(ckin_gpio);\n\nexit_ckin:\n\tgpiod_put(ck_gpio);\nexit_ck:\n\tgpiod_put(cmd_gpio);\nexit_cmd:\n\tpinctrl_select_default_state(dev);\n}\n\nstatic int mmci_of_parse(struct device_node *np, struct mmc_host *mmc)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tint ret = mmc_of_parse(mmc);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (of_property_read_bool(np, \"st,sig-dir-dat0\"))\n\t\thost->pwr_reg_add |= MCI_ST_DATA0DIREN;\n\tif (of_property_read_bool(np, \"st,sig-dir-dat2\"))\n\t\thost->pwr_reg_add |= MCI_ST_DATA2DIREN;\n\tif (of_property_read_bool(np, \"st,sig-dir-dat31\"))\n\t\thost->pwr_reg_add |= MCI_ST_DATA31DIREN;\n\tif (of_property_read_bool(np, \"st,sig-dir-dat74\"))\n\t\thost->pwr_reg_add |= MCI_ST_DATA74DIREN;\n\tif (of_property_read_bool(np, \"st,sig-dir-cmd\"))\n\t\thost->pwr_reg_add |= MCI_ST_CMDDIREN;\n\tif (of_property_read_bool(np, \"st,sig-pin-fbclk\"))\n\t\thost->pwr_reg_add |= MCI_ST_FBCLKEN;\n\tif (of_property_read_bool(np, \"st,sig-dir\"))\n\t\thost->pwr_reg_add |= MCI_STM32_DIRPOL;\n\tif (of_property_read_bool(np, \"st,neg-edge\"))\n\t\thost->clk_reg_add |= MCI_STM32_CLK_NEGEDGE;\n\tif (of_property_read_bool(np, \"st,use-ckin\"))\n\t\tmmci_probe_level_translator(mmc);\n\n\tif (of_property_read_bool(np, \"mmc-cap-mmc-highspeed\"))\n\t\tmmc->caps |= MMC_CAP_MMC_HIGHSPEED;\n\tif (of_property_read_bool(np, \"mmc-cap-sd-highspeed\"))\n\t\tmmc->caps |= MMC_CAP_SD_HIGHSPEED;\n\n\treturn 0;\n}\n\nstatic int mmci_probe(struct amba_device *dev,\n\tconst struct amba_id *id)\n{\n\tstruct mmci_platform_data *plat = dev->dev.platform_data;\n\tstruct device_node *np = dev->dev.of_node;\n\tstruct variant_data *variant = id->data;\n\tstruct mmci_host *host;\n\tstruct mmc_host *mmc;\n\tint ret;\n\n\t \n\tif (!plat && !np) {\n\t\tdev_err(&dev->dev, \"No plat data or DT found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!plat) {\n\t\tplat = devm_kzalloc(&dev->dev, sizeof(*plat), GFP_KERNEL);\n\t\tif (!plat)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tmmc = mmc_alloc_host(sizeof(struct mmci_host), &dev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->mmc_ops = &mmci_ops;\n\tmmc->ops = &mmci_ops;\n\n\tret = mmci_of_parse(np, mmc);\n\tif (ret)\n\t\tgoto host_free;\n\n\t \n\tif (!variant->opendrain) {\n\t\thost->pinctrl = devm_pinctrl_get(&dev->dev);\n\t\tif (IS_ERR(host->pinctrl)) {\n\t\t\tdev_err(&dev->dev, \"failed to get pinctrl\");\n\t\t\tret = PTR_ERR(host->pinctrl);\n\t\t\tgoto host_free;\n\t\t}\n\n\t\thost->pins_opendrain = pinctrl_lookup_state(host->pinctrl,\n\t\t\t\t\t\t\t    MMCI_PINCTRL_STATE_OPENDRAIN);\n\t\tif (IS_ERR(host->pins_opendrain)) {\n\t\t\tdev_err(mmc_dev(mmc), \"Can't select opendrain pins\\n\");\n\t\t\tret = PTR_ERR(host->pins_opendrain);\n\t\t\tgoto host_free;\n\t\t}\n\t}\n\n\thost->hw_designer = amba_manf(dev);\n\thost->hw_revision = amba_rev(dev);\n\tdev_dbg(mmc_dev(mmc), \"designer ID = 0x%02x\\n\", host->hw_designer);\n\tdev_dbg(mmc_dev(mmc), \"revision = 0x%01x\\n\", host->hw_revision);\n\n\thost->clk = devm_clk_get(&dev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\tgoto host_free;\n\t}\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\tgoto host_free;\n\n\tif (variant->qcom_fifo)\n\t\thost->get_rx_fifocnt = mmci_qcom_get_rx_fifocnt;\n\telse\n\t\thost->get_rx_fifocnt = mmci_get_rx_fifocnt;\n\n\thost->plat = plat;\n\thost->variant = variant;\n\thost->mclk = clk_get_rate(host->clk);\n\t \n\tif (host->mclk > variant->f_max) {\n\t\tret = clk_set_rate(host->clk, variant->f_max);\n\t\tif (ret < 0)\n\t\t\tgoto clk_disable;\n\t\thost->mclk = clk_get_rate(host->clk);\n\t\tdev_dbg(mmc_dev(mmc), \"eventual mclk rate: %u Hz\\n\",\n\t\t\thost->mclk);\n\t}\n\n\thost->phybase = dev->res.start;\n\thost->base = devm_ioremap_resource(&dev->dev, &dev->res);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto clk_disable;\n\t}\n\n\tif (variant->init)\n\t\tvariant->init(host);\n\n\t \n\tif (variant->st_clkdiv)\n\t\tmmc->f_min = DIV_ROUND_UP(host->mclk, 257);\n\telse if (variant->stm32_clkdiv)\n\t\tmmc->f_min = DIV_ROUND_UP(host->mclk, 2046);\n\telse if (variant->explicit_mclk_control)\n\t\tmmc->f_min = clk_round_rate(host->clk, 100000);\n\telse\n\t\tmmc->f_min = DIV_ROUND_UP(host->mclk, 512);\n\t \n\tif (mmc->f_max)\n\t\tmmc->f_max = variant->explicit_mclk_control ?\n\t\t\t\tmin(variant->f_max, mmc->f_max) :\n\t\t\t\tmin(host->mclk, mmc->f_max);\n\telse\n\t\tmmc->f_max = variant->explicit_mclk_control ?\n\t\t\t\tfmax : min(host->mclk, fmax);\n\n\n\tdev_dbg(mmc_dev(mmc), \"clocking block at %u Hz\\n\", mmc->f_max);\n\n\thost->rst = devm_reset_control_get_optional_exclusive(&dev->dev, NULL);\n\tif (IS_ERR(host->rst)) {\n\t\tret = PTR_ERR(host->rst);\n\t\tgoto clk_disable;\n\t}\n\tret = reset_control_deassert(host->rst);\n\tif (ret)\n\t\tdev_err(mmc_dev(mmc), \"failed to de-assert reset\\n\");\n\n\t \n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tif (!mmc->ocr_avail)\n\t\tmmc->ocr_avail = plat->ocr_mask;\n\telse if (plat->ocr_mask)\n\t\tdev_warn(mmc_dev(mmc), \"Platform OCR mask is ignored\\n\");\n\n\t \n\tmmc->caps |= MMC_CAP_CMD23;\n\n\t \n\tif (variant->busy_detect) {\n\t\tmmci_ops.card_busy = mmci_card_busy;\n\t\t \n\t\tif (variant->busy_dpsm_flag)\n\t\t\tmmci_write_datactrlreg(host,\n\t\t\t\t\t       host->variant->busy_dpsm_flag);\n\t\tmmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\n\t}\n\n\t \n\tif (variant->busy_timeout)\n\t\tmmc->caps |= MMC_CAP_NEED_RSP_BUSY;\n\n\t \n\thost->stop_abort.opcode = MMC_STOP_TRANSMISSION;\n\thost->stop_abort.arg = 0;\n\thost->stop_abort.flags = MMC_RSP_R1B | MMC_CMD_AC;\n\n\t \n\tmmc->pm_caps |= MMC_PM_KEEP_POWER;\n\n\t \n\tmmc->max_segs = NR_SG;\n\n\t \n\tmmc->max_req_size = (1 << variant->datalength_bits) - 1;\n\n\t \n\tmmc->max_seg_size = mmc->max_req_size;\n\n\t \n\tmmc->max_blk_size = 1 << variant->datactrl_blocksz;\n\n\t \n\tmmc->max_blk_count = mmc->max_req_size >> variant->datactrl_blocksz;\n\n\tspin_lock_init(&host->lock);\n\n\twritel(0, host->base + MMCIMASK0);\n\n\tif (variant->mmcimask1)\n\t\twritel(0, host->base + MMCIMASK1);\n\n\twritel(0xfff, host->base + MMCICLEAR);\n\n\t \n\tif (!np) {\n\t\tret = mmc_gpiod_request_cd(mmc, \"cd\", 0, false, 0);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto clk_disable;\n\n\t\tret = mmc_gpiod_request_ro(mmc, \"wp\", 0, 0);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto clk_disable;\n\t}\n\n\tret = devm_request_threaded_irq(&dev->dev, dev->irq[0], mmci_irq,\n\t\t\t\t\tmmci_irq_thread, IRQF_SHARED,\n\t\t\t\t\tDRIVER_NAME \" (cmd)\", host);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tif (!dev->irq[1])\n\t\thost->singleirq = true;\n\telse {\n\t\tret = devm_request_irq(&dev->dev, dev->irq[1], mmci_pio_irq,\n\t\t\t\tIRQF_SHARED, DRIVER_NAME \" (pio)\", host);\n\t\tif (ret)\n\t\t\tgoto clk_disable;\n\t}\n\n\tif (host->variant->busy_detect)\n\t\tINIT_DELAYED_WORK(&host->ux500_busy_timeout_work,\n\t\t\t\t  ux500_busy_timeout_work);\n\n\twritel(MCI_IRQENABLE | variant->start_err, host->base + MMCIMASK0);\n\n\tamba_set_drvdata(dev, mmc);\n\n\tdev_info(&dev->dev, \"%s: PL%03x manf %x rev%u at 0x%08llx irq %d,%d (pio)\\n\",\n\t\t mmc_hostname(mmc), amba_part(dev), amba_manf(dev),\n\t\t amba_rev(dev), (unsigned long long)dev->res.start,\n\t\t dev->irq[0], dev->irq[1]);\n\n\tmmci_dma_setup(host);\n\n\tpm_runtime_set_autosuspend_delay(&dev->dev, 50);\n\tpm_runtime_use_autosuspend(&dev->dev);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tpm_runtime_put(&dev->dev);\n\treturn 0;\n\n clk_disable:\n\tclk_disable_unprepare(host->clk);\n host_free:\n\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void mmci_remove(struct amba_device *dev)\n{\n\tstruct mmc_host *mmc = amba_get_drvdata(dev);\n\n\tif (mmc) {\n\t\tstruct mmci_host *host = mmc_priv(mmc);\n\t\tstruct variant_data *variant = host->variant;\n\n\t\t \n\t\tpm_runtime_get_sync(&dev->dev);\n\n\t\tmmc_remove_host(mmc);\n\n\t\twritel(0, host->base + MMCIMASK0);\n\n\t\tif (variant->mmcimask1)\n\t\t\twritel(0, host->base + MMCIMASK1);\n\n\t\twritel(0, host->base + MMCICOMMAND);\n\t\twritel(0, host->base + MMCIDATACTRL);\n\n\t\tmmci_dma_release(host);\n\t\tclk_disable_unprepare(host->clk);\n\t\tmmc_free_host(mmc);\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic void mmci_save(struct mmci_host *host)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\twritel(0, host->base + MMCIMASK0);\n\tif (host->variant->pwrreg_nopower) {\n\t\twritel(0, host->base + MMCIDATACTRL);\n\t\twritel(0, host->base + MMCIPOWER);\n\t\twritel(0, host->base + MMCICLOCK);\n\t}\n\tmmci_reg_delay(host);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void mmci_restore(struct mmci_host *host)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (host->variant->pwrreg_nopower) {\n\t\twritel(host->clk_reg, host->base + MMCICLOCK);\n\t\twritel(host->datactrl_reg, host->base + MMCIDATACTRL);\n\t\twritel(host->pwr_reg, host->base + MMCIPOWER);\n\t}\n\twritel(MCI_IRQENABLE | host->variant->start_err,\n\t       host->base + MMCIMASK0);\n\tmmci_reg_delay(host);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic int mmci_runtime_suspend(struct device *dev)\n{\n\tstruct amba_device *adev = to_amba_device(dev);\n\tstruct mmc_host *mmc = amba_get_drvdata(adev);\n\n\tif (mmc) {\n\t\tstruct mmci_host *host = mmc_priv(mmc);\n\t\tpinctrl_pm_select_sleep_state(dev);\n\t\tmmci_save(host);\n\t\tclk_disable_unprepare(host->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int mmci_runtime_resume(struct device *dev)\n{\n\tstruct amba_device *adev = to_amba_device(dev);\n\tstruct mmc_host *mmc = amba_get_drvdata(adev);\n\n\tif (mmc) {\n\t\tstruct mmci_host *host = mmc_priv(mmc);\n\t\tclk_prepare_enable(host->clk);\n\t\tmmci_restore(host);\n\t\tpinctrl_select_default_state(dev);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops mmci_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(mmci_runtime_suspend, mmci_runtime_resume, NULL)\n};\n\nstatic const struct amba_id mmci_ids[] = {\n\t{\n\t\t.id\t= 0x00041180,\n\t\t.mask\t= 0xff0fffff,\n\t\t.data\t= &variant_arm,\n\t},\n\t{\n\t\t.id\t= 0x01041180,\n\t\t.mask\t= 0xff0fffff,\n\t\t.data\t= &variant_arm_extended_fifo,\n\t},\n\t{\n\t\t.id\t= 0x02041180,\n\t\t.mask\t= 0xff0fffff,\n\t\t.data\t= &variant_arm_extended_fifo_hwfc,\n\t},\n\t{\n\t\t.id\t= 0x00041181,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &variant_arm,\n\t},\n\t \n\t{\n\t\t.id     = 0x00180180,\n\t\t.mask   = 0x00ffffff,\n\t\t.data\t= &variant_u300,\n\t},\n\t{\n\t\t.id     = 0x10180180,\n\t\t.mask   = 0xf0ffffff,\n\t\t.data\t= &variant_nomadik,\n\t},\n\t{\n\t\t.id     = 0x00280180,\n\t\t.mask   = 0x00ffffff,\n\t\t.data\t= &variant_nomadik,\n\t},\n\t{\n\t\t.id     = 0x00480180,\n\t\t.mask   = 0xf0ffffff,\n\t\t.data\t= &variant_ux500,\n\t},\n\t{\n\t\t.id     = 0x10480180,\n\t\t.mask   = 0xf0ffffff,\n\t\t.data\t= &variant_ux500v2,\n\t},\n\t{\n\t\t.id     = 0x00880180,\n\t\t.mask   = 0x00ffffff,\n\t\t.data\t= &variant_stm32,\n\t},\n\t{\n\t\t.id     = 0x10153180,\n\t\t.mask\t= 0xf0ffffff,\n\t\t.data\t= &variant_stm32_sdmmc,\n\t},\n\t{\n\t\t.id     = 0x00253180,\n\t\t.mask\t= 0xf0ffffff,\n\t\t.data\t= &variant_stm32_sdmmcv2,\n\t},\n\t{\n\t\t.id     = 0x20253180,\n\t\t.mask\t= 0xf0ffffff,\n\t\t.data\t= &variant_stm32_sdmmcv2,\n\t},\n\t{\n\t\t.id     = 0x00353180,\n\t\t.mask\t= 0xf0ffffff,\n\t\t.data\t= &variant_stm32_sdmmcv3,\n\t},\n\t \n\t{\n\t\t.id     = 0x00051180,\n\t\t.mask\t= 0x000fffff,\n\t\t.data\t= &variant_qcom,\n\t},\n\t{ 0, 0 },\n};\n\nMODULE_DEVICE_TABLE(amba, mmci_ids);\n\nstatic struct amba_driver mmci_driver = {\n\t.drv\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.pm\t= &mmci_dev_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe\t\t= mmci_probe,\n\t.remove\t\t= mmci_remove,\n\t.id_table\t= mmci_ids,\n};\n\nmodule_amba_driver(mmci_driver);\n\nmodule_param(fmax, uint, 0444);\n\nMODULE_DESCRIPTION(\"ARM PrimeCell PL180/181 Multimedia Card Interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}