{
  "module_name": "ushc.c",
  "hash_id": "767255889521d6ff4bc74135ea4ccfbed2f4d8eeb19ff30f7c0262da35a186f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/ushc.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/dma-mapping.h>\n#include <linux/mmc/host.h>\n\nenum ushc_request {\n\tUSHC_GET_CAPS  = 0x00,\n\tUSHC_HOST_CTRL = 0x01,\n\tUSHC_PWR_CTRL  = 0x02,\n\tUSHC_CLK_FREQ  = 0x03,\n\tUSHC_EXEC_CMD  = 0x04,\n\tUSHC_READ_RESP = 0x05,\n\tUSHC_RESET     = 0x06,\n};\n\nenum ushc_request_type {\n\tUSHC_GET_CAPS_TYPE  = USB_DIR_IN  | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_HOST_CTRL_TYPE = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_PWR_CTRL_TYPE  = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_CLK_FREQ_TYPE  = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_EXEC_CMD_TYPE  = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_READ_RESP_TYPE = USB_DIR_IN  | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\tUSHC_RESET_TYPE     = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n};\n\n#define USHC_GET_CAPS_VERSION_MASK 0xff\n#define USHC_GET_CAPS_3V3      (1 << 8)\n#define USHC_GET_CAPS_3V0      (1 << 9)\n#define USHC_GET_CAPS_1V8      (1 << 10)\n#define USHC_GET_CAPS_HIGH_SPD (1 << 16)\n\n#define USHC_HOST_CTRL_4BIT     (1 << 1)\n#define USHC_HOST_CTRL_HIGH_SPD (1 << 0)\n\n#define USHC_PWR_CTRL_OFF 0x00\n#define USHC_PWR_CTRL_3V3 0x01\n#define USHC_PWR_CTRL_3V0 0x02\n#define USHC_PWR_CTRL_1V8 0x03\n\n#define USHC_READ_RESP_BUSY        (1 << 4)\n#define USHC_READ_RESP_ERR_TIMEOUT (1 << 3)\n#define USHC_READ_RESP_ERR_CRC     (1 << 2)\n#define USHC_READ_RESP_ERR_DAT     (1 << 1)\n#define USHC_READ_RESP_ERR_CMD     (1 << 0)\n#define USHC_READ_RESP_ERR_MASK    0x0f\n\nstruct ushc_cbw {\n\t__u8 signature;\n\t__u8 cmd_idx;\n\t__le16 block_size;\n\t__le32 arg;\n} __attribute__((packed));\n\n#define USHC_CBW_SIGNATURE 'C'\n\nstruct ushc_csw {\n\t__u8 signature;\n\t__u8 status;\n\t__le32 response;\n} __attribute__((packed));\n\n#define USHC_CSW_SIGNATURE 'S'\n\nstruct ushc_int_data {\n\tu8 status;\n\tu8 reserved[3];\n};\n\n#define USHC_INT_STATUS_SDIO_INT     (1 << 1)\n#define USHC_INT_STATUS_CARD_PRESENT (1 << 0)\n\n\nstruct ushc_data {\n\tstruct usb_device *usb_dev;\n\tstruct mmc_host *mmc;\n\n\tstruct urb *int_urb;\n\tstruct ushc_int_data *int_data;\n\n\tstruct urb *cbw_urb;\n\tstruct ushc_cbw *cbw;\n\n\tstruct urb *data_urb;\n\n\tstruct urb *csw_urb;\n\tstruct ushc_csw *csw;\n\n\tspinlock_t lock;\n\tstruct mmc_request *current_req;\n\tu32 caps;\n\tu16 host_ctrl;\n\tunsigned long flags;\n\tu8 last_status;\n\tint clock_freq;\n};\n\n#define DISCONNECTED    0\n#define INT_EN          1\n#define IGNORE_NEXT_INT 2\n\nstatic void data_callback(struct urb *urb);\n\nstatic int ushc_hw_reset(struct ushc_data *ushc)\n{\n\treturn usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\n\t\t\t       USHC_RESET, USHC_RESET_TYPE,\n\t\t\t       0, 0, NULL, 0, 100);\n}\n\nstatic int ushc_hw_get_caps(struct ushc_data *ushc)\n{\n\tint ret;\n\tint version;\n\n\tret = usb_control_msg(ushc->usb_dev, usb_rcvctrlpipe(ushc->usb_dev, 0),\n\t\t\t      USHC_GET_CAPS, USHC_GET_CAPS_TYPE,\n\t\t\t      0, 0, &ushc->caps, sizeof(ushc->caps), 100);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tushc->caps = le32_to_cpu(ushc->caps);\n\n\tversion = ushc->caps & USHC_GET_CAPS_VERSION_MASK;\n\tif (version != 0x02) {\n\t\tdev_err(&ushc->usb_dev->dev, \"controller version %d is not supported\\n\", version);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int ushc_hw_set_host_ctrl(struct ushc_data *ushc, u16 mask, u16 val)\n{\n\tu16 host_ctrl;\n\tint ret;\n\n\thost_ctrl = (ushc->host_ctrl & ~mask) | val;\n\tret = usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\n\t\t\t      USHC_HOST_CTRL, USHC_HOST_CTRL_TYPE,\n\t\t\t      host_ctrl, 0, NULL, 0, 100);\n\tif (ret < 0)\n\t\treturn ret;\n\tushc->host_ctrl = host_ctrl;\n\treturn 0;\n}\n\nstatic void int_callback(struct urb *urb)\n{\n\tstruct ushc_data *ushc = urb->context;\n\tu8 status, last_status;\n\n\tif (urb->status < 0)\n\t\treturn;\n\n\tstatus = ushc->int_data->status;\n\tlast_status = ushc->last_status;\n\tushc->last_status = status;\n\n\t \n\n\tif (!test_and_clear_bit(IGNORE_NEXT_INT, &ushc->flags)\n\t    && test_bit(INT_EN, &ushc->flags)\n\t    && status & USHC_INT_STATUS_SDIO_INT) {\n\t\tmmc_signal_sdio_irq(ushc->mmc);\n\t}\n\n\tif ((status ^ last_status) & USHC_INT_STATUS_CARD_PRESENT)\n\t\tmmc_detect_change(ushc->mmc, msecs_to_jiffies(100));\n\n\tif (!test_bit(INT_EN, &ushc->flags))\n\t\tset_bit(IGNORE_NEXT_INT, &ushc->flags);\n\tusb_submit_urb(ushc->int_urb, GFP_ATOMIC);\n}\n\nstatic void cbw_callback(struct urb *urb)\n{\n\tstruct ushc_data *ushc = urb->context;\n\n\tif (urb->status != 0) {\n\t\tusb_unlink_urb(ushc->data_urb);\n\t\tusb_unlink_urb(ushc->csw_urb);\n\t}\n}\n\nstatic void data_callback(struct urb *urb)\n{\n\tstruct ushc_data *ushc = urb->context;\n\n\tif (urb->status != 0)\n\t\tusb_unlink_urb(ushc->csw_urb);\n}\n\nstatic void csw_callback(struct urb *urb)\n{\n\tstruct ushc_data *ushc = urb->context;\n\tstruct mmc_request *req = ushc->current_req;\n\tint status;\n\n\tstatus = ushc->csw->status;\n\n\tif (urb->status != 0) {\n\t\treq->cmd->error = urb->status;\n\t} else if (status & USHC_READ_RESP_ERR_CMD) {\n\t\tif (status & USHC_READ_RESP_ERR_CRC)\n\t\t\treq->cmd->error = -EIO;\n\t\telse\n\t\t\treq->cmd->error = -ETIMEDOUT;\n\t}\n\tif (req->data) {\n\t\tif (status & USHC_READ_RESP_ERR_DAT) {\n\t\t\tif (status & USHC_READ_RESP_ERR_CRC)\n\t\t\t\treq->data->error = -EIO;\n\t\t\telse\n\t\t\t\treq->data->error = -ETIMEDOUT;\n\t\t\treq->data->bytes_xfered = 0;\n\t\t} else {\n\t\t\treq->data->bytes_xfered = req->data->blksz * req->data->blocks;\n\t\t}\n\t}\n\n\treq->cmd->resp[0] = le32_to_cpu(ushc->csw->response);\n\n\tmmc_request_done(ushc->mmc, req);\n}\n\nstatic void ushc_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct ushc_data *ushc = mmc_priv(mmc);\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ushc->lock, flags);\n\n\tif (test_bit(DISCONNECTED, &ushc->flags)) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\n\t \n\tif (req->cmd->flags & MMC_RSP_136) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (req->data && ushc->clock_freq < 6000000) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tushc->current_req = req;\n\n\t \n\tushc->cbw->cmd_idx = cpu_to_le16(req->cmd->opcode);\n\tif (req->data)\n\t\tushc->cbw->block_size = cpu_to_le16(req->data->blksz);\n\telse\n\t\tushc->cbw->block_size = 0;\n\tushc->cbw->arg = cpu_to_le32(req->cmd->arg);\n\n\tret = usb_submit_urb(ushc->cbw_urb, GFP_ATOMIC);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tif (req->data) {\n\t\tstruct mmc_data *data = req->data;\n\t\tint pipe;\n\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tpipe = usb_rcvbulkpipe(ushc->usb_dev, 6);\n\t\telse\n\t\t\tpipe = usb_sndbulkpipe(ushc->usb_dev, 2);\n\n\t\tusb_fill_bulk_urb(ushc->data_urb, ushc->usb_dev, pipe,\n\t\t\t\t  NULL, data->sg->length,\n\t\t\t\t  data_callback, ushc);\n\t\tushc->data_urb->num_sgs = 1;\n\t\tushc->data_urb->sg = data->sg;\n\t\tret = usb_submit_urb(ushc->data_urb, GFP_ATOMIC);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\t \n\tret = usb_submit_urb(ushc->csw_urb, GFP_ATOMIC);\n\nout:\n\tspin_unlock_irqrestore(&ushc->lock, flags);\n\tif (ret < 0) {\n\t\tusb_unlink_urb(ushc->cbw_urb);\n\t\tusb_unlink_urb(ushc->data_urb);\n\t\treq->cmd->error = ret;\n\t\tmmc_request_done(mmc, req);\n\t}\n}\n\nstatic int ushc_set_power(struct ushc_data *ushc, unsigned char power_mode)\n{\n\tu16 voltage;\n\n\tswitch (power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tvoltage = USHC_PWR_CTRL_OFF;\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\tcase MMC_POWER_ON:\n\t\tvoltage = USHC_PWR_CTRL_3V3;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\n\t\t\t       USHC_PWR_CTRL, USHC_PWR_CTRL_TYPE,\n\t\t\t       voltage, 0, NULL, 0, 100);\n}\n\nstatic int ushc_set_bus_width(struct ushc_data *ushc, int bus_width)\n{\n\treturn ushc_hw_set_host_ctrl(ushc, USHC_HOST_CTRL_4BIT,\n\t\t\t\t     bus_width == 4 ? USHC_HOST_CTRL_4BIT : 0);\n}\n\nstatic int ushc_set_bus_freq(struct ushc_data *ushc, int clk, bool enable_hs)\n{\n\tint ret;\n\n\t \n\tif (clk == 0)\n\t\tclk = 400000;\n\n\tret = ushc_hw_set_host_ctrl(ushc, USHC_HOST_CTRL_HIGH_SPD,\n\t\t\t\t    enable_hs ? USHC_HOST_CTRL_HIGH_SPD : 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usb_control_msg(ushc->usb_dev, usb_sndctrlpipe(ushc->usb_dev, 0),\n\t\t\t      USHC_CLK_FREQ, USHC_CLK_FREQ_TYPE,\n\t\t\t      clk & 0xffff, (clk >> 16) & 0xffff, NULL, 0, 100);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tushc->clock_freq = clk;\n\treturn 0;\n}\n\nstatic void ushc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct ushc_data *ushc = mmc_priv(mmc);\n\n\tushc_set_power(ushc, ios->power_mode);\n\tushc_set_bus_width(ushc, 1 << ios->bus_width);\n\tushc_set_bus_freq(ushc, ios->clock, ios->timing == MMC_TIMING_SD_HS);\n}\n\nstatic int ushc_get_cd(struct mmc_host *mmc)\n{\n\tstruct ushc_data *ushc = mmc_priv(mmc);\n\n\treturn !!(ushc->last_status & USHC_INT_STATUS_CARD_PRESENT);\n}\n\nstatic void ushc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct ushc_data *ushc = mmc_priv(mmc);\n\n\tif (enable)\n\t\tset_bit(INT_EN, &ushc->flags);\n\telse\n\t\tclear_bit(INT_EN, &ushc->flags);\n}\n\nstatic void ushc_clean_up(struct ushc_data *ushc)\n{\n\tusb_free_urb(ushc->int_urb);\n\tusb_free_urb(ushc->csw_urb);\n\tusb_free_urb(ushc->data_urb);\n\tusb_free_urb(ushc->cbw_urb);\n\n\tkfree(ushc->int_data);\n\tkfree(ushc->cbw);\n\tkfree(ushc->csw);\n\n\tmmc_free_host(ushc->mmc);\n}\n\nstatic const struct mmc_host_ops ushc_ops = {\n\t.request         = ushc_request,\n\t.set_ios         = ushc_set_ios,\n\t.get_cd          = ushc_get_cd,\n\t.enable_sdio_irq = ushc_enable_sdio_irq,\n};\n\nstatic int ushc_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *usb_dev = interface_to_usbdev(intf);\n\tstruct mmc_host *mmc;\n\tstruct ushc_data *ushc;\n\tint ret;\n\n\tif (intf->cur_altsetting->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\tmmc = mmc_alloc_host(sizeof(struct ushc_data), &intf->dev);\n\tif (mmc == NULL)\n\t\treturn -ENOMEM;\n\tushc = mmc_priv(mmc);\n\tusb_set_intfdata(intf, ushc);\n\n\tushc->usb_dev = usb_dev;\n\tushc->mmc = mmc;\n\n\tspin_lock_init(&ushc->lock);\n\n\tret = ushc_hw_reset(ushc);\n\tif (ret < 0)\n\t\tgoto err;\n\n\t \n\tret = ushc_hw_get_caps(ushc);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tmmc->ops = &ushc_ops;\n\n\tmmc->f_min = 400000;\n\tmmc->f_max = 50000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\n\tmmc->caps |= (ushc->caps & USHC_GET_CAPS_HIGH_SPD) ? MMC_CAP_SD_HIGHSPEED : 0;\n\n\tmmc->max_seg_size  = 512*511;\n\tmmc->max_segs      = 1;\n\tmmc->max_req_size  = 512*511;\n\tmmc->max_blk_size  = 512;\n\tmmc->max_blk_count = 511;\n\n\tushc->int_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (ushc->int_urb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tushc->int_data = kzalloc(sizeof(struct ushc_int_data), GFP_KERNEL);\n\tif (ushc->int_data == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tusb_fill_int_urb(ushc->int_urb, ushc->usb_dev,\n\t\t\t usb_rcvintpipe(usb_dev,\n\t\t\t\t\tintf->cur_altsetting->endpoint[0].desc.bEndpointAddress),\n\t\t\t ushc->int_data, sizeof(struct ushc_int_data),\n\t\t\t int_callback, ushc,\n\t\t\t intf->cur_altsetting->endpoint[0].desc.bInterval);\n\n\tushc->cbw_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (ushc->cbw_urb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tushc->cbw = kzalloc(sizeof(struct ushc_cbw), GFP_KERNEL);\n\tif (ushc->cbw == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tushc->cbw->signature = USHC_CBW_SIGNATURE;\n\n\tusb_fill_bulk_urb(ushc->cbw_urb, ushc->usb_dev, usb_sndbulkpipe(usb_dev, 2),\n\t\t\t  ushc->cbw, sizeof(struct ushc_cbw),\n\t\t\t  cbw_callback, ushc);\n\n\tushc->data_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (ushc->data_urb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tushc->csw_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (ushc->csw_urb == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tushc->csw = kzalloc(sizeof(struct ushc_csw), GFP_KERNEL);\n\tif (ushc->csw == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tusb_fill_bulk_urb(ushc->csw_urb, ushc->usb_dev, usb_rcvbulkpipe(usb_dev, 6),\n\t\t\t  ushc->csw, sizeof(struct ushc_csw),\n\t\t\t  csw_callback, ushc);\n\n\tret = mmc_add_host(ushc->mmc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = usb_submit_urb(ushc->int_urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tmmc_remove_host(ushc->mmc);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tushc_clean_up(ushc);\n\treturn ret;\n}\n\nstatic void ushc_disconnect(struct usb_interface *intf)\n{\n\tstruct ushc_data *ushc = usb_get_intfdata(intf);\n\n\tspin_lock_irq(&ushc->lock);\n\tset_bit(DISCONNECTED, &ushc->flags);\n\tspin_unlock_irq(&ushc->lock);\n\n\tusb_kill_urb(ushc->int_urb);\n\tusb_kill_urb(ushc->cbw_urb);\n\tusb_kill_urb(ushc->data_urb);\n\tusb_kill_urb(ushc->csw_urb);\n\n\tmmc_remove_host(ushc->mmc);\n\n\tushc_clean_up(ushc);\n}\n\nstatic struct usb_device_id ushc_id_table[] = {\n\t \n\t{ USB_DEVICE(0x0a12, 0x5d10) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, ushc_id_table);\n\nstatic struct usb_driver ushc_driver = {\n\t.name       = \"ushc\",\n\t.id_table   = ushc_id_table,\n\t.probe      = ushc_probe,\n\t.disconnect = ushc_disconnect,\n};\n\nmodule_usb_driver(ushc_driver);\n\nMODULE_DESCRIPTION(\"USB SD Host Controller driver\");\nMODULE_AUTHOR(\"David Vrabel <david.vrabel@csr.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}