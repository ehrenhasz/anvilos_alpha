{
  "module_name": "mmc_hsq.c",
  "hash_id": "eab4b9b660b51734c4a1813540c201e109252bb6b94f691da304c1035648b823",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mmc_hsq.c",
  "human_readable_source": "\n \n\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n\n#include \"mmc_hsq.h\"\n\nstatic void mmc_hsq_retry_handler(struct work_struct *work)\n{\n\tstruct mmc_hsq *hsq = container_of(work, struct mmc_hsq, retry_work);\n\tstruct mmc_host *mmc = hsq->mmc;\n\n\tmmc->ops->request(mmc, hsq->mrq);\n}\n\nstatic void mmc_hsq_pump_requests(struct mmc_hsq *hsq)\n{\n\tstruct mmc_host *mmc = hsq->mmc;\n\tstruct hsq_slot *slot;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hsq->lock, flags);\n\n\t \n\tif (hsq->mrq || hsq->recovery_halt) {\n\t\tspin_unlock_irqrestore(&hsq->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (!hsq->qcnt || !hsq->enabled) {\n\t\tspin_unlock_irqrestore(&hsq->lock, flags);\n\t\treturn;\n\t}\n\n\tslot = &hsq->slot[hsq->next_tag];\n\thsq->mrq = slot->mrq;\n\thsq->qcnt--;\n\n\tspin_unlock_irqrestore(&hsq->lock, flags);\n\n\tif (mmc->ops->request_atomic)\n\t\tret = mmc->ops->request_atomic(mmc, hsq->mrq);\n\telse\n\t\tmmc->ops->request(mmc, hsq->mrq);\n\n\t \n\tif (ret == -EBUSY)\n\t\tschedule_work(&hsq->retry_work);\n\telse\n\t\tWARN_ON_ONCE(ret);\n}\n\nstatic void mmc_hsq_update_next_tag(struct mmc_hsq *hsq, int remains)\n{\n\tint tag;\n\n\t \n\tif (!remains) {\n\t\thsq->next_tag = HSQ_INVALID_TAG;\n\t\thsq->tail_tag = HSQ_INVALID_TAG;\n\t\treturn;\n\t}\n\n\ttag = hsq->tag_slot[hsq->next_tag];\n\thsq->tag_slot[hsq->next_tag] = HSQ_INVALID_TAG;\n\thsq->next_tag = tag;\n}\n\nstatic void mmc_hsq_post_request(struct mmc_hsq *hsq)\n{\n\tunsigned long flags;\n\tint remains;\n\n\tspin_lock_irqsave(&hsq->lock, flags);\n\n\tremains = hsq->qcnt;\n\thsq->mrq = NULL;\n\n\t \n\tmmc_hsq_update_next_tag(hsq, remains);\n\n\tif (hsq->waiting_for_idle && !remains) {\n\t\thsq->waiting_for_idle = false;\n\t\twake_up(&hsq->wait_queue);\n\t}\n\n\t \n\tif (hsq->recovery_halt) {\n\t\tspin_unlock_irqrestore(&hsq->lock, flags);\n\t\treturn;\n\t}\n\n\tspin_unlock_irqrestore(&hsq->lock, flags);\n\n\t  \n\tif (remains > 0)\n\t\tmmc_hsq_pump_requests(hsq);\n}\n\n \nbool mmc_hsq_finalize_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsq->lock, flags);\n\n\tif (!hsq->enabled || !hsq->mrq || hsq->mrq != mrq) {\n\t\tspin_unlock_irqrestore(&hsq->lock, flags);\n\t\treturn false;\n\t}\n\n\t \n\thsq->slot[hsq->next_tag].mrq = NULL;\n\n\tspin_unlock_irqrestore(&hsq->lock, flags);\n\n\tmmc_cqe_request_done(mmc, hsq->mrq);\n\n\tmmc_hsq_post_request(hsq);\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mmc_hsq_finalize_request);\n\nstatic void mmc_hsq_recovery_start(struct mmc_host *mmc)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsq->lock, flags);\n\n\thsq->recovery_halt = true;\n\n\tspin_unlock_irqrestore(&hsq->lock, flags);\n}\n\nstatic void mmc_hsq_recovery_finish(struct mmc_host *mmc)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tint remains;\n\n\tspin_lock_irq(&hsq->lock);\n\n\thsq->recovery_halt = false;\n\tremains = hsq->qcnt;\n\n\tspin_unlock_irq(&hsq->lock);\n\n\t \n\tif (remains > 0)\n\t\tmmc_hsq_pump_requests(hsq);\n}\n\nstatic int mmc_hsq_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tint tag = mrq->tag;\n\n\tspin_lock_irq(&hsq->lock);\n\n\tif (!hsq->enabled) {\n\t\tspin_unlock_irq(&hsq->lock);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\tif (hsq->recovery_halt) {\n\t\tspin_unlock_irq(&hsq->lock);\n\t\treturn -EBUSY;\n\t}\n\n\thsq->slot[tag].mrq = mrq;\n\n\t \n\tif (hsq->next_tag == HSQ_INVALID_TAG) {\n\t\thsq->next_tag = tag;\n\t\thsq->tail_tag = tag;\n\t\thsq->tag_slot[hsq->tail_tag] = HSQ_INVALID_TAG;\n\t} else {\n\t\thsq->tag_slot[hsq->tail_tag] = tag;\n\t\thsq->tail_tag = tag;\n\t}\n\n\thsq->qcnt++;\n\n\tspin_unlock_irq(&hsq->lock);\n\n\tmmc_hsq_pump_requests(hsq);\n\n\treturn 0;\n}\n\nstatic void mmc_hsq_post_req(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tif (mmc->ops->post_req)\n\t\tmmc->ops->post_req(mmc, mrq, 0);\n}\n\nstatic bool mmc_hsq_queue_is_idle(struct mmc_hsq *hsq, int *ret)\n{\n\tbool is_idle;\n\n\tspin_lock_irq(&hsq->lock);\n\n\tis_idle = (!hsq->mrq && !hsq->qcnt) ||\n\t\thsq->recovery_halt;\n\n\t*ret = hsq->recovery_halt ? -EBUSY : 0;\n\thsq->waiting_for_idle = !is_idle;\n\n\tspin_unlock_irq(&hsq->lock);\n\n\treturn is_idle;\n}\n\nstatic int mmc_hsq_wait_for_idle(struct mmc_host *mmc)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tint ret;\n\n\twait_event(hsq->wait_queue,\n\t\t   mmc_hsq_queue_is_idle(hsq, &ret));\n\n\treturn ret;\n}\n\nstatic void mmc_hsq_disable(struct mmc_host *mmc)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\tu32 timeout = 500;\n\tint ret;\n\n\tspin_lock_irq(&hsq->lock);\n\n\tif (!hsq->enabled) {\n\t\tspin_unlock_irq(&hsq->lock);\n\t\treturn;\n\t}\n\n\tspin_unlock_irq(&hsq->lock);\n\n\tret = wait_event_timeout(hsq->wait_queue,\n\t\t\t\t mmc_hsq_queue_is_idle(hsq, &ret),\n\t\t\t\t msecs_to_jiffies(timeout));\n\tif (ret == 0) {\n\t\tpr_warn(\"could not stop mmc software queue\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&hsq->lock);\n\n\thsq->enabled = false;\n\n\tspin_unlock_irq(&hsq->lock);\n}\n\nstatic int mmc_hsq_enable(struct mmc_host *mmc, struct mmc_card *card)\n{\n\tstruct mmc_hsq *hsq = mmc->cqe_private;\n\n\tspin_lock_irq(&hsq->lock);\n\n\tif (hsq->enabled) {\n\t\tspin_unlock_irq(&hsq->lock);\n\t\treturn -EBUSY;\n\t}\n\n\thsq->enabled = true;\n\n\tspin_unlock_irq(&hsq->lock);\n\n\treturn 0;\n}\n\nstatic const struct mmc_cqe_ops mmc_hsq_ops = {\n\t.cqe_enable = mmc_hsq_enable,\n\t.cqe_disable = mmc_hsq_disable,\n\t.cqe_request = mmc_hsq_request,\n\t.cqe_post_req = mmc_hsq_post_req,\n\t.cqe_wait_for_idle = mmc_hsq_wait_for_idle,\n\t.cqe_recovery_start = mmc_hsq_recovery_start,\n\t.cqe_recovery_finish = mmc_hsq_recovery_finish,\n};\n\nint mmc_hsq_init(struct mmc_hsq *hsq, struct mmc_host *mmc)\n{\n\tint i;\n\thsq->num_slots = HSQ_NUM_SLOTS;\n\thsq->next_tag = HSQ_INVALID_TAG;\n\thsq->tail_tag = HSQ_INVALID_TAG;\n\n\thsq->slot = devm_kcalloc(mmc_dev(mmc), hsq->num_slots,\n\t\t\t\t sizeof(struct hsq_slot), GFP_KERNEL);\n\tif (!hsq->slot)\n\t\treturn -ENOMEM;\n\n\thsq->mmc = mmc;\n\thsq->mmc->cqe_private = hsq;\n\tmmc->cqe_ops = &mmc_hsq_ops;\n\n\tfor (i = 0; i < HSQ_NUM_SLOTS; i++)\n\t\thsq->tag_slot[i] = HSQ_INVALID_TAG;\n\n\tINIT_WORK(&hsq->retry_work, mmc_hsq_retry_handler);\n\tspin_lock_init(&hsq->lock);\n\tinit_waitqueue_head(&hsq->wait_queue);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmc_hsq_init);\n\nvoid mmc_hsq_suspend(struct mmc_host *mmc)\n{\n\tmmc_hsq_disable(mmc);\n}\nEXPORT_SYMBOL_GPL(mmc_hsq_suspend);\n\nint mmc_hsq_resume(struct mmc_host *mmc)\n{\n\treturn mmc_hsq_enable(mmc, NULL);\n}\nEXPORT_SYMBOL_GPL(mmc_hsq_resume);\n\nMODULE_DESCRIPTION(\"MMC Host Software Queue support\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}