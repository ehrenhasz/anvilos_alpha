{
  "module_name": "sdhci-pci-o2micro.c",
  "hash_id": "39529729e35d90766d08e97180600c846c85521b64cb130c30c34967f93bc120",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pci-o2micro.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/bitfield.h>\n\n#include \"sdhci.h\"\n#include \"sdhci-pci.h\"\n\n \n\n#define O2_SD_PCIE_SWITCH\t0x54\n#define O2_SD_MISC_REG5\t\t0x64\n#define O2_SD_LD0_CTRL\t\t0x68\n#define O2_SD_DEV_CTRL\t\t0x88\n#define O2_SD_LOCK_WP\t\t0xD3\n#define O2_SD_TEST_REG\t\t0xD4\n#define O2_SD_FUNC_REG0\t\t0xDC\n#define O2_SD_MULTI_VCC3V\t0xEE\n#define O2_SD_CLKREQ\t\t0xEC\n#define O2_SD_CAPS\t\t0xE0\n#define O2_SD_ADMA1\t\t0xE2\n#define O2_SD_ADMA2\t\t0xE7\n#define O2_SD_MISC_CTRL2\t0xF0\n#define O2_SD_INF_MOD\t\t0xF1\n#define O2_SD_MISC_CTRL4\t0xFC\n#define O2_SD_MISC_CTRL\t\t0x1C0\n#define O2_SD_EXP_INT_REG\t0x1E0\n#define O2_SD_PWR_FORCE_L0\t0x0002\n#define O2_SD_TUNING_CTRL\t0x300\n#define O2_SD_PLL_SETTING\t0x304\n#define O2_SD_MISC_SETTING\t0x308\n#define O2_SD_CLK_SETTING\t0x328\n#define O2_SD_CAP_REG2\t\t0x330\n#define O2_SD_CAP_REG0\t\t0x334\n#define O2_SD_UHS1_CAP_SETTING\t0x33C\n#define O2_SD_DELAY_CTRL\t0x350\n#define O2_SD_OUTPUT_CLK_SOURCE_SWITCH\t0x354\n#define O2_SD_UHS2_L1_CTRL\t0x35C\n#define O2_SD_FUNC_REG3\t\t0x3E0\n#define O2_SD_FUNC_REG4\t\t0x3E4\n#define O2_SD_PARA_SET_REG1\t0x444\n#define O2_SD_VDDX_CTRL_REG\t0x508\n#define O2_SD_GPIO_CTRL_REG1\t0x510\n#define O2_SD_LED_ENABLE\tBIT(6)\n#define O2_SD_FREG0_LEDOFF\tBIT(13)\n#define O2_SD_SEL_DLL\t\tBIT(16)\n#define O2_SD_FREG4_ENABLE_CLK_SET\tBIT(22)\n#define O2_SD_PHASE_MASK\tGENMASK(23, 20)\n#define O2_SD_FIX_PHASE\t\tFIELD_PREP(O2_SD_PHASE_MASK, 0x9)\n\n#define O2_SD_VENDOR_SETTING\t0x110\n#define O2_SD_VENDOR_SETTING2\t0x1C8\n#define O2_SD_HW_TUNING_DISABLE\tBIT(4)\n\n#define O2_PLL_DLL_WDT_CONTROL1\t0x1CC\n#define  O2_PLL_FORCE_ACTIVE\tBIT(18)\n#define  O2_PLL_LOCK_STATUS\tBIT(14)\n#define  O2_PLL_SOFT_RESET\tBIT(12)\n#define  O2_DLL_LOCK_STATUS\tBIT(11)\n\n#define O2_SD_DETECT_SETTING 0x324\n\nstatic const u32 dmdn_table[] = {0x2B1C0000,\n\t0x2C1A0000, 0x371B0000, 0x35100000};\n#define DMDN_SZ ARRAY_SIZE(dmdn_table)\n\nstruct o2_host {\n\tu8 dll_adjust_count;\n};\n\nstatic void sdhci_o2_wait_card_detect_stable(struct sdhci_host *host)\n{\n\tktime_t timeout;\n\tu32 scratch32;\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 50);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tscratch32 = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\t\tif ((scratch32 & SDHCI_CARD_PRESENT) >> SDHCI_CARD_PRES_SHIFT\n\t\t    == (scratch32 & SDHCI_CD_LVL) >> SDHCI_CD_LVL_SHIFT)\n\t\t\tbreak;\n\n\t\tif (timedout) {\n\t\t\tpr_err(\"%s: Card Detect debounce never finished.\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\t\t\tsdhci_dumpregs(host);\n\t\t\treturn;\n\t\t}\n\t\tudelay(10);\n\t}\n}\n\nstatic void sdhci_o2_enable_internal_clock(struct sdhci_host *host)\n{\n\tktime_t timeout;\n\tu16 scratch;\n\tu32 scratch32;\n\n\t \n\tscratch32 = sdhci_readl(host, O2_PLL_DLL_WDT_CONTROL1);\n\tscratch32 |= O2_PLL_SOFT_RESET;\n\tsdhci_writel(host, scratch32, O2_PLL_DLL_WDT_CONTROL1);\n\tudelay(1);\n\tscratch32 &= ~(O2_PLL_SOFT_RESET);\n\tsdhci_writel(host, scratch32, O2_PLL_DLL_WDT_CONTROL1);\n\n\t \n\tscratch32 |= O2_PLL_FORCE_ACTIVE;\n\tsdhci_writel(host, scratch32, O2_PLL_DLL_WDT_CONTROL1);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 20);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tscratch = sdhci_readw(host, O2_PLL_DLL_WDT_CONTROL1);\n\t\tif (scratch & O2_PLL_LOCK_STATUS)\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tpr_err(\"%s: Internal clock never stabilised.\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\t\t\tsdhci_dumpregs(host);\n\t\t\tgoto out;\n\t\t}\n\t\tudelay(10);\n\t}\n\n\t \n\tudelay(1);\n\tsdhci_o2_wait_card_detect_stable(host);\n\nout:\n\t \n\tscratch32 = sdhci_readl(host, O2_PLL_DLL_WDT_CONTROL1);\n\tscratch32 &= ~O2_PLL_FORCE_ACTIVE;\n\tsdhci_writel(host, scratch32, O2_PLL_DLL_WDT_CONTROL1);\n}\n\nstatic int sdhci_o2_get_cd(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tif (!(sdhci_readw(host, O2_PLL_DLL_WDT_CONTROL1) & O2_PLL_LOCK_STATUS))\n\t\tsdhci_o2_enable_internal_clock(host);\n\telse\n\t\tsdhci_o2_wait_card_detect_stable(host);\n\n\treturn !!(sdhci_readl(host, SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT);\n}\n\nstatic void o2_pci_set_baseclk(struct sdhci_pci_chip *chip, u32 value)\n{\n\tu32 scratch_32;\n\n\tpci_read_config_dword(chip->pdev,\n\t\t\t      O2_SD_PLL_SETTING, &scratch_32);\n\n\tscratch_32 &= 0x0000FFFF;\n\tscratch_32 |= value;\n\n\tpci_write_config_dword(chip->pdev,\n\t\t\t       O2_SD_PLL_SETTING, scratch_32);\n}\n\nstatic u32 sdhci_o2_pll_dll_wdt_control(struct sdhci_host *host)\n{\n\treturn sdhci_readl(host, O2_PLL_DLL_WDT_CONTROL1);\n}\n\n \nstatic int sdhci_o2_wait_dll_detect_lock(struct sdhci_host *host)\n{\n\tu32\tscratch32 = 0;\n\n\treturn readx_poll_timeout(sdhci_o2_pll_dll_wdt_control, host,\n\t\tscratch32, !(scratch32 & O2_DLL_LOCK_STATUS), 1, 1000000);\n}\n\nstatic void sdhci_o2_set_tuning_mode(struct sdhci_host *host)\n{\n\tu16 reg;\n\n\t \n\treg = sdhci_readw(host, O2_SD_VENDOR_SETTING);\n\treg &= ~O2_SD_HW_TUNING_DISABLE;\n\tsdhci_writew(host, reg, O2_SD_VENDOR_SETTING);\n}\n\nstatic void __sdhci_o2_execute_tuning(struct sdhci_host *host, u32 opcode)\n{\n\tint i;\n\n\tsdhci_send_tuning(host, opcode);\n\n\tfor (i = 0; i < 150; i++) {\n\t\tu16 ctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\n\t\tif (!(ctrl & SDHCI_CTRL_EXEC_TUNING)) {\n\t\t\tif (ctrl & SDHCI_CTRL_TUNED_CLK) {\n\t\t\t\thost->tuning_done = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpr_warn(\"%s: HW tuning failed !\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\tbreak;\n\t\t}\n\n\t\tmdelay(1);\n\t}\n\n\tpr_info(\"%s: Tuning failed, falling back to fixed sampling clock\\n\",\n\t\tmmc_hostname(host->mmc));\n\tsdhci_reset_tuning(host);\n}\n\n \nstatic int sdhci_o2_dll_recovery(struct sdhci_host *host)\n{\n\tint ret = 0;\n\tu8 scratch_8 = 0;\n\tu32 scratch_32 = 0;\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct sdhci_pci_chip *chip = slot->chip;\n\tstruct o2_host *o2_host = sdhci_pci_priv(slot);\n\n\t \n\tpci_read_config_byte(chip->pdev,\n\t\t\tO2_SD_LOCK_WP, &scratch_8);\n\tscratch_8 &= 0x7f;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch_8);\n\twhile (o2_host->dll_adjust_count < DMDN_SZ && !ret) {\n\t\t \n\t\tsdhci_writeb(host, 0, SDHCI_CLOCK_CONTROL);\n\n\t\t \n\t\tscratch_32 = sdhci_readl(host, O2_PLL_DLL_WDT_CONTROL1);\n\t\tscratch_32 |= O2_PLL_SOFT_RESET;\n\t\tsdhci_writel(host, scratch_32, O2_PLL_DLL_WDT_CONTROL1);\n\n\t\tpci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_FUNC_REG4,\n\t\t\t\t\t    &scratch_32);\n\t\t \n\t\tscratch_32 |= O2_SD_FREG4_ENABLE_CLK_SET;\n\t\tpci_write_config_dword(chip->pdev, O2_SD_FUNC_REG4, scratch_32);\n\t\to2_pci_set_baseclk(chip, dmdn_table[o2_host->dll_adjust_count]);\n\n\t\t \n\t\tscratch_8 = SDHCI_CLOCK_INT_EN;\n\t\tsdhci_writeb(host, scratch_8, SDHCI_CLOCK_CONTROL);\n\n\t\tif (sdhci_o2_get_cd(host->mmc)) {\n\t\t\t \n\t\t\tusleep_range(5000, 6000);\n\t\t\tif (sdhci_o2_wait_dll_detect_lock(host)) {\n\t\t\t\tscratch_8 |= SDHCI_CLOCK_CARD_EN;\n\t\t\t\tsdhci_writeb(host, scratch_8,\n\t\t\t\t\tSDHCI_CLOCK_CONTROL);\n\t\t\t\tret = 1;\n\t\t\t} else {\n\t\t\t\tpr_warn(\"%s: DLL unlocked when dll_adjust_count is %d.\\n\",\n\t\t\t\t\tmmc_hostname(host->mmc),\n\t\t\t\t\to2_host->dll_adjust_count);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err(\"%s: card present detect failed.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\tbreak;\n\t\t}\n\n\t\to2_host->dll_adjust_count++;\n\t}\n\tif (!ret && o2_host->dll_adjust_count == DMDN_SZ)\n\t\tpr_err(\"%s: DLL adjust over max times\\n\",\n\t\tmmc_hostname(host->mmc));\n\t \n\tpci_read_config_byte(chip->pdev,\n\t\t\t\t   O2_SD_LOCK_WP, &scratch_8);\n\tscratch_8 |= 0x80;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch_8);\n\treturn ret;\n}\n\nstatic int sdhci_o2_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct sdhci_pci_chip *chip = slot->chip;\n\tint current_bus_width = 0;\n\tu32 scratch32 = 0;\n\tu16 scratch = 0;\n\tu8  scratch_8 = 0;\n\tu32 reg_val;\n\n\t \n\tif ((host->timing != MMC_TIMING_MMC_HS200) &&\n\t\t(host->timing != MMC_TIMING_UHS_SDR104) &&\n\t\t(host->timing != MMC_TIMING_UHS_SDR50))\n\t\treturn sdhci_execute_tuning(mmc, opcode);\n\n\tif (WARN_ON(!mmc_op_tuning(opcode)))\n\t\treturn -EINVAL;\n\n\t \n\tscratch = sdhci_readw(host, O2_SD_MISC_CTRL);\n\tscratch |= O2_SD_PWR_FORCE_L0;\n\tsdhci_writew(host, scratch, O2_SD_MISC_CTRL);\n\n\t \n\tswitch (chip->pdev->device) {\n\tcase PCI_DEVICE_ID_O2_SDS0:\n\tcase PCI_DEVICE_ID_O2_SEABIRD0:\n\tcase PCI_DEVICE_ID_O2_SEABIRD1:\n\tcase PCI_DEVICE_ID_O2_SDS1:\n\tcase PCI_DEVICE_ID_O2_FUJIN2:\n\t\t \n\t\treg_val = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\t\treg_val &= ~SDHCI_CLOCK_CARD_EN;\n\t\tsdhci_writew(host, reg_val, SDHCI_CLOCK_CONTROL);\n\n\t\tif (host->timing == MMC_TIMING_MMC_HS200 ||\n\t\t    host->timing == MMC_TIMING_UHS_SDR104) {\n\t\t\t \n\t\t\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch_8);\n\t\t\tscratch_8 &= 0x7f;\n\t\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch_8);\n\n\t\t\t \n\t\t\tpci_read_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, &reg_val);\n\t\t\treg_val &= ~(O2_SD_SEL_DLL | O2_SD_PHASE_MASK);\n\t\t\treg_val |= (O2_SD_SEL_DLL | O2_SD_FIX_PHASE);\n\t\t\tpci_write_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, reg_val);\n\n\t\t\t \n\t\t\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch_8);\n\t\t\tscratch_8 |= 0x80;\n\t\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch_8);\n\t\t}\n\n\t\t \n\t\treg_val = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\t\treg_val |= SDHCI_CLOCK_CARD_EN;\n\t\tsdhci_writew(host, reg_val, SDHCI_CLOCK_CONTROL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (readx_poll_timeout(sdhci_o2_pll_dll_wdt_control, host,\n\t\tscratch32, (scratch32 & O2_DLL_LOCK_STATUS), 1, 5000))\n\t\tpr_warn(\"%s: DLL can't lock in 5ms after force L0 during tuning.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t \n\tif (!sdhci_o2_wait_dll_detect_lock(host))\n\t\tif (!sdhci_o2_dll_recovery(host)) {\n\t\t\tpr_err(\"%s: o2 dll recovery failed\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\treturn -EINVAL;\n\t\t}\n\t \n\tif (mmc->ios.bus_width == MMC_BUS_WIDTH_8) {\n\t\tcurrent_bus_width = mmc->ios.bus_width;\n\t\tmmc->ios.bus_width = MMC_BUS_WIDTH_4;\n\t\tsdhci_set_bus_width(host, MMC_BUS_WIDTH_4);\n\t}\n\n\tsdhci_o2_set_tuning_mode(host);\n\n\tsdhci_start_tuning(host);\n\n\t__sdhci_o2_execute_tuning(host, opcode);\n\n\tsdhci_end_tuning(host);\n\n\tif (current_bus_width == MMC_BUS_WIDTH_8) {\n\t\tmmc->ios.bus_width = MMC_BUS_WIDTH_8;\n\t\tsdhci_set_bus_width(host, current_bus_width);\n\t}\n\n\t \n\tscratch = sdhci_readw(host, O2_SD_MISC_CTRL);\n\tscratch &= ~(O2_SD_PWR_FORCE_L0);\n\tsdhci_writew(host, scratch, O2_SD_MISC_CTRL);\n\n\tsdhci_reset(host, SDHCI_RESET_CMD);\n\tsdhci_reset(host, SDHCI_RESET_DATA);\n\n\thost->flags &= ~SDHCI_HS400_TUNING;\n\treturn 0;\n}\n\nstatic void o2_pci_led_enable(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\tu32 scratch_32;\n\n\t \n\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t    O2_SD_FUNC_REG0, &scratch_32);\n\tif (ret)\n\t\treturn;\n\n\tscratch_32 &= ~O2_SD_FREG0_LEDOFF;\n\tpci_write_config_dword(chip->pdev,\n\t\t\t       O2_SD_FUNC_REG0, scratch_32);\n\n\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t    O2_SD_TEST_REG, &scratch_32);\n\tif (ret)\n\t\treturn;\n\n\tscratch_32 |= O2_SD_LED_ENABLE;\n\tpci_write_config_dword(chip->pdev,\n\t\t\t       O2_SD_TEST_REG, scratch_32);\n}\n\nstatic void sdhci_pci_o2_fujin2_pci_init(struct sdhci_pci_chip *chip)\n{\n\tu32 scratch_32;\n\tint ret;\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_DEV_CTRL, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~((1 << 12) | (1 << 13) | (1 << 14));\n\tpci_write_config_dword(chip->pdev, O2_SD_DEV_CTRL, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_MISC_REG5, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~((1 << 19) | (1 << 11));\n\tscratch_32 |= (1 << 10);\n\tpci_write_config_dword(chip->pdev, O2_SD_MISC_REG5, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_TEST_REG, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 |= (1 << 4);\n\tpci_write_config_dword(chip->pdev, O2_SD_TEST_REG, scratch_32);\n\n\t \n\tpci_write_config_dword(chip->pdev, O2_SD_DELAY_CTRL, 0x00002492);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_LD0_CTRL, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(3 << 12);\n\tpci_write_config_dword(chip->pdev, O2_SD_LD0_CTRL, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_CAP_REG0, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(0x01FE);\n\tscratch_32 |= 0x00CC;\n\tpci_write_config_dword(chip->pdev, O2_SD_CAP_REG0, scratch_32);\n\t \n\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t    O2_SD_TUNING_CTRL, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(0x000000FF);\n\tscratch_32 |= 0x00000066;\n\tpci_write_config_dword(chip->pdev, O2_SD_TUNING_CTRL, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t    O2_SD_UHS2_L1_CTRL, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(0x000000FC);\n\tscratch_32 |= 0x00000084;\n\tpci_write_config_dword(chip->pdev, O2_SD_UHS2_L1_CTRL, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_FUNC_REG3, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~((1 << 21) | (1 << 30));\n\n\tpci_write_config_dword(chip->pdev, O2_SD_FUNC_REG3, scratch_32);\n\n\t \n\tret = pci_read_config_dword(chip->pdev, O2_SD_CAPS, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(0xf0000000);\n\tscratch_32 |= 0x30000000;\n\tpci_write_config_dword(chip->pdev, O2_SD_CAPS, scratch_32);\n\n\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t    O2_SD_MISC_CTRL4, &scratch_32);\n\tif (ret)\n\t\treturn;\n\tscratch_32 &= ~(0x000f0000);\n\tscratch_32 |= 0x00080000;\n\tpci_write_config_dword(chip->pdev, O2_SD_MISC_CTRL4, scratch_32);\n}\n\nstatic void sdhci_pci_o2_enable_msi(struct sdhci_pci_chip *chip,\n\t\t\t\t    struct sdhci_host *host)\n{\n\tint ret;\n\n\tret = pci_find_capability(chip->pdev, PCI_CAP_ID_MSI);\n\tif (!ret) {\n\t\tpr_info(\"%s: unsupported MSI, use INTx irq\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t\treturn;\n\t}\n\n\tret = pci_alloc_irq_vectors(chip->pdev, 1, 1,\n\t\t\t\t    PCI_IRQ_MSI | PCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: enable PCI MSI failed, err=%d\\n\",\n\t\t       mmc_hostname(host->mmc), ret);\n\t\treturn;\n\t}\n\n\thost->irq = pci_irq_vector(chip->pdev, 0);\n}\n\nstatic void sdhci_o2_enable_clk(struct sdhci_host *host, u16 clk)\n{\n\t \n\tclk |= SDHCI_CLOCK_INT_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\tsdhci_o2_enable_internal_clock(host);\n\tif (sdhci_o2_get_cd(host->mmc)) {\n\t\tclk |= SDHCI_CLOCK_CARD_EN;\n\t\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\t}\n}\n\nstatic void sdhci_pci_o2_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tu16 clk;\n\tu8 scratch;\n\tu32 scratch_32;\n\tu32 dmdn_208m, dmdn_200m;\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct sdhci_pci_chip *chip = slot->chip;\n\n\thost->mmc->actual_clock = 0;\n\n\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\n\tif (clock == 0)\n\t\treturn;\n\n\t \n\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\n\tscratch &= 0x7f;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\tif (chip->pdev->device == PCI_DEVICE_ID_O2_GG8_9860 ||\n\t    chip->pdev->device == PCI_DEVICE_ID_O2_GG8_9861 ||\n\t    chip->pdev->device == PCI_DEVICE_ID_O2_GG8_9862 ||\n\t    chip->pdev->device == PCI_DEVICE_ID_O2_GG8_9863) {\n\t\tdmdn_208m = 0x2c500000;\n\t\tdmdn_200m = 0x25200000;\n\t} else {\n\t\tdmdn_208m = 0x2c280000;\n\t\tdmdn_200m = 0x25100000;\n\t}\n\n\tif ((host->timing == MMC_TIMING_UHS_SDR104) && (clock == 200000000)) {\n\t\tpci_read_config_dword(chip->pdev, O2_SD_PLL_SETTING, &scratch_32);\n\n\t\tif ((scratch_32 & 0xFFFF0000) != dmdn_208m)\n\t\t\to2_pci_set_baseclk(chip, dmdn_208m);\n\t} else {\n\t\tpci_read_config_dword(chip->pdev, O2_SD_PLL_SETTING, &scratch_32);\n\n\t\tif ((scratch_32 & 0xFFFF0000) != dmdn_200m)\n\t\t\to2_pci_set_baseclk(chip, dmdn_200m);\n\t}\n\n\tpci_read_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, &scratch_32);\n\tscratch_32 &= ~(O2_SD_SEL_DLL | O2_SD_PHASE_MASK);\n\tpci_write_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, scratch_32);\n\n\t \n\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\n\tscratch |= 0x80;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\tclk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);\n\tsdhci_o2_enable_clk(host, clk);\n}\n\nstatic int sdhci_pci_o2_init_sd_express(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct sdhci_pci_chip *chip = slot->chip;\n\tu8 scratch8;\n\tu16 scratch16;\n\tint ret;\n\n\t \n\tsdhci_writeb(host, 0, SDHCI_CLOCK_CONTROL);\n\n\t \n\tscratch8 = sdhci_readb(host, SDHCI_POWER_CONTROL);\n\tscratch8 &= 0x0F;\n\tif (host->mmc->ios.timing == MMC_TIMING_SD_EXP_1_2V &&\n\t    host->mmc->caps2 & MMC_CAP2_SD_EXP_1_2V) {\n\t\tscratch8 |= SDHCI_VDD2_POWER_ON | SDHCI_VDD2_POWER_120;\n\t} else {\n\t\tscratch8 |= SDHCI_VDD2_POWER_ON | SDHCI_VDD2_POWER_180;\n\t}\n\n\tsdhci_writeb(host, scratch8, SDHCI_POWER_CONTROL);\n\n\t \n\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch8);\n\tscratch8 &= 0x7f;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch8);\n\n\t \n\tret = read_poll_timeout(sdhci_readb, scratch8, !(scratch8 & BIT(0)),\n\t\t\t\t1, 30000, false, host, O2_SD_EXP_INT_REG);\n\n\tif (!ret) {\n\t\t \n\t\tscratch16 = sdhci_readw(host, O2_SD_PCIE_SWITCH);\n\t\tscratch16 |= BIT(8);\n\t\tsdhci_writew(host, scratch16, O2_SD_PCIE_SWITCH);\n\t} else {\n\t\t \n\t\tscratch8 = sdhci_readb(host, SDHCI_POWER_CONTROL);\n\t\tscratch8 &= 0x0F;\n\t\tsdhci_writeb(host, scratch8, SDHCI_POWER_CONTROL);\n\n\t\t \n\t\tpci_read_config_word(chip->pdev, O2_SD_PARA_SET_REG1, &scratch16);\n\t\tscratch16 &= ~BIT(11);\n\t\tpci_write_config_word(chip->pdev, O2_SD_PARA_SET_REG1, scratch16);\n\n\t\thost->mmc->ios.timing = MMC_TIMING_LEGACY;\n\t\tpr_info(\"%s: Express card initialization failed, falling back to Legacy\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t}\n\t \n\tpci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch8);\n\tscratch8 |= 0x80;\n\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch8);\n\n\treturn 0;\n}\n\nstatic int sdhci_pci_o2_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tstruct sdhci_pci_chip *chip;\n\tstruct sdhci_host *host;\n\tstruct o2_host *o2_host = sdhci_pci_priv(slot);\n\tu32 reg, caps;\n\tint ret;\n\n\tchip = slot->chip;\n\thost = slot->host;\n\n\to2_host->dll_adjust_count = 0;\n\tcaps = sdhci_readl(host, SDHCI_CAPABILITIES);\n\n\t \n\tif (caps & SDHCI_CAN_DO_8BIT)\n\t\thost->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\n\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_DDR50;\n\n\tsdhci_pci_o2_enable_msi(chip, host);\n\n\thost->mmc_host_ops.execute_tuning = sdhci_o2_execute_tuning;\n\tswitch (chip->pdev->device) {\n\tcase PCI_DEVICE_ID_O2_SDS0:\n\tcase PCI_DEVICE_ID_O2_SEABIRD0:\n\tcase PCI_DEVICE_ID_O2_SEABIRD1:\n\tcase PCI_DEVICE_ID_O2_SDS1:\n\tcase PCI_DEVICE_ID_O2_FUJIN2:\n\t\treg = sdhci_readl(host, O2_SD_VENDOR_SETTING);\n\t\tif (reg & 0x1)\n\t\t\thost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\n\n\t\tif (chip->pdev->device == PCI_DEVICE_ID_O2_SEABIRD0) {\n\t\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t\t    O2_SD_MISC_SETTING, &reg);\n\t\t\tif (ret)\n\t\t\t\treturn -EIO;\n\t\t\tif (reg & (1 << 4)) {\n\t\t\t\tpr_info(\"%s: emmc 1.8v flag is set, force 1.8v signaling voltage\\n\",\n\t\t\t\t\tmmc_hostname(host->mmc));\n\t\t\t\thost->flags &= ~SDHCI_SIGNALING_330;\n\t\t\t\thost->flags |= SDHCI_SIGNALING_180;\n\t\t\t\thost->mmc->caps2 |= MMC_CAP2_NO_SD;\n\t\t\t\thost->mmc->caps2 |= MMC_CAP2_NO_SDIO;\n\t\t\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t\t\t       O2_SD_DETECT_SETTING, 3);\n\t\t\t}\n\n\t\t\tslot->host->mmc_host_ops.get_cd = sdhci_o2_get_cd;\n\t\t}\n\n\t\tif (chip->pdev->device == PCI_DEVICE_ID_O2_SEABIRD1) {\n\t\t\tslot->host->mmc_host_ops.get_cd = sdhci_o2_get_cd;\n\t\t\thost->mmc->caps2 |= MMC_CAP2_NO_SDIO;\n\t\t\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\t\t}\n\n\t\tif (chip->pdev->device != PCI_DEVICE_ID_O2_FUJIN2)\n\t\t\tbreak;\n\t\t \n\t\treg = sdhci_readl(host, O2_SD_VENDOR_SETTING2);\n\t\treg |= (1 << 12);\n\t\tsdhci_writel(host, reg, O2_SD_VENDOR_SETTING2);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_O2_GG8_9860:\n\tcase PCI_DEVICE_ID_O2_GG8_9861:\n\tcase PCI_DEVICE_ID_O2_GG8_9862:\n\tcase PCI_DEVICE_ID_O2_GG8_9863:\n\t\thost->mmc->caps2 |= MMC_CAP2_NO_SDIO | MMC_CAP2_SD_EXP | MMC_CAP2_SD_EXP_1_2V;\n\t\thost->mmc->caps |= MMC_CAP_HW_RESET;\n\t\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\t\tslot->host->mmc_host_ops.get_cd = sdhci_o2_get_cd;\n\t\thost->mmc_host_ops.init_sd_express = sdhci_pci_o2_init_sd_express;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_pci_o2_probe(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\tu8 scratch;\n\tu16 scratch16;\n\tu32 scratch_32;\n\n\tswitch (chip->pdev->device) {\n\tcase PCI_DEVICE_ID_O2_8220:\n\tcase PCI_DEVICE_ID_O2_8221:\n\tcase PCI_DEVICE_ID_O2_8320:\n\tcase PCI_DEVICE_ID_O2_8321:\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch &= 0x7f;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\t\t \n\t\tpci_write_config_byte(chip->pdev, O2_SD_MULTI_VCC3V, 0x08);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_CLKREQ, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x20;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_CLKREQ, scratch);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev, O2_SD_CAPS, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x01;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_CAPS, scratch);\n\t\tpci_write_config_byte(chip->pdev, O2_SD_CAPS, 0x73);\n\n\t\t \n\t\tpci_write_config_byte(chip->pdev, O2_SD_ADMA1, 0x39);\n\t\tpci_write_config_byte(chip->pdev, O2_SD_ADMA2, 0x08);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_INF_MOD, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x08;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_INF_MOD, scratch);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x80;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_O2_SDS0:\n\tcase PCI_DEVICE_ID_O2_SDS1:\n\tcase PCI_DEVICE_ID_O2_FUJIN2:\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tscratch &= 0x7f;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\t\t \n\t\tif (chip->pdev->device == PCI_DEVICE_ID_O2_FUJIN2) {\n\t\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t\t    O2_SD_FUNC_REG0,\n\t\t\t\t\t\t    &scratch_32);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tscratch_32 = ((scratch_32 & 0xFF000000) >> 24);\n\n\t\t\t \n\t\t\tif ((scratch_32 == 0x11) || (scratch_32 == 0x12)) {\n\t\t\t\tscratch_32 = 0x25100000;\n\n\t\t\t\to2_pci_set_baseclk(chip, scratch_32);\n\t\t\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t\t\t    O2_SD_FUNC_REG4,\n\t\t\t\t\t\t\t    &scratch_32);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\n\t\t\t\t \n\t\t\t\tscratch_32 |= O2_SD_FREG4_ENABLE_CLK_SET;\n\t\t\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t\t\t       O2_SD_FUNC_REG4,\n\t\t\t\t\t\t       scratch_32);\n\n\t\t\t\t \n\t\t\t\tpci_write_config_byte(chip->pdev,\n\t\t\t\t\t\t      O2_SD_TUNING_CTRL, 0x44);\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\to2_pci_led_enable(chip);\n\n\t\t \n\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_CLK_SETTING, &scratch_32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tscratch_32 &= ~(0xFF00);\n\t\tscratch_32 |= 0x07E0C800;\n\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t       O2_SD_CLK_SETTING, scratch_32);\n\n\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_CLKREQ, &scratch_32);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch_32 |= 0x3;\n\t\tpci_write_config_dword(chip->pdev, O2_SD_CLKREQ, scratch_32);\n\n\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_PLL_SETTING, &scratch_32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tscratch_32 &= ~(0x1F3F070E);\n\t\tscratch_32 |= 0x18270106;\n\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t       O2_SD_PLL_SETTING, scratch_32);\n\n\t\t \n\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_CAP_REG2, &scratch_32);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch_32 &= ~(0xE0);\n\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t       O2_SD_CAP_REG2, scratch_32);\n\n\t\tif (chip->pdev->device == PCI_DEVICE_ID_O2_FUJIN2)\n\t\t\tsdhci_pci_o2_fujin2_pci_init(chip);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\t\t   O2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x80;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_O2_SEABIRD0:\n\tcase PCI_DEVICE_ID_O2_SEABIRD1:\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\tO2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tscratch &= 0x7f;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t    O2_SD_PLL_SETTING, &scratch_32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((scratch_32 & 0xff000000) == 0x01000000) {\n\t\t\tscratch_32 &= 0x0000FFFF;\n\t\t\tscratch_32 |= 0x1F340000;\n\n\t\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t\t       O2_SD_PLL_SETTING, scratch_32);\n\t\t} else {\n\t\t\tscratch_32 &= 0x0000FFFF;\n\t\t\tscratch_32 |= 0x25100000;\n\n\t\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t\t       O2_SD_PLL_SETTING, scratch_32);\n\n\t\t\tret = pci_read_config_dword(chip->pdev,\n\t\t\t\t\t\t    O2_SD_FUNC_REG4,\n\t\t\t\t\t\t    &scratch_32);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tscratch_32 |= (1 << 22);\n\t\t\tpci_write_config_dword(chip->pdev,\n\t\t\t\t\t       O2_SD_FUNC_REG4, scratch_32);\n\t\t}\n\n\t\t \n\t\tpci_write_config_byte(chip->pdev,\n\t\t\t\tO2_SD_TUNING_CTRL, 0x55);\n\t\t\n\t\tpci_read_config_dword(chip->pdev, O2_SD_MISC_CTRL2, &scratch_32);\n\t\tscratch_32 &= 0xFFE7FFFF;\n\t\tscratch_32 |= 0x00180000;\n\t\tpci_write_config_dword(chip->pdev, O2_SD_MISC_CTRL2, scratch_32);\n\t\tpci_write_config_dword(chip->pdev, O2_SD_DETECT_SETTING, 1);\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev,\n\t\t\t\t\t   O2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x80;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\t\tbreak;\n\tcase PCI_DEVICE_ID_O2_GG8_9860:\n\tcase PCI_DEVICE_ID_O2_GG8_9861:\n\tcase PCI_DEVICE_ID_O2_GG8_9862:\n\tcase PCI_DEVICE_ID_O2_GG8_9863:\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch &= 0x7f;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\n\t\t \n\t\tpci_read_config_word(chip->pdev, O2_SD_PARA_SET_REG1, &scratch16);\n\t\tscratch16 &= 0xF8FF;\n\t\tscratch16 |= BIT(9);\n\t\tpci_write_config_word(chip->pdev, O2_SD_PARA_SET_REG1, scratch16);\n\n\t\t \n\t\tpci_read_config_word(chip->pdev, O2_SD_VDDX_CTRL_REG, &scratch16);\n\t\tscratch16 &= 0xFFE3;\n\t\tscratch16 |= BIT(3);\n\t\tpci_write_config_word(chip->pdev, O2_SD_VDDX_CTRL_REG, scratch16);\n\n\t\t \n\t\tscratch16 = 0x0025;\n\t\tpci_write_config_word(chip->pdev, O2_SD_PLL_SETTING, scratch16);\n\n\t\t \n\t\tpci_read_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, &scratch_32);\n\t\tscratch_32 &= 0xFF0FFF00;\n\t\tscratch_32 |= 0x00B0003B;\n\t\tpci_write_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, scratch_32);\n\n\t\t \n\t\tret = pci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tscratch |= 0x80;\n\t\tpci_write_config_byte(chip->pdev, O2_SD_LOCK_WP, scratch);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_pci_o2_resume(struct sdhci_pci_chip *chip)\n{\n\tsdhci_pci_o2_probe(chip);\n\treturn sdhci_pci_resume_host(chip);\n}\n#endif\n\nstatic const struct sdhci_ops sdhci_pci_o2_ops = {\n\t.set_clock = sdhci_pci_o2_set_clock,\n\t.enable_dma = sdhci_pci_enable_dma,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nconst struct sdhci_pci_fixes sdhci_o2 = {\n\t.probe = sdhci_pci_o2_probe,\n\t.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.quirks2 = SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD,\n\t.probe_slot = sdhci_pci_o2_probe_slot,\n#ifdef CONFIG_PM_SLEEP\n\t.resume = sdhci_pci_o2_resume,\n#endif\n\t.ops = &sdhci_pci_o2_ops,\n\t.priv_size = sizeof(struct o2_host),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}