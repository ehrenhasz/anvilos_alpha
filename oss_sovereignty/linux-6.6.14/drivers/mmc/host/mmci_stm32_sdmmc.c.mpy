{
  "module_name": "mmci_stm32_sdmmc.c",
  "hash_id": "5bd8ae0676355a946e49ae862b72b9e2d510c65f7127bda1ad5eadacb8192491",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mmci_stm32_sdmmc.c",
  "human_readable_source": "\n \n#include <linux/bitfield.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/of_address.h>\n#include <linux/reset.h>\n#include <linux/scatterlist.h>\n#include \"mmci.h\"\n\n#define SDMMC_LLI_BUF_LEN\tPAGE_SIZE\n\n#define DLYB_CR\t\t\t0x0\n#define DLYB_CR_DEN\t\tBIT(0)\n#define DLYB_CR_SEN\t\tBIT(1)\n\n#define DLYB_CFGR\t\t0x4\n#define DLYB_CFGR_SEL_MASK\tGENMASK(3, 0)\n#define DLYB_CFGR_UNIT_MASK\tGENMASK(14, 8)\n#define DLYB_CFGR_LNG_MASK\tGENMASK(27, 16)\n#define DLYB_CFGR_LNGF\t\tBIT(31)\n\n#define DLYB_NB_DELAY\t\t11\n#define DLYB_CFGR_SEL_MAX\t(DLYB_NB_DELAY + 1)\n#define DLYB_CFGR_UNIT_MAX\t127\n\n#define DLYB_LNG_TIMEOUT_US\t1000\n#define SDMMC_VSWEND_TIMEOUT_US 10000\n\n#define SYSCFG_DLYBSD_CR\t0x0\n#define DLYBSD_CR_EN\t\tBIT(0)\n#define DLYBSD_CR_RXTAPSEL_MASK\tGENMASK(6, 1)\n#define DLYBSD_TAPSEL_NB\t32\n#define DLYBSD_BYP_EN\t\tBIT(16)\n#define DLYBSD_BYP_CMD\t\tGENMASK(21, 17)\n#define DLYBSD_ANTIGLITCH_EN\tBIT(22)\n\n#define SYSCFG_DLYBSD_SR\t0x4\n#define DLYBSD_SR_LOCK\t\tBIT(0)\n#define DLYBSD_SR_RXTAPSEL_ACK\tBIT(1)\n\n#define DLYBSD_TIMEOUT_1S_IN_US\t1000000\n\nstruct sdmmc_lli_desc {\n\tu32 idmalar;\n\tu32 idmabase;\n\tu32 idmasize;\n};\n\nstruct sdmmc_idma {\n\tdma_addr_t sg_dma;\n\tvoid *sg_cpu;\n\tdma_addr_t bounce_dma_addr;\n\tvoid *bounce_buf;\n\tbool use_bounce_buffer;\n};\n\nstruct sdmmc_dlyb;\n\nstruct sdmmc_tuning_ops {\n\tint (*dlyb_enable)(struct sdmmc_dlyb *dlyb);\n\tvoid (*set_input_ck)(struct sdmmc_dlyb *dlyb);\n\tint (*tuning_prepare)(struct mmci_host *host);\n\tint (*set_cfg)(struct sdmmc_dlyb *dlyb, int unit __maybe_unused,\n\t\t       int phase, bool sampler __maybe_unused);\n};\n\nstruct sdmmc_dlyb {\n\tvoid __iomem *base;\n\tu32 unit;\n\tu32 max;\n\tstruct sdmmc_tuning_ops *ops;\n};\n\nstatic int sdmmc_idma_validate_data(struct mmci_host *host,\n\t\t\t\t    struct mmc_data *data)\n{\n\tstruct sdmmc_idma *idma = host->dma_priv;\n\tstruct device *dev = mmc_dev(host->mmc);\n\tstruct scatterlist *sg;\n\tint i;\n\n\t \n\tidma->use_bounce_buffer = false;\n\tfor_each_sg(data->sg, sg, data->sg_len - 1, i) {\n\t\tif (!IS_ALIGNED(sg->offset, sizeof(u32)) ||\n\t\t    !IS_ALIGNED(sg->length,\n\t\t\t\thost->variant->stm32_idmabsize_align)) {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"unaligned scatterlist: ofst:%x length:%d\\n\",\n\t\t\t\tdata->sg->offset, data->sg->length);\n\t\t\tgoto use_bounce_buffer;\n\t\t}\n\t}\n\n\tif (!IS_ALIGNED(sg->offset, sizeof(u32))) {\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"unaligned last scatterlist: ofst:%x length:%d\\n\",\n\t\t\tdata->sg->offset, data->sg->length);\n\t\tgoto use_bounce_buffer;\n\t}\n\n\treturn 0;\n\nuse_bounce_buffer:\n\tif (!idma->bounce_buf) {\n\t\tidma->bounce_buf = dmam_alloc_coherent(dev,\n\t\t\t\t\t\t       host->mmc->max_req_size,\n\t\t\t\t\t\t       &idma->bounce_dma_addr,\n\t\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!idma->bounce_buf) {\n\t\t\tdev_err(dev, \"Unable to map allocate DMA bounce buffer.\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tidma->use_bounce_buffer = true;\n\n\treturn 0;\n}\n\nstatic int _sdmmc_idma_prep_data(struct mmci_host *host,\n\t\t\t\t struct mmc_data *data)\n{\n\tstruct sdmmc_idma *idma = host->dma_priv;\n\n\tif (idma->use_bounce_buffer) {\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tunsigned int xfer_bytes = data->blksz * data->blocks;\n\n\t\t\tsg_copy_to_buffer(data->sg, data->sg_len,\n\t\t\t\t\t  idma->bounce_buf, xfer_bytes);\n\t\t\tdma_wmb();\n\t\t}\n\t} else {\n\t\tint n_elem;\n\n\t\tn_elem = dma_map_sg(mmc_dev(host->mmc),\n\t\t\t\t    data->sg,\n\t\t\t\t    data->sg_len,\n\t\t\t\t    mmc_get_dma_dir(data));\n\n\t\tif (!n_elem) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"dma_map_sg failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int sdmmc_idma_prep_data(struct mmci_host *host,\n\t\t\t\tstruct mmc_data *data, bool next)\n{\n\t \n\tif (!next && data->host_cookie == host->next_cookie)\n\t\treturn 0;\n\n\treturn _sdmmc_idma_prep_data(host, data);\n}\n\nstatic void sdmmc_idma_unprep_data(struct mmci_host *host,\n\t\t\t\t   struct mmc_data *data, int err)\n{\n\tstruct sdmmc_idma *idma = host->dma_priv;\n\n\tif (idma->use_bounce_buffer) {\n\t\tif (data->flags & MMC_DATA_READ) {\n\t\t\tunsigned int xfer_bytes = data->blksz * data->blocks;\n\n\t\t\tsg_copy_from_buffer(data->sg, data->sg_len,\n\t\t\t\t\t    idma->bounce_buf, xfer_bytes);\n\t\t}\n\t} else {\n\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t}\n}\n\nstatic int sdmmc_idma_setup(struct mmci_host *host)\n{\n\tstruct sdmmc_idma *idma;\n\tstruct device *dev = mmc_dev(host->mmc);\n\n\tidma = devm_kzalloc(dev, sizeof(*idma), GFP_KERNEL);\n\tif (!idma)\n\t\treturn -ENOMEM;\n\n\thost->dma_priv = idma;\n\n\tif (host->variant->dma_lli) {\n\t\tidma->sg_cpu = dmam_alloc_coherent(dev, SDMMC_LLI_BUF_LEN,\n\t\t\t\t\t\t   &idma->sg_dma, GFP_KERNEL);\n\t\tif (!idma->sg_cpu) {\n\t\t\tdev_err(dev, \"Failed to alloc IDMA descriptor\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\thost->mmc->max_segs = SDMMC_LLI_BUF_LEN /\n\t\t\tsizeof(struct sdmmc_lli_desc);\n\t\thost->mmc->max_seg_size = host->variant->stm32_idmabsize_mask;\n\n\t\thost->mmc->max_req_size = SZ_1M;\n\t} else {\n\t\thost->mmc->max_segs = 1;\n\t\thost->mmc->max_seg_size = host->mmc->max_req_size;\n\t}\n\n\treturn dma_set_max_seg_size(dev, host->mmc->max_seg_size);\n}\n\nstatic int sdmmc_idma_start(struct mmci_host *host, unsigned int *datactrl)\n\n{\n\tstruct sdmmc_idma *idma = host->dma_priv;\n\tstruct sdmmc_lli_desc *desc = (struct sdmmc_lli_desc *)idma->sg_cpu;\n\tstruct mmc_data *data = host->data;\n\tstruct scatterlist *sg;\n\tint i;\n\n\tif (!host->variant->dma_lli || data->sg_len == 1 ||\n\t    idma->use_bounce_buffer) {\n\t\tu32 dma_addr;\n\n\t\tif (idma->use_bounce_buffer)\n\t\t\tdma_addr = idma->bounce_dma_addr;\n\t\telse\n\t\t\tdma_addr = sg_dma_address(data->sg);\n\n\t\twritel_relaxed(dma_addr,\n\t\t\t       host->base + MMCI_STM32_IDMABASE0R);\n\t\twritel_relaxed(MMCI_STM32_IDMAEN,\n\t\t\t       host->base + MMCI_STM32_IDMACTRLR);\n\t\treturn 0;\n\t}\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tdesc[i].idmalar = (i + 1) * sizeof(struct sdmmc_lli_desc);\n\t\tdesc[i].idmalar |= MMCI_STM32_ULA | MMCI_STM32_ULS\n\t\t\t| MMCI_STM32_ABR;\n\t\tdesc[i].idmabase = sg_dma_address(sg);\n\t\tdesc[i].idmasize = sg_dma_len(sg);\n\t}\n\n\t \n\tdesc[data->sg_len - 1].idmalar &= ~MMCI_STM32_ULA;\n\n\tdma_wmb();\n\twritel_relaxed(idma->sg_dma, host->base + MMCI_STM32_IDMABAR);\n\twritel_relaxed(desc[0].idmalar, host->base + MMCI_STM32_IDMALAR);\n\twritel_relaxed(desc[0].idmabase, host->base + MMCI_STM32_IDMABASE0R);\n\twritel_relaxed(desc[0].idmasize, host->base + MMCI_STM32_IDMABSIZER);\n\twritel_relaxed(MMCI_STM32_IDMAEN | MMCI_STM32_IDMALLIEN,\n\t\t       host->base + MMCI_STM32_IDMACTRLR);\n\n\treturn 0;\n}\n\nstatic void sdmmc_idma_finalize(struct mmci_host *host, struct mmc_data *data)\n{\n\twritel_relaxed(0, host->base + MMCI_STM32_IDMACTRLR);\n\n\tif (!data->host_cookie)\n\t\tsdmmc_idma_unprep_data(host, data, 0);\n}\n\nstatic void mmci_sdmmc_set_clkreg(struct mmci_host *host, unsigned int desired)\n{\n\tunsigned int clk = 0, ddr = 0;\n\n\tif (host->mmc->ios.timing == MMC_TIMING_MMC_DDR52 ||\n\t    host->mmc->ios.timing == MMC_TIMING_UHS_DDR50)\n\t\tddr = MCI_STM32_CLK_DDR;\n\n\t \n\tif (desired) {\n\t\tif (desired >= host->mclk && !ddr) {\n\t\t\thost->cclk = host->mclk;\n\t\t} else {\n\t\t\tclk = DIV_ROUND_UP(host->mclk, 2 * desired);\n\t\t\tif (clk > MCI_STM32_CLK_CLKDIV_MSK)\n\t\t\t\tclk = MCI_STM32_CLK_CLKDIV_MSK;\n\t\t\thost->cclk = host->mclk / (2 * clk);\n\t\t}\n\t} else {\n\t\t \n\t\tclk = MCI_STM32_CLK_CLKDIV_MSK;\n\t\thost->cclk = host->mclk / (2 * clk);\n\t}\n\n\t \n\tif (host->mmc->ios.power_mode == MMC_POWER_ON)\n\t\thost->mmc->actual_clock = host->cclk;\n\telse\n\t\thost->mmc->actual_clock = 0;\n\n\tif (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)\n\t\tclk |= MCI_STM32_CLK_WIDEBUS_4;\n\tif (host->mmc->ios.bus_width == MMC_BUS_WIDTH_8)\n\t\tclk |= MCI_STM32_CLK_WIDEBUS_8;\n\n\tclk |= MCI_STM32_CLK_HWFCEN;\n\tclk |= host->clk_reg_add;\n\tclk |= ddr;\n\n\tif (host->mmc->ios.timing >= MMC_TIMING_UHS_SDR50)\n\t\tclk |= MCI_STM32_CLK_BUSSPEED;\n\n\tmmci_write_clkreg(host, clk);\n}\n\nstatic void sdmmc_dlyb_mp15_input_ck(struct sdmmc_dlyb *dlyb)\n{\n\tif (!dlyb || !dlyb->base)\n\t\treturn;\n\n\t \n\twritel_relaxed(0, dlyb->base + DLYB_CR);\n}\n\nstatic void mmci_sdmmc_set_pwrreg(struct mmci_host *host, unsigned int pwr)\n{\n\tstruct mmc_ios ios = host->mmc->ios;\n\tstruct sdmmc_dlyb *dlyb = host->variant_priv;\n\n\t \n\tpwr = host->pwr_reg_add;\n\n\tif (dlyb && dlyb->ops->set_input_ck)\n\t\tdlyb->ops->set_input_ck(dlyb);\n\n\tif (ios.power_mode == MMC_POWER_OFF) {\n\t\t \n\t\treset_control_assert(host->rst);\n\t\tudelay(2);\n\t\treset_control_deassert(host->rst);\n\n\t\t \n\t\tmmci_write_pwrreg(host, MCI_STM32_PWR_CYC | pwr);\n\t} else if (ios.power_mode == MMC_POWER_ON) {\n\t\t \n\t\twritel(MCI_IRQENABLE | host->variant->start_err,\n\t\t       host->base + MMCIMASK0);\n\n\t\t \n\t\tpwr |= host->pwr_reg & (MCI_STM32_VSWITCHEN |\n\t\t\t\t\tMCI_STM32_VSWITCH);\n\n\t\t \n\t\tmmci_write_pwrreg(host, MCI_PWR_OFF | pwr);\n\t\tmdelay(1);\n\t\tmmci_write_pwrreg(host, MCI_PWR_ON | pwr);\n\t}\n}\n\nstatic u32 sdmmc_get_dctrl_cfg(struct mmci_host *host)\n{\n\tu32 datactrl;\n\n\tdatactrl = mmci_dctrl_blksz(host);\n\n\tif (host->hw_revision >= 3) {\n\t\tu32 thr = 0;\n\n\t\tif (host->mmc->ios.timing == MMC_TIMING_UHS_SDR104 ||\n\t\t    host->mmc->ios.timing == MMC_TIMING_MMC_HS200) {\n\t\t\tthr = ffs(min_t(unsigned int, host->data->blksz,\n\t\t\t\t\thost->variant->fifosize));\n\t\t\tthr = min_t(u32, thr, MMCI_STM32_THR_MASK);\n\t\t}\n\n\t\twritel_relaxed(thr, host->base + MMCI_STM32_FIFOTHRR);\n\t}\n\n\tif (host->mmc->card && mmc_card_sdio(host->mmc->card) &&\n\t    host->data->blocks == 1)\n\t\tdatactrl |= MCI_DPSM_STM32_MODE_SDIO;\n\telse if (host->data->stop && !host->mrq->sbc)\n\t\tdatactrl |= MCI_DPSM_STM32_MODE_BLOCK_STOP;\n\telse\n\t\tdatactrl |= MCI_DPSM_STM32_MODE_BLOCK;\n\n\treturn datactrl;\n}\n\nstatic bool sdmmc_busy_complete(struct mmci_host *host, struct mmc_command *cmd,\n\t\t\t\tu32 status, u32 err_msk)\n{\n\tvoid __iomem *base = host->base;\n\tu32 busy_d0, busy_d0end, mask, sdmmc_status;\n\n\tmask = readl_relaxed(base + MMCIMASK0);\n\tsdmmc_status = readl_relaxed(base + MMCISTATUS);\n\tbusy_d0end = sdmmc_status & MCI_STM32_BUSYD0END;\n\tbusy_d0 = sdmmc_status & MCI_STM32_BUSYD0;\n\n\t \n\tif ((status & err_msk) || busy_d0end)\n\t\tgoto complete;\n\n\t \n\tif (busy_d0) {\n\t\tif (!host->busy_status) {\n\t\t\twritel_relaxed(mask | host->variant->busy_detect_mask,\n\t\t\t\t       base + MMCIMASK0);\n\t\t\thost->busy_status = status &\n\t\t\t\t(MCI_CMDSENT | MCI_CMDRESPEND);\n\t\t}\n\t\treturn false;\n\t}\n\ncomplete:\n\tif (host->busy_status) {\n\t\twritel_relaxed(mask & ~host->variant->busy_detect_mask,\n\t\t\t       base + MMCIMASK0);\n\t\thost->busy_status = 0;\n\t}\n\n\twritel_relaxed(host->variant->busy_detect_mask, base + MMCICLEAR);\n\n\treturn true;\n}\n\nstatic int sdmmc_dlyb_mp15_enable(struct sdmmc_dlyb *dlyb)\n{\n\twritel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);\n\n\treturn 0;\n}\n\nstatic int sdmmc_dlyb_mp15_set_cfg(struct sdmmc_dlyb *dlyb,\n\t\t\t\t   int unit, int phase, bool sampler)\n{\n\tu32 cfgr;\n\n\twritel_relaxed(DLYB_CR_SEN | DLYB_CR_DEN, dlyb->base + DLYB_CR);\n\n\tcfgr = FIELD_PREP(DLYB_CFGR_UNIT_MASK, unit) |\n\t       FIELD_PREP(DLYB_CFGR_SEL_MASK, phase);\n\twritel_relaxed(cfgr, dlyb->base + DLYB_CFGR);\n\n\tif (!sampler)\n\t\twritel_relaxed(DLYB_CR_DEN, dlyb->base + DLYB_CR);\n\n\treturn 0;\n}\n\nstatic int sdmmc_dlyb_mp15_prepare(struct mmci_host *host)\n{\n\tstruct sdmmc_dlyb *dlyb = host->variant_priv;\n\tu32 cfgr;\n\tint i, lng, ret;\n\n\tfor (i = 0; i <= DLYB_CFGR_UNIT_MAX; i++) {\n\t\tdlyb->ops->set_cfg(dlyb, i, DLYB_CFGR_SEL_MAX, true);\n\n\t\tret = readl_relaxed_poll_timeout(dlyb->base + DLYB_CFGR, cfgr,\n\t\t\t\t\t\t (cfgr & DLYB_CFGR_LNGF),\n\t\t\t\t\t\t 1, DLYB_LNG_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"delay line cfg timeout unit:%d cfgr:%d\\n\",\n\t\t\t\t i, cfgr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlng = FIELD_GET(DLYB_CFGR_LNG_MASK, cfgr);\n\t\tif (lng < BIT(DLYB_NB_DELAY) && lng > 0)\n\t\t\tbreak;\n\t}\n\n\tif (i > DLYB_CFGR_UNIT_MAX)\n\t\treturn -EINVAL;\n\n\tdlyb->unit = i;\n\tdlyb->max = __fls(lng);\n\n\treturn 0;\n}\n\nstatic int sdmmc_dlyb_mp25_enable(struct sdmmc_dlyb *dlyb)\n{\n\tu32 cr, sr;\n\n\tcr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);\n\tcr |= DLYBSD_CR_EN;\n\n\twritel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);\n\n\treturn readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,\n\t\t\t\t\t   sr, sr & DLYBSD_SR_LOCK, 1,\n\t\t\t\t\t   DLYBSD_TIMEOUT_1S_IN_US);\n}\n\nstatic int sdmmc_dlyb_mp25_set_cfg(struct sdmmc_dlyb *dlyb,\n\t\t\t\t   int unit __maybe_unused, int phase,\n\t\t\t\t   bool sampler __maybe_unused)\n{\n\tu32 cr, sr;\n\n\tcr = readl_relaxed(dlyb->base + SYSCFG_DLYBSD_CR);\n\tcr &= ~DLYBSD_CR_RXTAPSEL_MASK;\n\tcr |= FIELD_PREP(DLYBSD_CR_RXTAPSEL_MASK, phase);\n\n\twritel_relaxed(cr, dlyb->base + SYSCFG_DLYBSD_CR);\n\n\treturn readl_relaxed_poll_timeout(dlyb->base + SYSCFG_DLYBSD_SR,\n\t\t\t\t\t  sr, sr & DLYBSD_SR_RXTAPSEL_ACK, 1,\n\t\t\t\t\t  DLYBSD_TIMEOUT_1S_IN_US);\n}\n\nstatic int sdmmc_dlyb_mp25_prepare(struct mmci_host *host)\n{\n\tstruct sdmmc_dlyb *dlyb = host->variant_priv;\n\n\tdlyb->max = DLYBSD_TAPSEL_NB;\n\n\treturn 0;\n}\n\nstatic int sdmmc_dlyb_phase_tuning(struct mmci_host *host, u32 opcode)\n{\n\tstruct sdmmc_dlyb *dlyb = host->variant_priv;\n\tint cur_len = 0, max_len = 0, end_of_len = 0;\n\tint phase, ret;\n\n\tfor (phase = 0; phase <= dlyb->max; phase++) {\n\t\tret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"tuning config failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (mmc_send_tuning(host->mmc, opcode, NULL)) {\n\t\t\tcur_len = 0;\n\t\t} else {\n\t\t\tcur_len++;\n\t\t\tif (cur_len > max_len) {\n\t\t\t\tmax_len = cur_len;\n\t\t\t\tend_of_len = phase;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!max_len) {\n\t\tdev_err(mmc_dev(host->mmc), \"no tuning point found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (dlyb->ops->set_input_ck)\n\t\tdlyb->ops->set_input_ck(dlyb);\n\n\tphase = end_of_len - max_len / 2;\n\tret = dlyb->ops->set_cfg(dlyb, dlyb->unit, phase, false);\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"tuning reconfig failed\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_dbg(mmc_dev(host->mmc), \"unit:%d max_dly:%d phase:%d\\n\",\n\t\tdlyb->unit, dlyb->max, phase);\n\n\treturn 0;\n}\n\nstatic int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct mmci_host *host = mmc_priv(mmc);\n\tstruct sdmmc_dlyb *dlyb = host->variant_priv;\n\tu32 clk;\n\tint ret;\n\n\tif ((host->mmc->ios.timing != MMC_TIMING_UHS_SDR104 &&\n\t     host->mmc->ios.timing != MMC_TIMING_MMC_HS200) ||\n\t    host->mmc->actual_clock <= 50000000)\n\t\treturn 0;\n\n\tif (!dlyb || !dlyb->base)\n\t\treturn -EINVAL;\n\n\tret = dlyb->ops->dlyb_enable(dlyb);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk = host->clk_reg;\n\tclk &= ~MCI_STM32_CLK_SEL_MSK;\n\tclk |= MCI_STM32_CLK_SELFBCK;\n\tmmci_write_clkreg(host, clk);\n\n\tret = dlyb->ops->tuning_prepare(host);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdmmc_dlyb_phase_tuning(host, opcode);\n}\n\nstatic void sdmmc_pre_sig_volt_vswitch(struct mmci_host *host)\n{\n\t \n\twritel_relaxed(MCI_STM32_VSWENDC, host->base + MMCICLEAR);\n\t \n\tmmci_write_pwrreg(host, host->pwr_reg | MCI_STM32_VSWITCHEN);\n}\n\nstatic int sdmmc_post_sig_volt_switch(struct mmci_host *host,\n\t\t\t\t      struct mmc_ios *ios)\n{\n\tunsigned long flags;\n\tu32 status;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180 &&\n\t    host->pwr_reg & MCI_STM32_VSWITCHEN) {\n\t\tmmci_write_pwrreg(host, host->pwr_reg | MCI_STM32_VSWITCH);\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\t \n\t\tret = readl_relaxed_poll_timeout(host->base + MMCISTATUS,\n\t\t\t\t\t\t status,\n\t\t\t\t\t\t (status & MCI_STM32_VSWEND),\n\t\t\t\t\t\t 10, SDMMC_VSWEND_TIMEOUT_US);\n\n\t\twritel_relaxed(MCI_STM32_VSWENDC | MCI_STM32_CKSTOPC,\n\t\t\t       host->base + MMCICLEAR);\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t\tmmci_write_pwrreg(host, host->pwr_reg &\n\t\t\t\t  ~(MCI_STM32_VSWITCHEN | MCI_STM32_VSWITCH));\n\t}\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn ret;\n}\n\nstatic struct mmci_host_ops sdmmc_variant_ops = {\n\t.validate_data = sdmmc_idma_validate_data,\n\t.prep_data = sdmmc_idma_prep_data,\n\t.unprep_data = sdmmc_idma_unprep_data,\n\t.get_datactrl_cfg = sdmmc_get_dctrl_cfg,\n\t.dma_setup = sdmmc_idma_setup,\n\t.dma_start = sdmmc_idma_start,\n\t.dma_finalize = sdmmc_idma_finalize,\n\t.set_clkreg = mmci_sdmmc_set_clkreg,\n\t.set_pwrreg = mmci_sdmmc_set_pwrreg,\n\t.busy_complete = sdmmc_busy_complete,\n\t.pre_sig_volt_switch = sdmmc_pre_sig_volt_vswitch,\n\t.post_sig_volt_switch = sdmmc_post_sig_volt_switch,\n};\n\nstatic struct sdmmc_tuning_ops dlyb_tuning_mp15_ops = {\n\t.dlyb_enable = sdmmc_dlyb_mp15_enable,\n\t.set_input_ck = sdmmc_dlyb_mp15_input_ck,\n\t.tuning_prepare = sdmmc_dlyb_mp15_prepare,\n\t.set_cfg = sdmmc_dlyb_mp15_set_cfg,\n};\n\nstatic struct sdmmc_tuning_ops dlyb_tuning_mp25_ops = {\n\t.dlyb_enable = sdmmc_dlyb_mp25_enable,\n\t.tuning_prepare = sdmmc_dlyb_mp25_prepare,\n\t.set_cfg = sdmmc_dlyb_mp25_set_cfg,\n};\n\nvoid sdmmc_variant_init(struct mmci_host *host)\n{\n\tstruct device_node *np = host->mmc->parent->of_node;\n\tvoid __iomem *base_dlyb;\n\tstruct sdmmc_dlyb *dlyb;\n\n\thost->ops = &sdmmc_variant_ops;\n\thost->pwr_reg = readl_relaxed(host->base + MMCIPOWER);\n\n\tbase_dlyb = devm_of_iomap(mmc_dev(host->mmc), np, 1, NULL);\n\tif (IS_ERR(base_dlyb))\n\t\treturn;\n\n\tdlyb = devm_kzalloc(mmc_dev(host->mmc), sizeof(*dlyb), GFP_KERNEL);\n\tif (!dlyb)\n\t\treturn;\n\n\tdlyb->base = base_dlyb;\n\tif (of_device_is_compatible(np, \"st,stm32mp25-sdmmc2\"))\n\t\tdlyb->ops = &dlyb_tuning_mp25_ops;\n\telse\n\t\tdlyb->ops = &dlyb_tuning_mp15_ops;\n\n\thost->variant_priv = dlyb;\n\thost->mmc_ops->execute_tuning = sdmmc_execute_tuning;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}