{
  "module_name": "pxamci.c",
  "hash_id": "87a9c6e24c21d7c8b1e63ddd62e160254a7d47d42ee4ab74508f0b92f44a78bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/pxamci.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/io.h>\n#include <linux/regulator/consumer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gfp.h>\n#include <linux/of.h>\n#include <linux/soc/pxa/cpu.h>\n\n#include <linux/sizes.h>\n\n#include <linux/platform_data/mmc-pxamci.h>\n\n#include \"pxamci.h\"\n\n#define DRIVER_NAME\t\"pxa2xx-mci\"\n\n#define NR_SG\t1\n#define CLKRT_OFF\t(~0)\n\n#define mmc_has_26MHz()\t\t(cpu_is_pxa300() || cpu_is_pxa310() \\\n\t\t\t\t|| cpu_is_pxa935())\n\nstruct pxamci_host {\n\tstruct mmc_host\t\t*mmc;\n\tspinlock_t\t\tlock;\n\tstruct resource\t\t*res;\n\tvoid __iomem\t\t*base;\n\tstruct clk\t\t*clk;\n\tunsigned long\t\tclkrate;\n\tunsigned int\t\tclkrt;\n\tunsigned int\t\tcmdat;\n\tunsigned int\t\timask;\n\tunsigned int\t\tpower_mode;\n\tunsigned long\t\tdetect_delay_ms;\n\tbool\t\t\tuse_ro_gpio;\n\tstruct gpio_desc\t*power;\n\tstruct pxamci_platform_data *pdata;\n\n\tstruct mmc_request\t*mrq;\n\tstruct mmc_command\t*cmd;\n\tstruct mmc_data\t\t*data;\n\n\tstruct dma_chan\t\t*dma_chan_rx;\n\tstruct dma_chan\t\t*dma_chan_tx;\n\tdma_cookie_t\t\tdma_cookie;\n\tunsigned int\t\tdma_len;\n\tunsigned int\t\tdma_dir;\n};\n\nstatic int pxamci_init_ocr(struct pxamci_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret;\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (IS_ERR(mmc->supply.vmmc)) {\n\t\t \n\t\tmmc->ocr_avail = host->pdata ?\n\t\t\thost->pdata->ocr_mask :\n\t\t\tMMC_VDD_32_33 | MMC_VDD_33_34;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int pxamci_set_power(struct pxamci_host *host,\n\t\t\t\t    unsigned char power_mode,\n\t\t\t\t    unsigned int vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct regulator *supply = mmc->supply.vmmc;\n\n\tif (!IS_ERR(supply))\n\t\treturn mmc_regulator_set_ocr(mmc, supply, vdd);\n\n\tif (host->power) {\n\t\tbool on = !!((1 << vdd) & host->pdata->ocr_mask);\n\t\tgpiod_set_value(host->power, on);\n\t}\n\n\tif (host->pdata && host->pdata->setpower)\n\t\treturn host->pdata->setpower(mmc_dev(host->mmc), vdd);\n\n\treturn 0;\n}\n\nstatic void pxamci_stop_clock(struct pxamci_host *host)\n{\n\tif (readl(host->base + MMC_STAT) & STAT_CLK_EN) {\n\t\tunsigned long timeout = 10000;\n\t\tunsigned int v;\n\n\t\twritel(STOP_CLOCK, host->base + MMC_STRPCL);\n\n\t\tdo {\n\t\t\tv = readl(host->base + MMC_STAT);\n\t\t\tif (!(v & STAT_CLK_EN))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t} while (timeout--);\n\n\t\tif (v & STAT_CLK_EN)\n\t\t\tdev_err(mmc_dev(host->mmc), \"unable to stop clock\\n\");\n\t}\n}\n\nstatic void pxamci_enable_irq(struct pxamci_host *host, unsigned int mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\thost->imask &= ~mask;\n\twritel(host->imask, host->base + MMC_I_MASK);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void pxamci_disable_irq(struct pxamci_host *host, unsigned int mask)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\thost->imask |= mask;\n\twritel(host->imask, host->base + MMC_I_MASK);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void pxamci_dma_irq(void *param);\n\nstatic void pxamci_setup_data(struct pxamci_host *host, struct mmc_data *data)\n{\n\tstruct dma_async_tx_descriptor *tx;\n\tenum dma_transfer_direction direction;\n\tstruct dma_slave_config\tconfig;\n\tstruct dma_chan *chan;\n\tunsigned int nob = data->blocks;\n\tunsigned long long clks;\n\tunsigned int timeout;\n\tint ret;\n\n\thost->data = data;\n\n\twritel(nob, host->base + MMC_NOB);\n\twritel(data->blksz, host->base + MMC_BLKLEN);\n\n\tclks = (unsigned long long)data->timeout_ns * host->clkrate;\n\tdo_div(clks, 1000000000UL);\n\ttimeout = (unsigned int)clks + (data->timeout_clks << host->clkrt);\n\twritel((timeout + 255) / 256, host->base + MMC_RDTO);\n\n\tmemset(&config, 0, sizeof(config));\n\tconfig.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tconfig.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;\n\tconfig.src_addr = host->res->start + MMC_RXFIFO;\n\tconfig.dst_addr = host->res->start + MMC_TXFIFO;\n\tconfig.src_maxburst = 32;\n\tconfig.dst_maxburst = 32;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\thost->dma_dir = DMA_FROM_DEVICE;\n\t\tdirection = DMA_DEV_TO_MEM;\n\t\tchan = host->dma_chan_rx;\n\t} else {\n\t\thost->dma_dir = DMA_TO_DEVICE;\n\t\tdirection = DMA_MEM_TO_DEV;\n\t\tchan = host->dma_chan_tx;\n\t}\n\n\tconfig.direction = direction;\n\n\tret = dmaengine_slave_config(chan, &config);\n\tif (ret < 0) {\n\t\tdev_err(mmc_dev(host->mmc), \"dma slave config failed\\n\");\n\t\treturn;\n\t}\n\n\thost->dma_len = dma_map_sg(chan->device->dev, data->sg, data->sg_len,\n\t\t\t\t   host->dma_dir);\n\n\ttx = dmaengine_prep_slave_sg(chan, data->sg, host->dma_len, direction,\n\t\t\t\t     DMA_PREP_INTERRUPT);\n\tif (!tx) {\n\t\tdev_err(mmc_dev(host->mmc), \"prep_slave_sg() failed\\n\");\n\t\treturn;\n\t}\n\n\tif (!(data->flags & MMC_DATA_READ)) {\n\t\ttx->callback = pxamci_dma_irq;\n\t\ttx->callback_param = host;\n\t}\n\n\thost->dma_cookie = dmaengine_submit(tx);\n\n\t \n\tif (!cpu_is_pxa27x() || data->flags & MMC_DATA_READ)\n\t\tdma_async_issue_pending(chan);\n}\n\nstatic void pxamci_start_cmd(struct pxamci_host *host, struct mmc_command *cmd, unsigned int cmdat)\n{\n\tWARN_ON(host->cmd != NULL);\n\thost->cmd = cmd;\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tcmdat |= CMDAT_BUSY;\n\n#define RSP_TYPE(x)\t((x) & ~(MMC_RSP_BUSY|MMC_RSP_OPCODE))\n\tswitch (RSP_TYPE(mmc_resp_type(cmd))) {\n\tcase RSP_TYPE(MMC_RSP_R1):  \n\t\tcmdat |= CMDAT_RESP_SHORT;\n\t\tbreak;\n\tcase RSP_TYPE(MMC_RSP_R3):\n\t\tcmdat |= CMDAT_RESP_R3;\n\t\tbreak;\n\tcase RSP_TYPE(MMC_RSP_R2):\n\t\tcmdat |= CMDAT_RESP_R2;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\twritel(cmd->opcode, host->base + MMC_CMD);\n\twritel(cmd->arg >> 16, host->base + MMC_ARGH);\n\twritel(cmd->arg & 0xffff, host->base + MMC_ARGL);\n\twritel(cmdat, host->base + MMC_CMDAT);\n\twritel(host->clkrt, host->base + MMC_CLKRT);\n\n\twritel(START_CLOCK, host->base + MMC_STRPCL);\n\n\tpxamci_enable_irq(host, END_CMD_RES);\n}\n\nstatic void pxamci_finish_request(struct pxamci_host *host, struct mmc_request *mrq)\n{\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic int pxamci_cmd_done(struct pxamci_host *host, unsigned int stat)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tint i;\n\tu32 v;\n\n\tif (!cmd)\n\t\treturn 0;\n\n\thost->cmd = NULL;\n\n\t \n\tv = readl(host->base + MMC_RES) & 0xffff;\n\tfor (i = 0; i < 4; i++) {\n\t\tu32 w1 = readl(host->base + MMC_RES) & 0xffff;\n\t\tu32 w2 = readl(host->base + MMC_RES) & 0xffff;\n\t\tcmd->resp[i] = v << 24 | w1 << 8 | w2 >> 8;\n\t\tv = w2;\n\t}\n\n\tif (stat & STAT_TIME_OUT_RESPONSE) {\n\t\tcmd->error = -ETIMEDOUT;\n\t} else if (stat & STAT_RES_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\n\t\t \n\t\tif (cpu_is_pxa27x() &&\n\t\t    (cmd->flags & MMC_RSP_136 && cmd->resp[0] & 0x80000000))\n\t\t\tpr_debug(\"ignoring CRC from command %d - *risky*\\n\", cmd->opcode);\n\t\telse\n\t\t\tcmd->error = -EILSEQ;\n\t}\n\n\tpxamci_disable_irq(host, END_CMD_RES);\n\tif (host->data && !cmd->error) {\n\t\tpxamci_enable_irq(host, DATA_TRAN_DONE);\n\t\t \n\t\tif (cpu_is_pxa27x() && host->data->flags & MMC_DATA_WRITE)\n\t\t\tdma_async_issue_pending(host->dma_chan_tx);\n\t} else {\n\t\tpxamci_finish_request(host, host->mrq);\n\t}\n\n\treturn 1;\n}\n\nstatic int pxamci_data_done(struct pxamci_host *host, unsigned int stat)\n{\n\tstruct mmc_data *data = host->data;\n\tstruct dma_chan *chan;\n\n\tif (!data)\n\t\treturn 0;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tchan = host->dma_chan_rx;\n\telse\n\t\tchan = host->dma_chan_tx;\n\tdma_unmap_sg(chan->device->dev,\n\t\t     data->sg, data->sg_len, host->dma_dir);\n\n\tif (stat & STAT_READ_TIME_OUT)\n\t\tdata->error = -ETIMEDOUT;\n\telse if (stat & (STAT_CRC_READ_ERROR|STAT_CRC_WRITE_ERROR))\n\t\tdata->error = -EILSEQ;\n\n\t \n\tif (!data->error)\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\telse\n\t\tdata->bytes_xfered = 0;\n\n\tpxamci_disable_irq(host, DATA_TRAN_DONE);\n\n\thost->data = NULL;\n\tif (host->mrq->stop) {\n\t\tpxamci_stop_clock(host);\n\t\tpxamci_start_cmd(host, host->mrq->stop, host->cmdat);\n\t} else {\n\t\tpxamci_finish_request(host, host->mrq);\n\t}\n\n\treturn 1;\n}\n\nstatic irqreturn_t pxamci_irq(int irq, void *devid)\n{\n\tstruct pxamci_host *host = devid;\n\tunsigned int ireg;\n\tint handled = 0;\n\n\tireg = readl(host->base + MMC_I_REG) & ~readl(host->base + MMC_I_MASK);\n\n\tif (ireg) {\n\t\tunsigned stat = readl(host->base + MMC_STAT);\n\n\t\tpr_debug(\"PXAMCI: irq %08x stat %08x\\n\", ireg, stat);\n\n\t\tif (ireg & END_CMD_RES)\n\t\t\thandled |= pxamci_cmd_done(host, stat);\n\t\tif (ireg & DATA_TRAN_DONE)\n\t\t\thandled |= pxamci_data_done(host, stat);\n\t\tif (ireg & SDIO_INT) {\n\t\t\tmmc_signal_sdio_irq(host->mmc);\n\t\t\thandled = 1;\n\t\t}\n\t}\n\n\treturn IRQ_RETVAL(handled);\n}\n\nstatic void pxamci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct pxamci_host *host = mmc_priv(mmc);\n\tunsigned int cmdat;\n\n\tWARN_ON(host->mrq != NULL);\n\n\thost->mrq = mrq;\n\n\tpxamci_stop_clock(host);\n\n\tcmdat = host->cmdat;\n\thost->cmdat &= ~CMDAT_INIT;\n\n\tif (mrq->data) {\n\t\tpxamci_setup_data(host, mrq->data);\n\n\t\tcmdat &= ~CMDAT_BUSY;\n\t\tcmdat |= CMDAT_DATAEN | CMDAT_DMAEN;\n\t\tif (mrq->data->flags & MMC_DATA_WRITE)\n\t\t\tcmdat |= CMDAT_WRITE;\n\t}\n\n\tpxamci_start_cmd(host, mrq->cmd, cmdat);\n}\n\nstatic int pxamci_get_ro(struct mmc_host *mmc)\n{\n\tstruct pxamci_host *host = mmc_priv(mmc);\n\n\tif (host->use_ro_gpio)\n\t\treturn mmc_gpio_get_ro(mmc);\n\tif (host->pdata && host->pdata->get_ro)\n\t\treturn !!host->pdata->get_ro(mmc_dev(mmc));\n\t \n\treturn -ENOSYS;\n}\n\nstatic void pxamci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct pxamci_host *host = mmc_priv(mmc);\n\n\tif (ios->clock) {\n\t\tunsigned long rate = host->clkrate;\n\t\tunsigned int clk = rate / ios->clock;\n\n\t\tif (host->clkrt == CLKRT_OFF)\n\t\t\tclk_prepare_enable(host->clk);\n\n\t\tif (ios->clock == 26000000) {\n\t\t\t \n\t\t\thost->clkrt = 7;\n\t\t} else {\n\t\t\t \n\t\t\tif (!clk)\n\t\t\t\tclk = 1;\n\n\t\t\t \n\t\t\tif (rate / clk > ios->clock)\n\t\t\t\tclk <<= 1;\n\t\t\thost->clkrt = fls(clk) - 1;\n\t\t}\n\n\t\t \n\t} else {\n\t\tpxamci_stop_clock(host);\n\t\tif (host->clkrt != CLKRT_OFF) {\n\t\t\thost->clkrt = CLKRT_OFF;\n\t\t\tclk_disable_unprepare(host->clk);\n\t\t}\n\t}\n\n\tif (host->power_mode != ios->power_mode) {\n\t\tint ret;\n\n\t\thost->power_mode = ios->power_mode;\n\n\t\tret = pxamci_set_power(host, ios->power_mode, ios->vdd);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(mmc), \"unable to set power\\n\");\n\t\t\t \n\t\t\treturn;\n\t\t}\n\n\t\tif (ios->power_mode == MMC_POWER_ON)\n\t\t\thost->cmdat |= CMDAT_INIT;\n\t}\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\thost->cmdat |= CMDAT_SD_4DAT;\n\telse\n\t\thost->cmdat &= ~CMDAT_SD_4DAT;\n\n\tdev_dbg(mmc_dev(mmc), \"PXAMCI: clkrt = %x cmdat = %x\\n\",\n\t\thost->clkrt, host->cmdat);\n}\n\nstatic void pxamci_enable_sdio_irq(struct mmc_host *host, int enable)\n{\n\tstruct pxamci_host *pxa_host = mmc_priv(host);\n\n\tif (enable)\n\t\tpxamci_enable_irq(pxa_host, SDIO_INT);\n\telse\n\t\tpxamci_disable_irq(pxa_host, SDIO_INT);\n}\n\nstatic const struct mmc_host_ops pxamci_ops = {\n\t.request\t\t= pxamci_request,\n\t.get_cd\t\t\t= mmc_gpio_get_cd,\n\t.get_ro\t\t\t= pxamci_get_ro,\n\t.set_ios\t\t= pxamci_set_ios,\n\t.enable_sdio_irq\t= pxamci_enable_sdio_irq,\n};\n\nstatic void pxamci_dma_irq(void *param)\n{\n\tstruct pxamci_host *host = param;\n\tstruct dma_tx_state state;\n\tenum dma_status status;\n\tstruct dma_chan *chan;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (!host->data)\n\t\tgoto out_unlock;\n\n\tif (host->data->flags & MMC_DATA_READ)\n\t\tchan = host->dma_chan_rx;\n\telse\n\t\tchan = host->dma_chan_tx;\n\n\tstatus = dmaengine_tx_status(chan, host->dma_cookie, &state);\n\n\tif (likely(status == DMA_COMPLETE)) {\n\t\twritel(BUF_PART_FULL, host->base + MMC_PRTBUF);\n\t} else {\n\t\tpr_err(\"%s: DMA error on %s channel\\n\", mmc_hostname(host->mmc),\n\t\t\thost->data->flags & MMC_DATA_READ ? \"rx\" : \"tx\");\n\t\thost->data->error = -EIO;\n\t\tpxamci_data_done(host, 0);\n\t}\n\nout_unlock:\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic irqreturn_t pxamci_detect_irq(int irq, void *devid)\n{\n\tstruct pxamci_host *host = mmc_priv(devid);\n\n\tmmc_detect_change(devid, msecs_to_jiffies(host->detect_delay_ms));\n\treturn IRQ_HANDLED;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_mmc_dt_ids[] = {\n        { .compatible = \"marvell,pxa-mmc\" },\n        { }\n};\n\nMODULE_DEVICE_TABLE(of, pxa_mmc_dt_ids);\n\nstatic int pxamci_of_init(struct platform_device *pdev,\n\t\t\t  struct mmc_host *mmc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pxamci_host *host = mmc_priv(mmc);\n\tu32 tmp;\n\tint ret;\n\n\tif (!np)\n\t\treturn 0;\n\n\t \n\tif (of_property_read_u32(np, \"pxa-mmc,detect-delay-ms\", &tmp) == 0)\n\t\thost->detect_delay_ms = tmp;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n#else\nstatic int pxamci_of_init(struct platform_device *pdev,\n\t\t\t  struct mmc_host *mmc)\n{\n        return 0;\n}\n#endif\n\nstatic int pxamci_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct pxamci_host *host = NULL;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *r;\n\tint ret, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmmc = mmc_alloc_host(sizeof(struct pxamci_host), dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmmc->ops = &pxamci_ops;\n\n\t \n\tmmc->max_segs = NR_SG;\n\n\t \n\tmmc->max_seg_size = PAGE_SIZE;\n\n\t \n\tmmc->max_blk_size = cpu_is_pxa25x() ? 1023 : 2048;\n\n\t \n\tmmc->max_blk_count = 65535;\n\n\tret = pxamci_of_init(pdev, mmc);\n\tif (ret)\n\t\tgoto out;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->pdata = pdev->dev.platform_data;\n\thost->clkrt = CLKRT_OFF;\n\n\thost->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\thost->clk = NULL;\n\t\tgoto out;\n\t}\n\n\thost->clkrate = clk_get_rate(host->clk);\n\n\t \n\tmmc->f_min = (host->clkrate + 63) / 64;\n\tmmc->f_max = (mmc_has_26MHz()) ? 26000000 : host->clkrate;\n\n\tret = pxamci_init_ocr(host);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmmc->caps = 0;\n\thost->cmdat = 0;\n\tif (!cpu_is_pxa25x()) {\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\n\t\thost->cmdat |= CMDAT_SDIO_INT_EN;\n\t\tif (mmc_has_26MHz())\n\t\t\tmmc->caps |= MMC_CAP_MMC_HIGHSPEED |\n\t\t\t\t     MMC_CAP_SD_HIGHSPEED;\n\t}\n\n\tspin_lock_init(&host->lock);\n\thost->imask = MMC_I_MASK_ALL;\n\n\thost->base = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto out;\n\t}\n\thost->res = r;\n\n\t \n\tpxamci_stop_clock(host);\n\twritel(0, host->base + MMC_SPI);\n\twritel(64, host->base + MMC_RESTO);\n\twritel(host->imask, host->base + MMC_I_MASK);\n\n\tret = devm_request_irq(dev, irq, pxamci_irq, 0,\n\t\t\t       DRIVER_NAME, host);\n\tif (ret)\n\t\tgoto out;\n\n\tplatform_set_drvdata(pdev, mmc);\n\n\thost->dma_chan_rx = dma_request_chan(dev, \"rx\");\n\tif (IS_ERR(host->dma_chan_rx)) {\n\t\tdev_err(dev, \"unable to request rx dma channel\\n\");\n\t\tret = PTR_ERR(host->dma_chan_rx);\n\t\thost->dma_chan_rx = NULL;\n\t\tgoto out;\n\t}\n\n\thost->dma_chan_tx = dma_request_chan(dev, \"tx\");\n\tif (IS_ERR(host->dma_chan_tx)) {\n\t\tdev_err(dev, \"unable to request tx dma channel\\n\");\n\t\tret = PTR_ERR(host->dma_chan_tx);\n\t\thost->dma_chan_tx = NULL;\n\t\tgoto out;\n\t}\n\n\tif (host->pdata) {\n\t\thost->detect_delay_ms = host->pdata->detect_delay_ms;\n\n\t\thost->power = devm_gpiod_get_optional(dev, \"power\", GPIOD_OUT_LOW);\n\t\tif (IS_ERR(host->power)) {\n\t\t\tret = PTR_ERR(host->power);\n\t\t\tdev_err(dev, \"Failed requesting gpio_power\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\t \n\t\tret = mmc_gpiod_request_cd(mmc, \"cd\", 0, false, 0);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tdev_err(dev, \"Failed requesting gpio_cd\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!host->pdata->gpio_card_ro_invert)\n\t\t\tmmc->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;\n\n\t\tret = mmc_gpiod_request_ro(mmc, \"wp\", 0, 0);\n\t\tif (ret && ret != -ENOENT) {\n\t\t\tdev_err(dev, \"Failed requesting gpio_ro\\n\");\n\t\t\tgoto out;\n\t\t}\n\t\tif (!ret)\n\t\t\thost->use_ro_gpio = true;\n\n\t\tif (host->pdata->init)\n\t\t\thost->pdata->init(dev, pxamci_detect_irq, mmc);\n\n\t\tif (host->power && host->pdata->setpower)\n\t\t\tdev_warn(dev, \"gpio_power and setpower() both defined\\n\");\n\t\tif (host->use_ro_gpio && host->pdata->get_ro)\n\t\t\tdev_warn(dev, \"gpio_ro and get_ro() both defined\\n\");\n\t}\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tif (host->pdata && host->pdata->exit)\n\t\t\thost->pdata->exit(dev, mmc);\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tif (host) {\n\t\tif (host->dma_chan_rx)\n\t\t\tdma_release_channel(host->dma_chan_rx);\n\t\tif (host->dma_chan_tx)\n\t\t\tdma_release_channel(host->dma_chan_tx);\n\t}\n\tif (mmc)\n\t\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void pxamci_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(pdev);\n\n\tif (mmc) {\n\t\tstruct pxamci_host *host = mmc_priv(mmc);\n\n\t\tmmc_remove_host(mmc);\n\n\t\tif (host->pdata && host->pdata->exit)\n\t\t\thost->pdata->exit(&pdev->dev, mmc);\n\n\t\tpxamci_stop_clock(host);\n\t\twritel(TXFIFO_WR_REQ|RXFIFO_RD_REQ|CLK_IS_OFF|STOP_CMD|\n\t\t       END_CMD_RES|PRG_DONE|DATA_TRAN_DONE,\n\t\t       host->base + MMC_I_MASK);\n\n\t\tdmaengine_terminate_all(host->dma_chan_rx);\n\t\tdmaengine_terminate_all(host->dma_chan_tx);\n\t\tdma_release_channel(host->dma_chan_rx);\n\t\tdma_release_channel(host->dma_chan_tx);\n\n\t\tmmc_free_host(mmc);\n\t}\n}\n\nstatic struct platform_driver pxamci_driver = {\n\t.probe\t\t= pxamci_probe,\n\t.remove_new\t= pxamci_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(pxa_mmc_dt_ids),\n\t},\n};\n\nmodule_platform_driver(pxamci_driver);\n\nMODULE_DESCRIPTION(\"PXA Multimedia Card Interface Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa2xx-mci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}