{
  "module_name": "owl-mmc.c",
  "hash_id": "1d29b8d2a176c2204c2f4285573c2b634ceefedf58384918bd7da47fa1d17efb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/owl-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-direction.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/spinlock.h>\n\n \n#define OWL_REG_SD_EN\t\t\t0x0000\n#define OWL_REG_SD_CTL\t\t\t0x0004\n#define OWL_REG_SD_STATE\t\t0x0008\n#define OWL_REG_SD_CMD\t\t\t0x000c\n#define OWL_REG_SD_ARG\t\t\t0x0010\n#define OWL_REG_SD_RSPBUF0\t\t0x0014\n#define OWL_REG_SD_RSPBUF1\t\t0x0018\n#define OWL_REG_SD_RSPBUF2\t\t0x001c\n#define OWL_REG_SD_RSPBUF3\t\t0x0020\n#define OWL_REG_SD_RSPBUF4\t\t0x0024\n#define OWL_REG_SD_DAT\t\t\t0x0028\n#define OWL_REG_SD_BLK_SIZE\t\t0x002c\n#define OWL_REG_SD_BLK_NUM\t\t0x0030\n#define OWL_REG_SD_BUF_SIZE\t\t0x0034\n\n \n#define OWL_SD_EN_RANE\t\t\tBIT(31)\n#define OWL_SD_EN_RAN_SEED(x)\t\t(((x) & 0x3f) << 24)\n#define OWL_SD_EN_S18EN\t\t\tBIT(12)\n#define OWL_SD_EN_RESE\t\t\tBIT(10)\n#define OWL_SD_EN_DAT1_S\t\tBIT(9)\n#define OWL_SD_EN_CLK_S\t\t\tBIT(8)\n#define OWL_SD_ENABLE\t\t\tBIT(7)\n#define OWL_SD_EN_BSEL\t\t\tBIT(6)\n#define OWL_SD_EN_SDIOEN\t\tBIT(3)\n#define OWL_SD_EN_DDREN\t\t\tBIT(2)\n#define OWL_SD_EN_DATAWID(x)\t\t(((x) & 0x3) << 0)\n\n \n#define OWL_SD_CTL_TOUTEN\t\tBIT(31)\n#define OWL_SD_CTL_TOUTCNT(x)\t\t(((x) & 0x7f) << 24)\n#define OWL_SD_CTL_DELAY_MSK\t\tGENMASK(23, 16)\n#define OWL_SD_CTL_RDELAY(x)\t\t(((x) & 0xf) << 20)\n#define OWL_SD_CTL_WDELAY(x)\t\t(((x) & 0xf) << 16)\n#define OWL_SD_CTL_CMDLEN\t\tBIT(13)\n#define OWL_SD_CTL_SCC\t\t\tBIT(12)\n#define OWL_SD_CTL_TCN(x)\t\t(((x) & 0xf) << 8)\n#define OWL_SD_CTL_TS\t\t\tBIT(7)\n#define OWL_SD_CTL_LBE\t\t\tBIT(6)\n#define OWL_SD_CTL_C7EN\t\t\tBIT(5)\n#define OWL_SD_CTL_TM(x)\t\t(((x) & 0xf) << 0)\n\n#define OWL_SD_DELAY_LOW_CLK\t\t0x0f\n#define OWL_SD_DELAY_MID_CLK\t\t0x0a\n#define OWL_SD_DELAY_HIGH_CLK\t\t0x09\n#define OWL_SD_RDELAY_DDR50\t\t0x0a\n#define OWL_SD_WDELAY_DDR50\t\t0x08\n\n \n#define OWL_SD_STATE_DAT1BS\t\tBIT(18)\n#define OWL_SD_STATE_SDIOB_P\t\tBIT(17)\n#define OWL_SD_STATE_SDIOB_EN\t\tBIT(16)\n#define OWL_SD_STATE_TOUTE\t\tBIT(15)\n#define OWL_SD_STATE_BAEP\t\tBIT(14)\n#define OWL_SD_STATE_MEMRDY\t\tBIT(12)\n#define OWL_SD_STATE_CMDS\t\tBIT(11)\n#define OWL_SD_STATE_DAT1AS\t\tBIT(10)\n#define OWL_SD_STATE_SDIOA_P\t\tBIT(9)\n#define OWL_SD_STATE_SDIOA_EN\t\tBIT(8)\n#define OWL_SD_STATE_DAT0S\t\tBIT(7)\n#define OWL_SD_STATE_TEIE\t\tBIT(6)\n#define OWL_SD_STATE_TEI\t\tBIT(5)\n#define OWL_SD_STATE_CLNR\t\tBIT(4)\n#define OWL_SD_STATE_CLC\t\tBIT(3)\n#define OWL_SD_STATE_WC16ER\t\tBIT(2)\n#define OWL_SD_STATE_RC16ER\t\tBIT(1)\n#define OWL_SD_STATE_CRC7ER\t\tBIT(0)\n\n#define OWL_CMD_TIMEOUT_MS\t\t30000\n\nstruct owl_mmc_host {\n\tstruct device *dev;\n\tstruct reset_control *reset;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct completion sdc_complete;\n\tspinlock_t lock;\n\tint irq;\n\tu32 clock;\n\tbool ddr_50;\n\n\tenum dma_data_direction dma_dir;\n\tstruct dma_chan *dma;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_slave_config dma_cfg;\n\tstruct completion dma_complete;\n\n\tstruct mmc_host\t*mmc;\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_data\t*data;\n};\n\nstatic void owl_mmc_update_reg(void __iomem *reg, unsigned int val, bool state)\n{\n\tunsigned int regval;\n\n\tregval = readl(reg);\n\n\tif (state)\n\t\tregval |= val;\n\telse\n\t\tregval &= ~val;\n\n\twritel(regval, reg);\n}\n\nstatic irqreturn_t owl_irq_handler(int irq, void *devid)\n{\n\tstruct owl_mmc_host *owl_host = devid;\n\tu32 state;\n\n\tspin_lock(&owl_host->lock);\n\n\tstate = readl(owl_host->base + OWL_REG_SD_STATE);\n\tif (state & OWL_SD_STATE_TEI) {\n\t\tstate = readl(owl_host->base + OWL_REG_SD_STATE);\n\t\tstate |= OWL_SD_STATE_TEI;\n\t\twritel(state, owl_host->base + OWL_REG_SD_STATE);\n\t\tcomplete(&owl_host->sdc_complete);\n\t}\n\n\tspin_unlock(&owl_host->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void owl_mmc_finish_request(struct owl_mmc_host *owl_host)\n{\n\tstruct mmc_request *mrq = owl_host->mrq;\n\tstruct mmc_data *data = mrq->data;\n\n\t \n\tWARN_ON(!mrq);\n\n\towl_host->mrq = NULL;\n\n\tif (data)\n\t\tdma_unmap_sg(owl_host->dma->device->dev, data->sg, data->sg_len,\n\t\t\t     owl_host->dma_dir);\n\n\t \n\tmmc_request_done(owl_host->mmc, mrq);\n}\n\nstatic void owl_mmc_send_cmd(struct owl_mmc_host *owl_host,\n\t\t\t     struct mmc_command *cmd,\n\t\t\t     struct mmc_data *data)\n{\n\tunsigned long timeout;\n\tu32 mode, state, resp[2];\n\tu32 cmd_rsp_mask = 0;\n\n\tinit_completion(&owl_host->sdc_complete);\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tmode = OWL_SD_CTL_TM(0);\n\t\tbreak;\n\n\tcase MMC_RSP_R1:\n\t\tif (data) {\n\t\t\tif (data->flags & MMC_DATA_READ)\n\t\t\t\tmode = OWL_SD_CTL_TM(4);\n\t\t\telse\n\t\t\t\tmode = OWL_SD_CTL_TM(5);\n\t\t} else {\n\t\t\tmode = OWL_SD_CTL_TM(1);\n\t\t}\n\t\tcmd_rsp_mask = OWL_SD_STATE_CLNR | OWL_SD_STATE_CRC7ER;\n\n\t\tbreak;\n\n\tcase MMC_RSP_R1B:\n\t\tmode = OWL_SD_CTL_TM(3);\n\t\tcmd_rsp_mask = OWL_SD_STATE_CLNR | OWL_SD_STATE_CRC7ER;\n\t\tbreak;\n\n\tcase MMC_RSP_R2:\n\t\tmode = OWL_SD_CTL_TM(2);\n\t\tcmd_rsp_mask = OWL_SD_STATE_CLNR | OWL_SD_STATE_CRC7ER;\n\t\tbreak;\n\n\tcase MMC_RSP_R3:\n\t\tmode = OWL_SD_CTL_TM(1);\n\t\tcmd_rsp_mask = OWL_SD_STATE_CLNR;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(owl_host->dev, \"Unknown MMC command\\n\");\n\t\tcmd->error = -EINVAL;\n\t\treturn;\n\t}\n\n\t \n\tmode |= (readl(owl_host->base + OWL_REG_SD_CTL) & (0xff << 16));\n\n\t \n\twritel(cmd->arg, owl_host->base + OWL_REG_SD_ARG);\n\twritel(cmd->opcode, owl_host->base + OWL_REG_SD_CMD);\n\n\t \n\tif (data) {\n\t\tmode |= (OWL_SD_CTL_TS | OWL_SD_CTL_LBE | 0x64000000);\n\t} else {\n\t\tmode &= ~(OWL_SD_CTL_TOUTEN | OWL_SD_CTL_LBE);\n\t\tmode |= OWL_SD_CTL_TS;\n\t}\n\n\towl_host->cmd = cmd;\n\n\t \n\twritel(mode, owl_host->base + OWL_REG_SD_CTL);\n\n\tif (data)\n\t\treturn;\n\n\ttimeout = msecs_to_jiffies(cmd->busy_timeout ? cmd->busy_timeout :\n\t\tOWL_CMD_TIMEOUT_MS);\n\n\tif (!wait_for_completion_timeout(&owl_host->sdc_complete, timeout)) {\n\t\tdev_err(owl_host->dev, \"CMD interrupt timeout\\n\");\n\t\tcmd->error = -ETIMEDOUT;\n\t\treturn;\n\t}\n\n\tstate = readl(owl_host->base + OWL_REG_SD_STATE);\n\tif (mmc_resp_type(cmd) & MMC_RSP_PRESENT) {\n\t\tif (cmd_rsp_mask & state) {\n\t\t\tif (state & OWL_SD_STATE_CLNR) {\n\t\t\t\tdev_err(owl_host->dev, \"Error CMD_NO_RSP\\n\");\n\t\t\t\tcmd->error = -EILSEQ;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (state & OWL_SD_STATE_CRC7ER) {\n\t\t\t\tdev_err(owl_host->dev, \"Error CMD_RSP_CRC\\n\");\n\t\t\t\tcmd->error = -EILSEQ;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (mmc_resp_type(cmd) & MMC_RSP_136) {\n\t\t\tcmd->resp[3] = readl(owl_host->base + OWL_REG_SD_RSPBUF0);\n\t\t\tcmd->resp[2] = readl(owl_host->base + OWL_REG_SD_RSPBUF1);\n\t\t\tcmd->resp[1] = readl(owl_host->base + OWL_REG_SD_RSPBUF2);\n\t\t\tcmd->resp[0] = readl(owl_host->base + OWL_REG_SD_RSPBUF3);\n\t\t} else {\n\t\t\tresp[0] = readl(owl_host->base + OWL_REG_SD_RSPBUF0);\n\t\t\tresp[1] = readl(owl_host->base + OWL_REG_SD_RSPBUF1);\n\t\t\tcmd->resp[0] = resp[1] << 24 | resp[0] >> 8;\n\t\t\tcmd->resp[1] = resp[1] >> 8;\n\t\t}\n\t}\n}\n\nstatic void owl_mmc_dma_complete(void *param)\n{\n\tstruct owl_mmc_host *owl_host = param;\n\tstruct mmc_data *data = owl_host->data;\n\n\tif (data)\n\t\tcomplete(&owl_host->dma_complete);\n}\n\nstatic int owl_mmc_prepare_data(struct owl_mmc_host *owl_host,\n\t\t\t\tstruct mmc_data *data)\n{\n\tu32 total;\n\n\towl_mmc_update_reg(owl_host->base + OWL_REG_SD_EN, OWL_SD_EN_BSEL,\n\t\t\t   true);\n\twritel(data->blocks, owl_host->base + OWL_REG_SD_BLK_NUM);\n\twritel(data->blksz, owl_host->base + OWL_REG_SD_BLK_SIZE);\n\ttotal = data->blksz * data->blocks;\n\n\tif (total < 512)\n\t\twritel(total, owl_host->base + OWL_REG_SD_BUF_SIZE);\n\telse\n\t\twritel(512, owl_host->base + OWL_REG_SD_BUF_SIZE);\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\towl_host->dma_dir = DMA_TO_DEVICE;\n\t\towl_host->dma_cfg.direction = DMA_MEM_TO_DEV;\n\t} else {\n\t\towl_host->dma_dir = DMA_FROM_DEVICE;\n\t\towl_host->dma_cfg.direction = DMA_DEV_TO_MEM;\n\t}\n\n\tdma_map_sg(owl_host->dma->device->dev, data->sg,\n\t\t   data->sg_len, owl_host->dma_dir);\n\n\tdmaengine_slave_config(owl_host->dma, &owl_host->dma_cfg);\n\towl_host->desc = dmaengine_prep_slave_sg(owl_host->dma, data->sg,\n\t\t\t\t\t\t data->sg_len,\n\t\t\t\t\t\t owl_host->dma_cfg.direction,\n\t\t\t\t\t\t DMA_PREP_INTERRUPT |\n\t\t\t\t\t\t DMA_CTRL_ACK);\n\tif (!owl_host->desc) {\n\t\tdev_err(owl_host->dev, \"Can't prepare slave sg\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\towl_host->data = data;\n\n\towl_host->desc->callback = owl_mmc_dma_complete;\n\towl_host->desc->callback_param = (void *)owl_host;\n\tdata->error = 0;\n\n\treturn 0;\n}\n\nstatic void owl_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct owl_mmc_host *owl_host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\tint ret;\n\n\towl_host->mrq = mrq;\n\tif (mrq->data) {\n\t\tret = owl_mmc_prepare_data(owl_host, data);\n\t\tif (ret < 0) {\n\t\t\tdata->error = ret;\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tinit_completion(&owl_host->dma_complete);\n\t\tdmaengine_submit(owl_host->desc);\n\t\tdma_async_issue_pending(owl_host->dma);\n\t}\n\n\towl_mmc_send_cmd(owl_host, mrq->cmd, data);\n\n\tif (data) {\n\t\tif (!wait_for_completion_timeout(&owl_host->sdc_complete,\n\t\t\t\t\t\t 10 * HZ)) {\n\t\t\tdev_err(owl_host->dev, \"CMD interrupt timeout\\n\");\n\t\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\t\tdmaengine_terminate_all(owl_host->dma);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (!wait_for_completion_timeout(&owl_host->dma_complete,\n\t\t\t\t\t\t 5 * HZ)) {\n\t\t\tdev_err(owl_host->dev, \"DMA interrupt timeout\\n\");\n\t\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\t\tdmaengine_terminate_all(owl_host->dma);\n\t\t\tgoto err_out;\n\t\t}\n\n\t\tif (data->stop)\n\t\t\towl_mmc_send_cmd(owl_host, data->stop, NULL);\n\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t}\n\nerr_out:\n\towl_mmc_finish_request(owl_host);\n}\n\nstatic int owl_mmc_set_clk_rate(struct owl_mmc_host *owl_host,\n\t\t\t\tunsigned int rate)\n{\n\tunsigned long clk_rate;\n\tint ret;\n\tu32 reg;\n\n\treg = readl(owl_host->base + OWL_REG_SD_CTL);\n\treg &= ~OWL_SD_CTL_DELAY_MSK;\n\n\t \n\tif (rate <= 1000000) {\n\t\twritel(reg | OWL_SD_CTL_RDELAY(OWL_SD_DELAY_LOW_CLK) |\n\t\t       OWL_SD_CTL_WDELAY(OWL_SD_DELAY_LOW_CLK),\n\t\t       owl_host->base + OWL_REG_SD_CTL);\n\t} else if ((rate > 1000000) && (rate <= 26000000)) {\n\t\twritel(reg | OWL_SD_CTL_RDELAY(OWL_SD_DELAY_MID_CLK) |\n\t\t       OWL_SD_CTL_WDELAY(OWL_SD_DELAY_MID_CLK),\n\t\t       owl_host->base + OWL_REG_SD_CTL);\n\t} else if ((rate > 26000000) && (rate <= 52000000) && !owl_host->ddr_50) {\n\t\twritel(reg | OWL_SD_CTL_RDELAY(OWL_SD_DELAY_HIGH_CLK) |\n\t\t       OWL_SD_CTL_WDELAY(OWL_SD_DELAY_HIGH_CLK),\n\t\t       owl_host->base + OWL_REG_SD_CTL);\n\t \n\t} else if ((rate > 26000000) && (rate <= 52000000) && owl_host->ddr_50) {\n\t\twritel(reg | OWL_SD_CTL_RDELAY(OWL_SD_RDELAY_DDR50) |\n\t\t       OWL_SD_CTL_WDELAY(OWL_SD_WDELAY_DDR50),\n\t\t       owl_host->base + OWL_REG_SD_CTL);\n\t} else {\n\t\tdev_err(owl_host->dev, \"SD clock rate not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk_rate = clk_round_rate(owl_host->clk, rate << 1);\n\tret = clk_set_rate(owl_host->clk, clk_rate);\n\n\treturn ret;\n}\n\nstatic void owl_mmc_set_clk(struct owl_mmc_host *owl_host, struct mmc_ios *ios)\n{\n\tif (!ios->clock)\n\t\treturn;\n\n\towl_host->clock = ios->clock;\n\towl_mmc_set_clk_rate(owl_host, ios->clock);\n}\n\nstatic void owl_mmc_set_bus_width(struct owl_mmc_host *owl_host,\n\t\t\t\t  struct mmc_ios *ios)\n{\n\tu32 reg;\n\n\treg = readl(owl_host->base + OWL_REG_SD_EN);\n\treg &= ~0x03;\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\treg |= OWL_SD_EN_DATAWID(1);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\treg |= OWL_SD_EN_DATAWID(2);\n\t\tbreak;\n\t}\n\n\twritel(reg, owl_host->base + OWL_REG_SD_EN);\n}\n\nstatic void owl_mmc_ctr_reset(struct owl_mmc_host *owl_host)\n{\n\treset_control_assert(owl_host->reset);\n\tudelay(20);\n\treset_control_deassert(owl_host->reset);\n}\n\nstatic void owl_mmc_power_on(struct owl_mmc_host *owl_host)\n{\n\tu32 mode;\n\n\tinit_completion(&owl_host->sdc_complete);\n\n\t \n\towl_mmc_update_reg(owl_host->base + OWL_REG_SD_STATE,\n\t\t       OWL_SD_STATE_TEIE, true);\n\n\t \n\tmode = (readl(owl_host->base + OWL_REG_SD_CTL) & (0xff << 16));\n\tmode |= OWL_SD_CTL_TS | OWL_SD_CTL_TCN(5) | OWL_SD_CTL_TM(8);\n\twritel(mode, owl_host->base + OWL_REG_SD_CTL);\n\n\tif (!wait_for_completion_timeout(&owl_host->sdc_complete, HZ)) {\n\t\tdev_err(owl_host->dev, \"CMD interrupt timeout\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void owl_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct owl_mmc_host *owl_host = mmc_priv(mmc);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_UP:\n\t\tdev_dbg(owl_host->dev, \"Powering card up\\n\");\n\n\t\t \n\t\towl_mmc_ctr_reset(owl_host);\n\t\tclk_prepare_enable(owl_host->clk);\n\t\twritel(OWL_SD_ENABLE | OWL_SD_EN_RESE,\n\t\t       owl_host->base + OWL_REG_SD_EN);\n\n\t\tbreak;\n\n\tcase MMC_POWER_ON:\n\t\tdev_dbg(owl_host->dev, \"Powering card on\\n\");\n\t\towl_mmc_power_on(owl_host);\n\n\t\tbreak;\n\n\tcase MMC_POWER_OFF:\n\t\tdev_dbg(owl_host->dev, \"Powering card off\\n\");\n\t\tclk_disable_unprepare(owl_host->clk);\n\n\t\treturn;\n\n\tdefault:\n\t\tdev_dbg(owl_host->dev, \"Ignoring unknown card power state\\n\");\n\t\tbreak;\n\t}\n\n\tif (ios->clock != owl_host->clock)\n\t\towl_mmc_set_clk(owl_host, ios);\n\n\towl_mmc_set_bus_width(owl_host, ios);\n\n\t \n\tif (ios->timing == MMC_TIMING_UHS_DDR50) {\n\t\towl_host->ddr_50 = true;\n\t\towl_mmc_update_reg(owl_host->base + OWL_REG_SD_EN,\n\t\t\t       OWL_SD_EN_DDREN, true);\n\t} else {\n\t\towl_host->ddr_50 = false;\n\t}\n}\n\nstatic int owl_mmc_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t       struct mmc_ios *ios)\n{\n\tstruct owl_mmc_host *owl_host = mmc_priv(mmc);\n\n\t \n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\towl_mmc_update_reg(owl_host->base + OWL_REG_SD_EN,\n\t\t\t       OWL_SD_EN_S18EN, false);\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\towl_mmc_update_reg(owl_host->base + OWL_REG_SD_EN,\n\t\t\t       OWL_SD_EN_S18EN, true);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct mmc_host_ops owl_mmc_ops = {\n\t.request\t= owl_mmc_request,\n\t.set_ios\t= owl_mmc_set_ios,\n\t.get_ro\t\t= mmc_gpio_get_ro,\n\t.get_cd\t\t= mmc_gpio_get_cd,\n\t.start_signal_voltage_switch = owl_mmc_start_signal_voltage_switch,\n};\n\nstatic int owl_mmc_probe(struct platform_device *pdev)\n{\n\tstruct owl_mmc_host *owl_host;\n\tstruct mmc_host *mmc;\n\tstruct resource *res;\n\tint ret;\n\n\tmmc = mmc_alloc_host(sizeof(struct owl_mmc_host), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"mmc alloc host failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, mmc);\n\n\towl_host = mmc_priv(mmc);\n\towl_host->dev = &pdev->dev;\n\towl_host->mmc = mmc;\n\tspin_lock_init(&owl_host->lock);\n\n\towl_host->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(owl_host->base)) {\n\t\tret = PTR_ERR(owl_host->base);\n\t\tgoto err_free_host;\n\t}\n\n\towl_host->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(owl_host->clk)) {\n\t\tdev_err(&pdev->dev, \"No clock defined\\n\");\n\t\tret = PTR_ERR(owl_host->clk);\n\t\tgoto err_free_host;\n\t}\n\n\towl_host->reset = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(owl_host->reset)) {\n\t\tdev_err(&pdev->dev, \"Could not get reset control\\n\");\n\t\tret = PTR_ERR(owl_host->reset);\n\t\tgoto err_free_host;\n\t}\n\n\tmmc->ops\t\t= &owl_mmc_ops;\n\tmmc->max_blk_count\t= 512;\n\tmmc->max_blk_size\t= 512;\n\tmmc->max_segs\t\t= 256;\n\tmmc->max_seg_size\t= 262144;\n\tmmc->max_req_size\t= 262144;\n\t \n\tmmc->f_min\t\t= 100000;\n\tmmc->f_max\t\t= 52000000;\n\tmmc->caps\t       |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |\n\t\t\t\t  MMC_CAP_4_BIT_DATA;\n\tmmc->caps2\t\t= (MMC_CAP2_BOOTPART_NOACC | MMC_CAP2_NO_SDIO);\n\tmmc->ocr_avail\t\t= MMC_VDD_32_33 | MMC_VDD_33_34 |\n\t\t\t\t  MMC_VDD_165_195;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err_free_host;\n\n\tpdev->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\tpdev->dev.dma_mask = &pdev->dev.coherent_dma_mask;\n\towl_host->dma = dma_request_chan(&pdev->dev, \"mmc\");\n\tif (IS_ERR(owl_host->dma)) {\n\t\tdev_err(owl_host->dev, \"Failed to get external DMA channel.\\n\");\n\t\tret = PTR_ERR(owl_host->dma);\n\t\tgoto err_free_host;\n\t}\n\n\tdev_info(&pdev->dev, \"Using %s for DMA transfers\\n\",\n\t\t dma_chan_name(owl_host->dma));\n\n\towl_host->dma_cfg.src_addr = res->start + OWL_REG_SD_DAT;\n\towl_host->dma_cfg.dst_addr = res->start + OWL_REG_SD_DAT;\n\towl_host->dma_cfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\towl_host->dma_cfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\towl_host->dma_cfg.device_fc = false;\n\n\towl_host->irq = platform_get_irq(pdev, 0);\n\tif (owl_host->irq < 0) {\n\t\tret = owl_host->irq;\n\t\tgoto err_release_channel;\n\t}\n\n\tret = devm_request_irq(&pdev->dev, owl_host->irq, owl_irq_handler,\n\t\t\t       0, dev_name(&pdev->dev), owl_host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq %d\\n\",\n\t\t\towl_host->irq);\n\t\tgoto err_release_channel;\n\t}\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add host\\n\");\n\t\tgoto err_release_channel;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Owl MMC Controller Initialized\\n\");\n\n\treturn 0;\n\nerr_release_channel:\n\tdma_release_channel(owl_host->dma);\nerr_free_host:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void owl_mmc_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host\t*mmc = platform_get_drvdata(pdev);\n\tstruct owl_mmc_host *owl_host = mmc_priv(mmc);\n\n\tmmc_remove_host(mmc);\n\tdisable_irq(owl_host->irq);\n\tdma_release_channel(owl_host->dma);\n\tmmc_free_host(mmc);\n}\n\nstatic const struct of_device_id owl_mmc_of_match[] = {\n\t{.compatible = \"actions,owl-mmc\",},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, owl_mmc_of_match);\n\nstatic struct platform_driver owl_mmc_driver = {\n\t.driver = {\n\t\t.name\t= \"owl_mmc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = owl_mmc_of_match,\n\t},\n\t.probe\t\t= owl_mmc_probe,\n\t.remove_new\t= owl_mmc_remove,\n};\nmodule_platform_driver(owl_mmc_driver);\n\nMODULE_DESCRIPTION(\"Actions Semi Owl SoCs SD/MMC Driver\");\nMODULE_AUTHOR(\"Actions Semi\");\nMODULE_AUTHOR(\"Manivannan Sadhasivam <manivannan.sadhasivam@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}