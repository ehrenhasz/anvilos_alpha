{
  "module_name": "sdhci-bcm-kona.c",
  "hash_id": "0b5bc6a11a42c1a5880c22416ce5808dd900e41f551938946dc7cb688d63d9b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-bcm-kona.c",
  "human_readable_source": "\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/platform_device.h>\n#include <linux/mmc/host.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include \"sdhci-pltfm.h\"\n#include \"sdhci.h\"\n\n#define SDHCI_SOFT_RESET\t\t\t0x01000000\n#define KONA_SDHOST_CORECTRL\t\t\t0x8000\n#define KONA_SDHOST_CD_PINCTRL\t\t\t0x00000008\n#define KONA_SDHOST_STOP_HCLK\t\t\t0x00000004\n#define KONA_SDHOST_RESET\t\t\t0x00000002\n#define KONA_SDHOST_EN\t\t\t\t0x00000001\n\n#define KONA_SDHOST_CORESTAT\t\t\t0x8004\n#define KONA_SDHOST_WP\t\t\t\t0x00000002\n#define KONA_SDHOST_CD_SW\t\t\t0x00000001\n\n#define KONA_SDHOST_COREIMR\t\t\t0x8008\n#define KONA_SDHOST_IP\t\t\t\t0x00000001\n\n#define KONA_SDHOST_COREISR\t\t\t0x800C\n#define KONA_SDHOST_COREIMSR\t\t\t0x8010\n#define KONA_SDHOST_COREDBG1\t\t\t0x8014\n#define KONA_SDHOST_COREGPO_MASK\t\t0x8018\n\n#define SD_DETECT_GPIO_DEBOUNCE_128MS\t\t128\n\n#define KONA_MMC_AUTOSUSPEND_DELAY\t\t(50)\n\nstruct sdhci_bcm_kona_dev {\n\tstruct mutex\twrite_lock;  \n};\n\n\nstatic int sdhci_bcm_kona_sd_reset(struct sdhci_host *host)\n{\n\tunsigned int val;\n\tunsigned long timeout;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(100);\n\n\t \n\tval = sdhci_readl(host, KONA_SDHOST_CORECTRL);\n\tval |= KONA_SDHOST_RESET;\n\tsdhci_writel(host, val, KONA_SDHOST_CORECTRL);\n\n\twhile (!(sdhci_readl(host, KONA_SDHOST_CORECTRL) & KONA_SDHOST_RESET)) {\n\t\tif (time_is_before_jiffies(timeout)) {\n\t\t\tpr_err(\"Error: sd host is stuck in reset!!!\\n\");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t \n\tval = sdhci_readl(host, KONA_SDHOST_CORECTRL);\n\tval &= ~KONA_SDHOST_RESET;\n\n\t \n\tusleep_range(1000, 5000);\n\tsdhci_writel(host, val, KONA_SDHOST_CORECTRL);\n\n\treturn 0;\n}\n\nstatic void sdhci_bcm_kona_sd_init(struct sdhci_host *host)\n{\n\tunsigned int val;\n\n\t \n\tval = sdhci_readl(host, KONA_SDHOST_COREIMR);\n\tval |= KONA_SDHOST_IP;\n\tsdhci_writel(host, val, KONA_SDHOST_COREIMR);\n\n\t \n\tval = sdhci_readl(host, KONA_SDHOST_CORECTRL);\n\tval |= KONA_SDHOST_EN;\n\n\t \n\tusleep_range(1000, 5000);\n\tsdhci_writel(host, val, KONA_SDHOST_CORECTRL);\n}\n\n \nstatic int sdhci_bcm_kona_sd_card_emulate(struct sdhci_host *host, int insert)\n{\n\tstruct sdhci_pltfm_host *pltfm_priv = sdhci_priv(host);\n\tstruct sdhci_bcm_kona_dev *kona_dev = sdhci_pltfm_priv(pltfm_priv);\n\tu32 val;\n\n\t \n\tmutex_lock(&kona_dev->write_lock);\n\tudelay(20);\n\tval = sdhci_readl(host, KONA_SDHOST_CORESTAT);\n\n\tif (insert) {\n\t\tint ret;\n\n\t\tret = mmc_gpio_get_ro(host->mmc);\n\t\tif (ret >= 0)\n\t\t\tval = (val & ~KONA_SDHOST_WP) |\n\t\t\t\t((ret) ? KONA_SDHOST_WP : 0);\n\n\t\tval |= KONA_SDHOST_CD_SW;\n\t\tsdhci_writel(host, val, KONA_SDHOST_CORESTAT);\n\t} else {\n\t\tval &= ~KONA_SDHOST_CD_SW;\n\t\tsdhci_writel(host, val, KONA_SDHOST_CORESTAT);\n\t}\n\tmutex_unlock(&kona_dev->write_lock);\n\n\treturn 0;\n}\n\n \nstatic void sdhci_bcm_kona_card_event(struct sdhci_host *host)\n{\n\tif (mmc_gpio_get_cd(host->mmc) > 0) {\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"card inserted\\n\");\n\t\tsdhci_bcm_kona_sd_card_emulate(host, 1);\n\t} else {\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"card removed\\n\");\n\t\tsdhci_bcm_kona_sd_card_emulate(host, 0);\n\t}\n}\n\nstatic void sdhci_bcm_kona_init_74_clocks(struct sdhci_host *host,\n\t\t\t\tu8 power_mode)\n{\n\t \n\tif (power_mode != MMC_POWER_OFF)\n\t\tudelay(740);\n}\n\nstatic const struct sdhci_ops sdhci_bcm_kona_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.platform_send_init_74_clocks = sdhci_bcm_kona_init_74_clocks,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.card_event = sdhci_bcm_kona_card_event,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_pltfm_data_kona = {\n\t.ops    = &sdhci_bcm_kona_ops,\n\t.quirks = SDHCI_QUIRK_NO_CARD_NO_RESET |\n\t\tSDHCI_QUIRK_BROKEN_TIMEOUT_VAL | SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\tSDHCI_QUIRK_32BIT_DMA_SIZE | SDHCI_QUIRK_32BIT_ADMA_SIZE |\n\t\tSDHCI_QUIRK_FORCE_BLK_SZ_2048 |\n\t\tSDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n};\n\nstatic const struct of_device_id sdhci_bcm_kona_of_match[] = {\n\t{ .compatible = \"brcm,kona-sdhci\"},\n\t{ .compatible = \"bcm,kona-sdhci\"},  \n\t{}\n};\nMODULE_DEVICE_TABLE(of, sdhci_bcm_kona_of_match);\n\nstatic int sdhci_bcm_kona_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_bcm_kona_dev *kona_dev = NULL;\n\tstruct sdhci_pltfm_host *pltfm_priv;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host;\n\tint ret;\n\n\tret = 0;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_pltfm_data_kona,\n\t\t\tsizeof(*kona_dev));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tdev_dbg(dev, \"%s: inited. IOADDR=%p\\n\", __func__, host->ioaddr);\n\n\tpltfm_priv = sdhci_priv(host);\n\n\tkona_dev = sdhci_pltfm_priv(pltfm_priv);\n\tmutex_init(&kona_dev->write_lock);\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err_pltfm_free;\n\n\tif (!host->mmc->f_max) {\n\t\tdev_err(&pdev->dev, \"Missing max-freq for SDHCI cfg\\n\");\n\t\tret = -ENXIO;\n\t\tgoto err_pltfm_free;\n\t}\n\n\t \n\tpltfm_priv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pltfm_priv->clk)) {\n\t\tdev_err(dev, \"Failed to get core clock\\n\");\n\t\tret = PTR_ERR(pltfm_priv->clk);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = clk_set_rate(pltfm_priv->clk, host->mmc->f_max);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to set rate core clock\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = clk_prepare_enable(pltfm_priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable core clock\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\tdev_dbg(dev, \"non-removable=%c\\n\",\n\t\tmmc_card_is_removable(host->mmc) ? 'N' : 'Y');\n\tdev_dbg(dev, \"cd_gpio %c, wp_gpio %c\\n\",\n\t\t(mmc_gpio_get_cd(host->mmc) != -ENOSYS) ? 'Y' : 'N',\n\t\t(mmc_gpio_get_ro(host->mmc) != -ENOSYS) ? 'Y' : 'N');\n\n\tif (!mmc_card_is_removable(host->mmc))\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\n\tdev_dbg(dev, \"is_8bit=%c\\n\",\n\t\t(host->mmc->caps & MMC_CAP_8_BIT_DATA) ? 'Y' : 'N');\n\n\tret = sdhci_bcm_kona_sd_reset(host);\n\tif (ret)\n\t\tgoto err_clk_disable;\n\n\tsdhci_bcm_kona_sd_init(host);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_reset;\n\n\t \n\tif (!mmc_card_is_removable(host->mmc)) {\n\t\tret = sdhci_bcm_kona_sd_card_emulate(host, 1);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"unable to emulate card insertion\\n\");\n\t\t\tgoto err_remove_host;\n\t\t}\n\t}\n\t \n\tif (mmc_gpio_get_cd(host->mmc) > 0)\n\t\tsdhci_bcm_kona_sd_card_emulate(host, 1);\n\n\tdev_dbg(dev, \"initialized properly\\n\");\n\treturn 0;\n\nerr_remove_host:\n\tsdhci_remove_host(host, 0);\n\nerr_reset:\n\tsdhci_bcm_kona_sd_reset(host);\n\nerr_clk_disable:\n\tclk_disable_unprepare(pltfm_priv->clk);\n\nerr_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\n\tdev_err(dev, \"Probing of sdhci-pltfm failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void sdhci_bcm_kona_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct clk *clk = pltfm_host->clk;\n\n\tsdhci_pltfm_remove(pdev);\n\tclk_disable_unprepare(clk);\n}\n\nstatic struct platform_driver sdhci_bcm_kona_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-kona\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &sdhci_pltfm_pmops,\n\t\t.of_match_table = sdhci_bcm_kona_of_match,\n\t},\n\t.probe\t\t= sdhci_bcm_kona_probe,\n\t.remove_new\t= sdhci_bcm_kona_remove,\n};\nmodule_platform_driver(sdhci_bcm_kona_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for Broadcom Kona platform\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}