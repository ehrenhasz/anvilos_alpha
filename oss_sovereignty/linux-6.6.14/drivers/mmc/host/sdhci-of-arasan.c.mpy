{
  "module_name": "sdhci-of-arasan.c",
  "hash_id": "a25a610143dbfc3c564965ea32cd3d3132842b961a455fc4edcf9832277dbac5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-arasan.c",
  "human_readable_source": "\n \n\n#include <linux/clk-provider.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n\n#include \"cqhci.h\"\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n\n#define SDHCI_ARASAN_VENDOR_REGISTER\t0x78\n\n#define SDHCI_ARASAN_ITAPDLY_REGISTER\t0xF0F8\n#define SDHCI_ARASAN_ITAPDLY_SEL_MASK\t0xFF\n\n#define SDHCI_ARASAN_OTAPDLY_REGISTER\t0xF0FC\n#define SDHCI_ARASAN_OTAPDLY_SEL_MASK\t0x3F\n\n#define SDHCI_ARASAN_CQE_BASE_ADDR\t0x200\n#define VENDOR_ENHANCED_STROBE\t\tBIT(0)\n\n#define PHY_CLK_TOO_SLOW_HZ\t\t400000\n#define MIN_PHY_CLK_HZ\t\t\t50000000\n\n#define SDHCI_ITAPDLY_CHGWIN\t\t0x200\n#define SDHCI_ITAPDLY_ENABLE\t\t0x100\n#define SDHCI_OTAPDLY_ENABLE\t\t0x40\n\n#define PHY_CTRL_REG1\t\t\t0x270\n#define PHY_CTRL_ITAPDLY_ENA_MASK\tBIT(0)\n#define PHY_CTRL_ITAPDLY_SEL_MASK\tGENMASK(5, 1)\n#define PHY_CTRL_ITAPDLY_SEL_SHIFT\t1\n#define PHY_CTRL_ITAP_CHG_WIN_MASK\tBIT(6)\n#define PHY_CTRL_OTAPDLY_ENA_MASK\tBIT(8)\n#define PHY_CTRL_OTAPDLY_SEL_MASK\tGENMASK(15, 12)\n#define PHY_CTRL_OTAPDLY_SEL_SHIFT\t12\n#define PHY_CTRL_STRB_SEL_MASK\t\tGENMASK(23, 16)\n#define PHY_CTRL_STRB_SEL_SHIFT\t\t16\n#define PHY_CTRL_TEST_CTRL_MASK\t\tGENMASK(31, 24)\n\n#define PHY_CTRL_REG2\t\t\t0x274\n#define PHY_CTRL_EN_DLL_MASK\t\tBIT(0)\n#define PHY_CTRL_DLL_RDY_MASK\t\tBIT(1)\n#define PHY_CTRL_FREQ_SEL_MASK\t\tGENMASK(6, 4)\n#define PHY_CTRL_FREQ_SEL_SHIFT\t\t4\n#define PHY_CTRL_SEL_DLY_TX_MASK\tBIT(16)\n#define PHY_CTRL_SEL_DLY_RX_MASK\tBIT(17)\n#define FREQSEL_200M_170M\t\t0x0\n#define FREQSEL_170M_140M\t        0x1\n#define FREQSEL_140M_110M\t        0x2\n#define FREQSEL_110M_80M\t        0x3\n#define FREQSEL_80M_50M\t\t\t0x4\n#define FREQSEL_275M_250M\t\t0x5\n#define FREQSEL_250M_225M\t\t0x6\n#define FREQSEL_225M_200M\t\t0x7\n#define PHY_DLL_TIMEOUT_MS\t\t100\n\n \n#define ZYNQMP_ICLK_PHASE {0, 63, 63, 0, 63,  0,   0, 183, 54,  0, 0}\n#define ZYNQMP_OCLK_PHASE {0, 72, 60, 0, 60, 72, 135, 48, 72, 135, 0}\n\n#define VERSAL_ICLK_PHASE {0, 132, 132, 0, 132, 0, 0, 162, 90, 0, 0}\n#define VERSAL_OCLK_PHASE {0,  60, 48, 0, 48, 72, 90, 36, 60, 90, 0}\n\n#define VERSAL_NET_EMMC_ICLK_PHASE {0, 0, 0, 0, 0, 0, 0, 0, 39, 0, 0}\n#define VERSAL_NET_EMMC_OCLK_PHASE {0, 113, 0, 0, 0, 0, 0, 0, 113, 79, 45}\n\n#define VERSAL_NET_PHY_CTRL_STRB90_STRB180_VAL\t\t0X77\n\n \n#define HIWORD_UPDATE(val, mask, shift) \\\n\t\t((val) << (shift) | (mask) << ((shift) + 16))\n\n \nstruct sdhci_arasan_soc_ctl_field {\n\tu32 reg;\n\tu16 width;\n\ts16 shift;\n};\n\n \nstruct sdhci_arasan_soc_ctl_map {\n\tstruct sdhci_arasan_soc_ctl_field\tbaseclkfreq;\n\tstruct sdhci_arasan_soc_ctl_field\tclockmultiplier;\n\tstruct sdhci_arasan_soc_ctl_field\tsupport64b;\n\tbool\t\t\t\t\thiword_update;\n};\n\n \nstruct sdhci_arasan_clk_ops {\n\tconst struct clk_ops *sdcardclk_ops;\n\tconst struct clk_ops *sampleclk_ops;\n};\n\n \nstruct sdhci_arasan_clk_data {\n\tstruct clk_hw\tsdcardclk_hw;\n\tstruct clk      *sdcardclk;\n\tstruct clk_hw\tsampleclk_hw;\n\tstruct clk      *sampleclk;\n\tint\t\tclk_phase_in[MMC_TIMING_MMC_HS400 + 1];\n\tint\t\tclk_phase_out[MMC_TIMING_MMC_HS400 + 1];\n\tvoid\t\t(*set_clk_delays)(struct sdhci_host *host);\n\tvoid\t\t*clk_of_data;\n};\n\n \nstruct sdhci_arasan_data {\n\tstruct sdhci_host *host;\n\tstruct clk\t*clk_ahb;\n\tstruct phy\t*phy;\n\tbool\t\tis_phy_on;\n\tbool\t\tinternal_phy_reg;\n\n\tbool\t\thas_cqe;\n\tstruct sdhci_arasan_clk_data clk_data;\n\tconst struct sdhci_arasan_clk_ops *clk_ops;\n\n\tstruct regmap\t*soc_ctl_base;\n\tconst struct sdhci_arasan_soc_ctl_map *soc_ctl_map;\n\tunsigned int\tquirks;\n\n \n#define SDHCI_ARASAN_QUIRK_FORCE_CDTEST\tBIT(0)\n \n#define SDHCI_ARASAN_QUIRK_CLOCK_UNSTABLE BIT(1)\n \n#define SDHCI_ARASAN_QUIRK_CLOCK_25_BROKEN BIT(2)\n};\n\nstruct sdhci_arasan_of_data {\n\tconst struct sdhci_arasan_soc_ctl_map *soc_ctl_map;\n\tconst struct sdhci_pltfm_data *pdata;\n\tconst struct sdhci_arasan_clk_ops *clk_ops;\n};\n\nstatic const struct sdhci_arasan_soc_ctl_map rk3399_soc_ctl_map = {\n\t.baseclkfreq = { .reg = 0xf000, .width = 8, .shift = 8 },\n\t.clockmultiplier = { .reg = 0xf02c, .width = 8, .shift = 0},\n\t.hiword_update = true,\n};\n\nstatic const struct sdhci_arasan_soc_ctl_map intel_lgm_emmc_soc_ctl_map = {\n\t.baseclkfreq = { .reg = 0xa0, .width = 8, .shift = 2 },\n\t.clockmultiplier = { .reg = 0, .width = -1, .shift = -1 },\n\t.hiword_update = false,\n};\n\nstatic const struct sdhci_arasan_soc_ctl_map intel_lgm_sdxc_soc_ctl_map = {\n\t.baseclkfreq = { .reg = 0x80, .width = 8, .shift = 2 },\n\t.clockmultiplier = { .reg = 0, .width = -1, .shift = -1 },\n\t.hiword_update = false,\n};\n\nstatic const struct sdhci_arasan_soc_ctl_map intel_keembay_soc_ctl_map = {\n\t.baseclkfreq = { .reg = 0x0, .width = 8, .shift = 14 },\n\t.clockmultiplier = { .reg = 0x4, .width = 8, .shift = 14 },\n\t.support64b = { .reg = 0x4, .width = 1, .shift = 24 },\n\t.hiword_update = false,\n};\n\nstatic void sdhci_arasan_phy_set_delaychain(struct sdhci_host *host, bool enable)\n{\n\tu32 reg;\n\n\treg = readl(host->ioaddr + PHY_CTRL_REG2);\n\tif (enable)\n\t\treg |= (PHY_CTRL_SEL_DLY_TX_MASK | PHY_CTRL_SEL_DLY_RX_MASK);\n\telse\n\t\treg &= ~(PHY_CTRL_SEL_DLY_TX_MASK | PHY_CTRL_SEL_DLY_RX_MASK);\n\n\twritel(reg, host->ioaddr + PHY_CTRL_REG2);\n}\n\nstatic int sdhci_arasan_phy_set_dll(struct sdhci_host *host, bool enable)\n{\n\tu32 reg;\n\n\treg = readl(host->ioaddr + PHY_CTRL_REG2);\n\tif (enable)\n\t\treg |= PHY_CTRL_EN_DLL_MASK;\n\telse\n\t\treg &= ~PHY_CTRL_EN_DLL_MASK;\n\n\twritel(reg, host->ioaddr + PHY_CTRL_REG2);\n\n\tif (!enable)\n\t\treturn 0;\n\n\treturn readl_relaxed_poll_timeout(host->ioaddr + PHY_CTRL_REG2, reg,\n\t\t\t\t\t  (reg & PHY_CTRL_DLL_RDY_MASK), 10,\n\t\t\t\t\t  1000 * PHY_DLL_TIMEOUT_MS);\n}\n\nstatic void sdhci_arasan_phy_dll_set_freq(struct sdhci_host *host, int clock)\n{\n\tu32 reg, freq_sel, freq;\n\n\tfreq = DIV_ROUND_CLOSEST(clock, 1000000);\n\tif (freq <= 200 && freq > 170)\n\t\tfreq_sel = FREQSEL_200M_170M;\n\telse if (freq <= 170 && freq > 140)\n\t\tfreq_sel = FREQSEL_170M_140M;\n\telse if (freq <= 140 && freq > 110)\n\t\tfreq_sel = FREQSEL_140M_110M;\n\telse if (freq <= 110 && freq > 80)\n\t\tfreq_sel = FREQSEL_110M_80M;\n\telse\n\t\tfreq_sel = FREQSEL_80M_50M;\n\n\treg = readl(host->ioaddr + PHY_CTRL_REG2);\n\treg &= ~PHY_CTRL_FREQ_SEL_MASK;\n\treg |= (freq_sel << PHY_CTRL_FREQ_SEL_SHIFT);\n\twritel(reg, host->ioaddr + PHY_CTRL_REG2);\n}\n\n \nstatic int sdhci_arasan_syscon_write(struct sdhci_host *host,\n\t\t\t\t   const struct sdhci_arasan_soc_ctl_field *fld,\n\t\t\t\t   u32 val)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tstruct regmap *soc_ctl_base = sdhci_arasan->soc_ctl_base;\n\tu32 reg = fld->reg;\n\tu16 width = fld->width;\n\ts16 shift = fld->shift;\n\tint ret;\n\n\t \n\tif (shift < 0)\n\t\treturn -EINVAL;\n\n\tif (sdhci_arasan->soc_ctl_map->hiword_update)\n\t\tret = regmap_write(soc_ctl_base, reg,\n\t\t\t\t   HIWORD_UPDATE(val, GENMASK(width, 0),\n\t\t\t\t\t\t shift));\n\telse\n\t\tret = regmap_update_bits(soc_ctl_base, reg,\n\t\t\t\t\t GENMASK(shift + width, shift),\n\t\t\t\t\t val << shift);\n\n\t \n\tif (ret)\n\t\tpr_warn(\"%s: Regmap write fail: %d\\n\",\n\t\t\t mmc_hostname(host->mmc), ret);\n\n\treturn ret;\n}\n\nstatic void sdhci_arasan_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tstruct sdhci_arasan_clk_data *clk_data = &sdhci_arasan->clk_data;\n\tbool ctrl_phy = false;\n\n\tif (!IS_ERR(sdhci_arasan->phy)) {\n\t\tif (!sdhci_arasan->is_phy_on && clock <= PHY_CLK_TOO_SLOW_HZ) {\n\t\t\t \n\t\t\tsdhci_set_clock(host, host->max_clk);\n\t\t\tif (phy_power_on(sdhci_arasan->phy)) {\n\t\t\t\tpr_err(\"%s: Cannot power on phy.\\n\",\n\t\t\t\t       mmc_hostname(host->mmc));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsdhci_arasan->is_phy_on = true;\n\n\t\t\t \n\t\t} else if (clock > PHY_CLK_TOO_SLOW_HZ) {\n\t\t\t \n\t\t\tctrl_phy = true;\n\t\t}\n\t}\n\n\tif (ctrl_phy && sdhci_arasan->is_phy_on) {\n\t\tphy_power_off(sdhci_arasan->phy);\n\t\tsdhci_arasan->is_phy_on = false;\n\t}\n\n\tif (sdhci_arasan->quirks & SDHCI_ARASAN_QUIRK_CLOCK_25_BROKEN) {\n\t\t \n\t\tif (clock == DEFAULT_SPEED_MAX_DTR)\n\t\t\tclock = (DEFAULT_SPEED_MAX_DTR * 19) / 25;\n\t}\n\n\t \n\tif (clk_data->set_clk_delays && clock > PHY_CLK_TOO_SLOW_HZ)\n\t\tclk_data->set_clk_delays(host);\n\n\tif (sdhci_arasan->internal_phy_reg && clock >= MIN_PHY_CLK_HZ) {\n\t\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\t\tsdhci_arasan_phy_set_dll(host, 0);\n\t\tsdhci_arasan_phy_set_delaychain(host, 0);\n\t\tsdhci_arasan_phy_dll_set_freq(host, clock);\n\t} else if (sdhci_arasan->internal_phy_reg) {\n\t\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\t\tsdhci_arasan_phy_set_delaychain(host, 1);\n\t}\n\n\tsdhci_set_clock(host, clock);\n\n\tif (sdhci_arasan->internal_phy_reg && clock >= MIN_PHY_CLK_HZ)\n\t\tsdhci_arasan_phy_set_dll(host, 1);\n\n\tif (sdhci_arasan->quirks & SDHCI_ARASAN_QUIRK_CLOCK_UNSTABLE)\n\t\t \n\t\tmsleep(20);\n\n\tif (ctrl_phy) {\n\t\tif (phy_power_on(sdhci_arasan->phy)) {\n\t\t\tpr_err(\"%s: Cannot power on phy.\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\t\t\treturn;\n\t\t}\n\n\t\tsdhci_arasan->is_phy_on = true;\n\t}\n}\n\nstatic void sdhci_arasan_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\tstruct mmc_ios *ios)\n{\n\tu32 vendor;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tvendor = sdhci_readl(host, SDHCI_ARASAN_VENDOR_REGISTER);\n\tif (ios->enhanced_strobe)\n\t\tvendor |= VENDOR_ENHANCED_STROBE;\n\telse\n\t\tvendor &= ~VENDOR_ENHANCED_STROBE;\n\n\tsdhci_writel(host, vendor, SDHCI_ARASAN_VENDOR_REGISTER);\n}\n\nstatic void sdhci_arasan_reset(struct sdhci_host *host, u8 mask)\n{\n\tu8 ctrl;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_and_cqhci_reset(host, mask);\n\n\tif (sdhci_arasan->quirks & SDHCI_ARASAN_QUIRK_FORCE_CDTEST) {\n\t\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\t\tctrl |= SDHCI_CTRL_CDTEST_INS | SDHCI_CTRL_CDTEST_EN;\n\t\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n\t}\n}\n\nstatic int sdhci_arasan_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\t \n\t\treturn 0;\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\tcase MMC_SIGNAL_VOLTAGE_120:\n\t\t \n\t\tbreak;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic const struct sdhci_ops sdhci_arasan_ops = {\n\t.set_clock = sdhci_arasan_set_clock,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_arasan_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n};\n\nstatic u32 sdhci_arasan_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\nstatic void sdhci_arasan_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\nstatic void sdhci_arasan_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 reg;\n\n\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\twhile (reg & SDHCI_DATA_AVAILABLE) {\n\t\tsdhci_readl(host, SDHCI_BUFFER);\n\t\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\t}\n\n\tsdhci_cqe_enable(mmc);\n}\n\nstatic const struct cqhci_host_ops sdhci_arasan_cqhci_ops = {\n\t.enable         = sdhci_arasan_cqe_enable,\n\t.disable        = sdhci_cqe_disable,\n\t.dumpregs       = sdhci_arasan_dumpregs,\n};\n\nstatic const struct sdhci_ops sdhci_arasan_cqe_ops = {\n\t.set_clock = sdhci_arasan_set_clock,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_arasan_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n\t.irq = sdhci_arasan_cqhci_irq,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_arasan_cqe_pdata = {\n\t.ops = &sdhci_arasan_cqe_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,\n};\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int sdhci_arasan_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tif (sdhci_arasan->has_cqe) {\n\t\tret = cqhci_suspend(host->mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sdhci_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(sdhci_arasan->phy) && sdhci_arasan->is_phy_on) {\n\t\tret = phy_power_off(sdhci_arasan->phy);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot power off phy.\\n\");\n\t\t\tif (sdhci_resume_host(host))\n\t\t\t\tdev_err(dev, \"Cannot resume host.\\n\");\n\n\t\t\treturn ret;\n\t\t}\n\t\tsdhci_arasan->is_phy_on = false;\n\t}\n\n\tclk_disable(pltfm_host->clk);\n\tclk_disable(sdhci_arasan->clk_ahb);\n\n\treturn 0;\n}\n\n \nstatic int sdhci_arasan_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = clk_enable(sdhci_arasan->clk_ahb);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable AHB clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_enable(pltfm_host->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot enable SD clock.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (!IS_ERR(sdhci_arasan->phy) && host->mmc->actual_clock) {\n\t\tret = phy_power_on(sdhci_arasan->phy);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Cannot power on phy.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tsdhci_arasan->is_phy_on = true;\n\t}\n\n\tret = sdhci_resume_host(host);\n\tif (ret) {\n\t\tdev_err(dev, \"Cannot resume host.\\n\");\n\t\treturn ret;\n\t}\n\n\tif (sdhci_arasan->has_cqe)\n\t\treturn cqhci_resume(host->mmc);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(sdhci_arasan_dev_pm_ops, sdhci_arasan_suspend,\n\t\t\t sdhci_arasan_resume);\n\n \nstatic unsigned long sdhci_arasan_sdcardclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sdcardclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\n\treturn host->mmc->actual_clock;\n}\n\nstatic const struct clk_ops arasan_sdcardclk_ops = {\n\t.recalc_rate = sdhci_arasan_sdcardclk_recalc_rate,\n};\n\n \nstatic unsigned long sdhci_arasan_sampleclk_recalc_rate(struct clk_hw *hw,\n\t\t\t\t\t\t      unsigned long parent_rate)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sampleclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\n\treturn host->mmc->actual_clock;\n}\n\nstatic const struct clk_ops arasan_sampleclk_ops = {\n\t.recalc_rate = sdhci_arasan_sampleclk_recalc_rate,\n};\n\n \nstatic int sdhci_zynqmp_sdcardclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sdcardclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 node_id = !strcmp(clk_name, \"clk_out_sd0\") ? NODE_SD_0 : NODE_SD_1;\n\tu8 tap_delay, tap_max = 0;\n\tint ret;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\t \n\t\ttap_max = 30;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\t \n\t\ttap_max = 15;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\t \n\t\ttap_max = 8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tret = zynqmp_pm_set_sd_tapdelay(node_id, PM_TAPDELAY_OUTPUT, tap_delay);\n\tif (ret)\n\t\tpr_err(\"Error setting Output Tap Delay\\n\");\n\n\t \n\tzynqmp_pm_sd_dll_reset(node_id, PM_DLL_RESET_RELEASE);\n\n\treturn ret;\n}\n\nstatic const struct clk_ops zynqmp_sdcardclk_ops = {\n\t.recalc_rate = sdhci_arasan_sdcardclk_recalc_rate,\n\t.set_phase = sdhci_zynqmp_sdcardclk_set_phase,\n};\n\n \nstatic int sdhci_zynqmp_sampleclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sampleclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 node_id = !strcmp(clk_name, \"clk_in_sd0\") ? NODE_SD_0 : NODE_SD_1;\n\tu8 tap_delay, tap_max = 0;\n\tint ret;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\t \n\tzynqmp_pm_sd_dll_reset(node_id, PM_DLL_RESET_ASSERT);\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\t \n\t\ttap_max = 120;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\t \n\t\ttap_max = 60;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\t \n\t\ttap_max = 30;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tret = zynqmp_pm_set_sd_tapdelay(node_id, PM_TAPDELAY_INPUT, tap_delay);\n\tif (ret)\n\t\tpr_err(\"Error setting Input Tap Delay\\n\");\n\n\treturn ret;\n}\n\nstatic const struct clk_ops zynqmp_sampleclk_ops = {\n\t.recalc_rate = sdhci_arasan_sampleclk_recalc_rate,\n\t.set_phase = sdhci_zynqmp_sampleclk_set_phase,\n};\n\n \nstatic int sdhci_versal_sdcardclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sdcardclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tu8 tap_delay, tap_max = 0;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\t \n\t\ttap_max = 30;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\t \n\t\ttap_max = 15;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\t \n\t\ttap_max = 8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tif (tap_delay) {\n\t\tu32 regval;\n\n\t\tregval = sdhci_readl(host, SDHCI_ARASAN_OTAPDLY_REGISTER);\n\t\tregval |= SDHCI_OTAPDLY_ENABLE;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_OTAPDLY_REGISTER);\n\t\tregval &= ~SDHCI_ARASAN_OTAPDLY_SEL_MASK;\n\t\tregval |= tap_delay;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_OTAPDLY_REGISTER);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops versal_sdcardclk_ops = {\n\t.recalc_rate = sdhci_arasan_sdcardclk_recalc_rate,\n\t.set_phase = sdhci_versal_sdcardclk_set_phase,\n};\n\n \nstatic int sdhci_versal_sampleclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sampleclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tu8 tap_delay, tap_max = 0;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\t \n\t\ttap_max = 120;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\t \n\t\ttap_max = 60;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\t \n\t\ttap_max = 30;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tif (tap_delay) {\n\t\tu32 regval;\n\n\t\tregval = sdhci_readl(host, SDHCI_ARASAN_ITAPDLY_REGISTER);\n\t\tregval |= SDHCI_ITAPDLY_CHGWIN;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_ITAPDLY_REGISTER);\n\t\tregval |= SDHCI_ITAPDLY_ENABLE;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_ITAPDLY_REGISTER);\n\t\tregval &= ~SDHCI_ARASAN_ITAPDLY_SEL_MASK;\n\t\tregval |= tap_delay;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_ITAPDLY_REGISTER);\n\t\tregval &= ~SDHCI_ITAPDLY_CHGWIN;\n\t\tsdhci_writel(host, regval, SDHCI_ARASAN_ITAPDLY_REGISTER);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops versal_sampleclk_ops = {\n\t.recalc_rate = sdhci_arasan_sampleclk_recalc_rate,\n\t.set_phase = sdhci_versal_sampleclk_set_phase,\n};\n\nstatic int sdhci_versal_net_emmc_sdcardclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sdcardclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tu8 tap_delay, tap_max = 0;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\ttap_max = 16;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS200:\n\tcase MMC_TIMING_MMC_HS400:\n\t\t  \n\t\ttap_max = 32;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tif (tap_delay) {\n\t\tu32 regval;\n\n\t\tregval = sdhci_readl(host, PHY_CTRL_REG1);\n\t\tregval |= PHY_CTRL_OTAPDLY_ENA_MASK;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t\tregval &= ~PHY_CTRL_OTAPDLY_SEL_MASK;\n\t\tregval |= tap_delay << PHY_CTRL_OTAPDLY_SEL_SHIFT;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops versal_net_sdcardclk_ops = {\n\t.recalc_rate = sdhci_arasan_sdcardclk_recalc_rate,\n\t.set_phase = sdhci_versal_net_emmc_sdcardclk_set_phase,\n};\n\nstatic int sdhci_versal_net_emmc_sampleclk_set_phase(struct clk_hw *hw, int degrees)\n{\n\tstruct sdhci_arasan_clk_data *clk_data =\n\t\tcontainer_of(hw, struct sdhci_arasan_clk_data, sampleclk_hw);\n\tstruct sdhci_arasan_data *sdhci_arasan =\n\t\tcontainer_of(clk_data, struct sdhci_arasan_data, clk_data);\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tu8 tap_delay, tap_max = 0;\n\tu32 regval;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\ttap_max = 32;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\t \n\t\tregval = sdhci_readl(host, PHY_CTRL_REG1);\n\t\tregval &= ~PHY_CTRL_STRB_SEL_MASK;\n\t\tregval |= VERSAL_NET_PHY_CTRL_STRB90_STRB180_VAL << PHY_CTRL_STRB_SEL_SHIFT;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\ttap_delay = (degrees * tap_max) / 360;\n\n\t \n\tif (tap_delay) {\n\t\tregval = sdhci_readl(host, PHY_CTRL_REG1);\n\t\tregval |= PHY_CTRL_ITAP_CHG_WIN_MASK;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t\tregval |= PHY_CTRL_ITAPDLY_ENA_MASK;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t\tregval &= ~PHY_CTRL_ITAPDLY_SEL_MASK;\n\t\tregval |= tap_delay << PHY_CTRL_ITAPDLY_SEL_SHIFT;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t\tregval &= ~PHY_CTRL_ITAP_CHG_WIN_MASK;\n\t\tsdhci_writel(host, regval, PHY_CTRL_REG1);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct clk_ops versal_net_sampleclk_ops = {\n\t.recalc_rate = sdhci_arasan_sampleclk_recalc_rate,\n\t.set_phase = sdhci_versal_net_emmc_sampleclk_set_phase,\n};\n\nstatic void arasan_zynqmp_dll_reset(struct sdhci_host *host, u32 deviceid)\n{\n\tu16 clk;\n\n\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tclk &= ~(SDHCI_CLOCK_CARD_EN | SDHCI_CLOCK_INT_EN);\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\t \n\tzynqmp_pm_sd_dll_reset(deviceid, PM_DLL_RESET_PULSE);\n\n\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\n\tsdhci_enable_clk(host, clk);\n}\n\nstatic int arasan_zynqmp_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tstruct clk_hw *hw = &sdhci_arasan->clk_data.sdcardclk_hw;\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 device_id = !strcmp(clk_name, \"clk_out_sd0\") ? NODE_SD_0 :\n\t\t\t\t\t\t\t   NODE_SD_1;\n\tint err;\n\n\t \n\tif (mmc->ios.timing == MMC_TIMING_UHS_DDR50)\n\t\treturn 0;\n\n\tarasan_zynqmp_dll_reset(host, device_id);\n\n\terr = sdhci_execute_tuning(mmc, opcode);\n\tif (err)\n\t\treturn err;\n\n\tarasan_zynqmp_dll_reset(host, device_id);\n\n\treturn 0;\n}\n\n \nstatic void sdhci_arasan_update_clockmultiplier(struct sdhci_host *host,\n\t\t\t\t\t\tu32 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_arasan_soc_ctl_map *soc_ctl_map =\n\t\tsdhci_arasan->soc_ctl_map;\n\n\t \n\tif (!soc_ctl_map)\n\t\treturn;\n\n\t \n\tif (!sdhci_arasan->soc_ctl_base) {\n\t\tpr_warn(\"%s: Have regmap, but no soc-ctl-syscon\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t\treturn;\n\t}\n\n\tsdhci_arasan_syscon_write(host, &soc_ctl_map->clockmultiplier, value);\n}\n\n \nstatic void sdhci_arasan_update_baseclkfreq(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_arasan_soc_ctl_map *soc_ctl_map =\n\t\tsdhci_arasan->soc_ctl_map;\n\tu32 mhz = DIV_ROUND_CLOSEST_ULL(clk_get_rate(pltfm_host->clk), 1000000);\n\n\t \n\tif (!soc_ctl_map)\n\t\treturn;\n\n\t \n\tif (!sdhci_arasan->soc_ctl_base) {\n\t\tpr_warn(\"%s: Have regmap, but no soc-ctl-syscon\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t\treturn;\n\t}\n\n\tsdhci_arasan_syscon_write(host, &soc_ctl_map->baseclkfreq, mhz);\n}\n\nstatic void sdhci_arasan_set_clk_delays(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tstruct sdhci_arasan_clk_data *clk_data = &sdhci_arasan->clk_data;\n\n\tclk_set_phase(clk_data->sampleclk,\n\t\t      clk_data->clk_phase_in[host->timing]);\n\tclk_set_phase(clk_data->sdcardclk,\n\t\t      clk_data->clk_phase_out[host->timing]);\n}\n\nstatic void arasan_dt_read_clk_phase(struct device *dev,\n\t\t\t\t     struct sdhci_arasan_clk_data *clk_data,\n\t\t\t\t     unsigned int timing, const char *prop)\n{\n\tstruct device_node *np = dev->of_node;\n\n\tu32 clk_phase[2] = {0};\n\tint ret;\n\n\t \n\tret = of_property_read_variable_u32_array(np, prop, &clk_phase[0],\n\t\t\t\t\t\t  2, 0);\n\tif (ret < 0) {\n\t\tdev_dbg(dev, \"Using predefined clock phase for %s = %d %d\\n\",\n\t\t\tprop, clk_data->clk_phase_in[timing],\n\t\t\tclk_data->clk_phase_out[timing]);\n\t\treturn;\n\t}\n\n\t \n\tclk_data->clk_phase_in[timing] = clk_phase[0];\n\tclk_data->clk_phase_out[timing] = clk_phase[1];\n}\n\n \nstatic void arasan_dt_parse_clk_phases(struct device *dev,\n\t\t\t\t       struct sdhci_arasan_clk_data *clk_data)\n{\n\tu32 mio_bank = 0;\n\tint i;\n\n\t \n\tclk_data->set_clk_delays = sdhci_arasan_set_clk_delays;\n\n\tif (of_device_is_compatible(dev->of_node, \"xlnx,zynqmp-8.9a\")) {\n\t\tu32 zynqmp_iclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tZYNQMP_ICLK_PHASE;\n\t\tu32 zynqmp_oclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tZYNQMP_OCLK_PHASE;\n\n\t\tof_property_read_u32(dev->of_node, \"xlnx,mio-bank\", &mio_bank);\n\t\tif (mio_bank == 2) {\n\t\t\tzynqmp_oclk_phase[MMC_TIMING_UHS_SDR104] = 90;\n\t\t\tzynqmp_oclk_phase[MMC_TIMING_MMC_HS200] = 90;\n\t\t}\n\n\t\tfor (i = 0; i <= MMC_TIMING_MMC_HS400; i++) {\n\t\t\tclk_data->clk_phase_in[i] = zynqmp_iclk_phase[i];\n\t\t\tclk_data->clk_phase_out[i] = zynqmp_oclk_phase[i];\n\t\t}\n\t}\n\n\tif (of_device_is_compatible(dev->of_node, \"xlnx,versal-8.9a\")) {\n\t\tu32 versal_iclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tVERSAL_ICLK_PHASE;\n\t\tu32 versal_oclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tVERSAL_OCLK_PHASE;\n\n\t\tfor (i = 0; i <= MMC_TIMING_MMC_HS400; i++) {\n\t\t\tclk_data->clk_phase_in[i] = versal_iclk_phase[i];\n\t\t\tclk_data->clk_phase_out[i] = versal_oclk_phase[i];\n\t\t}\n\t}\n\tif (of_device_is_compatible(dev->of_node, \"xlnx,versal-net-emmc\")) {\n\t\tu32 versal_net_iclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tVERSAL_NET_EMMC_ICLK_PHASE;\n\t\tu32 versal_net_oclk_phase[MMC_TIMING_MMC_HS400 + 1] =\n\t\t\tVERSAL_NET_EMMC_OCLK_PHASE;\n\n\t\tfor (i = 0; i <= MMC_TIMING_MMC_HS400; i++) {\n\t\t\tclk_data->clk_phase_in[i] = versal_net_iclk_phase[i];\n\t\t\tclk_data->clk_phase_out[i] = versal_net_oclk_phase[i];\n\t\t}\n\t}\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_LEGACY,\n\t\t\t\t \"clk-phase-legacy\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS,\n\t\t\t\t \"clk-phase-mmc-hs\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_SD_HS,\n\t\t\t\t \"clk-phase-sd-hs\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR12,\n\t\t\t\t \"clk-phase-uhs-sdr12\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR25,\n\t\t\t\t \"clk-phase-uhs-sdr25\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR50,\n\t\t\t\t \"clk-phase-uhs-sdr50\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_SDR104,\n\t\t\t\t \"clk-phase-uhs-sdr104\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_UHS_DDR50,\n\t\t\t\t \"clk-phase-uhs-ddr50\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_DDR52,\n\t\t\t\t \"clk-phase-mmc-ddr52\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS200,\n\t\t\t\t \"clk-phase-mmc-hs200\");\n\tarasan_dt_read_clk_phase(dev, clk_data, MMC_TIMING_MMC_HS400,\n\t\t\t\t \"clk-phase-mmc-hs400\");\n}\n\nstatic const struct sdhci_pltfm_data sdhci_arasan_pdata = {\n\t.ops = &sdhci_arasan_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\t\tSDHCI_QUIRK2_STOP_WITH_TC,\n};\n\nstatic const struct sdhci_arasan_clk_ops arasan_clk_ops = {\n\t.sdcardclk_ops = &arasan_sdcardclk_ops,\n\t.sampleclk_ops = &arasan_sampleclk_ops,\n};\n\nstatic struct sdhci_arasan_of_data sdhci_arasan_generic_data = {\n\t.pdata = &sdhci_arasan_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_keembay_emmc_pdata = {\n\t.ops = &sdhci_arasan_cqe_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\tSDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\tSDHCI_QUIRK_NO_LED |\n\t\tSDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\tSDHCI_QUIRK_32BIT_DMA_SIZE |\n\t\tSDHCI_QUIRK_32BIT_ADMA_SIZE,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\tSDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |\n\t\tSDHCI_QUIRK2_STOP_WITH_TC |\n\t\tSDHCI_QUIRK2_BROKEN_64_BIT_DMA,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_keembay_sd_pdata = {\n\t.ops = &sdhci_arasan_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\tSDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\tSDHCI_QUIRK_NO_LED |\n\t\tSDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\tSDHCI_QUIRK_32BIT_DMA_SIZE |\n\t\tSDHCI_QUIRK_32BIT_ADMA_SIZE,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\tSDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON |\n\t\tSDHCI_QUIRK2_STOP_WITH_TC |\n\t\tSDHCI_QUIRK2_BROKEN_64_BIT_DMA,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_keembay_sdio_pdata = {\n\t.ops = &sdhci_arasan_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\tSDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\tSDHCI_QUIRK_NO_LED |\n\t\tSDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\tSDHCI_QUIRK_32BIT_DMA_SIZE |\n\t\tSDHCI_QUIRK_32BIT_ADMA_SIZE,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\tSDHCI_QUIRK2_HOST_OFF_CARD_ON |\n\t\tSDHCI_QUIRK2_BROKEN_64_BIT_DMA,\n};\n\nstatic struct sdhci_arasan_of_data sdhci_arasan_rk3399_data = {\n\t.soc_ctl_map = &rk3399_soc_ctl_map,\n\t.pdata = &sdhci_arasan_cqe_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic struct sdhci_arasan_of_data intel_lgm_emmc_data = {\n\t.soc_ctl_map = &intel_lgm_emmc_soc_ctl_map,\n\t.pdata = &sdhci_arasan_cqe_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic struct sdhci_arasan_of_data intel_lgm_sdxc_data = {\n\t.soc_ctl_map = &intel_lgm_sdxc_soc_ctl_map,\n\t.pdata = &sdhci_arasan_cqe_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_arasan_zynqmp_pdata = {\n\t.ops = &sdhci_arasan_ops,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\t\tSDHCI_QUIRK2_STOP_WITH_TC,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_arasan_versal_net_pdata = {\n\t.ops = &sdhci_arasan_ops,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\tSDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN |\n\t\t\tSDHCI_QUIRK2_STOP_WITH_TC |\n\t\t\tSDHCI_QUIRK2_CAPS_BIT63_FOR_HS400,\n};\n\nstatic const struct sdhci_arasan_clk_ops zynqmp_clk_ops = {\n\t.sdcardclk_ops = &zynqmp_sdcardclk_ops,\n\t.sampleclk_ops = &zynqmp_sampleclk_ops,\n};\n\nstatic struct sdhci_arasan_of_data sdhci_arasan_zynqmp_data = {\n\t.pdata = &sdhci_arasan_zynqmp_pdata,\n\t.clk_ops = &zynqmp_clk_ops,\n};\n\nstatic const struct sdhci_arasan_clk_ops versal_clk_ops = {\n\t.sdcardclk_ops = &versal_sdcardclk_ops,\n\t.sampleclk_ops = &versal_sampleclk_ops,\n};\n\nstatic struct sdhci_arasan_of_data sdhci_arasan_versal_data = {\n\t.pdata = &sdhci_arasan_zynqmp_pdata,\n\t.clk_ops = &versal_clk_ops,\n};\n\nstatic const struct sdhci_arasan_clk_ops versal_net_clk_ops = {\n\t.sdcardclk_ops = &versal_net_sdcardclk_ops,\n\t.sampleclk_ops = &versal_net_sampleclk_ops,\n};\n\nstatic struct sdhci_arasan_of_data sdhci_arasan_versal_net_data = {\n\t.pdata = &sdhci_arasan_versal_net_pdata,\n\t.clk_ops = &versal_net_clk_ops,\n};\n\nstatic struct sdhci_arasan_of_data intel_keembay_emmc_data = {\n\t.soc_ctl_map = &intel_keembay_soc_ctl_map,\n\t.pdata = &sdhci_keembay_emmc_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic struct sdhci_arasan_of_data intel_keembay_sd_data = {\n\t.soc_ctl_map = &intel_keembay_soc_ctl_map,\n\t.pdata = &sdhci_keembay_sd_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic struct sdhci_arasan_of_data intel_keembay_sdio_data = {\n\t.soc_ctl_map = &intel_keembay_soc_ctl_map,\n\t.pdata = &sdhci_keembay_sdio_pdata,\n\t.clk_ops = &arasan_clk_ops,\n};\n\nstatic const struct of_device_id sdhci_arasan_of_match[] = {\n\t \n\t{\n\t\t.compatible = \"rockchip,rk3399-sdhci-5.1\",\n\t\t.data = &sdhci_arasan_rk3399_data,\n\t},\n\t{\n\t\t.compatible = \"intel,lgm-sdhci-5.1-emmc\",\n\t\t.data = &intel_lgm_emmc_data,\n\t},\n\t{\n\t\t.compatible = \"intel,lgm-sdhci-5.1-sdxc\",\n\t\t.data = &intel_lgm_sdxc_data,\n\t},\n\t{\n\t\t.compatible = \"intel,keembay-sdhci-5.1-emmc\",\n\t\t.data = &intel_keembay_emmc_data,\n\t},\n\t{\n\t\t.compatible = \"intel,keembay-sdhci-5.1-sd\",\n\t\t.data = &intel_keembay_sd_data,\n\t},\n\t{\n\t\t.compatible = \"intel,keembay-sdhci-5.1-sdio\",\n\t\t.data = &intel_keembay_sdio_data,\n\t},\n\t \n\t{\n\t\t.compatible = \"arasan,sdhci-8.9a\",\n\t\t.data = &sdhci_arasan_generic_data,\n\t},\n\t{\n\t\t.compatible = \"arasan,sdhci-5.1\",\n\t\t.data = &sdhci_arasan_generic_data,\n\t},\n\t{\n\t\t.compatible = \"arasan,sdhci-4.9a\",\n\t\t.data = &sdhci_arasan_generic_data,\n\t},\n\t{\n\t\t.compatible = \"xlnx,zynqmp-8.9a\",\n\t\t.data = &sdhci_arasan_zynqmp_data,\n\t},\n\t{\n\t\t.compatible = \"xlnx,versal-8.9a\",\n\t\t.data = &sdhci_arasan_versal_data,\n\t},\n\t{\n\t\t.compatible = \"xlnx,versal-net-emmc\",\n\t\t.data = &sdhci_arasan_versal_net_data,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sdhci_arasan_of_match);\n\n \nstatic int\nsdhci_arasan_register_sdcardclk(struct sdhci_arasan_data *sdhci_arasan,\n\t\t\t\tstruct clk *clk_xin,\n\t\t\t\tstruct device *dev)\n{\n\tstruct sdhci_arasan_clk_data *clk_data = &sdhci_arasan->clk_data;\n\tstruct device_node *np = dev->of_node;\n\tstruct clk_init_data sdcardclk_init;\n\tconst char *parent_clk_name;\n\tint ret;\n\n\tret = of_property_read_string_index(np, \"clock-output-names\", 0,\n\t\t\t\t\t    &sdcardclk_init.name);\n\tif (ret) {\n\t\tdev_err(dev, \"DT has #clock-cells but no clock-output-names\\n\");\n\t\treturn ret;\n\t}\n\n\tparent_clk_name = __clk_get_name(clk_xin);\n\tsdcardclk_init.parent_names = &parent_clk_name;\n\tsdcardclk_init.num_parents = 1;\n\tsdcardclk_init.flags = CLK_GET_RATE_NOCACHE;\n\tsdcardclk_init.ops = sdhci_arasan->clk_ops->sdcardclk_ops;\n\n\tclk_data->sdcardclk_hw.init = &sdcardclk_init;\n\tclk_data->sdcardclk =\n\t\tdevm_clk_register(dev, &clk_data->sdcardclk_hw);\n\tif (IS_ERR(clk_data->sdcardclk))\n\t\treturn PTR_ERR(clk_data->sdcardclk);\n\tclk_data->sdcardclk_hw.init = NULL;\n\n\tret = of_clk_add_provider(np, of_clk_src_simple_get,\n\t\t\t\t  clk_data->sdcardclk);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add sdcard clock provider\\n\");\n\n\treturn ret;\n}\n\n \nstatic int\nsdhci_arasan_register_sampleclk(struct sdhci_arasan_data *sdhci_arasan,\n\t\t\t\tstruct clk *clk_xin,\n\t\t\t\tstruct device *dev)\n{\n\tstruct sdhci_arasan_clk_data *clk_data = &sdhci_arasan->clk_data;\n\tstruct device_node *np = dev->of_node;\n\tstruct clk_init_data sampleclk_init;\n\tconst char *parent_clk_name;\n\tint ret;\n\n\tret = of_property_read_string_index(np, \"clock-output-names\", 1,\n\t\t\t\t\t    &sampleclk_init.name);\n\tif (ret) {\n\t\tdev_err(dev, \"DT has #clock-cells but no clock-output-names\\n\");\n\t\treturn ret;\n\t}\n\n\tparent_clk_name = __clk_get_name(clk_xin);\n\tsampleclk_init.parent_names = &parent_clk_name;\n\tsampleclk_init.num_parents = 1;\n\tsampleclk_init.flags = CLK_GET_RATE_NOCACHE;\n\tsampleclk_init.ops = sdhci_arasan->clk_ops->sampleclk_ops;\n\n\tclk_data->sampleclk_hw.init = &sampleclk_init;\n\tclk_data->sampleclk =\n\t\tdevm_clk_register(dev, &clk_data->sampleclk_hw);\n\tif (IS_ERR(clk_data->sampleclk))\n\t\treturn PTR_ERR(clk_data->sampleclk);\n\tclk_data->sampleclk_hw.init = NULL;\n\n\tret = of_clk_add_provider(np, of_clk_src_simple_get,\n\t\t\t\t  clk_data->sampleclk);\n\tif (ret)\n\t\tdev_err(dev, \"Failed to add sample clock provider\\n\");\n\n\treturn ret;\n}\n\n \nstatic void sdhci_arasan_unregister_sdclk(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\n\tif (!of_property_present(np, \"#clock-cells\"))\n\t\treturn;\n\n\tof_clk_del_provider(dev->of_node);\n}\n\n \nstatic void sdhci_arasan_update_support64b(struct sdhci_host *host, u32 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_arasan_soc_ctl_map *soc_ctl_map;\n\n\t \n\tsoc_ctl_map = sdhci_arasan->soc_ctl_map;\n\tif (!soc_ctl_map)\n\t\treturn;\n\n\t \n\tif (!sdhci_arasan->soc_ctl_base) {\n\t\tpr_warn(\"%s: Have regmap, but no soc-ctl-syscon\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\t\treturn;\n\t}\n\n\tsdhci_arasan_syscon_write(host, &soc_ctl_map->support64b, value);\n}\n\n \nstatic int sdhci_arasan_register_sdclk(struct sdhci_arasan_data *sdhci_arasan,\n\t\t\t\t       struct clk *clk_xin,\n\t\t\t\t       struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tu32 num_clks = 0;\n\tint ret;\n\n\t \n\tif (of_property_read_u32(np, \"#clock-cells\", &num_clks) < 0)\n\t\treturn 0;\n\n\tret = sdhci_arasan_register_sdcardclk(sdhci_arasan, clk_xin, dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (num_clks) {\n\t\tret = sdhci_arasan_register_sampleclk(sdhci_arasan, clk_xin,\n\t\t\t\t\t\t      dev);\n\t\tif (ret) {\n\t\t\tsdhci_arasan_unregister_sdclk(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_zynqmp_set_dynamic_config(struct device *dev,\n\t\t\t\t\t   struct sdhci_arasan_data *sdhci_arasan)\n{\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tstruct clk_hw *hw = &sdhci_arasan->clk_data.sdcardclk_hw;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tconst char *clk_name = clk_hw_get_name(hw);\n\tu32 mhz, node_id = !strcmp(clk_name, \"clk_out_sd0\") ? NODE_SD_0 : NODE_SD_1;\n\tstruct reset_control *rstc;\n\tint ret;\n\n\t \n\trstc = devm_reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(rstc)) {\n\t\tdev_err(dev, \"Cannot get SDHC reset.\\n\");\n\t\treturn PTR_ERR(rstc);\n\t}\n\n\tret = reset_control_assert(rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_pm_set_sd_config(node_id, SD_CONFIG_FIXED, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_pm_set_sd_config(node_id, SD_CONFIG_EMMC_SEL,\n\t\t\t\t      !!(host->mmc->caps & MMC_CAP_NONREMOVABLE));\n\tif (ret)\n\t\treturn ret;\n\n\tmhz = DIV_ROUND_CLOSEST_ULL(clk_get_rate(pltfm_host->clk), 1000000);\n\tif (mhz > 100 && mhz <= 200)\n\t\tmhz = 200;\n\telse if (mhz > 50 && mhz <= 100)\n\t\tmhz = 100;\n\telse if (mhz > 25 && mhz <= 50)\n\t\tmhz = 50;\n\telse\n\t\tmhz = 25;\n\n\tret = zynqmp_pm_set_sd_config(node_id, SD_CONFIG_BASECLK, mhz);\n\tif (ret)\n\t\treturn ret;\n\n\tret = zynqmp_pm_set_sd_config(node_id, SD_CONFIG_8BIT,\n\t\t\t\t      !!(host->mmc->caps & MMC_CAP_8_BIT_DATA));\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(rstc);\n\tif (ret)\n\t\treturn ret;\n\n\tusleep_range(1000, 1500);\n\n\treturn 0;\n}\n\nstatic int sdhci_arasan_add_host(struct sdhci_arasan_data *sdhci_arasan)\n{\n\tstruct sdhci_host *host = sdhci_arasan->host;\n\tstruct cqhci_host *cq_host;\n\tbool dma64;\n\tint ret;\n\n\tif (!sdhci_arasan->has_cqe)\n\t\treturn sdhci_add_host(host);\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tcq_host = devm_kzalloc(host->mmc->parent,\n\t\t\t       sizeof(*cq_host), GFP_KERNEL);\n\tif (!cq_host) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tcq_host->mmio = host->ioaddr + SDHCI_ARASAN_CQE_BASE_ADDR;\n\tcq_host->ops = &sdhci_arasan_cqhci_ops;\n\n\tdma64 = host->flags & SDHCI_USE_64_BIT_DMA;\n\tif (dma64)\n\t\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\n\tret = cqhci_init(cq_host, host->mmc, dma64);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\nstatic int sdhci_arasan_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tstruct device_node *node;\n\tstruct clk *clk_xin;\n\tstruct clk *clk_dll;\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct sdhci_arasan_data *sdhci_arasan;\n\tconst struct sdhci_arasan_of_data *data;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -EINVAL;\n\n\thost = sdhci_pltfm_init(pdev, data->pdata, sizeof(*sdhci_arasan));\n\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tsdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tsdhci_arasan->host = host;\n\n\tsdhci_arasan->soc_ctl_map = data->soc_ctl_map;\n\tsdhci_arasan->clk_ops = data->clk_ops;\n\n\tnode = of_parse_phandle(np, \"arasan,soc-ctl-syscon\", 0);\n\tif (node) {\n\t\tsdhci_arasan->soc_ctl_base = syscon_node_to_regmap(node);\n\t\tof_node_put(node);\n\n\t\tif (IS_ERR(sdhci_arasan->soc_ctl_base)) {\n\t\t\tret = dev_err_probe(dev,\n\t\t\t\t\t    PTR_ERR(sdhci_arasan->soc_ctl_base),\n\t\t\t\t\t    \"Can't get syscon\\n\");\n\t\t\tgoto err_pltfm_free;\n\t\t}\n\t}\n\n\tsdhci_get_of_property(pdev);\n\n\tsdhci_arasan->clk_ahb = devm_clk_get(dev, \"clk_ahb\");\n\tif (IS_ERR(sdhci_arasan->clk_ahb)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(sdhci_arasan->clk_ahb),\n\t\t\t\t    \"clk_ahb clock not found.\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\tclk_xin = devm_clk_get(dev, \"clk_xin\");\n\tif (IS_ERR(clk_xin)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(clk_xin), \"clk_xin clock not found.\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = clk_prepare_enable(sdhci_arasan->clk_ahb);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable AHB clock.\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\t \n\tif (pltfm_host->clock &&\n\t    pltfm_host->clock != clk_get_rate(clk_xin)) {\n\t\tret = clk_set_rate(clk_xin, pltfm_host->clock);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Failed to set SD clock rate\\n\");\n\t\t\tgoto clk_dis_ahb;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(clk_xin);\n\tif (ret) {\n\t\tdev_err(dev, \"Unable to enable SD clock.\\n\");\n\t\tgoto clk_dis_ahb;\n\t}\n\n\tclk_dll = devm_clk_get_optional_enabled(dev, \"gate\");\n\tif (IS_ERR(clk_dll)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(clk_dll), \"failed to get dll clk\\n\");\n\t\tgoto clk_disable_all;\n\t}\n\n\tif (of_property_read_bool(np, \"xlnx,fails-without-test-cd\"))\n\t\tsdhci_arasan->quirks |= SDHCI_ARASAN_QUIRK_FORCE_CDTEST;\n\n\tif (of_property_read_bool(np, \"xlnx,int-clock-stable-broken\"))\n\t\tsdhci_arasan->quirks |= SDHCI_ARASAN_QUIRK_CLOCK_UNSTABLE;\n\n\tpltfm_host->clk = clk_xin;\n\n\tif (of_device_is_compatible(np, \"rockchip,rk3399-sdhci-5.1\"))\n\t\tsdhci_arasan_update_clockmultiplier(host, 0x0);\n\n\tif (of_device_is_compatible(np, \"intel,keembay-sdhci-5.1-emmc\") ||\n\t    of_device_is_compatible(np, \"intel,keembay-sdhci-5.1-sd\") ||\n\t    of_device_is_compatible(np, \"intel,keembay-sdhci-5.1-sdio\")) {\n\t\tsdhci_arasan_update_clockmultiplier(host, 0x0);\n\t\tsdhci_arasan_update_support64b(host, 0x0);\n\n\t\thost->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\n\t}\n\n\tsdhci_arasan_update_baseclkfreq(host);\n\n\tret = sdhci_arasan_register_sdclk(sdhci_arasan, clk_xin, dev);\n\tif (ret)\n\t\tgoto clk_disable_all;\n\n\tif (of_device_is_compatible(np, \"xlnx,zynqmp-8.9a\")) {\n\t\thost->mmc_host_ops.execute_tuning =\n\t\t\tarasan_zynqmp_execute_tuning;\n\n\t\tsdhci_arasan->quirks |= SDHCI_ARASAN_QUIRK_CLOCK_25_BROKEN;\n\t\thost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\n\t}\n\n\tarasan_dt_parse_clk_phases(dev, &sdhci_arasan->clk_data);\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret) {\n\t\tret = dev_err_probe(dev, ret, \"parsing dt failed.\\n\");\n\t\tgoto unreg_clk;\n\t}\n\n\tif (of_device_is_compatible(np, \"xlnx,zynqmp-8.9a\")) {\n\t\tret = zynqmp_pm_is_function_supported(PM_IOCTL, IOCTL_SET_SD_CONFIG);\n\t\tif (!ret) {\n\t\t\tret = sdhci_zynqmp_set_dynamic_config(dev, sdhci_arasan);\n\t\t\tif (ret)\n\t\t\t\tgoto unreg_clk;\n\t\t}\n\t}\n\n\tsdhci_arasan->phy = ERR_PTR(-ENODEV);\n\tif (of_device_is_compatible(np, \"arasan,sdhci-5.1\")) {\n\t\tsdhci_arasan->phy = devm_phy_get(dev, \"phy_arasan\");\n\t\tif (IS_ERR(sdhci_arasan->phy)) {\n\t\t\tret = dev_err_probe(dev, PTR_ERR(sdhci_arasan->phy),\n\t\t\t\t\t    \"No phy for arasan,sdhci-5.1.\\n\");\n\t\t\tgoto unreg_clk;\n\t\t}\n\n\t\tret = phy_init(sdhci_arasan->phy);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"phy_init err.\\n\");\n\t\t\tgoto unreg_clk;\n\t\t}\n\n\t\thost->mmc_host_ops.hs400_enhanced_strobe =\n\t\t\t\t\tsdhci_arasan_hs400_enhanced_strobe;\n\t\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\t\t\t\tsdhci_arasan_voltage_switch;\n\t\tsdhci_arasan->has_cqe = true;\n\t\thost->mmc->caps2 |= MMC_CAP2_CQE;\n\n\t\tif (!of_property_read_bool(np, \"disable-cqe-dcmd\"))\n\t\t\thost->mmc->caps2 |= MMC_CAP2_CQE_DCMD;\n\t}\n\n\tif (of_device_is_compatible(np, \"xlnx,versal-net-emmc\"))\n\t\tsdhci_arasan->internal_phy_reg = true;\n\n\tret = sdhci_arasan_add_host(sdhci_arasan);\n\tif (ret)\n\t\tgoto err_add_host;\n\n\treturn 0;\n\nerr_add_host:\n\tif (!IS_ERR(sdhci_arasan->phy))\n\t\tphy_exit(sdhci_arasan->phy);\nunreg_clk:\n\tsdhci_arasan_unregister_sdclk(dev);\nclk_disable_all:\n\tclk_disable_unprepare(clk_xin);\nclk_dis_ahb:\n\tclk_disable_unprepare(sdhci_arasan->clk_ahb);\nerr_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_arasan_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);\n\tstruct clk *clk_ahb = sdhci_arasan->clk_ahb;\n\tstruct clk *clk_xin = pltfm_host->clk;\n\n\tif (!IS_ERR(sdhci_arasan->phy)) {\n\t\tif (sdhci_arasan->is_phy_on)\n\t\t\tphy_power_off(sdhci_arasan->phy);\n\t\tphy_exit(sdhci_arasan->phy);\n\t}\n\n\tsdhci_arasan_unregister_sdclk(&pdev->dev);\n\n\tsdhci_pltfm_remove(pdev);\n\n\tclk_disable_unprepare(clk_xin);\n\tclk_disable_unprepare(clk_ahb);\n}\n\nstatic struct platform_driver sdhci_arasan_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-arasan\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_arasan_of_match,\n\t\t.pm = &sdhci_arasan_dev_pm_ops,\n\t},\n\t.probe = sdhci_arasan_probe,\n\t.remove_new = sdhci_arasan_remove,\n};\n\nmodule_platform_driver(sdhci_arasan_driver);\n\nMODULE_DESCRIPTION(\"Driver for the Arasan SDHCI Controller\");\nMODULE_AUTHOR(\"Soeren Brinkmann <soren.brinkmann@xilinx.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}