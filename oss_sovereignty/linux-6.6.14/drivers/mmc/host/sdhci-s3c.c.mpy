{
  "module_name": "sdhci-s3c.c",
  "hash_id": "9529e47757021bb9113661f23b00c1edff2275f28fe48277119a8c0370d5b1d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-s3c.c",
  "human_readable_source": "\n \n\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/mmc-sdhci-s3c.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include <linux/mmc/host.h>\n\n#include \"sdhci.h\"\n\n#define MAX_BUS_CLK\t(4)\n\n#define S3C_SDHCI_CONTROL2\t\t\t(0x80)\n#define S3C_SDHCI_CONTROL3\t\t\t(0x84)\n#define S3C64XX_SDHCI_CONTROL4\t\t\t(0x8C)\n\n#define S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR\tBIT(31)\n#define S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK\t\tBIT(30)\n#define S3C_SDHCI_CTRL2_CDINVRXD3\t\tBIT(29)\n#define S3C_SDHCI_CTRL2_SLCARDOUT\t\tBIT(28)\n\n#define S3C_SDHCI_CTRL2_FLTCLKSEL_MASK\t\t(0xf << 24)\n#define S3C_SDHCI_CTRL2_FLTCLKSEL_SHIFT\t\t(24)\n#define S3C_SDHCI_CTRL2_FLTCLKSEL(_x)\t\t((_x) << 24)\n\n#define S3C_SDHCI_CTRL2_LVLDAT_MASK\t\t(0xff << 16)\n#define S3C_SDHCI_CTRL2_LVLDAT_SHIFT\t\t(16)\n#define S3C_SDHCI_CTRL2_LVLDAT(_x)\t\t((_x) << 16)\n\n#define S3C_SDHCI_CTRL2_ENFBCLKTX\t\tBIT(15)\n#define S3C_SDHCI_CTRL2_ENFBCLKRX\t\tBIT(14)\n#define S3C_SDHCI_CTRL2_SDCDSEL\t\t\tBIT(13)\n#define S3C_SDHCI_CTRL2_SDSIGPC\t\t\tBIT(12)\n#define S3C_SDHCI_CTRL2_ENBUSYCHKTXSTART\tBIT(11)\n\n#define S3C_SDHCI_CTRL2_DFCNT_MASK\t\t(0x3 << 9)\n#define S3C_SDHCI_CTRL2_DFCNT_SHIFT\t\t(9)\n#define S3C_SDHCI_CTRL2_DFCNT_NONE\t\t(0x0 << 9)\n#define S3C_SDHCI_CTRL2_DFCNT_4SDCLK\t\t(0x1 << 9)\n#define S3C_SDHCI_CTRL2_DFCNT_16SDCLK\t\t(0x2 << 9)\n#define S3C_SDHCI_CTRL2_DFCNT_64SDCLK\t\t(0x3 << 9)\n\n#define S3C_SDHCI_CTRL2_ENCLKOUTHOLD\t\tBIT(8)\n#define S3C_SDHCI_CTRL2_RWAITMODE\t\tBIT(7)\n#define S3C_SDHCI_CTRL2_DISBUFRD\t\tBIT(6)\n\n#define S3C_SDHCI_CTRL2_SELBASECLK_MASK\t\t(0x3 << 4)\n#define S3C_SDHCI_CTRL2_SELBASECLK_SHIFT\t(4)\n#define S3C_SDHCI_CTRL2_PWRSYNC\t\t\tBIT(3)\n#define S3C_SDHCI_CTRL2_ENCLKOUTMSKCON\t\tBIT(1)\n#define S3C_SDHCI_CTRL2_HWINITFIN\t\tBIT(0)\n\n#define S3C_SDHCI_CTRL3_FCSEL3\t\t\tBIT(31)\n#define S3C_SDHCI_CTRL3_FCSEL2\t\t\tBIT(23)\n#define S3C_SDHCI_CTRL3_FCSEL1\t\t\tBIT(15)\n#define S3C_SDHCI_CTRL3_FCSEL0\t\t\tBIT(7)\n\n#define S3C_SDHCI_CTRL3_FIA3_MASK\t\t(0x7f << 24)\n#define S3C_SDHCI_CTRL3_FIA3_SHIFT\t\t(24)\n#define S3C_SDHCI_CTRL3_FIA3(_x)\t\t((_x) << 24)\n\n#define S3C_SDHCI_CTRL3_FIA2_MASK\t\t(0x7f << 16)\n#define S3C_SDHCI_CTRL3_FIA2_SHIFT\t\t(16)\n#define S3C_SDHCI_CTRL3_FIA2(_x)\t\t((_x) << 16)\n\n#define S3C_SDHCI_CTRL3_FIA1_MASK\t\t(0x7f << 8)\n#define S3C_SDHCI_CTRL3_FIA1_SHIFT\t\t(8)\n#define S3C_SDHCI_CTRL3_FIA1(_x)\t\t((_x) << 8)\n\n#define S3C_SDHCI_CTRL3_FIA0_MASK\t\t(0x7f << 0)\n#define S3C_SDHCI_CTRL3_FIA0_SHIFT\t\t(0)\n#define S3C_SDHCI_CTRL3_FIA0(_x)\t\t((_x) << 0)\n\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_MASK\t(0x3 << 16)\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_SHIFT\t(16)\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_2mA\t(0x0 << 16)\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_4mA\t(0x1 << 16)\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_7mA\t(0x2 << 16)\n#define S3C64XX_SDHCI_CONTROL4_DRIVE_9mA\t(0x3 << 16)\n\n#define S3C64XX_SDHCI_CONTROL4_BUSY\t\t(1)\n\n \nstruct sdhci_s3c {\n\tstruct sdhci_host\t*host;\n\tstruct platform_device\t*pdev;\n\tstruct resource\t\t*ioarea;\n\tstruct s3c_sdhci_platdata *pdata;\n\tint\t\t\tcur_clk;\n\tint\t\t\text_cd_irq;\n\n\tstruct clk\t\t*clk_io;\n\tstruct clk\t\t*clk_bus[MAX_BUS_CLK];\n\tunsigned long\t\tclk_rates[MAX_BUS_CLK];\n\n\tbool\t\t\tno_divider;\n};\n\n \nstruct sdhci_s3c_drv_data {\n\tunsigned int\tsdhci_quirks;\n\tbool\t\tno_divider;\n};\n\nstatic inline struct sdhci_s3c *to_s3c(struct sdhci_host *host)\n{\n\treturn sdhci_priv(host);\n}\n\n \nstatic unsigned int sdhci_s3c_get_max_clk(struct sdhci_host *host)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tunsigned long rate, max = 0;\n\tint src;\n\n\tfor (src = 0; src < MAX_BUS_CLK; src++) {\n\t\trate = ourhost->clk_rates[src];\n\t\tif (rate > max)\n\t\t\tmax = rate;\n\t}\n\n\treturn max;\n}\n\n \nstatic unsigned int sdhci_s3c_consider_clock(struct sdhci_s3c *ourhost,\n\t\t\t\t\t     unsigned int src,\n\t\t\t\t\t     unsigned int wanted)\n{\n\tunsigned long rate;\n\tstruct clk *clksrc = ourhost->clk_bus[src];\n\tint shift;\n\n\tif (IS_ERR(clksrc))\n\t\treturn UINT_MAX;\n\n\t \n\tif (ourhost->no_divider) {\n\t\trate = clk_round_rate(clksrc, wanted);\n\t\treturn wanted - rate;\n\t}\n\n\trate = ourhost->clk_rates[src];\n\n\tfor (shift = 0; shift <= 8; ++shift) {\n\t\tif ((rate >> shift) <= wanted)\n\t\t\tbreak;\n\t}\n\n\tif (shift > 8) {\n\t\tdev_dbg(&ourhost->pdev->dev,\n\t\t\t\"clk %d: rate %ld, min rate %lu > wanted %u\\n\",\n\t\t\tsrc, rate, rate / 256, wanted);\n\t\treturn UINT_MAX;\n\t}\n\n\tdev_dbg(&ourhost->pdev->dev, \"clk %d: rate %ld, want %d, got %ld\\n\",\n\t\tsrc, rate, wanted, rate >> shift);\n\n\treturn wanted - (rate >> shift);\n}\n\n \nstatic void sdhci_s3c_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tunsigned int best = UINT_MAX;\n\tunsigned int delta;\n\tint best_src = 0;\n\tint src;\n\tu32 ctrl;\n\n\thost->mmc->actual_clock = 0;\n\n\t \n\tif (clock == 0) {\n\t\tsdhci_set_clock(host, clock);\n\t\treturn;\n\t}\n\n\tfor (src = 0; src < MAX_BUS_CLK; src++) {\n\t\tdelta = sdhci_s3c_consider_clock(ourhost, src, clock);\n\t\tif (delta < best) {\n\t\t\tbest = delta;\n\t\t\tbest_src = src;\n\t\t}\n\t}\n\n\tdev_dbg(&ourhost->pdev->dev,\n\t\t\"selected source %d, clock %d, delta %d\\n\",\n\t\t best_src, clock, best);\n\n\t \n\tif (ourhost->cur_clk != best_src) {\n\t\tstruct clk *clk = ourhost->clk_bus[best_src];\n\n\t\tclk_prepare_enable(clk);\n\t\tif (ourhost->cur_clk >= 0)\n\t\t\tclk_disable_unprepare(\n\t\t\t\t\tourhost->clk_bus[ourhost->cur_clk]);\n\n\t\tourhost->cur_clk = best_src;\n\t\thost->max_clk = ourhost->clk_rates[best_src];\n\t}\n\n\t \n\twritew(0, host->ioaddr + SDHCI_CLOCK_CONTROL);\n\n\tctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\n\tctrl &= ~S3C_SDHCI_CTRL2_SELBASECLK_MASK;\n\tctrl |= best_src << S3C_SDHCI_CTRL2_SELBASECLK_SHIFT;\n\twritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\n\n\t \n\twritel(S3C64XX_SDHCI_CONTROL4_DRIVE_9mA,\n\t\thost->ioaddr + S3C64XX_SDHCI_CONTROL4);\n\n\tctrl = readl(host->ioaddr + S3C_SDHCI_CONTROL2);\n\tctrl |= (S3C64XX_SDHCI_CTRL2_ENSTAASYNCCLR |\n\t\t  S3C64XX_SDHCI_CTRL2_ENCMDCNFMSK |\n\t\t  S3C_SDHCI_CTRL2_ENFBCLKRX |\n\t\t  S3C_SDHCI_CTRL2_DFCNT_NONE |\n\t\t  S3C_SDHCI_CTRL2_ENCLKOUTHOLD);\n\twritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL2);\n\n\t \n\tctrl = (S3C_SDHCI_CTRL3_FCSEL1 | S3C_SDHCI_CTRL3_FCSEL0);\n\tif (clock < 25 * 1000000)\n\t\tctrl |= (S3C_SDHCI_CTRL3_FCSEL3 | S3C_SDHCI_CTRL3_FCSEL2);\n\twritel(ctrl, host->ioaddr + S3C_SDHCI_CONTROL3);\n\n\tsdhci_set_clock(host, clock);\n}\n\n \nstatic unsigned int sdhci_s3c_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tunsigned long rate, min = ULONG_MAX;\n\tint src;\n\n\tfor (src = 0; src < MAX_BUS_CLK; src++) {\n\t\trate = ourhost->clk_rates[src] / 256;\n\t\tif (!rate)\n\t\t\tcontinue;\n\t\tif (rate < min)\n\t\t\tmin = rate;\n\t}\n\n\treturn min;\n}\n\n \nstatic unsigned int sdhci_cmu_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tunsigned long rate, max = 0;\n\tint src;\n\n\tfor (src = 0; src < MAX_BUS_CLK; src++) {\n\t\tstruct clk *clk;\n\n\t\tclk = ourhost->clk_bus[src];\n\t\tif (IS_ERR(clk))\n\t\t\tcontinue;\n\n\t\trate = clk_round_rate(clk, ULONG_MAX);\n\t\tif (rate > max)\n\t\t\tmax = rate;\n\t}\n\n\treturn max;\n}\n\n \nstatic unsigned int sdhci_cmu_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tunsigned long rate, min = ULONG_MAX;\n\tint src;\n\n\tfor (src = 0; src < MAX_BUS_CLK; src++) {\n\t\tstruct clk *clk;\n\n\t\tclk = ourhost->clk_bus[src];\n\t\tif (IS_ERR(clk))\n\t\t\tcontinue;\n\n\t\trate = clk_round_rate(clk, 0);\n\t\tif (rate < min)\n\t\t\tmin = rate;\n\t}\n\n\treturn min;\n}\n\n \nstatic void sdhci_cmu_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tstruct device *dev = &ourhost->pdev->dev;\n\tunsigned long timeout;\n\tu16 clk = 0;\n\tint ret;\n\n\thost->mmc->actual_clock = 0;\n\n\t \n\tif (clock == 0) {\n\t\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\t\treturn;\n\t}\n\n\tsdhci_s3c_set_clock(host, clock);\n\n\t \n\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tclk &= ~SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\tret = clk_set_rate(ourhost->clk_bus[ourhost->cur_clk], clock);\n\tif (ret != 0) {\n\t\tdev_err(dev, \"%s: failed to set clock rate %uHz\\n\",\n\t\t\tmmc_hostname(host->mmc), clock);\n\t\treturn;\n\t}\n\n\tclk = SDHCI_CLOCK_INT_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\t \n\ttimeout = 20;\n\twhile (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))\n\t\t& SDHCI_CLOCK_INT_STABLE)) {\n\t\tif (timeout == 0) {\n\t\t\tdev_err(dev, \"%s: Internal clock never stabilised.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\treturn;\n\t\t}\n\t\ttimeout--;\n\t\tmdelay(1);\n\t}\n\n\tclk |= SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n}\n\nstatic struct sdhci_ops sdhci_s3c_ops = {\n\t.get_max_clock\t\t= sdhci_s3c_get_max_clk,\n\t.set_clock\t\t= sdhci_s3c_set_clock,\n\t.get_min_clock\t\t= sdhci_s3c_get_min_clock,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t= sdhci_reset,\n\t.set_uhs_signaling\t= sdhci_set_uhs_signaling,\n};\n\n#ifdef CONFIG_OF\nstatic int sdhci_s3c_parse_dt(struct device *dev,\n\t\tstruct sdhci_host *host, struct s3c_sdhci_platdata *pdata)\n{\n\tstruct device_node *node = dev->of_node;\n\tu32 max_width;\n\n\t \n\tif (of_property_read_u32(node, \"bus-width\", &max_width))\n\t\tmax_width = 1;\n\tpdata->max_width = max_width;\n\n\t \n\tif (of_property_read_bool(node, \"broken-cd\")) {\n\t\tpdata->cd_type = S3C_SDHCI_CD_NONE;\n\t\treturn 0;\n\t}\n\n\tif (of_property_read_bool(node, \"non-removable\")) {\n\t\tpdata->cd_type = S3C_SDHCI_CD_PERMANENT;\n\t\treturn 0;\n\t}\n\n\tif (of_get_named_gpio(node, \"cd-gpios\", 0))\n\t\treturn 0;\n\n\t \n\tpdata->cd_type = S3C_SDHCI_CD_INTERNAL;\n\treturn 0;\n}\n#else\nstatic int sdhci_s3c_parse_dt(struct device *dev,\n\t\tstruct sdhci_host *host, struct s3c_sdhci_platdata *pdata)\n{\n\treturn -EINVAL;\n}\n#endif\n\nstatic inline const struct sdhci_s3c_drv_data *sdhci_s3c_get_driver_data(\n\t\t\tstruct platform_device *pdev)\n{\n#ifdef CONFIG_OF\n\tif (pdev->dev.of_node)\n\t\treturn of_device_get_match_data(&pdev->dev);\n#endif\n\treturn (const struct sdhci_s3c_drv_data *)\n\t\t\tplatform_get_device_id(pdev)->driver_data;\n}\n\nstatic int sdhci_s3c_probe(struct platform_device *pdev)\n{\n\tstruct s3c_sdhci_platdata *pdata;\n\tconst struct sdhci_s3c_drv_data *drv_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host;\n\tstruct sdhci_s3c *sc;\n\tint ret, irq, ptr, clks;\n\n\tif (!pdev->dev.platform_data && !pdev->dev.of_node) {\n\t\tdev_err(dev, \"no device data specified\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = sdhci_alloc_host(dev, sizeof(struct sdhci_s3c));\n\tif (IS_ERR(host)) {\n\t\tdev_err(dev, \"sdhci_alloc_host() failed\\n\");\n\t\treturn PTR_ERR(host);\n\t}\n\tsc = sdhci_priv(host);\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata) {\n\t\tret = -ENOMEM;\n\t\tgoto err_pdata_io_clk;\n\t}\n\n\tif (pdev->dev.of_node) {\n\t\tret = sdhci_s3c_parse_dt(&pdev->dev, host, pdata);\n\t\tif (ret)\n\t\t\tgoto err_pdata_io_clk;\n\t} else {\n\t\tmemcpy(pdata, pdev->dev.platform_data, sizeof(*pdata));\n\t}\n\n\tdrv_data = sdhci_s3c_get_driver_data(pdev);\n\n\tsc->host = host;\n\tsc->pdev = pdev;\n\tsc->pdata = pdata;\n\tsc->cur_clk = -1;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tsc->clk_io = devm_clk_get(dev, \"hsmmc\");\n\tif (IS_ERR(sc->clk_io)) {\n\t\tdev_err(dev, \"failed to get io clock\\n\");\n\t\tret = PTR_ERR(sc->clk_io);\n\t\tgoto err_pdata_io_clk;\n\t}\n\n\t \n\tclk_prepare_enable(sc->clk_io);\n\n\tfor (clks = 0, ptr = 0; ptr < MAX_BUS_CLK; ptr++) {\n\t\tchar name[14];\n\n\t\tsnprintf(name, 14, \"mmc_busclk.%d\", ptr);\n\t\tsc->clk_bus[ptr] = devm_clk_get(dev, name);\n\t\tif (IS_ERR(sc->clk_bus[ptr]))\n\t\t\tcontinue;\n\n\t\tclks++;\n\t\tsc->clk_rates[ptr] = clk_get_rate(sc->clk_bus[ptr]);\n\n\t\tdev_info(dev, \"clock source %d: %s (%ld Hz)\\n\",\n\t\t\t\tptr, name, sc->clk_rates[ptr]);\n\t}\n\n\tif (clks == 0) {\n\t\tdev_err(dev, \"failed to find any bus clocks\\n\");\n\t\tret = -ENOENT;\n\t\tgoto err_no_busclks;\n\t}\n\n\thost->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->ioaddr)) {\n\t\tret = PTR_ERR(host->ioaddr);\n\t\tgoto err_req_regs;\n\t}\n\n\t \n\tif (pdata->cfg_gpio)\n\t\tpdata->cfg_gpio(pdev, pdata->max_width);\n\n\thost->hw_name = \"samsung-hsmmc\";\n\thost->ops = &sdhci_s3c_ops;\n\thost->quirks = 0;\n\thost->quirks2 = 0;\n\thost->irq = irq;\n\n\t \n\thost->quirks |= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC;\n\thost->quirks |= SDHCI_QUIRK_NO_HISPD_BIT;\n\tif (drv_data) {\n\t\thost->quirks |= drv_data->sdhci_quirks;\n\t\tsc->no_divider = drv_data->no_divider;\n\t}\n\n#ifndef CONFIG_MMC_SDHCI_S3C_DMA\n\n\t \n\thost->quirks |= SDHCI_QUIRK_BROKEN_DMA;\n\n#endif  \n\n\t \n\thost->quirks |= SDHCI_QUIRK_NO_BUSY_IRQ;\n\n\t \n\thost->quirks |= SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12;\n\n\t \n\thost->quirks |= SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC;\n\n\tif (pdata->cd_type == S3C_SDHCI_CD_NONE ||\n\t    pdata->cd_type == S3C_SDHCI_CD_PERMANENT)\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\n\tif (pdata->cd_type == S3C_SDHCI_CD_PERMANENT)\n\t\thost->mmc->caps = MMC_CAP_NONREMOVABLE;\n\n\tswitch (pdata->max_width) {\n\tcase 8:\n\t\thost->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\t\tfallthrough;\n\tcase 4:\n\t\thost->mmc->caps |= MMC_CAP_4_BIT_DATA;\n\t\tbreak;\n\t}\n\n\tif (pdata->pm_caps)\n\t\thost->mmc->pm_caps |= pdata->pm_caps;\n\n\thost->quirks |= (SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\t\t SDHCI_QUIRK_32BIT_DMA_SIZE);\n\n\t \n\thost->quirks |= SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;\n\n\t \n\tif (sc->no_divider) {\n\t\tsdhci_s3c_ops.set_clock = sdhci_cmu_set_clock;\n\t\tsdhci_s3c_ops.get_min_clock = sdhci_cmu_get_min_clock;\n\t\tsdhci_s3c_ops.get_max_clock = sdhci_cmu_get_max_clock;\n\t}\n\n\t \n\tif (pdata->host_caps)\n\t\thost->mmc->caps |= pdata->host_caps;\n\n\tif (pdata->host_caps2)\n\t\thost->mmc->caps2 |= pdata->host_caps2;\n\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err_req_regs;\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_req_regs;\n\n#ifdef CONFIG_PM\n\tif (pdata->cd_type != S3C_SDHCI_CD_INTERNAL)\n\t\tclk_disable_unprepare(sc->clk_io);\n#endif\n\treturn 0;\n\n err_req_regs:\n\tpm_runtime_disable(&pdev->dev);\n\n err_no_busclks:\n\tclk_disable_unprepare(sc->clk_io);\n\n err_pdata_io_clk:\n\tsdhci_free_host(host);\n\n\treturn ret;\n}\n\nstatic void sdhci_s3c_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host =  platform_get_drvdata(pdev);\n\tstruct sdhci_s3c *sc = sdhci_priv(host);\n\n\tif (sc->ext_cd_irq)\n\t\tfree_irq(sc->ext_cd_irq, sc);\n\n#ifdef CONFIG_PM\n\tif (sc->pdata->cd_type != S3C_SDHCI_CD_INTERNAL)\n\t\tclk_prepare_enable(sc->clk_io);\n#endif\n\tsdhci_remove_host(host, 1);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tclk_disable_unprepare(sc->clk_io);\n\n\tsdhci_free_host(host);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_s3c_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\treturn sdhci_suspend_host(host);\n}\n\nstatic int sdhci_s3c_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\treturn sdhci_resume_host(host);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sdhci_s3c_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tstruct clk *busclk = ourhost->clk_io;\n\tint ret;\n\n\tret = sdhci_runtime_suspend_host(host);\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tif (ourhost->cur_clk >= 0)\n\t\tclk_disable_unprepare(ourhost->clk_bus[ourhost->cur_clk]);\n\tclk_disable_unprepare(busclk);\n\treturn ret;\n}\n\nstatic int sdhci_s3c_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_s3c *ourhost = to_s3c(host);\n\tstruct clk *busclk = ourhost->clk_io;\n\tint ret;\n\n\tclk_prepare_enable(busclk);\n\tif (ourhost->cur_clk >= 0)\n\t\tclk_prepare_enable(ourhost->clk_bus[ourhost->cur_clk]);\n\tret = sdhci_runtime_resume_host(host, 0);\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_s3c_pmops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_s3c_suspend, sdhci_s3c_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_s3c_runtime_suspend, sdhci_s3c_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct platform_device_id sdhci_s3c_driver_ids[] = {\n\t{\n\t\t.name\t\t= \"s3c-sdhci\",\n\t\t.driver_data\t= (kernel_ulong_t)NULL,\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, sdhci_s3c_driver_ids);\n\n#ifdef CONFIG_OF\nstatic const struct sdhci_s3c_drv_data exynos4_sdhci_drv_data = {\n\t.no_divider = true,\n};\n\nstatic const struct of_device_id sdhci_s3c_dt_match[] = {\n\t{ .compatible = \"samsung,s3c6410-sdhci\", },\n\t{ .compatible = \"samsung,exynos4210-sdhci\",\n\t\t.data = &exynos4_sdhci_drv_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdhci_s3c_dt_match);\n#endif\n\nstatic struct platform_driver sdhci_s3c_driver = {\n\t.probe\t\t= sdhci_s3c_probe,\n\t.remove_new\t= sdhci_s3c_remove,\n\t.id_table\t= sdhci_s3c_driver_ids,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c-sdhci\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(sdhci_s3c_dt_match),\n\t\t.pm\t= &sdhci_s3c_pmops,\n\t},\n};\n\nmodule_platform_driver(sdhci_s3c_driver);\n\nMODULE_DESCRIPTION(\"Samsung SDHCI (HSMMC) glue\");\nMODULE_AUTHOR(\"Ben Dooks, <ben@simtec.co.uk>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}