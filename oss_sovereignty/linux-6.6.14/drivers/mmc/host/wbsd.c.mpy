{
  "module_name": "wbsd.c",
  "hash_id": "3dc8140f790b128599bcb0273b85a191e6b45d7355fa8821346d8338115d4d79",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/wbsd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/pnp.h>\n#include <linux/highmem.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n\n#include <asm/io.h>\n#include <asm/dma.h>\n\n#include \"wbsd.h\"\n\n#define DRIVER_NAME \"wbsd\"\n\n#define DBG(x...) \\\n\tpr_debug(DRIVER_NAME \": \" x)\n#define DBGF(f, x...) \\\n\tpr_debug(DRIVER_NAME \" [%s()]: \" f, __func__ , ##x)\n\n \n\n#ifdef CONFIG_PNP\n\nstatic const struct pnp_device_id pnp_dev_table[] = {\n\t{ \"WEC0517\", 0 },\n\t{ \"WEC0518\", 0 },\n\t{ \"\", 0 },\n};\n\nMODULE_DEVICE_TABLE(pnp, pnp_dev_table);\n\n#endif  \n\nstatic const int config_ports[] = { 0x2E, 0x4E };\nstatic const int unlock_codes[] = { 0x83, 0x87 };\n\nstatic const int valid_ids[] = {\n\t0x7112,\n};\n\n#ifdef CONFIG_PNP\nstatic unsigned int param_nopnp = 0;\n#else\nstatic const unsigned int param_nopnp = 1;\n#endif\nstatic unsigned int param_io = 0x248;\nstatic unsigned int param_irq = 6;\nstatic int param_dma = 2;\n\n \n\nstatic inline void wbsd_unlock_config(struct wbsd_host *host)\n{\n\tBUG_ON(host->config == 0);\n\n\toutb(host->unlock_code, host->config);\n\toutb(host->unlock_code, host->config);\n}\n\nstatic inline void wbsd_lock_config(struct wbsd_host *host)\n{\n\tBUG_ON(host->config == 0);\n\n\toutb(LOCK_CODE, host->config);\n}\n\nstatic inline void wbsd_write_config(struct wbsd_host *host, u8 reg, u8 value)\n{\n\tBUG_ON(host->config == 0);\n\n\toutb(reg, host->config);\n\toutb(value, host->config + 1);\n}\n\nstatic inline u8 wbsd_read_config(struct wbsd_host *host, u8 reg)\n{\n\tBUG_ON(host->config == 0);\n\n\toutb(reg, host->config);\n\treturn inb(host->config + 1);\n}\n\nstatic inline void wbsd_write_index(struct wbsd_host *host, u8 index, u8 value)\n{\n\toutb(index, host->base + WBSD_IDXR);\n\toutb(value, host->base + WBSD_DATAR);\n}\n\nstatic inline u8 wbsd_read_index(struct wbsd_host *host, u8 index)\n{\n\toutb(index, host->base + WBSD_IDXR);\n\treturn inb(host->base + WBSD_DATAR);\n}\n\n \n\nstatic void wbsd_init_device(struct wbsd_host *host)\n{\n\tu8 setup, ier;\n\n\t \n\tsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\n\tsetup |= WBSD_FIFO_RESET | WBSD_SOFT_RESET;\n\twbsd_write_index(host, WBSD_IDX_SETUP, setup);\n\n\t \n\tsetup &= ~WBSD_DAT3_H;\n\twbsd_write_index(host, WBSD_IDX_SETUP, setup);\n\thost->flags &= ~WBSD_FIGNORE_DETECT;\n\n\t \n\thost->clk = wbsd_read_index(host, WBSD_IDX_CLK);\n\n\t \n\toutb(WBSD_POWER_N, host->base + WBSD_CSR);\n\n\t \n\twbsd_write_index(host, WBSD_IDX_TAAC, 0x7F);\n\n\t \n\tif (inb(host->base + WBSD_CSR) & WBSD_CARDPRESENT)\n\t\thost->flags |= WBSD_FCARD_PRESENT;\n\telse\n\t\thost->flags &= ~WBSD_FCARD_PRESENT;\n\n\t \n\tier = 0;\n\tier |= WBSD_EINT_CARD;\n\tier |= WBSD_EINT_FIFO_THRE;\n\tier |= WBSD_EINT_CRC;\n\tier |= WBSD_EINT_TIMEOUT;\n\tier |= WBSD_EINT_TC;\n\n\toutb(ier, host->base + WBSD_EIR);\n\n\t \n\tinb(host->base + WBSD_ISR);\n}\n\nstatic void wbsd_reset(struct wbsd_host *host)\n{\n\tu8 setup;\n\n\tpr_err(\"%s: Resetting chip\\n\", mmc_hostname(host->mmc));\n\n\t \n\tsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\n\tsetup |= WBSD_SOFT_RESET;\n\twbsd_write_index(host, WBSD_IDX_SETUP, setup);\n}\n\nstatic void wbsd_request_end(struct wbsd_host *host, struct mmc_request *mrq)\n{\n\tunsigned long dmaflags;\n\n\tif (host->dma >= 0) {\n\t\t \n\t\tdmaflags = claim_dma_lock();\n\t\tdisable_dma(host->dma);\n\t\tclear_dma_ff(host->dma);\n\t\trelease_dma_lock(dmaflags);\n\n\t\t \n\t\twbsd_write_index(host, WBSD_IDX_DMA, 0);\n\t}\n\n\thost->mrq = NULL;\n\n\t \n\tspin_unlock(&host->lock);\n\tmmc_request_done(host->mmc, mrq);\n\tspin_lock(&host->lock);\n}\n\n \n\nstatic inline void wbsd_init_sg(struct wbsd_host *host, struct mmc_data *data)\n{\n\t \n\thost->cur_sg = data->sg;\n\thost->num_sg = data->sg_len;\n\n\thost->offset = 0;\n\thost->remain = host->cur_sg->length;\n}\n\nstatic inline int wbsd_next_sg(struct wbsd_host *host)\n{\n\t \n\thost->cur_sg++;\n\thost->num_sg--;\n\n\t \n\tif (host->num_sg > 0) {\n\t\thost->offset = 0;\n\t\thost->remain = host->cur_sg->length;\n\t}\n\n\treturn host->num_sg;\n}\n\nstatic inline char *wbsd_map_sg(struct wbsd_host *host)\n{\n\treturn kmap_local_page(sg_page(host->cur_sg)) + host->cur_sg->offset;\n}\n\nstatic inline void wbsd_sg_to_dma(struct wbsd_host *host, struct mmc_data *data)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < data->sg_len; i++)\n\t\tlen += data->sg[i].length;\n\tsg_copy_to_buffer(data->sg, data->sg_len, host->dma_buffer, len);\n}\n\nstatic inline void wbsd_dma_to_sg(struct wbsd_host *host, struct mmc_data *data)\n{\n\tsize_t len = 0;\n\tint i;\n\n\tfor (i = 0; i < data->sg_len; i++)\n\t\tlen += data->sg[i].length;\n\tsg_copy_from_buffer(data->sg, data->sg_len, host->dma_buffer, len);\n}\n\n \n\nstatic inline void wbsd_get_short_reply(struct wbsd_host *host,\n\t\t\t\t\tstruct mmc_command *cmd)\n{\n\t \n\tif (wbsd_read_index(host, WBSD_IDX_RSPLEN) != WBSD_RSP_SHORT) {\n\t\tcmd->error = -EILSEQ;\n\t\treturn;\n\t}\n\n\tcmd->resp[0]  = wbsd_read_index(host, WBSD_IDX_RESP12) << 24;\n\tcmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP13) << 16;\n\tcmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP14) << 8;\n\tcmd->resp[0] |= wbsd_read_index(host, WBSD_IDX_RESP15) << 0;\n\tcmd->resp[1]  = wbsd_read_index(host, WBSD_IDX_RESP16) << 24;\n}\n\nstatic inline void wbsd_get_long_reply(struct wbsd_host *host,\n\tstruct mmc_command *cmd)\n{\n\tint i;\n\n\t \n\tif (wbsd_read_index(host, WBSD_IDX_RSPLEN) != WBSD_RSP_LONG) {\n\t\tcmd->error = -EILSEQ;\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < 4; i++) {\n\t\tcmd->resp[i] =\n\t\t\twbsd_read_index(host, WBSD_IDX_RESP1 + i * 4) << 24;\n\t\tcmd->resp[i] |=\n\t\t\twbsd_read_index(host, WBSD_IDX_RESP2 + i * 4) << 16;\n\t\tcmd->resp[i] |=\n\t\t\twbsd_read_index(host, WBSD_IDX_RESP3 + i * 4) << 8;\n\t\tcmd->resp[i] |=\n\t\t\twbsd_read_index(host, WBSD_IDX_RESP4 + i * 4) << 0;\n\t}\n}\n\nstatic void wbsd_send_command(struct wbsd_host *host, struct mmc_command *cmd)\n{\n\tint i;\n\tu8 status, isr;\n\n\t \n\thost->isr = 0;\n\n\t \n\toutb(cmd->opcode, host->base + WBSD_CMDR);\n\tfor (i = 3; i >= 0; i--)\n\t\toutb((cmd->arg >> (i * 8)) & 0xff, host->base + WBSD_CMDR);\n\n\tcmd->error = 0;\n\n\t \n\tdo {\n\t\tstatus = wbsd_read_index(host, WBSD_IDX_STATUS);\n\t} while (status & WBSD_CARDTRAFFIC);\n\n\t \n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\t \n\t\tisr = host->isr;\n\n\t\t \n\t\tif (isr & WBSD_INT_CARD)\n\t\t\tcmd->error = -ENOMEDIUM;\n\t\t \n\t\telse if (isr & WBSD_INT_TIMEOUT)\n\t\t\tcmd->error = -ETIMEDOUT;\n\t\t \n\t\telse if ((cmd->flags & MMC_RSP_CRC) && (isr & WBSD_INT_CRC))\n\t\t\tcmd->error = -EILSEQ;\n\t\t \n\t\telse {\n\t\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\t\twbsd_get_long_reply(host, cmd);\n\t\t\telse\n\t\t\t\twbsd_get_short_reply(host, cmd);\n\t\t}\n\t}\n}\n\n \n\nstatic void wbsd_empty_fifo(struct wbsd_host *host)\n{\n\tstruct mmc_data *data = host->mrq->cmd->data;\n\tchar *buffer;\n\tint i, idx, fsr, fifo;\n\n\t \n\tif (host->num_sg == 0)\n\t\treturn;\n\n\tbuffer = wbsd_map_sg(host) + host->offset;\n\tidx = 0;\n\n\t \n\twhile (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_EMPTY)) {\n\t\t \n\t\tif (fsr & WBSD_FIFO_FULL)\n\t\t\tfifo = 16;\n\t\telse if (fsr & WBSD_FIFO_FUTHRE)\n\t\t\tfifo = 8;\n\t\telse\n\t\t\tfifo = 1;\n\n\t\tfor (i = 0; i < fifo; i++) {\n\t\t\tbuffer[idx++] = inb(host->base + WBSD_DFR);\n\t\t\thost->offset++;\n\t\t\thost->remain--;\n\n\t\t\tdata->bytes_xfered++;\n\n\t\t\t \n\t\t\tif (host->remain == 0) {\n\t\t\t\tkunmap_local(buffer);\n\t\t\t\t \n\t\t\t\tif (!wbsd_next_sg(host))\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = wbsd_map_sg(host);\n\t\t\t\tidx = 0;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap_local(buffer);\n\n\t \n\tif ((data->blocks * data->blksz - data->bytes_xfered) < 16)\n\t\ttasklet_schedule(&host->fifo_tasklet);\n}\n\nstatic void wbsd_fill_fifo(struct wbsd_host *host)\n{\n\tstruct mmc_data *data = host->mrq->cmd->data;\n\tchar *buffer;\n\tint i, idx, fsr, fifo;\n\n\t \n\tif (host->num_sg == 0)\n\t\treturn;\n\n\tbuffer = wbsd_map_sg(host) + host->offset;\n\tidx = 0;\n\n\t \n\twhile (!((fsr = inb(host->base + WBSD_FSR)) & WBSD_FIFO_FULL)) {\n\t\t \n\t\tif (fsr & WBSD_FIFO_EMPTY)\n\t\t\tfifo = 0;\n\t\telse if (fsr & WBSD_FIFO_EMTHRE)\n\t\t\tfifo = 8;\n\t\telse\n\t\t\tfifo = 15;\n\n\t\tfor (i = 16; i > fifo; i--) {\n\t\t\toutb(buffer[idx], host->base + WBSD_DFR);\n\t\t\thost->offset++;\n\t\t\thost->remain--;\n\n\t\t\tdata->bytes_xfered++;\n\n\t\t\t \n\t\t\tif (host->remain == 0) {\n\t\t\t\tkunmap_local(buffer);\n\t\t\t\t \n\t\t\t\tif (!wbsd_next_sg(host))\n\t\t\t\t\treturn;\n\n\t\t\t\tbuffer = wbsd_map_sg(host);\n\t\t\t\tidx = 0;\n\t\t\t}\n\t\t}\n\t}\n\tkunmap_local(buffer);\n\n\t \n\ttasklet_schedule(&host->fifo_tasklet);\n}\n\nstatic void wbsd_prepare_data(struct wbsd_host *host, struct mmc_data *data)\n{\n\tu16 blksize;\n\tu8 setup;\n\tunsigned long dmaflags;\n\tunsigned int size;\n\n\t \n\tsize = data->blocks * data->blksz;\n\n\t \n\tif (data->timeout_ns > 127000000)\n\t\twbsd_write_index(host, WBSD_IDX_TAAC, 127);\n\telse {\n\t\twbsd_write_index(host, WBSD_IDX_TAAC,\n\t\t\tdata->timeout_ns / 1000000);\n\t}\n\n\tif (data->timeout_clks > 255)\n\t\twbsd_write_index(host, WBSD_IDX_NSAC, 255);\n\telse\n\t\twbsd_write_index(host, WBSD_IDX_NSAC, data->timeout_clks);\n\n\t \n\tif (host->bus_width == MMC_BUS_WIDTH_1) {\n\t\tblksize = data->blksz + 2;\n\n\t\twbsd_write_index(host, WBSD_IDX_PBSMSB, (blksize >> 4) & 0xF0);\n\t\twbsd_write_index(host, WBSD_IDX_PBSLSB, blksize & 0xFF);\n\t} else if (host->bus_width == MMC_BUS_WIDTH_4) {\n\t\tblksize = data->blksz + 2 * 4;\n\n\t\twbsd_write_index(host, WBSD_IDX_PBSMSB,\n\t\t\t((blksize >> 4) & 0xF0) | WBSD_DATA_WIDTH);\n\t\twbsd_write_index(host, WBSD_IDX_PBSLSB, blksize & 0xFF);\n\t} else {\n\t\tdata->error = -EINVAL;\n\t\treturn;\n\t}\n\n\t \n\tsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\n\tsetup |= WBSD_FIFO_RESET;\n\twbsd_write_index(host, WBSD_IDX_SETUP, setup);\n\n\t \n\tif (host->dma >= 0) {\n\t\t \n\t\tBUG_ON(size > 0x10000);\n\t\tif (size > 0x10000) {\n\t\t\tdata->error = -EINVAL;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif (data->flags & MMC_DATA_WRITE)\n\t\t\twbsd_sg_to_dma(host, data);\n\n\t\t \n\t\tdmaflags = claim_dma_lock();\n\t\tdisable_dma(host->dma);\n\t\tclear_dma_ff(host->dma);\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tset_dma_mode(host->dma, DMA_MODE_READ & ~0x40);\n\t\telse\n\t\t\tset_dma_mode(host->dma, DMA_MODE_WRITE & ~0x40);\n\t\tset_dma_addr(host->dma, host->dma_addr);\n\t\tset_dma_count(host->dma, size);\n\n\t\tenable_dma(host->dma);\n\t\trelease_dma_lock(dmaflags);\n\n\t\t \n\t\twbsd_write_index(host, WBSD_IDX_DMA, WBSD_DMA_ENABLE);\n\t} else {\n\t\t \n\t\thost->firsterr = 1;\n\n\t\t \n\t\twbsd_init_sg(host, data);\n\n\t\t \n\t\twbsd_write_index(host, WBSD_IDX_DMA, 0);\n\n\t\t \n\t\tif (data->flags & MMC_DATA_READ) {\n\t\t\twbsd_write_index(host, WBSD_IDX_FIFOEN,\n\t\t\t\tWBSD_FIFOEN_FULL | 8);\n\t\t} else {\n\t\t\twbsd_write_index(host, WBSD_IDX_FIFOEN,\n\t\t\t\tWBSD_FIFOEN_EMPTY | 8);\n\t\t\twbsd_fill_fifo(host);\n\t\t}\n\t}\n\n\tdata->error = 0;\n}\n\nstatic void wbsd_finish_data(struct wbsd_host *host, struct mmc_data *data)\n{\n\tunsigned long dmaflags;\n\tint count;\n\tu8 status;\n\n\tWARN_ON(host->mrq == NULL);\n\n\t \n\tif (data->stop)\n\t\twbsd_send_command(host, data->stop);\n\n\t \n\tdo {\n\t\tstatus = wbsd_read_index(host, WBSD_IDX_STATUS);\n\t} while (status & (WBSD_BLOCK_READ | WBSD_BLOCK_WRITE));\n\n\t \n\tif (host->dma >= 0) {\n\t\t \n\t\twbsd_write_index(host, WBSD_IDX_DMA, 0);\n\n\t\t \n\t\tdmaflags = claim_dma_lock();\n\t\tdisable_dma(host->dma);\n\t\tclear_dma_ff(host->dma);\n\t\tcount = get_dma_residue(host->dma);\n\t\trelease_dma_lock(dmaflags);\n\n\t\tdata->bytes_xfered = host->mrq->data->blocks *\n\t\t\thost->mrq->data->blksz - count;\n\t\tdata->bytes_xfered -= data->bytes_xfered % data->blksz;\n\n\t\t \n\t\tif (count) {\n\t\t\tpr_err(\"%s: Incomplete DMA transfer. \"\n\t\t\t\t\"%d bytes left.\\n\",\n\t\t\t\tmmc_hostname(host->mmc), count);\n\n\t\t\tif (!data->error)\n\t\t\t\tdata->error = -EIO;\n\t\t} else {\n\t\t\t \n\t\t\tif (data->flags & MMC_DATA_READ)\n\t\t\t\twbsd_dma_to_sg(host, data);\n\t\t}\n\n\t\tif (data->error) {\n\t\t\tif (data->bytes_xfered)\n\t\t\t\tdata->bytes_xfered -= data->blksz;\n\t\t}\n\t}\n\n\twbsd_request_end(host, host->mrq);\n}\n\n \n\nstatic void wbsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct wbsd_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd;\n\n\t \n\tspin_lock_bh(&host->lock);\n\n\tBUG_ON(host->mrq != NULL);\n\n\tcmd = mrq->cmd;\n\n\thost->mrq = mrq;\n\n\t \n\tif (!(host->flags & WBSD_FCARD_PRESENT)) {\n\t\tcmd->error = -ENOMEDIUM;\n\t\tgoto done;\n\t}\n\n\tif (cmd->data) {\n\t\t \n\t\tswitch (cmd->opcode) {\n\t\tcase SD_SWITCH_VOLTAGE:\n\t\tcase MMC_READ_SINGLE_BLOCK:\n\t\tcase MMC_READ_MULTIPLE_BLOCK:\n\t\tcase MMC_WRITE_DAT_UNTIL_STOP:\n\t\tcase MMC_WRITE_BLOCK:\n\t\tcase MMC_WRITE_MULTIPLE_BLOCK:\n\t\tcase MMC_PROGRAM_CID:\n\t\tcase MMC_PROGRAM_CSD:\n\t\tcase MMC_SEND_WRITE_PROT:\n\t\tcase MMC_LOCK_UNLOCK:\n\t\tcase MMC_GEN_CMD:\n\t\t\tbreak;\n\n\t\t \n\t\tcase SD_APP_SEND_SCR:\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_warn(\"%s: Data command %d is not supported by this controller\\n\",\n\t\t\t\tmmc_hostname(host->mmc), cmd->opcode);\n\t\t\tcmd->error = -EINVAL;\n\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (cmd->data) {\n\t\twbsd_prepare_data(host, cmd->data);\n\n\t\tif (cmd->data->error)\n\t\t\tgoto done;\n\t}\n\n\twbsd_send_command(host, cmd);\n\n\t \n\tif (cmd->data && !cmd->error) {\n\t\t \n\t\tif (host->dma == -1)\n\t\t\ttasklet_schedule(&host->fifo_tasklet);\n\n\t\tspin_unlock_bh(&host->lock);\n\n\t\treturn;\n\t}\n\ndone:\n\twbsd_request_end(host, mrq);\n\n\tspin_unlock_bh(&host->lock);\n}\n\nstatic void wbsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct wbsd_host *host = mmc_priv(mmc);\n\tu8 clk, setup, pwr;\n\n\tspin_lock_bh(&host->lock);\n\n\t \n\tif (ios->power_mode == MMC_POWER_OFF)\n\t\twbsd_init_device(host);\n\n\tif (ios->clock >= 24000000)\n\t\tclk = WBSD_CLK_24M;\n\telse if (ios->clock >= 16000000)\n\t\tclk = WBSD_CLK_16M;\n\telse if (ios->clock >= 12000000)\n\t\tclk = WBSD_CLK_12M;\n\telse\n\t\tclk = WBSD_CLK_375K;\n\n\t \n\tif (clk != host->clk) {\n\t\twbsd_write_index(host, WBSD_IDX_CLK, clk);\n\t\thost->clk = clk;\n\t}\n\n\t \n\tif (ios->power_mode != MMC_POWER_OFF) {\n\t\tpwr = inb(host->base + WBSD_CSR);\n\t\tpwr &= ~WBSD_POWER_N;\n\t\toutb(pwr, host->base + WBSD_CSR);\n\t}\n\n\t \n\tsetup = wbsd_read_index(host, WBSD_IDX_SETUP);\n\tif (ios->chip_select == MMC_CS_HIGH) {\n\t\tBUG_ON(ios->bus_width != MMC_BUS_WIDTH_1);\n\t\tsetup |= WBSD_DAT3_H;\n\t\thost->flags |= WBSD_FIGNORE_DETECT;\n\t} else {\n\t\tif (setup & WBSD_DAT3_H) {\n\t\t\tsetup &= ~WBSD_DAT3_H;\n\n\t\t\t \n\t\t\tmod_timer(&host->ignore_timer, jiffies + HZ / 100);\n\t\t}\n\t}\n\twbsd_write_index(host, WBSD_IDX_SETUP, setup);\n\n\t \n\thost->bus_width = ios->bus_width;\n\n\tspin_unlock_bh(&host->lock);\n}\n\nstatic int wbsd_get_ro(struct mmc_host *mmc)\n{\n\tstruct wbsd_host *host = mmc_priv(mmc);\n\tu8 csr;\n\n\tspin_lock_bh(&host->lock);\n\n\tcsr = inb(host->base + WBSD_CSR);\n\tcsr |= WBSD_MSLED;\n\toutb(csr, host->base + WBSD_CSR);\n\n\tmdelay(1);\n\n\tcsr = inb(host->base + WBSD_CSR);\n\tcsr &= ~WBSD_MSLED;\n\toutb(csr, host->base + WBSD_CSR);\n\n\tspin_unlock_bh(&host->lock);\n\n\treturn !!(csr & WBSD_WRPT);\n}\n\nstatic const struct mmc_host_ops wbsd_ops = {\n\t.request\t= wbsd_request,\n\t.set_ios\t= wbsd_set_ios,\n\t.get_ro\t\t= wbsd_get_ro,\n};\n\n \n\n \n\nstatic void wbsd_reset_ignore(struct timer_list *t)\n{\n\tstruct wbsd_host *host = from_timer(host, t, ignore_timer);\n\n\tBUG_ON(host == NULL);\n\n\tDBG(\"Resetting card detection ignore\\n\");\n\n\tspin_lock_bh(&host->lock);\n\n\thost->flags &= ~WBSD_FIGNORE_DETECT;\n\n\t \n\ttasklet_schedule(&host->card_tasklet);\n\n\tspin_unlock_bh(&host->lock);\n}\n\n \n\nstatic inline struct mmc_data *wbsd_get_data(struct wbsd_host *host)\n{\n\tWARN_ON(!host->mrq);\n\tif (!host->mrq)\n\t\treturn NULL;\n\n\tWARN_ON(!host->mrq->cmd);\n\tif (!host->mrq->cmd)\n\t\treturn NULL;\n\n\tWARN_ON(!host->mrq->cmd->data);\n\tif (!host->mrq->cmd->data)\n\t\treturn NULL;\n\n\treturn host->mrq->cmd->data;\n}\n\nstatic void wbsd_tasklet_card(struct tasklet_struct *t)\n{\n\tstruct wbsd_host *host = from_tasklet(host, t, card_tasklet);\n\tu8 csr;\n\tint delay = -1;\n\n\tspin_lock(&host->lock);\n\n\tif (host->flags & WBSD_FIGNORE_DETECT) {\n\t\tspin_unlock(&host->lock);\n\t\treturn;\n\t}\n\n\tcsr = inb(host->base + WBSD_CSR);\n\tWARN_ON(csr == 0xff);\n\n\tif (csr & WBSD_CARDPRESENT) {\n\t\tif (!(host->flags & WBSD_FCARD_PRESENT)) {\n\t\t\tDBG(\"Card inserted\\n\");\n\t\t\thost->flags |= WBSD_FCARD_PRESENT;\n\n\t\t\tdelay = 500;\n\t\t}\n\t} else if (host->flags & WBSD_FCARD_PRESENT) {\n\t\tDBG(\"Card removed\\n\");\n\t\thost->flags &= ~WBSD_FCARD_PRESENT;\n\n\t\tif (host->mrq) {\n\t\t\tpr_err(\"%s: Card removed during transfer!\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\twbsd_reset(host);\n\n\t\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\t\ttasklet_schedule(&host->finish_tasklet);\n\t\t}\n\n\t\tdelay = 0;\n\t}\n\n\t \n\n\tspin_unlock(&host->lock);\n\n\tif (delay != -1)\n\t\tmmc_detect_change(host->mmc, msecs_to_jiffies(delay));\n}\n\nstatic void wbsd_tasklet_fifo(struct tasklet_struct *t)\n{\n\tstruct wbsd_host *host = from_tasklet(host, t, fifo_tasklet);\n\tstruct mmc_data *data;\n\n\tspin_lock(&host->lock);\n\n\tif (!host->mrq)\n\t\tgoto end;\n\n\tdata = wbsd_get_data(host);\n\tif (!data)\n\t\tgoto end;\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\twbsd_fill_fifo(host);\n\telse\n\t\twbsd_empty_fifo(host);\n\n\t \n\tif (host->num_sg == 0) {\n\t\twbsd_write_index(host, WBSD_IDX_FIFOEN, 0);\n\t\ttasklet_schedule(&host->finish_tasklet);\n\t}\n\nend:\n\tspin_unlock(&host->lock);\n}\n\nstatic void wbsd_tasklet_crc(struct tasklet_struct *t)\n{\n\tstruct wbsd_host *host = from_tasklet(host, t, crc_tasklet);\n\tstruct mmc_data *data;\n\n\tspin_lock(&host->lock);\n\n\tif (!host->mrq)\n\t\tgoto end;\n\n\tdata = wbsd_get_data(host);\n\tif (!data)\n\t\tgoto end;\n\n\tDBGF(\"CRC error\\n\");\n\n\tdata->error = -EILSEQ;\n\n\ttasklet_schedule(&host->finish_tasklet);\n\nend:\n\tspin_unlock(&host->lock);\n}\n\nstatic void wbsd_tasklet_timeout(struct tasklet_struct *t)\n{\n\tstruct wbsd_host *host = from_tasklet(host, t, timeout_tasklet);\n\tstruct mmc_data *data;\n\n\tspin_lock(&host->lock);\n\n\tif (!host->mrq)\n\t\tgoto end;\n\n\tdata = wbsd_get_data(host);\n\tif (!data)\n\t\tgoto end;\n\n\tDBGF(\"Timeout\\n\");\n\n\tdata->error = -ETIMEDOUT;\n\n\ttasklet_schedule(&host->finish_tasklet);\n\nend:\n\tspin_unlock(&host->lock);\n}\n\nstatic void wbsd_tasklet_finish(struct tasklet_struct *t)\n{\n\tstruct wbsd_host *host = from_tasklet(host, t, finish_tasklet);\n\tstruct mmc_data *data;\n\n\tspin_lock(&host->lock);\n\n\tWARN_ON(!host->mrq);\n\tif (!host->mrq)\n\t\tgoto end;\n\n\tdata = wbsd_get_data(host);\n\tif (!data)\n\t\tgoto end;\n\n\twbsd_finish_data(host, data);\n\nend:\n\tspin_unlock(&host->lock);\n}\n\n \n\nstatic irqreturn_t wbsd_irq(int irq, void *dev_id)\n{\n\tstruct wbsd_host *host = dev_id;\n\tint isr;\n\n\tisr = inb(host->base + WBSD_ISR);\n\n\t \n\tif (isr == 0xff || isr == 0x00)\n\t\treturn IRQ_NONE;\n\n\thost->isr |= isr;\n\n\t \n\tif (isr & WBSD_INT_CARD)\n\t\ttasklet_schedule(&host->card_tasklet);\n\tif (isr & WBSD_INT_FIFO_THRE)\n\t\ttasklet_schedule(&host->fifo_tasklet);\n\tif (isr & WBSD_INT_CRC)\n\t\ttasklet_hi_schedule(&host->crc_tasklet);\n\tif (isr & WBSD_INT_TIMEOUT)\n\t\ttasklet_hi_schedule(&host->timeout_tasklet);\n\tif (isr & WBSD_INT_TC)\n\t\ttasklet_schedule(&host->finish_tasklet);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\n \n\nstatic int wbsd_alloc_mmc(struct device *dev)\n{\n\tstruct mmc_host *mmc;\n\tstruct wbsd_host *host;\n\n\t \n\tmmc = mmc_alloc_host(sizeof(struct wbsd_host), dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\n\thost->dma = -1;\n\n\t \n\tmmc->ops = &wbsd_ops;\n\tmmc->f_min = 375000;\n\tmmc->f_max = 24000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA;\n\n\tspin_lock_init(&host->lock);\n\n\t \n\ttimer_setup(&host->ignore_timer, wbsd_reset_ignore, 0);\n\n\t \n\tmmc->max_segs = 128;\n\n\t \n\tmmc->max_req_size = 65536;\n\n\t \n\tmmc->max_seg_size = mmc->max_req_size;\n\n\t \n\tmmc->max_blk_size = 4087;\n\n\t \n\tmmc->max_blk_count = mmc->max_req_size;\n\n\tdev_set_drvdata(dev, mmc);\n\n\treturn 0;\n}\n\nstatic void wbsd_free_mmc(struct device *dev)\n{\n\tstruct mmc_host *mmc;\n\tstruct wbsd_host *host;\n\n\tmmc = dev_get_drvdata(dev);\n\tif (!mmc)\n\t\treturn;\n\n\thost = mmc_priv(mmc);\n\tBUG_ON(host == NULL);\n\n\tdel_timer_sync(&host->ignore_timer);\n\n\tmmc_free_host(mmc);\n}\n\n \n\nstatic int wbsd_scan(struct wbsd_host *host)\n{\n\tint i, j, k;\n\tint id;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(config_ports); i++) {\n\t\tif (!request_region(config_ports[i], 2, DRIVER_NAME))\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < ARRAY_SIZE(unlock_codes); j++) {\n\t\t\tid = 0xFFFF;\n\n\t\t\thost->config = config_ports[i];\n\t\t\thost->unlock_code = unlock_codes[j];\n\n\t\t\twbsd_unlock_config(host);\n\n\t\t\toutb(WBSD_CONF_ID_HI, config_ports[i]);\n\t\t\tid = inb(config_ports[i] + 1) << 8;\n\n\t\t\toutb(WBSD_CONF_ID_LO, config_ports[i]);\n\t\t\tid |= inb(config_ports[i] + 1);\n\n\t\t\twbsd_lock_config(host);\n\n\t\t\tfor (k = 0; k < ARRAY_SIZE(valid_ids); k++) {\n\t\t\t\tif (id == valid_ids[k]) {\n\t\t\t\t\thost->chip_id = id;\n\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (id != 0xFFFF) {\n\t\t\t\tDBG(\"Unknown hardware (id %x) found at %x\\n\",\n\t\t\t\t\tid, config_ports[i]);\n\t\t\t}\n\t\t}\n\n\t\trelease_region(config_ports[i], 2);\n\t}\n\n\thost->config = 0;\n\thost->unlock_code = 0;\n\n\treturn -ENODEV;\n}\n\n \n\nstatic int wbsd_request_region(struct wbsd_host *host, int base)\n{\n\tif (base & 0x7)\n\t\treturn -EINVAL;\n\n\tif (!request_region(base, 8, DRIVER_NAME))\n\t\treturn -EIO;\n\n\thost->base = base;\n\n\treturn 0;\n}\n\nstatic void wbsd_release_regions(struct wbsd_host *host)\n{\n\tif (host->base)\n\t\trelease_region(host->base, 8);\n\n\thost->base = 0;\n\n\tif (host->config)\n\t\trelease_region(host->config, 2);\n\n\thost->config = 0;\n}\n\n \n\nstatic void wbsd_request_dma(struct wbsd_host *host, int dma)\n{\n\tif (dma < 0)\n\t\treturn;\n\n\tif (request_dma(dma, DRIVER_NAME))\n\t\tgoto err;\n\n\t \n\thost->dma_buffer = kmalloc(WBSD_DMA_SIZE,\n\t\tGFP_NOIO | GFP_DMA | __GFP_RETRY_MAYFAIL | __GFP_NOWARN);\n\tif (!host->dma_buffer)\n\t\tgoto free;\n\n\t \n\thost->dma_addr = dma_map_single(mmc_dev(host->mmc), host->dma_buffer,\n\t\tWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\n\tif (dma_mapping_error(mmc_dev(host->mmc), host->dma_addr))\n\t\tgoto kfree;\n\n\t \n\tif ((host->dma_addr & 0xffff) != 0)\n\t\tgoto unmap;\n\t \n\telse if (host->dma_addr >= 0x1000000)\n\t\tgoto unmap;\n\n\thost->dma = dma;\n\n\treturn;\n\nunmap:\n\t \n\tBUG_ON(1);\n\n\tdma_unmap_single(mmc_dev(host->mmc), host->dma_addr,\n\t\tWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\n\thost->dma_addr = 0;\n\nkfree:\n\tkfree(host->dma_buffer);\n\thost->dma_buffer = NULL;\n\nfree:\n\tfree_dma(dma);\n\nerr:\n\tpr_warn(DRIVER_NAME \": Unable to allocate DMA %d - falling back on FIFO\\n\",\n\t\tdma);\n}\n\nstatic void wbsd_release_dma(struct wbsd_host *host)\n{\n\t \n\tif (host->dma_buffer) {\n\t\tdma_unmap_single(mmc_dev(host->mmc), host->dma_addr,\n\t\t\tWBSD_DMA_SIZE, DMA_BIDIRECTIONAL);\n\t\tkfree(host->dma_buffer);\n\t}\n\tif (host->dma >= 0)\n\t\tfree_dma(host->dma);\n\n\thost->dma = -1;\n\thost->dma_buffer = NULL;\n\thost->dma_addr = 0;\n}\n\n \n\nstatic int wbsd_request_irq(struct wbsd_host *host, int irq)\n{\n\tint ret;\n\n\t \n\ttasklet_setup(&host->card_tasklet, wbsd_tasklet_card);\n\ttasklet_setup(&host->fifo_tasklet, wbsd_tasklet_fifo);\n\ttasklet_setup(&host->crc_tasklet, wbsd_tasklet_crc);\n\ttasklet_setup(&host->timeout_tasklet, wbsd_tasklet_timeout);\n\ttasklet_setup(&host->finish_tasklet, wbsd_tasklet_finish);\n\n\t \n\tret = request_irq(irq, wbsd_irq, IRQF_SHARED, DRIVER_NAME, host);\n\tif (ret)\n\t\treturn ret;\n\n\thost->irq = irq;\n\n\treturn 0;\n}\n\nstatic void  wbsd_release_irq(struct wbsd_host *host)\n{\n\tif (!host->irq)\n\t\treturn;\n\n\tfree_irq(host->irq, host);\n\n\thost->irq = 0;\n\n\ttasklet_kill(&host->card_tasklet);\n\ttasklet_kill(&host->fifo_tasklet);\n\ttasklet_kill(&host->crc_tasklet);\n\ttasklet_kill(&host->timeout_tasklet);\n\ttasklet_kill(&host->finish_tasklet);\n}\n\n \n\nstatic int wbsd_request_resources(struct wbsd_host *host,\n\tint base, int irq, int dma)\n{\n\tint ret;\n\n\t \n\tret = wbsd_request_region(host, base);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = wbsd_request_irq(host, irq);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\twbsd_request_dma(host, dma);\n\n\treturn 0;\n}\n\n \n\nstatic void wbsd_release_resources(struct wbsd_host *host)\n{\n\twbsd_release_dma(host);\n\twbsd_release_irq(host);\n\twbsd_release_regions(host);\n}\n\n \n\nstatic void wbsd_chip_config(struct wbsd_host *host)\n{\n\twbsd_unlock_config(host);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_SWRST, 1);\n\twbsd_write_config(host, WBSD_CONF_SWRST, 0);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_PINS, WBSD_PINS_DETECT_GP11);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_PORT_HI, host->base >> 8);\n\twbsd_write_config(host, WBSD_CONF_PORT_LO, host->base & 0xff);\n\n\twbsd_write_config(host, WBSD_CONF_IRQ, host->irq);\n\n\tif (host->dma >= 0)\n\t\twbsd_write_config(host, WBSD_CONF_DRQ, host->dma);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_ENABLE, 1);\n\twbsd_write_config(host, WBSD_CONF_POWER, 0x20);\n\n\twbsd_lock_config(host);\n}\n\n \n\nstatic int wbsd_chip_validate(struct wbsd_host *host)\n{\n\tint base, irq, dma;\n\n\twbsd_unlock_config(host);\n\n\t \n\twbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\n\n\t \n\tbase = wbsd_read_config(host, WBSD_CONF_PORT_HI) << 8;\n\tbase |= wbsd_read_config(host, WBSD_CONF_PORT_LO);\n\n\tirq = wbsd_read_config(host, WBSD_CONF_IRQ);\n\n\tdma = wbsd_read_config(host, WBSD_CONF_DRQ);\n\n\twbsd_lock_config(host);\n\n\t \n\tif (base != host->base)\n\t\treturn 0;\n\tif (irq != host->irq)\n\t\treturn 0;\n\tif ((dma != host->dma) && (host->dma != -1))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \n\nstatic void wbsd_chip_poweroff(struct wbsd_host *host)\n{\n\twbsd_unlock_config(host);\n\n\twbsd_write_config(host, WBSD_CONF_DEVICE, DEVICE_SD);\n\twbsd_write_config(host, WBSD_CONF_ENABLE, 0);\n\n\twbsd_lock_config(host);\n}\n\n \n\nstatic int wbsd_init(struct device *dev, int base, int irq, int dma,\n\tint pnp)\n{\n\tstruct wbsd_host *host = NULL;\n\tstruct mmc_host *mmc = NULL;\n\tint ret;\n\n\tret = wbsd_alloc_mmc(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc = dev_get_drvdata(dev);\n\thost = mmc_priv(mmc);\n\n\t \n\tret = wbsd_scan(host);\n\tif (ret) {\n\t\tif (pnp && (ret == -ENODEV)) {\n\t\t\tpr_warn(DRIVER_NAME \": Unable to confirm device presence - you may experience lock-ups\\n\");\n\t\t} else {\n\t\t\twbsd_free_mmc(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = wbsd_request_resources(host, base, irq, dma);\n\tif (ret) {\n\t\twbsd_release_resources(host);\n\t\twbsd_free_mmc(dev);\n\t\treturn ret;\n\t}\n\n\t \n\tif (pnp) {\n\t\tif ((host->config != 0) && !wbsd_chip_validate(host)) {\n\t\t\tpr_warn(DRIVER_NAME \": PnP active but chip not configured! You probably have a buggy BIOS. Configuring chip manually.\\n\");\n\t\t\twbsd_chip_config(host);\n\t\t}\n\t} else\n\t\twbsd_chip_config(host);\n\n\t \n#ifdef CONFIG_PM\n\tif (host->config) {\n\t\twbsd_unlock_config(host);\n\t\twbsd_write_config(host, WBSD_CONF_PME, 0xA0);\n\t\twbsd_lock_config(host);\n\t}\n#endif\n\t \n\tmdelay(5);\n\n\t \n\twbsd_init_device(host);\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tif (!pnp)\n\t\t\twbsd_chip_poweroff(host);\n\n\t\twbsd_release_resources(host);\n\t\twbsd_free_mmc(dev);\n\t\treturn ret;\n\t}\n\n\tpr_info(\"%s: W83L51xD\", mmc_hostname(mmc));\n\tif (host->chip_id != 0)\n\t\tprintk(\" id %x\", (int)host->chip_id);\n\tprintk(\" at 0x%x irq %d\", (int)host->base, (int)host->irq);\n\tif (host->dma >= 0)\n\t\tprintk(\" dma %d\", (int)host->dma);\n\telse\n\t\tprintk(\" FIFO\");\n\tif (pnp)\n\t\tprintk(\" PnP\");\n\tprintk(\"\\n\");\n\n\treturn 0;\n}\n\nstatic void wbsd_shutdown(struct device *dev, int pnp)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct wbsd_host *host;\n\n\tif (!mmc)\n\t\treturn;\n\n\thost = mmc_priv(mmc);\n\n\tmmc_remove_host(mmc);\n\n\t \n\tif (!pnp)\n\t\twbsd_chip_poweroff(host);\n\n\twbsd_release_resources(host);\n\n\twbsd_free_mmc(dev);\n}\n\n \n\nstatic int wbsd_probe(struct platform_device *dev)\n{\n\t \n\treturn wbsd_init(&dev->dev, param_io, param_irq, param_dma, 0);\n}\n\nstatic void wbsd_remove(struct platform_device *dev)\n{\n\twbsd_shutdown(&dev->dev, 0);\n}\n\n \n\n#ifdef CONFIG_PNP\n\nstatic int\nwbsd_pnp_probe(struct pnp_dev *pnpdev, const struct pnp_device_id *dev_id)\n{\n\tint io, irq, dma;\n\n\t \n\tio = pnp_port_start(pnpdev, 0);\n\tirq = pnp_irq(pnpdev, 0);\n\tif (pnp_dma_valid(pnpdev, 0))\n\t\tdma = pnp_dma(pnpdev, 0);\n\telse\n\t\tdma = -1;\n\n\tDBGF(\"PnP resources: port %3x irq %d dma %d\\n\", io, irq, dma);\n\n\treturn wbsd_init(&pnpdev->dev, io, irq, dma, 1);\n}\n\nstatic void wbsd_pnp_remove(struct pnp_dev *dev)\n{\n\twbsd_shutdown(&dev->dev, 1);\n}\n\n#endif  \n\n \n\n#ifdef CONFIG_PM\n\nstatic int wbsd_platform_suspend(struct platform_device *dev,\n\t\t\t\t pm_message_t state)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(dev);\n\tstruct wbsd_host *host;\n\n\tif (mmc == NULL)\n\t\treturn 0;\n\n\tDBGF(\"Suspending...\\n\");\n\n\thost = mmc_priv(mmc);\n\n\twbsd_chip_poweroff(host);\n\treturn 0;\n}\n\nstatic int wbsd_platform_resume(struct platform_device *dev)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(dev);\n\tstruct wbsd_host *host;\n\n\tif (mmc == NULL)\n\t\treturn 0;\n\n\tDBGF(\"Resuming...\\n\");\n\n\thost = mmc_priv(mmc);\n\n\twbsd_chip_config(host);\n\n\t \n\tmdelay(5);\n\n\twbsd_init_device(host);\n\treturn 0;\n}\n\n#ifdef CONFIG_PNP\n\nstatic int wbsd_pnp_suspend(struct pnp_dev *pnp_dev, pm_message_t state)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(&pnp_dev->dev);\n\n\tif (mmc == NULL)\n\t\treturn 0;\n\n\tDBGF(\"Suspending...\\n\");\n\treturn 0;\n}\n\nstatic int wbsd_pnp_resume(struct pnp_dev *pnp_dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(&pnp_dev->dev);\n\tstruct wbsd_host *host;\n\n\tif (mmc == NULL)\n\t\treturn 0;\n\n\tDBGF(\"Resuming...\\n\");\n\n\thost = mmc_priv(mmc);\n\n\t \n\tif (host->config != 0) {\n\t\tif (!wbsd_chip_validate(host)) {\n\t\t\tpr_warn(DRIVER_NAME \": PnP active but chip not configured! You probably have a buggy BIOS. Configuring chip manually.\\n\");\n\t\t\twbsd_chip_config(host);\n\t\t}\n\t}\n\n\t \n\tmdelay(5);\n\n\twbsd_init_device(host);\n\treturn 0;\n}\n\n#endif  \n\n#else  \n\n#define wbsd_platform_suspend NULL\n#define wbsd_platform_resume NULL\n\n#define wbsd_pnp_suspend NULL\n#define wbsd_pnp_resume NULL\n\n#endif  \n\nstatic struct platform_device *wbsd_device;\n\nstatic struct platform_driver wbsd_driver = {\n\t.probe\t\t= wbsd_probe,\n\t.remove_new\t= wbsd_remove,\n\t.suspend\t= wbsd_platform_suspend,\n\t.resume\t\t= wbsd_platform_resume,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\n#ifdef CONFIG_PNP\n\nstatic struct pnp_driver wbsd_pnp_driver = {\n\t.name\t\t= DRIVER_NAME,\n\t.id_table\t= pnp_dev_table,\n\t.probe\t\t= wbsd_pnp_probe,\n\t.remove\t\t= wbsd_pnp_remove,\n\n\t.suspend\t= wbsd_pnp_suspend,\n\t.resume\t\t= wbsd_pnp_resume,\n};\n\n#endif  \n\n \n\nstatic int __init wbsd_drv_init(void)\n{\n\tint result;\n\n\tpr_info(DRIVER_NAME\n\t\t\": Winbond W83L51xD SD/MMC card interface driver\\n\");\n\tpr_info(DRIVER_NAME \": Copyright(c) Pierre Ossman\\n\");\n\n#ifdef CONFIG_PNP\n\n\tif (!param_nopnp) {\n\t\tresult = pnp_register_driver(&wbsd_pnp_driver);\n\t\tif (result < 0)\n\t\t\treturn result;\n\t}\n#endif  \n\n\tif (param_nopnp) {\n\t\tresult = platform_driver_register(&wbsd_driver);\n\t\tif (result < 0)\n\t\t\treturn result;\n\n\t\twbsd_device = platform_device_alloc(DRIVER_NAME, -1);\n\t\tif (!wbsd_device) {\n\t\t\tplatform_driver_unregister(&wbsd_driver);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tresult = platform_device_add(wbsd_device);\n\t\tif (result) {\n\t\t\tplatform_device_put(wbsd_device);\n\t\t\tplatform_driver_unregister(&wbsd_driver);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit wbsd_drv_exit(void)\n{\n#ifdef CONFIG_PNP\n\n\tif (!param_nopnp)\n\t\tpnp_unregister_driver(&wbsd_pnp_driver);\n\n#endif  \n\n\tif (param_nopnp) {\n\t\tplatform_device_unregister(wbsd_device);\n\n\t\tplatform_driver_unregister(&wbsd_driver);\n\t}\n\n\tDBG(\"unloaded\\n\");\n}\n\nmodule_init(wbsd_drv_init);\nmodule_exit(wbsd_drv_exit);\n#ifdef CONFIG_PNP\nmodule_param_hw_named(nopnp, param_nopnp, uint, other, 0444);\n#endif\nmodule_param_hw_named(io, param_io, uint, ioport, 0444);\nmodule_param_hw_named(irq, param_irq, uint, irq, 0444);\nmodule_param_hw_named(dma, param_dma, int, dma, 0444);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Pierre Ossman <pierre@ossman.eu>\");\nMODULE_DESCRIPTION(\"Winbond W83L51xD SD/MMC card interface driver\");\n\n#ifdef CONFIG_PNP\nMODULE_PARM_DESC(nopnp, \"Scan for device instead of relying on PNP. (default 0)\");\n#endif\nMODULE_PARM_DESC(io, \"I/O base to allocate. Must be 8 byte aligned. (default 0x248)\");\nMODULE_PARM_DESC(irq, \"IRQ to allocate. (default 6)\");\nMODULE_PARM_DESC(dma, \"DMA channel to allocate. -1 for no DMA. (default 2)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}