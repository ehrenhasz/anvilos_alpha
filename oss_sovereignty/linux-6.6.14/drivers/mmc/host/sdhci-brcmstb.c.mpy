{
  "module_name": "sdhci-brcmstb.c",
  "hash_id": "4013a89ca6db6a7abadffcf148913fae7dc2c012bdf6acc0910ec67a88cb9916",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-brcmstb.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n#include \"cqhci.h\"\n\n#define SDHCI_VENDOR 0x78\n#define  SDHCI_VENDOR_ENHANCED_STRB 0x1\n#define  SDHCI_VENDOR_GATE_SDCLK_EN 0x2\n\n#define BRCMSTB_MATCH_FLAGS_NO_64BIT\t\tBIT(0)\n#define BRCMSTB_MATCH_FLAGS_BROKEN_TIMEOUT\tBIT(1)\n#define BRCMSTB_MATCH_FLAGS_HAS_CLOCK_GATE\tBIT(2)\n\n#define BRCMSTB_PRIV_FLAGS_HAS_CQE\t\tBIT(0)\n#define BRCMSTB_PRIV_FLAGS_GATE_CLOCK\t\tBIT(1)\n\n#define SDHCI_ARASAN_CQE_BASE_ADDR\t\t0x200\n\nstruct sdhci_brcmstb_priv {\n\tvoid __iomem *cfg_regs;\n\tunsigned int flags;\n\tstruct clk *base_clk;\n\tu32 base_freq_hz;\n};\n\nstruct brcmstb_match_priv {\n\tvoid (*hs400es)(struct mmc_host *mmc, struct mmc_ios *ios);\n\tstruct sdhci_ops *ops;\n\tconst unsigned int flags;\n};\n\nstatic inline void enable_clock_gating(struct sdhci_host *host)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, SDHCI_VENDOR);\n\treg |= SDHCI_VENDOR_GATE_SDCLK_EN;\n\tsdhci_writel(host, reg, SDHCI_VENDOR);\n}\n\nstatic void brcmstb_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_brcmstb_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_and_cqhci_reset(host, mask);\n\n\t \n\tif (priv->flags & BRCMSTB_PRIV_FLAGS_GATE_CLOCK)\n\t\tenable_clock_gating(host);\n}\n\nstatic void sdhci_brcmstb_hs400es(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tu32 reg;\n\n\tdev_dbg(mmc_dev(mmc), \"%s(): Setting HS400-Enhanced-Strobe mode\\n\",\n\t\t__func__);\n\treg = readl(host->ioaddr + SDHCI_VENDOR);\n\tif (ios->enhanced_strobe)\n\t\treg |= SDHCI_VENDOR_ENHANCED_STRB;\n\telse\n\t\treg &= ~SDHCI_VENDOR_ENHANCED_STRB;\n\twritel(reg, host->ioaddr + SDHCI_VENDOR);\n}\n\nstatic void sdhci_brcmstb_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tu16 clk;\n\n\thost->mmc->actual_clock = 0;\n\n\tclk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\tif (clock == 0)\n\t\treturn;\n\n\tsdhci_enable_clk(host, clk);\n}\n\nstatic void sdhci_brcmstb_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t    unsigned int timing)\n{\n\tu16 ctrl_2;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s: Setting UHS signaling for %d timing\\n\",\n\t\t__func__, timing);\n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tif ((timing == MMC_TIMING_MMC_HS200) ||\n\t    (timing == MMC_TIMING_UHS_SDR104))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104;\n\telse if (timing == MMC_TIMING_UHS_SDR12)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\telse if (timing == MMC_TIMING_SD_HS ||\n\t\t timing == MMC_TIMING_MMC_HS ||\n\t\t timing == MMC_TIMING_UHS_SDR25)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\telse if (timing == MMC_TIMING_UHS_SDR50)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50;\n\telse if ((timing == MMC_TIMING_UHS_DDR50) ||\n\t\t (timing == MMC_TIMING_MMC_DDR52))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50;\n\telse if (timing == MMC_TIMING_MMC_HS400)\n\t\tctrl_2 |= SDHCI_CTRL_HS400;  \n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n}\n\nstatic void sdhci_brcmstb_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\nstatic void sdhci_brcmstb_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 reg;\n\n\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\twhile (reg & SDHCI_DATA_AVAILABLE) {\n\t\tsdhci_readl(host, SDHCI_BUFFER);\n\t\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\t}\n\n\tsdhci_cqe_enable(mmc);\n}\n\nstatic const struct cqhci_host_ops sdhci_brcmstb_cqhci_ops = {\n\t.enable         = sdhci_brcmstb_cqe_enable,\n\t.disable        = sdhci_cqe_disable,\n\t.dumpregs       = sdhci_brcmstb_dumpregs,\n};\n\nstatic struct sdhci_ops sdhci_brcmstb_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic struct sdhci_ops sdhci_brcmstb_ops_7216 = {\n\t.set_clock = sdhci_brcmstb_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = brcmstb_reset,\n\t.set_uhs_signaling = sdhci_brcmstb_set_uhs_signaling,\n};\n\nstatic struct brcmstb_match_priv match_priv_7425 = {\n\t.flags = BRCMSTB_MATCH_FLAGS_NO_64BIT |\n\tBRCMSTB_MATCH_FLAGS_BROKEN_TIMEOUT,\n\t.ops = &sdhci_brcmstb_ops,\n};\n\nstatic struct brcmstb_match_priv match_priv_7445 = {\n\t.flags = BRCMSTB_MATCH_FLAGS_BROKEN_TIMEOUT,\n\t.ops = &sdhci_brcmstb_ops,\n};\n\nstatic const struct brcmstb_match_priv match_priv_7216 = {\n\t.flags = BRCMSTB_MATCH_FLAGS_HAS_CLOCK_GATE,\n\t.hs400es = sdhci_brcmstb_hs400es,\n\t.ops = &sdhci_brcmstb_ops_7216,\n};\n\nstatic const struct of_device_id __maybe_unused sdhci_brcm_of_match[] = {\n\t{ .compatible = \"brcm,bcm7425-sdhci\", .data = &match_priv_7425 },\n\t{ .compatible = \"brcm,bcm7445-sdhci\", .data = &match_priv_7445 },\n\t{ .compatible = \"brcm,bcm7216-sdhci\", .data = &match_priv_7216 },\n\t{},\n};\n\nstatic u32 sdhci_brcmstb_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\nstatic int sdhci_brcmstb_add_host(struct sdhci_host *host,\n\t\t\t\t  struct sdhci_brcmstb_priv *priv)\n{\n\tstruct cqhci_host *cq_host;\n\tbool dma64;\n\tint ret;\n\n\tif ((priv->flags & BRCMSTB_PRIV_FLAGS_HAS_CQE) == 0)\n\t\treturn sdhci_add_host(host);\n\n\tdev_dbg(mmc_dev(host->mmc), \"CQE is enabled\\n\");\n\thost->mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tcq_host = devm_kzalloc(mmc_dev(host->mmc),\n\t\t\t       sizeof(*cq_host), GFP_KERNEL);\n\tif (!cq_host) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tcq_host->mmio = host->ioaddr + SDHCI_ARASAN_CQE_BASE_ADDR;\n\tcq_host->ops = &sdhci_brcmstb_cqhci_ops;\n\n\tdma64 = host->flags & SDHCI_USE_64_BIT_DMA;\n\tif (dma64) {\n\t\tdev_dbg(mmc_dev(host->mmc), \"Using 64 bit DMA\\n\");\n\t\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\t}\n\n\tret = cqhci_init(cq_host, host->mmc, dma64);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\nstatic int sdhci_brcmstb_probe(struct platform_device *pdev)\n{\n\tconst struct brcmstb_match_priv *match_priv;\n\tstruct sdhci_pltfm_data brcmstb_pdata;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tconst struct of_device_id *match;\n\tstruct sdhci_brcmstb_priv *priv;\n\tu32 actual_clock_mhz;\n\tstruct sdhci_host *host;\n\tstruct clk *clk;\n\tstruct clk *base_clk = NULL;\n\tint res;\n\n\tmatch = of_match_node(sdhci_brcm_of_match, pdev->dev.of_node);\n\tmatch_priv = match->data;\n\n\tdev_dbg(&pdev->dev, \"Probe found match for %s\\n\",  match->compatible);\n\n\tclk = devm_clk_get_optional_enabled(&pdev->dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(clk),\n\t\t\t\t     \"Failed to get and enable clock from Device Tree\\n\");\n\n\tmemset(&brcmstb_pdata, 0, sizeof(brcmstb_pdata));\n\tbrcmstb_pdata.ops = match_priv->ops;\n\thost = sdhci_pltfm_init(pdev, &brcmstb_pdata,\n\t\t\t\tsizeof(struct sdhci_brcmstb_priv));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\tif (device_property_read_bool(&pdev->dev, \"supports-cqe\")) {\n\t\tpriv->flags |= BRCMSTB_PRIV_FLAGS_HAS_CQE;\n\t\tmatch_priv->ops->irq = sdhci_brcmstb_cqhci_irq;\n\t}\n\n\t \n\tpriv->cfg_regs = devm_platform_get_and_ioremap_resource(pdev, 1, NULL);\n\tif (IS_ERR(priv->cfg_regs)) {\n\t\tres = PTR_ERR(priv->cfg_regs);\n\t\tgoto err;\n\t}\n\n\tsdhci_get_of_property(pdev);\n\tres = mmc_of_parse(host->mmc);\n\tif (res)\n\t\tgoto err;\n\n\t \n\tif ((match_priv->flags & BRCMSTB_MATCH_FLAGS_HAS_CLOCK_GATE) &&\n\t    (host->mmc->caps & MMC_CAP_NONREMOVABLE))\n\t\tpriv->flags |= BRCMSTB_PRIV_FLAGS_GATE_CLOCK;\n\n\t \n\tif (match_priv->hs400es &&\n\t    (host->mmc->caps2 & MMC_CAP2_HS400_ES))\n\t\thost->mmc_host_ops.hs400_enhanced_strobe = match_priv->hs400es;\n\n\t \n\tsdhci_read_caps(host);\n\tif (match_priv->flags & BRCMSTB_MATCH_FLAGS_NO_64BIT)\n\t\thost->caps &= ~SDHCI_CAN_64BIT;\n\thost->caps1 &= ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_SDR104 |\n\t\t\t SDHCI_SUPPORT_DDR50);\n\n\tif (match_priv->flags & BRCMSTB_MATCH_FLAGS_BROKEN_TIMEOUT)\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\n\n\t \n\tif (device_property_read_u32(&pdev->dev, \"clock-frequency\",\n\t\t\t\t     &priv->base_freq_hz) != 0)\n\t\tgoto add_host;\n\n\tbase_clk = devm_clk_get_optional(&pdev->dev, \"sdio_freq\");\n\tif (IS_ERR(base_clk)) {\n\t\tdev_warn(&pdev->dev, \"Clock for \\\"sdio_freq\\\" not found\\n\");\n\t\tgoto add_host;\n\t}\n\n\tres = clk_prepare_enable(base_clk);\n\tif (res)\n\t\tgoto err;\n\n\t \n\tclk_set_rate(base_clk, priv->base_freq_hz);\n\tactual_clock_mhz = clk_get_rate(base_clk) / 1000000;\n\n\thost->caps &= ~SDHCI_CLOCK_V3_BASE_MASK;\n\thost->caps |= (actual_clock_mhz << SDHCI_CLOCK_BASE_SHIFT);\n\t \n\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\n\tdev_dbg(&pdev->dev, \"Base Clock Frequency changed to %dMHz\\n\",\n\t\tactual_clock_mhz);\n\tpriv->base_clk = base_clk;\n\nadd_host:\n\tres = sdhci_brcmstb_add_host(host, priv);\n\tif (res)\n\t\tgoto err;\n\n\tpltfm_host->clk = clk;\n\treturn res;\n\nerr:\n\tsdhci_pltfm_free(pdev);\n\tclk_disable_unprepare(base_clk);\n\treturn res;\n}\n\nstatic void sdhci_brcmstb_shutdown(struct platform_device *pdev)\n{\n\tsdhci_pltfm_suspend(&pdev->dev);\n}\n\nMODULE_DEVICE_TABLE(of, sdhci_brcm_of_match);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_brcmstb_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_brcmstb_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\n\tclk_disable_unprepare(priv->base_clk);\n\treturn sdhci_pltfm_suspend(dev);\n}\n\nstatic int sdhci_brcmstb_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_brcmstb_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = sdhci_pltfm_resume(dev);\n\tif (!ret && priv->base_freq_hz) {\n\t\tret = clk_prepare_enable(priv->base_clk);\n\t\t \n\t\tif (!ret &&\n\t\t    (clk_get_rate(priv->base_clk) != priv->base_freq_hz))\n\t\t\tret = clk_set_rate(priv->base_clk, priv->base_freq_hz);\n\t}\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_brcmstb_pmops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_brcmstb_suspend, sdhci_brcmstb_resume)\n};\n\nstatic struct platform_driver sdhci_brcmstb_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-brcmstb\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &sdhci_brcmstb_pmops,\n\t\t.of_match_table = of_match_ptr(sdhci_brcm_of_match),\n\t},\n\t.probe\t\t= sdhci_brcmstb_probe,\n\t.remove_new\t= sdhci_pltfm_remove,\n\t.shutdown\t= sdhci_brcmstb_shutdown,\n};\n\nmodule_platform_driver(sdhci_brcmstb_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for Broadcom BRCMSTB SoCs\");\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}