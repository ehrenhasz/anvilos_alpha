{
  "module_name": "bcm2835.c",
  "hash_id": "7ad9646ce80971eb69cec1252477a648154e99059c21e98a97a03c57478ac511",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/bcm2835.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/time.h>\n#include <linux/workqueue.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n\n#define SDCMD  0x00  \n#define SDARG  0x04  \n#define SDTOUT 0x08  \n#define SDCDIV 0x0c  \n#define SDRSP0 0x10  \n#define SDRSP1 0x14  \n#define SDRSP2 0x18  \n#define SDRSP3 0x1c  \n#define SDHSTS 0x20  \n#define SDVDD  0x30  \n#define SDEDM  0x34  \n#define SDHCFG 0x38  \n#define SDHBCT 0x3c  \n#define SDDATA 0x40  \n#define SDHBLC 0x50  \n\n#define SDCMD_NEW_FLAG\t\t\t0x8000\n#define SDCMD_FAIL_FLAG\t\t\t0x4000\n#define SDCMD_BUSYWAIT\t\t\t0x800\n#define SDCMD_NO_RESPONSE\t\t0x400\n#define SDCMD_LONG_RESPONSE\t\t0x200\n#define SDCMD_WRITE_CMD\t\t\t0x80\n#define SDCMD_READ_CMD\t\t\t0x40\n#define SDCMD_CMD_MASK\t\t\t0x3f\n\n#define SDCDIV_MAX_CDIV\t\t\t0x7ff\n\n#define SDHSTS_BUSY_IRPT\t\t0x400\n#define SDHSTS_BLOCK_IRPT\t\t0x200\n#define SDHSTS_SDIO_IRPT\t\t0x100\n#define SDHSTS_REW_TIME_OUT\t\t0x80\n#define SDHSTS_CMD_TIME_OUT\t\t0x40\n#define SDHSTS_CRC16_ERROR\t\t0x20\n#define SDHSTS_CRC7_ERROR\t\t0x10\n#define SDHSTS_FIFO_ERROR\t\t0x08\n \n \n#define SDHSTS_DATA_FLAG\t\t0x01\n\n#define SDHSTS_TRANSFER_ERROR_MASK\t(SDHSTS_CRC7_ERROR | \\\n\t\t\t\t\t SDHSTS_CRC16_ERROR | \\\n\t\t\t\t\t SDHSTS_REW_TIME_OUT | \\\n\t\t\t\t\t SDHSTS_FIFO_ERROR)\n\n#define SDHSTS_ERROR_MASK\t\t(SDHSTS_CMD_TIME_OUT | \\\n\t\t\t\t\t SDHSTS_TRANSFER_ERROR_MASK)\n\n#define SDHCFG_BUSY_IRPT_EN\tBIT(10)\n#define SDHCFG_BLOCK_IRPT_EN\tBIT(8)\n#define SDHCFG_SDIO_IRPT_EN\tBIT(5)\n#define SDHCFG_DATA_IRPT_EN\tBIT(4)\n#define SDHCFG_SLOW_CARD\tBIT(3)\n#define SDHCFG_WIDE_EXT_BUS\tBIT(2)\n#define SDHCFG_WIDE_INT_BUS\tBIT(1)\n#define SDHCFG_REL_CMD_LINE\tBIT(0)\n\n#define SDVDD_POWER_OFF\t\t0\n#define SDVDD_POWER_ON\t\t1\n\n#define SDEDM_FORCE_DATA_MODE\tBIT(19)\n#define SDEDM_CLOCK_PULSE\tBIT(20)\n#define SDEDM_BYPASS\t\tBIT(21)\n\n#define SDEDM_WRITE_THRESHOLD_SHIFT\t9\n#define SDEDM_READ_THRESHOLD_SHIFT\t14\n#define SDEDM_THRESHOLD_MASK\t\t0x1f\n\n#define SDEDM_FSM_MASK\t\t0xf\n#define SDEDM_FSM_IDENTMODE\t0x0\n#define SDEDM_FSM_DATAMODE\t0x1\n#define SDEDM_FSM_READDATA\t0x2\n#define SDEDM_FSM_WRITEDATA\t0x3\n#define SDEDM_FSM_READWAIT\t0x4\n#define SDEDM_FSM_READCRC\t0x5\n#define SDEDM_FSM_WRITECRC\t0x6\n#define SDEDM_FSM_WRITEWAIT1\t0x7\n#define SDEDM_FSM_POWERDOWN\t0x8\n#define SDEDM_FSM_POWERUP\t0x9\n#define SDEDM_FSM_WRITESTART1\t0xa\n#define SDEDM_FSM_WRITESTART2\t0xb\n#define SDEDM_FSM_GENPULSES\t0xc\n#define SDEDM_FSM_WRITEWAIT2\t0xd\n#define SDEDM_FSM_STARTPOWDOWN\t0xf\n\n#define SDDATA_FIFO_WORDS\t16\n\n#define FIFO_READ_THRESHOLD\t4\n#define FIFO_WRITE_THRESHOLD\t4\n#define SDDATA_FIFO_PIO_BURST\t8\n\n#define PIO_THRESHOLD\t1   \n\nstruct bcm2835_host {\n\tspinlock_t\t\tlock;\n\tstruct mutex\t\tmutex;\n\n\tvoid __iomem\t\t*ioaddr;\n\tu32\t\t\tphys_addr;\n\n\tstruct platform_device\t*pdev;\n\n\tint\t\t\tclock;\t\t \n\tunsigned int\t\tmax_clk;\t \n\tstruct work_struct\tdma_work;\n\tstruct delayed_work\ttimeout_work;\t \n\tstruct sg_mapping_iter\tsg_miter;\t \n\tunsigned int\t\tblocks;\t\t \n\tint\t\t\tirq;\t\t \n\n\tu32\t\t\tns_per_fifo_word;\n\n\t \n\tu32\t\t\thcfg;\n\tu32\t\t\tcdiv;\n\n\tstruct mmc_request\t*mrq;\t\t \n\tstruct mmc_command\t*cmd;\t\t \n\tstruct mmc_data\t\t*data;\t\t \n\tbool\t\t\tdata_complete:1; \n\tbool\t\t\tuse_busy:1;\t \n\tbool\t\t\tuse_sbc:1;\t \n\n\t \n\tbool\t\t\tirq_block;\n\tbool\t\t\tirq_busy;\n\tbool\t\t\tirq_data;\n\n\t \n\tstruct dma_chan\t\t*dma_chan_rxtx;\n\tstruct dma_chan\t\t*dma_chan;\n\tstruct dma_slave_config dma_cfg_rx;\n\tstruct dma_slave_config dma_cfg_tx;\n\tstruct dma_async_tx_descriptor\t*dma_desc;\n\tu32\t\t\tdma_dir;\n\tu32\t\t\tdrain_words;\n\tstruct page\t\t*drain_page;\n\tu32\t\t\tdrain_offset;\n\tbool\t\t\tuse_dma;\n};\n\nstatic void bcm2835_dumpcmd(struct bcm2835_host *host, struct mmc_command *cmd,\n\t\t\t    const char *label)\n{\n\tstruct device *dev = &host->pdev->dev;\n\n\tif (!cmd)\n\t\treturn;\n\n\tdev_dbg(dev, \"%c%s op %d arg 0x%x flags 0x%x - resp %08x %08x %08x %08x, err %d\\n\",\n\t\t(cmd == host->cmd) ? '>' : ' ',\n\t\tlabel, cmd->opcode, cmd->arg, cmd->flags,\n\t\tcmd->resp[0], cmd->resp[1], cmd->resp[2], cmd->resp[3],\n\t\tcmd->error);\n}\n\nstatic void bcm2835_dumpregs(struct bcm2835_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct device *dev = &host->pdev->dev;\n\n\tif (mrq) {\n\t\tbcm2835_dumpcmd(host, mrq->sbc, \"sbc\");\n\t\tbcm2835_dumpcmd(host, mrq->cmd, \"cmd\");\n\t\tif (mrq->data) {\n\t\t\tdev_dbg(dev, \"data blocks %x blksz %x - err %d\\n\",\n\t\t\t\tmrq->data->blocks,\n\t\t\t\tmrq->data->blksz,\n\t\t\t\tmrq->data->error);\n\t\t}\n\t\tbcm2835_dumpcmd(host, mrq->stop, \"stop\");\n\t}\n\n\tdev_dbg(dev, \"=========== REGISTER DUMP ===========\\n\");\n\tdev_dbg(dev, \"SDCMD  0x%08x\\n\", readl(host->ioaddr + SDCMD));\n\tdev_dbg(dev, \"SDARG  0x%08x\\n\", readl(host->ioaddr + SDARG));\n\tdev_dbg(dev, \"SDTOUT 0x%08x\\n\", readl(host->ioaddr + SDTOUT));\n\tdev_dbg(dev, \"SDCDIV 0x%08x\\n\", readl(host->ioaddr + SDCDIV));\n\tdev_dbg(dev, \"SDRSP0 0x%08x\\n\", readl(host->ioaddr + SDRSP0));\n\tdev_dbg(dev, \"SDRSP1 0x%08x\\n\", readl(host->ioaddr + SDRSP1));\n\tdev_dbg(dev, \"SDRSP2 0x%08x\\n\", readl(host->ioaddr + SDRSP2));\n\tdev_dbg(dev, \"SDRSP3 0x%08x\\n\", readl(host->ioaddr + SDRSP3));\n\tdev_dbg(dev, \"SDHSTS 0x%08x\\n\", readl(host->ioaddr + SDHSTS));\n\tdev_dbg(dev, \"SDVDD  0x%08x\\n\", readl(host->ioaddr + SDVDD));\n\tdev_dbg(dev, \"SDEDM  0x%08x\\n\", readl(host->ioaddr + SDEDM));\n\tdev_dbg(dev, \"SDHCFG 0x%08x\\n\", readl(host->ioaddr + SDHCFG));\n\tdev_dbg(dev, \"SDHBCT 0x%08x\\n\", readl(host->ioaddr + SDHBCT));\n\tdev_dbg(dev, \"SDHBLC 0x%08x\\n\", readl(host->ioaddr + SDHBLC));\n\tdev_dbg(dev, \"===========================================\\n\");\n}\n\nstatic void bcm2835_reset_internal(struct bcm2835_host *host)\n{\n\tu32 temp;\n\n\twritel(SDVDD_POWER_OFF, host->ioaddr + SDVDD);\n\twritel(0, host->ioaddr + SDCMD);\n\twritel(0, host->ioaddr + SDARG);\n\twritel(0xf00000, host->ioaddr + SDTOUT);\n\twritel(0, host->ioaddr + SDCDIV);\n\twritel(0x7f8, host->ioaddr + SDHSTS);  \n\twritel(0, host->ioaddr + SDHCFG);\n\twritel(0, host->ioaddr + SDHBCT);\n\twritel(0, host->ioaddr + SDHBLC);\n\n\t \n\ttemp = readl(host->ioaddr + SDEDM);\n\ttemp &= ~((SDEDM_THRESHOLD_MASK << SDEDM_READ_THRESHOLD_SHIFT) |\n\t\t  (SDEDM_THRESHOLD_MASK << SDEDM_WRITE_THRESHOLD_SHIFT));\n\ttemp |= (FIFO_READ_THRESHOLD << SDEDM_READ_THRESHOLD_SHIFT) |\n\t\t(FIFO_WRITE_THRESHOLD << SDEDM_WRITE_THRESHOLD_SHIFT);\n\twritel(temp, host->ioaddr + SDEDM);\n\tmsleep(20);\n\twritel(SDVDD_POWER_ON, host->ioaddr + SDVDD);\n\tmsleep(20);\n\thost->clock = 0;\n\twritel(host->hcfg, host->ioaddr + SDHCFG);\n\twritel(host->cdiv, host->ioaddr + SDCDIV);\n}\n\nstatic void bcm2835_reset(struct mmc_host *mmc)\n{\n\tstruct bcm2835_host *host = mmc_priv(mmc);\n\n\tif (host->dma_chan)\n\t\tdmaengine_terminate_sync(host->dma_chan);\n\thost->dma_chan = NULL;\n\tbcm2835_reset_internal(host);\n}\n\nstatic void bcm2835_finish_command(struct bcm2835_host *host);\n\nstatic void bcm2835_wait_transfer_complete(struct bcm2835_host *host)\n{\n\tint timediff;\n\tu32 alternate_idle;\n\n\talternate_idle = (host->mrq->data->flags & MMC_DATA_READ) ?\n\t\tSDEDM_FSM_READWAIT : SDEDM_FSM_WRITESTART1;\n\n\ttimediff = 0;\n\n\twhile (1) {\n\t\tu32 edm, fsm;\n\n\t\tedm = readl(host->ioaddr + SDEDM);\n\t\tfsm = edm & SDEDM_FSM_MASK;\n\n\t\tif ((fsm == SDEDM_FSM_IDENTMODE) ||\n\t\t    (fsm == SDEDM_FSM_DATAMODE))\n\t\t\tbreak;\n\t\tif (fsm == alternate_idle) {\n\t\t\twritel(edm | SDEDM_FORCE_DATA_MODE,\n\t\t\t       host->ioaddr + SDEDM);\n\t\t\tbreak;\n\t\t}\n\n\t\ttimediff++;\n\t\tif (timediff == 100000) {\n\t\t\tdev_err(&host->pdev->dev,\n\t\t\t\t\"wait_transfer_complete - still waiting after %d retries\\n\",\n\t\t\t\ttimediff);\n\t\t\tbcm2835_dumpregs(host);\n\t\t\thost->mrq->data->error = -ETIMEDOUT;\n\t\t\treturn;\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\nstatic void bcm2835_dma_complete(void *param)\n{\n\tstruct bcm2835_host *host = param;\n\n\tschedule_work(&host->dma_work);\n}\n\nstatic void bcm2835_transfer_block_pio(struct bcm2835_host *host, bool is_read)\n{\n\tsize_t blksize;\n\tunsigned long wait_max;\n\n\tblksize = host->data->blksz;\n\n\twait_max = jiffies + msecs_to_jiffies(500);\n\n\twhile (blksize) {\n\t\tint copy_words;\n\t\tu32 hsts = 0;\n\t\tsize_t len;\n\t\tu32 *buf;\n\n\t\tif (!sg_miter_next(&host->sg_miter)) {\n\t\t\thost->data->error = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = min(host->sg_miter.length, blksize);\n\t\tif (len % 4) {\n\t\t\thost->data->error = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tblksize -= len;\n\t\thost->sg_miter.consumed = len;\n\n\t\tbuf = (u32 *)host->sg_miter.addr;\n\n\t\tcopy_words = len / 4;\n\n\t\twhile (copy_words) {\n\t\t\tint burst_words, words;\n\t\t\tu32 edm;\n\n\t\t\tburst_words = min(SDDATA_FIFO_PIO_BURST, copy_words);\n\t\t\tedm = readl(host->ioaddr + SDEDM);\n\t\t\tif (is_read)\n\t\t\t\twords = ((edm >> 4) & 0x1f);\n\t\t\telse\n\t\t\t\twords = SDDATA_FIFO_WORDS - ((edm >> 4) & 0x1f);\n\n\t\t\tif (words < burst_words) {\n\t\t\t\tint fsm_state = (edm & SDEDM_FSM_MASK);\n\t\t\t\tstruct device *dev = &host->pdev->dev;\n\n\t\t\t\tif ((is_read &&\n\t\t\t\t     (fsm_state != SDEDM_FSM_READDATA &&\n\t\t\t\t      fsm_state != SDEDM_FSM_READWAIT &&\n\t\t\t\t      fsm_state != SDEDM_FSM_READCRC)) ||\n\t\t\t\t    (!is_read &&\n\t\t\t\t     (fsm_state != SDEDM_FSM_WRITEDATA &&\n\t\t\t\t      fsm_state != SDEDM_FSM_WRITESTART1 &&\n\t\t\t\t      fsm_state != SDEDM_FSM_WRITESTART2))) {\n\t\t\t\t\thsts = readl(host->ioaddr + SDHSTS);\n\t\t\t\t\tdev_err(dev, \"fsm %x, hsts %08x\\n\",\n\t\t\t\t\t\tfsm_state, hsts);\n\t\t\t\t\tif (hsts & SDHSTS_ERROR_MASK)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (time_after(jiffies, wait_max)) {\n\t\t\t\t\tdev_err(dev, \"PIO %s timeout - EDM %08x\\n\",\n\t\t\t\t\t\tis_read ? \"read\" : \"write\",\n\t\t\t\t\t\tedm);\n\t\t\t\t\thsts = SDHSTS_REW_TIME_OUT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tndelay((burst_words - words) *\n\t\t\t\t       host->ns_per_fifo_word);\n\t\t\t\tcontinue;\n\t\t\t} else if (words > copy_words) {\n\t\t\t\twords = copy_words;\n\t\t\t}\n\n\t\t\tcopy_words -= words;\n\n\t\t\twhile (words) {\n\t\t\t\tif (is_read)\n\t\t\t\t\t*(buf++) = readl(host->ioaddr + SDDATA);\n\t\t\t\telse\n\t\t\t\t\twritel(*(buf++), host->ioaddr + SDDATA);\n\t\t\t\twords--;\n\t\t\t}\n\t\t}\n\n\t\tif (hsts & SDHSTS_ERROR_MASK)\n\t\t\tbreak;\n\t}\n\n\tsg_miter_stop(&host->sg_miter);\n}\n\nstatic void bcm2835_transfer_pio(struct bcm2835_host *host)\n{\n\tstruct device *dev = &host->pdev->dev;\n\tu32 sdhsts;\n\tbool is_read;\n\n\tis_read = (host->data->flags & MMC_DATA_READ) != 0;\n\tbcm2835_transfer_block_pio(host, is_read);\n\n\tsdhsts = readl(host->ioaddr + SDHSTS);\n\tif (sdhsts & (SDHSTS_CRC16_ERROR |\n\t\t      SDHSTS_CRC7_ERROR |\n\t\t      SDHSTS_FIFO_ERROR)) {\n\t\tdev_err(dev, \"%s transfer error - HSTS %08x\\n\",\n\t\t\tis_read ? \"read\" : \"write\", sdhsts);\n\t\thost->data->error = -EILSEQ;\n\t} else if ((sdhsts & (SDHSTS_CMD_TIME_OUT |\n\t\t\t      SDHSTS_REW_TIME_OUT))) {\n\t\tdev_err(dev, \"%s timeout error - HSTS %08x\\n\",\n\t\t\tis_read ? \"read\" : \"write\", sdhsts);\n\t\thost->data->error = -ETIMEDOUT;\n\t}\n}\n\nstatic\nvoid bcm2835_prepare_dma(struct bcm2835_host *host, struct mmc_data *data)\n{\n\tint sg_len, dir_data, dir_slave;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_chan *dma_chan;\n\n\tdma_chan = host->dma_chan_rxtx;\n\tif (data->flags & MMC_DATA_READ) {\n\t\tdir_data = DMA_FROM_DEVICE;\n\t\tdir_slave = DMA_DEV_TO_MEM;\n\t} else {\n\t\tdir_data = DMA_TO_DEVICE;\n\t\tdir_slave = DMA_MEM_TO_DEV;\n\t}\n\n\t \n\n\thost->drain_words = 0;\n\tif ((data->blocks > 1) && (dir_data == DMA_FROM_DEVICE)) {\n\t\tstruct scatterlist *sg;\n\t\tu32 len;\n\t\tint i;\n\n\t\tlen = min((u32)(FIFO_READ_THRESHOLD - 1) * 4,\n\t\t\t  (u32)data->blocks * data->blksz);\n\n\t\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t\tif (sg_is_last(sg)) {\n\t\t\t\tWARN_ON(sg->length < len);\n\t\t\t\tsg->length -= len;\n\t\t\t\thost->drain_page = sg_page(sg);\n\t\t\t\thost->drain_offset = sg->offset + sg->length;\n\t\t\t}\n\t\t}\n\t\thost->drain_words = len / 4;\n\t}\n\n\t \n\t(void)dmaengine_slave_config(dma_chan,\n\t\t\t\t     (dir_data == DMA_FROM_DEVICE) ?\n\t\t\t\t     &host->dma_cfg_rx :\n\t\t\t\t     &host->dma_cfg_tx);\n\n\tsg_len = dma_map_sg(dma_chan->device->dev, data->sg, data->sg_len,\n\t\t\t    dir_data);\n\tif (!sg_len)\n\t\treturn;\n\n\tdesc = dmaengine_prep_slave_sg(dma_chan, data->sg, sg_len, dir_slave,\n\t\t\t\t       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!desc) {\n\t\tdma_unmap_sg(dma_chan->device->dev, data->sg, sg_len, dir_data);\n\t\treturn;\n\t}\n\n\tdesc->callback = bcm2835_dma_complete;\n\tdesc->callback_param = host;\n\thost->dma_desc = desc;\n\thost->dma_chan = dma_chan;\n\thost->dma_dir = dir_data;\n}\n\nstatic void bcm2835_start_dma(struct bcm2835_host *host)\n{\n\tdmaengine_submit(host->dma_desc);\n\tdma_async_issue_pending(host->dma_chan);\n}\n\nstatic void bcm2835_set_transfer_irqs(struct bcm2835_host *host)\n{\n\tu32 all_irqs = SDHCFG_DATA_IRPT_EN | SDHCFG_BLOCK_IRPT_EN |\n\t\tSDHCFG_BUSY_IRPT_EN;\n\n\tif (host->dma_desc) {\n\t\thost->hcfg = (host->hcfg & ~all_irqs) |\n\t\t\tSDHCFG_BUSY_IRPT_EN;\n\t} else {\n\t\thost->hcfg = (host->hcfg & ~all_irqs) |\n\t\t\tSDHCFG_DATA_IRPT_EN |\n\t\t\tSDHCFG_BUSY_IRPT_EN;\n\t}\n\n\twritel(host->hcfg, host->ioaddr + SDHCFG);\n}\n\nstatic\nvoid bcm2835_prepare_data(struct bcm2835_host *host, struct mmc_command *cmd)\n{\n\tstruct mmc_data *data = cmd->data;\n\n\tWARN_ON(host->data);\n\n\thost->data = data;\n\tif (!data)\n\t\treturn;\n\n\thost->data_complete = false;\n\thost->data->bytes_xfered = 0;\n\n\tif (!host->dma_desc) {\n\t\t \n\t\tint flags = SG_MITER_ATOMIC;\n\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tflags |= SG_MITER_TO_SG;\n\t\telse\n\t\t\tflags |= SG_MITER_FROM_SG;\n\t\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n\t\thost->blocks = data->blocks;\n\t}\n\n\tbcm2835_set_transfer_irqs(host);\n\n\twritel(data->blksz, host->ioaddr + SDHBCT);\n\twritel(data->blocks, host->ioaddr + SDHBLC);\n}\n\nstatic u32 bcm2835_read_wait_sdcmd(struct bcm2835_host *host, u32 max_ms)\n{\n\tstruct device *dev = &host->pdev->dev;\n\tu32 value;\n\tint ret;\n\n\tret = readl_poll_timeout(host->ioaddr + SDCMD, value,\n\t\t\t\t !(value & SDCMD_NEW_FLAG), 1, 10);\n\tif (ret == -ETIMEDOUT)\n\t\t \n\t\tret = readl_poll_timeout(host->ioaddr + SDCMD, value,\n\t\t\t\t\t !(value & SDCMD_NEW_FLAG),\n\t\t\t\t\t 10, max_ms * 1000);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(dev, \"%s: timeout (%d ms)\\n\", __func__, max_ms);\n\n\treturn value;\n}\n\nstatic void bcm2835_finish_request(struct bcm2835_host *host)\n{\n\tstruct dma_chan *terminate_chan = NULL;\n\tstruct mmc_request *mrq;\n\n\tcancel_delayed_work(&host->timeout_work);\n\n\tmrq = host->mrq;\n\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\n\thost->dma_desc = NULL;\n\tterminate_chan = host->dma_chan;\n\thost->dma_chan = NULL;\n\n\tif (terminate_chan) {\n\t\tint err = dmaengine_terminate_all(terminate_chan);\n\n\t\tif (err)\n\t\t\tdev_err(&host->pdev->dev,\n\t\t\t\t\"failed to terminate DMA (%d)\\n\", err);\n\t}\n\n\tmmc_request_done(mmc_from_priv(host), mrq);\n}\n\nstatic\nbool bcm2835_send_command(struct bcm2835_host *host, struct mmc_command *cmd)\n{\n\tstruct device *dev = &host->pdev->dev;\n\tu32 sdcmd, sdhsts;\n\tunsigned long timeout;\n\n\tWARN_ON(host->cmd);\n\n\tsdcmd = bcm2835_read_wait_sdcmd(host, 100);\n\tif (sdcmd & SDCMD_NEW_FLAG) {\n\t\tdev_err(dev, \"previous command never completed.\\n\");\n\t\tbcm2835_dumpregs(host);\n\t\tcmd->error = -EILSEQ;\n\t\tbcm2835_finish_request(host);\n\t\treturn false;\n\t}\n\n\tif (!cmd->data && cmd->busy_timeout > 9000)\n\t\ttimeout = DIV_ROUND_UP(cmd->busy_timeout, 1000) * HZ + HZ;\n\telse\n\t\ttimeout = 10 * HZ;\n\tschedule_delayed_work(&host->timeout_work, timeout);\n\n\thost->cmd = cmd;\n\n\t \n\tsdhsts = readl(host->ioaddr + SDHSTS);\n\tif (sdhsts & SDHSTS_ERROR_MASK)\n\t\twritel(sdhsts, host->ioaddr + SDHSTS);\n\n\tif ((cmd->flags & MMC_RSP_136) && (cmd->flags & MMC_RSP_BUSY)) {\n\t\tdev_err(dev, \"unsupported response type!\\n\");\n\t\tcmd->error = -EINVAL;\n\t\tbcm2835_finish_request(host);\n\t\treturn false;\n\t}\n\n\tbcm2835_prepare_data(host, cmd);\n\n\twritel(cmd->arg, host->ioaddr + SDARG);\n\n\tsdcmd = cmd->opcode & SDCMD_CMD_MASK;\n\n\thost->use_busy = false;\n\tif (!(cmd->flags & MMC_RSP_PRESENT)) {\n\t\tsdcmd |= SDCMD_NO_RESPONSE;\n\t} else {\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tsdcmd |= SDCMD_LONG_RESPONSE;\n\t\tif (cmd->flags & MMC_RSP_BUSY) {\n\t\t\tsdcmd |= SDCMD_BUSYWAIT;\n\t\t\thost->use_busy = true;\n\t\t}\n\t}\n\n\tif (cmd->data) {\n\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\tsdcmd |= SDCMD_WRITE_CMD;\n\t\tif (cmd->data->flags & MMC_DATA_READ)\n\t\t\tsdcmd |= SDCMD_READ_CMD;\n\t}\n\n\twritel(sdcmd | SDCMD_NEW_FLAG, host->ioaddr + SDCMD);\n\n\treturn true;\n}\n\nstatic void bcm2835_transfer_complete(struct bcm2835_host *host)\n{\n\tstruct mmc_data *data;\n\n\tWARN_ON(!host->data_complete);\n\n\tdata = host->data;\n\thost->data = NULL;\n\n\t \n\tif (host->mrq->stop && (data->error || !host->use_sbc)) {\n\t\tif (bcm2835_send_command(host, host->mrq->stop)) {\n\t\t\t \n\t\t\tif (!host->use_busy)\n\t\t\t\tbcm2835_finish_command(host);\n\t\t}\n\t} else {\n\t\tbcm2835_wait_transfer_complete(host);\n\t\tbcm2835_finish_request(host);\n\t}\n}\n\nstatic void bcm2835_finish_data(struct bcm2835_host *host)\n{\n\tstruct device *dev = &host->pdev->dev;\n\tstruct mmc_data *data;\n\n\tdata = host->data;\n\n\thost->hcfg &= ~(SDHCFG_DATA_IRPT_EN | SDHCFG_BLOCK_IRPT_EN);\n\twritel(host->hcfg, host->ioaddr + SDHCFG);\n\n\tdata->bytes_xfered = data->error ? 0 : (data->blksz * data->blocks);\n\n\thost->data_complete = true;\n\n\tif (host->cmd) {\n\t\t \n\t\tdev_dbg(dev, \"Finished early - HSTS %08x\\n\",\n\t\t\treadl(host->ioaddr + SDHSTS));\n\t} else {\n\t\tbcm2835_transfer_complete(host);\n\t}\n}\n\nstatic void bcm2835_finish_command(struct bcm2835_host *host)\n{\n\tstruct device *dev = &host->pdev->dev;\n\tstruct mmc_command *cmd = host->cmd;\n\tu32 sdcmd;\n\n\tsdcmd = bcm2835_read_wait_sdcmd(host, 100);\n\n\t \n\tif (sdcmd & SDCMD_NEW_FLAG) {\n\t\tdev_err(dev, \"command never completed.\\n\");\n\t\tbcm2835_dumpregs(host);\n\t\thost->cmd->error = -EIO;\n\t\tbcm2835_finish_request(host);\n\t\treturn;\n\t} else if (sdcmd & SDCMD_FAIL_FLAG) {\n\t\tu32 sdhsts = readl(host->ioaddr + SDHSTS);\n\n\t\t \n\t\twritel(SDHSTS_ERROR_MASK, host->ioaddr + SDHSTS);\n\n\t\tif (!(sdhsts & SDHSTS_CRC7_ERROR) ||\n\t\t    (host->cmd->opcode != MMC_SEND_OP_COND)) {\n\t\t\tu32 edm, fsm;\n\n\t\t\tif (sdhsts & SDHSTS_CMD_TIME_OUT) {\n\t\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\t\t} else {\n\t\t\t\tdev_err(dev, \"unexpected command %d error\\n\",\n\t\t\t\t\thost->cmd->opcode);\n\t\t\t\tbcm2835_dumpregs(host);\n\t\t\t\thost->cmd->error = -EILSEQ;\n\t\t\t}\n\t\t\tedm = readl(host->ioaddr + SDEDM);\n\t\t\tfsm = edm & SDEDM_FSM_MASK;\n\t\t\tif (fsm == SDEDM_FSM_READWAIT ||\n\t\t\t    fsm == SDEDM_FSM_WRITESTART1)\n\t\t\t\t \n\t\t\t\twritel(edm | SDEDM_FORCE_DATA_MODE,\n\t\t\t\t       host->ioaddr + SDEDM);\n\t\t\tbcm2835_finish_request(host);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tcmd->resp[3 - i] =\n\t\t\t\t\treadl(host->ioaddr + SDRSP0 + i * 4);\n\t\t\t}\n\t\t} else {\n\t\t\tcmd->resp[0] = readl(host->ioaddr + SDRSP0);\n\t\t}\n\t}\n\n\tif (cmd == host->mrq->sbc) {\n\t\t \n\t\thost->cmd = NULL;\n\t\tif (bcm2835_send_command(host, host->mrq->cmd)) {\n\t\t\tif (host->data && host->dma_desc)\n\t\t\t\t \n\t\t\t\tbcm2835_start_dma(host);\n\n\t\t\tif (!host->use_busy)\n\t\t\t\tbcm2835_finish_command(host);\n\t\t}\n\t} else if (cmd == host->mrq->stop) {\n\t\t \n\t\tbcm2835_finish_request(host);\n\t} else {\n\t\t \n\t\thost->cmd = NULL;\n\t\tif (!host->data)\n\t\t\tbcm2835_finish_request(host);\n\t\telse if (host->data_complete)\n\t\t\tbcm2835_transfer_complete(host);\n\t}\n}\n\nstatic void bcm2835_timeout(struct work_struct *work)\n{\n\tstruct delayed_work *d = to_delayed_work(work);\n\tstruct bcm2835_host *host =\n\t\tcontainer_of(d, struct bcm2835_host, timeout_work);\n\tstruct device *dev = &host->pdev->dev;\n\n\tmutex_lock(&host->mutex);\n\n\tif (host->mrq) {\n\t\tdev_err(dev, \"timeout waiting for hardware interrupt.\\n\");\n\t\tbcm2835_dumpregs(host);\n\n\t\tbcm2835_reset(mmc_from_priv(host));\n\n\t\tif (host->data) {\n\t\t\thost->data->error = -ETIMEDOUT;\n\t\t\tbcm2835_finish_data(host);\n\t\t} else {\n\t\t\tif (host->cmd)\n\t\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\t\telse\n\t\t\t\thost->mrq->cmd->error = -ETIMEDOUT;\n\n\t\t\tbcm2835_finish_request(host);\n\t\t}\n\t}\n\n\tmutex_unlock(&host->mutex);\n}\n\nstatic bool bcm2835_check_cmd_error(struct bcm2835_host *host, u32 intmask)\n{\n\tstruct device *dev = &host->pdev->dev;\n\n\tif (!(intmask & SDHSTS_ERROR_MASK))\n\t\treturn false;\n\n\tif (!host->cmd)\n\t\treturn true;\n\n\tdev_err(dev, \"sdhost_busy_irq: intmask %08x\\n\", intmask);\n\tif (intmask & SDHSTS_CRC7_ERROR) {\n\t\thost->cmd->error = -EILSEQ;\n\t} else if (intmask & (SDHSTS_CRC16_ERROR |\n\t\t\t      SDHSTS_FIFO_ERROR)) {\n\t\tif (host->mrq->data)\n\t\t\thost->mrq->data->error = -EILSEQ;\n\t\telse\n\t\t\thost->cmd->error = -EILSEQ;\n\t} else if (intmask & SDHSTS_REW_TIME_OUT) {\n\t\tif (host->mrq->data)\n\t\t\thost->mrq->data->error = -ETIMEDOUT;\n\t\telse\n\t\t\thost->cmd->error = -ETIMEDOUT;\n\t} else if (intmask & SDHSTS_CMD_TIME_OUT) {\n\t\thost->cmd->error = -ETIMEDOUT;\n\t}\n\tbcm2835_dumpregs(host);\n\treturn true;\n}\n\nstatic void bcm2835_check_data_error(struct bcm2835_host *host, u32 intmask)\n{\n\tif (!host->data)\n\t\treturn;\n\tif (intmask & (SDHSTS_CRC16_ERROR | SDHSTS_FIFO_ERROR))\n\t\thost->data->error = -EILSEQ;\n\tif (intmask & SDHSTS_REW_TIME_OUT)\n\t\thost->data->error = -ETIMEDOUT;\n}\n\nstatic void bcm2835_busy_irq(struct bcm2835_host *host)\n{\n\tif (WARN_ON(!host->cmd)) {\n\t\tbcm2835_dumpregs(host);\n\t\treturn;\n\t}\n\n\tif (WARN_ON(!host->use_busy)) {\n\t\tbcm2835_dumpregs(host);\n\t\treturn;\n\t}\n\thost->use_busy = false;\n\n\tbcm2835_finish_command(host);\n}\n\nstatic void bcm2835_data_irq(struct bcm2835_host *host, u32 intmask)\n{\n\t \n\tif (!host->data)\n\t\treturn;\n\n\tbcm2835_check_data_error(host, intmask);\n\tif (host->data->error)\n\t\tgoto finished;\n\n\tif (host->data->flags & MMC_DATA_WRITE) {\n\t\t \n\t\thost->hcfg &= ~(SDHCFG_DATA_IRPT_EN);\n\t\thost->hcfg |= SDHCFG_BLOCK_IRPT_EN;\n\t\twritel(host->hcfg, host->ioaddr + SDHCFG);\n\t\tbcm2835_transfer_pio(host);\n\t} else {\n\t\tbcm2835_transfer_pio(host);\n\t\thost->blocks--;\n\t\tif ((host->blocks == 0) || host->data->error)\n\t\t\tgoto finished;\n\t}\n\treturn;\n\nfinished:\n\thost->hcfg &= ~(SDHCFG_DATA_IRPT_EN | SDHCFG_BLOCK_IRPT_EN);\n\twritel(host->hcfg, host->ioaddr + SDHCFG);\n}\n\nstatic void bcm2835_data_threaded_irq(struct bcm2835_host *host)\n{\n\tif (!host->data)\n\t\treturn;\n\tif ((host->blocks == 0) || host->data->error)\n\t\tbcm2835_finish_data(host);\n}\n\nstatic void bcm2835_block_irq(struct bcm2835_host *host)\n{\n\tif (WARN_ON(!host->data)) {\n\t\tbcm2835_dumpregs(host);\n\t\treturn;\n\t}\n\n\tif (!host->dma_desc) {\n\t\tWARN_ON(!host->blocks);\n\t\tif (host->data->error || (--host->blocks == 0))\n\t\t\tbcm2835_finish_data(host);\n\t\telse\n\t\t\tbcm2835_transfer_pio(host);\n\t} else if (host->data->flags & MMC_DATA_WRITE) {\n\t\tbcm2835_finish_data(host);\n\t}\n}\n\nstatic irqreturn_t bcm2835_irq(int irq, void *dev_id)\n{\n\tirqreturn_t result = IRQ_NONE;\n\tstruct bcm2835_host *host = dev_id;\n\tu32 intmask;\n\n\tspin_lock(&host->lock);\n\n\tintmask = readl(host->ioaddr + SDHSTS);\n\n\twritel(SDHSTS_BUSY_IRPT |\n\t       SDHSTS_BLOCK_IRPT |\n\t       SDHSTS_SDIO_IRPT |\n\t       SDHSTS_DATA_FLAG,\n\t       host->ioaddr + SDHSTS);\n\n\tif (intmask & SDHSTS_BLOCK_IRPT) {\n\t\tbcm2835_check_data_error(host, intmask);\n\t\thost->irq_block = true;\n\t\tresult = IRQ_WAKE_THREAD;\n\t}\n\n\tif (intmask & SDHSTS_BUSY_IRPT) {\n\t\tif (!bcm2835_check_cmd_error(host, intmask)) {\n\t\t\thost->irq_busy = true;\n\t\t\tresult = IRQ_WAKE_THREAD;\n\t\t} else {\n\t\t\tresult = IRQ_HANDLED;\n\t\t}\n\t}\n\n\t \n\tif ((intmask & SDHSTS_DATA_FLAG) &&\n\t    (host->hcfg & SDHCFG_DATA_IRPT_EN)) {\n\t\tbcm2835_data_irq(host, intmask);\n\t\thost->irq_data = true;\n\t\tresult = IRQ_WAKE_THREAD;\n\t}\n\n\tspin_unlock(&host->lock);\n\n\treturn result;\n}\n\nstatic irqreturn_t bcm2835_threaded_irq(int irq, void *dev_id)\n{\n\tstruct bcm2835_host *host = dev_id;\n\tunsigned long flags;\n\tbool block, busy, data;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tblock = host->irq_block;\n\tbusy  = host->irq_busy;\n\tdata  = host->irq_data;\n\thost->irq_block = false;\n\thost->irq_busy  = false;\n\thost->irq_data  = false;\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tmutex_lock(&host->mutex);\n\n\tif (block)\n\t\tbcm2835_block_irq(host);\n\tif (busy)\n\t\tbcm2835_busy_irq(host);\n\tif (data)\n\t\tbcm2835_data_threaded_irq(host);\n\n\tmutex_unlock(&host->mutex);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void bcm2835_dma_complete_work(struct work_struct *work)\n{\n\tstruct bcm2835_host *host =\n\t\tcontainer_of(work, struct bcm2835_host, dma_work);\n\tstruct mmc_data *data;\n\n\tmutex_lock(&host->mutex);\n\n\tdata = host->data;\n\n\tif (host->dma_chan) {\n\t\tdma_unmap_sg(host->dma_chan->device->dev,\n\t\t\t     data->sg, data->sg_len,\n\t\t\t     host->dma_dir);\n\n\t\thost->dma_chan = NULL;\n\t}\n\n\tif (host->drain_words) {\n\t\tvoid *page;\n\t\tu32 *buf;\n\n\t\tif (host->drain_offset & PAGE_MASK) {\n\t\t\thost->drain_page += host->drain_offset >> PAGE_SHIFT;\n\t\t\thost->drain_offset &= ~PAGE_MASK;\n\t\t}\n\t\tpage = kmap_local_page(host->drain_page);\n\t\tbuf = page + host->drain_offset;\n\n\t\twhile (host->drain_words) {\n\t\t\tu32 edm = readl(host->ioaddr + SDEDM);\n\n\t\t\tif ((edm >> 4) & 0x1f)\n\t\t\t\t*(buf++) = readl(host->ioaddr + SDDATA);\n\t\t\thost->drain_words--;\n\t\t}\n\n\t\tkunmap_local(page);\n\t}\n\n\tbcm2835_finish_data(host);\n\n\tmutex_unlock(&host->mutex);\n}\n\nstatic void bcm2835_set_clock(struct bcm2835_host *host, unsigned int clock)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tint div;\n\n\t \n\n\tif (clock < 100000) {\n\t\t \n\t\thost->cdiv = SDCDIV_MAX_CDIV;\n\t\twritel(host->cdiv, host->ioaddr + SDCDIV);\n\t\treturn;\n\t}\n\n\tdiv = host->max_clk / clock;\n\tif (div < 2)\n\t\tdiv = 2;\n\tif ((host->max_clk / div) > clock)\n\t\tdiv++;\n\tdiv -= 2;\n\n\tif (div > SDCDIV_MAX_CDIV)\n\t\tdiv = SDCDIV_MAX_CDIV;\n\n\tclock = host->max_clk / (div + 2);\n\tmmc->actual_clock = clock;\n\n\t \n\n\thost->ns_per_fifo_word = (1000000000 / clock) *\n\t\t((mmc->caps & MMC_CAP_4_BIT_DATA) ? 8 : 32);\n\n\thost->cdiv = div;\n\twritel(host->cdiv, host->ioaddr + SDCDIV);\n\n\t \n\twritel(mmc->actual_clock / 2, host->ioaddr + SDTOUT);\n}\n\nstatic void bcm2835_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct bcm2835_host *host = mmc_priv(mmc);\n\tstruct device *dev = &host->pdev->dev;\n\tu32 edm, fsm;\n\n\t \n\tif (mrq->sbc)\n\t\tmrq->sbc->error = 0;\n\tif (mrq->cmd)\n\t\tmrq->cmd->error = 0;\n\tif (mrq->data)\n\t\tmrq->data->error = 0;\n\tif (mrq->stop)\n\t\tmrq->stop->error = 0;\n\n\tif (mrq->data && !is_power_of_2(mrq->data->blksz)) {\n\t\tdev_err(dev, \"unsupported block size (%d bytes)\\n\",\n\t\t\tmrq->data->blksz);\n\n\t\tif (mrq->cmd)\n\t\t\tmrq->cmd->error = -EINVAL;\n\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tmutex_lock(&host->mutex);\n\n\tWARN_ON(host->mrq);\n\thost->mrq = mrq;\n\n\tedm = readl(host->ioaddr + SDEDM);\n\tfsm = edm & SDEDM_FSM_MASK;\n\n\tif ((fsm != SDEDM_FSM_IDENTMODE) &&\n\t    (fsm != SDEDM_FSM_DATAMODE)) {\n\t\tdev_err(dev, \"previous command (%d) not complete (EDM %08x)\\n\",\n\t\t\treadl(host->ioaddr + SDCMD) & SDCMD_CMD_MASK,\n\t\t\tedm);\n\t\tbcm2835_dumpregs(host);\n\n\t\tif (mrq->cmd)\n\t\t\tmrq->cmd->error = -EILSEQ;\n\n\t\tbcm2835_finish_request(host);\n\t\tmutex_unlock(&host->mutex);\n\t\treturn;\n\t}\n\n\tif (host->use_dma && mrq->data && (mrq->data->blocks > PIO_THRESHOLD))\n\t\tbcm2835_prepare_dma(host, mrq->data);\n\n\thost->use_sbc = !!mrq->sbc && host->mrq->data &&\n\t\t\t(host->mrq->data->flags & MMC_DATA_READ);\n\tif (host->use_sbc) {\n\t\tif (bcm2835_send_command(host, mrq->sbc)) {\n\t\t\tif (!host->use_busy)\n\t\t\t\tbcm2835_finish_command(host);\n\t\t}\n\t} else if (mrq->cmd && bcm2835_send_command(host, mrq->cmd)) {\n\t\tif (host->data && host->dma_desc) {\n\t\t\t \n\t\t\tbcm2835_start_dma(host);\n\t\t}\n\n\t\tif (!host->use_busy)\n\t\t\tbcm2835_finish_command(host);\n\t}\n\n\tmutex_unlock(&host->mutex);\n}\n\nstatic void bcm2835_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct bcm2835_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->mutex);\n\n\tif (!ios->clock || ios->clock != host->clock) {\n\t\tbcm2835_set_clock(host, ios->clock);\n\t\thost->clock = ios->clock;\n\t}\n\n\t \n\thost->hcfg &= ~SDHCFG_WIDE_EXT_BUS;\n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\thost->hcfg |= SDHCFG_WIDE_EXT_BUS;\n\n\thost->hcfg |= SDHCFG_WIDE_INT_BUS;\n\n\t \n\thost->hcfg |= SDHCFG_SLOW_CARD;\n\n\twritel(host->hcfg, host->ioaddr + SDHCFG);\n\n\tmutex_unlock(&host->mutex);\n}\n\nstatic const struct mmc_host_ops bcm2835_ops = {\n\t.request = bcm2835_request,\n\t.set_ios = bcm2835_set_ios,\n\t.card_hw_reset = bcm2835_reset,\n};\n\nstatic int bcm2835_add_host(struct bcm2835_host *host)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tstruct device *dev = &host->pdev->dev;\n\tchar pio_limit_string[20];\n\tint ret;\n\n\tif (!mmc->f_max || mmc->f_max > host->max_clk)\n\t\tmmc->f_max = host->max_clk;\n\tmmc->f_min = host->max_clk / SDCDIV_MAX_CDIV;\n\n\tmmc->max_busy_timeout = ~0 / (mmc->f_max / 1000);\n\n\tdev_dbg(dev, \"f_max %d, f_min %d, max_busy_timeout %d\\n\",\n\t\tmmc->f_max, mmc->f_min, mmc->max_busy_timeout);\n\n\t \n\tmmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\n\t\t     MMC_CAP_NEEDS_POLL | MMC_CAP_HW_RESET | MMC_CAP_CMD23;\n\n\tspin_lock_init(&host->lock);\n\tmutex_init(&host->mutex);\n\n\tif (!host->dma_chan_rxtx) {\n\t\tdev_warn(dev, \"unable to initialise DMA channel. Falling back to PIO\\n\");\n\t\thost->use_dma = false;\n\t} else {\n\t\thost->use_dma = true;\n\n\t\thost->dma_cfg_tx.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\thost->dma_cfg_tx.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\thost->dma_cfg_tx.direction = DMA_MEM_TO_DEV;\n\t\thost->dma_cfg_tx.src_addr = 0;\n\t\thost->dma_cfg_tx.dst_addr = host->phys_addr + SDDATA;\n\n\t\thost->dma_cfg_rx.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\thost->dma_cfg_rx.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\thost->dma_cfg_rx.direction = DMA_DEV_TO_MEM;\n\t\thost->dma_cfg_rx.src_addr = host->phys_addr + SDDATA;\n\t\thost->dma_cfg_rx.dst_addr = 0;\n\n\t\tif (dmaengine_slave_config(host->dma_chan_rxtx,\n\t\t\t\t\t   &host->dma_cfg_tx) != 0 ||\n\t\t    dmaengine_slave_config(host->dma_chan_rxtx,\n\t\t\t\t\t   &host->dma_cfg_rx) != 0)\n\t\t\thost->use_dma = false;\n\t}\n\n\tmmc->max_segs = 128;\n\tmmc->max_req_size = min_t(size_t, 524288, dma_max_mapping_size(dev));\n\tmmc->max_seg_size = mmc->max_req_size;\n\tmmc->max_blk_size = 1024;\n\tmmc->max_blk_count =  65535;\n\n\t \n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\tINIT_WORK(&host->dma_work, bcm2835_dma_complete_work);\n\tINIT_DELAYED_WORK(&host->timeout_work, bcm2835_timeout);\n\n\t \n\thost->hcfg = SDHCFG_BUSY_IRPT_EN;\n\n\tbcm2835_reset_internal(host);\n\n\tret = request_threaded_irq(host->irq, bcm2835_irq,\n\t\t\t\t   bcm2835_threaded_irq,\n\t\t\t\t   0, mmc_hostname(mmc), host);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ %d: %d\\n\", host->irq, ret);\n\t\treturn ret;\n\t}\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tfree_irq(host->irq, host);\n\t\treturn ret;\n\t}\n\n\tpio_limit_string[0] = '\\0';\n\tif (host->use_dma && (PIO_THRESHOLD > 0))\n\t\tsprintf(pio_limit_string, \" (>%d)\", PIO_THRESHOLD);\n\tdev_info(dev, \"loaded - DMA %s%s\\n\",\n\t\t host->use_dma ? \"enabled\" : \"disabled\", pio_limit_string);\n\n\treturn 0;\n}\n\nstatic int bcm2835_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct clk *clk;\n\tstruct bcm2835_host *host;\n\tstruct mmc_host *mmc;\n\tconst __be32 *regaddr_p;\n\tint ret;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\tmmc = mmc_alloc_host(sizeof(*host), dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tmmc->ops = &bcm2835_ops;\n\thost = mmc_priv(mmc);\n\thost->pdev = pdev;\n\tspin_lock_init(&host->lock);\n\n\thost->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->ioaddr)) {\n\t\tret = PTR_ERR(host->ioaddr);\n\t\tgoto err;\n\t}\n\n\t \n\tregaddr_p = of_get_address(pdev->dev.of_node, 0, NULL, NULL);\n\tif (!regaddr_p) {\n\t\tdev_err(dev, \"Can't get phys address\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\thost->phys_addr = be32_to_cpup(regaddr_p);\n\n\thost->dma_chan = NULL;\n\thost->dma_desc = NULL;\n\n\thost->dma_chan_rxtx = dma_request_chan(dev, \"rx-tx\");\n\tif (IS_ERR(host->dma_chan_rxtx)) {\n\t\tret = PTR_ERR(host->dma_chan_rxtx);\n\t\thost->dma_chan_rxtx = NULL;\n\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err;\n\n\t\t \n\t}\n\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(clk), \"could not get clk\\n\");\n\t\tgoto err;\n\t}\n\n\thost->max_clk = clk_get_rate(clk);\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto err;\n\t}\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err;\n\n\tret = bcm2835_add_host(host);\n\tif (ret)\n\t\tgoto err;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tdev_dbg(dev, \"%s -> OK\\n\", __func__);\n\n\treturn 0;\n\nerr:\n\tdev_dbg(dev, \"%s -> err %d\\n\", __func__, ret);\n\tif (host->dma_chan_rxtx)\n\t\tdma_release_channel(host->dma_chan_rxtx);\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void bcm2835_remove(struct platform_device *pdev)\n{\n\tstruct bcm2835_host *host = platform_get_drvdata(pdev);\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\n\tmmc_remove_host(mmc);\n\n\twritel(SDVDD_POWER_OFF, host->ioaddr + SDVDD);\n\n\tfree_irq(host->irq, host);\n\n\tcancel_work_sync(&host->dma_work);\n\tcancel_delayed_work_sync(&host->timeout_work);\n\n\tif (host->dma_chan_rxtx)\n\t\tdma_release_channel(host->dma_chan_rxtx);\n\n\tmmc_free_host(mmc);\n}\n\nstatic const struct of_device_id bcm2835_match[] = {\n\t{ .compatible = \"brcm,bcm2835-sdhost\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, bcm2835_match);\n\nstatic struct platform_driver bcm2835_driver = {\n\t.probe      = bcm2835_probe,\n\t.remove_new = bcm2835_remove,\n\t.driver     = {\n\t\t.name\t\t= \"sdhost-bcm2835\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= bcm2835_match,\n\t},\n};\nmodule_platform_driver(bcm2835_driver);\n\nMODULE_ALIAS(\"platform:sdhost-bcm2835\");\nMODULE_DESCRIPTION(\"BCM2835 SDHost driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Phil Elwell\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}