{
  "module_name": "sdhci_am654.c",
  "hash_id": "ea0f08b35d5532e6787548adf21c3aa20b4c294fa75cbd06cf1739cc75c97f47",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci_am654.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/pm_runtime.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/sys_soc.h>\n\n#include \"cqhci.h\"\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n\n \n#define CTL_CFG_2\t\t0x14\n#define CTL_CFG_3\t\t0x18\n\n#define SLOTTYPE_MASK\t\tGENMASK(31, 30)\n#define SLOTTYPE_EMBEDDED\tBIT(30)\n#define TUNINGFORSDR50_MASK\tBIT(13)\n\n \n#define PHY_CTRL1\t0x100\n#define PHY_CTRL2\t0x104\n#define PHY_CTRL3\t0x108\n#define PHY_CTRL4\t0x10C\n#define PHY_CTRL5\t0x110\n#define PHY_CTRL6\t0x114\n#define PHY_STAT1\t0x130\n#define PHY_STAT2\t0x134\n\n#define IOMUX_ENABLE_SHIFT\t31\n#define IOMUX_ENABLE_MASK\tBIT(IOMUX_ENABLE_SHIFT)\n#define OTAPDLYENA_SHIFT\t20\n#define OTAPDLYENA_MASK\t\tBIT(OTAPDLYENA_SHIFT)\n#define OTAPDLYSEL_SHIFT\t12\n#define OTAPDLYSEL_MASK\t\tGENMASK(15, 12)\n#define STRBSEL_SHIFT\t\t24\n#define STRBSEL_4BIT_MASK\tGENMASK(27, 24)\n#define STRBSEL_8BIT_MASK\tGENMASK(31, 24)\n#define SEL50_SHIFT\t\t8\n#define SEL50_MASK\t\tBIT(SEL50_SHIFT)\n#define SEL100_SHIFT\t\t9\n#define SEL100_MASK\t\tBIT(SEL100_SHIFT)\n#define FREQSEL_SHIFT\t\t8\n#define FREQSEL_MASK\t\tGENMASK(10, 8)\n#define CLKBUFSEL_SHIFT\t\t0\n#define CLKBUFSEL_MASK\t\tGENMASK(2, 0)\n#define DLL_TRIM_ICP_SHIFT\t4\n#define DLL_TRIM_ICP_MASK\tGENMASK(7, 4)\n#define DR_TY_SHIFT\t\t20\n#define DR_TY_MASK\t\tGENMASK(22, 20)\n#define ENDLL_SHIFT\t\t1\n#define ENDLL_MASK\t\tBIT(ENDLL_SHIFT)\n#define DLLRDY_SHIFT\t\t0\n#define DLLRDY_MASK\t\tBIT(DLLRDY_SHIFT)\n#define PDB_SHIFT\t\t0\n#define PDB_MASK\t\tBIT(PDB_SHIFT)\n#define CALDONE_SHIFT\t\t1\n#define CALDONE_MASK\t\tBIT(CALDONE_SHIFT)\n#define RETRIM_SHIFT\t\t17\n#define RETRIM_MASK\t\tBIT(RETRIM_SHIFT)\n#define SELDLYTXCLK_SHIFT\t17\n#define SELDLYTXCLK_MASK\tBIT(SELDLYTXCLK_SHIFT)\n#define SELDLYRXCLK_SHIFT\t16\n#define SELDLYRXCLK_MASK\tBIT(SELDLYRXCLK_SHIFT)\n#define ITAPDLYSEL_SHIFT\t0\n#define ITAPDLYSEL_MASK\t\tGENMASK(4, 0)\n#define ITAPDLYENA_SHIFT\t8\n#define ITAPDLYENA_MASK\t\tBIT(ITAPDLYENA_SHIFT)\n#define ITAPCHGWIN_SHIFT\t9\n#define ITAPCHGWIN_MASK\t\tBIT(ITAPCHGWIN_SHIFT)\n\n#define DRIVER_STRENGTH_50_OHM\t0x0\n#define DRIVER_STRENGTH_33_OHM\t0x1\n#define DRIVER_STRENGTH_66_OHM\t0x2\n#define DRIVER_STRENGTH_100_OHM\t0x3\n#define DRIVER_STRENGTH_40_OHM\t0x4\n\n#define CLOCK_TOO_SLOW_HZ\t50000000\n#define SDHCI_AM654_AUTOSUSPEND_DELAY\t-1\n\n \n#define SDHCI_AM654_CQE_BASE_ADDR 0x200\n\nstatic struct regmap_config sdhci_am654_regmap_config = {\n\t.reg_bits = 32,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.fast_io = true,\n};\n\nstruct timing_data {\n\tconst char *otap_binding;\n\tconst char *itap_binding;\n\tu32 capability;\n};\n\nstatic const struct timing_data td[] = {\n\t[MMC_TIMING_LEGACY]\t= {\"ti,otap-del-sel-legacy\",\n\t\t\t\t   \"ti,itap-del-sel-legacy\",\n\t\t\t\t   0},\n\t[MMC_TIMING_MMC_HS]\t= {\"ti,otap-del-sel-mmc-hs\",\n\t\t\t\t   \"ti,itap-del-sel-mmc-hs\",\n\t\t\t\t   MMC_CAP_MMC_HIGHSPEED},\n\t[MMC_TIMING_SD_HS]\t= {\"ti,otap-del-sel-sd-hs\",\n\t\t\t\t   \"ti,itap-del-sel-sd-hs\",\n\t\t\t\t   MMC_CAP_SD_HIGHSPEED},\n\t[MMC_TIMING_UHS_SDR12]\t= {\"ti,otap-del-sel-sdr12\",\n\t\t\t\t   \"ti,itap-del-sel-sdr12\",\n\t\t\t\t   MMC_CAP_UHS_SDR12},\n\t[MMC_TIMING_UHS_SDR25]\t= {\"ti,otap-del-sel-sdr25\",\n\t\t\t\t   \"ti,itap-del-sel-sdr25\",\n\t\t\t\t   MMC_CAP_UHS_SDR25},\n\t[MMC_TIMING_UHS_SDR50]\t= {\"ti,otap-del-sel-sdr50\",\n\t\t\t\t   NULL,\n\t\t\t\t   MMC_CAP_UHS_SDR50},\n\t[MMC_TIMING_UHS_SDR104]\t= {\"ti,otap-del-sel-sdr104\",\n\t\t\t\t   NULL,\n\t\t\t\t   MMC_CAP_UHS_SDR104},\n\t[MMC_TIMING_UHS_DDR50]\t= {\"ti,otap-del-sel-ddr50\",\n\t\t\t\t   NULL,\n\t\t\t\t   MMC_CAP_UHS_DDR50},\n\t[MMC_TIMING_MMC_DDR52]\t= {\"ti,otap-del-sel-ddr52\",\n\t\t\t\t   \"ti,itap-del-sel-ddr52\",\n\t\t\t\t   MMC_CAP_DDR},\n\t[MMC_TIMING_MMC_HS200]\t= {\"ti,otap-del-sel-hs200\",\n\t\t\t\t   NULL,\n\t\t\t\t   MMC_CAP2_HS200},\n\t[MMC_TIMING_MMC_HS400]\t= {\"ti,otap-del-sel-hs400\",\n\t\t\t\t   NULL,\n\t\t\t\t   MMC_CAP2_HS400},\n};\n\nstruct sdhci_am654_data {\n\tstruct regmap *base;\n\tbool legacy_otapdly;\n\tint otap_del_sel[ARRAY_SIZE(td)];\n\tint itap_del_sel[ARRAY_SIZE(td)];\n\tint clkbuf_sel;\n\tint trm_icp;\n\tint drv_strength;\n\tint strb_sel;\n\tu32 flags;\n\tu32 quirks;\n\n#define SDHCI_AM654_QUIRK_FORCE_CDTEST BIT(0)\n};\n\nstruct sdhci_am654_driver_data {\n\tconst struct sdhci_pltfm_data *pdata;\n\tu32 flags;\n#define IOMUX_PRESENT\t(1 << 0)\n#define FREQSEL_2_BIT\t(1 << 1)\n#define STRBSEL_4_BIT\t(1 << 2)\n#define DLL_PRESENT\t(1 << 3)\n#define DLL_CALIB\t(1 << 4)\n};\n\nstatic void sdhci_am654_setup_dll(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tint sel50, sel100, freqsel;\n\tu32 mask, val;\n\tint ret;\n\n\t \n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5,\n\t\t\t   SELDLYTXCLK_MASK | SELDLYRXCLK_MASK, 0);\n\n\tif (sdhci_am654->flags & FREQSEL_2_BIT) {\n\t\tswitch (clock) {\n\t\tcase 200000000:\n\t\t\tsel50 = 0;\n\t\t\tsel100 = 0;\n\t\t\tbreak;\n\t\tcase 100000000:\n\t\t\tsel50 = 0;\n\t\t\tsel100 = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsel50 = 1;\n\t\t\tsel100 = 0;\n\t\t}\n\n\t\t \n\t\tmask = SEL50_MASK | SEL100_MASK;\n\t\tval = (sel50 << SEL50_SHIFT) | (sel100 << SEL100_SHIFT);\n\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5, mask, val);\n\n\t} else {\n\t\tswitch (clock) {\n\t\tcase 200000000:\n\t\t\tfreqsel = 0x0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tfreqsel = 0x4;\n\t\t}\n\n\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5, FREQSEL_MASK,\n\t\t\t\t   freqsel << FREQSEL_SHIFT);\n\t}\n\t \n\tmask = DLL_TRIM_ICP_MASK;\n\tval = sdhci_am654->trm_icp << DLL_TRIM_ICP_SHIFT;\n\n\t \n\tmask |= DR_TY_MASK;\n\tval |= sdhci_am654->drv_strength << DR_TY_SHIFT;\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1, mask, val);\n\n\t \n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1, ENDLL_MASK,\n\t\t\t   0x1 << ENDLL_SHIFT);\n\t \n\tret = regmap_read_poll_timeout(sdhci_am654->base, PHY_STAT1, val,\n\t\t\t\t       val & DLLRDY_MASK, 1000, 1000000);\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"DLL failed to relock\\n\");\n\t\treturn;\n\t}\n}\n\nstatic void sdhci_am654_write_itapdly(struct sdhci_am654_data *sdhci_am654,\n\t\t\t\t      u32 itapdly)\n{\n\t \n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, ITAPCHGWIN_MASK,\n\t\t\t   1 << ITAPCHGWIN_SHIFT);\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, ITAPDLYSEL_MASK,\n\t\t\t   itapdly << ITAPDLYSEL_SHIFT);\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, ITAPCHGWIN_MASK, 0);\n}\n\nstatic void sdhci_am654_setup_delay_chain(struct sdhci_am654_data *sdhci_am654,\n\t\t\t\t\t  unsigned char timing)\n{\n\tu32 mask, val;\n\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1, ENDLL_MASK, 0);\n\n\tval = 1 << SELDLYTXCLK_SHIFT | 1 << SELDLYRXCLK_SHIFT;\n\tmask = SELDLYTXCLK_MASK | SELDLYRXCLK_MASK;\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5, mask, val);\n\n\tsdhci_am654_write_itapdly(sdhci_am654,\n\t\t\t\t  sdhci_am654->itap_del_sel[timing]);\n}\n\nstatic void sdhci_am654_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tunsigned char timing = host->mmc->ios.timing;\n\tu32 otap_del_sel;\n\tu32 otap_del_ena;\n\tu32 mask, val;\n\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1, ENDLL_MASK, 0);\n\n\tsdhci_set_clock(host, clock);\n\n\t \n\tif (sdhci_am654->legacy_otapdly)\n\t\totap_del_sel = sdhci_am654->otap_del_sel[0];\n\telse\n\t\totap_del_sel = sdhci_am654->otap_del_sel[timing];\n\n\totap_del_ena = (timing > MMC_TIMING_UHS_SDR25) ? 1 : 0;\n\n\tmask = OTAPDLYENA_MASK | OTAPDLYSEL_MASK;\n\tval = (otap_del_ena << OTAPDLYENA_SHIFT) |\n\t      (otap_del_sel << OTAPDLYSEL_SHIFT);\n\n\t \n\tif (timing == MMC_TIMING_MMC_HS400) {\n\t\tif (sdhci_am654->flags & STRBSEL_4_BIT)\n\t\t\tmask |= STRBSEL_4BIT_MASK;\n\t\telse\n\t\t\tmask |= STRBSEL_8BIT_MASK;\n\n\t\tval |= sdhci_am654->strb_sel << STRBSEL_SHIFT;\n\t}\n\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, mask, val);\n\n\tif (timing > MMC_TIMING_UHS_SDR25 && clock >= CLOCK_TOO_SLOW_HZ)\n\t\tsdhci_am654_setup_dll(host, clock);\n\telse\n\t\tsdhci_am654_setup_delay_chain(sdhci_am654, timing);\n\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5, CLKBUFSEL_MASK,\n\t\t\t   sdhci_am654->clkbuf_sel);\n}\n\nstatic void sdhci_j721e_4bit_set_clock(struct sdhci_host *host,\n\t\t\t\t       unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tunsigned char timing = host->mmc->ios.timing;\n\tu32 otap_del_sel;\n\tu32 mask, val;\n\n\t \n\tif (sdhci_am654->legacy_otapdly)\n\t\totap_del_sel = sdhci_am654->otap_del_sel[0];\n\telse\n\t\totap_del_sel = sdhci_am654->otap_del_sel[timing];\n\n\tmask = OTAPDLYENA_MASK | OTAPDLYSEL_MASK;\n\tval = (0x1 << OTAPDLYENA_SHIFT) |\n\t      (otap_del_sel << OTAPDLYSEL_SHIFT);\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, mask, val);\n\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL5, CLKBUFSEL_MASK,\n\t\t\t   sdhci_am654->clkbuf_sel);\n\n\tsdhci_set_clock(host, clock);\n}\n\nstatic u8 sdhci_am654_write_power_on(struct sdhci_host *host, u8 val, int reg)\n{\n\twriteb(val, host->ioaddr + reg);\n\tusleep_range(1000, 10000);\n\treturn readb(host->ioaddr + reg);\n}\n\n#define MAX_POWER_ON_TIMEOUT\t1500000  \nstatic void sdhci_am654_write_b(struct sdhci_host *host, u8 val, int reg)\n{\n\tunsigned char timing = host->mmc->ios.timing;\n\tu8 pwr;\n\tint ret;\n\n\tif (reg == SDHCI_HOST_CONTROL) {\n\t\tswitch (timing) {\n\t\t \n\t\tcase MMC_TIMING_SD_HS:\n\t\tcase MMC_TIMING_MMC_HS:\n\t\t\tval &= ~SDHCI_CTRL_HISPD;\n\t\t}\n\t}\n\n\twriteb(val, host->ioaddr + reg);\n\tif (reg == SDHCI_POWER_CONTROL && (val & SDHCI_POWER_ON)) {\n\t\t \n\t\tret = read_poll_timeout(sdhci_am654_write_power_on, pwr,\n\t\t\t\t\tpwr & SDHCI_POWER_ON, 0,\n\t\t\t\t\tMAX_POWER_ON_TIMEOUT, false, host, val,\n\t\t\t\t\treg);\n\t\tif (ret)\n\t\t\tdev_info(mmc_dev(host->mmc), \"Power on failed\\n\");\n\t}\n}\n\nstatic void sdhci_am654_reset(struct sdhci_host *host, u8 mask)\n{\n\tu8 ctrl;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_and_cqhci_reset(host, mask);\n\n\tif (sdhci_am654->quirks & SDHCI_AM654_QUIRK_FORCE_CDTEST) {\n\t\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\t\tctrl |= SDHCI_CTRL_CDTEST_INS | SDHCI_CTRL_CDTEST_EN;\n\t\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n\t}\n}\n\nstatic int sdhci_am654_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tint err = sdhci_execute_tuning(mmc, opcode);\n\n\tif (err)\n\t\treturn err;\n\t \n\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\n\treturn 0;\n}\n\nstatic u32 sdhci_am654_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\n#define ITAP_MAX\t32\nstatic int sdhci_am654_platform_execute_tuning(struct sdhci_host *host,\n\t\t\t\t\t       u32 opcode)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tint cur_val, prev_val = 1, fail_len = 0, pass_window = 0, pass_len;\n\tu32 itap;\n\n\t \n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, ITAPDLYENA_MASK,\n\t\t\t   1 << ITAPDLYENA_SHIFT);\n\n\tfor (itap = 0; itap < ITAP_MAX; itap++) {\n\t\tsdhci_am654_write_itapdly(sdhci_am654, itap);\n\n\t\tcur_val = !mmc_send_tuning(host->mmc, opcode, NULL);\n\t\tif (cur_val && !prev_val)\n\t\t\tpass_window = itap;\n\n\t\tif (!cur_val)\n\t\t\tfail_len++;\n\n\t\tprev_val = cur_val;\n\t}\n\t \n\tpass_len = ITAP_MAX - fail_len;\n\titap = (pass_window + (pass_len >> 1)) % ITAP_MAX;\n\tsdhci_am654_write_itapdly(sdhci_am654, itap);\n\n\treturn 0;\n}\n\nstatic struct sdhci_ops sdhci_am654_ops = {\n\t.platform_execute_tuning = sdhci_am654_platform_execute_tuning,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n\t.set_clock = sdhci_am654_set_clock,\n\t.write_b = sdhci_am654_write_b,\n\t.irq = sdhci_am654_cqhci_irq,\n\t.reset = sdhci_and_cqhci_reset,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_am654_pdata = {\n\t.ops = &sdhci_am654_ops,\n\t.quirks = SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n};\n\nstatic const struct sdhci_am654_driver_data sdhci_am654_sr1_drvdata = {\n\t.pdata = &sdhci_am654_pdata,\n\t.flags = IOMUX_PRESENT | FREQSEL_2_BIT | STRBSEL_4_BIT | DLL_PRESENT |\n\t\t DLL_CALIB,\n};\n\nstatic const struct sdhci_am654_driver_data sdhci_am654_drvdata = {\n\t.pdata = &sdhci_am654_pdata,\n\t.flags = IOMUX_PRESENT | FREQSEL_2_BIT | STRBSEL_4_BIT | DLL_PRESENT,\n};\n\nstatic struct sdhci_ops sdhci_j721e_8bit_ops = {\n\t.platform_execute_tuning = sdhci_am654_platform_execute_tuning,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n\t.set_clock = sdhci_am654_set_clock,\n\t.write_b = sdhci_am654_write_b,\n\t.irq = sdhci_am654_cqhci_irq,\n\t.reset = sdhci_and_cqhci_reset,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_j721e_8bit_pdata = {\n\t.ops = &sdhci_j721e_8bit_ops,\n\t.quirks = SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n};\n\nstatic const struct sdhci_am654_driver_data sdhci_j721e_8bit_drvdata = {\n\t.pdata = &sdhci_j721e_8bit_pdata,\n\t.flags = DLL_PRESENT | DLL_CALIB,\n};\n\nstatic struct sdhci_ops sdhci_j721e_4bit_ops = {\n\t.platform_execute_tuning = sdhci_am654_platform_execute_tuning,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n\t.set_clock = sdhci_j721e_4bit_set_clock,\n\t.write_b = sdhci_am654_write_b,\n\t.irq = sdhci_am654_cqhci_irq,\n\t.reset = sdhci_am654_reset,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_j721e_4bit_pdata = {\n\t.ops = &sdhci_j721e_4bit_ops,\n\t.quirks = SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n};\n\nstatic const struct sdhci_am654_driver_data sdhci_j721e_4bit_drvdata = {\n\t.pdata = &sdhci_j721e_4bit_pdata,\n\t.flags = IOMUX_PRESENT,\n};\n\nstatic const struct soc_device_attribute sdhci_am654_devices[] = {\n\t{ .family = \"AM65X\",\n\t  .revision = \"SR1.0\",\n\t  .data = &sdhci_am654_sr1_drvdata\n\t},\n\t{ }\n};\n\nstatic void sdhci_am654_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\nstatic const struct cqhci_host_ops sdhci_am654_cqhci_ops = {\n\t.enable\t\t= sdhci_cqe_enable,\n\t.disable\t= sdhci_cqe_disable,\n\t.dumpregs\t= sdhci_am654_dumpregs,\n};\n\nstatic int sdhci_am654_cqe_add_host(struct sdhci_host *host)\n{\n\tstruct cqhci_host *cq_host;\n\n\tcq_host = devm_kzalloc(mmc_dev(host->mmc), sizeof(struct cqhci_host),\n\t\t\t       GFP_KERNEL);\n\tif (!cq_host)\n\t\treturn -ENOMEM;\n\n\tcq_host->mmio = host->ioaddr + SDHCI_AM654_CQE_BASE_ADDR;\n\tcq_host->quirks |= CQHCI_QUIRK_SHORT_TXFR_DESC_SZ;\n\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\tcq_host->ops = &sdhci_am654_cqhci_ops;\n\n\thost->mmc->caps2 |= MMC_CAP2_CQE;\n\n\treturn cqhci_init(cq_host, host->mmc, 1);\n}\n\nstatic int sdhci_am654_get_otap_delay(struct sdhci_host *host,\n\t\t\t\t      struct sdhci_am654_data *sdhci_am654)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\tint i;\n\tint ret;\n\n\tret = device_property_read_u32(dev, td[MMC_TIMING_LEGACY].otap_binding,\n\t\t\t\t &sdhci_am654->otap_del_sel[MMC_TIMING_LEGACY]);\n\tif (ret) {\n\t\t \n\t\tret = device_property_read_u32(dev, \"ti,otap-del-sel\",\n\t\t\t\t\t       &sdhci_am654->otap_del_sel[0]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Couldn't find otap-del-sel\\n\");\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tdev_info(dev, \"Using legacy binding ti,otap-del-sel\\n\");\n\t\tsdhci_am654->legacy_otapdly = true;\n\n\t\treturn 0;\n\t}\n\n\tfor (i = MMC_TIMING_LEGACY; i <= MMC_TIMING_MMC_HS400; i++) {\n\n\t\tret = device_property_read_u32(dev, td[i].otap_binding,\n\t\t\t\t\t       &sdhci_am654->otap_del_sel[i]);\n\t\tif (ret) {\n\t\t\tdev_dbg(dev, \"Couldn't find %s\\n\",\n\t\t\t\ttd[i].otap_binding);\n\t\t\t \n\t\t\tif (i <= MMC_TIMING_MMC_DDR52)\n\t\t\t\thost->mmc->caps &= ~td[i].capability;\n\t\t\telse\n\t\t\t\thost->mmc->caps2 &= ~td[i].capability;\n\t\t}\n\n\t\tif (td[i].itap_binding)\n\t\t\tdevice_property_read_u32(dev, td[i].itap_binding,\n\t\t\t\t\t\t &sdhci_am654->itap_del_sel[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_am654_init(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tu32 ctl_cfg_2 = 0;\n\tu32 mask;\n\tu32 val;\n\tint ret;\n\n\t \n\tmask = OTAPDLYENA_MASK | OTAPDLYSEL_MASK;\n\tregmap_update_bits(sdhci_am654->base, PHY_CTRL4, mask, 0x0);\n\n\tif (sdhci_am654->flags & DLL_CALIB) {\n\t\tregmap_read(sdhci_am654->base, PHY_STAT1, &val);\n\t\tif (~val & CALDONE_MASK) {\n\t\t\t \n\t\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1,\n\t\t\t\t\t   PDB_MASK, PDB_MASK);\n\t\t\tret = regmap_read_poll_timeout(sdhci_am654->base,\n\t\t\t\t\t\t       PHY_STAT1, val,\n\t\t\t\t\t\t       val & CALDONE_MASK,\n\t\t\t\t\t\t       1, 20);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (sdhci_am654->flags & IOMUX_PRESENT)\n\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1,\n\t\t\t\t   IOMUX_ENABLE_MASK, 0);\n\n\t \n\tif (host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t\tctl_cfg_2 = SLOTTYPE_EMBEDDED;\n\n\tregmap_update_bits(sdhci_am654->base, CTL_CFG_2, SLOTTYPE_MASK,\n\t\t\t   ctl_cfg_2);\n\n\t \n\tregmap_update_bits(sdhci_am654->base, CTL_CFG_3, TUNINGFORSDR50_MASK,\n\t\t\t   TUNINGFORSDR50_MASK);\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdhci_am654_cqe_add_host(host);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\tret = sdhci_am654_get_otap_delay(host, sdhci_am654);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\treturn 0;\n\nerr_cleanup_host:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\nstatic int sdhci_am654_get_of_property(struct platform_device *pdev,\n\t\t\t\t\tstruct sdhci_am654_data *sdhci_am654)\n{\n\tstruct device *dev = &pdev->dev;\n\tint drv_strength;\n\tint ret;\n\n\tif (sdhci_am654->flags & DLL_PRESENT) {\n\t\tret = device_property_read_u32(dev, \"ti,trm-icp\",\n\t\t\t\t\t       &sdhci_am654->trm_icp);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = device_property_read_u32(dev, \"ti,driver-strength-ohm\",\n\t\t\t\t\t       &drv_strength);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tswitch (drv_strength) {\n\t\tcase 50:\n\t\t\tsdhci_am654->drv_strength = DRIVER_STRENGTH_50_OHM;\n\t\t\tbreak;\n\t\tcase 33:\n\t\t\tsdhci_am654->drv_strength = DRIVER_STRENGTH_33_OHM;\n\t\t\tbreak;\n\t\tcase 66:\n\t\t\tsdhci_am654->drv_strength = DRIVER_STRENGTH_66_OHM;\n\t\t\tbreak;\n\t\tcase 100:\n\t\t\tsdhci_am654->drv_strength = DRIVER_STRENGTH_100_OHM;\n\t\t\tbreak;\n\t\tcase 40:\n\t\t\tsdhci_am654->drv_strength = DRIVER_STRENGTH_40_OHM;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"Invalid driver strength\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tdevice_property_read_u32(dev, \"ti,strobe-sel\", &sdhci_am654->strb_sel);\n\tdevice_property_read_u32(dev, \"ti,clkbuf-sel\",\n\t\t\t\t &sdhci_am654->clkbuf_sel);\n\n\tif (device_property_read_bool(dev, \"ti,fails-without-test-cd\"))\n\t\tsdhci_am654->quirks |= SDHCI_AM654_QUIRK_FORCE_CDTEST;\n\n\tsdhci_get_of_property(pdev);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id sdhci_am654_of_match[] = {\n\t{\n\t\t.compatible = \"ti,am654-sdhci-5.1\",\n\t\t.data = &sdhci_am654_drvdata,\n\t},\n\t{\n\t\t.compatible = \"ti,j721e-sdhci-8bit\",\n\t\t.data = &sdhci_j721e_8bit_drvdata,\n\t},\n\t{\n\t\t.compatible = \"ti,j721e-sdhci-4bit\",\n\t\t.data = &sdhci_j721e_4bit_drvdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-sdhci-8bit\",\n\t\t.data = &sdhci_j721e_8bit_drvdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am64-sdhci-4bit\",\n\t\t.data = &sdhci_j721e_4bit_drvdata,\n\t},\n\t{\n\t\t.compatible = \"ti,am62-sdhci\",\n\t\t.data = &sdhci_j721e_4bit_drvdata,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sdhci_am654_of_match);\n\nstatic int sdhci_am654_probe(struct platform_device *pdev)\n{\n\tconst struct sdhci_am654_driver_data *drvdata;\n\tconst struct soc_device_attribute *soc;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_am654_data *sdhci_am654;\n\tconst struct of_device_id *match;\n\tstruct sdhci_host *host;\n\tstruct clk *clk_xin;\n\tstruct device *dev = &pdev->dev;\n\tvoid __iomem *base;\n\tint ret;\n\n\tmatch = of_match_node(sdhci_am654_of_match, pdev->dev.of_node);\n\tdrvdata = match->data;\n\n\t \n\tsoc = soc_device_match(sdhci_am654_devices);\n\tif (soc && soc->data)\n\t\tdrvdata = soc->data;\n\n\thost = sdhci_pltfm_init(pdev, drvdata->pdata, sizeof(*sdhci_am654));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tsdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tsdhci_am654->flags = drvdata->flags;\n\n\tclk_xin = devm_clk_get(dev, \"clk_xin\");\n\tif (IS_ERR(clk_xin)) {\n\t\tdev_err(dev, \"clk_xin clock not found.\\n\");\n\t\tret = PTR_ERR(clk_xin);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tpltfm_host->clk = clk_xin;\n\n\tbase = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tsdhci_am654->base = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t\t  &sdhci_am654_regmap_config);\n\tif (IS_ERR(sdhci_am654->base)) {\n\t\tdev_err(dev, \"Failed to initialize regmap\\n\");\n\t\tret = PTR_ERR(sdhci_am654->base);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = sdhci_am654_get_of_property(pdev, sdhci_am654);\n\tif (ret)\n\t\tgoto err_pltfm_free;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"parsing dt failed\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\thost->mmc_host_ops.execute_tuning = sdhci_am654_execute_tuning;\n\n\tpm_runtime_get_noresume(dev);\n\tret = pm_runtime_set_active(dev);\n\tif (ret)\n\t\tgoto pm_put;\n\tpm_runtime_enable(dev);\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret)\n\t\tgoto pm_disable;\n\n\tret = sdhci_am654_init(host);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\t \n\tpm_runtime_set_autosuspend_delay(dev, SDHCI_AM654_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(pltfm_host->clk);\npm_disable:\n\tpm_runtime_disable(dev);\npm_put:\n\tpm_runtime_put_noidle(dev);\nerr_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_am654_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0)\n\t\tdev_err(dev, \"pm_runtime_get_sync() Failed\\n\");\n\n\tsdhci_remove_host(host, true);\n\tclk_disable_unprepare(pltfm_host->clk);\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM\nstatic int sdhci_am654_restore(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_am654_data *sdhci_am654 = sdhci_pltfm_priv(pltfm_host);\n\tu32 ctl_cfg_2 = 0;\n\tu32 val;\n\tint ret;\n\n\tif (sdhci_am654->flags & DLL_CALIB) {\n\t\tregmap_read(sdhci_am654->base, PHY_STAT1, &val);\n\t\tif (~val & CALDONE_MASK) {\n\t\t\t \n\t\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1,\n\t\t\t\t\t   PDB_MASK, PDB_MASK);\n\t\t\tret = regmap_read_poll_timeout(sdhci_am654->base,\n\t\t\t\t\t\t       PHY_STAT1, val,\n\t\t\t\t\t\t       val & CALDONE_MASK,\n\t\t\t\t\t\t       1, 20);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (sdhci_am654->flags & IOMUX_PRESENT)\n\t\tregmap_update_bits(sdhci_am654->base, PHY_CTRL1,\n\t\t\t\t   IOMUX_ENABLE_MASK, 0);\n\n\t \n\tif (host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t\tctl_cfg_2 = SLOTTYPE_EMBEDDED;\n\n\tregmap_update_bits(sdhci_am654->base, CTL_CFG_2, SLOTTYPE_MASK,\n\t\t\t   ctl_cfg_2);\n\n\tregmap_read(sdhci_am654->base, CTL_CFG_3, &val);\n\tif (~val & TUNINGFORSDR50_MASK)\n\t\t \n\t\tregmap_update_bits(sdhci_am654->base, CTL_CFG_3, TUNINGFORSDR50_MASK,\n\t\t\t\t   TUNINGFORSDR50_MASK);\n\n\treturn 0;\n}\n\nstatic int sdhci_am654_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = cqhci_suspend(host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdhci_runtime_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tclk_disable_unprepare(pltfm_host->clk);\n\treturn 0;\n}\n\nstatic int sdhci_am654_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tint ret;\n\n\t \n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdhci_am654_restore(host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdhci_runtime_resume_host(host, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tret = cqhci_resume(host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_am654_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sdhci_am654_runtime_suspend,\n\t\t\t   sdhci_am654_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver sdhci_am654_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-am654\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = &sdhci_am654_dev_pm_ops,\n\t\t.of_match_table = sdhci_am654_of_match,\n\t},\n\t.probe = sdhci_am654_probe,\n\t.remove_new = sdhci_am654_remove,\n};\n\nmodule_platform_driver(sdhci_am654_driver);\n\nMODULE_DESCRIPTION(\"Driver for SDHCI Controller on TI's AM654 devices\");\nMODULE_AUTHOR(\"Faiz Abbas <faiz_abbas@ti.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}