{
  "module_name": "cavium-thunderx.c",
  "hash_id": "0a10dfbf1e274242b919e3a4c28a552ae9bcd6df1fd85e847174c9b0e449190d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/cavium-thunderx.c",
  "human_readable_source": " \n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/mmc/mmc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pci.h>\n#include \"cavium.h\"\n\nstatic void thunder_mmc_acquire_bus(struct cvm_mmc_host *host)\n{\n\tdown(&host->mmc_serializer);\n}\n\nstatic void thunder_mmc_release_bus(struct cvm_mmc_host *host)\n{\n\tup(&host->mmc_serializer);\n}\n\nstatic void thunder_mmc_int_enable(struct cvm_mmc_host *host, u64 val)\n{\n\twriteq(val, host->base + MIO_EMM_INT(host));\n\twriteq(val, host->base + MIO_EMM_INT_EN_SET(host));\n}\n\nstatic int thunder_mmc_register_interrupts(struct cvm_mmc_host *host,\n\t\t\t\t\t   struct pci_dev *pdev)\n{\n\tint nvec, ret, i;\n\n\tnvec = pci_alloc_irq_vectors(pdev, 1, 9, PCI_IRQ_MSIX);\n\tif (nvec < 0)\n\t\treturn nvec;\n\n\t \n\tfor (i = 0; i < nvec; i++) {\n\t\tret = devm_request_irq(&pdev->dev, pci_irq_vector(pdev, i),\n\t\t\t\t       cvm_mmc_interrupt,\n\t\t\t\t       0, cvm_mmc_irq_names[i], host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int thunder_mmc_probe(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *child_node;\n\tstruct cvm_mmc_host *host;\n\tint ret, i = 0;\n\n\thost = devm_kzalloc(dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tpci_set_drvdata(pdev, host);\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_regions(pdev, KBUILD_MODNAME);\n\tif (ret)\n\t\treturn ret;\n\n\thost->base = pcim_iomap(pdev, 0, pci_resource_len(pdev, 0));\n\tif (!host->base) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\t \n\thost->dma_base = host->base;\n\n\thost->reg_off = 0x2000;\n\thost->reg_off_dma = 0x160;\n\n\thost->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\tgoto error;\n\t}\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\tgoto error;\n\thost->sys_freq = clk_get_rate(host->clk);\n\n\tspin_lock_init(&host->irq_handler_lock);\n\tsema_init(&host->mmc_serializer, 1);\n\n\thost->dev = dev;\n\thost->acquire_bus = thunder_mmc_acquire_bus;\n\thost->release_bus = thunder_mmc_release_bus;\n\thost->int_enable = thunder_mmc_int_enable;\n\n\thost->use_sg = true;\n\thost->big_dma_addr = true;\n\thost->need_irq_handler_lock = true;\n\thost->last_slot = -1;\n\n\tret = dma_set_mask(dev, DMA_BIT_MASK(48));\n\tif (ret)\n\t\tgoto error;\n\n\t \n\twriteq(127, host->base + MIO_EMM_INT_EN(host));\n\twriteq(3, host->base + MIO_EMM_DMA_INT_ENA_W1C(host));\n\t \n\twriteq(BIT_ULL(16), host->base + MIO_EMM_DMA_FIFO_CFG(host));\n\n\tret = thunder_mmc_register_interrupts(host, pdev);\n\tif (ret)\n\t\tgoto error;\n\n\tfor_each_child_of_node(node, child_node) {\n\t\t \n\t\tif (of_device_is_compatible(child_node, \"mmc-slot\")) {\n\t\t\thost->slot_pdev[i] = of_platform_device_create(child_node, NULL,\n\t\t\t\t\t\t\t\t       &pdev->dev);\n\t\t\tif (!host->slot_pdev[i])\n\t\t\t\tcontinue;\n\n\t\t\tret = cvm_mmc_of_slot_probe(&host->slot_pdev[i]->dev, host);\n\t\t\tif (ret) {\n\t\t\t\tof_node_put(child_node);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tdev_info(dev, \"probed\\n\");\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < CAVIUM_MAX_MMC; i++) {\n\t\tif (host->slot[i])\n\t\t\tcvm_mmc_of_slot_remove(host->slot[i]);\n\t\tif (host->slot_pdev[i]) {\n\t\t\tget_device(&host->slot_pdev[i]->dev);\n\t\t\tof_platform_device_destroy(&host->slot_pdev[i]->dev, NULL);\n\t\t\tput_device(&host->slot_pdev[i]->dev);\n\t\t}\n\t}\n\tclk_disable_unprepare(host->clk);\n\tpci_release_regions(pdev);\n\treturn ret;\n}\n\nstatic void thunder_mmc_remove(struct pci_dev *pdev)\n{\n\tstruct cvm_mmc_host *host = pci_get_drvdata(pdev);\n\tu64 dma_cfg;\n\tint i;\n\n\tfor (i = 0; i < CAVIUM_MAX_MMC; i++)\n\t\tif (host->slot[i])\n\t\t\tcvm_mmc_of_slot_remove(host->slot[i]);\n\n\tdma_cfg = readq(host->dma_base + MIO_EMM_DMA_CFG(host));\n\tdma_cfg &= ~MIO_EMM_DMA_CFG_EN;\n\twriteq(dma_cfg, host->dma_base + MIO_EMM_DMA_CFG(host));\n\n\tclk_disable_unprepare(host->clk);\n\tpci_release_regions(pdev);\n}\n\nstatic const struct pci_device_id thunder_mmc_id_table[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_CAVIUM, 0xa010) },\n\t{ 0, }   \n};\n\nstatic struct pci_driver thunder_mmc_driver = {\n\t.name = KBUILD_MODNAME,\n\t.id_table = thunder_mmc_id_table,\n\t.probe = thunder_mmc_probe,\n\t.remove = thunder_mmc_remove,\n};\n\nmodule_pci_driver(thunder_mmc_driver);\n\nMODULE_AUTHOR(\"Cavium Inc.\");\nMODULE_DESCRIPTION(\"Cavium ThunderX eMMC Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(pci, thunder_mmc_id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}