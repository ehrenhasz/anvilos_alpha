{
  "module_name": "sdhci_f_sdh30.c",
  "hash_id": "a8ffe8d4b6c6b45e3dac4fa1a0ffd5cfdc7f55808a61e0e1a088a24e85f206a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci_f_sdh30.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/err.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/property.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n\n#include \"sdhci-pltfm.h\"\n#include \"sdhci_f_sdh30.h\"\n\nstruct f_sdhost_priv {\n\tstruct clk *clk_iface;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tu32 vendor_hs200;\n\tstruct device *dev;\n\tbool enable_cmd_dat_delay;\n};\n\nstatic void *sdhci_f_sdhost_priv(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn sdhci_pltfm_priv(pltfm_host);\n}\n\nstatic void sdhci_f_sdh30_soft_voltage_switch(struct sdhci_host *host)\n{\n\tstruct f_sdhost_priv *priv = sdhci_f_sdhost_priv(host);\n\tu32 ctrl = 0;\n\n\tusleep_range(2500, 3000);\n\tctrl = sdhci_readl(host, F_SDH30_IO_CONTROL2);\n\tctrl |= F_SDH30_CRES_O_DN;\n\tsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\n\tctrl |= F_SDH30_MSEL_O_1_8;\n\tsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\n\n\tctrl &= ~F_SDH30_CRES_O_DN;\n\tsdhci_writel(host, ctrl, F_SDH30_IO_CONTROL2);\n\tusleep_range(2500, 3000);\n\n\tif (priv->vendor_hs200) {\n\t\tdev_info(priv->dev, \"%s: setting hs200\\n\", __func__);\n\t\tctrl = sdhci_readl(host, F_SDH30_ESD_CONTROL);\n\t\tctrl |= priv->vendor_hs200;\n\t\tsdhci_writel(host, ctrl, F_SDH30_ESD_CONTROL);\n\t}\n\n\tctrl = sdhci_readl(host, F_SDH30_TUNING_SETTING);\n\tctrl |= F_SDH30_CMD_CHK_DIS;\n\tsdhci_writel(host, ctrl, F_SDH30_TUNING_SETTING);\n}\n\nstatic unsigned int sdhci_f_sdh30_get_min_clock(struct sdhci_host *host)\n{\n\treturn F_SDH30_MIN_CLOCK;\n}\n\nstatic void sdhci_f_sdh30_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct f_sdhost_priv *priv = sdhci_f_sdhost_priv(host);\n\tu32 ctl;\n\n\tif (sdhci_readw(host, SDHCI_CLOCK_CONTROL) == 0)\n\t\tsdhci_writew(host, 0xBC01, SDHCI_CLOCK_CONTROL);\n\n\tsdhci_reset(host, mask);\n\n\tif (priv->enable_cmd_dat_delay) {\n\t\tctl = sdhci_readl(host, F_SDH30_ESD_CONTROL);\n\t\tctl |= F_SDH30_CMD_DAT_DELAY;\n\t\tsdhci_writel(host, ctl, F_SDH30_ESD_CONTROL);\n\t}\n\n\tif ((host->mmc->caps & MMC_CAP_NONREMOVABLE) &&\n\t    !(sdhci_readl(host, SDHCI_PRESENT_STATE) & SDHCI_CARD_PRESENT)) {\n\t\tctl = sdhci_readl(host, F_SDH30_TEST);\n\t\tctl |= F_SDH30_FORCE_CARD_INSERT;\n\t\tsdhci_writel(host, ctl, F_SDH30_TEST);\n\t}\n}\n\nstatic const struct sdhci_ops sdhci_f_sdh30_ops = {\n\t.voltage_switch = sdhci_f_sdh30_soft_voltage_switch,\n\t.get_min_clock = sdhci_f_sdh30_get_min_clock,\n\t.reset = sdhci_f_sdh30_reset,\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_f_sdh30_pltfm_data = {\n\t.ops = &sdhci_f_sdh30_ops,\n\t.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC\n\t\t| SDHCI_QUIRK_INVERTED_WRITE_PROTECT,\n\t.quirks2 = SDHCI_QUIRK2_SUPPORT_SINGLE\n\t\t|  SDHCI_QUIRK2_TUNING_WORK_AROUND,\n};\n\nstatic int sdhci_f_sdh30_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct device *dev = &pdev->dev;\n\tint ctrl = 0, ret = 0;\n\tstruct f_sdhost_priv *priv;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tu32 reg = 0;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_f_sdh30_pltfm_data,\n\t\t\t\tsizeof(struct f_sdhost_priv));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\tpriv->dev = dev;\n\n\tpriv->enable_cmd_dat_delay = device_property_read_bool(dev,\n\t\t\t\t\t\t\"fujitsu,cmd-dat-delay-select\");\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err;\n\n\tif (dev_of_node(dev)) {\n\t\tsdhci_get_of_property(pdev);\n\n\t\tpriv->clk_iface = devm_clk_get(&pdev->dev, \"iface\");\n\t\tif (IS_ERR(priv->clk_iface)) {\n\t\t\tret = PTR_ERR(priv->clk_iface);\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = clk_prepare_enable(priv->clk_iface);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tpriv->clk = devm_clk_get(&pdev->dev, \"core\");\n\t\tif (IS_ERR(priv->clk)) {\n\t\t\tret = PTR_ERR(priv->clk);\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tret = clk_prepare_enable(priv->clk);\n\t\tif (ret)\n\t\t\tgoto err_clk;\n\n\t\tpriv->rst = devm_reset_control_get_optional_shared(dev, NULL);\n\t\tif (IS_ERR(priv->rst)) {\n\t\t\tret = PTR_ERR(priv->rst);\n\t\t\tgoto err_rst;\n\t\t}\n\n\t\tret = reset_control_deassert(priv->rst);\n\t\tif (ret)\n\t\t\tgoto err_rst;\n\t}\n\n\t \n\tctrl = sdhci_readw(host, F_SDH30_AHB_CONFIG);\n\tctrl |= F_SDH30_SIN | F_SDH30_AHB_INCR_16 | F_SDH30_AHB_INCR_8 |\n\t\tF_SDH30_AHB_INCR_4;\n\tctrl &= ~(F_SDH30_AHB_BIGED | F_SDH30_BUSLOCK_EN);\n\tsdhci_writew(host, ctrl, F_SDH30_AHB_CONFIG);\n\n\treg = sdhci_readl(host, F_SDH30_ESD_CONTROL);\n\tsdhci_writel(host, reg & ~F_SDH30_EMMC_RST, F_SDH30_ESD_CONTROL);\n\tmsleep(20);\n\tsdhci_writel(host, reg | F_SDH30_EMMC_RST, F_SDH30_ESD_CONTROL);\n\n\treg = sdhci_readl(host, SDHCI_CAPABILITIES);\n\tif (reg & SDHCI_CAN_DO_8BIT)\n\t\tpriv->vendor_hs200 = F_SDH30_EMMC_HS200;\n\n\tif (!(reg & SDHCI_TIMEOUT_CLK_MASK))\n\t\thost->quirks |= SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK;\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_add_host;\n\n\treturn 0;\n\nerr_add_host:\n\treset_control_assert(priv->rst);\nerr_rst:\n\tclk_disable_unprepare(priv->clk);\nerr_clk:\n\tclk_disable_unprepare(priv->clk_iface);\nerr:\n\tsdhci_pltfm_free(pdev);\n\n\treturn ret;\n}\n\nstatic void sdhci_f_sdh30_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct f_sdhost_priv *priv = sdhci_f_sdhost_priv(host);\n\tstruct clk *clk_iface = priv->clk_iface;\n\tstruct reset_control *rst = priv->rst;\n\tstruct clk *clk = priv->clk;\n\n\tsdhci_pltfm_remove(pdev);\n\n\treset_control_assert(rst);\n\tclk_disable_unprepare(clk);\n\tclk_disable_unprepare(clk_iface);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id f_sdh30_dt_ids[] = {\n\t{ .compatible = \"fujitsu,mb86s70-sdhci-3.0\" },\n\t{ .compatible = \"socionext,f-sdh30-e51-mmc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, f_sdh30_dt_ids);\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id f_sdh30_acpi_ids[] = {\n\t{ \"SCX0002\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, f_sdh30_acpi_ids);\n#endif\n\nstatic struct platform_driver sdhci_f_sdh30_driver = {\n\t.driver = {\n\t\t.name = \"f_sdh30\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(f_sdh30_dt_ids),\n\t\t.acpi_match_table = ACPI_PTR(f_sdh30_acpi_ids),\n\t\t.pm\t= &sdhci_pltfm_pmops,\n\t},\n\t.probe = sdhci_f_sdh30_probe,\n\t.remove_new = sdhci_f_sdh30_remove,\n};\n\nmodule_platform_driver(sdhci_f_sdh30_driver);\n\nMODULE_DESCRIPTION(\"F_SDH30 SD Card Controller driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"FUJITSU SEMICONDUCTOR LTD., Socionext Inc.\");\nMODULE_ALIAS(\"platform:f_sdh30\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}