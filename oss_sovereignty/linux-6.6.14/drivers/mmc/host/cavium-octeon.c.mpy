{
  "module_name": "cavium-octeon.c",
  "hash_id": "2082f5a68b5af859e4041d9ba1ea2c7cc5e5adea07d1771055a6d37e18307bc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/cavium-octeon.c",
  "human_readable_source": " \n#include <linux/dma-mapping.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <asm/octeon/octeon.h>\n#include \"cavium.h\"\n\n#define CVMX_MIO_BOOT_CTL CVMX_ADD_IO_SEG(0x00011800000000D0ull)\n\n \nstatic inline void *phys_to_ptr(u64 address)\n{\n\treturn (void *)(address | (1ull << 63));  \n}\n\n \nstatic void l2c_lock_line(u64 addr)\n{\n\tchar *addr_ptr = phys_to_ptr(addr);\n\n\tasm volatile (\n\t\t\"cache 31, %[line]\"\t \n\t\t::[line] \"m\" (*addr_ptr));\n}\n\n \nstatic void l2c_unlock_line(u64 addr)\n{\n\tchar *addr_ptr = phys_to_ptr(addr);\n\n\tasm volatile (\n\t\t\"cache 23, %[line]\"\t \n\t\t::[line] \"m\" (*addr_ptr));\n}\n\n \nstatic void l2c_lock_mem_region(u64 start, u64 len)\n{\n\tu64 end;\n\n\t \n\tend = ALIGN(start + len - 1, CVMX_CACHE_LINE_SIZE);\n\tstart = ALIGN(start, CVMX_CACHE_LINE_SIZE);\n\n\twhile (start <= end) {\n\t\tl2c_lock_line(start);\n\t\tstart += CVMX_CACHE_LINE_SIZE;\n\t}\n\tasm volatile(\"sync\");\n}\n\n \nstatic void l2c_unlock_mem_region(u64 start, u64 len)\n{\n\tu64 end;\n\n\t \n\tend = ALIGN(start + len - 1, CVMX_CACHE_LINE_SIZE);\n\tstart = ALIGN(start, CVMX_CACHE_LINE_SIZE);\n\n\twhile (start <= end) {\n\t\tl2c_unlock_line(start);\n\t\tstart += CVMX_CACHE_LINE_SIZE;\n\t}\n}\n\nstatic void octeon_mmc_acquire_bus(struct cvm_mmc_host *host)\n{\n\tif (!host->has_ciu3) {\n\t\tdown(&octeon_bootbus_sem);\n\t\t \n\t\tif (OCTEON_IS_MODEL(OCTEON_CN70XX))\n\t\t\twriteq(0, (void __iomem *)CVMX_MIO_BOOT_CTL);\n\t} else {\n\t\tdown(&host->mmc_serializer);\n\t}\n}\n\nstatic void octeon_mmc_release_bus(struct cvm_mmc_host *host)\n{\n\tif (!host->has_ciu3)\n\t\tup(&octeon_bootbus_sem);\n\telse\n\t\tup(&host->mmc_serializer);\n}\n\nstatic void octeon_mmc_int_enable(struct cvm_mmc_host *host, u64 val)\n{\n\twriteq(val, host->base + MIO_EMM_INT(host));\n\tif (!host->has_ciu3)\n\t\twriteq(val, host->base + MIO_EMM_INT_EN(host));\n}\n\nstatic void octeon_mmc_set_shared_power(struct cvm_mmc_host *host, int dir)\n{\n\tif (dir == 0)\n\t\tif (!atomic_dec_return(&host->shared_power_users))\n\t\t\tgpiod_set_value_cansleep(host->global_pwr_gpiod, 0);\n\tif (dir == 1)\n\t\tif (atomic_inc_return(&host->shared_power_users) == 1)\n\t\t\tgpiod_set_value_cansleep(host->global_pwr_gpiod, 1);\n}\n\nstatic void octeon_mmc_dmar_fixup(struct cvm_mmc_host *host,\n\t\t\t\t  struct mmc_command *cmd,\n\t\t\t\t  struct mmc_data *data,\n\t\t\t\t  u64 addr)\n{\n\tif (cmd->opcode != MMC_WRITE_MULTIPLE_BLOCK)\n\t\treturn;\n\tif (data->blksz * data->blocks <= 1024)\n\t\treturn;\n\n\thost->n_minus_one = addr + (data->blksz * data->blocks) - 1024;\n\tl2c_lock_mem_region(host->n_minus_one, 512);\n}\n\nstatic void octeon_mmc_dmar_fixup_done(struct cvm_mmc_host *host)\n{\n\tif (!host->n_minus_one)\n\t\treturn;\n\tl2c_unlock_mem_region(host->n_minus_one, 512);\n\thost->n_minus_one = 0;\n}\n\nstatic int octeon_mmc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *cn, *node = pdev->dev.of_node;\n\tstruct cvm_mmc_host *host;\n\tvoid __iomem *base;\n\tint mmc_irq[9];\n\tint i, ret = 0;\n\tu64 val;\n\n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&host->irq_handler_lock);\n\tsema_init(&host->mmc_serializer, 1);\n\n\thost->dev = &pdev->dev;\n\thost->acquire_bus = octeon_mmc_acquire_bus;\n\thost->release_bus = octeon_mmc_release_bus;\n\thost->int_enable = octeon_mmc_int_enable;\n\thost->set_shared_power = octeon_mmc_set_shared_power;\n\tif (OCTEON_IS_MODEL(OCTEON_CN6XXX) ||\n\t    OCTEON_IS_MODEL(OCTEON_CNF7XXX)) {\n\t\thost->dmar_fixup = octeon_mmc_dmar_fixup;\n\t\thost->dmar_fixup_done = octeon_mmc_dmar_fixup_done;\n\t}\n\n\thost->sys_freq = octeon_get_io_clock_rate();\n\n\tif (of_device_is_compatible(node, \"cavium,octeon-7890-mmc\")) {\n\t\thost->big_dma_addr = true;\n\t\thost->need_irq_handler_lock = true;\n\t\thost->has_ciu3 = true;\n\t\thost->use_sg = true;\n\t\t \n\t\tfor (i = 0; i < 9; i++) {\n\t\t\tmmc_irq[i] = platform_get_irq(pdev, i);\n\t\t\tif (mmc_irq[i] < 0)\n\t\t\t\treturn mmc_irq[i];\n\n\t\t\t \n\t\t\tirq_set_irq_type(mmc_irq[i], IRQ_TYPE_EDGE_RISING);\n\t\t}\n\t} else {\n\t\thost->big_dma_addr = false;\n\t\thost->need_irq_handler_lock = false;\n\t\thost->has_ciu3 = false;\n\t\t \n\t\tfor (i = 0; i < 2; i++) {\n\t\t\tmmc_irq[i] = platform_get_irq(pdev, i);\n\t\t\tif (mmc_irq[i] < 0)\n\t\t\t\treturn mmc_irq[i];\n\t\t}\n\t}\n\n\thost->last_slot = -1;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\thost->base = base;\n\thost->reg_off = 0;\n\n\tbase = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\thost->dma_base = base;\n\t \n\thost->reg_off_dma = -0x20;\n\n\tret = dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tval = readq(host->base + MIO_EMM_INT(host));\n\twriteq(val, host->base + MIO_EMM_INT(host));\n\n\tif (host->has_ciu3) {\n\t\t \n\t\tfor (i = 1; i <= 4; i++) {\n\t\t\tret = devm_request_irq(&pdev->dev, mmc_irq[i],\n\t\t\t\t\t       cvm_mmc_interrupt,\n\t\t\t\t\t       0, cvm_mmc_irq_names[i], host);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(&pdev->dev, \"Error: devm_request_irq %d\\n\",\n\t\t\t\t\tmmc_irq[i]);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = devm_request_irq(&pdev->dev, mmc_irq[0],\n\t\t\t\t       cvm_mmc_interrupt, 0, KBUILD_MODNAME,\n\t\t\t\t       host);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error: devm_request_irq %d\\n\",\n\t\t\t\tmmc_irq[0]);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thost->global_pwr_gpiod = devm_gpiod_get_optional(&pdev->dev,\n\t\t\t\t\t\t\t \"power\",\n\t\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(host->global_pwr_gpiod)) {\n\t\tdev_err(&pdev->dev, \"Invalid power GPIO\\n\");\n\t\treturn PTR_ERR(host->global_pwr_gpiod);\n\t}\n\n\tplatform_set_drvdata(pdev, host);\n\n\ti = 0;\n\tfor_each_child_of_node(node, cn) {\n\t\thost->slot_pdev[i] =\n\t\t\tof_platform_device_create(cn, NULL, &pdev->dev);\n\t\tif (!host->slot_pdev[i]) {\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tret = cvm_mmc_of_slot_probe(&host->slot_pdev[i]->dev, host);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Error populating slots\\n\");\n\t\t\tocteon_mmc_set_shared_power(host, 0);\n\t\t\tof_node_put(cn);\n\t\t\tgoto error;\n\t\t}\n\t\ti++;\n\t}\n\treturn 0;\n\nerror:\n\tfor (i = 0; i < CAVIUM_MAX_MMC; i++) {\n\t\tif (host->slot[i])\n\t\t\tcvm_mmc_of_slot_remove(host->slot[i]);\n\t\tif (host->slot_pdev[i])\n\t\t\tof_platform_device_destroy(&host->slot_pdev[i]->dev, NULL);\n\t}\n\treturn ret;\n}\n\nstatic void octeon_mmc_remove(struct platform_device *pdev)\n{\n\tstruct cvm_mmc_host *host = platform_get_drvdata(pdev);\n\tu64 dma_cfg;\n\tint i;\n\n\tfor (i = 0; i < CAVIUM_MAX_MMC; i++)\n\t\tif (host->slot[i])\n\t\t\tcvm_mmc_of_slot_remove(host->slot[i]);\n\n\tdma_cfg = readq(host->dma_base + MIO_EMM_DMA_CFG(host));\n\tdma_cfg &= ~MIO_EMM_DMA_CFG_EN;\n\twriteq(dma_cfg, host->dma_base + MIO_EMM_DMA_CFG(host));\n\n\tocteon_mmc_set_shared_power(host, 0);\n}\n\nstatic const struct of_device_id octeon_mmc_match[] = {\n\t{\n\t\t.compatible = \"cavium,octeon-6130-mmc\",\n\t},\n\t{\n\t\t.compatible = \"cavium,octeon-7890-mmc\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, octeon_mmc_match);\n\nstatic struct platform_driver octeon_mmc_driver = {\n\t.probe\t\t= octeon_mmc_probe,\n\t.remove_new\t= octeon_mmc_remove,\n\t.driver\t\t= {\n\t\t.name\t= KBUILD_MODNAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = octeon_mmc_match,\n\t},\n};\n\nmodule_platform_driver(octeon_mmc_driver);\n\nMODULE_AUTHOR(\"Cavium Inc. <support@cavium.com>\");\nMODULE_DESCRIPTION(\"Low-level driver for Cavium OCTEON MMC/SSD card\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}