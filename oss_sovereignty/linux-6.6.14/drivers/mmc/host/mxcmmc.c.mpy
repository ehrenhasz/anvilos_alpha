{
  "module_name": "mxcmmc.c",
  "hash_id": "22f1470c5ced721e3633dbd68e32f6fa28ea99760796975b3a02cfd5fb22c4f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mxcmmc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/delay.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/regulator/consumer.h>\n#include <linux/dmaengine.h>\n#include <linux/types.h>\n#include <linux/of.h>\n#include <linux/of_dma.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include <asm/dma.h>\n#include <asm/irq.h>\n#include <linux/platform_data/mmc-mxcmmc.h>\n\n#include <linux/dma/imx-dma.h>\n\n#define DRIVER_NAME \"mxc-mmc\"\n#define MXCMCI_TIMEOUT_MS 10000\n\n#define MMC_REG_STR_STP_CLK\t\t0x00\n#define MMC_REG_STATUS\t\t\t0x04\n#define MMC_REG_CLK_RATE\t\t0x08\n#define MMC_REG_CMD_DAT_CONT\t\t0x0C\n#define MMC_REG_RES_TO\t\t\t0x10\n#define MMC_REG_READ_TO\t\t\t0x14\n#define MMC_REG_BLK_LEN\t\t\t0x18\n#define MMC_REG_NOB\t\t\t0x1C\n#define MMC_REG_REV_NO\t\t\t0x20\n#define MMC_REG_INT_CNTR\t\t0x24\n#define MMC_REG_CMD\t\t\t0x28\n#define MMC_REG_ARG\t\t\t0x2C\n#define MMC_REG_RES_FIFO\t\t0x34\n#define MMC_REG_BUFFER_ACCESS\t\t0x38\n\n#define STR_STP_CLK_RESET               (1 << 3)\n#define STR_STP_CLK_START_CLK           (1 << 1)\n#define STR_STP_CLK_STOP_CLK            (1 << 0)\n\n#define STATUS_CARD_INSERTION\t\t(1 << 31)\n#define STATUS_CARD_REMOVAL\t\t(1 << 30)\n#define STATUS_YBUF_EMPTY\t\t(1 << 29)\n#define STATUS_XBUF_EMPTY\t\t(1 << 28)\n#define STATUS_YBUF_FULL\t\t(1 << 27)\n#define STATUS_XBUF_FULL\t\t(1 << 26)\n#define STATUS_BUF_UND_RUN\t\t(1 << 25)\n#define STATUS_BUF_OVFL\t\t\t(1 << 24)\n#define STATUS_SDIO_INT_ACTIVE\t\t(1 << 14)\n#define STATUS_END_CMD_RESP\t\t(1 << 13)\n#define STATUS_WRITE_OP_DONE\t\t(1 << 12)\n#define STATUS_DATA_TRANS_DONE\t\t(1 << 11)\n#define STATUS_READ_OP_DONE\t\t(1 << 11)\n#define STATUS_WR_CRC_ERROR_CODE_MASK\t(3 << 10)\n#define STATUS_CARD_BUS_CLK_RUN\t\t(1 << 8)\n#define STATUS_BUF_READ_RDY\t\t(1 << 7)\n#define STATUS_BUF_WRITE_RDY\t\t(1 << 6)\n#define STATUS_RESP_CRC_ERR\t\t(1 << 5)\n#define STATUS_CRC_READ_ERR\t\t(1 << 3)\n#define STATUS_CRC_WRITE_ERR\t\t(1 << 2)\n#define STATUS_TIME_OUT_RESP\t\t(1 << 1)\n#define STATUS_TIME_OUT_READ\t\t(1 << 0)\n#define STATUS_ERR_MASK\t\t\t0x2f\n\n#define CMD_DAT_CONT_CMD_RESP_LONG_OFF\t(1 << 12)\n#define CMD_DAT_CONT_STOP_READWAIT\t(1 << 11)\n#define CMD_DAT_CONT_START_READWAIT\t(1 << 10)\n#define CMD_DAT_CONT_BUS_WIDTH_4\t(2 << 8)\n#define CMD_DAT_CONT_INIT\t\t(1 << 7)\n#define CMD_DAT_CONT_WRITE\t\t(1 << 4)\n#define CMD_DAT_CONT_DATA_ENABLE\t(1 << 3)\n#define CMD_DAT_CONT_RESPONSE_48BIT_CRC\t(1 << 0)\n#define CMD_DAT_CONT_RESPONSE_136BIT\t(2 << 0)\n#define CMD_DAT_CONT_RESPONSE_48BIT\t(3 << 0)\n\n#define INT_SDIO_INT_WKP_EN\t\t(1 << 18)\n#define INT_CARD_INSERTION_WKP_EN\t(1 << 17)\n#define INT_CARD_REMOVAL_WKP_EN\t\t(1 << 16)\n#define INT_CARD_INSERTION_EN\t\t(1 << 15)\n#define INT_CARD_REMOVAL_EN\t\t(1 << 14)\n#define INT_SDIO_IRQ_EN\t\t\t(1 << 13)\n#define INT_DAT0_EN\t\t\t(1 << 12)\n#define INT_BUF_READ_EN\t\t\t(1 << 4)\n#define INT_BUF_WRITE_EN\t\t(1 << 3)\n#define INT_END_CMD_RES_EN\t\t(1 << 2)\n#define INT_WRITE_OP_DONE_EN\t\t(1 << 1)\n#define INT_READ_OP_EN\t\t\t(1 << 0)\n\nenum mxcmci_type {\n\tIMX21_MMC,\n\tIMX31_MMC,\n\tMPC512X_MMC,\n};\n\nstruct mxcmci_host {\n\tstruct mmc_host\t\t*mmc;\n\tvoid __iomem\t\t*base;\n\tdma_addr_t\t\tphys_base;\n\tint\t\t\tdetect_irq;\n\tstruct dma_chan\t\t*dma;\n\tstruct dma_async_tx_descriptor *desc;\n\tint\t\t\tdo_dma;\n\tint\t\t\tdefault_irq_mask;\n\tint\t\t\tuse_sdio;\n\tunsigned int\t\tpower_mode;\n\tstruct imxmmc_platform_data *pdata;\n\n\tstruct mmc_request\t*req;\n\tstruct mmc_command\t*cmd;\n\tstruct mmc_data\t\t*data;\n\n\tunsigned int\t\tdatasize;\n\tunsigned int\t\tdma_dir;\n\n\tu16\t\t\trev_no;\n\tunsigned int\t\tcmdat;\n\n\tstruct clk\t\t*clk_ipg;\n\tstruct clk\t\t*clk_per;\n\n\tint\t\t\tclock;\n\n\tstruct work_struct\tdatawork;\n\tspinlock_t\t\tlock;\n\n\tint\t\t\tburstlen;\n\tint\t\t\tdmareq;\n\tstruct dma_slave_config dma_slave_config;\n\tstruct imx_dma_data\tdma_data;\n\n\tstruct timer_list\twatchdog;\n\tenum mxcmci_type\tdevtype;\n};\n\nstatic const struct of_device_id mxcmci_of_match[] = {\n\t{\n\t\t.compatible = \"fsl,imx21-mmc\",\n\t\t.data = (void *) IMX21_MMC,\n\t}, {\n\t\t.compatible = \"fsl,imx31-mmc\",\n\t\t.data = (void *) IMX31_MMC,\n\t}, {\n\t\t.compatible = \"fsl,mpc5121-sdhc\",\n\t\t.data = (void *) MPC512X_MMC,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, mxcmci_of_match);\n\nstatic inline int is_imx31_mmc(struct mxcmci_host *host)\n{\n\treturn host->devtype == IMX31_MMC;\n}\n\nstatic inline int is_mpc512x_mmc(struct mxcmci_host *host)\n{\n\treturn host->devtype == MPC512X_MMC;\n}\n\nstatic inline u32 mxcmci_readl(struct mxcmci_host *host, int reg)\n{\n\tif (IS_ENABLED(CONFIG_PPC_MPC512x))\n\t\treturn ioread32be(host->base + reg);\n\telse\n\t\treturn readl(host->base + reg);\n}\n\nstatic inline void mxcmci_writel(struct mxcmci_host *host, u32 val, int reg)\n{\n\tif (IS_ENABLED(CONFIG_PPC_MPC512x))\n\t\tiowrite32be(val, host->base + reg);\n\telse\n\t\twritel(val, host->base + reg);\n}\n\nstatic inline u16 mxcmci_readw(struct mxcmci_host *host, int reg)\n{\n\tif (IS_ENABLED(CONFIG_PPC_MPC512x))\n\t\treturn ioread32be(host->base + reg);\n\telse\n\t\treturn readw(host->base + reg);\n}\n\nstatic inline void mxcmci_writew(struct mxcmci_host *host, u16 val, int reg)\n{\n\tif (IS_ENABLED(CONFIG_PPC_MPC512x))\n\t\tiowrite32be(val, host->base + reg);\n\telse\n\t\twritew(val, host->base + reg);\n}\n\nstatic void mxcmci_set_clk_rate(struct mxcmci_host *host, unsigned int clk_ios);\n\nstatic void mxcmci_set_power(struct mxcmci_host *host, unsigned int vdd)\n{\n\tif (!IS_ERR(host->mmc->supply.vmmc)) {\n\t\tif (host->power_mode == MMC_POWER_UP)\n\t\t\tmmc_regulator_set_ocr(host->mmc,\n\t\t\t\t\t      host->mmc->supply.vmmc, vdd);\n\t\telse if (host->power_mode == MMC_POWER_OFF)\n\t\t\tmmc_regulator_set_ocr(host->mmc,\n\t\t\t\t\t      host->mmc->supply.vmmc, 0);\n\t}\n\n\tif (host->pdata && host->pdata->setpower)\n\t\thost->pdata->setpower(mmc_dev(host->mmc), vdd);\n}\n\nstatic inline int mxcmci_use_dma(struct mxcmci_host *host)\n{\n\treturn host->do_dma;\n}\n\nstatic void mxcmci_softreset(struct mxcmci_host *host)\n{\n\tint i;\n\n\tdev_dbg(mmc_dev(host->mmc), \"mxcmci_softreset\\n\");\n\n\t \n\tmxcmci_writew(host, STR_STP_CLK_RESET, MMC_REG_STR_STP_CLK);\n\tmxcmci_writew(host, STR_STP_CLK_RESET | STR_STP_CLK_START_CLK,\n\t\t\tMMC_REG_STR_STP_CLK);\n\n\tfor (i = 0; i < 8; i++)\n\t\tmxcmci_writew(host, STR_STP_CLK_START_CLK, MMC_REG_STR_STP_CLK);\n\n\tmxcmci_writew(host, 0xff, MMC_REG_RES_TO);\n}\n\n#if IS_ENABLED(CONFIG_PPC_MPC512x)\nstatic inline void buffer_swap32(u32 *buf, int len)\n{\n\tint i;\n\n\tfor (i = 0; i < ((len + 3) / 4); i++) {\n\t\t*buf = swab32(*buf);\n\t\tbuf++;\n\t}\n}\n\nstatic void mxcmci_swap_buffers(struct mmc_data *data)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i)\n\t\tbuffer_swap32(sg_virt(sg), sg->length);\n}\n#else\nstatic inline void mxcmci_swap_buffers(struct mmc_data *data) {}\n#endif\n\nstatic int mxcmci_setup_data(struct mxcmci_host *host, struct mmc_data *data)\n{\n\tunsigned int nob = data->blocks;\n\tunsigned int blksz = data->blksz;\n\tunsigned int datasize = nob * blksz;\n\tstruct scatterlist *sg;\n\tenum dma_transfer_direction slave_dirn;\n\tint i, nents;\n\n\thost->data = data;\n\tdata->bytes_xfered = 0;\n\n\tmxcmci_writew(host, nob, MMC_REG_NOB);\n\tmxcmci_writew(host, blksz, MMC_REG_BLK_LEN);\n\thost->datasize = datasize;\n\n\tif (!mxcmci_use_dma(host))\n\t\treturn 0;\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (sg->offset & 3 || sg->length & 3 || sg->length < 512) {\n\t\t\thost->do_dma = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\thost->dma_dir = DMA_FROM_DEVICE;\n\t\tslave_dirn = DMA_DEV_TO_MEM;\n\t} else {\n\t\thost->dma_dir = DMA_TO_DEVICE;\n\t\tslave_dirn = DMA_MEM_TO_DEV;\n\n\t\tmxcmci_swap_buffers(data);\n\t}\n\n\tnents = dma_map_sg(host->dma->device->dev, data->sg,\n\t\t\t\t     data->sg_len,  host->dma_dir);\n\tif (nents != data->sg_len)\n\t\treturn -EINVAL;\n\n\thost->desc = dmaengine_prep_slave_sg(host->dma,\n\t\tdata->sg, data->sg_len, slave_dirn,\n\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n\tif (!host->desc) {\n\t\tdma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\n\t\t\t\thost->dma_dir);\n\t\thost->do_dma = 0;\n\t\treturn 0;  \n\t}\n\twmb();\n\n\tdmaengine_submit(host->desc);\n\tdma_async_issue_pending(host->dma);\n\n\tmod_timer(&host->watchdog, jiffies + msecs_to_jiffies(MXCMCI_TIMEOUT_MS));\n\n\treturn 0;\n}\n\nstatic void mxcmci_cmd_done(struct mxcmci_host *host, unsigned int stat);\nstatic void mxcmci_data_done(struct mxcmci_host *host, unsigned int stat);\n\nstatic void mxcmci_dma_callback(void *data)\n{\n\tstruct mxcmci_host *host = data;\n\tu32 stat;\n\n\tdel_timer(&host->watchdog);\n\n\tstat = mxcmci_readl(host, MMC_REG_STATUS);\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s: 0x%08x\\n\", __func__, stat);\n\n\tmxcmci_data_done(host, stat);\n}\n\nstatic int mxcmci_start_cmd(struct mxcmci_host *host, struct mmc_command *cmd,\n\t\tunsigned int cmdat)\n{\n\tu32 int_cntr = host->default_irq_mask;\n\tunsigned long flags;\n\n\tWARN_ON(host->cmd != NULL);\n\thost->cmd = cmd;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_R1:  \n\tcase MMC_RSP_R1B: \n\t\tcmdat |= CMD_DAT_CONT_RESPONSE_48BIT_CRC;\n\t\tbreak;\n\tcase MMC_RSP_R2:  \n\t\tcmdat |= CMD_DAT_CONT_RESPONSE_136BIT;\n\t\tbreak;\n\tcase MMC_RSP_R3:  \n\t\tcmdat |= CMD_DAT_CONT_RESPONSE_48BIT;\n\t\tbreak;\n\tcase MMC_RSP_NONE:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc), \"unhandled response type 0x%x\\n\",\n\t\t\t\tmmc_resp_type(cmd));\n\t\tcmd->error = -EINVAL;\n\t\treturn -EINVAL;\n\t}\n\n\tint_cntr = INT_END_CMD_RES_EN;\n\n\tif (mxcmci_use_dma(host)) {\n\t\tif (host->dma_dir == DMA_FROM_DEVICE) {\n\t\t\thost->desc->callback = mxcmci_dma_callback;\n\t\t\thost->desc->callback_param = host;\n\t\t} else {\n\t\t\tint_cntr |= INT_WRITE_OP_DONE_EN;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (host->use_sdio)\n\t\tint_cntr |= INT_SDIO_IRQ_EN;\n\tmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tmxcmci_writew(host, cmd->opcode, MMC_REG_CMD);\n\tmxcmci_writel(host, cmd->arg, MMC_REG_ARG);\n\tmxcmci_writew(host, cmdat, MMC_REG_CMD_DAT_CONT);\n\n\treturn 0;\n}\n\nstatic void mxcmci_finish_request(struct mxcmci_host *host,\n\t\tstruct mmc_request *req)\n{\n\tu32 int_cntr = host->default_irq_mask;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (host->use_sdio)\n\t\tint_cntr |= INT_SDIO_IRQ_EN;\n\tmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\thost->req = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\n\tmmc_request_done(host->mmc, req);\n}\n\nstatic int mxcmci_finish_data(struct mxcmci_host *host, unsigned int stat)\n{\n\tstruct mmc_data *data = host->data;\n\tint data_error;\n\n\tif (mxcmci_use_dma(host)) {\n\t\tdma_unmap_sg(host->dma->device->dev, data->sg, data->sg_len,\n\t\t\t\thost->dma_dir);\n\t\tmxcmci_swap_buffers(data);\n\t}\n\n\tif (stat & STATUS_ERR_MASK) {\n\t\tdev_dbg(mmc_dev(host->mmc), \"request failed. status: 0x%08x\\n\",\n\t\t\t\tstat);\n\t\tif (stat & STATUS_CRC_READ_ERR) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"%s: -EILSEQ\\n\", __func__);\n\t\t\tdata->error = -EILSEQ;\n\t\t} else if (stat & STATUS_CRC_WRITE_ERR) {\n\t\t\tu32 err_code = (stat >> 9) & 0x3;\n\t\t\tif (err_code == 2) {  \n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"%s: No CRC -ETIMEDOUT\\n\", __func__);\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\t} else {\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"%s: -EILSEQ\\n\", __func__);\n\t\t\t\tdata->error = -EILSEQ;\n\t\t\t}\n\t\t} else if (stat & STATUS_TIME_OUT_READ) {\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"%s: read -ETIMEDOUT\\n\", __func__);\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t} else {\n\t\t\tdev_err(mmc_dev(host->mmc), \"%s: -EIO\\n\", __func__);\n\t\t\tdata->error = -EIO;\n\t\t}\n\t} else {\n\t\tdata->bytes_xfered = host->datasize;\n\t}\n\n\tdata_error = data->error;\n\n\thost->data = NULL;\n\n\treturn data_error;\n}\n\nstatic void mxcmci_read_response(struct mxcmci_host *host, unsigned int stat)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tint i;\n\tu32 a, b, c;\n\n\tif (!cmd)\n\t\treturn;\n\n\tif (stat & STATUS_TIME_OUT_RESP) {\n\t\tdev_dbg(mmc_dev(host->mmc), \"CMD TIMEOUT\\n\");\n\t\tcmd->error = -ETIMEDOUT;\n\t} else if (stat & STATUS_RESP_CRC_ERR && cmd->flags & MMC_RSP_CRC) {\n\t\tdev_dbg(mmc_dev(host->mmc), \"cmd crc error\\n\");\n\t\tcmd->error = -EILSEQ;\n\t}\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\ta = mxcmci_readw(host, MMC_REG_RES_FIFO);\n\t\t\t\tb = mxcmci_readw(host, MMC_REG_RES_FIFO);\n\t\t\t\tcmd->resp[i] = a << 16 | b;\n\t\t\t}\n\t\t} else {\n\t\t\ta = mxcmci_readw(host, MMC_REG_RES_FIFO);\n\t\t\tb = mxcmci_readw(host, MMC_REG_RES_FIFO);\n\t\t\tc = mxcmci_readw(host, MMC_REG_RES_FIFO);\n\t\t\tcmd->resp[0] = a << 24 | b << 8 | c >> 8;\n\t\t}\n\t}\n}\n\nstatic int mxcmci_poll_status(struct mxcmci_host *host, u32 mask)\n{\n\tu32 stat;\n\tunsigned long timeout = jiffies + HZ;\n\n\tdo {\n\t\tstat = mxcmci_readl(host, MMC_REG_STATUS);\n\t\tif (stat & STATUS_ERR_MASK)\n\t\t\treturn stat;\n\t\tif (time_after(jiffies, timeout)) {\n\t\t\tmxcmci_softreset(host);\n\t\t\tmxcmci_set_clk_rate(host, host->clock);\n\t\t\treturn STATUS_TIME_OUT_READ;\n\t\t}\n\t\tif (stat & mask)\n\t\t\treturn 0;\n\t\tcpu_relax();\n\t} while (1);\n}\n\nstatic int mxcmci_pull(struct mxcmci_host *host, void *_buf, int bytes)\n{\n\tunsigned int stat;\n\tu32 *buf = _buf;\n\n\twhile (bytes > 3) {\n\t\tstat = mxcmci_poll_status(host,\n\t\t\t\tSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\n\t\tif (stat)\n\t\t\treturn stat;\n\t\t*buf++ = cpu_to_le32(mxcmci_readl(host, MMC_REG_BUFFER_ACCESS));\n\t\tbytes -= 4;\n\t}\n\n\tif (bytes) {\n\t\tu8 *b = (u8 *)buf;\n\t\tu32 tmp;\n\n\t\tstat = mxcmci_poll_status(host,\n\t\t\t\tSTATUS_BUF_READ_RDY | STATUS_READ_OP_DONE);\n\t\tif (stat)\n\t\t\treturn stat;\n\t\ttmp = cpu_to_le32(mxcmci_readl(host, MMC_REG_BUFFER_ACCESS));\n\t\tmemcpy(b, &tmp, bytes);\n\t}\n\n\treturn 0;\n}\n\nstatic int mxcmci_push(struct mxcmci_host *host, void *_buf, int bytes)\n{\n\tunsigned int stat;\n\tu32 *buf = _buf;\n\n\twhile (bytes > 3) {\n\t\tstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\n\t\tif (stat)\n\t\t\treturn stat;\n\t\tmxcmci_writel(host, cpu_to_le32(*buf++), MMC_REG_BUFFER_ACCESS);\n\t\tbytes -= 4;\n\t}\n\n\tif (bytes) {\n\t\tu8 *b = (u8 *)buf;\n\t\tu32 tmp;\n\n\t\tstat = mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\n\t\tif (stat)\n\t\t\treturn stat;\n\n\t\tmemcpy(&tmp, b, bytes);\n\t\tmxcmci_writel(host, cpu_to_le32(tmp), MMC_REG_BUFFER_ACCESS);\n\t}\n\n\treturn mxcmci_poll_status(host, STATUS_BUF_WRITE_RDY);\n}\n\nstatic int mxcmci_transfer_data(struct mxcmci_host *host)\n{\n\tstruct mmc_data *data = host->req->data;\n\tstruct scatterlist *sg;\n\tint stat, i;\n\n\thost->data = data;\n\thost->datasize = 0;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t\tstat = mxcmci_pull(host, sg_virt(sg), sg->length);\n\t\t\tif (stat)\n\t\t\t\treturn stat;\n\t\t\thost->datasize += sg->length;\n\t\t}\n\t} else {\n\t\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t\tstat = mxcmci_push(host, sg_virt(sg), sg->length);\n\t\t\tif (stat)\n\t\t\t\treturn stat;\n\t\t\thost->datasize += sg->length;\n\t\t}\n\t\tstat = mxcmci_poll_status(host, STATUS_WRITE_OP_DONE);\n\t\tif (stat)\n\t\t\treturn stat;\n\t}\n\treturn 0;\n}\n\nstatic void mxcmci_datawork(struct work_struct *work)\n{\n\tstruct mxcmci_host *host = container_of(work, struct mxcmci_host,\n\t\t\t\t\t\t  datawork);\n\tint datastat = mxcmci_transfer_data(host);\n\n\tmxcmci_writel(host, STATUS_READ_OP_DONE | STATUS_WRITE_OP_DONE,\n\t\tMMC_REG_STATUS);\n\tmxcmci_finish_data(host, datastat);\n\n\tif (host->req->stop) {\n\t\tif (mxcmci_start_cmd(host, host->req->stop, 0)) {\n\t\t\tmxcmci_finish_request(host, host->req);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmxcmci_finish_request(host, host->req);\n\t}\n}\n\nstatic void mxcmci_data_done(struct mxcmci_host *host, unsigned int stat)\n{\n\tstruct mmc_request *req;\n\tint data_error;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (!host->data) {\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\treturn;\n\t}\n\n\tif (!host->req) {\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\treturn;\n\t}\n\n\treq = host->req;\n\tif (!req->stop)\n\t\thost->req = NULL;  \n\n\tdata_error = mxcmci_finish_data(host, stat);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (data_error)\n\t\treturn;\n\n\tmxcmci_read_response(host, stat);\n\thost->cmd = NULL;\n\n\tif (req->stop) {\n\t\tif (mxcmci_start_cmd(host, req->stop, 0)) {\n\t\t\tmxcmci_finish_request(host, req);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmxcmci_finish_request(host, req);\n\t}\n}\n\nstatic void mxcmci_cmd_done(struct mxcmci_host *host, unsigned int stat)\n{\n\tmxcmci_read_response(host, stat);\n\thost->cmd = NULL;\n\n\tif (!host->data && host->req) {\n\t\tmxcmci_finish_request(host, host->req);\n\t\treturn;\n\t}\n\n\t \n\tif (!mxcmci_use_dma(host) && host->data)\n\t\tschedule_work(&host->datawork);\n\n}\n\nstatic irqreturn_t mxcmci_irq(int irq, void *devid)\n{\n\tstruct mxcmci_host *host = devid;\n\tbool sdio_irq;\n\tu32 stat;\n\n\tstat = mxcmci_readl(host, MMC_REG_STATUS);\n\tmxcmci_writel(host,\n\t\tstat & ~(STATUS_SDIO_INT_ACTIVE | STATUS_DATA_TRANS_DONE |\n\t\t\t STATUS_WRITE_OP_DONE),\n\t\tMMC_REG_STATUS);\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s: 0x%08x\\n\", __func__, stat);\n\n\tspin_lock(&host->lock);\n\tsdio_irq = (stat & STATUS_SDIO_INT_ACTIVE) && host->use_sdio;\n\tspin_unlock(&host->lock);\n\n\tif (mxcmci_use_dma(host) && (stat & (STATUS_WRITE_OP_DONE)))\n\t\tmxcmci_writel(host, STATUS_WRITE_OP_DONE, MMC_REG_STATUS);\n\n\tif (sdio_irq) {\n\t\tmxcmci_writel(host, STATUS_SDIO_INT_ACTIVE, MMC_REG_STATUS);\n\t\tmmc_signal_sdio_irq(host->mmc);\n\t}\n\n\tif (stat & STATUS_END_CMD_RESP)\n\t\tmxcmci_cmd_done(host, stat);\n\n\tif (mxcmci_use_dma(host) && (stat & STATUS_WRITE_OP_DONE)) {\n\t\tdel_timer(&host->watchdog);\n\t\tmxcmci_data_done(host, stat);\n\t}\n\n\tif (host->default_irq_mask &&\n\t\t  (stat & (STATUS_CARD_INSERTION | STATUS_CARD_REMOVAL)))\n\t\tmmc_detect_change(host->mmc, msecs_to_jiffies(200));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mxcmci_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\tunsigned int cmdat = host->cmdat;\n\tint error;\n\n\tWARN_ON(host->req != NULL);\n\n\thost->req = req;\n\thost->cmdat &= ~CMD_DAT_CONT_INIT;\n\n\tif (host->dma)\n\t\thost->do_dma = 1;\n\n\tif (req->data) {\n\t\terror = mxcmci_setup_data(host, req->data);\n\t\tif (error) {\n\t\t\treq->cmd->error = error;\n\t\t\tgoto out;\n\t\t}\n\n\n\t\tcmdat |= CMD_DAT_CONT_DATA_ENABLE;\n\n\t\tif (req->data->flags & MMC_DATA_WRITE)\n\t\t\tcmdat |= CMD_DAT_CONT_WRITE;\n\t}\n\n\terror = mxcmci_start_cmd(host, req->cmd, cmdat);\n\nout:\n\tif (error)\n\t\tmxcmci_finish_request(host, req);\n}\n\nstatic void mxcmci_set_clk_rate(struct mxcmci_host *host, unsigned int clk_ios)\n{\n\tunsigned int divider;\n\tint prescaler = 0;\n\tunsigned int clk_in = clk_get_rate(host->clk_per);\n\n\twhile (prescaler <= 0x800) {\n\t\tfor (divider = 1; divider <= 0xF; divider++) {\n\t\t\tint x;\n\n\t\t\tx = (clk_in / (divider + 1));\n\n\t\t\tif (prescaler)\n\t\t\t\tx /= (prescaler * 2);\n\n\t\t\tif (x <= clk_ios)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (divider < 0x10)\n\t\t\tbreak;\n\n\t\tif (prescaler == 0)\n\t\t\tprescaler = 1;\n\t\telse\n\t\t\tprescaler <<= 1;\n\t}\n\n\tmxcmci_writew(host, (prescaler << 4) | divider, MMC_REG_CLK_RATE);\n\n\tdev_dbg(mmc_dev(host->mmc), \"scaler: %d divider: %d in: %d out: %d\\n\",\n\t\t\tprescaler, divider, clk_in, clk_ios);\n}\n\nstatic int mxcmci_setup_dma(struct mmc_host *mmc)\n{\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\tstruct dma_slave_config *config = &host->dma_slave_config;\n\n\tconfig->dst_addr = host->phys_base + MMC_REG_BUFFER_ACCESS;\n\tconfig->src_addr = host->phys_base + MMC_REG_BUFFER_ACCESS;\n\tconfig->dst_addr_width = 4;\n\tconfig->src_addr_width = 4;\n\tconfig->dst_maxburst = host->burstlen;\n\tconfig->src_maxburst = host->burstlen;\n\tconfig->device_fc = false;\n\n\treturn dmaengine_slave_config(host->dma, config);\n}\n\nstatic void mxcmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\tint burstlen, ret;\n\n\t \n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\tburstlen = 16;\n\telse\n\t\tburstlen = 4;\n\n\tif (mxcmci_use_dma(host) && burstlen != host->burstlen) {\n\t\thost->burstlen = burstlen;\n\t\tret = mxcmci_setup_dma(mmc);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"failed to config DMA channel. Falling back to PIO\\n\");\n\t\t\tdma_release_channel(host->dma);\n\t\t\thost->do_dma = 0;\n\t\t\thost->dma = NULL;\n\t\t}\n\t}\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\thost->cmdat |= CMD_DAT_CONT_BUS_WIDTH_4;\n\telse\n\t\thost->cmdat &= ~CMD_DAT_CONT_BUS_WIDTH_4;\n\n\tif (host->power_mode != ios->power_mode) {\n\t\thost->power_mode = ios->power_mode;\n\t\tmxcmci_set_power(host, ios->vdd);\n\n\t\tif (ios->power_mode == MMC_POWER_ON)\n\t\t\thost->cmdat |= CMD_DAT_CONT_INIT;\n\t}\n\n\tif (ios->clock) {\n\t\tmxcmci_set_clk_rate(host, ios->clock);\n\t\tmxcmci_writew(host, STR_STP_CLK_START_CLK, MMC_REG_STR_STP_CLK);\n\t} else {\n\t\tmxcmci_writew(host, STR_STP_CLK_STOP_CLK, MMC_REG_STR_STP_CLK);\n\t}\n\n\thost->clock = ios->clock;\n}\n\nstatic irqreturn_t mxcmci_detect_irq(int irq, void *data)\n{\n\tstruct mmc_host *mmc = data;\n\n\tdev_dbg(mmc_dev(mmc), \"%s\\n\", __func__);\n\n\tmmc_detect_change(mmc, msecs_to_jiffies(250));\n\treturn IRQ_HANDLED;\n}\n\nstatic int mxcmci_get_ro(struct mmc_host *mmc)\n{\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\n\tif (host->pdata && host->pdata->get_ro)\n\t\treturn !!host->pdata->get_ro(mmc_dev(mmc));\n\t \n\treturn mmc_gpio_get_ro(mmc);\n}\n\nstatic void mxcmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tu32 int_cntr;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\thost->use_sdio = enable;\n\tint_cntr = mxcmci_readl(host, MMC_REG_INT_CNTR);\n\n\tif (enable)\n\t\tint_cntr |= INT_SDIO_IRQ_EN;\n\telse\n\t\tint_cntr &= ~INT_SDIO_IRQ_EN;\n\n\tmxcmci_writel(host, int_cntr, MMC_REG_INT_CNTR);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void mxcmci_init_card(struct mmc_host *host, struct mmc_card *card)\n{\n\tstruct mxcmci_host *mxcmci = mmc_priv(host);\n\n\t \n\n\tif (is_imx31_mmc(mxcmci) && mmc_card_sdio(card))\n\t\thost->caps &= ~MMC_CAP_4_BIT_DATA;\n\telse\n\t\thost->caps |= MMC_CAP_4_BIT_DATA;\n}\n\nstatic bool filter(struct dma_chan *chan, void *param)\n{\n\tstruct mxcmci_host *host = param;\n\n\tif (!imx_dma_is_general_purpose(chan))\n\t\treturn false;\n\n\tchan->private = &host->dma_data;\n\n\treturn true;\n}\n\nstatic void mxcmci_watchdog(struct timer_list *t)\n{\n\tstruct mxcmci_host *host = from_timer(host, t, watchdog);\n\tstruct mmc_request *req = host->req;\n\tunsigned int stat = mxcmci_readl(host, MMC_REG_STATUS);\n\n\tif (host->dma_dir == DMA_FROM_DEVICE) {\n\t\tdmaengine_terminate_all(host->dma);\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"%s: read time out (status = 0x%08x)\\n\",\n\t\t\t__func__, stat);\n\t} else {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"%s: write time out (status = 0x%08x)\\n\",\n\t\t\t__func__, stat);\n\t\tmxcmci_softreset(host);\n\t}\n\n\t \n\n\tif (host->data)\n\t\thost->data->error = -ETIMEDOUT;\n\thost->req = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\tmmc_request_done(host->mmc, req);\n}\n\nstatic const struct mmc_host_ops mxcmci_ops = {\n\t.request\t\t= mxcmci_request,\n\t.set_ios\t\t= mxcmci_set_ios,\n\t.get_ro\t\t\t= mxcmci_get_ro,\n\t.enable_sdio_irq\t= mxcmci_enable_sdio_irq,\n\t.init_card\t\t= mxcmci_init_card,\n};\n\nstatic int mxcmci_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct mxcmci_host *host;\n\tstruct resource *res;\n\tint ret = 0, irq;\n\tbool dat3_card_detect = false;\n\tdma_cap_mask_t mask;\n\tstruct imxmmc_platform_data *pdata = pdev->dev.platform_data;\n\n\tpr_info(\"i.MX/MPC512x SDHC driver\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\n\thost->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto out_free;\n\t}\n\n\thost->phys_base = res->start;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto out_free;\n\tmmc->ops = &mxcmci_ops;\n\n\t \n\tif (pdata)\n\t\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SDIO_IRQ;\n\telse\n\t\tmmc->caps |= MMC_CAP_SDIO_IRQ;\n\n\t \n\tmmc->max_blk_size = 2048;\n\tmmc->max_blk_count = 65535;\n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\thost->devtype = (uintptr_t)of_device_get_match_data(&pdev->dev);\n\n\t \n\tif (!is_mpc512x_mmc(host))\n\t\tmmc->max_segs = 64;\n\n\thost->mmc = mmc;\n\thost->pdata = pdata;\n\tspin_lock_init(&host->lock);\n\n\tif (pdata)\n\t\tdat3_card_detect = pdata->dat3_card_detect;\n\telse if (mmc_card_is_removable(mmc)\n\t\t\t&& !of_property_read_bool(pdev->dev.of_node, \"cd-gpios\"))\n\t\tdat3_card_detect = true;\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (!mmc->ocr_avail) {\n\t\tif (pdata && pdata->ocr_avail)\n\t\t\tmmc->ocr_avail = pdata->ocr_avail;\n\t\telse\n\t\t\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\t}\n\n\tif (dat3_card_detect)\n\t\thost->default_irq_mask =\n\t\t\tINT_CARD_INSERTION_EN | INT_CARD_REMOVAL_EN;\n\telse\n\t\thost->default_irq_mask = 0;\n\n\thost->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(host->clk_ipg)) {\n\t\tret = PTR_ERR(host->clk_ipg);\n\t\tgoto out_free;\n\t}\n\n\thost->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(host->clk_per)) {\n\t\tret = PTR_ERR(host->clk_per);\n\t\tgoto out_free;\n\t}\n\n\tret = clk_prepare_enable(host->clk_per);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = clk_prepare_enable(host->clk_ipg);\n\tif (ret)\n\t\tgoto out_clk_per_put;\n\n\tmxcmci_softreset(host);\n\n\thost->rev_no = mxcmci_readw(host, MMC_REG_REV_NO);\n\tif (host->rev_no != 0x400) {\n\t\tret = -ENODEV;\n\t\tdev_err(mmc_dev(host->mmc), \"wrong rev.no. 0x%08x. aborting.\\n\",\n\t\t\thost->rev_no);\n\t\tgoto out_clk_put;\n\t}\n\n\tmmc->f_min = clk_get_rate(host->clk_per) >> 16;\n\tmmc->f_max = clk_get_rate(host->clk_per) >> 1;\n\n\t \n\tmxcmci_writew(host, 0x2db4, MMC_REG_READ_TO);\n\n\tmxcmci_writel(host, host->default_irq_mask, MMC_REG_INT_CNTR);\n\n\tif (!host->pdata) {\n\t\thost->dma = dma_request_chan(&pdev->dev, \"rx-tx\");\n\t\tif (IS_ERR(host->dma)) {\n\t\t\tif (PTR_ERR(host->dma) == -EPROBE_DEFER) {\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\t\tgoto out_clk_put;\n\t\t\t}\n\n\t\t\t \n\t\t\thost->dma = NULL;\n\t\t}\n\t} else {\n\t\tres = platform_get_resource(pdev, IORESOURCE_DMA, 0);\n\t\tif (res) {\n\t\t\thost->dmareq = res->start;\n\t\t\thost->dma_data.peripheral_type = IMX_DMATYPE_SDHC;\n\t\t\thost->dma_data.priority = DMA_PRIO_LOW;\n\t\t\thost->dma_data.dma_request = host->dmareq;\n\t\t\tdma_cap_zero(mask);\n\t\t\tdma_cap_set(DMA_SLAVE, mask);\n\t\t\thost->dma = dma_request_channel(mask, filter, host);\n\t\t}\n\t}\n\tif (host->dma)\n\t\tmmc->max_seg_size = dma_get_max_seg_size(\n\t\t\t\thost->dma->device->dev);\n\telse\n\t\tdev_info(mmc_dev(host->mmc), \"dma not available. Using PIO\\n\");\n\n\tINIT_WORK(&host->datawork, mxcmci_datawork);\n\n\tret = devm_request_irq(&pdev->dev, irq, mxcmci_irq, 0,\n\t\t\t       dev_name(&pdev->dev), host);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\tplatform_set_drvdata(pdev, mmc);\n\n\tif (host->pdata && host->pdata->init) {\n\t\tret = host->pdata->init(&pdev->dev, mxcmci_detect_irq,\n\t\t\t\thost->mmc);\n\t\tif (ret)\n\t\t\tgoto out_free_dma;\n\t}\n\n\ttimer_setup(&host->watchdog, mxcmci_watchdog, 0);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\treturn 0;\n\nout_free_dma:\n\tif (host->dma)\n\t\tdma_release_channel(host->dma);\n\nout_clk_put:\n\tclk_disable_unprepare(host->clk_ipg);\nout_clk_per_put:\n\tclk_disable_unprepare(host->clk_per);\n\nout_free:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void mxcmci_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(pdev);\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\n\tmmc_remove_host(mmc);\n\n\tif (host->pdata && host->pdata->exit)\n\t\thost->pdata->exit(&pdev->dev, mmc);\n\n\tif (host->dma)\n\t\tdma_release_channel(host->dma);\n\n\tclk_disable_unprepare(host->clk_per);\n\tclk_disable_unprepare(host->clk_ipg);\n\n\tmmc_free_host(mmc);\n}\n\nstatic int mxcmci_suspend(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\n\tclk_disable_unprepare(host->clk_per);\n\tclk_disable_unprepare(host->clk_ipg);\n\treturn 0;\n}\n\nstatic int mxcmci_resume(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct mxcmci_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tret = clk_prepare_enable(host->clk_per);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(host->clk_ipg);\n\tif (ret)\n\t\tclk_disable_unprepare(host->clk_per);\n\n\treturn ret;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(mxcmci_pm_ops, mxcmci_suspend, mxcmci_resume);\n\nstatic struct platform_driver mxcmci_driver = {\n\t.probe\t\t= mxcmci_probe,\n\t.remove_new\t= mxcmci_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= DRIVER_NAME,\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= pm_sleep_ptr(&mxcmci_pm_ops),\n\t\t.of_match_table\t= mxcmci_of_match,\n\t}\n};\n\nmodule_platform_driver(mxcmci_driver);\n\nMODULE_DESCRIPTION(\"i.MX Multimedia Card Interface Driver\");\nMODULE_AUTHOR(\"Sascha Hauer, Pengutronix\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mxc-mmc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}