{
  "module_name": "omap.c",
  "hash_id": "7c17903fec2f3b5c9690b3f310cfa89d651c9e8528c50aa9a75be09837d7fdfe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/omap.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/spinlock.h>\n#include <linux/timer.h>\n#include <linux/of.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/clk.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_data/mmc-omap.h>\n\n\n#define\tOMAP_MMC_REG_CMD\t0x00\n#define\tOMAP_MMC_REG_ARGL\t0x01\n#define\tOMAP_MMC_REG_ARGH\t0x02\n#define\tOMAP_MMC_REG_CON\t0x03\n#define\tOMAP_MMC_REG_STAT\t0x04\n#define\tOMAP_MMC_REG_IE\t\t0x05\n#define\tOMAP_MMC_REG_CTO\t0x06\n#define\tOMAP_MMC_REG_DTO\t0x07\n#define\tOMAP_MMC_REG_DATA\t0x08\n#define\tOMAP_MMC_REG_BLEN\t0x09\n#define\tOMAP_MMC_REG_NBLK\t0x0a\n#define\tOMAP_MMC_REG_BUF\t0x0b\n#define\tOMAP_MMC_REG_SDIO\t0x0d\n#define\tOMAP_MMC_REG_REV\t0x0f\n#define\tOMAP_MMC_REG_RSP0\t0x10\n#define\tOMAP_MMC_REG_RSP1\t0x11\n#define\tOMAP_MMC_REG_RSP2\t0x12\n#define\tOMAP_MMC_REG_RSP3\t0x13\n#define\tOMAP_MMC_REG_RSP4\t0x14\n#define\tOMAP_MMC_REG_RSP5\t0x15\n#define\tOMAP_MMC_REG_RSP6\t0x16\n#define\tOMAP_MMC_REG_RSP7\t0x17\n#define\tOMAP_MMC_REG_IOSR\t0x18\n#define\tOMAP_MMC_REG_SYSC\t0x19\n#define\tOMAP_MMC_REG_SYSS\t0x1a\n\n#define\tOMAP_MMC_STAT_CARD_ERR\t\t(1 << 14)\n#define\tOMAP_MMC_STAT_CARD_IRQ\t\t(1 << 13)\n#define\tOMAP_MMC_STAT_OCR_BUSY\t\t(1 << 12)\n#define\tOMAP_MMC_STAT_A_EMPTY\t\t(1 << 11)\n#define\tOMAP_MMC_STAT_A_FULL\t\t(1 << 10)\n#define\tOMAP_MMC_STAT_CMD_CRC\t\t(1 <<  8)\n#define\tOMAP_MMC_STAT_CMD_TOUT\t\t(1 <<  7)\n#define\tOMAP_MMC_STAT_DATA_CRC\t\t(1 <<  6)\n#define\tOMAP_MMC_STAT_DATA_TOUT\t\t(1 <<  5)\n#define\tOMAP_MMC_STAT_END_BUSY\t\t(1 <<  4)\n#define\tOMAP_MMC_STAT_END_OF_DATA\t(1 <<  3)\n#define\tOMAP_MMC_STAT_CARD_BUSY\t\t(1 <<  2)\n#define\tOMAP_MMC_STAT_END_OF_CMD\t(1 <<  0)\n\n#define mmc_omap7xx()\t(host->features & MMC_OMAP7XX)\n#define mmc_omap15xx()\t(host->features & MMC_OMAP15XX)\n#define mmc_omap16xx()\t(host->features & MMC_OMAP16XX)\n#define MMC_OMAP1_MASK\t(MMC_OMAP7XX | MMC_OMAP15XX | MMC_OMAP16XX)\n#define mmc_omap1()\t(host->features & MMC_OMAP1_MASK)\n#define mmc_omap2()\t(!mmc_omap1())\n\n#define OMAP_MMC_REG(host, reg)\t\t(OMAP_MMC_REG_##reg << (host)->reg_shift)\n#define OMAP_MMC_READ(host, reg)\t__raw_readw((host)->virt_base + OMAP_MMC_REG(host, reg))\n#define OMAP_MMC_WRITE(host, reg, val)\t__raw_writew((val), (host)->virt_base + OMAP_MMC_REG(host, reg))\n\n \n#define OMAP_MMC_CMDTYPE_BC\t0\n#define OMAP_MMC_CMDTYPE_BCR\t1\n#define OMAP_MMC_CMDTYPE_AC\t2\n#define OMAP_MMC_CMDTYPE_ADTC\t3\n\n#define DRIVER_NAME \"mmci-omap\"\n\n \n#define OMAP_MMC_COVER_POLL_DELAY\t500\n\nstruct mmc_omap_host;\n\nstruct mmc_omap_slot {\n\tint\t\t\tid;\n\tunsigned int\t\tvdd;\n\tu16\t\t\tsaved_con;\n\tu16\t\t\tbus_mode;\n\tu16\t\t\tpower_mode;\n\tunsigned int\t\tfclk_freq;\n\n\tstruct tasklet_struct\tcover_tasklet;\n\tstruct timer_list       cover_timer;\n\tunsigned\t\tcover_open;\n\n\tstruct mmc_request      *mrq;\n\tstruct mmc_omap_host    *host;\n\tstruct mmc_host\t\t*mmc;\n\tstruct gpio_desc\t*vsd;\n\tstruct gpio_desc\t*vio;\n\tstruct gpio_desc\t*cover;\n\tstruct omap_mmc_slot_data *pdata;\n};\n\nstruct mmc_omap_host {\n\tint\t\t\tinitialized;\n\tstruct mmc_request *\tmrq;\n\tstruct mmc_command *\tcmd;\n\tstruct mmc_data *\tdata;\n\tstruct mmc_host *\tmmc;\n\tstruct device *\t\tdev;\n\tunsigned char\t\tid;  \n\tstruct clk *\t\ticlk;\n\tstruct clk *\t\tfclk;\n\tstruct dma_chan\t\t*dma_rx;\n\tu32\t\t\tdma_rx_burst;\n\tstruct dma_chan\t\t*dma_tx;\n\tu32\t\t\tdma_tx_burst;\n\tvoid __iomem\t\t*virt_base;\n\tunsigned int\t\tphys_base;\n\tint\t\t\tirq;\n\tunsigned char\t\tbus_mode;\n\tunsigned int\t\treg_shift;\n\tstruct gpio_desc\t*slot_switch;\n\n\tstruct work_struct\tcmd_abort_work;\n\tunsigned\t\tabort:1;\n\tstruct timer_list\tcmd_abort_timer;\n\n\tstruct work_struct      slot_release_work;\n\tstruct mmc_omap_slot    *next_slot;\n\tstruct work_struct      send_stop_work;\n\tstruct mmc_data\t\t*stop_data;\n\n\tunsigned int\t\tsg_len;\n\tint\t\t\tsg_idx;\n\tu16 *\t\t\tbuffer;\n\tu32\t\t\tbuffer_bytes_left;\n\tu32\t\t\ttotal_bytes_left;\n\n\tunsigned\t\tfeatures;\n\tunsigned\t\tbrs_received:1, dma_done:1;\n\tunsigned\t\tdma_in_use:1;\n\tspinlock_t\t\tdma_lock;\n\n\tstruct mmc_omap_slot    *slots[OMAP_MMC_MAX_SLOTS];\n\tstruct mmc_omap_slot    *current_slot;\n\tspinlock_t              slot_lock;\n\twait_queue_head_t       slot_wq;\n\tint                     nr_slots;\n\n\tstruct timer_list       clk_timer;\n\tspinlock_t\t\tclk_lock;      \n\tunsigned int            fclk_enabled:1;\n\tstruct workqueue_struct *mmc_omap_wq;\n\n\tstruct omap_mmc_platform_data *pdata;\n};\n\n\nstatic void mmc_omap_fclk_offdelay(struct mmc_omap_slot *slot)\n{\n\tunsigned long tick_ns;\n\n\tif (slot != NULL && slot->host->fclk_enabled && slot->fclk_freq > 0) {\n\t\ttick_ns = DIV_ROUND_UP(NSEC_PER_SEC, slot->fclk_freq);\n\t\tndelay(8 * tick_ns);\n\t}\n}\n\nstatic void mmc_omap_fclk_enable(struct mmc_omap_host *host, unsigned int enable)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->clk_lock, flags);\n\tif (host->fclk_enabled != enable) {\n\t\thost->fclk_enabled = enable;\n\t\tif (enable)\n\t\t\tclk_enable(host->fclk);\n\t\telse\n\t\t\tclk_disable(host->fclk);\n\t}\n\tspin_unlock_irqrestore(&host->clk_lock, flags);\n}\n\nstatic void mmc_omap_select_slot(struct mmc_omap_slot *slot, int claimed)\n{\n\tstruct mmc_omap_host *host = slot->host;\n\tunsigned long flags;\n\n\tif (claimed)\n\t\tgoto no_claim;\n\tspin_lock_irqsave(&host->slot_lock, flags);\n\twhile (host->mmc != NULL) {\n\t\tspin_unlock_irqrestore(&host->slot_lock, flags);\n\t\twait_event(host->slot_wq, host->mmc == NULL);\n\t\tspin_lock_irqsave(&host->slot_lock, flags);\n\t}\n\thost->mmc = slot->mmc;\n\tspin_unlock_irqrestore(&host->slot_lock, flags);\nno_claim:\n\tdel_timer(&host->clk_timer);\n\tif (host->current_slot != slot || !claimed)\n\t\tmmc_omap_fclk_offdelay(host->current_slot);\n\n\tif (host->current_slot != slot) {\n\t\tOMAP_MMC_WRITE(host, CON, slot->saved_con & 0xFC00);\n\t\tif (host->slot_switch)\n\t\t\t \n\t\t\tgpiod_set_value(host->slot_switch, slot->id);\n\t\thost->current_slot = slot;\n\t}\n\n\tif (claimed) {\n\t\tmmc_omap_fclk_enable(host, 1);\n\n\t\t \n\t\tOMAP_MMC_READ(host, CON);\n\n\t\tOMAP_MMC_WRITE(host, CON, slot->saved_con);\n\t} else\n\t\tmmc_omap_fclk_enable(host, 0);\n}\n\nstatic void mmc_omap_start_request(struct mmc_omap_host *host,\n\t\t\t\t   struct mmc_request *req);\n\nstatic void mmc_omap_slot_release_work(struct work_struct *work)\n{\n\tstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\n\t\t\t\t\t\t  slot_release_work);\n\tstruct mmc_omap_slot *next_slot = host->next_slot;\n\tstruct mmc_request *rq;\n\n\thost->next_slot = NULL;\n\tmmc_omap_select_slot(next_slot, 1);\n\n\trq = next_slot->mrq;\n\tnext_slot->mrq = NULL;\n\tmmc_omap_start_request(host, rq);\n}\n\nstatic void mmc_omap_release_slot(struct mmc_omap_slot *slot, int clk_enabled)\n{\n\tstruct mmc_omap_host *host = slot->host;\n\tunsigned long flags;\n\tint i;\n\n\tBUG_ON(slot == NULL || host->mmc == NULL);\n\n\tif (clk_enabled)\n\t\t \n\t\tmod_timer(&host->clk_timer, jiffies  + HZ/10);\n\telse {\n\t\tdel_timer(&host->clk_timer);\n\t\tmmc_omap_fclk_offdelay(slot);\n\t\tmmc_omap_fclk_enable(host, 0);\n\t}\n\n\tspin_lock_irqsave(&host->slot_lock, flags);\n\t \n\tfor (i = 0; i < host->nr_slots; i++) {\n\t\tstruct mmc_omap_slot *new_slot;\n\n\t\tif (host->slots[i] == NULL || host->slots[i]->mrq == NULL)\n\t\t\tcontinue;\n\n\t\tBUG_ON(host->next_slot != NULL);\n\t\tnew_slot = host->slots[i];\n\t\t \n\t\tBUG_ON(new_slot == host->current_slot);\n\n\t\thost->next_slot = new_slot;\n\t\thost->mmc = new_slot->mmc;\n\t\tspin_unlock_irqrestore(&host->slot_lock, flags);\n\t\tqueue_work(host->mmc_omap_wq, &host->slot_release_work);\n\t\treturn;\n\t}\n\n\thost->mmc = NULL;\n\twake_up(&host->slot_wq);\n\tspin_unlock_irqrestore(&host->slot_lock, flags);\n}\n\nstatic inline\nint mmc_omap_cover_is_open(struct mmc_omap_slot *slot)\n{\n\t \n\tif (slot->cover)\n\t\treturn gpiod_get_value(slot->cover);\n\tif (slot->pdata->get_cover_state)\n\t\treturn slot->pdata->get_cover_state(mmc_dev(slot->mmc),\n\t\t\t\t\t\t    slot->id);\n\treturn 0;\n}\n\nstatic ssize_t\nmmc_omap_show_cover_switch(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\n\tstruct mmc_omap_slot *slot = mmc_priv(mmc);\n\n\treturn sprintf(buf, \"%s\\n\", mmc_omap_cover_is_open(slot) ? \"open\" :\n\t\t       \"closed\");\n}\n\nstatic DEVICE_ATTR(cover_switch, S_IRUGO, mmc_omap_show_cover_switch, NULL);\n\nstatic ssize_t\nmmc_omap_show_slot_name(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tstruct mmc_host *mmc = container_of(dev, struct mmc_host, class_dev);\n\tstruct mmc_omap_slot *slot = mmc_priv(mmc);\n\n\treturn sprintf(buf, \"%s\\n\", slot->pdata->name);\n}\n\nstatic DEVICE_ATTR(slot_name, S_IRUGO, mmc_omap_show_slot_name, NULL);\n\nstatic void\nmmc_omap_start_command(struct mmc_omap_host *host, struct mmc_command *cmd)\n{\n\tu32 cmdreg;\n\tu32 resptype;\n\tu32 cmdtype;\n\tu16 irq_mask;\n\n\thost->cmd = cmd;\n\n\tresptype = 0;\n\tcmdtype = 0;\n\n\t \n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\tcase MMC_RSP_R1B:\n\t\t \n\t\tresptype = 1;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tresptype = 2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tresptype = 3;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc), \"Invalid response type: %04x\\n\", mmc_resp_type(cmd));\n\t\tbreak;\n\t}\n\n\tif (mmc_cmd_type(cmd) == MMC_CMD_ADTC) {\n\t\tcmdtype = OMAP_MMC_CMDTYPE_ADTC;\n\t} else if (mmc_cmd_type(cmd) == MMC_CMD_BC) {\n\t\tcmdtype = OMAP_MMC_CMDTYPE_BC;\n\t} else if (mmc_cmd_type(cmd) == MMC_CMD_BCR) {\n\t\tcmdtype = OMAP_MMC_CMDTYPE_BCR;\n\t} else {\n\t\tcmdtype = OMAP_MMC_CMDTYPE_AC;\n\t}\n\n\tcmdreg = cmd->opcode | (resptype << 8) | (cmdtype << 12);\n\n\tif (host->current_slot->bus_mode == MMC_BUSMODE_OPENDRAIN)\n\t\tcmdreg |= 1 << 6;\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tcmdreg |= 1 << 11;\n\n\tif (host->data && !(host->data->flags & MMC_DATA_WRITE))\n\t\tcmdreg |= 1 << 15;\n\n\tmod_timer(&host->cmd_abort_timer, jiffies + HZ/2);\n\n\tOMAP_MMC_WRITE(host, CTO, 200);\n\tOMAP_MMC_WRITE(host, ARGL, cmd->arg & 0xffff);\n\tOMAP_MMC_WRITE(host, ARGH, cmd->arg >> 16);\n\tirq_mask = OMAP_MMC_STAT_A_EMPTY    | OMAP_MMC_STAT_A_FULL    |\n\t\t   OMAP_MMC_STAT_CMD_CRC    | OMAP_MMC_STAT_CMD_TOUT  |\n\t\t   OMAP_MMC_STAT_DATA_CRC   | OMAP_MMC_STAT_DATA_TOUT |\n\t\t   OMAP_MMC_STAT_END_OF_CMD | OMAP_MMC_STAT_CARD_ERR  |\n\t\t   OMAP_MMC_STAT_END_OF_DATA;\n\tif (cmd->opcode == MMC_ERASE)\n\t\tirq_mask &= ~OMAP_MMC_STAT_DATA_TOUT;\n\tOMAP_MMC_WRITE(host, IE, irq_mask);\n\tOMAP_MMC_WRITE(host, CMD, cmdreg);\n}\n\nstatic void\nmmc_omap_release_dma(struct mmc_omap_host *host, struct mmc_data *data,\n\t\t     int abort)\n{\n\tenum dma_data_direction dma_data_dir;\n\tstruct device *dev = mmc_dev(host->mmc);\n\tstruct dma_chan *c;\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\tdma_data_dir = DMA_TO_DEVICE;\n\t\tc = host->dma_tx;\n\t} else {\n\t\tdma_data_dir = DMA_FROM_DEVICE;\n\t\tc = host->dma_rx;\n\t}\n\tif (c) {\n\t\tif (data->error) {\n\t\t\tdmaengine_terminate_all(c);\n\t\t\t \n\t\t\tdata->bytes_xfered = 0;\n\t\t}\n\t\tdev = c->device->dev;\n\t}\n\tdma_unmap_sg(dev, data->sg, host->sg_len, dma_data_dir);\n}\n\nstatic void mmc_omap_send_stop_work(struct work_struct *work)\n{\n\tstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\n\t\t\t\t\t\t  send_stop_work);\n\tstruct mmc_omap_slot *slot = host->current_slot;\n\tstruct mmc_data *data = host->stop_data;\n\tunsigned long tick_ns;\n\n\ttick_ns = DIV_ROUND_UP(NSEC_PER_SEC, slot->fclk_freq);\n\tndelay(8*tick_ns);\n\n\tmmc_omap_start_command(host, data->stop);\n}\n\nstatic void\nmmc_omap_xfer_done(struct mmc_omap_host *host, struct mmc_data *data)\n{\n\tif (host->dma_in_use)\n\t\tmmc_omap_release_dma(host, data, data->error);\n\n\thost->data = NULL;\n\thost->sg_len = 0;\n\n\t \n\n\tif (!data->stop) {\n\t\tstruct mmc_host *mmc;\n\n\t\thost->mrq = NULL;\n\t\tmmc = host->mmc;\n\t\tmmc_omap_release_slot(host->current_slot, 1);\n\t\tmmc_request_done(mmc, data->mrq);\n\t\treturn;\n\t}\n\n\thost->stop_data = data;\n\tqueue_work(host->mmc_omap_wq, &host->send_stop_work);\n}\n\nstatic void\nmmc_omap_send_abort(struct mmc_omap_host *host, int maxloops)\n{\n\tstruct mmc_omap_slot *slot = host->current_slot;\n\tunsigned int restarts, passes, timeout;\n\tu16 stat = 0;\n\n\t \n\ttimeout = DIV_ROUND_UP(120 * USEC_PER_SEC, slot->fclk_freq);\n\trestarts = 0;\n\twhile (restarts < maxloops) {\n\t\tOMAP_MMC_WRITE(host, STAT, 0xFFFF);\n\t\tOMAP_MMC_WRITE(host, CMD, (3 << 12) | (1 << 7));\n\n\t\tpasses = 0;\n\t\twhile (passes < timeout) {\n\t\t\tstat = OMAP_MMC_READ(host, STAT);\n\t\t\tif (stat & OMAP_MMC_STAT_END_OF_CMD)\n\t\t\t\tgoto out;\n\t\t\tudelay(1);\n\t\t\tpasses++;\n\t\t}\n\n\t\trestarts++;\n\t}\nout:\n\tOMAP_MMC_WRITE(host, STAT, stat);\n}\n\nstatic void\nmmc_omap_abort_xfer(struct mmc_omap_host *host, struct mmc_data *data)\n{\n\tif (host->dma_in_use)\n\t\tmmc_omap_release_dma(host, data, 1);\n\n\thost->data = NULL;\n\thost->sg_len = 0;\n\n\tmmc_omap_send_abort(host, 10000);\n}\n\nstatic void\nmmc_omap_end_of_data(struct mmc_omap_host *host, struct mmc_data *data)\n{\n\tunsigned long flags;\n\tint done;\n\n\tif (!host->dma_in_use) {\n\t\tmmc_omap_xfer_done(host, data);\n\t\treturn;\n\t}\n\tdone = 0;\n\tspin_lock_irqsave(&host->dma_lock, flags);\n\tif (host->dma_done)\n\t\tdone = 1;\n\telse\n\t\thost->brs_received = 1;\n\tspin_unlock_irqrestore(&host->dma_lock, flags);\n\tif (done)\n\t\tmmc_omap_xfer_done(host, data);\n}\n\nstatic void\nmmc_omap_dma_done(struct mmc_omap_host *host, struct mmc_data *data)\n{\n\tunsigned long flags;\n\tint done;\n\n\tdone = 0;\n\tspin_lock_irqsave(&host->dma_lock, flags);\n\tif (host->brs_received)\n\t\tdone = 1;\n\telse\n\t\thost->dma_done = 1;\n\tspin_unlock_irqrestore(&host->dma_lock, flags);\n\tif (done)\n\t\tmmc_omap_xfer_done(host, data);\n}\n\nstatic void\nmmc_omap_cmd_done(struct mmc_omap_host *host, struct mmc_command *cmd)\n{\n\thost->cmd = NULL;\n\n\tdel_timer(&host->cmd_abort_timer);\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\t \n\t\t\tcmd->resp[3] =\n\t\t\t\tOMAP_MMC_READ(host, RSP0) |\n\t\t\t\t(OMAP_MMC_READ(host, RSP1) << 16);\n\t\t\tcmd->resp[2] =\n\t\t\t\tOMAP_MMC_READ(host, RSP2) |\n\t\t\t\t(OMAP_MMC_READ(host, RSP3) << 16);\n\t\t\tcmd->resp[1] =\n\t\t\t\tOMAP_MMC_READ(host, RSP4) |\n\t\t\t\t(OMAP_MMC_READ(host, RSP5) << 16);\n\t\t\tcmd->resp[0] =\n\t\t\t\tOMAP_MMC_READ(host, RSP6) |\n\t\t\t\t(OMAP_MMC_READ(host, RSP7) << 16);\n\t\t} else {\n\t\t\t \n\t\t\tcmd->resp[0] =\n\t\t\t\tOMAP_MMC_READ(host, RSP6) |\n\t\t\t\t(OMAP_MMC_READ(host, RSP7) << 16);\n\t\t}\n\t}\n\n\tif (host->data == NULL || cmd->error) {\n\t\tstruct mmc_host *mmc;\n\n\t\tif (host->data != NULL)\n\t\t\tmmc_omap_abort_xfer(host, host->data);\n\t\thost->mrq = NULL;\n\t\tmmc = host->mmc;\n\t\tmmc_omap_release_slot(host->current_slot, 1);\n\t\tmmc_request_done(mmc, cmd->mrq);\n\t}\n}\n\n \nstatic void mmc_omap_abort_command(struct work_struct *work)\n{\n\tstruct mmc_omap_host *host = container_of(work, struct mmc_omap_host,\n\t\t\t\t\t\t  cmd_abort_work);\n\tBUG_ON(!host->cmd);\n\n\tdev_dbg(mmc_dev(host->mmc), \"Aborting stuck command CMD%d\\n\",\n\t\thost->cmd->opcode);\n\n\tif (host->cmd->error == 0)\n\t\thost->cmd->error = -ETIMEDOUT;\n\n\tif (host->data == NULL) {\n\t\tstruct mmc_command *cmd;\n\t\tstruct mmc_host    *mmc;\n\n\t\tcmd = host->cmd;\n\t\thost->cmd = NULL;\n\t\tmmc_omap_send_abort(host, 10000);\n\n\t\thost->mrq = NULL;\n\t\tmmc = host->mmc;\n\t\tmmc_omap_release_slot(host->current_slot, 1);\n\t\tmmc_request_done(mmc, cmd->mrq);\n\t} else\n\t\tmmc_omap_cmd_done(host, host->cmd);\n\n\thost->abort = 0;\n\tenable_irq(host->irq);\n}\n\nstatic void\nmmc_omap_cmd_timer(struct timer_list *t)\n{\n\tstruct mmc_omap_host *host = from_timer(host, t, cmd_abort_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->slot_lock, flags);\n\tif (host->cmd != NULL && !host->abort) {\n\t\tOMAP_MMC_WRITE(host, IE, 0);\n\t\tdisable_irq(host->irq);\n\t\thost->abort = 1;\n\t\tqueue_work(host->mmc_omap_wq, &host->cmd_abort_work);\n\t}\n\tspin_unlock_irqrestore(&host->slot_lock, flags);\n}\n\n \nstatic void\nmmc_omap_sg_to_buf(struct mmc_omap_host *host)\n{\n\tstruct scatterlist *sg;\n\n\tsg = host->data->sg + host->sg_idx;\n\thost->buffer_bytes_left = sg->length;\n\thost->buffer = sg_virt(sg);\n\tif (host->buffer_bytes_left > host->total_bytes_left)\n\t\thost->buffer_bytes_left = host->total_bytes_left;\n}\n\nstatic void\nmmc_omap_clk_timer(struct timer_list *t)\n{\n\tstruct mmc_omap_host *host = from_timer(host, t, clk_timer);\n\n\tmmc_omap_fclk_enable(host, 0);\n}\n\n \nstatic void\nmmc_omap_xfer_data(struct mmc_omap_host *host, int write)\n{\n\tint n, nwords;\n\n\tif (host->buffer_bytes_left == 0) {\n\t\thost->sg_idx++;\n\t\tBUG_ON(host->sg_idx == host->sg_len);\n\t\tmmc_omap_sg_to_buf(host);\n\t}\n\tn = 64;\n\tif (n > host->buffer_bytes_left)\n\t\tn = host->buffer_bytes_left;\n\n\t \n\tnwords = DIV_ROUND_UP(n, 2);\n\n\thost->buffer_bytes_left -= n;\n\thost->total_bytes_left -= n;\n\thost->data->bytes_xfered += n;\n\n\tif (write) {\n\t\t__raw_writesw(host->virt_base + OMAP_MMC_REG(host, DATA),\n\t\t\t      host->buffer, nwords);\n\t} else {\n\t\t__raw_readsw(host->virt_base + OMAP_MMC_REG(host, DATA),\n\t\t\t     host->buffer, nwords);\n\t}\n\n\thost->buffer += nwords;\n}\n\n#ifdef CONFIG_MMC_DEBUG\nstatic void mmc_omap_report_irq(struct mmc_omap_host *host, u16 status)\n{\n\tstatic const char *mmc_omap_status_bits[] = {\n\t\t\"EOC\", \"CD\", \"CB\", \"BRS\", \"EOFB\", \"DTO\", \"DCRC\", \"CTO\",\n\t\t\"CCRC\", \"CRW\", \"AF\", \"AE\", \"OCRB\", \"CIRQ\", \"CERR\"\n\t};\n\tint i;\n\tchar res[64], *buf = res;\n\n\tbuf += sprintf(buf, \"MMC IRQ 0x%x:\", status);\n\n\tfor (i = 0; i < ARRAY_SIZE(mmc_omap_status_bits); i++)\n\t\tif (status & (1 << i))\n\t\t\tbuf += sprintf(buf, \" %s\", mmc_omap_status_bits[i]);\n\tdev_vdbg(mmc_dev(host->mmc), \"%s\\n\", res);\n}\n#else\nstatic void mmc_omap_report_irq(struct mmc_omap_host *host, u16 status)\n{\n}\n#endif\n\n\nstatic irqreturn_t mmc_omap_irq(int irq, void *dev_id)\n{\n\tstruct mmc_omap_host * host = (struct mmc_omap_host *)dev_id;\n\tu16 status;\n\tint end_command;\n\tint end_transfer;\n\tint transfer_error, cmd_error;\n\n\tif (host->cmd == NULL && host->data == NULL) {\n\t\tstatus = OMAP_MMC_READ(host, STAT);\n\t\tdev_info(mmc_dev(host->slots[0]->mmc),\n\t\t\t \"Spurious IRQ 0x%04x\\n\", status);\n\t\tif (status != 0) {\n\t\t\tOMAP_MMC_WRITE(host, STAT, status);\n\t\t\tOMAP_MMC_WRITE(host, IE, 0);\n\t\t}\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tend_command = 0;\n\tend_transfer = 0;\n\ttransfer_error = 0;\n\tcmd_error = 0;\n\n\twhile ((status = OMAP_MMC_READ(host, STAT)) != 0) {\n\t\tint cmd;\n\n\t\tOMAP_MMC_WRITE(host, STAT, status);\n\t\tif (host->cmd != NULL)\n\t\t\tcmd = host->cmd->opcode;\n\t\telse\n\t\t\tcmd = -1;\n\t\tdev_dbg(mmc_dev(host->mmc), \"MMC IRQ %04x (CMD %d): \",\n\t\t\tstatus, cmd);\n\t\tmmc_omap_report_irq(host, status);\n\n\t\tif (host->total_bytes_left) {\n\t\t\tif ((status & OMAP_MMC_STAT_A_FULL) ||\n\t\t\t    (status & OMAP_MMC_STAT_END_OF_DATA))\n\t\t\t\tmmc_omap_xfer_data(host, 0);\n\t\t\tif (status & OMAP_MMC_STAT_A_EMPTY)\n\t\t\t\tmmc_omap_xfer_data(host, 1);\n\t\t}\n\n\t\tif (status & OMAP_MMC_STAT_END_OF_DATA)\n\t\t\tend_transfer = 1;\n\n\t\tif (status & OMAP_MMC_STAT_DATA_TOUT) {\n\t\t\tdev_dbg(mmc_dev(host->mmc), \"data timeout (CMD%d)\\n\",\n\t\t\t\tcmd);\n\t\t\tif (host->data) {\n\t\t\t\thost->data->error = -ETIMEDOUT;\n\t\t\t\ttransfer_error = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (status & OMAP_MMC_STAT_DATA_CRC) {\n\t\t\tif (host->data) {\n\t\t\t\thost->data->error = -EILSEQ;\n\t\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\t \"data CRC error, bytes left %d\\n\",\n\t\t\t\t\thost->total_bytes_left);\n\t\t\t\ttransfer_error = 1;\n\t\t\t} else {\n\t\t\t\tdev_dbg(mmc_dev(host->mmc), \"data CRC error\\n\");\n\t\t\t}\n\t\t}\n\n\t\tif (status & OMAP_MMC_STAT_CMD_TOUT) {\n\t\t\t \n\t\t\tif (host->cmd) {\n\t\t\t\tstruct mmc_omap_slot *slot =\n\t\t\t\t\thost->current_slot;\n\t\t\t\tif (slot == NULL ||\n\t\t\t\t    !mmc_omap_cover_is_open(slot))\n\t\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\t\"command timeout (CMD%d)\\n\",\n\t\t\t\t\t\tcmd);\n\t\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\t\t\tend_command = 1;\n\t\t\t\tcmd_error = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (status & OMAP_MMC_STAT_CMD_CRC) {\n\t\t\tif (host->cmd) {\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"command CRC error (CMD%d, arg 0x%08x)\\n\",\n\t\t\t\t\tcmd, host->cmd->arg);\n\t\t\t\thost->cmd->error = -EILSEQ;\n\t\t\t\tend_command = 1;\n\t\t\t\tcmd_error = 1;\n\t\t\t} else\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"command CRC error without cmd?\\n\");\n\t\t}\n\n\t\tif (status & OMAP_MMC_STAT_CARD_ERR) {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"ignoring card status error (CMD%d)\\n\",\n\t\t\t\tcmd);\n\t\t\tend_command = 1;\n\t\t}\n\n\t\t \n\t\tif ((status & OMAP_MMC_STAT_END_OF_CMD) &&\n\t\t    (!(status & OMAP_MMC_STAT_A_EMPTY))) {\n\t\t\tend_command = 1;\n\t\t}\n\t}\n\n\tif (cmd_error && host->data) {\n\t\tdel_timer(&host->cmd_abort_timer);\n\t\thost->abort = 1;\n\t\tOMAP_MMC_WRITE(host, IE, 0);\n\t\tdisable_irq_nosync(host->irq);\n\t\tqueue_work(host->mmc_omap_wq, &host->cmd_abort_work);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (end_command && host->cmd)\n\t\tmmc_omap_cmd_done(host, host->cmd);\n\tif (host->data != NULL) {\n\t\tif (transfer_error)\n\t\t\tmmc_omap_xfer_done(host, host->data);\n\t\telse if (end_transfer)\n\t\t\tmmc_omap_end_of_data(host, host->data);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nvoid omap_mmc_notify_cover_event(struct device *dev, int num, int is_closed)\n{\n\tint cover_open;\n\tstruct mmc_omap_host *host = dev_get_drvdata(dev);\n\tstruct mmc_omap_slot *slot = host->slots[num];\n\n\tBUG_ON(num >= host->nr_slots);\n\n\t \n\tif (host->nr_slots == 0 || !host->slots[num])\n\t\treturn;\n\n\tcover_open = mmc_omap_cover_is_open(slot);\n\tif (cover_open != slot->cover_open) {\n\t\tslot->cover_open = cover_open;\n\t\tsysfs_notify(&slot->mmc->class_dev.kobj, NULL, \"cover_switch\");\n\t}\n\n\ttasklet_hi_schedule(&slot->cover_tasklet);\n}\n\nstatic void mmc_omap_cover_timer(struct timer_list *t)\n{\n\tstruct mmc_omap_slot *slot = from_timer(slot, t, cover_timer);\n\ttasklet_schedule(&slot->cover_tasklet);\n}\n\nstatic void mmc_omap_cover_handler(struct tasklet_struct *t)\n{\n\tstruct mmc_omap_slot *slot = from_tasklet(slot, t, cover_tasklet);\n\tint cover_open = mmc_omap_cover_is_open(slot);\n\n\tmmc_detect_change(slot->mmc, 0);\n\tif (!cover_open)\n\t\treturn;\n\n\t \n\tif (slot->mmc->card == NULL)\n\t\treturn;\n\n\tmod_timer(&slot->cover_timer,\n\t\t  jiffies + msecs_to_jiffies(OMAP_MMC_COVER_POLL_DELAY));\n}\n\nstatic void mmc_omap_dma_callback(void *priv)\n{\n\tstruct mmc_omap_host *host = priv;\n\tstruct mmc_data *data = host->data;\n\n\t \n\tdata->bytes_xfered += data->blocks * data->blksz;\n\n\tmmc_omap_dma_done(host, data);\n}\n\nstatic inline void set_cmd_timeout(struct mmc_omap_host *host, struct mmc_request *req)\n{\n\tu16 reg;\n\n\treg = OMAP_MMC_READ(host, SDIO);\n\treg &= ~(1 << 5);\n\tOMAP_MMC_WRITE(host, SDIO, reg);\n\t \n\tOMAP_MMC_WRITE(host, CTO, 0xfd);\n}\n\nstatic inline void set_data_timeout(struct mmc_omap_host *host, struct mmc_request *req)\n{\n\tunsigned int timeout, cycle_ns;\n\tu16 reg;\n\n\tcycle_ns = 1000000000 / host->current_slot->fclk_freq;\n\ttimeout = req->data->timeout_ns / cycle_ns;\n\ttimeout += req->data->timeout_clks;\n\n\t \n\treg = OMAP_MMC_READ(host, SDIO);\n\tif (timeout > 0xffff) {\n\t\treg |= (1 << 5);\n\t\ttimeout /= 1024;\n\t} else\n\t\treg &= ~(1 << 5);\n\tOMAP_MMC_WRITE(host, SDIO, reg);\n\tOMAP_MMC_WRITE(host, DTO, timeout);\n}\n\nstatic void\nmmc_omap_prepare_data(struct mmc_omap_host *host, struct mmc_request *req)\n{\n\tstruct mmc_data *data = req->data;\n\tint i, use_dma = 1, block_size;\n\tstruct scatterlist *sg;\n\tunsigned sg_len;\n\n\thost->data = data;\n\tif (data == NULL) {\n\t\tOMAP_MMC_WRITE(host, BLEN, 0);\n\t\tOMAP_MMC_WRITE(host, NBLK, 0);\n\t\tOMAP_MMC_WRITE(host, BUF, 0);\n\t\thost->dma_in_use = 0;\n\t\tset_cmd_timeout(host, req);\n\t\treturn;\n\t}\n\n\tblock_size = data->blksz;\n\n\tOMAP_MMC_WRITE(host, NBLK, data->blocks - 1);\n\tOMAP_MMC_WRITE(host, BLEN, block_size - 1);\n\tset_data_timeout(host, req);\n\n\t \n\tsg_len = (data->blocks == 1) ? 1 : data->sg_len;\n\n\t \n\tfor_each_sg(data->sg, sg, sg_len, i) {\n\t\tif ((sg->length % block_size) != 0) {\n\t\t\tuse_dma = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thost->sg_idx = 0;\n\tif (use_dma) {\n\t\tenum dma_data_direction dma_data_dir;\n\t\tstruct dma_async_tx_descriptor *tx;\n\t\tstruct dma_chan *c;\n\t\tu32 burst, *bp;\n\t\tu16 buf;\n\n\t\t \n\t\tburst = mmc_omap15xx() ? 32 : 64;\n\t\tif (burst > data->blksz)\n\t\t\tburst = data->blksz;\n\n\t\tburst >>= 1;\n\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tc = host->dma_tx;\n\t\t\tbp = &host->dma_tx_burst;\n\t\t\tbuf = 0x0f80 | (burst - 1) << 0;\n\t\t\tdma_data_dir = DMA_TO_DEVICE;\n\t\t} else {\n\t\t\tc = host->dma_rx;\n\t\t\tbp = &host->dma_rx_burst;\n\t\t\tbuf = 0x800f | (burst - 1) << 8;\n\t\t\tdma_data_dir = DMA_FROM_DEVICE;\n\t\t}\n\n\t\tif (!c)\n\t\t\tgoto use_pio;\n\n\t\t \n\t\tif (*bp != burst) {\n\t\t\tstruct dma_slave_config cfg = {\n\t\t\t\t.src_addr = host->phys_base +\n\t\t\t\t\t    OMAP_MMC_REG(host, DATA),\n\t\t\t\t.dst_addr = host->phys_base +\n\t\t\t\t\t    OMAP_MMC_REG(host, DATA),\n\t\t\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES,\n\t\t\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES,\n\t\t\t\t.src_maxburst = burst,\n\t\t\t\t.dst_maxburst = burst,\n\t\t\t};\n\n\t\t\tif (dmaengine_slave_config(c, &cfg))\n\t\t\t\tgoto use_pio;\n\n\t\t\t*bp = burst;\n\t\t}\n\n\t\thost->sg_len = dma_map_sg(c->device->dev, data->sg, sg_len,\n\t\t\t\t\t  dma_data_dir);\n\t\tif (host->sg_len == 0)\n\t\t\tgoto use_pio;\n\n\t\ttx = dmaengine_prep_slave_sg(c, data->sg, host->sg_len,\n\t\t\tdata->flags & MMC_DATA_WRITE ? DMA_MEM_TO_DEV : DMA_DEV_TO_MEM,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!tx)\n\t\t\tgoto use_pio;\n\n\t\tOMAP_MMC_WRITE(host, BUF, buf);\n\n\t\ttx->callback = mmc_omap_dma_callback;\n\t\ttx->callback_param = host;\n\t\tdmaengine_submit(tx);\n\t\thost->brs_received = 0;\n\t\thost->dma_done = 0;\n\t\thost->dma_in_use = 1;\n\t\treturn;\n\t}\n use_pio:\n\n\t \n\tOMAP_MMC_WRITE(host, BUF, 0x1f1f);\n\thost->total_bytes_left = data->blocks * block_size;\n\thost->sg_len = sg_len;\n\tmmc_omap_sg_to_buf(host);\n\thost->dma_in_use = 0;\n}\n\nstatic void mmc_omap_start_request(struct mmc_omap_host *host,\n\t\t\t\t   struct mmc_request *req)\n{\n\tBUG_ON(host->mrq != NULL);\n\n\thost->mrq = req;\n\n\t \n\tmmc_omap_prepare_data(host, req);\n\tmmc_omap_start_command(host, req->cmd);\n\tif (host->dma_in_use) {\n\t\tstruct dma_chan *c = host->data->flags & MMC_DATA_WRITE ?\n\t\t\t\thost->dma_tx : host->dma_rx;\n\n\t\tdma_async_issue_pending(c);\n\t}\n}\n\nstatic void mmc_omap_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct mmc_omap_slot *slot = mmc_priv(mmc);\n\tstruct mmc_omap_host *host = slot->host;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->slot_lock, flags);\n\tif (host->mmc != NULL) {\n\t\tBUG_ON(slot->mrq != NULL);\n\t\tslot->mrq = req;\n\t\tspin_unlock_irqrestore(&host->slot_lock, flags);\n\t\treturn;\n\t} else\n\t\thost->mmc = mmc;\n\tspin_unlock_irqrestore(&host->slot_lock, flags);\n\tmmc_omap_select_slot(slot, 1);\n\tmmc_omap_start_request(host, req);\n}\n\nstatic void mmc_omap_set_power(struct mmc_omap_slot *slot, int power_on,\n\t\t\t\tint vdd)\n{\n\tstruct mmc_omap_host *host;\n\n\thost = slot->host;\n\n\tif (slot->vsd)\n\t\tgpiod_set_value(slot->vsd, power_on);\n\tif (slot->vio)\n\t\tgpiod_set_value(slot->vio, power_on);\n\n\tif (slot->pdata->set_power != NULL)\n\t\tslot->pdata->set_power(mmc_dev(slot->mmc), slot->id, power_on,\n\t\t\t\t\tvdd);\n\tif (mmc_omap2()) {\n\t\tu16 w;\n\n\t\tif (power_on) {\n\t\t\tw = OMAP_MMC_READ(host, CON);\n\t\t\tOMAP_MMC_WRITE(host, CON, w | (1 << 11));\n\t\t} else {\n\t\t\tw = OMAP_MMC_READ(host, CON);\n\t\t\tOMAP_MMC_WRITE(host, CON, w & ~(1 << 11));\n\t\t}\n\t}\n}\n\nstatic int mmc_omap_calc_divisor(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmc_omap_slot *slot = mmc_priv(mmc);\n\tstruct mmc_omap_host *host = slot->host;\n\tint func_clk_rate = clk_get_rate(host->fclk);\n\tint dsor;\n\n\tif (ios->clock == 0)\n\t\treturn 0;\n\n\tdsor = func_clk_rate / ios->clock;\n\tif (dsor < 1)\n\t\tdsor = 1;\n\n\tif (func_clk_rate / dsor > ios->clock)\n\t\tdsor++;\n\n\tif (dsor > 250)\n\t\tdsor = 250;\n\n\tslot->fclk_freq = func_clk_rate / dsor;\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\tdsor |= 1 << 15;\n\n\treturn dsor;\n}\n\nstatic void mmc_omap_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmc_omap_slot *slot = mmc_priv(mmc);\n\tstruct mmc_omap_host *host = slot->host;\n\tint i, dsor;\n\tint clk_enabled, init_stream;\n\n\tmmc_omap_select_slot(slot, 0);\n\n\tdsor = mmc_omap_calc_divisor(mmc, ios);\n\n\tif (ios->vdd != slot->vdd)\n\t\tslot->vdd = ios->vdd;\n\n\tclk_enabled = 0;\n\tinit_stream = 0;\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tmmc_omap_set_power(slot, 0, ios->vdd);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\t \n\t\tmmc_omap_set_power(slot, 1, ios->vdd);\n\t\tslot->power_mode = ios->power_mode;\n\t\tgoto exit;\n\tcase MMC_POWER_ON:\n\t\tmmc_omap_fclk_enable(host, 1);\n\t\tclk_enabled = 1;\n\t\tdsor |= 1 << 11;\n\t\tif (slot->power_mode != MMC_POWER_ON)\n\t\t\tinit_stream = 1;\n\t\tbreak;\n\t}\n\tslot->power_mode = ios->power_mode;\n\n\tif (slot->bus_mode != ios->bus_mode) {\n\t\tif (slot->pdata->set_bus_mode != NULL)\n\t\t\tslot->pdata->set_bus_mode(mmc_dev(mmc), slot->id,\n\t\t\t\t\t\t  ios->bus_mode);\n\t\tslot->bus_mode = ios->bus_mode;\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++)\n\t\tOMAP_MMC_WRITE(host, CON, dsor);\n\tslot->saved_con = dsor;\n\tif (init_stream) {\n\t\t \n\t\tint usecs = 250;\n\n\t\t \n\t\tOMAP_MMC_WRITE(host, IE, 0);\n\t\tOMAP_MMC_WRITE(host, STAT, 0xffff);\n\t\tOMAP_MMC_WRITE(host, CMD, 1 << 7);\n\t\twhile (usecs > 0 && (OMAP_MMC_READ(host, STAT) & 1) == 0) {\n\t\t\tudelay(1);\n\t\t\tusecs--;\n\t\t}\n\t\tOMAP_MMC_WRITE(host, STAT, 1);\n\t}\n\nexit:\n\tmmc_omap_release_slot(slot, clk_enabled);\n}\n\nstatic const struct mmc_host_ops mmc_omap_ops = {\n\t.request\t= mmc_omap_request,\n\t.set_ios\t= mmc_omap_set_ios,\n};\n\nstatic int mmc_omap_new_slot(struct mmc_omap_host *host, int id)\n{\n\tstruct mmc_omap_slot *slot = NULL;\n\tstruct mmc_host *mmc;\n\tint r;\n\n\tmmc = mmc_alloc_host(sizeof(struct mmc_omap_slot), host->dev);\n\tif (mmc == NULL)\n\t\treturn -ENOMEM;\n\n\tslot = mmc_priv(mmc);\n\tslot->host = host;\n\tslot->mmc = mmc;\n\tslot->id = id;\n\tslot->power_mode = MMC_POWER_UNDEFINED;\n\tslot->pdata = &host->pdata->slots[id];\n\n\t \n\tslot->vsd = gpiod_get_index_optional(host->dev, \"vsd\",\n\t\t\t\t\t     id, GPIOD_OUT_LOW);\n\tif (IS_ERR(slot->vsd))\n\t\treturn dev_err_probe(host->dev, PTR_ERR(slot->vsd),\n\t\t\t\t     \"error looking up VSD GPIO\\n\");\n\tslot->vio = gpiod_get_index_optional(host->dev, \"vio\",\n\t\t\t\t\t     id, GPIOD_OUT_LOW);\n\tif (IS_ERR(slot->vio))\n\t\treturn dev_err_probe(host->dev, PTR_ERR(slot->vio),\n\t\t\t\t     \"error looking up VIO GPIO\\n\");\n\tslot->cover = gpiod_get_index_optional(host->dev, \"cover\",\n\t\t\t\t\t\tid, GPIOD_IN);\n\tif (IS_ERR(slot->cover))\n\t\treturn dev_err_probe(host->dev, PTR_ERR(slot->cover),\n\t\t\t\t     \"error looking up cover switch GPIO\\n\");\n\n\thost->slots[id] = slot;\n\n\tmmc->caps = 0;\n\tif (host->pdata->slots[id].wires >= 4)\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\tmmc->ops = &mmc_omap_ops;\n\tmmc->f_min = 400000;\n\n\tif (mmc_omap2())\n\t\tmmc->f_max = 48000000;\n\telse\n\t\tmmc->f_max = 24000000;\n\tif (host->pdata->max_freq)\n\t\tmmc->f_max = min(host->pdata->max_freq, mmc->f_max);\n\tmmc->ocr_avail = slot->pdata->ocr_mask;\n\n\t \n\tmmc->max_segs = 32;\n\tmmc->max_blk_size = 2048;\t \n\tmmc->max_blk_count = 2048;\t \n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\tif (slot->pdata->get_cover_state != NULL) {\n\t\ttimer_setup(&slot->cover_timer, mmc_omap_cover_timer, 0);\n\t\ttasklet_setup(&slot->cover_tasklet, mmc_omap_cover_handler);\n\t}\n\n\tr = mmc_add_host(mmc);\n\tif (r < 0)\n\t\tgoto err_remove_host;\n\n\tif (slot->pdata->name != NULL) {\n\t\tr = device_create_file(&mmc->class_dev,\n\t\t\t\t\t&dev_attr_slot_name);\n\t\tif (r < 0)\n\t\t\tgoto err_remove_host;\n\t}\n\n\tif (slot->pdata->get_cover_state != NULL) {\n\t\tr = device_create_file(&mmc->class_dev,\n\t\t\t\t\t&dev_attr_cover_switch);\n\t\tif (r < 0)\n\t\t\tgoto err_remove_slot_name;\n\t\ttasklet_schedule(&slot->cover_tasklet);\n\t}\n\n\treturn 0;\n\nerr_remove_slot_name:\n\tif (slot->pdata->name != NULL)\n\t\tdevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\nerr_remove_host:\n\tmmc_remove_host(mmc);\n\tmmc_free_host(mmc);\n\treturn r;\n}\n\nstatic void mmc_omap_remove_slot(struct mmc_omap_slot *slot)\n{\n\tstruct mmc_host *mmc = slot->mmc;\n\n\tif (slot->pdata->name != NULL)\n\t\tdevice_remove_file(&mmc->class_dev, &dev_attr_slot_name);\n\tif (slot->pdata->get_cover_state != NULL)\n\t\tdevice_remove_file(&mmc->class_dev, &dev_attr_cover_switch);\n\n\ttasklet_kill(&slot->cover_tasklet);\n\tdel_timer_sync(&slot->cover_timer);\n\tflush_workqueue(slot->host->mmc_omap_wq);\n\n\tmmc_remove_host(mmc);\n\tmmc_free_host(mmc);\n}\n\nstatic int mmc_omap_probe(struct platform_device *pdev)\n{\n\tstruct omap_mmc_platform_data *pdata = pdev->dev.platform_data;\n\tstruct mmc_omap_host *host = NULL;\n\tstruct resource *res;\n\tint i, ret = 0;\n\tint irq;\n\n\tif (pdata == NULL) {\n\t\tdev_err(&pdev->dev, \"platform data missing\\n\");\n\t\treturn -ENXIO;\n\t}\n\tif (pdata->nr_slots == 0) {\n\t\tdev_err(&pdev->dev, \"no slots\\n\");\n\t\treturn -EPROBE_DEFER;\n\t}\n\n\thost = devm_kzalloc(&pdev->dev, sizeof(struct mmc_omap_host),\n\t\t\t    GFP_KERNEL);\n\tif (host == NULL)\n\t\treturn -ENOMEM;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost->virt_base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->virt_base))\n\t\treturn PTR_ERR(host->virt_base);\n\n\thost->slot_switch = gpiod_get_optional(host->dev, \"switch\",\n\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(host->slot_switch))\n\t\treturn dev_err_probe(host->dev, PTR_ERR(host->slot_switch),\n\t\t\t\t     \"error looking up slot switch GPIO\\n\");\n\n\n\tINIT_WORK(&host->slot_release_work, mmc_omap_slot_release_work);\n\tINIT_WORK(&host->send_stop_work, mmc_omap_send_stop_work);\n\n\tINIT_WORK(&host->cmd_abort_work, mmc_omap_abort_command);\n\ttimer_setup(&host->cmd_abort_timer, mmc_omap_cmd_timer, 0);\n\n\tspin_lock_init(&host->clk_lock);\n\ttimer_setup(&host->clk_timer, mmc_omap_clk_timer, 0);\n\n\tspin_lock_init(&host->dma_lock);\n\tspin_lock_init(&host->slot_lock);\n\tinit_waitqueue_head(&host->slot_wq);\n\n\thost->pdata = pdata;\n\thost->features = host->pdata->slots[0].features;\n\thost->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, host);\n\n\thost->id = pdev->id;\n\thost->irq = irq;\n\thost->phys_base = res->start;\n\thost->iclk = clk_get(&pdev->dev, \"ick\");\n\tif (IS_ERR(host->iclk))\n\t\treturn PTR_ERR(host->iclk);\n\tclk_prepare_enable(host->iclk);\n\n\thost->fclk = clk_get(&pdev->dev, \"fck\");\n\tif (IS_ERR(host->fclk)) {\n\t\tret = PTR_ERR(host->fclk);\n\t\tgoto err_free_iclk;\n\t}\n\n\tret = clk_prepare(host->fclk);\n\tif (ret)\n\t\tgoto err_put_fclk;\n\n\thost->dma_tx_burst = -1;\n\thost->dma_rx_burst = -1;\n\n\thost->dma_tx = dma_request_chan(&pdev->dev, \"tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\tret = PTR_ERR(host->dma_tx);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto err_free_fclk;\n\n\t\thost->dma_tx = NULL;\n\t\tdev_warn(host->dev, \"TX DMA channel request failed\\n\");\n\t}\n\n\thost->dma_rx = dma_request_chan(&pdev->dev, \"rx\");\n\tif (IS_ERR(host->dma_rx)) {\n\t\tret = PTR_ERR(host->dma_rx);\n\t\tif (ret == -EPROBE_DEFER) {\n\t\t\tif (host->dma_tx)\n\t\t\t\tdma_release_channel(host->dma_tx);\n\t\t\tgoto err_free_fclk;\n\t\t}\n\n\t\thost->dma_rx = NULL;\n\t\tdev_warn(host->dev, \"RX DMA channel request failed\\n\");\n\t}\n\n\tret = request_irq(host->irq, mmc_omap_irq, 0, DRIVER_NAME, host);\n\tif (ret)\n\t\tgoto err_free_dma;\n\n\tif (pdata->init != NULL) {\n\t\tret = pdata->init(&pdev->dev);\n\t\tif (ret < 0)\n\t\t\tgoto err_free_irq;\n\t}\n\n\thost->nr_slots = pdata->nr_slots;\n\thost->reg_shift = (mmc_omap7xx() ? 1 : 2);\n\n\thost->mmc_omap_wq = alloc_workqueue(\"mmc_omap\", 0, 0);\n\tif (!host->mmc_omap_wq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_plat_cleanup;\n\t}\n\n\tfor (i = 0; i < pdata->nr_slots; i++) {\n\t\tret = mmc_omap_new_slot(host, i);\n\t\tif (ret < 0) {\n\t\t\twhile (--i >= 0)\n\t\t\t\tmmc_omap_remove_slot(host->slots[i]);\n\n\t\t\tgoto err_destroy_wq;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_destroy_wq:\n\tdestroy_workqueue(host->mmc_omap_wq);\nerr_plat_cleanup:\n\tif (pdata->cleanup)\n\t\tpdata->cleanup(&pdev->dev);\nerr_free_irq:\n\tfree_irq(host->irq, host);\nerr_free_dma:\n\tif (host->dma_tx)\n\t\tdma_release_channel(host->dma_tx);\n\tif (host->dma_rx)\n\t\tdma_release_channel(host->dma_rx);\nerr_free_fclk:\n\tclk_unprepare(host->fclk);\nerr_put_fclk:\n\tclk_put(host->fclk);\nerr_free_iclk:\n\tclk_disable_unprepare(host->iclk);\n\tclk_put(host->iclk);\n\treturn ret;\n}\n\nstatic void mmc_omap_remove(struct platform_device *pdev)\n{\n\tstruct mmc_omap_host *host = platform_get_drvdata(pdev);\n\tint i;\n\n\tBUG_ON(host == NULL);\n\n\tfor (i = 0; i < host->nr_slots; i++)\n\t\tmmc_omap_remove_slot(host->slots[i]);\n\n\tif (host->pdata->cleanup)\n\t\thost->pdata->cleanup(&pdev->dev);\n\n\tmmc_omap_fclk_enable(host, 0);\n\tfree_irq(host->irq, host);\n\tclk_unprepare(host->fclk);\n\tclk_put(host->fclk);\n\tclk_disable_unprepare(host->iclk);\n\tclk_put(host->iclk);\n\n\tif (host->dma_tx)\n\t\tdma_release_channel(host->dma_tx);\n\tif (host->dma_rx)\n\t\tdma_release_channel(host->dma_rx);\n\n\tdestroy_workqueue(host->mmc_omap_wq);\n}\n\n#if IS_BUILTIN(CONFIG_OF)\nstatic const struct of_device_id mmc_omap_match[] = {\n\t{ .compatible = \"ti,omap2420-mmc\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mmc_omap_match);\n#endif\n\nstatic struct platform_driver mmc_omap_driver = {\n\t.probe\t\t= mmc_omap_probe,\n\t.remove_new\t= mmc_omap_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(mmc_omap_match),\n\t},\n};\n\nmodule_platform_driver(mmc_omap_driver);\nMODULE_DESCRIPTION(\"OMAP Multimedia Card driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\nMODULE_AUTHOR(\"Juha Yrj\u00f6l\u00e4\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}