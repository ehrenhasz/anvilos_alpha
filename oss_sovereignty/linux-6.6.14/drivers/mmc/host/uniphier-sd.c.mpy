{
  "module_name": "uniphier-sd.c",
  "hash_id": "1560ea1ec75bc72db8dd3668dc86997257f066e3f6b1a0fa968b0338c7891647",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/uniphier-sd.c",
  "human_readable_source": "\n\n\n\n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mfd/tmio.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/reset.h>\n\n#include \"tmio_mmc.h\"\n\n#define   UNIPHIER_SD_CLK_CTL_DIV1024\t\tBIT(16)\n#define   UNIPHIER_SD_CLK_CTL_DIV1\t\tBIT(10)\n#define   UNIPHIER_SD_CLKCTL_OFFEN\t\tBIT(9)  \n#define UNIPHIER_SD_CC_EXT_MODE\t\t0x1b0\n#define   UNIPHIER_SD_CC_EXT_MODE_DMA\t\tBIT(1)\n#define UNIPHIER_SD_HOST_MODE\t\t0x1c8\n#define UNIPHIER_SD_VOLT\t\t0x1e4\n#define   UNIPHIER_SD_VOLT_MASK\t\t\tGENMASK(1, 0)\n#define   UNIPHIER_SD_VOLT_OFF\t\t\t0\n#define   UNIPHIER_SD_VOLT_330\t\t\t1\t\n#define   UNIPHIER_SD_VOLT_180\t\t\t2\t\n#define UNIPHIER_SD_DMA_MODE\t\t0x410\n#define   UNIPHIER_SD_DMA_MODE_DIR_MASK\t\tGENMASK(17, 16)\n#define   UNIPHIER_SD_DMA_MODE_DIR_TO_DEV\t0\n#define   UNIPHIER_SD_DMA_MODE_DIR_FROM_DEV\t1\n#define   UNIPHIER_SD_DMA_MODE_WIDTH_MASK\tGENMASK(5, 4)\n#define   UNIPHIER_SD_DMA_MODE_WIDTH_8\t\t0\n#define   UNIPHIER_SD_DMA_MODE_WIDTH_16\t\t1\n#define   UNIPHIER_SD_DMA_MODE_WIDTH_32\t\t2\n#define   UNIPHIER_SD_DMA_MODE_WIDTH_64\t\t3\n#define   UNIPHIER_SD_DMA_MODE_ADDR_INC\t\tBIT(0)\t\n#define UNIPHIER_SD_DMA_CTL\t\t0x414\n#define   UNIPHIER_SD_DMA_CTL_START\tBIT(0)\t\n#define UNIPHIER_SD_DMA_RST\t\t0x418\n#define   UNIPHIER_SD_DMA_RST_CH1\tBIT(9)\n#define   UNIPHIER_SD_DMA_RST_CH0\tBIT(8)\n#define UNIPHIER_SD_DMA_ADDR_L\t\t0x440\n#define UNIPHIER_SD_DMA_ADDR_H\t\t0x444\n\n \n#define UNIPHIER_SDCTRL_CHOFFSET\t0x200\n#define UNIPHIER_SDCTRL_MODE\t\t0x30\n#define   UNIPHIER_SDCTRL_MODE_UHS1MOD\t\tBIT(15)\n#define   UNIPHIER_SDCTRL_MODE_SDRSEL\t\tBIT(14)\n\n \n#define UNIPHIER_SD_CAP_EXTENDED_IP\t\tBIT(0)\n \n#define UNIPHIER_SD_CAP_BROKEN_DMA_RX\t\tBIT(1)\n\nstruct uniphier_sd_priv {\n\tstruct tmio_mmc_data tmio_data;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pinstate_uhs;\n\tstruct clk *clk;\n\tstruct reset_control *rst;\n\tstruct reset_control *rst_br;\n\tstruct reset_control *rst_hw;\n\tstruct dma_chan *chan;\n\tenum dma_data_direction dma_dir;\n\tstruct regmap *sdctrl_regmap;\n\tu32 sdctrl_ch;\n\tunsigned long clk_rate;\n\tunsigned long caps;\n};\n\nstatic void *uniphier_sd_priv(struct tmio_mmc_host *host)\n{\n\treturn container_of(host->pdata, struct uniphier_sd_priv, tmio_data);\n}\n\nstatic void uniphier_sd_dma_endisable(struct tmio_mmc_host *host, int enable)\n{\n\tsd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? DMA_ENABLE_DMASDRW : 0);\n}\n\n \nstatic void uniphier_sd_external_dma_issue(struct tasklet_struct *t)\n{\n\tstruct tmio_mmc_host *host = from_tasklet(host, t, dma_issue);\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\tuniphier_sd_dma_endisable(host, 1);\n\tdma_async_issue_pending(priv->chan);\n}\n\nstatic void uniphier_sd_external_dma_callback(void *param,\n\t\t\t\t\tconst struct dmaengine_result *result)\n{\n\tstruct tmio_mmc_host *host = param;\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tunsigned long flags;\n\n\tdma_unmap_sg(mmc_dev(host->mmc), host->sg_ptr, host->sg_len,\n\t\t     priv->dma_dir);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (result->result == DMA_TRANS_NOERROR) {\n\t\t \n\t\ttmio_mmc_enable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\t} else {\n\t\thost->data->error = -ETIMEDOUT;\n\t\ttmio_mmc_do_data_irq(host);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void uniphier_sd_external_dma_start(struct tmio_mmc_host *host,\n\t\t\t\t\t   struct mmc_data *data)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tenum dma_transfer_direction dma_tx_dir;\n\tstruct dma_async_tx_descriptor *desc;\n\tdma_cookie_t cookie;\n\tint sg_len;\n\n\tif (!priv->chan)\n\t\tgoto force_pio;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tpriv->dma_dir = DMA_FROM_DEVICE;\n\t\tdma_tx_dir = DMA_DEV_TO_MEM;\n\t} else {\n\t\tpriv->dma_dir = DMA_TO_DEVICE;\n\t\tdma_tx_dir = DMA_MEM_TO_DEV;\n\t}\n\n\tsg_len = dma_map_sg(mmc_dev(host->mmc), host->sg_ptr, host->sg_len,\n\t\t\t    priv->dma_dir);\n\tif (sg_len == 0)\n\t\tgoto force_pio;\n\n\tdesc = dmaengine_prep_slave_sg(priv->chan, host->sg_ptr, sg_len,\n\t\t\t\t       dma_tx_dir, DMA_CTRL_ACK);\n\tif (!desc)\n\t\tgoto unmap_sg;\n\n\tdesc->callback_result = uniphier_sd_external_dma_callback;\n\tdesc->callback_param = host;\n\n\tcookie = dmaengine_submit(desc);\n\tif (cookie < 0)\n\t\tgoto unmap_sg;\n\n\thost->dma_on = true;\n\n\treturn;\n\nunmap_sg:\n\tdma_unmap_sg(mmc_dev(host->mmc), host->sg_ptr, host->sg_len,\n\t\t     priv->dma_dir);\nforce_pio:\n\tuniphier_sd_dma_endisable(host, 0);\n}\n\nstatic void uniphier_sd_external_dma_enable(struct tmio_mmc_host *host,\n\t\t\t\t\t    bool enable)\n{\n}\n\nstatic void uniphier_sd_external_dma_request(struct tmio_mmc_host *host,\n\t\t\t\t\t     struct tmio_mmc_data *pdata)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tstruct dma_chan *chan;\n\n\tchan = dma_request_chan(mmc_dev(host->mmc), \"rx-tx\");\n\tif (IS_ERR(chan)) {\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"failed to request DMA channel. falling back to PIO\\n\");\n\t\treturn;\t \n\t}\n\n\t \n\tpriv->chan = chan;\n\thost->chan_rx = chan;\n\thost->chan_tx = chan;\n\n\ttasklet_setup(&host->dma_issue, uniphier_sd_external_dma_issue);\n}\n\nstatic void uniphier_sd_external_dma_release(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\tif (priv->chan)\n\t\tdma_release_channel(priv->chan);\n}\n\nstatic void uniphier_sd_external_dma_abort(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\tuniphier_sd_dma_endisable(host, 0);\n\n\tif (priv->chan)\n\t\tdmaengine_terminate_sync(priv->chan);\n}\n\nstatic void uniphier_sd_external_dma_dataend(struct tmio_mmc_host *host)\n{\n\tuniphier_sd_dma_endisable(host, 0);\n\n\ttmio_mmc_do_data_irq(host);\n}\n\nstatic const struct tmio_mmc_dma_ops uniphier_sd_external_dma_ops = {\n\t.start = uniphier_sd_external_dma_start,\n\t.enable = uniphier_sd_external_dma_enable,\n\t.request = uniphier_sd_external_dma_request,\n\t.release = uniphier_sd_external_dma_release,\n\t.abort = uniphier_sd_external_dma_abort,\n\t.dataend = uniphier_sd_external_dma_dataend,\n};\n\nstatic void uniphier_sd_internal_dma_issue(struct tasklet_struct *t)\n{\n\tstruct tmio_mmc_host *host = from_tasklet(host, t, dma_issue);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\ttmio_mmc_enable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tuniphier_sd_dma_endisable(host, 1);\n\twritel(UNIPHIER_SD_DMA_CTL_START, host->ctl + UNIPHIER_SD_DMA_CTL);\n}\n\nstatic void uniphier_sd_internal_dma_start(struct tmio_mmc_host *host,\n\t\t\t\t\t   struct mmc_data *data)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tstruct scatterlist *sg = host->sg_ptr;\n\tdma_addr_t dma_addr;\n\tunsigned int dma_mode_dir;\n\tu32 dma_mode;\n\tint sg_len;\n\n\tif ((data->flags & MMC_DATA_READ) && !host->chan_rx)\n\t\tgoto force_pio;\n\n\tif (WARN_ON(host->sg_len != 1))\n\t\tgoto force_pio;\n\n\tif (!IS_ALIGNED(sg->offset, 8))\n\t\tgoto force_pio;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tpriv->dma_dir = DMA_FROM_DEVICE;\n\t\tdma_mode_dir = UNIPHIER_SD_DMA_MODE_DIR_FROM_DEV;\n\t} else {\n\t\tpriv->dma_dir = DMA_TO_DEVICE;\n\t\tdma_mode_dir = UNIPHIER_SD_DMA_MODE_DIR_TO_DEV;\n\t}\n\n\tsg_len = dma_map_sg(mmc_dev(host->mmc), sg, 1, priv->dma_dir);\n\tif (sg_len == 0)\n\t\tgoto force_pio;\n\n\tdma_mode = FIELD_PREP(UNIPHIER_SD_DMA_MODE_DIR_MASK, dma_mode_dir);\n\tdma_mode |= FIELD_PREP(UNIPHIER_SD_DMA_MODE_WIDTH_MASK,\n\t\t\t       UNIPHIER_SD_DMA_MODE_WIDTH_64);\n\tdma_mode |= UNIPHIER_SD_DMA_MODE_ADDR_INC;\n\n\twritel(dma_mode, host->ctl + UNIPHIER_SD_DMA_MODE);\n\n\tdma_addr = sg_dma_address(data->sg);\n\twritel(lower_32_bits(dma_addr), host->ctl + UNIPHIER_SD_DMA_ADDR_L);\n\twritel(upper_32_bits(dma_addr), host->ctl + UNIPHIER_SD_DMA_ADDR_H);\n\n\thost->dma_on = true;\n\n\treturn;\nforce_pio:\n\tuniphier_sd_dma_endisable(host, 0);\n}\n\nstatic void uniphier_sd_internal_dma_enable(struct tmio_mmc_host *host,\n\t\t\t\t\t    bool enable)\n{\n}\n\nstatic void uniphier_sd_internal_dma_request(struct tmio_mmc_host *host,\n\t\t\t\t\t     struct tmio_mmc_data *pdata)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\t \n\tif (!(priv->caps & UNIPHIER_SD_CAP_BROKEN_DMA_RX))\n\t\thost->chan_rx = (void *)0xdeadbeaf;\n\n\thost->chan_tx = (void *)0xdeadbeaf;\n\n\ttasklet_setup(&host->dma_issue, uniphier_sd_internal_dma_issue);\n}\n\nstatic void uniphier_sd_internal_dma_release(struct tmio_mmc_host *host)\n{\n\t \n\thost->chan_rx = NULL;\n\thost->chan_tx = NULL;\n}\n\nstatic void uniphier_sd_internal_dma_abort(struct tmio_mmc_host *host)\n{\n\tu32 tmp;\n\n\tuniphier_sd_dma_endisable(host, 0);\n\n\ttmp = readl(host->ctl + UNIPHIER_SD_DMA_RST);\n\ttmp &= ~(UNIPHIER_SD_DMA_RST_CH1 | UNIPHIER_SD_DMA_RST_CH0);\n\twritel(tmp, host->ctl + UNIPHIER_SD_DMA_RST);\n\n\ttmp |= UNIPHIER_SD_DMA_RST_CH1 | UNIPHIER_SD_DMA_RST_CH0;\n\twritel(tmp, host->ctl + UNIPHIER_SD_DMA_RST);\n}\n\nstatic void uniphier_sd_internal_dma_dataend(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\tuniphier_sd_dma_endisable(host, 0);\n\tdma_unmap_sg(mmc_dev(host->mmc), host->sg_ptr, 1, priv->dma_dir);\n\n\ttmio_mmc_do_data_irq(host);\n}\n\nstatic const struct tmio_mmc_dma_ops uniphier_sd_internal_dma_ops = {\n\t.start = uniphier_sd_internal_dma_start,\n\t.enable = uniphier_sd_internal_dma_enable,\n\t.request = uniphier_sd_internal_dma_request,\n\t.release = uniphier_sd_internal_dma_release,\n\t.abort = uniphier_sd_internal_dma_abort,\n\t.dataend = uniphier_sd_internal_dma_dataend,\n};\n\nstatic int uniphier_sd_clk_enable(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_set_rate(priv->clk, ULONG_MAX);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tpriv->clk_rate = clk_get_rate(priv->clk);\n\n\t \n\tif (!mmc->f_max)\n\t\tmmc->f_max = priv->clk_rate;\n\n\t \n\tif (priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP)\n\t\tmmc->f_min = priv->clk_rate / 1024;\n\telse\n\t\tmmc->f_min = priv->clk_rate / 512;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = reset_control_deassert(priv->rst_br);\n\tif (ret)\n\t\tgoto assert_rst;\n\n\treturn 0;\n\nassert_rst:\n\treset_control_assert(priv->rst);\ndisable_clk:\n\tclk_disable_unprepare(priv->clk);\n\n\treturn ret;\n}\n\nstatic void uniphier_sd_clk_disable(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\treset_control_assert(priv->rst_br);\n\treset_control_assert(priv->rst);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic void uniphier_sd_hw_reset(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\n\treset_control_assert(priv->rst_hw);\n\t \n\tudelay(9);\n\treset_control_deassert(priv->rst_hw);\n\t \n\tusleep_range(300, 1000);\n}\n\nstatic void uniphier_sd_speed_switch(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tunsigned int offset;\n\tu32 val = 0;\n\n\tif (!(host->mmc->caps & MMC_CAP_UHS))\n\t\treturn;\n\n\tif (host->mmc->ios.timing == MMC_TIMING_UHS_SDR50 ||\n\t    host->mmc->ios.timing == MMC_TIMING_UHS_SDR104)\n\t\tval = UNIPHIER_SDCTRL_MODE_SDRSEL;\n\n\toffset = UNIPHIER_SDCTRL_CHOFFSET * priv->sdctrl_ch\n\t\t+ UNIPHIER_SDCTRL_MODE;\n\tregmap_write_bits(priv->sdctrl_regmap, offset,\n\t\t\t  UNIPHIER_SDCTRL_MODE_SDRSEL, val);\n}\n\nstatic void uniphier_sd_uhs_enable(struct tmio_mmc_host *host, bool uhs_en)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tunsigned int offset;\n\tu32 val;\n\n\tif (!(host->mmc->caps & MMC_CAP_UHS))\n\t\treturn;\n\n\tval = (uhs_en) ? UNIPHIER_SDCTRL_MODE_UHS1MOD : 0;\n\n\toffset = UNIPHIER_SDCTRL_CHOFFSET * priv->sdctrl_ch\n\t\t+ UNIPHIER_SDCTRL_MODE;\n\tregmap_write_bits(priv->sdctrl_regmap, offset,\n\t\t\t  UNIPHIER_SDCTRL_MODE_UHS1MOD, val);\n}\n\nstatic void uniphier_sd_set_clock(struct tmio_mmc_host *host,\n\t\t\t\t  unsigned int clock)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tunsigned long divisor;\n\tu32 tmp;\n\n\ttmp = readl(host->ctl + (CTL_SD_CARD_CLK_CTL << 1));\n\n\t \n\ttmp &= ~CLK_CTL_SCLKEN;\n\twritel(tmp, host->ctl + (CTL_SD_CARD_CLK_CTL << 1));\n\n\tuniphier_sd_speed_switch(host);\n\n\tif (clock == 0)\n\t\treturn;\n\n\ttmp &= ~UNIPHIER_SD_CLK_CTL_DIV1024;\n\ttmp &= ~UNIPHIER_SD_CLK_CTL_DIV1;\n\ttmp &= ~CLK_CTL_DIV_MASK;\n\n\tdivisor = priv->clk_rate / clock;\n\n\t \n\tif (divisor <= 1)\n\t\ttmp |= UNIPHIER_SD_CLK_CTL_DIV1;\n\telse if (priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP && divisor > 512)\n\t\ttmp |= UNIPHIER_SD_CLK_CTL_DIV1024;\n\telse\n\t\ttmp |= roundup_pow_of_two(divisor) >> 2;\n\n\twritel(tmp, host->ctl + (CTL_SD_CARD_CLK_CTL << 1));\n\n\ttmp |= CLK_CTL_SCLKEN;\n\twritel(tmp, host->ctl + (CTL_SD_CARD_CLK_CTL << 1));\n}\n\nstatic void uniphier_sd_host_init(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tu32 val;\n\n\t \n\tif (priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP)\n\t\tval = 0x00000101;\n\telse\n\t\tval = 0x00000000;\n\n\twritel(val, host->ctl + UNIPHIER_SD_HOST_MODE);\n\n\tval = 0;\n\t \n\tif (priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP)\n\t\tval |= UNIPHIER_SD_CLKCTL_OFFEN;\n\n\twritel(val, host->ctl + (CTL_SD_CARD_CLK_CTL << 1));\n}\n\nstatic int uniphier_sd_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t\t   struct mmc_ios *ios)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tstruct pinctrl_state *pinstate = NULL;\n\tu32 val, tmp;\n\tbool uhs_en;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tval = UNIPHIER_SD_VOLT_330;\n\t\tuhs_en = false;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tval = UNIPHIER_SD_VOLT_180;\n\t\tpinstate = priv->pinstate_uhs;\n\t\tuhs_en = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTSUPP;\n\t}\n\n\ttmp = readl(host->ctl + UNIPHIER_SD_VOLT);\n\ttmp &= ~UNIPHIER_SD_VOLT_MASK;\n\ttmp |= FIELD_PREP(UNIPHIER_SD_VOLT_MASK, val);\n\twritel(tmp, host->ctl + UNIPHIER_SD_VOLT);\n\n\tif (pinstate)\n\t\tpinctrl_select_state(priv->pinctrl, pinstate);\n\telse\n\t\tpinctrl_select_default_state(mmc_dev(mmc));\n\n\tuniphier_sd_uhs_enable(host, uhs_en);\n\n\treturn 0;\n}\n\nstatic int uniphier_sd_uhs_init(struct tmio_mmc_host *host)\n{\n\tstruct uniphier_sd_priv *priv = uniphier_sd_priv(host);\n\tstruct device *dev = &host->pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args args;\n\tint ret;\n\n\tpriv->pinctrl = devm_pinctrl_get(mmc_dev(host->mmc));\n\tif (IS_ERR(priv->pinctrl))\n\t\treturn PTR_ERR(priv->pinctrl);\n\n\tpriv->pinstate_uhs = pinctrl_lookup_state(priv->pinctrl, \"uhs\");\n\tif (IS_ERR(priv->pinstate_uhs))\n\t\treturn PTR_ERR(priv->pinstate_uhs);\n\n\tret = of_parse_phandle_with_fixed_args(np,\n\t\t\t\t\t       \"socionext,syscon-uhs-mode\",\n\t\t\t\t\t       1, 0, &args);\n\tif (ret) {\n\t\tdev_err(dev, \"Can't get syscon-uhs-mode property\\n\");\n\t\treturn ret;\n\t}\n\tpriv->sdctrl_regmap = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tif (IS_ERR(priv->sdctrl_regmap)) {\n\t\tdev_err(dev, \"Can't map syscon-uhs-mode\\n\");\n\t\treturn PTR_ERR(priv->sdctrl_regmap);\n\t}\n\tpriv->sdctrl_ch = args.args[0];\n\n\treturn 0;\n}\n\nstatic int uniphier_sd_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct uniphier_sd_priv *priv;\n\tstruct tmio_mmc_data *tmio_data;\n\tstruct tmio_mmc_host *host;\n\tint irq, ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->caps = (unsigned long)of_device_get_match_data(dev);\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\tpriv->rst = devm_reset_control_get_shared(dev, \"host\");\n\tif (IS_ERR(priv->rst)) {\n\t\tdev_err(dev, \"failed to get host reset\\n\");\n\t\treturn PTR_ERR(priv->rst);\n\t}\n\n\t \n\tif (!(priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP)) {\n\t\tpriv->rst_br = devm_reset_control_get_shared(dev, \"bridge\");\n\t\tif (IS_ERR(priv->rst_br)) {\n\t\t\tdev_err(dev, \"failed to get bridge reset\\n\");\n\t\t\treturn PTR_ERR(priv->rst_br);\n\t\t}\n\t}\n\n\ttmio_data = &priv->tmio_data;\n\ttmio_data->flags |= TMIO_MMC_32BIT_DATA_PORT;\n\ttmio_data->flags |= TMIO_MMC_USE_BUSY_TIMEOUT;\n\n\thost = tmio_mmc_host_alloc(pdev, tmio_data);\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tif (host->mmc->caps & MMC_CAP_HW_RESET) {\n\t\tpriv->rst_hw = devm_reset_control_get_exclusive(dev, \"hw\");\n\t\tif (IS_ERR(priv->rst_hw)) {\n\t\t\tdev_err(dev, \"failed to get hw reset\\n\");\n\t\t\tret = PTR_ERR(priv->rst_hw);\n\t\t\tgoto free_host;\n\t\t}\n\t\thost->ops.card_hw_reset = uniphier_sd_hw_reset;\n\t}\n\n\tif (host->mmc->caps & MMC_CAP_UHS) {\n\t\tret = uniphier_sd_uhs_init(host);\n\t\tif (ret) {\n\t\t\tdev_warn(dev,\n\t\t\t\t \"failed to setup UHS (error %d).  Disabling UHS.\",\n\t\t\t\t ret);\n\t\t\thost->mmc->caps &= ~MMC_CAP_UHS;\n\t\t} else {\n\t\t\thost->ops.start_signal_voltage_switch =\n\t\t\t\tuniphier_sd_start_signal_voltage_switch;\n\t\t}\n\t}\n\n\tif (priv->caps & UNIPHIER_SD_CAP_EXTENDED_IP)\n\t\thost->dma_ops = &uniphier_sd_internal_dma_ops;\n\telse\n\t\thost->dma_ops = &uniphier_sd_external_dma_ops;\n\n\thost->bus_shift = 1;\n\thost->clk_enable = uniphier_sd_clk_enable;\n\thost->clk_disable = uniphier_sd_clk_disable;\n\thost->set_clock = uniphier_sd_set_clock;\n\n\tret = uniphier_sd_clk_enable(host);\n\tif (ret)\n\t\tgoto free_host;\n\n\tuniphier_sd_host_init(host);\n\n\ttmio_data->ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tif (host->mmc->caps & MMC_CAP_UHS)\n\t\ttmio_data->ocr_mask |= MMC_VDD_165_195;\n\n\ttmio_data->max_segs = 1;\n\ttmio_data->max_blk_count = U16_MAX;\n\n\tsd_ctrl_write32_as_16_and_16(host, CTL_IRQ_MASK, TMIO_MASK_ALL);\n\n\tret = devm_request_irq(dev, irq, tmio_mmc_irq, IRQF_SHARED,\n\t\t\t       dev_name(dev), host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = tmio_mmc_host_probe(host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tuniphier_sd_clk_disable(host);\nfree_host:\n\ttmio_mmc_host_free(host);\n\n\treturn ret;\n}\n\nstatic void uniphier_sd_remove(struct platform_device *pdev)\n{\n\tstruct tmio_mmc_host *host = platform_get_drvdata(pdev);\n\n\ttmio_mmc_host_remove(host);\n\tuniphier_sd_clk_disable(host);\n\ttmio_mmc_host_free(host);\n}\n\nstatic const struct of_device_id uniphier_sd_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-sd-v2.91\",\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-sd-v3.1\",\n\t\t.data = (void *)(UNIPHIER_SD_CAP_EXTENDED_IP |\n\t\t\t\t UNIPHIER_SD_CAP_BROKEN_DMA_RX),\n\t},\n\t{\n\t\t.compatible = \"socionext,uniphier-sd-v3.1.1\",\n\t\t.data = (void *)UNIPHIER_SD_CAP_EXTENDED_IP,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, uniphier_sd_match);\n\nstatic struct platform_driver uniphier_sd_driver = {\n\t.probe = uniphier_sd_probe,\n\t.remove_new = uniphier_sd_remove,\n\t.driver = {\n\t\t.name = \"uniphier-sd\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = uniphier_sd_match,\n\t},\n};\nmodule_platform_driver(uniphier_sd_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"UniPhier SD/eMMC host controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}