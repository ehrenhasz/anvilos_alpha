{
  "module_name": "mtk-sd.c",
  "hash_id": "a93c0e5c8b3673ec35824758941c742d9c2c1f347671186d1950026e04b52b34",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mtk-sd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/reset.h>\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include \"cqhci.h\"\n\n#define MAX_BD_NUM          1024\n#define MSDC_NR_CLOCKS      3\n\n \n \n \n#define MSDC_BUS_1BITS          0x0\n#define MSDC_BUS_4BITS          0x1\n#define MSDC_BUS_8BITS          0x2\n\n#define MSDC_BURST_64B          0x6\n\n \n \n \n#define MSDC_CFG         0x0\n#define MSDC_IOCON       0x04\n#define MSDC_PS          0x08\n#define MSDC_INT         0x0c\n#define MSDC_INTEN       0x10\n#define MSDC_FIFOCS      0x14\n#define SDC_CFG          0x30\n#define SDC_CMD          0x34\n#define SDC_ARG          0x38\n#define SDC_STS          0x3c\n#define SDC_RESP0        0x40\n#define SDC_RESP1        0x44\n#define SDC_RESP2        0x48\n#define SDC_RESP3        0x4c\n#define SDC_BLK_NUM      0x50\n#define SDC_ADV_CFG0     0x64\n#define EMMC_IOCON       0x7c\n#define SDC_ACMD_RESP    0x80\n#define DMA_SA_H4BIT     0x8c\n#define MSDC_DMA_SA      0x90\n#define MSDC_DMA_CTRL    0x98\n#define MSDC_DMA_CFG     0x9c\n#define MSDC_PATCH_BIT   0xb0\n#define MSDC_PATCH_BIT1  0xb4\n#define MSDC_PATCH_BIT2  0xb8\n#define MSDC_PAD_TUNE    0xec\n#define MSDC_PAD_TUNE0   0xf0\n#define PAD_DS_TUNE      0x188\n#define PAD_CMD_TUNE     0x18c\n#define EMMC51_CFG0\t 0x204\n#define EMMC50_CFG0      0x208\n#define EMMC50_CFG1      0x20c\n#define EMMC50_CFG3      0x220\n#define SDC_FIFO_CFG     0x228\n#define CQHCI_SETTING\t 0x7fc\n\n \n \n \n#define EMMC_TOP_CONTROL\t0x00\n#define EMMC_TOP_CMD\t\t0x04\n#define EMMC50_PAD_DS_TUNE\t0x0c\n\n \n \n \n\n \n#define MSDC_CFG_MODE           BIT(0)\t \n#define MSDC_CFG_CKPDN          BIT(1)\t \n#define MSDC_CFG_RST            BIT(2)\t \n#define MSDC_CFG_PIO            BIT(3)\t \n#define MSDC_CFG_CKDRVEN        BIT(4)\t \n#define MSDC_CFG_BV18SDT        BIT(5)\t \n#define MSDC_CFG_BV18PSS        BIT(6)\t \n#define MSDC_CFG_CKSTB          BIT(7)\t \n#define MSDC_CFG_CKDIV          GENMASK(15, 8)\t \n#define MSDC_CFG_CKMOD          GENMASK(17, 16)\t \n#define MSDC_CFG_HS400_CK_MODE  BIT(18)\t \n#define MSDC_CFG_HS400_CK_MODE_EXTRA  BIT(22)\t \n#define MSDC_CFG_CKDIV_EXTRA    GENMASK(19, 8)\t \n#define MSDC_CFG_CKMOD_EXTRA    GENMASK(21, 20)\t \n\n \n#define MSDC_IOCON_SDR104CKS    BIT(0)\t \n#define MSDC_IOCON_RSPL         BIT(1)\t \n#define MSDC_IOCON_DSPL         BIT(2)\t \n#define MSDC_IOCON_DDLSEL       BIT(3)\t \n#define MSDC_IOCON_DDR50CKD     BIT(4)\t \n#define MSDC_IOCON_DSPLSEL      BIT(5)\t \n#define MSDC_IOCON_W_DSPL       BIT(8)\t \n#define MSDC_IOCON_D0SPL        BIT(16)\t \n#define MSDC_IOCON_D1SPL        BIT(17)\t \n#define MSDC_IOCON_D2SPL        BIT(18)\t \n#define MSDC_IOCON_D3SPL        BIT(19)\t \n#define MSDC_IOCON_D4SPL        BIT(20)\t \n#define MSDC_IOCON_D5SPL        BIT(21)\t \n#define MSDC_IOCON_D6SPL        BIT(22)\t \n#define MSDC_IOCON_D7SPL        BIT(23)\t \n#define MSDC_IOCON_RISCSZ       GENMASK(25, 24)\t \n\n \n#define MSDC_PS_CDEN            BIT(0)\t \n#define MSDC_PS_CDSTS           BIT(1)\t \n#define MSDC_PS_CDDEBOUNCE      GENMASK(15, 12)\t \n#define MSDC_PS_DAT             GENMASK(23, 16)\t \n#define MSDC_PS_DATA1           BIT(17)\t \n#define MSDC_PS_CMD             BIT(24)\t \n#define MSDC_PS_WP              BIT(31)\t \n\n \n#define MSDC_INT_MMCIRQ         BIT(0)\t \n#define MSDC_INT_CDSC           BIT(1)\t \n#define MSDC_INT_ACMDRDY        BIT(3)\t \n#define MSDC_INT_ACMDTMO        BIT(4)\t \n#define MSDC_INT_ACMDCRCERR     BIT(5)\t \n#define MSDC_INT_DMAQ_EMPTY     BIT(6)\t \n#define MSDC_INT_SDIOIRQ        BIT(7)\t \n#define MSDC_INT_CMDRDY         BIT(8)\t \n#define MSDC_INT_CMDTMO         BIT(9)\t \n#define MSDC_INT_RSPCRCERR      BIT(10)\t \n#define MSDC_INT_CSTA           BIT(11)\t \n#define MSDC_INT_XFER_COMPL     BIT(12)\t \n#define MSDC_INT_DXFER_DONE     BIT(13)\t \n#define MSDC_INT_DATTMO         BIT(14)\t \n#define MSDC_INT_DATCRCERR      BIT(15)\t \n#define MSDC_INT_ACMD19_DONE    BIT(16)\t \n#define MSDC_INT_DMA_BDCSERR    BIT(17)\t \n#define MSDC_INT_DMA_GPDCSERR   BIT(18)\t \n#define MSDC_INT_DMA_PROTECT    BIT(19)\t \n#define MSDC_INT_CMDQ           BIT(28)\t \n\n \n#define MSDC_INTEN_MMCIRQ       BIT(0)\t \n#define MSDC_INTEN_CDSC         BIT(1)\t \n#define MSDC_INTEN_ACMDRDY      BIT(3)\t \n#define MSDC_INTEN_ACMDTMO      BIT(4)\t \n#define MSDC_INTEN_ACMDCRCERR   BIT(5)\t \n#define MSDC_INTEN_DMAQ_EMPTY   BIT(6)\t \n#define MSDC_INTEN_SDIOIRQ      BIT(7)\t \n#define MSDC_INTEN_CMDRDY       BIT(8)\t \n#define MSDC_INTEN_CMDTMO       BIT(9)\t \n#define MSDC_INTEN_RSPCRCERR    BIT(10)\t \n#define MSDC_INTEN_CSTA         BIT(11)\t \n#define MSDC_INTEN_XFER_COMPL   BIT(12)\t \n#define MSDC_INTEN_DXFER_DONE   BIT(13)\t \n#define MSDC_INTEN_DATTMO       BIT(14)\t \n#define MSDC_INTEN_DATCRCERR    BIT(15)\t \n#define MSDC_INTEN_ACMD19_DONE  BIT(16)\t \n#define MSDC_INTEN_DMA_BDCSERR  BIT(17)\t \n#define MSDC_INTEN_DMA_GPDCSERR BIT(18)\t \n#define MSDC_INTEN_DMA_PROTECT  BIT(19)\t \n\n \n#define MSDC_FIFOCS_RXCNT       GENMASK(7, 0)\t \n#define MSDC_FIFOCS_TXCNT       GENMASK(23, 16)\t \n#define MSDC_FIFOCS_CLR         BIT(31)\t \n\n \n#define SDC_CFG_SDIOINTWKUP     BIT(0)\t \n#define SDC_CFG_INSWKUP         BIT(1)\t \n#define SDC_CFG_WRDTOC          GENMASK(14, 2)   \n#define SDC_CFG_BUSWIDTH        GENMASK(17, 16)\t \n#define SDC_CFG_SDIO            BIT(19)\t \n#define SDC_CFG_SDIOIDE         BIT(20)\t \n#define SDC_CFG_INTATGAP        BIT(21)\t \n#define SDC_CFG_DTOC            GENMASK(31, 24)\t \n\n \n#define SDC_STS_SDCBUSY         BIT(0)\t \n#define SDC_STS_CMDBUSY         BIT(1)\t \n#define SDC_STS_SWR_COMPL       BIT(31)\t \n\n#define SDC_DAT1_IRQ_TRIGGER\tBIT(19)\t \n \n#define SDC_RX_ENHANCE_EN\tBIT(20)\t \n\n \n#define DMA_ADDR_HIGH_4BIT      GENMASK(3, 0)\t \n\n \n#define MSDC_DMA_CTRL_START     BIT(0)\t \n#define MSDC_DMA_CTRL_STOP      BIT(1)\t \n#define MSDC_DMA_CTRL_RESUME    BIT(2)\t \n#define MSDC_DMA_CTRL_MODE      BIT(8)\t \n#define MSDC_DMA_CTRL_LASTBUF   BIT(10)\t \n#define MSDC_DMA_CTRL_BRUSTSZ   GENMASK(14, 12)\t \n\n \n#define MSDC_DMA_CFG_STS        BIT(0)\t \n#define MSDC_DMA_CFG_DECSEN     BIT(1)\t \n#define MSDC_DMA_CFG_AHBHPROT2  BIT(9)\t \n#define MSDC_DMA_CFG_ACTIVEEN   BIT(13)\t \n#define MSDC_DMA_CFG_CS12B16B   BIT(16)\t \n\n \n#define MSDC_PATCH_BIT_ODDSUPP    BIT(1)\t \n#define MSDC_INT_DAT_LATCH_CK_SEL GENMASK(9, 7)\n#define MSDC_CKGEN_MSDC_DLY_SEL   GENMASK(14, 10)\n#define MSDC_PATCH_BIT_IODSSEL    BIT(16)\t \n#define MSDC_PATCH_BIT_IOINTSEL   BIT(17)\t \n#define MSDC_PATCH_BIT_BUSYDLY    GENMASK(21, 18)\t \n#define MSDC_PATCH_BIT_WDOD       GENMASK(25, 22)\t \n#define MSDC_PATCH_BIT_IDRTSEL    BIT(26)\t \n#define MSDC_PATCH_BIT_CMDFSEL    BIT(27)\t \n#define MSDC_PATCH_BIT_INTDLSEL   BIT(28)\t \n#define MSDC_PATCH_BIT_SPCPUSH    BIT(29)\t \n#define MSDC_PATCH_BIT_DECRCTMO   BIT(30)\t \n\n#define MSDC_PATCH_BIT1_CMDTA     GENMASK(5, 3)     \n#define MSDC_PB1_BUSY_CHECK_SEL   BIT(7)     \n#define MSDC_PATCH_BIT1_STOP_DLY  GENMASK(11, 8)     \n\n#define MSDC_PATCH_BIT2_CFGRESP   BIT(15)    \n#define MSDC_PATCH_BIT2_CFGCRCSTS BIT(28)    \n#define MSDC_PB2_SUPPORT_64G      BIT(1)     \n#define MSDC_PB2_RESPWAIT         GENMASK(3, 2)    \n#define MSDC_PB2_RESPSTSENSEL     GENMASK(18, 16)  \n#define MSDC_PB2_CRCSTSENSEL      GENMASK(31, 29)  \n\n#define MSDC_PAD_TUNE_DATWRDLY\t  GENMASK(4, 0)\t\t \n#define MSDC_PAD_TUNE_DATRRDLY\t  GENMASK(12, 8)\t \n#define MSDC_PAD_TUNE_CMDRDLY\t  GENMASK(20, 16)\t \n#define MSDC_PAD_TUNE_CMDRRDLY\t  GENMASK(26, 22)\t \n#define MSDC_PAD_TUNE_CLKTDLY\t  GENMASK(31, 27)\t \n#define MSDC_PAD_TUNE_RXDLYSEL\t  BIT(15)    \n#define MSDC_PAD_TUNE_RD_SEL\t  BIT(13)    \n#define MSDC_PAD_TUNE_CMD_SEL\t  BIT(21)    \n\n#define PAD_DS_TUNE_DLY_SEL       BIT(0)\t   \n#define PAD_DS_TUNE_DLY1\t  GENMASK(6, 2)    \n#define PAD_DS_TUNE_DLY2\t  GENMASK(11, 7)   \n#define PAD_DS_TUNE_DLY3\t  GENMASK(16, 12)  \n\n#define PAD_CMD_TUNE_RX_DLY3\t  GENMASK(5, 1)    \n\n \n#define CMDQ_RDAT_CNT\t\t  GENMASK(21, 12)  \n\n#define EMMC50_CFG_PADCMD_LATCHCK BIT(0)    \n#define EMMC50_CFG_CRCSTS_EDGE    BIT(3)    \n#define EMMC50_CFG_CFCSTS_SEL     BIT(4)    \n#define EMMC50_CFG_CMD_RESP_SEL   BIT(9)    \n\n \n#define EMMC50_CFG1_DS_CFG        BIT(28)   \n\n#define EMMC50_CFG3_OUTS_WR       GENMASK(4, 0)   \n\n#define SDC_FIFO_CFG_WRVALIDSEL   BIT(24)   \n#define SDC_FIFO_CFG_RDVALIDSEL   BIT(25)   \n\n \n#define CQHCI_RD_CMD_WND_SEL\t  BIT(14)  \n#define CQHCI_WR_CMD_WND_SEL\t  BIT(15)  \n\n \n#define PAD_RXDLY_SEL           BIT(0)       \n#define DELAY_EN                BIT(1)       \n#define PAD_DAT_RD_RXDLY2       GENMASK(6, 2)      \n#define PAD_DAT_RD_RXDLY        GENMASK(11, 7)     \n#define PAD_DAT_RD_RXDLY2_SEL   BIT(12)      \n#define PAD_DAT_RD_RXDLY_SEL    BIT(13)      \n#define DATA_K_VALUE_SEL        BIT(14)      \n#define SDC_RX_ENH_EN           BIT(15)      \n\n \n#define PAD_CMD_RXDLY2          GENMASK(4, 0)\t \n#define PAD_CMD_RXDLY           GENMASK(9, 5)\t \n#define PAD_CMD_RD_RXDLY2_SEL   BIT(10)\t\t \n#define PAD_CMD_RD_RXDLY_SEL    BIT(11)\t\t \n#define PAD_CMD_TX_DLY          GENMASK(16, 12)\t \n\n \n#define PAD_DS_DLY_SEL\t\tBIT(16)\t \n#define PAD_DS_DLY1\t\tGENMASK(14, 10)\t \n#define PAD_DS_DLY3\t\tGENMASK(4, 0)\t \n\n#define REQ_CMD_EIO  BIT(0)\n#define REQ_CMD_TMO  BIT(1)\n#define REQ_DAT_ERR  BIT(2)\n#define REQ_STOP_EIO BIT(3)\n#define REQ_STOP_TMO BIT(4)\n#define REQ_CMD_BUSY BIT(5)\n\n#define MSDC_PREPARE_FLAG BIT(0)\n#define MSDC_ASYNC_FLAG BIT(1)\n#define MSDC_MMAP_FLAG BIT(2)\n\n#define MTK_MMC_AUTOSUSPEND_DELAY\t50\n#define CMD_TIMEOUT         (HZ/10 * 5)\t \n#define DAT_TIMEOUT         (HZ    * 5)\t \n\n#define DEFAULT_DEBOUNCE\t(8)\t \n\n#define PAD_DELAY_MAX\t32  \n \n \n \nstruct mt_gpdma_desc {\n\tu32 gpd_info;\n#define GPDMA_DESC_HWO\t\tBIT(0)\n#define GPDMA_DESC_BDP\t\tBIT(1)\n#define GPDMA_DESC_CHECKSUM\tGENMASK(15, 8)\n#define GPDMA_DESC_INT\t\tBIT(16)\n#define GPDMA_DESC_NEXT_H4\tGENMASK(27, 24)\n#define GPDMA_DESC_PTR_H4\tGENMASK(31, 28)\n\tu32 next;\n\tu32 ptr;\n\tu32 gpd_data_len;\n#define GPDMA_DESC_BUFLEN\tGENMASK(15, 0)\n#define GPDMA_DESC_EXTLEN\tGENMASK(23, 16)\n\tu32 arg;\n\tu32 blknum;\n\tu32 cmd;\n};\n\nstruct mt_bdma_desc {\n\tu32 bd_info;\n#define BDMA_DESC_EOL\t\tBIT(0)\n#define BDMA_DESC_CHECKSUM\tGENMASK(15, 8)\n#define BDMA_DESC_BLKPAD\tBIT(17)\n#define BDMA_DESC_DWPAD\t\tBIT(18)\n#define BDMA_DESC_NEXT_H4\tGENMASK(27, 24)\n#define BDMA_DESC_PTR_H4\tGENMASK(31, 28)\n\tu32 next;\n\tu32 ptr;\n\tu32 bd_data_len;\n#define BDMA_DESC_BUFLEN\tGENMASK(15, 0)\n#define BDMA_DESC_BUFLEN_EXT\tGENMASK(23, 0)\n};\n\nstruct msdc_dma {\n\tstruct scatterlist *sg;\t \n\tstruct mt_gpdma_desc *gpd;\t\t \n\tstruct mt_bdma_desc *bd;\t\t \n\tdma_addr_t gpd_addr;\t \n\tdma_addr_t bd_addr;\t \n};\n\nstruct msdc_save_para {\n\tu32 msdc_cfg;\n\tu32 iocon;\n\tu32 sdc_cfg;\n\tu32 pad_tune;\n\tu32 patch_bit0;\n\tu32 patch_bit1;\n\tu32 patch_bit2;\n\tu32 pad_ds_tune;\n\tu32 pad_cmd_tune;\n\tu32 emmc50_cfg0;\n\tu32 emmc50_cfg3;\n\tu32 sdc_fifo_cfg;\n\tu32 emmc_top_control;\n\tu32 emmc_top_cmd;\n\tu32 emmc50_pad_ds_tune;\n};\n\nstruct mtk_mmc_compatible {\n\tu8 clk_div_bits;\n\tbool recheck_sdio_irq;\n\tbool hs400_tune;  \n\tu32 pad_tune_reg;\n\tbool async_fifo;\n\tbool data_tune;\n\tbool busy_check;\n\tbool stop_clk_fix;\n\tbool enhance_rx;\n\tbool support_64g;\n\tbool use_internal_cd;\n};\n\nstruct msdc_tune_para {\n\tu32 iocon;\n\tu32 pad_tune;\n\tu32 pad_cmd_tune;\n\tu32 emmc_top_control;\n\tu32 emmc_top_cmd;\n};\n\nstruct msdc_delay_phase {\n\tu8 maxlen;\n\tu8 start;\n\tu8 final_phase;\n};\n\nstruct msdc_host {\n\tstruct device *dev;\n\tconst struct mtk_mmc_compatible *dev_comp;\n\tint cmd_rsp;\n\n\tspinlock_t lock;\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\tint error;\n\n\tvoid __iomem *base;\t\t \n\tvoid __iomem *top_base;\t\t \n\n\tstruct msdc_dma dma;\t \n\tu64 dma_mask;\n\n\tu32 timeout_ns;\t\t \n\tu32 timeout_clks;\t \n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_default;\n\tstruct pinctrl_state *pins_uhs;\n\tstruct pinctrl_state *pins_eint;\n\tstruct delayed_work req_timeout;\n\tint irq;\t\t \n\tint eint_irq;\t\t \n\tstruct reset_control *reset;\n\n\tstruct clk *src_clk;\t \n\tstruct clk *h_clk;       \n\tstruct clk *bus_clk;\t \n\tstruct clk *src_clk_cg;  \n\tstruct clk *sys_clk_cg;\t \n\tstruct clk *crypto_clk;  \n\tstruct clk_bulk_data bulk_clks[MSDC_NR_CLOCKS];\n\tu32 mclk;\t\t \n\tu32 src_clk_freq;\t \n\tunsigned char timing;\n\tbool vqmmc_enabled;\n\tu32 latch_ck;\n\tu32 hs400_ds_delay;\n\tu32 hs400_ds_dly3;\n\tu32 hs200_cmd_int_delay;  \n\tu32 hs400_cmd_int_delay;  \n\tbool hs400_cmd_resp_sel_rising;\n\t\t\t\t  \n\tbool hs400_mode;\t \n\tbool hs400_tuning;\t \n\tbool internal_cd;\t \n\tbool cqhci;\t\t \n\tstruct msdc_save_para save_para;  \n\tstruct msdc_tune_para def_tune_para;  \n\tstruct msdc_tune_para saved_tune_para;  \n\tstruct cqhci_host *cq_host;\n\tu32 cq_ssc1_time;\n};\n\nstatic const struct mtk_mmc_compatible mt2701_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = false,\n\t.stop_clk_fix = false,\n\t.enhance_rx = false,\n\t.support_64g = false,\n};\n\nstatic const struct mtk_mmc_compatible mt2712_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = false,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n\t.enhance_rx = true,\n\t.support_64g = true,\n};\n\nstatic const struct mtk_mmc_compatible mt6779_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = false,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n\t.enhance_rx = true,\n\t.support_64g = true,\n};\n\nstatic const struct mtk_mmc_compatible mt6795_compat = {\n\t.clk_div_bits = 8,\n\t.recheck_sdio_irq = false,\n\t.hs400_tune = true,\n\t.pad_tune_reg = MSDC_PAD_TUNE,\n\t.async_fifo = false,\n\t.data_tune = false,\n\t.busy_check = false,\n\t.stop_clk_fix = false,\n\t.enhance_rx = false,\n\t.support_64g = false,\n};\n\nstatic const struct mtk_mmc_compatible mt7620_compat = {\n\t.clk_div_bits = 8,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE,\n\t.async_fifo = false,\n\t.data_tune = false,\n\t.busy_check = false,\n\t.stop_clk_fix = false,\n\t.enhance_rx = false,\n\t.use_internal_cd = true,\n};\n\nstatic const struct mtk_mmc_compatible mt7622_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n\t.enhance_rx = true,\n\t.support_64g = false,\n};\n\nstatic const struct mtk_mmc_compatible mt7986_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n\t.enhance_rx = true,\n\t.support_64g = true,\n};\n\nstatic const struct mtk_mmc_compatible mt8135_compat = {\n\t.clk_div_bits = 8,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE,\n\t.async_fifo = false,\n\t.data_tune = false,\n\t.busy_check = false,\n\t.stop_clk_fix = false,\n\t.enhance_rx = false,\n\t.support_64g = false,\n};\n\nstatic const struct mtk_mmc_compatible mt8173_compat = {\n\t.clk_div_bits = 8,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = true,\n\t.pad_tune_reg = MSDC_PAD_TUNE,\n\t.async_fifo = false,\n\t.data_tune = false,\n\t.busy_check = false,\n\t.stop_clk_fix = false,\n\t.enhance_rx = false,\n\t.support_64g = false,\n};\n\nstatic const struct mtk_mmc_compatible mt8183_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = false,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n\t.enhance_rx = true,\n\t.support_64g = true,\n};\n\nstatic const struct mtk_mmc_compatible mt8516_compat = {\n\t.clk_div_bits = 12,\n\t.recheck_sdio_irq = true,\n\t.hs400_tune = false,\n\t.pad_tune_reg = MSDC_PAD_TUNE0,\n\t.async_fifo = true,\n\t.data_tune = true,\n\t.busy_check = true,\n\t.stop_clk_fix = true,\n};\n\nstatic const struct of_device_id msdc_of_ids[] = {\n\t{ .compatible = \"mediatek,mt2701-mmc\", .data = &mt2701_compat},\n\t{ .compatible = \"mediatek,mt2712-mmc\", .data = &mt2712_compat},\n\t{ .compatible = \"mediatek,mt6779-mmc\", .data = &mt6779_compat},\n\t{ .compatible = \"mediatek,mt6795-mmc\", .data = &mt6795_compat},\n\t{ .compatible = \"mediatek,mt7620-mmc\", .data = &mt7620_compat},\n\t{ .compatible = \"mediatek,mt7622-mmc\", .data = &mt7622_compat},\n\t{ .compatible = \"mediatek,mt7986-mmc\", .data = &mt7986_compat},\n\t{ .compatible = \"mediatek,mt8135-mmc\", .data = &mt8135_compat},\n\t{ .compatible = \"mediatek,mt8173-mmc\", .data = &mt8173_compat},\n\t{ .compatible = \"mediatek,mt8183-mmc\", .data = &mt8183_compat},\n\t{ .compatible = \"mediatek,mt8516-mmc\", .data = &mt8516_compat},\n\n\t{}\n};\nMODULE_DEVICE_TABLE(of, msdc_of_ids);\n\nstatic void sdr_set_bits(void __iomem *reg, u32 bs)\n{\n\tu32 val = readl(reg);\n\n\tval |= bs;\n\twritel(val, reg);\n}\n\nstatic void sdr_clr_bits(void __iomem *reg, u32 bs)\n{\n\tu32 val = readl(reg);\n\n\tval &= ~bs;\n\twritel(val, reg);\n}\n\nstatic void sdr_set_field(void __iomem *reg, u32 field, u32 val)\n{\n\tunsigned int tv = readl(reg);\n\n\ttv &= ~field;\n\ttv |= ((val) << (ffs((unsigned int)field) - 1));\n\twritel(tv, reg);\n}\n\nstatic void sdr_get_field(void __iomem *reg, u32 field, u32 *val)\n{\n\tunsigned int tv = readl(reg);\n\n\t*val = ((tv & field) >> (ffs((unsigned int)field) - 1));\n}\n\nstatic void msdc_reset_hw(struct msdc_host *host)\n{\n\tu32 val;\n\n\tsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_RST);\n\treadl_poll_timeout_atomic(host->base + MSDC_CFG, val, !(val & MSDC_CFG_RST), 0, 0);\n\n\tsdr_set_bits(host->base + MSDC_FIFOCS, MSDC_FIFOCS_CLR);\n\treadl_poll_timeout_atomic(host->base + MSDC_FIFOCS, val,\n\t\t\t\t  !(val & MSDC_FIFOCS_CLR), 0, 0);\n\n\tval = readl(host->base + MSDC_INT);\n\twritel(val, host->base + MSDC_INT);\n}\n\nstatic void msdc_cmd_next(struct msdc_host *host,\n\t\tstruct mmc_request *mrq, struct mmc_command *cmd);\nstatic void __msdc_enable_sdio_irq(struct msdc_host *host, int enb);\n\nstatic const u32 cmd_ints_mask = MSDC_INTEN_CMDRDY | MSDC_INTEN_RSPCRCERR |\n\t\t\tMSDC_INTEN_CMDTMO | MSDC_INTEN_ACMDRDY |\n\t\t\tMSDC_INTEN_ACMDCRCERR | MSDC_INTEN_ACMDTMO;\nstatic const u32 data_ints_mask = MSDC_INTEN_XFER_COMPL | MSDC_INTEN_DATTMO |\n\t\t\tMSDC_INTEN_DATCRCERR | MSDC_INTEN_DMA_BDCSERR |\n\t\t\tMSDC_INTEN_DMA_GPDCSERR | MSDC_INTEN_DMA_PROTECT;\n\nstatic u8 msdc_dma_calcs(u8 *buf, u32 len)\n{\n\tu32 i, sum = 0;\n\n\tfor (i = 0; i < len; i++)\n\t\tsum += buf[i];\n\treturn 0xff - (u8) sum;\n}\n\nstatic inline void msdc_dma_setup(struct msdc_host *host, struct msdc_dma *dma,\n\t\tstruct mmc_data *data)\n{\n\tunsigned int j, dma_len;\n\tdma_addr_t dma_address;\n\tu32 dma_ctrl;\n\tstruct scatterlist *sg;\n\tstruct mt_gpdma_desc *gpd;\n\tstruct mt_bdma_desc *bd;\n\n\tsg = data->sg;\n\n\tgpd = dma->gpd;\n\tbd = dma->bd;\n\n\t \n\tgpd->gpd_info |= GPDMA_DESC_HWO;\n\tgpd->gpd_info |= GPDMA_DESC_BDP;\n\t \n\tgpd->gpd_info &= ~GPDMA_DESC_CHECKSUM;\n\tgpd->gpd_info |= msdc_dma_calcs((u8 *) gpd, 16) << 8;\n\n\t \n\tfor_each_sg(data->sg, sg, data->sg_count, j) {\n\t\tdma_address = sg_dma_address(sg);\n\t\tdma_len = sg_dma_len(sg);\n\n\t\t \n\t\tbd[j].bd_info &= ~BDMA_DESC_BLKPAD;\n\t\tbd[j].bd_info &= ~BDMA_DESC_DWPAD;\n\t\tbd[j].ptr = lower_32_bits(dma_address);\n\t\tif (host->dev_comp->support_64g) {\n\t\t\tbd[j].bd_info &= ~BDMA_DESC_PTR_H4;\n\t\t\tbd[j].bd_info |= (upper_32_bits(dma_address) & 0xf)\n\t\t\t\t\t << 28;\n\t\t}\n\n\t\tif (host->dev_comp->support_64g) {\n\t\t\tbd[j].bd_data_len &= ~BDMA_DESC_BUFLEN_EXT;\n\t\t\tbd[j].bd_data_len |= (dma_len & BDMA_DESC_BUFLEN_EXT);\n\t\t} else {\n\t\t\tbd[j].bd_data_len &= ~BDMA_DESC_BUFLEN;\n\t\t\tbd[j].bd_data_len |= (dma_len & BDMA_DESC_BUFLEN);\n\t\t}\n\n\t\tif (j == data->sg_count - 1)  \n\t\t\tbd[j].bd_info |= BDMA_DESC_EOL;\n\t\telse\n\t\t\tbd[j].bd_info &= ~BDMA_DESC_EOL;\n\n\t\t \n\t\tbd[j].bd_info &= ~BDMA_DESC_CHECKSUM;\n\t\tbd[j].bd_info |= msdc_dma_calcs((u8 *)(&bd[j]), 16) << 8;\n\t}\n\n\tsdr_set_field(host->base + MSDC_DMA_CFG, MSDC_DMA_CFG_DECSEN, 1);\n\tdma_ctrl = readl_relaxed(host->base + MSDC_DMA_CTRL);\n\tdma_ctrl &= ~(MSDC_DMA_CTRL_BRUSTSZ | MSDC_DMA_CTRL_MODE);\n\tdma_ctrl |= (MSDC_BURST_64B << 12 | BIT(8));\n\twritel_relaxed(dma_ctrl, host->base + MSDC_DMA_CTRL);\n\tif (host->dev_comp->support_64g)\n\t\tsdr_set_field(host->base + DMA_SA_H4BIT, DMA_ADDR_HIGH_4BIT,\n\t\t\t      upper_32_bits(dma->gpd_addr) & 0xf);\n\twritel(lower_32_bits(dma->gpd_addr), host->base + MSDC_DMA_SA);\n}\n\nstatic void msdc_prepare_data(struct msdc_host *host, struct mmc_data *data)\n{\n\tif (!(data->host_cookie & MSDC_PREPARE_FLAG)) {\n\t\tdata->host_cookie |= MSDC_PREPARE_FLAG;\n\t\tdata->sg_count = dma_map_sg(host->dev, data->sg, data->sg_len,\n\t\t\t\t\t    mmc_get_dma_dir(data));\n\t}\n}\n\nstatic void msdc_unprepare_data(struct msdc_host *host, struct mmc_data *data)\n{\n\tif (data->host_cookie & MSDC_ASYNC_FLAG)\n\t\treturn;\n\n\tif (data->host_cookie & MSDC_PREPARE_FLAG) {\n\t\tdma_unmap_sg(host->dev, data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t\tdata->host_cookie &= ~MSDC_PREPARE_FLAG;\n\t}\n}\n\nstatic u64 msdc_timeout_cal(struct msdc_host *host, u64 ns, u64 clks)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tu64 timeout, clk_ns;\n\tu32 mode = 0;\n\n\tif (mmc->actual_clock == 0) {\n\t\ttimeout = 0;\n\t} else {\n\t\tclk_ns  = 1000000000ULL;\n\t\tdo_div(clk_ns, mmc->actual_clock);\n\t\ttimeout = ns + clk_ns - 1;\n\t\tdo_div(timeout, clk_ns);\n\t\ttimeout += clks;\n\t\t \n\t\ttimeout = DIV_ROUND_UP(timeout, BIT(20));\n\t\tif (host->dev_comp->clk_div_bits == 8)\n\t\t\tsdr_get_field(host->base + MSDC_CFG,\n\t\t\t\t      MSDC_CFG_CKMOD, &mode);\n\t\telse\n\t\t\tsdr_get_field(host->base + MSDC_CFG,\n\t\t\t\t      MSDC_CFG_CKMOD_EXTRA, &mode);\n\t\t \n\t\ttimeout = mode >= 2 ? timeout * 2 : timeout;\n\t\ttimeout = timeout > 1 ? timeout - 1 : 0;\n\t}\n\treturn timeout;\n}\n\n \nstatic void msdc_set_timeout(struct msdc_host *host, u64 ns, u64 clks)\n{\n\tu64 timeout;\n\n\thost->timeout_ns = ns;\n\thost->timeout_clks = clks;\n\n\ttimeout = msdc_timeout_cal(host, ns, clks);\n\tsdr_set_field(host->base + SDC_CFG, SDC_CFG_DTOC,\n\t\t      (u32)(timeout > 255 ? 255 : timeout));\n}\n\nstatic void msdc_set_busy_timeout(struct msdc_host *host, u64 ns, u64 clks)\n{\n\tu64 timeout;\n\n\ttimeout = msdc_timeout_cal(host, ns, clks);\n\tsdr_set_field(host->base + SDC_CFG, SDC_CFG_WRDTOC,\n\t\t      (u32)(timeout > 8191 ? 8191 : timeout));\n}\n\nstatic void msdc_gate_clock(struct msdc_host *host)\n{\n\tclk_bulk_disable_unprepare(MSDC_NR_CLOCKS, host->bulk_clks);\n\tclk_disable_unprepare(host->crypto_clk);\n\tclk_disable_unprepare(host->src_clk_cg);\n\tclk_disable_unprepare(host->src_clk);\n\tclk_disable_unprepare(host->bus_clk);\n\tclk_disable_unprepare(host->h_clk);\n}\n\nstatic int msdc_ungate_clock(struct msdc_host *host)\n{\n\tu32 val;\n\tint ret;\n\n\tclk_prepare_enable(host->h_clk);\n\tclk_prepare_enable(host->bus_clk);\n\tclk_prepare_enable(host->src_clk);\n\tclk_prepare_enable(host->src_clk_cg);\n\tclk_prepare_enable(host->crypto_clk);\n\tret = clk_bulk_prepare_enable(MSDC_NR_CLOCKS, host->bulk_clks);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Cannot enable pclk/axi/ahb clock gates\\n\");\n\t\treturn ret;\n\t}\n\n\treturn readl_poll_timeout(host->base + MSDC_CFG, val,\n\t\t\t\t  (val & MSDC_CFG_CKSTB), 1, 20000);\n}\n\nstatic void msdc_set_mclk(struct msdc_host *host, unsigned char timing, u32 hz)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tu32 mode;\n\tu32 flags;\n\tu32 div;\n\tu32 sclk;\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\tu32 val;\n\n\tif (!hz) {\n\t\tdev_dbg(host->dev, \"set mclk to 0\\n\");\n\t\thost->mclk = 0;\n\t\tmmc->actual_clock = 0;\n\t\tsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_CKPDN);\n\t\treturn;\n\t}\n\n\tflags = readl(host->base + MSDC_INTEN);\n\tsdr_clr_bits(host->base + MSDC_INTEN, flags);\n\tif (host->dev_comp->clk_div_bits == 8)\n\t\tsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_HS400_CK_MODE);\n\telse\n\t\tsdr_clr_bits(host->base + MSDC_CFG,\n\t\t\t     MSDC_CFG_HS400_CK_MODE_EXTRA);\n\tif (timing == MMC_TIMING_UHS_DDR50 ||\n\t    timing == MMC_TIMING_MMC_DDR52 ||\n\t    timing == MMC_TIMING_MMC_HS400) {\n\t\tif (timing == MMC_TIMING_MMC_HS400)\n\t\t\tmode = 0x3;\n\t\telse\n\t\t\tmode = 0x2;  \n\n\t\tif (hz >= (host->src_clk_freq >> 2)) {\n\t\t\tdiv = 0;  \n\t\t\tsclk = host->src_clk_freq >> 2;  \n\t\t} else {\n\t\t\tdiv = (host->src_clk_freq + ((hz << 2) - 1)) / (hz << 2);\n\t\t\tsclk = (host->src_clk_freq >> 2) / div;\n\t\t\tdiv = (div >> 1);\n\t\t}\n\n\t\tif (timing == MMC_TIMING_MMC_HS400 &&\n\t\t    hz >= (host->src_clk_freq >> 1)) {\n\t\t\tif (host->dev_comp->clk_div_bits == 8)\n\t\t\t\tsdr_set_bits(host->base + MSDC_CFG,\n\t\t\t\t\t     MSDC_CFG_HS400_CK_MODE);\n\t\t\telse\n\t\t\t\tsdr_set_bits(host->base + MSDC_CFG,\n\t\t\t\t\t     MSDC_CFG_HS400_CK_MODE_EXTRA);\n\t\t\tsclk = host->src_clk_freq >> 1;\n\t\t\tdiv = 0;  \n\t\t}\n\t} else if (hz >= host->src_clk_freq) {\n\t\tmode = 0x1;  \n\t\tdiv = 0;\n\t\tsclk = host->src_clk_freq;\n\t} else {\n\t\tmode = 0x0;  \n\t\tif (hz >= (host->src_clk_freq >> 1)) {\n\t\t\tdiv = 0;  \n\t\t\tsclk = host->src_clk_freq >> 1;  \n\t\t} else {\n\t\t\tdiv = (host->src_clk_freq + ((hz << 2) - 1)) / (hz << 2);\n\t\t\tsclk = (host->src_clk_freq >> 2) / div;\n\t\t}\n\t}\n\tsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_CKPDN);\n\n\tclk_disable_unprepare(host->src_clk_cg);\n\tif (host->dev_comp->clk_div_bits == 8)\n\t\tsdr_set_field(host->base + MSDC_CFG,\n\t\t\t      MSDC_CFG_CKMOD | MSDC_CFG_CKDIV,\n\t\t\t      (mode << 8) | div);\n\telse\n\t\tsdr_set_field(host->base + MSDC_CFG,\n\t\t\t      MSDC_CFG_CKMOD_EXTRA | MSDC_CFG_CKDIV_EXTRA,\n\t\t\t      (mode << 12) | div);\n\n\tclk_prepare_enable(host->src_clk_cg);\n\treadl_poll_timeout(host->base + MSDC_CFG, val, (val & MSDC_CFG_CKSTB), 0, 0);\n\tsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_CKPDN);\n\tmmc->actual_clock = sclk;\n\thost->mclk = hz;\n\thost->timing = timing;\n\t \n\tmsdc_set_timeout(host, host->timeout_ns, host->timeout_clks);\n\tsdr_set_bits(host->base + MSDC_INTEN, flags);\n\n\t \n\tif (mmc->actual_clock <= 52000000) {\n\t\twritel(host->def_tune_para.iocon, host->base + MSDC_IOCON);\n\t\tif (host->top_base) {\n\t\t\twritel(host->def_tune_para.emmc_top_control,\n\t\t\t       host->top_base + EMMC_TOP_CONTROL);\n\t\t\twritel(host->def_tune_para.emmc_top_cmd,\n\t\t\t       host->top_base + EMMC_TOP_CMD);\n\t\t} else {\n\t\t\twritel(host->def_tune_para.pad_tune,\n\t\t\t       host->base + tune_reg);\n\t\t}\n\t} else {\n\t\twritel(host->saved_tune_para.iocon, host->base + MSDC_IOCON);\n\t\twritel(host->saved_tune_para.pad_cmd_tune,\n\t\t       host->base + PAD_CMD_TUNE);\n\t\tif (host->top_base) {\n\t\t\twritel(host->saved_tune_para.emmc_top_control,\n\t\t\t       host->top_base + EMMC_TOP_CONTROL);\n\t\t\twritel(host->saved_tune_para.emmc_top_cmd,\n\t\t\t       host->top_base + EMMC_TOP_CMD);\n\t\t} else {\n\t\t\twritel(host->saved_tune_para.pad_tune,\n\t\t\t       host->base + tune_reg);\n\t\t}\n\t}\n\n\tif (timing == MMC_TIMING_MMC_HS400 &&\n\t    host->dev_comp->hs400_tune)\n\t\tsdr_set_field(host->base + tune_reg,\n\t\t\t      MSDC_PAD_TUNE_CMDRRDLY,\n\t\t\t      host->hs400_cmd_int_delay);\n\tdev_dbg(host->dev, \"sclk: %d, timing: %d\\n\", mmc->actual_clock,\n\t\ttiming);\n}\n\nstatic inline u32 msdc_cmd_find_resp(struct msdc_host *host,\n\t\tstruct mmc_command *cmd)\n{\n\tu32 resp;\n\n\tswitch (mmc_resp_type(cmd)) {\n\t\t \n\tcase MMC_RSP_R1:\n\t\tresp = 0x1;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tresp = 0x7;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tresp = 0x2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tresp = 0x3;\n\t\tbreak;\n\tcase MMC_RSP_NONE:\n\tdefault:\n\t\tresp = 0x0;\n\t\tbreak;\n\t}\n\n\treturn resp;\n}\n\nstatic inline u32 msdc_cmd_prepare_raw_cmd(struct msdc_host *host,\n\t\tstruct mmc_request *mrq, struct mmc_command *cmd)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\t \n\tu32 opcode = cmd->opcode;\n\tu32 resp = msdc_cmd_find_resp(host, cmd);\n\tu32 rawcmd = (opcode & 0x3f) | ((resp & 0x7) << 7);\n\n\thost->cmd_rsp = resp;\n\n\tif ((opcode == SD_IO_RW_DIRECT && cmd->flags == (unsigned int) -1) ||\n\t    opcode == MMC_STOP_TRANSMISSION)\n\t\trawcmd |= BIT(14);\n\telse if (opcode == SD_SWITCH_VOLTAGE)\n\t\trawcmd |= BIT(30);\n\telse if (opcode == SD_APP_SEND_SCR ||\n\t\t opcode == SD_APP_SEND_NUM_WR_BLKS ||\n\t\t (opcode == SD_SWITCH && mmc_cmd_type(cmd) == MMC_CMD_ADTC) ||\n\t\t (opcode == SD_APP_SD_STATUS && mmc_cmd_type(cmd) == MMC_CMD_ADTC) ||\n\t\t (opcode == MMC_SEND_EXT_CSD && mmc_cmd_type(cmd) == MMC_CMD_ADTC))\n\t\trawcmd |= BIT(11);\n\n\tif (cmd->data) {\n\t\tstruct mmc_data *data = cmd->data;\n\n\t\tif (mmc_op_multi(opcode)) {\n\t\t\tif (mmc_card_mmc(mmc->card) && mrq->sbc &&\n\t\t\t    !(mrq->sbc->arg & 0xFFFF0000))\n\t\t\t\trawcmd |= BIT(29);  \n\t\t}\n\n\t\trawcmd |= ((data->blksz & 0xFFF) << 16);\n\t\tif (data->flags & MMC_DATA_WRITE)\n\t\t\trawcmd |= BIT(13);\n\t\tif (data->blocks > 1)\n\t\t\trawcmd |= BIT(12);\n\t\telse\n\t\t\trawcmd |= BIT(11);\n\t\t \n\t\tsdr_clr_bits(host->base + MSDC_CFG, MSDC_CFG_PIO);\n\n\t\tif (host->timeout_ns != data->timeout_ns ||\n\t\t    host->timeout_clks != data->timeout_clks)\n\t\t\tmsdc_set_timeout(host, data->timeout_ns,\n\t\t\t\t\tdata->timeout_clks);\n\n\t\twritel(data->blocks, host->base + SDC_BLK_NUM);\n\t}\n\treturn rawcmd;\n}\n\nstatic void msdc_start_data(struct msdc_host *host, struct mmc_command *cmd,\n\t\tstruct mmc_data *data)\n{\n\tbool read;\n\n\tWARN_ON(host->data);\n\thost->data = data;\n\tread = data->flags & MMC_DATA_READ;\n\n\tmod_delayed_work(system_wq, &host->req_timeout, DAT_TIMEOUT);\n\tmsdc_dma_setup(host, &host->dma, data);\n\tsdr_set_bits(host->base + MSDC_INTEN, data_ints_mask);\n\tsdr_set_field(host->base + MSDC_DMA_CTRL, MSDC_DMA_CTRL_START, 1);\n\tdev_dbg(host->dev, \"DMA start\\n\");\n\tdev_dbg(host->dev, \"%s: cmd=%d DMA data: %d blocks; read=%d\\n\",\n\t\t\t__func__, cmd->opcode, data->blocks, read);\n}\n\nstatic int msdc_auto_cmd_done(struct msdc_host *host, int events,\n\t\tstruct mmc_command *cmd)\n{\n\tu32 *rsp = cmd->resp;\n\n\trsp[0] = readl(host->base + SDC_ACMD_RESP);\n\n\tif (events & MSDC_INT_ACMDRDY) {\n\t\tcmd->error = 0;\n\t} else {\n\t\tmsdc_reset_hw(host);\n\t\tif (events & MSDC_INT_ACMDCRCERR) {\n\t\t\tcmd->error = -EILSEQ;\n\t\t\thost->error |= REQ_STOP_EIO;\n\t\t} else if (events & MSDC_INT_ACMDTMO) {\n\t\t\tcmd->error = -ETIMEDOUT;\n\t\t\thost->error |= REQ_STOP_TMO;\n\t\t}\n\t\tdev_err(host->dev,\n\t\t\t\"%s: AUTO_CMD%d arg=%08X; rsp %08X; cmd_error=%d\\n\",\n\t\t\t__func__, cmd->opcode, cmd->arg, rsp[0], cmd->error);\n\t}\n\treturn cmd->error;\n}\n\n \nstatic void msdc_recheck_sdio_irq(struct msdc_host *host)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tu32 reg_int, reg_inten, reg_ps;\n\n\tif (mmc->caps & MMC_CAP_SDIO_IRQ) {\n\t\treg_inten = readl(host->base + MSDC_INTEN);\n\t\tif (reg_inten & MSDC_INTEN_SDIOIRQ) {\n\t\t\treg_int = readl(host->base + MSDC_INT);\n\t\t\treg_ps = readl(host->base + MSDC_PS);\n\t\t\tif (!(reg_int & MSDC_INT_SDIOIRQ ||\n\t\t\t      reg_ps & MSDC_PS_DATA1)) {\n\t\t\t\t__msdc_enable_sdio_irq(host, 0);\n\t\t\t\tsdio_signal_irq(mmc);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void msdc_track_cmd_data(struct msdc_host *host, struct mmc_command *cmd)\n{\n\tif (host->error)\n\t\tdev_dbg(host->dev, \"%s: cmd=%d arg=%08X; host->error=0x%08X\\n\",\n\t\t\t__func__, cmd->opcode, cmd->arg, host->error);\n}\n\nstatic void msdc_request_done(struct msdc_host *host, struct mmc_request *mrq)\n{\n\tunsigned long flags;\n\n\t \n\tcancel_delayed_work(&host->req_timeout);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\thost->mrq = NULL;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tmsdc_track_cmd_data(host, mrq->cmd);\n\tif (mrq->data)\n\t\tmsdc_unprepare_data(host, mrq->data);\n\tif (host->error)\n\t\tmsdc_reset_hw(host);\n\tmmc_request_done(mmc_from_priv(host), mrq);\n\tif (host->dev_comp->recheck_sdio_irq)\n\t\tmsdc_recheck_sdio_irq(host);\n}\n\n \nstatic bool msdc_cmd_done(struct msdc_host *host, int events,\n\t\t\t  struct mmc_request *mrq, struct mmc_command *cmd)\n{\n\tbool done = false;\n\tbool sbc_error;\n\tunsigned long flags;\n\tu32 *rsp;\n\n\tif (mrq->sbc && cmd == mrq->cmd &&\n\t    (events & (MSDC_INT_ACMDRDY | MSDC_INT_ACMDCRCERR\n\t\t\t\t   | MSDC_INT_ACMDTMO)))\n\t\tmsdc_auto_cmd_done(host, events, mrq->sbc);\n\n\tsbc_error = mrq->sbc && mrq->sbc->error;\n\n\tif (!sbc_error && !(events & (MSDC_INT_CMDRDY\n\t\t\t\t\t| MSDC_INT_RSPCRCERR\n\t\t\t\t\t| MSDC_INT_CMDTMO)))\n\t\treturn done;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tdone = !host->cmd;\n\thost->cmd = NULL;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (done)\n\t\treturn true;\n\trsp = cmd->resp;\n\n\tsdr_clr_bits(host->base + MSDC_INTEN, cmd_ints_mask);\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\trsp[0] = readl(host->base + SDC_RESP3);\n\t\t\trsp[1] = readl(host->base + SDC_RESP2);\n\t\t\trsp[2] = readl(host->base + SDC_RESP1);\n\t\t\trsp[3] = readl(host->base + SDC_RESP0);\n\t\t} else {\n\t\t\trsp[0] = readl(host->base + SDC_RESP0);\n\t\t}\n\t}\n\n\tif (!sbc_error && !(events & MSDC_INT_CMDRDY)) {\n\t\tif (events & MSDC_INT_CMDTMO ||\n\t\t    (!mmc_op_tuning(cmd->opcode) && !host->hs400_tuning))\n\t\t\t \n\t\t\tmsdc_reset_hw(host);\n\t\tif (events & MSDC_INT_RSPCRCERR) {\n\t\t\tcmd->error = -EILSEQ;\n\t\t\thost->error |= REQ_CMD_EIO;\n\t\t} else if (events & MSDC_INT_CMDTMO) {\n\t\t\tcmd->error = -ETIMEDOUT;\n\t\t\thost->error |= REQ_CMD_TMO;\n\t\t}\n\t}\n\tif (cmd->error)\n\t\tdev_dbg(host->dev,\n\t\t\t\t\"%s: cmd=%d arg=%08X; rsp %08X; cmd_error=%d\\n\",\n\t\t\t\t__func__, cmd->opcode, cmd->arg, rsp[0],\n\t\t\t\tcmd->error);\n\n\tmsdc_cmd_next(host, mrq, cmd);\n\treturn true;\n}\n\n \nstatic inline bool msdc_cmd_is_ready(struct msdc_host *host,\n\t\tstruct mmc_request *mrq, struct mmc_command *cmd)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tret = readl_poll_timeout_atomic(host->base + SDC_STS, val,\n\t\t\t\t\t!(val & SDC_STS_CMDBUSY), 1, 20000);\n\tif (ret) {\n\t\tdev_err(host->dev, \"CMD bus busy detected\\n\");\n\t\thost->error |= REQ_CMD_BUSY;\n\t\tmsdc_cmd_done(host, MSDC_INT_CMDTMO, mrq, cmd);\n\t\treturn false;\n\t}\n\n\tif (mmc_resp_type(cmd) == MMC_RSP_R1B || cmd->data) {\n\t\t \n\t\tret = readl_poll_timeout_atomic(host->base + SDC_STS, val,\n\t\t\t\t\t\t!(val & SDC_STS_SDCBUSY), 1, 20000);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, \"Controller busy detected\\n\");\n\t\t\thost->error |= REQ_CMD_BUSY;\n\t\t\tmsdc_cmd_done(host, MSDC_INT_CMDTMO, mrq, cmd);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void msdc_start_command(struct msdc_host *host,\n\t\tstruct mmc_request *mrq, struct mmc_command *cmd)\n{\n\tu32 rawcmd;\n\tunsigned long flags;\n\n\tWARN_ON(host->cmd);\n\thost->cmd = cmd;\n\n\tmod_delayed_work(system_wq, &host->req_timeout, DAT_TIMEOUT);\n\tif (!msdc_cmd_is_ready(host, mrq, cmd))\n\t\treturn;\n\n\tif ((readl(host->base + MSDC_FIFOCS) & MSDC_FIFOCS_TXCNT) >> 16 ||\n\t    readl(host->base + MSDC_FIFOCS) & MSDC_FIFOCS_RXCNT) {\n\t\tdev_err(host->dev, \"TX/RX FIFO non-empty before start of IO. Reset\\n\");\n\t\tmsdc_reset_hw(host);\n\t}\n\n\tcmd->error = 0;\n\trawcmd = msdc_cmd_prepare_raw_cmd(host, mrq, cmd);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tsdr_set_bits(host->base + MSDC_INTEN, cmd_ints_mask);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\twritel(cmd->arg, host->base + SDC_ARG);\n\twritel(rawcmd, host->base + SDC_CMD);\n}\n\nstatic void msdc_cmd_next(struct msdc_host *host,\n\t\tstruct mmc_request *mrq, struct mmc_command *cmd)\n{\n\tif ((cmd->error &&\n\t    !(cmd->error == -EILSEQ &&\n\t      (mmc_op_tuning(cmd->opcode) || host->hs400_tuning))) ||\n\t    (mrq->sbc && mrq->sbc->error))\n\t\tmsdc_request_done(host, mrq);\n\telse if (cmd == mrq->sbc)\n\t\tmsdc_start_command(host, mrq, mrq->cmd);\n\telse if (!cmd->data)\n\t\tmsdc_request_done(host, mrq);\n\telse\n\t\tmsdc_start_data(host, cmd, cmd->data);\n}\n\nstatic void msdc_ops_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\thost->error = 0;\n\tWARN_ON(host->mrq);\n\thost->mrq = mrq;\n\n\tif (mrq->data)\n\t\tmsdc_prepare_data(host, mrq->data);\n\n\t \n\tif (mrq->sbc && (!mmc_card_mmc(mmc->card) ||\n\t    (mrq->sbc->arg & 0xFFFF0000)))\n\t\tmsdc_start_command(host, mrq, mrq->sbc);\n\telse\n\t\tmsdc_start_command(host, mrq, mrq->cmd);\n}\n\nstatic void msdc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tmsdc_prepare_data(host, data);\n\tdata->host_cookie |= MSDC_ASYNC_FLAG;\n}\n\nstatic void msdc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\tint err)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tif (data->host_cookie) {\n\t\tdata->host_cookie &= ~MSDC_ASYNC_FLAG;\n\t\tmsdc_unprepare_data(host, data);\n\t}\n}\n\nstatic void msdc_data_xfer_next(struct msdc_host *host, struct mmc_request *mrq)\n{\n\tif (mmc_op_multi(mrq->cmd->opcode) && mrq->stop && !mrq->stop->error &&\n\t    !mrq->sbc)\n\t\tmsdc_start_command(host, mrq, mrq->stop);\n\telse\n\t\tmsdc_request_done(host, mrq);\n}\n\nstatic void msdc_data_xfer_done(struct msdc_host *host, u32 events,\n\t\t\t\tstruct mmc_request *mrq, struct mmc_data *data)\n{\n\tstruct mmc_command *stop;\n\tunsigned long flags;\n\tbool done;\n\tunsigned int check_data = events &\n\t    (MSDC_INT_XFER_COMPL | MSDC_INT_DATCRCERR | MSDC_INT_DATTMO\n\t     | MSDC_INT_DMA_BDCSERR | MSDC_INT_DMA_GPDCSERR\n\t     | MSDC_INT_DMA_PROTECT);\n\tu32 val;\n\tint ret;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tdone = !host->data;\n\tif (check_data)\n\t\thost->data = NULL;\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (done)\n\t\treturn;\n\tstop = data->stop;\n\n\tif (check_data || (stop && stop->error)) {\n\t\tdev_dbg(host->dev, \"DMA status: 0x%8X\\n\",\n\t\t\t\treadl(host->base + MSDC_DMA_CFG));\n\t\tsdr_set_field(host->base + MSDC_DMA_CTRL, MSDC_DMA_CTRL_STOP,\n\t\t\t\t1);\n\n\t\tret = readl_poll_timeout_atomic(host->base + MSDC_DMA_CTRL, val,\n\t\t\t\t\t\t!(val & MSDC_DMA_CTRL_STOP), 1, 20000);\n\t\tif (ret)\n\t\t\tdev_dbg(host->dev, \"DMA stop timed out\\n\");\n\n\t\tret = readl_poll_timeout_atomic(host->base + MSDC_DMA_CFG, val,\n\t\t\t\t\t\t!(val & MSDC_DMA_CFG_STS), 1, 20000);\n\t\tif (ret)\n\t\t\tdev_dbg(host->dev, \"DMA inactive timed out\\n\");\n\n\t\tsdr_clr_bits(host->base + MSDC_INTEN, data_ints_mask);\n\t\tdev_dbg(host->dev, \"DMA stop\\n\");\n\n\t\tif ((events & MSDC_INT_XFER_COMPL) && (!stop || !stop->error)) {\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t} else {\n\t\t\tdev_dbg(host->dev, \"interrupt events: %x\\n\", events);\n\t\t\tmsdc_reset_hw(host);\n\t\t\thost->error |= REQ_DAT_ERR;\n\t\t\tdata->bytes_xfered = 0;\n\n\t\t\tif (events & MSDC_INT_DATTMO)\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\telse if (events & MSDC_INT_DATCRCERR)\n\t\t\t\tdata->error = -EILSEQ;\n\n\t\t\tdev_dbg(host->dev, \"%s: cmd=%d; blocks=%d\",\n\t\t\t\t__func__, mrq->cmd->opcode, data->blocks);\n\t\t\tdev_dbg(host->dev, \"data_error=%d xfer_size=%d\\n\",\n\t\t\t\t(int)data->error, data->bytes_xfered);\n\t\t}\n\n\t\tmsdc_data_xfer_next(host, mrq);\n\t}\n}\n\nstatic void msdc_set_buswidth(struct msdc_host *host, u32 width)\n{\n\tu32 val = readl(host->base + SDC_CFG);\n\n\tval &= ~SDC_CFG_BUSWIDTH;\n\n\tswitch (width) {\n\tdefault:\n\tcase MMC_BUS_WIDTH_1:\n\t\tval |= (MSDC_BUS_1BITS << 16);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tval |= (MSDC_BUS_4BITS << 16);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tval |= (MSDC_BUS_8BITS << 16);\n\t\tbreak;\n\t}\n\n\twritel(val, host->base + SDC_CFG);\n\tdev_dbg(host->dev, \"Bus Width = %d\", width);\n}\n\nstatic int msdc_ops_switch_volt(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tif (ios->signal_voltage != MMC_SIGNAL_VOLTAGE_330 &&\n\t\t    ios->signal_voltage != MMC_SIGNAL_VOLTAGE_180) {\n\t\t\tdev_err(host->dev, \"Unsupported signal voltage!\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(host->dev, \"Regulator set error %d (%d)\\n\",\n\t\t\t\tret, ios->signal_voltage);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)\n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_uhs);\n\t\telse\n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_default);\n\t}\n\treturn 0;\n}\n\nstatic int msdc_card_busy(struct mmc_host *mmc)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 status = readl(host->base + MSDC_PS);\n\n\t \n\treturn !(status & BIT(16));\n}\n\nstatic void msdc_request_timeout(struct work_struct *work)\n{\n\tstruct msdc_host *host = container_of(work, struct msdc_host,\n\t\t\treq_timeout.work);\n\n\t \n\tdev_err(host->dev, \"%s: aborting cmd/data/mrq\\n\", __func__);\n\tif (host->mrq) {\n\t\tdev_err(host->dev, \"%s: aborting mrq=%p cmd=%d\\n\", __func__,\n\t\t\t\thost->mrq, host->mrq->cmd->opcode);\n\t\tif (host->cmd) {\n\t\t\tdev_err(host->dev, \"%s: aborting cmd=%d\\n\",\n\t\t\t\t\t__func__, host->cmd->opcode);\n\t\t\tmsdc_cmd_done(host, MSDC_INT_CMDTMO, host->mrq,\n\t\t\t\t\thost->cmd);\n\t\t} else if (host->data) {\n\t\t\tdev_err(host->dev, \"%s: abort data: cmd%d; %d blocks\\n\",\n\t\t\t\t\t__func__, host->mrq->cmd->opcode,\n\t\t\t\t\thost->data->blocks);\n\t\t\tmsdc_data_xfer_done(host, MSDC_INT_DATTMO, host->mrq,\n\t\t\t\t\thost->data);\n\t\t}\n\t}\n}\n\nstatic void __msdc_enable_sdio_irq(struct msdc_host *host, int enb)\n{\n\tif (enb) {\n\t\tsdr_set_bits(host->base + MSDC_INTEN, MSDC_INTEN_SDIOIRQ);\n\t\tsdr_set_bits(host->base + SDC_CFG, SDC_CFG_SDIOIDE);\n\t\tif (host->dev_comp->recheck_sdio_irq)\n\t\t\tmsdc_recheck_sdio_irq(host);\n\t} else {\n\t\tsdr_clr_bits(host->base + MSDC_INTEN, MSDC_INTEN_SDIOIRQ);\n\t\tsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_SDIOIDE);\n\t}\n}\n\nstatic void msdc_enable_sdio_irq(struct mmc_host *mmc, int enb)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\t__msdc_enable_sdio_irq(host, enb);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (mmc_card_enable_async_irq(mmc->card) && host->pins_eint) {\n\t\tif (enb) {\n\t\t\t \n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_eint);\n\t\t\tret = dev_pm_set_dedicated_wake_irq_reverse(host->dev, host->eint_irq);\n\n\t\t\tif (ret) {\n\t\t\t\tdev_err(host->dev, \"Failed to register SDIO wakeup irq!\\n\");\n\t\t\t\thost->pins_eint = NULL;\n\t\t\t\tpm_runtime_get_noresume(host->dev);\n\t\t\t} else {\n\t\t\t\tdev_dbg(host->dev, \"SDIO eint irq: %d!\\n\", host->eint_irq);\n\t\t\t}\n\n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_uhs);\n\t\t} else {\n\t\t\tdev_pm_clear_wake_irq(host->dev);\n\t\t}\n\t} else {\n\t\tif (enb) {\n\t\t\t \n\t\t\thost->pins_eint = NULL;\n\t\t\tpm_runtime_get_noresume(host->dev);\n\t\t} else {\n\t\t\tpm_runtime_put_noidle(host->dev);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t msdc_cmdq_irq(struct msdc_host *host, u32 intsts)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tint cmd_err = 0, dat_err = 0;\n\n\tif (intsts & MSDC_INT_RSPCRCERR) {\n\t\tcmd_err = -EILSEQ;\n\t\tdev_err(host->dev, \"%s: CMD CRC ERR\", __func__);\n\t} else if (intsts & MSDC_INT_CMDTMO) {\n\t\tcmd_err = -ETIMEDOUT;\n\t\tdev_err(host->dev, \"%s: CMD TIMEOUT ERR\", __func__);\n\t}\n\n\tif (intsts & MSDC_INT_DATCRCERR) {\n\t\tdat_err = -EILSEQ;\n\t\tdev_err(host->dev, \"%s: DATA CRC ERR\", __func__);\n\t} else if (intsts & MSDC_INT_DATTMO) {\n\t\tdat_err = -ETIMEDOUT;\n\t\tdev_err(host->dev, \"%s: DATA TIMEOUT ERR\", __func__);\n\t}\n\n\tif (cmd_err || dat_err) {\n\t\tdev_err(host->dev, \"cmd_err = %d, dat_err =%d, intsts = 0x%x\",\n\t\t\tcmd_err, dat_err, intsts);\n\t}\n\n\treturn cqhci_irq(mmc, 0, cmd_err, dat_err);\n}\n\nstatic irqreturn_t msdc_irq(int irq, void *dev_id)\n{\n\tstruct msdc_host *host = (struct msdc_host *) dev_id;\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\n\twhile (true) {\n\t\tstruct mmc_request *mrq;\n\t\tstruct mmc_command *cmd;\n\t\tstruct mmc_data *data;\n\t\tu32 events, event_mask;\n\n\t\tspin_lock(&host->lock);\n\t\tevents = readl(host->base + MSDC_INT);\n\t\tevent_mask = readl(host->base + MSDC_INTEN);\n\t\tif ((events & event_mask) & MSDC_INT_SDIOIRQ)\n\t\t\t__msdc_enable_sdio_irq(host, 0);\n\t\t \n\t\twritel(events & event_mask, host->base + MSDC_INT);\n\n\t\tmrq = host->mrq;\n\t\tcmd = host->cmd;\n\t\tdata = host->data;\n\t\tspin_unlock(&host->lock);\n\n\t\tif ((events & event_mask) & MSDC_INT_SDIOIRQ)\n\t\t\tsdio_signal_irq(mmc);\n\n\t\tif ((events & event_mask) & MSDC_INT_CDSC) {\n\t\t\tif (host->internal_cd)\n\t\t\t\tmmc_detect_change(mmc, msecs_to_jiffies(20));\n\t\t\tevents &= ~MSDC_INT_CDSC;\n\t\t}\n\n\t\tif (!(events & (event_mask & ~MSDC_INT_SDIOIRQ)))\n\t\t\tbreak;\n\n\t\tif ((mmc->caps2 & MMC_CAP2_CQE) &&\n\t\t    (events & MSDC_INT_CMDQ)) {\n\t\t\tmsdc_cmdq_irq(host, events);\n\t\t\t \n\t\t\twritel(events, host->base + MSDC_INT);\n\t\t\treturn IRQ_HANDLED;\n\t\t}\n\n\t\tif (!mrq) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"%s: MRQ=NULL; events=%08X; event_mask=%08X\\n\",\n\t\t\t\t__func__, events, event_mask);\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tdev_dbg(host->dev, \"%s: events=%08X\\n\", __func__, events);\n\n\t\tif (cmd)\n\t\t\tmsdc_cmd_done(host, events, mrq, cmd);\n\t\telse if (data)\n\t\t\tmsdc_data_xfer_done(host, events, mrq, data);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void msdc_init_hw(struct msdc_host *host)\n{\n\tu32 val;\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\n\tif (host->reset) {\n\t\treset_control_assert(host->reset);\n\t\tusleep_range(10, 50);\n\t\treset_control_deassert(host->reset);\n\t}\n\n\t \n\tsdr_set_bits(host->base + MSDC_CFG, MSDC_CFG_MODE | MSDC_CFG_CKPDN);\n\n\t \n\tmsdc_reset_hw(host);\n\n\t \n\twritel(0, host->base + MSDC_INTEN);\n\tval = readl(host->base + MSDC_INT);\n\twritel(val, host->base + MSDC_INT);\n\n\t \n\tif (host->internal_cd) {\n\t\tsdr_set_field(host->base + MSDC_PS, MSDC_PS_CDDEBOUNCE,\n\t\t\t      DEFAULT_DEBOUNCE);\n\t\tsdr_set_bits(host->base + MSDC_PS, MSDC_PS_CDEN);\n\t\tsdr_set_bits(host->base + MSDC_INTEN, MSDC_INTEN_CDSC);\n\t\tsdr_set_bits(host->base + SDC_CFG, SDC_CFG_INSWKUP);\n\t} else {\n\t\tsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_INSWKUP);\n\t\tsdr_clr_bits(host->base + MSDC_PS, MSDC_PS_CDEN);\n\t\tsdr_clr_bits(host->base + MSDC_INTEN, MSDC_INTEN_CDSC);\n\t}\n\n\tif (host->top_base) {\n\t\twritel(0, host->top_base + EMMC_TOP_CONTROL);\n\t\twritel(0, host->top_base + EMMC_TOP_CMD);\n\t} else {\n\t\twritel(0, host->base + tune_reg);\n\t}\n\twritel(0, host->base + MSDC_IOCON);\n\tsdr_set_field(host->base + MSDC_IOCON, MSDC_IOCON_DDLSEL, 0);\n\twritel(0x403c0046, host->base + MSDC_PATCH_BIT);\n\tsdr_set_field(host->base + MSDC_PATCH_BIT, MSDC_CKGEN_MSDC_DLY_SEL, 1);\n\twritel(0xffff4089, host->base + MSDC_PATCH_BIT1);\n\tsdr_set_bits(host->base + EMMC50_CFG0, EMMC50_CFG_CFCSTS_SEL);\n\n\tif (host->dev_comp->stop_clk_fix) {\n\t\tsdr_set_field(host->base + MSDC_PATCH_BIT1,\n\t\t\t      MSDC_PATCH_BIT1_STOP_DLY, 3);\n\t\tsdr_clr_bits(host->base + SDC_FIFO_CFG,\n\t\t\t     SDC_FIFO_CFG_WRVALIDSEL);\n\t\tsdr_clr_bits(host->base + SDC_FIFO_CFG,\n\t\t\t     SDC_FIFO_CFG_RDVALIDSEL);\n\t}\n\n\tif (host->dev_comp->busy_check)\n\t\tsdr_clr_bits(host->base + MSDC_PATCH_BIT1, BIT(7));\n\n\tif (host->dev_comp->async_fifo) {\n\t\tsdr_set_field(host->base + MSDC_PATCH_BIT2,\n\t\t\t      MSDC_PB2_RESPWAIT, 3);\n\t\tif (host->dev_comp->enhance_rx) {\n\t\t\tif (host->top_base)\n\t\t\t\tsdr_set_bits(host->top_base + EMMC_TOP_CONTROL,\n\t\t\t\t\t     SDC_RX_ENH_EN);\n\t\t\telse\n\t\t\t\tsdr_set_bits(host->base + SDC_ADV_CFG0,\n\t\t\t\t\t     SDC_RX_ENHANCE_EN);\n\t\t} else {\n\t\t\tsdr_set_field(host->base + MSDC_PATCH_BIT2,\n\t\t\t\t      MSDC_PB2_RESPSTSENSEL, 2);\n\t\t\tsdr_set_field(host->base + MSDC_PATCH_BIT2,\n\t\t\t\t      MSDC_PB2_CRCSTSENSEL, 2);\n\t\t}\n\t\t \n\t\tsdr_clr_bits(host->base + MSDC_PATCH_BIT2,\n\t\t\t     MSDC_PATCH_BIT2_CFGRESP);\n\t\tsdr_set_bits(host->base + MSDC_PATCH_BIT2,\n\t\t\t     MSDC_PATCH_BIT2_CFGCRCSTS);\n\t}\n\n\tif (host->dev_comp->support_64g)\n\t\tsdr_set_bits(host->base + MSDC_PATCH_BIT2,\n\t\t\t     MSDC_PB2_SUPPORT_64G);\n\tif (host->dev_comp->data_tune) {\n\t\tif (host->top_base) {\n\t\t\tsdr_set_bits(host->top_base + EMMC_TOP_CONTROL,\n\t\t\t\t     PAD_DAT_RD_RXDLY_SEL);\n\t\t\tsdr_clr_bits(host->top_base + EMMC_TOP_CONTROL,\n\t\t\t\t     DATA_K_VALUE_SEL);\n\t\t\tsdr_set_bits(host->top_base + EMMC_TOP_CMD,\n\t\t\t\t     PAD_CMD_RD_RXDLY_SEL);\n\t\t} else {\n\t\t\tsdr_set_bits(host->base + tune_reg,\n\t\t\t\t     MSDC_PAD_TUNE_RD_SEL |\n\t\t\t\t     MSDC_PAD_TUNE_CMD_SEL);\n\t\t}\n\t} else {\n\t\t \n\t\tif (host->top_base)\n\t\t\tsdr_set_bits(host->top_base + EMMC_TOP_CONTROL,\n\t\t\t\t     PAD_RXDLY_SEL);\n\t\telse\n\t\t\tsdr_set_bits(host->base + tune_reg,\n\t\t\t\t     MSDC_PAD_TUNE_RXDLYSEL);\n\t}\n\n\tif (mmc->caps2 & MMC_CAP2_NO_SDIO) {\n\t\tsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_SDIO);\n\t\tsdr_clr_bits(host->base + MSDC_INTEN, MSDC_INTEN_SDIOIRQ);\n\t\tsdr_clr_bits(host->base + SDC_ADV_CFG0, SDC_DAT1_IRQ_TRIGGER);\n\t} else {\n\t\t \n\t\tsdr_set_bits(host->base + SDC_CFG, SDC_CFG_SDIO);\n\n\t\t \n\t\tsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_SDIOIDE);\n\t\tsdr_set_bits(host->base + SDC_ADV_CFG0, SDC_DAT1_IRQ_TRIGGER);\n\t}\n\n\t \n\tsdr_set_field(host->base + SDC_CFG, SDC_CFG_DTOC, 3);\n\n\thost->def_tune_para.iocon = readl(host->base + MSDC_IOCON);\n\thost->saved_tune_para.iocon = readl(host->base + MSDC_IOCON);\n\tif (host->top_base) {\n\t\thost->def_tune_para.emmc_top_control =\n\t\t\treadl(host->top_base + EMMC_TOP_CONTROL);\n\t\thost->def_tune_para.emmc_top_cmd =\n\t\t\treadl(host->top_base + EMMC_TOP_CMD);\n\t\thost->saved_tune_para.emmc_top_control =\n\t\t\treadl(host->top_base + EMMC_TOP_CONTROL);\n\t\thost->saved_tune_para.emmc_top_cmd =\n\t\t\treadl(host->top_base + EMMC_TOP_CMD);\n\t} else {\n\t\thost->def_tune_para.pad_tune = readl(host->base + tune_reg);\n\t\thost->saved_tune_para.pad_tune = readl(host->base + tune_reg);\n\t}\n\tdev_dbg(host->dev, \"init hardware done!\");\n}\n\nstatic void msdc_deinit_hw(struct msdc_host *host)\n{\n\tu32 val;\n\n\tif (host->internal_cd) {\n\t\t \n\t\tsdr_clr_bits(host->base + MSDC_PS, MSDC_PS_CDEN);\n\t\tsdr_clr_bits(host->base + SDC_CFG, SDC_CFG_INSWKUP);\n\t}\n\n\t \n\twritel(0, host->base + MSDC_INTEN);\n\n\tval = readl(host->base + MSDC_INT);\n\twritel(val, host->base + MSDC_INT);\n}\n\n \nstatic void msdc_init_gpd_bd(struct msdc_host *host, struct msdc_dma *dma)\n{\n\tstruct mt_gpdma_desc *gpd = dma->gpd;\n\tstruct mt_bdma_desc *bd = dma->bd;\n\tdma_addr_t dma_addr;\n\tint i;\n\n\tmemset(gpd, 0, sizeof(struct mt_gpdma_desc) * 2);\n\n\tdma_addr = dma->gpd_addr + sizeof(struct mt_gpdma_desc);\n\tgpd->gpd_info = GPDMA_DESC_BDP;  \n\t \n\tgpd->next = lower_32_bits(dma_addr);\n\tif (host->dev_comp->support_64g)\n\t\tgpd->gpd_info |= (upper_32_bits(dma_addr) & 0xf) << 24;\n\n\tdma_addr = dma->bd_addr;\n\tgpd->ptr = lower_32_bits(dma->bd_addr);  \n\tif (host->dev_comp->support_64g)\n\t\tgpd->gpd_info |= (upper_32_bits(dma_addr) & 0xf) << 28;\n\n\tmemset(bd, 0, sizeof(struct mt_bdma_desc) * MAX_BD_NUM);\n\tfor (i = 0; i < (MAX_BD_NUM - 1); i++) {\n\t\tdma_addr = dma->bd_addr + sizeof(*bd) * (i + 1);\n\t\tbd[i].next = lower_32_bits(dma_addr);\n\t\tif (host->dev_comp->support_64g)\n\t\t\tbd[i].bd_info |= (upper_32_bits(dma_addr) & 0xf) << 24;\n\t}\n}\n\nstatic void msdc_ops_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tmsdc_set_buswidth(host, ios->bus_width);\n\n\t \n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_UP:\n\t\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\t\tmsdc_init_hw(host);\n\t\t\tret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc,\n\t\t\t\t\tios->vdd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(host->dev, \"Failed to set vmmc power!\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {\n\t\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\t\tif (ret)\n\t\t\t\tdev_err(host->dev, \"Failed to set vqmmc power!\\n\");\n\t\t\telse\n\t\t\t\thost->vqmmc_enabled = true;\n\t\t}\n\t\tbreak;\n\tcase MMC_POWER_OFF:\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {\n\t\t\tregulator_disable(mmc->supply.vqmmc);\n\t\t\thost->vqmmc_enabled = false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (host->mclk != ios->clock || host->timing != ios->timing)\n\t\tmsdc_set_mclk(host, ios->timing, ios->clock);\n}\n\nstatic u32 test_delay_bit(u32 delay, u32 bit)\n{\n\tbit %= PAD_DELAY_MAX;\n\treturn delay & BIT(bit);\n}\n\nstatic int get_delay_len(u32 delay, u32 start_bit)\n{\n\tint i;\n\n\tfor (i = 0; i < (PAD_DELAY_MAX - start_bit); i++) {\n\t\tif (test_delay_bit(delay, start_bit + i) == 0)\n\t\t\treturn i;\n\t}\n\treturn PAD_DELAY_MAX - start_bit;\n}\n\nstatic struct msdc_delay_phase get_best_delay(struct msdc_host *host, u32 delay)\n{\n\tint start = 0, len = 0;\n\tint start_final = 0, len_final = 0;\n\tu8 final_phase = 0xff;\n\tstruct msdc_delay_phase delay_phase = { 0, };\n\n\tif (delay == 0) {\n\t\tdev_err(host->dev, \"phase error: [map:%x]\\n\", delay);\n\t\tdelay_phase.final_phase = final_phase;\n\t\treturn delay_phase;\n\t}\n\n\twhile (start < PAD_DELAY_MAX) {\n\t\tlen = get_delay_len(delay, start);\n\t\tif (len_final < len) {\n\t\t\tstart_final = start;\n\t\t\tlen_final = len;\n\t\t}\n\t\tstart += len ? len : 1;\n\t\tif (len >= 12 && start_final < 4)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (start_final == 0)\n\t\tfinal_phase = (start_final + len_final / 3) % PAD_DELAY_MAX;\n\telse\n\t\tfinal_phase = (start_final + len_final / 2) % PAD_DELAY_MAX;\n\tdev_dbg(host->dev, \"phase: [map:%x] [maxlen:%d] [final:%d]\\n\",\n\t\tdelay, len_final, final_phase);\n\n\tdelay_phase.maxlen = len_final;\n\tdelay_phase.start = start_final;\n\tdelay_phase.final_phase = final_phase;\n\treturn delay_phase;\n}\n\nstatic inline void msdc_set_cmd_delay(struct msdc_host *host, u32 value)\n{\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\n\tif (host->top_base)\n\t\tsdr_set_field(host->top_base + EMMC_TOP_CMD, PAD_CMD_RXDLY,\n\t\t\t      value);\n\telse\n\t\tsdr_set_field(host->base + tune_reg, MSDC_PAD_TUNE_CMDRDLY,\n\t\t\t      value);\n}\n\nstatic inline void msdc_set_data_delay(struct msdc_host *host, u32 value)\n{\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\n\tif (host->top_base)\n\t\tsdr_set_field(host->top_base + EMMC_TOP_CONTROL,\n\t\t\t      PAD_DAT_RD_RXDLY, value);\n\telse\n\t\tsdr_set_field(host->base + tune_reg, MSDC_PAD_TUNE_DATRRDLY,\n\t\t\t      value);\n}\n\nstatic int msdc_tune_response(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 rise_delay = 0, fall_delay = 0;\n\tstruct msdc_delay_phase final_rise_delay, final_fall_delay = { 0,};\n\tstruct msdc_delay_phase internal_delay_phase;\n\tu8 final_delay, final_maxlen;\n\tu32 internal_delay = 0;\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\tint cmd_err;\n\tint i, j;\n\n\tif (mmc->ios.timing == MMC_TIMING_MMC_HS200 ||\n\t    mmc->ios.timing == MMC_TIMING_UHS_SDR104)\n\t\tsdr_set_field(host->base + tune_reg,\n\t\t\t      MSDC_PAD_TUNE_CMDRRDLY,\n\t\t\t      host->hs200_cmd_int_delay);\n\n\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tfor (i = 0 ; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_cmd_delay(host, i);\n\t\t \n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tmmc_send_tuning(mmc, opcode, &cmd_err);\n\t\t\tif (!cmd_err) {\n\t\t\t\trise_delay |= BIT(i);\n\t\t\t} else {\n\t\t\t\trise_delay &= ~BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfinal_rise_delay = get_best_delay(host, rise_delay);\n\t \n\tif (final_rise_delay.maxlen >= 12 ||\n\t    (final_rise_delay.start == 0 && final_rise_delay.maxlen >= 4))\n\t\tgoto skip_fall;\n\n\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tfor (i = 0; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_cmd_delay(host, i);\n\t\t \n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tmmc_send_tuning(mmc, opcode, &cmd_err);\n\t\t\tif (!cmd_err) {\n\t\t\t\tfall_delay |= BIT(i);\n\t\t\t} else {\n\t\t\t\tfall_delay &= ~BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfinal_fall_delay = get_best_delay(host, fall_delay);\n\nskip_fall:\n\tfinal_maxlen = max(final_rise_delay.maxlen, final_fall_delay.maxlen);\n\tif (final_fall_delay.maxlen >= 12 && final_fall_delay.start < 4)\n\t\tfinal_maxlen = final_fall_delay.maxlen;\n\tif (final_maxlen == final_rise_delay.maxlen) {\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\t\tfinal_delay = final_rise_delay.final_phase;\n\t} else {\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\t\tfinal_delay = final_fall_delay.final_phase;\n\t}\n\tmsdc_set_cmd_delay(host, final_delay);\n\n\tif (host->dev_comp->async_fifo || host->hs200_cmd_int_delay)\n\t\tgoto skip_internal;\n\n\tfor (i = 0; i < PAD_DELAY_MAX; i++) {\n\t\tsdr_set_field(host->base + tune_reg,\n\t\t\t      MSDC_PAD_TUNE_CMDRRDLY, i);\n\t\tmmc_send_tuning(mmc, opcode, &cmd_err);\n\t\tif (!cmd_err)\n\t\t\tinternal_delay |= BIT(i);\n\t}\n\tdev_dbg(host->dev, \"Final internal delay: 0x%x\\n\", internal_delay);\n\tinternal_delay_phase = get_best_delay(host, internal_delay);\n\tsdr_set_field(host->base + tune_reg, MSDC_PAD_TUNE_CMDRRDLY,\n\t\t      internal_delay_phase.final_phase);\nskip_internal:\n\tdev_dbg(host->dev, \"Final cmd pad delay: %x\\n\", final_delay);\n\treturn final_delay == 0xff ? -EIO : 0;\n}\n\nstatic int hs400_tune_response(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 cmd_delay = 0;\n\tstruct msdc_delay_phase final_cmd_delay = { 0,};\n\tu8 final_delay;\n\tint cmd_err;\n\tint i, j;\n\n\t \n\tsdr_set_bits(host->base + PAD_CMD_TUNE, BIT(0));\n\tsdr_set_field(host->base + MSDC_PATCH_BIT1, MSDC_PATCH_BIT1_CMDTA, 2);\n\n\tif (mmc->ios.timing == MMC_TIMING_MMC_HS200 ||\n\t    mmc->ios.timing == MMC_TIMING_UHS_SDR104)\n\t\tsdr_set_field(host->base + MSDC_PAD_TUNE,\n\t\t\t      MSDC_PAD_TUNE_CMDRRDLY,\n\t\t\t      host->hs200_cmd_int_delay);\n\n\tif (host->hs400_cmd_resp_sel_rising)\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\telse\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tfor (i = 0 ; i < PAD_DELAY_MAX; i++) {\n\t\tsdr_set_field(host->base + PAD_CMD_TUNE,\n\t\t\t      PAD_CMD_TUNE_RX_DLY3, i);\n\t\t \n\t\tfor (j = 0; j < 3; j++) {\n\t\t\tmmc_send_tuning(mmc, opcode, &cmd_err);\n\t\t\tif (!cmd_err) {\n\t\t\t\tcmd_delay |= BIT(i);\n\t\t\t} else {\n\t\t\t\tcmd_delay &= ~BIT(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfinal_cmd_delay = get_best_delay(host, cmd_delay);\n\tsdr_set_field(host->base + PAD_CMD_TUNE, PAD_CMD_TUNE_RX_DLY3,\n\t\t      final_cmd_delay.final_phase);\n\tfinal_delay = final_cmd_delay.final_phase;\n\n\tdev_dbg(host->dev, \"Final cmd pad delay: %x\\n\", final_delay);\n\treturn final_delay == 0xff ? -EIO : 0;\n}\n\nstatic int msdc_tune_data(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 rise_delay = 0, fall_delay = 0;\n\tstruct msdc_delay_phase final_rise_delay, final_fall_delay = { 0,};\n\tu8 final_delay, final_maxlen;\n\tint i, ret;\n\n\tsdr_set_field(host->base + MSDC_PATCH_BIT, MSDC_INT_DAT_LATCH_CK_SEL,\n\t\t      host->latch_ck);\n\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_DSPL);\n\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_W_DSPL);\n\tfor (i = 0 ; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_data_delay(host, i);\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret)\n\t\t\trise_delay |= BIT(i);\n\t}\n\tfinal_rise_delay = get_best_delay(host, rise_delay);\n\t \n\tif (final_rise_delay.maxlen >= 12 ||\n\t    (final_rise_delay.start == 0 && final_rise_delay.maxlen >= 4))\n\t\tgoto skip_fall;\n\n\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_DSPL);\n\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_W_DSPL);\n\tfor (i = 0; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_data_delay(host, i);\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret)\n\t\t\tfall_delay |= BIT(i);\n\t}\n\tfinal_fall_delay = get_best_delay(host, fall_delay);\n\nskip_fall:\n\tfinal_maxlen = max(final_rise_delay.maxlen, final_fall_delay.maxlen);\n\tif (final_maxlen == final_rise_delay.maxlen) {\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_DSPL);\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_W_DSPL);\n\t\tfinal_delay = final_rise_delay.final_phase;\n\t} else {\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_DSPL);\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_W_DSPL);\n\t\tfinal_delay = final_fall_delay.final_phase;\n\t}\n\tmsdc_set_data_delay(host, final_delay);\n\n\tdev_dbg(host->dev, \"Final data pad delay: %x\\n\", final_delay);\n\treturn final_delay == 0xff ? -EIO : 0;\n}\n\n \nstatic int msdc_tune_together(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tu32 rise_delay = 0, fall_delay = 0;\n\tstruct msdc_delay_phase final_rise_delay, final_fall_delay = { 0,};\n\tu8 final_delay, final_maxlen;\n\tint i, ret;\n\n\tsdr_set_field(host->base + MSDC_PATCH_BIT, MSDC_INT_DAT_LATCH_CK_SEL,\n\t\t      host->latch_ck);\n\n\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tsdr_clr_bits(host->base + MSDC_IOCON,\n\t\t     MSDC_IOCON_DSPL | MSDC_IOCON_W_DSPL);\n\tfor (i = 0 ; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_cmd_delay(host, i);\n\t\tmsdc_set_data_delay(host, i);\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret)\n\t\t\trise_delay |= BIT(i);\n\t}\n\tfinal_rise_delay = get_best_delay(host, rise_delay);\n\t \n\tif (final_rise_delay.maxlen >= 12 ||\n\t    (final_rise_delay.start == 0 && final_rise_delay.maxlen >= 4))\n\t\tgoto skip_fall;\n\n\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\tsdr_set_bits(host->base + MSDC_IOCON,\n\t\t     MSDC_IOCON_DSPL | MSDC_IOCON_W_DSPL);\n\tfor (i = 0; i < PAD_DELAY_MAX; i++) {\n\t\tmsdc_set_cmd_delay(host, i);\n\t\tmsdc_set_data_delay(host, i);\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret)\n\t\t\tfall_delay |= BIT(i);\n\t}\n\tfinal_fall_delay = get_best_delay(host, fall_delay);\n\nskip_fall:\n\tfinal_maxlen = max(final_rise_delay.maxlen, final_fall_delay.maxlen);\n\tif (final_maxlen == final_rise_delay.maxlen) {\n\t\tsdr_clr_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\t\tsdr_clr_bits(host->base + MSDC_IOCON,\n\t\t\t     MSDC_IOCON_DSPL | MSDC_IOCON_W_DSPL);\n\t\tfinal_delay = final_rise_delay.final_phase;\n\t} else {\n\t\tsdr_set_bits(host->base + MSDC_IOCON, MSDC_IOCON_RSPL);\n\t\tsdr_set_bits(host->base + MSDC_IOCON,\n\t\t\t     MSDC_IOCON_DSPL | MSDC_IOCON_W_DSPL);\n\t\tfinal_delay = final_fall_delay.final_phase;\n\t}\n\n\tmsdc_set_cmd_delay(host, final_delay);\n\tmsdc_set_data_delay(host, final_delay);\n\n\tdev_dbg(host->dev, \"Final pad delay: %x\\n\", final_delay);\n\treturn final_delay == 0xff ? -EIO : 0;\n}\n\nstatic int msdc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint ret;\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\n\tif (host->dev_comp->data_tune && host->dev_comp->async_fifo) {\n\t\tret = msdc_tune_together(mmc, opcode);\n\t\tif (host->hs400_mode) {\n\t\t\tsdr_clr_bits(host->base + MSDC_IOCON,\n\t\t\t\t     MSDC_IOCON_DSPL | MSDC_IOCON_W_DSPL);\n\t\t\tmsdc_set_data_delay(host, 0);\n\t\t}\n\t\tgoto tune_done;\n\t}\n\tif (host->hs400_mode &&\n\t    host->dev_comp->hs400_tune)\n\t\tret = hs400_tune_response(mmc, opcode);\n\telse\n\t\tret = msdc_tune_response(mmc, opcode);\n\tif (ret == -EIO) {\n\t\tdev_err(host->dev, \"Tune response fail!\\n\");\n\t\treturn ret;\n\t}\n\tif (host->hs400_mode == false) {\n\t\tret = msdc_tune_data(mmc, opcode);\n\t\tif (ret == -EIO)\n\t\t\tdev_err(host->dev, \"Tune data fail!\\n\");\n\t}\n\ntune_done:\n\thost->saved_tune_para.iocon = readl(host->base + MSDC_IOCON);\n\thost->saved_tune_para.pad_tune = readl(host->base + tune_reg);\n\thost->saved_tune_para.pad_cmd_tune = readl(host->base + PAD_CMD_TUNE);\n\tif (host->top_base) {\n\t\thost->saved_tune_para.emmc_top_control = readl(host->top_base +\n\t\t\t\tEMMC_TOP_CONTROL);\n\t\thost->saved_tune_para.emmc_top_cmd = readl(host->top_base +\n\t\t\t\tEMMC_TOP_CMD);\n\t}\n\treturn ret;\n}\n\nstatic int msdc_prepare_hs400_tuning(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\thost->hs400_mode = true;\n\n\tif (host->top_base)\n\t\twritel(host->hs400_ds_delay,\n\t\t       host->top_base + EMMC50_PAD_DS_TUNE);\n\telse\n\t\twritel(host->hs400_ds_delay, host->base + PAD_DS_TUNE);\n\t \n\tsdr_clr_bits(host->base + MSDC_PATCH_BIT2, MSDC_PATCH_BIT2_CFGCRCSTS);\n\t \n\tsdr_set_field(host->base + EMMC50_CFG3, EMMC50_CFG3_OUTS_WR, 2);\n\n\treturn 0;\n}\n\nstatic int msdc_execute_hs400_tuning(struct mmc_host *mmc, struct mmc_card *card)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tstruct msdc_delay_phase dly1_delay;\n\tu32 val, result_dly1 = 0;\n\tu8 *ext_csd;\n\tint i, ret;\n\n\tif (host->top_base) {\n\t\tsdr_set_bits(host->top_base + EMMC50_PAD_DS_TUNE,\n\t\t\t     PAD_DS_DLY_SEL);\n\t\tif (host->hs400_ds_dly3)\n\t\t\tsdr_set_field(host->top_base + EMMC50_PAD_DS_TUNE,\n\t\t\t\t      PAD_DS_DLY3, host->hs400_ds_dly3);\n\t} else {\n\t\tsdr_set_bits(host->base + PAD_DS_TUNE, PAD_DS_TUNE_DLY_SEL);\n\t\tif (host->hs400_ds_dly3)\n\t\t\tsdr_set_field(host->base + PAD_DS_TUNE,\n\t\t\t\t      PAD_DS_TUNE_DLY3, host->hs400_ds_dly3);\n\t}\n\n\thost->hs400_tuning = true;\n\tfor (i = 0; i < PAD_DELAY_MAX; i++) {\n\t\tif (host->top_base)\n\t\t\tsdr_set_field(host->top_base + EMMC50_PAD_DS_TUNE,\n\t\t\t\t      PAD_DS_DLY1, i);\n\t\telse\n\t\t\tsdr_set_field(host->base + PAD_DS_TUNE,\n\t\t\t\t      PAD_DS_TUNE_DLY1, i);\n\t\tret = mmc_get_ext_csd(card, &ext_csd);\n\t\tif (!ret) {\n\t\t\tresult_dly1 |= BIT(i);\n\t\t\tkfree(ext_csd);\n\t\t}\n\t}\n\thost->hs400_tuning = false;\n\n\tdly1_delay = get_best_delay(host, result_dly1);\n\tif (dly1_delay.maxlen == 0) {\n\t\tdev_err(host->dev, \"Failed to get DLY1 delay!\\n\");\n\t\tgoto fail;\n\t}\n\tif (host->top_base)\n\t\tsdr_set_field(host->top_base + EMMC50_PAD_DS_TUNE,\n\t\t\t      PAD_DS_DLY1, dly1_delay.final_phase);\n\telse\n\t\tsdr_set_field(host->base + PAD_DS_TUNE,\n\t\t\t      PAD_DS_TUNE_DLY1, dly1_delay.final_phase);\n\n\tif (host->top_base)\n\t\tval = readl(host->top_base + EMMC50_PAD_DS_TUNE);\n\telse\n\t\tval = readl(host->base + PAD_DS_TUNE);\n\n\tdev_info(host->dev, \"Final PAD_DS_TUNE: 0x%x\\n\", val);\n\n\treturn 0;\n\nfail:\n\tdev_err(host->dev, \"Failed to tuning DS pin delay!\\n\");\n\treturn -EIO;\n}\n\nstatic void msdc_hw_reset(struct mmc_host *mmc)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\tsdr_set_bits(host->base + EMMC_IOCON, 1);\n\tudelay(10);  \n\tsdr_clr_bits(host->base + EMMC_IOCON, 1);\n}\n\nstatic void msdc_ack_sdio_irq(struct mmc_host *mmc)\n{\n\tunsigned long flags;\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\t__msdc_enable_sdio_irq(host, 1);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic int msdc_get_cd(struct mmc_host *mmc)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint val;\n\n\tif (mmc->caps & MMC_CAP_NONREMOVABLE)\n\t\treturn 1;\n\n\tif (!host->internal_cd)\n\t\treturn mmc_gpio_get_cd(mmc);\n\n\tval = readl(host->base + MSDC_PS) & MSDC_PS_CDSTS;\n\tif (mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH)\n\t\treturn !!val;\n\telse\n\t\treturn !val;\n}\n\nstatic void msdc_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\tif (ios->enhanced_strobe) {\n\t\tmsdc_prepare_hs400_tuning(mmc, ios);\n\t\tsdr_set_field(host->base + EMMC50_CFG0, EMMC50_CFG_PADCMD_LATCHCK, 1);\n\t\tsdr_set_field(host->base + EMMC50_CFG0, EMMC50_CFG_CMD_RESP_SEL, 1);\n\t\tsdr_set_field(host->base + EMMC50_CFG1, EMMC50_CFG1_DS_CFG, 1);\n\n\t\tsdr_clr_bits(host->base + CQHCI_SETTING, CQHCI_RD_CMD_WND_SEL);\n\t\tsdr_clr_bits(host->base + CQHCI_SETTING, CQHCI_WR_CMD_WND_SEL);\n\t\tsdr_clr_bits(host->base + EMMC51_CFG0, CMDQ_RDAT_CNT);\n\t} else {\n\t\tsdr_set_field(host->base + EMMC50_CFG0, EMMC50_CFG_PADCMD_LATCHCK, 0);\n\t\tsdr_set_field(host->base + EMMC50_CFG0, EMMC50_CFG_CMD_RESP_SEL, 0);\n\t\tsdr_set_field(host->base + EMMC50_CFG1, EMMC50_CFG1_DS_CFG, 0);\n\n\t\tsdr_set_bits(host->base + CQHCI_SETTING, CQHCI_RD_CMD_WND_SEL);\n\t\tsdr_set_bits(host->base + CQHCI_SETTING, CQHCI_WR_CMD_WND_SEL);\n\t\tsdr_set_field(host->base + EMMC51_CFG0, CMDQ_RDAT_CNT, 0xb4);\n\t}\n}\n\nstatic void msdc_cqe_cit_cal(struct msdc_host *host, u64 timer_ns)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu8 itcfmul;\n\tu64 hclk_freq, value;\n\n\t \n\thclk_freq = (u64)clk_get_rate(host->h_clk);\n\titcfmul = CQHCI_ITCFMUL(cqhci_readl(cq_host, CQHCI_CAP));\n\tswitch (itcfmul) {\n\tcase 0x0:\n\t\tdo_div(hclk_freq, 1000);\n\t\tbreak;\n\tcase 0x1:\n\t\tdo_div(hclk_freq, 100);\n\t\tbreak;\n\tcase 0x2:\n\t\tdo_div(hclk_freq, 10);\n\t\tbreak;\n\tcase 0x3:\n\t\tbreak;\n\tcase 0x4:\n\t\thclk_freq = hclk_freq * 10;\n\t\tbreak;\n\tdefault:\n\t\thost->cq_ssc1_time = 0x40;\n\t\treturn;\n\t}\n\n\tvalue = hclk_freq * timer_ns;\n\tdo_div(value, 1000000000);\n\thost->cq_ssc1_time = value;\n}\n\nstatic void msdc_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\t \n\twritel(MSDC_INT_CMDQ, host->base + MSDC_INTEN);\n\t \n\tsdr_set_bits(host->base + MSDC_PATCH_BIT1, MSDC_PB1_BUSY_CHECK_SEL);\n\t \n\tmsdc_set_busy_timeout(host, 20 * 1000000000ULL, 0);\n\t \n\tmsdc_set_timeout(host, 1000000000ULL, 0);\n\n\t \n\tcqhci_writel(cq_host, host->cq_ssc1_time, CQHCI_SSC1);\n}\n\nstatic void msdc_cqe_disable(struct mmc_host *mmc, bool recovery)\n{\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tunsigned int val = 0;\n\n\t \n\tsdr_clr_bits(host->base + MSDC_INTEN, MSDC_INT_CMDQ);\n\t \n\tsdr_clr_bits(host->base + MSDC_PATCH_BIT1, MSDC_PB1_BUSY_CHECK_SEL);\n\n\tval = readl(host->base + MSDC_INT);\n\twritel(val, host->base + MSDC_INT);\n\n\tif (recovery) {\n\t\tsdr_set_field(host->base + MSDC_DMA_CTRL,\n\t\t\t      MSDC_DMA_CTRL_STOP, 1);\n\t\tif (WARN_ON(readl_poll_timeout(host->base + MSDC_DMA_CTRL, val,\n\t\t\t!(val & MSDC_DMA_CTRL_STOP), 1, 3000)))\n\t\t\treturn;\n\t\tif (WARN_ON(readl_poll_timeout(host->base + MSDC_DMA_CFG, val,\n\t\t\t!(val & MSDC_DMA_CFG_STS), 1, 3000)))\n\t\t\treturn;\n\t\tmsdc_reset_hw(host);\n\t}\n}\n\nstatic void msdc_cqe_pre_enable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu32 reg;\n\n\treg = cqhci_readl(cq_host, CQHCI_CFG);\n\treg |= CQHCI_ENABLE;\n\tcqhci_writel(cq_host, reg, CQHCI_CFG);\n}\n\nstatic void msdc_cqe_post_disable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu32 reg;\n\n\treg = cqhci_readl(cq_host, CQHCI_CFG);\n\treg &= ~CQHCI_ENABLE;\n\tcqhci_writel(cq_host, reg, CQHCI_CFG);\n}\n\nstatic const struct mmc_host_ops mt_msdc_ops = {\n\t.post_req = msdc_post_req,\n\t.pre_req = msdc_pre_req,\n\t.request = msdc_ops_request,\n\t.set_ios = msdc_ops_set_ios,\n\t.get_ro = mmc_gpio_get_ro,\n\t.get_cd = msdc_get_cd,\n\t.hs400_enhanced_strobe = msdc_hs400_enhanced_strobe,\n\t.enable_sdio_irq = msdc_enable_sdio_irq,\n\t.ack_sdio_irq = msdc_ack_sdio_irq,\n\t.start_signal_voltage_switch = msdc_ops_switch_volt,\n\t.card_busy = msdc_card_busy,\n\t.execute_tuning = msdc_execute_tuning,\n\t.prepare_hs400_tuning = msdc_prepare_hs400_tuning,\n\t.execute_hs400_tuning = msdc_execute_hs400_tuning,\n\t.card_hw_reset = msdc_hw_reset,\n};\n\nstatic const struct cqhci_host_ops msdc_cmdq_ops = {\n\t.enable         = msdc_cqe_enable,\n\t.disable        = msdc_cqe_disable,\n\t.pre_enable = msdc_cqe_pre_enable,\n\t.post_disable = msdc_cqe_post_disable,\n};\n\nstatic void msdc_of_property_parse(struct platform_device *pdev,\n\t\t\t\t   struct msdc_host *host)\n{\n\tof_property_read_u32(pdev->dev.of_node, \"mediatek,latch-ck\",\n\t\t\t     &host->latch_ck);\n\n\tof_property_read_u32(pdev->dev.of_node, \"hs400-ds-delay\",\n\t\t\t     &host->hs400_ds_delay);\n\n\tof_property_read_u32(pdev->dev.of_node, \"mediatek,hs400-ds-dly3\",\n\t\t\t     &host->hs400_ds_dly3);\n\n\tof_property_read_u32(pdev->dev.of_node, \"mediatek,hs200-cmd-int-delay\",\n\t\t\t     &host->hs200_cmd_int_delay);\n\n\tof_property_read_u32(pdev->dev.of_node, \"mediatek,hs400-cmd-int-delay\",\n\t\t\t     &host->hs400_cmd_int_delay);\n\n\tif (of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t  \"mediatek,hs400-cmd-resp-sel-rising\"))\n\t\thost->hs400_cmd_resp_sel_rising = true;\n\telse\n\t\thost->hs400_cmd_resp_sel_rising = false;\n\n\tif (of_property_read_bool(pdev->dev.of_node,\n\t\t\t\t  \"supports-cqe\"))\n\t\thost->cqhci = true;\n\telse\n\t\thost->cqhci = false;\n}\n\nstatic int msdc_of_clock_parse(struct platform_device *pdev,\n\t\t\t       struct msdc_host *host)\n{\n\tint ret;\n\n\thost->src_clk = devm_clk_get(&pdev->dev, \"source\");\n\tif (IS_ERR(host->src_clk))\n\t\treturn PTR_ERR(host->src_clk);\n\n\thost->h_clk = devm_clk_get(&pdev->dev, \"hclk\");\n\tif (IS_ERR(host->h_clk))\n\t\treturn PTR_ERR(host->h_clk);\n\n\thost->bus_clk = devm_clk_get_optional(&pdev->dev, \"bus_clk\");\n\tif (IS_ERR(host->bus_clk))\n\t\thost->bus_clk = NULL;\n\n\t \n\thost->src_clk_cg = devm_clk_get_optional(&pdev->dev, \"source_cg\");\n\tif (IS_ERR(host->src_clk_cg))\n\t\treturn PTR_ERR(host->src_clk_cg);\n\n\t \n\tif (!host->src_clk_cg) {\n\t\thost->src_clk_cg = clk_get_parent(host->src_clk);\n\t\tif (IS_ERR(host->src_clk_cg))\n\t\t\treturn PTR_ERR(host->src_clk_cg);\n\t}\n\n\t \n\thost->sys_clk_cg = devm_clk_get_optional_enabled(&pdev->dev, \"sys_cg\");\n\tif (IS_ERR(host->sys_clk_cg))\n\t\thost->sys_clk_cg = NULL;\n\n\thost->bulk_clks[0].id = \"pclk_cg\";\n\thost->bulk_clks[1].id = \"axi_cg\";\n\thost->bulk_clks[2].id = \"ahb_cg\";\n\tret = devm_clk_bulk_get_optional(&pdev->dev, MSDC_NR_CLOCKS,\n\t\t\t\t\t host->bulk_clks);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot get pclk/axi/ahb clock gates\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int msdc_drv_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct msdc_host *host;\n\tstruct resource *res;\n\tint ret;\n\n\tif (!pdev->dev.of_node) {\n\t\tdev_err(&pdev->dev, \"No DT found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmmc = mmc_alloc_host(sizeof(struct msdc_host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto host_free;\n\n\thost->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto host_free;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res) {\n\t\thost->top_base = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(host->top_base))\n\t\t\thost->top_base = NULL;\n\t}\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto host_free;\n\n\tret = msdc_of_clock_parse(pdev, host);\n\tif (ret)\n\t\tgoto host_free;\n\n\thost->reset = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t\"hrst\");\n\tif (IS_ERR(host->reset)) {\n\t\tret = PTR_ERR(host->reset);\n\t\tgoto host_free;\n\t}\n\n\t \n\tif (!(mmc->caps2 & MMC_CAP2_NO_MMC)) {\n\t\thost->crypto_clk = devm_clk_get_optional(&pdev->dev, \"crypto\");\n\t\tif (IS_ERR(host->crypto_clk))\n\t\t\thost->crypto_clk = NULL;\n\t\telse\n\t\t\tmmc->caps2 |= MMC_CAP2_CRYPTO;\n\t}\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto host_free;\n\t}\n\n\thost->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(host->pinctrl)) {\n\t\tret = PTR_ERR(host->pinctrl);\n\t\tdev_err(&pdev->dev, \"Cannot find pinctrl!\\n\");\n\t\tgoto host_free;\n\t}\n\n\thost->pins_default = pinctrl_lookup_state(host->pinctrl, \"default\");\n\tif (IS_ERR(host->pins_default)) {\n\t\tret = PTR_ERR(host->pins_default);\n\t\tdev_err(&pdev->dev, \"Cannot find pinctrl default!\\n\");\n\t\tgoto host_free;\n\t}\n\n\thost->pins_uhs = pinctrl_lookup_state(host->pinctrl, \"state_uhs\");\n\tif (IS_ERR(host->pins_uhs)) {\n\t\tret = PTR_ERR(host->pins_uhs);\n\t\tdev_err(&pdev->dev, \"Cannot find pinctrl uhs!\\n\");\n\t\tgoto host_free;\n\t}\n\n\t \n\tif ((mmc->pm_caps & MMC_PM_WAKE_SDIO_IRQ) && (mmc->pm_caps & MMC_PM_KEEP_POWER)) {\n\t\thost->eint_irq = platform_get_irq_byname_optional(pdev, \"sdio_wakeup\");\n\t\tif (host->eint_irq > 0) {\n\t\t\thost->pins_eint = pinctrl_lookup_state(host->pinctrl, \"state_eint\");\n\t\t\tif (IS_ERR(host->pins_eint)) {\n\t\t\t\tdev_err(&pdev->dev, \"Cannot find pinctrl eint!\\n\");\n\t\t\t\thost->pins_eint = NULL;\n\t\t\t} else {\n\t\t\t\tdevice_init_wakeup(&pdev->dev, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tmsdc_of_property_parse(pdev, host);\n\n\thost->dev = &pdev->dev;\n\thost->dev_comp = of_device_get_match_data(&pdev->dev);\n\thost->src_clk_freq = clk_get_rate(host->src_clk);\n\t \n\tmmc->ops = &mt_msdc_ops;\n\tif (host->dev_comp->clk_div_bits == 8)\n\t\tmmc->f_min = DIV_ROUND_UP(host->src_clk_freq, 4 * 255);\n\telse\n\t\tmmc->f_min = DIV_ROUND_UP(host->src_clk_freq, 4 * 4095);\n\n\tif (!(mmc->caps & MMC_CAP_NONREMOVABLE) &&\n\t    !mmc_can_gpio_cd(mmc) &&\n\t    host->dev_comp->use_internal_cd) {\n\t\t \n\t\thost->internal_cd = true;\n\t}\n\n\tif (mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\tmmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;\n\n\tmmc->caps |= MMC_CAP_CMD23;\n\tif (host->cqhci)\n\t\tmmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;\n\t \n\tmmc->max_segs = MAX_BD_NUM;\n\tif (host->dev_comp->support_64g)\n\t\tmmc->max_seg_size = BDMA_DESC_BUFLEN_EXT;\n\telse\n\t\tmmc->max_seg_size = BDMA_DESC_BUFLEN;\n\tmmc->max_blk_size = 2048;\n\tmmc->max_req_size = 512 * 1024;\n\tmmc->max_blk_count = mmc->max_req_size / 512;\n\tif (host->dev_comp->support_64g)\n\t\thost->dma_mask = DMA_BIT_MASK(36);\n\telse\n\t\thost->dma_mask = DMA_BIT_MASK(32);\n\tmmc_dev(mmc)->dma_mask = &host->dma_mask;\n\n\thost->timeout_clks = 3 * 1048576;\n\thost->dma.gpd = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t2 * sizeof(struct mt_gpdma_desc),\n\t\t\t\t&host->dma.gpd_addr, GFP_KERNEL);\n\thost->dma.bd = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tMAX_BD_NUM * sizeof(struct mt_bdma_desc),\n\t\t\t\t&host->dma.bd_addr, GFP_KERNEL);\n\tif (!host->dma.gpd || !host->dma.bd) {\n\t\tret = -ENOMEM;\n\t\tgoto release_mem;\n\t}\n\tmsdc_init_gpd_bd(host, &host->dma);\n\tINIT_DELAYED_WORK(&host->req_timeout, msdc_request_timeout);\n\tspin_lock_init(&host->lock);\n\n\tplatform_set_drvdata(pdev, mmc);\n\tret = msdc_ungate_clock(host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Cannot ungate clocks!\\n\");\n\t\tgoto release_mem;\n\t}\n\tmsdc_init_hw(host);\n\n\tif (mmc->caps2 & MMC_CAP2_CQE) {\n\t\thost->cq_host = devm_kzalloc(mmc->parent,\n\t\t\t\t\t     sizeof(*host->cq_host),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!host->cq_host) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto host_free;\n\t\t}\n\t\thost->cq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\t\thost->cq_host->mmio = host->base + 0x800;\n\t\thost->cq_host->ops = &msdc_cmdq_ops;\n\t\tret = cqhci_init(host->cq_host, mmc, true);\n\t\tif (ret)\n\t\t\tgoto host_free;\n\t\tmmc->max_segs = 128;\n\t\t \n\t\t \n\t\tmmc->max_seg_size = 64 * 1024;\n\t\t \n\t\tmsdc_cqe_cit_cal(host, 2350);\n\t}\n\n\tret = devm_request_irq(&pdev->dev, host->irq, msdc_irq,\n\t\t\t       IRQF_TRIGGER_NONE, pdev->name, host);\n\tif (ret)\n\t\tgoto release;\n\n\tpm_runtime_set_active(host->dev);\n\tpm_runtime_set_autosuspend_delay(host->dev, MTK_MMC_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(host->dev);\n\tpm_runtime_enable(host->dev);\n\tret = mmc_add_host(mmc);\n\n\tif (ret)\n\t\tgoto end;\n\n\treturn 0;\nend:\n\tpm_runtime_disable(host->dev);\nrelease:\n\tplatform_set_drvdata(pdev, NULL);\n\tmsdc_deinit_hw(host);\n\tmsdc_gate_clock(host);\nrelease_mem:\n\tif (host->dma.gpd)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t2 * sizeof(struct mt_gpdma_desc),\n\t\t\thost->dma.gpd, host->dma.gpd_addr);\n\tif (host->dma.bd)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\tMAX_BD_NUM * sizeof(struct mt_bdma_desc),\n\t\t\thost->dma.bd, host->dma.bd_addr);\nhost_free:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void msdc_drv_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct msdc_host *host;\n\n\tmmc = platform_get_drvdata(pdev);\n\thost = mmc_priv(mmc);\n\n\tpm_runtime_get_sync(host->dev);\n\n\tplatform_set_drvdata(pdev, NULL);\n\tmmc_remove_host(mmc);\n\tmsdc_deinit_hw(host);\n\tmsdc_gate_clock(host);\n\n\tpm_runtime_disable(host->dev);\n\tpm_runtime_put_noidle(host->dev);\n\tdma_free_coherent(&pdev->dev,\n\t\t\t2 * sizeof(struct mt_gpdma_desc),\n\t\t\thost->dma.gpd, host->dma.gpd_addr);\n\tdma_free_coherent(&pdev->dev, MAX_BD_NUM * sizeof(struct mt_bdma_desc),\n\t\t\thost->dma.bd, host->dma.bd_addr);\n\n\tmmc_free_host(mmc);\n}\n\nstatic void msdc_save_reg(struct msdc_host *host)\n{\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\n\thost->save_para.msdc_cfg = readl(host->base + MSDC_CFG);\n\thost->save_para.iocon = readl(host->base + MSDC_IOCON);\n\thost->save_para.sdc_cfg = readl(host->base + SDC_CFG);\n\thost->save_para.patch_bit0 = readl(host->base + MSDC_PATCH_BIT);\n\thost->save_para.patch_bit1 = readl(host->base + MSDC_PATCH_BIT1);\n\thost->save_para.patch_bit2 = readl(host->base + MSDC_PATCH_BIT2);\n\thost->save_para.pad_ds_tune = readl(host->base + PAD_DS_TUNE);\n\thost->save_para.pad_cmd_tune = readl(host->base + PAD_CMD_TUNE);\n\thost->save_para.emmc50_cfg0 = readl(host->base + EMMC50_CFG0);\n\thost->save_para.emmc50_cfg3 = readl(host->base + EMMC50_CFG3);\n\thost->save_para.sdc_fifo_cfg = readl(host->base + SDC_FIFO_CFG);\n\tif (host->top_base) {\n\t\thost->save_para.emmc_top_control =\n\t\t\treadl(host->top_base + EMMC_TOP_CONTROL);\n\t\thost->save_para.emmc_top_cmd =\n\t\t\treadl(host->top_base + EMMC_TOP_CMD);\n\t\thost->save_para.emmc50_pad_ds_tune =\n\t\t\treadl(host->top_base + EMMC50_PAD_DS_TUNE);\n\t} else {\n\t\thost->save_para.pad_tune = readl(host->base + tune_reg);\n\t}\n}\n\nstatic void msdc_restore_reg(struct msdc_host *host)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\tu32 tune_reg = host->dev_comp->pad_tune_reg;\n\n\twritel(host->save_para.msdc_cfg, host->base + MSDC_CFG);\n\twritel(host->save_para.iocon, host->base + MSDC_IOCON);\n\twritel(host->save_para.sdc_cfg, host->base + SDC_CFG);\n\twritel(host->save_para.patch_bit0, host->base + MSDC_PATCH_BIT);\n\twritel(host->save_para.patch_bit1, host->base + MSDC_PATCH_BIT1);\n\twritel(host->save_para.patch_bit2, host->base + MSDC_PATCH_BIT2);\n\twritel(host->save_para.pad_ds_tune, host->base + PAD_DS_TUNE);\n\twritel(host->save_para.pad_cmd_tune, host->base + PAD_CMD_TUNE);\n\twritel(host->save_para.emmc50_cfg0, host->base + EMMC50_CFG0);\n\twritel(host->save_para.emmc50_cfg3, host->base + EMMC50_CFG3);\n\twritel(host->save_para.sdc_fifo_cfg, host->base + SDC_FIFO_CFG);\n\tif (host->top_base) {\n\t\twritel(host->save_para.emmc_top_control,\n\t\t       host->top_base + EMMC_TOP_CONTROL);\n\t\twritel(host->save_para.emmc_top_cmd,\n\t\t       host->top_base + EMMC_TOP_CMD);\n\t\twritel(host->save_para.emmc50_pad_ds_tune,\n\t\t       host->top_base + EMMC50_PAD_DS_TUNE);\n\t} else {\n\t\twritel(host->save_para.pad_tune, host->base + tune_reg);\n\t}\n\n\tif (sdio_irq_claimed(mmc))\n\t\t__msdc_enable_sdio_irq(host, 1);\n}\n\nstatic int __maybe_unused msdc_runtime_suspend(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\tmsdc_save_reg(host);\n\n\tif (sdio_irq_claimed(mmc)) {\n\t\tif (host->pins_eint) {\n\t\t\tdisable_irq(host->irq);\n\t\t\tpinctrl_select_state(host->pinctrl, host->pins_eint);\n\t\t}\n\n\t\t__msdc_enable_sdio_irq(host, 0);\n\t}\n\tmsdc_gate_clock(host);\n\treturn 0;\n}\n\nstatic int __maybe_unused msdc_runtime_resume(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tret = msdc_ungate_clock(host);\n\tif (ret)\n\t\treturn ret;\n\n\tmsdc_restore_reg(host);\n\n\tif (sdio_irq_claimed(mmc) && host->pins_eint) {\n\t\tpinctrl_select_state(host->pinctrl, host->pins_uhs);\n\t\tenable_irq(host->irq);\n\t}\n\treturn 0;\n}\n\nstatic int __maybe_unused msdc_suspend(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct msdc_host *host = mmc_priv(mmc);\n\tint ret;\n\tu32 val;\n\n\tif (mmc->caps2 & MMC_CAP2_CQE) {\n\t\tret = cqhci_suspend(mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval = readl(host->base + MSDC_INT);\n\t\twritel(val, host->base + MSDC_INT);\n\t}\n\n\t \n\tif (sdio_irq_claimed(mmc) && host->pins_eint)\n\t\tpm_runtime_get_noresume(dev);\n\n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int __maybe_unused msdc_resume(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct msdc_host *host = mmc_priv(mmc);\n\n\tif (sdio_irq_claimed(mmc) && host->pins_eint)\n\t\tpm_runtime_put_noidle(dev);\n\n\treturn pm_runtime_force_resume(dev);\n}\n\nstatic const struct dev_pm_ops msdc_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(msdc_suspend, msdc_resume)\n\tSET_RUNTIME_PM_OPS(msdc_runtime_suspend, msdc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver mt_msdc_driver = {\n\t.probe = msdc_drv_probe,\n\t.remove_new = msdc_drv_remove,\n\t.driver = {\n\t\t.name = \"mtk-msdc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = msdc_of_ids,\n\t\t.pm = &msdc_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(mt_msdc_driver);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek SD/MMC Card Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}