{
  "module_name": "sdhci-of-at91.c",
  "hash_id": "734b513b7f27ca392954c88b944d5e3b4a17fae46831fa2f012b1316a32a6247",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-at91.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include \"sdhci-pltfm.h\"\n\n#define SDMMC_MC1R\t0x204\n#define\t\tSDMMC_MC1R_DDR\t\tBIT(3)\n#define\t\tSDMMC_MC1R_FCD\t\tBIT(7)\n#define SDMMC_CACR\t0x230\n#define\t\tSDMMC_CACR_CAPWREN\tBIT(0)\n#define\t\tSDMMC_CACR_KEY\t\t(0x46 << 8)\n#define SDMMC_CALCR\t0x240\n#define\t\tSDMMC_CALCR_EN\t\tBIT(0)\n#define\t\tSDMMC_CALCR_ALWYSON\tBIT(4)\n\n#define SDHCI_AT91_PRESET_COMMON_CONF\t0x400  \n\nstruct sdhci_at91_soc_data {\n\tconst struct sdhci_pltfm_data *pdata;\n\tbool baseclk_is_generated_internally;\n\tunsigned int divider_for_baseclk;\n};\n\nstruct sdhci_at91_priv {\n\tconst struct sdhci_at91_soc_data *soc_data;\n\tstruct clk *hclock;\n\tstruct clk *gck;\n\tstruct clk *mainck;\n\tbool restore_needed;\n\tbool cal_always_on;\n};\n\nstatic void sdhci_at91_set_force_card_detect(struct sdhci_host *host)\n{\n\tu8 mc1r;\n\n\tmc1r = readb(host->ioaddr + SDMMC_MC1R);\n\tmc1r |= SDMMC_MC1R_FCD;\n\twriteb(mc1r, host->ioaddr + SDMMC_MC1R);\n}\n\nstatic void sdhci_at91_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tu16 clk;\n\n\thost->mmc->actual_clock = 0;\n\n\t \n\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tclk &= SDHCI_CLOCK_INT_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\tif (clock == 0)\n\t\treturn;\n\n\tclk = sdhci_calc_clk(host, clock, &host->mmc->actual_clock);\n\n\tclk |= SDHCI_CLOCK_INT_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n\n\t \n\tif (read_poll_timeout(sdhci_readw, clk, (clk & SDHCI_CLOCK_INT_STABLE),\n\t\t\t      1000, 20000, false, host, SDHCI_CLOCK_CONTROL)) {\n\t\tpr_err(\"%s: Internal clock never stabilised.\\n\",\n\t\t       mmc_hostname(host->mmc));\n\t\treturn;\n\t}\n\n\tclk |= SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);\n}\n\nstatic void sdhci_at91_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t unsigned int timing)\n{\n\tu8 mc1r;\n\n\tif (timing == MMC_TIMING_MMC_DDR52) {\n\t\tmc1r = sdhci_readb(host, SDMMC_MC1R);\n\t\tmc1r |= SDMMC_MC1R_DDR;\n\t\tsdhci_writeb(host, mc1r, SDMMC_MC1R);\n\t}\n\tsdhci_set_uhs_signaling(host, timing);\n}\n\nstatic void sdhci_at91_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tunsigned int tmp;\n\n\tsdhci_reset(host, mask);\n\n\tif ((host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t    || mmc_gpio_get_cd(host->mmc) >= 0)\n\t\tsdhci_at91_set_force_card_detect(host);\n\n\tif (priv->cal_always_on && (mask & SDHCI_RESET_ALL)) {\n\t\tu32 calcr = sdhci_readl(host, SDMMC_CALCR);\n\n\t\tsdhci_writel(host, calcr | SDMMC_CALCR_ALWYSON | SDMMC_CALCR_EN,\n\t\t\t     SDMMC_CALCR);\n\n\t\tif (read_poll_timeout(sdhci_readl, tmp, !(tmp & SDMMC_CALCR_EN),\n\t\t\t\t      10, 20000, false, host, SDMMC_CALCR))\n\t\t\tdev_err(mmc_dev(host->mmc), \"Failed to calibrate\\n\");\n\t}\n}\n\nstatic const struct sdhci_ops sdhci_at91_sama5d2_ops = {\n\t.set_clock\t\t= sdhci_at91_set_clock,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t= sdhci_at91_reset,\n\t.set_uhs_signaling\t= sdhci_at91_set_uhs_signaling,\n\t.set_power\t\t= sdhci_set_power_and_bus_voltage,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_sama5d2_pdata = {\n\t.ops = &sdhci_at91_sama5d2_ops,\n};\n\nstatic const struct sdhci_at91_soc_data soc_data_sama5d2 = {\n\t.pdata = &sdhci_sama5d2_pdata,\n\t.baseclk_is_generated_internally = false,\n};\n\nstatic const struct sdhci_at91_soc_data soc_data_sam9x60 = {\n\t.pdata = &sdhci_sama5d2_pdata,\n\t.baseclk_is_generated_internally = true,\n\t.divider_for_baseclk = 2,\n};\n\nstatic const struct of_device_id sdhci_at91_dt_match[] = {\n\t{ .compatible = \"atmel,sama5d2-sdhci\", .data = &soc_data_sama5d2 },\n\t{ .compatible = \"microchip,sam9x60-sdhci\", .data = &soc_data_sam9x60 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sdhci_at91_dt_match);\n\nstatic int sdhci_at91_set_clks_presets(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tunsigned int\t\t\tcaps0, caps1;\n\tunsigned int\t\t\tclk_base, clk_mul;\n\tunsigned int\t\t\tgck_rate, clk_base_rate;\n\tunsigned int\t\t\tpreset_div;\n\n\tclk_prepare_enable(priv->hclock);\n\tcaps0 = readl(host->ioaddr + SDHCI_CAPABILITIES);\n\tcaps1 = readl(host->ioaddr + SDHCI_CAPABILITIES_1);\n\n\tgck_rate = clk_get_rate(priv->gck);\n\tif (priv->soc_data->baseclk_is_generated_internally)\n\t\tclk_base_rate = gck_rate / priv->soc_data->divider_for_baseclk;\n\telse\n\t\tclk_base_rate = clk_get_rate(priv->mainck);\n\n\tclk_base = clk_base_rate / 1000000;\n\tclk_mul = gck_rate / clk_base_rate - 1;\n\n\tcaps0 &= ~SDHCI_CLOCK_V3_BASE_MASK;\n\tcaps0 |= FIELD_PREP(SDHCI_CLOCK_V3_BASE_MASK, clk_base);\n\tcaps1 &= ~SDHCI_CLOCK_MUL_MASK;\n\tcaps1 |= FIELD_PREP(SDHCI_CLOCK_MUL_MASK, clk_mul);\n\t \n\twritel(SDMMC_CACR_KEY | SDMMC_CACR_CAPWREN, host->ioaddr + SDMMC_CACR);\n\twritel(caps0, host->ioaddr + SDHCI_CAPABILITIES);\n\twritel(caps1, host->ioaddr + SDHCI_CAPABILITIES_1);\n\t \n\twritel(0, host->ioaddr + SDMMC_CACR);\n\n\tdev_dbg(dev, \"update clk mul to %u as gck rate is %u Hz and clk base is %u Hz\\n\",\n\t\tclk_mul, gck_rate, clk_base_rate);\n\n\t \n\tpreset_div = DIV_ROUND_UP(gck_rate, 24000000) - 1;\n\twritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\n\t       host->ioaddr + SDHCI_PRESET_FOR_SDR12);\n\tpreset_div = DIV_ROUND_UP(gck_rate, 50000000) - 1;\n\twritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\n\t       host->ioaddr + SDHCI_PRESET_FOR_SDR25);\n\tpreset_div = DIV_ROUND_UP(gck_rate, 100000000) - 1;\n\twritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\n\t       host->ioaddr + SDHCI_PRESET_FOR_SDR50);\n\tpreset_div = DIV_ROUND_UP(gck_rate, 120000000) - 1;\n\twritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\n\t       host->ioaddr + SDHCI_PRESET_FOR_SDR104);\n\tpreset_div = DIV_ROUND_UP(gck_rate, 50000000) - 1;\n\twritew(SDHCI_AT91_PRESET_COMMON_CONF | preset_div,\n\t       host->ioaddr + SDHCI_PRESET_FOR_DDR50);\n\n\tclk_prepare_enable(priv->mainck);\n\tclk_prepare_enable(priv->gck);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_at91_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\n\tpriv->restore_needed = true;\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM\nstatic int sdhci_at91_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = sdhci_runtime_suspend_host(host);\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tclk_disable_unprepare(priv->gck);\n\tclk_disable_unprepare(priv->hclock);\n\tclk_disable_unprepare(priv->mainck);\n\n\treturn ret;\n}\n\nstatic int sdhci_at91_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (priv->restore_needed) {\n\t\tret = sdhci_at91_set_clks_presets(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tpriv->restore_needed = false;\n\t\tgoto out;\n\t}\n\n\tret = clk_prepare_enable(priv->mainck);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable mainck\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(priv->hclock);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable hclock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(priv->gck);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable gck\\n\");\n\t\treturn ret;\n\t}\n\nout:\n\treturn sdhci_runtime_resume_host(host, 0);\n}\n#endif  \n\nstatic const struct dev_pm_ops sdhci_at91_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_at91_suspend, pm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_at91_runtime_suspend,\n\t\t\t   sdhci_at91_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic int sdhci_at91_probe(struct platform_device *pdev)\n{\n\tconst struct sdhci_at91_soc_data\t*soc_data;\n\tstruct sdhci_host\t\t*host;\n\tstruct sdhci_pltfm_host\t\t*pltfm_host;\n\tstruct sdhci_at91_priv\t\t*priv;\n\tint\t\t\t\tret;\n\n\tsoc_data = of_device_get_match_data(&pdev->dev);\n\tif (!soc_data)\n\t\treturn -EINVAL;\n\n\thost = sdhci_pltfm_init(pdev, soc_data->pdata, sizeof(*priv));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\tpriv->soc_data = soc_data;\n\n\tpriv->mainck = devm_clk_get(&pdev->dev, \"baseclk\");\n\tif (IS_ERR(priv->mainck)) {\n\t\tif (soc_data->baseclk_is_generated_internally) {\n\t\t\tpriv->mainck = NULL;\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"failed to get baseclk\\n\");\n\t\t\tret = PTR_ERR(priv->mainck);\n\t\t\tgoto sdhci_pltfm_free;\n\t\t}\n\t}\n\n\tpriv->hclock = devm_clk_get(&pdev->dev, \"hclock\");\n\tif (IS_ERR(priv->hclock)) {\n\t\tdev_err(&pdev->dev, \"failed to get hclock\\n\");\n\t\tret = PTR_ERR(priv->hclock);\n\t\tgoto sdhci_pltfm_free;\n\t}\n\n\tpriv->gck = devm_clk_get(&pdev->dev, \"multclk\");\n\tif (IS_ERR(priv->gck)) {\n\t\tdev_err(&pdev->dev, \"failed to get multclk\\n\");\n\t\tret = PTR_ERR(priv->gck);\n\t\tgoto sdhci_pltfm_free;\n\t}\n\n\tret = sdhci_at91_set_clks_presets(&pdev->dev);\n\tif (ret)\n\t\tgoto sdhci_pltfm_free;\n\n\tpriv->restore_needed = false;\n\n\t \n\tpriv->cal_always_on =\n\t\tdevice_property_read_bool(&pdev->dev,\n\t\t\t\t\t  \"microchip,sdcal-inverted\");\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto clocks_disable_unprepare;\n\n\tsdhci_get_of_property(pdev);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\t \n\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto pm_runtime_disable;\n\n\t \n\tif (mmc_card_is_removable(host->mmc) &&\n\t    mmc_gpio_get_cd(host->mmc) < 0) {\n\t\thost->mmc->caps |= MMC_CAP_NEEDS_POLL;\n\t\thost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\t}\n\n\t \n\tif ((host->mmc->caps & MMC_CAP_NONREMOVABLE)\n\t    || mmc_gpio_get_cd(host->mmc) >= 0)\n\t\tsdhci_at91_set_force_card_detect(host);\n\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\npm_runtime_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\nclocks_disable_unprepare:\n\tclk_disable_unprepare(priv->gck);\n\tclk_disable_unprepare(priv->mainck);\n\tclk_disable_unprepare(priv->hclock);\nsdhci_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_at91_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host\t*host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host\t*pltfm_host = sdhci_priv(host);\n\tstruct sdhci_at91_priv\t*priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct clk *gck = priv->gck;\n\tstruct clk *hclock = priv->hclock;\n\tstruct clk *mainck = priv->mainck;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tsdhci_pltfm_remove(pdev);\n\n\tclk_disable_unprepare(gck);\n\tclk_disable_unprepare(hclock);\n\tclk_disable_unprepare(mainck);\n}\n\nstatic struct platform_driver sdhci_at91_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-at91\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_at91_dt_match,\n\t\t.pm\t= &sdhci_at91_dev_pm_ops,\n\t},\n\t.probe\t\t= sdhci_at91_probe,\n\t.remove_new\t= sdhci_at91_remove,\n};\n\nmodule_platform_driver(sdhci_at91_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for at91\");\nMODULE_AUTHOR(\"Ludovic Desroches <ludovic.desroches@atmel.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}