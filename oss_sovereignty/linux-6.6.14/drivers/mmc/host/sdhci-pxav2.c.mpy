{
  "module_name": "sdhci-pxav2.c",
  "hash_id": "a5c50299d7fbcf0b60c13c33377759b5485d1fa45f954e3b08a9ec364d0d2455",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pxav2.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/platform_data/pxa_sdhci.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/mmc.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"sdhci.h\"\n#include \"sdhci-pltfm.h\"\n\n#define SD_FIFO_PARAM\t\t0xe0\n#define DIS_PAD_SD_CLK_GATE\t0x0400  \n#define CLK_GATE_ON\t\t0x0200  \n#define CLK_GATE_CTL\t\t0x0100  \n#define CLK_GATE_SETTING_BITS\t(DIS_PAD_SD_CLK_GATE | \\\n\t\tCLK_GATE_ON | CLK_GATE_CTL)\n\n#define SD_CLOCK_BURST_SIZE_SETUP\t0xe6\n#define SDCLK_SEL_SHIFT\t\t8\n#define SDCLK_SEL_MASK\t\t0x3\n#define SDCLK_DELAY_SHIFT\t10\n#define SDCLK_DELAY_MASK\t0x3c\n\n#define SD_CE_ATA_2\t\t0xea\n#define MMC_CARD\t\t0x1000\n#define MMC_WIDTH\t\t0x0100\n\nstruct sdhci_pxav2_host {\n\tstruct mmc_request *sdio_mrq;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_default;\n\tstruct pinctrl_state *pins_cmd_gpio;\n};\n\nstatic void pxav2_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));\n\tstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\n\n\tsdhci_reset(host, mask);\n\n\tif (mask == SDHCI_RESET_ALL) {\n\t\tu16 tmp = 0;\n\n\t\t \n\t\tif (pdata && pdata->clk_delay_sel == 1) {\n\t\t\ttmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\n\n\t\t\ttmp &= ~(SDCLK_DELAY_MASK << SDCLK_DELAY_SHIFT);\n\t\t\ttmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)\n\t\t\t\t<< SDCLK_DELAY_SHIFT;\n\t\t\ttmp &= ~(SDCLK_SEL_MASK << SDCLK_SEL_SHIFT);\n\t\t\ttmp |= (1 & SDCLK_SEL_MASK) << SDCLK_SEL_SHIFT;\n\n\t\t\twritew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\n\t\t}\n\n\t\tif (pdata && (pdata->flags & PXA_FLAG_ENABLE_CLOCK_GATING)) {\n\t\t\ttmp = readw(host->ioaddr + SD_FIFO_PARAM);\n\t\t\ttmp &= ~CLK_GATE_SETTING_BITS;\n\t\t\twritew(tmp, host->ioaddr + SD_FIFO_PARAM);\n\t\t} else {\n\t\t\ttmp = readw(host->ioaddr + SD_FIFO_PARAM);\n\t\t\ttmp &= ~CLK_GATE_SETTING_BITS;\n\t\t\ttmp |= CLK_GATE_SETTING_BITS;\n\t\t\twritew(tmp, host->ioaddr + SD_FIFO_PARAM);\n\t\t}\n\t}\n}\n\nstatic u16 pxav1_readw(struct sdhci_host *host, int reg)\n{\n\t \n\tif (reg == SDHCI_HOST_VERSION)\n\t\treturn readl(host->ioaddr + SDHCI_HOST_VERSION - 2) >> 16;\n\n\treturn readw(host->ioaddr + reg);\n}\n\nstatic u32 pxav1_irq(struct sdhci_host *host, u32 intmask)\n{\n\tstruct sdhci_pxav2_host *pxav2_host = sdhci_pltfm_priv(sdhci_priv(host));\n\tstruct mmc_request *sdio_mrq;\n\n\tif (pxav2_host->sdio_mrq && (intmask & SDHCI_INT_CMD_MASK)) {\n\t\t \n\t\tsdhci_writel(host, intmask & SDHCI_INT_CMD_MASK, SDHCI_INT_STATUS);\n\t\tintmask &= ~SDHCI_INT_CMD_MASK;\n\n\t\t \n\t\tif (pxav2_host->pinctrl && pxav2_host->pins_default)\n\t\t\tpinctrl_select_state(pxav2_host->pinctrl, pxav2_host->pins_default);\n\n\t\tsdio_mrq = pxav2_host->sdio_mrq;\n\t\tpxav2_host->sdio_mrq = NULL;\n\t\tmmc_request_done(host->mmc, sdio_mrq);\n\t}\n\n\treturn intmask;\n}\n\nstatic void pxav1_request_done(struct sdhci_host *host, struct mmc_request *mrq)\n{\n\tu16 tmp;\n\tstruct sdhci_pxav2_host *pxav2_host;\n\n\t \n\tif (mrq->cmd && !mrq->cmd->error &&\n\t    (mrq->cmd->opcode == SD_IO_RW_DIRECT ||\n\t     mrq->cmd->opcode == SD_IO_RW_EXTENDED)) {\n\t\t \n\t\ttmp = readw(host->ioaddr + SDHCI_TIMEOUT_CONTROL);\n\t\ttmp |= 0x400;\n\t\twritew(tmp, host->ioaddr + SDHCI_TIMEOUT_CONTROL);\n\n\t\t \n\t\tpxav2_host = sdhci_pltfm_priv(sdhci_priv(host));\n\t\tpxav2_host->sdio_mrq = mrq;\n\n\t\t \n\t\tif (pxav2_host->pinctrl && pxav2_host->pins_cmd_gpio)\n\t\t\tpinctrl_select_state(pxav2_host->pinctrl, pxav2_host->pins_cmd_gpio);\n\n\t\tsdhci_writel(host, 0, SDHCI_ARGUMENT);\n\t\tsdhci_writew(host, 0, SDHCI_TRANSFER_MODE);\n\t\tsdhci_writew(host, SDHCI_MAKE_CMD(MMC_GO_IDLE_STATE, SDHCI_CMD_RESP_NONE),\n\t\t\t     SDHCI_COMMAND);\n\n\t\t \n\t\treturn;\n\t}\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void pxav2_mmc_set_bus_width(struct sdhci_host *host, int width)\n{\n\tu8 ctrl;\n\tu16 tmp;\n\n\tctrl = readb(host->ioaddr + SDHCI_HOST_CONTROL);\n\ttmp = readw(host->ioaddr + SD_CE_ATA_2);\n\tif (width == MMC_BUS_WIDTH_8) {\n\t\tctrl &= ~SDHCI_CTRL_4BITBUS;\n\t\ttmp |= MMC_CARD | MMC_WIDTH;\n\t} else {\n\t\ttmp &= ~(MMC_CARD | MMC_WIDTH);\n\t\tif (width == MMC_BUS_WIDTH_4)\n\t\t\tctrl |= SDHCI_CTRL_4BITBUS;\n\t\telse\n\t\t\tctrl &= ~SDHCI_CTRL_4BITBUS;\n\t}\n\twritew(tmp, host->ioaddr + SD_CE_ATA_2);\n\twriteb(ctrl, host->ioaddr + SDHCI_HOST_CONTROL);\n}\n\nstruct sdhci_pxa_variant {\n\tconst struct sdhci_ops *ops;\n\tunsigned int extra_quirks;\n};\n\nstatic const struct sdhci_ops pxav1_sdhci_ops = {\n\t.read_w        = pxav1_readw,\n\t.set_clock     = sdhci_set_clock,\n\t.irq           = pxav1_irq,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_bus_width = pxav2_mmc_set_bus_width,\n\t.reset         = pxav2_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.request_done  = pxav1_request_done,\n};\n\nstatic const struct sdhci_pxa_variant __maybe_unused pxav1_variant = {\n\t.ops = &pxav1_sdhci_ops,\n\t.extra_quirks = SDHCI_QUIRK_NO_BUSY_IRQ | SDHCI_QUIRK_32BIT_DMA_SIZE,\n};\n\nstatic const struct sdhci_ops pxav2_sdhci_ops = {\n\t.set_clock     = sdhci_set_clock,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_bus_width = pxav2_mmc_set_bus_width,\n\t.reset         = pxav2_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pxa_variant pxav2_variant = {\n\t.ops = &pxav2_sdhci_ops,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sdhci_pxav2_of_match[] = {\n\t{ .compatible = \"mrvl,pxav1-mmc\", .data = &pxav1_variant, },\n\t{ .compatible = \"mrvl,pxav2-mmc\", .data = &pxav2_variant, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdhci_pxav2_of_match);\n\nstatic struct sdhci_pxa_platdata *pxav2_get_mmc_pdata(struct device *dev)\n{\n\tstruct sdhci_pxa_platdata *pdata;\n\tstruct device_node *np = dev->of_node;\n\tu32 bus_width;\n\tu32 clk_delay_cycles;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tif (of_property_read_bool(np, \"non-removable\"))\n\t\tpdata->flags |= PXA_FLAG_CARD_PERMANENT;\n\n\tof_property_read_u32(np, \"bus-width\", &bus_width);\n\tif (bus_width == 8)\n\t\tpdata->flags |= PXA_FLAG_SD_8_BIT_CAPABLE_SLOT;\n\n\tof_property_read_u32(np, \"mrvl,clk-delay-cycles\", &clk_delay_cycles);\n\tif (clk_delay_cycles > 0) {\n\t\tpdata->clk_delay_sel = 1;\n\t\tpdata->clk_delay_cycles = clk_delay_cycles;\n\t}\n\n\treturn pdata;\n}\n#else\nstatic inline struct sdhci_pxa_platdata *pxav2_get_mmc_pdata(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int sdhci_pxav2_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\n\tstruct sdhci_pxav2_host *pxav2_host;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host = NULL;\n\tconst struct sdhci_pxa_variant *variant;\n\n\tint ret;\n\tstruct clk *clk, *clk_core;\n\n\thost = sdhci_pltfm_init(pdev, NULL, sizeof(*pxav2_host));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpxav2_host = sdhci_pltfm_priv(pltfm_host);\n\n\tclk = devm_clk_get_optional_enabled(dev, \"io\");\n\tif (!clk)\n\t\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err_probe(dev, ret, \"failed to get io clock\\n\");\n\t\tgoto free;\n\t}\n\tpltfm_host->clk = clk;\n\n\tclk_core = devm_clk_get_optional_enabled(dev, \"core\");\n\tif (IS_ERR(clk_core)) {\n\t\tret = PTR_ERR(clk_core);\n\t\tdev_err_probe(dev, ret, \"failed to enable core clock\\n\");\n\t\tgoto free;\n\t}\n\n\thost->quirks = SDHCI_QUIRK_BROKEN_ADMA\n\t\t| SDHCI_QUIRK_BROKEN_TIMEOUT_VAL\n\t\t| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;\n\n\tvariant = of_device_get_match_data(dev);\n\tif (variant)\n\t\tpdata = pxav2_get_mmc_pdata(dev);\n\telse\n\t\tvariant = &pxav2_variant;\n\n\tif (pdata) {\n\t\tif (pdata->flags & PXA_FLAG_CARD_PERMANENT) {\n\t\t\t \n\t\t\thost->quirks |= SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\t\t\thost->mmc->caps |= MMC_CAP_NONREMOVABLE;\n\t\t}\n\n\t\t \n\t\tif (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)\n\t\t\thost->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\n\t\tif (pdata->quirks)\n\t\t\thost->quirks |= pdata->quirks;\n\t\tif (pdata->host_caps)\n\t\t\thost->mmc->caps |= pdata->host_caps;\n\t\tif (pdata->pm_caps)\n\t\t\thost->mmc->pm_caps |= pdata->pm_caps;\n\t}\n\n\thost->quirks |= variant->extra_quirks;\n\thost->ops = variant->ops;\n\n\t \n\tpxav2_host->pinctrl = devm_pinctrl_get(dev);\n\tif (!IS_ERR(pxav2_host->pinctrl)) {\n\t\tpxav2_host->pins_cmd_gpio = pinctrl_lookup_state(pxav2_host->pinctrl,\n\t\t\t\t\t\t\t\t \"state_cmd_gpio\");\n\t\tif (IS_ERR(pxav2_host->pins_cmd_gpio))\n\t\t\tpxav2_host->pins_cmd_gpio = NULL;\n\t\tpxav2_host->pins_default = pinctrl_lookup_state(pxav2_host->pinctrl,\n\t\t\t\t\t\t\t\t\"default\");\n\t\tif (IS_ERR(pxav2_host->pins_default))\n\t\t\tpxav2_host->pins_default = NULL;\n\t} else {\n\t\tpxav2_host->pinctrl = NULL;\n\t}\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto free;\n\n\treturn 0;\n\nfree:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic struct platform_driver sdhci_pxav2_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-pxav2\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(sdhci_pxav2_of_match),\n\t\t.pm\t= &sdhci_pltfm_pmops,\n\t},\n\t.probe\t\t= sdhci_pxav2_probe,\n\t.remove_new\t= sdhci_pltfm_remove,\n};\n\nmodule_platform_driver(sdhci_pxav2_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for pxav2\");\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}