{
  "module_name": "davinci_mmc.c",
  "hash_id": "75752f79677264732b3885156af0cb935ff3dcea747810558b6a1f6bf07cca81",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/davinci_mmc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/cpufreq.h>\n#include <linux/mmc/host.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/mmc/mmc.h>\n#include <linux/of.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/interrupt.h>\n\n#include <linux/platform_data/mmc-davinci.h>\n\n \n#define DAVINCI_MMCCTL       0x00  \n#define DAVINCI_MMCCLK       0x04  \n#define DAVINCI_MMCST0       0x08  \n#define DAVINCI_MMCST1       0x0C  \n#define DAVINCI_MMCIM        0x10  \n#define DAVINCI_MMCTOR       0x14  \n#define DAVINCI_MMCTOD       0x18  \n#define DAVINCI_MMCBLEN      0x1C  \n#define DAVINCI_MMCNBLK      0x20  \n#define DAVINCI_MMCNBLC      0x24  \n#define DAVINCI_MMCDRR       0x28  \n#define DAVINCI_MMCDXR       0x2C  \n#define DAVINCI_MMCCMD       0x30  \n#define DAVINCI_MMCARGHL     0x34  \n#define DAVINCI_MMCRSP01     0x38  \n#define DAVINCI_MMCRSP23     0x3C  \n#define DAVINCI_MMCRSP45     0x40  \n#define DAVINCI_MMCRSP67     0x44  \n#define DAVINCI_MMCDRSP      0x48  \n#define DAVINCI_MMCETOK      0x4C\n#define DAVINCI_MMCCIDX      0x50  \n#define DAVINCI_MMCCKC       0x54\n#define DAVINCI_MMCTORC      0x58\n#define DAVINCI_MMCTODC      0x5C\n#define DAVINCI_MMCBLNC      0x60\n#define DAVINCI_SDIOCTL      0x64\n#define DAVINCI_SDIOST0      0x68\n#define DAVINCI_SDIOIEN      0x6C\n#define DAVINCI_SDIOIST      0x70\n#define DAVINCI_MMCFIFOCTL   0x74  \n\n \n#define MMCCTL_DATRST         (1 << 0)\n#define MMCCTL_CMDRST         (1 << 1)\n#define MMCCTL_WIDTH_8_BIT    (1 << 8)\n#define MMCCTL_WIDTH_4_BIT    (1 << 2)\n#define MMCCTL_DATEG_DISABLED (0 << 6)\n#define MMCCTL_DATEG_RISING   (1 << 6)\n#define MMCCTL_DATEG_FALLING  (2 << 6)\n#define MMCCTL_DATEG_BOTH     (3 << 6)\n#define MMCCTL_PERMDR_LE      (0 << 9)\n#define MMCCTL_PERMDR_BE      (1 << 9)\n#define MMCCTL_PERMDX_LE      (0 << 10)\n#define MMCCTL_PERMDX_BE      (1 << 10)\n\n \n#define MMCCLK_CLKEN          (1 << 8)\n#define MMCCLK_CLKRT_MASK     (0xFF << 0)\n\n \n#define MMCST0_DATDNE         BIT(0)\t \n#define MMCST0_BSYDNE         BIT(1)\t \n#define MMCST0_RSPDNE         BIT(2)\t \n#define MMCST0_TOUTRD         BIT(3)\t \n#define MMCST0_TOUTRS         BIT(4)\t \n#define MMCST0_CRCWR          BIT(5)\t \n#define MMCST0_CRCRD          BIT(6)\t \n#define MMCST0_CRCRS          BIT(7)\t \n#define MMCST0_DXRDY          BIT(9)\t \n#define MMCST0_DRRDY          BIT(10)\t \n#define MMCST0_DATED          BIT(11)\t \n#define MMCST0_TRNDNE         BIT(12)\t \n\n \n#define MMCST1_BUSY           (1 << 0)\n\n \n#define MMCCMD_CMD_MASK       (0x3F << 0)\n#define MMCCMD_PPLEN          (1 << 7)\n#define MMCCMD_BSYEXP         (1 << 8)\n#define MMCCMD_RSPFMT_MASK    (3 << 9)\n#define MMCCMD_RSPFMT_NONE    (0 << 9)\n#define MMCCMD_RSPFMT_R1456   (1 << 9)\n#define MMCCMD_RSPFMT_R2      (2 << 9)\n#define MMCCMD_RSPFMT_R3      (3 << 9)\n#define MMCCMD_DTRW           (1 << 11)\n#define MMCCMD_STRMTP         (1 << 12)\n#define MMCCMD_WDATX          (1 << 13)\n#define MMCCMD_INITCK         (1 << 14)\n#define MMCCMD_DCLR           (1 << 15)\n#define MMCCMD_DMATRIG        (1 << 16)\n\n \n#define MMCFIFOCTL_FIFORST    (1 << 0)\n#define MMCFIFOCTL_FIFODIR_WR (1 << 1)\n#define MMCFIFOCTL_FIFODIR_RD (0 << 1)\n#define MMCFIFOCTL_FIFOLEV    (1 << 2)  \n#define MMCFIFOCTL_ACCWD_4    (0 << 3)  \n#define MMCFIFOCTL_ACCWD_3    (1 << 3)  \n#define MMCFIFOCTL_ACCWD_2    (2 << 3)  \n#define MMCFIFOCTL_ACCWD_1    (3 << 3)  \n\n \n#define SDIOST0_DAT1_HI       BIT(0)\n\n \n#define SDIOIEN_IOINTEN       BIT(0)\n\n \n#define SDIOIST_IOINT         BIT(0)\n\n \n#define MMCSD_INIT_CLOCK\t\t200000\n\n \n#define MAX_CCNT\t((1 << 16) - 1)\n\n#define MAX_NR_SG\t16\n\nstatic unsigned rw_threshold = 32;\nmodule_param(rw_threshold, uint, S_IRUGO);\nMODULE_PARM_DESC(rw_threshold,\n\t\t\"Read/Write threshold. Default = 32\");\n\nstatic unsigned poll_threshold = 128;\nmodule_param(poll_threshold, uint, S_IRUGO);\nMODULE_PARM_DESC(poll_threshold,\n\t\t \"Polling transaction size threshold. Default = 128\");\n\nstatic unsigned poll_loopcount = 32;\nmodule_param(poll_loopcount, uint, S_IRUGO);\nMODULE_PARM_DESC(poll_loopcount,\n\t\t \"Maximum polling loop count. Default = 32\");\n\nstatic unsigned use_dma = 1;\nmodule_param(use_dma, uint, 0);\nMODULE_PARM_DESC(use_dma, \"Whether to use DMA or not. Default = 1\");\n\nstruct mmc_davinci_host {\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\tstruct mmc_host *mmc;\n\tstruct clk *clk;\n\tunsigned int mmc_input_clk;\n\tvoid __iomem *base;\n\tstruct resource *mem_res;\n\tint mmc_irq, sdio_irq;\n\tunsigned char bus_mode;\n\n#define DAVINCI_MMC_DATADIR_NONE\t0\n#define DAVINCI_MMC_DATADIR_READ\t1\n#define DAVINCI_MMC_DATADIR_WRITE\t2\n\tunsigned char data_dir;\n\n\t \n\tu8 *buffer;\n\tu32 buffer_bytes_left;\n\tu32 bytes_left;\n\n\tstruct dma_chan *dma_tx;\n\tstruct dma_chan *dma_rx;\n\tbool use_dma;\n\tbool do_dma;\n\tbool sdio_int;\n\tbool active_request;\n\n\t \n\tunsigned int\t\tsg_len;\n\tstruct scatterlist *sg;\n\n\t \n\tu8 version;\n\t \n\tunsigned ns_in_one_cycle;\n\t \n\tu8 nr_sg;\n#ifdef CONFIG_CPU_FREQ\n\tstruct notifier_block\tfreq_transition;\n#endif\n};\n\nstatic irqreturn_t mmc_davinci_irq(int irq, void *dev_id);\n\n \nstatic void mmc_davinci_sg_to_buf(struct mmc_davinci_host *host)\n{\n\thost->buffer_bytes_left = sg_dma_len(host->sg);\n\thost->buffer = sg_virt(host->sg);\n\tif (host->buffer_bytes_left > host->bytes_left)\n\t\thost->buffer_bytes_left = host->bytes_left;\n}\n\nstatic void davinci_fifo_data_trans(struct mmc_davinci_host *host,\n\t\t\t\t\tunsigned int n)\n{\n\tu8 *p;\n\tunsigned int i;\n\n\tif (host->buffer_bytes_left == 0) {\n\t\thost->sg = sg_next(host->data->sg);\n\t\tmmc_davinci_sg_to_buf(host);\n\t}\n\n\tp = host->buffer;\n\tif (n > host->buffer_bytes_left)\n\t\tn = host->buffer_bytes_left;\n\thost->buffer_bytes_left -= n;\n\thost->bytes_left -= n;\n\n\t \n\tif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\n\t\tfor (i = 0; i < (n >> 2); i++) {\n\t\t\twritel(*((u32 *)p), host->base + DAVINCI_MMCDXR);\n\t\t\tp = p + 4;\n\t\t}\n\t\tif (n & 3) {\n\t\t\tiowrite8_rep(host->base + DAVINCI_MMCDXR, p, (n & 3));\n\t\t\tp = p + (n & 3);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < (n >> 2); i++) {\n\t\t\t*((u32 *)p) = readl(host->base + DAVINCI_MMCDRR);\n\t\t\tp  = p + 4;\n\t\t}\n\t\tif (n & 3) {\n\t\t\tioread8_rep(host->base + DAVINCI_MMCDRR, p, (n & 3));\n\t\t\tp = p + (n & 3);\n\t\t}\n\t}\n\thost->buffer = p;\n}\n\nstatic void mmc_davinci_start_command(struct mmc_davinci_host *host,\n\t\tstruct mmc_command *cmd)\n{\n\tu32 cmd_reg = 0;\n\tu32 im_val;\n\n\tdev_dbg(mmc_dev(host->mmc), \"CMD%d, arg 0x%08x%s\\n\",\n\t\tcmd->opcode, cmd->arg,\n\t\t({ char *s;\n\t\tswitch (mmc_resp_type(cmd)) {\n\t\tcase MMC_RSP_R1:\n\t\t\ts = \", R1/R5/R6/R7 response\";\n\t\t\tbreak;\n\t\tcase MMC_RSP_R1B:\n\t\t\ts = \", R1b response\";\n\t\t\tbreak;\n\t\tcase MMC_RSP_R2:\n\t\t\ts = \", R2 response\";\n\t\t\tbreak;\n\t\tcase MMC_RSP_R3:\n\t\t\ts = \", R3/R4 response\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ts = \", (R? response)\";\n\t\t\tbreak;\n\t\t} s; }));\n\thost->cmd = cmd;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_R1B:\n\t\t \n\t\tcmd_reg |= MMCCMD_BSYEXP;\n\t\tfallthrough;\n\tcase MMC_RSP_R1:\t\t \n\t\tcmd_reg |= MMCCMD_RSPFMT_R1456;\n\t\tbreak;\n\tcase MMC_RSP_R2:\t\t \n\t\tcmd_reg |= MMCCMD_RSPFMT_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\t\t \n\t\tcmd_reg |= MMCCMD_RSPFMT_R3;\n\t\tbreak;\n\tdefault:\n\t\tcmd_reg |= MMCCMD_RSPFMT_NONE;\n\t\tdev_dbg(mmc_dev(host->mmc), \"unknown resp_type %04x\\n\",\n\t\t\tmmc_resp_type(cmd));\n\t\tbreak;\n\t}\n\n\t \n\tcmd_reg |= cmd->opcode;\n\n\t \n\tif (host->do_dma)\n\t\tcmd_reg |= MMCCMD_DMATRIG;\n\n\tif (host->version == MMC_CTLR_VERSION_2 && host->data != NULL &&\n\t\t\thost->data_dir == DAVINCI_MMC_DATADIR_READ)\n\t\tcmd_reg |= MMCCMD_DMATRIG;\n\n\t \n\tif (cmd->data)\n\t\tcmd_reg |= MMCCMD_WDATX;\n\n\t \n\tif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE)\n\t\tcmd_reg |= MMCCMD_DTRW;\n\n\tif (host->bus_mode == MMC_BUSMODE_PUSHPULL)\n\t\tcmd_reg |= MMCCMD_PPLEN;\n\n\t \n\twritel(0x1FFF, host->base + DAVINCI_MMCTOR);\n\n\t \n\tim_val =  MMCST0_RSPDNE | MMCST0_CRCRS | MMCST0_TOUTRS;\n\tif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\n\t\tim_val |= MMCST0_DATDNE | MMCST0_CRCWR;\n\n\t\tif (!host->do_dma)\n\t\t\tim_val |= MMCST0_DXRDY;\n\t} else if (host->data_dir == DAVINCI_MMC_DATADIR_READ) {\n\t\tim_val |= MMCST0_DATDNE | MMCST0_CRCRD | MMCST0_TOUTRD;\n\n\t\tif (!host->do_dma)\n\t\t\tim_val |= MMCST0_DRRDY;\n\t}\n\n\t \n\tif (!host->do_dma && (host->data_dir == DAVINCI_MMC_DATADIR_WRITE))\n\t\tdavinci_fifo_data_trans(host, rw_threshold);\n\n\twritel(cmd->arg, host->base + DAVINCI_MMCARGHL);\n\twritel(cmd_reg,  host->base + DAVINCI_MMCCMD);\n\n\thost->active_request = true;\n\n\tif (!host->do_dma && host->bytes_left <= poll_threshold) {\n\t\tu32 count = poll_loopcount;\n\n\t\twhile (host->active_request && count--) {\n\t\t\tmmc_davinci_irq(0, host);\n\t\t\tcpu_relax();\n\t\t}\n\t}\n\n\tif (host->active_request)\n\t\twritel(im_val, host->base + DAVINCI_MMCIM);\n}\n\n \n\n \n\nstatic void davinci_abort_dma(struct mmc_davinci_host *host)\n{\n\tstruct dma_chan *sync_dev;\n\n\tif (host->data_dir == DAVINCI_MMC_DATADIR_READ)\n\t\tsync_dev = host->dma_rx;\n\telse\n\t\tsync_dev = host->dma_tx;\n\n\tdmaengine_terminate_all(sync_dev);\n}\n\nstatic int mmc_davinci_send_dma_request(struct mmc_davinci_host *host,\n\t\tstruct mmc_data *data)\n{\n\tstruct dma_chan *chan;\n\tstruct dma_async_tx_descriptor *desc;\n\tint ret = 0;\n\n\tif (host->data_dir == DAVINCI_MMC_DATADIR_WRITE) {\n\t\tstruct dma_slave_config dma_tx_conf = {\n\t\t\t.direction = DMA_MEM_TO_DEV,\n\t\t\t.dst_addr = host->mem_res->start + DAVINCI_MMCDXR,\n\t\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t\t.dst_maxburst =\n\t\t\t\trw_threshold / DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t};\n\t\tchan = host->dma_tx;\n\t\tdmaengine_slave_config(host->dma_tx, &dma_tx_conf);\n\n\t\tdesc = dmaengine_prep_slave_sg(host->dma_tx,\n\t\t\t\tdata->sg,\n\t\t\t\thost->sg_len,\n\t\t\t\tDMA_MEM_TO_DEV,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc) {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"failed to allocate DMA TX descriptor\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t} else {\n\t\tstruct dma_slave_config dma_rx_conf = {\n\t\t\t.direction = DMA_DEV_TO_MEM,\n\t\t\t.src_addr = host->mem_res->start + DAVINCI_MMCDRR,\n\t\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t\t.src_maxburst =\n\t\t\t\trw_threshold / DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t};\n\t\tchan = host->dma_rx;\n\t\tdmaengine_slave_config(host->dma_rx, &dma_rx_conf);\n\n\t\tdesc = dmaengine_prep_slave_sg(host->dma_rx,\n\t\t\t\tdata->sg,\n\t\t\t\thost->sg_len,\n\t\t\t\tDMA_DEV_TO_MEM,\n\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t\tif (!desc) {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"failed to allocate DMA RX descriptor\");\n\t\t\tret = -1;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(chan);\n\nout:\n\treturn ret;\n}\n\nstatic int mmc_davinci_start_dma_transfer(struct mmc_davinci_host *host,\n\t\tstruct mmc_data *data)\n{\n\tint i;\n\tint mask = rw_threshold - 1;\n\tint ret = 0;\n\n\thost->sg_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\t\t  mmc_get_dma_dir(data));\n\n\t \n\tfor (i = 0; i < host->sg_len; i++) {\n\t\tif (sg_dma_len(data->sg + i) & mask) {\n\t\t\tdma_unmap_sg(mmc_dev(host->mmc),\n\t\t\t\t     data->sg, data->sg_len,\n\t\t\t\t     mmc_get_dma_dir(data));\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\thost->do_dma = 1;\n\tret = mmc_davinci_send_dma_request(host, data);\n\n\treturn ret;\n}\n\nstatic void davinci_release_dma_channels(struct mmc_davinci_host *host)\n{\n\tif (!host->use_dma)\n\t\treturn;\n\n\tdma_release_channel(host->dma_tx);\n\tdma_release_channel(host->dma_rx);\n}\n\nstatic int davinci_acquire_dma_channels(struct mmc_davinci_host *host)\n{\n\thost->dma_tx = dma_request_chan(mmc_dev(host->mmc), \"tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\tdev_err(mmc_dev(host->mmc), \"Can't get dma_tx channel\\n\");\n\t\treturn PTR_ERR(host->dma_tx);\n\t}\n\n\thost->dma_rx = dma_request_chan(mmc_dev(host->mmc), \"rx\");\n\tif (IS_ERR(host->dma_rx)) {\n\t\tdev_err(mmc_dev(host->mmc), \"Can't get dma_rx channel\\n\");\n\t\tdma_release_channel(host->dma_tx);\n\t\treturn PTR_ERR(host->dma_rx);\n\t}\n\n\treturn 0;\n}\n\n \n\nstatic void\nmmc_davinci_prepare_data(struct mmc_davinci_host *host, struct mmc_request *req)\n{\n\tint fifo_lev = (rw_threshold == 32) ? MMCFIFOCTL_FIFOLEV : 0;\n\tint timeout;\n\tstruct mmc_data *data = req->data;\n\n\tif (host->version == MMC_CTLR_VERSION_2)\n\t\tfifo_lev = (rw_threshold == 64) ? MMCFIFOCTL_FIFOLEV : 0;\n\n\thost->data = data;\n\tif (data == NULL) {\n\t\thost->data_dir = DAVINCI_MMC_DATADIR_NONE;\n\t\twritel(0, host->base + DAVINCI_MMCBLEN);\n\t\twritel(0, host->base + DAVINCI_MMCNBLK);\n\t\treturn;\n\t}\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s, %d blocks of %d bytes\\n\",\n\t\t(data->flags & MMC_DATA_WRITE) ? \"write\" : \"read\",\n\t\tdata->blocks, data->blksz);\n\tdev_dbg(mmc_dev(host->mmc), \"  DTO %d cycles + %d ns\\n\",\n\t\tdata->timeout_clks, data->timeout_ns);\n\ttimeout = data->timeout_clks +\n\t\t(data->timeout_ns / host->ns_in_one_cycle);\n\tif (timeout > 0xffff)\n\t\ttimeout = 0xffff;\n\n\twritel(timeout, host->base + DAVINCI_MMCTOD);\n\twritel(data->blocks, host->base + DAVINCI_MMCNBLK);\n\twritel(data->blksz, host->base + DAVINCI_MMCBLEN);\n\n\t \n\tif (data->flags & MMC_DATA_WRITE) {\n\t\thost->data_dir = DAVINCI_MMC_DATADIR_WRITE;\n\t\twritel(fifo_lev | MMCFIFOCTL_FIFODIR_WR | MMCFIFOCTL_FIFORST,\n\t\t\thost->base + DAVINCI_MMCFIFOCTL);\n\t\twritel(fifo_lev | MMCFIFOCTL_FIFODIR_WR,\n\t\t\thost->base + DAVINCI_MMCFIFOCTL);\n\t} else {\n\t\thost->data_dir = DAVINCI_MMC_DATADIR_READ;\n\t\twritel(fifo_lev | MMCFIFOCTL_FIFODIR_RD | MMCFIFOCTL_FIFORST,\n\t\t\thost->base + DAVINCI_MMCFIFOCTL);\n\t\twritel(fifo_lev | MMCFIFOCTL_FIFODIR_RD,\n\t\t\thost->base + DAVINCI_MMCFIFOCTL);\n\t}\n\n\thost->buffer = NULL;\n\thost->bytes_left = data->blocks * data->blksz;\n\n\t \n\tif (host->use_dma && (host->bytes_left & (rw_threshold - 1)) == 0\n\t\t\t&& mmc_davinci_start_dma_transfer(host, data) == 0) {\n\t\t \n\t\thost->bytes_left = 0;\n\t} else {\n\t\t \n\t\thost->sg_len = data->sg_len;\n\t\thost->sg = host->data->sg;\n\t\tmmc_davinci_sg_to_buf(host);\n\t}\n}\n\nstatic void mmc_davinci_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct mmc_davinci_host *host = mmc_priv(mmc);\n\tunsigned long timeout = jiffies + msecs_to_jiffies(900);\n\tu32 mmcst1 = 0;\n\n\t \n\twhile (time_before(jiffies, timeout)) {\n\t\tmmcst1  = readl(host->base + DAVINCI_MMCST1);\n\t\tif (!(mmcst1 & MMCST1_BUSY))\n\t\t\tbreak;\n\t\tcpu_relax();\n\t}\n\tif (mmcst1 & MMCST1_BUSY) {\n\t\tdev_err(mmc_dev(host->mmc), \"still BUSY? bad ... \\n\");\n\t\treq->cmd->error = -ETIMEDOUT;\n\t\tmmc_request_done(mmc, req);\n\t\treturn;\n\t}\n\n\thost->do_dma = 0;\n\tmmc_davinci_prepare_data(host, req);\n\tmmc_davinci_start_command(host, req->cmd);\n}\n\nstatic unsigned int calculate_freq_for_card(struct mmc_davinci_host *host,\n\tunsigned int mmc_req_freq)\n{\n\tunsigned int mmc_freq = 0, mmc_pclk = 0, mmc_push_pull_divisor = 0;\n\n\tmmc_pclk = host->mmc_input_clk;\n\tif (mmc_req_freq && mmc_pclk > (2 * mmc_req_freq))\n\t\tmmc_push_pull_divisor = ((unsigned int)mmc_pclk\n\t\t\t\t/ (2 * mmc_req_freq)) - 1;\n\telse\n\t\tmmc_push_pull_divisor = 0;\n\n\tmmc_freq = (unsigned int)mmc_pclk\n\t\t/ (2 * (mmc_push_pull_divisor + 1));\n\n\tif (mmc_freq > mmc_req_freq)\n\t\tmmc_push_pull_divisor = mmc_push_pull_divisor + 1;\n\t \n\tif (mmc_req_freq <= 400000)\n\t\thost->ns_in_one_cycle = (1000000) / (((mmc_pclk\n\t\t\t\t/ (2 * (mmc_push_pull_divisor + 1)))/1000));\n\telse\n\t\thost->ns_in_one_cycle = (1000000) / (((mmc_pclk\n\t\t\t\t/ (2 * (mmc_push_pull_divisor + 1)))/1000000));\n\n\treturn mmc_push_pull_divisor;\n}\n\nstatic void calculate_clk_divider(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tunsigned int open_drain_freq = 0, mmc_pclk = 0;\n\tunsigned int mmc_push_pull_freq = 0;\n\tstruct mmc_davinci_host *host = mmc_priv(mmc);\n\n\tif (ios->bus_mode == MMC_BUSMODE_OPENDRAIN) {\n\t\tu32 temp;\n\n\t\t \n\t\topen_drain_freq = ((unsigned int)mmc_pclk\n\t\t\t\t/ (2 * MMCSD_INIT_CLOCK)) - 1;\n\n\t\tif (open_drain_freq > 0xFF)\n\t\t\topen_drain_freq = 0xFF;\n\n\t\ttemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;\n\t\ttemp |= open_drain_freq;\n\t\twritel(temp, host->base + DAVINCI_MMCCLK);\n\n\t\t \n\t\thost->ns_in_one_cycle = (1000000) / (MMCSD_INIT_CLOCK/1000);\n\t} else {\n\t\tu32 temp;\n\t\tmmc_push_pull_freq = calculate_freq_for_card(host, ios->clock);\n\n\t\tif (mmc_push_pull_freq > 0xFF)\n\t\t\tmmc_push_pull_freq = 0xFF;\n\n\t\ttemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKEN;\n\t\twritel(temp, host->base + DAVINCI_MMCCLK);\n\n\t\tudelay(10);\n\n\t\ttemp = readl(host->base + DAVINCI_MMCCLK) & ~MMCCLK_CLKRT_MASK;\n\t\ttemp |= mmc_push_pull_freq;\n\t\twritel(temp, host->base + DAVINCI_MMCCLK);\n\n\t\twritel(temp | MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);\n\n\t\tudelay(10);\n\t}\n}\n\nstatic void mmc_davinci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mmc_davinci_host *host = mmc_priv(mmc);\n\tstruct platform_device *pdev = to_platform_device(mmc->parent);\n\tstruct davinci_mmc_config *config = pdev->dev.platform_data;\n\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"clock %dHz busmode %d powermode %d Vdd %04x\\n\",\n\t\tios->clock, ios->bus_mode, ios->power_mode,\n\t\tios->vdd);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tif (config && config->set_power)\n\t\t\tconfig->set_power(pdev->id, false);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tif (config && config->set_power)\n\t\t\tconfig->set_power(pdev->id, true);\n\t\tbreak;\n\t}\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tdev_dbg(mmc_dev(host->mmc), \"Enabling 8 bit mode\\n\");\n\t\twritel((readl(host->base + DAVINCI_MMCCTL) &\n\t\t\t~MMCCTL_WIDTH_4_BIT) | MMCCTL_WIDTH_8_BIT,\n\t\t\thost->base + DAVINCI_MMCCTL);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tdev_dbg(mmc_dev(host->mmc), \"Enabling 4 bit mode\\n\");\n\t\tif (host->version == MMC_CTLR_VERSION_2)\n\t\t\twritel((readl(host->base + DAVINCI_MMCCTL) &\n\t\t\t\t~MMCCTL_WIDTH_8_BIT) | MMCCTL_WIDTH_4_BIT,\n\t\t\t\thost->base + DAVINCI_MMCCTL);\n\t\telse\n\t\t\twritel(readl(host->base + DAVINCI_MMCCTL) |\n\t\t\t\tMMCCTL_WIDTH_4_BIT,\n\t\t\t\thost->base + DAVINCI_MMCCTL);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_1:\n\t\tdev_dbg(mmc_dev(host->mmc), \"Enabling 1 bit mode\\n\");\n\t\tif (host->version == MMC_CTLR_VERSION_2)\n\t\t\twritel(readl(host->base + DAVINCI_MMCCTL) &\n\t\t\t\t~(MMCCTL_WIDTH_8_BIT | MMCCTL_WIDTH_4_BIT),\n\t\t\t\thost->base + DAVINCI_MMCCTL);\n\t\telse\n\t\t\twritel(readl(host->base + DAVINCI_MMCCTL) &\n\t\t\t\t~MMCCTL_WIDTH_4_BIT,\n\t\t\t\thost->base + DAVINCI_MMCCTL);\n\t\tbreak;\n\t}\n\n\tcalculate_clk_divider(mmc, ios);\n\n\thost->bus_mode = ios->bus_mode;\n\tif (ios->power_mode == MMC_POWER_UP) {\n\t\tunsigned long timeout = jiffies + msecs_to_jiffies(50);\n\t\tbool lose = true;\n\n\t\t \n\t\twritel(0, host->base + DAVINCI_MMCARGHL);\n\t\twritel(MMCCMD_INITCK, host->base + DAVINCI_MMCCMD);\n\t\twhile (time_before(jiffies, timeout)) {\n\t\t\tu32 tmp = readl(host->base + DAVINCI_MMCST0);\n\n\t\t\tif (tmp & MMCST0_RSPDNE) {\n\t\t\t\tlose = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcpu_relax();\n\t\t}\n\t\tif (lose)\n\t\t\tdev_warn(mmc_dev(host->mmc), \"powerup timeout\\n\");\n\t}\n\n\t \n}\n\nstatic void\nmmc_davinci_xfer_done(struct mmc_davinci_host *host, struct mmc_data *data)\n{\n\thost->data = NULL;\n\n\tif (host->mmc->caps & MMC_CAP_SDIO_IRQ) {\n\t\t \n\t\tif (host->sdio_int && !(readl(host->base + DAVINCI_SDIOST0) &\n\t\t\t\t\tSDIOST0_DAT1_HI)) {\n\t\t\twritel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\n\t\t\tmmc_signal_sdio_irq(host->mmc);\n\t\t}\n\t}\n\n\tif (host->do_dma) {\n\t\tdavinci_abort_dma(host);\n\n\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t\thost->do_dma = false;\n\t}\n\thost->data_dir = DAVINCI_MMC_DATADIR_NONE;\n\n\tif (!data->stop || (host->cmd && host->cmd->error)) {\n\t\tmmc_request_done(host->mmc, data->mrq);\n\t\twritel(0, host->base + DAVINCI_MMCIM);\n\t\thost->active_request = false;\n\t} else\n\t\tmmc_davinci_start_command(host, data->stop);\n}\n\nstatic void mmc_davinci_cmd_done(struct mmc_davinci_host *host,\n\t\t\t\t struct mmc_command *cmd)\n{\n\thost->cmd = NULL;\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\t \n\t\t\tcmd->resp[3] = readl(host->base + DAVINCI_MMCRSP01);\n\t\t\tcmd->resp[2] = readl(host->base + DAVINCI_MMCRSP23);\n\t\t\tcmd->resp[1] = readl(host->base + DAVINCI_MMCRSP45);\n\t\t\tcmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);\n\t\t} else {\n\t\t\t \n\t\t\tcmd->resp[0] = readl(host->base + DAVINCI_MMCRSP67);\n\t\t}\n\t}\n\n\tif (host->data == NULL || cmd->error) {\n\t\tif (cmd->error == -ETIMEDOUT)\n\t\t\tcmd->mrq->cmd->retries = 0;\n\t\tmmc_request_done(host->mmc, cmd->mrq);\n\t\twritel(0, host->base + DAVINCI_MMCIM);\n\t\thost->active_request = false;\n\t}\n}\n\nstatic inline void mmc_davinci_reset_ctrl(struct mmc_davinci_host *host,\n\t\t\t\t\t\t\t\tint val)\n{\n\tu32 temp;\n\n\ttemp = readl(host->base + DAVINCI_MMCCTL);\n\tif (val)\t \n\t\ttemp |= MMCCTL_CMDRST | MMCCTL_DATRST;\n\telse\t\t \n\t\ttemp &= ~(MMCCTL_CMDRST | MMCCTL_DATRST);\n\n\twritel(temp, host->base + DAVINCI_MMCCTL);\n\tudelay(10);\n}\n\nstatic void\ndavinci_abort_data(struct mmc_davinci_host *host, struct mmc_data *data)\n{\n\tmmc_davinci_reset_ctrl(host, 1);\n\tmmc_davinci_reset_ctrl(host, 0);\n}\n\nstatic irqreturn_t mmc_davinci_sdio_irq(int irq, void *dev_id)\n{\n\tstruct mmc_davinci_host *host = dev_id;\n\tunsigned int status;\n\n\tstatus = readl(host->base + DAVINCI_SDIOIST);\n\tif (status & SDIOIST_IOINT) {\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"SDIO interrupt status %x\\n\", status);\n\t\twritel(status | SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\n\t\tmmc_signal_sdio_irq(host->mmc);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mmc_davinci_irq(int irq, void *dev_id)\n{\n\tstruct mmc_davinci_host *host = (struct mmc_davinci_host *)dev_id;\n\tunsigned int status, qstatus;\n\tint end_command = 0;\n\tint end_transfer = 0;\n\tstruct mmc_data *data = host->data;\n\n\tif (host->cmd == NULL && host->data == NULL) {\n\t\tstatus = readl(host->base + DAVINCI_MMCST0);\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"Spurious interrupt 0x%04x\\n\", status);\n\t\t \n\t\twritel(0, host->base + DAVINCI_MMCIM);\n\t\treturn IRQ_NONE;\n\t}\n\n\tstatus = readl(host->base + DAVINCI_MMCST0);\n\tqstatus = status;\n\n\t \n\tif (host->bytes_left && (status & (MMCST0_DXRDY | MMCST0_DRRDY))) {\n\t\tunsigned long im_val;\n\n\t\t \n\t\tim_val = readl(host->base + DAVINCI_MMCIM);\n\t\twritel(0, host->base + DAVINCI_MMCIM);\n\n\t\tdo {\n\t\t\tdavinci_fifo_data_trans(host, rw_threshold);\n\t\t\tstatus = readl(host->base + DAVINCI_MMCST0);\n\t\t\tqstatus |= status;\n\t\t} while (host->bytes_left &&\n\t\t\t (status & (MMCST0_DXRDY | MMCST0_DRRDY)));\n\n\t\t \n\t\twritel(im_val, host->base + DAVINCI_MMCIM);\n\t}\n\n\tif (qstatus & MMCST0_DATDNE) {\n\t\t \n\t\tif (data != NULL) {\n\t\t\tif ((host->do_dma == 0) && (host->bytes_left > 0)) {\n\t\t\t\t \n\t\t\t\tdavinci_fifo_data_trans(host, host->bytes_left);\n\t\t\t}\n\t\t\tend_transfer = 1;\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t} else {\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"DATDNE with no host->data\\n\");\n\t\t}\n\t}\n\n\tif (qstatus & MMCST0_TOUTRD) {\n\t\t \n\t\tdata->error = -ETIMEDOUT;\n\t\tend_transfer = 1;\n\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"read data timeout, status %x\\n\",\n\t\t\tqstatus);\n\n\t\tdavinci_abort_data(host, data);\n\t}\n\n\tif (qstatus & (MMCST0_CRCWR | MMCST0_CRCRD)) {\n\t\t \n\t\tdata->error = -EILSEQ;\n\t\tend_transfer = 1;\n\n\t\t \n\t\tif (qstatus & MMCST0_CRCWR) {\n\t\t\tu32 temp = readb(host->base + DAVINCI_MMCDRSP);\n\n\t\t\tif (temp == 0x9f)\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t}\n\t\tdev_dbg(mmc_dev(host->mmc), \"data %s %s error\\n\",\n\t\t\t(qstatus & MMCST0_CRCWR) ? \"write\" : \"read\",\n\t\t\t(data->error == -ETIMEDOUT) ? \"timeout\" : \"CRC\");\n\n\t\tdavinci_abort_data(host, data);\n\t}\n\n\tif (qstatus & MMCST0_TOUTRS) {\n\t\t \n\t\tif (host->cmd) {\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"CMD%d timeout, status %x\\n\",\n\t\t\t\thost->cmd->opcode, qstatus);\n\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\t\tif (data) {\n\t\t\t\tend_transfer = 1;\n\t\t\t\tdavinci_abort_data(host, data);\n\t\t\t} else\n\t\t\t\tend_command = 1;\n\t\t}\n\t}\n\n\tif (qstatus & MMCST0_CRCRS) {\n\t\t \n\t\tdev_dbg(mmc_dev(host->mmc), \"Command CRC error\\n\");\n\t\tif (host->cmd) {\n\t\t\thost->cmd->error = -EILSEQ;\n\t\t\tend_command = 1;\n\t\t}\n\t}\n\n\tif (qstatus & MMCST0_RSPDNE) {\n\t\t \n\t\tend_command = host->cmd ? 1 : 0;\n\t}\n\n\tif (end_command)\n\t\tmmc_davinci_cmd_done(host, host->cmd);\n\tif (end_transfer)\n\t\tmmc_davinci_xfer_done(host, data);\n\treturn IRQ_HANDLED;\n}\n\nstatic int mmc_davinci_get_cd(struct mmc_host *mmc)\n{\n\tstruct platform_device *pdev = to_platform_device(mmc->parent);\n\tstruct davinci_mmc_config *config = pdev->dev.platform_data;\n\n\tif (config && config->get_cd)\n\t\treturn config->get_cd(pdev->id);\n\n\treturn mmc_gpio_get_cd(mmc);\n}\n\nstatic int mmc_davinci_get_ro(struct mmc_host *mmc)\n{\n\tstruct platform_device *pdev = to_platform_device(mmc->parent);\n\tstruct davinci_mmc_config *config = pdev->dev.platform_data;\n\n\tif (config && config->get_ro)\n\t\treturn config->get_ro(pdev->id);\n\n\treturn mmc_gpio_get_ro(mmc);\n}\n\nstatic void mmc_davinci_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct mmc_davinci_host *host = mmc_priv(mmc);\n\n\tif (enable) {\n\t\tif (!(readl(host->base + DAVINCI_SDIOST0) & SDIOST0_DAT1_HI)) {\n\t\t\twritel(SDIOIST_IOINT, host->base + DAVINCI_SDIOIST);\n\t\t\tmmc_signal_sdio_irq(host->mmc);\n\t\t} else {\n\t\t\thost->sdio_int = true;\n\t\t\twritel(readl(host->base + DAVINCI_SDIOIEN) |\n\t\t\t       SDIOIEN_IOINTEN, host->base + DAVINCI_SDIOIEN);\n\t\t}\n\t} else {\n\t\thost->sdio_int = false;\n\t\twritel(readl(host->base + DAVINCI_SDIOIEN) & ~SDIOIEN_IOINTEN,\n\t\t       host->base + DAVINCI_SDIOIEN);\n\t}\n}\n\nstatic const struct mmc_host_ops mmc_davinci_ops = {\n\t.request\t= mmc_davinci_request,\n\t.set_ios\t= mmc_davinci_set_ios,\n\t.get_cd\t\t= mmc_davinci_get_cd,\n\t.get_ro\t\t= mmc_davinci_get_ro,\n\t.enable_sdio_irq = mmc_davinci_enable_sdio_irq,\n};\n\n \n\n#ifdef CONFIG_CPU_FREQ\nstatic int mmc_davinci_cpufreq_transition(struct notifier_block *nb,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct mmc_davinci_host *host;\n\tunsigned int mmc_pclk;\n\tstruct mmc_host *mmc;\n\tunsigned long flags;\n\n\thost = container_of(nb, struct mmc_davinci_host, freq_transition);\n\tmmc = host->mmc;\n\tmmc_pclk = clk_get_rate(host->clk);\n\n\tif (val == CPUFREQ_POSTCHANGE) {\n\t\tspin_lock_irqsave(&mmc->lock, flags);\n\t\thost->mmc_input_clk = mmc_pclk;\n\t\tcalculate_clk_divider(mmc, &mmc->ios);\n\t\tspin_unlock_irqrestore(&mmc->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int mmc_davinci_cpufreq_register(struct mmc_davinci_host *host)\n{\n\thost->freq_transition.notifier_call = mmc_davinci_cpufreq_transition;\n\n\treturn cpufreq_register_notifier(&host->freq_transition,\n\t\t\t\t\t CPUFREQ_TRANSITION_NOTIFIER);\n}\n\nstatic inline void mmc_davinci_cpufreq_deregister(struct mmc_davinci_host *host)\n{\n\tcpufreq_unregister_notifier(&host->freq_transition,\n\t\t\t\t    CPUFREQ_TRANSITION_NOTIFIER);\n}\n#else\nstatic inline int mmc_davinci_cpufreq_register(struct mmc_davinci_host *host)\n{\n\treturn 0;\n}\n\nstatic inline void mmc_davinci_cpufreq_deregister(struct mmc_davinci_host *host)\n{\n}\n#endif\nstatic void init_mmcsd_host(struct mmc_davinci_host *host)\n{\n\n\tmmc_davinci_reset_ctrl(host, 1);\n\n\twritel(0, host->base + DAVINCI_MMCCLK);\n\twritel(MMCCLK_CLKEN, host->base + DAVINCI_MMCCLK);\n\n\twritel(0x1FFF, host->base + DAVINCI_MMCTOR);\n\twritel(0xFFFF, host->base + DAVINCI_MMCTOD);\n\n\tmmc_davinci_reset_ctrl(host, 0);\n}\n\nstatic const struct platform_device_id davinci_mmc_devtype[] = {\n\t{\n\t\t.name\t= \"dm6441-mmc\",\n\t\t.driver_data = MMC_CTLR_VERSION_1,\n\t}, {\n\t\t.name\t= \"da830-mmc\",\n\t\t.driver_data = MMC_CTLR_VERSION_2,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(platform, davinci_mmc_devtype);\n\nstatic const struct of_device_id davinci_mmc_dt_ids[] = {\n\t{\n\t\t.compatible = \"ti,dm6441-mmc\",\n\t\t.data = &davinci_mmc_devtype[MMC_CTLR_VERSION_1],\n\t},\n\t{\n\t\t.compatible = \"ti,da830-mmc\",\n\t\t.data = &davinci_mmc_devtype[MMC_CTLR_VERSION_2],\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, davinci_mmc_dt_ids);\n\nstatic int mmc_davinci_parse_pdata(struct mmc_host *mmc)\n{\n\tstruct platform_device *pdev = to_platform_device(mmc->parent);\n\tstruct davinci_mmc_config *pdata = pdev->dev.platform_data;\n\tstruct mmc_davinci_host *host;\n\tint ret;\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\thost = mmc_priv(mmc);\n\tif (!host)\n\t\treturn -EINVAL;\n\n\tif (pdata && pdata->nr_sg)\n\t\thost->nr_sg = pdata->nr_sg - 1;\n\n\tif (pdata && (pdata->wires == 4 || pdata->wires == 0))\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\tif (pdata && (pdata->wires == 8))\n\t\tmmc->caps |= (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA);\n\n\tmmc->f_min = 312500;\n\tmmc->f_max = 25000000;\n\tif (pdata && pdata->max_freq)\n\t\tmmc->f_max = pdata->max_freq;\n\tif (pdata && pdata->caps)\n\t\tmmc->caps |= pdata->caps;\n\n\t \n\tret = mmc_gpiod_request_cd(mmc, \"cd\", 0, false, 0);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\telse if (ret)\n\t\tmmc->caps |= MMC_CAP_NEEDS_POLL;\n\n\tret = mmc_gpiod_request_ro(mmc, \"wp\", 0, 0);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int davinci_mmcsd_probe(struct platform_device *pdev)\n{\n\tstruct mmc_davinci_host *host = NULL;\n\tstruct mmc_host *mmc = NULL;\n\tstruct resource *r, *mem = NULL;\n\tint ret, irq;\n\tsize_t mem_size;\n\tconst struct platform_device_id *id_entry;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -ENODEV;\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmem_size = resource_size(r);\n\tmem = devm_request_mem_region(&pdev->dev, r->start, mem_size,\n\t\t\t\t      pdev->name);\n\tif (!mem)\n\t\treturn -EBUSY;\n\n\tmmc = mmc_alloc_host(sizeof(struct mmc_davinci_host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\t \n\n\thost->mem_res = mem;\n\thost->base = devm_ioremap(&pdev->dev, mem->start, mem_size);\n\tif (!host->base) {\n\t\tret = -ENOMEM;\n\t\tgoto ioremap_fail;\n\t}\n\n\thost->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\tgoto clk_get_fail;\n\t}\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\tgoto clk_prepare_enable_fail;\n\n\thost->mmc_input_clk = clk_get_rate(host->clk);\n\n\tpdev->id_entry = of_device_get_match_data(&pdev->dev);\n\tif (pdev->id_entry) {\n\t\tret = mmc_of_parse(mmc);\n\t\tif (ret) {\n\t\t\tdev_err_probe(&pdev->dev, ret,\n\t\t\t\t      \"could not parse of data\\n\");\n\t\t\tgoto parse_fail;\n\t\t}\n\t} else {\n\t\tret = mmc_davinci_parse_pdata(mmc);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"could not parse platform data: %d\\n\", ret);\n\t\t\tgoto parse_fail;\n\t}\t}\n\n\tif (host->nr_sg > MAX_NR_SG || !host->nr_sg)\n\t\thost->nr_sg = MAX_NR_SG;\n\n\tinit_mmcsd_host(host);\n\n\thost->use_dma = use_dma;\n\thost->mmc_irq = irq;\n\thost->sdio_irq = platform_get_irq_optional(pdev, 1);\n\n\tif (host->use_dma) {\n\t\tret = davinci_acquire_dma_channels(host);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto dma_probe_defer;\n\t\telse if (ret)\n\t\t\thost->use_dma = 0;\n\t}\n\n\tmmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\n\n\tid_entry = platform_get_device_id(pdev);\n\tif (id_entry)\n\t\thost->version = id_entry->driver_data;\n\n\tmmc->ops = &mmc_davinci_ops;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\t \n\tmmc->max_segs\t\t= MAX_NR_SG;\n\n\t \n\tmmc->max_seg_size\t= MAX_CCNT * rw_threshold;\n\n\t \n\tmmc->max_blk_size\t= 4095;   \n\tmmc->max_blk_count\t= 65535;  \n\tmmc->max_req_size\t= mmc->max_blk_size * mmc->max_blk_count;\n\n\tdev_dbg(mmc_dev(host->mmc), \"max_segs=%d\\n\", mmc->max_segs);\n\tdev_dbg(mmc_dev(host->mmc), \"max_blk_size=%d\\n\", mmc->max_blk_size);\n\tdev_dbg(mmc_dev(host->mmc), \"max_req_size=%d\\n\", mmc->max_req_size);\n\tdev_dbg(mmc_dev(host->mmc), \"max_seg_size=%d\\n\", mmc->max_seg_size);\n\n\tplatform_set_drvdata(pdev, host);\n\n\tret = mmc_davinci_cpufreq_register(host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to register cpufreq\\n\");\n\t\tgoto cpu_freq_fail;\n\t}\n\n\tret = mmc_add_host(mmc);\n\tif (ret < 0)\n\t\tgoto mmc_add_host_fail;\n\n\tret = devm_request_irq(&pdev->dev, irq, mmc_davinci_irq, 0,\n\t\t\t       mmc_hostname(mmc), host);\n\tif (ret)\n\t\tgoto request_irq_fail;\n\n\tif (host->sdio_irq >= 0) {\n\t\tret = devm_request_irq(&pdev->dev, host->sdio_irq,\n\t\t\t\t       mmc_davinci_sdio_irq, 0,\n\t\t\t\t       mmc_hostname(mmc), host);\n\t\tif (!ret)\n\t\t\tmmc->caps |= MMC_CAP_SDIO_IRQ;\n\t}\n\n\trename_region(mem, mmc_hostname(mmc));\n\n\tdev_info(mmc_dev(host->mmc), \"Using %s, %d-bit mode\\n\",\n\t\thost->use_dma ? \"DMA\" : \"PIO\",\n\t\t(mmc->caps & MMC_CAP_4_BIT_DATA) ? 4 : 1);\n\n\treturn 0;\n\nrequest_irq_fail:\n\tmmc_remove_host(mmc);\nmmc_add_host_fail:\n\tmmc_davinci_cpufreq_deregister(host);\ncpu_freq_fail:\n\tdavinci_release_dma_channels(host);\nparse_fail:\ndma_probe_defer:\n\tclk_disable_unprepare(host->clk);\nclk_prepare_enable_fail:\nclk_get_fail:\nioremap_fail:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void __exit davinci_mmcsd_remove(struct platform_device *pdev)\n{\n\tstruct mmc_davinci_host *host = platform_get_drvdata(pdev);\n\n\tmmc_remove_host(host->mmc);\n\tmmc_davinci_cpufreq_deregister(host);\n\tdavinci_release_dma_channels(host);\n\tclk_disable_unprepare(host->clk);\n\tmmc_free_host(host->mmc);\n}\n\n#ifdef CONFIG_PM\nstatic int davinci_mmcsd_suspend(struct device *dev)\n{\n\tstruct mmc_davinci_host *host = dev_get_drvdata(dev);\n\n\twritel(0, host->base + DAVINCI_MMCIM);\n\tmmc_davinci_reset_ctrl(host, 1);\n\tclk_disable(host->clk);\n\n\treturn 0;\n}\n\nstatic int davinci_mmcsd_resume(struct device *dev)\n{\n\tstruct mmc_davinci_host *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = clk_enable(host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc_davinci_reset_ctrl(host, 0);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops davinci_mmcsd_pm = {\n\t.suspend        = davinci_mmcsd_suspend,\n\t.resume         = davinci_mmcsd_resume,\n};\n\n#define davinci_mmcsd_pm_ops (&davinci_mmcsd_pm)\n#else\n#define davinci_mmcsd_pm_ops NULL\n#endif\n\nstatic struct platform_driver davinci_mmcsd_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"davinci_mmc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= davinci_mmcsd_pm_ops,\n\t\t.of_match_table = davinci_mmc_dt_ids,\n\t},\n\t.probe\t\t= davinci_mmcsd_probe,\n\t.remove_new\t= __exit_p(davinci_mmcsd_remove),\n\t.id_table\t= davinci_mmc_devtype,\n};\n\nmodule_platform_driver(davinci_mmcsd_driver);\n\nMODULE_AUTHOR(\"Texas Instruments India\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"MMC/SD driver for Davinci MMC controller\");\nMODULE_ALIAS(\"platform:davinci_mmc\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}