{
  "module_name": "sdhci-esdhc-imx.c",
  "hash_id": "737b17b2f9419b53e30a2874e296e578ed240337a7afa0759ebf108d51c5bd87",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-esdhc-imx.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/pm_qos.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n#include \"sdhci-esdhc.h\"\n#include \"cqhci.h\"\n\n#define ESDHC_SYS_CTRL_DTOCV_MASK\t0x0f\n#define\tESDHC_CTRL_D3CD\t\t\t0x08\n#define ESDHC_BURST_LEN_EN_INCR\t\t(1 << 27)\n \n#define ESDHC_VENDOR_SPEC\t\t0xc0\n#define  ESDHC_VENDOR_SPEC_SDIO_QUIRK\t(1 << 1)\n#define  ESDHC_VENDOR_SPEC_VSELECT\t(1 << 1)\n#define  ESDHC_VENDOR_SPEC_FRC_SDCLK_ON\t(1 << 8)\n#define ESDHC_DEBUG_SEL_AND_STATUS_REG\t\t0xc2\n#define ESDHC_DEBUG_SEL_REG\t\t\t0xc3\n#define ESDHC_DEBUG_SEL_MASK\t\t\t0xf\n#define ESDHC_DEBUG_SEL_CMD_STATE\t\t1\n#define ESDHC_DEBUG_SEL_DATA_STATE\t\t2\n#define ESDHC_DEBUG_SEL_TRANS_STATE\t\t3\n#define ESDHC_DEBUG_SEL_DMA_STATE\t\t4\n#define ESDHC_DEBUG_SEL_ADMA_STATE\t\t5\n#define ESDHC_DEBUG_SEL_FIFO_STATE\t\t6\n#define ESDHC_DEBUG_SEL_ASYNC_FIFO_STATE\t7\n#define ESDHC_WTMK_LVL\t\t\t0x44\n#define  ESDHC_WTMK_DEFAULT_VAL\t\t0x10401040\n#define  ESDHC_WTMK_LVL_RD_WML_MASK\t0x000000FF\n#define  ESDHC_WTMK_LVL_RD_WML_SHIFT\t0\n#define  ESDHC_WTMK_LVL_WR_WML_MASK\t0x00FF0000\n#define  ESDHC_WTMK_LVL_WR_WML_SHIFT\t16\n#define  ESDHC_WTMK_LVL_WML_VAL_DEF\t64\n#define  ESDHC_WTMK_LVL_WML_VAL_MAX\t128\n#define ESDHC_MIX_CTRL\t\t\t0x48\n#define  ESDHC_MIX_CTRL_DDREN\t\t(1 << 3)\n#define  ESDHC_MIX_CTRL_AC23EN\t\t(1 << 7)\n#define  ESDHC_MIX_CTRL_EXE_TUNE\t(1 << 22)\n#define  ESDHC_MIX_CTRL_SMPCLK_SEL\t(1 << 23)\n#define  ESDHC_MIX_CTRL_AUTO_TUNE_EN\t(1 << 24)\n#define  ESDHC_MIX_CTRL_FBCLK_SEL\t(1 << 25)\n#define  ESDHC_MIX_CTRL_HS400_EN\t(1 << 26)\n#define  ESDHC_MIX_CTRL_HS400_ES_EN\t(1 << 27)\n \n#define  ESDHC_MIX_CTRL_SDHCI_MASK\t0xb7\n \n#define  ESDHC_MIX_CTRL_TUNING_MASK\t0x03c00000\n\n \n#define ESDHC_DLL_CTRL\t\t\t0x60\n#define ESDHC_DLL_OVERRIDE_VAL_SHIFT\t9\n#define ESDHC_DLL_OVERRIDE_EN_SHIFT\t8\n\n \n#define ESDHC_TUNE_CTRL_STATUS\t\t0x68\n#define  ESDHC_TUNE_CTRL_STEP\t\t1\n#define  ESDHC_TUNE_CTRL_MIN\t\t0\n#define  ESDHC_TUNE_CTRL_MAX\t\t((1 << 7) - 1)\n\n \n#define ESDHC_STROBE_DLL_CTRL\t\t0x70\n#define ESDHC_STROBE_DLL_CTRL_ENABLE\t(1 << 0)\n#define ESDHC_STROBE_DLL_CTRL_RESET\t(1 << 1)\n#define ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_DEFAULT\t0x7\n#define ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT\t3\n#define ESDHC_STROBE_DLL_CTRL_SLV_UPDATE_INT_DEFAULT\t(4 << 20)\n\n#define ESDHC_STROBE_DLL_STATUS\t\t0x74\n#define ESDHC_STROBE_DLL_STS_REF_LOCK\t(1 << 1)\n#define ESDHC_STROBE_DLL_STS_SLV_LOCK\t0x1\n\n#define ESDHC_VEND_SPEC2\t\t0xc8\n#define ESDHC_VEND_SPEC2_EN_BUSY_IRQ\t(1 << 8)\n#define ESDHC_VEND_SPEC2_AUTO_TUNE_8BIT_EN\t(1 << 4)\n#define ESDHC_VEND_SPEC2_AUTO_TUNE_4BIT_EN\t(0 << 4)\n#define ESDHC_VEND_SPEC2_AUTO_TUNE_1BIT_EN\t(2 << 4)\n#define ESDHC_VEND_SPEC2_AUTO_TUNE_CMD_EN\t(1 << 6)\n#define ESDHC_VEND_SPEC2_AUTO_TUNE_MODE_MASK\t(7 << 4)\n\n#define ESDHC_TUNING_CTRL\t\t0xcc\n#define ESDHC_STD_TUNING_EN\t\t(1 << 24)\n \n#define ESDHC_TUNING_START_TAP_DEFAULT\t0x1\n#define ESDHC_TUNING_START_TAP_MASK\t0x7f\n#define ESDHC_TUNING_CMD_CRC_CHECK_DISABLE\t(1 << 7)\n#define ESDHC_TUNING_STEP_DEFAULT\t0x1\n#define ESDHC_TUNING_STEP_MASK\t\t0x00070000\n#define ESDHC_TUNING_STEP_SHIFT\t\t16\n\n \n#define ESDHC_PINCTRL_STATE_100MHZ\t\"state_100mhz\"\n#define ESDHC_PINCTRL_STATE_200MHZ\t\"state_200mhz\"\n\n \n#define ESDHC_CTRL_4BITBUS\t\t(0x1 << 1)\n#define ESDHC_CTRL_8BITBUS\t\t(0x2 << 1)\n#define ESDHC_CTRL_BUSWIDTH_MASK\t(0x3 << 1)\n#define USDHC_GET_BUSWIDTH(c) (c & ESDHC_CTRL_BUSWIDTH_MASK)\n\n \n#define ESDHC_INT_VENDOR_SPEC_DMA_ERR\t(1 << 28)\n\n \n#define ESDHC_CQHCI_ADDR_OFFSET\t\t0x100\n\n \n#define ESDHC_FLAG_MULTIBLK_NO_INT\tBIT(1)\n \n#define ESDHC_FLAG_USDHC\t\tBIT(3)\n \n#define ESDHC_FLAG_MAN_TUNING\t\tBIT(4)\n \n#define ESDHC_FLAG_STD_TUNING\t\tBIT(5)\n \n#define ESDHC_FLAG_HAVE_CAP1\t\tBIT(6)\n \n#define ESDHC_FLAG_ERR004536\t\tBIT(7)\n \n#define ESDHC_FLAG_HS200\t\tBIT(8)\n \n#define ESDHC_FLAG_HS400\t\tBIT(9)\n \n#define ESDHC_FLAG_ERR010450\t\tBIT(10)\n \n#define ESDHC_FLAG_HS400_ES\t\tBIT(11)\n \n#define ESDHC_FLAG_CQHCI\t\tBIT(12)\n \n#define ESDHC_FLAG_PMQOS\t\tBIT(13)\n \n#define ESDHC_FLAG_STATE_LOST_IN_LPMODE\t\tBIT(14)\n \n#define ESDHC_FLAG_CLK_RATE_LOST_IN_PM_RUNTIME\tBIT(15)\n \n#define ESDHC_FLAG_BROKEN_AUTO_CMD23\tBIT(16)\n\n \n#define ESDHC_FLAG_SKIP_ERR004536\tBIT(17)\n\nenum wp_types {\n\tESDHC_WP_NONE,\t\t \n\tESDHC_WP_CONTROLLER,\t \n\tESDHC_WP_GPIO,\t\t \n};\n\nenum cd_types {\n\tESDHC_CD_NONE,\t\t \n\tESDHC_CD_CONTROLLER,\t \n\tESDHC_CD_GPIO,\t\t \n\tESDHC_CD_PERMANENT,\t \n};\n\n \n\nstruct esdhc_platform_data {\n\tenum wp_types wp_type;\n\tenum cd_types cd_type;\n\tint max_bus_width;\n\tunsigned int delay_line;\n\tunsigned int tuning_step;        \n\tunsigned int tuning_start_tap;\t \n\tunsigned int strobe_dll_delay_target;\t \n};\n\nstruct esdhc_soc_data {\n\tu32 flags;\n};\n\nstatic const struct esdhc_soc_data esdhc_imx25_data = {\n\t.flags = ESDHC_FLAG_ERR004536,\n};\n\nstatic const struct esdhc_soc_data esdhc_imx35_data = {\n\t.flags = ESDHC_FLAG_ERR004536,\n};\n\nstatic const struct esdhc_soc_data esdhc_imx51_data = {\n\t.flags = 0,\n};\n\nstatic const struct esdhc_soc_data esdhc_imx53_data = {\n\t.flags = ESDHC_FLAG_MULTIBLK_NO_INT,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx6q_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_MAN_TUNING\n\t\t\t| ESDHC_FLAG_BROKEN_AUTO_CMD23,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx6sl_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_ERR004536\n\t\t\t| ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_BROKEN_AUTO_CMD23,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx6sll_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_HS400\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx6sx_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE\n\t\t\t| ESDHC_FLAG_BROKEN_AUTO_CMD23,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx6ull_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_ERR010450\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE,\n};\n\nstatic const struct esdhc_soc_data usdhc_imx7d_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_HS400\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE\n\t\t\t| ESDHC_FLAG_BROKEN_AUTO_CMD23,\n};\n\nstatic struct esdhc_soc_data usdhc_s32g2_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_MAN_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES\n\t\t\t| ESDHC_FLAG_SKIP_ERR004536,\n};\n\nstatic struct esdhc_soc_data usdhc_imx7ulp_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_PMQOS | ESDHC_FLAG_HS400\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE,\n};\nstatic struct esdhc_soc_data usdhc_imxrt1050_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200,\n};\n\nstatic struct esdhc_soc_data usdhc_imx8qxp_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE\n\t\t\t| ESDHC_FLAG_CLK_RATE_LOST_IN_PM_RUNTIME,\n};\n\nstatic struct esdhc_soc_data usdhc_imx8mm_data = {\n\t.flags = ESDHC_FLAG_USDHC | ESDHC_FLAG_STD_TUNING\n\t\t\t| ESDHC_FLAG_HAVE_CAP1 | ESDHC_FLAG_HS200\n\t\t\t| ESDHC_FLAG_HS400 | ESDHC_FLAG_HS400_ES\n\t\t\t| ESDHC_FLAG_STATE_LOST_IN_LPMODE,\n};\n\nstruct pltfm_imx_data {\n\tu32 scratchpad;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_100mhz;\n\tstruct pinctrl_state *pins_200mhz;\n\tconst struct esdhc_soc_data *socdata;\n\tstruct esdhc_platform_data boarddata;\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_ahb;\n\tstruct clk *clk_per;\n\tunsigned int actual_clock;\n\n\t \n\tunsigned int init_card_type;\n\n\tenum {\n\t\tNO_CMD_PENDING,       \n\t\tMULTIBLK_IN_PROCESS,  \n\t\tWAIT_FOR_INT,         \n\t} multiblock_status;\n\tu32 is_ddr;\n\tstruct pm_qos_request pm_qos_req;\n};\n\nstatic const struct of_device_id imx_esdhc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx25-esdhc\", .data = &esdhc_imx25_data, },\n\t{ .compatible = \"fsl,imx35-esdhc\", .data = &esdhc_imx35_data, },\n\t{ .compatible = \"fsl,imx51-esdhc\", .data = &esdhc_imx51_data, },\n\t{ .compatible = \"fsl,imx53-esdhc\", .data = &esdhc_imx53_data, },\n\t{ .compatible = \"fsl,imx6sx-usdhc\", .data = &usdhc_imx6sx_data, },\n\t{ .compatible = \"fsl,imx6sl-usdhc\", .data = &usdhc_imx6sl_data, },\n\t{ .compatible = \"fsl,imx6sll-usdhc\", .data = &usdhc_imx6sll_data, },\n\t{ .compatible = \"fsl,imx6q-usdhc\", .data = &usdhc_imx6q_data, },\n\t{ .compatible = \"fsl,imx6ull-usdhc\", .data = &usdhc_imx6ull_data, },\n\t{ .compatible = \"fsl,imx7d-usdhc\", .data = &usdhc_imx7d_data, },\n\t{ .compatible = \"fsl,imx7ulp-usdhc\", .data = &usdhc_imx7ulp_data, },\n\t{ .compatible = \"fsl,imx8qxp-usdhc\", .data = &usdhc_imx8qxp_data, },\n\t{ .compatible = \"fsl,imx8mm-usdhc\", .data = &usdhc_imx8mm_data, },\n\t{ .compatible = \"fsl,imxrt1050-usdhc\", .data = &usdhc_imxrt1050_data, },\n\t{ .compatible = \"nxp,s32g2-usdhc\", .data = &usdhc_s32g2_data, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, imx_esdhc_dt_ids);\n\nstatic inline int is_imx25_esdhc(struct pltfm_imx_data *data)\n{\n\treturn data->socdata == &esdhc_imx25_data;\n}\n\nstatic inline int is_imx53_esdhc(struct pltfm_imx_data *data)\n{\n\treturn data->socdata == &esdhc_imx53_data;\n}\n\nstatic inline int esdhc_is_usdhc(struct pltfm_imx_data *data)\n{\n\treturn !!(data->socdata->flags & ESDHC_FLAG_USDHC);\n}\n\nstatic inline void esdhc_clrset_le(struct sdhci_host *host, u32 mask, u32 val, int reg)\n{\n\tvoid __iomem *base = host->ioaddr + (reg & ~0x3);\n\tu32 shift = (reg & 0x3) * 8;\n\n\twritel(((readl(base) & ~(mask << shift)) | (val << shift)), base);\n}\n\n#define DRIVER_NAME \"sdhci-esdhc-imx\"\n#define ESDHC_IMX_DUMP(f, x...) \\\n\tpr_err(\"%s: \" DRIVER_NAME \": \" f, mmc_hostname(host->mmc), ## x)\nstatic void esdhc_dump_debug_regs(struct sdhci_host *host)\n{\n\tint i;\n\tchar *debug_status[7] = {\n\t\t\t\t \"cmd debug status\",\n\t\t\t\t \"data debug status\",\n\t\t\t\t \"trans debug status\",\n\t\t\t\t \"dma debug status\",\n\t\t\t\t \"adma debug status\",\n\t\t\t\t \"fifo debug status\",\n\t\t\t\t \"async fifo debug status\"\n\t};\n\n\tESDHC_IMX_DUMP(\"========= ESDHC IMX DEBUG STATUS DUMP =========\\n\");\n\tfor (i = 0; i < 7; i++) {\n\t\tesdhc_clrset_le(host, ESDHC_DEBUG_SEL_MASK,\n\t\t\tESDHC_DEBUG_SEL_CMD_STATE + i, ESDHC_DEBUG_SEL_REG);\n\t\tESDHC_IMX_DUMP(\"%s:  0x%04x\\n\", debug_status[i],\n\t\t\treadw(host->ioaddr + ESDHC_DEBUG_SEL_AND_STATUS_REG));\n\t}\n\n\tesdhc_clrset_le(host, ESDHC_DEBUG_SEL_MASK, 0, ESDHC_DEBUG_SEL_REG);\n\n}\n\nstatic inline void esdhc_wait_for_card_clock_gate_off(struct sdhci_host *host)\n{\n\tu32 present_state;\n\tint ret;\n\n\tret = readl_poll_timeout(host->ioaddr + ESDHC_PRSSTAT, present_state,\n\t\t\t\t(present_state & ESDHC_CLOCK_GATE_OFF), 2, 100);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(mmc_dev(host->mmc), \"%s: card clock still not gate off in 100us!.\\n\", __func__);\n}\n\n \nstatic inline void usdhc_auto_tuning_mode_sel_and_en(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 buswidth, auto_tune_buswidth;\n\tu32 reg;\n\n\tbuswidth = USDHC_GET_BUSWIDTH(readl(host->ioaddr + SDHCI_HOST_CONTROL));\n\n\tswitch (buswidth) {\n\tcase ESDHC_CTRL_8BITBUS:\n\t\tauto_tune_buswidth = ESDHC_VEND_SPEC2_AUTO_TUNE_8BIT_EN;\n\t\tbreak;\n\tcase ESDHC_CTRL_4BITBUS:\n\t\tauto_tune_buswidth = ESDHC_VEND_SPEC2_AUTO_TUNE_4BIT_EN;\n\t\tbreak;\n\tdefault:\t \n\t\tauto_tune_buswidth = ESDHC_VEND_SPEC2_AUTO_TUNE_1BIT_EN;\n\t\tbreak;\n\t}\n\n\t \n\tif (imx_data->init_card_type == MMC_TYPE_SDIO)\n\t\tauto_tune_buswidth = ESDHC_VEND_SPEC2_AUTO_TUNE_1BIT_EN;\n\n\tesdhc_clrset_le(host, ESDHC_VEND_SPEC2_AUTO_TUNE_MODE_MASK,\n\t\t\tauto_tune_buswidth | ESDHC_VEND_SPEC2_AUTO_TUNE_CMD_EN,\n\t\t\tESDHC_VEND_SPEC2);\n\n\treg = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\treg |= ESDHC_MIX_CTRL_AUTO_TUNE_EN;\n\twritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\n}\n\nstatic u32 esdhc_readl_le(struct sdhci_host *host, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 val = readl(host->ioaddr + reg);\n\n\tif (unlikely(reg == SDHCI_PRESENT_STATE)) {\n\t\tu32 fsl_prss = val;\n\t\t \n\t\tval = fsl_prss & 0x000FFFFF;\n\t\t \n\t\tval |= (fsl_prss & 0x0F000000) >> 4;\n\t\t \n\t\tval |= (fsl_prss & 0x00800000) << 1;\n\t}\n\n\tif (unlikely(reg == SDHCI_CAPABILITIES)) {\n\t\t \n\t\tif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\n\t\t\tval &= 0xffff0000;\n\n\t\t \n\n\t\tif (val & SDHCI_CAN_DO_ADMA1) {\n\t\t\tval &= ~SDHCI_CAN_DO_ADMA1;\n\t\t\tval |= SDHCI_CAN_DO_ADMA2;\n\t\t}\n\t}\n\n\tif (unlikely(reg == SDHCI_CAPABILITIES_1)) {\n\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\tif (imx_data->socdata->flags & ESDHC_FLAG_HAVE_CAP1)\n\t\t\t\tval = readl(host->ioaddr + SDHCI_CAPABILITIES) & 0xFFFF;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tval = SDHCI_SUPPORT_DDR50 | SDHCI_SUPPORT_SDR104\n\t\t\t\t\t| SDHCI_SUPPORT_SDR50\n\t\t\t\t\t| SDHCI_USE_SDR50_TUNING\n\t\t\t\t\t| FIELD_PREP(SDHCI_RETUNING_MODE_MASK,\n\t\t\t\t\t\t     SDHCI_TUNING_MODE_3);\n\n\t\t\t \n\t\t\tif (IS_ERR_OR_NULL(imx_data->pins_100mhz))\n\t\t\t\tval &= ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_DDR50);\n\t\t\tif (IS_ERR_OR_NULL(imx_data->pins_200mhz))\n\t\t\t\tval &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_HS400);\n\t\t}\n\t}\n\n\tif (unlikely(reg == SDHCI_MAX_CURRENT) && esdhc_is_usdhc(imx_data)) {\n\t\tval = 0;\n\t\tval |= FIELD_PREP(SDHCI_MAX_CURRENT_330_MASK, 0xFF);\n\t\tval |= FIELD_PREP(SDHCI_MAX_CURRENT_300_MASK, 0xFF);\n\t\tval |= FIELD_PREP(SDHCI_MAX_CURRENT_180_MASK, 0xFF);\n\t}\n\n\tif (unlikely(reg == SDHCI_INT_STATUS)) {\n\t\tif (val & ESDHC_INT_VENDOR_SPEC_DMA_ERR) {\n\t\t\tval &= ~ESDHC_INT_VENDOR_SPEC_DMA_ERR;\n\t\t\tval |= SDHCI_INT_ADMA_ERROR;\n\t\t}\n\n\t\t \n\t\tif ((imx_data->multiblock_status == WAIT_FOR_INT) &&\n\t\t    ((val & SDHCI_INT_RESPONSE) == SDHCI_INT_RESPONSE)) {\n\t\t\tval &= ~SDHCI_INT_RESPONSE;\n\t\t\twritel(SDHCI_INT_RESPONSE, host->ioaddr +\n\t\t\t\t\t\t   SDHCI_INT_STATUS);\n\t\t\timx_data->multiblock_status = NO_CMD_PENDING;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic void esdhc_writel_le(struct sdhci_host *host, u32 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 data;\n\n\tif (unlikely(reg == SDHCI_INT_ENABLE || reg == SDHCI_SIGNAL_ENABLE ||\n\t\t\treg == SDHCI_INT_STATUS)) {\n\t\tif ((val & SDHCI_INT_CARD_INT) && !esdhc_is_usdhc(imx_data)) {\n\t\t\t \n\t\t\tdata = readl(host->ioaddr + SDHCI_HOST_CONTROL);\n\t\t\tdata &= ~ESDHC_CTRL_D3CD;\n\t\t\twritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\n\t\t\tdata |= ESDHC_CTRL_D3CD;\n\t\t\twritel(data, host->ioaddr + SDHCI_HOST_CONTROL);\n\t\t}\n\n\t\tif (val & SDHCI_INT_ADMA_ERROR) {\n\t\t\tval &= ~SDHCI_INT_ADMA_ERROR;\n\t\t\tval |= ESDHC_INT_VENDOR_SPEC_DMA_ERR;\n\t\t}\n\t}\n\n\tif (unlikely((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\n\t\t\t\t&& (reg == SDHCI_INT_STATUS)\n\t\t\t\t&& (val & SDHCI_INT_DATA_END))) {\n\t\t\tu32 v;\n\t\t\tv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\t\tv &= ~ESDHC_VENDOR_SPEC_SDIO_QUIRK;\n\t\t\twritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\n\n\t\t\tif (imx_data->multiblock_status == MULTIBLK_IN_PROCESS)\n\t\t\t{\n\t\t\t\t \n\t\t\t\tdata = MMC_STOP_TRANSMISSION << 24 |\n\t\t\t\t       SDHCI_CMD_ABORTCMD << 16;\n\t\t\t\twritel(data, host->ioaddr + SDHCI_TRANSFER_MODE);\n\t\t\t\timx_data->multiblock_status = WAIT_FOR_INT;\n\t\t\t}\n\t}\n\n\twritel(val, host->ioaddr + reg);\n}\n\nstatic u16 esdhc_readw_le(struct sdhci_host *host, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu16 ret = 0;\n\tu32 val;\n\n\tif (unlikely(reg == SDHCI_HOST_VERSION)) {\n\t\treg ^= 2;\n\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\t \n\t\t\treturn SDHCI_SPEC_300;\n\t\t}\n\t}\n\n\tif (unlikely(reg == SDHCI_HOST_CONTROL2)) {\n\t\tval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tif (val & ESDHC_VENDOR_SPEC_VSELECT)\n\t\t\tret |= SDHCI_CTRL_VDD_180;\n\n\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\tif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\n\t\t\t\tval = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\telse if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING)\n\t\t\t\t \n\t\t\t\tval = readl(host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\t}\n\n\t\tif (val & ESDHC_MIX_CTRL_EXE_TUNE)\n\t\t\tret |= SDHCI_CTRL_EXEC_TUNING;\n\t\tif (val & ESDHC_MIX_CTRL_SMPCLK_SEL)\n\t\t\tret |= SDHCI_CTRL_TUNED_CLK;\n\n\t\tret &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;\n\n\t\treturn ret;\n\t}\n\n\tif (unlikely(reg == SDHCI_TRANSFER_MODE)) {\n\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\tu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\tret = m & ESDHC_MIX_CTRL_SDHCI_MASK;\n\t\t\t \n\t\t\tif (m & ESDHC_MIX_CTRL_AC23EN) {\n\t\t\t\tret &= ~ESDHC_MIX_CTRL_AC23EN;\n\t\t\t\tret |= SDHCI_TRNS_AUTO_CMD23;\n\t\t\t}\n\t\t} else {\n\t\t\tret = readw(host->ioaddr + SDHCI_TRANSFER_MODE);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treturn readw(host->ioaddr + reg);\n}\n\nstatic void esdhc_writew_le(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 new_val = 0;\n\n\tswitch (reg) {\n\tcase SDHCI_CLOCK_CONTROL:\n\t\tnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tif (val & SDHCI_CLOCK_CARD_EN)\n\t\t\tnew_val |= ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\n\t\telse\n\t\t\tnew_val &= ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON;\n\t\twritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tif (!(new_val & ESDHC_VENDOR_SPEC_FRC_SDCLK_ON))\n\t\t\tesdhc_wait_for_card_clock_gate_off(host);\n\t\treturn;\n\tcase SDHCI_HOST_CONTROL2:\n\t\tnew_val = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tif (val & SDHCI_CTRL_VDD_180)\n\t\t\tnew_val |= ESDHC_VENDOR_SPEC_VSELECT;\n\t\telse\n\t\t\tnew_val &= ~ESDHC_VENDOR_SPEC_VSELECT;\n\t\twritel(new_val, host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tif (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\n\t\t\tu32 v = readl(host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\t\tu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\tif (val & SDHCI_CTRL_TUNED_CLK) {\n\t\t\t\tv |= ESDHC_MIX_CTRL_SMPCLK_SEL;\n\t\t\t} else {\n\t\t\t\tv &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\n\t\t\t\tm &= ~ESDHC_MIX_CTRL_FBCLK_SEL;\n\t\t\t}\n\n\t\t\tif (val & SDHCI_CTRL_EXEC_TUNING) {\n\t\t\t\tv |= ESDHC_MIX_CTRL_EXE_TUNE;\n\t\t\t\tm |= ESDHC_MIX_CTRL_FBCLK_SEL;\n\t\t\t} else {\n\t\t\t\tv &= ~ESDHC_MIX_CTRL_EXE_TUNE;\n\t\t\t}\n\n\t\t\twritel(v, host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\t\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n\t\t}\n\t\treturn;\n\tcase SDHCI_TRANSFER_MODE:\n\t\tif ((imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT)\n\t\t\t\t&& (host->cmd->opcode == SD_IO_RW_EXTENDED)\n\t\t\t\t&& (host->cmd->data->blocks > 1)\n\t\t\t\t&& (host->cmd->data->flags & MMC_DATA_READ)) {\n\t\t\tu32 v;\n\t\t\tv = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\t\tv |= ESDHC_VENDOR_SPEC_SDIO_QUIRK;\n\t\t\twritel(v, host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\t}\n\n\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\tu32 wml;\n\t\t\tu32 m = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\t \n\t\t\tif (val & SDHCI_TRNS_AUTO_CMD23) {\n\t\t\t\tval &= ~SDHCI_TRNS_AUTO_CMD23;\n\t\t\t\tval |= ESDHC_MIX_CTRL_AC23EN;\n\t\t\t}\n\t\t\tm = val | (m & ~ESDHC_MIX_CTRL_SDHCI_MASK);\n\t\t\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n\n\t\t\t \n\t\t\tm = readl(host->ioaddr + ESDHC_WTMK_LVL);\n\t\t\tif (val & SDHCI_TRNS_DMA) {\n\t\t\t\twml = ESDHC_WTMK_LVL_WML_VAL_DEF;\n\t\t\t} else {\n\t\t\t\tu8 ctrl;\n\t\t\t\twml = ESDHC_WTMK_LVL_WML_VAL_MAX;\n\n\t\t\t\t \n\t\t\t\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\t\t\t\tctrl &= ~SDHCI_CTRL_DMA_MASK;\n\t\t\t\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n\t\t\t}\n\t\t\tm &= ~(ESDHC_WTMK_LVL_RD_WML_MASK |\n\t\t\t       ESDHC_WTMK_LVL_WR_WML_MASK);\n\t\t\tm |= (wml << ESDHC_WTMK_LVL_RD_WML_SHIFT) |\n\t\t\t     (wml << ESDHC_WTMK_LVL_WR_WML_SHIFT);\n\t\t\twritel(m, host->ioaddr + ESDHC_WTMK_LVL);\n\t\t} else {\n\t\t\t \n\t\t\timx_data->scratchpad = val;\n\t\t}\n\t\treturn;\n\tcase SDHCI_COMMAND:\n\t\tif (host->cmd->opcode == MMC_STOP_TRANSMISSION)\n\t\t\tval |= SDHCI_CMD_ABORTCMD;\n\n\t\tif ((host->cmd->opcode == MMC_SET_BLOCK_COUNT) &&\n\t\t    (imx_data->socdata->flags & ESDHC_FLAG_MULTIBLK_NO_INT))\n\t\t\timx_data->multiblock_status = MULTIBLK_IN_PROCESS;\n\n\t\tif (esdhc_is_usdhc(imx_data))\n\t\t\twritel(val << 16,\n\t\t\t       host->ioaddr + SDHCI_TRANSFER_MODE);\n\t\telse\n\t\t\twritel(val << 16 | imx_data->scratchpad,\n\t\t\t       host->ioaddr + SDHCI_TRANSFER_MODE);\n\t\treturn;\n\tcase SDHCI_BLOCK_SIZE:\n\t\tval &= ~SDHCI_MAKE_BLKSZ(0x7, 0);\n\t\tbreak;\n\t}\n\tesdhc_clrset_le(host, 0xffff, val, reg);\n}\n\nstatic u8 esdhc_readb_le(struct sdhci_host *host, int reg)\n{\n\tu8 ret;\n\tu32 val;\n\n\tswitch (reg) {\n\tcase SDHCI_HOST_CONTROL:\n\t\tval = readl(host->ioaddr + reg);\n\n\t\tret = val & SDHCI_CTRL_LED;\n\t\tret |= (val >> 5) & SDHCI_CTRL_DMA_MASK;\n\t\tret |= (val & ESDHC_CTRL_4BITBUS);\n\t\tret |= (val & ESDHC_CTRL_8BITBUS) << 3;\n\t\treturn ret;\n\t}\n\n\treturn readb(host->ioaddr + reg);\n}\n\nstatic void esdhc_writeb_le(struct sdhci_host *host, u8 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 new_val = 0;\n\tu32 mask;\n\n\tswitch (reg) {\n\tcase SDHCI_POWER_CONTROL:\n\t\t \n\t\treturn;\n\tcase SDHCI_HOST_CONTROL:\n\t\t \n\t\tnew_val = val & SDHCI_CTRL_LED;\n\t\t \n\t\tnew_val |= ESDHC_HOST_CONTROL_LE;\n\t\t \n\t\tif (!is_imx25_esdhc(imx_data)) {\n\t\t\t \n\t\t\tnew_val |= (val & SDHCI_CTRL_DMA_MASK) << 5;\n\t\t}\n\n\t\t \n\t\tmask = 0xffff & ~(ESDHC_CTRL_BUSWIDTH_MASK | ESDHC_CTRL_D3CD);\n\n\t\tesdhc_clrset_le(host, mask, new_val, reg);\n\t\treturn;\n\tcase SDHCI_SOFTWARE_RESET:\n\t\tif (val & SDHCI_RESET_DATA)\n\t\t\tnew_val = readl(host->ioaddr + SDHCI_HOST_CONTROL);\n\t\tbreak;\n\t}\n\tesdhc_clrset_le(host, 0xff, val, reg);\n\n\tif (reg == SDHCI_SOFTWARE_RESET) {\n\t\tif (val & SDHCI_RESET_ALL) {\n\t\t\t \n\t\t\tesdhc_clrset_le(host, 0x7, 0x7, ESDHC_SYSTEM_CONTROL);\n\t\t\t \n\t\t\tif (esdhc_is_usdhc(imx_data)) {\n\t\t\t\t \n\t\t\t\tnew_val = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\t\twritel(new_val & ESDHC_MIX_CTRL_TUNING_MASK,\n\t\t\t\t\t\thost->ioaddr + ESDHC_MIX_CTRL);\n\t\t\t\timx_data->is_ddr = 0;\n\t\t\t}\n\t\t} else if (val & SDHCI_RESET_DATA) {\n\t\t\t \n\t\t\tesdhc_clrset_le(host, 0xff, new_val,\n\t\t\t\t\tSDHCI_HOST_CONTROL);\n\t\t}\n\t}\n}\n\nstatic unsigned int esdhc_pltfm_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn pltfm_host->clock;\n}\n\nstatic unsigned int esdhc_pltfm_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn pltfm_host->clock / 256 / 16;\n}\n\nstatic inline void esdhc_pltfm_set_clock(struct sdhci_host *host,\n\t\t\t\t\t unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tunsigned int host_clock = pltfm_host->clock;\n\tint ddr_pre_div = imx_data->is_ddr ? 2 : 1;\n\tint pre_div = 1;\n\tint div = 1;\n\tint ret;\n\tu32 temp, val;\n\n\tif (esdhc_is_usdhc(imx_data)) {\n\t\tval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\twritel(val & ~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\n\t\t\thost->ioaddr + ESDHC_VENDOR_SPEC);\n\t\tesdhc_wait_for_card_clock_gate_off(host);\n\t}\n\n\tif (clock == 0) {\n\t\thost->mmc->actual_clock = 0;\n\t\treturn;\n\t}\n\n\t \n\tif (is_imx53_esdhc(imx_data)) {\n\t\t \n\t\tval = readl(host->ioaddr + ESDHC_DLL_CTRL);\n\t\twritel(val | BIT(10), host->ioaddr + ESDHC_DLL_CTRL);\n\t\ttemp = readl(host->ioaddr + ESDHC_DLL_CTRL);\n\t\twritel(val, host->ioaddr + ESDHC_DLL_CTRL);\n\t\tif (temp & BIT(10))\n\t\t\tpre_div = 2;\n\t}\n\n\ttemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\n\ttemp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\n\t\t| ESDHC_CLOCK_MASK);\n\tsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\n\n\tif ((imx_data->socdata->flags & ESDHC_FLAG_ERR010450) &&\n\t    (!(host->quirks2 & SDHCI_QUIRK2_NO_1_8_V))) {\n\t\tunsigned int max_clock;\n\n\t\tmax_clock = imx_data->is_ddr ? 45000000 : 150000000;\n\n\t\tclock = min(clock, max_clock);\n\t}\n\n\twhile (host_clock / (16 * pre_div * ddr_pre_div) > clock &&\n\t\t\tpre_div < 256)\n\t\tpre_div *= 2;\n\n\twhile (host_clock / (div * pre_div * ddr_pre_div) > clock && div < 16)\n\t\tdiv++;\n\n\thost->mmc->actual_clock = host_clock / (div * pre_div * ddr_pre_div);\n\tdev_dbg(mmc_dev(host->mmc), \"desired SD clock: %d, actual: %d\\n\",\n\t\tclock, host->mmc->actual_clock);\n\n\tpre_div >>= 1;\n\tdiv--;\n\n\ttemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\n\ttemp |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN\n\t\t| (div << ESDHC_DIVIDER_SHIFT)\n\t\t| (pre_div << ESDHC_PREDIV_SHIFT));\n\tsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\n\n\t \n\tret = readl_poll_timeout(host->ioaddr + ESDHC_PRSSTAT, temp,\n\t\t\t\t(temp & ESDHC_CLOCK_STABLE), 2, 100);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(mmc_dev(host->mmc), \"card clock still not stable in 100us!.\\n\");\n\n\tif (esdhc_is_usdhc(imx_data)) {\n\t\tval = readl(host->ioaddr + ESDHC_VENDOR_SPEC);\n\t\twritel(val | ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\n\t\t\thost->ioaddr + ESDHC_VENDOR_SPEC);\n\t}\n\n}\n\nstatic unsigned int esdhc_pltfm_get_ro(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\n\n\tswitch (boarddata->wp_type) {\n\tcase ESDHC_WP_GPIO:\n\t\treturn mmc_gpio_get_ro(host->mmc);\n\tcase ESDHC_WP_CONTROLLER:\n\t\treturn !(readl(host->ioaddr + SDHCI_PRESENT_STATE) &\n\t\t\t       SDHCI_WRITE_PROTECT);\n\tcase ESDHC_WP_NONE:\n\t\tbreak;\n\t}\n\n\treturn -ENOSYS;\n}\n\nstatic void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)\n{\n\tu32 ctrl;\n\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tctrl = ESDHC_CTRL_8BITBUS;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tctrl = ESDHC_CTRL_4BITBUS;\n\t\tbreak;\n\tdefault:\n\t\tctrl = 0;\n\t\tbreak;\n\t}\n\n\tesdhc_clrset_le(host, ESDHC_CTRL_BUSWIDTH_MASK, ctrl,\n\t\t\tSDHCI_HOST_CONTROL);\n}\n\nstatic void esdhc_reset_tuning(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 ctrl;\n\tint ret;\n\n\t \n\tif (esdhc_is_usdhc(imx_data)) {\n\t\tctrl = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\t\tctrl &= ~ESDHC_MIX_CTRL_AUTO_TUNE_EN;\n\t\tif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING) {\n\t\t\tctrl &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\n\t\t\tctrl &= ~ESDHC_MIX_CTRL_FBCLK_SEL;\n\t\t\twritel(ctrl, host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\twritel(0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\n\t\t} else if (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\n\t\t\twritel(ctrl, host->ioaddr + ESDHC_MIX_CTRL);\n\t\t\tctrl = readl(host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\t\tctrl &= ~ESDHC_MIX_CTRL_SMPCLK_SEL;\n\t\t\tctrl &= ~ESDHC_MIX_CTRL_EXE_TUNE;\n\t\t\twritel(ctrl, host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\t\t \n\t\t\tret = readl_poll_timeout(host->ioaddr + SDHCI_AUTO_CMD_STATUS,\n\t\t\t\tctrl, !(ctrl & ESDHC_MIX_CTRL_EXE_TUNE), 1, 50);\n\t\t\tif (ret == -ETIMEDOUT)\n\t\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"Warning! clear execute tuning bit failed\\n\");\n\t\t\t \n\t\t\tctrl = readl(host->ioaddr + SDHCI_INT_STATUS);\n\t\t\tctrl |= SDHCI_INT_DATA_AVAIL;\n\t\t\twritel(ctrl, host->ioaddr + SDHCI_INT_STATUS);\n\t\t}\n\t}\n}\n\nstatic void usdhc_init_card(struct mmc_host *mmc, struct mmc_card *card)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\n\timx_data->init_card_type = card->type;\n}\n\nstatic int usdhc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tint err;\n\n\t \n\tif (host->timing == MMC_TIMING_UHS_DDR50)\n\t\treturn 0;\n\n\t \n\tesdhc_reset_tuning(host);\n\terr = sdhci_execute_tuning(mmc, opcode);\n\t \n\tif (!err && !host->tuning_err)\n\t\tusdhc_auto_tuning_mode_sel_and_en(host);\n\n\treturn err;\n}\n\nstatic void esdhc_prepare_tuning(struct sdhci_host *host, u32 val)\n{\n\tu32 reg;\n\tu8 sw_rst;\n\tint ret;\n\n\t \n\tmdelay(1);\n\n\t \n\tesdhc_clrset_le(host, 0xff, SDHCI_RESET_ALL, SDHCI_SOFTWARE_RESET);\n\tret = readb_poll_timeout(host->ioaddr + SDHCI_SOFTWARE_RESET, sw_rst,\n\t\t\t\t!(sw_rst & SDHCI_RESET_ALL), 10, 100);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\"warning! RESET_ALL never complete before sending tuning command\\n\");\n\n\treg = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\treg |= ESDHC_MIX_CTRL_EXE_TUNE | ESDHC_MIX_CTRL_SMPCLK_SEL |\n\t\t\tESDHC_MIX_CTRL_FBCLK_SEL;\n\twritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\n\twritel(val << 8, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"tuning with delay 0x%x ESDHC_TUNE_CTRL_STATUS 0x%x\\n\",\n\t\t\tval, readl(host->ioaddr + ESDHC_TUNE_CTRL_STATUS));\n}\n\nstatic void esdhc_post_tuning(struct sdhci_host *host)\n{\n\tu32 reg;\n\n\treg = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\treg &= ~ESDHC_MIX_CTRL_EXE_TUNE;\n\twritel(reg, host->ioaddr + ESDHC_MIX_CTRL);\n}\n\nstatic int esdhc_executing_tuning(struct sdhci_host *host, u32 opcode)\n{\n\tint min, max, avg, ret;\n\n\t \n\tmin = ESDHC_TUNE_CTRL_MIN;\n\twhile (min < ESDHC_TUNE_CTRL_MAX) {\n\t\tesdhc_prepare_tuning(host, min);\n\t\tif (!mmc_send_tuning(host->mmc, opcode, NULL))\n\t\t\tbreak;\n\t\tmin += ESDHC_TUNE_CTRL_STEP;\n\t}\n\n\t \n\tmax = min + ESDHC_TUNE_CTRL_STEP;\n\twhile (max < ESDHC_TUNE_CTRL_MAX) {\n\t\tesdhc_prepare_tuning(host, max);\n\t\tif (mmc_send_tuning(host->mmc, opcode, NULL)) {\n\t\t\tmax -= ESDHC_TUNE_CTRL_STEP;\n\t\t\tbreak;\n\t\t}\n\t\tmax += ESDHC_TUNE_CTRL_STEP;\n\t}\n\n\t \n\tavg = (min + max) / 2;\n\tesdhc_prepare_tuning(host, avg);\n\tret = mmc_send_tuning(host->mmc, opcode, NULL);\n\tesdhc_post_tuning(host);\n\n\tdev_dbg(mmc_dev(host->mmc), \"tuning %s at 0x%x ret %d\\n\",\n\t\tret ? \"failed\" : \"passed\", avg, ret);\n\n\treturn ret;\n}\n\nstatic void esdhc_hs400_enhanced_strobe(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 m;\n\n\tm = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\tif (ios->enhanced_strobe)\n\t\tm |= ESDHC_MIX_CTRL_HS400_ES_EN;\n\telse\n\t\tm &= ~ESDHC_MIX_CTRL_HS400_ES_EN;\n\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n}\n\nstatic int esdhc_change_pinstate(struct sdhci_host *host,\n\t\t\t\t\t\tunsigned int uhs)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tstruct pinctrl_state *pinctrl;\n\n\tdev_dbg(mmc_dev(host->mmc), \"change pinctrl state for uhs %d\\n\", uhs);\n\n\tif (IS_ERR(imx_data->pinctrl) ||\n\t\tIS_ERR(imx_data->pins_100mhz) ||\n\t\tIS_ERR(imx_data->pins_200mhz))\n\t\treturn -EINVAL;\n\n\tswitch (uhs) {\n\tcase MMC_TIMING_UHS_SDR50:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tpinctrl = imx_data->pins_100mhz;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\tcase MMC_TIMING_MMC_HS400:\n\t\tpinctrl = imx_data->pins_200mhz;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn pinctrl_select_default_state(mmc_dev(host->mmc));\n\t}\n\n\treturn pinctrl_select_state(imx_data->pinctrl, pinctrl);\n}\n\n \nstatic void esdhc_set_strobe_dll(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tu32 strobe_delay;\n\tu32 v;\n\tint ret;\n\n\t \n\twritel(readl(host->ioaddr + ESDHC_VENDOR_SPEC) &\n\t\t~ESDHC_VENDOR_SPEC_FRC_SDCLK_ON,\n\t\thost->ioaddr + ESDHC_VENDOR_SPEC);\n\tesdhc_wait_for_card_clock_gate_off(host);\n\n\t \n\twritel(ESDHC_STROBE_DLL_CTRL_RESET,\n\t\thost->ioaddr + ESDHC_STROBE_DLL_CTRL);\n\t \n\twritel(0, host->ioaddr + ESDHC_STROBE_DLL_CTRL);\n\n\t \n\tif (imx_data->boarddata.strobe_dll_delay_target)\n\t\tstrobe_delay = imx_data->boarddata.strobe_dll_delay_target;\n\telse\n\t\tstrobe_delay = ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_DEFAULT;\n\tv = ESDHC_STROBE_DLL_CTRL_ENABLE |\n\t\tESDHC_STROBE_DLL_CTRL_SLV_UPDATE_INT_DEFAULT |\n\t\t(strobe_delay << ESDHC_STROBE_DLL_CTRL_SLV_DLY_TARGET_SHIFT);\n\twritel(v, host->ioaddr + ESDHC_STROBE_DLL_CTRL);\n\n\t \n\tret = readl_poll_timeout(host->ioaddr + ESDHC_STROBE_DLL_STATUS, v,\n\t\t((v & ESDHC_STROBE_DLL_STS_REF_LOCK) && (v & ESDHC_STROBE_DLL_STS_SLV_LOCK)), 1, 50);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\"warning! HS400 strobe DLL status REF/SLV not lock in 50us, STROBE DLL status is %x!\\n\", v);\n}\n\nstatic void esdhc_set_uhs_signaling(struct sdhci_host *host, unsigned timing)\n{\n\tu32 m;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\n\n\t \n\tm = readl(host->ioaddr + ESDHC_MIX_CTRL);\n\tm &= ~(ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN);\n\timx_data->is_ddr = 0;\n\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR12:\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_SDR50:\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_MMC_HS200:\n\t\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tm |= ESDHC_MIX_CTRL_DDREN;\n\t\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n\t\timx_data->is_ddr = 1;\n\t\tif (boarddata->delay_line) {\n\t\t\tu32 v;\n\t\t\tv = boarddata->delay_line <<\n\t\t\t\tESDHC_DLL_OVERRIDE_VAL_SHIFT |\n\t\t\t\t(1 << ESDHC_DLL_OVERRIDE_EN_SHIFT);\n\t\t\tif (is_imx53_esdhc(imx_data))\n\t\t\t\tv <<= 1;\n\t\t\twritel(v, host->ioaddr + ESDHC_DLL_CTRL);\n\t\t}\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tm |= ESDHC_MIX_CTRL_DDREN | ESDHC_MIX_CTRL_HS400_EN;\n\t\twritel(m, host->ioaddr + ESDHC_MIX_CTRL);\n\t\timx_data->is_ddr = 1;\n\t\t \n\t\thost->ops->set_clock(host, host->clock);\n\t\tesdhc_set_strobe_dll(host);\n\t\tbreak;\n\tcase MMC_TIMING_LEGACY:\n\tdefault:\n\t\tesdhc_reset_tuning(host);\n\t\tbreak;\n\t}\n\n\tesdhc_change_pinstate(host, timing);\n}\n\nstatic void esdhc_reset(struct sdhci_host *host, u8 mask)\n{\n\tsdhci_and_cqhci_reset(host, mask);\n\n\tsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\n}\n\nstatic unsigned int esdhc_get_max_timeout_count(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\n\t \n\treturn esdhc_is_usdhc(imx_data) ? 1 << 29 : 1 << 27;\n}\n\nstatic void esdhc_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\n\t \n\tesdhc_clrset_le(host, ESDHC_SYS_CTRL_DTOCV_MASK,\n\t\t\tesdhc_is_usdhc(imx_data) ? 0xF : 0xE,\n\t\t\tSDHCI_TIMEOUT_CONTROL);\n}\n\nstatic u32 esdhc_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\nstatic struct sdhci_ops sdhci_esdhc_ops = {\n\t.read_l = esdhc_readl_le,\n\t.read_w = esdhc_readw_le,\n\t.read_b = esdhc_readb_le,\n\t.write_l = esdhc_writel_le,\n\t.write_w = esdhc_writew_le,\n\t.write_b = esdhc_writeb_le,\n\t.set_clock = esdhc_pltfm_set_clock,\n\t.get_max_clock = esdhc_pltfm_get_max_clock,\n\t.get_min_clock = esdhc_pltfm_get_min_clock,\n\t.get_max_timeout_count = esdhc_get_max_timeout_count,\n\t.get_ro = esdhc_pltfm_get_ro,\n\t.set_timeout = esdhc_set_timeout,\n\t.set_bus_width = esdhc_pltfm_set_bus_width,\n\t.set_uhs_signaling = esdhc_set_uhs_signaling,\n\t.reset = esdhc_reset,\n\t.irq = esdhc_cqhci_irq,\n\t.dump_vendor_regs = esdhc_dump_debug_regs,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_esdhc_imx_pdata = {\n\t.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_NO_HISPD_BIT\n\t\t\t| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC\n\t\t\t| SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC\n\t\t\t| SDHCI_QUIRK_BROKEN_CARD_DETECTION,\n\t.ops = &sdhci_esdhc_ops,\n};\n\nstatic void sdhci_esdhc_imx_hwinit(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tstruct cqhci_host *cq_host = host->mmc->cqe_private;\n\tu32 tmp;\n\n\tif (esdhc_is_usdhc(imx_data)) {\n\t\t \n\t\twritel(ESDHC_WTMK_DEFAULT_VAL, host->ioaddr + ESDHC_WTMK_LVL);\n\n\t\t \n\t\twritel(readl(host->ioaddr + SDHCI_HOST_CONTROL)\n\t\t\t| ESDHC_BURST_LEN_EN_INCR,\n\t\t\thost->ioaddr + SDHCI_HOST_CONTROL);\n\n\t\t \n\t\tif (!(imx_data->socdata->flags & ESDHC_FLAG_SKIP_ERR004536)) {\n\t\t\twritel(readl(host->ioaddr + 0x6c) & ~BIT(7),\n\t\t\t\thost->ioaddr + 0x6c);\n\t\t}\n\n\t\t \n\t\twritel(0x0, host->ioaddr + ESDHC_DLL_CTRL);\n\n\t\t \n\t\tif (imx_data->socdata->flags & ESDHC_FLAG_CQHCI) {\n\t\t\ttmp = readl(host->ioaddr + ESDHC_VEND_SPEC2);\n\t\t\ttmp |= ESDHC_VEND_SPEC2_EN_BUSY_IRQ;\n\t\t\twritel(tmp, host->ioaddr + ESDHC_VEND_SPEC2);\n\n\t\t\thost->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;\n\t\t}\n\n\t\tif (imx_data->socdata->flags & ESDHC_FLAG_STD_TUNING) {\n\t\t\ttmp = readl(host->ioaddr + ESDHC_TUNING_CTRL);\n\t\t\ttmp |= ESDHC_STD_TUNING_EN;\n\n\t\t\t \n\t\t\ttmp &= ~(ESDHC_TUNING_START_TAP_MASK | ESDHC_TUNING_STEP_MASK);\n\t\t\tif (imx_data->boarddata.tuning_start_tap)\n\t\t\t\ttmp |= imx_data->boarddata.tuning_start_tap;\n\t\t\telse\n\t\t\t\ttmp |= ESDHC_TUNING_START_TAP_DEFAULT;\n\n\t\t\tif (imx_data->boarddata.tuning_step) {\n\t\t\t\ttmp |= imx_data->boarddata.tuning_step\n\t\t\t\t\t<< ESDHC_TUNING_STEP_SHIFT;\n\t\t\t} else {\n\t\t\t\ttmp |= ESDHC_TUNING_STEP_DEFAULT\n\t\t\t\t\t<< ESDHC_TUNING_STEP_SHIFT;\n\t\t\t}\n\n\t\t\t \n\t\t\ttmp |= ESDHC_TUNING_CMD_CRC_CHECK_DISABLE;\n\t\t\twritel(tmp, host->ioaddr + ESDHC_TUNING_CTRL);\n\t\t} else if (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING) {\n\t\t\t \n\t\t\ttmp = readl(host->ioaddr + ESDHC_TUNING_CTRL);\n\t\t\ttmp &= ~ESDHC_STD_TUNING_EN;\n\t\t\twritel(tmp, host->ioaddr + ESDHC_TUNING_CTRL);\n\t\t}\n\n\t\t \n\t\tif (cq_host) {\n\t\t\ttmp = cqhci_readl(cq_host, CQHCI_IS);\n\t\t\tcqhci_writel(cq_host, tmp, CQHCI_IS);\n\t\t\tcqhci_writel(cq_host, CQHCI_HALT, CQHCI_CTL);\n\t\t}\n\t}\n}\n\nstatic void esdhc_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu32 reg;\n\tu16 mode;\n\tint count = 10;\n\n\t \n\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\twhile (reg & SDHCI_DATA_AVAILABLE) {\n\t\tsdhci_readl(host, SDHCI_BUFFER);\n\t\treg = sdhci_readl(host, SDHCI_PRESENT_STATE);\n\t\tif (count-- == 0) {\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t\"CQE may get stuck because the Buffer Read Enable bit is set\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tmdelay(1);\n\t}\n\n\t \n\tmode = sdhci_readw(host, SDHCI_TRANSFER_MODE);\n\tif (host->flags & SDHCI_REQ_USE_DMA)\n\t\tmode |= SDHCI_TRNS_DMA;\n\tif (!(host->quirks2 & SDHCI_QUIRK2_SUPPORT_SINGLE))\n\t\tmode |= SDHCI_TRNS_BLK_CNT_EN;\n\tsdhci_writew(host, mode, SDHCI_TRANSFER_MODE);\n\n\t \n\tcqhci_writel(cq_host, 0, CQHCI_CTL);\n\tif (cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_HALT)\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"failed to exit halt state when enable CQE\\n\");\n\n\n\tsdhci_cqe_enable(mmc);\n}\n\nstatic void esdhc_sdhci_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\nstatic const struct cqhci_host_ops esdhc_cqhci_ops = {\n\t.enable\t\t= esdhc_cqe_enable,\n\t.disable\t= sdhci_cqe_disable,\n\t.dumpregs\t= esdhc_sdhci_dumpregs,\n};\n\nstatic int\nsdhci_esdhc_imx_probe_dt(struct platform_device *pdev,\n\t\t\t struct sdhci_host *host,\n\t\t\t struct pltfm_imx_data *imx_data)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct esdhc_platform_data *boarddata = &imx_data->boarddata;\n\tint ret;\n\n\tif (of_property_read_bool(np, \"fsl,wp-controller\"))\n\t\tboarddata->wp_type = ESDHC_WP_CONTROLLER;\n\n\t \n\tif (of_property_read_bool(np, \"wp-gpios\"))\n\t\tboarddata->wp_type = ESDHC_WP_GPIO;\n\n\tof_property_read_u32(np, \"fsl,tuning-step\", &boarddata->tuning_step);\n\tof_property_read_u32(np, \"fsl,tuning-start-tap\",\n\t\t\t     &boarddata->tuning_start_tap);\n\n\tof_property_read_u32(np, \"fsl,strobe-dll-delay-target\",\n\t\t\t\t&boarddata->strobe_dll_delay_target);\n\tif (of_property_read_bool(np, \"no-1-8-v\"))\n\t\thost->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\n\n\tif (of_property_read_u32(np, \"fsl,delay-line\", &boarddata->delay_line))\n\t\tboarddata->delay_line = 0;\n\n\tmmc_of_parse_voltage(host->mmc, &host->ocr_mask);\n\n\tif (esdhc_is_usdhc(imx_data) && !IS_ERR(imx_data->pinctrl)) {\n\t\timx_data->pins_100mhz = pinctrl_lookup_state(imx_data->pinctrl,\n\t\t\t\t\t\tESDHC_PINCTRL_STATE_100MHZ);\n\t\timx_data->pins_200mhz = pinctrl_lookup_state(imx_data->pinctrl,\n\t\t\t\t\t\tESDHC_PINCTRL_STATE_200MHZ);\n\t}\n\n\t \n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (!(host->mmc->caps & MMC_CAP_8_BIT_DATA))\n\t\thost->mmc->caps2 &= ~(MMC_CAP2_HS400 | MMC_CAP2_HS400_ES);\n\n\tif (mmc_gpio_get_cd(host->mmc) >= 0)\n\t\thost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\n\treturn 0;\n}\n\nstatic int sdhci_esdhc_imx_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_host *host;\n\tstruct cqhci_host *cq_host;\n\tint err;\n\tstruct pltfm_imx_data *imx_data;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_esdhc_imx_pdata,\n\t\t\t\tsizeof(*imx_data));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\n\timx_data = sdhci_pltfm_priv(pltfm_host);\n\n\timx_data->socdata = device_get_match_data(&pdev->dev);\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_add_request(&imx_data->pm_qos_req, 0);\n\n\timx_data->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(imx_data->clk_ipg)) {\n\t\terr = PTR_ERR(imx_data->clk_ipg);\n\t\tgoto free_sdhci;\n\t}\n\n\timx_data->clk_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(imx_data->clk_ahb)) {\n\t\terr = PTR_ERR(imx_data->clk_ahb);\n\t\tgoto free_sdhci;\n\t}\n\n\timx_data->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(imx_data->clk_per)) {\n\t\terr = PTR_ERR(imx_data->clk_per);\n\t\tgoto free_sdhci;\n\t}\n\n\tpltfm_host->clk = imx_data->clk_per;\n\tpltfm_host->clock = clk_get_rate(pltfm_host->clk);\n\terr = clk_prepare_enable(imx_data->clk_per);\n\tif (err)\n\t\tgoto free_sdhci;\n\terr = clk_prepare_enable(imx_data->clk_ipg);\n\tif (err)\n\t\tgoto disable_per_clk;\n\terr = clk_prepare_enable(imx_data->clk_ahb);\n\tif (err)\n\t\tgoto disable_ipg_clk;\n\n\timx_data->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(imx_data->pinctrl))\n\t\tdev_warn(mmc_dev(host->mmc), \"could not get pinctrl\\n\");\n\n\tif (esdhc_is_usdhc(imx_data)) {\n\t\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\t\thost->mmc->caps |= MMC_CAP_1_8V_DDR | MMC_CAP_3_3V_DDR;\n\n\t\t \n\t\thost->mmc->caps |= MMC_CAP_CD_WAKE;\n\n\t\tif (!(imx_data->socdata->flags & ESDHC_FLAG_HS200))\n\t\t\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;\n\n\t\t \n\t\twritel(0x0, host->ioaddr + ESDHC_MIX_CTRL);\n\t\twritel(0x0, host->ioaddr + SDHCI_AUTO_CMD_STATUS);\n\t\twritel(0x0, host->ioaddr + ESDHC_TUNE_CTRL_STATUS);\n\n\t\t \n\t\thost->mmc_host_ops.execute_tuning = usdhc_execute_tuning;\n\n\t\t \n\t\thost->mmc_host_ops.init_card = usdhc_init_card;\n\t}\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_MAN_TUNING)\n\t\tsdhci_esdhc_ops.platform_execute_tuning =\n\t\t\t\t\tesdhc_executing_tuning;\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_ERR004536)\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_ADMA;\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_HS400)\n\t\thost->mmc->caps2 |= MMC_CAP2_HS400;\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_BROKEN_AUTO_CMD23)\n\t\thost->quirks2 |= SDHCI_QUIRK2_ACMD23_BROKEN;\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_HS400_ES) {\n\t\thost->mmc->caps2 |= MMC_CAP2_HS400_ES;\n\t\thost->mmc_host_ops.hs400_enhanced_strobe =\n\t\t\t\t\tesdhc_hs400_enhanced_strobe;\n\t}\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_CQHCI) {\n\t\thost->mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;\n\t\tcq_host = devm_kzalloc(&pdev->dev, sizeof(*cq_host), GFP_KERNEL);\n\t\tif (!cq_host) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto disable_ahb_clk;\n\t\t}\n\n\t\tcq_host->mmio = host->ioaddr + ESDHC_CQHCI_ADDR_OFFSET;\n\t\tcq_host->ops = &esdhc_cqhci_ops;\n\n\t\terr = cqhci_init(cq_host, host->mmc, false);\n\t\tif (err)\n\t\t\tgoto disable_ahb_clk;\n\t}\n\n\terr = sdhci_esdhc_imx_probe_dt(pdev, host, imx_data);\n\tif (err)\n\t\tgoto disable_ahb_clk;\n\n\tsdhci_esdhc_imx_hwinit(host);\n\n\terr = sdhci_add_host(host);\n\tif (err)\n\t\tgoto disable_ahb_clk;\n\n\t \n\tif ((host->mmc->pm_caps & MMC_PM_KEEP_POWER) &&\n\t\t\t(host->mmc->pm_caps & MMC_PM_WAKE_SDIO_IRQ))\n\t\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\ndisable_ahb_clk:\n\tclk_disable_unprepare(imx_data->clk_ahb);\ndisable_ipg_clk:\n\tclk_disable_unprepare(imx_data->clk_ipg);\ndisable_per_clk:\n\tclk_disable_unprepare(imx_data->clk_per);\nfree_sdhci:\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_remove_request(&imx_data->pm_qos_req);\n\tsdhci_pltfm_free(pdev);\n\treturn err;\n}\n\nstatic void sdhci_esdhc_imx_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tint dead;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tdead = (readl(host->ioaddr + SDHCI_INT_STATUS) == 0xffffffff);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tsdhci_remove_host(host, dead);\n\n\tclk_disable_unprepare(imx_data->clk_per);\n\tclk_disable_unprepare(imx_data->clk_ipg);\n\tclk_disable_unprepare(imx_data->clk_ahb);\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_remove_request(&imx_data->pm_qos_req);\n\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_esdhc_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE) {\n\t\tret = cqhci_suspend(host->mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif ((imx_data->socdata->flags & ESDHC_FLAG_STATE_LOST_IN_LPMODE) &&\n\t\t(host->tuning_mode != SDHCI_TUNING_MODE_1)) {\n\t\tmmc_retune_timer_stop(host->mmc);\n\t\tmmc_retune_needed(host->mmc);\n\t}\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = sdhci_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pinctrl_pm_select_sleep_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_gpio_set_cd_wake(host->mmc, true);\n\n\treturn ret;\n}\n\nstatic int sdhci_esdhc_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = pinctrl_pm_select_default_state(dev);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsdhci_esdhc_imx_hwinit(host);\n\n\tret = sdhci_resume_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE)\n\t\tret = cqhci_resume(host->mmc);\n\n\tif (!ret)\n\t\tret = mmc_gpio_set_cd_wake(host->mmc, false);\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sdhci_esdhc_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE) {\n\t\tret = cqhci_suspend(host->mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sdhci_runtime_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\timx_data->actual_clock = host->mmc->actual_clock;\n\tesdhc_pltfm_set_clock(host, 0);\n\tclk_disable_unprepare(imx_data->clk_per);\n\tclk_disable_unprepare(imx_data->clk_ipg);\n\tclk_disable_unprepare(imx_data->clk_ahb);\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_remove_request(&imx_data->pm_qos_req);\n\n\treturn ret;\n}\n\nstatic int sdhci_esdhc_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_imx_data *imx_data = sdhci_pltfm_priv(pltfm_host);\n\tint err;\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_add_request(&imx_data->pm_qos_req, 0);\n\n\tif (imx_data->socdata->flags & ESDHC_FLAG_CLK_RATE_LOST_IN_PM_RUNTIME)\n\t\tclk_set_rate(imx_data->clk_per, pltfm_host->clock);\n\n\terr = clk_prepare_enable(imx_data->clk_ahb);\n\tif (err)\n\t\tgoto remove_pm_qos_request;\n\n\terr = clk_prepare_enable(imx_data->clk_per);\n\tif (err)\n\t\tgoto disable_ahb_clk;\n\n\terr = clk_prepare_enable(imx_data->clk_ipg);\n\tif (err)\n\t\tgoto disable_per_clk;\n\n\tesdhc_pltfm_set_clock(host, imx_data->actual_clock);\n\n\terr = sdhci_runtime_resume_host(host, 0);\n\tif (err)\n\t\tgoto disable_ipg_clk;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE)\n\t\terr = cqhci_resume(host->mmc);\n\n\treturn err;\n\ndisable_ipg_clk:\n\tclk_disable_unprepare(imx_data->clk_ipg);\ndisable_per_clk:\n\tclk_disable_unprepare(imx_data->clk_per);\ndisable_ahb_clk:\n\tclk_disable_unprepare(imx_data->clk_ahb);\nremove_pm_qos_request:\n\tif (imx_data->socdata->flags & ESDHC_FLAG_PMQOS)\n\t\tcpu_latency_qos_remove_request(&imx_data->pm_qos_req);\n\treturn err;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_esdhc_pmops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_esdhc_suspend, sdhci_esdhc_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_esdhc_runtime_suspend,\n\t\t\t\tsdhci_esdhc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sdhci_esdhc_imx_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-esdhc-imx\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = imx_esdhc_dt_ids,\n\t\t.pm\t= &sdhci_esdhc_pmops,\n\t},\n\t.probe\t\t= sdhci_esdhc_imx_probe,\n\t.remove_new\t= sdhci_esdhc_imx_remove,\n};\n\nmodule_platform_driver(sdhci_esdhc_imx_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for Freescale i.MX eSDHC\");\nMODULE_AUTHOR(\"Wolfram Sang <kernel@pengutronix.de>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}