{
  "module_name": "meson-mx-sdhc-mmc.c",
  "hash_id": "b304ba6606e6ded4c78b145d47761b8c96dbcd64fb9a9bd03ca3044082cd9b30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/meson-mx-sdhc-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/types.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include \"meson-mx-sdhc.h\"\n\n#define MESON_SDHC_NUM_BULK_CLKS\t\t\t\t4\n#define MESON_SDHC_MAX_BLK_SIZE\t\t\t\t\t512\n#define MESON_SDHC_NUM_TUNING_TRIES\t\t\t\t10\n\n#define MESON_SDHC_WAIT_CMD_READY_SLEEP_US\t\t\t1\n#define MESON_SDHC_WAIT_CMD_READY_TIMEOUT_US\t\t\t100000\n#define MESON_SDHC_WAIT_BEFORE_SEND_SLEEP_US\t\t\t1\n#define MESON_SDHC_WAIT_BEFORE_SEND_TIMEOUT_US\t\t\t200\n\nstruct meson_mx_sdhc_data {\n\tvoid\t\t(*init_hw)(struct mmc_host *mmc);\n\tvoid\t\t(*set_pdma)(struct mmc_host *mmc);\n\tvoid\t\t(*wait_before_send)(struct mmc_host *mmc);\n\tbool\t\thardware_flush_all_cmds;\n};\n\nstruct meson_mx_sdhc_host {\n\tstruct mmc_host\t\t\t*mmc;\n\n\tstruct mmc_request\t\t*mrq;\n\tstruct mmc_command\t\t*cmd;\n\tint\t\t\t\terror;\n\n\tstruct regmap\t\t\t*regmap;\n\n\tstruct clk\t\t\t*pclk;\n\tstruct clk\t\t\t*sd_clk;\n\tstruct clk_bulk_data\t\tbulk_clks[MESON_SDHC_NUM_BULK_CLKS];\n\tbool\t\t\t\tbulk_clks_enabled;\n\n\tconst struct meson_mx_sdhc_data\t*platform;\n};\n\nstatic const struct regmap_config meson_mx_sdhc_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 32,\n\t.reg_stride = 4,\n\t.max_register = MESON_SDHC_CLK2,\n};\n\nstatic void meson_mx_sdhc_hw_reset(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tregmap_write(host->regmap, MESON_SDHC_SRST, MESON_SDHC_SRST_MAIN_CTRL |\n\t\t     MESON_SDHC_SRST_RXFIFO | MESON_SDHC_SRST_TXFIFO |\n\t\t     MESON_SDHC_SRST_DPHY_RX | MESON_SDHC_SRST_DPHY_TX |\n\t\t     MESON_SDHC_SRST_DMA_IF);\n\tusleep_range(10, 100);\n\n\tregmap_write(host->regmap, MESON_SDHC_SRST, 0);\n\tusleep_range(10, 100);\n}\n\nstatic void meson_mx_sdhc_clear_fifo(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tu32 stat;\n\n\tregmap_read(host->regmap, MESON_SDHC_STAT, &stat);\n\tif (!FIELD_GET(MESON_SDHC_STAT_RXFIFO_CNT, stat) &&\n\t    !FIELD_GET(MESON_SDHC_STAT_TXFIFO_CNT, stat))\n\t\treturn;\n\n\tregmap_write(host->regmap, MESON_SDHC_SRST, MESON_SDHC_SRST_RXFIFO |\n\t\t     MESON_SDHC_SRST_TXFIFO | MESON_SDHC_SRST_MAIN_CTRL);\n\tudelay(5);\n\n\tregmap_read(host->regmap, MESON_SDHC_STAT, &stat);\n\tif (FIELD_GET(MESON_SDHC_STAT_RXFIFO_CNT, stat) ||\n\t    FIELD_GET(MESON_SDHC_STAT_TXFIFO_CNT, stat))\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"Failed to clear FIFOs, RX: %lu, TX: %lu\\n\",\n\t\t\t FIELD_GET(MESON_SDHC_STAT_RXFIFO_CNT, stat),\n\t\t\t FIELD_GET(MESON_SDHC_STAT_TXFIFO_CNT, stat));\n}\n\nstatic void meson_mx_sdhc_wait_cmd_ready(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tu32 stat, esta;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(host->regmap, MESON_SDHC_STAT, stat,\n\t\t\t\t       !(stat & MESON_SDHC_STAT_CMD_BUSY),\n\t\t\t\t       MESON_SDHC_WAIT_CMD_READY_SLEEP_US,\n\t\t\t\t       MESON_SDHC_WAIT_CMD_READY_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_warn(mmc_dev(mmc),\n\t\t\t \"Failed to poll for CMD_BUSY while processing CMD%d\\n\",\n\t\t\t host->cmd->opcode);\n\t\tmeson_mx_sdhc_hw_reset(mmc);\n\t}\n\n\tret = regmap_read_poll_timeout(host->regmap, MESON_SDHC_ESTA, esta,\n\t\t\t\t       !(esta & MESON_SDHC_ESTA_11_13),\n\t\t\t\t       MESON_SDHC_WAIT_CMD_READY_SLEEP_US,\n\t\t\t\t       MESON_SDHC_WAIT_CMD_READY_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_warn(mmc_dev(mmc),\n\t\t\t \"Failed to poll for ESTA[13:11] while processing CMD%d\\n\",\n\t\t\t host->cmd->opcode);\n\t\tmeson_mx_sdhc_hw_reset(mmc);\n\t}\n}\n\nstatic void meson_mx_sdhc_start_cmd(struct mmc_host *mmc,\n\t\t\t\t    struct mmc_command *cmd)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tbool manual_stop = false;\n\tu32 ictl, send;\n\tint pack_len;\n\n\thost->cmd = cmd;\n\n\tictl = MESON_SDHC_ICTL_DATA_TIMEOUT | MESON_SDHC_ICTL_DATA_ERR_CRC |\n\t       MESON_SDHC_ICTL_RXFIFO_FULL | MESON_SDHC_ICTL_TXFIFO_EMPTY |\n\t       MESON_SDHC_ICTL_RESP_TIMEOUT | MESON_SDHC_ICTL_RESP_ERR_CRC;\n\n\tsend = FIELD_PREP(MESON_SDHC_SEND_CMD_INDEX, cmd->opcode);\n\n\tif (cmd->data) {\n\t\tsend |= MESON_SDHC_SEND_CMD_HAS_DATA;\n\t\tsend |= FIELD_PREP(MESON_SDHC_SEND_TOTAL_PACK,\n\t\t\t\t   cmd->data->blocks - 1);\n\n\t\tif (cmd->data->blksz < MESON_SDHC_MAX_BLK_SIZE)\n\t\t\tpack_len = cmd->data->blksz;\n\t\telse\n\t\t\tpack_len = 0;\n\n\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\tsend |= MESON_SDHC_SEND_DATA_DIR;\n\n\t\t \n\t\tif (host->platform->hardware_flush_all_cmds ||\n\t\t    cmd->data->flags & MMC_DATA_WRITE)\n\t\t\t \n\t\t\tictl |= MESON_SDHC_ICTL_DMA_DONE;\n\t\telse\n\t\t\t \n\t\t\tictl |= MESON_SDHC_ICTL_DATA_XFER_OK;\n\n\t\t \n\t\tmanual_stop = cmd->data->blocks > 1 &&\n\t\t\t      cmd->opcode == SD_IO_RW_EXTENDED;\n\t} else {\n\t\tpack_len = 0;\n\n\t\tictl |= MESON_SDHC_ICTL_RESP_OK;\n\t}\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_MISC,\n\t\t\t   MESON_SDHC_MISC_MANUAL_STOP,\n\t\t\t   manual_stop ? MESON_SDHC_MISC_MANUAL_STOP : 0);\n\n\tif (cmd->opcode == MMC_STOP_TRANSMISSION)\n\t\tsend |= MESON_SDHC_SEND_DATA_STOP;\n\n\tif (cmd->flags & MMC_RSP_PRESENT)\n\t\tsend |= MESON_SDHC_SEND_CMD_HAS_RESP;\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tsend |= MESON_SDHC_SEND_RESP_LEN;\n\t\tsend |= MESON_SDHC_SEND_RESP_NO_CRC;\n\t}\n\n\tif (!(cmd->flags & MMC_RSP_CRC))\n\t\tsend |= MESON_SDHC_SEND_RESP_NO_CRC;\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tsend |= MESON_SDHC_SEND_R1B;\n\n\t \n\tregmap_write(host->regmap, MESON_SDHC_ICTL, ictl);\n\tregmap_write(host->regmap, MESON_SDHC_ISTA, MESON_SDHC_ISTA_ALL_IRQS);\n\n\tregmap_write(host->regmap, MESON_SDHC_ARGU, cmd->arg);\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_CTRL,\n\t\t\t   MESON_SDHC_CTRL_PACK_LEN,\n\t\t\t   FIELD_PREP(MESON_SDHC_CTRL_PACK_LEN, pack_len));\n\n\tif (cmd->data)\n\t\tregmap_write(host->regmap, MESON_SDHC_ADDR,\n\t\t\t     sg_dma_address(cmd->data->sg));\n\n\tmeson_mx_sdhc_wait_cmd_ready(mmc);\n\n\tif (cmd->data)\n\t\thost->platform->set_pdma(mmc);\n\n\tif (host->platform->wait_before_send)\n\t\thost->platform->wait_before_send(mmc);\n\n\tregmap_write(host->regmap, MESON_SDHC_SEND, send);\n}\n\nstatic void meson_mx_sdhc_disable_clks(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tif (!host->bulk_clks_enabled)\n\t\treturn;\n\n\tclk_bulk_disable_unprepare(MESON_SDHC_NUM_BULK_CLKS, host->bulk_clks);\n\n\thost->bulk_clks_enabled = false;\n}\n\nstatic int meson_mx_sdhc_enable_clks(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tif (host->bulk_clks_enabled)\n\t\treturn 0;\n\n\tret = clk_bulk_prepare_enable(MESON_SDHC_NUM_BULK_CLKS,\n\t\t\t\t      host->bulk_clks);\n\tif (ret)\n\t\treturn ret;\n\n\thost->bulk_clks_enabled = true;\n\n\treturn 0;\n}\n\nstatic int meson_mx_sdhc_set_clk(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tu32 val, rx_clk_phase;\n\tint ret;\n\n\tmeson_mx_sdhc_disable_clks(mmc);\n\n\tif (ios->clock) {\n\t\tret = clk_set_rate(host->sd_clk, ios->clock);\n\t\tif (ret) {\n\t\t\tdev_warn(mmc_dev(mmc),\n\t\t\t\t \"Failed to set MMC clock to %uHz: %d\\n\",\n\t\t\t\t ios->clock, host->error);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = meson_mx_sdhc_enable_clks(mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmmc->actual_clock = clk_get_rate(host->sd_clk);\n\n\t\t \n\t\tregmap_read(host->regmap, MESON_SDHC_CLKC, &val);\n\t\trx_clk_phase = FIELD_GET(MESON_SDHC_CLKC_CLK_DIV, val) / 4;\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_CLK2,\n\t\t\t\t   MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t\t\t      rx_clk_phase));\n\t} else {\n\t\tmmc->actual_clock = 0;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_mx_sdhc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tunsigned short vdd = ios->vdd;\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tvdd = 0;\n\t\tfallthrough;\n\n\tcase MMC_POWER_UP:\n\t\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\t\thost->error = mmc_regulator_set_ocr(mmc,\n\t\t\t\t\t\t\t    mmc->supply.vmmc,\n\t\t\t\t\t\t\t    vdd);\n\t\t\tif (host->error)\n\t\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\n\tcase MMC_POWER_ON:\n\t\tbreak;\n\t}\n\n\thost->error = meson_mx_sdhc_set_clk(mmc, ios);\n\tif (host->error)\n\t\treturn;\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_CTRL,\n\t\t\t\t   MESON_SDHC_CTRL_DAT_TYPE,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_CTRL_DAT_TYPE, 0));\n\t\tbreak;\n\n\tcase MMC_BUS_WIDTH_4:\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_CTRL,\n\t\t\t\t   MESON_SDHC_CTRL_DAT_TYPE,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_CTRL_DAT_TYPE, 1));\n\t\tbreak;\n\n\tcase MMC_BUS_WIDTH_8:\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_CTRL,\n\t\t\t\t   MESON_SDHC_CTRL_DAT_TYPE,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_CTRL_DAT_TYPE, 2));\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(mmc_dev(mmc), \"unsupported bus width: %d\\n\",\n\t\t\tios->bus_width);\n\t\thost->error = -EINVAL;\n\t\treturn;\n\t}\n}\n\nstatic int meson_mx_sdhc_map_dma(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_data *data = mrq->data;\n\tunsigned int dma_len;\n\n\tif (!data)\n\t\treturn 0;\n\n\tdma_len = dma_map_sg(mmc_dev(mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\tif (!dma_len) {\n\t\tdev_err(mmc_dev(mmc), \"dma_map_sg failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_mx_sdhc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\n\tif (!host->error)\n\t\thost->error = meson_mx_sdhc_map_dma(mmc, mrq);\n\n\tif (host->error) {\n\t\tcmd->error = host->error;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\thost->mrq = mrq;\n\n\tmeson_mx_sdhc_start_cmd(mmc, mrq->cmd);\n}\n\nstatic int meson_mx_sdhc_card_busy(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tu32 stat;\n\n\tregmap_read(host->regmap, MESON_SDHC_STAT, &stat);\n\treturn FIELD_GET(MESON_SDHC_STAT_DAT3_0, stat) == 0;\n}\n\nstatic bool meson_mx_sdhc_tuning_point_matches(struct mmc_host *mmc,\n\t\t\t\t\t       u32 opcode)\n{\n\tunsigned int i, num_matches = 0;\n\tint ret;\n\n\tfor (i = 0; i < MESON_SDHC_NUM_TUNING_TRIES; i++) {\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret)\n\t\t\tnum_matches++;\n\t}\n\n\treturn num_matches == MESON_SDHC_NUM_TUNING_TRIES;\n}\n\nstatic int meson_mx_sdhc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tint div, start, len, best_start, best_len;\n\tint curr_phase, old_phase, new_phase;\n\tu32 val;\n\n\tlen = 0;\n\tstart = 0;\n\tbest_len = 0;\n\n\tregmap_read(host->regmap, MESON_SDHC_CLK2, &val);\n\told_phase = FIELD_GET(MESON_SDHC_CLK2_RX_CLK_PHASE, val);\n\n\tregmap_read(host->regmap, MESON_SDHC_CLKC, &val);\n\tdiv = FIELD_GET(MESON_SDHC_CLKC_CLK_DIV, val);\n\n\tfor (curr_phase = 0; curr_phase <= div; curr_phase++) {\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_CLK2,\n\t\t\t\t   MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t\t\t      curr_phase));\n\n\t\tif (meson_mx_sdhc_tuning_point_matches(mmc, opcode)) {\n\t\t\tif (!len) {\n\t\t\t\tstart = curr_phase;\n\n\t\t\t\tdev_dbg(mmc_dev(mmc),\n\t\t\t\t\t\"New RX phase window starts at %u\\n\",\n\t\t\t\t\tstart);\n\t\t\t}\n\n\t\t\tlen++;\n\t\t} else {\n\t\t\tif (len > best_len) {\n\t\t\t\tbest_start = start;\n\t\t\t\tbest_len = len;\n\n\t\t\t\tdev_dbg(mmc_dev(mmc),\n\t\t\t\t\t\"New best RX phase window: %u - %u\\n\",\n\t\t\t\t\tbest_start, best_start + best_len);\n\t\t\t}\n\n\t\t\t \n\t\t\tlen = 0;\n\t\t}\n\t}\n\n\tif (len > best_len)\n\t\t \n\t\tnew_phase = start + (len / 2);\n\telse if (best_len)\n\t\t \n\t\tnew_phase = best_start + (best_len / 2);\n\telse\n\t\t \n\t\tnew_phase = old_phase;\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_CLK2,\n\t\t\t   MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t   FIELD_PREP(MESON_SDHC_CLK2_RX_CLK_PHASE,\n\t\t\t\t      new_phase));\n\n\tif (!len && !best_len)\n\t\treturn -EIO;\n\n\tdev_dbg(mmc_dev(mmc), \"Tuned RX clock phase to %u\\n\", new_phase);\n\n\treturn 0;\n}\n\nstatic const struct mmc_host_ops meson_mx_sdhc_ops = {\n\t.card_hw_reset\t\t\t= meson_mx_sdhc_hw_reset,\n\t.request\t\t\t= meson_mx_sdhc_request,\n\t.set_ios\t\t\t= meson_mx_sdhc_set_ios,\n\t.card_busy\t\t\t= meson_mx_sdhc_card_busy,\n\t.execute_tuning\t\t\t= meson_mx_sdhc_execute_tuning,\n\t.get_cd\t\t\t\t= mmc_gpio_get_cd,\n\t.get_ro\t\t\t\t= mmc_gpio_get_ro,\n};\n\nstatic void meson_mx_sdhc_request_done(struct meson_mx_sdhc_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_host *mmc = host->mmc;\n\n\t \n\tregmap_update_bits(host->regmap, MESON_SDHC_ICTL,\n\t\t\t   MESON_SDHC_ICTL_ALL_IRQS, 0);\n\tregmap_update_bits(host->regmap, MESON_SDHC_ISTA,\n\t\t\t   MESON_SDHC_ISTA_ALL_IRQS, MESON_SDHC_ISTA_ALL_IRQS);\n\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic u32 meson_mx_sdhc_read_response(struct meson_mx_sdhc_host *host, u8 idx)\n{\n\tu32 val;\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t   MESON_SDHC_PDMA_DMA_MODE, 0);\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t   MESON_SDHC_PDMA_PIO_RDRESP,\n\t\t\t   FIELD_PREP(MESON_SDHC_PDMA_PIO_RDRESP, idx));\n\n\tregmap_read(host->regmap, MESON_SDHC_ARGU, &val);\n\n\treturn val;\n}\n\nstatic irqreturn_t meson_mx_sdhc_irq(int irq, void *data)\n{\n\tstruct meson_mx_sdhc_host *host = data;\n\tstruct mmc_command *cmd = host->cmd;\n\tu32 ictl, ista;\n\n\tregmap_read(host->regmap, MESON_SDHC_ICTL, &ictl);\n\tregmap_read(host->regmap, MESON_SDHC_ISTA, &ista);\n\n\tif (!(ictl & ista))\n\t\treturn IRQ_NONE;\n\n\tif (ista & MESON_SDHC_ISTA_RXFIFO_FULL ||\n\t    ista & MESON_SDHC_ISTA_TXFIFO_EMPTY)\n\t\tcmd->error = -EIO;\n\telse if (ista & MESON_SDHC_ISTA_RESP_ERR_CRC)\n\t\tcmd->error = -EILSEQ;\n\telse if (ista & MESON_SDHC_ISTA_RESP_TIMEOUT)\n\t\tcmd->error = -ETIMEDOUT;\n\n\tif (cmd->data) {\n\t\tif (ista & MESON_SDHC_ISTA_DATA_ERR_CRC)\n\t\t\tcmd->data->error = -EILSEQ;\n\t\telse if (ista & MESON_SDHC_ISTA_DATA_TIMEOUT)\n\t\t\tcmd->data->error = -ETIMEDOUT;\n\t}\n\n\tif (cmd->error || (cmd->data && cmd->data->error))\n\t\tdev_dbg(mmc_dev(host->mmc), \"CMD%d error, ISTA: 0x%08x\\n\",\n\t\t\tcmd->opcode, ista);\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t meson_mx_sdhc_irq_thread(int irq, void *irq_data)\n{\n\tstruct meson_mx_sdhc_host *host = irq_data;\n\tstruct mmc_command *cmd;\n\tu32 val;\n\n\tcmd = host->cmd;\n\tif (WARN_ON(!cmd))\n\t\treturn IRQ_HANDLED;\n\n\tif (cmd->data && !cmd->data->error) {\n\t\tif (!host->platform->hardware_flush_all_cmds &&\n\t\t    cmd->data->flags & MMC_DATA_READ) {\n\t\t\tmeson_mx_sdhc_wait_cmd_ready(host->mmc);\n\n\t\t\t \n\t\t\tval = FIELD_PREP(MESON_SDHC_PDMA_RXFIFO_MANUAL_FLUSH,\n\t\t\t\t\t 2);\n\t\t\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA, val,\n\t\t\t\t\t   val);\n\t\t}\n\n\t\tdma_unmap_sg(mmc_dev(host->mmc), cmd->data->sg,\n\t\t\t     cmd->data->sg_len, mmc_get_dma_dir(cmd->data));\n\n\t\tcmd->data->bytes_xfered = cmd->data->blksz * cmd->data->blocks;\n\t}\n\n\tmeson_mx_sdhc_wait_cmd_ready(host->mmc);\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tcmd->resp[0] = meson_mx_sdhc_read_response(host, 4);\n\t\tcmd->resp[1] = meson_mx_sdhc_read_response(host, 3);\n\t\tcmd->resp[2] = meson_mx_sdhc_read_response(host, 2);\n\t\tcmd->resp[3] = meson_mx_sdhc_read_response(host, 1);\n\t} else {\n\t\tcmd->resp[0] = meson_mx_sdhc_read_response(host, 0);\n\t}\n\n\tif (cmd->error == -EIO || cmd->error == -ETIMEDOUT)\n\t\tmeson_mx_sdhc_hw_reset(host->mmc);\n\telse if (cmd->data)\n\t\t \n\t\tmeson_mx_sdhc_clear_fifo(host->mmc);\n\n\tmeson_mx_sdhc_request_done(host);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void meson_mx_sdhc_init_hw_meson8(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tregmap_write(host->regmap, MESON_SDHC_MISC,\n\t\t     FIELD_PREP(MESON_SDHC_MISC_TXSTART_THRES, 7) |\n\t\t     FIELD_PREP(MESON_SDHC_MISC_WCRC_ERR_PATT, 5) |\n\t\t     FIELD_PREP(MESON_SDHC_MISC_WCRC_OK_PATT, 2));\n\n\tregmap_write(host->regmap, MESON_SDHC_ENHC,\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_RXFIFO_TH, 63) |\n\t\t     MESON_SDHC_ENHC_MESON6_DMA_WR_RESP |\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_MESON6_RX_TIMEOUT, 255) |\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_SDIO_IRQ_PERIOD, 12));\n};\n\nstatic void meson_mx_sdhc_set_pdma_meson8(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tif (host->cmd->data->flags & MMC_DATA_WRITE)\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t\t   MESON_SDHC_PDMA_DMA_MODE |\n\t\t\t\t   MESON_SDHC_PDMA_RD_BURST |\n\t\t\t\t   MESON_SDHC_PDMA_TXFIFO_FILL,\n\t\t\t\t   MESON_SDHC_PDMA_DMA_MODE |\n\t\t\t\t   FIELD_PREP(MESON_SDHC_PDMA_RD_BURST, 31) |\n\t\t\t\t   MESON_SDHC_PDMA_TXFIFO_FILL);\n\telse\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t\t   MESON_SDHC_PDMA_DMA_MODE |\n\t\t\t\t   MESON_SDHC_PDMA_RXFIFO_MANUAL_FLUSH,\n\t\t\t\t   MESON_SDHC_PDMA_DMA_MODE |\n\t\t\t\t   FIELD_PREP(MESON_SDHC_PDMA_RXFIFO_MANUAL_FLUSH,\n\t\t\t\t\t      1));\n\n\tif (host->cmd->data->flags & MMC_DATA_WRITE)\n\t\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t\t   MESON_SDHC_PDMA_RD_BURST,\n\t\t\t\t   FIELD_PREP(MESON_SDHC_PDMA_RD_BURST, 15));\n}\n\nstatic void meson_mx_sdhc_wait_before_send_meson8(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read_poll_timeout(host->regmap, MESON_SDHC_ESTA, val,\n\t\t\t\t       val == 0,\n\t\t\t\t       MESON_SDHC_WAIT_BEFORE_SEND_SLEEP_US,\n\t\t\t\t       MESON_SDHC_WAIT_BEFORE_SEND_TIMEOUT_US);\n\tif (ret)\n\t\tdev_warn(mmc_dev(mmc),\n\t\t\t \"Failed to wait for ESTA to clear: 0x%08x\\n\", val);\n\n\tif (host->cmd->data && host->cmd->data->flags & MMC_DATA_WRITE) {\n\t\tret = regmap_read_poll_timeout(host->regmap, MESON_SDHC_STAT,\n\t\t\t\t\tval, val & MESON_SDHC_STAT_TXFIFO_CNT,\n\t\t\t\t\tMESON_SDHC_WAIT_BEFORE_SEND_SLEEP_US,\n\t\t\t\t\tMESON_SDHC_WAIT_BEFORE_SEND_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tdev_warn(mmc_dev(mmc),\n\t\t\t\t \"Failed to wait for TX FIFO to fill\\n\");\n\t}\n}\n\nstatic void meson_mx_sdhc_init_hw_meson8m2(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tregmap_write(host->regmap, MESON_SDHC_MISC,\n\t\t     FIELD_PREP(MESON_SDHC_MISC_TXSTART_THRES, 6) |\n\t\t     FIELD_PREP(MESON_SDHC_MISC_WCRC_ERR_PATT, 5) |\n\t\t     FIELD_PREP(MESON_SDHC_MISC_WCRC_OK_PATT, 2));\n\n\tregmap_write(host->regmap, MESON_SDHC_ENHC,\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_RXFIFO_TH, 64) |\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_MESON8M2_DEBUG, 1) |\n\t\t     MESON_SDHC_ENHC_MESON8M2_WRRSP_MODE |\n\t\t     FIELD_PREP(MESON_SDHC_ENHC_SDIO_IRQ_PERIOD, 12));\n}\n\nstatic void meson_mx_sdhc_set_pdma_meson8m2(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tregmap_update_bits(host->regmap, MESON_SDHC_PDMA,\n\t\t\t   MESON_SDHC_PDMA_DMA_MODE, MESON_SDHC_PDMA_DMA_MODE);\n}\n\nstatic void meson_mx_sdhc_init_hw(struct mmc_host *mmc)\n{\n\tstruct meson_mx_sdhc_host *host = mmc_priv(mmc);\n\n\tmeson_mx_sdhc_hw_reset(mmc);\n\n\tregmap_write(host->regmap, MESON_SDHC_CTRL,\n\t\t     FIELD_PREP(MESON_SDHC_CTRL_RX_PERIOD, 0xf) |\n\t\t     FIELD_PREP(MESON_SDHC_CTRL_RX_TIMEOUT, 0x7f) |\n\t\t     FIELD_PREP(MESON_SDHC_CTRL_RX_ENDIAN, 0x7) |\n\t\t     FIELD_PREP(MESON_SDHC_CTRL_TX_ENDIAN, 0x7));\n\n\t \n\tregmap_write(host->regmap, MESON_SDHC_CLKC, MESON_SDHC_CLKC_CLK_DIV);\n\n\tregmap_write(host->regmap, MESON_SDHC_CLK2,\n\t\t     FIELD_PREP(MESON_SDHC_CLK2_SD_CLK_PHASE, 1));\n\n\tregmap_write(host->regmap, MESON_SDHC_PDMA,\n\t\t     MESON_SDHC_PDMA_DMA_URGENT |\n\t\t     FIELD_PREP(MESON_SDHC_PDMA_WR_BURST, 7) |\n\t\t     FIELD_PREP(MESON_SDHC_PDMA_TXFIFO_TH, 49) |\n\t\t     FIELD_PREP(MESON_SDHC_PDMA_RD_BURST, 15) |\n\t\t     FIELD_PREP(MESON_SDHC_PDMA_RXFIFO_TH, 7));\n\n\t \n\thost->platform->init_hw(mmc);\n\n\t \n\tregmap_write(host->regmap, MESON_SDHC_ICTL, 0);\n\tregmap_write(host->regmap, MESON_SDHC_ISTA, MESON_SDHC_ISTA_ALL_IRQS);\n}\n\nstatic void meason_mx_mmc_free_host(void *data)\n{\n       mmc_free_host(data);\n}\n\nstatic int meson_mx_sdhc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct meson_mx_sdhc_host *host;\n\tstruct mmc_host *mmc;\n\tvoid __iomem *base;\n\tint ret, irq;\n\n\tmmc = mmc_alloc_host(sizeof(*host), dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(dev, meason_mx_mmc_free_host, mmc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register mmc_free_host action\\n\");\n\t\treturn ret;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\n\tplatform_set_drvdata(pdev, host);\n\n\thost->platform = device_get_match_data(dev);\n\tif (!host->platform)\n\t\treturn -EINVAL;\n\n\tbase = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\thost->regmap = devm_regmap_init_mmio(dev, base,\n\t\t\t\t\t     &meson_mx_sdhc_regmap_config);\n\tif (IS_ERR(host->regmap))\n\t\treturn PTR_ERR(host->regmap);\n\n\thost->pclk = devm_clk_get(dev, \"pclk\");\n\tif (IS_ERR(host->pclk))\n\t\treturn PTR_ERR(host->pclk);\n\n\t \n\tret = clk_prepare_enable(host->pclk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable 'pclk' clock\\n\");\n\t\treturn ret;\n\t}\n\n\tmeson_mx_sdhc_init_hw(mmc);\n\n\tret = meson_mx_sdhc_register_clkc(dev, base, host->bulk_clks);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\thost->sd_clk = host->bulk_clks[1].clk;\n\n\t \n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\tmmc->max_req_size = SZ_128K;\n\tmmc->max_seg_size = mmc->max_req_size;\n\tmmc->max_blk_count = FIELD_GET(MESON_SDHC_SEND_TOTAL_PACK, ~0);\n\tmmc->max_blk_size = MESON_SDHC_MAX_BLK_SIZE;\n\tmmc->max_busy_timeout = 30 * MSEC_PER_SEC;\n\tmmc->f_min = clk_round_rate(host->sd_clk, 1);\n\tmmc->f_max = clk_round_rate(host->sd_clk, ULONG_MAX);\n\tmmc->max_current_180 = 300;\n\tmmc->max_current_330 = 300;\n\tmmc->caps |= MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_HW_RESET;\n\tmmc->ops = &meson_mx_sdhc_ops;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto err_disable_pclk;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq, meson_mx_sdhc_irq,\n\t\t\t\t\tmeson_mx_sdhc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tNULL, host);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto err_disable_pclk;\n\n\treturn 0;\n\nerr_disable_pclk:\n\tclk_disable_unprepare(host->pclk);\n\treturn ret;\n}\n\nstatic void meson_mx_sdhc_remove(struct platform_device *pdev)\n{\n\tstruct meson_mx_sdhc_host *host = platform_get_drvdata(pdev);\n\n\tmmc_remove_host(host->mmc);\n\n\tmeson_mx_sdhc_disable_clks(host->mmc);\n\n\tclk_disable_unprepare(host->pclk);\n}\n\nstatic const struct meson_mx_sdhc_data meson_mx_sdhc_data_meson8 = {\n\t.init_hw\t\t\t= meson_mx_sdhc_init_hw_meson8,\n\t.set_pdma\t\t\t= meson_mx_sdhc_set_pdma_meson8,\n\t.wait_before_send\t\t= meson_mx_sdhc_wait_before_send_meson8,\n\t.hardware_flush_all_cmds\t= false,\n};\n\nstatic const struct meson_mx_sdhc_data meson_mx_sdhc_data_meson8m2 = {\n\t.init_hw\t\t\t= meson_mx_sdhc_init_hw_meson8m2,\n\t.set_pdma\t\t\t= meson_mx_sdhc_set_pdma_meson8m2,\n\t.hardware_flush_all_cmds\t= true,\n};\n\nstatic const struct of_device_id meson_mx_sdhc_of_match[] = {\n\t{\n\t\t.compatible = \"amlogic,meson8-sdhc\",\n\t\t.data = &meson_mx_sdhc_data_meson8\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8b-sdhc\",\n\t\t.data = &meson_mx_sdhc_data_meson8\n\t},\n\t{\n\t\t.compatible = \"amlogic,meson8m2-sdhc\",\n\t\t.data = &meson_mx_sdhc_data_meson8m2\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_mx_sdhc_of_match);\n\nstatic struct platform_driver meson_mx_sdhc_driver = {\n\t.probe   = meson_mx_sdhc_probe,\n\t.remove_new = meson_mx_sdhc_remove,\n\t.driver  = {\n\t\t.name = \"meson-mx-sdhc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(meson_mx_sdhc_of_match),\n\t},\n};\n\nmodule_platform_driver(meson_mx_sdhc_driver);\n\nMODULE_DESCRIPTION(\"Meson6, Meson8, Meson8b and Meson8m2 SDHC Host Driver\");\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}