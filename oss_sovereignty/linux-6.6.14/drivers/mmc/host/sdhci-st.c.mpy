{
  "module_name": "sdhci-st.c",
  "hash_id": "46f3bb9c690f810dbe06e38dd00e809575785ba0ccaa45faee4c658548b49735",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-st.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/mmc/host.h>\n#include <linux/reset.h>\n#include \"sdhci-pltfm.h\"\n\nstruct st_mmc_platform_data {\n\tstruct  reset_control *rstc;\n\tstruct  clk *icnclk;\n\tvoid __iomem *top_ioaddr;\n};\n\n \n\n#define ST_MMC_CCONFIG_REG_1\t\t0x400\n#define ST_MMC_CCONFIG_TIMEOUT_CLK_UNIT\tBIT(24)\n#define ST_MMC_CCONFIG_TIMEOUT_CLK_FREQ\tBIT(12)\n#define ST_MMC_CCONFIG_TUNING_COUNT_DEFAULT\tBIT(8)\n#define ST_MMC_CCONFIG_ASYNC_WAKEUP\tBIT(0)\n#define ST_MMC_CCONFIG_1_DEFAULT\t\\\n\t\t\t\t((ST_MMC_CCONFIG_TIMEOUT_CLK_UNIT) | \\\n\t\t\t\t (ST_MMC_CCONFIG_TIMEOUT_CLK_FREQ) | \\\n\t\t\t\t (ST_MMC_CCONFIG_TUNING_COUNT_DEFAULT))\n\n#define ST_MMC_CCONFIG_REG_2\t\t0x404\n#define ST_MMC_CCONFIG_HIGH_SPEED\tBIT(28)\n#define ST_MMC_CCONFIG_ADMA2\t\tBIT(24)\n#define ST_MMC_CCONFIG_8BIT\t\tBIT(20)\n#define ST_MMC_CCONFIG_MAX_BLK_LEN\t16\n#define  MAX_BLK_LEN_1024\t\t1\n#define  MAX_BLK_LEN_2048\t\t2\n#define BASE_CLK_FREQ_200\t\t0xc8\n#define BASE_CLK_FREQ_100\t\t0x64\n#define BASE_CLK_FREQ_50\t\t0x32\n#define ST_MMC_CCONFIG_2_DEFAULT \\\n\t(ST_MMC_CCONFIG_HIGH_SPEED | ST_MMC_CCONFIG_ADMA2 | \\\n\t ST_MMC_CCONFIG_8BIT | \\\n\t (MAX_BLK_LEN_1024 << ST_MMC_CCONFIG_MAX_BLK_LEN))\n\n#define ST_MMC_CCONFIG_REG_3\t\t\t0x408\n#define ST_MMC_CCONFIG_EMMC_SLOT_TYPE\t\tBIT(28)\n#define ST_MMC_CCONFIG_64BIT\t\t\tBIT(24)\n#define ST_MMC_CCONFIG_ASYNCH_INTR_SUPPORT\tBIT(20)\n#define ST_MMC_CCONFIG_1P8_VOLT\t\t\tBIT(16)\n#define ST_MMC_CCONFIG_3P0_VOLT\t\t\tBIT(12)\n#define ST_MMC_CCONFIG_3P3_VOLT\t\t\tBIT(8)\n#define ST_MMC_CCONFIG_SUSP_RES_SUPPORT\t\tBIT(4)\n#define ST_MMC_CCONFIG_SDMA\t\t\tBIT(0)\n#define ST_MMC_CCONFIG_3_DEFAULT\t\\\n\t\t\t (ST_MMC_CCONFIG_ASYNCH_INTR_SUPPORT\t| \\\n\t\t\t  ST_MMC_CCONFIG_3P3_VOLT\t\t| \\\n\t\t\t  ST_MMC_CCONFIG_SUSP_RES_SUPPORT\t| \\\n\t\t\t  ST_MMC_CCONFIG_SDMA)\n\n#define ST_MMC_CCONFIG_REG_4\t0x40c\n#define ST_MMC_CCONFIG_D_DRIVER\tBIT(20)\n#define ST_MMC_CCONFIG_C_DRIVER\tBIT(16)\n#define ST_MMC_CCONFIG_A_DRIVER\tBIT(12)\n#define ST_MMC_CCONFIG_DDR50\tBIT(8)\n#define ST_MMC_CCONFIG_SDR104\tBIT(4)\n#define ST_MMC_CCONFIG_SDR50\tBIT(0)\n#define ST_MMC_CCONFIG_4_DEFAULT\t0\n\n#define ST_MMC_CCONFIG_REG_5\t\t0x410\n#define ST_MMC_CCONFIG_TUNING_FOR_SDR50\tBIT(8)\n#define RETUNING_TIMER_CNT_MAX\t\t0xf\n#define ST_MMC_CCONFIG_5_DEFAULT\t0\n\n \n#define ST_MMC_GP_OUTPUT\t0x450\n#define ST_MMC_GP_OUTPUT_CD\tBIT(12)\n\n#define ST_MMC_STATUS_R\t\t0x460\n\n#define ST_TOP_MMC_DLY_FIX_OFF(x)\t(x - 0x8)\n\n \n#define ST_TOP_MMC_TX_CLK_DLY\t\t\tST_TOP_MMC_DLY_FIX_OFF(0x8)\n#define ST_TOP_MMC_RX_CLK_DLY\t\t\tST_TOP_MMC_DLY_FIX_OFF(0xc)\n \n#define ST_TOP_MMC_DLY_CTRL\t\t\tST_TOP_MMC_DLY_FIX_OFF(0x18)\n#define ST_TOP_MMC_DLY_CTRL_DLL_BYPASS_CMD\tBIT(0)\n#define ST_TOP_MMC_DLY_CTRL_DLL_BYPASS_PH_SEL\tBIT(1)\n#define ST_TOP_MMC_DLY_CTRL_TX_DLL_ENABLE\tBIT(8)\n#define ST_TOP_MMC_DLY_CTRL_RX_DLL_ENABLE\tBIT(9)\n#define ST_TOP_MMC_DLY_CTRL_ATUNE_NOT_CFG_DLY\tBIT(10)\n#define ST_TOP_MMC_START_DLL_LOCK\t\tBIT(11)\n\n \n#define ST_TOP_MMC_TX_DLL_STEP_DLY\t\tST_TOP_MMC_DLY_FIX_OFF(0x1c)\n#define ST_TOP_MMC_RX_DLL_STEP_DLY\t\tST_TOP_MMC_DLY_FIX_OFF(0x20)\n#define ST_TOP_MMC_RX_CMD_STEP_DLY\t\tST_TOP_MMC_DLY_FIX_OFF(0x24)\n\n \n#define ST_TOP_MMC_TX_DLL_STEP_DLY_VALID\t0x6\n\n#define ST_TOP_MMC_DLY_MAX\t\t\t0xf\n\n#define ST_TOP_MMC_DYN_DLY_CONF\t\\\n\t\t(ST_TOP_MMC_DLY_CTRL_TX_DLL_ENABLE | \\\n\t\t ST_TOP_MMC_DLY_CTRL_ATUNE_NOT_CFG_DLY | \\\n\t\t ST_TOP_MMC_START_DLL_LOCK)\n\n \n#define\tCLK_TO_CHECK_DLL_LOCK\t90000000\n\nstatic inline void st_mmcss_set_static_delay(void __iomem *ioaddr)\n{\n\tif (!ioaddr)\n\t\treturn;\n\n\twritel_relaxed(0x0, ioaddr + ST_TOP_MMC_DLY_CTRL);\n\twritel_relaxed(ST_TOP_MMC_DLY_MAX,\n\t\t\tioaddr + ST_TOP_MMC_TX_CLK_DLY);\n}\n\n \nstatic void st_mmcss_cconfig(struct device_node *np, struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct mmc_host *mhost = host->mmc;\n\tu32 cconf2, cconf3, cconf4, cconf5;\n\n\tif (!of_device_is_compatible(np, \"st,sdhci-stih407\"))\n\t\treturn;\n\n\tcconf2 = ST_MMC_CCONFIG_2_DEFAULT;\n\tcconf3 = ST_MMC_CCONFIG_3_DEFAULT;\n\tcconf4 = ST_MMC_CCONFIG_4_DEFAULT;\n\tcconf5 = ST_MMC_CCONFIG_5_DEFAULT;\n\n\twritel_relaxed(ST_MMC_CCONFIG_1_DEFAULT,\n\t\t\thost->ioaddr + ST_MMC_CCONFIG_REG_1);\n\n\t \n\n\tswitch (mhost->f_max) {\n\tcase 200000000:\n\t\tclk_set_rate(pltfm_host->clk, mhost->f_max);\n\t\tcconf2 |= BASE_CLK_FREQ_200;\n\t\tbreak;\n\tcase 100000000:\n\t\tclk_set_rate(pltfm_host->clk, mhost->f_max);\n\t\tcconf2 |= BASE_CLK_FREQ_100;\n\t\tbreak;\n\tdefault:\n\t\tclk_set_rate(pltfm_host->clk, 50000000);\n\t\tcconf2 |= BASE_CLK_FREQ_50;\n\t}\n\n\twritel_relaxed(cconf2, host->ioaddr + ST_MMC_CCONFIG_REG_2);\n\n\tif (!mmc_card_is_removable(mhost))\n\t\tcconf3 |= ST_MMC_CCONFIG_EMMC_SLOT_TYPE;\n\telse\n\t\t \n\t\twritel_relaxed(ST_MMC_GP_OUTPUT_CD,\n\t\t\t\thost->ioaddr + ST_MMC_GP_OUTPUT);\n\n\tif (mhost->caps & MMC_CAP_UHS_SDR50) {\n\t\t \n\t\tcconf3 |= ST_MMC_CCONFIG_1P8_VOLT;\n\t\tcconf4 |= ST_MMC_CCONFIG_SDR50;\n\t\t \n\t\tcconf5 |= ST_MMC_CCONFIG_TUNING_FOR_SDR50;\n\t\t \n\t\tcconf5 |= RETUNING_TIMER_CNT_MAX;\n\t}\n\n\tif (mhost->caps & MMC_CAP_UHS_SDR104) {\n\t\t \n\t\tcconf3 |= ST_MMC_CCONFIG_1P8_VOLT;\n\t\tcconf4 |= ST_MMC_CCONFIG_SDR104;\n\t\t \n\t\tcconf5 |= RETUNING_TIMER_CNT_MAX;\n\t}\n\n\tif (mhost->caps & MMC_CAP_UHS_DDR50)\n\t\tcconf4 |= ST_MMC_CCONFIG_DDR50;\n\n\twritel_relaxed(cconf3, host->ioaddr + ST_MMC_CCONFIG_REG_3);\n\twritel_relaxed(cconf4, host->ioaddr + ST_MMC_CCONFIG_REG_4);\n\twritel_relaxed(cconf5, host->ioaddr + ST_MMC_CCONFIG_REG_5);\n}\n\nstatic inline void st_mmcss_set_dll(void __iomem *ioaddr)\n{\n\tif (!ioaddr)\n\t\treturn;\n\n\twritel_relaxed(ST_TOP_MMC_DYN_DLY_CONF,\tioaddr + ST_TOP_MMC_DLY_CTRL);\n\twritel_relaxed(ST_TOP_MMC_TX_DLL_STEP_DLY_VALID,\n\t\t\tioaddr + ST_TOP_MMC_TX_DLL_STEP_DLY);\n}\n\nstatic int st_mmcss_lock_dll(void __iomem *ioaddr)\n{\n\tunsigned long curr, value;\n\tunsigned long finish = jiffies + HZ;\n\n\t \n\tdo {\n\t\tcurr = jiffies;\n\t\tvalue = readl(ioaddr + ST_MMC_STATUS_R);\n\t\tif (value & 0x1)\n\t\t\treturn 0;\n\n\t\tcpu_relax();\n\t} while (!time_after_eq(curr, finish));\n\n\treturn -EBUSY;\n}\n\nstatic int sdhci_st_set_dll_for_clock(struct sdhci_host *host)\n{\n\tint ret = 0;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct st_mmc_platform_data *pdata = sdhci_pltfm_priv(pltfm_host);\n\n\tif (host->clock > CLK_TO_CHECK_DLL_LOCK) {\n\t\tst_mmcss_set_dll(pdata->top_ioaddr);\n\t\tret = st_mmcss_lock_dll(host->ioaddr);\n\t}\n\n\treturn ret;\n}\n\nstatic void sdhci_st_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\tunsigned int uhs)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct st_mmc_platform_data *pdata = sdhci_pltfm_priv(pltfm_host);\n\tu16 ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\tint ret = 0;\n\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tswitch (uhs) {\n\t \n\n\tcase MMC_TIMING_UHS_SDR12:\n\t\tst_mmcss_set_static_delay(pdata->top_ioaddr);\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\t\tst_mmcss_set_static_delay(pdata->top_ioaddr);\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tst_mmcss_set_static_delay(pdata->top_ioaddr);\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50 | SDHCI_CTRL_VDD_180;\n\t\tret = sdhci_st_set_dll_for_clock(host);\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\tst_mmcss_set_static_delay(pdata->top_ioaddr);\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104 | SDHCI_CTRL_VDD_180;\n\t\tret =  sdhci_st_set_dll_for_clock(host);\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tst_mmcss_set_static_delay(pdata->top_ioaddr);\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_warn(mmc_dev(host->mmc), \"Error setting dll for clock \"\n\t\t\t\t\t\t\"(uhs %d)\\n\", uhs);\n\n\tdev_dbg(mmc_dev(host->mmc), \"uhs %d, ctrl_2 %04X\\n\", uhs, ctrl_2);\n\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n}\n\nstatic u32 sdhci_st_readl(struct sdhci_host *host, int reg)\n{\n\tu32 ret;\n\n\tswitch (reg) {\n\tcase SDHCI_CAPABILITIES:\n\t\tret = readl_relaxed(host->ioaddr + reg);\n\t\t \n\t\tret &= ~SDHCI_CAN_VDD_300;\n\t\tbreak;\n\tdefault:\n\t\tret = readl_relaxed(host->ioaddr + reg);\n\t}\n\treturn ret;\n}\n\nstatic const struct sdhci_ops sdhci_st_ops = {\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.read_l = sdhci_st_readl,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_st_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_st_pdata = {\n\t.ops = &sdhci_st_ops,\n\t.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\tSDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\tSDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\tSDHCI_QUIRK2_STOP_WITH_TC,\n};\n\n\nstatic int sdhci_st_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sdhci_host *host;\n\tstruct st_mmc_platform_data *pdata;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct clk *clk, *icnclk;\n\tint ret = 0;\n\tu16 host_version;\n\tstruct reset_control *rstc;\n\n\tclk =  devm_clk_get(&pdev->dev, \"mmc\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"Peripheral clk not found\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\n\t \n\ticnclk = devm_clk_get(&pdev->dev, \"icn\");\n\tif (IS_ERR(icnclk))\n\t\ticnclk = NULL;\n\n\trstc = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(rstc))\n\t\treturn PTR_ERR(rstc);\n\treset_control_deassert(rstc);\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_st_pdata, sizeof(*pdata));\n\tif (IS_ERR(host)) {\n\t\tdev_err(&pdev->dev, \"Failed sdhci_pltfm_init\\n\");\n\t\tret = PTR_ERR(host);\n\t\tgoto err_pltfm_init;\n\t}\n\n\tpltfm_host = sdhci_priv(host);\n\tpdata = sdhci_pltfm_priv(pltfm_host);\n\tpdata->rstc = rstc;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed mmc_of_parse\\n\");\n\t\tgoto err_of;\n\t}\n\n\tret = clk_prepare_enable(clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare clock\\n\");\n\t\tgoto err_of;\n\t}\n\n\tret = clk_prepare_enable(icnclk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to prepare icn clock\\n\");\n\t\tgoto err_icnclk;\n\t}\n\n\t \n\tpdata->top_ioaddr = devm_platform_ioremap_resource_byname(pdev, \"top-mmc-delay\");\n\tif (IS_ERR(pdata->top_ioaddr))\n\t\tpdata->top_ioaddr = NULL;\n\n\tpltfm_host->clk = clk;\n\tpdata->icnclk = icnclk;\n\n\t \n\tst_mmcss_cconfig(np, host);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_out;\n\n\thost_version = readw_relaxed((host->ioaddr + SDHCI_HOST_VERSION));\n\n\tdev_info(&pdev->dev, \"SDHCI ST Initialised: Host Version: 0x%x Vendor Version 0x%x\\n\",\n\t\t((host_version & SDHCI_SPEC_VER_MASK) >> SDHCI_SPEC_VER_SHIFT),\n\t\t((host_version & SDHCI_VENDOR_VER_MASK) >>\n\t\tSDHCI_VENDOR_VER_SHIFT));\n\n\treturn 0;\n\nerr_out:\n\tclk_disable_unprepare(icnclk);\nerr_icnclk:\n\tclk_disable_unprepare(clk);\nerr_of:\n\tsdhci_pltfm_free(pdev);\nerr_pltfm_init:\n\treset_control_assert(rstc);\n\n\treturn ret;\n}\n\nstatic void sdhci_st_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct st_mmc_platform_data *pdata = sdhci_pltfm_priv(pltfm_host);\n\tstruct reset_control *rstc = pdata->rstc;\n\tstruct clk *clk = pltfm_host->clk;\n\n\tsdhci_pltfm_remove(pdev);\n\n\tclk_disable_unprepare(pdata->icnclk);\n\tclk_disable_unprepare(clk);\n\n\treset_control_assert(rstc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_st_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct st_mmc_platform_data *pdata = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = sdhci_suspend_host(host);\n\tif (ret)\n\t\tgoto out;\n\n\treset_control_assert(pdata->rstc);\n\n\tclk_disable_unprepare(pdata->icnclk);\n\tclk_disable_unprepare(pltfm_host->clk);\nout:\n\treturn ret;\n}\n\nstatic int sdhci_st_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct st_mmc_platform_data *pdata = sdhci_pltfm_priv(pltfm_host);\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(pdata->icnclk);\n\tif (ret) {\n\t\tclk_disable_unprepare(pltfm_host->clk);\n\t\treturn ret;\n\t}\n\n\treset_control_deassert(pdata->rstc);\n\n\tst_mmcss_cconfig(np, host);\n\n\treturn sdhci_resume_host(host);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sdhci_st_pmops, sdhci_st_suspend, sdhci_st_resume);\n\nstatic const struct of_device_id st_sdhci_match[] = {\n\t{ .compatible = \"st,sdhci\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, st_sdhci_match);\n\nstatic struct platform_driver sdhci_st_driver = {\n\t.probe = sdhci_st_probe,\n\t.remove_new = sdhci_st_remove,\n\t.driver = {\n\t\t   .name = \"sdhci-st\",\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t   .pm = &sdhci_st_pmops,\n\t\t   .of_match_table = st_sdhci_match,\n\t\t  },\n};\n\nmodule_platform_driver(sdhci_st_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for STMicroelectronics SoCs\");\nMODULE_AUTHOR(\"Giuseppe Cavallaro <peppe.cavallaro@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sdhci-st\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}