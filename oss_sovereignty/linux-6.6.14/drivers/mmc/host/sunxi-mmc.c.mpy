{
  "module_name": "sunxi-mmc.c",
  "hash_id": "e49aa81305bcce7b2cecdc6fcec4ca207d830ae42c981177536bfbb023828a1a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sunxi-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/clk/sunxi-ng.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n\n \n#define SDXC_REG_GCTRL\t(0x00)  \n#define SDXC_REG_CLKCR\t(0x04)  \n#define SDXC_REG_TMOUT\t(0x08)  \n#define SDXC_REG_WIDTH\t(0x0C)  \n#define SDXC_REG_BLKSZ\t(0x10)  \n#define SDXC_REG_BCNTR\t(0x14)  \n#define SDXC_REG_CMDR\t(0x18)  \n#define SDXC_REG_CARG\t(0x1C)  \n#define SDXC_REG_RESP0\t(0x20)  \n#define SDXC_REG_RESP1\t(0x24)  \n#define SDXC_REG_RESP2\t(0x28)  \n#define SDXC_REG_RESP3\t(0x2C)  \n#define SDXC_REG_IMASK\t(0x30)  \n#define SDXC_REG_MISTA\t(0x34)  \n#define SDXC_REG_RINTR\t(0x38)  \n#define SDXC_REG_STAS\t(0x3C)  \n#define SDXC_REG_FTRGL\t(0x40)  \n#define SDXC_REG_FUNS\t(0x44)  \n#define SDXC_REG_CBCR\t(0x48)  \n#define SDXC_REG_BBCR\t(0x4C)  \n#define SDXC_REG_DBGC\t(0x50)  \n#define SDXC_REG_HWRST\t(0x78)  \n#define SDXC_REG_DMAC\t(0x80)  \n#define SDXC_REG_DLBA\t(0x84)  \n#define SDXC_REG_IDST\t(0x88)  \n#define SDXC_REG_IDIE\t(0x8C)  \n#define SDXC_REG_CHDA\t(0x90)\n#define SDXC_REG_CBDA\t(0x94)\n\n \n#define SDXC_REG_A12A\t\t0x058  \n#define SDXC_REG_SD_NTSR\t0x05C  \n#define SDXC_REG_DRV_DL\t\t0x140  \n#define SDXC_REG_SAMP_DL_REG\t0x144  \n#define SDXC_REG_DS_DL_REG\t0x148  \n\n#define mmc_readl(host, reg) \\\n\treadl((host)->reg_base + SDXC_##reg)\n#define mmc_writel(host, reg, value) \\\n\twritel((value), (host)->reg_base + SDXC_##reg)\n\n \n#define SDXC_SOFT_RESET\t\t\tBIT(0)\n#define SDXC_FIFO_RESET\t\t\tBIT(1)\n#define SDXC_DMA_RESET\t\t\tBIT(2)\n#define SDXC_INTERRUPT_ENABLE_BIT\tBIT(4)\n#define SDXC_DMA_ENABLE_BIT\t\tBIT(5)\n#define SDXC_DEBOUNCE_ENABLE_BIT\tBIT(8)\n#define SDXC_POSEDGE_LATCH_DATA\t\tBIT(9)\n#define SDXC_DDR_MODE\t\t\tBIT(10)\n#define SDXC_MEMORY_ACCESS_DONE\t\tBIT(29)\n#define SDXC_ACCESS_DONE_DIRECT\t\tBIT(30)\n#define SDXC_ACCESS_BY_AHB\t\tBIT(31)\n#define SDXC_ACCESS_BY_DMA\t\t(0 << 31)\n#define SDXC_HARDWARE_RESET \\\n\t(SDXC_SOFT_RESET | SDXC_FIFO_RESET | SDXC_DMA_RESET)\n\n \n#define SDXC_MASK_DATA0\t\t\tBIT(31)\n#define SDXC_CARD_CLOCK_ON\t\tBIT(16)\n#define SDXC_LOW_POWER_ON\t\tBIT(17)\n\n \n#define SDXC_WIDTH1\t\t\t0\n#define SDXC_WIDTH4\t\t\t1\n#define SDXC_WIDTH8\t\t\t2\n\n \n#define SDXC_RESP_EXPIRE\t\tBIT(6)\n#define SDXC_LONG_RESPONSE\t\tBIT(7)\n#define SDXC_CHECK_RESPONSE_CRC\t\tBIT(8)\n#define SDXC_DATA_EXPIRE\t\tBIT(9)\n#define SDXC_WRITE\t\t\tBIT(10)\n#define SDXC_SEQUENCE_MODE\t\tBIT(11)\n#define SDXC_SEND_AUTO_STOP\t\tBIT(12)\n#define SDXC_WAIT_PRE_OVER\t\tBIT(13)\n#define SDXC_STOP_ABORT_CMD\t\tBIT(14)\n#define SDXC_SEND_INIT_SEQUENCE\t\tBIT(15)\n#define SDXC_UPCLK_ONLY\t\t\tBIT(21)\n#define SDXC_READ_CEATA_DEV\t\tBIT(22)\n#define SDXC_CCS_EXPIRE\t\t\tBIT(23)\n#define SDXC_ENABLE_BIT_BOOT\t\tBIT(24)\n#define SDXC_ALT_BOOT_OPTIONS\t\tBIT(25)\n#define SDXC_BOOT_ACK_EXPIRE\t\tBIT(26)\n#define SDXC_BOOT_ABORT\t\t\tBIT(27)\n#define SDXC_VOLTAGE_SWITCH\t        BIT(28)\n#define SDXC_USE_HOLD_REGISTER\t        BIT(29)\n#define SDXC_START\t\t\tBIT(31)\n\n \n#define SDXC_RESP_ERROR\t\t\tBIT(1)\n#define SDXC_COMMAND_DONE\t\tBIT(2)\n#define SDXC_DATA_OVER\t\t\tBIT(3)\n#define SDXC_TX_DATA_REQUEST\t\tBIT(4)\n#define SDXC_RX_DATA_REQUEST\t\tBIT(5)\n#define SDXC_RESP_CRC_ERROR\t\tBIT(6)\n#define SDXC_DATA_CRC_ERROR\t\tBIT(7)\n#define SDXC_RESP_TIMEOUT\t\tBIT(8)\n#define SDXC_DATA_TIMEOUT\t\tBIT(9)\n#define SDXC_VOLTAGE_CHANGE_DONE\tBIT(10)\n#define SDXC_FIFO_RUN_ERROR\t\tBIT(11)\n#define SDXC_HARD_WARE_LOCKED\t\tBIT(12)\n#define SDXC_START_BIT_ERROR\t\tBIT(13)\n#define SDXC_AUTO_COMMAND_DONE\t\tBIT(14)\n#define SDXC_END_BIT_ERROR\t\tBIT(15)\n#define SDXC_SDIO_INTERRUPT\t\tBIT(16)\n#define SDXC_CARD_INSERT\t\tBIT(30)\n#define SDXC_CARD_REMOVE\t\tBIT(31)\n#define SDXC_INTERRUPT_ERROR_BIT \\\n\t(SDXC_RESP_ERROR | SDXC_RESP_CRC_ERROR | SDXC_DATA_CRC_ERROR | \\\n\t SDXC_RESP_TIMEOUT | SDXC_DATA_TIMEOUT | SDXC_FIFO_RUN_ERROR | \\\n\t SDXC_HARD_WARE_LOCKED | SDXC_START_BIT_ERROR | SDXC_END_BIT_ERROR)\n#define SDXC_INTERRUPT_DONE_BIT \\\n\t(SDXC_AUTO_COMMAND_DONE | SDXC_DATA_OVER | \\\n\t SDXC_COMMAND_DONE | SDXC_VOLTAGE_CHANGE_DONE)\n\n \n#define SDXC_RXWL_FLAG\t\t\tBIT(0)\n#define SDXC_TXWL_FLAG\t\t\tBIT(1)\n#define SDXC_FIFO_EMPTY\t\t\tBIT(2)\n#define SDXC_FIFO_FULL\t\t\tBIT(3)\n#define SDXC_CARD_PRESENT\t\tBIT(8)\n#define SDXC_CARD_DATA_BUSY\t\tBIT(9)\n#define SDXC_DATA_FSM_BUSY\t\tBIT(10)\n#define SDXC_DMA_REQUEST\t\tBIT(31)\n#define SDXC_FIFO_SIZE\t\t\t16\n\n \n#define SDXC_CEATA_ON\t\t\t(0xceaa << 16)\n#define SDXC_SEND_IRQ_RESPONSE\t\tBIT(0)\n#define SDXC_SDIO_READ_WAIT\t\tBIT(1)\n#define SDXC_ABORT_READ_DATA\t\tBIT(2)\n#define SDXC_SEND_CCSD\t\t\tBIT(8)\n#define SDXC_SEND_AUTO_STOPCCSD\t\tBIT(9)\n#define SDXC_CEATA_DEV_IRQ_ENABLE\tBIT(10)\n\n \n#define SDXC_IDMAC_SOFT_RESET\t\tBIT(0)\n#define SDXC_IDMAC_FIX_BURST\t\tBIT(1)\n#define SDXC_IDMAC_IDMA_ON\t\tBIT(7)\n#define SDXC_IDMAC_REFETCH_DES\t\tBIT(31)\n\n \n#define SDXC_IDMAC_TRANSMIT_INTERRUPT\t\tBIT(0)\n#define SDXC_IDMAC_RECEIVE_INTERRUPT\t\tBIT(1)\n#define SDXC_IDMAC_FATAL_BUS_ERROR\t\tBIT(2)\n#define SDXC_IDMAC_DESTINATION_INVALID\t\tBIT(4)\n#define SDXC_IDMAC_CARD_ERROR_SUM\t\tBIT(5)\n#define SDXC_IDMAC_NORMAL_INTERRUPT_SUM\t\tBIT(8)\n#define SDXC_IDMAC_ABNORMAL_INTERRUPT_SUM\tBIT(9)\n#define SDXC_IDMAC_HOST_ABORT_INTERRUPT\t\tBIT(10)\n#define SDXC_IDMAC_IDLE\t\t\t\t(0 << 13)\n#define SDXC_IDMAC_SUSPEND\t\t\t(1 << 13)\n#define SDXC_IDMAC_DESC_READ\t\t\t(2 << 13)\n#define SDXC_IDMAC_DESC_CHECK\t\t\t(3 << 13)\n#define SDXC_IDMAC_READ_REQUEST_WAIT\t\t(4 << 13)\n#define SDXC_IDMAC_WRITE_REQUEST_WAIT\t\t(5 << 13)\n#define SDXC_IDMAC_READ\t\t\t\t(6 << 13)\n#define SDXC_IDMAC_WRITE\t\t\t(7 << 13)\n#define SDXC_IDMAC_DESC_CLOSE\t\t\t(8 << 13)\n\n \n#define SDXC_IDMAC_DES0_DIC\tBIT(1)   \n#define SDXC_IDMAC_DES0_LD\tBIT(2)   \n#define SDXC_IDMAC_DES0_FD\tBIT(3)   \n#define SDXC_IDMAC_DES0_CH\tBIT(4)   \n#define SDXC_IDMAC_DES0_ER\tBIT(5)   \n#define SDXC_IDMAC_DES0_CES\tBIT(30)  \n#define SDXC_IDMAC_DES0_OWN\tBIT(31)  \n\n#define SDXC_CLK_400K\t\t0\n#define SDXC_CLK_25M\t\t1\n#define SDXC_CLK_50M\t\t2\n#define SDXC_CLK_50M_DDR\t3\n#define SDXC_CLK_50M_DDR_8BIT\t4\n\n#define SDXC_2X_TIMING_MODE\tBIT(31)\n\n#define SDXC_CAL_START\t\tBIT(15)\n#define SDXC_CAL_DONE\t\tBIT(14)\n#define SDXC_CAL_DL_SHIFT\t8\n#define SDXC_CAL_DL_SW_EN\tBIT(7)\n#define SDXC_CAL_DL_SW_SHIFT\t0\n#define SDXC_CAL_DL_MASK\t0x3f\n\n#define SDXC_CAL_TIMEOUT\t3\t \n\nstruct sunxi_mmc_clk_delay {\n\tu32 output;\n\tu32 sample;\n};\n\nstruct sunxi_idma_des {\n\t__le32 config;\n\t__le32 buf_size;\n\t__le32 buf_addr_ptr1;\n\t__le32 buf_addr_ptr2;\n};\n\nstruct sunxi_mmc_cfg {\n\tu32 idma_des_size_bits;\n\tu32 idma_des_shift;\n\tconst struct sunxi_mmc_clk_delay *clk_delays;\n\n\t \n\tbool can_calibrate;\n\n\t \n\tbool mask_data0;\n\n\t \n\tbool needs_new_timings;\n\n\t \n\tbool ccu_has_timings_switch;\n};\n\nstruct sunxi_mmc_host {\n\tstruct device *dev;\n\tstruct mmc_host\t*mmc;\n\tstruct reset_control *reset;\n\tconst struct sunxi_mmc_cfg *cfg;\n\n\t \n\tvoid __iomem\t*reg_base;\n\n\t \n\tstruct clk\t*clk_ahb;\n\tstruct clk\t*clk_mmc;\n\tstruct clk\t*clk_sample;\n\tstruct clk\t*clk_output;\n\n\t \n\tspinlock_t\tlock;\n\tint\t\tirq;\n\tu32\t\tint_sum;\n\tu32\t\tsdio_imask;\n\n\t \n\tdma_addr_t\tsg_dma;\n\tvoid\t\t*sg_cpu;\n\tbool\t\twait_dma;\n\n\tstruct mmc_request *mrq;\n\tstruct mmc_request *manual_stop_mrq;\n\tint\t\tferror;\n\n\t \n\tbool\t\tvqmmc_enabled;\n\n\t \n\tbool\t\tuse_new_timings;\n};\n\nstatic int sunxi_mmc_reset_host(struct sunxi_mmc_host *host)\n{\n\tunsigned long expire = jiffies + msecs_to_jiffies(250);\n\tu32 rval;\n\n\tmmc_writel(host, REG_GCTRL, SDXC_HARDWARE_RESET);\n\tdo {\n\t\trval = mmc_readl(host, REG_GCTRL);\n\t} while (time_before(jiffies, expire) && (rval & SDXC_HARDWARE_RESET));\n\n\tif (rval & SDXC_HARDWARE_RESET) {\n\t\tdev_err(mmc_dev(host->mmc), \"fatal err reset timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_mmc_init_host(struct sunxi_mmc_host *host)\n{\n\tu32 rval;\n\n\tif (sunxi_mmc_reset_host(host))\n\t\treturn -EIO;\n\n\t \n\tmmc_writel(host, REG_FTRGL, 0x20070008);\n\t \n\tmmc_writel(host, REG_TMOUT, 0xffffffff);\n\t \n\tmmc_writel(host, REG_IMASK, host->sdio_imask);\n\t \n\tmmc_writel(host, REG_RINTR, 0xffffffff);\n\t \n\tmmc_writel(host, REG_DBGC, 0xdeb);\n\t \n\tmmc_writel(host, REG_FUNS, SDXC_CEATA_ON);\n\t \n\tmmc_writel(host, REG_DLBA, host->sg_dma >> host->cfg->idma_des_shift);\n\n\trval = mmc_readl(host, REG_GCTRL);\n\trval |= SDXC_INTERRUPT_ENABLE_BIT;\n\t \n\trval &= ~SDXC_ACCESS_DONE_DIRECT;\n\tmmc_writel(host, REG_GCTRL, rval);\n\n\treturn 0;\n}\n\nstatic void sunxi_mmc_init_idma_des(struct sunxi_mmc_host *host,\n\t\t\t\t    struct mmc_data *data)\n{\n\tstruct sunxi_idma_des *pdes = (struct sunxi_idma_des *)host->sg_cpu;\n\tdma_addr_t next_desc = host->sg_dma;\n\tint i, max_len = (1 << host->cfg->idma_des_size_bits);\n\n\tfor (i = 0; i < data->sg_len; i++) {\n\t\tpdes[i].config = cpu_to_le32(SDXC_IDMAC_DES0_CH |\n\t\t\t\t\t     SDXC_IDMAC_DES0_OWN |\n\t\t\t\t\t     SDXC_IDMAC_DES0_DIC);\n\n\t\tif (data->sg[i].length == max_len)\n\t\t\tpdes[i].buf_size = 0;  \n\t\telse\n\t\t\tpdes[i].buf_size = cpu_to_le32(data->sg[i].length);\n\n\t\tnext_desc += sizeof(struct sunxi_idma_des);\n\t\tpdes[i].buf_addr_ptr1 =\n\t\t\tcpu_to_le32(sg_dma_address(&data->sg[i]) >>\n\t\t\t\t    host->cfg->idma_des_shift);\n\t\tpdes[i].buf_addr_ptr2 =\n\t\t\tcpu_to_le32(next_desc >>\n\t\t\t\t    host->cfg->idma_des_shift);\n\t}\n\n\tpdes[0].config |= cpu_to_le32(SDXC_IDMAC_DES0_FD);\n\tpdes[i - 1].config |= cpu_to_le32(SDXC_IDMAC_DES0_LD |\n\t\t\t\t\t  SDXC_IDMAC_DES0_ER);\n\tpdes[i - 1].config &= cpu_to_le32(~SDXC_IDMAC_DES0_DIC);\n\tpdes[i - 1].buf_addr_ptr2 = 0;\n\n\t \n\twmb();\n}\n\nstatic int sunxi_mmc_map_dma(struct sunxi_mmc_host *host,\n\t\t\t     struct mmc_data *data)\n{\n\tu32 i, dma_len;\n\tstruct scatterlist *sg;\n\n\tdma_len = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\tif (dma_len == 0) {\n\t\tdev_err(mmc_dev(host->mmc), \"dma_map_sg failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (sg->offset & 3 || sg->length & 3) {\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"unaligned scatterlist: os %x length %d\\n\",\n\t\t\t\tsg->offset, sg->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sunxi_mmc_start_dma(struct sunxi_mmc_host *host,\n\t\t\t\tstruct mmc_data *data)\n{\n\tu32 rval;\n\n\tsunxi_mmc_init_idma_des(host, data);\n\n\trval = mmc_readl(host, REG_GCTRL);\n\trval |= SDXC_DMA_ENABLE_BIT;\n\tmmc_writel(host, REG_GCTRL, rval);\n\trval |= SDXC_DMA_RESET;\n\tmmc_writel(host, REG_GCTRL, rval);\n\n\tmmc_writel(host, REG_DMAC, SDXC_IDMAC_SOFT_RESET);\n\n\tif (!(data->flags & MMC_DATA_WRITE))\n\t\tmmc_writel(host, REG_IDIE, SDXC_IDMAC_RECEIVE_INTERRUPT);\n\n\tmmc_writel(host, REG_DMAC,\n\t\t   SDXC_IDMAC_FIX_BURST | SDXC_IDMAC_IDMA_ON);\n}\n\nstatic void sunxi_mmc_send_manual_stop(struct sunxi_mmc_host *host,\n\t\t\t\t       struct mmc_request *req)\n{\n\tu32 arg, cmd_val, ri;\n\tunsigned long expire = jiffies + msecs_to_jiffies(1000);\n\n\tcmd_val = SDXC_START | SDXC_RESP_EXPIRE |\n\t\t  SDXC_STOP_ABORT_CMD | SDXC_CHECK_RESPONSE_CRC;\n\n\tif (req->cmd->opcode == SD_IO_RW_EXTENDED) {\n\t\tcmd_val |= SD_IO_RW_DIRECT;\n\t\targ = (1 << 31) | (0 << 28) | (SDIO_CCCR_ABORT << 9) |\n\t\t      ((req->cmd->arg >> 28) & 0x7);\n\t} else {\n\t\tcmd_val |= MMC_STOP_TRANSMISSION;\n\t\targ = 0;\n\t}\n\n\tmmc_writel(host, REG_CARG, arg);\n\tmmc_writel(host, REG_CMDR, cmd_val);\n\n\tdo {\n\t\tri = mmc_readl(host, REG_RINTR);\n\t} while (!(ri & (SDXC_COMMAND_DONE | SDXC_INTERRUPT_ERROR_BIT)) &&\n\t\t time_before(jiffies, expire));\n\n\tif (!(ri & SDXC_COMMAND_DONE) || (ri & SDXC_INTERRUPT_ERROR_BIT)) {\n\t\tdev_err(mmc_dev(host->mmc), \"send stop command failed\\n\");\n\t\tif (req->stop)\n\t\t\treq->stop->resp[0] = -ETIMEDOUT;\n\t} else {\n\t\tif (req->stop)\n\t\t\treq->stop->resp[0] = mmc_readl(host, REG_RESP0);\n\t}\n\n\tmmc_writel(host, REG_RINTR, 0xffff);\n}\n\nstatic void sunxi_mmc_dump_errinfo(struct sunxi_mmc_host *host)\n{\n\tstruct mmc_command *cmd = host->mrq->cmd;\n\tstruct mmc_data *data = host->mrq->data;\n\n\t \n\tif ((host->int_sum & SDXC_INTERRUPT_ERROR_BIT) ==\n\t\tSDXC_RESP_TIMEOUT && (cmd->opcode == SD_IO_SEND_OP_COND ||\n\t\t\t\t      cmd->opcode == SD_IO_RW_DIRECT))\n\t\treturn;\n\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"smc %d err, cmd %d,%s%s%s%s%s%s%s%s%s%s !!\\n\",\n\t\thost->mmc->index, cmd->opcode,\n\t\tdata ? (data->flags & MMC_DATA_WRITE ? \" WR\" : \" RD\") : \"\",\n\t\thost->int_sum & SDXC_RESP_ERROR     ? \" RE\"     : \"\",\n\t\thost->int_sum & SDXC_RESP_CRC_ERROR  ? \" RCE\"    : \"\",\n\t\thost->int_sum & SDXC_DATA_CRC_ERROR  ? \" DCE\"    : \"\",\n\t\thost->int_sum & SDXC_RESP_TIMEOUT ? \" RTO\"    : \"\",\n\t\thost->int_sum & SDXC_DATA_TIMEOUT ? \" DTO\"    : \"\",\n\t\thost->int_sum & SDXC_FIFO_RUN_ERROR  ? \" FE\"     : \"\",\n\t\thost->int_sum & SDXC_HARD_WARE_LOCKED ? \" HL\"     : \"\",\n\t\thost->int_sum & SDXC_START_BIT_ERROR ? \" SBE\"    : \"\",\n\t\thost->int_sum & SDXC_END_BIT_ERROR   ? \" EBE\"    : \"\"\n\t\t);\n}\n\n \nstatic irqreturn_t sunxi_mmc_finalize_request(struct sunxi_mmc_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_data *data = mrq->data;\n\tu32 rval;\n\n\tmmc_writel(host, REG_IMASK, host->sdio_imask);\n\tmmc_writel(host, REG_IDIE, 0);\n\n\tif (host->int_sum & SDXC_INTERRUPT_ERROR_BIT) {\n\t\tsunxi_mmc_dump_errinfo(host);\n\t\tmrq->cmd->error = -ETIMEDOUT;\n\n\t\tif (data) {\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t\thost->manual_stop_mrq = mrq;\n\t\t}\n\n\t\tif (mrq->stop)\n\t\t\tmrq->stop->error = -ETIMEDOUT;\n\t} else {\n\t\tif (mrq->cmd->flags & MMC_RSP_136) {\n\t\t\tmrq->cmd->resp[0] = mmc_readl(host, REG_RESP3);\n\t\t\tmrq->cmd->resp[1] = mmc_readl(host, REG_RESP2);\n\t\t\tmrq->cmd->resp[2] = mmc_readl(host, REG_RESP1);\n\t\t\tmrq->cmd->resp[3] = mmc_readl(host, REG_RESP0);\n\t\t} else {\n\t\t\tmrq->cmd->resp[0] = mmc_readl(host, REG_RESP0);\n\t\t}\n\n\t\tif (data)\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t}\n\n\tif (data) {\n\t\tmmc_writel(host, REG_IDST, 0x337);\n\t\tmmc_writel(host, REG_DMAC, 0);\n\t\trval = mmc_readl(host, REG_GCTRL);\n\t\trval |= SDXC_DMA_RESET;\n\t\tmmc_writel(host, REG_GCTRL, rval);\n\t\trval &= ~SDXC_DMA_ENABLE_BIT;\n\t\tmmc_writel(host, REG_GCTRL, rval);\n\t\trval |= SDXC_FIFO_RESET;\n\t\tmmc_writel(host, REG_GCTRL, rval);\n\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t}\n\n\tmmc_writel(host, REG_RINTR, 0xffff);\n\n\thost->mrq = NULL;\n\thost->int_sum = 0;\n\thost->wait_dma = false;\n\n\treturn host->manual_stop_mrq ? IRQ_WAKE_THREAD : IRQ_HANDLED;\n}\n\nstatic irqreturn_t sunxi_mmc_irq(int irq, void *dev_id)\n{\n\tstruct sunxi_mmc_host *host = dev_id;\n\tstruct mmc_request *mrq;\n\tu32 msk_int, idma_int;\n\tbool finalize = false;\n\tbool sdio_int = false;\n\tirqreturn_t ret = IRQ_HANDLED;\n\n\tspin_lock(&host->lock);\n\n\tidma_int  = mmc_readl(host, REG_IDST);\n\tmsk_int   = mmc_readl(host, REG_MISTA);\n\n\tdev_dbg(mmc_dev(host->mmc), \"irq: rq %p mi %08x idi %08x\\n\",\n\t\thost->mrq, msk_int, idma_int);\n\n\tmrq = host->mrq;\n\tif (mrq) {\n\t\tif (idma_int & SDXC_IDMAC_RECEIVE_INTERRUPT)\n\t\t\thost->wait_dma = false;\n\n\t\thost->int_sum |= msk_int;\n\n\t\t \n\t\tif ((host->int_sum & SDXC_RESP_TIMEOUT) &&\n\t\t\t\t!(host->int_sum & SDXC_COMMAND_DONE))\n\t\t\tmmc_writel(host, REG_IMASK,\n\t\t\t\t   host->sdio_imask | SDXC_COMMAND_DONE);\n\t\t \n\t\telse if (host->int_sum & SDXC_INTERRUPT_ERROR_BIT)\n\t\t\tfinalize = true;\n\t\telse if ((host->int_sum & SDXC_INTERRUPT_DONE_BIT) &&\n\t\t\t\t!host->wait_dma)\n\t\t\tfinalize = true;\n\t}\n\n\tif (msk_int & SDXC_SDIO_INTERRUPT)\n\t\tsdio_int = true;\n\n\tmmc_writel(host, REG_RINTR, msk_int);\n\tmmc_writel(host, REG_IDST, idma_int);\n\n\tif (finalize)\n\t\tret = sunxi_mmc_finalize_request(host);\n\n\tspin_unlock(&host->lock);\n\n\tif (finalize && ret == IRQ_HANDLED)\n\t\tmmc_request_done(host->mmc, mrq);\n\n\tif (sdio_int)\n\t\tmmc_signal_sdio_irq(host->mmc);\n\n\treturn ret;\n}\n\nstatic irqreturn_t sunxi_mmc_handle_manual_stop(int irq, void *dev_id)\n{\n\tstruct sunxi_mmc_host *host = dev_id;\n\tstruct mmc_request *mrq;\n\tunsigned long iflags;\n\n\tspin_lock_irqsave(&host->lock, iflags);\n\tmrq = host->manual_stop_mrq;\n\tspin_unlock_irqrestore(&host->lock, iflags);\n\n\tif (!mrq) {\n\t\tdev_err(mmc_dev(host->mmc), \"no request for manual stop\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdev_err(mmc_dev(host->mmc), \"data error, sending stop command\\n\");\n\n\t \n\tsunxi_mmc_send_manual_stop(host, mrq);\n\n\tspin_lock_irqsave(&host->lock, iflags);\n\thost->manual_stop_mrq = NULL;\n\tspin_unlock_irqrestore(&host->lock, iflags);\n\n\tmmc_request_done(host->mmc, mrq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int sunxi_mmc_oclk_onoff(struct sunxi_mmc_host *host, u32 oclk_en)\n{\n\tunsigned long expire = jiffies + msecs_to_jiffies(750);\n\tu32 rval;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%sabling the clock\\n\",\n\t\toclk_en ? \"en\" : \"dis\");\n\n\trval = mmc_readl(host, REG_CLKCR);\n\trval &= ~(SDXC_CARD_CLOCK_ON | SDXC_LOW_POWER_ON | SDXC_MASK_DATA0);\n\n\tif (oclk_en)\n\t\trval |= SDXC_CARD_CLOCK_ON;\n\tif (host->cfg->mask_data0)\n\t\trval |= SDXC_MASK_DATA0;\n\n\tmmc_writel(host, REG_CLKCR, rval);\n\n\trval = SDXC_START | SDXC_UPCLK_ONLY | SDXC_WAIT_PRE_OVER;\n\tmmc_writel(host, REG_CMDR, rval);\n\n\tdo {\n\t\trval = mmc_readl(host, REG_CMDR);\n\t} while (time_before(jiffies, expire) && (rval & SDXC_START));\n\n\t \n\tmmc_writel(host, REG_RINTR,\n\t\t   mmc_readl(host, REG_RINTR) & ~SDXC_SDIO_INTERRUPT);\n\n\tif (rval & SDXC_START) {\n\t\tdev_err(mmc_dev(host->mmc), \"fatal err update clk timeout\\n\");\n\t\treturn -EIO;\n\t}\n\n\tif (host->cfg->mask_data0) {\n\t\trval = mmc_readl(host, REG_CLKCR);\n\t\tmmc_writel(host, REG_CLKCR, rval & ~SDXC_MASK_DATA0);\n\t}\n\n\treturn 0;\n}\n\nstatic int sunxi_mmc_calibrate(struct sunxi_mmc_host *host, int reg_off)\n{\n\tif (!host->cfg->can_calibrate)\n\t\treturn 0;\n\n\t \n\twritel(SDXC_CAL_DL_SW_EN, host->reg_base + reg_off);\n\n\treturn 0;\n}\n\nstatic int sunxi_mmc_clk_set_phase(struct sunxi_mmc_host *host,\n\t\t\t\t   struct mmc_ios *ios, u32 rate)\n{\n\tint index;\n\n\t \n\tif (host->use_new_timings)\n\t\treturn 0;\n\n\t \n\tif (!host->cfg->clk_delays)\n\t\treturn 0;\n\n\t \n\tif (rate <= 400000) {\n\t\tindex = SDXC_CLK_400K;\n\t} else if (rate <= 25000000) {\n\t\tindex = SDXC_CLK_25M;\n\t} else if (rate <= 52000000) {\n\t\tif (ios->timing != MMC_TIMING_UHS_DDR50 &&\n\t\t    ios->timing != MMC_TIMING_MMC_DDR52) {\n\t\t\tindex = SDXC_CLK_50M;\n\t\t} else if (ios->bus_width == MMC_BUS_WIDTH_8) {\n\t\t\tindex = SDXC_CLK_50M_DDR_8BIT;\n\t\t} else {\n\t\t\tindex = SDXC_CLK_50M_DDR;\n\t\t}\n\t} else {\n\t\tdev_dbg(mmc_dev(host->mmc), \"Invalid clock... returning\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclk_set_phase(host->clk_sample, host->cfg->clk_delays[index].sample);\n\tclk_set_phase(host->clk_output, host->cfg->clk_delays[index].output);\n\n\treturn 0;\n}\n\nstatic int sunxi_mmc_clk_set_rate(struct sunxi_mmc_host *host,\n\t\t\t\t  struct mmc_ios *ios)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tlong rate;\n\tu32 rval, clock = ios->clock, div = 1;\n\tint ret;\n\n\tret = sunxi_mmc_oclk_onoff(host, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmmc->actual_clock = 0;\n\n\tif (!ios->clock)\n\t\treturn 0;\n\n\t \n\tif (ios->timing == MMC_TIMING_MMC_DDR52 &&\n\t    (host->use_new_timings ||\n\t     ios->bus_width == MMC_BUS_WIDTH_8)) {\n\t\tdiv = 2;\n\t\tclock <<= 1;\n\t}\n\n\tif (host->use_new_timings && host->cfg->ccu_has_timings_switch) {\n\t\tret = sunxi_ccu_set_mmc_timing_mode(host->clk_mmc, true);\n\t\tif (ret) {\n\t\t\tdev_err(mmc_dev(mmc),\n\t\t\t\t\"error setting new timing mode\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trate = clk_round_rate(host->clk_mmc, clock);\n\tif (rate < 0) {\n\t\tdev_err(mmc_dev(mmc), \"error rounding clk to %d: %ld\\n\",\n\t\t\tclock, rate);\n\t\treturn rate;\n\t}\n\tdev_dbg(mmc_dev(mmc), \"setting clk to %d, rounded %ld\\n\",\n\t\tclock, rate);\n\n\t \n\tret = clk_set_rate(host->clk_mmc, rate);\n\tif (ret) {\n\t\tdev_err(mmc_dev(mmc), \"error setting clk to %ld: %d\\n\",\n\t\t\trate, ret);\n\t\treturn ret;\n\t}\n\n\t \n\trval = mmc_readl(host, REG_CLKCR);\n\trval &= ~0xff;\n\trval |= div - 1;\n\tmmc_writel(host, REG_CLKCR, rval);\n\n\t \n\trate /= div;\n\n\t \n\tif (host->use_new_timings) {\n\t\t \n\t\trval = mmc_readl(host, REG_SD_NTSR);\n\t\trval |= SDXC_2X_TIMING_MODE;\n\t\tmmc_writel(host, REG_SD_NTSR, rval);\n\t}\n\n\t \n\tret = sunxi_mmc_clk_set_phase(host, ios, rate);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sunxi_mmc_calibrate(host, SDXC_REG_SAMP_DL_REG);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tret = sunxi_mmc_oclk_onoff(host, 1);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmmc->actual_clock = rate;\n\n\treturn 0;\n}\n\nstatic void sunxi_mmc_set_bus_width(struct sunxi_mmc_host *host,\n\t\t\t\t   unsigned char width)\n{\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tmmc_writel(host, REG_WIDTH, SDXC_WIDTH1);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tmmc_writel(host, REG_WIDTH, SDXC_WIDTH4);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tmmc_writel(host, REG_WIDTH, SDXC_WIDTH8);\n\t\tbreak;\n\t}\n}\n\nstatic void sunxi_mmc_set_clk(struct sunxi_mmc_host *host, struct mmc_ios *ios)\n{\n\tu32 rval;\n\n\t \n\trval = mmc_readl(host, REG_GCTRL);\n\tif (ios->timing == MMC_TIMING_UHS_DDR50 ||\n\t    ios->timing == MMC_TIMING_MMC_DDR52)\n\t\trval |= SDXC_DDR_MODE;\n\telse\n\t\trval &= ~SDXC_DDR_MODE;\n\tmmc_writel(host, REG_GCTRL, rval);\n\n\thost->ferror = sunxi_mmc_clk_set_rate(host, ios);\n\t \n}\n\nstatic void sunxi_mmc_card_power(struct sunxi_mmc_host *host,\n\t\t\t\t struct mmc_ios *ios)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_UP:\n\t\tdev_dbg(mmc_dev(mmc), \"Powering card up\\n\");\n\n\t\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\t\thost->ferror = mmc_regulator_set_ocr(mmc,\n\t\t\t\t\t\t\t     mmc->supply.vmmc,\n\t\t\t\t\t\t\t     ios->vdd);\n\t\t\tif (host->ferror)\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\t\thost->ferror = regulator_enable(mmc->supply.vqmmc);\n\t\t\tif (host->ferror) {\n\t\t\t\tdev_err(mmc_dev(mmc),\n\t\t\t\t\t\"failed to enable vqmmc\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thost->vqmmc_enabled = true;\n\t\t}\n\t\tbreak;\n\n\tcase MMC_POWER_OFF:\n\t\tdev_dbg(mmc_dev(mmc), \"Powering card off\\n\");\n\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled)\n\t\t\tregulator_disable(mmc->supply.vqmmc);\n\n\t\thost->vqmmc_enabled = false;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(mmc_dev(mmc), \"Ignoring unknown card power state\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void sunxi_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\n\tsunxi_mmc_card_power(host, ios);\n\tsunxi_mmc_set_bus_width(host, ios->bus_width);\n\tsunxi_mmc_set_clk(host, ios);\n}\n\nstatic int sunxi_mmc_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tint ret;\n\n\t \n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\treturn ret < 0 ? ret : 0;\n\t}\n\n\t \n\tif (mmc->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void sunxi_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tu32 imask;\n\n\tif (enable)\n\t\tpm_runtime_get_noresume(host->dev);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\timask = mmc_readl(host, REG_IMASK);\n\tif (enable) {\n\t\thost->sdio_imask = SDXC_SDIO_INTERRUPT;\n\t\timask |= SDXC_SDIO_INTERRUPT;\n\t} else {\n\t\thost->sdio_imask = 0;\n\t\timask &= ~SDXC_SDIO_INTERRUPT;\n\t}\n\tmmc_writel(host, REG_IMASK, imask);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (!enable)\n\t\tpm_runtime_put_noidle(host->mmc->parent);\n}\n\nstatic void sunxi_mmc_hw_reset(struct mmc_host *mmc)\n{\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\tmmc_writel(host, REG_HWRST, 0);\n\tudelay(10);\n\tmmc_writel(host, REG_HWRST, 1);\n\tudelay(300);\n}\n\nstatic void sunxi_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tunsigned long iflags;\n\tu32 imask = SDXC_INTERRUPT_ERROR_BIT;\n\tu32 cmd_val = SDXC_START | (cmd->opcode & 0x3f);\n\tbool wait_dma = host->wait_dma;\n\tint ret;\n\n\t \n\tif (host->ferror) {\n\t\tmrq->cmd->error = host->ferror;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tif (data) {\n\t\tret = sunxi_mmc_map_dma(host, data);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"map DMA failed\\n\");\n\t\t\tcmd->error = ret;\n\t\t\tdata->error = ret;\n\t\t\tmmc_request_done(mmc, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (cmd->opcode == MMC_GO_IDLE_STATE) {\n\t\tcmd_val |= SDXC_SEND_INIT_SEQUENCE;\n\t\timask |= SDXC_COMMAND_DONE;\n\t}\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tcmd_val |= SDXC_RESP_EXPIRE;\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tcmd_val |= SDXC_LONG_RESPONSE;\n\t\tif (cmd->flags & MMC_RSP_CRC)\n\t\t\tcmd_val |= SDXC_CHECK_RESPONSE_CRC;\n\n\t\tif ((cmd->flags & MMC_CMD_MASK) == MMC_CMD_ADTC) {\n\t\t\tcmd_val |= SDXC_DATA_EXPIRE | SDXC_WAIT_PRE_OVER;\n\n\t\t\tif (cmd->data->stop) {\n\t\t\t\timask |= SDXC_AUTO_COMMAND_DONE;\n\t\t\t\tcmd_val |= SDXC_SEND_AUTO_STOP;\n\t\t\t} else {\n\t\t\t\timask |= SDXC_DATA_OVER;\n\t\t\t}\n\n\t\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\t\tcmd_val |= SDXC_WRITE;\n\t\t\telse\n\t\t\t\twait_dma = true;\n\t\t} else {\n\t\t\timask |= SDXC_COMMAND_DONE;\n\t\t}\n\t} else {\n\t\timask |= SDXC_COMMAND_DONE;\n\t}\n\n\tdev_dbg(mmc_dev(mmc), \"cmd %d(%08x) arg %x ie 0x%08x len %d\\n\",\n\t\tcmd_val & 0x3f, cmd_val, cmd->arg, imask,\n\t\tmrq->data ? mrq->data->blksz * mrq->data->blocks : 0);\n\n\tspin_lock_irqsave(&host->lock, iflags);\n\n\tif (host->mrq || host->manual_stop_mrq) {\n\t\tspin_unlock_irqrestore(&host->lock, iflags);\n\n\t\tif (data)\n\t\t\tdma_unmap_sg(mmc_dev(mmc), data->sg, data->sg_len,\n\t\t\t\t     mmc_get_dma_dir(data));\n\n\t\tdev_err(mmc_dev(mmc), \"request already pending\\n\");\n\t\tmrq->cmd->error = -EBUSY;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tif (data) {\n\t\tmmc_writel(host, REG_BLKSZ, data->blksz);\n\t\tmmc_writel(host, REG_BCNTR, data->blksz * data->blocks);\n\t\tsunxi_mmc_start_dma(host, data);\n\t}\n\n\thost->mrq = mrq;\n\thost->wait_dma = wait_dma;\n\tmmc_writel(host, REG_IMASK, host->sdio_imask | imask);\n\tmmc_writel(host, REG_CARG, cmd->arg);\n\tmmc_writel(host, REG_CMDR, cmd_val);\n\n\tspin_unlock_irqrestore(&host->lock, iflags);\n}\n\nstatic int sunxi_mmc_card_busy(struct mmc_host *mmc)\n{\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\n\treturn !!(mmc_readl(host, REG_STAS) & SDXC_CARD_DATA_BUSY);\n}\n\nstatic const struct mmc_host_ops sunxi_mmc_ops = {\n\t.request\t = sunxi_mmc_request,\n\t.set_ios\t = sunxi_mmc_set_ios,\n\t.get_ro\t\t = mmc_gpio_get_ro,\n\t.get_cd\t\t = mmc_gpio_get_cd,\n\t.enable_sdio_irq = sunxi_mmc_enable_sdio_irq,\n\t.start_signal_voltage_switch = sunxi_mmc_volt_switch,\n\t.card_hw_reset\t = sunxi_mmc_hw_reset,\n\t.card_busy\t = sunxi_mmc_card_busy,\n};\n\nstatic const struct sunxi_mmc_clk_delay sunxi_mmc_clk_delays[] = {\n\t[SDXC_CLK_400K]\t\t= { .output = 180, .sample = 180 },\n\t[SDXC_CLK_25M]\t\t= { .output = 180, .sample =  75 },\n\t[SDXC_CLK_50M]\t\t= { .output =  90, .sample = 120 },\n\t[SDXC_CLK_50M_DDR]\t= { .output =  60, .sample = 120 },\n\t \n\t[SDXC_CLK_50M_DDR_8BIT]\t= { .output =  90, .sample = 180 },\n};\n\nstatic const struct sunxi_mmc_clk_delay sun9i_mmc_clk_delays[] = {\n\t[SDXC_CLK_400K]\t\t= { .output = 180, .sample = 180 },\n\t[SDXC_CLK_25M]\t\t= { .output = 180, .sample =  75 },\n\t[SDXC_CLK_50M]\t\t= { .output = 150, .sample = 120 },\n\t[SDXC_CLK_50M_DDR]\t= { .output =  54, .sample =  36 },\n\t[SDXC_CLK_50M_DDR_8BIT]\t= { .output =  72, .sample =  72 },\n};\n\nstatic const struct sunxi_mmc_cfg sun4i_a10_cfg = {\n\t.idma_des_size_bits = 13,\n\t.clk_delays = NULL,\n\t.can_calibrate = false,\n};\n\nstatic const struct sunxi_mmc_cfg sun5i_a13_cfg = {\n\t.idma_des_size_bits = 16,\n\t.clk_delays = NULL,\n\t.can_calibrate = false,\n};\n\nstatic const struct sunxi_mmc_cfg sun7i_a20_cfg = {\n\t.idma_des_size_bits = 16,\n\t.clk_delays = sunxi_mmc_clk_delays,\n\t.can_calibrate = false,\n};\n\nstatic const struct sunxi_mmc_cfg sun8i_a83t_emmc_cfg = {\n\t.idma_des_size_bits = 16,\n\t.clk_delays = sunxi_mmc_clk_delays,\n\t.can_calibrate = false,\n\t.ccu_has_timings_switch = true,\n};\n\nstatic const struct sunxi_mmc_cfg sun9i_a80_cfg = {\n\t.idma_des_size_bits = 16,\n\t.clk_delays = sun9i_mmc_clk_delays,\n\t.can_calibrate = false,\n};\n\nstatic const struct sunxi_mmc_cfg sun20i_d1_cfg = {\n\t.idma_des_size_bits = 13,\n\t.idma_des_shift = 2,\n\t.can_calibrate = true,\n\t.mask_data0 = true,\n\t.needs_new_timings = true,\n};\n\nstatic const struct sunxi_mmc_cfg sun50i_a64_cfg = {\n\t.idma_des_size_bits = 16,\n\t.clk_delays = NULL,\n\t.can_calibrate = true,\n\t.mask_data0 = true,\n\t.needs_new_timings = true,\n};\n\nstatic const struct sunxi_mmc_cfg sun50i_a64_emmc_cfg = {\n\t.idma_des_size_bits = 13,\n\t.clk_delays = NULL,\n\t.can_calibrate = true,\n\t.needs_new_timings = true,\n};\n\nstatic const struct sunxi_mmc_cfg sun50i_a100_cfg = {\n\t.idma_des_size_bits = 16,\n\t.idma_des_shift = 2,\n\t.clk_delays = NULL,\n\t.can_calibrate = true,\n\t.mask_data0 = true,\n\t.needs_new_timings = true,\n};\n\nstatic const struct sunxi_mmc_cfg sun50i_a100_emmc_cfg = {\n\t.idma_des_size_bits = 13,\n\t.idma_des_shift = 2,\n\t.clk_delays = NULL,\n\t.can_calibrate = true,\n\t.needs_new_timings = true,\n};\n\nstatic const struct of_device_id sunxi_mmc_of_match[] = {\n\t{ .compatible = \"allwinner,sun4i-a10-mmc\", .data = &sun4i_a10_cfg },\n\t{ .compatible = \"allwinner,sun5i-a13-mmc\", .data = &sun5i_a13_cfg },\n\t{ .compatible = \"allwinner,sun7i-a20-mmc\", .data = &sun7i_a20_cfg },\n\t{ .compatible = \"allwinner,sun8i-a83t-emmc\", .data = &sun8i_a83t_emmc_cfg },\n\t{ .compatible = \"allwinner,sun9i-a80-mmc\", .data = &sun9i_a80_cfg },\n\t{ .compatible = \"allwinner,sun20i-d1-mmc\", .data = &sun20i_d1_cfg },\n\t{ .compatible = \"allwinner,sun50i-a64-mmc\", .data = &sun50i_a64_cfg },\n\t{ .compatible = \"allwinner,sun50i-a64-emmc\", .data = &sun50i_a64_emmc_cfg },\n\t{ .compatible = \"allwinner,sun50i-a100-mmc\", .data = &sun50i_a100_cfg },\n\t{ .compatible = \"allwinner,sun50i-a100-emmc\", .data = &sun50i_a100_emmc_cfg },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sunxi_mmc_of_match);\n\nstatic int sunxi_mmc_enable(struct sunxi_mmc_host *host)\n{\n\tint ret;\n\n\tif (!IS_ERR(host->reset)) {\n\t\tret = reset_control_reset(host->reset);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, \"Couldn't reset the MMC controller (%d)\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = clk_prepare_enable(host->clk_ahb);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Couldn't enable the bus clocks (%d)\\n\", ret);\n\t\tgoto error_assert_reset;\n\t}\n\n\tret = clk_prepare_enable(host->clk_mmc);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Enable mmc clk err %d\\n\", ret);\n\t\tgoto error_disable_clk_ahb;\n\t}\n\n\tret = clk_prepare_enable(host->clk_output);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Enable output clk err %d\\n\", ret);\n\t\tgoto error_disable_clk_mmc;\n\t}\n\n\tret = clk_prepare_enable(host->clk_sample);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Enable sample clk err %d\\n\", ret);\n\t\tgoto error_disable_clk_output;\n\t}\n\n\t \n\tret = sunxi_mmc_reset_host(host);\n\tif (ret)\n\t\tgoto error_disable_clk_sample;\n\n\treturn 0;\n\nerror_disable_clk_sample:\n\tclk_disable_unprepare(host->clk_sample);\nerror_disable_clk_output:\n\tclk_disable_unprepare(host->clk_output);\nerror_disable_clk_mmc:\n\tclk_disable_unprepare(host->clk_mmc);\nerror_disable_clk_ahb:\n\tclk_disable_unprepare(host->clk_ahb);\nerror_assert_reset:\n\tif (!IS_ERR(host->reset))\n\t\treset_control_assert(host->reset);\n\treturn ret;\n}\n\nstatic void sunxi_mmc_disable(struct sunxi_mmc_host *host)\n{\n\tsunxi_mmc_reset_host(host);\n\n\tclk_disable_unprepare(host->clk_sample);\n\tclk_disable_unprepare(host->clk_output);\n\tclk_disable_unprepare(host->clk_mmc);\n\tclk_disable_unprepare(host->clk_ahb);\n\n\tif (!IS_ERR(host->reset))\n\t\treset_control_assert(host->reset);\n}\n\nstatic int sunxi_mmc_resource_request(struct sunxi_mmc_host *host,\n\t\t\t\t      struct platform_device *pdev)\n{\n\tint ret;\n\n\thost->cfg = of_device_get_match_data(&pdev->dev);\n\tif (!host->cfg)\n\t\treturn -EINVAL;\n\n\tret = mmc_regulator_get_supply(host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\thost->reg_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->reg_base))\n\t\treturn PTR_ERR(host->reg_base);\n\n\thost->clk_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(host->clk_ahb)) {\n\t\tdev_err(&pdev->dev, \"Could not get ahb clock\\n\");\n\t\treturn PTR_ERR(host->clk_ahb);\n\t}\n\n\thost->clk_mmc = devm_clk_get(&pdev->dev, \"mmc\");\n\tif (IS_ERR(host->clk_mmc)) {\n\t\tdev_err(&pdev->dev, \"Could not get mmc clock\\n\");\n\t\treturn PTR_ERR(host->clk_mmc);\n\t}\n\n\tif (host->cfg->clk_delays) {\n\t\thost->clk_output = devm_clk_get(&pdev->dev, \"output\");\n\t\tif (IS_ERR(host->clk_output)) {\n\t\t\tdev_err(&pdev->dev, \"Could not get output clock\\n\");\n\t\t\treturn PTR_ERR(host->clk_output);\n\t\t}\n\n\t\thost->clk_sample = devm_clk_get(&pdev->dev, \"sample\");\n\t\tif (IS_ERR(host->clk_sample)) {\n\t\t\tdev_err(&pdev->dev, \"Could not get sample clock\\n\");\n\t\t\treturn PTR_ERR(host->clk_sample);\n\t\t}\n\t}\n\n\thost->reset = devm_reset_control_get_optional_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t\t\"ahb\");\n\tif (PTR_ERR(host->reset) == -EPROBE_DEFER)\n\t\treturn PTR_ERR(host->reset);\n\n\tret = sunxi_mmc_enable(host);\n\tif (ret)\n\t\treturn ret;\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto error_disable_mmc;\n\t}\n\n\treturn devm_request_threaded_irq(&pdev->dev, host->irq, sunxi_mmc_irq,\n\t\t\tsunxi_mmc_handle_manual_stop, 0, \"sunxi-mmc\", host);\n\nerror_disable_mmc:\n\tsunxi_mmc_disable(host);\n\treturn ret;\n}\n\nstatic int sunxi_mmc_probe(struct platform_device *pdev)\n{\n\tstruct sunxi_mmc_host *host;\n\tstruct mmc_host *mmc;\n\tint ret;\n\n\tmmc = mmc_alloc_host(sizeof(struct sunxi_mmc_host), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"mmc alloc host failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tplatform_set_drvdata(pdev, mmc);\n\n\thost = mmc_priv(mmc);\n\thost->dev = &pdev->dev;\n\thost->mmc = mmc;\n\tspin_lock_init(&host->lock);\n\n\tret = sunxi_mmc_resource_request(host, pdev);\n\tif (ret)\n\t\tgoto error_free_host;\n\n\thost->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,\n\t\t\t\t\t  &host->sg_dma, GFP_KERNEL);\n\tif (!host->sg_cpu) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate DMA descriptor mem\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto error_free_host;\n\t}\n\n\tif (host->cfg->ccu_has_timings_switch) {\n\t\t \n\t\tsunxi_ccu_set_mmc_timing_mode(host->clk_mmc, true);\n\n\t\t \n\t\tret = sunxi_ccu_get_mmc_timing_mode(host->clk_mmc);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tdev_warn(&pdev->dev, \"MMC clk timing mode unknown\\n\");\n\t\t\thost->use_new_timings = false;\n\t\t} else {\n\t\t\thost->use_new_timings = !!ret;\n\t\t}\n\t} else if (host->cfg->needs_new_timings) {\n\t\t \n\t\thost->use_new_timings = true;\n\t}\n\n\tmmc->ops\t\t= &sunxi_mmc_ops;\n\tmmc->max_blk_count\t= 8192;\n\tmmc->max_blk_size\t= 4096;\n\tmmc->max_segs\t\t= PAGE_SIZE / sizeof(struct sunxi_idma_des);\n\tmmc->max_seg_size\t= (1 << host->cfg->idma_des_size_bits);\n\tmmc->max_req_size\t= mmc->max_seg_size * mmc->max_segs;\n\t \n\tmmc->f_min\t\t=   400000;\n\tmmc->f_max\t\t= 52000000;\n\tmmc->caps\t       |= MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED |\n\t\t\t\t  MMC_CAP_SDIO_IRQ;\n\n\t \n\tif ((host->cfg->clk_delays || host->use_new_timings) &&\n\t    !of_device_is_compatible(pdev->dev.of_node,\n\t\t\t\t     \"allwinner,sun50i-h5-emmc\"))\n\t\tmmc->caps      |= MMC_CAP_1_8V_DDR | MMC_CAP_3_3V_DDR;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto error_free_dma;\n\n\t \n\tif (!(host->cfg->clk_delays || host->use_new_timings)) {\n\t\tmmc->caps &= ~(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR |\n\t\t\t       MMC_CAP_1_2V_DDR | MMC_CAP_UHS);\n\t\tmmc->caps2 &= ~MMC_CAP2_HS200;\n\t}\n\n\t \n\tmmc->caps2 &= ~MMC_CAP2_HS400;\n\n\tret = sunxi_mmc_init_host(host);\n\tif (ret)\n\t\tgoto error_free_dma;\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto error_free_dma;\n\n\tdev_info(&pdev->dev, \"initialized, max. request size: %u KB%s\\n\",\n\t\t mmc->max_req_size >> 10,\n\t\t host->use_new_timings ? \", uses new timings mode\" : \"\");\n\n\treturn 0;\n\nerror_free_dma:\n\tdma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\nerror_free_host:\n\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void sunxi_mmc_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host\t*mmc = platform_get_drvdata(pdev);\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\n\tmmc_remove_host(mmc);\n\tpm_runtime_disable(&pdev->dev);\n\tif (!pm_runtime_status_suspended(&pdev->dev)) {\n\t\tdisable_irq(host->irq);\n\t\tsunxi_mmc_disable(host);\n\t}\n\tdma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);\n\tmmc_free_host(mmc);\n}\n\n#ifdef CONFIG_PM\nstatic int sunxi_mmc_runtime_resume(struct device *dev)\n{\n\tstruct mmc_host\t*mmc = dev_get_drvdata(dev);\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tret = sunxi_mmc_enable(host);\n\tif (ret)\n\t\treturn ret;\n\n\tsunxi_mmc_init_host(host);\n\tsunxi_mmc_set_bus_width(host, mmc->ios.bus_width);\n\tsunxi_mmc_set_clk(host, &mmc->ios);\n\tenable_irq(host->irq);\n\n\treturn 0;\n}\n\nstatic int sunxi_mmc_runtime_suspend(struct device *dev)\n{\n\tstruct mmc_host\t*mmc = dev_get_drvdata(dev);\n\tstruct sunxi_mmc_host *host = mmc_priv(mmc);\n\n\t \n\tdisable_irq(host->irq);\n\tsunxi_mmc_reset_host(host);\n\tsunxi_mmc_disable(host);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops sunxi_mmc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(sunxi_mmc_runtime_suspend,\n\t\t\t   sunxi_mmc_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver sunxi_mmc_driver = {\n\t.driver = {\n\t\t.name\t= \"sunxi-mmc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sunxi_mmc_of_match,\n\t\t.pm = &sunxi_mmc_pm_ops,\n\t},\n\t.probe\t\t= sunxi_mmc_probe,\n\t.remove_new\t= sunxi_mmc_remove,\n};\nmodule_platform_driver(sunxi_mmc_driver);\n\nMODULE_DESCRIPTION(\"Allwinner's SD/MMC Card Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"David Lanzend\u00f6rfer <david.lanzendoerfer@o2s.ch>\");\nMODULE_ALIAS(\"platform:sunxi-mmc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}