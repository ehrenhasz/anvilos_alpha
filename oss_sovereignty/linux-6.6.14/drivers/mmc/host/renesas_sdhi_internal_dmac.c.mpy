{
  "module_name": "renesas_sdhi_internal_dmac.c",
  "hash_id": "da4d980e09ce6fc92fca689accd7974e73d4aa2ce67598cde8321343ce80c6d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/renesas_sdhi_internal_dmac.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io-64-nonatomic-hi-lo.h>\n#include <linux/mfd/tmio.h>\n#include <linux/mmc/host.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pagemap.h>\n#include <linux/scatterlist.h>\n#include <linux/sys_soc.h>\n\n#include \"renesas_sdhi.h\"\n#include \"tmio_mmc.h\"\n\n#define DM_CM_DTRAN_MODE\t0x820\n#define DM_CM_DTRAN_CTRL\t0x828\n#define DM_CM_RST\t\t0x830\n#define DM_CM_INFO1\t\t0x840\n#define DM_CM_INFO1_MASK\t0x848\n#define DM_CM_INFO2\t\t0x850\n#define DM_CM_INFO2_MASK\t0x858\n#define DM_DTRAN_ADDR\t\t0x880\n\n \n#define DTRAN_MODE_CH_NUM_CH0\t0\t \n#define DTRAN_MODE_CH_NUM_CH1\tBIT(16)\t \n#define DTRAN_MODE_BUS_WIDTH\t(BIT(5) | BIT(4))\n#define DTRAN_MODE_ADDR_MODE\tBIT(0)\t \n\n \n#define DTRAN_CTRL_DM_START\tBIT(0)\n\n \n#define RST_DTRANRST1\t\tBIT(9)\n#define RST_DTRANRST0\t\tBIT(8)\n#define RST_RESERVED_BITS\tGENMASK_ULL(31, 0)\n\n \n#define INFO1_MASK_CLEAR\tGENMASK_ULL(31, 0)\n#define INFO1_DTRANEND1\t\tBIT(20)\n#define INFO1_DTRANEND1_OLD\tBIT(17)\n#define INFO1_DTRANEND0\t\tBIT(16)\n\n \n#define INFO2_MASK_CLEAR\tGENMASK_ULL(31, 0)\n#define INFO2_DTRANERR1\t\tBIT(17)\n#define INFO2_DTRANERR0\t\tBIT(16)\n\nenum renesas_sdhi_dma_cookie {\n\tCOOKIE_UNMAPPED,\n\tCOOKIE_PRE_MAPPED,\n\tCOOKIE_MAPPED,\n};\n\n \n\nstatic unsigned long global_flags;\n \n#define SDHI_INTERNAL_DMAC_RX_IN_USE\t0\n\n \nstatic struct renesas_sdhi_scc rcar_gen3_scc_taps[] = {\n\t{\n\t\t.clk_rate = 0,\n\t\t.tap = 0x00000300,\n\t\t.tap_hs400_4tap = 0x00000100,\n\t},\n};\n\nstatic const struct renesas_sdhi_of_data of_data_rza2 = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_CLK_ACTUAL |\n\t\t\t  TMIO_MMC_HAVE_CBSY,\n\t.tmio_ocr_mask\t= MMC_VDD_32_33,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY,\n\t.bus_shift\t= 2,\n\t.scc_offset\t= 0 - 0x1000,\n\t.taps\t\t= rcar_gen3_scc_taps,\n\t.taps_num\t= ARRAY_SIZE(rcar_gen3_scc_taps),\n\t \n\t.max_blk_count\t= UINT_MAX / TMIO_MAX_BLK_SIZE,\n\t.max_segs\t= 1,\n};\n\nstatic const struct renesas_sdhi_of_data of_data_rcar_gen3 = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_CLK_ACTUAL |\n\t\t\t  TMIO_MMC_HAVE_CBSY | TMIO_MMC_MIN_RCAR2,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY,\n\t.capabilities2\t= MMC_CAP2_NO_WRITE_PROTECT | MMC_CAP2_MERGE_CAPABLE,\n\t.bus_shift\t= 2,\n\t.scc_offset\t= 0x1000,\n\t.taps\t\t= rcar_gen3_scc_taps,\n\t.taps_num\t= ARRAY_SIZE(rcar_gen3_scc_taps),\n\t \n\t.max_blk_count\t= UINT_MAX / TMIO_MAX_BLK_SIZE,\n\t.max_segs\t= 1,\n\t.sdhi_flags\t= SDHI_FLAG_NEED_CLKH_FALLBACK,\n};\n\nstatic const struct renesas_sdhi_of_data of_data_rcar_gen3_no_sdh_fallback = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_CLK_ACTUAL |\n\t\t\t  TMIO_MMC_HAVE_CBSY | TMIO_MMC_MIN_RCAR2,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY,\n\t.capabilities2\t= MMC_CAP2_NO_WRITE_PROTECT | MMC_CAP2_MERGE_CAPABLE,\n\t.bus_shift\t= 2,\n\t.scc_offset\t= 0x1000,\n\t.taps\t\t= rcar_gen3_scc_taps,\n\t.taps_num\t= ARRAY_SIZE(rcar_gen3_scc_taps),\n\t \n\t.max_blk_count\t= UINT_MAX / TMIO_MAX_BLK_SIZE,\n\t.max_segs\t= 1,\n};\n\nstatic const u8 r8a7796_es13_calib_table[2][SDHI_CALIB_TABLE_MAX] = {\n\t{ 3,  3,  3,  3,  3,  3,  3,  4,  4,  5,  6,  7,  8,  9, 10, 15,\n\t 16, 16, 16, 16, 16, 16, 17, 18, 18, 19, 20, 21, 22, 23, 24, 25 },\n\t{ 5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  5,  6,  7,  8, 11,\n\t 12, 17, 18, 18, 18, 18, 18, 18, 18, 19, 20, 21, 22, 23, 25, 25 }\n};\n\nstatic const u8 r8a77965_calib_table[2][SDHI_CALIB_TABLE_MAX] = {\n\t{ 1,  2,  6,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 15, 15, 16,\n\t 17, 18, 19, 20, 21, 22, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31 },\n\t{ 2,  3,  4,  4,  5,  6,  7,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n\t 17, 17, 20, 21, 22, 23, 24, 25, 27, 28, 29, 30, 31, 31, 31, 31 }\n};\n\nstatic const u8 r8a77990_calib_table[2][SDHI_CALIB_TABLE_MAX] = {\n\t{ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\t  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n\t{ 0,  0,  0,  1,  2,  3,  3,  4,  4,  4,  5,  5,  6,  8,  9, 10,\n\t 11, 12, 13, 15, 16, 17, 17, 18, 18, 19, 20, 22, 24, 25, 26, 26 }\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_4tap_nohs400 = {\n\t.hs400_disabled = true,\n\t.hs400_4taps = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_4tap_nohs400_one_rx = {\n\t.hs400_disabled = true,\n\t.hs400_4taps = true,\n\t.dma_one_rx_only = true,\n\t.old_info1_layout = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_4tap = {\n\t.hs400_4taps = true,\n\t.hs400_bad_taps = BIT(2) | BIT(3) | BIT(6) | BIT(7),\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_nohs400 = {\n\t.hs400_disabled = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_fixed_addr = {\n\t.fixed_addr_mode = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_bad_taps1357 = {\n\t.hs400_bad_taps = BIT(1) | BIT(3) | BIT(5) | BIT(7),\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_bad_taps2367 = {\n\t.hs400_bad_taps = BIT(2) | BIT(3) | BIT(6) | BIT(7),\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_r8a7796_es13 = {\n\t.hs400_4taps = true,\n\t.hs400_bad_taps = BIT(2) | BIT(3) | BIT(6) | BIT(7),\n\t.hs400_calib_table = r8a7796_es13_calib_table,\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_r8a77965 = {\n\t.hs400_bad_taps = BIT(2) | BIT(3) | BIT(6) | BIT(7),\n\t.hs400_calib_table = r8a77965_calib_table,\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_r8a77990 = {\n\t.hs400_calib_table = r8a77990_calib_table,\n\t.manual_tap_correction = true,\n};\n\nstatic const struct renesas_sdhi_quirks sdhi_quirks_r9a09g011 = {\n\t.fixed_addr_mode = true,\n\t.hs400_disabled = true,\n};\n\n \nstatic const struct soc_device_attribute sdhi_quirks_match[]  = {\n\t{ .soc_id = \"r8a774a1\", .revision = \"ES1.[012]\", .data = &sdhi_quirks_4tap_nohs400 },\n\t{ .soc_id = \"r8a7795\", .revision = \"ES2.0\", .data = &sdhi_quirks_4tap },\n\t{ .soc_id = \"r8a7796\", .revision = \"ES1.0\", .data = &sdhi_quirks_4tap_nohs400_one_rx },\n\t{ .soc_id = \"r8a7796\", .revision = \"ES1.[12]\", .data = &sdhi_quirks_4tap_nohs400 },\n\t{ .soc_id = \"r8a7796\", .revision = \"ES1.*\", .data = &sdhi_quirks_r8a7796_es13 },\n\t{ .soc_id = \"r8a77980\", .revision = \"ES1.*\", .data = &sdhi_quirks_nohs400 },\n\t{   }\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r8a7795_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_bad_taps2367,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r8a77961_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_bad_taps1357,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r8a77965_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_r8a77965,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r8a77970_compatible = {\n\t.of_data = &of_data_rcar_gen3_no_sdh_fallback,\n\t.quirks = &sdhi_quirks_nohs400,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r8a77990_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_r8a77990,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_r9a09g011_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_r9a09g011,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_rcar_gen3_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_rcar_gen3_nohs400_compatible = {\n\t.of_data = &of_data_rcar_gen3,\n\t.quirks = &sdhi_quirks_nohs400,\n};\n\nstatic const struct renesas_sdhi_of_data_with_quirks of_rza2_compatible = {\n\t.of_data\t= &of_data_rza2,\n\t.quirks\t\t= &sdhi_quirks_fixed_addr,\n};\n\nstatic const struct of_device_id renesas_sdhi_internal_dmac_of_match[] = {\n\t{ .compatible = \"renesas,sdhi-r7s9210\", .data = &of_rza2_compatible, },\n\t{ .compatible = \"renesas,sdhi-mmc-r8a77470\", .data = &of_rcar_gen3_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7795\", .data = &of_r8a7795_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a77961\", .data = &of_r8a77961_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a77965\", .data = &of_r8a77965_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a77970\", .data = &of_r8a77970_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a77990\", .data = &of_r8a77990_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a77995\", .data = &of_rcar_gen3_nohs400_compatible, },\n\t{ .compatible = \"renesas,sdhi-r9a09g011\", .data = &of_r9a09g011_compatible, },\n\t{ .compatible = \"renesas,rcar-gen3-sdhi\", .data = &of_rcar_gen3_compatible, },\n\t{ .compatible = \"renesas,rcar-gen4-sdhi\", .data = &of_rcar_gen3_compatible, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, renesas_sdhi_internal_dmac_of_match);\n\nstatic void\nrenesas_sdhi_internal_dmac_enable_dma(struct tmio_mmc_host *host, bool enable)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tu32 dma_irqs = INFO1_DTRANEND0 |\n\t\t\t(sdhi_has_quirk(priv, old_info1_layout) ?\n\t\t\tINFO1_DTRANEND1_OLD : INFO1_DTRANEND1);\n\n\tif (!host->chan_tx || !host->chan_rx)\n\t\treturn;\n\n\twritel(enable ? ~dma_irqs : INFO1_MASK_CLEAR, host->ctl + DM_CM_INFO1_MASK);\n\n\tif (priv->dma_priv.enable)\n\t\tpriv->dma_priv.enable(host, enable);\n}\n\nstatic void\nrenesas_sdhi_internal_dmac_abort_dma(struct tmio_mmc_host *host)\n{\n\tu64 val = RST_DTRANRST1 | RST_DTRANRST0;\n\n\trenesas_sdhi_internal_dmac_enable_dma(host, false);\n\n\twritel(RST_RESERVED_BITS & ~val, host->ctl + DM_CM_RST);\n\twritel(RST_RESERVED_BITS | val, host->ctl + DM_CM_RST);\n\n\tclear_bit(SDHI_INTERNAL_DMAC_RX_IN_USE, &global_flags);\n\n\trenesas_sdhi_internal_dmac_enable_dma(host, true);\n}\n\nstatic bool renesas_sdhi_internal_dmac_dma_irq(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct renesas_sdhi_dma *dma_priv = &priv->dma_priv;\n\n\tu32 dma_irqs = INFO1_DTRANEND0 |\n\t\t\t(sdhi_has_quirk(priv, old_info1_layout) ?\n\t\t\tINFO1_DTRANEND1_OLD : INFO1_DTRANEND1);\n\tu32 status = readl(host->ctl + DM_CM_INFO1);\n\n\tif (status & dma_irqs) {\n\t\twritel(status ^ dma_irqs, host->ctl + DM_CM_INFO1);\n\t\tset_bit(SDHI_DMA_END_FLAG_DMA, &dma_priv->end_flags);\n\t\tif (test_bit(SDHI_DMA_END_FLAG_ACCESS, &dma_priv->end_flags))\n\t\t\ttasklet_schedule(&dma_priv->dma_complete);\n\t}\n\n\treturn status & dma_irqs;\n}\n\nstatic void\nrenesas_sdhi_internal_dmac_dataend_dma(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct renesas_sdhi_dma *dma_priv = &priv->dma_priv;\n\n\tset_bit(SDHI_DMA_END_FLAG_ACCESS, &dma_priv->end_flags);\n\tif (test_bit(SDHI_DMA_END_FLAG_DMA, &dma_priv->end_flags) ||\n\t    host->data->error)\n\t\ttasklet_schedule(&dma_priv->dma_complete);\n}\n\n \nstatic void\nrenesas_sdhi_internal_dmac_unmap(struct tmio_mmc_host *host,\n\t\t\t\t struct mmc_data *data,\n\t\t\t\t enum renesas_sdhi_dma_cookie cookie)\n{\n\tbool unmap = cookie == COOKIE_UNMAPPED ? (data->host_cookie != cookie) :\n\t\t\t\t\t\t (data->host_cookie == cookie);\n\n\tif (unmap) {\n\t\tdma_unmap_sg(&host->pdev->dev, data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t\tdata->host_cookie = COOKIE_UNMAPPED;\n\t}\n}\n\nstatic bool\nrenesas_sdhi_internal_dmac_map(struct tmio_mmc_host *host,\n\t\t\t       struct mmc_data *data,\n\t\t\t       enum renesas_sdhi_dma_cookie cookie)\n{\n\tif (data->host_cookie == COOKIE_PRE_MAPPED)\n\t\treturn true;\n\n\tif (!dma_map_sg(&host->pdev->dev, data->sg, data->sg_len,\n\t\t\t    mmc_get_dma_dir(data)))\n\t\treturn false;\n\n\tdata->host_cookie = cookie;\n\n\t \n\tif (!IS_ALIGNED(sg_dma_address(data->sg), 128)) {\n\t\trenesas_sdhi_internal_dmac_unmap(host, data, cookie);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void\nrenesas_sdhi_internal_dmac_start_dma(struct tmio_mmc_host *host,\n\t\t\t\t     struct mmc_data *data)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct scatterlist *sg = host->sg_ptr;\n\tu32 dtran_mode = DTRAN_MODE_BUS_WIDTH;\n\n\tif (!sdhi_has_quirk(priv, fixed_addr_mode))\n\t\tdtran_mode |= DTRAN_MODE_ADDR_MODE;\n\n\tif (!renesas_sdhi_internal_dmac_map(host, data, COOKIE_MAPPED))\n\t\tgoto force_pio;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tdtran_mode |= DTRAN_MODE_CH_NUM_CH1;\n\t\tif (sdhi_has_quirk(priv, dma_one_rx_only) &&\n\t\t    test_and_set_bit(SDHI_INTERNAL_DMAC_RX_IN_USE, &global_flags))\n\t\t\tgoto force_pio_with_unmap;\n\t} else {\n\t\tdtran_mode |= DTRAN_MODE_CH_NUM_CH0;\n\t}\n\n\tpriv->dma_priv.end_flags = 0;\n\trenesas_sdhi_internal_dmac_enable_dma(host, true);\n\n\t \n\twritel(dtran_mode, host->ctl + DM_CM_DTRAN_MODE);\n\twritel(sg_dma_address(sg), host->ctl + DM_DTRAN_ADDR);\n\n\thost->dma_on = true;\n\n\treturn;\n\nforce_pio_with_unmap:\n\trenesas_sdhi_internal_dmac_unmap(host, data, COOKIE_UNMAPPED);\n\nforce_pio:\n\trenesas_sdhi_internal_dmac_enable_dma(host, false);\n}\n\nstatic void renesas_sdhi_internal_dmac_issue_tasklet_fn(unsigned long arg)\n{\n\tstruct tmio_mmc_host *host = (struct tmio_mmc_host *)arg;\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\ttmio_mmc_enable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\n\tif (!host->cmd->error) {\n\t\t \n\t\twritel(DTRAN_CTRL_DM_START, host->ctl + DM_CM_DTRAN_CTRL);\n\t} else {\n\t\t \n\t\tset_bit(SDHI_DMA_END_FLAG_DMA, &priv->dma_priv.end_flags);\n\t\tif (test_bit(SDHI_DMA_END_FLAG_ACCESS, &priv->dma_priv.end_flags))\n\t\t\ttasklet_schedule(&priv->dma_priv.dma_complete);\n\t}\n}\n\nstatic bool renesas_sdhi_internal_dmac_complete(struct tmio_mmc_host *host)\n{\n\tenum dma_data_direction dir;\n\n\tif (!host->dma_on)\n\t\treturn false;\n\n\tif (!host->data)\n\t\treturn false;\n\n\tif (host->data->flags & MMC_DATA_READ)\n\t\tdir = DMA_FROM_DEVICE;\n\telse\n\t\tdir = DMA_TO_DEVICE;\n\n\trenesas_sdhi_internal_dmac_enable_dma(host, false);\n\trenesas_sdhi_internal_dmac_unmap(host, host->data, COOKIE_MAPPED);\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tclear_bit(SDHI_INTERNAL_DMAC_RX_IN_USE, &global_flags);\n\n\thost->dma_on = false;\n\n\treturn true;\n}\n\nstatic void renesas_sdhi_internal_dmac_complete_tasklet_fn(unsigned long arg)\n{\n\tstruct tmio_mmc_host *host = (struct tmio_mmc_host *)arg;\n\n\tspin_lock_irq(&host->lock);\n\tif (!renesas_sdhi_internal_dmac_complete(host))\n\t\tgoto out;\n\n\ttmio_mmc_do_data_irq(host);\nout:\n\tspin_unlock_irq(&host->lock);\n}\n\nstatic void renesas_sdhi_internal_dmac_end_dma(struct tmio_mmc_host *host)\n{\n\tif (host->data)\n\t\trenesas_sdhi_internal_dmac_complete(host);\n}\n\nstatic void renesas_sdhi_internal_dmac_post_req(struct mmc_host *mmc,\n\t\t\t\t\t\tstruct mmc_request *mrq,\n\t\t\t\t\t\tint err)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\trenesas_sdhi_internal_dmac_unmap(host, data, COOKIE_UNMAPPED);\n}\n\nstatic void renesas_sdhi_internal_dmac_pre_req(struct mmc_host *mmc,\n\t\t\t\t\t       struct mmc_request *mrq)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tdata->host_cookie = COOKIE_UNMAPPED;\n\trenesas_sdhi_internal_dmac_map(host, data, COOKIE_PRE_MAPPED);\n}\n\nstatic void\nrenesas_sdhi_internal_dmac_request_dma(struct tmio_mmc_host *host,\n\t\t\t\t       struct tmio_mmc_data *pdata)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\t \n\twritel(INFO1_MASK_CLEAR, host->ctl + DM_CM_INFO1_MASK);\n\twritel(INFO2_MASK_CLEAR, host->ctl + DM_CM_INFO2_MASK);\n\twritel(0, host->ctl + DM_CM_INFO1);\n\twritel(0, host->ctl + DM_CM_INFO2);\n\n\t \n\thost->chan_rx = host->chan_tx = (void *)0xdeadbeaf;\n\n\ttasklet_init(&priv->dma_priv.dma_complete,\n\t\t     renesas_sdhi_internal_dmac_complete_tasklet_fn,\n\t\t     (unsigned long)host);\n\ttasklet_init(&host->dma_issue,\n\t\t     renesas_sdhi_internal_dmac_issue_tasklet_fn,\n\t\t     (unsigned long)host);\n\n\t \n\thost->ops.pre_req = renesas_sdhi_internal_dmac_pre_req;\n\thost->ops.post_req = renesas_sdhi_internal_dmac_post_req;\n}\n\nstatic void\nrenesas_sdhi_internal_dmac_release_dma(struct tmio_mmc_host *host)\n{\n\t \n\thost->chan_rx = host->chan_tx = NULL;\n}\n\nstatic const struct tmio_mmc_dma_ops renesas_sdhi_internal_dmac_dma_ops = {\n\t.start = renesas_sdhi_internal_dmac_start_dma,\n\t.enable = renesas_sdhi_internal_dmac_enable_dma,\n\t.request = renesas_sdhi_internal_dmac_request_dma,\n\t.release = renesas_sdhi_internal_dmac_release_dma,\n\t.abort = renesas_sdhi_internal_dmac_abort_dma,\n\t.dataend = renesas_sdhi_internal_dmac_dataend_dma,\n\t.end = renesas_sdhi_internal_dmac_end_dma,\n\t.dma_irq = renesas_sdhi_internal_dmac_dma_irq,\n};\n\nstatic int renesas_sdhi_internal_dmac_probe(struct platform_device *pdev)\n{\n\tconst struct soc_device_attribute *attr;\n\tconst struct renesas_sdhi_of_data_with_quirks *of_data_quirks;\n\tconst struct renesas_sdhi_quirks *quirks;\n\tstruct device *dev = &pdev->dev;\n\n\tof_data_quirks = of_device_get_match_data(&pdev->dev);\n\tquirks = of_data_quirks->quirks;\n\n\tattr = soc_device_match(sdhi_quirks_match);\n\tif (attr)\n\t\tquirks = attr->data;\n\n\t \n\tdma_set_max_seg_size(dev, 0xffffffff);\n\n\treturn renesas_sdhi_probe(pdev, &renesas_sdhi_internal_dmac_dma_ops,\n\t\t\t\t  of_data_quirks->of_data, quirks);\n}\n\nstatic const struct dev_pm_ops renesas_sdhi_internal_dmac_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(tmio_mmc_host_runtime_suspend,\n\t\t\t   tmio_mmc_host_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver renesas_internal_dmac_sdhi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"renesas_sdhi_internal_dmac\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &renesas_sdhi_internal_dmac_dev_pm_ops,\n\t\t.of_match_table = renesas_sdhi_internal_dmac_of_match,\n\t},\n\t.probe\t\t= renesas_sdhi_internal_dmac_probe,\n\t.remove_new\t= renesas_sdhi_remove,\n};\n\nmodule_platform_driver(renesas_internal_dmac_sdhi_driver);\n\nMODULE_DESCRIPTION(\"Renesas SDHI driver for internal DMAC\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}