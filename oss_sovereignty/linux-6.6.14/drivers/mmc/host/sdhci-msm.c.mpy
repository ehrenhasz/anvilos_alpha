{
  "module_name": "sdhci-msm.c",
  "hash_id": "07e0c13d1eaf3aaa77007a77497e86e2a299730027c17606c680579cdf5c681c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-msm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/mmc/mmc.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_opp.h>\n#include <linux/slab.h>\n#include <linux/iopoll.h>\n#include <linux/regulator/consumer.h>\n#include <linux/interconnect.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/reset.h>\n\n#include <soc/qcom/ice.h>\n\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n#include \"cqhci.h\"\n\n#define CORE_MCI_VERSION\t\t0x50\n#define CORE_VERSION_MAJOR_SHIFT\t28\n#define CORE_VERSION_MAJOR_MASK\t\t(0xf << CORE_VERSION_MAJOR_SHIFT)\n#define CORE_VERSION_MINOR_MASK\t\t0xff\n\n#define CORE_MCI_GENERICS\t\t0x70\n#define SWITCHABLE_SIGNALING_VOLTAGE\tBIT(29)\n\n#define HC_MODE_EN\t\t0x1\n#define CORE_POWER\t\t0x0\n#define CORE_SW_RST\t\tBIT(7)\n#define FF_CLK_SW_RST_DIS\tBIT(13)\n\n#define CORE_PWRCTL_BUS_OFF\tBIT(0)\n#define CORE_PWRCTL_BUS_ON\tBIT(1)\n#define CORE_PWRCTL_IO_LOW\tBIT(2)\n#define CORE_PWRCTL_IO_HIGH\tBIT(3)\n#define CORE_PWRCTL_BUS_SUCCESS BIT(0)\n#define CORE_PWRCTL_BUS_FAIL    BIT(1)\n#define CORE_PWRCTL_IO_SUCCESS\tBIT(2)\n#define CORE_PWRCTL_IO_FAIL     BIT(3)\n#define REQ_BUS_OFF\t\tBIT(0)\n#define REQ_BUS_ON\t\tBIT(1)\n#define REQ_IO_LOW\t\tBIT(2)\n#define REQ_IO_HIGH\t\tBIT(3)\n#define INT_MASK\t\t0xf\n#define MAX_PHASES\t\t16\n#define CORE_DLL_LOCK\t\tBIT(7)\n#define CORE_DDR_DLL_LOCK\tBIT(11)\n#define CORE_DLL_EN\t\tBIT(16)\n#define CORE_CDR_EN\t\tBIT(17)\n#define CORE_CK_OUT_EN\t\tBIT(18)\n#define CORE_CDR_EXT_EN\t\tBIT(19)\n#define CORE_DLL_PDN\t\tBIT(29)\n#define CORE_DLL_RST\t\tBIT(30)\n#define CORE_CMD_DAT_TRACK_SEL\tBIT(0)\n\n#define CORE_DDR_CAL_EN\t\tBIT(0)\n#define CORE_FLL_CYCLE_CNT\tBIT(18)\n#define CORE_DLL_CLOCK_DISABLE\tBIT(21)\n\n#define DLL_USR_CTL_POR_VAL\t0x10800\n#define ENABLE_DLL_LOCK_STATUS\tBIT(26)\n#define FINE_TUNE_MODE_EN\tBIT(27)\n#define BIAS_OK_SIGNAL\t\tBIT(29)\n\n#define DLL_CONFIG_3_LOW_FREQ_VAL\t0x08\n#define DLL_CONFIG_3_HIGH_FREQ_VAL\t0x10\n\n#define CORE_VENDOR_SPEC_POR_VAL 0xa9c\n#define CORE_CLK_PWRSAVE\tBIT(1)\n#define CORE_HC_MCLK_SEL_DFLT\t(2 << 8)\n#define CORE_HC_MCLK_SEL_HS400\t(3 << 8)\n#define CORE_HC_MCLK_SEL_MASK\t(3 << 8)\n#define CORE_IO_PAD_PWR_SWITCH_EN\tBIT(15)\n#define CORE_IO_PAD_PWR_SWITCH\tBIT(16)\n#define CORE_HC_SELECT_IN_EN\tBIT(18)\n#define CORE_HC_SELECT_IN_HS400\t(6 << 19)\n#define CORE_HC_SELECT_IN_MASK\t(7 << 19)\n\n#define CORE_3_0V_SUPPORT\tBIT(25)\n#define CORE_1_8V_SUPPORT\tBIT(26)\n#define CORE_VOLT_SUPPORT\t(CORE_3_0V_SUPPORT | CORE_1_8V_SUPPORT)\n\n#define CORE_CSR_CDC_CTLR_CFG0\t\t0x130\n#define CORE_SW_TRIG_FULL_CALIB\t\tBIT(16)\n#define CORE_HW_AUTOCAL_ENA\t\tBIT(17)\n\n#define CORE_CSR_CDC_CTLR_CFG1\t\t0x134\n#define CORE_CSR_CDC_CAL_TIMER_CFG0\t0x138\n#define CORE_TIMER_ENA\t\t\tBIT(16)\n\n#define CORE_CSR_CDC_CAL_TIMER_CFG1\t0x13C\n#define CORE_CSR_CDC_REFCOUNT_CFG\t0x140\n#define CORE_CSR_CDC_COARSE_CAL_CFG\t0x144\n#define CORE_CDC_OFFSET_CFG\t\t0x14C\n#define CORE_CSR_CDC_DELAY_CFG\t\t0x150\n#define CORE_CDC_SLAVE_DDA_CFG\t\t0x160\n#define CORE_CSR_CDC_STATUS0\t\t0x164\n#define CORE_CALIBRATION_DONE\t\tBIT(0)\n\n#define CORE_CDC_ERROR_CODE_MASK\t0x7000000\n\n#define CORE_CSR_CDC_GEN_CFG\t\t0x178\n#define CORE_CDC_SWITCH_BYPASS_OFF\tBIT(0)\n#define CORE_CDC_SWITCH_RC_EN\t\tBIT(1)\n\n#define CORE_CDC_T4_DLY_SEL\t\tBIT(0)\n#define CORE_CMDIN_RCLK_EN\t\tBIT(1)\n#define CORE_START_CDC_TRAFFIC\t\tBIT(6)\n\n#define CORE_PWRSAVE_DLL\tBIT(3)\n\n#define DDR_CONFIG_POR_VAL\t0x80040873\n\n\n#define INVALID_TUNING_PHASE\t-1\n#define SDHCI_MSM_MIN_CLOCK\t400000\n#define CORE_FREQ_100MHZ\t(100 * 1000 * 1000)\n\n#define CDR_SELEXT_SHIFT\t20\n#define CDR_SELEXT_MASK\t\t(0xf << CDR_SELEXT_SHIFT)\n#define CMUX_SHIFT_PHASE_SHIFT\t24\n#define CMUX_SHIFT_PHASE_MASK\t(7 << CMUX_SHIFT_PHASE_SHIFT)\n\n#define MSM_MMC_AUTOSUSPEND_DELAY_MS\t50\n\n \n#define MSM_PWR_IRQ_TIMEOUT_MS 5000\n\n \n#define MMC_VQMMC_MAX_LOAD_UA\t325000\n\n#define msm_host_readl(msm_host, host, offset) \\\n\tmsm_host->var_ops->msm_readl_relaxed(host, offset)\n\n#define msm_host_writel(msm_host, val, host, offset) \\\n\tmsm_host->var_ops->msm_writel_relaxed(val, host, offset)\n\n \n#define CQHCI_VENDOR_CFG1\t0xA00\n#define CQHCI_VENDOR_DIS_RST_ON_CQ_EN\t(0x3 << 13)\n\nstruct sdhci_msm_offset {\n\tu32 core_hc_mode;\n\tu32 core_mci_data_cnt;\n\tu32 core_mci_status;\n\tu32 core_mci_fifo_cnt;\n\tu32 core_mci_version;\n\tu32 core_generics;\n\tu32 core_testbus_config;\n\tu32 core_testbus_sel2_bit;\n\tu32 core_testbus_ena;\n\tu32 core_testbus_sel2;\n\tu32 core_pwrctl_status;\n\tu32 core_pwrctl_mask;\n\tu32 core_pwrctl_clear;\n\tu32 core_pwrctl_ctl;\n\tu32 core_sdcc_debug_reg;\n\tu32 core_dll_config;\n\tu32 core_dll_status;\n\tu32 core_vendor_spec;\n\tu32 core_vendor_spec_adma_err_addr0;\n\tu32 core_vendor_spec_adma_err_addr1;\n\tu32 core_vendor_spec_func2;\n\tu32 core_vendor_spec_capabilities0;\n\tu32 core_ddr_200_cfg;\n\tu32 core_vendor_spec3;\n\tu32 core_dll_config_2;\n\tu32 core_dll_config_3;\n\tu32 core_ddr_config_old;  \n\tu32 core_ddr_config;\n\tu32 core_dll_usr_ctl;  \n};\n\nstatic const struct sdhci_msm_offset sdhci_msm_v5_offset = {\n\t.core_mci_data_cnt = 0x35c,\n\t.core_mci_status = 0x324,\n\t.core_mci_fifo_cnt = 0x308,\n\t.core_mci_version = 0x318,\n\t.core_generics = 0x320,\n\t.core_testbus_config = 0x32c,\n\t.core_testbus_sel2_bit = 3,\n\t.core_testbus_ena = (1 << 31),\n\t.core_testbus_sel2 = (1 << 3),\n\t.core_pwrctl_status = 0x240,\n\t.core_pwrctl_mask = 0x244,\n\t.core_pwrctl_clear = 0x248,\n\t.core_pwrctl_ctl = 0x24c,\n\t.core_sdcc_debug_reg = 0x358,\n\t.core_dll_config = 0x200,\n\t.core_dll_status = 0x208,\n\t.core_vendor_spec = 0x20c,\n\t.core_vendor_spec_adma_err_addr0 = 0x214,\n\t.core_vendor_spec_adma_err_addr1 = 0x218,\n\t.core_vendor_spec_func2 = 0x210,\n\t.core_vendor_spec_capabilities0 = 0x21c,\n\t.core_ddr_200_cfg = 0x224,\n\t.core_vendor_spec3 = 0x250,\n\t.core_dll_config_2 = 0x254,\n\t.core_dll_config_3 = 0x258,\n\t.core_ddr_config = 0x25c,\n\t.core_dll_usr_ctl = 0x388,\n};\n\nstatic const struct sdhci_msm_offset sdhci_msm_mci_offset = {\n\t.core_hc_mode = 0x78,\n\t.core_mci_data_cnt = 0x30,\n\t.core_mci_status = 0x34,\n\t.core_mci_fifo_cnt = 0x44,\n\t.core_mci_version = 0x050,\n\t.core_generics = 0x70,\n\t.core_testbus_config = 0x0cc,\n\t.core_testbus_sel2_bit = 4,\n\t.core_testbus_ena = (1 << 3),\n\t.core_testbus_sel2 = (1 << 4),\n\t.core_pwrctl_status = 0xdc,\n\t.core_pwrctl_mask = 0xe0,\n\t.core_pwrctl_clear = 0xe4,\n\t.core_pwrctl_ctl = 0xe8,\n\t.core_sdcc_debug_reg = 0x124,\n\t.core_dll_config = 0x100,\n\t.core_dll_status = 0x108,\n\t.core_vendor_spec = 0x10c,\n\t.core_vendor_spec_adma_err_addr0 = 0x114,\n\t.core_vendor_spec_adma_err_addr1 = 0x118,\n\t.core_vendor_spec_func2 = 0x110,\n\t.core_vendor_spec_capabilities0 = 0x11c,\n\t.core_ddr_200_cfg = 0x184,\n\t.core_vendor_spec3 = 0x1b0,\n\t.core_dll_config_2 = 0x1b4,\n\t.core_ddr_config_old = 0x1b8,\n\t.core_ddr_config = 0x1bc,\n};\n\nstruct sdhci_msm_variant_ops {\n\tu32 (*msm_readl_relaxed)(struct sdhci_host *host, u32 offset);\n\tvoid (*msm_writel_relaxed)(u32 val, struct sdhci_host *host,\n\t\t\tu32 offset);\n};\n\n \nstruct sdhci_msm_variant_info {\n\tbool mci_removed;\n\tbool restore_dll_config;\n\tconst struct sdhci_msm_variant_ops *var_ops;\n\tconst struct sdhci_msm_offset *offset;\n};\n\nstruct sdhci_msm_host {\n\tstruct platform_device *pdev;\n\tvoid __iomem *core_mem;\t \n\tint pwr_irq;\t\t \n\tstruct clk *bus_clk;\t \n\tstruct clk *xo_clk;\t \n\t \n\tstruct clk_bulk_data bulk_clks[4];\n#ifdef CONFIG_MMC_CRYPTO\n\tstruct qcom_ice *ice;\n#endif\n\tunsigned long clk_rate;\n\tstruct mmc_host *mmc;\n\tbool use_14lpp_dll_reset;\n\tbool tuning_done;\n\tbool calibration_done;\n\tu8 saved_tuning_phase;\n\tbool use_cdclp533;\n\tu32 curr_pwr_state;\n\tu32 curr_io_level;\n\twait_queue_head_t pwr_irq_wait;\n\tbool pwr_irq_flag;\n\tu32 caps_0;\n\tbool mci_removed;\n\tbool restore_dll_config;\n\tconst struct sdhci_msm_variant_ops *var_ops;\n\tconst struct sdhci_msm_offset *offset;\n\tbool use_cdr;\n\tu32 transfer_mode;\n\tbool updated_ddr_cfg;\n\tbool uses_tassadar_dll;\n\tu32 dll_config;\n\tu32 ddr_config;\n\tbool vqmmc_enabled;\n};\n\nstatic const struct sdhci_msm_offset *sdhci_priv_msm_offset(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\treturn msm_host->offset;\n}\n\n \nstatic u32 sdhci_msm_mci_variant_readl_relaxed(struct sdhci_host *host,\n\t\tu32 offset)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\treturn readl_relaxed(msm_host->core_mem + offset);\n}\n\nstatic u32 sdhci_msm_v5_variant_readl_relaxed(struct sdhci_host *host,\n\t\tu32 offset)\n{\n\treturn readl_relaxed(host->ioaddr + offset);\n}\n\nstatic void sdhci_msm_mci_variant_writel_relaxed(u32 val,\n\t\tstruct sdhci_host *host, u32 offset)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\twritel_relaxed(val, msm_host->core_mem + offset);\n}\n\nstatic void sdhci_msm_v5_variant_writel_relaxed(u32 val,\n\t\tstruct sdhci_host *host, u32 offset)\n{\n\twritel_relaxed(val, host->ioaddr + offset);\n}\n\nstatic unsigned int msm_get_clock_mult_for_bus_mode(struct sdhci_host *host)\n{\n\tstruct mmc_ios ios = host->mmc->ios;\n\t \n\tif (ios.timing == MMC_TIMING_UHS_DDR50 ||\n\t    ios.timing == MMC_TIMING_MMC_DDR52 ||\n\t    ios.timing == MMC_TIMING_MMC_HS400 ||\n\t    host->flags & SDHCI_HS400_TUNING)\n\t\treturn 2;\n\treturn 1;\n}\n\nstatic void msm_set_clock_rate_for_bus_mode(struct sdhci_host *host,\n\t\t\t\t\t    unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct mmc_ios curr_ios = host->mmc->ios;\n\tstruct clk *core_clk = msm_host->bulk_clks[0].clk;\n\tunsigned long achieved_rate;\n\tunsigned int desired_rate;\n\tunsigned int mult;\n\tint rc;\n\n\tmult = msm_get_clock_mult_for_bus_mode(host);\n\tdesired_rate = clock * mult;\n\trc = dev_pm_opp_set_rate(mmc_dev(host->mmc), desired_rate);\n\tif (rc) {\n\t\tpr_err(\"%s: Failed to set clock at rate %u at timing %d\\n\",\n\t\t       mmc_hostname(host->mmc), desired_rate, curr_ios.timing);\n\t\treturn;\n\t}\n\n\t \n\tachieved_rate = clk_get_rate(core_clk);\n\tif (achieved_rate > desired_rate)\n\t\tpr_warn(\"%s: Card appears overclocked; req %u Hz, actual %lu Hz\\n\",\n\t\t\tmmc_hostname(host->mmc), desired_rate, achieved_rate);\n\thost->mmc->actual_clock = achieved_rate / mult;\n\n\t \n\tmsm_host->clk_rate = desired_rate;\n\n\tpr_debug(\"%s: Setting clock at rate %lu at timing %d\\n\",\n\t\t mmc_hostname(host->mmc), achieved_rate, curr_ios.timing);\n}\n\n \nstatic inline int msm_dll_poll_ck_out_en(struct sdhci_host *host, u8 poll)\n{\n\tu32 wait_cnt = 50;\n\tu8 ck_out_en;\n\tstruct mmc_host *mmc = host->mmc;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tsdhci_priv_msm_offset(host);\n\n\t \n\tck_out_en = !!(readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config) & CORE_CK_OUT_EN);\n\n\twhile (ck_out_en != poll) {\n\t\tif (--wait_cnt == 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"%s: CK_OUT_EN bit is not %d\\n\",\n\t\t\t       mmc_hostname(mmc), poll);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\n\t\tck_out_en = !!(readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config) & CORE_CK_OUT_EN);\n\t}\n\n\treturn 0;\n}\n\nstatic int msm_config_cm_dll_phase(struct sdhci_host *host, u8 phase)\n{\n\tint rc;\n\tstatic const u8 grey_coded_phase_table[] = {\n\t\t0x0, 0x1, 0x3, 0x2, 0x6, 0x7, 0x5, 0x4,\n\t\t0xc, 0xd, 0xf, 0xe, 0xa, 0xb, 0x9, 0x8\n\t};\n\tunsigned long flags;\n\tu32 config;\n\tstruct mmc_host *mmc = host->mmc;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tsdhci_priv_msm_offset(host);\n\n\tif (phase > 0xf)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig &= ~(CORE_CDR_EN | CORE_CK_OUT_EN);\n\tconfig |= (CORE_CDR_EXT_EN | CORE_DLL_EN);\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n\n\t \n\trc = msm_dll_poll_ck_out_en(host, 0);\n\tif (rc)\n\t\tgoto err_out;\n\n\t \n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig &= ~CDR_SELEXT_MASK;\n\tconfig |= grey_coded_phase_table[phase] << CDR_SELEXT_SHIFT;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig |= CORE_CK_OUT_EN;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n\n\t \n\trc = msm_dll_poll_ck_out_en(host, 1);\n\tif (rc)\n\t\tgoto err_out;\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig |= CORE_CDR_EN;\n\tconfig &= ~CORE_CDR_EXT_EN;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n\tgoto out;\n\nerr_out:\n\tdev_err(mmc_dev(mmc), \"%s: Failed to set DLL phase: %d\\n\",\n\t       mmc_hostname(mmc), phase);\nout:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\treturn rc;\n}\n\n \n\nstatic int msm_find_most_appropriate_phase(struct sdhci_host *host,\n\t\t\t\t\t   u8 *phase_table, u8 total_phases)\n{\n\tint ret;\n\tu8 ranges[MAX_PHASES][MAX_PHASES] = { {0}, {0} };\n\tu8 phases_per_row[MAX_PHASES] = { 0 };\n\tint row_index = 0, col_index = 0, selected_row_index = 0, curr_max = 0;\n\tint i, cnt, phase_0_raw_index = 0, phase_15_raw_index = 0;\n\tbool phase_0_found = false, phase_15_found = false;\n\tstruct mmc_host *mmc = host->mmc;\n\n\tif (!total_phases || (total_phases > MAX_PHASES)) {\n\t\tdev_err(mmc_dev(mmc), \"%s: Invalid argument: total_phases=%d\\n\",\n\t\t       mmc_hostname(mmc), total_phases);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (cnt = 0; cnt < total_phases; cnt++) {\n\t\tranges[row_index][col_index] = phase_table[cnt];\n\t\tphases_per_row[row_index] += 1;\n\t\tcol_index++;\n\n\t\tif ((cnt + 1) == total_phases) {\n\t\t\tcontinue;\n\t\t \n\t\t} else if ((phase_table[cnt] + 1) != phase_table[cnt + 1]) {\n\t\t\trow_index++;\n\t\t\tcol_index = 0;\n\t\t}\n\t}\n\n\tif (row_index >= MAX_PHASES)\n\t\treturn -EINVAL;\n\n\t \n\tif (!ranges[0][0]) {\n\t\tphase_0_found = true;\n\t\tphase_0_raw_index = 0;\n\t\t \n\t\tfor (cnt = 1; cnt <= row_index; cnt++) {\n\t\t\tif (phases_per_row[cnt]) {\n\t\t\t\tfor (i = 0; i < phases_per_row[cnt]; i++) {\n\t\t\t\t\tif (ranges[cnt][i] == 15) {\n\t\t\t\t\t\tphase_15_found = true;\n\t\t\t\t\t\tphase_15_raw_index = cnt;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (phase_0_found && phase_15_found) {\n\t\t \n\t\tu8 phases_0 = phases_per_row[phase_0_raw_index];\n\t\t \n\t\tu8 phases_15 = phases_per_row[phase_15_raw_index];\n\n\t\tif (phases_0 + phases_15 >= MAX_PHASES)\n\t\t\t \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\ti = phases_15;\n\t\tfor (cnt = 0; cnt < phases_0; cnt++) {\n\t\t\tranges[phase_15_raw_index][i] =\n\t\t\t    ranges[phase_0_raw_index][cnt];\n\t\t\tif (++i >= MAX_PHASES)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tphases_per_row[phase_0_raw_index] = 0;\n\t\tphases_per_row[phase_15_raw_index] = phases_15 + phases_0;\n\t}\n\n\tfor (cnt = 0; cnt <= row_index; cnt++) {\n\t\tif (phases_per_row[cnt] > curr_max) {\n\t\t\tcurr_max = phases_per_row[cnt];\n\t\t\tselected_row_index = cnt;\n\t\t}\n\t}\n\n\ti = (curr_max * 3) / 4;\n\tif (i)\n\t\ti--;\n\n\tret = ranges[selected_row_index][i];\n\n\tif (ret >= MAX_PHASES) {\n\t\tret = -EINVAL;\n\t\tdev_err(mmc_dev(mmc), \"%s: Invalid phase selected=%d\\n\",\n\t\t       mmc_hostname(mmc), ret);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void msm_cm_dll_set_freq(struct sdhci_host *host)\n{\n\tu32 mclk_freq = 0, config;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tsdhci_priv_msm_offset(host);\n\n\t \n\tif (host->clock <= 112000000)\n\t\tmclk_freq = 0;\n\telse if (host->clock <= 125000000)\n\t\tmclk_freq = 1;\n\telse if (host->clock <= 137000000)\n\t\tmclk_freq = 2;\n\telse if (host->clock <= 150000000)\n\t\tmclk_freq = 3;\n\telse if (host->clock <= 162000000)\n\t\tmclk_freq = 4;\n\telse if (host->clock <= 175000000)\n\t\tmclk_freq = 5;\n\telse if (host->clock <= 187000000)\n\t\tmclk_freq = 6;\n\telse if (host->clock <= 200000000)\n\t\tmclk_freq = 7;\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig &= ~CMUX_SHIFT_PHASE_MASK;\n\tconfig |= mclk_freq << CMUX_SHIFT_PHASE_SHIFT;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n}\n\n \nstatic int msm_init_cm_dll(struct sdhci_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tint wait_cnt = 50;\n\tunsigned long flags, xo_clk = 0;\n\tu32 config;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tif (msm_host->use_14lpp_dll_reset && !IS_ERR_OR_NULL(msm_host->xo_clk))\n\t\txo_clk = clk_get_rate(msm_host->xo_clk);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\t \n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_vendor_spec);\n\tconfig &= ~CORE_CLK_PWRSAVE;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_vendor_spec);\n\n\tif (msm_host->dll_config)\n\t\twritel_relaxed(msm_host->dll_config,\n\t\t\t\thost->ioaddr + msm_offset->core_dll_config);\n\n\tif (msm_host->use_14lpp_dll_reset) {\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\t\tconfig &= ~CORE_CK_OUT_EN;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t\tconfig |= CORE_DLL_CLOCK_DISABLE;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig |= CORE_DLL_RST;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig |= CORE_DLL_PDN;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\tif (!msm_host->dll_config)\n\t\tmsm_cm_dll_set_freq(host);\n\n\tif (msm_host->use_14lpp_dll_reset &&\n\t    !IS_ERR_OR_NULL(msm_host->xo_clk)) {\n\t\tu32 mclk_freq = 0;\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t\tconfig &= CORE_FLL_CYCLE_CNT;\n\t\tif (config)\n\t\t\tmclk_freq = DIV_ROUND_CLOSEST_ULL((host->clock * 8),\n\t\t\t\t\txo_clk);\n\t\telse\n\t\t\tmclk_freq = DIV_ROUND_CLOSEST_ULL((host->clock * 4),\n\t\t\t\t\txo_clk);\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t\tconfig &= ~(0xFF << 10);\n\t\tconfig |= mclk_freq << 10;\n\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t\t \n\t\tudelay(5);\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig &= ~CORE_DLL_RST;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig &= ~CORE_DLL_PDN;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\tif (msm_host->use_14lpp_dll_reset) {\n\t\tif (!msm_host->dll_config)\n\t\t\tmsm_cm_dll_set_freq(host);\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t\tconfig &= ~CORE_DLL_CLOCK_DISABLE;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_2);\n\t}\n\n\t \n\tif (msm_host->uses_tassadar_dll) {\n\t\tconfig = DLL_USR_CTL_POR_VAL | FINE_TUNE_MODE_EN |\n\t\t\tENABLE_DLL_LOCK_STATUS | BIAS_OK_SIGNAL;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_usr_ctl);\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config_3);\n\t\tconfig &= ~0xFF;\n\t\tif (msm_host->clk_rate < 150000000)\n\t\t\tconfig |= DLL_CONFIG_3_LOW_FREQ_VAL;\n\t\telse\n\t\t\tconfig |= DLL_CONFIG_3_HIGH_FREQ_VAL;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config_3);\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig |= CORE_DLL_EN;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\tconfig = readl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\tconfig |= CORE_CK_OUT_EN;\n\twritel_relaxed(config, host->ioaddr +\n\t\t\tmsm_offset->core_dll_config);\n\n\t \n\twhile (!(readl_relaxed(host->ioaddr + msm_offset->core_dll_status) &\n\t\t CORE_DLL_LOCK)) {\n\t\t \n\t\tif (--wait_cnt == 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"%s: DLL failed to LOCK\\n\",\n\t\t\t       mmc_hostname(mmc));\n\t\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(1);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\treturn 0;\n}\n\nstatic void msm_hc_select_default(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 config;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tif (!msm_host->use_cdclp533) {\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec3);\n\t\tconfig &= ~CORE_PWRSAVE_DLL;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec3);\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_vendor_spec);\n\tconfig &= ~CORE_HC_MCLK_SEL_MASK;\n\tconfig |= CORE_HC_MCLK_SEL_DFLT;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_vendor_spec);\n\n\t \n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_vendor_spec);\n\tconfig &= ~CORE_HC_SELECT_IN_EN;\n\tconfig &= ~CORE_HC_SELECT_IN_MASK;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_vendor_spec);\n\n\t \n\twmb();\n}\n\nstatic void msm_hc_select_hs400(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct mmc_ios ios = host->mmc->ios;\n\tu32 config, dll_lock;\n\tint rc;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\t \n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_vendor_spec);\n\tconfig &= ~CORE_HC_MCLK_SEL_MASK;\n\tconfig |= CORE_HC_MCLK_SEL_HS400;\n\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_vendor_spec);\n\t \n\tif ((msm_host->tuning_done || ios.enhanced_strobe) &&\n\t    !msm_host->calibration_done) {\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec);\n\t\tconfig |= CORE_HC_SELECT_IN_HS400;\n\t\tconfig |= CORE_HC_SELECT_IN_EN;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec);\n\t}\n\tif (!msm_host->clk_rate && !msm_host->use_cdclp533) {\n\t\t \n\t\trc = readl_relaxed_poll_timeout(host->ioaddr +\n\t\t\t\t\t\tmsm_offset->core_dll_status,\n\t\t\t\t\t\tdll_lock,\n\t\t\t\t\t\t(dll_lock &\n\t\t\t\t\t\t(CORE_DLL_LOCK |\n\t\t\t\t\t\tCORE_DDR_DLL_LOCK)), 10,\n\t\t\t\t\t\t1000);\n\t\tif (rc == -ETIMEDOUT)\n\t\t\tpr_err(\"%s: Unable to get DLL_LOCK/DDR_DLL_LOCK, dll_status: 0x%08x\\n\",\n\t\t\t       mmc_hostname(host->mmc), dll_lock);\n\t}\n\t \n\twmb();\n}\n\n \nstatic void sdhci_msm_hc_select_mode(struct sdhci_host *host)\n{\n\tstruct mmc_ios ios = host->mmc->ios;\n\n\tif (ios.timing == MMC_TIMING_MMC_HS400 ||\n\t    host->flags & SDHCI_HS400_TUNING)\n\t\tmsm_hc_select_hs400(host);\n\telse\n\t\tmsm_hc_select_default(host);\n}\n\nstatic int sdhci_msm_cdclp533_calibration(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 config, calib_done;\n\tint ret;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tpr_debug(\"%s: %s: Enter\\n\", mmc_hostname(host->mmc), __func__);\n\n\t \n\tret = msm_init_cm_dll(host);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = msm_config_cm_dll_phase(host, msm_host->saved_tuning_phase);\n\tif (ret)\n\t\tgoto out;\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config);\n\tconfig |= CORE_CMD_DAT_TRACK_SEL;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config);\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_ddr_200_cfg);\n\tconfig &= ~CORE_CDC_T4_DLY_SEL;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_ddr_200_cfg);\n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_GEN_CFG);\n\tconfig &= ~CORE_CDC_SWITCH_BYPASS_OFF;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_GEN_CFG);\n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_GEN_CFG);\n\tconfig |= CORE_CDC_SWITCH_RC_EN;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_GEN_CFG);\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_ddr_200_cfg);\n\tconfig &= ~CORE_START_CDC_TRAFFIC;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_ddr_200_cfg);\n\n\t \n\n\twritel_relaxed(0x11800EC, host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\twritel_relaxed(0x3011111, host->ioaddr + CORE_CSR_CDC_CTLR_CFG1);\n\twritel_relaxed(0x1201000, host->ioaddr + CORE_CSR_CDC_CAL_TIMER_CFG0);\n\twritel_relaxed(0x4, host->ioaddr + CORE_CSR_CDC_CAL_TIMER_CFG1);\n\twritel_relaxed(0xCB732020, host->ioaddr + CORE_CSR_CDC_REFCOUNT_CFG);\n\twritel_relaxed(0xB19, host->ioaddr + CORE_CSR_CDC_COARSE_CAL_CFG);\n\twritel_relaxed(0x4E2, host->ioaddr + CORE_CSR_CDC_DELAY_CFG);\n\twritel_relaxed(0x0, host->ioaddr + CORE_CDC_OFFSET_CFG);\n\twritel_relaxed(0x16334, host->ioaddr + CORE_CDC_SLAVE_DDA_CFG);\n\n\t \n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\tconfig |= CORE_SW_TRIG_FULL_CALIB;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\tconfig &= ~CORE_SW_TRIG_FULL_CALIB;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\tconfig |= CORE_HW_AUTOCAL_ENA;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_CTLR_CFG0);\n\n\tconfig = readl_relaxed(host->ioaddr + CORE_CSR_CDC_CAL_TIMER_CFG0);\n\tconfig |= CORE_TIMER_ENA;\n\twritel_relaxed(config, host->ioaddr + CORE_CSR_CDC_CAL_TIMER_CFG0);\n\n\tret = readl_relaxed_poll_timeout(host->ioaddr + CORE_CSR_CDC_STATUS0,\n\t\t\t\t\t calib_done,\n\t\t\t\t\t (calib_done & CORE_CALIBRATION_DONE),\n\t\t\t\t\t 1, 50);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tpr_err(\"%s: %s: CDC calibration was not completed\\n\",\n\t\t       mmc_hostname(host->mmc), __func__);\n\t\tgoto out;\n\t}\n\n\tret = readl_relaxed(host->ioaddr + CORE_CSR_CDC_STATUS0)\n\t\t\t& CORE_CDC_ERROR_CODE_MASK;\n\tif (ret) {\n\t\tpr_err(\"%s: %s: CDC error code %d\\n\",\n\t\t       mmc_hostname(host->mmc), __func__, ret);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_ddr_200_cfg);\n\tconfig |= CORE_START_CDC_TRAFFIC;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_ddr_200_cfg);\nout:\n\tpr_debug(\"%s: %s: Exit, ret %d\\n\", mmc_hostname(host->mmc),\n\t\t __func__, ret);\n\treturn ret;\n}\n\nstatic int sdhci_msm_cm_dll_sdc4_calibration(struct sdhci_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tu32 dll_status, config, ddr_cfg_offset;\n\tint ret;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tsdhci_priv_msm_offset(host);\n\n\tpr_debug(\"%s: %s: Enter\\n\", mmc_hostname(host->mmc), __func__);\n\n\t \n\tif (msm_host->updated_ddr_cfg)\n\t\tddr_cfg_offset = msm_offset->core_ddr_config;\n\telse\n\t\tddr_cfg_offset = msm_offset->core_ddr_config_old;\n\twritel_relaxed(msm_host->ddr_config, host->ioaddr + ddr_cfg_offset);\n\n\tif (mmc->ios.enhanced_strobe) {\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_ddr_200_cfg);\n\t\tconfig |= CORE_CMDIN_RCLK_EN;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_ddr_200_cfg);\n\t}\n\n\tconfig = readl_relaxed(host->ioaddr + msm_offset->core_dll_config_2);\n\tconfig |= CORE_DDR_CAL_EN;\n\twritel_relaxed(config, host->ioaddr + msm_offset->core_dll_config_2);\n\n\tret = readl_relaxed_poll_timeout(host->ioaddr +\n\t\t\t\t\tmsm_offset->core_dll_status,\n\t\t\t\t\tdll_status,\n\t\t\t\t\t(dll_status & CORE_DDR_DLL_LOCK),\n\t\t\t\t\t10, 1000);\n\n\tif (ret == -ETIMEDOUT) {\n\t\tpr_err(\"%s: %s: CM_DLL_SDC4 calibration was not completed\\n\",\n\t\t       mmc_hostname(host->mmc), __func__);\n\t\tgoto out;\n\t}\n\n\t \n\tif (!msm_host->use_14lpp_dll_reset) {\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec3);\n\t\tconfig |= CORE_PWRSAVE_DLL;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec3);\n\t}\n\n\t \n\twmb();\nout:\n\tpr_debug(\"%s: %s: Exit, ret %d\\n\", mmc_hostname(host->mmc),\n\t\t __func__, ret);\n\treturn ret;\n}\n\nstatic int sdhci_msm_hs400_dll_calibration(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret;\n\tu32 config;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tpr_debug(\"%s: %s: Enter\\n\", mmc_hostname(host->mmc), __func__);\n\n\t \n\tret = msm_init_cm_dll(host);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!mmc->ios.enhanced_strobe) {\n\t\t \n\t\tret = msm_config_cm_dll_phase(host,\n\t\t\t\t\t      msm_host->saved_tuning_phase);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\t\tconfig |= CORE_CMD_DAT_TRACK_SEL;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\t}\n\n\tif (msm_host->use_cdclp533)\n\t\tret = sdhci_msm_cdclp533_calibration(host);\n\telse\n\t\tret = sdhci_msm_cm_dll_sdc4_calibration(host);\nout:\n\tpr_debug(\"%s: %s: Exit, ret %d\\n\", mmc_hostname(host->mmc),\n\t\t __func__, ret);\n\treturn ret;\n}\n\nstatic bool sdhci_msm_is_tuning_needed(struct sdhci_host *host)\n{\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\n\t \n\tif (host->clock <= CORE_FREQ_100MHZ ||\n\t    !(ios->timing == MMC_TIMING_MMC_HS400 ||\n\t    ios->timing == MMC_TIMING_MMC_HS200 ||\n\t    ios->timing == MMC_TIMING_UHS_SDR104) ||\n\t    ios->enhanced_strobe)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int sdhci_msm_restore_sdr_dll_config(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\t \n\tif (!sdhci_msm_is_tuning_needed(host))\n\t\treturn 0;\n\n\t \n\tret = msm_init_cm_dll(host);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = msm_config_cm_dll_phase(host, msm_host->saved_tuning_phase);\n\n\treturn ret;\n}\n\nstatic void sdhci_msm_set_cdr(struct sdhci_host *host, bool enable)\n{\n\tconst struct sdhci_msm_offset *msm_offset = sdhci_priv_msm_offset(host);\n\tu32 config, oldconfig = readl_relaxed(host->ioaddr +\n\t\t\t\t\t      msm_offset->core_dll_config);\n\n\tconfig = oldconfig;\n\tif (enable) {\n\t\tconfig |= CORE_CDR_EN;\n\t\tconfig &= ~CORE_CDR_EXT_EN;\n\t} else {\n\t\tconfig &= ~CORE_CDR_EN;\n\t\tconfig |= CORE_CDR_EXT_EN;\n\t}\n\n\tif (config != oldconfig) {\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t       msm_offset->core_dll_config);\n\t}\n}\n\nstatic int sdhci_msm_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tint tuning_seq_cnt = 10;\n\tu8 phase, tuned_phases[16], tuned_phase_cnt = 0;\n\tint rc;\n\tstruct mmc_ios ios = host->mmc->ios;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (!sdhci_msm_is_tuning_needed(host)) {\n\t\tmsm_host->use_cdr = false;\n\t\tsdhci_msm_set_cdr(host, false);\n\t\treturn 0;\n\t}\n\n\t \n\tmsm_host->use_cdr = true;\n\n\t \n\tmsm_host->tuning_done = 0;\n\n\t \n\tif (host->flags & SDHCI_HS400_TUNING) {\n\t\tsdhci_msm_hc_select_mode(host);\n\t\tmsm_set_clock_rate_for_bus_mode(host, ios.clock);\n\t\thost->flags &= ~SDHCI_HS400_TUNING;\n\t}\n\nretry:\n\t \n\trc = msm_init_cm_dll(host);\n\tif (rc)\n\t\treturn rc;\n\n\tphase = 0;\n\tdo {\n\t\t \n\t\trc = msm_config_cm_dll_phase(host, phase);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\trc = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!rc) {\n\t\t\t \n\t\t\ttuned_phases[tuned_phase_cnt++] = phase;\n\t\t\tdev_dbg(mmc_dev(mmc), \"%s: Found good phase = %d\\n\",\n\t\t\t\t mmc_hostname(mmc), phase);\n\t\t}\n\t} while (++phase < ARRAY_SIZE(tuned_phases));\n\n\tif (tuned_phase_cnt) {\n\t\tif (tuned_phase_cnt == ARRAY_SIZE(tuned_phases)) {\n\t\t\t \n\t\t\tdev_dbg(mmc_dev(mmc), \"%s: All phases valid; try again\\n\",\n\t\t\t\tmmc_hostname(mmc));\n\t\t\tif (--tuning_seq_cnt) {\n\t\t\t\ttuned_phase_cnt = 0;\n\t\t\t\tgoto retry;\n\t\t\t}\n\t\t}\n\n\t\trc = msm_find_most_appropriate_phase(host, tuned_phases,\n\t\t\t\t\t\t     tuned_phase_cnt);\n\t\tif (rc < 0)\n\t\t\treturn rc;\n\t\telse\n\t\t\tphase = rc;\n\n\t\t \n\t\trc = msm_config_cm_dll_phase(host, phase);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tmsm_host->saved_tuning_phase = phase;\n\t\tdev_dbg(mmc_dev(mmc), \"%s: Setting the tuning phase to %d\\n\",\n\t\t\t mmc_hostname(mmc), phase);\n\t} else {\n\t\tif (--tuning_seq_cnt)\n\t\t\tgoto retry;\n\t\t \n\t\tdev_dbg(mmc_dev(mmc), \"%s: No tuning point found\\n\",\n\t\t       mmc_hostname(mmc));\n\t\trc = -EIO;\n\t}\n\n\tif (!rc)\n\t\tmsm_host->tuning_done = true;\n\treturn rc;\n}\n\n \nstatic void sdhci_msm_hs400(struct sdhci_host *host, struct mmc_ios *ios)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tif (host->clock > CORE_FREQ_100MHZ &&\n\t    (msm_host->tuning_done || ios->enhanced_strobe) &&\n\t    !msm_host->calibration_done) {\n\t\tret = sdhci_msm_hs400_dll_calibration(host);\n\t\tif (!ret)\n\t\t\tmsm_host->calibration_done = true;\n\t\telse\n\t\t\tpr_err(\"%s: Failed to calibrate DLL for hs400 mode (%d)\\n\",\n\t\t\t       mmc_hostname(host->mmc), ret);\n\t}\n}\n\nstatic void sdhci_msm_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\tunsigned int uhs)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tu16 ctrl_2;\n\tu32 config;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tswitch (uhs) {\n\tcase MMC_TIMING_UHS_SDR12:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\tcase MMC_TIMING_MMC_HS200:\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50;\n\t\tbreak;\n\t}\n\n\t \n\tif (host->clock <= CORE_FREQ_100MHZ) {\n\t\tif (uhs == MMC_TIMING_MMC_HS400 ||\n\t\t    uhs == MMC_TIMING_MMC_HS200 ||\n\t\t    uhs == MMC_TIMING_UHS_SDR104)\n\t\t\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\t\t \n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\t\tconfig |= CORE_DLL_RST;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\t\tconfig |= CORE_DLL_PDN;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_dll_config);\n\n\t\t \n\t\tmsm_host->calibration_done = false;\n\t}\n\n\tdev_dbg(mmc_dev(mmc), \"%s: clock=%u uhs=%u ctrl_2=0x%x\\n\",\n\t\tmmc_hostname(host->mmc), host->clock, uhs, ctrl_2);\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n\n\tif (mmc->ios.timing == MMC_TIMING_MMC_HS400)\n\t\tsdhci_msm_hs400(host, &mmc->ios);\n}\n\nstatic int sdhci_msm_set_pincfg(struct sdhci_msm_host *msm_host, bool level)\n{\n\tstruct platform_device *pdev = msm_host->pdev;\n\tint ret;\n\n\tif (level)\n\t\tret = pinctrl_pm_select_default_state(&pdev->dev);\n\telse\n\t\tret = pinctrl_pm_select_sleep_state(&pdev->dev);\n\n\treturn ret;\n}\n\nstatic int sdhci_msm_set_vmmc(struct mmc_host *mmc)\n{\n\tif (IS_ERR(mmc->supply.vmmc))\n\t\treturn 0;\n\n\treturn mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, mmc->ios.vdd);\n}\n\nstatic int msm_toggle_vqmmc(struct sdhci_msm_host *msm_host,\n\t\t\t      struct mmc_host *mmc, bool level)\n{\n\tint ret;\n\tstruct mmc_ios ios;\n\n\tif (msm_host->vqmmc_enabled == level)\n\t\treturn 0;\n\n\tif (level) {\n\t\t \n\t\tif (msm_host->caps_0 & CORE_3_0V_SUPPORT)\n\t\t\tios.signal_voltage = MMC_SIGNAL_VOLTAGE_330;\n\t\telse if (msm_host->caps_0 & CORE_1_8V_SUPPORT)\n\t\t\tios.signal_voltage = MMC_SIGNAL_VOLTAGE_180;\n\n\t\tif (msm_host->caps_0 & CORE_VOLT_SUPPORT) {\n\t\t\tret = mmc_regulator_set_vqmmc(mmc, &ios);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(mmc_dev(mmc), \"%s: vqmmc set volgate failed: %d\\n\",\n\t\t\t\t\tmmc_hostname(mmc), ret);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t} else {\n\t\tret = regulator_disable(mmc->supply.vqmmc);\n\t}\n\n\tif (ret)\n\t\tdev_err(mmc_dev(mmc), \"%s: vqmm %sable failed: %d\\n\",\n\t\t\tmmc_hostname(mmc), level ? \"en\":\"dis\", ret);\n\telse\n\t\tmsm_host->vqmmc_enabled = level;\nout:\n\treturn ret;\n}\n\nstatic int msm_config_vqmmc_mode(struct sdhci_msm_host *msm_host,\n\t\t\t      struct mmc_host *mmc, bool hpm)\n{\n\tint load, ret;\n\n\tload = hpm ? MMC_VQMMC_MAX_LOAD_UA : 0;\n\tret = regulator_set_load(mmc->supply.vqmmc, load);\n\tif (ret)\n\t\tdev_err(mmc_dev(mmc), \"%s: vqmmc set load failed: %d\\n\",\n\t\t\tmmc_hostname(mmc), ret);\n\treturn ret;\n}\n\nstatic int sdhci_msm_set_vqmmc(struct sdhci_msm_host *msm_host,\n\t\t\t      struct mmc_host *mmc, bool level)\n{\n\tint ret;\n\tbool always_on;\n\n\tif (IS_ERR(mmc->supply.vqmmc) ||\n\t\t\t(mmc->ios.power_mode == MMC_POWER_UNDEFINED))\n\t\treturn 0;\n\t \n\talways_on = !mmc_card_is_removable(mmc) &&\n\t\t\tmmc->card && mmc_card_mmc(mmc->card);\n\n\tif (always_on)\n\t\tret = msm_config_vqmmc_mode(msm_host, mmc, level);\n\telse\n\t\tret = msm_toggle_vqmmc(msm_host, mmc, level);\n\n\treturn ret;\n}\n\nstatic inline void sdhci_msm_init_pwr_irq_wait(struct sdhci_msm_host *msm_host)\n{\n\tinit_waitqueue_head(&msm_host->pwr_irq_wait);\n}\n\nstatic inline void sdhci_msm_complete_pwr_irq_wait(\n\t\tstruct sdhci_msm_host *msm_host)\n{\n\twake_up(&msm_host->pwr_irq_wait);\n}\n\n \nstatic void sdhci_msm_check_power_status(struct sdhci_host *host, u32 req_type)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tbool done = false;\n\tu32 val = SWITCHABLE_SIGNALING_VOLTAGE;\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tpr_debug(\"%s: %s: request %d curr_pwr_state %x curr_io_level %x\\n\",\n\t\t\tmmc_hostname(host->mmc), __func__, req_type,\n\t\t\tmsm_host->curr_pwr_state, msm_host->curr_io_level);\n\n\t \n\tif (!msm_host->mci_removed)\n\t\tval = msm_host_readl(msm_host, host,\n\t\t\t\tmsm_offset->core_generics);\n\tif ((req_type & REQ_IO_HIGH || req_type & REQ_IO_LOW) &&\n\t    !(val & SWITCHABLE_SIGNALING_VOLTAGE)) {\n\t\treturn;\n\t}\n\n\t \n\tif ((req_type & REQ_IO_HIGH) && !host->pwr) {\n\t\tpr_debug(\"%s: do not wait for power IRQ that never comes, req_type: %d\\n\",\n\t\t\t\tmmc_hostname(host->mmc), req_type);\n\t\treturn;\n\t}\n\tif ((req_type & msm_host->curr_pwr_state) ||\n\t\t\t(req_type & msm_host->curr_io_level))\n\t\tdone = true;\n\t \n\tif (!done) {\n\t\tif (!wait_event_timeout(msm_host->pwr_irq_wait,\n\t\t\t\tmsm_host->pwr_irq_flag,\n\t\t\t\tmsecs_to_jiffies(MSM_PWR_IRQ_TIMEOUT_MS)))\n\t\t\tdev_warn(&msm_host->pdev->dev,\n\t\t\t\t \"%s: pwr_irq for req: (%d) timed out\\n\",\n\t\t\t\t mmc_hostname(host->mmc), req_type);\n\t}\n\tpr_debug(\"%s: %s: request %d done\\n\", mmc_hostname(host->mmc),\n\t\t\t__func__, req_type);\n}\n\nstatic void sdhci_msm_dump_pwr_ctrl_regs(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_msm_offset *msm_offset =\n\t\t\t\t\tmsm_host->offset;\n\n\tpr_err(\"%s: PWRCTL_STATUS: 0x%08x | PWRCTL_MASK: 0x%08x | PWRCTL_CTL: 0x%08x\\n\",\n\t\tmmc_hostname(host->mmc),\n\t\tmsm_host_readl(msm_host, host, msm_offset->core_pwrctl_status),\n\t\tmsm_host_readl(msm_host, host, msm_offset->core_pwrctl_mask),\n\t\tmsm_host_readl(msm_host, host, msm_offset->core_pwrctl_ctl));\n}\n\nstatic void sdhci_msm_handle_pwr_irq(struct sdhci_host *host, int irq)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct mmc_host *mmc = host->mmc;\n\tu32 irq_status, irq_ack = 0;\n\tint retry = 10, ret;\n\tu32 pwr_state = 0, io_level = 0;\n\tu32 config;\n\tconst struct sdhci_msm_offset *msm_offset = msm_host->offset;\n\n\tirq_status = msm_host_readl(msm_host, host,\n\t\t\tmsm_offset->core_pwrctl_status);\n\tirq_status &= INT_MASK;\n\n\tmsm_host_writel(msm_host, irq_status, host,\n\t\t\tmsm_offset->core_pwrctl_clear);\n\n\t \n\twhile (irq_status & msm_host_readl(msm_host, host,\n\t\t\t\tmsm_offset->core_pwrctl_status)) {\n\t\tif (retry == 0) {\n\t\t\tpr_err(\"%s: Timedout clearing (0x%x) pwrctl status register\\n\",\n\t\t\t\t\tmmc_hostname(host->mmc), irq_status);\n\t\t\tsdhci_msm_dump_pwr_ctrl_regs(host);\n\t\t\tWARN_ON(1);\n\t\t\tbreak;\n\t\t}\n\t\tmsm_host_writel(msm_host, irq_status, host,\n\t\t\tmsm_offset->core_pwrctl_clear);\n\t\tretry--;\n\t\tudelay(10);\n\t}\n\n\t \n\tif (irq_status & CORE_PWRCTL_BUS_ON) {\n\t\tpwr_state = REQ_BUS_ON;\n\t\tio_level = REQ_IO_HIGH;\n\t}\n\tif (irq_status & CORE_PWRCTL_BUS_OFF) {\n\t\tpwr_state = REQ_BUS_OFF;\n\t\tio_level = REQ_IO_LOW;\n\t}\n\n\tif (pwr_state) {\n\t\tret = sdhci_msm_set_vmmc(mmc);\n\t\tif (!ret)\n\t\t\tret = sdhci_msm_set_vqmmc(msm_host, mmc,\n\t\t\t\t\tpwr_state & REQ_BUS_ON);\n\t\tif (!ret)\n\t\t\tret = sdhci_msm_set_pincfg(msm_host,\n\t\t\t\t\tpwr_state & REQ_BUS_ON);\n\t\tif (!ret)\n\t\t\tirq_ack |= CORE_PWRCTL_BUS_SUCCESS;\n\t\telse\n\t\t\tirq_ack |= CORE_PWRCTL_BUS_FAIL;\n\t}\n\n\t \n\tif (irq_status & CORE_PWRCTL_IO_LOW)\n\t\tio_level = REQ_IO_LOW;\n\n\tif (irq_status & CORE_PWRCTL_IO_HIGH)\n\t\tio_level = REQ_IO_HIGH;\n\n\tif (io_level)\n\t\tirq_ack |= CORE_PWRCTL_IO_SUCCESS;\n\n\tif (io_level && !IS_ERR(mmc->supply.vqmmc) && !pwr_state) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, &mmc->ios);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"%s: IO_level setting failed(%d). signal_voltage: %d, vdd: %d irq_status: 0x%08x\\n\",\n\t\t\t\t\tmmc_hostname(mmc), ret,\n\t\t\t\t\tmmc->ios.signal_voltage, mmc->ios.vdd,\n\t\t\t\t\tirq_status);\n\t\t\tirq_ack |= CORE_PWRCTL_IO_FAIL;\n\t\t}\n\t}\n\n\t \n\tmsm_host_writel(msm_host, irq_ack, host,\n\t\t\tmsm_offset->core_pwrctl_ctl);\n\n\t \n\tif (msm_host->caps_0 & CORE_VOLT_SUPPORT) {\n\t\tu32 new_config;\n\t\t \n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec);\n\t\tnew_config = config;\n\n\t\tif ((io_level & REQ_IO_HIGH) &&\n\t\t\t\t(msm_host->caps_0 & CORE_3_0V_SUPPORT))\n\t\t\tnew_config &= ~CORE_IO_PAD_PWR_SWITCH;\n\t\telse if ((io_level & REQ_IO_LOW) ||\n\t\t\t\t(msm_host->caps_0 & CORE_1_8V_SUPPORT))\n\t\t\tnew_config |= CORE_IO_PAD_PWR_SWITCH;\n\n\t\tif (config ^ new_config)\n\t\t\twritel_relaxed(new_config, host->ioaddr +\n\t\t\t\t\tmsm_offset->core_vendor_spec);\n\t}\n\n\tif (pwr_state)\n\t\tmsm_host->curr_pwr_state = pwr_state;\n\tif (io_level)\n\t\tmsm_host->curr_io_level = io_level;\n\n\tdev_dbg(mmc_dev(mmc), \"%s: %s: Handled IRQ(%d), irq_status=0x%x, ack=0x%x\\n\",\n\t\tmmc_hostname(msm_host->mmc), __func__, irq, irq_status,\n\t\tirq_ack);\n}\n\nstatic irqreturn_t sdhci_msm_pwr_irq(int irq, void *data)\n{\n\tstruct sdhci_host *host = (struct sdhci_host *)data;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_msm_handle_pwr_irq(host, irq);\n\tmsm_host->pwr_irq_flag = 1;\n\tsdhci_msm_complete_pwr_irq_wait(msm_host);\n\n\n\treturn IRQ_HANDLED;\n}\n\nstatic unsigned int sdhci_msm_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct clk *core_clk = msm_host->bulk_clks[0].clk;\n\n\treturn clk_round_rate(core_clk, ULONG_MAX);\n}\n\nstatic unsigned int sdhci_msm_get_min_clock(struct sdhci_host *host)\n{\n\treturn SDHCI_MSM_MIN_CLOCK;\n}\n\n \nstatic void __sdhci_msm_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tu16 clk;\n\n\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\n\tif (clock == 0)\n\t\treturn;\n\n\t \n\tclk = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tsdhci_enable_clk(host, clk);\n}\n\n \nstatic void sdhci_msm_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (!clock) {\n\t\thost->mmc->actual_clock = msm_host->clk_rate = 0;\n\t\tgoto out;\n\t}\n\n\tsdhci_msm_hc_select_mode(host);\n\n\tmsm_set_clock_rate_for_bus_mode(host, clock);\nout:\n\t__sdhci_msm_set_clock(host, clock);\n}\n\n \n\n#ifdef CONFIG_MMC_CRYPTO\n\nstatic int sdhci_msm_ice_init(struct sdhci_msm_host *msm_host,\n\t\t\t      struct cqhci_host *cq_host)\n{\n\tstruct mmc_host *mmc = msm_host->mmc;\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct qcom_ice *ice;\n\n\tif (!(cqhci_readl(cq_host, CQHCI_CAP) & CQHCI_CAP_CS))\n\t\treturn 0;\n\n\tice = of_qcom_ice_get(dev);\n\tif (ice == ERR_PTR(-EOPNOTSUPP)) {\n\t\tdev_warn(dev, \"Disabling inline encryption support\\n\");\n\t\tice = NULL;\n\t}\n\n\tif (IS_ERR_OR_NULL(ice))\n\t\treturn PTR_ERR_OR_ZERO(ice);\n\n\tmsm_host->ice = ice;\n\tmmc->caps2 |= MMC_CAP2_CRYPTO;\n\n\treturn 0;\n}\n\nstatic void sdhci_msm_ice_enable(struct sdhci_msm_host *msm_host)\n{\n\tif (msm_host->mmc->caps2 & MMC_CAP2_CRYPTO)\n\t\tqcom_ice_enable(msm_host->ice);\n}\n\nstatic __maybe_unused int sdhci_msm_ice_resume(struct sdhci_msm_host *msm_host)\n{\n\tif (msm_host->mmc->caps2 & MMC_CAP2_CRYPTO)\n\t\treturn qcom_ice_resume(msm_host->ice);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int sdhci_msm_ice_suspend(struct sdhci_msm_host *msm_host)\n{\n\tif (msm_host->mmc->caps2 & MMC_CAP2_CRYPTO)\n\t\treturn qcom_ice_suspend(msm_host->ice);\n\n\treturn 0;\n}\n\n \nstatic int sdhci_msm_program_key(struct cqhci_host *cq_host,\n\t\t\t\t const union cqhci_crypto_cfg_entry *cfg,\n\t\t\t\t int slot)\n{\n\tstruct sdhci_host *host = mmc_priv(cq_host->mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tunion cqhci_crypto_cap_entry cap;\n\n\t \n\tcap = cq_host->crypto_cap_array[cfg->crypto_cap_idx];\n\tif (cap.algorithm_id != CQHCI_CRYPTO_ALG_AES_XTS ||\n\t\tcap.key_size != CQHCI_CRYPTO_KEY_SIZE_256)\n\t\treturn -EINVAL;\n\n\tif (cfg->config_enable & CQHCI_CRYPTO_CONFIGURATION_ENABLE)\n\t\treturn qcom_ice_program_key(msm_host->ice,\n\t\t\t\t\t    QCOM_ICE_CRYPTO_ALG_AES_XTS,\n\t\t\t\t\t    QCOM_ICE_CRYPTO_KEY_SIZE_256,\n\t\t\t\t\t    cfg->crypto_key,\n\t\t\t\t\t    cfg->data_unit_size, slot);\n\telse\n\t\treturn qcom_ice_evict_key(msm_host->ice, slot);\n}\n\n#else  \n\nstatic inline int sdhci_msm_ice_init(struct sdhci_msm_host *msm_host,\n\t\t\t\t     struct cqhci_host *cq_host)\n{\n\treturn 0;\n}\n\nstatic inline void sdhci_msm_ice_enable(struct sdhci_msm_host *msm_host)\n{\n}\n\nstatic inline __maybe_unused int\nsdhci_msm_ice_resume(struct sdhci_msm_host *msm_host)\n{\n\treturn 0;\n}\n\nstatic inline __maybe_unused int\nsdhci_msm_ice_suspend(struct sdhci_msm_host *msm_host)\n{\n\treturn 0;\n}\n#endif  \n\n \n\nstatic u32 sdhci_msm_cqe_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\treturn 0;\n}\n\nstatic void sdhci_msm_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_cqe_enable(mmc);\n\tsdhci_msm_ice_enable(msm_host);\n}\n\nstatic void sdhci_msm_cqe_disable(struct mmc_host *mmc, bool recovery)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tu32 ctrl;\n\n\t \n\tif (host->flags & SDHCI_USE_64_BIT_DMA)\n\t\thost->desc_sz = 16;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\t \n\tctrl = sdhci_readl(host, SDHCI_INT_ENABLE);\n\tctrl |= SDHCI_INT_RESPONSE;\n\tsdhci_writel(host,  ctrl, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, SDHCI_INT_RESPONSE, SDHCI_INT_STATUS);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tsdhci_cqe_disable(mmc, recovery);\n}\n\nstatic void sdhci_msm_set_timeout(struct sdhci_host *host, struct mmc_command *cmd)\n{\n\tu32 count, start = 15;\n\n\t__sdhci_set_timeout(host, cmd);\n\tcount = sdhci_readb(host, SDHCI_TIMEOUT_CONTROL);\n\t \n\tif (cmd && cmd->data && host->clock > 400000 &&\n\t    host->clock <= 50000000 &&\n\t    ((1 << (count + start)) > (10 * host->clock)))\n\t\thost->data_timeout = 22LL * NSEC_PER_SEC;\n}\n\nstatic const struct cqhci_host_ops sdhci_msm_cqhci_ops = {\n\t.enable\t\t= sdhci_msm_cqe_enable,\n\t.disable\t= sdhci_msm_cqe_disable,\n#ifdef CONFIG_MMC_CRYPTO\n\t.program_key\t= sdhci_msm_program_key,\n#endif\n};\n\nstatic int sdhci_msm_cqe_add_host(struct sdhci_host *host,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct cqhci_host *cq_host;\n\tbool dma64;\n\tu32 cqcfg;\n\tint ret;\n\n\t \n\tif (host->caps & SDHCI_CAN_64BIT)\n\t\thost->alloc_desc_sz = 16;\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tcq_host = cqhci_pltfm_init(pdev);\n\tif (IS_ERR(cq_host)) {\n\t\tret = PTR_ERR(cq_host);\n\t\tdev_err(&pdev->dev, \"cqhci-pltfm init: failed: %d\\n\", ret);\n\t\tgoto cleanup;\n\t}\n\n\tmsm_host->mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;\n\tcq_host->ops = &sdhci_msm_cqhci_ops;\n\n\tdma64 = host->flags & SDHCI_USE_64_BIT_DMA;\n\n\tret = sdhci_msm_ice_init(msm_host, cq_host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = cqhci_init(cq_host, host->mmc, dma64);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"%s: CQE init: failed (%d)\\n\",\n\t\t\t\tmmc_hostname(host->mmc), ret);\n\t\tgoto cleanup;\n\t}\n\n\t \n\tcqcfg = cqhci_readl(cq_host, CQHCI_VENDOR_CFG1);\n\tcqcfg |= CQHCI_VENDOR_DIS_RST_ON_CQ_EN;\n\tcqhci_writel(cq_host, cqcfg, CQHCI_VENDOR_CFG1);\n\n\t \n\tif (host->flags & SDHCI_USE_64_BIT_DMA)\n\t\thost->desc_sz = 12;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tdev_info(&pdev->dev, \"%s: CQE init: success\\n\",\n\t\t\tmmc_hostname(host->mmc));\n\treturn ret;\n\ncleanup:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\n \nstatic int __sdhci_msm_check_write(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 req_type = 0;\n\n\tswitch (reg) {\n\tcase SDHCI_HOST_CONTROL2:\n\t\treq_type = (val & SDHCI_CTRL_VDD_180) ? REQ_IO_LOW :\n\t\t\tREQ_IO_HIGH;\n\t\tbreak;\n\tcase SDHCI_SOFTWARE_RESET:\n\t\tif (host->pwr && (val & SDHCI_RESET_ALL))\n\t\t\treq_type = REQ_BUS_OFF;\n\t\tbreak;\n\tcase SDHCI_POWER_CONTROL:\n\t\treq_type = !val ? REQ_BUS_OFF : REQ_BUS_ON;\n\t\tbreak;\n\tcase SDHCI_TRANSFER_MODE:\n\t\tmsm_host->transfer_mode = val;\n\t\tbreak;\n\tcase SDHCI_COMMAND:\n\t\tif (!msm_host->use_cdr)\n\t\t\tbreak;\n\t\tif ((msm_host->transfer_mode & SDHCI_TRNS_READ) &&\n\t\t    !mmc_op_tuning(SDHCI_GET_CMD(val)))\n\t\t\tsdhci_msm_set_cdr(host, true);\n\t\telse\n\t\t\tsdhci_msm_set_cdr(host, false);\n\t\tbreak;\n\t}\n\n\tif (req_type) {\n\t\tmsm_host->pwr_irq_flag = 0;\n\t\t \n\t\tmb();\n\t}\n\treturn req_type;\n}\n\n \nstatic void sdhci_msm_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tu32 req_type = 0;\n\n\treq_type = __sdhci_msm_check_write(host, val, reg);\n\twritew_relaxed(val, host->ioaddr + reg);\n\n\tif (req_type)\n\t\tsdhci_msm_check_power_status(host, req_type);\n}\n\n \nstatic void sdhci_msm_writeb(struct sdhci_host *host, u8 val, int reg)\n{\n\tu32 req_type = 0;\n\n\treq_type = __sdhci_msm_check_write(host, val, reg);\n\n\twriteb_relaxed(val, host->ioaddr + reg);\n\n\tif (req_type)\n\t\tsdhci_msm_check_power_status(host, req_type);\n}\n\nstatic void sdhci_msm_set_regulator_caps(struct sdhci_msm_host *msm_host)\n{\n\tstruct mmc_host *mmc = msm_host->mmc;\n\tstruct regulator *supply = mmc->supply.vqmmc;\n\tu32 caps = 0, config;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tconst struct sdhci_msm_offset *msm_offset = msm_host->offset;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tif (regulator_is_supported_voltage(supply, 1700000, 1950000))\n\t\t\tcaps |= CORE_1_8V_SUPPORT;\n\t\tif (regulator_is_supported_voltage(supply, 2700000, 3600000))\n\t\t\tcaps |= CORE_3_0V_SUPPORT;\n\n\t\tif (!caps)\n\t\t\tpr_warn(\"%s: 1.8/3V not supported for vqmmc\\n\",\n\t\t\t\t\tmmc_hostname(mmc));\n\t}\n\n\tif (caps) {\n\t\t \n\t\tu32 io_level = msm_host->curr_io_level;\n\n\t\tconfig = readl_relaxed(host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec);\n\t\tconfig |= CORE_IO_PAD_PWR_SWITCH_EN;\n\n\t\tif ((io_level & REQ_IO_HIGH) && (caps &\tCORE_3_0V_SUPPORT))\n\t\t\tconfig &= ~CORE_IO_PAD_PWR_SWITCH;\n\t\telse if ((io_level & REQ_IO_LOW) || (caps & CORE_1_8V_SUPPORT))\n\t\t\tconfig |= CORE_IO_PAD_PWR_SWITCH;\n\n\t\twritel_relaxed(config,\n\t\t\t\thost->ioaddr + msm_offset->core_vendor_spec);\n\t}\n\tmsm_host->caps_0 |= caps;\n\tpr_debug(\"%s: supported caps: 0x%08x\\n\", mmc_hostname(mmc), caps);\n}\n\nstatic int sdhci_msm_register_vreg(struct sdhci_msm_host *msm_host)\n{\n\tint ret;\n\n\tret = mmc_regulator_get_supply(msm_host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tsdhci_msm_set_regulator_caps(msm_host);\n\n\treturn 0;\n}\n\nstatic int sdhci_msm_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t      struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu16 ctrl, status;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\tctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tif (!(host->flags & SDHCI_SIGNALING_330))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tctrl &= ~SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tif (!(host->flags & SDHCI_SIGNALING_180))\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tctrl |= SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsdhci_writew(host, ctrl, SDHCI_HOST_CONTROL2);\n\n\t \n\tusleep_range(5000, 5500);\n\n\t \n\tstatus = ctrl & SDHCI_CTRL_VDD_180;\n\tctrl = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\tif ((ctrl & SDHCI_CTRL_VDD_180) == status)\n\t\treturn 0;\n\n\tdev_warn(mmc_dev(mmc), \"%s: Regulator output did not became stable\\n\",\n\t\tmmc_hostname(mmc));\n\n\treturn -EAGAIN;\n}\n\n#define DRIVER_NAME \"sdhci_msm\"\n#define SDHCI_MSM_DUMP(f, x...) \\\n\tpr_err(\"%s: \" DRIVER_NAME \": \" f, mmc_hostname(host->mmc), ## x)\n\nstatic void sdhci_msm_dump_vendor_regs(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_msm_offset *msm_offset = msm_host->offset;\n\n\tSDHCI_MSM_DUMP(\"----------- VENDOR REGISTER DUMP -----------\\n\");\n\n\tSDHCI_MSM_DUMP(\n\t\t\t\"DLL sts: 0x%08x | DLL cfg:  0x%08x | DLL cfg2: 0x%08x\\n\",\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_dll_status),\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_dll_config),\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_dll_config_2));\n\tSDHCI_MSM_DUMP(\n\t\t\t\"DLL cfg3: 0x%08x | DLL usr ctl:  0x%08x | DDR cfg: 0x%08x\\n\",\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_dll_config_3),\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_dll_usr_ctl),\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_ddr_config));\n\tSDHCI_MSM_DUMP(\n\t\t\t\"Vndr func: 0x%08x | Vndr func2 : 0x%08x Vndr func3: 0x%08x\\n\",\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_vendor_spec),\n\t\treadl_relaxed(host->ioaddr +\n\t\t\tmsm_offset->core_vendor_spec_func2),\n\t\treadl_relaxed(host->ioaddr + msm_offset->core_vendor_spec3));\n}\n\nstatic const struct sdhci_msm_variant_ops mci_var_ops = {\n\t.msm_readl_relaxed = sdhci_msm_mci_variant_readl_relaxed,\n\t.msm_writel_relaxed = sdhci_msm_mci_variant_writel_relaxed,\n};\n\nstatic const struct sdhci_msm_variant_ops v5_var_ops = {\n\t.msm_readl_relaxed = sdhci_msm_v5_variant_readl_relaxed,\n\t.msm_writel_relaxed = sdhci_msm_v5_variant_writel_relaxed,\n};\n\nstatic const struct sdhci_msm_variant_info sdhci_msm_mci_var = {\n\t.var_ops = &mci_var_ops,\n\t.offset = &sdhci_msm_mci_offset,\n};\n\nstatic const struct sdhci_msm_variant_info sdhci_msm_v5_var = {\n\t.mci_removed = true,\n\t.var_ops = &v5_var_ops,\n\t.offset = &sdhci_msm_v5_offset,\n};\n\nstatic const struct sdhci_msm_variant_info sdm845_sdhci_var = {\n\t.mci_removed = true,\n\t.restore_dll_config = true,\n\t.var_ops = &v5_var_ops,\n\t.offset = &sdhci_msm_v5_offset,\n};\n\nstatic const struct of_device_id sdhci_msm_dt_match[] = {\n\t \n\t{.compatible = \"qcom,sdhci-msm-v4\", .data = &sdhci_msm_mci_var},\n\t{.compatible = \"qcom,sdhci-msm-v5\", .data = &sdhci_msm_v5_var},\n\t{.compatible = \"qcom,sdm670-sdhci\", .data = &sdm845_sdhci_var},\n\t{.compatible = \"qcom,sdm845-sdhci\", .data = &sdm845_sdhci_var},\n\t{.compatible = \"qcom,sc7180-sdhci\", .data = &sdm845_sdhci_var},\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, sdhci_msm_dt_match);\n\nstatic const struct sdhci_ops sdhci_msm_ops = {\n\t.reset = sdhci_and_cqhci_reset,\n\t.set_clock = sdhci_msm_set_clock,\n\t.get_min_clock = sdhci_msm_get_min_clock,\n\t.get_max_clock = sdhci_msm_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.set_uhs_signaling = sdhci_msm_set_uhs_signaling,\n\t.write_w = sdhci_msm_writew,\n\t.write_b = sdhci_msm_writeb,\n\t.irq\t= sdhci_msm_cqe_irq,\n\t.dump_vendor_regs = sdhci_msm_dump_vendor_regs,\n\t.set_power = sdhci_set_power_noreg,\n\t.set_timeout = sdhci_msm_set_timeout,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_msm_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\t  SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12,\n\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops = &sdhci_msm_ops,\n};\n\nstatic inline void sdhci_msm_get_of_property(struct platform_device *pdev,\n\t\tstruct sdhci_host *host)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (of_property_read_u32(node, \"qcom,ddr-config\",\n\t\t\t\t&msm_host->ddr_config))\n\t\tmsm_host->ddr_config = DDR_CONFIG_POR_VAL;\n\n\tof_property_read_u32(node, \"qcom,dll-config\", &msm_host->dll_config);\n\n\tif (of_device_is_compatible(node, \"qcom,msm8916-sdhci\"))\n\t\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_64_BIT_DMA;\n}\n\nstatic int sdhci_msm_gcc_reset(struct device *dev, struct sdhci_host *host)\n{\n\tstruct reset_control *reset;\n\tint ret = 0;\n\n\treset = reset_control_get_optional_exclusive(dev, NULL);\n\tif (IS_ERR(reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(reset),\n\t\t\t\t\"unable to acquire core_reset\\n\");\n\n\tif (!reset)\n\t\treturn ret;\n\n\tret = reset_control_assert(reset);\n\tif (ret) {\n\t\treset_control_put(reset);\n\t\treturn dev_err_probe(dev, ret, \"core_reset assert failed\\n\");\n\t}\n\n\t \n\tusleep_range(200, 210);\n\n\tret = reset_control_deassert(reset);\n\tif (ret) {\n\t\treset_control_put(reset);\n\t\treturn dev_err_probe(dev, ret, \"core_reset deassert failed\\n\");\n\t}\n\n\tusleep_range(200, 210);\n\treset_control_put(reset);\n\n\treturn ret;\n}\n\nstatic int sdhci_msm_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_msm_host *msm_host;\n\tstruct clk *clk;\n\tint ret;\n\tu16 host_version, core_minor;\n\tu32 core_version, config;\n\tu8 core_major;\n\tconst struct sdhci_msm_offset *msm_offset;\n\tconst struct sdhci_msm_variant_info *var_info;\n\tstruct device_node *node = pdev->dev.of_node;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_msm_pdata, sizeof(*msm_host));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\thost->sdma_boundary = 0;\n\tpltfm_host = sdhci_priv(host);\n\tmsm_host = sdhci_pltfm_priv(pltfm_host);\n\tmsm_host->mmc = host->mmc;\n\tmsm_host->pdev = pdev;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto pltfm_free;\n\n\t \n\tvar_info = of_device_get_match_data(&pdev->dev);\n\n\tmsm_host->mci_removed = var_info->mci_removed;\n\tmsm_host->restore_dll_config = var_info->restore_dll_config;\n\tmsm_host->var_ops = var_info->var_ops;\n\tmsm_host->offset = var_info->offset;\n\n\tmsm_offset = msm_host->offset;\n\n\tsdhci_get_of_property(pdev);\n\tsdhci_msm_get_of_property(pdev, host);\n\n\tmsm_host->saved_tuning_phase = INVALID_TUNING_PHASE;\n\n\tret = sdhci_msm_gcc_reset(&pdev->dev, host);\n\tif (ret)\n\t\tgoto pltfm_free;\n\n\t \n\tmsm_host->bus_clk = devm_clk_get(&pdev->dev, \"bus\");\n\tif (!IS_ERR(msm_host->bus_clk)) {\n\t\t \n\t\tret = clk_set_rate(msm_host->bus_clk, INT_MAX);\n\t\tif (ret)\n\t\t\tgoto pltfm_free;\n\t\tret = clk_prepare_enable(msm_host->bus_clk);\n\t\tif (ret)\n\t\t\tgoto pltfm_free;\n\t}\n\n\t \n\tclk = devm_clk_get(&pdev->dev, \"iface\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err(&pdev->dev, \"Peripheral clk setup failed (%d)\\n\", ret);\n\t\tgoto bus_clk_disable;\n\t}\n\tmsm_host->bulk_clks[1].clk = clk;\n\n\t \n\tclk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tdev_err(&pdev->dev, \"SDC MMC clk setup failed (%d)\\n\", ret);\n\t\tgoto bus_clk_disable;\n\t}\n\tmsm_host->bulk_clks[0].clk = clk;\n\n\t  \n\tret = dev_pm_opp_of_find_icc_paths(&pdev->dev, NULL);\n\tif (ret)\n\t\tgoto bus_clk_disable;\n\n\tret = devm_pm_opp_set_clkname(&pdev->dev, \"core\");\n\tif (ret)\n\t\tgoto bus_clk_disable;\n\n\t \n\tret = devm_pm_opp_of_add_table(&pdev->dev);\n\tif (ret && ret != -ENODEV) {\n\t\tdev_err(&pdev->dev, \"Invalid OPP table in Device tree\\n\");\n\t\tgoto bus_clk_disable;\n\t}\n\n\t \n\tret = dev_pm_opp_set_rate(&pdev->dev, INT_MAX);\n\tif (ret)\n\t\tdev_warn(&pdev->dev, \"core clock boost failed\\n\");\n\n\tclk = devm_clk_get(&pdev->dev, \"cal\");\n\tif (IS_ERR(clk))\n\t\tclk = NULL;\n\tmsm_host->bulk_clks[2].clk = clk;\n\n\tclk = devm_clk_get(&pdev->dev, \"sleep\");\n\tif (IS_ERR(clk))\n\t\tclk = NULL;\n\tmsm_host->bulk_clks[3].clk = clk;\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(msm_host->bulk_clks),\n\t\t\t\t      msm_host->bulk_clks);\n\tif (ret)\n\t\tgoto bus_clk_disable;\n\n\t \n\tmsm_host->xo_clk = devm_clk_get(&pdev->dev, \"xo\");\n\tif (IS_ERR(msm_host->xo_clk)) {\n\t\tret = PTR_ERR(msm_host->xo_clk);\n\t\tdev_warn(&pdev->dev, \"TCXO clk not present (%d)\\n\", ret);\n\t}\n\n\tif (!msm_host->mci_removed) {\n\t\tmsm_host->core_mem = devm_platform_ioremap_resource(pdev, 1);\n\t\tif (IS_ERR(msm_host->core_mem)) {\n\t\t\tret = PTR_ERR(msm_host->core_mem);\n\t\t\tgoto clk_disable;\n\t\t}\n\t}\n\n\t \n\twritel_relaxed(CORE_VENDOR_SPEC_POR_VAL,\n\t\t\thost->ioaddr + msm_offset->core_vendor_spec);\n\n\tif (!msm_host->mci_removed) {\n\t\t \n\t\tmsm_host_writel(msm_host, HC_MODE_EN, host,\n\t\t\t\tmsm_offset->core_hc_mode);\n\t\tconfig = msm_host_readl(msm_host, host,\n\t\t\t\tmsm_offset->core_hc_mode);\n\t\tconfig |= FF_CLK_SW_RST_DIS;\n\t\tmsm_host_writel(msm_host, config, host,\n\t\t\t\tmsm_offset->core_hc_mode);\n\t}\n\n\thost_version = readw_relaxed((host->ioaddr + SDHCI_HOST_VERSION));\n\tdev_dbg(&pdev->dev, \"Host Version: 0x%x Vendor Version 0x%x\\n\",\n\t\thost_version, ((host_version & SDHCI_VENDOR_VER_MASK) >>\n\t\t\t       SDHCI_VENDOR_VER_SHIFT));\n\n\tcore_version = msm_host_readl(msm_host, host,\n\t\t\tmsm_offset->core_mci_version);\n\tcore_major = (core_version & CORE_VERSION_MAJOR_MASK) >>\n\t\t      CORE_VERSION_MAJOR_SHIFT;\n\tcore_minor = core_version & CORE_VERSION_MINOR_MASK;\n\tdev_dbg(&pdev->dev, \"MCI Version: 0x%08x, major: 0x%04x, minor: 0x%02x\\n\",\n\t\tcore_version, core_major, core_minor);\n\n\tif (core_major == 1 && core_minor >= 0x42)\n\t\tmsm_host->use_14lpp_dll_reset = true;\n\n\t \n\tif (core_major == 1 && core_minor < 0x34)\n\t\tmsm_host->use_cdclp533 = true;\n\n\t \n\tif (core_major >= 1 && core_minor != 0x11 && core_minor != 0x12) {\n\t\tconfig = readl_relaxed(host->ioaddr + SDHCI_CAPABILITIES);\n\t\tconfig |= SDHCI_CAN_VDD_300 | SDHCI_CAN_DO_8BIT;\n\t\twritel_relaxed(config, host->ioaddr +\n\t\t\t\tmsm_offset->core_vendor_spec_capabilities0);\n\t}\n\n\tif (core_major == 1 && core_minor >= 0x49)\n\t\tmsm_host->updated_ddr_cfg = true;\n\n\tif (core_major == 1 && core_minor >= 0x71)\n\t\tmsm_host->uses_tassadar_dll = true;\n\n\tret = sdhci_msm_register_vreg(msm_host);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\t \n\tsdhci_msm_handle_pwr_irq(host, 0);\n\n\t \n\tmb();\n\n\t \n\tmsm_host->pwr_irq = platform_get_irq_byname(pdev, \"pwr_irq\");\n\tif (msm_host->pwr_irq < 0) {\n\t\tret = msm_host->pwr_irq;\n\t\tgoto clk_disable;\n\t}\n\n\tsdhci_msm_init_pwr_irq_wait(msm_host);\n\t \n\tmsm_host_writel(msm_host, INT_MASK, host,\n\t\tmsm_offset->core_pwrctl_mask);\n\n\tret = devm_request_threaded_irq(&pdev->dev, msm_host->pwr_irq, NULL,\n\t\t\t\t\tsdhci_msm_pwr_irq, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(&pdev->dev), host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Request IRQ failed (%d)\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\tmsm_host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_NEED_RSP_BUSY;\n\n\t \n\thost->max_timeout_count = 0xF;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev,\n\t\t\t\t\t MSM_MMC_AUTOSUSPEND_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\tsdhci_msm_start_signal_voltage_switch;\n\thost->mmc_host_ops.execute_tuning = sdhci_msm_execute_tuning;\n\tif (of_property_read_bool(node, \"supports-cqe\"))\n\t\tret = sdhci_msm_cqe_add_host(host, pdev);\n\telse\n\t\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto pm_runtime_disable;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\npm_runtime_disable:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\nclk_disable:\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(msm_host->bulk_clks),\n\t\t\t\t   msm_host->bulk_clks);\nbus_clk_disable:\n\tif (!IS_ERR(msm_host->bus_clk))\n\t\tclk_disable_unprepare(msm_host->bus_clk);\npltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_msm_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tint dead = (readl_relaxed(host->ioaddr + SDHCI_INT_STATUS) ==\n\t\t    0xffffffff);\n\n\tsdhci_remove_host(host, dead);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(msm_host->bulk_clks),\n\t\t\t\t   msm_host->bulk_clks);\n\tif (!IS_ERR(msm_host->bus_clk))\n\t\tclk_disable_unprepare(msm_host->bus_clk);\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic __maybe_unused int sdhci_msm_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\n\t \n\tdev_pm_opp_set_rate(dev, 0);\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(msm_host->bulk_clks),\n\t\t\t\t   msm_host->bulk_clks);\n\n\treturn sdhci_msm_ice_suspend(msm_host);\n}\n\nstatic __maybe_unused int sdhci_msm_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_msm_host *msm_host = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(msm_host->bulk_clks),\n\t\t\t\t       msm_host->bulk_clks);\n\tif (ret)\n\t\treturn ret;\n\t \n\tif (msm_host->restore_dll_config && msm_host->clk_rate) {\n\t\tret = sdhci_msm_restore_sdr_dll_config(host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_pm_opp_set_rate(dev, msm_host->clk_rate);\n\n\treturn sdhci_msm_ice_resume(msm_host);\n}\n\nstatic const struct dev_pm_ops sdhci_msm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_msm_runtime_suspend,\n\t\t\t   sdhci_msm_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver sdhci_msm_driver = {\n\t.probe = sdhci_msm_probe,\n\t.remove_new = sdhci_msm_remove,\n\t.driver = {\n\t\t   .name = \"sdhci_msm\",\n\t\t   .of_match_table = sdhci_msm_dt_match,\n\t\t   .pm = &sdhci_msm_pm_ops,\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_platform_driver(sdhci_msm_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Secure Digital Host Controller Interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}