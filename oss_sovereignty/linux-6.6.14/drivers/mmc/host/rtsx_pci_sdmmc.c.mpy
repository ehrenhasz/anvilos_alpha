{
  "module_name": "rtsx_pci_sdmmc.c",
  "hash_id": "ebf75cb31a14b04fd6b8a5655172d8e73a4c3c7057feb0e9eb9cb104443be26d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/rtsx_pci_sdmmc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/highmem.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/card.h>\n#include <linux/rtsx_pci.h>\n#include <asm/unaligned.h>\n#include <linux/pm_runtime.h>\n\nstruct realtek_pci_sdmmc {\n\tstruct platform_device\t*pdev;\n\tstruct rtsx_pcr\t\t*pcr;\n\tstruct mmc_host\t\t*mmc;\n\tstruct mmc_request\t*mrq;\n#define SDMMC_WORKQ_NAME\t\"rtsx_pci_sdmmc_workq\"\n\n\tstruct work_struct\twork;\n\tstruct mutex\t\thost_mutex;\n\n\tu8\t\t\tssc_depth;\n\tunsigned int\t\tclock;\n\tbool\t\t\tvpclk;\n\tbool\t\t\tdouble_clk;\n\tbool\t\t\teject;\n\tbool\t\t\tinitial_mode;\n\tint\t\t\tprev_power_state;\n\tint\t\t\tsg_count;\n\ts32\t\t\tcookie;\n\tint\t\t\tcookie_sg_count;\n\tbool\t\t\tusing_cookie;\n};\n\nstatic int sdmmc_init_sd_express(struct mmc_host *mmc, struct mmc_ios *ios);\n\nstatic inline struct device *sdmmc_dev(struct realtek_pci_sdmmc *host)\n{\n\treturn &(host->pdev->dev);\n}\n\nstatic inline void sd_clear_error(struct realtek_pci_sdmmc *host)\n{\n\trtsx_pci_write_register(host->pcr, CARD_STOP,\n\t\t\tSD_STOP | SD_CLR_ERR, SD_STOP | SD_CLR_ERR);\n}\n\n#ifdef DEBUG\nstatic void dump_reg_range(struct realtek_pci_sdmmc *host, u16 start, u16 end)\n{\n\tu16 len = end - start + 1;\n\tint i;\n\tu8 data[8];\n\n\tfor (i = 0; i < len; i += 8) {\n\t\tint j;\n\t\tint n = min(8, len - i);\n\n\t\tmemset(&data, 0, sizeof(data));\n\t\tfor (j = 0; j < n; j++)\n\t\t\trtsx_pci_read_register(host->pcr, start + i + j,\n\t\t\t\tdata + j);\n\t\tdev_dbg(sdmmc_dev(host), \"0x%04X(%d): %8ph\\n\",\n\t\t\tstart + i, n, data);\n\t}\n}\n\nstatic void sd_print_debug_regs(struct realtek_pci_sdmmc *host)\n{\n\tdump_reg_range(host, 0xFDA0, 0xFDB3);\n\tdump_reg_range(host, 0xFD52, 0xFD69);\n}\n#else\n#define sd_print_debug_regs(host)\n#endif  \n\nstatic inline int sd_get_cd_int(struct realtek_pci_sdmmc *host)\n{\n\treturn rtsx_pci_readl(host->pcr, RTSX_BIPR) & SD_EXIST;\n}\n\nstatic void sd_cmd_set_sd_cmd(struct rtsx_pcr *pcr, struct mmc_command *cmd)\n{\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CMD0, 0xFF,\n\t\tSD_CMD_START | cmd->opcode);\n\trtsx_pci_write_be32(pcr, SD_CMD1, cmd->arg);\n}\n\nstatic void sd_cmd_set_data_len(struct rtsx_pcr *pcr, u16 blocks, u16 blksz)\n{\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_BLOCK_CNT_L, 0xFF, blocks);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_BLOCK_CNT_H, 0xFF, blocks >> 8);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_BYTE_CNT_L, 0xFF, blksz);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_BYTE_CNT_H, 0xFF, blksz >> 8);\n}\n\nstatic int sd_response_type(struct mmc_command *cmd)\n{\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\treturn SD_RSP_TYPE_R0;\n\tcase MMC_RSP_R1:\n\t\treturn SD_RSP_TYPE_R1;\n\tcase MMC_RSP_R1_NO_CRC:\n\t\treturn SD_RSP_TYPE_R1 | SD_NO_CHECK_CRC7;\n\tcase MMC_RSP_R1B:\n\t\treturn SD_RSP_TYPE_R1b;\n\tcase MMC_RSP_R2:\n\t\treturn SD_RSP_TYPE_R2;\n\tcase MMC_RSP_R3:\n\t\treturn SD_RSP_TYPE_R3;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int sd_status_index(int resp_type)\n{\n\tif (resp_type == SD_RSP_TYPE_R0)\n\t\treturn 0;\n\telse if (resp_type == SD_RSP_TYPE_R2)\n\t\treturn 16;\n\n\treturn 5;\n}\n \nstatic int sd_pre_dma_transfer(struct realtek_pci_sdmmc *host,\n\t\tstruct mmc_data *data, bool pre)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint read = data->flags & MMC_DATA_READ;\n\tint count = 0;\n\tint using_cookie = 0;\n\n\tif (!pre && data->host_cookie && data->host_cookie != host->cookie) {\n\t\tdev_err(sdmmc_dev(host),\n\t\t\t\"error: data->host_cookie = %d, host->cookie = %d\\n\",\n\t\t\tdata->host_cookie, host->cookie);\n\t\tdata->host_cookie = 0;\n\t}\n\n\tif (pre || data->host_cookie != host->cookie) {\n\t\tcount = rtsx_pci_dma_map_sg(pcr, data->sg, data->sg_len, read);\n\t} else {\n\t\tcount = host->cookie_sg_count;\n\t\tusing_cookie = 1;\n\t}\n\n\tif (pre) {\n\t\thost->cookie_sg_count = count;\n\t\tif (++host->cookie < 0)\n\t\t\thost->cookie = 1;\n\t\tdata->host_cookie = host->cookie;\n\t} else {\n\t\thost->sg_count = count;\n\t}\n\n\treturn using_cookie;\n}\n\nstatic void sdmmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (data->host_cookie) {\n\t\tdev_err(sdmmc_dev(host),\n\t\t\t\"error: reset data->host_cookie = %d\\n\",\n\t\t\tdata->host_cookie);\n\t\tdata->host_cookie = 0;\n\t}\n\n\tsd_pre_dma_transfer(host, data, true);\n\tdev_dbg(sdmmc_dev(host), \"pre dma sg: %d\\n\", host->cookie_sg_count);\n}\n\nstatic void sdmmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\tint err)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tstruct mmc_data *data = mrq->data;\n\tint read = data->flags & MMC_DATA_READ;\n\n\trtsx_pci_dma_unmap_sg(pcr, data->sg, data->sg_len, read);\n\tdata->host_cookie = 0;\n}\n\nstatic void sd_send_cmd_get_rsp(struct realtek_pci_sdmmc *host,\n\t\tstruct mmc_command *cmd)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tu8 cmd_idx = (u8)cmd->opcode;\n\tu32 arg = cmd->arg;\n\tint err = 0;\n\tint timeout = 100;\n\tint i;\n\tu8 *ptr;\n\tint rsp_type;\n\tint stat_idx;\n\tbool clock_toggled = false;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t\t__func__, cmd_idx, arg);\n\n\trsp_type = sd_response_type(cmd);\n\tif (rsp_type < 0)\n\t\tgoto out;\n\n\tstat_idx = sd_status_index(rsp_type);\n\n\tif (rsp_type == SD_RSP_TYPE_R1b)\n\t\ttimeout = cmd->busy_timeout ? cmd->busy_timeout : 3000;\n\n\tif (cmd->opcode == SD_SWITCH_VOLTAGE) {\n\t\terr = rtsx_pci_write_register(pcr, SD_BUS_STAT,\n\t\t\t\t0xFF, SD_CLK_TOGGLE_EN);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\n\t\tclock_toggled = true;\n\t}\n\n\trtsx_pci_init_cmd(pcr);\n\tsd_cmd_set_sd_cmd(pcr, cmd);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG2, 0xFF, rsp_type);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, PINGPONG_BUFFER);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_TRANSFER,\n\t\t\t0xFF, SD_TM_CMD_RSP | SD_TRANSFER_START);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t     SD_TRANSFER_END | SD_STAT_IDLE,\n\t\t     SD_TRANSFER_END | SD_STAT_IDLE);\n\n\tif (rsp_type == SD_RSP_TYPE_R2) {\n\t\t \n\t\tfor (i = PPBUF_BASE2; i < PPBUF_BASE2 + 16; i++)\n\t\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, (u16)i, 0, 0);\n\t} else if (rsp_type != SD_RSP_TYPE_R0) {\n\t\t \n\t\tfor (i = SD_CMD0; i <= SD_CMD4; i++)\n\t\t\trtsx_pci_add_cmd(pcr, READ_REG_CMD, (u16)i, 0, 0);\n\t}\n\n\trtsx_pci_add_cmd(pcr, READ_REG_CMD, SD_STAT1, 0, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, timeout);\n\tif (err < 0) {\n\t\tsd_print_debug_regs(host);\n\t\tsd_clear_error(host);\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_pci_send_cmd error (err = %d)\\n\", err);\n\t\tgoto out;\n\t}\n\n\tif (rsp_type == SD_RSP_TYPE_R0) {\n\t\terr = 0;\n\t\tgoto out;\n\t}\n\n\t \n\tptr = rtsx_pci_get_cmd_data(pcr) + 1;\n\n\t \n\tif ((ptr[0] & 0xC0) != 0) {\n\t\terr = -EILSEQ;\n\t\tdev_dbg(sdmmc_dev(host), \"Invalid response bit\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (!(rsp_type & SD_NO_CHECK_CRC7)) {\n\t\tif (ptr[stat_idx] & SD_CRC7_ERR) {\n\t\t\terr = -EILSEQ;\n\t\t\tdev_dbg(sdmmc_dev(host), \"CRC7 error\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (rsp_type == SD_RSP_TYPE_R2) {\n\t\t \n\t\tptr[16] = 1;\n\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tcmd->resp[i] = get_unaligned_be32(ptr + 1 + i * 4);\n\t\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[%d] = 0x%08x\\n\",\n\t\t\t\t\ti, cmd->resp[i]);\n\t\t}\n\t} else {\n\t\tcmd->resp[0] = get_unaligned_be32(ptr + 1);\n\t\tdev_dbg(sdmmc_dev(host), \"cmd->resp[0] = 0x%08x\\n\",\n\t\t\t\tcmd->resp[0]);\n\t}\n\nout:\n\tcmd->error = err;\n\n\tif (err && clock_toggled)\n\t\trtsx_pci_write_register(pcr, SD_BUS_STAT,\n\t\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP, 0);\n}\n\nstatic int sd_read_data(struct realtek_pci_sdmmc *host, struct mmc_command *cmd,\n\tu16 byte_cnt, u8 *buf, int buf_len, int timeout)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\tu8 trans_mode;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t__func__, cmd->opcode, cmd->arg);\n\n\tif (!buf)\n\t\tbuf_len = 0;\n\n\tif (cmd->opcode == MMC_SEND_TUNING_BLOCK)\n\t\ttrans_mode = SD_TM_AUTO_TUNING;\n\telse\n\t\ttrans_mode = SD_TM_NORMAL_READ;\n\n\trtsx_pci_init_cmd(pcr);\n\tsd_cmd_set_sd_cmd(pcr, cmd);\n\tsd_cmd_set_data_len(pcr, 1, byte_cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG2, 0xFF,\n\t\t\tSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\t\tSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_6);\n\tif (trans_mode != SD_TM_AUTO_TUNING)\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\tCARD_DATA_SOURCE, 0x01, PINGPONG_BUFFER);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_TRANSFER,\n\t\t\t0xFF, trans_mode | SD_TRANSFER_START);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\n\terr = rtsx_pci_send_cmd(pcr, timeout);\n\tif (err < 0) {\n\t\tsd_print_debug_regs(host);\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_pci_send_cmd fail (err = %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (buf && buf_len) {\n\t\terr = rtsx_pci_read_ppbuf(pcr, buf, buf_len);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_pci_read_ppbuf fail (err = %d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sd_write_data(struct realtek_pci_sdmmc *host,\n\tstruct mmc_command *cmd, u16 byte_cnt, u8 *buf, int buf_len,\n\tint timeout)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t__func__, cmd->opcode, cmd->arg);\n\n\tif (!buf)\n\t\tbuf_len = 0;\n\n\tsd_send_cmd_get_rsp(host, cmd);\n\tif (cmd->error)\n\t\treturn cmd->error;\n\n\tif (buf && buf_len) {\n\t\terr = rtsx_pci_write_ppbuf(pcr, buf, buf_len);\n\t\tif (err < 0) {\n\t\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\t\"rtsx_pci_write_ppbuf fail (err = %d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\trtsx_pci_init_cmd(pcr);\n\tsd_cmd_set_data_len(pcr, 1, byte_cnt);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG2, 0xFF,\n\t\tSD_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\tSD_NO_WAIT_BUSY_END | SD_CHECK_CRC7 | SD_RSP_LEN_0);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\n\t\t\tSD_TRANSFER_START | SD_TM_AUTO_WRITE_3);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\n\terr = rtsx_pci_send_cmd(pcr, timeout);\n\tif (err < 0) {\n\t\tsd_print_debug_regs(host);\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"rtsx_pci_send_cmd fail (err = %d)\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int sd_read_long_data(struct realtek_pci_sdmmc *host,\n\tstruct mmc_request *mrq)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct mmc_card *card = mmc->card;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tint uhs = mmc_card_uhs(card);\n\tu8 cfg2 = 0;\n\tint err;\n\tint resp_type;\n\tsize_t data_len = data->blksz * data->blocks;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t__func__, cmd->opcode, cmd->arg);\n\n\tresp_type = sd_response_type(cmd);\n\tif (resp_type < 0)\n\t\treturn resp_type;\n\n\tif (!uhs)\n\t\tcfg2 |= SD_NO_CHECK_WAIT_CRC_TO;\n\n\trtsx_pci_init_cmd(pcr);\n\tsd_cmd_set_sd_cmd(pcr, cmd);\n\tsd_cmd_set_data_len(pcr, data->blocks, data->blksz);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\n\t\t\tDMA_DONE_INT, DMA_DONE_INT);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC3,\n\t\t0xFF, (u8)(data_len >> 24));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC2,\n\t\t0xFF, (u8)(data_len >> 16));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC1,\n\t\t0xFF, (u8)(data_len >> 8));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC0, 0xFF, (u8)data_len);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMACTL,\n\t\t0x03 | DMA_PACK_SIZE_MASK,\n\t\tDMA_DIR_FROM_CARD | DMA_EN | DMA_512);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, RING_BUFFER);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG2, 0xFF, cfg2 | resp_type);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\n\t\t\tSD_TRANSFER_START | SD_TM_AUTO_READ_2);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\trtsx_pci_send_cmd_no_wait(pcr);\n\n\terr = rtsx_pci_dma_transfer(pcr, data->sg, host->sg_count, 1, 10000);\n\tif (err < 0) {\n\t\tsd_print_debug_regs(host);\n\t\tsd_clear_error(host);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int sd_write_long_data(struct realtek_pci_sdmmc *host,\n\tstruct mmc_request *mrq)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct mmc_card *card = mmc->card;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tint uhs = mmc_card_uhs(card);\n\tu8 cfg2;\n\tint err;\n\tsize_t data_len = data->blksz * data->blocks;\n\n\tsd_send_cmd_get_rsp(host, cmd);\n\tif (cmd->error)\n\t\treturn cmd->error;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: SD/MMC CMD %d, arg = 0x%08x\\n\",\n\t\t__func__, cmd->opcode, cmd->arg);\n\n\tcfg2 = SD_NO_CALCULATE_CRC7 | SD_CHECK_CRC16 |\n\t\tSD_NO_WAIT_BUSY_END | SD_NO_CHECK_CRC7 | SD_RSP_LEN_0;\n\n\tif (!uhs)\n\t\tcfg2 |= SD_NO_CHECK_WAIT_CRC_TO;\n\n\trtsx_pci_init_cmd(pcr);\n\tsd_cmd_set_data_len(pcr, data->blocks, data->blksz);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, IRQSTAT0,\n\t\t\tDMA_DONE_INT, DMA_DONE_INT);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC3,\n\t\t0xFF, (u8)(data_len >> 24));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC2,\n\t\t0xFF, (u8)(data_len >> 16));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC1,\n\t\t0xFF, (u8)(data_len >> 8));\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMATC0, 0xFF, (u8)data_len);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, DMACTL,\n\t\t0x03 | DMA_PACK_SIZE_MASK,\n\t\tDMA_DIR_TO_CARD | DMA_EN | DMA_512);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_DATA_SOURCE,\n\t\t\t0x01, RING_BUFFER);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG2, 0xFF, cfg2);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_TRANSFER, 0xFF,\n\t\t\tSD_TRANSFER_START | SD_TM_AUTO_WRITE_3);\n\trtsx_pci_add_cmd(pcr, CHECK_REG_CMD, SD_TRANSFER,\n\t\t\tSD_TRANSFER_END, SD_TRANSFER_END);\n\trtsx_pci_send_cmd_no_wait(pcr);\n\terr = rtsx_pci_dma_transfer(pcr, data->sg, host->sg_count, 0, 10000);\n\tif (err < 0) {\n\t\tsd_clear_error(host);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void sd_enable_initial_mode(struct realtek_pci_sdmmc *host)\n{\n\trtsx_pci_write_register(host->pcr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_128);\n}\n\nstatic inline void sd_disable_initial_mode(struct realtek_pci_sdmmc *host)\n{\n\trtsx_pci_write_register(host->pcr, SD_CFG1,\n\t\t\tSD_CLK_DIVIDE_MASK, SD_CLK_DIVIDE_0);\n}\n\nstatic int sd_rw_multi(struct realtek_pci_sdmmc *host, struct mmc_request *mrq)\n{\n\tstruct mmc_data *data = mrq->data;\n\tint err;\n\n\tif (host->sg_count < 0) {\n\t\tdata->error = host->sg_count;\n\t\tdev_dbg(sdmmc_dev(host), \"%s: sg_count = %d is invalid\\n\",\n\t\t\t__func__, host->sg_count);\n\t\treturn data->error;\n\t}\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tif (host->initial_mode)\n\t\t\tsd_disable_initial_mode(host);\n\n\t\terr = sd_read_long_data(host, mrq);\n\n\t\tif (host->initial_mode)\n\t\t\tsd_enable_initial_mode(host);\n\n\t\treturn err;\n\t}\n\n\treturn sd_write_long_data(host, mrq);\n}\n\nstatic void sd_normal_rw(struct realtek_pci_sdmmc *host,\n\t\tstruct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tu8 *buf;\n\n\tbuf = kzalloc(data->blksz, GFP_NOIO);\n\tif (!buf) {\n\t\tcmd->error = -ENOMEM;\n\t\treturn;\n\t}\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tif (host->initial_mode)\n\t\t\tsd_disable_initial_mode(host);\n\n\t\tcmd->error = sd_read_data(host, cmd, (u16)data->blksz, buf,\n\t\t\t\tdata->blksz, 200);\n\n\t\tif (host->initial_mode)\n\t\t\tsd_enable_initial_mode(host);\n\n\t\tsg_copy_from_buffer(data->sg, data->sg_len, buf, data->blksz);\n\t} else {\n\t\tsg_copy_to_buffer(data->sg, data->sg_len, buf, data->blksz);\n\n\t\tcmd->error = sd_write_data(host, cmd, (u16)data->blksz, buf,\n\t\t\t\tdata->blksz, 200);\n\t}\n\n\tkfree(buf);\n}\n\nstatic int sd_change_phase(struct realtek_pci_sdmmc *host,\n\t\tu8 sample_point, bool rx)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tu16 SD_VP_CTL = 0;\n\tdev_dbg(sdmmc_dev(host), \"%s(%s): sample_point = %d\\n\",\n\t\t\t__func__, rx ? \"RX\" : \"TX\", sample_point);\n\n\trtsx_pci_write_register(pcr, CLK_CTL, CHANGE_CLK, CHANGE_CLK);\n\tif (rx) {\n\t\tSD_VP_CTL = SD_VPRX_CTL;\n\t\trtsx_pci_write_register(pcr, SD_VPRX_CTL,\n\t\t\tPHASE_SELECT_MASK, sample_point);\n\t} else {\n\t\tSD_VP_CTL = SD_VPTX_CTL;\n\t\trtsx_pci_write_register(pcr, SD_VPTX_CTL,\n\t\t\tPHASE_SELECT_MASK, sample_point);\n\t}\n\trtsx_pci_write_register(pcr, SD_VP_CTL, PHASE_NOT_RESET, 0);\n\trtsx_pci_write_register(pcr, SD_VP_CTL, PHASE_NOT_RESET,\n\t\t\t\tPHASE_NOT_RESET);\n\trtsx_pci_write_register(pcr, CLK_CTL, CHANGE_CLK, 0);\n\trtsx_pci_write_register(pcr, SD_CFG1, SD_ASYNC_FIFO_NOT_RST, 0);\n\n\treturn 0;\n}\n\nstatic inline u32 test_phase_bit(u32 phase_map, unsigned int bit)\n{\n\tbit %= RTSX_PHASE_MAX;\n\treturn phase_map & (1 << bit);\n}\n\nstatic int sd_get_phase_len(u32 phase_map, unsigned int start_bit)\n{\n\tint i;\n\n\tfor (i = 0; i < RTSX_PHASE_MAX; i++) {\n\t\tif (test_phase_bit(phase_map, start_bit + i) == 0)\n\t\t\treturn i;\n\t}\n\treturn RTSX_PHASE_MAX;\n}\n\nstatic u8 sd_search_final_phase(struct realtek_pci_sdmmc *host, u32 phase_map)\n{\n\tint start = 0, len = 0;\n\tint start_final = 0, len_final = 0;\n\tu8 final_phase = 0xFF;\n\n\tif (phase_map == 0) {\n\t\tdev_err(sdmmc_dev(host), \"phase error: [map:%x]\\n\", phase_map);\n\t\treturn final_phase;\n\t}\n\n\twhile (start < RTSX_PHASE_MAX) {\n\t\tlen = sd_get_phase_len(phase_map, start);\n\t\tif (len_final < len) {\n\t\t\tstart_final = start;\n\t\t\tlen_final = len;\n\t\t}\n\t\tstart += len ? len : 1;\n\t}\n\n\tfinal_phase = (start_final + len_final / 2) % RTSX_PHASE_MAX;\n\tdev_dbg(sdmmc_dev(host), \"phase: [map:%x] [maxlen:%d] [final:%d]\\n\",\n\t\tphase_map, len_final, final_phase);\n\n\treturn final_phase;\n}\n\nstatic void sd_wait_data_idle(struct realtek_pci_sdmmc *host)\n{\n\tint i;\n\tu8 val = 0;\n\n\tfor (i = 0; i < 100; i++) {\n\t\trtsx_pci_read_register(host->pcr, SD_DATA_STATE, &val);\n\t\tif (val & SD_DATA_IDLE)\n\t\t\treturn;\n\n\t\tudelay(100);\n\t}\n}\n\nstatic int sd_tuning_rx_cmd(struct realtek_pci_sdmmc *host,\n\t\tu8 opcode, u8 sample_point)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\tsd_change_phase(host, sample_point, true);\n\n\trtsx_pci_write_register(pcr, SD_CFG3, SD_RSP_80CLK_TIMEOUT_EN,\n\t\tSD_RSP_80CLK_TIMEOUT_EN);\n\n\tcmd.opcode = opcode;\n\terr = sd_read_data(host, &cmd, 0x40, NULL, 0, 100);\n\tif (err < 0) {\n\t\t \n\t\tsd_wait_data_idle(host);\n\t\tsd_clear_error(host);\n\t\trtsx_pci_write_register(pcr, SD_CFG3,\n\t\t\tSD_RSP_80CLK_TIMEOUT_EN, 0);\n\t\treturn err;\n\t}\n\n\trtsx_pci_write_register(pcr, SD_CFG3, SD_RSP_80CLK_TIMEOUT_EN, 0);\n\treturn 0;\n}\n\nstatic int sd_tuning_phase(struct realtek_pci_sdmmc *host,\n\t\tu8 opcode, u32 *phase_map)\n{\n\tint err, i;\n\tu32 raw_phase_map = 0;\n\n\tfor (i = 0; i < RTSX_PHASE_MAX; i++) {\n\t\terr = sd_tuning_rx_cmd(host, opcode, (u8)i);\n\t\tif (err == 0)\n\t\t\traw_phase_map |= 1 << i;\n\t}\n\n\tif (phase_map)\n\t\t*phase_map = raw_phase_map;\n\n\treturn 0;\n}\n\nstatic int sd_tuning_rx(struct realtek_pci_sdmmc *host, u8 opcode)\n{\n\tint err, i;\n\tu32 raw_phase_map[RX_TUNING_CNT] = {0}, phase_map;\n\tu8 final_phase;\n\n\tfor (i = 0; i < RX_TUNING_CNT; i++) {\n\t\terr = sd_tuning_phase(host, opcode, &(raw_phase_map[i]));\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (raw_phase_map[i] == 0)\n\t\t\tbreak;\n\t}\n\n\tphase_map = 0xFFFFFFFF;\n\tfor (i = 0; i < RX_TUNING_CNT; i++) {\n\t\tdev_dbg(sdmmc_dev(host), \"RX raw_phase_map[%d] = 0x%08x\\n\",\n\t\t\t\ti, raw_phase_map[i]);\n\t\tphase_map &= raw_phase_map[i];\n\t}\n\tdev_dbg(sdmmc_dev(host), \"RX phase_map = 0x%08x\\n\", phase_map);\n\n\tif (phase_map) {\n\t\tfinal_phase = sd_search_final_phase(host, phase_map);\n\t\tif (final_phase == 0xFF)\n\t\t\treturn -EINVAL;\n\n\t\terr = sd_change_phase(host, final_phase, true);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int sdio_extblock_cmd(struct mmc_command *cmd,\n\tstruct mmc_data *data)\n{\n\treturn (cmd->opcode == SD_IO_RW_EXTENDED) && (data->blksz == 512);\n}\n\nstatic inline int sd_rw_cmd(struct mmc_command *cmd)\n{\n\treturn mmc_op_multi(cmd->opcode) ||\n\t\t(cmd->opcode == MMC_READ_SINGLE_BLOCK) ||\n\t\t(cmd->opcode == MMC_WRITE_BLOCK);\n}\n\nstatic void sd_request(struct work_struct *work)\n{\n\tstruct realtek_pci_sdmmc *host = container_of(work,\n\t\t\tstruct realtek_pci_sdmmc, work);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\n\tunsigned int data_size = 0;\n\tint err;\n\n\tif (host->eject || !sd_get_cd_int(host)) {\n\t\tcmd->error = -ENOMEDIUM;\n\t\tgoto finish;\n\t}\n\n\terr = rtsx_pci_card_exclusive_check(host->pcr, RTSX_SD_CARD);\n\tif (err) {\n\t\tcmd->error = err;\n\t\tgoto finish;\n\t}\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\trtsx_pci_switch_clock(pcr, host->clock, host->ssc_depth,\n\t\t\thost->initial_mode, host->double_clk, host->vpclk);\n\trtsx_pci_write_register(pcr, CARD_SELECT, 0x07, SD_MOD_SEL);\n\trtsx_pci_write_register(pcr, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_48_SD);\n\n\tmutex_lock(&host->host_mutex);\n\thost->mrq = mrq;\n\tmutex_unlock(&host->host_mutex);\n\n\tif (mrq->data)\n\t\tdata_size = data->blocks * data->blksz;\n\n\tif (!data_size) {\n\t\tsd_send_cmd_get_rsp(host, cmd);\n\t} else if (sd_rw_cmd(cmd) || sdio_extblock_cmd(cmd, data)) {\n\t\tcmd->error = sd_rw_multi(host, mrq);\n\t\tif (!host->using_cookie)\n\t\t\tsdmmc_post_req(host->mmc, host->mrq, 0);\n\n\t\tif (mmc_op_multi(cmd->opcode) && mrq->stop)\n\t\t\tsd_send_cmd_get_rsp(host, mrq->stop);\n\t} else {\n\t\tsd_normal_rw(host, mrq);\n\t}\n\n\tif (mrq->data) {\n\t\tif (cmd->error || data->error)\n\t\t\tdata->bytes_xfered = 0;\n\t\telse\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t}\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\nfinish:\n\tif (cmd->error) {\n\t\tdev_dbg(sdmmc_dev(host), \"CMD %d 0x%08x error(%d)\\n\",\n\t\t\tcmd->opcode, cmd->arg, cmd->error);\n\t}\n\n\tmutex_lock(&host->host_mutex);\n\thost->mrq = NULL;\n\tmutex_unlock(&host->host_mutex);\n\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic void sdmmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tmutex_lock(&host->host_mutex);\n\thost->mrq = mrq;\n\tmutex_unlock(&host->host_mutex);\n\n\tif (sd_rw_cmd(mrq->cmd) || sdio_extblock_cmd(mrq->cmd, data))\n\t\thost->using_cookie = sd_pre_dma_transfer(host, data, false);\n\n\tschedule_work(&host->work);\n}\n\nstatic int sd_set_bus_width(struct realtek_pci_sdmmc *host,\n\t\tunsigned char bus_width)\n{\n\tint err = 0;\n\tu8 width[] = {\n\t\t[MMC_BUS_WIDTH_1] = SD_BUS_WIDTH_1BIT,\n\t\t[MMC_BUS_WIDTH_4] = SD_BUS_WIDTH_4BIT,\n\t\t[MMC_BUS_WIDTH_8] = SD_BUS_WIDTH_8BIT,\n\t};\n\n\tif (bus_width <= MMC_BUS_WIDTH_8)\n\t\terr = rtsx_pci_write_register(host->pcr, SD_CFG1,\n\t\t\t\t0x03, width[bus_width]);\n\n\treturn err;\n}\n\nstatic int sd_power_on(struct realtek_pci_sdmmc *host, unsigned char power_mode)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tstruct mmc_host *mmc = host->mmc;\n\tint err;\n\tu32 val;\n\tu8 test_mode;\n\n\tif (host->prev_power_state == MMC_POWER_ON)\n\t\treturn 0;\n\n\tif (host->prev_power_state == MMC_POWER_UP) {\n\t\trtsx_pci_write_register(pcr, SD_BUS_STAT, SD_CLK_TOGGLE_EN, 0);\n\t\tgoto finish;\n\t}\n\n\tmsleep(100);\n\n\trtsx_pci_init_cmd(pcr);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SELECT, 0x07, SD_MOD_SEL);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_SHARE_MODE,\n\t\t\tCARD_SHARE_MASK, CARD_SHARE_48_SD);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN,\n\t\t\tSD_CLK_EN, SD_CLK_EN);\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_pull_ctl_enable(pcr, RTSX_SD_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_power_on(pcr, RTSX_SD_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\tmdelay(1);\n\n\terr = rtsx_pci_write_register(pcr, CARD_OE, SD_OUTPUT_EN, SD_OUTPUT_EN);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\trtsx_pci_write_register(pcr, SD_BUS_STAT, SD_CLK_TOGGLE_EN, SD_CLK_TOGGLE_EN);\n\n\tif (PCI_PID(pcr) == PID_5261) {\n\t\t \n\t\trtsx_pci_read_register(pcr, RTS5261_FW_CFG_INFO0, &test_mode);\n\t\tif (test_mode & RTS5261_FW_EXPRESS_TEST_MASK) {\n\t\t\tsdmmc_init_sd_express(mmc, NULL);\n\t\t\treturn 0;\n\t\t}\n\t\tif (pcr->extra_caps & EXTRA_CAPS_SD_EXPRESS)\n\t\t\tmmc->caps2 |= MMC_CAP2_SD_EXP | MMC_CAP2_SD_EXP_1_2V;\n\t\t \n\t\tval = rtsx_pci_readl(pcr, RTSX_BIPR);\n\t\tif (val & SD_WRITE_PROTECT) {\n\t\t\tpcr->extra_caps &= ~EXTRA_CAPS_SD_EXPRESS;\n\t\t\tmmc->caps2 &= ~(MMC_CAP2_SD_EXP | MMC_CAP2_SD_EXP_1_2V);\n\t\t}\n\t}\n\nfinish:\n\thost->prev_power_state = power_mode;\n\treturn 0;\n}\n\nstatic int sd_power_off(struct realtek_pci_sdmmc *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\n\thost->prev_power_state = MMC_POWER_OFF;\n\n\trtsx_pci_init_cmd(pcr);\n\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_EN, SD_CLK_EN, 0);\n\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_OE, SD_OUTPUT_EN, 0);\n\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = rtsx_pci_card_power_off(pcr, RTSX_SD_CARD);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn rtsx_pci_card_pull_ctl_disable(pcr, RTSX_SD_CARD);\n}\n\nstatic int sd_set_power_mode(struct realtek_pci_sdmmc *host,\n\t\tunsigned char power_mode)\n{\n\tint err;\n\n\tif (power_mode == MMC_POWER_OFF)\n\t\terr = sd_power_off(host);\n\telse\n\t\terr = sd_power_on(host, power_mode);\n\n\treturn err;\n}\n\nstatic int sd_set_timing(struct realtek_pci_sdmmc *host, unsigned char timing)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err = 0;\n\n\trtsx_pci_init_cmd(pcr);\n\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_UHS_SDR50:\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C | SD_ASYNC_FIFO_NOT_RST,\n\t\t\t\tSD_30_MODE | SD_ASYNC_FIFO_NOT_RST);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL, CLK_LOW_FREQ, 0);\n\t\tbreak;\n\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C | SD_ASYNC_FIFO_NOT_RST,\n\t\t\t\tSD_DDR_MODE | SD_ASYNC_FIFO_NOT_RST);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_VAR_CLK0 | SD30_FIX_CLK | SAMPLE_VAR_CLK1);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL, CLK_LOW_FREQ, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\n\t\t\t\tDDR_VAR_TX_CMD_DAT, DDR_VAR_TX_CMD_DAT);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tDDR_VAR_RX_DAT | DDR_VAR_RX_CMD,\n\t\t\t\tDDR_VAR_RX_DAT | DDR_VAR_RX_CMD);\n\t\tbreak;\n\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_CFG1,\n\t\t\t\t0x0C, SD_20_MODE);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL, CLK_LOW_FREQ, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_PUSH_POINT_CTL,\n\t\t\t\tSD20_TX_SEL_MASK, SD20_TX_14_AHEAD);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tSD20_RX_SEL_MASK, SD20_RX_14_DELAY);\n\t\tbreak;\n\n\tdefault:\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\tSD_CFG1, 0x0C, SD_20_MODE);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL,\n\t\t\t\tCLK_LOW_FREQ, CLK_LOW_FREQ);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CARD_CLK_SOURCE, 0xFF,\n\t\t\t\tCRC_FIX_CLK | SD30_VAR_CLK0 | SAMPLE_VAR_CLK1);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, CLK_CTL, CLK_LOW_FREQ, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD,\n\t\t\t\tSD_PUSH_POINT_CTL, 0xFF, 0);\n\t\trtsx_pci_add_cmd(pcr, WRITE_REG_CMD, SD_SAMPLE_POINT_CTL,\n\t\t\t\tSD20_RX_SEL_MASK, SD20_RX_POS_EDGE);\n\t\tbreak;\n\t}\n\n\terr = rtsx_pci_send_cmd(pcr, 100);\n\n\treturn err;\n}\n\nstatic void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\tif (host->eject)\n\t\treturn;\n\n\tif (rtsx_pci_card_exclusive_check(host->pcr, RTSX_SD_CARD))\n\t\treturn;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\tsd_set_bus_width(host, ios->bus_width);\n\tsd_set_power_mode(host, ios->power_mode);\n\tsd_set_timing(host, ios->timing);\n\n\thost->vpclk = false;\n\thost->double_clk = true;\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_UHS_SDR50:\n\t\thost->ssc_depth = RTSX_SSC_DEPTH_2M;\n\t\thost->vpclk = true;\n\t\thost->double_clk = false;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_UHS_SDR25:\n\t\thost->ssc_depth = RTSX_SSC_DEPTH_1M;\n\t\tbreak;\n\tdefault:\n\t\thost->ssc_depth = RTSX_SSC_DEPTH_500K;\n\t\tbreak;\n\t}\n\n\thost->initial_mode = (ios->clock <= 1000000) ? true : false;\n\n\thost->clock = ios->clock;\n\trtsx_pci_switch_clock(pcr, ios->clock, host->ssc_depth,\n\t\t\thost->initial_mode, host->double_clk, host->vpclk);\n\n\tmutex_unlock(&pcr->pcr_mutex);\n}\n\nstatic int sdmmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint ro = 0;\n\tu32 val;\n\n\tif (host->eject)\n\t\treturn -ENOMEDIUM;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\t \n\tval = rtsx_pci_readl(pcr, RTSX_BIPR);\n\tdev_dbg(sdmmc_dev(host), \"%s: RTSX_BIPR = 0x%08x\\n\", __func__, val);\n\tif (val & SD_WRITE_PROTECT)\n\t\tro = 1;\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\treturn ro;\n}\n\nstatic int sdmmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint cd = 0;\n\tu32 val;\n\n\tif (host->eject)\n\t\treturn cd;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\t \n\tval = rtsx_pci_card_exist(pcr);\n\tdev_dbg(sdmmc_dev(host), \"%s: RTSX_BIPR = 0x%08x\\n\", __func__, val);\n\tif (val & SD_EXIST)\n\t\tcd = 1;\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\treturn cd;\n}\n\nstatic int sd_wait_voltage_stable_1(struct realtek_pci_sdmmc *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\tu8 stat;\n\n\t \n\tmdelay(1);\n\n\t \n\terr = rtsx_pci_read_register(pcr, SD_BUS_STAT, &stat);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (stat & (SD_CMD_STATUS | SD_DAT3_STATUS | SD_DAT2_STATUS |\n\t\t\t\tSD_DAT1_STATUS | SD_DAT0_STATUS))\n\t\treturn -EINVAL;\n\n\t \n\terr = rtsx_pci_write_register(pcr, SD_BUS_STAT,\n\t\t\t0xFF, SD_CLK_FORCE_STOP);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int sd_wait_voltage_stable_2(struct realtek_pci_sdmmc *host)\n{\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err;\n\tu8 stat, mask, val;\n\n\t \n\tmsleep(50);\n\n\t \n\terr = rtsx_pci_write_register(pcr, SD_BUS_STAT, 0xFF, SD_CLK_TOGGLE_EN);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tmsleep(20);\n\n\t \n\terr = rtsx_pci_read_register(pcr, SD_BUS_STAT, &stat);\n\tif (err < 0)\n\t\treturn err;\n\n\tmask = SD_CMD_STATUS | SD_DAT3_STATUS | SD_DAT2_STATUS |\n\t\tSD_DAT1_STATUS | SD_DAT0_STATUS;\n\tval = SD_CMD_STATUS | SD_DAT3_STATUS | SD_DAT2_STATUS |\n\t\tSD_DAT1_STATUS | SD_DAT0_STATUS;\n\tif ((stat & mask) != val) {\n\t\tdev_dbg(sdmmc_dev(host),\n\t\t\t\"%s: SD_BUS_STAT = 0x%x\\n\", __func__, stat);\n\t\trtsx_pci_write_register(pcr, SD_BUS_STAT,\n\t\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP, 0);\n\t\trtsx_pci_write_register(pcr, CARD_CLK_EN, 0xFF, 0);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdmmc_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err = 0;\n\tu8 voltage;\n\n\tdev_dbg(sdmmc_dev(host), \"%s: signal_voltage = %d\\n\",\n\t\t\t__func__, ios->signal_voltage);\n\n\tif (host->eject)\n\t\treturn -ENOMEDIUM;\n\n\terr = rtsx_pci_card_exclusive_check(host->pcr, RTSX_SD_CARD);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\tvoltage = OUTPUT_3V3;\n\telse\n\t\tvoltage = OUTPUT_1V8;\n\n\tif (voltage == OUTPUT_1V8) {\n\t\terr = sd_wait_voltage_stable_1(host);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = rtsx_pci_switch_output_voltage(pcr, voltage);\n\tif (err < 0)\n\t\tgoto out;\n\n\tif (voltage == OUTPUT_1V8) {\n\t\terr = sd_wait_voltage_stable_2(host);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\nout:\n\t \n\terr = rtsx_pci_write_register(pcr, SD_BUS_STAT,\n\t\t\tSD_CLK_TOGGLE_EN | SD_CLK_FORCE_STOP, 0);\n\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\treturn err;\n}\n\nstatic int sdmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\tint err = 0;\n\n\tif (host->eject)\n\t\treturn -ENOMEDIUM;\n\n\terr = rtsx_pci_card_exclusive_check(host->pcr, RTSX_SD_CARD);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&pcr->pcr_mutex);\n\n\trtsx_pci_start_run(pcr);\n\n\t \n\tswitch (mmc->ios.timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\t\terr = sd_change_phase(host, SDR104_TX_PHASE(pcr), false);\n\t\tbreak;\n\n\tcase MMC_TIMING_UHS_SDR50:\n\t\terr = sd_change_phase(host, SDR50_TX_PHASE(pcr), false);\n\t\tbreak;\n\n\tcase MMC_TIMING_UHS_DDR50:\n\t\terr = sd_change_phase(host, DDR50_TX_PHASE(pcr), false);\n\t\tbreak;\n\n\tdefault:\n\t\terr = 0;\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif ((mmc->ios.timing == MMC_TIMING_UHS_SDR104) ||\n\t\t\t(mmc->ios.timing == MMC_TIMING_UHS_SDR50))\n\t\terr = sd_tuning_rx(host, opcode);\n\telse if (mmc->ios.timing == MMC_TIMING_UHS_DDR50)\n\t\terr = sd_change_phase(host, DDR50_RX_PHASE(pcr), true);\n\nout:\n\tmutex_unlock(&pcr->pcr_mutex);\n\n\treturn err;\n}\n\nstatic int sdmmc_init_sd_express(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tu32 relink_time;\n\tstruct realtek_pci_sdmmc *host = mmc_priv(mmc);\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\t \n\trelink_time = 0x8FFF;\n\n\trtsx_pci_write_register(pcr, 0xFF01, 0xFF, relink_time);\n\trtsx_pci_write_register(pcr, 0xFF02, 0xFF, relink_time >> 8);\n\trtsx_pci_write_register(pcr, 0xFF03, 0x01, relink_time >> 16);\n\n\trtsx_pci_write_register(pcr, PETXCFG, 0x80, 0x80);\n\trtsx_pci_write_register(pcr, LDO_VCC_CFG0,\n\t\tRTS5261_LDO1_OCP_THD_MASK,\n\t\tpcr->option.sd_800mA_ocp_thd);\n\n\tif (pcr->ops->disable_auto_blink)\n\t\tpcr->ops->disable_auto_blink(pcr);\n\n\t \n\tpcr->hw_param.interrupt_en &= ~(SD_INT_EN);\n\trtsx_pci_writel(pcr, RTSX_BIER, pcr->hw_param.interrupt_en);\n\n\trtsx_pci_write_register(pcr, RTS5260_AUTOLOAD_CFG4,\n\t\tRTS5261_AUX_CLK_16M_EN, RTS5261_AUX_CLK_16M_EN);\n\trtsx_pci_write_register(pcr, RTS5261_FW_CFG0,\n\t\tRTS5261_FW_ENTER_EXPRESS, RTS5261_FW_ENTER_EXPRESS);\n\trtsx_pci_write_register(pcr, RTS5261_FW_CFG1,\n\t\tRTS5261_MCU_CLOCK_GATING, RTS5261_MCU_CLOCK_GATING);\n\trtsx_pci_write_register(pcr, RTS5261_FW_CFG1,\n\t\tRTS5261_MCU_BUS_SEL_MASK | RTS5261_MCU_CLOCK_SEL_MASK\n\t\t| RTS5261_DRIVER_ENABLE_FW,\n\t\tRTS5261_MCU_CLOCK_SEL_16M | RTS5261_DRIVER_ENABLE_FW);\n\thost->eject = true;\n\treturn 0;\n}\n\nstatic const struct mmc_host_ops realtek_pci_sdmmc_ops = {\n\t.pre_req = sdmmc_pre_req,\n\t.post_req = sdmmc_post_req,\n\t.request = sdmmc_request,\n\t.set_ios = sdmmc_set_ios,\n\t.get_ro = sdmmc_get_ro,\n\t.get_cd = sdmmc_get_cd,\n\t.start_signal_voltage_switch = sdmmc_switch_voltage,\n\t.execute_tuning = sdmmc_execute_tuning,\n\t.init_sd_express = sdmmc_init_sd_express,\n};\n\nstatic void init_extra_caps(struct realtek_pci_sdmmc *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\tdev_dbg(sdmmc_dev(host), \"pcr->extra_caps = 0x%x\\n\", pcr->extra_caps);\n\n\tif (pcr->extra_caps & EXTRA_CAPS_SD_SDR50)\n\t\tmmc->caps |= MMC_CAP_UHS_SDR50;\n\tif (pcr->extra_caps & EXTRA_CAPS_SD_SDR104)\n\t\tmmc->caps |= MMC_CAP_UHS_SDR104;\n\tif (pcr->extra_caps & EXTRA_CAPS_SD_DDR50)\n\t\tmmc->caps |= MMC_CAP_UHS_DDR50;\n\tif (pcr->extra_caps & EXTRA_CAPS_MMC_HSDDR)\n\t\tmmc->caps |= MMC_CAP_1_8V_DDR;\n\tif (pcr->extra_caps & EXTRA_CAPS_MMC_8BIT)\n\t\tmmc->caps |= MMC_CAP_8_BIT_DATA;\n\tif (pcr->extra_caps & EXTRA_CAPS_NO_MMC)\n\t\tmmc->caps2 |= MMC_CAP2_NO_MMC;\n\tif (pcr->extra_caps & EXTRA_CAPS_SD_EXPRESS)\n\t\tmmc->caps2 |= MMC_CAP2_SD_EXP | MMC_CAP2_SD_EXP_1_2V;\n}\n\nstatic void realtek_init_host(struct realtek_pci_sdmmc *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct rtsx_pcr *pcr = host->pcr;\n\n\tmmc->f_min = 250000;\n\tmmc->f_max = 208000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED |\n\t\tMMC_CAP_MMC_HIGHSPEED | MMC_CAP_BUS_WIDTH_TEST |\n\t\tMMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25;\n\tif (pcr->rtd3_en)\n\t\tmmc->caps = mmc->caps | MMC_CAP_AGGRESSIVE_PM;\n\tmmc->caps2 = MMC_CAP2_NO_PRESCAN_POWERUP | MMC_CAP2_FULL_PWR_CYCLE |\n\t\tMMC_CAP2_NO_SDIO;\n\tmmc->max_current_330 = 400;\n\tmmc->max_current_180 = 800;\n\tmmc->ops = &realtek_pci_sdmmc_ops;\n\n\tinit_extra_caps(host);\n\n\tmmc->max_segs = 256;\n\tmmc->max_seg_size = 65536;\n\tmmc->max_blk_size = 512;\n\tmmc->max_blk_count = 65535;\n\tmmc->max_req_size = 524288;\n}\n\nstatic void rtsx_pci_sdmmc_card_event(struct platform_device *pdev)\n{\n\tstruct realtek_pci_sdmmc *host = platform_get_drvdata(pdev);\n\n\thost->cookie = -1;\n\tmmc_detect_change(host->mmc, 0);\n}\n\nstatic int rtsx_pci_sdmmc_drv_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct realtek_pci_sdmmc *host;\n\tstruct rtsx_pcr *pcr;\n\tstruct pcr_handle *handle = pdev->dev.platform_data;\n\tint ret;\n\n\tif (!handle)\n\t\treturn -ENXIO;\n\n\tpcr = handle->pcr;\n\tif (!pcr)\n\t\treturn -ENXIO;\n\n\tdev_dbg(&(pdev->dev), \": Realtek PCI-E SDMMC controller found\\n\");\n\n\tmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->pcr = pcr;\n\tmmc->ios.power_delay_ms = 5;\n\thost->mmc = mmc;\n\thost->pdev = pdev;\n\thost->cookie = -1;\n\thost->prev_power_state = MMC_POWER_OFF;\n\tINIT_WORK(&host->work, sd_request);\n\tplatform_set_drvdata(pdev, host);\n\tpcr->slots[RTSX_SD_CARD].p_dev = pdev;\n\tpcr->slots[RTSX_SD_CARD].card_event = rtsx_pci_sdmmc_card_event;\n\n\tmutex_init(&host->host_mutex);\n\n\trealtek_init_host(host);\n\n\tpm_runtime_no_callbacks(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 200);\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tmmc_free_host(mmc);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void rtsx_pci_sdmmc_drv_remove(struct platform_device *pdev)\n{\n\tstruct realtek_pci_sdmmc *host = platform_get_drvdata(pdev);\n\tstruct rtsx_pcr *pcr;\n\tstruct mmc_host *mmc;\n\n\tpcr = host->pcr;\n\tpcr->slots[RTSX_SD_CARD].p_dev = NULL;\n\tpcr->slots[RTSX_SD_CARD].card_event = NULL;\n\tmmc = host->mmc;\n\n\tcancel_work_sync(&host->work);\n\n\tmutex_lock(&host->host_mutex);\n\tif (host->mrq) {\n\t\tdev_dbg(&(pdev->dev),\n\t\t\t\"%s: Controller removed during transfer\\n\",\n\t\t\tmmc_hostname(mmc));\n\n\t\trtsx_pci_complete_unfinished_transfer(pcr);\n\n\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\tif (host->mrq->stop)\n\t\t\thost->mrq->stop->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, host->mrq);\n\t}\n\tmutex_unlock(&host->host_mutex);\n\n\tmmc_remove_host(mmc);\n\thost->eject = true;\n\n\tflush_work(&host->work);\n\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\tmmc_free_host(mmc);\n\n\tdev_dbg(&(pdev->dev),\n\t\t\": Realtek PCI-E SDMMC controller has been removed\\n\");\n}\n\nstatic const struct platform_device_id rtsx_pci_sdmmc_ids[] = {\n\t{\n\t\t.name = DRV_NAME_RTSX_PCI_SDMMC,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, rtsx_pci_sdmmc_ids);\n\nstatic struct platform_driver rtsx_pci_sdmmc_driver = {\n\t.probe\t\t= rtsx_pci_sdmmc_drv_probe,\n\t.remove_new\t= rtsx_pci_sdmmc_drv_remove,\n\t.id_table       = rtsx_pci_sdmmc_ids,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME_RTSX_PCI_SDMMC,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_platform_driver(rtsx_pci_sdmmc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Wei WANG <wei_wang@realsil.com.cn>\");\nMODULE_DESCRIPTION(\"Realtek PCI-E SD/MMC Card Host Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}