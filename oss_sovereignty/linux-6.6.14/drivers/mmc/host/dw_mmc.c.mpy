{
  "module_name": "dw_mmc.c",
  "hash_id": "855f95e090ebe3201e81bd840ec1560cf306a1463371ef63d60fdf1029c3808c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc.c",
  "human_readable_source": "\n \n\n#include <linux/blkdev.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/ioport.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/prandom.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/irq.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio.h>\n#include <linux/bitops.h>\n#include <linux/regulator/consumer.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include \"dw_mmc.h\"\n\n \n#define DW_MCI_DATA_ERROR_FLAGS\t(SDMMC_INT_DRTO | SDMMC_INT_DCRC | \\\n\t\t\t\t SDMMC_INT_HTO | SDMMC_INT_SBE  | \\\n\t\t\t\t SDMMC_INT_EBE | SDMMC_INT_HLE)\n#define DW_MCI_CMD_ERROR_FLAGS\t(SDMMC_INT_RTO | SDMMC_INT_RCRC | \\\n\t\t\t\t SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)\n#define DW_MCI_ERROR_FLAGS\t(DW_MCI_DATA_ERROR_FLAGS | \\\n\t\t\t\t DW_MCI_CMD_ERROR_FLAGS)\n#define DW_MCI_SEND_STATUS\t1\n#define DW_MCI_RECV_STATUS\t2\n#define DW_MCI_DMA_THRESHOLD\t16\n\n#define DW_MCI_FREQ_MAX\t200000000\t \n#define DW_MCI_FREQ_MIN\t100000\t\t \n\n#define IDMAC_INT_CLR\t\t(SDMMC_IDMAC_INT_AI | SDMMC_IDMAC_INT_NI | \\\n\t\t\t\t SDMMC_IDMAC_INT_CES | SDMMC_IDMAC_INT_DU | \\\n\t\t\t\t SDMMC_IDMAC_INT_FBE | SDMMC_IDMAC_INT_RI | \\\n\t\t\t\t SDMMC_IDMAC_INT_TI)\n\n#define DESC_RING_BUF_SZ\tPAGE_SIZE\n\nstruct idmac_desc_64addr {\n\tu32\t\tdes0;\t \n#define IDMAC_OWN_CLR64(x) \\\n\t!((x) & cpu_to_le32(IDMAC_DES0_OWN))\n\n\tu32\t\tdes1;\t \n\n\tu32\t\tdes2;\t \n#define IDMAC_64ADDR_SET_BUFFER1_SIZE(d, s) \\\n\t((d)->des2 = ((d)->des2 & cpu_to_le32(0x03ffe000)) | \\\n\t ((cpu_to_le32(s)) & cpu_to_le32(0x1fff)))\n\n\tu32\t\tdes3;\t \n\n\tu32\t\tdes4;\t \n\tu32\t\tdes5;\t \n\n\tu32\t\tdes6;\t \n\tu32\t\tdes7;\t \n};\n\nstruct idmac_desc {\n\t__le32\t\tdes0;\t \n#define IDMAC_DES0_DIC\tBIT(1)\n#define IDMAC_DES0_LD\tBIT(2)\n#define IDMAC_DES0_FD\tBIT(3)\n#define IDMAC_DES0_CH\tBIT(4)\n#define IDMAC_DES0_ER\tBIT(5)\n#define IDMAC_DES0_CES\tBIT(30)\n#define IDMAC_DES0_OWN\tBIT(31)\n\n\t__le32\t\tdes1;\t \n#define IDMAC_SET_BUFFER1_SIZE(d, s) \\\n\t((d)->des1 = ((d)->des1 & cpu_to_le32(0x03ffe000)) | (cpu_to_le32((s) & 0x1fff)))\n\n\t__le32\t\tdes2;\t \n\n\t__le32\t\tdes3;\t \n};\n\n \n#define DW_MCI_DESC_DATA_LENGTH\t0x1000\n\n#if defined(CONFIG_DEBUG_FS)\nstatic int dw_mci_req_show(struct seq_file *s, void *v)\n{\n\tstruct dw_mci_slot *slot = s->private;\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_command *stop;\n\tstruct mmc_data\t*data;\n\n\t \n\tspin_lock_bh(&slot->host->lock);\n\tmrq = slot->mrq;\n\n\tif (mrq) {\n\t\tcmd = mrq->cmd;\n\t\tdata = mrq->data;\n\t\tstop = mrq->stop;\n\n\t\tif (cmd)\n\t\t\tseq_printf(s,\n\t\t\t\t   \"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\\n\",\n\t\t\t\t   cmd->opcode, cmd->arg, cmd->flags,\n\t\t\t\t   cmd->resp[0], cmd->resp[1], cmd->resp[2],\n\t\t\t\t   cmd->resp[2], cmd->error);\n\t\tif (data)\n\t\t\tseq_printf(s, \"DATA %u / %u * %u flg %x err %d\\n\",\n\t\t\t\t   data->bytes_xfered, data->blocks,\n\t\t\t\t   data->blksz, data->flags, data->error);\n\t\tif (stop)\n\t\t\tseq_printf(s,\n\t\t\t\t   \"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\\n\",\n\t\t\t\t   stop->opcode, stop->arg, stop->flags,\n\t\t\t\t   stop->resp[0], stop->resp[1], stop->resp[2],\n\t\t\t\t   stop->resp[2], stop->error);\n\t}\n\n\tspin_unlock_bh(&slot->host->lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dw_mci_req);\n\nstatic int dw_mci_regs_show(struct seq_file *s, void *v)\n{\n\tstruct dw_mci *host = s->private;\n\n\tpm_runtime_get_sync(host->dev);\n\n\tseq_printf(s, \"STATUS:\\t0x%08x\\n\", mci_readl(host, STATUS));\n\tseq_printf(s, \"RINTSTS:\\t0x%08x\\n\", mci_readl(host, RINTSTS));\n\tseq_printf(s, \"CMD:\\t0x%08x\\n\", mci_readl(host, CMD));\n\tseq_printf(s, \"CTRL:\\t0x%08x\\n\", mci_readl(host, CTRL));\n\tseq_printf(s, \"INTMASK:\\t0x%08x\\n\", mci_readl(host, INTMASK));\n\tseq_printf(s, \"CLKENA:\\t0x%08x\\n\", mci_readl(host, CLKENA));\n\n\tpm_runtime_put_autosuspend(host->dev);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(dw_mci_regs);\n\nstatic void dw_mci_init_debugfs(struct dw_mci_slot *slot)\n{\n\tstruct mmc_host\t*mmc = slot->mmc;\n\tstruct dw_mci *host = slot->host;\n\tstruct dentry *root;\n\n\troot = mmc->debugfs_root;\n\tif (!root)\n\t\treturn;\n\n\tdebugfs_create_file(\"regs\", S_IRUSR, root, host, &dw_mci_regs_fops);\n\tdebugfs_create_file(\"req\", S_IRUSR, root, slot, &dw_mci_req_fops);\n\tdebugfs_create_u32(\"state\", S_IRUSR, root, &host->state);\n\tdebugfs_create_xul(\"pending_events\", S_IRUSR, root,\n\t\t\t   &host->pending_events);\n\tdebugfs_create_xul(\"completed_events\", S_IRUSR, root,\n\t\t\t   &host->completed_events);\n#ifdef CONFIG_FAULT_INJECTION\n\tfault_create_debugfs_attr(\"fail_data_crc\", root, &host->fail_data_crc);\n#endif\n}\n#endif  \n\nstatic bool dw_mci_ctrl_reset(struct dw_mci *host, u32 reset)\n{\n\tu32 ctrl;\n\n\tctrl = mci_readl(host, CTRL);\n\tctrl |= reset;\n\tmci_writel(host, CTRL, ctrl);\n\n\t \n\tif (readl_poll_timeout_atomic(host->regs + SDMMC_CTRL, ctrl,\n\t\t\t\t      !(ctrl & reset),\n\t\t\t\t      1, 500 * USEC_PER_MSEC)) {\n\t\tdev_err(host->dev,\n\t\t\t\"Timeout resetting block (ctrl reset %#x)\\n\",\n\t\t\tctrl & reset);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void dw_mci_wait_while_busy(struct dw_mci *host, u32 cmd_flags)\n{\n\tu32 status;\n\n\t \n\tif ((cmd_flags & SDMMC_CMD_PRV_DAT_WAIT) &&\n\t    !(cmd_flags & SDMMC_CMD_VOLT_SWITCH)) {\n\t\tif (readl_poll_timeout_atomic(host->regs + SDMMC_STATUS,\n\t\t\t\t\t      status,\n\t\t\t\t\t      !(status & SDMMC_STATUS_BUSY),\n\t\t\t\t\t      10, 500 * USEC_PER_MSEC))\n\t\t\tdev_err(host->dev, \"Busy; trying anyway\\n\");\n\t}\n}\n\nstatic void mci_send_cmd(struct dw_mci_slot *slot, u32 cmd, u32 arg)\n{\n\tstruct dw_mci *host = slot->host;\n\tunsigned int cmd_status = 0;\n\n\tmci_writel(host, CMDARG, arg);\n\twmb();  \n\tdw_mci_wait_while_busy(host, cmd);\n\tmci_writel(host, CMD, SDMMC_CMD_START | cmd);\n\n\tif (readl_poll_timeout_atomic(host->regs + SDMMC_CMD, cmd_status,\n\t\t\t\t      !(cmd_status & SDMMC_CMD_START),\n\t\t\t\t      1, 500 * USEC_PER_MSEC))\n\t\tdev_err(&slot->mmc->class_dev,\n\t\t\t\"Timeout sending command (cmd %#x arg %#x status %#x)\\n\",\n\t\t\tcmd, arg, cmd_status);\n}\n\nstatic u32 dw_mci_prepare_command(struct mmc_host *mmc, struct mmc_command *cmd)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tu32 cmdr;\n\n\tcmd->error = -EINPROGRESS;\n\tcmdr = cmd->opcode;\n\n\tif (cmd->opcode == MMC_STOP_TRANSMISSION ||\n\t    cmd->opcode == MMC_GO_IDLE_STATE ||\n\t    cmd->opcode == MMC_GO_INACTIVE_STATE ||\n\t    (cmd->opcode == SD_IO_RW_DIRECT &&\n\t     ((cmd->arg >> 9) & 0x1FFFF) == SDIO_CCCR_ABORT))\n\t\tcmdr |= SDMMC_CMD_STOP;\n\telse if (cmd->opcode != MMC_SEND_STATUS && cmd->data)\n\t\tcmdr |= SDMMC_CMD_PRV_DAT_WAIT;\n\n\tif (cmd->opcode == SD_SWITCH_VOLTAGE) {\n\t\tu32 clk_en_a;\n\n\t\t \n\t\tcmdr |= SDMMC_CMD_VOLT_SWITCH;\n\n\t\t \n\t\tWARN_ON(slot->host->state != STATE_SENDING_CMD);\n\t\tslot->host->state = STATE_SENDING_CMD11;\n\n\t\t \n\t\tclk_en_a = mci_readl(host, CLKENA);\n\t\tclk_en_a &= ~(SDMMC_CLKEN_LOW_PWR << slot->id);\n\t\tmci_writel(host, CLKENA, clk_en_a);\n\t\tmci_send_cmd(slot, SDMMC_CMD_UPD_CLK |\n\t\t\t     SDMMC_CMD_PRV_DAT_WAIT, 0);\n\t}\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\t \n\t\tcmdr |= SDMMC_CMD_RESP_EXP;\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tcmdr |= SDMMC_CMD_RESP_LONG;\n\t}\n\n\tif (cmd->flags & MMC_RSP_CRC)\n\t\tcmdr |= SDMMC_CMD_RESP_CRC;\n\n\tif (cmd->data) {\n\t\tcmdr |= SDMMC_CMD_DAT_EXP;\n\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\tcmdr |= SDMMC_CMD_DAT_WR;\n\t}\n\n\tif (!test_bit(DW_MMC_CARD_NO_USE_HOLD, &slot->flags))\n\t\tcmdr |= SDMMC_CMD_USE_HOLD_REG;\n\n\treturn cmdr;\n}\n\nstatic u32 dw_mci_prep_stop_abort(struct dw_mci *host, struct mmc_command *cmd)\n{\n\tstruct mmc_command *stop;\n\tu32 cmdr;\n\n\tif (!cmd->data)\n\t\treturn 0;\n\n\tstop = &host->stop_abort;\n\tcmdr = cmd->opcode;\n\tmemset(stop, 0, sizeof(struct mmc_command));\n\n\tif (cmdr == MMC_READ_SINGLE_BLOCK ||\n\t    cmdr == MMC_READ_MULTIPLE_BLOCK ||\n\t    cmdr == MMC_WRITE_BLOCK ||\n\t    cmdr == MMC_WRITE_MULTIPLE_BLOCK ||\n\t    mmc_op_tuning(cmdr) ||\n\t    cmdr == MMC_GEN_CMD) {\n\t\tstop->opcode = MMC_STOP_TRANSMISSION;\n\t\tstop->arg = 0;\n\t\tstop->flags = MMC_RSP_R1B | MMC_CMD_AC;\n\t} else if (cmdr == SD_IO_RW_EXTENDED) {\n\t\tstop->opcode = SD_IO_RW_DIRECT;\n\t\tstop->arg |= (1 << 31) | (0 << 28) | (SDIO_CCCR_ABORT << 9) |\n\t\t\t     ((cmd->arg >> 28) & 0x7);\n\t\tstop->flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;\n\t} else {\n\t\treturn 0;\n\t}\n\n\tcmdr = stop->opcode | SDMMC_CMD_STOP |\n\t\tSDMMC_CMD_RESP_CRC | SDMMC_CMD_RESP_EXP;\n\n\tif (!test_bit(DW_MMC_CARD_NO_USE_HOLD, &host->slot->flags))\n\t\tcmdr |= SDMMC_CMD_USE_HOLD_REG;\n\n\treturn cmdr;\n}\n\nstatic inline void dw_mci_set_cto(struct dw_mci *host)\n{\n\tunsigned int cto_clks;\n\tunsigned int cto_div;\n\tunsigned int cto_ms;\n\tunsigned long irqflags;\n\n\tcto_clks = mci_readl(host, TMOUT) & 0xff;\n\tcto_div = (mci_readl(host, CLKDIV) & 0xff) * 2;\n\tif (cto_div == 0)\n\t\tcto_div = 1;\n\n\tcto_ms = DIV_ROUND_UP_ULL((u64)MSEC_PER_SEC * cto_clks * cto_div,\n\t\t\t\t  host->bus_hz);\n\n\t \n\tcto_ms += 10;\n\n\t \n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\tif (!test_bit(EVENT_CMD_COMPLETE, &host->pending_events))\n\t\tmod_timer(&host->cto_timer,\n\t\t\tjiffies + msecs_to_jiffies(cto_ms) + 1);\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n}\n\nstatic void dw_mci_start_command(struct dw_mci *host,\n\t\t\t\t struct mmc_command *cmd, u32 cmd_flags)\n{\n\thost->cmd = cmd;\n\tdev_vdbg(host->dev,\n\t\t \"start command: ARGR=0x%08x CMDR=0x%08x\\n\",\n\t\t cmd->arg, cmd_flags);\n\n\tmci_writel(host, CMDARG, cmd->arg);\n\twmb();  \n\tdw_mci_wait_while_busy(host, cmd_flags);\n\n\tmci_writel(host, CMD, cmd_flags | SDMMC_CMD_START);\n\n\t \n\tif (cmd_flags & SDMMC_CMD_RESP_EXP)\n\t\tdw_mci_set_cto(host);\n}\n\nstatic inline void send_stop_abort(struct dw_mci *host, struct mmc_data *data)\n{\n\tstruct mmc_command *stop = &host->stop_abort;\n\n\tdw_mci_start_command(host, stop, host->stop_cmdr);\n}\n\n \nstatic void dw_mci_stop_dma(struct dw_mci *host)\n{\n\tif (host->using_dma) {\n\t\thost->dma_ops->stop(host);\n\t\thost->dma_ops->cleanup(host);\n\t}\n\n\t \n\tset_bit(EVENT_XFER_COMPLETE, &host->pending_events);\n}\n\nstatic void dw_mci_dma_cleanup(struct dw_mci *host)\n{\n\tstruct mmc_data *data = host->data;\n\n\tif (data && data->host_cookie == COOKIE_MAPPED) {\n\t\tdma_unmap_sg(host->dev,\n\t\t\t     data->sg,\n\t\t\t     data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t\tdata->host_cookie = COOKIE_UNMAPPED;\n\t}\n}\n\nstatic void dw_mci_idmac_reset(struct dw_mci *host)\n{\n\tu32 bmod = mci_readl(host, BMOD);\n\t \n\tbmod |= SDMMC_IDMAC_SWRESET;\n\tmci_writel(host, BMOD, bmod);\n}\n\nstatic void dw_mci_idmac_stop_dma(struct dw_mci *host)\n{\n\tu32 temp;\n\n\t \n\ttemp = mci_readl(host, CTRL);\n\ttemp &= ~SDMMC_CTRL_USE_IDMAC;\n\ttemp |= SDMMC_CTRL_DMA_RESET;\n\tmci_writel(host, CTRL, temp);\n\n\t \n\ttemp = mci_readl(host, BMOD);\n\ttemp &= ~(SDMMC_IDMAC_ENABLE | SDMMC_IDMAC_FB);\n\ttemp |= SDMMC_IDMAC_SWRESET;\n\tmci_writel(host, BMOD, temp);\n}\n\nstatic void dw_mci_dmac_complete_dma(void *arg)\n{\n\tstruct dw_mci *host = arg;\n\tstruct mmc_data *data = host->data;\n\n\tdev_vdbg(host->dev, \"DMA complete\\n\");\n\n\tif ((host->use_dma == TRANS_MODE_EDMAC) &&\n\t    data && (data->flags & MMC_DATA_READ))\n\t\t \n\t\tdma_sync_sg_for_cpu(mmc_dev(host->slot->mmc),\n\t\t\t\t    data->sg,\n\t\t\t\t    data->sg_len,\n\t\t\t\t    DMA_FROM_DEVICE);\n\n\thost->dma_ops->cleanup(host);\n\n\t \n\tif (data) {\n\t\tset_bit(EVENT_XFER_COMPLETE, &host->pending_events);\n\t\ttasklet_schedule(&host->tasklet);\n\t}\n}\n\nstatic int dw_mci_idmac_init(struct dw_mci *host)\n{\n\tint i;\n\n\tif (host->dma_64bit_address == 1) {\n\t\tstruct idmac_desc_64addr *p;\n\t\t \n\t\thost->ring_size =\n\t\t\tDESC_RING_BUF_SZ / sizeof(struct idmac_desc_64addr);\n\n\t\t \n\t\tfor (i = 0, p = host->sg_cpu; i < host->ring_size - 1;\n\t\t\t\t\t\t\t\ti++, p++) {\n\t\t\tp->des6 = (host->sg_dma +\n\t\t\t\t\t(sizeof(struct idmac_desc_64addr) *\n\t\t\t\t\t\t\t(i + 1))) & 0xffffffff;\n\n\t\t\tp->des7 = (u64)(host->sg_dma +\n\t\t\t\t\t(sizeof(struct idmac_desc_64addr) *\n\t\t\t\t\t\t\t(i + 1))) >> 32;\n\t\t\t \n\t\t\tp->des0 = 0;\n\t\t\tp->des1 = 0;\n\t\t\tp->des2 = 0;\n\t\t\tp->des3 = 0;\n\t\t}\n\n\t\t \n\t\tp->des6 = host->sg_dma & 0xffffffff;\n\t\tp->des7 = (u64)host->sg_dma >> 32;\n\t\tp->des0 = IDMAC_DES0_ER;\n\n\t} else {\n\t\tstruct idmac_desc *p;\n\t\t \n\t\thost->ring_size =\n\t\t\tDESC_RING_BUF_SZ / sizeof(struct idmac_desc);\n\n\t\t \n\t\tfor (i = 0, p = host->sg_cpu;\n\t\t     i < host->ring_size - 1;\n\t\t     i++, p++) {\n\t\t\tp->des3 = cpu_to_le32(host->sg_dma +\n\t\t\t\t\t(sizeof(struct idmac_desc) * (i + 1)));\n\t\t\tp->des0 = 0;\n\t\t\tp->des1 = 0;\n\t\t}\n\n\t\t \n\t\tp->des3 = cpu_to_le32(host->sg_dma);\n\t\tp->des0 = cpu_to_le32(IDMAC_DES0_ER);\n\t}\n\n\tdw_mci_idmac_reset(host);\n\n\tif (host->dma_64bit_address == 1) {\n\t\t \n\t\tmci_writel(host, IDSTS64, IDMAC_INT_CLR);\n\t\tmci_writel(host, IDINTEN64, SDMMC_IDMAC_INT_NI |\n\t\t\t\tSDMMC_IDMAC_INT_RI | SDMMC_IDMAC_INT_TI);\n\n\t\t \n\t\tmci_writel(host, DBADDRL, host->sg_dma & 0xffffffff);\n\t\tmci_writel(host, DBADDRU, (u64)host->sg_dma >> 32);\n\n\t} else {\n\t\t \n\t\tmci_writel(host, IDSTS, IDMAC_INT_CLR);\n\t\tmci_writel(host, IDINTEN, SDMMC_IDMAC_INT_NI |\n\t\t\t\tSDMMC_IDMAC_INT_RI | SDMMC_IDMAC_INT_TI);\n\n\t\t \n\t\tmci_writel(host, DBADDR, host->sg_dma);\n\t}\n\n\treturn 0;\n}\n\nstatic inline int dw_mci_prepare_desc64(struct dw_mci *host,\n\t\t\t\t\t struct mmc_data *data,\n\t\t\t\t\t unsigned int sg_len)\n{\n\tunsigned int desc_len;\n\tstruct idmac_desc_64addr *desc_first, *desc_last, *desc;\n\tu32 val;\n\tint i;\n\n\tdesc_first = desc_last = desc = host->sg_cpu;\n\n\tfor (i = 0; i < sg_len; i++) {\n\t\tunsigned int length = sg_dma_len(&data->sg[i]);\n\n\t\tu64 mem_addr = sg_dma_address(&data->sg[i]);\n\n\t\tfor ( ; length ; desc++) {\n\t\t\tdesc_len = (length <= DW_MCI_DESC_DATA_LENGTH) ?\n\t\t\t\t   length : DW_MCI_DESC_DATA_LENGTH;\n\n\t\t\tlength -= desc_len;\n\n\t\t\t \n\t\t\tif (readl_poll_timeout_atomic(&desc->des0, val,\n\t\t\t\t\t\t!(val & IDMAC_DES0_OWN),\n\t\t\t\t\t\t10, 100 * USEC_PER_MSEC))\n\t\t\t\tgoto err_own_bit;\n\n\t\t\t \n\t\t\tdesc->des0 = IDMAC_DES0_OWN | IDMAC_DES0_DIC |\n\t\t\t\t\t\tIDMAC_DES0_CH;\n\n\t\t\t \n\t\t\tIDMAC_64ADDR_SET_BUFFER1_SIZE(desc, desc_len);\n\n\t\t\t \n\t\t\tdesc->des4 = mem_addr & 0xffffffff;\n\t\t\tdesc->des5 = mem_addr >> 32;\n\n\t\t\t \n\t\t\tmem_addr += desc_len;\n\n\t\t\t \n\t\t\tdesc_last = desc;\n\t\t}\n\t}\n\n\t \n\tdesc_first->des0 |= IDMAC_DES0_FD;\n\n\t \n\tdesc_last->des0 &= ~(IDMAC_DES0_CH | IDMAC_DES0_DIC);\n\tdesc_last->des0 |= IDMAC_DES0_LD;\n\n\treturn 0;\nerr_own_bit:\n\t \n\tdev_dbg(host->dev, \"descriptor is still owned by IDMAC.\\n\");\n\tmemset(host->sg_cpu, 0, DESC_RING_BUF_SZ);\n\tdw_mci_idmac_init(host);\n\treturn -EINVAL;\n}\n\n\nstatic inline int dw_mci_prepare_desc32(struct dw_mci *host,\n\t\t\t\t\t struct mmc_data *data,\n\t\t\t\t\t unsigned int sg_len)\n{\n\tunsigned int desc_len;\n\tstruct idmac_desc *desc_first, *desc_last, *desc;\n\tu32 val;\n\tint i;\n\n\tdesc_first = desc_last = desc = host->sg_cpu;\n\n\tfor (i = 0; i < sg_len; i++) {\n\t\tunsigned int length = sg_dma_len(&data->sg[i]);\n\n\t\tu32 mem_addr = sg_dma_address(&data->sg[i]);\n\n\t\tfor ( ; length ; desc++) {\n\t\t\tdesc_len = (length <= DW_MCI_DESC_DATA_LENGTH) ?\n\t\t\t\t   length : DW_MCI_DESC_DATA_LENGTH;\n\n\t\t\tlength -= desc_len;\n\n\t\t\t \n\t\t\tif (readl_poll_timeout_atomic(&desc->des0, val,\n\t\t\t\t\t\t      IDMAC_OWN_CLR64(val),\n\t\t\t\t\t\t      10,\n\t\t\t\t\t\t      100 * USEC_PER_MSEC))\n\t\t\t\tgoto err_own_bit;\n\n\t\t\t \n\t\t\tdesc->des0 = cpu_to_le32(IDMAC_DES0_OWN |\n\t\t\t\t\t\t IDMAC_DES0_DIC |\n\t\t\t\t\t\t IDMAC_DES0_CH);\n\n\t\t\t \n\t\t\tIDMAC_SET_BUFFER1_SIZE(desc, desc_len);\n\n\t\t\t \n\t\t\tdesc->des2 = cpu_to_le32(mem_addr);\n\n\t\t\t \n\t\t\tmem_addr += desc_len;\n\n\t\t\t \n\t\t\tdesc_last = desc;\n\t\t}\n\t}\n\n\t \n\tdesc_first->des0 |= cpu_to_le32(IDMAC_DES0_FD);\n\n\t \n\tdesc_last->des0 &= cpu_to_le32(~(IDMAC_DES0_CH |\n\t\t\t\t       IDMAC_DES0_DIC));\n\tdesc_last->des0 |= cpu_to_le32(IDMAC_DES0_LD);\n\n\treturn 0;\nerr_own_bit:\n\t \n\tdev_dbg(host->dev, \"descriptor is still owned by IDMAC.\\n\");\n\tmemset(host->sg_cpu, 0, DESC_RING_BUF_SZ);\n\tdw_mci_idmac_init(host);\n\treturn -EINVAL;\n}\n\nstatic int dw_mci_idmac_start_dma(struct dw_mci *host, unsigned int sg_len)\n{\n\tu32 temp;\n\tint ret;\n\n\tif (host->dma_64bit_address == 1)\n\t\tret = dw_mci_prepare_desc64(host, host->data, sg_len);\n\telse\n\t\tret = dw_mci_prepare_desc32(host, host->data, sg_len);\n\n\tif (ret)\n\t\tgoto out;\n\n\t \n\twmb();\n\n\t \n\tdw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET);\n\tdw_mci_idmac_reset(host);\n\n\t \n\ttemp = mci_readl(host, CTRL);\n\ttemp |= SDMMC_CTRL_USE_IDMAC;\n\tmci_writel(host, CTRL, temp);\n\n\t \n\twmb();\n\n\t \n\ttemp = mci_readl(host, BMOD);\n\ttemp |= SDMMC_IDMAC_ENABLE | SDMMC_IDMAC_FB;\n\tmci_writel(host, BMOD, temp);\n\n\t \n\tmci_writel(host, PLDMND, 1);\n\nout:\n\treturn ret;\n}\n\nstatic const struct dw_mci_dma_ops dw_mci_idmac_ops = {\n\t.init = dw_mci_idmac_init,\n\t.start = dw_mci_idmac_start_dma,\n\t.stop = dw_mci_idmac_stop_dma,\n\t.complete = dw_mci_dmac_complete_dma,\n\t.cleanup = dw_mci_dma_cleanup,\n};\n\nstatic void dw_mci_edmac_stop_dma(struct dw_mci *host)\n{\n\tdmaengine_terminate_async(host->dms->ch);\n}\n\nstatic int dw_mci_edmac_start_dma(struct dw_mci *host,\n\t\t\t\t\t    unsigned int sg_len)\n{\n\tstruct dma_slave_config cfg;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct scatterlist *sgl = host->data->sg;\n\tstatic const u32 mszs[] = {1, 4, 8, 16, 32, 64, 128, 256};\n\tu32 sg_elems = host->data->sg_len;\n\tu32 fifoth_val;\n\tu32 fifo_offset = host->fifo_reg - host->regs;\n\tint ret = 0;\n\n\t \n\tmemset(&cfg, 0, sizeof(cfg));\n\tcfg.dst_addr = host->phy_regs + fifo_offset;\n\tcfg.src_addr = cfg.dst_addr;\n\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\t \n\tfifoth_val = mci_readl(host, FIFOTH);\n\tcfg.dst_maxburst = mszs[(fifoth_val >> 28) & 0x7];\n\tcfg.src_maxburst = cfg.dst_maxburst;\n\n\tif (host->data->flags & MMC_DATA_WRITE)\n\t\tcfg.direction = DMA_MEM_TO_DEV;\n\telse\n\t\tcfg.direction = DMA_DEV_TO_MEM;\n\n\tret = dmaengine_slave_config(host->dms->ch, &cfg);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Failed to config edmac.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tdesc = dmaengine_prep_slave_sg(host->dms->ch, sgl,\n\t\t\t\t       sg_len, cfg.direction,\n\t\t\t\t       DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(host->dev, \"Can't prepare slave sg.\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tdesc->callback = dw_mci_dmac_complete_dma;\n\tdesc->callback_param = (void *)host;\n\tdmaengine_submit(desc);\n\n\t \n\tif (host->data->flags & MMC_DATA_WRITE)\n\t\tdma_sync_sg_for_device(mmc_dev(host->slot->mmc), sgl,\n\t\t\t\t       sg_elems, DMA_TO_DEVICE);\n\n\tdma_async_issue_pending(host->dms->ch);\n\n\treturn 0;\n}\n\nstatic int dw_mci_edmac_init(struct dw_mci *host)\n{\n\t \n\thost->dms = kzalloc(sizeof(struct dw_mci_dma_slave), GFP_KERNEL);\n\tif (!host->dms)\n\t\treturn -ENOMEM;\n\n\thost->dms->ch = dma_request_chan(host->dev, \"rx-tx\");\n\tif (IS_ERR(host->dms->ch)) {\n\t\tint ret = PTR_ERR(host->dms->ch);\n\n\t\tdev_err(host->dev, \"Failed to get external DMA channel.\\n\");\n\t\tkfree(host->dms);\n\t\thost->dms = NULL;\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_mci_edmac_exit(struct dw_mci *host)\n{\n\tif (host->dms) {\n\t\tif (host->dms->ch) {\n\t\t\tdma_release_channel(host->dms->ch);\n\t\t\thost->dms->ch = NULL;\n\t\t}\n\t\tkfree(host->dms);\n\t\thost->dms = NULL;\n\t}\n}\n\nstatic const struct dw_mci_dma_ops dw_mci_edmac_ops = {\n\t.init = dw_mci_edmac_init,\n\t.exit = dw_mci_edmac_exit,\n\t.start = dw_mci_edmac_start_dma,\n\t.stop = dw_mci_edmac_stop_dma,\n\t.complete = dw_mci_dmac_complete_dma,\n\t.cleanup = dw_mci_dma_cleanup,\n};\n\nstatic int dw_mci_pre_dma_transfer(struct dw_mci *host,\n\t\t\t\t   struct mmc_data *data,\n\t\t\t\t   int cookie)\n{\n\tstruct scatterlist *sg;\n\tunsigned int i, sg_len;\n\n\tif (data->host_cookie == COOKIE_PRE_MAPPED)\n\t\treturn data->sg_len;\n\n\t \n\tif (data->blocks * data->blksz < DW_MCI_DMA_THRESHOLD)\n\t\treturn -EINVAL;\n\n\tif (data->blksz & 3)\n\t\treturn -EINVAL;\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (sg->offset & 3 || sg->length & 3)\n\t\t\treturn -EINVAL;\n\t}\n\n\tsg_len = dma_map_sg(host->dev,\n\t\t\t    data->sg,\n\t\t\t    data->sg_len,\n\t\t\t    mmc_get_dma_dir(data));\n\tif (sg_len == 0)\n\t\treturn -EINVAL;\n\n\tdata->host_cookie = cookie;\n\n\treturn sg_len;\n}\n\nstatic void dw_mci_pre_req(struct mmc_host *mmc,\n\t\t\t   struct mmc_request *mrq)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!slot->host->use_dma || !data)\n\t\treturn;\n\n\t \n\tdata->host_cookie = COOKIE_UNMAPPED;\n\n\tif (dw_mci_pre_dma_transfer(slot->host, mrq->data,\n\t\t\t\tCOOKIE_PRE_MAPPED) < 0)\n\t\tdata->host_cookie = COOKIE_UNMAPPED;\n}\n\nstatic void dw_mci_post_req(struct mmc_host *mmc,\n\t\t\t    struct mmc_request *mrq,\n\t\t\t    int err)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!slot->host->use_dma || !data)\n\t\treturn;\n\n\tif (data->host_cookie != COOKIE_UNMAPPED)\n\t\tdma_unmap_sg(slot->host->dev,\n\t\t\t     data->sg,\n\t\t\t     data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\tdata->host_cookie = COOKIE_UNMAPPED;\n}\n\nstatic int dw_mci_get_cd(struct mmc_host *mmc)\n{\n\tint present;\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tint gpio_cd = mmc_gpio_get_cd(mmc);\n\n\t \n\tif (((mmc->caps & MMC_CAP_NEEDS_POLL)\n\t\t\t\t|| !mmc_card_is_removable(mmc))) {\n\t\tpresent = 1;\n\n\t\tif (!test_bit(DW_MMC_CARD_PRESENT, &slot->flags)) {\n\t\t\tif (mmc->caps & MMC_CAP_NEEDS_POLL) {\n\t\t\t\tdev_info(&mmc->class_dev,\n\t\t\t\t\t\"card is polling.\\n\");\n\t\t\t} else {\n\t\t\t\tdev_info(&mmc->class_dev,\n\t\t\t\t\t\"card is non-removable.\\n\");\n\t\t\t}\n\t\t\tset_bit(DW_MMC_CARD_PRESENT, &slot->flags);\n\t\t}\n\n\t\treturn present;\n\t} else if (gpio_cd >= 0)\n\t\tpresent = gpio_cd;\n\telse\n\t\tpresent = (mci_readl(slot->host, CDETECT) & (1 << slot->id))\n\t\t\t== 0 ? 1 : 0;\n\n\tspin_lock_bh(&host->lock);\n\tif (present && !test_and_set_bit(DW_MMC_CARD_PRESENT, &slot->flags))\n\t\tdev_dbg(&mmc->class_dev, \"card is present\\n\");\n\telse if (!present &&\n\t\t\t!test_and_clear_bit(DW_MMC_CARD_PRESENT, &slot->flags))\n\t\tdev_dbg(&mmc->class_dev, \"card is not present\\n\");\n\tspin_unlock_bh(&host->lock);\n\n\treturn present;\n}\n\nstatic void dw_mci_adjust_fifoth(struct dw_mci *host, struct mmc_data *data)\n{\n\tunsigned int blksz = data->blksz;\n\tstatic const u32 mszs[] = {1, 4, 8, 16, 32, 64, 128, 256};\n\tu32 fifo_width = 1 << host->data_shift;\n\tu32 blksz_depth = blksz / fifo_width, fifoth_val;\n\tu32 msize = 0, rx_wmark = 1, tx_wmark, tx_wmark_invers;\n\tint idx = ARRAY_SIZE(mszs) - 1;\n\n\t \n\tif (!host->use_dma)\n\t\treturn;\n\n\ttx_wmark = (host->fifo_depth) / 2;\n\ttx_wmark_invers = host->fifo_depth - tx_wmark;\n\n\t \n\tif (blksz % fifo_width)\n\t\tgoto done;\n\n\tdo {\n\t\tif (!((blksz_depth % mszs[idx]) ||\n\t\t     (tx_wmark_invers % mszs[idx]))) {\n\t\t\tmsize = idx;\n\t\t\trx_wmark = mszs[idx] - 1;\n\t\t\tbreak;\n\t\t}\n\t} while (--idx > 0);\n\t \ndone:\n\tfifoth_val = SDMMC_SET_FIFOTH(msize, rx_wmark, tx_wmark);\n\tmci_writel(host, FIFOTH, fifoth_val);\n}\n\nstatic void dw_mci_ctrl_thld(struct dw_mci *host, struct mmc_data *data)\n{\n\tunsigned int blksz = data->blksz;\n\tu32 blksz_depth, fifo_depth;\n\tu16 thld_size;\n\tu8 enable;\n\n\t \n\tif (host->verid < DW_MMC_240A ||\n\t\t(host->verid < DW_MMC_280A && data->flags & MMC_DATA_WRITE))\n\t\treturn;\n\n\t \n\tif (data->flags & MMC_DATA_WRITE &&\n\t\thost->timing != MMC_TIMING_MMC_HS400)\n\t\tgoto disable;\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\tenable = SDMMC_CARD_WR_THR_EN;\n\telse\n\t\tenable = SDMMC_CARD_RD_THR_EN;\n\n\tif (host->timing != MMC_TIMING_MMC_HS200 &&\n\t    host->timing != MMC_TIMING_UHS_SDR104 &&\n\t    host->timing != MMC_TIMING_MMC_HS400)\n\t\tgoto disable;\n\n\tblksz_depth = blksz / (1 << host->data_shift);\n\tfifo_depth = host->fifo_depth;\n\n\tif (blksz_depth > fifo_depth)\n\t\tgoto disable;\n\n\t \n\tthld_size = blksz;\n\tmci_writel(host, CDTHRCTL, SDMMC_SET_THLD(thld_size, enable));\n\treturn;\n\ndisable:\n\tmci_writel(host, CDTHRCTL, 0);\n}\n\nstatic int dw_mci_submit_data_dma(struct dw_mci *host, struct mmc_data *data)\n{\n\tunsigned long irqflags;\n\tint sg_len;\n\tu32 temp;\n\n\thost->using_dma = 0;\n\n\t \n\tif (!host->use_dma)\n\t\treturn -ENODEV;\n\n\tsg_len = dw_mci_pre_dma_transfer(host, data, COOKIE_MAPPED);\n\tif (sg_len < 0) {\n\t\thost->dma_ops->stop(host);\n\t\treturn sg_len;\n\t}\n\n\thost->using_dma = 1;\n\n\tif (host->use_dma == TRANS_MODE_IDMAC)\n\t\tdev_vdbg(host->dev,\n\t\t\t \"sd sg_cpu: %#lx sg_dma: %#lx sg_len: %d\\n\",\n\t\t\t (unsigned long)host->sg_cpu,\n\t\t\t (unsigned long)host->sg_dma,\n\t\t\t sg_len);\n\n\t \n\tif (host->prev_blksz != data->blksz)\n\t\tdw_mci_adjust_fifoth(host, data);\n\n\t \n\ttemp = mci_readl(host, CTRL);\n\ttemp |= SDMMC_CTRL_DMA_ENABLE;\n\tmci_writel(host, CTRL, temp);\n\n\t \n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\ttemp = mci_readl(host, INTMASK);\n\ttemp  &= ~(SDMMC_INT_RXDR | SDMMC_INT_TXDR);\n\tmci_writel(host, INTMASK, temp);\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\n\tif (host->dma_ops->start(host, sg_len)) {\n\t\thost->dma_ops->stop(host);\n\t\t \n\t\tdev_dbg(host->dev,\n\t\t\t\"%s: fall back to PIO mode for current transfer\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_mci_submit_data(struct dw_mci *host, struct mmc_data *data)\n{\n\tunsigned long irqflags;\n\tint flags = SG_MITER_ATOMIC;\n\tu32 temp;\n\n\tdata->error = -EINPROGRESS;\n\n\tWARN_ON(host->data);\n\thost->sg = NULL;\n\thost->data = data;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\thost->dir_status = DW_MCI_RECV_STATUS;\n\telse\n\t\thost->dir_status = DW_MCI_SEND_STATUS;\n\n\tdw_mci_ctrl_thld(host, data);\n\n\tif (dw_mci_submit_data_dma(host, data)) {\n\t\tif (host->data->flags & MMC_DATA_READ)\n\t\t\tflags |= SG_MITER_TO_SG;\n\t\telse\n\t\t\tflags |= SG_MITER_FROM_SG;\n\n\t\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n\t\thost->sg = data->sg;\n\t\thost->part_buf_start = 0;\n\t\thost->part_buf_count = 0;\n\n\t\tmci_writel(host, RINTSTS, SDMMC_INT_TXDR | SDMMC_INT_RXDR);\n\n\t\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\t\ttemp = mci_readl(host, INTMASK);\n\t\ttemp |= SDMMC_INT_TXDR | SDMMC_INT_RXDR;\n\t\tmci_writel(host, INTMASK, temp);\n\t\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\n\t\ttemp = mci_readl(host, CTRL);\n\t\ttemp &= ~SDMMC_CTRL_DMA_ENABLE;\n\t\tmci_writel(host, CTRL, temp);\n\n\t\t \n\t\tif (host->wm_aligned)\n\t\t\tdw_mci_adjust_fifoth(host, data);\n\t\telse\n\t\t\tmci_writel(host, FIFOTH, host->fifoth_val);\n\t\thost->prev_blksz = 0;\n\t} else {\n\t\t \n\t\thost->prev_blksz = data->blksz;\n\t}\n}\n\nstatic void dw_mci_setup_bus(struct dw_mci_slot *slot, bool force_clkinit)\n{\n\tstruct dw_mci *host = slot->host;\n\tunsigned int clock = slot->clock;\n\tu32 div;\n\tu32 clk_en_a;\n\tu32 sdmmc_cmd_bits = SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT;\n\n\t \n\tif (host->state == STATE_WAITING_CMD11_DONE)\n\t\tsdmmc_cmd_bits |= SDMMC_CMD_VOLT_SWITCH;\n\n\tslot->mmc->actual_clock = 0;\n\n\tif (!clock) {\n\t\tmci_writel(host, CLKENA, 0);\n\t\tmci_send_cmd(slot, sdmmc_cmd_bits, 0);\n\t} else if (clock != host->current_speed || force_clkinit) {\n\t\tdiv = host->bus_hz / clock;\n\t\tif (host->bus_hz % clock && host->bus_hz > clock)\n\t\t\t \n\t\t\tdiv += 1;\n\n\t\tdiv = (host->bus_hz != clock) ? DIV_ROUND_UP(div, 2) : 0;\n\n\t\tif ((clock != slot->__clk_old &&\n\t\t\t!test_bit(DW_MMC_CARD_NEEDS_POLL, &slot->flags)) ||\n\t\t\tforce_clkinit) {\n\t\t\t \n\t\t\tif (!force_clkinit)\n\t\t\t\tdev_info(&slot->mmc->class_dev,\n\t\t\t\t\t \"Bus speed (slot %d) = %dHz (slot req %dHz, actual %dHZ div = %d)\\n\",\n\t\t\t\t\t slot->id, host->bus_hz, clock,\n\t\t\t\t\t div ? ((host->bus_hz / div) >> 1) :\n\t\t\t\t\t host->bus_hz, div);\n\n\t\t\t \n\t\t\tif (slot->mmc->caps & MMC_CAP_NEEDS_POLL &&\n\t\t\t\t\tslot->mmc->f_min == clock)\n\t\t\t\tset_bit(DW_MMC_CARD_NEEDS_POLL, &slot->flags);\n\t\t}\n\n\t\t \n\t\tmci_writel(host, CLKENA, 0);\n\t\tmci_writel(host, CLKSRC, 0);\n\n\t\t \n\t\tmci_send_cmd(slot, sdmmc_cmd_bits, 0);\n\n\t\t \n\t\tmci_writel(host, CLKDIV, div);\n\n\t\t \n\t\tmci_send_cmd(slot, sdmmc_cmd_bits, 0);\n\n\t\t \n\t\tclk_en_a = SDMMC_CLKEN_ENABLE << slot->id;\n\t\tif (!test_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags))\n\t\t\tclk_en_a |= SDMMC_CLKEN_LOW_PWR << slot->id;\n\t\tmci_writel(host, CLKENA, clk_en_a);\n\n\t\t \n\t\tmci_send_cmd(slot, sdmmc_cmd_bits, 0);\n\n\t\t \n\t\tslot->__clk_old = clock;\n\t\tslot->mmc->actual_clock = div ? ((host->bus_hz / div) >> 1) :\n\t\t\t\t\t  host->bus_hz;\n\t}\n\n\thost->current_speed = clock;\n\n\t \n\tmci_writel(host, CTYPE, (slot->ctype << slot->id));\n}\n\nstatic void dw_mci_set_data_timeout(struct dw_mci *host,\n\t\t\t\t    unsigned int timeout_ns)\n{\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tu32 clk_div, tmout;\n\tu64 tmp;\n\n\tif (drv_data && drv_data->set_data_timeout)\n\t\treturn drv_data->set_data_timeout(host, timeout_ns);\n\n\tclk_div = (mci_readl(host, CLKDIV) & 0xFF) * 2;\n\tif (clk_div == 0)\n\t\tclk_div = 1;\n\n\ttmp = DIV_ROUND_UP_ULL((u64)timeout_ns * host->bus_hz, NSEC_PER_SEC);\n\ttmp = DIV_ROUND_UP_ULL(tmp, clk_div);\n\n\t \n\ttmout = 0xFF;  \n\n\t \n\tif (!tmp || tmp > 0xFFFFFF)\n\t\ttmout |= (0xFFFFFF << 8);\n\telse\n\t\ttmout |= (tmp & 0xFFFFFF) << 8;\n\n\tmci_writel(host, TMOUT, tmout);\n\tdev_dbg(host->dev, \"timeout_ns: %u => TMOUT[31:8]: %#08x\",\n\t\ttimeout_ns, tmout >> 8);\n}\n\nstatic void __dw_mci_start_request(struct dw_mci *host,\n\t\t\t\t   struct dw_mci_slot *slot,\n\t\t\t\t   struct mmc_command *cmd)\n{\n\tstruct mmc_request *mrq;\n\tstruct mmc_data\t*data;\n\tu32 cmdflags;\n\n\tmrq = slot->mrq;\n\n\thost->mrq = mrq;\n\n\thost->pending_events = 0;\n\thost->completed_events = 0;\n\thost->cmd_status = 0;\n\thost->data_status = 0;\n\thost->dir_status = 0;\n\n\tdata = cmd->data;\n\tif (data) {\n\t\tdw_mci_set_data_timeout(host, data->timeout_ns);\n\t\tmci_writel(host, BYTCNT, data->blksz*data->blocks);\n\t\tmci_writel(host, BLKSIZ, data->blksz);\n\t}\n\n\tcmdflags = dw_mci_prepare_command(slot->mmc, cmd);\n\n\t \n\tif (test_and_clear_bit(DW_MMC_CARD_NEED_INIT, &slot->flags))\n\t\tcmdflags |= SDMMC_CMD_INIT;\n\n\tif (data) {\n\t\tdw_mci_submit_data(host, data);\n\t\twmb();  \n\t}\n\n\tdw_mci_start_command(host, cmd, cmdflags);\n\n\tif (cmd->opcode == SD_SWITCH_VOLTAGE) {\n\t\tunsigned long irqflags;\n\n\t\t \n\t\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\t\tif (!test_bit(EVENT_CMD_COMPLETE, &host->pending_events))\n\t\t\tmod_timer(&host->cmd11_timer,\n\t\t\t\tjiffies + msecs_to_jiffies(500) + 1);\n\t\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\t}\n\n\thost->stop_cmdr = dw_mci_prep_stop_abort(host, cmd);\n}\n\nstatic void dw_mci_start_request(struct dw_mci *host,\n\t\t\t\t struct dw_mci_slot *slot)\n{\n\tstruct mmc_request *mrq = slot->mrq;\n\tstruct mmc_command *cmd;\n\n\tcmd = mrq->sbc ? mrq->sbc : mrq->cmd;\n\t__dw_mci_start_request(host, slot, cmd);\n}\n\n \nstatic void dw_mci_queue_request(struct dw_mci *host, struct dw_mci_slot *slot,\n\t\t\t\t struct mmc_request *mrq)\n{\n\tdev_vdbg(&slot->mmc->class_dev, \"queue request: state=%d\\n\",\n\t\t host->state);\n\n\tslot->mrq = mrq;\n\n\tif (host->state == STATE_WAITING_CMD11_DONE) {\n\t\tdev_warn(&slot->mmc->class_dev,\n\t\t\t \"Voltage change didn't complete\\n\");\n\t\t \n\t\thost->state = STATE_IDLE;\n\t}\n\n\tif (host->state == STATE_IDLE) {\n\t\thost->state = STATE_SENDING_CMD;\n\t\tdw_mci_start_request(host, slot);\n\t} else {\n\t\tlist_add_tail(&slot->queue_node, &host->queue);\n\t}\n}\n\nstatic void dw_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\n\tWARN_ON(slot->mrq);\n\n\t \n\n\tif (!dw_mci_get_cd(mmc)) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&host->lock);\n\n\tdw_mci_queue_request(host, slot, mrq);\n\n\tspin_unlock_bh(&host->lock);\n}\n\nstatic void dw_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tconst struct dw_mci_drv_data *drv_data = slot->host->drv_data;\n\tu32 regs;\n\tint ret;\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_4:\n\t\tslot->ctype = SDMMC_CTYPE_4BIT;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tslot->ctype = SDMMC_CTYPE_8BIT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tslot->ctype = SDMMC_CTYPE_1BIT;\n\t}\n\n\tregs = mci_readl(slot->host, UHS_REG);\n\n\t \n\tif (ios->timing == MMC_TIMING_MMC_DDR52 ||\n\t    ios->timing == MMC_TIMING_UHS_DDR50 ||\n\t    ios->timing == MMC_TIMING_MMC_HS400)\n\t\tregs |= ((0x1 << slot->id) << 16);\n\telse\n\t\tregs &= ~((0x1 << slot->id) << 16);\n\n\tmci_writel(slot->host, UHS_REG, regs);\n\tslot->host->timing = ios->timing;\n\n\t \n\tslot->clock = ios->clock;\n\n\tif (drv_data && drv_data->set_ios)\n\t\tdrv_data->set_ios(slot->host, ios);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_UP:\n\t\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\t\tret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc,\n\t\t\t\t\tios->vdd);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(slot->host->dev,\n\t\t\t\t\t\"failed to enable vmmc regulator\\n\");\n\t\t\t\t \n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tset_bit(DW_MMC_CARD_NEED_INIT, &slot->flags);\n\t\tregs = mci_readl(slot->host, PWREN);\n\t\tregs |= (1 << slot->id);\n\t\tmci_writel(slot->host, PWREN, regs);\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tif (!slot->host->vqmmc_enabled) {\n\t\t\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\t\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tdev_err(slot->host->dev,\n\t\t\t\t\t\t\"failed to enable vqmmc\\n\");\n\t\t\t\telse\n\t\t\t\t\tslot->host->vqmmc_enabled = true;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tslot->host->vqmmc_enabled = true;\n\t\t\t}\n\n\t\t\t \n\t\t\tdw_mci_ctrl_reset(slot->host,\n\t\t\t\t\t  SDMMC_CTRL_ALL_RESET_FLAGS);\n\t\t}\n\n\t\t \n\t\tdw_mci_setup_bus(slot, false);\n\n\t\tbreak;\n\tcase MMC_POWER_OFF:\n\t\t \n\t\tdw_mci_setup_bus(slot, false);\n\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && slot->host->vqmmc_enabled)\n\t\t\tregulator_disable(mmc->supply.vqmmc);\n\t\tslot->host->vqmmc_enabled = false;\n\n\t\tregs = mci_readl(slot->host, PWREN);\n\t\tregs &= ~(1 << slot->id);\n\t\tmci_writel(slot->host, PWREN, regs);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (slot->host->state == STATE_WAITING_CMD11_DONE && ios->clock != 0)\n\t\tslot->host->state = STATE_IDLE;\n}\n\nstatic int dw_mci_card_busy(struct mmc_host *mmc)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tu32 status;\n\n\t \n\tstatus = mci_readl(slot->host, STATUS);\n\n\treturn !!(status & SDMMC_STATUS_BUSY);\n}\n\nstatic int dw_mci_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tu32 uhs;\n\tu32 v18 = SDMMC_UHS_18V << slot->id;\n\tint ret;\n\n\tif (drv_data && drv_data->switch_voltage)\n\t\treturn drv_data->switch_voltage(mmc, ios);\n\n\t \n\tuhs = mci_readl(host, UHS_REG);\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\tuhs &= ~v18;\n\telse\n\t\tuhs |= v18;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\tif (ret < 0) {\n\t\t\tdev_dbg(&mmc->class_dev,\n\t\t\t\t\t \"Regulator set error %d - %s V\\n\",\n\t\t\t\t\t ret, uhs & v18 ? \"1.8\" : \"3.3\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\tmci_writel(host, UHS_REG, uhs);\n\n\treturn 0;\n}\n\nstatic int dw_mci_get_ro(struct mmc_host *mmc)\n{\n\tint read_only;\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tint gpio_ro = mmc_gpio_get_ro(mmc);\n\n\t \n\tif (gpio_ro >= 0)\n\t\tread_only = gpio_ro;\n\telse\n\t\tread_only =\n\t\t\tmci_readl(slot->host, WRTPRT) & (1 << slot->id) ? 1 : 0;\n\n\tdev_dbg(&mmc->class_dev, \"card is %s\\n\",\n\t\tread_only ? \"read-only\" : \"read-write\");\n\n\treturn read_only;\n}\n\nstatic void dw_mci_hw_reset(struct mmc_host *mmc)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tint reset;\n\n\tif (host->use_dma == TRANS_MODE_IDMAC)\n\t\tdw_mci_idmac_reset(host);\n\n\tif (!dw_mci_ctrl_reset(host, SDMMC_CTRL_DMA_RESET |\n\t\t\t\t     SDMMC_CTRL_FIFO_RESET))\n\t\treturn;\n\n\t \n\treset = mci_readl(host, RST_N);\n\treset &= ~(SDMMC_RST_HWACTIVE << slot->id);\n\tmci_writel(host, RST_N, reset);\n\tusleep_range(1, 2);\n\treset |= SDMMC_RST_HWACTIVE << slot->id;\n\tmci_writel(host, RST_N, reset);\n\tusleep_range(200, 300);\n}\n\nstatic void dw_mci_prepare_sdio_irq(struct dw_mci_slot *slot, bool prepare)\n{\n\tstruct dw_mci *host = slot->host;\n\tconst u32 clken_low_pwr = SDMMC_CLKEN_LOW_PWR << slot->id;\n\tu32 clk_en_a_old;\n\tu32 clk_en_a;\n\n\t \n\n\tclk_en_a_old = mci_readl(host, CLKENA);\n\tif (prepare) {\n\t\tset_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags);\n\t\tclk_en_a = clk_en_a_old & ~clken_low_pwr;\n\t} else {\n\t\tclear_bit(DW_MMC_CARD_NO_LOW_PWR, &slot->flags);\n\t\tclk_en_a = clk_en_a_old | clken_low_pwr;\n\t}\n\n\tif (clk_en_a != clk_en_a_old) {\n\t\tmci_writel(host, CLKENA, clk_en_a);\n\t\tmci_send_cmd(slot, SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT,\n\t\t\t     0);\n\t}\n}\n\nstatic void __dw_mci_enable_sdio_irq(struct dw_mci_slot *slot, int enb)\n{\n\tstruct dw_mci *host = slot->host;\n\tunsigned long irqflags;\n\tu32 int_mask;\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\n\t \n\tint_mask = mci_readl(host, INTMASK);\n\tif (enb)\n\t\tint_mask |= SDMMC_INT_SDIO(slot->sdio_id);\n\telse\n\t\tint_mask &= ~SDMMC_INT_SDIO(slot->sdio_id);\n\tmci_writel(host, INTMASK, int_mask);\n\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n}\n\nstatic void dw_mci_enable_sdio_irq(struct mmc_host *mmc, int enb)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\n\tdw_mci_prepare_sdio_irq(slot, enb);\n\t__dw_mci_enable_sdio_irq(slot, enb);\n\n\t \n\tif (enb)\n\t\tpm_runtime_get_noresume(host->dev);\n\telse\n\t\tpm_runtime_put_noidle(host->dev);\n}\n\nstatic void dw_mci_ack_sdio_irq(struct mmc_host *mmc)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\n\t__dw_mci_enable_sdio_irq(slot, 1);\n}\n\nstatic int dw_mci_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tint err = -EINVAL;\n\n\tif (drv_data && drv_data->execute_tuning)\n\t\terr = drv_data->execute_tuning(slot, opcode);\n\treturn err;\n}\n\nstatic int dw_mci_prepare_hs400_tuning(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct dw_mci *host = slot->host;\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\n\tif (drv_data && drv_data->prepare_hs400_tuning)\n\t\treturn drv_data->prepare_hs400_tuning(host, ios);\n\n\treturn 0;\n}\n\nstatic bool dw_mci_reset(struct dw_mci *host)\n{\n\tu32 flags = SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET;\n\tbool ret = false;\n\tu32 status = 0;\n\n\t \n\tif (host->sg) {\n\t\tsg_miter_stop(&host->sg_miter);\n\t\thost->sg = NULL;\n\t}\n\n\tif (host->use_dma)\n\t\tflags |= SDMMC_CTRL_DMA_RESET;\n\n\tif (dw_mci_ctrl_reset(host, flags)) {\n\t\t \n\t\tmci_writel(host, RINTSTS, 0xFFFFFFFF);\n\n\t\tif (!host->use_dma) {\n\t\t\tret = true;\n\t\t\tgoto ciu_out;\n\t\t}\n\n\t\t \n\t\tif (readl_poll_timeout_atomic(host->regs + SDMMC_STATUS,\n\t\t\t\t\t      status,\n\t\t\t\t\t      !(status & SDMMC_STATUS_DMA_REQ),\n\t\t\t\t\t      1, 500 * USEC_PER_MSEC)) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"%s: Timeout waiting for dma_req to be cleared\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto ciu_out;\n\t\t}\n\n\t\t \n\t\tif (!dw_mci_ctrl_reset(host, SDMMC_CTRL_FIFO_RESET))\n\t\t\tgoto ciu_out;\n\t} else {\n\t\t \n\t\tif (!(mci_readl(host, CTRL) & SDMMC_CTRL_RESET)) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"%s: fifo/dma reset bits didn't clear but ciu was reset, doing clock update\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto ciu_out;\n\t\t}\n\t}\n\n\tif (host->use_dma == TRANS_MODE_IDMAC)\n\t\t \n\t\tdw_mci_idmac_init(host);\n\n\tret = true;\n\nciu_out:\n\t \n\tmci_send_cmd(host->slot, SDMMC_CMD_UPD_CLK, 0);\n\n\treturn ret;\n}\n\nstatic const struct mmc_host_ops dw_mci_ops = {\n\t.request\t\t= dw_mci_request,\n\t.pre_req\t\t= dw_mci_pre_req,\n\t.post_req\t\t= dw_mci_post_req,\n\t.set_ios\t\t= dw_mci_set_ios,\n\t.get_ro\t\t\t= dw_mci_get_ro,\n\t.get_cd\t\t\t= dw_mci_get_cd,\n\t.card_hw_reset          = dw_mci_hw_reset,\n\t.enable_sdio_irq\t= dw_mci_enable_sdio_irq,\n\t.ack_sdio_irq\t\t= dw_mci_ack_sdio_irq,\n\t.execute_tuning\t\t= dw_mci_execute_tuning,\n\t.card_busy\t\t= dw_mci_card_busy,\n\t.start_signal_voltage_switch = dw_mci_switch_voltage,\n\t.prepare_hs400_tuning\t= dw_mci_prepare_hs400_tuning,\n};\n\n#ifdef CONFIG_FAULT_INJECTION\nstatic enum hrtimer_restart dw_mci_fault_timer(struct hrtimer *t)\n{\n\tstruct dw_mci *host = container_of(t, struct dw_mci, fault_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->irq_lock, flags);\n\n\t \n\tif (!host->data_status) {\n\t\thost->data_status = SDMMC_INT_DCRC;\n\t\tset_bit(EVENT_DATA_ERROR, &host->pending_events);\n\t\ttasklet_schedule(&host->tasklet);\n\t}\n\n\tspin_unlock_irqrestore(&host->irq_lock, flags);\n\n\treturn HRTIMER_NORESTART;\n}\n\nstatic void dw_mci_start_fault_timer(struct dw_mci *host)\n{\n\tstruct mmc_data *data = host->data;\n\n\tif (!data || data->blocks <= 1)\n\t\treturn;\n\n\tif (!should_fail(&host->fail_data_crc, 1))\n\t\treturn;\n\n\t \n\thrtimer_start(&host->fault_timer,\n\t\t      ms_to_ktime(get_random_u32_below(25)),\n\t\t      HRTIMER_MODE_REL);\n}\n\nstatic void dw_mci_stop_fault_timer(struct dw_mci *host)\n{\n\thrtimer_cancel(&host->fault_timer);\n}\n\nstatic void dw_mci_init_fault(struct dw_mci *host)\n{\n\thost->fail_data_crc = (struct fault_attr) FAULT_ATTR_INITIALIZER;\n\n\thrtimer_init(&host->fault_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\thost->fault_timer.function = dw_mci_fault_timer;\n}\n#else\nstatic void dw_mci_init_fault(struct dw_mci *host)\n{\n}\n\nstatic void dw_mci_start_fault_timer(struct dw_mci *host)\n{\n}\n\nstatic void dw_mci_stop_fault_timer(struct dw_mci *host)\n{\n}\n#endif\n\nstatic void dw_mci_request_end(struct dw_mci *host, struct mmc_request *mrq)\n\t__releases(&host->lock)\n\t__acquires(&host->lock)\n{\n\tstruct dw_mci_slot *slot;\n\tstruct mmc_host\t*prev_mmc = host->slot->mmc;\n\n\tWARN_ON(host->cmd || host->data);\n\n\thost->slot->mrq = NULL;\n\thost->mrq = NULL;\n\tif (!list_empty(&host->queue)) {\n\t\tslot = list_entry(host->queue.next,\n\t\t\t\t  struct dw_mci_slot, queue_node);\n\t\tlist_del(&slot->queue_node);\n\t\tdev_vdbg(host->dev, \"list not empty: %s is next\\n\",\n\t\t\t mmc_hostname(slot->mmc));\n\t\thost->state = STATE_SENDING_CMD;\n\t\tdw_mci_start_request(host, slot);\n\t} else {\n\t\tdev_vdbg(host->dev, \"list empty\\n\");\n\n\t\tif (host->state == STATE_SENDING_CMD11)\n\t\t\thost->state = STATE_WAITING_CMD11_DONE;\n\t\telse\n\t\t\thost->state = STATE_IDLE;\n\t}\n\n\tspin_unlock(&host->lock);\n\tmmc_request_done(prev_mmc, mrq);\n\tspin_lock(&host->lock);\n}\n\nstatic int dw_mci_command_complete(struct dw_mci *host, struct mmc_command *cmd)\n{\n\tu32 status = host->cmd_status;\n\n\thost->cmd_status = 0;\n\n\t \n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\tcmd->resp[3] = mci_readl(host, RESP0);\n\t\t\tcmd->resp[2] = mci_readl(host, RESP1);\n\t\t\tcmd->resp[1] = mci_readl(host, RESP2);\n\t\t\tcmd->resp[0] = mci_readl(host, RESP3);\n\t\t} else {\n\t\t\tcmd->resp[0] = mci_readl(host, RESP0);\n\t\t\tcmd->resp[1] = 0;\n\t\t\tcmd->resp[2] = 0;\n\t\t\tcmd->resp[3] = 0;\n\t\t}\n\t}\n\n\tif (status & SDMMC_INT_RTO)\n\t\tcmd->error = -ETIMEDOUT;\n\telse if ((cmd->flags & MMC_RSP_CRC) && (status & SDMMC_INT_RCRC))\n\t\tcmd->error = -EILSEQ;\n\telse if (status & SDMMC_INT_RESP_ERR)\n\t\tcmd->error = -EIO;\n\telse\n\t\tcmd->error = 0;\n\n\treturn cmd->error;\n}\n\nstatic int dw_mci_data_complete(struct dw_mci *host, struct mmc_data *data)\n{\n\tu32 status = host->data_status;\n\n\tif (status & DW_MCI_DATA_ERROR_FLAGS) {\n\t\tif (status & SDMMC_INT_DRTO) {\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t} else if (status & SDMMC_INT_DCRC) {\n\t\t\tdata->error = -EILSEQ;\n\t\t} else if (status & SDMMC_INT_EBE) {\n\t\t\tif (host->dir_status ==\n\t\t\t\tDW_MCI_SEND_STATUS) {\n\t\t\t\t \n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\t} else if (host->dir_status ==\n\t\t\t\t\tDW_MCI_RECV_STATUS) {\n\t\t\t\tdata->error = -EILSEQ;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdata->error = -EILSEQ;\n\t\t}\n\n\t\tdev_dbg(host->dev, \"data error, status 0x%08x\\n\", status);\n\n\t\t \n\t\tdw_mci_reset(host);\n\t} else {\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\tdata->error = 0;\n\t}\n\n\treturn data->error;\n}\n\nstatic void dw_mci_set_drto(struct dw_mci *host)\n{\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tunsigned int drto_clks;\n\tunsigned int drto_div;\n\tunsigned int drto_ms;\n\tunsigned long irqflags;\n\n\tif (drv_data && drv_data->get_drto_clks)\n\t\tdrto_clks = drv_data->get_drto_clks(host);\n\telse\n\t\tdrto_clks = mci_readl(host, TMOUT) >> 8;\n\tdrto_div = (mci_readl(host, CLKDIV) & 0xff) * 2;\n\tif (drto_div == 0)\n\t\tdrto_div = 1;\n\n\tdrto_ms = DIV_ROUND_UP_ULL((u64)MSEC_PER_SEC * drto_clks * drto_div,\n\t\t\t\t   host->bus_hz);\n\n\tdev_dbg(host->dev, \"drto_ms: %u\\n\", drto_ms);\n\n\t \n\tdrto_ms += 10;\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\tif (!test_bit(EVENT_DATA_COMPLETE, &host->pending_events))\n\t\tmod_timer(&host->dto_timer,\n\t\t\t  jiffies + msecs_to_jiffies(drto_ms));\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n}\n\nstatic bool dw_mci_clear_pending_cmd_complete(struct dw_mci *host)\n{\n\tif (!test_bit(EVENT_CMD_COMPLETE, &host->pending_events))\n\t\treturn false;\n\n\t \n\tWARN_ON(del_timer_sync(&host->cto_timer));\n\tclear_bit(EVENT_CMD_COMPLETE, &host->pending_events);\n\n\treturn true;\n}\n\nstatic bool dw_mci_clear_pending_data_complete(struct dw_mci *host)\n{\n\tif (!test_bit(EVENT_DATA_COMPLETE, &host->pending_events))\n\t\treturn false;\n\n\t \n\tWARN_ON(del_timer_sync(&host->dto_timer));\n\tclear_bit(EVENT_DATA_COMPLETE, &host->pending_events);\n\n\treturn true;\n}\n\nstatic void dw_mci_tasklet_func(struct tasklet_struct *t)\n{\n\tstruct dw_mci *host = from_tasklet(host, t, tasklet);\n\tstruct mmc_data\t*data;\n\tstruct mmc_command *cmd;\n\tstruct mmc_request *mrq;\n\tenum dw_mci_state state;\n\tenum dw_mci_state prev_state;\n\tunsigned int err;\n\n\tspin_lock(&host->lock);\n\n\tstate = host->state;\n\tdata = host->data;\n\tmrq = host->mrq;\n\n\tdo {\n\t\tprev_state = state;\n\n\t\tswitch (state) {\n\t\tcase STATE_IDLE:\n\t\tcase STATE_WAITING_CMD11_DONE:\n\t\t\tbreak;\n\n\t\tcase STATE_SENDING_CMD11:\n\t\tcase STATE_SENDING_CMD:\n\t\t\tif (!dw_mci_clear_pending_cmd_complete(host))\n\t\t\t\tbreak;\n\n\t\t\tcmd = host->cmd;\n\t\t\thost->cmd = NULL;\n\t\t\tset_bit(EVENT_CMD_COMPLETE, &host->completed_events);\n\t\t\terr = dw_mci_command_complete(host, cmd);\n\t\t\tif (cmd == mrq->sbc && !err) {\n\t\t\t\t__dw_mci_start_request(host, host->slot,\n\t\t\t\t\t\t       mrq->cmd);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tif (cmd->data && err) {\n\t\t\t\t \n\t\t\t\tif (err != -ETIMEDOUT &&\n\t\t\t\t    host->dir_status == DW_MCI_RECV_STATUS) {\n\t\t\t\t\tstate = STATE_SENDING_DATA;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsend_stop_abort(host, data);\n\t\t\t\tdw_mci_stop_dma(host);\n\t\t\t\tstate = STATE_SENDING_STOP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!cmd->data || err) {\n\t\t\t\tdw_mci_request_end(host, mrq);\n\t\t\t\tgoto unlock;\n\t\t\t}\n\n\t\t\tprev_state = state = STATE_SENDING_DATA;\n\t\t\tfallthrough;\n\n\t\tcase STATE_SENDING_DATA:\n\t\t\t \n\t\t\tif (test_and_clear_bit(EVENT_DATA_ERROR,\n\t\t\t\t\t       &host->pending_events)) {\n\t\t\t\tif (!(host->data_status & (SDMMC_INT_DRTO |\n\t\t\t\t\t\t\t   SDMMC_INT_EBE)))\n\t\t\t\t\tsend_stop_abort(host, data);\n\t\t\t\tdw_mci_stop_dma(host);\n\t\t\t\tstate = STATE_DATA_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\t\t\t\t\t\t&host->pending_events)) {\n\t\t\t\t \n\t\t\t\tif (host->dir_status == DW_MCI_RECV_STATUS)\n\t\t\t\t\tdw_mci_set_drto(host);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tset_bit(EVENT_XFER_COMPLETE, &host->completed_events);\n\n\t\t\t \n\t\t\tif (test_and_clear_bit(EVENT_DATA_ERROR,\n\t\t\t\t\t       &host->pending_events)) {\n\t\t\t\tif (!(host->data_status & (SDMMC_INT_DRTO |\n\t\t\t\t\t\t\t   SDMMC_INT_EBE)))\n\t\t\t\t\tsend_stop_abort(host, data);\n\t\t\t\tdw_mci_stop_dma(host);\n\t\t\t\tstate = STATE_DATA_ERROR;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprev_state = state = STATE_DATA_BUSY;\n\n\t\t\tfallthrough;\n\n\t\tcase STATE_DATA_BUSY:\n\t\t\tif (!dw_mci_clear_pending_data_complete(host)) {\n\t\t\t\t \n\t\t\t\tif (host->dir_status == DW_MCI_RECV_STATUS)\n\t\t\t\t\tdw_mci_set_drto(host);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdw_mci_stop_fault_timer(host);\n\t\t\thost->data = NULL;\n\t\t\tset_bit(EVENT_DATA_COMPLETE, &host->completed_events);\n\t\t\terr = dw_mci_data_complete(host, data);\n\n\t\t\tif (!err) {\n\t\t\t\tif (!data->stop || mrq->sbc) {\n\t\t\t\t\tif (mrq->sbc && data->stop)\n\t\t\t\t\t\tdata->stop->error = 0;\n\t\t\t\t\tdw_mci_request_end(host, mrq);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (data->stop)\n\t\t\t\t\tsend_stop_abort(host, data);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!test_bit(EVENT_CMD_COMPLETE,\n\t\t\t\t\t      &host->pending_events)) {\n\t\t\t\t\thost->cmd = NULL;\n\t\t\t\t\tdw_mci_request_end(host, mrq);\n\t\t\t\t\tgoto unlock;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\tprev_state = state = STATE_SENDING_STOP;\n\n\t\t\tfallthrough;\n\n\t\tcase STATE_SENDING_STOP:\n\t\t\tif (!dw_mci_clear_pending_cmd_complete(host))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (mrq->cmd->error && mrq->data)\n\t\t\t\tdw_mci_reset(host);\n\n\t\t\tdw_mci_stop_fault_timer(host);\n\t\t\thost->cmd = NULL;\n\t\t\thost->data = NULL;\n\n\t\t\tif (!mrq->sbc && mrq->stop)\n\t\t\t\tdw_mci_command_complete(host, mrq->stop);\n\t\t\telse\n\t\t\t\thost->cmd_status = 0;\n\n\t\t\tdw_mci_request_end(host, mrq);\n\t\t\tgoto unlock;\n\n\t\tcase STATE_DATA_ERROR:\n\t\t\tif (!test_and_clear_bit(EVENT_XFER_COMPLETE,\n\t\t\t\t\t\t&host->pending_events))\n\t\t\t\tbreak;\n\n\t\t\tstate = STATE_DATA_BUSY;\n\t\t\tbreak;\n\t\t}\n\t} while (state != prev_state);\n\n\thost->state = state;\nunlock:\n\tspin_unlock(&host->lock);\n\n}\n\n \nstatic void dw_mci_set_part_bytes(struct dw_mci *host, void *buf, int cnt)\n{\n\tmemcpy((void *)&host->part_buf, buf, cnt);\n\thost->part_buf_count = cnt;\n}\n\n \nstatic int dw_mci_push_part_bytes(struct dw_mci *host, void *buf, int cnt)\n{\n\tcnt = min(cnt, (1 << host->data_shift) - host->part_buf_count);\n\tmemcpy((void *)&host->part_buf + host->part_buf_count, buf, cnt);\n\thost->part_buf_count += cnt;\n\treturn cnt;\n}\n\n \nstatic int dw_mci_pull_part_bytes(struct dw_mci *host, void *buf, int cnt)\n{\n\tcnt = min_t(int, cnt, host->part_buf_count);\n\tif (cnt) {\n\t\tmemcpy(buf, (void *)&host->part_buf + host->part_buf_start,\n\t\t       cnt);\n\t\thost->part_buf_count -= cnt;\n\t\thost->part_buf_start += cnt;\n\t}\n\treturn cnt;\n}\n\n \nstatic void dw_mci_pull_final_bytes(struct dw_mci *host, void *buf, int cnt)\n{\n\tmemcpy(buf, &host->part_buf, cnt);\n\thost->part_buf_start = cnt;\n\thost->part_buf_count = (1 << host->data_shift) - cnt;\n}\n\nstatic void dw_mci_push_data16(struct dw_mci *host, void *buf, int cnt)\n{\n\tstruct mmc_data *data = host->data;\n\tint init_cnt = cnt;\n\n\t \n\tif (unlikely(host->part_buf_count)) {\n\t\tint len = dw_mci_push_part_bytes(host, buf, cnt);\n\n\t\tbuf += len;\n\t\tcnt -= len;\n\t\tif (host->part_buf_count == 2) {\n\t\t\tmci_fifo_writew(host->fifo_reg, host->part_buf16);\n\t\t\thost->part_buf_count = 0;\n\t\t}\n\t}\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x1)) {\n\t\twhile (cnt >= 2) {\n\t\t\tu16 aligned_buf[64];\n\t\t\tint len = min(cnt & -2, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 1;\n\t\t\tint i;\n\t\t\t \n\t\t\tmemcpy(aligned_buf, buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t\t \n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\tmci_fifo_writew(host->fifo_reg, aligned_buf[i]);\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu16 *pdata = buf;\n\n\t\tfor (; cnt >= 2; cnt -= 2)\n\t\t\tmci_fifo_writew(host->fifo_reg, *pdata++);\n\t\tbuf = pdata;\n\t}\n\t \n\tif (cnt) {\n\t\tdw_mci_set_part_bytes(host, buf, cnt);\n\t\t  \n\t\tif ((data->bytes_xfered + init_cnt) ==\n\t\t    (data->blksz * data->blocks))\n\t\t\tmci_fifo_writew(host->fifo_reg, host->part_buf16);\n\t}\n}\n\nstatic void dw_mci_pull_data16(struct dw_mci *host, void *buf, int cnt)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x1)) {\n\t\twhile (cnt >= 2) {\n\t\t\t \n\t\t\tu16 aligned_buf[64];\n\t\t\tint len = min(cnt & -2, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 1;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\taligned_buf[i] = mci_fifo_readw(host->fifo_reg);\n\t\t\t \n\t\t\tmemcpy(buf, aligned_buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu16 *pdata = buf;\n\n\t\tfor (; cnt >= 2; cnt -= 2)\n\t\t\t*pdata++ = mci_fifo_readw(host->fifo_reg);\n\t\tbuf = pdata;\n\t}\n\tif (cnt) {\n\t\thost->part_buf16 = mci_fifo_readw(host->fifo_reg);\n\t\tdw_mci_pull_final_bytes(host, buf, cnt);\n\t}\n}\n\nstatic void dw_mci_push_data32(struct dw_mci *host, void *buf, int cnt)\n{\n\tstruct mmc_data *data = host->data;\n\tint init_cnt = cnt;\n\n\t \n\tif (unlikely(host->part_buf_count)) {\n\t\tint len = dw_mci_push_part_bytes(host, buf, cnt);\n\n\t\tbuf += len;\n\t\tcnt -= len;\n\t\tif (host->part_buf_count == 4) {\n\t\t\tmci_fifo_writel(host->fifo_reg,\thost->part_buf32);\n\t\t\thost->part_buf_count = 0;\n\t\t}\n\t}\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x3)) {\n\t\twhile (cnt >= 4) {\n\t\t\tu32 aligned_buf[32];\n\t\t\tint len = min(cnt & -4, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 2;\n\t\t\tint i;\n\t\t\t \n\t\t\tmemcpy(aligned_buf, buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t\t \n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\tmci_fifo_writel(host->fifo_reg,\taligned_buf[i]);\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu32 *pdata = buf;\n\n\t\tfor (; cnt >= 4; cnt -= 4)\n\t\t\tmci_fifo_writel(host->fifo_reg, *pdata++);\n\t\tbuf = pdata;\n\t}\n\t \n\tif (cnt) {\n\t\tdw_mci_set_part_bytes(host, buf, cnt);\n\t\t  \n\t\tif ((data->bytes_xfered + init_cnt) ==\n\t\t    (data->blksz * data->blocks))\n\t\t\tmci_fifo_writel(host->fifo_reg, host->part_buf32);\n\t}\n}\n\nstatic void dw_mci_pull_data32(struct dw_mci *host, void *buf, int cnt)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x3)) {\n\t\twhile (cnt >= 4) {\n\t\t\t \n\t\t\tu32 aligned_buf[32];\n\t\t\tint len = min(cnt & -4, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 2;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\taligned_buf[i] = mci_fifo_readl(host->fifo_reg);\n\t\t\t \n\t\t\tmemcpy(buf, aligned_buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu32 *pdata = buf;\n\n\t\tfor (; cnt >= 4; cnt -= 4)\n\t\t\t*pdata++ = mci_fifo_readl(host->fifo_reg);\n\t\tbuf = pdata;\n\t}\n\tif (cnt) {\n\t\thost->part_buf32 = mci_fifo_readl(host->fifo_reg);\n\t\tdw_mci_pull_final_bytes(host, buf, cnt);\n\t}\n}\n\nstatic void dw_mci_push_data64(struct dw_mci *host, void *buf, int cnt)\n{\n\tstruct mmc_data *data = host->data;\n\tint init_cnt = cnt;\n\n\t \n\tif (unlikely(host->part_buf_count)) {\n\t\tint len = dw_mci_push_part_bytes(host, buf, cnt);\n\n\t\tbuf += len;\n\t\tcnt -= len;\n\n\t\tif (host->part_buf_count == 8) {\n\t\t\tmci_fifo_writeq(host->fifo_reg,\thost->part_buf);\n\t\t\thost->part_buf_count = 0;\n\t\t}\n\t}\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x7)) {\n\t\twhile (cnt >= 8) {\n\t\t\tu64 aligned_buf[16];\n\t\t\tint len = min(cnt & -8, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 3;\n\t\t\tint i;\n\t\t\t \n\t\t\tmemcpy(aligned_buf, buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t\t \n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\tmci_fifo_writeq(host->fifo_reg,\taligned_buf[i]);\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu64 *pdata = buf;\n\n\t\tfor (; cnt >= 8; cnt -= 8)\n\t\t\tmci_fifo_writeq(host->fifo_reg, *pdata++);\n\t\tbuf = pdata;\n\t}\n\t \n\tif (cnt) {\n\t\tdw_mci_set_part_bytes(host, buf, cnt);\n\t\t \n\t\tif ((data->bytes_xfered + init_cnt) ==\n\t\t    (data->blksz * data->blocks))\n\t\t\tmci_fifo_writeq(host->fifo_reg, host->part_buf);\n\t}\n}\n\nstatic void dw_mci_pull_data64(struct dw_mci *host, void *buf, int cnt)\n{\n#ifndef CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS\n\tif (unlikely((unsigned long)buf & 0x7)) {\n\t\twhile (cnt >= 8) {\n\t\t\t \n\t\t\tu64 aligned_buf[16];\n\t\t\tint len = min(cnt & -8, (int)sizeof(aligned_buf));\n\t\t\tint items = len >> 3;\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < items; ++i)\n\t\t\t\taligned_buf[i] = mci_fifo_readq(host->fifo_reg);\n\n\t\t\t \n\t\t\tmemcpy(buf, aligned_buf, len);\n\t\t\tbuf += len;\n\t\t\tcnt -= len;\n\t\t}\n\t} else\n#endif\n\t{\n\t\tu64 *pdata = buf;\n\n\t\tfor (; cnt >= 8; cnt -= 8)\n\t\t\t*pdata++ = mci_fifo_readq(host->fifo_reg);\n\t\tbuf = pdata;\n\t}\n\tif (cnt) {\n\t\thost->part_buf = mci_fifo_readq(host->fifo_reg);\n\t\tdw_mci_pull_final_bytes(host, buf, cnt);\n\t}\n}\n\nstatic void dw_mci_pull_data(struct dw_mci *host, void *buf, int cnt)\n{\n\tint len;\n\n\t \n\tlen = dw_mci_pull_part_bytes(host, buf, cnt);\n\tif (unlikely(len == cnt))\n\t\treturn;\n\tbuf += len;\n\tcnt -= len;\n\n\t \n\thost->pull_data(host, buf, cnt);\n}\n\nstatic void dw_mci_read_data_pio(struct dw_mci *host, bool dto)\n{\n\tstruct sg_mapping_iter *sg_miter = &host->sg_miter;\n\tvoid *buf;\n\tunsigned int offset;\n\tstruct mmc_data\t*data = host->data;\n\tint shift = host->data_shift;\n\tu32 status;\n\tunsigned int len;\n\tunsigned int remain, fcnt;\n\n\tdo {\n\t\tif (!sg_miter_next(sg_miter))\n\t\t\tgoto done;\n\n\t\thost->sg = sg_miter->piter.sg;\n\t\tbuf = sg_miter->addr;\n\t\tremain = sg_miter->length;\n\t\toffset = 0;\n\n\t\tdo {\n\t\t\tfcnt = (SDMMC_GET_FCNT(mci_readl(host, STATUS))\n\t\t\t\t\t<< shift) + host->part_buf_count;\n\t\t\tlen = min(remain, fcnt);\n\t\t\tif (!len)\n\t\t\t\tbreak;\n\t\t\tdw_mci_pull_data(host, (void *)(buf + offset), len);\n\t\t\tdata->bytes_xfered += len;\n\t\t\toffset += len;\n\t\t\tremain -= len;\n\t\t} while (remain);\n\n\t\tsg_miter->consumed = offset;\n\t\tstatus = mci_readl(host, MINTSTS);\n\t\tmci_writel(host, RINTSTS, SDMMC_INT_RXDR);\n\t \n\t} while ((status & SDMMC_INT_RXDR) ||\n\t\t (dto && SDMMC_GET_FCNT(mci_readl(host, STATUS))));\n\n\tif (!remain) {\n\t\tif (!sg_miter_next(sg_miter))\n\t\t\tgoto done;\n\t\tsg_miter->consumed = 0;\n\t}\n\tsg_miter_stop(sg_miter);\n\treturn;\n\ndone:\n\tsg_miter_stop(sg_miter);\n\thost->sg = NULL;\n\tsmp_wmb();  \n\tset_bit(EVENT_XFER_COMPLETE, &host->pending_events);\n}\n\nstatic void dw_mci_write_data_pio(struct dw_mci *host)\n{\n\tstruct sg_mapping_iter *sg_miter = &host->sg_miter;\n\tvoid *buf;\n\tunsigned int offset;\n\tstruct mmc_data\t*data = host->data;\n\tint shift = host->data_shift;\n\tu32 status;\n\tunsigned int len;\n\tunsigned int fifo_depth = host->fifo_depth;\n\tunsigned int remain, fcnt;\n\n\tdo {\n\t\tif (!sg_miter_next(sg_miter))\n\t\t\tgoto done;\n\n\t\thost->sg = sg_miter->piter.sg;\n\t\tbuf = sg_miter->addr;\n\t\tremain = sg_miter->length;\n\t\toffset = 0;\n\n\t\tdo {\n\t\t\tfcnt = ((fifo_depth -\n\t\t\t\t SDMMC_GET_FCNT(mci_readl(host, STATUS)))\n\t\t\t\t\t<< shift) - host->part_buf_count;\n\t\t\tlen = min(remain, fcnt);\n\t\t\tif (!len)\n\t\t\t\tbreak;\n\t\t\thost->push_data(host, (void *)(buf + offset), len);\n\t\t\tdata->bytes_xfered += len;\n\t\t\toffset += len;\n\t\t\tremain -= len;\n\t\t} while (remain);\n\n\t\tsg_miter->consumed = offset;\n\t\tstatus = mci_readl(host, MINTSTS);\n\t\tmci_writel(host, RINTSTS, SDMMC_INT_TXDR);\n\t} while (status & SDMMC_INT_TXDR);  \n\n\tif (!remain) {\n\t\tif (!sg_miter_next(sg_miter))\n\t\t\tgoto done;\n\t\tsg_miter->consumed = 0;\n\t}\n\tsg_miter_stop(sg_miter);\n\treturn;\n\ndone:\n\tsg_miter_stop(sg_miter);\n\thost->sg = NULL;\n\tsmp_wmb();  \n\tset_bit(EVENT_XFER_COMPLETE, &host->pending_events);\n}\n\nstatic void dw_mci_cmd_interrupt(struct dw_mci *host, u32 status)\n{\n\tdel_timer(&host->cto_timer);\n\n\tif (!host->cmd_status)\n\t\thost->cmd_status = status;\n\n\tsmp_wmb();  \n\n\tset_bit(EVENT_CMD_COMPLETE, &host->pending_events);\n\ttasklet_schedule(&host->tasklet);\n\n\tdw_mci_start_fault_timer(host);\n}\n\nstatic void dw_mci_handle_cd(struct dw_mci *host)\n{\n\tstruct dw_mci_slot *slot = host->slot;\n\n\tmmc_detect_change(slot->mmc,\n\t\tmsecs_to_jiffies(host->pdata->detect_delay_ms));\n}\n\nstatic irqreturn_t dw_mci_interrupt(int irq, void *dev_id)\n{\n\tstruct dw_mci *host = dev_id;\n\tu32 pending;\n\tstruct dw_mci_slot *slot = host->slot;\n\n\tpending = mci_readl(host, MINTSTS);  \n\n\tif (pending) {\n\t\t \n\t\tif ((host->state == STATE_SENDING_CMD11) &&\n\t\t    (pending & SDMMC_INT_VOLT_SWITCH)) {\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_VOLT_SWITCH);\n\t\t\tpending &= ~SDMMC_INT_VOLT_SWITCH;\n\n\t\t\t \n\t\t\tspin_lock(&host->irq_lock);\n\t\t\tdw_mci_cmd_interrupt(host, pending);\n\t\t\tspin_unlock(&host->irq_lock);\n\n\t\t\tdel_timer(&host->cmd11_timer);\n\t\t}\n\n\t\tif (pending & DW_MCI_CMD_ERROR_FLAGS) {\n\t\t\tspin_lock(&host->irq_lock);\n\n\t\t\tdel_timer(&host->cto_timer);\n\t\t\tmci_writel(host, RINTSTS, DW_MCI_CMD_ERROR_FLAGS);\n\t\t\thost->cmd_status = pending;\n\t\t\tsmp_wmb();  \n\t\t\tset_bit(EVENT_CMD_COMPLETE, &host->pending_events);\n\n\t\t\tspin_unlock(&host->irq_lock);\n\t\t}\n\n\t\tif (pending & DW_MCI_DATA_ERROR_FLAGS) {\n\t\t\tspin_lock(&host->irq_lock);\n\n\t\t\tif (host->quirks & DW_MMC_QUIRK_EXTENDED_TMOUT)\n\t\t\t\tdel_timer(&host->dto_timer);\n\n\t\t\t \n\t\t\tmci_writel(host, RINTSTS, DW_MCI_DATA_ERROR_FLAGS);\n\t\t\thost->data_status = pending;\n\t\t\tsmp_wmb();  \n\t\t\tset_bit(EVENT_DATA_ERROR, &host->pending_events);\n\n\t\t\tif (host->quirks & DW_MMC_QUIRK_EXTENDED_TMOUT)\n\t\t\t\t \n\t\t\t\tset_bit(EVENT_DATA_COMPLETE,\n\t\t\t\t\t&host->pending_events);\n\n\t\t\ttasklet_schedule(&host->tasklet);\n\n\t\t\tspin_unlock(&host->irq_lock);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_DATA_OVER) {\n\t\t\tspin_lock(&host->irq_lock);\n\n\t\t\tdel_timer(&host->dto_timer);\n\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_DATA_OVER);\n\t\t\tif (!host->data_status)\n\t\t\t\thost->data_status = pending;\n\t\t\tsmp_wmb();  \n\t\t\tif (host->dir_status == DW_MCI_RECV_STATUS) {\n\t\t\t\tif (host->sg != NULL)\n\t\t\t\t\tdw_mci_read_data_pio(host, true);\n\t\t\t}\n\t\t\tset_bit(EVENT_DATA_COMPLETE, &host->pending_events);\n\t\t\ttasklet_schedule(&host->tasklet);\n\n\t\t\tspin_unlock(&host->irq_lock);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_RXDR) {\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_RXDR);\n\t\t\tif (host->dir_status == DW_MCI_RECV_STATUS && host->sg)\n\t\t\t\tdw_mci_read_data_pio(host, false);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_TXDR) {\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_TXDR);\n\t\t\tif (host->dir_status == DW_MCI_SEND_STATUS && host->sg)\n\t\t\t\tdw_mci_write_data_pio(host);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_CMD_DONE) {\n\t\t\tspin_lock(&host->irq_lock);\n\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_CMD_DONE);\n\t\t\tdw_mci_cmd_interrupt(host, pending);\n\n\t\t\tspin_unlock(&host->irq_lock);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_CD) {\n\t\t\tmci_writel(host, RINTSTS, SDMMC_INT_CD);\n\t\t\tdw_mci_handle_cd(host);\n\t\t}\n\n\t\tif (pending & SDMMC_INT_SDIO(slot->sdio_id)) {\n\t\t\tmci_writel(host, RINTSTS,\n\t\t\t\t   SDMMC_INT_SDIO(slot->sdio_id));\n\t\t\t__dw_mci_enable_sdio_irq(slot, 0);\n\t\t\tsdio_signal_irq(slot->mmc);\n\t\t}\n\n\t}\n\n\tif (host->use_dma != TRANS_MODE_IDMAC)\n\t\treturn IRQ_HANDLED;\n\n\t \n\tif (host->dma_64bit_address == 1) {\n\t\tpending = mci_readl(host, IDSTS64);\n\t\tif (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {\n\t\t\tmci_writel(host, IDSTS64, SDMMC_IDMAC_INT_TI |\n\t\t\t\t\t\t\tSDMMC_IDMAC_INT_RI);\n\t\t\tmci_writel(host, IDSTS64, SDMMC_IDMAC_INT_NI);\n\t\t\tif (!test_bit(EVENT_DATA_ERROR, &host->pending_events))\n\t\t\t\thost->dma_ops->complete((void *)host);\n\t\t}\n\t} else {\n\t\tpending = mci_readl(host, IDSTS);\n\t\tif (pending & (SDMMC_IDMAC_INT_TI | SDMMC_IDMAC_INT_RI)) {\n\t\t\tmci_writel(host, IDSTS, SDMMC_IDMAC_INT_TI |\n\t\t\t\t\t\t\tSDMMC_IDMAC_INT_RI);\n\t\t\tmci_writel(host, IDSTS, SDMMC_IDMAC_INT_NI);\n\t\t\tif (!test_bit(EVENT_DATA_ERROR, &host->pending_events))\n\t\t\t\thost->dma_ops->complete((void *)host);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int dw_mci_init_slot_caps(struct dw_mci_slot *slot)\n{\n\tstruct dw_mci *host = slot->host;\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tstruct mmc_host *mmc = slot->mmc;\n\tint ctrl_id;\n\n\tif (host->pdata->caps)\n\t\tmmc->caps = host->pdata->caps;\n\n\tif (host->pdata->pm_caps)\n\t\tmmc->pm_caps = host->pdata->pm_caps;\n\n\tif (drv_data)\n\t\tmmc->caps |= drv_data->common_caps;\n\n\tif (host->dev->of_node) {\n\t\tctrl_id = of_alias_get_id(host->dev->of_node, \"mshc\");\n\t\tif (ctrl_id < 0)\n\t\t\tctrl_id = 0;\n\t} else {\n\t\tctrl_id = to_platform_device(host->dev)->id;\n\t}\n\n\tif (drv_data && drv_data->caps) {\n\t\tif (ctrl_id >= drv_data->num_caps) {\n\t\t\tdev_err(host->dev, \"invalid controller id %d\\n\",\n\t\t\t\tctrl_id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmmc->caps |= drv_data->caps[ctrl_id];\n\t}\n\n\tif (host->pdata->caps2)\n\t\tmmc->caps2 = host->pdata->caps2;\n\n\t \n\tif (host->minimum_speed)\n\t\tmmc->f_min = host->minimum_speed;\n\telse\n\t\tmmc->f_min = DW_MCI_FREQ_MIN;\n\n\tif (!mmc->f_max)\n\t\tmmc->f_max = DW_MCI_FREQ_MAX;\n\n\t \n\tif (mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\tmmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;\n\n\treturn 0;\n}\n\nstatic int dw_mci_init_slot(struct dw_mci *host)\n{\n\tstruct mmc_host *mmc;\n\tstruct dw_mci_slot *slot;\n\tint ret;\n\n\tmmc = mmc_alloc_host(sizeof(struct dw_mci_slot), host->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tslot = mmc_priv(mmc);\n\tslot->id = 0;\n\tslot->sdio_id = host->sdio_id0 + slot->id;\n\tslot->mmc = mmc;\n\tslot->host = host;\n\thost->slot = slot;\n\n\tmmc->ops = &dw_mci_ops;\n\n\t \n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto err_host_allocated;\n\n\tif (!mmc->ocr_avail)\n\t\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err_host_allocated;\n\n\tret = dw_mci_init_slot_caps(slot);\n\tif (ret)\n\t\tgoto err_host_allocated;\n\n\t \n\tif (host->use_dma == TRANS_MODE_IDMAC) {\n\t\tmmc->max_segs = host->ring_size;\n\t\tmmc->max_blk_size = 65535;\n\t\tmmc->max_seg_size = 0x1000;\n\t\tmmc->max_req_size = mmc->max_seg_size * host->ring_size;\n\t\tmmc->max_blk_count = mmc->max_req_size / 512;\n\t} else if (host->use_dma == TRANS_MODE_EDMAC) {\n\t\tmmc->max_segs = 64;\n\t\tmmc->max_blk_size = 65535;\n\t\tmmc->max_blk_count = 65535;\n\t\tmmc->max_req_size =\n\t\t\t\tmmc->max_blk_size * mmc->max_blk_count;\n\t\tmmc->max_seg_size = mmc->max_req_size;\n\t} else {\n\t\t \n\t\tmmc->max_segs = 64;\n\t\tmmc->max_blk_size = 65535;  \n\t\tmmc->max_blk_count = 512;\n\t\tmmc->max_req_size = mmc->max_blk_size *\n\t\t\t\t    mmc->max_blk_count;\n\t\tmmc->max_seg_size = mmc->max_req_size;\n\t}\n\n\tdw_mci_get_cd(mmc);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto err_host_allocated;\n\n#if defined(CONFIG_DEBUG_FS)\n\tdw_mci_init_debugfs(slot);\n#endif\n\n\treturn 0;\n\nerr_host_allocated:\n\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void dw_mci_cleanup_slot(struct dw_mci_slot *slot)\n{\n\t \n\tmmc_remove_host(slot->mmc);\n\tslot->host->slot = NULL;\n\tmmc_free_host(slot->mmc);\n}\n\nstatic void dw_mci_init_dma(struct dw_mci *host)\n{\n\tint addr_config;\n\tstruct device *dev = host->dev;\n\n\t \n\thost->use_dma = SDMMC_GET_TRANS_MODE(mci_readl(host, HCON));\n\tif (host->use_dma == DMA_INTERFACE_IDMA) {\n\t\thost->use_dma = TRANS_MODE_IDMAC;\n\t} else if (host->use_dma == DMA_INTERFACE_DWDMA ||\n\t\t   host->use_dma == DMA_INTERFACE_GDMA) {\n\t\thost->use_dma = TRANS_MODE_EDMAC;\n\t} else {\n\t\tgoto no_dma;\n\t}\n\n\t \n\tif (host->use_dma == TRANS_MODE_IDMAC) {\n\t\t \n\t\taddr_config = SDMMC_GET_ADDR_CONFIG(mci_readl(host, HCON));\n\n\t\tif (addr_config == 1) {\n\t\t\t \n\t\t\thost->dma_64bit_address = 1;\n\t\t\tdev_info(host->dev,\n\t\t\t\t \"IDMAC supports 64-bit address mode.\\n\");\n\t\t\tif (!dma_set_mask(host->dev, DMA_BIT_MASK(64)))\n\t\t\t\tdma_set_coherent_mask(host->dev,\n\t\t\t\t\t\t      DMA_BIT_MASK(64));\n\t\t} else {\n\t\t\t \n\t\t\thost->dma_64bit_address = 0;\n\t\t\tdev_info(host->dev,\n\t\t\t\t \"IDMAC supports 32-bit address mode.\\n\");\n\t\t}\n\n\t\t \n\t\thost->sg_cpu = dmam_alloc_coherent(host->dev,\n\t\t\t\t\t\t   DESC_RING_BUF_SZ,\n\t\t\t\t\t\t   &host->sg_dma, GFP_KERNEL);\n\t\tif (!host->sg_cpu) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"%s: could not alloc DMA memory\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto no_dma;\n\t\t}\n\n\t\thost->dma_ops = &dw_mci_idmac_ops;\n\t\tdev_info(host->dev, \"Using internal DMA controller.\\n\");\n\t} else {\n\t\t \n\t\tif ((device_property_string_array_count(dev, \"dma-names\") < 0) ||\n\t\t    !device_property_present(dev, \"dmas\")) {\n\t\t\tgoto no_dma;\n\t\t}\n\t\thost->dma_ops = &dw_mci_edmac_ops;\n\t\tdev_info(host->dev, \"Using external DMA controller.\\n\");\n\t}\n\n\tif (host->dma_ops->init && host->dma_ops->start &&\n\t    host->dma_ops->stop && host->dma_ops->cleanup) {\n\t\tif (host->dma_ops->init(host)) {\n\t\t\tdev_err(host->dev, \"%s: Unable to initialize DMA Controller.\\n\",\n\t\t\t\t__func__);\n\t\t\tgoto no_dma;\n\t\t}\n\t} else {\n\t\tdev_err(host->dev, \"DMA initialization not found.\\n\");\n\t\tgoto no_dma;\n\t}\n\n\treturn;\n\nno_dma:\n\tdev_info(host->dev, \"Using PIO mode.\\n\");\n\thost->use_dma = TRANS_MODE_PIO;\n}\n\nstatic void dw_mci_cmd11_timer(struct timer_list *t)\n{\n\tstruct dw_mci *host = from_timer(host, t, cmd11_timer);\n\n\tif (host->state != STATE_SENDING_CMD11) {\n\t\tdev_warn(host->dev, \"Unexpected CMD11 timeout\\n\");\n\t\treturn;\n\t}\n\n\thost->cmd_status = SDMMC_INT_RTO;\n\tset_bit(EVENT_CMD_COMPLETE, &host->pending_events);\n\ttasklet_schedule(&host->tasklet);\n}\n\nstatic void dw_mci_cto_timer(struct timer_list *t)\n{\n\tstruct dw_mci *host = from_timer(host, t, cto_timer);\n\tunsigned long irqflags;\n\tu32 pending;\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\n\t \n\tpending = mci_readl(host, MINTSTS);  \n\tif (pending & (DW_MCI_CMD_ERROR_FLAGS | SDMMC_INT_CMD_DONE)) {\n\t\t \n\t\tdev_warn(host->dev, \"Unexpected interrupt latency\\n\");\n\t\tgoto exit;\n\t}\n\tif (test_bit(EVENT_CMD_COMPLETE, &host->pending_events)) {\n\t\t \n\t\tdev_warn(host->dev, \"CTO timeout when already completed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tswitch (host->state) {\n\tcase STATE_SENDING_CMD11:\n\tcase STATE_SENDING_CMD:\n\tcase STATE_SENDING_STOP:\n\t\t \n\t\thost->cmd_status = SDMMC_INT_RTO;\n\t\tset_bit(EVENT_CMD_COMPLETE, &host->pending_events);\n\t\ttasklet_schedule(&host->tasklet);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(host->dev, \"Unexpected command timeout, state %d\\n\",\n\t\t\t host->state);\n\t\tbreak;\n\t}\n\nexit:\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n}\n\nstatic void dw_mci_dto_timer(struct timer_list *t)\n{\n\tstruct dw_mci *host = from_timer(host, t, dto_timer);\n\tunsigned long irqflags;\n\tu32 pending;\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\n\t \n\tpending = mci_readl(host, MINTSTS);  \n\tif (pending & SDMMC_INT_DATA_OVER) {\n\t\t \n\t\tdev_warn(host->dev, \"Unexpected data interrupt latency\\n\");\n\t\tgoto exit;\n\t}\n\tif (test_bit(EVENT_DATA_COMPLETE, &host->pending_events)) {\n\t\t \n\t\tdev_warn(host->dev, \"DTO timeout when already completed\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tswitch (host->state) {\n\tcase STATE_SENDING_DATA:\n\tcase STATE_DATA_BUSY:\n\t\t \n\t\thost->data_status = SDMMC_INT_DRTO;\n\t\tset_bit(EVENT_DATA_ERROR, &host->pending_events);\n\t\tset_bit(EVENT_DATA_COMPLETE, &host->pending_events);\n\t\ttasklet_schedule(&host->tasklet);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(host->dev, \"Unexpected data timeout, state %d\\n\",\n\t\t\t host->state);\n\t\tbreak;\n\t}\n\nexit:\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n}\n\n#ifdef CONFIG_OF\nstatic struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)\n{\n\tstruct dw_mci_board *pdata;\n\tstruct device *dev = host->dev;\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tint ret;\n\tu32 clock_frequency;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tpdata->rstc = devm_reset_control_get_optional_exclusive(dev, \"reset\");\n\tif (IS_ERR(pdata->rstc))\n\t\treturn ERR_CAST(pdata->rstc);\n\n\tif (device_property_read_u32(dev, \"fifo-depth\", &pdata->fifo_depth))\n\t\tdev_info(dev,\n\t\t\t \"fifo-depth property not found, using value of FIFOTH register as default\\n\");\n\n\tdevice_property_read_u32(dev, \"card-detect-delay\",\n\t\t\t\t &pdata->detect_delay_ms);\n\n\tdevice_property_read_u32(dev, \"data-addr\", &host->data_addr_override);\n\n\tif (device_property_present(dev, \"fifo-watermark-aligned\"))\n\t\thost->wm_aligned = true;\n\n\tif (!device_property_read_u32(dev, \"clock-frequency\", &clock_frequency))\n\t\tpdata->bus_hz = clock_frequency;\n\n\tif (drv_data && drv_data->parse_dt) {\n\t\tret = drv_data->parse_dt(host);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pdata;\n}\n\n#else  \nstatic struct dw_mci_board *dw_mci_parse_dt(struct dw_mci *host)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif  \n\nstatic void dw_mci_enable_cd(struct dw_mci *host)\n{\n\tunsigned long irqflags;\n\tu32 temp;\n\n\t \n\tif (host->slot->mmc->caps & MMC_CAP_NEEDS_POLL)\n\t\treturn;\n\n\tif (mmc_gpio_get_cd(host->slot->mmc) < 0) {\n\t\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\t\ttemp = mci_readl(host, INTMASK);\n\t\ttemp  |= SDMMC_INT_CD;\n\t\tmci_writel(host, INTMASK, temp);\n\t\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\t}\n}\n\nint dw_mci_probe(struct dw_mci *host)\n{\n\tconst struct dw_mci_drv_data *drv_data = host->drv_data;\n\tint width, i, ret = 0;\n\tu32 fifo_size;\n\n\tif (!host->pdata) {\n\t\thost->pdata = dw_mci_parse_dt(host);\n\t\tif (IS_ERR(host->pdata))\n\t\t\treturn dev_err_probe(host->dev, PTR_ERR(host->pdata),\n\t\t\t\t\t     \"platform data not available\\n\");\n\t}\n\n\thost->biu_clk = devm_clk_get(host->dev, \"biu\");\n\tif (IS_ERR(host->biu_clk)) {\n\t\tdev_dbg(host->dev, \"biu clock not available\\n\");\n\t} else {\n\t\tret = clk_prepare_enable(host->biu_clk);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, \"failed to enable biu clock\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\thost->ciu_clk = devm_clk_get(host->dev, \"ciu\");\n\tif (IS_ERR(host->ciu_clk)) {\n\t\tdev_dbg(host->dev, \"ciu clock not available\\n\");\n\t\thost->bus_hz = host->pdata->bus_hz;\n\t} else {\n\t\tret = clk_prepare_enable(host->ciu_clk);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev, \"failed to enable ciu clock\\n\");\n\t\t\tgoto err_clk_biu;\n\t\t}\n\n\t\tif (host->pdata->bus_hz) {\n\t\t\tret = clk_set_rate(host->ciu_clk, host->pdata->bus_hz);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(host->dev,\n\t\t\t\t\t \"Unable to set bus rate to %uHz\\n\",\n\t\t\t\t\t host->pdata->bus_hz);\n\t\t}\n\t\thost->bus_hz = clk_get_rate(host->ciu_clk);\n\t}\n\n\tif (!host->bus_hz) {\n\t\tdev_err(host->dev,\n\t\t\t\"Platform data must supply bus speed\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err_clk_ciu;\n\t}\n\n\tif (host->pdata->rstc) {\n\t\treset_control_assert(host->pdata->rstc);\n\t\tusleep_range(10, 50);\n\t\treset_control_deassert(host->pdata->rstc);\n\t}\n\n\tif (drv_data && drv_data->init) {\n\t\tret = drv_data->init(host);\n\t\tif (ret) {\n\t\t\tdev_err(host->dev,\n\t\t\t\t\"implementation specific init failed\\n\");\n\t\t\tgoto err_clk_ciu;\n\t\t}\n\t}\n\n\ttimer_setup(&host->cmd11_timer, dw_mci_cmd11_timer, 0);\n\ttimer_setup(&host->cto_timer, dw_mci_cto_timer, 0);\n\ttimer_setup(&host->dto_timer, dw_mci_dto_timer, 0);\n\n\tspin_lock_init(&host->lock);\n\tspin_lock_init(&host->irq_lock);\n\tINIT_LIST_HEAD(&host->queue);\n\n\tdw_mci_init_fault(host);\n\n\t \n\ti = SDMMC_GET_HDATA_WIDTH(mci_readl(host, HCON));\n\tif (!i) {\n\t\thost->push_data = dw_mci_push_data16;\n\t\thost->pull_data = dw_mci_pull_data16;\n\t\twidth = 16;\n\t\thost->data_shift = 1;\n\t} else if (i == 2) {\n\t\thost->push_data = dw_mci_push_data64;\n\t\thost->pull_data = dw_mci_pull_data64;\n\t\twidth = 64;\n\t\thost->data_shift = 3;\n\t} else {\n\t\t \n\t\tWARN((i != 1),\n\t\t     \"HCON reports a reserved host data width!\\n\"\n\t\t     \"Defaulting to 32-bit access.\\n\");\n\t\thost->push_data = dw_mci_push_data32;\n\t\thost->pull_data = dw_mci_pull_data32;\n\t\twidth = 32;\n\t\thost->data_shift = 2;\n\t}\n\n\t \n\tif (!dw_mci_ctrl_reset(host, SDMMC_CTRL_ALL_RESET_FLAGS)) {\n\t\tret = -ENODEV;\n\t\tgoto err_clk_ciu;\n\t}\n\n\thost->dma_ops = host->pdata->dma_ops;\n\tdw_mci_init_dma(host);\n\n\t \n\tmci_writel(host, RINTSTS, 0xFFFFFFFF);\n\tmci_writel(host, INTMASK, 0);  \n\n\t \n\tmci_writel(host, TMOUT, 0xFFFFFFFF);\n\n\t \n\tif (!host->pdata->fifo_depth) {\n\t\t \n\t\tfifo_size = mci_readl(host, FIFOTH);\n\t\tfifo_size = 1 + ((fifo_size >> 16) & 0xfff);\n\t} else {\n\t\tfifo_size = host->pdata->fifo_depth;\n\t}\n\thost->fifo_depth = fifo_size;\n\thost->fifoth_val =\n\t\tSDMMC_SET_FIFOTH(0x2, fifo_size / 2 - 1, fifo_size / 2);\n\tmci_writel(host, FIFOTH, host->fifoth_val);\n\n\t \n\tmci_writel(host, CLKENA, 0);\n\tmci_writel(host, CLKSRC, 0);\n\n\t \n\thost->verid = SDMMC_GET_VERID(mci_readl(host, VERID));\n\tdev_info(host->dev, \"Version ID is %04x\\n\", host->verid);\n\n\tif (host->data_addr_override)\n\t\thost->fifo_reg = host->regs + host->data_addr_override;\n\telse if (host->verid < DW_MMC_240A)\n\t\thost->fifo_reg = host->regs + DATA_OFFSET;\n\telse\n\t\thost->fifo_reg = host->regs + DATA_240A_OFFSET;\n\n\ttasklet_setup(&host->tasklet, dw_mci_tasklet_func);\n\tret = devm_request_irq(host->dev, host->irq, dw_mci_interrupt,\n\t\t\t       host->irq_flags, \"dw-mci\", host);\n\tif (ret)\n\t\tgoto err_dmaunmap;\n\n\t \n\tmci_writel(host, INTMASK, SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER |\n\t\t   SDMMC_INT_TXDR | SDMMC_INT_RXDR |\n\t\t   DW_MCI_ERROR_FLAGS);\n\t \n\tmci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE);\n\n\tdev_info(host->dev,\n\t\t \"DW MMC controller at irq %d,%d bit host data width,%u deep fifo\\n\",\n\t\t host->irq, width, fifo_size);\n\n\t \n\tret = dw_mci_init_slot(host);\n\tif (ret) {\n\t\tdev_dbg(host->dev, \"slot %d init failed\\n\", i);\n\t\tgoto err_dmaunmap;\n\t}\n\n\t \n\tdw_mci_enable_cd(host);\n\n\treturn 0;\n\nerr_dmaunmap:\n\tif (host->use_dma && host->dma_ops->exit)\n\t\thost->dma_ops->exit(host);\n\n\treset_control_assert(host->pdata->rstc);\n\nerr_clk_ciu:\n\tclk_disable_unprepare(host->ciu_clk);\n\nerr_clk_biu:\n\tclk_disable_unprepare(host->biu_clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dw_mci_probe);\n\nvoid dw_mci_remove(struct dw_mci *host)\n{\n\tdev_dbg(host->dev, \"remove slot\\n\");\n\tif (host->slot)\n\t\tdw_mci_cleanup_slot(host->slot);\n\n\tmci_writel(host, RINTSTS, 0xFFFFFFFF);\n\tmci_writel(host, INTMASK, 0);  \n\n\t \n\tmci_writel(host, CLKENA, 0);\n\tmci_writel(host, CLKSRC, 0);\n\n\tif (host->use_dma && host->dma_ops->exit)\n\t\thost->dma_ops->exit(host);\n\n\treset_control_assert(host->pdata->rstc);\n\n\tclk_disable_unprepare(host->ciu_clk);\n\tclk_disable_unprepare(host->biu_clk);\n}\nEXPORT_SYMBOL(dw_mci_remove);\n\n\n\n#ifdef CONFIG_PM\nint dw_mci_runtime_suspend(struct device *dev)\n{\n\tstruct dw_mci *host = dev_get_drvdata(dev);\n\n\tif (host->use_dma && host->dma_ops->exit)\n\t\thost->dma_ops->exit(host);\n\n\tclk_disable_unprepare(host->ciu_clk);\n\n\tif (host->slot &&\n\t    (mmc_can_gpio_cd(host->slot->mmc) ||\n\t     !mmc_card_is_removable(host->slot->mmc)))\n\t\tclk_disable_unprepare(host->biu_clk);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(dw_mci_runtime_suspend);\n\nint dw_mci_runtime_resume(struct device *dev)\n{\n\tint ret = 0;\n\tstruct dw_mci *host = dev_get_drvdata(dev);\n\n\tif (host->slot &&\n\t    (mmc_can_gpio_cd(host->slot->mmc) ||\n\t     !mmc_card_is_removable(host->slot->mmc))) {\n\t\tret = clk_prepare_enable(host->biu_clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(host->ciu_clk);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!dw_mci_ctrl_reset(host, SDMMC_CTRL_ALL_RESET_FLAGS)) {\n\t\tclk_disable_unprepare(host->ciu_clk);\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t}\n\n\tif (host->use_dma && host->dma_ops->init)\n\t\thost->dma_ops->init(host);\n\n\t \n\tmci_writel(host, FIFOTH, host->fifoth_val);\n\thost->prev_blksz = 0;\n\n\t \n\tmci_writel(host, TMOUT, 0xFFFFFFFF);\n\n\tmci_writel(host, RINTSTS, 0xFFFFFFFF);\n\tmci_writel(host, INTMASK, SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER |\n\t\t   SDMMC_INT_TXDR | SDMMC_INT_RXDR |\n\t\t   DW_MCI_ERROR_FLAGS);\n\tmci_writel(host, CTRL, SDMMC_CTRL_INT_ENABLE);\n\n\n\tif (host->slot && host->slot->mmc->pm_flags & MMC_PM_KEEP_POWER)\n\t\tdw_mci_set_ios(host->slot->mmc, &host->slot->mmc->ios);\n\n\t \n\tdw_mci_setup_bus(host->slot, true);\n\n\t \n\tif (sdio_irq_claimed(host->slot->mmc))\n\t\t__dw_mci_enable_sdio_irq(host->slot, 1);\n\n\t \n\tdw_mci_enable_cd(host);\n\n\treturn 0;\n\nerr:\n\tif (host->slot &&\n\t    (mmc_can_gpio_cd(host->slot->mmc) ||\n\t     !mmc_card_is_removable(host->slot->mmc)))\n\t\tclk_disable_unprepare(host->biu_clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(dw_mci_runtime_resume);\n#endif  \n\nstatic int __init dw_mci_init(void)\n{\n\tpr_info(\"Synopsys Designware Multimedia Card Interface Driver\\n\");\n\treturn 0;\n}\n\nstatic void __exit dw_mci_exit(void)\n{\n}\n\nmodule_init(dw_mci_init);\nmodule_exit(dw_mci_exit);\n\nMODULE_DESCRIPTION(\"DW Multimedia Card Interface driver\");\nMODULE_AUTHOR(\"NXP Semiconductor VietNam\");\nMODULE_AUTHOR(\"Imagination Technologies Ltd\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}