{
  "module_name": "mxs-mmc.c",
  "hash_id": "4a222ec11385e330b598c6b847df25b0bd908c4d7737fc039f1603ebb8dad5f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mxs-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/dma/mxs-dma.h>\n#include <linux/highmem.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/regulator/consumer.h>\n#include <linux/module.h>\n#include <linux/stmp_device.h>\n#include <linux/spi/mxs-spi.h>\n\n#define DRIVER_NAME\t\"mxs-mmc\"\n\n#define MXS_MMC_IRQ_BITS\t(BM_SSP_CTRL1_SDIO_IRQ\t\t| \\\n\t\t\t\t BM_SSP_CTRL1_RESP_ERR_IRQ\t| \\\n\t\t\t\t BM_SSP_CTRL1_RESP_TIMEOUT_IRQ\t| \\\n\t\t\t\t BM_SSP_CTRL1_DATA_TIMEOUT_IRQ\t| \\\n\t\t\t\t BM_SSP_CTRL1_DATA_CRC_IRQ\t| \\\n\t\t\t\t BM_SSP_CTRL1_FIFO_UNDERRUN_IRQ\t| \\\n\t\t\t\t BM_SSP_CTRL1_RECV_TIMEOUT_IRQ  | \\\n\t\t\t\t BM_SSP_CTRL1_FIFO_OVERRUN_IRQ)\n\n \n#define MXS_MMC_DETECT_TIMEOUT\t\t\t(HZ/2)\n\nstruct mxs_mmc_host {\n\tstruct mxs_ssp\t\t\tssp;\n\n\tstruct mmc_host\t\t\t*mmc;\n\tstruct mmc_request\t\t*mrq;\n\tstruct mmc_command\t\t*cmd;\n\tstruct mmc_data\t\t\t*data;\n\n\tunsigned char\t\t\tbus_width;\n\tspinlock_t\t\t\tlock;\n\tint\t\t\t\tsdio_irq_en;\n\tbool\t\t\t\tbroken_cd;\n};\n\nstatic int mxs_mmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tint present, ret;\n\n\tif (host->broken_cd)\n\t\treturn -ENOSYS;\n\n\tret = mmc_gpio_get_cd(mmc);\n\tif (ret >= 0)\n\t\treturn ret;\n\n\tpresent = mmc->caps & MMC_CAP_NEEDS_POLL ||\n\t\t!(readl(ssp->base + HW_SSP_STATUS(ssp)) &\n\t\t\tBM_SSP_STATUS_CARD_DETECT);\n\n\tif (mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH)\n\t\tpresent = !present;\n\n\treturn present;\n}\n\nstatic int mxs_mmc_reset(struct mxs_mmc_host *host)\n{\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tu32 ctrl0, ctrl1;\n\tint ret;\n\n\tret = stmp_reset_block(ssp->base);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl0 = BM_SSP_CTRL0_IGNORE_CRC;\n\tctrl1 = BF_SSP(0x3, CTRL1_SSP_MODE) |\n\t\tBF_SSP(0x7, CTRL1_WORD_LENGTH) |\n\t\tBM_SSP_CTRL1_DMA_ENABLE |\n\t\tBM_SSP_CTRL1_POLARITY |\n\t\tBM_SSP_CTRL1_RECV_TIMEOUT_IRQ_EN |\n\t\tBM_SSP_CTRL1_DATA_CRC_IRQ_EN |\n\t\tBM_SSP_CTRL1_DATA_TIMEOUT_IRQ_EN |\n\t\tBM_SSP_CTRL1_RESP_TIMEOUT_IRQ_EN |\n\t\tBM_SSP_CTRL1_RESP_ERR_IRQ_EN;\n\n\twritel(BF_SSP(0xffff, TIMING_TIMEOUT) |\n\t       BF_SSP(2, TIMING_CLOCK_DIVIDE) |\n\t       BF_SSP(0, TIMING_CLOCK_RATE),\n\t       ssp->base + HW_SSP_TIMING(ssp));\n\n\tif (host->sdio_irq_en) {\n\t\tctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\n\t\tctrl1 |= BM_SSP_CTRL1_SDIO_IRQ_EN;\n\t}\n\n\twritel(ctrl0, ssp->base + HW_SSP_CTRL0);\n\twritel(ctrl1, ssp->base + HW_SSP_CTRL1(ssp));\n\treturn 0;\n}\n\nstatic void mxs_mmc_start_cmd(struct mxs_mmc_host *host,\n\t\t\t      struct mmc_command *cmd);\n\nstatic void mxs_mmc_request_done(struct mxs_mmc_host *host)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tstruct mmc_data *data = host->data;\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mxs_ssp *ssp = &host->ssp;\n\n\tif (mmc_resp_type(cmd) & MMC_RSP_PRESENT) {\n\t\tif (mmc_resp_type(cmd) & MMC_RSP_136) {\n\t\t\tcmd->resp[3] = readl(ssp->base + HW_SSP_SDRESP0(ssp));\n\t\t\tcmd->resp[2] = readl(ssp->base + HW_SSP_SDRESP1(ssp));\n\t\t\tcmd->resp[1] = readl(ssp->base + HW_SSP_SDRESP2(ssp));\n\t\t\tcmd->resp[0] = readl(ssp->base + HW_SSP_SDRESP3(ssp));\n\t\t} else {\n\t\t\tcmd->resp[0] = readl(ssp->base + HW_SSP_SDRESP0(ssp));\n\t\t}\n\t}\n\n\tif (cmd == mrq->sbc) {\n\t\t \n\t\tmxs_mmc_start_cmd(host, mrq->cmd);\n\t\treturn;\n\t} else if (data) {\n\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg,\n\t\t\t     data->sg_len, ssp->dma_dir);\n\t\t \n\t\tif (!data->error)\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\telse\n\t\t\tdata->bytes_xfered = 0;\n\n\t\thost->data = NULL;\n\t\tif (data->stop && (data->error || !mrq->sbc)) {\n\t\t\tmxs_mmc_start_cmd(host, mrq->stop);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thost->mrq = NULL;\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void mxs_mmc_dma_irq_callback(void *param)\n{\n\tstruct mxs_mmc_host *host = param;\n\n\tmxs_mmc_request_done(host);\n}\n\nstatic irqreturn_t mxs_mmc_irq_handler(int irq, void *dev_id)\n{\n\tstruct mxs_mmc_host *host = dev_id;\n\tstruct mmc_command *cmd = host->cmd;\n\tstruct mmc_data *data = host->data;\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tu32 stat;\n\n\tspin_lock(&host->lock);\n\n\tstat = readl(ssp->base + HW_SSP_CTRL1(ssp));\n\twritel(stat & MXS_MMC_IRQ_BITS,\n\t       ssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_CLR);\n\n\tspin_unlock(&host->lock);\n\n\tif ((stat & BM_SSP_CTRL1_SDIO_IRQ) && (stat & BM_SSP_CTRL1_SDIO_IRQ_EN))\n\t\tmmc_signal_sdio_irq(host->mmc);\n\n\tif (stat & BM_SSP_CTRL1_RESP_TIMEOUT_IRQ)\n\t\tcmd->error = -ETIMEDOUT;\n\telse if (stat & BM_SSP_CTRL1_RESP_ERR_IRQ)\n\t\tcmd->error = -EIO;\n\n\tif (data) {\n\t\tif (stat & (BM_SSP_CTRL1_DATA_TIMEOUT_IRQ |\n\t\t\t    BM_SSP_CTRL1_RECV_TIMEOUT_IRQ))\n\t\t\tdata->error = -ETIMEDOUT;\n\t\telse if (stat & BM_SSP_CTRL1_DATA_CRC_IRQ)\n\t\t\tdata->error = -EILSEQ;\n\t\telse if (stat & (BM_SSP_CTRL1_FIFO_UNDERRUN_IRQ |\n\t\t\t\t BM_SSP_CTRL1_FIFO_OVERRUN_IRQ))\n\t\t\tdata->error = -EIO;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic struct dma_async_tx_descriptor *mxs_mmc_prep_dma(\n\tstruct mxs_mmc_host *host, unsigned long flags)\n{\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct mmc_data *data = host->data;\n\tstruct scatterlist * sgl;\n\tunsigned int sg_len;\n\n\tif (data) {\n\t\t \n\t\tdma_map_sg(mmc_dev(host->mmc), data->sg,\n\t\t\t   data->sg_len, ssp->dma_dir);\n\t\tsgl = data->sg;\n\t\tsg_len = data->sg_len;\n\t} else {\n\t\t \n\t\tsgl = (struct scatterlist *) ssp->ssp_pio_words;\n\t\tsg_len = SSP_PIO_NUM;\n\t}\n\n\tdesc = dmaengine_prep_slave_sg(ssp->dmach,\n\t\t\t\tsgl, sg_len, ssp->slave_dirn, flags);\n\tif (desc) {\n\t\tdesc->callback = mxs_mmc_dma_irq_callback;\n\t\tdesc->callback_param = host;\n\t} else {\n\t\tif (data)\n\t\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg,\n\t\t\t\t     data->sg_len, ssp->dma_dir);\n\t}\n\n\treturn desc;\n}\n\nstatic void mxs_mmc_bc(struct mxs_mmc_host *host)\n{\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tstruct mmc_command *cmd = host->cmd;\n\tstruct dma_async_tx_descriptor *desc;\n\tu32 ctrl0, cmd0, cmd1;\n\n\tctrl0 = BM_SSP_CTRL0_ENABLE | BM_SSP_CTRL0_IGNORE_CRC;\n\tcmd0 = BF_SSP(cmd->opcode, CMD0_CMD) | BM_SSP_CMD0_APPEND_8CYC;\n\tcmd1 = cmd->arg;\n\n\tif (host->sdio_irq_en) {\n\t\tctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\n\t\tcmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\n\t}\n\n\tssp->ssp_pio_words[0] = ctrl0;\n\tssp->ssp_pio_words[1] = cmd0;\n\tssp->ssp_pio_words[2] = cmd1;\n\tssp->dma_dir = DMA_NONE;\n\tssp->slave_dirn = DMA_TRANS_NONE;\n\tdesc = mxs_mmc_prep_dma(host, MXS_DMA_CTRL_WAIT4END);\n\tif (!desc)\n\t\tgoto out;\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(ssp->dmach);\n\treturn;\n\nout:\n\tdev_warn(mmc_dev(host->mmc),\n\t\t \"%s: failed to prep dma\\n\", __func__);\n}\n\nstatic void mxs_mmc_ac(struct mxs_mmc_host *host)\n{\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tstruct mmc_command *cmd = host->cmd;\n\tstruct dma_async_tx_descriptor *desc;\n\tu32 ignore_crc, get_resp, long_resp;\n\tu32 ctrl0, cmd0, cmd1;\n\n\tignore_crc = (mmc_resp_type(cmd) & MMC_RSP_CRC) ?\n\t\t\t0 : BM_SSP_CTRL0_IGNORE_CRC;\n\tget_resp = (mmc_resp_type(cmd) & MMC_RSP_PRESENT) ?\n\t\t\tBM_SSP_CTRL0_GET_RESP : 0;\n\tlong_resp = (mmc_resp_type(cmd) & MMC_RSP_136) ?\n\t\t\tBM_SSP_CTRL0_LONG_RESP : 0;\n\n\tctrl0 = BM_SSP_CTRL0_ENABLE | ignore_crc | get_resp | long_resp;\n\tcmd0 = BF_SSP(cmd->opcode, CMD0_CMD);\n\tcmd1 = cmd->arg;\n\n\tif (cmd->opcode == MMC_STOP_TRANSMISSION)\n\t\tcmd0 |= BM_SSP_CMD0_APPEND_8CYC;\n\n\tif (host->sdio_irq_en) {\n\t\tctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\n\t\tcmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\n\t}\n\n\tssp->ssp_pio_words[0] = ctrl0;\n\tssp->ssp_pio_words[1] = cmd0;\n\tssp->ssp_pio_words[2] = cmd1;\n\tssp->dma_dir = DMA_NONE;\n\tssp->slave_dirn = DMA_TRANS_NONE;\n\tdesc = mxs_mmc_prep_dma(host, MXS_DMA_CTRL_WAIT4END);\n\tif (!desc)\n\t\tgoto out;\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(ssp->dmach);\n\treturn;\n\nout:\n\tdev_warn(mmc_dev(host->mmc),\n\t\t \"%s: failed to prep dma\\n\", __func__);\n}\n\nstatic unsigned short mxs_ns_to_ssp_ticks(unsigned clock_rate, unsigned ns)\n{\n\tconst unsigned int ssp_timeout_mul = 4096;\n\t \n\tconst unsigned int clock_per_ms = clock_rate / 1000;\n\tconst unsigned int ms = ns / 1000;\n\tconst unsigned int ticks = ms * clock_per_ms;\n\tconst unsigned int ssp_ticks = ticks / ssp_timeout_mul;\n\n\tWARN_ON(ssp_ticks == 0);\n\treturn ssp_ticks;\n}\n\nstatic void mxs_mmc_adtc(struct mxs_mmc_host *host)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tstruct mmc_data *data = cmd->data;\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct scatterlist *sgl = data->sg, *sg;\n\tunsigned int sg_len = data->sg_len;\n\tunsigned int i;\n\n\tunsigned short dma_data_dir, timeout;\n\tenum dma_transfer_direction slave_dirn;\n\tunsigned int data_size = 0, log2_blksz;\n\tunsigned int blocks = data->blocks;\n\n\tstruct mxs_ssp *ssp = &host->ssp;\n\n\tu32 ignore_crc, get_resp, long_resp, read;\n\tu32 ctrl0, cmd0, cmd1, val;\n\n\tignore_crc = (mmc_resp_type(cmd) & MMC_RSP_CRC) ?\n\t\t\t0 : BM_SSP_CTRL0_IGNORE_CRC;\n\tget_resp = (mmc_resp_type(cmd) & MMC_RSP_PRESENT) ?\n\t\t\tBM_SSP_CTRL0_GET_RESP : 0;\n\tlong_resp = (mmc_resp_type(cmd) & MMC_RSP_136) ?\n\t\t\tBM_SSP_CTRL0_LONG_RESP : 0;\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\tdma_data_dir = DMA_TO_DEVICE;\n\t\tslave_dirn = DMA_MEM_TO_DEV;\n\t\tread = 0;\n\t} else {\n\t\tdma_data_dir = DMA_FROM_DEVICE;\n\t\tslave_dirn = DMA_DEV_TO_MEM;\n\t\tread = BM_SSP_CTRL0_READ;\n\t}\n\n\tctrl0 = BF_SSP(host->bus_width, CTRL0_BUS_WIDTH) |\n\t\tignore_crc | get_resp | long_resp |\n\t\tBM_SSP_CTRL0_DATA_XFER | read |\n\t\tBM_SSP_CTRL0_WAIT_FOR_IRQ |\n\t\tBM_SSP_CTRL0_ENABLE;\n\n\tcmd0 = BF_SSP(cmd->opcode, CMD0_CMD);\n\n\t \n\tlog2_blksz = ilog2(data->blksz);\n\n\t \n\tfor_each_sg(sgl, sg, sg_len, i)\n\t\tdata_size += sg->length;\n\n\tif (data_size != data->blocks * data->blksz)\n\t\tblocks = 1;\n\n\t \n\tif (ssp_is_old(ssp)) {\n\t\tctrl0 |= BF_SSP(data_size, CTRL0_XFER_COUNT);\n\t\tcmd0 |= BF_SSP(log2_blksz, CMD0_BLOCK_SIZE) |\n\t\t\tBF_SSP(blocks - 1, CMD0_BLOCK_COUNT);\n\t} else {\n\t\twritel(data_size, ssp->base + HW_SSP_XFER_SIZE);\n\t\twritel(BF_SSP(log2_blksz, BLOCK_SIZE_BLOCK_SIZE) |\n\t\t       BF_SSP(blocks - 1, BLOCK_SIZE_BLOCK_COUNT),\n\t\t       ssp->base + HW_SSP_BLOCK_SIZE);\n\t}\n\n\tif (cmd->opcode == SD_IO_RW_EXTENDED)\n\t\tcmd0 |= BM_SSP_CMD0_APPEND_8CYC;\n\n\tcmd1 = cmd->arg;\n\n\tif (host->sdio_irq_en) {\n\t\tctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;\n\t\tcmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;\n\t}\n\n\t \n\ttimeout = mxs_ns_to_ssp_ticks(ssp->clk_rate, data->timeout_ns);\n\tval = readl(ssp->base + HW_SSP_TIMING(ssp));\n\tval &= ~(BM_SSP_TIMING_TIMEOUT);\n\tval |= BF_SSP(timeout, TIMING_TIMEOUT);\n\twritel(val, ssp->base + HW_SSP_TIMING(ssp));\n\n\t \n\tssp->ssp_pio_words[0] = ctrl0;\n\tssp->ssp_pio_words[1] = cmd0;\n\tssp->ssp_pio_words[2] = cmd1;\n\tssp->dma_dir = DMA_NONE;\n\tssp->slave_dirn = DMA_TRANS_NONE;\n\tdesc = mxs_mmc_prep_dma(host, 0);\n\tif (!desc)\n\t\tgoto out;\n\n\t \n\tWARN_ON(host->data != NULL);\n\thost->data = data;\n\tssp->dma_dir = dma_data_dir;\n\tssp->slave_dirn = slave_dirn;\n\tdesc = mxs_mmc_prep_dma(host, DMA_PREP_INTERRUPT | MXS_DMA_CTRL_WAIT4END);\n\tif (!desc)\n\t\tgoto out;\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(ssp->dmach);\n\treturn;\nout:\n\tdev_warn(mmc_dev(host->mmc),\n\t\t \"%s: failed to prep dma\\n\", __func__);\n}\n\nstatic void mxs_mmc_start_cmd(struct mxs_mmc_host *host,\n\t\t\t      struct mmc_command *cmd)\n{\n\thost->cmd = cmd;\n\n\tswitch (mmc_cmd_type(cmd)) {\n\tcase MMC_CMD_BC:\n\t\tmxs_mmc_bc(host);\n\t\tbreak;\n\tcase MMC_CMD_BCR:\n\t\tmxs_mmc_ac(host);\n\t\tbreak;\n\tcase MMC_CMD_AC:\n\t\tmxs_mmc_ac(host);\n\t\tbreak;\n\tcase MMC_CMD_ADTC:\n\t\tmxs_mmc_adtc(host);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"%s: unknown MMC command\\n\", __func__);\n\t\tbreak;\n\t}\n}\n\nstatic void mxs_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\n\tWARN_ON(host->mrq != NULL);\n\thost->mrq = mrq;\n\n\tif (mrq->sbc)\n\t\tmxs_mmc_start_cmd(host, mrq->sbc);\n\telse\n\t\tmxs_mmc_start_cmd(host, mrq->cmd);\n}\n\nstatic void mxs_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_8)\n\t\thost->bus_width = 2;\n\telse if (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\thost->bus_width = 1;\n\telse\n\t\thost->bus_width = 0;\n\n\tif (ios->clock)\n\t\tmxs_ssp_set_clk_rate(&host->ssp, ios->clock);\n}\n\nstatic void mxs_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\tstruct mxs_ssp *ssp = &host->ssp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\thost->sdio_irq_en = enable;\n\n\tif (enable) {\n\t\twritel(BM_SSP_CTRL0_SDIO_IRQ_CHECK,\n\t\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_SET);\n\t\twritel(BM_SSP_CTRL1_SDIO_IRQ_EN,\n\t\t       ssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_SET);\n\t} else {\n\t\twritel(BM_SSP_CTRL0_SDIO_IRQ_CHECK,\n\t\t       ssp->base + HW_SSP_CTRL0 + STMP_OFFSET_REG_CLR);\n\t\twritel(BM_SSP_CTRL1_SDIO_IRQ_EN,\n\t\t       ssp->base + HW_SSP_CTRL1(ssp) + STMP_OFFSET_REG_CLR);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (enable && readl(ssp->base + HW_SSP_STATUS(ssp)) &\n\t\t\tBM_SSP_STATUS_SDIO_IRQ)\n\t\tmmc_signal_sdio_irq(host->mmc);\n\n}\n\nstatic const struct mmc_host_ops mxs_mmc_ops = {\n\t.request = mxs_mmc_request,\n\t.get_ro = mmc_gpio_get_ro,\n\t.get_cd = mxs_mmc_get_cd,\n\t.set_ios = mxs_mmc_set_ios,\n\t.enable_sdio_irq = mxs_mmc_enable_sdio_irq,\n};\n\nstatic const struct of_device_id mxs_mmc_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-mmc\", .data = (void *) IMX23_SSP, },\n\t{ .compatible = \"fsl,imx28-mmc\", .data = (void *) IMX28_SSP, },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mxs_mmc_dt_ids);\n\nstatic void mxs_mmc_regulator_disable(void *regulator)\n{\n\tregulator_disable(regulator);\n}\n\nstatic int mxs_mmc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mxs_mmc_host *host;\n\tstruct mmc_host *mmc;\n\tint ret = 0, irq_err;\n\tstruct regulator *reg_vmmc;\n\tstruct mxs_ssp *ssp;\n\n\tirq_err = platform_get_irq(pdev, 0);\n\tif (irq_err < 0)\n\t\treturn irq_err;\n\n\tmmc = mmc_alloc_host(sizeof(struct mxs_mmc_host), &pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\tssp = &host->ssp;\n\tssp->dev = &pdev->dev;\n\tssp->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ssp->base)) {\n\t\tret = PTR_ERR(ssp->base);\n\t\tgoto out_mmc_free;\n\t}\n\n\tssp->devid = (enum mxs_ssp_id)of_device_get_match_data(&pdev->dev);\n\n\thost->mmc = mmc;\n\thost->sdio_irq_en = 0;\n\n\treg_vmmc = devm_regulator_get(&pdev->dev, \"vmmc\");\n\tif (!IS_ERR(reg_vmmc)) {\n\t\tret = regulator_enable(reg_vmmc);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to enable vmmc regulator: %d\\n\", ret);\n\t\t\tgoto out_mmc_free;\n\t\t}\n\n\t\tret = devm_add_action_or_reset(&pdev->dev, mxs_mmc_regulator_disable,\n\t\t\t\t\t       reg_vmmc);\n\t\tif (ret)\n\t\t\tgoto out_mmc_free;\n\t}\n\n\tssp->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(ssp->clk)) {\n\t\tret = PTR_ERR(ssp->clk);\n\t\tgoto out_mmc_free;\n\t}\n\tret = clk_prepare_enable(ssp->clk);\n\tif (ret)\n\t\tgoto out_mmc_free;\n\n\tret = mxs_mmc_reset(host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to reset mmc: %d\\n\", ret);\n\t\tgoto out_clk_disable;\n\t}\n\n\tssp->dmach = dma_request_chan(&pdev->dev, \"rx-tx\");\n\tif (IS_ERR(ssp->dmach)) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"%s: failed to request dma\\n\", __func__);\n\t\tret = PTR_ERR(ssp->dmach);\n\t\tgoto out_clk_disable;\n\t}\n\n\t \n\tmmc->ops = &mxs_mmc_ops;\n\tmmc->caps = MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\n\t\t    MMC_CAP_SDIO_IRQ | MMC_CAP_NEEDS_POLL | MMC_CAP_CMD23;\n\n\thost->broken_cd = of_property_read_bool(np, \"broken-cd\");\n\n\tmmc->f_min = 400000;\n\tmmc->f_max = 288000000;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\tmmc->max_segs = 52;\n\tmmc->max_blk_size = 1 << 0xf;\n\tmmc->max_blk_count = (ssp_is_old(ssp)) ? 0xff : 0xffffff;\n\tmmc->max_req_size = (ssp_is_old(ssp)) ? 0xffff : 0xffffffff;\n\tmmc->max_seg_size = dma_get_max_seg_size(ssp->dmach->device->dev);\n\n\tplatform_set_drvdata(pdev, mmc);\n\n\tspin_lock_init(&host->lock);\n\n\tret = devm_request_irq(&pdev->dev, irq_err, mxs_mmc_irq_handler, 0,\n\t\t\t       dev_name(&pdev->dev), host);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto out_free_dma;\n\n\tdev_info(mmc_dev(host->mmc), \"initialized\\n\");\n\n\treturn 0;\n\nout_free_dma:\n\tdma_release_channel(ssp->dmach);\nout_clk_disable:\n\tclk_disable_unprepare(ssp->clk);\nout_mmc_free:\n\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void mxs_mmc_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(pdev);\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\tstruct mxs_ssp *ssp = &host->ssp;\n\n\tmmc_remove_host(mmc);\n\n\tif (ssp->dmach)\n\t\tdma_release_channel(ssp->dmach);\n\n\tclk_disable_unprepare(ssp->clk);\n\n\tmmc_free_host(mmc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mxs_mmc_suspend(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\tstruct mxs_ssp *ssp = &host->ssp;\n\n\tclk_disable_unprepare(ssp->clk);\n\treturn 0;\n}\n\nstatic int mxs_mmc_resume(struct device *dev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct mxs_mmc_host *host = mmc_priv(mmc);\n\tstruct mxs_ssp *ssp = &host->ssp;\n\n\treturn clk_prepare_enable(ssp->clk);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(mxs_mmc_pm_ops, mxs_mmc_suspend, mxs_mmc_resume);\n\nstatic struct platform_driver mxs_mmc_driver = {\n\t.probe\t\t= mxs_mmc_probe,\n\t.remove_new\t= mxs_mmc_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &mxs_mmc_pm_ops,\n\t\t.of_match_table = mxs_mmc_dt_ids,\n\t},\n};\n\nmodule_platform_driver(mxs_mmc_driver);\n\nMODULE_DESCRIPTION(\"FREESCALE MXS MMC peripheral\");\nMODULE_AUTHOR(\"Freescale Semiconductor\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRIVER_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}