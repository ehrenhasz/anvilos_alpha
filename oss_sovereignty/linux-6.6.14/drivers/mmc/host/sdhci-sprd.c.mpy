{
  "module_name": "sdhci-sprd.c",
  "hash_id": "12b5ada0d121f7c7d6ce1ed2c5f11785ac7102eefbbd5ffd4f2ddbf9fab8e307",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-sprd.c",
  "human_readable_source": "\n\n\n\n\n\n\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/iopoll.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n#include \"sdhci-pltfm.h\"\n#include \"mmc_hsq.h\"\n\n \n#define SDHCI_SPRD_ARG2_STUFF\t\tGENMASK(31, 16)\n\n#define SDHCI_SPRD_REG_32_DLL_CFG\t0x200\n#define  SDHCI_SPRD_DLL_ALL_CPST_EN\t(BIT(18) | BIT(24) | BIT(25) | BIT(26) | BIT(27))\n#define  SDHCI_SPRD_DLL_EN\t\tBIT(21)\n#define  SDHCI_SPRD_DLL_SEARCH_MODE\tBIT(16)\n#define  SDHCI_SPRD_DLL_INIT_COUNT\t0xc00\n#define  SDHCI_SPRD_DLL_PHASE_INTERNAL\t0x3\n\n#define SDHCI_SPRD_REG_32_DLL_DLY\t0x204\n\n#define SDHCI_SPRD_REG_32_DLL_DLY_OFFSET\t0x208\n#define  SDHCIBSPRD_IT_WR_DLY_INV\t\tBIT(5)\n#define  SDHCI_SPRD_BIT_CMD_DLY_INV\t\tBIT(13)\n#define  SDHCI_SPRD_BIT_POSRD_DLY_INV\t\tBIT(21)\n#define  SDHCI_SPRD_BIT_NEGRD_DLY_INV\t\tBIT(29)\n\n#define SDHCI_SPRD_REG_32_DLL_STS0\t0x210\n#define SDHCI_SPRD_DLL_LOCKED\t\tBIT(18)\n\n#define SDHCI_SPRD_REG_32_BUSY_POSI\t\t0x250\n#define  SDHCI_SPRD_BIT_OUTR_CLK_AUTO_EN\tBIT(25)\n#define  SDHCI_SPRD_BIT_INNR_CLK_AUTO_EN\tBIT(24)\n\n#define SDHCI_SPRD_REG_DEBOUNCE\t\t0x28C\n#define  SDHCI_SPRD_BIT_DLL_BAK\t\tBIT(0)\n#define  SDHCI_SPRD_BIT_DLL_VAL\t\tBIT(1)\n\n#define  SDHCI_SPRD_INT_SIGNAL_MASK\t0x1B7F410B\n\n \n#define  SDHCI_SPRD_CTRL_HS200\t\t0x0005\n#define  SDHCI_SPRD_CTRL_HS400\t\t0x0006\n#define  SDHCI_SPRD_CTRL_HS400ES\t0x0007\n\n \n#define  SDHCI_HW_RESET_CARD\t\tBIT(3)\n\n#define SDHCI_SPRD_MAX_CUR\t\t0xFFFFFF\n#define SDHCI_SPRD_CLK_MAX_DIV\t\t1023\n\n#define SDHCI_SPRD_CLK_DEF_RATE\t\t26000000\n#define SDHCI_SPRD_PHY_DLL_CLK\t\t52000000\n\n#define SDHCI_SPRD_MAX_RANGE\t\t0xff\n#define SDHCI_SPRD_CMD_DLY_MASK\t\tGENMASK(15, 8)\n#define SDHCI_SPRD_POSRD_DLY_MASK\tGENMASK(23, 16)\n#define SDHCI_SPRD_CPST_EN\t\tGENMASK(27, 24)\n\nstruct sdhci_sprd_host {\n\tu32 version;\n\tstruct clk *clk_sdio;\n\tstruct clk *clk_enable;\n\tstruct clk *clk_2x_enable;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_uhs;\n\tstruct pinctrl_state *pins_default;\n\tu32 base_rate;\n\tint flags;  \n\tu32 phy_delay[MMC_TIMING_MMC_HS400 + 2];\n};\n\nenum sdhci_sprd_tuning_type {\n\tSDHCI_SPRD_TUNING_SD_HS_CMD,\n\tSDHCI_SPRD_TUNING_SD_HS_DATA,\n};\n\nstruct sdhci_sprd_phy_cfg {\n\tconst char *property;\n\tu8 timing;\n};\n\nstatic const struct sdhci_sprd_phy_cfg sdhci_sprd_phy_cfgs[] = {\n\t{ \"sprd,phy-delay-legacy\", MMC_TIMING_LEGACY, },\n\t{ \"sprd,phy-delay-sd-highspeed\", MMC_TIMING_SD_HS, },\n\t{ \"sprd,phy-delay-sd-uhs-sdr50\", MMC_TIMING_UHS_SDR50, },\n\t{ \"sprd,phy-delay-sd-uhs-sdr104\", MMC_TIMING_UHS_SDR104, },\n\t{ \"sprd,phy-delay-mmc-highspeed\", MMC_TIMING_MMC_HS, },\n\t{ \"sprd,phy-delay-mmc-ddr52\", MMC_TIMING_MMC_DDR52, },\n\t{ \"sprd,phy-delay-mmc-hs200\", MMC_TIMING_MMC_HS200, },\n\t{ \"sprd,phy-delay-mmc-hs400\", MMC_TIMING_MMC_HS400, },\n\t{ \"sprd,phy-delay-mmc-hs400es\", MMC_TIMING_MMC_HS400 + 1, },\n};\n\n#define TO_SPRD_HOST(host) sdhci_pltfm_priv(sdhci_priv(host))\n\nstatic void sdhci_sprd_init_config(struct sdhci_host *host)\n{\n\tu16 val;\n\n\t \n\tval = sdhci_readl(host, SDHCI_SPRD_REG_DEBOUNCE);\n\tval |= SDHCI_SPRD_BIT_DLL_BAK | SDHCI_SPRD_BIT_DLL_VAL;\n\tsdhci_writel(host, val, SDHCI_SPRD_REG_DEBOUNCE);\n}\n\nstatic inline u32 sdhci_sprd_readl(struct sdhci_host *host, int reg)\n{\n\tif (unlikely(reg == SDHCI_MAX_CURRENT))\n\t\treturn SDHCI_SPRD_MAX_CUR;\n\n\treturn readl_relaxed(host->ioaddr + reg);\n}\n\nstatic inline void sdhci_sprd_writel(struct sdhci_host *host, u32 val, int reg)\n{\n\t \n\tif (unlikely(reg == SDHCI_MAX_CURRENT))\n\t\treturn;\n\n\tif (unlikely(reg == SDHCI_SIGNAL_ENABLE || reg == SDHCI_INT_ENABLE))\n\t\tval = val & SDHCI_SPRD_INT_SIGNAL_MASK;\n\n\twritel_relaxed(val, host->ioaddr + reg);\n}\n\nstatic inline void sdhci_sprd_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\t \n\tif (unlikely(reg == SDHCI_BLOCK_COUNT))\n\t\treturn;\n\n\twritew_relaxed(val, host->ioaddr + reg);\n}\n\nstatic inline void sdhci_sprd_writeb(struct sdhci_host *host, u8 val, int reg)\n{\n\t \n\tif (unlikely(reg == SDHCI_SOFTWARE_RESET)) {\n\t\tif (readb_relaxed(host->ioaddr + reg) & SDHCI_HW_RESET_CARD)\n\t\t\tval |= SDHCI_HW_RESET_CARD;\n\t}\n\n\twriteb_relaxed(val, host->ioaddr + reg);\n}\n\nstatic inline void sdhci_sprd_sd_clk_off(struct sdhci_host *host)\n{\n\tu16 ctrl = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\n\tctrl &= ~SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, ctrl, SDHCI_CLOCK_CONTROL);\n}\n\nstatic inline void sdhci_sprd_sd_clk_on(struct sdhci_host *host)\n{\n\tu16 ctrl;\n\n\tctrl = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tctrl |= SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, ctrl, SDHCI_CLOCK_CONTROL);\n}\n\nstatic inline void\nsdhci_sprd_set_dll_invert(struct sdhci_host *host, u32 mask, bool en)\n{\n\tu32 dll_dly_offset;\n\n\tdll_dly_offset = sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_DLY_OFFSET);\n\tif (en)\n\t\tdll_dly_offset |= mask;\n\telse\n\t\tdll_dly_offset &= ~mask;\n\tsdhci_writel(host, dll_dly_offset, SDHCI_SPRD_REG_32_DLL_DLY_OFFSET);\n}\n\nstatic inline u32 sdhci_sprd_calc_div(u32 base_clk, u32 clk)\n{\n\tu32 div;\n\n\t \n\tif (base_clk <= clk * 2)\n\t\treturn 0;\n\n\tdiv = (u32) (base_clk / (clk * 2));\n\n\tif ((base_clk / div) > (clk * 2))\n\t\tdiv++;\n\n\tif (div % 2)\n\t\tdiv = (div + 1) / 2;\n\telse\n\t\tdiv = div / 2;\n\n\tif (div > SDHCI_SPRD_CLK_MAX_DIV)\n\t\tdiv = SDHCI_SPRD_CLK_MAX_DIV;\n\n\treturn div;\n}\n\nstatic inline void _sdhci_sprd_set_clock(struct sdhci_host *host,\n\t\t\t\t\tunsigned int clk)\n{\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tu32 div, val, mask;\n\n\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\n\tdiv = sdhci_sprd_calc_div(sprd_host->base_rate, clk);\n\tdiv = ((div & 0x300) >> 2) | ((div & 0xFF) << 8);\n\tsdhci_enable_clk(host, div);\n\n\tval = sdhci_readl(host, SDHCI_SPRD_REG_32_BUSY_POSI);\n\tmask = SDHCI_SPRD_BIT_OUTR_CLK_AUTO_EN | SDHCI_SPRD_BIT_INNR_CLK_AUTO_EN;\n\t \n\tif (clk > 400000) {\n\t\tif (mask != (val & mask)) {\n\t\t\tval |= mask;\n\t\t\tsdhci_writel(host, val, SDHCI_SPRD_REG_32_BUSY_POSI);\n\t\t}\n\t} else {\n\t\tif (val & mask) {\n\t\t\tval &= ~mask;\n\t\t\tsdhci_writel(host, val, SDHCI_SPRD_REG_32_BUSY_POSI);\n\t\t}\n\t}\n}\n\nstatic void sdhci_sprd_enable_phy_dll(struct sdhci_host *host)\n{\n\tu32 tmp;\n\n\ttmp = sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_CFG);\n\ttmp &= ~(SDHCI_SPRD_DLL_EN | SDHCI_SPRD_DLL_ALL_CPST_EN);\n\tsdhci_writel(host, tmp, SDHCI_SPRD_REG_32_DLL_CFG);\n\t \n\tusleep_range(1000, 1250);\n\n\ttmp = sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_CFG);\n\ttmp |= SDHCI_SPRD_DLL_ALL_CPST_EN | SDHCI_SPRD_DLL_SEARCH_MODE |\n\t\tSDHCI_SPRD_DLL_INIT_COUNT | SDHCI_SPRD_DLL_PHASE_INTERNAL;\n\tsdhci_writel(host, tmp, SDHCI_SPRD_REG_32_DLL_CFG);\n\t \n\tusleep_range(1000, 1250);\n\n\ttmp = sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_CFG);\n\ttmp |= SDHCI_SPRD_DLL_EN;\n\tsdhci_writel(host, tmp, SDHCI_SPRD_REG_32_DLL_CFG);\n\t \n\tusleep_range(1000, 1250);\n\n\tif (read_poll_timeout(sdhci_readl, tmp, (tmp & SDHCI_SPRD_DLL_LOCKED),\n\t\t2000, USEC_PER_SEC, false, host, SDHCI_SPRD_REG_32_DLL_STS0)) {\n\t\tpr_err(\"%s: DLL locked fail!\\n\", mmc_hostname(host->mmc));\n\t\tpr_info(\"%s: DLL_STS0 : 0x%x, DLL_CFG : 0x%x\\n\",\n\t\t\t mmc_hostname(host->mmc),\n\t\t\t sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_STS0),\n\t\t\t sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_CFG));\n\t}\n}\n\nstatic void sdhci_sprd_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tbool en = false, clk_changed = false;\n\n\tif (clock == 0) {\n\t\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\t} else if (clock != host->clock) {\n\t\tsdhci_sprd_sd_clk_off(host);\n\t\t_sdhci_sprd_set_clock(host, clock);\n\n\t\tif (clock <= 400000)\n\t\t\ten = true;\n\t\tsdhci_sprd_set_dll_invert(host, SDHCI_SPRD_BIT_CMD_DLY_INV |\n\t\t\t\t\t  SDHCI_SPRD_BIT_POSRD_DLY_INV, en);\n\t\tclk_changed = true;\n\t} else {\n\t\t_sdhci_sprd_set_clock(host, clock);\n\t}\n\n\t \n\tif (clk_changed && clock > SDHCI_SPRD_PHY_DLL_CLK)\n\t\tsdhci_sprd_enable_phy_dll(host);\n}\n\nstatic unsigned int sdhci_sprd_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\n\treturn clk_round_rate(sprd_host->clk_sdio, ULONG_MAX);\n}\n\nstatic unsigned int sdhci_sprd_get_min_clock(struct sdhci_host *host)\n{\n\treturn 100000;\n}\n\nstatic void sdhci_sprd_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t unsigned int timing)\n{\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tstruct mmc_host *mmc = host->mmc;\n\tu32 *p = sprd_host->phy_delay;\n\tu16 ctrl_2;\n\n\tif (timing == host->timing)\n\t\treturn;\n\n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR12:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR25:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS200:\n\t\tctrl_2 |= SDHCI_SPRD_CTRL_HS200;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tctrl_2 |= SDHCI_SPRD_CTRL_HS400;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n\n\tif (!mmc->ios.enhanced_strobe)\n\t\tsdhci_writel(host, p[timing], SDHCI_SPRD_REG_32_DLL_DLY);\n}\n\nstatic void sdhci_sprd_hw_reset(struct sdhci_host *host)\n{\n\tint val;\n\n\t \n\tval = readb_relaxed(host->ioaddr + SDHCI_SOFTWARE_RESET);\n\tval &= ~SDHCI_HW_RESET_CARD;\n\twriteb_relaxed(val, host->ioaddr + SDHCI_SOFTWARE_RESET);\n\t \n\tusleep_range(10, 20);\n\n\tval |= SDHCI_HW_RESET_CARD;\n\twriteb_relaxed(val, host->ioaddr + SDHCI_SOFTWARE_RESET);\n\tusleep_range(300, 500);\n}\n\nstatic unsigned int sdhci_sprd_get_max_timeout_count(struct sdhci_host *host)\n{\n\t \n\treturn 1 << 31;\n}\n\nstatic unsigned int sdhci_sprd_get_ro(struct sdhci_host *host)\n{\n\treturn 0;\n}\n\nstatic void sdhci_sprd_request_done(struct sdhci_host *host,\n\t\t\t\t    struct mmc_request *mrq)\n{\n\t \n\tif (mmc_hsq_finalize_request(host->mmc, mrq))\n\t\treturn;\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void sdhci_sprd_set_power(struct sdhci_host *host, unsigned char mode,\n\t\t\t\t unsigned short vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tswitch (mode) {\n\tcase MMC_POWER_OFF:\n\t\tmmc_regulator_set_ocr(host->mmc, mmc->supply.vmmc, 0);\n\n\t\tmmc_regulator_disable_vqmmc(mmc);\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tmmc_regulator_enable_vqmmc(mmc);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tmmc_regulator_set_ocr(host->mmc, mmc->supply.vmmc, vdd);\n\t\tbreak;\n\t}\n}\n\nstatic struct sdhci_ops sdhci_sprd_ops = {\n\t.read_l = sdhci_sprd_readl,\n\t.write_l = sdhci_sprd_writel,\n\t.write_w = sdhci_sprd_writew,\n\t.write_b = sdhci_sprd_writeb,\n\t.set_clock = sdhci_sprd_set_clock,\n\t.set_power = sdhci_sprd_set_power,\n\t.get_max_clock = sdhci_sprd_get_max_clock,\n\t.get_min_clock = sdhci_sprd_get_min_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_sprd_set_uhs_signaling,\n\t.hw_reset = sdhci_sprd_hw_reset,\n\t.get_max_timeout_count = sdhci_sprd_get_max_timeout_count,\n\t.get_ro = sdhci_sprd_get_ro,\n\t.request_done = sdhci_sprd_request_done,\n};\n\nstatic void sdhci_sprd_check_auto_cmd23(struct mmc_host *mmc,\n\t\t\t\t\tstruct mmc_request *mrq)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\n\thost->flags |= sprd_host->flags & SDHCI_AUTO_CMD23;\n\n\t \n\tif (host->version >= SDHCI_SPEC_410 &&\n\t    mrq->sbc && (mrq->sbc->arg & SDHCI_SPRD_ARG2_STUFF) &&\n\t    (host->flags & SDHCI_AUTO_CMD23))\n\t\thost->flags &= ~SDHCI_AUTO_CMD23;\n}\n\nstatic void sdhci_sprd_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tsdhci_sprd_check_auto_cmd23(mmc, mrq);\n\n\tsdhci_request(mmc, mrq);\n}\n\nstatic int sdhci_sprd_request_atomic(struct mmc_host *mmc,\n\t\t\t\t     struct mmc_request *mrq)\n{\n\tsdhci_sprd_check_auto_cmd23(mmc, mrq);\n\n\treturn sdhci_request_atomic(mmc, mrq);\n}\n\nstatic int sdhci_sprd_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tint ret;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: Switching signalling voltage failed\\n\",\n\t\t\t       mmc_hostname(mmc));\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (IS_ERR(sprd_host->pinctrl))\n\t\tgoto reset;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tret = pinctrl_select_state(sprd_host->pinctrl,\n\t\t\t\t\t   sprd_host->pins_uhs);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: failed to select uhs pin state\\n\",\n\t\t\t       mmc_hostname(mmc));\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tfallthrough;\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tret = pinctrl_select_state(sprd_host->pinctrl,\n\t\t\t\t\t   sprd_host->pins_default);\n\t\tif (ret) {\n\t\t\tpr_err(\"%s: failed to select default pin state\\n\",\n\t\t\t       mmc_hostname(mmc));\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\tusleep_range(300, 500);\n\nreset:\n\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\n\treturn 0;\n}\n\nstatic void sdhci_sprd_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\t     struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tu32 *p = sprd_host->phy_delay;\n\tu16 ctrl_2;\n\n\tif (!ios->enhanced_strobe)\n\t\treturn;\n\n\tsdhci_sprd_sd_clk_off(host);\n\n\t \n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tctrl_2 |= SDHCI_SPRD_CTRL_HS400ES;\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n\n\tsdhci_sprd_sd_clk_on(host);\n\n\t \n\tsdhci_writel(host, p[MMC_TIMING_MMC_HS400 + 1],\n\t\t     SDHCI_SPRD_REG_32_DLL_DLY);\n}\n\nstatic int mmc_send_tuning_cmd(struct mmc_card *card)\n{\n\treturn mmc_send_status(card, NULL);\n}\n\nstatic int mmc_send_tuning_data(struct mmc_card *card)\n{\n\tu8 *status;\n\tint ret;\n\n\tstatus = kmalloc(64, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tret = mmc_sd_switch(card, 0, 0, 0, status);\n\n\tkfree(status);\n\n\treturn ret;\n}\n\nstatic int sdhci_sprd_get_best_clk_sample(struct mmc_host *mmc, u8 *value)\n{\n\tint range_end = SDHCI_SPRD_MAX_RANGE;\n\tint range_length = 0;\n\tint middle_range = 0;\n\tint count = 0;\n\tint i;\n\n\tfor (i = 0; i <= SDHCI_SPRD_MAX_RANGE; i++) {\n\t\tif (value[i]) {\n\t\t\tpr_debug(\"%s: tuning ok: %d\\n\", mmc_hostname(mmc), i);\n\t\t\tcount++;\n\t\t} else {\n\t\t\tpr_debug(\"%s: tuning fail: %d\\n\", mmc_hostname(mmc), i);\n\t\t\tif (range_length < count) {\n\t\t\t\trange_length = count;\n\t\t\t\trange_end = i - 1;\n\t\t\t\tcount = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!count)\n\t\treturn -EIO;\n\n\tif (count > range_length) {\n\t\trange_length = count;\n\t\trange_end = i - 1;\n\t}\n\n\tmiddle_range = range_end - (range_length - 1) / 2;\n\n\treturn middle_range;\n}\n\nstatic int sdhci_sprd_tuning(struct mmc_host *mmc, struct mmc_card *card,\n\t\t\tenum sdhci_sprd_tuning_type type)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tu32 *p = sprd_host->phy_delay;\n\tu32 dll_cfg, dll_dly;\n\tint best_clk_sample;\n\tint err = 0;\n\tu8 *value;\n\tint i;\n\n\tvalue = kmalloc(SDHCI_SPRD_MAX_RANGE + 1, GFP_KERNEL);\n\tif (!value)\n\t\treturn -ENOMEM;\n\n\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\n\tdll_cfg = sdhci_readl(host, SDHCI_SPRD_REG_32_DLL_CFG);\n\tdll_cfg &= ~SDHCI_SPRD_CPST_EN;\n\tsdhci_writel(host, dll_cfg, SDHCI_SPRD_REG_32_DLL_CFG);\n\n\tdll_dly = p[mmc->ios.timing];\n\n\tfor (i = 0; i <= SDHCI_SPRD_MAX_RANGE; i++) {\n\t\tif (type == SDHCI_SPRD_TUNING_SD_HS_CMD) {\n\t\t\tdll_dly &= ~SDHCI_SPRD_CMD_DLY_MASK;\n\t\t\tdll_dly |= ((i << 8) & SDHCI_SPRD_CMD_DLY_MASK);\n\t\t} else {\n\t\t\tdll_dly &= ~SDHCI_SPRD_POSRD_DLY_MASK;\n\t\t\tdll_dly |= ((i << 16) & SDHCI_SPRD_POSRD_DLY_MASK);\n\t\t}\n\n\t\tsdhci_writel(host, dll_dly, SDHCI_SPRD_REG_32_DLL_DLY);\n\n\t\tif (type == SDHCI_SPRD_TUNING_SD_HS_CMD)\n\t\t\tvalue[i] = !mmc_send_tuning_cmd(card);\n\t\telse\n\t\t\tvalue[i] = !mmc_send_tuning_data(card);\n\t}\n\n\tbest_clk_sample = sdhci_sprd_get_best_clk_sample(mmc, value);\n\tif (best_clk_sample < 0) {\n\t\tdev_err(mmc_dev(host->mmc), \"all tuning phase fail!\\n\");\n\t\terr = best_clk_sample;\n\t\tgoto out;\n\t}\n\n\tif (type == SDHCI_SPRD_TUNING_SD_HS_CMD) {\n\t\tp[mmc->ios.timing] &= ~SDHCI_SPRD_CMD_DLY_MASK;\n\t\tp[mmc->ios.timing] |= ((best_clk_sample << 8) & SDHCI_SPRD_CMD_DLY_MASK);\n\t} else {\n\t\tp[mmc->ios.timing] &= ~(SDHCI_SPRD_POSRD_DLY_MASK);\n\t\tp[mmc->ios.timing] |= ((best_clk_sample << 16) & SDHCI_SPRD_POSRD_DLY_MASK);\n\t}\n\n\tpr_debug(\"%s: the best clk sample %d, delay value 0x%08x\\n\",\n\t\t\tmmc_hostname(host->mmc), best_clk_sample, p[mmc->ios.timing]);\n\nout:\n\tsdhci_writel(host, p[mmc->ios.timing], SDHCI_SPRD_REG_32_DLL_DLY);\n\n\tkfree(value);\n\n\treturn err;\n}\n\nstatic int sdhci_sprd_prepare_sd_hs_cmd_tuning(struct mmc_host *mmc, struct mmc_card *card)\n{\n\treturn sdhci_sprd_tuning(mmc, card, SDHCI_SPRD_TUNING_SD_HS_CMD);\n}\n\nstatic int sdhci_sprd_execute_sd_hs_data_tuning(struct mmc_host *mmc, struct mmc_card *card)\n{\n\treturn sdhci_sprd_tuning(mmc, card, SDHCI_SPRD_TUNING_SD_HS_DATA);\n}\n\nstatic void sdhci_sprd_phy_param_parse(struct sdhci_sprd_host *sprd_host,\n\t\t\t\t       struct device_node *np)\n{\n\tu32 *p = sprd_host->phy_delay;\n\tint ret, i, index;\n\tu32 val[4];\n\n\tfor (i = 0; i < ARRAY_SIZE(sdhci_sprd_phy_cfgs); i++) {\n\t\tret = of_property_read_u32_array(np,\n\t\t\t\tsdhci_sprd_phy_cfgs[i].property, val, 4);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tindex = sdhci_sprd_phy_cfgs[i].timing;\n\t\tp[index] = val[0] | (val[1] << 8) | (val[2] << 16) | (val[3] << 24);\n\t}\n}\n\nstatic const struct sdhci_pltfm_data sdhci_sprd_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK,\n\t.quirks2 = SDHCI_QUIRK2_BROKEN_HS200 |\n\t\t   SDHCI_QUIRK2_USE_32BIT_BLK_CNT |\n\t\t   SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops = &sdhci_sprd_ops,\n};\n\nstatic int sdhci_sprd_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct sdhci_sprd_host *sprd_host;\n\tstruct mmc_hsq *hsq;\n\tstruct clk *clk;\n\tint ret = 0;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_sprd_pdata, sizeof(*sprd_host));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\thost->dma_mask = DMA_BIT_MASK(64);\n\tpdev->dev.dma_mask = &host->dma_mask;\n\thost->mmc_host_ops.request = sdhci_sprd_request;\n\thost->mmc_host_ops.hs400_enhanced_strobe =\n\t\tsdhci_sprd_hs400_enhanced_strobe;\n\thost->mmc_host_ops.prepare_sd_hs_tuning =\n\t\tsdhci_sprd_prepare_sd_hs_cmd_tuning;\n\thost->mmc_host_ops.execute_sd_hs_tuning =\n\t\tsdhci_sprd_execute_sd_hs_data_tuning;\n\n\t \n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\tsdhci_sprd_voltage_switch;\n\n\thost->mmc->caps = MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\n\t\tMMC_CAP_WAIT_WHILE_BUSY;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto pltfm_free;\n\n\tif (!mmc_card_is_removable(host->mmc))\n\t\thost->mmc_host_ops.request_atomic = sdhci_sprd_request_atomic;\n\telse\n\t\thost->always_defer_done = true;\n\n\tsprd_host = TO_SPRD_HOST(host);\n\tsdhci_sprd_phy_param_parse(sprd_host, pdev->dev.of_node);\n\n\tsprd_host->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (!IS_ERR(sprd_host->pinctrl)) {\n\t\tsprd_host->pins_uhs =\n\t\t\tpinctrl_lookup_state(sprd_host->pinctrl, \"state_uhs\");\n\t\tif (IS_ERR(sprd_host->pins_uhs)) {\n\t\t\tret = PTR_ERR(sprd_host->pins_uhs);\n\t\t\tgoto pltfm_free;\n\t\t}\n\n\t\tsprd_host->pins_default =\n\t\t\tpinctrl_lookup_state(sprd_host->pinctrl, \"default\");\n\t\tif (IS_ERR(sprd_host->pins_default)) {\n\t\t\tret = PTR_ERR(sprd_host->pins_default);\n\t\t\tgoto pltfm_free;\n\t\t}\n\t}\n\n\tclk = devm_clk_get(&pdev->dev, \"sdio\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto pltfm_free;\n\t}\n\tsprd_host->clk_sdio = clk;\n\tsprd_host->base_rate = clk_get_rate(sprd_host->clk_sdio);\n\tif (!sprd_host->base_rate)\n\t\tsprd_host->base_rate = SDHCI_SPRD_CLK_DEF_RATE;\n\n\tclk = devm_clk_get(&pdev->dev, \"enable\");\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto pltfm_free;\n\t}\n\tsprd_host->clk_enable = clk;\n\n\tclk = devm_clk_get(&pdev->dev, \"2x_enable\");\n\tif (!IS_ERR(clk))\n\t\tsprd_host->clk_2x_enable = clk;\n\n\tret = clk_prepare_enable(sprd_host->clk_sdio);\n\tif (ret)\n\t\tgoto pltfm_free;\n\n\tret = clk_prepare_enable(sprd_host->clk_enable);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tret = clk_prepare_enable(sprd_host->clk_2x_enable);\n\tif (ret)\n\t\tgoto clk_disable2;\n\n\tsdhci_sprd_init_config(host);\n\thost->version = sdhci_readw(host, SDHCI_HOST_VERSION);\n\tsprd_host->version = ((host->version & SDHCI_VENDOR_VER_MASK) >>\n\t\t\t       SDHCI_VENDOR_VER_SHIFT);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\n\tsdhci_enable_v4_mode(host);\n\n\t \n\tsdhci_read_caps(host);\n\thost->caps1 &= ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_SDR104 |\n\t\t\t SDHCI_SUPPORT_DDR50);\n\n\tret = mmc_regulator_get_supply(host->mmc);\n\tif (ret)\n\t\tgoto pm_runtime_disable;\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\tgoto pm_runtime_disable;\n\n\tsprd_host->flags = host->flags;\n\n\thsq = devm_kzalloc(&pdev->dev, sizeof(*hsq), GFP_KERNEL);\n\tif (!hsq) {\n\t\tret = -ENOMEM;\n\t\tgoto err_cleanup_host;\n\t}\n\n\tret = mmc_hsq_init(hsq, host->mmc);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\tpm_runtime_mark_last_busy(&pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_cleanup_host:\n\tsdhci_cleanup_host(host);\n\npm_runtime_disable:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\tclk_disable_unprepare(sprd_host->clk_2x_enable);\n\nclk_disable2:\n\tclk_disable_unprepare(sprd_host->clk_enable);\n\nclk_disable:\n\tclk_disable_unprepare(sprd_host->clk_sdio);\n\npltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_sprd_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\n\tsdhci_remove_host(host, 0);\n\n\tclk_disable_unprepare(sprd_host->clk_sdio);\n\tclk_disable_unprepare(sprd_host->clk_enable);\n\tclk_disable_unprepare(sprd_host->clk_2x_enable);\n\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic const struct of_device_id sdhci_sprd_of_match[] = {\n\t{ .compatible = \"sprd,sdhci-r11\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sdhci_sprd_of_match);\n\n#ifdef CONFIG_PM\nstatic int sdhci_sprd_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\n\tmmc_hsq_suspend(host->mmc);\n\tsdhci_runtime_suspend_host(host);\n\n\tclk_disable_unprepare(sprd_host->clk_sdio);\n\tclk_disable_unprepare(sprd_host->clk_enable);\n\tclk_disable_unprepare(sprd_host->clk_2x_enable);\n\n\treturn 0;\n}\n\nstatic int sdhci_sprd_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_sprd_host *sprd_host = TO_SPRD_HOST(host);\n\tint ret;\n\n\tret = clk_prepare_enable(sprd_host->clk_2x_enable);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(sprd_host->clk_enable);\n\tif (ret)\n\t\tgoto clk_2x_disable;\n\n\tret = clk_prepare_enable(sprd_host->clk_sdio);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tsdhci_runtime_resume_host(host, 1);\n\tmmc_hsq_resume(host->mmc);\n\n\treturn 0;\n\nclk_disable:\n\tclk_disable_unprepare(sprd_host->clk_enable);\n\nclk_2x_disable:\n\tclk_disable_unprepare(sprd_host->clk_2x_enable);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_sprd_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_sprd_runtime_suspend,\n\t\t\t   sdhci_sprd_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sdhci_sprd_driver = {\n\t.probe = sdhci_sprd_probe,\n\t.remove_new = sdhci_sprd_remove,\n\t.driver = {\n\t\t.name = \"sdhci_sprd_r11\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_sprd_of_match,\n\t\t.pm = &sdhci_sprd_pm_ops,\n\t},\n};\nmodule_platform_driver(sdhci_sprd_driver);\n\nMODULE_DESCRIPTION(\"Spreadtrum sdio host controller r11 driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sdhci-sprd-r11\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}