{
  "module_name": "meson-mx-sdio.c",
  "hash_id": "5e9bbbce706196f67f505259b1679cc507955593ac11260d6c752fb2f30254c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/meson-mx-sdio.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n#include <linux/of_platform.h>\n#include <linux/timer.h>\n#include <linux/types.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n\n#define MESON_MX_SDIO_ARGU\t\t\t\t\t0x00\n\n#define MESON_MX_SDIO_SEND\t\t\t\t\t0x04\n\t#define MESON_MX_SDIO_SEND_COMMAND_INDEX_MASK\t\tGENMASK(7, 0)\n\t#define MESON_MX_SDIO_SEND_CMD_RESP_BITS_MASK\t\tGENMASK(15, 8)\n\t#define MESON_MX_SDIO_SEND_RESP_WITHOUT_CRC7\t\tBIT(16)\n\t#define MESON_MX_SDIO_SEND_RESP_HAS_DATA\t\tBIT(17)\n\t#define MESON_MX_SDIO_SEND_RESP_CRC7_FROM_8\t\tBIT(18)\n\t#define MESON_MX_SDIO_SEND_CHECK_DAT0_BUSY\t\tBIT(19)\n\t#define MESON_MX_SDIO_SEND_DATA\t\t\t\tBIT(20)\n\t#define MESON_MX_SDIO_SEND_USE_INT_WINDOW\t\tBIT(21)\n\t#define MESON_MX_SDIO_SEND_REPEAT_PACKAGE_TIMES_MASK\tGENMASK(31, 24)\n\n#define MESON_MX_SDIO_CONF\t\t\t\t\t0x08\n\t#define MESON_MX_SDIO_CONF_CMD_CLK_DIV_SHIFT\t\t0\n\t#define MESON_MX_SDIO_CONF_CMD_CLK_DIV_WIDTH\t\t10\n\t#define MESON_MX_SDIO_CONF_CMD_DISABLE_CRC\t\tBIT(10)\n\t#define MESON_MX_SDIO_CONF_CMD_OUT_AT_POSITIVE_EDGE\tBIT(11)\n\t#define MESON_MX_SDIO_CONF_CMD_ARGUMENT_BITS_MASK\tGENMASK(17, 12)\n\t#define MESON_MX_SDIO_CONF_RESP_LATCH_AT_NEGATIVE_EDGE\tBIT(18)\n\t#define MESON_MX_SDIO_CONF_DATA_LATCH_AT_NEGATIVE_EDGE\tBIT(19)\n\t#define MESON_MX_SDIO_CONF_BUS_WIDTH\t\t\tBIT(20)\n\t#define MESON_MX_SDIO_CONF_M_ENDIAN_MASK\t\tGENMASK(22, 21)\n\t#define MESON_MX_SDIO_CONF_WRITE_NWR_MASK\t\tGENMASK(28, 23)\n\t#define MESON_MX_SDIO_CONF_WRITE_CRC_OK_STATUS_MASK\tGENMASK(31, 29)\n\n#define MESON_MX_SDIO_IRQS\t\t\t\t\t0x0c\n\t#define MESON_MX_SDIO_IRQS_STATUS_STATE_MACHINE_MASK\tGENMASK(3, 0)\n\t#define MESON_MX_SDIO_IRQS_CMD_BUSY\t\t\tBIT(4)\n\t#define MESON_MX_SDIO_IRQS_RESP_CRC7_OK\t\t\tBIT(5)\n\t#define MESON_MX_SDIO_IRQS_DATA_READ_CRC16_OK\t\tBIT(6)\n\t#define MESON_MX_SDIO_IRQS_DATA_WRITE_CRC16_OK\t\tBIT(7)\n\t#define MESON_MX_SDIO_IRQS_IF_INT\t\t\tBIT(8)\n\t#define MESON_MX_SDIO_IRQS_CMD_INT\t\t\tBIT(9)\n\t#define MESON_MX_SDIO_IRQS_STATUS_INFO_MASK\t\tGENMASK(15, 12)\n\t#define MESON_MX_SDIO_IRQS_TIMING_OUT_INT\t\tBIT(16)\n\t#define MESON_MX_SDIO_IRQS_AMRISC_TIMING_OUT_INT_EN\tBIT(17)\n\t#define MESON_MX_SDIO_IRQS_ARC_TIMING_OUT_INT_EN\tBIT(18)\n\t#define MESON_MX_SDIO_IRQS_TIMING_OUT_COUNT_MASK\tGENMASK(31, 19)\n\n#define MESON_MX_SDIO_IRQC\t\t\t\t\t0x10\n\t#define MESON_MX_SDIO_IRQC_ARC_IF_INT_EN\t\tBIT(3)\n\t#define MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN\t\tBIT(4)\n\t#define MESON_MX_SDIO_IRQC_IF_CONFIG_MASK\t\tGENMASK(7, 6)\n\t#define MESON_MX_SDIO_IRQC_FORCE_DATA_CLK\t\tBIT(8)\n\t#define MESON_MX_SDIO_IRQC_FORCE_DATA_CMD\t\tBIT(9)\n\t#define MESON_MX_SDIO_IRQC_FORCE_DATA_DAT_MASK\t\tGENMASK(13, 10)\n\t#define MESON_MX_SDIO_IRQC_SOFT_RESET\t\t\tBIT(15)\n\t#define MESON_MX_SDIO_IRQC_FORCE_HALT\t\t\tBIT(30)\n\t#define MESON_MX_SDIO_IRQC_HALT_HOLE\t\t\tBIT(31)\n\n#define MESON_MX_SDIO_MULT\t\t\t\t\t0x14\n\t#define MESON_MX_SDIO_MULT_PORT_SEL_MASK\t\tGENMASK(1, 0)\n\t#define MESON_MX_SDIO_MULT_MEMORY_STICK_ENABLE\t\tBIT(2)\n\t#define MESON_MX_SDIO_MULT_MEMORY_STICK_SCLK_ALWAYS\tBIT(3)\n\t#define MESON_MX_SDIO_MULT_STREAM_ENABLE\t\tBIT(4)\n\t#define MESON_MX_SDIO_MULT_STREAM_8BITS_MODE\t\tBIT(5)\n\t#define MESON_MX_SDIO_MULT_WR_RD_OUT_INDEX\t\tBIT(8)\n\t#define MESON_MX_SDIO_MULT_DAT0_DAT1_SWAPPED\t\tBIT(10)\n\t#define MESON_MX_SDIO_MULT_DAT1_DAT0_SWAPPED\t\tBIT(11)\n\t#define MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK\t\tGENMASK(15, 12)\n\n#define MESON_MX_SDIO_ADDR\t\t\t\t\t0x18\n\n#define MESON_MX_SDIO_EXT\t\t\t\t\t0x1c\n\t#define MESON_MX_SDIO_EXT_DATA_RW_NUMBER_MASK\t\tGENMASK(29, 16)\n\n#define MESON_MX_SDIO_BOUNCE_REQ_SIZE\t\t\t\t(128 * 1024)\n#define MESON_MX_SDIO_RESPONSE_CRC16_BITS\t\t\t(16 - 1)\n#define MESON_MX_SDIO_MAX_SLOTS\t\t\t\t\t3\n\nstruct meson_mx_mmc_host {\n\tstruct device\t\t\t*controller_dev;\n\n\tstruct clk\t\t\t*parent_clk;\n\tstruct clk\t\t\t*core_clk;\n\tstruct clk_divider\t\tcfg_div;\n\tstruct clk\t\t\t*cfg_div_clk;\n\tstruct clk_fixed_factor\t\tfixed_factor;\n\tstruct clk\t\t\t*fixed_factor_clk;\n\n\tvoid __iomem\t\t\t*base;\n\tint\t\t\t\tirq;\n\tspinlock_t\t\t\tirq_lock;\n\n\tstruct timer_list\t\tcmd_timeout;\n\n\tunsigned int\t\t\tslot_id;\n\tstruct mmc_host\t\t\t*mmc;\n\n\tstruct mmc_request\t\t*mrq;\n\tstruct mmc_command\t\t*cmd;\n\tint\t\t\t\terror;\n};\n\nstatic void meson_mx_mmc_mask_bits(struct mmc_host *mmc, char reg, u32 mask,\n\t\t\t\t   u32 val)\n{\n\tstruct meson_mx_mmc_host *host = mmc_priv(mmc);\n\tu32 regval;\n\n\tregval = readl(host->base + reg);\n\tregval &= ~mask;\n\tregval |= (val & mask);\n\n\twritel(regval, host->base + reg);\n}\n\nstatic void meson_mx_mmc_soft_reset(struct meson_mx_mmc_host *host)\n{\n\twritel(MESON_MX_SDIO_IRQC_SOFT_RESET, host->base + MESON_MX_SDIO_IRQC);\n\tudelay(2);\n}\n\nstatic struct mmc_command *meson_mx_mmc_get_next_cmd(struct mmc_command *cmd)\n{\n\tif (cmd->opcode == MMC_SET_BLOCK_COUNT && !cmd->error)\n\t\treturn cmd->mrq->cmd;\n\telse if (mmc_op_multi(cmd->opcode) &&\n\t\t (!cmd->mrq->sbc || cmd->error || cmd->data->error))\n\t\treturn cmd->mrq->stop;\n\telse\n\t\treturn NULL;\n}\n\nstatic void meson_mx_mmc_start_cmd(struct mmc_host *mmc,\n\t\t\t\t   struct mmc_command *cmd)\n{\n\tstruct meson_mx_mmc_host *host = mmc_priv(mmc);\n\tunsigned int pack_size;\n\tunsigned long irqflags, timeout;\n\tu32 mult, send = 0, ext = 0;\n\n\thost->cmd = cmd;\n\n\tif (cmd->busy_timeout)\n\t\ttimeout = msecs_to_jiffies(cmd->busy_timeout);\n\telse\n\t\ttimeout = msecs_to_jiffies(1000);\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_R1:\n\tcase MMC_RSP_R1B:\n\tcase MMC_RSP_R3:\n\t\t \n\t\tsend |= FIELD_PREP(MESON_MX_SDIO_SEND_CMD_RESP_BITS_MASK, 45);\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\t \n\t\tsend |= FIELD_PREP(MESON_MX_SDIO_SEND_CMD_RESP_BITS_MASK, 133);\n\t\tsend |= MESON_MX_SDIO_SEND_RESP_CRC7_FROM_8;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!(cmd->flags & MMC_RSP_CRC))\n\t\tsend |= MESON_MX_SDIO_SEND_RESP_WITHOUT_CRC7;\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tsend |= MESON_MX_SDIO_SEND_CHECK_DAT0_BUSY;\n\n\tif (cmd->data) {\n\t\tsend |= FIELD_PREP(MESON_MX_SDIO_SEND_REPEAT_PACKAGE_TIMES_MASK,\n\t\t\t\t   (cmd->data->blocks - 1));\n\n\t\tpack_size = cmd->data->blksz * BITS_PER_BYTE;\n\t\tif (mmc->ios.bus_width == MMC_BUS_WIDTH_4)\n\t\t\tpack_size += MESON_MX_SDIO_RESPONSE_CRC16_BITS * 4;\n\t\telse\n\t\t\tpack_size += MESON_MX_SDIO_RESPONSE_CRC16_BITS * 1;\n\n\t\text |= FIELD_PREP(MESON_MX_SDIO_EXT_DATA_RW_NUMBER_MASK,\n\t\t\t\t  pack_size);\n\n\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\tsend |= MESON_MX_SDIO_SEND_DATA;\n\t\telse\n\t\t\tsend |= MESON_MX_SDIO_SEND_RESP_HAS_DATA;\n\n\t\tcmd->data->bytes_xfered = 0;\n\t}\n\n\tsend |= FIELD_PREP(MESON_MX_SDIO_SEND_COMMAND_INDEX_MASK,\n\t\t\t   (0x40 | cmd->opcode));\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\n\tmult = readl(host->base + MESON_MX_SDIO_MULT);\n\tmult &= ~MESON_MX_SDIO_MULT_PORT_SEL_MASK;\n\tmult |= FIELD_PREP(MESON_MX_SDIO_MULT_PORT_SEL_MASK, host->slot_id);\n\tmult |= BIT(31);\n\twritel(mult, host->base + MESON_MX_SDIO_MULT);\n\n\t \n\tmeson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_IRQC,\n\t\t\t       MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN,\n\t\t\t       MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN);\n\n\t \n\tmeson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_IRQS,\n\t\t\t       MESON_MX_SDIO_IRQS_CMD_INT,\n\t\t\t       MESON_MX_SDIO_IRQS_CMD_INT);\n\n\twritel(cmd->arg, host->base + MESON_MX_SDIO_ARGU);\n\twritel(ext, host->base + MESON_MX_SDIO_EXT);\n\twritel(send, host->base + MESON_MX_SDIO_SEND);\n\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\n\tmod_timer(&host->cmd_timeout, jiffies + timeout);\n}\n\nstatic void meson_mx_mmc_request_done(struct meson_mx_mmc_host *host)\n{\n\tstruct mmc_request *mrq;\n\n\tmrq = host->mrq;\n\n\tif (host->cmd->error)\n\t\tmeson_mx_mmc_soft_reset(host);\n\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void meson_mx_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct meson_mx_mmc_host *host = mmc_priv(mmc);\n\tunsigned short vdd = ios->vdd;\n\tunsigned long clk_rate = ios->clock;\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tmeson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_CONF,\n\t\t\t\t       MESON_MX_SDIO_CONF_BUS_WIDTH, 0);\n\t\tbreak;\n\n\tcase MMC_BUS_WIDTH_4:\n\t\tmeson_mx_mmc_mask_bits(mmc, MESON_MX_SDIO_CONF,\n\t\t\t\t       MESON_MX_SDIO_CONF_BUS_WIDTH,\n\t\t\t\t       MESON_MX_SDIO_CONF_BUS_WIDTH);\n\t\tbreak;\n\n\tcase MMC_BUS_WIDTH_8:\n\tdefault:\n\t\tdev_err(mmc_dev(mmc), \"unsupported bus width: %d\\n\",\n\t\t\tios->bus_width);\n\t\thost->error = -EINVAL;\n\t\treturn;\n\t}\n\n\thost->error = clk_set_rate(host->cfg_div_clk, ios->clock);\n\tif (host->error) {\n\t\tdev_warn(mmc_dev(mmc),\n\t\t\t\t\"failed to set MMC clock to %lu: %d\\n\",\n\t\t\t\tclk_rate, host->error);\n\t\treturn;\n\t}\n\n\tmmc->actual_clock = clk_get_rate(host->cfg_div_clk);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tvdd = 0;\n\t\tfallthrough;\n\tcase MMC_POWER_UP:\n\t\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\t\thost->error = mmc_regulator_set_ocr(mmc,\n\t\t\t\t\t\t\t    mmc->supply.vmmc,\n\t\t\t\t\t\t\t    vdd);\n\t\t\tif (host->error)\n\t\t\t\treturn;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int meson_mx_mmc_map_dma(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_data *data = mrq->data;\n\tint dma_len;\n\tstruct scatterlist *sg;\n\n\tif (!data)\n\t\treturn 0;\n\n\tsg = data->sg;\n\tif (sg->offset & 3 || sg->length & 3) {\n\t\tdev_err(mmc_dev(mmc),\n\t\t\t\"unaligned scatterlist: offset %x length %d\\n\",\n\t\t\tsg->offset, sg->length);\n\t\treturn -EINVAL;\n\t}\n\n\tdma_len = dma_map_sg(mmc_dev(mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\tif (dma_len <= 0) {\n\t\tdev_err(mmc_dev(mmc), \"dma_map_sg failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_mx_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct meson_mx_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\n\tif (!host->error)\n\t\thost->error = meson_mx_mmc_map_dma(mmc, mrq);\n\n\tif (host->error) {\n\t\tcmd->error = host->error;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\thost->mrq = mrq;\n\n\tif (mrq->data)\n\t\twritel(sg_dma_address(mrq->data->sg),\n\t\t       host->base + MESON_MX_SDIO_ADDR);\n\n\tif (mrq->sbc)\n\t\tmeson_mx_mmc_start_cmd(mmc, mrq->sbc);\n\telse\n\t\tmeson_mx_mmc_start_cmd(mmc, mrq->cmd);\n}\n\nstatic void meson_mx_mmc_read_response(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_command *cmd)\n{\n\tstruct meson_mx_mmc_host *host = mmc_priv(mmc);\n\tu32 mult;\n\tint i, resp[4];\n\n\tmult = readl(host->base + MESON_MX_SDIO_MULT);\n\tmult |= MESON_MX_SDIO_MULT_WR_RD_OUT_INDEX;\n\tmult &= ~MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK;\n\tmult |= FIELD_PREP(MESON_MX_SDIO_MULT_RESP_READ_INDEX_MASK, 0);\n\twritel(mult, host->base + MESON_MX_SDIO_MULT);\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tfor (i = 0; i <= 3; i++)\n\t\t\tresp[3 - i] = readl(host->base + MESON_MX_SDIO_ARGU);\n\t\tcmd->resp[0] = (resp[0] << 8) | ((resp[1] >> 24) & 0xff);\n\t\tcmd->resp[1] = (resp[1] << 8) | ((resp[2] >> 24) & 0xff);\n\t\tcmd->resp[2] = (resp[2] << 8) | ((resp[3] >> 24) & 0xff);\n\t\tcmd->resp[3] = (resp[3] << 8);\n\t} else if (cmd->flags & MMC_RSP_PRESENT) {\n\t\tcmd->resp[0] = readl(host->base + MESON_MX_SDIO_ARGU);\n\t}\n}\n\nstatic irqreturn_t meson_mx_mmc_process_cmd_irq(struct meson_mx_mmc_host *host,\n\t\t\t\t\t\tu32 irqs, u32 send)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\n\t \n\tif (!cmd)\n\t\treturn IRQ_HANDLED;\n\n\tcmd->error = 0;\n\tmeson_mx_mmc_read_response(host->mmc, cmd);\n\n\tif (cmd->data) {\n\t\tif (!((irqs & MESON_MX_SDIO_IRQS_DATA_READ_CRC16_OK) ||\n\t\t      (irqs & MESON_MX_SDIO_IRQS_DATA_WRITE_CRC16_OK)))\n\t\t\tcmd->error = -EILSEQ;\n\t} else {\n\t\tif (!((irqs & MESON_MX_SDIO_IRQS_RESP_CRC7_OK) ||\n\t\t      (send & MESON_MX_SDIO_SEND_RESP_WITHOUT_CRC7)))\n\t\t\tcmd->error = -EILSEQ;\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t meson_mx_mmc_irq(int irq, void *data)\n{\n\tstruct meson_mx_mmc_host *host = (void *) data;\n\tu32 irqs, send;\n\tirqreturn_t ret;\n\n\tspin_lock(&host->irq_lock);\n\n\tirqs = readl(host->base + MESON_MX_SDIO_IRQS);\n\tsend = readl(host->base + MESON_MX_SDIO_SEND);\n\n\tif (irqs & MESON_MX_SDIO_IRQS_CMD_INT)\n\t\tret = meson_mx_mmc_process_cmd_irq(host, irqs, send);\n\telse\n\t\tret = IRQ_HANDLED;\n\n\t \n\twritel(irqs, host->base + MESON_MX_SDIO_IRQS);\n\n\tspin_unlock(&host->irq_lock);\n\n\treturn ret;\n}\n\nstatic irqreturn_t meson_mx_mmc_irq_thread(int irq, void *irq_data)\n{\n\tstruct meson_mx_mmc_host *host = (void *) irq_data;\n\tstruct mmc_command *cmd = host->cmd, *next_cmd;\n\n\tif (WARN_ON(!cmd))\n\t\treturn IRQ_HANDLED;\n\n\tdel_timer_sync(&host->cmd_timeout);\n\n\tif (cmd->data) {\n\t\tdma_unmap_sg(mmc_dev(host->mmc), cmd->data->sg,\n\t\t\t\tcmd->data->sg_len,\n\t\t\t\tmmc_get_dma_dir(cmd->data));\n\n\t\tcmd->data->bytes_xfered = cmd->data->blksz * cmd->data->blocks;\n\t}\n\n\tnext_cmd = meson_mx_mmc_get_next_cmd(cmd);\n\tif (next_cmd)\n\t\tmeson_mx_mmc_start_cmd(host->mmc, next_cmd);\n\telse\n\t\tmeson_mx_mmc_request_done(host);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void meson_mx_mmc_timeout(struct timer_list *t)\n{\n\tstruct meson_mx_mmc_host *host = from_timer(host, t, cmd_timeout);\n\tunsigned long irqflags;\n\tu32 irqc;\n\n\tspin_lock_irqsave(&host->irq_lock, irqflags);\n\n\t \n\tirqc = readl(host->base + MESON_MX_SDIO_IRQC);\n\tirqc &= ~MESON_MX_SDIO_IRQC_ARC_CMD_INT_EN;\n\twritel(irqc, host->base + MESON_MX_SDIO_IRQC);\n\n\tspin_unlock_irqrestore(&host->irq_lock, irqflags);\n\n\t \n\tif (!host->cmd)\n\t\treturn;\n\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"Timeout on CMD%u (IRQS = 0x%08x, ARGU = 0x%08x)\\n\",\n\t\thost->cmd->opcode, readl(host->base + MESON_MX_SDIO_IRQS),\n\t\treadl(host->base + MESON_MX_SDIO_ARGU));\n\n\thost->cmd->error = -ETIMEDOUT;\n\n\tmeson_mx_mmc_request_done(host);\n}\n\nstatic struct mmc_host_ops meson_mx_mmc_ops = {\n\t.request\t\t= meson_mx_mmc_request,\n\t.set_ios\t\t= meson_mx_mmc_set_ios,\n\t.get_cd\t\t\t= mmc_gpio_get_cd,\n\t.get_ro\t\t\t= mmc_gpio_get_ro,\n};\n\nstatic struct platform_device *meson_mx_mmc_slot_pdev(struct device *parent)\n{\n\tstruct device_node *slot_node;\n\tstruct platform_device *pdev;\n\n\t \n\tslot_node = of_get_compatible_child(parent->of_node, \"mmc-slot\");\n\tif (!slot_node) {\n\t\tdev_warn(parent, \"no 'mmc-slot' sub-node found\\n\");\n\t\treturn ERR_PTR(-ENOENT);\n\t}\n\n\tpdev = of_platform_device_create(slot_node, NULL, parent);\n\tof_node_put(slot_node);\n\n\treturn pdev;\n}\n\nstatic int meson_mx_mmc_add_host(struct meson_mx_mmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct device *slot_dev = mmc_dev(mmc);\n\tint ret;\n\n\tif (of_property_read_u32(slot_dev->of_node, \"reg\", &host->slot_id)) {\n\t\tdev_err(slot_dev, \"missing 'reg' property\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (host->slot_id >= MESON_MX_SDIO_MAX_SLOTS) {\n\t\tdev_err(slot_dev, \"invalid 'reg' property value %d\\n\",\n\t\t\thost->slot_id);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc->max_req_size = MESON_MX_SDIO_BOUNCE_REQ_SIZE;\n\tmmc->max_seg_size = mmc->max_req_size;\n\tmmc->max_blk_count =\n\t\tFIELD_GET(MESON_MX_SDIO_SEND_REPEAT_PACKAGE_TIMES_MASK,\n\t\t\t  0xffffffff);\n\tmmc->max_blk_size = FIELD_GET(MESON_MX_SDIO_EXT_DATA_RW_NUMBER_MASK,\n\t\t\t\t      0xffffffff);\n\tmmc->max_blk_size -= (4 * MESON_MX_SDIO_RESPONSE_CRC16_BITS);\n\tmmc->max_blk_size /= BITS_PER_BYTE;\n\n\t \n\tmmc->f_min = clk_round_rate(host->cfg_div_clk, 1);\n\tmmc->f_max = clk_round_rate(host->cfg_div_clk,\n\t\t\t\t    clk_get_rate(host->parent_clk));\n\n\tmmc->caps |= MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY;\n\tmmc->ops = &meson_mx_mmc_ops;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int meson_mx_mmc_register_clks(struct meson_mx_mmc_host *host)\n{\n\tstruct clk_init_data init;\n\tconst char *clk_div_parent, *clk_fixed_factor_parent;\n\n\tclk_fixed_factor_parent = __clk_get_name(host->parent_clk);\n\tinit.name = devm_kasprintf(host->controller_dev, GFP_KERNEL,\n\t\t\t\t   \"%s#fixed_factor\",\n\t\t\t\t   dev_name(host->controller_dev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &clk_fixed_factor_ops;\n\tinit.flags = 0;\n\tinit.parent_names = &clk_fixed_factor_parent;\n\tinit.num_parents = 1;\n\thost->fixed_factor.div = 2;\n\thost->fixed_factor.mult = 1;\n\thost->fixed_factor.hw.init = &init;\n\n\thost->fixed_factor_clk = devm_clk_register(host->controller_dev,\n\t\t\t\t\t\t &host->fixed_factor.hw);\n\tif (WARN_ON(IS_ERR(host->fixed_factor_clk)))\n\t\treturn PTR_ERR(host->fixed_factor_clk);\n\n\tclk_div_parent = __clk_get_name(host->fixed_factor_clk);\n\tinit.name = devm_kasprintf(host->controller_dev, GFP_KERNEL,\n\t\t\t\t   \"%s#div\", dev_name(host->controller_dev));\n\tif (!init.name)\n\t\treturn -ENOMEM;\n\n\tinit.ops = &clk_divider_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tinit.parent_names = &clk_div_parent;\n\tinit.num_parents = 1;\n\thost->cfg_div.reg = host->base + MESON_MX_SDIO_CONF;\n\thost->cfg_div.shift = MESON_MX_SDIO_CONF_CMD_CLK_DIV_SHIFT;\n\thost->cfg_div.width = MESON_MX_SDIO_CONF_CMD_CLK_DIV_WIDTH;\n\thost->cfg_div.hw.init = &init;\n\thost->cfg_div.flags = CLK_DIVIDER_ALLOW_ZERO;\n\n\thost->cfg_div_clk = devm_clk_register(host->controller_dev,\n\t\t\t\t\t      &host->cfg_div.hw);\n\tif (WARN_ON(IS_ERR(host->cfg_div_clk)))\n\t\treturn PTR_ERR(host->cfg_div_clk);\n\n\treturn 0;\n}\n\nstatic int meson_mx_mmc_probe(struct platform_device *pdev)\n{\n\tstruct platform_device *slot_pdev;\n\tstruct mmc_host *mmc;\n\tstruct meson_mx_mmc_host *host;\n\tint ret, irq;\n\tu32 conf;\n\n\tslot_pdev = meson_mx_mmc_slot_pdev(&pdev->dev);\n\tif (!slot_pdev)\n\t\treturn -ENODEV;\n\telse if (IS_ERR(slot_pdev))\n\t\treturn PTR_ERR(slot_pdev);\n\n\tmmc = mmc_alloc_host(sizeof(*host), &slot_pdev->dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto error_unregister_slot_pdev;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->controller_dev = &pdev->dev;\n\n\tspin_lock_init(&host->irq_lock);\n\ttimer_setup(&host->cmd_timeout, meson_mx_mmc_timeout, 0);\n\n\tplatform_set_drvdata(pdev, host);\n\n\thost->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto error_free_mmc;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto error_free_mmc;\n\t}\n\n\tret = devm_request_threaded_irq(host->controller_dev, irq,\n\t\t\t\t\tmeson_mx_mmc_irq,\n\t\t\t\t\tmeson_mx_mmc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t\tNULL, host);\n\tif (ret)\n\t\tgoto error_free_mmc;\n\n\thost->core_clk = devm_clk_get(host->controller_dev, \"core\");\n\tif (IS_ERR(host->core_clk)) {\n\t\tret = PTR_ERR(host->core_clk);\n\t\tgoto error_free_mmc;\n\t}\n\n\thost->parent_clk = devm_clk_get(host->controller_dev, \"clkin\");\n\tif (IS_ERR(host->parent_clk)) {\n\t\tret = PTR_ERR(host->parent_clk);\n\t\tgoto error_free_mmc;\n\t}\n\n\tret = meson_mx_mmc_register_clks(host);\n\tif (ret)\n\t\tgoto error_free_mmc;\n\n\tret = clk_prepare_enable(host->core_clk);\n\tif (ret) {\n\t\tdev_err(host->controller_dev, \"Failed to enable core clock\\n\");\n\t\tgoto error_free_mmc;\n\t}\n\n\tret = clk_prepare_enable(host->cfg_div_clk);\n\tif (ret) {\n\t\tdev_err(host->controller_dev, \"Failed to enable MMC clock\\n\");\n\t\tgoto error_disable_core_clk;\n\t}\n\n\tconf = 0;\n\tconf |= FIELD_PREP(MESON_MX_SDIO_CONF_CMD_ARGUMENT_BITS_MASK, 39);\n\tconf |= FIELD_PREP(MESON_MX_SDIO_CONF_M_ENDIAN_MASK, 0x3);\n\tconf |= FIELD_PREP(MESON_MX_SDIO_CONF_WRITE_NWR_MASK, 0x2);\n\tconf |= FIELD_PREP(MESON_MX_SDIO_CONF_WRITE_CRC_OK_STATUS_MASK, 0x2);\n\twritel(conf, host->base + MESON_MX_SDIO_CONF);\n\n\tmeson_mx_mmc_soft_reset(host);\n\n\tret = meson_mx_mmc_add_host(host);\n\tif (ret)\n\t\tgoto error_disable_clks;\n\n\treturn 0;\n\nerror_disable_clks:\n\tclk_disable_unprepare(host->cfg_div_clk);\nerror_disable_core_clk:\n\tclk_disable_unprepare(host->core_clk);\nerror_free_mmc:\n\tmmc_free_host(mmc);\nerror_unregister_slot_pdev:\n\tof_platform_device_destroy(&slot_pdev->dev, NULL);\n\treturn ret;\n}\n\nstatic void meson_mx_mmc_remove(struct platform_device *pdev)\n{\n\tstruct meson_mx_mmc_host *host = platform_get_drvdata(pdev);\n\tstruct device *slot_dev = mmc_dev(host->mmc);\n\n\tdel_timer_sync(&host->cmd_timeout);\n\n\tmmc_remove_host(host->mmc);\n\n\tof_platform_device_destroy(slot_dev, NULL);\n\n\tclk_disable_unprepare(host->cfg_div_clk);\n\tclk_disable_unprepare(host->core_clk);\n\n\tmmc_free_host(host->mmc);\n}\n\nstatic const struct of_device_id meson_mx_mmc_of_match[] = {\n\t{ .compatible = \"amlogic,meson8-sdio\", },\n\t{ .compatible = \"amlogic,meson8b-sdio\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_mx_mmc_of_match);\n\nstatic struct platform_driver meson_mx_mmc_driver = {\n\t.probe   = meson_mx_mmc_probe,\n\t.remove_new = meson_mx_mmc_remove,\n\t.driver  = {\n\t\t.name = \"meson-mx-sdio\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(meson_mx_mmc_of_match),\n\t},\n};\n\nmodule_platform_driver(meson_mx_mmc_driver);\n\nMODULE_DESCRIPTION(\"Meson6, Meson8 and Meson8b SDIO/MMC Host Driver\");\nMODULE_AUTHOR(\"Carlo Caione <carlo@endlessm.com>\");\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}