{
  "module_name": "meson-gx-mmc.c",
  "hash_id": "d3e1605e8cc8963eff1687a37881529083259a8170b58e0d9e22838d32b356a9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/meson-gx-mmc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/iopoll.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/dma-mapping.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/io.h>\n#include <linux/clk.h>\n#include <linux/clk-provider.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/interrupt.h>\n#include <linux/bitfield.h>\n#include <linux/pinctrl/consumer.h>\n\n#define DRIVER_NAME \"meson-gx-mmc\"\n\n#define SD_EMMC_CLOCK 0x0\n#define   CLK_DIV_MASK GENMASK(5, 0)\n#define   CLK_SRC_MASK GENMASK(7, 6)\n#define   CLK_CORE_PHASE_MASK GENMASK(9, 8)\n#define   CLK_TX_PHASE_MASK GENMASK(11, 10)\n#define   CLK_RX_PHASE_MASK GENMASK(13, 12)\n#define   CLK_PHASE_0 0\n#define   CLK_PHASE_180 2\n#define   CLK_V2_TX_DELAY_MASK GENMASK(19, 16)\n#define   CLK_V2_RX_DELAY_MASK GENMASK(23, 20)\n#define   CLK_V2_ALWAYS_ON BIT(24)\n#define   CLK_V2_IRQ_SDIO_SLEEP BIT(25)\n\n#define   CLK_V3_TX_DELAY_MASK GENMASK(21, 16)\n#define   CLK_V3_RX_DELAY_MASK GENMASK(27, 22)\n#define   CLK_V3_ALWAYS_ON BIT(28)\n#define   CLK_V3_IRQ_SDIO_SLEEP BIT(29)\n\n#define   CLK_TX_DELAY_MASK(h)\t\t(h->data->tx_delay_mask)\n#define   CLK_RX_DELAY_MASK(h)\t\t(h->data->rx_delay_mask)\n#define   CLK_ALWAYS_ON(h)\t\t(h->data->always_on)\n#define   CLK_IRQ_SDIO_SLEEP(h)\t\t(h->data->irq_sdio_sleep)\n\n#define SD_EMMC_DELAY 0x4\n#define SD_EMMC_ADJUST 0x8\n#define   ADJUST_ADJ_DELAY_MASK GENMASK(21, 16)\n#define   ADJUST_DS_EN BIT(15)\n#define   ADJUST_ADJ_EN BIT(13)\n\n#define SD_EMMC_DELAY1 0x4\n#define SD_EMMC_DELAY2 0x8\n#define SD_EMMC_V3_ADJUST 0xc\n\n#define SD_EMMC_CALOUT 0x10\n#define SD_EMMC_START 0x40\n#define   START_DESC_INIT BIT(0)\n#define   START_DESC_BUSY BIT(1)\n#define   START_DESC_ADDR_MASK GENMASK(31, 2)\n\n#define SD_EMMC_CFG 0x44\n#define   CFG_BUS_WIDTH_MASK GENMASK(1, 0)\n#define   CFG_BUS_WIDTH_1 0x0\n#define   CFG_BUS_WIDTH_4 0x1\n#define   CFG_BUS_WIDTH_8 0x2\n#define   CFG_DDR BIT(2)\n#define   CFG_BLK_LEN_MASK GENMASK(7, 4)\n#define   CFG_RESP_TIMEOUT_MASK GENMASK(11, 8)\n#define   CFG_RC_CC_MASK GENMASK(15, 12)\n#define   CFG_STOP_CLOCK BIT(22)\n#define   CFG_CLK_ALWAYS_ON BIT(18)\n#define   CFG_CHK_DS BIT(20)\n#define   CFG_AUTO_CLK BIT(23)\n#define   CFG_ERR_ABORT BIT(27)\n\n#define SD_EMMC_STATUS 0x48\n#define   STATUS_BUSY BIT(31)\n#define   STATUS_DESC_BUSY BIT(30)\n#define   STATUS_DATI GENMASK(23, 16)\n\n#define SD_EMMC_IRQ_EN 0x4c\n#define   IRQ_RXD_ERR_MASK GENMASK(7, 0)\n#define   IRQ_TXD_ERR BIT(8)\n#define   IRQ_DESC_ERR BIT(9)\n#define   IRQ_RESP_ERR BIT(10)\n#define   IRQ_CRC_ERR \\\n\t(IRQ_RXD_ERR_MASK | IRQ_TXD_ERR | IRQ_DESC_ERR | IRQ_RESP_ERR)\n#define   IRQ_RESP_TIMEOUT BIT(11)\n#define   IRQ_DESC_TIMEOUT BIT(12)\n#define   IRQ_TIMEOUTS \\\n\t(IRQ_RESP_TIMEOUT | IRQ_DESC_TIMEOUT)\n#define   IRQ_END_OF_CHAIN BIT(13)\n#define   IRQ_RESP_STATUS BIT(14)\n#define   IRQ_SDIO BIT(15)\n#define   IRQ_EN_MASK \\\n\t(IRQ_CRC_ERR | IRQ_TIMEOUTS | IRQ_END_OF_CHAIN)\n\n#define SD_EMMC_CMD_CFG 0x50\n#define SD_EMMC_CMD_ARG 0x54\n#define SD_EMMC_CMD_DAT 0x58\n#define SD_EMMC_CMD_RSP 0x5c\n#define SD_EMMC_CMD_RSP1 0x60\n#define SD_EMMC_CMD_RSP2 0x64\n#define SD_EMMC_CMD_RSP3 0x68\n\n#define SD_EMMC_RXD 0x94\n#define SD_EMMC_TXD 0x94\n#define SD_EMMC_LAST_REG SD_EMMC_TXD\n\n#define SD_EMMC_SRAM_DATA_BUF_LEN 1536\n#define SD_EMMC_SRAM_DATA_BUF_OFF 0x200\n\n#define SD_EMMC_CFG_BLK_SIZE 512  \n#define SD_EMMC_CFG_RESP_TIMEOUT 256  \n#define SD_EMMC_CMD_TIMEOUT 1024  \n#define SD_EMMC_CMD_TIMEOUT_DATA 4096  \n#define SD_EMMC_CFG_CMD_GAP 16  \n#define SD_EMMC_DESC_BUF_LEN PAGE_SIZE\n\n#define SD_EMMC_PRE_REQ_DONE BIT(0)\n#define SD_EMMC_DESC_CHAIN_MODE BIT(1)\n\n#define MUX_CLK_NUM_PARENTS 2\n\nstruct meson_mmc_data {\n\tunsigned int tx_delay_mask;\n\tunsigned int rx_delay_mask;\n\tunsigned int always_on;\n\tunsigned int adjust;\n\tunsigned int irq_sdio_sleep;\n};\n\nstruct sd_emmc_desc {\n\tu32 cmd_cfg;\n\tu32 cmd_arg;\n\tu32 cmd_data;\n\tu32 cmd_resp;\n};\n\nstruct meson_host {\n\tstruct\tdevice\t\t*dev;\n\tconst struct meson_mmc_data *data;\n\tstruct\tmmc_host\t*mmc;\n\tstruct\tmmc_command\t*cmd;\n\n\tvoid __iomem *regs;\n\tstruct clk *mux_clk;\n\tstruct clk *mmc_clk;\n\tunsigned long req_rate;\n\tbool ddr;\n\n\tbool dram_access_quirk;\n\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_clk_gate;\n\n\tunsigned int bounce_buf_size;\n\tvoid *bounce_buf;\n\tvoid __iomem *bounce_iomem_buf;\n\tdma_addr_t bounce_dma_addr;\n\tstruct sd_emmc_desc *descs;\n\tdma_addr_t descs_dma_addr;\n\n\tint irq;\n\n\tbool needs_pre_post_req;\n\n\tspinlock_t lock;\n};\n\n#define CMD_CFG_LENGTH_MASK GENMASK(8, 0)\n#define CMD_CFG_BLOCK_MODE BIT(9)\n#define CMD_CFG_R1B BIT(10)\n#define CMD_CFG_END_OF_CHAIN BIT(11)\n#define CMD_CFG_TIMEOUT_MASK GENMASK(15, 12)\n#define CMD_CFG_NO_RESP BIT(16)\n#define CMD_CFG_NO_CMD BIT(17)\n#define CMD_CFG_DATA_IO BIT(18)\n#define CMD_CFG_DATA_WR BIT(19)\n#define CMD_CFG_RESP_NOCRC BIT(20)\n#define CMD_CFG_RESP_128 BIT(21)\n#define CMD_CFG_RESP_NUM BIT(22)\n#define CMD_CFG_DATA_NUM BIT(23)\n#define CMD_CFG_CMD_INDEX_MASK GENMASK(29, 24)\n#define CMD_CFG_ERROR BIT(30)\n#define CMD_CFG_OWNER BIT(31)\n\n#define CMD_DATA_MASK GENMASK(31, 2)\n#define CMD_DATA_BIG_ENDIAN BIT(1)\n#define CMD_DATA_SRAM BIT(0)\n#define CMD_RESP_MASK GENMASK(31, 1)\n#define CMD_RESP_SRAM BIT(0)\n\nstatic unsigned int meson_mmc_get_timeout_msecs(struct mmc_data *data)\n{\n\tunsigned int timeout = data->timeout_ns / NSEC_PER_MSEC;\n\n\tif (!timeout)\n\t\treturn SD_EMMC_CMD_TIMEOUT_DATA;\n\n\ttimeout = roundup_pow_of_two(timeout);\n\n\treturn min(timeout, 32768U);  \n}\n\nstatic struct mmc_command *meson_mmc_get_next_command(struct mmc_command *cmd)\n{\n\tif (cmd->opcode == MMC_SET_BLOCK_COUNT && !cmd->error)\n\t\treturn cmd->mrq->cmd;\n\telse if (mmc_op_multi(cmd->opcode) &&\n\t\t (!cmd->mrq->sbc || cmd->error || cmd->data->error))\n\t\treturn cmd->mrq->stop;\n\telse\n\t\treturn NULL;\n}\n\nstatic void meson_mmc_get_transfer_mode(struct mmc_host *mmc,\n\t\t\t\t\tstruct mmc_request *mrq)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\tstruct scatterlist *sg;\n\tint i;\n\n\t \n\tif (host->dram_access_quirk)\n\t\treturn;\n\n\t \n\tif (data->blocks > 1 || mrq->cmd->opcode == SD_IO_RW_EXTENDED) {\n\t\t \n\t\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t\tif (sg->length % data->blksz) {\n\t\t\t\tdev_warn_once(mmc_dev(mmc),\n\t\t\t\t\t      \"unaligned sg len %u blksize %u, disabling descriptor DMA for transfer\\n\",\n\t\t\t\t\t      sg->length, data->blksz);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\t \n\t\tif (sg->offset % 8) {\n\t\t\tdev_warn_once(mmc_dev(mmc),\n\t\t\t\t      \"unaligned sg offset %u, disabling descriptor DMA for transfer\\n\",\n\t\t\t\t      sg->offset);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdata->host_cookie |= SD_EMMC_DESC_CHAIN_MODE;\n}\n\nstatic inline bool meson_mmc_desc_chain_mode(const struct mmc_data *data)\n{\n\treturn data->host_cookie & SD_EMMC_DESC_CHAIN_MODE;\n}\n\nstatic inline bool meson_mmc_bounce_buf_read(const struct mmc_data *data)\n{\n\treturn data && data->flags & MMC_DATA_READ &&\n\t       !meson_mmc_desc_chain_mode(data);\n}\n\nstatic void meson_mmc_pre_req(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tmeson_mmc_get_transfer_mode(mmc, mrq);\n\tdata->host_cookie |= SD_EMMC_PRE_REQ_DONE;\n\n\tif (!meson_mmc_desc_chain_mode(data))\n\t\treturn;\n\n\tdata->sg_count = dma_map_sg(mmc_dev(mmc), data->sg, data->sg_len,\n                                   mmc_get_dma_dir(data));\n\tif (!data->sg_count)\n\t\tdev_err(mmc_dev(mmc), \"dma_map_sg failed\");\n}\n\nstatic void meson_mmc_post_req(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\t\t       int err)\n{\n\tstruct mmc_data *data = mrq->data;\n\n\tif (data && meson_mmc_desc_chain_mode(data) && data->sg_count)\n\t\tdma_unmap_sg(mmc_dev(mmc), data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n}\n\n \nstatic void meson_mmc_clk_gate(struct meson_host *host)\n{\n\tu32 cfg;\n\n\tif (host->pins_clk_gate) {\n\t\tpinctrl_select_state(host->pinctrl, host->pins_clk_gate);\n\t} else {\n\t\t \n\t\tcfg = readl(host->regs + SD_EMMC_CFG);\n\t\tcfg |= CFG_STOP_CLOCK;\n\t\twritel(cfg, host->regs + SD_EMMC_CFG);\n\t}\n}\n\nstatic void meson_mmc_clk_ungate(struct meson_host *host)\n{\n\tu32 cfg;\n\n\tif (host->pins_clk_gate)\n\t\tpinctrl_select_default_state(host->dev);\n\n\t \n\tcfg = readl(host->regs + SD_EMMC_CFG);\n\tcfg &= ~CFG_STOP_CLOCK;\n\twritel(cfg, host->regs + SD_EMMC_CFG);\n}\n\nstatic int meson_mmc_clk_set(struct meson_host *host, unsigned long rate,\n\t\t\t     bool ddr)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret;\n\tu32 cfg;\n\n\t \n\tif (host->ddr == ddr && host->req_rate == rate)\n\t\treturn 0;\n\n\t \n\tmeson_mmc_clk_gate(host);\n\thost->req_rate = 0;\n\tmmc->actual_clock = 0;\n\n\t \n\tif (!rate)\n\t\treturn 0;\n\n\t \n\tcfg = readl(host->regs + SD_EMMC_CFG);\n\tcfg |= CFG_STOP_CLOCK;\n\twritel(cfg, host->regs + SD_EMMC_CFG);\n\n\tif (ddr) {\n\t\t \n\t\trate <<= 1;\n\t\tcfg |= CFG_DDR;\n\t} else {\n\t\tcfg &= ~CFG_DDR;\n\t}\n\twritel(cfg, host->regs + SD_EMMC_CFG);\n\thost->ddr = ddr;\n\n\tret = clk_set_rate(host->mmc_clk, rate);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Unable to set cfg_div_clk to %lu. ret=%d\\n\",\n\t\t\trate, ret);\n\t\treturn ret;\n\t}\n\n\thost->req_rate = rate;\n\tmmc->actual_clock = clk_get_rate(host->mmc_clk);\n\n\t \n\tif (ddr) {\n\t\thost->req_rate >>= 1;\n\t\tmmc->actual_clock >>= 1;\n\t}\n\n\tdev_dbg(host->dev, \"clk rate: %u Hz\\n\", mmc->actual_clock);\n\tif (rate != mmc->actual_clock)\n\t\tdev_dbg(host->dev, \"requested rate was %lu\\n\", rate);\n\n\t \n\tmeson_mmc_clk_ungate(host);\n\n\treturn 0;\n}\n\n \nstatic int meson_mmc_clk_init(struct meson_host *host)\n{\n\tstruct clk_init_data init;\n\tstruct clk_mux *mux;\n\tstruct clk_divider *div;\n\tchar clk_name[32];\n\tint i, ret = 0;\n\tconst char *mux_parent_names[MUX_CLK_NUM_PARENTS];\n\tconst char *clk_parent[1];\n\tu32 clk_reg;\n\n\t \n\tclk_reg = CLK_ALWAYS_ON(host);\n\tclk_reg |= CLK_DIV_MASK;\n\tclk_reg |= FIELD_PREP(CLK_CORE_PHASE_MASK, CLK_PHASE_180);\n\tclk_reg |= FIELD_PREP(CLK_TX_PHASE_MASK, CLK_PHASE_0);\n\tclk_reg |= FIELD_PREP(CLK_RX_PHASE_MASK, CLK_PHASE_0);\n\tif (host->mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\tclk_reg |= CLK_IRQ_SDIO_SLEEP(host);\n\twritel(clk_reg, host->regs + SD_EMMC_CLOCK);\n\n\t \n\tfor (i = 0; i < MUX_CLK_NUM_PARENTS; i++) {\n\t\tstruct clk *clk;\n\t\tchar name[16];\n\n\t\tsnprintf(name, sizeof(name), \"clkin%d\", i);\n\t\tclk = devm_clk_get(host->dev, name);\n\t\tif (IS_ERR(clk))\n\t\t\treturn dev_err_probe(host->dev, PTR_ERR(clk),\n\t\t\t\t\t     \"Missing clock %s\\n\", name);\n\n\t\tmux_parent_names[i] = __clk_get_name(clk);\n\t}\n\n\t \n\tmux = devm_kzalloc(host->dev, sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn -ENOMEM;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s#mux\", dev_name(host->dev));\n\tinit.name = clk_name;\n\tinit.ops = &clk_mux_ops;\n\tinit.flags = 0;\n\tinit.parent_names = mux_parent_names;\n\tinit.num_parents = MUX_CLK_NUM_PARENTS;\n\n\tmux->reg = host->regs + SD_EMMC_CLOCK;\n\tmux->shift = __ffs(CLK_SRC_MASK);\n\tmux->mask = CLK_SRC_MASK >> mux->shift;\n\tmux->hw.init = &init;\n\n\thost->mux_clk = devm_clk_register(host->dev, &mux->hw);\n\tif (WARN_ON(IS_ERR(host->mux_clk)))\n\t\treturn PTR_ERR(host->mux_clk);\n\n\t \n\tdiv = devm_kzalloc(host->dev, sizeof(*div), GFP_KERNEL);\n\tif (!div)\n\t\treturn -ENOMEM;\n\n\tsnprintf(clk_name, sizeof(clk_name), \"%s#div\", dev_name(host->dev));\n\tinit.name = clk_name;\n\tinit.ops = &clk_divider_ops;\n\tinit.flags = CLK_SET_RATE_PARENT;\n\tclk_parent[0] = __clk_get_name(host->mux_clk);\n\tinit.parent_names = clk_parent;\n\tinit.num_parents = 1;\n\n\tdiv->reg = host->regs + SD_EMMC_CLOCK;\n\tdiv->shift = __ffs(CLK_DIV_MASK);\n\tdiv->width = __builtin_popcountl(CLK_DIV_MASK);\n\tdiv->hw.init = &init;\n\tdiv->flags = CLK_DIVIDER_ONE_BASED;\n\n\thost->mmc_clk = devm_clk_register(host->dev, &div->hw);\n\tif (WARN_ON(IS_ERR(host->mmc_clk)))\n\t\treturn PTR_ERR(host->mmc_clk);\n\n\t \n\thost->mmc->f_min = clk_round_rate(host->mmc_clk, 400000);\n\tret = clk_set_rate(host->mmc_clk, host->mmc->f_min);\n\tif (ret)\n\t\treturn ret;\n\n\treturn clk_prepare_enable(host->mmc_clk);\n}\n\nstatic void meson_mmc_disable_resampling(struct meson_host *host)\n{\n\tunsigned int val = readl(host->regs + host->data->adjust);\n\n\tval &= ~ADJUST_ADJ_EN;\n\twritel(val, host->regs + host->data->adjust);\n}\n\nstatic void meson_mmc_reset_resampling(struct meson_host *host)\n{\n\tunsigned int val;\n\n\tmeson_mmc_disable_resampling(host);\n\n\tval = readl(host->regs + host->data->adjust);\n\tval &= ~ADJUST_ADJ_DELAY_MASK;\n\twritel(val, host->regs + host->data->adjust);\n}\n\nstatic int meson_mmc_resampling_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tunsigned int val, dly, max_dly, i;\n\tint ret;\n\n\t \n\tmax_dly = DIV_ROUND_UP(clk_get_rate(host->mux_clk),\n\t\t\t       clk_get_rate(host->mmc_clk));\n\n\tval = readl(host->regs + host->data->adjust);\n\tval |= ADJUST_ADJ_EN;\n\twritel(val, host->regs + host->data->adjust);\n\n\tif (mmc_doing_retune(mmc))\n\t\tdly = FIELD_GET(ADJUST_ADJ_DELAY_MASK, val) + 1;\n\telse\n\t\tdly = 0;\n\n\tfor (i = 0; i < max_dly; i++) {\n\t\tval &= ~ADJUST_ADJ_DELAY_MASK;\n\t\tval |= FIELD_PREP(ADJUST_ADJ_DELAY_MASK, (dly + i) % max_dly);\n\t\twritel(val, host->regs + host->data->adjust);\n\n\t\tret = mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (!ret) {\n\t\t\tdev_dbg(mmc_dev(mmc), \"resampling delay: %u\\n\",\n\t\t\t\t(dly + i) % max_dly);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tmeson_mmc_reset_resampling(host);\n\treturn -EIO;\n}\n\nstatic int meson_mmc_prepare_ios_clock(struct meson_host *host,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tbool ddr;\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tddr = true;\n\t\tbreak;\n\n\tdefault:\n\t\tddr = false;\n\t\tbreak;\n\t}\n\n\treturn meson_mmc_clk_set(host, ios->clock, ddr);\n}\n\nstatic void meson_mmc_check_resampling(struct meson_host *host,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_LEGACY:\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tmeson_mmc_disable_resampling(host);\n\t\tbreak;\n\t}\n}\n\nstatic void meson_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tu32 bus_width, val;\n\tint err;\n\n\t \n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\t\tmmc_regulator_disable_vqmmc(mmc);\n\n\t\tbreak;\n\n\tcase MMC_POWER_UP:\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\n\n\t\tbreak;\n\n\tcase MMC_POWER_ON:\n\t\tmmc_regulator_enable_vqmmc(mmc);\n\n\t\tbreak;\n\t}\n\n\t \n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tbus_width = CFG_BUS_WIDTH_1;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tbus_width = CFG_BUS_WIDTH_4;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tbus_width = CFG_BUS_WIDTH_8;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(host->dev, \"Invalid ios->bus_width: %u.  Setting to 4.\\n\",\n\t\t\tios->bus_width);\n\t\tbus_width = CFG_BUS_WIDTH_4;\n\t}\n\n\tval = readl(host->regs + SD_EMMC_CFG);\n\tval &= ~CFG_BUS_WIDTH_MASK;\n\tval |= FIELD_PREP(CFG_BUS_WIDTH_MASK, bus_width);\n\twritel(val, host->regs + SD_EMMC_CFG);\n\n\tmeson_mmc_check_resampling(host, ios);\n\terr = meson_mmc_prepare_ios_clock(host, ios);\n\tif (err)\n\t\tdev_err(host->dev, \"Failed to set clock: %d\\n,\", err);\n\n\tdev_dbg(host->dev, \"SD_EMMC_CFG:  0x%08x\\n\", val);\n}\n\nstatic void meson_mmc_request_done(struct mmc_host *mmc,\n\t\t\t\t   struct mmc_request *mrq)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\n\thost->cmd = NULL;\n\tif (host->needs_pre_post_req)\n\t\tmeson_mmc_post_req(mmc, mrq, 0);\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void meson_mmc_set_blksz(struct mmc_host *mmc, unsigned int blksz)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tu32 cfg, blksz_old;\n\n\tcfg = readl(host->regs + SD_EMMC_CFG);\n\tblksz_old = FIELD_GET(CFG_BLK_LEN_MASK, cfg);\n\n\tif (!is_power_of_2(blksz))\n\t\tdev_err(host->dev, \"blksz %u is not a power of 2\\n\", blksz);\n\n\tblksz = ilog2(blksz);\n\n\t \n\tif (blksz == blksz_old)\n\t\treturn;\n\n\tdev_dbg(host->dev, \"%s: update blk_len %d -> %d\\n\", __func__,\n\t\tblksz_old, blksz);\n\n\tcfg &= ~CFG_BLK_LEN_MASK;\n\tcfg |= FIELD_PREP(CFG_BLK_LEN_MASK, blksz);\n\twritel(cfg, host->regs + SD_EMMC_CFG);\n}\n\nstatic void meson_mmc_set_response_bits(struct mmc_command *cmd, u32 *cmd_cfg)\n{\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\t*cmd_cfg |= CMD_CFG_RESP_128;\n\t\t*cmd_cfg |= CMD_CFG_RESP_NUM;\n\n\t\tif (!(cmd->flags & MMC_RSP_CRC))\n\t\t\t*cmd_cfg |= CMD_CFG_RESP_NOCRC;\n\n\t\tif (cmd->flags & MMC_RSP_BUSY)\n\t\t\t*cmd_cfg |= CMD_CFG_R1B;\n\t} else {\n\t\t*cmd_cfg |= CMD_CFG_NO_RESP;\n\t}\n}\n\nstatic void meson_mmc_desc_chain_transfer(struct mmc_host *mmc, u32 cmd_cfg)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tstruct sd_emmc_desc *desc = host->descs;\n\tstruct mmc_data *data = host->cmd->data;\n\tstruct scatterlist *sg;\n\tu32 start;\n\tint i;\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\tcmd_cfg |= CMD_CFG_DATA_WR;\n\n\tif (data->blocks > 1) {\n\t\tcmd_cfg |= CMD_CFG_BLOCK_MODE;\n\t\tmeson_mmc_set_blksz(mmc, data->blksz);\n\t}\n\n\tfor_each_sg(data->sg, sg, data->sg_count, i) {\n\t\tunsigned int len = sg_dma_len(sg);\n\n\t\tif (data->blocks > 1)\n\t\t\tlen /= data->blksz;\n\n\t\tdesc[i].cmd_cfg = cmd_cfg;\n\t\tdesc[i].cmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, len);\n\t\tif (i > 0)\n\t\t\tdesc[i].cmd_cfg |= CMD_CFG_NO_CMD;\n\t\tdesc[i].cmd_arg = host->cmd->arg;\n\t\tdesc[i].cmd_resp = 0;\n\t\tdesc[i].cmd_data = sg_dma_address(sg);\n\t}\n\tdesc[data->sg_count - 1].cmd_cfg |= CMD_CFG_END_OF_CHAIN;\n\n\tdma_wmb();  \n\tstart = host->descs_dma_addr | START_DESC_BUSY;\n\twritel(start, host->regs + SD_EMMC_START);\n}\n\n \nstatic void meson_mmc_copy_buffer(struct meson_host *host, struct mmc_data *data,\n\t\t\t\t  size_t buflen, bool to_buffer)\n{\n\tunsigned int sg_flags = SG_MITER_ATOMIC;\n\tstruct scatterlist *sgl = data->sg;\n\tunsigned int nents = data->sg_len;\n\tstruct sg_mapping_iter miter;\n\tunsigned int offset = 0;\n\n\tif (to_buffer)\n\t\tsg_flags |= SG_MITER_FROM_SG;\n\telse\n\t\tsg_flags |= SG_MITER_TO_SG;\n\n\tsg_miter_start(&miter, sgl, nents, sg_flags);\n\n\twhile ((offset < buflen) && sg_miter_next(&miter)) {\n\t\tunsigned int buf_offset = 0;\n\t\tunsigned int len, left;\n\t\tu32 *buf = miter.addr;\n\n\t\tlen = min(miter.length, buflen - offset);\n\t\tleft = len;\n\n\t\tif (to_buffer) {\n\t\t\tdo {\n\t\t\t\twritel(*buf++, host->bounce_iomem_buf + offset + buf_offset);\n\n\t\t\t\tbuf_offset += 4;\n\t\t\t\tleft -= 4;\n\t\t\t} while (left);\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t*buf++ = readl(host->bounce_iomem_buf + offset + buf_offset);\n\n\t\t\t\tbuf_offset += 4;\n\t\t\t\tleft -= 4;\n\t\t\t} while (left);\n\t\t}\n\n\t\toffset += len;\n\t}\n\n\tsg_miter_stop(&miter);\n}\n\nstatic void meson_mmc_start_cmd(struct mmc_host *mmc, struct mmc_command *cmd)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = cmd->data;\n\tu32 cmd_cfg = 0, cmd_data = 0;\n\tunsigned int xfer_bytes = 0;\n\n\t \n\tdma_rmb();\n\n\thost->cmd = cmd;\n\n\tcmd_cfg |= FIELD_PREP(CMD_CFG_CMD_INDEX_MASK, cmd->opcode);\n\tcmd_cfg |= CMD_CFG_OWNER;   \n\n\tmeson_mmc_set_response_bits(cmd, &cmd_cfg);\n\n\t \n\tif (data) {\n\t\tdata->bytes_xfered = 0;\n\t\tcmd_cfg |= CMD_CFG_DATA_IO;\n\t\tcmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,\n\t\t\t\t      ilog2(meson_mmc_get_timeout_msecs(data)));\n\n\t\tif (meson_mmc_desc_chain_mode(data)) {\n\t\t\tmeson_mmc_desc_chain_transfer(mmc, cmd_cfg);\n\t\t\treturn;\n\t\t}\n\n\t\tif (data->blocks > 1) {\n\t\t\tcmd_cfg |= CMD_CFG_BLOCK_MODE;\n\t\t\tcmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK,\n\t\t\t\t\t      data->blocks);\n\t\t\tmeson_mmc_set_blksz(mmc, data->blksz);\n\t\t} else {\n\t\t\tcmd_cfg |= FIELD_PREP(CMD_CFG_LENGTH_MASK, data->blksz);\n\t\t}\n\n\t\txfer_bytes = data->blksz * data->blocks;\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tcmd_cfg |= CMD_CFG_DATA_WR;\n\t\t\tWARN_ON(xfer_bytes > host->bounce_buf_size);\n\t\t\tif (host->dram_access_quirk)\n\t\t\t\tmeson_mmc_copy_buffer(host, data, xfer_bytes, true);\n\t\t\telse\n\t\t\t\tsg_copy_to_buffer(data->sg, data->sg_len,\n\t\t\t\t\t\t  host->bounce_buf, xfer_bytes);\n\t\t\tdma_wmb();\n\t\t}\n\n\t\tcmd_data = host->bounce_dma_addr & CMD_DATA_MASK;\n\t} else {\n\t\tcmd_cfg |= FIELD_PREP(CMD_CFG_TIMEOUT_MASK,\n\t\t\t\t      ilog2(SD_EMMC_CMD_TIMEOUT));\n\t}\n\n\t \n\tcmd_cfg |= CMD_CFG_END_OF_CHAIN;\n\twritel(cmd_cfg, host->regs + SD_EMMC_CMD_CFG);\n\twritel(cmd_data, host->regs + SD_EMMC_CMD_DAT);\n\twritel(0, host->regs + SD_EMMC_CMD_RSP);\n\twmb();  \n\twritel(cmd->arg, host->regs + SD_EMMC_CMD_ARG);\n}\n\nstatic int meson_mmc_validate_dram_access(struct mmc_host *mmc, struct mmc_data *data)\n{\n\tstruct scatterlist *sg;\n\tint i;\n\n\t \n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (!IS_ALIGNED(sg->offset, sizeof(u32)) ||\n\t\t    !IS_ALIGNED(sg->length, sizeof(u32))) {\n\t\t\tdev_err(mmc_dev(mmc), \"unaligned sg offset %u len %u\\n\",\n\t\t\t\tdata->sg->offset, data->sg->length);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void meson_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\thost->needs_pre_post_req = mrq->data &&\n\t\t\t!(mrq->data->host_cookie & SD_EMMC_PRE_REQ_DONE);\n\n\t \n\tif (host->dram_access_quirk && mrq->data) {\n\t\tmrq->cmd->error = meson_mmc_validate_dram_access(mmc, mrq->data);\n\t\tif (mrq->cmd->error) {\n\t\t\tmmc_request_done(mmc, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (host->needs_pre_post_req) {\n\t\tmeson_mmc_get_transfer_mode(mmc, mrq);\n\t\tif (!meson_mmc_desc_chain_mode(mrq->data))\n\t\t\thost->needs_pre_post_req = false;\n\t}\n\n\tif (host->needs_pre_post_req)\n\t\tmeson_mmc_pre_req(mmc, mrq);\n\n\t \n\twritel(0, host->regs + SD_EMMC_START);\n\n\tmeson_mmc_start_cmd(mmc, mrq->sbc ?: mrq->cmd);\n}\n\nstatic void meson_mmc_read_resp(struct mmc_host *mmc, struct mmc_command *cmd)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tcmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP3);\n\t\tcmd->resp[1] = readl(host->regs + SD_EMMC_CMD_RSP2);\n\t\tcmd->resp[2] = readl(host->regs + SD_EMMC_CMD_RSP1);\n\t\tcmd->resp[3] = readl(host->regs + SD_EMMC_CMD_RSP);\n\t} else if (cmd->flags & MMC_RSP_PRESENT) {\n\t\tcmd->resp[0] = readl(host->regs + SD_EMMC_CMD_RSP);\n\t}\n}\n\nstatic void __meson_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tu32 reg_irqen = IRQ_EN_MASK;\n\n\tif (enable)\n\t\treg_irqen |= IRQ_SDIO;\n\twritel(reg_irqen, host->regs + SD_EMMC_IRQ_EN);\n}\n\nstatic irqreturn_t meson_mmc_irq(int irq, void *dev_id)\n{\n\tstruct meson_host *host = dev_id;\n\tstruct mmc_command *cmd;\n\tu32 status, raw_status, irq_mask = IRQ_EN_MASK;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tif (host->mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\tirq_mask |= IRQ_SDIO;\n\traw_status = readl(host->regs + SD_EMMC_STATUS);\n\tstatus = raw_status & irq_mask;\n\n\tif (!status) {\n\t\tdev_dbg(host->dev,\n\t\t\t\"Unexpected IRQ! irq_en 0x%08x - status 0x%08x\\n\",\n\t\t\t irq_mask, raw_status);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(status, host->regs + SD_EMMC_STATUS);\n\n\tcmd = host->cmd;\n\n\tif (status & IRQ_SDIO) {\n\t\tspin_lock(&host->lock);\n\t\t__meson_mmc_enable_sdio_irq(host->mmc, 0);\n\t\tsdio_signal_irq(host->mmc);\n\t\tspin_unlock(&host->lock);\n\t\tstatus &= ~IRQ_SDIO;\n\t\tif (!status)\n\t\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (WARN_ON(!cmd))\n\t\treturn IRQ_NONE;\n\n\tcmd->error = 0;\n\tif (status & IRQ_CRC_ERR) {\n\t\tdev_dbg(host->dev, \"CRC Error - status 0x%08x\\n\", status);\n\t\tcmd->error = -EILSEQ;\n\t\tret = IRQ_WAKE_THREAD;\n\t\tgoto out;\n\t}\n\n\tif (status & IRQ_TIMEOUTS) {\n\t\tdev_dbg(host->dev, \"Timeout - status 0x%08x\\n\", status);\n\t\tcmd->error = -ETIMEDOUT;\n\t\tret = IRQ_WAKE_THREAD;\n\t\tgoto out;\n\t}\n\n\tmeson_mmc_read_resp(host->mmc, cmd);\n\n\tif (status & (IRQ_END_OF_CHAIN | IRQ_RESP_STATUS)) {\n\t\tstruct mmc_data *data = cmd->data;\n\n\t\tif (data && !cmd->error)\n\t\t\tdata->bytes_xfered = data->blksz * data->blocks;\n\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\nout:\n\tif (cmd->error) {\n\t\t \n\t\tu32 start = readl(host->regs + SD_EMMC_START);\n\n\t\tstart &= ~START_DESC_BUSY;\n\t\twritel(start, host->regs + SD_EMMC_START);\n\t}\n\n\treturn ret;\n}\n\nstatic int meson_mmc_wait_desc_stop(struct meson_host *host)\n{\n\tu32 status;\n\n\t \n\n\treturn readl_poll_timeout(host->regs + SD_EMMC_STATUS, status,\n\t\t\t\t  !(status & (STATUS_BUSY | STATUS_DESC_BUSY)),\n\t\t\t\t  100, 5000);\n}\n\nstatic irqreturn_t meson_mmc_irq_thread(int irq, void *dev_id)\n{\n\tstruct meson_host *host = dev_id;\n\tstruct mmc_command *next_cmd, *cmd = host->cmd;\n\tstruct mmc_data *data;\n\tunsigned int xfer_bytes;\n\n\tif (WARN_ON(!cmd))\n\t\treturn IRQ_NONE;\n\n\tif (cmd->error) {\n\t\tmeson_mmc_wait_desc_stop(host);\n\t\tmeson_mmc_request_done(host->mmc, cmd->mrq);\n\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tdata = cmd->data;\n\tif (meson_mmc_bounce_buf_read(data)) {\n\t\txfer_bytes = data->blksz * data->blocks;\n\t\tWARN_ON(xfer_bytes > host->bounce_buf_size);\n\t\tif (host->dram_access_quirk)\n\t\t\tmeson_mmc_copy_buffer(host, data, xfer_bytes, false);\n\t\telse\n\t\t\tsg_copy_from_buffer(data->sg, data->sg_len,\n\t\t\t\t\t    host->bounce_buf, xfer_bytes);\n\t}\n\n\tnext_cmd = meson_mmc_get_next_command(cmd);\n\tif (next_cmd)\n\t\tmeson_mmc_start_cmd(host->mmc, next_cmd);\n\telse\n\t\tmeson_mmc_request_done(host->mmc, cmd->mrq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void meson_mmc_cfg_init(struct meson_host *host)\n{\n\tu32 cfg = 0;\n\n\tcfg |= FIELD_PREP(CFG_RESP_TIMEOUT_MASK,\n\t\t\t  ilog2(SD_EMMC_CFG_RESP_TIMEOUT));\n\tcfg |= FIELD_PREP(CFG_RC_CC_MASK, ilog2(SD_EMMC_CFG_CMD_GAP));\n\tcfg |= FIELD_PREP(CFG_BLK_LEN_MASK, ilog2(SD_EMMC_CFG_BLK_SIZE));\n\n\t \n\tcfg |= CFG_ERR_ABORT;\n\n\twritel(cfg, host->regs + SD_EMMC_CFG);\n}\n\nstatic int meson_mmc_card_busy(struct mmc_host *mmc)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tu32 regval;\n\n\tregval = readl(host->regs + SD_EMMC_STATUS);\n\n\t \n\treturn !(FIELD_GET(STATUS_DATI, regval) & 0xf);\n}\n\nstatic int meson_mmc_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tint ret;\n\n\t \n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\t \n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\treturn ret < 0 ? ret : 0;\n\t}\n\n\t \n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic void meson_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct meson_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\t__meson_mmc_enable_sdio_irq(mmc, enable);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void meson_mmc_ack_sdio_irq(struct mmc_host *mmc)\n{\n\tmeson_mmc_enable_sdio_irq(mmc, 1);\n}\n\nstatic const struct mmc_host_ops meson_mmc_ops = {\n\t.request\t= meson_mmc_request,\n\t.set_ios\t= meson_mmc_set_ios,\n\t.get_cd         = mmc_gpio_get_cd,\n\t.pre_req\t= meson_mmc_pre_req,\n\t.post_req\t= meson_mmc_post_req,\n\t.execute_tuning = meson_mmc_resampling_tuning,\n\t.card_busy\t= meson_mmc_card_busy,\n\t.start_signal_voltage_switch = meson_mmc_voltage_switch,\n\t.enable_sdio_irq = meson_mmc_enable_sdio_irq,\n\t.ack_sdio_irq\t= meson_mmc_ack_sdio_irq,\n};\n\nstatic int meson_mmc_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct meson_host *host;\n\tstruct mmc_host *mmc;\n\tstruct clk *core_clk;\n\tint cd_irq, ret;\n\n\tmmc = devm_mmc_alloc_host(&pdev->dev, sizeof(struct meson_host));\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->dev = &pdev->dev;\n\tdev_set_drvdata(&pdev->dev, host);\n\n\t \n\thost->dram_access_quirk = device_property_read_bool(&pdev->dev,\n\t\t\t\t\t\"amlogic,dram-access-quirk\");\n\n\t \n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"error parsing DT\\n\");\n\n\tmmc->caps |= MMC_CAP_CMD23;\n\n\tif (mmc->caps & MMC_CAP_SDIO_IRQ)\n\t\tmmc->caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;\n\n\thost->data = of_device_get_match_data(&pdev->dev);\n\tif (!host->data)\n\t\treturn -EINVAL;\n\n\tret = device_reset_optional(&pdev->dev);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"device reset failed\\n\");\n\n\thost->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->regs))\n\t\treturn PTR_ERR(host->regs);\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0)\n\t\treturn host->irq;\n\n\tcd_irq = platform_get_irq_optional(pdev, 1);\n\tmmc_gpio_set_cd_irq(mmc, cd_irq);\n\n\thost->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(host->pinctrl))\n\t\treturn PTR_ERR(host->pinctrl);\n\n\thost->pins_clk_gate = pinctrl_lookup_state(host->pinctrl,\n\t\t\t\t\t\t   \"clk-gate\");\n\tif (IS_ERR(host->pins_clk_gate)) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"can't get clk-gate pinctrl, using clk_stop bit\\n\");\n\t\thost->pins_clk_gate = NULL;\n\t}\n\n\tcore_clk = devm_clk_get_enabled(&pdev->dev, \"core\");\n\tif (IS_ERR(core_clk))\n\t\treturn PTR_ERR(core_clk);\n\n\tret = meson_mmc_clk_init(host);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmeson_mmc_cfg_init(host);\n\n\t \n\twritel(0, host->regs + SD_EMMC_START);\n\n\t \n\twritel(0, host->regs + SD_EMMC_IRQ_EN);\n\twritel(IRQ_EN_MASK, host->regs + SD_EMMC_STATUS);\n\twritel(IRQ_EN_MASK, host->regs + SD_EMMC_IRQ_EN);\n\n\tret = request_threaded_irq(host->irq, meson_mmc_irq,\n\t\t\t\t   meson_mmc_irq_thread, IRQF_ONESHOT,\n\t\t\t\t   dev_name(&pdev->dev), host);\n\tif (ret)\n\t\tgoto err_init_clk;\n\n\tspin_lock_init(&host->lock);\n\n\tif (host->dram_access_quirk) {\n\t\t \n\t\tmmc->max_segs = 1;\n\t\t \n\t\tmmc->max_blk_count = SD_EMMC_SRAM_DATA_BUF_LEN /\n\t\t\t\t     mmc->max_blk_size;\n\t} else {\n\t\tmmc->max_blk_count = CMD_CFG_LENGTH_MASK;\n\t\tmmc->max_segs = SD_EMMC_DESC_BUF_LEN /\n\t\t\t\tsizeof(struct sd_emmc_desc);\n\t}\n\tmmc->max_req_size = mmc->max_blk_count * mmc->max_blk_size;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\t \n\tmmc->caps2 &= ~MMC_CAP2_HS400;\n\n\tif (host->dram_access_quirk) {\n\t\t \n\t\thost->bounce_buf_size = SD_EMMC_SRAM_DATA_BUF_LEN;\n\t\thost->bounce_iomem_buf = host->regs + SD_EMMC_SRAM_DATA_BUF_OFF;\n\t\thost->bounce_dma_addr = res->start + SD_EMMC_SRAM_DATA_BUF_OFF;\n\t} else {\n\t\t \n\t\thost->bounce_buf_size = mmc->max_req_size;\n\t\thost->bounce_buf =\n\t\t\tdmam_alloc_coherent(host->dev, host->bounce_buf_size,\n\t\t\t\t\t    &host->bounce_dma_addr, GFP_KERNEL);\n\t\tif (host->bounce_buf == NULL) {\n\t\t\tdev_err(host->dev, \"Unable to map allocate DMA bounce buffer.\\n\");\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_free_irq;\n\t\t}\n\t}\n\n\thost->descs = dmam_alloc_coherent(host->dev, SD_EMMC_DESC_BUF_LEN,\n\t\t\t\t\t  &host->descs_dma_addr, GFP_KERNEL);\n\tif (!host->descs) {\n\t\tdev_err(host->dev, \"Allocating descriptor DMA buffer failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_free_irq;\n\t}\n\n\tmmc->ops = &meson_mmc_ops;\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto err_free_irq;\n\n\treturn 0;\n\nerr_free_irq:\n\tfree_irq(host->irq, host);\nerr_init_clk:\n\tclk_disable_unprepare(host->mmc_clk);\n\treturn ret;\n}\n\nstatic void meson_mmc_remove(struct platform_device *pdev)\n{\n\tstruct meson_host *host = dev_get_drvdata(&pdev->dev);\n\n\tmmc_remove_host(host->mmc);\n\n\t \n\twritel(0, host->regs + SD_EMMC_IRQ_EN);\n\tfree_irq(host->irq, host);\n\n\tclk_disable_unprepare(host->mmc_clk);\n}\n\nstatic const struct meson_mmc_data meson_gx_data = {\n\t.tx_delay_mask\t= CLK_V2_TX_DELAY_MASK,\n\t.rx_delay_mask\t= CLK_V2_RX_DELAY_MASK,\n\t.always_on\t= CLK_V2_ALWAYS_ON,\n\t.adjust\t\t= SD_EMMC_ADJUST,\n\t.irq_sdio_sleep\t= CLK_V2_IRQ_SDIO_SLEEP,\n};\n\nstatic const struct meson_mmc_data meson_axg_data = {\n\t.tx_delay_mask\t= CLK_V3_TX_DELAY_MASK,\n\t.rx_delay_mask\t= CLK_V3_RX_DELAY_MASK,\n\t.always_on\t= CLK_V3_ALWAYS_ON,\n\t.adjust\t\t= SD_EMMC_V3_ADJUST,\n\t.irq_sdio_sleep\t= CLK_V3_IRQ_SDIO_SLEEP,\n};\n\nstatic const struct of_device_id meson_mmc_of_match[] = {\n\t{ .compatible = \"amlogic,meson-gx-mmc\",\t\t.data = &meson_gx_data },\n\t{ .compatible = \"amlogic,meson-gxbb-mmc\", \t.data = &meson_gx_data },\n\t{ .compatible = \"amlogic,meson-gxl-mmc\",\t.data = &meson_gx_data },\n\t{ .compatible = \"amlogic,meson-gxm-mmc\",\t.data = &meson_gx_data },\n\t{ .compatible = \"amlogic,meson-axg-mmc\",\t.data = &meson_axg_data },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, meson_mmc_of_match);\n\nstatic struct platform_driver meson_mmc_driver = {\n\t.probe\t\t= meson_mmc_probe,\n\t.remove_new\t= meson_mmc_remove,\n\t.driver\t\t= {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = meson_mmc_of_match,\n\t},\n};\n\nmodule_platform_driver(meson_mmc_driver);\n\nMODULE_DESCRIPTION(\"Amlogic S905*/GX*/AXG SD/eMMC driver\");\nMODULE_AUTHOR(\"Kevin Hilman <khilman@baylibre.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}