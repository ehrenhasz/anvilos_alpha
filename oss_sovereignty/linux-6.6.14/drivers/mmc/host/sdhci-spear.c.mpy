{
  "module_name": "sdhci-spear.c",
  "hash_id": "2aa253190275df14eab3d62583a92c1334c6cf68ad0d78c53b713bc6d949c6a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-spear.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/io.h>\n#include \"sdhci.h\"\n\nstruct spear_sdhci {\n\tstruct clk *clk;\n};\n\n \nstatic const struct sdhci_ops sdhci_pltfm_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic int sdhci_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct spear_sdhci *sdhci;\n\tstruct device *dev;\n\tint ret;\n\n\tdev = pdev->dev.parent ? pdev->dev.parent : &pdev->dev;\n\thost = sdhci_alloc_host(dev, sizeof(*sdhci));\n\tif (IS_ERR(host)) {\n\t\tret = PTR_ERR(host);\n\t\tdev_dbg(&pdev->dev, \"cannot allocate memory for sdhci\\n\");\n\t\tgoto err;\n\t}\n\n\thost->ioaddr = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->ioaddr)) {\n\t\tret = PTR_ERR(host->ioaddr);\n\t\tdev_dbg(&pdev->dev, \"unable to map iomem: %d\\n\", ret);\n\t\tgoto err_host;\n\t}\n\n\thost->hw_name = \"sdhci\";\n\thost->ops = &sdhci_pltfm_ops;\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto err_host;\n\t}\n\thost->quirks = SDHCI_QUIRK_BROKEN_ADMA;\n\n\tsdhci = sdhci_priv(host);\n\n\t \n\tsdhci->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sdhci->clk)) {\n\t\tret = PTR_ERR(sdhci->clk);\n\t\tdev_dbg(&pdev->dev, \"Error getting clock\\n\");\n\t\tgoto err_host;\n\t}\n\n\tret = clk_prepare_enable(sdhci->clk);\n\tif (ret) {\n\t\tdev_dbg(&pdev->dev, \"Error enabling clock\\n\");\n\t\tgoto err_host;\n\t}\n\n\tret = clk_set_rate(sdhci->clk, 50000000);\n\tif (ret)\n\t\tdev_dbg(&pdev->dev, \"Error setting desired clk, clk=%lu\\n\",\n\t\t\t\tclk_get_rate(sdhci->clk));\n\n\t \n\tret = mmc_gpiod_request_cd(host->mmc, \"cd\", 0, false, 0);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto disable_clk;\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tplatform_set_drvdata(pdev, host);\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(sdhci->clk);\nerr_host:\n\tsdhci_free_host(host);\nerr:\n\tdev_err(&pdev->dev, \"spear-sdhci probe failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void sdhci_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct spear_sdhci *sdhci = sdhci_priv(host);\n\tint dead = 0;\n\tu32 scratch;\n\n\tscratch = readl(host->ioaddr + SDHCI_INT_STATUS);\n\tif (scratch == (u32)-1)\n\t\tdead = 1;\n\n\tsdhci_remove_host(host, dead);\n\tclk_disable_unprepare(sdhci->clk);\n\tsdhci_free_host(host);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct spear_sdhci *sdhci = sdhci_priv(host);\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = sdhci_suspend_host(host);\n\tif (!ret)\n\t\tclk_disable(sdhci->clk);\n\n\treturn ret;\n}\n\nstatic int sdhci_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct spear_sdhci *sdhci = sdhci_priv(host);\n\tint ret;\n\n\tret = clk_enable(sdhci->clk);\n\tif (ret) {\n\t\tdev_dbg(dev, \"Resume: Error enabling clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn sdhci_resume_host(host);\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(sdhci_pm_ops, sdhci_suspend, sdhci_resume);\n\nstatic const struct of_device_id sdhci_spear_id_table[] = {\n\t{ .compatible = \"st,spear300-sdhci\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sdhci_spear_id_table);\n\nstatic struct platform_driver sdhci_driver = {\n\t.driver = {\n\t\t.name\t= \"sdhci\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &sdhci_pm_ops,\n\t\t.of_match_table = sdhci_spear_id_table,\n\t},\n\t.probe\t\t= sdhci_probe,\n\t.remove_new\t= sdhci_remove,\n};\n\nmodule_platform_driver(sdhci_driver);\n\nMODULE_DESCRIPTION(\"SPEAr Secure Digital Host Controller Interface driver\");\nMODULE_AUTHOR(\"Viresh Kumar <vireshk@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}