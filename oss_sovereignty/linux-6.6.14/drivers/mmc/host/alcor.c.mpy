{
  "module_name": "alcor.c",
  "hash_id": "35ec5285030c67d9a545561599c7ce3a5a90b803a109b9129618b46be3246893",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/alcor.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/delay.h>\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/pm.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n\n#include <linux/alcor_pci.h>\n\nenum alcor_cookie {\n\tCOOKIE_UNMAPPED,\n\tCOOKIE_PRE_MAPPED,\n\tCOOKIE_MAPPED,\n};\n\nstruct alcor_pll_conf {\n\tunsigned int clk_src_freq;\n\tunsigned int clk_src_reg;\n\tunsigned int min_div;\n\tunsigned int max_div;\n};\n\nstruct alcor_sdmmc_host {\n\tstruct  device *dev;\n\tstruct alcor_pci_priv *alcor_pci;\n\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\tunsigned int dma_on:1;\n\n\tstruct mutex cmd_mutex;\n\n\tstruct delayed_work timeout_work;\n\n\tstruct sg_mapping_iter sg_miter;\t \n\tstruct scatterlist *sg;\n\tunsigned int blocks;\t\t \n\tint sg_count;\n\n\tu32\t\t\tirq_status_sd;\n\tunsigned char\t\tcur_power_mode;\n};\n\nstatic const struct alcor_pll_conf alcor_pll_cfg[] = {\n\t \n\t{ 31250000,\tAU6601_CLK_31_25_MHZ,\t1,\t511},\n\t{ 48000000,\tAU6601_CLK_48_MHZ,\t1,\t511},\n\t{125000000,\tAU6601_CLK_125_MHZ,\t1,\t511},\n\t{384000000,\tAU6601_CLK_384_MHZ,\t1,\t511},\n};\n\nstatic inline void alcor_rmw8(struct alcor_sdmmc_host *host, unsigned int addr,\n\t\t\t       u8 clear, u8 set)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu32 var;\n\n\tvar = alcor_read8(priv, addr);\n\tvar &= ~clear;\n\tvar |= set;\n\talcor_write8(priv, var, addr);\n}\n\n \nstatic inline void alcor_mask_sd_irqs(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\talcor_write32(priv, 0, AU6601_REG_INT_ENABLE);\n}\n\nstatic inline void alcor_unmask_sd_irqs(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\talcor_write32(priv, AU6601_INT_CMD_MASK | AU6601_INT_DATA_MASK |\n\t\t  AU6601_INT_CARD_INSERT | AU6601_INT_CARD_REMOVE |\n\t\t  AU6601_INT_OVER_CURRENT_ERR,\n\t\t  AU6601_REG_INT_ENABLE);\n}\n\nstatic void alcor_reset(struct alcor_sdmmc_host *host, u8 val)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tint i;\n\n\talcor_write8(priv, val | AU6601_BUF_CTRL_RESET,\n\t\t      AU6601_REG_SW_RESET);\n\tfor (i = 0; i < 100; i++) {\n\t\tif (!(alcor_read8(priv, AU6601_REG_SW_RESET) & val))\n\t\t\treturn;\n\t\tudelay(50);\n\t}\n\tdev_err(host->dev, \"%s: timeout\\n\", __func__);\n}\n\n \nstatic void alcor_data_set_dma(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu32 addr;\n\n\tif (!host->sg_count)\n\t\treturn;\n\n\tif (!host->sg) {\n\t\tdev_err(host->dev, \"have blocks, but no SG\\n\");\n\t\treturn;\n\t}\n\n\tif (!sg_dma_len(host->sg)) {\n\t\tdev_err(host->dev, \"DMA SG len == 0\\n\");\n\t\treturn;\n\t}\n\n\n\taddr = (u32)sg_dma_address(host->sg);\n\n\talcor_write32(priv, addr, AU6601_REG_SDMA_ADDR);\n\thost->sg = sg_next(host->sg);\n\thost->sg_count--;\n}\n\nstatic void alcor_trigger_data_transfer(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tstruct mmc_data *data = host->data;\n\tu8 ctrl = 0;\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\tctrl |= AU6601_DATA_WRITE;\n\n\tif (data->host_cookie == COOKIE_MAPPED) {\n\t\t \n\t\talcor_data_set_dma(host);\n\t\tctrl |= AU6601_DATA_DMA_MODE;\n\t\thost->dma_on = 1;\n\t\talcor_write32(priv, data->sg_count * 0x1000,\n\t\t\t       AU6601_REG_BLOCK_SIZE);\n\t} else {\n\t\t \n\t\talcor_write32(priv, data->blksz, AU6601_REG_BLOCK_SIZE);\n\t}\n\n\talcor_write8(priv, ctrl | AU6601_DATA_START_XFER,\n\t\t      AU6601_DATA_XFER_CTRL);\n}\n\nstatic void alcor_trf_block_pio(struct alcor_sdmmc_host *host, bool read)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tsize_t blksize, len;\n\tu8 *buf;\n\n\tif (!host->blocks)\n\t\treturn;\n\n\tif (host->dma_on) {\n\t\tdev_err(host->dev, \"configured DMA but got PIO request.\\n\");\n\t\treturn;\n\t}\n\n\tif (!!(host->data->flags & MMC_DATA_READ) != read) {\n\t\tdev_err(host->dev, \"got unexpected direction %i != %i\\n\",\n\t\t\t!!(host->data->flags & MMC_DATA_READ), read);\n\t}\n\n\tif (!sg_miter_next(&host->sg_miter))\n\t\treturn;\n\n\tblksize = host->data->blksz;\n\tlen = min(host->sg_miter.length, blksize);\n\n\tdev_dbg(host->dev, \"PIO, %s block size: 0x%zx\\n\",\n\t\tread ? \"read\" : \"write\", blksize);\n\n\thost->sg_miter.consumed = len;\n\thost->blocks--;\n\n\tbuf = host->sg_miter.addr;\n\n\tif (read)\n\t\tioread32_rep(priv->iobase + AU6601_REG_BUFFER, buf, len >> 2);\n\telse\n\t\tiowrite32_rep(priv->iobase + AU6601_REG_BUFFER, buf, len >> 2);\n\n\tsg_miter_stop(&host->sg_miter);\n}\n\nstatic void alcor_prepare_sg_miter(struct alcor_sdmmc_host *host)\n{\n\tunsigned int flags = SG_MITER_ATOMIC;\n\tstruct mmc_data *data = host->data;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tflags |= SG_MITER_TO_SG;\n\telse\n\t\tflags |= SG_MITER_FROM_SG;\n\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n}\n\nstatic void alcor_prepare_data(struct alcor_sdmmc_host *host,\n\t\t\t       struct mmc_command *cmd)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tstruct mmc_data *data = cmd->data;\n\n\tif (!data)\n\t\treturn;\n\n\n\thost->data = data;\n\thost->data->bytes_xfered = 0;\n\thost->blocks = data->blocks;\n\thost->sg = data->sg;\n\thost->sg_count = data->sg_count;\n\tdev_dbg(host->dev, \"prepare DATA: sg %i, blocks: %i\\n\",\n\t\t\thost->sg_count, host->blocks);\n\n\tif (data->host_cookie != COOKIE_MAPPED)\n\t\talcor_prepare_sg_miter(host);\n\n\talcor_write8(priv, 0, AU6601_DATA_XFER_CTRL);\n}\n\nstatic void alcor_send_cmd(struct alcor_sdmmc_host *host,\n\t\t\t   struct mmc_command *cmd, bool set_timeout)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tunsigned long timeout = 0;\n\tu8 ctrl = 0;\n\n\thost->cmd = cmd;\n\talcor_prepare_data(host, cmd);\n\n\tdev_dbg(host->dev, \"send CMD. opcode: 0x%02x, arg; 0x%08x\\n\",\n\t\tcmd->opcode, cmd->arg);\n\talcor_write8(priv, cmd->opcode | 0x40, AU6601_REG_CMD_OPCODE);\n\talcor_write32be(priv, cmd->arg, AU6601_REG_CMD_ARG);\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tctrl = AU6601_CMD_NO_RESP;\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\t\tctrl = AU6601_CMD_6_BYTE_CRC;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tctrl = AU6601_CMD_6_BYTE_CRC | AU6601_CMD_STOP_WAIT_RDY;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tctrl = AU6601_CMD_17_BYTE_CRC;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tctrl = AU6601_CMD_6_BYTE_WO_CRC;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(host->dev, \"%s: cmd->flag (0x%02x) is not valid\\n\",\n\t\t\tmmc_hostname(mmc_from_priv(host)), mmc_resp_type(cmd));\n\t\tbreak;\n\t}\n\n\tif (set_timeout) {\n\t\tif (!cmd->data && cmd->busy_timeout)\n\t\t\ttimeout = cmd->busy_timeout;\n\t\telse\n\t\t\ttimeout = 10000;\n\n\t\tschedule_delayed_work(&host->timeout_work,\n\t\t\t\t      msecs_to_jiffies(timeout));\n\t}\n\n\tdev_dbg(host->dev, \"xfer ctrl: 0x%02x; timeout: %lu\\n\", ctrl, timeout);\n\talcor_write8(priv, ctrl | AU6601_CMD_START_XFER,\n\t\t\t\t AU6601_CMD_XFER_CTRL);\n}\n\nstatic void alcor_request_complete(struct alcor_sdmmc_host *host,\n\t\t\t\t   bool cancel_timeout)\n{\n\tstruct mmc_request *mrq;\n\n\t \n\tif (!host->mrq)\n\t\treturn;\n\n\tif (cancel_timeout)\n\t\tcancel_delayed_work(&host->timeout_work);\n\n\tmrq = host->mrq;\n\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\thost->dma_on = 0;\n\n\tmmc_request_done(mmc_from_priv(host), mrq);\n}\n\nstatic void alcor_finish_data(struct alcor_sdmmc_host *host)\n{\n\tstruct mmc_data *data;\n\n\tdata = host->data;\n\thost->data = NULL;\n\thost->dma_on = 0;\n\n\t \n\tif (data->error)\n\t\tdata->bytes_xfered = 0;\n\telse\n\t\tdata->bytes_xfered = data->blksz * data->blocks;\n\n\t \n\tif (data->stop &&\n\t    (data->error ||\n\t     !host->mrq->sbc)) {\n\n\t\t \n\t\tif (data->error)\n\t\t\talcor_reset(host, AU6601_RESET_CMD | AU6601_RESET_DATA);\n\n\t\talcor_unmask_sd_irqs(host);\n\t\talcor_send_cmd(host, data->stop, false);\n\t\treturn;\n\t}\n\n\talcor_request_complete(host, 1);\n}\n\nstatic void alcor_err_irq(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tdev_dbg(host->dev, \"ERR IRQ %x\\n\", intmask);\n\n\tif (host->cmd) {\n\t\tif (intmask & AU6601_INT_CMD_TIMEOUT_ERR)\n\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\telse\n\t\t\thost->cmd->error = -EILSEQ;\n\t}\n\n\tif (host->data) {\n\t\tif (intmask & AU6601_INT_DATA_TIMEOUT_ERR)\n\t\t\thost->data->error = -ETIMEDOUT;\n\t\telse\n\t\t\thost->data->error = -EILSEQ;\n\n\t\thost->data->bytes_xfered = 0;\n\t}\n\n\talcor_reset(host, AU6601_RESET_CMD | AU6601_RESET_DATA);\n\talcor_request_complete(host, 1);\n}\n\nstatic int alcor_cmd_irq_done(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\tintmask &= AU6601_INT_CMD_END;\n\n\tif (!intmask)\n\t\treturn true;\n\n\t \n\tif (!host->cmd)\n\t\treturn false;\n\n\tif (host->cmd->flags & MMC_RSP_PRESENT) {\n\t\tstruct mmc_command *cmd = host->cmd;\n\n\t\tcmd->resp[0] = alcor_read32be(priv, AU6601_REG_CMD_RSP0);\n\t\tdev_dbg(host->dev, \"RSP0: 0x%04x\\n\", cmd->resp[0]);\n\t\tif (host->cmd->flags & MMC_RSP_136) {\n\t\t\tcmd->resp[1] =\n\t\t\t\talcor_read32be(priv, AU6601_REG_CMD_RSP1);\n\t\t\tcmd->resp[2] =\n\t\t\t\talcor_read32be(priv, AU6601_REG_CMD_RSP2);\n\t\t\tcmd->resp[3] =\n\t\t\t\talcor_read32be(priv, AU6601_REG_CMD_RSP3);\n\t\t\tdev_dbg(host->dev, \"RSP1,2,3: 0x%04x 0x%04x 0x%04x\\n\",\n\t\t\t\tcmd->resp[1], cmd->resp[2], cmd->resp[3]);\n\t\t}\n\n\t}\n\n\thost->cmd->error = 0;\n\n\t \n\tif (!host->data)\n\t\treturn false;\n\n\talcor_trigger_data_transfer(host);\n\thost->cmd = NULL;\n\treturn true;\n}\n\nstatic void alcor_cmd_irq_thread(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tintmask &= AU6601_INT_CMD_END;\n\n\tif (!intmask)\n\t\treturn;\n\n\tif (!host->cmd && intmask & AU6601_INT_CMD_END) {\n\t\tdev_dbg(host->dev, \"Got command interrupt 0x%08x even though no command operation was in progress.\\n\",\n\t\t\tintmask);\n\t}\n\n\t \n\tif (!host->data)\n\t\talcor_request_complete(host, 1);\n\telse\n\t\talcor_trigger_data_transfer(host);\n\thost->cmd = NULL;\n}\n\nstatic int alcor_data_irq_done(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tu32 tmp;\n\n\tintmask &= AU6601_INT_DATA_MASK;\n\n\t \n\tif (!intmask)\n\t\treturn 1;\n\n\t \n\tif (!host->data && intmask == AU6601_INT_DATA_END)\n\t\treturn 1;\n\n\t \n\tif (!host->data)\n\t\treturn 0;\n\n\ttmp = intmask & (AU6601_INT_READ_BUF_RDY | AU6601_INT_WRITE_BUF_RDY\n\t\t\t | AU6601_INT_DMA_END);\n\tswitch (tmp) {\n\tcase 0:\n\t\tbreak;\n\tcase AU6601_INT_READ_BUF_RDY:\n\t\talcor_trf_block_pio(host, true);\n\t\treturn 1;\n\tcase AU6601_INT_WRITE_BUF_RDY:\n\t\talcor_trf_block_pio(host, false);\n\t\treturn 1;\n\tcase AU6601_INT_DMA_END:\n\t\tif (!host->sg_count)\n\t\t\tbreak;\n\n\t\talcor_data_set_dma(host);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(host->dev, \"Got READ_BUF_RDY and WRITE_BUF_RDY at same time\\n\");\n\t\tbreak;\n\t}\n\n\tif (intmask & AU6601_INT_DATA_END) {\n\t\tif (!host->dma_on && host->blocks) {\n\t\t\talcor_trigger_data_transfer(host);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic void alcor_data_irq_thread(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tintmask &= AU6601_INT_DATA_MASK;\n\n\tif (!intmask)\n\t\treturn;\n\n\tif (!host->data) {\n\t\tdev_dbg(host->dev, \"Got data interrupt 0x%08x even though no data operation was in progress.\\n\",\n\t\t\tintmask);\n\t\talcor_reset(host, AU6601_RESET_DATA);\n\t\treturn;\n\t}\n\n\tif (alcor_data_irq_done(host, intmask))\n\t\treturn;\n\n\tif ((intmask & AU6601_INT_DATA_END) || !host->blocks ||\n\t    (host->dma_on && !host->sg_count))\n\t\talcor_finish_data(host);\n}\n\nstatic void alcor_cd_irq(struct alcor_sdmmc_host *host, u32 intmask)\n{\n\tdev_dbg(host->dev, \"card %s\\n\",\n\t\tintmask & AU6601_INT_CARD_REMOVE ? \"removed\" : \"inserted\");\n\n\tif (host->mrq) {\n\t\tdev_dbg(host->dev, \"cancel all pending tasks.\\n\");\n\n\t\tif (host->data)\n\t\t\thost->data->error = -ENOMEDIUM;\n\n\t\tif (host->cmd)\n\t\t\thost->cmd->error = -ENOMEDIUM;\n\t\telse\n\t\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\n\t\talcor_request_complete(host, 1);\n\t}\n\n\tmmc_detect_change(mmc_from_priv(host), msecs_to_jiffies(1));\n}\n\nstatic irqreturn_t alcor_irq_thread(int irq, void *d)\n{\n\tstruct alcor_sdmmc_host *host = d;\n\tirqreturn_t ret = IRQ_HANDLED;\n\tu32 intmask, tmp;\n\n\tmutex_lock(&host->cmd_mutex);\n\n\tintmask = host->irq_status_sd;\n\n\t \n\tif (unlikely(!intmask || AU6601_INT_ALL_MASK == intmask)) {\n\t\tdev_dbg(host->dev, \"unexpected IRQ: 0x%04x\\n\", intmask);\n\t\tret = IRQ_NONE;\n\t\tgoto exit;\n\t}\n\n\ttmp = intmask & (AU6601_INT_CMD_MASK | AU6601_INT_DATA_MASK);\n\tif (tmp) {\n\t\tif (tmp & AU6601_INT_ERROR_MASK)\n\t\t\talcor_err_irq(host, tmp);\n\t\telse {\n\t\t\talcor_cmd_irq_thread(host, tmp);\n\t\t\talcor_data_irq_thread(host, tmp);\n\t\t}\n\t\tintmask &= ~(AU6601_INT_CMD_MASK | AU6601_INT_DATA_MASK);\n\t}\n\n\tif (intmask & (AU6601_INT_CARD_INSERT | AU6601_INT_CARD_REMOVE)) {\n\t\talcor_cd_irq(host, intmask);\n\t\tintmask &= ~(AU6601_INT_CARD_INSERT | AU6601_INT_CARD_REMOVE);\n\t}\n\n\tif (intmask & AU6601_INT_OVER_CURRENT_ERR) {\n\t\tdev_warn(host->dev,\n\t\t\t \"warning: over current detected!\\n\");\n\t\tintmask &= ~AU6601_INT_OVER_CURRENT_ERR;\n\t}\n\n\tif (intmask)\n\t\tdev_dbg(host->dev, \"got not handled IRQ: 0x%04x\\n\", intmask);\n\nexit:\n\tmutex_unlock(&host->cmd_mutex);\n\talcor_unmask_sd_irqs(host);\n\treturn ret;\n}\n\n\nstatic irqreturn_t alcor_irq(int irq, void *d)\n{\n\tstruct alcor_sdmmc_host *host = d;\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu32 status, tmp;\n\tirqreturn_t ret;\n\tint cmd_done, data_done;\n\n\tstatus = alcor_read32(priv, AU6601_REG_INT_STATUS);\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\talcor_write32(priv, status, AU6601_REG_INT_STATUS);\n\n\ttmp = status & (AU6601_INT_READ_BUF_RDY | AU6601_INT_WRITE_BUF_RDY\n\t\t\t| AU6601_INT_DATA_END | AU6601_INT_DMA_END\n\t\t\t| AU6601_INT_CMD_END);\n\tif (tmp == status) {\n\t\tcmd_done = alcor_cmd_irq_done(host, tmp);\n\t\tdata_done = alcor_data_irq_done(host, tmp);\n\t\t \n\t\tif (cmd_done && data_done) {\n\t\t\tret = IRQ_HANDLED;\n\t\t\tgoto alcor_irq_done;\n\t\t}\n\t}\n\n\thost->irq_status_sd = status;\n\tret = IRQ_WAKE_THREAD;\n\talcor_mask_sd_irqs(host);\nalcor_irq_done:\n\treturn ret;\n}\n\nstatic void alcor_set_clock(struct alcor_sdmmc_host *host, unsigned int clock)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tint i, diff = 0x7fffffff, tmp_clock = 0;\n\tu16 clk_src = 0;\n\tu8 clk_div = 0;\n\n\tif (clock == 0) {\n\t\talcor_write16(priv, 0, AU6601_CLK_SELECT);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(alcor_pll_cfg); i++) {\n\t\tunsigned int tmp_div, tmp_diff;\n\t\tconst struct alcor_pll_conf *cfg = &alcor_pll_cfg[i];\n\n\t\ttmp_div = DIV_ROUND_UP(cfg->clk_src_freq, clock);\n\t\tif (cfg->min_div > tmp_div || tmp_div > cfg->max_div)\n\t\t\tcontinue;\n\n\t\ttmp_clock = DIV_ROUND_UP(cfg->clk_src_freq, tmp_div);\n\t\ttmp_diff = abs(clock - tmp_clock);\n\n\t\tif (tmp_diff < diff) {\n\t\t\tdiff = tmp_diff;\n\t\t\tclk_src = cfg->clk_src_reg;\n\t\t\tclk_div = tmp_div;\n\t\t}\n\t}\n\n\tclk_src |= ((clk_div - 1) << 8);\n\tclk_src |= AU6601_CLK_ENABLE;\n\n\tdev_dbg(host->dev, \"set freq %d cal freq %d, use div %d, mod %x\\n\",\n\t\t\tclock, tmp_clock, clk_div, clk_src);\n\n\talcor_write16(priv, clk_src, AU6601_CLK_SELECT);\n\n}\n\nstatic void alcor_set_timing(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\n\tif (ios->timing == MMC_TIMING_LEGACY) {\n\t\talcor_rmw8(host, AU6601_CLK_DELAY,\n\t\t\t    AU6601_CLK_POSITIVE_EDGE_ALL, 0);\n\t} else {\n\t\talcor_rmw8(host, AU6601_CLK_DELAY,\n\t\t\t    0, AU6601_CLK_POSITIVE_EDGE_ALL);\n\t}\n}\n\nstatic void alcor_set_bus_width(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_1) {\n\t\talcor_write8(priv, 0, AU6601_REG_BUS_CTRL);\n\t} else if (ios->bus_width == MMC_BUS_WIDTH_4) {\n\t\talcor_write8(priv, AU6601_BUS_WIDTH_4BIT,\n\t\t\t      AU6601_REG_BUS_CTRL);\n\t} else\n\t\tdev_err(host->dev, \"Unknown BUS mode\\n\");\n\n}\n\nstatic int alcor_card_busy(struct mmc_host *mmc)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu8 status;\n\n\t \n\tstatus = alcor_read8(priv, AU6601_DATA_PIN_STATE);\n\n\treturn !(status & AU6601_BUS_STAT_DAT_MASK);\n}\n\nstatic int alcor_get_cd(struct mmc_host *mmc)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu8 detect;\n\n\tdetect = alcor_read8(priv, AU6601_DETECT_STATUS)\n\t\t& AU6601_DETECT_STATUS_M;\n\t \n\treturn (detect == AU6601_SD_DETECTED);\n}\n\nstatic int alcor_get_ro(struct mmc_host *mmc)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tu8 status;\n\n\t \n\tstatus = alcor_read8(priv, AU6601_INTERFACE_MODE_CTRL);\n\n\treturn !!(status & AU6601_SD_CARD_WP);\n}\n\nstatic void alcor_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->cmd_mutex);\n\n\thost->mrq = mrq;\n\n\t \n\tif (alcor_get_cd(mmc))\n\t\talcor_send_cmd(host, mrq->cmd, true);\n\telse {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\talcor_request_complete(host, 1);\n\t}\n\n\tmutex_unlock(&host->cmd_mutex);\n}\n\nstatic void alcor_pre_req(struct mmc_host *mmc,\n\t\t\t   struct mmc_request *mrq)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct scatterlist *sg;\n\tunsigned int i, sg_len;\n\n\tif (!data || !cmd)\n\t\treturn;\n\n\tdata->host_cookie = COOKIE_UNMAPPED;\n\n\t \n\tif (cmd->opcode != MMC_READ_MULTIPLE_BLOCK\n\t\t\t&& cmd->opcode != MMC_WRITE_MULTIPLE_BLOCK)\n\t\treturn;\n\t \n\tif (data->blocks * data->blksz < AU6601_MAX_DMA_BLOCK_SIZE)\n\t\treturn;\n\n\tif (data->blksz & 3)\n\t\treturn;\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (sg->length != AU6601_MAX_DMA_BLOCK_SIZE)\n\t\t\treturn;\n\t\tif (sg->offset != 0)\n\t\t\treturn;\n\t}\n\n\t \n\n\tsg_len = dma_map_sg(host->dev, data->sg, data->sg_len,\n\t\t\t    mmc_get_dma_dir(data));\n\tif (sg_len)\n\t\tdata->host_cookie = COOKIE_MAPPED;\n\n\tdata->sg_count = sg_len;\n}\n\nstatic void alcor_post_req(struct mmc_host *mmc,\n\t\t\t    struct mmc_request *mrq,\n\t\t\t    int err)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn;\n\n\tif (data->host_cookie == COOKIE_MAPPED) {\n\t\tdma_unmap_sg(host->dev,\n\t\t\t     data->sg,\n\t\t\t     data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t}\n\n\tdata->host_cookie = COOKIE_UNMAPPED;\n}\n\nstatic void alcor_set_power_mode(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\talcor_set_clock(host, ios->clock);\n\t\t \n\t\talcor_write8(priv, 0, AU6601_OUTPUT_ENABLE);\n\t\t \n\t\talcor_write8(priv, 0, AU6601_POWER_CONTROL);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\t \n\n\t\t \n\t\talcor_write8(priv, AU6601_SD_CARD,\n\t\t\t      AU6601_ACTIVE_CTRL);\n\t\t \n\t\talcor_write8(priv, 0, AU6601_OPT);\n\t\t \n\t\talcor_write8(priv, 0x20, AU6601_CLK_DELAY);\n\t\t \n\t\talcor_write8(priv, 0, AU6601_REG_BUS_CTRL);\n\t\t \n\t\talcor_set_clock(host, ios->clock);\n\t\t \n\t\talcor_write8(priv, AU6601_SD_CARD,\n\t\t\t      AU6601_POWER_CONTROL);\n\t\t \n\t\tmdelay(20);\n\t\t \n\t\talcor_set_clock(host, ios->clock);\n\n\t\t \n\t\talcor_write8(priv, AU6601_SD_CARD,\n\t\t\t      AU6601_OUTPUT_ENABLE);\n\t\t \n\t\talcor_write8(priv, AU6601_DATA_WRITE,\n\t\t\t      AU6601_DATA_XFER_CTRL);\n\t\t \n\t\talcor_write8(priv, 0x7d, AU6601_TIME_OUT_CTRL);\n\t\tmdelay(100);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(host->dev, \"Unknown power parameter\\n\");\n\t}\n}\n\nstatic void alcor_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->cmd_mutex);\n\n\tdev_dbg(host->dev, \"set ios. bus width: %x, power mode: %x\\n\",\n\t\tios->bus_width, ios->power_mode);\n\n\tif (ios->power_mode != host->cur_power_mode) {\n\t\talcor_set_power_mode(mmc, ios);\n\t\thost->cur_power_mode = ios->power_mode;\n\t} else {\n\t\talcor_set_timing(mmc, ios);\n\t\talcor_set_bus_width(mmc, ios);\n\t\talcor_set_clock(host, ios->clock);\n\t}\n\n\tmutex_unlock(&host->cmd_mutex);\n}\n\nstatic int alcor_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tstruct alcor_sdmmc_host *host = mmc_priv(mmc);\n\n\tmutex_lock(&host->cmd_mutex);\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\talcor_rmw8(host, AU6601_OPT, AU6601_OPT_SD_18V, 0);\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\talcor_rmw8(host, AU6601_OPT, 0, AU6601_OPT_SD_18V);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n\n\tmutex_unlock(&host->cmd_mutex);\n\treturn 0;\n}\n\nstatic const struct mmc_host_ops alcor_sdc_ops = {\n\t.card_busy\t= alcor_card_busy,\n\t.get_cd\t\t= alcor_get_cd,\n\t.get_ro\t\t= alcor_get_ro,\n\t.post_req\t= alcor_post_req,\n\t.pre_req\t= alcor_pre_req,\n\t.request\t= alcor_request,\n\t.set_ios\t= alcor_set_ios,\n\t.start_signal_voltage_switch = alcor_signal_voltage_switch,\n};\n\nstatic void alcor_timeout_timer(struct work_struct *work)\n{\n\tstruct delayed_work *d = to_delayed_work(work);\n\tstruct alcor_sdmmc_host *host = container_of(d, struct alcor_sdmmc_host,\n\t\t\t\t\t\ttimeout_work);\n\tmutex_lock(&host->cmd_mutex);\n\n\tdev_dbg(host->dev, \"triggered timeout\\n\");\n\tif (host->mrq) {\n\t\tdev_err(host->dev, \"Timeout waiting for hardware interrupt.\\n\");\n\n\t\tif (host->data) {\n\t\t\thost->data->error = -ETIMEDOUT;\n\t\t} else {\n\t\t\tif (host->cmd)\n\t\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\t\telse\n\t\t\t\thost->mrq->cmd->error = -ETIMEDOUT;\n\t\t}\n\n\t\talcor_reset(host, AU6601_RESET_CMD | AU6601_RESET_DATA);\n\t\talcor_request_complete(host, 0);\n\t}\n\n\tmutex_unlock(&host->cmd_mutex);\n}\n\nstatic void alcor_hw_init(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\tstruct alcor_dev_cfg *cfg = priv->cfg;\n\n\t \n\n\t \n\talcor_reset(host, AU6601_RESET_CMD);\n\n\talcor_write8(priv, 0, AU6601_DMA_BOUNDARY);\n\t \n\talcor_write8(priv, AU6601_SD_CARD, AU6601_ACTIVE_CTRL);\n\n\t \n\talcor_write8(priv, 0, AU6601_REG_BUS_CTRL);\n\n\t \n\talcor_reset(host, AU6601_RESET_DATA);\n\t \n\talcor_write8(priv, 0, AU6601_DMA_BOUNDARY);\n\n\talcor_write8(priv, 0, AU6601_INTERFACE_MODE_CTRL);\n\t \n\talcor_write8(priv, 0x44, AU6601_PAD_DRIVE0);\n\talcor_write8(priv, 0x44, AU6601_PAD_DRIVE1);\n\talcor_write8(priv, 0x00, AU6601_PAD_DRIVE2);\n\n\t \n\talcor_write8(priv, cfg->dma, AU6601_DMA_BOUNDARY);\n\n\t \n\talcor_write8(priv, 0, AU6601_OUTPUT_ENABLE);\n\talcor_write8(priv, 0, AU6601_POWER_CONTROL);\n\n\talcor_write8(priv, AU6601_DETECT_EN, AU6601_DETECT_STATUS);\n\t \n\talcor_unmask_sd_irqs(host);\n}\n\nstatic void alcor_hw_uninit(struct alcor_sdmmc_host *host)\n{\n\tstruct alcor_pci_priv *priv = host->alcor_pci;\n\n\talcor_mask_sd_irqs(host);\n\talcor_reset(host, AU6601_RESET_CMD | AU6601_RESET_DATA);\n\n\talcor_write8(priv, 0, AU6601_DETECT_STATUS);\n\n\talcor_write8(priv, 0, AU6601_OUTPUT_ENABLE);\n\talcor_write8(priv, 0, AU6601_POWER_CONTROL);\n\n\talcor_write8(priv, 0, AU6601_OPT);\n}\n\nstatic void alcor_init_mmc(struct alcor_sdmmc_host *host)\n{\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\n\tmmc->f_min = AU6601_MIN_CLOCK;\n\tmmc->f_max = AU6601_MAX_CLOCK;\n\tmmc->ocr_avail = MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED\n\t\t| MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50\n\t\t| MMC_CAP_UHS_SDR104 | MMC_CAP_UHS_DDR50;\n\tmmc->caps2 = MMC_CAP2_NO_SDIO;\n\tmmc->ops = &alcor_sdc_ops;\n\n\t \n\tmmc->max_segs = AU6601_MAX_DMA_SEGMENTS;\n\tmmc->max_seg_size = AU6601_MAX_DMA_BLOCK_SIZE;\n\tmmc->max_blk_count = 240;\n\tmmc->max_req_size = mmc->max_blk_count * mmc->max_blk_size;\n\tdma_set_max_seg_size(host->dev, mmc->max_seg_size);\n}\n\nstatic int alcor_pci_sdmmc_drv_probe(struct platform_device *pdev)\n{\n\tstruct alcor_pci_priv *priv = pdev->dev.platform_data;\n\tstruct mmc_host *mmc;\n\tstruct alcor_sdmmc_host *host;\n\tint ret;\n\n\tmmc = mmc_alloc_host(sizeof(*host), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"Can't allocate MMC\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->dev = &pdev->dev;\n\thost->cur_power_mode = MMC_POWER_UNDEFINED;\n\thost->alcor_pci = priv;\n\n\t \n\talcor_write32(priv, 0, AU6601_REG_INT_ENABLE);\n\talcor_write32(priv, 0, AU6601_MS_INT_ENABLE);\n\n\tret = devm_request_threaded_irq(&pdev->dev, priv->irq,\n\t\t\talcor_irq, alcor_irq_thread, IRQF_SHARED,\n\t\t\tDRV_NAME_ALCOR_PCI_SDMMC, host);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to get irq for data line\\n\");\n\t\tgoto free_host;\n\t}\n\n\tmutex_init(&host->cmd_mutex);\n\tINIT_DELAYED_WORK(&host->timeout_work, alcor_timeout_timer);\n\n\talcor_init_mmc(host);\n\talcor_hw_init(host);\n\n\tdev_set_drvdata(&pdev->dev, host);\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto free_host;\n\n\treturn 0;\n\nfree_host:\n\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void alcor_pci_sdmmc_drv_remove(struct platform_device *pdev)\n{\n\tstruct alcor_sdmmc_host *host = dev_get_drvdata(&pdev->dev);\n\tstruct mmc_host *mmc = mmc_from_priv(host);\n\n\tif (cancel_delayed_work_sync(&host->timeout_work))\n\t\talcor_request_complete(host, 0);\n\n\talcor_hw_uninit(host);\n\tmmc_remove_host(mmc);\n\tmmc_free_host(mmc);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int alcor_pci_sdmmc_suspend(struct device *dev)\n{\n\tstruct alcor_sdmmc_host *host = dev_get_drvdata(dev);\n\n\tif (cancel_delayed_work_sync(&host->timeout_work))\n\t\talcor_request_complete(host, 0);\n\n\talcor_hw_uninit(host);\n\n\treturn 0;\n}\n\nstatic int alcor_pci_sdmmc_resume(struct device *dev)\n{\n\tstruct alcor_sdmmc_host *host = dev_get_drvdata(dev);\n\n\talcor_hw_init(host);\n\n\treturn 0;\n}\n#endif  \n\nstatic SIMPLE_DEV_PM_OPS(alcor_mmc_pm_ops, alcor_pci_sdmmc_suspend,\n\t\t\t alcor_pci_sdmmc_resume);\n\nstatic const struct platform_device_id alcor_pci_sdmmc_ids[] = {\n\t{\n\t\t.name = DRV_NAME_ALCOR_PCI_SDMMC,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(platform, alcor_pci_sdmmc_ids);\n\nstatic struct platform_driver alcor_pci_sdmmc_driver = {\n\t.probe\t\t= alcor_pci_sdmmc_drv_probe,\n\t.remove_new\t= alcor_pci_sdmmc_drv_remove,\n\t.id_table\t= alcor_pci_sdmmc_ids,\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME_ALCOR_PCI_SDMMC,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &alcor_mmc_pm_ops\n\t},\n};\nmodule_platform_driver(alcor_pci_sdmmc_driver);\n\nMODULE_AUTHOR(\"Oleksij Rempel <linux@rempel-privat.de>\");\nMODULE_DESCRIPTION(\"PCI driver for Alcor Micro AU6601 Secure Digital Host Controller Interface\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}