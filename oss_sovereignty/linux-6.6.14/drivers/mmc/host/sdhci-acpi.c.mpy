{
  "module_name": "sdhci-acpi.c",
  "hash_id": "5548fdea122536e02e071a80ae484e9c511b509ce097103961357721c9744e5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-acpi.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/compiler.h>\n#include <linux/stddef.h>\n#include <linux/bitops.h>\n#include <linux/types.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/acpi.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/delay.h>\n#include <linux/dmi.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/pm.h>\n#include <linux/mmc/slot-gpio.h>\n\n#ifdef CONFIG_X86\n#include <linux/platform_data/x86/soc.h>\n#include <asm/iosf_mbi.h>\n#endif\n\n#include \"sdhci.h\"\n\nenum {\n\tSDHCI_ACPI_SD_CD\t\t= BIT(0),\n\tSDHCI_ACPI_RUNTIME_PM\t\t= BIT(1),\n\tSDHCI_ACPI_SD_CD_OVERRIDE_LEVEL\t= BIT(2),\n};\n\nstruct sdhci_acpi_chip {\n\tconst struct\tsdhci_ops *ops;\n\tunsigned int\tquirks;\n\tunsigned int\tquirks2;\n\tunsigned long\tcaps;\n\tunsigned int\tcaps2;\n\tmmc_pm_flag_t\tpm_caps;\n};\n\nstruct sdhci_acpi_slot {\n\tconst struct\tsdhci_acpi_chip *chip;\n\tunsigned int\tquirks;\n\tunsigned int\tquirks2;\n\tunsigned long\tcaps;\n\tunsigned int\tcaps2;\n\tmmc_pm_flag_t\tpm_caps;\n\tunsigned int\tflags;\n\tsize_t\t\tpriv_size;\n\tint (*probe_slot)(struct platform_device *, struct acpi_device *);\n\tint (*remove_slot)(struct platform_device *);\n\tint (*free_slot)(struct platform_device *pdev);\n\tint (*setup_host)(struct platform_device *pdev);\n};\n\nstruct sdhci_acpi_host {\n\tstruct sdhci_host\t\t*host;\n\tconst struct sdhci_acpi_slot\t*slot;\n\tstruct platform_device\t\t*pdev;\n\tbool\t\t\t\tuse_runtime_pm;\n\tbool\t\t\t\tis_intel;\n\tbool\t\t\t\treset_signal_volt_on_suspend;\n\tunsigned long\t\t\tprivate[] ____cacheline_aligned;\n};\n\nenum {\n\tDMI_QUIRK_RESET_SD_SIGNAL_VOLT_ON_SUSP\t\t\t= BIT(0),\n\tDMI_QUIRK_SD_NO_WRITE_PROTECT\t\t\t\t= BIT(1),\n};\n\nstatic inline void *sdhci_acpi_priv(struct sdhci_acpi_host *c)\n{\n\treturn (void *)c->private;\n}\n\nstatic inline bool sdhci_acpi_flag(struct sdhci_acpi_host *c, unsigned int flag)\n{\n\treturn c->slot && (c->slot->flags & flag);\n}\n\n#define INTEL_DSM_HS_CAPS_SDR25\t\tBIT(0)\n#define INTEL_DSM_HS_CAPS_DDR50\t\tBIT(1)\n#define INTEL_DSM_HS_CAPS_SDR50\t\tBIT(2)\n#define INTEL_DSM_HS_CAPS_SDR104\tBIT(3)\n\nenum {\n\tINTEL_DSM_FNS\t\t=  0,\n\tINTEL_DSM_V18_SWITCH\t=  3,\n\tINTEL_DSM_V33_SWITCH\t=  4,\n\tINTEL_DSM_HS_CAPS\t=  8,\n};\n\nstruct intel_host {\n\tu32\tdsm_fns;\n\tu32\ths_caps;\n};\n\nstatic const guid_t intel_dsm_guid =\n\tGUID_INIT(0xF6C13EA5, 0x65CD, 0x461F,\n\t\t  0xAB, 0x7A, 0x29, 0xF7, 0xE8, 0xD5, 0xBD, 0x61);\n\nstatic int __intel_dsm(struct intel_host *intel_host, struct device *dev,\n\t\t       unsigned int fn, u32 *result)\n{\n\tunion acpi_object *obj;\n\tint err = 0;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dev), &intel_dsm_guid, 0, fn, NULL);\n\tif (!obj)\n\t\treturn -EOPNOTSUPP;\n\n\tif (obj->type == ACPI_TYPE_INTEGER) {\n\t\t*result = obj->integer.value;\n\t} else if (obj->type == ACPI_TYPE_BUFFER && obj->buffer.length > 0) {\n\t\tsize_t len = min_t(size_t, obj->buffer.length, 4);\n\n\t\t*result = 0;\n\t\tmemcpy(result, obj->buffer.pointer, len);\n\t} else {\n\t\tdev_err(dev, \"%s DSM fn %u obj->type %d obj->buffer.length %d\\n\",\n\t\t\t__func__, fn, obj->type, obj->buffer.length);\n\t\terr = -EINVAL;\n\t}\n\n\tACPI_FREE(obj);\n\n\treturn err;\n}\n\nstatic int intel_dsm(struct intel_host *intel_host, struct device *dev,\n\t\t     unsigned int fn, u32 *result)\n{\n\tif (fn > 31 || !(intel_host->dsm_fns & (1 << fn)))\n\t\treturn -EOPNOTSUPP;\n\n\treturn __intel_dsm(intel_host, dev, fn, result);\n}\n\nstatic void intel_dsm_init(struct intel_host *intel_host, struct device *dev,\n\t\t\t   struct mmc_host *mmc)\n{\n\tint err;\n\n\tintel_host->hs_caps = ~0;\n\n\terr = __intel_dsm(intel_host, dev, INTEL_DSM_FNS, &intel_host->dsm_fns);\n\tif (err) {\n\t\tpr_debug(\"%s: DSM not supported, error %d\\n\",\n\t\t\t mmc_hostname(mmc), err);\n\t\treturn;\n\t}\n\n\tpr_debug(\"%s: DSM function mask %#x\\n\",\n\t\t mmc_hostname(mmc), intel_host->dsm_fns);\n\n\tintel_dsm(intel_host, dev, INTEL_DSM_HS_CAPS, &intel_host->hs_caps);\n}\n\nstatic int intel_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t     struct mmc_ios *ios)\n{\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\tstruct intel_host *intel_host = sdhci_acpi_priv(c);\n\tunsigned int fn;\n\tu32 result = 0;\n\tint err;\n\n\terr = sdhci_start_signal_voltage_switch(mmc, ios);\n\tif (err)\n\t\treturn err;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tfn = INTEL_DSM_V33_SWITCH;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tfn = INTEL_DSM_V18_SWITCH;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = intel_dsm(intel_host, dev, fn, &result);\n\tpr_debug(\"%s: %s DSM fn %u error %d result %u\\n\",\n\t\t mmc_hostname(mmc), __func__, fn, err, result);\n\n\treturn 0;\n}\n\nstatic void sdhci_acpi_int_hw_reset(struct sdhci_host *host)\n{\n\tu8 reg;\n\n\treg = sdhci_readb(host, SDHCI_POWER_CONTROL);\n\treg |= 0x10;\n\tsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\n\t \n\tudelay(9);\n\treg &= ~0x10;\n\tsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\n\t \n\tusleep_range(300, 1000);\n}\n\nstatic const struct sdhci_ops sdhci_acpi_ops_dflt = {\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_ops sdhci_acpi_ops_int = {\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.hw_reset   = sdhci_acpi_int_hw_reset,\n};\n\nstatic const struct sdhci_acpi_chip sdhci_acpi_chip_int = {\n\t.ops = &sdhci_acpi_ops_int,\n};\n\n#ifdef CONFIG_X86\n\n#define BYT_IOSF_SCCEP\t\t\t0x63\n#define BYT_IOSF_OCP_NETCTRL0\t\t0x1078\n#define BYT_IOSF_OCP_TIMEOUT_BASE\tGENMASK(10, 8)\n\nstatic void sdhci_acpi_byt_setting(struct device *dev)\n{\n\tu32 val = 0;\n\n\tif (!soc_intel_is_byt())\n\t\treturn;\n\n\tif (iosf_mbi_read(BYT_IOSF_SCCEP, MBI_CR_READ, BYT_IOSF_OCP_NETCTRL0,\n\t\t\t  &val)) {\n\t\tdev_err(dev, \"%s read error\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!(val & BYT_IOSF_OCP_TIMEOUT_BASE))\n\t\treturn;\n\n\tval &= ~BYT_IOSF_OCP_TIMEOUT_BASE;\n\n\tif (iosf_mbi_write(BYT_IOSF_SCCEP, MBI_CR_WRITE, BYT_IOSF_OCP_NETCTRL0,\n\t\t\t   val)) {\n\t\tdev_err(dev, \"%s write error\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdev_dbg(dev, \"%s completed\\n\", __func__);\n}\n\nstatic bool sdhci_acpi_byt_defer(struct device *dev)\n{\n\tif (!soc_intel_is_byt())\n\t\treturn false;\n\n\tif (!iosf_mbi_available())\n\t\treturn true;\n\n\tsdhci_acpi_byt_setting(dev);\n\n\treturn false;\n}\n\n#else\n\nstatic inline void sdhci_acpi_byt_setting(struct device *dev)\n{\n}\n\nstatic inline bool sdhci_acpi_byt_defer(struct device *dev)\n{\n\treturn false;\n}\n\n#endif\n\nstatic int bxt_get_cd(struct mmc_host *mmc)\n{\n\tint gpio_cd = mmc_gpio_get_cd(mmc);\n\n\tif (!gpio_cd)\n\t\treturn 0;\n\n\treturn sdhci_get_cd_nogpio(mmc);\n}\n\nstatic int intel_probe_slot(struct platform_device *pdev, struct acpi_device *adev)\n{\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct intel_host *intel_host = sdhci_acpi_priv(c);\n\tstruct sdhci_host *host = c->host;\n\n\tif (acpi_dev_hid_uid_match(adev, \"80860F14\", \"1\") &&\n\t    sdhci_readl(host, SDHCI_CAPABILITIES) == 0x446cc8b2 &&\n\t    sdhci_readl(host, SDHCI_CAPABILITIES_1) == 0x00000807)\n\t\thost->timeout_clk = 1000;  \n\n\tif (acpi_dev_hid_uid_match(adev, \"80865ACA\", NULL))\n\t\thost->mmc_host_ops.get_cd = bxt_get_cd;\n\n\tintel_dsm_init(intel_host, &pdev->dev, host->mmc);\n\n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\t\t\t\tintel_start_signal_voltage_switch;\n\n\tc->is_intel = true;\n\n\treturn 0;\n}\n\nstatic int intel_setup_host(struct platform_device *pdev)\n{\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct intel_host *intel_host = sdhci_acpi_priv(c);\n\n\tif (!(intel_host->hs_caps & INTEL_DSM_HS_CAPS_SDR25))\n\t\tc->host->mmc->caps &= ~MMC_CAP_UHS_SDR25;\n\n\tif (!(intel_host->hs_caps & INTEL_DSM_HS_CAPS_SDR50))\n\t\tc->host->mmc->caps &= ~MMC_CAP_UHS_SDR50;\n\n\tif (!(intel_host->hs_caps & INTEL_DSM_HS_CAPS_DDR50))\n\t\tc->host->mmc->caps &= ~MMC_CAP_UHS_DDR50;\n\n\tif (!(intel_host->hs_caps & INTEL_DSM_HS_CAPS_SDR104))\n\t\tc->host->mmc->caps &= ~MMC_CAP_UHS_SDR104;\n\n\treturn 0;\n}\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_int_emmc = {\n\t.chip    = &sdhci_acpi_chip_int,\n\t.caps    = MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |\n\t\t   MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |\n\t\t   MMC_CAP_CMD_DURING_TFR | MMC_CAP_WAIT_WHILE_BUSY,\n\t.flags   = SDHCI_ACPI_RUNTIME_PM,\n\t.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t   SDHCI_QUIRK_NO_LED,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_STOP_WITH_TC |\n\t\t   SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400,\n\t.probe_slot\t= intel_probe_slot,\n\t.setup_host\t= intel_setup_host,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_int_sdio = {\n\t.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t   SDHCI_QUIRK_NO_LED |\n\t\t   SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.quirks2 = SDHCI_QUIRK2_HOST_OFF_CARD_ON,\n\t.caps    = MMC_CAP_NONREMOVABLE | MMC_CAP_POWER_OFF_CARD |\n\t\t   MMC_CAP_WAIT_WHILE_BUSY,\n\t.flags   = SDHCI_ACPI_RUNTIME_PM,\n\t.pm_caps = MMC_PM_KEEP_POWER,\n\t.probe_slot\t= intel_probe_slot,\n\t.setup_host\t= intel_setup_host,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_int_sd = {\n\t.flags   = SDHCI_ACPI_SD_CD | SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL |\n\t\t   SDHCI_ACPI_RUNTIME_PM,\n\t.quirks  = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t   SDHCI_QUIRK_NO_LED,\n\t.quirks2 = SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON |\n\t\t   SDHCI_QUIRK2_STOP_WITH_TC,\n\t.caps    = MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_AGGRESSIVE_PM,\n\t.probe_slot\t= intel_probe_slot,\n\t.setup_host\t= intel_setup_host,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\n#define VENDOR_SPECIFIC_PWRCTL_CLEAR_REG\t0x1a8\n#define VENDOR_SPECIFIC_PWRCTL_CTL_REG\t\t0x1ac\nstatic irqreturn_t sdhci_acpi_qcom_handler(int irq, void *ptr)\n{\n\tstruct sdhci_host *host = ptr;\n\n\tsdhci_writel(host, 0x3, VENDOR_SPECIFIC_PWRCTL_CLEAR_REG);\n\tsdhci_writel(host, 0x1, VENDOR_SPECIFIC_PWRCTL_CTL_REG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int qcom_probe_slot(struct platform_device *pdev, struct acpi_device *adev)\n{\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct sdhci_host *host = c->host;\n\tint *irq = sdhci_acpi_priv(c);\n\n\t*irq = -EINVAL;\n\n\tif (!acpi_dev_hid_uid_match(adev, \"QCOM8051\", NULL))\n\t\treturn 0;\n\n\t*irq = platform_get_irq(pdev, 1);\n\tif (*irq < 0)\n\t\treturn 0;\n\n\treturn request_threaded_irq(*irq, NULL, sdhci_acpi_qcom_handler,\n\t\t\t\t    IRQF_ONESHOT | IRQF_TRIGGER_HIGH,\n\t\t\t\t    \"sdhci_qcom\", host);\n}\n\nstatic int qcom_free_slot(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct sdhci_host *host = c->host;\n\tstruct acpi_device *adev;\n\tint *irq = sdhci_acpi_priv(c);\n\n\tadev = ACPI_COMPANION(dev);\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tif (!acpi_dev_hid_uid_match(adev, \"QCOM8051\", NULL))\n\t\treturn 0;\n\n\tif (*irq < 0)\n\t\treturn 0;\n\n\tfree_irq(*irq, host);\n\treturn 0;\n}\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_qcom_sd_3v = {\n\t.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION,\n\t.quirks2 = SDHCI_QUIRK2_NO_1_8_V,\n\t.caps    = MMC_CAP_NONREMOVABLE,\n\t.priv_size\t= sizeof(int),\n\t.probe_slot\t= qcom_probe_slot,\n\t.free_slot\t= qcom_free_slot,\n};\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_qcom_sd = {\n\t.quirks  = SDHCI_QUIRK_BROKEN_CARD_DETECTION,\n\t.caps    = MMC_CAP_NONREMOVABLE,\n};\n\nstruct amd_sdhci_host {\n\tbool\ttuned_clock;\n\tbool\tdll_enabled;\n};\n\n \n#define SDHCI_AMD_RESET_DLL_REGISTER    0x908\n\nstatic int amd_select_drive_strength(struct mmc_card *card,\n\t\t\t\t     unsigned int max_dtr, int host_drv,\n\t\t\t\t     int card_drv, int *host_driver_strength)\n{\n\tstruct sdhci_host *host = mmc_priv(card->host);\n\tu16 preset, preset_driver_strength;\n\n\t \n\tpreset = sdhci_readw(host, SDHCI_PRESET_FOR_SDR104);\n\tpreset_driver_strength = FIELD_GET(SDHCI_PRESET_DRV_MASK, preset);\n\n\t \n\t*host_driver_strength = preset_driver_strength;\n\n\t \n\treturn preset_driver_strength;\n}\n\nstatic void sdhci_acpi_amd_hs400_dll(struct sdhci_host *host, bool enable)\n{\n\tstruct sdhci_acpi_host *acpi_host = sdhci_priv(host);\n\tstruct amd_sdhci_host *amd_host = sdhci_acpi_priv(acpi_host);\n\n\t \n\tsdhci_writel(host, 0x40003210, SDHCI_AMD_RESET_DLL_REGISTER);\n\tusleep_range(10, 20);\n\tif (enable)\n\t\tsdhci_writel(host, 0x40033210, SDHCI_AMD_RESET_DLL_REGISTER);\n\n\tamd_host->dll_enabled = enable;\n}\n\n \nstatic void amd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_acpi_host *acpi_host = sdhci_priv(host);\n\tstruct amd_sdhci_host *amd_host = sdhci_acpi_priv(acpi_host);\n\tunsigned int old_timing = host->timing;\n\tu16 val;\n\n\tsdhci_set_ios(mmc, ios);\n\n\tif (old_timing != host->timing && amd_host->tuned_clock) {\n\t\tif (host->timing == MMC_TIMING_MMC_HS400 ||\n\t\t    host->timing == MMC_TIMING_MMC_HS200) {\n\t\t\tval = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t\t\tval |= SDHCI_CTRL_TUNED_CLK;\n\t\t\tsdhci_writew(host, val, SDHCI_HOST_CONTROL2);\n\t\t} else {\n\t\t\tval = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t\t\tval &= ~SDHCI_CTRL_TUNED_CLK;\n\t\t\tsdhci_writew(host, val, SDHCI_HOST_CONTROL2);\n\t\t}\n\n\t\t \n\t\tif (host->timing == MMC_TIMING_MMC_HS400 &&\n\t\t    !amd_host->dll_enabled)\n\t\t\tsdhci_acpi_amd_hs400_dll(host, true);\n\t}\n}\n\nstatic int amd_sdhci_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tint err;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_acpi_host *acpi_host = sdhci_priv(host);\n\tstruct amd_sdhci_host *amd_host = sdhci_acpi_priv(acpi_host);\n\n\tamd_host->tuned_clock = false;\n\n\terr = sdhci_execute_tuning(mmc, opcode);\n\n\tif (!err && !host->tuning_err)\n\t\tamd_host->tuned_clock = true;\n\n\treturn err;\n}\n\nstatic void amd_sdhci_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_acpi_host *acpi_host = sdhci_priv(host);\n\tstruct amd_sdhci_host *amd_host = sdhci_acpi_priv(acpi_host);\n\n\tif (mask & SDHCI_RESET_ALL) {\n\t\tamd_host->tuned_clock = false;\n\t\tsdhci_acpi_amd_hs400_dll(host, false);\n\t}\n\n\tsdhci_reset(host, mask);\n}\n\nstatic const struct sdhci_ops sdhci_acpi_ops_amd = {\n\t.set_clock\t= sdhci_set_clock,\n\t.set_bus_width\t= sdhci_set_bus_width,\n\t.reset\t\t= amd_sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_acpi_chip sdhci_acpi_chip_amd = {\n\t.ops = &sdhci_acpi_ops_amd,\n};\n\nstatic int sdhci_acpi_emmc_amd_probe_slot(struct platform_device *pdev,\n\t\t\t\t\t  struct acpi_device *adev)\n{\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct sdhci_host *host   = c->host;\n\n\tsdhci_read_caps(host);\n\tif (host->caps1 & SDHCI_SUPPORT_DDR50)\n\t\thost->mmc->caps = MMC_CAP_1_8V_DDR;\n\n\tif ((host->caps1 & SDHCI_SUPPORT_SDR104) &&\n\t    (host->mmc->caps & MMC_CAP_1_8V_DDR))\n\t\thost->mmc->caps2 = MMC_CAP2_HS400_1_8V;\n\n\t \n\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\n\thost->mmc_host_ops.select_drive_strength = amd_select_drive_strength;\n\thost->mmc_host_ops.set_ios = amd_set_ios;\n\thost->mmc_host_ops.execute_tuning = amd_sdhci_execute_tuning;\n\treturn 0;\n}\n\nstatic const struct sdhci_acpi_slot sdhci_acpi_slot_amd_emmc = {\n\t.chip\t\t= &sdhci_acpi_chip_amd,\n\t.caps\t\t= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE,\n\t.quirks\t\t= SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\t\t  SDHCI_QUIRK_32BIT_DMA_SIZE |\n\t\t\t  SDHCI_QUIRK_32BIT_ADMA_SIZE,\n\t.quirks2\t= SDHCI_QUIRK2_BROKEN_64_BIT_DMA,\n\t.probe_slot     = sdhci_acpi_emmc_amd_probe_slot,\n\t.priv_size\t= sizeof(struct amd_sdhci_host),\n};\n\nstruct sdhci_acpi_uid_slot {\n\tconst char *hid;\n\tconst char *uid;\n\tconst struct sdhci_acpi_slot *slot;\n};\n\nstatic const struct sdhci_acpi_uid_slot sdhci_acpi_uids[] = {\n\t{ \"80865ACA\", NULL, &sdhci_acpi_slot_int_sd },\n\t{ \"80865ACC\", NULL, &sdhci_acpi_slot_int_emmc },\n\t{ \"80865AD0\", NULL, &sdhci_acpi_slot_int_sdio },\n\t{ \"80860F14\" , \"1\" , &sdhci_acpi_slot_int_emmc },\n\t{ \"80860F14\" , \"2\" , &sdhci_acpi_slot_int_sdio },\n\t{ \"80860F14\" , \"3\" , &sdhci_acpi_slot_int_sd   },\n\t{ \"80860F16\" , NULL, &sdhci_acpi_slot_int_sd   },\n\t{ \"INT33BB\"  , \"2\" , &sdhci_acpi_slot_int_sdio },\n\t{ \"INT33BB\"  , \"3\" , &sdhci_acpi_slot_int_sd },\n\t{ \"INT33C6\"  , NULL, &sdhci_acpi_slot_int_sdio },\n\t{ \"INT3436\"  , NULL, &sdhci_acpi_slot_int_sdio },\n\t{ \"INT344D\"  , NULL, &sdhci_acpi_slot_int_sdio },\n\t{ \"PNP0FFF\"  , \"3\" , &sdhci_acpi_slot_int_sd   },\n\t{ \"PNP0D40\"  },\n\t{ \"QCOM8051\", NULL, &sdhci_acpi_slot_qcom_sd_3v },\n\t{ \"QCOM8052\", NULL, &sdhci_acpi_slot_qcom_sd },\n\t{ \"AMDI0040\", NULL, &sdhci_acpi_slot_amd_emmc },\n\t{ \"AMDI0041\", NULL, &sdhci_acpi_slot_amd_emmc },\n\t{ },\n};\n\nstatic const struct acpi_device_id sdhci_acpi_ids[] = {\n\t{ \"80865ACA\" },\n\t{ \"80865ACC\" },\n\t{ \"80865AD0\" },\n\t{ \"80860F14\" },\n\t{ \"80860F16\" },\n\t{ \"INT33BB\"  },\n\t{ \"INT33C6\"  },\n\t{ \"INT3436\"  },\n\t{ \"INT344D\"  },\n\t{ \"PNP0D40\"  },\n\t{ \"QCOM8051\" },\n\t{ \"QCOM8052\" },\n\t{ \"AMDI0040\" },\n\t{ \"AMDI0041\" },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, sdhci_acpi_ids);\n\nstatic const struct dmi_system_id sdhci_acpi_quirks[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"LENOVO\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_VERSION, \"Lenovo MIIX 320-10ICR\"),\n\t\t},\n\t\t.driver_data = (void *)DMI_QUIRK_RESET_SD_SIGNAL_VOLT_ON_SUSP,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Acer\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Aspire SW5-012\"),\n\t\t},\n\t\t.driver_data = (void *)DMI_QUIRK_SD_NO_WRITE_PROTECT,\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"TOSHIBA\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TOSHIBA ENCORE 2 WT8-B\"),\n\t\t},\n\t\t.driver_data = (void *)DMI_QUIRK_SD_NO_WRITE_PROTECT,\n\t},\n\t{}  \n};\n\nstatic const struct sdhci_acpi_slot *sdhci_acpi_get_slot(struct acpi_device *adev)\n{\n\tconst struct sdhci_acpi_uid_slot *u;\n\n\tfor (u = sdhci_acpi_uids; u->hid; u++) {\n\t\tif (acpi_dev_hid_uid_match(adev, u->hid, u->uid))\n\t\t\treturn u->slot;\n\t}\n\treturn NULL;\n}\n\nstatic int sdhci_acpi_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct sdhci_acpi_slot *slot;\n\tconst struct dmi_system_id *id;\n\tstruct acpi_device *device;\n\tstruct sdhci_acpi_host *c;\n\tstruct sdhci_host *host;\n\tstruct resource *iomem;\n\tresource_size_t len;\n\tsize_t priv_size;\n\tint quirks = 0;\n\tint err;\n\n\tdevice = ACPI_COMPANION(dev);\n\tif (!device)\n\t\treturn -ENODEV;\n\n\tid = dmi_first_match(sdhci_acpi_quirks);\n\tif (id)\n\t\tquirks = (long)id->driver_data;\n\n\tslot = sdhci_acpi_get_slot(device);\n\n\t \n\tacpi_device_fix_up_power_extended(device);\n\n\tif (sdhci_acpi_byt_defer(dev))\n\t\treturn -EPROBE_DEFER;\n\n\tiomem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!iomem)\n\t\treturn -ENOMEM;\n\n\tlen = resource_size(iomem);\n\tif (len < 0x100)\n\t\tdev_err(dev, \"Invalid iomem size!\\n\");\n\n\tif (!devm_request_mem_region(dev, iomem->start, len, dev_name(dev)))\n\t\treturn -ENOMEM;\n\n\tpriv_size = slot ? slot->priv_size : 0;\n\thost = sdhci_alloc_host(dev, sizeof(struct sdhci_acpi_host) + priv_size);\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tc = sdhci_priv(host);\n\tc->host = host;\n\tc->slot = slot;\n\tc->pdev = pdev;\n\tc->use_runtime_pm = sdhci_acpi_flag(c, SDHCI_ACPI_RUNTIME_PM);\n\n\tplatform_set_drvdata(pdev, c);\n\n\thost->hw_name\t= \"ACPI\";\n\thost->ops\t= &sdhci_acpi_ops_dflt;\n\thost->irq\t= platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\terr = host->irq;\n\t\tgoto err_free;\n\t}\n\n\thost->ioaddr = devm_ioremap(dev, iomem->start,\n\t\t\t\t\t    resource_size(iomem));\n\tif (host->ioaddr == NULL) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tif (c->slot) {\n\t\tif (c->slot->probe_slot) {\n\t\t\terr = c->slot->probe_slot(pdev, device);\n\t\t\tif (err)\n\t\t\t\tgoto err_free;\n\t\t}\n\t\tif (c->slot->chip) {\n\t\t\thost->ops            = c->slot->chip->ops;\n\t\t\thost->quirks        |= c->slot->chip->quirks;\n\t\t\thost->quirks2       |= c->slot->chip->quirks2;\n\t\t\thost->mmc->caps     |= c->slot->chip->caps;\n\t\t\thost->mmc->caps2    |= c->slot->chip->caps2;\n\t\t\thost->mmc->pm_caps  |= c->slot->chip->pm_caps;\n\t\t}\n\t\thost->quirks        |= c->slot->quirks;\n\t\thost->quirks2       |= c->slot->quirks2;\n\t\thost->mmc->caps     |= c->slot->caps;\n\t\thost->mmc->caps2    |= c->slot->caps2;\n\t\thost->mmc->pm_caps  |= c->slot->pm_caps;\n\t}\n\n\thost->mmc->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;\n\n\tif (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {\n\t\tbool v = sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL);\n\n\t\terr = mmc_gpiod_request_cd(host->mmc, NULL, 0, v, 0);\n\t\tif (err) {\n\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\tgoto err_free;\n\t\t\tdev_warn(dev, \"failed to setup card detect gpio\\n\");\n\t\t\tc->use_runtime_pm = false;\n\t\t}\n\n\t\tif (quirks & DMI_QUIRK_RESET_SD_SIGNAL_VOLT_ON_SUSP)\n\t\t\tc->reset_signal_volt_on_suspend = true;\n\n\t\tif (quirks & DMI_QUIRK_SD_NO_WRITE_PROTECT)\n\t\t\thost->mmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;\n\t}\n\n\terr = sdhci_setup_host(host);\n\tif (err)\n\t\tgoto err_free;\n\n\tif (c->slot && c->slot->setup_host) {\n\t\terr = c->slot->setup_host(pdev);\n\t\tif (err)\n\t\t\tgoto err_cleanup;\n\t}\n\n\terr = __sdhci_add_host(host);\n\tif (err)\n\t\tgoto err_cleanup;\n\n\tif (c->use_runtime_pm) {\n\t\tpm_runtime_set_active(dev);\n\t\tpm_suspend_ignore_children(dev, 1);\n\t\tpm_runtime_set_autosuspend_delay(dev, 50);\n\t\tpm_runtime_use_autosuspend(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\tdevice_enable_async_suspend(dev);\n\n\treturn 0;\n\nerr_cleanup:\n\tsdhci_cleanup_host(c->host);\nerr_free:\n\tif (c->slot && c->slot->free_slot)\n\t\tc->slot->free_slot(pdev);\n\n\tsdhci_free_host(c->host);\n\treturn err;\n}\n\nstatic void sdhci_acpi_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_acpi_host *c = platform_get_drvdata(pdev);\n\tstruct device *dev = &pdev->dev;\n\tint dead;\n\n\tif (c->use_runtime_pm) {\n\t\tpm_runtime_get_sync(dev);\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_put_noidle(dev);\n\t}\n\n\tif (c->slot && c->slot->remove_slot)\n\t\tc->slot->remove_slot(pdev);\n\n\tdead = (sdhci_readl(c->host, SDHCI_INT_STATUS) == ~0);\n\tsdhci_remove_host(c->host, dead);\n\n\tif (c->slot && c->slot->free_slot)\n\t\tc->slot->free_slot(pdev);\n\n\tsdhci_free_host(c->host);\n}\n\nstatic void __maybe_unused sdhci_acpi_reset_signal_voltage_if_needed(\n\tstruct device *dev)\n{\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\tstruct sdhci_host *host = c->host;\n\n\tif (c->is_intel && c->reset_signal_volt_on_suspend &&\n\t    host->mmc->ios.signal_voltage != MMC_SIGNAL_VOLTAGE_330) {\n\t\tstruct intel_host *intel_host = sdhci_acpi_priv(c);\n\t\tunsigned int fn = INTEL_DSM_V33_SWITCH;\n\t\tu32 result = 0;\n\n\t\tintel_dsm(intel_host, dev, fn, &result);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int sdhci_acpi_suspend(struct device *dev)\n{\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\tstruct sdhci_host *host = c->host;\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = sdhci_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tsdhci_acpi_reset_signal_voltage_if_needed(dev);\n\treturn 0;\n}\n\nstatic int sdhci_acpi_resume(struct device *dev)\n{\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\n\tsdhci_acpi_byt_setting(&c->pdev->dev);\n\n\treturn sdhci_resume_host(c->host);\n}\n\n#endif\n\n#ifdef CONFIG_PM\n\nstatic int sdhci_acpi_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\tstruct sdhci_host *host = c->host;\n\tint ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tret = sdhci_runtime_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tsdhci_acpi_reset_signal_voltage_if_needed(dev);\n\treturn 0;\n}\n\nstatic int sdhci_acpi_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_acpi_host *c = dev_get_drvdata(dev);\n\n\tsdhci_acpi_byt_setting(&c->pdev->dev);\n\n\treturn sdhci_runtime_resume_host(c->host, 0);\n}\n\n#endif\n\nstatic const struct dev_pm_ops sdhci_acpi_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_acpi_suspend, sdhci_acpi_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_acpi_runtime_suspend,\n\t\t\tsdhci_acpi_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sdhci_acpi_driver = {\n\t.driver = {\n\t\t.name\t\t\t= \"sdhci-acpi\",\n\t\t.probe_type\t\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.acpi_match_table\t= sdhci_acpi_ids,\n\t\t.pm\t\t\t= &sdhci_acpi_pm_ops,\n\t},\n\t.probe\t= sdhci_acpi_probe,\n\t.remove_new = sdhci_acpi_remove,\n};\n\nmodule_platform_driver(sdhci_acpi_driver);\n\nMODULE_DESCRIPTION(\"Secure Digital Host Controller Interface ACPI driver\");\nMODULE_AUTHOR(\"Adrian Hunter\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}