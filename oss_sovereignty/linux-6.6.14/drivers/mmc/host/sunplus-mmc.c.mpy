{
  "module_name": "sunplus-mmc.c",
  "hash_id": "756893ee941c1920defec00141386969c5208620c10e1355c814c02f68a262ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sunplus-mmc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#define SPMMC_MIN_CLK\t\t\t400000\n#define SPMMC_MAX_CLK\t\t\t52000000\n#define SPMMC_MAX_BLK_COUNT\t\t65536\n#define SPMMC_MAX_TUNABLE_DLY\t7\n#define SPMMC_TIMEOUT_US\t\t500000\n#define SPMMC_POLL_DELAY_US\t\t10\n\n#define SPMMC_CARD_MEDIATYPE_SRCDST_REG 0x0000\n#define SPMMC_MEDIA_TYPE\t\tGENMASK(2, 0)\n#define SPMMC_DMA_SOURCE\t\tGENMASK(6, 4)\n#define SPMMC_DMA_DESTINATION\t\tGENMASK(10, 8)\n#define SPMMC_MEDIA_NONE\t0\n#define SPMMC_MEDIA_SD\t\t6\n#define SPMMC_MEDIA_MS\t\t7\n\n#define SPMMC_SDRAM_SECTOR_0_SIZE_REG\t0x0008\n#define SPMMC_DMA_BASE_ADDR_REG\t\t0x000C\n#define SPMMC_HW_DMA_CTRL_REG\t\t0x0010\n#define SPMMC_HW_DMA_RST\tBIT(9)\n#define SPMMC_DMAIDLE\t\tBIT(10)\n\n#define SPMMC_MAX_DMA_MEMORY_SECTORS\t8\n\n#define SPMMC_SDRAM_SECTOR_1_ADDR_REG 0x0018\n#define SPMMC_SDRAM_SECTOR_1_LENG_REG 0x001C\n#define SPMMC_SDRAM_SECTOR_2_ADDR_REG 0x0020\n#define SPMMC_SDRAM_SECTOR_2_LENG_REG 0x0024\n#define SPMMC_SDRAM_SECTOR_3_ADDR_REG 0x0028\n#define SPMMC_SDRAM_SECTOR_3_LENG_REG 0x002C\n#define SPMMC_SDRAM_SECTOR_4_ADDR_REG 0x0030\n#define SPMMC_SDRAM_SECTOR_4_LENG_REG 0x0034\n#define SPMMC_SDRAM_SECTOR_5_ADDR_REG 0x0038\n#define SPMMC_SDRAM_SECTOR_5_LENG_REG 0x003C\n#define SPMMC_SDRAM_SECTOR_6_ADDR_REG 0x0040\n#define SPMMC_SDRAM_SECTOR_6_LENG_REG 0x0044\n#define SPMMC_SDRAM_SECTOR_7_ADDR_REG 0x0048\n#define SPMMC_SDRAM_SECTOR_7_LENG_REG 0x004C\n\n#define SPMMC_SD_INT_REG\t0x0088\n#define SPMMC_SDINT_SDCMPEN\tBIT(0)\n#define SPMMC_SDINT_SDCMP\tBIT(1)\n#define SPMMC_SDINT_SDCMPCLR\tBIT(2)\n#define SPMMC_SDINT_SDIOEN\tBIT(3)\n#define SPMMC_SDINT_SDIO\tBIT(4)\n#define SPMMC_SDINT_SDIOCLR\tBIT(5)\n\n#define SPMMC_SD_PAGE_NUM_REG\t0x008C\n\n#define SPMMC_SD_CONFIG0_REG\t0x0090\n#define SPMMC_SD_PIO_MODE\tBIT(0)\n#define SPMMC_SD_DDR_MODE\tBIT(1)\n#define SPMMC_SD_LEN_MODE\tBIT(2)\n#define SPMMC_SD_TRANS_MODE\tGENMASK(5, 4)\n#define SPMMC_SD_AUTO_RESPONSE\tBIT(6)\n#define SPMMC_SD_CMD_DUMMY\tBIT(7)\n#define SPMMC_SD_RSP_CHK_EN\tBIT(8)\n#define SPMMC_SDIO_MODE\t\tBIT(9)\n#define SPMMC_SD_MMC_MODE\tBIT(10)\n#define SPMMC_SD_DATA_WD\tBIT(11)\n#define SPMMC_RX4_EN\t\tBIT(14)\n#define SPMMC_SD_RSP_TYPE\tBIT(15)\n#define SPMMC_MMC8_EN\t\tBIT(18)\n#define SPMMC_CLOCK_DIVISION\tGENMASK(31, 20)\n\n#define SPMMC_SDIO_CTRL_REG\t\t0x0094\n#define SPMMC_INT_MULTI_TRIG\t\tBIT(6)\n\n#define SPMMC_SD_RST_REG\t\t0x0098\n#define SPMMC_SD_CTRL_REG\t\t0x009C\n#define SPMMC_NEW_COMMAND_TRIGGER\tBIT(0)\n#define SPMMC_DUMMY_CLOCK_TRIGGER\tBIT(1)\n\n#define SPMMC_SD_STATUS_REG\t\t\t\t\t\t0x00A0\n#define SPMMC_SDSTATUS_DUMMY_READY\t\t\t\tBIT(0)\n#define SPMMC_SDSTATUS_RSP_BUF_FULL\t\t\t\tBIT(1)\n#define SPMMC_SDSTATUS_TX_DATA_BUF_EMPTY\t\tBIT(2)\n#define SPMMC_SDSTATUS_RX_DATA_BUF_FULL\t\t\tBIT(3)\n#define SPMMC_SDSTATUS_CMD_PIN_STATUS\t\t\tBIT(4)\n#define SPMMC_SDSTATUS_DAT0_PIN_STATUS\t\t\tBIT(5)\n#define SPMMC_SDSTATUS_RSP_TIMEOUT\t\t\t\tBIT(6)\n#define SPMMC_SDSTATUS_CARD_CRC_CHECK_TIMEOUT\tBIT(7)\n#define SPMMC_SDSTATUS_STB_TIMEOUT\t\t\t\tBIT(8)\n#define SPMMC_SDSTATUS_RSP_CRC7_ERROR\t\t\tBIT(9)\n#define SPMMC_SDSTATUS_CRC_TOKEN_CHECK_ERROR\tBIT(10)\n#define SPMMC_SDSTATUS_RDATA_CRC16_ERROR\t\tBIT(11)\n#define SPMMC_SDSTATUS_SUSPEND_STATE_READY\t\tBIT(12)\n#define SPMMC_SDSTATUS_BUSY_CYCLE\t\t\t\tBIT(13)\n#define SPMMC_SDSTATUS_DAT1_PIN_STATUS\t\t\tBIT(14)\n#define SPMMC_SDSTATUS_SD_SENSE_STATUS\t\t\tBIT(15)\n#define SPMMC_SDSTATUS_BOOT_ACK_TIMEOUT\t\t\tBIT(16)\n#define SPMMC_SDSTATUS_BOOT_DATA_TIMEOUT\t\tBIT(17)\n#define SPMMC_SDSTATUS_BOOT_ACK_ERROR\t\t\tBIT(18)\n\n#define SPMMC_SD_STATE_REG\t\t0x00A4\n#define SPMMC_CRCTOKEN_CHECK_RESULT\tGENMASK(6, 4)\n#define SPMMC_SDSTATE_ERROR\t\tBIT(13)\n#define SPMMC_SDSTATE_FINISH\tBIT(14)\n\n#define SPMMC_SD_HW_STATE_REG\t\t0x00A8\n#define SPMMC_SD_BLOCKSIZE_REG\t\t0x00AC\n\n#define SPMMC_SD_CONFIG1_REG\t\t0x00B0\n#define SPMMC_TX_DUMMY_NUM\t\tGENMASK(8, 0)\n#define SPMMC_SD_HIGH_SPEED_EN\t\tBIT(31)\n\n#define SPMMC_SD_TIMING_CONFIG0_REG 0x00B4\n#define SPMMC_SD_CLOCK_DELAY\tGENMASK(2, 0)\n#define SPMMC_SD_WRITE_DATA_DELAY\tGENMASK(6, 4)\n#define SPMMC_SD_WRITE_COMMAND_DELAY\tGENMASK(10, 8)\n#define SPMMC_SD_READ_RESPONSE_DELAY\tGENMASK(14, 12)\n#define SPMMC_SD_READ_DATA_DELAY\tGENMASK(18, 16)\n#define SPMMC_SD_READ_CRC_DELAY\tGENMASK(22, 20)\n\n#define SPMMC_SD_PIODATATX_REG\t\t0x00BC\n#define SPMMC_SD_PIODATARX_REG\t\t0x00C0\n#define SPMMC_SD_CMDBUF0_3_REG\t\t0x00C4\n#define SPMMC_SD_CMDBUF4_REG\t\t0x00C8\n#define SPMMC_SD_RSPBUF0_3_REG\t\t0x00CC\n#define SPMMC_SD_RSPBUF4_5_REG\t\t0x00D0\n\n#define SPMMC_MAX_RETRIES (8 * 8)\n\nstruct spmmc_tuning_info {\n\tint enable_tuning;\n\tint need_tuning;\n\tint retried;  \n\tu32 rd_crc_dly:3;\n\tu32 rd_dat_dly:3;\n\tu32 rd_rsp_dly:3;\n\tu32 wr_cmd_dly:3;\n\tu32 wr_dat_dly:3;\n\tu32 clk_dly:3;\n};\n\n#define SPMMC_DMA_MODE 0\n#define\tSPMMC_PIO_MODE 1\n\nstruct spmmc_host {\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\tstruct reset_control *rstc;\n\tstruct mmc_host *mmc;\n\tstruct mmc_request *mrq;  \n\tint irq;\n\tint dmapio_mode;\n\tstruct spmmc_tuning_info tuning_info;\n\tint dma_int_threshold;\n\tint dma_use_int;\n};\n\nstatic inline int spmmc_wait_finish(struct spmmc_host *host)\n{\n\tu32 state;\n\n\treturn readl_poll_timeout(host->base + SPMMC_SD_STATE_REG, state,\n\t\t\t\t\t(state & SPMMC_SDSTATE_FINISH),\n\t\t\t\t\tSPMMC_POLL_DELAY_US, SPMMC_TIMEOUT_US);\n}\n\nstatic inline int spmmc_wait_sdstatus(struct spmmc_host *host, unsigned int status_bit)\n{\n\tu32 status;\n\n\treturn readl_poll_timeout(host->base + SPMMC_SD_STATUS_REG, status,\n\t\t\t\t\t(status & status_bit),\n\t\t\t\t\tSPMMC_POLL_DELAY_US, SPMMC_TIMEOUT_US);\n}\n\n#define spmmc_wait_rspbuf_full(host) spmmc_wait_sdstatus(host, SPMMC_SDSTATUS_RSP_BUF_FULL)\n#define spmmc_wait_rxbuf_full(host) spmmc_wait_sdstatus(host, SPMMC_SDSTATUS_RX_DATA_BUF_FULL)\n#define spmmc_wait_txbuf_empty(host) spmmc_wait_sdstatus(host, SPMMC_SDSTATUS_TX_DATA_BUF_EMPTY)\n\nstatic void spmmc_get_rsp(struct spmmc_host *host, struct mmc_command *cmd)\n{\n\tu32 value0_3, value4_5;\n\n\tif (!(cmd->flags & MMC_RSP_PRESENT))\n\t\treturn;\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tif (spmmc_wait_rspbuf_full(host))\n\t\t\treturn;\n\t\tvalue0_3 = readl(host->base + SPMMC_SD_RSPBUF0_3_REG);\n\t\tvalue4_5 = readl(host->base + SPMMC_SD_RSPBUF4_5_REG) & 0xffff;\n\t\tcmd->resp[0] = (value0_3 << 8) | (value4_5 >> 8);\n\t\tcmd->resp[1] = value4_5 << 24;\n\t\tvalue0_3 = readl(host->base + SPMMC_SD_RSPBUF0_3_REG);\n\t\tvalue4_5 = readl(host->base + SPMMC_SD_RSPBUF4_5_REG) & 0xffff;\n\t\tcmd->resp[1] |= value0_3 >> 8;\n\t\tcmd->resp[2] = value0_3 << 24;\n\t\tcmd->resp[2] |= value4_5 << 8;\n\t\tvalue0_3 = readl(host->base + SPMMC_SD_RSPBUF0_3_REG);\n\t\tvalue4_5 = readl(host->base + SPMMC_SD_RSPBUF4_5_REG) & 0xffff;\n\t\tcmd->resp[2] |= value0_3 >> 24;\n\t\tcmd->resp[3] = value0_3 << 8;\n\t\tcmd->resp[3] |= value4_5 >> 8;\n\t} else {\n\t\tif (spmmc_wait_rspbuf_full(host))\n\t\t\treturn;\n\t\tvalue0_3 = readl(host->base + SPMMC_SD_RSPBUF0_3_REG);\n\t\tvalue4_5 = readl(host->base + SPMMC_SD_RSPBUF4_5_REG) & 0xffff;\n\t\tcmd->resp[0] = (value0_3 << 8) | (value4_5 >> 8);\n\t\tcmd->resp[1] = value4_5 << 24;\n\t}\n}\n\nstatic void spmmc_set_bus_clk(struct spmmc_host *host, int clk)\n{\n\tunsigned int clkdiv;\n\tint f_min = host->mmc->f_min;\n\tint f_max = host->mmc->f_max;\n\tu32 value = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\n\tif (clk < f_min)\n\t\tclk = f_min;\n\tif (clk > f_max)\n\t\tclk = f_max;\n\n\tclkdiv = (clk_get_rate(host->clk) + clk) / clk - 1;\n\tif (clkdiv > 0xfff)\n\t\tclkdiv = 0xfff;\n\tvalue &= ~SPMMC_CLOCK_DIVISION;\n\tvalue |= FIELD_PREP(SPMMC_CLOCK_DIVISION, clkdiv);\n\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n}\n\nstatic void spmmc_set_bus_timing(struct spmmc_host *host, unsigned int timing)\n{\n\tu32 value = readl(host->base + SPMMC_SD_CONFIG1_REG);\n\tint clkdiv = FIELD_GET(SPMMC_CLOCK_DIVISION, readl(host->base + SPMMC_SD_CONFIG0_REG));\n\tint delay = clkdiv / 2 < 7 ? clkdiv / 2 : 7;\n\tint hs_en = 1, ddr_enabled = 0;\n\n\tswitch (timing) {\n\tcase MMC_TIMING_LEGACY:\n\t\ths_en = 0;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_UHS_SDR50:\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\ths_en = 1;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tddr_enabled = 1;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tddr_enabled = 1;\n\t\tbreak;\n\tdefault:\n\t\ths_en = 0;\n\t\tbreak;\n\t}\n\n\tif (hs_en) {\n\t\tvalue |= SPMMC_SD_HIGH_SPEED_EN;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG1_REG);\n\t\tvalue = readl(host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\tvalue &= ~SPMMC_SD_WRITE_DATA_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_WRITE_DATA_DELAY, delay);\n\t\tvalue &= ~SPMMC_SD_WRITE_COMMAND_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_WRITE_COMMAND_DELAY, delay);\n\t\twritel(value, host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t} else {\n\t\tvalue &= ~SPMMC_SD_HIGH_SPEED_EN;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG1_REG);\n\t}\n\tif (ddr_enabled) {\n\t\tvalue = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\t\tvalue |= SPMMC_SD_DDR_MODE;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n\t} else {\n\t\tvalue = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\t\tvalue &= ~SPMMC_SD_DDR_MODE;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n\t}\n}\n\nstatic void spmmc_set_bus_width(struct spmmc_host *host, int width)\n{\n\tu32 value = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tvalue &= ~SPMMC_SD_DATA_WD;\n\t\tvalue |= SPMMC_MMC8_EN;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tvalue |= SPMMC_SD_DATA_WD;\n\t\tvalue &= ~SPMMC_MMC8_EN;\n\t\tbreak;\n\tdefault:\n\t\tvalue &= ~SPMMC_SD_DATA_WD;\n\t\tvalue &= ~SPMMC_MMC8_EN;\n\t\tbreak;\n\t}\n\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n}\n\n \nstatic void spmmc_set_sdmmc_mode(struct spmmc_host *host)\n{\n\tu32 value = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\n\tvalue |= SPMMC_SD_MMC_MODE;\n\tvalue &= ~SPMMC_SDIO_MODE;\n\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n}\n\nstatic void spmmc_sw_reset(struct spmmc_host *host)\n{\n\tu32 value;\n\n\t \n\tvalue = readl(host->base + SPMMC_HW_DMA_CTRL_REG);\n\tvalue |= SPMMC_DMAIDLE;\n\twritel(value, host->base + SPMMC_HW_DMA_CTRL_REG);\n\tvalue &= ~SPMMC_DMAIDLE;\n\twritel(value, host->base + SPMMC_HW_DMA_CTRL_REG);\n\tvalue = readl(host->base + SPMMC_HW_DMA_CTRL_REG);\n\tvalue |= SPMMC_HW_DMA_RST;\n\twritel(value, host->base + SPMMC_HW_DMA_CTRL_REG);\n\twritel(0x7, host->base + SPMMC_SD_RST_REG);\n\treadl_poll_timeout_atomic(host->base + SPMMC_SD_HW_STATE_REG, value,\n\t\t\t\t  !(value & BIT(6)), 1, SPMMC_TIMEOUT_US);\n}\n\nstatic void spmmc_prepare_cmd(struct spmmc_host *host, struct mmc_command *cmd)\n{\n\tu32 value;\n\n\t \n\tvalue = ((cmd->opcode | 0x40) << 24) | (cmd->arg >> 8);\n\twritel(value, host->base + SPMMC_SD_CMDBUF0_3_REG);\n\twriteb(cmd->arg & 0xff, host->base + SPMMC_SD_CMDBUF4_REG);\n\n\t \n\tvalue = readl(host->base + SPMMC_SD_INT_REG);\n\tvalue |= SPMMC_SDINT_SDCMPCLR;\n\tvalue &= ~SPMMC_SDINT_SDCMPEN;\n\twritel(value, host->base + SPMMC_SD_INT_REG);\n\n\tvalue = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\tvalue &= ~SPMMC_SD_TRANS_MODE;\n\tvalue |= SPMMC_SD_CMD_DUMMY;\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tvalue |= SPMMC_SD_AUTO_RESPONSE;\n\t} else {\n\t\tvalue &= ~SPMMC_SD_AUTO_RESPONSE;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n\n\t\treturn;\n\t}\n\t \n\tif (cmd->flags & MMC_RSP_CRC && !(cmd->flags & MMC_RSP_136))\n\t\tvalue |= SPMMC_SD_RSP_CHK_EN;\n\telse\n\t\tvalue &= ~SPMMC_SD_RSP_CHK_EN;\n\n\tif (cmd->flags & MMC_RSP_136)\n\t\tvalue |= SPMMC_SD_RSP_TYPE;\n\telse\n\t\tvalue &= ~SPMMC_SD_RSP_TYPE;\n\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n}\n\nstatic void spmmc_prepare_data(struct spmmc_host *host, struct mmc_data *data)\n{\n\tu32 value, srcdst;\n\n\twritel(data->blocks - 1, host->base + SPMMC_SD_PAGE_NUM_REG);\n\twritel(data->blksz - 1, host->base + SPMMC_SD_BLOCKSIZE_REG);\n\tvalue = readl(host->base + SPMMC_SD_CONFIG0_REG);\n\tif (data->flags & MMC_DATA_READ) {\n\t\tvalue &= ~SPMMC_SD_TRANS_MODE;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_TRANS_MODE, 2);\n\t\tvalue &= ~SPMMC_SD_AUTO_RESPONSE;\n\t\tvalue &= ~SPMMC_SD_CMD_DUMMY;\n\t\tsrcdst = readl(host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n\t\tsrcdst &= ~SPMMC_DMA_SOURCE;\n\t\tsrcdst |= FIELD_PREP(SPMMC_DMA_SOURCE, 0x2);\n\t\tsrcdst &= ~SPMMC_DMA_DESTINATION;\n\t\tsrcdst |= FIELD_PREP(SPMMC_DMA_DESTINATION, 0x1);\n\t\twritel(srcdst, host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n\t} else {\n\t\tvalue &= ~SPMMC_SD_TRANS_MODE;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_TRANS_MODE, 1);\n\t\tsrcdst = readl(host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n\t\tsrcdst &= ~SPMMC_DMA_SOURCE;\n\t\tsrcdst |= FIELD_PREP(SPMMC_DMA_SOURCE, 0x1);\n\t\tsrcdst &= ~SPMMC_DMA_DESTINATION;\n\t\tsrcdst |= FIELD_PREP(SPMMC_DMA_DESTINATION, 0x2);\n\t\twritel(srcdst, host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n\t}\n\n\tvalue |= SPMMC_SD_LEN_MODE;\n\tif (host->dmapio_mode == SPMMC_DMA_MODE) {\n\t\tstruct scatterlist *sg;\n\t\tdma_addr_t dma_addr;\n\t\tunsigned int dma_size;\n\t\tint i, count = 1;\n\n\t\tcount = dma_map_sg(host->mmc->parent, data->sg, data->sg_len,\n\t\t\t\t   mmc_get_dma_dir(data));\n\t\tif (!count || count > SPMMC_MAX_DMA_MEMORY_SECTORS) {\n\t\t\tdata->error = -EINVAL;\n\n\t\t\treturn;\n\t\t}\n\t\tfor_each_sg(data->sg, sg, count, i) {\n\t\t\tdma_addr = sg_dma_address(sg);\n\t\t\tdma_size = sg_dma_len(sg) / data->blksz - 1;\n\t\t\tif (i == 0) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_DMA_BASE_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_0_SIZE_REG);\n\t\t\t} else if (i == 1) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_1_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_1_LENG_REG);\n\t\t\t} else if (i == 2) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_2_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_2_LENG_REG);\n\t\t\t} else if (i == 3) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_3_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_3_LENG_REG);\n\t\t\t} else if (i == 4) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_4_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_4_LENG_REG);\n\t\t\t} else if (i == 5) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_5_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_5_LENG_REG);\n\t\t\t} else if (i == 6) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_6_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_6_LENG_REG);\n\t\t\t} else if (i == 7) {\n\t\t\t\twritel(dma_addr, host->base + SPMMC_SDRAM_SECTOR_7_ADDR_REG);\n\t\t\t\twritel(dma_size, host->base + SPMMC_SDRAM_SECTOR_7_LENG_REG);\n\t\t\t}\n\t\t}\n\t\tvalue &= ~SPMMC_SD_PIO_MODE;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n\t\t \n\t\tif (data->blksz * data->blocks > host->dma_int_threshold) {\n\t\t\thost->dma_use_int = 1;\n\t\t\tvalue = readl(host->base + SPMMC_SD_INT_REG);\n\t\t\tvalue &= ~SPMMC_SDINT_SDCMPEN;\n\t\t\tvalue |= FIELD_PREP(SPMMC_SDINT_SDCMPEN, 1);  \n\t\t\twritel(value, host->base + SPMMC_SD_INT_REG);\n\t\t}\n\t} else {\n\t\tvalue |= SPMMC_SD_PIO_MODE;\n\t\tvalue |= SPMMC_RX4_EN;\n\t\twritel(value, host->base + SPMMC_SD_CONFIG0_REG);\n\t}\n}\n\nstatic inline void spmmc_trigger_transaction(struct spmmc_host *host)\n{\n\tu32 value = readl(host->base + SPMMC_SD_CTRL_REG);\n\n\tvalue |= SPMMC_NEW_COMMAND_TRIGGER;\n\twritel(value, host->base + SPMMC_SD_CTRL_REG);\n}\n\nstatic void spmmc_send_stop_cmd(struct spmmc_host *host)\n{\n\tstruct mmc_command stop = {};\n\tu32 value;\n\n\tstop.opcode = MMC_STOP_TRANSMISSION;\n\tstop.arg = 0;\n\tstop.flags = MMC_RSP_R1B;\n\tspmmc_prepare_cmd(host, &stop);\n\tvalue = readl(host->base + SPMMC_SD_INT_REG);\n\tvalue &= ~SPMMC_SDINT_SDCMPEN;\n\tvalue |= FIELD_PREP(SPMMC_SDINT_SDCMPEN, 0);\n\twritel(value, host->base + SPMMC_SD_INT_REG);\n\tspmmc_trigger_transaction(host);\n\treadl_poll_timeout(host->base + SPMMC_SD_STATE_REG, value,\n\t\t\t   (value & SPMMC_SDSTATE_FINISH), 1, SPMMC_TIMEOUT_US);\n}\n\nstatic int spmmc_check_error(struct spmmc_host *host, struct mmc_request *mrq)\n{\n\tint ret = 0;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\n\tu32 value = readl(host->base + SPMMC_SD_STATE_REG);\n\tu32 crc_token = FIELD_GET(SPMMC_CRCTOKEN_CHECK_RESULT, value);\n\n\tif (value & SPMMC_SDSTATE_ERROR) {\n\t\tu32 timing_cfg0 = 0;\n\n\t\tvalue = readl(host->base + SPMMC_SD_STATUS_REG);\n\n\t\tif (host->tuning_info.enable_tuning) {\n\t\t\ttiming_cfg0 = readl(host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\t\thost->tuning_info.rd_crc_dly = FIELD_GET(SPMMC_SD_READ_CRC_DELAY,\n\t\t\t\t\t\t\t\t timing_cfg0);\n\t\t\thost->tuning_info.rd_dat_dly = FIELD_GET(SPMMC_SD_READ_DATA_DELAY,\n\t\t\t\t\t\t\t\t timing_cfg0);\n\t\t\thost->tuning_info.rd_rsp_dly = FIELD_GET(SPMMC_SD_READ_RESPONSE_DELAY,\n\t\t\t\t\t\t\t\t timing_cfg0);\n\t\t\thost->tuning_info.wr_cmd_dly = FIELD_GET(SPMMC_SD_WRITE_COMMAND_DELAY,\n\t\t\t\t\t\t\t\t timing_cfg0);\n\t\t\thost->tuning_info.wr_dat_dly = FIELD_GET(SPMMC_SD_WRITE_DATA_DELAY,\n\t\t\t\t\t\t\t\t timing_cfg0);\n\t\t}\n\n\t\tif (value & SPMMC_SDSTATUS_RSP_TIMEOUT) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\thost->tuning_info.wr_cmd_dly++;\n\t\t} else if (value & SPMMC_SDSTATUS_RSP_CRC7_ERROR) {\n\t\t\tret = -EILSEQ;\n\t\t\thost->tuning_info.rd_rsp_dly++;\n\t\t} else if (data) {\n\t\t\tif ((value & SPMMC_SDSTATUS_STB_TIMEOUT)) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\thost->tuning_info.rd_dat_dly++;\n\t\t\t} else if (value & SPMMC_SDSTATUS_RDATA_CRC16_ERROR) {\n\t\t\t\tret = -EILSEQ;\n\t\t\t\thost->tuning_info.rd_dat_dly++;\n\t\t\t} else if (value & SPMMC_SDSTATUS_CARD_CRC_CHECK_TIMEOUT) {\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\t\thost->tuning_info.rd_crc_dly++;\n\t\t\t} else if (value & SPMMC_SDSTATUS_CRC_TOKEN_CHECK_ERROR) {\n\t\t\t\tret = -EILSEQ;\n\t\t\t\tif (crc_token == 0x5)\n\t\t\t\t\thost->tuning_info.wr_dat_dly++;\n\t\t\t\telse\n\t\t\t\t\thost->tuning_info.rd_crc_dly++;\n\t\t\t}\n\t\t}\n\t\tcmd->error = ret;\n\t\tif (data) {\n\t\t\tdata->error = ret;\n\t\t\tdata->bytes_xfered = 0;\n\t\t}\n\t\tif (!host->tuning_info.need_tuning && host->tuning_info.enable_tuning)\n\t\t\tcmd->retries = SPMMC_MAX_RETRIES;\n\t\tspmmc_sw_reset(host);\n\n\t\tif (host->tuning_info.enable_tuning) {\n\t\t\ttiming_cfg0 &= ~SPMMC_SD_READ_CRC_DELAY;\n\t\t\ttiming_cfg0 |= FIELD_PREP(SPMMC_SD_READ_CRC_DELAY,\n\t\t\t\t\t\t       host->tuning_info.rd_crc_dly);\n\t\t\ttiming_cfg0 &= ~SPMMC_SD_READ_DATA_DELAY;\n\t\t\ttiming_cfg0 |= FIELD_PREP(SPMMC_SD_READ_DATA_DELAY,\n\t\t\t\t\t\t       host->tuning_info.rd_dat_dly);\n\t\t\ttiming_cfg0 &= ~SPMMC_SD_READ_RESPONSE_DELAY;\n\t\t\ttiming_cfg0 |= FIELD_PREP(SPMMC_SD_READ_RESPONSE_DELAY,\n\t\t\t\t\t\t       host->tuning_info.rd_rsp_dly);\n\t\t\ttiming_cfg0 &= ~SPMMC_SD_WRITE_COMMAND_DELAY;\n\t\t\ttiming_cfg0 |= FIELD_PREP(SPMMC_SD_WRITE_COMMAND_DELAY,\n\t\t\t\t\t\t       host->tuning_info.wr_cmd_dly);\n\t\t\ttiming_cfg0 &= ~SPMMC_SD_WRITE_DATA_DELAY;\n\t\t\ttiming_cfg0 |= FIELD_PREP(SPMMC_SD_WRITE_DATA_DELAY,\n\t\t\t\t\t\t       host->tuning_info.wr_dat_dly);\n\t\t\twritel(timing_cfg0, host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\t}\n\t} else if (data) {\n\t\tdata->error = 0;\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t}\n\thost->tuning_info.need_tuning = ret;\n\n\treturn ret;\n}\n\n \nstatic inline int spmmc_find_best_delay(u8 candidate_dly)\n{\n\tint f, w, value;\n\n\tif (!candidate_dly)\n\t\treturn 0;\n\tf = ffs(candidate_dly) - 1;\n\tw = hweight8(candidate_dly);\n\tvalue = ((1 << w) - 1) << f;\n\tif (0xff == (value & ~candidate_dly))\n\t\treturn (f + w / 2);\n\telse\n\t\treturn (f);\n}\n\nstatic void spmmc_xfer_data_pio(struct spmmc_host *host, struct mmc_data *data)\n{\n\tu32 *buf;\n\tint data_left = data->blocks * data->blksz;\n\tint consumed, remain;\n\n\tstruct sg_mapping_iter sg_miter;\n\tunsigned int flags = 0;\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\tflags |= SG_MITER_FROM_SG;\n\telse\n\t\tflags |= SG_MITER_TO_SG;\n\tsg_miter_start(&sg_miter, data->sg, data->sg_len, flags);\n\twhile (data_left > 0) {\n\t\tconsumed = 0;\n\t\tif (!sg_miter_next(&sg_miter))\n\t\t\tbreak;\n\t\tbuf = sg_miter.addr;\n\t\tremain = sg_miter.length;\n\t\tdo {\n\t\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\t\tif (spmmc_wait_txbuf_empty(host))\n\t\t\t\t\tgoto done;\n\t\t\t\twritel(*buf, host->base + SPMMC_SD_PIODATATX_REG);\n\t\t\t} else {\n\t\t\t\tif (spmmc_wait_rxbuf_full(host))\n\t\t\t\t\tgoto done;\n\t\t\t\t*buf = readl(host->base + SPMMC_SD_PIODATARX_REG);\n\t\t\t}\n\t\t\tbuf++;\n\t\t\t \n\t\t\tconsumed += 4;\n\t\t\tremain -= 4;\n\t\t} while (remain);\n\t\tsg_miter.consumed = consumed;\n\t\tdata_left -= consumed;\n\t}\ndone:\n\tsg_miter_stop(&sg_miter);\n}\n\nstatic void spmmc_controller_init(struct spmmc_host *host)\n{\n\tu32 value;\n\tint ret = reset_control_assert(host->rstc);\n\n\tif (!ret) {\n\t\tusleep_range(1000, 1250);\n\t\tret = reset_control_deassert(host->rstc);\n\t}\n\n\tvalue = readl(host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n\tvalue &= ~SPMMC_MEDIA_TYPE;\n\tvalue |= FIELD_PREP(SPMMC_MEDIA_TYPE, SPMMC_MEDIA_SD);\n\twritel(value, host->base + SPMMC_CARD_MEDIATYPE_SRCDST_REG);\n}\n\n \nstatic void spmmc_finish_request(struct spmmc_host *host, struct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\n\tif (!mrq)\n\t\treturn;\n\n\tcmd = mrq->cmd;\n\tdata = mrq->data;\n\n\tif (data && SPMMC_DMA_MODE == host->dmapio_mode) {\n\t\tdma_unmap_sg(host->mmc->parent, data->sg, data->sg_len, mmc_get_dma_dir(data));\n\t\thost->dma_use_int = 0;\n\t}\n\n\tspmmc_get_rsp(host, cmd);\n\tspmmc_check_error(host, mrq);\n\tif (mrq->stop)\n\t\tspmmc_send_stop_cmd(host);\n\n\thost->mrq = NULL;\n\tmmc_request_done(host->mmc, mrq);\n}\n\n \nstatic irqreturn_t spmmc_irq(int irq, void *dev_id)\n{\n\tstruct spmmc_host *host = dev_id;\n\tu32 value = readl(host->base + SPMMC_SD_INT_REG);\n\n\tif ((value & SPMMC_SDINT_SDCMP) && (value & SPMMC_SDINT_SDCMPEN)) {\n\t\tvalue &= ~SPMMC_SDINT_SDCMPEN;\n\t\tvalue |= SPMMC_SDINT_SDCMPCLR;\n\t\twritel(value, host->base + SPMMC_SD_INT_REG);\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic void spmmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct spmmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data;\n\tstruct mmc_command *cmd;\n\n\thost->mrq = mrq;\n\tdata = mrq->data;\n\tcmd = mrq->cmd;\n\n\tspmmc_prepare_cmd(host, cmd);\n\t \n\tif (cmd->flags & MMC_RSP_136) {\n\t\tspmmc_trigger_transaction(host);\n\t\tspmmc_get_rsp(host, cmd);\n\t\tspmmc_wait_finish(host);\n\t\tspmmc_check_error(host, mrq);\n\t\thost->mrq = NULL;\n\t\tmmc_request_done(host->mmc, mrq);\n\t} else {\n\t\tif (data)\n\t\t\tspmmc_prepare_data(host, data);\n\n\t\tif (host->dmapio_mode == SPMMC_PIO_MODE && data) {\n\t\t\tu32 value;\n\t\t\t \n\t\t\tvalue = readl(host->base + SPMMC_SD_INT_REG);\n\t\t\tvalue &= ~SPMMC_SDINT_SDCMPEN;\n\t\t\twritel(value, host->base + SPMMC_SD_INT_REG);\n\t\t\tspmmc_trigger_transaction(host);\n\t\t\tspmmc_xfer_data_pio(host, data);\n\t\t\tspmmc_wait_finish(host);\n\t\t\tspmmc_finish_request(host, mrq);\n\t\t} else {\n\t\t\tif (host->dma_use_int) {\n\t\t\t\tspmmc_trigger_transaction(host);\n\t\t\t} else {\n\t\t\t\tspmmc_trigger_transaction(host);\n\t\t\t\tspmmc_wait_finish(host);\n\t\t\t\tspmmc_finish_request(host, mrq);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void spmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct spmmc_host *host = (struct spmmc_host *)mmc_priv(mmc);\n\n\tspmmc_set_bus_clk(host, ios->clock);\n\tspmmc_set_bus_timing(host, ios->timing);\n\tspmmc_set_bus_width(host, ios->bus_width);\n\t \n\tspmmc_set_sdmmc_mode(host);\n}\n\n \nstatic int spmmc_get_cd(struct mmc_host *mmc)\n{\n\tint ret = 0;\n\n\tif (mmc_can_gpio_cd(mmc))\n\t\tret = mmc_gpio_get_cd(mmc);\n\n\tif (ret < 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\nstatic int spmmc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct spmmc_host *host = mmc_priv(mmc);\n\tu8 smpl_dly = 0, candidate_dly = 0;\n\tu32 value;\n\n\thost->tuning_info.enable_tuning = 0;\n\tdo {\n\t\tvalue = readl(host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\tvalue &= ~SPMMC_SD_READ_RESPONSE_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_RESPONSE_DELAY, smpl_dly);\n\t\tvalue &= ~SPMMC_SD_READ_DATA_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_DATA_DELAY, smpl_dly);\n\t\tvalue &= ~SPMMC_SD_READ_CRC_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_CRC_DELAY, smpl_dly);\n\t\twritel(value, host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\n\t\tif (!mmc_send_tuning(mmc, opcode, NULL)) {\n\t\t\tcandidate_dly |= (1 << smpl_dly);\n\t\t\tbreak;\n\t\t}\n\t} while (smpl_dly++ <= SPMMC_MAX_TUNABLE_DLY);\n\thost->tuning_info.enable_tuning = 1;\n\n\tif (candidate_dly) {\n\t\tsmpl_dly = spmmc_find_best_delay(candidate_dly);\n\t\tvalue = readl(host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\tvalue &= ~SPMMC_SD_READ_RESPONSE_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_RESPONSE_DELAY, smpl_dly);\n\t\tvalue &= ~SPMMC_SD_READ_DATA_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_DATA_DELAY, smpl_dly);\n\t\tvalue &= ~SPMMC_SD_READ_CRC_DELAY;\n\t\tvalue |= FIELD_PREP(SPMMC_SD_READ_CRC_DELAY, smpl_dly);\n\t\twritel(value, host->base + SPMMC_SD_TIMING_CONFIG0_REG);\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\nstatic const struct mmc_host_ops spmmc_ops = {\n\t.request = spmmc_request,\n\t.set_ios = spmmc_set_ios,\n\t.get_cd = spmmc_get_cd,\n\t.execute_tuning = spmmc_execute_tuning,\n};\n\nstatic irqreturn_t spmmc_func_finish_req(int irq, void *dev_id)\n{\n\tstruct spmmc_host *host = dev_id;\n\n\tspmmc_finish_request(host, host->mrq);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int spmmc_drv_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct resource *res;\n\tstruct spmmc_host *host;\n\tint ret = 0;\n\n\tmmc = devm_mmc_alloc_host(&pdev->dev, sizeof(struct spmmc_host));\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->dmapio_mode = SPMMC_DMA_MODE;\n\thost->dma_int_threshold = 1024;\n\n\thost->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->base))\n\t\treturn PTR_ERR(host->base);\n\n\thost->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(host->clk), \"clk get fail\\n\");\n\n\thost->rstc = devm_reset_control_get_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(host->rstc))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(host->rstc), \"rst get fail\\n\");\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0)\n\t\treturn host->irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, host->irq,\n\t\t\t\t\tspmmc_irq, spmmc_func_finish_req, IRQF_SHARED,\n\t\t\tNULL, host);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret)\n\t\treturn dev_err_probe(&pdev->dev, ret, \"failed to enable clk\\n\");\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tmmc->ops = &spmmc_ops;\n\tmmc->f_min = SPMMC_MIN_CLK;\n\tif (mmc->f_max > SPMMC_MAX_CLK)\n\t\tmmc->f_max = SPMMC_MAX_CLK;\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto clk_disable;\n\n\tif (!mmc->ocr_avail)\n\t\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->max_seg_size = SPMMC_MAX_BLK_COUNT * 512;\n\tmmc->max_segs = SPMMC_MAX_DMA_MEMORY_SECTORS;\n\tmmc->max_req_size = SPMMC_MAX_BLK_COUNT * 512;\n\tmmc->max_blk_size = 512;\n\tmmc->max_blk_count = SPMMC_MAX_BLK_COUNT;\n\n\tdev_set_drvdata(&pdev->dev, host);\n\tspmmc_controller_init(host);\n\tspmmc_set_sdmmc_mode(host);\n\thost->tuning_info.enable_tuning = 1;\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto pm_disable;\n\n\treturn 0;\n\npm_disable:\n\tpm_runtime_disable(&pdev->dev);\n\nclk_disable:\n\tclk_disable_unprepare(host->clk);\n\treturn ret;\n}\n\nstatic void spmmc_drv_remove(struct platform_device *dev)\n{\n\tstruct spmmc_host *host = platform_get_drvdata(dev);\n\n\tmmc_remove_host(host->mmc);\n\tpm_runtime_get_sync(&dev->dev);\n\tclk_disable_unprepare(host->clk);\n\tpm_runtime_put_noidle(&dev->dev);\n\tpm_runtime_disable(&dev->dev);\n}\n\nstatic int spmmc_pm_runtime_suspend(struct device *dev)\n{\n\tstruct spmmc_host *host;\n\n\thost = dev_get_drvdata(dev);\n\tclk_disable_unprepare(host->clk);\n\n\treturn 0;\n}\n\nstatic int spmmc_pm_runtime_resume(struct device *dev)\n{\n\tstruct spmmc_host *host;\n\n\thost = dev_get_drvdata(dev);\n\n\treturn clk_prepare_enable(host->clk);\n}\n\nstatic DEFINE_RUNTIME_DEV_PM_OPS(spmmc_pm_ops, spmmc_pm_runtime_suspend,\n\t\t\t\t\t\t\tspmmc_pm_runtime_resume, NULL);\n\nstatic const struct of_device_id spmmc_of_table[] = {\n\t{\n\t\t.compatible = \"sunplus,sp7021-mmc\",\n\t},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, spmmc_of_table);\n\nstatic struct platform_driver spmmc_driver = {\n\t.probe = spmmc_drv_probe,\n\t.remove_new = spmmc_drv_remove,\n\t.driver = {\n\t\t.name = \"spmmc\",\n\t\t.pm = pm_ptr(&spmmc_pm_ops),\n\t\t.of_match_table = spmmc_of_table,\n\t},\n};\nmodule_platform_driver(spmmc_driver);\n\nMODULE_AUTHOR(\"Tony Huang <tonyhuang.sunplus@gmail.com>\");\nMODULE_AUTHOR(\"Li-hao Kuo <lhjeff911@gmail.com>\");\nMODULE_DESCRIPTION(\"Sunplus MMC controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}