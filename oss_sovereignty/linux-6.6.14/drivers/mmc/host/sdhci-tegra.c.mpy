{
  "module_name": "sdhci-tegra.c",
  "hash_id": "4ec8d7643845839060c346fd2e88029827612269b8ae532edd0ca508aee5e3e6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/ktime.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/pm_opp.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include <soc/tegra/common.h>\n\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pltfm.h\"\n#include \"cqhci.h\"\n\n \n#define SDHCI_TEGRA_VENDOR_CLOCK_CTRL\t\t\t0x100\n#define SDHCI_CLOCK_CTRL_TAP_MASK\t\t\t0x00ff0000\n#define SDHCI_CLOCK_CTRL_TAP_SHIFT\t\t\t16\n#define SDHCI_CLOCK_CTRL_TRIM_MASK\t\t\t0x1f000000\n#define SDHCI_CLOCK_CTRL_TRIM_SHIFT\t\t\t24\n#define SDHCI_CLOCK_CTRL_SDR50_TUNING_OVERRIDE\t\tBIT(5)\n#define SDHCI_CLOCK_CTRL_PADPIPE_CLKEN_OVERRIDE\t\tBIT(3)\n#define SDHCI_CLOCK_CTRL_SPI_MODE_CLKEN_OVERRIDE\tBIT(2)\n\n#define SDHCI_TEGRA_VENDOR_SYS_SW_CTRL\t\t\t0x104\n#define SDHCI_TEGRA_SYS_SW_CTRL_ENHANCED_STROBE\t\tBIT(31)\n\n#define SDHCI_TEGRA_VENDOR_CAP_OVERRIDES\t\t0x10c\n#define SDHCI_TEGRA_CAP_OVERRIDES_DQS_TRIM_MASK\t\t0x00003f00\n#define SDHCI_TEGRA_CAP_OVERRIDES_DQS_TRIM_SHIFT\t8\n\n#define SDHCI_TEGRA_VENDOR_MISC_CTRL\t\t\t0x120\n#define SDHCI_MISC_CTRL_ERASE_TIMEOUT_LIMIT\t\tBIT(0)\n#define SDHCI_MISC_CTRL_ENABLE_SDR104\t\t\t0x8\n#define SDHCI_MISC_CTRL_ENABLE_SDR50\t\t\t0x10\n#define SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300\t\t0x20\n#define SDHCI_MISC_CTRL_ENABLE_DDR50\t\t\t0x200\n\n#define SDHCI_TEGRA_VENDOR_DLLCAL_CFG\t\t\t0x1b0\n#define SDHCI_TEGRA_DLLCAL_CALIBRATE\t\t\tBIT(31)\n\n#define SDHCI_TEGRA_VENDOR_DLLCAL_STA\t\t\t0x1bc\n#define SDHCI_TEGRA_DLLCAL_STA_ACTIVE\t\t\tBIT(31)\n\n#define SDHCI_VNDR_TUN_CTRL0_0\t\t\t\t0x1c0\n#define SDHCI_VNDR_TUN_CTRL0_TUN_HW_TAP\t\t\t0x20000\n#define SDHCI_VNDR_TUN_CTRL0_START_TAP_VAL_MASK\t\t0x03fc0000\n#define SDHCI_VNDR_TUN_CTRL0_START_TAP_VAL_SHIFT\t18\n#define SDHCI_VNDR_TUN_CTRL0_MUL_M_MASK\t\t\t0x00001fc0\n#define SDHCI_VNDR_TUN_CTRL0_MUL_M_SHIFT\t\t6\n#define SDHCI_VNDR_TUN_CTRL0_TUN_ITER_MASK\t\t0x000e000\n#define SDHCI_VNDR_TUN_CTRL0_TUN_ITER_SHIFT\t\t13\n#define TRIES_128\t\t\t\t\t2\n#define TRIES_256\t\t\t\t\t4\n#define SDHCI_VNDR_TUN_CTRL0_TUN_WORD_SEL_MASK\t\t0x7\n\n#define SDHCI_TEGRA_VNDR_TUN_CTRL1_0\t\t\t0x1c4\n#define SDHCI_TEGRA_VNDR_TUN_STATUS0\t\t\t0x1C8\n#define SDHCI_TEGRA_VNDR_TUN_STATUS1\t\t\t0x1CC\n#define SDHCI_TEGRA_VNDR_TUN_STATUS1_TAP_MASK\t\t0xFF\n#define SDHCI_TEGRA_VNDR_TUN_STATUS1_END_TAP_SHIFT\t0x8\n#define TUNING_WORD_BIT_SIZE\t\t\t\t32\n\n#define SDHCI_TEGRA_AUTO_CAL_CONFIG\t\t\t0x1e4\n#define SDHCI_AUTO_CAL_START\t\t\t\tBIT(31)\n#define SDHCI_AUTO_CAL_ENABLE\t\t\t\tBIT(29)\n#define SDHCI_AUTO_CAL_PDPU_OFFSET_MASK\t\t\t0x0000ffff\n\n#define SDHCI_TEGRA_SDMEM_COMP_PADCTRL\t\t\t0x1e0\n#define SDHCI_TEGRA_SDMEM_COMP_PADCTRL_VREF_SEL_MASK\t0x0000000f\n#define SDHCI_TEGRA_SDMEM_COMP_PADCTRL_VREF_SEL_VAL\t0x7\n#define SDHCI_TEGRA_SDMEM_COMP_PADCTRL_E_INPUT_E_PWRD\tBIT(31)\n#define SDHCI_COMP_PADCTRL_DRVUPDN_OFFSET_MASK\t\t0x07FFF000\n\n#define SDHCI_TEGRA_AUTO_CAL_STATUS\t\t\t0x1ec\n#define SDHCI_TEGRA_AUTO_CAL_ACTIVE\t\t\tBIT(31)\n\n#define SDHCI_TEGRA_CIF2AXI_CTRL_0\t\t\t0x1fc\n\n#define NVQUIRK_FORCE_SDHCI_SPEC_200\t\t\tBIT(0)\n#define NVQUIRK_ENABLE_BLOCK_GAP_DET\t\t\tBIT(1)\n#define NVQUIRK_ENABLE_SDHCI_SPEC_300\t\t\tBIT(2)\n#define NVQUIRK_ENABLE_SDR50\t\t\t\tBIT(3)\n#define NVQUIRK_ENABLE_SDR104\t\t\t\tBIT(4)\n#define NVQUIRK_ENABLE_DDR50\t\t\t\tBIT(5)\n \n#define NVQUIRK_HAS_PADCALIB\t\t\t\tBIT(6)\n \n#define NVQUIRK_NEEDS_PAD_CONTROL\t\t\tBIT(7)\n#define NVQUIRK_DIS_CARD_CLK_CONFIG_TAP\t\t\tBIT(8)\n#define NVQUIRK_CQHCI_DCMD_R1B_CMD_TIMING\t\tBIT(9)\n\n \n#define NVQUIRK_HAS_TMCLK\t\t\t\tBIT(10)\n\n#define NVQUIRK_HAS_ANDROID_GPT_SECTOR\t\t\tBIT(11)\n#define NVQUIRK_PROGRAM_STREAMID\t\t\tBIT(12)\n\n \n#define SDHCI_TEGRA_CQE_BASE_ADDR\t\t\t0xF000\n\n#define SDHCI_TEGRA_CQE_TRNS_MODE\t(SDHCI_TRNS_MULTI | \\\n\t\t\t\t\t SDHCI_TRNS_BLK_CNT_EN | \\\n\t\t\t\t\t SDHCI_TRNS_DMA)\n\nstruct sdhci_tegra_soc_data {\n\tconst struct sdhci_pltfm_data *pdata;\n\tu64 dma_mask;\n\tu32 nvquirks;\n\tu8 min_tap_delay;\n\tu8 max_tap_delay;\n};\n\n \nstruct sdhci_tegra_autocal_offsets {\n\tu32 pull_up_3v3;\n\tu32 pull_down_3v3;\n\tu32 pull_up_3v3_timeout;\n\tu32 pull_down_3v3_timeout;\n\tu32 pull_up_1v8;\n\tu32 pull_down_1v8;\n\tu32 pull_up_1v8_timeout;\n\tu32 pull_down_1v8_timeout;\n\tu32 pull_up_sdr104;\n\tu32 pull_down_sdr104;\n\tu32 pull_up_hs400;\n\tu32 pull_down_hs400;\n};\n\nstruct sdhci_tegra {\n\tconst struct sdhci_tegra_soc_data *soc_data;\n\tstruct gpio_desc *power_gpio;\n\tstruct clk *tmclk;\n\tbool ddr_signaling;\n\tbool pad_calib_required;\n\tbool pad_control_available;\n\n\tstruct reset_control *rst;\n\tstruct pinctrl *pinctrl_sdmmc;\n\tstruct pinctrl_state *pinctrl_state_3v3;\n\tstruct pinctrl_state *pinctrl_state_1v8;\n\tstruct pinctrl_state *pinctrl_state_3v3_drv;\n\tstruct pinctrl_state *pinctrl_state_1v8_drv;\n\n\tstruct sdhci_tegra_autocal_offsets autocal_offsets;\n\tktime_t last_calib;\n\n\tu32 default_tap;\n\tu32 default_trim;\n\tu32 dqs_trim;\n\tbool enable_hwcq;\n\tunsigned long curr_clk_rate;\n\tu8 tuned_tap_delay;\n\tu32 stream_id;\n};\n\nstatic u16 tegra_sdhci_readw(struct sdhci_host *host, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\n\tif (unlikely((soc_data->nvquirks & NVQUIRK_FORCE_SDHCI_SPEC_200) &&\n\t\t\t(reg == SDHCI_HOST_VERSION))) {\n\t\t \n\t\treturn SDHCI_SPEC_200;\n\t}\n\n\treturn readw(host->ioaddr + reg);\n}\n\nstatic void tegra_sdhci_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\tswitch (reg) {\n\tcase SDHCI_TRANSFER_MODE:\n\t\t \n\t\tpltfm_host->xfer_mode_shadow = val;\n\t\treturn;\n\tcase SDHCI_COMMAND:\n\t\twritel((val << 16) | pltfm_host->xfer_mode_shadow,\n\t\t\thost->ioaddr + SDHCI_TRANSFER_MODE);\n\t\treturn;\n\t}\n\n\twritew(val, host->ioaddr + reg);\n}\n\nstatic void tegra_sdhci_writel(struct sdhci_host *host, u32 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\n\t \n\tif (unlikely(reg == SDHCI_SIGNAL_ENABLE))\n\t\tval &= ~(SDHCI_INT_TIMEOUT|SDHCI_INT_CRC);\n\n\twritel(val, host->ioaddr + reg);\n\n\tif (unlikely((soc_data->nvquirks & NVQUIRK_ENABLE_BLOCK_GAP_DET) &&\n\t\t\t(reg == SDHCI_INT_ENABLE))) {\n\t\t \n\t\tu8 gap_ctrl = readb(host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\n\t\tif (val & SDHCI_INT_CARD_INT)\n\t\t\tgap_ctrl |= 0x8;\n\t\telse\n\t\t\tgap_ctrl &= ~0x8;\n\t\twriteb(gap_ctrl, host->ioaddr + SDHCI_BLOCK_GAP_CONTROL);\n\t}\n}\n\nstatic bool tegra_sdhci_configure_card_clk(struct sdhci_host *host, bool enable)\n{\n\tbool status;\n\tu32 reg;\n\n\treg = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tstatus = !!(reg & SDHCI_CLOCK_CARD_EN);\n\n\tif (status == enable)\n\t\treturn status;\n\n\tif (enable)\n\t\treg |= SDHCI_CLOCK_CARD_EN;\n\telse\n\t\treg &= ~SDHCI_CLOCK_CARD_EN;\n\n\tsdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);\n\n\treturn status;\n}\n\nstatic void tegra210_sdhci_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tbool is_tuning_cmd = 0;\n\tbool clk_enabled;\n\n\tif (reg == SDHCI_COMMAND)\n\t\tis_tuning_cmd = mmc_op_tuning(SDHCI_GET_CMD(val));\n\n\tif (is_tuning_cmd)\n\t\tclk_enabled = tegra_sdhci_configure_card_clk(host, 0);\n\n\twritew(val, host->ioaddr + reg);\n\n\tif (is_tuning_cmd) {\n\t\tudelay(1);\n\t\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\t\ttegra_sdhci_configure_card_clk(host, clk_enabled);\n\t}\n}\n\nstatic unsigned int tegra_sdhci_get_ro(struct sdhci_host *host)\n{\n\t \n\treturn mmc_gpio_get_ro(host->mmc);\n}\n\nstatic bool tegra_sdhci_is_pad_and_regulator_valid(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tint has_1v8, has_3v3;\n\n\t \n\n\tif (!(tegra_host->soc_data->nvquirks & NVQUIRK_NEEDS_PAD_CONTROL))\n\t\treturn true;\n\n\tif (IS_ERR(host->mmc->supply.vqmmc))\n\t\treturn false;\n\n\thas_1v8 = regulator_is_supported_voltage(host->mmc->supply.vqmmc,\n\t\t\t\t\t\t 1700000, 1950000);\n\n\thas_3v3 = regulator_is_supported_voltage(host->mmc->supply.vqmmc,\n\t\t\t\t\t\t 2700000, 3600000);\n\n\tif (has_1v8 == 1 && has_3v3 == 1)\n\t\treturn tegra_host->pad_control_available;\n\n\t \n\treturn true;\n}\n\nstatic void tegra_sdhci_set_tap(struct sdhci_host *host, unsigned int tap)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\tbool card_clk_enabled = false;\n\tu32 reg;\n\n\t \n\n\tif (soc_data->nvquirks & NVQUIRK_DIS_CARD_CLK_CONFIG_TAP)\n\t\tcard_clk_enabled = tegra_sdhci_configure_card_clk(host, false);\n\n\treg = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\n\treg &= ~SDHCI_CLOCK_CTRL_TAP_MASK;\n\treg |= tap << SDHCI_CLOCK_CTRL_TAP_SHIFT;\n\tsdhci_writel(host, reg, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\n\n\tif (soc_data->nvquirks & NVQUIRK_DIS_CARD_CLK_CONFIG_TAP &&\n\t    card_clk_enabled) {\n\t\tudelay(1);\n\t\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\t\ttegra_sdhci_configure_card_clk(host, card_clk_enabled);\n\t}\n}\n\nstatic void tegra_sdhci_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\tu32 misc_ctrl, clk_ctrl, pad_ctrl;\n\n\tsdhci_and_cqhci_reset(host, mask);\n\n\tif (!(mask & SDHCI_RESET_ALL))\n\t\treturn;\n\n\ttegra_sdhci_set_tap(host, tegra_host->default_tap);\n\n\tmisc_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_MISC_CTRL);\n\tclk_ctrl = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\n\n\tmisc_ctrl &= ~(SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300 |\n\t\t       SDHCI_MISC_CTRL_ENABLE_SDR50 |\n\t\t       SDHCI_MISC_CTRL_ENABLE_DDR50 |\n\t\t       SDHCI_MISC_CTRL_ENABLE_SDR104);\n\n\tclk_ctrl &= ~(SDHCI_CLOCK_CTRL_TRIM_MASK |\n\t\t      SDHCI_CLOCK_CTRL_SPI_MODE_CLKEN_OVERRIDE);\n\n\tif (tegra_sdhci_is_pad_and_regulator_valid(host)) {\n\t\t \n\t\tif (soc_data->nvquirks & NVQUIRK_ENABLE_SDHCI_SPEC_300)\n\t\t\tmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDHCI_SPEC_300;\n\t\t \n\t\tif (soc_data->nvquirks & NVQUIRK_ENABLE_SDR50)\n\t\t\tmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR50;\n\t\tif (soc_data->nvquirks & NVQUIRK_ENABLE_DDR50)\n\t\t\tmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_DDR50;\n\t\tif (soc_data->nvquirks & NVQUIRK_ENABLE_SDR104)\n\t\t\tmisc_ctrl |= SDHCI_MISC_CTRL_ENABLE_SDR104;\n\t\tif (soc_data->nvquirks & NVQUIRK_ENABLE_SDR50)\n\t\t\tclk_ctrl |= SDHCI_CLOCK_CTRL_SDR50_TUNING_OVERRIDE;\n\t}\n\n\tclk_ctrl |= tegra_host->default_trim << SDHCI_CLOCK_CTRL_TRIM_SHIFT;\n\n\tsdhci_writel(host, misc_ctrl, SDHCI_TEGRA_VENDOR_MISC_CTRL);\n\tsdhci_writel(host, clk_ctrl, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\n\n\tif (soc_data->nvquirks & NVQUIRK_HAS_PADCALIB) {\n\t\tpad_ctrl = sdhci_readl(host, SDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\t\tpad_ctrl &= ~SDHCI_TEGRA_SDMEM_COMP_PADCTRL_VREF_SEL_MASK;\n\t\tpad_ctrl |= SDHCI_TEGRA_SDMEM_COMP_PADCTRL_VREF_SEL_VAL;\n\t\tsdhci_writel(host, pad_ctrl, SDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\n\t\ttegra_host->pad_calib_required = true;\n\t}\n\n\ttegra_host->ddr_signaling = false;\n}\n\nstatic void tegra_sdhci_configure_cal_pad(struct sdhci_host *host, bool enable)\n{\n\tu32 val;\n\n\t \n\tval = sdhci_readl(host, SDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\n\tif (enable)\n\t\tval |= SDHCI_TEGRA_SDMEM_COMP_PADCTRL_E_INPUT_E_PWRD;\n\telse\n\t\tval &= ~SDHCI_TEGRA_SDMEM_COMP_PADCTRL_E_INPUT_E_PWRD;\n\n\tsdhci_writel(host, val, SDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\n\tif (enable)\n\t\tusleep_range(1, 2);\n}\n\nstatic void tegra_sdhci_set_pad_autocal_offset(struct sdhci_host *host,\n\t\t\t\t\t       u16 pdpu)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n\treg &= ~SDHCI_AUTO_CAL_PDPU_OFFSET_MASK;\n\treg |= pdpu;\n\tsdhci_writel(host, reg, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n}\n\nstatic int tegra_sdhci_set_padctrl(struct sdhci_host *host, int voltage,\n\t\t\t\t   bool state_drvupdn)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct sdhci_tegra_autocal_offsets *offsets =\n\t\t\t\t\t\t&tegra_host->autocal_offsets;\n\tstruct pinctrl_state *pinctrl_drvupdn = NULL;\n\tint ret = 0;\n\tu8 drvup = 0, drvdn = 0;\n\tu32 reg;\n\n\tif (!state_drvupdn) {\n\t\t \n\t\tif (voltage == MMC_SIGNAL_VOLTAGE_180) {\n\t\t\tif (tegra_host->pinctrl_state_1v8_drv) {\n\t\t\t\tpinctrl_drvupdn =\n\t\t\t\t\ttegra_host->pinctrl_state_1v8_drv;\n\t\t\t} else {\n\t\t\t\tdrvup = offsets->pull_up_1v8_timeout;\n\t\t\t\tdrvdn = offsets->pull_down_1v8_timeout;\n\t\t\t}\n\t\t} else {\n\t\t\tif (tegra_host->pinctrl_state_3v3_drv) {\n\t\t\t\tpinctrl_drvupdn =\n\t\t\t\t\ttegra_host->pinctrl_state_3v3_drv;\n\t\t\t} else {\n\t\t\t\tdrvup = offsets->pull_up_3v3_timeout;\n\t\t\t\tdrvdn = offsets->pull_down_3v3_timeout;\n\t\t\t}\n\t\t}\n\n\t\tif (pinctrl_drvupdn != NULL) {\n\t\t\tret = pinctrl_select_state(tegra_host->pinctrl_sdmmc,\n\t\t\t\t\t\t\tpinctrl_drvupdn);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"failed pads drvupdn, ret: %d\\n\", ret);\n\t\t} else if ((drvup) || (drvdn)) {\n\t\t\treg = sdhci_readl(host,\n\t\t\t\t\tSDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\t\t\treg &= ~SDHCI_COMP_PADCTRL_DRVUPDN_OFFSET_MASK;\n\t\t\treg |= (drvup << 20) | (drvdn << 12);\n\t\t\tsdhci_writel(host, reg,\n\t\t\t\t\tSDHCI_TEGRA_SDMEM_COMP_PADCTRL);\n\t\t}\n\n\t} else {\n\t\t \n\t\tif (!tegra_host->pad_control_available)\n\t\t\treturn 0;\n\n\t\tif (voltage == MMC_SIGNAL_VOLTAGE_180) {\n\t\t\tret = pinctrl_select_state(tegra_host->pinctrl_sdmmc,\n\t\t\t\t\t\ttegra_host->pinctrl_state_1v8);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"setting 1.8V failed, ret: %d\\n\", ret);\n\t\t} else {\n\t\t\tret = pinctrl_select_state(tegra_host->pinctrl_sdmmc,\n\t\t\t\t\t\ttegra_host->pinctrl_state_3v3);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\t\"setting 3.3V failed, ret: %d\\n\", ret);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void tegra_sdhci_pad_autocalib(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct sdhci_tegra_autocal_offsets offsets =\n\t\t\ttegra_host->autocal_offsets;\n\tstruct mmc_ios *ios = &host->mmc->ios;\n\tbool card_clk_enabled;\n\tu16 pdpu;\n\tu32 reg;\n\tint ret;\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tpdpu = offsets.pull_down_sdr104 << 8 | offsets.pull_up_sdr104;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tpdpu = offsets.pull_down_hs400 << 8 | offsets.pull_up_hs400;\n\t\tbreak;\n\tdefault:\n\t\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)\n\t\t\tpdpu = offsets.pull_down_1v8 << 8 | offsets.pull_up_1v8;\n\t\telse\n\t\t\tpdpu = offsets.pull_down_3v3 << 8 | offsets.pull_up_3v3;\n\t}\n\n\t \n\ttegra_sdhci_set_pad_autocal_offset(host, pdpu);\n\n\tcard_clk_enabled = tegra_sdhci_configure_card_clk(host, false);\n\n\ttegra_sdhci_configure_cal_pad(host, true);\n\n\treg = sdhci_readl(host, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n\treg |= SDHCI_AUTO_CAL_ENABLE | SDHCI_AUTO_CAL_START;\n\tsdhci_writel(host, reg, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n\n\tusleep_range(1, 2);\n\t \n\tret = readl_poll_timeout(host->ioaddr + SDHCI_TEGRA_AUTO_CAL_STATUS,\n\t\t\t\t reg, !(reg & SDHCI_TEGRA_AUTO_CAL_ACTIVE),\n\t\t\t\t 1000, 10000);\n\n\ttegra_sdhci_configure_cal_pad(host, false);\n\n\ttegra_sdhci_configure_card_clk(host, card_clk_enabled);\n\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"Pad autocal timed out\\n\");\n\n\t\t \n\t\treg = sdhci_readl(host, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n\t\treg &= ~SDHCI_AUTO_CAL_ENABLE;\n\t\tsdhci_writel(host, reg, SDHCI_TEGRA_AUTO_CAL_CONFIG);\n\n\t\tret = tegra_sdhci_set_padctrl(host, ios->signal_voltage, false);\n\t\tif (ret < 0)\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"Setting drive strengths failed: %d\\n\", ret);\n\t}\n}\n\nstatic void tegra_sdhci_parse_pad_autocal_dt(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct sdhci_tegra_autocal_offsets *autocal =\n\t\t\t&tegra_host->autocal_offsets;\n\tint err;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-3v3\",\n\t\t\t&autocal->pull_up_3v3);\n\tif (err)\n\t\tautocal->pull_up_3v3 = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-3v3\",\n\t\t\t&autocal->pull_down_3v3);\n\tif (err)\n\t\tautocal->pull_down_3v3 = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-1v8\",\n\t\t\t&autocal->pull_up_1v8);\n\tif (err)\n\t\tautocal->pull_up_1v8 = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-1v8\",\n\t\t\t&autocal->pull_down_1v8);\n\tif (err)\n\t\tautocal->pull_down_1v8 = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-sdr104\",\n\t\t\t&autocal->pull_up_sdr104);\n\tif (err)\n\t\tautocal->pull_up_sdr104 = autocal->pull_up_1v8;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-sdr104\",\n\t\t\t&autocal->pull_down_sdr104);\n\tif (err)\n\t\tautocal->pull_down_sdr104 = autocal->pull_down_1v8;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-hs400\",\n\t\t\t&autocal->pull_up_hs400);\n\tif (err)\n\t\tautocal->pull_up_hs400 = autocal->pull_up_1v8;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-hs400\",\n\t\t\t&autocal->pull_down_hs400);\n\tif (err)\n\t\tautocal->pull_down_hs400 = autocal->pull_down_1v8;\n\n\t \n\tif (!(tegra_host->soc_data->nvquirks & NVQUIRK_NEEDS_PAD_CONTROL))\n\t\treturn;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-3v3-timeout\",\n\t\t\t&autocal->pull_up_3v3_timeout);\n\tif (err) {\n\t\tif (!IS_ERR(tegra_host->pinctrl_state_3v3) &&\n\t\t\t(tegra_host->pinctrl_state_3v3_drv == NULL))\n\t\t\tpr_warn(\"%s: Missing autocal timeout 3v3-pad drvs\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\tautocal->pull_up_3v3_timeout = 0;\n\t}\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-3v3-timeout\",\n\t\t\t&autocal->pull_down_3v3_timeout);\n\tif (err) {\n\t\tif (!IS_ERR(tegra_host->pinctrl_state_3v3) &&\n\t\t\t(tegra_host->pinctrl_state_3v3_drv == NULL))\n\t\t\tpr_warn(\"%s: Missing autocal timeout 3v3-pad drvs\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\tautocal->pull_down_3v3_timeout = 0;\n\t}\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-up-offset-1v8-timeout\",\n\t\t\t&autocal->pull_up_1v8_timeout);\n\tif (err) {\n\t\tif (!IS_ERR(tegra_host->pinctrl_state_1v8) &&\n\t\t\t(tegra_host->pinctrl_state_1v8_drv == NULL))\n\t\t\tpr_warn(\"%s: Missing autocal timeout 1v8-pad drvs\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\tautocal->pull_up_1v8_timeout = 0;\n\t}\n\n\terr = device_property_read_u32(mmc_dev(host->mmc),\n\t\t\t\"nvidia,pad-autocal-pull-down-offset-1v8-timeout\",\n\t\t\t&autocal->pull_down_1v8_timeout);\n\tif (err) {\n\t\tif (!IS_ERR(tegra_host->pinctrl_state_1v8) &&\n\t\t\t(tegra_host->pinctrl_state_1v8_drv == NULL))\n\t\t\tpr_warn(\"%s: Missing autocal timeout 1v8-pad drvs\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\tautocal->pull_down_1v8_timeout = 0;\n\t}\n}\n\nstatic void tegra_sdhci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tktime_t since_calib = ktime_sub(ktime_get(), tegra_host->last_calib);\n\n\t \n\tif (ktime_to_ms(since_calib) > 100) {\n\t\ttegra_sdhci_pad_autocalib(host);\n\t\ttegra_host->last_calib = ktime_get();\n\t}\n\n\tsdhci_request(mmc, mrq);\n}\n\nstatic void tegra_sdhci_parse_tap_and_trim(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tint err;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc), \"nvidia,default-tap\",\n\t\t\t\t       &tegra_host->default_tap);\n\tif (err)\n\t\ttegra_host->default_tap = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc), \"nvidia,default-trim\",\n\t\t\t\t       &tegra_host->default_trim);\n\tif (err)\n\t\ttegra_host->default_trim = 0;\n\n\terr = device_property_read_u32(mmc_dev(host->mmc), \"nvidia,dqs-trim\",\n\t\t\t\t       &tegra_host->dqs_trim);\n\tif (err)\n\t\ttegra_host->dqs_trim = 0x11;\n}\n\nstatic void tegra_sdhci_parse_dt(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (device_property_read_bool(mmc_dev(host->mmc), \"supports-cqe\"))\n\t\ttegra_host->enable_hwcq = true;\n\telse\n\t\ttegra_host->enable_hwcq = false;\n\n\ttegra_sdhci_parse_pad_autocal_dt(host);\n\ttegra_sdhci_parse_tap_and_trim(host);\n}\n\nstatic void tegra_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct device *dev = mmc_dev(host->mmc);\n\tunsigned long host_clk;\n\tint err;\n\n\tif (!clock)\n\t\treturn sdhci_set_clock(host, clock);\n\n\t \n\thost_clk = tegra_host->ddr_signaling ? clock * 2 : clock;\n\n\terr = dev_pm_opp_set_rate(dev, host_clk);\n\tif (err)\n\t\tdev_err(dev, \"failed to set clk rate to %luHz: %d\\n\",\n\t\t\thost_clk, err);\n\n\ttegra_host->curr_clk_rate = clk_get_rate(pltfm_host->clk);\n\tif (tegra_host->ddr_signaling)\n\t\thost->max_clk = host_clk;\n\telse\n\t\thost->max_clk = clk_get_rate(pltfm_host->clk);\n\n\tsdhci_set_clock(host, clock);\n\n\tif (tegra_host->pad_calib_required) {\n\t\ttegra_sdhci_pad_autocalib(host);\n\t\ttegra_host->pad_calib_required = false;\n\t}\n}\n\nstatic void tegra_sdhci_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\t      struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 val;\n\n\tval = sdhci_readl(host, SDHCI_TEGRA_VENDOR_SYS_SW_CTRL);\n\n\tif (ios->enhanced_strobe) {\n\t\tval |= SDHCI_TEGRA_SYS_SW_CTRL_ENHANCED_STROBE;\n\t\t \n\t\ttegra_sdhci_set_clock(host, MMC_HS200_MAX_DTR);\n\t} else {\n\t\tval &= ~SDHCI_TEGRA_SYS_SW_CTRL_ENHANCED_STROBE;\n\t}\n\n\tsdhci_writel(host, val, SDHCI_TEGRA_VENDOR_SYS_SW_CTRL);\n}\n\nstatic unsigned int tegra_sdhci_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn clk_round_rate(pltfm_host->clk, UINT_MAX);\n}\n\nstatic void tegra_sdhci_set_dqs_trim(struct sdhci_host *host, u8 trim)\n{\n\tu32 val;\n\n\tval = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CAP_OVERRIDES);\n\tval &= ~SDHCI_TEGRA_CAP_OVERRIDES_DQS_TRIM_MASK;\n\tval |= trim << SDHCI_TEGRA_CAP_OVERRIDES_DQS_TRIM_SHIFT;\n\tsdhci_writel(host, val, SDHCI_TEGRA_VENDOR_CAP_OVERRIDES);\n}\n\nstatic void tegra_sdhci_hs400_dll_cal(struct sdhci_host *host)\n{\n\tu32 reg;\n\tint err;\n\n\treg = sdhci_readl(host, SDHCI_TEGRA_VENDOR_DLLCAL_CFG);\n\treg |= SDHCI_TEGRA_DLLCAL_CALIBRATE;\n\tsdhci_writel(host, reg, SDHCI_TEGRA_VENDOR_DLLCAL_CFG);\n\n\t \n\terr = readl_poll_timeout(host->ioaddr + SDHCI_TEGRA_VENDOR_DLLCAL_STA,\n\t\t\t\t reg, !(reg & SDHCI_TEGRA_DLLCAL_STA_ACTIVE),\n\t\t\t\t 1000, 5000);\n\tif (err)\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"HS400 delay line calibration timed out\\n\");\n}\n\nstatic void tegra_sdhci_tap_correction(struct sdhci_host *host, u8 thd_up,\n\t\t\t\t       u8 thd_low, u8 fixed_tap)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 val, tun_status;\n\tu8 word, bit, edge1, tap, window;\n\tbool tap_result;\n\tbool start_fail = false;\n\tbool start_pass = false;\n\tbool end_pass = false;\n\tbool first_fail = false;\n\tbool first_pass = false;\n\tu8 start_pass_tap = 0;\n\tu8 end_pass_tap = 0;\n\tu8 first_fail_tap = 0;\n\tu8 first_pass_tap = 0;\n\tu8 total_tuning_words = host->tuning_loop_count / TUNING_WORD_BIT_SIZE;\n\n\t \n\tfor (word = 0; word < total_tuning_words; word++) {\n\t\tval = sdhci_readl(host, SDHCI_VNDR_TUN_CTRL0_0);\n\t\tval &= ~SDHCI_VNDR_TUN_CTRL0_TUN_WORD_SEL_MASK;\n\t\tval |= word;\n\t\tsdhci_writel(host, val, SDHCI_VNDR_TUN_CTRL0_0);\n\t\ttun_status = sdhci_readl(host, SDHCI_TEGRA_VNDR_TUN_STATUS0);\n\t\tbit = 0;\n\t\twhile (bit < TUNING_WORD_BIT_SIZE) {\n\t\t\ttap = word * TUNING_WORD_BIT_SIZE + bit;\n\t\t\ttap_result = tun_status & (1 << bit);\n\t\t\tif (!tap_result && !start_fail) {\n\t\t\t\tstart_fail = true;\n\t\t\t\tif (!first_fail) {\n\t\t\t\t\tfirst_fail_tap = tap;\n\t\t\t\t\tfirst_fail = true;\n\t\t\t\t}\n\n\t\t\t} else if (tap_result && start_fail && !start_pass) {\n\t\t\t\tstart_pass_tap = tap;\n\t\t\t\tstart_pass = true;\n\t\t\t\tif (!first_pass) {\n\t\t\t\t\tfirst_pass_tap = tap;\n\t\t\t\t\tfirst_pass = true;\n\t\t\t\t}\n\n\t\t\t} else if (!tap_result && start_fail && start_pass &&\n\t\t\t\t   !end_pass) {\n\t\t\t\tend_pass_tap = tap - 1;\n\t\t\t\tend_pass = true;\n\t\t\t} else if (tap_result && start_pass && start_fail &&\n\t\t\t\t   end_pass) {\n\t\t\t\twindow = end_pass_tap - start_pass_tap;\n\t\t\t\t \n\t\t\t\tif (window >= thd_up || window < thd_low) {\n\t\t\t\t\tstart_pass_tap = tap;\n\t\t\t\t\tend_pass = false;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\ttap = start_pass_tap + window / 2;\n\t\t\t\t\ttegra_host->tuned_tap_delay = tap;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbit++;\n\t\t}\n\t}\n\n\tif (!first_fail) {\n\t\tWARN(1, \"no edge detected, continue with hw tuned delay.\\n\");\n\t} else if (first_pass) {\n\t\t \n\t\tedge1 = first_fail_tap + (first_pass_tap - first_fail_tap) / 2;\n\t\tif (edge1 - 1 > fixed_tap)\n\t\t\ttegra_host->tuned_tap_delay = edge1 - fixed_tap;\n\t\telse\n\t\t\ttegra_host->tuned_tap_delay = edge1 + fixed_tap;\n\t}\n}\n\nstatic void tegra_sdhci_post_tuning(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\tu32 avg_tap_dly, val, min_tap_dly, max_tap_dly;\n\tu8 fixed_tap, start_tap, end_tap, window_width;\n\tu8 thdupper, thdlower;\n\tu8 num_iter;\n\tu32 clk_rate_mhz, period_ps, bestcase, worstcase;\n\n\t \n\tval = sdhci_readl(host, SDHCI_TEGRA_VENDOR_CLOCK_CTRL);\n\ttegra_host->tuned_tap_delay = (val & SDHCI_CLOCK_CTRL_TAP_MASK) >>\n\t\t\t\t      SDHCI_CLOCK_CTRL_TAP_SHIFT;\n\tif (soc_data->min_tap_delay && soc_data->max_tap_delay) {\n\t\tmin_tap_dly = soc_data->min_tap_delay;\n\t\tmax_tap_dly = soc_data->max_tap_delay;\n\t\tclk_rate_mhz = tegra_host->curr_clk_rate / USEC_PER_SEC;\n\t\tperiod_ps = USEC_PER_SEC / clk_rate_mhz;\n\t\tbestcase = period_ps / min_tap_dly;\n\t\tworstcase = period_ps / max_tap_dly;\n\t\t \n\t\tthdupper = (2 * worstcase + bestcase) / 2;\n\t\tthdlower = worstcase / 4;\n\t\t \n\t\tavg_tap_dly = (period_ps * 2) / (min_tap_dly + max_tap_dly);\n\t\tfixed_tap = avg_tap_dly / 2;\n\n\t\tval = sdhci_readl(host, SDHCI_TEGRA_VNDR_TUN_STATUS1);\n\t\tstart_tap = val & SDHCI_TEGRA_VNDR_TUN_STATUS1_TAP_MASK;\n\t\tend_tap = (val >> SDHCI_TEGRA_VNDR_TUN_STATUS1_END_TAP_SHIFT) &\n\t\t\t  SDHCI_TEGRA_VNDR_TUN_STATUS1_TAP_MASK;\n\t\twindow_width = end_tap - start_tap;\n\t\tnum_iter = host->tuning_loop_count;\n\t\t \n\t\tif (start_tap == 0 || (end_tap == (num_iter - 1)) ||\n\t\t    (end_tap == num_iter - 2) || window_width >= thdupper) {\n\t\t\tpr_debug(\"%s: Apply tuning correction\\n\",\n\t\t\t\t mmc_hostname(host->mmc));\n\t\t\ttegra_sdhci_tap_correction(host, thdupper, thdlower,\n\t\t\t\t\t\t   fixed_tap);\n\t\t}\n\t}\n\n\ttegra_sdhci_set_tap(host, tegra_host->tuned_tap_delay);\n}\n\nstatic int tegra_sdhci_execute_hw_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tint err;\n\n\terr = sdhci_execute_tuning(mmc, opcode);\n\tif (!err && !host->tuning_err)\n\t\ttegra_sdhci_post_tuning(host);\n\n\treturn err;\n}\n\nstatic void tegra_sdhci_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t  unsigned timing)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tbool set_default_tap = false;\n\tbool set_dqs_trim = false;\n\tbool do_hs400_dll_cal = false;\n\tu8 iter = TRIES_256;\n\tu32 val;\n\n\ttegra_host->ddr_signaling = false;\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_MMC_HS200:\n\t\t \n\t\titer = TRIES_128;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tset_dqs_trim = true;\n\t\tdo_hs400_dll_cal = true;\n\t\titer = TRIES_128;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\ttegra_host->ddr_signaling = true;\n\t\tset_default_tap = true;\n\t\tbreak;\n\tdefault:\n\t\tset_default_tap = true;\n\t\tbreak;\n\t}\n\n\tval = sdhci_readl(host, SDHCI_VNDR_TUN_CTRL0_0);\n\tval &= ~(SDHCI_VNDR_TUN_CTRL0_TUN_ITER_MASK |\n\t\t SDHCI_VNDR_TUN_CTRL0_START_TAP_VAL_MASK |\n\t\t SDHCI_VNDR_TUN_CTRL0_MUL_M_MASK);\n\tval |= (iter << SDHCI_VNDR_TUN_CTRL0_TUN_ITER_SHIFT |\n\t\t0 << SDHCI_VNDR_TUN_CTRL0_START_TAP_VAL_SHIFT |\n\t\t1 << SDHCI_VNDR_TUN_CTRL0_MUL_M_SHIFT);\n\tsdhci_writel(host, val, SDHCI_VNDR_TUN_CTRL0_0);\n\tsdhci_writel(host, 0, SDHCI_TEGRA_VNDR_TUN_CTRL1_0);\n\n\thost->tuning_loop_count = (iter == TRIES_128) ? 128 : 256;\n\n\tsdhci_set_uhs_signaling(host, timing);\n\n\ttegra_sdhci_pad_autocalib(host);\n\n\tif (tegra_host->tuned_tap_delay && !set_default_tap)\n\t\ttegra_sdhci_set_tap(host, tegra_host->tuned_tap_delay);\n\telse\n\t\ttegra_sdhci_set_tap(host, tegra_host->default_tap);\n\n\tif (set_dqs_trim)\n\t\ttegra_sdhci_set_dqs_trim(host, tegra_host->dqs_trim);\n\n\tif (do_hs400_dll_cal)\n\t\ttegra_sdhci_hs400_dll_cal(host);\n}\n\nstatic int tegra_sdhci_execute_tuning(struct sdhci_host *host, u32 opcode)\n{\n\tunsigned int min, max;\n\n\t \n\tmin = 10;\n\twhile (min < 255) {\n\t\ttegra_sdhci_set_tap(host, min);\n\t\tif (!mmc_send_tuning(host->mmc, opcode, NULL))\n\t\t\tbreak;\n\t\tmin++;\n\t}\n\n\t \n\tmax = min + 1;\n\twhile (max < 255) {\n\t\ttegra_sdhci_set_tap(host, max);\n\t\tif (mmc_send_tuning(host->mmc, opcode, NULL)) {\n\t\t\tmax--;\n\t\t\tbreak;\n\t\t}\n\t\tmax++;\n\t}\n\n\t \n\ttegra_sdhci_set_tap(host, min + ((max - min) * 3 / 4));\n\n\treturn mmc_send_tuning(host->mmc, opcode, NULL);\n}\n\nstatic int sdhci_tegra_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t\t   struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tint ret = 0;\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\tret = tegra_sdhci_set_padctrl(host, ios->signal_voltage, true);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = sdhci_start_signal_voltage_switch(mmc, ios);\n\t} else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) {\n\t\tret = sdhci_start_signal_voltage_switch(mmc, ios);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = tegra_sdhci_set_padctrl(host, ios->signal_voltage, true);\n\t}\n\n\tif (tegra_host->pad_calib_required)\n\t\ttegra_sdhci_pad_autocalib(host);\n\n\treturn ret;\n}\n\nstatic int tegra_sdhci_init_pinctrl_info(struct device *dev,\n\t\t\t\t\t struct sdhci_tegra *tegra_host)\n{\n\ttegra_host->pinctrl_sdmmc = devm_pinctrl_get(dev);\n\tif (IS_ERR(tegra_host->pinctrl_sdmmc)) {\n\t\tdev_dbg(dev, \"No pinctrl info, err: %ld\\n\",\n\t\t\tPTR_ERR(tegra_host->pinctrl_sdmmc));\n\t\treturn -1;\n\t}\n\n\ttegra_host->pinctrl_state_1v8_drv = pinctrl_lookup_state(\n\t\t\t\ttegra_host->pinctrl_sdmmc, \"sdmmc-1v8-drv\");\n\tif (IS_ERR(tegra_host->pinctrl_state_1v8_drv)) {\n\t\tif (PTR_ERR(tegra_host->pinctrl_state_1v8_drv) == -ENODEV)\n\t\t\ttegra_host->pinctrl_state_1v8_drv = NULL;\n\t}\n\n\ttegra_host->pinctrl_state_3v3_drv = pinctrl_lookup_state(\n\t\t\t\ttegra_host->pinctrl_sdmmc, \"sdmmc-3v3-drv\");\n\tif (IS_ERR(tegra_host->pinctrl_state_3v3_drv)) {\n\t\tif (PTR_ERR(tegra_host->pinctrl_state_3v3_drv) == -ENODEV)\n\t\t\ttegra_host->pinctrl_state_3v3_drv = NULL;\n\t}\n\n\ttegra_host->pinctrl_state_3v3 =\n\t\tpinctrl_lookup_state(tegra_host->pinctrl_sdmmc, \"sdmmc-3v3\");\n\tif (IS_ERR(tegra_host->pinctrl_state_3v3)) {\n\t\tdev_warn(dev, \"Missing 3.3V pad state, err: %ld\\n\",\n\t\t\t PTR_ERR(tegra_host->pinctrl_state_3v3));\n\t\treturn -1;\n\t}\n\n\ttegra_host->pinctrl_state_1v8 =\n\t\tpinctrl_lookup_state(tegra_host->pinctrl_sdmmc, \"sdmmc-1v8\");\n\tif (IS_ERR(tegra_host->pinctrl_state_1v8)) {\n\t\tdev_warn(dev, \"Missing 1.8V pad state, err: %ld\\n\",\n\t\t\t PTR_ERR(tegra_host->pinctrl_state_1v8));\n\t\treturn -1;\n\t}\n\n\ttegra_host->pad_control_available = true;\n\n\treturn 0;\n}\n\nstatic void tegra_sdhci_voltage_switch(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\n\tif (soc_data->nvquirks & NVQUIRK_HAS_PADCALIB)\n\t\ttegra_host->pad_calib_required = true;\n}\n\nstatic void tegra_cqhci_writel(struct cqhci_host *cq_host, u32 val, int reg)\n{\n\tstruct mmc_host *mmc = cq_host->mmc;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu8 ctrl;\n\tktime_t timeout;\n\tbool timed_out;\n\n\t \n\tif (reg == CQHCI_CTL && !(val & CQHCI_HALT) &&\n\t    cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_HALT) {\n\t\tsdhci_writew(host, SDHCI_TEGRA_CQE_TRNS_MODE, SDHCI_TRANSFER_MODE);\n\t\tsdhci_cqe_enable(mmc);\n\t\twritel(val, cq_host->mmio + reg);\n\t\ttimeout = ktime_add_us(ktime_get(), 50);\n\t\twhile (1) {\n\t\t\ttimed_out = ktime_compare(ktime_get(), timeout) > 0;\n\t\t\tctrl = cqhci_readl(cq_host, CQHCI_CTL);\n\t\t\tif (!(ctrl & CQHCI_HALT) || timed_out)\n\t\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (timed_out)\n\t\t\twritel(val, cq_host->mmio + reg);\n\t} else {\n\t\twritel(val, cq_host->mmio + reg);\n\t}\n}\n\nstatic void sdhci_tegra_update_dcmd_desc(struct mmc_host *mmc,\n\t\t\t\t\t struct mmc_request *mrq, u64 *data)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(mmc_priv(mmc));\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tconst struct sdhci_tegra_soc_data *soc_data = tegra_host->soc_data;\n\n\tif (soc_data->nvquirks & NVQUIRK_CQHCI_DCMD_R1B_CMD_TIMING &&\n\t    mrq->cmd->flags & MMC_RSP_R1B)\n\t\t*data |= CQHCI_CMD_TIMING(1);\n}\n\nstatic void sdhci_tegra_cqe_enable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 val;\n\n\t \n\tif (!cq_host->activated) {\n\t\tval = cqhci_readl(cq_host, CQHCI_CFG);\n\t\tif (val & CQHCI_ENABLE)\n\t\t\tcqhci_writel(cq_host, (val & ~CQHCI_ENABLE),\n\t\t\t\t     CQHCI_CFG);\n\t\tsdhci_writew(host, SDHCI_TEGRA_CQE_TRNS_MODE, SDHCI_TRANSFER_MODE);\n\t\tsdhci_cqe_enable(mmc);\n\t\tif (val & CQHCI_ENABLE)\n\t\t\tcqhci_writel(cq_host, val, CQHCI_CFG);\n\t}\n\n\t \n\tval = cqhci_readl(cq_host, CQHCI_SSC1);\n\tval &= ~CQHCI_SSC1_CBC_MASK;\n\tcqhci_writel(cq_host, val, CQHCI_SSC1);\n}\n\nstatic void sdhci_tegra_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\nstatic u32 sdhci_tegra_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\nstatic void tegra_sdhci_set_timeout(struct sdhci_host *host,\n\t\t\t\t    struct mmc_command *cmd)\n{\n\tu32 val;\n\n\t \n\tval = sdhci_readl(host, SDHCI_TEGRA_VENDOR_MISC_CTRL);\n\tif (cmd && cmd->busy_timeout >= 11 * MSEC_PER_SEC)\n\t\tval |= SDHCI_MISC_CTRL_ERASE_TIMEOUT_LIMIT;\n\telse\n\t\tval &= ~SDHCI_MISC_CTRL_ERASE_TIMEOUT_LIMIT;\n\tsdhci_writel(host, val, SDHCI_TEGRA_VENDOR_MISC_CTRL);\n\n\t__sdhci_set_timeout(host, cmd);\n}\n\nstatic void sdhci_tegra_cqe_pre_enable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu32 reg;\n\n\treg = cqhci_readl(cq_host, CQHCI_CFG);\n\treg |= CQHCI_ENABLE;\n\tcqhci_writel(cq_host, reg, CQHCI_CFG);\n}\n\nstatic void sdhci_tegra_cqe_post_disable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 reg;\n\n\treg = cqhci_readl(cq_host, CQHCI_CFG);\n\treg &= ~CQHCI_ENABLE;\n\tcqhci_writel(cq_host, reg, CQHCI_CFG);\n\tsdhci_writew(host, 0x0, SDHCI_TRANSFER_MODE);\n}\n\nstatic const struct cqhci_host_ops sdhci_tegra_cqhci_ops = {\n\t.write_l    = tegra_cqhci_writel,\n\t.enable\t= sdhci_tegra_cqe_enable,\n\t.disable = sdhci_cqe_disable,\n\t.dumpregs = sdhci_tegra_dumpregs,\n\t.update_dcmd_desc = sdhci_tegra_update_dcmd_desc,\n\t.pre_enable = sdhci_tegra_cqe_pre_enable,\n\t.post_disable = sdhci_tegra_cqe_post_disable,\n};\n\nstatic int tegra_sdhci_set_dma_mask(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *platform = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra = sdhci_pltfm_priv(platform);\n\tconst struct sdhci_tegra_soc_data *soc = tegra->soc_data;\n\tstruct device *dev = mmc_dev(host->mmc);\n\n\tif (soc->dma_mask)\n\t\treturn dma_set_mask_and_coherent(dev, soc->dma_mask);\n\n\treturn 0;\n}\n\nstatic const struct sdhci_ops tegra_sdhci_ops = {\n\t.get_ro     = tegra_sdhci_get_ro,\n\t.read_w     = tegra_sdhci_readw,\n\t.write_l    = tegra_sdhci_writel,\n\t.set_clock  = tegra_sdhci_set_clock,\n\t.set_dma_mask = tegra_sdhci_set_dma_mask,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset      = tegra_sdhci_reset,\n\t.platform_execute_tuning = tegra_sdhci_execute_tuning,\n\t.set_uhs_signaling = tegra_sdhci_set_uhs_signaling,\n\t.voltage_switch = tegra_sdhci_voltage_switch,\n\t.get_max_clock = tegra_sdhci_get_max_clock,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra20_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.ops  = &tegra_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra20 = {\n\t.pdata = &sdhci_tegra20_pdata,\n\t.dma_mask = DMA_BIT_MASK(32),\n\t.nvquirks = NVQUIRK_FORCE_SDHCI_SPEC_200 |\n\t\t    NVQUIRK_HAS_ANDROID_GPT_SECTOR |\n\t\t    NVQUIRK_ENABLE_BLOCK_GAP_DET,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra30_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_BROKEN_HS200 |\n\t\t    \n\t\t   SDHCI_QUIRK2_ACMD23_BROKEN,\n\t.ops  = &tegra_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra30 = {\n\t.pdata = &sdhci_tegra30_pdata,\n\t.dma_mask = DMA_BIT_MASK(32),\n\t.nvquirks = NVQUIRK_ENABLE_SDHCI_SPEC_300 |\n\t\t    NVQUIRK_ENABLE_SDR50 |\n\t\t    NVQUIRK_ENABLE_SDR104 |\n\t\t    NVQUIRK_HAS_ANDROID_GPT_SECTOR |\n\t\t    NVQUIRK_HAS_PADCALIB,\n};\n\nstatic const struct sdhci_ops tegra114_sdhci_ops = {\n\t.get_ro     = tegra_sdhci_get_ro,\n\t.read_w     = tegra_sdhci_readw,\n\t.write_w    = tegra_sdhci_writew,\n\t.write_l    = tegra_sdhci_writel,\n\t.set_clock  = tegra_sdhci_set_clock,\n\t.set_dma_mask = tegra_sdhci_set_dma_mask,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset      = tegra_sdhci_reset,\n\t.platform_execute_tuning = tegra_sdhci_execute_tuning,\n\t.set_uhs_signaling = tegra_sdhci_set_uhs_signaling,\n\t.voltage_switch = tegra_sdhci_voltage_switch,\n\t.get_max_clock = tegra_sdhci_get_max_clock,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra114_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops  = &tegra114_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra114 = {\n\t.pdata = &sdhci_tegra114_pdata,\n\t.dma_mask = DMA_BIT_MASK(32),\n\t.nvquirks = NVQUIRK_HAS_ANDROID_GPT_SECTOR,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra124_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops  = &tegra114_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra124 = {\n\t.pdata = &sdhci_tegra124_pdata,\n\t.dma_mask = DMA_BIT_MASK(34),\n\t.nvquirks = NVQUIRK_HAS_ANDROID_GPT_SECTOR,\n};\n\nstatic const struct sdhci_ops tegra210_sdhci_ops = {\n\t.get_ro     = tegra_sdhci_get_ro,\n\t.read_w     = tegra_sdhci_readw,\n\t.write_w    = tegra210_sdhci_writew,\n\t.write_l    = tegra_sdhci_writel,\n\t.set_clock  = tegra_sdhci_set_clock,\n\t.set_dma_mask = tegra_sdhci_set_dma_mask,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset      = tegra_sdhci_reset,\n\t.set_uhs_signaling = tegra_sdhci_set_uhs_signaling,\n\t.voltage_switch = tegra_sdhci_voltage_switch,\n\t.get_max_clock = tegra_sdhci_get_max_clock,\n\t.set_timeout = tegra_sdhci_set_timeout,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra210_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops  = &tegra210_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra210 = {\n\t.pdata = &sdhci_tegra210_pdata,\n\t.dma_mask = DMA_BIT_MASK(34),\n\t.nvquirks = NVQUIRK_NEEDS_PAD_CONTROL |\n\t\t    NVQUIRK_HAS_PADCALIB |\n\t\t    NVQUIRK_DIS_CARD_CLK_CONFIG_TAP |\n\t\t    NVQUIRK_ENABLE_SDR50 |\n\t\t    NVQUIRK_ENABLE_SDR104 |\n\t\t    NVQUIRK_HAS_TMCLK,\n\t.min_tap_delay = 106,\n\t.max_tap_delay = 185,\n};\n\nstatic const struct sdhci_ops tegra186_sdhci_ops = {\n\t.get_ro     = tegra_sdhci_get_ro,\n\t.read_w     = tegra_sdhci_readw,\n\t.write_l    = tegra_sdhci_writel,\n\t.set_clock  = tegra_sdhci_set_clock,\n\t.set_dma_mask = tegra_sdhci_set_dma_mask,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset      = tegra_sdhci_reset,\n\t.set_uhs_signaling = tegra_sdhci_set_uhs_signaling,\n\t.voltage_switch = tegra_sdhci_voltage_switch,\n\t.get_max_clock = tegra_sdhci_get_max_clock,\n\t.irq = sdhci_tegra_cqhci_irq,\n\t.set_timeout = tegra_sdhci_set_timeout,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_tegra186_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\t  SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_ISSUE_CMD_DAT_RESET_TOGETHER,\n\t.ops  = &tegra186_sdhci_ops,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra186 = {\n\t.pdata = &sdhci_tegra186_pdata,\n\t.dma_mask = DMA_BIT_MASK(40),\n\t.nvquirks = NVQUIRK_NEEDS_PAD_CONTROL |\n\t\t    NVQUIRK_HAS_PADCALIB |\n\t\t    NVQUIRK_DIS_CARD_CLK_CONFIG_TAP |\n\t\t    NVQUIRK_ENABLE_SDR50 |\n\t\t    NVQUIRK_ENABLE_SDR104 |\n\t\t    NVQUIRK_HAS_TMCLK |\n\t\t    NVQUIRK_CQHCI_DCMD_R1B_CMD_TIMING,\n\t.min_tap_delay = 84,\n\t.max_tap_delay = 136,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra194 = {\n\t.pdata = &sdhci_tegra186_pdata,\n\t.dma_mask = DMA_BIT_MASK(39),\n\t.nvquirks = NVQUIRK_NEEDS_PAD_CONTROL |\n\t\t    NVQUIRK_HAS_PADCALIB |\n\t\t    NVQUIRK_DIS_CARD_CLK_CONFIG_TAP |\n\t\t    NVQUIRK_ENABLE_SDR50 |\n\t\t    NVQUIRK_ENABLE_SDR104 |\n\t\t    NVQUIRK_HAS_TMCLK,\n\t.min_tap_delay = 96,\n\t.max_tap_delay = 139,\n};\n\nstatic const struct sdhci_tegra_soc_data soc_data_tegra234 = {\n\t.pdata = &sdhci_tegra186_pdata,\n\t.dma_mask = DMA_BIT_MASK(39),\n\t.nvquirks = NVQUIRK_NEEDS_PAD_CONTROL |\n\t\t    NVQUIRK_HAS_PADCALIB |\n\t\t    NVQUIRK_DIS_CARD_CLK_CONFIG_TAP |\n\t\t    NVQUIRK_ENABLE_SDR50 |\n\t\t    NVQUIRK_ENABLE_SDR104 |\n\t\t    NVQUIRK_PROGRAM_STREAMID |\n\t\t    NVQUIRK_HAS_TMCLK,\n\t.min_tap_delay = 95,\n\t.max_tap_delay = 111,\n};\n\nstatic const struct of_device_id sdhci_tegra_dt_match[] = {\n\t{ .compatible = \"nvidia,tegra234-sdhci\", .data = &soc_data_tegra234 },\n\t{ .compatible = \"nvidia,tegra194-sdhci\", .data = &soc_data_tegra194 },\n\t{ .compatible = \"nvidia,tegra186-sdhci\", .data = &soc_data_tegra186 },\n\t{ .compatible = \"nvidia,tegra210-sdhci\", .data = &soc_data_tegra210 },\n\t{ .compatible = \"nvidia,tegra124-sdhci\", .data = &soc_data_tegra124 },\n\t{ .compatible = \"nvidia,tegra114-sdhci\", .data = &soc_data_tegra114 },\n\t{ .compatible = \"nvidia,tegra30-sdhci\", .data = &soc_data_tegra30 },\n\t{ .compatible = \"nvidia,tegra20-sdhci\", .data = &soc_data_tegra20 },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sdhci_tegra_dt_match);\n\nstatic int sdhci_tegra_add_host(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct cqhci_host *cq_host;\n\tbool dma64;\n\tint ret;\n\n\tif (!tegra_host->enable_hwcq)\n\t\treturn sdhci_add_host(host);\n\n\tsdhci_enable_v4_mode(host);\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\thost->mmc->caps2 |= MMC_CAP2_CQE | MMC_CAP2_CQE_DCMD;\n\n\tcq_host = devm_kzalloc(mmc_dev(host->mmc),\n\t\t\t\tsizeof(*cq_host), GFP_KERNEL);\n\tif (!cq_host) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tcq_host->mmio = host->ioaddr + SDHCI_TEGRA_CQE_BASE_ADDR;\n\tcq_host->ops = &sdhci_tegra_cqhci_ops;\n\n\tdma64 = host->flags & SDHCI_USE_64_BIT_DMA;\n\tif (dma64)\n\t\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\n\tret = cqhci_init(cq_host, host->mmc, dma64);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\n \nstatic void sdhci_tegra_program_stream_id(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (tegra_host->soc_data->nvquirks & NVQUIRK_PROGRAM_STREAMID) {\n\t\ttegra_sdhci_writel(host, FIELD_PREP(GENMASK(15, 8), tegra_host->stream_id) |\n\t\t\t\t\t FIELD_PREP(GENMASK(7, 0), tegra_host->stream_id),\n\t\t\t\t\t SDHCI_TEGRA_CIF2AXI_CTRL_0);\n\t}\n}\n\nstatic int sdhci_tegra_probe(struct platform_device *pdev)\n{\n\tconst struct sdhci_tegra_soc_data *soc_data;\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_tegra *tegra_host;\n\tstruct clk *clk;\n\tint rc;\n\n\tsoc_data = of_device_get_match_data(&pdev->dev);\n\tif (!soc_data)\n\t\treturn -EINVAL;\n\n\thost = sdhci_pltfm_init(pdev, soc_data->pdata, sizeof(*tegra_host));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\tpltfm_host = sdhci_priv(host);\n\n\ttegra_host = sdhci_pltfm_priv(pltfm_host);\n\ttegra_host->ddr_signaling = false;\n\ttegra_host->pad_calib_required = false;\n\ttegra_host->pad_control_available = false;\n\ttegra_host->soc_data = soc_data;\n\n\tif (soc_data->nvquirks & NVQUIRK_HAS_ANDROID_GPT_SECTOR)\n\t\thost->mmc->caps2 |= MMC_CAP2_ALT_GPT_TEGRA;\n\n\tif (soc_data->nvquirks & NVQUIRK_NEEDS_PAD_CONTROL) {\n\t\trc = tegra_sdhci_init_pinctrl_info(&pdev->dev, tegra_host);\n\t\tif (rc == 0)\n\t\t\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\t\t\tsdhci_tegra_start_signal_voltage_switch;\n\t}\n\n\t \n\tif (soc_data->nvquirks & NVQUIRK_HAS_PADCALIB)\n\t\thost->mmc_host_ops.request = tegra_sdhci_request;\n\n\thost->mmc_host_ops.hs400_enhanced_strobe =\n\t\t\ttegra_sdhci_hs400_enhanced_strobe;\n\n\tif (!host->ops->platform_execute_tuning)\n\t\thost->mmc_host_ops.execute_tuning =\n\t\t\t\ttegra_sdhci_execute_hw_tuning;\n\n\trc = mmc_of_parse(host->mmc);\n\tif (rc)\n\t\tgoto err_parse_dt;\n\n\tif (tegra_host->soc_data->nvquirks & NVQUIRK_ENABLE_DDR50)\n\t\thost->mmc->caps |= MMC_CAP_1_8V_DDR;\n\n\t \n\thost->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY | MMC_CAP_NEED_RSP_BUSY;\n\n\t \n\thost->mmc->caps |= MMC_CAP_CD_WAKE;\n\n\ttegra_sdhci_parse_dt(host);\n\n\tif (tegra_host->soc_data->nvquirks & NVQUIRK_PROGRAM_STREAMID &&\n\t    !tegra_dev_iommu_get_stream_id(&pdev->dev, &tegra_host->stream_id)) {\n\t\tdev_warn(mmc_dev(host->mmc), \"missing IOMMU stream ID\\n\");\n\t\ttegra_host->stream_id = 0x7f;\n\t}\n\n\ttegra_host->power_gpio = devm_gpiod_get_optional(&pdev->dev, \"power\",\n\t\t\t\t\t\t\t GPIOD_OUT_HIGH);\n\tif (IS_ERR(tegra_host->power_gpio)) {\n\t\trc = PTR_ERR(tegra_host->power_gpio);\n\t\tgoto err_power_req;\n\t}\n\n\t \n\n\tif (soc_data->nvquirks & NVQUIRK_HAS_TMCLK) {\n\t\tclk = devm_clk_get(&pdev->dev, \"tmclk\");\n\t\tif (IS_ERR(clk)) {\n\t\t\trc = PTR_ERR(clk);\n\t\t\tif (rc == -EPROBE_DEFER)\n\t\t\t\tgoto err_power_req;\n\n\t\t\tdev_warn(&pdev->dev, \"failed to get tmclk: %d\\n\", rc);\n\t\t\tclk = NULL;\n\t\t}\n\n\t\tclk_set_rate(clk, 12000000);\n\t\trc = clk_prepare_enable(clk);\n\t\tif (rc) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to enable tmclk: %d\\n\", rc);\n\t\t\tgoto err_power_req;\n\t\t}\n\n\t\ttegra_host->tmclk = clk;\n\t}\n\n\tclk = devm_clk_get(mmc_dev(host->mmc), NULL);\n\tif (IS_ERR(clk)) {\n\t\trc = dev_err_probe(&pdev->dev, PTR_ERR(clk),\n\t\t\t\t   \"failed to get clock\\n\");\n\t\tgoto err_clk_get;\n\t}\n\tpltfm_host->clk = clk;\n\n\ttegra_host->rst = devm_reset_control_get_exclusive(&pdev->dev,\n\t\t\t\t\t\t\t   \"sdhci\");\n\tif (IS_ERR(tegra_host->rst)) {\n\t\trc = PTR_ERR(tegra_host->rst);\n\t\tdev_err(&pdev->dev, \"failed to get reset control: %d\\n\", rc);\n\t\tgoto err_rst_get;\n\t}\n\n\trc = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (rc)\n\t\tgoto err_rst_get;\n\n\tpm_runtime_enable(&pdev->dev);\n\trc = pm_runtime_resume_and_get(&pdev->dev);\n\tif (rc)\n\t\tgoto err_pm_get;\n\n\trc = reset_control_assert(tegra_host->rst);\n\tif (rc)\n\t\tgoto err_rst_assert;\n\n\tusleep_range(2000, 4000);\n\n\trc = reset_control_deassert(tegra_host->rst);\n\tif (rc)\n\t\tgoto err_rst_assert;\n\n\tusleep_range(2000, 4000);\n\n\trc = sdhci_tegra_add_host(host);\n\tif (rc)\n\t\tgoto err_add_host;\n\n\tsdhci_tegra_program_stream_id(host);\n\n\treturn 0;\n\nerr_add_host:\n\treset_control_assert(tegra_host->rst);\nerr_rst_assert:\n\tpm_runtime_put_sync_suspend(&pdev->dev);\nerr_pm_get:\n\tpm_runtime_disable(&pdev->dev);\nerr_rst_get:\nerr_clk_get:\n\tclk_disable_unprepare(tegra_host->tmclk);\nerr_power_req:\nerr_parse_dt:\n\tsdhci_pltfm_free(pdev);\n\treturn rc;\n}\n\nstatic void sdhci_tegra_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_tegra *tegra_host = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_remove_host(host, 0);\n\n\treset_control_assert(tegra_host->rst);\n\tusleep_range(2000, 4000);\n\n\tpm_runtime_put_sync_suspend(&pdev->dev);\n\tpm_runtime_force_suspend(&pdev->dev);\n\n\tclk_disable_unprepare(tegra_host->tmclk);\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic int __maybe_unused sdhci_tegra_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\tclk_disable_unprepare(pltfm_host->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sdhci_tegra_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn clk_prepare_enable(pltfm_host->clk);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_tegra_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE) {\n\t\tret = cqhci_suspend(host->mmc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = sdhci_suspend_host(host);\n\tif (ret) {\n\t\tcqhci_resume(host->mmc);\n\t\treturn ret;\n\t}\n\n\tret = pm_runtime_force_suspend(dev);\n\tif (ret) {\n\t\tsdhci_resume_host(host);\n\t\tcqhci_resume(host->mmc);\n\t\treturn ret;\n\t}\n\n\treturn mmc_gpio_set_cd_wake(host->mmc, true);\n}\n\nstatic int sdhci_tegra_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = mmc_gpio_set_cd_wake(host->mmc, false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tsdhci_tegra_program_stream_id(host);\n\n\tret = sdhci_resume_host(host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tif (host->mmc->caps2 & MMC_CAP2_CQE) {\n\t\tret = cqhci_resume(host->mmc);\n\t\tif (ret)\n\t\t\tgoto suspend_host;\n\t}\n\n\treturn 0;\n\nsuspend_host:\n\tsdhci_suspend_host(host);\ndisable_clk:\n\tpm_runtime_force_suspend(dev);\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_tegra_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sdhci_tegra_runtime_suspend, sdhci_tegra_runtime_resume,\n\t\t\t   NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_tegra_suspend, sdhci_tegra_resume)\n};\n\nstatic struct platform_driver sdhci_tegra_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-tegra\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_tegra_dt_match,\n\t\t.pm\t= &sdhci_tegra_dev_pm_ops,\n\t},\n\t.probe\t\t= sdhci_tegra_probe,\n\t.remove_new\t= sdhci_tegra_remove,\n};\n\nmodule_platform_driver(sdhci_tegra_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for Tegra\");\nMODULE_AUTHOR(\"Google, Inc.\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}