{
  "module_name": "sdhci-of-esdhc.c",
  "hash_id": "bda8d6500f94ce679a44908c0835079c419896c497ef8453680ab7343c26bee6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-esdhc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/sys_soc.h>\n#include <linux/clk.h>\n#include <linux/ktime.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include \"sdhci-pltfm.h\"\n#include \"sdhci-esdhc.h\"\n\n#define VENDOR_V_22\t0x12\n#define VENDOR_V_23\t0x13\n\n#define MMC_TIMING_NUM (MMC_TIMING_MMC_HS400 + 1)\n\nstruct esdhc_clk_fixup {\n\tconst unsigned int sd_dflt_max_clk;\n\tconst unsigned int max_clk[MMC_TIMING_NUM];\n};\n\nstatic const struct esdhc_clk_fixup ls1021a_esdhc_clk = {\n\t.sd_dflt_max_clk = 25000000,\n\t.max_clk[MMC_TIMING_MMC_HS] = 46500000,\n\t.max_clk[MMC_TIMING_SD_HS] = 46500000,\n};\n\nstatic const struct esdhc_clk_fixup ls1043a_esdhc_clk = {\n\t.sd_dflt_max_clk = 25000000,\n\t.max_clk[MMC_TIMING_UHS_SDR104] = 116700000,\n\t.max_clk[MMC_TIMING_MMC_HS200] = 116700000,\n};\n\nstatic const struct esdhc_clk_fixup ls1046a_esdhc_clk = {\n\t.sd_dflt_max_clk = 25000000,\n\t.max_clk[MMC_TIMING_UHS_SDR104] = 167000000,\n\t.max_clk[MMC_TIMING_MMC_HS200] = 167000000,\n};\n\nstatic const struct esdhc_clk_fixup ls1012a_esdhc_clk = {\n\t.sd_dflt_max_clk = 25000000,\n\t.max_clk[MMC_TIMING_UHS_SDR104] = 125000000,\n\t.max_clk[MMC_TIMING_MMC_HS200] = 125000000,\n};\n\nstatic const struct esdhc_clk_fixup p1010_esdhc_clk = {\n\t.sd_dflt_max_clk = 20000000,\n\t.max_clk[MMC_TIMING_LEGACY] = 20000000,\n\t.max_clk[MMC_TIMING_MMC_HS] = 42000000,\n\t.max_clk[MMC_TIMING_SD_HS] = 40000000,\n};\n\nstatic const struct of_device_id sdhci_esdhc_of_match[] = {\n\t{ .compatible = \"fsl,ls1021a-esdhc\", .data = &ls1021a_esdhc_clk},\n\t{ .compatible = \"fsl,ls1043a-esdhc\", .data = &ls1043a_esdhc_clk},\n\t{ .compatible = \"fsl,ls1046a-esdhc\", .data = &ls1046a_esdhc_clk},\n\t{ .compatible = \"fsl,ls1012a-esdhc\", .data = &ls1012a_esdhc_clk},\n\t{ .compatible = \"fsl,p1010-esdhc\",   .data = &p1010_esdhc_clk},\n\t{ .compatible = \"fsl,mpc8379-esdhc\" },\n\t{ .compatible = \"fsl,mpc8536-esdhc\" },\n\t{ .compatible = \"fsl,esdhc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sdhci_esdhc_of_match);\n\nstruct sdhci_esdhc {\n\tu8 vendor_ver;\n\tu8 spec_ver;\n\tbool quirk_incorrect_hostver;\n\tbool quirk_limited_clk_division;\n\tbool quirk_unreliable_pulse_detection;\n\tbool quirk_tuning_erratum_type1;\n\tbool quirk_tuning_erratum_type2;\n\tbool quirk_ignore_data_inhibit;\n\tbool quirk_delay_before_data_reset;\n\tbool quirk_trans_complete_erratum;\n\tbool in_sw_tuning;\n\tunsigned int peripheral_clock;\n\tconst struct esdhc_clk_fixup *clk_fixup;\n\tu32 div_ratio;\n};\n\n \nstatic u32 esdhc_readl_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u32 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu32 ret;\n\n\t \n\tif ((spec_reg == SDHCI_CAPABILITIES) && (value & SDHCI_CAN_DO_ADMA1)) {\n\t\tif (esdhc->vendor_ver > VENDOR_V_22) {\n\t\t\tret = value | SDHCI_CAN_DO_ADMA2;\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (spec_reg == SDHCI_PRESENT_STATE) {\n\t\tret = value & 0x000fffff;\n\t\tret |= (value >> 4) & SDHCI_DATA_LVL_MASK;\n\t\tret |= (value << 1) & SDHCI_CMD_LVL;\n\n\t\t \n\t\tif (esdhc->quirk_ignore_data_inhibit)\n\t\t\tret &= ~SDHCI_DATA_INHIBIT;\n\t\treturn ret;\n\t}\n\n\t \n\tif (spec_reg == SDHCI_CAPABILITIES_1) {\n\t\tret = value & ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_SDR104 |\n\t\t\t\tSDHCI_SUPPORT_DDR50);\n\t\treturn ret;\n\t}\n\n\tret = value;\n\treturn ret;\n}\n\nstatic u16 esdhc_readw_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u32 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu16 ret;\n\tint shift = (spec_reg & 0x2) * 8;\n\n\tif (spec_reg == SDHCI_TRANSFER_MODE)\n\t\treturn pltfm_host->xfer_mode_shadow;\n\n\tif (spec_reg == SDHCI_HOST_VERSION)\n\t\tret = value & 0xffff;\n\telse\n\t\tret = (value >> shift) & 0xffff;\n\t \n\tif ((spec_reg == SDHCI_HOST_VERSION) &&\n\t    (esdhc->quirk_incorrect_hostver))\n\t\tret = (VENDOR_V_23 << SDHCI_VENDOR_VER_SHIFT) | SDHCI_SPEC_200;\n\treturn ret;\n}\n\nstatic u8 esdhc_readb_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u32 value)\n{\n\tu8 ret;\n\tu8 dma_bits;\n\tint shift = (spec_reg & 0x3) * 8;\n\n\tret = (value >> shift) & 0xff;\n\n\t \n\tif (spec_reg == SDHCI_HOST_CONTROL) {\n\t\t \n\t\tdma_bits = (value >> 5) & SDHCI_CTRL_DMA_MASK;\n\t\t \n\t\tret &= ~SDHCI_CTRL_DMA_MASK;\n\t\tret |= dma_bits;\n\t}\n\treturn ret;\n}\n\n \nstatic u32 esdhc_writel_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u32 value, u32 old_value)\n{\n\tu32 ret;\n\n\t \n\tif (spec_reg == SDHCI_INT_ENABLE)\n\t\tret = value | SDHCI_INT_BLK_GAP;\n\telse\n\t\tret = value;\n\n\treturn ret;\n}\n\nstatic u32 esdhc_writew_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u16 value, u32 old_value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tint shift = (spec_reg & 0x2) * 8;\n\tu32 ret;\n\n\tswitch (spec_reg) {\n\tcase SDHCI_TRANSFER_MODE:\n\t\t \n\t\tpltfm_host->xfer_mode_shadow = value;\n\t\treturn old_value;\n\tcase SDHCI_COMMAND:\n\t\tret = (value << 16) | pltfm_host->xfer_mode_shadow;\n\t\treturn ret;\n\t}\n\n\tret = old_value & (~(0xffff << shift));\n\tret |= (value << shift);\n\n\tif (spec_reg == SDHCI_BLOCK_SIZE) {\n\t\t \n\t\tret &= (~SDHCI_MAKE_BLKSZ(0x7, 0));\n\t}\n\treturn ret;\n}\n\nstatic u32 esdhc_writeb_fixup(struct sdhci_host *host,\n\t\t\t\t     int spec_reg, u8 value, u32 old_value)\n{\n\tu32 ret;\n\tu32 dma_bits;\n\tu8 tmp;\n\tint shift = (spec_reg & 0x3) * 8;\n\n\t \n\tif (spec_reg == SDHCI_POWER_CONTROL)\n\t\treturn old_value;\n\t \n\tif (spec_reg == SDHCI_HOST_CONTROL) {\n\t\t \n\t\tif (host->quirks2 & SDHCI_QUIRK2_BROKEN_HOST_CONTROL)\n\t\t\treturn old_value;\n\n\t\t \n\t\tdma_bits = (value & SDHCI_CTRL_DMA_MASK) << 5;\n\t\tret = (old_value & (~(SDHCI_CTRL_DMA_MASK << 5))) | dma_bits;\n\t\ttmp = (value & (~SDHCI_CTRL_DMA_MASK)) |\n\t\t      (old_value & SDHCI_CTRL_DMA_MASK);\n\t\tret = (ret & (~0xff)) | tmp;\n\n\t\t \n\t\tret &= ~ESDHC_HOST_CONTROL_RES;\n\t\treturn ret;\n\t}\n\n\tret = (old_value & (~(0xff << shift))) | (value << shift);\n\treturn ret;\n}\n\nstatic u32 esdhc_be_readl(struct sdhci_host *host, int reg)\n{\n\tu32 ret;\n\tu32 value;\n\n\tif (reg == SDHCI_CAPABILITIES_1)\n\t\tvalue = ioread32be(host->ioaddr + ESDHC_CAPABILITIES_1);\n\telse\n\t\tvalue = ioread32be(host->ioaddr + reg);\n\n\tret = esdhc_readl_fixup(host, reg, value);\n\n\treturn ret;\n}\n\nstatic u32 esdhc_le_readl(struct sdhci_host *host, int reg)\n{\n\tu32 ret;\n\tu32 value;\n\n\tif (reg == SDHCI_CAPABILITIES_1)\n\t\tvalue = ioread32(host->ioaddr + ESDHC_CAPABILITIES_1);\n\telse\n\t\tvalue = ioread32(host->ioaddr + reg);\n\n\tret = esdhc_readl_fixup(host, reg, value);\n\n\treturn ret;\n}\n\nstatic u16 esdhc_be_readw(struct sdhci_host *host, int reg)\n{\n\tu16 ret;\n\tu32 value;\n\tint base = reg & ~0x3;\n\n\tvalue = ioread32be(host->ioaddr + base);\n\tret = esdhc_readw_fixup(host, reg, value);\n\treturn ret;\n}\n\nstatic u16 esdhc_le_readw(struct sdhci_host *host, int reg)\n{\n\tu16 ret;\n\tu32 value;\n\tint base = reg & ~0x3;\n\n\tvalue = ioread32(host->ioaddr + base);\n\tret = esdhc_readw_fixup(host, reg, value);\n\treturn ret;\n}\n\nstatic u8 esdhc_be_readb(struct sdhci_host *host, int reg)\n{\n\tu8 ret;\n\tu32 value;\n\tint base = reg & ~0x3;\n\n\tvalue = ioread32be(host->ioaddr + base);\n\tret = esdhc_readb_fixup(host, reg, value);\n\treturn ret;\n}\n\nstatic u8 esdhc_le_readb(struct sdhci_host *host, int reg)\n{\n\tu8 ret;\n\tu32 value;\n\tint base = reg & ~0x3;\n\n\tvalue = ioread32(host->ioaddr + base);\n\tret = esdhc_readb_fixup(host, reg, value);\n\treturn ret;\n}\n\nstatic void esdhc_be_writel(struct sdhci_host *host, u32 val, int reg)\n{\n\tu32 value;\n\n\tvalue = esdhc_writel_fixup(host, reg, val, 0);\n\tiowrite32be(value, host->ioaddr + reg);\n}\n\nstatic void esdhc_le_writel(struct sdhci_host *host, u32 val, int reg)\n{\n\tu32 value;\n\n\tvalue = esdhc_writel_fixup(host, reg, val, 0);\n\tiowrite32(value, host->ioaddr + reg);\n}\n\nstatic void esdhc_be_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tint base = reg & ~0x3;\n\tu32 value;\n\tu32 ret;\n\n\tvalue = ioread32be(host->ioaddr + base);\n\tret = esdhc_writew_fixup(host, reg, val, value);\n\tif (reg != SDHCI_TRANSFER_MODE)\n\t\tiowrite32be(ret, host->ioaddr + base);\n\n\t \n\tif (base == ESDHC_SYSTEM_CONTROL_2) {\n\t\tif (!(value & ESDHC_EXTN) && (ret & ESDHC_EXTN) &&\n\t\t    esdhc->in_sw_tuning) {\n\t\t\tudelay(1);\n\t\t\tret |= ESDHC_SMPCLKSEL;\n\t\t\tiowrite32be(ret, host->ioaddr + base);\n\t\t}\n\t}\n}\n\nstatic void esdhc_le_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tint base = reg & ~0x3;\n\tu32 value;\n\tu32 ret;\n\n\tvalue = ioread32(host->ioaddr + base);\n\tret = esdhc_writew_fixup(host, reg, val, value);\n\tif (reg != SDHCI_TRANSFER_MODE)\n\t\tiowrite32(ret, host->ioaddr + base);\n\n\t \n\tif (base == ESDHC_SYSTEM_CONTROL_2) {\n\t\tif (!(value & ESDHC_EXTN) && (ret & ESDHC_EXTN) &&\n\t\t    esdhc->in_sw_tuning) {\n\t\t\tudelay(1);\n\t\t\tret |= ESDHC_SMPCLKSEL;\n\t\t\tiowrite32(ret, host->ioaddr + base);\n\t\t}\n\t}\n}\n\nstatic void esdhc_be_writeb(struct sdhci_host *host, u8 val, int reg)\n{\n\tint base = reg & ~0x3;\n\tu32 value;\n\tu32 ret;\n\n\tvalue = ioread32be(host->ioaddr + base);\n\tret = esdhc_writeb_fixup(host, reg, val, value);\n\tiowrite32be(ret, host->ioaddr + base);\n}\n\nstatic void esdhc_le_writeb(struct sdhci_host *host, u8 val, int reg)\n{\n\tint base = reg & ~0x3;\n\tu32 value;\n\tu32 ret;\n\n\tvalue = ioread32(host->ioaddr + base);\n\tret = esdhc_writeb_fixup(host, reg, val, value);\n\tiowrite32(ret, host->ioaddr + base);\n}\n\n \nstatic void esdhc_of_adma_workaround(struct sdhci_host *host, u32 intmask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tbool applicable;\n\tdma_addr_t dmastart;\n\tdma_addr_t dmanow;\n\n\tapplicable = (intmask & SDHCI_INT_DATA_END) &&\n\t\t     (intmask & SDHCI_INT_BLK_GAP) &&\n\t\t     (esdhc->vendor_ver == VENDOR_V_23);\n\tif (!applicable)\n\t\treturn;\n\n\thost->data->error = 0;\n\tdmastart = sg_dma_address(host->data->sg);\n\tdmanow = dmastart + host->data->bytes_xfered;\n\t \n\tdmanow = (dmanow & ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1)) +\n\t\tSDHCI_DEFAULT_BOUNDARY_SIZE;\n\thost->data->bytes_xfered = dmanow - dmastart;\n\tsdhci_writel(host, dmanow, SDHCI_DMA_ADDRESS);\n}\n\nstatic int esdhc_of_enable_dma(struct sdhci_host *host)\n{\n\tint ret;\n\tu32 value;\n\tstruct device *dev = mmc_dev(host->mmc);\n\n\tif (of_device_is_compatible(dev->of_node, \"fsl,ls1043a-esdhc\") ||\n\t    of_device_is_compatible(dev->of_node, \"fsl,ls1046a-esdhc\")) {\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(40));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tvalue = sdhci_readl(host, ESDHC_DMA_SYSCTL);\n\n\tif (of_dma_is_coherent(dev->of_node))\n\t\tvalue |= ESDHC_DMA_SNOOP;\n\telse\n\t\tvalue &= ~ESDHC_DMA_SNOOP;\n\n\tsdhci_writel(host, value, ESDHC_DMA_SYSCTL);\n\treturn 0;\n}\n\nstatic unsigned int esdhc_of_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\n\tif (esdhc->peripheral_clock)\n\t\treturn esdhc->peripheral_clock;\n\telse\n\t\treturn pltfm_host->clock;\n}\n\nstatic unsigned int esdhc_of_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tunsigned int clock;\n\n\tif (esdhc->peripheral_clock)\n\t\tclock = esdhc->peripheral_clock;\n\telse\n\t\tclock = pltfm_host->clock;\n\treturn clock / 256 / 16;\n}\n\nstatic void esdhc_clock_enable(struct sdhci_host *host, bool enable)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tktime_t timeout;\n\tu32 val, clk_en;\n\n\tclk_en = ESDHC_CLOCK_SDCLKEN;\n\n\t \n\tif (esdhc->vendor_ver <= VENDOR_V_22)\n\t\tclk_en |= (ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN |\n\t\t\t   ESDHC_CLOCK_PEREN);\n\n\tval = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\n\n\tif (enable)\n\t\tval |= clk_en;\n\telse\n\t\tval &= ~clk_en;\n\n\tsdhci_writel(host, val, ESDHC_SYSTEM_CONTROL);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 20);\n\twhile (esdhc->vendor_ver > VENDOR_V_22) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (sdhci_readl(host, ESDHC_PRSSTAT) & ESDHC_CLOCK_STABLE)\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tpr_err(\"%s: Internal clock never stabilised.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n}\n\nstatic void esdhc_flush_async_fifo(struct sdhci_host *host)\n{\n\tktime_t timeout;\n\tu32 val;\n\n\tval = sdhci_readl(host, ESDHC_DMA_SYSCTL);\n\tval |= ESDHC_FLUSH_ASYNC_FIFO;\n\tsdhci_writel(host, val, ESDHC_DMA_SYSCTL);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 20);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (!(sdhci_readl(host, ESDHC_DMA_SYSCTL) &\n\t\t      ESDHC_FLUSH_ASYNC_FIFO))\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tpr_err(\"%s: flushing asynchronous FIFO timeout.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n}\n\nstatic void esdhc_of_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tunsigned int pre_div = 1, div = 1;\n\tunsigned int clock_fixup = 0;\n\tktime_t timeout;\n\tu32 temp;\n\n\tif (clock == 0) {\n\t\thost->mmc->actual_clock = 0;\n\t\tesdhc_clock_enable(host, false);\n\t\treturn;\n\t}\n\n\t \n\tif (esdhc->vendor_ver < VENDOR_V_23)\n\t\tpre_div = 2;\n\n\t \n\tif (host->mmc->card && mmc_card_sd(host->mmc->card) &&\n\t    esdhc->clk_fixup && host->mmc->ios.timing == MMC_TIMING_LEGACY)\n\t\tclock_fixup = esdhc->clk_fixup->sd_dflt_max_clk;\n\telse if (esdhc->clk_fixup)\n\t\tclock_fixup = esdhc->clk_fixup->max_clk[host->mmc->ios.timing];\n\n\tif (clock_fixup == 0 || clock < clock_fixup)\n\t\tclock_fixup = clock;\n\n\t \n\twhile (host->max_clk / pre_div / 16 > clock_fixup && pre_div < 256)\n\t\tpre_div *= 2;\n\n\twhile (host->max_clk / pre_div / div > clock_fixup && div < 16)\n\t\tdiv++;\n\n\tesdhc->div_ratio = pre_div * div;\n\n\t \n\tif (esdhc->quirk_limited_clk_division &&\n\t    clock == MMC_HS200_MAX_DTR &&\n\t    (host->mmc->ios.timing == MMC_TIMING_MMC_HS400 ||\n\t     host->flags & SDHCI_HS400_TUNING)) {\n\t\tif (esdhc->div_ratio <= 4) {\n\t\t\tpre_div = 4;\n\t\t\tdiv = 1;\n\t\t} else if (esdhc->div_ratio <= 8) {\n\t\t\tpre_div = 4;\n\t\t\tdiv = 2;\n\t\t} else if (esdhc->div_ratio <= 12) {\n\t\t\tpre_div = 4;\n\t\t\tdiv = 3;\n\t\t} else {\n\t\t\tpr_warn(\"%s: using unsupported clock division.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t}\n\t\tesdhc->div_ratio = pre_div * div;\n\t}\n\n\thost->mmc->actual_clock = host->max_clk / esdhc->div_ratio;\n\n\tdev_dbg(mmc_dev(host->mmc), \"desired SD clock: %d, actual: %d\\n\",\n\t\tclock, host->mmc->actual_clock);\n\n\t \n\tpre_div >>= 1;\n\tdiv--;\n\n\tesdhc_clock_enable(host, false);\n\n\ttemp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);\n\ttemp &= ~ESDHC_CLOCK_MASK;\n\ttemp |= ((div << ESDHC_DIVIDER_SHIFT) |\n\t\t(pre_div << ESDHC_PREDIV_SHIFT));\n\tsdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 20);\n\twhile (esdhc->vendor_ver > VENDOR_V_22) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (sdhci_readl(host, ESDHC_PRSSTAT) & ESDHC_CLOCK_STABLE)\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tpr_err(\"%s: Internal clock never stabilised.\\n\",\n\t\t\t\tmmc_hostname(host->mmc));\n\t\t\tbreak;\n\t\t}\n\t\tusleep_range(10, 20);\n\t}\n\n\t \n\tif (host->mmc->ios.timing == MMC_TIMING_MMC_HS400 &&\n\t    clock == MMC_HS200_MAX_DTR) {\n\t\ttemp = sdhci_readl(host, ESDHC_TBCTL);\n\t\tsdhci_writel(host, temp | ESDHC_HS400_MODE, ESDHC_TBCTL);\n\t\ttemp = sdhci_readl(host, ESDHC_SDCLKCTL);\n\t\tsdhci_writel(host, temp | ESDHC_CMD_CLK_CTL, ESDHC_SDCLKCTL);\n\t\tesdhc_clock_enable(host, true);\n\n\t\ttemp = sdhci_readl(host, ESDHC_DLLCFG0);\n\t\ttemp |= ESDHC_DLL_ENABLE;\n\t\tif (host->mmc->actual_clock == MMC_HS200_MAX_DTR)\n\t\t\ttemp |= ESDHC_DLL_FREQ_SEL;\n\t\tsdhci_writel(host, temp, ESDHC_DLLCFG0);\n\n\t\ttemp |= ESDHC_DLL_RESET;\n\t\tsdhci_writel(host, temp, ESDHC_DLLCFG0);\n\t\tudelay(1);\n\t\ttemp &= ~ESDHC_DLL_RESET;\n\t\tsdhci_writel(host, temp, ESDHC_DLLCFG0);\n\n\t\t \n\t\tif (read_poll_timeout(sdhci_readl, temp,\n\t\t\t\t      temp & ESDHC_DLL_STS_SLV_LOCK,\n\t\t\t\t      10, 20000, false,\n\t\t\t\t      host, ESDHC_DLLSTAT0))\n\t\t\tpr_err(\"%s: timeout for delay chain lock.\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\n\t\ttemp = sdhci_readl(host, ESDHC_TBCTL);\n\t\tsdhci_writel(host, temp | ESDHC_HS400_WNDW_ADJUST, ESDHC_TBCTL);\n\n\t\tesdhc_clock_enable(host, false);\n\t\tesdhc_flush_async_fifo(host);\n\t}\n\tesdhc_clock_enable(host, true);\n}\n\nstatic void esdhc_pltfm_set_bus_width(struct sdhci_host *host, int width)\n{\n\tu32 ctrl;\n\n\tctrl = sdhci_readl(host, ESDHC_PROCTL);\n\tctrl &= (~ESDHC_CTRL_BUSWIDTH_MASK);\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tctrl |= ESDHC_CTRL_8BITBUS;\n\t\tbreak;\n\n\tcase MMC_BUS_WIDTH_4:\n\t\tctrl |= ESDHC_CTRL_4BITBUS;\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsdhci_writel(host, ctrl, ESDHC_PROCTL);\n}\n\nstatic void esdhc_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu32 val, bus_width = 0;\n\n\t \n\tif (esdhc->quirk_delay_before_data_reset &&\n\t    (mask & SDHCI_RESET_DATA) &&\n\t    (host->flags & SDHCI_REQ_USE_DMA))\n\t\tmdelay(5);\n\n\t \n\tif ((mask & SDHCI_RESET_DATA) &&\n\t    (esdhc->vendor_ver <= VENDOR_V_22)) {\n\t\tval = sdhci_readl(host, ESDHC_PROCTL);\n\t\tbus_width = val & ESDHC_CTRL_BUSWIDTH_MASK;\n\t}\n\n\tsdhci_reset(host, mask);\n\n\t \n\tif ((mask & SDHCI_RESET_DATA) &&\n\t    (esdhc->vendor_ver <= VENDOR_V_22)) {\n\t\tval = sdhci_readl(host, ESDHC_PROCTL);\n\t\tval &= ~ESDHC_CTRL_BUSWIDTH_MASK;\n\t\tval |= bus_width;\n\t\tsdhci_writel(host, val, ESDHC_PROCTL);\n\n\t\tsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\n\t\tsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\n\t}\n\n\t \n\tif ((mask & SDHCI_RESET_ALL) &&\n\t    (esdhc->spec_ver >= SDHCI_SPEC_300)) {\n\t\tval = sdhci_readl(host, ESDHC_TBCTL);\n\t\tval &= ~ESDHC_TB_EN;\n\t\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\t\t \n\t\tif (esdhc->quirk_unreliable_pulse_detection) {\n\t\t\tval = sdhci_readl(host, ESDHC_DLLCFG1);\n\t\t\tval &= ~ESDHC_DLL_PD_PULSE_STRETCH_SEL;\n\t\t\tsdhci_writel(host, val, ESDHC_DLLCFG1);\n\t\t}\n\t}\n}\n\n \nstatic const struct of_device_id scfg_device_ids[] = {\n\t{ .compatible = \"fsl,t1040-scfg\", },\n\t{ .compatible = \"fsl,ls1012a-scfg\", },\n\t{ .compatible = \"fsl,ls1046a-scfg\", },\n\t{}\n};\n\n \n#define SCFG_SDHCIOVSELCR\t0x408\n#define SDHCIOVSELCR_TGLEN\t0x80000000\n#define SDHCIOVSELCR_VSELVAL\t0x60000000\n#define SDHCIOVSELCR_SDHC_VS\t0x00000001\n\nstatic int esdhc_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t       struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct device_node *scfg_node;\n\tvoid __iomem *scfg_base = NULL;\n\tu32 sdhciovselcr;\n\tu32 val;\n\n\t \n\tif (host->version < SDHCI_SPEC_300)\n\t\treturn 0;\n\n\tval = sdhci_readl(host, ESDHC_PROCTL);\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tval &= ~ESDHC_VOLT_SEL;\n\t\tsdhci_writel(host, val, ESDHC_PROCTL);\n\t\treturn 0;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tscfg_node = of_find_matching_node(NULL, scfg_device_ids);\n\t\tif (scfg_node)\n\t\t\tscfg_base = of_iomap(scfg_node, 0);\n\t\tof_node_put(scfg_node);\n\t\tif (scfg_base) {\n\t\t\tsdhciovselcr = SDHCIOVSELCR_TGLEN |\n\t\t\t\t       SDHCIOVSELCR_VSELVAL;\n\t\t\tiowrite32be(sdhciovselcr,\n\t\t\t\tscfg_base + SCFG_SDHCIOVSELCR);\n\n\t\t\tval |= ESDHC_VOLT_SEL;\n\t\t\tsdhci_writel(host, val, ESDHC_PROCTL);\n\t\t\tmdelay(5);\n\n\t\t\tsdhciovselcr = SDHCIOVSELCR_TGLEN |\n\t\t\t\t       SDHCIOVSELCR_SDHC_VS;\n\t\t\tiowrite32be(sdhciovselcr,\n\t\t\t\tscfg_base + SCFG_SDHCIOVSELCR);\n\t\t\tiounmap(scfg_base);\n\t\t} else {\n\t\t\tval |= ESDHC_VOLT_SEL;\n\t\t\tsdhci_writel(host, val, ESDHC_PROCTL);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic struct soc_device_attribute soc_tuning_erratum_type1[] = {\n\t{ .family = \"QorIQ T1023\", },\n\t{ .family = \"QorIQ T1040\", },\n\t{ .family = \"QorIQ T2080\", },\n\t{ .family = \"QorIQ LS1021A\", },\n\t{   }\n};\n\nstatic struct soc_device_attribute soc_tuning_erratum_type2[] = {\n\t{ .family = \"QorIQ LS1012A\", },\n\t{ .family = \"QorIQ LS1043A\", },\n\t{ .family = \"QorIQ LS1046A\", },\n\t{ .family = \"QorIQ LS1080A\", },\n\t{ .family = \"QorIQ LS2080A\", },\n\t{ .family = \"QorIQ LA1575A\", },\n\t{   }\n};\n\nstatic void esdhc_tuning_block_enable(struct sdhci_host *host, bool enable)\n{\n\tu32 val;\n\n\tesdhc_clock_enable(host, false);\n\tesdhc_flush_async_fifo(host);\n\n\tval = sdhci_readl(host, ESDHC_TBCTL);\n\tif (enable)\n\t\tval |= ESDHC_TB_EN;\n\telse\n\t\tval &= ~ESDHC_TB_EN;\n\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\tesdhc_clock_enable(host, true);\n}\n\nstatic void esdhc_tuning_window_ptr(struct sdhci_host *host, u8 *window_start,\n\t\t\t\t    u8 *window_end)\n{\n\tu32 val;\n\n\t \n\tval = sdhci_readl(host, ESDHC_TBCTL);\n\tval &= ~(0xf << 8);\n\tval |= 8 << 8;\n\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\tmdelay(1);\n\n\t \n\tval = sdhci_readl(host, ESDHC_TBCTL);\n\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\tmdelay(1);\n\n\t \n\tval = sdhci_readl(host, ESDHC_TBSTAT);\n\tval = sdhci_readl(host, ESDHC_TBSTAT);\n\n\t*window_end = val & 0xff;\n\t*window_start = (val >> 8) & 0xff;\n}\n\nstatic void esdhc_prepare_sw_tuning(struct sdhci_host *host, u8 *window_start,\n\t\t\t\t    u8 *window_end)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu8 start_ptr, end_ptr;\n\n\tif (esdhc->quirk_tuning_erratum_type1) {\n\t\t*window_start = 5 * esdhc->div_ratio;\n\t\t*window_end = 3 * esdhc->div_ratio;\n\t\treturn;\n\t}\n\n\tesdhc_tuning_window_ptr(host, &start_ptr, &end_ptr);\n\n\t \n\tsdhci_reset(host, SDHCI_RESET_DATA);\n\t \n\tsdhci_writel(host, 0xFFFFFFFF, SDHCI_INT_STATUS);\n\n\t \n\n\tif (abs(start_ptr - end_ptr) > (4 * esdhc->div_ratio + 2)) {\n\t\t*window_start = 8 * esdhc->div_ratio;\n\t\t*window_end = 4 * esdhc->div_ratio;\n\t} else {\n\t\t*window_start = 5 * esdhc->div_ratio;\n\t\t*window_end = 3 * esdhc->div_ratio;\n\t}\n}\n\nstatic int esdhc_execute_sw_tuning(struct mmc_host *mmc, u32 opcode,\n\t\t\t\t   u8 window_start, u8 window_end)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu32 val;\n\tint ret;\n\n\t \n\tval = ((u32)window_start << ESDHC_WNDW_STRT_PTR_SHIFT) &\n\t      ESDHC_WNDW_STRT_PTR_MASK;\n\tval |= window_end & ESDHC_WNDW_END_PTR_MASK;\n\tsdhci_writel(host, val, ESDHC_TBPTR);\n\n\t \n\tval = sdhci_readl(host, ESDHC_TBCTL);\n\tval &= ~ESDHC_TB_MODE_MASK;\n\tval |= ESDHC_TB_MODE_SW;\n\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\tesdhc->in_sw_tuning = true;\n\tret = sdhci_execute_tuning(mmc, opcode);\n\tesdhc->in_sw_tuning = false;\n\treturn ret;\n}\n\nstatic int esdhc_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu8 window_start, window_end;\n\tint ret, retries = 1;\n\tbool hs400_tuning;\n\tunsigned int clk;\n\tu32 val;\n\n\t \n\tclk = esdhc->peripheral_clock / 3;\n\tif (host->clock > clk)\n\t\tesdhc_of_set_clock(host, clk);\n\n\tesdhc_tuning_block_enable(host, true);\n\n\t \n\tsdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);\n\n\ths400_tuning = host->flags & SDHCI_HS400_TUNING;\n\n\tdo {\n\t\tif (esdhc->quirk_limited_clk_division &&\n\t\t    hs400_tuning)\n\t\t\tesdhc_of_set_clock(host, host->clock);\n\n\t\t \n\t\tval = sdhci_readl(host, ESDHC_TBCTL);\n\t\tval &= ~ESDHC_TB_MODE_MASK;\n\t\tval |= ESDHC_TB_MODE_3;\n\t\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\t\tret = sdhci_execute_tuning(mmc, opcode);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (esdhc->quirk_tuning_erratum_type2 &&\n\t\t    !host->tuning_err) {\n\t\t\tesdhc_tuning_window_ptr(host, &window_start,\n\t\t\t\t\t\t&window_end);\n\t\t\tif (abs(window_start - window_end) >\n\t\t\t    (4 * esdhc->div_ratio + 2))\n\t\t\t\thost->tuning_err = -EAGAIN;\n\t\t}\n\n\t\t \n\t\tret = host->tuning_err;\n\t\tif (ret == -EAGAIN &&\n\t\t    (esdhc->quirk_tuning_erratum_type1 ||\n\t\t     esdhc->quirk_tuning_erratum_type2)) {\n\t\t\t \n\t\t\tif (hs400_tuning)\n\t\t\t\thost->flags |= SDHCI_HS400_TUNING;\n\t\t\tpr_info(\"%s: Hold on to use fixed sampling clock. Try SW tuning!\\n\",\n\t\t\t\tmmc_hostname(mmc));\n\t\t\t \n\t\t\tesdhc_prepare_sw_tuning(host, &window_start,\n\t\t\t\t\t\t&window_end);\n\t\t\tret = esdhc_execute_sw_tuning(mmc, opcode,\n\t\t\t\t\t\t      window_start,\n\t\t\t\t\t\t      window_end);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tret = host->tuning_err;\n\t\t\tif (ret == -EAGAIN && retries) {\n\t\t\t\t \n\t\t\t\tif (hs400_tuning)\n\t\t\t\t\thost->flags |= SDHCI_HS400_TUNING;\n\n\t\t\t\tclk = host->max_clk / (esdhc->div_ratio + 1);\n\t\t\t\tesdhc_of_set_clock(host, clk);\n\t\t\t\tpr_info(\"%s: Hold on to use fixed sampling clock. Try tuning with reduced clock!\\n\",\n\t\t\t\t\tmmc_hostname(mmc));\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t} while (retries--);\n\n\tif (ret) {\n\t\tesdhc_tuning_block_enable(host, false);\n\t} else if (hs400_tuning) {\n\t\tval = sdhci_readl(host, ESDHC_SDTIMNGCTL);\n\t\tval |= ESDHC_FLW_CTL_BG;\n\t\tsdhci_writel(host, val, ESDHC_SDTIMNGCTL);\n\t}\n\n\treturn ret;\n}\n\nstatic void esdhc_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t   unsigned int timing)\n{\n\tu32 val;\n\n\t \n\tval = sdhci_readl(host, ESDHC_TBCTL);\n\tif (val & ESDHC_HS400_MODE) {\n\t\tval = sdhci_readl(host, ESDHC_SDTIMNGCTL);\n\t\tval &= ~ESDHC_FLW_CTL_BG;\n\t\tsdhci_writel(host, val, ESDHC_SDTIMNGCTL);\n\n\t\tval = sdhci_readl(host, ESDHC_SDCLKCTL);\n\t\tval &= ~ESDHC_CMD_CLK_CTL;\n\t\tsdhci_writel(host, val, ESDHC_SDCLKCTL);\n\n\t\tesdhc_clock_enable(host, false);\n\t\tval = sdhci_readl(host, ESDHC_TBCTL);\n\t\tval &= ~ESDHC_HS400_MODE;\n\t\tsdhci_writel(host, val, ESDHC_TBCTL);\n\t\tesdhc_clock_enable(host, true);\n\n\t\tval = sdhci_readl(host, ESDHC_DLLCFG0);\n\t\tval &= ~(ESDHC_DLL_ENABLE | ESDHC_DLL_FREQ_SEL);\n\t\tsdhci_writel(host, val, ESDHC_DLLCFG0);\n\n\t\tval = sdhci_readl(host, ESDHC_TBCTL);\n\t\tval &= ~ESDHC_HS400_WNDW_ADJUST;\n\t\tsdhci_writel(host, val, ESDHC_TBCTL);\n\n\t\tesdhc_tuning_block_enable(host, false);\n\t}\n\n\tif (timing == MMC_TIMING_MMC_HS400)\n\t\tesdhc_tuning_block_enable(host, true);\n\telse\n\t\tsdhci_set_uhs_signaling(host, timing);\n}\n\nstatic u32 esdhc_irq(struct sdhci_host *host, u32 intmask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_esdhc *esdhc = sdhci_pltfm_priv(pltfm_host);\n\tu32 command;\n\n\tif (esdhc->quirk_trans_complete_erratum) {\n\t\tcommand = SDHCI_GET_CMD(sdhci_readw(host,\n\t\t\t\t\tSDHCI_COMMAND));\n\t\tif (command == MMC_WRITE_MULTIPLE_BLOCK &&\n\t\t\t\tsdhci_readw(host, SDHCI_BLOCK_COUNT) &&\n\t\t\t\tintmask & SDHCI_INT_DATA_END) {\n\t\t\tintmask &= ~SDHCI_INT_DATA_END;\n\t\t\tsdhci_writel(host, SDHCI_INT_DATA_END,\n\t\t\t\t\tSDHCI_INT_STATUS);\n\t\t}\n\t}\n\treturn intmask;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic u32 esdhc_proctl;\nstatic int esdhc_of_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tesdhc_proctl = sdhci_readl(host, SDHCI_HOST_CONTROL);\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\treturn sdhci_suspend_host(host);\n}\n\nstatic int esdhc_of_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tint ret = sdhci_resume_host(host);\n\n\tif (ret == 0) {\n\t\t \n\t\tesdhc_of_enable_dma(host);\n\t\tsdhci_writel(host, esdhc_proctl, SDHCI_HOST_CONTROL);\n\t}\n\treturn ret;\n}\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(esdhc_of_dev_pm_ops,\n\t\t\tesdhc_of_suspend,\n\t\t\tesdhc_of_resume);\n\nstatic const struct sdhci_ops sdhci_esdhc_be_ops = {\n\t.read_l = esdhc_be_readl,\n\t.read_w = esdhc_be_readw,\n\t.read_b = esdhc_be_readb,\n\t.write_l = esdhc_be_writel,\n\t.write_w = esdhc_be_writew,\n\t.write_b = esdhc_be_writeb,\n\t.set_clock = esdhc_of_set_clock,\n\t.enable_dma = esdhc_of_enable_dma,\n\t.get_max_clock = esdhc_of_get_max_clock,\n\t.get_min_clock = esdhc_of_get_min_clock,\n\t.adma_workaround = esdhc_of_adma_workaround,\n\t.set_bus_width = esdhc_pltfm_set_bus_width,\n\t.reset = esdhc_reset,\n\t.set_uhs_signaling = esdhc_set_uhs_signaling,\n\t.irq = esdhc_irq,\n};\n\nstatic const struct sdhci_ops sdhci_esdhc_le_ops = {\n\t.read_l = esdhc_le_readl,\n\t.read_w = esdhc_le_readw,\n\t.read_b = esdhc_le_readb,\n\t.write_l = esdhc_le_writel,\n\t.write_w = esdhc_le_writew,\n\t.write_b = esdhc_le_writeb,\n\t.set_clock = esdhc_of_set_clock,\n\t.enable_dma = esdhc_of_enable_dma,\n\t.get_max_clock = esdhc_of_get_max_clock,\n\t.get_min_clock = esdhc_of_get_min_clock,\n\t.adma_workaround = esdhc_of_adma_workaround,\n\t.set_bus_width = esdhc_pltfm_set_bus_width,\n\t.reset = esdhc_reset,\n\t.set_uhs_signaling = esdhc_set_uhs_signaling,\n\t.irq = esdhc_irq,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_esdhc_be_pdata = {\n\t.quirks = ESDHC_DEFAULT_QUIRKS |\n#ifdef CONFIG_PPC\n\t\t  SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n#endif\n\t\t  SDHCI_QUIRK_NO_CARD_NO_RESET |\n\t\t  SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.ops = &sdhci_esdhc_be_ops,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_esdhc_le_pdata = {\n\t.quirks = ESDHC_DEFAULT_QUIRKS |\n\t\t  SDHCI_QUIRK_NO_CARD_NO_RESET |\n\t\t  SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.ops = &sdhci_esdhc_le_ops,\n};\n\nstatic struct soc_device_attribute soc_incorrect_hostver[] = {\n\t{ .family = \"QorIQ T4240\", .revision = \"1.0\", },\n\t{ .family = \"QorIQ T4240\", .revision = \"2.0\", },\n\t{   }\n};\n\nstatic struct soc_device_attribute soc_fixup_sdhc_clkdivs[] = {\n\t{ .family = \"QorIQ LX2160A\", .revision = \"1.0\", },\n\t{ .family = \"QorIQ LX2160A\", .revision = \"2.0\", },\n\t{ .family = \"QorIQ LS1028A\", .revision = \"1.0\", },\n\t{   }\n};\n\nstatic struct soc_device_attribute soc_unreliable_pulse_detection[] = {\n\t{ .family = \"QorIQ LX2160A\", .revision = \"1.0\", },\n\t{ .family = \"QorIQ LX2160A\", .revision = \"2.0\", },\n\t{ .family = \"QorIQ LS1028A\", .revision = \"1.0\", },\n\t{   }\n};\n\nstatic void esdhc_init(struct platform_device *pdev, struct sdhci_host *host)\n{\n\tconst struct of_device_id *match;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_esdhc *esdhc;\n\tstruct device_node *np;\n\tstruct clk *clk;\n\tu32 val;\n\tu16 host_ver;\n\n\tpltfm_host = sdhci_priv(host);\n\tesdhc = sdhci_pltfm_priv(pltfm_host);\n\n\thost_ver = sdhci_readw(host, SDHCI_HOST_VERSION);\n\tesdhc->vendor_ver = (host_ver & SDHCI_VENDOR_VER_MASK) >>\n\t\t\t     SDHCI_VENDOR_VER_SHIFT;\n\tesdhc->spec_ver = host_ver & SDHCI_SPEC_VER_MASK;\n\tif (soc_device_match(soc_incorrect_hostver))\n\t\tesdhc->quirk_incorrect_hostver = true;\n\telse\n\t\tesdhc->quirk_incorrect_hostver = false;\n\n\tif (soc_device_match(soc_fixup_sdhc_clkdivs))\n\t\tesdhc->quirk_limited_clk_division = true;\n\telse\n\t\tesdhc->quirk_limited_clk_division = false;\n\n\tif (soc_device_match(soc_unreliable_pulse_detection))\n\t\tesdhc->quirk_unreliable_pulse_detection = true;\n\telse\n\t\tesdhc->quirk_unreliable_pulse_detection = false;\n\n\tmatch = of_match_node(sdhci_esdhc_of_match, pdev->dev.of_node);\n\tif (match)\n\t\tesdhc->clk_fixup = match->data;\n\tnp = pdev->dev.of_node;\n\n\tif (of_device_is_compatible(np, \"fsl,p2020-esdhc\")) {\n\t\tesdhc->quirk_delay_before_data_reset = true;\n\t\tesdhc->quirk_trans_complete_erratum = true;\n\t}\n\n\tclk = of_clk_get(np, 0);\n\tif (!IS_ERR(clk)) {\n\t\t \n\t\tif (of_device_is_compatible(np, \"fsl,ls1046a-esdhc\") ||\n\t\t    of_device_is_compatible(np, \"fsl,ls1028a-esdhc\") ||\n\t\t    of_device_is_compatible(np, \"fsl,ls1088a-esdhc\"))\n\t\t\tesdhc->peripheral_clock = clk_get_rate(clk) / 2;\n\t\telse\n\t\t\tesdhc->peripheral_clock = clk_get_rate(clk);\n\n\t\tclk_put(clk);\n\t}\n\n\tesdhc_clock_enable(host, false);\n\tval = sdhci_readl(host, ESDHC_DMA_SYSCTL);\n\t \n\tif (esdhc->peripheral_clock)\n\t\tval |= ESDHC_PERIPHERAL_CLK_SEL;\n\telse\n\t\tval &= ~ESDHC_PERIPHERAL_CLK_SEL;\n\tsdhci_writel(host, val, ESDHC_DMA_SYSCTL);\n\tesdhc_clock_enable(host, true);\n}\n\nstatic int esdhc_hs400_prepare_ddr(struct mmc_host *mmc)\n{\n\tesdhc_tuning_block_enable(mmc_priv(mmc), false);\n\treturn 0;\n}\n\nstatic int sdhci_esdhc_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct device_node *np, *tp;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_esdhc *esdhc;\n\tint ret;\n\n\tnp = pdev->dev.of_node;\n\n\tif (of_property_read_bool(np, \"little-endian\"))\n\t\thost = sdhci_pltfm_init(pdev, &sdhci_esdhc_le_pdata,\n\t\t\t\t\tsizeof(struct sdhci_esdhc));\n\telse\n\t\thost = sdhci_pltfm_init(pdev, &sdhci_esdhc_be_pdata,\n\t\t\t\t\tsizeof(struct sdhci_esdhc));\n\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\tesdhc_signal_voltage_switch;\n\thost->mmc_host_ops.execute_tuning = esdhc_execute_tuning;\n\thost->mmc_host_ops.hs400_prepare_ddr = esdhc_hs400_prepare_ddr;\n\thost->tuning_delay = 1;\n\n\tesdhc_init(pdev, host);\n\n\tsdhci_get_of_property(pdev);\n\n\tpltfm_host = sdhci_priv(host);\n\tesdhc = sdhci_pltfm_priv(pltfm_host);\n\tif (soc_device_match(soc_tuning_erratum_type1))\n\t\tesdhc->quirk_tuning_erratum_type1 = true;\n\telse\n\t\tesdhc->quirk_tuning_erratum_type1 = false;\n\n\tif (soc_device_match(soc_tuning_erratum_type2))\n\t\tesdhc->quirk_tuning_erratum_type2 = true;\n\telse\n\t\tesdhc->quirk_tuning_erratum_type2 = false;\n\n\tif (esdhc->vendor_ver == VENDOR_V_22)\n\t\thost->quirks2 |= SDHCI_QUIRK2_HOST_NO_CMD23;\n\n\tif (esdhc->vendor_ver > VENDOR_V_22)\n\t\thost->quirks &= ~SDHCI_QUIRK_NO_BUSY_IRQ;\n\n\ttp = of_find_compatible_node(NULL, NULL, \"fsl,p2020-esdhc\");\n\tif (tp) {\n\t\tof_node_put(tp);\n\t\thost->quirks |= SDHCI_QUIRK_RESET_AFTER_REQUEST;\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\n\t}\n\n\tif (of_device_is_compatible(np, \"fsl,p5040-esdhc\") ||\n\t    of_device_is_compatible(np, \"fsl,p5020-esdhc\") ||\n\t    of_device_is_compatible(np, \"fsl,p4080-esdhc\") ||\n\t    of_device_is_compatible(np, \"fsl,p1020-esdhc\") ||\n\t    of_device_is_compatible(np, \"fsl,t1040-esdhc\"))\n\t\thost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\n\tif (of_device_is_compatible(np, \"fsl,ls1021a-esdhc\"))\n\t\thost->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;\n\n\tesdhc->quirk_ignore_data_inhibit = false;\n\tif (of_device_is_compatible(np, \"fsl,p2020-esdhc\")) {\n\t\t \n\t\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_HOST_CONTROL;\n\t\tesdhc->quirk_ignore_data_inhibit = true;\n\t}\n\n\t \n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err;\n\n\tmmc_of_parse_voltage(host->mmc, &host->ocr_mask);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n err:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic struct platform_driver sdhci_esdhc_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-esdhc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_esdhc_of_match,\n\t\t.pm = &esdhc_of_dev_pm_ops,\n\t},\n\t.probe = sdhci_esdhc_probe,\n\t.remove_new = sdhci_pltfm_remove,\n};\n\nmodule_platform_driver(sdhci_esdhc_driver);\n\nMODULE_DESCRIPTION(\"SDHCI OF driver for Freescale MPC eSDHC\");\nMODULE_AUTHOR(\"Xiaobo Xie <X.Xie@freescale.com>, \"\n\t      \"Anton Vorontsov <avorontsov@ru.mvista.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}