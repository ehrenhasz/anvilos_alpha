{
  "module_name": "sdhci-of-aspeed.c",
  "hash_id": "fc2d0f0bf4c27767f5e9a104c20cc67d49692d5f38f6727abaf3fcb39d43204f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-aspeed.c",
  "human_readable_source": "\n \n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/io.h>\n#include <linux/math64.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/spinlock.h>\n\n#include \"sdhci-pltfm.h\"\n\n#define ASPEED_SDC_INFO\t\t\t0x00\n#define   ASPEED_SDC_S1_MMC8\t\tBIT(25)\n#define   ASPEED_SDC_S0_MMC8\t\tBIT(24)\n#define ASPEED_SDC_PHASE\t\t0xf4\n#define   ASPEED_SDC_S1_PHASE_IN\tGENMASK(25, 21)\n#define   ASPEED_SDC_S0_PHASE_IN\tGENMASK(20, 16)\n#define   ASPEED_SDC_S1_PHASE_OUT\tGENMASK(15, 11)\n#define   ASPEED_SDC_S1_PHASE_IN_EN\tBIT(10)\n#define   ASPEED_SDC_S1_PHASE_OUT_EN\tGENMASK(9, 8)\n#define   ASPEED_SDC_S0_PHASE_OUT\tGENMASK(7, 3)\n#define   ASPEED_SDC_S0_PHASE_IN_EN\tBIT(2)\n#define   ASPEED_SDC_S0_PHASE_OUT_EN\tGENMASK(1, 0)\n#define   ASPEED_SDC_PHASE_MAX\t\t31\n\n \n#define ASPEED_SDC_CAP1_1_8V           (0 * 32 + 26)\n \n#define ASPEED_SDC_CAP2_SDR104         (1 * 32 + 1)\n\nstruct aspeed_sdc {\n\tstruct clk *clk;\n\tstruct resource *res;\n\n\tspinlock_t lock;\n\tvoid __iomem *regs;\n};\n\nstruct aspeed_sdhci_tap_param {\n\tbool valid;\n\n#define ASPEED_SDHCI_TAP_PARAM_INVERT_CLK\tBIT(4)\n\tu8 in;\n\tu8 out;\n};\n\nstruct aspeed_sdhci_tap_desc {\n\tu32 tap_mask;\n\tu32 enable_mask;\n\tu8 enable_value;\n};\n\nstruct aspeed_sdhci_phase_desc {\n\tstruct aspeed_sdhci_tap_desc in;\n\tstruct aspeed_sdhci_tap_desc out;\n};\n\nstruct aspeed_sdhci_pdata {\n\tunsigned int clk_div_start;\n\tconst struct aspeed_sdhci_phase_desc *phase_desc;\n\tsize_t nr_phase_descs;\n};\n\nstruct aspeed_sdhci {\n\tconst struct aspeed_sdhci_pdata *pdata;\n\tstruct aspeed_sdc *parent;\n\tu32 width_mask;\n\tstruct mmc_clk_phase_map phase_map;\n\tconst struct aspeed_sdhci_phase_desc *phase_desc;\n};\n\n \nstatic void aspeed_sdc_set_slot_capability(struct sdhci_host *host, struct aspeed_sdc *sdc,\n\t\t\t\t\t   int capability, bool enable, u8 slot)\n{\n\tu32 mirror_reg_offset;\n\tu32 cap_val;\n\tu8 cap_reg;\n\n\tif (slot > 1)\n\t\treturn;\n\n\tcap_reg = capability / 32;\n\tcap_val = sdhci_readl(host, 0x40 + (cap_reg * 4));\n\tif (enable)\n\t\tcap_val |= BIT(capability % 32);\n\telse\n\t\tcap_val &= ~BIT(capability % 32);\n\tmirror_reg_offset = ((slot + 1) * 0x10) + (cap_reg * 4);\n\twritel(cap_val, sdc->regs + mirror_reg_offset);\n}\n\nstatic void aspeed_sdc_configure_8bit_mode(struct aspeed_sdc *sdc,\n\t\t\t\t\t   struct aspeed_sdhci *sdhci,\n\t\t\t\t\t   bool bus8)\n{\n\tu32 info;\n\n\t \n\tspin_lock(&sdc->lock);\n\tinfo = readl(sdc->regs + ASPEED_SDC_INFO);\n\tif (bus8)\n\t\tinfo |= sdhci->width_mask;\n\telse\n\t\tinfo &= ~sdhci->width_mask;\n\twritel(info, sdc->regs + ASPEED_SDC_INFO);\n\tspin_unlock(&sdc->lock);\n}\n\nstatic u32\naspeed_sdc_set_phase_tap(const struct aspeed_sdhci_tap_desc *desc,\n\t\t\t u8 tap, bool enable, u32 reg)\n{\n\treg &= ~(desc->enable_mask | desc->tap_mask);\n\tif (enable) {\n\t\treg |= tap << __ffs(desc->tap_mask);\n\t\treg |= desc->enable_value << __ffs(desc->enable_mask);\n\t}\n\n\treturn reg;\n}\n\nstatic void\naspeed_sdc_set_phase_taps(struct aspeed_sdc *sdc,\n\t\t\t  const struct aspeed_sdhci_phase_desc *desc,\n\t\t\t  const struct aspeed_sdhci_tap_param *taps)\n{\n\tu32 reg;\n\n\tspin_lock(&sdc->lock);\n\treg = readl(sdc->regs + ASPEED_SDC_PHASE);\n\n\treg = aspeed_sdc_set_phase_tap(&desc->in, taps->in, taps->valid, reg);\n\treg = aspeed_sdc_set_phase_tap(&desc->out, taps->out, taps->valid, reg);\n\n\twritel(reg, sdc->regs + ASPEED_SDC_PHASE);\n\tspin_unlock(&sdc->lock);\n}\n\n#define PICOSECONDS_PER_SECOND\t\t1000000000000ULL\n#define ASPEED_SDHCI_NR_TAPS\t\t15\n \n#define ASPEED_SDHCI_MAX_TAP_DELAY_PS\t1253\nstatic int aspeed_sdhci_phase_to_tap(struct device *dev, unsigned long rate_hz,\n\t\t\t\t     int phase_deg)\n{\n\tu64 phase_period_ps;\n\tu64 prop_delay_ps;\n\tu64 clk_period_ps;\n\tunsigned int tap;\n\tu8 inverted;\n\n\tphase_deg %= 360;\n\n\tif (phase_deg >= 180) {\n\t\tinverted = ASPEED_SDHCI_TAP_PARAM_INVERT_CLK;\n\t\tphase_deg -= 180;\n\t\tdev_dbg(dev,\n\t\t\t\"Inverting clock to reduce phase correction from %d to %d degrees\\n\",\n\t\t\tphase_deg + 180, phase_deg);\n\t} else {\n\t\tinverted = 0;\n\t}\n\n\tprop_delay_ps = ASPEED_SDHCI_MAX_TAP_DELAY_PS / ASPEED_SDHCI_NR_TAPS;\n\tclk_period_ps = div_u64(PICOSECONDS_PER_SECOND, (u64)rate_hz);\n\tphase_period_ps = div_u64((u64)phase_deg * clk_period_ps, 360ULL);\n\n\ttap = div_u64(phase_period_ps, prop_delay_ps);\n\tif (tap > ASPEED_SDHCI_NR_TAPS) {\n\t\tdev_dbg(dev,\n\t\t\t \"Requested out of range phase tap %d for %d degrees of phase compensation at %luHz, clamping to tap %d\\n\",\n\t\t\t tap, phase_deg, rate_hz, ASPEED_SDHCI_NR_TAPS);\n\t\ttap = ASPEED_SDHCI_NR_TAPS;\n\t}\n\n\treturn inverted | tap;\n}\n\nstatic void\naspeed_sdhci_phases_to_taps(struct device *dev, unsigned long rate,\n\t\t\t    const struct mmc_clk_phase *phases,\n\t\t\t    struct aspeed_sdhci_tap_param *taps)\n{\n\ttaps->valid = phases->valid;\n\n\tif (!phases->valid)\n\t\treturn;\n\n\ttaps->in = aspeed_sdhci_phase_to_tap(dev, rate, phases->in_deg);\n\ttaps->out = aspeed_sdhci_phase_to_tap(dev, rate, phases->out_deg);\n}\n\nstatic void\naspeed_sdhci_configure_phase(struct sdhci_host *host, unsigned long rate)\n{\n\tstruct aspeed_sdhci_tap_param _taps = {0}, *taps = &_taps;\n\tstruct mmc_clk_phase *params;\n\tstruct aspeed_sdhci *sdhci;\n\tstruct device *dev;\n\n\tdev = mmc_dev(host->mmc);\n\tsdhci = sdhci_pltfm_priv(sdhci_priv(host));\n\n\tif (!sdhci->phase_desc)\n\t\treturn;\n\n\tparams = &sdhci->phase_map.phase[host->timing];\n\taspeed_sdhci_phases_to_taps(dev, rate, params, taps);\n\taspeed_sdc_set_phase_taps(sdhci->parent, sdhci->phase_desc, taps);\n\tdev_dbg(dev,\n\t\t\"Using taps [%d, %d] for [%d, %d] degrees of phase correction at %luHz (%d)\\n\",\n\t\ttaps->in & ASPEED_SDHCI_NR_TAPS,\n\t\ttaps->out & ASPEED_SDHCI_NR_TAPS,\n\t\tparams->in_deg, params->out_deg, rate, host->timing);\n}\n\nstatic void aspeed_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tunsigned long parent, bus;\n\tstruct aspeed_sdhci *sdhci;\n\tint div;\n\tu16 clk;\n\n\tpltfm_host = sdhci_priv(host);\n\tsdhci = sdhci_pltfm_priv(pltfm_host);\n\n\tparent = clk_get_rate(pltfm_host->clk);\n\n\tsdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);\n\n\tif (clock == 0)\n\t\treturn;\n\n\tif (WARN_ON(clock > host->max_clk))\n\t\tclock = host->max_clk;\n\n\t \n\tfor (div = sdhci->pdata->clk_div_start; div < 256; div *= 2) {\n\t\tbus = parent / div;\n\t\tif (bus <= clock)\n\t\t\tbreak;\n\t}\n\n\tdiv >>= 1;\n\n\tclk = div << SDHCI_DIVIDER_SHIFT;\n\n\taspeed_sdhci_configure_phase(host, bus);\n\n\tsdhci_enable_clk(host, clk);\n}\n\nstatic unsigned int aspeed_sdhci_get_max_clock(struct sdhci_host *host)\n{\n\tif (host->mmc->f_max)\n\t\treturn host->mmc->f_max;\n\n\treturn sdhci_pltfm_clk_get_max_clock(host);\n}\n\nstatic void aspeed_sdhci_set_bus_width(struct sdhci_host *host, int width)\n{\n\tstruct sdhci_pltfm_host *pltfm_priv;\n\tstruct aspeed_sdhci *aspeed_sdhci;\n\tstruct aspeed_sdc *aspeed_sdc;\n\tu8 ctrl;\n\n\tpltfm_priv = sdhci_priv(host);\n\taspeed_sdhci = sdhci_pltfm_priv(pltfm_priv);\n\taspeed_sdc = aspeed_sdhci->parent;\n\n\t \n\taspeed_sdc_configure_8bit_mode(aspeed_sdc, aspeed_sdhci,\n\t\t\t\t       width == MMC_BUS_WIDTH_8);\n\n\t \n\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\tif (width == MMC_BUS_WIDTH_4)\n\t\tctrl |= SDHCI_CTRL_4BITBUS;\n\telse\n\t\tctrl &= ~SDHCI_CTRL_4BITBUS;\n\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n}\n\nstatic u32 aspeed_sdhci_readl(struct sdhci_host *host, int reg)\n{\n\tu32 val = readl(host->ioaddr + reg);\n\n\tif (unlikely(reg == SDHCI_PRESENT_STATE) &&\n\t    (host->mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH))\n\t\tval ^= SDHCI_CARD_PRESENT;\n\n\treturn val;\n}\n\nstatic const struct sdhci_ops aspeed_sdhci_ops = {\n\t.read_l = aspeed_sdhci_readl,\n\t.set_clock = aspeed_sdhci_set_clock,\n\t.get_max_clock = aspeed_sdhci_get_max_clock,\n\t.set_bus_width = aspeed_sdhci_set_bus_width,\n\t.get_timeout_clock = sdhci_pltfm_clk_get_max_clock,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data aspeed_sdhci_pdata = {\n\t.ops = &aspeed_sdhci_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n};\n\nstatic inline int aspeed_sdhci_calculate_slot(struct aspeed_sdhci *dev,\n\t\t\t\t\t      struct resource *res)\n{\n\tresource_size_t delta;\n\n\tif (!res || resource_type(res) != IORESOURCE_MEM)\n\t\treturn -EINVAL;\n\n\tif (res->start < dev->parent->res->start)\n\t\treturn -EINVAL;\n\n\tdelta = res->start - dev->parent->res->start;\n\tif (delta & (0x100 - 1))\n\t\treturn -EINVAL;\n\n\treturn (delta / 0x100) - 1;\n}\n\nstatic int aspeed_sdhci_probe(struct platform_device *pdev)\n{\n\tconst struct aspeed_sdhci_pdata *aspeed_pdata;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct aspeed_sdhci *dev;\n\tstruct sdhci_host *host;\n\tstruct resource *res;\n\tint slot;\n\tint ret;\n\n\taspeed_pdata = of_device_get_match_data(&pdev->dev);\n\tif (!aspeed_pdata) {\n\t\tdev_err(&pdev->dev, \"Missing platform configuration data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\thost = sdhci_pltfm_init(pdev, &aspeed_sdhci_pdata, sizeof(*dev));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tdev = sdhci_pltfm_priv(pltfm_host);\n\tdev->pdata = aspeed_pdata;\n\tdev->parent = dev_get_drvdata(pdev->dev.parent);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tslot = aspeed_sdhci_calculate_slot(dev, res);\n\n\tif (slot < 0)\n\t\treturn slot;\n\telse if (slot >= 2)\n\t\treturn -EINVAL;\n\n\tif (slot < dev->pdata->nr_phase_descs) {\n\t\tdev->phase_desc = &dev->pdata->phase_desc[slot];\n\t} else {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"Phase control not supported for slot %d\\n\", slot);\n\t\tdev->phase_desc = NULL;\n\t}\n\n\tdev->width_mask = !slot ? ASPEED_SDC_S0_MMC8 : ASPEED_SDC_S1_MMC8;\n\n\tdev_info(&pdev->dev, \"Configured for slot %d\\n\", slot);\n\n\tsdhci_get_of_property(pdev);\n\n\tif (of_property_read_bool(np, \"mmc-hs200-1_8v\") ||\n\t    of_property_read_bool(np, \"sd-uhs-sdr104\")) {\n\t\taspeed_sdc_set_slot_capability(host, dev->parent, ASPEED_SDC_CAP1_1_8V,\n\t\t\t\t\t       true, slot);\n\t}\n\n\tif (of_property_read_bool(np, \"sd-uhs-sdr104\")) {\n\t\taspeed_sdc_set_slot_capability(host, dev->parent, ASPEED_SDC_CAP2_SDR104,\n\t\t\t\t\t       true, slot);\n\t}\n\n\tpltfm_host->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(pltfm_host->clk))\n\t\treturn PTR_ERR(pltfm_host->clk);\n\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable SDIO clock\\n\");\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err_sdhci_add;\n\n\tif (dev->phase_desc)\n\t\tmmc_of_parse_clk_phase(host->mmc, &dev->phase_map);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_sdhci_add;\n\n\treturn 0;\n\nerr_sdhci_add:\n\tclk_disable_unprepare(pltfm_host->clk);\nerr_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void aspeed_sdhci_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_host *host;\n\n\thost = platform_get_drvdata(pdev);\n\tpltfm_host = sdhci_priv(host);\n\n\tsdhci_remove_host(host, 0);\n\n\tclk_disable_unprepare(pltfm_host->clk);\n\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic const struct aspeed_sdhci_pdata ast2400_sdhci_pdata = {\n\t.clk_div_start = 2,\n};\n\nstatic const struct aspeed_sdhci_phase_desc ast2600_sdhci_phase[] = {\n\t \n\t[0] = {\n\t\t.in = {\n\t\t\t.tap_mask = ASPEED_SDC_S0_PHASE_IN,\n\t\t\t.enable_mask = ASPEED_SDC_S0_PHASE_IN_EN,\n\t\t\t.enable_value = 1,\n\t\t},\n\t\t.out = {\n\t\t\t.tap_mask = ASPEED_SDC_S0_PHASE_OUT,\n\t\t\t.enable_mask = ASPEED_SDC_S0_PHASE_OUT_EN,\n\t\t\t.enable_value = 3,\n\t\t},\n\t},\n\t \n\t[1] = {\n\t\t.in = {\n\t\t\t.tap_mask = ASPEED_SDC_S1_PHASE_IN,\n\t\t\t.enable_mask = ASPEED_SDC_S1_PHASE_IN_EN,\n\t\t\t.enable_value = 1,\n\t\t},\n\t\t.out = {\n\t\t\t.tap_mask = ASPEED_SDC_S1_PHASE_OUT,\n\t\t\t.enable_mask = ASPEED_SDC_S1_PHASE_OUT_EN,\n\t\t\t.enable_value = 3,\n\t\t},\n\t},\n};\n\nstatic const struct aspeed_sdhci_pdata ast2600_sdhci_pdata = {\n\t.clk_div_start = 1,\n\t.phase_desc = ast2600_sdhci_phase,\n\t.nr_phase_descs = ARRAY_SIZE(ast2600_sdhci_phase),\n};\n\nstatic const struct of_device_id aspeed_sdhci_of_match[] = {\n\t{ .compatible = \"aspeed,ast2400-sdhci\", .data = &ast2400_sdhci_pdata, },\n\t{ .compatible = \"aspeed,ast2500-sdhci\", .data = &ast2400_sdhci_pdata, },\n\t{ .compatible = \"aspeed,ast2600-sdhci\", .data = &ast2600_sdhci_pdata, },\n\t{ }\n};\n\nstatic struct platform_driver aspeed_sdhci_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-aspeed\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = aspeed_sdhci_of_match,\n\t},\n\t.probe\t\t= aspeed_sdhci_probe,\n\t.remove_new\t= aspeed_sdhci_remove,\n};\n\nstatic int aspeed_sdc_probe(struct platform_device *pdev)\n\n{\n\tstruct device_node *parent, *child;\n\tstruct aspeed_sdc *sdc;\n\tint ret;\n\n\tsdc = devm_kzalloc(&pdev->dev, sizeof(*sdc), GFP_KERNEL);\n\tif (!sdc)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&sdc->lock);\n\n\tsdc->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(sdc->clk))\n\t\treturn PTR_ERR(sdc->clk);\n\n\tret = clk_prepare_enable(sdc->clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Unable to enable SDCLK\\n\");\n\t\treturn ret;\n\t}\n\n\tsdc->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &sdc->res);\n\tif (IS_ERR(sdc->regs)) {\n\t\tret = PTR_ERR(sdc->regs);\n\t\tgoto err_clk;\n\t}\n\n\tdev_set_drvdata(&pdev->dev, sdc);\n\n\tparent = pdev->dev.of_node;\n\tfor_each_available_child_of_node(parent, child) {\n\t\tstruct platform_device *cpdev;\n\n\t\tcpdev = of_platform_device_create(child, NULL, &pdev->dev);\n\t\tif (!cpdev) {\n\t\t\tof_node_put(child);\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(sdc->clk);\n\treturn ret;\n}\n\nstatic void aspeed_sdc_remove(struct platform_device *pdev)\n{\n\tstruct aspeed_sdc *sdc = dev_get_drvdata(&pdev->dev);\n\n\tclk_disable_unprepare(sdc->clk);\n}\n\nstatic const struct of_device_id aspeed_sdc_of_match[] = {\n\t{ .compatible = \"aspeed,ast2400-sd-controller\", },\n\t{ .compatible = \"aspeed,ast2500-sd-controller\", },\n\t{ .compatible = \"aspeed,ast2600-sd-controller\", },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, aspeed_sdc_of_match);\n\nstatic struct platform_driver aspeed_sdc_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sd-controller-aspeed\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &sdhci_pltfm_pmops,\n\t\t.of_match_table = aspeed_sdc_of_match,\n\t},\n\t.probe\t\t= aspeed_sdc_probe,\n\t.remove_new\t= aspeed_sdc_remove,\n};\n\n#if defined(CONFIG_MMC_SDHCI_OF_ASPEED_TEST)\n#include \"sdhci-of-aspeed-test.c\"\n#endif\n\nstatic int __init aspeed_sdc_init(void)\n{\n\tint rc;\n\n\trc = platform_driver_register(&aspeed_sdhci_driver);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = platform_driver_register(&aspeed_sdc_driver);\n\tif (rc < 0)\n\t\tplatform_driver_unregister(&aspeed_sdhci_driver);\n\n\treturn rc;\n}\nmodule_init(aspeed_sdc_init);\n\nstatic void __exit aspeed_sdc_exit(void)\n{\n\tplatform_driver_unregister(&aspeed_sdc_driver);\n\tplatform_driver_unregister(&aspeed_sdhci_driver);\n}\nmodule_exit(aspeed_sdc_exit);\n\nMODULE_DESCRIPTION(\"Driver for the ASPEED SD/SDIO/SDHCI Controllers\");\nMODULE_AUTHOR(\"Ryan Chen <ryan_chen@aspeedtech.com>\");\nMODULE_AUTHOR(\"Andrew Jeffery <andrew@aj.id.au>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}