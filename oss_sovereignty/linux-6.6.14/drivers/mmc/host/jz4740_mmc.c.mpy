{
  "module_name": "jz4740_mmc.c",
  "hash_id": "877ca5e083796eb9ce96340662c67486b735c7a012b7eb9a4620796cd4fcc2c4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/jz4740_mmc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/scatterlist.h>\n\n#include <asm/cacheflush.h>\n\n#define JZ_REG_MMC_STRPCL\t0x00\n#define JZ_REG_MMC_STATUS\t0x04\n#define JZ_REG_MMC_CLKRT\t0x08\n#define JZ_REG_MMC_CMDAT\t0x0C\n#define JZ_REG_MMC_RESTO\t0x10\n#define JZ_REG_MMC_RDTO\t\t0x14\n#define JZ_REG_MMC_BLKLEN\t0x18\n#define JZ_REG_MMC_NOB\t\t0x1C\n#define JZ_REG_MMC_SNOB\t\t0x20\n#define JZ_REG_MMC_IMASK\t0x24\n#define JZ_REG_MMC_IREG\t\t0x28\n#define JZ_REG_MMC_CMD\t\t0x2C\n#define JZ_REG_MMC_ARG\t\t0x30\n#define JZ_REG_MMC_RESP_FIFO\t0x34\n#define JZ_REG_MMC_RXFIFO\t0x38\n#define JZ_REG_MMC_TXFIFO\t0x3C\n#define JZ_REG_MMC_LPM\t\t0x40\n#define JZ_REG_MMC_DMAC\t\t0x44\n\n#define JZ_MMC_STRPCL_EXIT_MULTIPLE BIT(7)\n#define JZ_MMC_STRPCL_EXIT_TRANSFER BIT(6)\n#define JZ_MMC_STRPCL_START_READWAIT BIT(5)\n#define JZ_MMC_STRPCL_STOP_READWAIT BIT(4)\n#define JZ_MMC_STRPCL_RESET BIT(3)\n#define JZ_MMC_STRPCL_START_OP BIT(2)\n#define JZ_MMC_STRPCL_CLOCK_CONTROL (BIT(1) | BIT(0))\n#define JZ_MMC_STRPCL_CLOCK_STOP BIT(0)\n#define JZ_MMC_STRPCL_CLOCK_START BIT(1)\n\n\n#define JZ_MMC_STATUS_IS_RESETTING BIT(15)\n#define JZ_MMC_STATUS_SDIO_INT_ACTIVE BIT(14)\n#define JZ_MMC_STATUS_PRG_DONE BIT(13)\n#define JZ_MMC_STATUS_DATA_TRAN_DONE BIT(12)\n#define JZ_MMC_STATUS_END_CMD_RES BIT(11)\n#define JZ_MMC_STATUS_DATA_FIFO_AFULL BIT(10)\n#define JZ_MMC_STATUS_IS_READWAIT BIT(9)\n#define JZ_MMC_STATUS_CLK_EN BIT(8)\n#define JZ_MMC_STATUS_DATA_FIFO_FULL BIT(7)\n#define JZ_MMC_STATUS_DATA_FIFO_EMPTY BIT(6)\n#define JZ_MMC_STATUS_CRC_RES_ERR BIT(5)\n#define JZ_MMC_STATUS_CRC_READ_ERROR BIT(4)\n#define JZ_MMC_STATUS_TIMEOUT_WRITE BIT(3)\n#define JZ_MMC_STATUS_CRC_WRITE_ERROR BIT(2)\n#define JZ_MMC_STATUS_TIMEOUT_RES BIT(1)\n#define JZ_MMC_STATUS_TIMEOUT_READ BIT(0)\n\n#define JZ_MMC_STATUS_READ_ERROR_MASK (BIT(4) | BIT(0))\n#define JZ_MMC_STATUS_WRITE_ERROR_MASK (BIT(3) | BIT(2))\n\n\n#define JZ_MMC_CMDAT_IO_ABORT BIT(11)\n#define JZ_MMC_CMDAT_BUS_WIDTH_4BIT BIT(10)\n#define JZ_MMC_CMDAT_BUS_WIDTH_8BIT (BIT(10) | BIT(9))\n#define\tJZ_MMC_CMDAT_BUS_WIDTH_MASK (BIT(10) | BIT(9))\n#define JZ_MMC_CMDAT_DMA_EN BIT(8)\n#define JZ_MMC_CMDAT_INIT BIT(7)\n#define JZ_MMC_CMDAT_BUSY BIT(6)\n#define JZ_MMC_CMDAT_STREAM BIT(5)\n#define JZ_MMC_CMDAT_WRITE BIT(4)\n#define JZ_MMC_CMDAT_DATA_EN BIT(3)\n#define JZ_MMC_CMDAT_RESPONSE_FORMAT (BIT(2) | BIT(1) | BIT(0))\n#define JZ_MMC_CMDAT_RSP_R1 1\n#define JZ_MMC_CMDAT_RSP_R2 2\n#define JZ_MMC_CMDAT_RSP_R3 3\n\n#define JZ_MMC_IRQ_SDIO BIT(7)\n#define JZ_MMC_IRQ_TXFIFO_WR_REQ BIT(6)\n#define JZ_MMC_IRQ_RXFIFO_RD_REQ BIT(5)\n#define JZ_MMC_IRQ_END_CMD_RES BIT(2)\n#define JZ_MMC_IRQ_PRG_DONE BIT(1)\n#define JZ_MMC_IRQ_DATA_TRAN_DONE BIT(0)\n\n#define JZ_MMC_DMAC_DMA_SEL BIT(1)\n#define JZ_MMC_DMAC_DMA_EN BIT(0)\n\n#define\tJZ_MMC_LPM_DRV_RISING BIT(31)\n#define\tJZ_MMC_LPM_DRV_RISING_QTR_PHASE_DLY BIT(31)\n#define\tJZ_MMC_LPM_DRV_RISING_1NS_DLY BIT(30)\n#define\tJZ_MMC_LPM_SMP_RISING_QTR_OR_HALF_PHASE_DLY BIT(29)\n#define\tJZ_MMC_LPM_LOW_POWER_MODE_EN BIT(0)\n\n#define JZ_MMC_CLK_RATE 24000000\n#define JZ_MMC_REQ_TIMEOUT_MS 5000\n\nenum jz4740_mmc_version {\n\tJZ_MMC_JZ4740,\n\tJZ_MMC_JZ4725B,\n\tJZ_MMC_JZ4760,\n\tJZ_MMC_JZ4780,\n\tJZ_MMC_X1000,\n};\n\nenum jz4740_mmc_state {\n\tJZ4740_MMC_STATE_READ_RESPONSE,\n\tJZ4740_MMC_STATE_TRANSFER_DATA,\n\tJZ4740_MMC_STATE_SEND_STOP,\n\tJZ4740_MMC_STATE_DONE,\n};\n\n \nenum jz4780_cookie {\n\tCOOKIE_UNMAPPED = 0,\n\tCOOKIE_PREMAPPED,\n\tCOOKIE_MAPPED,\n};\n\nstruct jz4740_mmc_host {\n\tstruct mmc_host *mmc;\n\tstruct platform_device *pdev;\n\tstruct clk *clk;\n\n\tenum jz4740_mmc_version version;\n\n\tint irq;\n\n\tvoid __iomem *base;\n\tstruct resource *mem_res;\n\tstruct mmc_request *req;\n\tstruct mmc_command *cmd;\n\n\tbool vqmmc_enabled;\n\n\tunsigned long waiting;\n\n\tuint32_t cmdat;\n\n\tuint32_t irq_mask;\n\n\tspinlock_t lock;\n\n\tstruct timer_list timeout_timer;\n\tstruct sg_mapping_iter miter;\n\tenum jz4740_mmc_state state;\n\n\t \n\tstruct dma_chan *dma_rx;\n\tstruct dma_chan *dma_tx;\n\tbool use_dma;\n\n \n#define JZ4740_MMC_FIFO_HALF_SIZE 8\n};\n\nstatic void jz4740_mmc_write_irq_mask(struct jz4740_mmc_host *host,\n\t\t\t\t      uint32_t val)\n{\n\tif (host->version >= JZ_MMC_JZ4725B)\n\t\treturn writel(val, host->base + JZ_REG_MMC_IMASK);\n\telse\n\t\treturn writew(val, host->base + JZ_REG_MMC_IMASK);\n}\n\nstatic void jz4740_mmc_write_irq_reg(struct jz4740_mmc_host *host,\n\t\t\t\t     uint32_t val)\n{\n\tif (host->version >= JZ_MMC_JZ4780)\n\t\twritel(val, host->base + JZ_REG_MMC_IREG);\n\telse\n\t\twritew(val, host->base + JZ_REG_MMC_IREG);\n}\n\nstatic uint32_t jz4740_mmc_read_irq_reg(struct jz4740_mmc_host *host)\n{\n\tif (host->version >= JZ_MMC_JZ4780)\n\t\treturn readl(host->base + JZ_REG_MMC_IREG);\n\telse\n\t\treturn readw(host->base + JZ_REG_MMC_IREG);\n}\n\n \n \n\nstatic void jz4740_mmc_release_dma_channels(struct jz4740_mmc_host *host)\n{\n\tif (!host->use_dma)\n\t\treturn;\n\n\tdma_release_channel(host->dma_tx);\n\tif (host->dma_rx)\n\t\tdma_release_channel(host->dma_rx);\n}\n\nstatic int jz4740_mmc_acquire_dma_channels(struct jz4740_mmc_host *host)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\n\thost->dma_tx = dma_request_chan(dev, \"tx-rx\");\n\tif (!IS_ERR(host->dma_tx))\n\t\treturn 0;\n\n\tif (PTR_ERR(host->dma_tx) != -ENODEV) {\n\t\tdev_err(dev, \"Failed to get dma tx-rx channel\\n\");\n\t\treturn PTR_ERR(host->dma_tx);\n\t}\n\n\thost->dma_tx = dma_request_chan(mmc_dev(host->mmc), \"tx\");\n\tif (IS_ERR(host->dma_tx)) {\n\t\tdev_err(mmc_dev(host->mmc), \"Failed to get dma_tx channel\\n\");\n\t\treturn PTR_ERR(host->dma_tx);\n\t}\n\n\thost->dma_rx = dma_request_chan(mmc_dev(host->mmc), \"rx\");\n\tif (IS_ERR(host->dma_rx)) {\n\t\tdev_err(mmc_dev(host->mmc), \"Failed to get dma_rx channel\\n\");\n\t\tdma_release_channel(host->dma_tx);\n\t\treturn PTR_ERR(host->dma_rx);\n\t}\n\n\t \n\tif (host->dma_tx) {\n\t\tstruct device *dev = host->dma_tx->device->dev;\n\t\tunsigned int max_seg_size = dma_get_max_seg_size(dev);\n\n\t\tif (max_seg_size < host->mmc->max_seg_size)\n\t\t\thost->mmc->max_seg_size = max_seg_size;\n\t}\n\n\tif (host->dma_rx) {\n\t\tstruct device *dev = host->dma_rx->device->dev;\n\t\tunsigned int max_seg_size = dma_get_max_seg_size(dev);\n\n\t\tif (max_seg_size < host->mmc->max_seg_size)\n\t\t\thost->mmc->max_seg_size = max_seg_size;\n\t}\n\n\treturn 0;\n}\n\nstatic inline struct dma_chan *jz4740_mmc_get_dma_chan(struct jz4740_mmc_host *host,\n\t\t\t\t\t\t       struct mmc_data *data)\n{\n\tif ((data->flags & MMC_DATA_READ) && host->dma_rx)\n\t\treturn host->dma_rx;\n\telse\n\t\treturn host->dma_tx;\n}\n\nstatic void jz4740_mmc_dma_unmap(struct jz4740_mmc_host *host,\n\t\t\t\t struct mmc_data *data)\n{\n\tstruct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);\n\tenum dma_data_direction dir = mmc_get_dma_dir(data);\n\n\tdma_unmap_sg(chan->device->dev, data->sg, data->sg_len, dir);\n\tdata->host_cookie = COOKIE_UNMAPPED;\n}\n\n \nstatic int jz4740_mmc_prepare_dma_data(struct jz4740_mmc_host *host,\n\t\t\t\t       struct mmc_data *data,\n\t\t\t\t       int cookie)\n{\n\tstruct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);\n\tenum dma_data_direction dir = mmc_get_dma_dir(data);\n\tunsigned int sg_count;\n\n\tif (data->host_cookie == COOKIE_PREMAPPED)\n\t\treturn data->sg_count;\n\n\tsg_count = dma_map_sg(chan->device->dev,\n\t\t\tdata->sg,\n\t\t\tdata->sg_len,\n\t\t\tdir);\n\n\tif (!sg_count) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"Failed to map scatterlist for DMA operation\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdata->sg_count = sg_count;\n\tdata->host_cookie = cookie;\n\n\treturn data->sg_count;\n}\n\nstatic int jz4740_mmc_start_dma_transfer(struct jz4740_mmc_host *host,\n\t\t\t\t\t struct mmc_data *data)\n{\n\tstruct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);\n\tstruct dma_async_tx_descriptor *desc;\n\tstruct dma_slave_config conf = {\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.src_maxburst = JZ4740_MMC_FIFO_HALF_SIZE,\n\t\t.dst_maxburst = JZ4740_MMC_FIFO_HALF_SIZE,\n\t};\n\tint sg_count;\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\tconf.direction = DMA_MEM_TO_DEV;\n\t\tconf.dst_addr = host->mem_res->start + JZ_REG_MMC_TXFIFO;\n\t} else {\n\t\tconf.direction = DMA_DEV_TO_MEM;\n\t\tconf.src_addr = host->mem_res->start + JZ_REG_MMC_RXFIFO;\n\t}\n\n\tsg_count = jz4740_mmc_prepare_dma_data(host, data, COOKIE_MAPPED);\n\tif (sg_count < 0)\n\t\treturn sg_count;\n\n\tdmaengine_slave_config(chan, &conf);\n\tdesc = dmaengine_prep_slave_sg(chan, data->sg, sg_count,\n\t\t\tconf.direction,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"Failed to allocate DMA %s descriptor\",\n\t\t\t conf.direction == DMA_MEM_TO_DEV ? \"TX\" : \"RX\");\n\t\tgoto dma_unmap;\n\t}\n\n\tdmaengine_submit(desc);\n\tdma_async_issue_pending(chan);\n\n\treturn 0;\n\ndma_unmap:\n\tif (data->host_cookie == COOKIE_MAPPED)\n\t\tjz4740_mmc_dma_unmap(host, data);\n\treturn -ENOMEM;\n}\n\nstatic void jz4740_mmc_pre_request(struct mmc_host *mmc,\n\t\t\t\t   struct mmc_request *mrq)\n{\n\tstruct jz4740_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!host->use_dma)\n\t\treturn;\n\n\tdata->host_cookie = COOKIE_UNMAPPED;\n\tif (jz4740_mmc_prepare_dma_data(host, data, COOKIE_PREMAPPED) < 0)\n\t\tdata->host_cookie = COOKIE_UNMAPPED;\n}\n\nstatic void jz4740_mmc_post_request(struct mmc_host *mmc,\n\t\t\t\t    struct mmc_request *mrq,\n\t\t\t\t    int err)\n{\n\tstruct jz4740_mmc_host *host = mmc_priv(mmc);\n\tstruct mmc_data *data = mrq->data;\n\n\tif (data && data->host_cookie != COOKIE_UNMAPPED)\n\t\tjz4740_mmc_dma_unmap(host, data);\n\n\tif (err) {\n\t\tstruct dma_chan *chan = jz4740_mmc_get_dma_chan(host, data);\n\n\t\tdmaengine_terminate_all(chan);\n\t}\n}\n\n \n\nstatic void jz4740_mmc_set_irq_enabled(struct jz4740_mmc_host *host,\n\tunsigned int irq, bool enabled)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (enabled)\n\t\thost->irq_mask &= ~irq;\n\telse\n\t\thost->irq_mask |= irq;\n\n\tjz4740_mmc_write_irq_mask(host, host->irq_mask);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void jz4740_mmc_clock_enable(struct jz4740_mmc_host *host,\n\tbool start_transfer)\n{\n\tuint16_t val = JZ_MMC_STRPCL_CLOCK_START;\n\n\tif (start_transfer)\n\t\tval |= JZ_MMC_STRPCL_START_OP;\n\n\twritew(val, host->base + JZ_REG_MMC_STRPCL);\n}\n\nstatic void jz4740_mmc_clock_disable(struct jz4740_mmc_host *host)\n{\n\tuint32_t status;\n\tunsigned int timeout = 1000;\n\n\twritew(JZ_MMC_STRPCL_CLOCK_STOP, host->base + JZ_REG_MMC_STRPCL);\n\tdo {\n\t\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\t} while (status & JZ_MMC_STATUS_CLK_EN && --timeout);\n}\n\nstatic void jz4740_mmc_reset(struct jz4740_mmc_host *host)\n{\n\tuint32_t status;\n\tunsigned int timeout = 1000;\n\n\twritew(JZ_MMC_STRPCL_RESET, host->base + JZ_REG_MMC_STRPCL);\n\tudelay(10);\n\tdo {\n\t\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\t} while (status & JZ_MMC_STATUS_IS_RESETTING && --timeout);\n}\n\nstatic void jz4740_mmc_request_done(struct jz4740_mmc_host *host)\n{\n\tstruct mmc_request *req;\n\tstruct mmc_data *data;\n\n\treq = host->req;\n\tdata = req->data;\n\thost->req = NULL;\n\n\tif (data && data->host_cookie == COOKIE_MAPPED)\n\t\tjz4740_mmc_dma_unmap(host, data);\n\tmmc_request_done(host->mmc, req);\n}\n\nstatic unsigned int jz4740_mmc_poll_irq(struct jz4740_mmc_host *host,\n\tunsigned int irq)\n{\n\tunsigned int timeout = 0x800;\n\tuint32_t status;\n\n\tdo {\n\t\tstatus = jz4740_mmc_read_irq_reg(host);\n\t} while (!(status & irq) && --timeout);\n\n\tif (timeout == 0) {\n\t\tset_bit(0, &host->waiting);\n\t\tmod_timer(&host->timeout_timer,\n\t\t\t  jiffies + msecs_to_jiffies(JZ_MMC_REQ_TIMEOUT_MS));\n\t\tjz4740_mmc_set_irq_enabled(host, irq, true);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic void jz4740_mmc_transfer_check_state(struct jz4740_mmc_host *host,\n\tstruct mmc_data *data)\n{\n\tint status;\n\n\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\tif (status & JZ_MMC_STATUS_WRITE_ERROR_MASK) {\n\t\tif (status & (JZ_MMC_STATUS_TIMEOUT_WRITE)) {\n\t\t\thost->req->cmd->error = -ETIMEDOUT;\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t} else {\n\t\t\thost->req->cmd->error = -EIO;\n\t\t\tdata->error = -EIO;\n\t\t}\n\t} else if (status & JZ_MMC_STATUS_READ_ERROR_MASK) {\n\t\tif (status & (JZ_MMC_STATUS_TIMEOUT_READ)) {\n\t\t\thost->req->cmd->error = -ETIMEDOUT;\n\t\t\tdata->error = -ETIMEDOUT;\n\t\t} else {\n\t\t\thost->req->cmd->error = -EIO;\n\t\t\tdata->error = -EIO;\n\t\t}\n\t}\n}\n\nstatic bool jz4740_mmc_write_data(struct jz4740_mmc_host *host,\n\tstruct mmc_data *data)\n{\n\tstruct sg_mapping_iter *miter = &host->miter;\n\tvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_TXFIFO;\n\tuint32_t *buf;\n\tbool timeout;\n\tsize_t i, j;\n\n\twhile (sg_miter_next(miter)) {\n\t\tbuf = miter->addr;\n\t\ti = miter->length / 4;\n\t\tj = i / 8;\n\t\ti = i & 0x7;\n\t\twhile (j) {\n\t\t\ttimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);\n\t\t\tif (unlikely(timeout))\n\t\t\t\tgoto poll_timeout;\n\n\t\t\twritel(buf[0], fifo_addr);\n\t\t\twritel(buf[1], fifo_addr);\n\t\t\twritel(buf[2], fifo_addr);\n\t\t\twritel(buf[3], fifo_addr);\n\t\t\twritel(buf[4], fifo_addr);\n\t\t\twritel(buf[5], fifo_addr);\n\t\t\twritel(buf[6], fifo_addr);\n\t\t\twritel(buf[7], fifo_addr);\n\t\t\tbuf += 8;\n\t\t\t--j;\n\t\t}\n\t\tif (unlikely(i)) {\n\t\t\ttimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_TXFIFO_WR_REQ);\n\t\t\tif (unlikely(timeout))\n\t\t\t\tgoto poll_timeout;\n\n\t\t\twhile (i) {\n\t\t\t\twritel(*buf, fifo_addr);\n\t\t\t\t++buf;\n\t\t\t\t--i;\n\t\t\t}\n\t\t}\n\t\tdata->bytes_xfered += miter->length;\n\t}\n\tsg_miter_stop(miter);\n\n\treturn false;\n\npoll_timeout:\n\tmiter->consumed = (void *)buf - miter->addr;\n\tdata->bytes_xfered += miter->consumed;\n\tsg_miter_stop(miter);\n\n\treturn true;\n}\n\nstatic bool jz4740_mmc_read_data(struct jz4740_mmc_host *host,\n\t\t\t\tstruct mmc_data *data)\n{\n\tstruct sg_mapping_iter *miter = &host->miter;\n\tvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_RXFIFO;\n\tuint32_t *buf;\n\tuint32_t d;\n\tuint32_t status;\n\tsize_t i, j;\n\tunsigned int timeout;\n\n\twhile (sg_miter_next(miter)) {\n\t\tbuf = miter->addr;\n\t\ti = miter->length;\n\t\tj = i / 32;\n\t\ti = i & 0x1f;\n\t\twhile (j) {\n\t\t\ttimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);\n\t\t\tif (unlikely(timeout))\n\t\t\t\tgoto poll_timeout;\n\n\t\t\tbuf[0] = readl(fifo_addr);\n\t\t\tbuf[1] = readl(fifo_addr);\n\t\t\tbuf[2] = readl(fifo_addr);\n\t\t\tbuf[3] = readl(fifo_addr);\n\t\t\tbuf[4] = readl(fifo_addr);\n\t\t\tbuf[5] = readl(fifo_addr);\n\t\t\tbuf[6] = readl(fifo_addr);\n\t\t\tbuf[7] = readl(fifo_addr);\n\n\t\t\tbuf += 8;\n\t\t\t--j;\n\t\t}\n\n\t\tif (unlikely(i)) {\n\t\t\ttimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_RXFIFO_RD_REQ);\n\t\t\tif (unlikely(timeout))\n\t\t\t\tgoto poll_timeout;\n\n\t\t\twhile (i >= 4) {\n\t\t\t\t*buf++ = readl(fifo_addr);\n\t\t\t\ti -= 4;\n\t\t\t}\n\t\t\tif (unlikely(i > 0)) {\n\t\t\t\td = readl(fifo_addr);\n\t\t\t\tmemcpy(buf, &d, i);\n\t\t\t}\n\t\t}\n\t\tdata->bytes_xfered += miter->length;\n\t}\n\tsg_miter_stop(miter);\n\n\t \n\ttimeout = 1000;\n\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\twhile (!(status & JZ_MMC_STATUS_DATA_FIFO_EMPTY) && --timeout) {\n\t\td = readl(fifo_addr);\n\t\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\t}\n\n\treturn false;\n\npoll_timeout:\n\tmiter->consumed = (void *)buf - miter->addr;\n\tdata->bytes_xfered += miter->consumed;\n\tsg_miter_stop(miter);\n\n\treturn true;\n}\n\nstatic void jz4740_mmc_timeout(struct timer_list *t)\n{\n\tstruct jz4740_mmc_host *host = from_timer(host, t, timeout_timer);\n\n\tif (!test_and_clear_bit(0, &host->waiting))\n\t\treturn;\n\n\tjz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_END_CMD_RES, false);\n\n\thost->req->cmd->error = -ETIMEDOUT;\n\tjz4740_mmc_request_done(host);\n}\n\nstatic void jz4740_mmc_read_response(struct jz4740_mmc_host *host,\n\tstruct mmc_command *cmd)\n{\n\tint i;\n\tuint16_t tmp;\n\tvoid __iomem *fifo_addr = host->base + JZ_REG_MMC_RESP_FIFO;\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\ttmp = readw(fifo_addr);\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\tcmd->resp[i] = tmp << 24;\n\t\t\ttmp = readw(fifo_addr);\n\t\t\tcmd->resp[i] |= tmp << 8;\n\t\t\ttmp = readw(fifo_addr);\n\t\t\tcmd->resp[i] |= tmp >> 8;\n\t\t}\n\t} else {\n\t\tcmd->resp[0] = readw(fifo_addr) << 24;\n\t\tcmd->resp[0] |= readw(fifo_addr) << 8;\n\t\tcmd->resp[0] |= readw(fifo_addr) & 0xff;\n\t}\n}\n\nstatic void jz4740_mmc_send_command(struct jz4740_mmc_host *host,\n\tstruct mmc_command *cmd)\n{\n\tuint32_t cmdat = host->cmdat;\n\n\thost->cmdat &= ~JZ_MMC_CMDAT_INIT;\n\tjz4740_mmc_clock_disable(host);\n\n\thost->cmd = cmd;\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tcmdat |= JZ_MMC_CMDAT_BUSY;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_R1B:\n\tcase MMC_RSP_R1:\n\t\tcmdat |= JZ_MMC_CMDAT_RSP_R1;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tcmdat |= JZ_MMC_CMDAT_RSP_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tcmdat |= JZ_MMC_CMDAT_RSP_R3;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (cmd->data) {\n\t\tcmdat |= JZ_MMC_CMDAT_DATA_EN;\n\t\tif (cmd->data->flags & MMC_DATA_WRITE)\n\t\t\tcmdat |= JZ_MMC_CMDAT_WRITE;\n\t\tif (host->use_dma) {\n\t\t\t \n\t\t\tif (host->version >= JZ_MMC_JZ4780) {\n\t\t\t\twritel(JZ_MMC_DMAC_DMA_EN | JZ_MMC_DMAC_DMA_SEL,\n\t\t\t\t       host->base + JZ_REG_MMC_DMAC);\n\t\t\t} else {\n\t\t\t\tcmdat |= JZ_MMC_CMDAT_DMA_EN;\n\t\t\t}\n\t\t} else if (host->version >= JZ_MMC_JZ4780) {\n\t\t\twritel(0, host->base + JZ_REG_MMC_DMAC);\n\t\t}\n\n\t\twritew(cmd->data->blksz, host->base + JZ_REG_MMC_BLKLEN);\n\t\twritew(cmd->data->blocks, host->base + JZ_REG_MMC_NOB);\n\t}\n\n\twriteb(cmd->opcode, host->base + JZ_REG_MMC_CMD);\n\twritel(cmd->arg, host->base + JZ_REG_MMC_ARG);\n\twritel(cmdat, host->base + JZ_REG_MMC_CMDAT);\n\n\tjz4740_mmc_clock_enable(host, 1);\n}\n\nstatic void jz_mmc_prepare_data_transfer(struct jz4740_mmc_host *host)\n{\n\tstruct mmc_command *cmd = host->req->cmd;\n\tstruct mmc_data *data = cmd->data;\n\tint direction;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tdirection = SG_MITER_TO_SG;\n\telse\n\t\tdirection = SG_MITER_FROM_SG;\n\n\tsg_miter_start(&host->miter, data->sg, data->sg_len, direction);\n}\n\n\nstatic irqreturn_t jz_mmc_irq_worker(int irq, void *devid)\n{\n\tstruct jz4740_mmc_host *host = (struct jz4740_mmc_host *)devid;\n\tstruct mmc_command *cmd = host->req->cmd;\n\tstruct mmc_request *req = host->req;\n\tstruct mmc_data *data = cmd->data;\n\tbool timeout = false;\n\n\tif (cmd->error)\n\t\thost->state = JZ4740_MMC_STATE_DONE;\n\n\tswitch (host->state) {\n\tcase JZ4740_MMC_STATE_READ_RESPONSE:\n\t\tif (cmd->flags & MMC_RSP_PRESENT)\n\t\t\tjz4740_mmc_read_response(host, cmd);\n\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\tjz_mmc_prepare_data_transfer(host);\n\t\tfallthrough;\n\n\tcase JZ4740_MMC_STATE_TRANSFER_DATA:\n\t\tif (host->use_dma) {\n\t\t\t \n\t\t\ttimeout = jz4740_mmc_start_dma_transfer(host, data);\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t} else if (data->flags & MMC_DATA_READ)\n\t\t\t \n\t\t\ttimeout = jz4740_mmc_read_data(host, data);\n\t\telse\n\t\t\ttimeout = jz4740_mmc_write_data(host, data);\n\n\t\tif (unlikely(timeout)) {\n\t\t\thost->state = JZ4740_MMC_STATE_TRANSFER_DATA;\n\t\t\tbreak;\n\t\t}\n\n\t\tjz4740_mmc_transfer_check_state(host, data);\n\n\t\ttimeout = jz4740_mmc_poll_irq(host, JZ_MMC_IRQ_DATA_TRAN_DONE);\n\t\tif (unlikely(timeout)) {\n\t\t\thost->state = JZ4740_MMC_STATE_SEND_STOP;\n\t\t\tbreak;\n\t\t}\n\t\tjz4740_mmc_write_irq_reg(host, JZ_MMC_IRQ_DATA_TRAN_DONE);\n\t\tfallthrough;\n\n\tcase JZ4740_MMC_STATE_SEND_STOP:\n\t\tif (!req->stop)\n\t\t\tbreak;\n\n\t\tjz4740_mmc_send_command(host, req->stop);\n\n\t\tif (mmc_resp_type(req->stop) & MMC_RSP_BUSY) {\n\t\t\ttimeout = jz4740_mmc_poll_irq(host,\n\t\t\t\t\t\t      JZ_MMC_IRQ_PRG_DONE);\n\t\t\tif (timeout) {\n\t\t\t\thost->state = JZ4740_MMC_STATE_DONE;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfallthrough;\n\n\tcase JZ4740_MMC_STATE_DONE:\n\t\tbreak;\n\t}\n\n\tif (!timeout)\n\t\tjz4740_mmc_request_done(host);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t jz_mmc_irq(int irq, void *devid)\n{\n\tstruct jz4740_mmc_host *host = devid;\n\tstruct mmc_command *cmd = host->cmd;\n\tuint32_t irq_reg, status, tmp;\n\n\tstatus = readl(host->base + JZ_REG_MMC_STATUS);\n\tirq_reg = jz4740_mmc_read_irq_reg(host);\n\n\ttmp = irq_reg;\n\tirq_reg &= ~host->irq_mask;\n\n\ttmp &= ~(JZ_MMC_IRQ_TXFIFO_WR_REQ | JZ_MMC_IRQ_RXFIFO_RD_REQ |\n\t\tJZ_MMC_IRQ_PRG_DONE | JZ_MMC_IRQ_DATA_TRAN_DONE);\n\n\tif (tmp != irq_reg)\n\t\tjz4740_mmc_write_irq_reg(host, tmp & ~irq_reg);\n\n\tif (irq_reg & JZ_MMC_IRQ_SDIO) {\n\t\tjz4740_mmc_write_irq_reg(host, JZ_MMC_IRQ_SDIO);\n\t\tmmc_signal_sdio_irq(host->mmc);\n\t\tirq_reg &= ~JZ_MMC_IRQ_SDIO;\n\t}\n\n\tif (host->req && cmd && irq_reg) {\n\t\tif (test_and_clear_bit(0, &host->waiting)) {\n\t\t\tdel_timer(&host->timeout_timer);\n\n\t\t\tif (status & JZ_MMC_STATUS_TIMEOUT_RES) {\n\t\t\t\tcmd->error = -ETIMEDOUT;\n\t\t\t} else if (status & JZ_MMC_STATUS_CRC_RES_ERR) {\n\t\t\t\tcmd->error = -EIO;\n\t\t\t} else if (status & (JZ_MMC_STATUS_CRC_READ_ERROR |\n\t\t\t\t    JZ_MMC_STATUS_CRC_WRITE_ERROR)) {\n\t\t\t\tif (cmd->data)\n\t\t\t\t\tcmd->data->error = -EIO;\n\t\t\t\tcmd->error = -EIO;\n\t\t\t}\n\n\t\t\tjz4740_mmc_set_irq_enabled(host, irq_reg, false);\n\t\t\tjz4740_mmc_write_irq_reg(host, irq_reg);\n\n\t\t\treturn IRQ_WAKE_THREAD;\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int jz4740_mmc_set_clock_rate(struct jz4740_mmc_host *host, int rate)\n{\n\tint div = 0;\n\tint real_rate;\n\n\tjz4740_mmc_clock_disable(host);\n\tclk_set_rate(host->clk, host->mmc->f_max);\n\n\treal_rate = clk_get_rate(host->clk);\n\n\twhile (real_rate > rate && div < 7) {\n\t\t++div;\n\t\treal_rate >>= 1;\n\t}\n\n\twritew(div, host->base + JZ_REG_MMC_CLKRT);\n\n\tif (real_rate > 25000000) {\n\t\tif (host->version >= JZ_MMC_JZ4780) {\n\t\t\twritel(JZ_MMC_LPM_DRV_RISING_QTR_PHASE_DLY |\n\t\t\t\t   JZ_MMC_LPM_SMP_RISING_QTR_OR_HALF_PHASE_DLY |\n\t\t\t\t   JZ_MMC_LPM_LOW_POWER_MODE_EN,\n\t\t\t\t   host->base + JZ_REG_MMC_LPM);\n\t\t} else if (host->version >= JZ_MMC_JZ4760) {\n\t\t\twritel(JZ_MMC_LPM_DRV_RISING |\n\t\t\t\t   JZ_MMC_LPM_LOW_POWER_MODE_EN,\n\t\t\t\t   host->base + JZ_REG_MMC_LPM);\n\t\t} else if (host->version >= JZ_MMC_JZ4725B)\n\t\t\twritel(JZ_MMC_LPM_LOW_POWER_MODE_EN,\n\t\t\t\t   host->base + JZ_REG_MMC_LPM);\n\t}\n\n\treturn real_rate;\n}\n\nstatic void jz4740_mmc_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct jz4740_mmc_host *host = mmc_priv(mmc);\n\n\thost->req = req;\n\n\tjz4740_mmc_write_irq_reg(host, ~0);\n\tjz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_END_CMD_RES, true);\n\n\thost->state = JZ4740_MMC_STATE_READ_RESPONSE;\n\tset_bit(0, &host->waiting);\n\tmod_timer(&host->timeout_timer,\n\t\t  jiffies + msecs_to_jiffies(JZ_MMC_REQ_TIMEOUT_MS));\n\tjz4740_mmc_send_command(host, req->cmd);\n}\n\nstatic void jz4740_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct jz4740_mmc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tif (ios->clock)\n\t\tjz4740_mmc_set_clock_rate(host, ios->clock);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_UP:\n\t\tjz4740_mmc_reset(host);\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\n\t\thost->cmdat |= JZ_MMC_CMDAT_INIT;\n\t\tclk_prepare_enable(host->clk);\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && !host->vqmmc_enabled) {\n\t\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\t\tif (ret)\n\t\t\t\tdev_err(&host->pdev->dev, \"Failed to set vqmmc power!\\n\");\n\t\t\telse\n\t\t\t\thost->vqmmc_enabled = true;\n\t\t}\n\t\tbreak;\n\tcase MMC_POWER_OFF:\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\t\tif (!IS_ERR(mmc->supply.vqmmc) && host->vqmmc_enabled) {\n\t\t\tregulator_disable(mmc->supply.vqmmc);\n\t\t\thost->vqmmc_enabled = false;\n\t\t}\n\t\tclk_disable_unprepare(host->clk);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\thost->cmdat &= ~JZ_MMC_CMDAT_BUS_WIDTH_MASK;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\thost->cmdat &= ~JZ_MMC_CMDAT_BUS_WIDTH_MASK;\n\t\thost->cmdat |= JZ_MMC_CMDAT_BUS_WIDTH_4BIT;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\thost->cmdat &= ~JZ_MMC_CMDAT_BUS_WIDTH_MASK;\n\t\thost->cmdat |= JZ_MMC_CMDAT_BUS_WIDTH_8BIT;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void jz4740_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct jz4740_mmc_host *host = mmc_priv(mmc);\n\tjz4740_mmc_set_irq_enabled(host, JZ_MMC_IRQ_SDIO, enable);\n}\n\nstatic int jz4740_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tint ret;\n\n\t \n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\treturn ret < 0 ? ret : 0;\n\t}\n\n\t \n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}\n\nstatic const struct mmc_host_ops jz4740_mmc_ops = {\n\t.request\t= jz4740_mmc_request,\n\t.pre_req\t= jz4740_mmc_pre_request,\n\t.post_req\t= jz4740_mmc_post_request,\n\t.set_ios\t= jz4740_mmc_set_ios,\n\t.get_ro\t\t= mmc_gpio_get_ro,\n\t.get_cd\t\t= mmc_gpio_get_cd,\n\t.enable_sdio_irq = jz4740_mmc_enable_sdio_irq,\n\t.start_signal_voltage_switch = jz4740_voltage_switch,\n};\n\nstatic const struct of_device_id jz4740_mmc_of_match[] = {\n\t{ .compatible = \"ingenic,jz4740-mmc\", .data = (void *) JZ_MMC_JZ4740 },\n\t{ .compatible = \"ingenic,jz4725b-mmc\", .data = (void *)JZ_MMC_JZ4725B },\n\t{ .compatible = \"ingenic,jz4760-mmc\", .data = (void *) JZ_MMC_JZ4760 },\n\t{ .compatible = \"ingenic,jz4775-mmc\", .data = (void *) JZ_MMC_JZ4780 },\n\t{ .compatible = \"ingenic,jz4780-mmc\", .data = (void *) JZ_MMC_JZ4780 },\n\t{ .compatible = \"ingenic,x1000-mmc\", .data = (void *) JZ_MMC_X1000 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, jz4740_mmc_of_match);\n\nstatic int jz4740_mmc_probe(struct platform_device* pdev)\n{\n\tint ret;\n\tstruct mmc_host *mmc;\n\tstruct jz4740_mmc_host *host;\n\tconst struct of_device_id *match;\n\n\tmmc = mmc_alloc_host(sizeof(struct jz4740_mmc_host), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"Failed to alloc mmc host structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thost = mmc_priv(mmc);\n\n\tmatch = of_match_device(jz4740_mmc_of_match, &pdev->dev);\n\tif (match) {\n\t\thost->version = (enum jz4740_mmc_version)match->data;\n\t} else {\n\t\t \n\t\thost->version = JZ_MMC_JZ4740;\n\t}\n\n\tret = mmc_of_parse(mmc);\n\tif (ret) {\n\t\tdev_err_probe(&pdev->dev, ret, \"could not parse device properties\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\tmmc_regulator_get_supply(mmc);\n\n\thost->irq = platform_get_irq(pdev, 0);\n\tif (host->irq < 0) {\n\t\tret = host->irq;\n\t\tgoto err_free_host;\n\t}\n\n\thost->clk = devm_clk_get(&pdev->dev, \"mmc\");\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\tdev_err(&pdev->dev, \"Failed to get mmc clock\\n\");\n\t\tgoto err_free_host;\n\t}\n\n\thost->base = devm_platform_get_and_ioremap_resource(pdev, 0, &host->mem_res);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto err_free_host;\n\t}\n\n\tmmc->ops = &jz4740_mmc_ops;\n\tif (!mmc->f_max)\n\t\tmmc->f_max = JZ_MMC_CLK_RATE;\n\n\t \n\tif (host->version == JZ_MMC_JZ4760 && mmc->f_max > JZ_MMC_CLK_RATE)\n\t\tmmc->f_max = JZ_MMC_CLK_RATE;\n\n\tmmc->f_min = mmc->f_max / 128;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\t \n\tmmc->max_busy_timeout = JZ_MMC_REQ_TIMEOUT_MS;\n\n\tmmc->max_blk_size = (1 << 10) - 1;\n\tmmc->max_blk_count = (1 << 15) - 1;\n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\n\tmmc->max_segs = 128;\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\thost->mmc = mmc;\n\thost->pdev = pdev;\n\tspin_lock_init(&host->lock);\n\thost->irq_mask = ~0;\n\n\tjz4740_mmc_reset(host);\n\n\tret = request_threaded_irq(host->irq, jz_mmc_irq, jz_mmc_irq_worker, 0,\n\t\t\tdev_name(&pdev->dev), host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to request irq: %d\\n\", ret);\n\t\tgoto err_free_host;\n\t}\n\n\tjz4740_mmc_clock_disable(host);\n\ttimer_setup(&host->timeout_timer, jz4740_mmc_timeout, 0);\n\n\tret = jz4740_mmc_acquire_dma_channels(host);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto err_free_irq;\n\thost->use_dma = !ret;\n\n\tplatform_set_drvdata(pdev, host);\n\tret = mmc_add_host(mmc);\n\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add mmc host: %d\\n\", ret);\n\t\tgoto err_release_dma;\n\t}\n\tdev_info(&pdev->dev, \"Ingenic SD/MMC card driver registered\\n\");\n\n\tdev_info(&pdev->dev, \"Using %s, %d-bit mode\\n\",\n\t\t host->use_dma ? \"DMA\" : \"PIO\",\n\t\t (mmc->caps & MMC_CAP_8_BIT_DATA) ? 8 :\n\t\t ((mmc->caps & MMC_CAP_4_BIT_DATA) ? 4 : 1));\n\n\treturn 0;\n\nerr_release_dma:\n\tif (host->use_dma)\n\t\tjz4740_mmc_release_dma_channels(host);\nerr_free_irq:\n\tfree_irq(host->irq, host);\nerr_free_host:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void jz4740_mmc_remove(struct platform_device *pdev)\n{\n\tstruct jz4740_mmc_host *host = platform_get_drvdata(pdev);\n\n\tdel_timer_sync(&host->timeout_timer);\n\tjz4740_mmc_set_irq_enabled(host, 0xff, false);\n\tjz4740_mmc_reset(host);\n\n\tmmc_remove_host(host->mmc);\n\n\tfree_irq(host->irq, host);\n\n\tif (host->use_dma)\n\t\tjz4740_mmc_release_dma_channels(host);\n\n\tmmc_free_host(host->mmc);\n}\n\nstatic int jz4740_mmc_suspend(struct device *dev)\n{\n\treturn pinctrl_pm_select_sleep_state(dev);\n}\n\nstatic int jz4740_mmc_resume(struct device *dev)\n{\n\treturn pinctrl_select_default_state(dev);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(jz4740_mmc_pm_ops, jz4740_mmc_suspend,\n\t\t\t\tjz4740_mmc_resume);\n\nstatic struct platform_driver jz4740_mmc_driver = {\n\t.probe = jz4740_mmc_probe,\n\t.remove_new = jz4740_mmc_remove,\n\t.driver = {\n\t\t.name = \"jz4740-mmc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(jz4740_mmc_of_match),\n\t\t.pm = pm_sleep_ptr(&jz4740_mmc_pm_ops),\n\t},\n};\n\nmodule_platform_driver(jz4740_mmc_driver);\n\nMODULE_DESCRIPTION(\"JZ4740 SD/MMC controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Lars-Peter Clausen <lars@metafoo.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}