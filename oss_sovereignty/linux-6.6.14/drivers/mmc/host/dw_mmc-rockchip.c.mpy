{
  "module_name": "dw_mmc-rockchip.c",
  "hash_id": "2edc3d3c9700cab740bc39f1325956be2057626c08280ff1d709ef39d8f16449",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc-rockchip.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/mmc/host.h>\n#include <linux/of_address.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"dw_mmc.h\"\n#include \"dw_mmc-pltfm.h\"\n\n#define RK3288_CLKGEN_DIV\t2\n\nstatic const unsigned int freqs[] = { 100000, 200000, 300000, 400000 };\n\nstruct dw_mci_rockchip_priv_data {\n\tstruct clk\t\t*drv_clk;\n\tstruct clk\t\t*sample_clk;\n\tint\t\t\tdefault_sample_phase;\n\tint\t\t\tnum_phases;\n};\n\nstatic void dw_mci_rk3288_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tstruct dw_mci_rockchip_priv_data *priv = host->priv;\n\tint ret;\n\tunsigned int cclkin;\n\tu32 bus_hz;\n\n\tif (ios->clock == 0)\n\t\treturn;\n\n\t \n\tif (ios->bus_width == MMC_BUS_WIDTH_8 &&\n\t    ios->timing == MMC_TIMING_MMC_DDR52)\n\t\tcclkin = 2 * ios->clock * RK3288_CLKGEN_DIV;\n\telse\n\t\tcclkin = ios->clock * RK3288_CLKGEN_DIV;\n\n\tret = clk_set_rate(host->ciu_clk, cclkin);\n\tif (ret)\n\t\tdev_warn(host->dev, \"failed to set rate %uHz err: %d\\n\", cclkin, ret);\n\n\tbus_hz = clk_get_rate(host->ciu_clk) / RK3288_CLKGEN_DIV;\n\tif (bus_hz != host->bus_hz) {\n\t\thost->bus_hz = bus_hz;\n\t\t \n\t\thost->current_speed = 0;\n\t}\n\n\t \n\tif (!IS_ERR(priv->sample_clk) && ios->timing <= MMC_TIMING_SD_HS)\n\t\tclk_set_phase(priv->sample_clk, priv->default_sample_phase);\n\n\t \n\tif (!IS_ERR(priv->drv_clk)) {\n\t\tint phase;\n\n\t\t \n\t\tphase = 90;\n\n\t\tswitch (ios->timing) {\n\t\tcase MMC_TIMING_MMC_DDR52:\n\t\t\t \n\t\t\tif (ios->bus_width == MMC_BUS_WIDTH_8)\n\t\t\t\tphase = 180;\n\t\t\tbreak;\n\t\tcase MMC_TIMING_UHS_SDR104:\n\t\tcase MMC_TIMING_MMC_HS200:\n\t\t\t \n\t\t\tphase = 180;\n\t\t\tbreak;\n\t\t}\n\n\t\tclk_set_phase(priv->drv_clk, phase);\n\t}\n}\n\n#define TUNING_ITERATION_TO_PHASE(i, num_phases) \\\n\t\t(DIV_ROUND_UP((i) * 360, num_phases))\n\nstatic int dw_mci_rk3288_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\n{\n\tstruct dw_mci *host = slot->host;\n\tstruct dw_mci_rockchip_priv_data *priv = host->priv;\n\tstruct mmc_host *mmc = slot->mmc;\n\tint ret = 0;\n\tint i;\n\tbool v, prev_v = 0, first_v;\n\tstruct range_t {\n\t\tint start;\n\t\tint end;  \n\t};\n\tstruct range_t *ranges;\n\tunsigned int range_count = 0;\n\tint longest_range_len = -1;\n\tint longest_range = -1;\n\tint middle_phase;\n\n\tif (IS_ERR(priv->sample_clk)) {\n\t\tdev_err(host->dev, \"Tuning clock (sample_clk) not defined.\\n\");\n\t\treturn -EIO;\n\t}\n\n\tranges = kmalloc_array(priv->num_phases / 2 + 1,\n\t\t\t       sizeof(*ranges), GFP_KERNEL);\n\tif (!ranges)\n\t\treturn -ENOMEM;\n\n\t \n\tfor (i = 0; i < priv->num_phases; ) {\n\t\tclk_set_phase(priv->sample_clk,\n\t\t\t      TUNING_ITERATION_TO_PHASE(i, priv->num_phases));\n\n\t\tv = !mmc_send_tuning(mmc, opcode, NULL);\n\n\t\tif (i == 0)\n\t\t\tfirst_v = v;\n\n\t\tif ((!prev_v) && v) {\n\t\t\trange_count++;\n\t\t\tranges[range_count-1].start = i;\n\t\t}\n\t\tif (v) {\n\t\t\tranges[range_count-1].end = i;\n\t\t\ti++;\n\t\t} else if (i == priv->num_phases - 1) {\n\t\t\t \n\t\t\ti++;\n\t\t} else {\n\t\t\t \n\t\t\ti += DIV_ROUND_UP(20 * priv->num_phases, 360);\n\n\t\t\t \n\t\t\tif (i >= priv->num_phases)\n\t\t\t\ti = priv->num_phases - 1;\n\t\t}\n\n\t\tprev_v = v;\n\t}\n\n\tif (range_count == 0) {\n\t\tdev_warn(host->dev, \"All phases bad!\");\n\t\tret = -EIO;\n\t\tgoto free;\n\t}\n\n\t \n\tif ((range_count > 1) && first_v && v) {\n\t\tranges[0].start = ranges[range_count-1].start;\n\t\trange_count--;\n\t}\n\n\tif (ranges[0].start == 0 && ranges[0].end == priv->num_phases - 1) {\n\t\tclk_set_phase(priv->sample_clk, priv->default_sample_phase);\n\t\tdev_info(host->dev, \"All phases work, using default phase %d.\",\n\t\t\t priv->default_sample_phase);\n\t\tgoto free;\n\t}\n\n\t \n\tfor (i = 0; i < range_count; i++) {\n\t\tint len = (ranges[i].end - ranges[i].start + 1);\n\n\t\tif (len < 0)\n\t\t\tlen += priv->num_phases;\n\n\t\tif (longest_range_len < len) {\n\t\t\tlongest_range_len = len;\n\t\t\tlongest_range = i;\n\t\t}\n\n\t\tdev_dbg(host->dev, \"Good phase range %d-%d (%d len)\\n\",\n\t\t\tTUNING_ITERATION_TO_PHASE(ranges[i].start,\n\t\t\t\t\t\t  priv->num_phases),\n\t\t\tTUNING_ITERATION_TO_PHASE(ranges[i].end,\n\t\t\t\t\t\t  priv->num_phases),\n\t\t\tlen\n\t\t);\n\t}\n\n\tdev_dbg(host->dev, \"Best phase range %d-%d (%d len)\\n\",\n\t\tTUNING_ITERATION_TO_PHASE(ranges[longest_range].start,\n\t\t\t\t\t  priv->num_phases),\n\t\tTUNING_ITERATION_TO_PHASE(ranges[longest_range].end,\n\t\t\t\t\t  priv->num_phases),\n\t\tlongest_range_len\n\t);\n\n\tmiddle_phase = ranges[longest_range].start + longest_range_len / 2;\n\tmiddle_phase %= priv->num_phases;\n\tdev_info(host->dev, \"Successfully tuned phase to %d\\n\",\n\t\t TUNING_ITERATION_TO_PHASE(middle_phase, priv->num_phases));\n\n\tclk_set_phase(priv->sample_clk,\n\t\t      TUNING_ITERATION_TO_PHASE(middle_phase,\n\t\t\t\t\t\tpriv->num_phases));\n\nfree:\n\tkfree(ranges);\n\treturn ret;\n}\n\nstatic int dw_mci_rk3288_parse_dt(struct dw_mci *host)\n{\n\tstruct device_node *np = host->dev->of_node;\n\tstruct dw_mci_rockchip_priv_data *priv;\n\n\tpriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_u32(np, \"rockchip,desired-num-phases\",\n\t\t\t\t\t&priv->num_phases))\n\t\tpriv->num_phases = 360;\n\n\tif (of_property_read_u32(np, \"rockchip,default-sample-phase\",\n\t\t\t\t\t&priv->default_sample_phase))\n\t\tpriv->default_sample_phase = 0;\n\n\tpriv->drv_clk = devm_clk_get(host->dev, \"ciu-drive\");\n\tif (IS_ERR(priv->drv_clk))\n\t\tdev_dbg(host->dev, \"ciu-drive not available\\n\");\n\n\tpriv->sample_clk = devm_clk_get(host->dev, \"ciu-sample\");\n\tif (IS_ERR(priv->sample_clk))\n\t\tdev_dbg(host->dev, \"ciu-sample not available\\n\");\n\n\thost->priv = priv;\n\n\treturn 0;\n}\n\nstatic int dw_mci_rockchip_init(struct dw_mci *host)\n{\n\tint ret, i;\n\n\t \n\thost->sdio_id0 = 8;\n\n\tif (of_device_is_compatible(host->dev->of_node, \"rockchip,rk3288-dw-mshc\")) {\n\t\thost->bus_hz /= RK3288_CLKGEN_DIV;\n\n\t\t \n\n\t\tfor (i = 0; i < ARRAY_SIZE(freqs); i++) {\n\t\t\tret = clk_round_rate(host->ciu_clk, freqs[i] * RK3288_CLKGEN_DIV);\n\t\t\tif (ret > 0) {\n\t\t\t\thost->minimum_speed = ret / RK3288_CLKGEN_DIV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (ret < 0)\n\t\t\tdev_warn(host->dev, \"no valid minimum freq: %d\\n\", ret);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_mci_drv_data rk2928_drv_data = {\n\t.init\t\t\t= dw_mci_rockchip_init,\n};\n\nstatic const struct dw_mci_drv_data rk3288_drv_data = {\n\t.common_caps\t\t= MMC_CAP_CMD23,\n\t.set_ios\t\t= dw_mci_rk3288_set_ios,\n\t.execute_tuning\t\t= dw_mci_rk3288_execute_tuning,\n\t.parse_dt\t\t= dw_mci_rk3288_parse_dt,\n\t.init\t\t\t= dw_mci_rockchip_init,\n};\n\nstatic const struct of_device_id dw_mci_rockchip_match[] = {\n\t{ .compatible = \"rockchip,rk2928-dw-mshc\",\n\t\t.data = &rk2928_drv_data },\n\t{ .compatible = \"rockchip,rk3288-dw-mshc\",\n\t\t.data = &rk3288_drv_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_mci_rockchip_match);\n\nstatic int dw_mci_rockchip_probe(struct platform_device *pdev)\n{\n\tconst struct dw_mci_drv_data *drv_data;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tif (!pdev->dev.of_node)\n\t\treturn -ENODEV;\n\n\tmatch = of_match_node(dw_mci_rockchip_match, pdev->dev.of_node);\n\tdrv_data = match->data;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\n\tret = dw_mci_pltfm_register(pdev, drv_data);\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_set_suspended(&pdev->dev);\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t\treturn ret;\n\t}\n\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void dw_mci_rockchip_remove(struct platform_device *pdev)\n{\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tdw_mci_pltfm_remove(pdev);\n}\n\nstatic const struct dev_pm_ops dw_mci_rockchip_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(dw_mci_runtime_suspend,\n\t\t\t   dw_mci_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver dw_mci_rockchip_pltfm_driver = {\n\t.probe\t\t= dw_mci_rockchip_probe,\n\t.remove_new\t= dw_mci_rockchip_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"dwmmc_rockchip\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= dw_mci_rockchip_match,\n\t\t.pm\t\t= &dw_mci_rockchip_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dw_mci_rockchip_pltfm_driver);\n\nMODULE_AUTHOR(\"Addy Ke <addy.ke@rock-chips.com>\");\nMODULE_DESCRIPTION(\"Rockchip Specific DW-MSHC Driver Extension\");\nMODULE_ALIAS(\"platform:dwmmc_rockchip\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}