{
  "module_name": "litex_mmc.c",
  "hash_id": "8bd31cba5dfe5058f6d7f33494728051f4878f6b81136288269d73e8c93bb67b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/litex_mmc.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/litex.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n\n#define LITEX_PHY_CARDDETECT  0x00\n#define LITEX_PHY_CLOCKERDIV  0x04\n#define LITEX_PHY_INITIALIZE  0x08\n#define LITEX_PHY_WRITESTATUS 0x0C\n#define LITEX_CORE_CMDARG     0x00\n#define LITEX_CORE_CMDCMD     0x04\n#define LITEX_CORE_CMDSND     0x08\n#define LITEX_CORE_CMDRSP     0x0C\n#define LITEX_CORE_CMDEVT     0x1C\n#define LITEX_CORE_DATEVT     0x20\n#define LITEX_CORE_BLKLEN     0x24\n#define LITEX_CORE_BLKCNT     0x28\n#define LITEX_BLK2MEM_BASE    0x00\n#define LITEX_BLK2MEM_LEN     0x08\n#define LITEX_BLK2MEM_ENA     0x0C\n#define LITEX_BLK2MEM_DONE    0x10\n#define LITEX_BLK2MEM_LOOP    0x14\n#define LITEX_MEM2BLK_BASE    0x00\n#define LITEX_MEM2BLK_LEN     0x08\n#define LITEX_MEM2BLK_ENA     0x0C\n#define LITEX_MEM2BLK_DONE    0x10\n#define LITEX_MEM2BLK_LOOP    0x14\n#define LITEX_MEM2BLK         0x18\n#define LITEX_IRQ_STATUS      0x00\n#define LITEX_IRQ_PENDING     0x04\n#define LITEX_IRQ_ENABLE      0x08\n\n#define SD_CTL_DATA_XFER_NONE  0\n#define SD_CTL_DATA_XFER_READ  1\n#define SD_CTL_DATA_XFER_WRITE 2\n\n#define SD_CTL_RESP_NONE       0\n#define SD_CTL_RESP_SHORT      1\n#define SD_CTL_RESP_LONG       2\n#define SD_CTL_RESP_SHORT_BUSY 3\n\n#define SD_BIT_DONE    BIT(0)\n#define SD_BIT_WR_ERR  BIT(1)\n#define SD_BIT_TIMEOUT BIT(2)\n#define SD_BIT_CRC_ERR BIT(3)\n\n#define SD_SLEEP_US       5\n#define SD_TIMEOUT_US 20000\n\n#define SDIRQ_CARD_DETECT    1\n#define SDIRQ_SD_TO_MEM_DONE 2\n#define SDIRQ_MEM_TO_SD_DONE 4\n#define SDIRQ_CMD_DONE       8\n\nstruct litex_mmc_host {\n\tstruct mmc_host *mmc;\n\n\tvoid __iomem *sdphy;\n\tvoid __iomem *sdcore;\n\tvoid __iomem *sdreader;\n\tvoid __iomem *sdwriter;\n\tvoid __iomem *sdirq;\n\n\tvoid *buffer;\n\tsize_t buf_size;\n\tdma_addr_t dma;\n\n\tstruct completion cmd_done;\n\tint irq;\n\n\tunsigned int ref_clk;\n\tunsigned int sd_clk;\n\n\tu32 resp[4];\n\tu16 rca;\n\n\tbool is_bus_width_set;\n\tbool app_cmd;\n};\n\nstatic int litex_mmc_sdcard_wait_done(void __iomem *reg, struct device *dev)\n{\n\tu8 evt;\n\tint ret;\n\n\tret = readx_poll_timeout(litex_read8, reg, evt, evt & SD_BIT_DONE,\n\t\t\t\t SD_SLEEP_US, SD_TIMEOUT_US);\n\tif (ret)\n\t\treturn ret;\n\tif (evt == SD_BIT_DONE)\n\t\treturn 0;\n\tif (evt & SD_BIT_WR_ERR)\n\t\treturn -EIO;\n\tif (evt & SD_BIT_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\tif (evt & SD_BIT_CRC_ERR)\n\t\treturn -EILSEQ;\n\tdev_err(dev, \"%s: unknown error (evt=%x)\\n\", __func__, evt);\n\treturn -EINVAL;\n}\n\nstatic int litex_mmc_send_cmd(struct litex_mmc_host *host,\n\t\t\t      u8 cmd, u32 arg, u8 response_len, u8 transfer)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\tvoid __iomem *reg;\n\tint ret;\n\tu8 evt;\n\n\tlitex_write32(host->sdcore + LITEX_CORE_CMDARG, arg);\n\tlitex_write32(host->sdcore + LITEX_CORE_CMDCMD,\n\t\t      cmd << 8 | transfer << 5 | response_len);\n\tlitex_write8(host->sdcore + LITEX_CORE_CMDSND, 1);\n\n\t \n\tif (host->irq > 0 &&\n\t    (transfer != SD_CTL_DATA_XFER_NONE ||\n\t     response_len == SD_CTL_RESP_SHORT_BUSY)) {\n\t\treinit_completion(&host->cmd_done);\n\t\tlitex_write32(host->sdirq + LITEX_IRQ_ENABLE,\n\t\t\t      SDIRQ_CMD_DONE | SDIRQ_CARD_DETECT);\n\t\twait_for_completion(&host->cmd_done);\n\t}\n\n\tret = litex_mmc_sdcard_wait_done(host->sdcore + LITEX_CORE_CMDEVT, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Command (cmd %d) error, status %d\\n\", cmd, ret);\n\t\treturn ret;\n\t}\n\n\tif (response_len != SD_CTL_RESP_NONE) {\n\t\t \n\t\tmemcpy_fromio(host->resp,\n\t\t\t      host->sdcore + LITEX_CORE_CMDRSP, 0x10);\n\t}\n\n\tif (!host->app_cmd && cmd == SD_SEND_RELATIVE_ADDR)\n\t\thost->rca = (host->resp[3] >> 16);\n\n\thost->app_cmd = (cmd == MMC_APP_CMD);\n\n\tif (transfer == SD_CTL_DATA_XFER_NONE)\n\t\treturn ret;  \n\n\tret = litex_mmc_sdcard_wait_done(host->sdcore + LITEX_CORE_DATEVT, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Data xfer (cmd %d) error, status %d\\n\", cmd, ret);\n\t\treturn ret;\n\t}\n\n\t \n\treg = (transfer == SD_CTL_DATA_XFER_READ) ?\n\t\thost->sdreader + LITEX_BLK2MEM_DONE :\n\t\thost->sdwriter + LITEX_MEM2BLK_DONE;\n\tret = readx_poll_timeout(litex_read8, reg, evt, evt & SD_BIT_DONE,\n\t\t\t\t SD_SLEEP_US, SD_TIMEOUT_US);\n\tif (ret)\n\t\tdev_err(dev, \"DMA timeout (cmd %d)\\n\", cmd);\n\n\treturn ret;\n}\n\nstatic int litex_mmc_send_app_cmd(struct litex_mmc_host *host)\n{\n\treturn litex_mmc_send_cmd(host, MMC_APP_CMD, host->rca << 16,\n\t\t\t\t  SD_CTL_RESP_SHORT, SD_CTL_DATA_XFER_NONE);\n}\n\nstatic int litex_mmc_send_set_bus_w_cmd(struct litex_mmc_host *host, u32 width)\n{\n\treturn litex_mmc_send_cmd(host, SD_APP_SET_BUS_WIDTH, width,\n\t\t\t\t  SD_CTL_RESP_SHORT, SD_CTL_DATA_XFER_NONE);\n}\n\nstatic int litex_mmc_set_bus_width(struct litex_mmc_host *host)\n{\n\tbool app_cmd_sent;\n\tint ret;\n\n\tif (host->is_bus_width_set)\n\t\treturn 0;\n\n\t \n\tapp_cmd_sent = host->app_cmd;  \n\tif (!app_cmd_sent) {\n\t\tret = litex_mmc_send_app_cmd(host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = litex_mmc_send_set_bus_w_cmd(host, MMC_BUS_WIDTH_4);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (app_cmd_sent) {\n\t\tret = litex_mmc_send_app_cmd(host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\thost->is_bus_width_set = true;\n\n\treturn 0;\n}\n\nstatic int litex_mmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct litex_mmc_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tif (!mmc_card_is_removable(mmc))\n\t\treturn 1;\n\n\tret = !litex_read8(host->sdphy + LITEX_PHY_CARDDETECT);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thost->is_bus_width_set = false;\n\n\treturn 0;\n}\n\nstatic irqreturn_t litex_mmc_interrupt(int irq, void *arg)\n{\n\tstruct mmc_host *mmc = arg;\n\tstruct litex_mmc_host *host = mmc_priv(mmc);\n\tu32 pending = litex_read32(host->sdirq + LITEX_IRQ_PENDING);\n\tirqreturn_t ret = IRQ_NONE;\n\n\t \n\tif (pending & SDIRQ_CARD_DETECT) {\n\t\tlitex_write32(host->sdirq + LITEX_IRQ_PENDING,\n\t\t\t      SDIRQ_CARD_DETECT);\n\t\tmmc_detect_change(mmc, msecs_to_jiffies(10));\n\t\tret = IRQ_HANDLED;\n\t}\n\n\t \n\tif (pending & SDIRQ_CMD_DONE) {\n\t\t \n\t\tlitex_write32(host->sdirq + LITEX_IRQ_ENABLE,\n\t\t\t      SDIRQ_CARD_DETECT);\n\t\tcomplete(&host->cmd_done);\n\t\tret = IRQ_HANDLED;\n\t}\n\n\treturn ret;\n}\n\nstatic u32 litex_mmc_response_len(struct mmc_command *cmd)\n{\n\tif (cmd->flags & MMC_RSP_136)\n\t\treturn SD_CTL_RESP_LONG;\n\tif (!(cmd->flags & MMC_RSP_PRESENT))\n\t\treturn SD_CTL_RESP_NONE;\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\treturn SD_CTL_RESP_SHORT_BUSY;\n\treturn SD_CTL_RESP_SHORT;\n}\n\nstatic void litex_mmc_do_dma(struct litex_mmc_host *host, struct mmc_data *data,\n\t\t\t     unsigned int *len, bool *direct, u8 *transfer)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\tdma_addr_t dma;\n\tint sg_count;\n\n\t \n\tdma = host->dma;\n\t*len = data->blksz * data->blocks;\n\tsg_count = dma_map_sg(dev, data->sg, data->sg_len,\n\t\t\t      mmc_get_dma_dir(data));\n\tif (sg_count == 1) {\n\t\tdma = sg_dma_address(data->sg);\n\t\t*len = sg_dma_len(data->sg);\n\t\t*direct = true;\n\t} else if (*len > host->buf_size)\n\t\t*len = host->buf_size;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tlitex_write8(host->sdreader + LITEX_BLK2MEM_ENA, 0);\n\t\tlitex_write64(host->sdreader + LITEX_BLK2MEM_BASE, dma);\n\t\tlitex_write32(host->sdreader + LITEX_BLK2MEM_LEN, *len);\n\t\tlitex_write8(host->sdreader + LITEX_BLK2MEM_ENA, 1);\n\t\t*transfer = SD_CTL_DATA_XFER_READ;\n\t} else if (data->flags & MMC_DATA_WRITE) {\n\t\tif (!*direct)\n\t\t\tsg_copy_to_buffer(data->sg, data->sg_len,\n\t\t\t\t\t  host->buffer, *len);\n\t\tlitex_write8(host->sdwriter + LITEX_MEM2BLK_ENA, 0);\n\t\tlitex_write64(host->sdwriter + LITEX_MEM2BLK_BASE, dma);\n\t\tlitex_write32(host->sdwriter + LITEX_MEM2BLK_LEN, *len);\n\t\tlitex_write8(host->sdwriter + LITEX_MEM2BLK_ENA, 1);\n\t\t*transfer = SD_CTL_DATA_XFER_WRITE;\n\t} else {\n\t\tdev_warn(dev, \"Data present w/o read or write flag.\\n\");\n\t\t \n\t}\n\n\tlitex_write16(host->sdcore + LITEX_CORE_BLKLEN, data->blksz);\n\tlitex_write32(host->sdcore + LITEX_CORE_BLKCNT, data->blocks);\n}\n\nstatic void litex_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct litex_mmc_host *host = mmc_priv(mmc);\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_command *sbc = mrq->sbc;\n\tstruct mmc_data *data = mrq->data;\n\tstruct mmc_command *stop = mrq->stop;\n\tunsigned int retries = cmd->retries;\n\tunsigned int len = 0;\n\tbool direct = false;\n\tu32 response_len = litex_mmc_response_len(cmd);\n\tu8 transfer = SD_CTL_DATA_XFER_NONE;\n\n\t \n\tif (!litex_mmc_get_cd(mmc)) {\n\t\tcmd->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\t \n\tif (sbc) {\n\t\tsbc->error = litex_mmc_send_cmd(host, sbc->opcode, sbc->arg,\n\t\t\t\t\t\tlitex_mmc_response_len(sbc),\n\t\t\t\t\t\tSD_CTL_DATA_XFER_NONE);\n\t\tif (sbc->error) {\n\t\t\thost->is_bus_width_set = false;\n\t\t\tmmc_request_done(mmc, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (data) {\n\t\t \n\t\tcmd->error = litex_mmc_set_bus_width(host);\n\t\tif (cmd->error) {\n\t\t\tdev_err(dev, \"Can't set bus width!\\n\");\n\t\t\tmmc_request_done(mmc, mrq);\n\t\t\treturn;\n\t\t}\n\n\t\tlitex_mmc_do_dma(host, data, &len, &direct, &transfer);\n\t}\n\n\tdo {\n\t\tcmd->error = litex_mmc_send_cmd(host, cmd->opcode, cmd->arg,\n\t\t\t\t\t\tresponse_len, transfer);\n\t} while (cmd->error && retries-- > 0);\n\n\tif (cmd->error) {\n\t\t \n\t\thost->is_bus_width_set = false;\n\t}\n\n\tif (response_len == SD_CTL_RESP_SHORT) {\n\t\t \n\t\tcmd->resp[0] = host->resp[3];\n\t\tcmd->resp[1] = host->resp[2] & 0xFF;\n\t} else if (response_len == SD_CTL_RESP_LONG) {\n\t\tcmd->resp[0] = host->resp[0];\n\t\tcmd->resp[1] = host->resp[1];\n\t\tcmd->resp[2] = host->resp[2];\n\t\tcmd->resp[3] = host->resp[3];\n\t}\n\n\t \n\tif (stop && (cmd->error || !sbc)) {\n\t\tstop->error = litex_mmc_send_cmd(host, stop->opcode, stop->arg,\n\t\t\t\t\t\t litex_mmc_response_len(stop),\n\t\t\t\t\t\t SD_CTL_DATA_XFER_NONE);\n\t\tif (stop->error)\n\t\t\thost->is_bus_width_set = false;\n\t}\n\n\tif (data) {\n\t\tdma_unmap_sg(dev, data->sg, data->sg_len,\n\t\t\t     mmc_get_dma_dir(data));\n\t}\n\n\tif (!cmd->error && transfer != SD_CTL_DATA_XFER_NONE) {\n\t\tdata->bytes_xfered = min(len, mmc->max_req_size);\n\t\tif (transfer == SD_CTL_DATA_XFER_READ && !direct) {\n\t\t\tsg_copy_from_buffer(data->sg, sg_nents(data->sg),\n\t\t\t\t\t    host->buffer, data->bytes_xfered);\n\t\t}\n\t}\n\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic void litex_mmc_setclk(struct litex_mmc_host *host, unsigned int freq)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\tu32 div;\n\n\tdiv = freq ? host->ref_clk / freq : 256U;\n\tdiv = roundup_pow_of_two(div);\n\tdiv = clamp(div, 2U, 256U);\n\tdev_dbg(dev, \"sd_clk_freq=%d: set to %d via div=%d\\n\",\n\t\tfreq, host->ref_clk / div, div);\n\tlitex_write16(host->sdphy + LITEX_PHY_CLOCKERDIV, div);\n\thost->sd_clk = freq;\n}\n\nstatic void litex_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct litex_mmc_host *host = mmc_priv(mmc);\n\n\t \n\n\t \n\tif (ios->clock != host->sd_clk)\n\t\tlitex_mmc_setclk(host, ios->clock);\n}\n\nstatic const struct mmc_host_ops litex_mmc_ops = {\n\t.get_cd = litex_mmc_get_cd,\n\t.request = litex_mmc_request,\n\t.set_ios = litex_mmc_set_ios,\n};\n\nstatic int litex_mmc_irq_init(struct platform_device *pdev,\n\t\t\t      struct litex_mmc_host *host)\n{\n\tstruct device *dev = mmc_dev(host->mmc);\n\tint ret;\n\n\tret = platform_get_irq_optional(pdev, 0);\n\tif (ret < 0 && ret != -ENXIO)\n\t\treturn ret;\n\tif (ret > 0)\n\t\thost->irq = ret;\n\telse {\n\t\tdev_warn(dev, \"Failed to get IRQ, using polling\\n\");\n\t\tgoto use_polling;\n\t}\n\n\thost->sdirq = devm_platform_ioremap_resource_byname(pdev, \"irq\");\n\tif (IS_ERR(host->sdirq))\n\t\treturn PTR_ERR(host->sdirq);\n\n\tret = devm_request_irq(dev, host->irq, litex_mmc_interrupt, 0,\n\t\t\t       \"litex-mmc\", host->mmc);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"IRQ request error %d, using polling\\n\", ret);\n\t\tgoto use_polling;\n\t}\n\n\t \n\tlitex_write32(host->sdirq + LITEX_IRQ_PENDING, SDIRQ_CARD_DETECT);\n\tlitex_write32(host->sdirq + LITEX_IRQ_ENABLE, SDIRQ_CARD_DETECT);\n\n\treturn 0;\n\nuse_polling:\n\thost->mmc->caps |= MMC_CAP_NEEDS_POLL;\n\thost->irq = 0;\n\treturn 0;\n}\n\nstatic void litex_mmc_free_host_wrapper(void *mmc)\n{\n\tmmc_free_host(mmc);\n}\n\nstatic int litex_mmc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct litex_mmc_host *host;\n\tstruct mmc_host *mmc;\n\tstruct clk *clk;\n\tint ret;\n\n\t \n\tmmc = mmc_alloc_host(sizeof(struct litex_mmc_host), dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tret = devm_add_action_or_reset(dev, litex_mmc_free_host_wrapper, mmc);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret,\n\t\t\t\t     \"Can't register mmc_free_host action\\n\");\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\n\t \n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn dev_err_probe(dev, PTR_ERR(clk), \"can't get clock\\n\");\n\thost->ref_clk = clk_get_rate(clk);\n\thost->sd_clk = 0;\n\n\t \n\thost->is_bus_width_set = false;\n\thost->app_cmd = false;\n\n\t \n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\thost->buf_size = mmc->max_req_size * 2;\n\thost->buffer = dmam_alloc_coherent(dev, host->buf_size,\n\t\t\t\t\t   &host->dma, GFP_KERNEL);\n\tif (host->buffer == NULL)\n\t\treturn -ENOMEM;\n\n\thost->sdphy = devm_platform_ioremap_resource_byname(pdev, \"phy\");\n\tif (IS_ERR(host->sdphy))\n\t\treturn PTR_ERR(host->sdphy);\n\n\thost->sdcore = devm_platform_ioremap_resource_byname(pdev, \"core\");\n\tif (IS_ERR(host->sdcore))\n\t\treturn PTR_ERR(host->sdcore);\n\n\thost->sdreader = devm_platform_ioremap_resource_byname(pdev, \"reader\");\n\tif (IS_ERR(host->sdreader))\n\t\treturn PTR_ERR(host->sdreader);\n\n\thost->sdwriter = devm_platform_ioremap_resource_byname(pdev, \"writer\");\n\tif (IS_ERR(host->sdwriter))\n\t\treturn PTR_ERR(host->sdwriter);\n\n\t \n\tlitex_write8(host->sdreader + LITEX_BLK2MEM_ENA, 0);\n\tlitex_write8(host->sdwriter + LITEX_MEM2BLK_ENA, 0);\n\n\tinit_completion(&host->cmd_done);\n\tret = litex_mmc_irq_init(pdev, host);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc->ops = &litex_mmc_ops;\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret || mmc->ocr_avail == 0) {\n\t\tdev_warn(dev, \"can't get voltage, defaulting to 3.3V\\n\");\n\t\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\t}\n\n\t \n\tmmc->f_min = 12.5e6;\n\tmmc->f_max = 50e6;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmmc->caps &= ~MMC_CAP_8_BIT_DATA;\n\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\t \n\tmmc->caps |= MMC_CAP_WAIT_WHILE_BUSY |\n\t\t     MMC_CAP_DRIVER_TYPE_D |\n\t\t     MMC_CAP_CMD23;\n\tmmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT |\n\t\t      MMC_CAP2_NO_SDIO |\n\t\t      MMC_CAP2_NO_MMC;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"LiteX MMC controller initialized.\\n\");\n\treturn 0;\n}\n\nstatic void litex_mmc_remove(struct platform_device *pdev)\n{\n\tstruct litex_mmc_host *host = platform_get_drvdata(pdev);\n\n\tmmc_remove_host(host->mmc);\n}\n\nstatic const struct of_device_id litex_match[] = {\n\t{ .compatible = \"litex,mmc\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, litex_match);\n\nstatic struct platform_driver litex_mmc_driver = {\n\t.probe = litex_mmc_probe,\n\t.remove_new = litex_mmc_remove,\n\t.driver = {\n\t\t.name = \"litex-mmc\",\n\t\t.of_match_table = litex_match,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\nmodule_platform_driver(litex_mmc_driver);\n\nMODULE_DESCRIPTION(\"LiteX SDCard driver\");\nMODULE_AUTHOR(\"Antmicro <contact@antmicro.com>\");\nMODULE_AUTHOR(\"Kamil Rakoczy <krakoczy@antmicro.com>\");\nMODULE_AUTHOR(\"Maciej Dudek <mdudek@internships.antmicro.com>\");\nMODULE_AUTHOR(\"Paul Mackerras <paulus@ozlabs.org>\");\nMODULE_AUTHOR(\"Gabriel Somlo <gsomlo@gmail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}