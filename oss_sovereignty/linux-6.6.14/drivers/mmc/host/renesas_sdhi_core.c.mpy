{
  "module_name": "renesas_sdhi_core.c",
  "hash_id": "56003197c0b15a66341d141f8b86b3bf6490d0b78269d4b41046a4db880d6233",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/renesas_sdhi_core.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/tmio.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pinctrl/pinctrl-state.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/sh_dma.h>\n#include <linux/slab.h>\n\n#include \"renesas_sdhi.h\"\n#include \"tmio_mmc.h\"\n\n#define CTL_HOST_MODE\t0xe4\n#define HOST_MODE_GEN2_SDR50_WMODE\tBIT(0)\n#define HOST_MODE_GEN2_SDR104_WMODE\tBIT(0)\n#define HOST_MODE_GEN3_WMODE\t\tBIT(0)\n#define HOST_MODE_GEN3_BUSWIDTH\t\tBIT(8)\n\n#define HOST_MODE_GEN3_16BIT\tHOST_MODE_GEN3_WMODE\n#define HOST_MODE_GEN3_32BIT\t(HOST_MODE_GEN3_WMODE | HOST_MODE_GEN3_BUSWIDTH)\n#define HOST_MODE_GEN3_64BIT\t0\n\n#define SDHI_VER_GEN2_SDR50\t0x490c\n#define SDHI_VER_RZ_A1\t\t0x820b\n \n#define SDHI_VER_GEN2_SDR104\t0xcb0d\n#define SDHI_VER_GEN3_SD\t0xcc10\n#define SDHI_VER_GEN3_SDMMC\t0xcd10\n\n#define SDHI_GEN3_MMC0_ADDR\t0xee140000\n\nstatic void renesas_sdhi_sdbuf_width(struct tmio_mmc_host *host, int width)\n{\n\tu32 val;\n\n\t \n\tswitch (sd_ctrl_read16(host, CTL_VERSION)) {\n\tcase SDHI_VER_GEN2_SDR50:\n\t\tval = (width == 32) ? HOST_MODE_GEN2_SDR50_WMODE : 0;\n\t\tbreak;\n\tcase SDHI_VER_GEN2_SDR104:\n\t\tval = (width == 32) ? 0 : HOST_MODE_GEN2_SDR104_WMODE;\n\t\tbreak;\n\tcase SDHI_VER_GEN3_SD:\n\tcase SDHI_VER_GEN3_SDMMC:\n\t\tif (width == 64)\n\t\t\tval = HOST_MODE_GEN3_64BIT;\n\t\telse if (width == 32)\n\t\t\tval = HOST_MODE_GEN3_32BIT;\n\t\telse\n\t\t\tval = HOST_MODE_GEN3_16BIT;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\n\tsd_ctrl_write16(host, CTL_HOST_MODE, val);\n}\n\nstatic int renesas_sdhi_clk_enable(struct tmio_mmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tint ret;\n\n\tret = clk_prepare_enable(priv->clk_cd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (!mmc->f_max)\n\t\tmmc->f_max = clk_get_rate(priv->clk);\n\n\t \n\tmmc->f_min = max(clk_round_rate(priv->clk, 1) / 512, 1L);\n\n\t \n\trenesas_sdhi_sdbuf_width(host, 16);\n\n\treturn 0;\n}\n\nstatic unsigned int renesas_sdhi_clk_update(struct tmio_mmc_host *host,\n\t\t\t\t\t    unsigned int wanted_clock)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct clk *ref_clk = priv->clk;\n\tunsigned int freq, diff, best_freq = 0, diff_min = ~0;\n\tunsigned int new_clock, clkh_shift = 0;\n\tunsigned int new_upper_limit;\n\tint i;\n\n\t \n\tif (!(host->pdata->flags & TMIO_MMC_MIN_RCAR2) || mmc_doing_tune(host->mmc))\n\t\treturn clk_get_rate(priv->clk);\n\n\tif (priv->clkh) {\n\t\t \n\t\tbool use_4tap = sdhi_has_quirk(priv, hs400_4taps);\n\t\tbool need_slow_clkh = host->mmc->ios.timing == MMC_TIMING_MMC_HS400;\n\t\tclkh_shift = use_4tap && need_slow_clkh ? 1 : 2;\n\t\tref_clk = priv->clkh;\n\t}\n\n\tnew_clock = wanted_clock << clkh_shift;\n\n\t \n\tfor (i = min(9, ilog2(UINT_MAX / new_clock)); i >= 0; i--) {\n\t\tfreq = clk_round_rate(ref_clk, new_clock << i);\n\t\tnew_upper_limit = (new_clock << i) + ((new_clock << i) >> 10);\n\t\tif (freq > new_upper_limit) {\n\t\t\t \n\t\t\tfreq = clk_round_rate(ref_clk, (new_clock << i) / 4 * 3);\n\t\t\tif (freq > new_upper_limit)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tdiff = new_clock - (freq >> i);\n\t\tif (diff <= diff_min) {\n\t\t\tbest_freq = freq;\n\t\t\tdiff_min = diff;\n\t\t}\n\t}\n\n\tclk_set_rate(ref_clk, best_freq);\n\n\tif (priv->clkh)\n\t\tclk_set_rate(priv->clk, best_freq >> clkh_shift);\n\n\treturn clk_get_rate(priv->clk);\n}\n\nstatic void renesas_sdhi_set_clock(struct tmio_mmc_host *host,\n\t\t\t\t   unsigned int new_clock)\n{\n\tunsigned int clk_margin;\n\tu32 clk = 0, clock;\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\n\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\tif (new_clock == 0) {\n\t\thost->mmc->actual_clock = 0;\n\t\tgoto out;\n\t}\n\n\thost->mmc->actual_clock = renesas_sdhi_clk_update(host, new_clock);\n\tclock = host->mmc->actual_clock / 512;\n\n\t \n\tclk_margin = new_clock >> 10;\n\tfor (clk = 0x80000080; new_clock + clk_margin >= (clock << 1); clk >>= 1)\n\t\tclock <<= 1;\n\n\t \n\tif ((host->pdata->flags & TMIO_MMC_CLK_ACTUAL) && ((clk >> 22) & 0x1)) {\n\t\tif (!(host->mmc->ios.timing == MMC_TIMING_MMC_HS400))\n\t\t\tclk |= 0xff;\n\t\telse\n\t\t\tclk &= ~0xff;\n\t}\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, clk & CLK_CTL_DIV_MASK);\n\tif (!(host->pdata->flags & TMIO_MMC_MIN_RCAR2))\n\t\tusleep_range(10000, 11000);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\n\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\nout:\n\t \n\tif (!(host->pdata->flags & TMIO_MMC_MIN_RCAR2))\n\t\tusleep_range(10000, 11000);\n}\n\nstatic void renesas_sdhi_clk_disable(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tclk_disable_unprepare(priv->clk_cd);\n}\n\nstatic int renesas_sdhi_card_busy(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\n\treturn !(sd_ctrl_read16_and_16_as_32(host, CTL_STATUS) &\n\t\t TMIO_STAT_DAT0);\n}\n\nstatic int renesas_sdhi_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t\t    struct mmc_ios *ios)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct pinctrl_state *pin_state;\n\tint ret;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tpin_state = priv->pins_default;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tpin_state = priv->pins_uhs;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (IS_ERR(priv->pinctrl) || IS_ERR(pin_state))\n\t\treturn ios->signal_voltage ==\n\t\t\tMMC_SIGNAL_VOLTAGE_330 ? 0 : -EINVAL;\n\n\tret = mmc_regulator_set_vqmmc(host->mmc, ios);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn pinctrl_select_state(priv->pinctrl, pin_state);\n}\n\n \n#define SH_MOBILE_SDHI_SCC_DTCNTL\t0x000\n#define SH_MOBILE_SDHI_SCC_TAPSET\t0x002\n#define SH_MOBILE_SDHI_SCC_DT2FF\t0x004\n#define SH_MOBILE_SDHI_SCC_CKSEL\t0x006\n#define SH_MOBILE_SDHI_SCC_RVSCNTL\t0x008\n#define SH_MOBILE_SDHI_SCC_RVSREQ\t0x00A\n#define SH_MOBILE_SDHI_SCC_SMPCMP       0x00C\n#define SH_MOBILE_SDHI_SCC_TMPPORT2\t0x00E\n#define SH_MOBILE_SDHI_SCC_TMPPORT3\t0x014\n#define SH_MOBILE_SDHI_SCC_TMPPORT4\t0x016\n#define SH_MOBILE_SDHI_SCC_TMPPORT5\t0x018\n#define SH_MOBILE_SDHI_SCC_TMPPORT6\t0x01A\n#define SH_MOBILE_SDHI_SCC_TMPPORT7\t0x01C\n\n#define SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN\t\tBIT(0)\n#define SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT\t16\n#define SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_MASK\t0xff\n\n#define SH_MOBILE_SDHI_SCC_CKSEL_DTSEL\t\tBIT(0)\n\n#define SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN\tBIT(0)\n\n#define SH_MOBILE_SDHI_SCC_RVSREQ_REQTAPDOWN\tBIT(0)\n#define SH_MOBILE_SDHI_SCC_RVSREQ_REQTAPUP\tBIT(1)\n#define SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR\tBIT(2)\n\n#define SH_MOBILE_SDHI_SCC_SMPCMP_CMD_REQDOWN\tBIT(8)\n#define SH_MOBILE_SDHI_SCC_SMPCMP_CMD_REQUP\tBIT(24)\n#define SH_MOBILE_SDHI_SCC_SMPCMP_CMD_ERR\t(BIT(8) | BIT(24))\n\n#define SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL\tBIT(4)\n#define SH_MOBILE_SDHI_SCC_TMPPORT2_HS400EN\tBIT(31)\n\n \n#define SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START\tBIT(0)\n\n \n#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_R\tBIT(8)\n#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_W\t(0 << 8)\n#define SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK\t0x3F\n\n \n#define SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE\t0xa5000000\n#define SH_MOBILE_SDHI_SCC_TMPPORT_CALIB_CODE_MASK\t0x1f\n#define SH_MOBILE_SDHI_SCC_TMPPORT_MANUAL_MODE\t\tBIT(7)\n\nstatic inline u32 sd_scc_read32(struct tmio_mmc_host *host,\n\t\t\t\tstruct renesas_sdhi *priv, int addr)\n{\n\treturn readl(priv->scc_ctl + (addr << host->bus_shift));\n}\n\nstatic inline void sd_scc_write32(struct tmio_mmc_host *host,\n\t\t\t\t  struct renesas_sdhi *priv,\n\t\t\t\t  int addr, u32 val)\n{\n\twritel(val, priv->scc_ctl + (addr << host->bus_shift));\n}\n\nstatic unsigned int renesas_sdhi_init_tuning(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv;\n\n\tpriv = host_to_priv(host);\n\n\t \n\tsd_ctrl_write32_as_16_and_16(host, CTL_STATUS, 0x0);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL,\n\t\t       SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN |\n\t\t       0x8 << SH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT);\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL,\n\t\t       SH_MOBILE_SDHI_SCC_CKSEL_DTSEL |\n\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\n\t\t       ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\n\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DT2FF, priv->scc_tappos);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\t \n\treturn (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL) >>\n\t\tSH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_SHIFT) &\n\t\tSH_MOBILE_SDHI_SCC_DTCNTL_TAPNUM_MASK;\n}\n\nstatic void renesas_sdhi_hs400_complete(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tu32 bad_taps = priv->quirks ? priv->quirks->hs400_bad_taps : 0;\n\tbool use_4tap = sdhi_has_quirk(priv, hs400_4taps);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\n\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\t \n\tsd_ctrl_write16(host, CTL_SDIF_MODE, SDIF_MODE_HS400 |\n\t\t\tsd_ctrl_read16(host, CTL_SDIF_MODE));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DT2FF,\n\t\t       priv->scc_tappos_hs400);\n\n\tif (sdhi_has_quirk(priv, manual_tap_correction))\n\t\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\n\t\t\t       ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\n\t\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2,\n\t\t       (SH_MOBILE_SDHI_SCC_TMPPORT2_HS400EN |\n\t\t\tSH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL) |\n\t\t\tsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL,\n\t\t       SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN |\n\t\t       sd_scc_read32(host, priv,\n\t\t\t\t     SH_MOBILE_SDHI_SCC_DTCNTL));\n\n\t \n\tif (bad_taps & BIT(priv->tap_set)) {\n\t\tu32 new_tap = (priv->tap_set + 1) % priv->tap_num;\n\n\t\tif (bad_taps & BIT(new_tap))\n\t\t\tnew_tap = (priv->tap_set - 1) % priv->tap_num;\n\n\t\tif (bad_taps & BIT(new_tap)) {\n\t\t\tnew_tap = priv->tap_set;\n\t\t\tdev_dbg(&host->pdev->dev, \"Can't handle three bad tap in a row\\n\");\n\t\t}\n\n\t\tpriv->tap_set = new_tap;\n\t}\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET,\n\t\t       priv->tap_set / (use_4tap ? 2 : 1));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL,\n\t\t       SH_MOBILE_SDHI_SCC_CKSEL_DTSEL |\n\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL));\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\tif (priv->adjust_hs400_calib_table)\n\t\tpriv->needs_adjust_hs400 = true;\n}\n\nstatic void renesas_sdhi_disable_scc(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_CKSEL,\n\t\t       ~SH_MOBILE_SDHI_SCC_CKSEL_DTSEL &\n\t\t       sd_scc_read32(host, priv,\n\t\t\t\t     SH_MOBILE_SDHI_SCC_CKSEL));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DTCNTL,\n\t\t       ~SH_MOBILE_SDHI_SCC_DTCNTL_TAPEN &\n\t\t       sd_scc_read32(host, priv,\n\t\t\t\t     SH_MOBILE_SDHI_SCC_DTCNTL));\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n}\n\nstatic u32 sd_scc_tmpport_read32(struct tmio_mmc_host *host,\n\t\t\t\t struct renesas_sdhi *priv, u32 addr)\n{\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT5,\n\t\t       SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_R |\n\t\t       (SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK & addr));\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4,\n\t\t       SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START);\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4, 0);\n\n\treturn sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT7);\n}\n\nstatic void sd_scc_tmpport_write32(struct tmio_mmc_host *host,\n\t\t\t\t   struct renesas_sdhi *priv, u32 addr, u32 val)\n{\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT5,\n\t\t       SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_RW_SEL_W |\n\t\t       (SH_MOBILE_SDHI_SCC_TMPPORT5_DLL_ADR_MASK & addr));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT6, val);\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4,\n\t\t       SH_MOBILE_SDHI_SCC_TMPPORT4_DLL_ACC_START);\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT4, 0);\n}\n\nstatic void renesas_sdhi_adjust_hs400_mode_enable(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tu32 calib_code;\n\n\t \n\tsd_scc_tmpport_write32(host, priv, 0x00,\n\t\t\t       SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE);\n\t \n\tcalib_code = sd_scc_tmpport_read32(host, priv, 0x26);\n\tcalib_code &= SH_MOBILE_SDHI_SCC_TMPPORT_CALIB_CODE_MASK;\n\n\tsd_scc_tmpport_write32(host, priv, 0x22,\n\t\t\t       SH_MOBILE_SDHI_SCC_TMPPORT_MANUAL_MODE |\n\t\t\t       priv->adjust_hs400_calib_table[calib_code]);\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT3, 0x3);\n\n\t \n\tpriv->needs_adjust_hs400 = false;\n}\n\nstatic void renesas_sdhi_adjust_hs400_mode_disable(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\t \n\tsd_scc_tmpport_write32(host, priv, 0x00,\n\t\t\t       SH_MOBILE_SDHI_SCC_TMPPORT_DISABLE_WP_CODE);\n\t \n\tsd_scc_tmpport_write32(host, priv, 0x22, 0);\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT3, 0);\n}\n\nstatic void renesas_sdhi_reset_hs400_mode(struct tmio_mmc_host *host,\n\t\t\t\t\t  struct renesas_sdhi *priv)\n{\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~CLK_CTL_SCLKEN &\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n\n\t \n\tsd_ctrl_write16(host, CTL_SDIF_MODE, ~SDIF_MODE_HS400 &\n\t\t\tsd_ctrl_read16(host, CTL_SDIF_MODE));\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_DT2FF, priv->scc_tappos);\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2,\n\t\t       ~(SH_MOBILE_SDHI_SCC_TMPPORT2_HS400EN |\n\t\t\t SH_MOBILE_SDHI_SCC_TMPPORT2_HS400OSEL) &\n\t\t\tsd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_TMPPORT2));\n\n\tif (sdhi_has_quirk(priv, hs400_calib_table) || sdhi_has_quirk(priv, hs400_bad_taps))\n\t\trenesas_sdhi_adjust_hs400_mode_disable(host);\n\n\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, CLK_CTL_SCLKEN |\n\t\t\tsd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));\n}\n\nstatic int renesas_sdhi_prepare_hs400_tuning(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\n\trenesas_sdhi_reset_hs400_mode(host, host_to_priv(host));\n\treturn 0;\n}\n\nstatic void renesas_sdhi_scc_reset(struct tmio_mmc_host *host, struct renesas_sdhi *priv)\n{\n\trenesas_sdhi_disable_scc(host->mmc);\n\trenesas_sdhi_reset_hs400_mode(host, priv);\n\tpriv->needs_adjust_hs400 = false;\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\n\t\t       ~SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN &\n\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\n}\n\n \nstatic void renesas_sdhi_reset(struct tmio_mmc_host *host, bool preserve)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tint ret;\n\tu16 val;\n\n\tif (!preserve) {\n\t\tif (priv->rstc) {\n\t\t\treset_control_reset(priv->rstc);\n\t\t\t \n\t\t\tread_poll_timeout(reset_control_status, ret, ret == 0, 1, 100,\n\t\t\t\t\t  false, priv->rstc);\n\t\t\t \n\t\t\tsd_ctrl_write16(host, CTL_RESET_SD, 0x0001);\n\t\t\tpriv->needs_adjust_hs400 = false;\n\t\t\trenesas_sdhi_set_clock(host, host->clk_cache);\n\t\t} else if (priv->scc_ctl) {\n\t\t\trenesas_sdhi_scc_reset(host, priv);\n\t\t}\n\t}\n\n\tif (sd_ctrl_read16(host, CTL_VERSION) >= SDHI_VER_GEN3_SD) {\n\t\tval = sd_ctrl_read16(host, CTL_SD_MEM_CARD_OPT);\n\t\tval |= CARD_OPT_EXTOP;\n\t\tsd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, val);\n\t}\n}\n\nstatic unsigned int renesas_sdhi_gen3_get_cycles(struct tmio_mmc_host *host)\n{\n\tu16 num, val = sd_ctrl_read16(host, CTL_SD_MEM_CARD_OPT);\n\n\tnum = (val & CARD_OPT_TOP_MASK) >> CARD_OPT_TOP_SHIFT;\n\treturn 1 << ((val & CARD_OPT_EXTOP ? 14 : 13) + num);\n\n}\n\n#define SH_MOBILE_SDHI_MIN_TAP_ROW 3\n\nstatic int renesas_sdhi_select_tuning(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tunsigned int tap_start = 0, tap_end = 0, tap_cnt = 0, rs, re, i;\n\tunsigned int taps_size = priv->tap_num * 2, min_tap_row;\n\tunsigned long *bitmap;\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);\n\n\t \n\tfor (i = 0; i < taps_size; i++) {\n\t\tint offset = priv->tap_num * (i < priv->tap_num ? 1 : -1);\n\n\t\tif (!test_bit(i, priv->taps))\n\t\t\tclear_bit(i + offset, priv->taps);\n\n\t\tif (!test_bit(i, priv->smpcmp))\n\t\t\tclear_bit(i + offset, priv->smpcmp);\n\t}\n\n\t \n\tif (bitmap_full(priv->taps, taps_size)) {\n\t\tbitmap = priv->smpcmp;\n\t\tmin_tap_row = 1;\n\t} else {\n\t\tbitmap = priv->taps;\n\t\tmin_tap_row = SH_MOBILE_SDHI_MIN_TAP_ROW;\n\t}\n\n\t \n\tfor_each_set_bitrange(rs, re, bitmap, taps_size) {\n\t\tif (re - rs > tap_cnt) {\n\t\t\ttap_end = re;\n\t\t\ttap_start = rs;\n\t\t\ttap_cnt = tap_end - tap_start;\n\t\t}\n\t}\n\n\tif (tap_cnt >= min_tap_row)\n\t\tpriv->tap_set = (tap_start + tap_end) / 2 % priv->tap_num;\n\telse\n\t\treturn -EIO;\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET, priv->tap_set);\n\n\t \n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL,\n\t\t       SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN |\n\t\t       sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL));\n\n\treturn 0;\n}\n\nstatic int renesas_sdhi_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tint i, ret;\n\n\tpriv->tap_num = renesas_sdhi_init_tuning(host);\n\tif (!priv->tap_num)\n\t\treturn 0;  \n\n\tif (priv->tap_num * 2 >= sizeof(priv->taps) * BITS_PER_BYTE) {\n\t\tdev_err(&host->pdev->dev,\n\t\t\t\"Too many taps, please update 'taps' in tmio_mmc_host!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(priv->taps, priv->tap_num * 2);\n\tbitmap_zero(priv->smpcmp, priv->tap_num * 2);\n\n\t \n\tfor (i = 0; i < 2 * priv->tap_num; i++) {\n\t\tint cmd_error = 0;\n\n\t\t \n\t\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET, i % priv->tap_num);\n\n\t\tif (mmc_send_tuning(mmc, opcode, &cmd_error) == 0)\n\t\t\tset_bit(i, priv->taps);\n\n\t\tif (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_SMPCMP) == 0)\n\t\t\tset_bit(i, priv->smpcmp);\n\n\t\tif (cmd_error)\n\t\t\tmmc_send_abort_tuning(mmc, opcode);\n\t}\n\n\tret = renesas_sdhi_select_tuning(host);\n\tif (ret < 0)\n\t\trenesas_sdhi_scc_reset(host, priv);\n\treturn ret;\n}\n\nstatic bool renesas_sdhi_manual_correction(struct tmio_mmc_host *host, bool use_4tap)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tunsigned int new_tap = priv->tap_set, error_tap = priv->tap_set;\n\tu32 val;\n\n\tval = sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ);\n\tif (!val)\n\t\treturn false;\n\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);\n\n\t \n\tif (sdhi_has_quirk(priv, manual_tap_correction) &&\n\t    host->mmc->ios.timing == MMC_TIMING_MMC_HS400) {\n\t\tu32 bad_taps = priv->quirks ? priv->quirks->hs400_bad_taps : 0;\n\t\t \n\t\tu32 smpcmp = sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_SMPCMP) &\n\t\t\t\t\t   SH_MOBILE_SDHI_SCC_SMPCMP_CMD_ERR;\n\t\tif (!smpcmp) {\n\t\t\treturn false;\t \n\t\t} else if (smpcmp == SH_MOBILE_SDHI_SCC_SMPCMP_CMD_REQUP) {\n\t\t\tnew_tap++;\n\t\t\terror_tap--;\n\t\t} else if (smpcmp == SH_MOBILE_SDHI_SCC_SMPCMP_CMD_REQDOWN) {\n\t\t\tnew_tap--;\n\t\t\terror_tap++;\n\t\t} else {\n\t\t\treturn true;\t \n\t\t}\n\n\t\t \n\t\tif (bad_taps & BIT(new_tap % priv->tap_num))\n\t\t\treturn test_bit(error_tap % priv->tap_num, priv->smpcmp);\n\t} else {\n\t\tif (val & SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR)\n\t\t\treturn true;     \n\t\telse if (val & SH_MOBILE_SDHI_SCC_RVSREQ_REQTAPUP)\n\t\t\tnew_tap++;\n\t\telse if (val & SH_MOBILE_SDHI_SCC_RVSREQ_REQTAPDOWN)\n\t\t\tnew_tap--;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpriv->tap_set = (new_tap % priv->tap_num);\n\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_TAPSET,\n\t\t       priv->tap_set / (use_4tap ? 2 : 1));\n\n\treturn false;\n}\n\nstatic bool renesas_sdhi_auto_correction(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\t \n\tif (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ) &\n\t    SH_MOBILE_SDHI_SCC_RVSREQ_RVSERR) {\n\t\tsd_scc_write32(host, priv, SH_MOBILE_SDHI_SCC_RVSREQ, 0);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool renesas_sdhi_check_scc_error(struct tmio_mmc_host *host,\n\t\t\t\t\t struct mmc_request *mrq)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tbool use_4tap = sdhi_has_quirk(priv, hs400_4taps);\n\tbool ret = false;\n\n\t \n\tif (!(host->mmc->ios.timing == MMC_TIMING_UHS_SDR104) &&\n\t    !(host->mmc->ios.timing == MMC_TIMING_MMC_HS200) &&\n\t    !(host->mmc->ios.timing == MMC_TIMING_MMC_HS400 && !use_4tap))\n\t\treturn false;\n\n\tif (mmc_doing_tune(host->mmc))\n\t\treturn false;\n\n\tif (((mrq->cmd->error == -ETIMEDOUT) ||\n\t     (mrq->data && mrq->data->error == -ETIMEDOUT)) &&\n\t    ((host->mmc->caps & MMC_CAP_NONREMOVABLE) ||\n\t     (host->ops.get_cd && host->ops.get_cd(host->mmc))))\n\t\tret |= true;\n\n\tif (sd_scc_read32(host, priv, SH_MOBILE_SDHI_SCC_RVSCNTL) &\n\t    SH_MOBILE_SDHI_SCC_RVSCNTL_RVSEN)\n\t\tret |= renesas_sdhi_auto_correction(host);\n\telse\n\t\tret |= renesas_sdhi_manual_correction(host, use_4tap);\n\n\treturn ret;\n}\n\nstatic int renesas_sdhi_wait_idle(struct tmio_mmc_host *host, u32 bit)\n{\n\tint timeout = 1000;\n\t \n\tu32 wait_state = (bit == TMIO_STAT_CMD_BUSY ? TMIO_STAT_CMD_BUSY : 0);\n\n\twhile (--timeout && (sd_ctrl_read16_and_16_as_32(host, CTL_STATUS)\n\t\t\t      & bit) == wait_state)\n\t\tudelay(1);\n\n\tif (!timeout) {\n\t\tdev_warn(&host->pdev->dev, \"timeout waiting for SD bus idle\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int renesas_sdhi_write16_hook(struct tmio_mmc_host *host, int addr)\n{\n\tu32 bit = TMIO_STAT_SCLKDIVEN;\n\n\tswitch (addr) {\n\tcase CTL_SD_CMD:\n\tcase CTL_STOP_INTERNAL_ACTION:\n\tcase CTL_XFER_BLK_COUNT:\n\tcase CTL_SD_XFER_LEN:\n\tcase CTL_SD_MEM_CARD_OPT:\n\tcase CTL_TRANSACTION_CTL:\n\tcase CTL_DMA_ENABLE:\n\tcase CTL_HOST_MODE:\n\t\tif (host->pdata->flags & TMIO_MMC_HAVE_CBSY)\n\t\t\tbit = TMIO_STAT_CMD_BUSY;\n\t\tfallthrough;\n\tcase CTL_SD_CARD_CLK_CTL:\n\t\treturn renesas_sdhi_wait_idle(host, bit);\n\t}\n\n\treturn 0;\n}\n\nstatic int renesas_sdhi_multi_io_quirk(struct mmc_card *card,\n\t\t\t\t       unsigned int direction, int blk_size)\n{\n\t \n\tif ((direction == MMC_DATA_READ) &&\n\t    blk_size == 2)\n\t\treturn 1;\n\n\treturn blk_size;\n}\n\nstatic void renesas_sdhi_fixup_request(struct tmio_mmc_host *host, struct mmc_request *mrq)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tif (priv->needs_adjust_hs400 && mrq->cmd->opcode == MMC_SEND_STATUS)\n\t\trenesas_sdhi_adjust_hs400_mode_enable(host);\n}\nstatic void renesas_sdhi_enable_dma(struct tmio_mmc_host *host, bool enable)\n{\n\t \n\tint width = (host->bus_shift == 2) ? 64 : 32;\n\n\tsd_ctrl_write16(host, CTL_DMA_ENABLE, enable ? DMA_ENABLE_DMASDRW : 0);\n\trenesas_sdhi_sdbuf_width(host, enable ? width : 16);\n}\n\nint renesas_sdhi_probe(struct platform_device *pdev,\n\t\t       const struct tmio_mmc_dma_ops *dma_ops,\n\t\t       const struct renesas_sdhi_of_data *of_data,\n\t\t       const struct renesas_sdhi_quirks *quirks)\n{\n\tstruct tmio_mmc_data *mmd = pdev->dev.platform_data;\n\tstruct tmio_mmc_data *mmc_data;\n\tstruct renesas_sdhi_dma *dma_priv;\n\tstruct tmio_mmc_host *host;\n\tstruct renesas_sdhi *priv;\n\tint num_irqs, irq, ret, i;\n\tstruct resource *res;\n\tu16 ver;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res)\n\t\treturn -EINVAL;\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct renesas_sdhi),\n\t\t\t    GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->quirks = quirks;\n\tmmc_data = &priv->mmc_data;\n\tdma_priv = &priv->dma_priv;\n\n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->clk), \"cannot get clock\");\n\n\tpriv->clkh = devm_clk_get_optional(&pdev->dev, \"clkh\");\n\tif (IS_ERR(priv->clkh))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->clkh), \"cannot get clkh\");\n\n\t \n\tpriv->clk_cd = devm_clk_get_optional(&pdev->dev, \"cd\");\n\tif (IS_ERR(priv->clk_cd))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(priv->clk_cd), \"cannot get cd clock\");\n\n\tpriv->rstc = devm_reset_control_get_optional_exclusive(&pdev->dev, NULL);\n\tif (IS_ERR(priv->rstc))\n\t\treturn PTR_ERR(priv->rstc);\n\n\tpriv->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (!IS_ERR(priv->pinctrl)) {\n\t\tpriv->pins_default = pinctrl_lookup_state(priv->pinctrl,\n\t\t\t\t\t\tPINCTRL_STATE_DEFAULT);\n\t\tpriv->pins_uhs = pinctrl_lookup_state(priv->pinctrl,\n\t\t\t\t\t\t\"state_uhs\");\n\t}\n\n\thost = tmio_mmc_host_alloc(pdev, mmc_data);\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tif (of_data) {\n\t\tmmc_data->flags |= of_data->tmio_flags;\n\t\tmmc_data->ocr_mask = of_data->tmio_ocr_mask;\n\t\tmmc_data->capabilities |= of_data->capabilities;\n\t\tmmc_data->capabilities2 |= of_data->capabilities2;\n\t\tmmc_data->dma_rx_offset = of_data->dma_rx_offset;\n\t\tmmc_data->max_blk_count = of_data->max_blk_count;\n\t\tmmc_data->max_segs = of_data->max_segs;\n\t\tdma_priv->dma_buswidth = of_data->dma_buswidth;\n\t\thost->bus_shift = of_data->bus_shift;\n\t\t \n\t\tif (!priv->clkh && of_data->sdhi_flags & SDHI_FLAG_NEED_CLKH_FALLBACK)\n\t\t\tpriv->clkh = clk_get_parent(clk_get_parent(priv->clk));\n\n\t}\n\n\thost->write16_hook = renesas_sdhi_write16_hook;\n\thost->clk_enable = renesas_sdhi_clk_enable;\n\thost->clk_disable = renesas_sdhi_clk_disable;\n\thost->set_clock = renesas_sdhi_set_clock;\n\thost->multi_io_quirk = renesas_sdhi_multi_io_quirk;\n\thost->dma_ops = dma_ops;\n\n\tif (sdhi_has_quirk(priv, hs400_disabled))\n\t\thost->mmc->caps2 &= ~(MMC_CAP2_HS400 | MMC_CAP2_HS400_ES);\n\n\t \n\tif (mmc_can_gpio_ro(host->mmc))\n\t\tmmc_data->capabilities2 &= ~MMC_CAP2_NO_WRITE_PROTECT;\n\n\t \n\tif (mmc_data->flags & TMIO_MMC_MIN_RCAR2) {\n\t\t \n\t\thost->ops.card_busy = renesas_sdhi_card_busy;\n\t\thost->ops.start_signal_voltage_switch =\n\t\t\trenesas_sdhi_start_signal_voltage_switch;\n\t\thost->sdcard_irq_setbit_mask = TMIO_STAT_ALWAYS_SET_27;\n\t\thost->sdcard_irq_mask_all = TMIO_MASK_ALL_RCAR2;\n\t\thost->reset = renesas_sdhi_reset;\n\t} else {\n\t\thost->sdcard_irq_mask_all = TMIO_MASK_ALL;\n\t}\n\n\t \n\tif (!host->bus_shift && resource_size(res) > 0x100)  \n\t\thost->bus_shift = 1;\n\n\tif (mmd)\n\t\t*mmc_data = *mmd;\n\n\tdma_priv->filter = shdma_chan_filter;\n\tdma_priv->enable = renesas_sdhi_enable_dma;\n\n\tmmc_data->capabilities |= MMC_CAP_MMC_HIGHSPEED;\n\n\t \n\tmmc_data->flags |= TMIO_MMC_BLKSZ_2BYTES;\n\n\t \n\tmmc_data->flags |= TMIO_MMC_SDIO_IRQ;\n\n\t \n\tmmc_data->flags |= TMIO_MMC_HAVE_CMD12_CTRL;\n\n\t \n\tmmc_data->flags |= TMIO_MMC_SDIO_STATUS_SETBITS;\n\n\t \n\tmmc_data->flags |= TMIO_MMC_USE_BUSY_TIMEOUT;\n\n\tdev_pm_domain_start(&pdev->dev);\n\n\tret = renesas_sdhi_clk_enable(host);\n\tif (ret)\n\t\tgoto efree;\n\n\tver = sd_ctrl_read16(host, CTL_VERSION);\n\t \n\tif (ver < SDHI_VER_GEN2_SDR104 && mmc_data->max_blk_count > U16_MAX)\n\t\tmmc_data->max_blk_count = U16_MAX;\n\n\t \n\tif (ver == SDHI_VER_GEN2_SDR50)\n\t\tmmc_data->flags &= ~TMIO_MMC_HAVE_CBSY;\n\n\tif (ver == SDHI_VER_GEN3_SDMMC && sdhi_has_quirk(priv, hs400_calib_table)) {\n\t\thost->fixup_request = renesas_sdhi_fixup_request;\n\t\tpriv->adjust_hs400_calib_table = *(\n\t\t\tres->start == SDHI_GEN3_MMC0_ADDR ?\n\t\t\tquirks->hs400_calib_table :\n\t\t\tquirks->hs400_calib_table + 1);\n\t}\n\n\t \n\tif (ver >= SDHI_VER_GEN3_SD)\n\t\thost->get_timeout_cycles = renesas_sdhi_gen3_get_cycles;\n\n\t \n\tif (of_data && of_data->scc_offset && ver >= SDHI_VER_GEN2_SDR104)\n\t\tpriv->scc_ctl = host->ctl + of_data->scc_offset;\n\n\t \n\tif (priv->scc_ctl && (host->mmc->caps & MMC_CAP_UHS_SDR104 ||\n\t    host->mmc->caps2 & MMC_CAP2_HSX00_1_8V)) {\n\t\tconst struct renesas_sdhi_scc *taps = of_data->taps;\n\t\tbool use_4tap = sdhi_has_quirk(priv, hs400_4taps);\n\t\tbool hit = false;\n\n\t\tfor (i = 0; i < of_data->taps_num; i++) {\n\t\t\tif (taps[i].clk_rate == 0 ||\n\t\t\t    taps[i].clk_rate == host->mmc->f_max) {\n\t\t\t\tpriv->scc_tappos = taps->tap;\n\t\t\t\tpriv->scc_tappos_hs400 = use_4tap ?\n\t\t\t\t\t\t\t taps->tap_hs400_4tap :\n\t\t\t\t\t\t\t taps->tap;\n\t\t\t\thit = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!hit)\n\t\t\tdev_warn(&host->pdev->dev, \"Unknown clock rate for tuning\\n\");\n\n\t\thost->check_retune = renesas_sdhi_check_scc_error;\n\t\thost->ops.execute_tuning = renesas_sdhi_execute_tuning;\n\t\thost->ops.prepare_hs400_tuning = renesas_sdhi_prepare_hs400_tuning;\n\t\thost->ops.hs400_downgrade = renesas_sdhi_disable_scc;\n\t\thost->ops.hs400_complete = renesas_sdhi_hs400_complete;\n\t}\n\n\tsd_ctrl_write32_as_16_and_16(host, CTL_IRQ_MASK, host->sdcard_irq_mask_all);\n\n\tnum_irqs = platform_irq_count(pdev);\n\tif (num_irqs < 0) {\n\t\tret = num_irqs;\n\t\tgoto eirq;\n\t}\n\n\t \n\tif (!num_irqs) {\n\t\tret = -ENXIO;\n\t\tgoto eirq;\n\t}\n\n\tfor (i = 0; i < num_irqs; i++) {\n\t\tirq = platform_get_irq(pdev, i);\n\t\tif (irq < 0) {\n\t\t\tret = irq;\n\t\t\tgoto eirq;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev, irq, tmio_mmc_irq, 0,\n\t\t\t\t       dev_name(&pdev->dev), host);\n\t\tif (ret)\n\t\t\tgoto eirq;\n\t}\n\n\tret = tmio_mmc_host_probe(host);\n\tif (ret < 0)\n\t\tgoto edisclk;\n\n\tdev_info(&pdev->dev, \"%s base at %pa, max clock rate %u MHz\\n\",\n\t\t mmc_hostname(host->mmc), &res->start, host->mmc->f_max / 1000000);\n\n\treturn ret;\n\neirq:\n\ttmio_mmc_host_remove(host);\nedisclk:\n\trenesas_sdhi_clk_disable(host);\nefree:\n\ttmio_mmc_host_free(host);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(renesas_sdhi_probe);\n\nvoid renesas_sdhi_remove(struct platform_device *pdev)\n{\n\tstruct tmio_mmc_host *host = platform_get_drvdata(pdev);\n\n\ttmio_mmc_host_remove(host);\n\trenesas_sdhi_clk_disable(host);\n\ttmio_mmc_host_free(host);\n}\nEXPORT_SYMBOL_GPL(renesas_sdhi_remove);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}