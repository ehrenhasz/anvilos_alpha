{
  "module_name": "sdricoh_cs.c",
  "hash_id": "b88711898760276033d933d12c32e41af9597ff56153f81016869913db52f668",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdricoh_cs.c",
  "human_readable_source": "\n \n\n \n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/ioport.h>\n#include <linux/iopoll.h>\n#include <linux/scatterlist.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ds.h>\n#include <linux/io.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n\n#define DRIVER_NAME \"sdricoh_cs\"\n\nstatic unsigned int switchlocked;\n\n \n#define SDRICOH_PCI_REGION 0\n#define SDRICOH_PCI_REGION_SIZE 0x1000\n\n \n#define R104_VERSION     0x104\n#define R200_CMD         0x200\n#define R204_CMD_ARG     0x204\n#define R208_DATAIO      0x208\n#define R20C_RESP        0x20c\n#define R21C_STATUS      0x21c\n#define R2E0_INIT        0x2e0\n#define R2E4_STATUS_RESP 0x2e4\n#define R2F0_RESET       0x2f0\n#define R224_MODE        0x224\n#define R226_BLOCKSIZE   0x226\n#define R228_POWER       0x228\n#define R230_DATA        0x230\n\n \n#define STATUS_CMD_FINISHED      0x00000001\n#define STATUS_TRANSFER_FINISHED 0x00000004\n#define STATUS_CARD_INSERTED     0x00000020\n#define STATUS_CARD_LOCKED       0x00000080\n#define STATUS_CMD_TIMEOUT       0x00400000\n#define STATUS_READY_TO_READ     0x01000000\n#define STATUS_READY_TO_WRITE    0x02000000\n#define STATUS_BUSY              0x40000000\n\n \n#define SDRICOH_CMD_TIMEOUT_US\t1000000\n#define SDRICOH_DATA_TIMEOUT_US\t1000000\n\n \nstatic const struct pcmcia_device_id pcmcia_ids[] = {\n\t \n\tPCMCIA_DEVICE_PROD_ID12(\"RICOH\", \"Bay1Controller\", 0xd9f522ed,\n\t\t\t\t0xc3901202),\n\tPCMCIA_DEVICE_PROD_ID12(\"RICOH\", \"Bay Controller\", 0xd9f522ed,\n\t\t\t\t0xace80909),\n\tPCMCIA_DEVICE_NULL,\n};\n\nMODULE_DEVICE_TABLE(pcmcia, pcmcia_ids);\n\n \nstruct sdricoh_host {\n\tstruct device *dev;\n\tstruct mmc_host *mmc;\t \n\tunsigned char __iomem *iobase;\n\tstruct pci_dev *pci_dev;\n\tint app_cmd;\n};\n\n \n\nstatic inline unsigned int sdricoh_readl(struct sdricoh_host *host,\n\t\t\t\t\t unsigned int reg)\n{\n\tunsigned int value = readl(host->iobase + reg);\n\tdev_vdbg(host->dev, \"rl %x 0x%x\\n\", reg, value);\n\treturn value;\n}\n\nstatic inline void sdricoh_writel(struct sdricoh_host *host, unsigned int reg,\n\t\t\t\t  unsigned int value)\n{\n\twritel(value, host->iobase + reg);\n\tdev_vdbg(host->dev, \"wl %x 0x%x\\n\", reg, value);\n\n}\n\nstatic inline void sdricoh_writew(struct sdricoh_host *host, unsigned int reg,\n\t\t\t\t\t unsigned short value)\n{\n\twritew(value, host->iobase + reg);\n\tdev_vdbg(host->dev, \"ww %x 0x%x\\n\", reg, value);\n}\n\nstatic inline unsigned int sdricoh_readb(struct sdricoh_host *host,\n\t\t\t\t\t unsigned int reg)\n{\n\tunsigned int value = readb(host->iobase + reg);\n\tdev_vdbg(host->dev, \"rb %x 0x%x\\n\", reg, value);\n\treturn value;\n}\n\nstatic bool sdricoh_status_ok(struct sdricoh_host *host, unsigned int status,\n\t\t\t      unsigned int wanted)\n{\n\tsdricoh_writel(host, R2E4_STATUS_RESP, status);\n\treturn status & wanted;\n}\n\nstatic int sdricoh_query_status(struct sdricoh_host *host, unsigned int wanted)\n{\n\tint ret;\n\tunsigned int status = 0;\n\tstruct device *dev = host->dev;\n\n\tret = read_poll_timeout(sdricoh_readl, status,\n\t\t\t\tsdricoh_status_ok(host, status, wanted),\n\t\t\t\t32, SDRICOH_DATA_TIMEOUT_US, false,\n\t\t\t\thost, R21C_STATUS);\n\tif (ret) {\n\t\tdev_err(dev, \"query_status: timeout waiting for %x\\n\", wanted);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\tif (status & 0x7F0000) {\n\t\tdev_err(dev, \"waiting for status bit %x failed\\n\", wanted);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n\n}\n\nstatic int sdricoh_mmc_cmd(struct sdricoh_host *host, struct mmc_command *cmd)\n{\n\tunsigned int status, timeout_us;\n\tint ret;\n\tunsigned char opcode = cmd->opcode;\n\n\t \n\tsdricoh_writel(host, R21C_STATUS, 0x18);\n\n\t \n\tif (host->app_cmd) {\n\t\topcode |= 64;\n\t\thost->app_cmd = 0;\n\t} else if (opcode == MMC_APP_CMD)\n\t\thost->app_cmd = 1;\n\n\t \n\tsdricoh_writel(host, R204_CMD_ARG, cmd->arg);\n\tsdricoh_writel(host, R200_CMD, (0x10000 << 8) | opcode);\n\n\t \n\tif (!opcode)\n\t\treturn 0;\n\n\ttimeout_us = cmd->busy_timeout ? cmd->busy_timeout * 1000 :\n\t\tSDRICOH_CMD_TIMEOUT_US;\n\n\tret = read_poll_timeout(sdricoh_readl, status,\n\t\t\tsdricoh_status_ok(host, status, STATUS_CMD_FINISHED),\n\t\t\t32, timeout_us, false,\n\t\t\thost, R21C_STATUS);\n\n\t \n\tif (ret || status & STATUS_CMD_TIMEOUT)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int sdricoh_reset(struct sdricoh_host *host)\n{\n\tdev_dbg(host->dev, \"reset\\n\");\n\tsdricoh_writel(host, R2F0_RESET, 0x10001);\n\tsdricoh_writel(host, R2E0_INIT, 0x10000);\n\tif (sdricoh_readl(host, R2E0_INIT) != 0x10000)\n\t\treturn -EIO;\n\tsdricoh_writel(host, R2E0_INIT, 0x10007);\n\n\tsdricoh_writel(host, R224_MODE, 0x2000000);\n\tsdricoh_writel(host, R228_POWER, 0xe0);\n\n\n\t \n\tsdricoh_writel(host, R21C_STATUS, 0x18);\n\n\treturn 0;\n}\n\nstatic int sdricoh_blockio(struct sdricoh_host *host, int read,\n\t\t\t\tu8 *buf, int len)\n{\n\tint size;\n\tu32 data = 0;\n\t \n\tif (read) {\n\t\tif (sdricoh_query_status(host, STATUS_READY_TO_READ))\n\t\t\treturn -ETIMEDOUT;\n\t\tsdricoh_writel(host, R21C_STATUS, 0x18);\n\t\t \n\t\twhile (len) {\n\t\t\tdata = sdricoh_readl(host, R230_DATA);\n\t\t\tsize = min(len, 4);\n\t\t\tlen -= size;\n\t\t\twhile (size) {\n\t\t\t\t*buf = data & 0xFF;\n\t\t\t\tbuf++;\n\t\t\t\tdata >>= 8;\n\t\t\t\tsize--;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (sdricoh_query_status(host, STATUS_READY_TO_WRITE))\n\t\t\treturn -ETIMEDOUT;\n\t\tsdricoh_writel(host, R21C_STATUS, 0x18);\n\t\t \n\t\twhile (len) {\n\t\t\tsize = min(len, 4);\n\t\t\tlen -= size;\n\t\t\twhile (size) {\n\t\t\t\tdata >>= 8;\n\t\t\t\tdata |= (u32)*buf << 24;\n\t\t\t\tbuf++;\n\t\t\t\tsize--;\n\t\t\t}\n\t\t\tsdricoh_writel(host, R230_DATA, data);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void sdricoh_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct sdricoh_host *host = mmc_priv(mmc);\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = cmd->data;\n\tstruct device *dev = host->dev;\n\tint i;\n\n\tdev_dbg(dev, \"=============================\\n\");\n\tdev_dbg(dev, \"sdricoh_request opcode=%i\\n\", cmd->opcode);\n\n\tsdricoh_writel(host, R21C_STATUS, 0x18);\n\n\t \n\tif (data) {\n\t\tsdricoh_writew(host, R226_BLOCKSIZE, data->blksz);\n\t\tsdricoh_writel(host, R208_DATAIO, 0);\n\t}\n\n\tcmd->error = sdricoh_mmc_cmd(host, cmd);\n\n\t \n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\t \n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tcmd->resp[i] =\n\t\t\t\t    sdricoh_readl(host,\n\t\t\t\t\t\t  R20C_RESP + (3 - i) * 4) << 8;\n\t\t\t\tif (i != 3)\n\t\t\t\t\tcmd->resp[i] |=\n\t\t\t\t\t    sdricoh_readb(host, R20C_RESP +\n\t\t\t\t\t\t\t  (3 - i) * 4 - 1);\n\t\t\t}\n\t\t} else\n\t\t\tcmd->resp[0] = sdricoh_readl(host, R20C_RESP);\n\t}\n\n\t \n\tif (data && cmd->error == 0) {\n\t\tdev_dbg(dev, \"transfer: blksz %i blocks %i sg_len %i \"\n\t\t\t\"sg length %i\\n\", data->blksz, data->blocks,\n\t\t\tdata->sg_len, data->sg->length);\n\n\t\t \n\t\tsdricoh_writel(host, R21C_STATUS, 0x837f031e);\n\t\tfor (i = 0; i < data->blocks; i++) {\n\t\t\tsize_t len = data->blksz;\n\t\t\tu8 *buf;\n\t\t\tstruct page *page;\n\t\t\tint result;\n\t\t\tpage = sg_page(data->sg);\n\n\t\t\tbuf = kmap(page) + data->sg->offset + (len * i);\n\t\t\tresult =\n\t\t\t\tsdricoh_blockio(host,\n\t\t\t\t\tdata->flags & MMC_DATA_READ, buf, len);\n\t\t\tkunmap(page);\n\t\t\tflush_dcache_page(page);\n\t\t\tif (result) {\n\t\t\t\tdev_err(dev, \"sdricoh_request: cmd %i \"\n\t\t\t\t\t\"block transfer failed\\n\", cmd->opcode);\n\t\t\t\tcmd->error = result;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\tdata->bytes_xfered += len;\n\t\t}\n\n\t\tsdricoh_writel(host, R208_DATAIO, 1);\n\n\t\tif (sdricoh_query_status(host, STATUS_TRANSFER_FINISHED)) {\n\t\t\tdev_err(dev, \"sdricoh_request: transfer end error\\n\");\n\t\t\tcmd->error = -EINVAL;\n\t\t}\n\t}\n\t \n\n\tmmc_request_done(mmc, mrq);\n\tdev_dbg(dev, \"=============================\\n\");\n}\n\nstatic void sdricoh_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdricoh_host *host = mmc_priv(mmc);\n\tdev_dbg(host->dev, \"set_ios\\n\");\n\n\tif (ios->power_mode == MMC_POWER_ON) {\n\t\tsdricoh_writel(host, R228_POWER, 0xc0e0);\n\n\t\tif (ios->bus_width == MMC_BUS_WIDTH_4) {\n\t\t\tsdricoh_writel(host, R224_MODE, 0x2000300);\n\t\t\tsdricoh_writel(host, R228_POWER, 0x40e0);\n\t\t} else {\n\t\t\tsdricoh_writel(host, R224_MODE, 0x2000340);\n\t\t}\n\n\t} else if (ios->power_mode == MMC_POWER_UP) {\n\t\tsdricoh_writel(host, R224_MODE, 0x2000320);\n\t\tsdricoh_writel(host, R228_POWER, 0xe0);\n\t}\n}\n\nstatic int sdricoh_get_ro(struct mmc_host *mmc)\n{\n\tstruct sdricoh_host *host = mmc_priv(mmc);\n\tunsigned int status;\n\n\tstatus = sdricoh_readl(host, R21C_STATUS);\n\tsdricoh_writel(host, R2E4_STATUS_RESP, status);\n\n\t \n\tif (switchlocked)\n\t\treturn !(status & STATUS_CARD_LOCKED);\n\n\treturn (status & STATUS_CARD_LOCKED);\n}\n\nstatic const struct mmc_host_ops sdricoh_ops = {\n\t.request = sdricoh_request,\n\t.set_ios = sdricoh_set_ios,\n\t.get_ro = sdricoh_get_ro,\n};\n\n \nstatic int sdricoh_init_mmc(struct pci_dev *pci_dev,\n\t\t\t    struct pcmcia_device *pcmcia_dev)\n{\n\tint result;\n\tvoid __iomem *iobase;\n\tstruct mmc_host *mmc;\n\tstruct sdricoh_host *host;\n\tstruct device *dev = &pcmcia_dev->dev;\n\t \n\tif (pci_resource_len(pci_dev, SDRICOH_PCI_REGION) !=\n\t    SDRICOH_PCI_REGION_SIZE) {\n\t\tdev_dbg(dev, \"unexpected pci resource len\\n\");\n\t\treturn -ENODEV;\n\t}\n\tiobase =\n\t    pci_iomap(pci_dev, SDRICOH_PCI_REGION, SDRICOH_PCI_REGION_SIZE);\n\tif (!iobase) {\n\t\tdev_err(dev, \"unable to map iobase\\n\");\n\t\treturn -ENODEV;\n\t}\n\t \n\tif (readl(iobase + R104_VERSION) != 0x4000) {\n\t\tdev_dbg(dev, \"no supported mmc controller found\\n\");\n\t\tresult = -ENODEV;\n\t\tgoto unmap_io;\n\t}\n\t \n\tmmc = pcmcia_dev->priv =\n\t    mmc_alloc_host(sizeof(struct sdricoh_host), &pcmcia_dev->dev);\n\tif (!mmc) {\n\t\tdev_err(dev, \"mmc_alloc_host failed\\n\");\n\t\tresult = -ENOMEM;\n\t\tgoto unmap_io;\n\t}\n\thost = mmc_priv(mmc);\n\n\thost->iobase = iobase;\n\thost->dev = dev;\n\thost->pci_dev = pci_dev;\n\n\tmmc->ops = &sdricoh_ops;\n\n\t \n\tmmc->f_min = 450000;\n\tmmc->f_max = 24000000;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\tmmc->max_seg_size = 1024 * 512;\n\tmmc->max_blk_size = 512;\n\n\t \n\tif (sdricoh_reset(host)) {\n\t\tdev_dbg(dev, \"could not reset\\n\");\n\t\tresult = -EIO;\n\t\tgoto free_host;\n\t}\n\n\tresult = mmc_add_host(mmc);\n\n\tif (!result) {\n\t\tdev_dbg(dev, \"mmc host registered\\n\");\n\t\treturn 0;\n\t}\nfree_host:\n\tmmc_free_host(mmc);\nunmap_io:\n\tpci_iounmap(pci_dev, iobase);\n\treturn result;\n}\n\n \nstatic int sdricoh_pcmcia_probe(struct pcmcia_device *pcmcia_dev)\n{\n\tstruct pci_dev *pci_dev = NULL;\n\n\tdev_info(&pcmcia_dev->dev, \"Searching MMC controller for pcmcia device\"\n\t\t\" %s %s ...\\n\", pcmcia_dev->prod_id[0], pcmcia_dev->prod_id[1]);\n\n\t \n\t \n\twhile ((pci_dev =\n\t\tpci_get_device(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_RL5C476,\n\t\t\t       pci_dev))) {\n\t\t \n\t\tif (!sdricoh_init_mmc(pci_dev, pcmcia_dev)) {\n\t\t\tdev_info(&pcmcia_dev->dev, \"MMC controller found\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t}\n\tdev_err(&pcmcia_dev->dev, \"No MMC controller was found.\\n\");\n\treturn -ENODEV;\n}\n\nstatic void sdricoh_pcmcia_detach(struct pcmcia_device *link)\n{\n\tstruct mmc_host *mmc = link->priv;\n\n\tdev_dbg(&link->dev, \"detach\\n\");\n\n\t \n\tif (mmc) {\n\t\tstruct sdricoh_host *host = mmc_priv(mmc);\n\t\tmmc_remove_host(mmc);\n\t\tpci_iounmap(host->pci_dev, host->iobase);\n\t\tpci_dev_put(host->pci_dev);\n\t\tmmc_free_host(mmc);\n\t}\n\tpcmcia_disable_device(link);\n\n}\n\n#ifdef CONFIG_PM\nstatic int sdricoh_pcmcia_suspend(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"suspend\\n\");\n\treturn 0;\n}\n\nstatic int sdricoh_pcmcia_resume(struct pcmcia_device *link)\n{\n\tstruct mmc_host *mmc = link->priv;\n\tdev_dbg(&link->dev, \"resume\\n\");\n\tsdricoh_reset(mmc_priv(mmc));\n\treturn 0;\n}\n#else\n#define sdricoh_pcmcia_suspend NULL\n#define sdricoh_pcmcia_resume NULL\n#endif\n\nstatic struct pcmcia_driver sdricoh_driver = {\n\t.name = DRIVER_NAME,\n\t.probe = sdricoh_pcmcia_probe,\n\t.remove = sdricoh_pcmcia_detach,\n\t.id_table = pcmcia_ids,\n\t.suspend = sdricoh_pcmcia_suspend,\n\t.resume = sdricoh_pcmcia_resume,\n};\nmodule_pcmcia_driver(sdricoh_driver);\n\nmodule_param(switchlocked, uint, 0444);\n\nMODULE_AUTHOR(\"Sascha Sommer <saschasommer@freenet.de>\");\nMODULE_DESCRIPTION(\"Ricoh PCMCIA Secure Digital Interface driver\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_PARM_DESC(switchlocked, \"Switch the cards locked status.\"\n\t\t\"Use this when unlocked cards are shown readonly (default 0)\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}