{
  "module_name": "sdhci-xenon.c",
  "hash_id": "dce4b5dac14455b7618975658967aab87cdd02119b539e0075a7dff566a72a3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-xenon.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n\n#include \"sdhci-pltfm.h\"\n#include \"sdhci-xenon.h\"\n\nstatic int xenon_enable_internal_clk(struct sdhci_host *host)\n{\n\tu32 reg;\n\tktime_t timeout;\n\n\treg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);\n\treg |= SDHCI_CLOCK_INT_EN;\n\tsdhci_writel(host, reg, SDHCI_CLOCK_CONTROL);\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 20);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\treg = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\t\tif (reg & SDHCI_CLOCK_INT_STABLE)\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"Internal clock never stabilised.\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tusleep_range(900, 1100);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xenon_set_sdclk_off_idle(struct sdhci_host *host,\n\t\t\t\t     unsigned char sdhc_id, bool enable)\n{\n\tu32 reg;\n\tu32 mask;\n\n\treg = sdhci_readl(host, XENON_SYS_OP_CTRL);\n\t \n\tmask = (0x1 << (XENON_SDCLK_IDLEOFF_ENABLE_SHIFT + sdhc_id));\n\tif (enable)\n\t\treg |= mask;\n\telse\n\t\treg &= ~mask;\n\n\tsdhci_writel(host, reg, XENON_SYS_OP_CTRL);\n}\n\n \nstatic void xenon_set_acg(struct sdhci_host *host, bool enable)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, XENON_SYS_OP_CTRL);\n\tif (enable)\n\t\treg &= ~XENON_AUTO_CLKGATE_DISABLE_MASK;\n\telse\n\t\treg |= XENON_AUTO_CLKGATE_DISABLE_MASK;\n\tsdhci_writel(host, reg, XENON_SYS_OP_CTRL);\n}\n\n \nstatic void xenon_enable_sdhc(struct sdhci_host *host,\n\t\t\t      unsigned char sdhc_id)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, XENON_SYS_OP_CTRL);\n\treg |= (BIT(sdhc_id) << XENON_SLOT_ENABLE_SHIFT);\n\tsdhci_writel(host, reg, XENON_SYS_OP_CTRL);\n\n\thost->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\n\t \n\thost->mmc->caps &= ~MMC_CAP_BUS_WIDTH_TEST;\n}\n\n \nstatic void xenon_disable_sdhc(struct sdhci_host *host,\n\t\t\t       unsigned char sdhc_id)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, XENON_SYS_OP_CTRL);\n\treg &= ~(BIT(sdhc_id) << XENON_SLOT_ENABLE_SHIFT);\n\tsdhci_writel(host, reg, XENON_SYS_OP_CTRL);\n}\n\n \nstatic void xenon_enable_sdhc_parallel_tran(struct sdhci_host *host,\n\t\t\t\t\t    unsigned char sdhc_id)\n{\n\tu32 reg;\n\n\treg = sdhci_readl(host, XENON_SYS_EXT_OP_CTRL);\n\treg |= BIT(sdhc_id);\n\tsdhci_writel(host, reg, XENON_SYS_EXT_OP_CTRL);\n}\n\n \nstatic void xenon_mask_cmd_conflict_err(struct sdhci_host *host)\n{\n\tu32  reg;\n\n\treg = sdhci_readl(host, XENON_SYS_EXT_OP_CTRL);\n\treg |= XENON_MASK_CMD_CONFLICT_ERR;\n\tsdhci_writel(host, reg, XENON_SYS_EXT_OP_CTRL);\n}\n\nstatic void xenon_retune_setup(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\t \n\treg = sdhci_readl(host, XENON_SLOT_RETUNING_REQ_CTRL);\n\treg &= ~XENON_RETUNING_COMPATIBLE;\n\tsdhci_writel(host, reg, XENON_SLOT_RETUNING_REQ_CTRL);\n\n\t \n\treg = sdhci_readl(host, SDHCI_SIGNAL_ENABLE);\n\treg &= ~SDHCI_INT_RETUNE;\n\tsdhci_writel(host, reg, SDHCI_SIGNAL_ENABLE);\n\treg = sdhci_readl(host, SDHCI_INT_ENABLE);\n\treg &= ~SDHCI_INT_RETUNE;\n\tsdhci_writel(host, reg, SDHCI_INT_ENABLE);\n\n\t \n\thost->tuning_mode = SDHCI_TUNING_MODE_1;\n\t \n\thost->tuning_count = 1 << (priv->tuning_count - 1);\n}\n\n \n \nstatic void xenon_reset_exit(struct sdhci_host *host,\n\t\t\t     unsigned char sdhc_id, u8 mask)\n{\n\t \n\tif (!(mask & SDHCI_RESET_ALL))\n\t\treturn;\n\n\t \n\txenon_retune_setup(host);\n\n\t \n\txenon_set_acg(host, false);\n\n\txenon_set_sdclk_off_idle(host, sdhc_id, false);\n\n\txenon_mask_cmd_conflict_err(host);\n}\n\nstatic void xenon_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_reset(host, mask);\n\txenon_reset_exit(host, priv->sdhc_id, mask);\n}\n\n \nstatic void xenon_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t    unsigned int timing)\n{\n\tu16 ctrl_2;\n\n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tif (timing == MMC_TIMING_MMC_HS200)\n\t\tctrl_2 |= XENON_CTRL_HS200;\n\telse if (timing == MMC_TIMING_UHS_SDR104)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104;\n\telse if (timing == MMC_TIMING_UHS_SDR12)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\telse if (timing == MMC_TIMING_UHS_SDR25)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\telse if (timing == MMC_TIMING_UHS_SDR50)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50;\n\telse if ((timing == MMC_TIMING_UHS_DDR50) ||\n\t\t (timing == MMC_TIMING_MMC_DDR52))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50;\n\telse if (timing == MMC_TIMING_MMC_HS400)\n\t\tctrl_2 |= XENON_CTRL_HS400;\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n}\n\nstatic void xenon_set_power(struct sdhci_host *host, unsigned char mode,\n\t\tunsigned short vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tu8 pwr = host->pwr;\n\n\tsdhci_set_power_noreg(host, mode, vdd);\n\n\tif (host->pwr == pwr)\n\t\treturn;\n\n\tif (host->pwr == 0)\n\t\tvdd = 0;\n\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);\n}\n\nstatic void xenon_voltage_switch(struct sdhci_host *host)\n{\n\t \n\tusleep_range(5000, 5500);\n}\n\nstatic unsigned int xenon_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\tif (pltfm_host->clk)\n\t\treturn sdhci_pltfm_clk_get_max_clock(host);\n\telse\n\t\treturn pltfm_host->clock;\n}\n\nstatic const struct sdhci_ops sdhci_xenon_ops = {\n\t.voltage_switch\t\t= xenon_voltage_switch,\n\t.set_clock\t\t= sdhci_set_clock,\n\t.set_power\t\t= xenon_set_power,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t= xenon_reset,\n\t.set_uhs_signaling\t= xenon_set_uhs_signaling,\n\t.get_max_clock\t\t= xenon_get_max_clock,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_xenon_pdata = {\n\t.ops = &sdhci_xenon_ops,\n\t.quirks = SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t  SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n};\n\n \nstatic void xenon_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\t \n\tif ((ios->timing == MMC_TIMING_MMC_HS400) ||\n\t    (ios->timing == MMC_TIMING_MMC_HS200) ||\n\t    (ios->timing == MMC_TIMING_MMC_HS)) {\n\t\thost->preset_enabled = false;\n\t\thost->quirks2 |= SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\t\thost->flags &= ~SDHCI_PV_ENABLED;\n\n\t\treg = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t\treg &= ~SDHCI_CTRL_PRESET_VAL_ENABLE;\n\t\tsdhci_writew(host, reg, SDHCI_HOST_CONTROL2);\n\t} else {\n\t\thost->quirks2 &= ~SDHCI_QUIRK2_PRESET_VALUE_BROKEN;\n\t}\n\n\tsdhci_set_ios(mmc, ios);\n\txenon_phy_adj(host, ios);\n\n\tif (host->clock > XENON_DEFAULT_SDCLK_FREQ)\n\t\txenon_set_sdclk_off_idle(host, priv->sdhc_id, true);\n}\n\nstatic int xenon_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t     struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\t \n\txenon_enable_internal_clk(host);\n\n\txenon_soc_pad_ctrl(host, ios->signal_voltage);\n\n\t \n\tif (PTR_ERR(mmc->supply.vqmmc) == -ENODEV)\n\t\treturn 0;\n\n\treturn sdhci_start_signal_voltage_switch(mmc, ios);\n}\n\n \nstatic void xenon_init_card(struct mmc_host *mmc, struct mmc_card *card)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\n\t \n\tpriv->init_card_type = card->type;\n}\n\nstatic int xenon_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tif (host->timing == MMC_TIMING_UHS_DDR50 ||\n\t\thost->timing == MMC_TIMING_MMC_DDR52)\n\t\treturn 0;\n\n\t \n\tif (host->tuning_mode != SDHCI_TUNING_MODE_1)\n\t\txenon_retune_setup(host);\n\n\treturn sdhci_execute_tuning(mmc, opcode);\n}\n\nstatic void xenon_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\tu8 sdhc_id = priv->sdhc_id;\n\n\tsdhci_enable_sdio_irq(mmc, enable);\n\n\tif (enable) {\n\t\t \n\t\treg = sdhci_readl(host, XENON_SYS_CFG_INFO);\n\t\treg |= (1 << (sdhc_id + XENON_SLOT_TYPE_SDIO_SHIFT));\n\t\tsdhci_writel(host, reg, XENON_SYS_CFG_INFO);\n\t} else {\n\t\t \n\t\treg = sdhci_readl(host, XENON_SYS_CFG_INFO);\n\t\treg &= ~(1 << (sdhc_id + XENON_SLOT_TYPE_SDIO_SHIFT));\n\t\tsdhci_writel(host, reg, XENON_SYS_CFG_INFO);\n\t}\n}\n\nstatic void xenon_replace_mmc_host_ops(struct sdhci_host *host)\n{\n\thost->mmc_host_ops.set_ios = xenon_set_ios;\n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\t\txenon_start_signal_voltage_switch;\n\thost->mmc_host_ops.init_card = xenon_init_card;\n\thost->mmc_host_ops.execute_tuning = xenon_execute_tuning;\n\thost->mmc_host_ops.enable_sdio_irq = xenon_enable_sdio_irq;\n}\n\n \nstatic int xenon_probe_params(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 sdhc_id, nr_sdhc;\n\tu32 tuning_count;\n\n\t \n\tif (priv->hw_version == XENON_AP806)\n\t\thost->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;\n\n\tsdhc_id = 0x0;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-sdhc-id\", &sdhc_id)) {\n\t\tnr_sdhc = sdhci_readl(host, XENON_SYS_CFG_INFO);\n\t\tnr_sdhc &= XENON_NR_SUPPORTED_SLOT_MASK;\n\t\tif (unlikely(sdhc_id > nr_sdhc)) {\n\t\t\tdev_err(mmc_dev(mmc), \"SDHC Index %d exceeds Number of SDHCs %d\\n\",\n\t\t\t\tsdhc_id, nr_sdhc);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tpriv->sdhc_id = sdhc_id;\n\n\ttuning_count = XENON_DEF_TUNING_COUNT;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-tun-count\",\n\t\t\t\t      &tuning_count)) {\n\t\tif (unlikely(tuning_count >= XENON_TMR_RETUN_NO_PRESENT)) {\n\t\t\tdev_err(mmc_dev(mmc), \"Wrong Re-tuning Count. Set default value %d\\n\",\n\t\t\t\tXENON_DEF_TUNING_COUNT);\n\t\t\ttuning_count = XENON_DEF_TUNING_COUNT;\n\t\t}\n\t}\n\tpriv->tuning_count = tuning_count;\n\n\treturn xenon_phy_parse_params(dev, host);\n}\n\nstatic int xenon_sdhc_prepare(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu8 sdhc_id = priv->sdhc_id;\n\n\t \n\txenon_enable_sdhc(host, sdhc_id);\n\n\t \n\txenon_set_acg(host, true);\n\n\t \n\txenon_enable_sdhc_parallel_tran(host, sdhc_id);\n\n\t \n\txenon_set_sdclk_off_idle(host, sdhc_id, false);\n\n\txenon_mask_cmd_conflict_err(host);\n\n\treturn 0;\n}\n\nstatic void xenon_sdhc_unprepare(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu8 sdhc_id = priv->sdhc_id;\n\n\t \n\txenon_disable_sdhc(host, sdhc_id);\n}\n\nstatic int xenon_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host;\n\tstruct xenon_priv *priv;\n\tint err;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_xenon_pdata,\n\t\t\t\tsizeof(struct xenon_priv));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\n\tpriv->hw_version = (unsigned long)device_get_match_data(&pdev->dev);\n\n\t \n\txenon_replace_mmc_host_ops(host);\n\n\tif (dev->of_node) {\n\t\tpltfm_host->clk = devm_clk_get(&pdev->dev, \"core\");\n\t\tif (IS_ERR(pltfm_host->clk)) {\n\t\t\terr = PTR_ERR(pltfm_host->clk);\n\t\t\tdev_err(&pdev->dev, \"Failed to setup input clk: %d\\n\", err);\n\t\t\tgoto free_pltfm;\n\t\t}\n\t\terr = clk_prepare_enable(pltfm_host->clk);\n\t\tif (err)\n\t\t\tgoto free_pltfm;\n\n\t\tpriv->axi_clk = devm_clk_get(&pdev->dev, \"axi\");\n\t\tif (IS_ERR(priv->axi_clk)) {\n\t\t\terr = PTR_ERR(priv->axi_clk);\n\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\tgoto err_clk;\n\t\t} else {\n\t\t\terr = clk_prepare_enable(priv->axi_clk);\n\t\t\tif (err)\n\t\t\t\tgoto err_clk;\n\t\t}\n\t}\n\n\terr = mmc_of_parse(host->mmc);\n\tif (err)\n\t\tgoto err_clk_axi;\n\n\tsdhci_get_property(pdev);\n\n\txenon_set_acg(host, false);\n\n\t \n\terr = xenon_probe_params(pdev);\n\tif (err)\n\t\tgoto err_clk_axi;\n\n\terr = xenon_sdhc_prepare(host);\n\tif (err)\n\t\tgoto err_clk_axi;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\n\terr = sdhci_add_host(host);\n\tif (err)\n\t\tgoto remove_sdhc;\n\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nremove_sdhc:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\txenon_sdhc_unprepare(host);\nerr_clk_axi:\n\tclk_disable_unprepare(priv->axi_clk);\nerr_clk:\n\tclk_disable_unprepare(pltfm_host->clk);\nfree_pltfm:\n\tsdhci_pltfm_free(pdev);\n\treturn err;\n}\n\nstatic void xenon_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tsdhci_remove_host(host, 0);\n\n\txenon_sdhc_unprepare(host);\n\tclk_disable_unprepare(priv->axi_clk);\n\tclk_disable_unprepare(pltfm_host->clk);\n\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int xenon_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = pm_runtime_force_suspend(dev);\n\n\tpriv->restore_needed = true;\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int xenon_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = sdhci_runtime_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tclk_disable_unprepare(pltfm_host->clk);\n\t \n\tpriv->clock = 0;\n\treturn 0;\n}\n\nstatic int xenon_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable mainck\\n\");\n\t\treturn ret;\n\t}\n\n\tif (priv->restore_needed) {\n\t\tret = xenon_sdhc_prepare(host);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tpriv->restore_needed = false;\n\t}\n\n\tret = sdhci_runtime_resume_host(host, 0);\n\tif (ret)\n\t\tgoto out;\n\treturn 0;\nout:\n\tclk_disable_unprepare(pltfm_host->clk);\n\treturn ret;\n}\n#endif  \n\nstatic const struct dev_pm_ops sdhci_xenon_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xenon_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(xenon_runtime_suspend,\n\t\t\t   xenon_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic const struct of_device_id sdhci_xenon_dt_ids[] = {\n\t{ .compatible = \"marvell,armada-ap806-sdhci\", .data = (void *)XENON_AP806},\n\t{ .compatible = \"marvell,armada-ap807-sdhci\", .data = (void *)XENON_AP807},\n\t{ .compatible = \"marvell,armada-cp110-sdhci\", .data =  (void *)XENON_CP110},\n\t{ .compatible = \"marvell,armada-3700-sdhci\", .data =  (void *)XENON_A3700},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, sdhci_xenon_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id sdhci_xenon_acpi_ids[] = {\n\t{ .id = \"MRVL0002\", XENON_AP806},\n\t{ .id = \"MRVL0003\", XENON_AP807},\n\t{ .id = \"MRVL0004\", XENON_CP110},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, sdhci_xenon_acpi_ids);\n#endif\n\nstatic struct platform_driver sdhci_xenon_driver = {\n\t.driver\t= {\n\t\t.name\t= \"xenon-sdhci\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_xenon_dt_ids,\n\t\t.acpi_match_table = ACPI_PTR(sdhci_xenon_acpi_ids),\n\t\t.pm = &sdhci_xenon_dev_pm_ops,\n\t},\n\t.probe\t= xenon_probe,\n\t.remove_new = xenon_remove,\n};\n\nmodule_platform_driver(sdhci_xenon_driver);\n\nMODULE_DESCRIPTION(\"SDHCI platform driver for Marvell Xenon SDHC\");\nMODULE_AUTHOR(\"Hu Ziji <huziji@marvell.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}