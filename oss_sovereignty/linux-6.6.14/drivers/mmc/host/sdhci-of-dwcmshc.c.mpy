{
  "module_name": "sdhci-of-dwcmshc.c",
  "hash_id": "d73504608140a17a20ba07eefc763b8eb9792059a1cf8f986e618255b3135403",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-dwcmshc.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n\n#include \"sdhci-pltfm.h\"\n\n#define SDHCI_DWCMSHC_ARG2_STUFF\tGENMASK(31, 16)\n\n \n#define DWCMSHC_CTRL_HS400\t\t0x7\n\n \n#define DWCMSHC_P_VENDOR_AREA1\t\t0xe8\n#define DWCMSHC_AREA1_MASK\t\tGENMASK(11, 0)\n \n#define DWCMSHC_HOST_CTRL3\t\t0x8\n#define DWCMSHC_EMMC_CONTROL\t\t0x2c\n#define DWCMSHC_CARD_IS_EMMC\t\tBIT(0)\n#define DWCMSHC_ENHANCED_STROBE\t\tBIT(8)\n#define DWCMSHC_EMMC_ATCTRL\t\t0x40\n\n \n#define DWCMSHC_EMMC_DLL_CTRL\t\t0x800\n#define DWCMSHC_EMMC_DLL_RXCLK\t\t0x804\n#define DWCMSHC_EMMC_DLL_TXCLK\t\t0x808\n#define DWCMSHC_EMMC_DLL_STRBIN\t\t0x80c\n#define DECMSHC_EMMC_DLL_CMDOUT\t\t0x810\n#define DWCMSHC_EMMC_DLL_STATUS0\t0x840\n#define DWCMSHC_EMMC_DLL_START\t\tBIT(0)\n#define DWCMSHC_EMMC_DLL_LOCKED\t\tBIT(8)\n#define DWCMSHC_EMMC_DLL_TIMEOUT\tBIT(9)\n#define DWCMSHC_EMMC_DLL_RXCLK_SRCSEL\t29\n#define DWCMSHC_EMMC_DLL_START_POINT\t16\n#define DWCMSHC_EMMC_DLL_INC\t\t8\n#define DWCMSHC_EMMC_DLL_BYPASS\t\tBIT(24)\n#define DWCMSHC_EMMC_DLL_DLYENA\t\tBIT(27)\n#define DLL_TXCLK_TAPNUM_DEFAULT\t0x10\n#define DLL_TXCLK_TAPNUM_90_DEGREES\t0xA\n#define DLL_TXCLK_TAPNUM_FROM_SW\tBIT(24)\n#define DLL_STRBIN_TAPNUM_DEFAULT\t0x8\n#define DLL_STRBIN_TAPNUM_FROM_SW\tBIT(24)\n#define DLL_STRBIN_DELAY_NUM_SEL\tBIT(26)\n#define DLL_STRBIN_DELAY_NUM_OFFSET\t16\n#define DLL_STRBIN_DELAY_NUM_DEFAULT\t0x16\n#define DLL_RXCLK_NO_INVERTER\t\t1\n#define DLL_RXCLK_INVERTER\t\t0\n#define DLL_CMDOUT_TAPNUM_90_DEGREES\t0x8\n#define DLL_RXCLK_ORI_GATE\t\tBIT(31)\n#define DLL_CMDOUT_TAPNUM_FROM_SW\tBIT(24)\n#define DLL_CMDOUT_SRC_CLK_NEG\t\tBIT(28)\n#define DLL_CMDOUT_EN_SRC_CLK_NEG\tBIT(29)\n\n#define DLL_LOCK_WO_TMOUT(x) \\\n\t((((x) & DWCMSHC_EMMC_DLL_LOCKED) == DWCMSHC_EMMC_DLL_LOCKED) && \\\n\t(((x) & DWCMSHC_EMMC_DLL_TIMEOUT) == 0))\n#define RK35xx_MAX_CLKS 3\n\n#define BOUNDARY_OK(addr, len) \\\n\t((addr | (SZ_128M - 1)) == ((addr + len - 1) | (SZ_128M - 1)))\n\nenum dwcmshc_rk_type {\n\tDWCMSHC_RK3568,\n\tDWCMSHC_RK3588,\n};\n\nstruct rk35xx_priv {\n\t \n\tstruct clk_bulk_data rockchip_clks[RK35xx_MAX_CLKS];\n\tstruct reset_control *reset;\n\tenum dwcmshc_rk_type devtype;\n\tu8 txclk_tapnum;\n};\n\nstruct dwcmshc_priv {\n\tstruct clk\t*bus_clk;\n\tint vendor_specific_area1;  \n\tvoid *priv;  \n};\n\n \nstatic void dwcmshc_adma_write_desc(struct sdhci_host *host, void **desc,\n\t\t\t\t    dma_addr_t addr, int len, unsigned int cmd)\n{\n\tint tmplen, offset;\n\n\tif (likely(!len || BOUNDARY_OK(addr, len))) {\n\t\tsdhci_adma_write_desc(host, desc, addr, len, cmd);\n\t\treturn;\n\t}\n\n\toffset = addr & (SZ_128M - 1);\n\ttmplen = SZ_128M - offset;\n\tsdhci_adma_write_desc(host, desc, addr, tmplen, cmd);\n\n\taddr += tmplen;\n\tlen -= tmplen;\n\tsdhci_adma_write_desc(host, desc, addr, len, cmd);\n}\n\nstatic unsigned int dwcmshc_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\tif (pltfm_host->clk)\n\t\treturn sdhci_pltfm_clk_get_max_clock(host);\n\telse\n\t\treturn pltfm_host->clock;\n}\n\nstatic unsigned int rk35xx_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn clk_round_rate(pltfm_host->clk, ULONG_MAX);\n}\n\nstatic void dwcmshc_check_auto_cmd23(struct mmc_host *mmc,\n\t\t\t\t     struct mmc_request *mrq)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\t \n\tif (mrq->sbc && (mrq->sbc->arg & SDHCI_DWCMSHC_ARG2_STUFF))\n\t\thost->flags &= ~SDHCI_AUTO_CMD23;\n\telse\n\t\thost->flags |= SDHCI_AUTO_CMD23;\n}\n\nstatic void dwcmshc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tdwcmshc_check_auto_cmd23(mmc, mrq);\n\n\tsdhci_request(mmc, mrq);\n}\n\nstatic void dwcmshc_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t      unsigned int timing)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu16 ctrl, ctrl_2;\n\n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tif ((timing == MMC_TIMING_MMC_HS200) ||\n\t    (timing == MMC_TIMING_UHS_SDR104))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104;\n\telse if (timing == MMC_TIMING_UHS_SDR12)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\telse if ((timing == MMC_TIMING_UHS_SDR25) ||\n\t\t (timing == MMC_TIMING_MMC_HS))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\telse if (timing == MMC_TIMING_UHS_SDR50)\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50;\n\telse if ((timing == MMC_TIMING_UHS_DDR50) ||\n\t\t (timing == MMC_TIMING_MMC_DDR52))\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50;\n\telse if (timing == MMC_TIMING_MMC_HS400) {\n\t\t \n\t\tctrl = sdhci_readw(host, priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL);\n\t\tctrl |= DWCMSHC_CARD_IS_EMMC;\n\t\tsdhci_writew(host, ctrl, priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL);\n\n\t\tctrl_2 |= DWCMSHC_CTRL_HS400;\n\t}\n\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n}\n\nstatic void dwcmshc_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\t  struct mmc_ios *ios)\n{\n\tu32 vendor;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint reg = priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL;\n\n\tvendor = sdhci_readl(host, reg);\n\tif (ios->enhanced_strobe)\n\t\tvendor |= DWCMSHC_ENHANCED_STROBE;\n\telse\n\t\tvendor &= ~DWCMSHC_ENHANCED_STROBE;\n\n\tsdhci_writel(host, vendor, reg);\n}\n\nstatic void dwcmshc_rk3568_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *dwc_priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct rk35xx_priv *priv = dwc_priv->priv;\n\tu8 txclk_tapnum = DLL_TXCLK_TAPNUM_DEFAULT;\n\tu32 extra, reg;\n\tint err;\n\n\thost->mmc->actual_clock = 0;\n\n\tif (clock == 0) {\n\t\t \n\t\tsdhci_set_clock(host, clock);\n\t\treturn;\n\t}\n\n\t \n\tif (clock <= 400000)\n\t\tclock = 375000;\n\n\terr = clk_set_rate(pltfm_host->clk, clock);\n\tif (err)\n\t\tdev_err(mmc_dev(host->mmc), \"fail to set clock %d\", clock);\n\n\tsdhci_set_clock(host, clock);\n\n\t \n\treg = dwc_priv->vendor_specific_area1 + DWCMSHC_HOST_CTRL3;\n\textra = sdhci_readl(host, reg);\n\textra &= ~BIT(0);\n\tsdhci_writel(host, extra, reg);\n\n\tif (clock <= 52000000) {\n\t\t \n\t\tsdhci_writel(host, DWCMSHC_EMMC_DLL_BYPASS | DWCMSHC_EMMC_DLL_START, DWCMSHC_EMMC_DLL_CTRL);\n\t\tsdhci_writel(host, DLL_RXCLK_ORI_GATE, DWCMSHC_EMMC_DLL_RXCLK);\n\t\tsdhci_writel(host, 0, DWCMSHC_EMMC_DLL_TXCLK);\n\t\tsdhci_writel(host, 0, DECMSHC_EMMC_DLL_CMDOUT);\n\t\t \n\t\textra = DWCMSHC_EMMC_DLL_DLYENA |\n\t\t\tDLL_STRBIN_DELAY_NUM_SEL |\n\t\t\tDLL_STRBIN_DELAY_NUM_DEFAULT << DLL_STRBIN_DELAY_NUM_OFFSET;\n\t\tsdhci_writel(host, extra, DWCMSHC_EMMC_DLL_STRBIN);\n\t\treturn;\n\t}\n\n\t \n\tsdhci_writel(host, BIT(1), DWCMSHC_EMMC_DLL_CTRL);\n\tudelay(1);\n\tsdhci_writel(host, 0x0, DWCMSHC_EMMC_DLL_CTRL);\n\n\t \n\textra = DWCMSHC_EMMC_DLL_DLYENA;\n\tif (priv->devtype == DWCMSHC_RK3568)\n\t\textra |= DLL_RXCLK_NO_INVERTER << DWCMSHC_EMMC_DLL_RXCLK_SRCSEL;\n\tsdhci_writel(host, extra, DWCMSHC_EMMC_DLL_RXCLK);\n\n\t \n\textra = 0x5 << DWCMSHC_EMMC_DLL_START_POINT |\n\t\t0x2 << DWCMSHC_EMMC_DLL_INC |\n\t\tDWCMSHC_EMMC_DLL_START;\n\tsdhci_writel(host, extra, DWCMSHC_EMMC_DLL_CTRL);\n\terr = readl_poll_timeout(host->ioaddr + DWCMSHC_EMMC_DLL_STATUS0,\n\t\t\t\t extra, DLL_LOCK_WO_TMOUT(extra), 1,\n\t\t\t\t 500 * USEC_PER_MSEC);\n\tif (err) {\n\t\tdev_err(mmc_dev(host->mmc), \"DLL lock timeout!\\n\");\n\t\treturn;\n\t}\n\n\textra = 0x1 << 16 |  \n\t\t0x3 << 17 |  \n\t\t0x3 << 19;   \n\tsdhci_writel(host, extra, dwc_priv->vendor_specific_area1 + DWCMSHC_EMMC_ATCTRL);\n\n\tif (host->mmc->ios.timing == MMC_TIMING_MMC_HS200 ||\n\t    host->mmc->ios.timing == MMC_TIMING_MMC_HS400)\n\t\ttxclk_tapnum = priv->txclk_tapnum;\n\n\tif ((priv->devtype == DWCMSHC_RK3588) && host->mmc->ios.timing == MMC_TIMING_MMC_HS400) {\n\t\ttxclk_tapnum = DLL_TXCLK_TAPNUM_90_DEGREES;\n\n\t\textra = DLL_CMDOUT_SRC_CLK_NEG |\n\t\t\tDLL_CMDOUT_EN_SRC_CLK_NEG |\n\t\t\tDWCMSHC_EMMC_DLL_DLYENA |\n\t\t\tDLL_CMDOUT_TAPNUM_90_DEGREES |\n\t\t\tDLL_CMDOUT_TAPNUM_FROM_SW;\n\t\tsdhci_writel(host, extra, DECMSHC_EMMC_DLL_CMDOUT);\n\t}\n\n\textra = DWCMSHC_EMMC_DLL_DLYENA |\n\t\tDLL_TXCLK_TAPNUM_FROM_SW |\n\t\tDLL_RXCLK_NO_INVERTER << DWCMSHC_EMMC_DLL_RXCLK_SRCSEL |\n\t\ttxclk_tapnum;\n\tsdhci_writel(host, extra, DWCMSHC_EMMC_DLL_TXCLK);\n\n\textra = DWCMSHC_EMMC_DLL_DLYENA |\n\t\tDLL_STRBIN_TAPNUM_DEFAULT |\n\t\tDLL_STRBIN_TAPNUM_FROM_SW;\n\tsdhci_writel(host, extra, DWCMSHC_EMMC_DLL_STRBIN);\n}\n\nstatic void rk35xx_sdhci_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *dwc_priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct rk35xx_priv *priv = dwc_priv->priv;\n\n\tif (mask & SDHCI_RESET_ALL && priv->reset) {\n\t\treset_control_assert(priv->reset);\n\t\tudelay(1);\n\t\treset_control_deassert(priv->reset);\n\t}\n\n\tsdhci_reset(host, mask);\n}\n\nstatic const struct sdhci_ops sdhci_dwcmshc_ops = {\n\t.set_clock\t\t= sdhci_set_clock,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.set_uhs_signaling\t= dwcmshc_set_uhs_signaling,\n\t.get_max_clock\t\t= dwcmshc_get_max_clock,\n\t.reset\t\t\t= sdhci_reset,\n\t.adma_write_desc\t= dwcmshc_adma_write_desc,\n};\n\nstatic const struct sdhci_ops sdhci_dwcmshc_rk35xx_ops = {\n\t.set_clock\t\t= dwcmshc_rk3568_set_clock,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.set_uhs_signaling\t= dwcmshc_set_uhs_signaling,\n\t.get_max_clock\t\t= rk35xx_get_max_clock,\n\t.reset\t\t\t= rk35xx_sdhci_reset,\n\t.adma_write_desc\t= dwcmshc_adma_write_desc,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_dwcmshc_pdata = {\n\t.ops = &sdhci_dwcmshc_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct sdhci_pltfm_data sdhci_dwcmshc_bf3_pdata = {\n\t.ops = &sdhci_dwcmshc_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_ACMD23_BROKEN,\n};\n#endif\n\nstatic const struct sdhci_pltfm_data sdhci_dwcmshc_rk35xx_pdata = {\n\t.ops = &sdhci_dwcmshc_rk35xx_ops,\n\t.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\t  SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,\n};\n\nstatic int dwcmshc_rk35xx_init(struct sdhci_host *host, struct dwcmshc_priv *dwc_priv)\n{\n\tint err;\n\tstruct rk35xx_priv *priv = dwc_priv->priv;\n\n\tpriv->reset = devm_reset_control_array_get_optional_exclusive(mmc_dev(host->mmc));\n\tif (IS_ERR(priv->reset)) {\n\t\terr = PTR_ERR(priv->reset);\n\t\tdev_err(mmc_dev(host->mmc), \"failed to get reset control %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tpriv->rockchip_clks[0].id = \"axi\";\n\tpriv->rockchip_clks[1].id = \"block\";\n\tpriv->rockchip_clks[2].id = \"timer\";\n\terr = devm_clk_bulk_get_optional(mmc_dev(host->mmc), RK35xx_MAX_CLKS,\n\t\t\t\t\t priv->rockchip_clks);\n\tif (err) {\n\t\tdev_err(mmc_dev(host->mmc), \"failed to get clocks %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_bulk_prepare_enable(RK35xx_MAX_CLKS, priv->rockchip_clks);\n\tif (err) {\n\t\tdev_err(mmc_dev(host->mmc), \"failed to enable clocks %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tif (of_property_read_u8(mmc_dev(host->mmc)->of_node, \"rockchip,txclk-tapnum\",\n\t\t\t\t&priv->txclk_tapnum))\n\t\tpriv->txclk_tapnum = DLL_TXCLK_TAPNUM_DEFAULT;\n\n\t \n\tsdhci_writel(host, 0x0, dwc_priv->vendor_specific_area1 + DWCMSHC_HOST_CTRL3);\n\t \n\tsdhci_writel(host, 0, DWCMSHC_EMMC_DLL_TXCLK);\n\tsdhci_writel(host, 0, DWCMSHC_EMMC_DLL_STRBIN);\n\n\treturn 0;\n}\n\nstatic void dwcmshc_rk35xx_postinit(struct sdhci_host *host, struct dwcmshc_priv *dwc_priv)\n{\n\t \n\tif (host->mmc->f_max <= 52000000) {\n\t\tdev_info(mmc_dev(host->mmc), \"Disabling HS200/HS400, frequency too low (%d)\\n\",\n\t\t\t host->mmc->f_max);\n\t\thost->mmc->caps2 &= ~(MMC_CAP2_HS200 | MMC_CAP2_HS400);\n\t\thost->mmc->caps &= ~(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR);\n\t}\n}\n\nstatic const struct of_device_id sdhci_dwcmshc_dt_ids[] = {\n\t{\n\t\t.compatible = \"rockchip,rk3588-dwcmshc\",\n\t\t.data = &sdhci_dwcmshc_rk35xx_pdata,\n\t},\n\t{\n\t\t.compatible = \"rockchip,rk3568-dwcmshc\",\n\t\t.data = &sdhci_dwcmshc_rk35xx_pdata,\n\t},\n\t{\n\t\t.compatible = \"snps,dwcmshc-sdhci\",\n\t\t.data = &sdhci_dwcmshc_pdata,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdhci_dwcmshc_dt_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id sdhci_dwcmshc_acpi_ids[] = {\n\t{\n\t\t.id = \"MLNXBF30\",\n\t\t.driver_data = (kernel_ulong_t)&sdhci_dwcmshc_bf3_pdata,\n\t},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, sdhci_dwcmshc_acpi_ids);\n#endif\n\nstatic int dwcmshc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_host *host;\n\tstruct dwcmshc_priv *priv;\n\tstruct rk35xx_priv *rk_priv = NULL;\n\tconst struct sdhci_pltfm_data *pltfm_data;\n\tint err;\n\tu32 extra;\n\n\tpltfm_data = device_get_match_data(&pdev->dev);\n\tif (!pltfm_data) {\n\t\tdev_err(&pdev->dev, \"Error: No device match data found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thost = sdhci_pltfm_init(pdev, pltfm_data,\n\t\t\t\tsizeof(struct dwcmshc_priv));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\t \n\textra = DIV_ROUND_UP_ULL(dma_get_required_mask(dev), SZ_128M);\n\tif (extra > SDHCI_MAX_SEGS)\n\t\textra = SDHCI_MAX_SEGS;\n\thost->adma_table_cnt += extra;\n\n\tpltfm_host = sdhci_priv(host);\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\n\tif (dev->of_node) {\n\t\tpltfm_host->clk = devm_clk_get(dev, \"core\");\n\t\tif (IS_ERR(pltfm_host->clk)) {\n\t\t\terr = PTR_ERR(pltfm_host->clk);\n\t\t\tdev_err(dev, \"failed to get core clk: %d\\n\", err);\n\t\t\tgoto free_pltfm;\n\t\t}\n\t\terr = clk_prepare_enable(pltfm_host->clk);\n\t\tif (err)\n\t\t\tgoto free_pltfm;\n\n\t\tpriv->bus_clk = devm_clk_get(dev, \"bus\");\n\t\tif (!IS_ERR(priv->bus_clk))\n\t\t\tclk_prepare_enable(priv->bus_clk);\n\t}\n\n\terr = mmc_of_parse(host->mmc);\n\tif (err)\n\t\tgoto err_clk;\n\n\tsdhci_get_of_property(pdev);\n\n\tpriv->vendor_specific_area1 =\n\t\tsdhci_readl(host, DWCMSHC_P_VENDOR_AREA1) & DWCMSHC_AREA1_MASK;\n\n\thost->mmc_host_ops.request = dwcmshc_request;\n\thost->mmc_host_ops.hs400_enhanced_strobe = dwcmshc_hs400_enhanced_strobe;\n\n\tif (pltfm_data == &sdhci_dwcmshc_rk35xx_pdata) {\n\t\trk_priv = devm_kzalloc(&pdev->dev, sizeof(struct rk35xx_priv), GFP_KERNEL);\n\t\tif (!rk_priv) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_clk;\n\t\t}\n\n\t\tif (of_device_is_compatible(pdev->dev.of_node, \"rockchip,rk3588-dwcmshc\"))\n\t\t\trk_priv->devtype = DWCMSHC_RK3588;\n\t\telse\n\t\t\trk_priv->devtype = DWCMSHC_RK3568;\n\n\t\tpriv->priv = rk_priv;\n\n\t\terr = dwcmshc_rk35xx_init(host, priv);\n\t\tif (err)\n\t\t\tgoto err_clk;\n\t}\n\n#ifdef CONFIG_ACPI\n\tif (pltfm_data == &sdhci_dwcmshc_bf3_pdata)\n\t\tsdhci_enable_v4_mode(host);\n#endif\n\n\thost->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;\n\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\terr = sdhci_setup_host(host);\n\tif (err)\n\t\tgoto err_rpm;\n\n\tif (rk_priv)\n\t\tdwcmshc_rk35xx_postinit(host, priv);\n\n\terr = __sdhci_add_host(host);\n\tif (err)\n\t\tgoto err_setup_host;\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n\nerr_setup_host:\n\tsdhci_cleanup_host(host);\nerr_rpm:\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\nerr_clk:\n\tclk_disable_unprepare(pltfm_host->clk);\n\tclk_disable_unprepare(priv->bus_clk);\n\tif (rk_priv)\n\t\tclk_bulk_disable_unprepare(RK35xx_MAX_CLKS,\n\t\t\t\t\t   rk_priv->rockchip_clks);\nfree_pltfm:\n\tsdhci_pltfm_free(pdev);\n\treturn err;\n}\n\nstatic void dwcmshc_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct rk35xx_priv *rk_priv = priv->priv;\n\n\tsdhci_remove_host(host, 0);\n\n\tclk_disable_unprepare(pltfm_host->clk);\n\tclk_disable_unprepare(priv->bus_clk);\n\tif (rk_priv)\n\t\tclk_bulk_disable_unprepare(RK35xx_MAX_CLKS,\n\t\t\t\t\t   rk_priv->rockchip_clks);\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int dwcmshc_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct rk35xx_priv *rk_priv = priv->priv;\n\tint ret;\n\n\tpm_runtime_resume(dev);\n\n\tret = sdhci_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tclk_disable_unprepare(pltfm_host->clk);\n\tif (!IS_ERR(priv->bus_clk))\n\t\tclk_disable_unprepare(priv->bus_clk);\n\n\tif (rk_priv)\n\t\tclk_bulk_disable_unprepare(RK35xx_MAX_CLKS,\n\t\t\t\t\t   rk_priv->rockchip_clks);\n\n\treturn ret;\n}\n\nstatic int dwcmshc_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct rk35xx_priv *rk_priv = priv->priv;\n\tint ret;\n\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(priv->bus_clk)) {\n\t\tret = clk_prepare_enable(priv->bus_clk);\n\t\tif (ret)\n\t\t\tgoto disable_clk;\n\t}\n\n\tif (rk_priv) {\n\t\tret = clk_bulk_prepare_enable(RK35xx_MAX_CLKS,\n\t\t\t\t\t      rk_priv->rockchip_clks);\n\t\tif (ret)\n\t\t\tgoto disable_bus_clk;\n\t}\n\n\tret = sdhci_resume_host(host);\n\tif (ret)\n\t\tgoto disable_rockchip_clks;\n\n\treturn 0;\n\ndisable_rockchip_clks:\n\tif (rk_priv)\n\t\tclk_bulk_disable_unprepare(RK35xx_MAX_CLKS,\n\t\t\t\t\t   rk_priv->rockchip_clks);\ndisable_bus_clk:\n\tif (!IS_ERR(priv->bus_clk))\n\t\tclk_disable_unprepare(priv->bus_clk);\ndisable_clk:\n\tclk_disable_unprepare(pltfm_host->clk);\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\n\nstatic void dwcmshc_enable_card_clk(struct sdhci_host *host)\n{\n\tu16 ctrl;\n\n\tctrl = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tif ((ctrl & SDHCI_CLOCK_INT_EN) && !(ctrl & SDHCI_CLOCK_CARD_EN)) {\n\t\tctrl |= SDHCI_CLOCK_CARD_EN;\n\t\tsdhci_writew(host, ctrl, SDHCI_CLOCK_CONTROL);\n\t}\n}\n\nstatic void dwcmshc_disable_card_clk(struct sdhci_host *host)\n{\n\tu16 ctrl;\n\n\tctrl = sdhci_readw(host, SDHCI_CLOCK_CONTROL);\n\tif (ctrl & SDHCI_CLOCK_CARD_EN) {\n\t\tctrl &= ~SDHCI_CLOCK_CARD_EN;\n\t\tsdhci_writew(host, ctrl, SDHCI_CLOCK_CONTROL);\n\t}\n}\n\nstatic int dwcmshc_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tdwcmshc_disable_card_clk(host);\n\n\treturn 0;\n}\n\nstatic int dwcmshc_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tdwcmshc_enable_card_clk(host);\n\n\treturn 0;\n}\n\n#endif\n\nstatic const struct dev_pm_ops dwcmshc_pmops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwcmshc_suspend, dwcmshc_resume)\n\tSET_RUNTIME_PM_OPS(dwcmshc_runtime_suspend,\n\t\t\t   dwcmshc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sdhci_dwcmshc_driver = {\n\t.driver\t= {\n\t\t.name\t= \"sdhci-dwcmshc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_dwcmshc_dt_ids,\n\t\t.acpi_match_table = ACPI_PTR(sdhci_dwcmshc_acpi_ids),\n\t\t.pm = &dwcmshc_pmops,\n\t},\n\t.probe\t= dwcmshc_probe,\n\t.remove_new = dwcmshc_remove,\n};\nmodule_platform_driver(sdhci_dwcmshc_driver);\n\nMODULE_DESCRIPTION(\"SDHCI platform driver for Synopsys DWC MSHC\");\nMODULE_AUTHOR(\"Jisheng Zhang <jszhang@kernel.org>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}