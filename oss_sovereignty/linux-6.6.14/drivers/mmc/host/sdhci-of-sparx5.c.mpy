{
  "module_name": "sdhci-of-sparx5.c",
  "hash_id": "c2620511ec01c7cb9673b42497660862d2f1827c43f189387152bdc720054209",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-of-sparx5.c",
  "human_readable_source": "\n \n\n#include <linux/sizes.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n\n#include \"sdhci-pltfm.h\"\n\n#define CPU_REGS_GENERAL_CTRL\t(0x22 * 4)\n#define  MSHC_DLY_CC_MASK\tGENMASK(16, 13)\n#define  MSHC_DLY_CC_SHIFT\t13\n#define  MSHC_DLY_CC_MAX\t15\n\n#define CPU_REGS_PROC_CTRL\t(0x2C * 4)\n#define  ACP_CACHE_FORCE_ENA\tBIT(4)\n#define  ACP_AWCACHE\t\tBIT(3)\n#define  ACP_ARCACHE\t\tBIT(2)\n#define  ACP_CACHE_MASK\t\t(ACP_CACHE_FORCE_ENA|ACP_AWCACHE|ACP_ARCACHE)\n\n#define MSHC2_VERSION\t\t\t0x500\t \n#define MSHC2_TYPE\t\t\t0x504\t \n#define MSHC2_EMMC_CTRL\t\t\t0x52c\t \n#define  MSHC2_EMMC_CTRL_EMMC_RST_N\tBIT(2)\n#define  MSHC2_EMMC_CTRL_IS_EMMC\tBIT(0)\n\nstruct sdhci_sparx5_data {\n\tstruct sdhci_host *host;\n\tstruct regmap *cpu_ctrl;\n\tint delay_clock;\n};\n\n#define BOUNDARY_OK(addr, len) \\\n\t((addr | (SZ_128M - 1)) == ((addr + len - 1) | (SZ_128M - 1)))\n\n \nstatic void sdhci_sparx5_adma_write_desc(struct sdhci_host *host, void **desc,\n\t\t\t\t\t  dma_addr_t addr, int len,\n\t\t\t\t\t  unsigned int cmd)\n{\n\tint tmplen, offset;\n\n\tif (likely(!len || BOUNDARY_OK(addr, len))) {\n\t\tsdhci_adma_write_desc(host, desc, addr, len, cmd);\n\t\treturn;\n\t}\n\n\tpr_debug(\"%s: write_desc: splitting dma len %d, offset %pad\\n\",\n\t\t mmc_hostname(host->mmc), len, &addr);\n\n\toffset = addr & (SZ_128M - 1);\n\ttmplen = SZ_128M - offset;\n\tsdhci_adma_write_desc(host, desc, addr, tmplen, cmd);\n\n\taddr += tmplen;\n\tlen -= tmplen;\n\tsdhci_adma_write_desc(host, desc, addr, len, cmd);\n}\n\nstatic void sparx5_set_cacheable(struct sdhci_host *host, u32 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_sparx5_data *sdhci_sparx5 = sdhci_pltfm_priv(pltfm_host);\n\n\tpr_debug(\"%s: Set Cacheable = 0x%x\\n\", mmc_hostname(host->mmc), value);\n\n\t \n\tregmap_update_bits(sdhci_sparx5->cpu_ctrl,\n\t\t\t   CPU_REGS_PROC_CTRL, ACP_CACHE_MASK, value);\n}\n\nstatic void sparx5_set_delay(struct sdhci_host *host, u8 value)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_sparx5_data *sdhci_sparx5 = sdhci_pltfm_priv(pltfm_host);\n\n\tpr_debug(\"%s: Set DLY_CC = %u\\n\", mmc_hostname(host->mmc), value);\n\n\t \n\tregmap_update_bits(sdhci_sparx5->cpu_ctrl,\n\t\t\t   CPU_REGS_GENERAL_CTRL,\n\t\t\t   MSHC_DLY_CC_MASK,\n\t\t\t   (value << MSHC_DLY_CC_SHIFT));\n}\n\nstatic void sdhci_sparx5_set_emmc(struct sdhci_host *host)\n{\n\tif (!mmc_card_is_removable(host->mmc)) {\n\t\tu8 value;\n\n\t\tvalue = sdhci_readb(host, MSHC2_EMMC_CTRL);\n\t\tif (!(value & MSHC2_EMMC_CTRL_IS_EMMC)) {\n\t\t\tvalue |= MSHC2_EMMC_CTRL_IS_EMMC;\n\t\t\tpr_debug(\"%s: Set EMMC_CTRL: 0x%08x\\n\",\n\t\t\t\t mmc_hostname(host->mmc), value);\n\t\t\tsdhci_writeb(host, value, MSHC2_EMMC_CTRL);\n\t\t}\n\t}\n}\n\nstatic void sdhci_sparx5_reset_emmc(struct sdhci_host *host)\n{\n\tu8 value;\n\n\tpr_debug(\"%s: Toggle EMMC_CTRL.EMMC_RST_N\\n\", mmc_hostname(host->mmc));\n\tvalue = sdhci_readb(host, MSHC2_EMMC_CTRL) &\n\t\t~MSHC2_EMMC_CTRL_EMMC_RST_N;\n\tsdhci_writeb(host, value, MSHC2_EMMC_CTRL);\n\t \n\tusleep_range(10, 20);\n\tsdhci_writeb(host, value | MSHC2_EMMC_CTRL_EMMC_RST_N,\n\t\t     MSHC2_EMMC_CTRL);\n\t \n\tusleep_range(300, 400);\n}\n\nstatic void sdhci_sparx5_reset(struct sdhci_host *host, u8 mask)\n{\n\tpr_debug(\"%s: *** RESET: mask %d\\n\", mmc_hostname(host->mmc), mask);\n\n\tsdhci_reset(host, mask);\n\n\t \n\tsdhci_sparx5_set_emmc(host);\n}\n\nstatic const struct sdhci_ops sdhci_sparx5_ops = {\n\t.set_clock\t\t= sdhci_set_clock,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.set_uhs_signaling\t= sdhci_set_uhs_signaling,\n\t.get_max_clock\t\t= sdhci_pltfm_clk_get_max_clock,\n\t.reset\t\t\t= sdhci_sparx5_reset,\n\t.adma_write_desc\t= sdhci_sparx5_adma_write_desc,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_sparx5_pdata = {\n\t.quirks  = 0,\n\t.quirks2 = SDHCI_QUIRK2_HOST_NO_CMD23 |  \n\t\t   SDHCI_QUIRK2_NO_1_8_V,  \n\t.ops = &sdhci_sparx5_ops,\n};\n\nstatic int sdhci_sparx5_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tconst char *syscon = \"microchip,sparx5-cpu-syscon\";\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_sparx5_data *sdhci_sparx5;\n\tstruct device_node *np = pdev->dev.of_node;\n\tu32 value;\n\tu32 extra;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_sparx5_pdata,\n\t\t\t\tsizeof(*sdhci_sparx5));\n\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\t \n\textra = DIV_ROUND_UP_ULL(dma_get_required_mask(&pdev->dev), SZ_128M);\n\tif (extra > SDHCI_MAX_SEGS)\n\t\textra = SDHCI_MAX_SEGS;\n\thost->adma_table_cnt += extra;\n\n\tpltfm_host = sdhci_priv(host);\n\tsdhci_sparx5 = sdhci_pltfm_priv(pltfm_host);\n\tsdhci_sparx5->host = host;\n\n\tpltfm_host->clk = devm_clk_get_enabled(&pdev->dev, \"core\");\n\tif (IS_ERR(pltfm_host->clk)) {\n\t\tret = PTR_ERR(pltfm_host->clk);\n\t\tdev_err(&pdev->dev, \"failed to get and enable core clk: %d\\n\", ret);\n\t\tgoto free_pltfm;\n\t}\n\n\tif (!of_property_read_u32(np, \"microchip,clock-delay\", &value) &&\n\t    (value > 0 && value <= MSHC_DLY_CC_MAX))\n\t\tsdhci_sparx5->delay_clock = value;\n\n\tsdhci_get_of_property(pdev);\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto free_pltfm;\n\n\tsdhci_sparx5->cpu_ctrl = syscon_regmap_lookup_by_compatible(syscon);\n\tif (IS_ERR(sdhci_sparx5->cpu_ctrl)) {\n\t\tdev_err(&pdev->dev, \"No CPU syscon regmap !\\n\");\n\t\tret = PTR_ERR(sdhci_sparx5->cpu_ctrl);\n\t\tgoto free_pltfm;\n\t}\n\n\tif (sdhci_sparx5->delay_clock >= 0)\n\t\tsparx5_set_delay(host, sdhci_sparx5->delay_clock);\n\n\tif (!mmc_card_is_removable(host->mmc)) {\n\t\t \n\t\tsdhci_sparx5_reset_emmc(host);\n\t\t \n\t\tsdhci_sparx5_set_emmc(host);\n\t\t \n\t\thost->mmc->caps2 |= (MMC_CAP2_NO_SDIO|MMC_CAP2_NO_SD);\n\t}\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto free_pltfm;\n\n\t \n\tif (host->flags & (SDHCI_USE_SDMA | SDHCI_USE_ADMA) &&\n\t    IS_ENABLED(CONFIG_DMA_DECLARE_COHERENT))\n\t\tsparx5_set_cacheable(host, ACP_CACHE_FORCE_ENA);\n\n\tpr_debug(\"%s: SDHC version: 0x%08x\\n\",\n\t\t mmc_hostname(host->mmc), sdhci_readl(host, MSHC2_VERSION));\n\tpr_debug(\"%s: SDHC type:    0x%08x\\n\",\n\t\t mmc_hostname(host->mmc), sdhci_readl(host, MSHC2_TYPE));\n\n\treturn ret;\n\nfree_pltfm:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic const struct of_device_id sdhci_sparx5_of_match[] = {\n\t{ .compatible = \"microchip,dw-sparx5-sdhci\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sdhci_sparx5_of_match);\n\nstatic struct platform_driver sdhci_sparx5_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-sparx5\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_sparx5_of_match,\n\t\t.pm = &sdhci_pltfm_pmops,\n\t},\n\t.probe = sdhci_sparx5_probe,\n\t.remove_new = sdhci_pltfm_remove,\n};\n\nmodule_platform_driver(sdhci_sparx5_driver);\n\nMODULE_DESCRIPTION(\"Sparx5 SDHCI OF driver\");\nMODULE_AUTHOR(\"Lars Povlsen <lars.povlsen@microchip.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}