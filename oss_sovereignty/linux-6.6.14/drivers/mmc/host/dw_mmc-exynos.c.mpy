{
  "module_name": "dw_mmc-exynos.c",
  "hash_id": "ada4ea2836f8e31e0e4246fc375d8bae637660c5cf79797e2e1851b969907254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/slab.h>\n\n#include \"dw_mmc.h\"\n#include \"dw_mmc-pltfm.h\"\n#include \"dw_mmc-exynos.h\"\n\n \nenum dw_mci_exynos_type {\n\tDW_MCI_TYPE_EXYNOS4210,\n\tDW_MCI_TYPE_EXYNOS4412,\n\tDW_MCI_TYPE_EXYNOS5250,\n\tDW_MCI_TYPE_EXYNOS5420,\n\tDW_MCI_TYPE_EXYNOS5420_SMU,\n\tDW_MCI_TYPE_EXYNOS7,\n\tDW_MCI_TYPE_EXYNOS7_SMU,\n\tDW_MCI_TYPE_ARTPEC8,\n};\n\n \nstruct dw_mci_exynos_priv_data {\n\tenum dw_mci_exynos_type\t\tctrl_type;\n\tu8\t\t\t\tciu_div;\n\tu32\t\t\t\tsdr_timing;\n\tu32\t\t\t\tddr_timing;\n\tu32\t\t\t\ths400_timing;\n\tu32\t\t\t\ttuned_sample;\n\tu32\t\t\t\tcur_speed;\n\tu32\t\t\t\tdqs_delay;\n\tu32\t\t\t\tsaved_dqs_en;\n\tu32\t\t\t\tsaved_strobe_ctrl;\n};\n\nstatic struct dw_mci_exynos_compatible {\n\tchar\t\t\t\t*compatible;\n\tenum dw_mci_exynos_type\t\tctrl_type;\n} exynos_compat[] = {\n\t{\n\t\t.compatible\t= \"samsung,exynos4210-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS4210,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos4412-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS4412,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5250-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS5250,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5420-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS5420,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos5420-dw-mshc-smu\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS5420_SMU,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos7-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS7,\n\t}, {\n\t\t.compatible\t= \"samsung,exynos7-dw-mshc-smu\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_EXYNOS7_SMU,\n\t}, {\n\t\t.compatible\t= \"axis,artpec8-dw-mshc\",\n\t\t.ctrl_type\t= DW_MCI_TYPE_ARTPEC8,\n\t},\n};\n\nstatic inline u8 dw_mci_exynos_get_ciu_div(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\n\t\treturn EXYNOS4412_FIXED_CIU_CLK_DIV;\n\telse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\n\t\treturn EXYNOS4210_FIXED_CIU_CLK_DIV;\n\telse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\treturn SDMMC_CLKSEL_GET_DIV(mci_readl(host, CLKSEL64)) + 1;\n\telse\n\t\treturn SDMMC_CLKSEL_GET_DIV(mci_readl(host, CLKSEL)) + 1;\n}\n\nstatic void dw_mci_exynos_config_smu(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\t \n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS5420_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU) {\n\t\tmci_writel(host, MPSBEGIN0, 0);\n\t\tmci_writel(host, MPSEND0, SDMMC_ENDING_SEC_NR_MAX);\n\t\tmci_writel(host, MPSCTRL0, SDMMC_MPSCTRL_SECURE_WRITE_BIT |\n\t\t\t   SDMMC_MPSCTRL_NON_SECURE_READ_BIT |\n\t\t\t   SDMMC_MPSCTRL_VALID |\n\t\t\t   SDMMC_MPSCTRL_NON_SECURE_WRITE_BIT);\n\t}\n}\n\nstatic int dw_mci_exynos_priv_init(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\tdw_mci_exynos_config_smu(host);\n\n\tif (priv->ctrl_type >= DW_MCI_TYPE_EXYNOS5420) {\n\t\tpriv->saved_strobe_ctrl = mci_readl(host, HS400_DLINE_CTRL);\n\t\tpriv->saved_dqs_en = mci_readl(host, HS400_DQS_EN);\n\t\tpriv->saved_dqs_en |= AXI_NON_BLOCKING_WR;\n\t\tmci_writel(host, HS400_DQS_EN, priv->saved_dqs_en);\n\t\tif (!priv->dqs_delay)\n\t\t\tpriv->dqs_delay =\n\t\t\t\tDQS_CTRL_GET_RD_DELAY(priv->saved_strobe_ctrl);\n\t}\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_ARTPEC8) {\n\t\t \n\t\thost->quirks |= DW_MMC_QUIRK_EXTENDED_TMOUT;\n\t}\n\n\thost->bus_hz /= (priv->ciu_div + 1);\n\n\treturn 0;\n}\n\nstatic void dw_mci_exynos_set_clksel_timing(struct dw_mci *host, u32 timing)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tu32 clksel;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tclksel = mci_readl(host, CLKSEL64);\n\telse\n\t\tclksel = mci_readl(host, CLKSEL);\n\n\tclksel = (clksel & ~SDMMC_CLKSEL_TIMING_MASK) | timing;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tmci_writel(host, CLKSEL64, clksel);\n\telse\n\t\tmci_writel(host, CLKSEL, clksel);\n\n\t \n\tif (!SDMMC_CLKSEL_GET_DRV_WD3(clksel) && host->slot)\n\t\tset_bit(DW_MMC_CARD_NO_USE_HOLD, &host->slot->flags);\n}\n\n#ifdef CONFIG_PM\nstatic int dw_mci_exynos_runtime_resume(struct device *dev)\n{\n\tstruct dw_mci *host = dev_get_drvdata(dev);\n\tint ret;\n\n\tret = dw_mci_runtime_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdw_mci_exynos_config_smu(host);\n\n\treturn ret;\n}\n#endif  \n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int dw_mci_exynos_suspend_noirq(struct device *dev)\n{\n\tpm_runtime_get_noresume(dev);\n\treturn pm_runtime_force_suspend(dev);\n}\n\n \nstatic int dw_mci_exynos_resume_noirq(struct device *dev)\n{\n\tstruct dw_mci *host = dev_get_drvdata(dev);\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tu32 clksel;\n\tint ret;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tclksel = mci_readl(host, CLKSEL64);\n\telse\n\t\tclksel = mci_readl(host, CLKSEL);\n\n\tif (clksel & SDMMC_CLKSEL_WAKEUP_INT) {\n\t\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\t\tmci_writel(host, CLKSEL64, clksel);\n\t\telse\n\t\t\tmci_writel(host, CLKSEL, clksel);\n\t}\n\n\tpm_runtime_put(dev);\n\n\treturn 0;\n}\n#endif  \n\nstatic void dw_mci_exynos_config_hs400(struct dw_mci *host, u32 timing)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tu32 dqs, strobe;\n\n\t \n\tif ((priv->ctrl_type < DW_MCI_TYPE_EXYNOS5420) ||\n\t\t(priv->ctrl_type == DW_MCI_TYPE_ARTPEC8)) {\n\t\tif (timing == MMC_TIMING_MMC_HS400)\n\t\t\tdev_warn(host->dev,\n\t\t\t\t \"cannot configure HS400, unsupported chipset\\n\");\n\t\treturn;\n\t}\n\n\tdqs = priv->saved_dqs_en;\n\tstrobe = priv->saved_strobe_ctrl;\n\n\tif (timing == MMC_TIMING_MMC_HS400) {\n\t\tdqs |= DATA_STROBE_EN;\n\t\tstrobe = DQS_CTRL_RD_DELAY(strobe, priv->dqs_delay);\n\t} else if (timing == MMC_TIMING_UHS_SDR104) {\n\t\tdqs &= 0xffffff00;\n\t} else {\n\t\tdqs &= ~DATA_STROBE_EN;\n\t}\n\n\tmci_writel(host, HS400_DQS_EN, dqs);\n\tmci_writel(host, HS400_DLINE_CTRL, strobe);\n}\n\nstatic void dw_mci_exynos_adjust_clock(struct dw_mci *host, unsigned int wanted)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tunsigned long actual;\n\tu8 div;\n\tint ret;\n\t \n\tif (!wanted || IS_ERR(host->ciu_clk))\n\t\treturn;\n\n\t \n\tif (wanted < EXYNOS_CCLKIN_MIN)\n\t\twanted = EXYNOS_CCLKIN_MIN;\n\n\tif (wanted == priv->cur_speed)\n\t\treturn;\n\n\tdiv = dw_mci_exynos_get_ciu_div(host);\n\tret = clk_set_rate(host->ciu_clk, wanted * div);\n\tif (ret)\n\t\tdev_warn(host->dev,\n\t\t\t\"failed to set clk-rate %u error: %d\\n\",\n\t\t\twanted * div, ret);\n\tactual = clk_get_rate(host->ciu_clk);\n\thost->bus_hz = actual / div;\n\tpriv->cur_speed = wanted;\n\thost->current_speed = 0;\n}\n\nstatic void dw_mci_exynos_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tunsigned int wanted = ios->clock;\n\tu32 timing = ios->timing, clksel;\n\n\tswitch (timing) {\n\tcase MMC_TIMING_MMC_HS400:\n\t\t \n\t\tclksel = SDMMC_CLKSEL_UP_SAMPLE(\n\t\t\t\tpriv->hs400_timing, priv->tuned_sample);\n\t\twanted <<= 1;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tclksel = priv->ddr_timing;\n\t\t \n\t\tif (ios->bus_width == MMC_BUS_WIDTH_8)\n\t\t\twanted <<= 1;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tclksel = (priv->sdr_timing & 0xfff8ffff) |\n\t\t\t(priv->ciu_div << 16);\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tclksel = (priv->ddr_timing & 0xfff8ffff) |\n\t\t\t(priv->ciu_div << 16);\n\t\tbreak;\n\tdefault:\n\t\tclksel = priv->sdr_timing;\n\t}\n\n\t \n\tdw_mci_exynos_set_clksel_timing(host, clksel);\n\n\t \n\tdw_mci_exynos_config_hs400(host, timing);\n\n\t \n\tdw_mci_exynos_adjust_clock(host, wanted);\n}\n\nstatic int dw_mci_exynos_parse_dt(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv;\n\tstruct device_node *np = host->dev->of_node;\n\tu32 timing[2];\n\tu32 div = 0;\n\tint idx;\n\tint ret;\n\n\tpriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(exynos_compat); idx++) {\n\t\tif (of_device_is_compatible(np, exynos_compat[idx].compatible))\n\t\t\tpriv->ctrl_type = exynos_compat[idx].ctrl_type;\n\t}\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4412)\n\t\tpriv->ciu_div = EXYNOS4412_FIXED_CIU_CLK_DIV - 1;\n\telse if (priv->ctrl_type == DW_MCI_TYPE_EXYNOS4210)\n\t\tpriv->ciu_div = EXYNOS4210_FIXED_CIU_CLK_DIV - 1;\n\telse {\n\t\tof_property_read_u32(np, \"samsung,dw-mshc-ciu-div\", &div);\n\t\tpriv->ciu_div = div;\n\t}\n\n\tret = of_property_read_u32_array(np,\n\t\t\t\"samsung,dw-mshc-sdr-timing\", timing, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->sdr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\n\n\tret = of_property_read_u32_array(np,\n\t\t\t\"samsung,dw-mshc-ddr-timing\", timing, 2);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->ddr_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1], div);\n\n\tret = of_property_read_u32_array(np,\n\t\t\t\"samsung,dw-mshc-hs400-timing\", timing, 2);\n\tif (!ret && of_property_read_u32(np,\n\t\t\t\t\"samsung,read-strobe-delay\", &priv->dqs_delay))\n\t\tdev_dbg(host->dev,\n\t\t\t\"read-strobe-delay is not found, assuming usage of default value\\n\");\n\n\tpriv->hs400_timing = SDMMC_CLKSEL_TIMING(timing[0], timing[1],\n\t\t\t\t\t\tHS400_FIXED_CIU_CLK_DIV);\n\thost->priv = priv;\n\treturn 0;\n}\n\nstatic inline u8 dw_mci_exynos_get_clksmpl(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\treturn SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL64));\n\telse\n\t\treturn SDMMC_CLKSEL_CCLK_SAMPLE(mci_readl(host, CLKSEL));\n}\n\nstatic inline void dw_mci_exynos_set_clksmpl(struct dw_mci *host, u8 sample)\n{\n\tu32 clksel;\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tclksel = mci_readl(host, CLKSEL64);\n\telse\n\t\tclksel = mci_readl(host, CLKSEL);\n\tclksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tmci_writel(host, CLKSEL64, clksel);\n\telse\n\t\tmci_writel(host, CLKSEL, clksel);\n}\n\nstatic inline u8 dw_mci_exynos_move_next_clksmpl(struct dw_mci *host)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tu32 clksel;\n\tu8 sample;\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tclksel = mci_readl(host, CLKSEL64);\n\telse\n\t\tclksel = mci_readl(host, CLKSEL);\n\n\tsample = (clksel + 1) & 0x7;\n\tclksel = SDMMC_CLKSEL_UP_SAMPLE(clksel, sample);\n\n\tif (priv->ctrl_type == DW_MCI_TYPE_EXYNOS7 ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_EXYNOS7_SMU ||\n\t\tpriv->ctrl_type == DW_MCI_TYPE_ARTPEC8)\n\t\tmci_writel(host, CLKSEL64, clksel);\n\telse\n\t\tmci_writel(host, CLKSEL, clksel);\n\n\treturn sample;\n}\n\nstatic s8 dw_mci_exynos_get_best_clksmpl(u8 candidates)\n{\n\tconst u8 iter = 8;\n\tu8 __c;\n\ts8 i, loc = -1;\n\n\tfor (i = 0; i < iter; i++) {\n\t\t__c = ror8(candidates, i);\n\t\tif ((__c & 0xc7) == 0xc7) {\n\t\t\tloc = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfor (i = 0; i < iter; i++) {\n\t\t__c = ror8(candidates, i);\n\t\tif ((__c & 0x83) == 0x83) {\n\t\t\tloc = i;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < iter; i++) {\n\t\t__c = ror8(candidates, i);\n\t\tif ((__c & 0x1) == 0x1) {\n\t\t\tloc = i;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn loc;\n}\n\nstatic int dw_mci_exynos_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\n{\n\tstruct dw_mci *host = slot->host;\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\tstruct mmc_host *mmc = slot->mmc;\n\tu8 start_smpl, smpl, candidates = 0;\n\ts8 found;\n\tint ret = 0;\n\n\tstart_smpl = dw_mci_exynos_get_clksmpl(host);\n\n\tdo {\n\t\tmci_writel(host, TMOUT, ~0);\n\t\tsmpl = dw_mci_exynos_move_next_clksmpl(host);\n\n\t\tif (!mmc_send_tuning(mmc, opcode, NULL))\n\t\t\tcandidates |= (1 << smpl);\n\n\t} while (start_smpl != smpl);\n\n\tfound = dw_mci_exynos_get_best_clksmpl(candidates);\n\tif (found >= 0) {\n\t\tdw_mci_exynos_set_clksmpl(host, found);\n\t\tpriv->tuned_sample = found;\n\t} else {\n\t\tret = -EIO;\n\t\tdev_warn(&mmc->class_dev,\n\t\t\t\"There is no candidates value about clksmpl!\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int dw_mci_exynos_prepare_hs400_tuning(struct dw_mci *host,\n\t\t\t\t\tstruct mmc_ios *ios)\n{\n\tstruct dw_mci_exynos_priv_data *priv = host->priv;\n\n\tdw_mci_exynos_set_clksel_timing(host, priv->hs400_timing);\n\tdw_mci_exynos_adjust_clock(host, (ios->clock) << 1);\n\n\treturn 0;\n}\n\nstatic void dw_mci_exynos_set_data_timeout(struct dw_mci *host,\n\t\t\t\t\t   unsigned int timeout_ns)\n{\n\tu32 clk_div, tmout;\n\tu64 tmp;\n\tunsigned int tmp2;\n\n\tclk_div = (mci_readl(host, CLKDIV) & 0xFF) * 2;\n\tif (clk_div == 0)\n\t\tclk_div = 1;\n\n\ttmp = DIV_ROUND_UP_ULL((u64)timeout_ns * host->bus_hz, NSEC_PER_SEC);\n\ttmp = DIV_ROUND_UP_ULL(tmp, clk_div);\n\n\t \n\ttmout = 0xFF;  \n\n\t \n\tif (!tmp || tmp > 0x6FFFFF2)\n\t\ttmout |= (0xFFFFFF << 8);\n\telse {\n\t\t \n\t\ttmp2 = (((unsigned int)tmp / 0xFFFFFF) + 1) & 0x7;\n\t\ttmout |= tmp2 << 8;\n\n\t\t \n\t\ttmp = tmp - ((tmp2 - 1) * 0xFFFFFF);\n\t\ttmout |= (tmp & 0xFFFFF8) << 8;\n\t}\n\n\tmci_writel(host, TMOUT, tmout);\n\tdev_dbg(host->dev, \"timeout_ns: %u => TMOUT[31:8]: %#08x\",\n\t\ttimeout_ns, tmout >> 8);\n}\n\nstatic u32 dw_mci_exynos_get_drto_clks(struct dw_mci *host)\n{\n\tu32 drto_clks;\n\n\tdrto_clks = mci_readl(host, TMOUT) >> 8;\n\n\treturn (((drto_clks & 0x7) - 1) * 0xFFFFFF) + ((drto_clks & 0xFFFFF8));\n}\n\n \nstatic unsigned long exynos_dwmmc_caps[4] = {\n\tMMC_CAP_1_8V_DDR | MMC_CAP_8_BIT_DATA,\n\t0,\n\t0,\n\t0,\n};\n\nstatic const struct dw_mci_drv_data exynos_drv_data = {\n\t.caps\t\t\t= exynos_dwmmc_caps,\n\t.num_caps\t\t= ARRAY_SIZE(exynos_dwmmc_caps),\n\t.common_caps\t\t= MMC_CAP_CMD23,\n\t.init\t\t\t= dw_mci_exynos_priv_init,\n\t.set_ios\t\t= dw_mci_exynos_set_ios,\n\t.parse_dt\t\t= dw_mci_exynos_parse_dt,\n\t.execute_tuning\t\t= dw_mci_exynos_execute_tuning,\n\t.prepare_hs400_tuning\t= dw_mci_exynos_prepare_hs400_tuning,\n};\n\nstatic const struct dw_mci_drv_data artpec_drv_data = {\n\t.common_caps\t\t= MMC_CAP_CMD23,\n\t.init\t\t\t= dw_mci_exynos_priv_init,\n\t.set_ios\t\t= dw_mci_exynos_set_ios,\n\t.parse_dt\t\t= dw_mci_exynos_parse_dt,\n\t.execute_tuning\t\t= dw_mci_exynos_execute_tuning,\n\t.set_data_timeout\t\t= dw_mci_exynos_set_data_timeout,\n\t.get_drto_clks\t\t= dw_mci_exynos_get_drto_clks,\n};\n\nstatic const struct of_device_id dw_mci_exynos_match[] = {\n\t{ .compatible = \"samsung,exynos4412-dw-mshc\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"samsung,exynos5250-dw-mshc\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"samsung,exynos5420-dw-mshc\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"samsung,exynos5420-dw-mshc-smu\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"samsung,exynos7-dw-mshc\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"samsung,exynos7-dw-mshc-smu\",\n\t\t\t.data = &exynos_drv_data, },\n\t{ .compatible = \"axis,artpec8-dw-mshc\",\n\t\t\t.data = &artpec_drv_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_mci_exynos_match);\n\nstatic int dw_mci_exynos_probe(struct platform_device *pdev)\n{\n\tconst struct dw_mci_drv_data *drv_data;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\tmatch = of_match_node(dw_mci_exynos_match, pdev->dev.of_node);\n\tdrv_data = match->data;\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = dw_mci_pltfm_register(pdev, drv_data);\n\tif (ret) {\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_set_suspended(&pdev->dev);\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_mci_exynos_remove(struct platform_device *pdev)\n{\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tdw_mci_pltfm_remove(pdev);\n}\n\nstatic const struct dev_pm_ops dw_mci_exynos_pmops = {\n\tSET_NOIRQ_SYSTEM_SLEEP_PM_OPS(dw_mci_exynos_suspend_noirq,\n\t\t\t\t      dw_mci_exynos_resume_noirq)\n\tSET_RUNTIME_PM_OPS(dw_mci_runtime_suspend,\n\t\t\t   dw_mci_exynos_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver dw_mci_exynos_pltfm_driver = {\n\t.probe\t\t= dw_mci_exynos_probe,\n\t.remove_new\t= dw_mci_exynos_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"dwmmc_exynos\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= dw_mci_exynos_match,\n\t\t.pm\t\t= &dw_mci_exynos_pmops,\n\t},\n};\n\nmodule_platform_driver(dw_mci_exynos_pltfm_driver);\n\nMODULE_DESCRIPTION(\"Samsung Specific DW-MSHC Driver Extension\");\nMODULE_AUTHOR(\"Thomas Abraham <thomas.ab@samsung.com\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dwmmc_exynos\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}