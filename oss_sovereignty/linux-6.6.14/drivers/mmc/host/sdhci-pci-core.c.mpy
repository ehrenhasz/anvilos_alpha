{
  "module_name": "sdhci-pci-core.c",
  "hash_id": "f81df28e34470ec3db01ed05670bb7394d647f35c1c8d0494c5f9b91d75720e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pci-core.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/gpio.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_qos.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n\n#ifdef CONFIG_X86\n#include <asm/iosf_mbi.h>\n#endif\n\n#include \"cqhci.h\"\n\n#include \"sdhci.h\"\n#include \"sdhci-cqhci.h\"\n#include \"sdhci-pci.h\"\n\nstatic void sdhci_pci_hw_reset(struct sdhci_host *host);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_pci_init_wakeup(struct sdhci_pci_chip *chip)\n{\n\tmmc_pm_flag_t pm_flags = 0;\n\tbool cap_cd_wake = false;\n\tint i;\n\n\tfor (i = 0; i < chip->num_slots; i++) {\n\t\tstruct sdhci_pci_slot *slot = chip->slots[i];\n\n\t\tif (slot) {\n\t\t\tpm_flags |= slot->host->mmc->pm_flags;\n\t\t\tif (slot->host->mmc->caps & MMC_CAP_CD_WAKE)\n\t\t\t\tcap_cd_wake = true;\n\t\t}\n\t}\n\n\tif ((pm_flags & MMC_PM_KEEP_POWER) && (pm_flags & MMC_PM_WAKE_SDIO_IRQ))\n\t\treturn device_wakeup_enable(&chip->pdev->dev);\n\telse if (!cap_cd_wake)\n\t\treturn device_wakeup_disable(&chip->pdev->dev);\n\n\treturn 0;\n}\n\nstatic int sdhci_pci_suspend_host(struct sdhci_pci_chip *chip)\n{\n\tint i, ret;\n\n\tsdhci_pci_init_wakeup(chip);\n\n\tfor (i = 0; i < chip->num_slots; i++) {\n\t\tstruct sdhci_pci_slot *slot = chip->slots[i];\n\t\tstruct sdhci_host *host;\n\n\t\tif (!slot)\n\t\t\tcontinue;\n\n\t\thost = slot->host;\n\n\t\tif (chip->pm_retune && host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\t\tmmc_retune_needed(host->mmc);\n\n\t\tret = sdhci_suspend_host(host);\n\t\tif (ret)\n\t\t\tgoto err_pci_suspend;\n\n\t\tif (device_may_wakeup(&chip->pdev->dev))\n\t\t\tmmc_gpio_set_cd_wake(host->mmc, true);\n\t}\n\n\treturn 0;\n\nerr_pci_suspend:\n\twhile (--i >= 0)\n\t\tsdhci_resume_host(chip->slots[i]->host);\n\treturn ret;\n}\n\nint sdhci_pci_resume_host(struct sdhci_pci_chip *chip)\n{\n\tstruct sdhci_pci_slot *slot;\n\tint i, ret;\n\n\tfor (i = 0; i < chip->num_slots; i++) {\n\t\tslot = chip->slots[i];\n\t\tif (!slot)\n\t\t\tcontinue;\n\n\t\tret = sdhci_resume_host(slot->host);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tmmc_gpio_set_cd_wake(slot->host->mmc, false);\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_cqhci_suspend(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\n\tret = cqhci_suspend(chip->slots[0]->host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdhci_pci_suspend_host(chip);\n}\n\nstatic int sdhci_cqhci_resume(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\n\tret = sdhci_pci_resume_host(chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cqhci_resume(chip->slots[0]->host->mmc);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sdhci_pci_runtime_suspend_host(struct sdhci_pci_chip *chip)\n{\n\tstruct sdhci_pci_slot *slot;\n\tstruct sdhci_host *host;\n\tint i, ret;\n\n\tfor (i = 0; i < chip->num_slots; i++) {\n\t\tslot = chip->slots[i];\n\t\tif (!slot)\n\t\t\tcontinue;\n\n\t\thost = slot->host;\n\n\t\tret = sdhci_runtime_suspend_host(host);\n\t\tif (ret)\n\t\t\tgoto err_pci_runtime_suspend;\n\n\t\tif (chip->rpm_retune &&\n\t\t    host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\t\tmmc_retune_needed(host->mmc);\n\t}\n\n\treturn 0;\n\nerr_pci_runtime_suspend:\n\twhile (--i >= 0)\n\t\tsdhci_runtime_resume_host(chip->slots[i]->host, 0);\n\treturn ret;\n}\n\nstatic int sdhci_pci_runtime_resume_host(struct sdhci_pci_chip *chip)\n{\n\tstruct sdhci_pci_slot *slot;\n\tint i, ret;\n\n\tfor (i = 0; i < chip->num_slots; i++) {\n\t\tslot = chip->slots[i];\n\t\tif (!slot)\n\t\t\tcontinue;\n\n\t\tret = sdhci_runtime_resume_host(slot->host, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_cqhci_runtime_suspend(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\n\tret = cqhci_suspend(chip->slots[0]->host->mmc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn sdhci_pci_runtime_suspend_host(chip);\n}\n\nstatic int sdhci_cqhci_runtime_resume(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\n\tret = sdhci_pci_runtime_resume_host(chip);\n\tif (ret)\n\t\treturn ret;\n\n\treturn cqhci_resume(chip->slots[0]->host->mmc);\n}\n#endif\n\nstatic u32 sdhci_cqhci_irq(struct sdhci_host *host, u32 intmask)\n{\n\tint cmd_error = 0;\n\tint data_error = 0;\n\n\tif (!sdhci_cqe_irq(host, intmask, &cmd_error, &data_error))\n\t\treturn intmask;\n\n\tcqhci_irq(host->mmc, intmask, cmd_error, data_error);\n\n\treturn 0;\n}\n\nstatic void sdhci_pci_dumpregs(struct mmc_host *mmc)\n{\n\tsdhci_dumpregs(mmc_priv(mmc));\n}\n\n \n\nstatic int ricoh_probe(struct sdhci_pci_chip *chip)\n{\n\tif (chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SAMSUNG ||\n\t    chip->pdev->subsystem_vendor == PCI_VENDOR_ID_SONY)\n\t\tchip->quirks |= SDHCI_QUIRK_NO_CARD_NO_RESET;\n\treturn 0;\n}\n\nstatic int ricoh_mmc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tu32 caps =\n\t\tFIELD_PREP(SDHCI_TIMEOUT_CLK_MASK, 0x21) |\n\t\tFIELD_PREP(SDHCI_CLOCK_BASE_MASK, 0x21) |\n\t\tSDHCI_TIMEOUT_CLK_UNIT |\n\t\tSDHCI_CAN_VDD_330 |\n\t\tSDHCI_CAN_DO_HISPD |\n\t\tSDHCI_CAN_DO_SDMA;\n\tu32 caps1 = 0;\n\n\t__sdhci_read_caps(slot->host, NULL, &caps, &caps1);\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ricoh_mmc_resume(struct sdhci_pci_chip *chip)\n{\n\t \n\t \n\tmsleep(500);\n\treturn sdhci_pci_resume_host(chip);\n}\n#endif\n\nstatic const struct sdhci_pci_fixes sdhci_ricoh = {\n\t.probe\t\t= ricoh_probe,\n\t.quirks\t\t= SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\t\t  SDHCI_QUIRK_FORCE_DMA |\n\t\t\t  SDHCI_QUIRK_CLOCK_BEFORE_RESET,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_ricoh_mmc = {\n\t.probe_slot\t= ricoh_mmc_probe_slot,\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= ricoh_mmc_resume,\n#endif\n\t.quirks\t\t= SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\t\t  SDHCI_QUIRK_CLOCK_BEFORE_RESET |\n\t\t\t  SDHCI_QUIRK_NO_CARD_NO_RESET,\n};\n\nstatic void ene_714_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tsdhci_set_ios(mmc, ios);\n\n\t \n\tif (!(host->flags & SDHCI_DEVICE_DEAD))\n\t\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n}\n\nstatic int ene_714_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc_host_ops.set_ios = ene_714_set_ios;\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_ene_712 = {\n\t.quirks\t\t= SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t\t  SDHCI_QUIRK_BROKEN_DMA,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_ene_714 = {\n\t.quirks\t\t= SDHCI_QUIRK_SINGLE_POWER_WRITE |\n\t\t\t  SDHCI_QUIRK_BROKEN_DMA,\n\t.probe_slot\t= ene_714_probe_slot,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_cafe = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER |\n\t\t\t  SDHCI_QUIRK_NO_BUSY_IRQ |\n\t\t\t  SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t\t  SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_qrk = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_HISPD_BIT,\n};\n\nstatic int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\treturn 0;\n}\n\n \nstatic int mrst_hc_probe(struct sdhci_pci_chip *chip)\n{\n\t \n\tchip->num_slots = 1;\n\treturn 0;\n}\n\nstatic int pch_hc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\treturn 0;\n}\n\nstatic int mfd_emmc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE;\n\tslot->host->mmc->caps2 |= MMC_CAP2_BOOTPART_NOACC;\n\treturn 0;\n}\n\nstatic int mfd_sdio_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE;\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mrst_hc0 = {\n\t.quirks\t\t= SDHCI_QUIRK_BROKEN_ADMA | SDHCI_QUIRK_NO_HISPD_BIT,\n\t.probe_slot\t= mrst_hc_probe_slot,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mrst_hc1_hc2 = {\n\t.quirks\t\t= SDHCI_QUIRK_BROKEN_ADMA | SDHCI_QUIRK_NO_HISPD_BIT,\n\t.probe\t\t= mrst_hc_probe,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mfd_sd = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.allow_runtime_pm = true,\n\t.own_cd_for_runtime_pm = true,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mfd_sdio = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.quirks2\t= SDHCI_QUIRK2_HOST_OFF_CARD_ON,\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= mfd_sdio_probe_slot,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mfd_emmc = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= mfd_emmc_probe_slot,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_pch_sdio = {\n\t.quirks\t\t= SDHCI_QUIRK_BROKEN_ADMA,\n\t.probe_slot\t= pch_hc_probe_slot,\n};\n\n#ifdef CONFIG_X86\n\n#define BYT_IOSF_SCCEP\t\t\t0x63\n#define BYT_IOSF_OCP_NETCTRL0\t\t0x1078\n#define BYT_IOSF_OCP_TIMEOUT_BASE\tGENMASK(10, 8)\n\nstatic void byt_ocp_setting(struct pci_dev *pdev)\n{\n\tu32 val = 0;\n\n\tif (pdev->device != PCI_DEVICE_ID_INTEL_BYT_EMMC &&\n\t    pdev->device != PCI_DEVICE_ID_INTEL_BYT_SDIO &&\n\t    pdev->device != PCI_DEVICE_ID_INTEL_BYT_SD &&\n\t    pdev->device != PCI_DEVICE_ID_INTEL_BYT_EMMC2)\n\t\treturn;\n\n\tif (iosf_mbi_read(BYT_IOSF_SCCEP, MBI_CR_READ, BYT_IOSF_OCP_NETCTRL0,\n\t\t\t  &val)) {\n\t\tdev_err(&pdev->dev, \"%s read error\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!(val & BYT_IOSF_OCP_TIMEOUT_BASE))\n\t\treturn;\n\n\tval &= ~BYT_IOSF_OCP_TIMEOUT_BASE;\n\n\tif (iosf_mbi_write(BYT_IOSF_SCCEP, MBI_CR_WRITE, BYT_IOSF_OCP_NETCTRL0,\n\t\t\t   val)) {\n\t\tdev_err(&pdev->dev, \"%s write error\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdev_dbg(&pdev->dev, \"%s completed\\n\", __func__);\n}\n\n#else\n\nstatic inline void byt_ocp_setting(struct pci_dev *pdev)\n{\n}\n\n#endif\n\nenum {\n\tINTEL_DSM_FNS\t\t=  0,\n\tINTEL_DSM_V18_SWITCH\t=  3,\n\tINTEL_DSM_V33_SWITCH\t=  4,\n\tINTEL_DSM_DRV_STRENGTH\t=  9,\n\tINTEL_DSM_D3_RETUNE\t= 10,\n};\n\nstruct intel_host {\n\tu32\tdsm_fns;\n\tint\tdrv_strength;\n\tbool\td3_retune;\n\tbool\trpm_retune_ok;\n\tbool\tneeds_pwr_off;\n\tu32\tglk_rx_ctrl1;\n\tu32\tglk_tun_val;\n\tu32\tactive_ltr;\n\tu32\tidle_ltr;\n};\n\nstatic const guid_t intel_dsm_guid =\n\tGUID_INIT(0xF6C13EA5, 0x65CD, 0x461F,\n\t\t  0xAB, 0x7A, 0x29, 0xF7, 0xE8, 0xD5, 0xBD, 0x61);\n\nstatic int __intel_dsm(struct intel_host *intel_host, struct device *dev,\n\t\t       unsigned int fn, u32 *result)\n{\n\tunion acpi_object *obj;\n\tint err = 0;\n\tsize_t len;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(dev), &intel_dsm_guid, 0, fn, NULL);\n\tif (!obj)\n\t\treturn -EOPNOTSUPP;\n\n\tif (obj->type != ACPI_TYPE_BUFFER || obj->buffer.length < 1) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tlen = min_t(size_t, obj->buffer.length, 4);\n\n\t*result = 0;\n\tmemcpy(result, obj->buffer.pointer, len);\nout:\n\tACPI_FREE(obj);\n\n\treturn err;\n}\n\nstatic int intel_dsm(struct intel_host *intel_host, struct device *dev,\n\t\t     unsigned int fn, u32 *result)\n{\n\tif (fn > 31 || !(intel_host->dsm_fns & (1 << fn)))\n\t\treturn -EOPNOTSUPP;\n\n\treturn __intel_dsm(intel_host, dev, fn, result);\n}\n\nstatic void intel_dsm_init(struct intel_host *intel_host, struct device *dev,\n\t\t\t   struct mmc_host *mmc)\n{\n\tint err;\n\tu32 val;\n\n\tintel_host->d3_retune = true;\n\n\terr = __intel_dsm(intel_host, dev, INTEL_DSM_FNS, &intel_host->dsm_fns);\n\tif (err) {\n\t\tpr_debug(\"%s: DSM not supported, error %d\\n\",\n\t\t\t mmc_hostname(mmc), err);\n\t\treturn;\n\t}\n\n\tpr_debug(\"%s: DSM function mask %#x\\n\",\n\t\t mmc_hostname(mmc), intel_host->dsm_fns);\n\n\terr = intel_dsm(intel_host, dev, INTEL_DSM_DRV_STRENGTH, &val);\n\tintel_host->drv_strength = err ? 0 : val;\n\n\terr = intel_dsm(intel_host, dev, INTEL_DSM_D3_RETUNE, &val);\n\tintel_host->d3_retune = err ? true : !!val;\n}\n\nstatic void sdhci_pci_int_hw_reset(struct sdhci_host *host)\n{\n\tu8 reg;\n\n\treg = sdhci_readb(host, SDHCI_POWER_CONTROL);\n\treg |= 0x10;\n\tsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\n\t \n\tudelay(9);\n\treg &= ~0x10;\n\tsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\n\t \n\tusleep_range(300, 1000);\n}\n\nstatic int intel_select_drive_strength(struct mmc_card *card,\n\t\t\t\t       unsigned int max_dtr, int host_drv,\n\t\t\t\t       int card_drv, int *drv_type)\n{\n\tstruct sdhci_host *host = mmc_priv(card->host);\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\n\tif (!(mmc_driver_type_mask(intel_host->drv_strength) & card_drv))\n\t\treturn 0;\n\n\treturn intel_host->drv_strength;\n}\n\nstatic int bxt_get_cd(struct mmc_host *mmc)\n{\n\tint gpio_cd = mmc_gpio_get_cd(mmc);\n\n\tif (!gpio_cd)\n\t\treturn 0;\n\n\treturn sdhci_get_cd_nogpio(mmc);\n}\n\nstatic int mrfld_get_cd(struct mmc_host *mmc)\n{\n\treturn sdhci_get_cd_nogpio(mmc);\n}\n\n#define SDHCI_INTEL_PWR_TIMEOUT_CNT\t20\n#define SDHCI_INTEL_PWR_TIMEOUT_UDELAY\t100\n\nstatic void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,\n\t\t\t\t  unsigned short vdd)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tint cntr;\n\tu8 reg;\n\n\t \n\tif (intel_host->needs_pwr_off) {\n\t\tintel_host->needs_pwr_off = false;\n\t\tif (mode != MMC_POWER_OFF) {\n\t\t\tsdhci_writeb(host, 0, SDHCI_POWER_CONTROL);\n\t\t\tusleep_range(10000, 12500);\n\t\t}\n\t}\n\n\tsdhci_set_power(host, mode, vdd);\n\n\tif (mode == MMC_POWER_OFF)\n\t\treturn;\n\n\t \n\tfor (cntr = 0; cntr < SDHCI_INTEL_PWR_TIMEOUT_CNT; cntr++) {\n\t\treg = sdhci_readb(host, SDHCI_POWER_CONTROL);\n\t\tif (reg & SDHCI_POWER_ON)\n\t\t\tbreak;\n\t\tudelay(SDHCI_INTEL_PWR_TIMEOUT_UDELAY);\n\t\treg |= SDHCI_POWER_ON;\n\t\tsdhci_writeb(host, reg, SDHCI_POWER_CONTROL);\n\t}\n}\n\nstatic void sdhci_intel_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t  unsigned int timing)\n{\n\t \n\tif (timing == MMC_TIMING_MMC_HS || timing == MMC_TIMING_SD_HS)\n\t\ttiming = MMC_TIMING_UHS_SDR25;\n\tsdhci_set_uhs_signaling(host, timing);\n}\n\n#define INTEL_HS400_ES_REG 0x78\n#define INTEL_HS400_ES_BIT BIT(0)\n\nstatic void intel_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\tstruct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tu32 val;\n\n\tval = sdhci_readl(host, INTEL_HS400_ES_REG);\n\tif (ios->enhanced_strobe)\n\t\tval |= INTEL_HS400_ES_BIT;\n\telse\n\t\tval &= ~INTEL_HS400_ES_BIT;\n\tsdhci_writel(host, val, INTEL_HS400_ES_REG);\n}\n\nstatic int intel_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t     struct mmc_ios *ios)\n{\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tunsigned int fn;\n\tu32 result = 0;\n\tint err;\n\n\terr = sdhci_start_signal_voltage_switch(mmc, ios);\n\tif (err)\n\t\treturn err;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tfn = INTEL_DSM_V33_SWITCH;\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tfn = INTEL_DSM_V18_SWITCH;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = intel_dsm(intel_host, dev, fn, &result);\n\tpr_debug(\"%s: %s DSM fn %u error %d result %u\\n\",\n\t\t mmc_hostname(mmc), __func__, fn, err, result);\n\n\treturn 0;\n}\n\nstatic const struct sdhci_ops sdhci_intel_byt_ops = {\n\t.set_clock\t\t= sdhci_set_clock,\n\t.set_power\t\t= sdhci_intel_set_power,\n\t.enable_dma\t\t= sdhci_pci_enable_dma,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t= sdhci_reset,\n\t.set_uhs_signaling\t= sdhci_intel_set_uhs_signaling,\n\t.hw_reset\t\t= sdhci_pci_hw_reset,\n};\n\nstatic const struct sdhci_ops sdhci_intel_glk_ops = {\n\t.set_clock\t\t= sdhci_set_clock,\n\t.set_power\t\t= sdhci_intel_set_power,\n\t.enable_dma\t\t= sdhci_pci_enable_dma,\n\t.set_bus_width\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t= sdhci_and_cqhci_reset,\n\t.set_uhs_signaling\t= sdhci_intel_set_uhs_signaling,\n\t.hw_reset\t\t= sdhci_pci_hw_reset,\n\t.irq\t\t\t= sdhci_cqhci_irq,\n};\n\nstatic void byt_read_dsm(struct sdhci_pci_slot *slot)\n{\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tstruct device *dev = &slot->chip->pdev->dev;\n\tstruct mmc_host *mmc = slot->host->mmc;\n\n\tintel_dsm_init(intel_host, dev, mmc);\n\tslot->chip->rpm_retune = intel_host->d3_retune;\n}\n\nstatic int intel_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tint err = sdhci_execute_tuning(mmc, opcode);\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tsdhci_reset(host, SDHCI_RESET_DATA);\n\n\treturn 0;\n}\n\n#define INTEL_ACTIVELTR\t\t0x804\n#define INTEL_IDLELTR\t\t0x808\n\n#define INTEL_LTR_REQ\t\tBIT(15)\n#define INTEL_LTR_SCALE_MASK\tGENMASK(11, 10)\n#define INTEL_LTR_SCALE_1US\t(2 << 10)\n#define INTEL_LTR_SCALE_32US\t(3 << 10)\n#define INTEL_LTR_VALUE_MASK\tGENMASK(9, 0)\n\nstatic void intel_cache_ltr(struct sdhci_pci_slot *slot)\n{\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tstruct sdhci_host *host = slot->host;\n\n\tintel_host->active_ltr = readl(host->ioaddr + INTEL_ACTIVELTR);\n\tintel_host->idle_ltr = readl(host->ioaddr + INTEL_IDLELTR);\n}\n\nstatic void intel_ltr_set(struct device *dev, s32 val)\n{\n\tstruct sdhci_pci_chip *chip = dev_get_drvdata(dev);\n\tstruct sdhci_pci_slot *slot = chip->slots[0];\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tstruct sdhci_host *host = slot->host;\n\tu32 ltr;\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\tltr = readl(host->ioaddr + INTEL_ACTIVELTR);\n\n\tif (val == PM_QOS_LATENCY_ANY || val < 0) {\n\t\tltr &= ~INTEL_LTR_REQ;\n\t} else {\n\t\tltr |= INTEL_LTR_REQ;\n\t\tltr &= ~INTEL_LTR_SCALE_MASK;\n\t\tltr &= ~INTEL_LTR_VALUE_MASK;\n\n\t\tif (val > INTEL_LTR_VALUE_MASK) {\n\t\t\tval >>= 5;\n\t\t\tif (val > INTEL_LTR_VALUE_MASK)\n\t\t\t\tval = INTEL_LTR_VALUE_MASK;\n\t\t\tltr |= INTEL_LTR_SCALE_32US | val;\n\t\t} else {\n\t\t\tltr |= INTEL_LTR_SCALE_1US | val;\n\t\t}\n\t}\n\n\tif (ltr == intel_host->active_ltr)\n\t\tgoto out;\n\n\twritel(ltr, host->ioaddr + INTEL_ACTIVELTR);\n\twritel(ltr, host->ioaddr + INTEL_IDLELTR);\n\n\t \n\tintel_cache_ltr(slot);\nout:\n\tpm_runtime_put_autosuspend(dev);\n}\n\nstatic bool intel_use_ltr(struct sdhci_pci_chip *chip)\n{\n\tswitch (chip->pdev->device) {\n\tcase PCI_DEVICE_ID_INTEL_BYT_EMMC:\n\tcase PCI_DEVICE_ID_INTEL_BYT_EMMC2:\n\tcase PCI_DEVICE_ID_INTEL_BYT_SDIO:\n\tcase PCI_DEVICE_ID_INTEL_BYT_SD:\n\tcase PCI_DEVICE_ID_INTEL_BSW_EMMC:\n\tcase PCI_DEVICE_ID_INTEL_BSW_SDIO:\n\tcase PCI_DEVICE_ID_INTEL_BSW_SD:\n\t\treturn false;\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic void intel_ltr_expose(struct sdhci_pci_chip *chip)\n{\n\tstruct device *dev = &chip->pdev->dev;\n\n\tif (!intel_use_ltr(chip))\n\t\treturn;\n\n\tdev->power.set_latency_tolerance = intel_ltr_set;\n\tdev_pm_qos_expose_latency_tolerance(dev);\n}\n\nstatic void intel_ltr_hide(struct sdhci_pci_chip *chip)\n{\n\tstruct device *dev = &chip->pdev->dev;\n\n\tif (!intel_use_ltr(chip))\n\t\treturn;\n\n\tdev_pm_qos_hide_latency_tolerance(dev);\n\tdev->power.set_latency_tolerance = NULL;\n}\n\nstatic void byt_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tstruct mmc_host_ops *ops = &slot->host->mmc_host_ops;\n\tstruct device *dev = &slot->chip->pdev->dev;\n\tstruct mmc_host *mmc = slot->host->mmc;\n\n\tbyt_read_dsm(slot);\n\n\tbyt_ocp_setting(slot->chip->pdev);\n\n\tops->execute_tuning = intel_execute_tuning;\n\tops->start_signal_voltage_switch = intel_start_signal_voltage_switch;\n\n\tdevice_property_read_u32(dev, \"max-frequency\", &mmc->f_max);\n\n\tif (!mmc->slotno) {\n\t\tslot->chip->slots[mmc->slotno] = slot;\n\t\tintel_ltr_expose(slot->chip);\n\t}\n}\n\nstatic void byt_add_debugfs(struct sdhci_pci_slot *slot)\n{\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tstruct mmc_host *mmc = slot->host->mmc;\n\tstruct dentry *dir = mmc->debugfs_root;\n\n\tif (!intel_use_ltr(slot->chip))\n\t\treturn;\n\n\tdebugfs_create_x32(\"active_ltr\", 0444, dir, &intel_host->active_ltr);\n\tdebugfs_create_x32(\"idle_ltr\", 0444, dir, &intel_host->idle_ltr);\n\n\tintel_cache_ltr(slot);\n}\n\nstatic int byt_add_host(struct sdhci_pci_slot *slot)\n{\n\tint ret = sdhci_add_host(slot->host);\n\n\tif (!ret)\n\t\tbyt_add_debugfs(slot);\n\treturn ret;\n}\n\nstatic void byt_remove_slot(struct sdhci_pci_slot *slot, int dead)\n{\n\tstruct mmc_host *mmc = slot->host->mmc;\n\n\tif (!mmc->slotno)\n\t\tintel_ltr_hide(slot->chip);\n}\n\nstatic int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tbyt_probe_slot(slot);\n\tslot->host->mmc->caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |\n\t\t\t\t MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |\n\t\t\t\t MMC_CAP_CMD_DURING_TFR |\n\t\t\t\t MMC_CAP_WAIT_WHILE_BUSY;\n\tslot->hw_reset = sdhci_pci_int_hw_reset;\n\tif (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BSW_EMMC)\n\t\tslot->host->timeout_clk = 1000;  \n\tslot->host->mmc_host_ops.select_drive_strength =\n\t\t\t\t\t\tintel_select_drive_strength;\n\treturn 0;\n}\n\nstatic bool glk_broken_cqhci(struct sdhci_pci_slot *slot)\n{\n\treturn slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_EMMC &&\n\t       (dmi_match(DMI_BIOS_VENDOR, \"LENOVO\") ||\n\t\tdmi_match(DMI_SYS_VENDOR, \"IRBIS\"));\n}\n\nstatic bool jsl_broken_hs400es(struct sdhci_pci_slot *slot)\n{\n\treturn slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_JSL_EMMC &&\n\t\t\tdmi_match(DMI_BIOS_VENDOR, \"ASUSTeK COMPUTER INC.\");\n}\n\nstatic int glk_emmc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tint ret = byt_emmc_probe_slot(slot);\n\n\tif (!glk_broken_cqhci(slot))\n\t\tslot->host->mmc->caps2 |= MMC_CAP2_CQE;\n\n\tif (slot->chip->pdev->device != PCI_DEVICE_ID_INTEL_GLK_EMMC) {\n\t\tif (!jsl_broken_hs400es(slot)) {\n\t\t\tslot->host->mmc->caps2 |= MMC_CAP2_HS400_ES;\n\t\t\tslot->host->mmc_host_ops.hs400_enhanced_strobe =\n\t\t\t\t\t\t\tintel_hs400_enhanced_strobe;\n\t\t}\n\t\tslot->host->mmc->caps2 |= MMC_CAP2_CQE_DCMD;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct cqhci_host_ops glk_cqhci_ops = {\n\t.enable\t\t= sdhci_cqe_enable,\n\t.disable\t= sdhci_cqe_disable,\n\t.dumpregs\t= sdhci_pci_dumpregs,\n};\n\nstatic int glk_emmc_add_host(struct sdhci_pci_slot *slot)\n{\n\tstruct device *dev = &slot->chip->pdev->dev;\n\tstruct sdhci_host *host = slot->host;\n\tstruct cqhci_host *cq_host;\n\tbool dma64;\n\tint ret;\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tcq_host = devm_kzalloc(dev, sizeof(*cq_host), GFP_KERNEL);\n\tif (!cq_host) {\n\t\tret = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\tcq_host->mmio = host->ioaddr + 0x200;\n\tcq_host->quirks |= CQHCI_QUIRK_SHORT_TXFR_DESC_SZ;\n\tcq_host->ops = &glk_cqhci_ops;\n\n\tdma64 = host->flags & SDHCI_USE_64_BIT_DMA;\n\tif (dma64)\n\t\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\n\tret = cqhci_init(cq_host, host->mmc, dma64);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbyt_add_debugfs(slot);\n\n\treturn 0;\n\ncleanup:\n\tsdhci_cleanup_host(host);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM\n#define GLK_RX_CTRL1\t0x834\n#define GLK_TUN_VAL\t0x840\n#define GLK_PATH_PLL\tGENMASK(13, 8)\n#define GLK_DLY\t\tGENMASK(6, 0)\n \nstatic void glk_rpm_retune_wa(struct sdhci_pci_chip *chip, bool susp)\n{\n\tstruct sdhci_pci_slot *slot = chip->slots[0];\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tstruct sdhci_host *host = slot->host;\n\tu32 glk_rx_ctrl1;\n\tu32 glk_tun_val;\n\tu32 dly;\n\n\tif (intel_host->rpm_retune_ok || !mmc_can_retune(host->mmc))\n\t\treturn;\n\n\tglk_rx_ctrl1 = sdhci_readl(host, GLK_RX_CTRL1);\n\tglk_tun_val = sdhci_readl(host, GLK_TUN_VAL);\n\n\tif (susp) {\n\t\tintel_host->glk_rx_ctrl1 = glk_rx_ctrl1;\n\t\tintel_host->glk_tun_val = glk_tun_val;\n\t\treturn;\n\t}\n\n\tif (!intel_host->glk_tun_val)\n\t\treturn;\n\n\tif (glk_rx_ctrl1 != intel_host->glk_rx_ctrl1) {\n\t\tintel_host->rpm_retune_ok = true;\n\t\treturn;\n\t}\n\n\tdly = FIELD_PREP(GLK_DLY, FIELD_GET(GLK_PATH_PLL, glk_rx_ctrl1) +\n\t\t\t\t  (intel_host->glk_tun_val << 1));\n\tif (dly == FIELD_GET(GLK_DLY, glk_rx_ctrl1))\n\t\treturn;\n\n\tglk_rx_ctrl1 = (glk_rx_ctrl1 & ~GLK_DLY) | dly;\n\tsdhci_writel(host, glk_rx_ctrl1, GLK_RX_CTRL1);\n\n\tintel_host->rpm_retune_ok = true;\n\tchip->rpm_retune = true;\n\tmmc_retune_needed(host->mmc);\n\tpr_info(\"%s: Requiring re-tune after rpm resume\", mmc_hostname(host->mmc));\n}\n\nstatic void glk_rpm_retune_chk(struct sdhci_pci_chip *chip, bool susp)\n{\n\tif (chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_EMMC &&\n\t    !chip->rpm_retune)\n\t\tglk_rpm_retune_wa(chip, susp);\n}\n\nstatic int glk_runtime_suspend(struct sdhci_pci_chip *chip)\n{\n\tglk_rpm_retune_chk(chip, true);\n\n\treturn sdhci_cqhci_runtime_suspend(chip);\n}\n\nstatic int glk_runtime_resume(struct sdhci_pci_chip *chip)\n{\n\tglk_rpm_retune_chk(chip, false);\n\n\treturn sdhci_cqhci_runtime_resume(chip);\n}\n#endif\n\n#ifdef CONFIG_ACPI\nstatic int ni_set_max_freq(struct sdhci_pci_slot *slot)\n{\n\tacpi_status status;\n\tunsigned long long max_freq;\n\n\tstatus = acpi_evaluate_integer(ACPI_HANDLE(&slot->chip->pdev->dev),\n\t\t\t\t       \"MXFQ\", NULL, &max_freq);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&slot->chip->pdev->dev,\n\t\t\t\"MXFQ not found in acpi table\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tslot->host->mmc->f_max = max_freq * 1000000;\n\n\treturn 0;\n}\n#else\nstatic inline int ni_set_max_freq(struct sdhci_pci_slot *slot)\n{\n\treturn 0;\n}\n#endif\n\nstatic int ni_byt_sdio_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tint err;\n\n\tbyt_probe_slot(slot);\n\n\terr = ni_set_max_freq(slot);\n\tif (err)\n\t\treturn err;\n\n\tslot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |\n\t\t\t\t MMC_CAP_WAIT_WHILE_BUSY;\n\treturn 0;\n}\n\nstatic int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tbyt_probe_slot(slot);\n\tslot->host->mmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |\n\t\t\t\t MMC_CAP_WAIT_WHILE_BUSY;\n\treturn 0;\n}\n\nstatic void byt_needs_pwr_off(struct sdhci_pci_slot *slot)\n{\n\tstruct intel_host *intel_host = sdhci_pci_priv(slot);\n\tu8 reg = sdhci_readb(slot->host, SDHCI_POWER_CONTROL);\n\n\tintel_host->needs_pwr_off = reg  & SDHCI_POWER_ON;\n}\n\nstatic int byt_sd_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tbyt_probe_slot(slot);\n\tslot->host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY |\n\t\t\t\t MMC_CAP_AGGRESSIVE_PM | MMC_CAP_CD_WAKE;\n\tslot->cd_idx = 0;\n\tslot->cd_override_level = true;\n\tif (slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXT_SD ||\n\t    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_BXTM_SD ||\n\t    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_APL_SD ||\n\t    slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_SD)\n\t\tslot->host->mmc_host_ops.get_cd = bxt_get_cd;\n\n\tif (slot->chip->pdev->subsystem_vendor == PCI_VENDOR_ID_NI &&\n\t    slot->chip->pdev->subsystem_device == PCI_SUBDEVICE_ID_NI_78E3)\n\t\tslot->host->mmc->caps2 |= MMC_CAP2_AVOID_3_3V;\n\n\tbyt_needs_pwr_off(slot);\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int byt_resume(struct sdhci_pci_chip *chip)\n{\n\tbyt_ocp_setting(chip->pdev);\n\n\treturn sdhci_pci_resume_host(chip);\n}\n\n#endif\n\n#ifdef CONFIG_PM\n\nstatic int byt_runtime_resume(struct sdhci_pci_chip *chip)\n{\n\tbyt_ocp_setting(chip->pdev);\n\n\treturn sdhci_pci_runtime_resume_host(chip);\n}\n\n#endif\n\nstatic const struct sdhci_pci_fixes sdhci_intel_byt_emmc = {\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= byt_resume,\n#endif\n#ifdef CONFIG_PM\n\t.runtime_resume\t= byt_runtime_resume,\n#endif\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= byt_emmc_probe_slot,\n\t.add_host\t= byt_add_host,\n\t.remove_slot\t= byt_remove_slot,\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t\t  SDHCI_QUIRK_NO_LED,\n\t.quirks2\t= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\t  SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |\n\t\t\t  SDHCI_QUIRK2_STOP_WITH_TC,\n\t.ops\t\t= &sdhci_intel_byt_ops,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_glk_emmc = {\n\t.allow_runtime_pm\t= true,\n\t.probe_slot\t\t= glk_emmc_probe_slot,\n\t.add_host\t\t= glk_emmc_add_host,\n\t.remove_slot\t\t= byt_remove_slot,\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t\t= sdhci_cqhci_suspend,\n\t.resume\t\t\t= sdhci_cqhci_resume,\n#endif\n#ifdef CONFIG_PM\n\t.runtime_suspend\t= glk_runtime_suspend,\n\t.runtime_resume\t\t= glk_runtime_resume,\n#endif\n\t.quirks\t\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t\t\t  SDHCI_QUIRK_NO_LED,\n\t.quirks2\t\t= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\t\t  SDHCI_QUIRK2_CAPS_BIT63_FOR_HS400 |\n\t\t\t\t  SDHCI_QUIRK2_STOP_WITH_TC,\n\t.ops\t\t\t= &sdhci_intel_glk_ops,\n\t.priv_size\t\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_pci_fixes sdhci_ni_byt_sdio = {\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= byt_resume,\n#endif\n#ifdef CONFIG_PM\n\t.runtime_resume\t= byt_runtime_resume,\n#endif\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t\t  SDHCI_QUIRK_NO_LED,\n\t.quirks2\t= SDHCI_QUIRK2_HOST_OFF_CARD_ON |\n\t\t\t  SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= ni_byt_sdio_probe_slot,\n\t.add_host\t= byt_add_host,\n\t.remove_slot\t= byt_remove_slot,\n\t.ops\t\t= &sdhci_intel_byt_ops,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_byt_sdio = {\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= byt_resume,\n#endif\n#ifdef CONFIG_PM\n\t.runtime_resume\t= byt_runtime_resume,\n#endif\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t\t  SDHCI_QUIRK_NO_LED,\n\t.quirks2\t= SDHCI_QUIRK2_HOST_OFF_CARD_ON |\n\t\t\tSDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= byt_sdio_probe_slot,\n\t.add_host\t= byt_add_host,\n\t.remove_slot\t= byt_remove_slot,\n\t.ops\t\t= &sdhci_intel_byt_ops,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\nstatic const struct sdhci_pci_fixes sdhci_intel_byt_sd = {\n#ifdef CONFIG_PM_SLEEP\n\t.resume\t\t= byt_resume,\n#endif\n#ifdef CONFIG_PM\n\t.runtime_resume\t= byt_runtime_resume,\n#endif\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC |\n\t\t\t  SDHCI_QUIRK_NO_LED,\n\t.quirks2\t= SDHCI_QUIRK2_CARD_ON_NEEDS_BUS_ON |\n\t\t\t  SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\t  SDHCI_QUIRK2_STOP_WITH_TC,\n\t.allow_runtime_pm = true,\n\t.own_cd_for_runtime_pm = true,\n\t.probe_slot\t= byt_sd_probe_slot,\n\t.add_host\t= byt_add_host,\n\t.remove_slot\t= byt_remove_slot,\n\t.ops\t\t= &sdhci_intel_byt_ops,\n\t.priv_size\t= sizeof(struct intel_host),\n};\n\n \n#define INTEL_MRFLD_EMMC_0\t0\n#define INTEL_MRFLD_EMMC_1\t1\n#define INTEL_MRFLD_SD\t\t2\n#define INTEL_MRFLD_SDIO\t3\n\n#ifdef CONFIG_ACPI\nstatic void intel_mrfld_mmc_fix_up_power_slot(struct sdhci_pci_slot *slot)\n{\n\tstruct acpi_device *device;\n\n\tdevice = ACPI_COMPANION(&slot->chip->pdev->dev);\n\tif (device)\n\t\tacpi_device_fix_up_power_extended(device);\n}\n#else\nstatic inline void intel_mrfld_mmc_fix_up_power_slot(struct sdhci_pci_slot *slot) {}\n#endif\n\nstatic int intel_mrfld_mmc_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tunsigned int func = PCI_FUNC(slot->chip->pdev->devfn);\n\n\tswitch (func) {\n\tcase INTEL_MRFLD_EMMC_0:\n\tcase INTEL_MRFLD_EMMC_1:\n\t\tslot->host->mmc->caps |= MMC_CAP_NONREMOVABLE |\n\t\t\t\t\t MMC_CAP_8_BIT_DATA |\n\t\t\t\t\t MMC_CAP_1_8V_DDR;\n\t\tbreak;\n\tcase INTEL_MRFLD_SD:\n\t\tslot->cd_idx = 0;\n\t\tslot->cd_override_level = true;\n\t\t \n\t\tslot->host->mmc_host_ops.get_cd = mrfld_get_cd;\n\t\tslot->host->quirks2 |= SDHCI_QUIRK2_NO_1_8_V;\n\t\tbreak;\n\tcase INTEL_MRFLD_SDIO:\n\t\t \n\t\tslot->host->ocr_mask = MMC_VDD_20_21 | MMC_VDD_165_195;\n\t\tslot->host->mmc->caps |= MMC_CAP_NONREMOVABLE |\n\t\t\t\t\t MMC_CAP_POWER_OFF_CARD;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\tintel_mrfld_mmc_fix_up_power_slot(slot);\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_intel_mrfld_mmc = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC,\n\t.quirks2\t= SDHCI_QUIRK2_BROKEN_HS200 |\n\t\t\tSDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.allow_runtime_pm = true,\n\t.probe_slot\t= intel_mrfld_mmc_probe_slot,\n};\n\nstatic int jmicron_pmos(struct sdhci_pci_chip *chip, int on)\n{\n\tu8 scratch;\n\tint ret;\n\n\tret = pci_read_config_byte(chip->pdev, 0xAE, &scratch);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (on)\n\t\tscratch |= 0x47;\n\telse\n\t\tscratch &= ~0x47;\n\n\treturn pci_write_config_byte(chip->pdev, 0xAE, scratch);\n}\n\nstatic int jmicron_probe(struct sdhci_pci_chip *chip)\n{\n\tint ret;\n\tu16 mmcdev = 0;\n\n\tif (chip->pdev->revision == 0) {\n\t\tchip->quirks |= SDHCI_QUIRK_32BIT_DMA_ADDR |\n\t\t\t  SDHCI_QUIRK_32BIT_DMA_SIZE |\n\t\t\t  SDHCI_QUIRK_32BIT_ADMA_SIZE |\n\t\t\t  SDHCI_QUIRK_RESET_AFTER_REQUEST |\n\t\t\t  SDHCI_QUIRK_BROKEN_SMALL_PIO;\n\t}\n\n\t \n\tif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_SD)\n\t\tmmcdev = PCI_DEVICE_ID_JMICRON_JMB38X_MMC;\n\telse if (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD)\n\t\tmmcdev = PCI_DEVICE_ID_JMICRON_JMB388_ESD;\n\n\tif (mmcdev) {\n\t\tstruct pci_dev *sd_dev;\n\n\t\tsd_dev = NULL;\n\t\twhile ((sd_dev = pci_get_device(PCI_VENDOR_ID_JMICRON,\n\t\t\t\t\t\tmmcdev, sd_dev)) != NULL) {\n\t\t\tif ((PCI_SLOT(chip->pdev->devfn) ==\n\t\t\t\tPCI_SLOT(sd_dev->devfn)) &&\n\t\t\t\t(chip->pdev->bus == sd_dev->bus))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (sd_dev) {\n\t\t\tpci_dev_put(sd_dev);\n\t\t\tdev_info(&chip->pdev->dev, \"Refusing to bind to \"\n\t\t\t\t\"secondary interface.\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\t \n\tret = jmicron_pmos(chip, 1);\n\tif (ret) {\n\t\tdev_err(&chip->pdev->dev, \"Failure enabling card power\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_SD ||\n\t    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\n\t\tchip->quirks |= SDHCI_QUIRK_UNSTABLE_RO_DETECT;\n\n\treturn 0;\n}\n\nstatic void jmicron_enable_mmc(struct sdhci_host *host, int on)\n{\n\tu8 scratch;\n\n\tscratch = readb(host->ioaddr + 0xC0);\n\n\tif (on)\n\t\tscratch |= 0x01;\n\telse\n\t\tscratch &= ~0x01;\n\n\twriteb(scratch, host->ioaddr + 0xC0);\n}\n\nstatic int jmicron_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tif (slot->chip->pdev->revision == 0) {\n\t\tu16 version;\n\n\t\tversion = readl(slot->host->ioaddr + SDHCI_HOST_VERSION);\n\t\tversion = (version & SDHCI_VENDOR_VER_MASK) >>\n\t\t\tSDHCI_VENDOR_VER_SHIFT;\n\n\t\t \n\t\tif (version < 0xAC)\n\t\t\tslot->host->quirks |= SDHCI_QUIRK_BROKEN_ADMA;\n\t}\n\n\t \n\tif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\n\t\tslot->host->ocr_avail_sd = MMC_VDD_32_33 | MMC_VDD_33_34 |\n\t\t\tMMC_VDD_29_30 | MMC_VDD_30_31 |\n\t\t\tMMC_VDD_165_195;  \n\t\tslot->host->ocr_avail_mmc = MMC_VDD_32_33 | MMC_VDD_33_34 |\n\t\t\tMMC_VDD_29_30 | MMC_VDD_30_31;  \n\t}\n\n\t \n\tif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\n\t    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\n\t\tjmicron_enable_mmc(slot->host, 1);\n\n\tslot->host->mmc->caps |= MMC_CAP_BUS_WIDTH_TEST;\n\n\treturn 0;\n}\n\nstatic void jmicron_remove_slot(struct sdhci_pci_slot *slot, int dead)\n{\n\tif (dead)\n\t\treturn;\n\n\tif (slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\n\t    slot->chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD)\n\t\tjmicron_enable_mmc(slot->host, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int jmicron_suspend(struct sdhci_pci_chip *chip)\n{\n\tint i, ret;\n\n\tret = sdhci_pci_suspend_host(chip);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\n\t    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\n\t\tfor (i = 0; i < chip->num_slots; i++)\n\t\t\tjmicron_enable_mmc(chip->slots[i]->host, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic int jmicron_resume(struct sdhci_pci_chip *chip)\n{\n\tint ret, i;\n\n\tif (chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB38X_MMC ||\n\t    chip->pdev->device == PCI_DEVICE_ID_JMICRON_JMB388_ESD) {\n\t\tfor (i = 0; i < chip->num_slots; i++)\n\t\t\tjmicron_enable_mmc(chip->slots[i]->host, 1);\n\t}\n\n\tret = jmicron_pmos(chip, 1);\n\tif (ret) {\n\t\tdev_err(&chip->pdev->dev, \"Failure enabling card power\\n\");\n\t\treturn ret;\n\t}\n\n\treturn sdhci_pci_resume_host(chip);\n}\n#endif\n\nstatic const struct sdhci_pci_fixes sdhci_jmicron = {\n\t.probe\t\t= jmicron_probe,\n\n\t.probe_slot\t= jmicron_probe_slot,\n\t.remove_slot\t= jmicron_remove_slot,\n\n#ifdef CONFIG_PM_SLEEP\n\t.suspend\t= jmicron_suspend,\n\t.resume\t\t= jmicron_resume,\n#endif\n};\n\n \n#define SYSKT_CTRL\t\t0x200\n#define SYSKT_RDFIFO_STAT\t0x204\n#define SYSKT_WRFIFO_STAT\t0x208\n#define SYSKT_POWER_DATA\t0x20c\n#define   SYSKT_POWER_330\t0xef\n#define   SYSKT_POWER_300\t0xf8\n#define   SYSKT_POWER_184\t0xcc\n#define SYSKT_POWER_CMD\t\t0x20d\n#define   SYSKT_POWER_START\t(1 << 7)\n#define SYSKT_POWER_STATUS\t0x20e\n#define   SYSKT_POWER_STATUS_OK\t(1 << 0)\n#define SYSKT_BOARD_REV\t\t0x210\n#define SYSKT_CHIP_REV\t\t0x211\n#define SYSKT_CONF_DATA\t\t0x212\n#define   SYSKT_CONF_DATA_1V8\t(1 << 2)\n#define   SYSKT_CONF_DATA_2V5\t(1 << 1)\n#define   SYSKT_CONF_DATA_3V3\t(1 << 0)\n\nstatic int syskt_probe(struct sdhci_pci_chip *chip)\n{\n\tif ((chip->pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {\n\t\tchip->pdev->class &= ~0x0000FF;\n\t\tchip->pdev->class |= PCI_SDHCI_IFDMA;\n\t}\n\treturn 0;\n}\n\nstatic int syskt_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tint tm, ps;\n\n\tu8 board_rev = readb(slot->host->ioaddr + SYSKT_BOARD_REV);\n\tu8  chip_rev = readb(slot->host->ioaddr + SYSKT_CHIP_REV);\n\tdev_info(&slot->chip->pdev->dev, \"SysKonnect CardBus2SDIO, \"\n\t\t\t\t\t \"board rev %d.%d, chip rev %d.%d\\n\",\n\t\t\t\t\t board_rev >> 4, board_rev & 0xf,\n\t\t\t\t\t chip_rev >> 4,  chip_rev & 0xf);\n\tif (chip_rev >= 0x20)\n\t\tslot->host->quirks |= SDHCI_QUIRK_FORCE_DMA;\n\n\twriteb(SYSKT_POWER_330, slot->host->ioaddr + SYSKT_POWER_DATA);\n\twriteb(SYSKT_POWER_START, slot->host->ioaddr + SYSKT_POWER_CMD);\n\tudelay(50);\n\ttm = 10;   \n\tdo {\n\t\tps = readw(slot->host->ioaddr + SYSKT_POWER_STATUS);\n\t\tif (ps & SYSKT_POWER_STATUS_OK)\n\t\t\tbreak;\n\t\tudelay(100);\n\t} while (--tm);\n\tif (!tm) {\n\t\tdev_err(&slot->chip->pdev->dev,\n\t\t\t\"power regulator never stabilized\");\n\t\twriteb(0, slot->host->ioaddr + SYSKT_POWER_CMD);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_syskt = {\n\t.quirks\t\t= SDHCI_QUIRK_NO_SIMULT_VDD_AND_POWER,\n\t.probe\t\t= syskt_probe,\n\t.probe_slot\t= syskt_probe_slot,\n};\n\nstatic int via_probe(struct sdhci_pci_chip *chip)\n{\n\tif (chip->pdev->revision == 0x10)\n\t\tchip->quirks |= SDHCI_QUIRK_DELAY_AFTER_POWER;\n\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_via = {\n\t.probe\t\t= via_probe,\n};\n\nstatic int rtsx_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tslot->host->mmc->caps2 |= MMC_CAP2_HS200;\n\treturn 0;\n}\n\nstatic const struct sdhci_pci_fixes sdhci_rtsx = {\n\t.quirks2\t= SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t\tSDHCI_QUIRK2_BROKEN_64_BIT_DMA |\n\t\t\tSDHCI_QUIRK2_BROKEN_DDR50,\n\t.probe_slot\t= rtsx_probe_slot,\n};\n\n \nenum amd_chipset_gen {\n\tAMD_CHIPSET_BEFORE_ML,\n\tAMD_CHIPSET_CZ,\n\tAMD_CHIPSET_NL,\n\tAMD_CHIPSET_UNKNOWN,\n};\n\n \n#define AMD_SD_AUTO_PATTERN\t\t0xB8\n#define AMD_MSLEEP_DURATION\t\t4\n#define AMD_SD_MISC_CONTROL\t\t0xD0\n#define AMD_MAX_TUNE_VALUE\t\t0x0B\n#define AMD_AUTO_TUNE_SEL\t\t0x10800\n#define AMD_FIFO_PTR\t\t\t0x30\n#define AMD_BIT_MASK\t\t\t0x1F\n\nstatic void amd_tuning_reset(struct sdhci_host *host)\n{\n\tunsigned int val;\n\n\tval = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\tval |= SDHCI_CTRL_PRESET_VAL_ENABLE | SDHCI_CTRL_EXEC_TUNING;\n\tsdhci_writew(host, val, SDHCI_HOST_CONTROL2);\n\n\tval = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\tval &= ~SDHCI_CTRL_EXEC_TUNING;\n\tsdhci_writew(host, val, SDHCI_HOST_CONTROL2);\n}\n\nstatic void amd_config_tuning_phase(struct pci_dev *pdev, u8 phase)\n{\n\tunsigned int val;\n\n\tpci_read_config_dword(pdev, AMD_SD_AUTO_PATTERN, &val);\n\tval &= ~AMD_BIT_MASK;\n\tval |= (AMD_AUTO_TUNE_SEL | (phase << 1));\n\tpci_write_config_dword(pdev, AMD_SD_AUTO_PATTERN, val);\n}\n\nstatic void amd_enable_manual_tuning(struct pci_dev *pdev)\n{\n\tunsigned int val;\n\n\tpci_read_config_dword(pdev, AMD_SD_MISC_CONTROL, &val);\n\tval |= AMD_FIFO_PTR;\n\tpci_write_config_dword(pdev, AMD_SD_MISC_CONTROL, val);\n}\n\nstatic int amd_execute_tuning_hs200(struct sdhci_host *host, u32 opcode)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct pci_dev *pdev = slot->chip->pdev;\n\tu8 valid_win = 0;\n\tu8 valid_win_max = 0;\n\tu8 valid_win_end = 0;\n\tu8 ctrl, tune_around;\n\n\tamd_tuning_reset(host);\n\n\tfor (tune_around = 0; tune_around < 12; tune_around++) {\n\t\tamd_config_tuning_phase(pdev, tune_around);\n\n\t\tif (mmc_send_tuning(host->mmc, opcode, NULL)) {\n\t\t\tvalid_win = 0;\n\t\t\tmsleep(AMD_MSLEEP_DURATION);\n\t\t\tctrl = SDHCI_RESET_CMD | SDHCI_RESET_DATA;\n\t\t\tsdhci_writeb(host, ctrl, SDHCI_SOFTWARE_RESET);\n\t\t} else if (++valid_win > valid_win_max) {\n\t\t\tvalid_win_max = valid_win;\n\t\t\tvalid_win_end = tune_around;\n\t\t}\n\t}\n\n\tif (!valid_win_max) {\n\t\tdev_err(&pdev->dev, \"no tuning point found\\n\");\n\t\treturn -EIO;\n\t}\n\n\tamd_config_tuning_phase(pdev, valid_win_end - valid_win_max / 2);\n\n\tamd_enable_manual_tuning(pdev);\n\n\thost->mmc->retune_period = 0;\n\n\treturn 0;\n}\n\nstatic int amd_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\n\t \n\tif (host->timing == MMC_TIMING_MMC_HS200)\n\t\treturn amd_execute_tuning_hs200(host, opcode);\n\n\t \n\treturn sdhci_execute_tuning(mmc, opcode);\n}\n\nstatic int amd_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tstruct mmc_host_ops *ops = &slot->host->mmc_host_ops;\n\n\tops->execute_tuning = amd_execute_tuning;\n\n\treturn 0;\n}\n\nstatic int amd_probe(struct sdhci_pci_chip *chip)\n{\n\tstruct pci_dev\t*smbus_dev;\n\tenum amd_chipset_gen gen;\n\n\tsmbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\tPCI_DEVICE_ID_AMD_HUDSON2_SMBUS, NULL);\n\tif (smbus_dev) {\n\t\tgen = AMD_CHIPSET_BEFORE_ML;\n\t} else {\n\t\tsmbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\tPCI_DEVICE_ID_AMD_KERNCZ_SMBUS, NULL);\n\t\tif (smbus_dev) {\n\t\t\tif (smbus_dev->revision < 0x51)\n\t\t\t\tgen = AMD_CHIPSET_CZ;\n\t\t\telse\n\t\t\t\tgen = AMD_CHIPSET_NL;\n\t\t} else {\n\t\t\tgen = AMD_CHIPSET_UNKNOWN;\n\t\t}\n\t}\n\n\tpci_dev_put(smbus_dev);\n\n\tif (gen == AMD_CHIPSET_BEFORE_ML || gen == AMD_CHIPSET_CZ)\n\t\tchip->quirks2 |= SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD;\n\n\treturn 0;\n}\n\nstatic u32 sdhci_read_present_state(struct sdhci_host *host)\n{\n\treturn sdhci_readl(host, SDHCI_PRESENT_STATE);\n}\n\nstatic void amd_sdhci_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct pci_dev *pdev = slot->chip->pdev;\n\tu32 present_state;\n\n\t \n\tif (pdev->device == 0x7906 && (mask & SDHCI_RESET_ALL)) {\n\t\tpci_clear_master(pdev);\n\n\t\tpci_save_state(pdev);\n\n\t\tpci_set_power_state(pdev, PCI_D3cold);\n\t\tpr_debug(\"%s: power_state=%u\\n\", mmc_hostname(host->mmc),\n\t\t\tpdev->current_state);\n\t\tpci_set_power_state(pdev, PCI_D0);\n\n\t\tpci_restore_state(pdev);\n\n\t\t \n\t\treadx_poll_timeout(\n\t\t\tsdhci_read_present_state,\n\t\t\thost,\n\t\t\tpresent_state,\n\t\t\tpresent_state & SDHCI_CD_STABLE,\n\t\t\t10000,\n\t\t\t100000\n\t\t);\n\t}\n\n\treturn sdhci_reset(host, mask);\n}\n\nstatic const struct sdhci_ops amd_sdhci_pci_ops = {\n\t.set_clock\t\t\t= sdhci_set_clock,\n\t.enable_dma\t\t\t= sdhci_pci_enable_dma,\n\t.set_bus_width\t\t\t= sdhci_set_bus_width,\n\t.reset\t\t\t\t= amd_sdhci_reset,\n\t.set_uhs_signaling\t\t= sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pci_fixes sdhci_amd = {\n\t.probe\t\t= amd_probe,\n\t.ops\t\t= &amd_sdhci_pci_ops,\n\t.probe_slot\t= amd_probe_slot,\n};\n\nstatic const struct pci_device_id pci_ids[] = {\n\tSDHCI_PCI_DEVICE(RICOH, R5C822,  ricoh),\n\tSDHCI_PCI_DEVICE(RICOH, R5C843,  ricoh_mmc),\n\tSDHCI_PCI_DEVICE(RICOH, R5CE822, ricoh_mmc),\n\tSDHCI_PCI_DEVICE(RICOH, R5CE823, ricoh_mmc),\n\tSDHCI_PCI_DEVICE(ENE, CB712_SD,   ene_712),\n\tSDHCI_PCI_DEVICE(ENE, CB712_SD_2, ene_712),\n\tSDHCI_PCI_DEVICE(ENE, CB714_SD,   ene_714),\n\tSDHCI_PCI_DEVICE(ENE, CB714_SD_2, ene_714),\n\tSDHCI_PCI_DEVICE(MARVELL, 88ALP01_SD, cafe),\n\tSDHCI_PCI_DEVICE(JMICRON, JMB38X_SD,  jmicron),\n\tSDHCI_PCI_DEVICE(JMICRON, JMB38X_MMC, jmicron),\n\tSDHCI_PCI_DEVICE(JMICRON, JMB388_SD,  jmicron),\n\tSDHCI_PCI_DEVICE(JMICRON, JMB388_ESD, jmicron),\n\tSDHCI_PCI_DEVICE(SYSKONNECT, 8000, syskt),\n\tSDHCI_PCI_DEVICE(VIA, 95D0, via),\n\tSDHCI_PCI_DEVICE(REALTEK, 5250, rtsx),\n\tSDHCI_PCI_DEVICE(INTEL, QRK_SD,    intel_qrk),\n\tSDHCI_PCI_DEVICE(INTEL, MRST_SD0,  intel_mrst_hc0),\n\tSDHCI_PCI_DEVICE(INTEL, MRST_SD1,  intel_mrst_hc1_hc2),\n\tSDHCI_PCI_DEVICE(INTEL, MRST_SD2,  intel_mrst_hc1_hc2),\n\tSDHCI_PCI_DEVICE(INTEL, MFD_SD,    intel_mfd_sd),\n\tSDHCI_PCI_DEVICE(INTEL, MFD_SDIO1, intel_mfd_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, MFD_SDIO2, intel_mfd_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, MFD_EMMC0, intel_mfd_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, MFD_EMMC1, intel_mfd_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, PCH_SDIO0, intel_pch_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, PCH_SDIO1, intel_pch_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BYT_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_SUBDEVICE(INTEL, BYT_SDIO, NI, 7884, ni_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BYT_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BYT_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, BYT_EMMC2, intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, BSW_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, BSW_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BSW_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CLV_SDIO0, intel_mfd_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CLV_SDIO1, intel_mfd_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, CLV_SDIO2, intel_mfd_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, CLV_EMMC0, intel_mfd_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, CLV_EMMC1, intel_mfd_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, MRFLD_MMC, intel_mrfld_mmc),\n\tSDHCI_PCI_DEVICE(INTEL, SPT_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, SPT_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, SPT_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, DNV_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, CDF_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, BXT_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, BXT_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BXT_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, BXTM_EMMC, intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, BXTM_SDIO, intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, BXTM_SD,   intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, APL_EMMC,  intel_byt_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, APL_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, APL_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, GLK_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, GLK_SDIO,  intel_byt_sdio),\n\tSDHCI_PCI_DEVICE(INTEL, GLK_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CNP_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, CNP_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CNPH_SD,   intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, ICP_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, ICP_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, EHL_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, EHL_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CML_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, CML_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, CMLH_SD,   intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, JSL_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, JSL_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, LKF_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(INTEL, LKF_SD,    intel_byt_sd),\n\tSDHCI_PCI_DEVICE(INTEL, ADL_EMMC,  intel_glk_emmc),\n\tSDHCI_PCI_DEVICE(O2, 8120,     o2),\n\tSDHCI_PCI_DEVICE(O2, 8220,     o2),\n\tSDHCI_PCI_DEVICE(O2, 8221,     o2),\n\tSDHCI_PCI_DEVICE(O2, 8320,     o2),\n\tSDHCI_PCI_DEVICE(O2, 8321,     o2),\n\tSDHCI_PCI_DEVICE(O2, FUJIN2,   o2),\n\tSDHCI_PCI_DEVICE(O2, SDS0,     o2),\n\tSDHCI_PCI_DEVICE(O2, SDS1,     o2),\n\tSDHCI_PCI_DEVICE(O2, SEABIRD0, o2),\n\tSDHCI_PCI_DEVICE(O2, SEABIRD1, o2),\n\tSDHCI_PCI_DEVICE(O2, GG8_9860, o2),\n\tSDHCI_PCI_DEVICE(O2, GG8_9861, o2),\n\tSDHCI_PCI_DEVICE(O2, GG8_9862, o2),\n\tSDHCI_PCI_DEVICE(O2, GG8_9863, o2),\n\tSDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),\n\tSDHCI_PCI_DEVICE(SYNOPSYS, DWC_MSHC, snps),\n\tSDHCI_PCI_DEVICE(GLI, 9750, gl9750),\n\tSDHCI_PCI_DEVICE(GLI, 9755, gl9755),\n\tSDHCI_PCI_DEVICE(GLI, 9763E, gl9763e),\n\tSDHCI_PCI_DEVICE(GLI, 9767, gl9767),\n\tSDHCI_PCI_DEVICE_CLASS(AMD, SYSTEM_SDHCI, PCI_CLASS_MASK, amd),\n\t \n\t{PCI_DEVICE_CLASS(SYSTEM_SDHCI, PCI_CLASS_MASK)},\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\n \n\nint sdhci_pci_enable_dma(struct sdhci_host *host)\n{\n\tstruct sdhci_pci_slot *slot;\n\tstruct pci_dev *pdev;\n\n\tslot = sdhci_priv(host);\n\tpdev = slot->chip->pdev;\n\n\tif (((pdev->class & 0xFFFF00) == (PCI_CLASS_SYSTEM_SDHCI << 8)) &&\n\t\t((pdev->class & 0x0000FF) != PCI_SDHCI_IFDMA) &&\n\t\t(host->flags & SDHCI_USE_SDMA)) {\n\t\tdev_warn(&pdev->dev, \"Will use DMA mode even though HW \"\n\t\t\t\"doesn't fully claim to support it.\\n\");\n\t}\n\n\tpci_set_master(pdev);\n\n\treturn 0;\n}\n\nstatic void sdhci_pci_hw_reset(struct sdhci_host *host)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\n\tif (slot->hw_reset)\n\t\tslot->hw_reset(host);\n}\n\nstatic const struct sdhci_ops sdhci_pci_ops = {\n\t.set_clock\t= sdhci_set_clock,\n\t.enable_dma\t= sdhci_pci_enable_dma,\n\t.set_bus_width\t= sdhci_set_bus_width,\n\t.reset\t\t= sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.hw_reset\t\t= sdhci_pci_hw_reset,\n};\n\n \n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_pci_suspend(struct device *dev)\n{\n\tstruct sdhci_pci_chip *chip = dev_get_drvdata(dev);\n\n\tif (!chip)\n\t\treturn 0;\n\n\tif (chip->fixes && chip->fixes->suspend)\n\t\treturn chip->fixes->suspend(chip);\n\n\treturn sdhci_pci_suspend_host(chip);\n}\n\nstatic int sdhci_pci_resume(struct device *dev)\n{\n\tstruct sdhci_pci_chip *chip = dev_get_drvdata(dev);\n\n\tif (!chip)\n\t\treturn 0;\n\n\tif (chip->fixes && chip->fixes->resume)\n\t\treturn chip->fixes->resume(chip);\n\n\treturn sdhci_pci_resume_host(chip);\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sdhci_pci_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_pci_chip *chip = dev_get_drvdata(dev);\n\n\tif (!chip)\n\t\treturn 0;\n\n\tif (chip->fixes && chip->fixes->runtime_suspend)\n\t\treturn chip->fixes->runtime_suspend(chip);\n\n\treturn sdhci_pci_runtime_suspend_host(chip);\n}\n\nstatic int sdhci_pci_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_pci_chip *chip = dev_get_drvdata(dev);\n\n\tif (!chip)\n\t\treturn 0;\n\n\tif (chip->fixes && chip->fixes->runtime_resume)\n\t\treturn chip->fixes->runtime_resume(chip);\n\n\treturn sdhci_pci_runtime_resume_host(chip);\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_pci_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_pci_suspend, sdhci_pci_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_pci_runtime_suspend,\n\t\t\tsdhci_pci_runtime_resume, NULL)\n};\n\n \n\nstatic struct sdhci_pci_slot *sdhci_pci_probe_slot(\n\tstruct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,\n\tint slotno)\n{\n\tstruct sdhci_pci_slot *slot;\n\tstruct sdhci_host *host;\n\tint ret, bar = first_bar + slotno;\n\tsize_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;\n\n\tif (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {\n\t\tdev_err(&pdev->dev, \"BAR %d is not iomem. Aborting.\\n\", bar);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif (pci_resource_len(pdev, bar) < 0x100) {\n\t\tdev_err(&pdev->dev, \"Invalid iomem size. You may \"\n\t\t\t\"experience problems.\\n\");\n\t}\n\n\tif ((pdev->class & 0x0000FF) == PCI_SDHCI_IFVENDOR) {\n\t\tdev_err(&pdev->dev, \"Vendor specific interface. Aborting.\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\tif ((pdev->class & 0x0000FF) > PCI_SDHCI_IFVENDOR) {\n\t\tdev_err(&pdev->dev, \"Unknown interface. Aborting.\\n\");\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\thost = sdhci_alloc_host(&pdev->dev, sizeof(*slot) + priv_size);\n\tif (IS_ERR(host)) {\n\t\tdev_err(&pdev->dev, \"cannot allocate host\\n\");\n\t\treturn ERR_CAST(host);\n\t}\n\n\tslot = sdhci_priv(host);\n\n\tslot->chip = chip;\n\tslot->host = host;\n\tslot->cd_idx = -1;\n\n\thost->hw_name = \"PCI\";\n\thost->ops = chip->fixes && chip->fixes->ops ?\n\t\t    chip->fixes->ops :\n\t\t    &sdhci_pci_ops;\n\thost->quirks = chip->quirks;\n\thost->quirks2 = chip->quirks2;\n\n\thost->irq = pdev->irq;\n\n\tret = pcim_iomap_regions(pdev, BIT(bar), mmc_hostname(host->mmc));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot request region\\n\");\n\t\tgoto cleanup;\n\t}\n\n\thost->ioaddr = pcim_iomap_table(pdev)[bar];\n\n\tif (chip->fixes && chip->fixes->probe_slot) {\n\t\tret = chip->fixes->probe_slot(slot);\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\t}\n\n\thost->mmc->pm_caps = MMC_PM_KEEP_POWER;\n\thost->mmc->slotno = slotno;\n\thost->mmc->caps2 |= MMC_CAP2_NO_PRESCAN_POWERUP;\n\n\tif (device_can_wakeup(&pdev->dev))\n\t\thost->mmc->pm_caps |= MMC_PM_WAKE_SDIO_IRQ;\n\n\tif (host->mmc->caps & MMC_CAP_CD_WAKE)\n\t\tdevice_init_wakeup(&pdev->dev, true);\n\n\tif (slot->cd_idx >= 0) {\n\t\tret = mmc_gpiod_request_cd(host->mmc, \"cd\", slot->cd_idx,\n\t\t\t\t\t   slot->cd_override_level, 0);\n\t\tif (ret && ret != -EPROBE_DEFER)\n\t\t\tret = mmc_gpiod_request_cd(host->mmc, NULL,\n\t\t\t\t\t\t   slot->cd_idx,\n\t\t\t\t\t\t   slot->cd_override_level,\n\t\t\t\t\t\t   0);\n\t\tif (ret == -EPROBE_DEFER)\n\t\t\tgoto remove;\n\n\t\tif (ret) {\n\t\t\tdev_warn(&pdev->dev, \"failed to setup card detect gpio\\n\");\n\t\t\tslot->cd_idx = -1;\n\t\t}\n\t}\n\n\tif (chip->fixes && chip->fixes->add_host)\n\t\tret = chip->fixes->add_host(slot);\n\telse\n\t\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto remove;\n\n\t \n\tif (chip->fixes && chip->fixes->own_cd_for_runtime_pm && slot->cd_idx < 0)\n\t\tchip->allow_runtime_pm = false;\n\n\treturn slot;\n\nremove:\n\tif (chip->fixes && chip->fixes->remove_slot)\n\t\tchip->fixes->remove_slot(slot, 0);\n\ncleanup:\n\tsdhci_free_host(host);\n\n\treturn ERR_PTR(ret);\n}\n\nstatic void sdhci_pci_remove_slot(struct sdhci_pci_slot *slot)\n{\n\tint dead;\n\tu32 scratch;\n\n\tdead = 0;\n\tscratch = readl(slot->host->ioaddr + SDHCI_INT_STATUS);\n\tif (scratch == (u32)-1)\n\t\tdead = 1;\n\n\tsdhci_remove_host(slot->host, dead);\n\n\tif (slot->chip->fixes && slot->chip->fixes->remove_slot)\n\t\tslot->chip->fixes->remove_slot(slot, dead);\n\n\tsdhci_free_host(slot->host);\n}\n\nstatic void sdhci_pci_runtime_pm_allow(struct device *dev)\n{\n\tpm_suspend_ignore_children(dev, 1);\n\tpm_runtime_set_autosuspend_delay(dev, 50);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_allow(dev);\n\t \n\tpm_runtime_put_noidle(dev);\n}\n\nstatic void sdhci_pci_runtime_pm_forbid(struct device *dev)\n{\n\tpm_runtime_forbid(dev);\n\tpm_runtime_get_noresume(dev);\n}\n\nstatic int sdhci_pci_probe(struct pci_dev *pdev,\n\t\t\t\t     const struct pci_device_id *ent)\n{\n\tstruct sdhci_pci_chip *chip;\n\tstruct sdhci_pci_slot *slot;\n\n\tu8 slots, first_bar;\n\tint ret, i;\n\n\tBUG_ON(pdev == NULL);\n\tBUG_ON(ent == NULL);\n\n\tdev_info(&pdev->dev, \"SDHCI controller found [%04x:%04x] (rev %x)\\n\",\n\t\t (int)pdev->vendor, (int)pdev->device, (int)pdev->revision);\n\n\tret = pci_read_config_byte(pdev, PCI_SLOT_INFO, &slots);\n\tif (ret)\n\t\treturn ret;\n\n\tslots = PCI_SLOT_INFO_SLOTS(slots) + 1;\n\tdev_dbg(&pdev->dev, \"found %d slot(s)\\n\", slots);\n\n\tBUG_ON(slots > MAX_SLOTS);\n\n\tret = pci_read_config_byte(pdev, PCI_SLOT_INFO, &first_bar);\n\tif (ret)\n\t\treturn ret;\n\n\tfirst_bar &= PCI_SLOT_INFO_FIRST_BAR_MASK;\n\n\tif (first_bar > 5) {\n\t\tdev_err(&pdev->dev, \"Invalid first BAR. Aborting.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->pdev = pdev;\n\tchip->fixes = (const struct sdhci_pci_fixes *)ent->driver_data;\n\tif (chip->fixes) {\n\t\tchip->quirks = chip->fixes->quirks;\n\t\tchip->quirks2 = chip->fixes->quirks2;\n\t\tchip->allow_runtime_pm = chip->fixes->allow_runtime_pm;\n\t}\n\tchip->num_slots = slots;\n\tchip->pm_retune = true;\n\tchip->rpm_retune = true;\n\n\tpci_set_drvdata(pdev, chip);\n\n\tif (chip->fixes && chip->fixes->probe) {\n\t\tret = chip->fixes->probe(chip);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tslots = chip->num_slots;\t \n\n\tfor (i = 0; i < slots; i++) {\n\t\tslot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);\n\t\tif (IS_ERR(slot)) {\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tsdhci_pci_remove_slot(chip->slots[i]);\n\t\t\treturn PTR_ERR(slot);\n\t\t}\n\n\t\tchip->slots[i] = slot;\n\t}\n\n\tif (chip->allow_runtime_pm)\n\t\tsdhci_pci_runtime_pm_allow(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic void sdhci_pci_remove(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct sdhci_pci_chip *chip = pci_get_drvdata(pdev);\n\n\tif (chip->allow_runtime_pm)\n\t\tsdhci_pci_runtime_pm_forbid(&pdev->dev);\n\n\tfor (i = 0; i < chip->num_slots; i++)\n\t\tsdhci_pci_remove_slot(chip->slots[i]);\n}\n\nstatic struct pci_driver sdhci_driver = {\n\t.name =\t\t\"sdhci-pci\",\n\t.id_table =\tpci_ids,\n\t.probe =\tsdhci_pci_probe,\n\t.remove =\tsdhci_pci_remove,\n\t.driver =\t{\n\t\t.pm =   &sdhci_pci_pm_ops,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nmodule_pci_driver(sdhci_driver);\n\nMODULE_AUTHOR(\"Pierre Ossman <pierre@ossman.eu>\");\nMODULE_DESCRIPTION(\"Secure Digital Host Controller Interface PCI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}