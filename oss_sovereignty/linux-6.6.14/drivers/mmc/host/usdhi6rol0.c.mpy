{
  "module_name": "usdhi6rol0.c",
  "hash_id": "b540524bcbfab748488d9a14809357dce280a8ed0d0389d198d7bb5891e9f135",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/usdhi6rol0.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/log2.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/sdio.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/string.h>\n#include <linux/time.h>\n#include <linux/virtio.h>\n#include <linux/workqueue.h>\n\n#define USDHI6_SD_CMD\t\t0x0000\n#define USDHI6_SD_PORT_SEL\t0x0004\n#define USDHI6_SD_ARG\t\t0x0008\n#define USDHI6_SD_STOP\t\t0x0010\n#define USDHI6_SD_SECCNT\t0x0014\n#define USDHI6_SD_RSP10\t\t0x0018\n#define USDHI6_SD_RSP32\t\t0x0020\n#define USDHI6_SD_RSP54\t\t0x0028\n#define USDHI6_SD_RSP76\t\t0x0030\n#define USDHI6_SD_INFO1\t\t0x0038\n#define USDHI6_SD_INFO2\t\t0x003c\n#define USDHI6_SD_INFO1_MASK\t0x0040\n#define USDHI6_SD_INFO2_MASK\t0x0044\n#define USDHI6_SD_CLK_CTRL\t0x0048\n#define USDHI6_SD_SIZE\t\t0x004c\n#define USDHI6_SD_OPTION\t0x0050\n#define USDHI6_SD_ERR_STS1\t0x0058\n#define USDHI6_SD_ERR_STS2\t0x005c\n#define USDHI6_SD_BUF0\t\t0x0060\n#define USDHI6_SDIO_MODE\t0x0068\n#define USDHI6_SDIO_INFO1\t0x006c\n#define USDHI6_SDIO_INFO1_MASK\t0x0070\n#define USDHI6_CC_EXT_MODE\t0x01b0\n#define USDHI6_SOFT_RST\t\t0x01c0\n#define USDHI6_VERSION\t\t0x01c4\n#define USDHI6_HOST_MODE\t0x01c8\n#define USDHI6_SDIF_MODE\t0x01cc\n\n#define USDHI6_SD_CMD_APP\t\t0x0040\n#define USDHI6_SD_CMD_MODE_RSP_AUTO\t0x0000\n#define USDHI6_SD_CMD_MODE_RSP_NONE\t0x0300\n#define USDHI6_SD_CMD_MODE_RSP_R1\t0x0400\t \n#define USDHI6_SD_CMD_MODE_RSP_R1B\t0x0500\t \n#define USDHI6_SD_CMD_MODE_RSP_R2\t0x0600\n#define USDHI6_SD_CMD_MODE_RSP_R3\t0x0700\t \n#define USDHI6_SD_CMD_DATA\t\t0x0800\n#define USDHI6_SD_CMD_READ\t\t0x1000\n#define USDHI6_SD_CMD_MULTI\t\t0x2000\n#define USDHI6_SD_CMD_CMD12_AUTO_OFF\t0x4000\n\n#define USDHI6_CC_EXT_MODE_SDRW\t\tBIT(1)\n\n#define USDHI6_SD_INFO1_RSP_END\t\tBIT(0)\n#define USDHI6_SD_INFO1_ACCESS_END\tBIT(2)\n#define USDHI6_SD_INFO1_CARD_OUT\tBIT(3)\n#define USDHI6_SD_INFO1_CARD_IN\t\tBIT(4)\n#define USDHI6_SD_INFO1_CD\t\tBIT(5)\n#define USDHI6_SD_INFO1_WP\t\tBIT(7)\n#define USDHI6_SD_INFO1_D3_CARD_OUT\tBIT(8)\n#define USDHI6_SD_INFO1_D3_CARD_IN\tBIT(9)\n\n#define USDHI6_SD_INFO2_CMD_ERR\t\tBIT(0)\n#define USDHI6_SD_INFO2_CRC_ERR\t\tBIT(1)\n#define USDHI6_SD_INFO2_END_ERR\t\tBIT(2)\n#define USDHI6_SD_INFO2_TOUT\t\tBIT(3)\n#define USDHI6_SD_INFO2_IWA_ERR\t\tBIT(4)\n#define USDHI6_SD_INFO2_IRA_ERR\t\tBIT(5)\n#define USDHI6_SD_INFO2_RSP_TOUT\tBIT(6)\n#define USDHI6_SD_INFO2_SDDAT0\t\tBIT(7)\n#define USDHI6_SD_INFO2_BRE\t\tBIT(8)\n#define USDHI6_SD_INFO2_BWE\t\tBIT(9)\n#define USDHI6_SD_INFO2_SCLKDIVEN\tBIT(13)\n#define USDHI6_SD_INFO2_CBSY\t\tBIT(14)\n#define USDHI6_SD_INFO2_ILA\t\tBIT(15)\n\n#define USDHI6_SD_INFO1_CARD_INSERT (USDHI6_SD_INFO1_CARD_IN | USDHI6_SD_INFO1_D3_CARD_IN)\n#define USDHI6_SD_INFO1_CARD_EJECT (USDHI6_SD_INFO1_CARD_OUT | USDHI6_SD_INFO1_D3_CARD_OUT)\n#define USDHI6_SD_INFO1_CARD (USDHI6_SD_INFO1_CARD_INSERT | USDHI6_SD_INFO1_CARD_EJECT)\n#define USDHI6_SD_INFO1_CARD_CD (USDHI6_SD_INFO1_CARD_IN | USDHI6_SD_INFO1_CARD_OUT)\n\n#define USDHI6_SD_INFO2_ERR\t(USDHI6_SD_INFO2_CMD_ERR |\t\\\n\tUSDHI6_SD_INFO2_CRC_ERR | USDHI6_SD_INFO2_END_ERR |\t\\\n\tUSDHI6_SD_INFO2_TOUT | USDHI6_SD_INFO2_IWA_ERR |\t\\\n\tUSDHI6_SD_INFO2_IRA_ERR | USDHI6_SD_INFO2_RSP_TOUT |\t\\\n\tUSDHI6_SD_INFO2_ILA)\n\n#define USDHI6_SD_INFO1_IRQ\t(USDHI6_SD_INFO1_RSP_END | USDHI6_SD_INFO1_ACCESS_END | \\\n\t\t\t\t USDHI6_SD_INFO1_CARD)\n\n#define USDHI6_SD_INFO2_IRQ\t(USDHI6_SD_INFO2_ERR | USDHI6_SD_INFO2_BRE | \\\n\t\t\t\t USDHI6_SD_INFO2_BWE | 0x0800 | USDHI6_SD_INFO2_ILA)\n\n#define USDHI6_SD_CLK_CTRL_SCLKEN\tBIT(8)\n\n#define USDHI6_SD_STOP_STP\t\tBIT(0)\n#define USDHI6_SD_STOP_SEC\t\tBIT(8)\n\n#define USDHI6_SDIO_INFO1_IOIRQ\t\tBIT(0)\n#define USDHI6_SDIO_INFO1_EXPUB52\tBIT(14)\n#define USDHI6_SDIO_INFO1_EXWT\t\tBIT(15)\n\n#define USDHI6_SD_ERR_STS1_CRC_NO_ERROR\tBIT(13)\n\n#define USDHI6_SOFT_RST_RESERVED\t(BIT(1) | BIT(2))\n#define USDHI6_SOFT_RST_RESET\t\tBIT(0)\n\n#define USDHI6_SD_OPTION_TIMEOUT_SHIFT\t4\n#define USDHI6_SD_OPTION_TIMEOUT_MASK\t(0xf << USDHI6_SD_OPTION_TIMEOUT_SHIFT)\n#define USDHI6_SD_OPTION_WIDTH_1\tBIT(15)\n\n#define USDHI6_SD_PORT_SEL_PORTS_SHIFT\t8\n\n#define USDHI6_SD_CLK_CTRL_DIV_MASK\t0xff\n\n#define USDHI6_SDIO_INFO1_IRQ\t(USDHI6_SDIO_INFO1_IOIRQ | 3 | \\\n\t\t\t\t USDHI6_SDIO_INFO1_EXPUB52 | USDHI6_SDIO_INFO1_EXWT)\n\n#define USDHI6_MIN_DMA 64\n\n#define USDHI6_REQ_TIMEOUT_MS 4000\n\nenum usdhi6_wait_for {\n\tUSDHI6_WAIT_FOR_REQUEST,\n\tUSDHI6_WAIT_FOR_CMD,\n\tUSDHI6_WAIT_FOR_MREAD,\n\tUSDHI6_WAIT_FOR_MWRITE,\n\tUSDHI6_WAIT_FOR_READ,\n\tUSDHI6_WAIT_FOR_WRITE,\n\tUSDHI6_WAIT_FOR_DATA_END,\n\tUSDHI6_WAIT_FOR_STOP,\n\tUSDHI6_WAIT_FOR_DMA,\n};\n\nstruct usdhi6_page {\n\tstruct page *page;\n\tvoid *mapped;\t\t \n};\n\nstruct usdhi6_host {\n\tstruct mmc_host *mmc;\n\tstruct mmc_request *mrq;\n\tvoid __iomem *base;\n\tstruct clk *clk;\n\n\t \n\n\t \n\tstruct usdhi6_page pg;\t \n\tvoid *blk_page;\t\t \n\tsize_t offset;\t\t \n\n\t \n\tsize_t head_len;\n\tstruct usdhi6_page head_pg;\n\n\t \n\tstruct scatterlist bounce_sg;\n\tu8 bounce_buf[512];\n\n\t \n\tstruct scatterlist *sg;\t \n\tint page_idx;\t\t \n\n\tenum usdhi6_wait_for wait;\n\tu32 status_mask;\n\tu32 status2_mask;\n\tu32 sdio_mask;\n\tu32 io_error;\n\tu32 irq_status;\n\tunsigned long imclk;\n\tunsigned long rate;\n\tbool app_cmd;\n\n\t \n\tstruct delayed_work timeout_work;\n\tunsigned long timeout;\n\n\t \n\tstruct dma_chan *chan_rx;\n\tstruct dma_chan *chan_tx;\n\tbool dma_active;\n\n\t \n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_uhs;\n};\n\n \n\nstatic void usdhi6_write(struct usdhi6_host *host, u32 reg, u32 data)\n{\n\tiowrite32(data, host->base + reg);\n\tdev_vdbg(mmc_dev(host->mmc), \"%s(0x%p + 0x%x) = 0x%x\\n\", __func__,\n\t\thost->base, reg, data);\n}\n\nstatic void usdhi6_write16(struct usdhi6_host *host, u32 reg, u16 data)\n{\n\tiowrite16(data, host->base + reg);\n\tdev_vdbg(mmc_dev(host->mmc), \"%s(0x%p + 0x%x) = 0x%x\\n\", __func__,\n\t\thost->base, reg, data);\n}\n\nstatic u32 usdhi6_read(struct usdhi6_host *host, u32 reg)\n{\n\tu32 data = ioread32(host->base + reg);\n\tdev_vdbg(mmc_dev(host->mmc), \"%s(0x%p + 0x%x) = 0x%x\\n\", __func__,\n\t\thost->base, reg, data);\n\treturn data;\n}\n\nstatic u16 usdhi6_read16(struct usdhi6_host *host, u32 reg)\n{\n\tu16 data = ioread16(host->base + reg);\n\tdev_vdbg(mmc_dev(host->mmc), \"%s(0x%p + 0x%x) = 0x%x\\n\", __func__,\n\t\thost->base, reg, data);\n\treturn data;\n}\n\nstatic void usdhi6_irq_enable(struct usdhi6_host *host, u32 info1, u32 info2)\n{\n\thost->status_mask = USDHI6_SD_INFO1_IRQ & ~info1;\n\thost->status2_mask = USDHI6_SD_INFO2_IRQ & ~info2;\n\tusdhi6_write(host, USDHI6_SD_INFO1_MASK, host->status_mask);\n\tusdhi6_write(host, USDHI6_SD_INFO2_MASK, host->status2_mask);\n}\n\nstatic void usdhi6_wait_for_resp(struct usdhi6_host *host)\n{\n\tusdhi6_irq_enable(host, USDHI6_SD_INFO1_RSP_END |\n\t\t\t  USDHI6_SD_INFO1_ACCESS_END | USDHI6_SD_INFO1_CARD_CD,\n\t\t\t  USDHI6_SD_INFO2_ERR);\n}\n\nstatic void usdhi6_wait_for_brwe(struct usdhi6_host *host, bool read)\n{\n\tusdhi6_irq_enable(host, USDHI6_SD_INFO1_ACCESS_END |\n\t\t\t  USDHI6_SD_INFO1_CARD_CD, USDHI6_SD_INFO2_ERR |\n\t\t\t  (read ? USDHI6_SD_INFO2_BRE : USDHI6_SD_INFO2_BWE));\n}\n\nstatic void usdhi6_only_cd(struct usdhi6_host *host)\n{\n\t \n\tusdhi6_irq_enable(host, USDHI6_SD_INFO1_CARD_CD, 0);\n}\n\nstatic void usdhi6_mask_all(struct usdhi6_host *host)\n{\n\tusdhi6_irq_enable(host, 0, 0);\n}\n\nstatic int usdhi6_error_code(struct usdhi6_host *host)\n{\n\tu32 err;\n\n\tusdhi6_write(host, USDHI6_SD_STOP, USDHI6_SD_STOP_STP);\n\n\tif (host->io_error &\n\t    (USDHI6_SD_INFO2_RSP_TOUT | USDHI6_SD_INFO2_TOUT)) {\n\t\tu32 rsp54 = usdhi6_read(host, USDHI6_SD_RSP54);\n\t\tint opc = host->mrq ? host->mrq->cmd->opcode : -1;\n\n\t\terr = usdhi6_read(host, USDHI6_SD_ERR_STS2);\n\t\t \n\t\tif (host->wait == USDHI6_WAIT_FOR_CMD)\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"T-out sts 0x%x, resp 0x%x, state %u, CMD%d\\n\",\n\t\t\t\terr, rsp54, host->wait, opc);\n\t\telse\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"T-out sts 0x%x, resp 0x%x, state %u, CMD%d\\n\",\n\t\t\t\t err, rsp54, host->wait, opc);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\terr = usdhi6_read(host, USDHI6_SD_ERR_STS1);\n\tif (err != USDHI6_SD_ERR_STS1_CRC_NO_ERROR)\n\t\tdev_warn(mmc_dev(host->mmc), \"Err sts 0x%x, state %u, CMD%d\\n\",\n\t\t\t err, host->wait, host->mrq ? host->mrq->cmd->opcode : -1);\n\tif (host->io_error & USDHI6_SD_INFO2_ILA)\n\t\treturn -EILSEQ;\n\n\treturn -EIO;\n}\n\n \n\n \nstatic void usdhi6_blk_bounce(struct usdhi6_host *host,\n\t\t\t      struct scatterlist *sg)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tsize_t blk_head = host->head_len;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): CMD%u of %u SG: %ux%u @ 0x%x\\n\",\n\t\t__func__, host->mrq->cmd->opcode, data->sg_len,\n\t\tdata->blksz, data->blocks, sg->offset);\n\n\thost->head_pg.page\t= host->pg.page;\n\thost->head_pg.mapped\t= host->pg.mapped;\n\thost->pg.page\t\t= nth_page(host->pg.page, 1);\n\thost->pg.mapped\t\t= kmap(host->pg.page);\n\n\thost->blk_page = host->bounce_buf;\n\thost->offset = 0;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\treturn;\n\n\tmemcpy(host->bounce_buf, host->head_pg.mapped + PAGE_SIZE - blk_head,\n\t       blk_head);\n\tmemcpy(host->bounce_buf + blk_head, host->pg.mapped,\n\t       data->blksz - blk_head);\n}\n\n \nstatic void usdhi6_sg_prep(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_data *data = mrq->data;\n\n\tusdhi6_write(host, USDHI6_SD_SECCNT, data->blocks);\n\n\thost->sg = data->sg;\n\t \n\thost->offset = host->sg->offset;\n}\n\n \nstatic void *usdhi6_sg_map(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tstruct scatterlist *sg = data->sg_len > 1 ? host->sg : data->sg;\n\tsize_t head = PAGE_SIZE - sg->offset;\n\tsize_t blk_head = head % data->blksz;\n\n\tWARN(host->pg.page, \"%p not properly unmapped!\\n\", host->pg.page);\n\tif (WARN(sg_dma_len(sg) % data->blksz,\n\t\t \"SG size %u isn't a multiple of block size %u\\n\",\n\t\t sg_dma_len(sg), data->blksz))\n\t\treturn NULL;\n\n\thost->pg.page = sg_page(sg);\n\thost->pg.mapped = kmap(host->pg.page);\n\thost->offset = sg->offset;\n\n\t \n\thost->head_len = blk_head;\n\n\tif (head < data->blksz)\n\t\t \n\t\tusdhi6_blk_bounce(host, sg);\n\telse\n\t\thost->blk_page = host->pg.mapped;\n\n\tdev_dbg(mmc_dev(host->mmc), \"Mapped %p (%lx) at %p + %u for CMD%u @ 0x%p\\n\",\n\t\thost->pg.page, page_to_pfn(host->pg.page), host->pg.mapped,\n\t\tsg->offset, host->mrq->cmd->opcode, host->mrq);\n\n\treturn host->blk_page + host->offset;\n}\n\n \nstatic void usdhi6_sg_unmap(struct usdhi6_host *host, bool force)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tstruct page *page = host->head_pg.page;\n\n\tif (page) {\n\t\t \n\t\tstruct scatterlist *sg = data->sg_len > 1 ?\n\t\t\thost->sg : data->sg;\n\t\tsize_t blk_head = host->head_len;\n\n\t\tif (!data->error && data->flags & MMC_DATA_READ) {\n\t\t\tmemcpy(host->head_pg.mapped + PAGE_SIZE - blk_head,\n\t\t\t       host->bounce_buf, blk_head);\n\t\t\tmemcpy(host->pg.mapped, host->bounce_buf + blk_head,\n\t\t\t       data->blksz - blk_head);\n\t\t}\n\n\t\tflush_dcache_page(page);\n\t\tkunmap(page);\n\n\t\thost->head_pg.page = NULL;\n\n\t\tif (!force && sg_dma_len(sg) + sg->offset >\n\t\t    (host->page_idx << PAGE_SHIFT) + data->blksz - blk_head)\n\t\t\t \n\t\t\treturn;\n\t}\n\n\tpage = host->pg.page;\n\tif (!page)\n\t\treturn;\n\n\tflush_dcache_page(page);\n\tkunmap(page);\n\n\thost->pg.page = NULL;\n}\n\n \nstatic void usdhi6_sg_advance(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tsize_t done, total;\n\n\t \n\tif (host->head_pg.page) {\n\t\t \n\t\thost->page_idx++;\n\t\thost->offset = data->blksz - host->head_len;\n\t\thost->blk_page = host->pg.mapped;\n\t\tusdhi6_sg_unmap(host, false);\n\t} else {\n\t\thost->offset += data->blksz;\n\t\t \n\t\tif (host->offset == PAGE_SIZE) {\n\t\t\t \n\t\t\thost->offset = 0;\n\t\t\thost->page_idx++;\n\t\t}\n\t}\n\n\t \n\n\tdone = (host->page_idx << PAGE_SHIFT) + host->offset;\n\ttotal = host->sg->offset + sg_dma_len(host->sg);\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): %zu of %zu @ %zu\\n\", __func__,\n\t\tdone, total, host->offset);\n\n\tif (done < total && host->offset) {\n\t\t \n\t\tif (host->offset + data->blksz > PAGE_SIZE)\n\t\t\t \n\t\t\tusdhi6_blk_bounce(host, host->sg);\n\n\t\treturn;\n\t}\n\n\t \n\tusdhi6_sg_unmap(host, false);\n\n\tif (done == total) {\n\t\t \n\t\tstruct scatterlist *next = sg_next(host->sg);\n\n\t\thost->page_idx = 0;\n\n\t\tif (!next)\n\t\t\thost->wait = USDHI6_WAIT_FOR_DATA_END;\n\t\thost->sg = next;\n\n\t\tif (WARN(next && sg_dma_len(next) % data->blksz,\n\t\t\t \"SG size %u isn't a multiple of block size %u\\n\",\n\t\t\t sg_dma_len(next), data->blksz))\n\t\t\tdata->error = -EINVAL;\n\n\t\treturn;\n\t}\n\n\t \n\n\t \n\thost->pg.page = nth_page(sg_page(host->sg), host->page_idx);\n\thost->pg.mapped = kmap(host->pg.page);\n\thost->blk_page = host->pg.mapped;\n\n\tdev_dbg(mmc_dev(host->mmc), \"Mapped %p (%lx) at %p for CMD%u @ 0x%p\\n\",\n\t\thost->pg.page, page_to_pfn(host->pg.page), host->pg.mapped,\n\t\thost->mrq->cmd->opcode, host->mrq);\n}\n\n \n\nstatic void usdhi6_dma_release(struct usdhi6_host *host)\n{\n\thost->dma_active = false;\n\tif (host->chan_tx) {\n\t\tstruct dma_chan *chan = host->chan_tx;\n\t\thost->chan_tx = NULL;\n\t\tdma_release_channel(chan);\n\t}\n\tif (host->chan_rx) {\n\t\tstruct dma_chan *chan = host->chan_rx;\n\t\thost->chan_rx = NULL;\n\t\tdma_release_channel(chan);\n\t}\n}\n\nstatic void usdhi6_dma_stop_unmap(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\n\tif (!host->dma_active)\n\t\treturn;\n\n\tusdhi6_write(host, USDHI6_CC_EXT_MODE, 0);\n\thost->dma_active = false;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tdma_unmap_sg(host->chan_rx->device->dev, data->sg,\n\t\t\t     data->sg_len, DMA_FROM_DEVICE);\n\telse\n\t\tdma_unmap_sg(host->chan_tx->device->dev, data->sg,\n\t\t\t     data->sg_len, DMA_TO_DEVICE);\n}\n\nstatic void usdhi6_dma_complete(void *arg)\n{\n\tstruct usdhi6_host *host = arg;\n\tstruct mmc_request *mrq = host->mrq;\n\n\tif (WARN(!mrq || !mrq->data, \"%s: NULL data in DMA completion for %p!\\n\",\n\t\t dev_name(mmc_dev(host->mmc)), mrq))\n\t\treturn;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): CMD%u DMA completed\\n\", __func__,\n\t\tmrq->cmd->opcode);\n\n\tusdhi6_dma_stop_unmap(host);\n\tusdhi6_wait_for_brwe(host, mrq->data->flags & MMC_DATA_READ);\n}\n\nstatic int usdhi6_dma_setup(struct usdhi6_host *host, struct dma_chan *chan,\n\t\t\t    enum dma_transfer_direction dir)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tstruct scatterlist *sg = data->sg;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tdma_cookie_t cookie = -EINVAL;\n\tenum dma_data_direction data_dir;\n\tint ret;\n\n\tswitch (dir) {\n\tcase DMA_MEM_TO_DEV:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase DMA_DEV_TO_MEM:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = dma_map_sg(chan->device->dev, sg, data->sg_len, data_dir);\n\tif (ret > 0) {\n\t\thost->dma_active = true;\n\t\tdesc = dmaengine_prep_slave_sg(chan, sg, ret, dir,\n\t\t\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\t}\n\n\tif (desc) {\n\t\tdesc->callback = usdhi6_dma_complete;\n\t\tdesc->callback_param = host;\n\t\tcookie = dmaengine_submit(desc);\n\t}\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): mapped %d -> %d, cookie %d @ %p\\n\",\n\t\t__func__, data->sg_len, ret, cookie, desc);\n\n\tif (cookie < 0) {\n\t\t \n\t\tif (ret >= 0)\n\t\t\tret = cookie;\n\t\tusdhi6_dma_release(host);\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"DMA failed: %d, falling back to PIO\\n\", ret);\n\t}\n\n\treturn cookie;\n}\n\nstatic int usdhi6_dma_start(struct usdhi6_host *host)\n{\n\tif (!host->chan_rx || !host->chan_tx)\n\t\treturn -ENODEV;\n\n\tif (host->mrq->data->flags & MMC_DATA_READ)\n\t\treturn usdhi6_dma_setup(host, host->chan_rx, DMA_DEV_TO_MEM);\n\n\treturn usdhi6_dma_setup(host, host->chan_tx, DMA_MEM_TO_DEV);\n}\n\nstatic void usdhi6_dma_kill(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): SG of %u: %ux%u\\n\",\n\t\t__func__, data->sg_len, data->blocks, data->blksz);\n\t \n\tif (data->flags & MMC_DATA_READ)\n\t\tdmaengine_terminate_sync(host->chan_rx);\n\telse\n\t\tdmaengine_terminate_sync(host->chan_tx);\n}\n\nstatic void usdhi6_dma_check_error(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): IO error %d, status 0x%x\\n\",\n\t\t__func__, host->io_error, usdhi6_read(host, USDHI6_SD_INFO1));\n\n\tif (host->io_error) {\n\t\tdata->error = usdhi6_error_code(host);\n\t\tdata->bytes_xfered = 0;\n\t\tusdhi6_dma_kill(host);\n\t\tusdhi6_dma_release(host);\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"DMA failed: %d, falling back to PIO\\n\", data->error);\n\t\treturn;\n\t}\n\n\t \n\tif (host->irq_status & USDHI6_SD_INFO1_RSP_END)\n\t\tdev_warn(mmc_dev(host->mmc), \"Unexpected response received!\\n\");\n}\n\nstatic void usdhi6_dma_kick(struct usdhi6_host *host)\n{\n\tif (host->mrq->data->flags & MMC_DATA_READ)\n\t\tdma_async_issue_pending(host->chan_rx);\n\telse\n\t\tdma_async_issue_pending(host->chan_tx);\n}\n\nstatic void usdhi6_dma_request(struct usdhi6_host *host, phys_addr_t start)\n{\n\tstruct dma_slave_config cfg = {\n\t\t.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t\t.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t};\n\tint ret;\n\n\thost->chan_tx = dma_request_chan(mmc_dev(host->mmc), \"tx\");\n\tdev_dbg(mmc_dev(host->mmc), \"%s: TX: got channel %p\\n\", __func__,\n\t\thost->chan_tx);\n\n\tif (IS_ERR(host->chan_tx)) {\n\t\thost->chan_tx = NULL;\n\t\treturn;\n\t}\n\n\tcfg.direction = DMA_MEM_TO_DEV;\n\tcfg.dst_addr = start + USDHI6_SD_BUF0;\n\tcfg.dst_maxburst = 128;\t \n\tcfg.src_addr = 0;\n\tret = dmaengine_slave_config(host->chan_tx, &cfg);\n\tif (ret < 0)\n\t\tgoto e_release_tx;\n\n\thost->chan_rx = dma_request_chan(mmc_dev(host->mmc), \"rx\");\n\tdev_dbg(mmc_dev(host->mmc), \"%s: RX: got channel %p\\n\", __func__,\n\t\thost->chan_rx);\n\n\tif (IS_ERR(host->chan_rx)) {\n\t\thost->chan_rx = NULL;\n\t\tgoto e_release_tx;\n\t}\n\n\tcfg.direction = DMA_DEV_TO_MEM;\n\tcfg.src_addr = cfg.dst_addr;\n\tcfg.src_maxburst = 128;\t \n\tcfg.dst_addr = 0;\n\tret = dmaengine_slave_config(host->chan_rx, &cfg);\n\tif (ret < 0)\n\t\tgoto e_release_rx;\n\n\treturn;\n\ne_release_rx:\n\tdma_release_channel(host->chan_rx);\n\thost->chan_rx = NULL;\ne_release_tx:\n\tdma_release_channel(host->chan_tx);\n\thost->chan_tx = NULL;\n}\n\n \n\nstatic void usdhi6_clk_set(struct usdhi6_host *host, struct mmc_ios *ios)\n{\n\tunsigned long rate = ios->clock;\n\tu32 val;\n\tunsigned int i;\n\n\tfor (i = 1000; i; i--) {\n\t\tif (usdhi6_read(host, USDHI6_SD_INFO2) & USDHI6_SD_INFO2_SCLKDIVEN)\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\n\tif (!i) {\n\t\tdev_err(mmc_dev(host->mmc), \"SD bus busy, clock set aborted\\n\");\n\t\treturn;\n\t}\n\n\tval = usdhi6_read(host, USDHI6_SD_CLK_CTRL) & ~USDHI6_SD_CLK_CTRL_DIV_MASK;\n\n\tif (rate) {\n\t\tunsigned long new_rate;\n\n\t\tif (host->imclk <= rate) {\n\t\t\tif (ios->timing != MMC_TIMING_UHS_DDR50) {\n\t\t\t\t \n\t\t\t\tnew_rate = host->imclk;\n\t\t\t\tval |= 0xff;\n\t\t\t} else {\n\t\t\t\tnew_rate = host->imclk / 2;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned long div =\n\t\t\t\troundup_pow_of_two(DIV_ROUND_UP(host->imclk, rate));\n\t\t\tval |= div >> 2;\n\t\t\tnew_rate = host->imclk / div;\n\t\t}\n\n\t\tif (host->rate == new_rate)\n\t\t\treturn;\n\n\t\thost->rate = new_rate;\n\n\t\tdev_dbg(mmc_dev(host->mmc), \"target %lu, div %u, set %lu\\n\",\n\t\t\trate, (val & 0xff) << 2, new_rate);\n\t}\n\n\t \n\tif (host->imclk == rate || host->imclk == host->rate || !rate)\n\t\tusdhi6_write(host, USDHI6_SD_CLK_CTRL,\n\t\t\t     val & ~USDHI6_SD_CLK_CTRL_SCLKEN);\n\n\tif (!rate) {\n\t\thost->rate = 0;\n\t\treturn;\n\t}\n\n\tusdhi6_write(host, USDHI6_SD_CLK_CTRL, val);\n\n\tif (host->imclk == rate || host->imclk == host->rate ||\n\t    !(val & USDHI6_SD_CLK_CTRL_SCLKEN))\n\t\tusdhi6_write(host, USDHI6_SD_CLK_CTRL,\n\t\t\t     val | USDHI6_SD_CLK_CTRL_SCLKEN);\n}\n\nstatic void usdhi6_set_power(struct usdhi6_host *host, struct mmc_ios *ios)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t \n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc,\n\t\t\t\t      ios->power_mode ? ios->vdd : 0);\n}\n\nstatic int usdhi6_reset(struct usdhi6_host *host)\n{\n\tint i;\n\n\tusdhi6_write(host, USDHI6_SOFT_RST, USDHI6_SOFT_RST_RESERVED);\n\tcpu_relax();\n\tusdhi6_write(host, USDHI6_SOFT_RST, USDHI6_SOFT_RST_RESERVED | USDHI6_SOFT_RST_RESET);\n\tfor (i = 1000; i; i--)\n\t\tif (usdhi6_read(host, USDHI6_SOFT_RST) & USDHI6_SOFT_RST_RESET)\n\t\t\tbreak;\n\n\treturn i ? 0 : -ETIMEDOUT;\n}\n\nstatic void usdhi6_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\tu32 option, mode;\n\tint ret;\n\n\tdev_dbg(mmc_dev(mmc), \"%uHz, OCR: %u, power %u, bus-width %u, timing %u\\n\",\n\t\tios->clock, ios->vdd, ios->power_mode, ios->bus_width, ios->timing);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tusdhi6_set_power(host, ios);\n\t\tusdhi6_only_cd(host);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\t \n\t\tret = usdhi6_reset(host);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"Cannot reset the interface!\\n\");\n\t\t} else {\n\t\t\tusdhi6_set_power(host, ios);\n\t\t\tusdhi6_only_cd(host);\n\t\t}\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\toption = usdhi6_read(host, USDHI6_SD_OPTION);\n\t\t \n\t\tif (ios->bus_width == MMC_BUS_WIDTH_1) {\n\t\t\tif (ios->timing == MMC_TIMING_UHS_DDR50)\n\t\t\t\tdev_err(mmc_dev(mmc),\n\t\t\t\t\t\"4 bits are required for DDR\\n\");\n\t\t\toption |= USDHI6_SD_OPTION_WIDTH_1;\n\t\t\tmode = 0;\n\t\t} else {\n\t\t\toption &= ~USDHI6_SD_OPTION_WIDTH_1;\n\t\t\tmode = ios->timing == MMC_TIMING_UHS_DDR50;\n\t\t}\n\t\tusdhi6_write(host, USDHI6_SD_OPTION, option);\n\t\tusdhi6_write(host, USDHI6_SDIF_MODE, mode);\n\t\tbreak;\n\t}\n\n\tif (host->rate != ios->clock)\n\t\tusdhi6_clk_set(host, ios);\n}\n\n \nstatic void usdhi6_timeout_set(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tu32 val;\n\tunsigned long ticks;\n\n\tif (!mrq->data)\n\t\tticks = host->rate / 1000 * mrq->cmd->busy_timeout;\n\telse\n\t\tticks = host->rate / 1000000 * (mrq->data->timeout_ns / 1000) +\n\t\t\tmrq->data->timeout_clks;\n\n\tif (!ticks || ticks > 1 << 27)\n\t\t \n\t\tval = 14;\n\telse if (ticks < 1 << 13)\n\t\t \n\t\tval = 0;\n\telse\n\t\tval = order_base_2(ticks) - 13;\n\n\tdev_dbg(mmc_dev(host->mmc), \"Set %s timeout %lu ticks @ %lu Hz\\n\",\n\t\tmrq->data ? \"data\" : \"cmd\", ticks, host->rate);\n\n\t \n\tusdhi6_write(host, USDHI6_SD_OPTION, (val << USDHI6_SD_OPTION_TIMEOUT_SHIFT) |\n\t\t     (usdhi6_read(host, USDHI6_SD_OPTION) & ~USDHI6_SD_OPTION_TIMEOUT_MASK));\n}\n\nstatic void usdhi6_request_done(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_data *data = mrq->data;\n\n\tif (WARN(host->pg.page || host->head_pg.page,\n\t\t \"Page %p or %p not unmapped: wait %u, CMD%d(%c) @ +0x%zx %ux%u in SG%u!\\n\",\n\t\t host->pg.page, host->head_pg.page, host->wait, mrq->cmd->opcode,\n\t\t data ? (data->flags & MMC_DATA_READ ? 'R' : 'W') : '-',\n\t\t data ? host->offset : 0, data ? data->blocks : 0,\n\t\t data ? data->blksz : 0, data ? data->sg_len : 0))\n\t\tusdhi6_sg_unmap(host, true);\n\n\tif (mrq->cmd->error ||\n\t    (data && data->error) ||\n\t    (mrq->stop && mrq->stop->error))\n\t\tdev_dbg(mmc_dev(host->mmc), \"%s(CMD%d: %ux%u): err %d %d %d\\n\",\n\t\t\t__func__, mrq->cmd->opcode, data ? data->blocks : 0,\n\t\t\tdata ? data->blksz : 0,\n\t\t\tmrq->cmd->error,\n\t\t\tdata ? data->error : 1,\n\t\t\tmrq->stop ? mrq->stop->error : 1);\n\n\t \n\tusdhi6_write(host, USDHI6_CC_EXT_MODE, 0);\n\thost->wait = USDHI6_WAIT_FOR_REQUEST;\n\thost->mrq = NULL;\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic int usdhi6_cmd_flags(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tu16 opc = cmd->opcode;\n\n\tif (host->app_cmd) {\n\t\thost->app_cmd = false;\n\t\topc |= USDHI6_SD_CMD_APP;\n\t}\n\n\tif (mrq->data) {\n\t\topc |= USDHI6_SD_CMD_DATA;\n\n\t\tif (mrq->data->flags & MMC_DATA_READ)\n\t\t\topc |= USDHI6_SD_CMD_READ;\n\n\t\tif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\n\t\t    cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\n\t\t    (cmd->opcode == SD_IO_RW_EXTENDED &&\n\t\t     mrq->data->blocks > 1)) {\n\t\t\topc |= USDHI6_SD_CMD_MULTI;\n\t\t\tif (!mrq->stop)\n\t\t\t\topc |= USDHI6_SD_CMD_CMD12_AUTO_OFF;\n\t\t}\n\n\t\tswitch (mmc_resp_type(cmd)) {\n\t\tcase MMC_RSP_NONE:\n\t\t\topc |= USDHI6_SD_CMD_MODE_RSP_NONE;\n\t\t\tbreak;\n\t\tcase MMC_RSP_R1:\n\t\t\topc |= USDHI6_SD_CMD_MODE_RSP_R1;\n\t\t\tbreak;\n\t\tcase MMC_RSP_R1B:\n\t\t\topc |= USDHI6_SD_CMD_MODE_RSP_R1B;\n\t\t\tbreak;\n\t\tcase MMC_RSP_R2:\n\t\t\topc |= USDHI6_SD_CMD_MODE_RSP_R2;\n\t\t\tbreak;\n\t\tcase MMC_RSP_R3:\n\t\t\topc |= USDHI6_SD_CMD_MODE_RSP_R3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"Unknown response type %d\\n\",\n\t\t\t\t mmc_resp_type(cmd));\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn opc;\n}\n\nstatic int usdhi6_rq_start(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tint opc = usdhi6_cmd_flags(host);\n\tint i;\n\n\tif (opc < 0)\n\t\treturn opc;\n\n\tfor (i = 1000; i; i--) {\n\t\tif (!(usdhi6_read(host, USDHI6_SD_INFO2) & USDHI6_SD_INFO2_CBSY))\n\t\t\tbreak;\n\t\tusleep_range(10, 100);\n\t}\n\n\tif (!i) {\n\t\tdev_dbg(mmc_dev(host->mmc), \"Command active, request aborted\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tif (data) {\n\t\tbool use_dma;\n\t\tint ret = 0;\n\n\t\thost->page_idx = 0;\n\n\t\tif (cmd->opcode == SD_IO_RW_EXTENDED && data->blocks > 1) {\n\t\t\tswitch (data->blksz) {\n\t\t\tcase 512:\n\t\t\t\tbreak;\n\t\t\tcase 32:\n\t\t\tcase 64:\n\t\t\tcase 128:\n\t\t\tcase 256:\n\t\t\t\tif (mrq->stop)\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t} else if ((cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\n\t\t\t    cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK) &&\n\t\t\t   data->blksz != 512) {\n\t\t\tret = -EINVAL;\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tdev_warn(mmc_dev(host->mmc), \"%s(): %u blocks of %u bytes\\n\",\n\t\t\t\t __func__, data->blocks, data->blksz);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\n\t\t    cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\n\t\t    (cmd->opcode == SD_IO_RW_EXTENDED &&\n\t\t     data->blocks > 1))\n\t\t\tusdhi6_sg_prep(host);\n\n\t\tusdhi6_write(host, USDHI6_SD_SIZE, data->blksz);\n\n\t\tif ((data->blksz >= USDHI6_MIN_DMA ||\n\t\t     data->blocks > 1) &&\n\t\t    (data->blksz % 4 ||\n\t\t     data->sg->offset % 4))\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"Bad SG of %u: %ux%u @ %u\\n\", data->sg_len,\n\t\t\t\tdata->blksz, data->blocks, data->sg->offset);\n\n\t\t \n\t\tuse_dma = data->blksz >= USDHI6_MIN_DMA &&\n\t\t\t!(data->blksz % 4) &&\n\t\t\tusdhi6_dma_start(host) >= DMA_MIN_COOKIE;\n\n\t\tif (use_dma)\n\t\t\tusdhi6_write(host, USDHI6_CC_EXT_MODE, USDHI6_CC_EXT_MODE_SDRW);\n\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"%s(): request opcode %u, %u blocks of %u bytes in %u segments, %s %s @+0x%x%s\\n\",\n\t\t\t__func__, cmd->opcode, data->blocks, data->blksz,\n\t\t\tdata->sg_len, use_dma ? \"DMA\" : \"PIO\",\n\t\t\tdata->flags & MMC_DATA_READ ? \"read\" : \"write\",\n\t\t\tdata->sg->offset, mrq->stop ? \" + stop\" : \"\");\n\t} else {\n\t\tdev_dbg(mmc_dev(host->mmc), \"%s(): request opcode %u\\n\",\n\t\t\t__func__, cmd->opcode);\n\t}\n\n\t \n\tusdhi6_wait_for_resp(host);\n\n\thost->wait = USDHI6_WAIT_FOR_CMD;\n\tschedule_delayed_work(&host->timeout_work, host->timeout);\n\n\t \n\tusdhi6_write(host, USDHI6_SD_STOP,\n\t\t     data && data->blocks > 1 ? USDHI6_SD_STOP_SEC : 0);\n\tusdhi6_write(host, USDHI6_SD_ARG, cmd->arg);\n\n\t \n\tusdhi6_write(host, USDHI6_SD_CMD, opc);\n\n\treturn 0;\n}\n\nstatic void usdhi6_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\tint ret;\n\n\tcancel_delayed_work_sync(&host->timeout_work);\n\n\thost->mrq = mrq;\n\thost->sg = NULL;\n\n\tusdhi6_timeout_set(host);\n\tret = usdhi6_rq_start(host);\n\tif (ret < 0) {\n\t\tmrq->cmd->error = ret;\n\t\tusdhi6_request_done(host);\n\t}\n}\n\nstatic int usdhi6_get_cd(struct mmc_host *mmc)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\t \n\tu32 status = usdhi6_read(host, USDHI6_SD_INFO1) & USDHI6_SD_INFO1_CD;\n\n \n\treturn !status ^ !(mmc->caps2 & MMC_CAP2_CD_ACTIVE_HIGH);\n}\n\nstatic int usdhi6_get_ro(struct mmc_host *mmc)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\t \n\tu32 status = usdhi6_read(host, USDHI6_SD_INFO1) & USDHI6_SD_INFO1_WP;\n\n \n\treturn !status ^ !(mmc->caps2 & MMC_CAP2_RO_ACTIVE_HIGH);\n}\n\nstatic void usdhi6_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\n\tdev_dbg(mmc_dev(mmc), \"%s(): %sable\\n\", __func__, enable ? \"en\" : \"dis\");\n\n\tif (enable) {\n\t\thost->sdio_mask = USDHI6_SDIO_INFO1_IRQ & ~USDHI6_SDIO_INFO1_IOIRQ;\n\t\tusdhi6_write(host, USDHI6_SDIO_INFO1_MASK, host->sdio_mask);\n\t\tusdhi6_write(host, USDHI6_SDIO_MODE, 1);\n\t} else {\n\t\tusdhi6_write(host, USDHI6_SDIO_MODE, 0);\n\t\tusdhi6_write(host, USDHI6_SDIO_INFO1_MASK, USDHI6_SDIO_INFO1_IRQ);\n\t\thost->sdio_mask = USDHI6_SDIO_INFO1_IRQ;\n\t}\n}\n\nstatic int usdhi6_set_pinstates(struct usdhi6_host *host, int voltage)\n{\n\tif (IS_ERR(host->pins_uhs))\n\t\treturn 0;\n\n\tswitch (voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\tcase MMC_SIGNAL_VOLTAGE_120:\n\t\treturn pinctrl_select_state(host->pinctrl,\n\t\t\t\t\t    host->pins_uhs);\n\n\tdefault:\n\t\treturn pinctrl_select_default_state(mmc_dev(host->mmc));\n\t}\n}\n\nstatic int usdhi6_sig_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tint ret;\n\n\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = usdhi6_set_pinstates(mmc_priv(mmc), ios->signal_voltage);\n\tif (ret)\n\t\tdev_warn_once(mmc_dev(mmc),\n\t\t\t      \"Failed to set pinstate err=%d\\n\", ret);\n\treturn ret;\n}\n\nstatic int usdhi6_card_busy(struct mmc_host *mmc)\n{\n\tstruct usdhi6_host *host = mmc_priv(mmc);\n\tu32 tmp = usdhi6_read(host, USDHI6_SD_INFO2);\n\n\t \n\treturn !(tmp & USDHI6_SD_INFO2_SDDAT0);\n}\n\nstatic const struct mmc_host_ops usdhi6_ops = {\n\t.request\t= usdhi6_request,\n\t.set_ios\t= usdhi6_set_ios,\n\t.get_cd\t\t= usdhi6_get_cd,\n\t.get_ro\t\t= usdhi6_get_ro,\n\t.enable_sdio_irq = usdhi6_enable_sdio_irq,\n\t.start_signal_voltage_switch = usdhi6_sig_volt_switch,\n\t.card_busy = usdhi6_card_busy,\n};\n\n \n\nstatic void usdhi6_resp_cmd12(struct usdhi6_host *host)\n{\n\tstruct mmc_command *cmd = host->mrq->stop;\n\tcmd->resp[0] = usdhi6_read(host, USDHI6_SD_RSP10);\n}\n\nstatic void usdhi6_resp_read(struct usdhi6_host *host)\n{\n\tstruct mmc_command *cmd = host->mrq->cmd;\n\tu32 *rsp = cmd->resp, tmp = 0;\n\tint i;\n\n \n\n\tif (mmc_resp_type(cmd) == MMC_RSP_NONE)\n\t\treturn;\n\n\tif (!(host->irq_status & USDHI6_SD_INFO1_RSP_END)) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"CMD%d: response expected but is missing!\\n\", cmd->opcode);\n\t\treturn;\n\t}\n\n\tif (mmc_resp_type(cmd) & MMC_RSP_136)\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tif (i)\n\t\t\t\trsp[3 - i] = tmp >> 24;\n\t\t\ttmp = usdhi6_read(host, USDHI6_SD_RSP10 + i * 8);\n\t\t\trsp[3 - i] |= tmp << 8;\n\t\t}\n\telse if (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\n\t\t cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK)\n\t\t \n\t\trsp[0] = usdhi6_read(host, USDHI6_SD_RSP54);\n\telse\n\t\trsp[0] = usdhi6_read(host, USDHI6_SD_RSP10);\n\n\tdev_dbg(mmc_dev(host->mmc), \"Response 0x%x\\n\", rsp[0]);\n}\n\nstatic int usdhi6_blk_read(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tu32 *p;\n\tint i, rest;\n\n\tif (host->io_error) {\n\t\tdata->error = usdhi6_error_code(host);\n\t\tgoto error;\n\t}\n\n\tif (host->pg.page) {\n\t\tp = host->blk_page + host->offset;\n\t} else {\n\t\tp = usdhi6_sg_map(host);\n\t\tif (!p) {\n\t\t\tdata->error = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < data->blksz / 4; i++, p++)\n\t\t*p = usdhi6_read(host, USDHI6_SD_BUF0);\n\n\trest = data->blksz % 4;\n\tfor (i = 0; i < (rest + 1) / 2; i++) {\n\t\tu16 d = usdhi6_read16(host, USDHI6_SD_BUF0);\n\t\t((u8 *)p)[2 * i] = ((u8 *)&d)[0];\n\t\tif (rest > 1 && !i)\n\t\t\t((u8 *)p)[2 * i + 1] = ((u8 *)&d)[1];\n\t}\n\n\treturn 0;\n\nerror:\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): %d\\n\", __func__, data->error);\n\thost->wait = USDHI6_WAIT_FOR_REQUEST;\n\treturn data->error;\n}\n\nstatic int usdhi6_blk_write(struct usdhi6_host *host)\n{\n\tstruct mmc_data *data = host->mrq->data;\n\tu32 *p;\n\tint i, rest;\n\n\tif (host->io_error) {\n\t\tdata->error = usdhi6_error_code(host);\n\t\tgoto error;\n\t}\n\n\tif (host->pg.page) {\n\t\tp = host->blk_page + host->offset;\n\t} else {\n\t\tp = usdhi6_sg_map(host);\n\t\tif (!p) {\n\t\t\tdata->error = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tfor (i = 0; i < data->blksz / 4; i++, p++)\n\t\tusdhi6_write(host, USDHI6_SD_BUF0, *p);\n\n\trest = data->blksz % 4;\n\tfor (i = 0; i < (rest + 1) / 2; i++) {\n\t\tu16 d;\n\t\t((u8 *)&d)[0] = ((u8 *)p)[2 * i];\n\t\tif (rest > 1 && !i)\n\t\t\t((u8 *)&d)[1] = ((u8 *)p)[2 * i + 1];\n\t\telse\n\t\t\t((u8 *)&d)[1] = 0;\n\t\tusdhi6_write16(host, USDHI6_SD_BUF0, d);\n\t}\n\n\treturn 0;\n\nerror:\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): %d\\n\", __func__, data->error);\n\thost->wait = USDHI6_WAIT_FOR_REQUEST;\n\treturn data->error;\n}\n\nstatic int usdhi6_stop_cmd(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\n\tswitch (mrq->cmd->opcode) {\n\tcase MMC_READ_MULTIPLE_BLOCK:\n\tcase MMC_WRITE_MULTIPLE_BLOCK:\n\t\tif (mrq->stop->opcode == MMC_STOP_TRANSMISSION) {\n\t\t\thost->wait = USDHI6_WAIT_FOR_STOP;\n\t\t\treturn 0;\n\t\t}\n\t\tfallthrough;\t \n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"unsupported stop CMD%d for CMD%d\\n\",\n\t\t\tmrq->stop->opcode, mrq->cmd->opcode);\n\t\tmrq->stop->error = -EOPNOTSUPP;\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic bool usdhi6_end_cmd(struct usdhi6_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_command *cmd = mrq->cmd;\n\n\tif (host->io_error) {\n\t\tcmd->error = usdhi6_error_code(host);\n\t\treturn false;\n\t}\n\n\tusdhi6_resp_read(host);\n\n\tif (!mrq->data)\n\t\treturn false;\n\n\tif (host->dma_active) {\n\t\tusdhi6_dma_kick(host);\n\t\tif (!mrq->stop)\n\t\t\thost->wait = USDHI6_WAIT_FOR_DMA;\n\t\telse if (usdhi6_stop_cmd(host) < 0)\n\t\t\treturn false;\n\t} else if (mrq->data->flags & MMC_DATA_READ) {\n\t\tif (cmd->opcode == MMC_READ_MULTIPLE_BLOCK ||\n\t\t    (cmd->opcode == SD_IO_RW_EXTENDED &&\n\t\t     mrq->data->blocks > 1))\n\t\t\thost->wait = USDHI6_WAIT_FOR_MREAD;\n\t\telse\n\t\t\thost->wait = USDHI6_WAIT_FOR_READ;\n\t} else {\n\t\tif (cmd->opcode == MMC_WRITE_MULTIPLE_BLOCK ||\n\t\t    (cmd->opcode == SD_IO_RW_EXTENDED &&\n\t\t     mrq->data->blocks > 1))\n\t\t\thost->wait = USDHI6_WAIT_FOR_MWRITE;\n\t\telse\n\t\t\thost->wait = USDHI6_WAIT_FOR_WRITE;\n\t}\n\n\treturn true;\n}\n\nstatic bool usdhi6_read_block(struct usdhi6_host *host)\n{\n\t \n\tint ret = usdhi6_blk_read(host);\n\n\t \n\tusdhi6_sg_unmap(host, true);\n\n\tif (ret < 0)\n\t\treturn false;\n\n\thost->wait = USDHI6_WAIT_FOR_DATA_END;\n\treturn true;\n}\n\nstatic bool usdhi6_mread_block(struct usdhi6_host *host)\n{\n\tint ret = usdhi6_blk_read(host);\n\n\tif (ret < 0)\n\t\treturn false;\n\n\tusdhi6_sg_advance(host);\n\n\treturn !host->mrq->data->error &&\n\t\t(host->wait != USDHI6_WAIT_FOR_DATA_END || !host->mrq->stop);\n}\n\nstatic bool usdhi6_write_block(struct usdhi6_host *host)\n{\n\tint ret = usdhi6_blk_write(host);\n\n\t \n\tusdhi6_sg_unmap(host, true);\n\n\tif (ret < 0)\n\t\treturn false;\n\n\thost->wait = USDHI6_WAIT_FOR_DATA_END;\n\treturn true;\n}\n\nstatic bool usdhi6_mwrite_block(struct usdhi6_host *host)\n{\n\tint ret = usdhi6_blk_write(host);\n\n\tif (ret < 0)\n\t\treturn false;\n\n\tusdhi6_sg_advance(host);\n\n\treturn !host->mrq->data->error &&\n\t\t(host->wait != USDHI6_WAIT_FOR_DATA_END || !host->mrq->stop);\n}\n\n \n\nstatic irqreturn_t usdhi6_sd_bh(int irq, void *dev_id)\n{\n\tstruct usdhi6_host *host = dev_id;\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\tbool io_wait = false;\n\n\tcancel_delayed_work_sync(&host->timeout_work);\n\n\tmrq = host->mrq;\n\tif (!mrq)\n\t\treturn IRQ_HANDLED;\n\n\tcmd = mrq->cmd;\n\tdata = mrq->data;\n\n\tswitch (host->wait) {\n\tcase USDHI6_WAIT_FOR_REQUEST:\n\t\t \n\t\treturn IRQ_HANDLED;\n\tcase USDHI6_WAIT_FOR_CMD:\n\t\t \n\t\tio_wait = usdhi6_end_cmd(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_MREAD:\n\t\t \n\t\tio_wait = usdhi6_mread_block(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_READ:\n\t\t \n\t\tio_wait = usdhi6_read_block(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_MWRITE:\n\t\t \n\t\tio_wait = usdhi6_mwrite_block(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_WRITE:\n\t\t \n\t\tio_wait = usdhi6_write_block(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_DMA:\n\t\tusdhi6_dma_check_error(host);\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_STOP:\n\t\tusdhi6_write(host, USDHI6_SD_STOP, 0);\n\t\tif (host->io_error) {\n\t\t\tint ret = usdhi6_error_code(host);\n\t\t\tif (mrq->stop)\n\t\t\t\tmrq->stop->error = ret;\n\t\t\telse\n\t\t\t\tmrq->data->error = ret;\n\t\t\tdev_warn(mmc_dev(host->mmc), \"%s(): %d\\n\", __func__, ret);\n\t\t\tbreak;\n\t\t}\n\t\tusdhi6_resp_cmd12(host);\n\t\tmrq->stop->error = 0;\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_DATA_END:\n\t\tif (host->io_error) {\n\t\t\tmrq->data->error = usdhi6_error_code(host);\n\t\t\tdev_warn(mmc_dev(host->mmc), \"%s(): %d\\n\", __func__,\n\t\t\t\t mrq->data->error);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcmd->error = -EFAULT;\n\t\tdev_err(mmc_dev(host->mmc), \"Invalid state %u\\n\", host->wait);\n\t\tusdhi6_request_done(host);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (io_wait) {\n\t\tschedule_delayed_work(&host->timeout_work, host->timeout);\n\t\t \n\t\tif (!host->dma_active)\n\t\t\tusdhi6_wait_for_brwe(host, mrq->data->flags & MMC_DATA_READ);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (!cmd->error) {\n\t\tif (data) {\n\t\t\tif (!data->error) {\n\t\t\t\tif (host->wait != USDHI6_WAIT_FOR_STOP &&\n\t\t\t\t    host->mrq->stop &&\n\t\t\t\t    !host->mrq->stop->error &&\n\t\t\t\t    !usdhi6_stop_cmd(host)) {\n\t\t\t\t\t \n\t\t\t\t\tusdhi6_wait_for_resp(host);\n\n\t\t\t\t\tschedule_delayed_work(&host->timeout_work,\n\t\t\t\t\t\t\t      host->timeout);\n\n\t\t\t\t\treturn IRQ_HANDLED;\n\t\t\t\t}\n\n\t\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdev_warn(mmc_dev(host->mmc), \"%s(): data error %d\\n\",\n\t\t\t\t\t __func__, data->error);\n\t\t\t\tusdhi6_sg_unmap(host, true);\n\t\t\t}\n\t\t} else if (cmd->opcode == MMC_APP_CMD) {\n\t\t\thost->app_cmd = true;\n\t\t}\n\t}\n\n\tusdhi6_request_done(host);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t usdhi6_sd(int irq, void *dev_id)\n{\n\tstruct usdhi6_host *host = dev_id;\n\tu16 status, status2, error;\n\n\tstatus = usdhi6_read(host, USDHI6_SD_INFO1) & ~host->status_mask &\n\t\t~USDHI6_SD_INFO1_CARD;\n\tstatus2 = usdhi6_read(host, USDHI6_SD_INFO2) & ~host->status2_mask;\n\n\tusdhi6_only_cd(host);\n\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"IRQ status = 0x%08x, status2 = 0x%08x\\n\", status, status2);\n\n\tif (!status && !status2)\n\t\treturn IRQ_NONE;\n\n\terror = status2 & USDHI6_SD_INFO2_ERR;\n\n\t \n\tif (USDHI6_SD_INFO1_IRQ & status)\n\t\tusdhi6_write(host, USDHI6_SD_INFO1,\n\t\t\t     0xffff & ~(USDHI6_SD_INFO1_IRQ & status));\n\n\tif (USDHI6_SD_INFO2_IRQ & status2) {\n\t\tif (error)\n\t\t\t \n\t\t\tstatus2 |= USDHI6_SD_INFO2_BWE | USDHI6_SD_INFO2_BRE;\n\n\t\tusdhi6_write(host, USDHI6_SD_INFO2,\n\t\t\t     0xffff & ~(USDHI6_SD_INFO2_IRQ & status2));\n\t}\n\n\thost->io_error = error;\n\thost->irq_status = status;\n\n\tif (error) {\n\t\t \n\t\tif (host->wait != USDHI6_WAIT_FOR_CMD ||\n\t\t    error != USDHI6_SD_INFO2_RSP_TOUT)\n\t\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t\t \"%s(): INFO2 error bits 0x%08x\\n\",\n\t\t\t\t __func__, error);\n\t\telse\n\t\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"%s(): INFO2 error bits 0x%08x\\n\",\n\t\t\t\t__func__, error);\n\t}\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic irqreturn_t usdhi6_sdio(int irq, void *dev_id)\n{\n\tstruct usdhi6_host *host = dev_id;\n\tu32 status = usdhi6_read(host, USDHI6_SDIO_INFO1) & ~host->sdio_mask;\n\n\tdev_dbg(mmc_dev(host->mmc), \"%s(): status 0x%x\\n\", __func__, status);\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\tusdhi6_write(host, USDHI6_SDIO_INFO1, ~status);\n\n\tmmc_signal_sdio_irq(host->mmc);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t usdhi6_cd(int irq, void *dev_id)\n{\n\tstruct usdhi6_host *host = dev_id;\n\tstruct mmc_host *mmc = host->mmc;\n\tu16 status;\n\n\t \n\tstatus = usdhi6_read(host, USDHI6_SD_INFO1) & ~host->status_mask &\n\t\tUSDHI6_SD_INFO1_CARD;\n\n\tif (!status)\n\t\treturn IRQ_NONE;\n\n\t \n\tusdhi6_write(host, USDHI6_SD_INFO1, ~status);\n\n\tif (!work_pending(&mmc->detect.work) &&\n\t    (((status & USDHI6_SD_INFO1_CARD_INSERT) &&\n\t      !mmc->card) ||\n\t     ((status & USDHI6_SD_INFO1_CARD_EJECT) &&\n\t      mmc->card)))\n\t\tmmc_detect_change(mmc, msecs_to_jiffies(100));\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void usdhi6_timeout_work(struct work_struct *work)\n{\n\tstruct delayed_work *d = to_delayed_work(work);\n\tstruct usdhi6_host *host = container_of(d, struct usdhi6_host, timeout_work);\n\tstruct mmc_request *mrq = host->mrq;\n\tstruct mmc_data *data = mrq ? mrq->data : NULL;\n\tstruct scatterlist *sg;\n\n\tdev_warn(mmc_dev(host->mmc),\n\t\t \"%s timeout wait %u CMD%d: IRQ 0x%08x:0x%08x, last IRQ 0x%08x\\n\",\n\t\t host->dma_active ? \"DMA\" : \"PIO\",\n\t\t host->wait, mrq ? mrq->cmd->opcode : -1,\n\t\t usdhi6_read(host, USDHI6_SD_INFO1),\n\t\t usdhi6_read(host, USDHI6_SD_INFO2), host->irq_status);\n\n\tif (host->dma_active) {\n\t\tusdhi6_dma_kill(host);\n\t\tusdhi6_dma_stop_unmap(host);\n\t}\n\n\tswitch (host->wait) {\n\tdefault:\n\t\tdev_err(mmc_dev(host->mmc), \"Invalid state %u\\n\", host->wait);\n\t\tfallthrough;\t \n\tcase USDHI6_WAIT_FOR_CMD:\n\t\tusdhi6_error_code(host);\n\t\tif (mrq)\n\t\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_STOP:\n\t\tusdhi6_error_code(host);\n\t\tmrq->stop->error = -ETIMEDOUT;\n\t\tbreak;\n\tcase USDHI6_WAIT_FOR_DMA:\n\tcase USDHI6_WAIT_FOR_MREAD:\n\tcase USDHI6_WAIT_FOR_MWRITE:\n\tcase USDHI6_WAIT_FOR_READ:\n\tcase USDHI6_WAIT_FOR_WRITE:\n\t\tsg = host->sg ?: data->sg;\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\"%c: page #%u @ +0x%zx %ux%u in SG%u. Current SG %u bytes @ %u\\n\",\n\t\t\tdata->flags & MMC_DATA_READ ? 'R' : 'W', host->page_idx,\n\t\t\thost->offset, data->blocks, data->blksz, data->sg_len,\n\t\t\tsg_dma_len(sg), sg->offset);\n\t\tusdhi6_sg_unmap(host, true);\n\t\tfallthrough;\t \n\tcase USDHI6_WAIT_FOR_DATA_END:\n\t\tusdhi6_error_code(host);\n\t\tdata->error = -ETIMEDOUT;\n\t}\n\n\tif (mrq)\n\t\tusdhi6_request_done(host);\n}\n\n \n\nstatic const struct of_device_id usdhi6_of_match[] = {\n\t{.compatible = \"renesas,usdhi6rol0\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, usdhi6_of_match);\n\nstatic int usdhi6_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct mmc_host *mmc;\n\tstruct usdhi6_host *host;\n\tstruct resource *res;\n\tint irq_cd, irq_sd, irq_sdio;\n\tu32 version;\n\tint ret;\n\n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\tirq_cd = platform_get_irq_byname(pdev, \"card detect\");\n\tirq_sd = platform_get_irq_byname(pdev, \"data\");\n\tirq_sdio = platform_get_irq_byname(pdev, \"SDIO\");\n\tif (irq_sd < 0)\n\t\treturn irq_sd;\n\tif (irq_sdio < 0)\n\t\treturn irq_sdio;\n\n\tmmc = mmc_alloc_host(sizeof(struct usdhi6_host), dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tret = mmc_regulator_get_supply(mmc);\n\tif (ret)\n\t\tgoto e_free_mmc;\n\n\tret = mmc_of_parse(mmc);\n\tif (ret < 0)\n\t\tgoto e_free_mmc;\n\n\thost\t\t= mmc_priv(mmc);\n\thost->mmc\t= mmc;\n\thost->wait\t= USDHI6_WAIT_FOR_REQUEST;\n\thost->timeout\t= msecs_to_jiffies(USDHI6_REQ_TIMEOUT_MS);\n\t \n\tmmc->max_busy_timeout = USDHI6_REQ_TIMEOUT_MS;\n\n\thost->pinctrl = devm_pinctrl_get(&pdev->dev);\n\tif (IS_ERR(host->pinctrl)) {\n\t\tret = PTR_ERR(host->pinctrl);\n\t\tgoto e_free_mmc;\n\t}\n\n\thost->pins_uhs = pinctrl_lookup_state(host->pinctrl, \"state_uhs\");\n\n\thost->base = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto e_free_mmc;\n\t}\n\n\thost->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tret = PTR_ERR(host->clk);\n\t\tgoto e_free_mmc;\n\t}\n\n\thost->imclk = clk_get_rate(host->clk);\n\n\tret = clk_prepare_enable(host->clk);\n\tif (ret < 0)\n\t\tgoto e_free_mmc;\n\n\tversion = usdhi6_read(host, USDHI6_VERSION);\n\tif ((version & 0xfff) != 0xa0d) {\n\t\tret = -EPERM;\n\t\tdev_err(dev, \"Version not recognized %x\\n\", version);\n\t\tgoto e_clk_off;\n\t}\n\n\tdev_info(dev, \"A USDHI6ROL0 SD host detected with %d ports\\n\",\n\t\t usdhi6_read(host, USDHI6_SD_PORT_SEL) >> USDHI6_SD_PORT_SEL_PORTS_SHIFT);\n\n\tusdhi6_mask_all(host);\n\n\tif (irq_cd >= 0) {\n\t\tret = devm_request_irq(dev, irq_cd, usdhi6_cd, 0,\n\t\t\t\t       dev_name(dev), host);\n\t\tif (ret < 0)\n\t\t\tgoto e_clk_off;\n\t} else {\n\t\tmmc->caps |= MMC_CAP_NEEDS_POLL;\n\t}\n\n\tret = devm_request_threaded_irq(dev, irq_sd, usdhi6_sd, usdhi6_sd_bh, 0,\n\t\t\t       dev_name(dev), host);\n\tif (ret < 0)\n\t\tgoto e_clk_off;\n\n\tret = devm_request_irq(dev, irq_sdio, usdhi6_sdio, 0,\n\t\t\t       dev_name(dev), host);\n\tif (ret < 0)\n\t\tgoto e_clk_off;\n\n\tINIT_DELAYED_WORK(&host->timeout_work, usdhi6_timeout_work);\n\n\tusdhi6_dma_request(host, res->start);\n\n\tmmc->ops = &usdhi6_ops;\n\tmmc->caps |= MMC_CAP_SD_HIGHSPEED | MMC_CAP_MMC_HIGHSPEED |\n\t\t     MMC_CAP_SDIO_IRQ;\n\t \n\tmmc->max_segs = 32;\n\tmmc->max_blk_size = 512;\n\tmmc->max_req_size = PAGE_SIZE * mmc->max_segs;\n\tmmc->max_blk_count = mmc->max_req_size / mmc->max_blk_size;\n\t \n\tmmc->max_seg_size = mmc->max_req_size;\n\tif (!mmc->f_max)\n\t\tmmc->f_max = host->imclk;\n\tmmc->f_min = host->imclk / 512;\n\n\tplatform_set_drvdata(pdev, host);\n\n\tret = mmc_add_host(mmc);\n\tif (ret < 0)\n\t\tgoto e_release_dma;\n\n\treturn 0;\n\ne_release_dma:\n\tusdhi6_dma_release(host);\ne_clk_off:\n\tclk_disable_unprepare(host->clk);\ne_free_mmc:\n\tmmc_free_host(mmc);\n\n\treturn ret;\n}\n\nstatic void usdhi6_remove(struct platform_device *pdev)\n{\n\tstruct usdhi6_host *host = platform_get_drvdata(pdev);\n\n\tmmc_remove_host(host->mmc);\n\n\tusdhi6_mask_all(host);\n\tcancel_delayed_work_sync(&host->timeout_work);\n\tusdhi6_dma_release(host);\n\tclk_disable_unprepare(host->clk);\n\tmmc_free_host(host->mmc);\n}\n\nstatic struct platform_driver usdhi6_driver = {\n\t.probe\t\t= usdhi6_probe,\n\t.remove_new\t= usdhi6_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"usdhi6rol0\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = usdhi6_of_match,\n\t},\n};\n\nmodule_platform_driver(usdhi6_driver);\n\nMODULE_DESCRIPTION(\"Renesas usdhi6rol0 SD/SDIO host driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:usdhi6rol0\");\nMODULE_AUTHOR(\"Guennadi Liakhovetski <g.liakhovetski@gmx.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}