{
  "module_name": "tifm_sd.c",
  "hash_id": "79de439e57d18e5d1da991ccc9ae0893359f979fc6f813735f1530193d0a4617",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/tifm_sd.c",
  "human_readable_source": "\n \n\n\n#include <linux/tifm.h>\n#include <linux/mmc/host.h>\n#include <linux/highmem.h>\n#include <linux/scatterlist.h>\n#include <linux/module.h>\n#include <asm/io.h>\n\n#define DRIVER_NAME \"tifm_sd\"\n#define DRIVER_VERSION \"0.8\"\n\nstatic bool no_dma = 0;\nstatic bool fixed_timeout = 0;\nmodule_param(no_dma, bool, 0644);\nmodule_param(fixed_timeout, bool, 0644);\n\n \n#define TIFM_MMCSD_RESET      0x0002\n#define TIFM_MMCSD_CLKMASK    0x03ff\n#define TIFM_MMCSD_POWER      0x0800\n#define TIFM_MMCSD_4BBUS      0x8000\n#define TIFM_MMCSD_RXDE       0x8000    \n#define TIFM_MMCSD_TXDE       0x0080    \n#define TIFM_MMCSD_BUFINT     0x0c00    \n#define TIFM_MMCSD_DPE        0x0020    \n#define TIFM_MMCSD_INAB       0x0080    \n#define TIFM_MMCSD_READ       0x8000\n\n#define TIFM_MMCSD_ERRMASK    0x01e0    \n#define TIFM_MMCSD_EOC        0x0001    \n#define TIFM_MMCSD_CD         0x0002    \n#define TIFM_MMCSD_CB         0x0004    \n#define TIFM_MMCSD_BRS        0x0008    \n#define TIFM_MMCSD_EOFB       0x0010    \n#define TIFM_MMCSD_DTO        0x0020    \n#define TIFM_MMCSD_DCRC       0x0040    \n#define TIFM_MMCSD_CTO        0x0080    \n#define TIFM_MMCSD_CCRC       0x0100    \n#define TIFM_MMCSD_AF         0x0400    \n#define TIFM_MMCSD_AE         0x0800    \n#define TIFM_MMCSD_OCRB       0x1000    \n#define TIFM_MMCSD_CIRQ       0x2000    \n#define TIFM_MMCSD_CERR       0x4000    \n\n#define TIFM_MMCSD_ODTO       0x0040    \n#define TIFM_MMCSD_CARD_RO    0x0200    \n\n#define TIFM_MMCSD_FIFO_SIZE  0x0020\n\n#define TIFM_MMCSD_RSP_R0     0x0000\n#define TIFM_MMCSD_RSP_R1     0x0100\n#define TIFM_MMCSD_RSP_R2     0x0200\n#define TIFM_MMCSD_RSP_R3     0x0300\n#define TIFM_MMCSD_RSP_R4     0x0400\n#define TIFM_MMCSD_RSP_R5     0x0500\n#define TIFM_MMCSD_RSP_R6     0x0600\n\n#define TIFM_MMCSD_RSP_BUSY   0x0800\n\n#define TIFM_MMCSD_CMD_BC     0x0000\n#define TIFM_MMCSD_CMD_BCR    0x1000\n#define TIFM_MMCSD_CMD_AC     0x2000\n#define TIFM_MMCSD_CMD_ADTC   0x3000\n\n#define TIFM_MMCSD_MAX_BLOCK_SIZE  0x0800UL\n\n#define TIFM_MMCSD_REQ_TIMEOUT_MS  1000\n\nenum {\n\tCMD_READY    = 0x0001,\n\tFIFO_READY   = 0x0002,\n\tBRS_READY    = 0x0004,\n\tSCMD_ACTIVE  = 0x0008,\n\tSCMD_READY   = 0x0010,\n\tCARD_BUSY    = 0x0020,\n\tDATA_CARRY   = 0x0040\n};\n\nstruct tifm_sd {\n\tstruct tifm_dev       *dev;\n\n\tunsigned short        eject:1,\n\t\t\t      open_drain:1,\n\t\t\t      no_dma:1;\n\tunsigned short        cmd_flags;\n\n\tunsigned int          clk_freq;\n\tunsigned int          clk_div;\n\tunsigned long         timeout_jiffies;\n\n\tstruct tasklet_struct finish_tasklet;\n\tstruct timer_list     timer;\n\tstruct mmc_request    *req;\n\n\tint                   sg_len;\n\tint                   sg_pos;\n\tunsigned int          block_pos;\n\tstruct scatterlist    bounce_buf;\n\tunsigned char         bounce_buf_data[TIFM_MMCSD_MAX_BLOCK_SIZE];\n};\n\n \nstatic void tifm_sd_read_fifo(struct tifm_sd *host, struct page *pg,\n\t\t\t      unsigned int off, unsigned int cnt)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned char *buf;\n\tunsigned int pos = 0, val;\n\n\tbuf = kmap_local_page(pg) + off;\n\tif (host->cmd_flags & DATA_CARRY) {\n\t\tbuf[pos++] = host->bounce_buf_data[0];\n\t\thost->cmd_flags &= ~DATA_CARRY;\n\t}\n\n\twhile (pos < cnt) {\n\t\tval = readl(sock->addr + SOCK_MMCSD_DATA);\n\t\tbuf[pos++] = val & 0xff;\n\t\tif (pos == cnt) {\n\t\t\thost->bounce_buf_data[0] = (val >> 8) & 0xff;\n\t\t\thost->cmd_flags |= DATA_CARRY;\n\t\t\tbreak;\n\t\t}\n\t\tbuf[pos++] = (val >> 8) & 0xff;\n\t}\n\tkunmap_local(buf - off);\n}\n\nstatic void tifm_sd_write_fifo(struct tifm_sd *host, struct page *pg,\n\t\t\t       unsigned int off, unsigned int cnt)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned char *buf;\n\tunsigned int pos = 0, val;\n\n\tbuf = kmap_local_page(pg) + off;\n\tif (host->cmd_flags & DATA_CARRY) {\n\t\tval = host->bounce_buf_data[0] | ((buf[pos++] << 8) & 0xff00);\n\t\twritel(val, sock->addr + SOCK_MMCSD_DATA);\n\t\thost->cmd_flags &= ~DATA_CARRY;\n\t}\n\n\twhile (pos < cnt) {\n\t\tval = buf[pos++];\n\t\tif (pos == cnt) {\n\t\t\thost->bounce_buf_data[0] = val & 0xff;\n\t\t\thost->cmd_flags |= DATA_CARRY;\n\t\t\tbreak;\n\t\t}\n\t\tval |= (buf[pos++] << 8) & 0xff00;\n\t\twritel(val, sock->addr + SOCK_MMCSD_DATA);\n\t}\n\tkunmap_local(buf - off);\n}\n\nstatic void tifm_sd_transfer_data(struct tifm_sd *host)\n{\n\tstruct mmc_data *r_data = host->req->cmd->data;\n\tstruct scatterlist *sg = r_data->sg;\n\tunsigned int off, cnt, t_size = TIFM_MMCSD_FIFO_SIZE * 2;\n\tunsigned int p_off, p_cnt;\n\tstruct page *pg;\n\n\tif (host->sg_pos == host->sg_len)\n\t\treturn;\n\twhile (t_size) {\n\t\tcnt = sg[host->sg_pos].length - host->block_pos;\n\t\tif (!cnt) {\n\t\t\thost->block_pos = 0;\n\t\t\thost->sg_pos++;\n\t\t\tif (host->sg_pos == host->sg_len) {\n\t\t\t\tif ((r_data->flags & MMC_DATA_WRITE)\n\t\t\t\t    && (host->cmd_flags & DATA_CARRY))\n\t\t\t\t\twritel(host->bounce_buf_data[0],\n\t\t\t\t\t       host->dev->addr\n\t\t\t\t\t       + SOCK_MMCSD_DATA);\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcnt = sg[host->sg_pos].length;\n\t\t}\n\t\toff = sg[host->sg_pos].offset + host->block_pos;\n\n\t\tpg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);\n\t\tp_off = offset_in_page(off);\n\t\tp_cnt = PAGE_SIZE - p_off;\n\t\tp_cnt = min(p_cnt, cnt);\n\t\tp_cnt = min(p_cnt, t_size);\n\n\t\tif (r_data->flags & MMC_DATA_READ)\n\t\t\ttifm_sd_read_fifo(host, pg, p_off, p_cnt);\n\t\telse if (r_data->flags & MMC_DATA_WRITE)\n\t\t\ttifm_sd_write_fifo(host, pg, p_off, p_cnt);\n\n\t\tt_size -= p_cnt;\n\t\thost->block_pos += p_cnt;\n\t}\n}\n\nstatic void tifm_sd_copy_page(struct page *dst, unsigned int dst_off,\n\t\t\t      struct page *src, unsigned int src_off,\n\t\t\t      unsigned int count)\n{\n\tunsigned char *src_buf = kmap_local_page(src) + src_off;\n\tunsigned char *dst_buf = kmap_local_page(dst) + dst_off;\n\n\tmemcpy(dst_buf, src_buf, count);\n\n\tkunmap_local(dst_buf - dst_off);\n\tkunmap_local(src_buf - src_off);\n}\n\nstatic void tifm_sd_bounce_block(struct tifm_sd *host, struct mmc_data *r_data)\n{\n\tstruct scatterlist *sg = r_data->sg;\n\tunsigned int t_size = r_data->blksz;\n\tunsigned int off, cnt;\n\tunsigned int p_off, p_cnt;\n\tstruct page *pg;\n\n\tdev_dbg(&host->dev->dev, \"bouncing block\\n\");\n\twhile (t_size) {\n\t\tcnt = sg[host->sg_pos].length - host->block_pos;\n\t\tif (!cnt) {\n\t\t\thost->block_pos = 0;\n\t\t\thost->sg_pos++;\n\t\t\tif (host->sg_pos == host->sg_len)\n\t\t\t\treturn;\n\t\t\tcnt = sg[host->sg_pos].length;\n\t\t}\n\t\toff = sg[host->sg_pos].offset + host->block_pos;\n\n\t\tpg = nth_page(sg_page(&sg[host->sg_pos]), off >> PAGE_SHIFT);\n\t\tp_off = offset_in_page(off);\n\t\tp_cnt = PAGE_SIZE - p_off;\n\t\tp_cnt = min(p_cnt, cnt);\n\t\tp_cnt = min(p_cnt, t_size);\n\n\t\tif (r_data->flags & MMC_DATA_WRITE)\n\t\t\ttifm_sd_copy_page(sg_page(&host->bounce_buf),\n\t\t\t\t\t  r_data->blksz - t_size,\n\t\t\t\t\t  pg, p_off, p_cnt);\n\t\telse if (r_data->flags & MMC_DATA_READ)\n\t\t\ttifm_sd_copy_page(pg, p_off, sg_page(&host->bounce_buf),\n\t\t\t\t\t  r_data->blksz - t_size, p_cnt);\n\n\t\tt_size -= p_cnt;\n\t\thost->block_pos += p_cnt;\n\t}\n}\n\nstatic int tifm_sd_set_dma_data(struct tifm_sd *host, struct mmc_data *r_data)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int t_size = TIFM_DMA_TSIZE * r_data->blksz;\n\tunsigned int dma_len, dma_blk_cnt, dma_off;\n\tstruct scatterlist *sg = NULL;\n\n\tif (host->sg_pos == host->sg_len)\n\t\treturn 1;\n\n\tif (host->cmd_flags & DATA_CARRY) {\n\t\thost->cmd_flags &= ~DATA_CARRY;\n\t\ttifm_sd_bounce_block(host, r_data);\n\t\tif (host->sg_pos == host->sg_len)\n\t\t\treturn 1;\n\t}\n\n\tdma_len = sg_dma_len(&r_data->sg[host->sg_pos]) - host->block_pos;\n\tif (!dma_len) {\n\t\thost->block_pos = 0;\n\t\thost->sg_pos++;\n\t\tif (host->sg_pos == host->sg_len)\n\t\t\treturn 1;\n\t\tdma_len = sg_dma_len(&r_data->sg[host->sg_pos]);\n\t}\n\n\tif (dma_len < t_size) {\n\t\tdma_blk_cnt = dma_len / r_data->blksz;\n\t\tdma_off = host->block_pos;\n\t\thost->block_pos += dma_blk_cnt * r_data->blksz;\n\t} else {\n\t\tdma_blk_cnt = TIFM_DMA_TSIZE;\n\t\tdma_off = host->block_pos;\n\t\thost->block_pos += t_size;\n\t}\n\n\tif (dma_blk_cnt)\n\t\tsg = &r_data->sg[host->sg_pos];\n\telse if (dma_len) {\n\t\tif (r_data->flags & MMC_DATA_WRITE)\n\t\t\ttifm_sd_bounce_block(host, r_data);\n\t\telse\n\t\t\thost->cmd_flags |= DATA_CARRY;\n\n\t\tsg = &host->bounce_buf;\n\t\tdma_off = 0;\n\t\tdma_blk_cnt = 1;\n\t} else\n\t\treturn 1;\n\n\tdev_dbg(&sock->dev, \"setting dma for %d blocks\\n\", dma_blk_cnt);\n\twritel(sg_dma_address(sg) + dma_off, sock->addr + SOCK_DMA_ADDRESS);\n\tif (r_data->flags & MMC_DATA_WRITE)\n\t\twritel((dma_blk_cnt << 8) | TIFM_DMA_TX | TIFM_DMA_EN,\n\t\t       sock->addr + SOCK_DMA_CONTROL);\n\telse\n\t\twritel((dma_blk_cnt << 8) | TIFM_DMA_EN,\n\t\t       sock->addr + SOCK_DMA_CONTROL);\n\n\treturn 0;\n}\n\nstatic unsigned int tifm_sd_op_flags(struct mmc_command *cmd)\n{\n\tunsigned int rc = 0;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\trc |= TIFM_MMCSD_RSP_R0;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\trc |= TIFM_MMCSD_RSP_BUSY;\n\t\tfallthrough;\n\tcase MMC_RSP_R1:\n\t\trc |= TIFM_MMCSD_RSP_R1;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\trc |= TIFM_MMCSD_RSP_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\trc |= TIFM_MMCSD_RSP_R3;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tswitch (mmc_cmd_type(cmd)) {\n\tcase MMC_CMD_BC:\n\t\trc |= TIFM_MMCSD_CMD_BC;\n\t\tbreak;\n\tcase MMC_CMD_BCR:\n\t\trc |= TIFM_MMCSD_CMD_BCR;\n\t\tbreak;\n\tcase MMC_CMD_AC:\n\t\trc |= TIFM_MMCSD_CMD_AC;\n\t\tbreak;\n\tcase MMC_CMD_ADTC:\n\t\trc |= TIFM_MMCSD_CMD_ADTC;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\treturn rc;\n}\n\nstatic void tifm_sd_exec(struct tifm_sd *host, struct mmc_command *cmd)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int cmd_mask = tifm_sd_op_flags(cmd);\n\n\tif (host->open_drain)\n\t\tcmd_mask |= TIFM_MMCSD_ODTO;\n\n\tif (cmd->data && (cmd->data->flags & MMC_DATA_READ))\n\t\tcmd_mask |= TIFM_MMCSD_READ;\n\n\tdev_dbg(&sock->dev, \"executing opcode 0x%x, arg: 0x%x, mask: 0x%x\\n\",\n\t\tcmd->opcode, cmd->arg, cmd_mask);\n\n\twritel((cmd->arg >> 16) & 0xffff, sock->addr + SOCK_MMCSD_ARG_HIGH);\n\twritel(cmd->arg & 0xffff, sock->addr + SOCK_MMCSD_ARG_LOW);\n\twritel(cmd->opcode | cmd_mask, sock->addr + SOCK_MMCSD_COMMAND);\n}\n\nstatic void tifm_sd_fetch_resp(struct mmc_command *cmd, struct tifm_dev *sock)\n{\n\tcmd->resp[0] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x1c) << 16)\n\t\t       | readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x18);\n\tcmd->resp[1] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x14) << 16)\n\t\t       | readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x10);\n\tcmd->resp[2] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x0c) << 16)\n\t\t       | readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x08);\n\tcmd->resp[3] = (readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x04) << 16)\n\t\t       | readl(sock->addr + SOCK_MMCSD_RESPONSE + 0x00);\n}\n\nstatic void tifm_sd_check_status(struct tifm_sd *host)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tstruct mmc_command *cmd = host->req->cmd;\n\n\tif (cmd->error)\n\t\tgoto finish_request;\n\n\tif (!(host->cmd_flags & CMD_READY))\n\t\treturn;\n\n\tif (cmd->data) {\n\t\tif (cmd->data->error) {\n\t\t\tif ((host->cmd_flags & SCMD_ACTIVE)\n\t\t\t    && !(host->cmd_flags & SCMD_READY))\n\t\t\t\treturn;\n\n\t\t\tgoto finish_request;\n\t\t}\n\n\t\tif (!(host->cmd_flags & BRS_READY))\n\t\t\treturn;\n\n\t\tif (!(host->no_dma || (host->cmd_flags & FIFO_READY)))\n\t\t\treturn;\n\n\t\tif (cmd->data->flags & MMC_DATA_WRITE) {\n\t\t\tif (host->req->stop) {\n\t\t\t\tif (!(host->cmd_flags & SCMD_ACTIVE)) {\n\t\t\t\t\thost->cmd_flags |= SCMD_ACTIVE;\n\t\t\t\t\twritel(TIFM_MMCSD_EOFB\n\t\t\t\t\t       | readl(sock->addr\n\t\t\t\t\t\t       + SOCK_MMCSD_INT_ENABLE),\n\t\t\t\t\t       sock->addr\n\t\t\t\t\t       + SOCK_MMCSD_INT_ENABLE);\n\t\t\t\t\ttifm_sd_exec(host, host->req->stop);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif (!(host->cmd_flags & SCMD_READY)\n\t\t\t\t\t    || (host->cmd_flags & CARD_BUSY))\n\t\t\t\t\t\treturn;\n\t\t\t\t\twritel((~TIFM_MMCSD_EOFB)\n\t\t\t\t\t       & readl(sock->addr\n\t\t\t\t\t\t       + SOCK_MMCSD_INT_ENABLE),\n\t\t\t\t\t       sock->addr\n\t\t\t\t\t       + SOCK_MMCSD_INT_ENABLE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (host->cmd_flags & CARD_BUSY)\n\t\t\t\t\treturn;\n\t\t\t\twritel((~TIFM_MMCSD_EOFB)\n\t\t\t\t       & readl(sock->addr\n\t\t\t\t\t       + SOCK_MMCSD_INT_ENABLE),\n\t\t\t\t       sock->addr + SOCK_MMCSD_INT_ENABLE);\n\t\t\t}\n\t\t} else {\n\t\t\tif (host->req->stop) {\n\t\t\t\tif (!(host->cmd_flags & SCMD_ACTIVE)) {\n\t\t\t\t\thost->cmd_flags |= SCMD_ACTIVE;\n\t\t\t\t\ttifm_sd_exec(host, host->req->stop);\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tif (!(host->cmd_flags & SCMD_READY))\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nfinish_request:\n\ttasklet_schedule(&host->finish_tasklet);\n}\n\n \nstatic void tifm_sd_data_event(struct tifm_dev *sock)\n{\n\tstruct tifm_sd *host;\n\tunsigned int fifo_status = 0;\n\tstruct mmc_data *r_data = NULL;\n\n\tspin_lock(&sock->lock);\n\thost = mmc_priv((struct mmc_host*)tifm_get_drvdata(sock));\n\tfifo_status = readl(sock->addr + SOCK_DMA_FIFO_STATUS);\n\tdev_dbg(&sock->dev, \"data event: fifo_status %x, flags %x\\n\",\n\t\tfifo_status, host->cmd_flags);\n\n\tif (host->req) {\n\t\tr_data = host->req->cmd->data;\n\n\t\tif (r_data && (fifo_status & TIFM_FIFO_READY)) {\n\t\t\tif (tifm_sd_set_dma_data(host, r_data)) {\n\t\t\t\thost->cmd_flags |= FIFO_READY;\n\t\t\t\ttifm_sd_check_status(host);\n\t\t\t}\n\t\t}\n\t}\n\n\twritel(fifo_status, sock->addr + SOCK_DMA_FIFO_STATUS);\n\tspin_unlock(&sock->lock);\n}\n\n \nstatic void tifm_sd_card_event(struct tifm_dev *sock)\n{\n\tstruct tifm_sd *host;\n\tunsigned int host_status = 0;\n\tint cmd_error = 0;\n\tstruct mmc_command *cmd = NULL;\n\n\tspin_lock(&sock->lock);\n\thost = mmc_priv((struct mmc_host*)tifm_get_drvdata(sock));\n\thost_status = readl(sock->addr + SOCK_MMCSD_STATUS);\n\tdev_dbg(&sock->dev, \"host event: host_status %x, flags %x\\n\",\n\t\thost_status, host->cmd_flags);\n\n\tif (host->req) {\n\t\tcmd = host->req->cmd;\n\n\t\tif (host_status & TIFM_MMCSD_ERRMASK) {\n\t\t\twritel(host_status & TIFM_MMCSD_ERRMASK,\n\t\t\t       sock->addr + SOCK_MMCSD_STATUS);\n\t\t\tif (host_status & TIFM_MMCSD_CTO)\n\t\t\t\tcmd_error = -ETIMEDOUT;\n\t\t\telse if (host_status & TIFM_MMCSD_CCRC)\n\t\t\t\tcmd_error = -EILSEQ;\n\n\t\t\tif (cmd->data) {\n\t\t\t\tif (host_status & TIFM_MMCSD_DTO)\n\t\t\t\t\tcmd->data->error = -ETIMEDOUT;\n\t\t\t\telse if (host_status & TIFM_MMCSD_DCRC)\n\t\t\t\t\tcmd->data->error = -EILSEQ;\n\t\t\t}\n\n\t\t\twritel(TIFM_FIFO_INT_SETALL,\n\t\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\t\t\twritel(TIFM_DMA_RESET, sock->addr + SOCK_DMA_CONTROL);\n\n\t\t\tif (host->req->stop) {\n\t\t\t\tif (host->cmd_flags & SCMD_ACTIVE) {\n\t\t\t\t\thost->req->stop->error = cmd_error;\n\t\t\t\t\thost->cmd_flags |= SCMD_READY;\n\t\t\t\t} else {\n\t\t\t\t\tcmd->error = cmd_error;\n\t\t\t\t\thost->cmd_flags |= SCMD_ACTIVE;\n\t\t\t\t\ttifm_sd_exec(host, host->req->stop);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tcmd->error = cmd_error;\n\t\t} else {\n\t\t\tif (host_status & (TIFM_MMCSD_EOC | TIFM_MMCSD_CERR)) {\n\t\t\t\tif (!(host->cmd_flags & CMD_READY)) {\n\t\t\t\t\thost->cmd_flags |= CMD_READY;\n\t\t\t\t\ttifm_sd_fetch_resp(cmd, sock);\n\t\t\t\t} else if (host->cmd_flags & SCMD_ACTIVE) {\n\t\t\t\t\thost->cmd_flags |= SCMD_READY;\n\t\t\t\t\ttifm_sd_fetch_resp(host->req->stop,\n\t\t\t\t\t\t\t   sock);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (host_status & TIFM_MMCSD_BRS)\n\t\t\t\thost->cmd_flags |= BRS_READY;\n\t\t}\n\n\t\tif (host->no_dma && cmd->data) {\n\t\t\tif (host_status & TIFM_MMCSD_AE)\n\t\t\t\twritel(host_status & TIFM_MMCSD_AE,\n\t\t\t\t       sock->addr + SOCK_MMCSD_STATUS);\n\n\t\t\tif (host_status & (TIFM_MMCSD_AE | TIFM_MMCSD_AF\n\t\t\t\t\t   | TIFM_MMCSD_BRS)) {\n\t\t\t\ttifm_sd_transfer_data(host);\n\t\t\t\thost_status &= ~TIFM_MMCSD_AE;\n\t\t\t}\n\t\t}\n\n\t\tif (host_status & TIFM_MMCSD_EOFB)\n\t\t\thost->cmd_flags &= ~CARD_BUSY;\n\t\telse if (host_status & TIFM_MMCSD_CB)\n\t\t\thost->cmd_flags |= CARD_BUSY;\n\n\t\ttifm_sd_check_status(host);\n\t}\ndone:\n\twritel(host_status, sock->addr + SOCK_MMCSD_STATUS);\n\tspin_unlock(&sock->lock);\n}\n\nstatic void tifm_sd_set_data_timeout(struct tifm_sd *host,\n\t\t\t\t     struct mmc_data *data)\n{\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int data_timeout = data->timeout_clks;\n\n\tif (fixed_timeout)\n\t\treturn;\n\n\tdata_timeout += data->timeout_ns /\n\t\t\t((1000000000UL / host->clk_freq) * host->clk_div);\n\n\tif (data_timeout < 0xffff) {\n\t\twritel(data_timeout, sock->addr + SOCK_MMCSD_DATA_TO);\n\t\twritel((~TIFM_MMCSD_DPE)\n\t\t       & readl(sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG),\n\t\t       sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG);\n\t} else {\n\t\tdata_timeout = (data_timeout >> 10) + 1;\n\t\tif (data_timeout > 0xffff)\n\t\t\tdata_timeout = 0;\t \n\t\twritel(data_timeout, sock->addr + SOCK_MMCSD_DATA_TO);\n\t\twritel(TIFM_MMCSD_DPE\n\t\t       | readl(sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG),\n\t\t       sock->addr + SOCK_MMCSD_SDIO_MODE_CONFIG);\n\t}\n}\n\nstatic void tifm_sd_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct tifm_sd *host = mmc_priv(mmc);\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned long flags;\n\tstruct mmc_data *r_data = mrq->cmd->data;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\tif (host->eject) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tgoto err_out;\n\t}\n\n\tif (host->req) {\n\t\tpr_err(\"%s : unfinished request detected\\n\",\n\t\t       dev_name(&sock->dev));\n\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\tgoto err_out;\n\t}\n\n\thost->cmd_flags = 0;\n\thost->block_pos = 0;\n\thost->sg_pos = 0;\n\n\tif (mrq->data && !is_power_of_2(mrq->data->blksz))\n\t\thost->no_dma = 1;\n\telse\n\t\thost->no_dma = no_dma ? 1 : 0;\n\n\tif (r_data) {\n\t\ttifm_sd_set_data_timeout(host, r_data);\n\n\t\tif ((r_data->flags & MMC_DATA_WRITE) && !mrq->stop)\n\t\t\t writel(TIFM_MMCSD_EOFB\n\t\t\t\t| readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\n\t\t\t\tsock->addr + SOCK_MMCSD_INT_ENABLE);\n\n\t\tif (host->no_dma) {\n\t\t\twritel(TIFM_MMCSD_BUFINT\n\t\t\t       | readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\n\t\t\t       sock->addr + SOCK_MMCSD_INT_ENABLE);\n\t\t\twritel(((TIFM_MMCSD_FIFO_SIZE - 1) << 8)\n\t\t\t       | (TIFM_MMCSD_FIFO_SIZE - 1),\n\t\t\t       sock->addr + SOCK_MMCSD_BUFFER_CONFIG);\n\n\t\t\thost->sg_len = r_data->sg_len;\n\t\t} else {\n\t\t\tsg_init_one(&host->bounce_buf, host->bounce_buf_data,\n\t\t\t\t    r_data->blksz);\n\n\t\t\tif(1 != tifm_map_sg(sock, &host->bounce_buf, 1,\n\t\t\t\t\t    r_data->flags & MMC_DATA_WRITE\n\t\t\t\t\t    ? DMA_TO_DEVICE\n\t\t\t\t\t    : DMA_FROM_DEVICE)) {\n\t\t\t\tpr_err(\"%s : scatterlist map failed\\n\",\n\t\t\t\t       dev_name(&sock->dev));\n\t\t\t\tmrq->cmd->error = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\thost->sg_len = tifm_map_sg(sock, r_data->sg,\n\t\t\t\t\t\t   r_data->sg_len,\n\t\t\t\t\t\t   r_data->flags\n\t\t\t\t\t\t   & MMC_DATA_WRITE\n\t\t\t\t\t\t   ? DMA_TO_DEVICE\n\t\t\t\t\t\t   : DMA_FROM_DEVICE);\n\t\t\tif (host->sg_len < 1) {\n\t\t\t\tpr_err(\"%s : scatterlist map failed\\n\",\n\t\t\t\t       dev_name(&sock->dev));\n\t\t\t\ttifm_unmap_sg(sock, &host->bounce_buf, 1,\n\t\t\t\t\t      r_data->flags & MMC_DATA_WRITE\n\t\t\t\t\t      ? DMA_TO_DEVICE\n\t\t\t\t\t      : DMA_FROM_DEVICE);\n\t\t\t\tmrq->cmd->error = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\n\t\t\twritel(TIFM_FIFO_INT_SETALL,\n\t\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\t\t\twritel(ilog2(r_data->blksz) - 2,\n\t\t\t       sock->addr + SOCK_FIFO_PAGE_SIZE);\n\t\t\twritel(TIFM_FIFO_ENABLE,\n\t\t\t       sock->addr + SOCK_FIFO_CONTROL);\n\t\t\twritel(TIFM_FIFO_INTMASK,\n\t\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\n\n\t\t\tif (r_data->flags & MMC_DATA_WRITE)\n\t\t\t\twritel(TIFM_MMCSD_TXDE,\n\t\t\t\t       sock->addr + SOCK_MMCSD_BUFFER_CONFIG);\n\t\t\telse\n\t\t\t\twritel(TIFM_MMCSD_RXDE,\n\t\t\t\t       sock->addr + SOCK_MMCSD_BUFFER_CONFIG);\n\n\t\t\ttifm_sd_set_dma_data(host, r_data);\n\t\t}\n\n\t\twritel(r_data->blocks - 1,\n\t\t       sock->addr + SOCK_MMCSD_NUM_BLOCKS);\n\t\twritel(r_data->blksz - 1,\n\t\t       sock->addr + SOCK_MMCSD_BLOCK_LEN);\n\t}\n\n\thost->req = mrq;\n\tmod_timer(&host->timer, jiffies + host->timeout_jiffies);\n\twritel(TIFM_CTRL_LED | readl(sock->addr + SOCK_CONTROL),\n\t       sock->addr + SOCK_CONTROL);\n\ttifm_sd_exec(host, mrq->cmd);\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\treturn;\n\nerr_out:\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic void tifm_sd_end_cmd(struct tasklet_struct *t)\n{\n\tstruct tifm_sd *host = from_tasklet(host, t, finish_tasklet);\n\tstruct tifm_dev *sock = host->dev;\n\tstruct mmc_host *mmc = tifm_get_drvdata(sock);\n\tstruct mmc_request *mrq;\n\tstruct mmc_data *r_data = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\n\tdel_timer(&host->timer);\n\tmrq = host->req;\n\thost->req = NULL;\n\n\tif (!mrq) {\n\t\tpr_err(\" %s : no request to complete?\\n\",\n\t\t       dev_name(&sock->dev));\n\t\tspin_unlock_irqrestore(&sock->lock, flags);\n\t\treturn;\n\t}\n\n\tr_data = mrq->cmd->data;\n\tif (r_data) {\n\t\tif (host->no_dma) {\n\t\t\twritel((~TIFM_MMCSD_BUFINT)\n\t\t\t       & readl(sock->addr + SOCK_MMCSD_INT_ENABLE),\n\t\t\t       sock->addr + SOCK_MMCSD_INT_ENABLE);\n\t\t} else {\n\t\t\ttifm_unmap_sg(sock, &host->bounce_buf, 1,\n\t\t\t\t      (r_data->flags & MMC_DATA_WRITE)\n\t\t\t\t      ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\t\ttifm_unmap_sg(sock, r_data->sg, r_data->sg_len,\n\t\t\t\t      (r_data->flags & MMC_DATA_WRITE)\n\t\t\t\t      ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\t}\n\n\t\tr_data->bytes_xfered = r_data->blocks\n\t\t\t- readl(sock->addr + SOCK_MMCSD_NUM_BLOCKS) - 1;\n\t\tr_data->bytes_xfered *= r_data->blksz;\n\t\tr_data->bytes_xfered += r_data->blksz\n\t\t\t- readl(sock->addr + SOCK_MMCSD_BLOCK_LEN) + 1;\n\t}\n\n\twritel((~TIFM_CTRL_LED) & readl(sock->addr + SOCK_CONTROL),\n\t       sock->addr + SOCK_CONTROL);\n\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\tmmc_request_done(mmc, mrq);\n}\n\nstatic void tifm_sd_abort(struct timer_list *t)\n{\n\tstruct tifm_sd *host = from_timer(host, t, timer);\n\n\tpr_err(\"%s : card failed to respond for a long period of time \"\n\t       \"(%x, %x)\\n\",\n\t       dev_name(&host->dev->dev), host->req->cmd->opcode, host->cmd_flags);\n\n\ttifm_eject(host->dev);\n}\n\nstatic void tifm_sd_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct tifm_sd *host = mmc_priv(mmc);\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned int clk_div1, clk_div2;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\n\tdev_dbg(&sock->dev, \"ios: clock = %u, vdd = %x, bus_mode = %x, \"\n\t\t\"chip_select = %x, power_mode = %x, bus_width = %x\\n\",\n\t\tios->clock, ios->vdd, ios->bus_mode, ios->chip_select,\n\t\tios->power_mode, ios->bus_width);\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_4) {\n\t\twritel(TIFM_MMCSD_4BBUS | readl(sock->addr + SOCK_MMCSD_CONFIG),\n\t\t       sock->addr + SOCK_MMCSD_CONFIG);\n\t} else {\n\t\twritel((~TIFM_MMCSD_4BBUS)\n\t\t       & readl(sock->addr + SOCK_MMCSD_CONFIG),\n\t\t       sock->addr + SOCK_MMCSD_CONFIG);\n\t}\n\n\tif (ios->clock) {\n\t\tclk_div1 = 20000000 / ios->clock;\n\t\tif (!clk_div1)\n\t\t\tclk_div1 = 1;\n\n\t\tclk_div2 = 24000000 / ios->clock;\n\t\tif (!clk_div2)\n\t\t\tclk_div2 = 1;\n\n\t\tif ((20000000 / clk_div1) > ios->clock)\n\t\t\tclk_div1++;\n\t\tif ((24000000 / clk_div2) > ios->clock)\n\t\t\tclk_div2++;\n\t\tif ((20000000 / clk_div1) > (24000000 / clk_div2)) {\n\t\t\thost->clk_freq = 20000000;\n\t\t\thost->clk_div = clk_div1;\n\t\t\twritel((~TIFM_CTRL_FAST_CLK)\n\t\t\t       & readl(sock->addr + SOCK_CONTROL),\n\t\t\t       sock->addr + SOCK_CONTROL);\n\t\t} else {\n\t\t\thost->clk_freq = 24000000;\n\t\t\thost->clk_div = clk_div2;\n\t\t\twritel(TIFM_CTRL_FAST_CLK\n\t\t\t       | readl(sock->addr + SOCK_CONTROL),\n\t\t\t       sock->addr + SOCK_CONTROL);\n\t\t}\n\t} else {\n\t\thost->clk_div = 0;\n\t}\n\thost->clk_div &= TIFM_MMCSD_CLKMASK;\n\twritel(host->clk_div\n\t       | ((~TIFM_MMCSD_CLKMASK)\n\t\t  & readl(sock->addr + SOCK_MMCSD_CONFIG)),\n\t       sock->addr + SOCK_MMCSD_CONFIG);\n\n\thost->open_drain = (ios->bus_mode == MMC_BUSMODE_OPENDRAIN);\n\n\t \n\t\n\t\n\n\tspin_unlock_irqrestore(&sock->lock, flags);\n}\n\nstatic int tifm_sd_ro(struct mmc_host *mmc)\n{\n\tint rc = 0;\n\tstruct tifm_sd *host = mmc_priv(mmc);\n\tstruct tifm_dev *sock = host->dev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\tif (TIFM_MMCSD_CARD_RO & readl(sock->addr + SOCK_PRESENT_STATE))\n\t\trc = 1;\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\treturn rc;\n}\n\nstatic const struct mmc_host_ops tifm_sd_ops = {\n\t.request = tifm_sd_request,\n\t.set_ios = tifm_sd_ios,\n\t.get_ro  = tifm_sd_ro\n};\n\nstatic int tifm_sd_initialize_host(struct tifm_sd *host)\n{\n\tint rc;\n\tunsigned int host_status = 0;\n\tstruct tifm_dev *sock = host->dev;\n\n\twritel(0, sock->addr + SOCK_MMCSD_INT_ENABLE);\n\thost->clk_div = 61;\n\thost->clk_freq = 20000000;\n\twritel(TIFM_MMCSD_RESET, sock->addr + SOCK_MMCSD_SYSTEM_CONTROL);\n\twritel(host->clk_div | TIFM_MMCSD_POWER,\n\t       sock->addr + SOCK_MMCSD_CONFIG);\n\n\t \n\tfor (rc = 32; rc <= 256; rc <<= 1) {\n\t\tif (1 & readl(sock->addr + SOCK_MMCSD_SYSTEM_STATUS)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(rc);\n\t}\n\n\tif (rc) {\n\t\tpr_err(\"%s : controller failed to reset\\n\",\n\t\t       dev_name(&sock->dev));\n\t\treturn -ENODEV;\n\t}\n\n\twritel(0, sock->addr + SOCK_MMCSD_NUM_BLOCKS);\n\twritel(host->clk_div | TIFM_MMCSD_POWER,\n\t       sock->addr + SOCK_MMCSD_CONFIG);\n\twritel(TIFM_MMCSD_RXDE, sock->addr + SOCK_MMCSD_BUFFER_CONFIG);\n\n\t\n\twritel(64, sock->addr + SOCK_MMCSD_COMMAND_TO);\n\twritel(TIFM_MMCSD_INAB, sock->addr + SOCK_MMCSD_COMMAND);\n\n\tfor (rc = 16; rc <= 64; rc <<= 1) {\n\t\thost_status = readl(sock->addr + SOCK_MMCSD_STATUS);\n\t\twritel(host_status, sock->addr + SOCK_MMCSD_STATUS);\n\t\tif (!(host_status & TIFM_MMCSD_ERRMASK)\n\t\t    && (host_status & TIFM_MMCSD_EOC)) {\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(rc);\n\t}\n\n\tif (rc) {\n\t\tpr_err(\"%s : card not ready - probe failed on initialization\\n\",\n\t\t       dev_name(&sock->dev));\n\t\treturn -ENODEV;\n\t}\n\n\twritel(TIFM_MMCSD_CERR | TIFM_MMCSD_BRS | TIFM_MMCSD_EOC\n\t       | TIFM_MMCSD_ERRMASK,\n\t       sock->addr + SOCK_MMCSD_INT_ENABLE);\n\n\treturn 0;\n}\n\nstatic int tifm_sd_probe(struct tifm_dev *sock)\n{\n\tstruct mmc_host *mmc;\n\tstruct tifm_sd *host;\n\tint rc = -EIO;\n\n\tif (!(TIFM_SOCK_STATE_OCCUPIED\n\t      & readl(sock->addr + SOCK_PRESENT_STATE))) {\n\t\tpr_warn(\"%s : card gone, unexpectedly\\n\",\n\t\t\tdev_name(&sock->dev));\n\t\treturn rc;\n\t}\n\n\tmmc = mmc_alloc_host(sizeof(struct tifm_sd), &sock->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\thost = mmc_priv(mmc);\n\ttifm_set_drvdata(sock, mmc);\n\thost->dev = sock;\n\thost->timeout_jiffies = msecs_to_jiffies(TIFM_MMCSD_REQ_TIMEOUT_MS);\n\t \n\tmmc->max_busy_timeout = TIFM_MMCSD_REQ_TIMEOUT_MS;\n\n\ttasklet_setup(&host->finish_tasklet, tifm_sd_end_cmd);\n\ttimer_setup(&host->timer, tifm_sd_abort, 0);\n\n\tmmc->ops = &tifm_sd_ops;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA;\n\tmmc->f_min = 20000000 / 60;\n\tmmc->f_max = 24000000;\n\n\tmmc->max_blk_count = 2048;\n\tmmc->max_segs = mmc->max_blk_count;\n\tmmc->max_blk_size = min(TIFM_MMCSD_MAX_BLOCK_SIZE, PAGE_SIZE);\n\tmmc->max_seg_size = mmc->max_blk_count * mmc->max_blk_size;\n\tmmc->max_req_size = mmc->max_seg_size;\n\n\tsock->card_event = tifm_sd_card_event;\n\tsock->data_event = tifm_sd_data_event;\n\trc = tifm_sd_initialize_host(host);\n\n\tif (!rc)\n\t\trc = mmc_add_host(mmc);\n\tif (!rc)\n\t\treturn 0;\n\n\tmmc_free_host(mmc);\n\treturn rc;\n}\n\nstatic void tifm_sd_remove(struct tifm_dev *sock)\n{\n\tstruct mmc_host *mmc = tifm_get_drvdata(sock);\n\tstruct tifm_sd *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\thost->eject = 1;\n\twritel(0, sock->addr + SOCK_MMCSD_INT_ENABLE);\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\n\ttasklet_kill(&host->finish_tasklet);\n\n\tspin_lock_irqsave(&sock->lock, flags);\n\tif (host->req) {\n\t\twritel(TIFM_FIFO_INT_SETALL,\n\t\t       sock->addr + SOCK_DMA_FIFO_INT_ENABLE_CLEAR);\n\t\twritel(0, sock->addr + SOCK_DMA_FIFO_INT_ENABLE_SET);\n\t\thost->req->cmd->error = -ENOMEDIUM;\n\t\tif (host->req->stop)\n\t\t\thost->req->stop->error = -ENOMEDIUM;\n\t\ttasklet_schedule(&host->finish_tasklet);\n\t}\n\tspin_unlock_irqrestore(&sock->lock, flags);\n\tmmc_remove_host(mmc);\n\tdev_dbg(&sock->dev, \"after remove\\n\");\n\n\tmmc_free_host(mmc);\n}\n\n#ifdef CONFIG_PM\n\nstatic int tifm_sd_suspend(struct tifm_dev *sock, pm_message_t state)\n{\n\treturn 0;\n}\n\nstatic int tifm_sd_resume(struct tifm_dev *sock)\n{\n\tstruct mmc_host *mmc = tifm_get_drvdata(sock);\n\tstruct tifm_sd *host = mmc_priv(mmc);\n\tint rc;\n\n\trc = tifm_sd_initialize_host(host);\n\tdev_dbg(&sock->dev, \"resume initialize %d\\n\", rc);\n\n\tif (rc)\n\t\thost->eject = 1;\n\n\treturn rc;\n}\n\n#else\n\n#define tifm_sd_suspend NULL\n#define tifm_sd_resume NULL\n\n#endif  \n\nstatic struct tifm_device_id tifm_sd_id_tbl[] = {\n\t{ TIFM_TYPE_SD }, { }\n};\n\nstatic struct tifm_driver tifm_sd_driver = {\n\t.driver = {\n\t\t.name  = DRIVER_NAME,\n\t\t.owner = THIS_MODULE\n\t},\n\t.id_table = tifm_sd_id_tbl,\n\t.probe    = tifm_sd_probe,\n\t.remove   = tifm_sd_remove,\n\t.suspend  = tifm_sd_suspend,\n\t.resume   = tifm_sd_resume\n};\n\nstatic int __init tifm_sd_init(void)\n{\n\treturn tifm_register_driver(&tifm_sd_driver);\n}\n\nstatic void __exit tifm_sd_exit(void)\n{\n\ttifm_unregister_driver(&tifm_sd_driver);\n}\n\nMODULE_AUTHOR(\"Alex Dubov\");\nMODULE_DESCRIPTION(\"TI FlashMedia SD driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DEVICE_TABLE(tifm, tifm_sd_id_tbl);\nMODULE_VERSION(DRIVER_VERSION);\n\nmodule_init(tifm_sd_init);\nmodule_exit(tifm_sd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}