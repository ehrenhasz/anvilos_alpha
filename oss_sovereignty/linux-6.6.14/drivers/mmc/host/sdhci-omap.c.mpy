{
  "module_name": "sdhci-omap.c",
  "hash_id": "6394ff910bcac42387bbaaad66de59f1dbd9c4104c98d5bf485233b2c3f11a69",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-omap.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/sys_soc.h>\n#include <linux/thermal.h>\n\n#include \"sdhci-pltfm.h\"\n\n \n#define SDHCI_OMAP_SYSCONFIG\t0x10\n\n#define SDHCI_OMAP_CON\t\t0x2c\n#define CON_DW8\t\t\tBIT(5)\n#define CON_DMA_MASTER\t\tBIT(20)\n#define CON_DDR\t\t\tBIT(19)\n#define CON_CLKEXTFREE\t\tBIT(16)\n#define CON_PADEN\t\tBIT(15)\n#define CON_CTPL\t\tBIT(11)\n#define CON_INIT\t\tBIT(1)\n#define CON_OD\t\t\tBIT(0)\n\n#define SDHCI_OMAP_DLL\t\t0x34\n#define DLL_SWT\t\t\tBIT(20)\n#define DLL_FORCE_SR_C_SHIFT\t13\n#define DLL_FORCE_SR_C_MASK\t(0x7f << DLL_FORCE_SR_C_SHIFT)\n#define DLL_FORCE_VALUE\t\tBIT(12)\n#define DLL_CALIB\t\tBIT(1)\n\n#define SDHCI_OMAP_CMD\t\t0x10c\n\n#define SDHCI_OMAP_PSTATE\t0x124\n#define PSTATE_DLEV_DAT0\tBIT(20)\n#define PSTATE_DATI\t\tBIT(1)\n\n#define SDHCI_OMAP_HCTL\t\t0x128\n#define HCTL_SDBP\t\tBIT(8)\n#define HCTL_SDVS_SHIFT\t\t9\n#define HCTL_SDVS_MASK\t\t(0x7 << HCTL_SDVS_SHIFT)\n#define HCTL_SDVS_33\t\t(0x7 << HCTL_SDVS_SHIFT)\n#define HCTL_SDVS_30\t\t(0x6 << HCTL_SDVS_SHIFT)\n#define HCTL_SDVS_18\t\t(0x5 << HCTL_SDVS_SHIFT)\n\n#define SDHCI_OMAP_SYSCTL\t0x12c\n#define SYSCTL_CEN\t\tBIT(2)\n#define SYSCTL_CLKD_SHIFT\t6\n#define SYSCTL_CLKD_MASK\t0x3ff\n\n#define SDHCI_OMAP_STAT\t\t0x130\n\n#define SDHCI_OMAP_IE\t\t0x134\n#define INT_CC_EN\t\tBIT(0)\n\n#define SDHCI_OMAP_ISE\t\t0x138\n\n#define SDHCI_OMAP_AC12\t\t0x13c\n#define AC12_V1V8_SIGEN\t\tBIT(19)\n#define AC12_SCLK_SEL\t\tBIT(23)\n\n#define SDHCI_OMAP_CAPA\t\t0x140\n#define CAPA_VS33\t\tBIT(24)\n#define CAPA_VS30\t\tBIT(25)\n#define CAPA_VS18\t\tBIT(26)\n\n#define SDHCI_OMAP_CAPA2\t0x144\n#define CAPA2_TSDR50\t\tBIT(13)\n\n#define SDHCI_OMAP_TIMEOUT\t1\t\t \n\n#define SYSCTL_CLKD_MAX\t\t0x3FF\n\n#define IOV_1V8\t\t\t1800000\t\t \n#define IOV_3V0\t\t\t3000000\t\t \n#define IOV_3V3\t\t\t3300000\t\t \n\n#define MAX_PHASE_DELAY\t\t0x7C\n\n \n#define SDHCI_OMAP_REQUIRE_IODELAY\tBIT(0)\n#define SDHCI_OMAP_SPECIAL_RESET\tBIT(1)\n\nstruct sdhci_omap_data {\n\tint omap_offset;\t \n\tu32 offset;\t\t \n\tu8 flags;\n};\n\nstruct sdhci_omap_host {\n\tchar\t\t\t*version;\n\tvoid __iomem\t\t*base;\n\tstruct device\t\t*dev;\n\tstruct\tregulator\t*pbias;\n\tbool\t\t\tpbias_enabled;\n\tstruct sdhci_host\t*host;\n\tu8\t\t\tbus_mode;\n\tu8\t\t\tpower_mode;\n\tu8\t\t\ttiming;\n\tu8\t\t\tflags;\n\n\tstruct pinctrl\t\t*pinctrl;\n\tstruct pinctrl_state\t**pinctrl_state;\n\tint\t\t\twakeirq;\n\tbool\t\t\tis_tuning;\n\n\t \n\tint\t\t\tomap_offset;\n\n\t \n\tu32\t\t\tcon;\n\tu32\t\t\thctl;\n\tu32\t\t\tsysctl;\n\tu32\t\t\tcapa;\n\tu32\t\t\tie;\n\tu32\t\t\tise;\n};\n\nstatic void sdhci_omap_start_clock(struct sdhci_omap_host *omap_host);\nstatic void sdhci_omap_stop_clock(struct sdhci_omap_host *omap_host);\n\nstatic inline u32 sdhci_omap_readl(struct sdhci_omap_host *host,\n\t\t\t\t   unsigned int offset)\n{\n\treturn readl(host->base + host->omap_offset + offset);\n}\n\nstatic inline void sdhci_omap_writel(struct sdhci_omap_host *host,\n\t\t\t\t     unsigned int offset, u32 data)\n{\n\twritel(data, host->base + host->omap_offset + offset);\n}\n\nstatic int sdhci_omap_set_pbias(struct sdhci_omap_host *omap_host,\n\t\t\t\tbool power_on, unsigned int iov)\n{\n\tint ret;\n\tstruct device *dev = omap_host->dev;\n\n\tif (IS_ERR(omap_host->pbias))\n\t\treturn 0;\n\n\tif (power_on) {\n\t\tret = regulator_set_voltage(omap_host->pbias, iov, iov);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"pbias set voltage failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (omap_host->pbias_enabled)\n\t\t\treturn 0;\n\n\t\tret = regulator_enable(omap_host->pbias);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"pbias reg enable fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tomap_host->pbias_enabled = true;\n\t} else {\n\t\tif (!omap_host->pbias_enabled)\n\t\t\treturn 0;\n\n\t\tret = regulator_disable(omap_host->pbias);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"pbias reg disable fail\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tomap_host->pbias_enabled = false;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_omap_enable_iov(struct sdhci_omap_host *omap_host,\n\t\t\t\t unsigned int iov_pbias)\n{\n\tint ret;\n\tstruct sdhci_host *host = omap_host->host;\n\tstruct mmc_host *mmc = host->mmc;\n\n\tret = sdhci_omap_set_pbias(omap_host, false, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\t \n\t\tret = mmc_regulator_set_vqmmc(mmc, &mmc->ios);\n\t\tif (ret < 0) {\n\t\t\tdev_err(mmc_dev(mmc), \"vqmmc set voltage failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = sdhci_omap_set_pbias(omap_host, true, iov_pbias);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic void sdhci_omap_conf_bus_power(struct sdhci_omap_host *omap_host,\n\t\t\t\t      unsigned char signal_voltage)\n{\n\tu32 reg, capa;\n\tktime_t timeout;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_HCTL);\n\treg &= ~HCTL_SDVS_MASK;\n\n\tswitch (signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tcapa = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA);\n\t\tif (capa & CAPA_VS33)\n\t\t\treg |= HCTL_SDVS_33;\n\t\telse if (capa & CAPA_VS30)\n\t\t\treg |= HCTL_SDVS_30;\n\t\telse\n\t\t\tdev_warn(omap_host->dev, \"misconfigured CAPA: %08x\\n\",\n\t\t\t\t capa);\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\tdefault:\n\t\treg |= HCTL_SDVS_18;\n\t\tbreak;\n\t}\n\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_HCTL, reg);\n\n\treg |= HCTL_SDBP;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_HCTL, reg);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), SDHCI_OMAP_TIMEOUT);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (sdhci_omap_readl(omap_host, SDHCI_OMAP_HCTL) & HCTL_SDBP)\n\t\t\tbreak;\n\t\tif (WARN_ON(timedout))\n\t\t\treturn;\n\t\tusleep_range(5, 10);\n\t}\n}\n\nstatic void sdhci_omap_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tif (enable)\n\t\treg |= (CON_CTPL | CON_CLKEXTFREE);\n\telse\n\t\treg &= ~(CON_CTPL | CON_CLKEXTFREE);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tsdhci_enable_sdio_irq(mmc, enable);\n}\n\nstatic inline void sdhci_omap_set_dll(struct sdhci_omap_host *omap_host,\n\t\t\t\t      int count)\n{\n\tint i;\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_DLL);\n\treg |= DLL_FORCE_VALUE;\n\treg &= ~DLL_FORCE_SR_C_MASK;\n\treg |= (count << DLL_FORCE_SR_C_SHIFT);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_DLL, reg);\n\n\treg |= DLL_CALIB;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_DLL, reg);\n\tfor (i = 0; i < 1000; i++) {\n\t\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_DLL);\n\t\tif (reg & DLL_CALIB)\n\t\t\tbreak;\n\t}\n\treg &= ~DLL_CALIB;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_DLL, reg);\n}\n\nstatic void sdhci_omap_disable_tuning(struct sdhci_omap_host *omap_host)\n{\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_AC12);\n\treg &= ~AC12_SCLK_SEL;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_AC12, reg);\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_DLL);\n\treg &= ~(DLL_FORCE_VALUE | DLL_SWT);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_DLL, reg);\n}\n\nstatic int sdhci_omap_execute_tuning(struct mmc_host *mmc, u32 opcode)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct thermal_zone_device *thermal_dev;\n\tstruct device *dev = omap_host->dev;\n\tstruct mmc_ios *ios = &mmc->ios;\n\tu32 start_window = 0, max_window = 0;\n\tbool single_point_failure = false;\n\tbool dcrc_was_enabled = false;\n\tu8 cur_match, prev_match = 0;\n\tu32 length = 0, max_len = 0;\n\tu32 phase_delay = 0;\n\tint temperature;\n\tint ret = 0;\n\tu32 reg;\n\tint i;\n\n\t \n\tif (ios->clock <= 52000000)\n\t\treturn 0;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA2);\n\tif (ios->timing == MMC_TIMING_UHS_SDR50 && !(reg & CAPA2_TSDR50))\n\t\treturn 0;\n\n\tthermal_dev = thermal_zone_get_zone_by_name(\"cpu_thermal\");\n\tif (IS_ERR(thermal_dev)) {\n\t\tdev_err(dev, \"Unable to get thermal zone for tuning\\n\");\n\t\treturn PTR_ERR(thermal_dev);\n\t}\n\n\tret = thermal_zone_get_temp(thermal_dev, &temperature);\n\tif (ret)\n\t\treturn ret;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_DLL);\n\treg |= DLL_SWT;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_DLL, reg);\n\n\t \n\tif (host->ier & SDHCI_INT_DATA_CRC) {\n\t\thost->ier &= ~SDHCI_INT_DATA_CRC;\n\t\tdcrc_was_enabled = true;\n\t}\n\n\tomap_host->is_tuning = true;\n\n\t \n\twhile (phase_delay <= MAX_PHASE_DELAY) {\n\t\tsdhci_omap_set_dll(omap_host, phase_delay);\n\n\t\tcur_match = !mmc_send_tuning(mmc, opcode, NULL);\n\t\tif (cur_match) {\n\t\t\tif (prev_match) {\n\t\t\t\tlength++;\n\t\t\t} else if (single_point_failure) {\n\t\t\t\t \n\t\t\t\tlength++;\n\t\t\t} else {\n\t\t\t\tstart_window = phase_delay;\n\t\t\t\tlength = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tsingle_point_failure = prev_match;\n\t\t}\n\n\t\tif (length > max_len) {\n\t\t\tmax_window = start_window;\n\t\t\tmax_len = length;\n\t\t}\n\n\t\tprev_match = cur_match;\n\t\tphase_delay += 4;\n\t}\n\n\tif (!max_len) {\n\t\tdev_err(dev, \"Unable to find match\\n\");\n\t\tret = -EIO;\n\t\tgoto tuning_error;\n\t}\n\n\t \n\tif (temperature < -20000)\n\t\tphase_delay = min(max_window + 4 * (max_len - 1) - 24,\n\t\t\t\t  max_window +\n\t\t\t\t  DIV_ROUND_UP(13 * max_len, 16) * 4);\n\telse if (temperature < 20000)\n\t\tphase_delay = max_window + DIV_ROUND_UP(9 * max_len, 16) * 4;\n\telse if (temperature < 40000)\n\t\tphase_delay = max_window + DIV_ROUND_UP(8 * max_len, 16) * 4;\n\telse if (temperature < 70000)\n\t\tphase_delay = max_window + DIV_ROUND_UP(7 * max_len, 16) * 4;\n\telse if (temperature < 90000)\n\t\tphase_delay = max_window + DIV_ROUND_UP(5 * max_len, 16) * 4;\n\telse if (temperature < 120000)\n\t\tphase_delay = max_window + DIV_ROUND_UP(4 * max_len, 16) * 4;\n\telse\n\t\tphase_delay = max_window + DIV_ROUND_UP(3 * max_len, 16) * 4;\n\n\t \n\tfor (i = 3; i <= 10; i++) {\n\t\tsdhci_omap_set_dll(omap_host, phase_delay + i);\n\n\t\tif (mmc_send_tuning(mmc, opcode, NULL)) {\n\t\t\tif (temperature < 10000)\n\t\t\t\tphase_delay += i + 6;\n\t\t\telse if (temperature < 20000)\n\t\t\t\tphase_delay += i - 12;\n\t\t\telse if (temperature < 70000)\n\t\t\t\tphase_delay += i - 8;\n\t\t\telse\n\t\t\t\tphase_delay += i - 6;\n\n\t\t\tgoto single_failure_found;\n\t\t}\n\t}\n\n\tfor (i = 2; i >= -10; i--) {\n\t\tsdhci_omap_set_dll(omap_host, phase_delay + i);\n\n\t\tif (mmc_send_tuning(mmc, opcode, NULL)) {\n\t\t\tif (temperature < 10000)\n\t\t\t\tphase_delay += i + 12;\n\t\t\telse if (temperature < 20000)\n\t\t\t\tphase_delay += i + 8;\n\t\t\telse if (temperature < 70000)\n\t\t\t\tphase_delay += i + 8;\n\t\t\telse if (temperature < 90000)\n\t\t\t\tphase_delay += i + 10;\n\t\t\telse\n\t\t\t\tphase_delay += i + 12;\n\n\t\t\tgoto single_failure_found;\n\t\t}\n\t}\n\nsingle_failure_found:\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_AC12);\n\tif (!(reg & AC12_SCLK_SEL)) {\n\t\tret = -EIO;\n\t\tgoto tuning_error;\n\t}\n\n\tsdhci_omap_set_dll(omap_host, phase_delay);\n\n\tomap_host->is_tuning = false;\n\n\tgoto ret;\n\ntuning_error:\n\tomap_host->is_tuning = false;\n\tdev_err(dev, \"Tuning failed\\n\");\n\tsdhci_omap_disable_tuning(omap_host);\n\nret:\n\tsdhci_reset(host, SDHCI_RESET_CMD | SDHCI_RESET_DATA);\n\t \n\tif (dcrc_was_enabled)\n\t\thost->ier |= SDHCI_INT_DATA_CRC;\n\tsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\n\treturn ret;\n}\n\nstatic int sdhci_omap_card_busy(struct mmc_host *mmc)\n{\n\tu32 reg, ac12;\n\tint ret = false;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_omap_host *omap_host;\n\tu32 ier = host->ier;\n\n\tpltfm_host = sdhci_priv(host);\n\tomap_host = sdhci_pltfm_priv(pltfm_host);\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tac12 = sdhci_omap_readl(omap_host, SDHCI_OMAP_AC12);\n\treg &= ~CON_CLKEXTFREE;\n\tif (ac12 & AC12_V1V8_SIGEN)\n\t\treg |= CON_CLKEXTFREE;\n\treg |= CON_PADEN;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tdisable_irq(host->irq);\n\tier |= SDHCI_INT_CARD_INT;\n\tsdhci_writel(host, ier, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, ier, SDHCI_SIGNAL_ENABLE);\n\n\t \n\tusleep_range(50, 100);\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_PSTATE);\n\tif ((reg & PSTATE_DATI) || !(reg & PSTATE_DLEV_DAT0))\n\t\tret = true;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\treg &= ~(CON_CLKEXTFREE | CON_PADEN);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\n\tenable_irq(host->irq);\n\n\treturn ret;\n}\n\nstatic int sdhci_omap_start_signal_voltage_switch(struct mmc_host *mmc,\n\t\t\t\t\t\t  struct mmc_ios *ios)\n{\n\tu32 reg;\n\tint ret;\n\tunsigned int iov;\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_omap_host *omap_host;\n\tstruct device *dev;\n\n\tpltfm_host = sdhci_priv(host);\n\tomap_host = sdhci_pltfm_priv(pltfm_host);\n\tdev = omap_host->dev;\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA);\n\t\tif (!(reg & (CAPA_VS30 | CAPA_VS33)))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tif (reg & CAPA_VS30)\n\t\t\tiov = IOV_3V0;\n\t\telse\n\t\t\tiov = IOV_3V3;\n\n\t\tsdhci_omap_conf_bus_power(omap_host, ios->signal_voltage);\n\n\t\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_AC12);\n\t\treg &= ~AC12_V1V8_SIGEN;\n\t\tsdhci_omap_writel(omap_host, SDHCI_OMAP_AC12, reg);\n\n\t} else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) {\n\t\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA);\n\t\tif (!(reg & CAPA_VS18))\n\t\t\treturn -EOPNOTSUPP;\n\n\t\tiov = IOV_1V8;\n\n\t\tsdhci_omap_conf_bus_power(omap_host, ios->signal_voltage);\n\n\t\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_AC12);\n\t\treg |= AC12_V1V8_SIGEN;\n\t\tsdhci_omap_writel(omap_host, SDHCI_OMAP_AC12, reg);\n\t} else {\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = sdhci_omap_enable_iov(omap_host, iov);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to switch IO voltage to %dmV\\n\", iov);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(dev, \"IO voltage switched to %dmV\\n\", iov);\n\treturn 0;\n}\n\nstatic void sdhci_omap_set_timing(struct sdhci_omap_host *omap_host, u8 timing)\n{\n\tint ret;\n\tstruct pinctrl_state *pinctrl_state;\n\tstruct device *dev = omap_host->dev;\n\n\tif (!(omap_host->flags & SDHCI_OMAP_REQUIRE_IODELAY))\n\t\treturn;\n\n\tif (omap_host->timing == timing)\n\t\treturn;\n\n\tsdhci_omap_stop_clock(omap_host);\n\n\tpinctrl_state = omap_host->pinctrl_state[timing];\n\tret = pinctrl_select_state(omap_host->pinctrl, pinctrl_state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to select pinctrl state\\n\");\n\t\treturn;\n\t}\n\n\tsdhci_omap_start_clock(omap_host);\n\tomap_host->timing = timing;\n}\n\nstatic void sdhci_omap_set_power_mode(struct sdhci_omap_host *omap_host,\n\t\t\t\t      u8 power_mode)\n{\n\tif (omap_host->bus_mode == MMC_POWER_OFF)\n\t\tsdhci_omap_disable_tuning(omap_host);\n\tomap_host->power_mode = power_mode;\n}\n\nstatic void sdhci_omap_set_bus_mode(struct sdhci_omap_host *omap_host,\n\t\t\t\t    unsigned int mode)\n{\n\tu32 reg;\n\n\tif (omap_host->bus_mode == mode)\n\t\treturn;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tif (mode == MMC_BUSMODE_OPENDRAIN)\n\t\treg |= CON_OD;\n\telse\n\t\treg &= ~CON_OD;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tomap_host->bus_mode = mode;\n}\n\nstatic void sdhci_omap_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_omap_host *omap_host;\n\n\tpltfm_host = sdhci_priv(host);\n\tomap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_omap_set_bus_mode(omap_host, ios->bus_mode);\n\tsdhci_omap_set_timing(omap_host, ios->timing);\n\tsdhci_set_ios(mmc, ios);\n\tsdhci_omap_set_power_mode(omap_host, ios->power_mode);\n}\n\nstatic u16 sdhci_omap_calc_divisor(struct sdhci_pltfm_host *host,\n\t\t\t\t   unsigned int clock)\n{\n\tu16 dsor;\n\n\tdsor = DIV_ROUND_UP(clk_get_rate(host->clk), clock);\n\tif (dsor > SYSCTL_CLKD_MAX)\n\t\tdsor = SYSCTL_CLKD_MAX;\n\n\treturn dsor;\n}\n\nstatic void sdhci_omap_start_clock(struct sdhci_omap_host *omap_host)\n{\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_SYSCTL);\n\treg |= SYSCTL_CEN;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_SYSCTL, reg);\n}\n\nstatic void sdhci_omap_stop_clock(struct sdhci_omap_host *omap_host)\n{\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_SYSCTL);\n\treg &= ~SYSCTL_CEN;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_SYSCTL, reg);\n}\n\nstatic void sdhci_omap_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tunsigned long clkdiv;\n\n\tsdhci_omap_stop_clock(omap_host);\n\n\tif (!clock)\n\t\treturn;\n\n\tclkdiv = sdhci_omap_calc_divisor(pltfm_host, clock);\n\tclkdiv = (clkdiv & SYSCTL_CLKD_MASK) << SYSCTL_CLKD_SHIFT;\n\tsdhci_enable_clk(host, clkdiv);\n\n\tsdhci_omap_start_clock(omap_host);\n}\n\nstatic void sdhci_omap_set_power(struct sdhci_host *host, unsigned char mode,\n\t\t\t  unsigned short vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);\n}\n\n \nstatic bool sdhci_omap_has_adma(struct sdhci_omap_host *omap_host, int offset)\n{\n\t \n\tif (offset < 0x200)\n\t\treturn false;\n\n\treturn readl(omap_host->base + 4) & 1;\n}\n\nstatic int sdhci_omap_enable_dma(struct sdhci_host *host)\n{\n\tu32 reg;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\treg &= ~CON_DMA_MASTER;\n\t \n\tif (!host->use_external_dma)\n\t\treg |= CON_DMA_MASTER;\n\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\treturn 0;\n}\n\nstatic unsigned int sdhci_omap_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn clk_get_rate(pltfm_host->clk) / SYSCTL_CLKD_MAX;\n}\n\nstatic void sdhci_omap_set_bus_width(struct sdhci_host *host, int width)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tif (width == MMC_BUS_WIDTH_8)\n\t\treg |= CON_DW8;\n\telse\n\t\treg &= ~CON_DW8;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tsdhci_set_bus_width(host, width);\n}\n\nstatic void sdhci_omap_init_74_clocks(struct sdhci_host *host, u8 power_mode)\n{\n\tu32 reg;\n\tktime_t timeout;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (omap_host->power_mode == power_mode)\n\t\treturn;\n\n\tif (power_mode != MMC_POWER_ON)\n\t\treturn;\n\n\tdisable_irq(host->irq);\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\treg |= CON_INIT;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CMD, 0x0);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), SDHCI_OMAP_TIMEOUT);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (sdhci_omap_readl(omap_host, SDHCI_OMAP_STAT) & INT_CC_EN)\n\t\t\tbreak;\n\t\tif (WARN_ON(timedout))\n\t\t\treturn;\n\t\tusleep_range(5, 10);\n\t}\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\treg &= ~CON_INIT;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_STAT, INT_CC_EN);\n\n\tenable_irq(host->irq);\n}\n\nstatic void sdhci_omap_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t unsigned int timing)\n{\n\tu32 reg;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_omap_stop_clock(omap_host);\n\n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tif (timing == MMC_TIMING_UHS_DDR50 || timing == MMC_TIMING_MMC_DDR52)\n\t\treg |= CON_DDR;\n\telse\n\t\treg &= ~CON_DDR;\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, reg);\n\n\tsdhci_set_uhs_signaling(host, timing);\n\tsdhci_omap_start_clock(omap_host);\n}\n\n#define MMC_TIMEOUT_US\t\t20000\t\t \nstatic void sdhci_omap_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tunsigned long limit = MMC_TIMEOUT_US;\n\tunsigned long i = 0;\n\tu32 sysc;\n\n\t \n\tif (mask & SDHCI_RESET_ALL)\n\t\tsysc = sdhci_omap_readl(omap_host, SDHCI_OMAP_SYSCONFIG);\n\n\t \n\tif (omap_host->is_tuning)\n\t\tmask &= ~SDHCI_RESET_DATA;\n\n\tif (omap_host->flags & SDHCI_OMAP_SPECIAL_RESET) {\n\t\tsdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);\n\t\twhile ((!(sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask)) &&\n\t\t       (i++ < limit))\n\t\t\tudelay(1);\n\t\ti = 0;\n\t\twhile ((sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) &&\n\t\t       (i++ < limit))\n\t\t\tudelay(1);\n\n\t\tif (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask)\n\t\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\t\"Timeout waiting on controller reset in %s\\n\",\n\t\t\t\t__func__);\n\n\t\tgoto restore_sysc;\n\t}\n\n\tsdhci_reset(host, mask);\n\nrestore_sysc:\n\tif (mask & SDHCI_RESET_ALL)\n\t\tsdhci_omap_writel(omap_host, SDHCI_OMAP_SYSCONFIG, sysc);\n}\n\n#define CMD_ERR_MASK (SDHCI_INT_CRC | SDHCI_INT_END_BIT | SDHCI_INT_INDEX |\\\n\t\t      SDHCI_INT_TIMEOUT)\n#define CMD_MASK (CMD_ERR_MASK | SDHCI_INT_RESPONSE)\n\nstatic u32 sdhci_omap_irq(struct sdhci_host *host, u32 intmask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (omap_host->is_tuning && host->cmd && !host->data_early &&\n\t    (intmask & CMD_ERR_MASK)) {\n\n\t\t \n\t\tif (intmask & SDHCI_INT_TIMEOUT)\n\t\t\thost->cmd->error = -ETIMEDOUT;\n\t\telse\n\t\t\thost->cmd->error = -EILSEQ;\n\n\t\thost->cmd = NULL;\n\n\t\t \n\t\tsdhci_writel(host, intmask & CMD_MASK, SDHCI_INT_STATUS);\n\t\tintmask &= ~CMD_MASK;\n\t}\n\n\treturn intmask;\n}\n\nstatic void sdhci_omap_set_timeout(struct sdhci_host *host,\n\t\t\t\t   struct mmc_command *cmd)\n{\n\tif (cmd->opcode == MMC_ERASE)\n\t\tsdhci_set_data_timeout_irq(host, false);\n\n\t__sdhci_set_timeout(host, cmd);\n}\n\nstatic struct sdhci_ops sdhci_omap_ops = {\n\t.set_clock = sdhci_omap_set_clock,\n\t.set_power = sdhci_omap_set_power,\n\t.enable_dma = sdhci_omap_enable_dma,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.get_min_clock = sdhci_omap_get_min_clock,\n\t.set_bus_width = sdhci_omap_set_bus_width,\n\t.platform_send_init_74_clocks = sdhci_omap_init_74_clocks,\n\t.reset = sdhci_omap_reset,\n\t.set_uhs_signaling = sdhci_omap_set_uhs_signaling,\n\t.irq = sdhci_omap_irq,\n\t.set_timeout = sdhci_omap_set_timeout,\n};\n\nstatic unsigned int sdhci_omap_regulator_get_caps(struct device *dev,\n\t\t\t\t\t\t  const char *name)\n{\n\tstruct regulator *reg;\n\tunsigned int caps = 0;\n\n\treg = regulator_get(dev, name);\n\tif (IS_ERR(reg))\n\t\treturn ~0U;\n\n\tif (regulator_is_supported_voltage(reg, 1700000, 1950000))\n\t\tcaps |= SDHCI_CAN_VDD_180;\n\tif (regulator_is_supported_voltage(reg, 2700000, 3150000))\n\t\tcaps |= SDHCI_CAN_VDD_300;\n\tif (regulator_is_supported_voltage(reg, 3150000, 3600000))\n\t\tcaps |= SDHCI_CAN_VDD_330;\n\n\tregulator_put(reg);\n\n\treturn caps;\n}\n\nstatic int sdhci_omap_set_capabilities(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\tstruct device *dev = omap_host->dev;\n\tconst u32 mask = SDHCI_CAN_VDD_180 | SDHCI_CAN_VDD_300 | SDHCI_CAN_VDD_330;\n\tunsigned int pbias, vqmmc, caps = 0;\n\tu32 reg;\n\n\tpbias = sdhci_omap_regulator_get_caps(dev, \"pbias\");\n\tvqmmc = sdhci_omap_regulator_get_caps(dev, \"vqmmc\");\n\tcaps = pbias & vqmmc;\n\n\tif (pbias != ~0U && vqmmc == ~0U)\n\t\tdev_warn(dev, \"vqmmc regulator missing for pbias\\n\");\n\telse if (caps == ~0U)\n\t\treturn 0;\n\n\t \n\tif (pbias != ~0U && (pbias & SDHCI_CAN_VDD_330) &&\n\t    (vqmmc & SDHCI_CAN_VDD_300))\n\t\tcaps |= SDHCI_CAN_VDD_330;\n\n\t \n\treg = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA);\n\treg &= ~(CAPA_VS18 | CAPA_VS30 | CAPA_VS33);\n\n\tif (caps & SDHCI_CAN_VDD_180)\n\t\treg |= CAPA_VS18;\n\n\tif (caps & SDHCI_CAN_VDD_300)\n\t\treg |= CAPA_VS30;\n\n\tif (caps & SDHCI_CAN_VDD_330)\n\t\treg |= CAPA_VS33;\n\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CAPA, reg);\n\n\thost->caps &= ~mask;\n\thost->caps |= caps;\n\n\treturn 0;\n}\n\nstatic const struct sdhci_pltfm_data sdhci_omap_pdata = {\n\t.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT |\n\t\t  SDHCI_QUIRK_BROKEN_ADMA_ZEROLEN_DESC,\n\t.quirks2 = SDHCI_QUIRK2_ACMD23_BROKEN |\n\t\t   SDHCI_QUIRK2_PRESET_VALUE_BROKEN |\n\t\t   SDHCI_QUIRK2_RSP_136_HAS_CRC |\n\t\t   SDHCI_QUIRK2_DISABLE_HW_TIMEOUT,\n\t.ops = &sdhci_omap_ops,\n};\n\nstatic const struct sdhci_omap_data omap2430_data = {\n\t.omap_offset = 0,\n\t.offset = 0x100,\n};\n\nstatic const struct sdhci_omap_data omap3_data = {\n\t.omap_offset = 0,\n\t.offset = 0x100,\n};\n\nstatic const struct sdhci_omap_data omap4_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n\t.flags = SDHCI_OMAP_SPECIAL_RESET,\n};\n\nstatic const struct sdhci_omap_data omap5_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n\t.flags = SDHCI_OMAP_SPECIAL_RESET,\n};\n\nstatic const struct sdhci_omap_data k2g_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n};\n\nstatic const struct sdhci_omap_data am335_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n\t.flags = SDHCI_OMAP_SPECIAL_RESET,\n};\n\nstatic const struct sdhci_omap_data am437_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n\t.flags = SDHCI_OMAP_SPECIAL_RESET,\n};\n\nstatic const struct sdhci_omap_data dra7_data = {\n\t.omap_offset = 0x100,\n\t.offset = 0x200,\n\t.flags\t= SDHCI_OMAP_REQUIRE_IODELAY,\n};\n\nstatic const struct of_device_id omap_sdhci_match[] = {\n\t{ .compatible = \"ti,omap2430-sdhci\", .data = &omap2430_data },\n\t{ .compatible = \"ti,omap3-sdhci\", .data = &omap3_data },\n\t{ .compatible = \"ti,omap4-sdhci\", .data = &omap4_data },\n\t{ .compatible = \"ti,omap5-sdhci\", .data = &omap5_data },\n\t{ .compatible = \"ti,dra7-sdhci\", .data = &dra7_data },\n\t{ .compatible = \"ti,k2g-sdhci\", .data = &k2g_data },\n\t{ .compatible = \"ti,am335-sdhci\", .data = &am335_data },\n\t{ .compatible = \"ti,am437-sdhci\", .data = &am437_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, omap_sdhci_match);\n\nstatic struct pinctrl_state\n*sdhci_omap_iodelay_pinctrl_state(struct sdhci_omap_host *omap_host, char *mode,\n\t\t\t\t  u32 *caps, u32 capmask)\n{\n\tstruct device *dev = omap_host->dev;\n\tchar *version = omap_host->version;\n\tstruct pinctrl_state *pinctrl_state = ERR_PTR(-ENODEV);\n\tchar str[20];\n\n\tif (!(*caps & capmask))\n\t\tgoto ret;\n\n\tif (version) {\n\t\tsnprintf(str, 20, \"%s-%s\", mode, version);\n\t\tpinctrl_state = pinctrl_lookup_state(omap_host->pinctrl, str);\n\t}\n\n\tif (IS_ERR(pinctrl_state))\n\t\tpinctrl_state = pinctrl_lookup_state(omap_host->pinctrl, mode);\n\n\tif (IS_ERR(pinctrl_state)) {\n\t\tdev_err(dev, \"no pinctrl state for %s mode\", mode);\n\t\t*caps &= ~capmask;\n\t}\n\nret:\n\treturn pinctrl_state;\n}\n\nstatic int sdhci_omap_config_iodelay_pinctrl_state(struct sdhci_omap_host\n\t\t\t\t\t\t   *omap_host)\n{\n\tstruct device *dev = omap_host->dev;\n\tstruct sdhci_host *host = omap_host->host;\n\tstruct mmc_host *mmc = host->mmc;\n\tu32 *caps = &mmc->caps;\n\tu32 *caps2 = &mmc->caps2;\n\tstruct pinctrl_state *state;\n\tstruct pinctrl_state **pinctrl_state;\n\n\tif (!(omap_host->flags & SDHCI_OMAP_REQUIRE_IODELAY))\n\t\treturn 0;\n\n\tpinctrl_state = devm_kcalloc(dev,\n\t\t\t\t     MMC_TIMING_MMC_HS200 + 1,\n\t\t\t\t     sizeof(*pinctrl_state),\n\t\t\t\t     GFP_KERNEL);\n\tif (!pinctrl_state)\n\t\treturn -ENOMEM;\n\n\tomap_host->pinctrl = devm_pinctrl_get(omap_host->dev);\n\tif (IS_ERR(omap_host->pinctrl)) {\n\t\tdev_err(dev, \"Cannot get pinctrl\\n\");\n\t\treturn PTR_ERR(omap_host->pinctrl);\n\t}\n\n\tstate = pinctrl_lookup_state(omap_host->pinctrl, \"default\");\n\tif (IS_ERR(state)) {\n\t\tdev_err(dev, \"no pinctrl state for default mode\\n\");\n\t\treturn PTR_ERR(state);\n\t}\n\tpinctrl_state[MMC_TIMING_LEGACY] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"sdr104\", caps,\n\t\t\t\t\t\t MMC_CAP_UHS_SDR104);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_UHS_SDR104] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"ddr50\", caps,\n\t\t\t\t\t\t MMC_CAP_UHS_DDR50);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_UHS_DDR50] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"sdr50\", caps,\n\t\t\t\t\t\t MMC_CAP_UHS_SDR50);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_UHS_SDR50] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"sdr25\", caps,\n\t\t\t\t\t\t MMC_CAP_UHS_SDR25);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_UHS_SDR25] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"sdr12\", caps,\n\t\t\t\t\t\t MMC_CAP_UHS_SDR12);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_UHS_SDR12] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"ddr_1_8v\", caps,\n\t\t\t\t\t\t MMC_CAP_1_8V_DDR);\n\tif (!IS_ERR(state)) {\n\t\tpinctrl_state[MMC_TIMING_MMC_DDR52] = state;\n\t} else {\n\t\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"ddr_3_3v\",\n\t\t\t\t\t\t\t caps,\n\t\t\t\t\t\t\t MMC_CAP_3_3V_DDR);\n\t\tif (!IS_ERR(state))\n\t\t\tpinctrl_state[MMC_TIMING_MMC_DDR52] = state;\n\t}\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"hs\", caps,\n\t\t\t\t\t\t MMC_CAP_SD_HIGHSPEED);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_SD_HS] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"hs\", caps,\n\t\t\t\t\t\t MMC_CAP_MMC_HIGHSPEED);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_MMC_HS] = state;\n\n\tstate = sdhci_omap_iodelay_pinctrl_state(omap_host, \"hs200_1_8v\", caps2,\n\t\t\t\t\t\t MMC_CAP2_HS200_1_8V_SDR);\n\tif (!IS_ERR(state))\n\t\tpinctrl_state[MMC_TIMING_MMC_HS200] = state;\n\n\tomap_host->pinctrl_state = pinctrl_state;\n\n\treturn 0;\n}\n\nstatic const struct soc_device_attribute sdhci_omap_soc_devices[] = {\n\t{\n\t\t.machine = \"DRA7[45]*\",\n\t\t.revision = \"ES1.[01]\",\n\t},\n\t{\n\t\t \n\t}\n};\n\nstatic int sdhci_omap_probe(struct platform_device *pdev)\n{\n\tint ret;\n\tu32 offset;\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_omap_host *omap_host;\n\tstruct mmc_host *mmc;\n\tconst struct sdhci_omap_data *data;\n\tconst struct soc_device_attribute *soc;\n\tstruct resource *regs;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data) {\n\t\tdev_err(dev, \"no sdhci omap data\\n\");\n\t\treturn -EINVAL;\n\t}\n\toffset = data->offset;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn -ENXIO;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_omap_pdata,\n\t\t\t\tsizeof(*omap_host));\n\tif (IS_ERR(host)) {\n\t\tdev_err(dev, \"Failed sdhci_pltfm_init\\n\");\n\t\treturn PTR_ERR(host);\n\t}\n\n\tpltfm_host = sdhci_priv(host);\n\tomap_host = sdhci_pltfm_priv(pltfm_host);\n\tomap_host->host = host;\n\tomap_host->base = host->ioaddr;\n\tomap_host->dev = dev;\n\tomap_host->power_mode = MMC_POWER_UNDEFINED;\n\tomap_host->timing = MMC_TIMING_LEGACY;\n\tomap_host->flags = data->flags;\n\tomap_host->omap_offset = data->omap_offset;\n\tomap_host->con = -EINVAL;  \n\thost->ioaddr += offset;\n\thost->mapbase = regs->start + offset;\n\n\tmmc = host->mmc;\n\tsdhci_get_of_property(pdev);\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto err_pltfm_free;\n\n\tsoc = soc_device_match(sdhci_omap_soc_devices);\n\tif (soc) {\n\t\tomap_host->version = \"rev11\";\n\t\tif (!strcmp(dev_name(dev), \"4809c000.mmc\"))\n\t\t\tmmc->f_max = 96000000;\n\t\tif (!strcmp(dev_name(dev), \"480b4000.mmc\"))\n\t\t\tmmc->f_max = 48000000;\n\t\tif (!strcmp(dev_name(dev), \"480ad000.mmc\"))\n\t\t\tmmc->f_max = 48000000;\n\t}\n\n\tif (!mmc_can_gpio_ro(mmc))\n\t\tmmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;\n\n\tpltfm_host->clk = devm_clk_get(dev, \"fck\");\n\tif (IS_ERR(pltfm_host->clk)) {\n\t\tret = PTR_ERR(pltfm_host->clk);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tret = clk_set_rate(pltfm_host->clk, mmc->f_max);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set clock to %d\\n\", mmc->f_max);\n\t\tgoto err_pltfm_free;\n\t}\n\n\tomap_host->pbias = devm_regulator_get_optional(dev, \"pbias\");\n\tif (IS_ERR(omap_host->pbias)) {\n\t\tret = PTR_ERR(omap_host->pbias);\n\t\tif (ret != -ENODEV)\n\t\t\tgoto err_pltfm_free;\n\t\tdev_dbg(dev, \"unable to get pbias regulator %d\\n\", ret);\n\t}\n\tomap_host->pbias_enabled = false;\n\n\t \n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 50);\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"pm_runtime_get_sync failed\\n\");\n\t\tgoto err_rpm_disable;\n\t}\n\n\tret = sdhci_omap_set_capabilities(host);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to set system capabilities\\n\");\n\t\tgoto err_rpm_put;\n\t}\n\n\thost->mmc_host_ops.start_signal_voltage_switch =\n\t\t\t\t\tsdhci_omap_start_signal_voltage_switch;\n\thost->mmc_host_ops.set_ios = sdhci_omap_set_ios;\n\thost->mmc_host_ops.card_busy = sdhci_omap_card_busy;\n\thost->mmc_host_ops.execute_tuning = sdhci_omap_execute_tuning;\n\thost->mmc_host_ops.enable_sdio_irq = sdhci_omap_enable_sdio_irq;\n\n\t \n\tif (device_property_present(dev, \"dmas\") &&\n\t    !sdhci_omap_has_adma(omap_host, offset))\n\t\tsdhci_switch_external_dma(host, true);\n\n\tif (device_property_read_bool(dev, \"ti,non-removable\")) {\n\t\tdev_warn_once(dev, \"using old ti,non-removable property\\n\");\n\t\tmmc->caps |= MMC_CAP_NONREMOVABLE;\n\t}\n\n\t \n\tmmc->caps |= MMC_CAP_NEED_RSP_BUSY;\n\n\t \n\tmmc->caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_AGGRESSIVE_PM;\n\n\tret = sdhci_setup_host(host);\n\tif (ret)\n\t\tgoto err_rpm_put;\n\n\tret = sdhci_omap_config_iodelay_pinctrl_state(omap_host);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\tret = __sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_cleanup_host;\n\n\t \n\tomap_host->wakeirq = of_irq_get_byname(dev->of_node, \"wakeup\");\n\tif (omap_host->wakeirq == -EPROBE_DEFER) {\n\t\tret = -EPROBE_DEFER;\n\t\tgoto err_cleanup_host;\n\t}\n\tif (omap_host->wakeirq > 0) {\n\t\tdevice_init_wakeup(dev, true);\n\t\tret = dev_pm_set_dedicated_wake_irq(dev, omap_host->wakeirq);\n\t\tif (ret) {\n\t\t\tdevice_init_wakeup(dev, false);\n\t\t\tgoto err_cleanup_host;\n\t\t}\n\t\thost->mmc->pm_caps |= MMC_PM_KEEP_POWER | MMC_PM_WAKE_SDIO_IRQ;\n\t}\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\nerr_cleanup_host:\n\tsdhci_cleanup_host(host);\n\nerr_rpm_put:\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\nerr_rpm_disable:\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_disable(dev);\n\nerr_pltfm_free:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_omap_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(dev);\n\tsdhci_remove_host(host, true);\n\tdevice_init_wakeup(dev, false);\n\tdev_pm_clear_wake_irq(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_put_sync(dev);\n\t \n\tpm_runtime_force_suspend(dev);\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM\nstatic void __maybe_unused sdhci_omap_context_save(struct sdhci_omap_host *omap_host)\n{\n\tomap_host->con = sdhci_omap_readl(omap_host, SDHCI_OMAP_CON);\n\tomap_host->hctl = sdhci_omap_readl(omap_host, SDHCI_OMAP_HCTL);\n\tomap_host->sysctl = sdhci_omap_readl(omap_host, SDHCI_OMAP_SYSCTL);\n\tomap_host->capa = sdhci_omap_readl(omap_host, SDHCI_OMAP_CAPA);\n\tomap_host->ie = sdhci_omap_readl(omap_host, SDHCI_OMAP_IE);\n\tomap_host->ise = sdhci_omap_readl(omap_host, SDHCI_OMAP_ISE);\n}\n\n \nstatic void __maybe_unused sdhci_omap_context_restore(struct sdhci_omap_host *omap_host)\n{\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_HCTL, omap_host->hctl);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CAPA, omap_host->capa);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_HCTL, omap_host->hctl);\n\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_SYSCTL, omap_host->sysctl);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_CON, omap_host->con);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_IE, omap_host->ie);\n\tsdhci_omap_writel(omap_host, SDHCI_OMAP_ISE, omap_host->ise);\n}\n\nstatic int __maybe_unused sdhci_omap_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tif (omap_host->con != -EINVAL)\n\t\tsdhci_runtime_suspend_host(host);\n\n\tsdhci_omap_context_save(omap_host);\n\n\tpinctrl_pm_select_idle_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused sdhci_omap_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_omap_host *omap_host = sdhci_pltfm_priv(pltfm_host);\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (omap_host->con != -EINVAL) {\n\t\tsdhci_omap_context_restore(omap_host);\n\t\tsdhci_runtime_resume_host(host, 0);\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_omap_dev_pm_ops = {\n\tSET_RUNTIME_PM_OPS(sdhci_omap_runtime_suspend,\n\t\t\t   sdhci_omap_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n};\n\nstatic struct platform_driver sdhci_omap_driver = {\n\t.probe = sdhci_omap_probe,\n\t.remove_new = sdhci_omap_remove,\n\t.driver = {\n\t\t   .name = \"sdhci-omap\",\n\t\t   .probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t   .pm = &sdhci_omap_dev_pm_ops,\n\t\t   .of_match_table = omap_sdhci_match,\n\t\t  },\n};\n\nmodule_platform_driver(sdhci_omap_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for OMAP SoCs\");\nMODULE_AUTHOR(\"Texas Instruments Inc.\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sdhci_omap\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}