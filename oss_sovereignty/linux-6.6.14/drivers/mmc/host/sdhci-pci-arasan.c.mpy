{
  "module_name": "sdhci-pci-arasan.c",
  "hash_id": "bfebde791fdc1cb887c59a2ed22cda1c0171378ce786311c5da73f8495c1b1fb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pci-arasan.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/delay.h>\n\n#include \"sdhci.h\"\n#include \"sdhci-pci.h\"\n\n \n#define PHY_ADDR_REG\t0x300\n#define PHY_DAT_REG\t0x304\n\n#define PHY_WRITE\tBIT(8)\n#define PHY_BUSY\tBIT(9)\n#define DATA_MASK\t0xFF\n\n \n#define DLL_STATUS\t0x00\n#define IPAD_CTRL1\t0x01\n#define IPAD_CTRL2\t0x02\n#define IPAD_STS\t0x03\n#define IOREN_CTRL1\t0x06\n#define IOREN_CTRL2\t0x07\n#define IOPU_CTRL1\t0x08\n#define IOPU_CTRL2\t0x09\n#define ITAP_DELAY\t0x0C\n#define OTAP_DELAY\t0x0D\n#define STRB_SEL\t0x0E\n#define CLKBUF_SEL\t0x0F\n#define MODE_CTRL\t0x11\n#define DLL_TRIM\t0x12\n#define CMD_CTRL\t0x20\n#define DATA_CTRL\t0x21\n#define STRB_CTRL\t0x22\n#define CLK_CTRL\t0x23\n#define PHY_CTRL\t0x24\n\n#define DLL_ENBL\tBIT(3)\n#define RTRIM_EN\tBIT(1)\n#define PDB_ENBL\tBIT(1)\n#define RETB_ENBL\tBIT(6)\n#define ODEN_CMD\tBIT(1)\n#define ODEN_DAT\t0xFF\n#define REN_STRB\tBIT(0)\n#define REN_CMND\tBIT(1)\n#define REN_DATA\t0xFF\n#define PU_CMD\t\tBIT(1)\n#define PU_DAT\t\t0xFF\n#define ITAPDLY_EN\tBIT(0)\n#define OTAPDLY_EN\tBIT(0)\n#define OD_REL_CMD\tBIT(1)\n#define OD_REL_DAT\t0xFF\n#define DLLTRM_ICP\t0x8\n#define PDB_CMND\tBIT(0)\n#define PDB_DATA\t0xFF\n#define PDB_STRB\tBIT(0)\n#define PDB_CLOCK\tBIT(0)\n#define CALDONE_MASK\t0x10\n#define DLL_RDY_MASK\t0x10\n#define MAX_CLK_BUF\t0x7\n\n \n#define ENHSTRB_MODE\tBIT(0)\n#define HS400_MODE\tBIT(1)\n#define LEGACY_MODE\tBIT(2)\n#define DDR50_MODE\tBIT(3)\n\n \n#define HS200_MODE\tBIT(4)\n#define HISPD_MODE\tBIT(5)\n\n#define OTAPDLY(x)\t(((x) << 1) | OTAPDLY_EN)\n#define ITAPDLY(x)\t(((x) << 1) | ITAPDLY_EN)\n#define FREQSEL(x)\t(((x) << 5) | DLL_ENBL)\n#define IOPAD(x, y)\t((x) | ((y) << 2))\n\n \nstruct arasan_host {\n\tu32 chg_clk;\n};\n\nstatic int arasan_phy_addr_poll(struct sdhci_host *host, u32 offset, u32 mask)\n{\n\tktime_t timeout = ktime_add_us(ktime_get(), 100);\n\tbool failed;\n\tu8 val = 0;\n\n\twhile (1) {\n\t\tfailed = ktime_after(ktime_get(), timeout);\n\t\tval = sdhci_readw(host, PHY_ADDR_REG);\n\t\tif (!(val & mask))\n\t\t\treturn 0;\n\t\tif (failed)\n\t\t\treturn -EBUSY;\n\t}\n}\n\nstatic int arasan_phy_write(struct sdhci_host *host, u8 data, u8 offset)\n{\n\tsdhci_writew(host, data, PHY_DAT_REG);\n\tsdhci_writew(host, (PHY_WRITE | offset), PHY_ADDR_REG);\n\treturn arasan_phy_addr_poll(host, PHY_ADDR_REG, PHY_BUSY);\n}\n\nstatic int arasan_phy_read(struct sdhci_host *host, u8 offset, u8 *data)\n{\n\tint ret;\n\n\tsdhci_writew(host, 0, PHY_DAT_REG);\n\tsdhci_writew(host, offset, PHY_ADDR_REG);\n\tret = arasan_phy_addr_poll(host, PHY_ADDR_REG, PHY_BUSY);\n\n\t \n\t*data = sdhci_readw(host, PHY_DAT_REG) & DATA_MASK;\n\treturn ret;\n}\n\nstatic int arasan_phy_sts_poll(struct sdhci_host *host, u32 offset, u32 mask)\n{\n\tint ret;\n\tktime_t timeout = ktime_add_us(ktime_get(), 100);\n\tbool failed;\n\tu8 val = 0;\n\n\twhile (1) {\n\t\tfailed = ktime_after(ktime_get(), timeout);\n\t\tret = arasan_phy_read(host, offset, &val);\n\t\tif (ret)\n\t\t\treturn -EBUSY;\n\t\telse if (val & mask)\n\t\t\treturn 0;\n\t\tif (failed)\n\t\t\treturn -EBUSY;\n\t}\n}\n\n \nstatic int arasan_phy_init(struct sdhci_host *host)\n{\n\tint ret;\n\tu8 val;\n\n\t \n\tif (arasan_phy_read(host, IPAD_CTRL1, &val) ||\n\t    arasan_phy_write(host, val | RETB_ENBL | PDB_ENBL, IPAD_CTRL1) ||\n\t    arasan_phy_read(host, IPAD_CTRL2, &val) ||\n\t    arasan_phy_write(host, val | RTRIM_EN, IPAD_CTRL2))\n\t\treturn -EBUSY;\n\tret = arasan_phy_sts_poll(host, IPAD_STS, CALDONE_MASK);\n\tif (ret)\n\t\treturn -EBUSY;\n\n\t \n\tif (arasan_phy_read(host, IOREN_CTRL1, &val) ||\n\t    arasan_phy_write(host, val | REN_CMND | REN_STRB, IOREN_CTRL1) ||\n\t    arasan_phy_read(host, IOPU_CTRL1, &val) ||\n\t    arasan_phy_write(host, val | PU_CMD, IOPU_CTRL1) ||\n\t    arasan_phy_read(host, CMD_CTRL, &val) ||\n\t    arasan_phy_write(host, val | PDB_CMND, CMD_CTRL) ||\n\t    arasan_phy_read(host, IOREN_CTRL2, &val) ||\n\t    arasan_phy_write(host, val | REN_DATA, IOREN_CTRL2) ||\n\t    arasan_phy_read(host, IOPU_CTRL2, &val) ||\n\t    arasan_phy_write(host, val | PU_DAT, IOPU_CTRL2) ||\n\t    arasan_phy_read(host, DATA_CTRL, &val) ||\n\t    arasan_phy_write(host, val | PDB_DATA, DATA_CTRL) ||\n\t    arasan_phy_read(host, STRB_CTRL, &val) ||\n\t    arasan_phy_write(host, val | PDB_STRB, STRB_CTRL) ||\n\t    arasan_phy_read(host, CLK_CTRL, &val) ||\n\t    arasan_phy_write(host, val | PDB_CLOCK, CLK_CTRL) ||\n\t    arasan_phy_read(host, CLKBUF_SEL, &val) ||\n\t    arasan_phy_write(host, val | MAX_CLK_BUF, CLKBUF_SEL) ||\n\t    arasan_phy_write(host, LEGACY_MODE, MODE_CTRL))\n\t\treturn -EBUSY;\n\treturn 0;\n}\n\n \nstatic int arasan_phy_set(struct sdhci_host *host, u8 mode, u8 otap,\n\t\t\t  u8 drv_type, u8 itap, u8 trim, u8 clk)\n{\n\tu8 val;\n\tint ret;\n\n\tif (mode == HISPD_MODE || mode == HS200_MODE)\n\t\tret = arasan_phy_write(host, 0x0, MODE_CTRL);\n\telse\n\t\tret = arasan_phy_write(host, mode, MODE_CTRL);\n\tif (ret)\n\t\treturn ret;\n\tif (mode == HS400_MODE || mode == HS200_MODE) {\n\t\tret = arasan_phy_read(host, IPAD_CTRL1, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = arasan_phy_write(host, IOPAD(val, drv_type), IPAD_CTRL1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (mode == LEGACY_MODE) {\n\t\tret = arasan_phy_write(host, 0x0, OTAP_DELAY);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = arasan_phy_write(host, 0x0, ITAP_DELAY);\n\t} else {\n\t\tret = arasan_phy_write(host, OTAPDLY(otap), OTAP_DELAY);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (mode != HS200_MODE)\n\t\t\tret = arasan_phy_write(host, ITAPDLY(itap), ITAP_DELAY);\n\t\telse\n\t\t\tret = arasan_phy_write(host, 0x0, ITAP_DELAY);\n\t}\n\tif (ret)\n\t\treturn ret;\n\tif (mode != LEGACY_MODE) {\n\t\tret = arasan_phy_write(host, trim, DLL_TRIM);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = arasan_phy_write(host, 0, DLL_STATUS);\n\tif (ret)\n\t\treturn ret;\n\tif (mode != LEGACY_MODE) {\n\t\tret = arasan_phy_write(host, FREQSEL(clk), DLL_STATUS);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = arasan_phy_sts_poll(host, DLL_STATUS, DLL_RDY_MASK);\n\t\tif (ret)\n\t\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int arasan_select_phy_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pci_slot *slot = sdhci_priv(host);\n\tstruct arasan_host *arasan_host = sdhci_pci_priv(slot);\n\tu8 clk;\n\n\tif (arasan_host->chg_clk == host->mmc->ios.clock)\n\t\treturn 0;\n\n\tarasan_host->chg_clk = host->mmc->ios.clock;\n\tif (host->mmc->ios.clock == 200000000)\n\t\tclk = 0x0;\n\telse if (host->mmc->ios.clock == 100000000)\n\t\tclk = 0x2;\n\telse if (host->mmc->ios.clock == 50000000)\n\t\tclk = 0x1;\n\telse\n\t\tclk = 0x0;\n\n\tif (host->mmc_host_ops.hs400_enhanced_strobe) {\n\t\tarasan_phy_set(host, ENHSTRB_MODE, 1, 0x0, 0x0,\n\t\t\t       DLLTRM_ICP, clk);\n\t} else {\n\t\tswitch (host->mmc->ios.timing) {\n\t\tcase MMC_TIMING_LEGACY:\n\t\t\tarasan_phy_set(host, LEGACY_MODE, 0x0, 0x0, 0x0,\n\t\t\t\t       0x0, 0x0);\n\t\t\tbreak;\n\t\tcase MMC_TIMING_MMC_HS:\n\t\tcase MMC_TIMING_SD_HS:\n\t\t\tarasan_phy_set(host, HISPD_MODE, 0x3, 0x0, 0x2,\n\t\t\t\t       DLLTRM_ICP, clk);\n\t\t\tbreak;\n\t\tcase MMC_TIMING_MMC_HS200:\n\t\tcase MMC_TIMING_UHS_SDR104:\n\t\t\tarasan_phy_set(host, HS200_MODE, 0x2,\n\t\t\t\t       host->mmc->ios.drv_type, 0x0,\n\t\t\t\t       DLLTRM_ICP, clk);\n\t\t\tbreak;\n\t\tcase MMC_TIMING_MMC_DDR52:\n\t\tcase MMC_TIMING_UHS_DDR50:\n\t\t\tarasan_phy_set(host, DDR50_MODE, 0x1, 0x0,\n\t\t\t\t       0x0, DLLTRM_ICP, clk);\n\t\t\tbreak;\n\t\tcase MMC_TIMING_MMC_HS400:\n\t\t\tarasan_phy_set(host, HS400_MODE, 0x1,\n\t\t\t\t       host->mmc->ios.drv_type, 0xa,\n\t\t\t\t       DLLTRM_ICP, clk);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int arasan_pci_probe_slot(struct sdhci_pci_slot *slot)\n{\n\tint err;\n\n\tslot->host->mmc->caps |= MMC_CAP_NONREMOVABLE | MMC_CAP_8_BIT_DATA;\n\terr = arasan_phy_init(slot->host);\n\tif (err)\n\t\treturn -ENODEV;\n\treturn 0;\n}\n\nstatic void arasan_sdhci_set_clock(struct sdhci_host *host, unsigned int clock)\n{\n\tsdhci_set_clock(host, clock);\n\n\t \n\tarasan_select_phy_clock(host);\n}\n\nstatic const struct sdhci_ops arasan_sdhci_pci_ops = {\n\t.set_clock\t= arasan_sdhci_set_clock,\n\t.enable_dma\t= sdhci_pci_enable_dma,\n\t.set_bus_width\t= sdhci_set_bus_width,\n\t.reset\t\t= sdhci_reset,\n\t.set_uhs_signaling\t= sdhci_set_uhs_signaling,\n};\n\nconst struct sdhci_pci_fixes sdhci_arasan = {\n\t.probe_slot = arasan_pci_probe_slot,\n\t.ops        = &arasan_sdhci_pci_ops,\n\t.priv_size  = sizeof(struct arasan_host),\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}