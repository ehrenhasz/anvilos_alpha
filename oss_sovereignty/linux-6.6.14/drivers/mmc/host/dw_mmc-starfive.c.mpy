{
  "module_name": "dw_mmc-starfive.c",
  "hash_id": "e2c28a9891c53c85b3c5c67edb87dfac88af2db67c4df76a7c0a3c5bafedaf77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc-starfive.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n\n#include \"dw_mmc.h\"\n#include \"dw_mmc-pltfm.h\"\n\n#define ALL_INT_CLR\t\t0x1ffff\n#define MAX_DELAY_CHAIN\t\t32\n\nstruct starfive_priv {\n\tstruct device *dev;\n\tstruct regmap *reg_syscon;\n\tu32 syscon_offset;\n\tu32 syscon_shift;\n\tu32 syscon_mask;\n};\n\nstatic void dw_mci_starfive_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tint ret;\n\tunsigned int clock;\n\n\tif (ios->timing == MMC_TIMING_MMC_DDR52 || ios->timing == MMC_TIMING_UHS_DDR50) {\n\t\tclock = (ios->clock > 50000000 && ios->clock <= 52000000) ? 100000000 : ios->clock;\n\t\tret = clk_set_rate(host->ciu_clk, clock);\n\t\tif (ret)\n\t\t\tdev_dbg(host->dev, \"Use an external frequency divider %uHz\\n\", ios->clock);\n\t\thost->bus_hz = clk_get_rate(host->ciu_clk);\n\t} else {\n\t\tdev_dbg(host->dev, \"Using the internal divider\\n\");\n\t}\n}\n\nstatic int dw_mci_starfive_execute_tuning(struct dw_mci_slot *slot,\n\t\t\t\t\t     u32 opcode)\n{\n\tstatic const int grade  = MAX_DELAY_CHAIN;\n\tstruct dw_mci *host = slot->host;\n\tstruct starfive_priv *priv = host->priv;\n\tint rise_point = -1, fall_point = -1;\n\tint err, prev_err = 0;\n\tint i;\n\tbool found = 0;\n\tu32 regval;\n\n\t \n\tfor (i = 0; i < grade; i++) {\n\t\tregval = i << priv->syscon_shift;\n\t\terr = regmap_update_bits(priv->reg_syscon, priv->syscon_offset,\n\t\t\t\t\t\tpriv->syscon_mask, regval);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmci_writel(host, RINTSTS, ALL_INT_CLR);\n\n\t\terr = mmc_send_tuning(slot->mmc, opcode, NULL);\n\t\tif (!err)\n\t\t\tfound = 1;\n\n\t\tif (i > 0) {\n\t\t\tif (err && !prev_err)\n\t\t\t\tfall_point = i - 1;\n\t\t\tif (!err && prev_err)\n\t\t\t\trise_point = i;\n\t\t}\n\n\t\tif (rise_point != -1 && fall_point != -1)\n\t\t\tgoto tuning_out;\n\n\t\tprev_err = err;\n\t\terr = 0;\n\t}\n\ntuning_out:\n\tif (found) {\n\t\tif (rise_point == -1)\n\t\t\trise_point = 0;\n\t\tif (fall_point == -1)\n\t\t\tfall_point = grade - 1;\n\t\tif (fall_point < rise_point) {\n\t\t\tif ((rise_point + fall_point) >\n\t\t\t    (grade - 1))\n\t\t\t\ti = fall_point / 2;\n\t\t\telse\n\t\t\t\ti = (rise_point + grade - 1) / 2;\n\t\t} else {\n\t\t\ti = (rise_point + fall_point) / 2;\n\t\t}\n\n\t\tregval = i << priv->syscon_shift;\n\t\terr = regmap_update_bits(priv->reg_syscon, priv->syscon_offset,\n\t\t\t\t\t\tpriv->syscon_mask, regval);\n\t\tif (err)\n\t\t\treturn err;\n\t\tmci_writel(host, RINTSTS, ALL_INT_CLR);\n\n\t\tdev_info(host->dev, \"Found valid delay chain! use it [delay=%d]\\n\", i);\n\t} else {\n\t\tdev_err(host->dev, \"No valid delay chain! use default\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tmci_writel(host, RINTSTS, ALL_INT_CLR);\n\treturn err;\n}\n\nstatic int dw_mci_starfive_parse_dt(struct dw_mci *host)\n{\n\tstruct of_phandle_args args;\n\tstruct starfive_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tret = of_parse_phandle_with_fixed_args(host->dev->of_node,\n\t\t\t\t\t\t\"starfive,sysreg\", 3, 0, &args);\n\tif (ret) {\n\t\tdev_err(host->dev, \"Failed to parse starfive,sysreg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tpriv->reg_syscon = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tif (IS_ERR(priv->reg_syscon))\n\t\treturn PTR_ERR(priv->reg_syscon);\n\n\tpriv->syscon_offset = args.args[0];\n\tpriv->syscon_shift  = args.args[1];\n\tpriv->syscon_mask   = args.args[2];\n\n\thost->priv = priv;\n\n\treturn 0;\n}\n\nstatic const struct dw_mci_drv_data starfive_data = {\n\t.common_caps\t\t= MMC_CAP_CMD23,\n\t.set_ios\t\t= dw_mci_starfive_set_ios,\n\t.parse_dt\t\t= dw_mci_starfive_parse_dt,\n\t.execute_tuning\t\t= dw_mci_starfive_execute_tuning,\n};\n\nstatic const struct of_device_id dw_mci_starfive_match[] = {\n\t{ .compatible = \"starfive,jh7110-mmc\",\n\t\t.data = &starfive_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_mci_starfive_match);\n\nstatic int dw_mci_starfive_probe(struct platform_device *pdev)\n{\n\treturn dw_mci_pltfm_register(pdev, &starfive_data);\n}\n\nstatic struct platform_driver dw_mci_starfive_driver = {\n\t.probe = dw_mci_starfive_probe,\n\t.remove_new = dw_mci_pltfm_remove,\n\t.driver = {\n\t\t.name = \"dwmmc_starfive\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = dw_mci_starfive_match,\n\t},\n};\nmodule_platform_driver(dw_mci_starfive_driver);\n\nMODULE_DESCRIPTION(\"StarFive JH7110 Specific DW-MSHC Driver Extension\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:dwmmc_starfive\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}