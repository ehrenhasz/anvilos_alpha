{
  "module_name": "moxart-mmc.c",
  "hash_id": "6f330ce04f8688cedb9b4b86283d9892d04d52be3b76047d3bd2350ecd7cdea4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/moxart-mmc.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/interrupt.h>\n#include <linux/blkdev.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sd.h>\n#include <linux/sched.h>\n#include <linux/io.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/clk.h>\n#include <linux/bitops.h>\n#include <linux/of_dma.h>\n#include <linux/spinlock.h>\n\n#define REG_COMMAND\t\t0\n#define REG_ARGUMENT\t\t4\n#define REG_RESPONSE0\t\t8\n#define REG_RESPONSE1\t\t12\n#define REG_RESPONSE2\t\t16\n#define REG_RESPONSE3\t\t20\n#define REG_RESPONSE_COMMAND\t24\n#define REG_DATA_CONTROL\t28\n#define REG_DATA_TIMER\t\t32\n#define REG_DATA_LENGTH\t\t36\n#define REG_STATUS\t\t40\n#define REG_CLEAR\t\t44\n#define REG_INTERRUPT_MASK\t48\n#define REG_POWER_CONTROL\t52\n#define REG_CLOCK_CONTROL\t56\n#define REG_BUS_WIDTH\t\t60\n#define REG_DATA_WINDOW\t\t64\n#define REG_FEATURE\t\t68\n#define REG_REVISION\t\t72\n\n \n#define CMD_SDC_RESET\t\tBIT(10)\n#define CMD_EN\t\t\tBIT(9)\n#define CMD_APP_CMD\t\tBIT(8)\n#define CMD_LONG_RSP\t\tBIT(7)\n#define CMD_NEED_RSP\t\tBIT(6)\n#define CMD_IDX_MASK\t\t0x3f\n\n \n#define RSP_CMD_APP\t\tBIT(6)\n#define RSP_CMD_IDX_MASK\t0x3f\n\n \n#define DCR_DATA_FIFO_RESET     BIT(8)\n#define DCR_DATA_THRES          BIT(7)\n#define DCR_DATA_EN\t\tBIT(6)\n#define DCR_DMA_EN\t\tBIT(5)\n#define DCR_DATA_WRITE\t\tBIT(4)\n#define DCR_BLK_SIZE\t\t0x0f\n\n \n#define DATA_LEN_MASK\t\t0xffffff\n\n \n#define WRITE_PROT\t\tBIT(12)\n#define CARD_DETECT\t\tBIT(11)\n \n#define CARD_CHANGE\t\tBIT(10)\n#define FIFO_ORUN\t\tBIT(9)\n#define FIFO_URUN\t\tBIT(8)\n#define DATA_END\t\tBIT(7)\n#define CMD_SENT\t\tBIT(6)\n#define DATA_CRC_OK\t\tBIT(5)\n#define RSP_CRC_OK\t\tBIT(4)\n#define DATA_TIMEOUT\t\tBIT(3)\n#define RSP_TIMEOUT\t\tBIT(2)\n#define DATA_CRC_FAIL\t\tBIT(1)\n#define RSP_CRC_FAIL\t\tBIT(0)\n\n#define MASK_RSP\t\t(RSP_TIMEOUT | RSP_CRC_FAIL | \\\n\t\t\t\t RSP_CRC_OK  | CARD_DETECT  | CMD_SENT)\n\n#define MASK_DATA\t\t(DATA_CRC_OK   | DATA_END | \\\n\t\t\t\t DATA_CRC_FAIL | DATA_TIMEOUT)\n\n#define MASK_INTR_PIO\t\t(FIFO_URUN | FIFO_ORUN | CARD_CHANGE)\n\n \n#define SD_POWER_ON\t\tBIT(4)\n#define SD_POWER_MASK\t\t0x0f\n\n \n#define CLK_HISPD\t\tBIT(9)\n#define CLK_OFF\t\t\tBIT(8)\n#define CLK_SD\t\t\tBIT(7)\n#define CLK_DIV_MASK\t\t0x7f\n\n \n#define BUS_WIDTH_4_SUPPORT\tBIT(3)\n#define BUS_WIDTH_4\t\tBIT(2)\n#define BUS_WIDTH_1\t\tBIT(0)\n\n#define MMC_VDD_360\t\t23\n#define MIN_POWER\t\t(MMC_VDD_360 - SD_POWER_MASK)\n#define MAX_RETRIES\t\t500000\n\nstruct moxart_host {\n\tspinlock_t\t\t\tlock;\n\n\tvoid __iomem\t\t\t*base;\n\n\tphys_addr_t\t\t\treg_phys;\n\n\tstruct dma_chan\t\t\t*dma_chan_tx;\n\tstruct dma_chan                 *dma_chan_rx;\n\tstruct dma_async_tx_descriptor\t*tx_desc;\n\tstruct mmc_host\t\t\t*mmc;\n\tstruct mmc_request\t\t*mrq;\n\tstruct scatterlist\t\t*cur_sg;\n\tstruct completion\t\tdma_complete;\n\tstruct completion\t\tpio_complete;\n\n\tu32\t\t\t\tnum_sg;\n\tu32\t\t\t\tdata_remain;\n\tu32\t\t\t\tdata_len;\n\tu32\t\t\t\tfifo_width;\n\tu32\t\t\t\ttimeout;\n\tu32\t\t\t\trate;\n\n\tlong\t\t\t\tsysclk;\n\n\tbool\t\t\t\thave_dma;\n\tbool\t\t\t\tis_removed;\n};\n\nstatic inline void moxart_init_sg(struct moxart_host *host,\n\t\t\t\t  struct mmc_data *data)\n{\n\thost->cur_sg = data->sg;\n\thost->num_sg = data->sg_len;\n\thost->data_remain = host->cur_sg->length;\n\n\tif (host->data_remain > host->data_len)\n\t\thost->data_remain = host->data_len;\n}\n\nstatic inline int moxart_next_sg(struct moxart_host *host)\n{\n\tint remain;\n\tstruct mmc_data *data = host->mrq->cmd->data;\n\n\thost->cur_sg++;\n\thost->num_sg--;\n\n\tif (host->num_sg > 0) {\n\t\thost->data_remain = host->cur_sg->length;\n\t\tremain = host->data_len - data->bytes_xfered;\n\t\tif (remain > 0 && remain < host->data_remain)\n\t\t\thost->data_remain = remain;\n\t}\n\n\treturn host->num_sg;\n}\n\nstatic int moxart_wait_for_status(struct moxart_host *host,\n\t\t\t\t  u32 mask, u32 *status)\n{\n\tint ret = -ETIMEDOUT;\n\tu32 i;\n\n\tfor (i = 0; i < MAX_RETRIES; i++) {\n\t\t*status = readl(host->base + REG_STATUS);\n\t\tif (!(*status & mask)) {\n\t\t\tudelay(5);\n\t\t\tcontinue;\n\t\t}\n\t\twritel(*status & mask, host->base + REG_CLEAR);\n\t\tret = 0;\n\t\tbreak;\n\t}\n\n\tif (ret)\n\t\tdev_err(mmc_dev(host->mmc), \"timed out waiting for status\\n\");\n\n\treturn ret;\n}\n\n\nstatic void moxart_send_command(struct moxart_host *host,\n\tstruct mmc_command *cmd)\n{\n\tu32 status, cmdctrl;\n\n\twritel(RSP_TIMEOUT  | RSP_CRC_OK |\n\t       RSP_CRC_FAIL | CMD_SENT, host->base + REG_CLEAR);\n\twritel(cmd->arg, host->base + REG_ARGUMENT);\n\n\tcmdctrl = cmd->opcode & CMD_IDX_MASK;\n\tif (cmdctrl == SD_APP_SET_BUS_WIDTH    || cmdctrl == SD_APP_OP_COND   ||\n\t    cmdctrl == SD_APP_SEND_SCR         || cmdctrl == SD_APP_SD_STATUS ||\n\t    cmdctrl == SD_APP_SEND_NUM_WR_BLKS)\n\t\tcmdctrl |= CMD_APP_CMD;\n\n\tif (cmd->flags & MMC_RSP_PRESENT)\n\t\tcmdctrl |= CMD_NEED_RSP;\n\n\tif (cmd->flags & MMC_RSP_136)\n\t\tcmdctrl |= CMD_LONG_RSP;\n\n\twritel(cmdctrl | CMD_EN, host->base + REG_COMMAND);\n\n\tif (moxart_wait_for_status(host, MASK_RSP, &status) == -ETIMEDOUT)\n\t\tcmd->error = -ETIMEDOUT;\n\n\tif (status & RSP_TIMEOUT) {\n\t\tcmd->error = -ETIMEDOUT;\n\t\treturn;\n\t}\n\tif (status & RSP_CRC_FAIL) {\n\t\tcmd->error = -EIO;\n\t\treturn;\n\t}\n\tif (status & RSP_CRC_OK) {\n\t\tif (cmd->flags & MMC_RSP_136) {\n\t\t\tcmd->resp[3] = readl(host->base + REG_RESPONSE0);\n\t\t\tcmd->resp[2] = readl(host->base + REG_RESPONSE1);\n\t\t\tcmd->resp[1] = readl(host->base + REG_RESPONSE2);\n\t\t\tcmd->resp[0] = readl(host->base + REG_RESPONSE3);\n\t\t} else {\n\t\t\tcmd->resp[0] = readl(host->base + REG_RESPONSE0);\n\t\t}\n\t}\n}\n\nstatic void moxart_dma_complete(void *param)\n{\n\tstruct moxart_host *host = param;\n\n\tcomplete(&host->dma_complete);\n}\n\nstatic void moxart_transfer_dma(struct mmc_data *data, struct moxart_host *host)\n{\n\tu32 len, dir_slave;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_chan *dma_chan;\n\n\tif (host->data_len == data->bytes_xfered)\n\t\treturn;\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\tdma_chan = host->dma_chan_tx;\n\t\tdir_slave = DMA_MEM_TO_DEV;\n\t} else {\n\t\tdma_chan = host->dma_chan_rx;\n\t\tdir_slave = DMA_DEV_TO_MEM;\n\t}\n\n\tlen = dma_map_sg(dma_chan->device->dev, data->sg,\n\t\t\t data->sg_len, mmc_get_dma_dir(data));\n\n\tif (len > 0) {\n\t\tdesc = dmaengine_prep_slave_sg(dma_chan, data->sg,\n\t\t\t\t\t       len, dir_slave,\n\t\t\t\t\t       DMA_PREP_INTERRUPT |\n\t\t\t\t\t       DMA_CTRL_ACK);\n\t} else {\n\t\tdev_err(mmc_dev(host->mmc), \"dma_map_sg returned zero length\\n\");\n\t}\n\n\tif (desc) {\n\t\thost->tx_desc = desc;\n\t\tdesc->callback = moxart_dma_complete;\n\t\tdesc->callback_param = host;\n\t\tdmaengine_submit(desc);\n\t\tdma_async_issue_pending(dma_chan);\n\t}\n\n\tdata->bytes_xfered += host->data_remain;\n\n\twait_for_completion_interruptible_timeout(&host->dma_complete,\n\t\t\t\t\t\t  host->timeout);\n\n\tdma_unmap_sg(dma_chan->device->dev,\n\t\t     data->sg, data->sg_len,\n\t\t     mmc_get_dma_dir(data));\n}\n\n\nstatic void moxart_transfer_pio(struct moxart_host *host)\n{\n\tstruct mmc_data *data = host->mrq->cmd->data;\n\tu32 *sgp, len = 0, remain, status;\n\n\tif (host->data_len == data->bytes_xfered)\n\t\treturn;\n\n\tsgp = sg_virt(host->cur_sg);\n\tremain = host->data_remain;\n\n\tif (data->flags & MMC_DATA_WRITE) {\n\t\twhile (remain > 0) {\n\t\t\tif (moxart_wait_for_status(host, FIFO_URUN, &status)\n\t\t\t     == -ETIMEDOUT) {\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\t\tcomplete(&host->pio_complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (len = 0; len < remain && len < host->fifo_width;) {\n\t\t\t\tiowrite32(*sgp, host->base + REG_DATA_WINDOW);\n\t\t\t\tsgp++;\n\t\t\t\tlen += 4;\n\t\t\t}\n\t\t\tremain -= len;\n\t\t}\n\n\t} else {\n\t\twhile (remain > 0) {\n\t\t\tif (moxart_wait_for_status(host, FIFO_ORUN, &status)\n\t\t\t    == -ETIMEDOUT) {\n\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\t\tcomplete(&host->pio_complete);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (len = 0; len < remain && len < host->fifo_width;) {\n\t\t\t\t*sgp = ioread32(host->base + REG_DATA_WINDOW);\n\t\t\t\tsgp++;\n\t\t\t\tlen += 4;\n\t\t\t}\n\t\t\tremain -= len;\n\t\t}\n\t}\n\n\tdata->bytes_xfered += host->data_remain - remain;\n\thost->data_remain = remain;\n\n\tif (host->data_len != data->bytes_xfered)\n\t\tmoxart_next_sg(host);\n\telse\n\t\tcomplete(&host->pio_complete);\n}\n\nstatic void moxart_prepare_data(struct moxart_host *host)\n{\n\tstruct mmc_data *data = host->mrq->cmd->data;\n\tu32 datactrl;\n\tint blksz_bits;\n\n\tif (!data)\n\t\treturn;\n\n\thost->data_len = data->blocks * data->blksz;\n\tblksz_bits = ffs(data->blksz) - 1;\n\tBUG_ON(1 << blksz_bits != data->blksz);\n\n\tmoxart_init_sg(host, data);\n\n\tdatactrl = DCR_DATA_EN | (blksz_bits & DCR_BLK_SIZE);\n\n\tif (data->flags & MMC_DATA_WRITE)\n\t\tdatactrl |= DCR_DATA_WRITE;\n\n\tif ((host->data_len > host->fifo_width) && host->have_dma)\n\t\tdatactrl |= DCR_DMA_EN;\n\n\twritel(DCR_DATA_FIFO_RESET, host->base + REG_DATA_CONTROL);\n\twritel(MASK_DATA | FIFO_URUN | FIFO_ORUN, host->base + REG_CLEAR);\n\twritel(host->rate, host->base + REG_DATA_TIMER);\n\twritel(host->data_len, host->base + REG_DATA_LENGTH);\n\twritel(datactrl, host->base + REG_DATA_CONTROL);\n}\n\nstatic void moxart_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct moxart_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tu32 status;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tinit_completion(&host->dma_complete);\n\tinit_completion(&host->pio_complete);\n\n\thost->mrq = mrq;\n\n\tif (readl(host->base + REG_STATUS) & CARD_DETECT) {\n\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\tgoto request_done;\n\t}\n\n\tmoxart_prepare_data(host);\n\tmoxart_send_command(host, host->mrq->cmd);\n\n\tif (mrq->cmd->data) {\n\t\tif ((host->data_len > host->fifo_width) && host->have_dma) {\n\n\t\t\twritel(CARD_CHANGE, host->base + REG_INTERRUPT_MASK);\n\n\t\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\t\tmoxart_transfer_dma(mrq->cmd->data, host);\n\n\t\t\tspin_lock_irqsave(&host->lock, flags);\n\t\t} else {\n\n\t\t\twritel(MASK_INTR_PIO, host->base + REG_INTERRUPT_MASK);\n\n\t\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\t\t \n\t\t\twait_for_completion_interruptible_timeout(&host->pio_complete,\n\t\t\t\t\t\t\t\t  host->timeout);\n\n\t\t\tspin_lock_irqsave(&host->lock, flags);\n\t\t}\n\n\t\tif (host->is_removed) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"card removed\\n\");\n\t\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\t\tgoto request_done;\n\t\t}\n\n\t\tif (moxart_wait_for_status(host, MASK_DATA, &status)\n\t\t    == -ETIMEDOUT) {\n\t\t\tmrq->cmd->data->error = -ETIMEDOUT;\n\t\t\tgoto request_done;\n\t\t}\n\n\t\tif (status & DATA_CRC_FAIL)\n\t\t\tmrq->cmd->data->error = -ETIMEDOUT;\n\n\t\tif (mrq->cmd->data->stop)\n\t\t\tmoxart_send_command(host, mrq->cmd->data->stop);\n\t}\n\nrequest_done:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic irqreturn_t moxart_irq(int irq, void *devid)\n{\n\tstruct moxart_host *host = (struct moxart_host *)devid;\n\tu32 status;\n\n\tspin_lock(&host->lock);\n\n\tstatus = readl(host->base + REG_STATUS);\n\tif (status & CARD_CHANGE) {\n\t\thost->is_removed = status & CARD_DETECT;\n\t\tif (host->is_removed && host->have_dma) {\n\t\t\tdmaengine_terminate_all(host->dma_chan_tx);\n\t\t\tdmaengine_terminate_all(host->dma_chan_rx);\n\t\t}\n\t\thost->mrq = NULL;\n\t\twritel(MASK_INTR_PIO, host->base + REG_CLEAR);\n\t\twritel(CARD_CHANGE, host->base + REG_INTERRUPT_MASK);\n\t\tmmc_detect_change(host->mmc, 0);\n\t}\n\tif (status & (FIFO_ORUN | FIFO_URUN) && host->mrq)\n\t\tmoxart_transfer_pio(host);\n\n\tspin_unlock(&host->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void moxart_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct moxart_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\tu8 power, div;\n\tu32 ctrl;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (ios->clock) {\n\t\tfor (div = 0; div < CLK_DIV_MASK; ++div) {\n\t\t\tif (ios->clock >= host->sysclk / (2 * (div + 1)))\n\t\t\t\tbreak;\n\t\t}\n\t\tctrl = CLK_SD | div;\n\t\thost->rate = host->sysclk / (2 * (div + 1));\n\t\tif (host->rate > host->sysclk)\n\t\t\tctrl |= CLK_HISPD;\n\t\twritel(ctrl, host->base + REG_CLOCK_CONTROL);\n\t}\n\n\tif (ios->power_mode == MMC_POWER_OFF) {\n\t\twritel(readl(host->base + REG_POWER_CONTROL) & ~SD_POWER_ON,\n\t\t       host->base + REG_POWER_CONTROL);\n\t} else {\n\t\tif (ios->vdd < MIN_POWER)\n\t\t\tpower = 0;\n\t\telse\n\t\t\tpower = ios->vdd - MIN_POWER;\n\n\t\twritel(SD_POWER_ON | (u32) power,\n\t\t       host->base + REG_POWER_CONTROL);\n\t}\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_4:\n\t\twritel(BUS_WIDTH_4, host->base + REG_BUS_WIDTH);\n\t\tbreak;\n\tdefault:\n\t\twritel(BUS_WIDTH_1, host->base + REG_BUS_WIDTH);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\n\nstatic int moxart_get_ro(struct mmc_host *mmc)\n{\n\tstruct moxart_host *host = mmc_priv(mmc);\n\n\treturn !!(readl(host->base + REG_STATUS) & WRITE_PROT);\n}\n\nstatic const struct mmc_host_ops moxart_ops = {\n\t.request = moxart_request,\n\t.set_ios = moxart_set_ios,\n\t.get_ro = moxart_get_ro,\n};\n\nstatic int moxart_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct resource res_mmc;\n\tstruct mmc_host *mmc;\n\tstruct moxart_host *host = NULL;\n\tstruct dma_slave_config cfg;\n\tstruct clk *clk;\n\tvoid __iomem *reg_mmc;\n\tint irq, ret;\n\tu32 i;\n\n\tmmc = mmc_alloc_host(sizeof(struct moxart_host), dev);\n\tif (!mmc) {\n\t\tdev_err(dev, \"mmc_alloc_host failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto out_mmc;\n\t}\n\n\tret = of_address_to_resource(node, 0, &res_mmc);\n\tif (ret) {\n\t\tdev_err(dev, \"of_address_to_resource failed\\n\");\n\t\tgoto out_mmc;\n\t}\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (irq <= 0) {\n\t\tdev_err(dev, \"irq_of_parse_and_map failed\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out_mmc;\n\t}\n\n\tclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(clk)) {\n\t\tret = PTR_ERR(clk);\n\t\tgoto out_mmc;\n\t}\n\n\treg_mmc = devm_ioremap_resource(dev, &res_mmc);\n\tif (IS_ERR(reg_mmc)) {\n\t\tret = PTR_ERR(reg_mmc);\n\t\tgoto out_mmc;\n\t}\n\n\tret = mmc_of_parse(mmc);\n\tif (ret)\n\t\tgoto out_mmc;\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->base = reg_mmc;\n\thost->reg_phys = res_mmc.start;\n\thost->timeout = msecs_to_jiffies(1000);\n\thost->sysclk = clk_get_rate(clk);\n\thost->fifo_width = readl(host->base + REG_FEATURE) << 2;\n\thost->dma_chan_tx = dma_request_chan(dev, \"tx\");\n\thost->dma_chan_rx = dma_request_chan(dev, \"rx\");\n\n\tspin_lock_init(&host->lock);\n\n\tmmc->ops = &moxart_ops;\n\tmmc->f_max = DIV_ROUND_CLOSEST(host->sysclk, 2);\n\tmmc->f_min = DIV_ROUND_CLOSEST(host->sysclk, CLK_DIV_MASK * 2);\n\tmmc->ocr_avail = 0xffff00;\t \n\tmmc->max_blk_size = 2048;  \n\tmmc->max_req_size = DATA_LEN_MASK;  \n\tmmc->max_blk_count = mmc->max_req_size / 512;\n\n\tif (IS_ERR(host->dma_chan_tx) || IS_ERR(host->dma_chan_rx)) {\n\t\tif (PTR_ERR(host->dma_chan_tx) == -EPROBE_DEFER ||\n\t\t    PTR_ERR(host->dma_chan_rx) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto out;\n\t\t}\n\t\tif (!IS_ERR(host->dma_chan_tx)) {\n\t\t\tdma_release_channel(host->dma_chan_tx);\n\t\t\thost->dma_chan_tx = NULL;\n\t\t}\n\t\tif (!IS_ERR(host->dma_chan_rx)) {\n\t\t\tdma_release_channel(host->dma_chan_rx);\n\t\t\thost->dma_chan_rx = NULL;\n\t\t}\n\t\tdev_dbg(dev, \"PIO mode transfer enabled\\n\");\n\t\thost->have_dma = false;\n\n\t\tmmc->max_seg_size = mmc->max_req_size;\n\t} else {\n\t\tdev_dbg(dev, \"DMA channels found (%p,%p)\\n\",\n\t\t\t host->dma_chan_tx, host->dma_chan_rx);\n\t\thost->have_dma = true;\n\n\t\tmemset(&cfg, 0, sizeof(cfg));\n\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\n\t\tcfg.direction = DMA_MEM_TO_DEV;\n\t\tcfg.src_addr = 0;\n\t\tcfg.dst_addr = host->reg_phys + REG_DATA_WINDOW;\n\t\tdmaengine_slave_config(host->dma_chan_tx, &cfg);\n\n\t\tcfg.direction = DMA_DEV_TO_MEM;\n\t\tcfg.src_addr = host->reg_phys + REG_DATA_WINDOW;\n\t\tcfg.dst_addr = 0;\n\t\tdmaengine_slave_config(host->dma_chan_rx, &cfg);\n\n\t\tmmc->max_seg_size = min3(mmc->max_req_size,\n\t\t\tdma_get_max_seg_size(host->dma_chan_rx->device->dev),\n\t\t\tdma_get_max_seg_size(host->dma_chan_tx->device->dev));\n\t}\n\n\tif (readl(host->base + REG_BUS_WIDTH) & BUS_WIDTH_4_SUPPORT)\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\n\twritel(0, host->base + REG_INTERRUPT_MASK);\n\n\twritel(CMD_SDC_RESET, host->base + REG_COMMAND);\n\tfor (i = 0; i < MAX_RETRIES; i++) {\n\t\tif (!(readl(host->base + REG_COMMAND) & CMD_SDC_RESET))\n\t\t\tbreak;\n\t\tudelay(5);\n\t}\n\n\tret = devm_request_irq(dev, irq, moxart_irq, 0, \"moxart-mmc\", host);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_set_drvdata(dev, mmc);\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto out;\n\n\tdev_dbg(dev, \"IRQ=%d, FIFO is %d bytes\\n\", irq, host->fifo_width);\n\n\treturn 0;\n\nout:\n\tif (!IS_ERR_OR_NULL(host->dma_chan_tx))\n\t\tdma_release_channel(host->dma_chan_tx);\n\tif (!IS_ERR_OR_NULL(host->dma_chan_rx))\n\t\tdma_release_channel(host->dma_chan_rx);\nout_mmc:\n\tif (mmc)\n\t\tmmc_free_host(mmc);\n\treturn ret;\n}\n\nstatic void moxart_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc = dev_get_drvdata(&pdev->dev);\n\tstruct moxart_host *host = mmc_priv(mmc);\n\n\tif (!IS_ERR_OR_NULL(host->dma_chan_tx))\n\t\tdma_release_channel(host->dma_chan_tx);\n\tif (!IS_ERR_OR_NULL(host->dma_chan_rx))\n\t\tdma_release_channel(host->dma_chan_rx);\n\tmmc_remove_host(mmc);\n\n\twritel(0, host->base + REG_INTERRUPT_MASK);\n\twritel(0, host->base + REG_POWER_CONTROL);\n\twritel(readl(host->base + REG_CLOCK_CONTROL) | CLK_OFF,\n\t       host->base + REG_CLOCK_CONTROL);\n\tmmc_free_host(mmc);\n}\n\nstatic const struct of_device_id moxart_mmc_match[] = {\n\t{ .compatible = \"moxa,moxart-mmc\" },\n\t{ .compatible = \"faraday,ftsdc010\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, moxart_mmc_match);\n\nstatic struct platform_driver moxart_mmc_driver = {\n\t.probe      = moxart_probe,\n\t.remove_new = moxart_remove,\n\t.driver     = {\n\t\t.name\t\t= \"mmc-moxart\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= moxart_mmc_match,\n\t},\n};\nmodule_platform_driver(moxart_mmc_driver);\n\nMODULE_ALIAS(\"platform:mmc-moxart\");\nMODULE_DESCRIPTION(\"MOXA ART MMC driver\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Jonas Jensen <jonas.jensen@gmail.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}