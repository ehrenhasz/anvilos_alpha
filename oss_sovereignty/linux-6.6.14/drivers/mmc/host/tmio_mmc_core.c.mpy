{
  "module_name": "tmio_mmc_core.c",
  "hash_id": "0df8fb8883ec0a49afe88a0a16e6e19dff7869c1a9ffc7f0df9ea7df9a97ead5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/tmio_mmc_core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/mfd/tmio.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/pagemap.h>\n#include <linux/platform_device.h>\n#include <linux/pm_qos.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/mmc/sdio.h>\n#include <linux/scatterlist.h>\n#include <linux/sizes.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\n#include \"tmio_mmc.h\"\n\nstatic inline void tmio_mmc_start_dma(struct tmio_mmc_host *host,\n\t\t\t\t      struct mmc_data *data)\n{\n\tif (host->dma_ops)\n\t\thost->dma_ops->start(host, data);\n}\n\nstatic inline void tmio_mmc_end_dma(struct tmio_mmc_host *host)\n{\n\tif (host->dma_ops && host->dma_ops->end)\n\t\thost->dma_ops->end(host);\n}\n\nstatic inline void tmio_mmc_enable_dma(struct tmio_mmc_host *host, bool enable)\n{\n\tif (host->dma_ops)\n\t\thost->dma_ops->enable(host, enable);\n}\n\nstatic inline void tmio_mmc_request_dma(struct tmio_mmc_host *host,\n\t\t\t\t\tstruct tmio_mmc_data *pdata)\n{\n\tif (host->dma_ops) {\n\t\thost->dma_ops->request(host, pdata);\n\t} else {\n\t\thost->chan_tx = NULL;\n\t\thost->chan_rx = NULL;\n\t}\n}\n\nstatic inline void tmio_mmc_release_dma(struct tmio_mmc_host *host)\n{\n\tif (host->dma_ops)\n\t\thost->dma_ops->release(host);\n}\n\nstatic inline void tmio_mmc_abort_dma(struct tmio_mmc_host *host)\n{\n\tif (host->dma_ops)\n\t\thost->dma_ops->abort(host);\n}\n\nstatic inline void tmio_mmc_dataend_dma(struct tmio_mmc_host *host)\n{\n\tif (host->dma_ops)\n\t\thost->dma_ops->dataend(host);\n}\n\nvoid tmio_mmc_enable_mmc_irqs(struct tmio_mmc_host *host, u32 i)\n{\n\thost->sdcard_irq_mask &= ~(i & TMIO_MASK_IRQ);\n\tsd_ctrl_write32_as_16_and_16(host, CTL_IRQ_MASK, host->sdcard_irq_mask);\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_enable_mmc_irqs);\n\nvoid tmio_mmc_disable_mmc_irqs(struct tmio_mmc_host *host, u32 i)\n{\n\thost->sdcard_irq_mask |= (i & TMIO_MASK_IRQ);\n\tsd_ctrl_write32_as_16_and_16(host, CTL_IRQ_MASK, host->sdcard_irq_mask);\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_disable_mmc_irqs);\n\nstatic void tmio_mmc_ack_mmc_irqs(struct tmio_mmc_host *host, u32 i)\n{\n\tsd_ctrl_write32_as_16_and_16(host, CTL_STATUS, ~i);\n}\n\nstatic void tmio_mmc_init_sg(struct tmio_mmc_host *host, struct mmc_data *data)\n{\n\thost->sg_len = data->sg_len;\n\thost->sg_ptr = data->sg;\n\thost->sg_orig = data->sg;\n\thost->sg_off = 0;\n}\n\nstatic int tmio_mmc_next_sg(struct tmio_mmc_host *host)\n{\n\thost->sg_ptr = sg_next(host->sg_ptr);\n\thost->sg_off = 0;\n\treturn --host->sg_len;\n}\n\n#define CMDREQ_TIMEOUT\t5000\n\nstatic void tmio_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\n\tif (enable && !host->sdio_irq_enabled) {\n\t\tu16 sdio_status;\n\n\t\t \n\t\tpm_runtime_get_sync(mmc_dev(mmc));\n\n\t\thost->sdio_irq_enabled = true;\n\t\thost->sdio_irq_mask = TMIO_SDIO_MASK_ALL & ~TMIO_SDIO_STAT_IOIRQ;\n\n\t\t \n\t\tsdio_status = sd_ctrl_read16(host, CTL_SDIO_STATUS) & ~TMIO_SDIO_MASK_ALL;\n\t\tif (host->pdata->flags & TMIO_MMC_SDIO_STATUS_SETBITS)\n\t\t\tsdio_status |= TMIO_SDIO_SETBITS_MASK;\n\t\tsd_ctrl_write16(host, CTL_SDIO_STATUS, sdio_status);\n\n\t\tsd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);\n\t} else if (!enable && host->sdio_irq_enabled) {\n\t\thost->sdio_irq_mask = TMIO_SDIO_MASK_ALL;\n\t\tsd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);\n\n\t\thost->sdio_irq_enabled = false;\n\t\tpm_runtime_mark_last_busy(mmc_dev(mmc));\n\t\tpm_runtime_put_autosuspend(mmc_dev(mmc));\n\t}\n}\n\nstatic void tmio_mmc_set_bus_width(struct tmio_mmc_host *host,\n\t\t\t\t   unsigned char bus_width)\n{\n\tu16 reg = sd_ctrl_read16(host, CTL_SD_MEM_CARD_OPT)\n\t\t\t\t& ~(CARD_OPT_WIDTH | CARD_OPT_WIDTH8);\n\n\t \n\tif (bus_width == MMC_BUS_WIDTH_1)\n\t\treg |= CARD_OPT_WIDTH;\n\telse if (bus_width == MMC_BUS_WIDTH_8)\n\t\treg |= CARD_OPT_WIDTH8;\n\n\tsd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, reg);\n}\n\nstatic void tmio_mmc_reset(struct tmio_mmc_host *host, bool preserve)\n{\n\tu16 card_opt, clk_ctrl, sdif_mode;\n\n\tif (preserve) {\n\t\tcard_opt = sd_ctrl_read16(host, CTL_SD_MEM_CARD_OPT);\n\t\tclk_ctrl = sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL);\n\t\tif (host->pdata->flags & TMIO_MMC_MIN_RCAR2)\n\t\t\tsdif_mode = sd_ctrl_read16(host, CTL_SDIF_MODE);\n\t}\n\n\t \n\tsd_ctrl_write16(host, CTL_RESET_SD, 0x0000);\n\tusleep_range(10000, 11000);\n\tsd_ctrl_write16(host, CTL_RESET_SD, 0x0001);\n\tusleep_range(10000, 11000);\n\n\ttmio_mmc_abort_dma(host);\n\n\tif (host->reset)\n\t\thost->reset(host, preserve);\n\n\tsd_ctrl_write32_as_16_and_16(host, CTL_IRQ_MASK, host->sdcard_irq_mask_all);\n\thost->sdcard_irq_mask = host->sdcard_irq_mask_all;\n\n\tif (host->native_hotplug)\n\t\ttmio_mmc_enable_mmc_irqs(host,\n\t\t\t\tTMIO_STAT_CARD_REMOVE | TMIO_STAT_CARD_INSERT);\n\n\ttmio_mmc_set_bus_width(host, host->mmc->ios.bus_width);\n\n\tif (host->pdata->flags & TMIO_MMC_SDIO_IRQ) {\n\t\tsd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);\n\t\tsd_ctrl_write16(host, CTL_TRANSACTION_CTL, 0x0001);\n\t}\n\n\tif (preserve) {\n\t\tsd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, card_opt);\n\t\tsd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, clk_ctrl);\n\t\tif (host->pdata->flags & TMIO_MMC_MIN_RCAR2)\n\t\t\tsd_ctrl_write16(host, CTL_SDIF_MODE, sdif_mode);\n\t}\n\n\tif (host->mmc->card)\n\t\tmmc_retune_needed(host->mmc);\n}\n\nstatic void tmio_mmc_reset_work(struct work_struct *work)\n{\n\tstruct tmio_mmc_host *host = container_of(work, struct tmio_mmc_host,\n\t\t\t\t\t\t  delayed_reset_work.work);\n\tstruct mmc_request *mrq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tmrq = host->mrq;\n\n\t \n\tif (IS_ERR_OR_NULL(mrq) ||\n\t    time_is_after_jiffies(host->last_req_ts +\n\t\t\t\t  msecs_to_jiffies(CMDREQ_TIMEOUT))) {\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\treturn;\n\t}\n\n\tdev_warn(&host->pdev->dev,\n\t\t \"timeout waiting for hardware interrupt (CMD%u)\\n\",\n\t\t mrq->cmd->opcode);\n\n\tif (host->data)\n\t\thost->data->error = -ETIMEDOUT;\n\telse if (host->cmd)\n\t\thost->cmd->error = -ETIMEDOUT;\n\telse\n\t\tmrq->cmd->error = -ETIMEDOUT;\n\n\thost->cmd = NULL;\n\thost->data = NULL;\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\ttmio_mmc_reset(host, true);\n\n\t \n\thost->mrq = NULL;\n\tmmc_request_done(host->mmc, mrq);\n}\n\n \n#define APP_CMD        0x0040\n#define RESP_NONE      0x0300\n#define RESP_R1        0x0400\n#define RESP_R1B       0x0500\n#define RESP_R2        0x0600\n#define RESP_R3        0x0700\n#define DATA_PRESENT   0x0800\n#define TRANSFER_READ  0x1000\n#define TRANSFER_MULTI 0x2000\n#define SECURITY_CMD   0x4000\n#define NO_CMD12_ISSUE 0x4000  \n\nstatic int tmio_mmc_start_command(struct tmio_mmc_host *host,\n\t\t\t\t  struct mmc_command *cmd)\n{\n\tstruct mmc_data *data = host->data;\n\tint c = cmd->opcode;\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE: c |= RESP_NONE; break;\n\tcase MMC_RSP_R1:\n\tcase MMC_RSP_R1_NO_CRC:\n\t\t\t   c |= RESP_R1;   break;\n\tcase MMC_RSP_R1B:  c |= RESP_R1B;  break;\n\tcase MMC_RSP_R2:   c |= RESP_R2;   break;\n\tcase MMC_RSP_R3:   c |= RESP_R3;   break;\n\tdefault:\n\t\tpr_debug(\"Unknown response type %d\\n\", mmc_resp_type(cmd));\n\t\treturn -EINVAL;\n\t}\n\n\thost->cmd = cmd;\n\n \n\tif (data) {\n\t\tc |= DATA_PRESENT;\n\t\tif (data->blocks > 1) {\n\t\t\tsd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, TMIO_STOP_SEC);\n\t\t\tc |= TRANSFER_MULTI;\n\n\t\t\t \n\t\t\tif ((host->pdata->flags & TMIO_MMC_HAVE_CMD12_CTRL) &&\n\t\t\t    (cmd->opcode == SD_IO_RW_EXTENDED || host->mrq->sbc))\n\t\t\t\tc |= NO_CMD12_ISSUE;\n\t\t}\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tc |= TRANSFER_READ;\n\t}\n\n\ttmio_mmc_enable_mmc_irqs(host, TMIO_MASK_CMD);\n\n\t \n\tsd_ctrl_write32_as_16_and_16(host, CTL_ARG_REG, cmd->arg);\n\tsd_ctrl_write16(host, CTL_SD_CMD, c);\n\n\treturn 0;\n}\n\nstatic void tmio_mmc_transfer_data(struct tmio_mmc_host *host,\n\t\t\t\t   unsigned short *buf,\n\t\t\t\t   unsigned int count)\n{\n\tint is_read = host->data->flags & MMC_DATA_READ;\n\tu8  *buf8;\n\n\t \n\tif (host->pdata->flags & TMIO_MMC_32BIT_DATA_PORT) {\n\t\tu32 data = 0;\n\t\tu32 *buf32 = (u32 *)buf;\n\n\t\tif (is_read)\n\t\t\tsd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, buf32,\n\t\t\t\t\t   count >> 2);\n\t\telse\n\t\t\tsd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, buf32,\n\t\t\t\t\t    count >> 2);\n\n\t\t \n\t\tif (!(count & 0x3))\n\t\t\treturn;\n\n\t\tbuf32 += count >> 2;\n\t\tcount %= 4;\n\n\t\tif (is_read) {\n\t\t\tsd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, &data, 1);\n\t\t\tmemcpy(buf32, &data, count);\n\t\t} else {\n\t\t\tmemcpy(&data, buf32, count);\n\t\t\tsd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, &data, 1);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (is_read)\n\t\tsd_ctrl_read16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);\n\telse\n\t\tsd_ctrl_write16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);\n\n\t \n\tif (!(count & 0x1))\n\t\treturn;\n\n\t \n\tbuf8 = (u8 *)(buf + (count >> 1));\n\n\t \n\tif (is_read)\n\t\t*buf8 = sd_ctrl_read16(host, CTL_SD_DATA_PORT) & 0xff;\n\telse\n\t\tsd_ctrl_write16(host, CTL_SD_DATA_PORT, *buf8);\n}\n\n \nstatic void tmio_mmc_pio_irq(struct tmio_mmc_host *host)\n{\n\tstruct mmc_data *data = host->data;\n\tvoid *sg_virt;\n\tunsigned short *buf;\n\tunsigned int count;\n\n\tif (host->dma_on) {\n\t\tpr_err(\"PIO IRQ in DMA mode!\\n\");\n\t\treturn;\n\t} else if (!data) {\n\t\tpr_debug(\"Spurious PIO IRQ\\n\");\n\t\treturn;\n\t}\n\n\tsg_virt = kmap_local_page(sg_page(host->sg_ptr));\n\tbuf = (unsigned short *)(sg_virt + host->sg_ptr->offset + host->sg_off);\n\n\tcount = host->sg_ptr->length - host->sg_off;\n\tif (count > data->blksz)\n\t\tcount = data->blksz;\n\n\tpr_debug(\"count: %08x offset: %08x flags %08x\\n\",\n\t\t count, host->sg_off, data->flags);\n\n\t \n\ttmio_mmc_transfer_data(host, buf, count);\n\n\thost->sg_off += count;\n\n\tkunmap_local(sg_virt);\n\n\tif (host->sg_off == host->sg_ptr->length)\n\t\ttmio_mmc_next_sg(host);\n}\n\nstatic void tmio_mmc_check_bounce_buffer(struct tmio_mmc_host *host)\n{\n\tif (host->sg_ptr == &host->bounce_sg) {\n\t\tvoid *sg_virt = kmap_local_page(sg_page(host->sg_orig));\n\n\t\tmemcpy(sg_virt + host->sg_orig->offset, host->bounce_buf,\n\t\t       host->bounce_sg.length);\n\t\tkunmap_local(sg_virt);\n\t}\n}\n\n \nvoid tmio_mmc_do_data_irq(struct tmio_mmc_host *host)\n{\n\tstruct mmc_data *data = host->data;\n\tstruct mmc_command *stop;\n\n\thost->data = NULL;\n\n\tif (!data) {\n\t\tdev_warn(&host->pdev->dev, \"Spurious data end IRQ\\n\");\n\t\treturn;\n\t}\n\tstop = data->stop;\n\n\t \n\tif (!data->error)\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\telse\n\t\tdata->bytes_xfered = 0;\n\n\tpr_debug(\"Completed data request\\n\");\n\n\t \n\n\tif (data->flags & MMC_DATA_READ) {\n\t\tif (host->dma_on)\n\t\t\ttmio_mmc_check_bounce_buffer(host);\n\t\tdev_dbg(&host->pdev->dev, \"Complete Rx request %p\\n\",\n\t\t\thost->mrq);\n\t} else {\n\t\tdev_dbg(&host->pdev->dev, \"Complete Tx request %p\\n\",\n\t\t\thost->mrq);\n\t}\n\n\tif (stop && !host->mrq->sbc) {\n\t\tif (stop->opcode != MMC_STOP_TRANSMISSION || stop->arg)\n\t\t\tdev_err(&host->pdev->dev, \"unsupported stop: CMD%u,0x%x. We did CMD12,0\\n\",\n\t\t\t\tstop->opcode, stop->arg);\n\n\t\t \n\t\tstop->resp[0] = sd_ctrl_read16_and_16_as_32(host, CTL_RESPONSE);\n\n\t\tsd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, 0);\n\t}\n\n\tschedule_work(&host->done);\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_do_data_irq);\n\nstatic void tmio_mmc_data_irq(struct tmio_mmc_host *host, unsigned int stat)\n{\n\tstruct mmc_data *data;\n\n\tspin_lock(&host->lock);\n\tdata = host->data;\n\n\tif (!data)\n\t\tgoto out;\n\n\tif (stat & TMIO_STAT_DATATIMEOUT)\n\t\tdata->error = -ETIMEDOUT;\n\telse if (stat & TMIO_STAT_CRCFAIL || stat & TMIO_STAT_STOPBIT_ERR ||\n\t\t stat & TMIO_STAT_TXUNDERRUN)\n\t\tdata->error = -EILSEQ;\n\tif (host->dma_on && (data->flags & MMC_DATA_WRITE)) {\n\t\tu32 status = sd_ctrl_read16_and_16_as_32(host, CTL_STATUS);\n\t\tbool done = false;\n\n\t\t \n\t\tif (host->pdata->flags & TMIO_MMC_HAS_IDLE_WAIT) {\n\t\t\tif (status & TMIO_STAT_SCLKDIVEN)\n\t\t\t\tdone = true;\n\t\t} else {\n\t\t\tif (!(status & TMIO_STAT_CMD_BUSY))\n\t\t\t\tdone = true;\n\t\t}\n\n\t\tif (done) {\n\t\t\ttmio_mmc_disable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\t\t\ttmio_mmc_dataend_dma(host);\n\t\t}\n\t} else if (host->dma_on && (data->flags & MMC_DATA_READ)) {\n\t\ttmio_mmc_disable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\t\ttmio_mmc_dataend_dma(host);\n\t} else {\n\t\ttmio_mmc_do_data_irq(host);\n\t\ttmio_mmc_disable_mmc_irqs(host, TMIO_MASK_READOP | TMIO_MASK_WRITEOP);\n\t}\nout:\n\tspin_unlock(&host->lock);\n}\n\nstatic void tmio_mmc_cmd_irq(struct tmio_mmc_host *host, unsigned int stat)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tint i, addr;\n\n\tspin_lock(&host->lock);\n\n\tif (!host->cmd) {\n\t\tpr_debug(\"Spurious CMD irq\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\n\tfor (i = 3, addr = CTL_RESPONSE ; i >= 0 ; i--, addr += 4)\n\t\tcmd->resp[i] = sd_ctrl_read16_and_16_as_32(host, addr);\n\n\tif (cmd->flags &  MMC_RSP_136) {\n\t\tcmd->resp[0] = (cmd->resp[0] << 8) | (cmd->resp[1] >> 24);\n\t\tcmd->resp[1] = (cmd->resp[1] << 8) | (cmd->resp[2] >> 24);\n\t\tcmd->resp[2] = (cmd->resp[2] << 8) | (cmd->resp[3] >> 24);\n\t\tcmd->resp[3] <<= 8;\n\t} else if (cmd->flags & MMC_RSP_R3) {\n\t\tcmd->resp[0] = cmd->resp[3];\n\t}\n\n\tif (stat & TMIO_STAT_CMDTIMEOUT)\n\t\tcmd->error = -ETIMEDOUT;\n\telse if ((stat & TMIO_STAT_CRCFAIL && cmd->flags & MMC_RSP_CRC) ||\n\t\t stat & TMIO_STAT_STOPBIT_ERR ||\n\t\t stat & TMIO_STAT_CMD_IDX_ERR)\n\t\tcmd->error = -EILSEQ;\n\n\t \n\tif (host->data && (!cmd->error || cmd->error == -EILSEQ)) {\n\t\tif (host->data->flags & MMC_DATA_READ) {\n\t\t\tif (!host->dma_on) {\n\t\t\t\ttmio_mmc_enable_mmc_irqs(host, TMIO_MASK_READOP);\n\t\t\t} else {\n\t\t\t\ttmio_mmc_disable_mmc_irqs(host,\n\t\t\t\t\t\t\t  TMIO_MASK_READOP);\n\t\t\t\ttasklet_schedule(&host->dma_issue);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!host->dma_on) {\n\t\t\t\ttmio_mmc_enable_mmc_irqs(host, TMIO_MASK_WRITEOP);\n\t\t\t} else {\n\t\t\t\ttmio_mmc_disable_mmc_irqs(host,\n\t\t\t\t\t\t\t  TMIO_MASK_WRITEOP);\n\t\t\t\ttasklet_schedule(&host->dma_issue);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tschedule_work(&host->done);\n\t}\n\nout:\n\tspin_unlock(&host->lock);\n}\n\nstatic bool __tmio_mmc_card_detect_irq(struct tmio_mmc_host *host,\n\t\t\t\t       int ireg, int status)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\t \n\tif (ireg & (TMIO_STAT_CARD_INSERT | TMIO_STAT_CARD_REMOVE)) {\n\t\ttmio_mmc_ack_mmc_irqs(host, TMIO_STAT_CARD_INSERT |\n\t\t\tTMIO_STAT_CARD_REMOVE);\n\t\tif ((((ireg & TMIO_STAT_CARD_REMOVE) && mmc->card) ||\n\t\t     ((ireg & TMIO_STAT_CARD_INSERT) && !mmc->card)) &&\n\t\t    !work_pending(&mmc->detect.work))\n\t\t\tmmc_detect_change(host->mmc, msecs_to_jiffies(100));\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic bool __tmio_mmc_sdcard_irq(struct tmio_mmc_host *host, int ireg,\n\t\t\t\t  int status)\n{\n\t \n\tif (ireg & (TMIO_STAT_CMDRESPEND | TMIO_STAT_CMDTIMEOUT)) {\n\t\ttmio_mmc_ack_mmc_irqs(host, TMIO_STAT_CMDRESPEND |\n\t\t\t\t      TMIO_STAT_CMDTIMEOUT);\n\t\ttmio_mmc_cmd_irq(host, status);\n\t\treturn true;\n\t}\n\n\t \n\tif (ireg & (TMIO_STAT_RXRDY | TMIO_STAT_TXRQ)) {\n\t\ttmio_mmc_ack_mmc_irqs(host, TMIO_STAT_RXRDY | TMIO_STAT_TXRQ);\n\t\ttmio_mmc_pio_irq(host);\n\t\treturn true;\n\t}\n\n\t \n\tif (ireg & TMIO_STAT_DATAEND) {\n\t\ttmio_mmc_ack_mmc_irqs(host, TMIO_STAT_DATAEND);\n\t\ttmio_mmc_data_irq(host, status);\n\t\treturn true;\n\t}\n\n\tif (host->dma_ops && host->dma_ops->dma_irq && host->dma_ops->dma_irq(host))\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic bool __tmio_mmc_sdio_irq(struct tmio_mmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tstruct tmio_mmc_data *pdata = host->pdata;\n\tunsigned int ireg, status;\n\tunsigned int sdio_status;\n\n\tif (!(pdata->flags & TMIO_MMC_SDIO_IRQ))\n\t\treturn false;\n\n\tstatus = sd_ctrl_read16(host, CTL_SDIO_STATUS);\n\tireg = status & TMIO_SDIO_MASK_ALL & ~host->sdio_irq_mask;\n\n\tsdio_status = status & ~TMIO_SDIO_MASK_ALL;\n\tif (pdata->flags & TMIO_MMC_SDIO_STATUS_SETBITS)\n\t\tsdio_status |= TMIO_SDIO_SETBITS_MASK;\n\n\tsd_ctrl_write16(host, CTL_SDIO_STATUS, sdio_status);\n\n\tif (mmc->caps & MMC_CAP_SDIO_IRQ && ireg & TMIO_SDIO_STAT_IOIRQ)\n\t\tmmc_signal_sdio_irq(mmc);\n\n\treturn ireg;\n}\n\nirqreturn_t tmio_mmc_irq(int irq, void *devid)\n{\n\tstruct tmio_mmc_host *host = devid;\n\tunsigned int ireg, status;\n\n\tstatus = sd_ctrl_read16_and_16_as_32(host, CTL_STATUS);\n\tireg = status & TMIO_MASK_IRQ & ~host->sdcard_irq_mask;\n\n\t \n\tsd_ctrl_write32_as_16_and_16(host, CTL_STATUS, TMIO_MASK_IRQ);\n\n\tif (__tmio_mmc_card_detect_irq(host, ireg, status))\n\t\treturn IRQ_HANDLED;\n\tif (__tmio_mmc_sdcard_irq(host, ireg, status))\n\t\treturn IRQ_HANDLED;\n\n\tif (__tmio_mmc_sdio_irq(host))\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_NONE;\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_irq);\n\nstatic int tmio_mmc_start_data(struct tmio_mmc_host *host,\n\t\t\t       struct mmc_data *data)\n{\n\tstruct tmio_mmc_data *pdata = host->pdata;\n\n\tpr_debug(\"setup data transfer: blocksize %08x  nr_blocks %d\\n\",\n\t\t data->blksz, data->blocks);\n\n\t \n\tif (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4 ||\n\t    host->mmc->ios.bus_width == MMC_BUS_WIDTH_8) {\n\t\tint blksz_2bytes = pdata->flags & TMIO_MMC_BLKSZ_2BYTES;\n\n\t\tif (data->blksz < 2 || (data->blksz < 4 && !blksz_2bytes)) {\n\t\t\tpr_err(\"%s: %d byte block unsupported in 4/8 bit mode\\n\",\n\t\t\t       mmc_hostname(host->mmc), data->blksz);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\ttmio_mmc_init_sg(host, data);\n\thost->data = data;\n\thost->dma_on = false;\n\n\t \n\tsd_ctrl_write16(host, CTL_SD_XFER_LEN, data->blksz);\n\tif (host->mmc->max_blk_count >= SZ_64K)\n\t\tsd_ctrl_write32(host, CTL_XFER_BLK_COUNT, data->blocks);\n\telse\n\t\tsd_ctrl_write16(host, CTL_XFER_BLK_COUNT, data->blocks);\n\n\ttmio_mmc_start_dma(host, data);\n\n\treturn 0;\n}\n\nstatic void tmio_process_mrq(struct tmio_mmc_host *host,\n\t\t\t     struct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd;\n\tint ret;\n\n\tif (mrq->sbc && host->cmd != mrq->sbc) {\n\t\tcmd = mrq->sbc;\n\t} else {\n\t\tcmd = mrq->cmd;\n\t\tif (mrq->data) {\n\t\t\tret = tmio_mmc_start_data(host, mrq->data);\n\t\t\tif (ret)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tret = tmio_mmc_start_command(host, cmd);\n\tif (ret)\n\t\tgoto fail;\n\n\tschedule_delayed_work(&host->delayed_reset_work,\n\t\t\t      msecs_to_jiffies(CMDREQ_TIMEOUT));\n\treturn;\n\nfail:\n\thost->mrq = NULL;\n\tmrq->cmd->error = ret;\n\tmmc_request_done(host->mmc, mrq);\n}\n\n \nstatic void tmio_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (host->mrq) {\n\t\tpr_debug(\"request not null\\n\");\n\t\tif (IS_ERR(host->mrq)) {\n\t\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\t\tmrq->cmd->error = -EAGAIN;\n\t\t\tmmc_request_done(mmc, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thost->last_req_ts = jiffies;\n\twmb();\n\thost->mrq = mrq;\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\ttmio_process_mrq(host, mrq);\n}\n\nstatic void tmio_mmc_finish_request(struct tmio_mmc_host *host)\n{\n\tstruct mmc_request *mrq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\ttmio_mmc_end_dma(host);\n\n\tmrq = host->mrq;\n\tif (IS_ERR_OR_NULL(mrq)) {\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tif (host->cmd != mrq->sbc) {\n\t\thost->cmd = NULL;\n\t\thost->data = NULL;\n\t\thost->mrq = NULL;\n\t}\n\n\tcancel_delayed_work(&host->delayed_reset_work);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (mrq->cmd->error || (mrq->data && mrq->data->error)) {\n\t\ttmio_mmc_ack_mmc_irqs(host, TMIO_MASK_IRQ);  \n\t\ttmio_mmc_abort_dma(host);\n\t}\n\n\t \n\tif (host->check_retune && host->check_retune(host, mrq))\n\t\tmmc_retune_needed(host->mmc);\n\n\t \n\tif (host->mrq && !mrq->cmd->error) {\n\t\ttmio_process_mrq(host, mrq);\n\t\treturn;\n\t}\n\n\tif (host->fixup_request)\n\t\thost->fixup_request(host, mrq);\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void tmio_mmc_done_work(struct work_struct *work)\n{\n\tstruct tmio_mmc_host *host = container_of(work, struct tmio_mmc_host,\n\t\t\t\t\t\t  done);\n\ttmio_mmc_finish_request(host);\n}\n\nstatic void tmio_mmc_power_on(struct tmio_mmc_host *host, unsigned short vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tint ret = 0;\n\n\t \n\n\tif (host->set_pwr)\n\t\thost->set_pwr(host->pdev, 1);\n\n\tif (!IS_ERR(mmc->supply.vmmc)) {\n\t\tret = mmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);\n\t\t \n\t\tusleep_range(200, 300);\n\t}\n\t \n\tif (!IS_ERR(mmc->supply.vqmmc) && !ret) {\n\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\tusleep_range(200, 300);\n\t}\n\n\tif (ret < 0)\n\t\tdev_dbg(&host->pdev->dev, \"Regulators failed to power up: %d\\n\",\n\t\t\tret);\n}\n\nstatic void tmio_mmc_power_off(struct tmio_mmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\n\tif (!IS_ERR(mmc->supply.vqmmc))\n\t\tregulator_disable(mmc->supply.vqmmc);\n\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\n\tif (host->set_pwr)\n\t\thost->set_pwr(host->pdev, 0);\n}\n\nstatic unsigned int tmio_mmc_get_timeout_cycles(struct tmio_mmc_host *host)\n{\n\tu16 val = sd_ctrl_read16(host, CTL_SD_MEM_CARD_OPT);\n\n\tval = (val & CARD_OPT_TOP_MASK) >> CARD_OPT_TOP_SHIFT;\n\treturn 1 << (13 + val);\n}\n\nstatic void tmio_mmc_max_busy_timeout(struct tmio_mmc_host *host)\n{\n\tunsigned int clk_rate = host->mmc->actual_clock ?: host->mmc->f_max;\n\n\thost->mmc->max_busy_timeout = host->get_timeout_cycles(host) /\n\t\t\t\t      (clk_rate / MSEC_PER_SEC);\n}\n\n \nstatic void tmio_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\tstruct device *dev = &host->pdev->dev;\n\tunsigned long flags;\n\n\tmutex_lock(&host->ios_lock);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (host->mrq) {\n\t\tif (IS_ERR(host->mrq)) {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s.%d: concurrent .set_ios(), clk %u, mode %u\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\t\tios->clock, ios->power_mode);\n\t\t\thost->mrq = ERR_PTR(-EINTR);\n\t\t} else {\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"%s.%d: CMD%u active since %lu, now %lu!\\n\",\n\t\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\t\thost->mrq->cmd->opcode, host->last_req_ts,\n\t\t\t\tjiffies);\n\t\t}\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\tmutex_unlock(&host->ios_lock);\n\t\treturn;\n\t}\n\n\thost->mrq = ERR_PTR(-EBUSY);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\ttmio_mmc_power_off(host);\n\t\t \n\t\tif (host->pdata->flags & TMIO_MMC_MIN_RCAR2)\n\t\t\ttmio_mmc_reset(host, false);\n\n\t\thost->set_clock(host, 0);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\ttmio_mmc_power_on(host, ios->vdd);\n\t\thost->set_clock(host, ios->clock);\n\t\ttmio_mmc_set_bus_width(host, ios->bus_width);\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\thost->set_clock(host, ios->clock);\n\t\ttmio_mmc_set_bus_width(host, ios->bus_width);\n\t\tbreak;\n\t}\n\n\tif (host->pdata->flags & TMIO_MMC_USE_BUSY_TIMEOUT)\n\t\ttmio_mmc_max_busy_timeout(host);\n\n\t \n\tusleep_range(140, 200);\n\tif (PTR_ERR(host->mrq) == -EINTR)\n\t\tdev_dbg(&host->pdev->dev,\n\t\t\t\"%s.%d: IOS interrupted: clk %u, mode %u\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tios->clock, ios->power_mode);\n\thost->mrq = NULL;\n\n\thost->clk_cache = ios->clock;\n\n\tmutex_unlock(&host->ios_lock);\n}\n\nstatic int tmio_mmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\n\treturn !(sd_ctrl_read16_and_16_as_32(host, CTL_STATUS) &\n\t\t TMIO_STAT_WRPROTECT);\n}\n\nstatic int tmio_mmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(mmc);\n\n\treturn !!(sd_ctrl_read16_and_16_as_32(host, CTL_STATUS) &\n\t\t  TMIO_STAT_SIGSTATE);\n}\n\nstatic int tmio_multi_io_quirk(struct mmc_card *card,\n\t\t\t       unsigned int direction, int blk_size)\n{\n\tstruct tmio_mmc_host *host = mmc_priv(card->host);\n\n\tif (host->multi_io_quirk)\n\t\treturn host->multi_io_quirk(card, direction, blk_size);\n\n\treturn blk_size;\n}\n\nstatic struct mmc_host_ops tmio_mmc_ops = {\n\t.request\t= tmio_mmc_request,\n\t.set_ios\t= tmio_mmc_set_ios,\n\t.get_ro         = tmio_mmc_get_ro,\n\t.get_cd\t\t= tmio_mmc_get_cd,\n\t.enable_sdio_irq = tmio_mmc_enable_sdio_irq,\n\t.multi_io_quirk\t= tmio_multi_io_quirk,\n};\n\nstatic int tmio_mmc_init_ocr(struct tmio_mmc_host *host)\n{\n\tstruct tmio_mmc_data *pdata = host->pdata;\n\tstruct mmc_host *mmc = host->mmc;\n\tint err;\n\n\terr = mmc_regulator_get_supply(mmc);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!mmc->ocr_avail)\n\t\tmmc->ocr_avail = pdata->ocr_mask;\n\n\t \n\tif (!mmc->ocr_avail)\n\t\treturn -EPROBE_DEFER;\n\n\treturn 0;\n}\n\nstatic void tmio_mmc_of_parse(struct platform_device *pdev,\n\t\t\t      struct mmc_host *mmc)\n{\n\tconst struct device_node *np = pdev->dev.of_node;\n\n\tif (!np)\n\t\treturn;\n\n\t \n\tif (of_property_read_bool(np, \"toshiba,mmc-wrprotect-disable\"))\n\t\tmmc->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;\n}\n\nstruct tmio_mmc_host *tmio_mmc_host_alloc(struct platform_device *pdev,\n\t\t\t\t\t  struct tmio_mmc_data *pdata)\n{\n\tstruct tmio_mmc_host *host;\n\tstruct mmc_host *mmc;\n\tvoid __iomem *ctl;\n\tint ret;\n\n\tctl = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(ctl))\n\t\treturn ERR_CAST(ctl);\n\n\tmmc = mmc_alloc_host(sizeof(struct tmio_mmc_host), &pdev->dev);\n\tif (!mmc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thost = mmc_priv(mmc);\n\thost->ctl = ctl;\n\thost->mmc = mmc;\n\thost->pdev = pdev;\n\thost->pdata = pdata;\n\thost->ops = tmio_mmc_ops;\n\tmmc->ops = &host->ops;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret) {\n\t\thost = ERR_PTR(ret);\n\t\tgoto free;\n\t}\n\n\ttmio_mmc_of_parse(pdev, mmc);\n\n\tplatform_set_drvdata(pdev, host);\n\n\treturn host;\nfree:\n\tmmc_free_host(mmc);\n\n\treturn host;\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_alloc);\n\nvoid tmio_mmc_host_free(struct tmio_mmc_host *host)\n{\n\tmmc_free_host(host->mmc);\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_free);\n\nint tmio_mmc_host_probe(struct tmio_mmc_host *_host)\n{\n\tstruct platform_device *pdev = _host->pdev;\n\tstruct tmio_mmc_data *pdata = _host->pdata;\n\tstruct mmc_host *mmc = _host->mmc;\n\tint ret;\n\n\t \n\tif (mmc->f_min == 0)\n\t\treturn -EINVAL;\n\n\tif (!(pdata->flags & TMIO_MMC_HAS_IDLE_WAIT))\n\t\t_host->write16_hook = NULL;\n\n\tif (pdata->flags & TMIO_MMC_USE_BUSY_TIMEOUT && !_host->get_timeout_cycles)\n\t\t_host->get_timeout_cycles = tmio_mmc_get_timeout_cycles;\n\n\t_host->set_pwr = pdata->set_pwr;\n\n\tret = tmio_mmc_init_ocr(_host);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = mmc_gpiod_request_cd(mmc, \"cd\", 0, false, 0);\n\tif (ret == -EPROBE_DEFER)\n\t\treturn ret;\n\n\tmmc->caps |= MMC_CAP_4_BIT_DATA | pdata->capabilities;\n\tmmc->caps2 |= pdata->capabilities2;\n\tmmc->max_segs = pdata->max_segs ? : 32;\n\tmmc->max_blk_size = TMIO_MAX_BLK_SIZE;\n\tmmc->max_blk_count = pdata->max_blk_count ? :\n\t\t(PAGE_SIZE / mmc->max_blk_size) * mmc->max_segs;\n\tmmc->max_req_size = min_t(size_t,\n\t\t\t\t  mmc->max_blk_size * mmc->max_blk_count,\n\t\t\t\t  dma_max_mapping_size(&pdev->dev));\n\tmmc->max_seg_size = mmc->max_req_size;\n\n\tif (mmc_can_gpio_ro(mmc))\n\t\t_host->ops.get_ro = mmc_gpio_get_ro;\n\n\tif (mmc_can_gpio_cd(mmc))\n\t\t_host->ops.get_cd = mmc_gpio_get_cd;\n\n\t \n\t_host->native_hotplug = !(mmc_can_gpio_cd(mmc) ||\n\t\t\t\t  mmc->caps & MMC_CAP_NEEDS_POLL ||\n\t\t\t\t  !mmc_card_is_removable(mmc));\n\n\t \n\tif (_host->native_hotplug)\n\t\tpm_runtime_get_noresume(&pdev->dev);\n\n\t_host->sdio_irq_enabled = false;\n\tif (pdata->flags & TMIO_MMC_SDIO_IRQ)\n\t\t_host->sdio_irq_mask = TMIO_SDIO_MASK_ALL;\n\n\tif (!_host->sdcard_irq_mask_all)\n\t\t_host->sdcard_irq_mask_all = TMIO_MASK_ALL;\n\n\t_host->set_clock(_host, 0);\n\ttmio_mmc_reset(_host, false);\n\n\tspin_lock_init(&_host->lock);\n\tmutex_init(&_host->ios_lock);\n\n\t \n\tINIT_DELAYED_WORK(&_host->delayed_reset_work, tmio_mmc_reset_work);\n\tINIT_WORK(&_host->done, tmio_mmc_done_work);\n\n\t \n\ttmio_mmc_request_dma(_host, pdata);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, 50);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto remove_host;\n\n\tdev_pm_qos_expose_latency_limit(&pdev->dev, 100);\n\tpm_runtime_put(&pdev->dev);\n\n\treturn 0;\n\nremove_host:\n\tpm_runtime_put_noidle(&pdev->dev);\n\ttmio_mmc_host_remove(_host);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_probe);\n\nvoid tmio_mmc_host_remove(struct tmio_mmc_host *host)\n{\n\tstruct platform_device *pdev = host->pdev;\n\tstruct mmc_host *mmc = host->mmc;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tif (host->pdata->flags & TMIO_MMC_SDIO_IRQ)\n\t\tsd_ctrl_write16(host, CTL_TRANSACTION_CTL, 0x0000);\n\n\tdev_pm_qos_hide_latency_limit(&pdev->dev);\n\n\tmmc_remove_host(mmc);\n\tcancel_work_sync(&host->done);\n\tcancel_delayed_work_sync(&host->delayed_reset_work);\n\ttmio_mmc_release_dma(host);\n\ttmio_mmc_disable_mmc_irqs(host, host->sdcard_irq_mask_all);\n\n\tif (host->native_hotplug)\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_dont_use_autosuspend(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_remove);\n\n#ifdef CONFIG_PM\nstatic int tmio_mmc_clk_enable(struct tmio_mmc_host *host)\n{\n\tif (!host->clk_enable)\n\t\treturn -ENOTSUPP;\n\n\treturn host->clk_enable(host);\n}\n\nstatic void tmio_mmc_clk_disable(struct tmio_mmc_host *host)\n{\n\tif (host->clk_disable)\n\t\thost->clk_disable(host);\n}\n\nint tmio_mmc_host_runtime_suspend(struct device *dev)\n{\n\tstruct tmio_mmc_host *host = dev_get_drvdata(dev);\n\n\ttmio_mmc_disable_mmc_irqs(host, host->sdcard_irq_mask_all);\n\n\tif (host->clk_cache)\n\t\thost->set_clock(host, 0);\n\n\ttmio_mmc_clk_disable(host);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_runtime_suspend);\n\nint tmio_mmc_host_runtime_resume(struct device *dev)\n{\n\tstruct tmio_mmc_host *host = dev_get_drvdata(dev);\n\n\ttmio_mmc_clk_enable(host);\n\ttmio_mmc_reset(host, false);\n\n\tif (host->clk_cache)\n\t\thost->set_clock(host, host->clk_cache);\n\n\ttmio_mmc_enable_dma(host, true);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(tmio_mmc_host_runtime_resume);\n#endif\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}