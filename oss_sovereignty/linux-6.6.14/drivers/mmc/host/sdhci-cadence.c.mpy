{
  "module_name": "sdhci-cadence.c",
  "hash_id": "17224b1025a017b310c9d8ff6e042623220a3406039ba86a0b1836366c32c89b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-cadence.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bits.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n\n#include \"sdhci-pltfm.h\"\n\n \n#define SDHCI_CDNS_HRS04\t\t0x10\t\t \n#define   SDHCI_CDNS_HRS04_ACK\t\t\tBIT(26)\n#define   SDHCI_CDNS_HRS04_RD\t\t\tBIT(25)\n#define   SDHCI_CDNS_HRS04_WR\t\t\tBIT(24)\n#define   SDHCI_CDNS_HRS04_RDATA\t\tGENMASK(23, 16)\n#define   SDHCI_CDNS_HRS04_WDATA\t\tGENMASK(15, 8)\n#define   SDHCI_CDNS_HRS04_ADDR\t\t\tGENMASK(5, 0)\n\n#define SDHCI_CDNS_HRS06\t\t0x18\t\t \n#define   SDHCI_CDNS_HRS06_TUNE_UP\t\tBIT(15)\n#define   SDHCI_CDNS_HRS06_TUNE\t\t\tGENMASK(13, 8)\n#define   SDHCI_CDNS_HRS06_MODE\t\t\tGENMASK(2, 0)\n#define   SDHCI_CDNS_HRS06_MODE_SD\t\t0x0\n#define   SDHCI_CDNS_HRS06_MODE_MMC_SDR\t\t0x2\n#define   SDHCI_CDNS_HRS06_MODE_MMC_DDR\t\t0x3\n#define   SDHCI_CDNS_HRS06_MODE_MMC_HS200\t0x4\n#define   SDHCI_CDNS_HRS06_MODE_MMC_HS400\t0x5\n#define   SDHCI_CDNS_HRS06_MODE_MMC_HS400ES\t0x6\n\n \n#define SDHCI_CDNS_SRS_BASE\t\t0x200\n\n \n#define SDHCI_CDNS_PHY_DLY_SD_HS\t0x00\n#define SDHCI_CDNS_PHY_DLY_SD_DEFAULT\t0x01\n#define SDHCI_CDNS_PHY_DLY_UHS_SDR12\t0x02\n#define SDHCI_CDNS_PHY_DLY_UHS_SDR25\t0x03\n#define SDHCI_CDNS_PHY_DLY_UHS_SDR50\t0x04\n#define SDHCI_CDNS_PHY_DLY_UHS_DDR50\t0x05\n#define SDHCI_CDNS_PHY_DLY_EMMC_LEGACY\t0x06\n#define SDHCI_CDNS_PHY_DLY_EMMC_SDR\t0x07\n#define SDHCI_CDNS_PHY_DLY_EMMC_DDR\t0x08\n#define SDHCI_CDNS_PHY_DLY_SDCLK\t0x0b\n#define SDHCI_CDNS_PHY_DLY_HSMMC\t0x0c\n#define SDHCI_CDNS_PHY_DLY_STROBE\t0x0d\n\n \n#define SDHCI_CDNS_MAX_TUNING_LOOP\t40\n\nstruct sdhci_cdns_phy_param {\n\tu8 addr;\n\tu8 data;\n};\n\nstruct sdhci_cdns_priv {\n\tvoid __iomem *hrs_addr;\n\tvoid __iomem *ctl_addr;\t \n\tspinlock_t wrlock;\t \n\tbool enhanced_strobe;\n\tvoid (*priv_writel)(struct sdhci_cdns_priv *priv, u32 val, void __iomem *reg);\n\tstruct reset_control *rst_hw;\n\tunsigned int nr_phy_params;\n\tstruct sdhci_cdns_phy_param phy_params[];\n};\n\nstruct sdhci_cdns_phy_cfg {\n\tconst char *property;\n\tu8 addr;\n};\n\nstruct sdhci_cdns_drv_data {\n\tint (*init)(struct platform_device *pdev);\n\tconst struct sdhci_pltfm_data pltfm_data;\n};\n\nstatic const struct sdhci_cdns_phy_cfg sdhci_cdns_phy_cfgs[] = {\n\t{ \"cdns,phy-input-delay-sd-highspeed\", SDHCI_CDNS_PHY_DLY_SD_HS, },\n\t{ \"cdns,phy-input-delay-legacy\", SDHCI_CDNS_PHY_DLY_SD_DEFAULT, },\n\t{ \"cdns,phy-input-delay-sd-uhs-sdr12\", SDHCI_CDNS_PHY_DLY_UHS_SDR12, },\n\t{ \"cdns,phy-input-delay-sd-uhs-sdr25\", SDHCI_CDNS_PHY_DLY_UHS_SDR25, },\n\t{ \"cdns,phy-input-delay-sd-uhs-sdr50\", SDHCI_CDNS_PHY_DLY_UHS_SDR50, },\n\t{ \"cdns,phy-input-delay-sd-uhs-ddr50\", SDHCI_CDNS_PHY_DLY_UHS_DDR50, },\n\t{ \"cdns,phy-input-delay-mmc-highspeed\", SDHCI_CDNS_PHY_DLY_EMMC_SDR, },\n\t{ \"cdns,phy-input-delay-mmc-ddr\", SDHCI_CDNS_PHY_DLY_EMMC_DDR, },\n\t{ \"cdns,phy-dll-delay-sdclk\", SDHCI_CDNS_PHY_DLY_SDCLK, },\n\t{ \"cdns,phy-dll-delay-sdclk-hsmmc\", SDHCI_CDNS_PHY_DLY_HSMMC, },\n\t{ \"cdns,phy-dll-delay-strobe\", SDHCI_CDNS_PHY_DLY_STROBE, },\n};\n\nstatic inline void cdns_writel(struct sdhci_cdns_priv *priv, u32 val,\n\t\t\t       void __iomem *reg)\n{\n\twritel(val, reg);\n}\n\nstatic int sdhci_cdns_write_phy_reg(struct sdhci_cdns_priv *priv,\n\t\t\t\t    u8 addr, u8 data)\n{\n\tvoid __iomem *reg = priv->hrs_addr + SDHCI_CDNS_HRS04;\n\tu32 tmp;\n\tint ret;\n\n\tret = readl_poll_timeout(reg, tmp, !(tmp & SDHCI_CDNS_HRS04_ACK),\n\t\t\t\t 0, 10);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = FIELD_PREP(SDHCI_CDNS_HRS04_WDATA, data) |\n\t      FIELD_PREP(SDHCI_CDNS_HRS04_ADDR, addr);\n\tpriv->priv_writel(priv, tmp, reg);\n\n\ttmp |= SDHCI_CDNS_HRS04_WR;\n\tpriv->priv_writel(priv, tmp, reg);\n\n\tret = readl_poll_timeout(reg, tmp, tmp & SDHCI_CDNS_HRS04_ACK, 0, 10);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp &= ~SDHCI_CDNS_HRS04_WR;\n\tpriv->priv_writel(priv, tmp, reg);\n\n\tret = readl_poll_timeout(reg, tmp, !(tmp & SDHCI_CDNS_HRS04_ACK),\n\t\t\t\t 0, 10);\n\n\treturn ret;\n}\n\nstatic unsigned int sdhci_cdns_phy_param_count(struct device_node *np)\n{\n\tunsigned int count = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdhci_cdns_phy_cfgs); i++)\n\t\tif (of_property_read_bool(np, sdhci_cdns_phy_cfgs[i].property))\n\t\t\tcount++;\n\n\treturn count;\n}\n\nstatic void sdhci_cdns_phy_param_parse(struct device_node *np,\n\t\t\t\t       struct sdhci_cdns_priv *priv)\n{\n\tstruct sdhci_cdns_phy_param *p = priv->phy_params;\n\tu32 val;\n\tint ret, i;\n\n\tfor (i = 0; i < ARRAY_SIZE(sdhci_cdns_phy_cfgs); i++) {\n\t\tret = of_property_read_u32(np, sdhci_cdns_phy_cfgs[i].property,\n\t\t\t\t\t   &val);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tp->addr = sdhci_cdns_phy_cfgs[i].addr;\n\t\tp->data = val;\n\t\tp++;\n\t}\n}\n\nstatic int sdhci_cdns_phy_init(struct sdhci_cdns_priv *priv)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < priv->nr_phy_params; i++) {\n\t\tret = sdhci_cdns_write_phy_reg(priv, priv->phy_params[i].addr,\n\t\t\t\t\t       priv->phy_params[i].data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void *sdhci_cdns_priv(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn sdhci_pltfm_priv(pltfm_host);\n}\n\nstatic unsigned int sdhci_cdns_get_timeout_clock(struct sdhci_host *host)\n{\n\t \n\treturn host->max_clk;\n}\n\nstatic void sdhci_cdns_set_emmc_mode(struct sdhci_cdns_priv *priv, u32 mode)\n{\n\tu32 tmp;\n\n\t \n\ttmp = readl(priv->hrs_addr + SDHCI_CDNS_HRS06);\n\ttmp &= ~SDHCI_CDNS_HRS06_MODE;\n\ttmp |= FIELD_PREP(SDHCI_CDNS_HRS06_MODE, mode);\n\tpriv->priv_writel(priv, tmp, priv->hrs_addr + SDHCI_CDNS_HRS06);\n}\n\nstatic u32 sdhci_cdns_get_emmc_mode(struct sdhci_cdns_priv *priv)\n{\n\tu32 tmp;\n\n\ttmp = readl(priv->hrs_addr + SDHCI_CDNS_HRS06);\n\treturn FIELD_GET(SDHCI_CDNS_HRS06_MODE, tmp);\n}\n\nstatic int sdhci_cdns_set_tune_val(struct sdhci_host *host, unsigned int val)\n{\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tvoid __iomem *reg = priv->hrs_addr + SDHCI_CDNS_HRS06;\n\tu32 tmp;\n\tint i, ret;\n\n\tif (WARN_ON(!FIELD_FIT(SDHCI_CDNS_HRS06_TUNE, val)))\n\t\treturn -EINVAL;\n\n\ttmp = readl(reg);\n\ttmp &= ~SDHCI_CDNS_HRS06_TUNE;\n\ttmp |= FIELD_PREP(SDHCI_CDNS_HRS06_TUNE, val);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\ttmp |= SDHCI_CDNS_HRS06_TUNE_UP;\n\t\tpriv->priv_writel(priv, tmp, reg);\n\n\t\tret = readl_poll_timeout(reg, tmp,\n\t\t\t\t\t !(tmp & SDHCI_CDNS_HRS06_TUNE_UP),\n\t\t\t\t\t 0, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int sdhci_cdns_execute_tuning(struct sdhci_host *host, u32 opcode)\n{\n\tint cur_streak = 0;\n\tint max_streak = 0;\n\tint end_of_streak = 0;\n\tint i;\n\n\t \n\tif (host->timing != MMC_TIMING_MMC_HS200 &&\n\t    host->timing != MMC_TIMING_UHS_SDR104)\n\t\treturn 0;\n\n\tfor (i = 0; i < SDHCI_CDNS_MAX_TUNING_LOOP; i++) {\n\t\tif (sdhci_cdns_set_tune_val(host, i) ||\n\t\t    mmc_send_tuning(host->mmc, opcode, NULL)) {  \n\t\t\tcur_streak = 0;\n\t\t} else {  \n\t\t\tcur_streak++;\n\t\t\tif (cur_streak > max_streak) {\n\t\t\t\tmax_streak = cur_streak;\n\t\t\t\tend_of_streak = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!max_streak) {\n\t\tdev_err(mmc_dev(host->mmc), \"no tuning point found\\n\");\n\t\treturn -EIO;\n\t}\n\n\treturn sdhci_cdns_set_tune_val(host, end_of_streak - max_streak / 2);\n}\n\nstatic void sdhci_cdns_set_uhs_signaling(struct sdhci_host *host,\n\t\t\t\t\t unsigned int timing)\n{\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tu32 mode;\n\n\tswitch (timing) {\n\tcase MMC_TIMING_MMC_HS:\n\t\tmode = SDHCI_CDNS_HRS06_MODE_MMC_SDR;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tmode = SDHCI_CDNS_HRS06_MODE_MMC_DDR;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS200:\n\t\tmode = SDHCI_CDNS_HRS06_MODE_MMC_HS200;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tif (priv->enhanced_strobe)\n\t\t\tmode = SDHCI_CDNS_HRS06_MODE_MMC_HS400ES;\n\t\telse\n\t\t\tmode = SDHCI_CDNS_HRS06_MODE_MMC_HS400;\n\t\tbreak;\n\tdefault:\n\t\tmode = SDHCI_CDNS_HRS06_MODE_SD;\n\t\tbreak;\n\t}\n\n\tsdhci_cdns_set_emmc_mode(priv, mode);\n\n\t \n\tif (mode == SDHCI_CDNS_HRS06_MODE_SD)\n\t\tsdhci_set_uhs_signaling(host, timing);\n}\n\n \n#define ELBA_BYTE_ENABLE_MASK(x)\t((x) << 3)\n\n \nstatic void elba_priv_writel(struct sdhci_cdns_priv *priv, u32 val,\n\t\t\t     void __iomem *reg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->wrlock, flags);\n\twritel(GENMASK(7, 3), priv->ctl_addr);\n\twritel(val, reg);\n\tspin_unlock_irqrestore(&priv->wrlock, flags);\n}\n\nstatic void elba_write_l(struct sdhci_host *host, u32 val, int reg)\n{\n\telba_priv_writel(sdhci_cdns_priv(host), val, host->ioaddr + reg);\n}\n\nstatic void elba_write_w(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tu32 shift = reg & GENMASK(1, 0);\n\tunsigned long flags;\n\tu32 byte_enables;\n\n\tbyte_enables = GENMASK(1, 0) << shift;\n\tspin_lock_irqsave(&priv->wrlock, flags);\n\twritel(ELBA_BYTE_ENABLE_MASK(byte_enables), priv->ctl_addr);\n\twritew(val, host->ioaddr + reg);\n\tspin_unlock_irqrestore(&priv->wrlock, flags);\n}\n\nstatic void elba_write_b(struct sdhci_host *host, u8 val, int reg)\n{\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tu32 shift = reg & GENMASK(1, 0);\n\tunsigned long flags;\n\tu32 byte_enables;\n\n\tbyte_enables = BIT(0) << shift;\n\tspin_lock_irqsave(&priv->wrlock, flags);\n\twritel(ELBA_BYTE_ENABLE_MASK(byte_enables), priv->ctl_addr);\n\twriteb(val, host->ioaddr + reg);\n\tspin_unlock_irqrestore(&priv->wrlock, flags);\n}\n\nstatic const struct sdhci_ops sdhci_elba_ops = {\n\t.write_l = elba_write_l,\n\t.write_w = elba_write_w,\n\t.write_b = elba_write_b,\n\t.set_clock = sdhci_set_clock,\n\t.get_timeout_clock = sdhci_cdns_get_timeout_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_cdns_set_uhs_signaling,\n};\n\nstatic int elba_drv_init(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tvoid __iomem *ioaddr;\n\n\thost->mmc->caps |= MMC_CAP_1_8V_DDR | MMC_CAP_8_BIT_DATA;\n\tspin_lock_init(&priv->wrlock);\n\n\t \n\tioaddr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(ioaddr))\n\t\treturn PTR_ERR(ioaddr);\n\n\tpriv->ctl_addr = ioaddr;\n\tpriv->priv_writel = elba_priv_writel;\n\twritel(ELBA_BYTE_ENABLE_MASK(0xf), priv->ctl_addr);\n\n\treturn 0;\n}\n\nstatic const struct sdhci_ops sdhci_cdns_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.get_timeout_clock = sdhci_cdns_get_timeout_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.platform_execute_tuning = sdhci_cdns_execute_tuning,\n\t.set_uhs_signaling = sdhci_cdns_set_uhs_signaling,\n};\n\nstatic const struct sdhci_cdns_drv_data sdhci_cdns_uniphier_drv_data = {\n\t.pltfm_data = {\n\t\t.ops = &sdhci_cdns_ops,\n\t\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t},\n};\n\nstatic const struct sdhci_cdns_drv_data sdhci_elba_drv_data = {\n\t.init = elba_drv_init,\n\t.pltfm_data = {\n\t\t.ops = &sdhci_elba_ops,\n\t},\n};\n\nstatic const struct sdhci_cdns_drv_data sdhci_cdns_drv_data = {\n\t.pltfm_data = {\n\t\t.ops = &sdhci_cdns_ops,\n\t},\n};\n\nstatic void sdhci_cdns_hs400_enhanced_strobe(struct mmc_host *mmc,\n\t\t\t\t\t     struct mmc_ios *ios)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\tu32 mode;\n\n\tpriv->enhanced_strobe = ios->enhanced_strobe;\n\n\tmode = sdhci_cdns_get_emmc_mode(priv);\n\n\tif (mode == SDHCI_CDNS_HRS06_MODE_MMC_HS400 && ios->enhanced_strobe)\n\t\tsdhci_cdns_set_emmc_mode(priv,\n\t\t\t\t\t SDHCI_CDNS_HRS06_MODE_MMC_HS400ES);\n\n\tif (mode == SDHCI_CDNS_HRS06_MODE_MMC_HS400ES && !ios->enhanced_strobe)\n\t\tsdhci_cdns_set_emmc_mode(priv,\n\t\t\t\t\t SDHCI_CDNS_HRS06_MODE_MMC_HS400);\n}\n\nstatic void sdhci_cdns_mmc_hw_reset(struct mmc_host *mmc)\n{\n\tstruct sdhci_host *host = mmc_priv(mmc);\n\tstruct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);\n\n\tdev_dbg(mmc_dev(host->mmc), \"emmc hardware reset\\n\");\n\n\treset_control_assert(priv->rst_hw);\n\t \n\tudelay(3);\n\n\treset_control_deassert(priv->rst_hw);\n\t \n\tusleep_range(300, 1000);\n}\n\nstatic int sdhci_cdns_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tconst struct sdhci_cdns_drv_data *data;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_cdns_priv *priv;\n\tstruct clk *clk;\n\tunsigned int nr_phy_params;\n\tint ret;\n\tstruct device *dev = &pdev->dev;\n\tstatic const u16 version = SDHCI_SPEC_400 << SDHCI_SPEC_VER_SHIFT;\n\n\tclk = devm_clk_get_enabled(dev, NULL);\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\tdata = &sdhci_cdns_drv_data;\n\n\tnr_phy_params = sdhci_cdns_phy_param_count(dev->of_node);\n\thost = sdhci_pltfm_init(pdev, &data->pltfm_data,\n\t\t\t\tstruct_size(priv, phy_params, nr_phy_params));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpltfm_host->clk = clk;\n\n\tpriv = sdhci_pltfm_priv(pltfm_host);\n\tpriv->nr_phy_params = nr_phy_params;\n\tpriv->hrs_addr = host->ioaddr;\n\tpriv->enhanced_strobe = false;\n\tpriv->priv_writel = cdns_writel;\n\thost->ioaddr += SDHCI_CDNS_SRS_BASE;\n\thost->mmc_host_ops.hs400_enhanced_strobe =\n\t\t\t\tsdhci_cdns_hs400_enhanced_strobe;\n\tif (data->init) {\n\t\tret = data->init(pdev);\n\t\tif (ret)\n\t\t\tgoto free;\n\t}\n\tsdhci_enable_v4_mode(host);\n\t__sdhci_read_caps(host, &version, NULL, NULL);\n\n\tsdhci_get_of_property(pdev);\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto free;\n\n\tsdhci_cdns_phy_param_parse(dev->of_node, priv);\n\n\tret = sdhci_cdns_phy_init(priv);\n\tif (ret)\n\t\tgoto free;\n\n\tif (host->mmc->caps & MMC_CAP_HW_RESET) {\n\t\tpriv->rst_hw = devm_reset_control_get_optional_exclusive(dev, NULL);\n\t\tif (IS_ERR(priv->rst_hw)) {\n\t\t\tret = dev_err_probe(mmc_dev(host->mmc), PTR_ERR(priv->rst_hw),\n\t\t\t\t\t    \"reset controller error\\n\");\n\t\t\tgoto free;\n\t\t}\n\t\tif (priv->rst_hw)\n\t\t\thost->mmc_host_ops.card_hw_reset = sdhci_cdns_mmc_hw_reset;\n\t}\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto free;\n\n\treturn 0;\nfree:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_cdns_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_cdns_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = clk_prepare_enable(pltfm_host->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = sdhci_cdns_phy_init(priv);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tret = sdhci_resume_host(host);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\treturn 0;\n\ndisable_clk:\n\tclk_disable_unprepare(pltfm_host->clk);\n\n\treturn ret;\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_cdns_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_pltfm_suspend, sdhci_cdns_resume)\n};\n\nstatic const struct of_device_id sdhci_cdns_match[] = {\n\t{\n\t\t.compatible = \"socionext,uniphier-sd4hc\",\n\t\t.data = &sdhci_cdns_uniphier_drv_data,\n\t},\n\t{\n\t\t.compatible = \"amd,pensando-elba-sd4hc\",\n\t\t.data = &sdhci_elba_drv_data,\n\t},\n\t{ .compatible = \"cdns,sd4hc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, sdhci_cdns_match);\n\nstatic struct platform_driver sdhci_cdns_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-cdns\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = &sdhci_cdns_pm_ops,\n\t\t.of_match_table = sdhci_cdns_match,\n\t},\n\t.probe = sdhci_cdns_probe,\n\t.remove_new = sdhci_pltfm_remove,\n};\nmodule_platform_driver(sdhci_cdns_driver);\n\nMODULE_AUTHOR(\"Masahiro Yamada <yamada.masahiro@socionext.com>\");\nMODULE_DESCRIPTION(\"Cadence SD/SDIO/eMMC Host Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}