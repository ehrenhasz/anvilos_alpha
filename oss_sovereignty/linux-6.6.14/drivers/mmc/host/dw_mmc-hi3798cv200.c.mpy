{
  "module_name": "dw_mmc-hi3798cv200.c",
  "hash_id": "9c6185d5f89be9d4f63b5ff17be9d9d5a05b4718fba96bc5c730424fe5dc21de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc-hi3798cv200.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"dw_mmc.h\"\n#include \"dw_mmc-pltfm.h\"\n\n#define ALL_INT_CLR\t\t0x1ffff\n\nstruct hi3798cv200_priv {\n\tstruct clk *sample_clk;\n\tstruct clk *drive_clk;\n};\n\nstatic void dw_mci_hi3798cv200_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tstruct hi3798cv200_priv *priv = host->priv;\n\tu32 val;\n\n\tval = mci_readl(host, UHS_REG);\n\tif (ios->timing == MMC_TIMING_MMC_DDR52 ||\n\t    ios->timing == MMC_TIMING_UHS_DDR50)\n\t\tval |= SDMMC_UHS_DDR;\n\telse\n\t\tval &= ~SDMMC_UHS_DDR;\n\tmci_writel(host, UHS_REG, val);\n\n\tval = mci_readl(host, ENABLE_SHIFT);\n\tif (ios->timing == MMC_TIMING_MMC_DDR52)\n\t\tval |= SDMMC_ENABLE_PHASE;\n\telse\n\t\tval &= ~SDMMC_ENABLE_PHASE;\n\tmci_writel(host, ENABLE_SHIFT, val);\n\n\tval = mci_readl(host, DDR_REG);\n\tif (ios->timing == MMC_TIMING_MMC_HS400)\n\t\tval |= SDMMC_DDR_HS400;\n\telse\n\t\tval &= ~SDMMC_DDR_HS400;\n\tmci_writel(host, DDR_REG, val);\n\n\tif (ios->timing == MMC_TIMING_MMC_HS ||\n\t    ios->timing == MMC_TIMING_LEGACY)\n\t\tclk_set_phase(priv->drive_clk, 180);\n\telse if (ios->timing == MMC_TIMING_MMC_HS200)\n\t\tclk_set_phase(priv->drive_clk, 135);\n}\n\nstatic int dw_mci_hi3798cv200_execute_tuning(struct dw_mci_slot *slot,\n\t\t\t\t\t     u32 opcode)\n{\n\tstatic const int degrees[] = { 0, 45, 90, 135, 180, 225, 270, 315 };\n\tstruct dw_mci *host = slot->host;\n\tstruct hi3798cv200_priv *priv = host->priv;\n\tint raise_point = -1, fall_point = -1;\n\tint err, prev_err = -1;\n\tint found = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(degrees); i++) {\n\t\tclk_set_phase(priv->sample_clk, degrees[i]);\n\t\tmci_writel(host, RINTSTS, ALL_INT_CLR);\n\n\t\terr = mmc_send_tuning(slot->mmc, opcode, NULL);\n\t\tif (!err)\n\t\t\tfound = 1;\n\n\t\tif (i > 0) {\n\t\t\tif (err && !prev_err)\n\t\t\t\tfall_point = i - 1;\n\t\t\tif (!err && prev_err)\n\t\t\t\traise_point = i;\n\t\t}\n\n\t\tif (raise_point != -1 && fall_point != -1)\n\t\t\tgoto tuning_out;\n\n\t\tprev_err = err;\n\t\terr = 0;\n\t}\n\ntuning_out:\n\tif (found) {\n\t\tif (raise_point == -1)\n\t\t\traise_point = 0;\n\t\tif (fall_point == -1)\n\t\t\tfall_point = ARRAY_SIZE(degrees) - 1;\n\t\tif (fall_point < raise_point) {\n\t\t\tif ((raise_point + fall_point) >\n\t\t\t    (ARRAY_SIZE(degrees) - 1))\n\t\t\t\ti = fall_point / 2;\n\t\t\telse\n\t\t\t\ti = (raise_point + ARRAY_SIZE(degrees) - 1) / 2;\n\t\t} else {\n\t\t\ti = (raise_point + fall_point) / 2;\n\t\t}\n\n\t\tclk_set_phase(priv->sample_clk, degrees[i]);\n\t\tdev_dbg(host->dev, \"Tuning clk_sample[%d, %d], set[%d]\\n\",\n\t\t\traise_point, fall_point, degrees[i]);\n\t} else {\n\t\tdev_err(host->dev, \"No valid clk_sample shift! use default\\n\");\n\t\terr = -EINVAL;\n\t}\n\n\tmci_writel(host, RINTSTS, ALL_INT_CLR);\n\treturn err;\n}\n\nstatic int dw_mci_hi3798cv200_init(struct dw_mci *host)\n{\n\tstruct hi3798cv200_priv *priv;\n\tint ret;\n\n\tpriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->sample_clk = devm_clk_get(host->dev, \"ciu-sample\");\n\tif (IS_ERR(priv->sample_clk)) {\n\t\tdev_err(host->dev, \"failed to get ciu-sample clock\\n\");\n\t\treturn PTR_ERR(priv->sample_clk);\n\t}\n\n\tpriv->drive_clk = devm_clk_get(host->dev, \"ciu-drive\");\n\tif (IS_ERR(priv->drive_clk)) {\n\t\tdev_err(host->dev, \"failed to get ciu-drive clock\\n\");\n\t\treturn PTR_ERR(priv->drive_clk);\n\t}\n\n\tret = clk_prepare_enable(priv->sample_clk);\n\tif (ret) {\n\t\tdev_err(host->dev, \"failed to enable ciu-sample clock\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(priv->drive_clk);\n\tif (ret) {\n\t\tdev_err(host->dev, \"failed to enable ciu-drive clock\\n\");\n\t\tgoto disable_sample_clk;\n\t}\n\n\thost->priv = priv;\n\treturn 0;\n\ndisable_sample_clk:\n\tclk_disable_unprepare(priv->sample_clk);\n\treturn ret;\n}\n\nstatic const struct dw_mci_drv_data hi3798cv200_data = {\n\t.common_caps = MMC_CAP_CMD23,\n\t.init = dw_mci_hi3798cv200_init,\n\t.set_ios = dw_mci_hi3798cv200_set_ios,\n\t.execute_tuning = dw_mci_hi3798cv200_execute_tuning,\n};\n\nstatic int dw_mci_hi3798cv200_probe(struct platform_device *pdev)\n{\n\treturn dw_mci_pltfm_register(pdev, &hi3798cv200_data);\n}\n\nstatic void dw_mci_hi3798cv200_remove(struct platform_device *pdev)\n{\n\tstruct dw_mci *host = platform_get_drvdata(pdev);\n\tstruct hi3798cv200_priv *priv = host->priv;\n\n\tclk_disable_unprepare(priv->drive_clk);\n\tclk_disable_unprepare(priv->sample_clk);\n\n\tdw_mci_pltfm_remove(pdev);\n}\n\nstatic const struct of_device_id dw_mci_hi3798cv200_match[] = {\n\t{ .compatible = \"hisilicon,hi3798cv200-dw-mshc\", },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, dw_mci_hi3798cv200_match);\nstatic struct platform_driver dw_mci_hi3798cv200_driver = {\n\t.probe = dw_mci_hi3798cv200_probe,\n\t.remove_new = dw_mci_hi3798cv200_remove,\n\t.driver = {\n\t\t.name = \"dwmmc_hi3798cv200\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = dw_mci_hi3798cv200_match,\n\t},\n};\nmodule_platform_driver(dw_mci_hi3798cv200_driver);\n\nMODULE_DESCRIPTION(\"HiSilicon Hi3798CV200 Specific DW-MSHC Driver Extension\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dwmmc_hi3798cv200\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}