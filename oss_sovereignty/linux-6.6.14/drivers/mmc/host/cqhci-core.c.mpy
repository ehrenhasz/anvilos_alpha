{
  "module_name": "cqhci-core.c",
  "hash_id": "81e0a124ce5c186c2d9442030ce3d592adad0bca5d343699b8152b3f46106961",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/cqhci-core.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n#include <linux/platform_device.h>\n#include <linux/ktime.h>\n\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n\n#include \"cqhci.h\"\n#include \"cqhci-crypto.h\"\n\n#define DCMD_SLOT 31\n#define NUM_SLOTS 32\n\nstruct cqhci_slot {\n\tstruct mmc_request *mrq;\n\tunsigned int flags;\n#define CQHCI_EXTERNAL_TIMEOUT\tBIT(0)\n#define CQHCI_COMPLETED\t\tBIT(1)\n#define CQHCI_HOST_CRC\t\tBIT(2)\n#define CQHCI_HOST_TIMEOUT\tBIT(3)\n#define CQHCI_HOST_OTHER\tBIT(4)\n};\n\nstatic inline u8 *get_desc(struct cqhci_host *cq_host, u8 tag)\n{\n\treturn cq_host->desc_base + (tag * cq_host->slot_sz);\n}\n\nstatic inline u8 *get_link_desc(struct cqhci_host *cq_host, u8 tag)\n{\n\tu8 *desc = get_desc(cq_host, tag);\n\n\treturn desc + cq_host->task_desc_len;\n}\n\nstatic inline size_t get_trans_desc_offset(struct cqhci_host *cq_host, u8 tag)\n{\n\treturn cq_host->trans_desc_len * cq_host->mmc->max_segs * tag;\n}\n\nstatic inline dma_addr_t get_trans_desc_dma(struct cqhci_host *cq_host, u8 tag)\n{\n\tsize_t offset = get_trans_desc_offset(cq_host, tag);\n\n\treturn cq_host->trans_desc_dma_base + offset;\n}\n\nstatic inline u8 *get_trans_desc(struct cqhci_host *cq_host, u8 tag)\n{\n\tsize_t offset = get_trans_desc_offset(cq_host, tag);\n\n\treturn cq_host->trans_desc_base + offset;\n}\n\nstatic void setup_trans_desc(struct cqhci_host *cq_host, u8 tag)\n{\n\tu8 *link_temp;\n\tdma_addr_t trans_temp;\n\n\tlink_temp = get_link_desc(cq_host, tag);\n\ttrans_temp = get_trans_desc_dma(cq_host, tag);\n\n\tmemset(link_temp, 0, cq_host->link_desc_len);\n\tif (cq_host->link_desc_len > 8)\n\t\t*(link_temp + 8) = 0;\n\n\tif (tag == DCMD_SLOT && (cq_host->mmc->caps2 & MMC_CAP2_CQE_DCMD)) {\n\t\t*link_temp = CQHCI_VALID(0) | CQHCI_ACT(0) | CQHCI_END(1);\n\t\treturn;\n\t}\n\n\t*link_temp = CQHCI_VALID(1) | CQHCI_ACT(0x6) | CQHCI_END(0);\n\n\tif (cq_host->dma64) {\n\t\t__le64 *data_addr = (__le64 __force *)(link_temp + 4);\n\n\t\tdata_addr[0] = cpu_to_le64(trans_temp);\n\t} else {\n\t\t__le32 *data_addr = (__le32 __force *)(link_temp + 4);\n\n\t\tdata_addr[0] = cpu_to_le32(trans_temp);\n\t}\n}\n\nstatic void cqhci_set_irqs(struct cqhci_host *cq_host, u32 set)\n{\n\tcqhci_writel(cq_host, set, CQHCI_ISTE);\n\tcqhci_writel(cq_host, set, CQHCI_ISGE);\n}\n\n#define DRV_NAME \"cqhci\"\n\n#define CQHCI_DUMP(f, x...) \\\n\tpr_err(\"%s: \" DRV_NAME \": \" f, mmc_hostname(mmc), ## x)\n\nstatic void cqhci_dumpregs(struct cqhci_host *cq_host)\n{\n\tstruct mmc_host *mmc = cq_host->mmc;\n\n\tCQHCI_DUMP(\"============ CQHCI REGISTER DUMP ===========\\n\");\n\n\tCQHCI_DUMP(\"Caps:      0x%08x | Version:  0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_CAP),\n\t\t   cqhci_readl(cq_host, CQHCI_VER));\n\tCQHCI_DUMP(\"Config:    0x%08x | Control:  0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_CFG),\n\t\t   cqhci_readl(cq_host, CQHCI_CTL));\n\tCQHCI_DUMP(\"Int stat:  0x%08x | Int enab: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_IS),\n\t\t   cqhci_readl(cq_host, CQHCI_ISTE));\n\tCQHCI_DUMP(\"Int sig:   0x%08x | Int Coal: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_ISGE),\n\t\t   cqhci_readl(cq_host, CQHCI_IC));\n\tCQHCI_DUMP(\"TDL base:  0x%08x | TDL up32: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_TDLBA),\n\t\t   cqhci_readl(cq_host, CQHCI_TDLBAU));\n\tCQHCI_DUMP(\"Doorbell:  0x%08x | TCN:      0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_TDBR),\n\t\t   cqhci_readl(cq_host, CQHCI_TCN));\n\tCQHCI_DUMP(\"Dev queue: 0x%08x | Dev Pend: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_DQS),\n\t\t   cqhci_readl(cq_host, CQHCI_DPT));\n\tCQHCI_DUMP(\"Task clr:  0x%08x | SSC1:     0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_TCLR),\n\t\t   cqhci_readl(cq_host, CQHCI_SSC1));\n\tCQHCI_DUMP(\"SSC2:      0x%08x | DCMD rsp: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_SSC2),\n\t\t   cqhci_readl(cq_host, CQHCI_CRDCT));\n\tCQHCI_DUMP(\"RED mask:  0x%08x | TERRI:    0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_RMEM),\n\t\t   cqhci_readl(cq_host, CQHCI_TERRI));\n\tCQHCI_DUMP(\"Resp idx:  0x%08x | Resp arg: 0x%08x\\n\",\n\t\t   cqhci_readl(cq_host, CQHCI_CRI),\n\t\t   cqhci_readl(cq_host, CQHCI_CRA));\n\n\tif (cq_host->ops->dumpregs)\n\t\tcq_host->ops->dumpregs(mmc);\n\telse\n\t\tCQHCI_DUMP(\": ===========================================\\n\");\n}\n\n \nstatic int cqhci_host_alloc_tdl(struct cqhci_host *cq_host)\n{\n\tint i = 0;\n\n\t \n\tif (cq_host->caps & CQHCI_TASK_DESC_SZ_128) {\n\t\tcqhci_writel(cq_host, cqhci_readl(cq_host, CQHCI_CFG) |\n\t\t\t       CQHCI_TASK_DESC_SZ, CQHCI_CFG);\n\t\tcq_host->task_desc_len = 16;\n\t} else {\n\t\tcq_host->task_desc_len = 8;\n\t}\n\n\t \n\tif (cq_host->dma64) {\n\t\tif (cq_host->quirks & CQHCI_QUIRK_SHORT_TXFR_DESC_SZ)\n\t\t\tcq_host->trans_desc_len = 12;\n\t\telse\n\t\t\tcq_host->trans_desc_len = 16;\n\t\tcq_host->link_desc_len = 16;\n\t} else {\n\t\tcq_host->trans_desc_len = 8;\n\t\tcq_host->link_desc_len = 8;\n\t}\n\n\t \n\tcq_host->slot_sz = cq_host->task_desc_len + cq_host->link_desc_len;\n\n\tcq_host->desc_size = cq_host->slot_sz * cq_host->num_slots;\n\n\tcq_host->data_size = get_trans_desc_offset(cq_host, cq_host->mmc->cqe_qdepth);\n\n\tpr_debug(\"%s: cqhci: desc_size: %zu data_sz: %zu slot-sz: %d\\n\",\n\t\t mmc_hostname(cq_host->mmc), cq_host->desc_size, cq_host->data_size,\n\t\t cq_host->slot_sz);\n\n\t \n\tcq_host->desc_base = dmam_alloc_coherent(mmc_dev(cq_host->mmc),\n\t\t\t\t\t\t cq_host->desc_size,\n\t\t\t\t\t\t &cq_host->desc_dma_base,\n\t\t\t\t\t\t GFP_KERNEL);\n\tif (!cq_host->desc_base)\n\t\treturn -ENOMEM;\n\n\tcq_host->trans_desc_base = dmam_alloc_coherent(mmc_dev(cq_host->mmc),\n\t\t\t\t\t      cq_host->data_size,\n\t\t\t\t\t      &cq_host->trans_desc_dma_base,\n\t\t\t\t\t      GFP_KERNEL);\n\tif (!cq_host->trans_desc_base) {\n\t\tdmam_free_coherent(mmc_dev(cq_host->mmc), cq_host->desc_size,\n\t\t\t\t   cq_host->desc_base,\n\t\t\t\t   cq_host->desc_dma_base);\n\t\tcq_host->desc_base = NULL;\n\t\tcq_host->desc_dma_base = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tpr_debug(\"%s: cqhci: desc-base: 0x%p trans-base: 0x%p\\n desc_dma 0x%llx trans_dma: 0x%llx\\n\",\n\t\t mmc_hostname(cq_host->mmc), cq_host->desc_base, cq_host->trans_desc_base,\n\t\t(unsigned long long)cq_host->desc_dma_base,\n\t\t(unsigned long long)cq_host->trans_desc_dma_base);\n\n\tfor (; i < (cq_host->num_slots); i++)\n\t\tsetup_trans_desc(cq_host, i);\n\n\treturn 0;\n}\n\nstatic void __cqhci_enable(struct cqhci_host *cq_host)\n{\n\tstruct mmc_host *mmc = cq_host->mmc;\n\tu32 cqcfg;\n\n\tcqcfg = cqhci_readl(cq_host, CQHCI_CFG);\n\n\t \n\tif (cqcfg & CQHCI_ENABLE) {\n\t\tcqcfg &= ~CQHCI_ENABLE;\n\t\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\t}\n\n\tcqcfg &= ~(CQHCI_DCMD | CQHCI_TASK_DESC_SZ);\n\n\tif (mmc->caps2 & MMC_CAP2_CQE_DCMD)\n\t\tcqcfg |= CQHCI_DCMD;\n\n\tif (cq_host->caps & CQHCI_TASK_DESC_SZ_128)\n\t\tcqcfg |= CQHCI_TASK_DESC_SZ;\n\n\tif (mmc->caps2 & MMC_CAP2_CRYPTO)\n\t\tcqcfg |= CQHCI_CRYPTO_GENERAL_ENABLE;\n\n\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\n\tcqhci_writel(cq_host, lower_32_bits(cq_host->desc_dma_base),\n\t\t     CQHCI_TDLBA);\n\tcqhci_writel(cq_host, upper_32_bits(cq_host->desc_dma_base),\n\t\t     CQHCI_TDLBAU);\n\n\tcqhci_writel(cq_host, cq_host->rca, CQHCI_SSC2);\n\n\tcqhci_set_irqs(cq_host, 0);\n\n\tcqcfg |= CQHCI_ENABLE;\n\n\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\n\tif (cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_HALT)\n\t\tcqhci_writel(cq_host, 0, CQHCI_CTL);\n\n\tmmc->cqe_on = true;\n\n\tif (cq_host->ops->enable)\n\t\tcq_host->ops->enable(mmc);\n\n\t \n\twmb();\n\n\tcqhci_set_irqs(cq_host, CQHCI_IS_MASK);\n\n\tcq_host->activated = true;\n}\n\nstatic void __cqhci_disable(struct cqhci_host *cq_host)\n{\n\tu32 cqcfg;\n\n\tcqcfg = cqhci_readl(cq_host, CQHCI_CFG);\n\tcqcfg &= ~CQHCI_ENABLE;\n\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\n\tcq_host->mmc->cqe_on = false;\n\n\tcq_host->activated = false;\n}\n\nint cqhci_deactivate(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\tif (cq_host->enabled && cq_host->activated)\n\t\t__cqhci_disable(cq_host);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(cqhci_deactivate);\n\nint cqhci_resume(struct mmc_host *mmc)\n{\n\t \n\treturn 0;\n}\nEXPORT_SYMBOL(cqhci_resume);\n\nstatic int cqhci_enable(struct mmc_host *mmc, struct mmc_card *card)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tint err;\n\n\tif (!card->ext_csd.cmdq_en)\n\t\treturn -EINVAL;\n\n\tif (cq_host->enabled)\n\t\treturn 0;\n\n\tcq_host->rca = card->rca;\n\n\terr = cqhci_host_alloc_tdl(cq_host);\n\tif (err) {\n\t\tpr_err(\"%s: Failed to enable CQE, error %d\\n\",\n\t\t       mmc_hostname(mmc), err);\n\t\treturn err;\n\t}\n\n\t__cqhci_enable(cq_host);\n\n\tcq_host->enabled = true;\n\n#ifdef DEBUG\n\tcqhci_dumpregs(cq_host);\n#endif\n\treturn 0;\n}\n\n \n#define CQHCI_OFF_TIMEOUT 100\n\nstatic u32 cqhci_read_ctl(struct cqhci_host *cq_host)\n{\n\treturn cqhci_readl(cq_host, CQHCI_CTL);\n}\n\nstatic void cqhci_off(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu32 reg;\n\tint err;\n\n\tif (!cq_host->enabled || !mmc->cqe_on || cq_host->recovery_halt)\n\t\treturn;\n\n\tif (cq_host->ops->disable)\n\t\tcq_host->ops->disable(mmc, false);\n\n\tcqhci_writel(cq_host, CQHCI_HALT, CQHCI_CTL);\n\n\terr = readx_poll_timeout(cqhci_read_ctl, cq_host, reg,\n\t\t\t\t reg & CQHCI_HALT, 0, CQHCI_OFF_TIMEOUT);\n\tif (err < 0)\n\t\tpr_err(\"%s: cqhci: CQE stuck on\\n\", mmc_hostname(mmc));\n\telse\n\t\tpr_debug(\"%s: cqhci: CQE off\\n\", mmc_hostname(mmc));\n\n\tif (cq_host->ops->post_disable)\n\t\tcq_host->ops->post_disable(mmc);\n\n\tmmc->cqe_on = false;\n}\n\nstatic void cqhci_disable(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\tif (!cq_host->enabled)\n\t\treturn;\n\n\tcqhci_off(mmc);\n\n\t__cqhci_disable(cq_host);\n\n\tdmam_free_coherent(mmc_dev(mmc), cq_host->data_size,\n\t\t\t   cq_host->trans_desc_base,\n\t\t\t   cq_host->trans_desc_dma_base);\n\n\tdmam_free_coherent(mmc_dev(mmc), cq_host->desc_size,\n\t\t\t   cq_host->desc_base,\n\t\t\t   cq_host->desc_dma_base);\n\n\tcq_host->trans_desc_base = NULL;\n\tcq_host->desc_base = NULL;\n\n\tcq_host->enabled = false;\n}\n\nstatic void cqhci_prep_task_desc(struct mmc_request *mrq,\n\t\t\t\t struct cqhci_host *cq_host, int tag)\n{\n\t__le64 *task_desc = (__le64 __force *)get_desc(cq_host, tag);\n\tu32 req_flags = mrq->data->flags;\n\tu64 desc0;\n\n\tdesc0 = CQHCI_VALID(1) |\n\t\tCQHCI_END(1) |\n\t\tCQHCI_INT(1) |\n\t\tCQHCI_ACT(0x5) |\n\t\tCQHCI_FORCED_PROG(!!(req_flags & MMC_DATA_FORCED_PRG)) |\n\t\tCQHCI_DATA_TAG(!!(req_flags & MMC_DATA_DAT_TAG)) |\n\t\tCQHCI_DATA_DIR(!!(req_flags & MMC_DATA_READ)) |\n\t\tCQHCI_PRIORITY(!!(req_flags & MMC_DATA_PRIO)) |\n\t\tCQHCI_QBAR(!!(req_flags & MMC_DATA_QBR)) |\n\t\tCQHCI_REL_WRITE(!!(req_flags & MMC_DATA_REL_WR)) |\n\t\tCQHCI_BLK_COUNT(mrq->data->blocks) |\n\t\tCQHCI_BLK_ADDR((u64)mrq->data->blk_addr);\n\n\ttask_desc[0] = cpu_to_le64(desc0);\n\n\tif (cq_host->caps & CQHCI_TASK_DESC_SZ_128) {\n\t\tu64 desc1 = cqhci_crypto_prep_task_desc(mrq);\n\n\t\ttask_desc[1] = cpu_to_le64(desc1);\n\n\t\tpr_debug(\"%s: cqhci: tag %d task descriptor 0x%016llx%016llx\\n\",\n\t\t\t mmc_hostname(mrq->host), mrq->tag, desc1, desc0);\n\t} else {\n\t\tpr_debug(\"%s: cqhci: tag %d task descriptor 0x%016llx\\n\",\n\t\t\t mmc_hostname(mrq->host), mrq->tag, desc0);\n\t}\n}\n\nstatic int cqhci_dma_map(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tint sg_count;\n\tstruct mmc_data *data = mrq->data;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tsg_count = dma_map_sg(mmc_dev(host), data->sg,\n\t\t\t      data->sg_len,\n\t\t\t      (data->flags & MMC_DATA_WRITE) ?\n\t\t\t      DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\tif (!sg_count) {\n\t\tpr_err(\"%s: sg-len: %d\\n\", __func__, data->sg_len);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn sg_count;\n}\n\nstatic void cqhci_set_tran_desc(u8 *desc, dma_addr_t addr, int len, bool end,\n\t\t\t\tbool dma64)\n{\n\t__le32 *attr = (__le32 __force *)desc;\n\n\t*attr = (CQHCI_VALID(1) |\n\t\t CQHCI_END(end ? 1 : 0) |\n\t\t CQHCI_INT(0) |\n\t\t CQHCI_ACT(0x4) |\n\t\t CQHCI_DAT_LENGTH(len));\n\n\tif (dma64) {\n\t\t__le64 *dataddr = (__le64 __force *)(desc + 4);\n\n\t\tdataddr[0] = cpu_to_le64(addr);\n\t} else {\n\t\t__le32 *dataddr = (__le32 __force *)(desc + 4);\n\n\t\tdataddr[0] = cpu_to_le32(addr);\n\t}\n}\n\nstatic int cqhci_prep_tran_desc(struct mmc_request *mrq,\n\t\t\t       struct cqhci_host *cq_host, int tag)\n{\n\tstruct mmc_data *data = mrq->data;\n\tint i, sg_count, len;\n\tbool end = false;\n\tbool dma64 = cq_host->dma64;\n\tdma_addr_t addr;\n\tu8 *desc;\n\tstruct scatterlist *sg;\n\n\tsg_count = cqhci_dma_map(mrq->host, mrq);\n\tif (sg_count < 0) {\n\t\tpr_err(\"%s: %s: unable to map sg lists, %d\\n\",\n\t\t\t\tmmc_hostname(mrq->host), __func__, sg_count);\n\t\treturn sg_count;\n\t}\n\n\tdesc = get_trans_desc(cq_host, tag);\n\n\tfor_each_sg(data->sg, sg, sg_count, i) {\n\t\taddr = sg_dma_address(sg);\n\t\tlen = sg_dma_len(sg);\n\n\t\tif ((i+1) == sg_count)\n\t\t\tend = true;\n\t\tcqhci_set_tran_desc(desc, addr, len, end, dma64);\n\t\tdesc += cq_host->trans_desc_len;\n\t}\n\n\treturn 0;\n}\n\nstatic void cqhci_prep_dcmd_desc(struct mmc_host *mmc,\n\t\t\t\t   struct mmc_request *mrq)\n{\n\tu64 *task_desc = NULL;\n\tu64 data = 0;\n\tu8 resp_type;\n\tu8 *desc;\n\t__le64 *dataddr;\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tu8 timing;\n\n\tif (!(mrq->cmd->flags & MMC_RSP_PRESENT)) {\n\t\tresp_type = 0x0;\n\t\ttiming = 0x1;\n\t} else {\n\t\tif (mrq->cmd->flags & MMC_RSP_R1B) {\n\t\t\tresp_type = 0x3;\n\t\t\ttiming = 0x0;\n\t\t} else {\n\t\t\tresp_type = 0x2;\n\t\t\ttiming = 0x1;\n\t\t}\n\t}\n\n\ttask_desc = (__le64 __force *)get_desc(cq_host, cq_host->dcmd_slot);\n\tmemset(task_desc, 0, cq_host->task_desc_len);\n\tdata |= (CQHCI_VALID(1) |\n\t\t CQHCI_END(1) |\n\t\t CQHCI_INT(1) |\n\t\t CQHCI_QBAR(1) |\n\t\t CQHCI_ACT(0x5) |\n\t\t CQHCI_CMD_INDEX(mrq->cmd->opcode) |\n\t\t CQHCI_CMD_TIMING(timing) | CQHCI_RESP_TYPE(resp_type));\n\tif (cq_host->ops->update_dcmd_desc)\n\t\tcq_host->ops->update_dcmd_desc(mmc, mrq, &data);\n\t*task_desc |= data;\n\tdesc = (u8 *)task_desc;\n\tpr_debug(\"%s: cqhci: dcmd: cmd: %d timing: %d resp: %d\\n\",\n\t\t mmc_hostname(mmc), mrq->cmd->opcode, timing, resp_type);\n\tdataddr = (__le64 __force *)(desc + 4);\n\tdataddr[0] = cpu_to_le64((u64)mrq->cmd->arg);\n\n}\n\nstatic void cqhci_post_req(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tstruct mmc_data *data = mrq->data;\n\n\tif (data) {\n\t\tdma_unmap_sg(mmc_dev(host), data->sg, data->sg_len,\n\t\t\t     (data->flags & MMC_DATA_READ) ?\n\t\t\t     DMA_FROM_DEVICE : DMA_TO_DEVICE);\n\t}\n}\n\nstatic inline int cqhci_tag(struct mmc_request *mrq)\n{\n\treturn mrq->cmd ? DCMD_SLOT : mrq->tag;\n}\n\nstatic int cqhci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tint err = 0;\n\tint tag = cqhci_tag(mrq);\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tunsigned long flags;\n\n\tif (!cq_host->enabled) {\n\t\tpr_err(\"%s: cqhci: not enabled\\n\", mmc_hostname(mmc));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!cq_host->activated)\n\t\t__cqhci_enable(cq_host);\n\n\tif (!mmc->cqe_on) {\n\t\tif (cq_host->ops->pre_enable)\n\t\t\tcq_host->ops->pre_enable(mmc);\n\n\t\tcqhci_writel(cq_host, 0, CQHCI_CTL);\n\t\tmmc->cqe_on = true;\n\t\tpr_debug(\"%s: cqhci: CQE on\\n\", mmc_hostname(mmc));\n\t\tif (cqhci_readl(cq_host, CQHCI_CTL) && CQHCI_HALT) {\n\t\t\tpr_err(\"%s: cqhci: CQE failed to exit halt state\\n\",\n\t\t\t       mmc_hostname(mmc));\n\t\t}\n\t\tif (cq_host->ops->enable)\n\t\t\tcq_host->ops->enable(mmc);\n\t}\n\n\tif (mrq->data) {\n\t\tcqhci_prep_task_desc(mrq, cq_host, tag);\n\n\t\terr = cqhci_prep_tran_desc(mrq, cq_host, tag);\n\t\tif (err) {\n\t\t\tpr_err(\"%s: cqhci: failed to setup tx desc: %d\\n\",\n\t\t\t       mmc_hostname(mmc), err);\n\t\t\treturn err;\n\t\t}\n\t} else {\n\t\tcqhci_prep_dcmd_desc(mmc, mrq);\n\t}\n\n\tspin_lock_irqsave(&cq_host->lock, flags);\n\n\tif (cq_host->recovery_halt) {\n\t\terr = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tcq_host->slot[tag].mrq = mrq;\n\tcq_host->slot[tag].flags = 0;\n\n\tcq_host->qcnt += 1;\n\t \n\twmb();\n\tcqhci_writel(cq_host, 1 << tag, CQHCI_TDBR);\n\tif (!(cqhci_readl(cq_host, CQHCI_TDBR) & (1 << tag)))\n\t\tpr_debug(\"%s: cqhci: doorbell not set for tag %d\\n\",\n\t\t\t mmc_hostname(mmc), tag);\nout_unlock:\n\tspin_unlock_irqrestore(&cq_host->lock, flags);\n\n\tif (err)\n\t\tcqhci_post_req(mmc, mrq);\n\n\treturn err;\n}\n\nstatic void cqhci_recovery_needed(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\t\t\t  bool notify)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\tif (!cq_host->recovery_halt) {\n\t\tcq_host->recovery_halt = true;\n\t\tpr_debug(\"%s: cqhci: recovery needed\\n\", mmc_hostname(mmc));\n\t\twake_up(&cq_host->wait_queue);\n\t\tif (notify && mrq->recovery_notifier)\n\t\t\tmrq->recovery_notifier(mrq);\n\t}\n}\n\nstatic unsigned int cqhci_error_flags(int error1, int error2)\n{\n\tint error = error1 ? error1 : error2;\n\n\tswitch (error) {\n\tcase -EILSEQ:\n\t\treturn CQHCI_HOST_CRC;\n\tcase -ETIMEDOUT:\n\t\treturn CQHCI_HOST_TIMEOUT;\n\tdefault:\n\t\treturn CQHCI_HOST_OTHER;\n\t}\n}\n\nstatic void cqhci_error_irq(struct mmc_host *mmc, u32 status, int cmd_error,\n\t\t\t    int data_error)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tstruct cqhci_slot *slot;\n\tu32 terri;\n\tu32 tdpe;\n\tint tag;\n\n\tspin_lock(&cq_host->lock);\n\n\tterri = cqhci_readl(cq_host, CQHCI_TERRI);\n\n\tpr_debug(\"%s: cqhci: error IRQ status: 0x%08x cmd error %d data error %d TERRI: 0x%08x\\n\",\n\t\t mmc_hostname(mmc), status, cmd_error, data_error, terri);\n\n\t \n\tif (cq_host->recovery_halt)\n\t\tgoto out_unlock;\n\n\tif (!cq_host->qcnt) {\n\t\tWARN_ONCE(1, \"%s: cqhci: error when idle. IRQ status: 0x%08x cmd error %d data error %d TERRI: 0x%08x\\n\",\n\t\t\t  mmc_hostname(mmc), status, cmd_error, data_error,\n\t\t\t  terri);\n\t\tgoto out_unlock;\n\t}\n\n\tif (CQHCI_TERRI_C_VALID(terri)) {\n\t\ttag = CQHCI_TERRI_C_TASK(terri);\n\t\tslot = &cq_host->slot[tag];\n\t\tif (slot->mrq) {\n\t\t\tslot->flags = cqhci_error_flags(cmd_error, data_error);\n\t\t\tcqhci_recovery_needed(mmc, slot->mrq, true);\n\t\t}\n\t}\n\n\tif (CQHCI_TERRI_D_VALID(terri)) {\n\t\ttag = CQHCI_TERRI_D_TASK(terri);\n\t\tslot = &cq_host->slot[tag];\n\t\tif (slot->mrq) {\n\t\t\tslot->flags = cqhci_error_flags(data_error, cmd_error);\n\t\t\tcqhci_recovery_needed(mmc, slot->mrq, true);\n\t\t}\n\t}\n\n\t \n\tif (status & CQHCI_IS_ICCE) {\n\t\ttdpe = cqhci_readl(cq_host, CQHCI_TDPE);\n\t\tWARN_ONCE(1,\n\t\t\t  \"%s: cqhci: invalid crypto configuration error. IRQ status: 0x%08x TDPE: 0x%08x\\n\",\n\t\t\t  mmc_hostname(mmc), status, tdpe);\n\t\twhile (tdpe != 0) {\n\t\t\ttag = __ffs(tdpe);\n\t\t\ttdpe &= ~(1 << tag);\n\t\t\tslot = &cq_host->slot[tag];\n\t\t\tif (!slot->mrq)\n\t\t\t\tcontinue;\n\t\t\tslot->flags = cqhci_error_flags(data_error, cmd_error);\n\t\t\tcqhci_recovery_needed(mmc, slot->mrq, true);\n\t\t}\n\t}\n\n\tif (!cq_host->recovery_halt) {\n\t\t \n\t\tfor (tag = 0; tag < NUM_SLOTS; tag++) {\n\t\t\tslot = &cq_host->slot[tag];\n\t\t\tif (!slot->mrq)\n\t\t\t\tcontinue;\n\t\t\tslot->flags = cqhci_error_flags(data_error, cmd_error);\n\t\t\tcqhci_recovery_needed(mmc, slot->mrq, true);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout_unlock:\n\tspin_unlock(&cq_host->lock);\n}\n\nstatic void cqhci_finish_mrq(struct mmc_host *mmc, unsigned int tag)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tstruct cqhci_slot *slot = &cq_host->slot[tag];\n\tstruct mmc_request *mrq = slot->mrq;\n\tstruct mmc_data *data;\n\n\tif (!mrq) {\n\t\tWARN_ONCE(1, \"%s: cqhci: spurious TCN for tag %d\\n\",\n\t\t\t  mmc_hostname(mmc), tag);\n\t\treturn;\n\t}\n\n\t \n\tif (cq_host->recovery_halt) {\n\t\tslot->flags |= CQHCI_COMPLETED;\n\t\treturn;\n\t}\n\n\tslot->mrq = NULL;\n\n\tcq_host->qcnt -= 1;\n\n\tdata = mrq->data;\n\tif (data) {\n\t\tif (data->error)\n\t\t\tdata->bytes_xfered = 0;\n\t\telse\n\t\t\tdata->bytes_xfered = data->blksz * data->blocks;\n\t}\n\n\tmmc_cqe_request_done(mmc, mrq);\n}\n\nirqreturn_t cqhci_irq(struct mmc_host *mmc, u32 intmask, int cmd_error,\n\t\t      int data_error)\n{\n\tu32 status;\n\tunsigned long tag = 0, comp_status;\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\tstatus = cqhci_readl(cq_host, CQHCI_IS);\n\tcqhci_writel(cq_host, status, CQHCI_IS);\n\n\tpr_debug(\"%s: cqhci: IRQ status: 0x%08x\\n\", mmc_hostname(mmc), status);\n\n\tif ((status & (CQHCI_IS_RED | CQHCI_IS_GCE | CQHCI_IS_ICCE)) ||\n\t    cmd_error || data_error) {\n\t\tif (status & CQHCI_IS_RED)\n\t\t\tmmc_debugfs_err_stats_inc(mmc, MMC_ERR_CMDQ_RED);\n\t\tif (status & CQHCI_IS_GCE)\n\t\t\tmmc_debugfs_err_stats_inc(mmc, MMC_ERR_CMDQ_GCE);\n\t\tif (status & CQHCI_IS_ICCE)\n\t\t\tmmc_debugfs_err_stats_inc(mmc, MMC_ERR_CMDQ_ICCE);\n\t\tcqhci_error_irq(mmc, status, cmd_error, data_error);\n\t}\n\n\tif (status & CQHCI_IS_TCC) {\n\t\t \n\t\tcomp_status = cqhci_readl(cq_host, CQHCI_TCN);\n\t\tcqhci_writel(cq_host, comp_status, CQHCI_TCN);\n\t\tpr_debug(\"%s: cqhci: TCN: 0x%08lx\\n\",\n\t\t\t mmc_hostname(mmc), comp_status);\n\n\t\tspin_lock(&cq_host->lock);\n\n\t\tfor_each_set_bit(tag, &comp_status, cq_host->num_slots) {\n\t\t\t \n\t\t\tpr_debug(\"%s: cqhci: completing tag %lu\\n\",\n\t\t\t\t mmc_hostname(mmc), tag);\n\t\t\tcqhci_finish_mrq(mmc, tag);\n\t\t}\n\n\t\tif (cq_host->waiting_for_idle && !cq_host->qcnt) {\n\t\t\tcq_host->waiting_for_idle = false;\n\t\t\twake_up(&cq_host->wait_queue);\n\t\t}\n\n\t\tspin_unlock(&cq_host->lock);\n\t}\n\n\tif (status & CQHCI_IS_TCL)\n\t\twake_up(&cq_host->wait_queue);\n\n\tif (status & CQHCI_IS_HAC)\n\t\twake_up(&cq_host->wait_queue);\n\n\treturn IRQ_HANDLED;\n}\nEXPORT_SYMBOL(cqhci_irq);\n\nstatic bool cqhci_is_idle(struct cqhci_host *cq_host, int *ret)\n{\n\tunsigned long flags;\n\tbool is_idle;\n\n\tspin_lock_irqsave(&cq_host->lock, flags);\n\tis_idle = !cq_host->qcnt || cq_host->recovery_halt;\n\t*ret = cq_host->recovery_halt ? -EBUSY : 0;\n\tcq_host->waiting_for_idle = !is_idle;\n\tspin_unlock_irqrestore(&cq_host->lock, flags);\n\n\treturn is_idle;\n}\n\nstatic int cqhci_wait_for_idle(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tint ret;\n\n\twait_event(cq_host->wait_queue, cqhci_is_idle(cq_host, &ret));\n\n\treturn ret;\n}\n\nstatic bool cqhci_timeout(struct mmc_host *mmc, struct mmc_request *mrq,\n\t\t\t  bool *recovery_needed)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tint tag = cqhci_tag(mrq);\n\tstruct cqhci_slot *slot = &cq_host->slot[tag];\n\tunsigned long flags;\n\tbool timed_out;\n\n\tspin_lock_irqsave(&cq_host->lock, flags);\n\ttimed_out = slot->mrq == mrq;\n\tif (timed_out) {\n\t\tslot->flags |= CQHCI_EXTERNAL_TIMEOUT;\n\t\tcqhci_recovery_needed(mmc, mrq, false);\n\t\t*recovery_needed = cq_host->recovery_halt;\n\t}\n\tspin_unlock_irqrestore(&cq_host->lock, flags);\n\n\tif (timed_out) {\n\t\tpr_err(\"%s: cqhci: timeout for tag %d, qcnt %d\\n\",\n\t\t       mmc_hostname(mmc), tag, cq_host->qcnt);\n\t\tcqhci_dumpregs(cq_host);\n\t}\n\n\treturn timed_out;\n}\n\nstatic bool cqhci_tasks_cleared(struct cqhci_host *cq_host)\n{\n\treturn !(cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_CLEAR_ALL_TASKS);\n}\n\nstatic bool cqhci_clear_all_tasks(struct mmc_host *mmc, unsigned int timeout)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tbool ret;\n\tu32 ctl;\n\n\tcqhci_set_irqs(cq_host, CQHCI_IS_TCL);\n\n\tctl = cqhci_readl(cq_host, CQHCI_CTL);\n\tctl |= CQHCI_CLEAR_ALL_TASKS;\n\tcqhci_writel(cq_host, ctl, CQHCI_CTL);\n\n\twait_event_timeout(cq_host->wait_queue, cqhci_tasks_cleared(cq_host),\n\t\t\t   msecs_to_jiffies(timeout) + 1);\n\n\tcqhci_set_irqs(cq_host, 0);\n\n\tret = cqhci_tasks_cleared(cq_host);\n\n\tif (!ret)\n\t\tpr_warn(\"%s: cqhci: Failed to clear tasks\\n\",\n\t\t\tmmc_hostname(mmc));\n\n\treturn ret;\n}\n\nstatic bool cqhci_halted(struct cqhci_host *cq_host)\n{\n\treturn cqhci_readl(cq_host, CQHCI_CTL) & CQHCI_HALT;\n}\n\nstatic bool cqhci_halt(struct mmc_host *mmc, unsigned int timeout)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tbool ret;\n\tu32 ctl;\n\n\tif (cqhci_halted(cq_host))\n\t\treturn true;\n\n\tcqhci_set_irqs(cq_host, CQHCI_IS_HAC);\n\n\tctl = cqhci_readl(cq_host, CQHCI_CTL);\n\tctl |= CQHCI_HALT;\n\tcqhci_writel(cq_host, ctl, CQHCI_CTL);\n\n\twait_event_timeout(cq_host->wait_queue, cqhci_halted(cq_host),\n\t\t\t   msecs_to_jiffies(timeout) + 1);\n\n\tcqhci_set_irqs(cq_host, 0);\n\n\tret = cqhci_halted(cq_host);\n\n\tif (!ret)\n\t\tpr_warn(\"%s: cqhci: Failed to halt\\n\", mmc_hostname(mmc));\n\n\treturn ret;\n}\n\n \n#define CQHCI_START_HALT_TIMEOUT\t500\n\nstatic void cqhci_recovery_start(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\n\tpr_debug(\"%s: cqhci: %s\\n\", mmc_hostname(mmc), __func__);\n\n\tWARN_ON(!cq_host->recovery_halt);\n\n\tcqhci_halt(mmc, CQHCI_START_HALT_TIMEOUT);\n\n\tif (cq_host->ops->disable)\n\t\tcq_host->ops->disable(mmc, true);\n\n\tmmc->cqe_on = false;\n}\n\nstatic int cqhci_error_from_flags(unsigned int flags)\n{\n\tif (!flags)\n\t\treturn 0;\n\n\t \n\tif (flags & CQHCI_HOST_CRC)\n\t\treturn -EILSEQ;\n\n\tif (flags & (CQHCI_EXTERNAL_TIMEOUT | CQHCI_HOST_TIMEOUT))\n\t\treturn -ETIMEDOUT;\n\n\treturn -EIO;\n}\n\nstatic void cqhci_recover_mrq(struct cqhci_host *cq_host, unsigned int tag)\n{\n\tstruct cqhci_slot *slot = &cq_host->slot[tag];\n\tstruct mmc_request *mrq = slot->mrq;\n\tstruct mmc_data *data;\n\n\tif (!mrq)\n\t\treturn;\n\n\tslot->mrq = NULL;\n\n\tcq_host->qcnt -= 1;\n\n\tdata = mrq->data;\n\tif (data) {\n\t\tdata->bytes_xfered = 0;\n\t\tdata->error = cqhci_error_from_flags(slot->flags);\n\t} else {\n\t\tmrq->cmd->error = cqhci_error_from_flags(slot->flags);\n\t}\n\n\tmmc_cqe_request_done(cq_host->mmc, mrq);\n}\n\nstatic void cqhci_recover_mrqs(struct cqhci_host *cq_host)\n{\n\tint i;\n\n\tfor (i = 0; i < cq_host->num_slots; i++)\n\t\tcqhci_recover_mrq(cq_host, i);\n}\n\n \n#define CQHCI_FINISH_HALT_TIMEOUT\t20\n\n \n#define CQHCI_CLEAR_TIMEOUT\t\t20\n\nstatic void cqhci_recovery_finish(struct mmc_host *mmc)\n{\n\tstruct cqhci_host *cq_host = mmc->cqe_private;\n\tunsigned long flags;\n\tu32 cqcfg;\n\tbool ok;\n\n\tpr_debug(\"%s: cqhci: %s\\n\", mmc_hostname(mmc), __func__);\n\n\tWARN_ON(!cq_host->recovery_halt);\n\n\tok = cqhci_halt(mmc, CQHCI_FINISH_HALT_TIMEOUT);\n\n\t \n\tif (!cqhci_clear_all_tasks(mmc, CQHCI_CLEAR_TIMEOUT))\n\t\tok = false;\n\n\t \n\tcqcfg = cqhci_readl(cq_host, CQHCI_CFG);\n\tcqcfg &= ~CQHCI_ENABLE;\n\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\n\tcqcfg = cqhci_readl(cq_host, CQHCI_CFG);\n\tcqcfg |= CQHCI_ENABLE;\n\tcqhci_writel(cq_host, cqcfg, CQHCI_CFG);\n\n\tcqhci_halt(mmc, CQHCI_FINISH_HALT_TIMEOUT);\n\n\tif (!ok)\n\t\tcqhci_clear_all_tasks(mmc, CQHCI_CLEAR_TIMEOUT);\n\n\tcqhci_recover_mrqs(cq_host);\n\n\tWARN_ON(cq_host->qcnt);\n\n\tspin_lock_irqsave(&cq_host->lock, flags);\n\tcq_host->qcnt = 0;\n\tcq_host->recovery_halt = false;\n\tmmc->cqe_on = false;\n\tspin_unlock_irqrestore(&cq_host->lock, flags);\n\n\t \n\twmb();\n\n\tcqhci_writel(cq_host, CQHCI_IS_HAC | CQHCI_IS_TCL, CQHCI_IS);\n\n\tcqhci_set_irqs(cq_host, CQHCI_IS_MASK);\n\n\tpr_debug(\"%s: cqhci: recovery done\\n\", mmc_hostname(mmc));\n}\n\nstatic const struct mmc_cqe_ops cqhci_cqe_ops = {\n\t.cqe_enable = cqhci_enable,\n\t.cqe_disable = cqhci_disable,\n\t.cqe_request = cqhci_request,\n\t.cqe_post_req = cqhci_post_req,\n\t.cqe_off = cqhci_off,\n\t.cqe_wait_for_idle = cqhci_wait_for_idle,\n\t.cqe_timeout = cqhci_timeout,\n\t.cqe_recovery_start = cqhci_recovery_start,\n\t.cqe_recovery_finish = cqhci_recovery_finish,\n};\n\nstruct cqhci_host *cqhci_pltfm_init(struct platform_device *pdev)\n{\n\tstruct cqhci_host *cq_host;\n\tstruct resource *cqhci_memres = NULL;\n\n\t \n\tcqhci_memres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"cqhci\");\n\tif (!cqhci_memres) {\n\t\tdev_dbg(&pdev->dev, \"CMDQ not supported\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tcq_host = devm_kzalloc(&pdev->dev, sizeof(*cq_host), GFP_KERNEL);\n\tif (!cq_host)\n\t\treturn ERR_PTR(-ENOMEM);\n\tcq_host->mmio = devm_ioremap(&pdev->dev,\n\t\t\t\t     cqhci_memres->start,\n\t\t\t\t     resource_size(cqhci_memres));\n\tif (!cq_host->mmio) {\n\t\tdev_err(&pdev->dev, \"failed to remap cqhci regs\\n\");\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tdev_dbg(&pdev->dev, \"CMDQ ioremap: done\\n\");\n\n\treturn cq_host;\n}\nEXPORT_SYMBOL(cqhci_pltfm_init);\n\nstatic unsigned int cqhci_ver_major(struct cqhci_host *cq_host)\n{\n\treturn CQHCI_VER_MAJOR(cqhci_readl(cq_host, CQHCI_VER));\n}\n\nstatic unsigned int cqhci_ver_minor(struct cqhci_host *cq_host)\n{\n\tu32 ver = cqhci_readl(cq_host, CQHCI_VER);\n\n\treturn CQHCI_VER_MINOR1(ver) * 10 + CQHCI_VER_MINOR2(ver);\n}\n\nint cqhci_init(struct cqhci_host *cq_host, struct mmc_host *mmc,\n\t      bool dma64)\n{\n\tint err;\n\n\tcq_host->dma64 = dma64;\n\tcq_host->mmc = mmc;\n\tcq_host->mmc->cqe_private = cq_host;\n\n\tcq_host->num_slots = NUM_SLOTS;\n\tcq_host->dcmd_slot = DCMD_SLOT;\n\n\tmmc->cqe_ops = &cqhci_cqe_ops;\n\n\tmmc->cqe_qdepth = NUM_SLOTS;\n\tif (mmc->caps2 & MMC_CAP2_CQE_DCMD)\n\t\tmmc->cqe_qdepth -= 1;\n\n\tcq_host->slot = devm_kcalloc(mmc_dev(mmc), cq_host->num_slots,\n\t\t\t\t     sizeof(*cq_host->slot), GFP_KERNEL);\n\tif (!cq_host->slot) {\n\t\terr = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\n\terr = cqhci_crypto_init(cq_host);\n\tif (err) {\n\t\tpr_err(\"%s: CQHCI crypto initialization failed\\n\",\n\t\t       mmc_hostname(mmc));\n\t\tgoto out_err;\n\t}\n\n\tspin_lock_init(&cq_host->lock);\n\n\tinit_completion(&cq_host->halt_comp);\n\tinit_waitqueue_head(&cq_host->wait_queue);\n\n\tpr_info(\"%s: CQHCI version %u.%02u\\n\",\n\t\tmmc_hostname(mmc), cqhci_ver_major(cq_host),\n\t\tcqhci_ver_minor(cq_host));\n\n\treturn 0;\n\nout_err:\n\tpr_err(\"%s: CQHCI version %u.%02u failed to initialize, error %d\\n\",\n\t       mmc_hostname(mmc), cqhci_ver_major(cq_host),\n\t       cqhci_ver_minor(cq_host), err);\n\treturn err;\n}\nEXPORT_SYMBOL(cqhci_init);\n\nMODULE_AUTHOR(\"Venkat Gopalakrishnan <venkatg@codeaurora.org>\");\nMODULE_DESCRIPTION(\"Command Queue Host Controller Interface driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}