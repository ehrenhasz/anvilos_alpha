{
  "module_name": "renesas_sdhi_sys_dmac.c",
  "hash_id": "0ba95292d8057dfafbeb4f0bf2c635d3010f3f46de7c8419e58a245a20630cd1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/renesas_sdhi_sys_dmac.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmaengine.h>\n#include <linux/mfd/tmio.h>\n#include <linux/mmc/host.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pagemap.h>\n#include <linux/scatterlist.h>\n#include <linux/sys_soc.h>\n\n#include \"renesas_sdhi.h\"\n#include \"tmio_mmc.h\"\n\n#define TMIO_MMC_MIN_DMA_LEN 8\n\nstatic const struct renesas_sdhi_of_data of_default_cfg = {\n\t.tmio_flags = TMIO_MMC_HAS_IDLE_WAIT,\n};\n\nstatic const struct renesas_sdhi_of_data of_rz_compatible = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_32BIT_DATA_PORT |\n\t\t\t  TMIO_MMC_HAVE_CBSY,\n\t.tmio_ocr_mask\t= MMC_VDD_32_33,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_WAIT_WHILE_BUSY,\n};\n\nstatic const struct renesas_sdhi_of_data of_rcar_gen1_compatible = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_CLK_ACTUAL,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_WAIT_WHILE_BUSY,\n\t.capabilities2\t= MMC_CAP2_NO_WRITE_PROTECT,\n};\n\n \nstatic struct renesas_sdhi_scc rcar_gen2_scc_taps[] = {\n\t{\n\t\t.clk_rate = 156000000,\n\t\t.tap = 0x00000703,\n\t},\n\t{\n\t\t.clk_rate = 0,\n\t\t.tap = 0x00000300,\n\t},\n};\n\nstatic const struct renesas_sdhi_of_data of_rcar_gen2_compatible = {\n\t.tmio_flags\t= TMIO_MMC_HAS_IDLE_WAIT | TMIO_MMC_CLK_ACTUAL |\n\t\t\t  TMIO_MMC_HAVE_CBSY | TMIO_MMC_MIN_RCAR2,\n\t.capabilities\t= MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ |\n\t\t\t  MMC_CAP_CMD23 | MMC_CAP_WAIT_WHILE_BUSY,\n\t.capabilities2\t= MMC_CAP2_NO_WRITE_PROTECT,\n\t.dma_buswidth\t= DMA_SLAVE_BUSWIDTH_4_BYTES,\n\t.dma_rx_offset\t= 0x2000,\n\t.scc_offset\t= 0x0300,\n\t.taps\t\t= rcar_gen2_scc_taps,\n\t.taps_num\t= ARRAY_SIZE(rcar_gen2_scc_taps),\n\t.max_blk_count\t= UINT_MAX / TMIO_MAX_BLK_SIZE,\n};\n\nstatic const struct of_device_id renesas_sdhi_sys_dmac_of_match[] = {\n\t{ .compatible = \"renesas,sdhi-sh73a0\", .data = &of_default_cfg, },\n\t{ .compatible = \"renesas,sdhi-r8a73a4\", .data = &of_default_cfg, },\n\t{ .compatible = \"renesas,sdhi-r8a7740\", .data = &of_default_cfg, },\n\t{ .compatible = \"renesas,sdhi-r7s72100\", .data = &of_rz_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7778\", .data = &of_rcar_gen1_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7779\", .data = &of_rcar_gen1_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7743\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7745\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7790\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7791\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7792\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7793\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-r8a7794\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,rcar-gen1-sdhi\", .data = &of_rcar_gen1_compatible, },\n\t{ .compatible = \"renesas,rcar-gen2-sdhi\", .data = &of_rcar_gen2_compatible, },\n\t{ .compatible = \"renesas,sdhi-shmobile\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, renesas_sdhi_sys_dmac_of_match);\n\nstatic void renesas_sdhi_sys_dmac_enable_dma(struct tmio_mmc_host *host,\n\t\t\t\t\t     bool enable)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tif (!host->chan_tx || !host->chan_rx)\n\t\treturn;\n\n\tif (priv->dma_priv.enable)\n\t\tpriv->dma_priv.enable(host, enable);\n}\n\nstatic void renesas_sdhi_sys_dmac_abort_dma(struct tmio_mmc_host *host)\n{\n\trenesas_sdhi_sys_dmac_enable_dma(host, false);\n\n\tif (host->chan_rx)\n\t\tdmaengine_terminate_sync(host->chan_rx);\n\tif (host->chan_tx)\n\t\tdmaengine_terminate_sync(host->chan_tx);\n\n\trenesas_sdhi_sys_dmac_enable_dma(host, true);\n}\n\nstatic void renesas_sdhi_sys_dmac_dataend_dma(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tcomplete(&priv->dma_priv.dma_dataend);\n}\n\nstatic void renesas_sdhi_sys_dmac_dma_callback(void *arg)\n{\n\tstruct tmio_mmc_host *host = arg;\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\tspin_lock_irq(&host->lock);\n\n\tif (!host->data)\n\t\tgoto out;\n\n\tif (host->data->flags & MMC_DATA_READ)\n\t\tdma_unmap_sg(host->chan_rx->device->dev,\n\t\t\t     host->sg_ptr, host->sg_len,\n\t\t\t     DMA_FROM_DEVICE);\n\telse\n\t\tdma_unmap_sg(host->chan_tx->device->dev,\n\t\t\t     host->sg_ptr, host->sg_len,\n\t\t\t     DMA_TO_DEVICE);\n\n\tspin_unlock_irq(&host->lock);\n\n\twait_for_completion(&priv->dma_priv.dma_dataend);\n\n\tspin_lock_irq(&host->lock);\n\ttmio_mmc_do_data_irq(host);\nout:\n\tspin_unlock_irq(&host->lock);\n}\n\nstatic void renesas_sdhi_sys_dmac_start_dma_rx(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct scatterlist *sg = host->sg_ptr, *sg_tmp;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_chan *chan = host->chan_rx;\n\tdma_cookie_t cookie;\n\tint ret, i;\n\tbool aligned = true, multiple = true;\n\tunsigned int align = 1;\t \n\n\tfor_each_sg(sg, sg_tmp, host->sg_len, i) {\n\t\tif (sg_tmp->offset & align)\n\t\t\taligned = false;\n\t\tif (sg_tmp->length & align) {\n\t\t\tmultiple = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((!aligned && (host->sg_len > 1 || sg->length > PAGE_SIZE ||\n\t\t\t  (align & PAGE_MASK))) || !multiple) {\n\t\tret = -EINVAL;\n\t\tgoto pio;\n\t}\n\n\tif (sg->length < TMIO_MMC_MIN_DMA_LEN)\n\t\treturn;\n\n\t \n\tif (!aligned) {\n\t\tsg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);\n\t\thost->sg_ptr = &host->bounce_sg;\n\t\tsg = host->sg_ptr;\n\t}\n\n\tret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_FROM_DEVICE);\n\tif (ret > 0)\n\t\tdesc = dmaengine_prep_slave_sg(chan, sg, ret, DMA_DEV_TO_MEM,\n\t\t\t\t\t       DMA_CTRL_ACK);\n\n\tif (desc) {\n\t\treinit_completion(&priv->dma_priv.dma_dataend);\n\t\tdesc->callback = renesas_sdhi_sys_dmac_dma_callback;\n\t\tdesc->callback_param = host;\n\n\t\tcookie = dmaengine_submit(desc);\n\t\tif (cookie < 0) {\n\t\t\tdesc = NULL;\n\t\t\tret = cookie;\n\t\t}\n\t\thost->dma_on = true;\n\t}\npio:\n\tif (!desc) {\n\t\t \n\t\trenesas_sdhi_sys_dmac_enable_dma(host, false);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\thost->chan_rx = NULL;\n\t\tdma_release_channel(chan);\n\t\t \n\t\tchan = host->chan_tx;\n\t\tif (chan) {\n\t\t\thost->chan_tx = NULL;\n\t\t\tdma_release_channel(chan);\n\t\t}\n\t\tdev_warn(&host->pdev->dev,\n\t\t\t \"DMA failed: %d, falling back to PIO\\n\", ret);\n\t}\n}\n\nstatic void renesas_sdhi_sys_dmac_start_dma_tx(struct tmio_mmc_host *host)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\tstruct scatterlist *sg = host->sg_ptr, *sg_tmp;\n\tstruct dma_async_tx_descriptor *desc = NULL;\n\tstruct dma_chan *chan = host->chan_tx;\n\tdma_cookie_t cookie;\n\tint ret, i;\n\tbool aligned = true, multiple = true;\n\tunsigned int align = 1;\t \n\n\tfor_each_sg(sg, sg_tmp, host->sg_len, i) {\n\t\tif (sg_tmp->offset & align)\n\t\t\taligned = false;\n\t\tif (sg_tmp->length & align) {\n\t\t\tmultiple = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif ((!aligned && (host->sg_len > 1 || sg->length > PAGE_SIZE ||\n\t\t\t  (align & PAGE_MASK))) || !multiple) {\n\t\tret = -EINVAL;\n\t\tgoto pio;\n\t}\n\n\tif (sg->length < TMIO_MMC_MIN_DMA_LEN)\n\t\treturn;\n\n\t \n\tif (!aligned) {\n\t\tvoid *sg_vaddr = kmap_local_page(sg_page(sg));\n\n\t\tsg_init_one(&host->bounce_sg, host->bounce_buf, sg->length);\n\t\tmemcpy(host->bounce_buf, sg_vaddr + sg->offset, host->bounce_sg.length);\n\t\tkunmap_local(sg_vaddr);\n\t\thost->sg_ptr = &host->bounce_sg;\n\t\tsg = host->sg_ptr;\n\t}\n\n\tret = dma_map_sg(chan->device->dev, sg, host->sg_len, DMA_TO_DEVICE);\n\tif (ret > 0)\n\t\tdesc = dmaengine_prep_slave_sg(chan, sg, ret, DMA_MEM_TO_DEV,\n\t\t\t\t\t       DMA_CTRL_ACK);\n\n\tif (desc) {\n\t\treinit_completion(&priv->dma_priv.dma_dataend);\n\t\tdesc->callback = renesas_sdhi_sys_dmac_dma_callback;\n\t\tdesc->callback_param = host;\n\n\t\tcookie = dmaengine_submit(desc);\n\t\tif (cookie < 0) {\n\t\t\tdesc = NULL;\n\t\t\tret = cookie;\n\t\t}\n\t\thost->dma_on = true;\n\t}\npio:\n\tif (!desc) {\n\t\t \n\t\trenesas_sdhi_sys_dmac_enable_dma(host, false);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\thost->chan_tx = NULL;\n\t\tdma_release_channel(chan);\n\t\t \n\t\tchan = host->chan_rx;\n\t\tif (chan) {\n\t\t\thost->chan_rx = NULL;\n\t\t\tdma_release_channel(chan);\n\t\t}\n\t\tdev_warn(&host->pdev->dev,\n\t\t\t \"DMA failed: %d, falling back to PIO\\n\", ret);\n\t}\n}\n\nstatic void renesas_sdhi_sys_dmac_start_dma(struct tmio_mmc_host *host,\n\t\t\t\t\t    struct mmc_data *data)\n{\n\tif (data->flags & MMC_DATA_READ) {\n\t\tif (host->chan_rx)\n\t\t\trenesas_sdhi_sys_dmac_start_dma_rx(host);\n\t} else {\n\t\tif (host->chan_tx)\n\t\t\trenesas_sdhi_sys_dmac_start_dma_tx(host);\n\t}\n}\n\nstatic void renesas_sdhi_sys_dmac_issue_tasklet_fn(unsigned long priv)\n{\n\tstruct tmio_mmc_host *host = (struct tmio_mmc_host *)priv;\n\tstruct dma_chan *chan = NULL;\n\n\tspin_lock_irq(&host->lock);\n\n\tif (host->data) {\n\t\tif (host->data->flags & MMC_DATA_READ)\n\t\t\tchan = host->chan_rx;\n\t\telse\n\t\t\tchan = host->chan_tx;\n\t}\n\n\tspin_unlock_irq(&host->lock);\n\n\ttmio_mmc_enable_mmc_irqs(host, TMIO_STAT_DATAEND);\n\n\tif (chan)\n\t\tdma_async_issue_pending(chan);\n}\n\nstatic void renesas_sdhi_sys_dmac_request_dma(struct tmio_mmc_host *host,\n\t\t\t\t\t      struct tmio_mmc_data *pdata)\n{\n\tstruct renesas_sdhi *priv = host_to_priv(host);\n\n\t \n\tif (!host->pdev->dev.of_node &&\n\t    (!pdata->chan_priv_tx || !pdata->chan_priv_rx))\n\t\treturn;\n\n\tif (!host->chan_tx && !host->chan_rx) {\n\t\tstruct resource *res = platform_get_resource(host->pdev,\n\t\t\t\t\t\t\t     IORESOURCE_MEM, 0);\n\t\tstruct dma_slave_config cfg = {};\n\t\tdma_cap_mask_t mask;\n\t\tint ret;\n\n\t\tif (!res)\n\t\t\treturn;\n\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\n\t\thost->chan_tx = dma_request_slave_channel_compat(mask,\n\t\t\t\t\tpriv->dma_priv.filter, pdata->chan_priv_tx,\n\t\t\t\t\t&host->pdev->dev, \"tx\");\n\t\tdev_dbg(&host->pdev->dev, \"%s: TX: got channel %p\\n\", __func__,\n\t\t\thost->chan_tx);\n\n\t\tif (!host->chan_tx)\n\t\t\treturn;\n\n\t\tcfg.direction = DMA_MEM_TO_DEV;\n\t\tcfg.dst_addr = res->start +\n\t\t\t(CTL_SD_DATA_PORT << host->bus_shift);\n\t\tcfg.dst_addr_width = priv->dma_priv.dma_buswidth;\n\t\tif (!cfg.dst_addr_width)\n\t\t\tcfg.dst_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tcfg.src_addr = 0;\n\t\tret = dmaengine_slave_config(host->chan_tx, &cfg);\n\t\tif (ret < 0)\n\t\t\tgoto ecfgtx;\n\n\t\thost->chan_rx = dma_request_slave_channel_compat(mask,\n\t\t\t\t\tpriv->dma_priv.filter, pdata->chan_priv_rx,\n\t\t\t\t\t&host->pdev->dev, \"rx\");\n\t\tdev_dbg(&host->pdev->dev, \"%s: RX: got channel %p\\n\", __func__,\n\t\t\thost->chan_rx);\n\n\t\tif (!host->chan_rx)\n\t\t\tgoto ereqrx;\n\n\t\tcfg.direction = DMA_DEV_TO_MEM;\n\t\tcfg.src_addr = cfg.dst_addr + host->pdata->dma_rx_offset;\n\t\tcfg.src_addr_width = priv->dma_priv.dma_buswidth;\n\t\tif (!cfg.src_addr_width)\n\t\t\tcfg.src_addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;\n\t\tcfg.dst_addr = 0;\n\t\tret = dmaengine_slave_config(host->chan_rx, &cfg);\n\t\tif (ret < 0)\n\t\t\tgoto ecfgrx;\n\n\t\thost->bounce_buf = (u8 *)__get_free_page(GFP_KERNEL | GFP_DMA);\n\t\tif (!host->bounce_buf)\n\t\t\tgoto ebouncebuf;\n\n\t\tinit_completion(&priv->dma_priv.dma_dataend);\n\t\ttasklet_init(&host->dma_issue,\n\t\t\t     renesas_sdhi_sys_dmac_issue_tasklet_fn,\n\t\t\t     (unsigned long)host);\n\t}\n\n\trenesas_sdhi_sys_dmac_enable_dma(host, true);\n\n\treturn;\n\nebouncebuf:\necfgrx:\n\tdma_release_channel(host->chan_rx);\n\thost->chan_rx = NULL;\nereqrx:\necfgtx:\n\tdma_release_channel(host->chan_tx);\n\thost->chan_tx = NULL;\n}\n\nstatic void renesas_sdhi_sys_dmac_release_dma(struct tmio_mmc_host *host)\n{\n\tif (host->chan_tx) {\n\t\tstruct dma_chan *chan = host->chan_tx;\n\n\t\thost->chan_tx = NULL;\n\t\tdma_release_channel(chan);\n\t}\n\tif (host->chan_rx) {\n\t\tstruct dma_chan *chan = host->chan_rx;\n\n\t\thost->chan_rx = NULL;\n\t\tdma_release_channel(chan);\n\t}\n\tif (host->bounce_buf) {\n\t\tfree_pages((unsigned long)host->bounce_buf, 0);\n\t\thost->bounce_buf = NULL;\n\t}\n}\n\nstatic const struct tmio_mmc_dma_ops renesas_sdhi_sys_dmac_dma_ops = {\n\t.start = renesas_sdhi_sys_dmac_start_dma,\n\t.enable = renesas_sdhi_sys_dmac_enable_dma,\n\t.request = renesas_sdhi_sys_dmac_request_dma,\n\t.release = renesas_sdhi_sys_dmac_release_dma,\n\t.abort = renesas_sdhi_sys_dmac_abort_dma,\n\t.dataend = renesas_sdhi_sys_dmac_dataend_dma,\n};\n\nstatic int renesas_sdhi_sys_dmac_probe(struct platform_device *pdev)\n{\n\treturn renesas_sdhi_probe(pdev, &renesas_sdhi_sys_dmac_dma_ops,\n\t\t\t\t  of_device_get_match_data(&pdev->dev), NULL);\n}\n\nstatic const struct dev_pm_ops renesas_sdhi_sys_dmac_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(tmio_mmc_host_runtime_suspend,\n\t\t\t   tmio_mmc_host_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver renesas_sys_dmac_sdhi_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sh_mobile_sdhi\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm\t= &renesas_sdhi_sys_dmac_dev_pm_ops,\n\t\t.of_match_table = renesas_sdhi_sys_dmac_of_match,\n\t},\n\t.probe\t\t= renesas_sdhi_sys_dmac_probe,\n\t.remove_new\t= renesas_sdhi_remove,\n};\n\nmodule_platform_driver(renesas_sys_dmac_sdhi_driver);\n\nMODULE_DESCRIPTION(\"Renesas SDHI driver\");\nMODULE_AUTHOR(\"Magnus Damm\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:sh_mobile_sdhi\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}