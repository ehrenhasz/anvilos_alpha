{
  "module_name": "dw_mmc-k3.c",
  "hash_id": "884cf64c67cf69e4b78cb934298b87469a54ece5d984bc724bccc2e8da0a3019",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/dw_mmc-k3.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/bitfield.h>\n#include <linux/clk.h>\n#include <linux/mfd/syscon.h>\n#include <linux/mmc/host.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#include \"dw_mmc.h\"\n#include \"dw_mmc-pltfm.h\"\n\n \n#define AO_SCTRL_SEL18\t\tBIT(10)\n#define AO_SCTRL_CTRL3\t\t0x40C\n\n#define DWMMC_SDIO_ID 2\n\n#define SOC_SCTRL_SCPERCTRL5    (0x314)\n#define SDCARD_IO_SEL18         BIT(2)\n\n#define SDCARD_RD_THRESHOLD  (512)\n\n#define GENCLK_DIV (7)\n\n#define GPIO_CLK_ENABLE                   BIT(16)\n#define GPIO_CLK_DIV_MASK                 GENMASK(11, 8)\n#define GPIO_USE_SAMPLE_DLY_MASK          GENMASK(13, 13)\n#define UHS_REG_EXT_SAMPLE_PHASE_MASK     GENMASK(20, 16)\n#define UHS_REG_EXT_SAMPLE_DRVPHASE_MASK  GENMASK(25, 21)\n#define UHS_REG_EXT_SAMPLE_DLY_MASK       GENMASK(30, 26)\n\n#define TIMING_MODE     3\n#define TIMING_CFG_NUM 10\n\n#define NUM_PHASES (40)\n\n#define ENABLE_SHIFT_MIN_SMPL (4)\n#define ENABLE_SHIFT_MAX_SMPL (12)\n#define USE_DLY_MIN_SMPL (11)\n#define USE_DLY_MAX_SMPL (14)\n\nstruct k3_priv {\n\tint ctrl_id;\n\tu32 cur_speed;\n\tstruct regmap\t*reg;\n};\n\nstatic unsigned long dw_mci_hi6220_caps[] = {\n\tMMC_CAP_CMD23,\n\tMMC_CAP_CMD23,\n\t0\n};\n\nstruct hs_timing {\n\tu32 drv_phase;\n\tu32 smpl_dly;\n\tu32 smpl_phase_max;\n\tu32 smpl_phase_min;\n};\n\nstatic struct hs_timing hs_timing_cfg[TIMING_MODE][TIMING_CFG_NUM] = {\n\t{   },\n\t{  \n\t\t{7, 0, 15, 15,},   \n\t\t{6, 0,  4,  4,},   \n\t\t{6, 0,  3,  3,},   \n\t\t{6, 0, 15, 15,},   \n\t\t{6, 0,  2,  2,},   \n\t\t{4, 0, 11,  0,},   \n\t\t{6, 4, 15,  0,},   \n\t\t{0},               \n\t\t{0},               \n\t\t{0},               \n\t},\n\t{  \n\t\t{7, 0, 15, 15,},   \n\t\t{0},               \n\t\t{6, 0, 15, 15,},   \n\t\t{6, 0, 15, 15,},   \n\t\t{6, 0,  0,  0,},   \n\t\t{4, 0, 12,  0,},   \n\t\t{5, 4, 15,  0,},   \n\t\t{0},               \n\t\t{0},               \n\t\t{0},               \n\t}\n};\n\nstatic void dw_mci_k3_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tint ret;\n\n\tret = clk_set_rate(host->ciu_clk, ios->clock);\n\tif (ret)\n\t\tdev_warn(host->dev, \"failed to set rate %uHz\\n\", ios->clock);\n\n\thost->bus_hz = clk_get_rate(host->ciu_clk);\n}\n\nstatic const struct dw_mci_drv_data k3_drv_data = {\n\t.set_ios\t\t= dw_mci_k3_set_ios,\n};\n\nstatic int dw_mci_hi6220_parse_dt(struct dw_mci *host)\n{\n\tstruct k3_priv *priv;\n\n\tpriv = devm_kzalloc(host->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->reg = syscon_regmap_lookup_by_phandle(host->dev->of_node,\n\t\t\t\t\t \"hisilicon,peripheral-syscon\");\n\tif (IS_ERR(priv->reg))\n\t\tpriv->reg = NULL;\n\n\tpriv->ctrl_id = of_alias_get_id(host->dev->of_node, \"mshc\");\n\tif (priv->ctrl_id < 0)\n\t\tpriv->ctrl_id = 0;\n\n\tif (priv->ctrl_id >= TIMING_MODE)\n\t\treturn -EINVAL;\n\n\thost->priv = priv;\n\treturn 0;\n}\n\nstatic int dw_mci_hi6220_switch_voltage(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct k3_priv *priv;\n\tstruct dw_mci *host;\n\tint min_uv, max_uv;\n\tint ret;\n\n\thost = slot->host;\n\tpriv = host->priv;\n\n\tif (!priv || !priv->reg)\n\t\treturn 0;\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\tret = regmap_update_bits(priv->reg, AO_SCTRL_CTRL3,\n\t\t\t\t\t AO_SCTRL_SEL18, 0);\n\t\tmin_uv = 3000000;\n\t\tmax_uv = 3000000;\n\t} else if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180) {\n\t\tret = regmap_update_bits(priv->reg, AO_SCTRL_CTRL3,\n\t\t\t\t\t AO_SCTRL_SEL18, AO_SCTRL_SEL18);\n\t\tmin_uv = 1800000;\n\t\tmax_uv = 1800000;\n\t} else {\n\t\tdev_dbg(host->dev, \"voltage not supported\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (ret) {\n\t\tdev_dbg(host->dev, \"switch voltage failed\\n\");\n\t\treturn ret;\n\t}\n\n\tif (IS_ERR_OR_NULL(mmc->supply.vqmmc))\n\t\treturn 0;\n\n\tret = regulator_set_voltage(mmc->supply.vqmmc, min_uv, max_uv);\n\tif (ret) {\n\t\tdev_dbg(host->dev, \"Regulator set error %d: %d - %d\\n\",\n\t\t\t\t ret, min_uv, max_uv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_mci_hi6220_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tint ret;\n\tunsigned int clock;\n\n\tclock = (ios->clock <= 25000000) ? 25000000 : ios->clock;\n\n\tret = clk_set_rate(host->biu_clk, clock);\n\tif (ret)\n\t\tdev_warn(host->dev, \"failed to set rate %uHz\\n\", clock);\n\n\thost->bus_hz = clk_get_rate(host->biu_clk);\n}\n\nstatic int dw_mci_hi6220_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\n{\n\treturn 0;\n}\n\nstatic const struct dw_mci_drv_data hi6220_data = {\n\t.caps\t\t\t= dw_mci_hi6220_caps,\n\t.num_caps\t\t= ARRAY_SIZE(dw_mci_hi6220_caps),\n\t.switch_voltage\t\t= dw_mci_hi6220_switch_voltage,\n\t.set_ios\t\t= dw_mci_hi6220_set_ios,\n\t.parse_dt\t\t= dw_mci_hi6220_parse_dt,\n\t.execute_tuning\t\t= dw_mci_hi6220_execute_tuning,\n};\n\nstatic void dw_mci_hs_set_timing(struct dw_mci *host, int timing,\n\t\t\t\t     int smpl_phase)\n{\n\tu32 drv_phase;\n\tu32 smpl_dly;\n\tu32 use_smpl_dly = 0;\n\tu32 enable_shift = 0;\n\tu32 reg_value;\n\tint ctrl_id;\n\tstruct k3_priv *priv;\n\n\tpriv = host->priv;\n\tctrl_id = priv->ctrl_id;\n\n\tdrv_phase = hs_timing_cfg[ctrl_id][timing].drv_phase;\n\tsmpl_dly   = hs_timing_cfg[ctrl_id][timing].smpl_dly;\n\tif (smpl_phase == -1)\n\t\tsmpl_phase = (hs_timing_cfg[ctrl_id][timing].smpl_phase_max +\n\t\t\t     hs_timing_cfg[ctrl_id][timing].smpl_phase_min) / 2;\n\n\tswitch (timing) {\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tif (smpl_phase >= USE_DLY_MIN_SMPL &&\n\t\t\t\tsmpl_phase <= USE_DLY_MAX_SMPL)\n\t\t\tuse_smpl_dly = 1;\n\t\tfallthrough;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tif (smpl_phase >= ENABLE_SHIFT_MIN_SMPL &&\n\t\t\t\tsmpl_phase <= ENABLE_SHIFT_MAX_SMPL)\n\t\t\tenable_shift = 1;\n\t\tbreak;\n\t}\n\n\tmci_writel(host, GPIO, 0x0);\n\tusleep_range(5, 10);\n\n\treg_value = FIELD_PREP(UHS_REG_EXT_SAMPLE_PHASE_MASK, smpl_phase) |\n\t\t    FIELD_PREP(UHS_REG_EXT_SAMPLE_DLY_MASK, smpl_dly) |\n\t\t    FIELD_PREP(UHS_REG_EXT_SAMPLE_DRVPHASE_MASK, drv_phase);\n\tmci_writel(host, UHS_REG_EXT, reg_value);\n\n\tmci_writel(host, ENABLE_SHIFT, enable_shift);\n\n\treg_value = FIELD_PREP(GPIO_CLK_DIV_MASK, GENCLK_DIV) |\n\t\t\t     FIELD_PREP(GPIO_USE_SAMPLE_DLY_MASK, use_smpl_dly);\n\tmci_writel(host, GPIO, (unsigned int)reg_value | GPIO_CLK_ENABLE);\n\n\t \n\tusleep_range(1000, 2000);\n}\n\nstatic int dw_mci_hi3660_init(struct dw_mci *host)\n{\n\tmci_writel(host, CDTHRCTL, SDMMC_SET_THLD(SDCARD_RD_THRESHOLD,\n\t\t    SDMMC_CARD_RD_THR_EN));\n\n\tdw_mci_hs_set_timing(host, MMC_TIMING_LEGACY, -1);\n\thost->bus_hz /= (GENCLK_DIV + 1);\n\n\treturn 0;\n}\n\nstatic int dw_mci_set_sel18(struct dw_mci *host, bool set)\n{\n\tint ret;\n\tunsigned int val;\n\tstruct k3_priv *priv;\n\n\tpriv = host->priv;\n\n\tval = set ? SDCARD_IO_SEL18 : 0;\n\tret = regmap_update_bits(priv->reg, SOC_SCTRL_SCPERCTRL5,\n\t\t\t\t SDCARD_IO_SEL18, val);\n\tif (ret) {\n\t\tdev_err(host->dev, \"sel18 %u error\\n\", val);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void dw_mci_hi3660_set_ios(struct dw_mci *host, struct mmc_ios *ios)\n{\n\tint ret;\n\tunsigned long wanted;\n\tunsigned long actual;\n\tstruct k3_priv *priv = host->priv;\n\n\tif (!ios->clock || ios->clock == priv->cur_speed)\n\t\treturn;\n\n\twanted = ios->clock * (GENCLK_DIV + 1);\n\tret = clk_set_rate(host->ciu_clk, wanted);\n\tif (ret) {\n\t\tdev_err(host->dev, \"failed to set rate %luHz\\n\", wanted);\n\t\treturn;\n\t}\n\tactual = clk_get_rate(host->ciu_clk);\n\n\tdw_mci_hs_set_timing(host, ios->timing, -1);\n\thost->bus_hz = actual / (GENCLK_DIV + 1);\n\thost->current_speed = 0;\n\tpriv->cur_speed = host->bus_hz;\n}\n\nstatic int dw_mci_get_best_clksmpl(unsigned int sample_flag)\n{\n\tint i;\n\tint interval;\n\tunsigned int v;\n\tunsigned int len;\n\tunsigned int range_start = 0;\n\tunsigned int range_length = 0;\n\tunsigned int middle_range = 0;\n\n\tif (!sample_flag)\n\t\treturn -EIO;\n\n\tif (~sample_flag == 0)\n\t\treturn 0;\n\n\ti = ffs(sample_flag) - 1;\n\n\t \n\twhile (i < 32) {\n\t\tv = ror32(sample_flag, i);\n\t\tlen = ffs(~v) - 1;\n\n\t\tif (len > range_length) {\n\t\t\trange_length = len;\n\t\t\trange_start = i;\n\t\t}\n\n\t\tinterval = ffs(v >> len) - 1;\n\t\tif (interval < 0)\n\t\t\tbreak;\n\n\t\ti += len + interval;\n\t}\n\n\tmiddle_range = range_start + range_length / 2;\n\tif (middle_range >= 32)\n\t\tmiddle_range %= 32;\n\n\treturn middle_range;\n}\n\nstatic int dw_mci_hi3660_execute_tuning(struct dw_mci_slot *slot, u32 opcode)\n{\n\tint i = 0;\n\tstruct dw_mci *host = slot->host;\n\tstruct mmc_host *mmc = slot->mmc;\n\tint smpl_phase = 0;\n\tu32 tuning_sample_flag = 0;\n\tint best_clksmpl = 0;\n\n\tfor (i = 0; i < NUM_PHASES; ++i, ++smpl_phase) {\n\t\tsmpl_phase %= 32;\n\n\t\tmci_writel(host, TMOUT, ~0);\n\t\tdw_mci_hs_set_timing(host, mmc->ios.timing, smpl_phase);\n\n\t\tif (!mmc_send_tuning(mmc, opcode, NULL))\n\t\t\ttuning_sample_flag |= (1 << smpl_phase);\n\t\telse\n\t\t\ttuning_sample_flag &= ~(1 << smpl_phase);\n\t}\n\n\tbest_clksmpl = dw_mci_get_best_clksmpl(tuning_sample_flag);\n\tif (best_clksmpl < 0) {\n\t\tdev_err(host->dev, \"All phases bad!\\n\");\n\t\treturn -EIO;\n\t}\n\n\tdw_mci_hs_set_timing(host, mmc->ios.timing, best_clksmpl);\n\n\tdev_info(host->dev, \"tuning ok best_clksmpl %u tuning_sample_flag %x\\n\",\n\t\t best_clksmpl, tuning_sample_flag);\n\treturn 0;\n}\n\nstatic int dw_mci_hi3660_switch_voltage(struct mmc_host *mmc,\n\t\t\t\t\tstruct mmc_ios *ios)\n{\n\tint ret = 0;\n\tstruct dw_mci_slot *slot = mmc_priv(mmc);\n\tstruct k3_priv *priv;\n\tstruct dw_mci *host;\n\n\thost = slot->host;\n\tpriv = host->priv;\n\n\tif (!priv || !priv->reg)\n\t\treturn 0;\n\n\tif (priv->ctrl_id == DWMMC_SDIO_ID)\n\t\treturn 0;\n\n\tif (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\tret = dw_mci_set_sel18(host, 0);\n\telse if (ios->signal_voltage == MMC_SIGNAL_VOLTAGE_180)\n\t\tret = dw_mci_set_sel18(host, 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!IS_ERR(mmc->supply.vqmmc)) {\n\t\tret = mmc_regulator_set_vqmmc(mmc, ios);\n\t\tif (ret < 0) {\n\t\t\tdev_err(host->dev, \"Regulator set error %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dw_mci_drv_data hi3660_data = {\n\t.init = dw_mci_hi3660_init,\n\t.set_ios = dw_mci_hi3660_set_ios,\n\t.parse_dt = dw_mci_hi6220_parse_dt,\n\t.execute_tuning = dw_mci_hi3660_execute_tuning,\n\t.switch_voltage  = dw_mci_hi3660_switch_voltage,\n};\n\nstatic const struct of_device_id dw_mci_k3_match[] = {\n\t{ .compatible = \"hisilicon,hi3660-dw-mshc\", .data = &hi3660_data, },\n\t{ .compatible = \"hisilicon,hi4511-dw-mshc\", .data = &k3_drv_data, },\n\t{ .compatible = \"hisilicon,hi6220-dw-mshc\", .data = &hi6220_data, },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dw_mci_k3_match);\n\nstatic int dw_mci_k3_probe(struct platform_device *pdev)\n{\n\tconst struct dw_mci_drv_data *drv_data;\n\tconst struct of_device_id *match;\n\n\tmatch = of_match_node(dw_mci_k3_match, pdev->dev.of_node);\n\tdrv_data = match->data;\n\n\treturn dw_mci_pltfm_register(pdev, drv_data);\n}\n\nstatic const struct dev_pm_ops dw_mci_k3_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(dw_mci_runtime_suspend,\n\t\t\t   dw_mci_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver dw_mci_k3_pltfm_driver = {\n\t.probe\t\t= dw_mci_k3_probe,\n\t.remove_new\t= dw_mci_pltfm_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"dwmmc_k3\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= dw_mci_k3_match,\n\t\t.pm\t\t= &dw_mci_k3_dev_pm_ops,\n\t},\n};\n\nmodule_platform_driver(dw_mci_k3_pltfm_driver);\n\nMODULE_DESCRIPTION(\"K3 Specific DW-MSHC Driver Extension\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS(\"platform:dwmmc_k3\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}