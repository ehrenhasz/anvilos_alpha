{
  "module_name": "sdhci-xenon-phy.c",
  "hash_id": "1109d41232af1919deecbb820870127d6a26b36bb6863468769a98fd5cc092bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-xenon-phy.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/ktime.h>\n#include <linux/of_address.h>\n\n#include \"sdhci-pltfm.h\"\n#include \"sdhci-xenon.h\"\n\n \n#define XENON_EMMC_5_0_PHY_REG_BASE\t\t0x0160\n \n#define XENON_EMMC_PHY_REG_BASE\t\t\t0x0170\n\n#define XENON_EMMC_PHY_TIMING_ADJUST\t\tXENON_EMMC_PHY_REG_BASE\n#define XENON_EMMC_5_0_PHY_TIMING_ADJUST\tXENON_EMMC_5_0_PHY_REG_BASE\n#define XENON_TIMING_ADJUST_SLOW_MODE\t\tBIT(29)\n#define XENON_TIMING_ADJUST_SDIO_MODE\t\tBIT(28)\n#define XENON_SAMPL_INV_QSP_PHASE_SELECT\tBIT(18)\n#define XENON_SAMPL_INV_QSP_PHASE_SELECT_SHIFT\t18\n#define XENON_PHY_INITIALIZAION\t\t\tBIT(31)\n#define XENON_WAIT_CYCLE_BEFORE_USING_MASK\t0xF\n#define XENON_WAIT_CYCLE_BEFORE_USING_SHIFT\t12\n#define XENON_FC_SYNC_EN_DURATION_MASK\t\t0xF\n#define XENON_FC_SYNC_EN_DURATION_SHIFT\t\t8\n#define XENON_FC_SYNC_RST_EN_DURATION_MASK\t0xF\n#define XENON_FC_SYNC_RST_EN_DURATION_SHIFT\t4\n#define XENON_FC_SYNC_RST_DURATION_MASK\t\t0xF\n#define XENON_FC_SYNC_RST_DURATION_SHIFT\t0\n\n#define XENON_EMMC_PHY_FUNC_CONTROL\t\t(XENON_EMMC_PHY_REG_BASE + 0x4)\n#define XENON_EMMC_5_0_PHY_FUNC_CONTROL\t\t\\\n\t(XENON_EMMC_5_0_PHY_REG_BASE + 0x4)\n#define XENON_ASYNC_DDRMODE_MASK\t\tBIT(23)\n#define XENON_ASYNC_DDRMODE_SHIFT\t\t23\n#define XENON_CMD_DDR_MODE\t\t\tBIT(16)\n#define XENON_DQ_DDR_MODE_SHIFT\t\t\t8\n#define XENON_DQ_DDR_MODE_MASK\t\t\t0xFF\n#define XENON_DQ_ASYNC_MODE\t\t\tBIT(4)\n\n#define XENON_EMMC_PHY_PAD_CONTROL\t\t(XENON_EMMC_PHY_REG_BASE + 0x8)\n#define XENON_EMMC_5_0_PHY_PAD_CONTROL\t\t\\\n\t(XENON_EMMC_5_0_PHY_REG_BASE + 0x8)\n#define XENON_REC_EN_SHIFT\t\t\t24\n#define XENON_REC_EN_MASK\t\t\t0xF\n#define XENON_FC_DQ_RECEN\t\t\tBIT(24)\n#define XENON_FC_CMD_RECEN\t\t\tBIT(25)\n#define XENON_FC_QSP_RECEN\t\t\tBIT(26)\n#define XENON_FC_QSN_RECEN\t\t\tBIT(27)\n#define XENON_OEN_QSN\t\t\t\tBIT(28)\n#define XENON_AUTO_RECEN_CTRL\t\t\tBIT(30)\n#define XENON_FC_ALL_CMOS_RECEIVER\t\t0xF000\n\n#define XENON_EMMC5_FC_QSP_PD\t\t\tBIT(18)\n#define XENON_EMMC5_FC_QSP_PU\t\t\tBIT(22)\n#define XENON_EMMC5_FC_CMD_PD\t\t\tBIT(17)\n#define XENON_EMMC5_FC_CMD_PU\t\t\tBIT(21)\n#define XENON_EMMC5_FC_DQ_PD\t\t\tBIT(16)\n#define XENON_EMMC5_FC_DQ_PU\t\t\tBIT(20)\n\n#define XENON_EMMC_PHY_PAD_CONTROL1\t\t(XENON_EMMC_PHY_REG_BASE + 0xC)\n#define XENON_EMMC5_1_FC_QSP_PD\t\t\tBIT(9)\n#define XENON_EMMC5_1_FC_QSP_PU\t\t\tBIT(25)\n#define XENON_EMMC5_1_FC_CMD_PD\t\t\tBIT(8)\n#define XENON_EMMC5_1_FC_CMD_PU\t\t\tBIT(24)\n#define XENON_EMMC5_1_FC_DQ_PD\t\t\t0xFF\n#define XENON_EMMC5_1_FC_DQ_PU\t\t\t(0xFF << 16)\n\n#define XENON_EMMC_PHY_PAD_CONTROL2\t\t(XENON_EMMC_PHY_REG_BASE + 0x10)\n#define XENON_EMMC_5_0_PHY_PAD_CONTROL2\t\t\\\n\t(XENON_EMMC_5_0_PHY_REG_BASE + 0xC)\n#define XENON_ZNR_MASK\t\t\t\t0x1F\n#define XENON_ZNR_SHIFT\t\t\t\t8\n#define XENON_ZPR_MASK\t\t\t\t0x1F\n \n#define XENON_ZNR_DEF_VALUE\t\t\t0xF\n#define XENON_ZPR_DEF_VALUE\t\t\t0xF\n\n#define XENON_EMMC_PHY_DLL_CONTROL\t\t(XENON_EMMC_PHY_REG_BASE + 0x14)\n#define XENON_EMMC_5_0_PHY_DLL_CONTROL\t\t\\\n\t(XENON_EMMC_5_0_PHY_REG_BASE + 0x10)\n#define XENON_DLL_ENABLE\t\t\tBIT(31)\n#define XENON_DLL_UPDATE_STROBE_5_0\t\tBIT(30)\n#define XENON_DLL_REFCLK_SEL\t\t\tBIT(30)\n#define XENON_DLL_UPDATE\t\t\tBIT(23)\n#define XENON_DLL_PHSEL1_SHIFT\t\t\t24\n#define XENON_DLL_PHSEL0_SHIFT\t\t\t16\n#define XENON_DLL_PHASE_MASK\t\t\t0x3F\n#define XENON_DLL_PHASE_90_DEGREE\t\t0x1F\n#define XENON_DLL_FAST_LOCK\t\t\tBIT(5)\n#define XENON_DLL_GAIN2X\t\t\tBIT(3)\n#define XENON_DLL_BYPASS_EN\t\t\tBIT(0)\n\n#define XENON_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST\t\\\n\t(XENON_EMMC_5_0_PHY_REG_BASE + 0x14)\n#define XENON_EMMC_5_0_PHY_LOGIC_TIMING_VALUE\t0x5A54\n#define XENON_EMMC_PHY_LOGIC_TIMING_ADJUST\t(XENON_EMMC_PHY_REG_BASE + 0x18)\n#define XENON_LOGIC_TIMING_VALUE\t\t0x00AA8977\n\n \nstruct xenon_emmc_phy_regs {\n\t \n\tu16 timing_adj;\n\t \n\tu16 func_ctrl;\n\t \n\tu16 pad_ctrl;\n\t \n\tu16 pad_ctrl2;\n\t \n\tu16 dll_ctrl;\n\t \n\tu16 logic_timing_adj;\n\t \n\tu32 dll_update;\n\t \n\tu32 logic_timing_val;\n};\n\nstatic const char * const phy_types[] = {\n\t\"emmc 5.0 phy\",\n\t\"emmc 5.1 phy\"\n};\n\nenum xenon_phy_type_enum {\n\tEMMC_5_0_PHY,\n\tEMMC_5_1_PHY,\n\tNR_PHY_TYPES\n};\n\nenum soc_pad_ctrl_type {\n\tSOC_PAD_SD,\n\tSOC_PAD_FIXED_1_8V,\n};\n\nstruct soc_pad_ctrl {\n\t \n\tvoid __iomem\t*reg;\n\t \n\tenum soc_pad_ctrl_type pad_type;\n\t \n\tvoid (*set_soc_pad)(struct sdhci_host *host,\n\t\t\t    unsigned char signal_voltage);\n};\n\nstatic struct xenon_emmc_phy_regs xenon_emmc_5_0_phy_regs = {\n\t.timing_adj\t= XENON_EMMC_5_0_PHY_TIMING_ADJUST,\n\t.func_ctrl\t= XENON_EMMC_5_0_PHY_FUNC_CONTROL,\n\t.pad_ctrl\t= XENON_EMMC_5_0_PHY_PAD_CONTROL,\n\t.pad_ctrl2\t= XENON_EMMC_5_0_PHY_PAD_CONTROL2,\n\t.dll_ctrl\t= XENON_EMMC_5_0_PHY_DLL_CONTROL,\n\t.logic_timing_adj = XENON_EMMC_5_0_PHY_LOGIC_TIMING_ADJUST,\n\t.dll_update\t= XENON_DLL_UPDATE_STROBE_5_0,\n\t.logic_timing_val = XENON_EMMC_5_0_PHY_LOGIC_TIMING_VALUE,\n};\n\nstatic struct xenon_emmc_phy_regs xenon_emmc_5_1_phy_regs = {\n\t.timing_adj\t= XENON_EMMC_PHY_TIMING_ADJUST,\n\t.func_ctrl\t= XENON_EMMC_PHY_FUNC_CONTROL,\n\t.pad_ctrl\t= XENON_EMMC_PHY_PAD_CONTROL,\n\t.pad_ctrl2\t= XENON_EMMC_PHY_PAD_CONTROL2,\n\t.dll_ctrl\t= XENON_EMMC_PHY_DLL_CONTROL,\n\t.logic_timing_adj = XENON_EMMC_PHY_LOGIC_TIMING_ADJUST,\n\t.dll_update\t= XENON_DLL_UPDATE,\n\t.logic_timing_val = XENON_LOGIC_TIMING_VALUE,\n};\n\n \nstruct xenon_emmc_phy_params {\n\tbool\tslow_mode;\n\n\tu8\tznr;\n\tu8\tzpr;\n\n\t \n\tu8\tnr_tun_times;\n\t \n\tu8\ttun_step_divider;\n\n\tstruct soc_pad_ctrl pad_ctrl;\n};\n\nstatic int xenon_alloc_emmc_phy(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params;\n\n\tparams = devm_kzalloc(mmc_dev(host->mmc), sizeof(*params), GFP_KERNEL);\n\tif (!params)\n\t\treturn -ENOMEM;\n\n\tpriv->phy_params = params;\n\tif (priv->phy_type == EMMC_5_0_PHY)\n\t\tpriv->emmc_phy_regs = &xenon_emmc_5_0_phy_regs;\n\telse\n\t\tpriv->emmc_phy_regs = &xenon_emmc_5_1_phy_regs;\n\n\treturn 0;\n}\n\n \nstatic int xenon_emmc_phy_init(struct sdhci_host *host)\n{\n\tu32 reg;\n\tu32 wait, clock;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;\n\n\treg = sdhci_readl(host, phy_regs->timing_adj);\n\treg |= XENON_PHY_INITIALIZAION;\n\tsdhci_writel(host, reg, phy_regs->timing_adj);\n\n\t \n\twait = ((reg >> XENON_FC_SYNC_RST_DURATION_SHIFT) &\n\t\t\tXENON_FC_SYNC_RST_DURATION_MASK);\n\t \n\twait += ((reg >> XENON_FC_SYNC_RST_EN_DURATION_SHIFT) &\n\t\t\tXENON_FC_SYNC_RST_EN_DURATION_MASK);\n\t \n\twait += ((reg >> XENON_FC_SYNC_EN_DURATION_SHIFT) &\n\t\t\tXENON_FC_SYNC_EN_DURATION_MASK);\n\t \n\twait += ((reg >> XENON_WAIT_CYCLE_BEFORE_USING_SHIFT) &\n\t\t\tXENON_WAIT_CYCLE_BEFORE_USING_MASK);\n\t \n\twait += 8;\n\twait <<= 20;\n\n\tclock = host->clock;\n\tif (!clock)\n\t\t \n\t\tclock = XENON_LOWEST_SDCLK_FREQ;\n\t \n\twait /= clock;\n\twait++;\n\t \n\tudelay(wait);\n\n\treg = sdhci_readl(host, phy_regs->timing_adj);\n\treg &= XENON_PHY_INITIALIZAION;\n\tif (reg) {\n\t\tdev_err(mmc_dev(host->mmc), \"eMMC PHY init cannot complete after %d us\\n\",\n\t\t\twait);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n#define ARMADA_3700_SOC_PAD_1_8V\t0x1\n#define ARMADA_3700_SOC_PAD_3_3V\t0x0\n\nstatic void armada_3700_soc_pad_voltage_set(struct sdhci_host *host,\n\t\t\t\t\t    unsigned char signal_voltage)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params = priv->phy_params;\n\n\tif (params->pad_ctrl.pad_type == SOC_PAD_FIXED_1_8V) {\n\t\twritel(ARMADA_3700_SOC_PAD_1_8V, params->pad_ctrl.reg);\n\t} else if (params->pad_ctrl.pad_type == SOC_PAD_SD) {\n\t\tif (signal_voltage == MMC_SIGNAL_VOLTAGE_180)\n\t\t\twritel(ARMADA_3700_SOC_PAD_1_8V, params->pad_ctrl.reg);\n\t\telse if (signal_voltage == MMC_SIGNAL_VOLTAGE_330)\n\t\t\twritel(ARMADA_3700_SOC_PAD_3_3V, params->pad_ctrl.reg);\n\t}\n}\n\n \nstatic void xenon_emmc_phy_set_soc_pad(struct sdhci_host *host,\n\t\t\t\t       unsigned char signal_voltage)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params = priv->phy_params;\n\n\tif (!params->pad_ctrl.reg)\n\t\treturn;\n\n\tif (params->pad_ctrl.set_soc_pad)\n\t\tparams->pad_ctrl.set_soc_pad(host, signal_voltage);\n}\n\n \nstatic int xenon_emmc_phy_enable_dll(struct sdhci_host *host)\n{\n\tu32 reg;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;\n\tktime_t timeout;\n\n\tif (WARN_ON(host->clock <= MMC_HIGH_52_MAX_DTR))\n\t\treturn -EINVAL;\n\n\treg = sdhci_readl(host, phy_regs->dll_ctrl);\n\tif (reg & XENON_DLL_ENABLE)\n\t\treturn 0;\n\n\t \n\treg = sdhci_readl(host, phy_regs->dll_ctrl);\n\treg |= (XENON_DLL_ENABLE | XENON_DLL_FAST_LOCK);\n\n\t \n\treg &= ~((XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL0_SHIFT) |\n\t\t (XENON_DLL_PHASE_MASK << XENON_DLL_PHSEL1_SHIFT));\n\treg |= ((XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL0_SHIFT) |\n\t\t(XENON_DLL_PHASE_90_DEGREE << XENON_DLL_PHSEL1_SHIFT));\n\n\treg &= ~XENON_DLL_BYPASS_EN;\n\treg |= phy_regs->dll_update;\n\tif (priv->phy_type == EMMC_5_1_PHY)\n\t\treg &= ~XENON_DLL_REFCLK_SEL;\n\tsdhci_writel(host, reg, phy_regs->dll_ctrl);\n\n\t \n\ttimeout = ktime_add_ms(ktime_get(), 32);\n\twhile (1) {\n\t\tbool timedout = ktime_after(ktime_get(), timeout);\n\n\t\tif (sdhci_readw(host, XENON_SLOT_EXT_PRESENT_STATE) &\n\t\t    XENON_DLL_LOCK_STATE)\n\t\t\tbreak;\n\t\tif (timedout) {\n\t\t\tdev_err(mmc_dev(host->mmc), \"Wait for DLL Lock time-out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tudelay(100);\n\t}\n\treturn 0;\n}\n\n \nstatic int xenon_emmc_phy_config_tuning(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params = priv->phy_params;\n\tu32 reg, tuning_step;\n\tint ret;\n\n\tif (host->clock <= MMC_HIGH_52_MAX_DTR)\n\t\treturn -EINVAL;\n\n\tret = xenon_emmc_phy_enable_dll(host);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treg = sdhci_readl(host, XENON_SLOT_DLL_CUR_DLY_VAL);\n\ttuning_step = reg / params->tun_step_divider;\n\tif (unlikely(tuning_step > XENON_TUNING_STEP_MASK)) {\n\t\tdev_warn(mmc_dev(host->mmc),\n\t\t\t \"HS200 TUNING_STEP %d is larger than MAX value\\n\",\n\t\t\t tuning_step);\n\t\ttuning_step = XENON_TUNING_STEP_MASK;\n\t}\n\n\t \n\treg = sdhci_readl(host, XENON_SLOT_OP_STATUS_CTRL);\n\treg &= ~(XENON_TUN_CONSECUTIVE_TIMES_MASK <<\n\t\t XENON_TUN_CONSECUTIVE_TIMES_SHIFT);\n\treg |= (params->nr_tun_times << XENON_TUN_CONSECUTIVE_TIMES_SHIFT);\n\treg &= ~(XENON_TUNING_STEP_MASK << XENON_TUNING_STEP_SHIFT);\n\treg |= (tuning_step << XENON_TUNING_STEP_SHIFT);\n\tsdhci_writel(host, reg, XENON_SLOT_OP_STATUS_CTRL);\n\n\treturn 0;\n}\n\nstatic void xenon_emmc_phy_disable_strobe(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\t \n\treg = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);\n\treg &= ~(XENON_ENABLE_DATA_STROBE | XENON_ENABLE_RESP_STROBE);\n\tsdhci_writel(host, reg, XENON_SLOT_EMMC_CTRL);\n\n\t \n\tif (priv->phy_type == EMMC_5_0_PHY) {\n\t\treg = sdhci_readl(host, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t\treg &= ~(XENON_EMMC5_FC_QSP_PD | XENON_EMMC5_FC_QSP_PU);\n\t\tsdhci_writel(host, reg, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t} else {\n\t\treg = sdhci_readl(host, XENON_EMMC_PHY_PAD_CONTROL1);\n\t\treg &= ~(XENON_EMMC5_1_FC_QSP_PD | XENON_EMMC5_1_FC_QSP_PU);\n\t\tsdhci_writel(host, reg, XENON_EMMC_PHY_PAD_CONTROL1);\n\t}\n}\n\n \nstatic void xenon_emmc_phy_strobe_delay_adj(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tu32 reg;\n\n\tif (WARN_ON(host->timing != MMC_TIMING_MMC_HS400))\n\t\treturn;\n\n\tif (host->clock <= MMC_HIGH_52_MAX_DTR)\n\t\treturn;\n\n\tdev_dbg(mmc_dev(host->mmc), \"starts HS400 strobe delay adjustment\\n\");\n\n\txenon_emmc_phy_enable_dll(host);\n\n\t \n\treg = sdhci_readl(host, XENON_SLOT_EMMC_CTRL);\n\treg |= XENON_ENABLE_DATA_STROBE;\n\t \n\tif (host->mmc->ios.enhanced_strobe)\n\t\treg |= XENON_ENABLE_RESP_STROBE;\n\tsdhci_writel(host, reg, XENON_SLOT_EMMC_CTRL);\n\n\t \n\tif (priv->phy_type == EMMC_5_0_PHY) {\n\t\treg = sdhci_readl(host, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t\treg |= XENON_EMMC5_FC_QSP_PD;\n\t\treg &= ~XENON_EMMC5_FC_QSP_PU;\n\t\tsdhci_writel(host, reg, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t} else {\n\t\treg = sdhci_readl(host, XENON_EMMC_PHY_PAD_CONTROL1);\n\t\treg |= XENON_EMMC5_1_FC_QSP_PD;\n\t\treg &= ~XENON_EMMC5_1_FC_QSP_PU;\n\t\tsdhci_writel(host, reg, XENON_EMMC_PHY_PAD_CONTROL1);\n\t}\n}\n\n \nstatic bool xenon_emmc_phy_slow_mode(struct sdhci_host *host,\n\t\t\t\t     unsigned char timing)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params = priv->phy_params;\n\tstruct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;\n\tu32 reg;\n\tint ret;\n\n\tif (host->clock > MMC_HIGH_52_MAX_DTR)\n\t\treturn false;\n\n\treg = sdhci_readl(host, phy_regs->timing_adj);\n\t \n\tswitch (timing) {\n\tcase MMC_TIMING_LEGACY:\n\t\t \n\t\tif (params->slow_mode) {\n\t\t\treg |= XENON_TIMING_ADJUST_SLOW_MODE;\n\t\t\tret = true;\n\t\t} else {\n\t\t\treg &= ~XENON_TIMING_ADJUST_SLOW_MODE;\n\t\t\tret = false;\n\t\t}\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\tcase MMC_TIMING_UHS_SDR12:\n\tcase MMC_TIMING_SD_HS:\n\tcase MMC_TIMING_MMC_HS:\n\t\tif ((priv->init_card_type == MMC_TYPE_SDIO) ||\n\t\t    params->slow_mode) {\n\t\t\treg |= XENON_TIMING_ADJUST_SLOW_MODE;\n\t\t\tret = true;\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\treg &= ~XENON_TIMING_ADJUST_SLOW_MODE;\n\t\tret = false;\n\t}\n\n\tsdhci_writel(host, reg, phy_regs->timing_adj);\n\treturn ret;\n}\n\n \nstatic void xenon_emmc_phy_set(struct sdhci_host *host,\n\t\t\t       unsigned char timing)\n{\n\tu32 reg;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tstruct xenon_emmc_phy_params *params = priv->phy_params;\n\tstruct xenon_emmc_phy_regs *phy_regs = priv->emmc_phy_regs;\n\n\tdev_dbg(mmc_dev(host->mmc), \"eMMC PHY setting starts\\n\");\n\n\t \n\treg = sdhci_readl(host, phy_regs->pad_ctrl);\n\treg |= (XENON_FC_DQ_RECEN | XENON_FC_CMD_RECEN |\n\t\tXENON_FC_QSP_RECEN | XENON_OEN_QSN);\n\t \n\treg |= XENON_FC_ALL_CMOS_RECEIVER;\n\tsdhci_writel(host, reg, phy_regs->pad_ctrl);\n\n\t \n\tif (priv->phy_type == EMMC_5_0_PHY) {\n\t\treg = sdhci_readl(host, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t\treg |= (XENON_EMMC5_FC_CMD_PU | XENON_EMMC5_FC_DQ_PU);\n\t\treg &= ~(XENON_EMMC5_FC_CMD_PD | XENON_EMMC5_FC_DQ_PD);\n\t\tsdhci_writel(host, reg, XENON_EMMC_5_0_PHY_PAD_CONTROL);\n\t} else {\n\t\treg = sdhci_readl(host, XENON_EMMC_PHY_PAD_CONTROL1);\n\t\treg |= (XENON_EMMC5_1_FC_CMD_PU | XENON_EMMC5_1_FC_DQ_PU);\n\t\treg &= ~(XENON_EMMC5_1_FC_CMD_PD | XENON_EMMC5_1_FC_DQ_PD);\n\t\tsdhci_writel(host, reg, XENON_EMMC_PHY_PAD_CONTROL1);\n\t}\n\n\tif (timing == MMC_TIMING_LEGACY) {\n\t\txenon_emmc_phy_slow_mode(host, timing);\n\t\tgoto phy_init;\n\t}\n\n\t \n\treg = sdhci_readl(host, phy_regs->timing_adj);\n\tif (priv->init_card_type == MMC_TYPE_SDIO)\n\t\treg |= XENON_TIMING_ADJUST_SDIO_MODE;\n\telse\n\t\treg &= ~XENON_TIMING_ADJUST_SDIO_MODE;\n\tsdhci_writel(host, reg, phy_regs->timing_adj);\n\n\tif (xenon_emmc_phy_slow_mode(host, timing))\n\t\tgoto phy_init;\n\n\t \n\treg = sdhci_readl(host, phy_regs->pad_ctrl2);\n\treg &= ~((XENON_ZNR_MASK << XENON_ZNR_SHIFT) | XENON_ZPR_MASK);\n\treg |= ((params->znr << XENON_ZNR_SHIFT) | params->zpr);\n\tsdhci_writel(host, reg, phy_regs->pad_ctrl2);\n\n\t \n\treg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);\n\treg &= ~SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);\n\n\treg = sdhci_readl(host, phy_regs->func_ctrl);\n\tswitch (timing) {\n\tcase MMC_TIMING_MMC_HS400:\n\t\treg |= (XENON_DQ_DDR_MODE_MASK << XENON_DQ_DDR_MODE_SHIFT) |\n\t\t       XENON_CMD_DDR_MODE;\n\t\treg &= ~XENON_DQ_ASYNC_MODE;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\tcase MMC_TIMING_MMC_DDR52:\n\t\treg |= (XENON_DQ_DDR_MODE_MASK << XENON_DQ_DDR_MODE_SHIFT) |\n\t\t       XENON_CMD_DDR_MODE | XENON_DQ_ASYNC_MODE;\n\t\tbreak;\n\tdefault:\n\t\treg &= ~((XENON_DQ_DDR_MODE_MASK << XENON_DQ_DDR_MODE_SHIFT) |\n\t\t\t XENON_CMD_DDR_MODE);\n\t\treg |= XENON_DQ_ASYNC_MODE;\n\t}\n\tsdhci_writel(host, reg, phy_regs->func_ctrl);\n\n\t \n\treg = sdhci_readl(host, SDHCI_CLOCK_CONTROL);\n\treg |= SDHCI_CLOCK_CARD_EN;\n\tsdhci_writew(host, reg, SDHCI_CLOCK_CONTROL);\n\n\tif (timing == MMC_TIMING_MMC_HS400)\n\t\t \n\t\tsdhci_writel(host, phy_regs->logic_timing_val,\n\t\t\t     phy_regs->logic_timing_adj);\n\telse\n\t\txenon_emmc_phy_disable_strobe(host);\n\nphy_init:\n\txenon_emmc_phy_init(host);\n\n\tdev_dbg(mmc_dev(host->mmc), \"eMMC PHY setting completes\\n\");\n}\n\nstatic int get_dt_pad_ctrl_data(struct sdhci_host *host,\n\t\t\t\tstruct device_node *np,\n\t\t\t\tstruct xenon_emmc_phy_params *params)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret = 0;\n\tconst char *name;\n\tstruct resource iomem;\n\n\tif (priv->hw_version == XENON_A3700)\n\t\tparams->pad_ctrl.set_soc_pad = armada_3700_soc_pad_voltage_set;\n\telse\n\t\treturn 0;\n\n\tif (of_address_to_resource(np, 1, &iomem)) {\n\t\tdev_err(mmc_dev(host->mmc), \"Unable to find SoC PAD ctrl register address for %pOFn\\n\",\n\t\t\tnp);\n\t\treturn -EINVAL;\n\t}\n\n\tparams->pad_ctrl.reg = devm_ioremap_resource(mmc_dev(host->mmc),\n\t\t\t\t\t\t     &iomem);\n\tif (IS_ERR(params->pad_ctrl.reg))\n\t\treturn PTR_ERR(params->pad_ctrl.reg);\n\n\tret = of_property_read_string(np, \"marvell,pad-type\", &name);\n\tif (ret) {\n\t\tdev_err(mmc_dev(host->mmc), \"Unable to determine SoC PHY PAD ctrl type\\n\");\n\t\treturn ret;\n\t}\n\tif (!strcmp(name, \"sd\")) {\n\t\tparams->pad_ctrl.pad_type = SOC_PAD_SD;\n\t} else if (!strcmp(name, \"fixed-1-8v\")) {\n\t\tparams->pad_ctrl.pad_type = SOC_PAD_FIXED_1_8V;\n\t} else {\n\t\tdev_err(mmc_dev(host->mmc), \"Unsupported SoC PHY PAD ctrl type %s\\n\",\n\t\t\tname);\n\t\treturn -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int xenon_emmc_phy_parse_params(struct sdhci_host *host,\n\t\t\t\t       struct device *dev,\n\t\t\t\t       struct xenon_emmc_phy_params *params)\n{\n\tu32 value;\n\n\tparams->slow_mode = false;\n\tif (device_property_read_bool(dev, \"marvell,xenon-phy-slow-mode\"))\n\t\tparams->slow_mode = true;\n\n\tparams->znr = XENON_ZNR_DEF_VALUE;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-phy-znr\", &value))\n\t\tparams->znr = value & XENON_ZNR_MASK;\n\n\tparams->zpr = XENON_ZPR_DEF_VALUE;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-phy-zpr\", &value))\n\t\tparams->zpr = value & XENON_ZPR_MASK;\n\n\tparams->nr_tun_times = XENON_TUN_CONSECUTIVE_TIMES;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-phy-nr-success-tun\",\n\t\t\t\t      &value))\n\t\tparams->nr_tun_times = value & XENON_TUN_CONSECUTIVE_TIMES_MASK;\n\n\tparams->tun_step_divider = XENON_TUNING_STEP_DIVIDER;\n\tif (!device_property_read_u32(dev, \"marvell,xenon-phy-tun-step-divider\",\n\t\t\t\t      &value))\n\t\tparams->tun_step_divider = value & 0xFF;\n\n\tif (dev->of_node)\n\t\treturn get_dt_pad_ctrl_data(host, dev->of_node, params);\n\treturn 0;\n}\n\n \nvoid xenon_soc_pad_ctrl(struct sdhci_host *host,\n\t\t\tunsigned char signal_voltage)\n{\n\txenon_emmc_phy_set_soc_pad(host, signal_voltage);\n}\n\n \nstatic int xenon_hs_delay_adj(struct sdhci_host *host)\n{\n\tint ret = 0;\n\n\tif (WARN_ON(host->clock <= XENON_DEFAULT_SDCLK_FREQ))\n\t\treturn -EINVAL;\n\n\tswitch (host->timing) {\n\tcase MMC_TIMING_MMC_HS400:\n\t\txenon_emmc_phy_strobe_delay_adj(host);\n\t\treturn 0;\n\tcase MMC_TIMING_MMC_HS200:\n\tcase MMC_TIMING_UHS_SDR104:\n\t\treturn xenon_emmc_phy_config_tuning(host);\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\t \n\t\tdev_warn_once(mmc_dev(host->mmc), \"Timing issue might occur in DDR mode\\n\");\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\n \nint xenon_phy_adj(struct sdhci_host *host, struct mmc_ios *ios)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret = 0;\n\n\tif (!host->clock) {\n\t\tpriv->clock = 0;\n\t\treturn 0;\n\t}\n\n\t \n\tif ((host->clock == priv->clock) &&\n\t    (ios->bus_width == priv->bus_width) &&\n\t    (ios->timing == priv->timing))\n\t\treturn 0;\n\n\txenon_emmc_phy_set(host, ios->timing);\n\n\t \n\tpriv->bus_width = ios->bus_width;\n\n\tpriv->timing = ios->timing;\n\tpriv->clock = host->clock;\n\n\t \n\tif (ios->timing == MMC_TIMING_LEGACY)\n\t\treturn 0;\n\n\tif (host->clock > XENON_DEFAULT_SDCLK_FREQ)\n\t\tret = xenon_hs_delay_adj(host);\n\treturn ret;\n}\n\nstatic int xenon_add_phy(struct device *dev, struct sdhci_host *host,\n\t\t\t const char *phy_name)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct xenon_priv *priv = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tpriv->phy_type = match_string(phy_types, NR_PHY_TYPES, phy_name);\n\tif (priv->phy_type < 0) {\n\t\tdev_err(mmc_dev(host->mmc),\n\t\t\t\"Unable to determine PHY name %s. Use default eMMC 5.1 PHY\\n\",\n\t\t\tphy_name);\n\t\tpriv->phy_type = EMMC_5_1_PHY;\n\t}\n\n\tret = xenon_alloc_emmc_phy(host);\n\tif (ret)\n\t\treturn ret;\n\n\treturn xenon_emmc_phy_parse_params(host, dev, priv->phy_params);\n}\n\nint xenon_phy_parse_params(struct device *dev, struct sdhci_host *host)\n{\n\tconst char *phy_type = NULL;\n\n\tif (!device_property_read_string(dev, \"marvell,xenon-phy-type\", &phy_type))\n\t\treturn xenon_add_phy(dev, host, phy_type);\n\n\treturn xenon_add_phy(dev, host, \"emmc 5.1 phy\");\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}