{
  "module_name": "mvsdio.c",
  "hash_id": "97f50b02547273e3c7caa5b91ab5319a89776e3b6d62cc5b8f0742b81d1b2fff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/mvsdio.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/mbus.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/scatterlist.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/of_irq.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include <linux/sizes.h>\n#include <asm/unaligned.h>\n\n#include \"mvsdio.h\"\n\n#define DRIVER_NAME\t\"mvsdio\"\n\nstatic int maxfreq;\nstatic int nodma;\n\nstruct mvsd_host {\n\tvoid __iomem *base;\n\tstruct mmc_request *mrq;\n\tspinlock_t lock;\n\tunsigned int xfer_mode;\n\tunsigned int intr_en;\n\tunsigned int ctrl;\n\tunsigned int pio_size;\n\tvoid *pio_ptr;\n\tunsigned int sg_frags;\n\tunsigned int ns_per_clk;\n\tunsigned int clock;\n\tunsigned int base_clock;\n\tstruct timer_list timer;\n\tstruct mmc_host *mmc;\n\tstruct device *dev;\n\tstruct clk *clk;\n};\n\n#define mvsd_write(offs, val)\twritel(val, iobase + (offs))\n#define mvsd_read(offs)\t\treadl(iobase + (offs))\n\nstatic int mvsd_setup_data(struct mvsd_host *host, struct mmc_data *data)\n{\n\tvoid __iomem *iobase = host->base;\n\tunsigned int tmout;\n\tint tmout_index;\n\n\t \n\tif (!(mvsd_read(MVSD_HW_STATE) & (1 << 13))) {\n\t\tunsigned long t = jiffies + HZ;\n\t\tunsigned int hw_state,  count = 0;\n\t\tdo {\n\t\t\thw_state = mvsd_read(MVSD_HW_STATE);\n\t\t\tif (time_after(jiffies, t)) {\n\t\t\t\tdev_warn(host->dev, \"FIFO_EMPTY bit missing\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t} while (!(hw_state & (1 << 13)));\n\t\tdev_dbg(host->dev, \"*** wait for FIFO_EMPTY bit \"\n\t\t\t\t   \"(hw=0x%04x, count=%d, jiffies=%ld)\\n\",\n\t\t\t\t   hw_state, count, jiffies - (t - HZ));\n\t}\n\n\t \n\ttmout = DIV_ROUND_UP(data->timeout_ns, host->ns_per_clk);\n\ttmout += data->timeout_clks;\n\ttmout_index = fls(tmout - 1) - 12;\n\tif (tmout_index < 0)\n\t\ttmout_index = 0;\n\tif (tmout_index > MVSD_HOST_CTRL_TMOUT_MAX)\n\t\ttmout_index = MVSD_HOST_CTRL_TMOUT_MAX;\n\n\tdev_dbg(host->dev, \"data %s at 0x%08x: blocks=%d blksz=%d tmout=%u (%d)\\n\",\n\t\t(data->flags & MMC_DATA_READ) ? \"read\" : \"write\",\n\t\t(u32)sg_virt(data->sg), data->blocks, data->blksz,\n\t\ttmout, tmout_index);\n\n\thost->ctrl &= ~MVSD_HOST_CTRL_TMOUT_MASK;\n\thost->ctrl |= MVSD_HOST_CTRL_TMOUT(tmout_index);\n\tmvsd_write(MVSD_HOST_CTRL, host->ctrl);\n\tmvsd_write(MVSD_BLK_COUNT, data->blocks);\n\tmvsd_write(MVSD_BLK_SIZE, data->blksz);\n\n\tif (nodma || (data->blksz | data->sg->offset) & 3 ||\n\t    ((!(data->flags & MMC_DATA_READ) && data->sg->offset & 0x3f))) {\n\t\t \n\t\thost->pio_size = data->blocks * data->blksz;\n\t\thost->pio_ptr = sg_virt(data->sg);\n\t\tif (!nodma)\n\t\t\tdev_dbg(host->dev, \"fallback to PIO for data at 0x%p size %d\\n\",\n\t\t\t\thost->pio_ptr, host->pio_size);\n\t\treturn 1;\n\t} else {\n\t\tdma_addr_t phys_addr;\n\n\t\thost->sg_frags = dma_map_sg(mmc_dev(host->mmc),\n\t\t\t\t\t    data->sg, data->sg_len,\n\t\t\t\t\t    mmc_get_dma_dir(data));\n\t\tphys_addr = sg_dma_address(data->sg);\n\t\tmvsd_write(MVSD_SYS_ADDR_LOW, (u32)phys_addr & 0xffff);\n\t\tmvsd_write(MVSD_SYS_ADDR_HI,  (u32)phys_addr >> 16);\n\t\treturn 0;\n\t}\n}\n\nstatic void mvsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct mvsd_host *host = mmc_priv(mmc);\n\tvoid __iomem *iobase = host->base;\n\tstruct mmc_command *cmd = mrq->cmd;\n\tu32 cmdreg = 0, xfer = 0, intr = 0;\n\tunsigned long flags;\n\tunsigned int timeout;\n\n\tBUG_ON(host->mrq != NULL);\n\thost->mrq = mrq;\n\n\tdev_dbg(host->dev, \"cmd %d (hw state 0x%04x)\\n\",\n\t\tcmd->opcode, mvsd_read(MVSD_HW_STATE));\n\n\tcmdreg = MVSD_CMD_INDEX(cmd->opcode);\n\n\tif (cmd->flags & MMC_RSP_BUSY)\n\t\tcmdreg |= MVSD_CMD_RSP_48BUSY;\n\telse if (cmd->flags & MMC_RSP_136)\n\t\tcmdreg |= MVSD_CMD_RSP_136;\n\telse if (cmd->flags & MMC_RSP_PRESENT)\n\t\tcmdreg |= MVSD_CMD_RSP_48;\n\telse\n\t\tcmdreg |= MVSD_CMD_RSP_NONE;\n\n\tif (cmd->flags & MMC_RSP_CRC)\n\t\tcmdreg |= MVSD_CMD_CHECK_CMDCRC;\n\n\tif (cmd->flags & MMC_RSP_OPCODE)\n\t\tcmdreg |= MVSD_CMD_INDX_CHECK;\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tcmdreg |= MVSD_UNEXPECTED_RESP;\n\t\tintr |= MVSD_NOR_UNEXP_RSP;\n\t}\n\n\tif (mrq->data) {\n\t\tstruct mmc_data *data = mrq->data;\n\t\tint pio;\n\n\t\tcmdreg |= MVSD_CMD_DATA_PRESENT | MVSD_CMD_CHECK_DATACRC16;\n\t\txfer |= MVSD_XFER_MODE_HW_WR_DATA_EN;\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\txfer |= MVSD_XFER_MODE_TO_HOST;\n\n\t\tpio = mvsd_setup_data(host, data);\n\t\tif (pio) {\n\t\t\txfer |= MVSD_XFER_MODE_PIO;\n\t\t\t \n\t\t\tif (data->flags & MMC_DATA_WRITE)\n\t\t\t\tintr |= MVSD_NOR_TX_AVAIL;\n\t\t\telse if (host->pio_size > 32)\n\t\t\t\tintr |= MVSD_NOR_RX_FIFO_8W;\n\t\t\telse\n\t\t\t\tintr |= MVSD_NOR_RX_READY;\n\t\t}\n\n\t\tif (data->stop) {\n\t\t\tstruct mmc_command *stop = data->stop;\n\t\t\tu32 cmd12reg = 0;\n\n\t\t\tmvsd_write(MVSD_AUTOCMD12_ARG_LOW, stop->arg & 0xffff);\n\t\t\tmvsd_write(MVSD_AUTOCMD12_ARG_HI,  stop->arg >> 16);\n\n\t\t\tif (stop->flags & MMC_RSP_BUSY)\n\t\t\t\tcmd12reg |= MVSD_AUTOCMD12_BUSY;\n\t\t\tif (stop->flags & MMC_RSP_OPCODE)\n\t\t\t\tcmd12reg |= MVSD_AUTOCMD12_INDX_CHECK;\n\t\t\tcmd12reg |= MVSD_AUTOCMD12_INDEX(stop->opcode);\n\t\t\tmvsd_write(MVSD_AUTOCMD12_CMD, cmd12reg);\n\n\t\t\txfer |= MVSD_XFER_MODE_AUTO_CMD12;\n\t\t\tintr |= MVSD_NOR_AUTOCMD12_DONE;\n\t\t} else {\n\t\t\tintr |= MVSD_NOR_XFER_DONE;\n\t\t}\n\t} else {\n\t\tintr |= MVSD_NOR_CMD_DONE;\n\t}\n\n\tmvsd_write(MVSD_ARG_LOW, cmd->arg & 0xffff);\n\tmvsd_write(MVSD_ARG_HI,  cmd->arg >> 16);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\thost->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;\n\thost->xfer_mode |= xfer;\n\tmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\n\n\tmvsd_write(MVSD_NOR_INTR_STATUS, ~MVSD_NOR_CARD_INT);\n\tmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\n\tmvsd_write(MVSD_CMD, cmdreg);\n\n\thost->intr_en &= MVSD_NOR_CARD_INT;\n\thost->intr_en |= intr | MVSD_NOR_ERROR;\n\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\tmvsd_write(MVSD_ERR_INTR_EN, 0xffff);\n\n\ttimeout = cmd->busy_timeout ? cmd->busy_timeout : 5000;\n\tmod_timer(&host->timer, jiffies + msecs_to_jiffies(timeout));\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic u32 mvsd_finish_cmd(struct mvsd_host *host, struct mmc_command *cmd,\n\t\t\t   u32 err_status)\n{\n\tvoid __iomem *iobase = host->base;\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tunsigned int response[8], i;\n\t\tfor (i = 0; i < 8; i++)\n\t\t\tresponse[i] = mvsd_read(MVSD_RSP(i));\n\t\tcmd->resp[0] =\t\t((response[0] & 0x03ff) << 22) |\n\t\t\t\t\t((response[1] & 0xffff) << 6) |\n\t\t\t\t\t((response[2] & 0xfc00) >> 10);\n\t\tcmd->resp[1] =\t\t((response[2] & 0x03ff) << 22) |\n\t\t\t\t\t((response[3] & 0xffff) << 6) |\n\t\t\t\t\t((response[4] & 0xfc00) >> 10);\n\t\tcmd->resp[2] =\t\t((response[4] & 0x03ff) << 22) |\n\t\t\t\t\t((response[5] & 0xffff) << 6) |\n\t\t\t\t\t((response[6] & 0xfc00) >> 10);\n\t\tcmd->resp[3] =\t\t((response[6] & 0x03ff) << 22) |\n\t\t\t\t\t((response[7] & 0x3fff) << 8);\n\t} else if (cmd->flags & MMC_RSP_PRESENT) {\n\t\tunsigned int response[3], i;\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tresponse[i] = mvsd_read(MVSD_RSP(i));\n\t\tcmd->resp[0] =\t\t((response[2] & 0x003f) << (8 - 8)) |\n\t\t\t\t\t((response[1] & 0xffff) << (14 - 8)) |\n\t\t\t\t\t((response[0] & 0x03ff) << (30 - 8));\n\t\tcmd->resp[1] =\t\t((response[0] & 0xfc00) >> 10);\n\t\tcmd->resp[2] = 0;\n\t\tcmd->resp[3] = 0;\n\t}\n\n\tif (err_status & MVSD_ERR_CMD_TIMEOUT) {\n\t\tcmd->error = -ETIMEDOUT;\n\t} else if (err_status & (MVSD_ERR_CMD_CRC | MVSD_ERR_CMD_ENDBIT |\n\t\t\t\t MVSD_ERR_CMD_INDEX | MVSD_ERR_CMD_STARTBIT)) {\n\t\tcmd->error = -EILSEQ;\n\t}\n\terr_status &= ~(MVSD_ERR_CMD_TIMEOUT | MVSD_ERR_CMD_CRC |\n\t\t\tMVSD_ERR_CMD_ENDBIT | MVSD_ERR_CMD_INDEX |\n\t\t\tMVSD_ERR_CMD_STARTBIT);\n\n\treturn err_status;\n}\n\nstatic u32 mvsd_finish_data(struct mvsd_host *host, struct mmc_data *data,\n\t\t\t    u32 err_status)\n{\n\tvoid __iomem *iobase = host->base;\n\n\tif (host->pio_ptr) {\n\t\thost->pio_ptr = NULL;\n\t\thost->pio_size = 0;\n\t} else {\n\t\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, host->sg_frags,\n\t\t\t     mmc_get_dma_dir(data));\n\t}\n\n\tif (err_status & MVSD_ERR_DATA_TIMEOUT)\n\t\tdata->error = -ETIMEDOUT;\n\telse if (err_status & (MVSD_ERR_DATA_CRC | MVSD_ERR_DATA_ENDBIT))\n\t\tdata->error = -EILSEQ;\n\telse if (err_status & MVSD_ERR_XFER_SIZE)\n\t\tdata->error = -EBADE;\n\terr_status &= ~(MVSD_ERR_DATA_TIMEOUT | MVSD_ERR_DATA_CRC |\n\t\t\tMVSD_ERR_DATA_ENDBIT | MVSD_ERR_XFER_SIZE);\n\n\tdev_dbg(host->dev, \"data done: blocks_left=%d, bytes_left=%d\\n\",\n\t\tmvsd_read(MVSD_CURR_BLK_LEFT), mvsd_read(MVSD_CURR_BYTE_LEFT));\n\tdata->bytes_xfered =\n\t\t(data->blocks - mvsd_read(MVSD_CURR_BLK_LEFT)) * data->blksz;\n\t \n\tif (data->bytes_xfered && data->error)\n\t\tdata->bytes_xfered -= data->blksz;\n\n\t \n\tif (data->stop) {\n\t\tunsigned int response[3], i;\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tresponse[i] = mvsd_read(MVSD_AUTO_RSP(i));\n\t\tdata->stop->resp[0] =\t((response[2] & 0x003f) << (8 - 8)) |\n\t\t\t\t\t((response[1] & 0xffff) << (14 - 8)) |\n\t\t\t\t\t((response[0] & 0x03ff) << (30 - 8));\n\t\tdata->stop->resp[1] =\t((response[0] & 0xfc00) >> 10);\n\t\tdata->stop->resp[2] = 0;\n\t\tdata->stop->resp[3] = 0;\n\n\t\tif (err_status & MVSD_ERR_AUTOCMD12) {\n\t\t\tu32 err_cmd12 = mvsd_read(MVSD_AUTOCMD12_ERR_STATUS);\n\t\t\tdev_dbg(host->dev, \"c12err 0x%04x\\n\", err_cmd12);\n\t\t\tif (err_cmd12 & MVSD_AUTOCMD12_ERR_NOTEXE)\n\t\t\t\tdata->stop->error = -ENOEXEC;\n\t\t\telse if (err_cmd12 & MVSD_AUTOCMD12_ERR_TIMEOUT)\n\t\t\t\tdata->stop->error = -ETIMEDOUT;\n\t\t\telse if (err_cmd12)\n\t\t\t\tdata->stop->error = -EILSEQ;\n\t\t\terr_status &= ~MVSD_ERR_AUTOCMD12;\n\t\t}\n\t}\n\n\treturn err_status;\n}\n\nstatic irqreturn_t mvsd_irq(int irq, void *dev)\n{\n\tstruct mvsd_host *host = dev;\n\tvoid __iomem *iobase = host->base;\n\tu32 intr_status, intr_done_mask;\n\tint irq_handled = 0;\n\n\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\tdev_dbg(host->dev, \"intr 0x%04x intr_en 0x%04x hw_state 0x%04x\\n\",\n\t\tintr_status, mvsd_read(MVSD_NOR_INTR_EN),\n\t\tmvsd_read(MVSD_HW_STATE));\n\n\t \n\tif (!mvsd_read(MVSD_NOR_INTR_EN) && !mvsd_read(MVSD_ERR_INTR_EN)) {\n\t\tdev_dbg(host->dev, \"spurious irq detected intr 0x%04x intr_en 0x%04x erri 0x%04x erri_en 0x%04x\\n\",\n\t\t\tmvsd_read(MVSD_NOR_INTR_STATUS),\n\t\t\tmvsd_read(MVSD_NOR_INTR_EN),\n\t\t\tmvsd_read(MVSD_ERR_INTR_STATUS),\n\t\t\tmvsd_read(MVSD_ERR_INTR_EN));\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tspin_lock(&host->lock);\n\n\t \n\tif (host->pio_size &&\n\t    (intr_status & host->intr_en &\n\t     (MVSD_NOR_RX_READY | MVSD_NOR_RX_FIFO_8W))) {\n\t\tu16 *p = host->pio_ptr;\n\t\tint s = host->pio_size;\n\t\twhile (s >= 32 && (intr_status & MVSD_NOR_RX_FIFO_8W)) {\n\t\t\treadsw(iobase + MVSD_FIFO, p, 16);\n\t\t\tp += 16;\n\t\t\ts -= 32;\n\t\t\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\t\t}\n\t\t \n\t\tif (s <= 32) {\n\t\t\twhile (s >= 4 && (intr_status & MVSD_NOR_RX_READY)) {\n\t\t\t\tput_unaligned(mvsd_read(MVSD_FIFO), p++);\n\t\t\t\tput_unaligned(mvsd_read(MVSD_FIFO), p++);\n\t\t\t\ts -= 4;\n\t\t\t\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\t\t\t}\n\t\t\tif (s && s < 4 && (intr_status & MVSD_NOR_RX_READY)) {\n\t\t\t\tu16 val[2] = {0, 0};\n\t\t\t\tval[0] = mvsd_read(MVSD_FIFO);\n\t\t\t\tval[1] = mvsd_read(MVSD_FIFO);\n\t\t\t\tmemcpy(p, ((void *)&val) + 4 - s, s);\n\t\t\t\ts = 0;\n\t\t\t\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\t\t\t}\n\t\t\tif (s == 0) {\n\t\t\t\thost->intr_en &=\n\t\t\t\t     ~(MVSD_NOR_RX_READY | MVSD_NOR_RX_FIFO_8W);\n\t\t\t\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\t\t\t} else if (host->intr_en & MVSD_NOR_RX_FIFO_8W) {\n\t\t\t\thost->intr_en &= ~MVSD_NOR_RX_FIFO_8W;\n\t\t\t\thost->intr_en |= MVSD_NOR_RX_READY;\n\t\t\t\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\t\t\t}\n\t\t}\n\t\tdev_dbg(host->dev, \"pio %d intr 0x%04x hw_state 0x%04x\\n\",\n\t\t\ts, intr_status, mvsd_read(MVSD_HW_STATE));\n\t\thost->pio_ptr = p;\n\t\thost->pio_size = s;\n\t\tirq_handled = 1;\n\t} else if (host->pio_size &&\n\t\t   (intr_status & host->intr_en &\n\t\t    (MVSD_NOR_TX_AVAIL | MVSD_NOR_TX_FIFO_8W))) {\n\t\tu16 *p = host->pio_ptr;\n\t\tint s = host->pio_size;\n\t\t \n\t\twhile (s >= 4 && (intr_status & MVSD_NOR_TX_AVAIL)) {\n\t\t\tmvsd_write(MVSD_FIFO, get_unaligned(p++));\n\t\t\tmvsd_write(MVSD_FIFO, get_unaligned(p++));\n\t\t\ts -= 4;\n\t\t\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\t\t}\n\t\tif (s < 4) {\n\t\t\tif (s && (intr_status & MVSD_NOR_TX_AVAIL)) {\n\t\t\t\tu16 val[2] = {0, 0};\n\t\t\t\tmemcpy(((void *)&val) + 4 - s, p, s);\n\t\t\t\tmvsd_write(MVSD_FIFO, val[0]);\n\t\t\t\tmvsd_write(MVSD_FIFO, val[1]);\n\t\t\t\ts = 0;\n\t\t\t\tintr_status = mvsd_read(MVSD_NOR_INTR_STATUS);\n\t\t\t}\n\t\t\tif (s == 0) {\n\t\t\t\thost->intr_en &=\n\t\t\t\t     ~(MVSD_NOR_TX_AVAIL | MVSD_NOR_TX_FIFO_8W);\n\t\t\t\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\t\t\t}\n\t\t}\n\t\tdev_dbg(host->dev, \"pio %d intr 0x%04x hw_state 0x%04x\\n\",\n\t\t\ts, intr_status, mvsd_read(MVSD_HW_STATE));\n\t\thost->pio_ptr = p;\n\t\thost->pio_size = s;\n\t\tirq_handled = 1;\n\t}\n\n\tmvsd_write(MVSD_NOR_INTR_STATUS, intr_status);\n\n\tintr_done_mask = MVSD_NOR_CARD_INT | MVSD_NOR_RX_READY |\n\t\t\t MVSD_NOR_RX_FIFO_8W | MVSD_NOR_TX_FIFO_8W;\n\tif (intr_status & host->intr_en & ~intr_done_mask) {\n\t\tstruct mmc_request *mrq = host->mrq;\n\t\tstruct mmc_command *cmd = mrq->cmd;\n\t\tu32 err_status = 0;\n\n\t\tdel_timer(&host->timer);\n\t\thost->mrq = NULL;\n\n\t\thost->intr_en &= MVSD_NOR_CARD_INT;\n\t\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\t\tmvsd_write(MVSD_ERR_INTR_EN, 0);\n\n\t\tspin_unlock(&host->lock);\n\n\t\tif (intr_status & MVSD_NOR_UNEXP_RSP) {\n\t\t\tcmd->error = -EPROTO;\n\t\t} else if (intr_status & MVSD_NOR_ERROR) {\n\t\t\terr_status = mvsd_read(MVSD_ERR_INTR_STATUS);\n\t\t\tdev_dbg(host->dev, \"err 0x%04x\\n\", err_status);\n\t\t}\n\n\t\terr_status = mvsd_finish_cmd(host, cmd, err_status);\n\t\tif (mrq->data)\n\t\t\terr_status = mvsd_finish_data(host, mrq->data, err_status);\n\t\tif (err_status) {\n\t\t\tdev_err(host->dev, \"unhandled error status %#04x\\n\",\n\t\t\t\terr_status);\n\t\t\tcmd->error = -ENOMSG;\n\t\t}\n\n\t\tmmc_request_done(host->mmc, mrq);\n\t\tirq_handled = 1;\n\t} else\n\t\tspin_unlock(&host->lock);\n\n\tif (intr_status & MVSD_NOR_CARD_INT) {\n\t\tmmc_signal_sdio_irq(host->mmc);\n\t\tirq_handled = 1;\n\t}\n\n\tif (irq_handled)\n\t\treturn IRQ_HANDLED;\n\n\tdev_err(host->dev, \"unhandled interrupt status=0x%04x en=0x%04x pio=%d\\n\",\n\t\tintr_status, host->intr_en, host->pio_size);\n\treturn IRQ_NONE;\n}\n\nstatic void mvsd_timeout_timer(struct timer_list *t)\n{\n\tstruct mvsd_host *host = from_timer(host, t, timer);\n\tvoid __iomem *iobase = host->base;\n\tstruct mmc_request *mrq;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tmrq = host->mrq;\n\tif (mrq) {\n\t\tdev_err(host->dev, \"Timeout waiting for hardware interrupt.\\n\");\n\t\tdev_err(host->dev, \"hw_state=0x%04x, intr_status=0x%04x intr_en=0x%04x\\n\",\n\t\t\tmvsd_read(MVSD_HW_STATE),\n\t\t\tmvsd_read(MVSD_NOR_INTR_STATUS),\n\t\t\tmvsd_read(MVSD_NOR_INTR_EN));\n\n\t\thost->mrq = NULL;\n\n\t\tmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\n\n\t\thost->xfer_mode &= MVSD_XFER_MODE_INT_CHK_EN;\n\t\tmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\n\n\t\thost->intr_en &= MVSD_NOR_CARD_INT;\n\t\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\t\tmvsd_write(MVSD_ERR_INTR_EN, 0);\n\t\tmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\n\n\t\tmrq->cmd->error = -ETIMEDOUT;\n\t\tmvsd_finish_cmd(host, mrq->cmd, 0);\n\t\tif (mrq->data) {\n\t\t\tmrq->data->error = -ETIMEDOUT;\n\t\t\tmvsd_finish_data(host, mrq->data, 0);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (mrq)\n\t\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void mvsd_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct mvsd_host *host = mmc_priv(mmc);\n\tvoid __iomem *iobase = host->base;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (enable) {\n\t\thost->xfer_mode |= MVSD_XFER_MODE_INT_CHK_EN;\n\t\thost->intr_en |= MVSD_NOR_CARD_INT;\n\t} else {\n\t\thost->xfer_mode &= ~MVSD_XFER_MODE_INT_CHK_EN;\n\t\thost->intr_en &= ~MVSD_NOR_CARD_INT;\n\t}\n\tmvsd_write(MVSD_XFER_MODE, host->xfer_mode);\n\tmvsd_write(MVSD_NOR_INTR_EN, host->intr_en);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void mvsd_power_up(struct mvsd_host *host)\n{\n\tvoid __iomem *iobase = host->base;\n\tdev_dbg(host->dev, \"power up\\n\");\n\tmvsd_write(MVSD_NOR_INTR_EN, 0);\n\tmvsd_write(MVSD_ERR_INTR_EN, 0);\n\tmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\n\tmvsd_write(MVSD_XFER_MODE, 0);\n\tmvsd_write(MVSD_NOR_STATUS_EN, 0xffff);\n\tmvsd_write(MVSD_ERR_STATUS_EN, 0xffff);\n\tmvsd_write(MVSD_NOR_INTR_STATUS, 0xffff);\n\tmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\n}\n\nstatic void mvsd_power_down(struct mvsd_host *host)\n{\n\tvoid __iomem *iobase = host->base;\n\tdev_dbg(host->dev, \"power down\\n\");\n\tmvsd_write(MVSD_NOR_INTR_EN, 0);\n\tmvsd_write(MVSD_ERR_INTR_EN, 0);\n\tmvsd_write(MVSD_SW_RESET, MVSD_SW_RESET_NOW);\n\tmvsd_write(MVSD_XFER_MODE, MVSD_XFER_MODE_STOP_CLK);\n\tmvsd_write(MVSD_NOR_STATUS_EN, 0);\n\tmvsd_write(MVSD_ERR_STATUS_EN, 0);\n\tmvsd_write(MVSD_NOR_INTR_STATUS, 0xffff);\n\tmvsd_write(MVSD_ERR_INTR_STATUS, 0xffff);\n}\n\nstatic void mvsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct mvsd_host *host = mmc_priv(mmc);\n\tvoid __iomem *iobase = host->base;\n\tu32 ctrl_reg = 0;\n\n\tif (ios->power_mode == MMC_POWER_UP)\n\t\tmvsd_power_up(host);\n\n\tif (ios->clock == 0) {\n\t\tmvsd_write(MVSD_XFER_MODE, MVSD_XFER_MODE_STOP_CLK);\n\t\tmvsd_write(MVSD_CLK_DIV, MVSD_BASE_DIV_MAX);\n\t\thost->clock = 0;\n\t\tdev_dbg(host->dev, \"clock off\\n\");\n\t} else if (ios->clock != host->clock) {\n\t\tu32 m = DIV_ROUND_UP(host->base_clock, ios->clock) - 1;\n\t\tif (m > MVSD_BASE_DIV_MAX)\n\t\t\tm = MVSD_BASE_DIV_MAX;\n\t\tmvsd_write(MVSD_CLK_DIV, m);\n\t\thost->clock = ios->clock;\n\t\thost->ns_per_clk = 1000000000 / (host->base_clock / (m+1));\n\t\tdev_dbg(host->dev, \"clock=%d (%d), div=0x%04x\\n\",\n\t\t\tios->clock, host->base_clock / (m+1), m);\n\t}\n\n\t \n\tctrl_reg |= MVSD_HOST_CTRL_BIG_ENDIAN;\n\tctrl_reg &= ~MVSD_HOST_CTRL_LSB_FIRST;\n\n\t \n\tctrl_reg |= MVSD_HOST_CTRL_TMOUT_MASK;\n\tctrl_reg |= MVSD_HOST_CTRL_TMOUT_EN;\n\n\tif (ios->bus_mode == MMC_BUSMODE_PUSHPULL)\n\t\tctrl_reg |= MVSD_HOST_CTRL_PUSH_PULL_EN;\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_4)\n\t\tctrl_reg |= MVSD_HOST_CTRL_DATA_WIDTH_4_BITS;\n\n\t \n#if 0\n\tif (ios->timing == MMC_TIMING_MMC_HS ||\n\t    ios->timing == MMC_TIMING_SD_HS)\n\t\tctrl_reg |= MVSD_HOST_CTRL_HI_SPEED_EN;\n#endif\n\n\thost->ctrl = ctrl_reg;\n\tmvsd_write(MVSD_HOST_CTRL, ctrl_reg);\n\tdev_dbg(host->dev, \"ctrl 0x%04x: %s %s %s\\n\", ctrl_reg,\n\t\t(ctrl_reg & MVSD_HOST_CTRL_PUSH_PULL_EN) ?\n\t\t\t\"push-pull\" : \"open-drain\",\n\t\t(ctrl_reg & MVSD_HOST_CTRL_DATA_WIDTH_4_BITS) ?\n\t\t\t\"4bit-width\" : \"1bit-width\",\n\t\t(ctrl_reg & MVSD_HOST_CTRL_HI_SPEED_EN) ?\n\t\t\t\"high-speed\" : \"\");\n\n\tif (ios->power_mode == MMC_POWER_OFF)\n\t\tmvsd_power_down(host);\n}\n\nstatic const struct mmc_host_ops mvsd_ops = {\n\t.request\t\t= mvsd_request,\n\t.get_ro\t\t\t= mmc_gpio_get_ro,\n\t.set_ios\t\t= mvsd_set_ios,\n\t.enable_sdio_irq\t= mvsd_enable_sdio_irq,\n};\n\nstatic void\nmv_conf_mbus_windows(struct mvsd_host *host,\n\t\t     const struct mbus_dram_target_info *dram)\n{\n\tvoid __iomem *iobase = host->base;\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\twritel(0, iobase + MVSD_WINDOW_CTRL(i));\n\t\twritel(0, iobase + MVSD_WINDOW_BASE(i));\n\t}\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\t\twritel(((cs->size - 1) & 0xffff0000) |\n\t\t       (cs->mbus_attr << 8) |\n\t\t       (dram->mbus_dram_target_id << 4) | 1,\n\t\t       iobase + MVSD_WINDOW_CTRL(i));\n\t\twritel(cs->base, iobase + MVSD_WINDOW_BASE(i));\n\t}\n}\n\nstatic int mvsd_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct mmc_host *mmc = NULL;\n\tstruct mvsd_host *host = NULL;\n\tconst struct mbus_dram_target_info *dram;\n\tint ret, irq;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"no DT node\\n\");\n\t\treturn -ENODEV;\n\t}\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tmmc = mmc_alloc_host(sizeof(struct mvsd_host), &pdev->dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\thost->dev = &pdev->dev;\n\n\t \n\thost->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(host->clk)) {\n\t\tdev_err(&pdev->dev, \"no clock associated\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tclk_prepare_enable(host->clk);\n\n\tmmc->ops = &mvsd_ops;\n\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;\n\n\tmmc->f_min = DIV_ROUND_UP(host->base_clock, MVSD_BASE_DIV_MAX);\n\tmmc->f_max = MVSD_CLOCKRATE_MAX;\n\n\tmmc->max_blk_size = 2048;\n\tmmc->max_blk_count = 65535;\n\n\tmmc->max_segs = 1;\n\tmmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;\n\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\n\thost->base_clock = clk_get_rate(host->clk) / 2;\n\tret = mmc_of_parse(mmc);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (maxfreq)\n\t\tmmc->f_max = maxfreq;\n\n\tspin_lock_init(&host->lock);\n\n\thost->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(host->base)) {\n\t\tret = PTR_ERR(host->base);\n\t\tgoto out;\n\t}\n\n\t \n\tdram = mv_mbus_dram_info();\n\tif (dram)\n\t\tmv_conf_mbus_windows(host, dram);\n\n\tmvsd_power_down(host);\n\n\tret = devm_request_irq(&pdev->dev, irq, mvsd_irq, 0, DRIVER_NAME, host);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"cannot assign irq %d\\n\", irq);\n\t\tgoto out;\n\t}\n\n\ttimer_setup(&host->timer, mvsd_timeout_timer, 0);\n\tplatform_set_drvdata(pdev, mmc);\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto out;\n\n\tif (!(mmc->caps & MMC_CAP_NEEDS_POLL))\n\t\tdev_dbg(&pdev->dev, \"using GPIO for card detection\\n\");\n\telse\n\t\tdev_dbg(&pdev->dev, \"lacking card detect (fall back to polling)\\n\");\n\n\treturn 0;\n\nout:\n\tif (mmc) {\n\t\tif (!IS_ERR(host->clk))\n\t\t\tclk_disable_unprepare(host->clk);\n\t\tmmc_free_host(mmc);\n\t}\n\n\treturn ret;\n}\n\nstatic void mvsd_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc = platform_get_drvdata(pdev);\n\n\tstruct mvsd_host *host = mmc_priv(mmc);\n\n\tmmc_remove_host(mmc);\n\tdel_timer_sync(&host->timer);\n\tmvsd_power_down(host);\n\n\tif (!IS_ERR(host->clk))\n\t\tclk_disable_unprepare(host->clk);\n\tmmc_free_host(mmc);\n}\n\nstatic const struct of_device_id mvsdio_dt_ids[] = {\n\t{ .compatible = \"marvell,orion-sdio\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, mvsdio_dt_ids);\n\nstatic struct platform_driver mvsd_driver = {\n\t.probe\t\t= mvsd_probe,\n\t.remove_new\t= mvsd_remove,\n\t.driver\t\t= {\n\t\t.name\t= DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = mvsdio_dt_ids,\n\t},\n};\n\nmodule_platform_driver(mvsd_driver);\n\n \nmodule_param(maxfreq, int, 0);\n\n \nmodule_param(nodma, int, 0);\n\nMODULE_AUTHOR(\"Maen Suleiman, Nicolas Pitre\");\nMODULE_DESCRIPTION(\"Marvell MMC,SD,SDIO Host Controller driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:mvsdio\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}