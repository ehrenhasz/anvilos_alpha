{
  "module_name": "sdhci-iproc.c",
  "hash_id": "e879722df1c01c65d34aa918b2a0f31ff5177acf4e441348cbf99a615491818d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-iproc.c",
  "human_readable_source": "\n\n\n \n\n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/mmc/host.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include \"sdhci-pltfm.h\"\n\nstruct sdhci_iproc_data {\n\tconst struct sdhci_pltfm_data *pdata;\n\tu32 caps;\n\tu32 caps1;\n\tu32 mmc_caps;\n\tbool missing_caps;\n};\n\nstruct sdhci_iproc_host {\n\tconst struct sdhci_iproc_data *data;\n\tu32 shadow_cmd;\n\tu32 shadow_blk;\n\tbool is_cmd_shadowed;\n\tbool is_blk_shadowed;\n};\n\n#define REG_OFFSET_IN_BITS(reg) ((reg) << 3 & 0x18)\n\nstatic inline u32 sdhci_iproc_readl(struct sdhci_host *host, int reg)\n{\n\tu32 val = readl(host->ioaddr + reg);\n\n\tpr_debug(\"%s: readl [0x%02x] 0x%08x\\n\",\n\t\t mmc_hostname(host->mmc), reg, val);\n\treturn val;\n}\n\nstatic u16 sdhci_iproc_readw(struct sdhci_host *host, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_iproc_host *iproc_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 val;\n\tu16 word;\n\n\tif ((reg == SDHCI_TRANSFER_MODE) && iproc_host->is_cmd_shadowed) {\n\t\t \n\t\tval = iproc_host->shadow_cmd;\n\t} else if ((reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) &&\n\t\t   iproc_host->is_blk_shadowed) {\n\t\t \n\t\tval = iproc_host->shadow_blk;\n\t} else {\n\t\tval = sdhci_iproc_readl(host, (reg & ~3));\n\t}\n\tword = val >> REG_OFFSET_IN_BITS(reg) & 0xffff;\n\treturn word;\n}\n\nstatic u8 sdhci_iproc_readb(struct sdhci_host *host, int reg)\n{\n\tu32 val = sdhci_iproc_readl(host, (reg & ~3));\n\tu8 byte = val >> REG_OFFSET_IN_BITS(reg) & 0xff;\n\treturn byte;\n}\n\nstatic inline void sdhci_iproc_writel(struct sdhci_host *host, u32 val, int reg)\n{\n\tpr_debug(\"%s: writel [0x%02x] 0x%08x\\n\",\n\t\t mmc_hostname(host->mmc), reg, val);\n\n\twritel(val, host->ioaddr + reg);\n\n\tif (host->clock <= 400000) {\n\t\t \n\t\tif (host->clock)\n\t\t\tudelay((4 * 1000000 + host->clock - 1) / host->clock);\n\t\telse\n\t\t\tudelay(10);\n\t}\n}\n\n \nstatic void sdhci_iproc_writew(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_iproc_host *iproc_host = sdhci_pltfm_priv(pltfm_host);\n\tu32 word_shift = REG_OFFSET_IN_BITS(reg);\n\tu32 mask = 0xffff << word_shift;\n\tu32 oldval, newval;\n\n\tif (reg == SDHCI_COMMAND) {\n\t\t \n\t\tif (iproc_host->is_blk_shadowed) {\n\t\t\tsdhci_iproc_writel(host, iproc_host->shadow_blk,\n\t\t\t\tSDHCI_BLOCK_SIZE);\n\t\t\tiproc_host->is_blk_shadowed = false;\n\t\t}\n\t\toldval = iproc_host->shadow_cmd;\n\t\tiproc_host->is_cmd_shadowed = false;\n\t} else if ((reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) &&\n\t\t   iproc_host->is_blk_shadowed) {\n\t\t \n\t\toldval = iproc_host->shadow_blk;\n\t} else {\n\t\t \n\t\toldval = sdhci_iproc_readl(host, (reg & ~3));\n\t}\n\tnewval = (oldval & ~mask) | (val << word_shift);\n\n\tif (reg == SDHCI_TRANSFER_MODE) {\n\t\t \n\t\tiproc_host->shadow_cmd = newval;\n\t\tiproc_host->is_cmd_shadowed = true;\n\t} else if (reg == SDHCI_BLOCK_SIZE || reg == SDHCI_BLOCK_COUNT) {\n\t\t \n\t\tiproc_host->shadow_blk = newval;\n\t\tiproc_host->is_blk_shadowed = true;\n\t} else {\n\t\t \n\t\tsdhci_iproc_writel(host, newval, reg & ~3);\n\t}\n}\n\nstatic void sdhci_iproc_writeb(struct sdhci_host *host, u8 val, int reg)\n{\n\tu32 oldval = sdhci_iproc_readl(host, (reg & ~3));\n\tu32 byte_shift = REG_OFFSET_IN_BITS(reg);\n\tu32 mask = 0xff << byte_shift;\n\tu32 newval = (oldval & ~mask) | (val << byte_shift);\n\n\tsdhci_iproc_writel(host, newval, reg & ~3);\n}\n\nstatic unsigned int sdhci_iproc_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\tif (pltfm_host->clk)\n\t\treturn sdhci_pltfm_clk_get_max_clock(host);\n\telse\n\t\treturn pltfm_host->clock;\n}\n\n \nstatic unsigned int sdhci_iproc_bcm2711_get_min_clock(struct sdhci_host *host)\n{\n\treturn 200000;\n}\n\nstatic const struct sdhci_ops sdhci_iproc_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.get_max_clock = sdhci_iproc_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_ops sdhci_iproc_32only_ops = {\n\t.read_l = sdhci_iproc_readl,\n\t.read_w = sdhci_iproc_readw,\n\t.read_b = sdhci_iproc_readb,\n\t.write_l = sdhci_iproc_writel,\n\t.write_w = sdhci_iproc_writew,\n\t.write_b = sdhci_iproc_writeb,\n\t.set_clock = sdhci_set_clock,\n\t.get_max_clock = sdhci_iproc_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_iproc_cygnus_pltfm_data = {\n\t.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_ACMD23_BROKEN | SDHCI_QUIRK2_HOST_OFF_CARD_ON,\n\t.ops = &sdhci_iproc_32only_ops,\n};\n\nstatic const struct sdhci_iproc_data iproc_cygnus_data = {\n\t.pdata = &sdhci_iproc_cygnus_pltfm_data,\n\t.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)\n\t\t\t& SDHCI_MAX_BLOCK_MASK) |\n\t\tSDHCI_CAN_VDD_330 |\n\t\tSDHCI_CAN_VDD_180 |\n\t\tSDHCI_CAN_DO_SUSPEND |\n\t\tSDHCI_CAN_DO_HISPD |\n\t\tSDHCI_CAN_DO_ADMA2 |\n\t\tSDHCI_CAN_DO_SDMA,\n\t.caps1 = SDHCI_DRIVER_TYPE_C |\n\t\t SDHCI_DRIVER_TYPE_D |\n\t\t SDHCI_SUPPORT_DDR50,\n\t.mmc_caps = MMC_CAP_1_8V_DDR,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_iproc_pltfm_data = {\n\t.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12 |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_ACMD23_BROKEN,\n\t.ops = &sdhci_iproc_ops,\n};\n\nstatic const struct sdhci_iproc_data iproc_data = {\n\t.pdata = &sdhci_iproc_pltfm_data,\n\t.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)\n\t\t\t& SDHCI_MAX_BLOCK_MASK) |\n\t\tSDHCI_CAN_VDD_330 |\n\t\tSDHCI_CAN_VDD_180 |\n\t\tSDHCI_CAN_DO_SUSPEND |\n\t\tSDHCI_CAN_DO_HISPD |\n\t\tSDHCI_CAN_DO_ADMA2 |\n\t\tSDHCI_CAN_DO_SDMA,\n\t.caps1 = SDHCI_DRIVER_TYPE_C |\n\t\t SDHCI_DRIVER_TYPE_D |\n\t\t SDHCI_SUPPORT_DDR50,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_bcm2835_pltfm_data = {\n\t.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops = &sdhci_iproc_32only_ops,\n};\n\nstatic const struct sdhci_iproc_data bcm2835_data = {\n\t.pdata = &sdhci_bcm2835_pltfm_data,\n\t.caps = ((0x1 << SDHCI_MAX_BLOCK_SHIFT)\n\t\t\t& SDHCI_MAX_BLOCK_MASK) |\n\t\tSDHCI_CAN_VDD_330 |\n\t\tSDHCI_CAN_DO_HISPD,\n\t.caps1 = SDHCI_DRIVER_TYPE_A |\n\t\t SDHCI_DRIVER_TYPE_C,\n\t.mmc_caps = 0x00000000,\n\t.missing_caps = true,\n};\n\nstatic const struct sdhci_ops sdhci_iproc_bcm2711_ops = {\n\t.read_l = sdhci_iproc_readl,\n\t.read_w = sdhci_iproc_readw,\n\t.read_b = sdhci_iproc_readb,\n\t.write_l = sdhci_iproc_writel,\n\t.write_w = sdhci_iproc_writew,\n\t.write_b = sdhci_iproc_writeb,\n\t.set_clock = sdhci_set_clock,\n\t.set_power = sdhci_set_power_and_bus_voltage,\n\t.get_max_clock = sdhci_iproc_get_max_clock,\n\t.get_min_clock = sdhci_iproc_bcm2711_get_min_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_bcm2711_pltfm_data = {\n\t.quirks = SDHCI_QUIRK_MULTIBLOCK_READ_ACMD12,\n\t.ops = &sdhci_iproc_bcm2711_ops,\n};\n\nstatic const struct sdhci_iproc_data bcm2711_data = {\n\t.pdata = &sdhci_bcm2711_pltfm_data,\n\t.mmc_caps = MMC_CAP_3_3V_DDR,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_bcm7211a0_pltfm_data = {\n\t.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL |\n\t\tSDHCI_QUIRK_BROKEN_DMA |\n\t\tSDHCI_QUIRK_BROKEN_ADMA,\n\t.ops = &sdhci_iproc_ops,\n};\n\n#define BCM7211A0_BASE_CLK_MHZ 100\nstatic const struct sdhci_iproc_data bcm7211a0_data = {\n\t.pdata = &sdhci_bcm7211a0_pltfm_data,\n\t.caps = ((BCM7211A0_BASE_CLK_MHZ / 2) << SDHCI_TIMEOUT_CLK_SHIFT) |\n\t\t(BCM7211A0_BASE_CLK_MHZ << SDHCI_CLOCK_BASE_SHIFT) |\n\t\t((0x2 << SDHCI_MAX_BLOCK_SHIFT)\n\t\t\t& SDHCI_MAX_BLOCK_MASK) |\n\t\tSDHCI_CAN_VDD_330 |\n\t\tSDHCI_CAN_VDD_180 |\n\t\tSDHCI_CAN_DO_SUSPEND |\n\t\tSDHCI_CAN_DO_HISPD,\n\t.caps1 = SDHCI_DRIVER_TYPE_C |\n\t\t SDHCI_DRIVER_TYPE_D,\n\t.missing_caps = true,\n};\n\nstatic const struct of_device_id sdhci_iproc_of_match[] = {\n\t{ .compatible = \"brcm,bcm2835-sdhci\", .data = &bcm2835_data },\n\t{ .compatible = \"brcm,bcm2711-emmc2\", .data = &bcm2711_data },\n\t{ .compatible = \"brcm,sdhci-iproc-cygnus\", .data = &iproc_cygnus_data},\n\t{ .compatible = \"brcm,sdhci-iproc\", .data = &iproc_data },\n\t{ .compatible = \"brcm,bcm7211a0-sdhci\", .data = &bcm7211a0_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, sdhci_iproc_of_match);\n\n#ifdef CONFIG_ACPI\n \nstatic const struct sdhci_pltfm_data sdhci_bcm_arasan_data = {\n\t.quirks = SDHCI_QUIRK_BROKEN_CARD_DETECTION |\n\t\t  SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK |\n\t\t  SDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,\n\t.ops = &sdhci_iproc_32only_ops,\n};\n\nstatic const struct sdhci_iproc_data bcm_arasan_data = {\n\t.pdata = &sdhci_bcm_arasan_data,\n};\n\nstatic const struct acpi_device_id sdhci_iproc_acpi_ids[] = {\n\t{ .id = \"BRCM5871\", .driver_data = (kernel_ulong_t)&iproc_cygnus_data },\n\t{ .id = \"BRCM5872\", .driver_data = (kernel_ulong_t)&iproc_data },\n\t{ .id = \"BCM2847\",  .driver_data = (kernel_ulong_t)&bcm_arasan_data },\n\t{ .id = \"BRCME88C\", .driver_data = (kernel_ulong_t)&bcm2711_data },\n\t{   }\n};\nMODULE_DEVICE_TABLE(acpi, sdhci_iproc_acpi_ids);\n#endif\n\nstatic int sdhci_iproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct sdhci_iproc_data *iproc_data = NULL;\n\tstruct sdhci_host *host;\n\tstruct sdhci_iproc_host *iproc_host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tint ret;\n\n\tiproc_data = device_get_match_data(dev);\n\tif (!iproc_data)\n\t\treturn -ENODEV;\n\n\thost = sdhci_pltfm_init(pdev, iproc_data->pdata, sizeof(*iproc_host));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tiproc_host = sdhci_pltfm_priv(pltfm_host);\n\n\tiproc_host->data = iproc_data;\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err;\n\n\tsdhci_get_property(pdev);\n\n\thost->mmc->caps |= iproc_host->data->mmc_caps;\n\n\tif (dev->of_node) {\n\t\tpltfm_host->clk = devm_clk_get_enabled(dev, NULL);\n\t\tif (IS_ERR(pltfm_host->clk)) {\n\t\t\tret = PTR_ERR(pltfm_host->clk);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (iproc_host->data->missing_caps) {\n\t\t__sdhci_read_caps(host, NULL,\n\t\t\t\t  &iproc_host->data->caps,\n\t\t\t\t  &iproc_host->data->caps1);\n\t}\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_iproc_shutdown(struct platform_device *pdev)\n{\n\tsdhci_pltfm_suspend(&pdev->dev);\n}\n\nstatic struct platform_driver sdhci_iproc_driver = {\n\t.driver = {\n\t\t.name = \"sdhci-iproc\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = sdhci_iproc_of_match,\n\t\t.acpi_match_table = ACPI_PTR(sdhci_iproc_acpi_ids),\n\t\t.pm = &sdhci_pltfm_pmops,\n\t},\n\t.probe = sdhci_iproc_probe,\n\t.remove_new = sdhci_pltfm_remove,\n\t.shutdown = sdhci_iproc_shutdown,\n};\nmodule_platform_driver(sdhci_iproc_driver);\n\nMODULE_AUTHOR(\"Broadcom\");\nMODULE_DESCRIPTION(\"IPROC SDHCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}