{
  "module_name": "sdhci-pxav3.c",
  "hash_id": "d2da87843248097358c21364b370da46caf23c8fb11f420ddb83c79fcd8186cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pxav3.c",
  "human_readable_source": "\n \n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/platform_device.h>\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/platform_data/pxa_sdhci.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/mbus.h>\n\n#include \"sdhci.h\"\n#include \"sdhci-pltfm.h\"\n\n#define PXAV3_RPM_DELAY_MS     50\n\n#define SD_CLOCK_BURST_SIZE_SETUP\t\t0x10A\n#define SDCLK_SEL\t0x100\n#define SDCLK_DELAY_SHIFT\t9\n#define SDCLK_DELAY_MASK\t0x1f\n\n#define SD_CFG_FIFO_PARAM       0x100\n#define SDCFG_GEN_PAD_CLK_ON\t(1<<6)\n#define SDCFG_GEN_PAD_CLK_CNT_MASK\t0xFF\n#define SDCFG_GEN_PAD_CLK_CNT_SHIFT\t24\n\n#define SD_SPI_MODE          0x108\n#define SD_CE_ATA_1          0x10C\n\n#define SD_CE_ATA_2          0x10E\n#define SDCE_MISC_INT\t\t(1<<2)\n#define SDCE_MISC_INT_EN\t(1<<1)\n\nstruct sdhci_pxa {\n\tstruct clk *clk_core;\n\tstruct clk *clk_io;\n\tu8\tpower_mode;\n\tvoid __iomem *sdio3_conf_reg;\n};\n\n \n#define SDHCI_WINDOW_CTRL(i)\t(0x80 + ((i) << 3))\n#define SDHCI_WINDOW_BASE(i)\t(0x84 + ((i) << 3))\n#define SDHCI_MAX_WIN_NUM\t8\n\n \n\n#define SDIO3_CONF_CLK_INV\tBIT(0)\n#define SDIO3_CONF_SD_FB_CLK\tBIT(2)\n\nstatic int mv_conf_mbus_windows(struct platform_device *pdev,\n\t\t\t\tconst struct mbus_dram_target_info *dram)\n{\n\tint i;\n\tvoid __iomem *regs;\n\tstruct resource *res;\n\n\tif (!dram) {\n\t\tdev_err(&pdev->dev, \"no mbus dram info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"cannot get mbus registers\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tregs = ioremap(res->start, resource_size(res));\n\tif (!regs) {\n\t\tdev_err(&pdev->dev, \"cannot map mbus registers\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < SDHCI_MAX_WIN_NUM; i++) {\n\t\twritel(0, regs + SDHCI_WINDOW_CTRL(i));\n\t\twritel(0, regs + SDHCI_WINDOW_BASE(i));\n\t}\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\t \n\t\twritel(((cs->size - 1) & 0xffff0000) |\n\t\t\t(cs->mbus_attr << 8) |\n\t\t\t(dram->mbus_dram_target_id << 4) | 1,\n\t\t\tregs + SDHCI_WINDOW_CTRL(i));\n\t\t \n\t\twritel(cs->base, regs + SDHCI_WINDOW_BASE(i));\n\t}\n\n\tiounmap(regs);\n\n\treturn 0;\n}\n\nstatic int armada_38x_quirks(struct platform_device *pdev,\n\t\t\t     struct sdhci_host *host)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\tstruct resource *res;\n\n\thost->quirks &= ~SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN;\n\n\tsdhci_read_caps(host);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t   \"conf-sdio3\");\n\tif (res) {\n\t\tpxa->sdio3_conf_reg = devm_ioremap_resource(&pdev->dev, res);\n\t\tif (IS_ERR(pxa->sdio3_conf_reg))\n\t\t\treturn PTR_ERR(pxa->sdio3_conf_reg);\n\t} else {\n\t\t \n\t\thost->caps1 &= ~(SDHCI_SUPPORT_SDR50 | SDHCI_SUPPORT_DDR50);\n\n\t\tdev_warn(&pdev->dev, \"conf-sdio3 register not found: disabling SDR50 and DDR50 modes.\\nConsider updating your dtb\\n\");\n\t}\n\n\t \n\tif (of_property_read_bool(np, \"no-1-8-v\")) {\n\t\thost->caps &= ~SDHCI_CAN_VDD_180;\n\t\thost->mmc->caps &= ~MMC_CAP_1_8V_DDR;\n\t} else {\n\t\thost->caps &= ~SDHCI_CAN_VDD_330;\n\t}\n\thost->caps1 &= ~(SDHCI_SUPPORT_SDR104 | SDHCI_USE_SDR50_TUNING);\n\n\treturn 0;\n}\n\nstatic void pxav3_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct platform_device *pdev = to_platform_device(mmc_dev(host->mmc));\n\tstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\n\n\tsdhci_reset(host, mask);\n\n\tif (mask == SDHCI_RESET_ALL) {\n\t\t \n\t\tif (pdata && 0 != pdata->clk_delay_cycles) {\n\t\t\tu16 tmp;\n\n\t\t\ttmp = readw(host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\n\t\t\ttmp |= (pdata->clk_delay_cycles & SDCLK_DELAY_MASK)\n\t\t\t\t<< SDCLK_DELAY_SHIFT;\n\t\t\ttmp |= SDCLK_SEL;\n\t\t\twritew(tmp, host->ioaddr + SD_CLOCK_BURST_SIZE_SETUP);\n\t\t}\n\t}\n}\n\n#define MAX_WAIT_COUNT 5\nstatic void pxav3_gen_init_74_clocks(struct sdhci_host *host, u8 power_mode)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\tu16 tmp;\n\tint count;\n\n\tif (pxa->power_mode == MMC_POWER_UP\n\t\t\t&& power_mode == MMC_POWER_ON) {\n\n\t\tdev_dbg(mmc_dev(host->mmc),\n\t\t\t\t\"%s: slot->power_mode = %d,\"\n\t\t\t\t\"ios->power_mode = %d\\n\",\n\t\t\t\t__func__,\n\t\t\t\tpxa->power_mode,\n\t\t\t\tpower_mode);\n\n\t\t \n\t\ttmp = readw(host->ioaddr + SD_CE_ATA_2);\n\t\ttmp |= SDCE_MISC_INT_EN;\n\t\twritew(tmp, host->ioaddr + SD_CE_ATA_2);\n\n\t\t \n\t\ttmp = readw(host->ioaddr + SD_CFG_FIFO_PARAM);\n\t\ttmp |= SDCFG_GEN_PAD_CLK_ON;\n\t\twritew(tmp, host->ioaddr + SD_CFG_FIFO_PARAM);\n\n\t\t \n\t\tudelay(740);\n\t\tcount = 0;\n\n\t\twhile (count++ < MAX_WAIT_COUNT) {\n\t\t\tif ((readw(host->ioaddr + SD_CE_ATA_2)\n\t\t\t\t\t\t& SDCE_MISC_INT) == 0)\n\t\t\t\tbreak;\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (count == MAX_WAIT_COUNT)\n\t\t\tdev_warn(mmc_dev(host->mmc), \"74 clock interrupt not cleared\\n\");\n\n\t\t \n\t\ttmp = readw(host->ioaddr + SD_CE_ATA_2);\n\t\ttmp |= SDCE_MISC_INT;\n\t\twritew(tmp, host->ioaddr + SD_CE_ATA_2);\n\t}\n\tpxa->power_mode = power_mode;\n}\n\nstatic void pxav3_set_uhs_signaling(struct sdhci_host *host, unsigned int uhs)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\tu16 ctrl_2;\n\n\t \n\tctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);\n\n\t \n\tctrl_2 &= ~SDHCI_CTRL_UHS_MASK;\n\tswitch (uhs) {\n\tcase MMC_TIMING_UHS_SDR12:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR12;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR25;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR50 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_SDR104 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tctrl_2 |= SDHCI_CTRL_UHS_DDR50 | SDHCI_CTRL_VDD_180;\n\t\tbreak;\n\t}\n\n\t \n\tif (pxa->sdio3_conf_reg) {\n\t\tu8 reg_val  = readb(pxa->sdio3_conf_reg);\n\n\t\tif (uhs == MMC_TIMING_UHS_SDR50 ||\n\t\t    uhs == MMC_TIMING_UHS_DDR50) {\n\t\t\treg_val &= ~SDIO3_CONF_CLK_INV;\n\t\t\treg_val |= SDIO3_CONF_SD_FB_CLK;\n\t\t} else if (uhs == MMC_TIMING_MMC_HS) {\n\t\t\treg_val &= ~SDIO3_CONF_CLK_INV;\n\t\t\treg_val &= ~SDIO3_CONF_SD_FB_CLK;\n\t\t} else {\n\t\t\treg_val |= SDIO3_CONF_CLK_INV;\n\t\t\treg_val &= ~SDIO3_CONF_SD_FB_CLK;\n\t\t}\n\t\twriteb(reg_val, pxa->sdio3_conf_reg);\n\t}\n\n\tsdhci_writew(host, ctrl_2, SDHCI_HOST_CONTROL2);\n\tdev_dbg(mmc_dev(host->mmc),\n\t\t\"%s uhs = %d, ctrl_2 = %04X\\n\",\n\t\t__func__, uhs, ctrl_2);\n}\n\nstatic void pxav3_set_power(struct sdhci_host *host, unsigned char mode,\n\t\t\t    unsigned short vdd)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tu8 pwr = host->pwr;\n\n\tsdhci_set_power_noreg(host, mode, vdd);\n\n\tif (host->pwr == pwr)\n\t\treturn;\n\n\tif (host->pwr == 0)\n\t\tvdd = 0;\n\n\tif (!IS_ERR(mmc->supply.vmmc))\n\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, vdd);\n}\n\nstatic const struct sdhci_ops pxav3_sdhci_ops = {\n\t.set_clock = sdhci_set_clock,\n\t.set_power = pxav3_set_power,\n\t.platform_send_init_74_clocks = pxav3_gen_init_74_clocks,\n\t.get_max_clock = sdhci_pltfm_clk_get_max_clock,\n\t.set_bus_width = sdhci_set_bus_width,\n\t.reset = pxav3_reset,\n\t.set_uhs_signaling = pxav3_set_uhs_signaling,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_pxav3_pdata = {\n\t.quirks = SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK\n\t\t| SDHCI_QUIRK_NO_ENDATTR_IN_NOPDESC\n\t\t| SDHCI_QUIRK_32BIT_ADMA_SIZE\n\t\t| SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,\n\t.ops = &pxav3_sdhci_ops,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id sdhci_pxav3_of_match[] = {\n\t{\n\t\t.compatible = \"mrvl,pxav3-mmc\",\n\t},\n\t{\n\t\t.compatible = \"marvell,armada-380-sdhci\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, sdhci_pxav3_of_match);\n\nstatic struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\n{\n\tstruct sdhci_pxa_platdata *pdata;\n\tstruct device_node *np = dev->of_node;\n\tu32 clk_delay_cycles;\n\n\tpdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn NULL;\n\n\tif (!of_property_read_u32(np, \"mrvl,clk-delay-cycles\",\n\t\t\t\t  &clk_delay_cycles))\n\t\tpdata->clk_delay_cycles = clk_delay_cycles;\n\n\treturn pdata;\n}\n#else\nstatic inline struct sdhci_pxa_platdata *pxav3_get_mmc_pdata(struct device *dev)\n{\n\treturn NULL;\n}\n#endif\n\nstatic int sdhci_pxav3_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct sdhci_pxa_platdata *pdata = pdev->dev.platform_data;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct sdhci_host *host = NULL;\n\tstruct sdhci_pxa *pxa = NULL;\n\tconst struct of_device_id *match;\n\tint ret;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_pxav3_pdata, sizeof(*pxa));\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tpxa = sdhci_pltfm_priv(pltfm_host);\n\n\tpxa->clk_io = devm_clk_get(dev, \"io\");\n\tif (IS_ERR(pxa->clk_io))\n\t\tpxa->clk_io = devm_clk_get(dev, NULL);\n\tif (IS_ERR(pxa->clk_io)) {\n\t\tdev_err(dev, \"failed to get io clock\\n\");\n\t\tret = PTR_ERR(pxa->clk_io);\n\t\tgoto err_clk_get;\n\t}\n\tpltfm_host->clk = pxa->clk_io;\n\tclk_prepare_enable(pxa->clk_io);\n\n\tpxa->clk_core = devm_clk_get(dev, \"core\");\n\tif (!IS_ERR(pxa->clk_core))\n\t\tclk_prepare_enable(pxa->clk_core);\n\n\t \n\thost->mmc->caps |= MMC_CAP_1_8V_DDR;\n\n\tif (of_device_is_compatible(np, \"marvell,armada-380-sdhci\")) {\n\t\tret = armada_38x_quirks(pdev, host);\n\t\tif (ret < 0)\n\t\t\tgoto err_mbus_win;\n\t\tret = mv_conf_mbus_windows(pdev, mv_mbus_dram_info());\n\t\tif (ret < 0)\n\t\t\tgoto err_mbus_win;\n\t}\n\n\tmatch = of_match_device(of_match_ptr(sdhci_pxav3_of_match), &pdev->dev);\n\tif (match) {\n\t\tret = mmc_of_parse(host->mmc);\n\t\tif (ret)\n\t\t\tgoto err_of_parse;\n\t\tsdhci_get_of_property(pdev);\n\t\tpdata = pxav3_get_mmc_pdata(dev);\n\t\tpdev->dev.platform_data = pdata;\n\t} else if (pdata) {\n\t\t \n\t\tif (pdata->flags & PXA_FLAG_CARD_PERMANENT)\n\t\t\thost->mmc->caps |= MMC_CAP_NONREMOVABLE;\n\n\t\t \n\t\tif (pdata->flags & PXA_FLAG_SD_8_BIT_CAPABLE_SLOT)\n\t\t\thost->mmc->caps |= MMC_CAP_8_BIT_DATA;\n\n\t\tif (pdata->quirks)\n\t\t\thost->quirks |= pdata->quirks;\n\t\tif (pdata->quirks2)\n\t\t\thost->quirks2 |= pdata->quirks2;\n\t\tif (pdata->host_caps)\n\t\t\thost->mmc->caps |= pdata->host_caps;\n\t\tif (pdata->host_caps2)\n\t\t\thost->mmc->caps2 |= pdata->host_caps2;\n\t\tif (pdata->pm_caps)\n\t\t\thost->mmc->pm_caps |= pdata->pm_caps;\n\t}\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, PXAV3_RPM_DELAY_MS);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_add_host;\n\n\tif (host->mmc->pm_caps & MMC_PM_WAKE_SDIO_IRQ)\n\t\tdevice_init_wakeup(&pdev->dev, 1);\n\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_add_host:\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\nerr_of_parse:\nerr_mbus_win:\n\tclk_disable_unprepare(pxa->clk_io);\n\tclk_disable_unprepare(pxa->clk_core);\nerr_clk_get:\n\tsdhci_pltfm_free(pdev);\n\treturn ret;\n}\n\nstatic void sdhci_pxav3_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tsdhci_remove_host(host, 1);\n\n\tclk_disable_unprepare(pxa->clk_io);\n\tclk_disable_unprepare(pxa->clk_core);\n\n\tsdhci_pltfm_free(pdev);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int sdhci_pxav3_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\tret = sdhci_suspend_host(host);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n\nstatic int sdhci_pxav3_resume(struct device *dev)\n{\n\tint ret;\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\n\tpm_runtime_get_sync(dev);\n\tret = sdhci_resume_host(host);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int sdhci_pxav3_runtime_suspend(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\tint ret;\n\n\tret = sdhci_runtime_suspend_host(host);\n\tif (ret)\n\t\treturn ret;\n\n\tif (host->tuning_mode != SDHCI_TUNING_MODE_3)\n\t\tmmc_retune_needed(host->mmc);\n\n\tclk_disable_unprepare(pxa->clk_io);\n\tif (!IS_ERR(pxa->clk_core))\n\t\tclk_disable_unprepare(pxa->clk_core);\n\n\treturn 0;\n}\n\nstatic int sdhci_pxav3_runtime_resume(struct device *dev)\n{\n\tstruct sdhci_host *host = dev_get_drvdata(dev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct sdhci_pxa *pxa = sdhci_pltfm_priv(pltfm_host);\n\n\tclk_prepare_enable(pxa->clk_io);\n\tif (!IS_ERR(pxa->clk_core))\n\t\tclk_prepare_enable(pxa->clk_core);\n\n\treturn sdhci_runtime_resume_host(host, 0);\n}\n#endif\n\nstatic const struct dev_pm_ops sdhci_pxav3_pmops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(sdhci_pxav3_suspend, sdhci_pxav3_resume)\n\tSET_RUNTIME_PM_OPS(sdhci_pxav3_runtime_suspend,\n\t\tsdhci_pxav3_runtime_resume, NULL)\n};\n\nstatic struct platform_driver sdhci_pxav3_driver = {\n\t.driver\t\t= {\n\t\t.name\t= \"sdhci-pxav3\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(sdhci_pxav3_of_match),\n\t\t.pm\t= &sdhci_pxav3_pmops,\n\t},\n\t.probe\t\t= sdhci_pxav3_probe,\n\t.remove_new\t= sdhci_pxav3_remove,\n};\n\nmodule_platform_driver(sdhci_pxav3_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for pxav3\");\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}