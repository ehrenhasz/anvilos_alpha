{
  "module_name": "wmt-sdmmc.c",
  "hash_id": "0cd1279fe37df462c13f8a2504cb3833ce29e897ecc67a59d469208a1332f320",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/wmt-sdmmc.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/clk.h>\n#include <linux/interrupt.h>\n\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n\n#include <asm/byteorder.h>\n\n\n#define DRIVER_NAME \"wmt-sdhc\"\n\n\n \n#define SDMMC_CTLR\t\t\t0x00\n#define SDMMC_CMD\t\t\t0x01\n#define SDMMC_RSPTYPE\t\t\t0x02\n#define SDMMC_ARG\t\t\t0x04\n#define SDMMC_BUSMODE\t\t\t0x08\n#define SDMMC_BLKLEN\t\t\t0x0C\n#define SDMMC_BLKCNT\t\t\t0x0E\n#define SDMMC_RSP\t\t\t0x10\n#define SDMMC_CBCR\t\t\t0x20\n#define SDMMC_INTMASK0\t\t\t0x24\n#define SDMMC_INTMASK1\t\t\t0x25\n#define SDMMC_STS0\t\t\t0x28\n#define SDMMC_STS1\t\t\t0x29\n#define SDMMC_STS2\t\t\t0x2A\n#define SDMMC_STS3\t\t\t0x2B\n#define SDMMC_RSPTIMEOUT\t\t0x2C\n#define SDMMC_CLK\t\t\t0x30\t \n#define SDMMC_EXTCTRL\t\t\t0x34\n#define SDMMC_SBLKLEN\t\t\t0x38\n#define SDMMC_DMATIMEOUT\t\t0x3C\n\n\n \n#define CTLR_CMD_START\t\t\t0x01\n#define CTLR_CMD_WRITE\t\t\t0x04\n#define CTLR_FIFO_RESET\t\t\t0x08\n\n \n#define BM_SPI_MODE\t\t\t0x01\n#define BM_FOURBIT_MODE\t\t\t0x02\n#define BM_EIGHTBIT_MODE\t\t0x04\n#define BM_SD_OFF\t\t\t0x10\n#define BM_SPI_CS\t\t\t0x20\n#define BM_SD_POWER\t\t\t0x40\n#define BM_SOFT_RESET\t\t\t0x80\n\n \n#define BLKL_CRCERR_ABORT\t\t0x0800\n#define BLKL_CD_POL_HIGH\t\t0x1000\n#define BLKL_GPI_CD\t\t\t0x2000\n#define BLKL_DATA3_CD\t\t\t0x4000\n#define BLKL_INT_ENABLE\t\t\t0x8000\n\n \n#define INT0_MBLK_TRAN_DONE_INT_EN\t0x10\n#define INT0_BLK_TRAN_DONE_INT_EN\t0x20\n#define INT0_CD_INT_EN\t\t\t0x40\n#define INT0_DI_INT_EN\t\t\t0x80\n\n \n#define INT1_CMD_RES_TRAN_DONE_INT_EN\t0x02\n#define INT1_CMD_RES_TOUT_INT_EN\t0x04\n#define INT1_MBLK_AUTO_STOP_INT_EN\t0x08\n#define INT1_DATA_TOUT_INT_EN\t\t0x10\n#define INT1_RESCRC_ERR_INT_EN\t\t0x20\n#define INT1_RCRC_ERR_INT_EN\t\t0x40\n#define INT1_WCRC_ERR_INT_EN\t\t0x80\n\n \n#define STS0_WRITE_PROTECT\t\t0x02\n#define STS0_CD_DATA3\t\t\t0x04\n#define STS0_CD_GPI\t\t\t0x08\n#define STS0_MBLK_DONE\t\t\t0x10\n#define STS0_BLK_DONE\t\t\t0x20\n#define STS0_CARD_DETECT\t\t0x40\n#define STS0_DEVICE_INS\t\t\t0x80\n\n \n#define STS1_SDIO_INT\t\t\t0x01\n#define STS1_CMDRSP_DONE\t\t0x02\n#define STS1_RSP_TIMEOUT\t\t0x04\n#define STS1_AUTOSTOP_DONE\t\t0x08\n#define STS1_DATA_TIMEOUT\t\t0x10\n#define STS1_RSP_CRC_ERR\t\t0x20\n#define STS1_RCRC_ERR\t\t\t0x40\n#define STS1_WCRC_ERR\t\t\t0x80\n\n \n#define STS2_CMD_RES_BUSY\t\t0x10\n#define STS2_DATARSP_BUSY\t\t0x20\n#define STS2_DIS_FORCECLK\t\t0x80\n\n \n#define EXT_EIGHTBIT\t\t\t0x04\n\n \n#define SDDMA_GCR\t\t\t0x100\n#define SDDMA_IER\t\t\t0x104\n#define SDDMA_ISR\t\t\t0x108\n#define SDDMA_DESPR\t\t\t0x10C\n#define SDDMA_RBR\t\t\t0x110\n#define SDDMA_DAR\t\t\t0x114\n#define SDDMA_BAR\t\t\t0x118\n#define SDDMA_CPR\t\t\t0x11C\n#define SDDMA_CCR\t\t\t0x120\n\n\n \n#define DMA_GCR_DMA_EN\t\t\t0x00000001\n#define DMA_GCR_SOFT_RESET\t\t0x00000100\n\n \n#define DMA_IER_INT_EN\t\t\t0x00000001\n\n \n#define DMA_ISR_INT_STS\t\t\t0x00000001\n\n \n#define DMA_RBR_FORMAT\t\t\t0x40000000\n#define DMA_RBR_END\t\t\t0x80000000\n\n \n#define DMA_CCR_RUN\t\t\t0x00000080\n#define DMA_CCR_IF_TO_PERIPHERAL\t0x00000000\n#define DMA_CCR_PERIPHERAL_TO_IF\t0x00400000\n\n \n#define DMA_CCR_EVT_NO_STATUS\t\t0x00000000\n#define DMA_CCR_EVT_UNDERRUN\t\t0x00000001\n#define DMA_CCR_EVT_OVERRUN\t\t0x00000002\n#define DMA_CCR_EVT_DESP_READ\t\t0x00000003\n#define DMA_CCR_EVT_DATA_RW\t\t0x00000004\n#define DMA_CCR_EVT_EARLY_END\t\t0x00000005\n#define DMA_CCR_EVT_SUCCESS\t\t0x0000000F\n\n#define PDMA_READ\t\t\t0x00\n#define PDMA_WRITE\t\t\t0x01\n\n#define WMT_SD_POWER_OFF\t\t0\n#define WMT_SD_POWER_ON\t\t\t1\n\nstruct wmt_dma_descriptor {\n\tu32 flags;\n\tu32 data_buffer_addr;\n\tu32 branch_addr;\n\tu32 reserved1;\n};\n\nstruct wmt_mci_caps {\n\tunsigned int\tf_min;\n\tunsigned int\tf_max;\n\tu32\t\tocr_avail;\n\tu32\t\tcaps;\n\tu32\t\tmax_seg_size;\n\tu32\t\tmax_segs;\n\tu32\t\tmax_blk_size;\n};\n\nstruct wmt_mci_priv {\n\tstruct mmc_host *mmc;\n\tvoid __iomem *sdmmc_base;\n\n\tint irq_regular;\n\tint irq_dma;\n\n\tvoid *dma_desc_buffer;\n\tdma_addr_t dma_desc_device_addr;\n\n\tstruct completion cmdcomp;\n\tstruct completion datacomp;\n\n\tstruct completion *comp_cmd;\n\tstruct completion *comp_dma;\n\n\tstruct mmc_request *req;\n\tstruct mmc_command *cmd;\n\n\tstruct clk *clk_sdmmc;\n\tstruct device *dev;\n\n\tu8 power_inverted;\n\tu8 cd_inverted;\n};\n\nstatic void wmt_set_sd_power(struct wmt_mci_priv *priv, int enable)\n{\n\tu32 reg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\n\tif (enable ^ priv->power_inverted)\n\t\treg_tmp &= ~BM_SD_OFF;\n\telse\n\t\treg_tmp |= BM_SD_OFF;\n\n\twriteb(reg_tmp, priv->sdmmc_base + SDMMC_BUSMODE);\n}\n\nstatic void wmt_mci_read_response(struct mmc_host *mmc)\n{\n\tstruct wmt_mci_priv *priv;\n\tint idx1, idx2;\n\tu8 tmp_resp;\n\tu32 response;\n\n\tpriv = mmc_priv(mmc);\n\n\tfor (idx1 = 0; idx1 < 4; idx1++) {\n\t\tresponse = 0;\n\t\tfor (idx2 = 0; idx2 < 4; idx2++) {\n\t\t\tif ((idx1 == 3) && (idx2 == 3))\n\t\t\t\ttmp_resp = readb(priv->sdmmc_base + SDMMC_RSP);\n\t\t\telse\n\t\t\t\ttmp_resp = readb(priv->sdmmc_base + SDMMC_RSP +\n\t\t\t\t\t\t (idx1*4) + idx2 + 1);\n\t\t\tresponse |= (tmp_resp << (idx2 * 8));\n\t\t}\n\t\tpriv->cmd->resp[idx1] = cpu_to_be32(response);\n\t}\n}\n\nstatic void wmt_mci_start_command(struct wmt_mci_priv *priv)\n{\n\tu32 reg_tmp;\n\n\treg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\n\twriteb(reg_tmp | CTLR_CMD_START, priv->sdmmc_base + SDMMC_CTLR);\n}\n\nstatic int wmt_mci_send_command(struct mmc_host *mmc, u8 command, u8 cmdtype,\n\t\t\t\tu32 arg, u8 rsptype)\n{\n\tstruct wmt_mci_priv *priv;\n\tu32 reg_tmp;\n\n\tpriv = mmc_priv(mmc);\n\n\t \n\twriteb(command, priv->sdmmc_base + SDMMC_CMD);\n\twritel(arg, priv->sdmmc_base + SDMMC_ARG);\n\twriteb(rsptype, priv->sdmmc_base + SDMMC_RSPTYPE);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\n\twriteb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);\n\n\t \n\twmt_set_sd_power(priv, WMT_SD_POWER_ON);\n\n\t \n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS2);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS3);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\n\twriteb((reg_tmp & 0x0F) | (cmdtype << 4),\n\t       priv->sdmmc_base + SDMMC_CTLR);\n\n\treturn 0;\n}\n\nstatic void wmt_mci_disable_dma(struct wmt_mci_priv *priv)\n{\n\twritel(DMA_ISR_INT_STS, priv->sdmmc_base + SDDMA_ISR);\n\twritel(0, priv->sdmmc_base + SDDMA_IER);\n}\n\nstatic void wmt_complete_data_request(struct wmt_mci_priv *priv)\n{\n\tstruct mmc_request *req;\n\treq = priv->req;\n\n\treq->data->bytes_xfered = req->data->blksz * req->data->blocks;\n\n\t \n\tif (req->data->flags & MMC_DATA_WRITE)\n\t\tdma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,\n\t\t\t     req->data->sg_len, DMA_TO_DEVICE);\n\telse\n\t\tdma_unmap_sg(mmc_dev(priv->mmc), req->data->sg,\n\t\t\t     req->data->sg_len, DMA_FROM_DEVICE);\n\n\t \n\tif ((req->cmd->error) || (req->data->error))\n\t\tmmc_request_done(priv->mmc, req);\n\telse {\n\t\twmt_mci_read_response(priv->mmc);\n\t\tif (!req->data->stop) {\n\t\t\t \n\t\t\tmmc_request_done(priv->mmc, req);\n\t\t} else {\n\t\t\t \n\t\t\tpriv->comp_cmd = &priv->cmdcomp;\n\t\t\tinit_completion(priv->comp_cmd);\n\t\t\tpriv->cmd = req->data->stop;\n\t\t\twmt_mci_send_command(priv->mmc, req->data->stop->opcode,\n\t\t\t\t\t     7, req->data->stop->arg, 9);\n\t\t\twmt_mci_start_command(priv);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t wmt_mci_dma_isr(int irq_num, void *data)\n{\n\tstruct wmt_mci_priv *priv;\n\n\tint status;\n\n\tpriv = (struct wmt_mci_priv *)data;\n\n\tstatus = readl(priv->sdmmc_base + SDDMA_CCR) & 0x0F;\n\n\tif (status != DMA_CCR_EVT_SUCCESS) {\n\t\tdev_err(priv->dev, \"DMA Error: Status = %d\\n\", status);\n\t\tpriv->req->data->error = -ETIMEDOUT;\n\t\tcomplete(priv->comp_dma);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tpriv->req->data->error = 0;\n\n\twmt_mci_disable_dma(priv);\n\n\tcomplete(priv->comp_dma);\n\n\tif (priv->comp_cmd) {\n\t\tif (completion_done(priv->comp_cmd)) {\n\t\t\t \n\t\t\twmt_complete_data_request(priv);\n\t\t}\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wmt_mci_regular_isr(int irq_num, void *data)\n{\n\tstruct wmt_mci_priv *priv;\n\tu32 status0;\n\tu32 status1;\n\tu32 status2;\n\tu32 reg_tmp;\n\tint cmd_done;\n\n\tpriv = (struct wmt_mci_priv *)data;\n\tcmd_done = 0;\n\tstatus0 = readb(priv->sdmmc_base + SDMMC_STS0);\n\tstatus1 = readb(priv->sdmmc_base + SDMMC_STS1);\n\tstatus2 = readb(priv->sdmmc_base + SDMMC_STS2);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);\n\tif ((reg_tmp & INT0_DI_INT_EN) && (status0 & STS0_DEVICE_INS)) {\n\t\tmmc_detect_change(priv->mmc, 0);\n\t\tif (priv->cmd)\n\t\t\tpriv->cmd->error = -ETIMEDOUT;\n\t\tif (priv->comp_cmd)\n\t\t\tcomplete(priv->comp_cmd);\n\t\tif (priv->comp_dma) {\n\t\t\twmt_mci_disable_dma(priv);\n\t\t\tcomplete(priv->comp_dma);\n\t\t}\n\t\twriteb(STS0_DEVICE_INS, priv->sdmmc_base + SDMMC_STS0);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif ((!priv->req->data) ||\n\t    ((priv->req->data->stop) && (priv->cmd == priv->req->data->stop))) {\n\t\t \n\t\tif (status1 & STS1_CMDRSP_DONE) {\n\t\t\tpriv->cmd->error = 0;\n\t\t\tcmd_done = 1;\n\t\t} else if ((status1 & STS1_RSP_TIMEOUT) ||\n\t\t\t   (status1 & STS1_DATA_TIMEOUT)) {\n\t\t\tpriv->cmd->error = -ETIMEDOUT;\n\t\t\tcmd_done = 1;\n\t\t}\n\n\t\tif (cmd_done) {\n\t\t\tpriv->comp_cmd = NULL;\n\n\t\t\tif (!priv->cmd->error)\n\t\t\t\twmt_mci_read_response(priv->mmc);\n\n\t\t\tpriv->cmd = NULL;\n\n\t\t\tmmc_request_done(priv->mmc, priv->req);\n\t\t}\n\t} else {\n\t\t \n\t\tif (status1 & STS1_CMDRSP_DONE) {\n\t\t\tif (priv->cmd)\n\t\t\t\tpriv->cmd->error = 0;\n\t\t\tif (priv->comp_cmd)\n\t\t\t\tcomplete(priv->comp_cmd);\n\t\t}\n\n\t\tif ((status1 & STS1_RSP_TIMEOUT) ||\n\t\t    (status1 & STS1_DATA_TIMEOUT)) {\n\t\t\tif (priv->cmd)\n\t\t\t\tpriv->cmd->error = -ETIMEDOUT;\n\t\t\tif (priv->comp_cmd)\n\t\t\t\tcomplete(priv->comp_cmd);\n\t\t\tif (priv->comp_dma) {\n\t\t\t\twmt_mci_disable_dma(priv);\n\t\t\t\tcomplete(priv->comp_dma);\n\t\t\t}\n\t\t}\n\n\t\tif (priv->comp_dma) {\n\t\t\t \n\t\t\tif (completion_done(priv->comp_dma))\n\t\t\t\twmt_complete_data_request(priv);\n\t\t}\n\t}\n\n\twriteb(status0, priv->sdmmc_base + SDMMC_STS0);\n\twriteb(status1, priv->sdmmc_base + SDMMC_STS1);\n\twriteb(status2, priv->sdmmc_base + SDMMC_STS2);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void wmt_reset_hardware(struct mmc_host *mmc)\n{\n\tstruct wmt_mci_priv *priv;\n\tu32 reg_tmp;\n\n\tpriv = mmc_priv(mmc);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\twriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_CTLR);\n\twriteb(reg_tmp | CTLR_FIFO_RESET, priv->sdmmc_base + SDMMC_CTLR);\n\n\t \n\twritew(BLKL_INT_ENABLE | BLKL_GPI_CD, priv->sdmmc_base + SDMMC_BLKLEN);\n\n\t \n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\n\n\t \n\twriteb(INT0_CD_INT_EN | INT0_DI_INT_EN, priv->sdmmc_base +\n\t       SDMMC_INTMASK0);\n\twriteb(INT1_DATA_TOUT_INT_EN | INT1_CMD_RES_TRAN_DONE_INT_EN |\n\t       INT1_CMD_RES_TOUT_INT_EN, priv->sdmmc_base + SDMMC_INTMASK1);\n\n\t \n\twritew(8191, priv->sdmmc_base + SDMMC_DMATIMEOUT);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_STS2);\n\twriteb(reg_tmp | STS2_DIS_FORCECLK, priv->sdmmc_base + SDMMC_STS2);\n\n\t \n\tclk_set_rate(priv->clk_sdmmc, 400000);\n}\n\nstatic int wmt_dma_init(struct mmc_host *mmc)\n{\n\tstruct wmt_mci_priv *priv;\n\n\tpriv = mmc_priv(mmc);\n\n\twritel(DMA_GCR_SOFT_RESET, priv->sdmmc_base + SDDMA_GCR);\n\twritel(DMA_GCR_DMA_EN, priv->sdmmc_base + SDDMA_GCR);\n\tif ((readl(priv->sdmmc_base + SDDMA_GCR) & DMA_GCR_DMA_EN) != 0)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\nstatic void wmt_dma_init_descriptor(struct wmt_dma_descriptor *desc,\n\t\tu16 req_count, u32 buffer_addr, u32 branch_addr, int end)\n{\n\tdesc->flags = 0x40000000 | req_count;\n\tif (end)\n\t\tdesc->flags |= 0x80000000;\n\tdesc->data_buffer_addr = buffer_addr;\n\tdesc->branch_addr = branch_addr;\n}\n\nstatic void wmt_dma_config(struct mmc_host *mmc, u32 descaddr, u8 dir)\n{\n\tstruct wmt_mci_priv *priv;\n\tu32 reg_tmp;\n\n\tpriv = mmc_priv(mmc);\n\n\t \n\twritel(DMA_IER_INT_EN, priv->sdmmc_base + SDDMA_IER);\n\n\t \n\twritel(descaddr, priv->sdmmc_base + SDDMA_DESPR);\n\n\twritel(0x00, priv->sdmmc_base + SDDMA_CCR);\n\n\tif (dir == PDMA_WRITE) {\n\t\treg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\n\t\twritel(reg_tmp & DMA_CCR_IF_TO_PERIPHERAL, priv->sdmmc_base +\n\t\t       SDDMA_CCR);\n\t} else {\n\t\treg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\n\t\twritel(reg_tmp | DMA_CCR_PERIPHERAL_TO_IF, priv->sdmmc_base +\n\t\t       SDDMA_CCR);\n\t}\n}\n\nstatic void wmt_dma_start(struct wmt_mci_priv *priv)\n{\n\tu32 reg_tmp;\n\n\treg_tmp = readl(priv->sdmmc_base + SDDMA_CCR);\n\twritel(reg_tmp | DMA_CCR_RUN, priv->sdmmc_base + SDDMA_CCR);\n}\n\nstatic void wmt_mci_request(struct mmc_host *mmc, struct mmc_request *req)\n{\n\tstruct wmt_mci_priv *priv;\n\tstruct wmt_dma_descriptor *desc;\n\tu8 command;\n\tu8 cmdtype;\n\tu32 arg;\n\tu8 rsptype;\n\tu32 reg_tmp;\n\n\tstruct scatterlist *sg;\n\tint i;\n\tint sg_cnt;\n\tint offset;\n\tu32 dma_address;\n\tint desc_cnt;\n\n\tpriv = mmc_priv(mmc);\n\tpriv->req = req;\n\n\t \n\tpriv->cmd = req->cmd;\n\n\tcommand = req->cmd->opcode;\n\targ = req->cmd->arg;\n\trsptype = mmc_resp_type(req->cmd);\n\tcmdtype = 0;\n\n\t \n\tif (rsptype == 7)\n\t\trsptype = 2;\n\t \n\tif (rsptype == 21)\n\t\trsptype = 9;\n\n\tif (!req->data) {\n\t\twmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);\n\t\twmt_mci_start_command(priv);\n\t\t \n\t}\n\tif (req->data) {\n\t\tpriv->comp_cmd = &priv->cmdcomp;\n\t\tinit_completion(priv->comp_cmd);\n\n\t\twmt_dma_init(mmc);\n\n\t\t \n\t\treg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\n\t\twritew((reg_tmp & 0xF800) | (req->data->blksz - 1),\n\t\t       priv->sdmmc_base + SDMMC_BLKLEN);\n\n\t\t \n\t\twritew(req->data->blocks, priv->sdmmc_base + SDMMC_BLKCNT);\n\n\t\tdesc = (struct wmt_dma_descriptor *)priv->dma_desc_buffer;\n\n\t\tif (req->data->flags & MMC_DATA_WRITE) {\n\t\t\tsg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,\n\t\t\t\t\t    req->data->sg_len, DMA_TO_DEVICE);\n\t\t\tcmdtype = 1;\n\t\t\tif (req->data->blocks > 1)\n\t\t\t\tcmdtype = 3;\n\t\t} else {\n\t\t\tsg_cnt = dma_map_sg(mmc_dev(mmc), req->data->sg,\n\t\t\t\t\t    req->data->sg_len, DMA_FROM_DEVICE);\n\t\t\tcmdtype = 2;\n\t\t\tif (req->data->blocks > 1)\n\t\t\t\tcmdtype = 4;\n\t\t}\n\n\t\tdma_address = priv->dma_desc_device_addr + 16;\n\t\tdesc_cnt = 0;\n\n\t\tfor_each_sg(req->data->sg, sg, sg_cnt, i) {\n\t\t\toffset = 0;\n\t\t\twhile (offset < sg_dma_len(sg)) {\n\t\t\t\twmt_dma_init_descriptor(desc, req->data->blksz,\n\t\t\t\t\t\tsg_dma_address(sg)+offset,\n\t\t\t\t\t\tdma_address, 0);\n\t\t\t\tdesc++;\n\t\t\t\tdesc_cnt++;\n\t\t\t\toffset += req->data->blksz;\n\t\t\t\tdma_address += 16;\n\t\t\t\tif (desc_cnt == req->data->blocks)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdesc--;\n\t\tdesc->flags |= 0x80000000;\n\n\t\tif (req->data->flags & MMC_DATA_WRITE)\n\t\t\twmt_dma_config(mmc, priv->dma_desc_device_addr,\n\t\t\t\t       PDMA_WRITE);\n\t\telse\n\t\t\twmt_dma_config(mmc, priv->dma_desc_device_addr,\n\t\t\t\t       PDMA_READ);\n\n\t\twmt_mci_send_command(mmc, command, cmdtype, arg, rsptype);\n\n\t\tpriv->comp_dma = &priv->datacomp;\n\t\tinit_completion(priv->comp_dma);\n\n\t\twmt_dma_start(priv);\n\t\twmt_mci_start_command(priv);\n\t}\n}\n\nstatic void wmt_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct wmt_mci_priv *priv;\n\tu32 busmode, extctrl;\n\n\tpriv = mmc_priv(mmc);\n\n\tif (ios->power_mode == MMC_POWER_UP) {\n\t\twmt_reset_hardware(mmc);\n\n\t\twmt_set_sd_power(priv, WMT_SD_POWER_ON);\n\t}\n\tif (ios->power_mode == MMC_POWER_OFF)\n\t\twmt_set_sd_power(priv, WMT_SD_POWER_OFF);\n\n\tif (ios->clock != 0)\n\t\tclk_set_rate(priv->clk_sdmmc, ios->clock);\n\n\tbusmode = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\textctrl = readb(priv->sdmmc_base + SDMMC_EXTCTRL);\n\n\tbusmode &= ~(BM_EIGHTBIT_MODE | BM_FOURBIT_MODE);\n\textctrl &= ~EXT_EIGHTBIT;\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_8:\n\t\tbusmode |= BM_EIGHTBIT_MODE;\n\t\textctrl |= EXT_EIGHTBIT;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tbusmode |= BM_FOURBIT_MODE;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_1:\n\t\tbreak;\n\t}\n\n\twriteb(busmode, priv->sdmmc_base + SDMMC_BUSMODE);\n\twriteb(extctrl, priv->sdmmc_base + SDMMC_EXTCTRL);\n}\n\nstatic int wmt_mci_get_ro(struct mmc_host *mmc)\n{\n\tstruct wmt_mci_priv *priv = mmc_priv(mmc);\n\n\treturn !(readb(priv->sdmmc_base + SDMMC_STS0) & STS0_WRITE_PROTECT);\n}\n\nstatic int wmt_mci_get_cd(struct mmc_host *mmc)\n{\n\tstruct wmt_mci_priv *priv = mmc_priv(mmc);\n\tu32 cd = (readb(priv->sdmmc_base + SDMMC_STS0) & STS0_CD_GPI) >> 3;\n\n\treturn !(cd ^ priv->cd_inverted);\n}\n\nstatic const struct mmc_host_ops wmt_mci_ops = {\n\t.request = wmt_mci_request,\n\t.set_ios = wmt_mci_set_ios,\n\t.get_ro = wmt_mci_get_ro,\n\t.get_cd = wmt_mci_get_cd,\n};\n\n \nstatic struct wmt_mci_caps wm8505_caps = {\n\t.f_min = 390425,\n\t.f_max = 50000000,\n\t.ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34,\n\t.caps = MMC_CAP_4_BIT_DATA | MMC_CAP_MMC_HIGHSPEED |\n\t\tMMC_CAP_SD_HIGHSPEED,\n\t.max_seg_size = 65024,\n\t.max_segs = 128,\n\t.max_blk_size = 2048,\n};\n\nstatic const struct of_device_id wmt_mci_dt_ids[] = {\n\t{ .compatible = \"wm,wm8505-sdhc\", .data = &wm8505_caps },\n\t{   },\n};\n\nstatic int wmt_mci_probe(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct wmt_mci_priv *priv;\n\tstruct device_node *np = pdev->dev.of_node;\n\tconst struct wmt_mci_caps *wmt_caps;\n\tint ret;\n\tint regular_irq, dma_irq;\n\n\twmt_caps = of_device_get_match_data(&pdev->dev);\n\tif (!wmt_caps) {\n\t\tdev_err(&pdev->dev, \"Controller capabilities data missing\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"Missing SDMMC description in devicetree\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tregular_irq = irq_of_parse_and_map(np, 0);\n\tdma_irq = irq_of_parse_and_map(np, 1);\n\n\tif (!regular_irq || !dma_irq) {\n\t\tdev_err(&pdev->dev, \"Getting IRQs failed!\\n\");\n\t\tret = -ENXIO;\n\t\tgoto fail1;\n\t}\n\n\tmmc = mmc_alloc_host(sizeof(struct wmt_mci_priv), &pdev->dev);\n\tif (!mmc) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate mmc_host\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tmmc->ops = &wmt_mci_ops;\n\tmmc->f_min = wmt_caps->f_min;\n\tmmc->f_max = wmt_caps->f_max;\n\tmmc->ocr_avail = wmt_caps->ocr_avail;\n\tmmc->caps = wmt_caps->caps;\n\n\tmmc->max_seg_size = wmt_caps->max_seg_size;\n\tmmc->max_segs = wmt_caps->max_segs;\n\tmmc->max_blk_size = wmt_caps->max_blk_size;\n\n\tmmc->max_req_size = (16*512*mmc->max_segs);\n\tmmc->max_blk_count = mmc->max_req_size / 512;\n\n\tpriv = mmc_priv(mmc);\n\tpriv->mmc = mmc;\n\tpriv->dev = &pdev->dev;\n\n\tpriv->power_inverted = 0;\n\tpriv->cd_inverted = 0;\n\n\tpriv->power_inverted = of_property_read_bool(np, \"sdon-inverted\");\n\tpriv->cd_inverted = of_property_read_bool(np, \"cd-inverted\");\n\n\tpriv->sdmmc_base = of_iomap(np, 0);\n\tif (!priv->sdmmc_base) {\n\t\tdev_err(&pdev->dev, \"Failed to map IO space\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail2;\n\t}\n\n\tpriv->irq_regular = regular_irq;\n\tpriv->irq_dma = dma_irq;\n\n\tret = request_irq(regular_irq, wmt_mci_regular_isr, 0, \"sdmmc\", priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Register regular IRQ fail\\n\");\n\t\tgoto fail3;\n\t}\n\n\tret = request_irq(dma_irq, wmt_mci_dma_isr, 0, \"sdmmc\", priv);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Register DMA IRQ fail\\n\");\n\t\tgoto fail4;\n\t}\n\n\t \n\tpriv->dma_desc_buffer = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t   mmc->max_blk_count * 16,\n\t\t\t\t\t\t   &priv->dma_desc_device_addr,\n\t\t\t\t\t\t   GFP_KERNEL);\n\tif (!priv->dma_desc_buffer) {\n\t\tdev_err(&pdev->dev, \"DMA alloc fail\\n\");\n\t\tret = -EPERM;\n\t\tgoto fail5;\n\t}\n\n\tplatform_set_drvdata(pdev, mmc);\n\n\tpriv->clk_sdmmc = of_clk_get(np, 0);\n\tif (IS_ERR(priv->clk_sdmmc)) {\n\t\tdev_err(&pdev->dev, \"Error getting clock\\n\");\n\t\tret = PTR_ERR(priv->clk_sdmmc);\n\t\tgoto fail5_and_a_half;\n\t}\n\n\tret = clk_prepare_enable(priv->clk_sdmmc);\n\tif (ret)\n\t\tgoto fail6;\n\n\t \n\twmt_reset_hardware(mmc);\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto fail7;\n\n\tdev_info(&pdev->dev, \"WMT SDHC Controller initialized\\n\");\n\n\treturn 0;\nfail7:\n\tclk_disable_unprepare(priv->clk_sdmmc);\nfail6:\n\tclk_put(priv->clk_sdmmc);\nfail5_and_a_half:\n\tdma_free_coherent(&pdev->dev, mmc->max_blk_count * 16,\n\t\t\t  priv->dma_desc_buffer, priv->dma_desc_device_addr);\nfail5:\n\tfree_irq(dma_irq, priv);\nfail4:\n\tfree_irq(regular_irq, priv);\nfail3:\n\tiounmap(priv->sdmmc_base);\nfail2:\n\tmmc_free_host(mmc);\nfail1:\n\treturn ret;\n}\n\nstatic void wmt_mci_remove(struct platform_device *pdev)\n{\n\tstruct mmc_host *mmc;\n\tstruct wmt_mci_priv *priv;\n\tstruct resource *res;\n\tu32 reg_tmp;\n\n\tmmc = platform_get_drvdata(pdev);\n\tpriv = mmc_priv(mmc);\n\n\t \n\treg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\twritel(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base + SDMMC_BUSMODE);\n\treg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\n\twritew(reg_tmp & ~(0xA000), priv->sdmmc_base + SDMMC_BLKLEN);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\n\n\t \n\tdma_free_coherent(&pdev->dev, priv->mmc->max_blk_count * 16,\n\t\t\t  priv->dma_desc_buffer, priv->dma_desc_device_addr);\n\n\tmmc_remove_host(mmc);\n\n\tfree_irq(priv->irq_regular, priv);\n\tfree_irq(priv->irq_dma, priv);\n\n\tiounmap(priv->sdmmc_base);\n\n\tclk_disable_unprepare(priv->clk_sdmmc);\n\tclk_put(priv->clk_sdmmc);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\trelease_mem_region(res->start, resource_size(res));\n\n\tmmc_free_host(mmc);\n\n\tdev_info(&pdev->dev, \"WMT MCI device removed\\n\");\n}\n\n#ifdef CONFIG_PM\nstatic int wmt_mci_suspend(struct device *dev)\n{\n\tu32 reg_tmp;\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct wmt_mci_priv *priv;\n\n\tif (!mmc)\n\t\treturn 0;\n\n\tpriv = mmc_priv(mmc);\n\treg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\twriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base +\n\t       SDMMC_BUSMODE);\n\n\treg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\n\twritew(reg_tmp & 0x5FFF, priv->sdmmc_base + SDMMC_BLKLEN);\n\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS0);\n\twriteb(0xFF, priv->sdmmc_base + SDMMC_STS1);\n\n\tclk_disable(priv->clk_sdmmc);\n\treturn 0;\n}\n\nstatic int wmt_mci_resume(struct device *dev)\n{\n\tu32 reg_tmp;\n\tstruct mmc_host *mmc = dev_get_drvdata(dev);\n\tstruct wmt_mci_priv *priv;\n\n\tif (mmc) {\n\t\tpriv = mmc_priv(mmc);\n\t\tclk_enable(priv->clk_sdmmc);\n\n\t\treg_tmp = readb(priv->sdmmc_base + SDMMC_BUSMODE);\n\t\twriteb(reg_tmp | BM_SOFT_RESET, priv->sdmmc_base +\n\t\t       SDMMC_BUSMODE);\n\n\t\treg_tmp = readw(priv->sdmmc_base + SDMMC_BLKLEN);\n\t\twritew(reg_tmp | (BLKL_GPI_CD | BLKL_INT_ENABLE),\n\t\t       priv->sdmmc_base + SDMMC_BLKLEN);\n\n\t\treg_tmp = readb(priv->sdmmc_base + SDMMC_INTMASK0);\n\t\twriteb(reg_tmp | INT0_DI_INT_EN, priv->sdmmc_base +\n\t\t       SDMMC_INTMASK0);\n\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops wmt_mci_pm = {\n\t.suspend        = wmt_mci_suspend,\n\t.resume         = wmt_mci_resume,\n};\n\n#define wmt_mci_pm_ops (&wmt_mci_pm)\n\n#else\t \n\n#define wmt_mci_pm_ops NULL\n\n#endif\n\nstatic struct platform_driver wmt_mci_driver = {\n\t.probe = wmt_mci_probe,\n\t.remove_new = wmt_mci_remove,\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.pm = wmt_mci_pm_ops,\n\t\t.of_match_table = wmt_mci_dt_ids,\n\t},\n};\n\nmodule_platform_driver(wmt_mci_driver);\n\nMODULE_DESCRIPTION(\"Wondermedia MMC/SD Driver\");\nMODULE_AUTHOR(\"Tony Prisk\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DEVICE_TABLE(of, wmt_mci_dt_ids);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}