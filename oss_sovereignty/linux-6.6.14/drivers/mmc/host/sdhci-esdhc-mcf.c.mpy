{
  "module_name": "sdhci-esdhc-mcf.c",
  "hash_id": "b8acef73ca1512c2902def21004d7cdc342ee795d906cd9c7adb5209b9a1a6fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-esdhc-mcf.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/platform_data/mmc-esdhc-mcf.h>\n#include <linux/mmc/mmc.h>\n#include \"sdhci-pltfm.h\"\n#include \"sdhci-esdhc.h\"\n\n#define\tESDHC_PROCTL_D3CD\t\t0x08\n#define ESDHC_SYS_CTRL_DTOCV_MASK\t0x0f\n#define ESDHC_DEFAULT_HOST_CONTROL\t0x28\n\n \n#define ESDHC_INT_VENDOR_SPEC_DMA_ERR\tBIT(28)\n\nstruct pltfm_mcf_data {\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_ahb;\n\tstruct clk *clk_per;\n\tint aside;\n\tint current_bus_width;\n};\n\nstatic inline void esdhc_mcf_buffer_swap32(u32 *buf, int len)\n{\n\tint i;\n\tu32 temp;\n\n\tlen = (len + 3) >> 2;\n\n\tfor (i = 0; i < len;  i++) {\n\t\ttemp = swab32(*buf);\n\t\t*buf++ = temp;\n\t}\n}\n\nstatic inline void esdhc_clrset_be(struct sdhci_host *host,\n\t\t\t\t   u32 mask, u32 val, int reg)\n{\n\tvoid __iomem *base = host->ioaddr + (reg & ~3);\n\tu8 shift = (reg & 3) << 3;\n\n\tmask <<= shift;\n\tval <<= shift;\n\n\tif (reg == SDHCI_HOST_CONTROL)\n\t\tval |= ESDHC_PROCTL_D3CD;\n\n\twritel((readl(base) & ~mask) | val, base);\n}\n\n \nstatic void esdhc_mcf_writeb_be(struct sdhci_host *host, u8 val, int reg)\n{\n\tvoid __iomem *base = host->ioaddr + (reg & ~3);\n\tu8 shift = (reg & 3) << 3;\n\tu32 mask = ~(0xff << shift);\n\n\tif (reg == SDHCI_HOST_CONTROL) {\n\t\tu32 host_ctrl = ESDHC_DEFAULT_HOST_CONTROL;\n\t\tu8 dma_bits = (val & SDHCI_CTRL_DMA_MASK) >> 3;\n\t\tu8 tmp = readb(host->ioaddr + SDHCI_HOST_CONTROL + 1);\n\n\t\ttmp &= ~0x03;\n\t\ttmp |= dma_bits;\n\n\t\t \n\t\thost_ctrl |= val;\n\t\thost_ctrl |= (dma_bits << 8);\n\t\twritel(host_ctrl, host->ioaddr + SDHCI_HOST_CONTROL);\n\n\t\treturn;\n\t}\n\n\twritel((readl(base) & mask) | (val << shift), base);\n}\n\nstatic void esdhc_mcf_writew_be(struct sdhci_host *host, u16 val, int reg)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_mcf_data *mcf_data = sdhci_pltfm_priv(pltfm_host);\n\tvoid __iomem *base = host->ioaddr + (reg & ~3);\n\tu8 shift = (reg & 3) << 3;\n\tu32 mask = ~(0xffff << shift);\n\n\tswitch (reg) {\n\tcase SDHCI_TRANSFER_MODE:\n\t\tmcf_data->aside = val;\n\t\treturn;\n\tcase SDHCI_COMMAND:\n\t\tif (host->cmd->opcode == MMC_STOP_TRANSMISSION)\n\t\t\tval |= SDHCI_CMD_ABORTCMD;\n\n\t\t \n\t\twritel(val << 16 | mcf_data->aside,\n\t\t       host->ioaddr + SDHCI_TRANSFER_MODE);\n\t\treturn;\n\t}\n\n\twritel((readl(base) & mask) | (val << shift), base);\n}\n\nstatic void esdhc_mcf_writel_be(struct sdhci_host *host, u32 val, int reg)\n{\n\twritel(val, host->ioaddr + reg);\n}\n\nstatic u8 esdhc_mcf_readb_be(struct sdhci_host *host, int reg)\n{\n\tif (reg == SDHCI_HOST_CONTROL) {\n\t\tu8 __iomem *base = host->ioaddr + (reg & ~3);\n\t\tu16 val = readw(base + 2);\n\t\tu8 dma_bits = (val >> 5) & SDHCI_CTRL_DMA_MASK;\n\t\tu8 host_ctrl = val & 0xff;\n\n\t\thost_ctrl &= ~SDHCI_CTRL_DMA_MASK;\n\t\thost_ctrl |= dma_bits;\n\n\t\treturn host_ctrl;\n\t}\n\n\treturn readb(host->ioaddr + (reg ^ 0x3));\n}\n\nstatic u16 esdhc_mcf_readw_be(struct sdhci_host *host, int reg)\n{\n\t \n\tif (reg == SDHCI_HOST_VERSION)\n\t\treg -= 2;\n\n\treturn readw(host->ioaddr + (reg ^ 0x2));\n}\n\nstatic u32 esdhc_mcf_readl_be(struct sdhci_host *host, int reg)\n{\n\tu32 val;\n\n\tval = readl(host->ioaddr + reg);\n\n\t \n\tif (unlikely(reg == SDHCI_CAPABILITIES))\n\t\tval &= ~SDHCI_CAN_DO_HISPD;\n\n\tif (unlikely(reg == SDHCI_INT_STATUS)) {\n\t\tif (val & ESDHC_INT_VENDOR_SPEC_DMA_ERR) {\n\t\t\tval &= ~ESDHC_INT_VENDOR_SPEC_DMA_ERR;\n\t\t\tval |= SDHCI_INT_ADMA_ERROR;\n\t\t}\n\t}\n\n\treturn val;\n}\n\nstatic unsigned int esdhc_mcf_get_max_timeout_count(struct sdhci_host *host)\n{\n\treturn 1 << 27;\n}\n\nstatic void esdhc_mcf_set_timeout(struct sdhci_host *host,\n\t\t\t\t  struct mmc_command *cmd)\n{\n\t \n\tesdhc_clrset_be(host, ESDHC_SYS_CTRL_DTOCV_MASK, 0xE,\n\t\t\tSDHCI_TIMEOUT_CONTROL);\n}\n\nstatic void esdhc_mcf_reset(struct sdhci_host *host, u8 mask)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_mcf_data *mcf_data = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_reset(host, mask);\n\n\tesdhc_clrset_be(host, ESDHC_CTRL_BUSWIDTH_MASK,\n\t\t\tmcf_data->current_bus_width, SDHCI_HOST_CONTROL);\n\n\tsdhci_writel(host, host->ier, SDHCI_INT_ENABLE);\n\tsdhci_writel(host, host->ier, SDHCI_SIGNAL_ENABLE);\n}\n\nstatic unsigned int esdhc_mcf_pltfm_get_max_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn pltfm_host->clock;\n}\n\nstatic unsigned int esdhc_mcf_pltfm_get_min_clock(struct sdhci_host *host)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\n\treturn pltfm_host->clock / 256 / 16;\n}\n\nstatic void esdhc_mcf_pltfm_set_clock(struct sdhci_host *host,\n\t\t\t\t      unsigned int clock)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tunsigned long *pll_dr = (unsigned long *)MCF_PLL_DR;\n\tu32 fvco, fsys, fesdhc, temp;\n\tconst int sdclkfs[] = {2, 4, 8, 16, 32, 64, 128, 256};\n\tint delta, old_delta = clock;\n\tint i, q, ri, rq;\n\n\tif (clock == 0) {\n\t\thost->mmc->actual_clock = 0;\n\t\treturn;\n\t}\n\n\t \n\ttemp = readl(pll_dr);\n\tfsys = pltfm_host->clock;\n\tfvco = fsys * ((temp & 0x1f) + 1);\n\tfesdhc = fvco / (((temp >> 10) & 0x1f) + 1);\n\n\tfor (i = 0; i < 8; ++i) {\n\t\tint result = fesdhc / sdclkfs[i];\n\n\t\tfor (q = 1; q < 17; ++q) {\n\t\t\tint finale = result / q;\n\n\t\t\tdelta = abs(clock - finale);\n\n\t\t\tif (delta < old_delta) {\n\t\t\t\told_delta = delta;\n\t\t\t\tri = i;\n\t\t\t\trq = q;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\ttemp = ((sdclkfs[ri] >> 1) << 8) | ((rq - 1) << 4) |\n\t\t(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN);\n\tesdhc_clrset_be(host, 0x0000fff7, temp, SDHCI_CLOCK_CONTROL);\n\n\thost->mmc->actual_clock = clock;\n\n\tmdelay(1);\n}\n\nstatic void esdhc_mcf_pltfm_set_bus_width(struct sdhci_host *host, int width)\n{\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_mcf_data *mcf_data = sdhci_pltfm_priv(pltfm_host);\n\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_4:\n\t\tmcf_data->current_bus_width = ESDHC_CTRL_4BITBUS;\n\t\tbreak;\n\tdefault:\n\t\tmcf_data->current_bus_width = 0;\n\t\tbreak;\n\t}\n\n\tesdhc_clrset_be(host, ESDHC_CTRL_BUSWIDTH_MASK,\n\t\t\tmcf_data->current_bus_width, SDHCI_HOST_CONTROL);\n}\n\nstatic void esdhc_mcf_request_done(struct sdhci_host *host,\n\t\t\t\t   struct mmc_request *mrq)\n{\n\tstruct scatterlist *sg;\n\tu32 *buffer;\n\tint i;\n\n\tif (!mrq->data || !mrq->data->bytes_xfered)\n\t\tgoto exit_done;\n\n\tif (mmc_get_dma_dir(mrq->data) != DMA_FROM_DEVICE)\n\t\tgoto exit_done;\n\n\t \n\tfor_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i) {\n\t\tbuffer = (u32 *)sg_virt(sg);\n\t\tesdhc_mcf_buffer_swap32(buffer, sg->length);\n\t}\n\nexit_done:\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void esdhc_mcf_copy_to_bounce_buffer(struct sdhci_host *host,\n\t\t\t\t\t    struct mmc_data *data,\n\t\t\t\t\t    unsigned int length)\n{\n\tsg_copy_to_buffer(data->sg, data->sg_len,\n\t\t\t  host->bounce_buffer, length);\n\n\tesdhc_mcf_buffer_swap32((u32 *)host->bounce_buffer,\n\t\t\t\tdata->blksz * data->blocks);\n}\n\nstatic struct sdhci_ops sdhci_esdhc_ops = {\n\t.reset = esdhc_mcf_reset,\n\t.set_clock = esdhc_mcf_pltfm_set_clock,\n\t.get_max_clock = esdhc_mcf_pltfm_get_max_clock,\n\t.get_min_clock = esdhc_mcf_pltfm_get_min_clock,\n\t.set_bus_width = esdhc_mcf_pltfm_set_bus_width,\n\t.get_max_timeout_count = esdhc_mcf_get_max_timeout_count,\n\t.set_timeout = esdhc_mcf_set_timeout,\n\t.write_b = esdhc_mcf_writeb_be,\n\t.write_w = esdhc_mcf_writew_be,\n\t.write_l = esdhc_mcf_writel_be,\n\t.read_b = esdhc_mcf_readb_be,\n\t.read_w = esdhc_mcf_readw_be,\n\t.read_l = esdhc_mcf_readl_be,\n\t.copy_to_bounce_buffer = esdhc_mcf_copy_to_bounce_buffer,\n\t.request_done = esdhc_mcf_request_done,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_esdhc_mcf_pdata = {\n\t.ops = &sdhci_esdhc_ops,\n\t.quirks = ESDHC_DEFAULT_QUIRKS | SDHCI_QUIRK_FORCE_DMA,\n\t\t  \n\t\t  SDHCI_QUIRK2_HOST_NO_CMD23,\n};\n\nstatic int esdhc_mcf_plat_init(struct sdhci_host *host,\n\t\t\t       struct pltfm_mcf_data *mcf_data)\n{\n\tstruct mcf_esdhc_platform_data *plat_data;\n\tstruct device *dev = mmc_dev(host->mmc);\n\n\tif (!dev->platform_data) {\n\t\tdev_err(dev, \"no platform data!\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tplat_data = (struct mcf_esdhc_platform_data *)dev->platform_data;\n\n\t \n\tswitch (plat_data->cd_type) {\n\tdefault:\n\tcase ESDHC_CD_CONTROLLER:\n\t\t \n\t\thost->quirks &= ~SDHCI_QUIRK_BROKEN_CARD_DETECTION;\n\t\tbreak;\n\tcase ESDHC_CD_PERMANENT:\n\t\thost->mmc->caps |= MMC_CAP_NONREMOVABLE;\n\t\tbreak;\n\tcase ESDHC_CD_NONE:\n\t\tbreak;\n\t}\n\n\tswitch (plat_data->max_bus_width) {\n\tcase 4:\n\t\thost->mmc->caps |= MMC_CAP_4_BIT_DATA;\n\t\tbreak;\n\tcase 1:\n\tdefault:\n\t\thost->quirks |= SDHCI_QUIRK_FORCE_1_BIT_DATA;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int sdhci_esdhc_mcf_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct pltfm_mcf_data *mcf_data;\n\tint err;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_esdhc_mcf_pdata,\n\t\t\t\tsizeof(*mcf_data));\n\n\tif (IS_ERR(host))\n\t\treturn PTR_ERR(host);\n\n\tpltfm_host = sdhci_priv(host);\n\tmcf_data = sdhci_pltfm_priv(pltfm_host);\n\n\thost->sdma_boundary = 0;\n\n\thost->flags |= SDHCI_AUTO_CMD12;\n\n\tmcf_data->clk_ipg = devm_clk_get(&pdev->dev, \"ipg\");\n\tif (IS_ERR(mcf_data->clk_ipg)) {\n\t\terr = PTR_ERR(mcf_data->clk_ipg);\n\t\tgoto err_exit;\n\t}\n\n\tmcf_data->clk_ahb = devm_clk_get(&pdev->dev, \"ahb\");\n\tif (IS_ERR(mcf_data->clk_ahb)) {\n\t\terr = PTR_ERR(mcf_data->clk_ahb);\n\t\tgoto err_exit;\n\t}\n\n\tmcf_data->clk_per = devm_clk_get(&pdev->dev, \"per\");\n\tif (IS_ERR(mcf_data->clk_per)) {\n\t\terr = PTR_ERR(mcf_data->clk_per);\n\t\tgoto err_exit;\n\t}\n\n\tpltfm_host->clk = mcf_data->clk_per;\n\tpltfm_host->clock = clk_get_rate(pltfm_host->clk);\n\terr = clk_prepare_enable(mcf_data->clk_per);\n\tif (err)\n\t\tgoto err_exit;\n\n\terr = clk_prepare_enable(mcf_data->clk_ipg);\n\tif (err)\n\t\tgoto unprep_per;\n\n\terr = clk_prepare_enable(mcf_data->clk_ahb);\n\tif (err)\n\t\tgoto unprep_ipg;\n\n\terr = esdhc_mcf_plat_init(host, mcf_data);\n\tif (err)\n\t\tgoto unprep_ahb;\n\n\terr = sdhci_setup_host(host);\n\tif (err)\n\t\tgoto unprep_ahb;\n\n\tif (!host->bounce_buffer) {\n\t\tdev_err(&pdev->dev, \"bounce buffer not allocated\");\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\n\terr = __sdhci_add_host(host);\n\tif (err)\n\t\tgoto cleanup;\n\n\treturn 0;\n\ncleanup:\n\tsdhci_cleanup_host(host);\nunprep_ahb:\n\tclk_disable_unprepare(mcf_data->clk_ahb);\nunprep_ipg:\n\tclk_disable_unprepare(mcf_data->clk_ipg);\nunprep_per:\n\tclk_disable_unprepare(mcf_data->clk_per);\nerr_exit:\n\tsdhci_pltfm_free(pdev);\n\n\treturn err;\n}\n\nstatic void sdhci_esdhc_mcf_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);\n\tstruct pltfm_mcf_data *mcf_data = sdhci_pltfm_priv(pltfm_host);\n\n\tsdhci_remove_host(host, 0);\n\n\tclk_disable_unprepare(mcf_data->clk_ipg);\n\tclk_disable_unprepare(mcf_data->clk_ahb);\n\tclk_disable_unprepare(mcf_data->clk_per);\n\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic struct platform_driver sdhci_esdhc_mcf_driver = {\n\t.driver\t= {\n\t\t.name = \"sdhci-esdhc-mcf\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n\t.probe = sdhci_esdhc_mcf_probe,\n\t.remove_new = sdhci_esdhc_mcf_remove,\n};\n\nmodule_platform_driver(sdhci_esdhc_mcf_driver);\n\nMODULE_DESCRIPTION(\"SDHCI driver for Freescale ColdFire eSDHC\");\nMODULE_AUTHOR(\"Angelo Dureghello <angelo.dureghello@timesys.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}