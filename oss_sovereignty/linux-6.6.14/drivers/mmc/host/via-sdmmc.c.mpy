{
  "module_name": "via-sdmmc.c",
  "hash_id": "5ca8baf9d90d6cbb06509c6df11df131c4bcc14d9020ef24ca2ad717804df915",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/via-sdmmc.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n#include <linux/highmem.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n\n#include <linux/mmc/host.h>\n\n#define DRV_NAME\t\"via_sdmmc\"\n\n#define PCI_DEVICE_ID_VIA_9530\t0x9530\n\n#define VIA_CRDR_SDC_OFF\t0x200\n#define VIA_CRDR_DDMA_OFF\t0x400\n#define VIA_CRDR_PCICTRL_OFF\t0x600\n\n#define VIA_CRDR_MIN_CLOCK\t375000\n#define VIA_CRDR_MAX_CLOCK\t48000000\n\n \n\n#define VIA_CRDR_PCI_WORK_MODE\t0x40\n#define VIA_CRDR_PCI_DBG_MODE\t0x41\n\n \n\n#define VIA_CRDR_SDCTRL\t\t\t0x0\n#define VIA_CRDR_SDCTRL_START\t\t0x01\n#define VIA_CRDR_SDCTRL_WRITE\t\t0x04\n#define VIA_CRDR_SDCTRL_SINGLE_WR\t0x10\n#define VIA_CRDR_SDCTRL_SINGLE_RD\t0x20\n#define VIA_CRDR_SDCTRL_MULTI_WR\t0x30\n#define VIA_CRDR_SDCTRL_MULTI_RD\t0x40\n#define VIA_CRDR_SDCTRL_STOP\t\t0x70\n\n#define VIA_CRDR_SDCTRL_RSP_NONE\t0x0\n#define VIA_CRDR_SDCTRL_RSP_R1\t\t0x10000\n#define VIA_CRDR_SDCTRL_RSP_R2\t\t0x20000\n#define VIA_CRDR_SDCTRL_RSP_R3\t\t0x30000\n#define VIA_CRDR_SDCTRL_RSP_R1B\t\t0x90000\n\n#define VIA_CRDR_SDCARG \t0x4\n\n#define VIA_CRDR_SDBUSMODE\t0x8\n#define VIA_CRDR_SDMODE_4BIT\t0x02\n#define VIA_CRDR_SDMODE_CLK_ON\t0x40\n\n#define VIA_CRDR_SDBLKLEN\t0xc\n \n#define VIA_CRDR_SDBLKLEN_GPIDET\t0x2000\n#define VIA_CRDR_SDBLKLEN_INTEN\t\t0x8000\n#define VIA_CRDR_MAX_BLOCK_COUNT\t65536\n#define VIA_CRDR_MAX_BLOCK_LENGTH\t2048\n\n#define VIA_CRDR_SDRESP0\t0x10\n#define VIA_CRDR_SDRESP1\t0x14\n#define VIA_CRDR_SDRESP2\t0x18\n#define VIA_CRDR_SDRESP3\t0x1c\n\n#define VIA_CRDR_SDCURBLKCNT\t0x20\n\n#define VIA_CRDR_SDINTMASK\t0x24\n \n#define VIA_CRDR_SDINTMASK_MBDIE\t0x10\n#define VIA_CRDR_SDINTMASK_BDDIE\t0x20\n#define VIA_CRDR_SDINTMASK_CIRIE\t0x80\n#define VIA_CRDR_SDINTMASK_CRDIE\t0x200\n#define VIA_CRDR_SDINTMASK_CRTOIE\t0x400\n#define VIA_CRDR_SDINTMASK_ASCRDIE\t0x800\n#define VIA_CRDR_SDINTMASK_DTIE\t\t0x1000\n#define VIA_CRDR_SDINTMASK_SCIE\t\t0x2000\n#define VIA_CRDR_SDINTMASK_RCIE\t\t0x4000\n#define VIA_CRDR_SDINTMASK_WCIE\t\t0x8000\n\n#define VIA_CRDR_SDACTIVE_INTMASK \\\n\t(VIA_CRDR_SDINTMASK_MBDIE | VIA_CRDR_SDINTMASK_CIRIE \\\n\t| VIA_CRDR_SDINTMASK_CRDIE | VIA_CRDR_SDINTMASK_CRTOIE \\\n\t| VIA_CRDR_SDINTMASK_DTIE | VIA_CRDR_SDINTMASK_SCIE \\\n\t| VIA_CRDR_SDINTMASK_RCIE | VIA_CRDR_SDINTMASK_WCIE)\n\n#define VIA_CRDR_SDSTATUS\t0x28\n \n#define VIA_CRDR_SDSTS_CECC\t\t0x01\n#define VIA_CRDR_SDSTS_WP\t\t0x02\n#define VIA_CRDR_SDSTS_SLOTD\t\t0x04\n#define VIA_CRDR_SDSTS_SLOTG\t\t0x08\n#define VIA_CRDR_SDSTS_MBD\t\t0x10\n#define VIA_CRDR_SDSTS_BDD\t\t0x20\n#define VIA_CRDR_SDSTS_CD\t\t0x40\n#define VIA_CRDR_SDSTS_CIR\t\t0x80\n#define VIA_CRDR_SDSTS_IO\t\t0x100\n#define VIA_CRDR_SDSTS_CRD\t\t0x200\n#define VIA_CRDR_SDSTS_CRTO\t\t0x400\n#define VIA_CRDR_SDSTS_ASCRDIE\t\t0x800\n#define VIA_CRDR_SDSTS_DT\t\t0x1000\n#define VIA_CRDR_SDSTS_SC\t\t0x2000\n#define VIA_CRDR_SDSTS_RC\t\t0x4000\n#define VIA_CRDR_SDSTS_WC\t\t0x8000\n\n#define VIA_CRDR_SDSTS_IGN_MASK\\\n\t(VIA_CRDR_SDSTS_BDD | VIA_CRDR_SDSTS_ASCRDIE | VIA_CRDR_SDSTS_IO)\n#define VIA_CRDR_SDSTS_INT_MASK \\\n\t(VIA_CRDR_SDSTS_MBD | VIA_CRDR_SDSTS_BDD | VIA_CRDR_SDSTS_CD \\\n\t| VIA_CRDR_SDSTS_CIR | VIA_CRDR_SDSTS_IO | VIA_CRDR_SDSTS_CRD \\\n\t| VIA_CRDR_SDSTS_CRTO | VIA_CRDR_SDSTS_ASCRDIE | VIA_CRDR_SDSTS_DT \\\n\t| VIA_CRDR_SDSTS_SC | VIA_CRDR_SDSTS_RC | VIA_CRDR_SDSTS_WC)\n#define VIA_CRDR_SDSTS_W1C_MASK \\\n\t(VIA_CRDR_SDSTS_CECC | VIA_CRDR_SDSTS_MBD | VIA_CRDR_SDSTS_BDD \\\n\t| VIA_CRDR_SDSTS_CD | VIA_CRDR_SDSTS_CIR | VIA_CRDR_SDSTS_CRD \\\n\t| VIA_CRDR_SDSTS_CRTO | VIA_CRDR_SDSTS_ASCRDIE | VIA_CRDR_SDSTS_DT \\\n\t| VIA_CRDR_SDSTS_SC | VIA_CRDR_SDSTS_RC | VIA_CRDR_SDSTS_WC)\n#define  VIA_CRDR_SDSTS_CMD_MASK \\\n\t(VIA_CRDR_SDSTS_CRD | VIA_CRDR_SDSTS_CRTO | VIA_CRDR_SDSTS_SC)\n#define  VIA_CRDR_SDSTS_DATA_MASK\\\n\t(VIA_CRDR_SDSTS_MBD | VIA_CRDR_SDSTS_DT \\\n\t| VIA_CRDR_SDSTS_RC | VIA_CRDR_SDSTS_WC)\n\n#define VIA_CRDR_SDSTATUS2\t0x2a\n \n#define VIA_CRDR_SDSTS_CFE\t\t0x80\n\n#define VIA_CRDR_SDRSPTMO\t0x2C\n\n#define VIA_CRDR_SDCLKSEL\t0x30\n\n#define VIA_CRDR_SDEXTCTRL\t0x34\n#define VIS_CRDR_SDEXTCTRL_AUTOSTOP_SD\t0x01\n#define VIS_CRDR_SDEXTCTRL_SHIFT_9\t0x02\n#define VIS_CRDR_SDEXTCTRL_MMC_8BIT\t0x04\n#define VIS_CRDR_SDEXTCTRL_RELD_BLK\t0x08\n#define VIS_CRDR_SDEXTCTRL_BAD_CMDA\t0x10\n#define VIS_CRDR_SDEXTCTRL_BAD_DATA\t0x20\n#define VIS_CRDR_SDEXTCTRL_AUTOSTOP_SPI\t0x40\n#define VIA_CRDR_SDEXTCTRL_HISPD\t0x80\n \n\n \n\n#define VIA_CRDR_DMABASEADD\t0x0\n#define VIA_CRDR_DMACOUNTER\t0x4\n\n#define VIA_CRDR_DMACTRL\t0x8\n \n#define VIA_CRDR_DMACTRL_DIR\t\t0x100\n#define VIA_CRDR_DMACTRL_ENIRQ\t\t0x10000\n#define VIA_CRDR_DMACTRL_SFTRST\t\t0x1000000\n\n#define VIA_CRDR_DMASTS\t\t0xc\n\n#define VIA_CRDR_DMASTART\t0x10\n \n\n \n\n \n#define VIA_CRDR_PCICLKGATT\t0x2\n \n#define VIA_CRDR_PCICLKGATT_SFTRST\t0x01\n \n#define VIA_CRDR_PCICLKGATT_3V3\t0x10\n \n#define VIA_CRDR_PCICLKGATT_PAD_PWRON\t0x20\n\n#define VIA_CRDR_PCISDCCLK\t0x5\n\n#define VIA_CRDR_PCIDMACLK\t0x7\n#define VIA_CRDR_PCIDMACLK_SDC\t\t0x2\n\n#define VIA_CRDR_PCIINTCTRL\t0x8\n#define VIA_CRDR_PCIINTCTRL_SDCIRQEN\t0x04\n\n#define VIA_CRDR_PCIINTSTATUS\t0x9\n#define VIA_CRDR_PCIINTSTATUS_SDC\t0x04\n\n#define  VIA_CRDR_PCITMOCTRL\t0xa\n#define VIA_CRDR_PCITMOCTRL_NO\t\t0x0\n#define VIA_CRDR_PCITMOCTRL_32US\t0x1\n#define VIA_CRDR_PCITMOCTRL_256US\t0x2\n#define VIA_CRDR_PCITMOCTRL_1024US\t0x3\n#define VIA_CRDR_PCITMOCTRL_256MS\t0x4\n#define VIA_CRDR_PCITMOCTRL_512MS\t0x5\n#define VIA_CRDR_PCITMOCTRL_1024MS\t0x6\n\n \n\nenum PCI_HOST_CLK_CONTROL {\n\tPCI_CLK_375K = 0x03,\n\tPCI_CLK_8M = 0x04,\n\tPCI_CLK_12M = 0x00,\n\tPCI_CLK_16M = 0x05,\n\tPCI_CLK_24M = 0x01,\n\tPCI_CLK_33M = 0x06,\n\tPCI_CLK_48M = 0x02\n};\n\nstruct sdhcreg {\n\tu32 sdcontrol_reg;\n\tu32 sdcmdarg_reg;\n\tu32 sdbusmode_reg;\n\tu32 sdblklen_reg;\n\tu32 sdresp_reg[4];\n\tu32 sdcurblkcnt_reg;\n\tu32 sdintmask_reg;\n\tu32 sdstatus_reg;\n\tu32 sdrsptmo_reg;\n\tu32 sdclksel_reg;\n\tu32 sdextctrl_reg;\n};\n\nstruct pcictrlreg {\n\tu8 reserve[2];\n\tu8 pciclkgat_reg;\n\tu8 pcinfcclk_reg;\n\tu8 pcimscclk_reg;\n\tu8 pcisdclk_reg;\n\tu8 pcicaclk_reg;\n\tu8 pcidmaclk_reg;\n\tu8 pciintctrl_reg;\n\tu8 pciintstatus_reg;\n\tu8 pcitmoctrl_reg;\n\tu8 Resv;\n};\n\nstruct via_crdr_mmc_host {\n\tstruct mmc_host *mmc;\n\tstruct mmc_request *mrq;\n\tstruct mmc_command *cmd;\n\tstruct mmc_data *data;\n\n\tvoid __iomem *mmiobase;\n\tvoid __iomem *sdhc_mmiobase;\n\tvoid __iomem *ddma_mmiobase;\n\tvoid __iomem *pcictrl_mmiobase;\n\n\tstruct pcictrlreg pm_pcictrl_reg;\n\tstruct sdhcreg pm_sdhc_reg;\n\n\tstruct work_struct carddet_work;\n\tstruct tasklet_struct finish_tasklet;\n\n\tstruct timer_list timer;\n\tspinlock_t lock;\n\tu8 power;\n\tint reject;\n\tunsigned int quirks;\n};\n\n \n#define VIA_CRDR_QUIRK_300MS_PWRDELAY\t0x0001\n\n#define VIA_CMD_TIMEOUT_MS\t\t1000\n\nstatic const struct pci_device_id via_ids[] = {\n\t{PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_9530,\n\t  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0,},\n\t{0,}\n};\n\nMODULE_DEVICE_TABLE(pci, via_ids);\n\nstatic void via_print_sdchc(struct via_crdr_mmc_host *host)\n{\n\tvoid __iomem *addrbase = host->sdhc_mmiobase;\n\n\tpr_debug(\"SDC MMIO Registers:\\n\");\n\tpr_debug(\"SDCONTROL=%08x, SDCMDARG=%08x, SDBUSMODE=%08x\\n\",\n\t\t readl(addrbase + VIA_CRDR_SDCTRL),\n\t\t readl(addrbase + VIA_CRDR_SDCARG),\n\t\t readl(addrbase + VIA_CRDR_SDBUSMODE));\n\tpr_debug(\"SDBLKLEN=%08x, SDCURBLKCNT=%08x, SDINTMASK=%08x\\n\",\n\t\t readl(addrbase + VIA_CRDR_SDBLKLEN),\n\t\t readl(addrbase + VIA_CRDR_SDCURBLKCNT),\n\t\t readl(addrbase + VIA_CRDR_SDINTMASK));\n\tpr_debug(\"SDSTATUS=%08x, SDCLKSEL=%08x, SDEXTCTRL=%08x\\n\",\n\t\t readl(addrbase + VIA_CRDR_SDSTATUS),\n\t\t readl(addrbase + VIA_CRDR_SDCLKSEL),\n\t\t readl(addrbase + VIA_CRDR_SDEXTCTRL));\n}\n\nstatic void via_print_pcictrl(struct via_crdr_mmc_host *host)\n{\n\tvoid __iomem *addrbase = host->pcictrl_mmiobase;\n\n\tpr_debug(\"PCI Control Registers:\\n\");\n\tpr_debug(\"PCICLKGATT=%02x, PCISDCCLK=%02x, PCIDMACLK=%02x\\n\",\n\t\t readb(addrbase + VIA_CRDR_PCICLKGATT),\n\t\t readb(addrbase + VIA_CRDR_PCISDCCLK),\n\t\t readb(addrbase + VIA_CRDR_PCIDMACLK));\n\tpr_debug(\"PCIINTCTRL=%02x, PCIINTSTATUS=%02x\\n\",\n\t\t readb(addrbase + VIA_CRDR_PCIINTCTRL),\n\t\t readb(addrbase + VIA_CRDR_PCIINTSTATUS));\n}\n\nstatic void via_save_pcictrlreg(struct via_crdr_mmc_host *host)\n{\n\tstruct pcictrlreg *pm_pcictrl_reg;\n\tvoid __iomem *addrbase;\n\n\tpm_pcictrl_reg = &(host->pm_pcictrl_reg);\n\taddrbase = host->pcictrl_mmiobase;\n\n\tpm_pcictrl_reg->pciclkgat_reg = readb(addrbase + VIA_CRDR_PCICLKGATT);\n\tpm_pcictrl_reg->pciclkgat_reg |=\n\t\tVIA_CRDR_PCICLKGATT_3V3 | VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\tpm_pcictrl_reg->pcisdclk_reg = readb(addrbase + VIA_CRDR_PCISDCCLK);\n\tpm_pcictrl_reg->pcidmaclk_reg = readb(addrbase + VIA_CRDR_PCIDMACLK);\n\tpm_pcictrl_reg->pciintctrl_reg = readb(addrbase + VIA_CRDR_PCIINTCTRL);\n\tpm_pcictrl_reg->pciintstatus_reg =\n\t\treadb(addrbase + VIA_CRDR_PCIINTSTATUS);\n\tpm_pcictrl_reg->pcitmoctrl_reg = readb(addrbase + VIA_CRDR_PCITMOCTRL);\n}\n\nstatic void via_restore_pcictrlreg(struct via_crdr_mmc_host *host)\n{\n\tstruct pcictrlreg *pm_pcictrl_reg;\n\tvoid __iomem *addrbase;\n\n\tpm_pcictrl_reg = &(host->pm_pcictrl_reg);\n\taddrbase = host->pcictrl_mmiobase;\n\n\twriteb(pm_pcictrl_reg->pciclkgat_reg, addrbase + VIA_CRDR_PCICLKGATT);\n\twriteb(pm_pcictrl_reg->pcisdclk_reg, addrbase + VIA_CRDR_PCISDCCLK);\n\twriteb(pm_pcictrl_reg->pcidmaclk_reg, addrbase + VIA_CRDR_PCIDMACLK);\n\twriteb(pm_pcictrl_reg->pciintctrl_reg, addrbase + VIA_CRDR_PCIINTCTRL);\n\twriteb(pm_pcictrl_reg->pciintstatus_reg,\n\t\taddrbase + VIA_CRDR_PCIINTSTATUS);\n\twriteb(pm_pcictrl_reg->pcitmoctrl_reg, addrbase + VIA_CRDR_PCITMOCTRL);\n}\n\nstatic void via_save_sdcreg(struct via_crdr_mmc_host *host)\n{\n\tstruct sdhcreg *pm_sdhc_reg;\n\tvoid __iomem *addrbase;\n\n\tpm_sdhc_reg = &(host->pm_sdhc_reg);\n\taddrbase = host->sdhc_mmiobase;\n\n\tpm_sdhc_reg->sdcontrol_reg = readl(addrbase + VIA_CRDR_SDCTRL);\n\tpm_sdhc_reg->sdcmdarg_reg = readl(addrbase + VIA_CRDR_SDCARG);\n\tpm_sdhc_reg->sdbusmode_reg = readl(addrbase + VIA_CRDR_SDBUSMODE);\n\tpm_sdhc_reg->sdblklen_reg = readl(addrbase + VIA_CRDR_SDBLKLEN);\n\tpm_sdhc_reg->sdcurblkcnt_reg = readl(addrbase + VIA_CRDR_SDCURBLKCNT);\n\tpm_sdhc_reg->sdintmask_reg = readl(addrbase + VIA_CRDR_SDINTMASK);\n\tpm_sdhc_reg->sdstatus_reg = readl(addrbase + VIA_CRDR_SDSTATUS);\n\tpm_sdhc_reg->sdrsptmo_reg = readl(addrbase + VIA_CRDR_SDRSPTMO);\n\tpm_sdhc_reg->sdclksel_reg = readl(addrbase + VIA_CRDR_SDCLKSEL);\n\tpm_sdhc_reg->sdextctrl_reg = readl(addrbase + VIA_CRDR_SDEXTCTRL);\n}\n\nstatic void via_restore_sdcreg(struct via_crdr_mmc_host *host)\n{\n\tstruct sdhcreg *pm_sdhc_reg;\n\tvoid __iomem *addrbase;\n\n\tpm_sdhc_reg = &(host->pm_sdhc_reg);\n\taddrbase = host->sdhc_mmiobase;\n\n\twritel(pm_sdhc_reg->sdcontrol_reg, addrbase + VIA_CRDR_SDCTRL);\n\twritel(pm_sdhc_reg->sdcmdarg_reg, addrbase + VIA_CRDR_SDCARG);\n\twritel(pm_sdhc_reg->sdbusmode_reg, addrbase + VIA_CRDR_SDBUSMODE);\n\twritel(pm_sdhc_reg->sdblklen_reg, addrbase + VIA_CRDR_SDBLKLEN);\n\twritel(pm_sdhc_reg->sdcurblkcnt_reg, addrbase + VIA_CRDR_SDCURBLKCNT);\n\twritel(pm_sdhc_reg->sdintmask_reg, addrbase + VIA_CRDR_SDINTMASK);\n\twritel(pm_sdhc_reg->sdstatus_reg, addrbase + VIA_CRDR_SDSTATUS);\n\twritel(pm_sdhc_reg->sdrsptmo_reg, addrbase + VIA_CRDR_SDRSPTMO);\n\twritel(pm_sdhc_reg->sdclksel_reg, addrbase + VIA_CRDR_SDCLKSEL);\n\twritel(pm_sdhc_reg->sdextctrl_reg, addrbase + VIA_CRDR_SDEXTCTRL);\n}\n\nstatic void via_pwron_sleep(struct via_crdr_mmc_host *sdhost)\n{\n\tif (sdhost->quirks & VIA_CRDR_QUIRK_300MS_PWRDELAY)\n\t\tmsleep(300);\n\telse\n\t\tmsleep(3);\n}\n\nstatic void via_set_ddma(struct via_crdr_mmc_host *host,\n\t\t\t dma_addr_t dmaaddr, u32 count, int dir, int enirq)\n{\n\tvoid __iomem *addrbase;\n\tu32 ctrl_data = 0;\n\n\tif (enirq)\n\t\tctrl_data |= VIA_CRDR_DMACTRL_ENIRQ;\n\n\tif (dir)\n\t\tctrl_data |= VIA_CRDR_DMACTRL_DIR;\n\n\taddrbase = host->ddma_mmiobase;\n\n\twritel(dmaaddr, addrbase + VIA_CRDR_DMABASEADD);\n\twritel(count, addrbase + VIA_CRDR_DMACOUNTER);\n\twritel(ctrl_data, addrbase + VIA_CRDR_DMACTRL);\n\twritel(0x01, addrbase + VIA_CRDR_DMASTART);\n\n\t \n\t \n\taddrbase = host->pcictrl_mmiobase;\n\tif (readb(addrbase + VIA_CRDR_PCISDCCLK) == PCI_CLK_375K) {\n\t\tdev_info(host->mmc->parent, \"forcing card speed to 8MHz\\n\");\n\t\twriteb(PCI_CLK_8M, addrbase + VIA_CRDR_PCISDCCLK);\n\t}\n}\n\nstatic void via_sdc_preparedata(struct via_crdr_mmc_host *host,\n\t\t\t\tstruct mmc_data *data)\n{\n\tvoid __iomem *addrbase;\n\tu32 blk_reg;\n\tint count;\n\n\tWARN_ON(host->data);\n\n\t \n\tBUG_ON(data->blksz > host->mmc->max_blk_size);\n\tBUG_ON(data->blocks > host->mmc->max_blk_count);\n\n\thost->data = data;\n\n\tcount = dma_map_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t((data->flags & MMC_DATA_READ) ?\n\t\tDMA_FROM_DEVICE : DMA_TO_DEVICE));\n\tBUG_ON(count != 1);\n\n\tvia_set_ddma(host, sg_dma_address(data->sg), sg_dma_len(data->sg),\n\t\t(data->flags & MMC_DATA_WRITE) ? 1 : 0, 1);\n\n\taddrbase = host->sdhc_mmiobase;\n\n\tblk_reg = data->blksz - 1;\n\tblk_reg |= VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\n\tblk_reg |= (data->blocks) << 16;\n\n\twritel(blk_reg, addrbase + VIA_CRDR_SDBLKLEN);\n}\n\nstatic void via_sdc_get_response(struct via_crdr_mmc_host *host,\n\t\t\t\t struct mmc_command *cmd)\n{\n\tvoid __iomem *addrbase = host->sdhc_mmiobase;\n\tu32 dwdata0 = readl(addrbase + VIA_CRDR_SDRESP0);\n\tu32 dwdata1 = readl(addrbase + VIA_CRDR_SDRESP1);\n\tu32 dwdata2 = readl(addrbase + VIA_CRDR_SDRESP2);\n\tu32 dwdata3 = readl(addrbase + VIA_CRDR_SDRESP3);\n\n\tif (cmd->flags & MMC_RSP_136) {\n\t\tcmd->resp[0] = ((u8) (dwdata1)) |\n\t\t    (((u8) (dwdata0 >> 24)) << 8) |\n\t\t    (((u8) (dwdata0 >> 16)) << 16) |\n\t\t    (((u8) (dwdata0 >> 8)) << 24);\n\n\t\tcmd->resp[1] = ((u8) (dwdata2)) |\n\t\t    (((u8) (dwdata1 >> 24)) << 8) |\n\t\t    (((u8) (dwdata1 >> 16)) << 16) |\n\t\t    (((u8) (dwdata1 >> 8)) << 24);\n\n\t\tcmd->resp[2] = ((u8) (dwdata3)) |\n\t\t    (((u8) (dwdata2 >> 24)) << 8) |\n\t\t    (((u8) (dwdata2 >> 16)) << 16) |\n\t\t    (((u8) (dwdata2 >> 8)) << 24);\n\n\t\tcmd->resp[3] = 0xff |\n\t\t    ((((u8) (dwdata3 >> 24))) << 8) |\n\t\t    (((u8) (dwdata3 >> 16)) << 16) |\n\t\t    (((u8) (dwdata3 >> 8)) << 24);\n\t} else {\n\t\tdwdata0 >>= 8;\n\t\tcmd->resp[0] = ((dwdata0 & 0xff) << 24) |\n\t\t    (((dwdata0 >> 8) & 0xff) << 16) |\n\t\t    (((dwdata0 >> 16) & 0xff) << 8) | (dwdata1 & 0xff);\n\n\t\tdwdata1 >>= 8;\n\t\tcmd->resp[1] = ((dwdata1 & 0xff) << 24) |\n\t\t    (((dwdata1 >> 8) & 0xff) << 16) |\n\t\t    (((dwdata1 >> 16) & 0xff) << 8);\n\t}\n}\n\nstatic void via_sdc_send_command(struct via_crdr_mmc_host *host,\n\t\t\t\t struct mmc_command *cmd)\n{\n\tvoid __iomem *addrbase;\n\tstruct mmc_data *data;\n\tunsigned int timeout_ms;\n\tu32 cmdctrl = 0;\n\n\tWARN_ON(host->cmd);\n\n\tdata = cmd->data;\n\thost->cmd = cmd;\n\n\ttimeout_ms = cmd->busy_timeout ? cmd->busy_timeout : VIA_CMD_TIMEOUT_MS;\n\tmod_timer(&host->timer, jiffies + msecs_to_jiffies(timeout_ms));\n\n\t \n\tcmdctrl = cmd->opcode << 8;\n\n\t \n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_RSP_NONE;\n\t\tbreak;\n\tcase MMC_RSP_R1:\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_RSP_R1;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_RSP_R1B;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_RSP_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_RSP_R3;\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: cmd->flag is not valid\\n\", mmc_hostname(host->mmc));\n\t\tbreak;\n\t}\n\n\tif (!(cmd->data))\n\t\tgoto nodata;\n\n\tvia_sdc_preparedata(host, data);\n\n\t \n\tif (data->blocks > 1) {\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_WRITE;\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_MULTI_WR;\n\t\t} else {\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_MULTI_RD;\n\t\t}\n\t} else {\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_WRITE;\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_SINGLE_WR;\n\t\t} else {\n\t\t\tcmdctrl |= VIA_CRDR_SDCTRL_SINGLE_RD;\n\t\t}\n\t}\n\nnodata:\n\tif (cmd == host->mrq->stop)\n\t\tcmdctrl |= VIA_CRDR_SDCTRL_STOP;\n\n\tcmdctrl |= VIA_CRDR_SDCTRL_START;\n\n\taddrbase = host->sdhc_mmiobase;\n\twritel(cmd->arg, addrbase + VIA_CRDR_SDCARG);\n\twritel(cmdctrl, addrbase + VIA_CRDR_SDCTRL);\n}\n\nstatic void via_sdc_finish_data(struct via_crdr_mmc_host *host)\n{\n\tstruct mmc_data *data;\n\n\tBUG_ON(!host->data);\n\n\tdata = host->data;\n\thost->data = NULL;\n\n\tif (data->error)\n\t\tdata->bytes_xfered = 0;\n\telse\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\n\tdma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len,\n\t\t((data->flags & MMC_DATA_READ) ?\n\t\tDMA_FROM_DEVICE : DMA_TO_DEVICE));\n\n\tif (data->stop)\n\t\tvia_sdc_send_command(host, data->stop);\n\telse\n\t\ttasklet_schedule(&host->finish_tasklet);\n}\n\nstatic void via_sdc_finish_command(struct via_crdr_mmc_host *host)\n{\n\tvia_sdc_get_response(host, host->cmd);\n\n\thost->cmd->error = 0;\n\n\tif (!host->cmd->data)\n\t\ttasklet_schedule(&host->finish_tasklet);\n\n\thost->cmd = NULL;\n}\n\nstatic void via_sdc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tvoid __iomem *addrbase;\n\tstruct via_crdr_mmc_host *host;\n\tunsigned long flags;\n\tu16 status;\n\n\thost = mmc_priv(mmc);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\taddrbase = host->pcictrl_mmiobase;\n\twriteb(VIA_CRDR_PCIDMACLK_SDC, addrbase + VIA_CRDR_PCIDMACLK);\n\n\tstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\n\tstatus &= VIA_CRDR_SDSTS_W1C_MASK;\n\twritew(status, host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\n\n\tWARN_ON(host->mrq != NULL);\n\thost->mrq = mrq;\n\n\tstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\n\tif (!(status & VIA_CRDR_SDSTS_SLOTG) || host->reject) {\n\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\ttasklet_schedule(&host->finish_tasklet);\n\t} else {\n\t\tvia_sdc_send_command(host, mrq->cmd);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void via_sdc_set_power(struct via_crdr_mmc_host *host,\n\t\t\t      unsigned short power, unsigned int on)\n{\n\tunsigned long flags;\n\tu8 gatt;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\thost->power = (1 << power);\n\n\tgatt = readb(host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tif (host->power == MMC_VDD_165_195)\n\t\tgatt &= ~VIA_CRDR_PCICLKGATT_3V3;\n\telse\n\t\tgatt |= VIA_CRDR_PCICLKGATT_3V3;\n\tif (on)\n\t\tgatt |= VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\telse\n\t\tgatt &= ~VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\twriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tvia_pwron_sleep(host);\n}\n\nstatic void via_sdc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct via_crdr_mmc_host *host;\n\tunsigned long flags;\n\tvoid __iomem *addrbase;\n\tu32 org_data, sdextctrl;\n\tu8 clock;\n\n\thost = mmc_priv(mmc);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\taddrbase = host->sdhc_mmiobase;\n\torg_data = readl(addrbase + VIA_CRDR_SDBUSMODE);\n\tsdextctrl = readl(addrbase + VIA_CRDR_SDEXTCTRL);\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_1)\n\t\torg_data &= ~VIA_CRDR_SDMODE_4BIT;\n\telse\n\t\torg_data |= VIA_CRDR_SDMODE_4BIT;\n\n\tif (ios->power_mode == MMC_POWER_OFF)\n\t\torg_data &= ~VIA_CRDR_SDMODE_CLK_ON;\n\telse\n\t\torg_data |= VIA_CRDR_SDMODE_CLK_ON;\n\n\tif (ios->timing == MMC_TIMING_SD_HS)\n\t\tsdextctrl |= VIA_CRDR_SDEXTCTRL_HISPD;\n\telse\n\t\tsdextctrl &= ~VIA_CRDR_SDEXTCTRL_HISPD;\n\n\twritel(org_data, addrbase + VIA_CRDR_SDBUSMODE);\n\twritel(sdextctrl, addrbase + VIA_CRDR_SDEXTCTRL);\n\n\tif (ios->clock >= 48000000)\n\t\tclock = PCI_CLK_48M;\n\telse if (ios->clock >= 33000000)\n\t\tclock = PCI_CLK_33M;\n\telse if (ios->clock >= 24000000)\n\t\tclock = PCI_CLK_24M;\n\telse if (ios->clock >= 16000000)\n\t\tclock = PCI_CLK_16M;\n\telse if (ios->clock >= 12000000)\n\t\tclock = PCI_CLK_12M;\n\telse if (ios->clock >=  8000000)\n\t\tclock = PCI_CLK_8M;\n\telse\n\t\tclock = PCI_CLK_375K;\n\n\taddrbase = host->pcictrl_mmiobase;\n\tif (readb(addrbase + VIA_CRDR_PCISDCCLK) != clock)\n\t\twriteb(clock, addrbase + VIA_CRDR_PCISDCCLK);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tif (ios->power_mode != MMC_POWER_OFF)\n\t\tvia_sdc_set_power(host, ios->vdd, 1);\n\telse\n\t\tvia_sdc_set_power(host, ios->vdd, 0);\n}\n\nstatic int via_sdc_get_ro(struct mmc_host *mmc)\n{\n\tstruct via_crdr_mmc_host *host;\n\tunsigned long flags;\n\tu16 status;\n\n\thost = mmc_priv(mmc);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tstatus = readw(host->sdhc_mmiobase + VIA_CRDR_SDSTATUS);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn !(status & VIA_CRDR_SDSTS_WP);\n}\n\nstatic const struct mmc_host_ops via_sdc_ops = {\n\t.request = via_sdc_request,\n\t.set_ios = via_sdc_set_ios,\n\t.get_ro = via_sdc_get_ro,\n};\n\nstatic void via_reset_pcictrl(struct via_crdr_mmc_host *host)\n{\n\tunsigned long flags;\n\tu8 gatt;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tvia_save_pcictrlreg(host);\n\tvia_save_sdcreg(host);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tgatt = VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\tif (host->power == MMC_VDD_165_195)\n\t\tgatt &= VIA_CRDR_PCICLKGATT_3V3;\n\telse\n\t\tgatt |= VIA_CRDR_PCICLKGATT_3V3;\n\twriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tvia_pwron_sleep(host);\n\tgatt |= VIA_CRDR_PCICLKGATT_SFTRST;\n\twriteb(gatt, host->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tmsleep(3);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tvia_restore_pcictrlreg(host);\n\tvia_restore_sdcreg(host);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void via_sdc_cmd_isr(struct via_crdr_mmc_host *host, u16 intmask)\n{\n\tBUG_ON(intmask == 0);\n\n\tif (!host->cmd) {\n\t\tpr_err(\"%s: Got command interrupt 0x%x even \"\n\t\t       \"though no command operation was in progress.\\n\",\n\t\t       mmc_hostname(host->mmc), intmask);\n\t\treturn;\n\t}\n\n\tif (intmask & VIA_CRDR_SDSTS_CRTO)\n\t\thost->cmd->error = -ETIMEDOUT;\n\telse if (intmask & VIA_CRDR_SDSTS_SC)\n\t\thost->cmd->error = -EILSEQ;\n\n\tif (host->cmd->error)\n\t\ttasklet_schedule(&host->finish_tasklet);\n\telse if (intmask & VIA_CRDR_SDSTS_CRD)\n\t\tvia_sdc_finish_command(host);\n}\n\nstatic void via_sdc_data_isr(struct via_crdr_mmc_host *host, u16 intmask)\n{\n\tBUG_ON(intmask == 0);\n\n\tif (!host->data)\n\t\treturn;\n\n\tif (intmask & VIA_CRDR_SDSTS_DT)\n\t\thost->data->error = -ETIMEDOUT;\n\telse if (intmask & (VIA_CRDR_SDSTS_RC | VIA_CRDR_SDSTS_WC))\n\t\thost->data->error = -EILSEQ;\n\n\tvia_sdc_finish_data(host);\n}\n\nstatic irqreturn_t via_sdc_isr(int irq, void *dev_id)\n{\n\tstruct via_crdr_mmc_host *sdhost = dev_id;\n\tvoid __iomem *addrbase;\n\tu8 pci_status;\n\tu16 sd_status;\n\tirqreturn_t result;\n\n\tif (!sdhost)\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&sdhost->lock);\n\n\taddrbase = sdhost->pcictrl_mmiobase;\n\tpci_status = readb(addrbase + VIA_CRDR_PCIINTSTATUS);\n\tif (!(pci_status & VIA_CRDR_PCIINTSTATUS_SDC)) {\n\t\tresult = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\taddrbase = sdhost->sdhc_mmiobase;\n\tsd_status = readw(addrbase + VIA_CRDR_SDSTATUS);\n\tsd_status &= VIA_CRDR_SDSTS_INT_MASK;\n\tsd_status &= ~VIA_CRDR_SDSTS_IGN_MASK;\n\tif (!sd_status) {\n\t\tresult = IRQ_NONE;\n\t\tgoto out;\n\t}\n\n\tif (sd_status & VIA_CRDR_SDSTS_CIR) {\n\t\twritew(sd_status & VIA_CRDR_SDSTS_CIR,\n\t\t\taddrbase + VIA_CRDR_SDSTATUS);\n\n\t\tschedule_work(&sdhost->carddet_work);\n\t}\n\n\tsd_status &= ~VIA_CRDR_SDSTS_CIR;\n\tif (sd_status & VIA_CRDR_SDSTS_CMD_MASK) {\n\t\twritew(sd_status & VIA_CRDR_SDSTS_CMD_MASK,\n\t\t\taddrbase + VIA_CRDR_SDSTATUS);\n\t\tvia_sdc_cmd_isr(sdhost, sd_status & VIA_CRDR_SDSTS_CMD_MASK);\n\t}\n\tif (sd_status & VIA_CRDR_SDSTS_DATA_MASK) {\n\t\twritew(sd_status & VIA_CRDR_SDSTS_DATA_MASK,\n\t\t\taddrbase + VIA_CRDR_SDSTATUS);\n\t\tvia_sdc_data_isr(sdhost, sd_status & VIA_CRDR_SDSTS_DATA_MASK);\n\t}\n\n\tsd_status &= ~(VIA_CRDR_SDSTS_CMD_MASK | VIA_CRDR_SDSTS_DATA_MASK);\n\tif (sd_status) {\n\t\tpr_err(\"%s: Unexpected interrupt 0x%x\\n\",\n\t\t       mmc_hostname(sdhost->mmc), sd_status);\n\t\twritew(sd_status, addrbase + VIA_CRDR_SDSTATUS);\n\t}\n\n\tresult = IRQ_HANDLED;\n\nout:\n\tspin_unlock(&sdhost->lock);\n\n\treturn result;\n}\n\nstatic void via_sdc_timeout(struct timer_list *t)\n{\n\tstruct via_crdr_mmc_host *sdhost;\n\tunsigned long flags;\n\n\tsdhost = from_timer(sdhost, t, timer);\n\n\tspin_lock_irqsave(&sdhost->lock, flags);\n\n\tif (sdhost->mrq) {\n\t\tpr_err(\"%s: Timeout waiting for hardware interrupt.\"\n\t\t       \"cmd:0x%x\\n\", mmc_hostname(sdhost->mmc),\n\t\t       sdhost->mrq->cmd->opcode);\n\n\t\tif (sdhost->data) {\n\t\t\twritel(VIA_CRDR_DMACTRL_SFTRST,\n\t\t\t\tsdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);\n\t\t\tsdhost->data->error = -ETIMEDOUT;\n\t\t\tvia_sdc_finish_data(sdhost);\n\t\t} else {\n\t\t\tif (sdhost->cmd)\n\t\t\t\tsdhost->cmd->error = -ETIMEDOUT;\n\t\t\telse\n\t\t\t\tsdhost->mrq->cmd->error = -ETIMEDOUT;\n\t\t\ttasklet_schedule(&sdhost->finish_tasklet);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&sdhost->lock, flags);\n}\n\nstatic void via_sdc_tasklet_finish(struct tasklet_struct *t)\n{\n\tstruct via_crdr_mmc_host *host = from_tasklet(host, t, finish_tasklet);\n\tunsigned long flags;\n\tstruct mmc_request *mrq;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tdel_timer(&host->timer);\n\tmrq = host->mrq;\n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic void via_sdc_card_detect(struct work_struct *work)\n{\n\tstruct via_crdr_mmc_host *host;\n\tvoid __iomem *addrbase;\n\tunsigned long flags;\n\tu16 status;\n\n\thost = container_of(work, struct via_crdr_mmc_host, carddet_work);\n\n\taddrbase = host->ddma_mmiobase;\n\twritel(VIA_CRDR_DMACTRL_SFTRST, addrbase + VIA_CRDR_DMACTRL);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\taddrbase = host->pcictrl_mmiobase;\n\twriteb(VIA_CRDR_PCIDMACLK_SDC, addrbase + VIA_CRDR_PCIDMACLK);\n\n\taddrbase = host->sdhc_mmiobase;\n\tstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\n\tif (!(status & VIA_CRDR_SDSTS_SLOTG)) {\n\t\tif (host->mrq) {\n\t\t\tpr_err(\"%s: Card removed during transfer!\\n\",\n\t\t\t       mmc_hostname(host->mmc));\n\t\t\thost->mrq->cmd->error = -ENOMEDIUM;\n\t\t\ttasklet_schedule(&host->finish_tasklet);\n\t\t}\n\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\n\t\tvia_reset_pcictrl(host);\n\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tvia_print_pcictrl(host);\n\tvia_print_sdchc(host);\n\n\tmmc_detect_change(host->mmc, msecs_to_jiffies(500));\n}\n\nstatic void via_init_mmc_host(struct via_crdr_mmc_host *host)\n{\n\tstruct mmc_host *mmc = host->mmc;\n\tvoid __iomem *addrbase;\n\tu32 lenreg;\n\tu32 status;\n\n\ttimer_setup(&host->timer, via_sdc_timeout, 0);\n\n\tspin_lock_init(&host->lock);\n\n\tmmc->f_min = VIA_CRDR_MIN_CLOCK;\n\tmmc->f_max = VIA_CRDR_MAX_CLOCK;\n\tmmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;\n\tmmc->caps = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED;\n\tmmc->ops = &via_sdc_ops;\n\n\t \n\tmmc->max_segs = 1;\n\n\tmmc->max_blk_size = VIA_CRDR_MAX_BLOCK_LENGTH;\n\tmmc->max_blk_count = VIA_CRDR_MAX_BLOCK_COUNT;\n\n\tmmc->max_seg_size = mmc->max_blk_size * mmc->max_blk_count;\n\tmmc->max_req_size = mmc->max_seg_size;\n\n\tINIT_WORK(&host->carddet_work, via_sdc_card_detect);\n\n\ttasklet_setup(&host->finish_tasklet, via_sdc_tasklet_finish);\n\n\taddrbase = host->sdhc_mmiobase;\n\twritel(0x0, addrbase + VIA_CRDR_SDINTMASK);\n\tmsleep(1);\n\n\tlenreg = VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\n\twritel(lenreg, addrbase + VIA_CRDR_SDBLKLEN);\n\n\tstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\n\tstatus &= VIA_CRDR_SDSTS_W1C_MASK;\n\twritew(status, addrbase + VIA_CRDR_SDSTATUS);\n\n\tstatus = readw(addrbase + VIA_CRDR_SDSTATUS2);\n\tstatus |= VIA_CRDR_SDSTS_CFE;\n\twritew(status, addrbase + VIA_CRDR_SDSTATUS2);\n\n\twriteb(0x0, addrbase + VIA_CRDR_SDEXTCTRL);\n\n\twritel(VIA_CRDR_SDACTIVE_INTMASK, addrbase + VIA_CRDR_SDINTMASK);\n\tmsleep(1);\n}\n\nstatic int via_sd_probe(struct pci_dev *pcidev,\n\t\t\t\t    const struct pci_device_id *id)\n{\n\tstruct mmc_host *mmc;\n\tstruct via_crdr_mmc_host *sdhost;\n\tu32 base, len;\n\tu8  gatt;\n\tint ret;\n\n\tpr_info(DRV_NAME\n\t\t\": VIA SDMMC controller found at %s [%04x:%04x] (rev %x)\\n\",\n\t\tpci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device,\n\t\t(int)pcidev->revision);\n\n\tret = pci_enable_device(pcidev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_request_regions(pcidev, DRV_NAME);\n\tif (ret)\n\t\tgoto disable;\n\n\tpci_write_config_byte(pcidev, VIA_CRDR_PCI_WORK_MODE, 0);\n\tpci_write_config_byte(pcidev, VIA_CRDR_PCI_DBG_MODE, 0);\n\n\tmmc = mmc_alloc_host(sizeof(struct via_crdr_mmc_host), &pcidev->dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\tsdhost = mmc_priv(mmc);\n\tsdhost->mmc = mmc;\n\tdev_set_drvdata(&pcidev->dev, sdhost);\n\n\tlen = pci_resource_len(pcidev, 0);\n\tbase = pci_resource_start(pcidev, 0);\n\tsdhost->mmiobase = ioremap(base, len);\n\tif (!sdhost->mmiobase) {\n\t\tret = -ENOMEM;\n\t\tgoto free_mmc_host;\n\t}\n\n\tsdhost->sdhc_mmiobase =\n\t\tsdhost->mmiobase + VIA_CRDR_SDC_OFF;\n\tsdhost->ddma_mmiobase =\n\t\tsdhost->mmiobase + VIA_CRDR_DDMA_OFF;\n\tsdhost->pcictrl_mmiobase =\n\t\tsdhost->mmiobase + VIA_CRDR_PCICTRL_OFF;\n\n\tsdhost->power = MMC_VDD_165_195;\n\n\tgatt = VIA_CRDR_PCICLKGATT_3V3 | VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\twriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tvia_pwron_sleep(sdhost);\n\tgatt |= VIA_CRDR_PCICLKGATT_SFTRST;\n\twriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tmsleep(3);\n\n\tvia_init_mmc_host(sdhost);\n\n\tret =\n\t    request_irq(pcidev->irq, via_sdc_isr, IRQF_SHARED, DRV_NAME,\n\t\t\tsdhost);\n\tif (ret)\n\t\tgoto unmap;\n\n\twriteb(VIA_CRDR_PCIINTCTRL_SDCIRQEN,\n\t       sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);\n\twriteb(VIA_CRDR_PCITMOCTRL_1024MS,\n\t       sdhost->pcictrl_mmiobase + VIA_CRDR_PCITMOCTRL);\n\n\t \n\tif (pcidev->subsystem_vendor == PCI_VENDOR_ID_LENOVO &&\n\t    pcidev->subsystem_device == 0x3891)\n\t\tsdhost->quirks = VIA_CRDR_QUIRK_300MS_PWRDELAY;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto unmap;\n\n\treturn 0;\n\nunmap:\n\tiounmap(sdhost->mmiobase);\nfree_mmc_host:\n\tmmc_free_host(mmc);\nrelease:\n\tpci_release_regions(pcidev);\ndisable:\n\tpci_disable_device(pcidev);\n\n\treturn ret;\n}\n\nstatic void via_sd_remove(struct pci_dev *pcidev)\n{\n\tstruct via_crdr_mmc_host *sdhost = pci_get_drvdata(pcidev);\n\tunsigned long flags;\n\tu8 gatt;\n\n\tspin_lock_irqsave(&sdhost->lock, flags);\n\n\t \n\tsdhost->reject = 1;\n\n\t \n\twriteb(0x0, sdhost->pcictrl_mmiobase + VIA_CRDR_PCIINTCTRL);\n\n\tif (sdhost->mrq) {\n\t\tpr_err(\"%s: Controller removed during \"\n\t\t\t\"transfer\\n\", mmc_hostname(sdhost->mmc));\n\n\t\t \n\t\twritel(VIA_CRDR_DMACTRL_SFTRST,\n\t\t\tsdhost->ddma_mmiobase + VIA_CRDR_DMACTRL);\n\t\tsdhost->mrq->cmd->error = -ENOMEDIUM;\n\t\tif (sdhost->mrq->stop)\n\t\t\tsdhost->mrq->stop->error = -ENOMEDIUM;\n\t\ttasklet_schedule(&sdhost->finish_tasklet);\n\t}\n\tspin_unlock_irqrestore(&sdhost->lock, flags);\n\n\tmmc_remove_host(sdhost->mmc);\n\n\tfree_irq(pcidev->irq, sdhost);\n\n\tdel_timer_sync(&sdhost->timer);\n\n\ttasklet_kill(&sdhost->finish_tasklet);\n\n\t \n\tgatt = readb(sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tgatt &= ~VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\twriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\n\tiounmap(sdhost->mmiobase);\n\tmmc_free_host(sdhost->mmc);\n\tpci_release_regions(pcidev);\n\tpci_disable_device(pcidev);\n\n\tpr_info(DRV_NAME\n\t\t\": VIA SDMMC controller at %s [%04x:%04x] has been removed\\n\",\n\t\tpci_name(pcidev), (int)pcidev->vendor, (int)pcidev->device);\n}\n\nstatic void __maybe_unused via_init_sdc_pm(struct via_crdr_mmc_host *host)\n{\n\tstruct sdhcreg *pm_sdhcreg;\n\tvoid __iomem *addrbase;\n\tu32 lenreg;\n\tu16 status;\n\n\tpm_sdhcreg = &(host->pm_sdhc_reg);\n\taddrbase = host->sdhc_mmiobase;\n\n\twritel(0x0, addrbase + VIA_CRDR_SDINTMASK);\n\n\tlenreg = VIA_CRDR_SDBLKLEN_GPIDET | VIA_CRDR_SDBLKLEN_INTEN;\n\twritel(lenreg, addrbase + VIA_CRDR_SDBLKLEN);\n\n\tstatus = readw(addrbase + VIA_CRDR_SDSTATUS);\n\tstatus &= VIA_CRDR_SDSTS_W1C_MASK;\n\twritew(status, addrbase + VIA_CRDR_SDSTATUS);\n\n\tstatus = readw(addrbase + VIA_CRDR_SDSTATUS2);\n\tstatus |= VIA_CRDR_SDSTS_CFE;\n\twritew(status, addrbase + VIA_CRDR_SDSTATUS2);\n\n\twritel(pm_sdhcreg->sdcontrol_reg, addrbase + VIA_CRDR_SDCTRL);\n\twritel(pm_sdhcreg->sdcmdarg_reg, addrbase + VIA_CRDR_SDCARG);\n\twritel(pm_sdhcreg->sdintmask_reg, addrbase + VIA_CRDR_SDINTMASK);\n\twritel(pm_sdhcreg->sdrsptmo_reg, addrbase + VIA_CRDR_SDRSPTMO);\n\twritel(pm_sdhcreg->sdclksel_reg, addrbase + VIA_CRDR_SDCLKSEL);\n\twritel(pm_sdhcreg->sdextctrl_reg, addrbase + VIA_CRDR_SDEXTCTRL);\n\n\tvia_print_pcictrl(host);\n\tvia_print_sdchc(host);\n}\n\nstatic int __maybe_unused via_sd_suspend(struct device *dev)\n{\n\tstruct via_crdr_mmc_host *host;\n\tunsigned long flags;\n\n\thost = dev_get_drvdata(dev);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tvia_save_pcictrlreg(host);\n\tvia_save_sdcreg(host);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\tdevice_wakeup_enable(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused via_sd_resume(struct device *dev)\n{\n\tstruct via_crdr_mmc_host *sdhost;\n\tu8 gatt;\n\n\tsdhost = dev_get_drvdata(dev);\n\n\tgatt = VIA_CRDR_PCICLKGATT_PAD_PWRON;\n\tif (sdhost->power == MMC_VDD_165_195)\n\t\tgatt &= ~VIA_CRDR_PCICLKGATT_3V3;\n\telse\n\t\tgatt |= VIA_CRDR_PCICLKGATT_3V3;\n\twriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tvia_pwron_sleep(sdhost);\n\tgatt |= VIA_CRDR_PCICLKGATT_SFTRST;\n\twriteb(gatt, sdhost->pcictrl_mmiobase + VIA_CRDR_PCICLKGATT);\n\tmsleep(3);\n\n\tmsleep(100);\n\n\tvia_restore_pcictrlreg(sdhost);\n\tvia_init_sdc_pm(sdhost);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(via_sd_pm_ops, via_sd_suspend, via_sd_resume);\n\nstatic struct pci_driver via_sd_driver = {\n\t.name = DRV_NAME,\n\t.id_table = via_ids,\n\t.probe = via_sd_probe,\n\t.remove = via_sd_remove,\n\t.driver.pm = &via_sd_pm_ops,\n};\n\nmodule_pci_driver(via_sd_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"VIA Technologies Inc.\");\nMODULE_DESCRIPTION(\"VIA SD/MMC Card Interface driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}