{
  "module_name": "vub300.c",
  "hash_id": "32025bd834492f007e99b1d3bdc711585f94940463f0d4c887feb2cee55bdec3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/vub300.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/workqueue.h>\n#include <linux/ctype.h>\n#include <linux/firmware.h>\n#include <linux/scatterlist.h>\n\nstruct host_controller_info {\n\tu8 info_size;\n\tu16 firmware_version;\n\tu8 number_of_ports;\n} __packed;\n\n#define FIRMWARE_BLOCK_BOUNDARY 1024\nstruct sd_command_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu8 command_type;  \n\tu8 command_index;\n\tu8 transfer_size[4];  \n\tu8 response_type;\n\tu8 arguments[4];\n\tu8 block_count[2];\n\tu8 block_size[2];\n\tu8 block_boundary[2];\n\tu8 reserved[44];  \n} __packed;\n\nstruct sd_irqpoll_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu8 command_type;  \n\tu8 padding[16];  \n\tu8 poll_timeout_msb;\n\tu8 poll_timeout_lsb;\n\tu8 reserved[42];  \n} __packed;\n\nstruct sd_common_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n} __packed;\n\nstruct sd_response_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu8 command_type;\n\tu8 command_index;\n\tu8 command_response[];\n} __packed;\n\nstruct sd_status_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu16 port_flags;\n\tu32 sdio_clock;\n\tu16 host_header_size;\n\tu16 func_header_size;\n\tu16 ctrl_header_size;\n} __packed;\n\nstruct sd_error_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu8 error_code;\n} __packed;\n\nstruct sd_interrupt_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n} __packed;\n\nstruct offload_registers_access {\n\tu8 command_byte[4];\n\tu8 Respond_Byte[4];\n} __packed;\n\n#define INTERRUPT_REGISTER_ACCESSES 15\nstruct sd_offloaded_interrupt {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tstruct offload_registers_access reg[INTERRUPT_REGISTER_ACCESSES];\n} __packed;\n\nstruct sd_register_header {\n\tu8 header_size;\n\tu8 header_type;\n\tu8 port_number;\n\tu8 command_type;\n\tu8 command_index;\n\tu8 command_response[6];\n} __packed;\n\n#define PIGGYBACK_REGISTER_ACCESSES 14\nstruct sd_offloaded_piggyback {\n\tstruct sd_register_header sdio;\n\tstruct offload_registers_access reg[PIGGYBACK_REGISTER_ACCESSES];\n} __packed;\n\nunion sd_response {\n\tstruct sd_common_header common;\n\tstruct sd_status_header status;\n\tstruct sd_error_header error;\n\tstruct sd_interrupt_header interrupt;\n\tstruct sd_response_header response;\n\tstruct sd_offloaded_interrupt irq;\n\tstruct sd_offloaded_piggyback pig;\n} __packed;\n\nunion sd_command {\n\tstruct sd_command_header head;\n\tstruct sd_irqpoll_header poll;\n} __packed;\n\nenum SD_RESPONSE_TYPE {\n\tSDRT_UNSPECIFIED = 0,\n\tSDRT_NONE,\n\tSDRT_1,\n\tSDRT_1B,\n\tSDRT_2,\n\tSDRT_3,\n\tSDRT_4,\n\tSDRT_5,\n\tSDRT_5B,\n\tSDRT_6,\n\tSDRT_7,\n};\n\n#define RESPONSE_INTERRUPT\t\t\t0x01\n#define RESPONSE_ERROR\t\t\t\t0x02\n#define RESPONSE_STATUS\t\t\t\t0x03\n#define RESPONSE_IRQ_DISABLED\t\t\t0x05\n#define RESPONSE_IRQ_ENABLED\t\t\t0x06\n#define RESPONSE_PIGGYBACKED\t\t\t0x07\n#define RESPONSE_NO_INTERRUPT\t\t\t0x08\n#define RESPONSE_PIG_DISABLED\t\t\t0x09\n#define RESPONSE_PIG_ENABLED\t\t\t0x0A\n#define SD_ERROR_1BIT_TIMEOUT\t\t\t0x01\n#define SD_ERROR_4BIT_TIMEOUT\t\t\t0x02\n#define SD_ERROR_1BIT_CRC_WRONG\t\t\t0x03\n#define SD_ERROR_4BIT_CRC_WRONG\t\t\t0x04\n#define SD_ERROR_1BIT_CRC_ERROR\t\t\t0x05\n#define SD_ERROR_4BIT_CRC_ERROR\t\t\t0x06\n#define SD_ERROR_NO_CMD_ENDBIT\t\t\t0x07\n#define SD_ERROR_NO_1BIT_DATEND\t\t\t0x08\n#define SD_ERROR_NO_4BIT_DATEND\t\t\t0x09\n#define SD_ERROR_1BIT_UNEXPECTED_TIMEOUT\t0x0A\n#define SD_ERROR_4BIT_UNEXPECTED_TIMEOUT\t0x0B\n#define SD_ERROR_ILLEGAL_COMMAND\t\t0x0C\n#define SD_ERROR_NO_DEVICE\t\t\t0x0D\n#define SD_ERROR_TRANSFER_LENGTH\t\t0x0E\n#define SD_ERROR_1BIT_DATA_TIMEOUT\t\t0x0F\n#define SD_ERROR_4BIT_DATA_TIMEOUT\t\t0x10\n#define SD_ERROR_ILLEGAL_STATE\t\t\t0x11\n#define SD_ERROR_UNKNOWN_ERROR\t\t\t0x12\n#define SD_ERROR_RESERVED_ERROR\t\t\t0x13\n#define SD_ERROR_INVALID_FUNCTION\t\t0x14\n#define SD_ERROR_OUT_OF_RANGE\t\t\t0x15\n#define SD_ERROR_STAT_CMD\t\t\t0x16\n#define SD_ERROR_STAT_DATA\t\t\t0x17\n#define SD_ERROR_STAT_CMD_TIMEOUT\t\t0x18\n#define SD_ERROR_SDCRDY_STUCK\t\t\t0x19\n#define SD_ERROR_UNHANDLED\t\t\t0x1A\n#define SD_ERROR_OVERRUN\t\t\t0x1B\n#define SD_ERROR_PIO_TIMEOUT\t\t\t0x1C\n\n#define FUN(c) (0x000007 & (c->arg>>28))\n#define REG(c) (0x01FFFF & (c->arg>>9))\n\nstatic bool limit_speed_to_24_MHz;\nmodule_param(limit_speed_to_24_MHz, bool, 0644);\nMODULE_PARM_DESC(limit_speed_to_24_MHz, \"Limit Max SDIO Clock Speed to 24 MHz\");\n\nstatic bool pad_input_to_usb_pkt;\nmodule_param(pad_input_to_usb_pkt, bool, 0644);\nMODULE_PARM_DESC(pad_input_to_usb_pkt,\n\t\t \"Pad USB data input transfers to whole USB Packet\");\n\nstatic bool disable_offload_processing;\nmodule_param(disable_offload_processing, bool, 0644);\nMODULE_PARM_DESC(disable_offload_processing, \"Disable Offload Processing\");\n\nstatic bool force_1_bit_data_xfers;\nmodule_param(force_1_bit_data_xfers, bool, 0644);\nMODULE_PARM_DESC(force_1_bit_data_xfers,\n\t\t \"Force SDIO Data Transfers to 1-bit Mode\");\n\nstatic bool force_polling_for_irqs;\nmodule_param(force_polling_for_irqs, bool, 0644);\nMODULE_PARM_DESC(force_polling_for_irqs, \"Force Polling for SDIO interrupts\");\n\nstatic int firmware_irqpoll_timeout = 1024;\nmodule_param(firmware_irqpoll_timeout, int, 0644);\nMODULE_PARM_DESC(firmware_irqpoll_timeout, \"VUB300 firmware irqpoll timeout\");\n\nstatic int force_max_req_size = 128;\nmodule_param(force_max_req_size, int, 0644);\nMODULE_PARM_DESC(force_max_req_size, \"set max request size in kBytes\");\n\n#ifdef SMSC_DEVELOPMENT_BOARD\nstatic int firmware_rom_wait_states = 0x04;\n#else\nstatic int firmware_rom_wait_states = 0x1C;\n#endif\n\nmodule_param(firmware_rom_wait_states, int, 0644);\nMODULE_PARM_DESC(firmware_rom_wait_states,\n\t\t \"ROM wait states byte=RRRIIEEE (Reserved Internal External)\");\n\n#define ELAN_VENDOR_ID\t\t0x2201\n#define VUB300_VENDOR_ID\t0x0424\n#define VUB300_PRODUCT_ID\t0x012C\nstatic const struct usb_device_id vub300_table[] = {\n\t{USB_DEVICE(ELAN_VENDOR_ID, VUB300_PRODUCT_ID)},\n\t{USB_DEVICE(VUB300_VENDOR_ID, VUB300_PRODUCT_ID)},\n\t{}  \n};\nMODULE_DEVICE_TABLE(usb, vub300_table);\n\nstatic struct workqueue_struct *cmndworkqueue;\nstatic struct workqueue_struct *pollworkqueue;\nstatic struct workqueue_struct *deadworkqueue;\n\nstatic inline int interface_to_InterfaceNumber(struct usb_interface *interface)\n{\n\tif (!interface)\n\t\treturn -1;\n\tif (!interface->cur_altsetting)\n\t\treturn -1;\n\treturn interface->cur_altsetting->desc.bInterfaceNumber;\n}\n\nstruct sdio_register {\n\tunsigned func_num:3;\n\tunsigned sdio_reg:17;\n\tunsigned activate:1;\n\tunsigned prepared:1;\n\tunsigned regvalue:8;\n\tunsigned response:8;\n\tunsigned sparebit:26;\n};\n\nstruct vub300_mmc_host {\n\tstruct usb_device *udev;\n\tstruct usb_interface *interface;\n\tstruct kref kref;\n\tstruct mutex cmd_mutex;\n\tstruct mutex irq_mutex;\n\tchar vub_name[3 + (9 * 8) + 4 + 1];  \n\tu8 cmnd_out_ep;  \n\tu8 cmnd_res_ep;  \n\tu8 data_out_ep;  \n\tu8 data_inp_ep;  \n\tbool card_powered;\n\tbool card_present;\n\tbool read_only;\n\tbool large_usb_packets;\n\tbool app_spec;  \n\tbool irq_enabled;  \n\tbool irq_disabled;  \n\tunsigned bus_width:4;\n\tu8 total_offload_count;\n\tu8 dynamic_register_count;\n\tu8 resp_len;\n\tu32 datasize;\n\tint errors;\n\tint usb_transport_fail;\n\tint usb_timed_out;\n\tint irqs_queued;\n\tstruct sdio_register sdio_register[16];\n\tstruct offload_interrupt_function_register {\n#define MAXREGBITS 4\n#define MAXREGS (1<<MAXREGBITS)\n#define MAXREGMASK (MAXREGS-1)\n\t\tu8 offload_count;\n\t\tu32 offload_point;\n\t\tstruct offload_registers_access reg[MAXREGS];\n\t} fn[8];\n\tu16 fbs[8];  \n\tstruct mmc_command *cmd;\n\tstruct mmc_request *req;\n\tstruct mmc_data *data;\n\tstruct mmc_host *mmc;\n\tstruct urb *urb;\n\tstruct urb *command_out_urb;\n\tstruct urb *command_res_urb;\n\tstruct completion command_complete;\n\tstruct completion irqpoll_complete;\n\tunion sd_command cmnd;\n\tunion sd_response resp;\n\tstruct timer_list sg_transfer_timer;\n\tstruct usb_sg_request sg_request;\n\tstruct timer_list inactivity_timer;\n\tstruct work_struct deadwork;\n\tstruct work_struct cmndwork;\n\tstruct delayed_work pollwork;\n\tstruct host_controller_info hc_info;\n\tstruct sd_status_header system_port_status;\n\tu8 padded_buffer[64];\n};\n\n#define kref_to_vub300_mmc_host(d) container_of(d, struct vub300_mmc_host, kref)\n#define SET_TRANSFER_PSEUDOCODE\t\t21\n#define SET_INTERRUPT_PSEUDOCODE\t20\n#define SET_FAILURE_MODE\t\t18\n#define SET_ROM_WAIT_STATES\t\t16\n#define SET_IRQ_ENABLE\t\t\t13\n#define SET_CLOCK_SPEED\t\t\t11\n#define SET_FUNCTION_BLOCK_SIZE\t\t9\n#define SET_SD_DATA_MODE\t\t6\n#define SET_SD_POWER\t\t\t4\n#define ENTER_DFU_MODE\t\t\t3\n#define GET_HC_INF0\t\t\t1\n#define GET_SYSTEM_PORT_STATUS\t\t0\n\nstatic void vub300_delete(struct kref *kref)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = kref_to_vub300_mmc_host(kref);\n\tstruct mmc_host *mmc = vub300->mmc;\n\tusb_free_urb(vub300->command_out_urb);\n\tvub300->command_out_urb = NULL;\n\tusb_free_urb(vub300->command_res_urb);\n\tvub300->command_res_urb = NULL;\n\tusb_put_dev(vub300->udev);\n\tmmc_free_host(mmc);\n\t \n}\n\nstatic void vub300_queue_cmnd_work(struct vub300_mmc_host *vub300)\n{\n\tkref_get(&vub300->kref);\n\tif (queue_work(cmndworkqueue, &vub300->cmndwork)) {\n\t\t \n\t} else {\n\t\t \n\t\tkref_put(&vub300->kref, vub300_delete);\n\t}\n}\n\nstatic void vub300_queue_poll_work(struct vub300_mmc_host *vub300, int delay)\n{\n\tkref_get(&vub300->kref);\n\tif (queue_delayed_work(pollworkqueue, &vub300->pollwork, delay)) {\n\t\t \n\t} else {\n\t\t \n\t\tkref_put(&vub300->kref, vub300_delete);\n\t}\n}\n\nstatic void vub300_queue_dead_work(struct vub300_mmc_host *vub300)\n{\n\tkref_get(&vub300->kref);\n\tif (queue_work(deadworkqueue, &vub300->deadwork)) {\n\t\t \n\t} else {\n\t\t \n\t\tkref_put(&vub300->kref, vub300_delete);\n\t}\n}\n\nstatic void irqpoll_res_completed(struct urb *urb)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\n\tif (urb->status)\n\t\tvub300->usb_transport_fail = urb->status;\n\tcomplete(&vub300->irqpoll_complete);\n}\n\nstatic void irqpoll_out_completed(struct urb *urb)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\n\tif (urb->status) {\n\t\tvub300->usb_transport_fail = urb->status;\n\t\tcomplete(&vub300->irqpoll_complete);\n\t\treturn;\n\t} else {\n\t\tint ret;\n\t\tunsigned int pipe =\n\t\t\tusb_rcvbulkpipe(vub300->udev, vub300->cmnd_res_ep);\n\t\tusb_fill_bulk_urb(vub300->command_res_urb, vub300->udev, pipe,\n\t\t\t\t  &vub300->resp, sizeof(vub300->resp),\n\t\t\t\t  irqpoll_res_completed, vub300);\n\t\tvub300->command_res_urb->actual_length = 0;\n\t\tret = usb_submit_urb(vub300->command_res_urb, GFP_ATOMIC);\n\t\tif (ret) {\n\t\t\tvub300->usb_transport_fail = ret;\n\t\t\tcomplete(&vub300->irqpoll_complete);\n\t\t}\n\t\treturn;\n\t}\n}\n\nstatic void send_irqpoll(struct vub300_mmc_host *vub300)\n{\n\t \n\tint retval;\n\tint timeout = 0xFFFF & (0x0001FFFF - firmware_irqpoll_timeout);\n\tvub300->cmnd.poll.header_size = 22;\n\tvub300->cmnd.poll.header_type = 1;\n\tvub300->cmnd.poll.port_number = 0;\n\tvub300->cmnd.poll.command_type = 2;\n\tvub300->cmnd.poll.poll_timeout_lsb = 0xFF & (unsigned)timeout;\n\tvub300->cmnd.poll.poll_timeout_msb = 0xFF & (unsigned)(timeout >> 8);\n\tusb_fill_bulk_urb(vub300->command_out_urb, vub300->udev,\n\t\t\t  usb_sndbulkpipe(vub300->udev, vub300->cmnd_out_ep)\n\t\t\t  , &vub300->cmnd, sizeof(vub300->cmnd)\n\t\t\t  , irqpoll_out_completed, vub300);\n\tretval = usb_submit_urb(vub300->command_out_urb, GFP_KERNEL);\n\tif (0 > retval) {\n\t\tvub300->usb_transport_fail = retval;\n\t\tvub300_queue_poll_work(vub300, 1);\n\t\tcomplete(&vub300->irqpoll_complete);\n\t\treturn;\n\t} else {\n\t\treturn;\n\t}\n}\n\nstatic void new_system_port_status(struct vub300_mmc_host *vub300)\n{\n\tint old_card_present = vub300->card_present;\n\tint new_card_present =\n\t\t(0x0001 & vub300->system_port_status.port_flags) ? 1 : 0;\n\tvub300->read_only =\n\t\t(0x0010 & vub300->system_port_status.port_flags) ? 1 : 0;\n\tif (new_card_present && !old_card_present) {\n\t\tdev_info(&vub300->udev->dev, \"card just inserted\\n\");\n\t\tvub300->card_present = 1;\n\t\tvub300->bus_width = 0;\n\t\tif (disable_offload_processing)\n\t\t\tstrncpy(vub300->vub_name, \"EMPTY Processing Disabled\",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\telse\n\t\t\tvub300->vub_name[0] = 0;\n\t\tmmc_detect_change(vub300->mmc, 1);\n\t} else if (!new_card_present && old_card_present) {\n\t\tdev_info(&vub300->udev->dev, \"card just ejected\\n\");\n\t\tvub300->card_present = 0;\n\t\tmmc_detect_change(vub300->mmc, 0);\n\t} else {\n\t\t \n\t}\n}\n\nstatic void __add_offloaded_reg_to_fifo(struct vub300_mmc_host *vub300,\n\t\t\t\t\tstruct offload_registers_access\n\t\t\t\t\t*register_access, u8 func)\n{\n\tu8 r = vub300->fn[func].offload_point + vub300->fn[func].offload_count;\n\tmemcpy(&vub300->fn[func].reg[MAXREGMASK & r], register_access,\n\t       sizeof(struct offload_registers_access));\n\tvub300->fn[func].offload_count += 1;\n\tvub300->total_offload_count += 1;\n}\n\nstatic void add_offloaded_reg(struct vub300_mmc_host *vub300,\n\t\t\t      struct offload_registers_access *register_access)\n{\n\tu32 Register = ((0x03 & register_access->command_byte[0]) << 15)\n\t\t\t| ((0xFF & register_access->command_byte[1]) << 7)\n\t\t\t| ((0xFE & register_access->command_byte[2]) >> 1);\n\tu8 func = ((0x70 & register_access->command_byte[0]) >> 4);\n\tu8 regs = vub300->dynamic_register_count;\n\tu8 i = 0;\n\twhile (0 < regs-- && 1 == vub300->sdio_register[i].activate) {\n\t\tif (vub300->sdio_register[i].func_num == func &&\n\t\t    vub300->sdio_register[i].sdio_reg == Register) {\n\t\t\tif (vub300->sdio_register[i].prepared == 0)\n\t\t\t\tvub300->sdio_register[i].prepared = 1;\n\t\t\tvub300->sdio_register[i].response =\n\t\t\t\tregister_access->Respond_Byte[2];\n\t\t\tvub300->sdio_register[i].regvalue =\n\t\t\t\tregister_access->Respond_Byte[3];\n\t\t\treturn;\n\t\t} else {\n\t\t\ti += 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\t__add_offloaded_reg_to_fifo(vub300, register_access, func);\n}\n\nstatic void check_vub300_port_status(struct vub300_mmc_host *vub300)\n{\n\t \n\tint retval;\n\tretval =\n\t\tusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\n\t\t\t\tGET_SYSTEM_PORT_STATUS,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x0000, 0x0000, &vub300->system_port_status,\n\t\t\t\tsizeof(vub300->system_port_status), 1000);\n\tif (sizeof(vub300->system_port_status) == retval)\n\t\tnew_system_port_status(vub300);\n}\n\nstatic void __vub300_irqpoll_response(struct vub300_mmc_host *vub300)\n{\n\t \n\tif (vub300->command_res_urb->actual_length == 0)\n\t\treturn;\n\n\tswitch (vub300->resp.common.header_type) {\n\tcase RESPONSE_INTERRUPT:\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irq_enabled)\n\t\t\tmmc_signal_sdio_irq(vub300->mmc);\n\t\telse\n\t\t\tvub300->irqs_queued += 1;\n\t\tvub300->irq_disabled = 1;\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tbreak;\n\tcase RESPONSE_ERROR:\n\t\tif (vub300->resp.error.error_code == SD_ERROR_NO_DEVICE)\n\t\t\tcheck_vub300_port_status(vub300);\n\t\tbreak;\n\tcase RESPONSE_STATUS:\n\t\tvub300->system_port_status = vub300->resp.status;\n\t\tnew_system_port_status(vub300);\n\t\tif (!vub300->card_present)\n\t\t\tvub300_queue_poll_work(vub300, HZ / 5);\n\t\tbreak;\n\tcase RESPONSE_IRQ_DISABLED:\n\t{\n\t\tint offloaded_data_length = vub300->resp.common.header_size - 3;\n\t\tint register_count = offloaded_data_length >> 3;\n\t\tint ri = 0;\n\t\twhile (register_count--) {\n\t\t\tadd_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);\n\t\t\tri += 1;\n\t\t}\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irq_enabled)\n\t\t\tmmc_signal_sdio_irq(vub300->mmc);\n\t\telse\n\t\t\tvub300->irqs_queued += 1;\n\t\tvub300->irq_disabled = 1;\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tbreak;\n\t}\n\tcase RESPONSE_IRQ_ENABLED:\n\t{\n\t\tint offloaded_data_length = vub300->resp.common.header_size - 3;\n\t\tint register_count = offloaded_data_length >> 3;\n\t\tint ri = 0;\n\t\twhile (register_count--) {\n\t\t\tadd_offloaded_reg(vub300, &vub300->resp.irq.reg[ri]);\n\t\t\tri += 1;\n\t\t}\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irq_enabled)\n\t\t\tmmc_signal_sdio_irq(vub300->mmc);\n\t\telse\n\t\t\tvub300->irqs_queued += 1;\n\t\tvub300->irq_disabled = 0;\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tbreak;\n\t}\n\tcase RESPONSE_NO_INTERRUPT:\n\t\tvub300_queue_poll_work(vub300, 1);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void __do_poll(struct vub300_mmc_host *vub300)\n{\n\t \n\tunsigned long commretval;\n\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\tinit_completion(&vub300->irqpoll_complete);\n\tsend_irqpoll(vub300);\n\tcommretval = wait_for_completion_timeout(&vub300->irqpoll_complete,\n\t\t\t\t\t\t msecs_to_jiffies(500));\n\tif (vub300->usb_transport_fail) {\n\t\t \n\t} else if (commretval == 0) {\n\t\tvub300->usb_timed_out = 1;\n\t\tusb_kill_urb(vub300->command_out_urb);\n\t\tusb_kill_urb(vub300->command_res_urb);\n\t} else {  \n\t\t__vub300_irqpoll_response(vub300);\n\t}\n}\n\n \nstatic void vub300_pollwork_thread(struct work_struct *work)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = container_of(work,\n\t\t\t      struct vub300_mmc_host, pollwork.work);\n\tif (!vub300->interface) {\n\t\tkref_put(&vub300->kref, vub300_delete);\n\t\treturn;\n\t}\n\tmutex_lock(&vub300->cmd_mutex);\n\tif (vub300->cmd) {\n\t\tvub300_queue_poll_work(vub300, 1);\n\t} else if (!vub300->card_present) {\n\t\t \n\t} else {  \n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (!vub300->irq_enabled) {\n\t\t\tmutex_unlock(&vub300->irq_mutex);\n\t\t} else if (vub300->irqs_queued) {\n\t\t\tvub300->irqs_queued -= 1;\n\t\t\tmmc_signal_sdio_irq(vub300->mmc);\n\t\t\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\t\t\tmutex_unlock(&vub300->irq_mutex);\n\t\t} else {  \n\t\t\tmutex_unlock(&vub300->irq_mutex);\n\t\t\t__do_poll(vub300);\n\t\t}\n\t}\n\tmutex_unlock(&vub300->cmd_mutex);\n\tkref_put(&vub300->kref, vub300_delete);\n}\n\nstatic void vub300_deadwork_thread(struct work_struct *work)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 =\n\t\tcontainer_of(work, struct vub300_mmc_host, deadwork);\n\tif (!vub300->interface) {\n\t\tkref_put(&vub300->kref, vub300_delete);\n\t\treturn;\n\t}\n\tmutex_lock(&vub300->cmd_mutex);\n\tif (vub300->cmd) {\n\t\t \n\t} else if (vub300->card_present) {\n\t\tcheck_vub300_port_status(vub300);\n\t} else if (vub300->mmc && vub300->mmc->card) {\n\t\t \n\t} else {\n\t\tcheck_vub300_port_status(vub300);\n\t}\n\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\tmutex_unlock(&vub300->cmd_mutex);\n\tkref_put(&vub300->kref, vub300_delete);\n}\n\nstatic void vub300_inactivity_timer_expired(struct timer_list *t)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = from_timer(vub300, t,\n\t\t\t\t\t\t    inactivity_timer);\n\tif (!vub300->interface) {\n\t\tkref_put(&vub300->kref, vub300_delete);\n\t} else if (vub300->cmd) {\n\t\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\t} else {\n\t\tvub300_queue_dead_work(vub300);\n\t\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\t}\n}\n\nstatic int vub300_response_error(u8 error_code)\n{\n\tswitch (error_code) {\n\tcase SD_ERROR_PIO_TIMEOUT:\n\tcase SD_ERROR_1BIT_TIMEOUT:\n\tcase SD_ERROR_4BIT_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase SD_ERROR_STAT_DATA:\n\tcase SD_ERROR_OVERRUN:\n\tcase SD_ERROR_STAT_CMD:\n\tcase SD_ERROR_STAT_CMD_TIMEOUT:\n\tcase SD_ERROR_SDCRDY_STUCK:\n\tcase SD_ERROR_UNHANDLED:\n\tcase SD_ERROR_1BIT_CRC_WRONG:\n\tcase SD_ERROR_4BIT_CRC_WRONG:\n\tcase SD_ERROR_1BIT_CRC_ERROR:\n\tcase SD_ERROR_4BIT_CRC_ERROR:\n\tcase SD_ERROR_NO_CMD_ENDBIT:\n\tcase SD_ERROR_NO_1BIT_DATEND:\n\tcase SD_ERROR_NO_4BIT_DATEND:\n\tcase SD_ERROR_1BIT_DATA_TIMEOUT:\n\tcase SD_ERROR_4BIT_DATA_TIMEOUT:\n\tcase SD_ERROR_1BIT_UNEXPECTED_TIMEOUT:\n\tcase SD_ERROR_4BIT_UNEXPECTED_TIMEOUT:\n\t\treturn -EILSEQ;\n\tcase 33:\n\t\treturn -EILSEQ;\n\tcase SD_ERROR_ILLEGAL_COMMAND:\n\t\treturn -EINVAL;\n\tcase SD_ERROR_NO_DEVICE:\n\t\treturn -ENOMEDIUM;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n}\n\nstatic void command_res_completed(struct urb *urb)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\n\tif (urb->status) {\n\t\t \n\t} else if (vub300->command_res_urb->actual_length == 0) {\n\t\t \n\t} else if (!vub300->data) {\n\t\t \n\t} else if (vub300->resp.common.header_type != 0x02) {\n\t\t \n\t} else if (vub300->urb) {\n\t\tvub300->cmd->error =\n\t\t\tvub300_response_error(vub300->resp.error.error_code);\n\t\tusb_unlink_urb(vub300->urb);\n\t} else {\n\t\tvub300->cmd->error =\n\t\t\tvub300_response_error(vub300->resp.error.error_code);\n\t\tusb_sg_cancel(&vub300->sg_request);\n\t}\n\tcomplete(&vub300->command_complete);\t \n}\n\nstatic void command_out_completed(struct urb *urb)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = (struct vub300_mmc_host *)urb->context;\n\tif (urb->status) {\n\t\tcomplete(&vub300->command_complete);\n\t} else {\n\t\tint ret;\n\t\tunsigned int pipe =\n\t\t\tusb_rcvbulkpipe(vub300->udev, vub300->cmnd_res_ep);\n\t\tusb_fill_bulk_urb(vub300->command_res_urb, vub300->udev, pipe,\n\t\t\t\t  &vub300->resp, sizeof(vub300->resp),\n\t\t\t\t  command_res_completed, vub300);\n\t\tvub300->command_res_urb->actual_length = 0;\n\t\tret = usb_submit_urb(vub300->command_res_urb, GFP_ATOMIC);\n\t\tif (ret == 0) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tcomplete(&vub300->command_complete);\n\t\t}\n\t}\n}\n\n \nstatic void snoop_block_size_and_bus_width(struct vub300_mmc_host *vub300,\n\t\t\t\t\t   u32 cmd_arg)\n{\n\tif ((0xFBFFFE00 & cmd_arg) == 0x80022200)\n\t\tvub300->fbs[1] = (cmd_arg << 8) | (0x00FF & vub300->fbs[1]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80022000)\n\t\tvub300->fbs[1] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[1]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80042200)\n\t\tvub300->fbs[2] = (cmd_arg << 8) | (0x00FF & vub300->fbs[2]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80042000)\n\t\tvub300->fbs[2] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[2]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80062200)\n\t\tvub300->fbs[3] = (cmd_arg << 8) | (0x00FF & vub300->fbs[3]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80062000)\n\t\tvub300->fbs[3] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[3]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80082200)\n\t\tvub300->fbs[4] = (cmd_arg << 8) | (0x00FF & vub300->fbs[4]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x80082000)\n\t\tvub300->fbs[4] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[4]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800A2200)\n\t\tvub300->fbs[5] = (cmd_arg << 8) | (0x00FF & vub300->fbs[5]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800A2000)\n\t\tvub300->fbs[5] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[5]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800C2200)\n\t\tvub300->fbs[6] = (cmd_arg << 8) | (0x00FF & vub300->fbs[6]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800C2000)\n\t\tvub300->fbs[6] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[6]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800E2200)\n\t\tvub300->fbs[7] = (cmd_arg << 8) | (0x00FF & vub300->fbs[7]);\n\telse if ((0xFBFFFE00 & cmd_arg) == 0x800E2000)\n\t\tvub300->fbs[7] = (0xFF & cmd_arg) | (0xFF00 & vub300->fbs[7]);\n\telse if ((0xFBFFFE03 & cmd_arg) == 0x80000E00)\n\t\tvub300->bus_width = 1;\n\telse if ((0xFBFFFE03 & cmd_arg) == 0x80000E02)\n\t\tvub300->bus_width = 4;\n}\n\nstatic void send_command(struct vub300_mmc_host *vub300)\n{\n\t \n\tstruct mmc_command *cmd = vub300->cmd;\n\tstruct mmc_data *data = vub300->data;\n\tint retval;\n\tint i;\n\tu8 response_type;\n\tif (vub300->app_spec) {\n\t\tswitch (cmd->opcode) {\n\t\tcase 6:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tif (0x00000000 == (0x00000003 & cmd->arg))\n\t\t\t\tvub300->bus_width = 1;\n\t\t\telse if (0x00000002 == (0x00000003 & cmd->arg))\n\t\t\t\tvub300->bus_width = 4;\n\t\t\telse\n\t\t\t\tdev_err(&vub300->udev->dev,\n\t\t\t\t\t\"unexpected ACMD6 bus_width=%d\\n\",\n\t\t\t\t\t0x00000003 & cmd->arg);\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 22:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 23:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 41:\n\t\t\tresponse_type = SDRT_3;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 51:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 55:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvub300->resp_len = 0;\n\t\t\tcmd->error = -EINVAL;\n\t\t\tcomplete(&vub300->command_complete);\n\t\t\treturn;\n\t\t}\n\t\tvub300->app_spec = 0;\n\t} else {\n\t\tswitch (cmd->opcode) {\n\t\tcase 0:\n\t\t\tresponse_type = SDRT_NONE;\n\t\t\tvub300->resp_len = 0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tresponse_type = SDRT_3;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tresponse_type = SDRT_2;\n\t\t\tvub300->resp_len = 17;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tresponse_type = SDRT_6;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tresponse_type = SDRT_NONE;\n\t\t\tvub300->resp_len = 0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tresponse_type = SDRT_4;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tresponse_type = SDRT_1B;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tresponse_type = SDRT_7;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 9:\n\t\t\tresponse_type = SDRT_2;\n\t\t\tvub300->resp_len = 17;\n\t\t\tbreak;\n\t\tcase 10:\n\t\t\tresponse_type = SDRT_2;\n\t\t\tvub300->resp_len = 17;\n\t\t\tbreak;\n\t\tcase 12:\n\t\t\tresponse_type = SDRT_1B;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 13:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\tresponse_type = SDRT_NONE;\n\t\t\tvub300->resp_len = 0;\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\tfor (i = 0; i < ARRAY_SIZE(vub300->fbs); i++)\n\t\t\t\tvub300->fbs[i] = 0xFFFF & cmd->arg;\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 17:\n\t\tcase 18:\n\t\tcase 24:\n\t\tcase 25:\n\t\tcase 27:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 28:\n\t\tcase 29:\n\t\t\tresponse_type = SDRT_1B;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 30:\n\t\tcase 32:\n\t\tcase 33:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 38:\n\t\t\tresponse_type = SDRT_1B;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 42:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 52:\n\t\t\tresponse_type = SDRT_5;\n\t\t\tvub300->resp_len = 6;\n\t\t\tsnoop_block_size_and_bus_width(vub300, cmd->arg);\n\t\t\tbreak;\n\t\tcase 53:\n\t\t\tresponse_type = SDRT_5;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tcase 55:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tvub300->app_spec = 1;\n\t\t\tbreak;\n\t\tcase 56:\n\t\t\tresponse_type = SDRT_1;\n\t\t\tvub300->resp_len = 6;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvub300->resp_len = 0;\n\t\t\tcmd->error = -EINVAL;\n\t\t\tcomplete(&vub300->command_complete);\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\tvub300->cmnd.head.header_size = 20;\n\tvub300->cmnd.head.header_type = 0x00;\n\tvub300->cmnd.head.port_number = 0;  \n\tvub300->cmnd.head.command_type = 0x00;  \n\tvub300->cmnd.head.response_type = response_type;\n\tvub300->cmnd.head.command_index = cmd->opcode;\n\tvub300->cmnd.head.arguments[0] = cmd->arg >> 24;\n\tvub300->cmnd.head.arguments[1] = cmd->arg >> 16;\n\tvub300->cmnd.head.arguments[2] = cmd->arg >> 8;\n\tvub300->cmnd.head.arguments[3] = cmd->arg >> 0;\n\tif (cmd->opcode == 52) {\n\t\tint fn = 0x7 & (cmd->arg >> 28);\n\t\tvub300->cmnd.head.block_count[0] = 0;\n\t\tvub300->cmnd.head.block_count[1] = 0;\n\t\tvub300->cmnd.head.block_size[0] = (vub300->fbs[fn] >> 8) & 0xFF;\n\t\tvub300->cmnd.head.block_size[1] = (vub300->fbs[fn] >> 0) & 0xFF;\n\t\tvub300->cmnd.head.command_type = 0x00;\n\t\tvub300->cmnd.head.transfer_size[0] = 0;\n\t\tvub300->cmnd.head.transfer_size[1] = 0;\n\t\tvub300->cmnd.head.transfer_size[2] = 0;\n\t\tvub300->cmnd.head.transfer_size[3] = 0;\n\t} else if (!data) {\n\t\tvub300->cmnd.head.block_count[0] = 0;\n\t\tvub300->cmnd.head.block_count[1] = 0;\n\t\tvub300->cmnd.head.block_size[0] = (vub300->fbs[0] >> 8) & 0xFF;\n\t\tvub300->cmnd.head.block_size[1] = (vub300->fbs[0] >> 0) & 0xFF;\n\t\tvub300->cmnd.head.command_type = 0x00;\n\t\tvub300->cmnd.head.transfer_size[0] = 0;\n\t\tvub300->cmnd.head.transfer_size[1] = 0;\n\t\tvub300->cmnd.head.transfer_size[2] = 0;\n\t\tvub300->cmnd.head.transfer_size[3] = 0;\n\t} else if (cmd->opcode == 53) {\n\t\tint fn = 0x7 & (cmd->arg >> 28);\n\t\tif (0x08 & vub300->cmnd.head.arguments[0]) {  \n\t\t\tvub300->cmnd.head.block_count[0] =\n\t\t\t\t(data->blocks >> 8) & 0xFF;\n\t\t\tvub300->cmnd.head.block_count[1] =\n\t\t\t\t(data->blocks >> 0) & 0xFF;\n\t\t\tvub300->cmnd.head.block_size[0] =\n\t\t\t\t(data->blksz >> 8) & 0xFF;\n\t\t\tvub300->cmnd.head.block_size[1] =\n\t\t\t\t(data->blksz >> 0) & 0xFF;\n\t\t} else {\t \n\t\t\tvub300->cmnd.head.block_count[0] = 0;\n\t\t\tvub300->cmnd.head.block_count[1] = 0;\n\t\t\tvub300->cmnd.head.block_size[0] =\n\t\t\t\t(vub300->datasize >> 8) & 0xFF;\n\t\t\tvub300->cmnd.head.block_size[1] =\n\t\t\t\t(vub300->datasize >> 0) & 0xFF;\n\t\t}\n\t\tvub300->cmnd.head.command_type =\n\t\t\t(MMC_DATA_READ & data->flags) ? 0x00 : 0x80;\n\t\tvub300->cmnd.head.transfer_size[0] =\n\t\t\t(vub300->datasize >> 24) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[1] =\n\t\t\t(vub300->datasize >> 16) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[2] =\n\t\t\t(vub300->datasize >> 8) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[3] =\n\t\t\t(vub300->datasize >> 0) & 0xFF;\n\t\tif (vub300->datasize < vub300->fbs[fn]) {\n\t\t\tvub300->cmnd.head.block_count[0] = 0;\n\t\t\tvub300->cmnd.head.block_count[1] = 0;\n\t\t}\n\t} else {\n\t\tvub300->cmnd.head.block_count[0] = (data->blocks >> 8) & 0xFF;\n\t\tvub300->cmnd.head.block_count[1] = (data->blocks >> 0) & 0xFF;\n\t\tvub300->cmnd.head.block_size[0] = (data->blksz >> 8) & 0xFF;\n\t\tvub300->cmnd.head.block_size[1] = (data->blksz >> 0) & 0xFF;\n\t\tvub300->cmnd.head.command_type =\n\t\t\t(MMC_DATA_READ & data->flags) ? 0x00 : 0x80;\n\t\tvub300->cmnd.head.transfer_size[0] =\n\t\t\t(vub300->datasize >> 24) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[1] =\n\t\t\t(vub300->datasize >> 16) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[2] =\n\t\t\t(vub300->datasize >> 8) & 0xFF;\n\t\tvub300->cmnd.head.transfer_size[3] =\n\t\t\t(vub300->datasize >> 0) & 0xFF;\n\t\tif (vub300->datasize < vub300->fbs[0]) {\n\t\t\tvub300->cmnd.head.block_count[0] = 0;\n\t\t\tvub300->cmnd.head.block_count[1] = 0;\n\t\t}\n\t}\n\tif (vub300->cmnd.head.block_size[0] || vub300->cmnd.head.block_size[1]) {\n\t\tu16 block_size = vub300->cmnd.head.block_size[1] |\n\t\t\t(vub300->cmnd.head.block_size[0] << 8);\n\t\tu16 block_boundary = FIRMWARE_BLOCK_BOUNDARY -\n\t\t\t(FIRMWARE_BLOCK_BOUNDARY % block_size);\n\t\tvub300->cmnd.head.block_boundary[0] =\n\t\t\t(block_boundary >> 8) & 0xFF;\n\t\tvub300->cmnd.head.block_boundary[1] =\n\t\t\t(block_boundary >> 0) & 0xFF;\n\t} else {\n\t\tvub300->cmnd.head.block_boundary[0] = 0;\n\t\tvub300->cmnd.head.block_boundary[1] = 0;\n\t}\n\tusb_fill_bulk_urb(vub300->command_out_urb, vub300->udev,\n\t\t\t  usb_sndbulkpipe(vub300->udev, vub300->cmnd_out_ep),\n\t\t\t  &vub300->cmnd, sizeof(vub300->cmnd),\n\t\t\t  command_out_completed, vub300);\n\tretval = usb_submit_urb(vub300->command_out_urb, GFP_KERNEL);\n\tif (retval < 0) {\n\t\tcmd->error = retval;\n\t\tcomplete(&vub300->command_complete);\n\t\treturn;\n\t} else {\n\t\treturn;\n\t}\n}\n\n \nstatic void vub300_sg_timed_out(struct timer_list *t)\n{\n\tstruct vub300_mmc_host *vub300 = from_timer(vub300, t,\n\t\t\t\t\t\t    sg_transfer_timer);\n\tvub300->usb_timed_out = 1;\n\tusb_sg_cancel(&vub300->sg_request);\n\tusb_unlink_urb(vub300->command_out_urb);\n\tusb_unlink_urb(vub300->command_res_urb);\n}\n\nstatic u16 roundup_to_multiple_of_64(u16 number)\n{\n\treturn 0xFFC0 & (0x3F + number);\n}\n\n \nstatic void __download_offload_pseudocode(struct vub300_mmc_host *vub300,\n\t\t\t\t\t  const struct firmware *fw)\n{\n\tu8 register_count = 0;\n\tu16 ts = 0;\n\tu16 interrupt_size = 0;\n\tconst u8 *data = fw->data;\n\tint size = fw->size;\n\tu8 c;\n\tdev_info(&vub300->udev->dev, \"using %s for SDIO offload processing\\n\",\n\t\t vub300->vub_name);\n\tdo {\n\t\tc = *data++;\n\t} while (size-- && c);  \n\tdev_info(&vub300->udev->dev, \"using offload firmware %s %s\\n\", fw->data,\n\t\t vub300->vub_name);\n\tif (size < 4) {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t\"corrupt offload pseudocode in firmware %s\\n\",\n\t\t\tvub300->vub_name);\n\t\tstrncpy(vub300->vub_name, \"corrupt offload pseudocode\",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\tinterrupt_size += *data++;\n\tsize -= 1;\n\tinterrupt_size <<= 8;\n\tinterrupt_size += *data++;\n\tsize -= 1;\n\tif (interrupt_size < size) {\n\t\tu16 xfer_length = roundup_to_multiple_of_64(interrupt_size);\n\t\tu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\n\t\tif (xfer_buffer) {\n\t\t\tint retval;\n\t\t\tmemcpy(xfer_buffer, data, interrupt_size);\n\t\t\tmemset(xfer_buffer + interrupt_size, 0,\n\t\t\t       xfer_length - interrupt_size);\n\t\t\tsize -= interrupt_size;\n\t\t\tdata += interrupt_size;\n\t\t\tretval =\n\t\t\t\tusb_control_msg(vub300->udev,\n\t\t\t\t\t\tusb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\t\t\tSET_INTERRUPT_PSEUDOCODE,\n\t\t\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\t\tUSB_RECIP_DEVICE, 0x0000, 0x0000,\n\t\t\t\t\t\txfer_buffer, xfer_length, 1000);\n\t\t\tkfree(xfer_buffer);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto copy_error_message;\n\t\t} else {\n\t\t\tdev_err(&vub300->udev->dev,\n\t\t\t\t\"not enough memory for xfer buffer to send\"\n\t\t\t\t\" INTERRUPT_PSEUDOCODE for %s %s\\n\", fw->data,\n\t\t\t\tvub300->vub_name);\n\t\t\tstrncpy(vub300->vub_name,\n\t\t\t\t\"SDIO interrupt pseudocode download failed\",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t\"corrupt interrupt pseudocode in firmware %s %s\\n\",\n\t\t\tfw->data, vub300->vub_name);\n\t\tstrncpy(vub300->vub_name, \"corrupt interrupt pseudocode\",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\tts += *data++;\n\tsize -= 1;\n\tts <<= 8;\n\tts += *data++;\n\tsize -= 1;\n\tif (ts < size) {\n\t\tu16 xfer_length = roundup_to_multiple_of_64(ts);\n\t\tu8 *xfer_buffer = kmalloc(xfer_length, GFP_KERNEL);\n\t\tif (xfer_buffer) {\n\t\t\tint retval;\n\t\t\tmemcpy(xfer_buffer, data, ts);\n\t\t\tmemset(xfer_buffer + ts, 0,\n\t\t\t       xfer_length - ts);\n\t\t\tsize -= ts;\n\t\t\tdata += ts;\n\t\t\tretval =\n\t\t\t\tusb_control_msg(vub300->udev,\n\t\t\t\t\t\tusb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\t\t\tSET_TRANSFER_PSEUDOCODE,\n\t\t\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t\t\tUSB_RECIP_DEVICE, 0x0000, 0x0000,\n\t\t\t\t\t\txfer_buffer, xfer_length, 1000);\n\t\t\tkfree(xfer_buffer);\n\t\t\tif (retval < 0)\n\t\t\t\tgoto copy_error_message;\n\t\t} else {\n\t\t\tdev_err(&vub300->udev->dev,\n\t\t\t\t\"not enough memory for xfer buffer to send\"\n\t\t\t\t\" TRANSFER_PSEUDOCODE for %s %s\\n\", fw->data,\n\t\t\t\tvub300->vub_name);\n\t\t\tstrncpy(vub300->vub_name,\n\t\t\t\t\"SDIO transfer pseudocode download failed\",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t\"corrupt transfer pseudocode in firmware %s %s\\n\",\n\t\t\tfw->data, vub300->vub_name);\n\t\tstrncpy(vub300->vub_name, \"corrupt transfer pseudocode\",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\tregister_count += *data++;\n\tsize -= 1;\n\tif (register_count * 4 == size) {\n\t\tint I = vub300->dynamic_register_count = register_count;\n\t\tint i = 0;\n\t\twhile (I--) {\n\t\t\tunsigned int func_num = 0;\n\t\t\tvub300->sdio_register[i].func_num = *data++;\n\t\t\tsize -= 1;\n\t\t\tfunc_num += *data++;\n\t\t\tsize -= 1;\n\t\t\tfunc_num <<= 8;\n\t\t\tfunc_num += *data++;\n\t\t\tsize -= 1;\n\t\t\tfunc_num <<= 8;\n\t\t\tfunc_num += *data++;\n\t\t\tsize -= 1;\n\t\t\tvub300->sdio_register[i].sdio_reg = func_num;\n\t\t\tvub300->sdio_register[i].activate = 1;\n\t\t\tvub300->sdio_register[i].prepared = 0;\n\t\t\ti += 1;\n\t\t}\n\t\tdev_info(&vub300->udev->dev,\n\t\t\t \"initialized %d dynamic pseudocode registers\\n\",\n\t\t\t vub300->dynamic_register_count);\n\t\treturn;\n\t} else {\n\t\tdev_err(&vub300->udev->dev,\n\t\t\t\"corrupt dynamic registers in firmware %s\\n\",\n\t\t\tvub300->vub_name);\n\t\tstrncpy(vub300->vub_name, \"corrupt dynamic registers\",\n\t\t\tsizeof(vub300->vub_name));\n\t\treturn;\n\t}\n\ncopy_error_message:\n\tstrncpy(vub300->vub_name, \"SDIO pseudocode download failed\",\n\t\tsizeof(vub300->vub_name));\n}\n\n \nstatic void download_offload_pseudocode(struct vub300_mmc_host *vub300)\n{\n\tstruct mmc_card *card = vub300->mmc->card;\n\tint sdio_funcs = card->sdio_funcs;\n\tconst struct firmware *fw = NULL;\n\tint l = snprintf(vub300->vub_name, sizeof(vub300->vub_name),\n\t\t\t \"vub_%04X%04X\", card->cis.vendor, card->cis.device);\n\tint n = 0;\n\tint retval;\n\tfor (n = 0; n < sdio_funcs; n++) {\n\t\tstruct sdio_func *sf = card->sdio_func[n];\n\t\tl += scnprintf(vub300->vub_name + l,\n\t\t\t      sizeof(vub300->vub_name) - l, \"_%04X%04X\",\n\t\t\t      sf->vendor, sf->device);\n\t}\n\tsnprintf(vub300->vub_name + l, sizeof(vub300->vub_name) - l, \".bin\");\n\tdev_info(&vub300->udev->dev, \"requesting offload firmware %s\\n\",\n\t\t vub300->vub_name);\n\tretval = request_firmware(&fw, vub300->vub_name, &card->dev);\n\tif (retval < 0) {\n\t\tstrncpy(vub300->vub_name, \"vub_default.bin\",\n\t\t\tsizeof(vub300->vub_name));\n\t\tretval = request_firmware(&fw, vub300->vub_name, &card->dev);\n\t\tif (retval < 0) {\n\t\t\tstrncpy(vub300->vub_name,\n\t\t\t\t\"no SDIO offload firmware found\",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\t} else {\n\t\t\t__download_offload_pseudocode(vub300, fw);\n\t\t\trelease_firmware(fw);\n\t\t}\n\t} else {\n\t\t__download_offload_pseudocode(vub300, fw);\n\t\trelease_firmware(fw);\n\t}\n}\n\nstatic void vub300_usb_bulk_msg_completion(struct urb *urb)\n{\t\t\t\t \n\tcomplete((struct completion *)urb->context);\n}\n\nstatic int vub300_usb_bulk_msg(struct vub300_mmc_host *vub300,\n\t\t\t       unsigned int pipe, void *data, int len,\n\t\t\t       int *actual_length, int timeout_msecs)\n{\n\t \n\tstruct usb_device *usb_dev = vub300->udev;\n\tstruct completion done;\n\tint retval;\n\tvub300->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!vub300->urb)\n\t\treturn -ENOMEM;\n\tusb_fill_bulk_urb(vub300->urb, usb_dev, pipe, data, len,\n\t\t\t  vub300_usb_bulk_msg_completion, NULL);\n\tinit_completion(&done);\n\tvub300->urb->context = &done;\n\tvub300->urb->actual_length = 0;\n\tretval = usb_submit_urb(vub300->urb, GFP_KERNEL);\n\tif (unlikely(retval))\n\t\tgoto out;\n\tif (!wait_for_completion_timeout\n\t    (&done, msecs_to_jiffies(timeout_msecs))) {\n\t\tretval = -ETIMEDOUT;\n\t\tusb_kill_urb(vub300->urb);\n\t} else {\n\t\tretval = vub300->urb->status;\n\t}\nout:\n\t*actual_length = vub300->urb->actual_length;\n\tusb_free_urb(vub300->urb);\n\tvub300->urb = NULL;\n\treturn retval;\n}\n\nstatic int __command_read_data(struct vub300_mmc_host *vub300,\n\t\t\t       struct mmc_command *cmd, struct mmc_data *data)\n{\n\t \n\tint linear_length = vub300->datasize;\n\tint padded_length = vub300->large_usb_packets ?\n\t\t((511 + linear_length) >> 9) << 9 :\n\t\t((63 + linear_length) >> 6) << 6;\n\tif ((padded_length == linear_length) || !pad_input_to_usb_pkt) {\n\t\tint result;\n\t\tunsigned pipe;\n\t\tpipe = usb_rcvbulkpipe(vub300->udev, vub300->data_inp_ep);\n\t\tresult = usb_sg_init(&vub300->sg_request, vub300->udev,\n\t\t\t\t     pipe, 0, data->sg,\n\t\t\t\t     data->sg_len, 0, GFP_KERNEL);\n\t\tif (result < 0) {\n\t\t\tusb_unlink_urb(vub300->command_out_urb);\n\t\t\tusb_unlink_urb(vub300->command_res_urb);\n\t\t\tcmd->error = result;\n\t\t\tdata->bytes_xfered = 0;\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tvub300->sg_transfer_timer.expires =\n\t\t\t\tjiffies + msecs_to_jiffies(2000 +\n\t\t\t\t\t\t  (linear_length / 16384));\n\t\t\tadd_timer(&vub300->sg_transfer_timer);\n\t\t\tusb_sg_wait(&vub300->sg_request);\n\t\t\tdel_timer(&vub300->sg_transfer_timer);\n\t\t\tif (vub300->sg_request.status < 0) {\n\t\t\t\tcmd->error = vub300->sg_request.status;\n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tdata->bytes_xfered = vub300->datasize;\n\t\t\t\treturn linear_length;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu8 *buf = kmalloc(padded_length, GFP_KERNEL);\n\t\tif (buf) {\n\t\t\tint result;\n\t\t\tunsigned pipe = usb_rcvbulkpipe(vub300->udev,\n\t\t\t\t\t\t\tvub300->data_inp_ep);\n\t\t\tint actual_length = 0;\n\t\t\tresult = vub300_usb_bulk_msg(vub300, pipe, buf,\n\t\t\t\t\t     padded_length, &actual_length,\n\t\t\t\t\t     2000 + (padded_length / 16384));\n\t\t\tif (result < 0) {\n\t\t\t\tcmd->error = result;\n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t\tkfree(buf);\n\t\t\t\treturn 0;\n\t\t\t} else if (actual_length < linear_length) {\n\t\t\t\tcmd->error = -EREMOTEIO;\n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t\tkfree(buf);\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tsg_copy_from_buffer(data->sg, data->sg_len, buf,\n\t\t\t\t\t\t    linear_length);\n\t\t\t\tkfree(buf);\n\t\t\t\tdata->bytes_xfered = vub300->datasize;\n\t\t\t\treturn linear_length;\n\t\t\t}\n\t\t} else {\n\t\t\tcmd->error = -ENOMEM;\n\t\t\tdata->bytes_xfered = 0;\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n\nstatic int __command_write_data(struct vub300_mmc_host *vub300,\n\t\t\t\tstruct mmc_command *cmd, struct mmc_data *data)\n{\n\t \n\tunsigned pipe = usb_sndbulkpipe(vub300->udev, vub300->data_out_ep);\n\tint linear_length = vub300->datasize;\n\tint modulo_64_length = linear_length & 0x003F;\n\tint modulo_512_length = linear_length & 0x01FF;\n\tif (linear_length < 64) {\n\t\tint result;\n\t\tint actual_length;\n\t\tsg_copy_to_buffer(data->sg, data->sg_len,\n\t\t\t\t  vub300->padded_buffer,\n\t\t\t\t  sizeof(vub300->padded_buffer));\n\t\tmemset(vub300->padded_buffer + linear_length, 0,\n\t\t       sizeof(vub300->padded_buffer) - linear_length);\n\t\tresult = vub300_usb_bulk_msg(vub300, pipe, vub300->padded_buffer,\n\t\t\t\t\t     sizeof(vub300->padded_buffer),\n\t\t\t\t\t     &actual_length, 2000 +\n\t\t\t\t\t     (sizeof(vub300->padded_buffer) /\n\t\t\t\t\t      16384));\n\t\tif (result < 0) {\n\t\t\tcmd->error = result;\n\t\t\tdata->bytes_xfered = 0;\n\t\t} else {\n\t\t\tdata->bytes_xfered = vub300->datasize;\n\t\t}\n\t} else if ((!vub300->large_usb_packets && (0 < modulo_64_length)) ||\n\t\t    (vub300->large_usb_packets && (64 > modulo_512_length))\n\t\t) {\t\t \n\t\tint padded_length = ((63 + linear_length) >> 6) << 6;\n\t\tu8 *buf = kmalloc(padded_length, GFP_KERNEL);\n\t\tif (buf) {\n\t\t\tint result;\n\t\t\tint actual_length;\n\t\t\tsg_copy_to_buffer(data->sg, data->sg_len, buf,\n\t\t\t\t\t  padded_length);\n\t\t\tmemset(buf + linear_length, 0,\n\t\t\t       padded_length - linear_length);\n\t\t\tresult =\n\t\t\t\tvub300_usb_bulk_msg(vub300, pipe, buf,\n\t\t\t\t\t\t    padded_length, &actual_length,\n\t\t\t\t\t\t    2000 + padded_length / 16384);\n\t\t\tkfree(buf);\n\t\t\tif (result < 0) {\n\t\t\t\tcmd->error = result;\n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t} else {\n\t\t\t\tdata->bytes_xfered = vub300->datasize;\n\t\t\t}\n\t\t} else {\n\t\t\tcmd->error = -ENOMEM;\n\t\t\tdata->bytes_xfered = 0;\n\t\t}\n\t} else {\t\t \n\t\tint result;\n\t\tunsigned char buf[64 * 4];\n\t\tsg_copy_to_buffer(data->sg, data->sg_len, buf, sizeof(buf));\n\t\tresult = usb_sg_init(&vub300->sg_request, vub300->udev,\n\t\t\t\t     pipe, 0, data->sg,\n\t\t\t\t     data->sg_len, 0, GFP_KERNEL);\n\t\tif (result < 0) {\n\t\t\tusb_unlink_urb(vub300->command_out_urb);\n\t\t\tusb_unlink_urb(vub300->command_res_urb);\n\t\t\tcmd->error = result;\n\t\t\tdata->bytes_xfered = 0;\n\t\t} else {\n\t\t\tvub300->sg_transfer_timer.expires =\n\t\t\t\tjiffies + msecs_to_jiffies(2000 +\n\t\t\t\t\t\t\t   linear_length / 16384);\n\t\t\tadd_timer(&vub300->sg_transfer_timer);\n\t\t\tusb_sg_wait(&vub300->sg_request);\n\t\t\tif (cmd->error) {\n\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t} else {\n\t\t\t\tdel_timer(&vub300->sg_transfer_timer);\n\t\t\t\tif (vub300->sg_request.status < 0) {\n\t\t\t\t\tcmd->error = vub300->sg_request.status;\n\t\t\t\t\tdata->bytes_xfered = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdata->bytes_xfered = vub300->datasize;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn linear_length;\n}\n\nstatic void __vub300_command_response(struct vub300_mmc_host *vub300,\n\t\t\t\t      struct mmc_command *cmd,\n\t\t\t\t      struct mmc_data *data, int data_length)\n{\n\t \n\tlong respretval;\n\tint msec_timeout = 1000 + data_length / 4;\n\trespretval =\n\t\twait_for_completion_timeout(&vub300->command_complete,\n\t\t\t\t\t    msecs_to_jiffies(msec_timeout));\n\tif (respretval == 0) {  \n\t\t \n\t\tint result;\n\t\tvub300->usb_timed_out = 1;\n\t\tusb_kill_urb(vub300->command_out_urb);\n\t\tusb_kill_urb(vub300->command_res_urb);\n\t\tcmd->error = -ETIMEDOUT;\n\t\tresult = usb_lock_device_for_reset(vub300->udev,\n\t\t\t\t\t\t   vub300->interface);\n\t\tif (result == 0) {\n\t\t\tresult = usb_reset_device(vub300->udev);\n\t\t\tusb_unlock_device(vub300->udev);\n\t\t}\n\t} else if (respretval < 0) {\n\t\t \n\t\tusb_kill_urb(vub300->command_out_urb);\n\t\tusb_kill_urb(vub300->command_res_urb);\n\t\tcmd->error = respretval;\n\t} else if (cmd->error) {\n\t\t \n\t} else if (vub300->command_out_urb->status) {\n\t\tvub300->usb_transport_fail = vub300->command_out_urb->status;\n\t\tcmd->error = -EPROTO == vub300->command_out_urb->status ?\n\t\t\t-ESHUTDOWN : vub300->command_out_urb->status;\n\t} else if (vub300->command_res_urb->status) {\n\t\tvub300->usb_transport_fail = vub300->command_res_urb->status;\n\t\tcmd->error = -EPROTO == vub300->command_res_urb->status ?\n\t\t\t-ESHUTDOWN : vub300->command_res_urb->status;\n\t} else if (vub300->resp.common.header_type == 0x00) {\n\t\t \n\t} else if (vub300->resp.common.header_type == RESPONSE_ERROR) {\n\t\tcmd->error =\n\t\t\tvub300_response_error(vub300->resp.error.error_code);\n\t\tif (vub300->data)\n\t\t\tusb_sg_cancel(&vub300->sg_request);\n\t} else if (vub300->resp.common.header_type == RESPONSE_PIGGYBACKED) {\n\t\tint offloaded_data_length =\n\t\t\tvub300->resp.common.header_size -\n\t\t\tsizeof(struct sd_register_header);\n\t\tint register_count = offloaded_data_length >> 3;\n\t\tint ri = 0;\n\t\twhile (register_count--) {\n\t\t\tadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\n\t\t\tri += 1;\n\t\t}\n\t\tvub300->resp.common.header_size =\n\t\t\tsizeof(struct sd_register_header);\n\t\tvub300->resp.common.header_type = 0x00;\n\t\tcmd->error = 0;\n\t} else if (vub300->resp.common.header_type == RESPONSE_PIG_DISABLED) {\n\t\tint offloaded_data_length =\n\t\t\tvub300->resp.common.header_size -\n\t\t\tsizeof(struct sd_register_header);\n\t\tint register_count = offloaded_data_length >> 3;\n\t\tint ri = 0;\n\t\twhile (register_count--) {\n\t\t\tadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\n\t\t\tri += 1;\n\t\t}\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irqs_queued) {\n\t\t\tvub300->irqs_queued += 1;\n\t\t} else if (vub300->irq_enabled) {\n\t\t\tvub300->irqs_queued += 1;\n\t\t\tvub300_queue_poll_work(vub300, 0);\n\t\t} else {\n\t\t\tvub300->irqs_queued += 1;\n\t\t}\n\t\tvub300->irq_disabled = 1;\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tvub300->resp.common.header_size =\n\t\t\tsizeof(struct sd_register_header);\n\t\tvub300->resp.common.header_type = 0x00;\n\t\tcmd->error = 0;\n\t} else if (vub300->resp.common.header_type == RESPONSE_PIG_ENABLED) {\n\t\tint offloaded_data_length =\n\t\t\tvub300->resp.common.header_size -\n\t\t\tsizeof(struct sd_register_header);\n\t\tint register_count = offloaded_data_length >> 3;\n\t\tint ri = 0;\n\t\twhile (register_count--) {\n\t\t\tadd_offloaded_reg(vub300, &vub300->resp.pig.reg[ri]);\n\t\t\tri += 1;\n\t\t}\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irqs_queued) {\n\t\t\tvub300->irqs_queued += 1;\n\t\t} else if (vub300->irq_enabled) {\n\t\t\tvub300->irqs_queued += 1;\n\t\t\tvub300_queue_poll_work(vub300, 0);\n\t\t} else {\n\t\t\tvub300->irqs_queued += 1;\n\t\t}\n\t\tvub300->irq_disabled = 0;\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tvub300->resp.common.header_size =\n\t\t\tsizeof(struct sd_register_header);\n\t\tvub300->resp.common.header_type = 0x00;\n\t\tcmd->error = 0;\n\t} else {\n\t\tcmd->error = -EINVAL;\n\t}\n}\n\nstatic void construct_request_response(struct vub300_mmc_host *vub300,\n\t\t\t\t       struct mmc_command *cmd)\n{\n\tint resp_len = vub300->resp_len;\n\tint less_cmd = (17 == resp_len) ? resp_len : resp_len - 1;\n\tint bytes = 3 & less_cmd;\n\tint words = less_cmd >> 2;\n\tu8 *r = vub300->resp.response.command_response;\n\n\tif (!resp_len)\n\t\treturn;\n\tif (bytes == 3) {\n\t\tcmd->resp[words] = (r[1 + (words << 2)] << 24)\n\t\t\t| (r[2 + (words << 2)] << 16)\n\t\t\t| (r[3 + (words << 2)] << 8);\n\t} else if (bytes == 2) {\n\t\tcmd->resp[words] = (r[1 + (words << 2)] << 24)\n\t\t\t| (r[2 + (words << 2)] << 16);\n\t} else if (bytes == 1) {\n\t\tcmd->resp[words] = (r[1 + (words << 2)] << 24);\n\t}\n\twhile (words-- > 0) {\n\t\tcmd->resp[words] = (r[1 + (words << 2)] << 24)\n\t\t\t| (r[2 + (words << 2)] << 16)\n\t\t\t| (r[3 + (words << 2)] << 8)\n\t\t\t| (r[4 + (words << 2)] << 0);\n\t}\n\tif ((cmd->opcode == 53) && (0x000000FF & cmd->resp[0]))\n\t\tcmd->resp[0] &= 0xFFFFFF00;\n}\n\n \nstatic void vub300_cmndwork_thread(struct work_struct *work)\n{\n\tstruct vub300_mmc_host *vub300 =\n\t\tcontainer_of(work, struct vub300_mmc_host, cmndwork);\n\tif (!vub300->interface) {\n\t\tkref_put(&vub300->kref, vub300_delete);\n\t\treturn;\n\t} else {\n\t\tstruct mmc_request *req = vub300->req;\n\t\tstruct mmc_command *cmd = vub300->cmd;\n\t\tstruct mmc_data *data = vub300->data;\n\t\tint data_length;\n\t\tmutex_lock(&vub300->cmd_mutex);\n\t\tinit_completion(&vub300->command_complete);\n\t\tif (likely(vub300->vub_name[0]) || !vub300->mmc->card) {\n\t\t\t \n\t\t} else if (0 == vub300->mmc->card->sdio_funcs) {\n\t\t\tstrncpy(vub300->vub_name, \"SD memory device\",\n\t\t\t\tsizeof(vub300->vub_name));\n\t\t} else {\n\t\t\tdownload_offload_pseudocode(vub300);\n\t\t}\n\t\tsend_command(vub300);\n\t\tif (!data)\n\t\t\tdata_length = 0;\n\t\telse if (MMC_DATA_READ & data->flags)\n\t\t\tdata_length = __command_read_data(vub300, cmd, data);\n\t\telse\n\t\t\tdata_length = __command_write_data(vub300, cmd, data);\n\t\t__vub300_command_response(vub300, cmd, data, data_length);\n\t\tvub300->req = NULL;\n\t\tvub300->cmd = NULL;\n\t\tvub300->data = NULL;\n\t\tif (cmd->error) {\n\t\t\tif (cmd->error == -ENOMEDIUM)\n\t\t\t\tcheck_vub300_port_status(vub300);\n\t\t\tmutex_unlock(&vub300->cmd_mutex);\n\t\t\tmmc_request_done(vub300->mmc, req);\n\t\t\tkref_put(&vub300->kref, vub300_delete);\n\t\t\treturn;\n\t\t} else {\n\t\t\tconstruct_request_response(vub300, cmd);\n\t\t\tvub300->resp_len = 0;\n\t\t\tmutex_unlock(&vub300->cmd_mutex);\n\t\t\tkref_put(&vub300->kref, vub300_delete);\n\t\t\tmmc_request_done(vub300->mmc, req);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic int examine_cyclic_buffer(struct vub300_mmc_host *vub300,\n\t\t\t\t struct mmc_command *cmd, u8 Function)\n{\n\t \n\tu8 cmd0 = 0xFF & (cmd->arg >> 24);\n\tu8 cmd1 = 0xFF & (cmd->arg >> 16);\n\tu8 cmd2 = 0xFF & (cmd->arg >> 8);\n\tu8 cmd3 = 0xFF & (cmd->arg >> 0);\n\tint first = MAXREGMASK & vub300->fn[Function].offload_point;\n\tstruct offload_registers_access *rf = &vub300->fn[Function].reg[first];\n\tif (cmd0 == rf->command_byte[0] &&\n\t    cmd1 == rf->command_byte[1] &&\n\t    cmd2 == rf->command_byte[2] &&\n\t    cmd3 == rf->command_byte[3]) {\n\t\tu8 checksum = 0x00;\n\t\tcmd->resp[1] = checksum << 24;\n\t\tcmd->resp[0] = (rf->Respond_Byte[0] << 24)\n\t\t\t| (rf->Respond_Byte[1] << 16)\n\t\t\t| (rf->Respond_Byte[2] << 8)\n\t\t\t| (rf->Respond_Byte[3] << 0);\n\t\tvub300->fn[Function].offload_point += 1;\n\t\tvub300->fn[Function].offload_count -= 1;\n\t\tvub300->total_offload_count -= 1;\n\t\treturn 1;\n\t} else {\n\t\tint delta = 1;\t \n\t\tu8 register_count = vub300->fn[Function].offload_count - 1;\n\t\tu32 register_point = vub300->fn[Function].offload_point + 1;\n\t\twhile (0 < register_count) {\n\t\t\tint point = MAXREGMASK & register_point;\n\t\t\tstruct offload_registers_access *r =\n\t\t\t\t&vub300->fn[Function].reg[point];\n\t\t\tif (cmd0 == r->command_byte[0] &&\n\t\t\t    cmd1 == r->command_byte[1] &&\n\t\t\t    cmd2 == r->command_byte[2] &&\n\t\t\t    cmd3 == r->command_byte[3]) {\n\t\t\t\tu8 checksum = 0x00;\n\t\t\t\tcmd->resp[1] = checksum << 24;\n\t\t\t\tcmd->resp[0] = (r->Respond_Byte[0] << 24)\n\t\t\t\t\t| (r->Respond_Byte[1] << 16)\n\t\t\t\t\t| (r->Respond_Byte[2] << 8)\n\t\t\t\t\t| (r->Respond_Byte[3] << 0);\n\t\t\t\tvub300->fn[Function].offload_point += delta;\n\t\t\t\tvub300->fn[Function].offload_count -= delta;\n\t\t\t\tvub300->total_offload_count -= delta;\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\tregister_point += 1;\n\t\t\t\tregister_count -= 1;\n\t\t\t\tdelta += 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}\n\nstatic int satisfy_request_from_offloaded_data(struct vub300_mmc_host *vub300,\n\t\t\t\t\t       struct mmc_command *cmd)\n{\n\t \n\tu8 regs = vub300->dynamic_register_count;\n\tu8 i = 0;\n\tu8 func = FUN(cmd);\n\tu32 reg = REG(cmd);\n\twhile (0 < regs--) {\n\t\tif ((vub300->sdio_register[i].func_num == func) &&\n\t\t    (vub300->sdio_register[i].sdio_reg == reg)) {\n\t\t\tif (!vub300->sdio_register[i].prepared) {\n\t\t\t\treturn 0;\n\t\t\t} else if ((0x80000000 & cmd->arg) == 0x80000000) {\n\t\t\t\t \n\t\t\t\tvub300->sdio_register[i].prepared = 0;\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\tu8 checksum = 0x00;\n\t\t\t\tu8 rsp0 = 0x00;\n\t\t\t\tu8 rsp1 = 0x00;\n\t\t\t\tu8 rsp2 = vub300->sdio_register[i].response;\n\t\t\t\tu8 rsp3 = vub300->sdio_register[i].regvalue;\n\t\t\t\tvub300->sdio_register[i].prepared = 0;\n\t\t\t\tcmd->resp[1] = checksum << 24;\n\t\t\t\tcmd->resp[0] = (rsp0 << 24)\n\t\t\t\t\t| (rsp1 << 16)\n\t\t\t\t\t| (rsp2 << 8)\n\t\t\t\t\t| (rsp3 << 0);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else {\n\t\t\ti += 1;\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (vub300->total_offload_count == 0)\n\t\treturn 0;\n\telse if (vub300->fn[func].offload_count == 0)\n\t\treturn 0;\n\telse\n\t\treturn examine_cyclic_buffer(vub300, cmd, func);\n}\n\nstatic void vub300_mmc_request(struct mmc_host *mmc, struct mmc_request *req)\n{\t\t\t\t \n\tstruct mmc_command *cmd = req->cmd;\n\tstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\n\tif (!vub300->interface) {\n\t\tcmd->error = -ESHUTDOWN;\n\t\tmmc_request_done(mmc, req);\n\t\treturn;\n\t} else {\n\t\tstruct mmc_data *data = req->data;\n\t\tif (!vub300->card_powered) {\n\t\t\tcmd->error = -ENOMEDIUM;\n\t\t\tmmc_request_done(mmc, req);\n\t\t\treturn;\n\t\t}\n\t\tif (!vub300->card_present) {\n\t\t\tcmd->error = -ENOMEDIUM;\n\t\t\tmmc_request_done(mmc, req);\n\t\t\treturn;\n\t\t}\n\t\tif (vub300->usb_transport_fail) {\n\t\t\tcmd->error = vub300->usb_transport_fail;\n\t\t\tmmc_request_done(mmc, req);\n\t\t\treturn;\n\t\t}\n\t\tif (!vub300->interface) {\n\t\t\tcmd->error = -ENODEV;\n\t\t\tmmc_request_done(mmc, req);\n\t\t\treturn;\n\t\t}\n\t\tkref_get(&vub300->kref);\n\t\tmutex_lock(&vub300->cmd_mutex);\n\t\tmod_timer(&vub300->inactivity_timer, jiffies + HZ);\n\t\t \n\t\tif (cmd->opcode == 52 &&\n\t\t    satisfy_request_from_offloaded_data(vub300, cmd)) {\n\t\t\tcmd->error = 0;\n\t\t\tmutex_unlock(&vub300->cmd_mutex);\n\t\t\tkref_put(&vub300->kref, vub300_delete);\n\t\t\tmmc_request_done(mmc, req);\n\t\t\treturn;\n\t\t} else {\n\t\t\tvub300->cmd = cmd;\n\t\t\tvub300->req = req;\n\t\t\tvub300->data = data;\n\t\t\tif (data)\n\t\t\t\tvub300->datasize = data->blksz * data->blocks;\n\t\t\telse\n\t\t\t\tvub300->datasize = 0;\n\t\t\tvub300_queue_cmnd_work(vub300);\n\t\t\tmutex_unlock(&vub300->cmd_mutex);\n\t\t\tkref_put(&vub300->kref, vub300_delete);\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic void __set_clock_speed(struct vub300_mmc_host *vub300, u8 buf[8],\n\t\t\t      struct mmc_ios *ios)\n{\n\tint buf_array_size = 8;  \n\tint retval;\n\tu32 kHzClock;\n\tif (ios->clock >= 48000000)\n\t\tkHzClock = 48000;\n\telse if (ios->clock >= 24000000)\n\t\tkHzClock = 24000;\n\telse if (ios->clock >= 20000000)\n\t\tkHzClock = 20000;\n\telse if (ios->clock >= 15000000)\n\t\tkHzClock = 15000;\n\telse if (ios->clock >= 200000)\n\t\tkHzClock = 200;\n\telse\n\t\tkHzClock = 0;\n\t{\n\t\tint i;\n\t\tu64 c = kHzClock;\n\t\tfor (i = 0; i < buf_array_size; i++) {\n\t\t\tbuf[i] = c;\n\t\t\tc >>= 8;\n\t\t}\n\t}\n\tretval =\n\t\tusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\tSET_CLOCK_SPEED,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x00, 0x00, buf, buf_array_size, 1000);\n\tif (retval != 8) {\n\t\tdev_err(&vub300->udev->dev, \"SET_CLOCK_SPEED\"\n\t\t\t\" %dkHz failed with retval=%d\\n\", kHzClock, retval);\n\t} else {\n\t\tdev_dbg(&vub300->udev->dev, \"SET_CLOCK_SPEED\"\n\t\t\t\" %dkHz\\n\", kHzClock);\n\t}\n}\n\nstatic void vub300_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\n\tif (!vub300->interface)\n\t\treturn;\n\tkref_get(&vub300->kref);\n\tmutex_lock(&vub300->cmd_mutex);\n\tif ((ios->power_mode == MMC_POWER_OFF) && vub300->card_powered) {\n\t\tvub300->card_powered = 0;\n\t\tusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\tSET_SD_POWER,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x0000, 0x0000, NULL, 0, 1000);\n\t\t \n\t\tmsleep(600);\n\t} else if ((ios->power_mode == MMC_POWER_UP) && !vub300->card_powered) {\n\t\tusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\tSET_SD_POWER,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x0001, 0x0000, NULL, 0, 1000);\n\t\tmsleep(600);\n\t\tvub300->card_powered = 1;\n\t} else if (ios->power_mode == MMC_POWER_ON) {\n\t\tu8 *buf = kmalloc(8, GFP_KERNEL);\n\t\tif (buf) {\n\t\t\t__set_clock_speed(vub300, buf, ios);\n\t\t\tkfree(buf);\n\t\t}\n\t} else {\n\t\t \n\t}\n\tmutex_unlock(&vub300->cmd_mutex);\n\tkref_put(&vub300->kref, vub300_delete);\n}\n\nstatic int vub300_mmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\n\treturn vub300->read_only;\n}\n\nstatic void vub300_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = mmc_priv(mmc);\n\tif (!vub300->interface)\n\t\treturn;\n\tkref_get(&vub300->kref);\n\tif (enable) {\n\t\tset_current_state(TASK_RUNNING);\n\t\tmutex_lock(&vub300->irq_mutex);\n\t\tif (vub300->irqs_queued) {\n\t\t\tvub300->irqs_queued -= 1;\n\t\t\tmmc_signal_sdio_irq(vub300->mmc);\n\t\t} else if (vub300->irq_disabled) {\n\t\t\tvub300->irq_disabled = 0;\n\t\t\tvub300->irq_enabled = 1;\n\t\t\tvub300_queue_poll_work(vub300, 0);\n\t\t} else if (vub300->irq_enabled) {\n\t\t\t \n\t\t} else {\n\t\t\tvub300->irq_enabled = 1;\n\t\t\tvub300_queue_poll_work(vub300, 0);\n\t\t}\n\t\tmutex_unlock(&vub300->irq_mutex);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t} else {\n\t\tvub300->irq_enabled = 0;\n\t}\n\tkref_put(&vub300->kref, vub300_delete);\n}\n\nstatic const struct mmc_host_ops vub300_mmc_ops = {\n\t.request = vub300_mmc_request,\n\t.set_ios = vub300_mmc_set_ios,\n\t.get_ro = vub300_mmc_get_ro,\n\t.enable_sdio_irq = vub300_enable_sdio_irq,\n};\n\nstatic int vub300_probe(struct usb_interface *interface,\n\t\t\tconst struct usb_device_id *id)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_device *udev = usb_get_dev(interface_to_usbdev(interface));\n\tint i;\n\tint retval = -ENOMEM;\n\tstruct urb *command_out_urb;\n\tstruct urb *command_res_urb;\n\tstruct mmc_host *mmc;\n\tchar manufacturer[48];\n\tchar product[32];\n\tchar serial_number[32];\n\tusb_string(udev, udev->descriptor.iManufacturer, manufacturer,\n\t\t   sizeof(manufacturer));\n\tusb_string(udev, udev->descriptor.iProduct, product, sizeof(product));\n\tusb_string(udev, udev->descriptor.iSerialNumber, serial_number,\n\t\t   sizeof(serial_number));\n\tdev_info(&udev->dev, \"probing VID:PID(%04X:%04X) %s %s %s\\n\",\n\t\t le16_to_cpu(udev->descriptor.idVendor),\n\t\t le16_to_cpu(udev->descriptor.idProduct),\n\t\t manufacturer, product, serial_number);\n\tcommand_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!command_out_urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error0;\n\t}\n\tcommand_res_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!command_res_urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error1;\n\t}\n\t \n\tmmc = mmc_alloc_host(sizeof(struct vub300_mmc_host), &udev->dev);\n\tif (!mmc) {\n\t\tretval = -ENOMEM;\n\t\tdev_err(&udev->dev, \"not enough memory for the mmc_host\\n\");\n\t\tgoto error4;\n\t}\n\t \n\tmmc->caps = 0;\n\tif (!force_1_bit_data_xfers)\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\tif (!force_polling_for_irqs)\n\t\tmmc->caps |= MMC_CAP_SDIO_IRQ;\n\tmmc->caps &= ~MMC_CAP_NEEDS_POLL;\n\t \n\tif (limit_speed_to_24_MHz) {\n\t\tmmc->caps |= MMC_CAP_MMC_HIGHSPEED;\n\t\tmmc->caps |= MMC_CAP_SD_HIGHSPEED;\n\t\tmmc->f_max = 24000000;\n\t\tdev_info(&udev->dev, \"limiting SDIO speed to 24_MHz\\n\");\n\t} else {\n\t\tmmc->caps |= MMC_CAP_MMC_HIGHSPEED;\n\t\tmmc->caps |= MMC_CAP_SD_HIGHSPEED;\n\t\tmmc->f_max = 48000000;\n\t}\n\tmmc->f_min = 200000;\n\tmmc->max_blk_count = 511;\n\tmmc->max_blk_size = 512;\n\tmmc->max_segs = 128;\n\tif (force_max_req_size)\n\t\tmmc->max_req_size = force_max_req_size * 1024;\n\telse\n\t\tmmc->max_req_size = 64 * 1024;\n\tmmc->max_seg_size = mmc->max_req_size;\n\tmmc->ocr_avail = 0;\n\tmmc->ocr_avail |= MMC_VDD_165_195;\n\tmmc->ocr_avail |= MMC_VDD_20_21;\n\tmmc->ocr_avail |= MMC_VDD_21_22;\n\tmmc->ocr_avail |= MMC_VDD_22_23;\n\tmmc->ocr_avail |= MMC_VDD_23_24;\n\tmmc->ocr_avail |= MMC_VDD_24_25;\n\tmmc->ocr_avail |= MMC_VDD_25_26;\n\tmmc->ocr_avail |= MMC_VDD_26_27;\n\tmmc->ocr_avail |= MMC_VDD_27_28;\n\tmmc->ocr_avail |= MMC_VDD_28_29;\n\tmmc->ocr_avail |= MMC_VDD_29_30;\n\tmmc->ocr_avail |= MMC_VDD_30_31;\n\tmmc->ocr_avail |= MMC_VDD_31_32;\n\tmmc->ocr_avail |= MMC_VDD_32_33;\n\tmmc->ocr_avail |= MMC_VDD_33_34;\n\tmmc->ocr_avail |= MMC_VDD_34_35;\n\tmmc->ocr_avail |= MMC_VDD_35_36;\n\tmmc->ops = &vub300_mmc_ops;\n\tvub300 = mmc_priv(mmc);\n\tvub300->mmc = mmc;\n\tvub300->card_powered = 0;\n\tvub300->bus_width = 0;\n\tvub300->cmnd.head.block_size[0] = 0x00;\n\tvub300->cmnd.head.block_size[1] = 0x00;\n\tvub300->app_spec = 0;\n\tmutex_init(&vub300->cmd_mutex);\n\tmutex_init(&vub300->irq_mutex);\n\tvub300->command_out_urb = command_out_urb;\n\tvub300->command_res_urb = command_res_urb;\n\tvub300->usb_timed_out = 0;\n\tvub300->dynamic_register_count = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vub300->fn); i++) {\n\t\tvub300->fn[i].offload_point = 0;\n\t\tvub300->fn[i].offload_count = 0;\n\t}\n\n\tvub300->total_offload_count = 0;\n\tvub300->irq_enabled = 0;\n\tvub300->irq_disabled = 0;\n\tvub300->irqs_queued = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vub300->sdio_register); i++)\n\t\tvub300->sdio_register[i++].activate = 0;\n\n\tvub300->udev = udev;\n\tvub300->interface = interface;\n\tvub300->cmnd_res_ep = 0;\n\tvub300->cmnd_out_ep = 0;\n\tvub300->data_inp_ep = 0;\n\tvub300->data_out_ep = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(vub300->fbs); i++)\n\t\tvub300->fbs[i] = 512;\n\n\t \n\tvub300->large_usb_packets = 0;\n\tiface_desc = interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tstruct usb_endpoint_descriptor *endpoint =\n\t\t\t&iface_desc->endpoint[i].desc;\n\t\tdev_info(&vub300->udev->dev,\n\t\t\t \"vub300 testing %s EndPoint(%d) %02X\\n\",\n\t\t\t usb_endpoint_is_bulk_in(endpoint) ? \"BULK IN\" :\n\t\t\t usb_endpoint_is_bulk_out(endpoint) ? \"BULK OUT\" :\n\t\t\t \"UNKNOWN\", i, endpoint->bEndpointAddress);\n\t\tif (endpoint->wMaxPacketSize > 64)\n\t\t\tvub300->large_usb_packets = 1;\n\t\tif (usb_endpoint_is_bulk_in(endpoint)) {\n\t\t\tif (!vub300->cmnd_res_ep) {\n\t\t\t\tvub300->cmnd_res_ep =\n\t\t\t\t\tendpoint->bEndpointAddress;\n\t\t\t} else if (!vub300->data_inp_ep) {\n\t\t\t\tvub300->data_inp_ep =\n\t\t\t\t\tendpoint->bEndpointAddress;\n\t\t\t} else {\n\t\t\t\tdev_warn(&vub300->udev->dev,\n\t\t\t\t\t \"ignoring\"\n\t\t\t\t\t \" unexpected bulk_in endpoint\");\n\t\t\t}\n\t\t} else if (usb_endpoint_is_bulk_out(endpoint)) {\n\t\t\tif (!vub300->cmnd_out_ep) {\n\t\t\t\tvub300->cmnd_out_ep =\n\t\t\t\t\tendpoint->bEndpointAddress;\n\t\t\t} else if (!vub300->data_out_ep) {\n\t\t\t\tvub300->data_out_ep =\n\t\t\t\t\tendpoint->bEndpointAddress;\n\t\t\t} else {\n\t\t\t\tdev_warn(&vub300->udev->dev,\n\t\t\t\t\t \"ignoring\"\n\t\t\t\t\t \" unexpected bulk_out endpoint\");\n\t\t\t}\n\t\t} else {\n\t\t\tdev_warn(&vub300->udev->dev,\n\t\t\t\t \"vub300 ignoring EndPoint(%d) %02X\", i,\n\t\t\t\t endpoint->bEndpointAddress);\n\t\t}\n\t}\n\tif (vub300->cmnd_res_ep && vub300->cmnd_out_ep &&\n\t    vub300->data_inp_ep && vub300->data_out_ep) {\n\t\tdev_info(&vub300->udev->dev,\n\t\t\t \"vub300 %s packets\"\n\t\t\t \" using EndPoints %02X %02X %02X %02X\\n\",\n\t\t\t vub300->large_usb_packets ? \"LARGE\" : \"SMALL\",\n\t\t\t vub300->cmnd_out_ep, vub300->cmnd_res_ep,\n\t\t\t vub300->data_out_ep, vub300->data_inp_ep);\n\t\t \n\t} else {\n\t\tdev_err(&vub300->udev->dev,\n\t\t    \"Could not find two sets of bulk-in/out endpoint pairs\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto error5;\n\t}\n\tretval =\n\t\tusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\n\t\t\t\tGET_HC_INF0,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x0000, 0x0000, &vub300->hc_info,\n\t\t\t\tsizeof(vub300->hc_info), 1000);\n\tif (retval < 0)\n\t\tgoto error5;\n\tretval =\n\t\tusb_control_msg(vub300->udev, usb_sndctrlpipe(vub300->udev, 0),\n\t\t\t\tSET_ROM_WAIT_STATES,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\tfirmware_rom_wait_states, 0x0000, NULL, 0, 1000);\n\tif (retval < 0)\n\t\tgoto error5;\n\tdev_info(&vub300->udev->dev,\n\t\t \"operating_mode = %s %s %d MHz %s %d byte USB packets\\n\",\n\t\t (mmc->caps & MMC_CAP_SDIO_IRQ) ? \"IRQs\" : \"POLL\",\n\t\t (mmc->caps & MMC_CAP_4_BIT_DATA) ? \"4-bit\" : \"1-bit\",\n\t\t mmc->f_max / 1000000,\n\t\t pad_input_to_usb_pkt ? \"padding input data to\" : \"with\",\n\t\t vub300->large_usb_packets ? 512 : 64);\n\tretval =\n\t\tusb_control_msg(vub300->udev, usb_rcvctrlpipe(vub300->udev, 0),\n\t\t\t\tGET_SYSTEM_PORT_STATUS,\n\t\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,\n\t\t\t\t0x0000, 0x0000, &vub300->system_port_status,\n\t\t\t\tsizeof(vub300->system_port_status), 1000);\n\tif (retval < 0) {\n\t\tgoto error5;\n\t} else if (sizeof(vub300->system_port_status) == retval) {\n\t\tvub300->card_present =\n\t\t\t(0x0001 & vub300->system_port_status.port_flags) ? 1 : 0;\n\t\tvub300->read_only =\n\t\t\t(0x0010 & vub300->system_port_status.port_flags) ? 1 : 0;\n\t} else {\n\t\tretval = -EINVAL;\n\t\tgoto error5;\n\t}\n\tusb_set_intfdata(interface, vub300);\n\tINIT_DELAYED_WORK(&vub300->pollwork, vub300_pollwork_thread);\n\tINIT_WORK(&vub300->cmndwork, vub300_cmndwork_thread);\n\tINIT_WORK(&vub300->deadwork, vub300_deadwork_thread);\n\tkref_init(&vub300->kref);\n\ttimer_setup(&vub300->sg_transfer_timer, vub300_sg_timed_out, 0);\n\tkref_get(&vub300->kref);\n\ttimer_setup(&vub300->inactivity_timer,\n\t\t    vub300_inactivity_timer_expired, 0);\n\tvub300->inactivity_timer.expires = jiffies + HZ;\n\tadd_timer(&vub300->inactivity_timer);\n\tif (vub300->card_present)\n\t\tdev_info(&vub300->udev->dev,\n\t\t\t \"USB vub300 remote SDIO host controller[%d]\"\n\t\t\t \"connected with SD/SDIO card inserted\\n\",\n\t\t\t interface_to_InterfaceNumber(interface));\n\telse\n\t\tdev_info(&vub300->udev->dev,\n\t\t\t \"USB vub300 remote SDIO host controller[%d]\"\n\t\t\t \"connected with no SD/SDIO card inserted\\n\",\n\t\t\t interface_to_InterfaceNumber(interface));\n\tretval = mmc_add_host(mmc);\n\tif (retval)\n\t\tgoto error6;\n\n\treturn 0;\nerror6:\n\tdel_timer_sync(&vub300->inactivity_timer);\nerror5:\n\tmmc_free_host(mmc);\n\t \nerror4:\n\tusb_free_urb(command_res_urb);\nerror1:\n\tusb_free_urb(command_out_urb);\nerror0:\n\tusb_put_dev(udev);\n\treturn retval;\n}\n\nstatic void vub300_disconnect(struct usb_interface *interface)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = usb_get_intfdata(interface);\n\tif (!vub300 || !vub300->mmc) {\n\t\treturn;\n\t} else {\n\t\tstruct mmc_host *mmc = vub300->mmc;\n\t\tif (!vub300->mmc) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint ifnum = interface_to_InterfaceNumber(interface);\n\t\t\tusb_set_intfdata(interface, NULL);\n\t\t\t \n\t\t\tvub300->interface = NULL;\n\t\t\tkref_put(&vub300->kref, vub300_delete);\n\t\t\tmmc_remove_host(mmc);\n\t\t\tpr_info(\"USB vub300 remote SDIO host controller[%d]\"\n\t\t\t\t\" now disconnected\", ifnum);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n#ifdef CONFIG_PM\nstatic int vub300_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int vub300_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n#else\n#define vub300_suspend NULL\n#define vub300_resume NULL\n#endif\nstatic int vub300_pre_reset(struct usb_interface *intf)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = usb_get_intfdata(intf);\n\tmutex_lock(&vub300->cmd_mutex);\n\treturn 0;\n}\n\nstatic int vub300_post_reset(struct usb_interface *intf)\n{\t\t\t\t \n\tstruct vub300_mmc_host *vub300 = usb_get_intfdata(intf);\n\t \n\tvub300->errors = -EPIPE;\n\tmutex_unlock(&vub300->cmd_mutex);\n\treturn 0;\n}\n\nstatic struct usb_driver vub300_driver = {\n\t.name = \"vub300\",\n\t.probe = vub300_probe,\n\t.disconnect = vub300_disconnect,\n\t.suspend = vub300_suspend,\n\t.resume = vub300_resume,\n\t.pre_reset = vub300_pre_reset,\n\t.post_reset = vub300_post_reset,\n\t.id_table = vub300_table,\n\t.supports_autosuspend = 1,\n};\n\nstatic int __init vub300_init(void)\n{\t\t\t\t \n\tint result;\n\n\tpr_info(\"VUB300 Driver rom wait states = %02X irqpoll timeout = %04X\",\n\t\tfirmware_rom_wait_states, 0x0FFFF & firmware_irqpoll_timeout);\n\tcmndworkqueue = create_singlethread_workqueue(\"kvub300c\");\n\tif (!cmndworkqueue) {\n\t\tpr_err(\"not enough memory for the REQUEST workqueue\");\n\t\tresult = -ENOMEM;\n\t\tgoto out1;\n\t}\n\tpollworkqueue = create_singlethread_workqueue(\"kvub300p\");\n\tif (!pollworkqueue) {\n\t\tpr_err(\"not enough memory for the IRQPOLL workqueue\");\n\t\tresult = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tdeadworkqueue = create_singlethread_workqueue(\"kvub300d\");\n\tif (!deadworkqueue) {\n\t\tpr_err(\"not enough memory for the EXPIRED workqueue\");\n\t\tresult = -ENOMEM;\n\t\tgoto out3;\n\t}\n\tresult = usb_register(&vub300_driver);\n\tif (result) {\n\t\tpr_err(\"usb_register failed. Error number %d\", result);\n\t\tgoto out4;\n\t}\n\treturn 0;\nout4:\n\tdestroy_workqueue(deadworkqueue);\nout3:\n\tdestroy_workqueue(pollworkqueue);\nout2:\n\tdestroy_workqueue(cmndworkqueue);\nout1:\n\treturn result;\n}\n\nstatic void __exit vub300_exit(void)\n{\n\tusb_deregister(&vub300_driver);\n\tflush_workqueue(cmndworkqueue);\n\tflush_workqueue(pollworkqueue);\n\tflush_workqueue(deadworkqueue);\n\tdestroy_workqueue(cmndworkqueue);\n\tdestroy_workqueue(pollworkqueue);\n\tdestroy_workqueue(deadworkqueue);\n}\n\nmodule_init(vub300_init);\nmodule_exit(vub300_exit);\n\nMODULE_AUTHOR(\"Tony Olech <tony.olech@elandigitalsystems.com>\");\nMODULE_DESCRIPTION(\"VUB300 USB to SD/MMC/SDIO adapter driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}