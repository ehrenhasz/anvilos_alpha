{
  "module_name": "cqhci-crypto.c",
  "hash_id": "2084d16d01aa71d69a00a6a9138bb25fbb54b2b1517bb7a9ae7ef023cfc38540",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/cqhci-crypto.c",
  "human_readable_source": "\n \n\n#include <linux/blk-crypto.h>\n#include <linux/blk-crypto-profile.h>\n#include <linux/mmc/host.h>\n\n#include \"cqhci-crypto.h\"\n\n \nstatic const struct cqhci_crypto_alg_entry {\n\tenum cqhci_crypto_alg alg;\n\tenum cqhci_crypto_key_size key_size;\n} cqhci_crypto_algs[BLK_ENCRYPTION_MODE_MAX] = {\n\t[BLK_ENCRYPTION_MODE_AES_256_XTS] = {\n\t\t.alg = CQHCI_CRYPTO_ALG_AES_XTS,\n\t\t.key_size = CQHCI_CRYPTO_KEY_SIZE_256,\n\t},\n};\n\nstatic inline struct cqhci_host *\ncqhci_host_from_crypto_profile(struct blk_crypto_profile *profile)\n{\n\tstruct mmc_host *mmc =\n\t\tcontainer_of(profile, struct mmc_host, crypto_profile);\n\n\treturn mmc->cqe_private;\n}\n\nstatic int cqhci_crypto_program_key(struct cqhci_host *cq_host,\n\t\t\t\t    const union cqhci_crypto_cfg_entry *cfg,\n\t\t\t\t    int slot)\n{\n\tu32 slot_offset = cq_host->crypto_cfg_register + slot * sizeof(*cfg);\n\tint i;\n\n\tif (cq_host->ops->program_key)\n\t\treturn cq_host->ops->program_key(cq_host, cfg, slot);\n\n\t \n\tcqhci_writel(cq_host, 0, slot_offset + 16 * sizeof(cfg->reg_val[0]));\n\n\t \n\tfor (i = 0; i < 16; i++) {\n\t\tcqhci_writel(cq_host, le32_to_cpu(cfg->reg_val[i]),\n\t\t\t     slot_offset + i * sizeof(cfg->reg_val[0]));\n\t}\n\t \n\tcqhci_writel(cq_host, le32_to_cpu(cfg->reg_val[17]),\n\t\t     slot_offset + 17 * sizeof(cfg->reg_val[0]));\n\t \n\tcqhci_writel(cq_host, le32_to_cpu(cfg->reg_val[16]),\n\t\t     slot_offset + 16 * sizeof(cfg->reg_val[0]));\n\treturn 0;\n}\n\nstatic int cqhci_crypto_keyslot_program(struct blk_crypto_profile *profile,\n\t\t\t\t\tconst struct blk_crypto_key *key,\n\t\t\t\t\tunsigned int slot)\n\n{\n\tstruct cqhci_host *cq_host = cqhci_host_from_crypto_profile(profile);\n\tconst union cqhci_crypto_cap_entry *ccap_array =\n\t\tcq_host->crypto_cap_array;\n\tconst struct cqhci_crypto_alg_entry *alg =\n\t\t\t&cqhci_crypto_algs[key->crypto_cfg.crypto_mode];\n\tu8 data_unit_mask = key->crypto_cfg.data_unit_size / 512;\n\tint i;\n\tint cap_idx = -1;\n\tunion cqhci_crypto_cfg_entry cfg = {};\n\tint err;\n\n\tBUILD_BUG_ON(CQHCI_CRYPTO_KEY_SIZE_INVALID != 0);\n\tfor (i = 0; i < cq_host->crypto_capabilities.num_crypto_cap; i++) {\n\t\tif (ccap_array[i].algorithm_id == alg->alg &&\n\t\t    ccap_array[i].key_size == alg->key_size &&\n\t\t    (ccap_array[i].sdus_mask & data_unit_mask)) {\n\t\t\tcap_idx = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (WARN_ON(cap_idx < 0))\n\t\treturn -EOPNOTSUPP;\n\n\tcfg.data_unit_size = data_unit_mask;\n\tcfg.crypto_cap_idx = cap_idx;\n\tcfg.config_enable = CQHCI_CRYPTO_CONFIGURATION_ENABLE;\n\n\tif (ccap_array[cap_idx].algorithm_id == CQHCI_CRYPTO_ALG_AES_XTS) {\n\t\t \n\t\tmemcpy(cfg.crypto_key, key->raw, key->size/2);\n\t\tmemcpy(cfg.crypto_key + CQHCI_CRYPTO_KEY_MAX_SIZE/2,\n\t\t       key->raw + key->size/2, key->size/2);\n\t} else {\n\t\tmemcpy(cfg.crypto_key, key->raw, key->size);\n\t}\n\n\terr = cqhci_crypto_program_key(cq_host, &cfg, slot);\n\n\tmemzero_explicit(&cfg, sizeof(cfg));\n\treturn err;\n}\n\nstatic int cqhci_crypto_clear_keyslot(struct cqhci_host *cq_host, int slot)\n{\n\t \n\tunion cqhci_crypto_cfg_entry cfg = {};\n\n\treturn cqhci_crypto_program_key(cq_host, &cfg, slot);\n}\n\nstatic int cqhci_crypto_keyslot_evict(struct blk_crypto_profile *profile,\n\t\t\t\t      const struct blk_crypto_key *key,\n\t\t\t\t      unsigned int slot)\n{\n\tstruct cqhci_host *cq_host = cqhci_host_from_crypto_profile(profile);\n\n\treturn cqhci_crypto_clear_keyslot(cq_host, slot);\n}\n\n \nstatic const struct blk_crypto_ll_ops cqhci_crypto_ops = {\n\t.keyslot_program\t= cqhci_crypto_keyslot_program,\n\t.keyslot_evict\t\t= cqhci_crypto_keyslot_evict,\n};\n\nstatic enum blk_crypto_mode_num\ncqhci_find_blk_crypto_mode(union cqhci_crypto_cap_entry cap)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cqhci_crypto_algs); i++) {\n\t\tBUILD_BUG_ON(CQHCI_CRYPTO_KEY_SIZE_INVALID != 0);\n\t\tif (cqhci_crypto_algs[i].alg == cap.algorithm_id &&\n\t\t    cqhci_crypto_algs[i].key_size == cap.key_size)\n\t\t\treturn i;\n\t}\n\treturn BLK_ENCRYPTION_MODE_INVALID;\n}\n\n \nint cqhci_crypto_init(struct cqhci_host *cq_host)\n{\n\tstruct mmc_host *mmc = cq_host->mmc;\n\tstruct device *dev = mmc_dev(mmc);\n\tstruct blk_crypto_profile *profile = &mmc->crypto_profile;\n\tunsigned int num_keyslots;\n\tunsigned int cap_idx;\n\tenum blk_crypto_mode_num blk_mode_num;\n\tunsigned int slot;\n\tint err = 0;\n\n\tif (!(mmc->caps2 & MMC_CAP2_CRYPTO) ||\n\t    !(cqhci_readl(cq_host, CQHCI_CAP) & CQHCI_CAP_CS))\n\t\tgoto out;\n\n\tcq_host->crypto_capabilities.reg_val =\n\t\t\tcpu_to_le32(cqhci_readl(cq_host, CQHCI_CCAP));\n\n\tcq_host->crypto_cfg_register =\n\t\t(u32)cq_host->crypto_capabilities.config_array_ptr * 0x100;\n\n\tcq_host->crypto_cap_array =\n\t\tdevm_kcalloc(dev, cq_host->crypto_capabilities.num_crypto_cap,\n\t\t\t     sizeof(cq_host->crypto_cap_array[0]), GFP_KERNEL);\n\tif (!cq_host->crypto_cap_array) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tnum_keyslots = cq_host->crypto_capabilities.config_count + 1;\n\n\terr = devm_blk_crypto_profile_init(dev, profile, num_keyslots);\n\tif (err)\n\t\tgoto out;\n\n\tprofile->ll_ops = cqhci_crypto_ops;\n\tprofile->dev = dev;\n\n\t \n\tprofile->max_dun_bytes_supported = 4;\n\n\t \n\tfor (cap_idx = 0; cap_idx < cq_host->crypto_capabilities.num_crypto_cap;\n\t     cap_idx++) {\n\t\tcq_host->crypto_cap_array[cap_idx].reg_val =\n\t\t\tcpu_to_le32(cqhci_readl(cq_host,\n\t\t\t\t\t\tCQHCI_CRYPTOCAP +\n\t\t\t\t\t\tcap_idx * sizeof(__le32)));\n\t\tblk_mode_num = cqhci_find_blk_crypto_mode(\n\t\t\t\t\tcq_host->crypto_cap_array[cap_idx]);\n\t\tif (blk_mode_num == BLK_ENCRYPTION_MODE_INVALID)\n\t\t\tcontinue;\n\t\tprofile->modes_supported[blk_mode_num] |=\n\t\t\tcq_host->crypto_cap_array[cap_idx].sdus_mask * 512;\n\t}\n\n\t \n\tfor (slot = 0; slot < num_keyslots; slot++)\n\t\tcqhci_crypto_clear_keyslot(cq_host, slot);\n\n\t \n\tcq_host->caps |= CQHCI_TASK_DESC_SZ_128;\n\n\treturn 0;\n\nout:\n\tmmc->caps2 &= ~MMC_CAP2_CRYPTO;\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}