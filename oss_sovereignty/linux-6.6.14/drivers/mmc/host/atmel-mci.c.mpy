{
  "module_name": "atmel-mci.c",
  "hash_id": "b35356763e1b48b30b32623283b76c5f112e3bfd2b93642de4c4a3ddea4abc68",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/atmel-mci.c",
  "human_readable_source": "\n \n#include <linux/blkdev.h>\n#include <linux/clk.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/dmaengine.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/ioport.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/irq.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/scatterlist.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/types.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio.h>\n\n#include <linux/atmel_pdc.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n\n#include <asm/cacheflush.h>\n#include <asm/io.h>\n#include <asm/unaligned.h>\n\n#define ATMCI_MAX_NR_SLOTS\t2\n\n \n\n \n#define\tATMCI_CR\t\t\t0x0000\t \n#define\t\tATMCI_CR_MCIEN\t\t\tBIT(0)\t\t \n#define\t\tATMCI_CR_MCIDIS\t\t\tBIT(1)\t\t \n#define\t\tATMCI_CR_PWSEN\t\t\tBIT(2)\t\t \n#define\t\tATMCI_CR_PWSDIS\t\t\tBIT(3)\t\t \n#define\t\tATMCI_CR_SWRST\t\t\tBIT(7)\t\t \n#define\tATMCI_MR\t\t\t0x0004\t \n#define\t\tATMCI_MR_CLKDIV(x)\t\t((x) <<  0)\t \n#define\t\tATMCI_MR_PWSDIV(x)\t\t((x) <<  8)\t \n#define\t\tATMCI_MR_RDPROOF\t\tBIT(11)\t\t \n#define\t\tATMCI_MR_WRPROOF\t\tBIT(12)\t\t \n#define\t\tATMCI_MR_PDCFBYTE\t\tBIT(13)\t\t \n#define\t\tATMCI_MR_PDCPADV\t\tBIT(14)\t\t \n#define\t\tATMCI_MR_PDCMODE\t\tBIT(15)\t\t \n#define\t\tATMCI_MR_CLKODD(x)\t\t((x) << 16)\t \n#define\tATMCI_DTOR\t\t\t0x0008\t \n#define\t\tATMCI_DTOCYC(x)\t\t\t((x) <<  0)\t \n#define\t\tATMCI_DTOMUL(x)\t\t\t((x) <<  4)\t \n#define\tATMCI_SDCR\t\t\t0x000c\t \n#define\t\tATMCI_SDCSEL_SLOT_A\t\t(0 <<  0)\t \n#define\t\tATMCI_SDCSEL_SLOT_B\t\t(1 <<  0)\t \n#define\t\tATMCI_SDCSEL_MASK\t\t(3 <<  0)\n#define\t\tATMCI_SDCBUS_1BIT\t\t(0 <<  6)\t \n#define\t\tATMCI_SDCBUS_4BIT\t\t(2 <<  6)\t \n#define\t\tATMCI_SDCBUS_8BIT\t\t(3 <<  6)\t \n#define\t\tATMCI_SDCBUS_MASK\t\t(3 <<  6)\n#define\tATMCI_ARGR\t\t\t0x0010\t \n#define\tATMCI_CMDR\t\t\t0x0014\t \n#define\t\tATMCI_CMDR_CMDNB(x)\t\t((x) <<  0)\t \n#define\t\tATMCI_CMDR_RSPTYP_NONE\t\t(0 <<  6)\t \n#define\t\tATMCI_CMDR_RSPTYP_48BIT\t\t(1 <<  6)\t \n#define\t\tATMCI_CMDR_RSPTYP_136BIT\t(2 <<  6)\t \n#define\t\tATMCI_CMDR_SPCMD_INIT\t\t(1 <<  8)\t \n#define\t\tATMCI_CMDR_SPCMD_SYNC\t\t(2 <<  8)\t \n#define\t\tATMCI_CMDR_SPCMD_INT\t\t(4 <<  8)\t \n#define\t\tATMCI_CMDR_SPCMD_INTRESP\t(5 <<  8)\t \n#define\t\tATMCI_CMDR_OPDCMD\t\t(1 << 11)\t \n#define\t\tATMCI_CMDR_MAXLAT_5CYC\t\t(0 << 12)\t \n#define\t\tATMCI_CMDR_MAXLAT_64CYC\t\t(1 << 12)\t \n#define\t\tATMCI_CMDR_START_XFER\t\t(1 << 16)\t \n#define\t\tATMCI_CMDR_STOP_XFER\t\t(2 << 16)\t \n#define\t\tATMCI_CMDR_TRDIR_WRITE\t\t(0 << 18)\t \n#define\t\tATMCI_CMDR_TRDIR_READ\t\t(1 << 18)\t \n#define\t\tATMCI_CMDR_BLOCK\t\t(0 << 19)\t \n#define\t\tATMCI_CMDR_MULTI_BLOCK\t\t(1 << 19)\t \n#define\t\tATMCI_CMDR_STREAM\t\t(2 << 19)\t \n#define\t\tATMCI_CMDR_SDIO_BYTE\t\t(4 << 19)\t \n#define\t\tATMCI_CMDR_SDIO_BLOCK\t\t(5 << 19)\t \n#define\t\tATMCI_CMDR_SDIO_SUSPEND\t\t(1 << 24)\t \n#define\t\tATMCI_CMDR_SDIO_RESUME\t\t(2 << 24)\t \n#define\tATMCI_BLKR\t\t\t0x0018\t \n#define\t\tATMCI_BCNT(x)\t\t\t((x) <<  0)\t \n#define\t\tATMCI_BLKLEN(x)\t\t\t((x) << 16)\t \n#define\tATMCI_CSTOR\t\t\t0x001c\t \n#define\t\tATMCI_CSTOCYC(x)\t\t((x) <<  0)\t \n#define\t\tATMCI_CSTOMUL(x)\t\t((x) <<  4)\t \n#define\tATMCI_RSPR\t\t\t0x0020\t \n#define\tATMCI_RSPR1\t\t\t0x0024\t \n#define\tATMCI_RSPR2\t\t\t0x0028\t \n#define\tATMCI_RSPR3\t\t\t0x002c\t \n#define\tATMCI_RDR\t\t\t0x0030\t \n#define\tATMCI_TDR\t\t\t0x0034\t \n#define\tATMCI_SR\t\t\t0x0040\t \n#define\tATMCI_IER\t\t\t0x0044\t \n#define\tATMCI_IDR\t\t\t0x0048\t \n#define\tATMCI_IMR\t\t\t0x004c\t \n#define\t\tATMCI_CMDRDY\t\t\tBIT(0)\t\t \n#define\t\tATMCI_RXRDY\t\t\tBIT(1)\t\t \n#define\t\tATMCI_TXRDY\t\t\tBIT(2)\t\t \n#define\t\tATMCI_BLKE\t\t\tBIT(3)\t\t \n#define\t\tATMCI_DTIP\t\t\tBIT(4)\t\t \n#define\t\tATMCI_NOTBUSY\t\t\tBIT(5)\t\t \n#define\t\tATMCI_ENDRX\t\t\tBIT(6)\t\t \n#define\t\tATMCI_ENDTX\t\t\tBIT(7)\t\t \n#define\t\tATMCI_SDIOIRQA\t\t\tBIT(8)\t\t \n#define\t\tATMCI_SDIOIRQB\t\t\tBIT(9)\t\t \n#define\t\tATMCI_SDIOWAIT\t\t\tBIT(12)\t\t \n#define\t\tATMCI_CSRCV\t\t\tBIT(13)\t\t \n#define\t\tATMCI_RXBUFF\t\t\tBIT(14)\t\t \n#define\t\tATMCI_TXBUFE\t\t\tBIT(15)\t\t \n#define\t\tATMCI_RINDE\t\t\tBIT(16)\t\t \n#define\t\tATMCI_RDIRE\t\t\tBIT(17)\t\t \n#define\t\tATMCI_RCRCE\t\t\tBIT(18)\t\t \n#define\t\tATMCI_RENDE\t\t\tBIT(19)\t\t \n#define\t\tATMCI_RTOE\t\t\tBIT(20)\t\t \n#define\t\tATMCI_DCRCE\t\t\tBIT(21)\t\t \n#define\t\tATMCI_DTOE\t\t\tBIT(22)\t\t \n#define\t\tATMCI_CSTOE\t\t\tBIT(23)\t\t \n#define\t\tATMCI_BLKOVRE\t\t\tBIT(24)\t\t \n#define\t\tATMCI_DMADONE\t\t\tBIT(25)\t\t \n#define\t\tATMCI_FIFOEMPTY\t\t\tBIT(26)\t\t \n#define\t\tATMCI_XFRDONE\t\t\tBIT(27)\t\t \n#define\t\tATMCI_ACKRCV\t\t\tBIT(28)\t\t \n#define\t\tATMCI_ACKRCVE\t\t\tBIT(29)\t\t \n#define\t\tATMCI_OVRE\t\t\tBIT(30)\t\t \n#define\t\tATMCI_UNRE\t\t\tBIT(31)\t\t \n#define\tATMCI_DMA\t\t\t0x0050\t \n#define\t\tATMCI_DMA_OFFSET(x)\t\t((x) <<  0)\t \n#define\t\tATMCI_DMA_CHKSIZE(x)\t\t((x) <<  4)\t \n#define\t\tATMCI_DMAEN\t\t\tBIT(8)\t \n#define\tATMCI_CFG\t\t\t0x0054\t \n#define\t\tATMCI_CFG_FIFOMODE_1DATA\tBIT(0)\t\t \n#define\t\tATMCI_CFG_FERRCTRL_COR\t\tBIT(4)\t\t \n#define\t\tATMCI_CFG_HSMODE\t\tBIT(8)\t\t \n#define\t\tATMCI_CFG_LSYNC\t\t\tBIT(12)\t\t \n#define\tATMCI_WPMR\t\t\t0x00e4\t \n#define\t\tATMCI_WP_EN\t\t\tBIT(0)\t\t \n#define\t\tATMCI_WP_KEY\t\t\t(0x4d4349 << 8)\t \n#define\tATMCI_WPSR\t\t\t0x00e8\t \n#define\t\tATMCI_GET_WP_VS(x)\t\t((x) & 0x0f)\n#define\t\tATMCI_GET_WP_VSRC(x)\t\t(((x) >> 8) & 0xffff)\n#define\tATMCI_VERSION\t\t\t0x00FC   \n#define\tATMCI_FIFO_APERTURE\t\t0x0200\t \n\n \n#define\tATMCI_REGS_SIZE\t\t0x100\n\n \n#define\tatmci_readl(port, reg)\t\t\t\t\\\n\t__raw_readl((port)->regs + reg)\n#define\tatmci_writel(port, reg, value)\t\t\t\\\n\t__raw_writel((value), (port)->regs + reg)\n\n#define ATMCI_CMD_TIMEOUT_MS\t2000\n#define AUTOSUSPEND_DELAY\t50\n\n#define ATMCI_DATA_ERROR_FLAGS\t(ATMCI_DCRCE | ATMCI_DTOE | ATMCI_OVRE | ATMCI_UNRE)\n#define ATMCI_DMA_THRESHOLD\t16\n\nenum {\n\tEVENT_CMD_RDY = 0,\n\tEVENT_XFER_COMPLETE,\n\tEVENT_NOTBUSY,\n\tEVENT_DATA_ERROR,\n};\n\nenum atmel_mci_state {\n\tSTATE_IDLE = 0,\n\tSTATE_SENDING_CMD,\n\tSTATE_DATA_XFER,\n\tSTATE_WAITING_NOTBUSY,\n\tSTATE_SENDING_STOP,\n\tSTATE_END_REQUEST,\n};\n\nenum atmci_xfer_dir {\n\tXFER_RECEIVE = 0,\n\tXFER_TRANSMIT,\n};\n\nenum atmci_pdc_buf {\n\tPDC_FIRST_BUF = 0,\n\tPDC_SECOND_BUF,\n};\n\n \nstruct mci_slot_pdata {\n\tunsigned int\t\tbus_width;\n\tstruct gpio_desc        *detect_pin;\n\tstruct gpio_desc\t*wp_pin;\n\tbool\t\t\tnon_removable;\n};\n\n \nstruct mci_platform_data {\n\tvoid\t\t\t*dma_slave;\n\tdma_filter_fn\t\tdma_filter;\n\tstruct mci_slot_pdata\tslot[ATMCI_MAX_NR_SLOTS];\n};\n\nstruct atmel_mci_caps {\n\tbool    has_dma_conf_reg;\n\tbool    has_pdc;\n\tbool    has_cfg_reg;\n\tbool    has_cstor_reg;\n\tbool    has_highspeed;\n\tbool    has_rwproof;\n\tbool\thas_odd_clk_div;\n\tbool\thas_bad_data_ordering;\n\tbool\tneed_reset_after_xfer;\n\tbool\tneed_blksz_mul_4;\n\tbool\tneed_notbusy_for_read_ops;\n};\n\nstruct atmel_mci_dma {\n\tstruct dma_chan\t\t\t*chan;\n\tstruct dma_async_tx_descriptor\t*data_desc;\n};\n\n \nstruct atmel_mci {\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*regs;\n\n\tstruct scatterlist\t*sg;\n\tunsigned int\t\tsg_len;\n\tunsigned int\t\tpio_offset;\n\tunsigned int\t\t*buffer;\n\tunsigned int\t\tbuf_size;\n\tdma_addr_t\t\tbuf_phys_addr;\n\n\tstruct atmel_mci_slot\t*cur_slot;\n\tstruct mmc_request\t*mrq;\n\tstruct mmc_command\t*cmd;\n\tstruct mmc_data\t\t*data;\n\tunsigned int\t\tdata_size;\n\n\tstruct atmel_mci_dma\tdma;\n\tstruct dma_chan\t\t*data_chan;\n\tstruct dma_slave_config\tdma_conf;\n\n\tu32\t\t\tcmd_status;\n\tu32\t\t\tdata_status;\n\tu32\t\t\tstop_cmdr;\n\n\tstruct tasklet_struct\ttasklet;\n\tunsigned long\t\tpending_events;\n\tunsigned long\t\tcompleted_events;\n\tenum atmel_mci_state\tstate;\n\tstruct list_head\tqueue;\n\n\tbool\t\t\tneed_clock_update;\n\tbool\t\t\tneed_reset;\n\tstruct timer_list\ttimer;\n\tu32\t\t\tmode_reg;\n\tu32\t\t\tcfg_reg;\n\tunsigned long\t\tbus_hz;\n\tunsigned long\t\tmapbase;\n\tstruct clk\t\t*mck;\n\tstruct platform_device\t*pdev;\n\n\tstruct atmel_mci_slot\t*slot[ATMCI_MAX_NR_SLOTS];\n\n\tstruct atmel_mci_caps   caps;\n\n\tu32 (*prepare_data)(struct atmel_mci *host, struct mmc_data *data);\n\tvoid (*submit_data)(struct atmel_mci *host, struct mmc_data *data);\n\tvoid (*stop_transfer)(struct atmel_mci *host);\n};\n\n \nstruct atmel_mci_slot {\n\tstruct mmc_host\t\t*mmc;\n\tstruct atmel_mci\t*host;\n\n\tu32\t\t\tsdc_reg;\n\tu32\t\t\tsdio_irq;\n\n\tstruct mmc_request\t*mrq;\n\tstruct list_head\tqueue_node;\n\n\tunsigned int\t\tclock;\n\tunsigned long\t\tflags;\n#define ATMCI_CARD_PRESENT\t0\n#define ATMCI_CARD_NEED_INIT\t1\n#define ATMCI_SHUTDOWN\t\t2\n\n\tstruct gpio_desc        *detect_pin;\n\tstruct gpio_desc\t*wp_pin;\n\n\tstruct timer_list\tdetect_timer;\n};\n\n#define atmci_test_and_clear_pending(host, event)\t\t\\\n\ttest_and_clear_bit(event, &host->pending_events)\n#define atmci_set_completed(host, event)\t\t\t\\\n\tset_bit(event, &host->completed_events)\n#define atmci_set_pending(host, event)\t\t\t\t\\\n\tset_bit(event, &host->pending_events)\n\n \nstatic int atmci_req_show(struct seq_file *s, void *v)\n{\n\tstruct atmel_mci_slot\t*slot = s->private;\n\tstruct mmc_request\t*mrq;\n\tstruct mmc_command\t*cmd;\n\tstruct mmc_command\t*stop;\n\tstruct mmc_data\t\t*data;\n\n\t \n\tspin_lock_bh(&slot->host->lock);\n\tmrq = slot->mrq;\n\n\tif (mrq) {\n\t\tcmd = mrq->cmd;\n\t\tdata = mrq->data;\n\t\tstop = mrq->stop;\n\n\t\tif (cmd)\n\t\t\tseq_printf(s,\n\t\t\t\t\"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\\n\",\n\t\t\t\tcmd->opcode, cmd->arg, cmd->flags,\n\t\t\t\tcmd->resp[0], cmd->resp[1], cmd->resp[2],\n\t\t\t\tcmd->resp[3], cmd->error);\n\t\tif (data)\n\t\t\tseq_printf(s, \"DATA %u / %u * %u flg %x err %d\\n\",\n\t\t\t\tdata->bytes_xfered, data->blocks,\n\t\t\t\tdata->blksz, data->flags, data->error);\n\t\tif (stop)\n\t\t\tseq_printf(s,\n\t\t\t\t\"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\\n\",\n\t\t\t\tstop->opcode, stop->arg, stop->flags,\n\t\t\t\tstop->resp[0], stop->resp[1], stop->resp[2],\n\t\t\t\tstop->resp[3], stop->error);\n\t}\n\n\tspin_unlock_bh(&slot->host->lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(atmci_req);\n\nstatic void atmci_show_status_reg(struct seq_file *s,\n\t\tconst char *regname, u32 value)\n{\n\tstatic const char\t*sr_bit[] = {\n\t\t[0]\t= \"CMDRDY\",\n\t\t[1]\t= \"RXRDY\",\n\t\t[2]\t= \"TXRDY\",\n\t\t[3]\t= \"BLKE\",\n\t\t[4]\t= \"DTIP\",\n\t\t[5]\t= \"NOTBUSY\",\n\t\t[6]\t= \"ENDRX\",\n\t\t[7]\t= \"ENDTX\",\n\t\t[8]\t= \"SDIOIRQA\",\n\t\t[9]\t= \"SDIOIRQB\",\n\t\t[12]\t= \"SDIOWAIT\",\n\t\t[14]\t= \"RXBUFF\",\n\t\t[15]\t= \"TXBUFE\",\n\t\t[16]\t= \"RINDE\",\n\t\t[17]\t= \"RDIRE\",\n\t\t[18]\t= \"RCRCE\",\n\t\t[19]\t= \"RENDE\",\n\t\t[20]\t= \"RTOE\",\n\t\t[21]\t= \"DCRCE\",\n\t\t[22]\t= \"DTOE\",\n\t\t[23]\t= \"CSTOE\",\n\t\t[24]\t= \"BLKOVRE\",\n\t\t[25]\t= \"DMADONE\",\n\t\t[26]\t= \"FIFOEMPTY\",\n\t\t[27]\t= \"XFRDONE\",\n\t\t[30]\t= \"OVRE\",\n\t\t[31]\t= \"UNRE\",\n\t};\n\tunsigned int\t\ti;\n\n\tseq_printf(s, \"%s:\\t0x%08x\", regname, value);\n\tfor (i = 0; i < ARRAY_SIZE(sr_bit); i++) {\n\t\tif (value & (1 << i)) {\n\t\t\tif (sr_bit[i])\n\t\t\t\tseq_printf(s, \" %s\", sr_bit[i]);\n\t\t\telse\n\t\t\t\tseq_puts(s, \" UNKNOWN\");\n\t\t}\n\t}\n\tseq_putc(s, '\\n');\n}\n\nstatic int atmci_regs_show(struct seq_file *s, void *v)\n{\n\tstruct atmel_mci\t*host = s->private;\n\tu32\t\t\t*buf;\n\tint\t\t\tret = 0;\n\n\n\tbuf = kmalloc(ATMCI_REGS_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpm_runtime_get_sync(&host->pdev->dev);\n\n\t \n\tspin_lock_bh(&host->lock);\n\tmemcpy_fromio(buf, host->regs, ATMCI_REGS_SIZE);\n\tspin_unlock_bh(&host->lock);\n\n\tpm_runtime_mark_last_busy(&host->pdev->dev);\n\tpm_runtime_put_autosuspend(&host->pdev->dev);\n\n\tseq_printf(s, \"MR:\\t0x%08x%s%s \",\n\t\t\tbuf[ATMCI_MR / 4],\n\t\t\tbuf[ATMCI_MR / 4] & ATMCI_MR_RDPROOF ? \" RDPROOF\" : \"\",\n\t\t\tbuf[ATMCI_MR / 4] & ATMCI_MR_WRPROOF ? \" WRPROOF\" : \"\");\n\tif (host->caps.has_odd_clk_div)\n\t\tseq_printf(s, \"{CLKDIV,CLKODD}=%u\\n\",\n\t\t\t\t((buf[ATMCI_MR / 4] & 0xff) << 1)\n\t\t\t\t| ((buf[ATMCI_MR / 4] >> 16) & 1));\n\telse\n\t\tseq_printf(s, \"CLKDIV=%u\\n\",\n\t\t\t\t(buf[ATMCI_MR / 4] & 0xff));\n\tseq_printf(s, \"DTOR:\\t0x%08x\\n\", buf[ATMCI_DTOR / 4]);\n\tseq_printf(s, \"SDCR:\\t0x%08x\\n\", buf[ATMCI_SDCR / 4]);\n\tseq_printf(s, \"ARGR:\\t0x%08x\\n\", buf[ATMCI_ARGR / 4]);\n\tseq_printf(s, \"BLKR:\\t0x%08x BCNT=%u BLKLEN=%u\\n\",\n\t\t\tbuf[ATMCI_BLKR / 4],\n\t\t\tbuf[ATMCI_BLKR / 4] & 0xffff,\n\t\t\t(buf[ATMCI_BLKR / 4] >> 16) & 0xffff);\n\tif (host->caps.has_cstor_reg)\n\t\tseq_printf(s, \"CSTOR:\\t0x%08x\\n\", buf[ATMCI_CSTOR / 4]);\n\n\t \n\n\tatmci_show_status_reg(s, \"SR\", buf[ATMCI_SR / 4]);\n\tatmci_show_status_reg(s, \"IMR\", buf[ATMCI_IMR / 4]);\n\n\tif (host->caps.has_dma_conf_reg) {\n\t\tu32 val;\n\n\t\tval = buf[ATMCI_DMA / 4];\n\t\tseq_printf(s, \"DMA:\\t0x%08x OFFSET=%u CHKSIZE=%u%s\\n\",\n\t\t\t\tval, val & 3,\n\t\t\t\t((val >> 4) & 3) ?\n\t\t\t\t\t1 << (((val >> 4) & 3) + 1) : 1,\n\t\t\t\tval & ATMCI_DMAEN ? \" DMAEN\" : \"\");\n\t}\n\tif (host->caps.has_cfg_reg) {\n\t\tu32 val;\n\n\t\tval = buf[ATMCI_CFG / 4];\n\t\tseq_printf(s, \"CFG:\\t0x%08x%s%s%s%s\\n\",\n\t\t\t\tval,\n\t\t\t\tval & ATMCI_CFG_FIFOMODE_1DATA ? \" FIFOMODE_ONE_DATA\" : \"\",\n\t\t\t\tval & ATMCI_CFG_FERRCTRL_COR ? \" FERRCTRL_CLEAR_ON_READ\" : \"\",\n\t\t\t\tval & ATMCI_CFG_HSMODE ? \" HSMODE\" : \"\",\n\t\t\t\tval & ATMCI_CFG_LSYNC ? \" LSYNC\" : \"\");\n\t}\n\n\tkfree(buf);\n\n\treturn ret;\n}\n\nDEFINE_SHOW_ATTRIBUTE(atmci_regs);\n\nstatic void atmci_init_debugfs(struct atmel_mci_slot *slot)\n{\n\tstruct mmc_host\t\t*mmc = slot->mmc;\n\tstruct atmel_mci\t*host = slot->host;\n\tstruct dentry\t\t*root;\n\n\troot = mmc->debugfs_root;\n\tif (!root)\n\t\treturn;\n\n\tdebugfs_create_file(\"regs\", S_IRUSR, root, host, &atmci_regs_fops);\n\tdebugfs_create_file(\"req\", S_IRUSR, root, slot, &atmci_req_fops);\n\tdebugfs_create_u32(\"state\", S_IRUSR, root, &host->state);\n\tdebugfs_create_xul(\"pending_events\", S_IRUSR, root,\n\t\t\t   &host->pending_events);\n\tdebugfs_create_xul(\"completed_events\", S_IRUSR, root,\n\t\t\t   &host->completed_events);\n}\n\n#if defined(CONFIG_OF)\nstatic const struct of_device_id atmci_dt_ids[] = {\n\t{ .compatible = \"atmel,hsmci\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmci_dt_ids);\n\nstatic struct mci_platform_data*\natmci_of_init(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device_node *cnp;\n\tstruct mci_platform_data *pdata;\n\tu32 slot_id;\n\tint err;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"device node not found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfor_each_child_of_node(np, cnp) {\n\t\tif (of_property_read_u32(cnp, \"reg\", &slot_id)) {\n\t\t\tdev_warn(&pdev->dev, \"reg property is missing for %pOF\\n\",\n\t\t\t\t cnp);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (slot_id >= ATMCI_MAX_NR_SLOTS) {\n\t\t\tdev_warn(&pdev->dev, \"can't have more than %d slots\\n\",\n\t\t\t         ATMCI_MAX_NR_SLOTS);\n\t\t\tof_node_put(cnp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (of_property_read_u32(cnp, \"bus-width\",\n\t\t                         &pdata->slot[slot_id].bus_width))\n\t\t\tpdata->slot[slot_id].bus_width = 1;\n\n\t\tpdata->slot[slot_id].detect_pin =\n\t\t\tdevm_fwnode_gpiod_get(&pdev->dev, of_fwnode_handle(cnp),\n\t\t\t\t\t      \"cd\", GPIOD_IN, \"cd-gpios\");\n\t\terr = PTR_ERR_OR_ZERO(pdata->slot[slot_id].detect_pin);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\treturn ERR_PTR(err);\n\t\t\tpdata->slot[slot_id].detect_pin = NULL;\n\t\t}\n\n\t\tpdata->slot[slot_id].non_removable =\n\t\t\tof_property_read_bool(cnp, \"non-removable\");\n\n\t\tpdata->slot[slot_id].wp_pin =\n\t\t\tdevm_fwnode_gpiod_get(&pdev->dev, of_fwnode_handle(cnp),\n\t\t\t\t\t      \"wp\", GPIOD_IN, \"wp-gpios\");\n\t\terr = PTR_ERR_OR_ZERO(pdata->slot[slot_id].wp_pin);\n\t\tif (err) {\n\t\t\tif (err != -ENOENT)\n\t\t\t\treturn ERR_PTR(err);\n\t\t\tpdata->slot[slot_id].wp_pin = NULL;\n\t\t}\n\t}\n\n\treturn pdata;\n}\n#else  \nstatic inline struct mci_platform_data*\natmci_of_init(struct platform_device *dev)\n{\n\treturn ERR_PTR(-EINVAL);\n}\n#endif\n\nstatic inline unsigned int atmci_get_version(struct atmel_mci *host)\n{\n\treturn atmci_readl(host, ATMCI_VERSION) & 0x00000fff;\n}\n\n \nstatic inline unsigned int atmci_convert_chksize(struct atmel_mci *host,\n\t\t\t\t\t\t unsigned int maxburst)\n{\n\tunsigned int version = atmci_get_version(host);\n\tunsigned int offset = 2;\n\n\tif (version >= 0x600)\n\t\toffset = 1;\n\n\tif (maxburst > 1)\n\t\treturn fls(maxburst) - offset;\n\telse\n\t\treturn 0;\n}\n\nstatic void atmci_timeout_timer(struct timer_list *t)\n{\n\tstruct atmel_mci *host;\n\n\thost = from_timer(host, t, timer);\n\n\tdev_dbg(&host->pdev->dev, \"software timeout\\n\");\n\n\tif (host->mrq->cmd->data) {\n\t\thost->mrq->cmd->data->error = -ETIMEDOUT;\n\t\thost->data = NULL;\n\t\t \n\t\tif (host->state == STATE_DATA_XFER)\n\t\t\thost->stop_transfer(host);\n\t} else {\n\t\thost->mrq->cmd->error = -ETIMEDOUT;\n\t\thost->cmd = NULL;\n\t}\n\thost->need_reset = 1;\n\thost->state = STATE_END_REQUEST;\n\tsmp_wmb();\n\ttasklet_schedule(&host->tasklet);\n}\n\nstatic inline unsigned int atmci_ns_to_clocks(struct atmel_mci *host,\n\t\t\t\t\tunsigned int ns)\n{\n\t \n\tunsigned int us = DIV_ROUND_UP(ns, 1000);\n\n\t \n\treturn us * (DIV_ROUND_UP(host->bus_hz, 2000000));\n}\n\nstatic void atmci_set_timeout(struct atmel_mci *host,\n\t\tstruct atmel_mci_slot *slot, struct mmc_data *data)\n{\n\tstatic unsigned\tdtomul_to_shift[] = {\n\t\t0, 4, 7, 8, 10, 12, 16, 20\n\t};\n\tunsigned\ttimeout;\n\tunsigned\tdtocyc;\n\tunsigned\tdtomul;\n\n\ttimeout = atmci_ns_to_clocks(host, data->timeout_ns)\n\t\t+ data->timeout_clks;\n\n\tfor (dtomul = 0; dtomul < 8; dtomul++) {\n\t\tunsigned shift = dtomul_to_shift[dtomul];\n\t\tdtocyc = (timeout + (1 << shift) - 1) >> shift;\n\t\tif (dtocyc < 15)\n\t\t\tbreak;\n\t}\n\n\tif (dtomul >= 8) {\n\t\tdtomul = 7;\n\t\tdtocyc = 15;\n\t}\n\n\tdev_vdbg(&slot->mmc->class_dev, \"setting timeout to %u cycles\\n\",\n\t\t\tdtocyc << dtomul_to_shift[dtomul]);\n\tatmci_writel(host, ATMCI_DTOR, (ATMCI_DTOMUL(dtomul) | ATMCI_DTOCYC(dtocyc)));\n}\n\n \nstatic u32 atmci_prepare_command(struct mmc_host *mmc,\n\t\t\t\t struct mmc_command *cmd)\n{\n\tstruct mmc_data\t*data;\n\tu32\t\tcmdr;\n\n\tcmd->error = -EINPROGRESS;\n\n\tcmdr = ATMCI_CMDR_CMDNB(cmd->opcode);\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tif (cmd->flags & MMC_RSP_136)\n\t\t\tcmdr |= ATMCI_CMDR_RSPTYP_136BIT;\n\t\telse\n\t\t\tcmdr |= ATMCI_CMDR_RSPTYP_48BIT;\n\t}\n\n\t \n\tcmdr |= ATMCI_CMDR_MAXLAT_64CYC;\n\n\tif (mmc->ios.bus_mode == MMC_BUSMODE_OPENDRAIN)\n\t\tcmdr |= ATMCI_CMDR_OPDCMD;\n\n\tdata = cmd->data;\n\tif (data) {\n\t\tcmdr |= ATMCI_CMDR_START_XFER;\n\n\t\tif (cmd->opcode == SD_IO_RW_EXTENDED) {\n\t\t\tcmdr |= ATMCI_CMDR_SDIO_BLOCK;\n\t\t} else {\n\t\t\tif (data->blocks > 1)\n\t\t\t\tcmdr |= ATMCI_CMDR_MULTI_BLOCK;\n\t\t\telse\n\t\t\t\tcmdr |= ATMCI_CMDR_BLOCK;\n\t\t}\n\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tcmdr |= ATMCI_CMDR_TRDIR_READ;\n\t}\n\n\treturn cmdr;\n}\n\nstatic void atmci_send_command(struct atmel_mci *host,\n\t\tstruct mmc_command *cmd, u32 cmd_flags)\n{\n\tunsigned int timeout_ms = cmd->busy_timeout ? cmd->busy_timeout :\n\t\tATMCI_CMD_TIMEOUT_MS;\n\n\tWARN_ON(host->cmd);\n\thost->cmd = cmd;\n\n\tdev_vdbg(&host->pdev->dev,\n\t\t\t\"start command: ARGR=0x%08x CMDR=0x%08x\\n\",\n\t\t\tcmd->arg, cmd_flags);\n\n\tatmci_writel(host, ATMCI_ARGR, cmd->arg);\n\tatmci_writel(host, ATMCI_CMDR, cmd_flags);\n\n\tmod_timer(&host->timer, jiffies + msecs_to_jiffies(timeout_ms));\n}\n\nstatic void atmci_send_stop_cmd(struct atmel_mci *host, struct mmc_data *data)\n{\n\tdev_dbg(&host->pdev->dev, \"send stop command\\n\");\n\tatmci_send_command(host, data->stop, host->stop_cmdr);\n\tatmci_writel(host, ATMCI_IER, ATMCI_CMDRDY);\n}\n\n \nstatic void atmci_pdc_set_single_buf(struct atmel_mci *host,\n\tenum atmci_xfer_dir dir, enum atmci_pdc_buf buf_nb)\n{\n\tu32 pointer_reg, counter_reg;\n\tunsigned int buf_size;\n\n\tif (dir == XFER_RECEIVE) {\n\t\tpointer_reg = ATMEL_PDC_RPR;\n\t\tcounter_reg = ATMEL_PDC_RCR;\n\t} else {\n\t\tpointer_reg = ATMEL_PDC_TPR;\n\t\tcounter_reg = ATMEL_PDC_TCR;\n\t}\n\n\tif (buf_nb == PDC_SECOND_BUF) {\n\t\tpointer_reg += ATMEL_PDC_SCND_BUF_OFF;\n\t\tcounter_reg += ATMEL_PDC_SCND_BUF_OFF;\n\t}\n\n\tif (!host->caps.has_rwproof) {\n\t\tbuf_size = host->buf_size;\n\t\tatmci_writel(host, pointer_reg, host->buf_phys_addr);\n\t} else {\n\t\tbuf_size = sg_dma_len(host->sg);\n\t\tatmci_writel(host, pointer_reg, sg_dma_address(host->sg));\n\t}\n\n\tif (host->data_size <= buf_size) {\n\t\tif (host->data_size & 0x3) {\n\t\t\t \n\t\t\tatmci_writel(host, counter_reg, host->data_size);\n\t\t\tatmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCFBYTE);\n\t\t} else {\n\t\t\t \n\t\t\tatmci_writel(host, counter_reg, host->data_size / 4);\n\t\t}\n\t\thost->data_size = 0;\n\t} else {\n\t\t \n\t\tatmci_writel(host, counter_reg, sg_dma_len(host->sg) / 4);\n\t\thost->data_size -= sg_dma_len(host->sg);\n\t\tif (host->data_size)\n\t\t\thost->sg = sg_next(host->sg);\n\t}\n}\n\n \nstatic void atmci_pdc_set_both_buf(struct atmel_mci *host, int dir)\n{\n\tatmci_pdc_set_single_buf(host, dir, PDC_FIRST_BUF);\n\tif (host->data_size)\n\t\tatmci_pdc_set_single_buf(host, dir, PDC_SECOND_BUF);\n}\n\n \nstatic void atmci_pdc_cleanup(struct atmel_mci *host)\n{\n\tstruct mmc_data         *data = host->data;\n\n\tif (data)\n\t\tdma_unmap_sg(&host->pdev->dev,\n\t\t\t\tdata->sg, data->sg_len,\n\t\t\t\tmmc_get_dma_dir(data));\n}\n\n \nstatic void atmci_pdc_complete(struct atmel_mci *host)\n{\n\tint transfer_size = host->data->blocks * host->data->blksz;\n\tint i;\n\n\tatmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\n\n\tif ((!host->caps.has_rwproof)\n\t    && (host->data->flags & MMC_DATA_READ)) {\n\t\tif (host->caps.has_bad_data_ordering)\n\t\t\tfor (i = 0; i < transfer_size; i++)\n\t\t\t\thost->buffer[i] = swab32(host->buffer[i]);\n\t\tsg_copy_from_buffer(host->data->sg, host->data->sg_len,\n\t\t                    host->buffer, transfer_size);\n\t}\n\n\tatmci_pdc_cleanup(host);\n\n\tdev_dbg(&host->pdev->dev, \"(%s) set pending xfer complete\\n\", __func__);\n\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n\ttasklet_schedule(&host->tasklet);\n}\n\nstatic void atmci_dma_cleanup(struct atmel_mci *host)\n{\n\tstruct mmc_data                 *data = host->data;\n\n\tif (data)\n\t\tdma_unmap_sg(host->dma.chan->device->dev,\n\t\t\t\tdata->sg, data->sg_len,\n\t\t\t\tmmc_get_dma_dir(data));\n}\n\n \nstatic void atmci_dma_complete(void *arg)\n{\n\tstruct atmel_mci\t*host = arg;\n\tstruct mmc_data\t\t*data = host->data;\n\n\tdev_vdbg(&host->pdev->dev, \"DMA complete\\n\");\n\n\tif (host->caps.has_dma_conf_reg)\n\t\t \n\t\tatmci_writel(host, ATMCI_DMA, atmci_readl(host, ATMCI_DMA) & ~ATMCI_DMAEN);\n\n\tatmci_dma_cleanup(host);\n\n\t \n\tif (data) {\n\t\tdev_dbg(&host->pdev->dev,\n\t\t        \"(%s) set pending xfer complete\\n\", __func__);\n\t\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n\t\ttasklet_schedule(&host->tasklet);\n\n\t\t \n\t\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\t}\n}\n\n \nstatic u32 atmci_prepare_data(struct atmel_mci *host, struct mmc_data *data)\n{\n\tu32 iflags;\n\n\tdata->error = -EINPROGRESS;\n\n\thost->sg = data->sg;\n\thost->sg_len = data->sg_len;\n\thost->data = data;\n\thost->data_chan = NULL;\n\n\tiflags = ATMCI_DATA_ERROR_FLAGS;\n\n\t \n\tif (data->blocks * data->blksz < 12\n\t\t\t|| (data->blocks * data->blksz) & 3)\n\t\thost->need_reset = true;\n\n\thost->pio_offset = 0;\n\tif (data->flags & MMC_DATA_READ)\n\t\tiflags |= ATMCI_RXRDY;\n\telse\n\t\tiflags |= ATMCI_TXRDY;\n\n\treturn iflags;\n}\n\n \nstatic u32\natmci_prepare_data_pdc(struct atmel_mci *host, struct mmc_data *data)\n{\n\tu32 iflags, tmp;\n\tint i;\n\n\tdata->error = -EINPROGRESS;\n\n\thost->data = data;\n\thost->sg = data->sg;\n\tiflags = ATMCI_DATA_ERROR_FLAGS;\n\n\t \n\tatmci_writel(host, ATMCI_MR, host->mode_reg | ATMCI_MR_PDCMODE);\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tiflags |= ATMCI_ENDRX | ATMCI_RXBUFF;\n\telse\n\t\tiflags |= ATMCI_ENDTX | ATMCI_TXBUFE | ATMCI_BLKE;\n\n\t \n\ttmp = atmci_readl(host, ATMCI_MR);\n\ttmp &= 0x0000ffff;\n\ttmp |= ATMCI_BLKLEN(data->blksz);\n\tatmci_writel(host, ATMCI_MR, tmp);\n\n\t \n\thost->data_size = data->blocks * data->blksz;\n\tdma_map_sg(&host->pdev->dev, data->sg, data->sg_len,\n\t\t   mmc_get_dma_dir(data));\n\n\tif ((!host->caps.has_rwproof)\n\t    && (host->data->flags & MMC_DATA_WRITE)) {\n\t\tsg_copy_to_buffer(host->data->sg, host->data->sg_len,\n\t\t                  host->buffer, host->data_size);\n\t\tif (host->caps.has_bad_data_ordering)\n\t\t\tfor (i = 0; i < host->data_size; i++)\n\t\t\t\thost->buffer[i] = swab32(host->buffer[i]);\n\t}\n\n\tif (host->data_size)\n\t\tatmci_pdc_set_both_buf(host, data->flags & MMC_DATA_READ ?\n\t\t\t\t       XFER_RECEIVE : XFER_TRANSMIT);\n\treturn iflags;\n}\n\nstatic u32\natmci_prepare_data_dma(struct atmel_mci *host, struct mmc_data *data)\n{\n\tstruct dma_chan\t\t\t*chan;\n\tstruct dma_async_tx_descriptor\t*desc;\n\tstruct scatterlist\t\t*sg;\n\tunsigned int\t\t\ti;\n\tenum dma_transfer_direction\tslave_dirn;\n\tunsigned int\t\t\tsglen;\n\tu32\t\t\t\tmaxburst;\n\tu32 iflags;\n\n\tdata->error = -EINPROGRESS;\n\n\tWARN_ON(host->data);\n\thost->sg = NULL;\n\thost->data = data;\n\n\tiflags = ATMCI_DATA_ERROR_FLAGS;\n\n\t \n\tif (data->blocks * data->blksz < ATMCI_DMA_THRESHOLD)\n\t\treturn atmci_prepare_data(host, data);\n\tif (data->blksz & 3)\n\t\treturn atmci_prepare_data(host, data);\n\n\tfor_each_sg(data->sg, sg, data->sg_len, i) {\n\t\tif (sg->offset & 3 || sg->length & 3)\n\t\t\treturn atmci_prepare_data(host, data);\n\t}\n\n\t \n\tif (!host->dma.chan)\n\t\treturn -ENODEV;\n\n\tchan = host->dma.chan;\n\thost->data_chan = chan;\n\n\tif (data->flags & MMC_DATA_READ) {\n\t\thost->dma_conf.direction = slave_dirn = DMA_DEV_TO_MEM;\n\t\tmaxburst = atmci_convert_chksize(host,\n\t\t\t\t\t\t host->dma_conf.src_maxburst);\n\t} else {\n\t\thost->dma_conf.direction = slave_dirn = DMA_MEM_TO_DEV;\n\t\tmaxburst = atmci_convert_chksize(host,\n\t\t\t\t\t\t host->dma_conf.dst_maxburst);\n\t}\n\n\tif (host->caps.has_dma_conf_reg)\n\t\tatmci_writel(host, ATMCI_DMA, ATMCI_DMA_CHKSIZE(maxburst) |\n\t\t\tATMCI_DMAEN);\n\n\tsglen = dma_map_sg(chan->device->dev, data->sg,\n\t\t\tdata->sg_len, mmc_get_dma_dir(data));\n\n\tdmaengine_slave_config(chan, &host->dma_conf);\n\tdesc = dmaengine_prep_slave_sg(chan,\n\t\t\tdata->sg, sglen, slave_dirn,\n\t\t\tDMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\tif (!desc)\n\t\tgoto unmap_exit;\n\n\thost->dma.data_desc = desc;\n\tdesc->callback = atmci_dma_complete;\n\tdesc->callback_param = host;\n\n\treturn iflags;\nunmap_exit:\n\tdma_unmap_sg(chan->device->dev, data->sg, data->sg_len,\n\t\t     mmc_get_dma_dir(data));\n\treturn -ENOMEM;\n}\n\nstatic void\natmci_submit_data(struct atmel_mci *host, struct mmc_data *data)\n{\n\treturn;\n}\n\n \nstatic void\natmci_submit_data_pdc(struct atmel_mci *host, struct mmc_data *data)\n{\n\tif (data->flags & MMC_DATA_READ)\n\t\tatmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTEN);\n\telse\n\t\tatmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);\n}\n\nstatic void\natmci_submit_data_dma(struct atmel_mci *host, struct mmc_data *data)\n{\n\tstruct dma_chan\t\t\t*chan = host->data_chan;\n\tstruct dma_async_tx_descriptor\t*desc = host->dma.data_desc;\n\n\tif (chan) {\n\t\tdmaengine_submit(desc);\n\t\tdma_async_issue_pending(chan);\n\t}\n}\n\nstatic void atmci_stop_transfer(struct atmel_mci *host)\n{\n\tdev_dbg(&host->pdev->dev,\n\t        \"(%s) set pending xfer complete\\n\", __func__);\n\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n}\n\n \nstatic void atmci_stop_transfer_pdc(struct atmel_mci *host)\n{\n\tatmci_writel(host, ATMEL_PDC_PTCR, ATMEL_PDC_RXTDIS | ATMEL_PDC_TXTDIS);\n}\n\nstatic void atmci_stop_transfer_dma(struct atmel_mci *host)\n{\n\tstruct dma_chan *chan = host->data_chan;\n\n\tif (chan) {\n\t\tdmaengine_terminate_all(chan);\n\t\tatmci_dma_cleanup(host);\n\t} else {\n\t\t \n\t\tdev_dbg(&host->pdev->dev,\n\t\t        \"(%s) set pending xfer complete\\n\", __func__);\n\t\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n\t\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\t}\n}\n\n \nstatic void atmci_start_request(struct atmel_mci *host,\n\t\tstruct atmel_mci_slot *slot)\n{\n\tstruct mmc_request\t*mrq;\n\tstruct mmc_command\t*cmd;\n\tstruct mmc_data\t\t*data;\n\tu32\t\t\tiflags;\n\tu32\t\t\tcmdflags;\n\n\tmrq = slot->mrq;\n\thost->cur_slot = slot;\n\thost->mrq = mrq;\n\n\thost->pending_events = 0;\n\thost->completed_events = 0;\n\thost->cmd_status = 0;\n\thost->data_status = 0;\n\n\tdev_dbg(&host->pdev->dev, \"start request: cmd %u\\n\", mrq->cmd->opcode);\n\n\tif (host->need_reset || host->caps.need_reset_after_xfer) {\n\t\tiflags = atmci_readl(host, ATMCI_IMR);\n\t\tiflags &= (ATMCI_SDIOIRQA | ATMCI_SDIOIRQB);\n\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\n\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\n\t\tatmci_writel(host, ATMCI_MR, host->mode_reg);\n\t\tif (host->caps.has_cfg_reg)\n\t\t\tatmci_writel(host, ATMCI_CFG, host->cfg_reg);\n\t\tatmci_writel(host, ATMCI_IER, iflags);\n\t\thost->need_reset = false;\n\t}\n\tatmci_writel(host, ATMCI_SDCR, slot->sdc_reg);\n\n\tiflags = atmci_readl(host, ATMCI_IMR);\n\tif (iflags & ~(ATMCI_SDIOIRQA | ATMCI_SDIOIRQB))\n\t\tdev_dbg(&slot->mmc->class_dev, \"WARNING: IMR=0x%08x\\n\",\n\t\t\t\tiflags);\n\n\tif (unlikely(test_and_clear_bit(ATMCI_CARD_NEED_INIT, &slot->flags))) {\n\t\t \n\t\tatmci_writel(host, ATMCI_CMDR, ATMCI_CMDR_SPCMD_INIT);\n\t\twhile (!(atmci_readl(host, ATMCI_SR) & ATMCI_CMDRDY))\n\t\t\tcpu_relax();\n\t}\n\tiflags = 0;\n\tdata = mrq->data;\n\tif (data) {\n\t\tatmci_set_timeout(host, slot, data);\n\n\t\t \n\t\tatmci_writel(host, ATMCI_BLKR, ATMCI_BCNT(data->blocks)\n\t\t\t\t| ATMCI_BLKLEN(data->blksz));\n\t\tdev_vdbg(&slot->mmc->class_dev, \"BLKR=0x%08x\\n\",\n\t\t\tATMCI_BCNT(data->blocks) | ATMCI_BLKLEN(data->blksz));\n\n\t\tiflags |= host->prepare_data(host, data);\n\t}\n\n\tiflags |= ATMCI_CMDRDY;\n\tcmd = mrq->cmd;\n\tcmdflags = atmci_prepare_command(slot->mmc, cmd);\n\n\t \n\tif (host->submit_data != &atmci_submit_data_dma)\n\t\tatmci_send_command(host, cmd, cmdflags);\n\n\tif (data)\n\t\thost->submit_data(host, data);\n\n\tif (host->submit_data == &atmci_submit_data_dma)\n\t\tatmci_send_command(host, cmd, cmdflags);\n\n\tif (mrq->stop) {\n\t\thost->stop_cmdr = atmci_prepare_command(slot->mmc, mrq->stop);\n\t\thost->stop_cmdr |= ATMCI_CMDR_STOP_XFER;\n\t\tif (!(data->flags & MMC_DATA_WRITE))\n\t\t\thost->stop_cmdr |= ATMCI_CMDR_TRDIR_READ;\n\t\thost->stop_cmdr |= ATMCI_CMDR_MULTI_BLOCK;\n\t}\n\n\t \n\tatmci_writel(host, ATMCI_IER, iflags);\n}\n\nstatic void atmci_queue_request(struct atmel_mci *host,\n\t\tstruct atmel_mci_slot *slot, struct mmc_request *mrq)\n{\n\tdev_vdbg(&slot->mmc->class_dev, \"queue request: state=%d\\n\",\n\t\t\thost->state);\n\n\tspin_lock_bh(&host->lock);\n\tslot->mrq = mrq;\n\tif (host->state == STATE_IDLE) {\n\t\thost->state = STATE_SENDING_CMD;\n\t\tatmci_start_request(host, slot);\n\t} else {\n\t\tdev_dbg(&host->pdev->dev, \"queue request\\n\");\n\t\tlist_add_tail(&slot->queue_node, &host->queue);\n\t}\n\tspin_unlock_bh(&host->lock);\n}\n\nstatic void atmci_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct atmel_mci_slot\t*slot = mmc_priv(mmc);\n\tstruct atmel_mci\t*host = slot->host;\n\tstruct mmc_data\t\t*data;\n\n\tWARN_ON(slot->mrq);\n\tdev_dbg(&host->pdev->dev, \"MRQ: cmd %u\\n\", mrq->cmd->opcode);\n\n\t \n\tif (!test_bit(ATMCI_CARD_PRESENT, &slot->flags)) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\t \n\tdata = mrq->data;\n\tif (data && data->blocks > 1 && data->blksz & 3) {\n\t\tmrq->cmd->error = -EINVAL;\n\t\tmmc_request_done(mmc, mrq);\n\t}\n\n\tatmci_queue_request(host, slot, mrq);\n}\n\nstatic void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct atmel_mci_slot\t*slot = mmc_priv(mmc);\n\tstruct atmel_mci\t*host = slot->host;\n\tunsigned int\t\ti;\n\n\tslot->sdc_reg &= ~ATMCI_SDCBUS_MASK;\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tslot->sdc_reg |= ATMCI_SDCBUS_1BIT;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tslot->sdc_reg |= ATMCI_SDCBUS_4BIT;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_8:\n\t\tslot->sdc_reg |= ATMCI_SDCBUS_8BIT;\n\t\tbreak;\n\t}\n\n\tif (ios->clock) {\n\t\tunsigned int clock_min = ~0U;\n\t\tint clkdiv;\n\n\t\tspin_lock_bh(&host->lock);\n\t\tif (!host->mode_reg) {\n\t\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\n\t\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\n\t\t\tif (host->caps.has_cfg_reg)\n\t\t\t\tatmci_writel(host, ATMCI_CFG, host->cfg_reg);\n\t\t}\n\n\t\t \n\t\tslot->clock = ios->clock;\n\t\tfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\n\t\t\tif (host->slot[i] && host->slot[i]->clock\n\t\t\t\t\t&& host->slot[i]->clock < clock_min)\n\t\t\t\tclock_min = host->slot[i]->clock;\n\t\t}\n\n\t\t \n\t\tif (host->caps.has_odd_clk_div) {\n\t\t\tclkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2;\n\t\t\tif (clkdiv < 0) {\n\t\t\t\tdev_warn(&mmc->class_dev,\n\t\t\t\t\t \"clock %u too fast; using %lu\\n\",\n\t\t\t\t\t clock_min, host->bus_hz / 2);\n\t\t\t\tclkdiv = 0;\n\t\t\t} else if (clkdiv > 511) {\n\t\t\t\tdev_warn(&mmc->class_dev,\n\t\t\t\t         \"clock %u too slow; using %lu\\n\",\n\t\t\t\t         clock_min, host->bus_hz / (511 + 2));\n\t\t\t\tclkdiv = 511;\n\t\t\t}\n\t\t\thost->mode_reg = ATMCI_MR_CLKDIV(clkdiv >> 1)\n\t\t\t                 | ATMCI_MR_CLKODD(clkdiv & 1);\n\t\t} else {\n\t\t\tclkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;\n\t\t\tif (clkdiv > 255) {\n\t\t\t\tdev_warn(&mmc->class_dev,\n\t\t\t\t         \"clock %u too slow; using %lu\\n\",\n\t\t\t\t         clock_min, host->bus_hz / (2 * 256));\n\t\t\t\tclkdiv = 255;\n\t\t\t}\n\t\t\thost->mode_reg = ATMCI_MR_CLKDIV(clkdiv);\n\t\t}\n\n\t\t \n\t\tif (host->caps.has_rwproof)\n\t\t\thost->mode_reg |= (ATMCI_MR_WRPROOF | ATMCI_MR_RDPROOF);\n\n\t\tif (host->caps.has_cfg_reg) {\n\t\t\t \n\t\t\tif (ios->timing == MMC_TIMING_SD_HS)\n\t\t\t\thost->cfg_reg |= ATMCI_CFG_HSMODE;\n\t\t\telse\n\t\t\t\thost->cfg_reg &= ~ATMCI_CFG_HSMODE;\n\t\t}\n\n\t\tif (list_empty(&host->queue)) {\n\t\t\tatmci_writel(host, ATMCI_MR, host->mode_reg);\n\t\t\tif (host->caps.has_cfg_reg)\n\t\t\t\tatmci_writel(host, ATMCI_CFG, host->cfg_reg);\n\t\t} else {\n\t\t\thost->need_clock_update = true;\n\t\t}\n\n\t\tspin_unlock_bh(&host->lock);\n\t} else {\n\t\tbool any_slot_active = false;\n\n\t\tspin_lock_bh(&host->lock);\n\t\tslot->clock = 0;\n\t\tfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\n\t\t\tif (host->slot[i] && host->slot[i]->clock) {\n\t\t\t\tany_slot_active = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!any_slot_active) {\n\t\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_MCIDIS);\n\t\t\tif (host->mode_reg) {\n\t\t\t\tatmci_readl(host, ATMCI_MR);\n\t\t\t}\n\t\t\thost->mode_reg = 0;\n\t\t}\n\t\tspin_unlock_bh(&host->lock);\n\t}\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, 0);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tset_bit(ATMCI_CARD_NEED_INIT, &slot->flags);\n\t\tif (!IS_ERR(mmc->supply.vmmc))\n\t\t\tmmc_regulator_set_ocr(mmc, mmc->supply.vmmc, ios->vdd);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int atmci_get_ro(struct mmc_host *mmc)\n{\n\tint\t\t\tread_only = -ENOSYS;\n\tstruct atmel_mci_slot\t*slot = mmc_priv(mmc);\n\n\tif (slot->wp_pin) {\n\t\tread_only = gpiod_get_value(slot->wp_pin);\n\t\tdev_dbg(&mmc->class_dev, \"card is %s\\n\",\n\t\t\t\tread_only ? \"read-only\" : \"read-write\");\n\t}\n\n\treturn read_only;\n}\n\nstatic int atmci_get_cd(struct mmc_host *mmc)\n{\n\tint\t\t\tpresent = -ENOSYS;\n\tstruct atmel_mci_slot\t*slot = mmc_priv(mmc);\n\n\tif (slot->detect_pin) {\n\t\tpresent = gpiod_get_value_cansleep(slot->detect_pin);\n\t\tdev_dbg(&mmc->class_dev, \"card is %spresent\\n\",\n\t\t\t\tpresent ? \"\" : \"not \");\n\t}\n\n\treturn present;\n}\n\nstatic void atmci_enable_sdio_irq(struct mmc_host *mmc, int enable)\n{\n\tstruct atmel_mci_slot\t*slot = mmc_priv(mmc);\n\tstruct atmel_mci\t*host = slot->host;\n\n\tif (enable)\n\t\tatmci_writel(host, ATMCI_IER, slot->sdio_irq);\n\telse\n\t\tatmci_writel(host, ATMCI_IDR, slot->sdio_irq);\n}\n\nstatic const struct mmc_host_ops atmci_ops = {\n\t.request\t= atmci_request,\n\t.set_ios\t= atmci_set_ios,\n\t.get_ro\t\t= atmci_get_ro,\n\t.get_cd\t\t= atmci_get_cd,\n\t.enable_sdio_irq = atmci_enable_sdio_irq,\n};\n\n \nstatic void atmci_request_end(struct atmel_mci *host, struct mmc_request *mrq)\n\t__releases(&host->lock)\n\t__acquires(&host->lock)\n{\n\tstruct atmel_mci_slot\t*slot = NULL;\n\tstruct mmc_host\t\t*prev_mmc = host->cur_slot->mmc;\n\n\tWARN_ON(host->cmd || host->data);\n\n\tdel_timer(&host->timer);\n\n\t \n\tif (host->need_clock_update) {\n\t\tatmci_writel(host, ATMCI_MR, host->mode_reg);\n\t\tif (host->caps.has_cfg_reg)\n\t\t\tatmci_writel(host, ATMCI_CFG, host->cfg_reg);\n\t}\n\n\thost->cur_slot->mrq = NULL;\n\thost->mrq = NULL;\n\tif (!list_empty(&host->queue)) {\n\t\tslot = list_entry(host->queue.next,\n\t\t\t\tstruct atmel_mci_slot, queue_node);\n\t\tlist_del(&slot->queue_node);\n\t\tdev_vdbg(&host->pdev->dev, \"list not empty: %s is next\\n\",\n\t\t\t\tmmc_hostname(slot->mmc));\n\t\thost->state = STATE_SENDING_CMD;\n\t\tatmci_start_request(host, slot);\n\t} else {\n\t\tdev_vdbg(&host->pdev->dev, \"list empty\\n\");\n\t\thost->state = STATE_IDLE;\n\t}\n\n\tspin_unlock(&host->lock);\n\tmmc_request_done(prev_mmc, mrq);\n\tspin_lock(&host->lock);\n}\n\nstatic void atmci_command_complete(struct atmel_mci *host,\n\t\t\tstruct mmc_command *cmd)\n{\n\tu32\t\tstatus = host->cmd_status;\n\n\t \n\tcmd->resp[0] = atmci_readl(host, ATMCI_RSPR);\n\tcmd->resp[1] = atmci_readl(host, ATMCI_RSPR);\n\tcmd->resp[2] = atmci_readl(host, ATMCI_RSPR);\n\tcmd->resp[3] = atmci_readl(host, ATMCI_RSPR);\n\n\tif (status & ATMCI_RTOE)\n\t\tcmd->error = -ETIMEDOUT;\n\telse if ((cmd->flags & MMC_RSP_CRC) && (status & ATMCI_RCRCE))\n\t\tcmd->error = -EILSEQ;\n\telse if (status & (ATMCI_RINDE | ATMCI_RDIRE | ATMCI_RENDE))\n\t\tcmd->error = -EIO;\n\telse if (host->mrq->data && (host->mrq->data->blksz & 3)) {\n\t\tif (host->caps.need_blksz_mul_4) {\n\t\t\tcmd->error = -EINVAL;\n\t\t\thost->need_reset = 1;\n\t\t}\n\t} else\n\t\tcmd->error = 0;\n}\n\nstatic void atmci_detect_change(struct timer_list *t)\n{\n\tstruct atmel_mci_slot\t*slot = from_timer(slot, t, detect_timer);\n\tbool\t\t\tpresent;\n\tbool\t\t\tpresent_old;\n\n\t \n\tsmp_rmb();\n\tif (test_bit(ATMCI_SHUTDOWN, &slot->flags))\n\t\treturn;\n\n\tenable_irq(gpiod_to_irq(slot->detect_pin));\n\tpresent = gpiod_get_value_cansleep(slot->detect_pin);\n\tpresent_old = test_bit(ATMCI_CARD_PRESENT, &slot->flags);\n\n\tdev_vdbg(&slot->mmc->class_dev, \"detect change: %d (was %d)\\n\",\n\t\t\tpresent, present_old);\n\n\tif (present != present_old) {\n\t\tstruct atmel_mci\t*host = slot->host;\n\t\tstruct mmc_request\t*mrq;\n\n\t\tdev_dbg(&slot->mmc->class_dev, \"card %s\\n\",\n\t\t\tpresent ? \"inserted\" : \"removed\");\n\n\t\tspin_lock(&host->lock);\n\n\t\tif (!present)\n\t\t\tclear_bit(ATMCI_CARD_PRESENT, &slot->flags);\n\t\telse\n\t\t\tset_bit(ATMCI_CARD_PRESENT, &slot->flags);\n\n\t\t \n\t\tmrq = slot->mrq;\n\t\tif (mrq) {\n\t\t\tif (mrq == host->mrq) {\n\t\t\t\t \n\t\t\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\n\t\t\t\tatmci_writel(host, ATMCI_CR, ATMCI_CR_MCIEN);\n\t\t\t\tatmci_writel(host, ATMCI_MR, host->mode_reg);\n\t\t\t\tif (host->caps.has_cfg_reg)\n\t\t\t\t\tatmci_writel(host, ATMCI_CFG, host->cfg_reg);\n\n\t\t\t\thost->data = NULL;\n\t\t\t\thost->cmd = NULL;\n\n\t\t\t\tswitch (host->state) {\n\t\t\t\tcase STATE_IDLE:\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_SENDING_CMD:\n\t\t\t\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\t\t\t\tif (mrq->data)\n\t\t\t\t\t\thost->stop_transfer(host);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_DATA_XFER:\n\t\t\t\t\tmrq->data->error = -ENOMEDIUM;\n\t\t\t\t\thost->stop_transfer(host);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_WAITING_NOTBUSY:\n\t\t\t\t\tmrq->data->error = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_SENDING_STOP:\n\t\t\t\t\tmrq->stop->error = -ENOMEDIUM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase STATE_END_REQUEST:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tatmci_request_end(host, mrq);\n\t\t\t} else {\n\t\t\t\tlist_del(&slot->queue_node);\n\t\t\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\t\t\tif (mrq->data)\n\t\t\t\t\tmrq->data->error = -ENOMEDIUM;\n\t\t\t\tif (mrq->stop)\n\t\t\t\t\tmrq->stop->error = -ENOMEDIUM;\n\n\t\t\t\tspin_unlock(&host->lock);\n\t\t\t\tmmc_request_done(slot->mmc, mrq);\n\t\t\t\tspin_lock(&host->lock);\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&host->lock);\n\n\t\tmmc_detect_change(slot->mmc, 0);\n\t}\n}\n\nstatic void atmci_tasklet_func(struct tasklet_struct *t)\n{\n\tstruct atmel_mci        *host = from_tasklet(host, t, tasklet);\n\tstruct mmc_request\t*mrq = host->mrq;\n\tstruct mmc_data\t\t*data = host->data;\n\tenum atmel_mci_state\tstate = host->state;\n\tenum atmel_mci_state\tprev_state;\n\tu32\t\t\tstatus;\n\n\tspin_lock(&host->lock);\n\n\tstate = host->state;\n\n\tdev_vdbg(&host->pdev->dev,\n\t\t\"tasklet: state %u pending/completed/mask %lx/%lx/%x\\n\",\n\t\tstate, host->pending_events, host->completed_events,\n\t\tatmci_readl(host, ATMCI_IMR));\n\n\tdo {\n\t\tprev_state = state;\n\t\tdev_dbg(&host->pdev->dev, \"FSM: state=%d\\n\", state);\n\n\t\tswitch (state) {\n\t\tcase STATE_IDLE:\n\t\t\tbreak;\n\n\t\tcase STATE_SENDING_CMD:\n\t\t\t \n\t\t\tdev_dbg(&host->pdev->dev, \"FSM: cmd ready?\\n\");\n\t\t\tif (!atmci_test_and_clear_pending(host,\n\t\t\t\t\t\tEVENT_CMD_RDY))\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(&host->pdev->dev, \"set completed cmd ready\\n\");\n\t\t\thost->cmd = NULL;\n\t\t\tatmci_set_completed(host, EVENT_CMD_RDY);\n\t\t\tatmci_command_complete(host, mrq->cmd);\n\t\t\tif (mrq->data) {\n\t\t\t\tdev_dbg(&host->pdev->dev,\n\t\t\t\t        \"command with data transfer\");\n\t\t\t\t \n\t\t\t\tif (mrq->cmd->error) {\n\t\t\t\t\thost->stop_transfer(host);\n\t\t\t\t\thost->data = NULL;\n\t\t\t\t\tatmci_writel(host, ATMCI_IDR,\n\t\t\t\t\t             ATMCI_TXRDY | ATMCI_RXRDY\n\t\t\t\t\t             | ATMCI_DATA_ERROR_FLAGS);\n\t\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\t\t} else\n\t\t\t\t\tstate = STATE_DATA_XFER;\n\t\t\t} else if ((!mrq->data) && (mrq->cmd->flags & MMC_RSP_BUSY)) {\n\t\t\t\tdev_dbg(&host->pdev->dev,\n\t\t\t\t        \"command response need waiting notbusy\");\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\t\t\t\tstate = STATE_WAITING_NOTBUSY;\n\t\t\t} else\n\t\t\t\tstate = STATE_END_REQUEST;\n\n\t\t\tbreak;\n\n\t\tcase STATE_DATA_XFER:\n\t\t\tif (atmci_test_and_clear_pending(host,\n\t\t\t\t\t\tEVENT_DATA_ERROR)) {\n\t\t\t\tdev_dbg(&host->pdev->dev, \"set completed data error\\n\");\n\t\t\t\tatmci_set_completed(host, EVENT_DATA_ERROR);\n\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tdev_dbg(&host->pdev->dev, \"FSM: xfer complete?\\n\");\n\t\t\tif (!atmci_test_and_clear_pending(host,\n\t\t\t\t\t\tEVENT_XFER_COMPLETE))\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(&host->pdev->dev,\n\t\t\t        \"(%s) set completed xfer complete\\n\",\n\t\t\t\t__func__);\n\t\t\tatmci_set_completed(host, EVENT_XFER_COMPLETE);\n\n\t\t\tif (host->caps.need_notbusy_for_read_ops ||\n\t\t\t   (host->data->flags & MMC_DATA_WRITE)) {\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\t\t\t\tstate = STATE_WAITING_NOTBUSY;\n\t\t\t} else if (host->mrq->stop) {\n\t\t\t\tatmci_send_stop_cmd(host, data);\n\t\t\t\tstate = STATE_SENDING_STOP;\n\t\t\t} else {\n\t\t\t\thost->data = NULL;\n\t\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t\t\tdata->error = 0;\n\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase STATE_WAITING_NOTBUSY:\n\t\t\t \n\t\t\tdev_dbg(&host->pdev->dev, \"FSM: not busy?\\n\");\n\t\t\tif (!atmci_test_and_clear_pending(host,\n\t\t\t\t\t\tEVENT_NOTBUSY))\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(&host->pdev->dev, \"set completed not busy\\n\");\n\t\t\tatmci_set_completed(host, EVENT_NOTBUSY);\n\n\t\t\tif (host->data) {\n\t\t\t\t \n\t\t\t\tif (host->mrq->stop) {\n\t\t\t\t\tatmci_send_stop_cmd(host, data);\n\t\t\t\t\tstate = STATE_SENDING_STOP;\n\t\t\t\t} else {\n\t\t\t\t\thost->data = NULL;\n\t\t\t\t\tdata->bytes_xfered = data->blocks\n\t\t\t\t\t                     * data->blksz;\n\t\t\t\t\tdata->error = 0;\n\t\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\tbreak;\n\n\t\tcase STATE_SENDING_STOP:\n\t\t\t \n\t\t\tdev_dbg(&host->pdev->dev, \"FSM: cmd ready?\\n\");\n\t\t\tif (!atmci_test_and_clear_pending(host,\n\t\t\t\t\t\tEVENT_CMD_RDY))\n\t\t\t\tbreak;\n\n\t\t\tdev_dbg(&host->pdev->dev, \"FSM: cmd ready\\n\");\n\t\t\thost->cmd = NULL;\n\t\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\t\t\tdata->error = 0;\n\t\t\tatmci_command_complete(host, mrq->stop);\n\t\t\tif (mrq->stop->error) {\n\t\t\t\thost->stop_transfer(host);\n\t\t\t\tatmci_writel(host, ATMCI_IDR,\n\t\t\t\t             ATMCI_TXRDY | ATMCI_RXRDY\n\t\t\t\t             | ATMCI_DATA_ERROR_FLAGS);\n\t\t\t\tstate = STATE_END_REQUEST;\n\t\t\t} else {\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\t\t\t\tstate = STATE_WAITING_NOTBUSY;\n\t\t\t}\n\t\t\thost->data = NULL;\n\t\t\tbreak;\n\n\t\tcase STATE_END_REQUEST:\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_TXRDY | ATMCI_RXRDY\n\t\t\t                   | ATMCI_DATA_ERROR_FLAGS);\n\t\t\tstatus = host->data_status;\n\t\t\tif (unlikely(status)) {\n\t\t\t\thost->stop_transfer(host);\n\t\t\t\thost->data = NULL;\n\t\t\t\tif (data) {\n\t\t\t\t\tif (status & ATMCI_DTOE) {\n\t\t\t\t\t\tdata->error = -ETIMEDOUT;\n\t\t\t\t\t} else if (status & ATMCI_DCRCE) {\n\t\t\t\t\t\tdata->error = -EILSEQ;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdata->error = -EIO;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tatmci_request_end(host, host->mrq);\n\t\t\tgoto unlock;  \n\t\t\tbreak;\n\t\t}\n\t} while (state != prev_state);\n\n\thost->state = state;\n\nunlock:\n\tspin_unlock(&host->lock);\n}\n\nstatic void atmci_read_data_pio(struct atmel_mci *host)\n{\n\tstruct scatterlist\t*sg = host->sg;\n\tunsigned int\t\toffset = host->pio_offset;\n\tstruct mmc_data\t\t*data = host->data;\n\tu32\t\t\tvalue;\n\tu32\t\t\tstatus;\n\tunsigned int\t\tnbytes = 0;\n\n\tdo {\n\t\tvalue = atmci_readl(host, ATMCI_RDR);\n\t\tif (likely(offset + 4 <= sg->length)) {\n\t\t\tsg_pcopy_from_buffer(sg, 1, &value, sizeof(u32), offset);\n\n\t\t\toffset += 4;\n\t\t\tnbytes += 4;\n\n\t\t\tif (offset == sg->length) {\n\t\t\t\tflush_dcache_page(sg_page(sg));\n\t\t\t\thost->sg = sg = sg_next(sg);\n\t\t\t\thost->sg_len--;\n\t\t\t\tif (!sg || !host->sg_len)\n\t\t\t\t\tgoto done;\n\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int remaining = sg->length - offset;\n\n\t\t\tsg_pcopy_from_buffer(sg, 1, &value, remaining, offset);\n\t\t\tnbytes += remaining;\n\n\t\t\tflush_dcache_page(sg_page(sg));\n\t\t\thost->sg = sg = sg_next(sg);\n\t\t\thost->sg_len--;\n\t\t\tif (!sg || !host->sg_len)\n\t\t\t\tgoto done;\n\n\t\t\toffset = 4 - remaining;\n\t\t\tsg_pcopy_from_buffer(sg, 1, (u8 *)&value + remaining,\n\t\t\t\t\toffset, 0);\n\t\t\tnbytes += offset;\n\t\t}\n\n\t\tstatus = atmci_readl(host, ATMCI_SR);\n\t\tif (status & ATMCI_DATA_ERROR_FLAGS) {\n\t\t\tatmci_writel(host, ATMCI_IDR, (ATMCI_NOTBUSY | ATMCI_RXRDY\n\t\t\t\t\t\t| ATMCI_DATA_ERROR_FLAGS));\n\t\t\thost->data_status = status;\n\t\t\tdata->bytes_xfered += nbytes;\n\t\t\treturn;\n\t\t}\n\t} while (status & ATMCI_RXRDY);\n\n\thost->pio_offset = offset;\n\tdata->bytes_xfered += nbytes;\n\n\treturn;\n\ndone:\n\tatmci_writel(host, ATMCI_IDR, ATMCI_RXRDY);\n\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\tdata->bytes_xfered += nbytes;\n\tsmp_wmb();\n\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n}\n\nstatic void atmci_write_data_pio(struct atmel_mci *host)\n{\n\tstruct scatterlist\t*sg = host->sg;\n\tunsigned int\t\toffset = host->pio_offset;\n\tstruct mmc_data\t\t*data = host->data;\n\tu32\t\t\tvalue;\n\tu32\t\t\tstatus;\n\tunsigned int\t\tnbytes = 0;\n\n\tdo {\n\t\tif (likely(offset + 4 <= sg->length)) {\n\t\t\tsg_pcopy_to_buffer(sg, 1, &value, sizeof(u32), offset);\n\t\t\tatmci_writel(host, ATMCI_TDR, value);\n\n\t\t\toffset += 4;\n\t\t\tnbytes += 4;\n\t\t\tif (offset == sg->length) {\n\t\t\t\thost->sg = sg = sg_next(sg);\n\t\t\t\thost->sg_len--;\n\t\t\t\tif (!sg || !host->sg_len)\n\t\t\t\t\tgoto done;\n\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tunsigned int remaining = sg->length - offset;\n\n\t\t\tvalue = 0;\n\t\t\tsg_pcopy_to_buffer(sg, 1, &value, remaining, offset);\n\t\t\tnbytes += remaining;\n\n\t\t\thost->sg = sg = sg_next(sg);\n\t\t\thost->sg_len--;\n\t\t\tif (!sg || !host->sg_len) {\n\t\t\t\tatmci_writel(host, ATMCI_TDR, value);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\toffset = 4 - remaining;\n\t\t\tsg_pcopy_to_buffer(sg, 1, (u8 *)&value + remaining,\n\t\t\t\t\toffset, 0);\n\t\t\tatmci_writel(host, ATMCI_TDR, value);\n\t\t\tnbytes += offset;\n\t\t}\n\n\t\tstatus = atmci_readl(host, ATMCI_SR);\n\t\tif (status & ATMCI_DATA_ERROR_FLAGS) {\n\t\t\tatmci_writel(host, ATMCI_IDR, (ATMCI_NOTBUSY | ATMCI_TXRDY\n\t\t\t\t\t\t| ATMCI_DATA_ERROR_FLAGS));\n\t\t\thost->data_status = status;\n\t\t\tdata->bytes_xfered += nbytes;\n\t\t\treturn;\n\t\t}\n\t} while (status & ATMCI_TXRDY);\n\n\thost->pio_offset = offset;\n\tdata->bytes_xfered += nbytes;\n\n\treturn;\n\ndone:\n\tatmci_writel(host, ATMCI_IDR, ATMCI_TXRDY);\n\tatmci_writel(host, ATMCI_IER, ATMCI_NOTBUSY);\n\tdata->bytes_xfered += nbytes;\n\tsmp_wmb();\n\tatmci_set_pending(host, EVENT_XFER_COMPLETE);\n}\n\nstatic void atmci_sdio_interrupt(struct atmel_mci *host, u32 status)\n{\n\tint\ti;\n\n\tfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\n\t\tstruct atmel_mci_slot *slot = host->slot[i];\n\t\tif (slot && (status & slot->sdio_irq)) {\n\t\t\tmmc_signal_sdio_irq(slot->mmc);\n\t\t}\n\t}\n}\n\n\nstatic irqreturn_t atmci_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_mci\t*host = dev_id;\n\tu32\t\t\tstatus, mask, pending;\n\tunsigned int\t\tpass_count = 0;\n\n\tdo {\n\t\tstatus = atmci_readl(host, ATMCI_SR);\n\t\tmask = atmci_readl(host, ATMCI_IMR);\n\t\tpending = status & mask;\n\t\tif (!pending)\n\t\t\tbreak;\n\n\t\tif (pending & ATMCI_DATA_ERROR_FLAGS) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: data error\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_DATA_ERROR_FLAGS\n\t\t\t\t\t| ATMCI_RXRDY | ATMCI_TXRDY\n\t\t\t\t\t| ATMCI_ENDRX | ATMCI_ENDTX\n\t\t\t\t\t| ATMCI_RXBUFF | ATMCI_TXBUFE);\n\n\t\t\thost->data_status = status;\n\t\t\tdev_dbg(&host->pdev->dev, \"set pending data error\\n\");\n\t\t\tsmp_wmb();\n\t\t\tatmci_set_pending(host, EVENT_DATA_ERROR);\n\t\t\ttasklet_schedule(&host->tasklet);\n\t\t}\n\n\t\tif (pending & ATMCI_TXBUFE) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: tx buffer empty\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_TXBUFE);\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_ENDTX);\n\t\t\t \n\t\t\tif (host->data_size) {\n\t\t\t\tatmci_pdc_set_both_buf(host, XFER_TRANSMIT);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_ENDTX);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_TXBUFE);\n\t\t\t} else {\n\t\t\t\tatmci_pdc_complete(host);\n\t\t\t}\n\t\t} else if (pending & ATMCI_ENDTX) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: end of tx buffer\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_ENDTX);\n\n\t\t\tif (host->data_size) {\n\t\t\t\tatmci_pdc_set_single_buf(host,\n\t\t\t\t\t\tXFER_TRANSMIT, PDC_SECOND_BUF);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_ENDTX);\n\t\t\t}\n\t\t}\n\n\t\tif (pending & ATMCI_RXBUFF) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: rx buffer full\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_RXBUFF);\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_ENDRX);\n\t\t\t \n\t\t\tif (host->data_size) {\n\t\t\t\tatmci_pdc_set_both_buf(host, XFER_RECEIVE);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_ENDRX);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_RXBUFF);\n\t\t\t} else {\n\t\t\t\tatmci_pdc_complete(host);\n\t\t\t}\n\t\t} else if (pending & ATMCI_ENDRX) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: end of rx buffer\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_ENDRX);\n\n\t\t\tif (host->data_size) {\n\t\t\t\tatmci_pdc_set_single_buf(host,\n\t\t\t\t\t\tXFER_RECEIVE, PDC_SECOND_BUF);\n\t\t\t\tatmci_writel(host, ATMCI_IER, ATMCI_ENDRX);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (pending & ATMCI_BLKE) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: blke\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_BLKE);\n\t\t\tsmp_wmb();\n\t\t\tdev_dbg(&host->pdev->dev, \"set pending notbusy\\n\");\n\t\t\tatmci_set_pending(host, EVENT_NOTBUSY);\n\t\t\ttasklet_schedule(&host->tasklet);\n\t\t}\n\n\t\tif (pending & ATMCI_NOTBUSY) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: not_busy\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_NOTBUSY);\n\t\t\tsmp_wmb();\n\t\t\tdev_dbg(&host->pdev->dev, \"set pending notbusy\\n\");\n\t\t\tatmci_set_pending(host, EVENT_NOTBUSY);\n\t\t\ttasklet_schedule(&host->tasklet);\n\t\t}\n\n\t\tif (pending & ATMCI_RXRDY)\n\t\t\tatmci_read_data_pio(host);\n\t\tif (pending & ATMCI_TXRDY)\n\t\t\tatmci_write_data_pio(host);\n\n\t\tif (pending & ATMCI_CMDRDY) {\n\t\t\tdev_dbg(&host->pdev->dev, \"IRQ: cmd ready\\n\");\n\t\t\tatmci_writel(host, ATMCI_IDR, ATMCI_CMDRDY);\n\t\t\thost->cmd_status = status;\n\t\t\tsmp_wmb();\n\t\t\tdev_dbg(&host->pdev->dev, \"set pending cmd rdy\\n\");\n\t\t\tatmci_set_pending(host, EVENT_CMD_RDY);\n\t\t\ttasklet_schedule(&host->tasklet);\n\t\t}\n\n\t\tif (pending & (ATMCI_SDIOIRQA | ATMCI_SDIOIRQB))\n\t\t\tatmci_sdio_interrupt(host, status);\n\n\t} while (pass_count++ < 5);\n\n\treturn pass_count ? IRQ_HANDLED : IRQ_NONE;\n}\n\nstatic irqreturn_t atmci_detect_interrupt(int irq, void *dev_id)\n{\n\tstruct atmel_mci_slot\t*slot = dev_id;\n\n\t \n\tdisable_irq_nosync(irq);\n\tmod_timer(&slot->detect_timer, jiffies + msecs_to_jiffies(20));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int atmci_init_slot(struct atmel_mci *host,\n\t\tstruct mci_slot_pdata *slot_data, unsigned int id,\n\t\tu32 sdc_reg, u32 sdio_irq)\n{\n\tstruct mmc_host\t\t\t*mmc;\n\tstruct atmel_mci_slot\t\t*slot;\n\tint ret;\n\n\tmmc = mmc_alloc_host(sizeof(struct atmel_mci_slot), &host->pdev->dev);\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tslot = mmc_priv(mmc);\n\tslot->mmc = mmc;\n\tslot->host = host;\n\tslot->detect_pin = slot_data->detect_pin;\n\tslot->wp_pin = slot_data->wp_pin;\n\tslot->sdc_reg = sdc_reg;\n\tslot->sdio_irq = sdio_irq;\n\n\tdev_dbg(&mmc->class_dev,\n\t        \"slot[%u]: bus_width=%u, detect_pin=%d, \"\n\t\t\"detect_is_active_high=%s, wp_pin=%d\\n\",\n\t\tid, slot_data->bus_width, desc_to_gpio(slot_data->detect_pin),\n\t\t!gpiod_is_active_low(slot_data->detect_pin) ? \"true\" : \"false\",\n\t\tdesc_to_gpio(slot_data->wp_pin));\n\n\tmmc->ops = &atmci_ops;\n\tmmc->f_min = DIV_ROUND_UP(host->bus_hz, 512);\n\tmmc->f_max = host->bus_hz / 2;\n\tmmc->ocr_avail\t= MMC_VDD_32_33 | MMC_VDD_33_34;\n\tif (sdio_irq)\n\t\tmmc->caps |= MMC_CAP_SDIO_IRQ;\n\tif (host->caps.has_highspeed)\n\t\tmmc->caps |= MMC_CAP_SD_HIGHSPEED;\n\t \n\tif ((slot_data->bus_width >= 4) && host->caps.has_rwproof) {\n\t\tmmc->caps |= MMC_CAP_4_BIT_DATA;\n\t\tif (slot_data->bus_width >= 8)\n\t\t\tmmc->caps |= MMC_CAP_8_BIT_DATA;\n\t}\n\n\tif (atmci_get_version(host) < 0x200) {\n\t\tmmc->max_segs = 256;\n\t\tmmc->max_blk_size = 4095;\n\t\tmmc->max_blk_count = 256;\n\t\tmmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;\n\t\tmmc->max_seg_size = mmc->max_blk_size * mmc->max_segs;\n\t} else {\n\t\tmmc->max_segs = 64;\n\t\tmmc->max_req_size = 32768 * 512;\n\t\tmmc->max_blk_size = 32768;\n\t\tmmc->max_blk_count = 512;\n\t}\n\n\t \n\tset_bit(ATMCI_CARD_PRESENT, &slot->flags);\n\tif (slot->detect_pin) {\n\t\tif (!gpiod_get_value_cansleep(slot->detect_pin))\n\t\t\tclear_bit(ATMCI_CARD_PRESENT, &slot->flags);\n\t} else {\n\t\tdev_dbg(&mmc->class_dev, \"no detect pin available\\n\");\n\t}\n\n\tif (!slot->detect_pin) {\n\t\tif (slot_data->non_removable)\n\t\t\tmmc->caps |= MMC_CAP_NONREMOVABLE;\n\t\telse\n\t\t\tmmc->caps |= MMC_CAP_NEEDS_POLL;\n\t}\n\n\tif (!slot->wp_pin)\n\t\tdev_dbg(&mmc->class_dev, \"no WP pin available\\n\");\n\n\thost->slot[id] = slot;\n\tmmc_regulator_get_supply(mmc);\n\tret = mmc_add_host(mmc);\n\tif (ret) {\n\t\tmmc_free_host(mmc);\n\t\treturn ret;\n\t}\n\n\tif (slot->detect_pin) {\n\t\ttimer_setup(&slot->detect_timer, atmci_detect_change, 0);\n\n\t\tret = request_irq(gpiod_to_irq(slot->detect_pin),\n\t\t\t\t  atmci_detect_interrupt,\n\t\t\t\t  IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,\n\t\t\t\t  \"mmc-detect\", slot);\n\t\tif (ret) {\n\t\t\tdev_dbg(&mmc->class_dev,\n\t\t\t\t\"could not request IRQ %d for detect pin\\n\",\n\t\t\t\tgpiod_to_irq(slot->detect_pin));\n\t\t\tslot->detect_pin = NULL;\n\t\t}\n\t}\n\n\tatmci_init_debugfs(slot);\n\n\treturn 0;\n}\n\nstatic void atmci_cleanup_slot(struct atmel_mci_slot *slot,\n\t\tunsigned int id)\n{\n\t \n\n\tset_bit(ATMCI_SHUTDOWN, &slot->flags);\n\tsmp_wmb();\n\n\tmmc_remove_host(slot->mmc);\n\n\tif (slot->detect_pin) {\n\t\tfree_irq(gpiod_to_irq(slot->detect_pin), slot);\n\t\tdel_timer_sync(&slot->detect_timer);\n\t}\n\n\tslot->host->slot[id] = NULL;\n\tmmc_free_host(slot->mmc);\n}\n\nstatic int atmci_configure_dma(struct atmel_mci *host)\n{\n\thost->dma.chan = dma_request_chan(&host->pdev->dev, \"rxtx\");\n\n\tif (PTR_ERR(host->dma.chan) == -ENODEV) {\n\t\tstruct mci_platform_data *pdata = host->pdev->dev.platform_data;\n\t\tdma_cap_mask_t mask;\n\n\t\tif (!pdata || !pdata->dma_filter)\n\t\t\treturn -ENODEV;\n\n\t\tdma_cap_zero(mask);\n\t\tdma_cap_set(DMA_SLAVE, mask);\n\n\t\thost->dma.chan = dma_request_channel(mask, pdata->dma_filter,\n\t\t\t\t\t\t     pdata->dma_slave);\n\t\tif (!host->dma.chan)\n\t\t\thost->dma.chan = ERR_PTR(-ENODEV);\n\t}\n\n\tif (IS_ERR(host->dma.chan))\n\t\treturn PTR_ERR(host->dma.chan);\n\n\tdev_info(&host->pdev->dev, \"using %s for DMA transfers\\n\",\n\t\t dma_chan_name(host->dma.chan));\n\n\thost->dma_conf.src_addr = host->mapbase + ATMCI_RDR;\n\thost->dma_conf.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_conf.src_maxburst = 1;\n\thost->dma_conf.dst_addr = host->mapbase + ATMCI_TDR;\n\thost->dma_conf.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;\n\thost->dma_conf.dst_maxburst = 1;\n\thost->dma_conf.device_fc = false;\n\n\treturn 0;\n}\n\n \nstatic void atmci_get_cap(struct atmel_mci *host)\n{\n\tunsigned int version;\n\n\tversion = atmci_get_version(host);\n\tdev_info(&host->pdev->dev,\n\t\t\t\"version: 0x%x\\n\", version);\n\n\thost->caps.has_dma_conf_reg = false;\n\thost->caps.has_pdc = true;\n\thost->caps.has_cfg_reg = false;\n\thost->caps.has_cstor_reg = false;\n\thost->caps.has_highspeed = false;\n\thost->caps.has_rwproof = false;\n\thost->caps.has_odd_clk_div = false;\n\thost->caps.has_bad_data_ordering = true;\n\thost->caps.need_reset_after_xfer = true;\n\thost->caps.need_blksz_mul_4 = true;\n\thost->caps.need_notbusy_for_read_ops = false;\n\n\t \n\tswitch (version & 0xf00) {\n\tcase 0x600:\n\tcase 0x500:\n\t\thost->caps.has_odd_clk_div = true;\n\t\tfallthrough;\n\tcase 0x400:\n\tcase 0x300:\n\t\thost->caps.has_dma_conf_reg = true;\n\t\thost->caps.has_pdc = false;\n\t\thost->caps.has_cfg_reg = true;\n\t\thost->caps.has_cstor_reg = true;\n\t\thost->caps.has_highspeed = true;\n\t\tfallthrough;\n\tcase 0x200:\n\t\thost->caps.has_rwproof = true;\n\t\thost->caps.need_blksz_mul_4 = false;\n\t\thost->caps.need_notbusy_for_read_ops = true;\n\t\tfallthrough;\n\tcase 0x100:\n\t\thost->caps.has_bad_data_ordering = false;\n\t\thost->caps.need_reset_after_xfer = false;\n\t\tfallthrough;\n\tcase 0x0:\n\t\tbreak;\n\tdefault:\n\t\thost->caps.has_pdc = false;\n\t\tdev_warn(&host->pdev->dev,\n\t\t\t\t\"Unmanaged mci version, set minimum capabilities\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic int atmci_probe(struct platform_device *pdev)\n{\n\tstruct mci_platform_data\t*pdata;\n\tstruct atmel_mci\t\t*host;\n\tstruct resource\t\t\t*regs;\n\tunsigned int\t\t\tnr_slots;\n\tint\t\t\t\tirq;\n\tint\t\t\t\tret, i;\n\n\tregs = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!regs)\n\t\treturn -ENXIO;\n\tpdata = pdev->dev.platform_data;\n\tif (!pdata) {\n\t\tpdata = atmci_of_init(pdev);\n\t\tif (IS_ERR(pdata)) {\n\t\t\tdev_err(&pdev->dev, \"platform data not available\\n\");\n\t\t\treturn PTR_ERR(pdata);\n\t\t}\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thost = devm_kzalloc(&pdev->dev, sizeof(*host), GFP_KERNEL);\n\tif (!host)\n\t\treturn -ENOMEM;\n\n\thost->pdev = pdev;\n\tspin_lock_init(&host->lock);\n\tINIT_LIST_HEAD(&host->queue);\n\n\thost->mck = devm_clk_get(&pdev->dev, \"mci_clk\");\n\tif (IS_ERR(host->mck))\n\t\treturn PTR_ERR(host->mck);\n\n\thost->regs = devm_ioremap(&pdev->dev, regs->start, resource_size(regs));\n\tif (!host->regs)\n\t\treturn -ENOMEM;\n\n\tret = clk_prepare_enable(host->mck);\n\tif (ret)\n\t\treturn ret;\n\n\tatmci_writel(host, ATMCI_CR, ATMCI_CR_SWRST);\n\thost->bus_hz = clk_get_rate(host->mck);\n\n\thost->mapbase = regs->start;\n\n\ttasklet_setup(&host->tasklet, atmci_tasklet_func);\n\n\tret = request_irq(irq, atmci_interrupt, 0, dev_name(&pdev->dev), host);\n\tif (ret) {\n\t\tclk_disable_unprepare(host->mck);\n\t\treturn ret;\n\t}\n\n\t \n\tatmci_get_cap(host);\n\tret = atmci_configure_dma(host);\n\tif (ret == -EPROBE_DEFER)\n\t\tgoto err_dma_probe_defer;\n\tif (ret == 0) {\n\t\thost->prepare_data = &atmci_prepare_data_dma;\n\t\thost->submit_data = &atmci_submit_data_dma;\n\t\thost->stop_transfer = &atmci_stop_transfer_dma;\n\t} else if (host->caps.has_pdc) {\n\t\tdev_info(&pdev->dev, \"using PDC\\n\");\n\t\thost->prepare_data = &atmci_prepare_data_pdc;\n\t\thost->submit_data = &atmci_submit_data_pdc;\n\t\thost->stop_transfer = &atmci_stop_transfer_pdc;\n\t} else {\n\t\tdev_info(&pdev->dev, \"using PIO\\n\");\n\t\thost->prepare_data = &atmci_prepare_data;\n\t\thost->submit_data = &atmci_submit_data;\n\t\thost->stop_transfer = &atmci_stop_transfer;\n\t}\n\n\tplatform_set_drvdata(pdev, host);\n\n\ttimer_setup(&host->timer, atmci_timeout_timer, 0);\n\n\tpm_runtime_get_noresume(&pdev->dev);\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\t \n\tnr_slots = 0;\n\tret = -ENODEV;\n\tif (pdata->slot[0].bus_width) {\n\t\tret = atmci_init_slot(host, &pdata->slot[0],\n\t\t\t\t0, ATMCI_SDCSEL_SLOT_A, ATMCI_SDIOIRQA);\n\t\tif (!ret) {\n\t\t\tnr_slots++;\n\t\t\thost->buf_size = host->slot[0]->mmc->max_req_size;\n\t\t}\n\t}\n\tif (pdata->slot[1].bus_width) {\n\t\tret = atmci_init_slot(host, &pdata->slot[1],\n\t\t\t\t1, ATMCI_SDCSEL_SLOT_B, ATMCI_SDIOIRQB);\n\t\tif (!ret) {\n\t\t\tnr_slots++;\n\t\t\tif (host->slot[1]->mmc->max_req_size > host->buf_size)\n\t\t\t\thost->buf_size =\n\t\t\t\t\thost->slot[1]->mmc->max_req_size;\n\t\t}\n\t}\n\n\tif (!nr_slots) {\n\t\tdev_err(&pdev->dev, \"init failed: no slot defined\\n\");\n\t\tgoto err_init_slot;\n\t}\n\n\tif (!host->caps.has_rwproof) {\n\t\thost->buffer = dma_alloc_coherent(&pdev->dev, host->buf_size,\n\t\t                                  &host->buf_phys_addr,\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!host->buffer) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(&pdev->dev, \"buffer allocation failed\\n\");\n\t\t\tgoto err_dma_alloc;\n\t\t}\n\t}\n\n\tdev_info(&pdev->dev,\n\t\t\t\"Atmel MCI controller at 0x%08lx irq %d, %u slots\\n\",\n\t\t\thost->mapbase, irq, nr_slots);\n\n\tpm_runtime_mark_last_busy(&host->pdev->dev);\n\tpm_runtime_put_autosuspend(&pdev->dev);\n\n\treturn 0;\n\nerr_dma_alloc:\n\tfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\n\t\tif (host->slot[i])\n\t\t\tatmci_cleanup_slot(host->slot[i], i);\n\t}\nerr_init_slot:\n\tclk_disable_unprepare(host->mck);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\tdel_timer_sync(&host->timer);\n\tif (!IS_ERR(host->dma.chan))\n\t\tdma_release_channel(host->dma.chan);\nerr_dma_probe_defer:\n\tfree_irq(irq, host);\n\treturn ret;\n}\n\nstatic void atmci_remove(struct platform_device *pdev)\n{\n\tstruct atmel_mci\t*host = platform_get_drvdata(pdev);\n\tunsigned int\t\ti;\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tif (host->buffer)\n\t\tdma_free_coherent(&pdev->dev, host->buf_size,\n\t\t                  host->buffer, host->buf_phys_addr);\n\n\tfor (i = 0; i < ATMCI_MAX_NR_SLOTS; i++) {\n\t\tif (host->slot[i])\n\t\t\tatmci_cleanup_slot(host->slot[i], i);\n\t}\n\n\tatmci_writel(host, ATMCI_IDR, ~0UL);\n\tatmci_writel(host, ATMCI_CR, ATMCI_CR_MCIDIS);\n\tatmci_readl(host, ATMCI_SR);\n\n\tdel_timer_sync(&host->timer);\n\tif (!IS_ERR(host->dma.chan))\n\t\tdma_release_channel(host->dma.chan);\n\n\tfree_irq(platform_get_irq(pdev, 0), host);\n\n\tclk_disable_unprepare(host->mck);\n\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int atmci_runtime_suspend(struct device *dev)\n{\n\tstruct atmel_mci *host = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(host->mck);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int atmci_runtime_resume(struct device *dev)\n{\n\tstruct atmel_mci *host = dev_get_drvdata(dev);\n\n\tpinctrl_select_default_state(dev);\n\n\treturn clk_prepare_enable(host->mck);\n}\n#endif\n\nstatic const struct dev_pm_ops atmci_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(atmci_runtime_suspend, atmci_runtime_resume, NULL)\n};\n\nstatic struct platform_driver atmci_driver = {\n\t.probe\t\t= atmci_probe,\n\t.remove_new\t= atmci_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"atmel_mci\",\n\t\t.probe_type\t= PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table\t= of_match_ptr(atmci_dt_ids),\n\t\t.pm\t\t= &atmci_dev_pm_ops,\n\t},\n};\nmodule_platform_driver(atmci_driver);\n\nMODULE_DESCRIPTION(\"Atmel Multimedia Card Interface driver\");\nMODULE_AUTHOR(\"Haavard Skinnemoen (Atmel)\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}