{
  "module_name": "toshsd.c",
  "hash_id": "9580e30b22550a69ed14f0ed3fc45339cc4434f558f1e8cb3ee1a1c6ae7f0366",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/toshsd.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/scatterlist.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n\n#include \"toshsd.h\"\n\n#define DRIVER_NAME \"toshsd\"\n\nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE(PCI_VENDOR_ID_TOSHIBA, 0x0805) },\n\t{   },\n};\n\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\nstatic void toshsd_init(struct toshsd_host *host)\n{\n\t \n\tpci_write_config_byte(host->pdev, SD_PCICFG_CLKSTOP,\n\t\t\t\t\tSD_PCICFG_CLKSTOP_ENABLE_ALL);\n\tpci_write_config_byte(host->pdev, SD_PCICFG_CARDDETECT, 2);\n\n\t \n\tiowrite16(0, host->ioaddr + SD_SOFTWARERESET);  \n\tmdelay(2);\n\tiowrite16(1, host->ioaddr + SD_SOFTWARERESET);  \n\tmdelay(2);\n\n\t \n\tiowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\n\tiowrite32(0, host->ioaddr + SD_CARDSTATUS);\n\tiowrite32(0, host->ioaddr + SD_ERRORSTATUS0);\n\tiowrite16(0, host->ioaddr + SD_STOPINTERNAL);\n\n\t \n\tiowrite16(0x100, host->ioaddr + SDIO_BASE + SDIO_CLOCKNWAITCTRL);\n\n\t \n\tpci_write_config_byte(host->pdev, SD_PCICFG_SDLED_ENABLE1,\n\t\t\t\t\tSD_PCICFG_LED_ENABLE1_START);\n\tpci_write_config_byte(host->pdev, SD_PCICFG_SDLED_ENABLE2,\n\t\t\t\t\tSD_PCICFG_LED_ENABLE2_START);\n\n\t \n\tiowrite32(~(u32)(SD_CARD_RESP_END | SD_CARD_RW_END\n\t\t\t| SD_CARD_CARD_REMOVED_0 | SD_CARD_CARD_INSERTED_0\n\t\t\t| SD_BUF_READ_ENABLE | SD_BUF_WRITE_ENABLE\n\t\t\t| SD_BUF_CMD_TIMEOUT),\n\t\t\thost->ioaddr + SD_INTMASKCARD);\n\n\tiowrite16(0x1000, host->ioaddr + SD_TRANSACTIONCTRL);\n}\n\n \nstatic void __toshsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct toshsd_host *host = mmc_priv(mmc);\n\n\tif (ios->clock) {\n\t\tu16 clk;\n\t\tint div = 1;\n\n\t\twhile (ios->clock < HCLK / div)\n\t\t\tdiv *= 2;\n\n\t\tclk = div >> 2;\n\n\t\tif (div == 1) {  \n\t\t\tpci_write_config_byte(host->pdev, SD_PCICFG_CLKMODE,\n\t\t\t\t\t      SD_PCICFG_CLKMODE_DIV_DISABLE);\n\t\t\tclk |= SD_CARDCLK_DIV_DISABLE;\n\t\t} else\n\t\t\tpci_write_config_byte(host->pdev, SD_PCICFG_CLKMODE, 0);\n\n\t\tclk |= SD_CARDCLK_ENABLE_CLOCK;\n\t\tiowrite16(clk, host->ioaddr + SD_CARDCLOCKCTRL);\n\n\t\tmdelay(10);\n\t} else\n\t\tiowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tpci_write_config_byte(host->pdev, SD_PCICFG_POWER1,\n\t\t\t\t\tSD_PCICFG_PWR1_OFF);\n\t\tmdelay(1);\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tpci_write_config_byte(host->pdev, SD_PCICFG_POWER1,\n\t\t\t\t\tSD_PCICFG_PWR1_33V);\n\t\tpci_write_config_byte(host->pdev, SD_PCICFG_POWER2,\n\t\t\t\t\tSD_PCICFG_PWR2_AUTO);\n\t\tmdelay(20);\n\t\tbreak;\n\t}\n\n\tswitch (ios->bus_width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tiowrite16(SD_CARDOPT_REQUIRED | SD_CARDOPT_DATA_RESP_TIMEOUT(14)\n\t\t\t\t| SD_CARDOPT_C2_MODULE_ABSENT\n\t\t\t\t| SD_CARDOPT_DATA_XFR_WIDTH_1,\n\t\t\t\thost->ioaddr + SD_CARDOPTIONSETUP);\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tiowrite16(SD_CARDOPT_REQUIRED | SD_CARDOPT_DATA_RESP_TIMEOUT(14)\n\t\t\t\t| SD_CARDOPT_C2_MODULE_ABSENT\n\t\t\t\t| SD_CARDOPT_DATA_XFR_WIDTH_4,\n\t\t\t\thost->ioaddr + SD_CARDOPTIONSETUP);\n\t\tbreak;\n\t}\n}\n\nstatic void toshsd_set_led(struct toshsd_host *host, unsigned char state)\n{\n\tiowrite16(state, host->ioaddr + SDIO_BASE + SDIO_LEDCTRL);\n}\n\nstatic void toshsd_finish_request(struct toshsd_host *host)\n{\n\tstruct mmc_request *mrq = host->mrq;\n\n\t \n\thost->mrq = NULL;\n\thost->cmd = NULL;\n\thost->data = NULL;\n\n\ttoshsd_set_led(host, 0);\n\tmmc_request_done(host->mmc, mrq);\n}\n\nstatic irqreturn_t toshsd_thread_irq(int irq, void *dev_id)\n{\n\tstruct toshsd_host *host = dev_id;\n\tstruct mmc_data *data = host->data;\n\tstruct sg_mapping_iter *sg_miter = &host->sg_miter;\n\tunsigned short *buf;\n\tint count;\n\tunsigned long flags;\n\n\tif (!data) {\n\t\tdev_warn(&host->pdev->dev, \"Spurious Data IRQ\\n\");\n\t\tif (host->cmd) {\n\t\t\thost->cmd->error = -EIO;\n\t\t\ttoshsd_finish_request(host);\n\t\t}\n\t\treturn IRQ_NONE;\n\t}\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tif (!sg_miter_next(sg_miter))\n\t\tgoto done;\n\n\tbuf = sg_miter->addr;\n\n\t \n\tcount = sg_miter->length;\n\tif (count > data->blksz)\n\t\tcount = data->blksz;\n\n\tdev_dbg(&host->pdev->dev, \"count: %08x, flags %08x\\n\", count,\n\t\tdata->flags);\n\n\t \n\tif (data->flags & MMC_DATA_READ)\n\t\tioread32_rep(host->ioaddr + SD_DATAPORT, buf, count >> 2);\n\telse\n\t\tiowrite32_rep(host->ioaddr + SD_DATAPORT, buf, count >> 2);\n\n\tsg_miter->consumed = count;\n\tsg_miter_stop(sg_miter);\n\ndone:\n\tspin_unlock_irqrestore(&host->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void toshsd_cmd_irq(struct toshsd_host *host)\n{\n\tstruct mmc_command *cmd = host->cmd;\n\tu8 *buf;\n\tu16 data;\n\n\tif (!host->cmd) {\n\t\tdev_warn(&host->pdev->dev, \"Spurious CMD irq\\n\");\n\t\treturn;\n\t}\n\tbuf = (u8 *)cmd->resp;\n\thost->cmd = NULL;\n\n\tif (cmd->flags & MMC_RSP_PRESENT && cmd->flags & MMC_RSP_136) {\n\t\t \n\t\tbuf[12] = 0xff;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE0);\n\t\tbuf[13] = data & 0xff;\n\t\tbuf[14] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE1);\n\t\tbuf[15] = data & 0xff;\n\t\tbuf[8] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE2);\n\t\tbuf[9] = data & 0xff;\n\t\tbuf[10] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE3);\n\t\tbuf[11] = data & 0xff;\n\t\tbuf[4] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE4);\n\t\tbuf[5] = data & 0xff;\n\t\tbuf[6] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE5);\n\t\tbuf[7] = data & 0xff;\n\t\tbuf[0] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE6);\n\t\tbuf[1] = data & 0xff;\n\t\tbuf[2] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE7);\n\t\tbuf[3] = data & 0xff;\n\t} else if (cmd->flags & MMC_RSP_PRESENT) {\n\t\t \n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE0);\n\t\tbuf[0] = data & 0xff;\n\t\tbuf[1] = data >> 8;\n\t\tdata = ioread16(host->ioaddr + SD_RESPONSE1);\n\t\tbuf[2] = data & 0xff;\n\t\tbuf[3] = data >> 8;\n\t}\n\n\tdev_dbg(&host->pdev->dev, \"Command IRQ complete %d %d %x\\n\",\n\t\tcmd->opcode, cmd->error, cmd->flags);\n\n\t \n\tif (host->data)\n\t\treturn;\n\n\ttoshsd_finish_request(host);\n}\n\nstatic void toshsd_data_end_irq(struct toshsd_host *host)\n{\n\tstruct mmc_data *data = host->data;\n\n\thost->data = NULL;\n\n\tif (!data) {\n\t\tdev_warn(&host->pdev->dev, \"Spurious data end IRQ\\n\");\n\t\treturn;\n\t}\n\n\tif (data->error == 0)\n\t\tdata->bytes_xfered = data->blocks * data->blksz;\n\telse\n\t\tdata->bytes_xfered = 0;\n\n\tdev_dbg(&host->pdev->dev, \"Completed data request xfr=%d\\n\",\n\t\tdata->bytes_xfered);\n\n\tiowrite16(0, host->ioaddr + SD_STOPINTERNAL);\n\n\ttoshsd_finish_request(host);\n}\n\nstatic irqreturn_t toshsd_irq(int irq, void *dev_id)\n{\n\tstruct toshsd_host *host = dev_id;\n\tu32 int_reg, int_mask, int_status, detail;\n\tint error = 0, ret = IRQ_HANDLED;\n\n\tspin_lock(&host->lock);\n\tint_status = ioread32(host->ioaddr + SD_CARDSTATUS);\n\tint_mask = ioread32(host->ioaddr + SD_INTMASKCARD);\n\tint_reg = int_status & ~int_mask & ~IRQ_DONT_CARE_BITS;\n\n\tdev_dbg(&host->pdev->dev, \"IRQ status:%x mask:%x\\n\",\n\t\tint_status, int_mask);\n\n\t \n\tif (!int_reg) {\n\t\tret = IRQ_NONE;\n\t\tgoto irq_end;\n\t}\n\n\tif (int_reg & SD_BUF_CMD_TIMEOUT) {\n\t\terror = -ETIMEDOUT;\n\t\tdev_dbg(&host->pdev->dev, \"Timeout\\n\");\n\t} else if (int_reg & SD_BUF_CRC_ERR) {\n\t\terror = -EILSEQ;\n\t\tdev_err(&host->pdev->dev, \"BadCRC\\n\");\n\t} else if (int_reg & (SD_BUF_ILLEGAL_ACCESS\n\t\t\t\t| SD_BUF_CMD_INDEX_ERR\n\t\t\t\t| SD_BUF_STOP_BIT_END_ERR\n\t\t\t\t| SD_BUF_OVERFLOW\n\t\t\t\t| SD_BUF_UNDERFLOW\n\t\t\t\t| SD_BUF_DATA_TIMEOUT)) {\n\t\tdev_err(&host->pdev->dev, \"Buffer status error: { %s%s%s%s%s%s}\\n\",\n\t\t\tint_reg & SD_BUF_ILLEGAL_ACCESS ? \"ILLEGAL_ACC \" : \"\",\n\t\t\tint_reg & SD_BUF_CMD_INDEX_ERR ? \"CMD_INDEX \" : \"\",\n\t\t\tint_reg & SD_BUF_STOP_BIT_END_ERR ? \"STOPBIT_END \" : \"\",\n\t\t\tint_reg & SD_BUF_OVERFLOW ? \"OVERFLOW \" : \"\",\n\t\t\tint_reg & SD_BUF_UNDERFLOW ? \"UNDERFLOW \" : \"\",\n\t\t\tint_reg & SD_BUF_DATA_TIMEOUT ? \"DATA_TIMEOUT \" : \"\");\n\n\t\tdetail = ioread32(host->ioaddr + SD_ERRORSTATUS0);\n\t\tdev_err(&host->pdev->dev, \"detail error status { %s%s%s%s%s%s%s%s%s%s%s%s%s}\\n\",\n\t\t\tdetail & SD_ERR0_RESP_CMD_ERR ? \"RESP_CMD \" : \"\",\n\t\t\tdetail & SD_ERR0_RESP_NON_CMD12_END_BIT_ERR ? \"RESP_END_BIT \" : \"\",\n\t\t\tdetail & SD_ERR0_RESP_CMD12_END_BIT_ERR ? \"RESP_END_BIT \" : \"\",\n\t\t\tdetail & SD_ERR0_READ_DATA_END_BIT_ERR ? \"READ_DATA_END_BIT \" : \"\",\n\t\t\tdetail & SD_ERR0_WRITE_CRC_STATUS_END_BIT_ERR ? \"WRITE_CMD_END_BIT \" : \"\",\n\t\t\tdetail & SD_ERR0_RESP_NON_CMD12_CRC_ERR ? \"RESP_CRC \" : \"\",\n\t\t\tdetail & SD_ERR0_RESP_CMD12_CRC_ERR ? \"RESP_CRC \" : \"\",\n\t\t\tdetail & SD_ERR0_READ_DATA_CRC_ERR ? \"READ_DATA_CRC \" : \"\",\n\t\t\tdetail & SD_ERR0_WRITE_CMD_CRC_ERR ? \"WRITE_CMD_CRC \" : \"\",\n\t\t\tdetail & SD_ERR1_NO_CMD_RESP ? \"NO_CMD_RESP \" : \"\",\n\t\t\tdetail & SD_ERR1_TIMEOUT_READ_DATA ? \"READ_DATA_TIMEOUT \" : \"\",\n\t\t\tdetail & SD_ERR1_TIMEOUT_CRS_STATUS ? \"CRS_STATUS_TIMEOUT \" : \"\",\n\t\t\tdetail & SD_ERR1_TIMEOUT_CRC_BUSY ? \"CRC_BUSY_TIMEOUT \" : \"\");\n\t\terror = -EIO;\n\t}\n\n\tif (error) {\n\t\tif (host->cmd)\n\t\t\thost->cmd->error = error;\n\n\t\tif (error == -ETIMEDOUT) {\n\t\t\tiowrite32(int_status &\n\t\t\t\t  ~(SD_BUF_CMD_TIMEOUT | SD_CARD_RESP_END),\n\t\t\t\t  host->ioaddr + SD_CARDSTATUS);\n\t\t} else {\n\t\t\ttoshsd_init(host);\n\t\t\t__toshsd_set_ios(host->mmc, &host->mmc->ios);\n\t\t\tgoto irq_end;\n\t\t}\n\t}\n\n\t \n\tif (int_reg & (SD_CARD_CARD_INSERTED_0 | SD_CARD_CARD_REMOVED_0)) {\n\t\tiowrite32(int_status &\n\t\t\t  ~(SD_CARD_CARD_REMOVED_0 | SD_CARD_CARD_INSERTED_0),\n\t\t\t  host->ioaddr + SD_CARDSTATUS);\n\n\t\tif (int_reg & SD_CARD_CARD_INSERTED_0)\n\t\t\ttoshsd_init(host);\n\n\t\tmmc_detect_change(host->mmc, 1);\n\t}\n\n\t \n\tif (int_reg & (SD_BUF_READ_ENABLE | SD_BUF_WRITE_ENABLE)) {\n\t\tiowrite32(int_status &\n\t\t\t  ~(SD_BUF_WRITE_ENABLE | SD_BUF_READ_ENABLE),\n\t\t\t  host->ioaddr + SD_CARDSTATUS);\n\n\t\tret = IRQ_WAKE_THREAD;\n\t\tgoto irq_end;\n\t}\n\n\t \n\tif (int_reg & SD_CARD_RESP_END) {\n\t\tiowrite32(int_status & ~(SD_CARD_RESP_END),\n\t\t\t  host->ioaddr + SD_CARDSTATUS);\n\t\ttoshsd_cmd_irq(host);\n\t}\n\n\t \n\tif (int_reg & SD_CARD_RW_END) {\n\t\tiowrite32(int_status & ~(SD_CARD_RW_END),\n\t\t\t  host->ioaddr + SD_CARDSTATUS);\n\t\ttoshsd_data_end_irq(host);\n\t}\nirq_end:\n\tspin_unlock(&host->lock);\n\treturn ret;\n}\n\nstatic void toshsd_start_cmd(struct toshsd_host *host, struct mmc_command *cmd)\n{\n\tstruct mmc_data *data = host->data;\n\tint c = cmd->opcode;\n\n\tdev_dbg(&host->pdev->dev, \"Command opcode: %d\\n\", cmd->opcode);\n\n\tif (cmd->opcode == MMC_STOP_TRANSMISSION) {\n\t\tiowrite16(SD_STOPINT_ISSUE_CMD12,\n\t\t\t  host->ioaddr + SD_STOPINTERNAL);\n\n\t\tcmd->resp[0] = cmd->opcode;\n\t\tcmd->resp[1] = 0;\n\t\tcmd->resp[2] = 0;\n\t\tcmd->resp[3] = 0;\n\n\t\ttoshsd_finish_request(host);\n\t\treturn;\n\t}\n\n\tswitch (mmc_resp_type(cmd)) {\n\tcase MMC_RSP_NONE:\n\t\tc |= SD_CMD_RESP_TYPE_NONE;\n\t\tbreak;\n\n\tcase MMC_RSP_R1:\n\t\tc |= SD_CMD_RESP_TYPE_EXT_R1;\n\t\tbreak;\n\tcase MMC_RSP_R1B:\n\t\tc |= SD_CMD_RESP_TYPE_EXT_R1B;\n\t\tbreak;\n\tcase MMC_RSP_R2:\n\t\tc |= SD_CMD_RESP_TYPE_EXT_R2;\n\t\tbreak;\n\tcase MMC_RSP_R3:\n\t\tc |= SD_CMD_RESP_TYPE_EXT_R3;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&host->pdev->dev, \"Unknown response type %d\\n\",\n\t\t\tmmc_resp_type(cmd));\n\t\tbreak;\n\t}\n\n\thost->cmd = cmd;\n\n\tif (cmd->opcode == MMC_APP_CMD)\n\t\tc |= SD_CMD_TYPE_ACMD;\n\n\tif (cmd->opcode == MMC_GO_IDLE_STATE)\n\t\tc |= (3 << 8);   \n\n\tif (data) {\n\t\tc |= SD_CMD_DATA_PRESENT;\n\n\t\tif (data->blocks > 1) {\n\t\t\tiowrite16(SD_STOPINT_AUTO_ISSUE_CMD12,\n\t\t\t\t  host->ioaddr + SD_STOPINTERNAL);\n\t\t\tc |= SD_CMD_MULTI_BLOCK;\n\t\t}\n\n\t\tif (data->flags & MMC_DATA_READ)\n\t\t\tc |= SD_CMD_TRANSFER_READ;\n\n\t\t \n\t}\n\n\t \n\tiowrite32(cmd->arg, host->ioaddr + SD_ARG0);\n\tiowrite16(c, host->ioaddr + SD_CMD);\n}\n\nstatic void toshsd_start_data(struct toshsd_host *host, struct mmc_data *data)\n{\n\tunsigned int flags = SG_MITER_ATOMIC;\n\n\tdev_dbg(&host->pdev->dev, \"setup data transfer: blocksize %08x  nr_blocks %d, offset: %08x\\n\",\n\t\tdata->blksz, data->blocks, data->sg->offset);\n\n\thost->data = data;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\tflags |= SG_MITER_TO_SG;\n\telse\n\t\tflags |= SG_MITER_FROM_SG;\n\n\tsg_miter_start(&host->sg_miter, data->sg, data->sg_len, flags);\n\n\t \n\tiowrite16(data->blocks, host->ioaddr + SD_BLOCKCOUNT);\n\tiowrite16(data->blksz, host->ioaddr + SD_CARDXFERDATALEN);\n}\n\n \nstatic void toshsd_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct toshsd_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\t \n\tif (!(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_PRESENT_0)) {\n\t\tmrq->cmd->error = -ENOMEDIUM;\n\t\tmmc_request_done(mmc, mrq);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&host->lock, flags);\n\n\tWARN_ON(host->mrq != NULL);\n\n\thost->mrq = mrq;\n\n\tif (mrq->data)\n\t\ttoshsd_start_data(host, mrq->data);\n\n\ttoshsd_set_led(host, 1);\n\n\ttoshsd_start_cmd(host, mrq->cmd);\n\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic void toshsd_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct toshsd_host *host = mmc_priv(mmc);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&host->lock, flags);\n\t__toshsd_set_ios(mmc, ios);\n\tspin_unlock_irqrestore(&host->lock, flags);\n}\n\nstatic int toshsd_get_ro(struct mmc_host *mmc)\n{\n\tstruct toshsd_host *host = mmc_priv(mmc);\n\n\t \n\treturn !(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_WRITE_PROTECT);\n}\n\nstatic int toshsd_get_cd(struct mmc_host *mmc)\n{\n\tstruct toshsd_host *host = mmc_priv(mmc);\n\n\treturn !!(ioread16(host->ioaddr + SD_CARDSTATUS) & SD_CARD_PRESENT_0);\n}\n\nstatic const struct mmc_host_ops toshsd_ops = {\n\t.request = toshsd_request,\n\t.set_ios = toshsd_set_ios,\n\t.get_ro = toshsd_get_ro,\n\t.get_cd = toshsd_get_cd,\n};\n\n\nstatic void toshsd_powerdown(struct toshsd_host *host)\n{\n\t \n\tiowrite32(0xffffffff, host->ioaddr + SD_INTMASKCARD);\n\t \n\tiowrite16(0x000, host->ioaddr + SDIO_BASE + SDIO_CLOCKNWAITCTRL);\n\tiowrite16(0, host->ioaddr + SD_CARDCLOCKCTRL);\n\t \n\tpci_write_config_byte(host->pdev, SD_PCICFG_POWER1, SD_PCICFG_PWR1_OFF);\n\t \n\tpci_write_config_byte(host->pdev, SD_PCICFG_CLKSTOP, 0);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int toshsd_pm_suspend(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct toshsd_host *host = pci_get_drvdata(pdev);\n\n\ttoshsd_powerdown(host);\n\n\tpci_save_state(pdev);\n\tpci_enable_wake(pdev, PCI_D3hot, 0);\n\tpci_disable_device(pdev);\n\tpci_set_power_state(pdev, PCI_D3hot);\n\n\treturn 0;\n}\n\nstatic int toshsd_pm_resume(struct device *dev)\n{\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\tstruct toshsd_host *host = pci_get_drvdata(pdev);\n\tint ret;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\ttoshsd_init(host);\n\n\treturn 0;\n}\n#endif  \n\nstatic int toshsd_probe(struct pci_dev *pdev, const struct pci_device_id *ent)\n{\n\tint ret;\n\tstruct toshsd_host *host;\n\tstruct mmc_host *mmc;\n\tresource_size_t base;\n\n\tret = pci_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc = mmc_alloc_host(sizeof(struct toshsd_host), &pdev->dev);\n\tif (!mmc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thost = mmc_priv(mmc);\n\thost->mmc = mmc;\n\n\thost->pdev = pdev;\n\tpci_set_drvdata(pdev, host);\n\n\tret = pci_request_regions(pdev, DRIVER_NAME);\n\tif (ret)\n\t\tgoto free;\n\n\thost->ioaddr = pci_iomap(pdev, 0, 0);\n\tif (!host->ioaddr) {\n\t\tret = -ENOMEM;\n\t\tgoto release;\n\t}\n\n\t \n\tmmc->ops = &toshsd_ops;\n\tmmc->caps = MMC_CAP_4_BIT_DATA;\n\tmmc->ocr_avail = MMC_VDD_32_33;\n\n\tmmc->f_min = HCLK / 512;\n\tmmc->f_max = HCLK;\n\n\tspin_lock_init(&host->lock);\n\n\ttoshsd_init(host);\n\n\tret = request_threaded_irq(pdev->irq, toshsd_irq, toshsd_thread_irq,\n\t\t\t\t   IRQF_SHARED, DRIVER_NAME, host);\n\tif (ret)\n\t\tgoto unmap;\n\n\tret = mmc_add_host(mmc);\n\tif (ret)\n\t\tgoto free_irq;\n\n\tbase = pci_resource_start(pdev, 0);\n\tdev_dbg(&pdev->dev, \"MMIO %pa, IRQ %d\\n\", &base, pdev->irq);\n\n\tpm_suspend_ignore_children(&pdev->dev, 1);\n\n\treturn 0;\n\nfree_irq:\n\tfree_irq(pdev->irq, host);\nunmap:\n\tpci_iounmap(pdev, host->ioaddr);\nrelease:\n\tpci_release_regions(pdev);\nfree:\n\tmmc_free_host(mmc);\n\tpci_set_drvdata(pdev, NULL);\nerr:\n\tpci_disable_device(pdev);\n\treturn ret;\n}\n\nstatic void toshsd_remove(struct pci_dev *pdev)\n{\n\tstruct toshsd_host *host = pci_get_drvdata(pdev);\n\n\tmmc_remove_host(host->mmc);\n\ttoshsd_powerdown(host);\n\tfree_irq(pdev->irq, host);\n\tpci_iounmap(pdev, host->ioaddr);\n\tpci_release_regions(pdev);\n\tmmc_free_host(host->mmc);\n\tpci_set_drvdata(pdev, NULL);\n\tpci_disable_device(pdev);\n}\n\nstatic const struct dev_pm_ops toshsd_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(toshsd_pm_suspend, toshsd_pm_resume)\n};\n\nstatic struct pci_driver toshsd_driver = {\n\t.name = DRIVER_NAME,\n\t.id_table = pci_ids,\n\t.probe = toshsd_probe,\n\t.remove = toshsd_remove,\n\t.driver.pm = &toshsd_pm_ops,\n};\n\nmodule_pci_driver(toshsd_driver);\n\nMODULE_AUTHOR(\"Ondrej Zary, Richard Betts\");\nMODULE_DESCRIPTION(\"Toshiba PCI Secure Digital Host Controller Interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}