{
  "module_name": "sdhci-pic32.c",
  "hash_id": "7c50553882722b562ecba7f6b1e9efdaf073e61cae70365eecdbd254e3187195",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/sdhci-pic32.c",
  "human_readable_source": " \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/slab.h>\n#include <linux/mmc/host.h>\n#include <linux/io.h>\n#include \"sdhci.h\"\n#include \"sdhci-pltfm.h\"\n#include <linux/platform_data/sdhci-pic32.h>\n\n#define SDH_SHARED_BUS_CTRL\t\t0x000000E0\n#define SDH_SHARED_BUS_NR_CLK_PINS_MASK\t0x7\n#define SDH_SHARED_BUS_NR_IRQ_PINS_MASK\t0x30\n#define SDH_SHARED_BUS_CLK_PINS\t\t0x10\n#define SDH_SHARED_BUS_IRQ_PINS\t\t0x14\n#define SDH_CAPS_SDH_SLOT_TYPE_MASK\t0xC0000000\n#define SDH_SLOT_TYPE_REMOVABLE\t\t0x0\n#define SDH_SLOT_TYPE_EMBEDDED\t\t0x1\n#define SDH_SLOT_TYPE_SHARED_BUS\t0x2\n#define SDHCI_CTRL_CDSSEL\t\t0x80\n#define SDHCI_CTRL_CDTLVL\t\t0x40\n\n#define ADMA_FIFO_RD_THSHLD\t512\n#define ADMA_FIFO_WR_THSHLD\t512\n\nstruct pic32_sdhci_priv {\n\tstruct platform_device\t*pdev;\n\tstruct clk *sys_clk;\n\tstruct clk *base_clk;\n};\n\nstatic unsigned int pic32_sdhci_get_max_clock(struct sdhci_host *host)\n{\n\tstruct pic32_sdhci_priv *sdhci_pdata = sdhci_priv(host);\n\n\treturn clk_get_rate(sdhci_pdata->base_clk);\n}\n\nstatic void pic32_sdhci_set_bus_width(struct sdhci_host *host, int width)\n{\n\tu8 ctrl;\n\n\tctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);\n\tif (width == MMC_BUS_WIDTH_8) {\n\t\tctrl &= ~SDHCI_CTRL_4BITBUS;\n\t\tif (host->version >= SDHCI_SPEC_300)\n\t\t\tctrl |= SDHCI_CTRL_8BITBUS;\n\t} else {\n\t\tif (host->version >= SDHCI_SPEC_300)\n\t\t\tctrl &= ~SDHCI_CTRL_8BITBUS;\n\t\tif (width == MMC_BUS_WIDTH_4)\n\t\t\tctrl |= SDHCI_CTRL_4BITBUS;\n\t\telse\n\t\t\tctrl &= ~SDHCI_CTRL_4BITBUS;\n\t}\n\n\t \n\tctrl &= ~SDHCI_CTRL_CDTLVL;\n\tctrl |= SDHCI_CTRL_CDSSEL;\n\tsdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);\n}\n\nstatic unsigned int pic32_sdhci_get_ro(struct sdhci_host *host)\n{\n\t \n\treturn 0;\n}\n\nstatic const struct sdhci_ops pic32_sdhci_ops = {\n\t.get_max_clock = pic32_sdhci_get_max_clock,\n\t.set_clock = sdhci_set_clock,\n\t.set_bus_width = pic32_sdhci_set_bus_width,\n\t.reset = sdhci_reset,\n\t.set_uhs_signaling = sdhci_set_uhs_signaling,\n\t.get_ro = pic32_sdhci_get_ro,\n};\n\nstatic const struct sdhci_pltfm_data sdhci_pic32_pdata = {\n\t.ops = &pic32_sdhci_ops,\n\t.quirks = SDHCI_QUIRK_NO_HISPD_BIT,\n\t.quirks2 = SDHCI_QUIRK2_NO_1_8_V,\n};\n\nstatic void pic32_sdhci_shared_bus(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tu32 bus = readl(host->ioaddr + SDH_SHARED_BUS_CTRL);\n\tu32 clk_pins = (bus & SDH_SHARED_BUS_NR_CLK_PINS_MASK) >> 0;\n\tu32 irq_pins = (bus & SDH_SHARED_BUS_NR_IRQ_PINS_MASK) >> 4;\n\n\t \n\tif (clk_pins & 1)\n\t\tbus |= (1 << SDH_SHARED_BUS_CLK_PINS);\n\n\t \n\tif (irq_pins & 1)\n\t\tbus |= (1 << SDH_SHARED_BUS_IRQ_PINS);\n\n\twritel(bus, host->ioaddr + SDH_SHARED_BUS_CTRL);\n}\n\nstatic void pic32_sdhci_probe_platform(struct platform_device *pdev,\n\t\t\t\t      struct pic32_sdhci_priv *pdata)\n{\n\tu32 caps_slot_type;\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\n\t \n\thost->caps = readl(host->ioaddr + SDHCI_CAPABILITIES);\n\tcaps_slot_type = (host->caps & SDH_CAPS_SDH_SLOT_TYPE_MASK) >> 30;\n\tif (caps_slot_type == SDH_SLOT_TYPE_SHARED_BUS)\n\t\tpic32_sdhci_shared_bus(pdev);\n}\n\nstatic int pic32_sdhci_probe(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host;\n\tstruct sdhci_pltfm_host *pltfm_host;\n\tstruct pic32_sdhci_priv *sdhci_pdata;\n\tstruct pic32_sdhci_platform_data *plat_data;\n\tint ret;\n\n\thost = sdhci_pltfm_init(pdev, &sdhci_pic32_pdata,\n\t\t\t\tsizeof(struct pic32_sdhci_priv));\n\tif (IS_ERR(host)) {\n\t\tret = PTR_ERR(host);\n\t\tgoto err;\n\t}\n\n\tpltfm_host = sdhci_priv(host);\n\tsdhci_pdata = sdhci_pltfm_priv(pltfm_host);\n\n\tplat_data = pdev->dev.platform_data;\n\tif (plat_data && plat_data->setup_dma) {\n\t\tret = plat_data->setup_dma(ADMA_FIFO_RD_THSHLD,\n\t\t\t\t\t   ADMA_FIFO_WR_THSHLD);\n\t\tif (ret)\n\t\t\tgoto err_host;\n\t}\n\n\tsdhci_pdata->sys_clk = devm_clk_get(&pdev->dev, \"sys_clk\");\n\tif (IS_ERR(sdhci_pdata->sys_clk)) {\n\t\tret = PTR_ERR(sdhci_pdata->sys_clk);\n\t\tdev_err(&pdev->dev, \"Error getting clock\\n\");\n\t\tgoto err_host;\n\t}\n\n\tret = clk_prepare_enable(sdhci_pdata->sys_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error enabling clock\\n\");\n\t\tgoto err_host;\n\t}\n\n\tsdhci_pdata->base_clk = devm_clk_get(&pdev->dev, \"base_clk\");\n\tif (IS_ERR(sdhci_pdata->base_clk)) {\n\t\tret = PTR_ERR(sdhci_pdata->base_clk);\n\t\tdev_err(&pdev->dev, \"Error getting clock\\n\");\n\t\tgoto err_sys_clk;\n\t}\n\n\tret = clk_prepare_enable(sdhci_pdata->base_clk);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Error enabling clock\\n\");\n\t\tgoto err_base_clk;\n\t}\n\n\tret = mmc_of_parse(host->mmc);\n\tif (ret)\n\t\tgoto err_base_clk;\n\n\tpic32_sdhci_probe_platform(pdev, sdhci_pdata);\n\n\tret = sdhci_add_host(host);\n\tif (ret)\n\t\tgoto err_base_clk;\n\n\tdev_info(&pdev->dev, \"Successfully added sdhci host\\n\");\n\treturn 0;\n\nerr_base_clk:\n\tclk_disable_unprepare(sdhci_pdata->base_clk);\nerr_sys_clk:\n\tclk_disable_unprepare(sdhci_pdata->sys_clk);\nerr_host:\n\tsdhci_pltfm_free(pdev);\nerr:\n\tdev_err(&pdev->dev, \"pic32-sdhci probe failed: %d\\n\", ret);\n\treturn ret;\n}\n\nstatic void pic32_sdhci_remove(struct platform_device *pdev)\n{\n\tstruct sdhci_host *host = platform_get_drvdata(pdev);\n\tstruct pic32_sdhci_priv *sdhci_pdata = sdhci_priv(host);\n\tu32 scratch;\n\n\tscratch = readl(host->ioaddr + SDHCI_INT_STATUS);\n\tsdhci_remove_host(host, scratch == (u32)~0);\n\tclk_disable_unprepare(sdhci_pdata->base_clk);\n\tclk_disable_unprepare(sdhci_pdata->sys_clk);\n\tsdhci_pltfm_free(pdev);\n}\n\nstatic const struct of_device_id pic32_sdhci_id_table[] = {\n\t{ .compatible = \"microchip,pic32mzda-sdhci\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, pic32_sdhci_id_table);\n\nstatic struct platform_driver pic32_sdhci_driver = {\n\t.driver = {\n\t\t.name\t= \"pic32-sdhci\",\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t\t.of_match_table = of_match_ptr(pic32_sdhci_id_table),\n\t},\n\t.probe\t\t= pic32_sdhci_probe,\n\t.remove_new\t= pic32_sdhci_remove,\n};\n\nmodule_platform_driver(pic32_sdhci_driver);\n\nMODULE_DESCRIPTION(\"Microchip PIC32 SDHCI driver\");\nMODULE_AUTHOR(\"Pistirica Sorin Andrei & Sandeep Sheriker\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}