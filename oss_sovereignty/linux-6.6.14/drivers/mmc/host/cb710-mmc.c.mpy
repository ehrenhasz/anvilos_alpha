{
  "module_name": "cb710-mmc.c",
  "hash_id": "cca9fd67ef18da47a3ab8c6946f2fc0d1938aa81c3c7e63bcaa8dbdf46600fb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/host/cb710-mmc.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include \"cb710-mmc.h\"\n\n#define CB710_MMC_REQ_TIMEOUT_MS\t2000\n\nstatic const u8 cb710_clock_divider_log2[8] = {\n \n\t0, 1, 2, 3,  4,  5,   7,   9\n};\n#define CB710_MAX_DIVIDER_IDX\t\\\n\t(ARRAY_SIZE(cb710_clock_divider_log2) - 1)\n\nstatic const u8 cb710_src_freq_mhz[16] = {\n\t33, 10, 20, 25, 30, 35, 40, 45,\n\t50, 55, 60, 65, 70, 75, 80, 85\n};\n\nstatic void cb710_mmc_select_clock_divider(struct mmc_host *mmc, int hz)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\tstruct pci_dev *pdev = cb710_slot_to_chip(slot)->pdev;\n\tu32 src_freq_idx;\n\tu32 divider_idx;\n\tint src_hz;\n\n\t \n\tpci_read_config_dword(pdev, 0x48, &src_freq_idx);\n\tsrc_freq_idx = (src_freq_idx >> 16) & 0xF;\n\tsrc_hz = cb710_src_freq_mhz[src_freq_idx] * 1000000;\n\n\tfor (divider_idx = 0; divider_idx < CB710_MAX_DIVIDER_IDX; ++divider_idx) {\n\t\tif (hz >= src_hz >> cb710_clock_divider_log2[divider_idx])\n\t\t\tbreak;\n\t}\n\n\tif (src_freq_idx)\n\t\tdivider_idx |= 0x8;\n\telse if (divider_idx == 0)\n\t\tdivider_idx = 1;\n\n\tcb710_pci_update_config_reg(pdev, 0x40, ~0xF0000000, divider_idx << 28);\n\n\tdev_dbg(cb710_slot_dev(slot),\n\t\t\"clock set to %d Hz, wanted %d Hz; src_freq_idx = %d, divider_idx = %d|%d\\n\",\n\t\tsrc_hz >> cb710_clock_divider_log2[divider_idx & 7],\n\t\thz, src_freq_idx, divider_idx & 7, divider_idx & 8);\n}\n\nstatic void __cb710_mmc_enable_irq(struct cb710_slot *slot,\n\tunsigned short enable, unsigned short mask)\n{\n\t \n\tmask |= CB710_MMC_IE_IRQ_ENABLE;\n\n\t \n\n\tenable = (cb710_read_port_16(slot, CB710_MMC_IRQ_ENABLE_PORT)\n\t\t& ~mask) | enable;\n\n\tif (enable)\n\t\tenable |= CB710_MMC_IE_IRQ_ENABLE;\n\n\tcb710_write_port_16(slot, CB710_MMC_IRQ_ENABLE_PORT, enable);\n}\n\nstatic void cb710_mmc_enable_irq(struct cb710_slot *slot,\n\tunsigned short enable, unsigned short mask)\n{\n\tstruct cb710_mmc_reader *reader = mmc_priv(cb710_slot_to_mmc(slot));\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&reader->irq_lock, flags);\n\t \n\t__cb710_mmc_enable_irq(slot, enable, mask);\n\tspin_unlock_irqrestore(&reader->irq_lock, flags);\n}\n\nstatic void cb710_mmc_reset_events(struct cb710_slot *slot)\n{\n\tcb710_write_port_8(slot, CB710_MMC_STATUS0_PORT, 0xFF);\n\tcb710_write_port_8(slot, CB710_MMC_STATUS1_PORT, 0xFF);\n\tcb710_write_port_8(slot, CB710_MMC_STATUS2_PORT, 0xFF);\n}\n\nstatic void cb710_mmc_enable_4bit_data(struct cb710_slot *slot, int enable)\n{\n\tif (enable)\n\t\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT,\n\t\t\tCB710_MMC_C1_4BIT_DATA_BUS, 0);\n\telse\n\t\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT,\n\t\t\t0, CB710_MMC_C1_4BIT_DATA_BUS);\n}\n\nstatic int cb710_check_event(struct cb710_slot *slot, u8 what)\n{\n\tu16 status;\n\n\tstatus = cb710_read_port_16(slot, CB710_MMC_STATUS_PORT);\n\n\tif (status & CB710_MMC_S0_FIFO_UNDERFLOW) {\n\t\t \n\t\tdev_dbg(cb710_slot_dev(slot),\n\t\t\t\"CHECK : ignoring bit 6 in status %04X\\n\", status);\n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS0_PORT,\n\t\t\tCB710_MMC_S0_FIFO_UNDERFLOW);\n\t\tstatus &= ~CB710_MMC_S0_FIFO_UNDERFLOW;\n\t}\n\n\tif (status & CB710_MMC_STATUS_ERROR_EVENTS) {\n\t\tdev_dbg(cb710_slot_dev(slot),\n\t\t\t\"CHECK : returning EIO on status %04X\\n\", status);\n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS0_PORT, status & 0xFF);\n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS1_PORT,\n\t\t\tCB710_MMC_S1_RESET);\n\t\treturn -EIO;\n\t}\n\n\t \n\tif ((status >> 8) & what) {\n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS1_PORT, what);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int cb710_wait_for_event(struct cb710_slot *slot, u8 what)\n{\n\tint err = 0;\n\tunsigned limit = 2000000;\t \n\n#ifdef CONFIG_CB710_DEBUG\n\tu32 e, x;\n\te = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\n#endif\n\n\twhile (!(err = cb710_check_event(slot, what))) {\n\t\tif (!--limit) {\n\t\t\tcb710_dump_regs(cb710_slot_to_chip(slot),\n\t\t\t\tCB710_DUMP_REGS_MMC);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\n#ifdef CONFIG_CB710_DEBUG\n\tx = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\n\n\tlimit = 2000000 - limit;\n\tif (limit > 100)\n\t\tdev_dbg(cb710_slot_dev(slot),\n\t\t\t\"WAIT10: waited %d loops, what %d, entry val %08X, exit val %08X\\n\",\n\t\t\tlimit, what, e, x);\n#endif\n\treturn err < 0 ? err : 0;\n}\n\n\nstatic int cb710_wait_while_busy(struct cb710_slot *slot, uint8_t mask)\n{\n\tunsigned limit = 500000;\t \n\tint err = 0;\n\n#ifdef CONFIG_CB710_DEBUG\n\tu32 e, x;\n\te = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\n#endif\n\n\twhile (cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT) & mask) {\n\t\tif (!--limit) {\n\t\t\tcb710_dump_regs(cb710_slot_to_chip(slot),\n\t\t\t\tCB710_DUMP_REGS_MMC);\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\tudelay(1);\n\t}\n\n#ifdef CONFIG_CB710_DEBUG\n\tx = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\n\n\tlimit = 500000 - limit;\n\tif (limit > 100)\n\t\tdev_dbg(cb710_slot_dev(slot),\n\t\t\t\"WAIT12: waited %d loops, mask %02X, entry val %08X, exit val %08X\\n\",\n\t\t\tlimit, mask, e, x);\n#endif\n\treturn err;\n}\n\nstatic void cb710_mmc_set_transfer_size(struct cb710_slot *slot,\n\tsize_t count, size_t blocksize)\n{\n\tcb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tcb710_write_port_32(slot, CB710_MMC_TRANSFER_SIZE_PORT,\n\t\t((count - 1) << 16)|(blocksize - 1));\n\n\tdev_vdbg(cb710_slot_dev(slot), \"set up for %zu block%s of %zu bytes\\n\",\n\t\tcount, count == 1 ? \"\" : \"s\", blocksize);\n}\n\nstatic void cb710_mmc_fifo_hack(struct cb710_slot *slot)\n{\n\t \n\tu32 r1, r2;\n\tint ok = 0;\n\n\tr1 = cb710_read_port_32(slot, CB710_MMC_DATA_PORT);\n\tr2 = cb710_read_port_32(slot, CB710_MMC_DATA_PORT);\n\tif (cb710_read_port_8(slot, CB710_MMC_STATUS0_PORT)\n\t    & CB710_MMC_S0_FIFO_UNDERFLOW) {\n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS0_PORT,\n\t\t\tCB710_MMC_S0_FIFO_UNDERFLOW);\n\t\tok = 1;\n\t}\n\n\tdev_dbg(cb710_slot_dev(slot),\n\t\t\"FIFO-read-hack: expected STATUS0 bit was %s\\n\",\n\t\tok ? \"set.\" : \"NOT SET!\");\n\tdev_dbg(cb710_slot_dev(slot),\n\t\t\"FIFO-read-hack: dwords ignored: %08X %08X - %s\\n\",\n\t\tr1, r2, (r1|r2) ? \"BAD (NOT ZERO)!\" : \"ok\");\n}\n\nstatic int cb710_mmc_receive_pio(struct cb710_slot *slot,\n\tstruct sg_mapping_iter *miter, size_t dw_count)\n{\n\tif (!(cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT) & CB710_MMC_S2_FIFO_READY)) {\n\t\tint err = cb710_wait_for_event(slot,\n\t\t\tCB710_MMC_S1_PIO_TRANSFER_DONE);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcb710_sg_dwiter_write_from_io(miter,\n\t\tslot->iobase + CB710_MMC_DATA_PORT, dw_count);\n\n\treturn 0;\n}\n\nstatic bool cb710_is_transfer_size_supported(struct mmc_data *data)\n{\n\treturn !(data->blksz & 15 && (data->blocks != 1 || data->blksz != 8));\n}\n\nstatic int cb710_mmc_receive(struct cb710_slot *slot, struct mmc_data *data)\n{\n\tstruct sg_mapping_iter miter;\n\tsize_t len, blocks = data->blocks;\n\tint err = 0;\n\n\t \n\tif (unlikely(data->blksz & 15 && (data->blocks != 1 || data->blksz != 8)))\n\t\treturn -EINVAL;\n\n\tsg_miter_start(&miter, data->sg, data->sg_len, SG_MITER_TO_SG);\n\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\n\t\t15, CB710_MMC_C2_READ_PIO_SIZE_MASK);\n\n\tcb710_mmc_fifo_hack(slot);\n\n\twhile (blocks-- > 0) {\n\t\tlen = data->blksz;\n\n\t\twhile (len >= 16) {\n\t\t\terr = cb710_mmc_receive_pio(slot, &miter, 4);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\tlen -= 16;\n\t\t}\n\n\t\tif (!len)\n\t\t\tcontinue;\n\n\t\tcb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\n\t\t\tlen - 1, CB710_MMC_C2_READ_PIO_SIZE_MASK);\n\n\t\tlen = (len >= 8) ? 4 : 2;\n\t\terr = cb710_mmc_receive_pio(slot, &miter, len);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\nout:\n\tsg_miter_stop(&miter);\n\treturn err;\n}\n\nstatic int cb710_mmc_send(struct cb710_slot *slot, struct mmc_data *data)\n{\n\tstruct sg_mapping_iter miter;\n\tsize_t len, blocks = data->blocks;\n\tint err = 0;\n\n\t \n\tif (unlikely(data->blocks > 1 && data->blksz & 15))\n\t\treturn -EINVAL;\n\n\tsg_miter_start(&miter, data->sg, data->sg_len, SG_MITER_FROM_SG);\n\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT,\n\t\t0, CB710_MMC_C2_READ_PIO_SIZE_MASK);\n\n\twhile (blocks-- > 0) {\n\t\tlen = (data->blksz + 15) >> 4;\n\t\tdo {\n\t\t\tif (!(cb710_read_port_8(slot, CB710_MMC_STATUS2_PORT)\n\t\t\t    & CB710_MMC_S2_FIFO_EMPTY)) {\n\t\t\t\terr = cb710_wait_for_event(slot,\n\t\t\t\t\tCB710_MMC_S1_PIO_TRANSFER_DONE);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcb710_sg_dwiter_read_to_io(&miter,\n\t\t\t\tslot->iobase + CB710_MMC_DATA_PORT, 4);\n\t\t} while (--len);\n\t}\nout:\n\tsg_miter_stop(&miter);\n\treturn err;\n}\n\nstatic u16 cb710_encode_cmd_flags(struct cb710_mmc_reader *reader,\n\tstruct mmc_command *cmd)\n{\n\tunsigned int flags = cmd->flags;\n\tu16 cb_flags = 0;\n\n\t \n\n\tswitch (flags & MMC_CMD_MASK) {\n\tcase MMC_CMD_AC:\tcb_flags = CB710_MMC_CMD_AC;\tbreak;\n\tcase MMC_CMD_ADTC:\tcb_flags = CB710_MMC_CMD_ADTC;\tbreak;\n\tcase MMC_CMD_BC:\tcb_flags = CB710_MMC_CMD_BC;\tbreak;\n\tcase MMC_CMD_BCR:\tcb_flags = CB710_MMC_CMD_BCR;\tbreak;\n\t}\n\n\tif (flags & MMC_RSP_BUSY)\n\t\tcb_flags |= CB710_MMC_RSP_BUSY;\n\n\tcb_flags |= cmd->opcode << CB710_MMC_CMD_CODE_SHIFT;\n\n\tif (cmd->data && (cmd->data->flags & MMC_DATA_READ))\n\t\tcb_flags |= CB710_MMC_DATA_READ;\n\n\tif (flags & MMC_RSP_PRESENT) {\n\t\t \n\t\tcb_flags |= CB710_MMC_RSP_PRESENT;\n\n\t\tif (flags & MMC_RSP_136)\n\t\t\tcb_flags |= CB710_MMC_RSP_136;\n\t\tif (!(flags & MMC_RSP_CRC))\n\t\t\tcb_flags |= CB710_MMC_RSP_NO_CRC;\n\t}\n\n\treturn cb_flags;\n}\n\nstatic void cb710_receive_response(struct cb710_slot *slot,\n\tstruct mmc_command *cmd)\n{\n\tunsigned rsp_opcode, wanted_opcode;\n\n\t \n\tif (cmd->flags & MMC_RSP_136) {\n\t\tu32 resp[4];\n\n\t\tresp[0] = cb710_read_port_32(slot, CB710_MMC_RESPONSE3_PORT);\n\t\tresp[1] = cb710_read_port_32(slot, CB710_MMC_RESPONSE2_PORT);\n\t\tresp[2] = cb710_read_port_32(slot, CB710_MMC_RESPONSE1_PORT);\n\t\tresp[3] = cb710_read_port_32(slot, CB710_MMC_RESPONSE0_PORT);\n\t\trsp_opcode = resp[0] >> 24;\n\n\t\tcmd->resp[0] = (resp[0] << 8)|(resp[1] >> 24);\n\t\tcmd->resp[1] = (resp[1] << 8)|(resp[2] >> 24);\n\t\tcmd->resp[2] = (resp[2] << 8)|(resp[3] >> 24);\n\t\tcmd->resp[3] = (resp[3] << 8);\n\t} else {\n\t\trsp_opcode = cb710_read_port_32(slot, CB710_MMC_RESPONSE1_PORT) & 0x3F;\n\t\tcmd->resp[0] = cb710_read_port_32(slot, CB710_MMC_RESPONSE0_PORT);\n\t}\n\n\twanted_opcode = (cmd->flags & MMC_RSP_OPCODE) ? cmd->opcode : 0x3F;\n\tif (rsp_opcode != wanted_opcode)\n\t\tcmd->error = -EILSEQ;\n}\n\nstatic int cb710_mmc_transfer_data(struct cb710_slot *slot,\n\tstruct mmc_data *data)\n{\n\tint error, to;\n\n\tif (data->flags & MMC_DATA_READ)\n\t\terror = cb710_mmc_receive(slot, data);\n\telse\n\t\terror = cb710_mmc_send(slot, data);\n\n\tto = cb710_wait_for_event(slot, CB710_MMC_S1_DATA_TRANSFER_DONE);\n\tif (!error)\n\t\terror = to;\n\n\tif (!error)\n\t\tdata->bytes_xfered = data->blksz * data->blocks;\n\treturn error;\n}\n\nstatic int cb710_mmc_command(struct mmc_host *mmc, struct mmc_command *cmd)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\tstruct cb710_mmc_reader *reader = mmc_priv(mmc);\n\tstruct mmc_data *data = cmd->data;\n\n\tu16 cb_cmd = cb710_encode_cmd_flags(reader, cmd);\n\tdev_dbg(cb710_slot_dev(slot), \"cmd request: 0x%04X\\n\", cb_cmd);\n\n\tif (data) {\n\t\tif (!cb710_is_transfer_size_supported(data)) {\n\t\t\tdata->error = -EINVAL;\n\t\t\treturn -1;\n\t\t}\n\t\tcb710_mmc_set_transfer_size(slot, data->blocks, data->blksz);\n\t}\n\n\tcb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20|CB710_MMC_S2_BUSY_10);\n\tcb710_write_port_16(slot, CB710_MMC_CMD_TYPE_PORT, cb_cmd);\n\tcb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tcb710_write_port_32(slot, CB710_MMC_CMD_PARAM_PORT, cmd->arg);\n\tcb710_mmc_reset_events(slot);\n\tcb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x01, 0);\n\n\tcmd->error = cb710_wait_for_event(slot, CB710_MMC_S1_COMMAND_SENT);\n\tif (cmd->error)\n\t\treturn -1;\n\n\tif (cmd->flags & MMC_RSP_PRESENT) {\n\t\tcb710_receive_response(slot, cmd);\n\t\tif (cmd->error)\n\t\t\treturn -1;\n\t}\n\n\tif (data)\n\t\tdata->error = cb710_mmc_transfer_data(slot, data);\n\treturn 0;\n}\n\nstatic void cb710_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\tstruct cb710_mmc_reader *reader = mmc_priv(mmc);\n\n\tWARN_ON(reader->mrq != NULL);\n\n\treader->mrq = mrq;\n\tcb710_mmc_enable_irq(slot, CB710_MMC_IE_TEST_MASK, 0);\n\n\tif (!cb710_mmc_command(mmc, mrq->cmd) && mrq->stop)\n\t\tcb710_mmc_command(mmc, mrq->stop);\n\n\ttasklet_schedule(&reader->finish_req_tasklet);\n}\n\nstatic int cb710_mmc_powerup(struct cb710_slot *slot)\n{\n#ifdef CONFIG_CB710_DEBUG\n\tstruct cb710_chip *chip = cb710_slot_to_chip(slot);\n#endif\n\tint err;\n\n\t \n\tdev_dbg(cb710_slot_dev(slot), \"bus powerup\\n\");\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\terr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tif (unlikely(err))\n\t\treturn err;\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x80, 0);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0x80, 0);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\tmdelay(1);\n\tdev_dbg(cb710_slot_dev(slot), \"after delay 1\\n\");\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\terr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tif (unlikely(err))\n\t\treturn err;\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x09, 0);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\tmdelay(1);\n\tdev_dbg(cb710_slot_dev(slot), \"after delay 2\\n\");\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\terr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tif (unlikely(err))\n\t\treturn err;\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0, 0x08);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\tmdelay(2);\n\tdev_dbg(cb710_slot_dev(slot), \"after delay 3\\n\");\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x06, 0);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0x70, 0);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG2_PORT, 0x80, 0);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0x03, 0);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\terr = cb710_wait_while_busy(slot, CB710_MMC_S2_BUSY_20);\n\tif (unlikely(err))\n\t\treturn err;\n\t \n\tcb710_write_port_16(slot, CB710_MMC_CONFIGB_PORT, 0xFFFF);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG0_PORT, 0x06, 0);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\tdev_dbg(cb710_slot_dev(slot), \"bus powerup finished\\n\");\n\n\treturn cb710_check_event(slot, 0);\n}\n\nstatic void cb710_mmc_powerdown(struct cb710_slot *slot)\n{\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG1_PORT, 0, 0x81);\n\tcb710_modify_port_8(slot, CB710_MMC_CONFIG3_PORT, 0, 0x80);\n}\n\nstatic void cb710_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\tstruct cb710_mmc_reader *reader = mmc_priv(mmc);\n\tint err;\n\n\tcb710_mmc_select_clock_divider(mmc, ios->clock);\n\n\tif (ios->power_mode != reader->last_power_mode) {\n\t\tswitch (ios->power_mode) {\n\t\tcase MMC_POWER_ON:\n\t\t\terr = cb710_mmc_powerup(slot);\n\t\t\tif (err) {\n\t\t\t\tdev_warn(cb710_slot_dev(slot),\n\t\t\t\t\t\"powerup failed (%d)- retrying\\n\", err);\n\t\t\t\tcb710_mmc_powerdown(slot);\n\t\t\t\tudelay(1);\n\t\t\t\terr = cb710_mmc_powerup(slot);\n\t\t\t\tif (err)\n\t\t\t\t\tdev_warn(cb710_slot_dev(slot),\n\t\t\t\t\t\t\"powerup retry failed (%d) - expect errors\\n\",\n\t\t\t\t\terr);\n\t\t\t}\n\t\t\treader->last_power_mode = MMC_POWER_ON;\n\t\t\tbreak;\n\t\tcase MMC_POWER_OFF:\n\t\t\tcb710_mmc_powerdown(slot);\n\t\t\treader->last_power_mode = MMC_POWER_OFF;\n\t\t\tbreak;\n\t\tcase MMC_POWER_UP:\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcb710_mmc_enable_4bit_data(slot, ios->bus_width != MMC_BUS_WIDTH_1);\n\n\tcb710_mmc_enable_irq(slot, CB710_MMC_IE_TEST_MASK, 0);\n}\n\nstatic int cb710_mmc_get_ro(struct mmc_host *mmc)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\n\treturn cb710_read_port_8(slot, CB710_MMC_STATUS3_PORT)\n\t\t& CB710_MMC_S3_WRITE_PROTECTED;\n}\n\nstatic int cb710_mmc_get_cd(struct mmc_host *mmc)\n{\n\tstruct cb710_slot *slot = cb710_mmc_to_slot(mmc);\n\n\treturn cb710_read_port_8(slot, CB710_MMC_STATUS3_PORT)\n\t\t& CB710_MMC_S3_CARD_DETECTED;\n}\n\nstatic int cb710_mmc_irq_handler(struct cb710_slot *slot)\n{\n\tstruct mmc_host *mmc = cb710_slot_to_mmc(slot);\n\tstruct cb710_mmc_reader *reader = mmc_priv(mmc);\n\tu32 status, config1, config2, irqen;\n\n\tstatus = cb710_read_port_32(slot, CB710_MMC_STATUS_PORT);\n\tirqen = cb710_read_port_32(slot, CB710_MMC_IRQ_ENABLE_PORT);\n\tconfig2 = cb710_read_port_32(slot, CB710_MMC_CONFIGB_PORT);\n\tconfig1 = cb710_read_port_32(slot, CB710_MMC_CONFIG_PORT);\n\n\tdev_dbg(cb710_slot_dev(slot), \"interrupt; status: %08X, \"\n\t\t\"ie: %08X, c2: %08X, c1: %08X\\n\",\n\t\tstatus, irqen, config2, config1);\n\n\tif (status & (CB710_MMC_S1_CARD_CHANGED << 8)) {\n\t\t \n\t\tcb710_write_port_8(slot, CB710_MMC_STATUS1_PORT,\n\t\t\tCB710_MMC_S1_CARD_CHANGED);\n\t\tif ((irqen & CB710_MMC_IE_CISTATUS_MASK)\n\t\t    == CB710_MMC_IE_CISTATUS_MASK)\n\t\t\tmmc_detect_change(mmc, HZ/5);\n\t} else {\n\t\tdev_dbg(cb710_slot_dev(slot), \"unknown interrupt (test)\\n\");\n\t\tspin_lock(&reader->irq_lock);\n\t\t__cb710_mmc_enable_irq(slot, 0, CB710_MMC_IE_TEST_MASK);\n\t\tspin_unlock(&reader->irq_lock);\n\t}\n\n\treturn 1;\n}\n\nstatic void cb710_mmc_finish_request_tasklet(struct tasklet_struct *t)\n{\n\tstruct cb710_mmc_reader *reader = from_tasklet(reader, t,\n\t\t\t\t\t\t       finish_req_tasklet);\n\tstruct mmc_request *mrq = reader->mrq;\n\n\treader->mrq = NULL;\n\tmmc_request_done(mmc_from_priv(reader), mrq);\n}\n\nstatic const struct mmc_host_ops cb710_mmc_host = {\n\t.request = cb710_mmc_request,\n\t.set_ios = cb710_mmc_set_ios,\n\t.get_ro = cb710_mmc_get_ro,\n\t.get_cd = cb710_mmc_get_cd,\n};\n\n#ifdef CONFIG_PM\n\nstatic int cb710_mmc_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\n\n\tcb710_mmc_enable_irq(slot, 0, ~0);\n\treturn 0;\n}\n\nstatic int cb710_mmc_resume(struct platform_device *pdev)\n{\n\tstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\n\n\tcb710_mmc_enable_irq(slot, 0, ~0);\n\treturn 0;\n}\n\n#endif  \n\nstatic int cb710_mmc_init(struct platform_device *pdev)\n{\n\tstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\n\tstruct cb710_chip *chip = cb710_slot_to_chip(slot);\n\tstruct mmc_host *mmc;\n\tstruct cb710_mmc_reader *reader;\n\tint err;\n\tu32 val;\n\n\tmmc = mmc_alloc_host(sizeof(*reader), cb710_slot_dev(slot));\n\tif (!mmc)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, mmc);\n\n\t \n\tpci_read_config_dword(chip->pdev, 0x48, &val);\n\tval = cb710_src_freq_mhz[(val >> 16) & 0xF];\n\tdev_dbg(cb710_slot_dev(slot), \"source frequency: %dMHz\\n\", val);\n\tval *= 1000000;\n\n\tmmc->ops = &cb710_mmc_host;\n\tmmc->f_max = val;\n\tmmc->f_min = val >> cb710_clock_divider_log2[CB710_MAX_DIVIDER_IDX];\n\tmmc->ocr_avail = MMC_VDD_32_33|MMC_VDD_33_34;\n\tmmc->caps = MMC_CAP_4_BIT_DATA;\n\t \n\tmmc->max_busy_timeout = CB710_MMC_REQ_TIMEOUT_MS;\n\n\treader = mmc_priv(mmc);\n\n\ttasklet_setup(&reader->finish_req_tasklet,\n\t\t      cb710_mmc_finish_request_tasklet);\n\tspin_lock_init(&reader->irq_lock);\n\tcb710_dump_regs(chip, CB710_DUMP_REGS_MMC);\n\n\tcb710_mmc_enable_irq(slot, 0, ~0);\n\tcb710_set_irq_handler(slot, cb710_mmc_irq_handler);\n\n\terr = mmc_add_host(mmc);\n\tif (unlikely(err))\n\t\tgoto err_free_mmc;\n\n\tdev_dbg(cb710_slot_dev(slot), \"mmc_hostname is %s\\n\",\n\t\tmmc_hostname(mmc));\n\n\tcb710_mmc_enable_irq(slot, CB710_MMC_IE_CARD_INSERTION_STATUS, 0);\n\n\treturn 0;\n\nerr_free_mmc:\n\tdev_dbg(cb710_slot_dev(slot), \"mmc_add_host() failed: %d\\n\", err);\n\n\tcb710_set_irq_handler(slot, NULL);\n\tmmc_free_host(mmc);\n\treturn err;\n}\n\nstatic void cb710_mmc_exit(struct platform_device *pdev)\n{\n\tstruct cb710_slot *slot = cb710_pdev_to_slot(pdev);\n\tstruct mmc_host *mmc = cb710_slot_to_mmc(slot);\n\tstruct cb710_mmc_reader *reader = mmc_priv(mmc);\n\n\tcb710_mmc_enable_irq(slot, 0, CB710_MMC_IE_CARD_INSERTION_STATUS);\n\n\tmmc_remove_host(mmc);\n\n\t \n\tcb710_mmc_enable_irq(slot, 0, ~0);\n\tcb710_set_irq_handler(slot, NULL);\n\n\t \n\tcb710_write_port_32(slot, CB710_MMC_CONFIG_PORT, 0);\n\tcb710_write_port_16(slot, CB710_MMC_CONFIGB_PORT, 0);\n\n\ttasklet_kill(&reader->finish_req_tasklet);\n\n\tmmc_free_host(mmc);\n}\n\nstatic struct platform_driver cb710_mmc_driver = {\n\t.driver.name = \"cb710-mmc\",\n\t.probe = cb710_mmc_init,\n\t.remove_new = cb710_mmc_exit,\n#ifdef CONFIG_PM\n\t.suspend = cb710_mmc_suspend,\n\t.resume = cb710_mmc_resume,\n#endif\n};\n\nmodule_platform_driver(cb710_mmc_driver);\n\nMODULE_AUTHOR(\"Micha\u0142 Miros\u0142aw <mirq-linux@rere.qmqm.pl>\");\nMODULE_DESCRIPTION(\"ENE CB710 memory card reader driver - MMC/SD part\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:cb710-mmc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}