{
  "module_name": "sdio_io.c",
  "hash_id": "5dc71a663891665b3f4f1060f1c30600475c6a247afc72f343d8c2adf02bd9f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_io.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"sdio_ops.h\"\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n\n \nvoid sdio_claim_host(struct sdio_func *func)\n{\n\tif (WARN_ON(!func))\n\t\treturn;\n\n\tmmc_claim_host(func->card->host);\n}\nEXPORT_SYMBOL_GPL(sdio_claim_host);\n\n \nvoid sdio_release_host(struct sdio_func *func)\n{\n\tif (WARN_ON(!func))\n\t\treturn;\n\n\tmmc_release_host(func->card->host);\n}\nEXPORT_SYMBOL_GPL(sdio_release_host);\n\n \nint sdio_enable_func(struct sdio_func *func)\n{\n\tint ret;\n\tunsigned char reg;\n\tunsigned long timeout;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"SDIO: Enabling device %s...\\n\", sdio_func_id(func));\n\n\tret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IOEx, 0, &reg);\n\tif (ret)\n\t\tgoto err;\n\n\treg |= 1 << func->num;\n\n\tret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IOEx, reg, NULL);\n\tif (ret)\n\t\tgoto err;\n\n\ttimeout = jiffies + msecs_to_jiffies(func->enable_timeout);\n\n\twhile (1) {\n\t\tret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IORx, 0, &reg);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tif (reg & (1 << func->num))\n\t\t\tbreak;\n\t\tret = -ETIME;\n\t\tif (time_after(jiffies, timeout))\n\t\t\tgoto err;\n\t}\n\n\tpr_debug(\"SDIO: Enabled device %s\\n\", sdio_func_id(func));\n\n\treturn 0;\n\nerr:\n\tpr_debug(\"SDIO: Failed to enable device %s\\n\", sdio_func_id(func));\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sdio_enable_func);\n\n \nint sdio_disable_func(struct sdio_func *func)\n{\n\tint ret;\n\tunsigned char reg;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"SDIO: Disabling device %s...\\n\", sdio_func_id(func));\n\n\tret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IOEx, 0, &reg);\n\tif (ret)\n\t\tgoto err;\n\n\treg &= ~(1 << func->num);\n\n\tret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IOEx, reg, NULL);\n\tif (ret)\n\t\tgoto err;\n\n\tpr_debug(\"SDIO: Disabled device %s\\n\", sdio_func_id(func));\n\n\treturn 0;\n\nerr:\n\tpr_debug(\"SDIO: Failed to disable device %s\\n\", sdio_func_id(func));\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sdio_disable_func);\n\n \nint sdio_set_block_size(struct sdio_func *func, unsigned blksz)\n{\n\tint ret;\n\n\tif (blksz > func->card->host->max_blk_size)\n\t\treturn -EINVAL;\n\n\tif (blksz == 0) {\n\t\tblksz = min(func->max_blksize, func->card->host->max_blk_size);\n\t\tblksz = min(blksz, 512u);\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 1, 0,\n\t\tSDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE,\n\t\tblksz & 0xff, NULL);\n\tif (ret)\n\t\treturn ret;\n\tret = mmc_io_rw_direct(func->card, 1, 0,\n\t\tSDIO_FBR_BASE(func->num) + SDIO_FBR_BLKSIZE + 1,\n\t\t(blksz >> 8) & 0xff, NULL);\n\tif (ret)\n\t\treturn ret;\n\tfunc->cur_blksize = blksz;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sdio_set_block_size);\n\n \nstatic inline unsigned int sdio_max_byte_size(struct sdio_func *func)\n{\n\tunsigned mval =\tfunc->card->host->max_blk_size;\n\n\tif (mmc_blksz_for_byte_mode(func->card))\n\t\tmval = min(mval, func->cur_blksize);\n\telse\n\t\tmval = min(mval, func->max_blksize);\n\n\tif (mmc_card_broken_byte_mode_512(func->card))\n\t\treturn min(mval, 511u);\n\n\treturn min(mval, 512u);  \n}\n\n \nstatic inline unsigned int _sdio_align_size(unsigned int sz)\n{\n\t \n\treturn ALIGN(sz, 4);\n}\n\n \nunsigned int sdio_align_size(struct sdio_func *func, unsigned int sz)\n{\n\tunsigned int orig_sz;\n\tunsigned int blk_sz, byte_sz;\n\tunsigned chunk_sz;\n\n\torig_sz = sz;\n\n\t \n\tsz = _sdio_align_size(sz);\n\n\t \n\tif (sz <= sdio_max_byte_size(func))\n\t\treturn sz;\n\n\tif (func->card->cccr.multi_block) {\n\t\t \n\t\tif ((sz % func->cur_blksize) == 0)\n\t\t\treturn sz;\n\n\t\t \n\t\tblk_sz = ((sz + func->cur_blksize - 1) /\n\t\t\tfunc->cur_blksize) * func->cur_blksize;\n\t\tblk_sz = _sdio_align_size(blk_sz);\n\n\t\t \n\t\tif ((blk_sz % func->cur_blksize) == 0)\n\t\t\treturn blk_sz;\n\n\t\t \n\t\tbyte_sz = _sdio_align_size(sz % func->cur_blksize);\n\t\tif (byte_sz <= sdio_max_byte_size(func)) {\n\t\t\tblk_sz = sz / func->cur_blksize;\n\t\t\treturn blk_sz * func->cur_blksize + byte_sz;\n\t\t}\n\t} else {\n\t\t \n\t\tchunk_sz = _sdio_align_size(sdio_max_byte_size(func));\n\t\tif (chunk_sz == sdio_max_byte_size(func)) {\n\t\t\t \n\t\t\tbyte_sz = orig_sz % chunk_sz;\n\t\t\tif (byte_sz) {\n\t\t\t\tbyte_sz = _sdio_align_size(byte_sz);\n\t\t\t}\n\n\t\t\treturn (orig_sz / chunk_sz) * chunk_sz + byte_sz;\n\t\t}\n\t}\n\n\t \n\treturn orig_sz;\n}\nEXPORT_SYMBOL_GPL(sdio_align_size);\n\n \nstatic int sdio_io_rw_ext_helper(struct sdio_func *func, int write,\n\tunsigned addr, int incr_addr, u8 *buf, unsigned size)\n{\n\tunsigned remainder = size;\n\tunsigned max_blocks;\n\tint ret;\n\n\tif (!func || (func->num > 7))\n\t\treturn -EINVAL;\n\n\t \n\tif (func->card->cccr.multi_block && (size > sdio_max_byte_size(func))) {\n\t\t \n\t\tmax_blocks = min(func->card->host->max_blk_count, 511u);\n\n\t\twhile (remainder >= func->cur_blksize) {\n\t\t\tunsigned blocks;\n\n\t\t\tblocks = remainder / func->cur_blksize;\n\t\t\tif (blocks > max_blocks)\n\t\t\t\tblocks = max_blocks;\n\t\t\tsize = blocks * func->cur_blksize;\n\n\t\t\tret = mmc_io_rw_extended(func->card, write,\n\t\t\t\tfunc->num, addr, incr_addr, buf,\n\t\t\t\tblocks, func->cur_blksize);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tremainder -= size;\n\t\t\tbuf += size;\n\t\t\tif (incr_addr)\n\t\t\t\taddr += size;\n\t\t}\n\t}\n\n\t \n\twhile (remainder > 0) {\n\t\tsize = min(remainder, sdio_max_byte_size(func));\n\n\t\t \n\t\tret = mmc_io_rw_extended(func->card, write, func->num, addr,\n\t\t\t incr_addr, buf, 0, size);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tremainder -= size;\n\t\tbuf += size;\n\t\tif (incr_addr)\n\t\t\taddr += size;\n\t}\n\treturn 0;\n}\n\n \nu8 sdio_readb(struct sdio_func *func, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\tu8 val;\n\n\tif (!func) {\n\t\tif (err_ret)\n\t\t\t*err_ret = -EINVAL;\n\t\treturn 0xFF;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, func->num, addr, 0, &val);\n\tif (err_ret)\n\t\t*err_ret = ret;\n\tif (ret)\n\t\treturn 0xFF;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(sdio_readb);\n\n \nvoid sdio_writeb(struct sdio_func *func, u8 b, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\n\tif (!func) {\n\t\tif (err_ret)\n\t\t\t*err_ret = -EINVAL;\n\t\treturn;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 1, func->num, addr, b, NULL);\n\tif (err_ret)\n\t\t*err_ret = ret;\n}\nEXPORT_SYMBOL_GPL(sdio_writeb);\n\n \nu8 sdio_writeb_readb(struct sdio_func *func, u8 write_byte,\n\tunsigned int addr, int *err_ret)\n{\n\tint ret;\n\tu8 val;\n\n\tret = mmc_io_rw_direct(func->card, 1, func->num, addr,\n\t\t\twrite_byte, &val);\n\tif (err_ret)\n\t\t*err_ret = ret;\n\tif (ret)\n\t\treturn 0xff;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(sdio_writeb_readb);\n\n \nint sdio_memcpy_fromio(struct sdio_func *func, void *dst,\n\tunsigned int addr, int count)\n{\n\treturn sdio_io_rw_ext_helper(func, 0, addr, 1, dst, count);\n}\nEXPORT_SYMBOL_GPL(sdio_memcpy_fromio);\n\n \nint sdio_memcpy_toio(struct sdio_func *func, unsigned int addr,\n\tvoid *src, int count)\n{\n\treturn sdio_io_rw_ext_helper(func, 1, addr, 1, src, count);\n}\nEXPORT_SYMBOL_GPL(sdio_memcpy_toio);\n\n \nint sdio_readsb(struct sdio_func *func, void *dst, unsigned int addr,\n\tint count)\n{\n\treturn sdio_io_rw_ext_helper(func, 0, addr, 0, dst, count);\n}\nEXPORT_SYMBOL_GPL(sdio_readsb);\n\n \nint sdio_writesb(struct sdio_func *func, unsigned int addr, void *src,\n\tint count)\n{\n\treturn sdio_io_rw_ext_helper(func, 1, addr, 0, src, count);\n}\nEXPORT_SYMBOL_GPL(sdio_writesb);\n\n \nu16 sdio_readw(struct sdio_func *func, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\n\tret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 2);\n\tif (err_ret)\n\t\t*err_ret = ret;\n\tif (ret)\n\t\treturn 0xFFFF;\n\n\treturn le16_to_cpup((__le16 *)func->tmpbuf);\n}\nEXPORT_SYMBOL_GPL(sdio_readw);\n\n \nvoid sdio_writew(struct sdio_func *func, u16 b, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\n\t*(__le16 *)func->tmpbuf = cpu_to_le16(b);\n\n\tret = sdio_memcpy_toio(func, addr, func->tmpbuf, 2);\n\tif (err_ret)\n\t\t*err_ret = ret;\n}\nEXPORT_SYMBOL_GPL(sdio_writew);\n\n \nu32 sdio_readl(struct sdio_func *func, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\n\tret = sdio_memcpy_fromio(func, func->tmpbuf, addr, 4);\n\tif (err_ret)\n\t\t*err_ret = ret;\n\tif (ret)\n\t\treturn 0xFFFFFFFF;\n\n\treturn le32_to_cpup((__le32 *)func->tmpbuf);\n}\nEXPORT_SYMBOL_GPL(sdio_readl);\n\n \nvoid sdio_writel(struct sdio_func *func, u32 b, unsigned int addr, int *err_ret)\n{\n\tint ret;\n\n\t*(__le32 *)func->tmpbuf = cpu_to_le32(b);\n\n\tret = sdio_memcpy_toio(func, addr, func->tmpbuf, 4);\n\tif (err_ret)\n\t\t*err_ret = ret;\n}\nEXPORT_SYMBOL_GPL(sdio_writel);\n\n \nunsigned char sdio_f0_readb(struct sdio_func *func, unsigned int addr,\n\tint *err_ret)\n{\n\tint ret;\n\tunsigned char val;\n\n\tif (!func) {\n\t\tif (err_ret)\n\t\t\t*err_ret = -EINVAL;\n\t\treturn 0xFF;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, 0, addr, 0, &val);\n\tif (err_ret)\n\t\t*err_ret = ret;\n\tif (ret)\n\t\treturn 0xFF;\n\n\treturn val;\n}\nEXPORT_SYMBOL_GPL(sdio_f0_readb);\n\n \nvoid sdio_f0_writeb(struct sdio_func *func, unsigned char b, unsigned int addr,\n\tint *err_ret)\n{\n\tint ret;\n\n\tif (!func) {\n\t\tif (err_ret)\n\t\t\t*err_ret = -EINVAL;\n\t\treturn;\n\t}\n\n\tif ((addr < 0xF0 || addr > 0xFF) && (!mmc_card_lenient_fn0(func->card))) {\n\t\tif (err_ret)\n\t\t\t*err_ret = -EINVAL;\n\t\treturn;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 1, 0, addr, b, NULL);\n\tif (err_ret)\n\t\t*err_ret = ret;\n}\nEXPORT_SYMBOL_GPL(sdio_f0_writeb);\n\n \nmmc_pm_flag_t sdio_get_host_pm_caps(struct sdio_func *func)\n{\n\tif (!func)\n\t\treturn 0;\n\n\treturn func->card->host->pm_caps;\n}\nEXPORT_SYMBOL_GPL(sdio_get_host_pm_caps);\n\n \nint sdio_set_host_pm_flags(struct sdio_func *func, mmc_pm_flag_t flags)\n{\n\tstruct mmc_host *host;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\thost = func->card->host;\n\n\tif (flags & ~host->pm_caps)\n\t\treturn -EINVAL;\n\n\t \n\thost->pm_flags |= flags;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sdio_set_host_pm_flags);\n\n \nvoid sdio_retune_crc_disable(struct sdio_func *func)\n{\n\tfunc->card->host->retune_crc_disable = true;\n}\nEXPORT_SYMBOL_GPL(sdio_retune_crc_disable);\n\n \nvoid sdio_retune_crc_enable(struct sdio_func *func)\n{\n\tfunc->card->host->retune_crc_disable = false;\n}\nEXPORT_SYMBOL_GPL(sdio_retune_crc_enable);\n\n \nvoid sdio_retune_hold_now(struct sdio_func *func)\n{\n\tmmc_retune_hold_now(func->card->host);\n}\nEXPORT_SYMBOL_GPL(sdio_retune_hold_now);\n\n \nvoid sdio_retune_release(struct sdio_func *func)\n{\n\tmmc_retune_release(func->card->host);\n}\nEXPORT_SYMBOL_GPL(sdio_retune_release);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}