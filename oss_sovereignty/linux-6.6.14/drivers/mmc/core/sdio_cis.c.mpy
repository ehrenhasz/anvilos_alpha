{
  "module_name": "sdio_cis.c",
  "hash_id": "28772aeb3a5af75790c53ef76eb6f63b9c2352851fb64b434823b7f665f84c6f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_cis.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"sdio_cis.h\"\n#include \"sdio_ops.h\"\n\n#define SDIO_READ_CIS_TIMEOUT_MS  (10 * 1000)  \n\nstatic int cistpl_vers_1(struct mmc_card *card, struct sdio_func *func,\n\t\t\t const unsigned char *buf, unsigned size)\n{\n\tu8 major_rev, minor_rev;\n\tunsigned i, nr_strings;\n\tchar **buffer, *string;\n\n\tif (size < 2)\n\t\treturn 0;\n\n\tmajor_rev = buf[0];\n\tminor_rev = buf[1];\n\n\t \n\tbuf += 2;\n\tsize -= 2;\n\n\tnr_strings = 0;\n\tfor (i = 0; i < size; i++) {\n\t\tif (buf[i] == 0xff)\n\t\t\tbreak;\n\t\tif (buf[i] == 0)\n\t\t\tnr_strings++;\n\t}\n\tif (nr_strings == 0)\n\t\treturn 0;\n\n\tsize = i;\n\n\tbuffer = kzalloc(sizeof(char*) * nr_strings + size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tstring = (char*)(buffer + nr_strings);\n\n\tfor (i = 0; i < nr_strings; i++) {\n\t\tbuffer[i] = string;\n\t\tstrcpy(string, buf);\n\t\tstring += strlen(string) + 1;\n\t\tbuf += strlen(buf) + 1;\n\t}\n\n\tif (func) {\n\t\tfunc->major_rev = major_rev;\n\t\tfunc->minor_rev = minor_rev;\n\t\tfunc->num_info = nr_strings;\n\t\tfunc->info = (const char**)buffer;\n\t} else {\n\t\tcard->major_rev = major_rev;\n\t\tcard->minor_rev = minor_rev;\n\t\tcard->num_info = nr_strings;\n\t\tcard->info = (const char**)buffer;\n\t}\n\n\treturn 0;\n}\n\nstatic int cistpl_manfid(struct mmc_card *card, struct sdio_func *func,\n\t\t\t const unsigned char *buf, unsigned size)\n{\n\tunsigned int vendor, device;\n\n\t \n\tvendor = buf[0] | (buf[1] << 8);\n\n\t \n\tdevice = buf[2] | (buf[3] << 8);\n\n\tif (func) {\n\t\tfunc->vendor = vendor;\n\t\tfunc->device = device;\n\t} else {\n\t\tcard->cis.vendor = vendor;\n\t\tcard->cis.device = device;\n\t}\n\n\treturn 0;\n}\n\nstatic const unsigned char speed_val[16] =\n\t{ 0, 10, 12, 13, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 70, 80 };\nstatic const unsigned int speed_unit[8] =\n\t{ 10000, 100000, 1000000, 10000000, 0, 0, 0, 0 };\n\n\ntypedef int (tpl_parse_t)(struct mmc_card *, struct sdio_func *,\n\t\t\t   const unsigned char *, unsigned);\n\nstruct cis_tpl {\n\tunsigned char code;\n\tunsigned char min_size;\n\ttpl_parse_t *parse;\n};\n\nstatic int cis_tpl_parse(struct mmc_card *card, struct sdio_func *func,\n\t\t\t const char *tpl_descr,\n\t\t\t const struct cis_tpl *tpl, int tpl_count,\n\t\t\t unsigned char code,\n\t\t\t const unsigned char *buf, unsigned size)\n{\n\tint i, ret;\n\n\t \n\tfor (i = 0; i < tpl_count; i++, tpl++) {\n\t\tif (tpl->code == code)\n\t\t\tbreak;\n\t}\n\tif (i < tpl_count) {\n\t\tif (size >= tpl->min_size) {\n\t\t\tif (tpl->parse)\n\t\t\t\tret = tpl->parse(card, func, buf, size);\n\t\t\telse\n\t\t\t\tret = -EILSEQ;\t \n\t\t} else {\n\t\t\t \n\t\t\tret = -EINVAL;\n\t\t}\n\t\tif (ret && ret != -EILSEQ && ret != -ENOENT) {\n\t\t\tpr_err(\"%s: bad %s tuple 0x%02x (%u bytes)\\n\",\n\t\t\t       mmc_hostname(card->host), tpl_descr, code, size);\n\t\t}\n\t} else {\n\t\t \n\t\tret = -ENOENT;\n\t}\n\n\treturn ret;\n}\n\nstatic int cistpl_funce_common(struct mmc_card *card, struct sdio_func *func,\n\t\t\t       const unsigned char *buf, unsigned size)\n{\n\t \n\tif (func)\n\t\treturn -EINVAL;\n\n\t \n\tcard->cis.blksize = buf[1] | (buf[2] << 8);\n\n\t \n\tcard->cis.max_dtr = speed_val[(buf[3] >> 3) & 15] *\n\t\t\t    speed_unit[buf[3] & 7];\n\n\treturn 0;\n}\n\nstatic int cistpl_funce_func(struct mmc_card *card, struct sdio_func *func,\n\t\t\t     const unsigned char *buf, unsigned size)\n{\n\tunsigned vsn;\n\tunsigned min_size;\n\n\t \n\tif (!func)\n\t\treturn -EINVAL;\n\n\t \n\tvsn = func->card->cccr.sdio_vsn;\n\tmin_size = (vsn == SDIO_SDIO_REV_1_00) ? 28 : 42;\n\n\tif (size == 28 && vsn == SDIO_SDIO_REV_1_10) {\n\t\tpr_warn(\"%s: card has broken SDIO 1.1 CIS, forcing SDIO 1.0\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\tvsn = SDIO_SDIO_REV_1_00;\n\t} else if (size < min_size) {\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfunc->max_blksize = buf[12] | (buf[13] << 8);\n\n\t \n\tif (vsn > SDIO_SDIO_REV_1_00)\n\t\tfunc->enable_timeout = (buf[28] | (buf[29] << 8)) * 10;\n\telse\n\t\tfunc->enable_timeout = jiffies_to_msecs(HZ);\n\n\treturn 0;\n}\n\n \nstatic const struct cis_tpl cis_tpl_funce_list[] = {\n\t{\t0x00,\t4,\tcistpl_funce_common\t\t},\n\t{\t0x01,\t0,\tcistpl_funce_func\t\t},\n\t{\t0x04,\t1+1+6,\t \t},\n};\n\nstatic int cistpl_funce(struct mmc_card *card, struct sdio_func *func,\n\t\t\tconst unsigned char *buf, unsigned size)\n{\n\tif (size < 1)\n\t\treturn -EINVAL;\n\n\treturn cis_tpl_parse(card, func, \"CISTPL_FUNCE\",\n\t\t\t     cis_tpl_funce_list,\n\t\t\t     ARRAY_SIZE(cis_tpl_funce_list),\n\t\t\t     buf[0], buf, size);\n}\n\n \nstatic const struct cis_tpl cis_tpl_list[] = {\n\t{\t0x15,\t3,\tcistpl_vers_1\t\t},\n\t{\t0x20,\t4,\tcistpl_manfid\t\t},\n\t{\t0x21,\t2,\t \t},\n\t{\t0x22,\t0,\tcistpl_funce\t\t},\n\t{\t0x91,\t2,\t \t},\n};\n\nstatic int sdio_read_cis(struct mmc_card *card, struct sdio_func *func)\n{\n\tint ret;\n\tstruct sdio_func_tuple *this, **prev;\n\tunsigned i, ptr = 0;\n\n\t \n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char x, fn;\n\n\t\tif (func)\n\t\t\tfn = func->num;\n\t\telse\n\t\t\tfn = 0;\n\n\t\tret = mmc_io_rw_direct(card, 0, 0,\n\t\t\tSDIO_FBR_BASE(fn) + SDIO_FBR_CIS + i, 0, &x);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tptr |= x << (i * 8);\n\t}\n\n\tif (func)\n\t\tprev = &func->tuples;\n\telse\n\t\tprev = &card->tuples;\n\n\tif (*prev)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tunsigned char tpl_code, tpl_link;\n\t\tunsigned long timeout = jiffies +\n\t\t\tmsecs_to_jiffies(SDIO_READ_CIS_TIMEOUT_MS);\n\n\t\tret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_code);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tpl_code == 0xff)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tpl_code == 0x00)\n\t\t\tcontinue;\n\n\t\tret = mmc_io_rw_direct(card, 0, 0, ptr++, 0, &tpl_link);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t \n\t\tif (tpl_link == 0xff)\n\t\t\tbreak;\n\n\t\tthis = kmalloc(sizeof(*this) + tpl_link, GFP_KERNEL);\n\t\tif (!this)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (i = 0; i < tpl_link; i++) {\n\t\t\tret = mmc_io_rw_direct(card, 0, 0,\n\t\t\t\t\t       ptr + i, 0, &this->data[i]);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (ret) {\n\t\t\tkfree(this);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tret = cis_tpl_parse(card, func, \"CIS\",\n\t\t\t\t    cis_tpl_list, ARRAY_SIZE(cis_tpl_list),\n\t\t\t\t    tpl_code, this->data, tpl_link);\n\t\tif (ret == -EILSEQ || ret == -ENOENT) {\n\t\t\t \n\t\t\tthis->next = NULL;\n\t\t\tthis->code = tpl_code;\n\t\t\tthis->size = tpl_link;\n\t\t\t*prev = this;\n\t\t\tprev = &this->next;\n\n\t\t\tif (ret == -ENOENT) {\n\n\t\t\t\tif (time_after(jiffies, timeout))\n\t\t\t\t\tbreak;\n\n#define FMT(type) \"%s: queuing \" type \" CIS tuple 0x%02x [%*ph] (%u bytes)\\n\"\n\t\t\t\t \n\t\t\t\tif (tpl_code >= 0x80 && tpl_code <= 0x8f)\n\t\t\t\t\tpr_debug_ratelimited(FMT(\"vendor\"),\n\t\t\t\t\t\tmmc_hostname(card->host),\n\t\t\t\t\t\ttpl_code, tpl_link, this->data,\n\t\t\t\t\t\ttpl_link);\n\t\t\t\telse\n\t\t\t\t\tpr_warn_ratelimited(FMT(\"unknown\"),\n\t\t\t\t\t\tmmc_hostname(card->host),\n\t\t\t\t\t\ttpl_code, tpl_link, this->data,\n\t\t\t\t\t\ttpl_link);\n\t\t\t}\n\n\t\t\t \n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tkfree(this);\n\t\t}\n\n\t\tptr += tpl_link;\n\t} while (!ret);\n\n\t \n\tif (func)\n\t\t*prev = card->tuples;\n\n\treturn ret;\n}\n\nint sdio_read_common_cis(struct mmc_card *card)\n{\n\treturn sdio_read_cis(card, NULL);\n}\n\nvoid sdio_free_common_cis(struct mmc_card *card)\n{\n\tstruct sdio_func_tuple *tuple, *victim;\n\n\ttuple = card->tuples;\n\n\twhile (tuple) {\n\t\tvictim = tuple;\n\t\ttuple = tuple->next;\n\t\tkfree(victim);\n\t}\n\n\tcard->tuples = NULL;\n}\n\nint sdio_read_func_cis(struct sdio_func *func)\n{\n\tint ret;\n\n\tret = sdio_read_cis(func->card, func);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (func->vendor == 0) {\n\t\tfunc->vendor = func->card->cis.vendor;\n\t\tfunc->device = func->card->cis.device;\n\t}\n\n\treturn 0;\n}\n\nvoid sdio_free_func_cis(struct sdio_func *func)\n{\n\tstruct sdio_func_tuple *tuple, *victim;\n\n\ttuple = func->tuples;\n\n\twhile (tuple && tuple != func->card->tuples) {\n\t\tvictim = tuple;\n\t\ttuple = tuple->next;\n\t\tkfree(victim);\n\t}\n\n\tfunc->tuples = NULL;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}