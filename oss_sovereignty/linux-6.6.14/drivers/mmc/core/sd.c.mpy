{
  "module_name": "sd.c",
  "hash_id": "ccad056883145d24d7f5d461f1f8e891719a1cc70524aab9574378fd34277dbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sd.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/sysfs.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"bus.h\"\n#include \"mmc_ops.h\"\n#include \"sd.h\"\n#include \"sd_ops.h\"\n\nstatic const unsigned int tran_exp[] = {\n\t10000,\t\t100000,\t\t1000000,\t10000000,\n\t0,\t\t0,\t\t0,\t\t0\n};\n\nstatic const unsigned char tran_mant[] = {\n\t0,\t10,\t12,\t13,\t15,\t20,\t25,\t30,\n\t35,\t40,\t45,\t50,\t55,\t60,\t70,\t80,\n};\n\nstatic const unsigned int taac_exp[] = {\n\t1,\t10,\t100,\t1000,\t10000,\t100000,\t1000000, 10000000,\n};\n\nstatic const unsigned int taac_mant[] = {\n\t0,\t10,\t12,\t13,\t15,\t20,\t25,\t30,\n\t35,\t40,\t45,\t50,\t55,\t60,\t70,\t80,\n};\n\nstatic const unsigned int sd_au_size[] = {\n\t0,\t\tSZ_16K / 512,\t\tSZ_32K / 512,\tSZ_64K / 512,\n\tSZ_128K / 512,\tSZ_256K / 512,\t\tSZ_512K / 512,\tSZ_1M / 512,\n\tSZ_2M / 512,\tSZ_4M / 512,\t\tSZ_8M / 512,\t(SZ_8M + SZ_4M) / 512,\n\tSZ_16M / 512,\t(SZ_16M + SZ_8M) / 512,\tSZ_32M / 512,\tSZ_64M / 512,\n};\n\n#define UNSTUFF_BITS(resp,start,size)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tconst int __size = size;\t\t\t\t\\\n\t\tconst u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;\t\\\n\t\tconst int __off = 3 - ((start) / 32);\t\t\t\\\n\t\tconst int __shft = (start) & 31;\t\t\t\\\n\t\tu32 __res;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__res = resp[__off] >> __shft;\t\t\t\t\\\n\t\tif (__size + __shft > 32)\t\t\t\t\\\n\t\t\t__res |= resp[__off-1] << ((32 - __shft) % 32);\t\\\n\t\t__res & __mask;\t\t\t\t\t\t\\\n\t})\n\n#define SD_POWEROFF_NOTIFY_TIMEOUT_MS 1000\n#define SD_WRITE_EXTR_SINGLE_TIMEOUT_MS 1000\n\nstruct sd_busy_data {\n\tstruct mmc_card *card;\n\tu8 *reg_buf;\n};\n\n \nvoid mmc_decode_cid(struct mmc_card *card)\n{\n\tu32 *resp = card->raw_cid;\n\n\t \n\tadd_device_randomness(&card->raw_cid, sizeof(card->raw_cid));\n\n\t \n\tcard->cid.manfid\t\t= UNSTUFF_BITS(resp, 120, 8);\n\tcard->cid.oemid\t\t\t= UNSTUFF_BITS(resp, 104, 16);\n\tcard->cid.prod_name[0]\t\t= UNSTUFF_BITS(resp, 96, 8);\n\tcard->cid.prod_name[1]\t\t= UNSTUFF_BITS(resp, 88, 8);\n\tcard->cid.prod_name[2]\t\t= UNSTUFF_BITS(resp, 80, 8);\n\tcard->cid.prod_name[3]\t\t= UNSTUFF_BITS(resp, 72, 8);\n\tcard->cid.prod_name[4]\t\t= UNSTUFF_BITS(resp, 64, 8);\n\tcard->cid.hwrev\t\t\t= UNSTUFF_BITS(resp, 60, 4);\n\tcard->cid.fwrev\t\t\t= UNSTUFF_BITS(resp, 56, 4);\n\tcard->cid.serial\t\t= UNSTUFF_BITS(resp, 24, 32);\n\tcard->cid.year\t\t\t= UNSTUFF_BITS(resp, 12, 8);\n\tcard->cid.month\t\t\t= UNSTUFF_BITS(resp, 8, 4);\n\n\tcard->cid.year += 2000;  \n}\n\n \nstatic int mmc_decode_csd(struct mmc_card *card)\n{\n\tstruct mmc_csd *csd = &card->csd;\n\tunsigned int e, m, csd_struct;\n\tu32 *resp = card->raw_csd;\n\n\tcsd_struct = UNSTUFF_BITS(resp, 126, 2);\n\n\tswitch (csd_struct) {\n\tcase 0:\n\t\tm = UNSTUFF_BITS(resp, 115, 4);\n\t\te = UNSTUFF_BITS(resp, 112, 3);\n\t\tcsd->taac_ns\t = (taac_exp[e] * taac_mant[m] + 9) / 10;\n\t\tcsd->taac_clks\t = UNSTUFF_BITS(resp, 104, 8) * 100;\n\n\t\tm = UNSTUFF_BITS(resp, 99, 4);\n\t\te = UNSTUFF_BITS(resp, 96, 3);\n\t\tcsd->max_dtr\t  = tran_exp[e] * tran_mant[m];\n\t\tcsd->cmdclass\t  = UNSTUFF_BITS(resp, 84, 12);\n\n\t\te = UNSTUFF_BITS(resp, 47, 3);\n\t\tm = UNSTUFF_BITS(resp, 62, 12);\n\t\tcsd->capacity\t  = (1 + m) << (e + 2);\n\n\t\tcsd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);\n\t\tcsd->read_partial = UNSTUFF_BITS(resp, 79, 1);\n\t\tcsd->write_misalign = UNSTUFF_BITS(resp, 78, 1);\n\t\tcsd->read_misalign = UNSTUFF_BITS(resp, 77, 1);\n\t\tcsd->dsr_imp = UNSTUFF_BITS(resp, 76, 1);\n\t\tcsd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);\n\t\tcsd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);\n\t\tcsd->write_partial = UNSTUFF_BITS(resp, 21, 1);\n\n\t\tif (UNSTUFF_BITS(resp, 46, 1)) {\n\t\t\tcsd->erase_size = 1;\n\t\t} else if (csd->write_blkbits >= 9) {\n\t\t\tcsd->erase_size = UNSTUFF_BITS(resp, 39, 7) + 1;\n\t\t\tcsd->erase_size <<= csd->write_blkbits - 9;\n\t\t}\n\n\t\tif (UNSTUFF_BITS(resp, 13, 1))\n\t\t\tmmc_card_set_readonly(card);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tmmc_card_set_blockaddr(card);\n\n\t\tcsd->taac_ns\t = 0;  \n\t\tcsd->taac_clks\t = 0;  \n\n\t\tm = UNSTUFF_BITS(resp, 99, 4);\n\t\te = UNSTUFF_BITS(resp, 96, 3);\n\t\tcsd->max_dtr\t  = tran_exp[e] * tran_mant[m];\n\t\tcsd->cmdclass\t  = UNSTUFF_BITS(resp, 84, 12);\n\t\tcsd->c_size\t  = UNSTUFF_BITS(resp, 48, 22);\n\n\t\t \n\t\tif (csd->c_size >= 0xFFFF)\n\t\t\tmmc_card_set_ext_capacity(card);\n\n\t\tm = UNSTUFF_BITS(resp, 48, 22);\n\t\tcsd->capacity     = (1 + m) << 10;\n\n\t\tcsd->read_blkbits = 9;\n\t\tcsd->read_partial = 0;\n\t\tcsd->write_misalign = 0;\n\t\tcsd->read_misalign = 0;\n\t\tcsd->r2w_factor = 4;  \n\t\tcsd->write_blkbits = 9;\n\t\tcsd->write_partial = 0;\n\t\tcsd->erase_size = 1;\n\n\t\tif (UNSTUFF_BITS(resp, 13, 1))\n\t\t\tmmc_card_set_readonly(card);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: unrecognised CSD structure version %d\\n\",\n\t\t\tmmc_hostname(card->host), csd_struct);\n\t\treturn -EINVAL;\n\t}\n\n\tcard->erase_size = csd->erase_size;\n\n\treturn 0;\n}\n\n \nstatic int mmc_decode_scr(struct mmc_card *card)\n{\n\tstruct sd_scr *scr = &card->scr;\n\tunsigned int scr_struct;\n\tu32 resp[4];\n\n\tresp[3] = card->raw_scr[1];\n\tresp[2] = card->raw_scr[0];\n\n\tscr_struct = UNSTUFF_BITS(resp, 60, 4);\n\tif (scr_struct != 0) {\n\t\tpr_err(\"%s: unrecognised SCR structure version %d\\n\",\n\t\t\tmmc_hostname(card->host), scr_struct);\n\t\treturn -EINVAL;\n\t}\n\n\tscr->sda_vsn = UNSTUFF_BITS(resp, 56, 4);\n\tscr->bus_widths = UNSTUFF_BITS(resp, 48, 4);\n\tif (scr->sda_vsn == SCR_SPEC_VER_2)\n\t\t \n\t\tscr->sda_spec3 = UNSTUFF_BITS(resp, 47, 1);\n\n\tif (scr->sda_spec3) {\n\t\tscr->sda_spec4 = UNSTUFF_BITS(resp, 42, 1);\n\t\tscr->sda_specx = UNSTUFF_BITS(resp, 38, 4);\n\t}\n\n\tif (UNSTUFF_BITS(resp, 55, 1))\n\t\tcard->erased_byte = 0xFF;\n\telse\n\t\tcard->erased_byte = 0x0;\n\n\tif (scr->sda_spec4)\n\t\tscr->cmds = UNSTUFF_BITS(resp, 32, 4);\n\telse if (scr->sda_spec3)\n\t\tscr->cmds = UNSTUFF_BITS(resp, 32, 2);\n\n\t \n\tif (!(scr->bus_widths & SD_SCR_BUS_WIDTH_1) ||\n\t    !(scr->bus_widths & SD_SCR_BUS_WIDTH_4)) {\n\t\tpr_err(\"%s: invalid bus width\\n\", mmc_hostname(card->host));\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mmc_read_ssr(struct mmc_card *card)\n{\n\tunsigned int au, es, et, eo;\n\t__be32 *raw_ssr;\n\tu32 resp[4] = {};\n\tu8 discard_support;\n\tint i;\n\n\tif (!(card->csd.cmdclass & CCC_APP_SPEC)) {\n\t\tpr_warn(\"%s: card lacks mandatory SD Status function\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\treturn 0;\n\t}\n\n\traw_ssr = kmalloc(sizeof(card->raw_ssr), GFP_KERNEL);\n\tif (!raw_ssr)\n\t\treturn -ENOMEM;\n\n\tif (mmc_app_sd_status(card, raw_ssr)) {\n\t\tpr_warn(\"%s: problem reading SD Status register\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\tkfree(raw_ssr);\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < 16; i++)\n\t\tcard->raw_ssr[i] = be32_to_cpu(raw_ssr[i]);\n\n\tkfree(raw_ssr);\n\n\t \n\tau = UNSTUFF_BITS(card->raw_ssr, 428 - 384, 4);\n\tif (au) {\n\t\tif (au <= 9 || card->scr.sda_spec3) {\n\t\t\tcard->ssr.au = sd_au_size[au];\n\t\t\tes = UNSTUFF_BITS(card->raw_ssr, 408 - 384, 16);\n\t\t\tet = UNSTUFF_BITS(card->raw_ssr, 402 - 384, 6);\n\t\t\tif (es && et) {\n\t\t\t\teo = UNSTUFF_BITS(card->raw_ssr, 400 - 384, 2);\n\t\t\t\tcard->ssr.erase_timeout = (et * 1000) / es;\n\t\t\t\tcard->ssr.erase_offset = eo * 1000;\n\t\t\t}\n\t\t} else {\n\t\t\tpr_warn(\"%s: SD Status: Invalid Allocation Unit size\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t}\n\t}\n\n\t \n\tresp[3] = card->raw_ssr[6];\n\tdiscard_support = UNSTUFF_BITS(resp, 313 - 288, 1);\n\tcard->erase_arg = (card->scr.sda_specx && discard_support) ?\n\t\t\t    SD_DISCARD_ARG : SD_ERASE_ARG;\n\n\treturn 0;\n}\n\n \nstatic int mmc_read_switch(struct mmc_card *card)\n{\n\tint err;\n\tu8 *status;\n\n\tif (card->scr.sda_vsn < SCR_SPEC_VER_1)\n\t\treturn 0;\n\n\tif (!(card->csd.cmdclass & CCC_SWITCH)) {\n\t\tpr_warn(\"%s: card lacks mandatory switch function, performance might suffer\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\treturn 0;\n\t}\n\n\tstatus = kmalloc(64, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\t \n\terr = mmc_sd_switch(card, 0, 0, 0, status);\n\tif (err) {\n\t\t \n\t\tif (err != -EINVAL && err != -ENOSYS && err != -EFAULT)\n\t\t\tgoto out;\n\n\t\tpr_warn(\"%s: problem reading Bus Speed modes\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\terr = 0;\n\n\t\tgoto out;\n\t}\n\n\tif (status[13] & SD_MODE_HIGH_SPEED)\n\t\tcard->sw_caps.hs_max_dtr = HIGH_SPEED_MAX_DTR;\n\n\tif (card->scr.sda_spec3) {\n\t\tcard->sw_caps.sd3_bus_mode = status[13];\n\t\t \n\t\tcard->sw_caps.sd3_drv_type = status[9];\n\t\tcard->sw_caps.sd3_curr_limit = status[7] | status[6] << 8;\n\t}\n\nout:\n\tkfree(status);\n\n\treturn err;\n}\n\n \nint mmc_sd_switch_hs(struct mmc_card *card)\n{\n\tint err;\n\tu8 *status;\n\n\tif (card->scr.sda_vsn < SCR_SPEC_VER_1)\n\t\treturn 0;\n\n\tif (!(card->csd.cmdclass & CCC_SWITCH))\n\t\treturn 0;\n\n\tif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\n\t\treturn 0;\n\n\tif (card->sw_caps.hs_max_dtr == 0)\n\t\treturn 0;\n\n\tstatus = kmalloc(64, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\terr = mmc_sd_switch(card, 1, 0, HIGH_SPEED_BUS_SPEED, status);\n\tif (err)\n\t\tgoto out;\n\n\tif ((status[16] & 0xF) != HIGH_SPEED_BUS_SPEED) {\n\t\tpr_warn(\"%s: Problem switching card into high-speed mode!\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\terr = 0;\n\t} else {\n\t\terr = 1;\n\t}\n\nout:\n\tkfree(status);\n\n\treturn err;\n}\n\nstatic int sd_select_driver_type(struct mmc_card *card, u8 *status)\n{\n\tint card_drv_type, drive_strength, drv_type;\n\tint err;\n\n\tcard->drive_strength = 0;\n\n\tcard_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;\n\n\tdrive_strength = mmc_select_drive_strength(card,\n\t\t\t\t\t\t   card->sw_caps.uhs_max_dtr,\n\t\t\t\t\t\t   card_drv_type, &drv_type);\n\n\tif (drive_strength) {\n\t\terr = mmc_sd_switch(card, 1, 2, drive_strength, status);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif ((status[15] & 0xF) != drive_strength) {\n\t\t\tpr_warn(\"%s: Problem setting drive strength!\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t\treturn 0;\n\t\t}\n\t\tcard->drive_strength = drive_strength;\n\t}\n\n\tif (drv_type)\n\t\tmmc_set_driver_type(card->host, drv_type);\n\n\treturn 0;\n}\n\nstatic void sd_update_bus_speed_mode(struct mmc_card *card)\n{\n\t \n\tif (!mmc_host_uhs(card->host)) {\n\t\tcard->sd_bus_speed = 0;\n\t\treturn;\n\t}\n\n\tif ((card->host->caps & MMC_CAP_UHS_SDR104) &&\n\t    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {\n\t\t\tcard->sd_bus_speed = UHS_SDR104_BUS_SPEED;\n\t} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&\n\t\t   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {\n\t\t\tcard->sd_bus_speed = UHS_DDR50_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &\n\t\t    SD_MODE_UHS_SDR50)) {\n\t\t\tcard->sd_bus_speed = UHS_SDR50_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&\n\t\t   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {\n\t\t\tcard->sd_bus_speed = UHS_SDR25_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |\n\t\t    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &\n\t\t    SD_MODE_UHS_SDR12)) {\n\t\t\tcard->sd_bus_speed = UHS_SDR12_BUS_SPEED;\n\t}\n}\n\nstatic int sd_set_bus_speed_mode(struct mmc_card *card, u8 *status)\n{\n\tint err;\n\tunsigned int timing = 0;\n\n\tswitch (card->sd_bus_speed) {\n\tcase UHS_SDR104_BUS_SPEED:\n\t\ttiming = MMC_TIMING_UHS_SDR104;\n\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;\n\t\tbreak;\n\tcase UHS_DDR50_BUS_SPEED:\n\t\ttiming = MMC_TIMING_UHS_DDR50;\n\t\tcard->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;\n\t\tbreak;\n\tcase UHS_SDR50_BUS_SPEED:\n\t\ttiming = MMC_TIMING_UHS_SDR50;\n\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;\n\t\tbreak;\n\tcase UHS_SDR25_BUS_SPEED:\n\t\ttiming = MMC_TIMING_UHS_SDR25;\n\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;\n\t\tbreak;\n\tcase UHS_SDR12_BUS_SPEED:\n\t\ttiming = MMC_TIMING_UHS_SDR12;\n\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\terr = mmc_sd_switch(card, 1, 0, card->sd_bus_speed, status);\n\tif (err)\n\t\treturn err;\n\n\tif ((status[16] & 0xF) != card->sd_bus_speed)\n\t\tpr_warn(\"%s: Problem setting bus speed mode!\\n\",\n\t\t\tmmc_hostname(card->host));\n\telse {\n\t\tmmc_set_timing(card->host, timing);\n\t\tmmc_set_clock(card->host, card->sw_caps.uhs_max_dtr);\n\t}\n\n\treturn 0;\n}\n\n \nstatic u32 sd_get_host_max_current(struct mmc_host *host)\n{\n\tu32 voltage, max_current;\n\n\tvoltage = 1 << host->ios.vdd;\n\tswitch (voltage) {\n\tcase MMC_VDD_165_195:\n\t\tmax_current = host->max_current_180;\n\t\tbreak;\n\tcase MMC_VDD_29_30:\n\tcase MMC_VDD_30_31:\n\t\tmax_current = host->max_current_300;\n\t\tbreak;\n\tcase MMC_VDD_32_33:\n\tcase MMC_VDD_33_34:\n\t\tmax_current = host->max_current_330;\n\t\tbreak;\n\tdefault:\n\t\tmax_current = 0;\n\t}\n\n\treturn max_current;\n}\n\nstatic int sd_set_current_limit(struct mmc_card *card, u8 *status)\n{\n\tint current_limit = SD_SET_CURRENT_NO_CHANGE;\n\tint err;\n\tu32 max_current;\n\n\t \n\tif ((card->sd_bus_speed != UHS_SDR50_BUS_SPEED) &&\n\t    (card->sd_bus_speed != UHS_SDR104_BUS_SPEED) &&\n\t    (card->sd_bus_speed != UHS_DDR50_BUS_SPEED))\n\t\treturn 0;\n\n\t \n\tmax_current = sd_get_host_max_current(card->host);\n\n\t \n\tif (max_current >= 800 &&\n\t    card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_800)\n\t\tcurrent_limit = SD_SET_CURRENT_LIMIT_800;\n\telse if (max_current >= 600 &&\n\t\t card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_600)\n\t\tcurrent_limit = SD_SET_CURRENT_LIMIT_600;\n\telse if (max_current >= 400 &&\n\t\t card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_400)\n\t\tcurrent_limit = SD_SET_CURRENT_LIMIT_400;\n\telse if (max_current >= 200 &&\n\t\t card->sw_caps.sd3_curr_limit & SD_MAX_CURRENT_200)\n\t\tcurrent_limit = SD_SET_CURRENT_LIMIT_200;\n\n\tif (current_limit != SD_SET_CURRENT_NO_CHANGE) {\n\t\terr = mmc_sd_switch(card, 1, 3, current_limit, status);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tif (((status[15] >> 4) & 0x0F) != current_limit)\n\t\t\tpr_warn(\"%s: Problem setting current limit!\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mmc_sd_init_uhs_card(struct mmc_card *card)\n{\n\tint err;\n\tu8 *status;\n\n\tif (!(card->csd.cmdclass & CCC_SWITCH))\n\t\treturn 0;\n\n\tstatus = kmalloc(64, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\t \n\terr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\n\tif (err)\n\t\tgoto out;\n\n\tmmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);\n\n\t \n\tsd_update_bus_speed_mode(card);\n\n\t \n\terr = sd_select_driver_type(card, status);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = sd_set_current_limit(card, status);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = sd_set_bus_speed_mode(card, status);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (!mmc_host_is_spi(card->host) &&\n\t\t(card->host->ios.timing == MMC_TIMING_UHS_SDR50 ||\n\t\t card->host->ios.timing == MMC_TIMING_UHS_DDR50 ||\n\t\t card->host->ios.timing == MMC_TIMING_UHS_SDR104)) {\n\t\terr = mmc_execute_tuning(card);\n\n\t\t \n\t\tif (err && card->host->ios.timing == MMC_TIMING_UHS_DDR50) {\n\t\t\tpr_warn(\"%s: ddr50 tuning failed\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t\terr = 0;\n\t\t}\n\t}\n\nout:\n\tkfree(status);\n\n\treturn err;\n}\n\nMMC_DEV_ATTR(cid, \"%08x%08x%08x%08x\\n\", card->raw_cid[0], card->raw_cid[1],\n\tcard->raw_cid[2], card->raw_cid[3]);\nMMC_DEV_ATTR(csd, \"%08x%08x%08x%08x\\n\", card->raw_csd[0], card->raw_csd[1],\n\tcard->raw_csd[2], card->raw_csd[3]);\nMMC_DEV_ATTR(scr, \"%08x%08x\\n\", card->raw_scr[0], card->raw_scr[1]);\nMMC_DEV_ATTR(ssr,\n\t\"%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x%08x\\n\",\n\t\tcard->raw_ssr[0], card->raw_ssr[1], card->raw_ssr[2],\n\t\tcard->raw_ssr[3], card->raw_ssr[4], card->raw_ssr[5],\n\t\tcard->raw_ssr[6], card->raw_ssr[7], card->raw_ssr[8],\n\t\tcard->raw_ssr[9], card->raw_ssr[10], card->raw_ssr[11],\n\t\tcard->raw_ssr[12], card->raw_ssr[13], card->raw_ssr[14],\n\t\tcard->raw_ssr[15]);\nMMC_DEV_ATTR(date, \"%02d/%04d\\n\", card->cid.month, card->cid.year);\nMMC_DEV_ATTR(erase_size, \"%u\\n\", card->erase_size << 9);\nMMC_DEV_ATTR(preferred_erase_size, \"%u\\n\", card->pref_erase << 9);\nMMC_DEV_ATTR(fwrev, \"0x%x\\n\", card->cid.fwrev);\nMMC_DEV_ATTR(hwrev, \"0x%x\\n\", card->cid.hwrev);\nMMC_DEV_ATTR(manfid, \"0x%06x\\n\", card->cid.manfid);\nMMC_DEV_ATTR(name, \"%s\\n\", card->cid.prod_name);\nMMC_DEV_ATTR(oemid, \"0x%04x\\n\", card->cid.oemid);\nMMC_DEV_ATTR(serial, \"0x%08x\\n\", card->cid.serial);\nMMC_DEV_ATTR(ocr, \"0x%08x\\n\", card->ocr);\nMMC_DEV_ATTR(rca, \"0x%04x\\n\", card->rca);\n\n\nstatic ssize_t mmc_dsr_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\n\tif (card->csd.dsr_imp && host->dsr_req)\n\t\treturn sysfs_emit(buf, \"0x%x\\n\", host->dsr);\n\t \n\treturn sysfs_emit(buf, \"0x%x\\n\", 0x404);\n}\n\nstatic DEVICE_ATTR(dsr, S_IRUGO, mmc_dsr_show, NULL);\n\nMMC_DEV_ATTR(vendor, \"0x%04x\\n\", card->cis.vendor);\nMMC_DEV_ATTR(device, \"0x%04x\\n\", card->cis.device);\nMMC_DEV_ATTR(revision, \"%u.%u\\n\", card->major_rev, card->minor_rev);\n\n#define sdio_info_attr(num)\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t info##num##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (num > card->num_info)\t\t\t\t\t\t\t\t\\\n\t\treturn -ENODATA;\t\t\t\t\t\t\t\t\\\n\tif (!card->info[num - 1][0])\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%s\\n\", card->info[num - 1]);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(info##num)\n\nsdio_info_attr(1);\nsdio_info_attr(2);\nsdio_info_attr(3);\nsdio_info_attr(4);\n\nstatic struct attribute *sd_std_attrs[] = {\n\t&dev_attr_vendor.attr,\n\t&dev_attr_device.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_info1.attr,\n\t&dev_attr_info2.attr,\n\t&dev_attr_info3.attr,\n\t&dev_attr_info4.attr,\n\t&dev_attr_cid.attr,\n\t&dev_attr_csd.attr,\n\t&dev_attr_scr.attr,\n\t&dev_attr_ssr.attr,\n\t&dev_attr_date.attr,\n\t&dev_attr_erase_size.attr,\n\t&dev_attr_preferred_erase_size.attr,\n\t&dev_attr_fwrev.attr,\n\t&dev_attr_hwrev.attr,\n\t&dev_attr_manfid.attr,\n\t&dev_attr_name.attr,\n\t&dev_attr_oemid.attr,\n\t&dev_attr_serial.attr,\n\t&dev_attr_ocr.attr,\n\t&dev_attr_rca.attr,\n\t&dev_attr_dsr.attr,\n\tNULL,\n};\n\nstatic umode_t sd_std_is_visible(struct kobject *kobj, struct attribute *attr,\n\t\t\t\t int index)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\t \n\tif ((attr == &dev_attr_vendor.attr ||\n\t     attr == &dev_attr_device.attr ||\n\t     attr == &dev_attr_revision.attr ||\n\t     attr == &dev_attr_info1.attr ||\n\t     attr == &dev_attr_info2.attr ||\n\t     attr == &dev_attr_info3.attr ||\n\t     attr == &dev_attr_info4.attr\n\t    ) &&!mmc_card_sd_combo(card))\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group sd_std_group = {\n\t.attrs = sd_std_attrs,\n\t.is_visible = sd_std_is_visible,\n};\n__ATTRIBUTE_GROUPS(sd_std);\n\nstruct device_type sd_type = {\n\t.groups = sd_std_groups,\n};\n\n \nint mmc_sd_get_cid(struct mmc_host *host, u32 ocr, u32 *cid, u32 *rocr)\n{\n\tint err;\n\tu32 max_current;\n\tint retries = 10;\n\tu32 pocr = ocr;\n\ntry_again:\n\tif (!retries) {\n\t\tocr &= ~SD_OCR_S18R;\n\t\tpr_warn(\"%s: Skipping voltage switch\\n\", mmc_hostname(host));\n\t}\n\n\t \n\tmmc_go_idle(host);\n\n\t \n\terr = mmc_send_if_cond(host, ocr);\n\tif (!err)\n\t\tocr |= SD_OCR_CCS;\n\n\t \n\tif (retries && mmc_host_uhs(host))\n\t\tocr |= SD_OCR_S18R;\n\n\t \n\tmax_current = sd_get_host_max_current(host);\n\tif (max_current > 150)\n\t\tocr |= SD_OCR_XPC;\n\n\terr = mmc_send_app_op_cond(host, ocr, rocr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!mmc_host_is_spi(host) && (ocr & SD_OCR_S18R) &&\n\t    rocr && (*rocr & SD_ROCR_S18A)) {\n\t\terr = mmc_set_uhs_voltage(host, pocr);\n\t\tif (err == -EAGAIN) {\n\t\t\tretries--;\n\t\t\tgoto try_again;\n\t\t} else if (err) {\n\t\t\tretries = 0;\n\t\t\tgoto try_again;\n\t\t}\n\t}\n\n\terr = mmc_send_cid(host, cid);\n\treturn err;\n}\n\nint mmc_sd_get_csd(struct mmc_card *card)\n{\n\tint err;\n\n\t \n\terr = mmc_send_csd(card, card->raw_csd);\n\tif (err)\n\t\treturn err;\n\n\terr = mmc_decode_csd(card);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int mmc_sd_get_ro(struct mmc_host *host)\n{\n\tint ro;\n\n\t \n\tif (host->caps2 & MMC_CAP2_NO_WRITE_PROTECT)\n\t\treturn 0;\n\n\tif (!host->ops->get_ro)\n\t\treturn -1;\n\n\tro = host->ops->get_ro(host);\n\n\treturn ro;\n}\n\nint mmc_sd_setup_card(struct mmc_host *host, struct mmc_card *card,\n\tbool reinit)\n{\n\tint err;\n\n\tif (!reinit) {\n\t\t \n\t\terr = mmc_app_send_scr(card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = mmc_decode_scr(card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = mmc_read_ssr(card);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tmmc_init_erase(card);\n\t}\n\n\t \n\terr = mmc_read_switch(card);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (mmc_host_is_spi(host)) {\n\t\terr = mmc_spi_set_crc(host, use_spi_crc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tif (!reinit) {\n\t\tint ro = mmc_sd_get_ro(host);\n\n\t\tif (ro < 0) {\n\t\t\tpr_warn(\"%s: host does not support reading read-only switch, assuming write-enable\\n\",\n\t\t\t\tmmc_hostname(host));\n\t\t} else if (ro > 0) {\n\t\t\tmmc_card_set_readonly(card);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nunsigned mmc_sd_get_max_clock(struct mmc_card *card)\n{\n\tunsigned max_dtr = (unsigned int)-1;\n\n\tif (mmc_card_hs(card)) {\n\t\tif (max_dtr > card->sw_caps.hs_max_dtr)\n\t\t\tmax_dtr = card->sw_caps.hs_max_dtr;\n\t} else if (max_dtr > card->csd.max_dtr) {\n\t\tmax_dtr = card->csd.max_dtr;\n\t}\n\n\treturn max_dtr;\n}\n\nstatic bool mmc_sd_card_using_v18(struct mmc_card *card)\n{\n\t \n\treturn card->sw_caps.sd3_bus_mode &\n\t       (SD_MODE_UHS_SDR50 | SD_MODE_UHS_SDR104 | SD_MODE_UHS_DDR50);\n}\n\nstatic int sd_write_ext_reg(struct mmc_card *card, u8 fno, u8 page, u16 offset,\n\t\t\t    u8 reg_data)\n{\n\tstruct mmc_host *host = card->host;\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\tu8 *reg_buf;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\t \n\tcmd.arg = fno << 27 | page << 18 | offset << 9;\n\n\t \n\treg_buf[0] = reg_data;\n\n\tdata.flags = MMC_DATA_WRITE;\n\tdata.blksz = 512;\n\tdata.blocks = 1;\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\tsg_init_one(&sg, reg_buf, 512);\n\n\tcmd.opcode = SD_WRITE_EXTR_SINGLE;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tmmc_set_data_timeout(&data, card);\n\tmmc_wait_for_req(host, &mrq);\n\n\tkfree(reg_buf);\n\n\t \n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn 0;\n}\n\nstatic int sd_read_ext_reg(struct mmc_card *card, u8 fno, u8 page,\n\t\t\t   u16 offset, u16 len, u8 *reg_buf)\n{\n\tu32 cmd_args;\n\n\t \n\tcmd_args = fno << 27 | page << 18 | offset << 9 | (len -1);\n\n\treturn mmc_send_adtc_data(card, card->host, SD_READ_EXTR_SINGLE,\n\t\t\t\t  cmd_args, reg_buf, 512);\n}\n\nstatic int sd_parse_ext_reg_power(struct mmc_card *card, u8 fno, u8 page,\n\t\t\t\t  u16 offset)\n{\n\tint err;\n\tu8 *reg_buf;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = sd_read_ext_reg(card, fno, page, offset, 512, reg_buf);\n\tif (err) {\n\t\tpr_warn(\"%s: error %d reading PM func of ext reg\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\tgoto out;\n\t}\n\n\t \n\tcard->ext_power.rev = reg_buf[0] & 0xf;\n\n\t \n\tif (reg_buf[1] & BIT(4))\n\t\tcard->ext_power.feature_support |= SD_EXT_POWER_OFF_NOTIFY;\n\n\t \n\tif (reg_buf[1] & BIT(5))\n\t\tcard->ext_power.feature_support |= SD_EXT_POWER_SUSTENANCE;\n\n\t \n\tif (reg_buf[1] & BIT(6))\n\t\tcard->ext_power.feature_support |= SD_EXT_POWER_DOWN_MODE;\n\n\tcard->ext_power.fno = fno;\n\tcard->ext_power.page = page;\n\tcard->ext_power.offset = offset;\n\nout:\n\tkfree(reg_buf);\n\treturn err;\n}\n\nstatic int sd_parse_ext_reg_perf(struct mmc_card *card, u8 fno, u8 page,\n\t\t\t\t u16 offset)\n{\n\tint err;\n\tu8 *reg_buf;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\terr = sd_read_ext_reg(card, fno, page, offset, 512, reg_buf);\n\tif (err) {\n\t\tpr_warn(\"%s: error %d reading PERF func of ext reg\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\tgoto out;\n\t}\n\n\t \n\tcard->ext_perf.rev = reg_buf[0];\n\n\t \n\tif (reg_buf[1] & BIT(0))\n\t\tcard->ext_perf.feature_support |= SD_EXT_PERF_FX_EVENT;\n\n\t \n\tif (reg_buf[2] & BIT(0))\n\t\tcard->ext_perf.feature_support |= SD_EXT_PERF_CARD_MAINT;\n\n\t \n\tif (reg_buf[2] & BIT(1))\n\t\tcard->ext_perf.feature_support |= SD_EXT_PERF_HOST_MAINT;\n\n\t \n\tif ((reg_buf[4] & BIT(0)) && !mmc_card_broken_sd_cache(card))\n\t\tcard->ext_perf.feature_support |= SD_EXT_PERF_CACHE;\n\n\t \n\tif (reg_buf[6] & 0x1f)\n\t\tcard->ext_perf.feature_support |= SD_EXT_PERF_CMD_QUEUE;\n\n\tcard->ext_perf.fno = fno;\n\tcard->ext_perf.page = page;\n\tcard->ext_perf.offset = offset;\n\nout:\n\tkfree(reg_buf);\n\treturn err;\n}\n\nstatic int sd_parse_ext_reg(struct mmc_card *card, u8 *gen_info_buf,\n\t\t\t    u16 *next_ext_addr)\n{\n\tu8 num_regs, fno, page;\n\tu16 sfc, offset, ext = *next_ext_addr;\n\tu32 reg_addr;\n\n\t \n\tif (ext + 48 > 512)\n\t\treturn -EFAULT;\n\n\t \n\tmemcpy(&sfc, &gen_info_buf[ext], 2);\n\n\t \n\tmemcpy(next_ext_addr, &gen_info_buf[ext + 40], 2);\n\n\t \n\tnum_regs = gen_info_buf[ext + 42];\n\n\t \n\tif (num_regs != 1)\n\t\treturn 0;\n\n\t \n\tmemcpy(&reg_addr, &gen_info_buf[ext + 44], 4);\n\n\t \n\toffset = reg_addr & 0x1ff;\n\n\t \n\tpage = reg_addr >> 9 & 0xff ;\n\n\t \n\tfno = reg_addr >> 18 & 0xf;\n\n\t \n\tif (sfc == 0x1)\n\t\treturn sd_parse_ext_reg_power(card, fno, page, offset);\n\n\t \n\tif (sfc == 0x2)\n\t\treturn sd_parse_ext_reg_perf(card, fno, page, offset);\n\n\treturn 0;\n}\n\nstatic int sd_read_ext_regs(struct mmc_card *card)\n{\n\tint err, i;\n\tu8 num_ext, *gen_info_buf;\n\tu16 rev, len, next_ext_addr;\n\n\tif (mmc_host_is_spi(card->host))\n\t\treturn 0;\n\n\tif (!(card->scr.cmds & SD_SCR_CMD48_SUPPORT))\n\t\treturn 0;\n\n\tgen_info_buf = kzalloc(512, GFP_KERNEL);\n\tif (!gen_info_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = sd_read_ext_reg(card, 0, 0, 0, 512, gen_info_buf);\n\tif (err) {\n\t\tpr_err(\"%s: error %d reading general info of SD ext reg\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\tgoto out;\n\t}\n\n\t \n\tmemcpy(&rev, &gen_info_buf[0], 2);\n\n\t \n\tmemcpy(&len, &gen_info_buf[2], 2);\n\n\t \n\tnum_ext = gen_info_buf[4];\n\n\t \n\tif (rev != 0 || len > 512) {\n\t\tpr_warn(\"%s: non-supported SD ext reg layout\\n\",\n\t\t\tmmc_hostname(card->host));\n\t\tgoto out;\n\t}\n\n\t \n\tnext_ext_addr = 16;\n\tfor (i = 0; i < num_ext; i++) {\n\t\terr = sd_parse_ext_reg(card, gen_info_buf, &next_ext_addr);\n\t\tif (err) {\n\t\t\tpr_err(\"%s: error %d parsing SD ext reg\\n\",\n\t\t\t\tmmc_hostname(card->host), err);\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tkfree(gen_info_buf);\n\treturn err;\n}\n\nstatic bool sd_cache_enabled(struct mmc_host *host)\n{\n\treturn host->card->ext_perf.feature_enabled & SD_EXT_PERF_CACHE;\n}\n\nstatic int sd_flush_cache(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\tu8 *reg_buf, fno, page;\n\tu16 offset;\n\tint err;\n\n\tif (!sd_cache_enabled(host))\n\t\treturn 0;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\t \n\tfno = card->ext_perf.fno;\n\tpage = card->ext_perf.page;\n\toffset = card->ext_perf.offset + 261;\n\n\terr = sd_write_ext_reg(card, fno, page, offset, BIT(0));\n\tif (err) {\n\t\tpr_warn(\"%s: error %d writing Cache Flush bit\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tgoto out;\n\t}\n\n\terr = mmc_poll_for_busy(card, SD_WRITE_EXTR_SINGLE_TIMEOUT_MS, false,\n\t\t\t\tMMC_BUSY_EXTR_SINGLE);\n\tif (err)\n\t\tgoto out;\n\n\t \n\terr = sd_read_ext_reg(card, fno, page, offset, 1, reg_buf);\n\tif (err) {\n\t\tpr_warn(\"%s: error %d reading Cache Flush bit\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tgoto out;\n\t}\n\n\tif (reg_buf[0] & BIT(0))\n\t\terr = -ETIMEDOUT;\nout:\n\tkfree(reg_buf);\n\treturn err;\n}\n\nstatic int sd_enable_cache(struct mmc_card *card)\n{\n\tu8 *reg_buf;\n\tint err;\n\n\tcard->ext_perf.feature_enabled &= ~SD_EXT_PERF_CACHE;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = sd_write_ext_reg(card, card->ext_perf.fno, card->ext_perf.page,\n\t\t\t       card->ext_perf.offset + 260, BIT(0));\n\tif (err) {\n\t\tpr_warn(\"%s: error %d writing Cache Enable bit\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\tgoto out;\n\t}\n\n\terr = mmc_poll_for_busy(card, SD_WRITE_EXTR_SINGLE_TIMEOUT_MS, false,\n\t\t\t\tMMC_BUSY_EXTR_SINGLE);\n\tif (!err)\n\t\tcard->ext_perf.feature_enabled |= SD_EXT_PERF_CACHE;\n\nout:\n\tkfree(reg_buf);\n\treturn err;\n}\n\n \nstatic int mmc_sd_init_card(struct mmc_host *host, u32 ocr,\n\tstruct mmc_card *oldcard)\n{\n\tstruct mmc_card *card;\n\tint err;\n\tu32 cid[4];\n\tu32 rocr = 0;\n\tbool v18_fixup_failed = false;\n\n\tWARN_ON(!host->claimed);\nretry:\n\terr = mmc_sd_get_cid(host, ocr, cid, &rocr);\n\tif (err)\n\t\treturn err;\n\n\tif (oldcard) {\n\t\tif (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {\n\t\t\tpr_debug(\"%s: Perhaps the card was replaced\\n\",\n\t\t\t\tmmc_hostname(host));\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tcard = oldcard;\n\t} else {\n\t\t \n\t\tcard = mmc_alloc_card(host, &sd_type);\n\t\tif (IS_ERR(card))\n\t\t\treturn PTR_ERR(card);\n\n\t\tcard->ocr = ocr;\n\t\tcard->type = MMC_TYPE_SD;\n\t\tmemcpy(card->raw_cid, cid, sizeof(card->raw_cid));\n\t}\n\n\t \n\tif (host->ops->init_card)\n\t\thost->ops->init_card(host, card);\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_send_relative_addr(host, &card->rca);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\tif (!oldcard) {\n\t\terr = mmc_sd_get_csd(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t\tmmc_decode_cid(card);\n\t}\n\n\t \n\tif (card->csd.dsr_imp && host->dsr_req)\n\t\tmmc_set_dsr(host);\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_select_card(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\terr = mmc_sd_setup_card(host, card, oldcard != NULL);\n\tif (err)\n\t\tgoto free_card;\n\n\t \n\tif (!v18_fixup_failed && !mmc_host_is_spi(host) && mmc_host_uhs(host) &&\n\t    mmc_sd_card_using_v18(card) &&\n\t    host->ios.signal_voltage != MMC_SIGNAL_VOLTAGE_180) {\n\t\tif (mmc_host_set_uhs_voltage(host) ||\n\t\t    mmc_sd_init_uhs_card(card)) {\n\t\t\tv18_fixup_failed = true;\n\t\t\tmmc_power_cycle(host, ocr);\n\t\t\tif (!oldcard)\n\t\t\t\tmmc_remove_card(card);\n\t\t\tgoto retry;\n\t\t}\n\t\tgoto cont;\n\t}\n\n\t \n\tif (rocr & SD_ROCR_S18A && mmc_host_uhs(host)) {\n\t\terr = mmc_sd_init_uhs_card(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t} else {\n\t\t \n\t\terr = mmc_sd_switch_hs(card);\n\t\tif (err > 0)\n\t\t\tmmc_set_timing(card->host, MMC_TIMING_SD_HS);\n\t\telse if (err)\n\t\t\tgoto free_card;\n\n\t\t \n\t\tmmc_set_clock(host, mmc_sd_get_max_clock(card));\n\n\t\tif (host->ios.timing == MMC_TIMING_SD_HS &&\n\t\t\thost->ops->prepare_sd_hs_tuning) {\n\t\t\terr = host->ops->prepare_sd_hs_tuning(host, card);\n\t\t\tif (err)\n\t\t\t\tgoto free_card;\n\t\t}\n\n\t\t \n\t\tif ((host->caps & MMC_CAP_4_BIT_DATA) &&\n\t\t\t(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4)) {\n\t\t\terr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\n\t\t\tif (err)\n\t\t\t\tgoto free_card;\n\n\t\t\tmmc_set_bus_width(host, MMC_BUS_WIDTH_4);\n\t\t}\n\n\t\tif (host->ios.timing == MMC_TIMING_SD_HS &&\n\t\t\thost->ops->execute_sd_hs_tuning) {\n\t\t\terr = host->ops->execute_sd_hs_tuning(host, card);\n\t\t\tif (err)\n\t\t\t\tgoto free_card;\n\t\t}\n\t}\ncont:\n\tif (!oldcard) {\n\t\t \n\t\terr = sd_read_ext_regs(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\t \n\tif (card->ext_perf.feature_support & SD_EXT_PERF_CACHE) {\n\t\terr = sd_enable_cache(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\tif (host->cqe_ops && !host->cqe_enabled) {\n\t\terr = host->cqe_ops->cqe_enable(host, card);\n\t\tif (!err) {\n\t\t\thost->cqe_enabled = true;\n\t\t\thost->hsq_enabled = true;\n\t\t\tpr_info(\"%s: Host Software Queue enabled\\n\",\n\t\t\t\tmmc_hostname(host));\n\t\t}\n\t}\n\n\tif (host->caps2 & MMC_CAP2_AVOID_3_3V &&\n\t    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\tpr_err(\"%s: Host failed to negotiate down from 3.3V\\n\",\n\t\t\tmmc_hostname(host));\n\t\terr = -EINVAL;\n\t\tgoto free_card;\n\t}\n\n\thost->card = card;\n\treturn 0;\n\nfree_card:\n\tif (!oldcard)\n\t\tmmc_remove_card(card);\n\n\treturn err;\n}\n\n \nstatic void mmc_sd_remove(struct mmc_host *host)\n{\n\tmmc_remove_card(host->card);\n\thost->card = NULL;\n}\n\n \nstatic int mmc_sd_alive(struct mmc_host *host)\n{\n\treturn mmc_send_status(host->card, NULL);\n}\n\n \nstatic void mmc_sd_detect(struct mmc_host *host)\n{\n\tint err;\n\n\tmmc_get_card(host->card, NULL);\n\n\t \n\terr = _mmc_detect_card_removed(host);\n\n\tmmc_put_card(host->card, NULL);\n\n\tif (err) {\n\t\tmmc_sd_remove(host);\n\n\t\tmmc_claim_host(host);\n\t\tmmc_detach_bus(host);\n\t\tmmc_power_off(host);\n\t\tmmc_release_host(host);\n\t}\n}\n\nstatic int sd_can_poweroff_notify(struct mmc_card *card)\n{\n\treturn card->ext_power.feature_support & SD_EXT_POWER_OFF_NOTIFY;\n}\n\nstatic int sd_busy_poweroff_notify_cb(void *cb_data, bool *busy)\n{\n\tstruct sd_busy_data *data = cb_data;\n\tstruct mmc_card *card = data->card;\n\tint err;\n\n\t \n\terr = sd_read_ext_reg(card, card->ext_power.fno, card->ext_power.page,\n\t\t\t      card->ext_power.offset + 1, 1, data->reg_buf);\n\tif (err) {\n\t\tpr_warn(\"%s: error %d reading status reg of PM func\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\treturn err;\n\t}\n\n\t*busy = !(data->reg_buf[0] & BIT(0));\n\treturn 0;\n}\n\nstatic int sd_poweroff_notify(struct mmc_card *card)\n{\n\tstruct sd_busy_data cb_data;\n\tu8 *reg_buf;\n\tint err;\n\n\treg_buf = kzalloc(512, GFP_KERNEL);\n\tif (!reg_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = sd_write_ext_reg(card, card->ext_power.fno, card->ext_power.page,\n\t\t\t       card->ext_power.offset + 2, BIT(0));\n\tif (err) {\n\t\tpr_warn(\"%s: error %d writing Power Off Notify bit\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\t\tgoto out;\n\t}\n\n\t \n\terr = mmc_poll_for_busy(card, SD_WRITE_EXTR_SINGLE_TIMEOUT_MS, false,\n\t\t\t\tMMC_BUSY_EXTR_SINGLE);\n\tif (err)\n\t\tgoto out;\n\n\tcb_data.card = card;\n\tcb_data.reg_buf = reg_buf;\n\terr = __mmc_poll_for_busy(card->host, 0, SD_POWEROFF_NOTIFY_TIMEOUT_MS,\n\t\t\t\t  &sd_busy_poweroff_notify_cb, &cb_data);\n\nout:\n\tkfree(reg_buf);\n\treturn err;\n}\n\nstatic int _mmc_sd_suspend(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\tint err = 0;\n\n\tmmc_claim_host(host);\n\n\tif (mmc_card_suspended(card))\n\t\tgoto out;\n\n\tif (sd_can_poweroff_notify(card))\n\t\terr = sd_poweroff_notify(card);\n\telse if (!mmc_host_is_spi(host))\n\t\terr = mmc_deselect_cards(host);\n\n\tif (!err) {\n\t\tmmc_power_off(host);\n\t\tmmc_card_set_suspended(card);\n\t}\n\nout:\n\tmmc_release_host(host);\n\treturn err;\n}\n\n \nstatic int mmc_sd_suspend(struct mmc_host *host)\n{\n\tint err;\n\n\terr = _mmc_sd_suspend(host);\n\tif (!err) {\n\t\tpm_runtime_disable(&host->card->dev);\n\t\tpm_runtime_set_suspended(&host->card->dev);\n\t}\n\n\treturn err;\n}\n\n \nstatic int _mmc_sd_resume(struct mmc_host *host)\n{\n\tint err = 0;\n\n\tmmc_claim_host(host);\n\n\tif (!mmc_card_suspended(host->card))\n\t\tgoto out;\n\n\tmmc_power_up(host, host->card->ocr);\n\terr = mmc_sd_init_card(host, host->card->ocr, host->card);\n\tmmc_card_clr_suspended(host->card);\n\nout:\n\tmmc_release_host(host);\n\treturn err;\n}\n\n \nstatic int mmc_sd_resume(struct mmc_host *host)\n{\n\tpm_runtime_enable(&host->card->dev);\n\treturn 0;\n}\n\n \nstatic int mmc_sd_runtime_suspend(struct mmc_host *host)\n{\n\tint err;\n\n\tif (!(host->caps & MMC_CAP_AGGRESSIVE_PM))\n\t\treturn 0;\n\n\terr = _mmc_sd_suspend(host);\n\tif (err)\n\t\tpr_err(\"%s: error %d doing aggressive suspend\\n\",\n\t\t\tmmc_hostname(host), err);\n\n\treturn err;\n}\n\n \nstatic int mmc_sd_runtime_resume(struct mmc_host *host)\n{\n\tint err;\n\n\terr = _mmc_sd_resume(host);\n\tif (err && err != -ENOMEDIUM)\n\t\tpr_err(\"%s: error %d doing runtime resume\\n\",\n\t\t\tmmc_hostname(host), err);\n\n\treturn 0;\n}\n\nstatic int mmc_sd_hw_reset(struct mmc_host *host)\n{\n\tmmc_power_cycle(host, host->card->ocr);\n\treturn mmc_sd_init_card(host, host->card->ocr, host->card);\n}\n\nstatic const struct mmc_bus_ops mmc_sd_ops = {\n\t.remove = mmc_sd_remove,\n\t.detect = mmc_sd_detect,\n\t.runtime_suspend = mmc_sd_runtime_suspend,\n\t.runtime_resume = mmc_sd_runtime_resume,\n\t.suspend = mmc_sd_suspend,\n\t.resume = mmc_sd_resume,\n\t.alive = mmc_sd_alive,\n\t.shutdown = mmc_sd_suspend,\n\t.hw_reset = mmc_sd_hw_reset,\n\t.cache_enabled = sd_cache_enabled,\n\t.flush_cache = sd_flush_cache,\n};\n\n \nint mmc_attach_sd(struct mmc_host *host)\n{\n\tint err;\n\tu32 ocr, rocr;\n\n\tWARN_ON(!host->claimed);\n\n\terr = mmc_send_app_op_cond(host, 0, &ocr);\n\tif (err)\n\t\treturn err;\n\n\tmmc_attach_bus(host, &mmc_sd_ops);\n\tif (host->ocr_avail_sd)\n\t\thost->ocr_avail = host->ocr_avail_sd;\n\n\t \n\tif (mmc_host_is_spi(host)) {\n\t\tmmc_go_idle(host);\n\n\t\terr = mmc_spi_read_ocr(host, 0, &ocr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t \n\tocr &= ~0x7FFF;\n\n\trocr = mmc_select_voltage(host, ocr);\n\n\t \n\tif (!rocr) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\terr = mmc_sd_init_card(host, rocr, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tmmc_release_host(host);\n\terr = mmc_add_card(host->card);\n\tif (err)\n\t\tgoto remove_card;\n\n\tmmc_claim_host(host);\n\treturn 0;\n\nremove_card:\n\tmmc_remove_card(host->card);\n\thost->card = NULL;\n\tmmc_claim_host(host);\nerr:\n\tmmc_detach_bus(host);\n\n\tpr_err(\"%s: error %d whilst initialising SD card\\n\",\n\t\tmmc_hostname(host), err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}