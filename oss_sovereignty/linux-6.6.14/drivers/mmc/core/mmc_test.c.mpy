{
  "module_name": "mmc_test.c",
  "hash_id": "ac8b7b7ba67139b7bbda452e29bb9e4a7a350c630c48a6a4ed5836662e0cbeed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/mmc_test.c",
  "human_readable_source": "\n \n\n#include <linux/mmc/core.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/slab.h>\n\n#include <linux/scatterlist.h>\n#include <linux/list.h>\n\n#include <linux/debugfs.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"bus.h\"\n#include \"mmc_ops.h\"\n\n#define RESULT_OK\t\t0\n#define RESULT_FAIL\t\t1\n#define RESULT_UNSUP_HOST\t2\n#define RESULT_UNSUP_CARD\t3\n\n#define BUFFER_ORDER\t\t2\n#define BUFFER_SIZE\t\t(PAGE_SIZE << BUFFER_ORDER)\n\n#define TEST_ALIGN_END\t\t8\n\n \n#define TEST_AREA_MAX_SIZE (128 * 1024 * 1024)\n\n \nstruct mmc_test_pages {\n\tstruct page *page;\n\tunsigned int order;\n};\n\n \nstruct mmc_test_mem {\n\tstruct mmc_test_pages *arr;\n\tunsigned int cnt;\n};\n\n \nstruct mmc_test_area {\n\tunsigned long max_sz;\n\tunsigned int dev_addr;\n\tunsigned int max_tfr;\n\tunsigned int max_segs;\n\tunsigned int max_seg_sz;\n\tunsigned int blocks;\n\tunsigned int sg_len;\n\tstruct mmc_test_mem *mem;\n\tstruct scatterlist *sg;\n\tstruct scatterlist *sg_areq;\n};\n\n \nstruct mmc_test_transfer_result {\n\tstruct list_head link;\n\tunsigned int count;\n\tunsigned int sectors;\n\tstruct timespec64 ts;\n\tunsigned int rate;\n\tunsigned int iops;\n};\n\n \nstruct mmc_test_general_result {\n\tstruct list_head link;\n\tstruct mmc_card *card;\n\tint testcase;\n\tint result;\n\tstruct list_head tr_lst;\n};\n\n \nstruct mmc_test_dbgfs_file {\n\tstruct list_head link;\n\tstruct mmc_card *card;\n\tstruct dentry *file;\n};\n\n \nstruct mmc_test_card {\n\tstruct mmc_card\t*card;\n\n\tu8\t\tscratch[BUFFER_SIZE];\n\tu8\t\t*buffer;\n#ifdef CONFIG_HIGHMEM\n\tstruct page\t*highmem;\n#endif\n\tstruct mmc_test_area\t\tarea;\n\tstruct mmc_test_general_result\t*gr;\n};\n\nenum mmc_test_prep_media {\n\tMMC_TEST_PREP_NONE = 0,\n\tMMC_TEST_PREP_WRITE_FULL = 1 << 0,\n\tMMC_TEST_PREP_ERASE = 1 << 1,\n};\n\nstruct mmc_test_multiple_rw {\n\tunsigned int *sg_len;\n\tunsigned int *bs;\n\tunsigned int len;\n\tunsigned int size;\n\tbool do_write;\n\tbool do_nonblock_req;\n\tenum mmc_test_prep_media prepare;\n};\n\n \n \n \n\n \nstatic int mmc_test_set_blksize(struct mmc_test_card *test, unsigned size)\n{\n\treturn mmc_set_blocklen(test->card, size);\n}\n\nstatic bool mmc_test_card_cmd23(struct mmc_card *card)\n{\n\treturn mmc_card_mmc(card) ||\n\t       (mmc_card_sd(card) && card->scr.cmds & SD_SCR_CMD23_SUPPORT);\n}\n\nstatic void mmc_test_prepare_sbc(struct mmc_test_card *test,\n\t\t\t\t struct mmc_request *mrq, unsigned int blocks)\n{\n\tstruct mmc_card *card = test->card;\n\n\tif (!mrq->sbc || !mmc_host_cmd23(card->host) ||\n\t    !mmc_test_card_cmd23(card) || !mmc_op_multi(mrq->cmd->opcode) ||\n\t    (card->quirks & MMC_QUIRK_BLK_NO_CMD23)) {\n\t\tmrq->sbc = NULL;\n\t\treturn;\n\t}\n\n\tmrq->sbc->opcode = MMC_SET_BLOCK_COUNT;\n\tmrq->sbc->arg = blocks;\n\tmrq->sbc->flags = MMC_RSP_R1 | MMC_CMD_AC;\n}\n\n \nstatic void mmc_test_prepare_mrq(struct mmc_test_card *test,\n\tstruct mmc_request *mrq, struct scatterlist *sg, unsigned sg_len,\n\tunsigned dev_addr, unsigned blocks, unsigned blksz, int write)\n{\n\tif (WARN_ON(!mrq || !mrq->cmd || !mrq->data || !mrq->stop))\n\t\treturn;\n\n\tif (blocks > 1) {\n\t\tmrq->cmd->opcode = write ?\n\t\t\tMMC_WRITE_MULTIPLE_BLOCK : MMC_READ_MULTIPLE_BLOCK;\n\t} else {\n\t\tmrq->cmd->opcode = write ?\n\t\t\tMMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;\n\t}\n\n\tmrq->cmd->arg = dev_addr;\n\tif (!mmc_card_blockaddr(test->card))\n\t\tmrq->cmd->arg <<= 9;\n\n\tmrq->cmd->flags = MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tif (blocks == 1)\n\t\tmrq->stop = NULL;\n\telse {\n\t\tmrq->stop->opcode = MMC_STOP_TRANSMISSION;\n\t\tmrq->stop->arg = 0;\n\t\tmrq->stop->flags = MMC_RSP_R1B | MMC_CMD_AC;\n\t}\n\n\tmrq->data->blksz = blksz;\n\tmrq->data->blocks = blocks;\n\tmrq->data->flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\n\tmrq->data->sg = sg;\n\tmrq->data->sg_len = sg_len;\n\n\tmmc_test_prepare_sbc(test, mrq, blocks);\n\n\tmmc_set_data_timeout(mrq->data, test->card);\n}\n\nstatic int mmc_test_busy(struct mmc_command *cmd)\n{\n\treturn !(cmd->resp[0] & R1_READY_FOR_DATA) ||\n\t\t(R1_CURRENT_STATE(cmd->resp[0]) == R1_STATE_PRG);\n}\n\n \nstatic int mmc_test_wait_busy(struct mmc_test_card *test)\n{\n\tint ret, busy;\n\tstruct mmc_command cmd = {};\n\n\tbusy = 0;\n\tdo {\n\t\tmemset(&cmd, 0, sizeof(struct mmc_command));\n\n\t\tcmd.opcode = MMC_SEND_STATUS;\n\t\tcmd.arg = test->card->rca << 16;\n\t\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\n\t\tret = mmc_wait_for_cmd(test->card->host, &cmd, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (!busy && mmc_test_busy(&cmd)) {\n\t\t\tbusy = 1;\n\t\t\tif (test->card->host->caps & MMC_CAP_WAIT_WHILE_BUSY)\n\t\t\t\tpr_info(\"%s: Warning: Host did not wait for busy state to end.\\n\",\n\t\t\t\t\tmmc_hostname(test->card->host));\n\t\t}\n\t} while (mmc_test_busy(&cmd));\n\n\treturn ret;\n}\n\n \nstatic int mmc_test_buffer_transfer(struct mmc_test_card *test,\n\tu8 *buffer, unsigned addr, unsigned blksz, int write)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_command stop = {};\n\tstruct mmc_data data = {};\n\n\tstruct scatterlist sg;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\tmrq.stop = &stop;\n\n\tsg_init_one(&sg, buffer, blksz);\n\n\tmmc_test_prepare_mrq(test, &mrq, &sg, 1, addr, 1, blksz, write);\n\n\tmmc_wait_for_req(test->card->host, &mrq);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn mmc_test_wait_busy(test);\n}\n\nstatic void mmc_test_free_mem(struct mmc_test_mem *mem)\n{\n\tif (!mem)\n\t\treturn;\n\twhile (mem->cnt--)\n\t\t__free_pages(mem->arr[mem->cnt].page,\n\t\t\t     mem->arr[mem->cnt].order);\n\tkfree(mem->arr);\n\tkfree(mem);\n}\n\n \nstatic struct mmc_test_mem *mmc_test_alloc_mem(unsigned long min_sz,\n\t\t\t\t\t       unsigned long max_sz,\n\t\t\t\t\t       unsigned int max_segs,\n\t\t\t\t\t       unsigned int max_seg_sz)\n{\n\tunsigned long max_page_cnt = DIV_ROUND_UP(max_sz, PAGE_SIZE);\n\tunsigned long min_page_cnt = DIV_ROUND_UP(min_sz, PAGE_SIZE);\n\tunsigned long max_seg_page_cnt = DIV_ROUND_UP(max_seg_sz, PAGE_SIZE);\n\tunsigned long page_cnt = 0;\n\tunsigned long limit = nr_free_buffer_pages() >> 4;\n\tstruct mmc_test_mem *mem;\n\n\tif (max_page_cnt > limit)\n\t\tmax_page_cnt = limit;\n\tif (min_page_cnt > max_page_cnt)\n\t\tmin_page_cnt = max_page_cnt;\n\n\tif (max_seg_page_cnt > max_page_cnt)\n\t\tmax_seg_page_cnt = max_page_cnt;\n\n\tif (max_segs > max_page_cnt)\n\t\tmax_segs = max_page_cnt;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn NULL;\n\n\tmem->arr = kcalloc(max_segs, sizeof(*mem->arr), GFP_KERNEL);\n\tif (!mem->arr)\n\t\tgoto out_free;\n\n\twhile (max_page_cnt) {\n\t\tstruct page *page;\n\t\tunsigned int order;\n\t\tgfp_t flags = GFP_KERNEL | GFP_DMA | __GFP_NOWARN |\n\t\t\t\t__GFP_NORETRY;\n\n\t\torder = get_order(max_seg_page_cnt << PAGE_SHIFT);\n\t\twhile (1) {\n\t\t\tpage = alloc_pages(flags, order);\n\t\t\tif (page || !order)\n\t\t\t\tbreak;\n\t\t\torder -= 1;\n\t\t}\n\t\tif (!page) {\n\t\t\tif (page_cnt < min_page_cnt)\n\t\t\t\tgoto out_free;\n\t\t\tbreak;\n\t\t}\n\t\tmem->arr[mem->cnt].page = page;\n\t\tmem->arr[mem->cnt].order = order;\n\t\tmem->cnt += 1;\n\t\tif (max_page_cnt <= (1UL << order))\n\t\t\tbreak;\n\t\tmax_page_cnt -= 1UL << order;\n\t\tpage_cnt += 1UL << order;\n\t\tif (mem->cnt >= max_segs) {\n\t\t\tif (page_cnt < min_page_cnt)\n\t\t\t\tgoto out_free;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mem;\n\nout_free:\n\tmmc_test_free_mem(mem);\n\treturn NULL;\n}\n\n \nstatic int mmc_test_map_sg(struct mmc_test_mem *mem, unsigned long size,\n\t\t\t   struct scatterlist *sglist, int repeat,\n\t\t\t   unsigned int max_segs, unsigned int max_seg_sz,\n\t\t\t   unsigned int *sg_len, int min_sg_len)\n{\n\tstruct scatterlist *sg = NULL;\n\tunsigned int i;\n\tunsigned long sz = size;\n\n\tsg_init_table(sglist, max_segs);\n\tif (min_sg_len > max_segs)\n\t\tmin_sg_len = max_segs;\n\n\t*sg_len = 0;\n\tdo {\n\t\tfor (i = 0; i < mem->cnt; i++) {\n\t\t\tunsigned long len = PAGE_SIZE << mem->arr[i].order;\n\n\t\t\tif (min_sg_len && (size / min_sg_len < len))\n\t\t\t\tlen = ALIGN(size / min_sg_len, 512);\n\t\t\tif (len > sz)\n\t\t\t\tlen = sz;\n\t\t\tif (len > max_seg_sz)\n\t\t\t\tlen = max_seg_sz;\n\t\t\tif (sg)\n\t\t\t\tsg = sg_next(sg);\n\t\t\telse\n\t\t\t\tsg = sglist;\n\t\t\tif (!sg)\n\t\t\t\treturn -EINVAL;\n\t\t\tsg_set_page(sg, mem->arr[i].page, len, 0);\n\t\t\tsz -= len;\n\t\t\t*sg_len += 1;\n\t\t\tif (!sz)\n\t\t\t\tbreak;\n\t\t}\n\t} while (sz && repeat);\n\n\tif (sz)\n\t\treturn -EINVAL;\n\n\tif (sg)\n\t\tsg_mark_end(sg);\n\n\treturn 0;\n}\n\n \nstatic int mmc_test_map_sg_max_scatter(struct mmc_test_mem *mem,\n\t\t\t\t       unsigned long sz,\n\t\t\t\t       struct scatterlist *sglist,\n\t\t\t\t       unsigned int max_segs,\n\t\t\t\t       unsigned int max_seg_sz,\n\t\t\t\t       unsigned int *sg_len)\n{\n\tstruct scatterlist *sg = NULL;\n\tunsigned int i = mem->cnt, cnt;\n\tunsigned long len;\n\tvoid *base, *addr, *last_addr = NULL;\n\n\tsg_init_table(sglist, max_segs);\n\n\t*sg_len = 0;\n\twhile (sz) {\n\t\tbase = page_address(mem->arr[--i].page);\n\t\tcnt = 1 << mem->arr[i].order;\n\t\twhile (sz && cnt) {\n\t\t\taddr = base + PAGE_SIZE * --cnt;\n\t\t\tif (last_addr && last_addr + PAGE_SIZE == addr)\n\t\t\t\tcontinue;\n\t\t\tlast_addr = addr;\n\t\t\tlen = PAGE_SIZE;\n\t\t\tif (len > max_seg_sz)\n\t\t\t\tlen = max_seg_sz;\n\t\t\tif (len > sz)\n\t\t\t\tlen = sz;\n\t\t\tif (sg)\n\t\t\t\tsg = sg_next(sg);\n\t\t\telse\n\t\t\t\tsg = sglist;\n\t\t\tif (!sg)\n\t\t\t\treturn -EINVAL;\n\t\t\tsg_set_page(sg, virt_to_page(addr), len, 0);\n\t\t\tsz -= len;\n\t\t\t*sg_len += 1;\n\t\t}\n\t\tif (i == 0)\n\t\t\ti = mem->cnt;\n\t}\n\n\tif (sg)\n\t\tsg_mark_end(sg);\n\n\treturn 0;\n}\n\n \nstatic unsigned int mmc_test_rate(uint64_t bytes, struct timespec64 *ts)\n{\n\tuint64_t ns;\n\n\tns = timespec64_to_ns(ts);\n\tbytes *= 1000000000;\n\n\twhile (ns > UINT_MAX) {\n\t\tbytes >>= 1;\n\t\tns >>= 1;\n\t}\n\n\tif (!ns)\n\t\treturn 0;\n\n\tdo_div(bytes, (uint32_t)ns);\n\n\treturn bytes;\n}\n\n \nstatic void mmc_test_save_transfer_result(struct mmc_test_card *test,\n\tunsigned int count, unsigned int sectors, struct timespec64 ts,\n\tunsigned int rate, unsigned int iops)\n{\n\tstruct mmc_test_transfer_result *tr;\n\n\tif (!test->gr)\n\t\treturn;\n\n\ttr = kmalloc(sizeof(*tr), GFP_KERNEL);\n\tif (!tr)\n\t\treturn;\n\n\ttr->count = count;\n\ttr->sectors = sectors;\n\ttr->ts = ts;\n\ttr->rate = rate;\n\ttr->iops = iops;\n\n\tlist_add_tail(&tr->link, &test->gr->tr_lst);\n}\n\n \nstatic void mmc_test_print_rate(struct mmc_test_card *test, uint64_t bytes,\n\t\t\t\tstruct timespec64 *ts1, struct timespec64 *ts2)\n{\n\tunsigned int rate, iops, sectors = bytes >> 9;\n\tstruct timespec64 ts;\n\n\tts = timespec64_sub(*ts2, *ts1);\n\n\trate = mmc_test_rate(bytes, &ts);\n\tiops = mmc_test_rate(100, &ts);  \n\n\tpr_info(\"%s: Transfer of %u sectors (%u%s KiB) took %llu.%09u \"\n\t\t\t \"seconds (%u kB/s, %u KiB/s, %u.%02u IOPS)\\n\",\n\t\t\t mmc_hostname(test->card->host), sectors, sectors >> 1,\n\t\t\t (sectors & 1 ? \".5\" : \"\"), (u64)ts.tv_sec,\n\t\t\t (u32)ts.tv_nsec, rate / 1000, rate / 1024,\n\t\t\t iops / 100, iops % 100);\n\n\tmmc_test_save_transfer_result(test, 1, sectors, ts, rate, iops);\n}\n\n \nstatic void mmc_test_print_avg_rate(struct mmc_test_card *test, uint64_t bytes,\n\t\t\t\t    unsigned int count, struct timespec64 *ts1,\n\t\t\t\t    struct timespec64 *ts2)\n{\n\tunsigned int rate, iops, sectors = bytes >> 9;\n\tuint64_t tot = bytes * count;\n\tstruct timespec64 ts;\n\n\tts = timespec64_sub(*ts2, *ts1);\n\n\trate = mmc_test_rate(tot, &ts);\n\tiops = mmc_test_rate(count * 100, &ts);  \n\n\tpr_info(\"%s: Transfer of %u x %u sectors (%u x %u%s KiB) took \"\n\t\t\t \"%llu.%09u seconds (%u kB/s, %u KiB/s, \"\n\t\t\t \"%u.%02u IOPS, sg_len %d)\\n\",\n\t\t\t mmc_hostname(test->card->host), count, sectors, count,\n\t\t\t sectors >> 1, (sectors & 1 ? \".5\" : \"\"),\n\t\t\t (u64)ts.tv_sec, (u32)ts.tv_nsec,\n\t\t\t rate / 1000, rate / 1024, iops / 100, iops % 100,\n\t\t\t test->area.sg_len);\n\n\tmmc_test_save_transfer_result(test, count, sectors, ts, rate, iops);\n}\n\n \nstatic unsigned int mmc_test_capacity(struct mmc_card *card)\n{\n\tif (!mmc_card_sd(card) && mmc_card_blockaddr(card))\n\t\treturn card->ext_csd.sectors;\n\telse\n\t\treturn card->csd.capacity << (card->csd.read_blkbits - 9);\n}\n\n \n \n \n\n \nstatic int __mmc_test_prepare(struct mmc_test_card *test, int write, int val)\n{\n\tint ret, i;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\tif (write)\n\t\tmemset(test->buffer, val, 512);\n\telse {\n\t\tfor (i = 0; i < 512; i++)\n\t\t\ttest->buffer[i] = i;\n\t}\n\n\tfor (i = 0; i < BUFFER_SIZE / 512; i++) {\n\t\tret = mmc_test_buffer_transfer(test, test->buffer, i, 512, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_prepare_write(struct mmc_test_card *test)\n{\n\treturn __mmc_test_prepare(test, 1, 0xDF);\n}\n\nstatic int mmc_test_prepare_read(struct mmc_test_card *test)\n{\n\treturn __mmc_test_prepare(test, 0, 0);\n}\n\nstatic int mmc_test_cleanup(struct mmc_test_card *test)\n{\n\treturn __mmc_test_prepare(test, 1, 0);\n}\n\n \n \n \n\n \nstatic void mmc_test_prepare_broken_mrq(struct mmc_test_card *test,\n\tstruct mmc_request *mrq, int write)\n{\n\tif (WARN_ON(!mrq || !mrq->cmd || !mrq->data))\n\t\treturn;\n\n\tif (mrq->data->blocks > 1) {\n\t\tmrq->cmd->opcode = write ?\n\t\t\tMMC_WRITE_BLOCK : MMC_READ_SINGLE_BLOCK;\n\t\tmrq->stop = NULL;\n\t} else {\n\t\tmrq->cmd->opcode = MMC_SEND_STATUS;\n\t\tmrq->cmd->arg = test->card->rca << 16;\n\t}\n}\n\n \nstatic int mmc_test_check_result(struct mmc_test_card *test,\n\t\t\t\t struct mmc_request *mrq)\n{\n\tint ret;\n\n\tif (WARN_ON(!mrq || !mrq->cmd || !mrq->data))\n\t\treturn -EINVAL;\n\n\tret = 0;\n\n\tif (mrq->sbc && mrq->sbc->error)\n\t\tret = mrq->sbc->error;\n\tif (!ret && mrq->cmd->error)\n\t\tret = mrq->cmd->error;\n\tif (!ret && mrq->data->error)\n\t\tret = mrq->data->error;\n\tif (!ret && mrq->stop && mrq->stop->error)\n\t\tret = mrq->stop->error;\n\tif (!ret && mrq->data->bytes_xfered !=\n\t\tmrq->data->blocks * mrq->data->blksz)\n\t\tret = RESULT_FAIL;\n\n\tif (ret == -EINVAL)\n\t\tret = RESULT_UNSUP_HOST;\n\n\treturn ret;\n}\n\n \nstatic int mmc_test_check_broken_result(struct mmc_test_card *test,\n\tstruct mmc_request *mrq)\n{\n\tint ret;\n\n\tif (WARN_ON(!mrq || !mrq->cmd || !mrq->data))\n\t\treturn -EINVAL;\n\n\tret = 0;\n\n\tif (!ret && mrq->cmd->error)\n\t\tret = mrq->cmd->error;\n\tif (!ret && mrq->data->error == 0)\n\t\tret = RESULT_FAIL;\n\tif (!ret && mrq->data->error != -ETIMEDOUT)\n\t\tret = mrq->data->error;\n\tif (!ret && mrq->stop && mrq->stop->error)\n\t\tret = mrq->stop->error;\n\tif (mrq->data->blocks > 1) {\n\t\tif (!ret && mrq->data->bytes_xfered > mrq->data->blksz)\n\t\t\tret = RESULT_FAIL;\n\t} else {\n\t\tif (!ret && mrq->data->bytes_xfered > 0)\n\t\t\tret = RESULT_FAIL;\n\t}\n\n\tif (ret == -EINVAL)\n\t\tret = RESULT_UNSUP_HOST;\n\n\treturn ret;\n}\n\nstruct mmc_test_req {\n\tstruct mmc_request mrq;\n\tstruct mmc_command sbc;\n\tstruct mmc_command cmd;\n\tstruct mmc_command stop;\n\tstruct mmc_command status;\n\tstruct mmc_data data;\n};\n\n \nstatic void mmc_test_req_reset(struct mmc_test_req *rq)\n{\n\tmemset(rq, 0, sizeof(struct mmc_test_req));\n\n\trq->mrq.cmd = &rq->cmd;\n\trq->mrq.data = &rq->data;\n\trq->mrq.stop = &rq->stop;\n}\n\nstatic struct mmc_test_req *mmc_test_req_alloc(void)\n{\n\tstruct mmc_test_req *rq = kmalloc(sizeof(*rq), GFP_KERNEL);\n\n\tif (rq)\n\t\tmmc_test_req_reset(rq);\n\n\treturn rq;\n}\n\nstatic void mmc_test_wait_done(struct mmc_request *mrq)\n{\n\tcomplete(&mrq->completion);\n}\n\nstatic int mmc_test_start_areq(struct mmc_test_card *test,\n\t\t\t       struct mmc_request *mrq,\n\t\t\t       struct mmc_request *prev_mrq)\n{\n\tstruct mmc_host *host = test->card->host;\n\tint err = 0;\n\n\tif (mrq) {\n\t\tinit_completion(&mrq->completion);\n\t\tmrq->done = mmc_test_wait_done;\n\t\tmmc_pre_req(host, mrq);\n\t}\n\n\tif (prev_mrq) {\n\t\twait_for_completion(&prev_mrq->completion);\n\t\terr = mmc_test_wait_busy(test);\n\t\tif (!err)\n\t\t\terr = mmc_test_check_result(test, prev_mrq);\n\t}\n\n\tif (!err && mrq) {\n\t\terr = mmc_start_request(host, mrq);\n\t\tif (err)\n\t\t\tmmc_retune_release(host);\n\t}\n\n\tif (prev_mrq)\n\t\tmmc_post_req(host, prev_mrq, 0);\n\n\tif (err && mrq)\n\t\tmmc_post_req(host, mrq, err);\n\n\treturn err;\n}\n\nstatic int mmc_test_nonblock_transfer(struct mmc_test_card *test,\n\t\t\t\t      unsigned int dev_addr, int write,\n\t\t\t\t      int count)\n{\n\tstruct mmc_test_req *rq1, *rq2;\n\tstruct mmc_request *mrq, *prev_mrq;\n\tint i;\n\tint ret = RESULT_OK;\n\tstruct mmc_test_area *t = &test->area;\n\tstruct scatterlist *sg = t->sg;\n\tstruct scatterlist *sg_areq = t->sg_areq;\n\n\trq1 = mmc_test_req_alloc();\n\trq2 = mmc_test_req_alloc();\n\tif (!rq1 || !rq2) {\n\t\tret = RESULT_FAIL;\n\t\tgoto err;\n\t}\n\n\tmrq = &rq1->mrq;\n\tprev_mrq = NULL;\n\n\tfor (i = 0; i < count; i++) {\n\t\tmmc_test_req_reset(container_of(mrq, struct mmc_test_req, mrq));\n\t\tmmc_test_prepare_mrq(test, mrq, sg, t->sg_len, dev_addr,\n\t\t\t\t     t->blocks, 512, write);\n\t\tret = mmc_test_start_areq(test, mrq, prev_mrq);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (!prev_mrq)\n\t\t\tprev_mrq = &rq2->mrq;\n\n\t\tswap(mrq, prev_mrq);\n\t\tswap(sg, sg_areq);\n\t\tdev_addr += t->blocks;\n\t}\n\n\tret = mmc_test_start_areq(test, NULL, prev_mrq);\nerr:\n\tkfree(rq1);\n\tkfree(rq2);\n\treturn ret;\n}\n\n \nstatic int mmc_test_simple_transfer(struct mmc_test_card *test,\n\tstruct scatterlist *sg, unsigned sg_len, unsigned dev_addr,\n\tunsigned blocks, unsigned blksz, int write)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_command stop = {};\n\tstruct mmc_data data = {};\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\tmrq.stop = &stop;\n\n\tmmc_test_prepare_mrq(test, &mrq, sg, sg_len, dev_addr,\n\t\tblocks, blksz, write);\n\n\tmmc_wait_for_req(test->card->host, &mrq);\n\n\tmmc_test_wait_busy(test);\n\n\treturn mmc_test_check_result(test, &mrq);\n}\n\n \nstatic int mmc_test_broken_transfer(struct mmc_test_card *test,\n\tunsigned blocks, unsigned blksz, int write)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_command stop = {};\n\tstruct mmc_data data = {};\n\n\tstruct scatterlist sg;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\tmrq.stop = &stop;\n\n\tsg_init_one(&sg, test->buffer, blocks * blksz);\n\n\tmmc_test_prepare_mrq(test, &mrq, &sg, 1, 0, blocks, blksz, write);\n\tmmc_test_prepare_broken_mrq(test, &mrq, write);\n\n\tmmc_wait_for_req(test->card->host, &mrq);\n\n\tmmc_test_wait_busy(test);\n\n\treturn mmc_test_check_broken_result(test, &mrq);\n}\n\n \nstatic int mmc_test_transfer(struct mmc_test_card *test,\n\tstruct scatterlist *sg, unsigned sg_len, unsigned dev_addr,\n\tunsigned blocks, unsigned blksz, int write)\n{\n\tint ret, i;\n\n\tif (write) {\n\t\tfor (i = 0; i < blocks * blksz; i++)\n\t\t\ttest->scratch[i] = i;\n\t} else {\n\t\tmemset(test->scratch, 0, BUFFER_SIZE);\n\t}\n\tsg_copy_from_buffer(sg, sg_len, test->scratch, BUFFER_SIZE);\n\n\tret = mmc_test_set_blksize(test, blksz);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_test_simple_transfer(test, sg, sg_len, dev_addr,\n\t\tblocks, blksz, write);\n\tif (ret)\n\t\treturn ret;\n\n\tif (write) {\n\t\tint sectors;\n\n\t\tret = mmc_test_set_blksize(test, 512);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tsectors = (blocks * blksz + 511) / 512;\n\t\tif ((sectors * 512) == (blocks * blksz))\n\t\t\tsectors++;\n\n\t\tif ((sectors * 512) > BUFFER_SIZE)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(test->buffer, 0, sectors * 512);\n\n\t\tfor (i = 0; i < sectors; i++) {\n\t\t\tret = mmc_test_buffer_transfer(test,\n\t\t\t\ttest->buffer + i * 512,\n\t\t\t\tdev_addr + i, 512, 0);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tfor (i = 0; i < blocks * blksz; i++) {\n\t\t\tif (test->buffer[i] != (u8)i)\n\t\t\t\treturn RESULT_FAIL;\n\t\t}\n\n\t\tfor (; i < sectors * 512; i++) {\n\t\t\tif (test->buffer[i] != 0xDF)\n\t\t\t\treturn RESULT_FAIL;\n\t\t}\n\t} else {\n\t\tsg_copy_to_buffer(sg, sg_len, test->scratch, BUFFER_SIZE);\n\t\tfor (i = 0; i < blocks * blksz; i++) {\n\t\t\tif (test->scratch[i] != (u8)i)\n\t\t\t\treturn RESULT_FAIL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \n \n \n\nstruct mmc_test_case {\n\tconst char *name;\n\n\tint (*prepare)(struct mmc_test_card *);\n\tint (*run)(struct mmc_test_card *);\n\tint (*cleanup)(struct mmc_test_card *);\n};\n\nstatic int mmc_test_basic_write(struct mmc_test_card *test)\n{\n\tint ret;\n\tstruct scatterlist sg;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\tsg_init_one(&sg, test->buffer, 512);\n\n\treturn mmc_test_simple_transfer(test, &sg, 1, 0, 1, 512, 1);\n}\n\nstatic int mmc_test_basic_read(struct mmc_test_card *test)\n{\n\tint ret;\n\tstruct scatterlist sg;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\tsg_init_one(&sg, test->buffer, 512);\n\n\treturn mmc_test_simple_transfer(test, &sg, 1, 0, 1, 512, 0);\n}\n\nstatic int mmc_test_verify_write(struct mmc_test_card *test)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, test->buffer, 512);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, 1, 512, 1);\n}\n\nstatic int mmc_test_verify_read(struct mmc_test_card *test)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_one(&sg, test->buffer, 512);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, 1, 512, 0);\n}\n\nstatic int mmc_test_multi_write(struct mmc_test_card *test)\n{\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsg_init_one(&sg, test->buffer, size);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 1);\n}\n\nstatic int mmc_test_multi_read(struct mmc_test_card *test)\n{\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsg_init_one(&sg, test->buffer, size);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 0);\n}\n\nstatic int mmc_test_pow2_write(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tif (!test->card->csd.write_partial)\n\t\treturn RESULT_UNSUP_CARD;\n\n\tfor (i = 1; i < 512; i <<= 1) {\n\t\tsg_init_one(&sg, test->buffer, i);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_pow2_read(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tif (!test->card->csd.read_partial)\n\t\treturn RESULT_UNSUP_CARD;\n\n\tfor (i = 1; i < 512; i <<= 1) {\n\t\tsg_init_one(&sg, test->buffer, i);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_weird_write(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tif (!test->card->csd.write_partial)\n\t\treturn RESULT_UNSUP_CARD;\n\n\tfor (i = 3; i < 512; i += 7) {\n\t\tsg_init_one(&sg, test->buffer, i);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_weird_read(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tif (!test->card->csd.read_partial)\n\t\treturn RESULT_UNSUP_CARD;\n\n\tfor (i = 3; i < 512; i += 7) {\n\t\tsg_init_one(&sg, test->buffer, i);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, i, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_align_write(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tfor (i = 1; i < TEST_ALIGN_END; i++) {\n\t\tsg_init_one(&sg, test->buffer + i, 512);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, 512, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_align_read(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tstruct scatterlist sg;\n\n\tfor (i = 1; i < TEST_ALIGN_END; i++) {\n\t\tsg_init_one(&sg, test->buffer + i, 512);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, 1, 512, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_align_multi_write(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tfor (i = 1; i < TEST_ALIGN_END; i++) {\n\t\tsg_init_one(&sg, test->buffer + i, size);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_align_multi_read(struct mmc_test_card *test)\n{\n\tint ret, i;\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tfor (i = 1; i < TEST_ALIGN_END; i++) {\n\t\tsg_init_one(&sg, test->buffer + i, size);\n\t\tret = mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_test_xfersize_write(struct mmc_test_card *test)\n{\n\tint ret;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_test_broken_transfer(test, 1, 512, 1);\n}\n\nstatic int mmc_test_xfersize_read(struct mmc_test_card *test)\n{\n\tint ret;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_test_broken_transfer(test, 1, 512, 0);\n}\n\nstatic int mmc_test_multi_xfersize_write(struct mmc_test_card *test)\n{\n\tint ret;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_test_broken_transfer(test, 2, 512, 1);\n}\n\nstatic int mmc_test_multi_xfersize_read(struct mmc_test_card *test)\n{\n\tint ret;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_test_broken_transfer(test, 2, 512, 0);\n}\n\n#ifdef CONFIG_HIGHMEM\n\nstatic int mmc_test_write_high(struct mmc_test_card *test)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, test->highmem, 512, 0);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, 1, 512, 1);\n}\n\nstatic int mmc_test_read_high(struct mmc_test_card *test)\n{\n\tstruct scatterlist sg;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, test->highmem, 512, 0);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, 1, 512, 0);\n}\n\nstatic int mmc_test_multi_write_high(struct mmc_test_card *test)\n{\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, test->highmem, size, 0);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 1);\n}\n\nstatic int mmc_test_multi_read_high(struct mmc_test_card *test)\n{\n\tunsigned int size;\n\tstruct scatterlist sg;\n\n\tif (test->card->host->max_blk_count == 1)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsize = PAGE_SIZE * 2;\n\tsize = min(size, test->card->host->max_req_size);\n\tsize = min(size, test->card->host->max_seg_size);\n\tsize = min(size, test->card->host->max_blk_count * 512);\n\n\tif (size < 1024)\n\t\treturn RESULT_UNSUP_HOST;\n\n\tsg_init_table(&sg, 1);\n\tsg_set_page(&sg, test->highmem, size, 0);\n\n\treturn mmc_test_transfer(test, &sg, 1, 0, size / 512, 512, 0);\n}\n\n#else\n\nstatic int mmc_test_no_highmem(struct mmc_test_card *test)\n{\n\tpr_info(\"%s: Highmem not configured - test skipped\\n\",\n\t       mmc_hostname(test->card->host));\n\treturn 0;\n}\n\n#endif  \n\n \nstatic int mmc_test_area_map(struct mmc_test_card *test, unsigned long sz,\n\t\t\t     int max_scatter, int min_sg_len, bool nonblock)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tint err;\n\tunsigned int sg_len = 0;\n\n\tt->blocks = sz >> 9;\n\n\tif (max_scatter) {\n\t\terr = mmc_test_map_sg_max_scatter(t->mem, sz, t->sg,\n\t\t\t\t\t\t  t->max_segs, t->max_seg_sz,\n\t\t\t\t       &t->sg_len);\n\t} else {\n\t\terr = mmc_test_map_sg(t->mem, sz, t->sg, 1, t->max_segs,\n\t\t\t\t      t->max_seg_sz, &t->sg_len, min_sg_len);\n\t}\n\n\tif (err || !nonblock)\n\t\tgoto err;\n\n\tif (max_scatter) {\n\t\terr = mmc_test_map_sg_max_scatter(t->mem, sz, t->sg_areq,\n\t\t\t\t\t\t  t->max_segs, t->max_seg_sz,\n\t\t\t\t\t\t  &sg_len);\n\t} else {\n\t\terr = mmc_test_map_sg(t->mem, sz, t->sg_areq, 1, t->max_segs,\n\t\t\t\t      t->max_seg_sz, &sg_len, min_sg_len);\n\t}\n\tif (!err && sg_len != t->sg_len)\n\t\terr = -EINVAL;\n\nerr:\n\tif (err)\n\t\tpr_info(\"%s: Failed to map sg list\\n\",\n\t\t       mmc_hostname(test->card->host));\n\treturn err;\n}\n\n \nstatic int mmc_test_area_transfer(struct mmc_test_card *test,\n\t\t\t\t  unsigned int dev_addr, int write)\n{\n\tstruct mmc_test_area *t = &test->area;\n\n\treturn mmc_test_simple_transfer(test, t->sg, t->sg_len, dev_addr,\n\t\t\t\t\tt->blocks, 512, write);\n}\n\n \nstatic int mmc_test_area_io_seq(struct mmc_test_card *test, unsigned long sz,\n\t\t\t\tunsigned int dev_addr, int write,\n\t\t\t\tint max_scatter, int timed, int count,\n\t\t\t\tbool nonblock, int min_sg_len)\n{\n\tstruct timespec64 ts1, ts2;\n\tint ret = 0;\n\tint i;\n\n\t \n\tif (max_scatter) {\n\t\tstruct mmc_test_area *t = &test->area;\n\t\tunsigned long max_tfr;\n\n\t\tif (t->max_seg_sz >= PAGE_SIZE)\n\t\t\tmax_tfr = t->max_segs * PAGE_SIZE;\n\t\telse\n\t\t\tmax_tfr = t->max_segs * t->max_seg_sz;\n\t\tif (sz > max_tfr)\n\t\t\tsz = max_tfr;\n\t}\n\n\tret = mmc_test_area_map(test, sz, max_scatter, min_sg_len, nonblock);\n\tif (ret)\n\t\treturn ret;\n\n\tif (timed)\n\t\tktime_get_ts64(&ts1);\n\tif (nonblock)\n\t\tret = mmc_test_nonblock_transfer(test, dev_addr, write, count);\n\telse\n\t\tfor (i = 0; i < count && ret == 0; i++) {\n\t\t\tret = mmc_test_area_transfer(test, dev_addr, write);\n\t\t\tdev_addr += sz >> 9;\n\t\t}\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (timed)\n\t\tktime_get_ts64(&ts2);\n\n\tif (timed)\n\t\tmmc_test_print_avg_rate(test, sz, count, &ts1, &ts2);\n\n\treturn 0;\n}\n\nstatic int mmc_test_area_io(struct mmc_test_card *test, unsigned long sz,\n\t\t\t    unsigned int dev_addr, int write, int max_scatter,\n\t\t\t    int timed)\n{\n\treturn mmc_test_area_io_seq(test, sz, dev_addr, write, max_scatter,\n\t\t\t\t    timed, 1, false, 0);\n}\n\n \nstatic int mmc_test_area_fill(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\n\treturn mmc_test_area_io(test, t->max_tfr, t->dev_addr, 1, 0, 0);\n}\n\n \nstatic int mmc_test_area_erase(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\n\tif (!mmc_can_erase(test->card))\n\t\treturn 0;\n\n\treturn mmc_erase(test->card, t->dev_addr, t->max_sz >> 9,\n\t\t\t MMC_ERASE_ARG);\n}\n\n \nstatic int mmc_test_area_cleanup(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\n\tkfree(t->sg);\n\tkfree(t->sg_areq);\n\tmmc_test_free_mem(t->mem);\n\n\treturn 0;\n}\n\n \nstatic int mmc_test_area_init(struct mmc_test_card *test, int erase, int fill)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long min_sz = 64 * 1024, sz;\n\tint ret;\n\n\tret = mmc_test_set_blksize(test, 512);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tsz = (unsigned long)test->card->pref_erase << 9;\n\tt->max_sz = sz;\n\twhile (t->max_sz < 4 * 1024 * 1024)\n\t\tt->max_sz += sz;\n\twhile (t->max_sz > TEST_AREA_MAX_SIZE && t->max_sz > sz)\n\t\tt->max_sz -= sz;\n\n\tt->max_segs = test->card->host->max_segs;\n\tt->max_seg_sz = test->card->host->max_seg_size;\n\tt->max_seg_sz -= t->max_seg_sz % 512;\n\n\tt->max_tfr = t->max_sz;\n\tif (t->max_tfr >> 9 > test->card->host->max_blk_count)\n\t\tt->max_tfr = test->card->host->max_blk_count << 9;\n\tif (t->max_tfr > test->card->host->max_req_size)\n\t\tt->max_tfr = test->card->host->max_req_size;\n\tif (t->max_tfr / t->max_seg_sz > t->max_segs)\n\t\tt->max_tfr = t->max_segs * t->max_seg_sz;\n\n\t \n\tt->mem = mmc_test_alloc_mem(min_sz, t->max_tfr, t->max_segs,\n\t\t\t\t    t->max_seg_sz);\n\tif (!t->mem)\n\t\treturn -ENOMEM;\n\n\tt->sg = kmalloc_array(t->max_segs, sizeof(*t->sg), GFP_KERNEL);\n\tif (!t->sg) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tt->sg_areq = kmalloc_array(t->max_segs, sizeof(*t->sg_areq),\n\t\t\t\t   GFP_KERNEL);\n\tif (!t->sg_areq) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\tt->dev_addr = mmc_test_capacity(test->card) / 2;\n\tt->dev_addr -= t->dev_addr % (t->max_sz >> 9);\n\n\tif (erase) {\n\t\tret = mmc_test_area_erase(test);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\tif (fill) {\n\t\tret = mmc_test_area_fill(test);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t}\n\n\treturn 0;\n\nout_free:\n\tmmc_test_area_cleanup(test);\n\treturn ret;\n}\n\n \nstatic int mmc_test_area_prepare(struct mmc_test_card *test)\n{\n\treturn mmc_test_area_init(test, 0, 0);\n}\n\n \nstatic int mmc_test_area_prepare_erase(struct mmc_test_card *test)\n{\n\treturn mmc_test_area_init(test, 1, 0);\n}\n\n \nstatic int mmc_test_area_prepare_fill(struct mmc_test_card *test)\n{\n\treturn mmc_test_area_init(test, 1, 1);\n}\n\n \nstatic int mmc_test_best_performance(struct mmc_test_card *test, int write,\n\t\t\t\t     int max_scatter)\n{\n\tstruct mmc_test_area *t = &test->area;\n\n\treturn mmc_test_area_io(test, t->max_tfr, t->dev_addr, write,\n\t\t\t\tmax_scatter, 1);\n}\n\n \nstatic int mmc_test_best_read_performance(struct mmc_test_card *test)\n{\n\treturn mmc_test_best_performance(test, 0, 0);\n}\n\n \nstatic int mmc_test_best_write_performance(struct mmc_test_card *test)\n{\n\treturn mmc_test_best_performance(test, 1, 0);\n}\n\n \nstatic int mmc_test_best_read_perf_max_scatter(struct mmc_test_card *test)\n{\n\treturn mmc_test_best_performance(test, 0, 1);\n}\n\n \nstatic int mmc_test_best_write_perf_max_scatter(struct mmc_test_card *test)\n{\n\treturn mmc_test_best_performance(test, 1, 1);\n}\n\n \nstatic int mmc_test_profile_read_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tunsigned int dev_addr;\n\tint ret;\n\n\tfor (sz = 512; sz < t->max_tfr; sz <<= 1) {\n\t\tdev_addr = t->dev_addr + (sz >> 9);\n\t\tret = mmc_test_area_io(test, sz, dev_addr, 0, 0, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsz = t->max_tfr;\n\tdev_addr = t->dev_addr;\n\treturn mmc_test_area_io(test, sz, dev_addr, 0, 0, 1);\n}\n\n \nstatic int mmc_test_profile_write_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tunsigned int dev_addr;\n\tint ret;\n\n\tret = mmc_test_area_erase(test);\n\tif (ret)\n\t\treturn ret;\n\tfor (sz = 512; sz < t->max_tfr; sz <<= 1) {\n\t\tdev_addr = t->dev_addr + (sz >> 9);\n\t\tret = mmc_test_area_io(test, sz, dev_addr, 1, 0, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tret = mmc_test_area_erase(test);\n\tif (ret)\n\t\treturn ret;\n\tsz = t->max_tfr;\n\tdev_addr = t->dev_addr;\n\treturn mmc_test_area_io(test, sz, dev_addr, 1, 0, 1);\n}\n\n \nstatic int mmc_test_profile_trim_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tunsigned int dev_addr;\n\tstruct timespec64 ts1, ts2;\n\tint ret;\n\n\tif (!mmc_can_trim(test->card))\n\t\treturn RESULT_UNSUP_CARD;\n\n\tif (!mmc_can_erase(test->card))\n\t\treturn RESULT_UNSUP_HOST;\n\n\tfor (sz = 512; sz < t->max_sz; sz <<= 1) {\n\t\tdev_addr = t->dev_addr + (sz >> 9);\n\t\tktime_get_ts64(&ts1);\n\t\tret = mmc_erase(test->card, dev_addr, sz >> 9, MMC_TRIM_ARG);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tktime_get_ts64(&ts2);\n\t\tmmc_test_print_rate(test, sz, &ts1, &ts2);\n\t}\n\tdev_addr = t->dev_addr;\n\tktime_get_ts64(&ts1);\n\tret = mmc_erase(test->card, dev_addr, sz >> 9, MMC_TRIM_ARG);\n\tif (ret)\n\t\treturn ret;\n\tktime_get_ts64(&ts2);\n\tmmc_test_print_rate(test, sz, &ts1, &ts2);\n\treturn 0;\n}\n\nstatic int mmc_test_seq_read_perf(struct mmc_test_card *test, unsigned long sz)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned int dev_addr, i, cnt;\n\tstruct timespec64 ts1, ts2;\n\tint ret;\n\n\tcnt = t->max_sz / sz;\n\tdev_addr = t->dev_addr;\n\tktime_get_ts64(&ts1);\n\tfor (i = 0; i < cnt; i++) {\n\t\tret = mmc_test_area_io(test, sz, dev_addr, 0, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_addr += (sz >> 9);\n\t}\n\tktime_get_ts64(&ts2);\n\tmmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);\n\treturn 0;\n}\n\n \nstatic int mmc_test_profile_seq_read_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tint ret;\n\n\tfor (sz = 512; sz < t->max_tfr; sz <<= 1) {\n\t\tret = mmc_test_seq_read_perf(test, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsz = t->max_tfr;\n\treturn mmc_test_seq_read_perf(test, sz);\n}\n\nstatic int mmc_test_seq_write_perf(struct mmc_test_card *test, unsigned long sz)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned int dev_addr, i, cnt;\n\tstruct timespec64 ts1, ts2;\n\tint ret;\n\n\tret = mmc_test_area_erase(test);\n\tif (ret)\n\t\treturn ret;\n\tcnt = t->max_sz / sz;\n\tdev_addr = t->dev_addr;\n\tktime_get_ts64(&ts1);\n\tfor (i = 0; i < cnt; i++) {\n\t\tret = mmc_test_area_io(test, sz, dev_addr, 1, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_addr += (sz >> 9);\n\t}\n\tktime_get_ts64(&ts2);\n\tmmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);\n\treturn 0;\n}\n\n \nstatic int mmc_test_profile_seq_write_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tint ret;\n\n\tfor (sz = 512; sz < t->max_tfr; sz <<= 1) {\n\t\tret = mmc_test_seq_write_perf(test, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsz = t->max_tfr;\n\treturn mmc_test_seq_write_perf(test, sz);\n}\n\n \nstatic int mmc_test_profile_seq_trim_perf(struct mmc_test_card *test)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tunsigned int dev_addr, i, cnt;\n\tstruct timespec64 ts1, ts2;\n\tint ret;\n\n\tif (!mmc_can_trim(test->card))\n\t\treturn RESULT_UNSUP_CARD;\n\n\tif (!mmc_can_erase(test->card))\n\t\treturn RESULT_UNSUP_HOST;\n\n\tfor (sz = 512; sz <= t->max_sz; sz <<= 1) {\n\t\tret = mmc_test_area_erase(test);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = mmc_test_area_fill(test);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tcnt = t->max_sz / sz;\n\t\tdev_addr = t->dev_addr;\n\t\tktime_get_ts64(&ts1);\n\t\tfor (i = 0; i < cnt; i++) {\n\t\t\tret = mmc_erase(test->card, dev_addr, sz >> 9,\n\t\t\t\t\tMMC_TRIM_ARG);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tdev_addr += (sz >> 9);\n\t\t}\n\t\tktime_get_ts64(&ts2);\n\t\tmmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);\n\t}\n\treturn 0;\n}\n\nstatic unsigned int rnd_next = 1;\n\nstatic unsigned int mmc_test_rnd_num(unsigned int rnd_cnt)\n{\n\tuint64_t r;\n\n\trnd_next = rnd_next * 1103515245 + 12345;\n\tr = (rnd_next >> 16) & 0x7fff;\n\treturn (r * rnd_cnt) >> 15;\n}\n\nstatic int mmc_test_rnd_perf(struct mmc_test_card *test, int write, int print,\n\t\t\t     unsigned long sz)\n{\n\tunsigned int dev_addr, cnt, rnd_addr, range1, range2, last_ea = 0, ea;\n\tunsigned int ssz;\n\tstruct timespec64 ts1, ts2, ts;\n\tint ret;\n\n\tssz = sz >> 9;\n\n\trnd_addr = mmc_test_capacity(test->card) / 4;\n\trange1 = rnd_addr / test->card->pref_erase;\n\trange2 = range1 / ssz;\n\n\tktime_get_ts64(&ts1);\n\tfor (cnt = 0; cnt < UINT_MAX; cnt++) {\n\t\tktime_get_ts64(&ts2);\n\t\tts = timespec64_sub(ts2, ts1);\n\t\tif (ts.tv_sec >= 10)\n\t\t\tbreak;\n\t\tea = mmc_test_rnd_num(range1);\n\t\tif (ea == last_ea)\n\t\t\tea -= 1;\n\t\tlast_ea = ea;\n\t\tdev_addr = rnd_addr + test->card->pref_erase * ea +\n\t\t\t   ssz * mmc_test_rnd_num(range2);\n\t\tret = mmc_test_area_io(test, sz, dev_addr, write, 0, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (print)\n\t\tmmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);\n\treturn 0;\n}\n\nstatic int mmc_test_random_perf(struct mmc_test_card *test, int write)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned int next;\n\tunsigned long sz;\n\tint ret;\n\n\tfor (sz = 512; sz < t->max_tfr; sz <<= 1) {\n\t\t \n\t\tif (write) {\n\t\t\tnext = rnd_next;\n\t\t\tret = mmc_test_rnd_perf(test, write, 0, sz);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\trnd_next = next;\n\t\t}\n\t\tret = mmc_test_rnd_perf(test, write, 1, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tsz = t->max_tfr;\n\tif (write) {\n\t\tnext = rnd_next;\n\t\tret = mmc_test_rnd_perf(test, write, 0, sz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\trnd_next = next;\n\t}\n\treturn mmc_test_rnd_perf(test, write, 1, sz);\n}\n\n \nstatic int mmc_test_random_read_perf(struct mmc_test_card *test)\n{\n\treturn mmc_test_random_perf(test, 0);\n}\n\n \nstatic int mmc_test_random_write_perf(struct mmc_test_card *test)\n{\n\treturn mmc_test_random_perf(test, 1);\n}\n\nstatic int mmc_test_seq_perf(struct mmc_test_card *test, int write,\n\t\t\t     unsigned int tot_sz, int max_scatter)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned int dev_addr, i, cnt, sz, ssz;\n\tstruct timespec64 ts1, ts2;\n\tint ret;\n\n\tsz = t->max_tfr;\n\n\t \n\tif (max_scatter) {\n\t\tunsigned long max_tfr;\n\n\t\tif (t->max_seg_sz >= PAGE_SIZE)\n\t\t\tmax_tfr = t->max_segs * PAGE_SIZE;\n\t\telse\n\t\t\tmax_tfr = t->max_segs * t->max_seg_sz;\n\t\tif (sz > max_tfr)\n\t\t\tsz = max_tfr;\n\t}\n\n\tssz = sz >> 9;\n\tdev_addr = mmc_test_capacity(test->card) / 4;\n\tif (tot_sz > dev_addr << 9)\n\t\ttot_sz = dev_addr << 9;\n\tcnt = tot_sz / sz;\n\tdev_addr &= 0xffff0000;  \n\n\tktime_get_ts64(&ts1);\n\tfor (i = 0; i < cnt; i++) {\n\t\tret = mmc_test_area_io(test, sz, dev_addr, write,\n\t\t\t\t       max_scatter, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdev_addr += ssz;\n\t}\n\tktime_get_ts64(&ts2);\n\n\tmmc_test_print_avg_rate(test, sz, cnt, &ts1, &ts2);\n\n\treturn 0;\n}\n\nstatic int mmc_test_large_seq_perf(struct mmc_test_card *test, int write)\n{\n\tint ret, i;\n\n\tfor (i = 0; i < 10; i++) {\n\t\tret = mmc_test_seq_perf(test, write, 10 * 1024 * 1024, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tfor (i = 0; i < 5; i++) {\n\t\tret = mmc_test_seq_perf(test, write, 100 * 1024 * 1024, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tfor (i = 0; i < 3; i++) {\n\t\tret = mmc_test_seq_perf(test, write, 1000 * 1024 * 1024, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int mmc_test_large_seq_read_perf(struct mmc_test_card *test)\n{\n\treturn mmc_test_large_seq_perf(test, 0);\n}\n\n \nstatic int mmc_test_large_seq_write_perf(struct mmc_test_card *test)\n{\n\treturn mmc_test_large_seq_perf(test, 1);\n}\n\nstatic int mmc_test_rw_multiple(struct mmc_test_card *test,\n\t\t\t\tstruct mmc_test_multiple_rw *tdata,\n\t\t\t\tunsigned int reqsize, unsigned int size,\n\t\t\t\tint min_sg_len)\n{\n\tunsigned int dev_addr;\n\tstruct mmc_test_area *t = &test->area;\n\tint ret = 0;\n\n\t \n\tif (size > mmc_test_capacity(test->card) / 2 * 512)\n\t\tsize = mmc_test_capacity(test->card) / 2 * 512;\n\tif (reqsize > t->max_tfr)\n\t\treqsize = t->max_tfr;\n\tdev_addr = mmc_test_capacity(test->card) / 4;\n\tif ((dev_addr & 0xffff0000))\n\t\tdev_addr &= 0xffff0000;  \n\telse\n\t\tdev_addr &= 0xfffff800;  \n\tif (!dev_addr)\n\t\tgoto err;\n\n\tif (reqsize > size)\n\t\treturn 0;\n\n\t \n\tif (mmc_can_erase(test->card) &&\n\t    tdata->prepare & MMC_TEST_PREP_ERASE) {\n\t\tret = mmc_erase(test->card, dev_addr,\n\t\t\t\tsize / 512, test->card->erase_arg);\n\t\tif (ret)\n\t\t\tret = mmc_erase(test->card, dev_addr,\n\t\t\t\t\tsize / 512, MMC_ERASE_ARG);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\t \n\tret = mmc_test_area_io_seq(test, reqsize, dev_addr,\n\t\t\t\t   tdata->do_write, 0, 1, size / reqsize,\n\t\t\t\t   tdata->do_nonblock_req, min_sg_len);\n\tif (ret)\n\t\tgoto err;\n\n\treturn ret;\n err:\n\tpr_info(\"[%s] error\\n\", __func__);\n\treturn ret;\n}\n\nstatic int mmc_test_rw_multiple_size(struct mmc_test_card *test,\n\t\t\t\t     struct mmc_test_multiple_rw *rw)\n{\n\tint ret = 0;\n\tint i;\n\tvoid *pre_req = test->card->host->ops->pre_req;\n\tvoid *post_req = test->card->host->ops->post_req;\n\n\tif (rw->do_nonblock_req &&\n\t    ((!pre_req && post_req) || (pre_req && !post_req))) {\n\t\tpr_info(\"error: only one of pre/post is defined\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0 ; i < rw->len && ret == 0; i++) {\n\t\tret = mmc_test_rw_multiple(test, rw, rw->bs[i], rw->size, 0);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int mmc_test_rw_multiple_sg_len(struct mmc_test_card *test,\n\t\t\t\t       struct mmc_test_multiple_rw *rw)\n{\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0 ; i < rw->len && ret == 0; i++) {\n\t\tret = mmc_test_rw_multiple(test, rw, 512 * 1024, rw->size,\n\t\t\t\t\t   rw->sg_len[i]);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\n \nstatic int mmc_test_profile_mult_write_blocking_perf(struct mmc_test_card *test)\n{\n\tunsigned int bs[] = {1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16,\n\t\t\t     1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 22};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.bs = bs,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(bs),\n\t\t.do_write = true,\n\t\t.do_nonblock_req = false,\n\t\t.prepare = MMC_TEST_PREP_ERASE,\n\t};\n\n\treturn mmc_test_rw_multiple_size(test, &test_data);\n};\n\n \nstatic int mmc_test_profile_mult_write_nonblock_perf(struct mmc_test_card *test)\n{\n\tunsigned int bs[] = {1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16,\n\t\t\t     1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 22};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.bs = bs,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(bs),\n\t\t.do_write = true,\n\t\t.do_nonblock_req = true,\n\t\t.prepare = MMC_TEST_PREP_ERASE,\n\t};\n\n\treturn mmc_test_rw_multiple_size(test, &test_data);\n}\n\n \nstatic int mmc_test_profile_mult_read_blocking_perf(struct mmc_test_card *test)\n{\n\tunsigned int bs[] = {1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16,\n\t\t\t     1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 22};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.bs = bs,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(bs),\n\t\t.do_write = false,\n\t\t.do_nonblock_req = false,\n\t\t.prepare = MMC_TEST_PREP_NONE,\n\t};\n\n\treturn mmc_test_rw_multiple_size(test, &test_data);\n}\n\n \nstatic int mmc_test_profile_mult_read_nonblock_perf(struct mmc_test_card *test)\n{\n\tunsigned int bs[] = {1 << 12, 1 << 13, 1 << 14, 1 << 15, 1 << 16,\n\t\t\t     1 << 17, 1 << 18, 1 << 19, 1 << 20, 1 << 22};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.bs = bs,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(bs),\n\t\t.do_write = false,\n\t\t.do_nonblock_req = true,\n\t\t.prepare = MMC_TEST_PREP_NONE,\n\t};\n\n\treturn mmc_test_rw_multiple_size(test, &test_data);\n}\n\n \nstatic int mmc_test_profile_sglen_wr_blocking_perf(struct mmc_test_card *test)\n{\n\tunsigned int sg_len[] = {1, 1 << 3, 1 << 4, 1 << 5, 1 << 6,\n\t\t\t\t 1 << 7, 1 << 8, 1 << 9};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.sg_len = sg_len,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(sg_len),\n\t\t.do_write = true,\n\t\t.do_nonblock_req = false,\n\t\t.prepare = MMC_TEST_PREP_ERASE,\n\t};\n\n\treturn mmc_test_rw_multiple_sg_len(test, &test_data);\n};\n\n \nstatic int mmc_test_profile_sglen_wr_nonblock_perf(struct mmc_test_card *test)\n{\n\tunsigned int sg_len[] = {1, 1 << 3, 1 << 4, 1 << 5, 1 << 6,\n\t\t\t\t 1 << 7, 1 << 8, 1 << 9};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.sg_len = sg_len,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(sg_len),\n\t\t.do_write = true,\n\t\t.do_nonblock_req = true,\n\t\t.prepare = MMC_TEST_PREP_ERASE,\n\t};\n\n\treturn mmc_test_rw_multiple_sg_len(test, &test_data);\n}\n\n \nstatic int mmc_test_profile_sglen_r_blocking_perf(struct mmc_test_card *test)\n{\n\tunsigned int sg_len[] = {1, 1 << 3, 1 << 4, 1 << 5, 1 << 6,\n\t\t\t\t 1 << 7, 1 << 8, 1 << 9};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.sg_len = sg_len,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(sg_len),\n\t\t.do_write = false,\n\t\t.do_nonblock_req = false,\n\t\t.prepare = MMC_TEST_PREP_NONE,\n\t};\n\n\treturn mmc_test_rw_multiple_sg_len(test, &test_data);\n}\n\n \nstatic int mmc_test_profile_sglen_r_nonblock_perf(struct mmc_test_card *test)\n{\n\tunsigned int sg_len[] = {1, 1 << 3, 1 << 4, 1 << 5, 1 << 6,\n\t\t\t\t 1 << 7, 1 << 8, 1 << 9};\n\tstruct mmc_test_multiple_rw test_data = {\n\t\t.sg_len = sg_len,\n\t\t.size = TEST_AREA_MAX_SIZE,\n\t\t.len = ARRAY_SIZE(sg_len),\n\t\t.do_write = false,\n\t\t.do_nonblock_req = true,\n\t\t.prepare = MMC_TEST_PREP_NONE,\n\t};\n\n\treturn mmc_test_rw_multiple_sg_len(test, &test_data);\n}\n\n \nstatic int mmc_test_reset(struct mmc_test_card *test)\n{\n\tstruct mmc_card *card = test->card;\n\tint err;\n\n\terr = mmc_hw_reset(card);\n\tif (!err) {\n\t\t \n\t\tif (card->ext_csd.cmdq_en)\n\t\t\tmmc_cmdq_disable(card);\n\t\treturn RESULT_OK;\n\t} else if (err == -EOPNOTSUPP) {\n\t\treturn RESULT_UNSUP_HOST;\n\t}\n\n\treturn RESULT_FAIL;\n}\n\nstatic int mmc_test_send_status(struct mmc_test_card *test,\n\t\t\t\tstruct mmc_command *cmd)\n{\n\tmemset(cmd, 0, sizeof(*cmd));\n\n\tcmd->opcode = MMC_SEND_STATUS;\n\tif (!mmc_host_is_spi(test->card->host))\n\t\tcmd->arg = test->card->rca << 16;\n\tcmd->flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(test->card->host, cmd, 0);\n}\n\nstatic int mmc_test_ongoing_transfer(struct mmc_test_card *test,\n\t\t\t\t     unsigned int dev_addr, int use_sbc,\n\t\t\t\t     int repeat_cmd, int write, int use_areq)\n{\n\tstruct mmc_test_req *rq = mmc_test_req_alloc();\n\tstruct mmc_host *host = test->card->host;\n\tstruct mmc_test_area *t = &test->area;\n\tstruct mmc_request *mrq;\n\tunsigned long timeout;\n\tbool expired = false;\n\tint ret = 0, cmd_ret;\n\tu32 status = 0;\n\tint count = 0;\n\n\tif (!rq)\n\t\treturn -ENOMEM;\n\n\tmrq = &rq->mrq;\n\tif (use_sbc)\n\t\tmrq->sbc = &rq->sbc;\n\tmrq->cap_cmd_during_tfr = true;\n\n\tmmc_test_prepare_mrq(test, mrq, t->sg, t->sg_len, dev_addr, t->blocks,\n\t\t\t     512, write);\n\n\tif (use_sbc && t->blocks > 1 && !mrq->sbc) {\n\t\tret =  mmc_host_cmd23(host) ?\n\t\t       RESULT_UNSUP_CARD :\n\t\t       RESULT_UNSUP_HOST;\n\t\tgoto out_free;\n\t}\n\n\t \n\tif (use_areq) {\n\t\tret = mmc_test_start_areq(test, mrq, NULL);\n\t\tif (ret)\n\t\t\tgoto out_free;\n\t} else {\n\t\tmmc_wait_for_req(host, mrq);\n\t}\n\n\ttimeout = jiffies + msecs_to_jiffies(3000);\n\tdo {\n\t\tcount += 1;\n\n\t\t \n\t\tcmd_ret = mmc_test_send_status(test, &rq->status);\n\t\tif (cmd_ret)\n\t\t\tbreak;\n\n\t\tstatus = rq->status.resp[0];\n\t\tif (status & R1_ERROR) {\n\t\t\tcmd_ret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (mmc_is_req_done(host, mrq))\n\t\t\tbreak;\n\n\t\texpired = time_after(jiffies, timeout);\n\t\tif (expired) {\n\t\t\tpr_info(\"%s: timeout waiting for Tran state status %#x\\n\",\n\t\t\t\tmmc_hostname(host), status);\n\t\t\tcmd_ret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t} while (repeat_cmd && R1_CURRENT_STATE(status) != R1_STATE_TRAN);\n\n\t \n\tif (use_areq) {\n\t\tret = mmc_test_start_areq(test, NULL, mrq);\n\t} else {\n\t\tmmc_wait_for_req_done(test->card->host, mrq);\n\t}\n\n\t \n\tif (mrq->data->stop && (mrq->data->error || !mrq->sbc)) {\n\t\tif (ret)\n\t\t\tmmc_wait_for_cmd(host, mrq->data->stop, 0);\n\t\telse\n\t\t\tret = mmc_wait_for_cmd(host, mrq->data->stop, 0);\n\t}\n\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (cmd_ret) {\n\t\tpr_info(\"%s: Send Status failed: status %#x, error %d\\n\",\n\t\t\tmmc_hostname(test->card->host), status, cmd_ret);\n\t}\n\n\tret = mmc_test_check_result(test, mrq);\n\tif (ret)\n\t\tgoto out_free;\n\n\tret = mmc_test_wait_busy(test);\n\tif (ret)\n\t\tgoto out_free;\n\n\tif (repeat_cmd && (t->blocks + 1) << 9 > t->max_tfr)\n\t\tpr_info(\"%s: %d commands completed during transfer of %u blocks\\n\",\n\t\t\tmmc_hostname(test->card->host), count, t->blocks);\n\n\tif (cmd_ret)\n\t\tret = cmd_ret;\nout_free:\n\tkfree(rq);\n\n\treturn ret;\n}\n\nstatic int __mmc_test_cmds_during_tfr(struct mmc_test_card *test,\n\t\t\t\t      unsigned long sz, int use_sbc, int write,\n\t\t\t\t      int use_areq)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tint ret;\n\n\tif (!(test->card->host->caps & MMC_CAP_CMD_DURING_TFR))\n\t\treturn RESULT_UNSUP_HOST;\n\n\tret = mmc_test_area_map(test, sz, 0, 0, use_areq);\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_test_ongoing_transfer(test, t->dev_addr, use_sbc, 0, write,\n\t\t\t\t\tuse_areq);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_test_ongoing_transfer(test, t->dev_addr, use_sbc, 1, write,\n\t\t\t\t\t use_areq);\n}\n\nstatic int mmc_test_cmds_during_tfr(struct mmc_test_card *test, int use_sbc,\n\t\t\t\t    int write, int use_areq)\n{\n\tstruct mmc_test_area *t = &test->area;\n\tunsigned long sz;\n\tint ret;\n\n\tfor (sz = 512; sz <= t->max_tfr; sz += 512) {\n\t\tret = __mmc_test_cmds_during_tfr(test, sz, use_sbc, write,\n\t\t\t\t\t\t use_areq);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}\n\n \nstatic int mmc_test_cmds_during_read(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 0, 0, 0);\n}\n\n \nstatic int mmc_test_cmds_during_write(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 0, 1, 0);\n}\n\n \nstatic int mmc_test_cmds_during_read_cmd23(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 1, 0, 0);\n}\n\n \nstatic int mmc_test_cmds_during_write_cmd23(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 1, 1, 0);\n}\n\n \nstatic int mmc_test_cmds_during_read_cmd23_nonblock(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 1, 0, 1);\n}\n\n \nstatic int mmc_test_cmds_during_write_cmd23_nonblock(struct mmc_test_card *test)\n{\n\treturn mmc_test_cmds_during_tfr(test, 1, 1, 1);\n}\n\nstatic const struct mmc_test_case mmc_test_cases[] = {\n\t{\n\t\t.name = \"Basic write (no data verification)\",\n\t\t.run = mmc_test_basic_write,\n\t},\n\n\t{\n\t\t.name = \"Basic read (no data verification)\",\n\t\t.run = mmc_test_basic_read,\n\t},\n\n\t{\n\t\t.name = \"Basic write (with data verification)\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_verify_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Basic read (with data verification)\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_verify_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Multi-block write\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_multi_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Multi-block read\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_multi_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Power of two block writes\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_pow2_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Power of two block reads\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_pow2_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Weird sized block writes\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_weird_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Weird sized block reads\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_weird_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Badly aligned write\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_align_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Badly aligned read\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_align_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Badly aligned multi-block write\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_align_multi_write,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Badly aligned multi-block read\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_align_multi_read,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Proper xfer_size at write (start failure)\",\n\t\t.run = mmc_test_xfersize_write,\n\t},\n\n\t{\n\t\t.name = \"Proper xfer_size at read (start failure)\",\n\t\t.run = mmc_test_xfersize_read,\n\t},\n\n\t{\n\t\t.name = \"Proper xfer_size at write (midway failure)\",\n\t\t.run = mmc_test_multi_xfersize_write,\n\t},\n\n\t{\n\t\t.name = \"Proper xfer_size at read (midway failure)\",\n\t\t.run = mmc_test_multi_xfersize_read,\n\t},\n\n#ifdef CONFIG_HIGHMEM\n\n\t{\n\t\t.name = \"Highmem write\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_write_high,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Highmem read\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_read_high,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Multi-block highmem write\",\n\t\t.prepare = mmc_test_prepare_write,\n\t\t.run = mmc_test_multi_write_high,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Multi-block highmem read\",\n\t\t.prepare = mmc_test_prepare_read,\n\t\t.run = mmc_test_multi_read_high,\n\t\t.cleanup = mmc_test_cleanup,\n\t},\n\n#else\n\n\t{\n\t\t.name = \"Highmem write\",\n\t\t.run = mmc_test_no_highmem,\n\t},\n\n\t{\n\t\t.name = \"Highmem read\",\n\t\t.run = mmc_test_no_highmem,\n\t},\n\n\t{\n\t\t.name = \"Multi-block highmem write\",\n\t\t.run = mmc_test_no_highmem,\n\t},\n\n\t{\n\t\t.name = \"Multi-block highmem read\",\n\t\t.run = mmc_test_no_highmem,\n\t},\n\n#endif  \n\n\t{\n\t\t.name = \"Best-case read performance\",\n\t\t.prepare = mmc_test_area_prepare_fill,\n\t\t.run = mmc_test_best_read_performance,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Best-case write performance\",\n\t\t.prepare = mmc_test_area_prepare_erase,\n\t\t.run = mmc_test_best_write_performance,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Best-case read performance into scattered pages\",\n\t\t.prepare = mmc_test_area_prepare_fill,\n\t\t.run = mmc_test_best_read_perf_max_scatter,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Best-case write performance from scattered pages\",\n\t\t.prepare = mmc_test_area_prepare_erase,\n\t\t.run = mmc_test_best_write_perf_max_scatter,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Single read performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare_fill,\n\t\t.run = mmc_test_profile_read_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Single write performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_write_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Single trim performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare_fill,\n\t\t.run = mmc_test_profile_trim_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Consecutive read performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare_fill,\n\t\t.run = mmc_test_profile_seq_read_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Consecutive write performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_seq_write_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Consecutive trim performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_seq_trim_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Random read performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_random_read_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Random write performance by transfer size\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_random_write_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Large sequential read into scattered pages\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_large_seq_read_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Large sequential write from scattered pages\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_large_seq_write_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Write performance with blocking req 4k to 4MB\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_mult_write_blocking_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Write performance with non-blocking req 4k to 4MB\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_mult_write_nonblock_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Read performance with blocking req 4k to 4MB\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_mult_read_blocking_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Read performance with non-blocking req 4k to 4MB\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_mult_read_nonblock_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Write performance blocking req 1 to 512 sg elems\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_sglen_wr_blocking_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Write performance non-blocking req 1 to 512 sg elems\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_sglen_wr_nonblock_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Read performance blocking req 1 to 512 sg elems\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_sglen_r_blocking_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Read performance non-blocking req 1 to 512 sg elems\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_profile_sglen_r_nonblock_perf,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Reset test\",\n\t\t.run = mmc_test_reset,\n\t},\n\n\t{\n\t\t.name = \"Commands during read - no Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_read,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Commands during write - no Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_write,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Commands during read - use Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_read_cmd23,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Commands during write - use Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_write_cmd23,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Commands during non-blocking read - use Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_read_cmd23_nonblock,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n\n\t{\n\t\t.name = \"Commands during non-blocking write - use Set Block Count (CMD23)\",\n\t\t.prepare = mmc_test_area_prepare,\n\t\t.run = mmc_test_cmds_during_write_cmd23_nonblock,\n\t\t.cleanup = mmc_test_area_cleanup,\n\t},\n};\n\nstatic DEFINE_MUTEX(mmc_test_lock);\n\nstatic LIST_HEAD(mmc_test_result);\n\nstatic void mmc_test_run(struct mmc_test_card *test, int testcase)\n{\n\tint i, ret;\n\n\tpr_info(\"%s: Starting tests of card %s...\\n\",\n\t\tmmc_hostname(test->card->host), mmc_card_id(test->card));\n\n\tmmc_claim_host(test->card->host);\n\n\tfor (i = 0; i < ARRAY_SIZE(mmc_test_cases); i++) {\n\t\tstruct mmc_test_general_result *gr;\n\n\t\tif (testcase && ((i + 1) != testcase))\n\t\t\tcontinue;\n\n\t\tpr_info(\"%s: Test case %d. %s...\\n\",\n\t\t\tmmc_hostname(test->card->host), i + 1,\n\t\t\tmmc_test_cases[i].name);\n\n\t\tif (mmc_test_cases[i].prepare) {\n\t\t\tret = mmc_test_cases[i].prepare(test);\n\t\t\tif (ret) {\n\t\t\t\tpr_info(\"%s: Result: Prepare stage failed! (%d)\\n\",\n\t\t\t\t\tmmc_hostname(test->card->host),\n\t\t\t\t\tret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tgr = kzalloc(sizeof(*gr), GFP_KERNEL);\n\t\tif (gr) {\n\t\t\tINIT_LIST_HEAD(&gr->tr_lst);\n\n\t\t\t \n\t\t\tgr->card = test->card;\n\t\t\tgr->testcase = i;\n\n\t\t\t \n\t\t\tlist_add_tail(&gr->link, &mmc_test_result);\n\n\t\t\t \n\t\t\ttest->gr = gr;\n\t\t}\n\n\t\tret = mmc_test_cases[i].run(test);\n\t\tswitch (ret) {\n\t\tcase RESULT_OK:\n\t\t\tpr_info(\"%s: Result: OK\\n\",\n\t\t\t\tmmc_hostname(test->card->host));\n\t\t\tbreak;\n\t\tcase RESULT_FAIL:\n\t\t\tpr_info(\"%s: Result: FAILED\\n\",\n\t\t\t\tmmc_hostname(test->card->host));\n\t\t\tbreak;\n\t\tcase RESULT_UNSUP_HOST:\n\t\t\tpr_info(\"%s: Result: UNSUPPORTED (by host)\\n\",\n\t\t\t\tmmc_hostname(test->card->host));\n\t\t\tbreak;\n\t\tcase RESULT_UNSUP_CARD:\n\t\t\tpr_info(\"%s: Result: UNSUPPORTED (by card)\\n\",\n\t\t\t\tmmc_hostname(test->card->host));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_info(\"%s: Result: ERROR (%d)\\n\",\n\t\t\t\tmmc_hostname(test->card->host), ret);\n\t\t}\n\n\t\t \n\t\tif (gr)\n\t\t\tgr->result = ret;\n\n\t\tif (mmc_test_cases[i].cleanup) {\n\t\t\tret = mmc_test_cases[i].cleanup(test);\n\t\t\tif (ret) {\n\t\t\t\tpr_info(\"%s: Warning: Cleanup stage failed! (%d)\\n\",\n\t\t\t\t\tmmc_hostname(test->card->host),\n\t\t\t\t\tret);\n\t\t\t}\n\t\t}\n\t}\n\n\tmmc_release_host(test->card->host);\n\n\tpr_info(\"%s: Tests completed.\\n\",\n\t\tmmc_hostname(test->card->host));\n}\n\nstatic void mmc_test_free_result(struct mmc_card *card)\n{\n\tstruct mmc_test_general_result *gr, *grs;\n\n\tmutex_lock(&mmc_test_lock);\n\n\tlist_for_each_entry_safe(gr, grs, &mmc_test_result, link) {\n\t\tstruct mmc_test_transfer_result *tr, *trs;\n\n\t\tif (card && gr->card != card)\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry_safe(tr, trs, &gr->tr_lst, link) {\n\t\t\tlist_del(&tr->link);\n\t\t\tkfree(tr);\n\t\t}\n\n\t\tlist_del(&gr->link);\n\t\tkfree(gr);\n\t}\n\n\tmutex_unlock(&mmc_test_lock);\n}\n\nstatic LIST_HEAD(mmc_test_file_test);\n\nstatic int mtf_test_show(struct seq_file *sf, void *data)\n{\n\tstruct mmc_card *card = sf->private;\n\tstruct mmc_test_general_result *gr;\n\n\tmutex_lock(&mmc_test_lock);\n\n\tlist_for_each_entry(gr, &mmc_test_result, link) {\n\t\tstruct mmc_test_transfer_result *tr;\n\n\t\tif (gr->card != card)\n\t\t\tcontinue;\n\n\t\tseq_printf(sf, \"Test %d: %d\\n\", gr->testcase + 1, gr->result);\n\n\t\tlist_for_each_entry(tr, &gr->tr_lst, link) {\n\t\t\tseq_printf(sf, \"%u %d %llu.%09u %u %u.%02u\\n\",\n\t\t\t\ttr->count, tr->sectors,\n\t\t\t\t(u64)tr->ts.tv_sec, (u32)tr->ts.tv_nsec,\n\t\t\t\ttr->rate, tr->iops / 100, tr->iops % 100);\n\t\t}\n\t}\n\n\tmutex_unlock(&mmc_test_lock);\n\n\treturn 0;\n}\n\nstatic int mtf_test_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mtf_test_show, inode->i_private);\n}\n\nstatic ssize_t mtf_test_write(struct file *file, const char __user *buf,\n\tsize_t count, loff_t *pos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct mmc_card *card = sf->private;\n\tstruct mmc_test_card *test;\n\tlong testcase;\n\tint ret;\n\n\tret = kstrtol_from_user(buf, count, 10, &testcase);\n\tif (ret)\n\t\treturn ret;\n\n\ttest = kzalloc(sizeof(*test), GFP_KERNEL);\n\tif (!test)\n\t\treturn -ENOMEM;\n\n\t \n\tmmc_test_free_result(card);\n\n\ttest->card = card;\n\n\ttest->buffer = kzalloc(BUFFER_SIZE, GFP_KERNEL);\n#ifdef CONFIG_HIGHMEM\n\ttest->highmem = alloc_pages(GFP_KERNEL | __GFP_HIGHMEM, BUFFER_ORDER);\n#endif\n\n#ifdef CONFIG_HIGHMEM\n\tif (test->buffer && test->highmem) {\n#else\n\tif (test->buffer) {\n#endif\n\t\tmutex_lock(&mmc_test_lock);\n\t\tmmc_test_run(test, testcase);\n\t\tmutex_unlock(&mmc_test_lock);\n\t}\n\n#ifdef CONFIG_HIGHMEM\n\t__free_pages(test->highmem, BUFFER_ORDER);\n#endif\n\tkfree(test->buffer);\n\tkfree(test);\n\n\treturn count;\n}\n\nstatic const struct file_operations mmc_test_fops_test = {\n\t.open\t\t= mtf_test_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= mtf_test_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int mtf_testlist_show(struct seq_file *sf, void *data)\n{\n\tint i;\n\n\tmutex_lock(&mmc_test_lock);\n\n\tseq_puts(sf, \"0:\\tRun all tests\\n\");\n\tfor (i = 0; i < ARRAY_SIZE(mmc_test_cases); i++)\n\t\tseq_printf(sf, \"%d:\\t%s\\n\", i + 1, mmc_test_cases[i].name);\n\n\tmutex_unlock(&mmc_test_lock);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mtf_testlist);\n\nstatic void mmc_test_free_dbgfs_file(struct mmc_card *card)\n{\n\tstruct mmc_test_dbgfs_file *df, *dfs;\n\n\tmutex_lock(&mmc_test_lock);\n\n\tlist_for_each_entry_safe(df, dfs, &mmc_test_file_test, link) {\n\t\tif (card && df->card != card)\n\t\t\tcontinue;\n\t\tdebugfs_remove(df->file);\n\t\tlist_del(&df->link);\n\t\tkfree(df);\n\t}\n\n\tmutex_unlock(&mmc_test_lock);\n}\n\nstatic int __mmc_test_register_dbgfs_file(struct mmc_card *card,\n\tconst char *name, umode_t mode, const struct file_operations *fops)\n{\n\tstruct dentry *file = NULL;\n\tstruct mmc_test_dbgfs_file *df;\n\n\tif (card->debugfs_root)\n\t\tfile = debugfs_create_file(name, mode, card->debugfs_root,\n\t\t\t\t\t   card, fops);\n\n\tdf = kmalloc(sizeof(*df), GFP_KERNEL);\n\tif (!df) {\n\t\tdebugfs_remove(file);\n\t\treturn -ENOMEM;\n\t}\n\n\tdf->card = card;\n\tdf->file = file;\n\n\tlist_add(&df->link, &mmc_test_file_test);\n\treturn 0;\n}\n\nstatic int mmc_test_register_dbgfs_file(struct mmc_card *card)\n{\n\tint ret;\n\n\tmutex_lock(&mmc_test_lock);\n\n\tret = __mmc_test_register_dbgfs_file(card, \"test\", S_IWUSR | S_IRUGO,\n\t\t&mmc_test_fops_test);\n\tif (ret)\n\t\tgoto err;\n\n\tret = __mmc_test_register_dbgfs_file(card, \"testlist\", S_IRUGO,\n\t\t&mtf_testlist_fops);\n\tif (ret)\n\t\tgoto err;\n\nerr:\n\tmutex_unlock(&mmc_test_lock);\n\n\treturn ret;\n}\n\nstatic int mmc_test_probe(struct mmc_card *card)\n{\n\tint ret;\n\n\tif (!mmc_card_mmc(card) && !mmc_card_sd(card))\n\t\treturn -ENODEV;\n\n\tret = mmc_test_register_dbgfs_file(card);\n\tif (ret)\n\t\treturn ret;\n\n\tif (card->ext_csd.cmdq_en) {\n\t\tmmc_claim_host(card->host);\n\t\tret = mmc_cmdq_disable(card);\n\t\tmmc_release_host(card->host);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tdev_info(&card->dev, \"Card claimed for testing.\\n\");\n\n\treturn 0;\n}\n\nstatic void mmc_test_remove(struct mmc_card *card)\n{\n\tif (card->reenable_cmdq) {\n\t\tmmc_claim_host(card->host);\n\t\tmmc_cmdq_enable(card);\n\t\tmmc_release_host(card->host);\n\t}\n\tmmc_test_free_result(card);\n\tmmc_test_free_dbgfs_file(card);\n}\n\nstatic struct mmc_driver mmc_driver = {\n\t.drv\t\t= {\n\t\t.name\t= \"mmc_test\",\n\t},\n\t.probe\t\t= mmc_test_probe,\n\t.remove\t\t= mmc_test_remove,\n};\n\nstatic int __init mmc_test_init(void)\n{\n\treturn mmc_register_driver(&mmc_driver);\n}\n\nstatic void __exit mmc_test_exit(void)\n{\n\t \n\tmmc_test_free_result(NULL);\n\tmmc_test_free_dbgfs_file(NULL);\n\n\tmmc_unregister_driver(&mmc_driver);\n}\n\nmodule_init(mmc_test_init);\nmodule_exit(mmc_test_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"Multimedia Card (MMC) host test driver\");\nMODULE_AUTHOR(\"Pierre Ossman\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}