{
  "module_name": "sdio_ops.c",
  "hash_id": "d7ce8a1ce4f9e018a23c94a79e7c53798df87b2f14a1b7c756533aeacf95c553",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_ops.c",
  "human_readable_source": "\n \n\n#include <linux/scatterlist.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n\n#include \"core.h\"\n#include \"sdio_ops.h\"\n\nint mmc_send_io_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\n{\n\tstruct mmc_command cmd = {};\n\tint i, err = 0;\n\n\tcmd.opcode = SD_IO_SEND_OP_COND;\n\tcmd.arg = ocr;\n\tcmd.flags = MMC_RSP_SPI_R4 | MMC_RSP_R4 | MMC_CMD_BCR;\n\n\tfor (i = 100; i; i--) {\n\t\terr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ocr == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mmc_host_is_spi(host)) {\n\t\t\t \n\t\t\tif (cmd.resp[1] & MMC_CARD_BUSY)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (cmd.resp[0] & MMC_CARD_BUSY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\terr = -ETIMEDOUT;\n\n\t\tmmc_delay(10);\n\t}\n\n\tif (rocr)\n\t\t*rocr = cmd.resp[mmc_host_is_spi(host) ? 1 : 0];\n\n\treturn err;\n}\n\nstatic int mmc_io_rw_direct_host(struct mmc_host *host, int write, unsigned fn,\n\tunsigned addr, u8 in, u8 *out)\n{\n\tstruct mmc_command cmd = {};\n\tint err;\n\n\tif (fn > 7)\n\t\treturn -EINVAL;\n\n\t \n\tif (addr & ~0x1FFFF)\n\t\treturn -EINVAL;\n\n\tcmd.opcode = SD_IO_RW_DIRECT;\n\tcmd.arg = write ? 0x80000000 : 0x00000000;\n\tcmd.arg |= fn << 28;\n\tcmd.arg |= (write && out) ? 0x08000000 : 0x00000000;\n\tcmd.arg |= addr << 9;\n\tcmd.arg |= in;\n\tcmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_AC;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (mmc_host_is_spi(host)) {\n\t\t \n\t} else {\n\t\tif (cmd.resp[0] & R5_ERROR)\n\t\t\treturn -EIO;\n\t\tif (cmd.resp[0] & R5_FUNCTION_NUMBER)\n\t\t\treturn -EINVAL;\n\t\tif (cmd.resp[0] & R5_OUT_OF_RANGE)\n\t\t\treturn -ERANGE;\n\t}\n\n\tif (out) {\n\t\tif (mmc_host_is_spi(host))\n\t\t\t*out = (cmd.resp[0] >> 8) & 0xFF;\n\t\telse\n\t\t\t*out = cmd.resp[0] & 0xFF;\n\t}\n\n\treturn 0;\n}\n\nint mmc_io_rw_direct(struct mmc_card *card, int write, unsigned fn,\n\tunsigned addr, u8 in, u8 *out)\n{\n\treturn mmc_io_rw_direct_host(card->host, write, fn, addr, in, out);\n}\n\nint mmc_io_rw_extended(struct mmc_card *card, int write, unsigned fn,\n\tunsigned addr, int incr_addr, u8 *buf, unsigned blocks, unsigned blksz)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg, *sg_ptr;\n\tstruct sg_table sgtable;\n\tunsigned int nents, left_size, i;\n\tunsigned int seg_size = card->host->max_seg_size;\n\tint err;\n\n\tWARN_ON(blksz == 0);\n\n\t \n\tif (addr & ~0x1FFFF)\n\t\treturn -EINVAL;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = SD_IO_RW_EXTENDED;\n\tcmd.arg = write ? 0x80000000 : 0x00000000;\n\tcmd.arg |= fn << 28;\n\tcmd.arg |= incr_addr ? 0x04000000 : 0x00000000;\n\tcmd.arg |= addr << 9;\n\tif (blocks == 0)\n\t\tcmd.arg |= (blksz == 512) ? 0 : blksz;\t \n\telse\n\t\tcmd.arg |= 0x08000000 | blocks;\t\t \n\tcmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;\n\n\tdata.blksz = blksz;\n\t \n\tdata.blocks = blocks ? blocks : 1;\n\tdata.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;\n\n\tleft_size = data.blksz * data.blocks;\n\tnents = DIV_ROUND_UP(left_size, seg_size);\n\tif (nents > 1) {\n\t\tif (sg_alloc_table(&sgtable, nents, GFP_KERNEL))\n\t\t\treturn -ENOMEM;\n\n\t\tdata.sg = sgtable.sgl;\n\t\tdata.sg_len = nents;\n\n\t\tfor_each_sg(data.sg, sg_ptr, data.sg_len, i) {\n\t\t\tsg_set_buf(sg_ptr, buf + i * seg_size,\n\t\t\t\t   min(seg_size, left_size));\n\t\t\tleft_size -= seg_size;\n\t\t}\n\t} else {\n\t\tdata.sg = &sg;\n\t\tdata.sg_len = 1;\n\n\t\tsg_init_one(&sg, buf, left_size);\n\t}\n\n\tmmc_set_data_timeout(&data, card);\n\n\tmmc_pre_req(card->host, &mrq);\n\n\tmmc_wait_for_req(card->host, &mrq);\n\n\tif (cmd.error)\n\t\terr = cmd.error;\n\telse if (data.error)\n\t\terr = data.error;\n\telse if (mmc_host_is_spi(card->host))\n\t\t \n\t\terr = 0;\n\telse if (cmd.resp[0] & R5_ERROR)\n\t\terr = -EIO;\n\telse if (cmd.resp[0] & R5_FUNCTION_NUMBER)\n\t\terr = -EINVAL;\n\telse if (cmd.resp[0] & R5_OUT_OF_RANGE)\n\t\terr = -ERANGE;\n\telse\n\t\terr = 0;\n\n\tmmc_post_req(card->host, &mrq, err);\n\n\tif (nents > 1)\n\t\tsg_free_table(&sgtable);\n\n\treturn err;\n}\n\nint sdio_reset(struct mmc_host *host)\n{\n\tint ret;\n\tu8 abort;\n\n\t \n\n\tret = mmc_io_rw_direct_host(host, 0, 0, SDIO_CCCR_ABORT, 0, &abort);\n\tif (ret)\n\t\tabort = 0x08;\n\telse\n\t\tabort |= 0x08;\n\n\treturn mmc_io_rw_direct_host(host, 1, 0, SDIO_CCCR_ABORT, abort, NULL);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}