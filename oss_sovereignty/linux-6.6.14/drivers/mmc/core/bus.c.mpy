{
  "module_name": "bus.c",
  "hash_id": "317798996a70292b70c9d91295d2adbb38470dd4ce2771e515f221d740ffdd73",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/bus.c",
  "human_readable_source": "\n \n\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"sdio_cis.h\"\n#include \"bus.h\"\n\n#define to_mmc_driver(d)\tcontainer_of(d, struct mmc_driver, drv)\n\nstatic ssize_t type_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\tswitch (card->type) {\n\tcase MMC_TYPE_MMC:\n\t\treturn sysfs_emit(buf, \"MMC\\n\");\n\tcase MMC_TYPE_SD:\n\t\treturn sysfs_emit(buf, \"SD\\n\");\n\tcase MMC_TYPE_SDIO:\n\t\treturn sysfs_emit(buf, \"SDIO\\n\");\n\tcase MMC_TYPE_SD_COMBO:\n\t\treturn sysfs_emit(buf, \"SDcombo\\n\");\n\tdefault:\n\t\treturn -EFAULT;\n\t}\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic struct attribute *mmc_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mmc_dev);\n\nstatic int\nmmc_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct mmc_card *card = mmc_dev_to_card(dev);\n\tconst char *type;\n\tunsigned int i;\n\tint retval = 0;\n\n\tswitch (card->type) {\n\tcase MMC_TYPE_MMC:\n\t\ttype = \"MMC\";\n\t\tbreak;\n\tcase MMC_TYPE_SD:\n\t\ttype = \"SD\";\n\t\tbreak;\n\tcase MMC_TYPE_SDIO:\n\t\ttype = \"SDIO\";\n\t\tbreak;\n\tcase MMC_TYPE_SD_COMBO:\n\t\ttype = \"SDcombo\";\n\t\tbreak;\n\tdefault:\n\t\ttype = NULL;\n\t}\n\n\tif (type) {\n\t\tretval = add_uevent_var(env, \"MMC_TYPE=%s\", type);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\tif (mmc_card_sdio(card) || mmc_card_sd_combo(card)) {\n\t\tretval = add_uevent_var(env, \"SDIO_ID=%04X:%04X\",\n\t\t\t\t\tcard->cis.vendor, card->cis.device);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = add_uevent_var(env, \"SDIO_REVISION=%u.%u\",\n\t\t\t\t\tcard->major_rev, card->minor_rev);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tfor (i = 0; i < card->num_info; i++) {\n\t\t\tretval = add_uevent_var(env, \"SDIO_INFO%u=%s\", i+1, card->info[i]);\n\t\t\tif (retval)\n\t\t\t\treturn retval;\n\t\t}\n\t}\n\n\t \n\tif (mmc_card_sdio(card))\n\t\treturn 0;\n\n\tretval = add_uevent_var(env, \"MMC_NAME=%s\", mmc_card_name(card));\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = add_uevent_var(env, \"MODALIAS=mmc:block\");\n\n\treturn retval;\n}\n\nstatic int mmc_bus_probe(struct device *dev)\n{\n\tstruct mmc_driver *drv = to_mmc_driver(dev->driver);\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\treturn drv->probe(card);\n}\n\nstatic void mmc_bus_remove(struct device *dev)\n{\n\tstruct mmc_driver *drv = to_mmc_driver(dev->driver);\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\tdrv->remove(card);\n}\n\nstatic void mmc_bus_shutdown(struct device *dev)\n{\n\tstruct mmc_driver *drv = to_mmc_driver(dev->driver);\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\tint ret;\n\n\tif (dev->driver && drv->shutdown)\n\t\tdrv->shutdown(card);\n\n\tif (host->bus_ops->shutdown) {\n\t\tret = host->bus_ops->shutdown(host);\n\t\tif (ret)\n\t\t\tpr_warn(\"%s: error %d during shutdown\\n\",\n\t\t\t\tmmc_hostname(host), ret);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mmc_bus_suspend(struct device *dev)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\tint ret;\n\n\tret = pm_generic_suspend(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = host->bus_ops->suspend(host);\n\tif (ret)\n\t\tpm_generic_resume(dev);\n\n\treturn ret;\n}\n\nstatic int mmc_bus_resume(struct device *dev)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\tint ret;\n\n\tret = host->bus_ops->resume(host);\n\tif (ret)\n\t\tpr_warn(\"%s: error %d during resume (card was removed?)\\n\",\n\t\t\tmmc_hostname(host), ret);\n\n\tret = pm_generic_resume(dev);\n\treturn ret;\n}\n#endif\n\n#ifdef CONFIG_PM\nstatic int mmc_runtime_suspend(struct device *dev)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\n\treturn host->bus_ops->runtime_suspend(host);\n}\n\nstatic int mmc_runtime_resume(struct device *dev)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\n\treturn host->bus_ops->runtime_resume(host);\n}\n#endif  \n\nstatic const struct dev_pm_ops mmc_bus_pm_ops = {\n\tSET_RUNTIME_PM_OPS(mmc_runtime_suspend, mmc_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(mmc_bus_suspend, mmc_bus_resume)\n};\n\nstatic struct bus_type mmc_bus_type = {\n\t.name\t\t= \"mmc\",\n\t.dev_groups\t= mmc_dev_groups,\n\t.uevent\t\t= mmc_bus_uevent,\n\t.probe\t\t= mmc_bus_probe,\n\t.remove\t\t= mmc_bus_remove,\n\t.shutdown\t= mmc_bus_shutdown,\n\t.pm\t\t= &mmc_bus_pm_ops,\n};\n\nint mmc_register_bus(void)\n{\n\treturn bus_register(&mmc_bus_type);\n}\n\nvoid mmc_unregister_bus(void)\n{\n\tbus_unregister(&mmc_bus_type);\n}\n\n \nint mmc_register_driver(struct mmc_driver *drv)\n{\n\tdrv->drv.bus = &mmc_bus_type;\n\treturn driver_register(&drv->drv);\n}\n\nEXPORT_SYMBOL(mmc_register_driver);\n\n \nvoid mmc_unregister_driver(struct mmc_driver *drv)\n{\n\tdrv->drv.bus = &mmc_bus_type;\n\tdriver_unregister(&drv->drv);\n}\n\nEXPORT_SYMBOL(mmc_unregister_driver);\n\nstatic void mmc_release_card(struct device *dev)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\tsdio_free_common_cis(card);\n\n\tkfree(card->info);\n\n\tkfree(card);\n}\n\n \nstruct mmc_card *mmc_alloc_card(struct mmc_host *host, struct device_type *type)\n{\n\tstruct mmc_card *card;\n\n\tcard = kzalloc(sizeof(struct mmc_card), GFP_KERNEL);\n\tif (!card)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcard->host = host;\n\n\tdevice_initialize(&card->dev);\n\n\tcard->dev.parent = mmc_classdev(host);\n\tcard->dev.bus = &mmc_bus_type;\n\tcard->dev.release = mmc_release_card;\n\tcard->dev.type = type;\n\n\treturn card;\n}\n\n \nint mmc_add_card(struct mmc_card *card)\n{\n\tint ret;\n\tconst char *type;\n\tconst char *uhs_bus_speed_mode = \"\";\n\tstatic const char *const uhs_speeds[] = {\n\t\t[UHS_SDR12_BUS_SPEED] = \"SDR12 \",\n\t\t[UHS_SDR25_BUS_SPEED] = \"SDR25 \",\n\t\t[UHS_SDR50_BUS_SPEED] = \"SDR50 \",\n\t\t[UHS_SDR104_BUS_SPEED] = \"SDR104 \",\n\t\t[UHS_DDR50_BUS_SPEED] = \"DDR50 \",\n\t};\n\n\n\tdev_set_name(&card->dev, \"%s:%04x\", mmc_hostname(card->host), card->rca);\n\tdev_set_removable(&card->dev,\n\t\t\t  mmc_card_is_removable(card->host) ?\n\t\t\t  DEVICE_REMOVABLE : DEVICE_FIXED);\n\n\tswitch (card->type) {\n\tcase MMC_TYPE_MMC:\n\t\ttype = \"MMC\";\n\t\tbreak;\n\tcase MMC_TYPE_SD:\n\t\ttype = \"SD\";\n\t\tif (mmc_card_blockaddr(card)) {\n\t\t\tif (mmc_card_ext_capacity(card))\n\t\t\t\ttype = \"SDXC\";\n\t\t\telse\n\t\t\t\ttype = \"SDHC\";\n\t\t}\n\t\tbreak;\n\tcase MMC_TYPE_SDIO:\n\t\ttype = \"SDIO\";\n\t\tbreak;\n\tcase MMC_TYPE_SD_COMBO:\n\t\ttype = \"SD-combo\";\n\t\tif (mmc_card_blockaddr(card))\n\t\t\ttype = \"SDHC-combo\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"?\";\n\t\tbreak;\n\t}\n\n\tif (mmc_card_uhs(card) &&\n\t\t(card->sd_bus_speed < ARRAY_SIZE(uhs_speeds)))\n\t\tuhs_bus_speed_mode = uhs_speeds[card->sd_bus_speed];\n\n\tif (mmc_host_is_spi(card->host)) {\n\t\tpr_info(\"%s: new %s%s%s card on SPI\\n\",\n\t\t\tmmc_hostname(card->host),\n\t\t\tmmc_card_hs(card) ? \"high speed \" : \"\",\n\t\t\tmmc_card_ddr52(card) ? \"DDR \" : \"\",\n\t\t\ttype);\n\t} else {\n\t\tpr_info(\"%s: new %s%s%s%s%s%s card at address %04x\\n\",\n\t\t\tmmc_hostname(card->host),\n\t\t\tmmc_card_uhs(card) ? \"ultra high speed \" :\n\t\t\t(mmc_card_hs(card) ? \"high speed \" : \"\"),\n\t\t\tmmc_card_hs400(card) ? \"HS400 \" :\n\t\t\t(mmc_card_hs200(card) ? \"HS200 \" : \"\"),\n\t\t\tmmc_card_hs400es(card) ? \"Enhanced strobe \" : \"\",\n\t\t\tmmc_card_ddr52(card) ? \"DDR \" : \"\",\n\t\t\tuhs_bus_speed_mode, type, card->rca);\n\t}\n\n\tmmc_add_card_debugfs(card);\n\tcard->dev.of_node = mmc_of_find_child_device(card->host, 0);\n\n\tdevice_enable_async_suspend(&card->dev);\n\n\tret = device_add(&card->dev);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc_card_set_present(card);\n\n\treturn 0;\n}\n\n \nvoid mmc_remove_card(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\n\tmmc_remove_card_debugfs(card);\n\n\tif (mmc_card_present(card)) {\n\t\tif (mmc_host_is_spi(card->host)) {\n\t\t\tpr_info(\"%s: SPI card removed\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t} else {\n\t\t\tpr_info(\"%s: card %04x removed\\n\",\n\t\t\t\tmmc_hostname(card->host), card->rca);\n\t\t}\n\t\tdevice_del(&card->dev);\n\t\tof_node_put(card->dev.of_node);\n\t}\n\n\tif (host->cqe_enabled) {\n\t\thost->cqe_ops->cqe_disable(host);\n\t\thost->cqe_enabled = false;\n\t}\n\n\tput_device(&card->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}