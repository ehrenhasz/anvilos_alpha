{
  "module_name": "queue.h",
  "hash_id": "db8b2c609c5bfd7d0675c41974399da3fc4248b60fdfa3db994c3e28b9e2cd5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/queue.h",
  "human_readable_source": " \n#ifndef MMC_QUEUE_H\n#define MMC_QUEUE_H\n\n#include <linux/types.h>\n#include <linux/blkdev.h>\n#include <linux/blk-mq.h>\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n\nenum mmc_issued {\n\tMMC_REQ_STARTED,\n\tMMC_REQ_BUSY,\n\tMMC_REQ_FAILED_TO_START,\n\tMMC_REQ_FINISHED,\n};\n\nenum mmc_issue_type {\n\tMMC_ISSUE_SYNC,\n\tMMC_ISSUE_DCMD,\n\tMMC_ISSUE_ASYNC,\n\tMMC_ISSUE_MAX,\n};\n\nstatic inline struct mmc_queue_req *req_to_mmc_queue_req(struct request *rq)\n{\n\treturn blk_mq_rq_to_pdu(rq);\n}\n\nstruct mmc_queue_req;\n\nstatic inline struct request *mmc_queue_req_to_req(struct mmc_queue_req *mqr)\n{\n\treturn blk_mq_rq_from_pdu(mqr);\n}\n\nstruct mmc_blk_data;\nstruct mmc_blk_ioc_data;\n\nstruct mmc_blk_request {\n\tstruct mmc_request\tmrq;\n\tstruct mmc_command\tsbc;\n\tstruct mmc_command\tcmd;\n\tstruct mmc_command\tstop;\n\tstruct mmc_data\t\tdata;\n};\n\n \nenum mmc_drv_op {\n\tMMC_DRV_OP_IOCTL,\n\tMMC_DRV_OP_IOCTL_RPMB,\n\tMMC_DRV_OP_BOOT_WP,\n\tMMC_DRV_OP_GET_CARD_STATUS,\n\tMMC_DRV_OP_GET_EXT_CSD,\n};\n\nstruct mmc_queue_req {\n\tstruct mmc_blk_request\tbrq;\n\tstruct scatterlist\t*sg;\n\tenum mmc_drv_op\t\tdrv_op;\n\tint\t\t\tdrv_op_result;\n\tvoid\t\t\t*drv_op_data;\n\tunsigned int\t\tioc_count;\n\tint\t\t\tretries;\n};\n\nstruct mmc_queue {\n\tstruct mmc_card\t\t*card;\n\tstruct mmc_ctx\t\tctx;\n\tstruct blk_mq_tag_set\ttag_set;\n\tstruct mmc_blk_data\t*blkdata;\n\tstruct request_queue\t*queue;\n\tspinlock_t\t\tlock;\n\tint\t\t\tin_flight[MMC_ISSUE_MAX];\n\tunsigned int\t\tcqe_busy;\n#define MMC_CQE_DCMD_BUSY\tBIT(0)\n\tbool\t\t\tbusy;\n\tbool\t\t\trecovery_needed;\n\tbool\t\t\tin_recovery;\n\tbool\t\t\trw_wait;\n\tbool\t\t\twaiting;\n\tstruct work_struct\trecovery_work;\n\twait_queue_head_t\twait;\n\tstruct request\t\t*recovery_req;\n\tstruct request\t\t*complete_req;\n\tstruct mutex\t\tcomplete_lock;\n\tstruct work_struct\tcomplete_work;\n};\n\nstruct gendisk *mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card);\nextern void mmc_cleanup_queue(struct mmc_queue *);\nextern void mmc_queue_suspend(struct mmc_queue *);\nextern void mmc_queue_resume(struct mmc_queue *);\nextern unsigned int mmc_queue_map_sg(struct mmc_queue *,\n\t\t\t\t     struct mmc_queue_req *);\n\nvoid mmc_cqe_check_busy(struct mmc_queue *mq);\nvoid mmc_cqe_recovery_notifier(struct mmc_request *mrq);\n\nenum mmc_issue_type mmc_issue_type(struct mmc_queue *mq, struct request *req);\n\nstatic inline int mmc_tot_in_flight(struct mmc_queue *mq)\n{\n\treturn mq->in_flight[MMC_ISSUE_SYNC] +\n\t       mq->in_flight[MMC_ISSUE_DCMD] +\n\t       mq->in_flight[MMC_ISSUE_ASYNC];\n}\n\nstatic inline int mmc_cqe_qcnt(struct mmc_queue *mq)\n{\n\treturn mq->in_flight[MMC_ISSUE_DCMD] +\n\t       mq->in_flight[MMC_ISSUE_ASYNC];\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}