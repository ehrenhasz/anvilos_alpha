{
  "module_name": "pwrseq_simple.c",
  "hash_id": "3e7891d965aee968d90f27b0feb88dfbbe86837a5978ae5df67699fb3cffaf29",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/pwrseq_simple.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/property.h>\n\n#include <linux/mmc/host.h>\n\n#include \"pwrseq.h\"\n\nstruct mmc_pwrseq_simple {\n\tstruct mmc_pwrseq pwrseq;\n\tbool clk_enabled;\n\tu32 post_power_on_delay_ms;\n\tu32 power_off_delay_us;\n\tstruct clk *ext_clk;\n\tstruct gpio_descs *reset_gpios;\n};\n\n#define to_pwrseq_simple(p) container_of(p, struct mmc_pwrseq_simple, pwrseq)\n\nstatic void mmc_pwrseq_simple_set_gpios_value(struct mmc_pwrseq_simple *pwrseq,\n\t\t\t\t\t      int value)\n{\n\tstruct gpio_descs *reset_gpios = pwrseq->reset_gpios;\n\n\tif (!IS_ERR(reset_gpios)) {\n\t\tunsigned long *values;\n\t\tint nvalues = reset_gpios->ndescs;\n\n\t\tvalues = bitmap_alloc(nvalues, GFP_KERNEL);\n\t\tif (!values)\n\t\t\treturn;\n\n\t\tif (value)\n\t\t\tbitmap_fill(values, nvalues);\n\t\telse\n\t\t\tbitmap_zero(values, nvalues);\n\n\t\tgpiod_set_array_value_cansleep(nvalues, reset_gpios->desc,\n\t\t\t\t\t       reset_gpios->info, values);\n\n\t\tbitmap_free(values);\n\t}\n}\n\nstatic void mmc_pwrseq_simple_pre_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_simple *pwrseq = to_pwrseq_simple(host->pwrseq);\n\n\tif (!IS_ERR(pwrseq->ext_clk) && !pwrseq->clk_enabled) {\n\t\tclk_prepare_enable(pwrseq->ext_clk);\n\t\tpwrseq->clk_enabled = true;\n\t}\n\n\tmmc_pwrseq_simple_set_gpios_value(pwrseq, 1);\n}\n\nstatic void mmc_pwrseq_simple_post_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_simple *pwrseq = to_pwrseq_simple(host->pwrseq);\n\n\tmmc_pwrseq_simple_set_gpios_value(pwrseq, 0);\n\n\tif (pwrseq->post_power_on_delay_ms)\n\t\tmsleep(pwrseq->post_power_on_delay_ms);\n}\n\nstatic void mmc_pwrseq_simple_power_off(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_simple *pwrseq = to_pwrseq_simple(host->pwrseq);\n\n\tmmc_pwrseq_simple_set_gpios_value(pwrseq, 1);\n\n\tif (pwrseq->power_off_delay_us)\n\t\tusleep_range(pwrseq->power_off_delay_us,\n\t\t\t2 * pwrseq->power_off_delay_us);\n\n\tif (!IS_ERR(pwrseq->ext_clk) && pwrseq->clk_enabled) {\n\t\tclk_disable_unprepare(pwrseq->ext_clk);\n\t\tpwrseq->clk_enabled = false;\n\t}\n}\n\nstatic const struct mmc_pwrseq_ops mmc_pwrseq_simple_ops = {\n\t.pre_power_on = mmc_pwrseq_simple_pre_power_on,\n\t.post_power_on = mmc_pwrseq_simple_post_power_on,\n\t.power_off = mmc_pwrseq_simple_power_off,\n};\n\nstatic const struct of_device_id mmc_pwrseq_simple_of_match[] = {\n\t{ .compatible = \"mmc-pwrseq-simple\",},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mmc_pwrseq_simple_of_match);\n\nstatic int mmc_pwrseq_simple_probe(struct platform_device *pdev)\n{\n\tstruct mmc_pwrseq_simple *pwrseq;\n\tstruct device *dev = &pdev->dev;\n\n\tpwrseq = devm_kzalloc(dev, sizeof(*pwrseq), GFP_KERNEL);\n\tif (!pwrseq)\n\t\treturn -ENOMEM;\n\n\tpwrseq->ext_clk = devm_clk_get(dev, \"ext_clock\");\n\tif (IS_ERR(pwrseq->ext_clk) && PTR_ERR(pwrseq->ext_clk) != -ENOENT)\n\t\treturn dev_err_probe(dev, PTR_ERR(pwrseq->ext_clk), \"external clock not ready\\n\");\n\n\tpwrseq->reset_gpios = devm_gpiod_get_array(dev, \"reset\",\n\t\t\t\t\t\t\tGPIOD_OUT_HIGH);\n\tif (IS_ERR(pwrseq->reset_gpios) &&\n\t    PTR_ERR(pwrseq->reset_gpios) != -ENOENT &&\n\t    PTR_ERR(pwrseq->reset_gpios) != -ENOSYS) {\n\t\treturn dev_err_probe(dev, PTR_ERR(pwrseq->reset_gpios), \"reset GPIOs not ready\\n\");\n\t}\n\n\tdevice_property_read_u32(dev, \"post-power-on-delay-ms\",\n\t\t\t\t &pwrseq->post_power_on_delay_ms);\n\tdevice_property_read_u32(dev, \"power-off-delay-us\",\n\t\t\t\t &pwrseq->power_off_delay_us);\n\n\tpwrseq->pwrseq.dev = dev;\n\tpwrseq->pwrseq.ops = &mmc_pwrseq_simple_ops;\n\tpwrseq->pwrseq.owner = THIS_MODULE;\n\tplatform_set_drvdata(pdev, pwrseq);\n\n\treturn mmc_pwrseq_register(&pwrseq->pwrseq);\n}\n\nstatic void mmc_pwrseq_simple_remove(struct platform_device *pdev)\n{\n\tstruct mmc_pwrseq_simple *pwrseq = platform_get_drvdata(pdev);\n\n\tmmc_pwrseq_unregister(&pwrseq->pwrseq);\n}\n\nstatic struct platform_driver mmc_pwrseq_simple_driver = {\n\t.probe = mmc_pwrseq_simple_probe,\n\t.remove_new = mmc_pwrseq_simple_remove,\n\t.driver = {\n\t\t.name = \"pwrseq_simple\",\n\t\t.of_match_table = mmc_pwrseq_simple_of_match,\n\t},\n};\n\nmodule_platform_driver(mmc_pwrseq_simple_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}