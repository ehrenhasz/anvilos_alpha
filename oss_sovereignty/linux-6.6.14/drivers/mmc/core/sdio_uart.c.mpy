{
  "module_name": "sdio_uart.c",
  "hash_id": "33222703a96280290034b1f9f80fc222aa3afaf2491c215df9cb9f16dd4ec0c6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_uart.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/circ_buf.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/kfifo.h>\n#include <linux/slab.h>\n\n#include <linux/mmc/core.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n\n\n#define UART_NR\t\t8\t \n\n\n#define FIFO_SIZE\tPAGE_SIZE\n#define WAKEUP_CHARS\t256\n\nstruct uart_icount {\n\t__u32\tcts;\n\t__u32\tdsr;\n\t__u32\trng;\n\t__u32\tdcd;\n\t__u32\trx;\n\t__u32\ttx;\n\t__u32\tframe;\n\t__u32\toverrun;\n\t__u32\tparity;\n\t__u32\tbrk;\n};\n\nstruct sdio_uart_port {\n\tstruct tty_port\t\tport;\n\tunsigned int\t\tindex;\n\tstruct sdio_func\t*func;\n\tstruct mutex\t\tfunc_lock;\n\tstruct task_struct\t*in_sdio_uart_irq;\n\tunsigned int\t\tregs_offset;\n\tstruct kfifo\t\txmit_fifo;\n\tspinlock_t\t\twrite_lock;\n\tstruct uart_icount\ticount;\n\tunsigned int\t\tuartclk;\n\tunsigned int\t\tmctrl;\n\tunsigned int\t\trx_mctrl;\n\tunsigned int\t\tread_status_mask;\n\tunsigned int\t\tignore_status_mask;\n\tunsigned char\t\tx_char;\n\tunsigned char           ier;\n\tunsigned char           lcr;\n};\n\nstatic struct sdio_uart_port *sdio_uart_table[UART_NR];\nstatic DEFINE_SPINLOCK(sdio_uart_table_lock);\n\nstatic int sdio_uart_add_port(struct sdio_uart_port *port)\n{\n\tint index, ret = -EBUSY;\n\n\tmutex_init(&port->func_lock);\n\tspin_lock_init(&port->write_lock);\n\tif (kfifo_alloc(&port->xmit_fifo, FIFO_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tspin_lock(&sdio_uart_table_lock);\n\tfor (index = 0; index < UART_NR; index++) {\n\t\tif (!sdio_uart_table[index]) {\n\t\t\tport->index = index;\n\t\t\tsdio_uart_table[index] = port;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&sdio_uart_table_lock);\n\n\treturn ret;\n}\n\nstatic struct sdio_uart_port *sdio_uart_port_get(unsigned index)\n{\n\tstruct sdio_uart_port *port;\n\n\tif (index >= UART_NR)\n\t\treturn NULL;\n\n\tspin_lock(&sdio_uart_table_lock);\n\tport = sdio_uart_table[index];\n\tif (port)\n\t\ttty_port_get(&port->port);\n\tspin_unlock(&sdio_uart_table_lock);\n\n\treturn port;\n}\n\nstatic void sdio_uart_port_put(struct sdio_uart_port *port)\n{\n\ttty_port_put(&port->port);\n}\n\nstatic void sdio_uart_port_remove(struct sdio_uart_port *port)\n{\n\tstruct sdio_func *func;\n\n\tspin_lock(&sdio_uart_table_lock);\n\tsdio_uart_table[port->index] = NULL;\n\tspin_unlock(&sdio_uart_table_lock);\n\n\t \n\tmutex_lock(&port->port.mutex);\n\tmutex_lock(&port->func_lock);\n\tfunc = port->func;\n\tsdio_claim_host(func);\n\tport->func = NULL;\n\tmutex_unlock(&port->func_lock);\n\t \n\ttty_port_tty_hangup(&port->port, false);\n\tmutex_unlock(&port->port.mutex);\n\tsdio_release_irq(func);\n\tsdio_disable_func(func);\n\tsdio_release_host(func);\n\n\tsdio_uart_port_put(port);\n}\n\nstatic int sdio_uart_claim_func(struct sdio_uart_port *port)\n{\n\tmutex_lock(&port->func_lock);\n\tif (unlikely(!port->func)) {\n\t\tmutex_unlock(&port->func_lock);\n\t\treturn -ENODEV;\n\t}\n\tif (likely(port->in_sdio_uart_irq != current))\n\t\tsdio_claim_host(port->func);\n\tmutex_unlock(&port->func_lock);\n\treturn 0;\n}\n\nstatic inline void sdio_uart_release_func(struct sdio_uart_port *port)\n{\n\tif (likely(port->in_sdio_uart_irq != current))\n\t\tsdio_release_host(port->func);\n}\n\nstatic inline unsigned int sdio_in(struct sdio_uart_port *port, int offset)\n{\n\tunsigned char c;\n\tc = sdio_readb(port->func, port->regs_offset + offset, NULL);\n\treturn c;\n}\n\nstatic inline void sdio_out(struct sdio_uart_port *port, int offset, int value)\n{\n\tsdio_writeb(port->func, value, port->regs_offset + offset, NULL);\n}\n\nstatic unsigned int sdio_uart_get_mctrl(struct sdio_uart_port *port)\n{\n\tunsigned char status;\n\tunsigned int ret;\n\n\t \n\tstatus = sdio_in(port, UART_MSR);\n\n\tret = 0;\n\tif (status & UART_MSR_DCD)\n\t\tret |= TIOCM_CAR;\n\tif (status & UART_MSR_RI)\n\t\tret |= TIOCM_RNG;\n\tif (status & UART_MSR_DSR)\n\t\tret |= TIOCM_DSR;\n\tif (status & UART_MSR_CTS)\n\t\tret |= TIOCM_CTS;\n\treturn ret;\n}\n\nstatic void sdio_uart_write_mctrl(struct sdio_uart_port *port,\n\t\t\t\t  unsigned int mctrl)\n{\n\tunsigned char mcr = 0;\n\n\tif (mctrl & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (mctrl & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (mctrl & TIOCM_OUT1)\n\t\tmcr |= UART_MCR_OUT1;\n\tif (mctrl & TIOCM_OUT2)\n\t\tmcr |= UART_MCR_OUT2;\n\tif (mctrl & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\tsdio_out(port, UART_MCR, mcr);\n}\n\nstatic inline void sdio_uart_update_mctrl(struct sdio_uart_port *port,\n\t\t\t\t\t  unsigned int set, unsigned int clear)\n{\n\tunsigned int old;\n\n\told = port->mctrl;\n\tport->mctrl = (old & ~clear) | set;\n\tif (old != port->mctrl)\n\t\tsdio_uart_write_mctrl(port, port->mctrl);\n}\n\n#define sdio_uart_set_mctrl(port, x)\tsdio_uart_update_mctrl(port, x, 0)\n#define sdio_uart_clear_mctrl(port, x)\tsdio_uart_update_mctrl(port, 0, x)\n\nstatic void sdio_uart_change_speed(struct sdio_uart_port *port,\n\t\t\t\t   struct ktermios *termios,\n\t\t\t\t   const struct ktermios *old)\n{\n\tunsigned char cval, fcr = 0;\n\tunsigned int baud, quot;\n\n\tcval = UART_LCR_WLEN(tty_get_char_size(termios->c_cflag));\n\n\tif (termios->c_cflag & CSTOPB)\n\t\tcval |= UART_LCR_STOP;\n\tif (termios->c_cflag & PARENB)\n\t\tcval |= UART_LCR_PARITY;\n\tif (!(termios->c_cflag & PARODD))\n\t\tcval |= UART_LCR_EPAR;\n\n\tfor (;;) {\n\t\tbaud = tty_termios_baud_rate(termios);\n\t\tif (baud == 0)\n\t\t\tbaud = 9600;   \n\t\tif (baud <= port->uartclk)\n\t\t\tbreak;\n\t\t \n\t\ttermios->c_cflag &= ~CBAUD;\n\t\tif (old) {\n\t\t\ttermios->c_cflag |= old->c_cflag & CBAUD;\n\t\t\told = NULL;\n\t\t} else\n\t\t\ttermios->c_cflag |= B9600;\n\t}\n\tquot = (2 * port->uartclk + baud) / (2 * baud);\n\n\tif (baud < 2400)\n\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_TRIGGER_1;\n\telse\n\t\tfcr = UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;\n\n\tport->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;\n\tif (termios->c_iflag & INPCK)\n\t\tport->read_status_mask |= UART_LSR_FE | UART_LSR_PE;\n\tif (termios->c_iflag & (BRKINT | PARMRK))\n\t\tport->read_status_mask |= UART_LSR_BI;\n\n\t \n\tport->ignore_status_mask = 0;\n\tif (termios->c_iflag & IGNPAR)\n\t\tport->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;\n\tif (termios->c_iflag & IGNBRK) {\n\t\tport->ignore_status_mask |= UART_LSR_BI;\n\t\t \n\t\tif (termios->c_iflag & IGNPAR)\n\t\t\tport->ignore_status_mask |= UART_LSR_OE;\n\t}\n\n\t \n\tif ((termios->c_cflag & CREAD) == 0)\n\t\tport->ignore_status_mask |= UART_LSR_DR;\n\n\t \n\tport->ier &= ~UART_IER_MSI;\n\tif ((termios->c_cflag & CRTSCTS) || !(termios->c_cflag & CLOCAL))\n\t\tport->ier |= UART_IER_MSI;\n\n\tport->lcr = cval;\n\n\tsdio_out(port, UART_IER, port->ier);\n\tsdio_out(port, UART_LCR, cval | UART_LCR_DLAB);\n\tsdio_out(port, UART_DLL, quot & 0xff);\n\tsdio_out(port, UART_DLM, quot >> 8);\n\tsdio_out(port, UART_LCR, cval);\n\tsdio_out(port, UART_FCR, fcr);\n\n\tsdio_uart_write_mctrl(port, port->mctrl);\n}\n\nstatic void sdio_uart_start_tx(struct sdio_uart_port *port)\n{\n\tif (!(port->ier & UART_IER_THRI)) {\n\t\tport->ier |= UART_IER_THRI;\n\t\tsdio_out(port, UART_IER, port->ier);\n\t}\n}\n\nstatic void sdio_uart_stop_tx(struct sdio_uart_port *port)\n{\n\tif (port->ier & UART_IER_THRI) {\n\t\tport->ier &= ~UART_IER_THRI;\n\t\tsdio_out(port, UART_IER, port->ier);\n\t}\n}\n\nstatic void sdio_uart_stop_rx(struct sdio_uart_port *port)\n{\n\tport->ier &= ~UART_IER_RLSI;\n\tport->read_status_mask &= ~UART_LSR_DR;\n\tsdio_out(port, UART_IER, port->ier);\n}\n\nstatic void sdio_uart_receive_chars(struct sdio_uart_port *port,\n\t\t\t\t    unsigned int *status)\n{\n\tunsigned int ch, flag;\n\tint max_count = 256;\n\n\tdo {\n\t\tch = sdio_in(port, UART_RX);\n\t\tflag = TTY_NORMAL;\n\t\tport->icount.rx++;\n\n\t\tif (unlikely(*status & (UART_LSR_BI | UART_LSR_PE |\n\t\t\t\t\tUART_LSR_FE | UART_LSR_OE))) {\n\t\t\t \n\t\t\tif (*status & UART_LSR_BI) {\n\t\t\t\t*status &= ~(UART_LSR_FE | UART_LSR_PE);\n\t\t\t\tport->icount.brk++;\n\t\t\t} else if (*status & UART_LSR_PE)\n\t\t\t\tport->icount.parity++;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tport->icount.frame++;\n\t\t\tif (*status & UART_LSR_OE)\n\t\t\t\tport->icount.overrun++;\n\n\t\t\t \n\t\t\t*status &= port->read_status_mask;\n\t\t\tif (*status & UART_LSR_BI)\n\t\t\t\tflag = TTY_BREAK;\n\t\t\telse if (*status & UART_LSR_PE)\n\t\t\t\tflag = TTY_PARITY;\n\t\t\telse if (*status & UART_LSR_FE)\n\t\t\t\tflag = TTY_FRAME;\n\t\t}\n\n\t\tif ((*status & port->ignore_status_mask & ~UART_LSR_OE) == 0)\n\t\t\ttty_insert_flip_char(&port->port, ch, flag);\n\n\t\t \n\t\tif (*status & ~port->ignore_status_mask & UART_LSR_OE)\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\n\t\t*status = sdio_in(port, UART_LSR);\n\t} while ((*status & UART_LSR_DR) && (max_count-- > 0));\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void sdio_uart_transmit_chars(struct sdio_uart_port *port)\n{\n\tstruct kfifo *xmit = &port->xmit_fifo;\n\tint count;\n\tstruct tty_struct *tty;\n\tu8 iobuf[16];\n\tint len;\n\n\tif (port->x_char) {\n\t\tsdio_out(port, UART_TX, port->x_char);\n\t\tport->icount.tx++;\n\t\tport->x_char = 0;\n\t\treturn;\n\t}\n\n\ttty = tty_port_tty_get(&port->port);\n\n\tif (tty == NULL || !kfifo_len(xmit) ||\n\t\t\t\ttty->flow.stopped || tty->hw_stopped) {\n\t\tsdio_uart_stop_tx(port);\n\t\ttty_kref_put(tty);\n\t\treturn;\n\t}\n\n\tlen = kfifo_out_locked(xmit, iobuf, 16, &port->write_lock);\n\tfor (count = 0; count < len; count++) {\n\t\tsdio_out(port, UART_TX, iobuf[count]);\n\t\tport->icount.tx++;\n\t}\n\n\tlen = kfifo_len(xmit);\n\tif (len < WAKEUP_CHARS) {\n\t\ttty_wakeup(tty);\n\t\tif (len == 0)\n\t\t\tsdio_uart_stop_tx(port);\n\t}\n\ttty_kref_put(tty);\n}\n\nstatic void sdio_uart_check_modem_status(struct sdio_uart_port *port)\n{\n\tint status;\n\tstruct tty_struct *tty;\n\n\tstatus = sdio_in(port, UART_MSR);\n\n\tif ((status & UART_MSR_ANY_DELTA) == 0)\n\t\treturn;\n\n\tif (status & UART_MSR_TERI)\n\t\tport->icount.rng++;\n\tif (status & UART_MSR_DDSR)\n\t\tport->icount.dsr++;\n\tif (status & UART_MSR_DDCD) {\n\t\tport->icount.dcd++;\n\t\t \n\t\tif (status & UART_MSR_DCD)\n\t\t\twake_up_interruptible(&port->port.open_wait);\n\t\telse {\n\t\t\t \n\t\t\ttty_port_tty_hangup(&port->port, false);\n\t\t}\n\t}\n\tif (status & UART_MSR_DCTS) {\n\t\tport->icount.cts++;\n\t\ttty = tty_port_tty_get(&port->port);\n\t\tif (tty && C_CRTSCTS(tty)) {\n\t\t\tint cts = (status & UART_MSR_CTS);\n\t\t\tif (tty->hw_stopped) {\n\t\t\t\tif (cts) {\n\t\t\t\t\ttty->hw_stopped = false;\n\t\t\t\t\tsdio_uart_start_tx(port);\n\t\t\t\t\ttty_wakeup(tty);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!cts) {\n\t\t\t\t\ttty->hw_stopped = true;\n\t\t\t\t\tsdio_uart_stop_tx(port);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttty_kref_put(tty);\n\t}\n}\n\n \nstatic void sdio_uart_irq(struct sdio_func *func)\n{\n\tstruct sdio_uart_port *port = sdio_get_drvdata(func);\n\tunsigned int iir, lsr;\n\n\t \n\tif (unlikely(port->in_sdio_uart_irq == current))\n\t\treturn;\n\n\tiir = sdio_in(port, UART_IIR);\n\tif (iir & UART_IIR_NO_INT)\n\t\treturn;\n\n\tport->in_sdio_uart_irq = current;\n\tlsr = sdio_in(port, UART_LSR);\n\tif (lsr & UART_LSR_DR)\n\t\tsdio_uart_receive_chars(port, &lsr);\n\tsdio_uart_check_modem_status(port);\n\tif (lsr & UART_LSR_THRE)\n\t\tsdio_uart_transmit_chars(port);\n\tport->in_sdio_uart_irq = NULL;\n}\n\nstatic bool uart_carrier_raised(struct tty_port *tport)\n{\n\tstruct sdio_uart_port *port =\n\t\t\tcontainer_of(tport, struct sdio_uart_port, port);\n\tunsigned int ret = sdio_uart_claim_func(port);\n\tif (ret)\t \n\t\treturn 1;\n\tret = sdio_uart_get_mctrl(port);\n\tsdio_uart_release_func(port);\n\n\treturn ret & TIOCM_CAR;\n}\n\n \n\nstatic void uart_dtr_rts(struct tty_port *tport, bool active)\n{\n\tstruct sdio_uart_port *port =\n\t\t\tcontainer_of(tport, struct sdio_uart_port, port);\n\tint ret = sdio_uart_claim_func(port);\n\tif (ret)\n\t\treturn;\n\tif (!active)\n\t\tsdio_uart_clear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\telse\n\t\tsdio_uart_set_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\tsdio_uart_release_func(port);\n}\n\n \n\nstatic int sdio_uart_activate(struct tty_port *tport, struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port =\n\t\t\tcontainer_of(tport, struct sdio_uart_port, port);\n\tint ret;\n\n\t \n\tset_bit(TTY_IO_ERROR, &tty->flags);\n\n\tkfifo_reset(&port->xmit_fifo);\n\n\tret = sdio_uart_claim_func(port);\n\tif (ret)\n\t\treturn ret;\n\tret = sdio_enable_func(port->func);\n\tif (ret)\n\t\tgoto err1;\n\tret = sdio_claim_irq(port->func, sdio_uart_irq);\n\tif (ret)\n\t\tgoto err2;\n\n\t \n\tsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);\n\tsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tsdio_out(port, UART_FCR, 0);\n\n\t \n\t(void) sdio_in(port, UART_LSR);\n\t(void) sdio_in(port, UART_RX);\n\t(void) sdio_in(port, UART_IIR);\n\t(void) sdio_in(port, UART_MSR);\n\n\t \n\tsdio_out(port, UART_LCR, UART_LCR_WLEN8);\n\n\tport->ier = UART_IER_RLSI|UART_IER_RDI|UART_IER_RTOIE|UART_IER_UUE;\n\tport->mctrl = TIOCM_OUT2;\n\n\tsdio_uart_change_speed(port, &tty->termios, NULL);\n\n\tif (C_BAUD(tty))\n\t\tsdio_uart_set_mctrl(port, TIOCM_RTS | TIOCM_DTR);\n\n\tif (C_CRTSCTS(tty))\n\t\tif (!(sdio_uart_get_mctrl(port) & TIOCM_CTS))\n\t\t\ttty->hw_stopped = true;\n\n\tclear_bit(TTY_IO_ERROR, &tty->flags);\n\n\t \n\tsdio_uart_irq(port->func);\n\n\tsdio_uart_release_func(port);\n\treturn 0;\n\nerr2:\n\tsdio_disable_func(port->func);\nerr1:\n\tsdio_uart_release_func(port);\n\treturn ret;\n}\n\n \n\nstatic void sdio_uart_shutdown(struct tty_port *tport)\n{\n\tstruct sdio_uart_port *port =\n\t\t\tcontainer_of(tport, struct sdio_uart_port, port);\n\tint ret;\n\n\tret = sdio_uart_claim_func(port);\n\tif (ret)\n\t\treturn;\n\n\tsdio_uart_stop_rx(port);\n\n\t \n\tsdio_release_irq(port->func);\n\tport->ier = 0;\n\tsdio_out(port, UART_IER, 0);\n\n\tsdio_uart_clear_mctrl(port, TIOCM_OUT2);\n\n\t \n\tport->lcr &= ~UART_LCR_SBC;\n\tsdio_out(port, UART_LCR, port->lcr);\n\tsdio_out(port, UART_FCR, UART_FCR_ENABLE_FIFO |\n\t\t\t\t UART_FCR_CLEAR_RCVR |\n\t\t\t\t UART_FCR_CLEAR_XMIT);\n\tsdio_out(port, UART_FCR, 0);\n\n\tsdio_disable_func(port->func);\n\n\tsdio_uart_release_func(port);\n}\n\nstatic void sdio_uart_port_destroy(struct tty_port *tport)\n{\n\tstruct sdio_uart_port *port =\n\t\tcontainer_of(tport, struct sdio_uart_port, port);\n\tkfifo_free(&port->xmit_fifo);\n\tkfree(port);\n}\n\n \n\nstatic int sdio_uart_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tint idx = tty->index;\n\tstruct sdio_uart_port *port = sdio_uart_port_get(idx);\n\tint ret = tty_standard_install(driver, tty);\n\n\tif (ret == 0)\n\t\t \n\t\ttty->driver_data = port;\n\telse\n\t\tsdio_uart_port_put(port);\n\treturn ret;\n}\n\n \n\nstatic void sdio_uart_cleanup(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\ttty->driver_data = NULL;\t \n\tsdio_uart_port_put(port);\n}\n\n \n\nstatic int sdio_uart_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\treturn tty_port_open(&port->port, tty, filp);\n}\n\nstatic void sdio_uart_close(struct tty_struct *tty, struct file * filp)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\ttty_port_close(&port->port, tty, filp);\n}\n\nstatic void sdio_uart_hangup(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\ttty_port_hangup(&port->port);\n}\n\nstatic ssize_t sdio_uart_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t      size_t count)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\tint ret;\n\n\tif (!port->func)\n\t\treturn -ENODEV;\n\n\tret = kfifo_in_locked(&port->xmit_fifo, buf, count, &port->write_lock);\n\tif (!(port->ier & UART_IER_THRI)) {\n\t\tint err = sdio_uart_claim_func(port);\n\t\tif (!err) {\n\t\t\tsdio_uart_start_tx(port);\n\t\t\tsdio_uart_irq(port->func);\n\t\t\tsdio_uart_release_func(port);\n\t\t} else\n\t\t\tret = err;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int sdio_uart_write_room(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\treturn FIFO_SIZE - kfifo_len(&port->xmit_fifo);\n}\n\nstatic unsigned int sdio_uart_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\treturn kfifo_len(&port->xmit_fifo);\n}\n\nstatic void sdio_uart_send_xchar(struct tty_struct *tty, char ch)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\n\tport->x_char = ch;\n\tif (ch && !(port->ier & UART_IER_THRI)) {\n\t\tif (sdio_uart_claim_func(port) != 0)\n\t\t\treturn;\n\t\tsdio_uart_start_tx(port);\n\t\tsdio_uart_irq(port->func);\n\t\tsdio_uart_release_func(port);\n\t}\n}\n\nstatic void sdio_uart_throttle(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\n\tif (!I_IXOFF(tty) && !C_CRTSCTS(tty))\n\t\treturn;\n\n\tif (sdio_uart_claim_func(port) != 0)\n\t\treturn;\n\n\tif (I_IXOFF(tty)) {\n\t\tport->x_char = STOP_CHAR(tty);\n\t\tsdio_uart_start_tx(port);\n\t}\n\n\tif (C_CRTSCTS(tty))\n\t\tsdio_uart_clear_mctrl(port, TIOCM_RTS);\n\n\tsdio_uart_irq(port->func);\n\tsdio_uart_release_func(port);\n}\n\nstatic void sdio_uart_unthrottle(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\n\tif (!I_IXOFF(tty) && !C_CRTSCTS(tty))\n\t\treturn;\n\n\tif (sdio_uart_claim_func(port) != 0)\n\t\treturn;\n\n\tif (I_IXOFF(tty)) {\n\t\tif (port->x_char) {\n\t\t\tport->x_char = 0;\n\t\t} else {\n\t\t\tport->x_char = START_CHAR(tty);\n\t\t\tsdio_uart_start_tx(port);\n\t\t}\n\t}\n\n\tif (C_CRTSCTS(tty))\n\t\tsdio_uart_set_mctrl(port, TIOCM_RTS);\n\n\tsdio_uart_irq(port->func);\n\tsdio_uart_release_func(port);\n}\n\nstatic void sdio_uart_set_termios(struct tty_struct *tty,\n\t\t\t\t  const struct ktermios *old_termios)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\tunsigned int cflag = tty->termios.c_cflag;\n\n\tif (sdio_uart_claim_func(port) != 0)\n\t\treturn;\n\n\tsdio_uart_change_speed(port, &tty->termios, old_termios);\n\n\t \n\tif ((old_termios->c_cflag & CBAUD) && !(cflag & CBAUD))\n\t\tsdio_uart_clear_mctrl(port, TIOCM_RTS | TIOCM_DTR);\n\n\t \n\tif (!(old_termios->c_cflag & CBAUD) && (cflag & CBAUD)) {\n\t\tunsigned int mask = TIOCM_DTR;\n\t\tif (!(cflag & CRTSCTS) || !tty_throttled(tty))\n\t\t\tmask |= TIOCM_RTS;\n\t\tsdio_uart_set_mctrl(port, mask);\n\t}\n\n\t \n\tif ((old_termios->c_cflag & CRTSCTS) && !(cflag & CRTSCTS)) {\n\t\ttty->hw_stopped = false;\n\t\tsdio_uart_start_tx(port);\n\t}\n\n\t \n\tif (!(old_termios->c_cflag & CRTSCTS) && (cflag & CRTSCTS)) {\n\t\tif (!(sdio_uart_get_mctrl(port) & TIOCM_CTS)) {\n\t\t\ttty->hw_stopped = true;\n\t\t\tsdio_uart_stop_tx(port);\n\t\t}\n\t}\n\n\tsdio_uart_release_func(port);\n}\n\nstatic int sdio_uart_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\tint result;\n\n\tresult = sdio_uart_claim_func(port);\n\tif (result != 0)\n\t\treturn result;\n\n\tif (break_state == -1)\n\t\tport->lcr |= UART_LCR_SBC;\n\telse\n\t\tport->lcr &= ~UART_LCR_SBC;\n\tsdio_out(port, UART_LCR, port->lcr);\n\n\tsdio_uart_release_func(port);\n\treturn 0;\n}\n\nstatic int sdio_uart_tiocmget(struct tty_struct *tty)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\tint result;\n\n\tresult = sdio_uart_claim_func(port);\n\tif (!result) {\n\t\tresult = port->mctrl | sdio_uart_get_mctrl(port);\n\t\tsdio_uart_release_func(port);\n\t}\n\n\treturn result;\n}\n\nstatic int sdio_uart_tiocmset(struct tty_struct *tty,\n\t\t\t      unsigned int set, unsigned int clear)\n{\n\tstruct sdio_uart_port *port = tty->driver_data;\n\tint result;\n\n\tresult = sdio_uart_claim_func(port);\n\tif (!result) {\n\t\tsdio_uart_update_mctrl(port, set, clear);\n\t\tsdio_uart_release_func(port);\n\t}\n\n\treturn result;\n}\n\nstatic int sdio_uart_proc_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tseq_printf(m, \"serinfo:1.0 driver%s%s revision:%s\\n\",\n\t\t       \"\", \"\", \"\");\n\tfor (i = 0; i < UART_NR; i++) {\n\t\tstruct sdio_uart_port *port = sdio_uart_port_get(i);\n\t\tif (port) {\n\t\t\tseq_printf(m, \"%d: uart:SDIO\", i);\n\t\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\t\tseq_printf(m, \" tx:%d rx:%d\",\n\t\t\t\t\t      port->icount.tx, port->icount.rx);\n\t\t\t\tif (port->icount.frame)\n\t\t\t\t\tseq_printf(m, \" fe:%d\",\n\t\t\t\t\t\t      port->icount.frame);\n\t\t\t\tif (port->icount.parity)\n\t\t\t\t\tseq_printf(m, \" pe:%d\",\n\t\t\t\t\t\t      port->icount.parity);\n\t\t\t\tif (port->icount.brk)\n\t\t\t\t\tseq_printf(m, \" brk:%d\",\n\t\t\t\t\t\t      port->icount.brk);\n\t\t\t\tif (port->icount.overrun)\n\t\t\t\t\tseq_printf(m, \" oe:%d\",\n\t\t\t\t\t\t      port->icount.overrun);\n\t\t\t\tif (port->icount.cts)\n\t\t\t\t\tseq_printf(m, \" cts:%d\",\n\t\t\t\t\t\t      port->icount.cts);\n\t\t\t\tif (port->icount.dsr)\n\t\t\t\t\tseq_printf(m, \" dsr:%d\",\n\t\t\t\t\t\t      port->icount.dsr);\n\t\t\t\tif (port->icount.rng)\n\t\t\t\t\tseq_printf(m, \" rng:%d\",\n\t\t\t\t\t\t      port->icount.rng);\n\t\t\t\tif (port->icount.dcd)\n\t\t\t\t\tseq_printf(m, \" dcd:%d\",\n\t\t\t\t\t\t      port->icount.dcd);\n\t\t\t}\n\t\t\tsdio_uart_port_put(port);\n\t\t\tseq_putc(m, '\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const struct tty_port_operations sdio_uart_port_ops = {\n\t.dtr_rts = uart_dtr_rts,\n\t.carrier_raised = uart_carrier_raised,\n\t.shutdown = sdio_uart_shutdown,\n\t.activate = sdio_uart_activate,\n\t.destruct = sdio_uart_port_destroy,\n};\n\nstatic const struct tty_operations sdio_uart_ops = {\n\t.open\t\t\t= sdio_uart_open,\n\t.close\t\t\t= sdio_uart_close,\n\t.write\t\t\t= sdio_uart_write,\n\t.write_room\t\t= sdio_uart_write_room,\n\t.chars_in_buffer\t= sdio_uart_chars_in_buffer,\n\t.send_xchar\t\t= sdio_uart_send_xchar,\n\t.throttle\t\t= sdio_uart_throttle,\n\t.unthrottle\t\t= sdio_uart_unthrottle,\n\t.set_termios\t\t= sdio_uart_set_termios,\n\t.hangup\t\t\t= sdio_uart_hangup,\n\t.break_ctl\t\t= sdio_uart_break_ctl,\n\t.tiocmget\t\t= sdio_uart_tiocmget,\n\t.tiocmset\t\t= sdio_uart_tiocmset,\n\t.install\t\t= sdio_uart_install,\n\t.cleanup\t\t= sdio_uart_cleanup,\n\t.proc_show\t\t= sdio_uart_proc_show,\n};\n\nstatic struct tty_driver *sdio_uart_tty_driver;\n\nstatic int sdio_uart_probe(struct sdio_func *func,\n\t\t\t   const struct sdio_device_id *id)\n{\n\tstruct sdio_uart_port *port;\n\tint ret;\n\n\tport = kzalloc(sizeof(struct sdio_uart_port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tif (func->class == SDIO_CLASS_UART) {\n\t\tpr_warn(\"%s: need info on UART class basic setup\\n\",\n\t\t\tsdio_func_id(func));\n\t\tkfree(port);\n\t\treturn -ENOSYS;\n\t} else if (func->class == SDIO_CLASS_GPS) {\n\t\t \n\t\tstruct sdio_func_tuple *tpl;\n\t\tfor (tpl = func->tuples; tpl; tpl = tpl->next) {\n\t\t\tif (tpl->code != 0x91)\n\t\t\t\tcontinue;\n\t\t\tif (tpl->size < 10)\n\t\t\t\tcontinue;\n\t\t\tif (tpl->data[1] == 0)   \n\t\t\t\tbreak;\n\t\t}\n\t\tif (!tpl) {\n\t\t\tpr_warn(\"%s: can't find tuple 0x91 subtuple 0 (SUBTPL_SIOREG) for GPS class\\n\",\n\t\t\t\tsdio_func_id(func));\n\t\t\tkfree(port);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpr_debug(\"%s: Register ID = 0x%02x, Exp ID = 0x%02x\\n\",\n\t\t       sdio_func_id(func), tpl->data[2], tpl->data[3]);\n\t\tport->regs_offset = (tpl->data[4] << 0) |\n\t\t\t\t    (tpl->data[5] << 8) |\n\t\t\t\t    (tpl->data[6] << 16);\n\t\tpr_debug(\"%s: regs offset = 0x%x\\n\",\n\t\t       sdio_func_id(func), port->regs_offset);\n\t\tport->uartclk = tpl->data[7] * 115200;\n\t\tif (port->uartclk == 0)\n\t\t\tport->uartclk = 115200;\n\t\tpr_debug(\"%s: clk %d baudcode %u 4800-div %u\\n\",\n\t\t       sdio_func_id(func), port->uartclk,\n\t\t       tpl->data[7], tpl->data[8] | (tpl->data[9] << 8));\n\t} else {\n\t\tkfree(port);\n\t\treturn -EINVAL;\n\t}\n\n\tport->func = func;\n\tsdio_set_drvdata(func, port);\n\ttty_port_init(&port->port);\n\tport->port.ops = &sdio_uart_port_ops;\n\n\tret = sdio_uart_add_port(port);\n\tif (ret) {\n\t\tkfree(port);\n\t} else {\n\t\tstruct device *dev;\n\t\tdev = tty_port_register_device(&port->port,\n\t\t\t\tsdio_uart_tty_driver, port->index, &func->dev);\n\t\tif (IS_ERR(dev)) {\n\t\t\tsdio_uart_port_remove(port);\n\t\t\tret = PTR_ERR(dev);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void sdio_uart_remove(struct sdio_func *func)\n{\n\tstruct sdio_uart_port *port = sdio_get_drvdata(func);\n\n\ttty_unregister_device(sdio_uart_tty_driver, port->index);\n\tsdio_uart_port_remove(port);\n}\n\nstatic const struct sdio_device_id sdio_uart_ids[] = {\n\t{ SDIO_DEVICE_CLASS(SDIO_CLASS_UART)\t\t},\n\t{ SDIO_DEVICE_CLASS(SDIO_CLASS_GPS)\t\t},\n\t{  \t\t\t\t},\n};\n\nMODULE_DEVICE_TABLE(sdio, sdio_uart_ids);\n\nstatic struct sdio_driver sdio_uart_driver = {\n\t.probe\t\t= sdio_uart_probe,\n\t.remove\t\t= sdio_uart_remove,\n\t.name\t\t= \"sdio_uart\",\n\t.id_table\t= sdio_uart_ids,\n};\n\nstatic int __init sdio_uart_init(void)\n{\n\tint ret;\n\tstruct tty_driver *tty_drv;\n\n\tsdio_uart_tty_driver = tty_drv = tty_alloc_driver(UART_NR,\n\t\t\tTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(tty_drv))\n\t\treturn PTR_ERR(tty_drv);\n\n\ttty_drv->driver_name = \"sdio_uart\";\n\ttty_drv->name =   \"ttySDIO\";\n\ttty_drv->major = 0;   \n\ttty_drv->minor_start = 0;\n\ttty_drv->type = TTY_DRIVER_TYPE_SERIAL;\n\ttty_drv->subtype = SERIAL_TYPE_NORMAL;\n\ttty_drv->init_termios = tty_std_termios;\n\ttty_drv->init_termios.c_cflag = B4800 | CS8 | CREAD | HUPCL | CLOCAL;\n\ttty_drv->init_termios.c_ispeed = 4800;\n\ttty_drv->init_termios.c_ospeed = 4800;\n\ttty_set_operations(tty_drv, &sdio_uart_ops);\n\n\tret = tty_register_driver(tty_drv);\n\tif (ret)\n\t\tgoto err1;\n\n\tret = sdio_register_driver(&sdio_uart_driver);\n\tif (ret)\n\t\tgoto err2;\n\n\treturn 0;\n\nerr2:\n\ttty_unregister_driver(tty_drv);\nerr1:\n\ttty_driver_kref_put(tty_drv);\n\treturn ret;\n}\n\nstatic void __exit sdio_uart_exit(void)\n{\n\tsdio_unregister_driver(&sdio_uart_driver);\n\ttty_unregister_driver(sdio_uart_tty_driver);\n\ttty_driver_kref_put(sdio_uart_tty_driver);\n}\n\nmodule_init(sdio_uart_init);\nmodule_exit(sdio_uart_exit);\n\nMODULE_AUTHOR(\"Nicolas Pitre\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}