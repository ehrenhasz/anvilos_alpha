{
  "module_name": "pwrseq.c",
  "hash_id": "b0c027a922b96cf5e2514a341c96ab18aa3fa83fb6b2ae5377f77b74df26ca75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/pwrseq.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <linux/module.h>\n#include <linux/of.h>\n\n#include <linux/mmc/host.h>\n\n#include \"pwrseq.h\"\n\nstatic DEFINE_MUTEX(pwrseq_list_mutex);\nstatic LIST_HEAD(pwrseq_list);\n\nint mmc_pwrseq_alloc(struct mmc_host *host)\n{\n\tstruct device_node *np;\n\tstruct mmc_pwrseq *p;\n\n\tnp = of_parse_phandle(host->parent->of_node, \"mmc-pwrseq\", 0);\n\tif (!np)\n\t\treturn 0;\n\n\tmutex_lock(&pwrseq_list_mutex);\n\tlist_for_each_entry(p, &pwrseq_list, pwrseq_node) {\n\t\tif (device_match_of_node(p->dev, np)) {\n\t\t\tif (!try_module_get(p->owner))\n\t\t\t\tdev_err(host->parent,\n\t\t\t\t\t\"increasing module refcount failed\\n\");\n\t\t\telse\n\t\t\t\thost->pwrseq = p;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tof_node_put(np);\n\tmutex_unlock(&pwrseq_list_mutex);\n\n\tif (!host->pwrseq)\n\t\treturn -EPROBE_DEFER;\n\n\tdev_info(host->parent, \"allocated mmc-pwrseq\\n\");\n\n\treturn 0;\n}\n\nvoid mmc_pwrseq_pre_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq *pwrseq = host->pwrseq;\n\n\tif (pwrseq && pwrseq->ops->pre_power_on)\n\t\tpwrseq->ops->pre_power_on(host);\n}\n\nvoid mmc_pwrseq_post_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq *pwrseq = host->pwrseq;\n\n\tif (pwrseq && pwrseq->ops->post_power_on)\n\t\tpwrseq->ops->post_power_on(host);\n}\n\nvoid mmc_pwrseq_power_off(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq *pwrseq = host->pwrseq;\n\n\tif (pwrseq && pwrseq->ops->power_off)\n\t\tpwrseq->ops->power_off(host);\n}\n\nvoid mmc_pwrseq_reset(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq *pwrseq = host->pwrseq;\n\n\tif (pwrseq && pwrseq->ops->reset)\n\t\tpwrseq->ops->reset(host);\n}\n\nvoid mmc_pwrseq_free(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq *pwrseq = host->pwrseq;\n\n\tif (pwrseq) {\n\t\tmodule_put(pwrseq->owner);\n\t\thost->pwrseq = NULL;\n\t}\n}\n\nint mmc_pwrseq_register(struct mmc_pwrseq *pwrseq)\n{\n\tif (!pwrseq || !pwrseq->ops || !pwrseq->dev)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&pwrseq_list_mutex);\n\tlist_add(&pwrseq->pwrseq_node, &pwrseq_list);\n\tmutex_unlock(&pwrseq_list_mutex);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmc_pwrseq_register);\n\nvoid mmc_pwrseq_unregister(struct mmc_pwrseq *pwrseq)\n{\n\tif (pwrseq) {\n\t\tmutex_lock(&pwrseq_list_mutex);\n\t\tlist_del(&pwrseq->pwrseq_node);\n\t\tmutex_unlock(&pwrseq_list_mutex);\n\t}\n}\nEXPORT_SYMBOL_GPL(mmc_pwrseq_unregister);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}