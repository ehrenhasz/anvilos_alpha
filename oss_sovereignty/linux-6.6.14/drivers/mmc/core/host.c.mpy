{
  "module_name": "host.c",
  "hash_id": "4c9673be1fbc43f7af1daaa8c0c25dadd97cfde15c47b82b9d01dab84e6ec8c2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/host.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/idr.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/pagemap.h>\n#include <linux/pm_wakeup.h>\n#include <linux/export.h>\n#include <linux/leds.h>\n#include <linux/slab.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/slot-gpio.h>\n\n#include \"core.h\"\n#include \"crypto.h\"\n#include \"host.h\"\n#include \"slot-gpio.h\"\n#include \"pwrseq.h\"\n#include \"sdio_ops.h\"\n\n#define cls_dev_to_mmc_host(d)\tcontainer_of(d, struct mmc_host, class_dev)\n\nstatic DEFINE_IDA(mmc_host_ida);\n\n#ifdef CONFIG_PM_SLEEP\nstatic int mmc_host_class_prepare(struct device *dev)\n{\n\tstruct mmc_host *host = cls_dev_to_mmc_host(dev);\n\n\t \n\tif (!host->bus_ops)\n\t\treturn 0;\n\n\t \n\tif (host->bus_ops->pre_suspend)\n\t\treturn host->bus_ops->pre_suspend(host);\n\n\treturn 0;\n}\n\nstatic void mmc_host_class_complete(struct device *dev)\n{\n\tstruct mmc_host *host = cls_dev_to_mmc_host(dev);\n\n\t_mmc_detect_change(host, 0, false);\n}\n\nstatic const struct dev_pm_ops mmc_host_class_dev_pm_ops = {\n\t.prepare = mmc_host_class_prepare,\n\t.complete = mmc_host_class_complete,\n};\n\n#define MMC_HOST_CLASS_DEV_PM_OPS (&mmc_host_class_dev_pm_ops)\n#else\n#define MMC_HOST_CLASS_DEV_PM_OPS NULL\n#endif\n\nstatic void mmc_host_classdev_release(struct device *dev)\n{\n\tstruct mmc_host *host = cls_dev_to_mmc_host(dev);\n\twakeup_source_unregister(host->ws);\n\tif (of_alias_get_id(host->parent->of_node, \"mmc\") < 0)\n\t\tida_simple_remove(&mmc_host_ida, host->index);\n\tkfree(host);\n}\n\nstatic int mmc_host_classdev_shutdown(struct device *dev)\n{\n\tstruct mmc_host *host = cls_dev_to_mmc_host(dev);\n\n\t__mmc_stop_host(host);\n\treturn 0;\n}\n\nstatic struct class mmc_host_class = {\n\t.name\t\t= \"mmc_host\",\n\t.dev_release\t= mmc_host_classdev_release,\n\t.shutdown_pre\t= mmc_host_classdev_shutdown,\n\t.pm\t\t= MMC_HOST_CLASS_DEV_PM_OPS,\n};\n\nint mmc_register_host_class(void)\n{\n\treturn class_register(&mmc_host_class);\n}\n\nvoid mmc_unregister_host_class(void)\n{\n\tclass_unregister(&mmc_host_class);\n}\n\n \nvoid mmc_retune_enable(struct mmc_host *host)\n{\n\thost->can_retune = 1;\n\tif (host->retune_period)\n\t\tmod_timer(&host->retune_timer,\n\t\t\t  jiffies + host->retune_period * HZ);\n}\n\n \nvoid mmc_retune_pause(struct mmc_host *host)\n{\n\tif (!host->retune_paused) {\n\t\thost->retune_paused = 1;\n\t\tmmc_retune_needed(host);\n\t\tmmc_retune_hold(host);\n\t}\n}\nEXPORT_SYMBOL(mmc_retune_pause);\n\nvoid mmc_retune_unpause(struct mmc_host *host)\n{\n\tif (host->retune_paused) {\n\t\thost->retune_paused = 0;\n\t\tmmc_retune_release(host);\n\t}\n}\nEXPORT_SYMBOL(mmc_retune_unpause);\n\n \nvoid mmc_retune_disable(struct mmc_host *host)\n{\n\tmmc_retune_unpause(host);\n\thost->can_retune = 0;\n\tdel_timer_sync(&host->retune_timer);\n\tmmc_retune_clear(host);\n}\n\nvoid mmc_retune_timer_stop(struct mmc_host *host)\n{\n\tdel_timer_sync(&host->retune_timer);\n}\nEXPORT_SYMBOL(mmc_retune_timer_stop);\n\nvoid mmc_retune_hold(struct mmc_host *host)\n{\n\tif (!host->hold_retune)\n\t\thost->retune_now = 1;\n\thost->hold_retune += 1;\n}\n\nvoid mmc_retune_release(struct mmc_host *host)\n{\n\tif (host->hold_retune)\n\t\thost->hold_retune -= 1;\n\telse\n\t\tWARN_ON(1);\n}\nEXPORT_SYMBOL(mmc_retune_release);\n\nint mmc_retune(struct mmc_host *host)\n{\n\tbool return_to_hs400 = false;\n\tint err;\n\n\tif (host->retune_now)\n\t\thost->retune_now = 0;\n\telse\n\t\treturn 0;\n\n\tif (!host->need_retune || host->doing_retune || !host->card)\n\t\treturn 0;\n\n\thost->need_retune = 0;\n\n\thost->doing_retune = 1;\n\n\tif (host->ios.timing == MMC_TIMING_MMC_HS400) {\n\t\terr = mmc_hs400_to_hs200(host->card);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\treturn_to_hs400 = true;\n\t}\n\n\terr = mmc_execute_tuning(host->card);\n\tif (err)\n\t\tgoto out;\n\n\tif (return_to_hs400)\n\t\terr = mmc_hs200_to_hs400(host->card);\nout:\n\thost->doing_retune = 0;\n\n\treturn err;\n}\n\nstatic void mmc_retune_timer(struct timer_list *t)\n{\n\tstruct mmc_host *host = from_timer(host, t, retune_timer);\n\n\tmmc_retune_needed(host);\n}\n\nstatic void mmc_of_parse_timing_phase(struct device *dev, const char *prop,\n\t\t\t\t      struct mmc_clk_phase *phase)\n{\n\tint degrees[2] = {0};\n\tint rc;\n\n\trc = device_property_read_u32_array(dev, prop, degrees, 2);\n\tphase->valid = !rc;\n\tif (phase->valid) {\n\t\tphase->in_deg = degrees[0];\n\t\tphase->out_deg = degrees[1];\n\t}\n}\n\nvoid\nmmc_of_parse_clk_phase(struct mmc_host *host, struct mmc_clk_phase_map *map)\n{\n\tstruct device *dev = host->parent;\n\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-legacy\",\n\t\t\t\t  &map->phase[MMC_TIMING_LEGACY]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-mmc-hs\",\n\t\t\t\t  &map->phase[MMC_TIMING_MMC_HS]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-sd-hs\",\n\t\t\t\t  &map->phase[MMC_TIMING_SD_HS]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-uhs-sdr12\",\n\t\t\t\t  &map->phase[MMC_TIMING_UHS_SDR12]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-uhs-sdr25\",\n\t\t\t\t  &map->phase[MMC_TIMING_UHS_SDR25]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-uhs-sdr50\",\n\t\t\t\t  &map->phase[MMC_TIMING_UHS_SDR50]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-uhs-sdr104\",\n\t\t\t\t  &map->phase[MMC_TIMING_UHS_SDR104]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-uhs-ddr50\",\n\t\t\t\t  &map->phase[MMC_TIMING_UHS_DDR50]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-mmc-ddr52\",\n\t\t\t\t  &map->phase[MMC_TIMING_MMC_DDR52]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-mmc-hs200\",\n\t\t\t\t  &map->phase[MMC_TIMING_MMC_HS200]);\n\tmmc_of_parse_timing_phase(dev, \"clk-phase-mmc-hs400\",\n\t\t\t\t  &map->phase[MMC_TIMING_MMC_HS400]);\n}\nEXPORT_SYMBOL(mmc_of_parse_clk_phase);\n\n \nint mmc_of_parse(struct mmc_host *host)\n{\n\tstruct device *dev = host->parent;\n\tu32 bus_width, drv_type, cd_debounce_delay_ms;\n\tint ret;\n\n\tif (!dev || !dev_fwnode(dev))\n\t\treturn 0;\n\n\t \n\tif (device_property_read_u32(dev, \"bus-width\", &bus_width) < 0) {\n\t\tdev_dbg(host->parent,\n\t\t\t\"\\\"bus-width\\\" property is missing, assuming 1 bit.\\n\");\n\t\tbus_width = 1;\n\t}\n\n\tswitch (bus_width) {\n\tcase 8:\n\t\thost->caps |= MMC_CAP_8_BIT_DATA;\n\t\tfallthrough;\t \n\tcase 4:\n\t\thost->caps |= MMC_CAP_4_BIT_DATA;\n\t\tbreak;\n\tcase 1:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(host->parent,\n\t\t\t\"Invalid \\\"bus-width\\\" value %u!\\n\", bus_width);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdevice_property_read_u32(dev, \"max-frequency\", &host->f_max);\n\n\t \n\n\t \n\n\tif (device_property_read_bool(dev, \"non-removable\")) {\n\t\thost->caps |= MMC_CAP_NONREMOVABLE;\n\t} else {\n\t\tif (device_property_read_bool(dev, \"cd-inverted\"))\n\t\t\thost->caps2 |= MMC_CAP2_CD_ACTIVE_HIGH;\n\n\t\tif (device_property_read_u32(dev, \"cd-debounce-delay-ms\",\n\t\t\t\t\t     &cd_debounce_delay_ms))\n\t\t\tcd_debounce_delay_ms = 200;\n\n\t\tif (device_property_read_bool(dev, \"broken-cd\"))\n\t\t\thost->caps |= MMC_CAP_NEEDS_POLL;\n\n\t\tret = mmc_gpiod_request_cd(host, \"cd\", 0, false,\n\t\t\t\t\t   cd_debounce_delay_ms * 1000);\n\t\tif (!ret)\n\t\t\tdev_info(host->parent, \"Got CD GPIO\\n\");\n\t\telse if (ret != -ENOENT && ret != -ENOSYS)\n\t\t\treturn ret;\n\t}\n\n\t \n\n\tif (device_property_read_bool(dev, \"wp-inverted\"))\n\t\thost->caps2 |= MMC_CAP2_RO_ACTIVE_HIGH;\n\n\tret = mmc_gpiod_request_ro(host, \"wp\", 0, 0);\n\tif (!ret)\n\t\tdev_info(host->parent, \"Got WP GPIO\\n\");\n\telse if (ret != -ENOENT && ret != -ENOSYS)\n\t\treturn ret;\n\n\tif (device_property_read_bool(dev, \"disable-wp\"))\n\t\thost->caps2 |= MMC_CAP2_NO_WRITE_PROTECT;\n\n\tif (device_property_read_bool(dev, \"cap-sd-highspeed\"))\n\t\thost->caps |= MMC_CAP_SD_HIGHSPEED;\n\tif (device_property_read_bool(dev, \"cap-mmc-highspeed\"))\n\t\thost->caps |= MMC_CAP_MMC_HIGHSPEED;\n\tif (device_property_read_bool(dev, \"sd-uhs-sdr12\"))\n\t\thost->caps |= MMC_CAP_UHS_SDR12;\n\tif (device_property_read_bool(dev, \"sd-uhs-sdr25\"))\n\t\thost->caps |= MMC_CAP_UHS_SDR25;\n\tif (device_property_read_bool(dev, \"sd-uhs-sdr50\"))\n\t\thost->caps |= MMC_CAP_UHS_SDR50;\n\tif (device_property_read_bool(dev, \"sd-uhs-sdr104\"))\n\t\thost->caps |= MMC_CAP_UHS_SDR104;\n\tif (device_property_read_bool(dev, \"sd-uhs-ddr50\"))\n\t\thost->caps |= MMC_CAP_UHS_DDR50;\n\tif (device_property_read_bool(dev, \"cap-power-off-card\"))\n\t\thost->caps |= MMC_CAP_POWER_OFF_CARD;\n\tif (device_property_read_bool(dev, \"cap-mmc-hw-reset\"))\n\t\thost->caps |= MMC_CAP_HW_RESET;\n\tif (device_property_read_bool(dev, \"cap-sdio-irq\"))\n\t\thost->caps |= MMC_CAP_SDIO_IRQ;\n\tif (device_property_read_bool(dev, \"full-pwr-cycle\"))\n\t\thost->caps2 |= MMC_CAP2_FULL_PWR_CYCLE;\n\tif (device_property_read_bool(dev, \"full-pwr-cycle-in-suspend\"))\n\t\thost->caps2 |= MMC_CAP2_FULL_PWR_CYCLE_IN_SUSPEND;\n\tif (device_property_read_bool(dev, \"keep-power-in-suspend\"))\n\t\thost->pm_caps |= MMC_PM_KEEP_POWER;\n\tif (device_property_read_bool(dev, \"wakeup-source\") ||\n\t    device_property_read_bool(dev, \"enable-sdio-wakeup\"))  \n\t\thost->pm_caps |= MMC_PM_WAKE_SDIO_IRQ;\n\tif (device_property_read_bool(dev, \"mmc-ddr-3_3v\"))\n\t\thost->caps |= MMC_CAP_3_3V_DDR;\n\tif (device_property_read_bool(dev, \"mmc-ddr-1_8v\"))\n\t\thost->caps |= MMC_CAP_1_8V_DDR;\n\tif (device_property_read_bool(dev, \"mmc-ddr-1_2v\"))\n\t\thost->caps |= MMC_CAP_1_2V_DDR;\n\tif (device_property_read_bool(dev, \"mmc-hs200-1_8v\"))\n\t\thost->caps2 |= MMC_CAP2_HS200_1_8V_SDR;\n\tif (device_property_read_bool(dev, \"mmc-hs200-1_2v\"))\n\t\thost->caps2 |= MMC_CAP2_HS200_1_2V_SDR;\n\tif (device_property_read_bool(dev, \"mmc-hs400-1_8v\"))\n\t\thost->caps2 |= MMC_CAP2_HS400_1_8V | MMC_CAP2_HS200_1_8V_SDR;\n\tif (device_property_read_bool(dev, \"mmc-hs400-1_2v\"))\n\t\thost->caps2 |= MMC_CAP2_HS400_1_2V | MMC_CAP2_HS200_1_2V_SDR;\n\tif (device_property_read_bool(dev, \"mmc-hs400-enhanced-strobe\"))\n\t\thost->caps2 |= MMC_CAP2_HS400_ES;\n\tif (device_property_read_bool(dev, \"no-sdio\"))\n\t\thost->caps2 |= MMC_CAP2_NO_SDIO;\n\tif (device_property_read_bool(dev, \"no-sd\"))\n\t\thost->caps2 |= MMC_CAP2_NO_SD;\n\tif (device_property_read_bool(dev, \"no-mmc\"))\n\t\thost->caps2 |= MMC_CAP2_NO_MMC;\n\tif (device_property_read_bool(dev, \"no-mmc-hs400\"))\n\t\thost->caps2 &= ~(MMC_CAP2_HS400_1_8V | MMC_CAP2_HS400_1_2V |\n\t\t\t\t MMC_CAP2_HS400_ES);\n\n\t \n\tif (device_property_read_u32(dev, \"fixed-emmc-driver-type\", &drv_type) == 0) {\n\t\tif (host->caps & MMC_CAP_NONREMOVABLE)\n\t\t\thost->fixed_drv_type = drv_type;\n\t\telse\n\t\t\tdev_err(host->parent,\n\t\t\t\t\"can't use fixed driver type, media is removable\\n\");\n\t}\n\n\thost->dsr_req = !device_property_read_u32(dev, \"dsr\", &host->dsr);\n\tif (host->dsr_req && (host->dsr & ~0xffff)) {\n\t\tdev_err(host->parent,\n\t\t\t\"device tree specified broken value for DSR: 0x%x, ignoring\\n\",\n\t\t\thost->dsr);\n\t\thost->dsr_req = 0;\n\t}\n\n\tdevice_property_read_u32(dev, \"post-power-on-delay-ms\",\n\t\t\t\t &host->ios.power_delay_ms);\n\n\treturn mmc_pwrseq_alloc(host);\n}\n\nEXPORT_SYMBOL(mmc_of_parse);\n\n \nint mmc_of_parse_voltage(struct mmc_host *host, u32 *mask)\n{\n\tconst char *prop = \"voltage-ranges\";\n\tstruct device *dev = host->parent;\n\tu32 *voltage_ranges;\n\tint num_ranges, i;\n\tint ret;\n\n\tif (!device_property_present(dev, prop)) {\n\t\tdev_dbg(dev, \"%s unspecified\\n\", prop);\n\t\treturn 0;\n\t}\n\n\tret = device_property_count_u32(dev, prop);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_ranges = ret / 2;\n\tif (!num_ranges) {\n\t\tdev_err(dev, \"%s empty\\n\", prop);\n\t\treturn -EINVAL;\n\t}\n\n\tvoltage_ranges = kcalloc(2 * num_ranges, sizeof(*voltage_ranges), GFP_KERNEL);\n\tif (!voltage_ranges)\n\t\treturn -ENOMEM;\n\n\tret = device_property_read_u32_array(dev, prop, voltage_ranges, 2 * num_ranges);\n\tif (ret) {\n\t\tkfree(voltage_ranges);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < num_ranges; i++) {\n\t\tconst int j = i * 2;\n\t\tu32 ocr_mask;\n\n\t\tocr_mask = mmc_vddrange_to_ocrmask(voltage_ranges[j + 0],\n\t\t\t\t\t\t   voltage_ranges[j + 1]);\n\t\tif (!ocr_mask) {\n\t\t\tdev_err(dev, \"range #%d in %s is invalid\\n\", i, prop);\n\t\t\tkfree(voltage_ranges);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*mask |= ocr_mask;\n\t}\n\n\tkfree(voltage_ranges);\n\n\treturn 1;\n}\nEXPORT_SYMBOL(mmc_of_parse_voltage);\n\n \nstatic int mmc_first_nonreserved_index(void)\n{\n\tint max;\n\n\tmax = of_alias_get_highest_id(\"mmc\");\n\tif (max < 0)\n\t\treturn 0;\n\n\treturn max + 1;\n}\n\n \nstruct mmc_host *mmc_alloc_host(int extra, struct device *dev)\n{\n\tint index;\n\tstruct mmc_host *host;\n\tint alias_id, min_idx, max_idx;\n\n\thost = kzalloc(sizeof(struct mmc_host) + extra, GFP_KERNEL);\n\tif (!host)\n\t\treturn NULL;\n\n\t \n\thost->rescan_disable = 1;\n\n\talias_id = of_alias_get_id(dev->of_node, \"mmc\");\n\tif (alias_id >= 0) {\n\t\tindex = alias_id;\n\t} else {\n\t\tmin_idx = mmc_first_nonreserved_index();\n\t\tmax_idx = 0;\n\n\t\tindex = ida_simple_get(&mmc_host_ida, min_idx, max_idx, GFP_KERNEL);\n\t\tif (index < 0) {\n\t\t\tkfree(host);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\thost->index = index;\n\n\tdev_set_name(&host->class_dev, \"mmc%d\", host->index);\n\thost->ws = wakeup_source_register(NULL, dev_name(&host->class_dev));\n\n\thost->parent = dev;\n\thost->class_dev.parent = dev;\n\thost->class_dev.class = &mmc_host_class;\n\tdevice_initialize(&host->class_dev);\n\tdevice_enable_async_suspend(&host->class_dev);\n\n\tif (mmc_gpio_alloc(host)) {\n\t\tput_device(&host->class_dev);\n\t\treturn NULL;\n\t}\n\n\tspin_lock_init(&host->lock);\n\tinit_waitqueue_head(&host->wq);\n\tINIT_DELAYED_WORK(&host->detect, mmc_rescan);\n\tINIT_WORK(&host->sdio_irq_work, sdio_irq_work);\n\ttimer_setup(&host->retune_timer, mmc_retune_timer, 0);\n\n\t \n\thost->max_segs = 1;\n\thost->max_seg_size = PAGE_SIZE;\n\n\thost->max_req_size = PAGE_SIZE;\n\thost->max_blk_size = 512;\n\thost->max_blk_count = PAGE_SIZE / 512;\n\n\thost->fixed_drv_type = -EINVAL;\n\thost->ios.power_delay_ms = 10;\n\thost->ios.power_mode = MMC_POWER_UNDEFINED;\n\n\treturn host;\n}\n\nEXPORT_SYMBOL(mmc_alloc_host);\n\nstatic void devm_mmc_host_release(struct device *dev, void *res)\n{\n\tmmc_free_host(*(struct mmc_host **)res);\n}\n\nstruct mmc_host *devm_mmc_alloc_host(struct device *dev, int extra)\n{\n\tstruct mmc_host **dr, *host;\n\n\tdr = devres_alloc(devm_mmc_host_release, sizeof(*dr), GFP_KERNEL);\n\tif (!dr)\n\t\treturn NULL;\n\n\thost = mmc_alloc_host(extra, dev);\n\tif (!host) {\n\t\tdevres_free(dr);\n\t\treturn NULL;\n\t}\n\n\t*dr = host;\n\tdevres_add(dev, dr);\n\n\treturn host;\n}\nEXPORT_SYMBOL(devm_mmc_alloc_host);\n\nstatic int mmc_validate_host_caps(struct mmc_host *host)\n{\n\tstruct device *dev = host->parent;\n\tu32 caps = host->caps, caps2 = host->caps2;\n\n\tif (caps & MMC_CAP_SDIO_IRQ && !host->ops->enable_sdio_irq) {\n\t\tdev_warn(dev, \"missing ->enable_sdio_irq() ops\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (caps2 & (MMC_CAP2_HS400_ES | MMC_CAP2_HS400) &&\n\t    !(caps & MMC_CAP_8_BIT_DATA) && !(caps2 & MMC_CAP2_NO_MMC)) {\n\t\tdev_warn(dev, \"drop HS400 support since no 8-bit bus\\n\");\n\t\thost->caps2 = caps2 & ~MMC_CAP2_HS400_ES & ~MMC_CAP2_HS400;\n\t}\n\n\treturn 0;\n}\n\n \nint mmc_add_host(struct mmc_host *host)\n{\n\tint err;\n\n\terr = mmc_validate_host_caps(host);\n\tif (err)\n\t\treturn err;\n\n\terr = device_add(&host->class_dev);\n\tif (err)\n\t\treturn err;\n\n\tled_trigger_register_simple(dev_name(&host->class_dev), &host->led);\n\n\tmmc_add_host_debugfs(host);\n\n\tmmc_start_host(host);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(mmc_add_host);\n\n \nvoid mmc_remove_host(struct mmc_host *host)\n{\n\tmmc_stop_host(host);\n\n\tmmc_remove_host_debugfs(host);\n\n\tdevice_del(&host->class_dev);\n\n\tled_trigger_unregister_simple(host->led);\n}\n\nEXPORT_SYMBOL(mmc_remove_host);\n\n \nvoid mmc_free_host(struct mmc_host *host)\n{\n\tcancel_delayed_work_sync(&host->detect);\n\tmmc_pwrseq_free(host);\n\tput_device(&host->class_dev);\n}\n\nEXPORT_SYMBOL(mmc_free_host);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}