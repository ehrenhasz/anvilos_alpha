{
  "module_name": "pwrseq_sd8787.c",
  "hash_id": "344deb6d0130d3d27fa6810e5c768e8e6728a7e8e26279eeb221eb5b69d1cc4d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/pwrseq_sd8787.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n\n#include <linux/mmc/host.h>\n\n#include \"pwrseq.h\"\n\nstruct mmc_pwrseq_sd8787 {\n\tstruct mmc_pwrseq pwrseq;\n\tstruct gpio_desc *reset_gpio;\n\tstruct gpio_desc *pwrdn_gpio;\n};\n\n#define to_pwrseq_sd8787(p) container_of(p, struct mmc_pwrseq_sd8787, pwrseq)\n\nstatic void mmc_pwrseq_sd8787_pre_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq = to_pwrseq_sd8787(host->pwrseq);\n\n\tgpiod_set_value_cansleep(pwrseq->reset_gpio, 1);\n\n\tmsleep(300);\n\tgpiod_set_value_cansleep(pwrseq->pwrdn_gpio, 1);\n}\n\nstatic void mmc_pwrseq_sd8787_power_off(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq = to_pwrseq_sd8787(host->pwrseq);\n\n\tgpiod_set_value_cansleep(pwrseq->pwrdn_gpio, 0);\n\tgpiod_set_value_cansleep(pwrseq->reset_gpio, 0);\n}\n\nstatic void mmc_pwrseq_wilc1000_pre_power_on(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq = to_pwrseq_sd8787(host->pwrseq);\n\n\t \n\tgpiod_set_value_cansleep(pwrseq->pwrdn_gpio, 1);\n\tmsleep(5);\n\tgpiod_set_value_cansleep(pwrseq->reset_gpio, 1);\n}\n\nstatic void mmc_pwrseq_wilc1000_power_off(struct mmc_host *host)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq = to_pwrseq_sd8787(host->pwrseq);\n\n\tgpiod_set_value_cansleep(pwrseq->reset_gpio, 0);\n\tgpiod_set_value_cansleep(pwrseq->pwrdn_gpio, 0);\n}\n\nstatic const struct mmc_pwrseq_ops mmc_pwrseq_sd8787_ops = {\n\t.pre_power_on = mmc_pwrseq_sd8787_pre_power_on,\n\t.power_off = mmc_pwrseq_sd8787_power_off,\n};\n\nstatic const struct mmc_pwrseq_ops mmc_pwrseq_wilc1000_ops = {\n\t.pre_power_on = mmc_pwrseq_wilc1000_pre_power_on,\n\t.power_off = mmc_pwrseq_wilc1000_power_off,\n};\n\nstatic const struct of_device_id mmc_pwrseq_sd8787_of_match[] = {\n\t{ .compatible = \"mmc-pwrseq-sd8787\", .data = &mmc_pwrseq_sd8787_ops },\n\t{ .compatible = \"mmc-pwrseq-wilc1000\", .data = &mmc_pwrseq_wilc1000_ops },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mmc_pwrseq_sd8787_of_match);\n\nstatic int mmc_pwrseq_sd8787_probe(struct platform_device *pdev)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq;\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\n\tpwrseq = devm_kzalloc(dev, sizeof(*pwrseq), GFP_KERNEL);\n\tif (!pwrseq)\n\t\treturn -ENOMEM;\n\n\tmatch = of_match_node(mmc_pwrseq_sd8787_of_match, pdev->dev.of_node);\n\n\tpwrseq->pwrdn_gpio = devm_gpiod_get(dev, \"powerdown\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pwrseq->pwrdn_gpio))\n\t\treturn PTR_ERR(pwrseq->pwrdn_gpio);\n\n\tpwrseq->reset_gpio = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(pwrseq->reset_gpio))\n\t\treturn PTR_ERR(pwrseq->reset_gpio);\n\n\tpwrseq->pwrseq.dev = dev;\n\tpwrseq->pwrseq.ops = match->data;\n\tpwrseq->pwrseq.owner = THIS_MODULE;\n\tplatform_set_drvdata(pdev, pwrseq);\n\n\treturn mmc_pwrseq_register(&pwrseq->pwrseq);\n}\n\nstatic void mmc_pwrseq_sd8787_remove(struct platform_device *pdev)\n{\n\tstruct mmc_pwrseq_sd8787 *pwrseq = platform_get_drvdata(pdev);\n\n\tmmc_pwrseq_unregister(&pwrseq->pwrseq);\n}\n\nstatic struct platform_driver mmc_pwrseq_sd8787_driver = {\n\t.probe = mmc_pwrseq_sd8787_probe,\n\t.remove_new = mmc_pwrseq_sd8787_remove,\n\t.driver = {\n\t\t.name = \"pwrseq_sd8787\",\n\t\t.of_match_table = mmc_pwrseq_sd8787_of_match,\n\t},\n};\n\nmodule_platform_driver(mmc_pwrseq_sd8787_driver);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}