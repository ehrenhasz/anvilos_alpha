{
  "module_name": "mmc_ops.c",
  "hash_id": "908c78163cd4c1e2feeecbce6ea0d1175f6df535c97c4a27af6bfdca38e8d98e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/mmc_ops.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/types.h>\n#include <linux/scatterlist.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"mmc_ops.h\"\n\n#define MMC_BKOPS_TIMEOUT_MS\t\t(120 * 1000)  \n#define MMC_SANITIZE_TIMEOUT_MS\t\t(240 * 1000)  \n#define MMC_OP_COND_PERIOD_US\t\t(4 * 1000)  \n#define MMC_OP_COND_TIMEOUT_MS\t\t1000  \n\nstatic const u8 tuning_blk_pattern_4bit[] = {\n\t0xff, 0x0f, 0xff, 0x00, 0xff, 0xcc, 0xc3, 0xcc,\n\t0xc3, 0x3c, 0xcc, 0xff, 0xfe, 0xff, 0xfe, 0xef,\n\t0xff, 0xdf, 0xff, 0xdd, 0xff, 0xfb, 0xff, 0xfb,\n\t0xbf, 0xff, 0x7f, 0xff, 0x77, 0xf7, 0xbd, 0xef,\n\t0xff, 0xf0, 0xff, 0xf0, 0x0f, 0xfc, 0xcc, 0x3c,\n\t0xcc, 0x33, 0xcc, 0xcf, 0xff, 0xef, 0xff, 0xee,\n\t0xff, 0xfd, 0xff, 0xfd, 0xdf, 0xff, 0xbf, 0xff,\n\t0xbb, 0xff, 0xf7, 0xff, 0xf7, 0x7f, 0x7b, 0xde,\n};\n\nstatic const u8 tuning_blk_pattern_8bit[] = {\n\t0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00,\n\t0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc, 0xcc,\n\t0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff, 0xff,\n\t0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xff,\n\t0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd, 0xdd,\n\t0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff, 0xbb,\n\t0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff, 0xff,\n\t0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee, 0xff,\n\t0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00,\n\t0x00, 0xff, 0xff, 0xcc, 0xcc, 0xcc, 0x33, 0xcc,\n\t0xcc, 0xcc, 0x33, 0x33, 0xcc, 0xcc, 0xcc, 0xff,\n\t0xff, 0xff, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee,\n\t0xff, 0xff, 0xff, 0xdd, 0xff, 0xff, 0xff, 0xdd,\n\t0xdd, 0xff, 0xff, 0xff, 0xbb, 0xff, 0xff, 0xff,\n\t0xbb, 0xbb, 0xff, 0xff, 0xff, 0x77, 0xff, 0xff,\n\t0xff, 0x77, 0x77, 0xff, 0x77, 0xbb, 0xdd, 0xee,\n};\n\nstruct mmc_busy_data {\n\tstruct mmc_card *card;\n\tbool retry_crc_err;\n\tenum mmc_busy_cmd busy_cmd;\n};\n\nstruct mmc_op_cond_busy_data {\n\tstruct mmc_host *host;\n\tu32 ocr;\n\tstruct mmc_command *cmd;\n};\n\nint __mmc_send_status(struct mmc_card *card, u32 *status, unsigned int retries)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = MMC_SEND_STATUS;\n\tif (!mmc_host_is_spi(card->host))\n\t\tcmd.arg = card->rca << 16;\n\tcmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_AC;\n\n\terr = mmc_wait_for_cmd(card->host, &cmd, retries);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (status)\n\t\t*status = cmd.resp[0];\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mmc_send_status);\n\nint mmc_send_status(struct mmc_card *card, u32 *status)\n{\n\treturn __mmc_send_status(card, status, MMC_CMD_RETRIES);\n}\nEXPORT_SYMBOL_GPL(mmc_send_status);\n\nstatic int _mmc_select_card(struct mmc_host *host, struct mmc_card *card)\n{\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = MMC_SELECT_CARD;\n\n\tif (card) {\n\t\tcmd.arg = card->rca << 16;\n\t\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\t} else {\n\t\tcmd.arg = 0;\n\t\tcmd.flags = MMC_RSP_NONE | MMC_CMD_AC;\n\t}\n\n\treturn mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n}\n\nint mmc_select_card(struct mmc_card *card)\n{\n\n\treturn _mmc_select_card(card->host, card);\n}\n\nint mmc_deselect_cards(struct mmc_host *host)\n{\n\treturn _mmc_select_card(host, NULL);\n}\n\n \nint mmc_set_dsr(struct mmc_host *host)\n{\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = MMC_SET_DSR;\n\n\tcmd.arg = (host->dsr << 16) | 0xffff;\n\tcmd.flags = MMC_RSP_NONE | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n}\n\nint mmc_go_idle(struct mmc_host *host)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\tmmc_set_chip_select(host, MMC_CS_HIGH);\n\t\tmmc_delay(1);\n\t}\n\n\tcmd.opcode = MMC_GO_IDLE_STATE;\n\tcmd.arg = 0;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_NONE | MMC_CMD_BC;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\n\tmmc_delay(1);\n\n\tif (!mmc_host_is_spi(host)) {\n\t\tmmc_set_chip_select(host, MMC_CS_DONTCARE);\n\t\tmmc_delay(1);\n\t}\n\n\thost->use_spi_crc = 0;\n\n\treturn err;\n}\n\nstatic int __mmc_send_op_cond_cb(void *cb_data, bool *busy)\n{\n\tstruct mmc_op_cond_busy_data *data = cb_data;\n\tstruct mmc_host *host = data->host;\n\tstruct mmc_command *cmd = data->cmd;\n\tu32 ocr = data->ocr;\n\tint err = 0;\n\n\terr = mmc_wait_for_cmd(host, cmd, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (mmc_host_is_spi(host)) {\n\t\tif (!(cmd->resp[0] & R1_SPI_IDLE)) {\n\t\t\t*busy = false;\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tif (cmd->resp[0] & MMC_CARD_BUSY) {\n\t\t\t*busy = false;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t*busy = true;\n\n\t \n\tif (!ocr && !mmc_host_is_spi(host))\n\t\tcmd->arg = cmd->resp[0] | BIT(30);\n\n\treturn 0;\n}\n\nint mmc_send_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\n{\n\tstruct mmc_command cmd = {};\n\tint err = 0;\n\tstruct mmc_op_cond_busy_data cb_data = {\n\t\t.host = host,\n\t\t.ocr = ocr,\n\t\t.cmd = &cmd\n\t};\n\n\tcmd.opcode = MMC_SEND_OP_COND;\n\tcmd.arg = mmc_host_is_spi(host) ? 0 : ocr;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;\n\n\terr = __mmc_poll_for_busy(host, MMC_OP_COND_PERIOD_US,\n\t\t\t\t  MMC_OP_COND_TIMEOUT_MS,\n\t\t\t\t  &__mmc_send_op_cond_cb, &cb_data);\n\tif (err)\n\t\treturn err;\n\n\tif (rocr && !mmc_host_is_spi(host))\n\t\t*rocr = cmd.resp[0];\n\n\treturn err;\n}\n\nint mmc_set_relative_addr(struct mmc_card *card)\n{\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = MMC_SET_RELATIVE_ADDR;\n\tcmd.arg = card->rca << 16;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\n\treturn mmc_wait_for_cmd(card->host, &cmd, MMC_CMD_RETRIES);\n}\n\nstatic int\nmmc_send_cxd_native(struct mmc_host *host, u32 arg, u32 *cxd, int opcode)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = opcode;\n\tcmd.arg = arg;\n\tcmd.flags = MMC_RSP_R2 | MMC_CMD_AC;\n\n\terr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\tif (err)\n\t\treturn err;\n\n\tmemcpy(cxd, cmd.resp, sizeof(u32) * 4);\n\n\treturn 0;\n}\n\n \nint mmc_send_adtc_data(struct mmc_card *card, struct mmc_host *host, u32 opcode,\n\t\t       u32 args, void *buf, unsigned len)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = opcode;\n\tcmd.arg = args;\n\n\t \n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tdata.blksz = len;\n\tdata.blocks = 1;\n\tdata.flags = MMC_DATA_READ;\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\n\tsg_init_one(&sg, buf, len);\n\n\tif (opcode == MMC_SEND_CSD || opcode == MMC_SEND_CID) {\n\t\t \n\t\tdata.timeout_ns = 0;\n\t\tdata.timeout_clks = 64;\n\t} else\n\t\tmmc_set_data_timeout(&data, card);\n\n\tmmc_wait_for_req(host, &mrq);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn 0;\n}\n\nstatic int mmc_spi_send_cxd(struct mmc_host *host, u32 *cxd, u32 opcode)\n{\n\tint ret, i;\n\t__be32 *cxd_tmp;\n\n\tcxd_tmp = kzalloc(16, GFP_KERNEL);\n\tif (!cxd_tmp)\n\t\treturn -ENOMEM;\n\n\tret = mmc_send_adtc_data(NULL, host, opcode, 0, cxd_tmp, 16);\n\tif (ret)\n\t\tgoto err;\n\n\tfor (i = 0; i < 4; i++)\n\t\tcxd[i] = be32_to_cpu(cxd_tmp[i]);\n\nerr:\n\tkfree(cxd_tmp);\n\treturn ret;\n}\n\nint mmc_send_csd(struct mmc_card *card, u32 *csd)\n{\n\tif (mmc_host_is_spi(card->host))\n\t\treturn mmc_spi_send_cxd(card->host, csd, MMC_SEND_CSD);\n\n\treturn mmc_send_cxd_native(card->host, card->rca << 16,\tcsd,\n\t\t\t\tMMC_SEND_CSD);\n}\n\nint mmc_send_cid(struct mmc_host *host, u32 *cid)\n{\n\tif (mmc_host_is_spi(host))\n\t\treturn mmc_spi_send_cxd(host, cid, MMC_SEND_CID);\n\n\treturn mmc_send_cxd_native(host, 0, cid, MMC_ALL_SEND_CID);\n}\n\nint mmc_get_ext_csd(struct mmc_card *card, u8 **new_ext_csd)\n{\n\tint err;\n\tu8 *ext_csd;\n\n\tif (!card || !new_ext_csd)\n\t\treturn -EINVAL;\n\n\tif (!mmc_can_ext_csd(card))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\text_csd = kzalloc(512, GFP_KERNEL);\n\tif (!ext_csd)\n\t\treturn -ENOMEM;\n\n\terr = mmc_send_adtc_data(card, card->host, MMC_SEND_EXT_CSD, 0, ext_csd,\n\t\t\t\t512);\n\tif (err)\n\t\tkfree(ext_csd);\n\telse\n\t\t*new_ext_csd = ext_csd;\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mmc_get_ext_csd);\n\nint mmc_spi_read_ocr(struct mmc_host *host, int highcap, u32 *ocrp)\n{\n\tstruct mmc_command cmd = {};\n\tint err;\n\n\tcmd.opcode = MMC_SPI_READ_OCR;\n\tcmd.arg = highcap ? (1 << 30) : 0;\n\tcmd.flags = MMC_RSP_SPI_R3;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\n\t*ocrp = cmd.resp[1];\n\treturn err;\n}\n\nint mmc_spi_set_crc(struct mmc_host *host, int use_crc)\n{\n\tstruct mmc_command cmd = {};\n\tint err;\n\n\tcmd.opcode = MMC_SPI_CRC_ON_OFF;\n\tcmd.flags = MMC_RSP_SPI_R1;\n\tcmd.arg = use_crc;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (!err)\n\t\thost->use_spi_crc = use_crc;\n\treturn err;\n}\n\nstatic int mmc_switch_status_error(struct mmc_host *host, u32 status)\n{\n\tif (mmc_host_is_spi(host)) {\n\t\tif (status & R1_SPI_ILLEGAL_COMMAND)\n\t\t\treturn -EBADMSG;\n\t} else {\n\t\tif (R1_STATUS(status))\n\t\t\tpr_warn(\"%s: unexpected status %#x after switch\\n\",\n\t\t\t\tmmc_hostname(host), status);\n\t\tif (status & R1_SWITCH_ERROR)\n\t\t\treturn -EBADMSG;\n\t}\n\treturn 0;\n}\n\n \nint mmc_switch_status(struct mmc_card *card, bool crc_err_fatal)\n{\n\tu32 status;\n\tint err;\n\n\terr = mmc_send_status(card, &status);\n\tif (!crc_err_fatal && err == -EILSEQ)\n\t\treturn 0;\n\tif (err)\n\t\treturn err;\n\n\treturn mmc_switch_status_error(card->host, status);\n}\n\nstatic int mmc_busy_cb(void *cb_data, bool *busy)\n{\n\tstruct mmc_busy_data *data = cb_data;\n\tstruct mmc_host *host = data->card->host;\n\tu32 status = 0;\n\tint err;\n\n\tif (data->busy_cmd != MMC_BUSY_IO && host->ops->card_busy) {\n\t\t*busy = host->ops->card_busy(host);\n\t\treturn 0;\n\t}\n\n\terr = mmc_send_status(data->card, &status);\n\tif (data->retry_crc_err && err == -EILSEQ) {\n\t\t*busy = true;\n\t\treturn 0;\n\t}\n\tif (err)\n\t\treturn err;\n\n\tswitch (data->busy_cmd) {\n\tcase MMC_BUSY_CMD6:\n\t\terr = mmc_switch_status_error(host, status);\n\t\tbreak;\n\tcase MMC_BUSY_ERASE:\n\t\terr = R1_STATUS(status) ? -EIO : 0;\n\t\tbreak;\n\tcase MMC_BUSY_HPI:\n\tcase MMC_BUSY_EXTR_SINGLE:\n\tcase MMC_BUSY_IO:\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\t*busy = !mmc_ready_for_data(status);\n\treturn 0;\n}\n\nint __mmc_poll_for_busy(struct mmc_host *host, unsigned int period_us,\n\t\t\tunsigned int timeout_ms,\n\t\t\tint (*busy_cb)(void *cb_data, bool *busy),\n\t\t\tvoid *cb_data)\n{\n\tint err;\n\tunsigned long timeout;\n\tunsigned int udelay = period_us ? period_us : 32, udelay_max = 32768;\n\tbool expired = false;\n\tbool busy = false;\n\n\ttimeout = jiffies + msecs_to_jiffies(timeout_ms) + 1;\n\tdo {\n\t\t \n\t\texpired = time_after(jiffies, timeout);\n\n\t\terr = (*busy_cb)(cb_data, &busy);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\tif (expired && busy) {\n\t\t\tpr_err(\"%s: Card stuck being busy! %s\\n\",\n\t\t\t\tmmc_hostname(host), __func__);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\tif (busy) {\n\t\t\tusleep_range(udelay, udelay * 2);\n\t\t\tif (udelay < udelay_max)\n\t\t\t\tudelay *= 2;\n\t\t}\n\t} while (busy);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(__mmc_poll_for_busy);\n\nint mmc_poll_for_busy(struct mmc_card *card, unsigned int timeout_ms,\n\t\t      bool retry_crc_err, enum mmc_busy_cmd busy_cmd)\n{\n\tstruct mmc_host *host = card->host;\n\tstruct mmc_busy_data cb_data;\n\n\tcb_data.card = card;\n\tcb_data.retry_crc_err = retry_crc_err;\n\tcb_data.busy_cmd = busy_cmd;\n\n\treturn __mmc_poll_for_busy(host, 0, timeout_ms, &mmc_busy_cb, &cb_data);\n}\nEXPORT_SYMBOL_GPL(mmc_poll_for_busy);\n\nbool mmc_prepare_busy_cmd(struct mmc_host *host, struct mmc_command *cmd,\n\t\t\t  unsigned int timeout_ms)\n{\n\t \n\tif (!(host->caps & MMC_CAP_NEED_RSP_BUSY) && host->max_busy_timeout &&\n\t    (timeout_ms > host->max_busy_timeout)) {\n\t\tcmd->flags = MMC_CMD_AC | MMC_RSP_SPI_R1 | MMC_RSP_R1;\n\t\treturn false;\n\t}\n\n\tcmd->flags = MMC_CMD_AC | MMC_RSP_SPI_R1B | MMC_RSP_R1B;\n\tcmd->busy_timeout = timeout_ms;\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(mmc_prepare_busy_cmd);\n\n \nint __mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,\n\t\tunsigned int timeout_ms, unsigned char timing,\n\t\tbool send_status, bool retry_crc_err, unsigned int retries)\n{\n\tstruct mmc_host *host = card->host;\n\tint err;\n\tstruct mmc_command cmd = {};\n\tbool use_r1b_resp;\n\tunsigned char old_timing = host->ios.timing;\n\n\tmmc_retune_hold(host);\n\n\tif (!timeout_ms) {\n\t\tpr_warn(\"%s: unspecified timeout for CMD6 - use generic\\n\",\n\t\t\tmmc_hostname(host));\n\t\ttimeout_ms = card->ext_csd.generic_cmd6_time;\n\t}\n\n\tcmd.opcode = MMC_SWITCH;\n\tcmd.arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |\n\t\t  (index << 16) |\n\t\t  (value << 8) |\n\t\t  set;\n\tuse_r1b_resp = mmc_prepare_busy_cmd(host, &cmd, timeout_ms);\n\n\terr = mmc_wait_for_cmd(host, &cmd, retries);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (((host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp) ||\n\t\tmmc_host_is_spi(host))\n\t\tgoto out_tim;\n\n\t \n\tif (!send_status && !host->ops->card_busy) {\n\t\tmmc_delay(timeout_ms);\n\t\tgoto out_tim;\n\t}\n\n\t \n\terr = mmc_poll_for_busy(card, timeout_ms, retry_crc_err, MMC_BUSY_CMD6);\n\tif (err)\n\t\tgoto out;\n\nout_tim:\n\t \n\tif (timing)\n\t\tmmc_set_timing(host, timing);\n\n\tif (send_status) {\n\t\terr = mmc_switch_status(card, true);\n\t\tif (err && timing)\n\t\t\tmmc_set_timing(host, old_timing);\n\t}\nout:\n\tmmc_retune_release(host);\n\n\treturn err;\n}\n\nint mmc_switch(struct mmc_card *card, u8 set, u8 index, u8 value,\n\t\tunsigned int timeout_ms)\n{\n\treturn __mmc_switch(card, set, index, value, timeout_ms, 0,\n\t\t\t    true, false, MMC_CMD_RETRIES);\n}\nEXPORT_SYMBOL_GPL(mmc_switch);\n\nint mmc_send_tuning(struct mmc_host *host, u32 opcode, int *cmd_error)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\tstruct mmc_ios *ios = &host->ios;\n\tconst u8 *tuning_block_pattern;\n\tint size, err = 0;\n\tu8 *data_buf;\n\n\tif (ios->bus_width == MMC_BUS_WIDTH_8) {\n\t\ttuning_block_pattern = tuning_blk_pattern_8bit;\n\t\tsize = sizeof(tuning_blk_pattern_8bit);\n\t} else if (ios->bus_width == MMC_BUS_WIDTH_4) {\n\t\ttuning_block_pattern = tuning_blk_pattern_4bit;\n\t\tsize = sizeof(tuning_blk_pattern_4bit);\n\t} else\n\t\treturn -EINVAL;\n\n\tdata_buf = kzalloc(size, GFP_KERNEL);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = opcode;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tdata.blksz = size;\n\tdata.blocks = 1;\n\tdata.flags = MMC_DATA_READ;\n\n\t \n\tdata.timeout_ns = 150 * NSEC_PER_MSEC;\n\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\tsg_init_one(&sg, data_buf, size);\n\n\tmmc_wait_for_req(host, &mrq);\n\n\tif (cmd_error)\n\t\t*cmd_error = cmd.error;\n\n\tif (cmd.error) {\n\t\terr = cmd.error;\n\t\tgoto out;\n\t}\n\n\tif (data.error) {\n\t\terr = data.error;\n\t\tgoto out;\n\t}\n\n\tif (memcmp(data_buf, tuning_block_pattern, size))\n\t\terr = -EIO;\n\nout:\n\tkfree(data_buf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mmc_send_tuning);\n\nint mmc_send_abort_tuning(struct mmc_host *host, u32 opcode)\n{\n\tstruct mmc_command cmd = {};\n\n\t \n\tif (opcode != MMC_SEND_TUNING_BLOCK_HS200)\n\t\treturn 0;\n\n\tcmd.opcode = MMC_STOP_TRANSMISSION;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\n\n\t \n\tcmd.busy_timeout = 150;\n\n\treturn mmc_wait_for_cmd(host, &cmd, 0);\n}\nEXPORT_SYMBOL_GPL(mmc_send_abort_tuning);\n\nstatic int\nmmc_send_bus_test(struct mmc_card *card, struct mmc_host *host, u8 opcode,\n\t\t  u8 len)\n{\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\tu8 *data_buf;\n\tu8 *test_buf;\n\tint i, err;\n\tstatic u8 testdata_8bit[8] = { 0x55, 0xaa, 0, 0, 0, 0, 0, 0 };\n\tstatic u8 testdata_4bit[4] = { 0x5a, 0, 0, 0 };\n\n\t \n\tdata_buf = kmalloc(len, GFP_KERNEL);\n\tif (!data_buf)\n\t\treturn -ENOMEM;\n\n\tif (len == 8)\n\t\ttest_buf = testdata_8bit;\n\telse if (len == 4)\n\t\ttest_buf = testdata_4bit;\n\telse {\n\t\tpr_err(\"%s: Invalid bus_width %d\\n\",\n\t\t       mmc_hostname(host), len);\n\t\tkfree(data_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (opcode == MMC_BUS_TEST_W)\n\t\tmemcpy(data_buf, test_buf, len);\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\tcmd.opcode = opcode;\n\tcmd.arg = 0;\n\n\t \n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tdata.blksz = len;\n\tdata.blocks = 1;\n\tif (opcode == MMC_BUS_TEST_R)\n\t\tdata.flags = MMC_DATA_READ;\n\telse\n\t\tdata.flags = MMC_DATA_WRITE;\n\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\tmmc_set_data_timeout(&data, card);\n\tsg_init_one(&sg, data_buf, len);\n\tmmc_wait_for_req(host, &mrq);\n\terr = 0;\n\tif (opcode == MMC_BUS_TEST_R) {\n\t\tfor (i = 0; i < len / 4; i++)\n\t\t\tif ((test_buf[i] ^ data_buf[i]) != 0xff) {\n\t\t\t\terr = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tkfree(data_buf);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn err;\n}\n\nint mmc_bus_test(struct mmc_card *card, u8 bus_width)\n{\n\tint width;\n\n\tif (bus_width == MMC_BUS_WIDTH_8)\n\t\twidth = 8;\n\telse if (bus_width == MMC_BUS_WIDTH_4)\n\t\twidth = 4;\n\telse if (bus_width == MMC_BUS_WIDTH_1)\n\t\treturn 0;  \n\telse\n\t\treturn -EINVAL;\n\n\t \n\tmmc_send_bus_test(card, card->host, MMC_BUS_TEST_W, width);\n\treturn mmc_send_bus_test(card, card->host, MMC_BUS_TEST_R, width);\n}\n\nstatic int mmc_send_hpi_cmd(struct mmc_card *card)\n{\n\tunsigned int busy_timeout_ms = card->ext_csd.out_of_int_time;\n\tstruct mmc_host *host = card->host;\n\tbool use_r1b_resp = false;\n\tstruct mmc_command cmd = {};\n\tint err;\n\n\tcmd.opcode = card->ext_csd.hpi_cmd;\n\tcmd.arg = card->rca << 16 | 1;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\n\tif (cmd.opcode == MMC_STOP_TRANSMISSION)\n\t\tuse_r1b_resp = mmc_prepare_busy_cmd(host, &cmd,\n\t\t\t\t\t\t    busy_timeout_ms);\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err) {\n\t\tpr_warn(\"%s: HPI error %d. Command response %#x\\n\",\n\t\t\tmmc_hostname(host), err, cmd.resp[0]);\n\t\treturn err;\n\t}\n\n\t \n\tif (host->caps & MMC_CAP_WAIT_WHILE_BUSY && use_r1b_resp)\n\t\treturn 0;\n\n\t \n\treturn mmc_poll_for_busy(card, busy_timeout_ms, false, MMC_BUSY_HPI);\n}\n\n \nstatic int mmc_interrupt_hpi(struct mmc_card *card)\n{\n\tint err;\n\tu32 status;\n\n\tif (!card->ext_csd.hpi_en) {\n\t\tpr_info(\"%s: HPI enable bit unset\\n\", mmc_hostname(card->host));\n\t\treturn 1;\n\t}\n\n\terr = mmc_send_status(card, &status);\n\tif (err) {\n\t\tpr_err(\"%s: Get card status fail\\n\", mmc_hostname(card->host));\n\t\tgoto out;\n\t}\n\n\tswitch (R1_CURRENT_STATE(status)) {\n\tcase R1_STATE_IDLE:\n\tcase R1_STATE_READY:\n\tcase R1_STATE_STBY:\n\tcase R1_STATE_TRAN:\n\t\t \n\t\tgoto out;\n\tcase R1_STATE_PRG:\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_debug(\"%s: HPI cannot be sent. Card state=%d\\n\",\n\t\t\tmmc_hostname(card->host), R1_CURRENT_STATE(status));\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\terr = mmc_send_hpi_cmd(card);\nout:\n\treturn err;\n}\n\nint mmc_can_ext_csd(struct mmc_card *card)\n{\n\treturn (card && card->csd.mmca_vsn > CSD_SPEC_VER_3);\n}\n\nstatic int mmc_read_bkops_status(struct mmc_card *card)\n{\n\tint err;\n\tu8 *ext_csd;\n\n\terr = mmc_get_ext_csd(card, &ext_csd);\n\tif (err)\n\t\treturn err;\n\n\tcard->ext_csd.raw_bkops_status = ext_csd[EXT_CSD_BKOPS_STATUS];\n\tcard->ext_csd.raw_exception_status = ext_csd[EXT_CSD_EXP_EVENTS_STATUS];\n\tkfree(ext_csd);\n\treturn 0;\n}\n\n \nvoid mmc_run_bkops(struct mmc_card *card)\n{\n\tint err;\n\n\tif (!card->ext_csd.man_bkops_en)\n\t\treturn;\n\n\terr = mmc_read_bkops_status(card);\n\tif (err) {\n\t\tpr_err(\"%s: Failed to read bkops status: %d\\n\",\n\t\t       mmc_hostname(card->host), err);\n\t\treturn;\n\t}\n\n\tif (!card->ext_csd.raw_bkops_status ||\n\t    card->ext_csd.raw_bkops_status < EXT_CSD_BKOPS_LEVEL_2)\n\t\treturn;\n\n\tmmc_retune_hold(card->host);\n\n\t \n\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t EXT_CSD_BKOPS_START, 1, MMC_BKOPS_TIMEOUT_MS);\n\t \n\tif (err == -ETIMEDOUT && !mmc_interrupt_hpi(card))\n\t\tpr_warn(\"%s: BKOPS aborted\\n\", mmc_hostname(card->host));\n\telse if (err)\n\t\tpr_warn(\"%s: Error %d running bkops\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\n\tmmc_retune_release(card->host);\n}\nEXPORT_SYMBOL(mmc_run_bkops);\n\nstatic int mmc_cmdq_switch(struct mmc_card *card, bool enable)\n{\n\tu8 val = enable ? EXT_CSD_CMDQ_MODE_ENABLED : 0;\n\tint err;\n\n\tif (!card->ext_csd.cmdq_support)\n\t\treturn -EOPNOTSUPP;\n\n\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_CMDQ_MODE_EN,\n\t\t\t val, card->ext_csd.generic_cmd6_time);\n\tif (!err)\n\t\tcard->ext_csd.cmdq_en = enable;\n\n\treturn err;\n}\n\nint mmc_cmdq_enable(struct mmc_card *card)\n{\n\treturn mmc_cmdq_switch(card, true);\n}\nEXPORT_SYMBOL_GPL(mmc_cmdq_enable);\n\nint mmc_cmdq_disable(struct mmc_card *card)\n{\n\treturn mmc_cmdq_switch(card, false);\n}\nEXPORT_SYMBOL_GPL(mmc_cmdq_disable);\n\nint mmc_sanitize(struct mmc_card *card, unsigned int timeout_ms)\n{\n\tstruct mmc_host *host = card->host;\n\tint err;\n\n\tif (!mmc_can_sanitize(card)) {\n\t\tpr_warn(\"%s: Sanitize not supported\\n\", mmc_hostname(host));\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!timeout_ms)\n\t\ttimeout_ms = MMC_SANITIZE_TIMEOUT_MS;\n\n\tpr_debug(\"%s: Sanitize in progress...\\n\", mmc_hostname(host));\n\n\tmmc_retune_hold(host);\n\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_SANITIZE_START,\n\t\t\t   1, timeout_ms, 0, true, false, 0);\n\tif (err)\n\t\tpr_err(\"%s: Sanitize failed err=%d\\n\", mmc_hostname(host), err);\n\n\t \n\tif (err == -ETIMEDOUT && !mmc_interrupt_hpi(card))\n\t\tpr_warn(\"%s: Sanitize aborted\\n\", mmc_hostname(host));\n\n\tmmc_retune_release(host);\n\n\tpr_debug(\"%s: Sanitize completed\\n\", mmc_hostname(host));\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(mmc_sanitize);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}