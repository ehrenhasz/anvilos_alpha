{
  "module_name": "core.c",
  "hash_id": "55171933afd6ceafa8f9b47f0325686c26876e9f682950e1c29da253da566c65",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/core.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/completion.h>\n#include <linux/device.h>\n#include <linux/delay.h>\n#include <linux/pagemap.h>\n#include <linux/err.h>\n#include <linux/leds.h>\n#include <linux/scatterlist.h>\n#include <linux/log2.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeup.h>\n#include <linux/suspend.h>\n#include <linux/fault-inject.h>\n#include <linux/random.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n#include <linux/mmc/slot-gpio.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/mmc.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"crypto.h\"\n#include \"bus.h\"\n#include \"host.h\"\n#include \"sdio_bus.h\"\n#include \"pwrseq.h\"\n\n#include \"mmc_ops.h\"\n#include \"sd_ops.h\"\n#include \"sdio_ops.h\"\n\n \n#define MMC_ERASE_TIMEOUT_MS\t(60 * 1000)  \n#define SD_DISCARD_TIMEOUT_MS\t(250)\n\nstatic const unsigned freqs[] = { 400000, 300000, 200000, 100000 };\n\n \nbool use_spi_crc = 1;\nmodule_param(use_spi_crc, bool, 0);\n\nstatic int mmc_schedule_delayed_work(struct delayed_work *work,\n\t\t\t\t     unsigned long delay)\n{\n\t \n\treturn queue_delayed_work(system_freezable_wq, work, delay);\n}\n\n#ifdef CONFIG_FAIL_MMC_REQUEST\n\n \nstatic void mmc_should_fail_request(struct mmc_host *host,\n\t\t\t\t    struct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd = mrq->cmd;\n\tstruct mmc_data *data = mrq->data;\n\tstatic const int data_errors[] = {\n\t\t-ETIMEDOUT,\n\t\t-EILSEQ,\n\t\t-EIO,\n\t};\n\n\tif (!data)\n\t\treturn;\n\n\tif ((cmd && cmd->error) || data->error ||\n\t    !should_fail(&host->fail_mmc_request, data->blksz * data->blocks))\n\t\treturn;\n\n\tdata->error = data_errors[get_random_u32_below(ARRAY_SIZE(data_errors))];\n\tdata->bytes_xfered = get_random_u32_below(data->bytes_xfered >> 9) << 9;\n}\n\n#else  \n\nstatic inline void mmc_should_fail_request(struct mmc_host *host,\n\t\t\t\t\t   struct mmc_request *mrq)\n{\n}\n\n#endif  \n\nstatic inline void mmc_complete_cmd(struct mmc_request *mrq)\n{\n\tif (mrq->cap_cmd_during_tfr && !completion_done(&mrq->cmd_completion))\n\t\tcomplete_all(&mrq->cmd_completion);\n}\n\nvoid mmc_command_done(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tif (!mrq->cap_cmd_during_tfr)\n\t\treturn;\n\n\tmmc_complete_cmd(mrq);\n\n\tpr_debug(\"%s: cmd done, tfr ongoing (CMD%u)\\n\",\n\t\t mmc_hostname(host), mrq->cmd->opcode);\n}\nEXPORT_SYMBOL(mmc_command_done);\n\n \nvoid mmc_request_done(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd = mrq->cmd;\n\tint err = cmd->error;\n\n\t \n\tif (!mmc_op_tuning(cmd->opcode) &&\n\t    !host->retune_crc_disable &&\n\t    (err == -EILSEQ || (mrq->sbc && mrq->sbc->error == -EILSEQ) ||\n\t    (mrq->data && mrq->data->error == -EILSEQ) ||\n\t    (mrq->stop && mrq->stop->error == -EILSEQ)))\n\t\tmmc_retune_needed(host);\n\n\tif (err && cmd->retries && mmc_host_is_spi(host)) {\n\t\tif (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)\n\t\t\tcmd->retries = 0;\n\t}\n\n\tif (host->ongoing_mrq == mrq)\n\t\thost->ongoing_mrq = NULL;\n\n\tmmc_complete_cmd(mrq);\n\n\ttrace_mmc_request_done(host, mrq);\n\n\t \n\tif (!err || !cmd->retries || mmc_card_removed(host->card)) {\n\t\tmmc_should_fail_request(host, mrq);\n\n\t\tif (!host->ongoing_mrq)\n\t\t\tled_trigger_event(host->led, LED_OFF);\n\n\t\tif (mrq->sbc) {\n\t\t\tpr_debug(\"%s: req done <CMD%u>: %d: %08x %08x %08x %08x\\n\",\n\t\t\t\tmmc_hostname(host), mrq->sbc->opcode,\n\t\t\t\tmrq->sbc->error,\n\t\t\t\tmrq->sbc->resp[0], mrq->sbc->resp[1],\n\t\t\t\tmrq->sbc->resp[2], mrq->sbc->resp[3]);\n\t\t}\n\n\t\tpr_debug(\"%s: req done (CMD%u): %d: %08x %08x %08x %08x\\n\",\n\t\t\tmmc_hostname(host), cmd->opcode, err,\n\t\t\tcmd->resp[0], cmd->resp[1],\n\t\t\tcmd->resp[2], cmd->resp[3]);\n\n\t\tif (mrq->data) {\n\t\t\tpr_debug(\"%s:     %d bytes transferred: %d\\n\",\n\t\t\t\tmmc_hostname(host),\n\t\t\t\tmrq->data->bytes_xfered, mrq->data->error);\n\t\t}\n\n\t\tif (mrq->stop) {\n\t\t\tpr_debug(\"%s:     (CMD%u): %d: %08x %08x %08x %08x\\n\",\n\t\t\t\tmmc_hostname(host), mrq->stop->opcode,\n\t\t\t\tmrq->stop->error,\n\t\t\t\tmrq->stop->resp[0], mrq->stop->resp[1],\n\t\t\t\tmrq->stop->resp[2], mrq->stop->resp[3]);\n\t\t}\n\t}\n\t \n\tif (mrq->done)\n\t\tmrq->done(mrq);\n}\n\nEXPORT_SYMBOL(mmc_request_done);\n\nstatic void __mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tint err;\n\n\t \n\terr = mmc_retune(host);\n\tif (err) {\n\t\tmrq->cmd->error = err;\n\t\tmmc_request_done(host, mrq);\n\t\treturn;\n\t}\n\n\t \n\tif (sdio_is_io_busy(mrq->cmd->opcode, mrq->cmd->arg) &&\n\t    host->ops->card_busy) {\n\t\tint tries = 500;  \n\n\t\twhile (host->ops->card_busy(host) && --tries)\n\t\t\tmmc_delay(1);\n\n\t\tif (tries == 0) {\n\t\t\tmrq->cmd->error = -EBUSY;\n\t\t\tmmc_request_done(host, mrq);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (mrq->cap_cmd_during_tfr) {\n\t\thost->ongoing_mrq = mrq;\n\t\t \n\t\treinit_completion(&mrq->cmd_completion);\n\t}\n\n\ttrace_mmc_request_start(host, mrq);\n\n\tif (host->cqe_on)\n\t\thost->cqe_ops->cqe_off(host);\n\n\thost->ops->request(host, mrq);\n}\n\nstatic void mmc_mrq_pr_debug(struct mmc_host *host, struct mmc_request *mrq,\n\t\t\t     bool cqe)\n{\n\tif (mrq->sbc) {\n\t\tpr_debug(\"<%s: starting CMD%u arg %08x flags %08x>\\n\",\n\t\t\t mmc_hostname(host), mrq->sbc->opcode,\n\t\t\t mrq->sbc->arg, mrq->sbc->flags);\n\t}\n\n\tif (mrq->cmd) {\n\t\tpr_debug(\"%s: starting %sCMD%u arg %08x flags %08x\\n\",\n\t\t\t mmc_hostname(host), cqe ? \"CQE direct \" : \"\",\n\t\t\t mrq->cmd->opcode, mrq->cmd->arg, mrq->cmd->flags);\n\t} else if (cqe) {\n\t\tpr_debug(\"%s: starting CQE transfer for tag %d blkaddr %u\\n\",\n\t\t\t mmc_hostname(host), mrq->tag, mrq->data->blk_addr);\n\t}\n\n\tif (mrq->data) {\n\t\tpr_debug(\"%s:     blksz %d blocks %d flags %08x \"\n\t\t\t\"tsac %d ms nsac %d\\n\",\n\t\t\tmmc_hostname(host), mrq->data->blksz,\n\t\t\tmrq->data->blocks, mrq->data->flags,\n\t\t\tmrq->data->timeout_ns / 1000000,\n\t\t\tmrq->data->timeout_clks);\n\t}\n\n\tif (mrq->stop) {\n\t\tpr_debug(\"%s:     CMD%u arg %08x flags %08x\\n\",\n\t\t\t mmc_hostname(host), mrq->stop->opcode,\n\t\t\t mrq->stop->arg, mrq->stop->flags);\n\t}\n}\n\nstatic int mmc_mrq_prep(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tunsigned int i, sz = 0;\n\tstruct scatterlist *sg;\n\n\tif (mrq->cmd) {\n\t\tmrq->cmd->error = 0;\n\t\tmrq->cmd->mrq = mrq;\n\t\tmrq->cmd->data = mrq->data;\n\t}\n\tif (mrq->sbc) {\n\t\tmrq->sbc->error = 0;\n\t\tmrq->sbc->mrq = mrq;\n\t}\n\tif (mrq->data) {\n\t\tif (mrq->data->blksz > host->max_blk_size ||\n\t\t    mrq->data->blocks > host->max_blk_count ||\n\t\t    mrq->data->blocks * mrq->data->blksz > host->max_req_size)\n\t\t\treturn -EINVAL;\n\n\t\tfor_each_sg(mrq->data->sg, sg, mrq->data->sg_len, i)\n\t\t\tsz += sg->length;\n\t\tif (sz != mrq->data->blocks * mrq->data->blksz)\n\t\t\treturn -EINVAL;\n\n\t\tmrq->data->error = 0;\n\t\tmrq->data->mrq = mrq;\n\t\tif (mrq->stop) {\n\t\t\tmrq->data->stop = mrq->stop;\n\t\t\tmrq->stop->error = 0;\n\t\t\tmrq->stop->mrq = mrq;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint mmc_start_request(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tint err;\n\n\tinit_completion(&mrq->cmd_completion);\n\n\tmmc_retune_hold(host);\n\n\tif (mmc_card_removed(host->card))\n\t\treturn -ENOMEDIUM;\n\n\tmmc_mrq_pr_debug(host, mrq, false);\n\n\tWARN_ON(!host->claimed);\n\n\terr = mmc_mrq_prep(host, mrq);\n\tif (err)\n\t\treturn err;\n\n\tled_trigger_event(host->led, LED_FULL);\n\t__mmc_start_request(host, mrq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_start_request);\n\nstatic void mmc_wait_done(struct mmc_request *mrq)\n{\n\tcomplete(&mrq->completion);\n}\n\nstatic inline void mmc_wait_ongoing_tfr_cmd(struct mmc_host *host)\n{\n\tstruct mmc_request *ongoing_mrq = READ_ONCE(host->ongoing_mrq);\n\n\t \n\tif (ongoing_mrq && !completion_done(&ongoing_mrq->cmd_completion))\n\t\twait_for_completion(&ongoing_mrq->cmd_completion);\n}\n\nstatic int __mmc_start_req(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tint err;\n\n\tmmc_wait_ongoing_tfr_cmd(host);\n\n\tinit_completion(&mrq->completion);\n\tmrq->done = mmc_wait_done;\n\n\terr = mmc_start_request(host, mrq);\n\tif (err) {\n\t\tmrq->cmd->error = err;\n\t\tmmc_complete_cmd(mrq);\n\t\tcomplete(&mrq->completion);\n\t}\n\n\treturn err;\n}\n\nvoid mmc_wait_for_req_done(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tstruct mmc_command *cmd;\n\n\twhile (1) {\n\t\twait_for_completion(&mrq->completion);\n\n\t\tcmd = mrq->cmd;\n\n\t\tif (!cmd->error || !cmd->retries ||\n\t\t    mmc_card_removed(host->card))\n\t\t\tbreak;\n\n\t\tmmc_retune_recheck(host);\n\n\t\tpr_debug(\"%s: req failed (CMD%u): %d, retrying...\\n\",\n\t\t\t mmc_hostname(host), cmd->opcode, cmd->error);\n\t\tcmd->retries--;\n\t\tcmd->error = 0;\n\t\t__mmc_start_request(host, mrq);\n\t}\n\n\tmmc_retune_release(host);\n}\nEXPORT_SYMBOL(mmc_wait_for_req_done);\n\n \nint mmc_cqe_start_req(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tint err;\n\n\t \n\terr = mmc_retune(host);\n\tif (err)\n\t\tgoto out_err;\n\n\tmrq->host = host;\n\n\tmmc_mrq_pr_debug(host, mrq, true);\n\n\terr = mmc_mrq_prep(host, mrq);\n\tif (err)\n\t\tgoto out_err;\n\n\terr = host->cqe_ops->cqe_request(host, mrq);\n\tif (err)\n\t\tgoto out_err;\n\n\ttrace_mmc_request_start(host, mrq);\n\n\treturn 0;\n\nout_err:\n\tif (mrq->cmd) {\n\t\tpr_debug(\"%s: failed to start CQE direct CMD%u, error %d\\n\",\n\t\t\t mmc_hostname(host), mrq->cmd->opcode, err);\n\t} else {\n\t\tpr_debug(\"%s: failed to start CQE transfer for tag %d, error %d\\n\",\n\t\t\t mmc_hostname(host), mrq->tag, err);\n\t}\n\treturn err;\n}\nEXPORT_SYMBOL(mmc_cqe_start_req);\n\n \nvoid mmc_cqe_request_done(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tmmc_should_fail_request(host, mrq);\n\n\t \n\tif ((mrq->cmd && mrq->cmd->error == -EILSEQ) ||\n\t    (mrq->data && mrq->data->error == -EILSEQ))\n\t\tmmc_retune_needed(host);\n\n\ttrace_mmc_request_done(host, mrq);\n\n\tif (mrq->cmd) {\n\t\tpr_debug(\"%s: CQE req done (direct CMD%u): %d\\n\",\n\t\t\t mmc_hostname(host), mrq->cmd->opcode, mrq->cmd->error);\n\t} else {\n\t\tpr_debug(\"%s: CQE transfer done tag %d\\n\",\n\t\t\t mmc_hostname(host), mrq->tag);\n\t}\n\n\tif (mrq->data) {\n\t\tpr_debug(\"%s:     %d bytes transferred: %d\\n\",\n\t\t\t mmc_hostname(host),\n\t\t\t mrq->data->bytes_xfered, mrq->data->error);\n\t}\n\n\tmrq->done(mrq);\n}\nEXPORT_SYMBOL(mmc_cqe_request_done);\n\n \nvoid mmc_cqe_post_req(struct mmc_host *host, struct mmc_request *mrq)\n{\n\tif (host->cqe_ops->cqe_post_req)\n\t\thost->cqe_ops->cqe_post_req(host, mrq);\n}\nEXPORT_SYMBOL(mmc_cqe_post_req);\n\n \n#define MMC_CQE_RECOVERY_TIMEOUT\t1000\n\n \nint mmc_cqe_recovery(struct mmc_host *host)\n{\n\tstruct mmc_command cmd;\n\tint err;\n\n\tmmc_retune_hold_now(host);\n\n\t \n\tpr_warn(\"%s: running CQE recovery\\n\", mmc_hostname(host));\n\n\thost->cqe_ops->cqe_recovery_start(host);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.opcode       = MMC_STOP_TRANSMISSION;\n\tcmd.flags        = MMC_RSP_R1B | MMC_CMD_AC;\n\tcmd.flags       &= ~MMC_RSP_CRC;  \n\tcmd.busy_timeout = MMC_CQE_RECOVERY_TIMEOUT;\n\tmmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\n\tmmc_poll_for_busy(host->card, MMC_CQE_RECOVERY_TIMEOUT, true, MMC_BUSY_IO);\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.opcode       = MMC_CMDQ_TASK_MGMT;\n\tcmd.arg          = 1;  \n\tcmd.flags        = MMC_RSP_R1B | MMC_CMD_AC;\n\tcmd.flags       &= ~MMC_RSP_CRC;  \n\tcmd.busy_timeout = MMC_CQE_RECOVERY_TIMEOUT;\n\terr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\n\thost->cqe_ops->cqe_recovery_finish(host);\n\n\tif (err)\n\t\terr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\n\tmmc_retune_release(host);\n\n\treturn err;\n}\nEXPORT_SYMBOL(mmc_cqe_recovery);\n\n \nbool mmc_is_req_done(struct mmc_host *host, struct mmc_request *mrq)\n{\n\treturn completion_done(&mrq->completion);\n}\nEXPORT_SYMBOL(mmc_is_req_done);\n\n \nvoid mmc_wait_for_req(struct mmc_host *host, struct mmc_request *mrq)\n{\n\t__mmc_start_req(host, mrq);\n\n\tif (!mrq->cap_cmd_during_tfr)\n\t\tmmc_wait_for_req_done(host, mrq);\n}\nEXPORT_SYMBOL(mmc_wait_for_req);\n\n \nint mmc_wait_for_cmd(struct mmc_host *host, struct mmc_command *cmd, int retries)\n{\n\tstruct mmc_request mrq = {};\n\n\tWARN_ON(!host->claimed);\n\n\tmemset(cmd->resp, 0, sizeof(cmd->resp));\n\tcmd->retries = retries;\n\n\tmrq.cmd = cmd;\n\tcmd->data = NULL;\n\n\tmmc_wait_for_req(host, &mrq);\n\n\treturn cmd->error;\n}\n\nEXPORT_SYMBOL(mmc_wait_for_cmd);\n\n \nvoid mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)\n{\n\tunsigned int mult;\n\n\t \n\tif (mmc_card_sdio(card)) {\n\t\tdata->timeout_ns = 1000000000;\n\t\tdata->timeout_clks = 0;\n\t\treturn;\n\t}\n\n\t \n\tmult = mmc_card_sd(card) ? 100 : 10;\n\n\t \n\tif (data->flags & MMC_DATA_WRITE)\n\t\tmult <<= card->csd.r2w_factor;\n\n\tdata->timeout_ns = card->csd.taac_ns * mult;\n\tdata->timeout_clks = card->csd.taac_clks * mult;\n\n\t \n\tif (mmc_card_sd(card)) {\n\t\tunsigned int timeout_us, limit_us;\n\n\t\ttimeout_us = data->timeout_ns / 1000;\n\t\tif (card->host->ios.clock)\n\t\t\ttimeout_us += data->timeout_clks * 1000 /\n\t\t\t\t(card->host->ios.clock / 1000);\n\n\t\tif (data->flags & MMC_DATA_WRITE)\n\t\t\t \n\t\t\tlimit_us = 3000000;\n\t\telse\n\t\t\tlimit_us = 100000;\n\n\t\t \n\t\tif (timeout_us > limit_us) {\n\t\t\tdata->timeout_ns = limit_us * 1000;\n\t\t\tdata->timeout_clks = 0;\n\t\t}\n\n\t\t \n\t\tif (timeout_us == 0)\n\t\t\tdata->timeout_ns = limit_us * 1000;\n\t}\n\n\t \n\tif (mmc_card_long_read_time(card) && data->flags & MMC_DATA_READ) {\n\t\tdata->timeout_ns = 600000000;\n\t\tdata->timeout_clks = 0;\n\t}\n\n\t \n\tif (mmc_host_is_spi(card->host)) {\n\t\tif (data->flags & MMC_DATA_WRITE) {\n\t\t\tif (data->timeout_ns < 1000000000)\n\t\t\t\tdata->timeout_ns = 1000000000;\t \n\t\t} else {\n\t\t\tif (data->timeout_ns < 100000000)\n\t\t\t\tdata->timeout_ns =  100000000;\t \n\t\t}\n\t}\n}\nEXPORT_SYMBOL(mmc_set_data_timeout);\n\n \nstatic inline bool mmc_ctx_matches(struct mmc_host *host, struct mmc_ctx *ctx,\n\t\t\t\t   struct task_struct *task)\n{\n\treturn host->claimer == ctx ||\n\t       (!ctx && task && host->claimer->task == task);\n}\n\nstatic inline void mmc_ctx_set_claimer(struct mmc_host *host,\n\t\t\t\t       struct mmc_ctx *ctx,\n\t\t\t\t       struct task_struct *task)\n{\n\tif (!host->claimer) {\n\t\tif (ctx)\n\t\t\thost->claimer = ctx;\n\t\telse\n\t\t\thost->claimer = &host->default_ctx;\n\t}\n\tif (task)\n\t\thost->claimer->task = task;\n}\n\n \nint __mmc_claim_host(struct mmc_host *host, struct mmc_ctx *ctx,\n\t\t     atomic_t *abort)\n{\n\tstruct task_struct *task = ctx ? NULL : current;\n\tDECLARE_WAITQUEUE(wait, current);\n\tunsigned long flags;\n\tint stop;\n\tbool pm = false;\n\n\tmight_sleep();\n\n\tadd_wait_queue(&host->wq, &wait);\n\tspin_lock_irqsave(&host->lock, flags);\n\twhile (1) {\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tstop = abort ? atomic_read(abort) : 0;\n\t\tif (stop || !host->claimed || mmc_ctx_matches(host, ctx, task))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\tschedule();\n\t\tspin_lock_irqsave(&host->lock, flags);\n\t}\n\tset_current_state(TASK_RUNNING);\n\tif (!stop) {\n\t\thost->claimed = 1;\n\t\tmmc_ctx_set_claimer(host, ctx, task);\n\t\thost->claim_cnt += 1;\n\t\tif (host->claim_cnt == 1)\n\t\t\tpm = true;\n\t} else\n\t\twake_up(&host->wq);\n\tspin_unlock_irqrestore(&host->lock, flags);\n\tremove_wait_queue(&host->wq, &wait);\n\n\tif (pm)\n\t\tpm_runtime_get_sync(mmc_dev(host));\n\n\treturn stop;\n}\nEXPORT_SYMBOL(__mmc_claim_host);\n\n \nvoid mmc_release_host(struct mmc_host *host)\n{\n\tunsigned long flags;\n\n\tWARN_ON(!host->claimed);\n\n\tspin_lock_irqsave(&host->lock, flags);\n\tif (--host->claim_cnt) {\n\t\t \n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t} else {\n\t\thost->claimed = 0;\n\t\thost->claimer->task = NULL;\n\t\thost->claimer = NULL;\n\t\tspin_unlock_irqrestore(&host->lock, flags);\n\t\twake_up(&host->wq);\n\t\tpm_runtime_mark_last_busy(mmc_dev(host));\n\t\tif (host->caps & MMC_CAP_SYNC_RUNTIME_PM)\n\t\t\tpm_runtime_put_sync_suspend(mmc_dev(host));\n\t\telse\n\t\t\tpm_runtime_put_autosuspend(mmc_dev(host));\n\t}\n}\nEXPORT_SYMBOL(mmc_release_host);\n\n \nvoid mmc_get_card(struct mmc_card *card, struct mmc_ctx *ctx)\n{\n\tpm_runtime_get_sync(&card->dev);\n\t__mmc_claim_host(card->host, ctx, NULL);\n}\nEXPORT_SYMBOL(mmc_get_card);\n\n \nvoid mmc_put_card(struct mmc_card *card, struct mmc_ctx *ctx)\n{\n\tstruct mmc_host *host = card->host;\n\n\tWARN_ON(ctx && host->claimer != ctx);\n\n\tmmc_release_host(host);\n\tpm_runtime_mark_last_busy(&card->dev);\n\tpm_runtime_put_autosuspend(&card->dev);\n}\nEXPORT_SYMBOL(mmc_put_card);\n\n \nstatic inline void mmc_set_ios(struct mmc_host *host)\n{\n\tstruct mmc_ios *ios = &host->ios;\n\n\tpr_debug(\"%s: clock %uHz busmode %u powermode %u cs %u Vdd %u \"\n\t\t\"width %u timing %u\\n\",\n\t\t mmc_hostname(host), ios->clock, ios->bus_mode,\n\t\t ios->power_mode, ios->chip_select, ios->vdd,\n\t\t 1 << ios->bus_width, ios->timing);\n\n\thost->ops->set_ios(host, ios);\n}\n\n \nvoid mmc_set_chip_select(struct mmc_host *host, int mode)\n{\n\thost->ios.chip_select = mode;\n\tmmc_set_ios(host);\n}\n\n \nvoid mmc_set_clock(struct mmc_host *host, unsigned int hz)\n{\n\tWARN_ON(hz && hz < host->f_min);\n\n\tif (hz > host->f_max)\n\t\thz = host->f_max;\n\n\thost->ios.clock = hz;\n\tmmc_set_ios(host);\n}\n\nint mmc_execute_tuning(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tu32 opcode;\n\tint err;\n\n\tif (!host->ops->execute_tuning)\n\t\treturn 0;\n\n\tif (host->cqe_on)\n\t\thost->cqe_ops->cqe_off(host);\n\n\tif (mmc_card_mmc(card))\n\t\topcode = MMC_SEND_TUNING_BLOCK_HS200;\n\telse\n\t\topcode = MMC_SEND_TUNING_BLOCK;\n\n\terr = host->ops->execute_tuning(host, opcode);\n\tif (!err) {\n\t\tmmc_retune_clear(host);\n\t\tmmc_retune_enable(host);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!host->detect_change) {\n\t\tpr_err(\"%s: tuning execution failed: %d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tmmc_debugfs_err_stats_inc(host, MMC_ERR_TUNING);\n\t}\n\n\treturn err;\n}\n\n \nvoid mmc_set_bus_mode(struct mmc_host *host, unsigned int mode)\n{\n\thost->ios.bus_mode = mode;\n\tmmc_set_ios(host);\n}\n\n \nvoid mmc_set_bus_width(struct mmc_host *host, unsigned int width)\n{\n\thost->ios.bus_width = width;\n\tmmc_set_ios(host);\n}\n\n \nvoid mmc_set_initial_state(struct mmc_host *host)\n{\n\tif (host->cqe_on)\n\t\thost->cqe_ops->cqe_off(host);\n\n\tmmc_retune_disable(host);\n\n\tif (mmc_host_is_spi(host))\n\t\thost->ios.chip_select = MMC_CS_HIGH;\n\telse\n\t\thost->ios.chip_select = MMC_CS_DONTCARE;\n\thost->ios.bus_mode = MMC_BUSMODE_PUSHPULL;\n\thost->ios.bus_width = MMC_BUS_WIDTH_1;\n\thost->ios.timing = MMC_TIMING_LEGACY;\n\thost->ios.drv_type = 0;\n\thost->ios.enhanced_strobe = false;\n\n\t \n\tif ((host->caps2 & MMC_CAP2_HS400_ES) &&\n\t     host->ops->hs400_enhanced_strobe)\n\t\thost->ops->hs400_enhanced_strobe(host, &host->ios);\n\n\tmmc_set_ios(host);\n\n\tmmc_crypto_set_initial_state(host);\n}\n\n \nstatic int mmc_vdd_to_ocrbitnum(int vdd, bool low_bits)\n{\n\tconst int max_bit = ilog2(MMC_VDD_35_36);\n\tint bit;\n\n\tif (vdd < 1650 || vdd > 3600)\n\t\treturn -EINVAL;\n\n\tif (vdd >= 1650 && vdd <= 1950)\n\t\treturn ilog2(MMC_VDD_165_195);\n\n\tif (low_bits)\n\t\tvdd -= 1;\n\n\t \n\tbit = (vdd - 2000) / 100 + 8;\n\tif (bit > max_bit)\n\t\treturn max_bit;\n\treturn bit;\n}\n\n \nu32 mmc_vddrange_to_ocrmask(int vdd_min, int vdd_max)\n{\n\tu32 mask = 0;\n\n\tif (vdd_max < vdd_min)\n\t\treturn 0;\n\n\t \n\tvdd_max = mmc_vdd_to_ocrbitnum(vdd_max, false);\n\tif (vdd_max < 0)\n\t\treturn 0;\n\n\t \n\tvdd_min = mmc_vdd_to_ocrbitnum(vdd_min, true);\n\tif (vdd_min < 0)\n\t\treturn 0;\n\n\t \n\twhile (vdd_max >= vdd_min)\n\t\tmask |= 1 << vdd_max--;\n\n\treturn mask;\n}\n\nstatic int mmc_of_get_func_num(struct device_node *node)\n{\n\tu32 reg;\n\tint ret;\n\n\tret = of_property_read_u32(node, \"reg\", &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn reg;\n}\n\nstruct device_node *mmc_of_find_child_device(struct mmc_host *host,\n\t\tunsigned func_num)\n{\n\tstruct device_node *node;\n\n\tif (!host->parent || !host->parent->of_node)\n\t\treturn NULL;\n\n\tfor_each_child_of_node(host->parent->of_node, node) {\n\t\tif (mmc_of_get_func_num(node) == func_num)\n\t\t\treturn node;\n\t}\n\n\treturn NULL;\n}\n\n \nu32 mmc_select_voltage(struct mmc_host *host, u32 ocr)\n{\n\tint bit;\n\n\t \n\tif (ocr & 0x7F) {\n\t\tdev_warn(mmc_dev(host),\n\t\t\"card claims to support voltages below defined range\\n\");\n\t\tocr &= ~0x7F;\n\t}\n\n\tocr &= host->ocr_avail;\n\tif (!ocr) {\n\t\tdev_warn(mmc_dev(host), \"no support for card's volts\\n\");\n\t\treturn 0;\n\t}\n\n\tif (host->caps2 & MMC_CAP2_FULL_PWR_CYCLE) {\n\t\tbit = ffs(ocr) - 1;\n\t\tocr &= 3 << bit;\n\t\tmmc_power_cycle(host, ocr);\n\t} else {\n\t\tbit = fls(ocr) - 1;\n\t\t \n\t\tocr &= 3 << (bit - 1);\n\t\tif (bit != host->ios.vdd)\n\t\t\tdev_warn(mmc_dev(host), \"exceeding card's volts\\n\");\n\t}\n\n\treturn ocr;\n}\n\nint mmc_set_signal_voltage(struct mmc_host *host, int signal_voltage)\n{\n\tint err = 0;\n\tint old_signal_voltage = host->ios.signal_voltage;\n\n\thost->ios.signal_voltage = signal_voltage;\n\tif (host->ops->start_signal_voltage_switch)\n\t\terr = host->ops->start_signal_voltage_switch(host, &host->ios);\n\n\tif (err)\n\t\thost->ios.signal_voltage = old_signal_voltage;\n\n\treturn err;\n\n}\n\nvoid mmc_set_initial_signal_voltage(struct mmc_host *host)\n{\n\t \n\tif (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330))\n\t\tdev_dbg(mmc_dev(host), \"Initial signal voltage of 3.3v\\n\");\n\telse if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))\n\t\tdev_dbg(mmc_dev(host), \"Initial signal voltage of 1.8v\\n\");\n\telse if (!mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120))\n\t\tdev_dbg(mmc_dev(host), \"Initial signal voltage of 1.2v\\n\");\n}\n\nint mmc_host_set_uhs_voltage(struct mmc_host *host)\n{\n\tu32 clock;\n\n\t \n\tclock = host->ios.clock;\n\thost->ios.clock = 0;\n\tmmc_set_ios(host);\n\n\tif (mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180))\n\t\treturn -EAGAIN;\n\n\t \n\tmmc_delay(10);\n\thost->ios.clock = clock;\n\tmmc_set_ios(host);\n\n\treturn 0;\n}\n\nint mmc_set_uhs_voltage(struct mmc_host *host, u32 ocr)\n{\n\tstruct mmc_command cmd = {};\n\tint err = 0;\n\n\t \n\tif (!host->ops->start_signal_voltage_switch)\n\t\treturn -EPERM;\n\tif (!host->ops->card_busy)\n\t\tpr_warn(\"%s: cannot verify signal voltage switch\\n\",\n\t\t\tmmc_hostname(host));\n\n\tcmd.opcode = SD_SWITCH_VOLTAGE;\n\tcmd.arg = 0;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err)\n\t\tgoto power_cycle;\n\n\tif (!mmc_host_is_spi(host) && (cmd.resp[0] & R1_ERROR))\n\t\treturn -EIO;\n\n\t \n\tmmc_delay(1);\n\tif (host->ops->card_busy && !host->ops->card_busy(host)) {\n\t\terr = -EAGAIN;\n\t\tgoto power_cycle;\n\t}\n\n\tif (mmc_host_set_uhs_voltage(host)) {\n\t\t \n\t\terr = -EAGAIN;\n\t\tgoto power_cycle;\n\t}\n\n\t \n\tmmc_delay(1);\n\n\t \n\tif (host->ops->card_busy && host->ops->card_busy(host))\n\t\terr = -EAGAIN;\n\npower_cycle:\n\tif (err) {\n\t\tpr_debug(\"%s: Signal voltage switch failed, \"\n\t\t\t\"power cycling card\\n\", mmc_hostname(host));\n\t\tmmc_power_cycle(host, ocr);\n\t}\n\n\treturn err;\n}\n\n \nvoid mmc_set_timing(struct mmc_host *host, unsigned int timing)\n{\n\thost->ios.timing = timing;\n\tmmc_set_ios(host);\n}\n\n \nvoid mmc_set_driver_type(struct mmc_host *host, unsigned int drv_type)\n{\n\thost->ios.drv_type = drv_type;\n\tmmc_set_ios(host);\n}\n\nint mmc_select_drive_strength(struct mmc_card *card, unsigned int max_dtr,\n\t\t\t      int card_drv_type, int *drv_type)\n{\n\tstruct mmc_host *host = card->host;\n\tint host_drv_type = SD_DRIVER_TYPE_B;\n\n\t*drv_type = 0;\n\n\tif (!host->ops->select_drive_strength)\n\t\treturn 0;\n\n\t \n\tif (host->caps & MMC_CAP_DRIVER_TYPE_A)\n\t\thost_drv_type |= SD_DRIVER_TYPE_A;\n\n\tif (host->caps & MMC_CAP_DRIVER_TYPE_C)\n\t\thost_drv_type |= SD_DRIVER_TYPE_C;\n\n\tif (host->caps & MMC_CAP_DRIVER_TYPE_D)\n\t\thost_drv_type |= SD_DRIVER_TYPE_D;\n\n\t \n\treturn host->ops->select_drive_strength(card, max_dtr,\n\t\t\t\t\t\thost_drv_type,\n\t\t\t\t\t\tcard_drv_type,\n\t\t\t\t\t\tdrv_type);\n}\n\n \nvoid mmc_power_up(struct mmc_host *host, u32 ocr)\n{\n\tif (host->ios.power_mode == MMC_POWER_ON)\n\t\treturn;\n\n\tmmc_pwrseq_pre_power_on(host);\n\n\thost->ios.vdd = fls(ocr) - 1;\n\thost->ios.power_mode = MMC_POWER_UP;\n\t \n\tmmc_set_initial_state(host);\n\n\tmmc_set_initial_signal_voltage(host);\n\n\t \n\tmmc_delay(host->ios.power_delay_ms);\n\n\tmmc_pwrseq_post_power_on(host);\n\n\thost->ios.clock = host->f_init;\n\n\thost->ios.power_mode = MMC_POWER_ON;\n\tmmc_set_ios(host);\n\n\t \n\tmmc_delay(host->ios.power_delay_ms);\n}\n\nvoid mmc_power_off(struct mmc_host *host)\n{\n\tif (host->ios.power_mode == MMC_POWER_OFF)\n\t\treturn;\n\n\tmmc_pwrseq_power_off(host);\n\n\thost->ios.clock = 0;\n\thost->ios.vdd = 0;\n\n\thost->ios.power_mode = MMC_POWER_OFF;\n\t \n\tmmc_set_initial_state(host);\n\n\t \n\tmmc_delay(1);\n}\n\nvoid mmc_power_cycle(struct mmc_host *host, u32 ocr)\n{\n\tmmc_power_off(host);\n\t \n\tmmc_delay(1);\n\tmmc_power_up(host, ocr);\n}\n\n \nvoid mmc_attach_bus(struct mmc_host *host, const struct mmc_bus_ops *ops)\n{\n\thost->bus_ops = ops;\n}\n\n \nvoid mmc_detach_bus(struct mmc_host *host)\n{\n\thost->bus_ops = NULL;\n}\n\nvoid _mmc_detect_change(struct mmc_host *host, unsigned long delay, bool cd_irq)\n{\n\t \n\tif (cd_irq && !(host->caps & MMC_CAP_NEEDS_POLL))\n\t\t__pm_wakeup_event(host->ws, 5000);\n\n\thost->detect_change = 1;\n\tmmc_schedule_delayed_work(&host->detect, delay);\n}\n\n \nvoid mmc_detect_change(struct mmc_host *host, unsigned long delay)\n{\n\t_mmc_detect_change(host, delay, true);\n}\nEXPORT_SYMBOL(mmc_detect_change);\n\nvoid mmc_init_erase(struct mmc_card *card)\n{\n\tunsigned int sz;\n\n\tif (is_power_of_2(card->erase_size))\n\t\tcard->erase_shift = ffs(card->erase_size) - 1;\n\telse\n\t\tcard->erase_shift = 0;\n\n\t \n\tif (mmc_card_sd(card) && card->ssr.au) {\n\t\tcard->pref_erase = card->ssr.au;\n\t\tcard->erase_shift = ffs(card->ssr.au) - 1;\n\t} else if (card->erase_size) {\n\t\tsz = (card->csd.capacity << (card->csd.read_blkbits - 9)) >> 11;\n\t\tif (sz < 128)\n\t\t\tcard->pref_erase = 512 * 1024 / 512;\n\t\telse if (sz < 512)\n\t\t\tcard->pref_erase = 1024 * 1024 / 512;\n\t\telse if (sz < 1024)\n\t\t\tcard->pref_erase = 2 * 1024 * 1024 / 512;\n\t\telse\n\t\t\tcard->pref_erase = 4 * 1024 * 1024 / 512;\n\t\tif (card->pref_erase < card->erase_size)\n\t\t\tcard->pref_erase = card->erase_size;\n\t\telse {\n\t\t\tsz = card->pref_erase % card->erase_size;\n\t\t\tif (sz)\n\t\t\t\tcard->pref_erase += card->erase_size - sz;\n\t\t}\n\t} else\n\t\tcard->pref_erase = 0;\n}\n\nstatic bool is_trim_arg(unsigned int arg)\n{\n\treturn (arg & MMC_TRIM_OR_DISCARD_ARGS) && arg != MMC_DISCARD_ARG;\n}\n\nstatic unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,\n\t\t\t\t          unsigned int arg, unsigned int qty)\n{\n\tunsigned int erase_timeout;\n\n\tif (arg == MMC_DISCARD_ARG ||\n\t    (arg == MMC_TRIM_ARG && card->ext_csd.rev >= 6)) {\n\t\terase_timeout = card->ext_csd.trim_timeout;\n\t} else if (card->ext_csd.erase_group_def & 1) {\n\t\t \n\t\tif (arg == MMC_TRIM_ARG)\n\t\t\terase_timeout = card->ext_csd.trim_timeout;\n\t\telse\n\t\t\terase_timeout = card->ext_csd.hc_erase_timeout;\n\t} else {\n\t\t \n\t\tunsigned int mult = (10 << card->csd.r2w_factor);\n\t\tunsigned int timeout_clks = card->csd.taac_clks * mult;\n\t\tunsigned int timeout_us;\n\n\t\t \n\t\tif (card->csd.taac_ns < 1000000)\n\t\t\ttimeout_us = (card->csd.taac_ns * mult) / 1000;\n\t\telse\n\t\t\ttimeout_us = (card->csd.taac_ns / 1000) * mult;\n\n\t\t \n\t\ttimeout_clks <<= 1;\n\t\ttimeout_us += (timeout_clks * 1000) /\n\t\t\t      (card->host->ios.clock / 1000);\n\n\t\terase_timeout = timeout_us / 1000;\n\n\t\t \n\t\tif (!erase_timeout)\n\t\t\terase_timeout = 1;\n\t}\n\n\t \n\tif (arg & MMC_SECURE_ARGS) {\n\t\tif (arg == MMC_SECURE_ERASE_ARG)\n\t\t\terase_timeout *= card->ext_csd.sec_erase_mult;\n\t\telse\n\t\t\terase_timeout *= card->ext_csd.sec_trim_mult;\n\t}\n\n\terase_timeout *= qty;\n\n\t \n\tif (mmc_host_is_spi(card->host) && erase_timeout < 1000)\n\t\terase_timeout = 1000;\n\n\treturn erase_timeout;\n}\n\nstatic unsigned int mmc_sd_erase_timeout(struct mmc_card *card,\n\t\t\t\t\t unsigned int arg,\n\t\t\t\t\t unsigned int qty)\n{\n\tunsigned int erase_timeout;\n\n\t \n\tif (arg == SD_DISCARD_ARG)\n\t\treturn SD_DISCARD_TIMEOUT_MS;\n\n\tif (card->ssr.erase_timeout) {\n\t\t \n\t\terase_timeout = card->ssr.erase_timeout * qty +\n\t\t\t\tcard->ssr.erase_offset;\n\t} else {\n\t\t \n\t\terase_timeout = 250 * qty;\n\t}\n\n\t \n\tif (erase_timeout < 1000)\n\t\terase_timeout = 1000;\n\n\treturn erase_timeout;\n}\n\nstatic unsigned int mmc_erase_timeout(struct mmc_card *card,\n\t\t\t\t      unsigned int arg,\n\t\t\t\t      unsigned int qty)\n{\n\tif (mmc_card_sd(card))\n\t\treturn mmc_sd_erase_timeout(card, arg, qty);\n\telse\n\t\treturn mmc_mmc_erase_timeout(card, arg, qty);\n}\n\nstatic int mmc_do_erase(struct mmc_card *card, unsigned int from,\n\t\t\tunsigned int to, unsigned int arg)\n{\n\tstruct mmc_command cmd = {};\n\tunsigned int qty = 0, busy_timeout = 0;\n\tbool use_r1b_resp;\n\tint err;\n\n\tmmc_retune_hold(card->host);\n\n\t \n\tif (card->erase_shift)\n\t\tqty += ((to >> card->erase_shift) -\n\t\t\t(from >> card->erase_shift)) + 1;\n\telse if (mmc_card_sd(card))\n\t\tqty += to - from + 1;\n\telse\n\t\tqty += ((to / card->erase_size) -\n\t\t\t(from / card->erase_size)) + 1;\n\n\tif (!mmc_card_blockaddr(card)) {\n\t\tfrom <<= 9;\n\t\tto <<= 9;\n\t}\n\n\tif (mmc_card_sd(card))\n\t\tcmd.opcode = SD_ERASE_WR_BLK_START;\n\telse\n\t\tcmd.opcode = MMC_ERASE_GROUP_START;\n\tcmd.arg = from;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\n\terr = mmc_wait_for_cmd(card->host, &cmd, 0);\n\tif (err) {\n\t\tpr_err(\"mmc_erase: group start error %d, \"\n\t\t       \"status %#x\\n\", err, cmd.resp[0]);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemset(&cmd, 0, sizeof(struct mmc_command));\n\tif (mmc_card_sd(card))\n\t\tcmd.opcode = SD_ERASE_WR_BLK_END;\n\telse\n\t\tcmd.opcode = MMC_ERASE_GROUP_END;\n\tcmd.arg = to;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\n\terr = mmc_wait_for_cmd(card->host, &cmd, 0);\n\tif (err) {\n\t\tpr_err(\"mmc_erase: group end error %d, status %#x\\n\",\n\t\t       err, cmd.resp[0]);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tmemset(&cmd, 0, sizeof(struct mmc_command));\n\tcmd.opcode = MMC_ERASE;\n\tcmd.arg = arg;\n\tbusy_timeout = mmc_erase_timeout(card, arg, qty);\n\tuse_r1b_resp = mmc_prepare_busy_cmd(card->host, &cmd, busy_timeout);\n\n\terr = mmc_wait_for_cmd(card->host, &cmd, 0);\n\tif (err) {\n\t\tpr_err(\"mmc_erase: erase error %d, status %#x\\n\",\n\t\t       err, cmd.resp[0]);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (mmc_host_is_spi(card->host))\n\t\tgoto out;\n\n\t \n\tif ((card->host->caps & MMC_CAP_WAIT_WHILE_BUSY) && use_r1b_resp)\n\t\tgoto out;\n\n\t \n\terr = mmc_poll_for_busy(card, busy_timeout, false, MMC_BUSY_ERASE);\n\nout:\n\tmmc_retune_release(card->host);\n\treturn err;\n}\n\nstatic unsigned int mmc_align_erase_size(struct mmc_card *card,\n\t\t\t\t\t unsigned int *from,\n\t\t\t\t\t unsigned int *to,\n\t\t\t\t\t unsigned int nr)\n{\n\tunsigned int from_new = *from, nr_new = nr, rem;\n\n\t \n\tif (is_power_of_2(card->erase_size)) {\n\t\tunsigned int temp = from_new;\n\n\t\tfrom_new = round_up(temp, card->erase_size);\n\t\trem = from_new - temp;\n\n\t\tif (nr_new > rem)\n\t\t\tnr_new -= rem;\n\t\telse\n\t\t\treturn 0;\n\n\t\tnr_new = round_down(nr_new, card->erase_size);\n\t} else {\n\t\trem = from_new % card->erase_size;\n\t\tif (rem) {\n\t\t\trem = card->erase_size - rem;\n\t\t\tfrom_new += rem;\n\t\t\tif (nr_new > rem)\n\t\t\t\tnr_new -= rem;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t}\n\n\t\trem = nr_new % card->erase_size;\n\t\tif (rem)\n\t\t\tnr_new -= rem;\n\t}\n\n\tif (nr_new == 0)\n\t\treturn 0;\n\n\t*to = from_new + nr_new;\n\t*from = from_new;\n\n\treturn nr_new;\n}\n\n \nint mmc_erase(struct mmc_card *card, unsigned int from, unsigned int nr,\n\t      unsigned int arg)\n{\n\tunsigned int rem, to = from + nr;\n\tint err;\n\n\tif (!(card->csd.cmdclass & CCC_ERASE))\n\t\treturn -EOPNOTSUPP;\n\n\tif (!card->erase_size)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mmc_card_sd(card) && arg != SD_ERASE_ARG && arg != SD_DISCARD_ARG)\n\t\treturn -EOPNOTSUPP;\n\n\tif (mmc_card_mmc(card) && (arg & MMC_SECURE_ARGS) &&\n\t    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN))\n\t\treturn -EOPNOTSUPP;\n\n\tif (mmc_card_mmc(card) && is_trim_arg(arg) &&\n\t    !(card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN))\n\t\treturn -EOPNOTSUPP;\n\n\tif (arg == MMC_SECURE_ERASE_ARG) {\n\t\tif (from % card->erase_size || nr % card->erase_size)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (arg == MMC_ERASE_ARG)\n\t\tnr = mmc_align_erase_size(card, &from, &to, nr);\n\n\tif (nr == 0)\n\t\treturn 0;\n\n\tif (to <= from)\n\t\treturn -EINVAL;\n\n\t \n\tto -= 1;\n\n\t \n\trem = card->erase_size - (from % card->erase_size);\n\tif ((arg & MMC_TRIM_OR_DISCARD_ARGS) && card->eg_boundary && nr > rem) {\n\t\terr = mmc_do_erase(card, from, from + rem - 1, arg);\n\t\tfrom += rem;\n\t\tif ((err) || (to <= from))\n\t\t\treturn err;\n\t}\n\n\treturn mmc_do_erase(card, from, to, arg);\n}\nEXPORT_SYMBOL(mmc_erase);\n\nint mmc_can_erase(struct mmc_card *card)\n{\n\tif (card->csd.cmdclass & CCC_ERASE && card->erase_size)\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_can_erase);\n\nint mmc_can_trim(struct mmc_card *card)\n{\n\tif ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_GB_CL_EN) &&\n\t    (!(card->quirks & MMC_QUIRK_TRIM_BROKEN)))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_can_trim);\n\nint mmc_can_discard(struct mmc_card *card)\n{\n\t \n\tif (card->ext_csd.feature_support & MMC_DISCARD_FEATURE)\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_can_discard);\n\nint mmc_can_sanitize(struct mmc_card *card)\n{\n\tif (!mmc_can_trim(card) && !mmc_can_erase(card))\n\t\treturn 0;\n\tif (card->ext_csd.sec_feature_support & EXT_CSD_SEC_SANITIZE)\n\t\treturn 1;\n\treturn 0;\n}\n\nint mmc_can_secure_erase_trim(struct mmc_card *card)\n{\n\tif ((card->ext_csd.sec_feature_support & EXT_CSD_SEC_ER_EN) &&\n\t    !(card->quirks & MMC_QUIRK_SEC_ERASE_TRIM_BROKEN))\n\t\treturn 1;\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_can_secure_erase_trim);\n\nint mmc_erase_group_aligned(struct mmc_card *card, unsigned int from,\n\t\t\t    unsigned int nr)\n{\n\tif (!card->erase_size)\n\t\treturn 0;\n\tif (from % card->erase_size || nr % card->erase_size)\n\t\treturn 0;\n\treturn 1;\n}\nEXPORT_SYMBOL(mmc_erase_group_aligned);\n\nstatic unsigned int mmc_do_calc_max_discard(struct mmc_card *card,\n\t\t\t\t\t    unsigned int arg)\n{\n\tstruct mmc_host *host = card->host;\n\tunsigned int max_discard, x, y, qty = 0, max_qty, min_qty, timeout;\n\tunsigned int last_timeout = 0;\n\tunsigned int max_busy_timeout = host->max_busy_timeout ?\n\t\t\thost->max_busy_timeout : MMC_ERASE_TIMEOUT_MS;\n\n\tif (card->erase_shift) {\n\t\tmax_qty = UINT_MAX >> card->erase_shift;\n\t\tmin_qty = card->pref_erase >> card->erase_shift;\n\t} else if (mmc_card_sd(card)) {\n\t\tmax_qty = UINT_MAX;\n\t\tmin_qty = card->pref_erase;\n\t} else {\n\t\tmax_qty = UINT_MAX / card->erase_size;\n\t\tmin_qty = card->pref_erase / card->erase_size;\n\t}\n\n\t \n\tdo {\n\t\ty = 0;\n\t\tfor (x = 1; x && x <= max_qty && max_qty - x >= qty; x <<= 1) {\n\t\t\ttimeout = mmc_erase_timeout(card, arg, qty + x);\n\n\t\t\tif (qty + x > min_qty && timeout > max_busy_timeout)\n\t\t\t\tbreak;\n\n\t\t\tif (timeout < last_timeout)\n\t\t\t\tbreak;\n\t\t\tlast_timeout = timeout;\n\t\t\ty = x;\n\t\t}\n\t\tqty += y;\n\t} while (y);\n\n\tif (!qty)\n\t\treturn 0;\n\n\t \n\tif (qty == 1)\n\t\tcard->eg_boundary = 1;\n\telse\n\t\tqty--;\n\n\t \n\tif (card->erase_shift)\n\t\tmax_discard = qty << card->erase_shift;\n\telse if (mmc_card_sd(card))\n\t\tmax_discard = qty + 1;\n\telse\n\t\tmax_discard = qty * card->erase_size;\n\n\treturn max_discard;\n}\n\nunsigned int mmc_calc_max_discard(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tunsigned int max_discard, max_trim;\n\n\t \n\tif (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))\n\t\treturn card->pref_erase;\n\n\tmax_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);\n\tif (mmc_can_trim(card)) {\n\t\tmax_trim = mmc_do_calc_max_discard(card, MMC_TRIM_ARG);\n\t\tif (max_trim < max_discard || max_discard == 0)\n\t\t\tmax_discard = max_trim;\n\t} else if (max_discard < card->erase_size) {\n\t\tmax_discard = 0;\n\t}\n\tpr_debug(\"%s: calculated max. discard sectors %u for timeout %u ms\\n\",\n\t\tmmc_hostname(host), max_discard, host->max_busy_timeout ?\n\t\thost->max_busy_timeout : MMC_ERASE_TIMEOUT_MS);\n\treturn max_discard;\n}\nEXPORT_SYMBOL(mmc_calc_max_discard);\n\nbool mmc_card_is_blockaddr(struct mmc_card *card)\n{\n\treturn card ? mmc_card_blockaddr(card) : false;\n}\nEXPORT_SYMBOL(mmc_card_is_blockaddr);\n\nint mmc_set_blocklen(struct mmc_card *card, unsigned int blocklen)\n{\n\tstruct mmc_command cmd = {};\n\n\tif (mmc_card_blockaddr(card) || mmc_card_ddr52(card) ||\n\t    mmc_card_hs400(card) || mmc_card_hs400es(card))\n\t\treturn 0;\n\n\tcmd.opcode = MMC_SET_BLOCKLEN;\n\tcmd.arg = blocklen;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\n\treturn mmc_wait_for_cmd(card->host, &cmd, 5);\n}\nEXPORT_SYMBOL(mmc_set_blocklen);\n\nstatic void mmc_hw_reset_for_init(struct mmc_host *host)\n{\n\tmmc_pwrseq_reset(host);\n\n\tif (!(host->caps & MMC_CAP_HW_RESET) || !host->ops->card_hw_reset)\n\t\treturn;\n\thost->ops->card_hw_reset(host);\n}\n\n \nint mmc_hw_reset(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tint ret;\n\n\tret = host->bus_ops->hw_reset(host);\n\tif (ret < 0)\n\t\tpr_warn(\"%s: tried to HW reset card, got error %d\\n\",\n\t\t\tmmc_hostname(host), ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mmc_hw_reset);\n\nint mmc_sw_reset(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tint ret;\n\n\tif (!host->bus_ops->sw_reset)\n\t\treturn -EOPNOTSUPP;\n\n\tret = host->bus_ops->sw_reset(host);\n\tif (ret)\n\t\tpr_warn(\"%s: tried to SW reset card, got error %d\\n\",\n\t\t\tmmc_hostname(host), ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mmc_sw_reset);\n\nstatic int mmc_rescan_try_freq(struct mmc_host *host, unsigned freq)\n{\n\thost->f_init = freq;\n\n\tpr_debug(\"%s: %s: trying to init card at %u Hz\\n\",\n\t\tmmc_hostname(host), __func__, host->f_init);\n\n\tmmc_power_up(host, host->ocr_avail);\n\n\t \n\tmmc_hw_reset_for_init(host);\n\n\t \n\tif (!(host->caps2 & MMC_CAP2_NO_SDIO))\n\t\tsdio_reset(host);\n\n\tmmc_go_idle(host);\n\n\tif (!(host->caps2 & MMC_CAP2_NO_SD)) {\n\t\tif (mmc_send_if_cond_pcie(host, host->ocr_avail))\n\t\t\tgoto out;\n\t\tif (mmc_card_sd_express(host))\n\t\t\treturn 0;\n\t}\n\n\t \n\tif (!(host->caps2 & MMC_CAP2_NO_SDIO))\n\t\tif (!mmc_attach_sdio(host))\n\t\t\treturn 0;\n\n\tif (!(host->caps2 & MMC_CAP2_NO_SD))\n\t\tif (!mmc_attach_sd(host))\n\t\t\treturn 0;\n\n\tif (!(host->caps2 & MMC_CAP2_NO_MMC))\n\t\tif (!mmc_attach_mmc(host))\n\t\t\treturn 0;\n\nout:\n\tmmc_power_off(host);\n\treturn -EIO;\n}\n\nint _mmc_detect_card_removed(struct mmc_host *host)\n{\n\tint ret;\n\n\tif (!host->card || mmc_card_removed(host->card))\n\t\treturn 1;\n\n\tret = host->bus_ops->alive(host);\n\n\t \n\tif (!ret && host->ops->get_cd && !host->ops->get_cd(host)) {\n\t\tmmc_detect_change(host, msecs_to_jiffies(200));\n\t\tpr_debug(\"%s: card removed too slowly\\n\", mmc_hostname(host));\n\t}\n\n\tif (ret) {\n\t\tmmc_card_set_removed(host->card);\n\t\tpr_debug(\"%s: card remove detected\\n\", mmc_hostname(host));\n\t}\n\n\treturn ret;\n}\n\nint mmc_detect_card_removed(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\tint ret;\n\n\tWARN_ON(!host->claimed);\n\n\tif (!card)\n\t\treturn 1;\n\n\tif (!mmc_card_is_removable(host))\n\t\treturn 0;\n\n\tret = mmc_card_removed(card);\n\t \n\tif (!host->detect_change && !(host->caps & MMC_CAP_NEEDS_POLL))\n\t\treturn ret;\n\n\thost->detect_change = 0;\n\tif (!ret) {\n\t\tret = _mmc_detect_card_removed(host);\n\t\tif (ret && (host->caps & MMC_CAP_NEEDS_POLL)) {\n\t\t\t \n\t\t\tcancel_delayed_work(&host->detect);\n\t\t\t_mmc_detect_change(host, 0, false);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mmc_detect_card_removed);\n\nint mmc_card_alternative_gpt_sector(struct mmc_card *card, sector_t *gpt_sector)\n{\n\tunsigned int boot_sectors_num;\n\n\tif ((!(card->host->caps2 & MMC_CAP2_ALT_GPT_TEGRA)))\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (card->ext_csd.rev < 3 ||\n\t    !mmc_card_mmc(card) ||\n\t    !mmc_card_is_blockaddr(card) ||\n\t     mmc_card_is_removable(card->host))\n\t\treturn -ENOENT;\n\n\t \n\tboot_sectors_num = card->ext_csd.raw_boot_mult * SZ_128K /\n\t\t\t   SZ_512 * MMC_NUM_BOOT_PARTITION;\n\n\t \n\t*gpt_sector = card->ext_csd.sectors - boot_sectors_num - 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_card_alternative_gpt_sector);\n\nvoid mmc_rescan(struct work_struct *work)\n{\n\tstruct mmc_host *host =\n\t\tcontainer_of(work, struct mmc_host, detect.work);\n\tint i;\n\n\tif (host->rescan_disable)\n\t\treturn;\n\n\t \n\tif (!mmc_card_is_removable(host) && host->rescan_entered)\n\t\treturn;\n\thost->rescan_entered = 1;\n\n\tif (host->trigger_card_event && host->ops->card_event) {\n\t\tmmc_claim_host(host);\n\t\thost->ops->card_event(host);\n\t\tmmc_release_host(host);\n\t\thost->trigger_card_event = false;\n\t}\n\n\t \n\tif (host->bus_ops)\n\t\thost->bus_ops->detect(host);\n\n\thost->detect_change = 0;\n\n\t \n\tif (host->bus_ops != NULL)\n\t\tgoto out;\n\n\tmmc_claim_host(host);\n\tif (mmc_card_is_removable(host) && host->ops->get_cd &&\n\t\t\thost->ops->get_cd(host) == 0) {\n\t\tmmc_power_off(host);\n\t\tmmc_release_host(host);\n\t\tgoto out;\n\t}\n\n\t \n\tif (mmc_card_sd_express(host)) {\n\t\tmmc_release_host(host);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(freqs); i++) {\n\t\tunsigned int freq = freqs[i];\n\t\tif (freq > host->f_max) {\n\t\t\tif (i + 1 < ARRAY_SIZE(freqs))\n\t\t\t\tcontinue;\n\t\t\tfreq = host->f_max;\n\t\t}\n\t\tif (!mmc_rescan_try_freq(host, max(freq, host->f_min)))\n\t\t\tbreak;\n\t\tif (freqs[i] <= host->f_min)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!mmc_card_is_removable(host) && !host->bus_ops)\n\t\tpr_info(\"%s: Failed to initialize a non-removable card\",\n\t\t\tmmc_hostname(host));\n\n\t \n\thost->err_stats[MMC_ERR_CMD_TIMEOUT] = 0;\n\tmmc_release_host(host);\n\n out:\n\tif (host->caps & MMC_CAP_NEEDS_POLL)\n\t\tmmc_schedule_delayed_work(&host->detect, HZ);\n}\n\nvoid mmc_start_host(struct mmc_host *host)\n{\n\thost->f_init = max(min(freqs[0], host->f_max), host->f_min);\n\thost->rescan_disable = 0;\n\n\tif (!(host->caps2 & MMC_CAP2_NO_PRESCAN_POWERUP)) {\n\t\tmmc_claim_host(host);\n\t\tmmc_power_up(host, host->ocr_avail);\n\t\tmmc_release_host(host);\n\t}\n\n\tmmc_gpiod_request_cd_irq(host);\n\t_mmc_detect_change(host, 0, false);\n}\n\nvoid __mmc_stop_host(struct mmc_host *host)\n{\n\tif (host->slot.cd_irq >= 0) {\n\t\tmmc_gpio_set_cd_wake(host, false);\n\t\tdisable_irq(host->slot.cd_irq);\n\t}\n\n\thost->rescan_disable = 1;\n\tcancel_delayed_work_sync(&host->detect);\n}\n\nvoid mmc_stop_host(struct mmc_host *host)\n{\n\t__mmc_stop_host(host);\n\n\t \n\thost->pm_flags = 0;\n\n\tif (host->bus_ops) {\n\t\t \n\t\thost->bus_ops->remove(host);\n\t\tmmc_claim_host(host);\n\t\tmmc_detach_bus(host);\n\t\tmmc_power_off(host);\n\t\tmmc_release_host(host);\n\t\treturn;\n\t}\n\n\tmmc_claim_host(host);\n\tmmc_power_off(host);\n\tmmc_release_host(host);\n}\n\nstatic int __init mmc_init(void)\n{\n\tint ret;\n\n\tret = mmc_register_bus();\n\tif (ret)\n\t\treturn ret;\n\n\tret = mmc_register_host_class();\n\tif (ret)\n\t\tgoto unregister_bus;\n\n\tret = sdio_register_bus();\n\tif (ret)\n\t\tgoto unregister_host_class;\n\n\treturn 0;\n\nunregister_host_class:\n\tmmc_unregister_host_class();\nunregister_bus:\n\tmmc_unregister_bus();\n\treturn ret;\n}\n\nstatic void __exit mmc_exit(void)\n{\n\tsdio_unregister_bus();\n\tmmc_unregister_host_class();\n\tmmc_unregister_bus();\n}\n\nsubsys_initcall(mmc_init);\nmodule_exit(mmc_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}