{
  "module_name": "debugfs.c",
  "hash_id": "1df4eff1027a84486750a6b0d63138df4aed88062686af24062e56b0dce9b5dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/debugfs.c",
  "human_readable_source": "\n \n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/debugfs.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/fault-inject.h>\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"mmc_ops.h\"\n\n#ifdef CONFIG_FAIL_MMC_REQUEST\n\nstatic DECLARE_FAULT_ATTR(fail_default_attr);\nstatic char *fail_request;\nmodule_param(fail_request, charp, 0);\nMODULE_PARM_DESC(fail_request, \"default fault injection attributes\");\n\n#endif  \n\n \nstatic int mmc_ios_show(struct seq_file *s, void *data)\n{\n\tstatic const char *vdd_str[] = {\n\t\t[8]\t= \"2.0\",\n\t\t[9]\t= \"2.1\",\n\t\t[10]\t= \"2.2\",\n\t\t[11]\t= \"2.3\",\n\t\t[12]\t= \"2.4\",\n\t\t[13]\t= \"2.5\",\n\t\t[14]\t= \"2.6\",\n\t\t[15]\t= \"2.7\",\n\t\t[16]\t= \"2.8\",\n\t\t[17]\t= \"2.9\",\n\t\t[18]\t= \"3.0\",\n\t\t[19]\t= \"3.1\",\n\t\t[20]\t= \"3.2\",\n\t\t[21]\t= \"3.3\",\n\t\t[22]\t= \"3.4\",\n\t\t[23]\t= \"3.5\",\n\t\t[24]\t= \"3.6\",\n\t};\n\tstruct mmc_host\t*host = s->private;\n\tstruct mmc_ios\t*ios = &host->ios;\n\tconst char *str;\n\n\tseq_printf(s, \"clock:\\t\\t%u Hz\\n\", ios->clock);\n\tif (host->actual_clock)\n\t\tseq_printf(s, \"actual clock:\\t%u Hz\\n\", host->actual_clock);\n\tseq_printf(s, \"vdd:\\t\\t%u \", ios->vdd);\n\tif ((1 << ios->vdd) & MMC_VDD_165_195)\n\t\tseq_printf(s, \"(1.65 - 1.95 V)\\n\");\n\telse if (ios->vdd < (ARRAY_SIZE(vdd_str) - 1)\n\t\t\t&& vdd_str[ios->vdd] && vdd_str[ios->vdd + 1])\n\t\tseq_printf(s, \"(%s ~ %s V)\\n\", vdd_str[ios->vdd],\n\t\t\t\tvdd_str[ios->vdd + 1]);\n\telse\n\t\tseq_printf(s, \"(invalid)\\n\");\n\n\tswitch (ios->bus_mode) {\n\tcase MMC_BUSMODE_OPENDRAIN:\n\t\tstr = \"open drain\";\n\t\tbreak;\n\tcase MMC_BUSMODE_PUSHPULL:\n\t\tstr = \"push-pull\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"bus mode:\\t%u (%s)\\n\", ios->bus_mode, str);\n\n\tswitch (ios->chip_select) {\n\tcase MMC_CS_DONTCARE:\n\t\tstr = \"don't care\";\n\t\tbreak;\n\tcase MMC_CS_HIGH:\n\t\tstr = \"active high\";\n\t\tbreak;\n\tcase MMC_CS_LOW:\n\t\tstr = \"active low\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"chip select:\\t%u (%s)\\n\", ios->chip_select, str);\n\n\tswitch (ios->power_mode) {\n\tcase MMC_POWER_OFF:\n\t\tstr = \"off\";\n\t\tbreak;\n\tcase MMC_POWER_UP:\n\t\tstr = \"up\";\n\t\tbreak;\n\tcase MMC_POWER_ON:\n\t\tstr = \"on\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"power mode:\\t%u (%s)\\n\", ios->power_mode, str);\n\tseq_printf(s, \"bus width:\\t%u (%u bits)\\n\",\n\t\t\tios->bus_width, 1 << ios->bus_width);\n\n\tswitch (ios->timing) {\n\tcase MMC_TIMING_LEGACY:\n\t\tstr = \"legacy\";\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS:\n\t\tstr = \"mmc high-speed\";\n\t\tbreak;\n\tcase MMC_TIMING_SD_HS:\n\t\tstr = \"sd high-speed\";\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR12:\n\t\tstr = \"sd uhs SDR12\";\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR25:\n\t\tstr = \"sd uhs SDR25\";\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR50:\n\t\tstr = \"sd uhs SDR50\";\n\t\tbreak;\n\tcase MMC_TIMING_UHS_SDR104:\n\t\tstr = \"sd uhs SDR104\";\n\t\tbreak;\n\tcase MMC_TIMING_UHS_DDR50:\n\t\tstr = \"sd uhs DDR50\";\n\t\tbreak;\n\tcase MMC_TIMING_MMC_DDR52:\n\t\tstr = \"mmc DDR52\";\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS200:\n\t\tstr = \"mmc HS200\";\n\t\tbreak;\n\tcase MMC_TIMING_MMC_HS400:\n\t\tstr = mmc_card_hs400es(host->card) ?\n\t\t\t\"mmc HS400 enhanced strobe\" : \"mmc HS400\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"timing spec:\\t%u (%s)\\n\", ios->timing, str);\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tstr = \"3.30 V\";\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\tstr = \"1.80 V\";\n\t\tbreak;\n\tcase MMC_SIGNAL_VOLTAGE_120:\n\t\tstr = \"1.20 V\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"signal voltage:\\t%u (%s)\\n\", ios->signal_voltage, str);\n\n\tswitch (ios->drv_type) {\n\tcase MMC_SET_DRIVER_TYPE_A:\n\t\tstr = \"driver type A\";\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_B:\n\t\tstr = \"driver type B\";\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_C:\n\t\tstr = \"driver type C\";\n\t\tbreak;\n\tcase MMC_SET_DRIVER_TYPE_D:\n\t\tstr = \"driver type D\";\n\t\tbreak;\n\tdefault:\n\t\tstr = \"invalid\";\n\t\tbreak;\n\t}\n\tseq_printf(s, \"driver type:\\t%u (%s)\\n\", ios->drv_type, str);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(mmc_ios);\n\nstatic int mmc_clock_opt_get(void *data, u64 *val)\n{\n\tstruct mmc_host *host = data;\n\n\t*val = host->ios.clock;\n\n\treturn 0;\n}\n\nstatic int mmc_clock_opt_set(void *data, u64 val)\n{\n\tstruct mmc_host *host = data;\n\n\t \n\tif (val != 0 && (val > host->f_max || val < host->f_min))\n\t\treturn -EINVAL;\n\n\tmmc_claim_host(host);\n\tmmc_set_clock(host, (unsigned int) val);\n\tmmc_release_host(host);\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(mmc_clock_fops, mmc_clock_opt_get, mmc_clock_opt_set,\n\t\"%llu\\n\");\n\nstatic int mmc_err_state_get(void *data, u64 *val)\n{\n\tstruct mmc_host *host = data;\n\tint i;\n\n\tif (!host)\n\t\treturn -EINVAL;\n\n\t*val = 0;\n\tfor (i = 0; i < MMC_ERR_MAX; i++) {\n\t\tif (host->err_stats[i]) {\n\t\t\t*val = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(mmc_err_state, mmc_err_state_get, NULL, \"%llu\\n\");\n\nstatic int mmc_err_stats_show(struct seq_file *file, void *data)\n{\n\tstruct mmc_host *host = file->private;\n\tconst char *desc[MMC_ERR_MAX] = {\n\t\t[MMC_ERR_CMD_TIMEOUT] = \"Command Timeout Occurred\",\n\t\t[MMC_ERR_CMD_CRC] = \"Command CRC Errors Occurred\",\n\t\t[MMC_ERR_DAT_TIMEOUT] = \"Data Timeout Occurred\",\n\t\t[MMC_ERR_DAT_CRC] = \"Data CRC Errors Occurred\",\n\t\t[MMC_ERR_AUTO_CMD] = \"Auto-Cmd Error Occurred\",\n\t\t[MMC_ERR_ADMA] = \"ADMA Error Occurred\",\n\t\t[MMC_ERR_TUNING] = \"Tuning Error Occurred\",\n\t\t[MMC_ERR_CMDQ_RED] = \"CMDQ RED Errors\",\n\t\t[MMC_ERR_CMDQ_GCE] = \"CMDQ GCE Errors\",\n\t\t[MMC_ERR_CMDQ_ICCE] = \"CMDQ ICCE Errors\",\n\t\t[MMC_ERR_REQ_TIMEOUT] = \"Request Timedout\",\n\t\t[MMC_ERR_CMDQ_REQ_TIMEOUT] = \"CMDQ Request Timedout\",\n\t\t[MMC_ERR_ICE_CFG] = \"ICE Config Errors\",\n\t\t[MMC_ERR_CTRL_TIMEOUT] = \"Controller Timedout errors\",\n\t\t[MMC_ERR_UNEXPECTED_IRQ] = \"Unexpected IRQ errors\",\n\t};\n\tint i;\n\n\tfor (i = 0; i < MMC_ERR_MAX; i++) {\n\t\tif (desc[i])\n\t\t\tseq_printf(file, \"# %s:\\t %d\\n\",\n\t\t\t\t\tdesc[i], host->err_stats[i]);\n\t}\n\n\treturn 0;\n}\n\nstatic int mmc_err_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mmc_err_stats_show, inode->i_private);\n}\n\nstatic ssize_t mmc_err_stats_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct mmc_host *host = filp->f_mapping->host->i_private;\n\n\tpr_debug(\"%s: Resetting MMC error statistics\\n\", __func__);\n\tmemset(host->err_stats, 0, sizeof(host->err_stats));\n\n\treturn cnt;\n}\n\nstatic const struct file_operations mmc_err_stats_fops = {\n\t.open\t= mmc_err_stats_open,\n\t.read\t= seq_read,\n\t.write\t= mmc_err_stats_write,\n\t.release = single_release,\n};\n\nvoid mmc_add_host_debugfs(struct mmc_host *host)\n{\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(mmc_hostname(host), NULL);\n\thost->debugfs_root = root;\n\n\tdebugfs_create_file(\"ios\", S_IRUSR, root, host, &mmc_ios_fops);\n\tdebugfs_create_x32(\"caps\", S_IRUSR, root, &host->caps);\n\tdebugfs_create_x32(\"caps2\", S_IRUSR, root, &host->caps2);\n\tdebugfs_create_file_unsafe(\"clock\", S_IRUSR | S_IWUSR, root, host,\n\t\t\t\t   &mmc_clock_fops);\n\n\tdebugfs_create_file_unsafe(\"err_state\", 0600, root, host,\n\t\t\t    &mmc_err_state);\n\tdebugfs_create_file(\"err_stats\", 0600, root, host,\n\t\t\t    &mmc_err_stats_fops);\n\n#ifdef CONFIG_FAIL_MMC_REQUEST\n\tif (fail_request)\n\t\tsetup_fault_attr(&fail_default_attr, fail_request);\n\thost->fail_mmc_request = fail_default_attr;\n\tfault_create_debugfs_attr(\"fail_mmc_request\", root,\n\t\t\t\t  &host->fail_mmc_request);\n#endif\n}\n\nvoid mmc_remove_host_debugfs(struct mmc_host *host)\n{\n\tdebugfs_remove_recursive(host->debugfs_root);\n}\n\nvoid mmc_add_card_debugfs(struct mmc_card *card)\n{\n\tstruct mmc_host\t*host = card->host;\n\tstruct dentry\t*root;\n\n\tif (!host->debugfs_root)\n\t\treturn;\n\n\troot = debugfs_create_dir(mmc_card_id(card), host->debugfs_root);\n\tcard->debugfs_root = root;\n\n\tdebugfs_create_x32(\"state\", S_IRUSR, root, &card->state);\n}\n\nvoid mmc_remove_card_debugfs(struct mmc_card *card)\n{\n\tdebugfs_remove_recursive(card->debugfs_root);\n\tcard->debugfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}