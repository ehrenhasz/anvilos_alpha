{
  "module_name": "quirks.h",
  "hash_id": "2b61b278b4dcae91b567996aa2c2a2ec9872ee16216dd8841ea6e9e9727be6a2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/quirks.h",
  "human_readable_source": " \n \n\n#include <linux/of.h>\n#include <linux/mmc/sdio_ids.h>\n\n#include \"card.h\"\n\nstatic const struct mmc_fixup __maybe_unused mmc_blk_fixups[] = {\n#define INAND_CMD38_ARG_EXT_CSD  113\n#define INAND_CMD38_ARG_ERASE    0x00\n#define INAND_CMD38_ARG_TRIM     0x01\n#define INAND_CMD38_ARG_SECERASE 0x80\n#define INAND_CMD38_ARG_SECTRIM1 0x81\n#define INAND_CMD38_ARG_SECTRIM2 0x88\n\t \n\tMMC_FIXUP(\"SEM02G\", CID_MANFID_SANDISK, 0x100, add_quirk,\n\t\t  MMC_QUIRK_INAND_CMD38),\n\tMMC_FIXUP(\"SEM04G\", CID_MANFID_SANDISK, 0x100, add_quirk,\n\t\t  MMC_QUIRK_INAND_CMD38),\n\tMMC_FIXUP(\"SEM08G\", CID_MANFID_SANDISK, 0x100, add_quirk,\n\t\t  MMC_QUIRK_INAND_CMD38),\n\tMMC_FIXUP(\"SEM16G\", CID_MANFID_SANDISK, 0x100, add_quirk,\n\t\t  MMC_QUIRK_INAND_CMD38),\n\tMMC_FIXUP(\"SEM32G\", CID_MANFID_SANDISK, 0x100, add_quirk,\n\t\t  MMC_QUIRK_INAND_CMD38),\n\n\t \n\tMMC_FIXUP(\"SDMB-32\", CID_MANFID_SANDISK, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\tMMC_FIXUP(\"SDM032\", CID_MANFID_SANDISK, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\tMMC_FIXUP(\"MMC08G\", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\tMMC_FIXUP(\"MMC16G\", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\tMMC_FIXUP(\"MMC32G\", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\n\t \n\t_FIXUP_EXT(\"SD64G\", CID_MANFID_KINGSTON_SD, 0x5449, 2019, 11,\n\t\t   0, -1ull, SDIO_ANY_ID, SDIO_ANY_ID, add_quirk_sd,\n\t\t   MMC_QUIRK_BROKEN_SD_CACHE, EXT_CSD_REV_ANY),\n\n\t \n\tMMC_FIXUP(\"AF SD\", CID_MANFID_ATP, CID_OEMID_ANY, add_quirk_sd,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\tMMC_FIXUP(\"APUSD\", CID_MANFID_APACER, 0x5048, add_quirk_sd,\n\t\t  MMC_QUIRK_BLK_NO_CMD23),\n\n\t \n\tMMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,\n\t\t  MMC_QUIRK_LONG_READ_TIME),\n\tMMC_FIXUP(\"008GE0\", CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_LONG_READ_TIME),\n\n\t \n\tMMC_FIXUP(\"M8G2FA\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"MAG4FA\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"MBG8FA\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"MCGAFA\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"VAL00M\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"VYL00M\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"KYL00M\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\tMMC_FIXUP(\"VZL00M\", CID_MANFID_SAMSUNG, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_SEC_ERASE_TRIM_BROKEN),\n\n\t \n\tMMC_FIXUP(\"V10008\", CID_MANFID_KINGSTON, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_TRIM_BROKEN),\n\tMMC_FIXUP(\"V10016\", CID_MANFID_KINGSTON, CID_OEMID_ANY, add_quirk_mmc,\n\t\t  MMC_QUIRK_TRIM_BROKEN),\n\n\t \n\tMMC_FIXUP(\"Q2J54A\", CID_MANFID_MICRON, 0x014e, add_quirk_mmc,\n\t\t  MMC_QUIRK_TRIM_BROKEN | MMC_QUIRK_BROKEN_CACHE_FLUSH),\n\n\t \n\tMMC_FIXUP(\"M62704\", CID_MANFID_KINGSTON, 0x0100, add_quirk_mmc,\n\t\t  MMC_QUIRK_TRIM_BROKEN),\n\n\t \n\tMMC_FIXUP(CID_NAME_ANY, CID_MANFID_SANDISK_SD, 0x5344, add_quirk_sd,\n\t\t  MMC_QUIRK_BROKEN_SD_DISCARD),\n\n\tEND_FIXUP\n};\n\nstatic const struct mmc_fixup __maybe_unused mmc_ext_csd_fixups[] = {\n\t \n\tMMC_FIXUP_EXT_CSD_REV(CID_NAME_ANY, CID_MANFID_HYNIX,\n\t\t\t      0x014a, add_quirk, MMC_QUIRK_BROKEN_HPI, 5),\n\t \n\tMMC_FIXUP_EXT_CSD_REV(CID_NAME_ANY, CID_MANFID_NUMONYX,\n\t\t\t      0x014e, add_quirk, MMC_QUIRK_BROKEN_HPI, 6),\n\n\tEND_FIXUP\n};\n\n\nstatic const struct mmc_fixup __maybe_unused sdio_fixup_methods[] = {\n\tSDIO_FIXUP(SDIO_VENDOR_ID_TI_WL1251, SDIO_DEVICE_ID_TI_WL1251,\n\t\t   add_quirk, MMC_QUIRK_NONSTD_FUNC_IF),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_TI_WL1251, SDIO_DEVICE_ID_TI_WL1251,\n\t\t   add_quirk, MMC_QUIRK_DISABLE_CD),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_TI, SDIO_DEVICE_ID_TI_WL1271,\n\t\t   add_quirk, MMC_QUIRK_NONSTD_FUNC_IF),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_TI, SDIO_DEVICE_ID_TI_WL1271,\n\t\t   add_quirk, MMC_QUIRK_DISABLE_CD),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_STE, SDIO_DEVICE_ID_STE_CW1200,\n\t\t   add_quirk, MMC_QUIRK_BROKEN_BYTE_MODE_512),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797_F0,\n\t\t   add_quirk, MMC_QUIRK_BROKEN_IRQ_POLLING),\n\n\tSDIO_FIXUP(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8887_F0,\n\t\t   add_limit_rate_quirk, 150000000),\n\n\tEND_FIXUP\n};\n\nstatic const struct mmc_fixup __maybe_unused sdio_card_init_methods[] = {\n\tSDIO_FIXUP_COMPATIBLE(\"ti,wl1251\", wl1251_quirk, 0),\n\n\tSDIO_FIXUP_COMPATIBLE(\"silabs,wf200\", add_quirk,\n\t\t\t      MMC_QUIRK_BROKEN_BYTE_MODE_512 |\n\t\t\t      MMC_QUIRK_LENIENT_FN0 |\n\t\t\t      MMC_QUIRK_BLKSZ_FOR_BYTE_MODE),\n\n\tEND_FIXUP\n};\n\nstatic inline bool mmc_fixup_of_compatible_match(struct mmc_card *card,\n\t\t\t\t\t\t const char *compatible)\n{\n\tstruct device_node *np;\n\n\tfor_each_child_of_node(mmc_dev(card->host)->of_node, np) {\n\t\tif (of_device_is_compatible(np, compatible)) {\n\t\t\tof_node_put(np);\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic inline void mmc_fixup_device(struct mmc_card *card,\n\t\t\t\t    const struct mmc_fixup *table)\n{\n\tconst struct mmc_fixup *f;\n\tu64 rev = cid_rev_card(card);\n\n\tfor (f = table; f->vendor_fixup; f++) {\n\t\tif (f->manfid != CID_MANFID_ANY &&\n\t\t    f->manfid != card->cid.manfid)\n\t\t\tcontinue;\n\t\tif (f->oemid != CID_OEMID_ANY &&\n\t\t    f->oemid != card->cid.oemid)\n\t\t\tcontinue;\n\t\tif (f->name != CID_NAME_ANY &&\n\t\t    strncmp(f->name, card->cid.prod_name,\n\t\t\t    sizeof(card->cid.prod_name)))\n\t\t\tcontinue;\n\t\tif (f->cis_vendor != (u16)SDIO_ANY_ID &&\n\t\t    f->cis_vendor != card->cis.vendor)\n\t\t\tcontinue;\n\t\tif (f->cis_device != (u16)SDIO_ANY_ID &&\n\t\t    f->cis_device != card->cis.device)\n\t\t\tcontinue;\n\t\tif (f->ext_csd_rev != EXT_CSD_REV_ANY &&\n\t\t    f->ext_csd_rev != card->ext_csd.rev)\n\t\t\tcontinue;\n\t\tif (rev < f->rev_start || rev > f->rev_end)\n\t\t\tcontinue;\n\t\tif (f->of_compatible &&\n\t\t    !mmc_fixup_of_compatible_match(card, f->of_compatible))\n\t\t\tcontinue;\n\t\tif (f->year != CID_YEAR_ANY && f->year != card->cid.year)\n\t\t\tcontinue;\n\t\tif (f->month != CID_MONTH_ANY && f->month != card->cid.month)\n\t\t\tcontinue;\n\n\t\tdev_dbg(&card->dev, \"calling %ps\\n\", f->vendor_fixup);\n\t\tf->vendor_fixup(card, f->data);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}