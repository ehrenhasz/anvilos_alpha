{
  "module_name": "mmc.c",
  "hash_id": "35c54704d37e80c89ee62e880e1e86ecdb6f30cc5a112924fb0c4916d1e14c9b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/mmc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/pm_runtime.h>\n#include <linux/random.h>\n#include <linux/sysfs.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"bus.h\"\n#include \"mmc_ops.h\"\n#include \"quirks.h\"\n#include \"sd_ops.h\"\n#include \"pwrseq.h\"\n\n#define DEFAULT_CMD6_TIMEOUT_MS\t500\n#define MIN_CACHE_EN_TIMEOUT_MS 1600\n#define CACHE_FLUSH_TIMEOUT_MS 30000  \n\nstatic const unsigned int tran_exp[] = {\n\t10000,\t\t100000,\t\t1000000,\t10000000,\n\t0,\t\t0,\t\t0,\t\t0\n};\n\nstatic const unsigned char tran_mant[] = {\n\t0,\t10,\t12,\t13,\t15,\t20,\t25,\t30,\n\t35,\t40,\t45,\t50,\t55,\t60,\t70,\t80,\n};\n\nstatic const unsigned int taac_exp[] = {\n\t1,\t10,\t100,\t1000,\t10000,\t100000,\t1000000, 10000000,\n};\n\nstatic const unsigned int taac_mant[] = {\n\t0,\t10,\t12,\t13,\t15,\t20,\t25,\t30,\n\t35,\t40,\t45,\t50,\t55,\t60,\t70,\t80,\n};\n\n#define UNSTUFF_BITS(resp,start,size)\t\t\t\t\t\\\n\t({\t\t\t\t\t\t\t\t\\\n\t\tconst int __size = size;\t\t\t\t\\\n\t\tconst u32 __mask = (__size < 32 ? 1 << __size : 0) - 1;\t\\\n\t\tconst int __off = 3 - ((start) / 32);\t\t\t\\\n\t\tconst int __shft = (start) & 31;\t\t\t\\\n\t\tu32 __res;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t\t__res = resp[__off] >> __shft;\t\t\t\t\\\n\t\tif (__size + __shft > 32)\t\t\t\t\\\n\t\t\t__res |= resp[__off-1] << ((32 - __shft) % 32);\t\\\n\t\t__res & __mask;\t\t\t\t\t\t\\\n\t})\n\n \nstatic int mmc_decode_cid(struct mmc_card *card)\n{\n\tu32 *resp = card->raw_cid;\n\n\t \n\tadd_device_randomness(&card->raw_cid, sizeof(card->raw_cid));\n\n\t \n\tswitch (card->csd.mmca_vsn) {\n\tcase 0:  \n\tcase 1:  \n\t\tcard->cid.manfid\t= UNSTUFF_BITS(resp, 104, 24);\n\t\tcard->cid.prod_name[0]\t= UNSTUFF_BITS(resp, 96, 8);\n\t\tcard->cid.prod_name[1]\t= UNSTUFF_BITS(resp, 88, 8);\n\t\tcard->cid.prod_name[2]\t= UNSTUFF_BITS(resp, 80, 8);\n\t\tcard->cid.prod_name[3]\t= UNSTUFF_BITS(resp, 72, 8);\n\t\tcard->cid.prod_name[4]\t= UNSTUFF_BITS(resp, 64, 8);\n\t\tcard->cid.prod_name[5]\t= UNSTUFF_BITS(resp, 56, 8);\n\t\tcard->cid.prod_name[6]\t= UNSTUFF_BITS(resp, 48, 8);\n\t\tcard->cid.hwrev\t\t= UNSTUFF_BITS(resp, 44, 4);\n\t\tcard->cid.fwrev\t\t= UNSTUFF_BITS(resp, 40, 4);\n\t\tcard->cid.serial\t= UNSTUFF_BITS(resp, 16, 24);\n\t\tcard->cid.month\t\t= UNSTUFF_BITS(resp, 12, 4);\n\t\tcard->cid.year\t\t= UNSTUFF_BITS(resp, 8, 4) + 1997;\n\t\tbreak;\n\n\tcase 2:  \n\tcase 3:  \n\tcase 4:  \n\t\tcard->cid.manfid\t= UNSTUFF_BITS(resp, 120, 8);\n\t\tcard->cid.oemid\t\t= UNSTUFF_BITS(resp, 104, 16);\n\t\tcard->cid.prod_name[0]\t= UNSTUFF_BITS(resp, 96, 8);\n\t\tcard->cid.prod_name[1]\t= UNSTUFF_BITS(resp, 88, 8);\n\t\tcard->cid.prod_name[2]\t= UNSTUFF_BITS(resp, 80, 8);\n\t\tcard->cid.prod_name[3]\t= UNSTUFF_BITS(resp, 72, 8);\n\t\tcard->cid.prod_name[4]\t= UNSTUFF_BITS(resp, 64, 8);\n\t\tcard->cid.prod_name[5]\t= UNSTUFF_BITS(resp, 56, 8);\n\t\tcard->cid.prv\t\t= UNSTUFF_BITS(resp, 48, 8);\n\t\tcard->cid.serial\t= UNSTUFF_BITS(resp, 16, 32);\n\t\tcard->cid.month\t\t= UNSTUFF_BITS(resp, 12, 4);\n\t\tcard->cid.year\t\t= UNSTUFF_BITS(resp, 8, 4) + 1997;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err(\"%s: card has unknown MMCA version %d\\n\",\n\t\t\tmmc_hostname(card->host), card->csd.mmca_vsn);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void mmc_set_erase_size(struct mmc_card *card)\n{\n\tif (card->ext_csd.erase_group_def & 1)\n\t\tcard->erase_size = card->ext_csd.hc_erase_size;\n\telse\n\t\tcard->erase_size = card->csd.erase_size;\n\n\tmmc_init_erase(card);\n}\n\n \nstatic int mmc_decode_csd(struct mmc_card *card)\n{\n\tstruct mmc_csd *csd = &card->csd;\n\tunsigned int e, m, a, b;\n\tu32 *resp = card->raw_csd;\n\n\t \n\tcsd->structure = UNSTUFF_BITS(resp, 126, 2);\n\tif (csd->structure == 0) {\n\t\tpr_err(\"%s: unrecognised CSD structure version %d\\n\",\n\t\t\tmmc_hostname(card->host), csd->structure);\n\t\treturn -EINVAL;\n\t}\n\n\tcsd->mmca_vsn\t = UNSTUFF_BITS(resp, 122, 4);\n\tm = UNSTUFF_BITS(resp, 115, 4);\n\te = UNSTUFF_BITS(resp, 112, 3);\n\tcsd->taac_ns\t = (taac_exp[e] * taac_mant[m] + 9) / 10;\n\tcsd->taac_clks\t = UNSTUFF_BITS(resp, 104, 8) * 100;\n\n\tm = UNSTUFF_BITS(resp, 99, 4);\n\te = UNSTUFF_BITS(resp, 96, 3);\n\tcsd->max_dtr\t  = tran_exp[e] * tran_mant[m];\n\tcsd->cmdclass\t  = UNSTUFF_BITS(resp, 84, 12);\n\n\te = UNSTUFF_BITS(resp, 47, 3);\n\tm = UNSTUFF_BITS(resp, 62, 12);\n\tcsd->capacity\t  = (1 + m) << (e + 2);\n\n\tcsd->read_blkbits = UNSTUFF_BITS(resp, 80, 4);\n\tcsd->read_partial = UNSTUFF_BITS(resp, 79, 1);\n\tcsd->write_misalign = UNSTUFF_BITS(resp, 78, 1);\n\tcsd->read_misalign = UNSTUFF_BITS(resp, 77, 1);\n\tcsd->dsr_imp = UNSTUFF_BITS(resp, 76, 1);\n\tcsd->r2w_factor = UNSTUFF_BITS(resp, 26, 3);\n\tcsd->write_blkbits = UNSTUFF_BITS(resp, 22, 4);\n\tcsd->write_partial = UNSTUFF_BITS(resp, 21, 1);\n\n\tif (csd->write_blkbits >= 9) {\n\t\ta = UNSTUFF_BITS(resp, 42, 5);\n\t\tb = UNSTUFF_BITS(resp, 37, 5);\n\t\tcsd->erase_size = (a + 1) * (b + 1);\n\t\tcsd->erase_size <<= csd->write_blkbits - 9;\n\t}\n\n\treturn 0;\n}\n\nstatic void mmc_select_card_type(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tu8 card_type = card->ext_csd.raw_card_type;\n\tu32 caps = host->caps, caps2 = host->caps2;\n\tunsigned int hs_max_dtr = 0, hs200_max_dtr = 0;\n\tunsigned int avail_type = 0;\n\n\tif (caps & MMC_CAP_MMC_HIGHSPEED &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS_26) {\n\t\ths_max_dtr = MMC_HIGH_26_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS_26;\n\t}\n\n\tif (caps & MMC_CAP_MMC_HIGHSPEED &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS_52) {\n\t\ths_max_dtr = MMC_HIGH_52_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS_52;\n\t}\n\n\tif (caps & (MMC_CAP_1_8V_DDR | MMC_CAP_3_3V_DDR) &&\n\t    card_type & EXT_CSD_CARD_TYPE_DDR_1_8V) {\n\t\ths_max_dtr = MMC_HIGH_DDR_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_DDR_1_8V;\n\t}\n\n\tif (caps & MMC_CAP_1_2V_DDR &&\n\t    card_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {\n\t\ths_max_dtr = MMC_HIGH_DDR_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_DDR_1_2V;\n\t}\n\n\tif (caps2 & MMC_CAP2_HS200_1_8V_SDR &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS200_1_8V) {\n\t\ths200_max_dtr = MMC_HS200_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS200_1_8V;\n\t}\n\n\tif (caps2 & MMC_CAP2_HS200_1_2V_SDR &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS200_1_2V) {\n\t\ths200_max_dtr = MMC_HS200_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS200_1_2V;\n\t}\n\n\tif (caps2 & MMC_CAP2_HS400_1_8V &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS400_1_8V) {\n\t\ths200_max_dtr = MMC_HS200_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS400_1_8V;\n\t}\n\n\tif (caps2 & MMC_CAP2_HS400_1_2V &&\n\t    card_type & EXT_CSD_CARD_TYPE_HS400_1_2V) {\n\t\ths200_max_dtr = MMC_HS200_MAX_DTR;\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS400_1_2V;\n\t}\n\n\tif ((caps2 & MMC_CAP2_HS400_ES) &&\n\t    card->ext_csd.strobe_support &&\n\t    (avail_type & EXT_CSD_CARD_TYPE_HS400))\n\t\tavail_type |= EXT_CSD_CARD_TYPE_HS400ES;\n\n\tcard->ext_csd.hs_max_dtr = hs_max_dtr;\n\tcard->ext_csd.hs200_max_dtr = hs200_max_dtr;\n\tcard->mmc_avail_type = avail_type;\n}\n\nstatic void mmc_manage_enhanced_area(struct mmc_card *card, u8 *ext_csd)\n{\n\tu8 hc_erase_grp_sz, hc_wp_grp_sz;\n\n\t \n\tcard->ext_csd.enhanced_area_offset = -EINVAL;\n\tcard->ext_csd.enhanced_area_size = -EINVAL;\n\n\t \n\tif ((ext_csd[EXT_CSD_PARTITION_SUPPORT] & 0x2) &&\n\t    (ext_csd[EXT_CSD_PARTITION_ATTRIBUTE] & 0x1)) {\n\t\tif (card->ext_csd.partition_setting_completed) {\n\t\t\thc_erase_grp_sz =\n\t\t\t\text_csd[EXT_CSD_HC_ERASE_GRP_SIZE];\n\t\t\thc_wp_grp_sz =\n\t\t\t\text_csd[EXT_CSD_HC_WP_GRP_SIZE];\n\n\t\t\t \n\t\t\tcard->ext_csd.enhanced_area_offset =\n\t\t\t\t(((unsigned long long)ext_csd[139]) << 24) +\n\t\t\t\t(((unsigned long long)ext_csd[138]) << 16) +\n\t\t\t\t(((unsigned long long)ext_csd[137]) << 8) +\n\t\t\t\t(((unsigned long long)ext_csd[136]));\n\t\t\tif (mmc_card_blockaddr(card))\n\t\t\t\tcard->ext_csd.enhanced_area_offset <<= 9;\n\t\t\t \n\t\t\tcard->ext_csd.enhanced_area_size =\n\t\t\t\t(ext_csd[142] << 16) + (ext_csd[141] << 8) +\n\t\t\t\text_csd[140];\n\t\t\tcard->ext_csd.enhanced_area_size *=\n\t\t\t\t(size_t)(hc_erase_grp_sz * hc_wp_grp_sz);\n\t\t\tcard->ext_csd.enhanced_area_size <<= 9;\n\t\t} else {\n\t\t\tpr_warn(\"%s: defines enhanced area without partition setting complete\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t}\n\t}\n}\n\nstatic void mmc_part_add(struct mmc_card *card, u64 size,\n\t\t\t unsigned int part_cfg, char *name, int idx, bool ro,\n\t\t\t int area_type)\n{\n\tcard->part[card->nr_parts].size = size;\n\tcard->part[card->nr_parts].part_cfg = part_cfg;\n\tsprintf(card->part[card->nr_parts].name, name, idx);\n\tcard->part[card->nr_parts].force_ro = ro;\n\tcard->part[card->nr_parts].area_type = area_type;\n\tcard->nr_parts++;\n}\n\nstatic void mmc_manage_gp_partitions(struct mmc_card *card, u8 *ext_csd)\n{\n\tint idx;\n\tu8 hc_erase_grp_sz, hc_wp_grp_sz;\n\tu64 part_size;\n\n\t \n\tif (ext_csd[EXT_CSD_PARTITION_SUPPORT] &\n\t    EXT_CSD_PART_SUPPORT_PART_EN) {\n\t\thc_erase_grp_sz =\n\t\t\text_csd[EXT_CSD_HC_ERASE_GRP_SIZE];\n\t\thc_wp_grp_sz =\n\t\t\text_csd[EXT_CSD_HC_WP_GRP_SIZE];\n\n\t\tfor (idx = 0; idx < MMC_NUM_GP_PARTITION; idx++) {\n\t\t\tif (!ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3] &&\n\t\t\t    !ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 1] &&\n\t\t\t    !ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 2])\n\t\t\t\tcontinue;\n\t\t\tif (card->ext_csd.partition_setting_completed == 0) {\n\t\t\t\tpr_warn(\"%s: has partition size defined without partition complete\\n\",\n\t\t\t\t\tmmc_hostname(card->host));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpart_size =\n\t\t\t\t(ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 2]\n\t\t\t\t<< 16) +\n\t\t\t\t(ext_csd[EXT_CSD_GP_SIZE_MULT + idx * 3 + 1]\n\t\t\t\t<< 8) +\n\t\t\t\text_csd[EXT_CSD_GP_SIZE_MULT + idx * 3];\n\t\t\tpart_size *= (hc_erase_grp_sz * hc_wp_grp_sz);\n\t\t\tmmc_part_add(card, part_size << 19,\n\t\t\t\tEXT_CSD_PART_CONFIG_ACC_GP0 + idx,\n\t\t\t\t\"gp%d\", idx, false,\n\t\t\t\tMMC_BLK_DATA_AREA_GP);\n\t\t}\n\t}\n}\n\n \n#define MMC_MIN_PART_SWITCH_TIME\t300\n\n \nstatic int mmc_decode_ext_csd(struct mmc_card *card, u8 *ext_csd)\n{\n\tint err = 0, idx;\n\tu64 part_size;\n\tstruct device_node *np;\n\tbool broken_hpi = false;\n\n\t \n\tcard->ext_csd.raw_ext_csd_structure = ext_csd[EXT_CSD_STRUCTURE];\n\tif (card->csd.structure == 3) {\n\t\tif (card->ext_csd.raw_ext_csd_structure > 2) {\n\t\t\tpr_err(\"%s: unrecognised EXT_CSD structure \"\n\t\t\t\t\"version %d\\n\", mmc_hostname(card->host),\n\t\t\t\t\tcard->ext_csd.raw_ext_csd_structure);\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnp = mmc_of_find_child_device(card->host, 0);\n\tif (np && of_device_is_compatible(np, \"mmc-card\"))\n\t\tbroken_hpi = of_property_read_bool(np, \"broken-hpi\");\n\tof_node_put(np);\n\n\t \n\tcard->ext_csd.rev = ext_csd[EXT_CSD_REV];\n\n\t \n\tmmc_fixup_device(card, mmc_ext_csd_fixups);\n\n\tcard->ext_csd.raw_sectors[0] = ext_csd[EXT_CSD_SEC_CNT + 0];\n\tcard->ext_csd.raw_sectors[1] = ext_csd[EXT_CSD_SEC_CNT + 1];\n\tcard->ext_csd.raw_sectors[2] = ext_csd[EXT_CSD_SEC_CNT + 2];\n\tcard->ext_csd.raw_sectors[3] = ext_csd[EXT_CSD_SEC_CNT + 3];\n\tif (card->ext_csd.rev >= 2) {\n\t\tcard->ext_csd.sectors =\n\t\t\text_csd[EXT_CSD_SEC_CNT + 0] << 0 |\n\t\t\text_csd[EXT_CSD_SEC_CNT + 1] << 8 |\n\t\t\text_csd[EXT_CSD_SEC_CNT + 2] << 16 |\n\t\t\text_csd[EXT_CSD_SEC_CNT + 3] << 24;\n\n\t\t \n\t\tif (card->ext_csd.sectors > (2u * 1024 * 1024 * 1024) / 512)\n\t\t\tmmc_card_set_blockaddr(card);\n\t}\n\n\tcard->ext_csd.strobe_support = ext_csd[EXT_CSD_STROBE_SUPPORT];\n\tcard->ext_csd.raw_card_type = ext_csd[EXT_CSD_CARD_TYPE];\n\tmmc_select_card_type(card);\n\n\tcard->ext_csd.raw_s_a_timeout = ext_csd[EXT_CSD_S_A_TIMEOUT];\n\tcard->ext_csd.raw_erase_timeout_mult =\n\t\text_csd[EXT_CSD_ERASE_TIMEOUT_MULT];\n\tcard->ext_csd.raw_hc_erase_grp_size =\n\t\text_csd[EXT_CSD_HC_ERASE_GRP_SIZE];\n\tcard->ext_csd.raw_boot_mult =\n\t\text_csd[EXT_CSD_BOOT_MULT];\n\tif (card->ext_csd.rev >= 3) {\n\t\tu8 sa_shift = ext_csd[EXT_CSD_S_A_TIMEOUT];\n\t\tcard->ext_csd.part_config = ext_csd[EXT_CSD_PART_CONFIG];\n\n\t\t \n\t\tcard->ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];\n\n\t\t \n\t\tif (sa_shift > 0 && sa_shift <= 0x17)\n\t\t\tcard->ext_csd.sa_timeout =\n\t\t\t\t\t1 << ext_csd[EXT_CSD_S_A_TIMEOUT];\n\t\tcard->ext_csd.erase_group_def =\n\t\t\text_csd[EXT_CSD_ERASE_GROUP_DEF];\n\t\tcard->ext_csd.hc_erase_timeout = 300 *\n\t\t\text_csd[EXT_CSD_ERASE_TIMEOUT_MULT];\n\t\tcard->ext_csd.hc_erase_size =\n\t\t\text_csd[EXT_CSD_HC_ERASE_GRP_SIZE] << 10;\n\n\t\tcard->ext_csd.rel_sectors = ext_csd[EXT_CSD_REL_WR_SEC_C];\n\n\t\t \n\t\tif (ext_csd[EXT_CSD_BOOT_MULT] && mmc_boot_partition_access(card->host)) {\n\t\t\tfor (idx = 0; idx < MMC_NUM_BOOT_PARTITION; idx++) {\n\t\t\t\tpart_size = ext_csd[EXT_CSD_BOOT_MULT] << 17;\n\t\t\t\tmmc_part_add(card, part_size,\n\t\t\t\t\tEXT_CSD_PART_CONFIG_ACC_BOOT0 + idx,\n\t\t\t\t\t\"boot%d\", idx, true,\n\t\t\t\t\tMMC_BLK_DATA_AREA_BOOT);\n\t\t\t}\n\t\t}\n\t}\n\n\tcard->ext_csd.raw_hc_erase_gap_size =\n\t\text_csd[EXT_CSD_HC_WP_GRP_SIZE];\n\tcard->ext_csd.raw_sec_trim_mult =\n\t\text_csd[EXT_CSD_SEC_TRIM_MULT];\n\tcard->ext_csd.raw_sec_erase_mult =\n\t\text_csd[EXT_CSD_SEC_ERASE_MULT];\n\tcard->ext_csd.raw_sec_feature_support =\n\t\text_csd[EXT_CSD_SEC_FEATURE_SUPPORT];\n\tcard->ext_csd.raw_trim_mult =\n\t\text_csd[EXT_CSD_TRIM_MULT];\n\tcard->ext_csd.raw_partition_support = ext_csd[EXT_CSD_PARTITION_SUPPORT];\n\tcard->ext_csd.raw_driver_strength = ext_csd[EXT_CSD_DRIVER_STRENGTH];\n\tif (card->ext_csd.rev >= 4) {\n\t\tif (ext_csd[EXT_CSD_PARTITION_SETTING_COMPLETED] &\n\t\t    EXT_CSD_PART_SETTING_COMPLETED)\n\t\t\tcard->ext_csd.partition_setting_completed = 1;\n\t\telse\n\t\t\tcard->ext_csd.partition_setting_completed = 0;\n\n\t\tmmc_manage_enhanced_area(card, ext_csd);\n\n\t\tmmc_manage_gp_partitions(card, ext_csd);\n\n\t\tcard->ext_csd.sec_trim_mult =\n\t\t\text_csd[EXT_CSD_SEC_TRIM_MULT];\n\t\tcard->ext_csd.sec_erase_mult =\n\t\t\text_csd[EXT_CSD_SEC_ERASE_MULT];\n\t\tcard->ext_csd.sec_feature_support =\n\t\t\text_csd[EXT_CSD_SEC_FEATURE_SUPPORT];\n\t\tcard->ext_csd.trim_timeout = 300 *\n\t\t\text_csd[EXT_CSD_TRIM_MULT];\n\n\t\t \n\t\tcard->ext_csd.boot_ro_lock = ext_csd[EXT_CSD_BOOT_WP];\n\t\tcard->ext_csd.boot_ro_lockable = true;\n\n\t\t \n\t\tcard->ext_csd.raw_pwr_cl_52_195 =\n\t\t\text_csd[EXT_CSD_PWR_CL_52_195];\n\t\tcard->ext_csd.raw_pwr_cl_26_195 =\n\t\t\text_csd[EXT_CSD_PWR_CL_26_195];\n\t\tcard->ext_csd.raw_pwr_cl_52_360 =\n\t\t\text_csd[EXT_CSD_PWR_CL_52_360];\n\t\tcard->ext_csd.raw_pwr_cl_26_360 =\n\t\t\text_csd[EXT_CSD_PWR_CL_26_360];\n\t\tcard->ext_csd.raw_pwr_cl_200_195 =\n\t\t\text_csd[EXT_CSD_PWR_CL_200_195];\n\t\tcard->ext_csd.raw_pwr_cl_200_360 =\n\t\t\text_csd[EXT_CSD_PWR_CL_200_360];\n\t\tcard->ext_csd.raw_pwr_cl_ddr_52_195 =\n\t\t\text_csd[EXT_CSD_PWR_CL_DDR_52_195];\n\t\tcard->ext_csd.raw_pwr_cl_ddr_52_360 =\n\t\t\text_csd[EXT_CSD_PWR_CL_DDR_52_360];\n\t\tcard->ext_csd.raw_pwr_cl_ddr_200_360 =\n\t\t\text_csd[EXT_CSD_PWR_CL_DDR_200_360];\n\t}\n\n\tif (card->ext_csd.rev >= 5) {\n\t\t \n\t\tif (card->cid.year < 2010)\n\t\t\tcard->cid.year += 16;\n\n\t\t \n\t\tif (ext_csd[EXT_CSD_BKOPS_SUPPORT] & 0x1) {\n\t\t\tcard->ext_csd.bkops = 1;\n\t\t\tcard->ext_csd.man_bkops_en =\n\t\t\t\t\t(ext_csd[EXT_CSD_BKOPS_EN] &\n\t\t\t\t\t\tEXT_CSD_MANUAL_BKOPS_MASK);\n\t\t\tcard->ext_csd.raw_bkops_status =\n\t\t\t\text_csd[EXT_CSD_BKOPS_STATUS];\n\t\t\tif (card->ext_csd.man_bkops_en)\n\t\t\t\tpr_debug(\"%s: MAN_BKOPS_EN bit is set\\n\",\n\t\t\t\t\tmmc_hostname(card->host));\n\t\t\tcard->ext_csd.auto_bkops_en =\n\t\t\t\t\t(ext_csd[EXT_CSD_BKOPS_EN] &\n\t\t\t\t\t\tEXT_CSD_AUTO_BKOPS_MASK);\n\t\t\tif (card->ext_csd.auto_bkops_en)\n\t\t\t\tpr_debug(\"%s: AUTO_BKOPS_EN bit is set\\n\",\n\t\t\t\t\tmmc_hostname(card->host));\n\t\t}\n\n\t\t \n\t\tif (!mmc_card_broken_hpi(card) &&\n\t\t    !broken_hpi && (ext_csd[EXT_CSD_HPI_FEATURES] & 0x1)) {\n\t\t\tcard->ext_csd.hpi = 1;\n\t\t\tif (ext_csd[EXT_CSD_HPI_FEATURES] & 0x2)\n\t\t\t\tcard->ext_csd.hpi_cmd =\tMMC_STOP_TRANSMISSION;\n\t\t\telse\n\t\t\t\tcard->ext_csd.hpi_cmd = MMC_SEND_STATUS;\n\t\t\t \n\t\t\tcard->ext_csd.out_of_int_time =\n\t\t\t\text_csd[EXT_CSD_OUT_OF_INTERRUPT_TIME] * 10;\n\t\t}\n\n\t\tcard->ext_csd.rel_param = ext_csd[EXT_CSD_WR_REL_PARAM];\n\t\tcard->ext_csd.rst_n_function = ext_csd[EXT_CSD_RST_N_FUNCTION];\n\n\t\t \n\t\tcard->ext_csd.raw_rpmb_size_mult = ext_csd[EXT_CSD_RPMB_MULT];\n\t\tif (ext_csd[EXT_CSD_RPMB_MULT] && mmc_host_cmd23(card->host)) {\n\t\t\tmmc_part_add(card, ext_csd[EXT_CSD_RPMB_MULT] << 17,\n\t\t\t\tEXT_CSD_PART_CONFIG_ACC_RPMB,\n\t\t\t\t\"rpmb\", 0, false,\n\t\t\t\tMMC_BLK_DATA_AREA_RPMB);\n\t\t}\n\t}\n\n\tcard->ext_csd.raw_erased_mem_count = ext_csd[EXT_CSD_ERASED_MEM_CONT];\n\tif (ext_csd[EXT_CSD_ERASED_MEM_CONT])\n\t\tcard->erased_byte = 0xFF;\n\telse\n\t\tcard->erased_byte = 0x0;\n\n\t \n\tcard->ext_csd.generic_cmd6_time = DEFAULT_CMD6_TIMEOUT_MS;\n\tif (card->ext_csd.rev >= 6) {\n\t\tcard->ext_csd.feature_support |= MMC_DISCARD_FEATURE;\n\n\t\tcard->ext_csd.generic_cmd6_time = 10 *\n\t\t\text_csd[EXT_CSD_GENERIC_CMD6_TIME];\n\t\tcard->ext_csd.power_off_longtime = 10 *\n\t\t\text_csd[EXT_CSD_POWER_OFF_LONG_TIME];\n\n\t\tcard->ext_csd.cache_size =\n\t\t\text_csd[EXT_CSD_CACHE_SIZE + 0] << 0 |\n\t\t\text_csd[EXT_CSD_CACHE_SIZE + 1] << 8 |\n\t\t\text_csd[EXT_CSD_CACHE_SIZE + 2] << 16 |\n\t\t\text_csd[EXT_CSD_CACHE_SIZE + 3] << 24;\n\n\t\tif (ext_csd[EXT_CSD_DATA_SECTOR_SIZE] == 1)\n\t\t\tcard->ext_csd.data_sector_size = 4096;\n\t\telse\n\t\t\tcard->ext_csd.data_sector_size = 512;\n\n\t\tif ((ext_csd[EXT_CSD_DATA_TAG_SUPPORT] & 1) &&\n\t\t    (ext_csd[EXT_CSD_TAG_UNIT_SIZE] <= 8)) {\n\t\t\tcard->ext_csd.data_tag_unit_size =\n\t\t\t((unsigned int) 1 << ext_csd[EXT_CSD_TAG_UNIT_SIZE]) *\n\t\t\t(card->ext_csd.data_sector_size);\n\t\t} else {\n\t\t\tcard->ext_csd.data_tag_unit_size = 0;\n\t\t}\n\n\t\tcard->ext_csd.max_packed_writes =\n\t\t\text_csd[EXT_CSD_MAX_PACKED_WRITES];\n\t\tcard->ext_csd.max_packed_reads =\n\t\t\text_csd[EXT_CSD_MAX_PACKED_READS];\n\t} else {\n\t\tcard->ext_csd.data_sector_size = 512;\n\t}\n\n\t \n\tif (!card->ext_csd.part_time)\n\t\tcard->ext_csd.part_time = card->ext_csd.generic_cmd6_time;\n\t \n\tif (card->ext_csd.part_time < MMC_MIN_PART_SWITCH_TIME)\n\t\tcard->ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;\n\n\t \n\tif (card->ext_csd.rev >= 7) {\n\t\tmemcpy(card->ext_csd.fwrev, &ext_csd[EXT_CSD_FIRMWARE_VERSION],\n\t\t       MMC_FIRMWARE_LEN);\n\t\tcard->ext_csd.ffu_capable =\n\t\t\t(ext_csd[EXT_CSD_SUPPORTED_MODE] & 0x1) &&\n\t\t\t!(ext_csd[EXT_CSD_FW_CONFIG] & 0x1);\n\n\t\tcard->ext_csd.pre_eol_info = ext_csd[EXT_CSD_PRE_EOL_INFO];\n\t\tcard->ext_csd.device_life_time_est_typ_a =\n\t\t\text_csd[EXT_CSD_DEVICE_LIFE_TIME_EST_TYP_A];\n\t\tcard->ext_csd.device_life_time_est_typ_b =\n\t\t\text_csd[EXT_CSD_DEVICE_LIFE_TIME_EST_TYP_B];\n\t}\n\n\t \n\tif (card->ext_csd.rev >= 8) {\n\t\tcard->ext_csd.cmdq_support = ext_csd[EXT_CSD_CMDQ_SUPPORT] &\n\t\t\t\t\t     EXT_CSD_CMDQ_SUPPORTED;\n\t\tcard->ext_csd.cmdq_depth = (ext_csd[EXT_CSD_CMDQ_DEPTH] &\n\t\t\t\t\t    EXT_CSD_CMDQ_DEPTH_MASK) + 1;\n\t\t \n\t\tif (card->ext_csd.cmdq_depth <= 2) {\n\t\t\tcard->ext_csd.cmdq_support = false;\n\t\t\tcard->ext_csd.cmdq_depth = 0;\n\t\t}\n\t\tif (card->ext_csd.cmdq_support) {\n\t\t\tpr_debug(\"%s: Command Queue supported depth %u\\n\",\n\t\t\t\t mmc_hostname(card->host),\n\t\t\t\t card->ext_csd.cmdq_depth);\n\t\t}\n\t\tcard->ext_csd.enhanced_rpmb_supported =\n\t\t\t\t\t(card->ext_csd.rel_param &\n\t\t\t\t\t EXT_CSD_WR_REL_PARAM_EN_RPMB_REL_WR);\n\t}\nout:\n\treturn err;\n}\n\nstatic int mmc_read_ext_csd(struct mmc_card *card)\n{\n\tu8 *ext_csd;\n\tint err;\n\n\tif (!mmc_can_ext_csd(card))\n\t\treturn 0;\n\n\terr = mmc_get_ext_csd(card, &ext_csd);\n\tif (err) {\n\t\t \n\t\tif ((err != -EINVAL)\n\t\t && (err != -ENOSYS)\n\t\t && (err != -EFAULT))\n\t\t\treturn err;\n\n\t\t \n\t\tif (card->csd.capacity == (4096 * 512)) {\n\t\t\tpr_err(\"%s: unable to read EXT_CSD on a possible high capacity card. Card will be ignored.\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t} else {\n\t\t\tpr_warn(\"%s: unable to read EXT_CSD, performance might suffer\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t\terr = 0;\n\t\t}\n\n\t\treturn err;\n\t}\n\n\terr = mmc_decode_ext_csd(card, ext_csd);\n\tkfree(ext_csd);\n\treturn err;\n}\n\nstatic int mmc_compare_ext_csds(struct mmc_card *card, unsigned bus_width)\n{\n\tu8 *bw_ext_csd;\n\tint err;\n\n\tif (bus_width == MMC_BUS_WIDTH_1)\n\t\treturn 0;\n\n\terr = mmc_get_ext_csd(card, &bw_ext_csd);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = !((card->ext_csd.raw_partition_support ==\n\t\t\tbw_ext_csd[EXT_CSD_PARTITION_SUPPORT]) &&\n\t\t(card->ext_csd.raw_erased_mem_count ==\n\t\t\tbw_ext_csd[EXT_CSD_ERASED_MEM_CONT]) &&\n\t\t(card->ext_csd.rev ==\n\t\t\tbw_ext_csd[EXT_CSD_REV]) &&\n\t\t(card->ext_csd.raw_ext_csd_structure ==\n\t\t\tbw_ext_csd[EXT_CSD_STRUCTURE]) &&\n\t\t(card->ext_csd.raw_card_type ==\n\t\t\tbw_ext_csd[EXT_CSD_CARD_TYPE]) &&\n\t\t(card->ext_csd.raw_s_a_timeout ==\n\t\t\tbw_ext_csd[EXT_CSD_S_A_TIMEOUT]) &&\n\t\t(card->ext_csd.raw_hc_erase_gap_size ==\n\t\t\tbw_ext_csd[EXT_CSD_HC_WP_GRP_SIZE]) &&\n\t\t(card->ext_csd.raw_erase_timeout_mult ==\n\t\t\tbw_ext_csd[EXT_CSD_ERASE_TIMEOUT_MULT]) &&\n\t\t(card->ext_csd.raw_hc_erase_grp_size ==\n\t\t\tbw_ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE]) &&\n\t\t(card->ext_csd.raw_sec_trim_mult ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_TRIM_MULT]) &&\n\t\t(card->ext_csd.raw_sec_erase_mult ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_ERASE_MULT]) &&\n\t\t(card->ext_csd.raw_sec_feature_support ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_FEATURE_SUPPORT]) &&\n\t\t(card->ext_csd.raw_trim_mult ==\n\t\t\tbw_ext_csd[EXT_CSD_TRIM_MULT]) &&\n\t\t(card->ext_csd.raw_sectors[0] ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_CNT + 0]) &&\n\t\t(card->ext_csd.raw_sectors[1] ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_CNT + 1]) &&\n\t\t(card->ext_csd.raw_sectors[2] ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_CNT + 2]) &&\n\t\t(card->ext_csd.raw_sectors[3] ==\n\t\t\tbw_ext_csd[EXT_CSD_SEC_CNT + 3]) &&\n\t\t(card->ext_csd.raw_pwr_cl_52_195 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_52_195]) &&\n\t\t(card->ext_csd.raw_pwr_cl_26_195 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_26_195]) &&\n\t\t(card->ext_csd.raw_pwr_cl_52_360 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_52_360]) &&\n\t\t(card->ext_csd.raw_pwr_cl_26_360 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_26_360]) &&\n\t\t(card->ext_csd.raw_pwr_cl_200_195 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_200_195]) &&\n\t\t(card->ext_csd.raw_pwr_cl_200_360 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_200_360]) &&\n\t\t(card->ext_csd.raw_pwr_cl_ddr_52_195 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_DDR_52_195]) &&\n\t\t(card->ext_csd.raw_pwr_cl_ddr_52_360 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_DDR_52_360]) &&\n\t\t(card->ext_csd.raw_pwr_cl_ddr_200_360 ==\n\t\t\tbw_ext_csd[EXT_CSD_PWR_CL_DDR_200_360]));\n\n\tif (err)\n\t\terr = -EINVAL;\n\n\tkfree(bw_ext_csd);\n\treturn err;\n}\n\nMMC_DEV_ATTR(cid, \"%08x%08x%08x%08x\\n\", card->raw_cid[0], card->raw_cid[1],\n\tcard->raw_cid[2], card->raw_cid[3]);\nMMC_DEV_ATTR(csd, \"%08x%08x%08x%08x\\n\", card->raw_csd[0], card->raw_csd[1],\n\tcard->raw_csd[2], card->raw_csd[3]);\nMMC_DEV_ATTR(date, \"%02d/%04d\\n\", card->cid.month, card->cid.year);\nMMC_DEV_ATTR(erase_size, \"%u\\n\", card->erase_size << 9);\nMMC_DEV_ATTR(preferred_erase_size, \"%u\\n\", card->pref_erase << 9);\nMMC_DEV_ATTR(ffu_capable, \"%d\\n\", card->ext_csd.ffu_capable);\nMMC_DEV_ATTR(hwrev, \"0x%x\\n\", card->cid.hwrev);\nMMC_DEV_ATTR(manfid, \"0x%06x\\n\", card->cid.manfid);\nMMC_DEV_ATTR(name, \"%s\\n\", card->cid.prod_name);\nMMC_DEV_ATTR(oemid, \"0x%04x\\n\", card->cid.oemid);\nMMC_DEV_ATTR(prv, \"0x%x\\n\", card->cid.prv);\nMMC_DEV_ATTR(rev, \"0x%x\\n\", card->ext_csd.rev);\nMMC_DEV_ATTR(pre_eol_info, \"0x%02x\\n\", card->ext_csd.pre_eol_info);\nMMC_DEV_ATTR(life_time, \"0x%02x 0x%02x\\n\",\n\tcard->ext_csd.device_life_time_est_typ_a,\n\tcard->ext_csd.device_life_time_est_typ_b);\nMMC_DEV_ATTR(serial, \"0x%08x\\n\", card->cid.serial);\nMMC_DEV_ATTR(enhanced_area_offset, \"%llu\\n\",\n\t\tcard->ext_csd.enhanced_area_offset);\nMMC_DEV_ATTR(enhanced_area_size, \"%u\\n\", card->ext_csd.enhanced_area_size);\nMMC_DEV_ATTR(raw_rpmb_size_mult, \"%#x\\n\", card->ext_csd.raw_rpmb_size_mult);\nMMC_DEV_ATTR(enhanced_rpmb_supported, \"%#x\\n\",\n\tcard->ext_csd.enhanced_rpmb_supported);\nMMC_DEV_ATTR(rel_sectors, \"%#x\\n\", card->ext_csd.rel_sectors);\nMMC_DEV_ATTR(ocr, \"0x%08x\\n\", card->ocr);\nMMC_DEV_ATTR(rca, \"0x%04x\\n\", card->rca);\nMMC_DEV_ATTR(cmdq_en, \"%d\\n\", card->ext_csd.cmdq_en);\n\nstatic ssize_t mmc_fwrev_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\n\tif (card->ext_csd.rev < 7)\n\t\treturn sysfs_emit(buf, \"0x%x\\n\", card->cid.fwrev);\n\telse\n\t\treturn sysfs_emit(buf, \"0x%*phN\\n\", MMC_FIRMWARE_LEN,\n\t\t\t\t  card->ext_csd.fwrev);\n}\n\nstatic DEVICE_ATTR(fwrev, S_IRUGO, mmc_fwrev_show, NULL);\n\nstatic ssize_t mmc_dsr_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\n\tstruct mmc_host *host = card->host;\n\n\tif (card->csd.dsr_imp && host->dsr_req)\n\t\treturn sysfs_emit(buf, \"0x%x\\n\", host->dsr);\n\telse\n\t\t \n\t\treturn sysfs_emit(buf, \"0x%x\\n\", 0x404);\n}\n\nstatic DEVICE_ATTR(dsr, S_IRUGO, mmc_dsr_show, NULL);\n\nstatic struct attribute *mmc_std_attrs[] = {\n\t&dev_attr_cid.attr,\n\t&dev_attr_csd.attr,\n\t&dev_attr_date.attr,\n\t&dev_attr_erase_size.attr,\n\t&dev_attr_preferred_erase_size.attr,\n\t&dev_attr_fwrev.attr,\n\t&dev_attr_ffu_capable.attr,\n\t&dev_attr_hwrev.attr,\n\t&dev_attr_manfid.attr,\n\t&dev_attr_name.attr,\n\t&dev_attr_oemid.attr,\n\t&dev_attr_prv.attr,\n\t&dev_attr_rev.attr,\n\t&dev_attr_pre_eol_info.attr,\n\t&dev_attr_life_time.attr,\n\t&dev_attr_serial.attr,\n\t&dev_attr_enhanced_area_offset.attr,\n\t&dev_attr_enhanced_area_size.attr,\n\t&dev_attr_raw_rpmb_size_mult.attr,\n\t&dev_attr_enhanced_rpmb_supported.attr,\n\t&dev_attr_rel_sectors.attr,\n\t&dev_attr_ocr.attr,\n\t&dev_attr_rca.attr,\n\t&dev_attr_dsr.attr,\n\t&dev_attr_cmdq_en.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(mmc_std);\n\nstatic struct device_type mmc_type = {\n\t.groups = mmc_std_groups,\n};\n\n \nstatic int __mmc_select_powerclass(struct mmc_card *card,\n\t\t\t\t   unsigned int bus_width)\n{\n\tstruct mmc_host *host = card->host;\n\tstruct mmc_ext_csd *ext_csd = &card->ext_csd;\n\tunsigned int pwrclass_val = 0;\n\tint err = 0;\n\n\tswitch (1 << host->ios.vdd) {\n\tcase MMC_VDD_165_195:\n\t\tif (host->ios.clock <= MMC_HIGH_26_MAX_DTR)\n\t\t\tpwrclass_val = ext_csd->raw_pwr_cl_26_195;\n\t\telse if (host->ios.clock <= MMC_HIGH_52_MAX_DTR)\n\t\t\tpwrclass_val = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?\n\t\t\t\text_csd->raw_pwr_cl_52_195 :\n\t\t\t\text_csd->raw_pwr_cl_ddr_52_195;\n\t\telse if (host->ios.clock <= MMC_HS200_MAX_DTR)\n\t\t\tpwrclass_val = ext_csd->raw_pwr_cl_200_195;\n\t\tbreak;\n\tcase MMC_VDD_27_28:\n\tcase MMC_VDD_28_29:\n\tcase MMC_VDD_29_30:\n\tcase MMC_VDD_30_31:\n\tcase MMC_VDD_31_32:\n\tcase MMC_VDD_32_33:\n\tcase MMC_VDD_33_34:\n\tcase MMC_VDD_34_35:\n\tcase MMC_VDD_35_36:\n\t\tif (host->ios.clock <= MMC_HIGH_26_MAX_DTR)\n\t\t\tpwrclass_val = ext_csd->raw_pwr_cl_26_360;\n\t\telse if (host->ios.clock <= MMC_HIGH_52_MAX_DTR)\n\t\t\tpwrclass_val = (bus_width <= EXT_CSD_BUS_WIDTH_8) ?\n\t\t\t\text_csd->raw_pwr_cl_52_360 :\n\t\t\t\text_csd->raw_pwr_cl_ddr_52_360;\n\t\telse if (host->ios.clock <= MMC_HS200_MAX_DTR)\n\t\t\tpwrclass_val = (bus_width == EXT_CSD_DDR_BUS_WIDTH_8) ?\n\t\t\t\text_csd->raw_pwr_cl_ddr_200_360 :\n\t\t\t\text_csd->raw_pwr_cl_200_360;\n\t\tbreak;\n\tdefault:\n\t\tpr_warn(\"%s: Voltage range not supported for power class\\n\",\n\t\t\tmmc_hostname(host));\n\t\treturn -EINVAL;\n\t}\n\n\tif (bus_width & (EXT_CSD_BUS_WIDTH_8 | EXT_CSD_DDR_BUS_WIDTH_8))\n\t\tpwrclass_val = (pwrclass_val & EXT_CSD_PWR_CL_8BIT_MASK) >>\n\t\t\t\tEXT_CSD_PWR_CL_8BIT_SHIFT;\n\telse\n\t\tpwrclass_val = (pwrclass_val & EXT_CSD_PWR_CL_4BIT_MASK) >>\n\t\t\t\tEXT_CSD_PWR_CL_4BIT_SHIFT;\n\n\t \n\tif (pwrclass_val > 0) {\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t EXT_CSD_POWER_CLASS,\n\t\t\t\t pwrclass_val,\n\t\t\t\t card->ext_csd.generic_cmd6_time);\n\t}\n\n\treturn err;\n}\n\nstatic int mmc_select_powerclass(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tu32 bus_width, ext_csd_bits;\n\tint err, ddr;\n\n\t \n\tif (!mmc_can_ext_csd(card))\n\t\treturn 0;\n\n\tbus_width = host->ios.bus_width;\n\t \n\tif (bus_width == MMC_BUS_WIDTH_1)\n\t\treturn 0;\n\n\tddr = card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52;\n\tif (ddr)\n\t\text_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?\n\t\t\tEXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;\n\telse\n\t\text_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?\n\t\t\tEXT_CSD_BUS_WIDTH_8 :  EXT_CSD_BUS_WIDTH_4;\n\n\terr = __mmc_select_powerclass(card, ext_csd_bits);\n\tif (err)\n\t\tpr_warn(\"%s: power class selection to bus width %d ddr %d failed\\n\",\n\t\t\tmmc_hostname(host), 1 << bus_width, ddr);\n\n\treturn err;\n}\n\n \nstatic void mmc_set_bus_speed(struct mmc_card *card)\n{\n\tunsigned int max_dtr = (unsigned int)-1;\n\n\tif ((mmc_card_hs200(card) || mmc_card_hs400(card)) &&\n\t     max_dtr > card->ext_csd.hs200_max_dtr)\n\t\tmax_dtr = card->ext_csd.hs200_max_dtr;\n\telse if (mmc_card_hs(card) && max_dtr > card->ext_csd.hs_max_dtr)\n\t\tmax_dtr = card->ext_csd.hs_max_dtr;\n\telse if (max_dtr > card->csd.max_dtr)\n\t\tmax_dtr = card->csd.max_dtr;\n\n\tmmc_set_clock(card->host, max_dtr);\n}\n\n \nstatic int mmc_select_bus_width(struct mmc_card *card)\n{\n\tstatic unsigned ext_csd_bits[] = {\n\t\tEXT_CSD_BUS_WIDTH_8,\n\t\tEXT_CSD_BUS_WIDTH_4,\n\t};\n\tstatic unsigned bus_widths[] = {\n\t\tMMC_BUS_WIDTH_8,\n\t\tMMC_BUS_WIDTH_4,\n\t};\n\tstruct mmc_host *host = card->host;\n\tunsigned idx, bus_width = 0;\n\tint err = 0;\n\n\tif (!mmc_can_ext_csd(card) ||\n\t    !(host->caps & (MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA)))\n\t\treturn 0;\n\n\tidx = (host->caps & MMC_CAP_8_BIT_DATA) ? 0 : 1;\n\n\t \n\tfor (; idx < ARRAY_SIZE(bus_widths); idx++) {\n\t\t \n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t EXT_CSD_BUS_WIDTH,\n\t\t\t\t ext_csd_bits[idx],\n\t\t\t\t card->ext_csd.generic_cmd6_time);\n\t\tif (err)\n\t\t\tcontinue;\n\n\t\tbus_width = bus_widths[idx];\n\t\tmmc_set_bus_width(host, bus_width);\n\n\t\t \n\t\tif (!(host->caps & MMC_CAP_BUS_WIDTH_TEST))\n\t\t\terr = mmc_compare_ext_csds(card, bus_width);\n\t\telse\n\t\t\terr = mmc_bus_test(card, bus_width);\n\n\t\tif (!err) {\n\t\t\terr = bus_width;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tpr_warn(\"%s: switch to bus width %d failed\\n\",\n\t\t\t\tmmc_hostname(host), 1 << bus_width);\n\t\t}\n\t}\n\n\treturn err;\n}\n\n \nstatic int mmc_select_hs(struct mmc_card *card)\n{\n\tint err;\n\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,\n\t\t\t   card->ext_csd.generic_cmd6_time, MMC_TIMING_MMC_HS,\n\t\t\t   true, true, MMC_CMD_RETRIES);\n\tif (err)\n\t\tpr_warn(\"%s: switch to high-speed failed, err:%d\\n\",\n\t\t\tmmc_hostname(card->host), err);\n\n\treturn err;\n}\n\n \nstatic int mmc_select_hs_ddr(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tu32 bus_width, ext_csd_bits;\n\tint err = 0;\n\n\tif (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_52))\n\t\treturn 0;\n\n\tbus_width = host->ios.bus_width;\n\tif (bus_width == MMC_BUS_WIDTH_1)\n\t\treturn 0;\n\n\text_csd_bits = (bus_width == MMC_BUS_WIDTH_8) ?\n\t\tEXT_CSD_DDR_BUS_WIDTH_8 : EXT_CSD_DDR_BUS_WIDTH_4;\n\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_BUS_WIDTH,\n\t\t\t   ext_csd_bits,\n\t\t\t   card->ext_csd.generic_cmd6_time,\n\t\t\t   MMC_TIMING_MMC_DDR52,\n\t\t\t   true, true, MMC_CMD_RETRIES);\n\tif (err) {\n\t\tpr_err(\"%s: switch to bus width %d ddr failed\\n\",\n\t\t\tmmc_hostname(host), 1 << bus_width);\n\t\treturn err;\n\t}\n\n\t \n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_2V) {\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);\n\t\tif (!err)\n\t\t\treturn 0;\n\t}\n\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_DDR_1_8V &&\n\t    host->caps & MMC_CAP_1_8V_DDR)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);\n\n\t \n\tif (err)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_330);\n\n\treturn err;\n}\n\nstatic int mmc_select_hs400(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tunsigned int max_dtr;\n\tint err = 0;\n\tu8 val;\n\n\t \n\tif (!(card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&\n\t      host->ios.bus_width == MMC_BUS_WIDTH_8))\n\t\treturn 0;\n\n\t \n\tval = EXT_CSD_TIMING_HS;\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_HS_TIMING, val,\n\t\t\t   card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err) {\n\t\tpr_err(\"%s: switch to high-speed from hs200 failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\treturn err;\n\t}\n\n\t \n\tif (host->ops->hs400_downgrade)\n\t\thost->ops->hs400_downgrade(host);\n\n\t \n\tmmc_set_timing(host, MMC_TIMING_MMC_HS);\n\n\t \n\tmax_dtr = card->ext_csd.hs_max_dtr;\n\tmmc_set_clock(host, max_dtr);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (host->ops->hs400_prepare_ddr)\n\t\thost->ops->hs400_prepare_ddr(host);\n\n\t \n\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t EXT_CSD_BUS_WIDTH,\n\t\t\t EXT_CSD_DDR_BUS_WIDTH_8,\n\t\t\t card->ext_csd.generic_cmd6_time);\n\tif (err) {\n\t\tpr_err(\"%s: switch to bus width for hs400 failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\treturn err;\n\t}\n\n\t \n\tval = EXT_CSD_TIMING_HS400 |\n\t      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_HS_TIMING, val,\n\t\t\t   card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err) {\n\t\tpr_err(\"%s: switch to hs400 failed, err:%d\\n\",\n\t\t\t mmc_hostname(host), err);\n\t\treturn err;\n\t}\n\n\t \n\tmmc_set_timing(host, MMC_TIMING_MMC_HS400);\n\tmmc_set_bus_speed(card);\n\n\tif (host->ops->execute_hs400_tuning) {\n\t\tmmc_retune_disable(host);\n\t\terr = host->ops->execute_hs400_tuning(host, card);\n\t\tmmc_retune_enable(host);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tif (host->ops->hs400_complete)\n\t\thost->ops->hs400_complete(host);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tpr_err(\"%s: %s failed, error %d\\n\", mmc_hostname(card->host),\n\t       __func__, err);\n\treturn err;\n}\n\nint mmc_hs200_to_hs400(struct mmc_card *card)\n{\n\treturn mmc_select_hs400(card);\n}\n\nint mmc_hs400_to_hs200(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tunsigned int max_dtr;\n\tint err;\n\tu8 val;\n\n\t \n\tmax_dtr = card->ext_csd.hs_max_dtr;\n\tmmc_set_clock(host, max_dtr);\n\n\t \n\tval = EXT_CSD_TIMING_HS;\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,\n\t\t\t   val, card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (host->ops->hs400_downgrade)\n\t\thost->ops->hs400_downgrade(host);\n\n\tmmc_set_timing(host, MMC_TIMING_MMC_DDR52);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_BUS_WIDTH,\n\t\t\t   EXT_CSD_BUS_WIDTH_8, card->ext_csd.generic_cmd6_time,\n\t\t\t   0, false, true, MMC_CMD_RETRIES);\n\tif (err)\n\t\tgoto out_err;\n\n\tmmc_set_timing(host, MMC_TIMING_MMC_HS);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\tval = EXT_CSD_TIMING_HS200 |\n\t      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING,\n\t\t\t   val, card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err)\n\t\tgoto out_err;\n\n\tmmc_set_timing(host, MMC_TIMING_MMC_HS200);\n\n\t \n\terr = mmc_switch_status(card, false);\n\tif (err)\n\t\tgoto out_err;\n\n\tmmc_set_bus_speed(card);\n\n\t \n\tif (host->ops->prepare_hs400_tuning)\n\t\thost->ops->prepare_hs400_tuning(host, &host->ios);\n\n\treturn 0;\n\nout_err:\n\tpr_err(\"%s: %s failed, error %d\\n\", mmc_hostname(card->host),\n\t       __func__, err);\n\treturn err;\n}\n\nstatic void mmc_select_driver_type(struct mmc_card *card)\n{\n\tint card_drv_type, drive_strength, drv_type = 0;\n\tint fixed_drv_type = card->host->fixed_drv_type;\n\n\tcard_drv_type = card->ext_csd.raw_driver_strength |\n\t\t\tmmc_driver_type_mask(0);\n\n\tif (fixed_drv_type >= 0)\n\t\tdrive_strength = card_drv_type & mmc_driver_type_mask(fixed_drv_type)\n\t\t\t\t ? fixed_drv_type : 0;\n\telse\n\t\tdrive_strength = mmc_select_drive_strength(card,\n\t\t\t\t\t\t\t   card->ext_csd.hs200_max_dtr,\n\t\t\t\t\t\t\t   card_drv_type, &drv_type);\n\n\tcard->drive_strength = drive_strength;\n\n\tif (drv_type)\n\t\tmmc_set_driver_type(card->host, drv_type);\n}\n\nstatic int mmc_select_hs400es(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tint err = -EINVAL;\n\tu8 val;\n\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400_1_2V)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);\n\n\tif (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400_1_8V)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);\n\n\t \n\tif (err)\n\t\tgoto out_err;\n\n\terr = mmc_select_bus_width(card);\n\tif (err != MMC_BUS_WIDTH_8) {\n\t\tpr_err(\"%s: switch to 8bit bus width failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\terr = err < 0 ? err : -ENOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\t \n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_HS_TIMING, EXT_CSD_TIMING_HS,\n\t\t\t   card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err) {\n\t\tpr_err(\"%s: switch to hs for hs400es failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tgoto out_err;\n\t}\n\n\t \n\tmmc_set_timing(host, MMC_TIMING_MMC_HS);\n\tmmc_set_bus_speed(card);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\t \n\tval = EXT_CSD_DDR_BUS_WIDTH_8 | EXT_CSD_BUS_WIDTH_STROBE;\n\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t EXT_CSD_BUS_WIDTH,\n\t\t\t val,\n\t\t\t card->ext_csd.generic_cmd6_time);\n\tif (err) {\n\t\tpr_err(\"%s: switch to bus width for hs400es failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tgoto out_err;\n\t}\n\n\tmmc_select_driver_type(card);\n\n\t \n\tval = EXT_CSD_TIMING_HS400 |\n\t      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t   EXT_CSD_HS_TIMING, val,\n\t\t\t   card->ext_csd.generic_cmd6_time, 0,\n\t\t\t   false, true, MMC_CMD_RETRIES);\n\tif (err) {\n\t\tpr_err(\"%s: switch to hs400es failed, err:%d\\n\",\n\t\t\tmmc_hostname(host), err);\n\t\tgoto out_err;\n\t}\n\n\t \n\tmmc_set_timing(host, MMC_TIMING_MMC_HS400);\n\n\t \n\thost->ios.enhanced_strobe = true;\n\tif (host->ops->hs400_enhanced_strobe)\n\t\thost->ops->hs400_enhanced_strobe(host, &host->ios);\n\n\terr = mmc_switch_status(card, true);\n\tif (err)\n\t\tgoto out_err;\n\n\treturn 0;\n\nout_err:\n\tpr_err(\"%s: %s failed, error %d\\n\", mmc_hostname(card->host),\n\t       __func__, err);\n\treturn err;\n}\n\n \nstatic int mmc_select_hs200(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\tunsigned int old_timing, old_signal_voltage, old_clock;\n\tint err = -EINVAL;\n\tu8 val;\n\n\told_signal_voltage = host->ios.signal_voltage;\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_2V)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);\n\n\tif (err && card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200_1_8V)\n\t\terr = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);\n\n\t \n\tif (err)\n\t\treturn err;\n\n\tmmc_select_driver_type(card);\n\n\t \n\terr = mmc_select_bus_width(card);\n\tif (err > 0) {\n\t\tval = EXT_CSD_TIMING_HS200 |\n\t\t      card->drive_strength << EXT_CSD_DRV_STR_SHIFT;\n\t\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t   EXT_CSD_HS_TIMING, val,\n\t\t\t\t   card->ext_csd.generic_cmd6_time, 0,\n\t\t\t\t   false, true, MMC_CMD_RETRIES);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\t \n\t\told_timing = host->ios.timing;\n\t\told_clock = host->ios.clock;\n\t\tmmc_set_timing(host, MMC_TIMING_MMC_HS200);\n\t\tmmc_set_clock(card->host, card->ext_csd.hs_max_dtr);\n\n\t\t \n\t\terr = mmc_switch_status(card, false);\n\n\t\t \n\t\tif (err == -EBADMSG) {\n\t\t\tmmc_set_clock(host, old_clock);\n\t\t\tmmc_set_timing(host, old_timing);\n\t\t}\n\t}\nerr:\n\tif (err) {\n\t\t \n\t\tif (mmc_set_signal_voltage(host, old_signal_voltage))\n\t\t\terr = -EIO;\n\n\t\tpr_err(\"%s: %s failed, error %d\\n\", mmc_hostname(card->host),\n\t\t       __func__, err);\n\t}\n\treturn err;\n}\n\n \nstatic int mmc_select_timing(struct mmc_card *card)\n{\n\tint err = 0;\n\n\tif (!mmc_can_ext_csd(card))\n\t\tgoto bus_speed;\n\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400ES) {\n\t\terr = mmc_select_hs400es(card);\n\t\tgoto out;\n\t}\n\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS200) {\n\t\terr = mmc_select_hs200(card);\n\t\tif (err == -EBADMSG)\n\t\t\tcard->mmc_avail_type &= ~EXT_CSD_CARD_TYPE_HS200;\n\t\telse\n\t\t\tgoto out;\n\t}\n\n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS)\n\t\terr = mmc_select_hs(card);\n\nout:\n\tif (err && err != -EBADMSG)\n\t\treturn err;\n\nbus_speed:\n\t \n\tmmc_set_bus_speed(card);\n\treturn 0;\n}\n\n \nstatic int mmc_hs200_tuning(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\n\t \n\tif (card->mmc_avail_type & EXT_CSD_CARD_TYPE_HS400 &&\n\t    host->ios.bus_width == MMC_BUS_WIDTH_8)\n\t\tif (host->ops->prepare_hs400_tuning)\n\t\t\thost->ops->prepare_hs400_tuning(host, &host->ios);\n\n\treturn mmc_execute_tuning(card);\n}\n\n \nstatic int mmc_init_card(struct mmc_host *host, u32 ocr,\n\tstruct mmc_card *oldcard)\n{\n\tstruct mmc_card *card;\n\tint err;\n\tu32 cid[4];\n\tu32 rocr;\n\n\tWARN_ON(!host->claimed);\n\n\t \n\tif (!mmc_host_is_spi(host))\n\t\tmmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);\n\n\t \n\tmmc_go_idle(host);\n\n\t \n\terr = mmc_send_op_cond(host, ocr | (1 << 30), &rocr);\n\tif (err)\n\t\tgoto err;\n\n\t \n\tif (mmc_host_is_spi(host)) {\n\t\terr = mmc_spi_set_crc(host, use_spi_crc);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\t \n\terr = mmc_send_cid(host, cid);\n\tif (err)\n\t\tgoto err;\n\n\tif (oldcard) {\n\t\tif (memcmp(cid, oldcard->raw_cid, sizeof(cid)) != 0) {\n\t\t\tpr_debug(\"%s: Perhaps the card was replaced\\n\",\n\t\t\t\tmmc_hostname(host));\n\t\t\terr = -ENOENT;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcard = oldcard;\n\t} else {\n\t\t \n\t\tcard = mmc_alloc_card(host, &mmc_type);\n\t\tif (IS_ERR(card)) {\n\t\t\terr = PTR_ERR(card);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcard->ocr = ocr;\n\t\tcard->type = MMC_TYPE_MMC;\n\t\tcard->rca = 1;\n\t\tmemcpy(card->raw_cid, cid, sizeof(card->raw_cid));\n\t}\n\n\t \n\tif (host->ops->init_card)\n\t\thost->ops->init_card(host, card);\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_set_relative_addr(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t\tmmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);\n\t}\n\n\tif (!oldcard) {\n\t\t \n\t\terr = mmc_send_csd(card, card->raw_csd);\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t\terr = mmc_decode_csd(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t\terr = mmc_decode_cid(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\t \n\tif (card->csd.dsr_imp && host->dsr_req)\n\t\tmmc_set_dsr(host);\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_select_card(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\t}\n\n\tif (!oldcard) {\n\t\t \n\t\terr = mmc_read_ext_csd(card);\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t\t \n\t\tif (rocr & BIT(30))\n\t\t\tmmc_card_set_blockaddr(card);\n\n\t\t \n\t\tmmc_set_erase_size(card);\n\t}\n\n\t \n\tif (card->ext_csd.rev >= 3) {\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t EXT_CSD_ERASE_GROUP_DEF, 1,\n\t\t\t\t card->ext_csd.generic_cmd6_time);\n\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\n\t\tif (err) {\n\t\t\t \n\t\t\tcard->ext_csd.enhanced_area_offset = -EINVAL;\n\t\t\tcard->ext_csd.enhanced_area_size = -EINVAL;\n\t\t} else {\n\t\t\tcard->ext_csd.erase_group_def = 1;\n\t\t\t \n\t\t\tmmc_set_erase_size(card);\n\t\t}\n\t}\n\n\t \n\tif (card->ext_csd.part_config & EXT_CSD_PART_CONFIG_ACC_MASK) {\n\t\tcard->ext_csd.part_config &= ~EXT_CSD_PART_CONFIG_ACC_MASK;\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONFIG,\n\t\t\t\t card->ext_csd.part_config,\n\t\t\t\t card->ext_csd.part_time);\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\t}\n\n\t \n\tif (card->ext_csd.rev >= 6) {\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t EXT_CSD_POWER_OFF_NOTIFICATION,\n\t\t\t\t EXT_CSD_POWER_ON,\n\t\t\t\t card->ext_csd.generic_cmd6_time);\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\n\t\t \n\t\tif (!err)\n\t\t\tcard->ext_csd.power_off_notification = EXT_CSD_POWER_ON;\n\t}\n\n\t \n\tif (mmc_can_discard(card))\n\t\tcard->erase_arg = MMC_DISCARD_ARG;\n\telse if (mmc_can_trim(card))\n\t\tcard->erase_arg = MMC_TRIM_ARG;\n\telse\n\t\tcard->erase_arg = MMC_ERASE_ARG;\n\n\t \n\terr = mmc_select_timing(card);\n\tif (err)\n\t\tgoto free_card;\n\n\tif (mmc_card_hs200(card)) {\n\t\thost->doing_init_tune = 1;\n\n\t\terr = mmc_hs200_tuning(card);\n\t\tif (!err)\n\t\t\terr = mmc_select_hs400(card);\n\n\t\thost->doing_init_tune = 0;\n\n\t\tif (err)\n\t\t\tgoto free_card;\n\n\t} else if (!mmc_card_hs400es(card)) {\n\t\t \n\t\terr = mmc_select_bus_width(card);\n\t\tif (err > 0 && mmc_card_hs(card)) {\n\t\t\terr = mmc_select_hs_ddr(card);\n\t\t\tif (err)\n\t\t\t\tgoto free_card;\n\t\t}\n\t}\n\n\t \n\tmmc_select_powerclass(card);\n\n\t \n\tif (card->ext_csd.hpi) {\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\tEXT_CSD_HPI_MGMT, 1,\n\t\t\t\tcard->ext_csd.generic_cmd6_time);\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Enabling HPI failed\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t\tcard->ext_csd.hpi_en = 0;\n\t\t} else {\n\t\t\tcard->ext_csd.hpi_en = 1;\n\t\t}\n\t}\n\n\t \n\tif (card->ext_csd.cache_size > 0) {\n\t\tunsigned int timeout_ms = MIN_CACHE_EN_TIMEOUT_MS;\n\n\t\ttimeout_ms = max(card->ext_csd.generic_cmd6_time, timeout_ms);\n\t\terr = mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\tEXT_CSD_CACHE_CTRL, 1, timeout_ms);\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\n\t\t \n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Cache is supported, but failed to turn on (%d)\\n\",\n\t\t\t\tmmc_hostname(card->host), err);\n\t\t\tcard->ext_csd.cache_ctrl = 0;\n\t\t} else {\n\t\t\tcard->ext_csd.cache_ctrl = 1;\n\t\t}\n\t}\n\n\t \n\tcard->ext_csd.cmdq_en = false;\n\tif (card->ext_csd.cmdq_support && host->caps2 & MMC_CAP2_CQE) {\n\t\terr = mmc_cmdq_enable(card);\n\t\tif (err && err != -EBADMSG)\n\t\t\tgoto free_card;\n\t\tif (err) {\n\t\t\tpr_warn(\"%s: Enabling CMDQ failed\\n\",\n\t\t\t\tmmc_hostname(card->host));\n\t\t\tcard->ext_csd.cmdq_support = false;\n\t\t\tcard->ext_csd.cmdq_depth = 0;\n\t\t}\n\t}\n\t \n\tcard->reenable_cmdq = card->ext_csd.cmdq_en;\n\n\tif (host->cqe_ops && !host->cqe_enabled) {\n\t\terr = host->cqe_ops->cqe_enable(host, card);\n\t\tif (!err) {\n\t\t\thost->cqe_enabled = true;\n\n\t\t\tif (card->ext_csd.cmdq_en) {\n\t\t\t\tpr_info(\"%s: Command Queue Engine enabled\\n\",\n\t\t\t\t\tmmc_hostname(host));\n\t\t\t} else {\n\t\t\t\thost->hsq_enabled = true;\n\t\t\t\tpr_info(\"%s: Host Software Queue enabled\\n\",\n\t\t\t\t\tmmc_hostname(host));\n\t\t\t}\n\t\t}\n\t}\n\n\tif (host->caps2 & MMC_CAP2_AVOID_3_3V &&\n\t    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\tpr_err(\"%s: Host failed to negotiate down from 3.3V\\n\",\n\t\t\tmmc_hostname(host));\n\t\terr = -EINVAL;\n\t\tgoto free_card;\n\t}\n\n\tif (!oldcard)\n\t\thost->card = card;\n\n\treturn 0;\n\nfree_card:\n\tif (!oldcard)\n\t\tmmc_remove_card(card);\nerr:\n\treturn err;\n}\n\nstatic int mmc_can_sleep(struct mmc_card *card)\n{\n\treturn card->ext_csd.rev >= 3;\n}\n\nstatic int mmc_sleep_busy_cb(void *cb_data, bool *busy)\n{\n\tstruct mmc_host *host = cb_data;\n\n\t*busy = host->ops->card_busy(host);\n\treturn 0;\n}\n\nstatic int mmc_sleep(struct mmc_host *host)\n{\n\tstruct mmc_command cmd = {};\n\tstruct mmc_card *card = host->card;\n\tunsigned int timeout_ms = DIV_ROUND_UP(card->ext_csd.sa_timeout, 10000);\n\tbool use_r1b_resp;\n\tint err;\n\n\t \n\tmmc_retune_hold(host);\n\n\terr = mmc_deselect_cards(host);\n\tif (err)\n\t\tgoto out_release;\n\n\tcmd.opcode = MMC_SLEEP_AWAKE;\n\tcmd.arg = card->rca << 16;\n\tcmd.arg |= 1 << 15;\n\tuse_r1b_resp = mmc_prepare_busy_cmd(host, &cmd, timeout_ms);\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err)\n\t\tgoto out_release;\n\n\t \n\tif (host->caps & MMC_CAP_WAIT_WHILE_BUSY && use_r1b_resp)\n\t\tgoto out_release;\n\n\tif (!host->ops->card_busy) {\n\t\tmmc_delay(timeout_ms);\n\t\tgoto out_release;\n\t}\n\n\terr = __mmc_poll_for_busy(host, 0, timeout_ms, &mmc_sleep_busy_cb, host);\n\nout_release:\n\tmmc_retune_release(host);\n\treturn err;\n}\n\nstatic int mmc_can_poweroff_notify(const struct mmc_card *card)\n{\n\treturn card &&\n\t\tmmc_card_mmc(card) &&\n\t\t(card->ext_csd.power_off_notification == EXT_CSD_POWER_ON);\n}\n\nstatic int mmc_poweroff_notify(struct mmc_card *card, unsigned int notify_type)\n{\n\tunsigned int timeout = card->ext_csd.generic_cmd6_time;\n\tint err;\n\n\t \n\tif (notify_type == EXT_CSD_POWER_OFF_LONG)\n\t\ttimeout = card->ext_csd.power_off_longtime;\n\n\terr = __mmc_switch(card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\tEXT_CSD_POWER_OFF_NOTIFICATION,\n\t\t\tnotify_type, timeout, 0, false, false, MMC_CMD_RETRIES);\n\tif (err)\n\t\tpr_err(\"%s: Power Off Notification timed out, %u\\n\",\n\t\t       mmc_hostname(card->host), timeout);\n\n\t \n\tcard->ext_csd.power_off_notification = EXT_CSD_NO_POWER_NOTIFICATION;\n\n\treturn err;\n}\n\n \nstatic void mmc_remove(struct mmc_host *host)\n{\n\tmmc_remove_card(host->card);\n\thost->card = NULL;\n}\n\n \nstatic int mmc_alive(struct mmc_host *host)\n{\n\treturn mmc_send_status(host->card, NULL);\n}\n\n \nstatic void mmc_detect(struct mmc_host *host)\n{\n\tint err;\n\n\tmmc_get_card(host->card, NULL);\n\n\t \n\terr = _mmc_detect_card_removed(host);\n\n\tmmc_put_card(host->card, NULL);\n\n\tif (err) {\n\t\tmmc_remove(host);\n\n\t\tmmc_claim_host(host);\n\t\tmmc_detach_bus(host);\n\t\tmmc_power_off(host);\n\t\tmmc_release_host(host);\n\t}\n}\n\nstatic bool _mmc_cache_enabled(struct mmc_host *host)\n{\n\treturn host->card->ext_csd.cache_size > 0 &&\n\t       host->card->ext_csd.cache_ctrl & 1;\n}\n\n \nstatic int _mmc_flush_cache(struct mmc_host *host)\n{\n\tint err = 0;\n\n\tif (mmc_card_broken_cache_flush(host->card) && !host->card->written_flag)\n\t\treturn 0;\n\n\tif (_mmc_cache_enabled(host)) {\n\t\terr = mmc_switch(host->card, EXT_CSD_CMD_SET_NORMAL,\n\t\t\t\t EXT_CSD_FLUSH_CACHE, 1,\n\t\t\t\t CACHE_FLUSH_TIMEOUT_MS);\n\t\tif (err)\n\t\t\tpr_err(\"%s: cache flush error %d\\n\", mmc_hostname(host), err);\n\t\telse\n\t\t\thost->card->written_flag = false;\n\t}\n\n\treturn err;\n}\n\nstatic int _mmc_suspend(struct mmc_host *host, bool is_suspend)\n{\n\tint err = 0;\n\tunsigned int notify_type = is_suspend ? EXT_CSD_POWER_OFF_SHORT :\n\t\t\t\t\tEXT_CSD_POWER_OFF_LONG;\n\n\tmmc_claim_host(host);\n\n\tif (mmc_card_suspended(host->card))\n\t\tgoto out;\n\n\terr = _mmc_flush_cache(host);\n\tif (err)\n\t\tgoto out;\n\n\tif (mmc_can_poweroff_notify(host->card) &&\n\t    ((host->caps2 & MMC_CAP2_FULL_PWR_CYCLE) || !is_suspend ||\n\t     (host->caps2 & MMC_CAP2_FULL_PWR_CYCLE_IN_SUSPEND)))\n\t\terr = mmc_poweroff_notify(host->card, notify_type);\n\telse if (mmc_can_sleep(host->card))\n\t\terr = mmc_sleep(host);\n\telse if (!mmc_host_is_spi(host))\n\t\terr = mmc_deselect_cards(host);\n\n\tif (!err) {\n\t\tmmc_power_off(host);\n\t\tmmc_card_set_suspended(host->card);\n\t}\nout:\n\tmmc_release_host(host);\n\treturn err;\n}\n\n \nstatic int mmc_suspend(struct mmc_host *host)\n{\n\tint err;\n\n\terr = _mmc_suspend(host, true);\n\tif (!err) {\n\t\tpm_runtime_disable(&host->card->dev);\n\t\tpm_runtime_set_suspended(&host->card->dev);\n\t}\n\n\treturn err;\n}\n\n \nstatic int _mmc_resume(struct mmc_host *host)\n{\n\tint err = 0;\n\n\tmmc_claim_host(host);\n\n\tif (!mmc_card_suspended(host->card))\n\t\tgoto out;\n\n\tmmc_power_up(host, host->card->ocr);\n\terr = mmc_init_card(host, host->card->ocr, host->card);\n\tmmc_card_clr_suspended(host->card);\n\nout:\n\tmmc_release_host(host);\n\treturn err;\n}\n\n \nstatic int mmc_shutdown(struct mmc_host *host)\n{\n\tint err = 0;\n\n\t \n\tif (mmc_can_poweroff_notify(host->card) &&\n\t\t!(host->caps2 & MMC_CAP2_FULL_PWR_CYCLE))\n\t\terr = _mmc_resume(host);\n\n\tif (!err)\n\t\terr = _mmc_suspend(host, false);\n\n\treturn err;\n}\n\n \nstatic int mmc_resume(struct mmc_host *host)\n{\n\tpm_runtime_enable(&host->card->dev);\n\treturn 0;\n}\n\n \nstatic int mmc_runtime_suspend(struct mmc_host *host)\n{\n\tint err;\n\n\tif (!(host->caps & MMC_CAP_AGGRESSIVE_PM))\n\t\treturn 0;\n\n\terr = _mmc_suspend(host, true);\n\tif (err)\n\t\tpr_err(\"%s: error %d doing aggressive suspend\\n\",\n\t\t\tmmc_hostname(host), err);\n\n\treturn err;\n}\n\n \nstatic int mmc_runtime_resume(struct mmc_host *host)\n{\n\tint err;\n\n\terr = _mmc_resume(host);\n\tif (err && err != -ENOMEDIUM)\n\t\tpr_err(\"%s: error %d doing runtime resume\\n\",\n\t\t\tmmc_hostname(host), err);\n\n\treturn 0;\n}\n\nstatic int mmc_can_reset(struct mmc_card *card)\n{\n\tu8 rst_n_function;\n\n\trst_n_function = card->ext_csd.rst_n_function;\n\tif ((rst_n_function & EXT_CSD_RST_N_EN_MASK) != EXT_CSD_RST_N_ENABLED)\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int _mmc_hw_reset(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\n\t \n\t_mmc_flush_cache(host);\n\n\tif ((host->caps & MMC_CAP_HW_RESET) && host->ops->card_hw_reset &&\n\t     mmc_can_reset(card)) {\n\t\t \n\t\tmmc_set_clock(host, host->f_init);\n\t\thost->ops->card_hw_reset(host);\n\t\t \n\t\tmmc_set_initial_state(host);\n\t} else {\n\t\t \n\t\tmmc_power_cycle(host, card->ocr);\n\t\tmmc_pwrseq_reset(host);\n\t}\n\treturn mmc_init_card(host, card->ocr, card);\n}\n\nstatic const struct mmc_bus_ops mmc_ops = {\n\t.remove = mmc_remove,\n\t.detect = mmc_detect,\n\t.suspend = mmc_suspend,\n\t.resume = mmc_resume,\n\t.runtime_suspend = mmc_runtime_suspend,\n\t.runtime_resume = mmc_runtime_resume,\n\t.alive = mmc_alive,\n\t.shutdown = mmc_shutdown,\n\t.hw_reset = _mmc_hw_reset,\n\t.cache_enabled = _mmc_cache_enabled,\n\t.flush_cache = _mmc_flush_cache,\n};\n\n \nint mmc_attach_mmc(struct mmc_host *host)\n{\n\tint err;\n\tu32 ocr, rocr;\n\n\tWARN_ON(!host->claimed);\n\n\t \n\tif (!mmc_host_is_spi(host))\n\t\tmmc_set_bus_mode(host, MMC_BUSMODE_OPENDRAIN);\n\n\terr = mmc_send_op_cond(host, 0, &ocr);\n\tif (err)\n\t\treturn err;\n\n\tmmc_attach_bus(host, &mmc_ops);\n\tif (host->ocr_avail_mmc)\n\t\thost->ocr_avail = host->ocr_avail_mmc;\n\n\t \n\tif (mmc_host_is_spi(host)) {\n\t\terr = mmc_spi_read_ocr(host, 1, &ocr);\n\t\tif (err)\n\t\t\tgoto err;\n\t}\n\n\trocr = mmc_select_voltage(host, ocr);\n\n\t \n\tif (!rocr) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\terr = mmc_init_card(host, rocr, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tmmc_release_host(host);\n\terr = mmc_add_card(host->card);\n\tif (err)\n\t\tgoto remove_card;\n\n\tmmc_claim_host(host);\n\treturn 0;\n\nremove_card:\n\tmmc_remove_card(host->card);\n\tmmc_claim_host(host);\n\thost->card = NULL;\nerr:\n\tmmc_detach_bus(host);\n\n\tpr_err(\"%s: error %d whilst initialising MMC card\\n\",\n\t\tmmc_hostname(host), err);\n\n\treturn err;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}