{
  "module_name": "sdio_irq.c",
  "hash_id": "cfc02aed0f9d365c7cd9fcfd3846fc2d50ec7e7ed98cfbc4655fc66a4e3be066",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_irq.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/wait.h>\n#include <linux/delay.h>\n\n#include <linux/mmc/core.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"sdio_ops.h\"\n#include \"core.h\"\n#include \"card.h\"\n\nstatic int sdio_get_pending_irqs(struct mmc_host *host, u8 *pending)\n{\n\tstruct mmc_card *card = host->card;\n\tint ret;\n\n\tWARN_ON(!host->claimed);\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTx, 0, pending);\n\tif (ret) {\n\t\tpr_debug(\"%s: error %d reading SDIO_CCCR_INTx\\n\",\n\t\t       mmc_card_id(card), ret);\n\t\treturn ret;\n\t}\n\n\tif (*pending && mmc_card_broken_irq_polling(card) &&\n\t    !(host->caps & MMC_CAP_SDIO_IRQ)) {\n\t\tunsigned char dummy;\n\n\t\t \n\t\tmmc_io_rw_direct(card, 0, 0, 0xff, 0, &dummy);\n\t}\n\n\treturn 0;\n}\n\nstatic int process_sdio_pending_irqs(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\tint i, ret, count;\n\tbool sdio_irq_pending = host->sdio_irq_pending;\n\tunsigned char pending;\n\tstruct sdio_func *func;\n\n\t \n\tif (mmc_card_suspended(card))\n\t\treturn 0;\n\n\t \n\thost->sdio_irq_pending = false;\n\n\t \n\tfunc = card->sdio_single_irq;\n\tif (func && sdio_irq_pending) {\n\t\tfunc->irq_handler(func);\n\t\treturn 1;\n\t}\n\n\tret = sdio_get_pending_irqs(host, &pending);\n\tif (ret)\n\t\treturn ret;\n\n\tcount = 0;\n\tfor (i = 1; i <= 7; i++) {\n\t\tif (pending & (1 << i)) {\n\t\t\tfunc = card->sdio_func[i - 1];\n\t\t\tif (!func) {\n\t\t\t\tpr_warn(\"%s: pending IRQ for non-existent function\\n\",\n\t\t\t\t\tmmc_card_id(card));\n\t\t\t\tret = -EINVAL;\n\t\t\t} else if (func->irq_handler) {\n\t\t\t\tfunc->irq_handler(func);\n\t\t\t\tcount++;\n\t\t\t} else {\n\t\t\t\tpr_warn(\"%s: pending IRQ with no handler\\n\",\n\t\t\t\t\tsdio_func_id(func));\n\t\t\t\tret = -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (count)\n\t\treturn count;\n\n\treturn ret;\n}\n\nstatic void sdio_run_irqs(struct mmc_host *host)\n{\n\tmmc_claim_host(host);\n\tif (host->sdio_irqs) {\n\t\tprocess_sdio_pending_irqs(host);\n\t\tif (!host->sdio_irq_pending)\n\t\t\thost->ops->ack_sdio_irq(host);\n\t}\n\tmmc_release_host(host);\n}\n\nvoid sdio_irq_work(struct work_struct *work)\n{\n\tstruct mmc_host *host =\n\t\tcontainer_of(work, struct mmc_host, sdio_irq_work);\n\n\tsdio_run_irqs(host);\n}\n\nvoid sdio_signal_irq(struct mmc_host *host)\n{\n\thost->sdio_irq_pending = true;\n\tschedule_work(&host->sdio_irq_work);\n}\nEXPORT_SYMBOL_GPL(sdio_signal_irq);\n\nstatic int sdio_irq_thread(void *_host)\n{\n\tstruct mmc_host *host = _host;\n\tunsigned long period, idle_period;\n\tint ret;\n\n\tsched_set_fifo_low(current);\n\n\t \n\tidle_period = msecs_to_jiffies(10);\n\tperiod = (host->caps & MMC_CAP_SDIO_IRQ) ?\n\t\tMAX_SCHEDULE_TIMEOUT : idle_period;\n\n\tpr_debug(\"%s: IRQ thread started (poll period = %lu jiffies)\\n\",\n\t\t mmc_hostname(host), period);\n\n\tdo {\n\t\t \n\t\tret = __mmc_claim_host(host, NULL,\n\t\t\t\t       &host->sdio_irq_thread_abort);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = process_sdio_pending_irqs(host);\n\t\tmmc_release_host(host);\n\n\t\t \n\t\tif (ret < 0) {\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (!kthread_should_stop())\n\t\t\t\tschedule_timeout(HZ);\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t}\n\n\t\t \n\t\tif (!(host->caps & MMC_CAP_SDIO_IRQ)) {\n\t\t\tif (ret > 0)\n\t\t\t\tperiod /= 2;\n\t\t\telse {\n\t\t\t\tperiod++;\n\t\t\t\tif (period > idle_period)\n\t\t\t\t\tperiod = idle_period;\n\t\t\t}\n\t\t}\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (host->caps & MMC_CAP_SDIO_IRQ)\n\t\t\thost->ops->enable_sdio_irq(host, 1);\n\t\tif (!kthread_should_stop())\n\t\t\tschedule_timeout(period);\n\t\tset_current_state(TASK_RUNNING);\n\t} while (!kthread_should_stop());\n\n\tif (host->caps & MMC_CAP_SDIO_IRQ)\n\t\thost->ops->enable_sdio_irq(host, 0);\n\n\tpr_debug(\"%s: IRQ thread exiting with code %d\\n\",\n\t\t mmc_hostname(host), ret);\n\n\treturn ret;\n}\n\nstatic int sdio_card_irq_get(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\n\tWARN_ON(!host->claimed);\n\n\tif (!host->sdio_irqs++) {\n\t\tif (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {\n\t\t\tatomic_set(&host->sdio_irq_thread_abort, 0);\n\t\t\thost->sdio_irq_thread =\n\t\t\t\tkthread_run(sdio_irq_thread, host,\n\t\t\t\t\t    \"ksdioirqd/%s\", mmc_hostname(host));\n\t\t\tif (IS_ERR(host->sdio_irq_thread)) {\n\t\t\t\tint err = PTR_ERR(host->sdio_irq_thread);\n\t\t\t\thost->sdio_irqs--;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (host->caps & MMC_CAP_SDIO_IRQ) {\n\t\t\thost->ops->enable_sdio_irq(host, 1);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int sdio_card_irq_put(struct mmc_card *card)\n{\n\tstruct mmc_host *host = card->host;\n\n\tWARN_ON(!host->claimed);\n\n\tif (host->sdio_irqs < 1)\n\t\treturn -EINVAL;\n\n\tif (!--host->sdio_irqs) {\n\t\tif (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD)) {\n\t\t\tatomic_set(&host->sdio_irq_thread_abort, 1);\n\t\t\tkthread_stop(host->sdio_irq_thread);\n\t\t} else if (host->caps & MMC_CAP_SDIO_IRQ) {\n\t\t\thost->ops->enable_sdio_irq(host, 0);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void sdio_single_irq_set(struct mmc_card *card)\n{\n\tstruct sdio_func *func;\n\tint i;\n\n\tcard->sdio_single_irq = NULL;\n\tif ((card->host->caps & MMC_CAP_SDIO_IRQ) &&\n\t    card->host->sdio_irqs == 1) {\n\t\tfor (i = 0; i < card->sdio_funcs; i++) {\n\t\t\tfunc = card->sdio_func[i];\n\t\t\tif (func && func->irq_handler) {\n\t\t\t\tcard->sdio_single_irq = func;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nint sdio_claim_irq(struct sdio_func *func, sdio_irq_handler_t *handler)\n{\n\tint ret;\n\tunsigned char reg;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"SDIO: Enabling IRQ for %s...\\n\", sdio_func_id(func));\n\n\tif (func->irq_handler) {\n\t\tpr_debug(\"SDIO: IRQ for %s already in use.\\n\", sdio_func_id(func));\n\t\treturn -EBUSY;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treg |= 1 << func->num;\n\n\treg |= 1;  \n\n\tret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tfunc->irq_handler = handler;\n\tret = sdio_card_irq_get(func->card);\n\tif (ret)\n\t\tfunc->irq_handler = NULL;\n\tsdio_single_irq_set(func->card);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(sdio_claim_irq);\n\n \nint sdio_release_irq(struct sdio_func *func)\n{\n\tint ret;\n\tunsigned char reg;\n\n\tif (!func)\n\t\treturn -EINVAL;\n\n\tpr_debug(\"SDIO: Disabling IRQ for %s...\\n\", sdio_func_id(func));\n\n\tif (func->irq_handler) {\n\t\tfunc->irq_handler = NULL;\n\t\tsdio_card_irq_put(func->card);\n\t\tsdio_single_irq_set(func->card);\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, 0, SDIO_CCCR_IENx, 0, &reg);\n\tif (ret)\n\t\treturn ret;\n\n\treg &= ~(1 << func->num);\n\n\t \n\tif (!(reg & 0xFE))\n\t\treg = 0;\n\n\tret = mmc_io_rw_direct(func->card, 1, 0, SDIO_CCCR_IENx, reg, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(sdio_release_irq);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}