{
  "module_name": "sdio.c",
  "hash_id": "ff912bb513e681fdecb3ce2042d3062f34cf521c508e3c274b17a9b209f03734",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/pm_runtime.h>\n#include <linux/sysfs.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sdio.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/mmc/sdio_ids.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"host.h\"\n#include \"bus.h\"\n#include \"quirks.h\"\n#include \"sd.h\"\n#include \"sdio_bus.h\"\n#include \"mmc_ops.h\"\n#include \"sd_ops.h\"\n#include \"sdio_ops.h\"\n#include \"sdio_cis.h\"\n\nMMC_DEV_ATTR(vendor, \"0x%04x\\n\", card->cis.vendor);\nMMC_DEV_ATTR(device, \"0x%04x\\n\", card->cis.device);\nMMC_DEV_ATTR(revision, \"%u.%u\\n\", card->major_rev, card->minor_rev);\nMMC_DEV_ATTR(ocr, \"0x%08x\\n\", card->ocr);\nMMC_DEV_ATTR(rca, \"0x%04x\\n\", card->rca);\n\n#define sdio_info_attr(num)\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t info##num##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstruct mmc_card *card = mmc_dev_to_card(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (num > card->num_info)\t\t\t\t\t\t\t\t\\\n\t\treturn -ENODATA;\t\t\t\t\t\t\t\t\\\n\tif (!card->info[num - 1][0])\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%s\\n\", card->info[num - 1]);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(info##num)\n\nsdio_info_attr(1);\nsdio_info_attr(2);\nsdio_info_attr(3);\nsdio_info_attr(4);\n\nstatic struct attribute *sdio_std_attrs[] = {\n\t&dev_attr_vendor.attr,\n\t&dev_attr_device.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_info1.attr,\n\t&dev_attr_info2.attr,\n\t&dev_attr_info3.attr,\n\t&dev_attr_info4.attr,\n\t&dev_attr_ocr.attr,\n\t&dev_attr_rca.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sdio_std);\n\nstatic struct device_type sdio_type = {\n\t.groups = sdio_std_groups,\n};\n\nstatic int sdio_read_fbr(struct sdio_func *func)\n{\n\tint ret;\n\tunsigned char data;\n\n\tif (mmc_card_nonstd_func_interface(func->card)) {\n\t\tfunc->class = SDIO_CLASS_NONE;\n\t\treturn 0;\n\t}\n\n\tret = mmc_io_rw_direct(func->card, 0, 0,\n\t\tSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF, 0, &data);\n\tif (ret)\n\t\tgoto out;\n\n\tdata &= 0x0f;\n\n\tif (data == 0x0f) {\n\t\tret = mmc_io_rw_direct(func->card, 0, 0,\n\t\t\tSDIO_FBR_BASE(func->num) + SDIO_FBR_STD_IF_EXT, 0, &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tfunc->class = data;\n\nout:\n\treturn ret;\n}\n\nstatic int sdio_init_func(struct mmc_card *card, unsigned int fn)\n{\n\tint ret;\n\tstruct sdio_func *func;\n\n\tif (WARN_ON(fn > SDIO_MAX_FUNCS))\n\t\treturn -EINVAL;\n\n\tfunc = sdio_alloc_func(card);\n\tif (IS_ERR(func))\n\t\treturn PTR_ERR(func);\n\n\tfunc->num = fn;\n\n\tif (!(card->quirks & MMC_QUIRK_NONSTD_SDIO)) {\n\t\tret = sdio_read_fbr(func);\n\t\tif (ret)\n\t\t\tgoto fail;\n\n\t\tret = sdio_read_func_cis(func);\n\t\tif (ret)\n\t\t\tgoto fail;\n\t} else {\n\t\tfunc->vendor = func->card->cis.vendor;\n\t\tfunc->device = func->card->cis.device;\n\t\tfunc->max_blksize = func->card->cis.blksize;\n\t}\n\n\tcard->sdio_func[fn - 1] = func;\n\n\treturn 0;\n\nfail:\n\t \n\tsdio_remove_func(func);\n\treturn ret;\n}\n\nstatic int sdio_read_cccr(struct mmc_card *card, u32 ocr)\n{\n\tint ret;\n\tint cccr_vsn;\n\tint uhs = ocr & R4_18V_PRESENT;\n\tunsigned char data;\n\tunsigned char speed;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CCCR, 0, &data);\n\tif (ret)\n\t\tgoto out;\n\n\tcccr_vsn = data & 0x0f;\n\n\tif (cccr_vsn > SDIO_CCCR_REV_3_00) {\n\t\tpr_err(\"%s: unrecognised CCCR structure version %d\\n\",\n\t\t\tmmc_hostname(card->host), cccr_vsn);\n\t\treturn -EINVAL;\n\t}\n\n\tcard->cccr.sdio_vsn = (data & 0xf0) >> 4;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_CAPS, 0, &data);\n\tif (ret)\n\t\tgoto out;\n\n\tif (data & SDIO_CCCR_CAP_SMB)\n\t\tcard->cccr.multi_block = 1;\n\tif (data & SDIO_CCCR_CAP_LSC)\n\t\tcard->cccr.low_speed = 1;\n\tif (data & SDIO_CCCR_CAP_4BLS)\n\t\tcard->cccr.wide_bus = 1;\n\n\tif (cccr_vsn >= SDIO_CCCR_REV_1_10) {\n\t\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_POWER, 0, &data);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (data & SDIO_POWER_SMPC)\n\t\t\tcard->cccr.high_power = 1;\n\t}\n\n\tif (cccr_vsn >= SDIO_CCCR_REV_1_20) {\n\t\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tcard->scr.sda_spec3 = 0;\n\t\tcard->sw_caps.sd3_bus_mode = 0;\n\t\tcard->sw_caps.sd3_drv_type = 0;\n\t\tif (cccr_vsn >= SDIO_CCCR_REV_3_00 && uhs) {\n\t\t\tcard->scr.sda_spec3 = 1;\n\t\t\tret = mmc_io_rw_direct(card, 0, 0,\n\t\t\t\tSDIO_CCCR_UHS, 0, &data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tif (mmc_host_uhs(card->host)) {\n\t\t\t\tif (data & SDIO_UHS_DDR50)\n\t\t\t\t\tcard->sw_caps.sd3_bus_mode\n\t\t\t\t\t\t|= SD_MODE_UHS_DDR50 | SD_MODE_UHS_SDR50\n\t\t\t\t\t\t\t| SD_MODE_UHS_SDR25 | SD_MODE_UHS_SDR12;\n\n\t\t\t\tif (data & SDIO_UHS_SDR50)\n\t\t\t\t\tcard->sw_caps.sd3_bus_mode\n\t\t\t\t\t\t|= SD_MODE_UHS_SDR50 | SD_MODE_UHS_SDR25\n\t\t\t\t\t\t\t| SD_MODE_UHS_SDR12;\n\n\t\t\t\tif (data & SDIO_UHS_SDR104)\n\t\t\t\t\tcard->sw_caps.sd3_bus_mode\n\t\t\t\t\t\t|= SD_MODE_UHS_SDR104 | SD_MODE_UHS_SDR50\n\t\t\t\t\t\t\t| SD_MODE_UHS_SDR25 | SD_MODE_UHS_SDR12;\n\t\t\t}\n\n\t\t\tret = mmc_io_rw_direct(card, 0, 0,\n\t\t\t\tSDIO_CCCR_DRIVE_STRENGTH, 0, &data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tif (data & SDIO_DRIVE_SDTA)\n\t\t\t\tcard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_A;\n\t\t\tif (data & SDIO_DRIVE_SDTC)\n\t\t\t\tcard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_C;\n\t\t\tif (data & SDIO_DRIVE_SDTD)\n\t\t\t\tcard->sw_caps.sd3_drv_type |= SD_DRIVER_TYPE_D;\n\n\t\t\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_INTERRUPT_EXT, 0, &data);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\tif (data & SDIO_INTERRUPT_EXT_SAI) {\n\t\t\t\tdata |= SDIO_INTERRUPT_EXT_EAI;\n\t\t\t\tret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_INTERRUPT_EXT,\n\t\t\t\t\t\t       data, NULL);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out;\n\n\t\t\t\tcard->cccr.enable_async_irq = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!card->sw_caps.sd3_bus_mode) {\n\t\t\tif (speed & SDIO_SPEED_SHS) {\n\t\t\t\tcard->cccr.high_speed = 1;\n\t\t\t\tcard->sw_caps.hs_max_dtr = 50000000;\n\t\t\t} else {\n\t\t\t\tcard->cccr.high_speed = 0;\n\t\t\t\tcard->sw_caps.hs_max_dtr = 25000000;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic int sdio_enable_wide(struct mmc_card *card)\n{\n\tint ret;\n\tu8 ctrl;\n\n\tif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\n\t\treturn 0;\n\n\tif (card->cccr.low_speed && !card->cccr.wide_bus)\n\t\treturn 0;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif ((ctrl & SDIO_BUS_WIDTH_MASK) == SDIO_BUS_WIDTH_RESERVED)\n\t\tpr_warn(\"%s: SDIO_CCCR_IF is invalid: 0x%02x\\n\",\n\t\t\tmmc_hostname(card->host), ctrl);\n\n\t \n\tctrl &= ~SDIO_BUS_WIDTH_MASK;\n\tctrl |= SDIO_BUS_WIDTH_4BIT;\n\n\tret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 1;\n}\n\n \nstatic int sdio_disable_cd(struct mmc_card *card)\n{\n\tint ret;\n\tu8 ctrl;\n\n\tif (!mmc_card_disable_cd(card))\n\t\treturn 0;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl |= SDIO_BUS_CD_DISABLE;\n\n\treturn mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\n}\n\n \nstatic int sdio_disable_wide(struct mmc_card *card)\n{\n\tint ret;\n\tu8 ctrl;\n\n\tif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\n\t\treturn 0;\n\n\tif (card->cccr.low_speed && !card->cccr.wide_bus)\n\t\treturn 0;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_IF, 0, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(ctrl & SDIO_BUS_WIDTH_4BIT))\n\t\treturn 0;\n\n\tctrl &= ~SDIO_BUS_WIDTH_4BIT;\n\tctrl |= SDIO_BUS_ASYNC_INT;\n\n\tret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_IF, ctrl, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tmmc_set_bus_width(card->host, MMC_BUS_WIDTH_1);\n\n\treturn 0;\n}\n\nstatic int sdio_disable_4bit_bus(struct mmc_card *card)\n{\n\tint err;\n\n\tif (mmc_card_sdio(card))\n\t\tgoto out;\n\n\tif (!(card->host->caps & MMC_CAP_4_BIT_DATA))\n\t\treturn 0;\n\n\tif (!(card->scr.bus_widths & SD_SCR_BUS_WIDTH_4))\n\t\treturn 0;\n\n\terr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_1);\n\tif (err)\n\t\treturn err;\n\nout:\n\treturn sdio_disable_wide(card);\n}\n\n\nstatic int sdio_enable_4bit_bus(struct mmc_card *card)\n{\n\tint err;\n\n\terr = sdio_enable_wide(card);\n\tif (err <= 0)\n\t\treturn err;\n\tif (mmc_card_sdio(card))\n\t\tgoto out;\n\n\tif (card->scr.bus_widths & SD_SCR_BUS_WIDTH_4) {\n\t\terr = mmc_app_set_bus_width(card, MMC_BUS_WIDTH_4);\n\t\tif (err) {\n\t\t\tsdio_disable_wide(card);\n\t\t\treturn err;\n\t\t}\n\t}\nout:\n\tmmc_set_bus_width(card->host, MMC_BUS_WIDTH_4);\n\n\treturn 0;\n}\n\n\n \nstatic int mmc_sdio_switch_hs(struct mmc_card *card, int enable)\n{\n\tint ret;\n\tu8 speed;\n\n\tif (!(card->host->caps & MMC_CAP_SD_HIGHSPEED))\n\t\treturn 0;\n\n\tif (!card->cccr.high_speed)\n\t\treturn 0;\n\n\tret = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\n\tif (ret)\n\t\treturn ret;\n\n\tif (enable)\n\t\tspeed |= SDIO_SPEED_EHS;\n\telse\n\t\tspeed &= ~SDIO_SPEED_EHS;\n\n\tret = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 1;\n}\n\n \nstatic int sdio_enable_hs(struct mmc_card *card)\n{\n\tint ret;\n\n\tret = mmc_sdio_switch_hs(card, true);\n\tif (ret <= 0 || mmc_card_sdio(card))\n\t\treturn ret;\n\n\tret = mmc_sd_switch_hs(card);\n\tif (ret <= 0)\n\t\tmmc_sdio_switch_hs(card, false);\n\n\treturn ret;\n}\n\nstatic unsigned mmc_sdio_get_max_clock(struct mmc_card *card)\n{\n\tunsigned max_dtr;\n\n\tif (mmc_card_hs(card)) {\n\t\t \n\t\tmax_dtr = 50000000;\n\t} else {\n\t\tmax_dtr = card->cis.max_dtr;\n\t}\n\n\tif (mmc_card_sd_combo(card))\n\t\tmax_dtr = min(max_dtr, mmc_sd_get_max_clock(card));\n\n\treturn max_dtr;\n}\n\nstatic unsigned char host_drive_to_sdio_drive(int host_strength)\n{\n\tswitch (host_strength) {\n\tcase MMC_SET_DRIVER_TYPE_A:\n\t\treturn SDIO_DTSx_SET_TYPE_A;\n\tcase MMC_SET_DRIVER_TYPE_B:\n\t\treturn SDIO_DTSx_SET_TYPE_B;\n\tcase MMC_SET_DRIVER_TYPE_C:\n\t\treturn SDIO_DTSx_SET_TYPE_C;\n\tcase MMC_SET_DRIVER_TYPE_D:\n\t\treturn SDIO_DTSx_SET_TYPE_D;\n\tdefault:\n\t\treturn SDIO_DTSx_SET_TYPE_B;\n\t}\n}\n\nstatic void sdio_select_driver_type(struct mmc_card *card)\n{\n\tint card_drv_type, drive_strength, drv_type;\n\tunsigned char card_strength;\n\tint err;\n\n\tcard->drive_strength = 0;\n\n\tcard_drv_type = card->sw_caps.sd3_drv_type | SD_DRIVER_TYPE_B;\n\n\tdrive_strength = mmc_select_drive_strength(card,\n\t\t\t\t\t\t   card->sw_caps.uhs_max_dtr,\n\t\t\t\t\t\t   card_drv_type, &drv_type);\n\n\tif (drive_strength) {\n\t\t \n\t\terr = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_DRIVE_STRENGTH, 0,\n\t\t\t\t       &card_strength);\n\t\tif (err)\n\t\t\treturn;\n\n\t\tcard_strength &= ~(SDIO_DRIVE_DTSx_MASK<<SDIO_DRIVE_DTSx_SHIFT);\n\t\tcard_strength |= host_drive_to_sdio_drive(drive_strength);\n\n\t\t \n\t\terr = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_DRIVE_STRENGTH,\n\t\t\t\t       card_strength, NULL);\n\t\tif (err)\n\t\t\treturn;\n\t\tcard->drive_strength = drive_strength;\n\t}\n\n\tif (drv_type)\n\t\tmmc_set_driver_type(card->host, drv_type);\n}\n\n\nstatic int sdio_set_bus_speed_mode(struct mmc_card *card)\n{\n\tunsigned int bus_speed, timing;\n\tint err;\n\tunsigned char speed;\n\tunsigned int max_rate;\n\n\t \n\tif (!mmc_host_uhs(card->host))\n\t\treturn 0;\n\n\tbus_speed = SDIO_SPEED_SDR12;\n\ttiming = MMC_TIMING_UHS_SDR12;\n\tif ((card->host->caps & MMC_CAP_UHS_SDR104) &&\n\t    (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR104)) {\n\t\t\tbus_speed = SDIO_SPEED_SDR104;\n\t\t\ttiming = MMC_TIMING_UHS_SDR104;\n\t\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR104_MAX_DTR;\n\t\t\tcard->sd_bus_speed = UHS_SDR104_BUS_SPEED;\n\t} else if ((card->host->caps & MMC_CAP_UHS_DDR50) &&\n\t\t   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_DDR50)) {\n\t\t\tbus_speed = SDIO_SPEED_DDR50;\n\t\t\ttiming = MMC_TIMING_UHS_DDR50;\n\t\t\tcard->sw_caps.uhs_max_dtr = UHS_DDR50_MAX_DTR;\n\t\t\tcard->sd_bus_speed = UHS_DDR50_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50)) && (card->sw_caps.sd3_bus_mode &\n\t\t    SD_MODE_UHS_SDR50)) {\n\t\t\tbus_speed = SDIO_SPEED_SDR50;\n\t\t\ttiming = MMC_TIMING_UHS_SDR50;\n\t\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR50_MAX_DTR;\n\t\t\tcard->sd_bus_speed = UHS_SDR50_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25)) &&\n\t\t   (card->sw_caps.sd3_bus_mode & SD_MODE_UHS_SDR25)) {\n\t\t\tbus_speed = SDIO_SPEED_SDR25;\n\t\t\ttiming = MMC_TIMING_UHS_SDR25;\n\t\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR25_MAX_DTR;\n\t\t\tcard->sd_bus_speed = UHS_SDR25_BUS_SPEED;\n\t} else if ((card->host->caps & (MMC_CAP_UHS_SDR104 |\n\t\t    MMC_CAP_UHS_SDR50 | MMC_CAP_UHS_SDR25 |\n\t\t    MMC_CAP_UHS_SDR12)) && (card->sw_caps.sd3_bus_mode &\n\t\t    SD_MODE_UHS_SDR12)) {\n\t\t\tbus_speed = SDIO_SPEED_SDR12;\n\t\t\ttiming = MMC_TIMING_UHS_SDR12;\n\t\t\tcard->sw_caps.uhs_max_dtr = UHS_SDR12_MAX_DTR;\n\t\t\tcard->sd_bus_speed = UHS_SDR12_BUS_SPEED;\n\t}\n\n\terr = mmc_io_rw_direct(card, 0, 0, SDIO_CCCR_SPEED, 0, &speed);\n\tif (err)\n\t\treturn err;\n\n\tspeed &= ~SDIO_SPEED_BSS_MASK;\n\tspeed |= bus_speed;\n\terr = mmc_io_rw_direct(card, 1, 0, SDIO_CCCR_SPEED, speed, NULL);\n\tif (err)\n\t\treturn err;\n\n\tmax_rate = min_not_zero(card->quirk_max_rate,\n\t\t\t\tcard->sw_caps.uhs_max_dtr);\n\n\tmmc_set_timing(card->host, timing);\n\tmmc_set_clock(card->host, max_rate);\n\n\treturn 0;\n}\n\n \nstatic int mmc_sdio_init_uhs_card(struct mmc_card *card)\n{\n\tint err;\n\n\tif (!card->scr.sda_spec3)\n\t\treturn 0;\n\n\t \n\terr = sdio_enable_4bit_bus(card);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tsdio_select_driver_type(card);\n\n\t \n\terr = sdio_set_bus_speed_mode(card);\n\tif (err)\n\t\tgoto out;\n\n\t \n\tif (!mmc_host_is_spi(card->host) &&\n\t    ((card->host->ios.timing == MMC_TIMING_UHS_SDR50) ||\n\t      (card->host->ios.timing == MMC_TIMING_UHS_SDR104)))\n\t\terr = mmc_execute_tuning(card);\nout:\n\treturn err;\n}\n\nstatic int mmc_sdio_pre_init(struct mmc_host *host, u32 ocr,\n\t\t\t     struct mmc_card *card)\n{\n\tif (card)\n\t\tmmc_remove_card(card);\n\n\t \n\n\tsdio_reset(host);\n\tmmc_go_idle(host);\n\tmmc_send_if_cond(host, ocr);\n\treturn mmc_send_io_op_cond(host, 0, NULL);\n}\n\n \nstatic int mmc_sdio_init_card(struct mmc_host *host, u32 ocr,\n\t\t\t      struct mmc_card *oldcard)\n{\n\tstruct mmc_card *card;\n\tint err;\n\tint retries = 10;\n\tu32 rocr = 0;\n\tu32 ocr_card = ocr;\n\n\tWARN_ON(!host->claimed);\n\n\t \n\tif (mmc_host_uhs(host))\n\t\tocr |= R4_18V_PRESENT;\n\ntry_again:\n\tif (!retries) {\n\t\tpr_warn(\"%s: Skipping voltage switch\\n\", mmc_hostname(host));\n\t\tocr &= ~R4_18V_PRESENT;\n\t}\n\n\t \n\terr = mmc_send_io_op_cond(host, ocr, &rocr);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (mmc_host_is_spi(host)) {\n\t\terr = mmc_spi_set_crc(host, use_spi_crc);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t \n\tcard = mmc_alloc_card(host, &sdio_type);\n\tif (IS_ERR(card))\n\t\treturn PTR_ERR(card);\n\n\tif ((rocr & R4_MEMORY_PRESENT) &&\n\t    mmc_sd_get_cid(host, ocr & rocr, card->raw_cid, NULL) == 0) {\n\t\tcard->type = MMC_TYPE_SD_COMBO;\n\n\t\tif (oldcard && (!mmc_card_sd_combo(oldcard) ||\n\t\t    memcmp(card->raw_cid, oldcard->raw_cid, sizeof(card->raw_cid)) != 0)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto mismatch;\n\t\t}\n\t} else {\n\t\tcard->type = MMC_TYPE_SDIO;\n\n\t\tif (oldcard && !mmc_card_sdio(oldcard)) {\n\t\t\terr = -ENOENT;\n\t\t\tgoto mismatch;\n\t\t}\n\t}\n\n\t \n\tif (host->ops->init_card)\n\t\thost->ops->init_card(host, card);\n\tmmc_fixup_device(card, sdio_card_init_methods);\n\n\tcard->ocr = ocr_card;\n\n\t \n\tif (rocr & ocr & R4_18V_PRESENT) {\n\t\terr = mmc_set_uhs_voltage(host, ocr_card);\n\t\tif (err == -EAGAIN) {\n\t\t\tmmc_sdio_pre_init(host, ocr_card, card);\n\t\t\tretries--;\n\t\t\tgoto try_again;\n\t\t} else if (err) {\n\t\t\tocr &= ~R4_18V_PRESENT;\n\t\t}\n\t}\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_send_relative_addr(host, &card->rca);\n\t\tif (err)\n\t\t\tgoto remove;\n\n\t\t \n\t\tif (oldcard)\n\t\t\toldcard->rca = card->rca;\n\t}\n\n\t \n\tif (!oldcard && mmc_card_sd_combo(card)) {\n\t\terr = mmc_sd_get_csd(card);\n\t\tif (err)\n\t\t\tgoto remove;\n\n\t\tmmc_decode_cid(card);\n\t}\n\n\t \n\tif (!mmc_host_is_spi(host)) {\n\t\terr = mmc_select_card(card);\n\t\tif (err)\n\t\t\tgoto remove;\n\t}\n\n\tif (card->quirks & MMC_QUIRK_NONSTD_SDIO) {\n\t\t \n\t\tmmc_set_clock(host, card->cis.max_dtr);\n\n\t\tif (card->cccr.high_speed) {\n\t\t\tmmc_set_timing(card->host, MMC_TIMING_SD_HS);\n\t\t}\n\n\t\tif (oldcard)\n\t\t\tmmc_remove_card(card);\n\t\telse\n\t\t\thost->card = card;\n\n\t\treturn 0;\n\t}\n\n\t \n\terr = sdio_read_cccr(card, ocr);\n\tif (err) {\n\t\tmmc_sdio_pre_init(host, ocr_card, card);\n\t\tif (ocr & R4_18V_PRESENT) {\n\t\t\t \n\t\t\tretries = 0;\n\t\t\tgoto try_again;\n\t\t}\n\t\treturn err;\n\t}\n\n\t \n\terr = sdio_read_common_cis(card);\n\tif (err)\n\t\tgoto remove;\n\n\tif (oldcard) {\n\t\tif (card->cis.vendor == oldcard->cis.vendor &&\n\t\t    card->cis.device == oldcard->cis.device) {\n\t\t\tmmc_remove_card(card);\n\t\t\tcard = oldcard;\n\t\t} else {\n\t\t\terr = -ENOENT;\n\t\t\tgoto mismatch;\n\t\t}\n\t}\n\n\tmmc_fixup_device(card, sdio_fixup_methods);\n\n\tif (mmc_card_sd_combo(card)) {\n\t\terr = mmc_sd_setup_card(host, card, oldcard != NULL);\n\t\t \n\t\tif (err) {\n\t\t\tmmc_go_idle(host);\n\t\t\tif (mmc_host_is_spi(host))\n\t\t\t\t \n\t\t\t\tmmc_spi_set_crc(host, use_spi_crc);\n\t\t\tcard->type = MMC_TYPE_SDIO;\n\t\t} else\n\t\t\tcard->dev.type = &sd_type;\n\t}\n\n\t \n\terr = sdio_disable_cd(card);\n\tif (err)\n\t\tgoto remove;\n\n\t \n\t \n\tif ((ocr & R4_18V_PRESENT) && card->sw_caps.sd3_bus_mode) {\n\t\terr = mmc_sdio_init_uhs_card(card);\n\t\tif (err)\n\t\t\tgoto remove;\n\t} else {\n\t\t \n\t\terr = sdio_enable_hs(card);\n\t\tif (err > 0)\n\t\t\tmmc_set_timing(card->host, MMC_TIMING_SD_HS);\n\t\telse if (err)\n\t\t\tgoto remove;\n\n\t\t \n\t\tmmc_set_clock(host, mmc_sdio_get_max_clock(card));\n\n\t\t \n\t\terr = sdio_enable_4bit_bus(card);\n\t\tif (err)\n\t\t\tgoto remove;\n\t}\n\n\tif (host->caps2 & MMC_CAP2_AVOID_3_3V &&\n\t    host->ios.signal_voltage == MMC_SIGNAL_VOLTAGE_330) {\n\t\tpr_err(\"%s: Host failed to negotiate down from 3.3V\\n\",\n\t\t\tmmc_hostname(host));\n\t\terr = -EINVAL;\n\t\tgoto remove;\n\t}\n\n\thost->card = card;\n\treturn 0;\n\nmismatch:\n\tpr_debug(\"%s: Perhaps the card was replaced\\n\", mmc_hostname(host));\nremove:\n\tif (oldcard != card)\n\t\tmmc_remove_card(card);\n\treturn err;\n}\n\nstatic int mmc_sdio_reinit_card(struct mmc_host *host)\n{\n\tint ret;\n\n\tret = mmc_sdio_pre_init(host, host->card->ocr, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn mmc_sdio_init_card(host, host->card->ocr, host->card);\n}\n\n \nstatic void mmc_sdio_remove(struct mmc_host *host)\n{\n\tint i;\n\n\tfor (i = 0;i < host->card->sdio_funcs;i++) {\n\t\tif (host->card->sdio_func[i]) {\n\t\t\tsdio_remove_func(host->card->sdio_func[i]);\n\t\t\thost->card->sdio_func[i] = NULL;\n\t\t}\n\t}\n\n\tmmc_remove_card(host->card);\n\thost->card = NULL;\n}\n\n \nstatic int mmc_sdio_alive(struct mmc_host *host)\n{\n\treturn mmc_select_card(host->card);\n}\n\n \nstatic void mmc_sdio_detect(struct mmc_host *host)\n{\n\tint err;\n\n\t \n\tif (host->caps & MMC_CAP_POWER_OFF_CARD) {\n\t\terr = pm_runtime_resume_and_get(&host->card->dev);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tmmc_claim_host(host);\n\n\t \n\terr = _mmc_detect_card_removed(host);\n\n\tmmc_release_host(host);\n\n\t \n\tif (host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_put_sync(&host->card->dev);\n\nout:\n\tif (err) {\n\t\tmmc_sdio_remove(host);\n\n\t\tmmc_claim_host(host);\n\t\tmmc_detach_bus(host);\n\t\tmmc_power_off(host);\n\t\tmmc_release_host(host);\n\t}\n}\n\n \nstatic int mmc_sdio_pre_suspend(struct mmc_host *host)\n{\n\tint i;\n\n\tfor (i = 0; i < host->card->sdio_funcs; i++) {\n\t\tstruct sdio_func *func = host->card->sdio_func[i];\n\t\tif (func && sdio_func_present(func) && func->dev.driver) {\n\t\t\tconst struct dev_pm_ops *pmops = func->dev.driver->pm;\n\t\t\tif (!pmops || !pmops->suspend || !pmops->resume)\n\t\t\t\t \n\t\t\t\tgoto remove;\n\t\t}\n\t}\n\n\treturn 0;\n\nremove:\n\tif (!mmc_card_is_removable(host)) {\n\t\tdev_warn(mmc_dev(host),\n\t\t\t \"missing suspend/resume ops for non-removable SDIO card\\n\");\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\tmmc_sdio_remove(host);\n\tmmc_claim_host(host);\n\tmmc_detach_bus(host);\n\tmmc_power_off(host);\n\tmmc_release_host(host);\n\thost->pm_flags = 0;\n\n\treturn 0;\n}\n\n \nstatic int mmc_sdio_suspend(struct mmc_host *host)\n{\n\tWARN_ON(host->sdio_irqs && !mmc_card_keep_power(host));\n\n\t \n\tmmc_card_set_suspended(host->card);\n\tcancel_work_sync(&host->sdio_irq_work);\n\n\tmmc_claim_host(host);\n\n\tif (mmc_card_keep_power(host) && mmc_card_wake_sdio_irq(host))\n\t\tsdio_disable_4bit_bus(host->card);\n\n\tif (!mmc_card_keep_power(host)) {\n\t\tmmc_power_off(host);\n\t} else if (host->retune_period) {\n\t\tmmc_retune_timer_stop(host);\n\t\tmmc_retune_needed(host);\n\t}\n\n\tmmc_release_host(host);\n\n\treturn 0;\n}\n\nstatic int mmc_sdio_resume(struct mmc_host *host)\n{\n\tint err = 0;\n\n\t \n\tmmc_claim_host(host);\n\n\t \n\tif (!mmc_card_keep_power(host)) {\n\t\tmmc_power_up(host, host->card->ocr);\n\t\t \n\t\tif (host->caps & MMC_CAP_POWER_OFF_CARD) {\n\t\t\tpm_runtime_disable(&host->card->dev);\n\t\t\tpm_runtime_set_active(&host->card->dev);\n\t\t\tpm_runtime_enable(&host->card->dev);\n\t\t}\n\t\terr = mmc_sdio_reinit_card(host);\n\t} else if (mmc_card_wake_sdio_irq(host)) {\n\t\t \n\t\tmmc_retune_hold_now(host);\n\t\terr = sdio_enable_4bit_bus(host->card);\n\t\tmmc_retune_release(host);\n\t}\n\n\tif (err)\n\t\tgoto out;\n\n\t \n\tmmc_card_clr_suspended(host->card);\n\n\tif (host->sdio_irqs) {\n\t\tif (!(host->caps2 & MMC_CAP2_SDIO_IRQ_NOTHREAD))\n\t\t\twake_up_process(host->sdio_irq_thread);\n\t\telse if (host->caps & MMC_CAP_SDIO_IRQ)\n\t\t\tschedule_work(&host->sdio_irq_work);\n\t}\n\nout:\n\tmmc_release_host(host);\n\n\thost->pm_flags &= ~MMC_PM_KEEP_POWER;\n\treturn err;\n}\n\nstatic int mmc_sdio_runtime_suspend(struct mmc_host *host)\n{\n\t \n\tmmc_claim_host(host);\n\tmmc_power_off(host);\n\tmmc_release_host(host);\n\n\treturn 0;\n}\n\nstatic int mmc_sdio_runtime_resume(struct mmc_host *host)\n{\n\tint ret;\n\n\t \n\tmmc_claim_host(host);\n\tmmc_power_up(host, host->card->ocr);\n\tret = mmc_sdio_reinit_card(host);\n\tmmc_release_host(host);\n\n\treturn ret;\n}\n\n \nstatic int mmc_sdio_hw_reset(struct mmc_host *host)\n{\n\tstruct mmc_card *card = host->card;\n\n\t \n\tif (atomic_read(&card->sdio_funcs_probed) > 1) {\n\t\tif (mmc_card_removed(card))\n\t\t\treturn 1;\n\t\thost->rescan_entered = 0;\n\t\tmmc_card_set_removed(card);\n\t\t_mmc_detect_change(host, 0, false);\n\t\treturn 1;\n\t}\n\n\t \n\tmmc_power_cycle(host, card->ocr);\n\treturn mmc_sdio_reinit_card(host);\n}\n\nstatic int mmc_sdio_sw_reset(struct mmc_host *host)\n{\n\tmmc_set_clock(host, host->f_init);\n\tsdio_reset(host);\n\tmmc_go_idle(host);\n\n\tmmc_set_initial_state(host);\n\tmmc_set_initial_signal_voltage(host);\n\n\treturn mmc_sdio_reinit_card(host);\n}\n\nstatic const struct mmc_bus_ops mmc_sdio_ops = {\n\t.remove = mmc_sdio_remove,\n\t.detect = mmc_sdio_detect,\n\t.pre_suspend = mmc_sdio_pre_suspend,\n\t.suspend = mmc_sdio_suspend,\n\t.resume = mmc_sdio_resume,\n\t.runtime_suspend = mmc_sdio_runtime_suspend,\n\t.runtime_resume = mmc_sdio_runtime_resume,\n\t.alive = mmc_sdio_alive,\n\t.hw_reset = mmc_sdio_hw_reset,\n\t.sw_reset = mmc_sdio_sw_reset,\n};\n\n\n \nint mmc_attach_sdio(struct mmc_host *host)\n{\n\tint err, i, funcs;\n\tu32 ocr, rocr;\n\tstruct mmc_card *card;\n\n\tWARN_ON(!host->claimed);\n\n\terr = mmc_send_io_op_cond(host, 0, &ocr);\n\tif (err)\n\t\treturn err;\n\n\tmmc_attach_bus(host, &mmc_sdio_ops);\n\tif (host->ocr_avail_sdio)\n\t\thost->ocr_avail = host->ocr_avail_sdio;\n\n\n\trocr = mmc_select_voltage(host, ocr);\n\n\t \n\tif (!rocr) {\n\t\terr = -EINVAL;\n\t\tgoto err;\n\t}\n\n\t \n\terr = mmc_sdio_init_card(host, rocr, NULL);\n\tif (err)\n\t\tgoto err;\n\n\tcard = host->card;\n\n\t \n\tif (host->caps & MMC_CAP_POWER_OFF_CARD) {\n\t\t \n\t\tpm_runtime_get_noresume(&card->dev);\n\n\t\t \n\t\terr = pm_runtime_set_active(&card->dev);\n\t\tif (err)\n\t\t\tgoto remove;\n\n\t\t \n\t\tpm_runtime_enable(&card->dev);\n\t}\n\n\t \n\tfuncs = (ocr & 0x70000000) >> 28;\n\tcard->sdio_funcs = 0;\n\n\t \n\tfor (i = 0; i < funcs; i++, card->sdio_funcs++) {\n\t\terr = sdio_init_func(host->card, i + 1);\n\t\tif (err)\n\t\t\tgoto remove;\n\n\t\t \n\t\tif (host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\t\tpm_runtime_enable(&card->sdio_func[i]->dev);\n\t}\n\n\t \n\tmmc_release_host(host);\n\terr = mmc_add_card(host->card);\n\tif (err)\n\t\tgoto remove_added;\n\n\t \n\tfor (i = 0;i < funcs;i++) {\n\t\terr = sdio_add_func(host->card->sdio_func[i]);\n\t\tif (err)\n\t\t\tgoto remove_added;\n\t}\n\n\tif (host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_put(&card->dev);\n\n\tmmc_claim_host(host);\n\treturn 0;\n\n\nremove:\n\tmmc_release_host(host);\nremove_added:\n\t \n\tmmc_sdio_remove(host);\n\tmmc_claim_host(host);\nerr:\n\tmmc_detach_bus(host);\n\n\tpr_err(\"%s: error %d whilst initialising SDIO card\\n\",\n\t\tmmc_hostname(host), err);\n\n\treturn err;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}