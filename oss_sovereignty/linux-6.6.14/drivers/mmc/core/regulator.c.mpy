{
  "module_name": "regulator.c",
  "hash_id": "db4e9ada1e7fd253c910f5c845e2e63d6115e222764cfa5bfba67f7363080af2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/regulator.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/log2.h>\n#include <linux/regulator/consumer.h>\n\n#include <linux/mmc/host.h>\n\n#include \"core.h\"\n#include \"host.h\"\n\n#ifdef CONFIG_REGULATOR\n\n \nstatic int mmc_ocrbitnum_to_vdd(int vdd_bit, int *min_uV, int *max_uV)\n{\n\tint\t\ttmp;\n\n\tif (!vdd_bit)\n\t\treturn -EINVAL;\n\n\t \n\ttmp = vdd_bit - ilog2(MMC_VDD_165_195);\n\tif (tmp == 0) {\n\t\t*min_uV = 1650 * 1000;\n\t\t*max_uV = 1950 * 1000;\n\t} else {\n\t\t*min_uV = 1900 * 1000 + tmp * 100 * 1000;\n\t\t*max_uV = *min_uV + 100 * 1000;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mmc_regulator_get_ocrmask(struct regulator *supply)\n{\n\tint\t\t\tresult = 0;\n\tint\t\t\tcount;\n\tint\t\t\ti;\n\tint\t\t\tvdd_uV;\n\tint\t\t\tvdd_mV;\n\n\tcount = regulator_count_voltages(supply);\n\tif (count < 0)\n\t\treturn count;\n\n\tfor (i = 0; i < count; i++) {\n\t\tvdd_uV = regulator_list_voltage(supply, i);\n\t\tif (vdd_uV <= 0)\n\t\t\tcontinue;\n\n\t\tvdd_mV = vdd_uV / 1000;\n\t\tresult |= mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);\n\t}\n\n\tif (!result) {\n\t\tvdd_uV = regulator_get_voltage(supply);\n\t\tif (vdd_uV <= 0)\n\t\t\treturn vdd_uV;\n\n\t\tvdd_mV = vdd_uV / 1000;\n\t\tresult = mmc_vddrange_to_ocrmask(vdd_mV, vdd_mV);\n\t}\n\n\treturn result;\n}\n\n \nint mmc_regulator_set_ocr(struct mmc_host *mmc,\n\t\t\tstruct regulator *supply,\n\t\t\tunsigned short vdd_bit)\n{\n\tint\t\t\tresult = 0;\n\tint\t\t\tmin_uV, max_uV;\n\n\tif (IS_ERR(supply))\n\t\treturn 0;\n\n\tif (vdd_bit) {\n\t\tmmc_ocrbitnum_to_vdd(vdd_bit, &min_uV, &max_uV);\n\n\t\tresult = regulator_set_voltage(supply, min_uV, max_uV);\n\t\tif (result == 0 && !mmc->regulator_enabled) {\n\t\t\tresult = regulator_enable(supply);\n\t\t\tif (!result)\n\t\t\t\tmmc->regulator_enabled = true;\n\t\t}\n\t} else if (mmc->regulator_enabled) {\n\t\tresult = regulator_disable(supply);\n\t\tif (result == 0)\n\t\t\tmmc->regulator_enabled = false;\n\t}\n\n\tif (result)\n\t\tdev_err(mmc_dev(mmc),\n\t\t\t\"could not set regulator OCR (%d)\\n\", result);\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(mmc_regulator_set_ocr);\n\nstatic int mmc_regulator_set_voltage_if_supported(struct regulator *regulator,\n\t\t\t\t\t\t  int min_uV, int target_uV,\n\t\t\t\t\t\t  int max_uV)\n{\n\tint current_uV;\n\n\t \n\tif (!regulator_is_supported_voltage(regulator, min_uV, max_uV))\n\t\treturn -EINVAL;\n\n\t \n\tcurrent_uV = regulator_get_voltage(regulator);\n\tif (current_uV == target_uV)\n\t\treturn 1;\n\n\treturn regulator_set_voltage_triplet(regulator, min_uV, target_uV,\n\t\t\t\t\t     max_uV);\n}\n\n \nint mmc_regulator_set_vqmmc(struct mmc_host *mmc, struct mmc_ios *ios)\n{\n\tstruct device *dev = mmc_dev(mmc);\n\tint ret, volt, min_uV, max_uV;\n\n\t \n\tif (IS_ERR(mmc->supply.vqmmc))\n\t\treturn -EINVAL;\n\n\tswitch (ios->signal_voltage) {\n\tcase MMC_SIGNAL_VOLTAGE_120:\n\t\treturn mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,\n\t\t\t\t\t\t1100000, 1200000, 1300000);\n\tcase MMC_SIGNAL_VOLTAGE_180:\n\t\treturn mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,\n\t\t\t\t\t\t1700000, 1800000, 1950000);\n\tcase MMC_SIGNAL_VOLTAGE_330:\n\t\tret = mmc_ocrbitnum_to_vdd(mmc->ios.vdd, &volt, &max_uV);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdev_dbg(dev, \"%s: found vmmc voltage range of %d-%duV\\n\",\n\t\t\t__func__, volt, max_uV);\n\n\t\tmin_uV = max(volt - 300000, 2700000);\n\t\tmax_uV = min(max_uV + 200000, 3600000);\n\n\t\t \n\t\tret = mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,\n\t\t\t\t\t\t\tmin_uV, volt, max_uV);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\n\t\treturn mmc_regulator_set_voltage_if_supported(mmc->supply.vqmmc,\n\t\t\t\t\t\t2700000, volt, 3600000);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\nEXPORT_SYMBOL_GPL(mmc_regulator_set_vqmmc);\n\n#else\n\nstatic inline int mmc_regulator_get_ocrmask(struct regulator *supply)\n{\n\treturn 0;\n}\n\n#endif  \n\n \nint mmc_regulator_get_supply(struct mmc_host *mmc)\n{\n\tstruct device *dev = mmc_dev(mmc);\n\tint ret;\n\n\tmmc->supply.vmmc = devm_regulator_get_optional(dev, \"vmmc\");\n\tmmc->supply.vqmmc = devm_regulator_get_optional(dev, \"vqmmc\");\n\n\tif (IS_ERR(mmc->supply.vmmc)) {\n\t\tif (PTR_ERR(mmc->supply.vmmc) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(dev, \"No vmmc regulator found\\n\");\n\t} else {\n\t\tret = mmc_regulator_get_ocrmask(mmc->supply.vmmc);\n\t\tif (ret > 0)\n\t\t\tmmc->ocr_avail = ret;\n\t\telse\n\t\t\tdev_warn(dev, \"Failed getting OCR mask: %d\\n\", ret);\n\t}\n\n\tif (IS_ERR(mmc->supply.vqmmc)) {\n\t\tif (PTR_ERR(mmc->supply.vqmmc) == -EPROBE_DEFER)\n\t\t\treturn -EPROBE_DEFER;\n\t\tdev_dbg(dev, \"No vqmmc regulator found\\n\");\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmc_regulator_get_supply);\n\n \nint mmc_regulator_enable_vqmmc(struct mmc_host *mmc)\n{\n\tint ret = 0;\n\n\tif (!IS_ERR(mmc->supply.vqmmc) && !mmc->vqmmc_enabled) {\n\t\tret = regulator_enable(mmc->supply.vqmmc);\n\t\tif (ret < 0)\n\t\t\tdev_err(mmc_dev(mmc), \"enabling vqmmc regulator failed\\n\");\n\t\telse\n\t\t\tmmc->vqmmc_enabled = true;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(mmc_regulator_enable_vqmmc);\n\n \nvoid mmc_regulator_disable_vqmmc(struct mmc_host *mmc)\n{\n\tif (!IS_ERR(mmc->supply.vqmmc) && mmc->vqmmc_enabled) {\n\t\tregulator_disable(mmc->supply.vqmmc);\n\t\tmmc->vqmmc_enabled = false;\n\t}\n}\nEXPORT_SYMBOL_GPL(mmc_regulator_disable_vqmmc);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}