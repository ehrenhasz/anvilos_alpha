{
  "module_name": "slot-gpio.c",
  "hash_id": "818ef5d06c9341125d4c32d7d2504646a81b9aefd70939dcbe42c99dc0b940ef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/slot-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/slot-gpio.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"slot-gpio.h\"\n\nstruct mmc_gpio {\n\tstruct gpio_desc *ro_gpio;\n\tstruct gpio_desc *cd_gpio;\n\tirqreturn_t (*cd_gpio_isr)(int irq, void *dev_id);\n\tchar *ro_label;\n\tchar *cd_label;\n\tu32 cd_debounce_delay_ms;\n\tint cd_irq;\n};\n\nstatic irqreturn_t mmc_gpio_cd_irqt(int irq, void *dev_id)\n{\n\t \n\tstruct mmc_host *host = dev_id;\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\thost->trigger_card_event = true;\n\tmmc_detect_change(host, msecs_to_jiffies(ctx->cd_debounce_delay_ms));\n\n\treturn IRQ_HANDLED;\n}\n\nint mmc_gpio_alloc(struct mmc_host *host)\n{\n\tconst char *devname = dev_name(host->parent);\n\tstruct mmc_gpio *ctx;\n\n\tctx = devm_kzalloc(host->parent, sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->cd_debounce_delay_ms = 200;\n\tctx->cd_label = devm_kasprintf(host->parent, GFP_KERNEL, \"%s cd\", devname);\n\tif (!ctx->cd_label)\n\t\treturn -ENOMEM;\n\tctx->ro_label = devm_kasprintf(host->parent, GFP_KERNEL, \"%s ro\", devname);\n\tif (!ctx->ro_label)\n\t\treturn -ENOMEM;\n\tctx->cd_irq = -EINVAL;\n\thost->slot.handler_priv = ctx;\n\thost->slot.cd_irq = -EINVAL;\n\n\treturn 0;\n}\n\nvoid mmc_gpio_set_cd_irq(struct mmc_host *host, int irq)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\tif (!ctx || irq < 0)\n\t\treturn;\n\n\tctx->cd_irq = irq;\n}\nEXPORT_SYMBOL(mmc_gpio_set_cd_irq);\n\nint mmc_gpio_get_ro(struct mmc_host *host)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\tif (!ctx || !ctx->ro_gpio)\n\t\treturn -ENOSYS;\n\n\treturn gpiod_get_value_cansleep(ctx->ro_gpio);\n}\nEXPORT_SYMBOL(mmc_gpio_get_ro);\n\nint mmc_gpio_get_cd(struct mmc_host *host)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\tint cansleep;\n\n\tif (!ctx || !ctx->cd_gpio)\n\t\treturn -ENOSYS;\n\n\tcansleep = gpiod_cansleep(ctx->cd_gpio);\n\treturn cansleep ?\n\t\tgpiod_get_value_cansleep(ctx->cd_gpio) :\n\t\tgpiod_get_value(ctx->cd_gpio);\n}\nEXPORT_SYMBOL(mmc_gpio_get_cd);\n\nvoid mmc_gpiod_request_cd_irq(struct mmc_host *host)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\tint irq = -EINVAL;\n\tint ret;\n\n\tif (host->slot.cd_irq >= 0 || !ctx || !ctx->cd_gpio)\n\t\treturn;\n\n\t \n\tif (ctx->cd_irq >= 0)\n\t\tirq = ctx->cd_irq;\n\telse if (!(host->caps & MMC_CAP_NEEDS_POLL))\n\t\tirq = gpiod_to_irq(ctx->cd_gpio);\n\n\tif (irq >= 0) {\n\t\tif (!ctx->cd_gpio_isr)\n\t\t\tctx->cd_gpio_isr = mmc_gpio_cd_irqt;\n\t\tret = devm_request_threaded_irq(host->parent, irq,\n\t\t\tNULL, ctx->cd_gpio_isr,\n\t\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\tctx->cd_label, host);\n\t\tif (ret < 0)\n\t\t\tirq = ret;\n\t}\n\n\thost->slot.cd_irq = irq;\n\n\tif (irq < 0)\n\t\thost->caps |= MMC_CAP_NEEDS_POLL;\n}\nEXPORT_SYMBOL(mmc_gpiod_request_cd_irq);\n\nint mmc_gpio_set_cd_wake(struct mmc_host *host, bool on)\n{\n\tint ret = 0;\n\n\tif (!(host->caps & MMC_CAP_CD_WAKE) ||\n\t    host->slot.cd_irq < 0 ||\n\t    on == host->slot.cd_wake_enabled)\n\t\treturn 0;\n\n\tif (on) {\n\t\tret = enable_irq_wake(host->slot.cd_irq);\n\t\thost->slot.cd_wake_enabled = !ret;\n\t} else {\n\t\tdisable_irq_wake(host->slot.cd_irq);\n\t\thost->slot.cd_wake_enabled = false;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(mmc_gpio_set_cd_wake);\n\n \nvoid mmc_gpio_set_cd_isr(struct mmc_host *host,\n\t\t\t irqreturn_t (*isr)(int irq, void *dev_id))\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\tWARN_ON(ctx->cd_gpio_isr);\n\tctx->cd_gpio_isr = isr;\n}\nEXPORT_SYMBOL(mmc_gpio_set_cd_isr);\n\n \nint mmc_gpiod_request_cd(struct mmc_host *host, const char *con_id,\n\t\t\t unsigned int idx, bool override_active_level,\n\t\t\t unsigned int debounce)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\tstruct gpio_desc *desc;\n\tint ret;\n\n\tdesc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t \n\tif (!con_id)\n\t\tgpiod_set_consumer_name(desc, ctx->cd_label);\n\n\tif (debounce) {\n\t\tret = gpiod_set_debounce(desc, debounce);\n\t\tif (ret < 0)\n\t\t\tctx->cd_debounce_delay_ms = debounce / 1000;\n\t}\n\n\t \n\tif (override_active_level && !gpiod_is_active_low(desc))\n\t\tgpiod_toggle_active_low(desc);\n\n\t \n\tif (host->caps2 & MMC_CAP2_CD_ACTIVE_HIGH)\n\t\tgpiod_toggle_active_low(desc);\n\n\tctx->cd_gpio = desc;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_gpiod_request_cd);\n\nbool mmc_can_gpio_cd(struct mmc_host *host)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\treturn ctx->cd_gpio ? true : false;\n}\nEXPORT_SYMBOL(mmc_can_gpio_cd);\n\n \nint mmc_gpiod_request_ro(struct mmc_host *host, const char *con_id,\n\t\t\t unsigned int idx, unsigned int debounce)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\tstruct gpio_desc *desc;\n\tint ret;\n\n\tdesc = devm_gpiod_get_index(host->parent, con_id, idx, GPIOD_IN);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\t \n\tif (!con_id)\n\t\tgpiod_set_consumer_name(desc, ctx->ro_label);\n\n\tif (debounce) {\n\t\tret = gpiod_set_debounce(desc, debounce);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (host->caps2 & MMC_CAP2_RO_ACTIVE_HIGH)\n\t\tgpiod_toggle_active_low(desc);\n\n\tctx->ro_gpio = desc;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(mmc_gpiod_request_ro);\n\nbool mmc_can_gpio_ro(struct mmc_host *host)\n{\n\tstruct mmc_gpio *ctx = host->slot.handler_priv;\n\n\treturn ctx->ro_gpio ? true : false;\n}\nEXPORT_SYMBOL(mmc_can_gpio_ro);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}