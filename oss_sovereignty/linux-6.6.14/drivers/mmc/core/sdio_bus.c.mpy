{
  "module_name": "sdio_bus.c",
  "hash_id": "facc10901899638d8997345068eabb65ab0bf2fdc696e5b6e1ceeb2b01d8f189",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sdio_bus.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/err.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_domain.h>\n#include <linux/acpi.h>\n#include <linux/sysfs.h>\n\n#include <linux/mmc/card.h>\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/of.h>\n\n#include \"core.h\"\n#include \"card.h\"\n#include \"sdio_cis.h\"\n#include \"sdio_bus.h\"\n\n#define to_sdio_driver(d)\tcontainer_of(d, struct sdio_driver, drv)\n\n \n#define sdio_config_attr(field, format_string, args...)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct sdio_func *func;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tfunc = dev_to_sdio_func (dev);\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string, args);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nsdio_config_attr(class, \"0x%02x\\n\", func->class);\nsdio_config_attr(vendor, \"0x%04x\\n\", func->vendor);\nsdio_config_attr(device, \"0x%04x\\n\", func->device);\nsdio_config_attr(revision, \"%u.%u\\n\", func->major_rev, func->minor_rev);\nsdio_config_attr(modalias, \"sdio:c%02Xv%04Xd%04X\\n\", func->class, func->vendor, func->device);\n\n#define sdio_info_attr(num)\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t info##num##_show(struct device *dev, struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tif (num > func->num_info)\t\t\t\t\t\t\t\t\\\n\t\treturn -ENODATA;\t\t\t\t\t\t\t\t\\\n\tif (!func->info[num - 1][0])\t\t\t\t\t\t\t\t\\\n\t\treturn 0;\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, \"%s\\n\", func->info[num - 1]);\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(info##num)\n\nsdio_info_attr(1);\nsdio_info_attr(2);\nsdio_info_attr(3);\nsdio_info_attr(4);\n\nstatic struct attribute *sdio_dev_attrs[] = {\n\t&dev_attr_class.attr,\n\t&dev_attr_vendor.attr,\n\t&dev_attr_device.attr,\n\t&dev_attr_revision.attr,\n\t&dev_attr_info1.attr,\n\t&dev_attr_info2.attr,\n\t&dev_attr_info3.attr,\n\t&dev_attr_info4.attr,\n\t&dev_attr_modalias.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(sdio_dev);\n\nstatic const struct sdio_device_id *sdio_match_one(struct sdio_func *func,\n\tconst struct sdio_device_id *id)\n{\n\tif (id->class != (__u8)SDIO_ANY_ID && id->class != func->class)\n\t\treturn NULL;\n\tif (id->vendor != (__u16)SDIO_ANY_ID && id->vendor != func->vendor)\n\t\treturn NULL;\n\tif (id->device != (__u16)SDIO_ANY_ID && id->device != func->device)\n\t\treturn NULL;\n\treturn id;\n}\n\nstatic const struct sdio_device_id *sdio_match_device(struct sdio_func *func,\n\tstruct sdio_driver *sdrv)\n{\n\tconst struct sdio_device_id *ids;\n\n\tids = sdrv->id_table;\n\n\tif (ids) {\n\t\twhile (ids->class || ids->vendor || ids->device) {\n\t\t\tif (sdio_match_one(func, ids))\n\t\t\t\treturn ids;\n\t\t\tids++;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic int sdio_bus_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct sdio_driver *sdrv = to_sdio_driver(drv);\n\n\tif (sdio_match_device(func, sdrv))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int\nsdio_bus_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct sdio_func *func = dev_to_sdio_func(dev);\n\tunsigned int i;\n\n\tif (add_uevent_var(env,\n\t\t\t\"SDIO_CLASS=%02X\", func->class))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \n\t\t\t\"SDIO_ID=%04X:%04X\", func->vendor, func->device))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env,\n\t\t\t\"SDIO_REVISION=%u.%u\", func->major_rev, func->minor_rev))\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < func->num_info; i++) {\n\t\tif (add_uevent_var(env, \"SDIO_INFO%u=%s\", i+1, func->info[i]))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (add_uevent_var(env,\n\t\t\t\"MODALIAS=sdio:c%02Xv%04Xd%04X\",\n\t\t\tfunc->class, func->vendor, func->device))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int sdio_bus_probe(struct device *dev)\n{\n\tstruct sdio_driver *drv = to_sdio_driver(dev->driver);\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tconst struct sdio_device_id *id;\n\tint ret;\n\n\tid = sdio_match_device(func, drv);\n\tif (!id)\n\t\treturn -ENODEV;\n\n\tret = dev_pm_domain_attach(dev, false);\n\tif (ret)\n\t\treturn ret;\n\n\tatomic_inc(&func->card->sdio_funcs_probed);\n\n\t \n\tif (func->card->host->caps & MMC_CAP_POWER_OFF_CARD) {\n\t\tret = pm_runtime_get_sync(dev);\n\t\tif (ret < 0)\n\t\t\tgoto disable_runtimepm;\n\t}\n\n\t \n\tsdio_claim_host(func);\n\tif (mmc_card_removed(func->card))\n\t\tret = -ENOMEDIUM;\n\telse\n\t\tret = sdio_set_block_size(func, 0);\n\tsdio_release_host(func);\n\tif (ret)\n\t\tgoto disable_runtimepm;\n\n\tret = drv->probe(func, id);\n\tif (ret)\n\t\tgoto disable_runtimepm;\n\n\treturn 0;\n\ndisable_runtimepm:\n\tatomic_dec(&func->card->sdio_funcs_probed);\n\tif (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_put_noidle(dev);\n\tdev_pm_domain_detach(dev, false);\n\treturn ret;\n}\n\nstatic void sdio_bus_remove(struct device *dev)\n{\n\tstruct sdio_driver *drv = to_sdio_driver(dev->driver);\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\n\t \n\tif (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_get_sync(dev);\n\n\tdrv->remove(func);\n\tatomic_dec(&func->card->sdio_funcs_probed);\n\n\tif (func->irq_handler) {\n\t\tpr_warn(\"WARNING: driver %s did not remove its interrupt handler!\\n\",\n\t\t\tdrv->name);\n\t\tsdio_claim_host(func);\n\t\tsdio_release_irq(func);\n\t\tsdio_release_host(func);\n\t}\n\n\t \n\tif (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_put_noidle(dev);\n\n\t \n\tif (func->card->host->caps & MMC_CAP_POWER_OFF_CARD)\n\t\tpm_runtime_put_sync(dev);\n\n\tdev_pm_domain_detach(dev, false);\n}\n\nstatic const struct dev_pm_ops sdio_bus_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_generic_suspend, pm_generic_resume)\n\tSET_RUNTIME_PM_OPS(\n\t\tpm_generic_runtime_suspend,\n\t\tpm_generic_runtime_resume,\n\t\tNULL\n\t)\n};\n\nstatic struct bus_type sdio_bus_type = {\n\t.name\t\t= \"sdio\",\n\t.dev_groups\t= sdio_dev_groups,\n\t.match\t\t= sdio_bus_match,\n\t.uevent\t\t= sdio_bus_uevent,\n\t.probe\t\t= sdio_bus_probe,\n\t.remove\t\t= sdio_bus_remove,\n\t.pm\t\t= &sdio_bus_pm_ops,\n};\n\nint sdio_register_bus(void)\n{\n\treturn bus_register(&sdio_bus_type);\n}\n\nvoid sdio_unregister_bus(void)\n{\n\tbus_unregister(&sdio_bus_type);\n}\n\n \nint sdio_register_driver(struct sdio_driver *drv)\n{\n\tdrv->drv.name = drv->name;\n\tdrv->drv.bus = &sdio_bus_type;\n\treturn driver_register(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(sdio_register_driver);\n\n \nvoid sdio_unregister_driver(struct sdio_driver *drv)\n{\n\tdrv->drv.bus = &sdio_bus_type;\n\tdriver_unregister(&drv->drv);\n}\nEXPORT_SYMBOL_GPL(sdio_unregister_driver);\n\nstatic void sdio_release_func(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\n\tif (!(func->card->quirks & MMC_QUIRK_NONSTD_SDIO))\n\t\tsdio_free_func_cis(func);\n\n\t \n\tput_device(&func->card->dev);\n\n\tkfree(func->info);\n\tkfree(func->tmpbuf);\n\tkfree(func);\n}\n\n \nstruct sdio_func *sdio_alloc_func(struct mmc_card *card)\n{\n\tstruct sdio_func *func;\n\n\tfunc = kzalloc(sizeof(struct sdio_func), GFP_KERNEL);\n\tif (!func)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tfunc->tmpbuf = kmalloc(4, GFP_KERNEL);\n\tif (!func->tmpbuf) {\n\t\tkfree(func);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tfunc->card = card;\n\n\tdevice_initialize(&func->dev);\n\n\t \n\tget_device(&func->card->dev);\n\n\tfunc->dev.parent = &card->dev;\n\tfunc->dev.bus = &sdio_bus_type;\n\tfunc->dev.release = sdio_release_func;\n\n\treturn func;\n}\n\n#ifdef CONFIG_ACPI\nstatic void sdio_acpi_set_handle(struct sdio_func *func)\n{\n\tstruct mmc_host *host = func->card->host;\n\tu64 addr = ((u64)host->slotno << 16) | func->num;\n\n\tacpi_preset_companion(&func->dev, ACPI_COMPANION(host->parent), addr);\n}\n#else\nstatic inline void sdio_acpi_set_handle(struct sdio_func *func) {}\n#endif\n\nstatic void sdio_set_of_node(struct sdio_func *func)\n{\n\tstruct mmc_host *host = func->card->host;\n\n\tfunc->dev.of_node = mmc_of_find_child_device(host, func->num);\n}\n\n \nint sdio_add_func(struct sdio_func *func)\n{\n\tint ret;\n\n\tdev_set_name(&func->dev, \"%s:%d\", mmc_card_id(func->card), func->num);\n\n\tsdio_set_of_node(func);\n\tsdio_acpi_set_handle(func);\n\tdevice_enable_async_suspend(&func->dev);\n\tret = device_add(&func->dev);\n\tif (ret == 0)\n\t\tsdio_func_set_present(func);\n\n\treturn ret;\n}\n\n \nvoid sdio_remove_func(struct sdio_func *func)\n{\n\tif (sdio_func_present(func))\n\t\tdevice_del(&func->dev);\n\n\tof_node_put(func->dev.of_node);\n\tput_device(&func->dev);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}