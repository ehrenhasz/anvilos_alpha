{
  "module_name": "sd_ops.c",
  "hash_id": "4a17d11d99fc189463278c483b983682369d986cde60b9e2e28bf2bc54d2c3ab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/mmc/core/sd_ops.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/export.h>\n#include <linux/scatterlist.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/card.h>\n#include <linux/mmc/mmc.h>\n#include <linux/mmc/sd.h>\n\n#include \"core.h\"\n#include \"sd_ops.h\"\n#include \"mmc_ops.h\"\n\nint mmc_app_cmd(struct mmc_host *host, struct mmc_card *card)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\tif (WARN_ON(card && card->host != host))\n\t\treturn -EINVAL;\n\n\tcmd.opcode = MMC_APP_CMD;\n\n\tif (card) {\n\t\tcmd.arg = card->rca << 16;\n\t\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_AC;\n\t} else {\n\t\tcmd.arg = 0;\n\t\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_BCR;\n\t}\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!mmc_host_is_spi(host) && !(cmd.resp[0] & R1_APP_CMD))\n\t\treturn -EOPNOTSUPP;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(mmc_app_cmd);\n\nstatic int mmc_wait_for_app_cmd(struct mmc_host *host, struct mmc_card *card,\n\t\t\t\tstruct mmc_command *cmd)\n{\n\tstruct mmc_request mrq = {};\n\tint i, err = -EIO;\n\n\t \n\tfor (i = 0; i <= MMC_CMD_RETRIES; i++) {\n\t\terr = mmc_app_cmd(host, card);\n\t\tif (err) {\n\t\t\t \n\t\t\tif (mmc_host_is_spi(host)) {\n\t\t\t\tif (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tmemset(&mrq, 0, sizeof(struct mmc_request));\n\n\t\tmemset(cmd->resp, 0, sizeof(cmd->resp));\n\t\tcmd->retries = 0;\n\n\t\tmrq.cmd = cmd;\n\t\tcmd->data = NULL;\n\n\t\tmmc_wait_for_req(host, &mrq);\n\n\t\terr = cmd->error;\n\t\tif (!cmd->error)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mmc_host_is_spi(host)) {\n\t\t\tif (cmd->resp[0] & R1_SPI_ILLEGAL_COMMAND)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn err;\n}\n\nint mmc_app_set_bus_width(struct mmc_card *card, int width)\n{\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = SD_APP_SET_BUS_WIDTH;\n\tcmd.flags = MMC_RSP_R1 | MMC_CMD_AC;\n\n\tswitch (width) {\n\tcase MMC_BUS_WIDTH_1:\n\t\tcmd.arg = SD_BUS_WIDTH_1;\n\t\tbreak;\n\tcase MMC_BUS_WIDTH_4:\n\t\tcmd.arg = SD_BUS_WIDTH_4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn mmc_wait_for_app_cmd(card->host, card, &cmd);\n}\n\nint mmc_send_app_op_cond(struct mmc_host *host, u32 ocr, u32 *rocr)\n{\n\tstruct mmc_command cmd = {};\n\tint i, err = 0;\n\n\tcmd.opcode = SD_APP_OP_COND;\n\tif (mmc_host_is_spi(host))\n\t\tcmd.arg = ocr & (1 << 30);  \n\telse\n\t\tcmd.arg = ocr;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R3 | MMC_CMD_BCR;\n\n\tfor (i = 100; i; i--) {\n\t\terr = mmc_wait_for_app_cmd(host, NULL, &cmd);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tif (ocr == 0)\n\t\t\tbreak;\n\n\t\t \n\t\tif (mmc_host_is_spi(host)) {\n\t\t\tif (!(cmd.resp[0] & R1_SPI_IDLE))\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tif (cmd.resp[0] & MMC_CARD_BUSY)\n\t\t\t\tbreak;\n\t\t}\n\n\t\terr = -ETIMEDOUT;\n\n\t\tmmc_delay(10);\n\t}\n\n\tif (!i)\n\t\tpr_err(\"%s: card never left busy state\\n\", mmc_hostname(host));\n\n\tif (rocr && !mmc_host_is_spi(host))\n\t\t*rocr = cmd.resp[0];\n\n\treturn err;\n}\n\nstatic int __mmc_send_if_cond(struct mmc_host *host, u32 ocr, u8 pcie_bits,\n\t\t\t      u32 *resp)\n{\n\tstruct mmc_command cmd = {};\n\tint err;\n\tstatic const u8 test_pattern = 0xAA;\n\tu8 result_pattern;\n\n\t \n\tcmd.opcode = SD_SEND_IF_COND;\n\tcmd.arg = ((ocr & 0xFF8000) != 0) << 8 | pcie_bits << 8 | test_pattern;\n\tcmd.flags = MMC_RSP_SPI_R7 | MMC_RSP_R7 | MMC_CMD_BCR;\n\n\terr = mmc_wait_for_cmd(host, &cmd, 0);\n\tif (err)\n\t\treturn err;\n\n\tif (mmc_host_is_spi(host))\n\t\tresult_pattern = cmd.resp[1] & 0xFF;\n\telse\n\t\tresult_pattern = cmd.resp[0] & 0xFF;\n\n\tif (result_pattern != test_pattern)\n\t\treturn -EIO;\n\n\tif (resp)\n\t\t*resp = cmd.resp[0];\n\n\treturn 0;\n}\n\nint mmc_send_if_cond(struct mmc_host *host, u32 ocr)\n{\n\treturn __mmc_send_if_cond(host, ocr, 0, NULL);\n}\n\nint mmc_send_if_cond_pcie(struct mmc_host *host, u32 ocr)\n{\n\tu32 resp = 0;\n\tu8 pcie_bits = 0;\n\tint ret;\n\n\tif (host->caps2 & MMC_CAP2_SD_EXP) {\n\t\t \n\t\tpcie_bits = 0x10;\n\t\tif (host->caps2 & MMC_CAP2_SD_EXP_1_2V)\n\t\t\t \n\t\t\tpcie_bits = 0x30;\n\t}\n\n\tret = __mmc_send_if_cond(host, ocr, pcie_bits, &resp);\n\tif (ret)\n\t\treturn 0;\n\n\t \n\tresp &= 0x3000;\n\tif (pcie_bits && resp) {\n\t\tif (resp == 0x3000)\n\t\t\thost->ios.timing = MMC_TIMING_SD_EXP_1_2V;\n\t\telse\n\t\t\thost->ios.timing = MMC_TIMING_SD_EXP;\n\n\t\t \n\t\treturn host->ops->init_sd_express(host, &host->ios);\n\t}\n\n\treturn 0;\n}\n\nint mmc_send_relative_addr(struct mmc_host *host, unsigned int *rca)\n{\n\tint err;\n\tstruct mmc_command cmd = {};\n\n\tcmd.opcode = SD_SEND_RELATIVE_ADDR;\n\tcmd.arg = 0;\n\tcmd.flags = MMC_RSP_R6 | MMC_CMD_BCR;\n\n\terr = mmc_wait_for_cmd(host, &cmd, MMC_CMD_RETRIES);\n\tif (err)\n\t\treturn err;\n\n\t*rca = cmd.resp[0] >> 16;\n\n\treturn 0;\n}\n\nint mmc_app_send_scr(struct mmc_card *card)\n{\n\tint err;\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\t__be32 *scr;\n\n\t \n\n\terr = mmc_app_cmd(card->host, card);\n\tif (err)\n\t\treturn err;\n\n\t \n\tscr = kmalloc(sizeof(card->raw_scr), GFP_KERNEL);\n\tif (!scr)\n\t\treturn -ENOMEM;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = SD_APP_SEND_SCR;\n\tcmd.arg = 0;\n\tcmd.flags = MMC_RSP_SPI_R1 | MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tdata.blksz = 8;\n\tdata.blocks = 1;\n\tdata.flags = MMC_DATA_READ;\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\n\tsg_init_one(&sg, scr, 8);\n\n\tmmc_set_data_timeout(&data, card);\n\n\tmmc_wait_for_req(card->host, &mrq);\n\n\tcard->raw_scr[0] = be32_to_cpu(scr[0]);\n\tcard->raw_scr[1] = be32_to_cpu(scr[1]);\n\n\tkfree(scr);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn 0;\n}\n\nint mmc_sd_switch(struct mmc_card *card, int mode, int group,\n\tu8 value, u8 *resp)\n{\n\tu32 cmd_args;\n\n\t \n\n\tmode = !!mode;\n\tvalue &= 0xF;\n\tcmd_args = mode << 31 | 0x00FFFFFF;\n\tcmd_args &= ~(0xF << (group * 4));\n\tcmd_args |= value << (group * 4);\n\n\treturn mmc_send_adtc_data(card, card->host, SD_SWITCH, cmd_args, resp,\n\t\t\t\t  64);\n}\nEXPORT_SYMBOL_GPL(mmc_sd_switch);\n\nint mmc_app_sd_status(struct mmc_card *card, void *ssr)\n{\n\tint err;\n\tstruct mmc_request mrq = {};\n\tstruct mmc_command cmd = {};\n\tstruct mmc_data data = {};\n\tstruct scatterlist sg;\n\n\t \n\n\terr = mmc_app_cmd(card->host, card);\n\tif (err)\n\t\treturn err;\n\n\tmrq.cmd = &cmd;\n\tmrq.data = &data;\n\n\tcmd.opcode = SD_APP_SD_STATUS;\n\tcmd.arg = 0;\n\tcmd.flags = MMC_RSP_SPI_R2 | MMC_RSP_R1 | MMC_CMD_ADTC;\n\n\tdata.blksz = 64;\n\tdata.blocks = 1;\n\tdata.flags = MMC_DATA_READ;\n\tdata.sg = &sg;\n\tdata.sg_len = 1;\n\n\tsg_init_one(&sg, ssr, 64);\n\n\tmmc_set_data_timeout(&data, card);\n\n\tmmc_wait_for_req(card->host, &mrq);\n\n\tif (cmd.error)\n\t\treturn cmd.error;\n\tif (data.error)\n\t\treturn data.error;\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}