{
  "module_name": "zorro.c",
  "hash_id": "811bfd014940cd7b5604146cd2ae3f2004d9ab98e2301b8a04ab02dcf6895286",
  "original_prompt": "Ingested from linux-6.6.14/drivers/zorro/zorro.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/zorro.h>\n#include <linux/bitops.h>\n#include <linux/string.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n\n#include <asm/byteorder.h>\n#include <asm/setup.h>\n#include <asm/amigahw.h>\n\n#include \"zorro.h\"\n\n\n     \n\nunsigned int zorro_num_autocon;\nstruct zorro_dev_init zorro_autocon_init[ZORRO_NUM_AUTO] __initdata;\nstruct zorro_dev *zorro_autocon;\n\n\n     \n\nstruct zorro_bus {\n\tstruct device dev;\n\tstruct zorro_dev devices[];\n};\n\n\n     \n\nstruct zorro_dev *zorro_find_device(zorro_id id, struct zorro_dev *from)\n{\n\tstruct zorro_dev *z;\n\n\tif (!zorro_num_autocon)\n\t\treturn NULL;\n\n\tfor (z = from ? from+1 : &zorro_autocon[0];\n\t     z < zorro_autocon+zorro_num_autocon;\n\t     z++)\n\t\tif (id == ZORRO_WILDCARD || id == z->id)\n\t\t\treturn z;\n\treturn NULL;\n}\nEXPORT_SYMBOL(zorro_find_device);\n\n\n     \n\nDECLARE_BITMAP(zorro_unused_z2ram, 128);\nEXPORT_SYMBOL(zorro_unused_z2ram);\n\n\nstatic void __init mark_region(unsigned long start, unsigned long end,\n\t\t\t       int flag)\n{\n\tif (flag)\n\t\tstart += Z2RAM_CHUNKMASK;\n\telse\n\t\tend += Z2RAM_CHUNKMASK;\n\tstart &= ~Z2RAM_CHUNKMASK;\n\tend &= ~Z2RAM_CHUNKMASK;\n\n\tif (end <= Z2RAM_START || start >= Z2RAM_END)\n\t\treturn;\n\tstart = start < Z2RAM_START ? 0x00000000 : start-Z2RAM_START;\n\tend = end > Z2RAM_END ? Z2RAM_SIZE : end-Z2RAM_START;\n\twhile (start < end) {\n\t\tu32 chunk = start>>Z2RAM_CHUNKSHIFT;\n\n\t\tif (flag)\n\t\t\tset_bit(chunk, zorro_unused_z2ram);\n\t\telse\n\t\t\tclear_bit(chunk, zorro_unused_z2ram);\n\t\tstart += Z2RAM_CHUNKSIZE;\n\t}\n}\n\n\nstatic struct resource __init *zorro_find_parent_resource(\n\tstruct platform_device *bridge, struct zorro_dev *z)\n{\n\tint i;\n\n\tfor (i = 0; i < bridge->num_resources; i++) {\n\t\tstruct resource *r = &bridge->resource[i];\n\n\t\tif (zorro_resource_start(z) >= r->start &&\n\t\t    zorro_resource_end(z) <= r->end)\n\t\t\treturn r;\n\t}\n\treturn &iomem_resource;\n}\n\n\n\nstatic int __init amiga_zorro_probe(struct platform_device *pdev)\n{\n\tstruct zorro_bus *bus;\n\tstruct zorro_dev_init *zi;\n\tstruct zorro_dev *z;\n\tstruct resource *r;\n\tunsigned int i;\n\tint error;\n\n\t \n\tbus = kzalloc(struct_size(bus, devices, zorro_num_autocon),\n\t\t      GFP_KERNEL);\n\tif (!bus)\n\t\treturn -ENOMEM;\n\n\tzorro_autocon = bus->devices;\n\tbus->dev.parent = &pdev->dev;\n\tdev_set_name(&bus->dev, zorro_bus_type.name);\n\terror = device_register(&bus->dev);\n\tif (error) {\n\t\tpr_err(\"Zorro: Error registering zorro_bus\\n\");\n\t\tput_device(&bus->dev);\n\t\tkfree(bus);\n\t\treturn error;\n\t}\n\tplatform_set_drvdata(pdev, bus);\n\n\tpr_info(\"Zorro: Probing AutoConfig expansion devices: %u device%s\\n\",\n\t\t zorro_num_autocon, zorro_num_autocon == 1 ? \"\" : \"s\");\n\n\t \n\tfor (i = 0; i < zorro_num_autocon; i++) {\n\t\tzi = &zorro_autocon_init[i];\n\t\tz = &zorro_autocon[i];\n\n\t\tz->rom = zi->rom;\n\t\tz->id = (be16_to_cpu(z->rom.er_Manufacturer) << 16) |\n\t\t\t(z->rom.er_Product << 8);\n\t\tif (z->id == ZORRO_PROD_GVP_EPC_BASE) {\n\t\t\t \n\t\t\tunsigned long magic = zi->boardaddr + 0x8000;\n\n\t\t\tz->id |= *(u16 *)ZTWO_VADDR(magic) & GVP_PRODMASK;\n\t\t}\n\t\tz->slotaddr = zi->slotaddr;\n\t\tz->slotsize = zi->slotsize;\n\t\tsprintf(z->name, \"Zorro device %08x\", z->id);\n\t\tzorro_name_device(z);\n\t\tz->resource.start = zi->boardaddr;\n\t\tz->resource.end = zi->boardaddr + zi->boardsize - 1;\n\t\tz->resource.name = z->name;\n\t\tr = zorro_find_parent_resource(pdev, z);\n\t\terror = request_resource(r, &z->resource);\n\t\tif (error && !(z->rom.er_Type & ERTF_MEMLIST))\n\t\t\tdev_err(&bus->dev,\n\t\t\t\t\"Address space collision on device %s %pR\\n\",\n\t\t\t\tz->name, &z->resource);\n\t\tz->dev.parent = &bus->dev;\n\t\tz->dev.bus = &zorro_bus_type;\n\t\tz->dev.id = i;\n\t\tswitch (z->rom.er_Type & ERT_TYPEMASK) {\n\t\tcase ERT_ZORROIII:\n\t\t\tz->dev.coherent_dma_mask = DMA_BIT_MASK(32);\n\t\t\tbreak;\n\n\t\tcase ERT_ZORROII:\n\t\tdefault:\n\t\t\tz->dev.coherent_dma_mask = DMA_BIT_MASK(24);\n\t\t\tbreak;\n\t\t}\n\t\tz->dev.dma_mask = &z->dev.coherent_dma_mask;\n\t}\n\n\t \n\tfor (i = 0; i < zorro_num_autocon; i++) {\n\t\tz = &zorro_autocon[i];\n\t\terror = device_register(&z->dev);\n\t\tif (error) {\n\t\t\tdev_err(&bus->dev, \"Error registering device %s\\n\",\n\t\t\t\tz->name);\n\t\t\tput_device(&z->dev);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\t \n\tzorro_for_each_dev(z) {\n\t\tif (z->rom.er_Type & ERTF_MEMLIST)\n\t\t\tmark_region(zorro_resource_start(z),\n\t\t\t\t    zorro_resource_end(z)+1, 1);\n\t}\n\n\t \n\tfor (i = 0; i < m68k_num_memory; i++)\n\t\tif (m68k_memory[i].addr < 16*1024*1024)\n\t\t\tmark_region(m68k_memory[i].addr,\n\t\t\t\t    m68k_memory[i].addr+m68k_memory[i].size,\n\t\t\t\t    0);\n\n\treturn 0;\n}\n\nstatic struct platform_driver amiga_zorro_driver = {\n\t.driver   = {\n\t\t.name\t= \"amiga-zorro\",\n\t},\n};\n\nstatic int __init amiga_zorro_init(void)\n{\n\treturn platform_driver_probe(&amiga_zorro_driver, amiga_zorro_probe);\n}\n\nmodule_init(amiga_zorro_init);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}