{
  "module_name": "proc.c",
  "hash_id": "da6a71423fa56ac4a167da23a35ccb6eab8c5f51a225493d58bbf6950ca5cc14",
  "original_prompt": "Ingested from linux-6.6.14/drivers/zorro/proc.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/zorro.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/export.h>\n\n#include <asm/byteorder.h>\n#include <linux/uaccess.h>\n#include <asm/amigahw.h>\n#include <asm/setup.h>\n\nstatic loff_t\nproc_bus_zorro_lseek(struct file *file, loff_t off, int whence)\n{\n\treturn fixed_size_llseek(file, off, whence, sizeof(struct ConfigDev));\n}\n\nstatic ssize_t\nproc_bus_zorro_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)\n{\n\tstruct zorro_dev *z = pde_data(file_inode(file));\n\tstruct ConfigDev cd;\n\tloff_t pos = *ppos;\n\n\tif (pos >= sizeof(struct ConfigDev))\n\t\treturn 0;\n\tif (nbytes >= sizeof(struct ConfigDev))\n\t\tnbytes = sizeof(struct ConfigDev);\n\tif (pos + nbytes > sizeof(struct ConfigDev))\n\t\tnbytes = sizeof(struct ConfigDev) - pos;\n\n\t \n\tmemset(&cd, 0, sizeof(cd));\n\tcd.cd_Rom = z->rom;\n\tcd.cd_SlotAddr = cpu_to_be16(z->slotaddr);\n\tcd.cd_SlotSize = cpu_to_be16(z->slotsize);\n\tcd.cd_BoardAddr = cpu_to_be32(zorro_resource_start(z));\n\tcd.cd_BoardSize = cpu_to_be32(zorro_resource_len(z));\n\n\tif (copy_to_user(buf, (void *)&cd + pos, nbytes))\n\t\treturn -EFAULT;\n\t*ppos += nbytes;\n\n\treturn nbytes;\n}\n\nstatic const struct proc_ops bus_zorro_proc_ops = {\n\t.proc_lseek\t= proc_bus_zorro_lseek,\n\t.proc_read\t= proc_bus_zorro_read,\n};\n\nstatic void * zorro_seq_start(struct seq_file *m, loff_t *pos)\n{\n\treturn (*pos < zorro_num_autocon) ? pos : NULL;\n}\n\nstatic void * zorro_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn (*pos < zorro_num_autocon) ? pos : NULL;\n}\n\nstatic void zorro_seq_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int zorro_seq_show(struct seq_file *m, void *v)\n{\n\tunsigned int slot = *(loff_t *)v;\n\tstruct zorro_dev *z = &zorro_autocon[slot];\n\n\tseq_printf(m, \"%02x\\t%08x\\t%08lx\\t%08lx\\t%02x\\n\", slot, z->id,\n\t\t   (unsigned long)zorro_resource_start(z),\n\t\t   (unsigned long)zorro_resource_len(z),\n\t\t   z->rom.er_Type);\n\treturn 0;\n}\n\nstatic const struct seq_operations zorro_devices_seq_ops = {\n\t.start = zorro_seq_start,\n\t.next  = zorro_seq_next,\n\t.stop  = zorro_seq_stop,\n\t.show  = zorro_seq_show,\n};\n\nstatic struct proc_dir_entry *proc_bus_zorro_dir;\n\nstatic int __init zorro_proc_attach_device(unsigned int slot)\n{\n\tstruct proc_dir_entry *entry;\n\tchar name[4];\n\n\tsprintf(name, \"%02x\", slot);\n\tentry = proc_create_data(name, 0, proc_bus_zorro_dir,\n\t\t\t\t &bus_zorro_proc_ops,\n\t\t\t\t &zorro_autocon[slot]);\n\tif (!entry)\n\t\treturn -ENOMEM;\n\tproc_set_size(entry, sizeof(struct zorro_dev));\n\treturn 0;\n}\n\nstatic int __init zorro_proc_init(void)\n{\n\tunsigned int slot;\n\n\tif (MACH_IS_AMIGA && AMIGAHW_PRESENT(ZORRO)) {\n\t\tproc_bus_zorro_dir = proc_mkdir(\"bus/zorro\", NULL);\n\t\tproc_create_seq(\"devices\", 0, proc_bus_zorro_dir,\n\t\t\t    &zorro_devices_seq_ops);\n\t\tfor (slot = 0; slot < zorro_num_autocon; slot++)\n\t\t\tzorro_proc_attach_device(slot);\n\t}\n\treturn 0;\n}\n\ndevice_initcall(zorro_proc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}