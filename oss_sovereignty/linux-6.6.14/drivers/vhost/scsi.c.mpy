{
  "module_name": "scsi.c",
  "hash_id": "f027dcefa097af0a2b466c01349c616b2660f659c3b01f306683aa829ab8127c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vhost/scsi.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <generated/utsrelease.h>\n#include <linux/utsname.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/kthread.h>\n#include <linux/types.h>\n#include <linux/string.h>\n#include <linux/configfs.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/eventfd.h>\n#include <linux/fs.h>\n#include <linux/vmalloc.h>\n#include <linux/miscdevice.h>\n#include <linux/blk_types.h>\n#include <linux/bio.h>\n#include <asm/unaligned.h>\n#include <scsi/scsi_common.h>\n#include <scsi/scsi_proto.h>\n#include <target/target_core_base.h>\n#include <target/target_core_fabric.h>\n#include <linux/vhost.h>\n#include <linux/virtio_scsi.h>\n#include <linux/llist.h>\n#include <linux/bitmap.h>\n\n#include \"vhost.h\"\n\n#define VHOST_SCSI_VERSION  \"v0.1\"\n#define VHOST_SCSI_NAMELEN 256\n#define VHOST_SCSI_MAX_CDB_SIZE 32\n#define VHOST_SCSI_PREALLOC_SGLS 2048\n#define VHOST_SCSI_PREALLOC_UPAGES 2048\n#define VHOST_SCSI_PREALLOC_PROT_SGLS 2048\n\n \n#define VHOST_SCSI_WEIGHT 256\n\nstruct vhost_scsi_inflight {\n\t \n\tstruct completion comp;\n\t \n\tstruct kref kref;\n};\n\nstruct vhost_scsi_cmd {\n\t \n\tint tvc_vq_desc;\n\t \n\tint tvc_task_attr;\n\t \n\tint tvc_in_iovs;\n\t \n\tenum dma_data_direction tvc_data_direction;\n\t \n\tu32 tvc_exp_data_len;\n\t \n\tu64 tvc_tag;\n\t \n\tu32 tvc_sgl_count;\n\tu32 tvc_prot_sgl_count;\n\t \n\tu32 tvc_lun;\n\tu32 copied_iov:1;\n\tconst void *saved_iter_addr;\n\tstruct iov_iter saved_iter;\n\t \n\tstruct scatterlist *tvc_sgl;\n\tstruct scatterlist *tvc_prot_sgl;\n\tstruct page **tvc_upages;\n\t \n\tstruct iovec *tvc_resp_iov;\n\t \n\tstruct vhost_scsi *tvc_vhost;\n\t \n\tstruct vhost_virtqueue *tvc_vq;\n\t \n\tstruct vhost_scsi_nexus *tvc_nexus;\n\t \n\tstruct se_cmd tvc_se_cmd;\n\t \n\tunsigned char tvc_cdb[VHOST_SCSI_MAX_CDB_SIZE];\n\t \n\tunsigned char tvc_sense_buf[TRANSPORT_SENSE_BUFFER];\n\t \n\tstruct llist_node tvc_completion_list;\n\t \n\tstruct vhost_scsi_inflight *inflight;\n};\n\nstruct vhost_scsi_nexus {\n\t \n\tstruct se_session *tvn_se_sess;\n};\n\nstruct vhost_scsi_tpg {\n\t \n\tu16 tport_tpgt;\n\t \n\tint tv_tpg_port_count;\n\t \n\tint tv_tpg_vhost_count;\n\t \n\tint tv_fabric_prot_type;\n\t \n\tstruct list_head tv_tpg_list;\n\t \n\tstruct mutex tv_tpg_mutex;\n\t \n\tstruct vhost_scsi_nexus *tpg_nexus;\n\t \n\tstruct vhost_scsi_tport *tport;\n\t \n\tstruct se_portal_group se_tpg;\n\t \n\tstruct vhost_scsi *vhost_scsi;\n};\n\nstruct vhost_scsi_tport {\n\t \n\tu8 tport_proto_id;\n\t \n\tu64 tport_wwpn;\n\t \n\tchar tport_name[VHOST_SCSI_NAMELEN];\n\t \n\tstruct se_wwn tport_wwn;\n};\n\nstruct vhost_scsi_evt {\n\t \n\tstruct virtio_scsi_event event;\n\t \n\tstruct llist_node list;\n};\n\nenum {\n\tVHOST_SCSI_VQ_CTL = 0,\n\tVHOST_SCSI_VQ_EVT = 1,\n\tVHOST_SCSI_VQ_IO = 2,\n};\n\n \nenum {\n\tVHOST_SCSI_FEATURES = VHOST_FEATURES | (1ULL << VIRTIO_SCSI_F_HOTPLUG) |\n\t\t\t\t\t       (1ULL << VIRTIO_SCSI_F_T10_PI)\n};\n\n#define VHOST_SCSI_MAX_TARGET\t256\n#define VHOST_SCSI_MAX_IO_VQ\t1024\n#define VHOST_SCSI_MAX_EVENT\t128\n\nstatic unsigned vhost_scsi_max_io_vqs = 128;\nmodule_param_named(max_io_vqs, vhost_scsi_max_io_vqs, uint, 0644);\nMODULE_PARM_DESC(max_io_vqs, \"Set the max number of IO virtqueues a vhost scsi device can support. The default is 128. The max is 1024.\");\n\nstruct vhost_scsi_virtqueue {\n\tstruct vhost_virtqueue vq;\n\tstruct vhost_scsi *vs;\n\t \n\tstruct vhost_scsi_inflight inflights[2];\n\t \n\tint inflight_idx;\n\tstruct vhost_scsi_cmd *scsi_cmds;\n\tstruct sbitmap scsi_tags;\n\tint max_cmds;\n\n\tstruct vhost_work completion_work;\n\tstruct llist_head completion_list;\n};\n\nstruct vhost_scsi {\n\t \n\tstruct vhost_scsi_tpg **vs_tpg;\n\tchar vs_vhost_wwpn[TRANSPORT_IQN_LEN];\n\n\tstruct vhost_dev dev;\n\tstruct vhost_scsi_virtqueue *vqs;\n\tstruct vhost_scsi_inflight **old_inflight;\n\n\tstruct vhost_work vs_event_work;  \n\tstruct llist_head vs_event_list;  \n\n\tbool vs_events_missed;  \n\tint vs_events_nr;  \n};\n\nstruct vhost_scsi_tmf {\n\tstruct vhost_work vwork;\n\tstruct vhost_scsi *vhost;\n\tstruct vhost_scsi_virtqueue *svq;\n\n\tstruct se_cmd se_cmd;\n\tu8 scsi_resp;\n\tstruct vhost_scsi_inflight *inflight;\n\tstruct iovec resp_iov;\n\tint in_iovs;\n\tint vq_desc;\n};\n\n \nstruct vhost_scsi_ctx {\n\tint head;\n\tunsigned int out, in;\n\tsize_t req_size, rsp_size;\n\tsize_t out_size, in_size;\n\tu8 *target, *lunp;\n\tvoid *req;\n\tstruct iov_iter out_iter;\n};\n\n \nstatic DEFINE_MUTEX(vhost_scsi_mutex);\nstatic LIST_HEAD(vhost_scsi_list);\n\nstatic void vhost_scsi_done_inflight(struct kref *kref)\n{\n\tstruct vhost_scsi_inflight *inflight;\n\n\tinflight = container_of(kref, struct vhost_scsi_inflight, kref);\n\tcomplete(&inflight->comp);\n}\n\nstatic void vhost_scsi_init_inflight(struct vhost_scsi *vs,\n\t\t\t\t    struct vhost_scsi_inflight *old_inflight[])\n{\n\tstruct vhost_scsi_inflight *new_inflight;\n\tstruct vhost_virtqueue *vq;\n\tint idx, i;\n\n\tfor (i = 0; i < vs->dev.nvqs;  i++) {\n\t\tvq = &vs->vqs[i].vq;\n\n\t\tmutex_lock(&vq->mutex);\n\n\t\t \n\t\tidx = vs->vqs[i].inflight_idx;\n\t\tif (old_inflight)\n\t\t\told_inflight[i] = &vs->vqs[i].inflights[idx];\n\n\t\t \n\t\tvs->vqs[i].inflight_idx = idx ^ 1;\n\t\tnew_inflight = &vs->vqs[i].inflights[idx ^ 1];\n\t\tkref_init(&new_inflight->kref);\n\t\tinit_completion(&new_inflight->comp);\n\n\t\tmutex_unlock(&vq->mutex);\n\t}\n}\n\nstatic struct vhost_scsi_inflight *\nvhost_scsi_get_inflight(struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_inflight *inflight;\n\tstruct vhost_scsi_virtqueue *svq;\n\n\tsvq = container_of(vq, struct vhost_scsi_virtqueue, vq);\n\tinflight = &svq->inflights[svq->inflight_idx];\n\tkref_get(&inflight->kref);\n\n\treturn inflight;\n}\n\nstatic void vhost_scsi_put_inflight(struct vhost_scsi_inflight *inflight)\n{\n\tkref_put(&inflight->kref, vhost_scsi_done_inflight);\n}\n\nstatic int vhost_scsi_check_true(struct se_portal_group *se_tpg)\n{\n\treturn 1;\n}\n\nstatic char *vhost_scsi_get_fabric_wwn(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_tport *tport = tpg->tport;\n\n\treturn &tport->tport_name[0];\n}\n\nstatic u16 vhost_scsi_get_tpgt(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\treturn tpg->tport_tpgt;\n}\n\nstatic int vhost_scsi_check_prot_fabric_only(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\treturn tpg->tv_fabric_prot_type;\n}\n\nstatic void vhost_scsi_release_cmd_res(struct se_cmd *se_cmd)\n{\n\tstruct vhost_scsi_cmd *tv_cmd = container_of(se_cmd,\n\t\t\t\tstruct vhost_scsi_cmd, tvc_se_cmd);\n\tstruct vhost_scsi_virtqueue *svq = container_of(tv_cmd->tvc_vq,\n\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\tstruct vhost_scsi_inflight *inflight = tv_cmd->inflight;\n\tint i;\n\n\tif (tv_cmd->tvc_sgl_count) {\n\t\tfor (i = 0; i < tv_cmd->tvc_sgl_count; i++) {\n\t\t\tif (tv_cmd->copied_iov)\n\t\t\t\t__free_page(sg_page(&tv_cmd->tvc_sgl[i]));\n\t\t\telse\n\t\t\t\tput_page(sg_page(&tv_cmd->tvc_sgl[i]));\n\t\t}\n\t\tkfree(tv_cmd->saved_iter_addr);\n\t}\n\tif (tv_cmd->tvc_prot_sgl_count) {\n\t\tfor (i = 0; i < tv_cmd->tvc_prot_sgl_count; i++)\n\t\t\tput_page(sg_page(&tv_cmd->tvc_prot_sgl[i]));\n\t}\n\n\tsbitmap_clear_bit(&svq->scsi_tags, se_cmd->map_tag);\n\tvhost_scsi_put_inflight(inflight);\n}\n\nstatic void vhost_scsi_release_tmf_res(struct vhost_scsi_tmf *tmf)\n{\n\tstruct vhost_scsi_inflight *inflight = tmf->inflight;\n\n\tkfree(tmf);\n\tvhost_scsi_put_inflight(inflight);\n}\n\nstatic void vhost_scsi_release_cmd(struct se_cmd *se_cmd)\n{\n\tif (se_cmd->se_cmd_flags & SCF_SCSI_TMR_CDB) {\n\t\tstruct vhost_scsi_tmf *tmf = container_of(se_cmd,\n\t\t\t\t\tstruct vhost_scsi_tmf, se_cmd);\n\t\tstruct vhost_virtqueue *vq = &tmf->svq->vq;\n\n\t\tvhost_vq_work_queue(vq, &tmf->vwork);\n\t} else {\n\t\tstruct vhost_scsi_cmd *cmd = container_of(se_cmd,\n\t\t\t\t\tstruct vhost_scsi_cmd, tvc_se_cmd);\n\t\tstruct vhost_scsi_virtqueue *svq =  container_of(cmd->tvc_vq,\n\t\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\n\t\tllist_add(&cmd->tvc_completion_list, &svq->completion_list);\n\t\tvhost_vq_work_queue(&svq->vq, &svq->completion_work);\n\t}\n}\n\nstatic int vhost_scsi_write_pending(struct se_cmd *se_cmd)\n{\n\t \n\ttarget_execute_cmd(se_cmd);\n\treturn 0;\n}\n\nstatic int vhost_scsi_queue_data_in(struct se_cmd *se_cmd)\n{\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn 0;\n}\n\nstatic int vhost_scsi_queue_status(struct se_cmd *se_cmd)\n{\n\ttransport_generic_free_cmd(se_cmd, 0);\n\treturn 0;\n}\n\nstatic void vhost_scsi_queue_tm_rsp(struct se_cmd *se_cmd)\n{\n\tstruct vhost_scsi_tmf *tmf = container_of(se_cmd, struct vhost_scsi_tmf,\n\t\t\t\t\t\t  se_cmd);\n\n\ttmf->scsi_resp = se_cmd->se_tmr_req->response;\n\ttransport_generic_free_cmd(&tmf->se_cmd, 0);\n}\n\nstatic void vhost_scsi_aborted_task(struct se_cmd *se_cmd)\n{\n\treturn;\n}\n\nstatic void vhost_scsi_free_evt(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)\n{\n\tvs->vs_events_nr--;\n\tkfree(evt);\n}\n\nstatic struct vhost_scsi_evt *\nvhost_scsi_allocate_evt(struct vhost_scsi *vs,\n\t\t       u32 event, u32 reason)\n{\n\tstruct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tstruct vhost_scsi_evt *evt;\n\n\tif (vs->vs_events_nr > VHOST_SCSI_MAX_EVENT) {\n\t\tvs->vs_events_missed = true;\n\t\treturn NULL;\n\t}\n\n\tevt = kzalloc(sizeof(*evt), GFP_KERNEL);\n\tif (!evt) {\n\t\tvq_err(vq, \"Failed to allocate vhost_scsi_evt\\n\");\n\t\tvs->vs_events_missed = true;\n\t\treturn NULL;\n\t}\n\n\tevt->event.event = cpu_to_vhost32(vq, event);\n\tevt->event.reason = cpu_to_vhost32(vq, reason);\n\tvs->vs_events_nr++;\n\n\treturn evt;\n}\n\nstatic int vhost_scsi_check_stop_free(struct se_cmd *se_cmd)\n{\n\treturn target_put_sess_cmd(se_cmd);\n}\n\nstatic void\nvhost_scsi_do_evt_work(struct vhost_scsi *vs, struct vhost_scsi_evt *evt)\n{\n\tstruct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tstruct virtio_scsi_event *event = &evt->event;\n\tstruct virtio_scsi_event __user *eventp;\n\tunsigned out, in;\n\tint head, ret;\n\n\tif (!vhost_vq_get_backend(vq)) {\n\t\tvs->vs_events_missed = true;\n\t\treturn;\n\t}\n\nagain:\n\tvhost_disable_notify(&vs->dev, vq);\n\thead = vhost_get_vq_desc(vq, vq->iov,\n\t\t\tARRAY_SIZE(vq->iov), &out, &in,\n\t\t\tNULL, NULL);\n\tif (head < 0) {\n\t\tvs->vs_events_missed = true;\n\t\treturn;\n\t}\n\tif (head == vq->num) {\n\t\tif (vhost_enable_notify(&vs->dev, vq))\n\t\t\tgoto again;\n\t\tvs->vs_events_missed = true;\n\t\treturn;\n\t}\n\n\tif ((vq->iov[out].iov_len != sizeof(struct virtio_scsi_event))) {\n\t\tvq_err(vq, \"Expecting virtio_scsi_event, got %zu bytes\\n\",\n\t\t\t\tvq->iov[out].iov_len);\n\t\tvs->vs_events_missed = true;\n\t\treturn;\n\t}\n\n\tif (vs->vs_events_missed) {\n\t\tevent->event |= cpu_to_vhost32(vq, VIRTIO_SCSI_T_EVENTS_MISSED);\n\t\tvs->vs_events_missed = false;\n\t}\n\n\teventp = vq->iov[out].iov_base;\n\tret = __copy_to_user(eventp, event, sizeof(*event));\n\tif (!ret)\n\t\tvhost_add_used_and_signal(&vs->dev, vq, head, 0);\n\telse\n\t\tvq_err(vq, \"Faulted on vhost_scsi_send_event\\n\");\n}\n\nstatic void vhost_scsi_evt_work(struct vhost_work *work)\n{\n\tstruct vhost_scsi *vs = container_of(work, struct vhost_scsi,\n\t\t\t\t\tvs_event_work);\n\tstruct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tstruct vhost_scsi_evt *evt, *t;\n\tstruct llist_node *llnode;\n\n\tmutex_lock(&vq->mutex);\n\tllnode = llist_del_all(&vs->vs_event_list);\n\tllist_for_each_entry_safe(evt, t, llnode, list) {\n\t\tvhost_scsi_do_evt_work(vs, evt);\n\t\tvhost_scsi_free_evt(vs, evt);\n\t}\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic int vhost_scsi_copy_sgl_to_iov(struct vhost_scsi_cmd *cmd)\n{\n\tstruct iov_iter *iter = &cmd->saved_iter;\n\tstruct scatterlist *sg = cmd->tvc_sgl;\n\tstruct page *page;\n\tsize_t len;\n\tint i;\n\n\tfor (i = 0; i < cmd->tvc_sgl_count; i++) {\n\t\tpage = sg_page(&sg[i]);\n\t\tlen = sg[i].length;\n\n\t\tif (copy_page_to_iter(page, 0, len, iter) != len) {\n\t\t\tpr_err(\"Could not copy data while handling misaligned cmd. Error %zu\\n\",\n\t\t\t       len);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void vhost_scsi_complete_cmd_work(struct vhost_work *work)\n{\n\tstruct vhost_scsi_virtqueue *svq = container_of(work,\n\t\t\t\tstruct vhost_scsi_virtqueue, completion_work);\n\tstruct virtio_scsi_cmd_resp v_rsp;\n\tstruct vhost_scsi_cmd *cmd, *t;\n\tstruct llist_node *llnode;\n\tstruct se_cmd *se_cmd;\n\tstruct iov_iter iov_iter;\n\tbool signal = false;\n\tint ret;\n\n\tllnode = llist_del_all(&svq->completion_list);\n\tllist_for_each_entry_safe(cmd, t, llnode, tvc_completion_list) {\n\t\tse_cmd = &cmd->tvc_se_cmd;\n\n\t\tpr_debug(\"%s tv_cmd %p resid %u status %#02x\\n\", __func__,\n\t\t\tcmd, se_cmd->residual_count, se_cmd->scsi_status);\n\t\tmemset(&v_rsp, 0, sizeof(v_rsp));\n\n\t\tif (cmd->saved_iter_addr && vhost_scsi_copy_sgl_to_iov(cmd)) {\n\t\t\tv_rsp.response = VIRTIO_SCSI_S_BAD_TARGET;\n\t\t} else {\n\t\t\tv_rsp.resid = cpu_to_vhost32(cmd->tvc_vq,\n\t\t\t\t\t\t     se_cmd->residual_count);\n\t\t\t \n\t\t\tv_rsp.status = se_cmd->scsi_status;\n\t\t\tv_rsp.sense_len = cpu_to_vhost32(cmd->tvc_vq,\n\t\t\t\t\t\t\t se_cmd->scsi_sense_length);\n\t\t\tmemcpy(v_rsp.sense, cmd->tvc_sense_buf,\n\t\t\t       se_cmd->scsi_sense_length);\n\t\t}\n\n\t\tiov_iter_init(&iov_iter, ITER_DEST, cmd->tvc_resp_iov,\n\t\t\t      cmd->tvc_in_iovs, sizeof(v_rsp));\n\t\tret = copy_to_iter(&v_rsp, sizeof(v_rsp), &iov_iter);\n\t\tif (likely(ret == sizeof(v_rsp))) {\n\t\t\tsignal = true;\n\n\t\t\tvhost_add_used(cmd->tvc_vq, cmd->tvc_vq_desc, 0);\n\t\t} else\n\t\t\tpr_err(\"Faulted on virtio_scsi_cmd_resp\\n\");\n\n\t\tvhost_scsi_release_cmd_res(se_cmd);\n\t}\n\n\tif (signal)\n\t\tvhost_signal(&svq->vs->dev, &svq->vq);\n}\n\nstatic struct vhost_scsi_cmd *\nvhost_scsi_get_cmd(struct vhost_virtqueue *vq, struct vhost_scsi_tpg *tpg,\n\t\t   unsigned char *cdb, u64 scsi_tag, u16 lun, u8 task_attr,\n\t\t   u32 exp_data_len, int data_direction)\n{\n\tstruct vhost_scsi_virtqueue *svq = container_of(vq,\n\t\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\tstruct vhost_scsi_cmd *cmd;\n\tstruct vhost_scsi_nexus *tv_nexus;\n\tstruct scatterlist *sg, *prot_sg;\n\tstruct iovec *tvc_resp_iov;\n\tstruct page **pages;\n\tint tag;\n\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tpr_err(\"Unable to locate active struct vhost_scsi_nexus\\n\");\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\ttag = sbitmap_get(&svq->scsi_tags);\n\tif (tag < 0) {\n\t\tpr_err(\"Unable to obtain tag for vhost_scsi_cmd\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tcmd = &svq->scsi_cmds[tag];\n\tsg = cmd->tvc_sgl;\n\tprot_sg = cmd->tvc_prot_sgl;\n\tpages = cmd->tvc_upages;\n\ttvc_resp_iov = cmd->tvc_resp_iov;\n\tmemset(cmd, 0, sizeof(*cmd));\n\tcmd->tvc_sgl = sg;\n\tcmd->tvc_prot_sgl = prot_sg;\n\tcmd->tvc_upages = pages;\n\tcmd->tvc_se_cmd.map_tag = tag;\n\tcmd->tvc_tag = scsi_tag;\n\tcmd->tvc_lun = lun;\n\tcmd->tvc_task_attr = task_attr;\n\tcmd->tvc_exp_data_len = exp_data_len;\n\tcmd->tvc_data_direction = data_direction;\n\tcmd->tvc_nexus = tv_nexus;\n\tcmd->inflight = vhost_scsi_get_inflight(vq);\n\tcmd->tvc_resp_iov = tvc_resp_iov;\n\n\tmemcpy(cmd->tvc_cdb, cdb, VHOST_SCSI_MAX_CDB_SIZE);\n\n\treturn cmd;\n}\n\n \nstatic int\nvhost_scsi_map_to_sgl(struct vhost_scsi_cmd *cmd,\n\t\t      struct iov_iter *iter,\n\t\t      struct scatterlist *sgl,\n\t\t      bool is_prot)\n{\n\tstruct page **pages = cmd->tvc_upages;\n\tstruct scatterlist *sg = sgl;\n\tssize_t bytes, mapped_bytes;\n\tsize_t offset, mapped_offset;\n\tunsigned int npages = 0;\n\n\tbytes = iov_iter_get_pages2(iter, pages, LONG_MAX,\n\t\t\t\tVHOST_SCSI_PREALLOC_UPAGES, &offset);\n\t \n\tif (bytes <= 0)\n\t\treturn bytes < 0 ? bytes : -EFAULT;\n\n\tmapped_bytes = bytes;\n\tmapped_offset = offset;\n\n\twhile (bytes) {\n\t\tunsigned n = min_t(unsigned, PAGE_SIZE - offset, bytes);\n\t\t \n\t\tif (!is_prot &&\n\t\t    (offset & (SECTOR_SIZE - 1) || n & (SECTOR_SIZE - 1)) &&\n\t\t    cmd->tvc_sgl_count > BIO_MAX_VECS) {\n\t\t\tWARN_ONCE(true,\n\t\t\t\t  \"vhost-scsi detected misaligned IO. Performance may be degraded.\");\n\t\t\tgoto revert_iter_get_pages;\n\t\t}\n\n\t\tsg_set_page(sg++, pages[npages++], n, offset);\n\t\tbytes -= n;\n\t\toffset = 0;\n\t}\n\n\treturn npages;\n\nrevert_iter_get_pages:\n\tiov_iter_revert(iter, mapped_bytes);\n\n\tnpages = 0;\n\twhile (mapped_bytes) {\n\t\tunsigned int n = min_t(unsigned int, PAGE_SIZE - mapped_offset,\n\t\t\t\t       mapped_bytes);\n\n\t\tput_page(pages[npages++]);\n\n\t\tmapped_bytes -= n;\n\t\tmapped_offset = 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int\nvhost_scsi_calc_sgls(struct iov_iter *iter, size_t bytes, int max_sgls)\n{\n\tint sgl_count = 0;\n\n\tif (!iter || !iter_iov(iter)) {\n\t\tpr_err(\"%s: iter->iov is NULL, but expected bytes: %zu\"\n\t\t       \" present\\n\", __func__, bytes);\n\t\treturn -EINVAL;\n\t}\n\n\tsgl_count = iov_iter_npages(iter, 0xffff);\n\tif (sgl_count > max_sgls) {\n\t\tpr_err(\"%s: requested sgl_count: %d exceeds pre-allocated\"\n\t\t       \" max_sgls: %d\\n\", __func__, sgl_count, max_sgls);\n\t\treturn -EINVAL;\n\t}\n\treturn sgl_count;\n}\n\nstatic int\nvhost_scsi_copy_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,\n\t\t\t   struct scatterlist *sg, int sg_count)\n{\n\tsize_t len = iov_iter_count(iter);\n\tunsigned int nbytes = 0;\n\tstruct page *page;\n\tint i;\n\n\tif (cmd->tvc_data_direction == DMA_FROM_DEVICE) {\n\t\tcmd->saved_iter_addr = dup_iter(&cmd->saved_iter, iter,\n\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!cmd->saved_iter_addr)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < sg_count; i++) {\n\t\tpage = alloc_page(GFP_KERNEL);\n\t\tif (!page) {\n\t\t\ti--;\n\t\t\tgoto err;\n\t\t}\n\n\t\tnbytes = min_t(unsigned int, PAGE_SIZE, len);\n\t\tsg_set_page(&sg[i], page, nbytes, 0);\n\n\t\tif (cmd->tvc_data_direction == DMA_TO_DEVICE &&\n\t\t    copy_page_from_iter(page, 0, nbytes, iter) != nbytes)\n\t\t\tgoto err;\n\n\t\tlen -= nbytes;\n\t}\n\n\tcmd->copied_iov = 1;\n\treturn 0;\n\nerr:\n\tpr_err(\"Could not read %u bytes while handling misaligned cmd\\n\",\n\t       nbytes);\n\n\tfor (; i >= 0; i--)\n\t\t__free_page(sg_page(&sg[i]));\n\tkfree(cmd->saved_iter_addr);\n\treturn -ENOMEM;\n}\n\nstatic int\nvhost_scsi_map_iov_to_sgl(struct vhost_scsi_cmd *cmd, struct iov_iter *iter,\n\t\t\t  struct scatterlist *sg, int sg_count, bool is_prot)\n{\n\tstruct scatterlist *p = sg;\n\tsize_t revert_bytes;\n\tint ret;\n\n\twhile (iov_iter_count(iter)) {\n\t\tret = vhost_scsi_map_to_sgl(cmd, iter, sg, is_prot);\n\t\tif (ret < 0) {\n\t\t\trevert_bytes = 0;\n\n\t\t\twhile (p < sg) {\n\t\t\t\tstruct page *page = sg_page(p);\n\n\t\t\t\tif (page) {\n\t\t\t\t\tput_page(page);\n\t\t\t\t\trevert_bytes += p->length;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\tiov_iter_revert(iter, revert_bytes);\n\t\t\treturn ret;\n\t\t}\n\t\tsg += ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvhost_scsi_mapal(struct vhost_scsi_cmd *cmd,\n\t\t size_t prot_bytes, struct iov_iter *prot_iter,\n\t\t size_t data_bytes, struct iov_iter *data_iter)\n{\n\tint sgl_count, ret;\n\n\tif (prot_bytes) {\n\t\tsgl_count = vhost_scsi_calc_sgls(prot_iter, prot_bytes,\n\t\t\t\t\t\t VHOST_SCSI_PREALLOC_PROT_SGLS);\n\t\tif (sgl_count < 0)\n\t\t\treturn sgl_count;\n\n\t\tsg_init_table(cmd->tvc_prot_sgl, sgl_count);\n\t\tcmd->tvc_prot_sgl_count = sgl_count;\n\t\tpr_debug(\"%s prot_sg %p prot_sgl_count %u\\n\", __func__,\n\t\t\t cmd->tvc_prot_sgl, cmd->tvc_prot_sgl_count);\n\n\t\tret = vhost_scsi_map_iov_to_sgl(cmd, prot_iter,\n\t\t\t\t\t\tcmd->tvc_prot_sgl,\n\t\t\t\t\t\tcmd->tvc_prot_sgl_count, true);\n\t\tif (ret < 0) {\n\t\t\tcmd->tvc_prot_sgl_count = 0;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tsgl_count = vhost_scsi_calc_sgls(data_iter, data_bytes,\n\t\t\t\t\t VHOST_SCSI_PREALLOC_SGLS);\n\tif (sgl_count < 0)\n\t\treturn sgl_count;\n\n\tsg_init_table(cmd->tvc_sgl, sgl_count);\n\tcmd->tvc_sgl_count = sgl_count;\n\tpr_debug(\"%s data_sg %p data_sgl_count %u\\n\", __func__,\n\t\t  cmd->tvc_sgl, cmd->tvc_sgl_count);\n\n\tret = vhost_scsi_map_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl,\n\t\t\t\t\tcmd->tvc_sgl_count, false);\n\tif (ret == -EINVAL) {\n\t\tsg_init_table(cmd->tvc_sgl, cmd->tvc_sgl_count);\n\t\tret = vhost_scsi_copy_iov_to_sgl(cmd, data_iter, cmd->tvc_sgl,\n\t\t\t\t\t\t cmd->tvc_sgl_count);\n\t}\n\n\tif (ret < 0) {\n\t\tcmd->tvc_sgl_count = 0;\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int vhost_scsi_to_tcm_attr(int attr)\n{\n\tswitch (attr) {\n\tcase VIRTIO_SCSI_S_SIMPLE:\n\t\treturn TCM_SIMPLE_TAG;\n\tcase VIRTIO_SCSI_S_ORDERED:\n\t\treturn TCM_ORDERED_TAG;\n\tcase VIRTIO_SCSI_S_HEAD:\n\t\treturn TCM_HEAD_TAG;\n\tcase VIRTIO_SCSI_S_ACA:\n\t\treturn TCM_ACA_TAG;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn TCM_SIMPLE_TAG;\n}\n\nstatic void vhost_scsi_target_queue_cmd(struct vhost_scsi_cmd *cmd)\n{\n\tstruct se_cmd *se_cmd = &cmd->tvc_se_cmd;\n\tstruct vhost_scsi_nexus *tv_nexus;\n\tstruct scatterlist *sg_ptr, *sg_prot_ptr = NULL;\n\n\t \n\tif (cmd->tvc_sgl_count) {\n\t\tsg_ptr = cmd->tvc_sgl;\n\n\t\tif (cmd->tvc_prot_sgl_count)\n\t\t\tsg_prot_ptr = cmd->tvc_prot_sgl;\n\t\telse\n\t\t\tse_cmd->prot_pto = true;\n\t} else {\n\t\tsg_ptr = NULL;\n\t}\n\ttv_nexus = cmd->tvc_nexus;\n\n\tse_cmd->tag = 0;\n\ttarget_init_cmd(se_cmd, tv_nexus->tvn_se_sess, &cmd->tvc_sense_buf[0],\n\t\t\tcmd->tvc_lun, cmd->tvc_exp_data_len,\n\t\t\tvhost_scsi_to_tcm_attr(cmd->tvc_task_attr),\n\t\t\tcmd->tvc_data_direction, TARGET_SCF_ACK_KREF);\n\n\tif (target_submit_prep(se_cmd, cmd->tvc_cdb, sg_ptr,\n\t\t\t       cmd->tvc_sgl_count, NULL, 0, sg_prot_ptr,\n\t\t\t       cmd->tvc_prot_sgl_count, GFP_KERNEL))\n\t\treturn;\n\n\ttarget_queue_submission(se_cmd);\n}\n\nstatic void\nvhost_scsi_send_bad_target(struct vhost_scsi *vs,\n\t\t\t   struct vhost_virtqueue *vq,\n\t\t\t   int head, unsigned out)\n{\n\tstruct virtio_scsi_cmd_resp __user *resp;\n\tstruct virtio_scsi_cmd_resp rsp;\n\tint ret;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.response = VIRTIO_SCSI_S_BAD_TARGET;\n\tresp = vq->iov[out].iov_base;\n\tret = __copy_to_user(resp, &rsp, sizeof(rsp));\n\tif (!ret)\n\t\tvhost_add_used_and_signal(&vs->dev, vq, head, 0);\n\telse\n\t\tpr_err(\"Faulted on virtio_scsi_cmd_resp\\n\");\n}\n\nstatic int\nvhost_scsi_get_desc(struct vhost_scsi *vs, struct vhost_virtqueue *vq,\n\t\t    struct vhost_scsi_ctx *vc)\n{\n\tint ret = -ENXIO;\n\n\tvc->head = vhost_get_vq_desc(vq, vq->iov,\n\t\t\t\t     ARRAY_SIZE(vq->iov), &vc->out, &vc->in,\n\t\t\t\t     NULL, NULL);\n\n\tpr_debug(\"vhost_get_vq_desc: head: %d, out: %u in: %u\\n\",\n\t\t vc->head, vc->out, vc->in);\n\n\t \n\tif (unlikely(vc->head < 0))\n\t\tgoto done;\n\n\t \n\tif (vc->head == vq->num) {\n\t\tif (unlikely(vhost_enable_notify(&vs->dev, vq))) {\n\t\t\tvhost_disable_notify(&vs->dev, vq);\n\t\t\tret = -EAGAIN;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tvc->out_size = iov_length(vq->iov, vc->out);\n\tvc->in_size = iov_length(&vq->iov[vc->out], vc->in);\n\n\t \n\tiov_iter_init(&vc->out_iter, ITER_SOURCE, vq->iov, vc->out, vc->out_size);\n\tret = 0;\n\ndone:\n\treturn ret;\n}\n\nstatic int\nvhost_scsi_chk_size(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc)\n{\n\tif (unlikely(vc->in_size < vc->rsp_size)) {\n\t\tvq_err(vq,\n\t\t       \"Response buf too small, need min %zu bytes got %zu\",\n\t\t       vc->rsp_size, vc->in_size);\n\t\treturn -EINVAL;\n\t} else if (unlikely(vc->out_size < vc->req_size)) {\n\t\tvq_err(vq,\n\t\t       \"Request buf too small, need min %zu bytes got %zu\",\n\t\t       vc->req_size, vc->out_size);\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int\nvhost_scsi_get_req(struct vhost_virtqueue *vq, struct vhost_scsi_ctx *vc,\n\t\t   struct vhost_scsi_tpg **tpgp)\n{\n\tint ret = -EIO;\n\n\tif (unlikely(!copy_from_iter_full(vc->req, vc->req_size,\n\t\t\t\t\t  &vc->out_iter))) {\n\t\tvq_err(vq, \"Faulted on copy_from_iter_full\\n\");\n\t} else if (unlikely(*vc->lunp != 1)) {\n\t\t \n\t\tvq_err(vq, \"Illegal virtio-scsi lun: %u\\n\", *vc->lunp);\n\t} else {\n\t\tstruct vhost_scsi_tpg **vs_tpg, *tpg;\n\n\t\tvs_tpg = vhost_vq_get_backend(vq);\t \n\n\t\ttpg = READ_ONCE(vs_tpg[*vc->target]);\n\t\tif (unlikely(!tpg)) {\n\t\t\tvq_err(vq, \"Target 0x%x does not exist\\n\", *vc->target);\n\t\t} else {\n\t\t\tif (tpgp)\n\t\t\t\t*tpgp = tpg;\n\t\t\tret = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic u16 vhost_buf_to_lun(u8 *lun_buf)\n{\n\treturn ((lun_buf[2] << 8) | lun_buf[3]) & 0x3FFF;\n}\n\nstatic void\nvhost_scsi_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_tpg **vs_tpg, *tpg;\n\tstruct virtio_scsi_cmd_req v_req;\n\tstruct virtio_scsi_cmd_req_pi v_req_pi;\n\tstruct vhost_scsi_ctx vc;\n\tstruct vhost_scsi_cmd *cmd;\n\tstruct iov_iter in_iter, prot_iter, data_iter;\n\tu64 tag;\n\tu32 exp_data_len, data_direction;\n\tint ret, prot_bytes, i, c = 0;\n\tu16 lun;\n\tu8 task_attr;\n\tbool t10_pi = vhost_has_feature(vq, VIRTIO_SCSI_F_T10_PI);\n\tvoid *cdb;\n\n\tmutex_lock(&vq->mutex);\n\t \n\tvs_tpg = vhost_vq_get_backend(vq);\n\tif (!vs_tpg)\n\t\tgoto out;\n\n\tmemset(&vc, 0, sizeof(vc));\n\tvc.rsp_size = sizeof(struct virtio_scsi_cmd_resp);\n\n\tvhost_disable_notify(&vs->dev, vq);\n\n\tdo {\n\t\tret = vhost_scsi_get_desc(vs, vq, &vc);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tif (t10_pi) {\n\t\t\tvc.req = &v_req_pi;\n\t\t\tvc.req_size = sizeof(v_req_pi);\n\t\t\tvc.lunp = &v_req_pi.lun[0];\n\t\t\tvc.target = &v_req_pi.lun[1];\n\t\t} else {\n\t\t\tvc.req = &v_req;\n\t\t\tvc.req_size = sizeof(v_req);\n\t\t\tvc.lunp = &v_req.lun[0];\n\t\t\tvc.target = &v_req.lun[1];\n\t\t}\n\n\t\t \n\t\tret = vhost_scsi_chk_size(vq, &vc);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = vhost_scsi_get_req(vq, &vc, &tpg);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tret = -EIO;\t \n\n\t\t \n\t\tprot_bytes = 0;\n\n\t\tif (vc.out_size > vc.req_size) {\n\t\t\tdata_direction = DMA_TO_DEVICE;\n\t\t\texp_data_len = vc.out_size - vc.req_size;\n\t\t\tdata_iter = vc.out_iter;\n\t\t} else if (vc.in_size > vc.rsp_size) {\n\t\t\tdata_direction = DMA_FROM_DEVICE;\n\t\t\texp_data_len = vc.in_size - vc.rsp_size;\n\n\t\t\tiov_iter_init(&in_iter, ITER_DEST, &vq->iov[vc.out], vc.in,\n\t\t\t\t      vc.rsp_size + exp_data_len);\n\t\t\tiov_iter_advance(&in_iter, vc.rsp_size);\n\t\t\tdata_iter = in_iter;\n\t\t} else {\n\t\t\tdata_direction = DMA_NONE;\n\t\t\texp_data_len = 0;\n\t\t}\n\t\t \n\t\tif (t10_pi) {\n\t\t\tif (v_req_pi.pi_bytesout) {\n\t\t\t\tif (data_direction != DMA_TO_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesout,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesout);\n\t\t\t} else if (v_req_pi.pi_bytesin) {\n\t\t\t\tif (data_direction != DMA_FROM_DEVICE) {\n\t\t\t\t\tvq_err(vq, \"Received non zero pi_bytesin,\"\n\t\t\t\t\t\t\" but wrong data_direction\\n\");\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tprot_bytes = vhost32_to_cpu(vq, v_req_pi.pi_bytesin);\n\t\t\t}\n\t\t\t \n\t\t\tif (prot_bytes) {\n\t\t\t\texp_data_len -= prot_bytes;\n\t\t\t\tprot_iter = data_iter;\n\t\t\t\tiov_iter_truncate(&prot_iter, prot_bytes);\n\t\t\t\tiov_iter_advance(&data_iter, prot_bytes);\n\t\t\t}\n\t\t\ttag = vhost64_to_cpu(vq, v_req_pi.tag);\n\t\t\ttask_attr = v_req_pi.task_attr;\n\t\t\tcdb = &v_req_pi.cdb[0];\n\t\t\tlun = vhost_buf_to_lun(v_req_pi.lun);\n\t\t} else {\n\t\t\ttag = vhost64_to_cpu(vq, v_req.tag);\n\t\t\ttask_attr = v_req.task_attr;\n\t\t\tcdb = &v_req.cdb[0];\n\t\t\tlun = vhost_buf_to_lun(v_req.lun);\n\t\t}\n\t\t \n\t\tif (unlikely(scsi_command_size(cdb) > VHOST_SCSI_MAX_CDB_SIZE)) {\n\t\t\tvq_err(vq, \"Received SCSI CDB with command_size: %d that\"\n\t\t\t\t\" exceeds SCSI_MAX_VARLEN_CDB_SIZE: %d\\n\",\n\t\t\t\tscsi_command_size(cdb), VHOST_SCSI_MAX_CDB_SIZE);\n\t\t\t\tgoto err;\n\t\t}\n\t\tcmd = vhost_scsi_get_cmd(vq, tpg, cdb, tag, lun, task_attr,\n\t\t\t\t\t exp_data_len + prot_bytes,\n\t\t\t\t\t data_direction);\n\t\tif (IS_ERR(cmd)) {\n\t\t\tvq_err(vq, \"vhost_scsi_get_cmd failed %ld\\n\",\n\t\t\t       PTR_ERR(cmd));\n\t\t\tgoto err;\n\t\t}\n\t\tcmd->tvc_vhost = vs;\n\t\tcmd->tvc_vq = vq;\n\t\tfor (i = 0; i < vc.in ; i++)\n\t\t\tcmd->tvc_resp_iov[i] = vq->iov[vc.out + i];\n\t\tcmd->tvc_in_iovs = vc.in;\n\n\t\tpr_debug(\"vhost_scsi got command opcode: %#02x, lun: %d\\n\",\n\t\t\t cmd->tvc_cdb[0], cmd->tvc_lun);\n\t\tpr_debug(\"cmd: %p exp_data_len: %d, prot_bytes: %d data_direction:\"\n\t\t\t \" %d\\n\", cmd, exp_data_len, prot_bytes, data_direction);\n\n\t\tif (data_direction != DMA_NONE) {\n\t\t\tif (unlikely(vhost_scsi_mapal(cmd, prot_bytes,\n\t\t\t\t\t\t      &prot_iter, exp_data_len,\n\t\t\t\t\t\t      &data_iter))) {\n\t\t\t\tvq_err(vq, \"Failed to map iov to sgl\\n\");\n\t\t\t\tvhost_scsi_release_cmd_res(&cmd->tvc_se_cmd);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\t\t \n\t\tcmd->tvc_vq_desc = vc.head;\n\t\tvhost_scsi_target_queue_cmd(cmd);\n\t\tret = 0;\nerr:\n\t\t \n\t\tif (ret == -ENXIO)\n\t\t\tbreak;\n\t\telse if (ret == -EIO)\n\t\t\tvhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);\n\t} while (likely(!vhost_exceeds_weight(vq, ++c, 0)));\nout:\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void\nvhost_scsi_send_tmf_resp(struct vhost_scsi *vs, struct vhost_virtqueue *vq,\n\t\t\t int in_iovs, int vq_desc, struct iovec *resp_iov,\n\t\t\t int tmf_resp_code)\n{\n\tstruct virtio_scsi_ctrl_tmf_resp rsp;\n\tstruct iov_iter iov_iter;\n\tint ret;\n\n\tpr_debug(\"%s\\n\", __func__);\n\tmemset(&rsp, 0, sizeof(rsp));\n\trsp.response = tmf_resp_code;\n\n\tiov_iter_init(&iov_iter, ITER_DEST, resp_iov, in_iovs, sizeof(rsp));\n\n\tret = copy_to_iter(&rsp, sizeof(rsp), &iov_iter);\n\tif (likely(ret == sizeof(rsp)))\n\t\tvhost_add_used_and_signal(&vs->dev, vq, vq_desc, 0);\n\telse\n\t\tpr_err(\"Faulted on virtio_scsi_ctrl_tmf_resp\\n\");\n}\n\nstatic void vhost_scsi_tmf_resp_work(struct vhost_work *work)\n{\n\tstruct vhost_scsi_tmf *tmf = container_of(work, struct vhost_scsi_tmf,\n\t\t\t\t\t\t  vwork);\n\tstruct vhost_virtqueue *ctl_vq, *vq;\n\tint resp_code, i;\n\n\tif (tmf->scsi_resp == TMR_FUNCTION_COMPLETE) {\n\t\t \n\t\tctl_vq = &tmf->vhost->vqs[VHOST_SCSI_VQ_CTL].vq;\n\t\tfor (i = VHOST_SCSI_VQ_IO; i < tmf->vhost->dev.nvqs; i++) {\n\t\t\tvq = &tmf->vhost->vqs[i].vq;\n\n\t\t\tif (vhost_vq_is_setup(vq) &&\n\t\t\t    vq->worker != ctl_vq->worker)\n\t\t\t\tvhost_vq_flush(vq);\n\t\t}\n\n\t\tresp_code = VIRTIO_SCSI_S_FUNCTION_SUCCEEDED;\n\t} else {\n\t\tresp_code = VIRTIO_SCSI_S_FUNCTION_REJECTED;\n\t}\n\n\tvhost_scsi_send_tmf_resp(tmf->vhost, &tmf->svq->vq, tmf->in_iovs,\n\t\t\t\t tmf->vq_desc, &tmf->resp_iov, resp_code);\n\tvhost_scsi_release_tmf_res(tmf);\n}\n\nstatic void\nvhost_scsi_handle_tmf(struct vhost_scsi *vs, struct vhost_scsi_tpg *tpg,\n\t\t      struct vhost_virtqueue *vq,\n\t\t      struct virtio_scsi_ctrl_tmf_req *vtmf,\n\t\t      struct vhost_scsi_ctx *vc)\n{\n\tstruct vhost_scsi_virtqueue *svq = container_of(vq,\n\t\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\tstruct vhost_scsi_tmf *tmf;\n\n\tif (vhost32_to_cpu(vq, vtmf->subtype) !=\n\t    VIRTIO_SCSI_T_TMF_LOGICAL_UNIT_RESET)\n\t\tgoto send_reject;\n\n\tif (!tpg->tpg_nexus || !tpg->tpg_nexus->tvn_se_sess) {\n\t\tpr_err(\"Unable to locate active struct vhost_scsi_nexus for LUN RESET.\\n\");\n\t\tgoto send_reject;\n\t}\n\n\ttmf = kzalloc(sizeof(*tmf), GFP_KERNEL);\n\tif (!tmf)\n\t\tgoto send_reject;\n\n\tvhost_work_init(&tmf->vwork, vhost_scsi_tmf_resp_work);\n\ttmf->vhost = vs;\n\ttmf->svq = svq;\n\ttmf->resp_iov = vq->iov[vc->out];\n\ttmf->vq_desc = vc->head;\n\ttmf->in_iovs = vc->in;\n\ttmf->inflight = vhost_scsi_get_inflight(vq);\n\n\tif (target_submit_tmr(&tmf->se_cmd, tpg->tpg_nexus->tvn_se_sess, NULL,\n\t\t\t      vhost_buf_to_lun(vtmf->lun), NULL,\n\t\t\t      TMR_LUN_RESET, GFP_KERNEL, 0,\n\t\t\t      TARGET_SCF_ACK_KREF) < 0) {\n\t\tvhost_scsi_release_tmf_res(tmf);\n\t\tgoto send_reject;\n\t}\n\n\treturn;\n\nsend_reject:\n\tvhost_scsi_send_tmf_resp(vs, vq, vc->in, vc->head, &vq->iov[vc->out],\n\t\t\t\t VIRTIO_SCSI_S_FUNCTION_REJECTED);\n}\n\nstatic void\nvhost_scsi_send_an_resp(struct vhost_scsi *vs,\n\t\t\tstruct vhost_virtqueue *vq,\n\t\t\tstruct vhost_scsi_ctx *vc)\n{\n\tstruct virtio_scsi_ctrl_an_resp rsp;\n\tstruct iov_iter iov_iter;\n\tint ret;\n\n\tpr_debug(\"%s\\n\", __func__);\n\tmemset(&rsp, 0, sizeof(rsp));\t \n\trsp.response = VIRTIO_SCSI_S_OK;\n\n\tiov_iter_init(&iov_iter, ITER_DEST, &vq->iov[vc->out], vc->in, sizeof(rsp));\n\n\tret = copy_to_iter(&rsp, sizeof(rsp), &iov_iter);\n\tif (likely(ret == sizeof(rsp)))\n\t\tvhost_add_used_and_signal(&vs->dev, vq, vc->head, 0);\n\telse\n\t\tpr_err(\"Faulted on virtio_scsi_ctrl_an_resp\\n\");\n}\n\nstatic void\nvhost_scsi_ctl_handle_vq(struct vhost_scsi *vs, struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_tpg *tpg;\n\tunion {\n\t\t__virtio32 type;\n\t\tstruct virtio_scsi_ctrl_an_req an;\n\t\tstruct virtio_scsi_ctrl_tmf_req tmf;\n\t} v_req;\n\tstruct vhost_scsi_ctx vc;\n\tsize_t typ_size;\n\tint ret, c = 0;\n\n\tmutex_lock(&vq->mutex);\n\t \n\tif (!vhost_vq_get_backend(vq))\n\t\tgoto out;\n\n\tmemset(&vc, 0, sizeof(vc));\n\n\tvhost_disable_notify(&vs->dev, vq);\n\n\tdo {\n\t\tret = vhost_scsi_get_desc(vs, vq, &vc);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tvc.req = &v_req.type;\n\t\ttyp_size = sizeof(v_req.type);\n\n\t\tif (unlikely(!copy_from_iter_full(vc.req, typ_size,\n\t\t\t\t\t\t  &vc.out_iter))) {\n\t\t\tvq_err(vq, \"Faulted on copy_from_iter tmf type\\n\");\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (vhost32_to_cpu(vq, v_req.type)) {\n\t\tcase VIRTIO_SCSI_T_TMF:\n\t\t\tvc.req = &v_req.tmf;\n\t\t\tvc.req_size = sizeof(struct virtio_scsi_ctrl_tmf_req);\n\t\t\tvc.rsp_size = sizeof(struct virtio_scsi_ctrl_tmf_resp);\n\t\t\tvc.lunp = &v_req.tmf.lun[0];\n\t\t\tvc.target = &v_req.tmf.lun[1];\n\t\t\tbreak;\n\t\tcase VIRTIO_SCSI_T_AN_QUERY:\n\t\tcase VIRTIO_SCSI_T_AN_SUBSCRIBE:\n\t\t\tvc.req = &v_req.an;\n\t\t\tvc.req_size = sizeof(struct virtio_scsi_ctrl_an_req);\n\t\t\tvc.rsp_size = sizeof(struct virtio_scsi_ctrl_an_resp);\n\t\t\tvc.lunp = &v_req.an.lun[0];\n\t\t\tvc.target = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvq_err(vq, \"Unknown control request %d\", v_req.type);\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tret = vhost_scsi_chk_size(vq, &vc);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\tvc.req += typ_size;\n\t\tvc.req_size -= typ_size;\n\n\t\tret = vhost_scsi_get_req(vq, &vc, &tpg);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (v_req.type == VIRTIO_SCSI_T_TMF)\n\t\t\tvhost_scsi_handle_tmf(vs, tpg, vq, &v_req.tmf, &vc);\n\t\telse\n\t\t\tvhost_scsi_send_an_resp(vs, vq, &vc);\nerr:\n\t\t \n\t\tif (ret == -ENXIO)\n\t\t\tbreak;\n\t\telse if (ret == -EIO)\n\t\t\tvhost_scsi_send_bad_target(vs, vq, vc.head, vc.out);\n\t} while (likely(!vhost_exceeds_weight(vq, ++c, 0)));\nout:\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void vhost_scsi_ctl_handle_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\tpoll.work);\n\tstruct vhost_scsi *vs = container_of(vq->dev, struct vhost_scsi, dev);\n\n\tpr_debug(\"%s: The handling func for control queue.\\n\", __func__);\n\tvhost_scsi_ctl_handle_vq(vs, vq);\n}\n\nstatic void\nvhost_scsi_send_evt(struct vhost_scsi *vs, struct vhost_virtqueue *vq,\n\t\t    struct vhost_scsi_tpg *tpg, struct se_lun *lun,\n\t\t    u32 event, u32 reason)\n{\n\tstruct vhost_scsi_evt *evt;\n\n\tevt = vhost_scsi_allocate_evt(vs, event, reason);\n\tif (!evt)\n\t\treturn;\n\n\tif (tpg && lun) {\n\t\t \n\t\t \n\t\tevt->event.lun[0] = 0x01;\n\t\tevt->event.lun[1] = tpg->tport_tpgt;\n\t\tif (lun->unpacked_lun >= 256)\n\t\t\tevt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;\n\t\tevt->event.lun[3] = lun->unpacked_lun & 0xFF;\n\t}\n\n\tllist_add(&evt->list, &vs->vs_event_list);\n\tvhost_vq_work_queue(vq, &vs->vs_event_work);\n}\n\nstatic void vhost_scsi_evt_handle_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\tpoll.work);\n\tstruct vhost_scsi *vs = container_of(vq->dev, struct vhost_scsi, dev);\n\n\tmutex_lock(&vq->mutex);\n\tif (!vhost_vq_get_backend(vq))\n\t\tgoto out;\n\n\tif (vs->vs_events_missed)\n\t\tvhost_scsi_send_evt(vs, vq, NULL, NULL, VIRTIO_SCSI_T_NO_EVENT,\n\t\t\t\t    0);\nout:\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void vhost_scsi_handle_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\tpoll.work);\n\tstruct vhost_scsi *vs = container_of(vq->dev, struct vhost_scsi, dev);\n\n\tvhost_scsi_handle_vq(vs, vq);\n}\n\n \nstatic void vhost_scsi_flush(struct vhost_scsi *vs)\n{\n\tint i;\n\n\t \n\tvhost_scsi_init_inflight(vs, vs->old_inflight);\n\n\t \n\tfor (i = 0; i < vs->dev.nvqs; i++)\n\t\tkref_put(&vs->old_inflight[i]->kref, vhost_scsi_done_inflight);\n\n\t \n\tvhost_dev_flush(&vs->dev);\n\n\t \n\tfor (i = 0; i < vs->dev.nvqs; i++)\n\t\twait_for_completion(&vs->old_inflight[i]->comp);\n}\n\nstatic void vhost_scsi_destroy_vq_cmds(struct vhost_virtqueue *vq)\n{\n\tstruct vhost_scsi_virtqueue *svq = container_of(vq,\n\t\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\tstruct vhost_scsi_cmd *tv_cmd;\n\tunsigned int i;\n\n\tif (!svq->scsi_cmds)\n\t\treturn;\n\n\tfor (i = 0; i < svq->max_cmds; i++) {\n\t\ttv_cmd = &svq->scsi_cmds[i];\n\n\t\tkfree(tv_cmd->tvc_sgl);\n\t\tkfree(tv_cmd->tvc_prot_sgl);\n\t\tkfree(tv_cmd->tvc_upages);\n\t\tkfree(tv_cmd->tvc_resp_iov);\n\t}\n\n\tsbitmap_free(&svq->scsi_tags);\n\tkfree(svq->scsi_cmds);\n\tsvq->scsi_cmds = NULL;\n}\n\nstatic int vhost_scsi_setup_vq_cmds(struct vhost_virtqueue *vq, int max_cmds)\n{\n\tstruct vhost_scsi_virtqueue *svq = container_of(vq,\n\t\t\t\t\tstruct vhost_scsi_virtqueue, vq);\n\tstruct vhost_scsi_cmd *tv_cmd;\n\tunsigned int i;\n\n\tif (svq->scsi_cmds)\n\t\treturn 0;\n\n\tif (sbitmap_init_node(&svq->scsi_tags, max_cmds, -1, GFP_KERNEL,\n\t\t\t      NUMA_NO_NODE, false, true))\n\t\treturn -ENOMEM;\n\tsvq->max_cmds = max_cmds;\n\n\tsvq->scsi_cmds = kcalloc(max_cmds, sizeof(*tv_cmd), GFP_KERNEL);\n\tif (!svq->scsi_cmds) {\n\t\tsbitmap_free(&svq->scsi_tags);\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < max_cmds; i++) {\n\t\ttv_cmd = &svq->scsi_cmds[i];\n\n\t\ttv_cmd->tvc_sgl = kcalloc(VHOST_SCSI_PREALLOC_SGLS,\n\t\t\t\t\t  sizeof(struct scatterlist),\n\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!tv_cmd->tvc_sgl) {\n\t\t\tpr_err(\"Unable to allocate tv_cmd->tvc_sgl\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ttv_cmd->tvc_upages = kcalloc(VHOST_SCSI_PREALLOC_UPAGES,\n\t\t\t\t\t     sizeof(struct page *),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!tv_cmd->tvc_upages) {\n\t\t\tpr_err(\"Unable to allocate tv_cmd->tvc_upages\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ttv_cmd->tvc_resp_iov = kcalloc(UIO_MAXIOV,\n\t\t\t\t\t       sizeof(struct iovec),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!tv_cmd->tvc_resp_iov) {\n\t\t\tpr_err(\"Unable to allocate tv_cmd->tvc_resp_iov\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\ttv_cmd->tvc_prot_sgl = kcalloc(VHOST_SCSI_PREALLOC_PROT_SGLS,\n\t\t\t\t\t       sizeof(struct scatterlist),\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!tv_cmd->tvc_prot_sgl) {\n\t\t\tpr_err(\"Unable to allocate tv_cmd->tvc_prot_sgl\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\treturn 0;\nout:\n\tvhost_scsi_destroy_vq_cmds(vq);\n\treturn -ENOMEM;\n}\n\n \nstatic int\nvhost_scsi_set_endpoint(struct vhost_scsi *vs,\n\t\t\tstruct vhost_scsi_target *t)\n{\n\tstruct se_portal_group *se_tpg;\n\tstruct vhost_scsi_tport *tv_tport;\n\tstruct vhost_scsi_tpg *tpg;\n\tstruct vhost_scsi_tpg **vs_tpg;\n\tstruct vhost_virtqueue *vq;\n\tint index, ret, i, len;\n\tbool match = false;\n\n\tmutex_lock(&vs->dev.mutex);\n\n\t \n\tfor (index = 0; index < vs->dev.nvqs; ++index) {\n\t\t \n\t\tif (!vhost_vq_access_ok(&vs->vqs[index].vq)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlen = sizeof(vs_tpg[0]) * VHOST_SCSI_MAX_TARGET;\n\tvs_tpg = kzalloc(len, GFP_KERNEL);\n\tif (!vs_tpg) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tif (vs->vs_tpg)\n\t\tmemcpy(vs_tpg, vs->vs_tpg, len);\n\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_for_each_entry(tpg, &vhost_scsi_list, tv_tpg_list) {\n\t\tmutex_lock(&tpg->tv_tpg_mutex);\n\t\tif (!tpg->tpg_nexus) {\n\t\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\tif (tpg->tv_tpg_vhost_count != 0) {\n\t\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\t\tcontinue;\n\t\t}\n\t\ttv_tport = tpg->tport;\n\n\t\tif (!strcmp(tv_tport->tport_name, t->vhost_wwpn)) {\n\t\t\tif (vs->vs_tpg && vs->vs_tpg[tpg->tport_tpgt]) {\n\t\t\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\t\t\tmutex_unlock(&vhost_scsi_mutex);\n\t\t\t\tret = -EEXIST;\n\t\t\t\tgoto undepend;\n\t\t\t}\n\t\t\t \n\t\t\tse_tpg = &tpg->se_tpg;\n\t\t\tret = target_depend_item(&se_tpg->tpg_group.cg_item);\n\t\t\tif (ret) {\n\t\t\t\tpr_warn(\"target_depend_item() failed: %d\\n\", ret);\n\t\t\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\t\t\tmutex_unlock(&vhost_scsi_mutex);\n\t\t\t\tgoto undepend;\n\t\t\t}\n\t\t\ttpg->tv_tpg_vhost_count++;\n\t\t\ttpg->vhost_scsi = vs;\n\t\t\tvs_tpg[tpg->tport_tpgt] = tpg;\n\t\t\tmatch = true;\n\t\t}\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t}\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\tif (match) {\n\t\tmemcpy(vs->vs_vhost_wwpn, t->vhost_wwpn,\n\t\t       sizeof(vs->vs_vhost_wwpn));\n\n\t\tfor (i = VHOST_SCSI_VQ_IO; i < vs->dev.nvqs; i++) {\n\t\t\tvq = &vs->vqs[i].vq;\n\t\t\tif (!vhost_vq_is_setup(vq))\n\t\t\t\tcontinue;\n\n\t\t\tret = vhost_scsi_setup_vq_cmds(vq, vq->num);\n\t\t\tif (ret)\n\t\t\t\tgoto destroy_vq_cmds;\n\t\t}\n\n\t\tfor (i = 0; i < vs->dev.nvqs; i++) {\n\t\t\tvq = &vs->vqs[i].vq;\n\t\t\tmutex_lock(&vq->mutex);\n\t\t\tvhost_vq_set_backend(vq, vs_tpg);\n\t\t\tvhost_vq_init_access(vq);\n\t\t\tmutex_unlock(&vq->mutex);\n\t\t}\n\t\tret = 0;\n\t} else {\n\t\tret = -EEXIST;\n\t}\n\n\t \n\tvhost_scsi_flush(vs);\n\tkfree(vs->vs_tpg);\n\tvs->vs_tpg = vs_tpg;\n\tgoto out;\n\ndestroy_vq_cmds:\n\tfor (i--; i >= VHOST_SCSI_VQ_IO; i--) {\n\t\tif (!vhost_vq_get_backend(&vs->vqs[i].vq))\n\t\t\tvhost_scsi_destroy_vq_cmds(&vs->vqs[i].vq);\n\t}\nundepend:\n\tfor (i = 0; i < VHOST_SCSI_MAX_TARGET; i++) {\n\t\ttpg = vs_tpg[i];\n\t\tif (tpg) {\n\t\t\tmutex_lock(&tpg->tv_tpg_mutex);\n\t\t\ttpg->vhost_scsi = NULL;\n\t\t\ttpg->tv_tpg_vhost_count--;\n\t\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\t\ttarget_undepend_item(&tpg->se_tpg.tpg_group.cg_item);\n\t\t}\n\t}\n\tkfree(vs_tpg);\nout:\n\tmutex_unlock(&vs->dev.mutex);\n\treturn ret;\n}\n\nstatic int\nvhost_scsi_clear_endpoint(struct vhost_scsi *vs,\n\t\t\t  struct vhost_scsi_target *t)\n{\n\tstruct se_portal_group *se_tpg;\n\tstruct vhost_scsi_tport *tv_tport;\n\tstruct vhost_scsi_tpg *tpg;\n\tstruct vhost_virtqueue *vq;\n\tbool match = false;\n\tint index, ret, i;\n\tu8 target;\n\n\tmutex_lock(&vs->dev.mutex);\n\t \n\tfor (index = 0; index < vs->dev.nvqs; ++index) {\n\t\tif (!vhost_vq_access_ok(&vs->vqs[index].vq)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err_dev;\n\t\t}\n\t}\n\n\tif (!vs->vs_tpg) {\n\t\tret = 0;\n\t\tgoto err_dev;\n\t}\n\n\tfor (i = 0; i < VHOST_SCSI_MAX_TARGET; i++) {\n\t\ttarget = i;\n\t\ttpg = vs->vs_tpg[target];\n\t\tif (!tpg)\n\t\t\tcontinue;\n\n\t\ttv_tport = tpg->tport;\n\t\tif (!tv_tport) {\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_dev;\n\t\t}\n\n\t\tif (strcmp(tv_tport->tport_name, t->vhost_wwpn)) {\n\t\t\tpr_warn(\"tv_tport->tport_name: %s, tpg->tport_tpgt: %hu\"\n\t\t\t\t\" does not match t->vhost_wwpn: %s, t->vhost_tpgt: %hu\\n\",\n\t\t\t\ttv_tport->tport_name, tpg->tport_tpgt,\n\t\t\t\tt->vhost_wwpn, t->vhost_tpgt);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_dev;\n\t\t}\n\t\tmatch = true;\n\t}\n\tif (!match)\n\t\tgoto free_vs_tpg;\n\n\t \n\tfor (i = 0; i < vs->dev.nvqs; i++) {\n\t\tvq = &vs->vqs[i].vq;\n\t\tmutex_lock(&vq->mutex);\n\t\tvhost_vq_set_backend(vq, NULL);\n\t\tmutex_unlock(&vq->mutex);\n\t}\n\t \n\tvhost_scsi_flush(vs);\n\n\tfor (i = 0; i < vs->dev.nvqs; i++) {\n\t\tvq = &vs->vqs[i].vq;\n\t\tvhost_scsi_destroy_vq_cmds(vq);\n\t}\n\n\t \n\tfor (i = 0; i < VHOST_SCSI_MAX_TARGET; i++) {\n\t\ttarget = i;\n\t\ttpg = vs->vs_tpg[target];\n\t\tif (!tpg)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&tpg->tv_tpg_mutex);\n\n\t\ttpg->tv_tpg_vhost_count--;\n\t\ttpg->vhost_scsi = NULL;\n\t\tvs->vs_tpg[target] = NULL;\n\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\t\tse_tpg = &tpg->se_tpg;\n\t\ttarget_undepend_item(&se_tpg->tpg_group.cg_item);\n\t}\n\nfree_vs_tpg:\n\t \n\tvhost_scsi_flush(vs);\n\tkfree(vs->vs_tpg);\n\tvs->vs_tpg = NULL;\n\tWARN_ON(vs->vs_events_nr);\n\tmutex_unlock(&vs->dev.mutex);\n\treturn 0;\n\nerr_dev:\n\tmutex_unlock(&vs->dev.mutex);\n\treturn ret;\n}\n\nstatic int vhost_scsi_set_features(struct vhost_scsi *vs, u64 features)\n{\n\tstruct vhost_virtqueue *vq;\n\tint i;\n\n\tif (features & ~VHOST_SCSI_FEATURES)\n\t\treturn -EOPNOTSUPP;\n\n\tmutex_lock(&vs->dev.mutex);\n\tif ((features & (1 << VHOST_F_LOG_ALL)) &&\n\t    !vhost_log_access_ok(&vs->dev)) {\n\t\tmutex_unlock(&vs->dev.mutex);\n\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < vs->dev.nvqs; i++) {\n\t\tvq = &vs->vqs[i].vq;\n\t\tmutex_lock(&vq->mutex);\n\t\tvq->acked_features = features;\n\t\tmutex_unlock(&vq->mutex);\n\t}\n\tmutex_unlock(&vs->dev.mutex);\n\treturn 0;\n}\n\nstatic int vhost_scsi_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_scsi_virtqueue *svq;\n\tstruct vhost_scsi *vs;\n\tstruct vhost_virtqueue **vqs;\n\tint r = -ENOMEM, i, nvqs = vhost_scsi_max_io_vqs;\n\n\tvs = kvzalloc(sizeof(*vs), GFP_KERNEL);\n\tif (!vs)\n\t\tgoto err_vs;\n\n\tif (nvqs > VHOST_SCSI_MAX_IO_VQ) {\n\t\tpr_err(\"Invalid max_io_vqs of %d. Using %d.\\n\", nvqs,\n\t\t       VHOST_SCSI_MAX_IO_VQ);\n\t\tnvqs = VHOST_SCSI_MAX_IO_VQ;\n\t} else if (nvqs == 0) {\n\t\tpr_err(\"Invalid max_io_vqs of %d. Using 1.\\n\", nvqs);\n\t\tnvqs = 1;\n\t}\n\tnvqs += VHOST_SCSI_VQ_IO;\n\n\tvs->old_inflight = kmalloc_array(nvqs, sizeof(*vs->old_inflight),\n\t\t\t\t\t GFP_KERNEL | __GFP_ZERO);\n\tif (!vs->old_inflight)\n\t\tgoto err_inflight;\n\n\tvs->vqs = kmalloc_array(nvqs, sizeof(*vs->vqs),\n\t\t\t\tGFP_KERNEL | __GFP_ZERO);\n\tif (!vs->vqs)\n\t\tgoto err_vqs;\n\n\tvqs = kmalloc_array(nvqs, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs)\n\t\tgoto err_local_vqs;\n\n\tvhost_work_init(&vs->vs_event_work, vhost_scsi_evt_work);\n\n\tvs->vs_events_nr = 0;\n\tvs->vs_events_missed = false;\n\n\tvqs[VHOST_SCSI_VQ_CTL] = &vs->vqs[VHOST_SCSI_VQ_CTL].vq;\n\tvqs[VHOST_SCSI_VQ_EVT] = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tvs->vqs[VHOST_SCSI_VQ_CTL].vq.handle_kick = vhost_scsi_ctl_handle_kick;\n\tvs->vqs[VHOST_SCSI_VQ_EVT].vq.handle_kick = vhost_scsi_evt_handle_kick;\n\tfor (i = VHOST_SCSI_VQ_IO; i < nvqs; i++) {\n\t\tsvq = &vs->vqs[i];\n\n\t\tvqs[i] = &svq->vq;\n\t\tsvq->vs = vs;\n\t\tinit_llist_head(&svq->completion_list);\n\t\tvhost_work_init(&svq->completion_work,\n\t\t\t\tvhost_scsi_complete_cmd_work);\n\t\tsvq->vq.handle_kick = vhost_scsi_handle_kick;\n\t}\n\tvhost_dev_init(&vs->dev, vqs, nvqs, UIO_MAXIOV,\n\t\t       VHOST_SCSI_WEIGHT, 0, true, NULL);\n\n\tvhost_scsi_init_inflight(vs, NULL);\n\n\tf->private_data = vs;\n\treturn 0;\n\nerr_local_vqs:\n\tkfree(vs->vqs);\nerr_vqs:\n\tkfree(vs->old_inflight);\nerr_inflight:\n\tkvfree(vs);\nerr_vs:\n\treturn r;\n}\n\nstatic int vhost_scsi_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_scsi *vs = f->private_data;\n\tstruct vhost_scsi_target t;\n\n\tmutex_lock(&vs->dev.mutex);\n\tmemcpy(t.vhost_wwpn, vs->vs_vhost_wwpn, sizeof(t.vhost_wwpn));\n\tmutex_unlock(&vs->dev.mutex);\n\tvhost_scsi_clear_endpoint(vs, &t);\n\tvhost_dev_stop(&vs->dev);\n\tvhost_dev_cleanup(&vs->dev);\n\tkfree(vs->dev.vqs);\n\tkfree(vs->vqs);\n\tkfree(vs->old_inflight);\n\tkvfree(vs);\n\treturn 0;\n}\n\nstatic long\nvhost_scsi_ioctl(struct file *f,\n\t\t unsigned int ioctl,\n\t\t unsigned long arg)\n{\n\tstruct vhost_scsi *vs = f->private_data;\n\tstruct vhost_scsi_target backend;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tu32 __user *eventsp = argp;\n\tu32 events_missed;\n\tu64 features;\n\tint r, abi_version = VHOST_SCSI_ABI_VERSION;\n\tstruct vhost_virtqueue *vq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\n\tswitch (ioctl) {\n\tcase VHOST_SCSI_SET_ENDPOINT:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\tif (backend.reserved != 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn vhost_scsi_set_endpoint(vs, &backend);\n\tcase VHOST_SCSI_CLEAR_ENDPOINT:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\tif (backend.reserved != 0)\n\t\t\treturn -EOPNOTSUPP;\n\n\t\treturn vhost_scsi_clear_endpoint(vs, &backend);\n\tcase VHOST_SCSI_GET_ABI_VERSION:\n\t\tif (copy_to_user(argp, &abi_version, sizeof abi_version))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SCSI_SET_EVENTS_MISSED:\n\t\tif (get_user(events_missed, eventsp))\n\t\t\treturn -EFAULT;\n\t\tmutex_lock(&vq->mutex);\n\t\tvs->vs_events_missed = events_missed;\n\t\tmutex_unlock(&vq->mutex);\n\t\treturn 0;\n\tcase VHOST_SCSI_GET_EVENTS_MISSED:\n\t\tmutex_lock(&vq->mutex);\n\t\tevents_missed = vs->vs_events_missed;\n\t\tmutex_unlock(&vq->mutex);\n\t\tif (put_user(events_missed, eventsp))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_SCSI_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_scsi_set_features(vs, features);\n\tcase VHOST_NEW_WORKER:\n\tcase VHOST_FREE_WORKER:\n\tcase VHOST_ATTACH_VRING_WORKER:\n\tcase VHOST_GET_VRING_WORKER:\n\t\tmutex_lock(&vs->dev.mutex);\n\t\tr = vhost_worker_ioctl(&vs->dev, ioctl, argp);\n\t\tmutex_unlock(&vs->dev.mutex);\n\t\treturn r;\n\tdefault:\n\t\tmutex_lock(&vs->dev.mutex);\n\t\tr = vhost_dev_ioctl(&vs->dev, ioctl, argp);\n\t\t \n\t\tif (r == -ENOIOCTLCMD)\n\t\t\tr = vhost_vring_ioctl(&vs->dev, ioctl, argp);\n\t\tmutex_unlock(&vs->dev.mutex);\n\t\treturn r;\n\t}\n}\n\nstatic const struct file_operations vhost_scsi_fops = {\n\t.owner          = THIS_MODULE,\n\t.release        = vhost_scsi_release,\n\t.unlocked_ioctl = vhost_scsi_ioctl,\n\t.compat_ioctl\t= compat_ptr_ioctl,\n\t.open           = vhost_scsi_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice vhost_scsi_misc = {\n\tMISC_DYNAMIC_MINOR,\n\t\"vhost-scsi\",\n\t&vhost_scsi_fops,\n};\n\nstatic int __init vhost_scsi_register(void)\n{\n\treturn misc_register(&vhost_scsi_misc);\n}\n\nstatic void vhost_scsi_deregister(void)\n{\n\tmisc_deregister(&vhost_scsi_misc);\n}\n\nstatic char *vhost_scsi_dump_proto_id(struct vhost_scsi_tport *tport)\n{\n\tswitch (tport->tport_proto_id) {\n\tcase SCSI_PROTOCOL_SAS:\n\t\treturn \"SAS\";\n\tcase SCSI_PROTOCOL_FCP:\n\t\treturn \"FCP\";\n\tcase SCSI_PROTOCOL_ISCSI:\n\t\treturn \"iSCSI\";\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn \"Unknown\";\n}\n\nstatic void\nvhost_scsi_do_plug(struct vhost_scsi_tpg *tpg,\n\t\t  struct se_lun *lun, bool plug)\n{\n\n\tstruct vhost_scsi *vs = tpg->vhost_scsi;\n\tstruct vhost_virtqueue *vq;\n\tu32 reason;\n\n\tif (!vs)\n\t\treturn;\n\n\tif (plug)\n\t\treason = VIRTIO_SCSI_EVT_RESET_RESCAN;\n\telse\n\t\treason = VIRTIO_SCSI_EVT_RESET_REMOVED;\n\n\tvq = &vs->vqs[VHOST_SCSI_VQ_EVT].vq;\n\tmutex_lock(&vq->mutex);\n\t \n\tif (!vhost_vq_get_backend(vq))\n\t\tgoto unlock;\n\n\tif (vhost_has_feature(vq, VIRTIO_SCSI_F_HOTPLUG))\n\t\tvhost_scsi_send_evt(vs, vq, tpg, lun,\n\t\t\t\t   VIRTIO_SCSI_T_TRANSPORT_RESET, reason);\nunlock:\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void vhost_scsi_hotplug(struct vhost_scsi_tpg *tpg, struct se_lun *lun)\n{\n\tvhost_scsi_do_plug(tpg, lun, true);\n}\n\nstatic void vhost_scsi_hotunplug(struct vhost_scsi_tpg *tpg, struct se_lun *lun)\n{\n\tvhost_scsi_do_plug(tpg, lun, false);\n}\n\nstatic int vhost_scsi_port_link(struct se_portal_group *se_tpg,\n\t\t\t       struct se_lun *lun)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_port_count++;\n\tvhost_scsi_hotplug(tpg, lun);\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn 0;\n}\n\nstatic void vhost_scsi_port_unlink(struct se_portal_group *se_tpg,\n\t\t\t\t  struct se_lun *lun)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttpg->tv_tpg_port_count--;\n\tvhost_scsi_hotunplug(tpg, lun);\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n}\n\nstatic ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_store(\n\t\tstruct config_item *item, const char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tunsigned long val;\n\tint ret = kstrtoul(page, 0, &val);\n\n\tif (ret) {\n\t\tpr_err(\"kstrtoul() returned %d for fabric_prot_type\\n\", ret);\n\t\treturn ret;\n\t}\n\tif (val != 0 && val != 1 && val != 3) {\n\t\tpr_err(\"Invalid vhost_scsi fabric_prot_type: %lu\\n\", val);\n\t\treturn -EINVAL;\n\t}\n\ttpg->tv_fabric_prot_type = val;\n\n\treturn count;\n}\n\nstatic ssize_t vhost_scsi_tpg_attrib_fabric_prot_type_show(\n\t\tstruct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = attrib_to_tpg(item);\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\treturn sysfs_emit(page, \"%d\\n\", tpg->tv_fabric_prot_type);\n}\n\nCONFIGFS_ATTR(vhost_scsi_tpg_attrib_, fabric_prot_type);\n\nstatic struct configfs_attribute *vhost_scsi_tpg_attrib_attrs[] = {\n\t&vhost_scsi_tpg_attrib_attr_fabric_prot_type,\n\tNULL,\n};\n\nstatic int vhost_scsi_make_nexus(struct vhost_scsi_tpg *tpg,\n\t\t\t\tconst char *name)\n{\n\tstruct vhost_scsi_nexus *tv_nexus;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\tif (tpg->tpg_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_debug(\"tpg->tpg_nexus already exists\\n\");\n\t\treturn -EEXIST;\n\t}\n\n\ttv_nexus = kzalloc(sizeof(*tv_nexus), GFP_KERNEL);\n\tif (!tv_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_nexus\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\ttv_nexus->tvn_se_sess = target_setup_session(&tpg->se_tpg, 0, 0,\n\t\t\t\t\tTARGET_PROT_DIN_PASS | TARGET_PROT_DOUT_PASS,\n\t\t\t\t\t(unsigned char *)name, tv_nexus, NULL);\n\tif (IS_ERR(tv_nexus->tvn_se_sess)) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tkfree(tv_nexus);\n\t\treturn -ENOMEM;\n\t}\n\ttpg->tpg_nexus = tv_nexus;\n\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\treturn 0;\n}\n\nstatic int vhost_scsi_drop_nexus(struct vhost_scsi_tpg *tpg)\n{\n\tstruct se_session *se_sess;\n\tstruct vhost_scsi_nexus *tv_nexus;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tse_sess = tv_nexus->tvn_se_sess;\n\tif (!se_sess) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tif (tpg->tv_tpg_port_count != 0) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_err(\"Unable to remove TCM_vhost I_T Nexus with\"\n\t\t\t\" active TPG port count: %d\\n\",\n\t\t\ttpg->tv_tpg_port_count);\n\t\treturn -EBUSY;\n\t}\n\n\tif (tpg->tv_tpg_vhost_count != 0) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\tpr_err(\"Unable to remove TCM_vhost I_T Nexus with\"\n\t\t\t\" active TPG vhost count: %d\\n\",\n\t\t\ttpg->tv_tpg_vhost_count);\n\t\treturn -EBUSY;\n\t}\n\n\tpr_debug(\"TCM_vhost_ConfigFS: Removing I_T Nexus to emulated\"\n\t\t\" %s Initiator Port: %s\\n\", vhost_scsi_dump_proto_id(tpg->tport),\n\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\n\n\t \n\ttarget_remove_session(se_sess);\n\ttpg->tpg_nexus = NULL;\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\tkfree(tv_nexus);\n\treturn 0;\n}\n\nstatic ssize_t vhost_scsi_tpg_nexus_show(struct config_item *item, char *page)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_nexus *tv_nexus;\n\tssize_t ret;\n\n\tmutex_lock(&tpg->tv_tpg_mutex);\n\ttv_nexus = tpg->tpg_nexus;\n\tif (!tv_nexus) {\n\t\tmutex_unlock(&tpg->tv_tpg_mutex);\n\t\treturn -ENODEV;\n\t}\n\tret = sysfs_emit(page, \"%s\\n\",\n\t\t\ttv_nexus->tvn_se_sess->se_node_acl->initiatorname);\n\tmutex_unlock(&tpg->tv_tpg_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t vhost_scsi_tpg_nexus_store(struct config_item *item,\n\t\tconst char *page, size_t count)\n{\n\tstruct se_portal_group *se_tpg = to_tpg(item);\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\tstruct vhost_scsi_tport *tport_wwn = tpg->tport;\n\tunsigned char i_port[VHOST_SCSI_NAMELEN], *ptr, *port_ptr;\n\tint ret;\n\t \n\tif (!strncmp(page, \"NULL\", 4)) {\n\t\tret = vhost_scsi_drop_nexus(tpg);\n\t\treturn (!ret) ? count : ret;\n\t}\n\t \n\tif (strlen(page) >= VHOST_SCSI_NAMELEN) {\n\t\tpr_err(\"Emulated NAA Sas Address: %s, exceeds\"\n\t\t\t\t\" max: %d\\n\", page, VHOST_SCSI_NAMELEN);\n\t\treturn -EINVAL;\n\t}\n\tsnprintf(&i_port[0], VHOST_SCSI_NAMELEN, \"%s\", page);\n\n\tptr = strstr(i_port, \"naa.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_SAS) {\n\t\t\tpr_err(\"Passed SAS Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\tvhost_scsi_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"fc.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_FCP) {\n\t\t\tpr_err(\"Passed FCP Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\tvhost_scsi_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[3];  \n\t\tgoto check_newline;\n\t}\n\tptr = strstr(i_port, \"iqn.\");\n\tif (ptr) {\n\t\tif (tport_wwn->tport_proto_id != SCSI_PROTOCOL_ISCSI) {\n\t\t\tpr_err(\"Passed iSCSI Initiator Port %s does not\"\n\t\t\t\t\" match target port protoid: %s\\n\", i_port,\n\t\t\t\tvhost_scsi_dump_proto_id(tport_wwn));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tport_ptr = &i_port[0];\n\t\tgoto check_newline;\n\t}\n\tpr_err(\"Unable to locate prefix for emulated Initiator Port:\"\n\t\t\t\" %s\\n\", i_port);\n\treturn -EINVAL;\n\t \ncheck_newline:\n\tif (i_port[strlen(i_port)-1] == '\\n')\n\t\ti_port[strlen(i_port)-1] = '\\0';\n\n\tret = vhost_scsi_make_nexus(tpg, port_ptr);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\n\nCONFIGFS_ATTR(vhost_scsi_tpg_, nexus);\n\nstatic struct configfs_attribute *vhost_scsi_tpg_attrs[] = {\n\t&vhost_scsi_tpg_attr_nexus,\n\tNULL,\n};\n\nstatic struct se_portal_group *\nvhost_scsi_make_tpg(struct se_wwn *wwn, const char *name)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tstruct vhost_scsi_tpg *tpg;\n\tu16 tpgt;\n\tint ret;\n\n\tif (strstr(name, \"tpgt_\") != name)\n\t\treturn ERR_PTR(-EINVAL);\n\tif (kstrtou16(name + 5, 10, &tpgt) || tpgt >= VHOST_SCSI_MAX_TARGET)\n\t\treturn ERR_PTR(-EINVAL);\n\n\ttpg = kzalloc(sizeof(*tpg), GFP_KERNEL);\n\tif (!tpg) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tpg\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tmutex_init(&tpg->tv_tpg_mutex);\n\tINIT_LIST_HEAD(&tpg->tv_tpg_list);\n\ttpg->tport = tport;\n\ttpg->tport_tpgt = tpgt;\n\n\tret = core_tpg_register(wwn, &tpg->se_tpg, tport->tport_proto_id);\n\tif (ret < 0) {\n\t\tkfree(tpg);\n\t\treturn NULL;\n\t}\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\n\treturn &tpg->se_tpg;\n}\n\nstatic void vhost_scsi_drop_tpg(struct se_portal_group *se_tpg)\n{\n\tstruct vhost_scsi_tpg *tpg = container_of(se_tpg,\n\t\t\t\tstruct vhost_scsi_tpg, se_tpg);\n\n\tmutex_lock(&vhost_scsi_mutex);\n\tlist_del(&tpg->tv_tpg_list);\n\tmutex_unlock(&vhost_scsi_mutex);\n\t \n\tvhost_scsi_drop_nexus(tpg);\n\t \n\tcore_tpg_deregister(se_tpg);\n\tkfree(tpg);\n}\n\nstatic struct se_wwn *\nvhost_scsi_make_tport(struct target_fabric_configfs *tf,\n\t\t     struct config_group *group,\n\t\t     const char *name)\n{\n\tstruct vhost_scsi_tport *tport;\n\tchar *ptr;\n\tu64 wwpn = 0;\n\tint off = 0;\n\n\t \n\n\ttport = kzalloc(sizeof(*tport), GFP_KERNEL);\n\tif (!tport) {\n\t\tpr_err(\"Unable to allocate struct vhost_scsi_tport\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\ttport->tport_wwpn = wwpn;\n\t \n\tptr = strstr(name, \"naa.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_SAS;\n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"fc.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_FCP;\n\t\toff = 3;  \n\t\tgoto check_len;\n\t}\n\tptr = strstr(name, \"iqn.\");\n\tif (ptr) {\n\t\ttport->tport_proto_id = SCSI_PROTOCOL_ISCSI;\n\t\tgoto check_len;\n\t}\n\n\tpr_err(\"Unable to locate prefix for emulated Target Port:\"\n\t\t\t\" %s\\n\", name);\n\tkfree(tport);\n\treturn ERR_PTR(-EINVAL);\n\ncheck_len:\n\tif (strlen(name) >= VHOST_SCSI_NAMELEN) {\n\t\tpr_err(\"Emulated %s Address: %s, exceeds\"\n\t\t\t\" max: %d\\n\", name, vhost_scsi_dump_proto_id(tport),\n\t\t\tVHOST_SCSI_NAMELEN);\n\t\tkfree(tport);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tsnprintf(&tport->tport_name[0], VHOST_SCSI_NAMELEN, \"%s\", &name[off]);\n\n\tpr_debug(\"TCM_VHost_ConfigFS: Allocated emulated Target\"\n\t\t\" %s Address: %s\\n\", vhost_scsi_dump_proto_id(tport), name);\n\n\treturn &tport->tport_wwn;\n}\n\nstatic void vhost_scsi_drop_tport(struct se_wwn *wwn)\n{\n\tstruct vhost_scsi_tport *tport = container_of(wwn,\n\t\t\t\tstruct vhost_scsi_tport, tport_wwn);\n\n\tpr_debug(\"TCM_VHost_ConfigFS: Deallocating emulated Target\"\n\t\t\" %s Address: %s\\n\", vhost_scsi_dump_proto_id(tport),\n\t\ttport->tport_name);\n\n\tkfree(tport);\n}\n\nstatic ssize_t\nvhost_scsi_wwn_version_show(struct config_item *item, char *page)\n{\n\treturn sysfs_emit(page, \"TCM_VHOST fabric module %s on %s/%s\"\n\t\t\"on \"UTS_RELEASE\"\\n\", VHOST_SCSI_VERSION, utsname()->sysname,\n\t\tutsname()->machine);\n}\n\nCONFIGFS_ATTR_RO(vhost_scsi_wwn_, version);\n\nstatic struct configfs_attribute *vhost_scsi_wwn_attrs[] = {\n\t&vhost_scsi_wwn_attr_version,\n\tNULL,\n};\n\nstatic const struct target_core_fabric_ops vhost_scsi_ops = {\n\t.module\t\t\t\t= THIS_MODULE,\n\t.fabric_name\t\t\t= \"vhost\",\n\t.max_data_sg_nents\t\t= VHOST_SCSI_PREALLOC_SGLS,\n\t.tpg_get_wwn\t\t\t= vhost_scsi_get_fabric_wwn,\n\t.tpg_get_tag\t\t\t= vhost_scsi_get_tpgt,\n\t.tpg_check_demo_mode\t\t= vhost_scsi_check_true,\n\t.tpg_check_demo_mode_cache\t= vhost_scsi_check_true,\n\t.tpg_check_prot_fabric_only\t= vhost_scsi_check_prot_fabric_only,\n\t.release_cmd\t\t\t= vhost_scsi_release_cmd,\n\t.check_stop_free\t\t= vhost_scsi_check_stop_free,\n\t.sess_get_initiator_sid\t\t= NULL,\n\t.write_pending\t\t\t= vhost_scsi_write_pending,\n\t.queue_data_in\t\t\t= vhost_scsi_queue_data_in,\n\t.queue_status\t\t\t= vhost_scsi_queue_status,\n\t.queue_tm_rsp\t\t\t= vhost_scsi_queue_tm_rsp,\n\t.aborted_task\t\t\t= vhost_scsi_aborted_task,\n\t \n\t.fabric_make_wwn\t\t= vhost_scsi_make_tport,\n\t.fabric_drop_wwn\t\t= vhost_scsi_drop_tport,\n\t.fabric_make_tpg\t\t= vhost_scsi_make_tpg,\n\t.fabric_drop_tpg\t\t= vhost_scsi_drop_tpg,\n\t.fabric_post_link\t\t= vhost_scsi_port_link,\n\t.fabric_pre_unlink\t\t= vhost_scsi_port_unlink,\n\n\t.tfc_wwn_attrs\t\t\t= vhost_scsi_wwn_attrs,\n\t.tfc_tpg_base_attrs\t\t= vhost_scsi_tpg_attrs,\n\t.tfc_tpg_attrib_attrs\t\t= vhost_scsi_tpg_attrib_attrs,\n};\n\nstatic int __init vhost_scsi_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tpr_debug(\"TCM_VHOST fabric module %s on %s/%s\"\n\t\t\" on \"UTS_RELEASE\"\\n\", VHOST_SCSI_VERSION, utsname()->sysname,\n\t\tutsname()->machine);\n\n\tret = vhost_scsi_register();\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = target_register_template(&vhost_scsi_ops);\n\tif (ret < 0)\n\t\tgoto out_vhost_scsi_deregister;\n\n\treturn 0;\n\nout_vhost_scsi_deregister:\n\tvhost_scsi_deregister();\nout:\n\treturn ret;\n};\n\nstatic void vhost_scsi_exit(void)\n{\n\ttarget_unregister_template(&vhost_scsi_ops);\n\tvhost_scsi_deregister();\n};\n\nMODULE_DESCRIPTION(\"VHOST_SCSI series fabric driver\");\nMODULE_ALIAS(\"tcm_vhost\");\nMODULE_LICENSE(\"GPL\");\nmodule_init(vhost_scsi_init);\nmodule_exit(vhost_scsi_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}