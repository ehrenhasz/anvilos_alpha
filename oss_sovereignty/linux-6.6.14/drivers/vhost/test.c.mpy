{
  "module_name": "test.c",
  "hash_id": "34865b397fa7a2a034d39760448c8dcc0e416fd83eb0a58778b630f516bf8c9e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/vhost/test.c",
  "human_readable_source": "\n \n\n#include <linux/compat.h>\n#include <linux/eventfd.h>\n#include <linux/vhost.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n\n#include \"test.h\"\n#include \"vhost.h\"\n\n \n#define VHOST_TEST_WEIGHT 0x80000\n\n \n#define VHOST_TEST_PKT_WEIGHT 256\n\nenum {\n\tVHOST_TEST_VQ = 0,\n\tVHOST_TEST_VQ_MAX = 1,\n};\n\nstruct vhost_test {\n\tstruct vhost_dev dev;\n\tstruct vhost_virtqueue vqs[VHOST_TEST_VQ_MAX];\n};\n\n \nstatic void handle_vq(struct vhost_test *n)\n{\n\tstruct vhost_virtqueue *vq = &n->vqs[VHOST_TEST_VQ];\n\tunsigned out, in;\n\tint head;\n\tsize_t len, total_len = 0;\n\tvoid *private;\n\n\tmutex_lock(&vq->mutex);\n\tprivate = vhost_vq_get_backend(vq);\n\tif (!private) {\n\t\tmutex_unlock(&vq->mutex);\n\t\treturn;\n\t}\n\n\tvhost_disable_notify(&n->dev, vq);\n\n\tfor (;;) {\n\t\thead = vhost_get_vq_desc(vq, vq->iov,\n\t\t\t\t\t ARRAY_SIZE(vq->iov),\n\t\t\t\t\t &out, &in,\n\t\t\t\t\t NULL, NULL);\n\t\t \n\t\tif (unlikely(head < 0))\n\t\t\tbreak;\n\t\t \n\t\tif (head == vq->num) {\n\t\t\tif (unlikely(vhost_enable_notify(&n->dev, vq))) {\n\t\t\t\tvhost_disable_notify(&n->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (in) {\n\t\t\tvq_err(vq, \"Unexpected descriptor format for TX: \"\n\t\t\t       \"out %d, int %d\\n\", out, in);\n\t\t\tbreak;\n\t\t}\n\t\tlen = iov_length(vq->iov, out);\n\t\t \n\t\tif (!len) {\n\t\t\tvq_err(vq, \"Unexpected 0 len for TX\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal(&n->dev, vq, head, 0);\n\t\ttotal_len += len;\n\t\tif (unlikely(vhost_exceeds_weight(vq, 0, total_len)))\n\t\t\tbreak;\n\t}\n\n\tmutex_unlock(&vq->mutex);\n}\n\nstatic void handle_vq_kick(struct vhost_work *work)\n{\n\tstruct vhost_virtqueue *vq = container_of(work, struct vhost_virtqueue,\n\t\t\t\t\t\t  poll.work);\n\tstruct vhost_test *n = container_of(vq->dev, struct vhost_test, dev);\n\n\thandle_vq(n);\n}\n\nstatic int vhost_test_open(struct inode *inode, struct file *f)\n{\n\tstruct vhost_test *n = kmalloc(sizeof *n, GFP_KERNEL);\n\tstruct vhost_dev *dev;\n\tstruct vhost_virtqueue **vqs;\n\n\tif (!n)\n\t\treturn -ENOMEM;\n\tvqs = kmalloc_array(VHOST_TEST_VQ_MAX, sizeof(*vqs), GFP_KERNEL);\n\tif (!vqs) {\n\t\tkfree(n);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev = &n->dev;\n\tvqs[VHOST_TEST_VQ] = &n->vqs[VHOST_TEST_VQ];\n\tn->vqs[VHOST_TEST_VQ].handle_kick = handle_vq_kick;\n\tvhost_dev_init(dev, vqs, VHOST_TEST_VQ_MAX, UIO_MAXIOV,\n\t\t       VHOST_TEST_PKT_WEIGHT, VHOST_TEST_WEIGHT, true, NULL);\n\n\tf->private_data = n;\n\n\treturn 0;\n}\n\nstatic void *vhost_test_stop_vq(struct vhost_test *n,\n\t\t\t\tstruct vhost_virtqueue *vq)\n{\n\tvoid *private;\n\n\tmutex_lock(&vq->mutex);\n\tprivate = vhost_vq_get_backend(vq);\n\tvhost_vq_set_backend(vq, NULL);\n\tmutex_unlock(&vq->mutex);\n\treturn private;\n}\n\nstatic void vhost_test_stop(struct vhost_test *n, void **privatep)\n{\n\t*privatep = vhost_test_stop_vq(n, n->vqs + VHOST_TEST_VQ);\n}\n\nstatic void vhost_test_flush(struct vhost_test *n)\n{\n\tvhost_dev_flush(&n->dev);\n}\n\nstatic int vhost_test_release(struct inode *inode, struct file *f)\n{\n\tstruct vhost_test *n = f->private_data;\n\tvoid  *private;\n\n\tvhost_test_stop(n, &private);\n\tvhost_test_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_cleanup(&n->dev);\n\tkfree(n->dev.vqs);\n\tkfree(n);\n\treturn 0;\n}\n\nstatic long vhost_test_run(struct vhost_test *n, int test)\n{\n\tvoid *priv, *oldpriv;\n\tstruct vhost_virtqueue *vq;\n\tint r, index;\n\n\tif (test < 0 || test > 1)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tfor (index = 0; index < n->dev.nvqs; ++index) {\n\t\t \n\t\tif (!vhost_vq_access_ok(&n->vqs[index])) {\n\t\t\tr = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tfor (index = 0; index < n->dev.nvqs; ++index) {\n\t\tvq = n->vqs + index;\n\t\tmutex_lock(&vq->mutex);\n\t\tpriv = test ? n : NULL;\n\n\t\t \n\t\toldpriv = vhost_vq_get_backend(vq);\n\t\tvhost_vq_set_backend(vq, priv);\n\n\t\tr = vhost_vq_init_access(&n->vqs[index]);\n\n\t\tmutex_unlock(&vq->mutex);\n\n\t\tif (r)\n\t\t\tgoto err;\n\n\t\tif (oldpriv) {\n\t\t\tvhost_test_flush(n);\n\t\t}\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_test_reset_owner(struct vhost_test *n)\n{\n\tvoid *priv = NULL;\n\tlong err;\n\tstruct vhost_iotlb *umem;\n\n\tmutex_lock(&n->dev.mutex);\n\terr = vhost_dev_check_owner(&n->dev);\n\tif (err)\n\t\tgoto done;\n\tumem = vhost_dev_reset_owner_prepare();\n\tif (!umem) {\n\t\terr = -ENOMEM;\n\t\tgoto done;\n\t}\n\tvhost_test_stop(n, &priv);\n\tvhost_test_flush(n);\n\tvhost_dev_stop(&n->dev);\n\tvhost_dev_reset_owner(&n->dev, umem);\ndone:\n\tmutex_unlock(&n->dev.mutex);\n\treturn err;\n}\n\nstatic int vhost_test_set_features(struct vhost_test *n, u64 features)\n{\n\tstruct vhost_virtqueue *vq;\n\n\tmutex_lock(&n->dev.mutex);\n\tif ((features & (1 << VHOST_F_LOG_ALL)) &&\n\t    !vhost_log_access_ok(&n->dev)) {\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn -EFAULT;\n\t}\n\tvq = &n->vqs[VHOST_TEST_VQ];\n\tmutex_lock(&vq->mutex);\n\tvq->acked_features = features;\n\tmutex_unlock(&vq->mutex);\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n}\n\nstatic long vhost_test_set_backend(struct vhost_test *n, unsigned index, int fd)\n{\n\tstatic void *backend;\n\n\tconst bool enable = fd != -1;\n\tstruct vhost_virtqueue *vq;\n\tint r;\n\n\tmutex_lock(&n->dev.mutex);\n\tr = vhost_dev_check_owner(&n->dev);\n\tif (r)\n\t\tgoto err;\n\n\tif (index >= VHOST_TEST_VQ_MAX) {\n\t\tr = -ENOBUFS;\n\t\tgoto err;\n\t}\n\tvq = &n->vqs[index];\n\tmutex_lock(&vq->mutex);\n\n\t \n\tif (!vhost_vq_access_ok(vq)) {\n\t\tr = -EFAULT;\n\t\tgoto err_vq;\n\t}\n\tif (!enable) {\n\t\tvhost_poll_stop(&vq->poll);\n\t\tbackend = vhost_vq_get_backend(vq);\n\t\tvhost_vq_set_backend(vq, NULL);\n\t} else {\n\t\tvhost_vq_set_backend(vq, backend);\n\t\tr = vhost_vq_init_access(vq);\n\t\tif (r == 0)\n\t\t\tr = vhost_poll_start(&vq->poll, vq->kick);\n\t}\n\n\tmutex_unlock(&vq->mutex);\n\n\tif (enable) {\n\t\tvhost_test_flush(n);\n\t}\n\n\tmutex_unlock(&n->dev.mutex);\n\treturn 0;\n\nerr_vq:\n\tmutex_unlock(&vq->mutex);\nerr:\n\tmutex_unlock(&n->dev.mutex);\n\treturn r;\n}\n\nstatic long vhost_test_ioctl(struct file *f, unsigned int ioctl,\n\t\t\t     unsigned long arg)\n{\n\tstruct vhost_vring_file backend;\n\tstruct vhost_test *n = f->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tu64 __user *featurep = argp;\n\tint test;\n\tu64 features;\n\tint r;\n\tswitch (ioctl) {\n\tcase VHOST_TEST_RUN:\n\t\tif (copy_from_user(&test, argp, sizeof test))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_test_run(n, test);\n\tcase VHOST_TEST_SET_BACKEND:\n\t\tif (copy_from_user(&backend, argp, sizeof backend))\n\t\t\treturn -EFAULT;\n\t\treturn vhost_test_set_backend(n, backend.index, backend.fd);\n\tcase VHOST_GET_FEATURES:\n\t\tfeatures = VHOST_FEATURES;\n\t\tif (copy_to_user(featurep, &features, sizeof features))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase VHOST_SET_FEATURES:\n\t\tif (copy_from_user(&features, featurep, sizeof features))\n\t\t\treturn -EFAULT;\n\t\tif (features & ~VHOST_FEATURES)\n\t\t\treturn -EOPNOTSUPP;\n\t\treturn vhost_test_set_features(n, features);\n\tcase VHOST_RESET_OWNER:\n\t\treturn vhost_test_reset_owner(n);\n\tdefault:\n\t\tmutex_lock(&n->dev.mutex);\n\t\tr = vhost_dev_ioctl(&n->dev, ioctl, argp);\n                if (r == -ENOIOCTLCMD)\n                        r = vhost_vring_ioctl(&n->dev, ioctl, argp);\n\t\tvhost_test_flush(n);\n\t\tmutex_unlock(&n->dev.mutex);\n\t\treturn r;\n\t}\n}\n\nstatic const struct file_operations vhost_test_fops = {\n\t.owner          = THIS_MODULE,\n\t.release        = vhost_test_release,\n\t.unlocked_ioctl = vhost_test_ioctl,\n\t.compat_ioctl   = compat_ptr_ioctl,\n\t.open           = vhost_test_open,\n\t.llseek\t\t= noop_llseek,\n};\n\nstatic struct miscdevice vhost_test_misc = {\n\tMISC_DYNAMIC_MINOR,\n\t\"vhost-test\",\n\t&vhost_test_fops,\n};\nmodule_misc_device(vhost_test_misc);\n\nMODULE_VERSION(\"0.0.1\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Michael S. Tsirkin\");\nMODULE_DESCRIPTION(\"Host kernel side for virtio simulator\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}