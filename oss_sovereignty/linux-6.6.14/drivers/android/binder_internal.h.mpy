{
  "module_name": "binder_internal.h",
  "hash_id": "74d630330335d29ff07550a6416d8eacc08cb7e1f6219ab4648ae1ccd12eabc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/android/binder_internal.h",
  "human_readable_source": " \n\n#ifndef _LINUX_BINDER_INTERNAL_H\n#define _LINUX_BINDER_INTERNAL_H\n\n#include <linux/export.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/miscdevice.h>\n#include <linux/mutex.h>\n#include <linux/refcount.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n#include <linux/uidgid.h>\n#include <uapi/linux/android/binderfs.h>\n#include \"binder_alloc.h\"\n\nstruct binder_context {\n\tstruct binder_node *binder_context_mgr_node;\n\tstruct mutex context_mgr_node_lock;\n\tkuid_t binder_context_mgr_uid;\n\tconst char *name;\n};\n\n \nstruct binder_device {\n\tstruct hlist_node hlist;\n\tstruct miscdevice miscdev;\n\tstruct binder_context context;\n\tstruct inode *binderfs_inode;\n\trefcount_t ref;\n};\n\n \nstruct binderfs_mount_opts {\n\tint max;\n\tint stats_mode;\n};\n\n \nstruct binderfs_info {\n\tstruct ipc_namespace *ipc_ns;\n\tstruct dentry *control_dentry;\n\tkuid_t root_uid;\n\tkgid_t root_gid;\n\tstruct binderfs_mount_opts mount_opts;\n\tint device_count;\n\tstruct dentry *proc_log_dir;\n};\n\nextern const struct file_operations binder_fops;\n\nextern char *binder_devices_param;\n\n#ifdef CONFIG_ANDROID_BINDERFS\nextern bool is_binderfs_device(const struct inode *inode);\nextern struct dentry *binderfs_create_file(struct dentry *dir, const char *name,\n\t\t\t\t\t   const struct file_operations *fops,\n\t\t\t\t\t   void *data);\nextern void binderfs_remove_file(struct dentry *dentry);\n#else\nstatic inline bool is_binderfs_device(const struct inode *inode)\n{\n\treturn false;\n}\nstatic inline struct dentry *binderfs_create_file(struct dentry *dir,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   const struct file_operations *fops,\n\t\t\t\t\t   void *data)\n{\n\treturn NULL;\n}\nstatic inline void binderfs_remove_file(struct dentry *dentry) {}\n#endif\n\n#ifdef CONFIG_ANDROID_BINDERFS\nextern int __init init_binderfs(void);\n#else\nstatic inline int __init init_binderfs(void)\n{\n\treturn 0;\n}\n#endif\n\nstruct binder_debugfs_entry {\n\tconst char *name;\n\tumode_t mode;\n\tconst struct file_operations *fops;\n\tvoid *data;\n};\n\nextern const struct binder_debugfs_entry binder_debugfs_entries[];\n\n#define binder_for_each_debugfs_entry(entry)\t\\\n\tfor ((entry) = binder_debugfs_entries;\t\\\n\t     (entry)->name;\t\t\t\\\n\t     (entry)++)\n\nenum binder_stat_types {\n\tBINDER_STAT_PROC,\n\tBINDER_STAT_THREAD,\n\tBINDER_STAT_NODE,\n\tBINDER_STAT_REF,\n\tBINDER_STAT_DEATH,\n\tBINDER_STAT_TRANSACTION,\n\tBINDER_STAT_TRANSACTION_COMPLETE,\n\tBINDER_STAT_COUNT\n};\n\nstruct binder_stats {\n\tatomic_t br[_IOC_NR(BR_TRANSACTION_PENDING_FROZEN) + 1];\n\tatomic_t bc[_IOC_NR(BC_REPLY_SG) + 1];\n\tatomic_t obj_created[BINDER_STAT_COUNT];\n\tatomic_t obj_deleted[BINDER_STAT_COUNT];\n};\n\n \nstruct binder_work {\n\tstruct list_head entry;\n\n\tenum binder_work_type {\n\t\tBINDER_WORK_TRANSACTION = 1,\n\t\tBINDER_WORK_TRANSACTION_COMPLETE,\n\t\tBINDER_WORK_TRANSACTION_PENDING,\n\t\tBINDER_WORK_TRANSACTION_ONEWAY_SPAM_SUSPECT,\n\t\tBINDER_WORK_RETURN_ERROR,\n\t\tBINDER_WORK_NODE,\n\t\tBINDER_WORK_DEAD_BINDER,\n\t\tBINDER_WORK_DEAD_BINDER_AND_CLEAR,\n\t\tBINDER_WORK_CLEAR_DEATH_NOTIFICATION,\n\t} type;\n};\n\nstruct binder_error {\n\tstruct binder_work work;\n\tuint32_t cmd;\n};\n\n \nstruct binder_node {\n\tint debug_id;\n\tspinlock_t lock;\n\tstruct binder_work work;\n\tunion {\n\t\tstruct rb_node rb_node;\n\t\tstruct hlist_node dead_node;\n\t};\n\tstruct binder_proc *proc;\n\tstruct hlist_head refs;\n\tint internal_strong_refs;\n\tint local_weak_refs;\n\tint local_strong_refs;\n\tint tmp_refs;\n\tbinder_uintptr_t ptr;\n\tbinder_uintptr_t cookie;\n\tstruct {\n\t\t \n\t\tu8 has_strong_ref:1;\n\t\tu8 pending_strong_ref:1;\n\t\tu8 has_weak_ref:1;\n\t\tu8 pending_weak_ref:1;\n\t};\n\tstruct {\n\t\t \n\t\tu8 accept_fds:1;\n\t\tu8 txn_security_ctx:1;\n\t\tu8 min_priority;\n\t};\n\tbool has_async_transaction;\n\tstruct list_head async_todo;\n};\n\nstruct binder_ref_death {\n\t \n\tstruct binder_work work;\n\tbinder_uintptr_t cookie;\n};\n\n \nstruct binder_ref_data {\n\tint debug_id;\n\tuint32_t desc;\n\tint strong;\n\tint weak;\n};\n\n \nstruct binder_ref {\n\t \n\t \n\t \n\t \n\tstruct binder_ref_data data;\n\tstruct rb_node rb_node_desc;\n\tstruct rb_node rb_node_node;\n\tstruct hlist_node node_entry;\n\tstruct binder_proc *proc;\n\tstruct binder_node *node;\n\tstruct binder_ref_death *death;\n};\n\n \nstruct binder_proc {\n\tstruct hlist_node proc_node;\n\tstruct rb_root threads;\n\tstruct rb_root nodes;\n\tstruct rb_root refs_by_desc;\n\tstruct rb_root refs_by_node;\n\tstruct list_head waiting_threads;\n\tint pid;\n\tstruct task_struct *tsk;\n\tconst struct cred *cred;\n\tstruct hlist_node deferred_work_node;\n\tint deferred_work;\n\tint outstanding_txns;\n\tbool is_dead;\n\tbool is_frozen;\n\tbool sync_recv;\n\tbool async_recv;\n\twait_queue_head_t freeze_wait;\n\n\tstruct list_head todo;\n\tstruct binder_stats stats;\n\tstruct list_head delivered_death;\n\tint max_threads;\n\tint requested_threads;\n\tint requested_threads_started;\n\tint tmp_ref;\n\tlong default_priority;\n\tstruct dentry *debugfs_entry;\n\tstruct binder_alloc alloc;\n\tstruct binder_context *context;\n\tspinlock_t inner_lock;\n\tspinlock_t outer_lock;\n\tstruct dentry *binderfs_entry;\n\tbool oneway_spam_detection_enabled;\n};\n\n \nstruct binder_thread {\n\tstruct binder_proc *proc;\n\tstruct rb_node rb_node;\n\tstruct list_head waiting_thread_node;\n\tint pid;\n\tint looper;               \n\tbool looper_need_return;  \n\tstruct binder_transaction *transaction_stack;\n\tstruct list_head todo;\n\tbool process_todo;\n\tstruct binder_error return_error;\n\tstruct binder_error reply_error;\n\tstruct binder_extended_error ee;\n\twait_queue_head_t wait;\n\tstruct binder_stats stats;\n\tatomic_t tmp_ref;\n\tbool is_dead;\n};\n\n \nstruct binder_txn_fd_fixup {\n\tstruct list_head fixup_entry;\n\tstruct file *file;\n\tsize_t offset;\n\tint target_fd;\n};\n\nstruct binder_transaction {\n\tint debug_id;\n\tstruct binder_work work;\n\tstruct binder_thread *from;\n\tpid_t from_pid;\n\tpid_t from_tid;\n\tstruct binder_transaction *from_parent;\n\tstruct binder_proc *to_proc;\n\tstruct binder_thread *to_thread;\n\tstruct binder_transaction *to_parent;\n\tunsigned need_reply:1;\n\t         \n\n\tstruct binder_buffer *buffer;\n\tunsigned int    code;\n\tunsigned int    flags;\n\tlong    priority;\n\tlong    saved_priority;\n\tkuid_t  sender_euid;\n\tktime_t start_time;\n\tstruct list_head fd_fixups;\n\tbinder_uintptr_t security_ctx;\n\t \n\tspinlock_t lock;\n};\n\n \nstruct binder_object {\n\tunion {\n\t\tstruct binder_object_header hdr;\n\t\tstruct flat_binder_object fbo;\n\t\tstruct binder_fd_object fdo;\n\t\tstruct binder_buffer_object bbo;\n\t\tstruct binder_fd_array_object fdao;\n\t};\n};\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}