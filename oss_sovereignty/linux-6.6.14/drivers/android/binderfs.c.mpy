{
  "module_name": "binderfs.c",
  "hash_id": "e9df61d820682700471b0a074a88f9f1a7136eb826c136c930647885197c7379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/android/binderfs.c",
  "human_readable_source": "\n\n#include <linux/compiler_types.h>\n#include <linux/errno.h>\n#include <linux/fs.h>\n#include <linux/fsnotify.h>\n#include <linux/gfp.h>\n#include <linux/idr.h>\n#include <linux/init.h>\n#include <linux/ipc_namespace.h>\n#include <linux/kdev_t.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/namei.h>\n#include <linux/magic.h>\n#include <linux/major.h>\n#include <linux/miscdevice.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/mount.h>\n#include <linux/fs_parser.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock_types.h>\n#include <linux/stddef.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/xarray.h>\n#include <uapi/asm-generic/errno-base.h>\n#include <uapi/linux/android/binder.h>\n#include <uapi/linux/android/binderfs.h>\n\n#include \"binder_internal.h\"\n\n#define FIRST_INODE 1\n#define SECOND_INODE 2\n#define INODE_OFFSET 3\n#define BINDERFS_MAX_MINOR (1U << MINORBITS)\n \n#define BINDERFS_MAX_MINOR_CAPPED (BINDERFS_MAX_MINOR - 4)\n\nstatic dev_t binderfs_dev;\nstatic DEFINE_MUTEX(binderfs_minors_mutex);\nstatic DEFINE_IDA(binderfs_minors);\n\nenum binderfs_param {\n\tOpt_max,\n\tOpt_stats_mode,\n};\n\nenum binderfs_stats_mode {\n\tbinderfs_stats_mode_unset,\n\tbinderfs_stats_mode_global,\n};\n\nstruct binder_features {\n\tbool oneway_spam_detection;\n\tbool extended_error;\n};\n\nstatic const struct constant_table binderfs_param_stats[] = {\n\t{ \"global\", binderfs_stats_mode_global },\n\t{}\n};\n\nstatic const struct fs_parameter_spec binderfs_fs_parameters[] = {\n\tfsparam_u32(\"max\",\tOpt_max),\n\tfsparam_enum(\"stats\",\tOpt_stats_mode, binderfs_param_stats),\n\t{}\n};\n\nstatic struct binder_features binder_features = {\n\t.oneway_spam_detection = true,\n\t.extended_error = true,\n};\n\nstatic inline struct binderfs_info *BINDERFS_SB(const struct super_block *sb)\n{\n\treturn sb->s_fs_info;\n}\n\nbool is_binderfs_device(const struct inode *inode)\n{\n\tif (inode->i_sb->s_magic == BINDERFS_SUPER_MAGIC)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int binderfs_binder_device_create(struct inode *ref_inode,\n\t\t\t\t\t struct binderfs_device __user *userp,\n\t\t\t\t\t struct binderfs_device *req)\n{\n\tint minor, ret;\n\tstruct dentry *dentry, *root;\n\tstruct binder_device *device;\n\tchar *name = NULL;\n\tsize_t name_len;\n\tstruct inode *inode = NULL;\n\tstruct super_block *sb = ref_inode->i_sb;\n\tstruct binderfs_info *info = sb->s_fs_info;\n#if defined(CONFIG_IPC_NS)\n\tbool use_reserve = (info->ipc_ns == &init_ipc_ns);\n#else\n\tbool use_reserve = true;\n#endif\n\n\t \n\tmutex_lock(&binderfs_minors_mutex);\n\tif (++info->device_count <= info->mount_opts.max)\n\t\tminor = ida_alloc_max(&binderfs_minors,\n\t\t\t\t      use_reserve ? BINDERFS_MAX_MINOR :\n\t\t\t\t\t\t    BINDERFS_MAX_MINOR_CAPPED,\n\t\t\t\t      GFP_KERNEL);\n\telse\n\t\tminor = -ENOSPC;\n\tif (minor < 0) {\n\t\t--info->device_count;\n\t\tmutex_unlock(&binderfs_minors_mutex);\n\t\treturn minor;\n\t}\n\tmutex_unlock(&binderfs_minors_mutex);\n\n\tret = -ENOMEM;\n\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\tif (!device)\n\t\tgoto err;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto err;\n\n\tinode->i_ino = minor + INODE_OFFSET;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinit_special_inode(inode, S_IFCHR | 0600,\n\t\t\t   MKDEV(MAJOR(binderfs_dev), minor));\n\tinode->i_fop = &binder_fops;\n\tinode->i_uid = info->root_uid;\n\tinode->i_gid = info->root_gid;\n\n\treq->name[BINDERFS_MAX_NAME] = '\\0';  \n\tname_len = strlen(req->name);\n\t \n\tname = kmemdup(req->name, name_len + 1, GFP_KERNEL);\n\tif (!name)\n\t\tgoto err;\n\n\trefcount_set(&device->ref, 1);\n\tdevice->binderfs_inode = inode;\n\tdevice->context.binder_context_mgr_uid = INVALID_UID;\n\tdevice->context.name = name;\n\tdevice->miscdev.name = name;\n\tdevice->miscdev.minor = minor;\n\tmutex_init(&device->context.context_mgr_node_lock);\n\n\treq->major = MAJOR(binderfs_dev);\n\treq->minor = minor;\n\n\tif (userp && copy_to_user(userp, req, sizeof(*req))) {\n\t\tret = -EFAULT;\n\t\tgoto err;\n\t}\n\n\troot = sb->s_root;\n\tinode_lock(d_inode(root));\n\n\t \n\tdentry = lookup_one_len(name, root, name_len);\n\tif (IS_ERR(dentry)) {\n\t\tinode_unlock(d_inode(root));\n\t\tret = PTR_ERR(dentry);\n\t\tgoto err;\n\t}\n\n\tif (d_really_is_positive(dentry)) {\n\t\t \n\t\tdput(dentry);\n\t\tinode_unlock(d_inode(root));\n\t\tret = -EEXIST;\n\t\tgoto err;\n\t}\n\n\tinode->i_private = device;\n\td_instantiate(dentry, inode);\n\tfsnotify_create(root->d_inode, dentry);\n\tinode_unlock(d_inode(root));\n\n\treturn 0;\n\nerr:\n\tkfree(name);\n\tkfree(device);\n\tmutex_lock(&binderfs_minors_mutex);\n\t--info->device_count;\n\tida_free(&binderfs_minors, minor);\n\tmutex_unlock(&binderfs_minors_mutex);\n\tiput(inode);\n\n\treturn ret;\n}\n\n \nstatic long binder_ctl_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tint ret = -EINVAL;\n\tstruct inode *inode = file_inode(file);\n\tstruct binderfs_device __user *device = (struct binderfs_device __user *)arg;\n\tstruct binderfs_device device_req;\n\n\tswitch (cmd) {\n\tcase BINDER_CTL_ADD:\n\t\tret = copy_from_user(&device_req, device, sizeof(device_req));\n\t\tif (ret) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = binderfs_binder_device_create(inode, device, &device_req);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void binderfs_evict_inode(struct inode *inode)\n{\n\tstruct binder_device *device = inode->i_private;\n\tstruct binderfs_info *info = BINDERFS_SB(inode->i_sb);\n\n\tclear_inode(inode);\n\n\tif (!S_ISCHR(inode->i_mode) || !device)\n\t\treturn;\n\n\tmutex_lock(&binderfs_minors_mutex);\n\t--info->device_count;\n\tida_free(&binderfs_minors, device->miscdev.minor);\n\tmutex_unlock(&binderfs_minors_mutex);\n\n\tif (refcount_dec_and_test(&device->ref)) {\n\t\tkfree(device->context.name);\n\t\tkfree(device);\n\t}\n}\n\nstatic int binderfs_fs_context_parse_param(struct fs_context *fc,\n\t\t\t\t\t   struct fs_parameter *param)\n{\n\tint opt;\n\tstruct binderfs_mount_opts *ctx = fc->fs_private;\n\tstruct fs_parse_result result;\n\n\topt = fs_parse(fc, binderfs_fs_parameters, param, &result);\n\tif (opt < 0)\n\t\treturn opt;\n\n\tswitch (opt) {\n\tcase Opt_max:\n\t\tif (result.uint_32 > BINDERFS_MAX_MINOR)\n\t\t\treturn invalfc(fc, \"Bad value for '%s'\", param->key);\n\n\t\tctx->max = result.uint_32;\n\t\tbreak;\n\tcase Opt_stats_mode:\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tctx->stats_mode = result.uint_32;\n\t\tbreak;\n\tdefault:\n\t\treturn invalfc(fc, \"Unsupported parameter '%s'\", param->key);\n\t}\n\n\treturn 0;\n}\n\nstatic int binderfs_fs_context_reconfigure(struct fs_context *fc)\n{\n\tstruct binderfs_mount_opts *ctx = fc->fs_private;\n\tstruct binderfs_info *info = BINDERFS_SB(fc->root->d_sb);\n\n\tif (info->mount_opts.stats_mode != ctx->stats_mode)\n\t\treturn invalfc(fc, \"Binderfs stats mode cannot be changed during a remount\");\n\n\tinfo->mount_opts.stats_mode = ctx->stats_mode;\n\tinfo->mount_opts.max = ctx->max;\n\treturn 0;\n}\n\nstatic int binderfs_show_options(struct seq_file *seq, struct dentry *root)\n{\n\tstruct binderfs_info *info = BINDERFS_SB(root->d_sb);\n\n\tif (info->mount_opts.max <= BINDERFS_MAX_MINOR)\n\t\tseq_printf(seq, \",max=%d\", info->mount_opts.max);\n\n\tswitch (info->mount_opts.stats_mode) {\n\tcase binderfs_stats_mode_unset:\n\t\tbreak;\n\tcase binderfs_stats_mode_global:\n\t\tseq_printf(seq, \",stats=global\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct super_operations binderfs_super_ops = {\n\t.evict_inode    = binderfs_evict_inode,\n\t.show_options\t= binderfs_show_options,\n\t.statfs         = simple_statfs,\n};\n\nstatic inline bool is_binderfs_control_device(const struct dentry *dentry)\n{\n\tstruct binderfs_info *info = dentry->d_sb->s_fs_info;\n\n\treturn info->control_dentry == dentry;\n}\n\nstatic int binderfs_rename(struct mnt_idmap *idmap,\n\t\t\t   struct inode *old_dir, struct dentry *old_dentry,\n\t\t\t   struct inode *new_dir, struct dentry *new_dentry,\n\t\t\t   unsigned int flags)\n{\n\tif (is_binderfs_control_device(old_dentry) ||\n\t    is_binderfs_control_device(new_dentry))\n\t\treturn -EPERM;\n\n\treturn simple_rename(idmap, old_dir, old_dentry, new_dir,\n\t\t\t     new_dentry, flags);\n}\n\nstatic int binderfs_unlink(struct inode *dir, struct dentry *dentry)\n{\n\tif (is_binderfs_control_device(dentry))\n\t\treturn -EPERM;\n\n\treturn simple_unlink(dir, dentry);\n}\n\nstatic const struct file_operations binder_ctl_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= nonseekable_open,\n\t.unlocked_ioctl\t= binder_ctl_ioctl,\n\t.compat_ioctl\t= binder_ctl_ioctl,\n\t.llseek\t\t= noop_llseek,\n};\n\n \nstatic int binderfs_binder_ctl_create(struct super_block *sb)\n{\n\tint minor, ret;\n\tstruct dentry *dentry;\n\tstruct binder_device *device;\n\tstruct inode *inode = NULL;\n\tstruct dentry *root = sb->s_root;\n\tstruct binderfs_info *info = sb->s_fs_info;\n#if defined(CONFIG_IPC_NS)\n\tbool use_reserve = (info->ipc_ns == &init_ipc_ns);\n#else\n\tbool use_reserve = true;\n#endif\n\n\tdevice = kzalloc(sizeof(*device), GFP_KERNEL);\n\tif (!device)\n\t\treturn -ENOMEM;\n\n\t \n\tif (info->control_dentry) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = -ENOMEM;\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\tgoto out;\n\n\t \n\tmutex_lock(&binderfs_minors_mutex);\n\tminor = ida_alloc_max(&binderfs_minors,\n\t\t\t      use_reserve ? BINDERFS_MAX_MINOR :\n\t\t\t\t\t    BINDERFS_MAX_MINOR_CAPPED,\n\t\t\t      GFP_KERNEL);\n\tmutex_unlock(&binderfs_minors_mutex);\n\tif (minor < 0) {\n\t\tret = minor;\n\t\tgoto out;\n\t}\n\n\tinode->i_ino = SECOND_INODE;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinit_special_inode(inode, S_IFCHR | 0600,\n\t\t\t   MKDEV(MAJOR(binderfs_dev), minor));\n\tinode->i_fop = &binder_ctl_fops;\n\tinode->i_uid = info->root_uid;\n\tinode->i_gid = info->root_gid;\n\n\trefcount_set(&device->ref, 1);\n\tdevice->binderfs_inode = inode;\n\tdevice->miscdev.minor = minor;\n\n\tdentry = d_alloc_name(root, \"binder-control\");\n\tif (!dentry)\n\t\tgoto out;\n\n\tinode->i_private = device;\n\tinfo->control_dentry = dentry;\n\td_add(dentry, inode);\n\n\treturn 0;\n\nout:\n\tkfree(device);\n\tiput(inode);\n\n\treturn ret;\n}\n\nstatic const struct inode_operations binderfs_dir_inode_operations = {\n\t.lookup = simple_lookup,\n\t.rename = binderfs_rename,\n\t.unlink = binderfs_unlink,\n};\n\nstatic struct inode *binderfs_make_inode(struct super_block *sb, int mode)\n{\n\tstruct inode *ret;\n\n\tret = new_inode(sb);\n\tif (ret) {\n\t\tret->i_ino = iunique(sb, BINDERFS_MAX_MINOR + INODE_OFFSET);\n\t\tret->i_mode = mode;\n\t\tret->i_atime = ret->i_mtime = inode_set_ctime_current(ret);\n\t}\n\treturn ret;\n}\n\nstatic struct dentry *binderfs_create_dentry(struct dentry *parent,\n\t\t\t\t\t     const char *name)\n{\n\tstruct dentry *dentry;\n\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\treturn dentry;\n\n\t \n\tif (d_really_is_positive(dentry)) {\n\t\tdput(dentry);\n\t\treturn ERR_PTR(-EEXIST);\n\t}\n\n\treturn dentry;\n}\n\nvoid binderfs_remove_file(struct dentry *dentry)\n{\n\tstruct inode *parent_inode;\n\n\tparent_inode = d_inode(dentry->d_parent);\n\tinode_lock(parent_inode);\n\tif (simple_positive(dentry)) {\n\t\tdget(dentry);\n\t\tsimple_unlink(parent_inode, dentry);\n\t\td_delete(dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(parent_inode);\n}\n\nstruct dentry *binderfs_create_file(struct dentry *parent, const char *name,\n\t\t\t\t    const struct file_operations *fops,\n\t\t\t\t    void *data)\n{\n\tstruct dentry *dentry;\n\tstruct inode *new_inode, *parent_inode;\n\tstruct super_block *sb;\n\n\tparent_inode = d_inode(parent);\n\tinode_lock(parent_inode);\n\n\tdentry = binderfs_create_dentry(parent, name);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tsb = parent_inode->i_sb;\n\tnew_inode = binderfs_make_inode(sb, S_IFREG | 0444);\n\tif (!new_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tnew_inode->i_fop = fops;\n\tnew_inode->i_private = data;\n\td_instantiate(dentry, new_inode);\n\tfsnotify_create(parent_inode, dentry);\n\nout:\n\tinode_unlock(parent_inode);\n\treturn dentry;\n}\n\nstatic struct dentry *binderfs_create_dir(struct dentry *parent,\n\t\t\t\t\t  const char *name)\n{\n\tstruct dentry *dentry;\n\tstruct inode *new_inode, *parent_inode;\n\tstruct super_block *sb;\n\n\tparent_inode = d_inode(parent);\n\tinode_lock(parent_inode);\n\n\tdentry = binderfs_create_dentry(parent, name);\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tsb = parent_inode->i_sb;\n\tnew_inode = binderfs_make_inode(sb, S_IFDIR | 0755);\n\tif (!new_inode) {\n\t\tdput(dentry);\n\t\tdentry = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tnew_inode->i_fop = &simple_dir_operations;\n\tnew_inode->i_op = &simple_dir_inode_operations;\n\n\tset_nlink(new_inode, 2);\n\td_instantiate(dentry, new_inode);\n\tinc_nlink(parent_inode);\n\tfsnotify_mkdir(parent_inode, dentry);\n\nout:\n\tinode_unlock(parent_inode);\n\treturn dentry;\n}\n\nstatic int binder_features_show(struct seq_file *m, void *unused)\n{\n\tbool *feature = m->private;\n\n\tseq_printf(m, \"%d\\n\", *feature);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(binder_features);\n\nstatic int init_binder_features(struct super_block *sb)\n{\n\tstruct dentry *dentry, *dir;\n\n\tdir = binderfs_create_dir(sb->s_root, \"features\");\n\tif (IS_ERR(dir))\n\t\treturn PTR_ERR(dir);\n\n\tdentry = binderfs_create_file(dir, \"oneway_spam_detection\",\n\t\t\t\t      &binder_features_fops,\n\t\t\t\t      &binder_features.oneway_spam_detection);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\tdentry = binderfs_create_file(dir, \"extended_error\",\n\t\t\t\t      &binder_features_fops,\n\t\t\t\t      &binder_features.extended_error);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\n\treturn 0;\n}\n\nstatic int init_binder_logs(struct super_block *sb)\n{\n\tstruct dentry *binder_logs_root_dir, *dentry, *proc_log_dir;\n\tconst struct binder_debugfs_entry *db_entry;\n\tstruct binderfs_info *info;\n\tint ret = 0;\n\n\tbinder_logs_root_dir = binderfs_create_dir(sb->s_root,\n\t\t\t\t\t\t   \"binder_logs\");\n\tif (IS_ERR(binder_logs_root_dir)) {\n\t\tret = PTR_ERR(binder_logs_root_dir);\n\t\tgoto out;\n\t}\n\n\tbinder_for_each_debugfs_entry(db_entry) {\n\t\tdentry = binderfs_create_file(binder_logs_root_dir,\n\t\t\t\t\t      db_entry->name,\n\t\t\t\t\t      db_entry->fops,\n\t\t\t\t\t      db_entry->data);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tret = PTR_ERR(dentry);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tproc_log_dir = binderfs_create_dir(binder_logs_root_dir, \"proc\");\n\tif (IS_ERR(proc_log_dir)) {\n\t\tret = PTR_ERR(proc_log_dir);\n\t\tgoto out;\n\t}\n\tinfo = sb->s_fs_info;\n\tinfo->proc_log_dir = proc_log_dir;\n\nout:\n\treturn ret;\n}\n\nstatic int binderfs_fill_super(struct super_block *sb, struct fs_context *fc)\n{\n\tint ret;\n\tstruct binderfs_info *info;\n\tstruct binderfs_mount_opts *ctx = fc->fs_private;\n\tstruct inode *inode = NULL;\n\tstruct binderfs_device device_info = {};\n\tconst char *name;\n\tsize_t len;\n\n\tsb->s_blocksize = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\n\t \n\tsb->s_iflags &= ~SB_I_NODEV;\n\tsb->s_iflags |= SB_I_NOEXEC;\n\tsb->s_magic = BINDERFS_SUPER_MAGIC;\n\tsb->s_op = &binderfs_super_ops;\n\tsb->s_time_gran = 1;\n\n\tsb->s_fs_info = kzalloc(sizeof(struct binderfs_info), GFP_KERNEL);\n\tif (!sb->s_fs_info)\n\t\treturn -ENOMEM;\n\tinfo = sb->s_fs_info;\n\n\tinfo->ipc_ns = get_ipc_ns(current->nsproxy->ipc_ns);\n\n\tinfo->root_gid = make_kgid(sb->s_user_ns, 0);\n\tif (!gid_valid(info->root_gid))\n\t\tinfo->root_gid = GLOBAL_ROOT_GID;\n\tinfo->root_uid = make_kuid(sb->s_user_ns, 0);\n\tif (!uid_valid(info->root_uid))\n\t\tinfo->root_uid = GLOBAL_ROOT_UID;\n\tinfo->mount_opts.max = ctx->max;\n\tinfo->mount_opts.stats_mode = ctx->stats_mode;\n\n\tinode = new_inode(sb);\n\tif (!inode)\n\t\treturn -ENOMEM;\n\n\tinode->i_ino = FIRST_INODE;\n\tinode->i_fop = &simple_dir_operations;\n\tinode->i_mode = S_IFDIR | 0755;\n\tinode->i_mtime = inode->i_atime = inode_set_ctime_current(inode);\n\tinode->i_op = &binderfs_dir_inode_operations;\n\tset_nlink(inode, 2);\n\n\tsb->s_root = d_make_root(inode);\n\tif (!sb->s_root)\n\t\treturn -ENOMEM;\n\n\tret = binderfs_binder_ctl_create(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tname = binder_devices_param;\n\tfor (len = strcspn(name, \",\"); len > 0; len = strcspn(name, \",\")) {\n\t\tstrscpy(device_info.name, name, len + 1);\n\t\tret = binderfs_binder_device_create(inode, NULL, &device_info);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tname += len;\n\t\tif (*name == ',')\n\t\t\tname++;\n\t}\n\n\tret = init_binder_features(sb);\n\tif (ret)\n\t\treturn ret;\n\n\tif (info->mount_opts.stats_mode == binderfs_stats_mode_global)\n\t\treturn init_binder_logs(sb);\n\n\treturn 0;\n}\n\nstatic int binderfs_fs_context_get_tree(struct fs_context *fc)\n{\n\treturn get_tree_nodev(fc, binderfs_fill_super);\n}\n\nstatic void binderfs_fs_context_free(struct fs_context *fc)\n{\n\tstruct binderfs_mount_opts *ctx = fc->fs_private;\n\n\tkfree(ctx);\n}\n\nstatic const struct fs_context_operations binderfs_fs_context_ops = {\n\t.free\t\t= binderfs_fs_context_free,\n\t.get_tree\t= binderfs_fs_context_get_tree,\n\t.parse_param\t= binderfs_fs_context_parse_param,\n\t.reconfigure\t= binderfs_fs_context_reconfigure,\n};\n\nstatic int binderfs_init_fs_context(struct fs_context *fc)\n{\n\tstruct binderfs_mount_opts *ctx;\n\n\tctx = kzalloc(sizeof(struct binderfs_mount_opts), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->max = BINDERFS_MAX_MINOR;\n\tctx->stats_mode = binderfs_stats_mode_unset;\n\n\tfc->fs_private = ctx;\n\tfc->ops = &binderfs_fs_context_ops;\n\n\treturn 0;\n}\n\nstatic void binderfs_kill_super(struct super_block *sb)\n{\n\tstruct binderfs_info *info = sb->s_fs_info;\n\n\t \n\tkill_litter_super(sb);\n\n\tif (info && info->ipc_ns)\n\t\tput_ipc_ns(info->ipc_ns);\n\n\tkfree(info);\n}\n\nstatic struct file_system_type binder_fs_type = {\n\t.name\t\t\t= \"binder\",\n\t.init_fs_context\t= binderfs_init_fs_context,\n\t.parameters\t\t= binderfs_fs_parameters,\n\t.kill_sb\t\t= binderfs_kill_super,\n\t.fs_flags\t\t= FS_USERNS_MOUNT,\n};\n\nint __init init_binderfs(void)\n{\n\tint ret;\n\tconst char *name;\n\tsize_t len;\n\n\t \n\tname = binder_devices_param;\n\tfor (len = strcspn(name, \",\"); len > 0; len = strcspn(name, \",\")) {\n\t\tif (len > BINDERFS_MAX_NAME)\n\t\t\treturn -E2BIG;\n\t\tname += len;\n\t\tif (*name == ',')\n\t\t\tname++;\n\t}\n\n\t \n\tret = alloc_chrdev_region(&binderfs_dev, 0, BINDERFS_MAX_MINOR,\n\t\t\t\t  \"binder\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_filesystem(&binder_fs_type);\n\tif (ret) {\n\t\tunregister_chrdev_region(binderfs_dev, BINDERFS_MAX_MINOR);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}