{
  "module_name": "binder_alloc_selftest.c",
  "hash_id": "8dc30ee313c264f5fecab88b54dce5982920512b408e2b851e41d1b785271c58",
  "original_prompt": "Ingested from linux-6.6.14/drivers/android/binder_alloc_selftest.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/mm_types.h>\n#include <linux/err.h>\n#include \"binder_alloc.h\"\n\n#define BUFFER_NUM 5\n#define BUFFER_MIN_SIZE (PAGE_SIZE / 8)\n\nstatic bool binder_selftest_run = true;\nstatic int binder_selftest_failures;\nstatic DEFINE_MUTEX(binder_selftest_lock);\n\n \nenum buf_end_align_type {\n\t \n\tSAME_PAGE_UNALIGNED = 0,\n\t \n\tSAME_PAGE_ALIGNED,\n\t \n\tNEXT_PAGE_UNALIGNED,\n\t \n\tNEXT_PAGE_ALIGNED,\n\t \n\tNEXT_NEXT_UNALIGNED,\n\tLOOP_END,\n};\n\nstatic void pr_err_size_seq(size_t *sizes, int *seq)\n{\n\tint i;\n\n\tpr_err(\"alloc sizes: \");\n\tfor (i = 0; i < BUFFER_NUM; i++)\n\t\tpr_cont(\"[%zu]\", sizes[i]);\n\tpr_cont(\"\\n\");\n\tpr_err(\"free seq: \");\n\tfor (i = 0; i < BUFFER_NUM; i++)\n\t\tpr_cont(\"[%d]\", seq[i]);\n\tpr_cont(\"\\n\");\n}\n\nstatic bool check_buffer_pages_allocated(struct binder_alloc *alloc,\n\t\t\t\t\t struct binder_buffer *buffer,\n\t\t\t\t\t size_t size)\n{\n\tvoid __user *page_addr;\n\tvoid __user *end;\n\tint page_index;\n\n\tend = (void __user *)PAGE_ALIGN((uintptr_t)buffer->user_data + size);\n\tpage_addr = buffer->user_data;\n\tfor (; page_addr < end; page_addr += PAGE_SIZE) {\n\t\tpage_index = (page_addr - alloc->buffer) / PAGE_SIZE;\n\t\tif (!alloc->pages[page_index].page_ptr ||\n\t\t    !list_empty(&alloc->pages[page_index].lru)) {\n\t\t\tpr_err(\"expect alloc but is %s at page index %d\\n\",\n\t\t\t       alloc->pages[page_index].page_ptr ?\n\t\t\t       \"lru\" : \"free\", page_index);\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nstatic void binder_selftest_alloc_buf(struct binder_alloc *alloc,\n\t\t\t\t      struct binder_buffer *buffers[],\n\t\t\t\t      size_t *sizes, int *seq)\n{\n\tint i;\n\n\tfor (i = 0; i < BUFFER_NUM; i++) {\n\t\tbuffers[i] = binder_alloc_new_buf(alloc, sizes[i], 0, 0, 0, 0);\n\t\tif (IS_ERR(buffers[i]) ||\n\t\t    !check_buffer_pages_allocated(alloc, buffers[i],\n\t\t\t\t\t\t  sizes[i])) {\n\t\t\tpr_err_size_seq(sizes, seq);\n\t\t\tbinder_selftest_failures++;\n\t\t}\n\t}\n}\n\nstatic void binder_selftest_free_buf(struct binder_alloc *alloc,\n\t\t\t\t     struct binder_buffer *buffers[],\n\t\t\t\t     size_t *sizes, int *seq, size_t end)\n{\n\tint i;\n\n\tfor (i = 0; i < BUFFER_NUM; i++)\n\t\tbinder_alloc_free_buf(alloc, buffers[seq[i]]);\n\n\tfor (i = 0; i < end / PAGE_SIZE; i++) {\n\t\t \n\t\tif (list_empty(&alloc->pages[i].lru)) {\n\t\t\tpr_err_size_seq(sizes, seq);\n\t\t\tpr_err(\"expect lru but is %s at page index %d\\n\",\n\t\t\t       alloc->pages[i].page_ptr ? \"alloc\" : \"free\", i);\n\t\t\tbinder_selftest_failures++;\n\t\t}\n\t}\n}\n\nstatic void binder_selftest_free_page(struct binder_alloc *alloc)\n{\n\tint i;\n\tunsigned long count;\n\n\twhile ((count = list_lru_count(&binder_alloc_lru))) {\n\t\tlist_lru_walk(&binder_alloc_lru, binder_alloc_free_page,\n\t\t\t      NULL, count);\n\t}\n\n\tfor (i = 0; i < (alloc->buffer_size / PAGE_SIZE); i++) {\n\t\tif (alloc->pages[i].page_ptr) {\n\t\t\tpr_err(\"expect free but is %s at page index %d\\n\",\n\t\t\t       list_empty(&alloc->pages[i].lru) ?\n\t\t\t       \"alloc\" : \"lru\", i);\n\t\t\tbinder_selftest_failures++;\n\t\t}\n\t}\n}\n\nstatic void binder_selftest_alloc_free(struct binder_alloc *alloc,\n\t\t\t\t       size_t *sizes, int *seq, size_t end)\n{\n\tstruct binder_buffer *buffers[BUFFER_NUM];\n\n\tbinder_selftest_alloc_buf(alloc, buffers, sizes, seq);\n\tbinder_selftest_free_buf(alloc, buffers, sizes, seq, end);\n\n\t \n\tbinder_selftest_alloc_buf(alloc, buffers, sizes, seq);\n\tif (list_lru_count(&binder_alloc_lru))\n\t\tpr_err(\"lru list should be empty but is not\\n\");\n\n\tbinder_selftest_free_buf(alloc, buffers, sizes, seq, end);\n\tbinder_selftest_free_page(alloc);\n}\n\nstatic bool is_dup(int *seq, int index, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < index; i++) {\n\t\tif (seq[i] == val)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n \nstatic void binder_selftest_free_seq(struct binder_alloc *alloc,\n\t\t\t\t     size_t *sizes, int *seq,\n\t\t\t\t     int index, size_t end)\n{\n\tint i;\n\n\tif (index == BUFFER_NUM) {\n\t\tbinder_selftest_alloc_free(alloc, sizes, seq, end);\n\t\treturn;\n\t}\n\tfor (i = 0; i < BUFFER_NUM; i++) {\n\t\tif (is_dup(seq, index, i))\n\t\t\tcontinue;\n\t\tseq[index] = i;\n\t\tbinder_selftest_free_seq(alloc, sizes, seq, index + 1, end);\n\t}\n}\n\nstatic void binder_selftest_alloc_size(struct binder_alloc *alloc,\n\t\t\t\t       size_t *end_offset)\n{\n\tint i;\n\tint seq[BUFFER_NUM] = {0};\n\tsize_t front_sizes[BUFFER_NUM];\n\tsize_t back_sizes[BUFFER_NUM];\n\tsize_t last_offset, offset = 0;\n\n\tfor (i = 0; i < BUFFER_NUM; i++) {\n\t\tlast_offset = offset;\n\t\toffset = end_offset[i];\n\t\tfront_sizes[i] = offset - last_offset;\n\t\tback_sizes[BUFFER_NUM - i - 1] = front_sizes[i];\n\t}\n\t \n\tback_sizes[0] += alloc->buffer_size - end_offset[BUFFER_NUM - 1];\n\tbinder_selftest_free_seq(alloc, front_sizes, seq, 0,\n\t\t\t\t end_offset[BUFFER_NUM - 1]);\n\tbinder_selftest_free_seq(alloc, back_sizes, seq, 0, alloc->buffer_size);\n}\n\nstatic void binder_selftest_alloc_offset(struct binder_alloc *alloc,\n\t\t\t\t\t size_t *end_offset, int index)\n{\n\tint align;\n\tsize_t end, prev;\n\n\tif (index == BUFFER_NUM) {\n\t\tbinder_selftest_alloc_size(alloc, end_offset);\n\t\treturn;\n\t}\n\tprev = index == 0 ? 0 : end_offset[index - 1];\n\tend = prev;\n\n\tBUILD_BUG_ON(BUFFER_MIN_SIZE * BUFFER_NUM >= PAGE_SIZE);\n\n\tfor (align = SAME_PAGE_UNALIGNED; align < LOOP_END; align++) {\n\t\tif (align % 2)\n\t\t\tend = ALIGN(end, PAGE_SIZE);\n\t\telse\n\t\t\tend += BUFFER_MIN_SIZE;\n\t\tend_offset[index] = end;\n\t\tbinder_selftest_alloc_offset(alloc, end_offset, index + 1);\n\t}\n}\n\n \nvoid binder_selftest_alloc(struct binder_alloc *alloc)\n{\n\tsize_t end_offset[BUFFER_NUM];\n\n\tif (!binder_selftest_run)\n\t\treturn;\n\tmutex_lock(&binder_selftest_lock);\n\tif (!binder_selftest_run || !alloc->vma)\n\t\tgoto done;\n\tpr_info(\"STARTED\\n\");\n\tbinder_selftest_alloc_offset(alloc, end_offset, 0);\n\tbinder_selftest_run = false;\n\tif (binder_selftest_failures > 0)\n\t\tpr_info(\"%d tests FAILED\\n\", binder_selftest_failures);\n\telse\n\t\tpr_info(\"PASSED\\n\");\n\ndone:\n\tmutex_unlock(&binder_selftest_lock);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}