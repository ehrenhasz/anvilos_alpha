{
  "module_name": "remoteproc_cdev.c",
  "hash_id": "c6449c67e9dc178f10edf6fc7136cebb6ba438bad27c6d3251091d30dcad79cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_cdev.c",
  "human_readable_source": "\n \n\n#include <linux/cdev.h>\n#include <linux/compat.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n#include <linux/remoteproc.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/remoteproc_cdev.h>\n\n#include \"remoteproc_internal.h\"\n\n#define NUM_RPROC_DEVICES\t64\nstatic dev_t rproc_major;\n\nstatic ssize_t rproc_cdev_write(struct file *filp, const char __user *buf, size_t len, loff_t *pos)\n{\n\tstruct rproc *rproc = container_of(filp->f_inode->i_cdev, struct rproc, cdev);\n\tint ret = 0;\n\tchar cmd[10];\n\n\tif (!len || len > sizeof(cmd))\n\t\treturn -EINVAL;\n\n\tret = copy_from_user(cmd, buf, len);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\tif (!strncmp(cmd, \"start\", len)) {\n\t\tret = rproc_boot(rproc);\n\t} else if (!strncmp(cmd, \"stop\", len)) {\n\t\tret = rproc_shutdown(rproc);\n\t} else if (!strncmp(cmd, \"detach\", len)) {\n\t\tret = rproc_detach(rproc);\n\t} else {\n\t\tdev_err(&rproc->dev, \"Unrecognized option\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ? ret : len;\n}\n\nstatic long rproc_device_ioctl(struct file *filp, unsigned int ioctl, unsigned long arg)\n{\n\tstruct rproc *rproc = container_of(filp->f_inode->i_cdev, struct rproc, cdev);\n\tvoid __user *argp = (void __user *)arg;\n\ts32 param;\n\n\tswitch (ioctl) {\n\tcase RPROC_SET_SHUTDOWN_ON_RELEASE:\n\t\tif (copy_from_user(&param, argp, sizeof(s32)))\n\t\t\treturn -EFAULT;\n\n\t\trproc->cdev_put_on_release = !!param;\n\t\tbreak;\n\tcase RPROC_GET_SHUTDOWN_ON_RELEASE:\n\t\tparam = (s32)rproc->cdev_put_on_release;\n\t\tif (copy_to_user(argp, &param, sizeof(s32)))\n\t\t\treturn -EFAULT;\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&rproc->dev, \"Unsupported ioctl\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int rproc_cdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rproc *rproc = container_of(inode->i_cdev, struct rproc, cdev);\n\tint ret = 0;\n\n\tif (!rproc->cdev_put_on_release)\n\t\treturn 0;\n\n\tif (rproc->state == RPROC_RUNNING)\n\t\trproc_shutdown(rproc);\n\telse if (rproc->state == RPROC_ATTACHED)\n\t\tret = rproc_detach(rproc);\n\n\treturn ret;\n}\n\nstatic const struct file_operations rproc_fops = {\n\t.write = rproc_cdev_write,\n\t.unlocked_ioctl = rproc_device_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n\t.release = rproc_cdev_release,\n};\n\nint rproc_char_device_add(struct rproc *rproc)\n{\n\tint ret;\n\n\tcdev_init(&rproc->cdev, &rproc_fops);\n\trproc->cdev.owner = THIS_MODULE;\n\n\trproc->dev.devt = MKDEV(MAJOR(rproc_major), rproc->index);\n\tcdev_set_parent(&rproc->cdev, &rproc->dev.kobj);\n\tret = cdev_add(&rproc->cdev, rproc->dev.devt, 1);\n\tif (ret < 0)\n\t\tdev_err(&rproc->dev, \"Failed to add char dev for %s\\n\", rproc->name);\n\n\treturn ret;\n}\n\nvoid rproc_char_device_remove(struct rproc *rproc)\n{\n\tcdev_del(&rproc->cdev);\n}\n\nvoid __init rproc_init_cdev(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rproc_major, 0, NUM_RPROC_DEVICES, \"remoteproc\");\n\tif (ret < 0)\n\t\tpr_err(\"Failed to alloc rproc_cdev region, err %d\\n\", ret);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}