{
  "module_name": "remoteproc_core.c",
  "hash_id": "6a32fcfe0e7a621c9999753dd4e6bcfad3c6f708dab3c99ec2ac53bccf5fd908",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    \"%s: \" fmt, __func__\n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/panic_notifier.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/string.h>\n#include <linux/debugfs.h>\n#include <linux/rculist.h>\n#include <linux/remoteproc.h>\n#include <linux/iommu.h>\n#include <linux/idr.h>\n#include <linux/elf.h>\n#include <linux/crc32.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_ring.h>\n#include <asm/byteorder.h>\n#include <linux/platform_device.h>\n\n#include \"remoteproc_internal.h\"\n\n#define HIGH_BITS_MASK 0xFFFFFFFF00000000ULL\n\nstatic DEFINE_MUTEX(rproc_list_mutex);\nstatic LIST_HEAD(rproc_list);\nstatic struct notifier_block rproc_panic_nb;\n\ntypedef int (*rproc_handle_resource_t)(struct rproc *rproc,\n\t\t\t\t void *, int offset, int avail);\n\nstatic int rproc_alloc_carveout(struct rproc *rproc,\n\t\t\t\tstruct rproc_mem_entry *mem);\nstatic int rproc_release_carveout(struct rproc *rproc,\n\t\t\t\t  struct rproc_mem_entry *mem);\n\n \nstatic DEFINE_IDA(rproc_dev_index);\nstatic struct workqueue_struct *rproc_recovery_wq;\n\nstatic const char * const rproc_crash_names[] = {\n\t[RPROC_MMUFAULT]\t= \"mmufault\",\n\t[RPROC_WATCHDOG]\t= \"watchdog\",\n\t[RPROC_FATAL_ERROR]\t= \"fatal error\",\n};\n\n \nstatic const char *rproc_crash_to_string(enum rproc_crash_type type)\n{\n\tif (type < ARRAY_SIZE(rproc_crash_names))\n\t\treturn rproc_crash_names[type];\n\treturn \"unknown\";\n}\n\n \nstatic int rproc_iommu_fault(struct iommu_domain *domain, struct device *dev,\n\t\t\t     unsigned long iova, int flags, void *token)\n{\n\tstruct rproc *rproc = token;\n\n\tdev_err(dev, \"iommu fault: da 0x%lx flags 0x%x\\n\", iova, flags);\n\n\trproc_report_crash(rproc, RPROC_MMUFAULT);\n\n\t \n\treturn -ENOSYS;\n}\n\nstatic int rproc_enable_iommu(struct rproc *rproc)\n{\n\tstruct iommu_domain *domain;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\n\tif (!rproc->has_iommu) {\n\t\tdev_dbg(dev, \"iommu not present\\n\");\n\t\treturn 0;\n\t}\n\n\tdomain = iommu_domain_alloc(dev->bus);\n\tif (!domain) {\n\t\tdev_err(dev, \"can't alloc iommu domain\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tiommu_set_fault_handler(domain, rproc_iommu_fault, rproc);\n\n\tret = iommu_attach_device(domain, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"can't attach iommu device: %d\\n\", ret);\n\t\tgoto free_domain;\n\t}\n\n\trproc->domain = domain;\n\n\treturn 0;\n\nfree_domain:\n\tiommu_domain_free(domain);\n\treturn ret;\n}\n\nstatic void rproc_disable_iommu(struct rproc *rproc)\n{\n\tstruct iommu_domain *domain = rproc->domain;\n\tstruct device *dev = rproc->dev.parent;\n\n\tif (!domain)\n\t\treturn;\n\n\tiommu_detach_device(domain, dev);\n\tiommu_domain_free(domain);\n}\n\nphys_addr_t rproc_va_to_pa(void *cpu_addr)\n{\n\t \n\tif (is_vmalloc_addr(cpu_addr)) {\n\t\treturn page_to_phys(vmalloc_to_page(cpu_addr)) +\n\t\t\t\t    offset_in_page(cpu_addr);\n\t}\n\n\tWARN_ON(!virt_addr_valid(cpu_addr));\n\treturn virt_to_phys(cpu_addr);\n}\nEXPORT_SYMBOL(rproc_va_to_pa);\n\n \nvoid *rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct rproc_mem_entry *carveout;\n\tvoid *ptr = NULL;\n\n\tif (rproc->ops->da_to_va) {\n\t\tptr = rproc->ops->da_to_va(rproc, da, len, is_iomem);\n\t\tif (ptr)\n\t\t\tgoto out;\n\t}\n\n\tlist_for_each_entry(carveout, &rproc->carveouts, node) {\n\t\tint offset = da - carveout->da;\n\n\t\t \n\t\tif (!carveout->va)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (offset < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (offset + len > carveout->len)\n\t\t\tcontinue;\n\n\t\tptr = carveout->va + offset;\n\n\t\tif (is_iomem)\n\t\t\t*is_iomem = carveout->is_iomem;\n\n\t\tbreak;\n\t}\n\nout:\n\treturn ptr;\n}\nEXPORT_SYMBOL(rproc_da_to_va);\n\n \n__printf(2, 3)\nstruct rproc_mem_entry *\nrproc_find_carveout_by_name(struct rproc *rproc, const char *name, ...)\n{\n\tva_list args;\n\tchar _name[32];\n\tstruct rproc_mem_entry *carveout, *mem = NULL;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tva_start(args, name);\n\tvsnprintf(_name, sizeof(_name), name, args);\n\tva_end(args);\n\n\tlist_for_each_entry(carveout, &rproc->carveouts, node) {\n\t\t \n\t\tif (!strcmp(carveout->name, _name)) {\n\t\t\tmem = carveout;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn mem;\n}\n\n \nstatic int rproc_check_carveout_da(struct rproc *rproc,\n\t\t\t\t   struct rproc_mem_entry *mem, u32 da, u32 len)\n{\n\tstruct device *dev = &rproc->dev;\n\tint delta;\n\n\t \n\tif (len > mem->len) {\n\t\tdev_err(dev, \"Registered carveout doesn't fit len request\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (da != FW_RSC_ADDR_ANY && mem->da == FW_RSC_ADDR_ANY) {\n\t\t \n\t\treturn -EINVAL;\n\t} else if (da != FW_RSC_ADDR_ANY && mem->da != FW_RSC_ADDR_ANY) {\n\t\tdelta = da - mem->da;\n\n\t\t \n\t\tif (delta < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Registered carveout doesn't fit da request\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (delta + len > mem->len) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Registered carveout doesn't fit len request\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint rproc_alloc_vring(struct rproc_vdev *rvdev, int i)\n{\n\tstruct rproc *rproc = rvdev->rproc;\n\tstruct device *dev = &rproc->dev;\n\tstruct rproc_vring *rvring = &rvdev->vring[i];\n\tstruct fw_rsc_vdev *rsc;\n\tint ret, notifyid;\n\tstruct rproc_mem_entry *mem;\n\tsize_t size;\n\n\t \n\tsize = PAGE_ALIGN(vring_size(rvring->num, rvring->align));\n\n\trsc = (void *)rproc->table_ptr + rvdev->rsc_offset;\n\n\t \n\tmem = rproc_find_carveout_by_name(rproc, \"vdev%dvring%d\", rvdev->index,\n\t\t\t\t\t  i);\n\tif (mem) {\n\t\tif (rproc_check_carveout_da(rproc, mem, rsc->vring[i].da, size))\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\t \n\t\tmem = rproc_mem_entry_init(dev, NULL, 0,\n\t\t\t\t\t   size, rsc->vring[i].da,\n\t\t\t\t\t   rproc_alloc_carveout,\n\t\t\t\t\t   rproc_release_carveout,\n\t\t\t\t\t   \"vdev%dvring%d\",\n\t\t\t\t\t   rvdev->index, i);\n\t\tif (!mem) {\n\t\t\tdev_err(dev, \"Can't allocate memory entry structure\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t}\n\n\t \n\tret = idr_alloc(&rproc->notifyids, rvring, 0, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"idr_alloc failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tnotifyid = ret;\n\n\t \n\tif (notifyid > rproc->max_notifyid)\n\t\trproc->max_notifyid = notifyid;\n\n\trvring->notifyid = notifyid;\n\n\t \n\trsc->vring[i].notifyid = notifyid;\n\treturn 0;\n}\n\nint\nrproc_parse_vring(struct rproc_vdev *rvdev, struct fw_rsc_vdev *rsc, int i)\n{\n\tstruct rproc *rproc = rvdev->rproc;\n\tstruct device *dev = &rproc->dev;\n\tstruct fw_rsc_vdev_vring *vring = &rsc->vring[i];\n\tstruct rproc_vring *rvring = &rvdev->vring[i];\n\n\tdev_dbg(dev, \"vdev rsc: vring%d: da 0x%x, qsz %d, align %d\\n\",\n\t\ti, vring->da, vring->num, vring->align);\n\n\t \n\tif (!vring->num || !vring->align) {\n\t\tdev_err(dev, \"invalid qsz (%d) or alignment (%d)\\n\",\n\t\t\tvring->num, vring->align);\n\t\treturn -EINVAL;\n\t}\n\n\trvring->num = vring->num;\n\trvring->align = vring->align;\n\trvring->rvdev = rvdev;\n\n\treturn 0;\n}\n\nvoid rproc_free_vring(struct rproc_vring *rvring)\n{\n\tstruct rproc *rproc = rvring->rvdev->rproc;\n\tint idx = rvring - rvring->rvdev->vring;\n\tstruct fw_rsc_vdev *rsc;\n\n\tidr_remove(&rproc->notifyids, rvring->notifyid);\n\n\t \n\tif (rproc->table_ptr) {\n\t\trsc = (void *)rproc->table_ptr + rvring->rvdev->rsc_offset;\n\t\trsc->vring[idx].da = 0;\n\t\trsc->vring[idx].notifyid = -1;\n\t}\n}\n\nvoid rproc_add_rvdev(struct rproc *rproc, struct rproc_vdev *rvdev)\n{\n\tif (rvdev && rproc)\n\t\tlist_add_tail(&rvdev->node, &rproc->rvdevs);\n}\n\nvoid rproc_remove_rvdev(struct rproc_vdev *rvdev)\n{\n\tif (rvdev)\n\t\tlist_del(&rvdev->node);\n}\n \nstatic int rproc_handle_vdev(struct rproc *rproc, void *ptr,\n\t\t\t     int offset, int avail)\n{\n\tstruct fw_rsc_vdev *rsc = ptr;\n\tstruct device *dev = &rproc->dev;\n\tstruct rproc_vdev *rvdev;\n\tsize_t rsc_size;\n\tstruct rproc_vdev_data rvdev_data;\n\tstruct platform_device *pdev;\n\n\t \n\trsc_size = struct_size(rsc, vring, rsc->num_of_vrings);\n\tif (size_add(rsc_size, rsc->config_len) > avail) {\n\t\tdev_err(dev, \"vdev rsc is truncated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rsc->reserved[0] || rsc->reserved[1]) {\n\t\tdev_err(dev, \"vdev rsc has non zero reserved bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"vdev rsc: id %d, dfeatures 0x%x, cfg len %d, %d vrings\\n\",\n\t\trsc->id, rsc->dfeatures, rsc->config_len, rsc->num_of_vrings);\n\n\t \n\tif (rsc->num_of_vrings > ARRAY_SIZE(rvdev->vring)) {\n\t\tdev_err(dev, \"too many vrings: %d\\n\", rsc->num_of_vrings);\n\t\treturn -EINVAL;\n\t}\n\n\trvdev_data.id = rsc->id;\n\trvdev_data.index = rproc->nb_vdev++;\n\trvdev_data.rsc_offset = offset;\n\trvdev_data.rsc = rsc;\n\n\t \n\tpdev = platform_device_register_data(dev, \"rproc-virtio\", PLATFORM_DEVID_AUTO, &rvdev_data,\n\t\t\t\t\t     sizeof(rvdev_data));\n\tif (IS_ERR(pdev)) {\n\t\tdev_err(dev, \"failed to create rproc-virtio device\\n\");\n\t\treturn PTR_ERR(pdev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int rproc_handle_trace(struct rproc *rproc, void *ptr,\n\t\t\t      int offset, int avail)\n{\n\tstruct fw_rsc_trace *rsc = ptr;\n\tstruct rproc_debug_trace *trace;\n\tstruct device *dev = &rproc->dev;\n\tchar name[15];\n\n\tif (sizeof(*rsc) > avail) {\n\t\tdev_err(dev, \"trace rsc is truncated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rsc->reserved) {\n\t\tdev_err(dev, \"trace rsc has non zero reserved bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ttrace = kzalloc(sizeof(*trace), GFP_KERNEL);\n\tif (!trace)\n\t\treturn -ENOMEM;\n\n\t \n\ttrace->trace_mem.len = rsc->len;\n\ttrace->trace_mem.da = rsc->da;\n\n\t \n\ttrace->rproc = rproc;\n\n\t \n\tsnprintf(name, sizeof(name), \"trace%d\", rproc->num_traces);\n\n\t \n\ttrace->tfile = rproc_create_trace_file(name, rproc, trace);\n\n\tlist_add_tail(&trace->node, &rproc->traces);\n\n\trproc->num_traces++;\n\n\tdev_dbg(dev, \"%s added: da 0x%x, len 0x%x\\n\",\n\t\tname, rsc->da, rsc->len);\n\n\treturn 0;\n}\n\n \nstatic int rproc_handle_devmem(struct rproc *rproc, void *ptr,\n\t\t\t       int offset, int avail)\n{\n\tstruct fw_rsc_devmem *rsc = ptr;\n\tstruct rproc_mem_entry *mapping;\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\t \n\tif (!rproc->domain)\n\t\treturn -EINVAL;\n\n\tif (sizeof(*rsc) > avail) {\n\t\tdev_err(dev, \"devmem rsc is truncated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rsc->reserved) {\n\t\tdev_err(dev, \"devmem rsc has non zero reserved bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\tif (!mapping)\n\t\treturn -ENOMEM;\n\n\tret = iommu_map(rproc->domain, rsc->da, rsc->pa, rsc->len, rsc->flags,\n\t\t\tGFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to map devmem: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\tmapping->da = rsc->da;\n\tmapping->len = rsc->len;\n\tlist_add_tail(&mapping->node, &rproc->mappings);\n\n\tdev_dbg(dev, \"mapped devmem pa 0x%x, da 0x%x, len 0x%x\\n\",\n\t\trsc->pa, rsc->da, rsc->len);\n\n\treturn 0;\n\nout:\n\tkfree(mapping);\n\treturn ret;\n}\n\n \nstatic int rproc_alloc_carveout(struct rproc *rproc,\n\t\t\t\tstruct rproc_mem_entry *mem)\n{\n\tstruct rproc_mem_entry *mapping = NULL;\n\tstruct device *dev = &rproc->dev;\n\tdma_addr_t dma;\n\tvoid *va;\n\tint ret;\n\n\tva = dma_alloc_coherent(dev->parent, mem->len, &dma, GFP_KERNEL);\n\tif (!va) {\n\t\tdev_err(dev->parent,\n\t\t\t\"failed to allocate dma memory: len 0x%zx\\n\",\n\t\t\tmem->len);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(dev, \"carveout va %pK, dma %pad, len 0x%zx\\n\",\n\t\tva, &dma, mem->len);\n\n\tif (mem->da != FW_RSC_ADDR_ANY && !rproc->domain) {\n\t\t \n\t\tif (mem->da != (u32)dma)\n\t\t\tdev_warn(dev->parent,\n\t\t\t\t \"Allocated carveout doesn't fit device address request\\n\");\n\t}\n\n\t \n\tif (mem->da != FW_RSC_ADDR_ANY && rproc->domain) {\n\t\tmapping = kzalloc(sizeof(*mapping), GFP_KERNEL);\n\t\tif (!mapping) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dma_free;\n\t\t}\n\n\t\tret = iommu_map(rproc->domain, mem->da, dma, mem->len,\n\t\t\t\tmem->flags, GFP_KERNEL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"iommu_map failed: %d\\n\", ret);\n\t\t\tgoto free_mapping;\n\t\t}\n\n\t\t \n\t\tmapping->da = mem->da;\n\t\tmapping->len = mem->len;\n\t\tlist_add_tail(&mapping->node, &rproc->mappings);\n\n\t\tdev_dbg(dev, \"carveout mapped 0x%x to %pad\\n\",\n\t\t\tmem->da, &dma);\n\t}\n\n\tif (mem->da == FW_RSC_ADDR_ANY) {\n\t\t \n\t\tif ((u64)dma & HIGH_BITS_MASK)\n\t\t\tdev_warn(dev, \"DMA address cast in 32bit to fit resource table format\\n\");\n\n\t\tmem->da = (u32)dma;\n\t}\n\n\tmem->dma = dma;\n\tmem->va = va;\n\n\treturn 0;\n\nfree_mapping:\n\tkfree(mapping);\ndma_free:\n\tdma_free_coherent(dev->parent, mem->len, va, dma);\n\treturn ret;\n}\n\n \nstatic int rproc_release_carveout(struct rproc *rproc,\n\t\t\t\t  struct rproc_mem_entry *mem)\n{\n\tstruct device *dev = &rproc->dev;\n\n\t \n\tdma_free_coherent(dev->parent, mem->len, mem->va, mem->dma);\n\treturn 0;\n}\n\n \nstatic int rproc_handle_carveout(struct rproc *rproc,\n\t\t\t\t void *ptr, int offset, int avail)\n{\n\tstruct fw_rsc_carveout *rsc = ptr;\n\tstruct rproc_mem_entry *carveout;\n\tstruct device *dev = &rproc->dev;\n\n\tif (sizeof(*rsc) > avail) {\n\t\tdev_err(dev, \"carveout rsc is truncated\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rsc->reserved) {\n\t\tdev_err(dev, \"carveout rsc has non zero reserved bytes\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"carveout rsc: name: %s, da 0x%x, pa 0x%x, len 0x%x, flags 0x%x\\n\",\n\t\trsc->name, rsc->da, rsc->pa, rsc->len, rsc->flags);\n\n\t \n\tcarveout = rproc_find_carveout_by_name(rproc, rsc->name);\n\n\tif (carveout) {\n\t\tif (carveout->rsc_offset != FW_RSC_ADDR_ANY) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Carveout already associated to resource table\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (rproc_check_carveout_da(rproc, carveout, rsc->da, rsc->len))\n\t\t\treturn -ENOMEM;\n\n\t\t \n\t\tcarveout->rsc_offset = offset;\n\t\tcarveout->flags = rsc->flags;\n\n\t\treturn 0;\n\t}\n\n\t \n\tcarveout = rproc_mem_entry_init(dev, NULL, 0, rsc->len, rsc->da,\n\t\t\t\t\trproc_alloc_carveout,\n\t\t\t\t\trproc_release_carveout, rsc->name);\n\tif (!carveout) {\n\t\tdev_err(dev, \"Can't allocate memory entry structure\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tcarveout->flags = rsc->flags;\n\tcarveout->rsc_offset = offset;\n\trproc_add_carveout(rproc, carveout);\n\n\treturn 0;\n}\n\n \nvoid rproc_add_carveout(struct rproc *rproc, struct rproc_mem_entry *mem)\n{\n\tlist_add_tail(&mem->node, &rproc->carveouts);\n}\nEXPORT_SYMBOL(rproc_add_carveout);\n\n \n__printf(8, 9)\nstruct rproc_mem_entry *\nrproc_mem_entry_init(struct device *dev,\n\t\t     void *va, dma_addr_t dma, size_t len, u32 da,\n\t\t     int (*alloc)(struct rproc *, struct rproc_mem_entry *),\n\t\t     int (*release)(struct rproc *, struct rproc_mem_entry *),\n\t\t     const char *name, ...)\n{\n\tstruct rproc_mem_entry *mem;\n\tva_list args;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn mem;\n\n\tmem->va = va;\n\tmem->dma = dma;\n\tmem->da = da;\n\tmem->len = len;\n\tmem->alloc = alloc;\n\tmem->release = release;\n\tmem->rsc_offset = FW_RSC_ADDR_ANY;\n\tmem->of_resm_idx = -1;\n\n\tva_start(args, name);\n\tvsnprintf(mem->name, sizeof(mem->name), name, args);\n\tva_end(args);\n\n\treturn mem;\n}\nEXPORT_SYMBOL(rproc_mem_entry_init);\n\n \n__printf(5, 6)\nstruct rproc_mem_entry *\nrproc_of_resm_mem_entry_init(struct device *dev, u32 of_resm_idx, size_t len,\n\t\t\t     u32 da, const char *name, ...)\n{\n\tstruct rproc_mem_entry *mem;\n\tva_list args;\n\n\tmem = kzalloc(sizeof(*mem), GFP_KERNEL);\n\tif (!mem)\n\t\treturn mem;\n\n\tmem->da = da;\n\tmem->len = len;\n\tmem->rsc_offset = FW_RSC_ADDR_ANY;\n\tmem->of_resm_idx = of_resm_idx;\n\n\tva_start(args, name);\n\tvsnprintf(mem->name, sizeof(mem->name), name, args);\n\tva_end(args);\n\n\treturn mem;\n}\nEXPORT_SYMBOL(rproc_of_resm_mem_entry_init);\n\n \nint rproc_of_parse_firmware(struct device *dev, int index, const char **fw_name)\n{\n\tint ret;\n\n\tret = of_property_read_string_index(dev->of_node, \"firmware-name\",\n\t\t\t\t\t    index, fw_name);\n\treturn ret ? ret : 0;\n}\nEXPORT_SYMBOL(rproc_of_parse_firmware);\n\n \nstatic rproc_handle_resource_t rproc_loading_handlers[RSC_LAST] = {\n\t[RSC_CARVEOUT] = rproc_handle_carveout,\n\t[RSC_DEVMEM] = rproc_handle_devmem,\n\t[RSC_TRACE] = rproc_handle_trace,\n\t[RSC_VDEV] = rproc_handle_vdev,\n};\n\n \nstatic int rproc_handle_resources(struct rproc *rproc,\n\t\t\t\t  rproc_handle_resource_t handlers[RSC_LAST])\n{\n\tstruct device *dev = &rproc->dev;\n\trproc_handle_resource_t handler;\n\tint ret = 0, i;\n\n\tif (!rproc->table_ptr)\n\t\treturn 0;\n\n\tfor (i = 0; i < rproc->table_ptr->num; i++) {\n\t\tint offset = rproc->table_ptr->offset[i];\n\t\tstruct fw_rsc_hdr *hdr = (void *)rproc->table_ptr + offset;\n\t\tint avail = rproc->table_sz - offset - sizeof(*hdr);\n\t\tvoid *rsc = (void *)hdr + sizeof(*hdr);\n\n\t\t \n\t\tif (avail < 0) {\n\t\t\tdev_err(dev, \"rsc table is truncated\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tdev_dbg(dev, \"rsc: type %d\\n\", hdr->type);\n\n\t\tif (hdr->type >= RSC_VENDOR_START &&\n\t\t    hdr->type <= RSC_VENDOR_END) {\n\t\t\tret = rproc_handle_rsc(rproc, hdr->type, rsc,\n\t\t\t\t\t       offset + sizeof(*hdr), avail);\n\t\t\tif (ret == RSC_HANDLED)\n\t\t\t\tcontinue;\n\t\t\telse if (ret < 0)\n\t\t\t\tbreak;\n\n\t\t\tdev_warn(dev, \"unsupported vendor resource %d\\n\",\n\t\t\t\t hdr->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (hdr->type >= RSC_LAST) {\n\t\t\tdev_warn(dev, \"unsupported resource %d\\n\", hdr->type);\n\t\t\tcontinue;\n\t\t}\n\n\t\thandler = handlers[hdr->type];\n\t\tif (!handler)\n\t\t\tcontinue;\n\n\t\tret = handler(rproc, rsc, offset + sizeof(*hdr), avail);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int rproc_prepare_subdevices(struct rproc *rproc)\n{\n\tstruct rproc_subdev *subdev;\n\tint ret;\n\n\tlist_for_each_entry(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->prepare) {\n\t\t\tret = subdev->prepare(subdev);\n\t\t\tif (ret)\n\t\t\t\tgoto unroll_preparation;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll_preparation:\n\tlist_for_each_entry_continue_reverse(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->unprepare)\n\t\t\tsubdev->unprepare(subdev);\n\t}\n\n\treturn ret;\n}\n\nstatic int rproc_start_subdevices(struct rproc *rproc)\n{\n\tstruct rproc_subdev *subdev;\n\tint ret;\n\n\tlist_for_each_entry(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->start) {\n\t\t\tret = subdev->start(subdev);\n\t\t\tif (ret)\n\t\t\t\tgoto unroll_registration;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll_registration:\n\tlist_for_each_entry_continue_reverse(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->stop)\n\t\t\tsubdev->stop(subdev, true);\n\t}\n\n\treturn ret;\n}\n\nstatic void rproc_stop_subdevices(struct rproc *rproc, bool crashed)\n{\n\tstruct rproc_subdev *subdev;\n\n\tlist_for_each_entry_reverse(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->stop)\n\t\t\tsubdev->stop(subdev, crashed);\n\t}\n}\n\nstatic void rproc_unprepare_subdevices(struct rproc *rproc)\n{\n\tstruct rproc_subdev *subdev;\n\n\tlist_for_each_entry_reverse(subdev, &rproc->subdevs, node) {\n\t\tif (subdev->unprepare)\n\t\t\tsubdev->unprepare(subdev);\n\t}\n}\n\n \nstatic int rproc_alloc_registered_carveouts(struct rproc *rproc)\n{\n\tstruct rproc_mem_entry *entry, *tmp;\n\tstruct fw_rsc_carveout *rsc;\n\tstruct device *dev = &rproc->dev;\n\tu64 pa;\n\tint ret;\n\n\tlist_for_each_entry_safe(entry, tmp, &rproc->carveouts, node) {\n\t\tif (entry->alloc) {\n\t\t\tret = entry->alloc(rproc, entry);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Unable to allocate carveout %s: %d\\n\",\n\t\t\t\t\tentry->name, ret);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tif (entry->rsc_offset != FW_RSC_ADDR_ANY) {\n\t\t\t \n\t\t\trsc = (void *)rproc->table_ptr + entry->rsc_offset;\n\n\t\t\t \n\n\t\t\t \n\t\t\tif (entry->va)\n\t\t\t\tpa = (u64)rproc_va_to_pa(entry->va);\n\t\t\telse\n\t\t\t\tpa = (u64)entry->dma;\n\n\t\t\tif (((u64)pa) & HIGH_BITS_MASK)\n\t\t\t\tdev_warn(dev,\n\t\t\t\t\t \"Physical address cast in 32bit to fit resource table format\\n\");\n\n\t\t\trsc->pa = (u32)pa;\n\t\t\trsc->da = entry->da;\n\t\t\trsc->len = entry->len;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n \nvoid rproc_resource_cleanup(struct rproc *rproc)\n{\n\tstruct rproc_mem_entry *entry, *tmp;\n\tstruct rproc_debug_trace *trace, *ttmp;\n\tstruct rproc_vdev *rvdev, *rvtmp;\n\tstruct device *dev = &rproc->dev;\n\n\t \n\tlist_for_each_entry_safe(trace, ttmp, &rproc->traces, node) {\n\t\trproc_remove_trace_file(trace->tfile);\n\t\trproc->num_traces--;\n\t\tlist_del(&trace->node);\n\t\tkfree(trace);\n\t}\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &rproc->mappings, node) {\n\t\tsize_t unmapped;\n\n\t\tunmapped = iommu_unmap(rproc->domain, entry->da, entry->len);\n\t\tif (unmapped != entry->len) {\n\t\t\t \n\t\t\tdev_err(dev, \"failed to unmap %zx/%zu\\n\", entry->len,\n\t\t\t\tunmapped);\n\t\t}\n\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n\n\t \n\tlist_for_each_entry_safe(entry, tmp, &rproc->carveouts, node) {\n\t\tif (entry->release)\n\t\t\tentry->release(rproc, entry);\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n\n\t \n\tlist_for_each_entry_safe(rvdev, rvtmp, &rproc->rvdevs, node)\n\t\tplatform_device_unregister(rvdev->pdev);\n\n\trproc_coredump_cleanup(rproc);\n}\nEXPORT_SYMBOL(rproc_resource_cleanup);\n\nstatic int rproc_start(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct resource_table *loaded_table;\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\t \n\tret = rproc_load_segments(rproc, fw);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to load program segments: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tloaded_table = rproc_find_loaded_rsc_table(rproc, fw);\n\tif (loaded_table) {\n\t\tmemcpy(loaded_table, rproc->cached_table, rproc->table_sz);\n\t\trproc->table_ptr = loaded_table;\n\t}\n\n\tret = rproc_prepare_subdevices(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to prepare subdevices for %s: %d\\n\",\n\t\t\trproc->name, ret);\n\t\tgoto reset_table_ptr;\n\t}\n\n\t \n\tret = rproc->ops->start(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't start rproc %s: %d\\n\", rproc->name, ret);\n\t\tgoto unprepare_subdevices;\n\t}\n\n\t \n\tret = rproc_start_subdevices(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to probe subdevices for %s: %d\\n\",\n\t\t\trproc->name, ret);\n\t\tgoto stop_rproc;\n\t}\n\n\trproc->state = RPROC_RUNNING;\n\n\tdev_info(dev, \"remote processor %s is now up\\n\", rproc->name);\n\n\treturn 0;\n\nstop_rproc:\n\trproc->ops->stop(rproc);\nunprepare_subdevices:\n\trproc_unprepare_subdevices(rproc);\nreset_table_ptr:\n\trproc->table_ptr = rproc->cached_table;\n\n\treturn ret;\n}\n\nstatic int __rproc_attach(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\tret = rproc_prepare_subdevices(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to prepare subdevices for %s: %d\\n\",\n\t\t\trproc->name, ret);\n\t\tgoto out;\n\t}\n\n\t \n\tret = rproc_attach_device(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't attach to rproc %s: %d\\n\",\n\t\t\trproc->name, ret);\n\t\tgoto unprepare_subdevices;\n\t}\n\n\t \n\tret = rproc_start_subdevices(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to probe subdevices for %s: %d\\n\",\n\t\t\trproc->name, ret);\n\t\tgoto stop_rproc;\n\t}\n\n\trproc->state = RPROC_ATTACHED;\n\n\tdev_info(dev, \"remote processor %s is now attached\\n\", rproc->name);\n\n\treturn 0;\n\nstop_rproc:\n\trproc->ops->stop(rproc);\nunprepare_subdevices:\n\trproc_unprepare_subdevices(rproc);\nout:\n\treturn ret;\n}\n\n \nstatic int rproc_fw_boot(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = &rproc->dev;\n\tconst char *name = rproc->firmware;\n\tint ret;\n\n\tret = rproc_fw_sanity_check(rproc, fw);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"Booting fw image %s, size %zd\\n\", name, fw->size);\n\n\t \n\tret = rproc_enable_iommu(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable iommu: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rproc_prepare_device(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't prepare rproc %s: %d\\n\", rproc->name, ret);\n\t\tgoto disable_iommu;\n\t}\n\n\trproc->bootaddr = rproc_get_boot_addr(rproc, fw);\n\n\t \n\tret = rproc_parse_fw(rproc, fw);\n\tif (ret)\n\t\tgoto unprepare_rproc;\n\n\t \n\trproc->max_notifyid = -1;\n\n\t \n\trproc->nb_vdev = 0;\n\n\t \n\tret = rproc_handle_resources(rproc, rproc_loading_handlers);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to process resources: %d\\n\", ret);\n\t\tgoto clean_up_resources;\n\t}\n\n\t \n\tret = rproc_alloc_registered_carveouts(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate associated carveouts: %d\\n\",\n\t\t\tret);\n\t\tgoto clean_up_resources;\n\t}\n\n\tret = rproc_start(rproc, fw);\n\tif (ret)\n\t\tgoto clean_up_resources;\n\n\treturn 0;\n\nclean_up_resources:\n\trproc_resource_cleanup(rproc);\n\tkfree(rproc->cached_table);\n\trproc->cached_table = NULL;\n\trproc->table_ptr = NULL;\nunprepare_rproc:\n\t \n\trproc_unprepare_device(rproc);\ndisable_iommu:\n\trproc_disable_iommu(rproc);\n\treturn ret;\n}\n\nstatic int rproc_set_rsc_table(struct rproc *rproc)\n{\n\tstruct resource_table *table_ptr;\n\tstruct device *dev = &rproc->dev;\n\tsize_t table_sz;\n\tint ret;\n\n\ttable_ptr = rproc_get_loaded_rsc_table(rproc, &table_sz);\n\tif (!table_ptr) {\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (IS_ERR(table_ptr)) {\n\t\tret = PTR_ERR(table_ptr);\n\t\tdev_err(dev, \"can't load resource table: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (rproc->ops->detach) {\n\t\trproc->clean_table = kmemdup(table_ptr, table_sz, GFP_KERNEL);\n\t\tif (!rproc->clean_table)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\trproc->clean_table = NULL;\n\t}\n\n\trproc->cached_table = NULL;\n\trproc->table_ptr = table_ptr;\n\trproc->table_sz = table_sz;\n\n\treturn 0;\n}\n\nstatic int rproc_reset_rsc_table_on_detach(struct rproc *rproc)\n{\n\tstruct resource_table *table_ptr;\n\n\t \n\tif (!rproc->table_ptr)\n\t\treturn 0;\n\n\t \n\tif (WARN_ON(!rproc->clean_table))\n\t\treturn -EINVAL;\n\n\t \n\ttable_ptr = rproc->table_ptr;\n\n\t \n\trproc->cached_table = kmemdup(rproc->table_ptr,\n\t\t\t\t      rproc->table_sz, GFP_KERNEL);\n\tif (!rproc->cached_table)\n\t\treturn -ENOMEM;\n\n\t \n\trproc->table_ptr = rproc->cached_table;\n\n\t \n\tmemcpy(table_ptr, rproc->clean_table, rproc->table_sz);\n\n\t \n\tkfree(rproc->clean_table);\n\n\treturn 0;\n}\n\nstatic int rproc_reset_rsc_table_on_stop(struct rproc *rproc)\n{\n\t \n\tif (!rproc->table_ptr)\n\t\treturn 0;\n\n\t \n\tif (rproc->cached_table)\n\t\tgoto out;\n\n\t \n\trproc->cached_table = kmemdup(rproc->table_ptr,\n\t\t\t\t      rproc->table_sz, GFP_KERNEL);\n\tif (!rproc->cached_table)\n\t\treturn -ENOMEM;\n\n\t \n\tkfree(rproc->clean_table);\n\nout:\n\t \n\trproc->table_ptr = rproc->cached_table;\n\treturn 0;\n}\n\n \nstatic int rproc_attach(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\t \n\tret = rproc_enable_iommu(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't enable iommu: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rproc_prepare_device(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't prepare rproc %s: %d\\n\", rproc->name, ret);\n\t\tgoto disable_iommu;\n\t}\n\n\tret = rproc_set_rsc_table(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't load resource table: %d\\n\", ret);\n\t\tgoto unprepare_device;\n\t}\n\n\t \n\trproc->max_notifyid = -1;\n\n\t \n\trproc->nb_vdev = 0;\n\n\t \n\tret = rproc_handle_resources(rproc, rproc_loading_handlers);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to process resources: %d\\n\", ret);\n\t\tgoto unprepare_device;\n\t}\n\n\t \n\tret = rproc_alloc_registered_carveouts(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to allocate associated carveouts: %d\\n\",\n\t\t\tret);\n\t\tgoto clean_up_resources;\n\t}\n\n\tret = __rproc_attach(rproc);\n\tif (ret)\n\t\tgoto clean_up_resources;\n\n\treturn 0;\n\nclean_up_resources:\n\trproc_resource_cleanup(rproc);\nunprepare_device:\n\t \n\trproc_unprepare_device(rproc);\ndisable_iommu:\n\trproc_disable_iommu(rproc);\n\treturn ret;\n}\n\n \nstatic void rproc_auto_boot_callback(const struct firmware *fw, void *context)\n{\n\tstruct rproc *rproc = context;\n\n\trproc_boot(rproc);\n\n\trelease_firmware(fw);\n}\n\nstatic int rproc_trigger_auto_boot(struct rproc *rproc)\n{\n\tint ret;\n\n\t \n\tif (rproc->state == RPROC_DETACHED)\n\t\treturn rproc_boot(rproc);\n\n\t \n\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t      rproc->firmware, &rproc->dev, GFP_KERNEL,\n\t\t\t\t      rproc, rproc_auto_boot_callback);\n\tif (ret < 0)\n\t\tdev_err(&rproc->dev, \"request_firmware_nowait err: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int rproc_stop(struct rproc *rproc, bool crashed)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\t \n\tif (!rproc->ops->stop)\n\t\treturn -EINVAL;\n\n\t \n\trproc_stop_subdevices(rproc, crashed);\n\n\t \n\tret = rproc_reset_rsc_table_on_stop(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't reset resource table: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\n\t \n\tret = rproc->ops->stop(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't stop rproc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trproc_unprepare_subdevices(rproc);\n\n\trproc->state = RPROC_OFFLINE;\n\n\tdev_info(dev, \"stopped remote processor %s\\n\", rproc->name);\n\n\treturn 0;\n}\n\n \nstatic int __rproc_detach(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\t \n\tif (!rproc->ops->detach)\n\t\treturn -EINVAL;\n\n\t \n\trproc_stop_subdevices(rproc, false);\n\n\t \n\tret = rproc_reset_rsc_table_on_detach(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't reset resource table: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rproc->ops->detach(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"can't detach from rproc: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trproc_unprepare_subdevices(rproc);\n\n\trproc->state = RPROC_DETACHED;\n\n\tdev_info(dev, \"detached remote processor %s\\n\", rproc->name);\n\n\treturn 0;\n}\n\nstatic int rproc_attach_recovery(struct rproc *rproc)\n{\n\tint ret;\n\n\tret = __rproc_detach(rproc);\n\tif (ret)\n\t\treturn ret;\n\n\treturn __rproc_attach(rproc);\n}\n\nstatic int rproc_boot_recovery(struct rproc *rproc)\n{\n\tconst struct firmware *firmware_p;\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\tret = rproc_stop(rproc, true);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\trproc->ops->coredump(rproc);\n\n\t \n\tret = request_firmware(&firmware_p, rproc->firmware, dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"request_firmware failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = rproc_start(rproc, firmware_p);\n\n\trelease_firmware(firmware_p);\n\n\treturn ret;\n}\n\n \nint rproc_trigger_recovery(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&rproc->lock);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (rproc->state != RPROC_CRASHED)\n\t\tgoto unlock_mutex;\n\n\tdev_err(dev, \"recovering %s\\n\", rproc->name);\n\n\tif (rproc_has_feature(rproc, RPROC_FEAT_ATTACH_ON_RECOVERY))\n\t\tret = rproc_attach_recovery(rproc);\n\telse\n\t\tret = rproc_boot_recovery(rproc);\n\nunlock_mutex:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\n\n \nstatic void rproc_crash_handler_work(struct work_struct *work)\n{\n\tstruct rproc *rproc = container_of(work, struct rproc, crash_handler);\n\tstruct device *dev = &rproc->dev;\n\n\tdev_dbg(dev, \"enter %s\\n\", __func__);\n\n\tmutex_lock(&rproc->lock);\n\n\tif (rproc->state == RPROC_CRASHED) {\n\t\t \n\t\tmutex_unlock(&rproc->lock);\n\t\treturn;\n\t}\n\n\tif (rproc->state == RPROC_OFFLINE) {\n\t\t \n\t\tmutex_unlock(&rproc->lock);\n\t\tgoto out;\n\t}\n\n\trproc->state = RPROC_CRASHED;\n\tdev_err(dev, \"handling crash #%u in %s\\n\", ++rproc->crash_cnt,\n\t\trproc->name);\n\n\tmutex_unlock(&rproc->lock);\n\n\tif (!rproc->recovery_disabled)\n\t\trproc_trigger_recovery(rproc);\n\nout:\n\tpm_relax(rproc->dev.parent);\n}\n\n \nint rproc_boot(struct rproc *rproc)\n{\n\tconst struct firmware *firmware_p;\n\tstruct device *dev;\n\tint ret;\n\n\tif (!rproc) {\n\t\tpr_err(\"invalid rproc handle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev = &rproc->dev;\n\n\tret = mutex_lock_interruptible(&rproc->lock);\n\tif (ret) {\n\t\tdev_err(dev, \"can't lock rproc %s: %d\\n\", rproc->name, ret);\n\t\treturn ret;\n\t}\n\n\tif (rproc->state == RPROC_DELETED) {\n\t\tret = -ENODEV;\n\t\tdev_err(dev, \"can't boot deleted rproc %s\\n\", rproc->name);\n\t\tgoto unlock_mutex;\n\t}\n\n\t \n\tif (atomic_inc_return(&rproc->power) > 1) {\n\t\tret = 0;\n\t\tgoto unlock_mutex;\n\t}\n\n\tif (rproc->state == RPROC_DETACHED) {\n\t\tdev_info(dev, \"attaching to %s\\n\", rproc->name);\n\n\t\tret = rproc_attach(rproc);\n\t} else {\n\t\tdev_info(dev, \"powering up %s\\n\", rproc->name);\n\n\t\t \n\t\tret = request_firmware(&firmware_p, rproc->firmware, dev);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"request_firmware failed: %d\\n\", ret);\n\t\t\tgoto downref_rproc;\n\t\t}\n\n\t\tret = rproc_fw_boot(rproc, firmware_p);\n\n\t\trelease_firmware(firmware_p);\n\t}\n\ndownref_rproc:\n\tif (ret)\n\t\tatomic_dec(&rproc->power);\nunlock_mutex:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_boot);\n\n \nint rproc_shutdown(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret = 0;\n\n\tret = mutex_lock_interruptible(&rproc->lock);\n\tif (ret) {\n\t\tdev_err(dev, \"can't lock rproc %s: %d\\n\", rproc->name, ret);\n\t\treturn ret;\n\t}\n\n\tif (rproc->state != RPROC_RUNNING &&\n\t    rproc->state != RPROC_ATTACHED) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!atomic_dec_and_test(&rproc->power))\n\t\tgoto out;\n\n\tret = rproc_stop(rproc, false);\n\tif (ret) {\n\t\tatomic_inc(&rproc->power);\n\t\tgoto out;\n\t}\n\n\t \n\trproc_resource_cleanup(rproc);\n\n\t \n\trproc_unprepare_device(rproc);\n\n\trproc_disable_iommu(rproc);\n\n\t \n\tkfree(rproc->cached_table);\n\trproc->cached_table = NULL;\n\trproc->table_ptr = NULL;\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_shutdown);\n\n \nint rproc_detach(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\tret = mutex_lock_interruptible(&rproc->lock);\n\tif (ret) {\n\t\tdev_err(dev, \"can't lock rproc %s: %d\\n\", rproc->name, ret);\n\t\treturn ret;\n\t}\n\n\tif (rproc->state != RPROC_ATTACHED) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!atomic_dec_and_test(&rproc->power)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tret = __rproc_detach(rproc);\n\tif (ret) {\n\t\tatomic_inc(&rproc->power);\n\t\tgoto out;\n\t}\n\n\t \n\trproc_resource_cleanup(rproc);\n\n\t \n\trproc_unprepare_device(rproc);\n\n\trproc_disable_iommu(rproc);\n\n\t \n\tkfree(rproc->cached_table);\n\trproc->cached_table = NULL;\n\trproc->table_ptr = NULL;\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_detach);\n\n \n#ifdef CONFIG_OF\nstruct rproc *rproc_get_by_phandle(phandle phandle)\n{\n\tstruct rproc *rproc = NULL, *r;\n\tstruct device_node *np;\n\n\tnp = of_find_node_by_phandle(phandle);\n\tif (!np)\n\t\treturn NULL;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(r, &rproc_list, node) {\n\t\tif (r->dev.parent && device_match_of_node(r->dev.parent, np)) {\n\t\t\t \n\t\t\tif (!try_module_get(r->dev.parent->driver->owner)) {\n\t\t\t\tdev_err(&r->dev, \"can't get owner\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\trproc = r;\n\t\t\tget_device(&rproc->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tof_node_put(np);\n\n\treturn rproc;\n}\n#else\nstruct rproc *rproc_get_by_phandle(phandle phandle)\n{\n\treturn NULL;\n}\n#endif\nEXPORT_SYMBOL(rproc_get_by_phandle);\n\n \nint rproc_set_firmware(struct rproc *rproc, const char *fw_name)\n{\n\tstruct device *dev;\n\tint ret, len;\n\tchar *p;\n\n\tif (!rproc || !fw_name)\n\t\treturn -EINVAL;\n\n\tdev = rproc->dev.parent;\n\n\tret = mutex_lock_interruptible(&rproc->lock);\n\tif (ret) {\n\t\tdev_err(dev, \"can't lock rproc %s: %d\\n\", rproc->name, ret);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rproc->state != RPROC_OFFLINE) {\n\t\tdev_err(dev, \"can't change firmware while running\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tlen = strcspn(fw_name, \"\\n\");\n\tif (!len) {\n\t\tdev_err(dev, \"can't provide empty string for firmware name\\n\");\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tp = kstrndup(fw_name, len, GFP_KERNEL);\n\tif (!p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkfree_const(rproc->firmware);\n\trproc->firmware = p;\n\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_set_firmware);\n\nstatic int rproc_validate(struct rproc *rproc)\n{\n\tswitch (rproc->state) {\n\tcase RPROC_OFFLINE:\n\t\t \n\t\tif (!rproc->ops->start)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase RPROC_DETACHED:\n\t\t \n\t\tif (!rproc->ops->attach)\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (rproc->cached_table)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nint rproc_add(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tint ret;\n\n\tret = rproc_validate(rproc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rproc_char_device_add(rproc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = device_add(dev);\n\tif (ret < 0) {\n\t\tput_device(dev);\n\t\tgoto rproc_remove_cdev;\n\t}\n\n\tdev_info(dev, \"%s is available\\n\", rproc->name);\n\n\t \n\trproc_create_debug_dir(rproc);\n\n\t \n\tif (rproc->auto_boot) {\n\t\tret = rproc_trigger_auto_boot(rproc);\n\t\tif (ret < 0)\n\t\t\tgoto rproc_remove_dev;\n\t}\n\n\t \n\tmutex_lock(&rproc_list_mutex);\n\tlist_add_rcu(&rproc->node, &rproc_list);\n\tmutex_unlock(&rproc_list_mutex);\n\n\treturn 0;\n\nrproc_remove_dev:\n\trproc_delete_debug_dir(rproc);\n\tdevice_del(dev);\nrproc_remove_cdev:\n\trproc_char_device_remove(rproc);\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_add);\n\nstatic void devm_rproc_remove(void *rproc)\n{\n\trproc_del(rproc);\n}\n\n \nint devm_rproc_add(struct device *dev, struct rproc *rproc)\n{\n\tint err;\n\n\terr = rproc_add(rproc);\n\tif (err)\n\t\treturn err;\n\n\treturn devm_add_action_or_reset(dev, devm_rproc_remove, rproc);\n}\nEXPORT_SYMBOL(devm_rproc_add);\n\n \nstatic void rproc_type_release(struct device *dev)\n{\n\tstruct rproc *rproc = container_of(dev, struct rproc, dev);\n\n\tdev_info(&rproc->dev, \"releasing %s\\n\", rproc->name);\n\n\tidr_destroy(&rproc->notifyids);\n\n\tif (rproc->index >= 0)\n\t\tida_free(&rproc_dev_index, rproc->index);\n\n\tkfree_const(rproc->firmware);\n\tkfree_const(rproc->name);\n\tkfree(rproc->ops);\n\tkfree(rproc);\n}\n\nstatic const struct device_type rproc_type = {\n\t.name\t\t= \"remoteproc\",\n\t.release\t= rproc_type_release,\n};\n\nstatic int rproc_alloc_firmware(struct rproc *rproc,\n\t\t\t\tconst char *name, const char *firmware)\n{\n\tconst char *p;\n\n\t \n\tif (firmware)\n\t\tp = kstrdup_const(firmware, GFP_KERNEL);\n\telse\n\t\tp = kasprintf(GFP_KERNEL, \"rproc-%s-fw\", name);\n\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\trproc->firmware = p;\n\n\treturn 0;\n}\n\nstatic int rproc_alloc_ops(struct rproc *rproc, const struct rproc_ops *ops)\n{\n\trproc->ops = kmemdup(ops, sizeof(*ops), GFP_KERNEL);\n\tif (!rproc->ops)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!rproc->ops->coredump)\n\t\trproc->ops->coredump = rproc_coredump;\n\n\tif (rproc->ops->load)\n\t\treturn 0;\n\n\t \n\trproc->ops->load = rproc_elf_load_segments;\n\trproc->ops->parse_fw = rproc_elf_load_rsc_table;\n\trproc->ops->find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table;\n\trproc->ops->sanity_check = rproc_elf_sanity_check;\n\trproc->ops->get_boot_addr = rproc_elf_get_boot_addr;\n\n\treturn 0;\n}\n\n \nstruct rproc *rproc_alloc(struct device *dev, const char *name,\n\t\t\t  const struct rproc_ops *ops,\n\t\t\t  const char *firmware, int len)\n{\n\tstruct rproc *rproc;\n\n\tif (!dev || !name || !ops)\n\t\treturn NULL;\n\n\trproc = kzalloc(sizeof(struct rproc) + len, GFP_KERNEL);\n\tif (!rproc)\n\t\treturn NULL;\n\n\trproc->priv = &rproc[1];\n\trproc->auto_boot = true;\n\trproc->elf_class = ELFCLASSNONE;\n\trproc->elf_machine = EM_NONE;\n\n\tdevice_initialize(&rproc->dev);\n\trproc->dev.parent = dev;\n\trproc->dev.type = &rproc_type;\n\trproc->dev.class = &rproc_class;\n\trproc->dev.driver_data = rproc;\n\tidr_init(&rproc->notifyids);\n\n\trproc->name = kstrdup_const(name, GFP_KERNEL);\n\tif (!rproc->name)\n\t\tgoto put_device;\n\n\tif (rproc_alloc_firmware(rproc, name, firmware))\n\t\tgoto put_device;\n\n\tif (rproc_alloc_ops(rproc, ops))\n\t\tgoto put_device;\n\n\t \n\trproc->index = ida_alloc(&rproc_dev_index, GFP_KERNEL);\n\tif (rproc->index < 0) {\n\t\tdev_err(dev, \"ida_alloc failed: %d\\n\", rproc->index);\n\t\tgoto put_device;\n\t}\n\n\tdev_set_name(&rproc->dev, \"remoteproc%d\", rproc->index);\n\n\tatomic_set(&rproc->power, 0);\n\n\tmutex_init(&rproc->lock);\n\n\tINIT_LIST_HEAD(&rproc->carveouts);\n\tINIT_LIST_HEAD(&rproc->mappings);\n\tINIT_LIST_HEAD(&rproc->traces);\n\tINIT_LIST_HEAD(&rproc->rvdevs);\n\tINIT_LIST_HEAD(&rproc->subdevs);\n\tINIT_LIST_HEAD(&rproc->dump_segments);\n\n\tINIT_WORK(&rproc->crash_handler, rproc_crash_handler_work);\n\n\trproc->state = RPROC_OFFLINE;\n\n\treturn rproc;\n\nput_device:\n\tput_device(&rproc->dev);\n\treturn NULL;\n}\nEXPORT_SYMBOL(rproc_alloc);\n\n \nvoid rproc_free(struct rproc *rproc)\n{\n\tput_device(&rproc->dev);\n}\nEXPORT_SYMBOL(rproc_free);\n\n \nvoid rproc_put(struct rproc *rproc)\n{\n\tmodule_put(rproc->dev.parent->driver->owner);\n\tput_device(&rproc->dev);\n}\nEXPORT_SYMBOL(rproc_put);\n\n \nint rproc_del(struct rproc *rproc)\n{\n\tif (!rproc)\n\t\treturn -EINVAL;\n\n\t \n\trproc_shutdown(rproc);\n\n\tmutex_lock(&rproc->lock);\n\trproc->state = RPROC_DELETED;\n\tmutex_unlock(&rproc->lock);\n\n\trproc_delete_debug_dir(rproc);\n\n\t \n\tmutex_lock(&rproc_list_mutex);\n\tlist_del_rcu(&rproc->node);\n\tmutex_unlock(&rproc_list_mutex);\n\n\t \n\tsynchronize_rcu();\n\n\tdevice_del(&rproc->dev);\n\trproc_char_device_remove(rproc);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_del);\n\nstatic void devm_rproc_free(struct device *dev, void *res)\n{\n\trproc_free(*(struct rproc **)res);\n}\n\n \nstruct rproc *devm_rproc_alloc(struct device *dev, const char *name,\n\t\t\t       const struct rproc_ops *ops,\n\t\t\t       const char *firmware, int len)\n{\n\tstruct rproc **ptr, *rproc;\n\n\tptr = devres_alloc(devm_rproc_free, sizeof(*ptr), GFP_KERNEL);\n\tif (!ptr)\n\t\treturn NULL;\n\n\trproc = rproc_alloc(dev, name, ops, firmware, len);\n\tif (rproc) {\n\t\t*ptr = rproc;\n\t\tdevres_add(dev, ptr);\n\t} else {\n\t\tdevres_free(ptr);\n\t}\n\n\treturn rproc;\n}\nEXPORT_SYMBOL(devm_rproc_alloc);\n\n \nvoid rproc_add_subdev(struct rproc *rproc, struct rproc_subdev *subdev)\n{\n\tlist_add_tail(&subdev->node, &rproc->subdevs);\n}\nEXPORT_SYMBOL(rproc_add_subdev);\n\n \nvoid rproc_remove_subdev(struct rproc *rproc, struct rproc_subdev *subdev)\n{\n\tlist_del(&subdev->node);\n}\nEXPORT_SYMBOL(rproc_remove_subdev);\n\n \nstruct rproc *rproc_get_by_child(struct device *dev)\n{\n\tfor (dev = dev->parent; dev; dev = dev->parent) {\n\t\tif (dev->type == &rproc_type)\n\t\t\treturn dev->driver_data;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL(rproc_get_by_child);\n\n \nvoid rproc_report_crash(struct rproc *rproc, enum rproc_crash_type type)\n{\n\tif (!rproc) {\n\t\tpr_err(\"NULL rproc pointer\\n\");\n\t\treturn;\n\t}\n\n\t \n\tpm_stay_awake(rproc->dev.parent);\n\n\tdev_err(&rproc->dev, \"crash detected in %s: type %s\\n\",\n\t\trproc->name, rproc_crash_to_string(type));\n\n\tqueue_work(rproc_recovery_wq, &rproc->crash_handler);\n}\nEXPORT_SYMBOL(rproc_report_crash);\n\nstatic int rproc_panic_handler(struct notifier_block *nb, unsigned long event,\n\t\t\t       void *ptr)\n{\n\tunsigned int longest = 0;\n\tstruct rproc *rproc;\n\tunsigned int d;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(rproc, &rproc_list, node) {\n\t\tif (!rproc->ops->panic)\n\t\t\tcontinue;\n\n\t\tif (rproc->state != RPROC_RUNNING &&\n\t\t    rproc->state != RPROC_ATTACHED)\n\t\t\tcontinue;\n\n\t\td = rproc->ops->panic(rproc);\n\t\tlongest = max(longest, d);\n\t}\n\trcu_read_unlock();\n\n\t \n\tmdelay(longest);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic void __init rproc_init_panic(void)\n{\n\trproc_panic_nb.notifier_call = rproc_panic_handler;\n\tatomic_notifier_chain_register(&panic_notifier_list, &rproc_panic_nb);\n}\n\nstatic void __exit rproc_exit_panic(void)\n{\n\tatomic_notifier_chain_unregister(&panic_notifier_list, &rproc_panic_nb);\n}\n\nstatic int __init remoteproc_init(void)\n{\n\trproc_recovery_wq = alloc_workqueue(\"rproc_recovery_wq\",\n\t\t\t\t\t\tWQ_UNBOUND | WQ_FREEZABLE, 0);\n\tif (!rproc_recovery_wq) {\n\t\tpr_err(\"remoteproc: creation of rproc_recovery_wq failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trproc_init_sysfs();\n\trproc_init_debugfs();\n\trproc_init_cdev();\n\trproc_init_panic();\n\n\treturn 0;\n}\nsubsys_initcall(remoteproc_init);\n\nstatic void __exit remoteproc_exit(void)\n{\n\tida_destroy(&rproc_dev_index);\n\n\tif (!rproc_recovery_wq)\n\t\treturn;\n\n\trproc_exit_panic();\n\trproc_exit_debugfs();\n\trproc_exit_sysfs();\n\tdestroy_workqueue(rproc_recovery_wq);\n}\nmodule_exit(remoteproc_exit);\n\nMODULE_DESCRIPTION(\"Generic Remote Processor Framework\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}