{
  "module_name": "mtk_scp.c",
  "hash_id": "0e6cb8919a50cc9616fe49941089e7f49a5f3d2380bb972605a0dd03704490ba",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/mtk_scp.c",
  "human_readable_source": "\n\n\n\n#include <asm/barrier.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/remoteproc/mtk_scp.h>\n#include <linux/rpmsg/mtk_rpmsg.h>\n\n#include \"mtk_common.h\"\n#include \"remoteproc_internal.h\"\n\n#define MAX_CODE_SIZE 0x500000\n#define SECTION_NAME_IPI_BUFFER \".ipi_buffer\"\n\n \nstruct mtk_scp *scp_get(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *scp_node;\n\tstruct platform_device *scp_pdev;\n\n\tscp_node = of_parse_phandle(dev->of_node, \"mediatek,scp\", 0);\n\tif (!scp_node) {\n\t\tdev_err(dev, \"can't get SCP node\\n\");\n\t\treturn NULL;\n\t}\n\n\tscp_pdev = of_find_device_by_node(scp_node);\n\tof_node_put(scp_node);\n\n\tif (WARN_ON(!scp_pdev)) {\n\t\tdev_err(dev, \"SCP pdev failed\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn platform_get_drvdata(scp_pdev);\n}\nEXPORT_SYMBOL_GPL(scp_get);\n\n \nvoid scp_put(struct mtk_scp *scp)\n{\n\tput_device(scp->dev);\n}\nEXPORT_SYMBOL_GPL(scp_put);\n\nstatic void scp_wdt_handler(struct mtk_scp *scp, u32 scp_to_host)\n{\n\tdev_err(scp->dev, \"SCP watchdog timeout! 0x%x\", scp_to_host);\n\trproc_report_crash(scp->rproc, RPROC_WATCHDOG);\n}\n\nstatic void scp_init_ipi_handler(void *data, unsigned int len, void *priv)\n{\n\tstruct mtk_scp *scp = priv;\n\tstruct scp_run *run = data;\n\n\tscp->run.signaled = run->signaled;\n\tstrscpy(scp->run.fw_ver, run->fw_ver, SCP_FW_VER_LEN);\n\tscp->run.dec_capability = run->dec_capability;\n\tscp->run.enc_capability = run->enc_capability;\n\twake_up_interruptible(&scp->run.wq);\n}\n\nstatic void scp_ipi_handler(struct mtk_scp *scp)\n{\n\tstruct mtk_share_obj __iomem *rcv_obj = scp->recv_buf;\n\tstruct scp_ipi_desc *ipi_desc = scp->ipi_desc;\n\tu8 tmp_data[SCP_SHARE_BUFFER_SIZE];\n\tscp_ipi_handler_t handler;\n\tu32 id = readl(&rcv_obj->id);\n\tu32 len = readl(&rcv_obj->len);\n\n\tif (len > SCP_SHARE_BUFFER_SIZE) {\n\t\tdev_err(scp->dev, \"ipi message too long (len %d, max %d)\", len,\n\t\t\tSCP_SHARE_BUFFER_SIZE);\n\t\treturn;\n\t}\n\tif (id >= SCP_IPI_MAX) {\n\t\tdev_err(scp->dev, \"No such ipi id = %d\\n\", id);\n\t\treturn;\n\t}\n\n\tscp_ipi_lock(scp, id);\n\thandler = ipi_desc[id].handler;\n\tif (!handler) {\n\t\tdev_err(scp->dev, \"No such ipi id = %d\\n\", id);\n\t\tscp_ipi_unlock(scp, id);\n\t\treturn;\n\t}\n\n\tmemcpy_fromio(tmp_data, &rcv_obj->share_buf, len);\n\thandler(tmp_data, len, ipi_desc[id].priv);\n\tscp_ipi_unlock(scp, id);\n\n\tscp->ipi_id_ack[id] = true;\n\twake_up(&scp->ack_wq);\n}\n\nstatic int scp_elf_read_ipi_buf_addr(struct mtk_scp *scp,\n\t\t\t\t     const struct firmware *fw,\n\t\t\t\t     size_t *offset);\n\nstatic int scp_ipi_init(struct mtk_scp *scp, const struct firmware *fw)\n{\n\tint ret;\n\tsize_t offset;\n\n\t \n\tret = scp_elf_read_ipi_buf_addr(scp, fw, &offset);\n\tif (ret) {\n\t\t \n\t\toffset = scp->data->ipi_buf_offset;\n\t\tif (!offset)\n\t\t\treturn ret;\n\t}\n\tdev_info(scp->dev, \"IPI buf addr %#010zx\\n\", offset);\n\n\tscp->recv_buf = (struct mtk_share_obj __iomem *)\n\t\t\t(scp->sram_base + offset);\n\tscp->send_buf = (struct mtk_share_obj __iomem *)\n\t\t\t(scp->sram_base + offset + sizeof(*scp->recv_buf));\n\tmemset_io(scp->recv_buf, 0, sizeof(*scp->recv_buf));\n\tmemset_io(scp->send_buf, 0, sizeof(*scp->send_buf));\n\n\treturn 0;\n}\n\nstatic void mt8183_scp_reset_assert(struct mtk_scp *scp)\n{\n\tu32 val;\n\n\tval = readl(scp->reg_base + MT8183_SW_RSTN);\n\tval &= ~MT8183_SW_RSTN_BIT;\n\twritel(val, scp->reg_base + MT8183_SW_RSTN);\n}\n\nstatic void mt8183_scp_reset_deassert(struct mtk_scp *scp)\n{\n\tu32 val;\n\n\tval = readl(scp->reg_base + MT8183_SW_RSTN);\n\tval |= MT8183_SW_RSTN_BIT;\n\twritel(val, scp->reg_base + MT8183_SW_RSTN);\n}\n\nstatic void mt8192_scp_reset_assert(struct mtk_scp *scp)\n{\n\twritel(1, scp->reg_base + MT8192_CORE0_SW_RSTN_SET);\n}\n\nstatic void mt8192_scp_reset_deassert(struct mtk_scp *scp)\n{\n\twritel(1, scp->reg_base + MT8192_CORE0_SW_RSTN_CLR);\n}\n\nstatic void mt8183_scp_irq_handler(struct mtk_scp *scp)\n{\n\tu32 scp_to_host;\n\n\tscp_to_host = readl(scp->reg_base + MT8183_SCP_TO_HOST);\n\tif (scp_to_host & MT8183_SCP_IPC_INT_BIT)\n\t\tscp_ipi_handler(scp);\n\telse\n\t\tscp_wdt_handler(scp, scp_to_host);\n\n\t \n\twritel(MT8183_SCP_IPC_INT_BIT | MT8183_SCP_WDT_INT_BIT,\n\t       scp->reg_base + MT8183_SCP_TO_HOST);\n}\n\nstatic void mt8192_scp_irq_handler(struct mtk_scp *scp)\n{\n\tu32 scp_to_host;\n\n\tscp_to_host = readl(scp->reg_base + MT8192_SCP2APMCU_IPC_SET);\n\n\tif (scp_to_host & MT8192_SCP_IPC_INT_BIT) {\n\t\tscp_ipi_handler(scp);\n\n\t\t \n\t\twritel(MT8192_SCP_IPC_INT_BIT,\n\t\t       scp->reg_base + MT8192_SCP2APMCU_IPC_CLR);\n\t} else {\n\t\tscp_wdt_handler(scp, scp_to_host);\n\t\twritel(1, scp->reg_base + MT8192_CORE0_WDT_IRQ);\n\t}\n}\n\nstatic irqreturn_t scp_irq_handler(int irq, void *priv)\n{\n\tstruct mtk_scp *scp = priv;\n\tint ret;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(scp->dev, \"failed to enable clocks\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tscp->data->scp_irq_handler(scp);\n\n\tclk_disable_unprepare(scp->clk);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int scp_elf_load_segments(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = &rproc->dev;\n\tstruct elf32_hdr *ehdr;\n\tstruct elf32_phdr *phdr;\n\tint i, ret = 0;\n\tconst u8 *elf_data = fw->data;\n\n\tehdr = (struct elf32_hdr *)elf_data;\n\tphdr = (struct elf32_phdr *)(elf_data + ehdr->e_phoff);\n\n\t \n\tfor (i = 0; i < ehdr->e_phnum; i++, phdr++) {\n\t\tu32 da = phdr->p_paddr;\n\t\tu32 memsz = phdr->p_memsz;\n\t\tu32 filesz = phdr->p_filesz;\n\t\tu32 offset = phdr->p_offset;\n\t\tvoid __iomem *ptr;\n\n\t\tdev_dbg(dev, \"phdr: type %d da 0x%x memsz 0x%x filesz 0x%x\\n\",\n\t\t\tphdr->p_type, da, memsz, filesz);\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\t\tif (!filesz)\n\t\t\tcontinue;\n\n\t\tif (filesz > memsz) {\n\t\t\tdev_err(dev, \"bad phdr filesz 0x%x memsz 0x%x\\n\",\n\t\t\t\tfilesz, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offset + filesz > fw->size) {\n\t\t\tdev_err(dev, \"truncated fw: need 0x%x avail 0x%zx\\n\",\n\t\t\t\toffset + filesz, fw->size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tptr = (void __iomem *)rproc_da_to_va(rproc, da, memsz, NULL);\n\t\tif (!ptr) {\n\t\t\tdev_err(dev, \"bad phdr da 0x%x mem 0x%x\\n\", da, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tscp_memcpy_aligned(ptr, elf_data + phdr->p_offset, filesz);\n\t}\n\n\treturn ret;\n}\n\nstatic int scp_elf_read_ipi_buf_addr(struct mtk_scp *scp,\n\t\t\t\t     const struct firmware *fw,\n\t\t\t\t     size_t *offset)\n{\n\tstruct elf32_hdr *ehdr;\n\tstruct elf32_shdr *shdr, *shdr_strtab;\n\tint i;\n\tconst u8 *elf_data = fw->data;\n\tconst char *strtab;\n\n\tehdr = (struct elf32_hdr *)elf_data;\n\tshdr = (struct elf32_shdr *)(elf_data + ehdr->e_shoff);\n\tshdr_strtab = shdr + ehdr->e_shstrndx;\n\tstrtab = (const char *)(elf_data + shdr_strtab->sh_offset);\n\n\tfor (i = 0; i < ehdr->e_shnum; i++, shdr++) {\n\t\tif (strcmp(strtab + shdr->sh_name,\n\t\t\t   SECTION_NAME_IPI_BUFFER) == 0) {\n\t\t\t*offset = shdr->sh_addr;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\nstatic int mt8183_scp_clk_get(struct mtk_scp *scp)\n{\n\tstruct device *dev = scp->dev;\n\tint ret = 0;\n\n\tscp->clk = devm_clk_get(dev, \"main\");\n\tif (IS_ERR(scp->clk)) {\n\t\tdev_err(dev, \"Failed to get clock\\n\");\n\t\tret = PTR_ERR(scp->clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int mt8192_scp_clk_get(struct mtk_scp *scp)\n{\n\treturn mt8183_scp_clk_get(scp);\n}\n\nstatic int mt8195_scp_clk_get(struct mtk_scp *scp)\n{\n\tscp->clk = NULL;\n\n\treturn 0;\n}\n\nstatic int mt8183_scp_before_load(struct mtk_scp *scp)\n{\n\t \n\twritel(MT8183_SCP_IPC_INT_BIT, scp->reg_base + MT8183_SCP_TO_HOST);\n\n\t \n\twritel(0x0, scp->reg_base + MT8183_SCP_CLK_SW_SEL);\n\twritel(0x0, scp->reg_base + MT8183_SCP_CLK_DIV_SEL);\n\n\t \n\twritel(0x0, scp->reg_base + MT8183_SCP_L1_SRAM_PD);\n\twritel(0x0, scp->reg_base + MT8183_SCP_TCM_TAIL_SRAM_PD);\n\n\t \n\twritel(0x0, scp->reg_base + MT8183_SCP_SRAM_PDN);\n\n\t \n\twritel(MT8183_SCP_CACHE_CON_WAYEN | MT8183_SCP_CACHESIZE_8KB,\n\t       scp->reg_base + MT8183_SCP_CACHE_CON);\n\twritel(MT8183_SCP_CACHESIZE_8KB, scp->reg_base + MT8183_SCP_DCACHE_CON);\n\n\treturn 0;\n}\n\nstatic void scp_sram_power_on(void __iomem *addr, u32 reserved_mask)\n{\n\tint i;\n\n\tfor (i = 31; i >= 0; i--)\n\t\twritel(GENMASK(i, 0) & ~reserved_mask, addr);\n\twritel(0, addr);\n}\n\nstatic void scp_sram_power_off(void __iomem *addr, u32 reserved_mask)\n{\n\tint i;\n\n\twritel(0, addr);\n\tfor (i = 0; i < 32; i++)\n\t\twritel(GENMASK(i, 0) & ~reserved_mask, addr);\n}\n\nstatic int mt8186_scp_before_load(struct mtk_scp *scp)\n{\n\t \n\twritel(MT8183_SCP_IPC_INT_BIT, scp->reg_base + MT8183_SCP_TO_HOST);\n\n\t \n\twritel(0x0, scp->reg_base + MT8183_SCP_CLK_SW_SEL);\n\twritel(0x0, scp->reg_base + MT8183_SCP_CLK_DIV_SEL);\n\n\t \n\tscp_sram_power_on(scp->reg_base + MT8183_SCP_SRAM_PDN, 0);\n\n\t \n\twritel(0x0, scp->reg_base + MT8183_SCP_L1_SRAM_PD);\n\twritel(0x0, scp->reg_base + MT8183_SCP_TCM_TAIL_SRAM_PD);\n\twritel(0x0, scp->reg_base + MT8186_SCP_L1_SRAM_PD_P1);\n\twritel(0x0, scp->reg_base + MT8186_SCP_L1_SRAM_PD_p2);\n\n\t \n\twritel(MT8183_SCP_CACHE_CON_WAYEN | MT8183_SCP_CACHESIZE_8KB,\n\t       scp->reg_base + MT8183_SCP_CACHE_CON);\n\twritel(MT8183_SCP_CACHESIZE_8KB, scp->reg_base + MT8183_SCP_DCACHE_CON);\n\n\treturn 0;\n}\n\nstatic int mt8192_scp_before_load(struct mtk_scp *scp)\n{\n\t \n\twritel(0xff, scp->reg_base + MT8192_SCP2SPM_IPC_CLR);\n\n\twritel(1, scp->reg_base + MT8192_CORE0_SW_RSTN_SET);\n\n\t \n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_0, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_1, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_2, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L1TCM_SRAM_PDN, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_CPU0_SRAM_PD, 0);\n\n\t \n\twritel(0xff, scp->reg_base + MT8192_CORE0_MEM_ATT_PREDEF);\n\n\treturn 0;\n}\n\nstatic int mt8195_scp_before_load(struct mtk_scp *scp)\n{\n\t \n\twritel(0xff, scp->reg_base + MT8192_SCP2SPM_IPC_CLR);\n\n\twritel(1, scp->reg_base + MT8192_CORE0_SW_RSTN_SET);\n\n\t \n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_0, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_1, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L2TCM_SRAM_PD_2, 0);\n\tscp_sram_power_on(scp->reg_base + MT8192_L1TCM_SRAM_PDN,\n\t\t\t  MT8195_L1TCM_SRAM_PDN_RESERVED_RSI_BITS);\n\tscp_sram_power_on(scp->reg_base + MT8192_CPU0_SRAM_PD, 0);\n\n\t \n\twritel(0xff, scp->reg_base + MT8192_CORE0_MEM_ATT_PREDEF);\n\n\treturn 0;\n}\n\nstatic int scp_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct mtk_scp *scp = rproc->priv;\n\tstruct device *dev = scp->dev;\n\tint ret;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tscp->data->scp_reset_assert(scp);\n\n\tret = scp->data->scp_before_load(scp);\n\tif (ret < 0)\n\t\tgoto leave;\n\n\tret = scp_elf_load_segments(rproc, fw);\nleave:\n\tclk_disable_unprepare(scp->clk);\n\n\treturn ret;\n}\n\nstatic int scp_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct mtk_scp *scp = rproc->priv;\n\tstruct device *dev = scp->dev;\n\tint ret;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = scp_ipi_init(scp, fw);\n\tclk_disable_unprepare(scp->clk);\n\treturn ret;\n}\n\nstatic int scp_start(struct rproc *rproc)\n{\n\tstruct mtk_scp *scp = rproc->priv;\n\tstruct device *dev = scp->dev;\n\tstruct scp_run *run = &scp->run;\n\tint ret;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\trun->signaled = false;\n\n\tscp->data->scp_reset_deassert(scp);\n\n\tret = wait_event_interruptible_timeout(\n\t\t\t\t\trun->wq,\n\t\t\t\t\trun->signaled,\n\t\t\t\t\tmsecs_to_jiffies(2000));\n\n\tif (ret == 0) {\n\t\tdev_err(dev, \"wait SCP initialization timeout!\\n\");\n\t\tret = -ETIME;\n\t\tgoto stop;\n\t}\n\tif (ret == -ERESTARTSYS) {\n\t\tdev_err(dev, \"wait SCP interrupted by a signal!\\n\");\n\t\tgoto stop;\n\t}\n\n\tclk_disable_unprepare(scp->clk);\n\tdev_info(dev, \"SCP is ready. FW version %s\\n\", run->fw_ver);\n\n\treturn 0;\n\nstop:\n\tscp->data->scp_reset_assert(scp);\n\tclk_disable_unprepare(scp->clk);\n\treturn ret;\n}\n\nstatic void *mt8183_scp_da_to_va(struct mtk_scp *scp, u64 da, size_t len)\n{\n\tint offset;\n\n\tif (da < scp->sram_size) {\n\t\toffset = da;\n\t\tif (offset >= 0 && (offset + len) <= scp->sram_size)\n\t\t\treturn (void __force *)scp->sram_base + offset;\n\t} else if (scp->dram_size) {\n\t\toffset = da - scp->dma_addr;\n\t\tif (offset >= 0 && (offset + len) <= scp->dram_size)\n\t\t\treturn scp->cpu_addr + offset;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *mt8192_scp_da_to_va(struct mtk_scp *scp, u64 da, size_t len)\n{\n\tint offset;\n\n\tif (da >= scp->sram_phys &&\n\t    (da + len) <= scp->sram_phys + scp->sram_size) {\n\t\toffset = da - scp->sram_phys;\n\t\treturn (void __force *)scp->sram_base + offset;\n\t}\n\n\t \n\tif (scp->l1tcm_size &&\n\t    da >= scp->l1tcm_phys &&\n\t    (da + len) <= scp->l1tcm_phys + scp->l1tcm_size) {\n\t\toffset = da - scp->l1tcm_phys;\n\t\treturn (void __force *)scp->l1tcm_base + offset;\n\t}\n\n\t \n\tif (scp->dram_size &&\n\t    da >= scp->dma_addr &&\n\t    (da + len) <= scp->dma_addr + scp->dram_size) {\n\t\toffset = da - scp->dma_addr;\n\t\treturn scp->cpu_addr + offset;\n\t}\n\n\treturn NULL;\n}\n\nstatic void *scp_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct mtk_scp *scp = rproc->priv;\n\n\treturn scp->data->scp_da_to_va(scp, da, len);\n}\n\nstatic void mt8183_scp_stop(struct mtk_scp *scp)\n{\n\t \n\twritel(0, scp->reg_base + MT8183_WDT_CFG);\n}\n\nstatic void mt8192_scp_stop(struct mtk_scp *scp)\n{\n\t \n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_0, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_1, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_2, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L1TCM_SRAM_PDN, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_CPU0_SRAM_PD, 0);\n\n\t \n\twritel(0, scp->reg_base + MT8192_CORE0_WDT_CFG);\n}\n\nstatic void mt8195_scp_stop(struct mtk_scp *scp)\n{\n\t \n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_0, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_1, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L2TCM_SRAM_PD_2, 0);\n\tscp_sram_power_off(scp->reg_base + MT8192_L1TCM_SRAM_PDN,\n\t\t\t   MT8195_L1TCM_SRAM_PDN_RESERVED_RSI_BITS);\n\tscp_sram_power_off(scp->reg_base + MT8192_CPU0_SRAM_PD, 0);\n\n\t \n\twritel(0, scp->reg_base + MT8192_CORE0_WDT_CFG);\n}\n\nstatic int scp_stop(struct rproc *rproc)\n{\n\tstruct mtk_scp *scp = rproc->priv;\n\tint ret;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(scp->dev, \"failed to enable clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tscp->data->scp_reset_assert(scp);\n\tscp->data->scp_stop(scp);\n\tclk_disable_unprepare(scp->clk);\n\n\treturn 0;\n}\n\nstatic const struct rproc_ops scp_ops = {\n\t.start\t\t= scp_start,\n\t.stop\t\t= scp_stop,\n\t.load\t\t= scp_load,\n\t.da_to_va\t= scp_da_to_va,\n\t.parse_fw\t= scp_parse_fw,\n\t.sanity_check\t= rproc_elf_sanity_check,\n};\n\n \nstruct device *scp_get_device(struct mtk_scp *scp)\n{\n\treturn scp->dev;\n}\nEXPORT_SYMBOL_GPL(scp_get_device);\n\n \nstruct rproc *scp_get_rproc(struct mtk_scp *scp)\n{\n\treturn scp->rproc;\n}\nEXPORT_SYMBOL_GPL(scp_get_rproc);\n\n \nunsigned int scp_get_vdec_hw_capa(struct mtk_scp *scp)\n{\n\treturn scp->run.dec_capability;\n}\nEXPORT_SYMBOL_GPL(scp_get_vdec_hw_capa);\n\n \nunsigned int scp_get_venc_hw_capa(struct mtk_scp *scp)\n{\n\treturn scp->run.enc_capability;\n}\nEXPORT_SYMBOL_GPL(scp_get_venc_hw_capa);\n\n \nvoid *scp_mapping_dm_addr(struct mtk_scp *scp, u32 mem_addr)\n{\n\tvoid *ptr;\n\n\tptr = scp_da_to_va(scp->rproc, mem_addr, 0, NULL);\n\tif (!ptr)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn ptr;\n}\nEXPORT_SYMBOL_GPL(scp_mapping_dm_addr);\n\nstatic int scp_map_memory_region(struct mtk_scp *scp)\n{\n\tint ret;\n\n\tret = of_reserved_mem_device_init(scp->dev);\n\n\t \n\tif (ret == -ENODEV) {\n\t\tdev_info(scp->dev, \"skipping reserved memory initialization.\");\n\t\treturn 0;\n\t}\n\n\tif (ret) {\n\t\tdev_err(scp->dev, \"failed to assign memory-region: %d\\n\", ret);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tscp->dram_size = MAX_CODE_SIZE;\n\tscp->cpu_addr = dma_alloc_coherent(scp->dev, scp->dram_size,\n\t\t\t\t\t   &scp->dma_addr, GFP_KERNEL);\n\tif (!scp->cpu_addr)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void scp_unmap_memory_region(struct mtk_scp *scp)\n{\n\tif (scp->dram_size == 0)\n\t\treturn;\n\n\tdma_free_coherent(scp->dev, scp->dram_size, scp->cpu_addr,\n\t\t\t  scp->dma_addr);\n\tof_reserved_mem_device_release(scp->dev);\n}\n\nstatic int scp_register_ipi(struct platform_device *pdev, u32 id,\n\t\t\t    ipi_handler_t handler, void *priv)\n{\n\tstruct mtk_scp *scp = platform_get_drvdata(pdev);\n\n\treturn scp_ipi_register(scp, id, handler, priv);\n}\n\nstatic void scp_unregister_ipi(struct platform_device *pdev, u32 id)\n{\n\tstruct mtk_scp *scp = platform_get_drvdata(pdev);\n\n\tscp_ipi_unregister(scp, id);\n}\n\nstatic int scp_send_ipi(struct platform_device *pdev, u32 id, void *buf,\n\t\t\tunsigned int len, unsigned int wait)\n{\n\tstruct mtk_scp *scp = platform_get_drvdata(pdev);\n\n\treturn scp_ipi_send(scp, id, buf, len, wait);\n}\n\nstatic struct mtk_rpmsg_info mtk_scp_rpmsg_info = {\n\t.send_ipi = scp_send_ipi,\n\t.register_ipi = scp_register_ipi,\n\t.unregister_ipi = scp_unregister_ipi,\n\t.ns_ipi_id = SCP_IPI_NS_SERVICE,\n};\n\nstatic void scp_add_rpmsg_subdev(struct mtk_scp *scp)\n{\n\tscp->rpmsg_subdev =\n\t\tmtk_rpmsg_create_rproc_subdev(to_platform_device(scp->dev),\n\t\t\t\t\t      &mtk_scp_rpmsg_info);\n\tif (scp->rpmsg_subdev)\n\t\trproc_add_subdev(scp->rproc, scp->rpmsg_subdev);\n}\n\nstatic void scp_remove_rpmsg_subdev(struct mtk_scp *scp)\n{\n\tif (scp->rpmsg_subdev) {\n\t\trproc_remove_subdev(scp->rproc, scp->rpmsg_subdev);\n\t\tmtk_rpmsg_destroy_rproc_subdev(scp->rpmsg_subdev);\n\t\tscp->rpmsg_subdev = NULL;\n\t}\n}\n\nstatic int scp_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct mtk_scp *scp;\n\tstruct rproc *rproc;\n\tstruct resource *res;\n\tconst char *fw_name = \"scp.img\";\n\tint ret, i;\n\n\tret = rproc_of_parse_firmware(dev, 0, &fw_name);\n\tif (ret < 0 && ret != -EINVAL)\n\t\treturn ret;\n\n\trproc = devm_rproc_alloc(dev, np->name, &scp_ops, fw_name, sizeof(*scp));\n\tif (!rproc)\n\t\treturn dev_err_probe(dev, -ENOMEM, \"unable to allocate remoteproc\\n\");\n\n\tscp = rproc->priv;\n\tscp->rproc = rproc;\n\tscp->dev = dev;\n\tscp->data = of_device_get_match_data(dev);\n\tplatform_set_drvdata(pdev, scp);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"sram\");\n\tscp->sram_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(scp->sram_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(scp->sram_base),\n\t\t\t\t     \"Failed to parse and map sram memory\\n\");\n\n\tscp->sram_size = resource_size(res);\n\tscp->sram_phys = res->start;\n\n\t \n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"l1tcm\");\n\tscp->l1tcm_base = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(scp->l1tcm_base)) {\n\t\tret = PTR_ERR(scp->l1tcm_base);\n\t\tif (ret != -EINVAL) {\n\t\t\treturn dev_err_probe(dev, ret, \"Failed to map l1tcm memory\\n\");\n\t\t}\n\t} else {\n\t\tscp->l1tcm_size = resource_size(res);\n\t\tscp->l1tcm_phys = res->start;\n\t}\n\n\tscp->reg_base = devm_platform_ioremap_resource_byname(pdev, \"cfg\");\n\tif (IS_ERR(scp->reg_base))\n\t\treturn dev_err_probe(dev, PTR_ERR(scp->reg_base),\n\t\t\t\t     \"Failed to parse and map cfg memory\\n\");\n\n\tret = scp->data->scp_clk_get(scp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = scp_map_memory_region(scp);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&scp->send_lock);\n\tfor (i = 0; i < SCP_IPI_MAX; i++)\n\t\tmutex_init(&scp->ipi_desc[i].lock);\n\n\t \n\tret = scp_ipi_register(scp, SCP_IPI_INIT, scp_init_ipi_handler, scp);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register IPI_SCP_INIT\\n\");\n\t\tgoto release_dev_mem;\n\t}\n\n\tinit_waitqueue_head(&scp->run.wq);\n\tinit_waitqueue_head(&scp->ack_wq);\n\n\tscp_add_rpmsg_subdev(scp);\n\n\tret = devm_request_threaded_irq(dev, platform_get_irq(pdev, 0), NULL,\n\t\t\t\t\tscp_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tpdev->name, scp);\n\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request irq\\n\");\n\t\tgoto remove_subdev;\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto remove_subdev;\n\n\treturn 0;\n\nremove_subdev:\n\tscp_remove_rpmsg_subdev(scp);\n\tscp_ipi_unregister(scp, SCP_IPI_INIT);\nrelease_dev_mem:\n\tscp_unmap_memory_region(scp);\n\tfor (i = 0; i < SCP_IPI_MAX; i++)\n\t\tmutex_destroy(&scp->ipi_desc[i].lock);\n\tmutex_destroy(&scp->send_lock);\n\n\treturn ret;\n}\n\nstatic void scp_remove(struct platform_device *pdev)\n{\n\tstruct mtk_scp *scp = platform_get_drvdata(pdev);\n\tint i;\n\n\trproc_del(scp->rproc);\n\tscp_remove_rpmsg_subdev(scp);\n\tscp_ipi_unregister(scp, SCP_IPI_INIT);\n\tscp_unmap_memory_region(scp);\n\tfor (i = 0; i < SCP_IPI_MAX; i++)\n\t\tmutex_destroy(&scp->ipi_desc[i].lock);\n\tmutex_destroy(&scp->send_lock);\n}\n\nstatic const struct mtk_scp_of_data mt8183_of_data = {\n\t.scp_clk_get = mt8183_scp_clk_get,\n\t.scp_before_load = mt8183_scp_before_load,\n\t.scp_irq_handler = mt8183_scp_irq_handler,\n\t.scp_reset_assert = mt8183_scp_reset_assert,\n\t.scp_reset_deassert = mt8183_scp_reset_deassert,\n\t.scp_stop = mt8183_scp_stop,\n\t.scp_da_to_va = mt8183_scp_da_to_va,\n\t.host_to_scp_reg = MT8183_HOST_TO_SCP,\n\t.host_to_scp_int_bit = MT8183_HOST_IPC_INT_BIT,\n\t.ipi_buf_offset = 0x7bdb0,\n};\n\nstatic const struct mtk_scp_of_data mt8186_of_data = {\n\t.scp_clk_get = mt8195_scp_clk_get,\n\t.scp_before_load = mt8186_scp_before_load,\n\t.scp_irq_handler = mt8183_scp_irq_handler,\n\t.scp_reset_assert = mt8183_scp_reset_assert,\n\t.scp_reset_deassert = mt8183_scp_reset_deassert,\n\t.scp_stop = mt8183_scp_stop,\n\t.scp_da_to_va = mt8183_scp_da_to_va,\n\t.host_to_scp_reg = MT8183_HOST_TO_SCP,\n\t.host_to_scp_int_bit = MT8183_HOST_IPC_INT_BIT,\n\t.ipi_buf_offset = 0x3bdb0,\n};\n\nstatic const struct mtk_scp_of_data mt8188_of_data = {\n\t.scp_clk_get = mt8195_scp_clk_get,\n\t.scp_before_load = mt8192_scp_before_load,\n\t.scp_irq_handler = mt8192_scp_irq_handler,\n\t.scp_reset_assert = mt8192_scp_reset_assert,\n\t.scp_reset_deassert = mt8192_scp_reset_deassert,\n\t.scp_stop = mt8192_scp_stop,\n\t.scp_da_to_va = mt8192_scp_da_to_va,\n\t.host_to_scp_reg = MT8192_GIPC_IN_SET,\n\t.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,\n};\n\nstatic const struct mtk_scp_of_data mt8192_of_data = {\n\t.scp_clk_get = mt8192_scp_clk_get,\n\t.scp_before_load = mt8192_scp_before_load,\n\t.scp_irq_handler = mt8192_scp_irq_handler,\n\t.scp_reset_assert = mt8192_scp_reset_assert,\n\t.scp_reset_deassert = mt8192_scp_reset_deassert,\n\t.scp_stop = mt8192_scp_stop,\n\t.scp_da_to_va = mt8192_scp_da_to_va,\n\t.host_to_scp_reg = MT8192_GIPC_IN_SET,\n\t.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,\n};\n\nstatic const struct mtk_scp_of_data mt8195_of_data = {\n\t.scp_clk_get = mt8195_scp_clk_get,\n\t.scp_before_load = mt8195_scp_before_load,\n\t.scp_irq_handler = mt8192_scp_irq_handler,\n\t.scp_reset_assert = mt8192_scp_reset_assert,\n\t.scp_reset_deassert = mt8192_scp_reset_deassert,\n\t.scp_stop = mt8195_scp_stop,\n\t.scp_da_to_va = mt8192_scp_da_to_va,\n\t.host_to_scp_reg = MT8192_GIPC_IN_SET,\n\t.host_to_scp_int_bit = MT8192_HOST_IPC_INT_BIT,\n};\n\nstatic const struct of_device_id mtk_scp_of_match[] = {\n\t{ .compatible = \"mediatek,mt8183-scp\", .data = &mt8183_of_data },\n\t{ .compatible = \"mediatek,mt8186-scp\", .data = &mt8186_of_data },\n\t{ .compatible = \"mediatek,mt8188-scp\", .data = &mt8188_of_data },\n\t{ .compatible = \"mediatek,mt8192-scp\", .data = &mt8192_of_data },\n\t{ .compatible = \"mediatek,mt8195-scp\", .data = &mt8195_of_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtk_scp_of_match);\n\nstatic struct platform_driver mtk_scp_driver = {\n\t.probe = scp_probe,\n\t.remove_new = scp_remove,\n\t.driver = {\n\t\t.name = \"mtk-scp\",\n\t\t.of_match_table = mtk_scp_of_match,\n\t},\n};\n\nmodule_platform_driver(mtk_scp_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek SCP control driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}