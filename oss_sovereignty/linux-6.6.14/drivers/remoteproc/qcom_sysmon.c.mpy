{
  "module_name": "qcom_sysmon.c",
  "hash_id": "0b8d7ad3c2320805bd621a37f690f739d172361b67cbfecf93761a6a2d6b205a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_sysmon.c",
  "human_readable_source": "\n \n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc/qcom_rproc.h>\n#include <linux/rpmsg.h>\n\n#include \"qcom_common.h\"\n\nstatic BLOCKING_NOTIFIER_HEAD(sysmon_notifiers);\n\nstruct qcom_sysmon {\n\tstruct rproc_subdev subdev;\n\tstruct rproc *rproc;\n\n\tint state;\n\tstruct mutex state_lock;\n\n\tstruct list_head node;\n\n\tconst char *name;\n\n\tint shutdown_irq;\n\tint ssctl_version;\n\tint ssctl_instance;\n\n\tstruct notifier_block nb;\n\n\tstruct device *dev;\n\n\tstruct rpmsg_endpoint *ept;\n\tstruct completion comp;\n\tstruct completion ind_comp;\n\tstruct completion shutdown_comp;\n\tstruct completion ssctl_comp;\n\tstruct mutex lock;\n\n\tbool ssr_ack;\n\tbool shutdown_acked;\n\n\tstruct qmi_handle qmi;\n\tstruct sockaddr_qrtr ssctl;\n};\n\nenum {\n\tSSCTL_SSR_EVENT_BEFORE_POWERUP,\n\tSSCTL_SSR_EVENT_AFTER_POWERUP,\n\tSSCTL_SSR_EVENT_BEFORE_SHUTDOWN,\n\tSSCTL_SSR_EVENT_AFTER_SHUTDOWN,\n};\n\nstatic const char * const sysmon_state_string[] = {\n\t[SSCTL_SSR_EVENT_BEFORE_POWERUP]\t= \"before_powerup\",\n\t[SSCTL_SSR_EVENT_AFTER_POWERUP]\t\t= \"after_powerup\",\n\t[SSCTL_SSR_EVENT_BEFORE_SHUTDOWN]\t= \"before_shutdown\",\n\t[SSCTL_SSR_EVENT_AFTER_SHUTDOWN]\t= \"after_shutdown\",\n};\n\nstruct sysmon_event {\n\tconst char *subsys_name;\n\tu32 ssr_event;\n};\n\nstatic DEFINE_MUTEX(sysmon_lock);\nstatic LIST_HEAD(sysmon_list);\n\n \nstatic void sysmon_send_event(struct qcom_sysmon *sysmon,\n\t\t\t      const struct sysmon_event *event)\n{\n\tchar req[50];\n\tint len;\n\tint ret;\n\n\tlen = snprintf(req, sizeof(req), \"ssr:%s:%s\", event->subsys_name,\n\t\t       sysmon_state_string[event->ssr_event]);\n\tif (len >= sizeof(req))\n\t\treturn;\n\n\tmutex_lock(&sysmon->lock);\n\treinit_completion(&sysmon->comp);\n\tsysmon->ssr_ack = false;\n\n\tret = rpmsg_send(sysmon->ept, req, len);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to send sysmon event\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tret = wait_for_completion_timeout(&sysmon->comp,\n\t\t\t\t\t  msecs_to_jiffies(5000));\n\tif (!ret) {\n\t\tdev_err(sysmon->dev, \"timeout waiting for sysmon ack\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (!sysmon->ssr_ack)\n\t\tdev_err(sysmon->dev, \"unexpected response to sysmon event\\n\");\n\nout_unlock:\n\tmutex_unlock(&sysmon->lock);\n}\n\n \nstatic bool sysmon_request_shutdown(struct qcom_sysmon *sysmon)\n{\n\tchar *req = \"ssr:shutdown\";\n\tbool acked = false;\n\tint ret;\n\n\tmutex_lock(&sysmon->lock);\n\treinit_completion(&sysmon->comp);\n\tsysmon->ssr_ack = false;\n\n\tret = rpmsg_send(sysmon->ept, req, strlen(req) + 1);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"send sysmon shutdown request failed\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tret = wait_for_completion_timeout(&sysmon->comp,\n\t\t\t\t\t  msecs_to_jiffies(5000));\n\tif (!ret) {\n\t\tdev_err(sysmon->dev, \"timeout waiting for sysmon ack\\n\");\n\t\tgoto out_unlock;\n\t}\n\n\tif (!sysmon->ssr_ack)\n\t\tdev_err(sysmon->dev,\n\t\t\t\"unexpected response to sysmon shutdown request\\n\");\n\telse\n\t\tacked = true;\n\nout_unlock:\n\tmutex_unlock(&sysmon->lock);\n\n\treturn acked;\n}\n\nstatic int sysmon_callback(struct rpmsg_device *rpdev, void *data, int count,\n\t\t\t   void *priv, u32 addr)\n{\n\tstruct qcom_sysmon *sysmon = priv;\n\tconst char *ssr_ack = \"ssr:ack\";\n\tconst int ssr_ack_len = strlen(ssr_ack) + 1;\n\n\tif (!sysmon)\n\t\treturn -EINVAL;\n\n\tif (count >= ssr_ack_len && !memcmp(data, ssr_ack, ssr_ack_len))\n\t\tsysmon->ssr_ack = true;\n\n\tcomplete(&sysmon->comp);\n\n\treturn 0;\n}\n\n#define SSCTL_SHUTDOWN_REQ\t\t0x21\n#define SSCTL_SHUTDOWN_READY_IND\t0x21\n#define SSCTL_SUBSYS_EVENT_REQ\t\t0x23\n\n#define SSCTL_MAX_MSG_LEN\t\t7\n\n#define SSCTL_SUBSYS_NAME_LENGTH\t15\n\nenum {\n\tSSCTL_SSR_EVENT_FORCED,\n\tSSCTL_SSR_EVENT_GRACEFUL,\n};\n\nstruct ssctl_shutdown_resp {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstatic const struct qmi_elem_info ssctl_shutdown_resp_ei[] = {\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x02,\n\t\t.offset\t\t= offsetof(struct ssctl_shutdown_resp, resp),\n\t\t.ei_array\t= qmi_response_type_v01_ei,\n\t},\n\t{}\n};\n\nstruct ssctl_subsys_event_req {\n\tu8 subsys_name_len;\n\tchar subsys_name[SSCTL_SUBSYS_NAME_LENGTH];\n\tu32 event;\n\tu8 evt_driven_valid;\n\tu32 evt_driven;\n};\n\nstatic const struct qmi_elem_info ssctl_subsys_event_req_ei[] = {\n\t{\n\t\t.data_type\t= QMI_DATA_LEN,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(uint8_t),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x01,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_req,\n\t\t\t\t\t   subsys_name_len),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_UNSIGNED_1_BYTE,\n\t\t.elem_len\t= SSCTL_SUBSYS_NAME_LENGTH,\n\t\t.elem_size\t= sizeof(char),\n\t\t.array_type\t= VAR_LEN_ARRAY,\n\t\t.tlv_type\t= 0x01,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_req,\n\t\t\t\t\t   subsys_name),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_SIGNED_4_BYTE_ENUM,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(uint32_t),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x02,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_req,\n\t\t\t\t\t   event),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_OPT_FLAG,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(uint8_t),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x10,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_req,\n\t\t\t\t\t   evt_driven_valid),\n\t\t.ei_array\t= NULL,\n\t},\n\t{\n\t\t.data_type\t= QMI_SIGNED_4_BYTE_ENUM,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(uint32_t),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x10,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_req,\n\t\t\t\t\t   evt_driven),\n\t\t.ei_array\t= NULL,\n\t},\n\t{}\n};\n\nstruct ssctl_subsys_event_resp {\n\tstruct qmi_response_type_v01 resp;\n};\n\nstatic const struct qmi_elem_info ssctl_subsys_event_resp_ei[] = {\n\t{\n\t\t.data_type\t= QMI_STRUCT,\n\t\t.elem_len\t= 1,\n\t\t.elem_size\t= sizeof(struct qmi_response_type_v01),\n\t\t.array_type\t= NO_ARRAY,\n\t\t.tlv_type\t= 0x02,\n\t\t.offset\t\t= offsetof(struct ssctl_subsys_event_resp,\n\t\t\t\t\t   resp),\n\t\t.ei_array\t= qmi_response_type_v01_ei,\n\t},\n\t{}\n};\n\nstatic const struct qmi_elem_info ssctl_shutdown_ind_ei[] = {\n\t{}\n};\n\nstatic void sysmon_ind_cb(struct qmi_handle *qmi, struct sockaddr_qrtr *sq,\n\t\t\t  struct qmi_txn *txn, const void *data)\n{\n\tstruct qcom_sysmon *sysmon = container_of(qmi, struct qcom_sysmon, qmi);\n\n\tcomplete(&sysmon->ind_comp);\n}\n\nstatic const struct qmi_msg_handler qmi_indication_handler[] = {\n\t{\n\t\t.type = QMI_INDICATION,\n\t\t.msg_id = SSCTL_SHUTDOWN_READY_IND,\n\t\t.ei = ssctl_shutdown_ind_ei,\n\t\t.decoded_size = 0,\n\t\t.fn = sysmon_ind_cb\n\t},\n\t{}\n};\n\nstatic bool ssctl_request_shutdown_wait(struct qcom_sysmon *sysmon)\n{\n\tint ret;\n\n\tret = wait_for_completion_timeout(&sysmon->shutdown_comp, 10 * HZ);\n\tif (ret)\n\t\treturn true;\n\n\tret = try_wait_for_completion(&sysmon->ind_comp);\n\tif (ret)\n\t\treturn true;\n\n\tdev_err(sysmon->dev, \"timeout waiting for shutdown ack\\n\");\n\treturn false;\n}\n\n \nstatic bool ssctl_request_shutdown(struct qcom_sysmon *sysmon)\n{\n\tstruct ssctl_shutdown_resp resp;\n\tstruct qmi_txn txn;\n\tbool acked = false;\n\tint ret;\n\n\treinit_completion(&sysmon->ind_comp);\n\treinit_completion(&sysmon->shutdown_comp);\n\tret = qmi_txn_init(&sysmon->qmi, &txn, ssctl_shutdown_resp_ei, &resp);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to allocate QMI txn\\n\");\n\t\treturn false;\n\t}\n\n\tret = qmi_send_request(&sysmon->qmi, &sysmon->ssctl, &txn,\n\t\t\t       SSCTL_SHUTDOWN_REQ, 0, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to send shutdown request\\n\");\n\t\tqmi_txn_cancel(&txn);\n\t\treturn false;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"timeout waiting for shutdown response\\n\");\n\t} else if (resp.resp.result) {\n\t\tdev_err(sysmon->dev, \"shutdown request rejected\\n\");\n\t} else {\n\t\tdev_dbg(sysmon->dev, \"shutdown request completed\\n\");\n\t\tacked = true;\n\t}\n\n\tif (sysmon->shutdown_irq > 0)\n\t\treturn ssctl_request_shutdown_wait(sysmon);\n\n\treturn acked;\n}\n\n \nstatic void ssctl_send_event(struct qcom_sysmon *sysmon,\n\t\t\t     const struct sysmon_event *event)\n{\n\tstruct ssctl_subsys_event_resp resp;\n\tstruct ssctl_subsys_event_req req;\n\tstruct qmi_txn txn;\n\tint ret;\n\n\tmemset(&resp, 0, sizeof(resp));\n\tret = qmi_txn_init(&sysmon->qmi, &txn, ssctl_subsys_event_resp_ei, &resp);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to allocate QMI txn\\n\");\n\t\treturn;\n\t}\n\n\tmemset(&req, 0, sizeof(req));\n\tstrscpy(req.subsys_name, event->subsys_name, sizeof(req.subsys_name));\n\treq.subsys_name_len = strlen(req.subsys_name);\n\treq.event = event->ssr_event;\n\treq.evt_driven_valid = true;\n\treq.evt_driven = SSCTL_SSR_EVENT_FORCED;\n\n\tret = qmi_send_request(&sysmon->qmi, &sysmon->ssctl, &txn,\n\t\t\t       SSCTL_SUBSYS_EVENT_REQ, 40,\n\t\t\t       ssctl_subsys_event_req_ei, &req);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to send subsystem event\\n\");\n\t\tqmi_txn_cancel(&txn);\n\t\treturn;\n\t}\n\n\tret = qmi_txn_wait(&txn, 5 * HZ);\n\tif (ret < 0)\n\t\tdev_err(sysmon->dev, \"timeout waiting for subsystem event response\\n\");\n\telse if (resp.resp.result)\n\t\tdev_err(sysmon->dev, \"subsystem event rejected\\n\");\n\telse\n\t\tdev_dbg(sysmon->dev, \"subsystem event accepted\\n\");\n}\n\n \nstatic int ssctl_new_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\n\tstruct qcom_sysmon *sysmon = container_of(qmi, struct qcom_sysmon, qmi);\n\n\tswitch (svc->version) {\n\tcase 1:\n\t\tif (svc->instance != 0)\n\t\t\treturn -EINVAL;\n\t\tif (strcmp(sysmon->name, \"modem\"))\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase 2:\n\t\tif (svc->instance != sysmon->ssctl_instance)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tsysmon->ssctl_version = svc->version;\n\n\tsysmon->ssctl.sq_family = AF_QIPCRTR;\n\tsysmon->ssctl.sq_node = svc->node;\n\tsysmon->ssctl.sq_port = svc->port;\n\n\tsvc->priv = sysmon;\n\n\tcomplete(&sysmon->ssctl_comp);\n\n\treturn 0;\n}\n\n \nstatic void ssctl_del_server(struct qmi_handle *qmi, struct qmi_service *svc)\n{\n\tstruct qcom_sysmon *sysmon = svc->priv;\n\n\tsysmon->ssctl_version = 0;\n}\n\nstatic const struct qmi_ops ssctl_ops = {\n\t.new_server = ssctl_new_server,\n\t.del_server = ssctl_del_server,\n};\n\nstatic int sysmon_prepare(struct rproc_subdev *subdev)\n{\n\tstruct qcom_sysmon *sysmon = container_of(subdev, struct qcom_sysmon,\n\t\t\t\t\t\t  subdev);\n\tstruct sysmon_event event = {\n\t\t.subsys_name = sysmon->name,\n\t\t.ssr_event = SSCTL_SSR_EVENT_BEFORE_POWERUP\n\t};\n\n\tmutex_lock(&sysmon->state_lock);\n\tsysmon->state = SSCTL_SSR_EVENT_BEFORE_POWERUP;\n\tblocking_notifier_call_chain(&sysmon_notifiers, 0, (void *)&event);\n\tmutex_unlock(&sysmon->state_lock);\n\n\treturn 0;\n}\n\n \nstatic int sysmon_start(struct rproc_subdev *subdev)\n{\n\tstruct qcom_sysmon *sysmon = container_of(subdev, struct qcom_sysmon,\n\t\t\t\t\t\t  subdev);\n\tstruct qcom_sysmon *target;\n\tstruct sysmon_event event = {\n\t\t.subsys_name = sysmon->name,\n\t\t.ssr_event = SSCTL_SSR_EVENT_AFTER_POWERUP\n\t};\n\n\treinit_completion(&sysmon->ssctl_comp);\n\tmutex_lock(&sysmon->state_lock);\n\tsysmon->state = SSCTL_SSR_EVENT_AFTER_POWERUP;\n\tblocking_notifier_call_chain(&sysmon_notifiers, 0, (void *)&event);\n\tmutex_unlock(&sysmon->state_lock);\n\n\tmutex_lock(&sysmon_lock);\n\tlist_for_each_entry(target, &sysmon_list, node) {\n\t\tmutex_lock(&target->state_lock);\n\t\tif (target == sysmon || target->state != SSCTL_SSR_EVENT_AFTER_POWERUP) {\n\t\t\tmutex_unlock(&target->state_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tevent.subsys_name = target->name;\n\t\tevent.ssr_event = target->state;\n\n\t\tif (sysmon->ssctl_version == 2)\n\t\t\tssctl_send_event(sysmon, &event);\n\t\telse if (sysmon->ept)\n\t\t\tsysmon_send_event(sysmon, &event);\n\t\tmutex_unlock(&target->state_lock);\n\t}\n\tmutex_unlock(&sysmon_lock);\n\n\treturn 0;\n}\n\nstatic void sysmon_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct qcom_sysmon *sysmon = container_of(subdev, struct qcom_sysmon, subdev);\n\tstruct sysmon_event event = {\n\t\t.subsys_name = sysmon->name,\n\t\t.ssr_event = SSCTL_SSR_EVENT_BEFORE_SHUTDOWN\n\t};\n\n\tsysmon->shutdown_acked = false;\n\n\tmutex_lock(&sysmon->state_lock);\n\tsysmon->state = SSCTL_SSR_EVENT_BEFORE_SHUTDOWN;\n\tblocking_notifier_call_chain(&sysmon_notifiers, 0, (void *)&event);\n\tmutex_unlock(&sysmon->state_lock);\n\n\t \n\tif (crashed)\n\t\treturn;\n\n\tif (sysmon->ssctl_instance) {\n\t\tif (!wait_for_completion_timeout(&sysmon->ssctl_comp, HZ / 2))\n\t\t\tdev_err(sysmon->dev, \"timeout waiting for ssctl service\\n\");\n\t}\n\n\tif (sysmon->ssctl_version)\n\t\tsysmon->shutdown_acked = ssctl_request_shutdown(sysmon);\n\telse if (sysmon->ept)\n\t\tsysmon->shutdown_acked = sysmon_request_shutdown(sysmon);\n}\n\nstatic void sysmon_unprepare(struct rproc_subdev *subdev)\n{\n\tstruct qcom_sysmon *sysmon = container_of(subdev, struct qcom_sysmon,\n\t\t\t\t\t\t  subdev);\n\tstruct sysmon_event event = {\n\t\t.subsys_name = sysmon->name,\n\t\t.ssr_event = SSCTL_SSR_EVENT_AFTER_SHUTDOWN\n\t};\n\n\tmutex_lock(&sysmon->state_lock);\n\tsysmon->state = SSCTL_SSR_EVENT_AFTER_SHUTDOWN;\n\tblocking_notifier_call_chain(&sysmon_notifiers, 0, (void *)&event);\n\tmutex_unlock(&sysmon->state_lock);\n}\n\n \nstatic int sysmon_notify(struct notifier_block *nb, unsigned long event,\n\t\t\t void *data)\n{\n\tstruct qcom_sysmon *sysmon = container_of(nb, struct qcom_sysmon, nb);\n\tstruct sysmon_event *sysmon_event = data;\n\n\t \n\tif (sysmon->state != SSCTL_SSR_EVENT_AFTER_POWERUP ||\n\t    !strcmp(sysmon_event->subsys_name, sysmon->name)) {\n\t\tdev_dbg(sysmon->dev, \"not notifying %s\\n\", sysmon->name);\n\t\treturn NOTIFY_DONE;\n\t}\n\n\t \n\tif (sysmon->ssctl_version == 2)\n\t\tssctl_send_event(sysmon, sysmon_event);\n\telse if (sysmon->ept)\n\t\tsysmon_send_event(sysmon, sysmon_event);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic irqreturn_t sysmon_shutdown_interrupt(int irq, void *data)\n{\n\tstruct qcom_sysmon *sysmon = data;\n\n\tcomplete(&sysmon->shutdown_comp);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstruct qcom_sysmon *qcom_add_sysmon_subdev(struct rproc *rproc,\n\t\t\t\t\t   const char *name,\n\t\t\t\t\t   int ssctl_instance)\n{\n\tstruct qcom_sysmon *sysmon;\n\tint ret;\n\n\tsysmon = kzalloc(sizeof(*sysmon), GFP_KERNEL);\n\tif (!sysmon)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsysmon->dev = rproc->dev.parent;\n\tsysmon->rproc = rproc;\n\n\tsysmon->name = name;\n\tsysmon->ssctl_instance = ssctl_instance;\n\n\tinit_completion(&sysmon->comp);\n\tinit_completion(&sysmon->ind_comp);\n\tinit_completion(&sysmon->shutdown_comp);\n\tinit_completion(&sysmon->ssctl_comp);\n\tmutex_init(&sysmon->lock);\n\tmutex_init(&sysmon->state_lock);\n\n\tsysmon->shutdown_irq = of_irq_get_byname(sysmon->dev->of_node,\n\t\t\t\t\t\t \"shutdown-ack\");\n\tif (sysmon->shutdown_irq < 0) {\n\t\tif (sysmon->shutdown_irq != -ENODATA) {\n\t\t\tdev_err(sysmon->dev,\n\t\t\t\t\"failed to retrieve shutdown-ack IRQ\\n\");\n\t\t\tret = sysmon->shutdown_irq;\n\t\t\tkfree(sysmon);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t} else {\n\t\tret = devm_request_threaded_irq(sysmon->dev,\n\t\t\t\t\t\tsysmon->shutdown_irq,\n\t\t\t\t\t\tNULL, sysmon_shutdown_interrupt,\n\t\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\t\"q6v5 shutdown-ack\", sysmon);\n\t\tif (ret) {\n\t\t\tdev_err(sysmon->dev,\n\t\t\t\t\"failed to acquire shutdown-ack IRQ\\n\");\n\t\t\tkfree(sysmon);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tret = qmi_handle_init(&sysmon->qmi, SSCTL_MAX_MSG_LEN, &ssctl_ops,\n\t\t\t      qmi_indication_handler);\n\tif (ret < 0) {\n\t\tdev_err(sysmon->dev, \"failed to initialize qmi handle\\n\");\n\t\tkfree(sysmon);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tqmi_add_lookup(&sysmon->qmi, 43, 0, 0);\n\n\tsysmon->subdev.prepare = sysmon_prepare;\n\tsysmon->subdev.start = sysmon_start;\n\tsysmon->subdev.stop = sysmon_stop;\n\tsysmon->subdev.unprepare = sysmon_unprepare;\n\n\trproc_add_subdev(rproc, &sysmon->subdev);\n\n\tsysmon->nb.notifier_call = sysmon_notify;\n\tblocking_notifier_chain_register(&sysmon_notifiers, &sysmon->nb);\n\n\tmutex_lock(&sysmon_lock);\n\tlist_add(&sysmon->node, &sysmon_list);\n\tmutex_unlock(&sysmon_lock);\n\n\treturn sysmon;\n}\nEXPORT_SYMBOL_GPL(qcom_add_sysmon_subdev);\n\n \nvoid qcom_remove_sysmon_subdev(struct qcom_sysmon *sysmon)\n{\n\tif (!sysmon)\n\t\treturn;\n\n\tmutex_lock(&sysmon_lock);\n\tlist_del(&sysmon->node);\n\tmutex_unlock(&sysmon_lock);\n\n\tblocking_notifier_chain_unregister(&sysmon_notifiers, &sysmon->nb);\n\n\trproc_remove_subdev(sysmon->rproc, &sysmon->subdev);\n\n\tqmi_handle_release(&sysmon->qmi);\n\n\tkfree(sysmon);\n}\nEXPORT_SYMBOL_GPL(qcom_remove_sysmon_subdev);\n\n \nbool qcom_sysmon_shutdown_acked(struct qcom_sysmon *sysmon)\n{\n\treturn sysmon && sysmon->shutdown_acked;\n}\nEXPORT_SYMBOL_GPL(qcom_sysmon_shutdown_acked);\n\n \nstatic int sysmon_probe(struct rpmsg_device *rpdev)\n{\n\tstruct qcom_sysmon *sysmon;\n\tstruct rproc *rproc;\n\n\trproc = rproc_get_by_child(&rpdev->dev);\n\tif (!rproc) {\n\t\tdev_err(&rpdev->dev, \"sysmon device not child of rproc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&sysmon_lock);\n\tlist_for_each_entry(sysmon, &sysmon_list, node) {\n\t\tif (sysmon->rproc == rproc)\n\t\t\tgoto found;\n\t}\n\tmutex_unlock(&sysmon_lock);\n\n\tdev_err(&rpdev->dev, \"no sysmon associated with parent rproc\\n\");\n\n\treturn -EINVAL;\n\nfound:\n\tmutex_unlock(&sysmon_lock);\n\n\trpdev->ept->priv = sysmon;\n\tsysmon->ept = rpdev->ept;\n\n\treturn 0;\n}\n\n \nstatic void sysmon_remove(struct rpmsg_device *rpdev)\n{\n\tstruct qcom_sysmon *sysmon = rpdev->ept->priv;\n\n\tsysmon->ept = NULL;\n}\n\nstatic const struct rpmsg_device_id sysmon_match[] = {\n\t{ \"sys_mon\" },\n\t{}\n};\n\nstatic struct rpmsg_driver sysmon_driver = {\n\t.probe = sysmon_probe,\n\t.remove = sysmon_remove,\n\t.callback = sysmon_callback,\n\t.id_table = sysmon_match,\n\t.drv = {\n\t\t.name = \"qcom_sysmon\",\n\t},\n};\n\nmodule_rpmsg_driver(sysmon_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm sysmon driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}