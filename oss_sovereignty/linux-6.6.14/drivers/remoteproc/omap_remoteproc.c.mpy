{
  "module_name": "omap_remoteproc.c",
  "hash_id": "d2e6315b3653c0be5a229b15c8ee6efdacdb40117b2b070ca132cf325b5e2b84",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/omap_remoteproc.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/clk.h>\n#include <linux/clk/ti.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/remoteproc.h>\n#include <linux/mailbox_client.h>\n#include <linux/omap-iommu.h>\n#include <linux/omap-mailbox.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/reset.h>\n#include <clocksource/timer-ti-dm.h>\n\n#include <linux/platform_data/dmtimer-omap.h>\n\n#include \"omap_remoteproc.h\"\n#include \"remoteproc_internal.h\"\n\n \n#define DEFAULT_AUTOSUSPEND_DELAY\t\t10000\n\n \nstruct omap_rproc_boot_data {\n\tstruct regmap *syscon;\n\tunsigned int boot_reg;\n\tunsigned int boot_reg_shift;\n};\n\n \nstruct omap_rproc_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\n \nstruct omap_rproc_timer {\n\tstruct omap_dm_timer *odt;\n\tconst struct omap_dm_timer_ops *timer_ops;\n\tint irq;\n};\n\n \nstruct omap_rproc {\n\tstruct mbox_chan *mbox;\n\tstruct mbox_client client;\n\tstruct omap_rproc_boot_data *boot_data;\n\tstruct omap_rproc_mem *mem;\n\tint num_mems;\n\tint num_timers;\n\tint num_wd_timers;\n\tstruct omap_rproc_timer *timers;\n\tint autosuspend_delay;\n\tbool need_resume;\n\tstruct rproc *rproc;\n\tstruct reset_control *reset;\n\tstruct completion pm_comp;\n\tstruct clk *fck;\n\tbool suspend_acked;\n};\n\n \nstruct omap_rproc_mem_data {\n\tconst char *name;\n\tconst u32 dev_addr;\n};\n\n \nstruct omap_rproc_dev_data {\n\tconst char *device_name;\n\tconst struct omap_rproc_mem_data *mems;\n};\n\n \nstatic int omap_rproc_request_timer(struct device *dev, struct device_node *np,\n\t\t\t\t    struct omap_rproc_timer *timer)\n{\n\tint ret;\n\n\ttimer->odt = timer->timer_ops->request_by_node(np);\n\tif (!timer->odt) {\n\t\tdev_err(dev, \"request for timer node %p failed\\n\", np);\n\t\treturn -EBUSY;\n\t}\n\n\tret = timer->timer_ops->set_source(timer->odt, OMAP_TIMER_SRC_SYS_CLK);\n\tif (ret) {\n\t\tdev_err(dev, \"error setting OMAP_TIMER_SRC_SYS_CLK as source for timer node %p\\n\",\n\t\t\tnp);\n\t\ttimer->timer_ops->free(timer->odt);\n\t\treturn ret;\n\t}\n\n\t \n\ttimer->timer_ops->set_load(timer->odt, 0);\n\n\treturn 0;\n}\n\n \nstatic inline int omap_rproc_start_timer(struct omap_rproc_timer *timer)\n{\n\treturn timer->timer_ops->start(timer->odt);\n}\n\n \nstatic inline int omap_rproc_stop_timer(struct omap_rproc_timer *timer)\n{\n\treturn timer->timer_ops->stop(timer->odt);\n}\n\n \nstatic inline int omap_rproc_release_timer(struct omap_rproc_timer *timer)\n{\n\treturn timer->timer_ops->free(timer->odt);\n}\n\n \nstatic inline int omap_rproc_get_timer_irq(struct omap_rproc_timer *timer)\n{\n\treturn timer->timer_ops->get_irq(timer->odt);\n}\n\n \nstatic inline void omap_rproc_ack_timer_irq(struct omap_rproc_timer *timer)\n{\n\ttimer->timer_ops->write_status(timer->odt, OMAP_TIMER_INT_OVERFLOW);\n}\n\n \nstatic irqreturn_t omap_rproc_watchdog_isr(int irq, void *data)\n{\n\tstruct rproc *rproc = data;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tstruct omap_rproc_timer *timers = oproc->timers;\n\tstruct omap_rproc_timer *wd_timer = NULL;\n\tint num_timers = oproc->num_timers + oproc->num_wd_timers;\n\tint i;\n\n\tfor (i = oproc->num_timers; i < num_timers; i++) {\n\t\tif (timers[i].irq > 0 && irq == timers[i].irq) {\n\t\t\twd_timer = &timers[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!wd_timer) {\n\t\tdev_err(dev, \"invalid timer\\n\");\n\t\treturn IRQ_NONE;\n\t}\n\n\tomap_rproc_ack_timer_irq(wd_timer);\n\n\trproc_report_crash(rproc, RPROC_WATCHDOG);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int omap_rproc_enable_timers(struct rproc *rproc, bool configure)\n{\n\tint i;\n\tint ret = 0;\n\tstruct platform_device *tpdev;\n\tstruct dmtimer_platform_data *tpdata;\n\tconst struct omap_dm_timer_ops *timer_ops;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct omap_rproc_timer *timers = oproc->timers;\n\tstruct device *dev = rproc->dev.parent;\n\tstruct device_node *np = NULL;\n\tint num_timers = oproc->num_timers + oproc->num_wd_timers;\n\n\tif (!num_timers)\n\t\treturn 0;\n\n\tif (!configure)\n\t\tgoto start_timers;\n\n\tfor (i = 0; i < num_timers; i++) {\n\t\tif (i < oproc->num_timers)\n\t\t\tnp = of_parse_phandle(dev->of_node, \"ti,timers\", i);\n\t\telse\n\t\t\tnp = of_parse_phandle(dev->of_node,\n\t\t\t\t\t      \"ti,watchdog-timers\",\n\t\t\t\t\t      (i - oproc->num_timers));\n\t\tif (!np) {\n\t\t\tret = -ENXIO;\n\t\t\tdev_err(dev, \"device node lookup for timer at index %d failed: %d\\n\",\n\t\t\t\ti < oproc->num_timers ? i :\n\t\t\t\ti - oproc->num_timers, ret);\n\t\t\tgoto free_timers;\n\t\t}\n\n\t\ttpdev = of_find_device_by_node(np);\n\t\tif (!tpdev) {\n\t\t\tret = -ENODEV;\n\t\t\tdev_err(dev, \"could not get timer platform device\\n\");\n\t\t\tgoto put_node;\n\t\t}\n\n\t\ttpdata = dev_get_platdata(&tpdev->dev);\n\t\tput_device(&tpdev->dev);\n\t\tif (!tpdata) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"dmtimer pdata structure NULL\\n\");\n\t\t\tgoto put_node;\n\t\t}\n\n\t\ttimer_ops = tpdata->timer_ops;\n\t\tif (!timer_ops || !timer_ops->request_by_node ||\n\t\t    !timer_ops->set_source || !timer_ops->set_load ||\n\t\t    !timer_ops->free || !timer_ops->start ||\n\t\t    !timer_ops->stop || !timer_ops->get_irq ||\n\t\t    !timer_ops->write_status) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(dev, \"device does not have required timer ops\\n\");\n\t\t\tgoto put_node;\n\t\t}\n\n\t\ttimers[i].irq = -1;\n\t\ttimers[i].timer_ops = timer_ops;\n\t\tret = omap_rproc_request_timer(dev, np, &timers[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"request for timer %p failed: %d\\n\", np,\n\t\t\t\tret);\n\t\t\tgoto put_node;\n\t\t}\n\t\tof_node_put(np);\n\n\t\tif (i >= oproc->num_timers) {\n\t\t\ttimers[i].irq = omap_rproc_get_timer_irq(&timers[i]);\n\t\t\tif (timers[i].irq < 0) {\n\t\t\t\tdev_err(dev, \"get_irq for timer %p failed: %d\\n\",\n\t\t\t\t\tnp, timers[i].irq);\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto free_timers;\n\t\t\t}\n\n\t\t\tret = request_irq(timers[i].irq,\n\t\t\t\t\t  omap_rproc_watchdog_isr, IRQF_SHARED,\n\t\t\t\t\t  \"rproc-wdt\", rproc);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"error requesting irq for timer %p\\n\",\n\t\t\t\t\tnp);\n\t\t\t\tomap_rproc_release_timer(&timers[i]);\n\t\t\t\ttimers[i].odt = NULL;\n\t\t\t\ttimers[i].timer_ops = NULL;\n\t\t\t\ttimers[i].irq = -1;\n\t\t\t\tgoto free_timers;\n\t\t\t}\n\t\t}\n\t}\n\nstart_timers:\n\tfor (i = 0; i < num_timers; i++) {\n\t\tret = omap_rproc_start_timer(&timers[i]);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"start timer %p failed failed: %d\\n\", np,\n\t\t\t\tret);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (ret) {\n\t\twhile (i >= 0) {\n\t\t\tomap_rproc_stop_timer(&timers[i]);\n\t\t\ti--;\n\t\t}\n\t\tgoto put_node;\n\t}\n\treturn 0;\n\nput_node:\n\tif (configure)\n\t\tof_node_put(np);\nfree_timers:\n\twhile (i--) {\n\t\tif (i >= oproc->num_timers)\n\t\t\tfree_irq(timers[i].irq, rproc);\n\t\tomap_rproc_release_timer(&timers[i]);\n\t\ttimers[i].odt = NULL;\n\t\ttimers[i].timer_ops = NULL;\n\t\ttimers[i].irq = -1;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int omap_rproc_disable_timers(struct rproc *rproc, bool configure)\n{\n\tint i;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct omap_rproc_timer *timers = oproc->timers;\n\tint num_timers = oproc->num_timers + oproc->num_wd_timers;\n\n\tif (!num_timers)\n\t\treturn 0;\n\n\tfor (i = 0; i < num_timers; i++) {\n\t\tomap_rproc_stop_timer(&timers[i]);\n\t\tif (configure) {\n\t\t\tif (i >= oproc->num_timers)\n\t\t\t\tfree_irq(timers[i].irq, rproc);\n\t\t\tomap_rproc_release_timer(&timers[i]);\n\t\t\ttimers[i].odt = NULL;\n\t\t\ttimers[i].timer_ops = NULL;\n\t\t\ttimers[i].irq = -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void omap_rproc_mbox_callback(struct mbox_client *client, void *data)\n{\n\tstruct omap_rproc *oproc = container_of(client, struct omap_rproc,\n\t\t\t\t\t\tclient);\n\tstruct device *dev = oproc->rproc->dev.parent;\n\tconst char *name = oproc->rproc->name;\n\tu32 msg = (u32)data;\n\n\tdev_dbg(dev, \"mbox msg: 0x%x\\n\", msg);\n\n\tswitch (msg) {\n\tcase RP_MBOX_CRASH:\n\t\t \n\t\tdev_err(dev, \"omap rproc %s crashed\\n\", name);\n\t\trproc_report_crash(oproc->rproc, RPROC_FATAL_ERROR);\n\t\tbreak;\n\tcase RP_MBOX_ECHO_REPLY:\n\t\tdev_info(dev, \"received echo reply from %s\\n\", name);\n\t\tbreak;\n\tcase RP_MBOX_SUSPEND_ACK:\n\tcase RP_MBOX_SUSPEND_CANCEL:\n\t\toproc->suspend_acked = msg == RP_MBOX_SUSPEND_ACK;\n\t\tcomplete(&oproc->pm_comp);\n\t\tbreak;\n\tdefault:\n\t\tif (msg >= RP_MBOX_READY && msg < RP_MBOX_END_MSG)\n\t\t\treturn;\n\t\tif (msg > oproc->rproc->max_notifyid) {\n\t\t\tdev_dbg(dev, \"dropping unknown message 0x%x\", msg);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (rproc_vq_interrupt(oproc->rproc, msg) == IRQ_NONE)\n\t\t\tdev_dbg(dev, \"no message was found in vqid %d\\n\", msg);\n\t}\n}\n\n \nstatic void omap_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(dev);\n\tif (WARN_ON(ret < 0)) {\n\t\tdev_err(dev, \"pm_runtime_get_sync() failed during kick, ret = %d\\n\",\n\t\t\tret);\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn;\n\t}\n\n\t \n\tret = mbox_send_message(oproc->mbox, (void *)vqid);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to send mailbox message, status = %d\\n\",\n\t\t\tret);\n\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n}\n\n \nstatic int omap_rproc_write_dsp_boot_addr(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct omap_rproc_boot_data *bdata = oproc->boot_data;\n\tu32 offset = bdata->boot_reg;\n\tu32 value;\n\tu32 mask;\n\n\tif (rproc->bootaddr & (SZ_1K - 1)) {\n\t\tdev_err(dev, \"invalid boot address 0x%llx, must be aligned on a 1KB boundary\\n\",\n\t\t\trproc->bootaddr);\n\t\treturn -EINVAL;\n\t}\n\n\tvalue = rproc->bootaddr >> bdata->boot_reg_shift;\n\tmask = ~(SZ_1K - 1) >> bdata->boot_reg_shift;\n\n\treturn regmap_update_bits(bdata->syscon, offset, mask, value);\n}\n\n \nstatic int omap_rproc_start(struct rproc *rproc)\n{\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\tstruct mbox_client *client = &oproc->client;\n\n\tif (oproc->boot_data) {\n\t\tret = omap_rproc_write_dsp_boot_addr(rproc);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tclient->dev = dev;\n\tclient->tx_done = NULL;\n\tclient->rx_callback = omap_rproc_mbox_callback;\n\tclient->tx_block = false;\n\tclient->knows_txdone = false;\n\n\toproc->mbox = mbox_request_channel(client, 0);\n\tif (IS_ERR(oproc->mbox)) {\n\t\tret = -EBUSY;\n\t\tdev_err(dev, \"mbox_request_channel failed: %ld\\n\",\n\t\t\tPTR_ERR(oproc->mbox));\n\t\treturn ret;\n\t}\n\n\t \n\tret = mbox_send_message(oproc->mbox, (void *)RP_MBOX_ECHO_REQUEST);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mbox_send_message failed: %d\\n\", ret);\n\t\tgoto put_mbox;\n\t}\n\n\tret = omap_rproc_enable_timers(rproc, true);\n\tif (ret) {\n\t\tdev_err(dev, \"omap_rproc_enable_timers failed: %d\\n\", ret);\n\t\tgoto put_mbox;\n\t}\n\n\tret = reset_control_deassert(oproc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset control deassert failed: %d\\n\", ret);\n\t\tgoto disable_timers;\n\t}\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_get_noresume(dev);\n\tpm_runtime_enable(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\n\treturn 0;\n\ndisable_timers:\n\tomap_rproc_disable_timers(rproc, true);\nput_mbox:\n\tmbox_free_channel(oproc->mbox);\n\treturn ret;\n}\n\n \nstatic int omap_rproc_stop(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint ret;\n\n\t \n\tret = pm_runtime_get_sync(dev);\n\tif (ret < 0) {\n\t\tpm_runtime_put_noidle(dev);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_assert(oproc->reset);\n\tif (ret)\n\t\tgoto out;\n\n\tret = omap_rproc_disable_timers(rproc, true);\n\tif (ret)\n\t\tgoto enable_device;\n\n\tmbox_free_channel(oproc->mbox);\n\n\t \n\tpm_runtime_disable(dev);\n\tpm_runtime_dont_use_autosuspend(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_suspended(dev);\n\n\treturn 0;\n\nenable_device:\n\treset_control_deassert(oproc->reset);\nout:\n\t \n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\treturn ret;\n}\n\n \nstatic void *omap_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint i;\n\tu32 offset;\n\n\tif (len <= 0)\n\t\treturn NULL;\n\n\tif (!oproc->num_mems)\n\t\treturn NULL;\n\n\tfor (i = 0; i < oproc->num_mems; i++) {\n\t\tif (da >= oproc->mem[i].dev_addr && da + len <=\n\t\t    oproc->mem[i].dev_addr + oproc->mem[i].size) {\n\t\t\toffset = da - oproc->mem[i].dev_addr;\n\t\t\t \n\t\t\treturn (__force void *)(oproc->mem[i].cpu_addr +\n\t\t\t\t\t\toffset);\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct rproc_ops omap_rproc_ops = {\n\t.start\t\t= omap_rproc_start,\n\t.stop\t\t= omap_rproc_stop,\n\t.kick\t\t= omap_rproc_kick,\n\t.da_to_va\t= omap_rproc_da_to_va,\n};\n\n#ifdef CONFIG_PM\nstatic bool _is_rproc_in_standby(struct omap_rproc *oproc)\n{\n\treturn ti_clk_is_in_standby(oproc->fck);\n}\n\n \n#define DEF_SUSPEND_TIMEOUT 1000\nstatic int _omap_rproc_suspend(struct rproc *rproc, bool auto_suspend)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tunsigned long to = msecs_to_jiffies(DEF_SUSPEND_TIMEOUT);\n\tunsigned long ta = jiffies + to;\n\tu32 suspend_msg = auto_suspend ?\n\t\t\t\tRP_MBOX_SUSPEND_AUTO : RP_MBOX_SUSPEND_SYSTEM;\n\tint ret;\n\n\treinit_completion(&oproc->pm_comp);\n\toproc->suspend_acked = false;\n\tret = mbox_send_message(oproc->mbox, (void *)suspend_msg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"PM mbox_send_message failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = wait_for_completion_timeout(&oproc->pm_comp, to);\n\tif (!oproc->suspend_acked)\n\t\treturn -EBUSY;\n\n\t \n\twhile (!_is_rproc_in_standby(oproc)) {\n\t\tif (time_after(jiffies, ta))\n\t\t\treturn -ETIME;\n\t\tschedule();\n\t}\n\n\tret = reset_control_assert(oproc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset assert during suspend failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = omap_rproc_disable_timers(rproc, false);\n\tif (ret) {\n\t\tdev_err(dev, \"disabling timers during suspend failed %d\\n\",\n\t\t\tret);\n\t\tgoto enable_device;\n\t}\n\n\t \n\tif (auto_suspend) {\n\t\tret = omap_iommu_domain_deactivate(rproc->domain);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"iommu domain deactivate failed %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto enable_timers;\n\t\t}\n\t}\n\n\treturn 0;\n\nenable_timers:\n\t \n\tomap_rproc_enable_timers(rproc, false);\nenable_device:\n\treset_control_deassert(oproc->reset);\n\treturn ret;\n}\n\nstatic int _omap_rproc_resume(struct rproc *rproc, bool auto_suspend)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint ret;\n\n\t \n\tif (auto_suspend) {\n\t\tret = omap_iommu_domain_activate(rproc->domain);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"omap_iommu activate failed %d\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tif (oproc->boot_data) {\n\t\tret = omap_rproc_write_dsp_boot_addr(rproc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"boot address restore failed %d\\n\", ret);\n\t\t\tgoto suspend_iommu;\n\t\t}\n\t}\n\n\tret = omap_rproc_enable_timers(rproc, false);\n\tif (ret) {\n\t\tdev_err(dev, \"enabling timers during resume failed %d\\n\", ret);\n\t\tgoto suspend_iommu;\n\t}\n\n\tret = reset_control_deassert(oproc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset deassert during resume failed %d\\n\", ret);\n\t\tgoto disable_timers;\n\t}\n\n\treturn 0;\n\ndisable_timers:\n\tomap_rproc_disable_timers(rproc, false);\nsuspend_iommu:\n\tif (auto_suspend)\n\t\tomap_iommu_domain_deactivate(rproc->domain);\nout:\n\treturn ret;\n}\n\nstatic int __maybe_unused omap_rproc_suspend(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint ret = 0;\n\n\tmutex_lock(&rproc->lock);\n\tif (rproc->state == RPROC_OFFLINE)\n\t\tgoto out;\n\n\tif (rproc->state == RPROC_SUSPENDED)\n\t\tgoto out;\n\n\tif (rproc->state != RPROC_RUNNING) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = _omap_rproc_suspend(rproc, false);\n\tif (ret) {\n\t\tdev_err(dev, \"suspend failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\t \n\toproc->need_resume = true;\n\trproc->state = RPROC_SUSPENDED;\n\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\n\nstatic int __maybe_unused omap_rproc_resume(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint ret = 0;\n\n\tmutex_lock(&rproc->lock);\n\tif (rproc->state == RPROC_OFFLINE)\n\t\tgoto out;\n\n\tif (rproc->state != RPROC_SUSPENDED) {\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!oproc->need_resume)\n\t\tgoto out;\n\n\tret = _omap_rproc_resume(rproc, false);\n\tif (ret) {\n\t\tdev_err(dev, \"resume failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\toproc->need_resume = false;\n\trproc->state = RPROC_RUNNING;\n\n\tpm_runtime_mark_last_busy(dev);\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\n\nstatic int omap_rproc_runtime_suspend(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct omap_rproc *oproc = rproc->priv;\n\tint ret;\n\n\tmutex_lock(&rproc->lock);\n\tif (rproc->state == RPROC_CRASHED) {\n\t\tdev_dbg(dev, \"rproc cannot be runtime suspended when crashed!\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON(rproc->state != RPROC_RUNNING)) {\n\t\tdev_err(dev, \"rproc cannot be runtime suspended when not running!\\n\");\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif (!_is_rproc_in_standby(oproc)) {\n\t\tret = -EBUSY;\n\t\tgoto abort;\n\t}\n\n\tret = _omap_rproc_suspend(rproc, true);\n\tif (ret)\n\t\tgoto abort;\n\n\trproc->state = RPROC_SUSPENDED;\n\tmutex_unlock(&rproc->lock);\n\treturn 0;\n\nabort:\n\tpm_runtime_mark_last_busy(dev);\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\n\nstatic int omap_rproc_runtime_resume(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tint ret;\n\n\tmutex_lock(&rproc->lock);\n\tif (WARN_ON(rproc->state != RPROC_SUSPENDED)) {\n\t\tdev_err(dev, \"rproc cannot be runtime resumed if not suspended! state=%d\\n\",\n\t\t\trproc->state);\n\t\tret = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tret = _omap_rproc_resume(rproc, true);\n\tif (ret) {\n\t\tdev_err(dev, \"runtime resume failed %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\trproc->state = RPROC_RUNNING;\nout:\n\tmutex_unlock(&rproc->lock);\n\treturn ret;\n}\n#endif  \n\nstatic const struct omap_rproc_mem_data ipu_mems[] = {\n\t{ .name = \"l2ram\", .dev_addr = 0x20000000 },\n\t{ },\n};\n\nstatic const struct omap_rproc_mem_data dra7_dsp_mems[] = {\n\t{ .name = \"l2ram\", .dev_addr = 0x800000 },\n\t{ .name = \"l1pram\", .dev_addr = 0xe00000 },\n\t{ .name = \"l1dram\", .dev_addr = 0xf00000 },\n\t{ },\n};\n\nstatic const struct omap_rproc_dev_data omap4_dsp_dev_data = {\n\t.device_name\t= \"dsp\",\n};\n\nstatic const struct omap_rproc_dev_data omap4_ipu_dev_data = {\n\t.device_name\t= \"ipu\",\n\t.mems\t\t= ipu_mems,\n};\n\nstatic const struct omap_rproc_dev_data omap5_dsp_dev_data = {\n\t.device_name\t= \"dsp\",\n};\n\nstatic const struct omap_rproc_dev_data omap5_ipu_dev_data = {\n\t.device_name\t= \"ipu\",\n\t.mems\t\t= ipu_mems,\n};\n\nstatic const struct omap_rproc_dev_data dra7_dsp_dev_data = {\n\t.device_name\t= \"dsp\",\n\t.mems\t\t= dra7_dsp_mems,\n};\n\nstatic const struct omap_rproc_dev_data dra7_ipu_dev_data = {\n\t.device_name\t= \"ipu\",\n\t.mems\t\t= ipu_mems,\n};\n\nstatic const struct of_device_id omap_rproc_of_match[] = {\n\t{\n\t\t.compatible     = \"ti,omap4-dsp\",\n\t\t.data           = &omap4_dsp_dev_data,\n\t},\n\t{\n\t\t.compatible     = \"ti,omap4-ipu\",\n\t\t.data           = &omap4_ipu_dev_data,\n\t},\n\t{\n\t\t.compatible     = \"ti,omap5-dsp\",\n\t\t.data           = &omap5_dsp_dev_data,\n\t},\n\t{\n\t\t.compatible     = \"ti,omap5-ipu\",\n\t\t.data           = &omap5_ipu_dev_data,\n\t},\n\t{\n\t\t.compatible     = \"ti,dra7-dsp\",\n\t\t.data           = &dra7_dsp_dev_data,\n\t},\n\t{\n\t\t.compatible     = \"ti,dra7-ipu\",\n\t\t.data           = &dra7_ipu_dev_data,\n\t},\n\t{\n\t\t \n\t},\n};\nMODULE_DEVICE_TABLE(of, omap_rproc_of_match);\n\nstatic const char *omap_rproc_get_firmware(struct platform_device *pdev)\n{\n\tconst char *fw_name;\n\tint ret;\n\n\tret = of_property_read_string(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t      &fw_name);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\treturn fw_name;\n}\n\nstatic int omap_rproc_get_boot_data(struct platform_device *pdev,\n\t\t\t\t    struct rproc *rproc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tconst struct omap_rproc_dev_data *data;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tif (!of_property_read_bool(np, \"ti,bootreg\"))\n\t\treturn 0;\n\n\toproc->boot_data = devm_kzalloc(&pdev->dev, sizeof(*oproc->boot_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!oproc->boot_data)\n\t\treturn -ENOMEM;\n\n\toproc->boot_data->syscon =\n\t\t\tsyscon_regmap_lookup_by_phandle(np, \"ti,bootreg\");\n\tif (IS_ERR(oproc->boot_data->syscon)) {\n\t\tret = PTR_ERR(oproc->boot_data->syscon);\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_u32_index(np, \"ti,bootreg\", 1,\n\t\t\t\t       &oproc->boot_data->boot_reg)) {\n\t\tdev_err(&pdev->dev, \"couldn't get the boot register\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tof_property_read_u32_index(np, \"ti,bootreg\", 2,\n\t\t\t\t   &oproc->boot_data->boot_reg_shift);\n\n\treturn 0;\n}\n\nstatic int omap_rproc_of_get_internal_memories(struct platform_device *pdev,\n\t\t\t\t\t       struct rproc *rproc)\n{\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct device *dev = &pdev->dev;\n\tconst struct omap_rproc_dev_data *data;\n\tstruct resource *res;\n\tint num_mems;\n\tint i;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tif (!data->mems)\n\t\treturn 0;\n\n\tnum_mems = of_property_count_elems_of_size(dev->of_node, \"reg\",\n\t\t\t\t\t\t   sizeof(u32)) / 2;\n\n\toproc->mem = devm_kcalloc(dev, num_mems, sizeof(*oproc->mem),\n\t\t\t\t  GFP_KERNEL);\n\tif (!oproc->mem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; data->mems[i].name; i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   data->mems[i].name);\n\t\tif (!res) {\n\t\t\tdev_err(dev, \"no memory defined for %s\\n\",\n\t\t\t\tdata->mems[i].name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\toproc->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(oproc->mem[i].cpu_addr)) {\n\t\t\tdev_err(dev, \"failed to parse and map %s memory\\n\",\n\t\t\t\tdata->mems[i].name);\n\t\t\treturn PTR_ERR(oproc->mem[i].cpu_addr);\n\t\t}\n\t\toproc->mem[i].bus_addr = res->start;\n\t\toproc->mem[i].dev_addr = data->mems[i].dev_addr;\n\t\toproc->mem[i].size = resource_size(res);\n\n\t\tdev_dbg(dev, \"memory %8s: bus addr %pa size 0x%x va %pK da 0x%x\\n\",\n\t\t\tdata->mems[i].name, &oproc->mem[i].bus_addr,\n\t\t\toproc->mem[i].size, oproc->mem[i].cpu_addr,\n\t\t\toproc->mem[i].dev_addr);\n\t}\n\toproc->num_mems = num_mems;\n\n\treturn 0;\n}\n\n#ifdef CONFIG_OMAP_REMOTEPROC_WATCHDOG\nstatic int omap_rproc_count_wdog_timers(struct device *dev)\n{\n\tstruct device_node *np = dev->of_node;\n\tint ret;\n\n\tret = of_count_phandle_with_args(np, \"ti,watchdog-timers\", NULL);\n\tif (ret <= 0) {\n\t\tdev_dbg(dev, \"device does not have watchdog timers, status = %d\\n\",\n\t\t\tret);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n#else\nstatic int omap_rproc_count_wdog_timers(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic int omap_rproc_of_get_timers(struct platform_device *pdev,\n\t\t\t\t    struct rproc *rproc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct omap_rproc *oproc = rproc->priv;\n\tstruct device *dev = &pdev->dev;\n\tint num_timers;\n\n\t \n\toproc->num_timers = of_count_phandle_with_args(np, \"ti,timers\", NULL);\n\tif (oproc->num_timers <= 0) {\n\t\tdev_dbg(dev, \"device does not have timers, status = %d\\n\",\n\t\t\toproc->num_timers);\n\t\toproc->num_timers = 0;\n\t}\n\n\toproc->num_wd_timers = omap_rproc_count_wdog_timers(dev);\n\n\tnum_timers = oproc->num_timers + oproc->num_wd_timers;\n\tif (num_timers) {\n\t\toproc->timers = devm_kcalloc(dev, num_timers,\n\t\t\t\t\t     sizeof(*oproc->timers),\n\t\t\t\t\t     GFP_KERNEL);\n\t\tif (!oproc->timers)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_dbg(dev, \"device has %d tick timers and %d watchdog timers\\n\",\n\t\t\toproc->num_timers, oproc->num_wd_timers);\n\t}\n\n\treturn 0;\n}\n\nstatic int omap_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct omap_rproc *oproc;\n\tstruct rproc *rproc;\n\tconst char *firmware;\n\tint ret;\n\tstruct reset_control *reset;\n\n\tif (!np) {\n\t\tdev_err(&pdev->dev, \"only DT-based devices are supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treset = devm_reset_control_array_get_exclusive(&pdev->dev);\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\tfirmware = omap_rproc_get_firmware(pdev);\n\tif (IS_ERR(firmware))\n\t\treturn PTR_ERR(firmware);\n\n\tret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"dma_set_coherent_mask: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trproc = rproc_alloc(&pdev->dev, dev_name(&pdev->dev), &omap_rproc_ops,\n\t\t\t    firmware, sizeof(*oproc));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\toproc = rproc->priv;\n\toproc->rproc = rproc;\n\toproc->reset = reset;\n\t \n\trproc->has_iommu = true;\n\n\tret = omap_rproc_of_get_internal_memories(pdev, rproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = omap_rproc_get_boot_data(pdev, rproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = omap_rproc_of_get_timers(pdev, rproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tinit_completion(&oproc->pm_comp);\n\toproc->autosuspend_delay = DEFAULT_AUTOSUSPEND_DELAY;\n\n\tof_property_read_u32(pdev->dev.of_node, \"ti,autosuspend-delay-ms\",\n\t\t\t     &oproc->autosuspend_delay);\n\n\tpm_runtime_set_autosuspend_delay(&pdev->dev, oproc->autosuspend_delay);\n\n\toproc->fck = devm_clk_get(&pdev->dev, 0);\n\tif (IS_ERR(oproc->fck)) {\n\t\tret = PTR_ERR(oproc->fck);\n\t\tgoto free_rproc;\n\t}\n\n\tret = of_reserved_mem_device_init(&pdev->dev);\n\tif (ret) {\n\t\tdev_warn(&pdev->dev, \"device does not have specific CMA pool.\\n\");\n\t\tdev_warn(&pdev->dev, \"Typically this should be provided,\\n\");\n\t\tdev_warn(&pdev->dev, \"only omit if you know what you are doing.\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto release_mem;\n\n\treturn 0;\n\nrelease_mem:\n\tof_reserved_mem_device_release(&pdev->dev);\nfree_rproc:\n\trproc_free(rproc);\n\treturn ret;\n}\n\nstatic void omap_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\n\trproc_del(rproc);\n\trproc_free(rproc);\n\tof_reserved_mem_device_release(&pdev->dev);\n}\n\nstatic const struct dev_pm_ops omap_rproc_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(omap_rproc_suspend, omap_rproc_resume)\n\tSET_RUNTIME_PM_OPS(omap_rproc_runtime_suspend,\n\t\t\t   omap_rproc_runtime_resume, NULL)\n};\n\nstatic struct platform_driver omap_rproc_driver = {\n\t.probe = omap_rproc_probe,\n\t.remove_new = omap_rproc_remove,\n\t.driver = {\n\t\t.name = \"omap-rproc\",\n\t\t.pm = &omap_rproc_pm_ops,\n\t\t.of_match_table = omap_rproc_of_match,\n\t},\n};\n\nmodule_platform_driver(omap_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"OMAP Remote Processor control driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}