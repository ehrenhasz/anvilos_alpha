{
  "module_name": "xlnx_r5_remoteproc.c",
  "hash_id": "76da514fdf2a3433231aa39a7b40cb852dec3c8e9fb0ad49c243557bd461cb36",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/xlnx_r5_remoteproc.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/power/xlnx-zynqmp-power.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware/xlnx-zynqmp.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/mailbox/zynqmp-ipi-message.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n\n#include \"remoteproc_internal.h\"\n\n \n#define IPI_BUF_LEN_MAX\t32U\n\n \n#define MBOX_CLIENT_BUF_MAX\t(IPI_BUF_LEN_MAX + \\\n\t\t\t\t sizeof(struct zynqmp_ipi_message))\n \nenum zynqmp_r5_cluster_mode {\n\tSPLIT_MODE = 0,  \n\tLOCKSTEP_MODE = 1,  \n\tSINGLE_CPU_MODE = 2,  \n};\n\n \nstruct mem_bank_data {\n\tphys_addr_t addr;\n\tsize_t size;\n\tu32 pm_domain_id;\n\tchar *bank_name;\n};\n\n \nstruct mbox_info {\n\tunsigned char rx_mc_buf[MBOX_CLIENT_BUF_MAX];\n\tunsigned char tx_mc_buf[MBOX_CLIENT_BUF_MAX];\n\tstruct zynqmp_r5_core *r5_core;\n\tstruct work_struct mbox_work;\n\tstruct mbox_client mbox_cl;\n\tstruct mbox_chan *tx_chan;\n\tstruct mbox_chan *rx_chan;\n};\n\n \nstatic const struct mem_bank_data zynqmp_tcm_banks[] = {\n\t{0xffe00000UL, 0x10000UL, PD_R5_0_ATCM, \"atcm0\"},  \n\t{0xffe20000UL, 0x10000UL, PD_R5_0_BTCM, \"btcm0\"},\n\t{0xffe90000UL, 0x10000UL, PD_R5_1_ATCM, \"atcm1\"},\n\t{0xffeb0000UL, 0x10000UL, PD_R5_1_BTCM, \"btcm1\"},\n};\n\n \nstruct zynqmp_r5_core {\n\tstruct device *dev;\n\tstruct device_node *np;\n\tint tcm_bank_count;\n\tstruct mem_bank_data **tcm_banks;\n\tstruct rproc *rproc;\n\tu32 pm_domain_id;\n\tstruct mbox_info *ipi;\n};\n\n \nstruct zynqmp_r5_cluster {\n\tstruct device *dev;\n\tenum  zynqmp_r5_cluster_mode mode;\n\tint core_count;\n\tstruct zynqmp_r5_core **r5_cores;\n};\n\n \nstatic int event_notified_idr_cb(int id, void *ptr, void *data)\n{\n\tstruct rproc *rproc = data;\n\n\tif (rproc_vq_interrupt(rproc, id) == IRQ_NONE)\n\t\tdev_dbg(&rproc->dev, \"data not found for vqid=%d\\n\", id);\n\n\treturn 0;\n}\n\n \nstatic void handle_event_notified(struct work_struct *work)\n{\n\tstruct mbox_info *ipi;\n\tstruct rproc *rproc;\n\n\tipi = container_of(work, struct mbox_info, mbox_work);\n\trproc = ipi->r5_core->rproc;\n\n\t \n\tidr_for_each(&rproc->notifyids, event_notified_idr_cb, rproc);\n}\n\n \nstatic void zynqmp_r5_mb_rx_cb(struct mbox_client *cl, void *msg)\n{\n\tstruct zynqmp_ipi_message *ipi_msg, *buf_msg;\n\tstruct mbox_info *ipi;\n\tsize_t len;\n\n\tipi = container_of(cl, struct mbox_info, mbox_cl);\n\n\t \n\tipi_msg = (struct zynqmp_ipi_message *)msg;\n\tbuf_msg = (struct zynqmp_ipi_message *)ipi->rx_mc_buf;\n\tlen = ipi_msg->len;\n\tif (len > IPI_BUF_LEN_MAX) {\n\t\tdev_warn(cl->dev, \"msg size exceeded than %d\\n\",\n\t\t\t IPI_BUF_LEN_MAX);\n\t\tlen = IPI_BUF_LEN_MAX;\n\t}\n\tbuf_msg->len = len;\n\tmemcpy(buf_msg->data, ipi_msg->data, len);\n\n\t \n\tif (mbox_send_message(ipi->rx_chan, NULL) < 0)\n\t\tdev_err(cl->dev, \"ack failed to mbox rx_chan\\n\");\n\n\tschedule_work(&ipi->mbox_work);\n}\n\n \nstatic struct mbox_info *zynqmp_r5_setup_mbox(struct device *cdev)\n{\n\tstruct mbox_client *mbox_cl;\n\tstruct mbox_info *ipi;\n\n\tipi = kzalloc(sizeof(*ipi), GFP_KERNEL);\n\tif (!ipi)\n\t\treturn NULL;\n\n\tmbox_cl = &ipi->mbox_cl;\n\tmbox_cl->rx_callback = zynqmp_r5_mb_rx_cb;\n\tmbox_cl->tx_block = false;\n\tmbox_cl->knows_txdone = false;\n\tmbox_cl->tx_done = NULL;\n\tmbox_cl->dev = cdev;\n\n\t \n\tipi->tx_chan = mbox_request_channel_byname(mbox_cl, \"tx\");\n\tif (IS_ERR(ipi->tx_chan)) {\n\t\tipi->tx_chan = NULL;\n\t\tkfree(ipi);\n\t\tdev_warn(cdev, \"mbox tx channel request failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tipi->rx_chan = mbox_request_channel_byname(mbox_cl, \"rx\");\n\tif (IS_ERR(ipi->rx_chan)) {\n\t\tmbox_free_channel(ipi->tx_chan);\n\t\tipi->rx_chan = NULL;\n\t\tipi->tx_chan = NULL;\n\t\tkfree(ipi);\n\t\tdev_warn(cdev, \"mbox rx channel request failed\\n\");\n\t\treturn NULL;\n\t}\n\n\tINIT_WORK(&ipi->mbox_work, handle_event_notified);\n\n\treturn ipi;\n}\n\nstatic void zynqmp_r5_free_mbox(struct mbox_info *ipi)\n{\n\tif (!ipi)\n\t\treturn;\n\n\tif (ipi->tx_chan) {\n\t\tmbox_free_channel(ipi->tx_chan);\n\t\tipi->tx_chan = NULL;\n\t}\n\n\tif (ipi->rx_chan) {\n\t\tmbox_free_channel(ipi->rx_chan);\n\t\tipi->rx_chan = NULL;\n\t}\n\n\tkfree(ipi);\n}\n\n \nstatic void zynqmp_r5_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct zynqmp_r5_core *r5_core = rproc->priv;\n\tstruct device *dev = r5_core->dev;\n\tstruct zynqmp_ipi_message *mb_msg;\n\tstruct mbox_info *ipi;\n\tint ret;\n\n\tipi = r5_core->ipi;\n\tif (!ipi)\n\t\treturn;\n\n\tmb_msg = (struct zynqmp_ipi_message *)ipi->tx_mc_buf;\n\tmemcpy(mb_msg->data, &vqid, sizeof(vqid));\n\tmb_msg->len = sizeof(vqid);\n\tret = mbox_send_message(ipi->tx_chan, mb_msg);\n\tif (ret < 0)\n\t\tdev_warn(dev, \"failed to send message\\n\");\n}\n\n \nstatic int zynqmp_r5_set_mode(struct zynqmp_r5_core *r5_core,\n\t\t\t      enum rpu_oper_mode fw_reg_val,\n\t\t\t      enum rpu_tcm_comb tcm_mode)\n{\n\tint ret;\n\n\tret = zynqmp_pm_set_rpu_mode(r5_core->pm_domain_id, fw_reg_val);\n\tif (ret < 0) {\n\t\tdev_err(r5_core->dev, \"failed to set RPU mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = zynqmp_pm_set_tcm_config(r5_core->pm_domain_id, tcm_mode);\n\tif (ret < 0)\n\t\tdev_err(r5_core->dev, \"failed to configure TCM\\n\");\n\n\treturn ret;\n}\n\n \nstatic int zynqmp_r5_rproc_start(struct rproc *rproc)\n{\n\tstruct zynqmp_r5_core *r5_core = rproc->priv;\n\tenum rpu_boot_mem bootmem;\n\tint ret;\n\n\t \n\tbootmem = (rproc->bootaddr >= 0xFFFC0000) ?\n\t\t   PM_RPU_BOOTMEM_HIVEC : PM_RPU_BOOTMEM_LOVEC;\n\n\tdev_dbg(r5_core->dev, \"RPU boot addr 0x%llx from %s.\", rproc->bootaddr,\n\t\tbootmem == PM_RPU_BOOTMEM_HIVEC ? \"OCM\" : \"TCM\");\n\n\tret = zynqmp_pm_request_wake(r5_core->pm_domain_id, 1,\n\t\t\t\t     bootmem, ZYNQMP_PM_REQUEST_ACK_NO);\n\tif (ret)\n\t\tdev_err(r5_core->dev,\n\t\t\t\"failed to start RPU = 0x%x\\n\", r5_core->pm_domain_id);\n\treturn ret;\n}\n\n \nstatic int zynqmp_r5_rproc_stop(struct rproc *rproc)\n{\n\tstruct zynqmp_r5_core *r5_core = rproc->priv;\n\tint ret;\n\n\tret = zynqmp_pm_force_pwrdwn(r5_core->pm_domain_id,\n\t\t\t\t     ZYNQMP_PM_REQUEST_ACK_BLOCKING);\n\tif (ret)\n\t\tdev_err(r5_core->dev, \"failed to stop remoteproc RPU %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int zynqmp_r5_mem_region_map(struct rproc *rproc,\n\t\t\t\t    struct rproc_mem_entry *mem)\n{\n\tvoid __iomem *va;\n\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (IS_ERR_OR_NULL(va))\n\t\treturn -ENOMEM;\n\n\tmem->va = (void *)va;\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_r5_mem_region_unmap(struct rproc *rproc,\n\t\t\t\t      struct rproc_mem_entry *mem)\n{\n\tiounmap((void __iomem *)mem->va);\n\treturn 0;\n}\n\n \nstatic int add_mem_regions_carveout(struct rproc *rproc)\n{\n\tstruct rproc_mem_entry *rproc_mem;\n\tstruct zynqmp_r5_core *r5_core;\n\tstruct of_phandle_iterator it;\n\tstruct reserved_mem *rmem;\n\tint i = 0;\n\n\tr5_core = rproc->priv;\n\n\t \n\tof_phandle_iterator_init(&it, r5_core->np, \"memory-region\", NULL, 0);\n\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(&rproc->dev, \"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!strcmp(it.node->name, \"vdev0buffer\")) {\n\t\t\t \n\t\t\trproc_mem = rproc_of_resm_mem_entry_init(&rproc->dev, i,\n\t\t\t\t\t\t\t\t rmem->size,\n\t\t\t\t\t\t\t\t rmem->base,\n\t\t\t\t\t\t\t\t it.node->name);\n\t\t} else {\n\t\t\t \n\t\t\trproc_mem = rproc_mem_entry_init(&rproc->dev, NULL,\n\t\t\t\t\t\t\t (dma_addr_t)rmem->base,\n\t\t\t\t\t\t\t rmem->size, rmem->base,\n\t\t\t\t\t\t\t zynqmp_r5_mem_region_map,\n\t\t\t\t\t\t\t zynqmp_r5_mem_region_unmap,\n\t\t\t\t\t\t\t it.node->name);\n\t\t}\n\n\t\tif (!rproc_mem) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, rproc_mem);\n\n\t\tdev_dbg(&rproc->dev, \"reserved mem carveout %s addr=%llx, size=0x%llx\",\n\t\t\tit.node->name, rmem->base, rmem->size);\n\t\ti++;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int tcm_mem_unmap(struct rproc *rproc, struct rproc_mem_entry *mem)\n{\n\tiounmap((void __iomem *)mem->va);\n\n\treturn 0;\n}\n\n \nstatic int tcm_mem_map(struct rproc *rproc,\n\t\t       struct rproc_mem_entry *mem)\n{\n\tvoid __iomem *va;\n\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (IS_ERR_OR_NULL(va))\n\t\treturn -ENOMEM;\n\n\t \n\tmem->va = (void *)va;\n\n\t \n\tmemset_io(va, 0, mem->len);\n\n\t \n\tmem->da &= 0x000fffff;\n\n\t \n\tif (mem->da == 0x90000 || mem->da == 0xB0000)\n\t\tmem->da -= 0x90000;\n\n\t \n\tif (mem->da != 0x0 && mem->da != 0x20000) {\n\t\tdev_err(&rproc->dev, \"invalid TCM address: %x\\n\", mem->da);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\n \nstatic int add_tcm_carveout_split_mode(struct rproc *rproc)\n{\n\tstruct rproc_mem_entry *rproc_mem;\n\tstruct zynqmp_r5_core *r5_core;\n\tint i, num_banks, ret;\n\tphys_addr_t bank_addr;\n\tstruct device *dev;\n\tu32 pm_domain_id;\n\tsize_t bank_size;\n\tchar *bank_name;\n\n\tr5_core = rproc->priv;\n\tdev = r5_core->dev;\n\tnum_banks = r5_core->tcm_bank_count;\n\n\t \n\tfor (i = 0; i < num_banks; i++) {\n\t\tbank_addr = r5_core->tcm_banks[i]->addr;\n\t\tbank_name = r5_core->tcm_banks[i]->bank_name;\n\t\tbank_size = r5_core->tcm_banks[i]->size;\n\t\tpm_domain_id = r5_core->tcm_banks[i]->pm_domain_id;\n\n\t\tret = zynqmp_pm_request_node(pm_domain_id,\n\t\t\t\t\t     ZYNQMP_PM_CAPABILITY_ACCESS, 0,\n\t\t\t\t\t     ZYNQMP_PM_REQUEST_ACK_BLOCKING);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to turn on TCM 0x%x\", pm_domain_id);\n\t\t\tgoto release_tcm_split;\n\t\t}\n\n\t\tdev_dbg(dev, \"TCM carveout split mode %s addr=%llx, size=0x%lx\",\n\t\t\tbank_name, bank_addr, bank_size);\n\n\t\trproc_mem = rproc_mem_entry_init(dev, NULL, bank_addr,\n\t\t\t\t\t\t bank_size, bank_addr,\n\t\t\t\t\t\t tcm_mem_map, tcm_mem_unmap,\n\t\t\t\t\t\t bank_name);\n\t\tif (!rproc_mem) {\n\t\t\tret = -ENOMEM;\n\t\t\tzynqmp_pm_release_node(pm_domain_id);\n\t\t\tgoto release_tcm_split;\n\t\t}\n\n\t\trproc_add_carveout(rproc, rproc_mem);\n\t}\n\n\treturn 0;\n\nrelease_tcm_split:\n\t \n\tfor (i--; i >= 0; i--) {\n\t\tpm_domain_id = r5_core->tcm_banks[i]->pm_domain_id;\n\t\tzynqmp_pm_release_node(pm_domain_id);\n\t}\n\treturn ret;\n}\n\n \nstatic int add_tcm_carveout_lockstep_mode(struct rproc *rproc)\n{\n\tstruct rproc_mem_entry *rproc_mem;\n\tstruct zynqmp_r5_core *r5_core;\n\tint i, num_banks, ret;\n\tphys_addr_t bank_addr;\n\tsize_t bank_size = 0;\n\tstruct device *dev;\n\tu32 pm_domain_id;\n\tchar *bank_name;\n\n\tr5_core = rproc->priv;\n\tdev = r5_core->dev;\n\n\t \n\tnum_banks = r5_core->tcm_bank_count;\n\n\t \n\tbank_addr = r5_core->tcm_banks[0]->addr;\n\tbank_name = r5_core->tcm_banks[0]->bank_name;\n\n\tfor (i = 0; i < num_banks; i++) {\n\t\tbank_size += r5_core->tcm_banks[i]->size;\n\t\tpm_domain_id = r5_core->tcm_banks[i]->pm_domain_id;\n\n\t\t \n\t\tret = zynqmp_pm_request_node(pm_domain_id,\n\t\t\t\t\t     ZYNQMP_PM_CAPABILITY_ACCESS, 0,\n\t\t\t\t\t     ZYNQMP_PM_REQUEST_ACK_BLOCKING);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to turn on TCM 0x%x\", pm_domain_id);\n\t\t\tgoto release_tcm_lockstep;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"TCM add carveout lockstep mode %s addr=0x%llx, size=0x%lx\",\n\t\tbank_name, bank_addr, bank_size);\n\n\t \n\trproc_mem = rproc_mem_entry_init(dev, NULL, bank_addr,\n\t\t\t\t\t bank_size, bank_addr,\n\t\t\t\t\t tcm_mem_map, tcm_mem_unmap,\n\t\t\t\t\t bank_name);\n\tif (!rproc_mem) {\n\t\tret = -ENOMEM;\n\t\tgoto release_tcm_lockstep;\n\t}\n\n\t \n\trproc_add_carveout(rproc, rproc_mem);\n\n\treturn 0;\n\nrelease_tcm_lockstep:\n\t \n\tfor (i--; i >= 0; i--) {\n\t\tpm_domain_id = r5_core->tcm_banks[i]->pm_domain_id;\n\t\tzynqmp_pm_release_node(pm_domain_id);\n\t}\n\treturn ret;\n}\n\n \nstatic int add_tcm_banks(struct rproc *rproc)\n{\n\tstruct zynqmp_r5_cluster *cluster;\n\tstruct zynqmp_r5_core *r5_core;\n\tstruct device *dev;\n\n\tr5_core = rproc->priv;\n\tif (!r5_core)\n\t\treturn -EINVAL;\n\n\tdev = r5_core->dev;\n\n\tcluster = dev_get_drvdata(dev->parent);\n\tif (!cluster) {\n\t\tdev_err(dev->parent, \"Invalid driver data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (cluster->mode == SPLIT_MODE)\n\t\treturn add_tcm_carveout_split_mode(rproc);\n\telse if (cluster->mode == LOCKSTEP_MODE)\n\t\treturn add_tcm_carveout_lockstep_mode(rproc);\n\n\treturn -EINVAL;\n}\n\n \nstatic int zynqmp_r5_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tint ret;\n\n\tret = rproc_elf_load_rsc_table(rproc, fw);\n\tif (ret == -EINVAL) {\n\t\t \n\t\tdev_info(&rproc->dev, \"no resource table found.\\n\");\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\n \nstatic int zynqmp_r5_rproc_prepare(struct rproc *rproc)\n{\n\tint ret;\n\n\tret = add_tcm_banks(rproc);\n\tif (ret) {\n\t\tdev_err(&rproc->dev, \"failed to get TCM banks, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = add_mem_regions_carveout(rproc);\n\tif (ret) {\n\t\tdev_err(&rproc->dev, \"failed to get reserve mem regions %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_r5_rproc_unprepare(struct rproc *rproc)\n{\n\tstruct zynqmp_r5_core *r5_core;\n\tu32 pm_domain_id;\n\tint i;\n\n\tr5_core = rproc->priv;\n\n\tfor (i = 0; i < r5_core->tcm_bank_count; i++) {\n\t\tpm_domain_id = r5_core->tcm_banks[i]->pm_domain_id;\n\t\tif (zynqmp_pm_release_node(pm_domain_id))\n\t\t\tdev_warn(r5_core->dev,\n\t\t\t\t \"can't turn off TCM bank 0x%x\", pm_domain_id);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct rproc_ops zynqmp_r5_rproc_ops = {\n\t.prepare\t= zynqmp_r5_rproc_prepare,\n\t.unprepare\t= zynqmp_r5_rproc_unprepare,\n\t.start\t\t= zynqmp_r5_rproc_start,\n\t.stop\t\t= zynqmp_r5_rproc_stop,\n\t.load\t\t= rproc_elf_load_segments,\n\t.parse_fw\t= zynqmp_r5_parse_fw,\n\t.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,\n\t.sanity_check\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n\t.kick\t\t= zynqmp_r5_rproc_kick,\n};\n\n \nstatic struct zynqmp_r5_core *zynqmp_r5_add_rproc_core(struct device *cdev)\n{\n\tstruct zynqmp_r5_core *r5_core;\n\tstruct rproc *r5_rproc;\n\tint ret;\n\n\t \n\tret = dma_set_coherent_mask(cdev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\t \n\tr5_rproc = rproc_alloc(cdev, dev_name(cdev),\n\t\t\t       &zynqmp_r5_rproc_ops,\n\t\t\t       NULL, sizeof(struct zynqmp_r5_core));\n\tif (!r5_rproc) {\n\t\tdev_err(cdev, \"failed to allocate memory for rproc instance\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tr5_rproc->auto_boot = false;\n\tr5_core = r5_rproc->priv;\n\tr5_core->dev = cdev;\n\tr5_core->np = dev_of_node(cdev);\n\tif (!r5_core->np) {\n\t\tdev_err(cdev, \"can't get device node for r5 core\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_rproc;\n\t}\n\n\t \n\tret = rproc_add(r5_rproc);\n\tif (ret) {\n\t\tdev_err(cdev, \"failed to add r5 remoteproc\\n\");\n\t\tgoto free_rproc;\n\t}\n\n\tr5_core->rproc = r5_rproc;\n\treturn r5_core;\n\nfree_rproc:\n\trproc_free(r5_rproc);\n\treturn ERR_PTR(ret);\n}\n\n \nstatic int zynqmp_r5_get_tcm_node(struct zynqmp_r5_cluster *cluster)\n{\n\tstruct device *dev = cluster->dev;\n\tstruct zynqmp_r5_core *r5_core;\n\tint tcm_bank_count, tcm_node;\n\tint i, j;\n\n\ttcm_bank_count = ARRAY_SIZE(zynqmp_tcm_banks);\n\n\t \n\ttcm_bank_count = tcm_bank_count / cluster->core_count;\n\n\t \n\ttcm_node = 0;\n\tfor (i = 0; i < cluster->core_count; i++) {\n\t\tr5_core = cluster->r5_cores[i];\n\t\tr5_core->tcm_banks = devm_kcalloc(dev, tcm_bank_count,\n\t\t\t\t\t\t  sizeof(struct mem_bank_data *),\n\t\t\t\t\t\t  GFP_KERNEL);\n\t\tif (!r5_core->tcm_banks)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (j = 0; j < tcm_bank_count; j++) {\n\t\t\t \n\t\t\tr5_core->tcm_banks[j] =\n\t\t\t\t(struct mem_bank_data *)&zynqmp_tcm_banks[tcm_node];\n\t\t\ttcm_node++;\n\t\t}\n\n\t\tr5_core->tcm_bank_count = tcm_bank_count;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_r5_core_init(struct zynqmp_r5_cluster *cluster,\n\t\t\t       enum rpu_oper_mode fw_reg_val,\n\t\t\t       enum rpu_tcm_comb tcm_mode)\n{\n\tstruct device *dev = cluster->dev;\n\tstruct zynqmp_r5_core *r5_core;\n\tint ret, i;\n\n\tret = zynqmp_r5_get_tcm_node(cluster);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't get tcm node, err %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < cluster->core_count; i++) {\n\t\tr5_core = cluster->r5_cores[i];\n\n\t\t \n\t\tret = of_property_read_u32_index(r5_core->np, \"power-domains\",\n\t\t\t\t\t\t 1, &r5_core->pm_domain_id);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to get power-domains property\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = zynqmp_r5_set_mode(r5_core, fw_reg_val, tcm_mode);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set r5 cluster mode %d, err %d\\n\",\n\t\t\t\tcluster->mode, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic int zynqmp_r5_cluster_init(struct zynqmp_r5_cluster *cluster)\n{\n\tenum zynqmp_r5_cluster_mode cluster_mode = LOCKSTEP_MODE;\n\tstruct device *dev = cluster->dev;\n\tstruct device_node *dev_node = dev_of_node(dev);\n\tstruct platform_device *child_pdev;\n\tstruct zynqmp_r5_core **r5_cores;\n\tenum rpu_oper_mode fw_reg_val;\n\tstruct device **child_devs;\n\tstruct device_node *child;\n\tenum rpu_tcm_comb tcm_mode;\n\tint core_count, ret, i;\n\tstruct mbox_info *ipi;\n\n\tret = of_property_read_u32(dev_node, \"xlnx,cluster-mode\", &cluster_mode);\n\n\t \n\tif (ret != -EINVAL && ret != 0) {\n\t\tdev_err(dev, \"Invalid xlnx,cluster-mode property\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (cluster_mode == LOCKSTEP_MODE) {\n\t\ttcm_mode = PM_RPU_TCM_COMB;\n\t\tfw_reg_val = PM_RPU_MODE_LOCKSTEP;\n\t} else if (cluster_mode == SPLIT_MODE) {\n\t\ttcm_mode = PM_RPU_TCM_SPLIT;\n\t\tfw_reg_val = PM_RPU_MODE_SPLIT;\n\t} else {\n\t\tdev_err(dev, \"driver does not support cluster mode %d\\n\", cluster_mode);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcore_count = of_get_available_child_count(dev_node);\n\tif (core_count == 0) {\n\t\tdev_err(dev, \"Invalid number of r5 cores %d\", core_count);\n\t\treturn -EINVAL;\n\t} else if (cluster_mode == SPLIT_MODE && core_count != 2) {\n\t\tdev_err(dev, \"Invalid number of r5 cores for split mode\\n\");\n\t\treturn -EINVAL;\n\t} else if (cluster_mode == LOCKSTEP_MODE && core_count == 2) {\n\t\tdev_warn(dev, \"Only r5 core0 will be used\\n\");\n\t\tcore_count = 1;\n\t}\n\n\tchild_devs = kcalloc(core_count, sizeof(struct device *), GFP_KERNEL);\n\tif (!child_devs)\n\t\treturn -ENOMEM;\n\n\tr5_cores = kcalloc(core_count,\n\t\t\t   sizeof(struct zynqmp_r5_core *), GFP_KERNEL);\n\tif (!r5_cores) {\n\t\tkfree(child_devs);\n\t\treturn -ENOMEM;\n\t}\n\n\ti = 0;\n\tfor_each_available_child_of_node(dev_node, child) {\n\t\tchild_pdev = of_find_device_by_node(child);\n\t\tif (!child_pdev) {\n\t\t\tof_node_put(child);\n\t\t\tret = -ENODEV;\n\t\t\tgoto release_r5_cores;\n\t\t}\n\n\t\tchild_devs[i] = &child_pdev->dev;\n\n\t\t \n\t\tr5_cores[i] = zynqmp_r5_add_rproc_core(&child_pdev->dev);\n\t\tif (IS_ERR(r5_cores[i])) {\n\t\t\tof_node_put(child);\n\t\t\tret = PTR_ERR(r5_cores[i]);\n\t\t\tr5_cores[i] = NULL;\n\t\t\tgoto release_r5_cores;\n\t\t}\n\n\t\t \n\t\tipi = zynqmp_r5_setup_mbox(&child_pdev->dev);\n\t\tif (ipi) {\n\t\t\tr5_cores[i]->ipi = ipi;\n\t\t\tipi->r5_core = r5_cores[i];\n\t\t}\n\n\t\t \n\t\tif (cluster_mode == LOCKSTEP_MODE) {\n\t\t\tof_node_put(child);\n\t\t\tbreak;\n\t\t}\n\n\t\ti++;\n\t}\n\n\tcluster->mode = cluster_mode;\n\tcluster->core_count = core_count;\n\tcluster->r5_cores = r5_cores;\n\n\tret = zynqmp_r5_core_init(cluster, fw_reg_val, tcm_mode);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to init r5 core err %d\\n\", ret);\n\t\tcluster->core_count = 0;\n\t\tcluster->r5_cores = NULL;\n\n\t\t \n\t\ti = core_count - 1;\n\t\tgoto release_r5_cores;\n\t}\n\n\tkfree(child_devs);\n\treturn 0;\n\nrelease_r5_cores:\n\twhile (i >= 0) {\n\t\tput_device(child_devs[i]);\n\t\tif (r5_cores[i]) {\n\t\t\tzynqmp_r5_free_mbox(r5_cores[i]->ipi);\n\t\t\tof_reserved_mem_device_release(r5_cores[i]->dev);\n\t\t\trproc_del(r5_cores[i]->rproc);\n\t\t\trproc_free(r5_cores[i]->rproc);\n\t\t}\n\t\ti--;\n\t}\n\tkfree(r5_cores);\n\tkfree(child_devs);\n\treturn ret;\n}\n\nstatic void zynqmp_r5_cluster_exit(void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct zynqmp_r5_cluster *cluster;\n\tstruct zynqmp_r5_core *r5_core;\n\tint i;\n\n\tcluster = platform_get_drvdata(pdev);\n\tif (!cluster)\n\t\treturn;\n\n\tfor (i = 0; i < cluster->core_count; i++) {\n\t\tr5_core = cluster->r5_cores[i];\n\t\tzynqmp_r5_free_mbox(r5_core->ipi);\n\t\tof_reserved_mem_device_release(r5_core->dev);\n\t\tput_device(r5_core->dev);\n\t\trproc_del(r5_core->rproc);\n\t\trproc_free(r5_core->rproc);\n\t}\n\n\tkfree(cluster->r5_cores);\n\tkfree(cluster);\n\tplatform_set_drvdata(pdev, NULL);\n}\n\n \nstatic int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)\n{\n\tstruct zynqmp_r5_cluster *cluster;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tcluster = kzalloc(sizeof(*cluster), GFP_KERNEL);\n\tif (!cluster)\n\t\treturn -ENOMEM;\n\n\tcluster->dev = dev;\n\n\tret = devm_of_platform_populate(dev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to populate platform dev\\n\");\n\t\tkfree(cluster);\n\t\treturn ret;\n\t}\n\n\t \n\tplatform_set_drvdata(pdev, cluster);\n\n\tret = zynqmp_r5_cluster_init(cluster);\n\tif (ret) {\n\t\tkfree(cluster);\n\t\tplatform_set_drvdata(pdev, NULL);\n\t\tdev_err_probe(dev, ret, \"Invalid r5f subsystem device tree\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, zynqmp_r5_cluster_exit, pdev);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\n \nstatic const struct of_device_id zynqmp_r5_remoteproc_match[] = {\n\t{ .compatible = \"xlnx,zynqmp-r5fss\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, zynqmp_r5_remoteproc_match);\n\nstatic struct platform_driver zynqmp_r5_remoteproc_driver = {\n\t.probe = zynqmp_r5_remoteproc_probe,\n\t.driver = {\n\t\t.name = \"zynqmp_r5_remoteproc\",\n\t\t.of_match_table = zynqmp_r5_remoteproc_match,\n\t},\n};\nmodule_platform_driver(zynqmp_r5_remoteproc_driver);\n\nMODULE_DESCRIPTION(\"Xilinx R5F remote processor driver\");\nMODULE_AUTHOR(\"Xilinx Inc.\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}