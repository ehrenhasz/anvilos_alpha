{
  "module_name": "qcom_q6v5.c",
  "hash_id": "0b68ef9229d21c9ef782ecb6664b2046a10fc71978e87cc622aad929e7a959bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_q6v5.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/interconnect.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/soc/qcom/qcom_aoss.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n#include <linux/remoteproc.h>\n#include \"qcom_common.h\"\n#include \"qcom_q6v5.h\"\n\n#define Q6V5_LOAD_STATE_MSG_LEN\t64\n#define Q6V5_PANIC_DELAY_MS\t200\n\nstatic int q6v5_load_state_toggle(struct qcom_q6v5 *q6v5, bool enable)\n{\n\tint ret;\n\n\tif (!q6v5->qmp)\n\t\treturn 0;\n\n\tret = qmp_send(q6v5->qmp, \"{class: image, res: load_state, name: %s, val: %s}\",\n\t\t       q6v5->load_state, enable ? \"on\" : \"off\");\n\tif (ret)\n\t\tdev_err(q6v5->dev, \"failed to toggle load state\\n\");\n\n\treturn ret;\n}\n\n \nint qcom_q6v5_prepare(struct qcom_q6v5 *q6v5)\n{\n\tint ret;\n\n\tret = icc_set_bw(q6v5->path, 0, UINT_MAX);\n\tif (ret < 0) {\n\t\tdev_err(q6v5->dev, \"failed to set bandwidth request\\n\");\n\t\treturn ret;\n\t}\n\n\tret = q6v5_load_state_toggle(q6v5, true);\n\tif (ret) {\n\t\ticc_set_bw(q6v5->path, 0, 0);\n\t\treturn ret;\n\t}\n\n\treinit_completion(&q6v5->start_done);\n\treinit_completion(&q6v5->stop_done);\n\n\tq6v5->running = true;\n\tq6v5->handover_issued = false;\n\n\tenable_irq(q6v5->handover_irq);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_prepare);\n\n \nint qcom_q6v5_unprepare(struct qcom_q6v5 *q6v5)\n{\n\tdisable_irq(q6v5->handover_irq);\n\tq6v5_load_state_toggle(q6v5, false);\n\n\t \n\ticc_set_bw(q6v5->path, 0, 0);\n\n\treturn !q6v5->handover_issued;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_unprepare);\n\nstatic irqreturn_t q6v5_wdog_interrupt(int irq, void *data)\n{\n\tstruct qcom_q6v5 *q6v5 = data;\n\tsize_t len;\n\tchar *msg;\n\n\t \n\tif (!q6v5->running) {\n\t\tcomplete(&q6v5->stop_done);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, q6v5->crash_reason, &len);\n\tif (!IS_ERR(msg) && len > 0 && msg[0])\n\t\tdev_err(q6v5->dev, \"watchdog received: %s\\n\", msg);\n\telse\n\t\tdev_err(q6v5->dev, \"watchdog without message\\n\");\n\n\tq6v5->running = false;\n\trproc_report_crash(q6v5->rproc, RPROC_WATCHDOG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t q6v5_fatal_interrupt(int irq, void *data)\n{\n\tstruct qcom_q6v5 *q6v5 = data;\n\tsize_t len;\n\tchar *msg;\n\n\tif (!q6v5->running)\n\t\treturn IRQ_HANDLED;\n\n\tmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, q6v5->crash_reason, &len);\n\tif (!IS_ERR(msg) && len > 0 && msg[0])\n\t\tdev_err(q6v5->dev, \"fatal error received: %s\\n\", msg);\n\telse\n\t\tdev_err(q6v5->dev, \"fatal error without message\\n\");\n\n\tq6v5->running = false;\n\trproc_report_crash(q6v5->rproc, RPROC_FATAL_ERROR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t q6v5_ready_interrupt(int irq, void *data)\n{\n\tstruct qcom_q6v5 *q6v5 = data;\n\n\tcomplete(&q6v5->start_done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint qcom_q6v5_wait_for_start(struct qcom_q6v5 *q6v5, int timeout)\n{\n\tint ret;\n\n\tret = wait_for_completion_timeout(&q6v5->start_done, timeout);\n\tif (!ret)\n\t\tdisable_irq(q6v5->handover_irq);\n\n\treturn !ret ? -ETIMEDOUT : 0;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_wait_for_start);\n\nstatic irqreturn_t q6v5_handover_interrupt(int irq, void *data)\n{\n\tstruct qcom_q6v5 *q6v5 = data;\n\n\tif (q6v5->handover)\n\t\tq6v5->handover(q6v5);\n\n\ticc_set_bw(q6v5->path, 0, 0);\n\n\tq6v5->handover_issued = true;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t q6v5_stop_interrupt(int irq, void *data)\n{\n\tstruct qcom_q6v5 *q6v5 = data;\n\n\tcomplete(&q6v5->stop_done);\n\n\treturn IRQ_HANDLED;\n}\n\n \nint qcom_q6v5_request_stop(struct qcom_q6v5 *q6v5, struct qcom_sysmon *sysmon)\n{\n\tint ret;\n\n\tq6v5->running = false;\n\n\t \n\tif (q6v5->rproc->state != RPROC_RUNNING || qcom_sysmon_shutdown_acked(sysmon))\n\t\treturn 0;\n\n\tqcom_smem_state_update_bits(q6v5->state,\n\t\t\t\t    BIT(q6v5->stop_bit), BIT(q6v5->stop_bit));\n\n\tret = wait_for_completion_timeout(&q6v5->stop_done, 5 * HZ);\n\n\tqcom_smem_state_update_bits(q6v5->state, BIT(q6v5->stop_bit), 0);\n\n\treturn ret == 0 ? -ETIMEDOUT : 0;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_request_stop);\n\n \nunsigned long qcom_q6v5_panic(struct qcom_q6v5 *q6v5)\n{\n\tqcom_smem_state_update_bits(q6v5->state,\n\t\t\t\t    BIT(q6v5->stop_bit), BIT(q6v5->stop_bit));\n\n\treturn Q6V5_PANIC_DELAY_MS;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_panic);\n\n \nint qcom_q6v5_init(struct qcom_q6v5 *q6v5, struct platform_device *pdev,\n\t\t   struct rproc *rproc, int crash_reason, const char *load_state,\n\t\t   void (*handover)(struct qcom_q6v5 *q6v5))\n{\n\tint ret;\n\n\tq6v5->rproc = rproc;\n\tq6v5->dev = &pdev->dev;\n\tq6v5->crash_reason = crash_reason;\n\tq6v5->handover = handover;\n\n\tinit_completion(&q6v5->start_done);\n\tinit_completion(&q6v5->stop_done);\n\n\tq6v5->wdog_irq = platform_get_irq_byname(pdev, \"wdog\");\n\tif (q6v5->wdog_irq < 0)\n\t\treturn q6v5->wdog_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, q6v5->wdog_irq,\n\t\t\t\t\tNULL, q6v5_wdog_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"q6v5 wdog\", q6v5);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to acquire wdog IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tq6v5->fatal_irq = platform_get_irq_byname(pdev, \"fatal\");\n\tif (q6v5->fatal_irq < 0)\n\t\treturn q6v5->fatal_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, q6v5->fatal_irq,\n\t\t\t\t\tNULL, q6v5_fatal_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"q6v5 fatal\", q6v5);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to acquire fatal IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tq6v5->ready_irq = platform_get_irq_byname(pdev, \"ready\");\n\tif (q6v5->ready_irq < 0)\n\t\treturn q6v5->ready_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, q6v5->ready_irq,\n\t\t\t\t\tNULL, q6v5_ready_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"q6v5 ready\", q6v5);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to acquire ready IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tq6v5->handover_irq = platform_get_irq_byname(pdev, \"handover\");\n\tif (q6v5->handover_irq < 0)\n\t\treturn q6v5->handover_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, q6v5->handover_irq,\n\t\t\t\t\tNULL, q6v5_handover_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"q6v5 handover\", q6v5);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to acquire handover IRQ\\n\");\n\t\treturn ret;\n\t}\n\tdisable_irq(q6v5->handover_irq);\n\n\tq6v5->stop_irq = platform_get_irq_byname(pdev, \"stop-ack\");\n\tif (q6v5->stop_irq < 0)\n\t\treturn q6v5->stop_irq;\n\n\tret = devm_request_threaded_irq(&pdev->dev, q6v5->stop_irq,\n\t\t\t\t\tNULL, q6v5_stop_interrupt,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"q6v5 stop\", q6v5);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"failed to acquire stop-ack IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tq6v5->state = devm_qcom_smem_state_get(&pdev->dev, \"stop\", &q6v5->stop_bit);\n\tif (IS_ERR(q6v5->state)) {\n\t\tdev_err(&pdev->dev, \"failed to acquire stop state\\n\");\n\t\treturn PTR_ERR(q6v5->state);\n\t}\n\n\tq6v5->load_state = devm_kstrdup_const(&pdev->dev, load_state, GFP_KERNEL);\n\tq6v5->qmp = qmp_get(&pdev->dev);\n\tif (IS_ERR(q6v5->qmp)) {\n\t\tif (PTR_ERR(q6v5->qmp) != -ENODEV)\n\t\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(q6v5->qmp),\n\t\t\t\t\t     \"failed to acquire load state\\n\");\n\t\tq6v5->qmp = NULL;\n\t} else if (!q6v5->load_state) {\n\t\tif (!load_state)\n\t\t\tdev_err(&pdev->dev, \"load state resource string empty\\n\");\n\n\t\tqmp_put(q6v5->qmp);\n\t\treturn load_state ? -ENOMEM : -EINVAL;\n\t}\n\n\tq6v5->path = devm_of_icc_get(&pdev->dev, NULL);\n\tif (IS_ERR(q6v5->path))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(q6v5->path),\n\t\t\t\t     \"failed to acquire interconnect path\\n\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_init);\n\n \nvoid qcom_q6v5_deinit(struct qcom_q6v5 *q6v5)\n{\n\tqmp_put(q6v5->qmp);\n}\nEXPORT_SYMBOL_GPL(qcom_q6v5_deinit);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Qualcomm Peripheral Image Loader for Q6V5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}