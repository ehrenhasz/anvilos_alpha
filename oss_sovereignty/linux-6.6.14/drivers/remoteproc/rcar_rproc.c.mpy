{
  "module_name": "rcar_rproc.c",
  "hash_id": "2770938daa12ad9adab4fdbafcce452e6fccad3d93e2e636dd5ff21ab30c4155",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/rcar_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/limits.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/soc/renesas/rcar-rst.h>\n\n#include \"remoteproc_internal.h\"\n\nstruct rcar_rproc {\n\tstruct reset_control *rst;\n};\n\nstatic int rcar_rproc_mem_alloc(struct rproc *rproc,\n\t\t\t\t struct rproc_mem_entry *mem)\n{\n\tstruct device *dev = &rproc->dev;\n\tvoid *va;\n\n\tdev_dbg(dev, \"map memory: %pa+%zx\\n\", &mem->dma, mem->len);\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (!va) {\n\t\tdev_err(dev, \"Unable to map memory region: %pa+%zx\\n\",\n\t\t\t&mem->dma, mem->len);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmem->va = va;\n\n\treturn 0;\n}\n\nstatic int rcar_rproc_mem_release(struct rproc *rproc,\n\t\t\t\t   struct rproc_mem_entry *mem)\n{\n\tdev_dbg(&rproc->dev, \"unmap memory: %pa\\n\", &mem->dma);\n\tiounmap(mem->va);\n\n\treturn 0;\n}\n\nstatic int rcar_rproc_prepare(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_iterator it;\n\tstruct rproc_mem_entry *mem;\n\tstruct reserved_mem *rmem;\n\tu32 da;\n\n\t \n\tof_phandle_iterator_init(&it, np, \"memory-region\", NULL, 0);\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(&rproc->dev,\n\t\t\t\t\"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (rmem->base > U32_MAX) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tda = rmem->base;\n\t\tmem = rproc_mem_entry_init(dev, NULL,\n\t\t\t\t\t   rmem->base,\n\t\t\t\t\t   rmem->size, da,\n\t\t\t\t\t   rcar_rproc_mem_alloc,\n\t\t\t\t\t   rcar_rproc_mem_release,\n\t\t\t\t\t   it.node->name);\n\n\t\tif (!mem) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t}\n\n\treturn 0;\n}\n\nstatic int rcar_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tint ret;\n\n\tret = rproc_elf_load_rsc_table(rproc, fw);\n\tif (ret)\n\t\tdev_info(&rproc->dev, \"No resource table in elf\\n\");\n\n\treturn 0;\n}\n\nstatic int rcar_rproc_start(struct rproc *rproc)\n{\n\tstruct rcar_rproc *priv = rproc->priv;\n\tint err;\n\n\tif (!rproc->bootaddr)\n\t\treturn -EINVAL;\n\n\terr = rcar_rst_set_rproc_boot_addr(rproc->bootaddr);\n\tif (err) {\n\t\tdev_err(&rproc->dev, \"failed to set rproc boot addr\\n\");\n\t\treturn err;\n\t}\n\n\terr = reset_control_deassert(priv->rst);\n\tif (err)\n\t\tdev_err(&rproc->dev, \"failed to deassert reset\\n\");\n\n\treturn err;\n}\n\nstatic int rcar_rproc_stop(struct rproc *rproc)\n{\n\tstruct rcar_rproc *priv = rproc->priv;\n\tint err;\n\n\terr = reset_control_assert(priv->rst);\n\tif (err)\n\t\tdev_err(&rproc->dev, \"failed to assert reset\\n\");\n\n\treturn err;\n}\n\nstatic struct rproc_ops rcar_rproc_ops = {\n\t.prepare\t= rcar_rproc_prepare,\n\t.start\t\t= rcar_rproc_start,\n\t.stop\t\t= rcar_rproc_stop,\n\t.load\t\t= rproc_elf_load_segments,\n\t.parse_fw\t= rcar_rproc_parse_fw,\n\t.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,\n\t.sanity_check\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n\n};\n\nstatic int rcar_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct rcar_rproc *priv;\n\tstruct rproc *rproc;\n\tint ret;\n\n\trproc = devm_rproc_alloc(dev, np->name, &rcar_rproc_ops,\n\t\t\t\tNULL, sizeof(*priv));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\tpriv = rproc->priv;\n\n\tpriv->rst = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(priv->rst)) {\n\t\tret = PTR_ERR(priv->rst);\n\t\tdev_err_probe(dev, ret, \"fail to acquire rproc reset\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to power up\\n\");\n\t\treturn ret;\n\t}\n\n\tdev_set_drvdata(dev, rproc);\n\n\t \n\trproc->auto_boot = false;\n\n\tret = devm_rproc_add(dev, rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed\\n\");\n\t\tgoto pm_disable;\n\t}\n\n\treturn 0;\n\npm_disable:\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void rcar_rproc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tpm_runtime_disable(dev);\n}\n\nstatic const struct of_device_id rcar_rproc_of_match[] = {\n\t{ .compatible = \"renesas,rcar-cr7\" },\n\t{},\n};\n\nMODULE_DEVICE_TABLE(of, rcar_rproc_of_match);\n\nstatic struct platform_driver rcar_rproc_driver = {\n\t.probe = rcar_rproc_probe,\n\t.remove_new = rcar_rproc_remove,\n\t.driver = {\n\t\t.name = \"rcar-rproc\",\n\t\t.of_match_table = rcar_rproc_of_match,\n\t},\n};\n\nmodule_platform_driver(rcar_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Renesas R-Car Gen3 remote processor control driver\");\nMODULE_AUTHOR(\"Julien Massot <julien.massot@iot.bzh>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}