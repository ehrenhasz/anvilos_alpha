{
  "module_name": "da8xx_remoteproc.c",
  "hash_id": "ad63a3c4f8b6050cbe39db57fa3c89e636bc11566c6a94e9fc6083a1fab99bdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/da8xx_remoteproc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n\n#include \"remoteproc_internal.h\"\n\nstatic char *da8xx_fw_name;\nmodule_param(da8xx_fw_name, charp, 0444);\nMODULE_PARM_DESC(da8xx_fw_name,\n\t\t \"Name of DSP firmware file in /lib/firmware (if not specified defaults to 'rproc-dsp-fw')\");\n\n \n#define SYSCFG_CHIPSIG0 BIT(0)\n#define SYSCFG_CHIPSIG1 BIT(1)\n#define SYSCFG_CHIPSIG2 BIT(2)\n#define SYSCFG_CHIPSIG3 BIT(3)\n#define SYSCFG_CHIPSIG4 BIT(4)\n\n#define DA8XX_RPROC_LOCAL_ADDRESS_MASK\t(SZ_16M - 1)\n\n \nstruct da8xx_rproc_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\n \nstruct da8xx_rproc {\n\tstruct rproc *rproc;\n\tstruct da8xx_rproc_mem *mem;\n\tint num_mems;\n\tstruct clk *dsp_clk;\n\tstruct reset_control *dsp_reset;\n\tvoid (*ack_fxn)(struct irq_data *data);\n\tstruct irq_data *irq_data;\n\tvoid __iomem *chipsig;\n\tvoid __iomem *bootreg;\n\tint irq;\n};\n\n \nstatic irqreturn_t handle_event(int irq, void *p)\n{\n\tstruct rproc *rproc = p;\n\n\t \n\trproc_vq_interrupt(rproc, 0);\n\trproc_vq_interrupt(rproc, 1);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t da8xx_rproc_callback(int irq, void *p)\n{\n\tstruct rproc *rproc = p;\n\tstruct da8xx_rproc *drproc = rproc->priv;\n\tu32 chipsig;\n\n\tchipsig = readl(drproc->chipsig);\n\tif (chipsig & SYSCFG_CHIPSIG0) {\n\t\t \n\t\twritel(SYSCFG_CHIPSIG0, drproc->chipsig + 4);\n\n\t\t \n\t\tdrproc->ack_fxn(drproc->irq_data);\n\n\t\treturn IRQ_WAKE_THREAD;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int da8xx_rproc_start(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct da8xx_rproc *drproc = rproc->priv;\n\tstruct clk *dsp_clk = drproc->dsp_clk;\n\tstruct reset_control *dsp_reset = drproc->dsp_reset;\n\tint ret;\n\n\t \n\tif (rproc->bootaddr & 0x3ff) {\n\t\tdev_err(dev, \"invalid boot address: must be aligned to 1KB\\n\");\n\n\t\treturn -EINVAL;\n\t}\n\n\twritel(rproc->bootaddr, drproc->bootreg);\n\n\tret = clk_prepare_enable(dsp_clk);\n\tif (ret) {\n\t\tdev_err(dev, \"clk_prepare_enable() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(dsp_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset_control_deassert() failed: %d\\n\", ret);\n\t\tclk_disable_unprepare(dsp_clk);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int da8xx_rproc_stop(struct rproc *rproc)\n{\n\tstruct da8xx_rproc *drproc = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\n\tret = reset_control_assert(drproc->dsp_reset);\n\tif (ret) {\n\t\tdev_err(dev, \"reset_control_assert() failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tclk_disable_unprepare(drproc->dsp_clk);\n\n\treturn 0;\n}\n\n \nstatic void da8xx_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct da8xx_rproc *drproc = rproc->priv;\n\n\t \n\twritel(SYSCFG_CHIPSIG2, drproc->chipsig);\n}\n\nstatic const struct rproc_ops da8xx_rproc_ops = {\n\t.start = da8xx_rproc_start,\n\t.stop = da8xx_rproc_stop,\n\t.kick = da8xx_rproc_kick,\n};\n\nstatic int da8xx_rproc_get_internal_memories(struct platform_device *pdev,\n\t\t\t\t\t     struct da8xx_rproc *drproc)\n{\n\tstatic const char * const mem_names[] = {\"l2sram\", \"l1pram\", \"l1dram\"};\n\tint num_mems = ARRAY_SIZE(mem_names);\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint i;\n\n\tdrproc->mem = devm_kcalloc(dev, num_mems, sizeof(*drproc->mem),\n\t\t\t\t   GFP_KERNEL);\n\tif (!drproc->mem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_mems; i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   mem_names[i]);\n\t\tdrproc->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(drproc->mem[i].cpu_addr)) {\n\t\t\tdev_err(dev, \"failed to parse and map %s memory\\n\",\n\t\t\t\tmem_names[i]);\n\t\t\treturn PTR_ERR(drproc->mem[i].cpu_addr);\n\t\t}\n\t\tdrproc->mem[i].bus_addr = res->start;\n\t\tdrproc->mem[i].dev_addr =\n\t\t\t\tres->start & DA8XX_RPROC_LOCAL_ADDRESS_MASK;\n\t\tdrproc->mem[i].size = resource_size(res);\n\n\t\tdev_dbg(dev, \"memory %8s: bus addr %pa size 0x%zx va %p da 0x%x\\n\",\n\t\t\tmem_names[i], &drproc->mem[i].bus_addr,\n\t\t\tdrproc->mem[i].size, drproc->mem[i].cpu_addr,\n\t\t\tdrproc->mem[i].dev_addr);\n\t}\n\tdrproc->num_mems = num_mems;\n\n\treturn 0;\n}\n\nstatic int da8xx_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct da8xx_rproc *drproc;\n\tstruct rproc *rproc;\n\tstruct irq_data *irq_data;\n\tstruct resource *bootreg_res;\n\tstruct resource *chipsig_res;\n\tstruct clk *dsp_clk;\n\tstruct reset_control *dsp_reset;\n\tvoid __iomem *chipsig;\n\tvoid __iomem *bootreg;\n\tint irq;\n\tint ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq_data = irq_get_irq_data(irq);\n\tif (!irq_data) {\n\t\tdev_err(dev, \"irq_get_irq_data(%d): NULL\\n\", irq);\n\t\treturn -EINVAL;\n\t}\n\n\tbootreg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"host1cfg\");\n\tbootreg = devm_ioremap_resource(dev, bootreg_res);\n\tif (IS_ERR(bootreg))\n\t\treturn PTR_ERR(bootreg);\n\n\tchipsig_res = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   \"chipsig\");\n\tchipsig = devm_ioremap_resource(dev, chipsig_res);\n\tif (IS_ERR(chipsig))\n\t\treturn PTR_ERR(chipsig);\n\n\tdsp_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(dsp_clk)) {\n\t\tdev_err(dev, \"clk_get error: %ld\\n\", PTR_ERR(dsp_clk));\n\n\t\treturn PTR_ERR(dsp_clk);\n\t}\n\n\tdsp_reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(dsp_reset)) {\n\t\tif (PTR_ERR(dsp_reset) != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"unable to get reset control: %ld\\n\",\n\t\t\t\tPTR_ERR(dsp_reset));\n\n\t\treturn PTR_ERR(dsp_reset);\n\t}\n\n\tif (dev->of_node) {\n\t\tret = of_reserved_mem_device_init(dev);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"device does not have specific CMA pool: %d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trproc = rproc_alloc(dev, \"dsp\", &da8xx_rproc_ops, da8xx_fw_name,\n\t\tsizeof(*drproc));\n\tif (!rproc) {\n\t\tret = -ENOMEM;\n\t\tgoto free_mem;\n\t}\n\n\t \n\trproc->recovery_disabled = true;\n\n\tdrproc = rproc->priv;\n\tdrproc->rproc = rproc;\n\tdrproc->dsp_clk = dsp_clk;\n\tdrproc->dsp_reset = dsp_reset;\n\trproc->has_iommu = false;\n\n\tret = da8xx_rproc_get_internal_memories(pdev, drproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\t \n\tret = devm_request_threaded_irq(dev, irq, da8xx_rproc_callback,\n\t\t\t\t\thandle_event, 0, \"da8xx-remoteproc\",\n\t\t\t\t\trproc);\n\tif (ret) {\n\t\tdev_err(dev, \"devm_request_threaded_irq error: %d\\n\", ret);\n\t\tgoto free_rproc;\n\t}\n\n\t \n\tret = reset_control_assert(dsp_reset);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tdrproc->chipsig = chipsig;\n\tdrproc->bootreg = bootreg;\n\tdrproc->ack_fxn = irq_data->chip->irq_ack;\n\tdrproc->irq_data = irq_data;\n\tdrproc->irq = irq;\n\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed: %d\\n\", ret);\n\t\tgoto free_rproc;\n\t}\n\n\treturn 0;\n\nfree_rproc:\n\trproc_free(rproc);\nfree_mem:\n\tif (dev->of_node)\n\t\tof_reserved_mem_device_release(dev);\n\treturn ret;\n}\n\nstatic void da8xx_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct da8xx_rproc *drproc = rproc->priv;\n\tstruct device *dev = &pdev->dev;\n\n\t \n\tdisable_irq(drproc->irq);\n\n\trproc_del(rproc);\n\trproc_free(rproc);\n\tif (dev->of_node)\n\t\tof_reserved_mem_device_release(dev);\n}\n\nstatic const struct of_device_id davinci_rproc_of_match[] __maybe_unused = {\n\t{ .compatible = \"ti,da850-dsp\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, davinci_rproc_of_match);\n\nstatic struct platform_driver da8xx_rproc_driver = {\n\t.probe = da8xx_rproc_probe,\n\t.remove_new = da8xx_rproc_remove,\n\t.driver = {\n\t\t.name = \"davinci-rproc\",\n\t\t.of_match_table = of_match_ptr(davinci_rproc_of_match),\n\t},\n};\n\nmodule_platform_driver(da8xx_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DA8XX Remote Processor control driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}