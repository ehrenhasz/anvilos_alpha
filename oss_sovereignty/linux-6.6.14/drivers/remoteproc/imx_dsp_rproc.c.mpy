{
  "module_name": "imx_dsp_rproc.c",
  "hash_id": "3a62e328746e0fe72fdf11b190a1a806e385a0f3ce9677416aa8e8f0109797c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/imx_dsp_rproc.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/firmware.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/slab.h>\n\n#include \"imx_rproc.h\"\n#include \"remoteproc_elf_helpers.h\"\n#include \"remoteproc_internal.h\"\n\n#define DSP_RPROC_CLK_MAX\t\t\t5\n\n \nstatic unsigned int no_mailboxes;\nmodule_param_named(no_mailboxes, no_mailboxes, int, 0644);\nMODULE_PARM_DESC(no_mailboxes,\n\t\t \"There is no mailbox between cores, so ignore remote proc reply after start, default is 0 (off).\");\n\n#define REMOTE_IS_READY\t\t\t\tBIT(0)\n#define REMOTE_READY_WAIT_MAX_RETRIES\t\t500\n\n \n \n#define ATT_OWN\t\t\t\t\tBIT(31)\n \n#define ATT_IRAM\t\t\t\tBIT(30)\n\n \n \n#define IMX8M_DAP_DEBUG\t\t\t\t0x28800000\n#define IMX8M_DAP_DEBUG_SIZE\t\t\t(64 * 1024)\n#define IMX8M_DAP_PWRCTL\t\t\t(0x4000 + 0x3020)\n#define IMX8M_PWRCTL_CORERESET\t\t\tBIT(16)\n\n \n#define IMX8M_AudioDSP_REG0\t\t\t0x100\n#define IMX8M_AudioDSP_REG1\t\t\t0x104\n#define IMX8M_AudioDSP_REG2\t\t\t0x108\n#define IMX8M_AudioDSP_REG3\t\t\t0x10c\n\n#define IMX8M_AudioDSP_REG2_RUNSTALL\t\tBIT(5)\n#define IMX8M_AudioDSP_REG2_PWAITMODE\t\tBIT(1)\n\n \n#define IMX8ULP_SIM_LPAV_REG_SYSCTRL0\t\t0x8\n#define IMX8ULP_SYSCTRL0_DSP_DBG_RST\t\tBIT(25)\n#define IMX8ULP_SYSCTRL0_DSP_PLAT_CLK_EN\tBIT(19)\n#define IMX8ULP_SYSCTRL0_DSP_PBCLK_EN\t\tBIT(18)\n#define IMX8ULP_SYSCTRL0_DSP_CLK_EN\t\tBIT(17)\n#define IMX8ULP_SYSCTRL0_DSP_RST\t\tBIT(16)\n#define IMX8ULP_SYSCTRL0_DSP_OCD_HALT\t\tBIT(14)\n#define IMX8ULP_SYSCTRL0_DSP_STALL\t\tBIT(13)\n\n#define IMX8ULP_SIP_HIFI_XRDC\t\t\t0xc200000e\n\n \nenum imx_dsp_rp_mbox_messages {\n\tRP_MBOX_SUSPEND_SYSTEM\t\t\t= 0xFF11,\n\tRP_MBOX_SUSPEND_ACK\t\t\t= 0xFF12,\n\tRP_MBOX_RESUME_SYSTEM\t\t\t= 0xFF13,\n\tRP_MBOX_RESUME_ACK\t\t\t= 0xFF14,\n};\n\n \nstruct imx_dsp_rproc {\n\tstruct regmap\t\t\t\t*regmap;\n\tstruct rproc\t\t\t\t*rproc;\n\tconst struct imx_dsp_rproc_dcfg\t\t*dsp_dcfg;\n\tstruct clk_bulk_data\t\t\tclks[DSP_RPROC_CLK_MAX];\n\tstruct mbox_client\t\t\tcl;\n\tstruct mbox_client\t\t\tcl_rxdb;\n\tstruct mbox_chan\t\t\t*tx_ch;\n\tstruct mbox_chan\t\t\t*rx_ch;\n\tstruct mbox_chan\t\t\t*rxdb_ch;\n\tstruct device\t\t\t\t**pd_dev;\n\tstruct device_link\t\t\t**pd_dev_link;\n\tstruct imx_sc_ipc\t\t\t*ipc_handle;\n\tstruct work_struct\t\t\trproc_work;\n\tstruct completion\t\t\tpm_comp;\n\tint\t\t\t\t\tnum_domains;\n\tu32\t\t\t\t\tflags;\n};\n\n \nstruct imx_dsp_rproc_dcfg {\n\tconst struct imx_rproc_dcfg\t\t*dcfg;\n\tint (*reset)(struct imx_dsp_rproc *priv);\n};\n\nstatic const struct imx_rproc_att imx_dsp_rproc_att_imx8qm[] = {\n\t \n\t{ 0x596e8000, 0x556e8000, 0x00008000, ATT_OWN },\n\t{ 0x596f0000, 0x556f0000, 0x00008000, ATT_OWN },\n\t{ 0x596f8000, 0x556f8000, 0x00000800, ATT_OWN | ATT_IRAM},\n\t{ 0x55700000, 0x55700000, 0x00070000, ATT_OWN },\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0},\n};\n\nstatic const struct imx_rproc_att imx_dsp_rproc_att_imx8qxp[] = {\n\t \n\t{ 0x596e8000, 0x596e8000, 0x00008000, ATT_OWN },\n\t{ 0x596f0000, 0x596f0000, 0x00008000, ATT_OWN },\n\t{ 0x596f8000, 0x596f8000, 0x00000800, ATT_OWN | ATT_IRAM},\n\t{ 0x59700000, 0x59700000, 0x00070000, ATT_OWN },\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0},\n};\n\nstatic const struct imx_rproc_att imx_dsp_rproc_att_imx8mp[] = {\n\t \n\t{ 0x3b6e8000, 0x3b6e8000, 0x00008000, ATT_OWN },\n\t{ 0x3b6f0000, 0x3b6f0000, 0x00008000, ATT_OWN },\n\t{ 0x3b6f8000, 0x3b6f8000, 0x00000800, ATT_OWN | ATT_IRAM},\n\t{ 0x3b700000, 0x3b700000, 0x00040000, ATT_OWN },\n\t \n\t{ 0x40000000, 0x40000000, 0x80000000, 0},\n};\n\nstatic const struct imx_rproc_att imx_dsp_rproc_att_imx8ulp[] = {\n\t \n\t{ 0x21170000, 0x21170000, 0x00010000, ATT_OWN | ATT_IRAM},\n\t{ 0x21180000, 0x21180000, 0x00010000, ATT_OWN },\n\t \n\t{ 0x0c000000, 0x80000000, 0x10000000, 0},\n\t{ 0x30000000, 0x90000000, 0x10000000, 0},\n};\n\n \nstatic int (*imx_dsp_rproc_mbox_init)(struct imx_dsp_rproc *priv);\n\n \nstatic int imx8mp_dsp_reset(struct imx_dsp_rproc *priv)\n{\n\tvoid __iomem *dap = ioremap_wc(IMX8M_DAP_DEBUG, IMX8M_DAP_DEBUG_SIZE);\n\tint pwrctl;\n\n\t \n\tpwrctl = readl(dap + IMX8M_DAP_PWRCTL);\n\tpwrctl |= IMX8M_PWRCTL_CORERESET;\n\twritel(pwrctl, dap + IMX8M_DAP_PWRCTL);\n\n\t \n\tusleep_range(1, 2);\n\n\tregmap_update_bits(priv->regmap, IMX8M_AudioDSP_REG2,\n\t\t\t   IMX8M_AudioDSP_REG2_RUNSTALL,\n\t\t\t   IMX8M_AudioDSP_REG2_RUNSTALL);\n\n\t \n\tpwrctl = readl(dap + IMX8M_DAP_PWRCTL);\n\tpwrctl &= ~IMX8M_PWRCTL_CORERESET;\n\twritel(pwrctl, dap + IMX8M_DAP_PWRCTL);\n\n\tiounmap(dap);\n\treturn 0;\n}\n\n \nstatic int imx8ulp_dsp_reset(struct imx_dsp_rproc *priv)\n{\n\tstruct arm_smccc_res res;\n\n\t \n\tregmap_update_bits(priv->regmap, IMX8ULP_SIM_LPAV_REG_SYSCTRL0,\n\t\t\t   IMX8ULP_SYSCTRL0_DSP_RST, IMX8ULP_SYSCTRL0_DSP_RST);\n\tregmap_update_bits(priv->regmap, IMX8ULP_SIM_LPAV_REG_SYSCTRL0,\n\t\t\t   IMX8ULP_SYSCTRL0_DSP_STALL,\n\t\t\t   IMX8ULP_SYSCTRL0_DSP_STALL);\n\n\t \n\tarm_smccc_smc(IMX8ULP_SIP_HIFI_XRDC, 0, 0, 0, 0, 0, 0, 0, &res);\n\n\t \n\tregmap_update_bits(priv->regmap, IMX8ULP_SIM_LPAV_REG_SYSCTRL0,\n\t\t\t   IMX8ULP_SYSCTRL0_DSP_RST, 0);\n\tregmap_update_bits(priv->regmap, IMX8ULP_SIM_LPAV_REG_SYSCTRL0,\n\t\t\t   IMX8ULP_SYSCTRL0_DSP_DBG_RST, 0);\n\n\treturn 0;\n}\n\n \nstatic const struct imx_rproc_dcfg dsp_rproc_cfg_imx8mp = {\n\t.src_reg\t= IMX8M_AudioDSP_REG2,\n\t.src_mask\t= IMX8M_AudioDSP_REG2_RUNSTALL,\n\t.src_start\t= 0,\n\t.src_stop\t= IMX8M_AudioDSP_REG2_RUNSTALL,\n\t.att\t\t= imx_dsp_rproc_att_imx8mp,\n\t.att_size\t= ARRAY_SIZE(imx_dsp_rproc_att_imx8mp),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_dsp_rproc_dcfg imx_dsp_rproc_cfg_imx8mp = {\n\t.dcfg\t\t= &dsp_rproc_cfg_imx8mp,\n\t.reset          = imx8mp_dsp_reset,\n};\n\n \nstatic const struct imx_rproc_dcfg dsp_rproc_cfg_imx8ulp = {\n\t.src_reg\t= IMX8ULP_SIM_LPAV_REG_SYSCTRL0,\n\t.src_mask\t= IMX8ULP_SYSCTRL0_DSP_STALL,\n\t.src_start\t= 0,\n\t.src_stop\t= IMX8ULP_SYSCTRL0_DSP_STALL,\n\t.att\t\t= imx_dsp_rproc_att_imx8ulp,\n\t.att_size\t= ARRAY_SIZE(imx_dsp_rproc_att_imx8ulp),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_dsp_rproc_dcfg imx_dsp_rproc_cfg_imx8ulp = {\n\t.dcfg\t\t= &dsp_rproc_cfg_imx8ulp,\n\t.reset          = imx8ulp_dsp_reset,\n};\n\n \nstatic const struct imx_rproc_dcfg dsp_rproc_cfg_imx8qxp = {\n\t.att\t\t= imx_dsp_rproc_att_imx8qxp,\n\t.att_size\t= ARRAY_SIZE(imx_dsp_rproc_att_imx8qxp),\n\t.method\t\t= IMX_RPROC_SCU_API,\n};\n\nstatic const struct imx_dsp_rproc_dcfg imx_dsp_rproc_cfg_imx8qxp = {\n\t.dcfg\t\t= &dsp_rproc_cfg_imx8qxp,\n};\n\n \nstatic const struct imx_rproc_dcfg dsp_rproc_cfg_imx8qm = {\n\t.att\t\t= imx_dsp_rproc_att_imx8qm,\n\t.att_size\t= ARRAY_SIZE(imx_dsp_rproc_att_imx8qm),\n\t.method\t\t= IMX_RPROC_SCU_API,\n};\n\nstatic const struct imx_dsp_rproc_dcfg imx_dsp_rproc_cfg_imx8qm = {\n\t.dcfg\t\t= &dsp_rproc_cfg_imx8qm,\n};\n\nstatic int imx_dsp_rproc_ready(struct rproc *rproc)\n{\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tint i;\n\n\tif (!priv->rxdb_ch)\n\t\treturn 0;\n\n\tfor (i = 0; i < REMOTE_READY_WAIT_MAX_RETRIES; i++) {\n\t\tif (priv->flags & REMOTE_IS_READY)\n\t\t\treturn 0;\n\t\tusleep_range(100, 200);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nstatic int imx_dsp_rproc_start(struct rproc *rproc)\n{\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tconst struct imx_rproc_dcfg *dcfg = dsp_dcfg->dcfg;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\n\tswitch (dcfg->method) {\n\tcase IMX_RPROC_MMIO:\n\t\tret = regmap_update_bits(priv->regmap,\n\t\t\t\t\t dcfg->src_reg,\n\t\t\t\t\t dcfg->src_mask,\n\t\t\t\t\t dcfg->src_start);\n\t\tbreak;\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_sc_pm_cpu_start(priv->ipc_handle,\n\t\t\t\t\t  IMX_SC_R_DSP,\n\t\t\t\t\t  true,\n\t\t\t\t\t  rproc->bootaddr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to enable remote core!\\n\");\n\telse\n\t\tret = imx_dsp_rproc_ready(rproc);\n\n\treturn ret;\n}\n\n \nstatic int imx_dsp_rproc_stop(struct rproc *rproc)\n{\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tconst struct imx_rproc_dcfg *dcfg = dsp_dcfg->dcfg;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret = 0;\n\n\tif (rproc->state == RPROC_CRASHED) {\n\t\tpriv->flags &= ~REMOTE_IS_READY;\n\t\treturn 0;\n\t}\n\n\tswitch (dcfg->method) {\n\tcase IMX_RPROC_MMIO:\n\t\tret = regmap_update_bits(priv->regmap, dcfg->src_reg, dcfg->src_mask,\n\t\t\t\t\t dcfg->src_stop);\n\t\tbreak;\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_sc_pm_cpu_start(priv->ipc_handle,\n\t\t\t\t\t  IMX_SC_R_DSP,\n\t\t\t\t\t  false,\n\t\t\t\t\t  rproc->bootaddr);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to stop remote core\\n\");\n\telse\n\t\tpriv->flags &= ~REMOTE_IS_READY;\n\n\treturn ret;\n}\n\n \nstatic int imx_dsp_rproc_sys_to_da(struct imx_dsp_rproc *priv, u64 sys,\n\t\t\t\t   size_t len, u64 *da)\n{\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tconst struct imx_rproc_dcfg *dcfg = dsp_dcfg->dcfg;\n\tint i;\n\n\t \n\tfor (i = 0; i < dcfg->att_size; i++) {\n\t\tconst struct imx_rproc_att *att = &dcfg->att[i];\n\n\t\tif (sys >= att->sa && sys + len <= att->sa + att->size) {\n\t\t\tunsigned int offset = sys - att->sa;\n\n\t\t\t*da = att->da + offset;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn -ENOENT;\n}\n\n \nstatic void imx_dsp_rproc_vq_work(struct work_struct *work)\n{\n\tstruct imx_dsp_rproc *priv = container_of(work, struct imx_dsp_rproc,\n\t\t\t\t\t\t  rproc_work);\n\tstruct rproc *rproc = priv->rproc;\n\n\tmutex_lock(&rproc->lock);\n\n\tif (rproc->state != RPROC_RUNNING)\n\t\tgoto unlock_mutex;\n\n\trproc_vq_interrupt(priv->rproc, 0);\n\trproc_vq_interrupt(priv->rproc, 1);\n\nunlock_mutex:\n\tmutex_unlock(&rproc->lock);\n}\n\n \nstatic void imx_dsp_rproc_rx_tx_callback(struct mbox_client *cl, void *data)\n{\n\tstruct rproc *rproc = dev_get_drvdata(cl->dev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tu32 message = (u32)(*(u32 *)data);\n\n\tdev_dbg(dev, \"mbox msg: 0x%x\\n\", message);\n\n\tswitch (message) {\n\tcase RP_MBOX_SUSPEND_ACK:\n\t\tcomplete(&priv->pm_comp);\n\t\tbreak;\n\tcase RP_MBOX_RESUME_ACK:\n\t\tcomplete(&priv->pm_comp);\n\t\tbreak;\n\tdefault:\n\t\tschedule_work(&priv->rproc_work);\n\t\tbreak;\n\t}\n}\n\n \nstatic void imx_dsp_rproc_rxdb_callback(struct mbox_client *cl, void *data)\n{\n\tstruct rproc *rproc = dev_get_drvdata(cl->dev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\n\t \n\tpriv->flags |= REMOTE_IS_READY;\n}\n\n \nstatic int imx_dsp_rproc_mbox_alloc(struct imx_dsp_rproc *priv)\n{\n\tstruct device *dev = priv->rproc->dev.parent;\n\tstruct mbox_client *cl;\n\tint ret;\n\n\tif (!of_get_property(dev->of_node, \"mbox-names\", NULL))\n\t\treturn 0;\n\n\tcl = &priv->cl;\n\tcl->dev = dev;\n\tcl->tx_block = true;\n\tcl->tx_tout = 100;\n\tcl->knows_txdone = false;\n\tcl->rx_callback = imx_dsp_rproc_rx_tx_callback;\n\n\t \n\tpriv->tx_ch = mbox_request_channel_byname(cl, \"tx\");\n\tif (IS_ERR(priv->tx_ch)) {\n\t\tret = PTR_ERR(priv->tx_ch);\n\t\tdev_dbg(cl->dev, \"failed to request tx mailbox channel: %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\t \n\tpriv->rx_ch = mbox_request_channel_byname(cl, \"rx\");\n\tif (IS_ERR(priv->rx_ch)) {\n\t\tret = PTR_ERR(priv->rx_ch);\n\t\tdev_dbg(cl->dev, \"failed to request rx mailbox channel: %d\\n\",\n\t\t\tret);\n\t\tgoto free_channel_tx;\n\t}\n\n\tcl = &priv->cl_rxdb;\n\tcl->dev = dev;\n\tcl->rx_callback = imx_dsp_rproc_rxdb_callback;\n\n\t \n\tpriv->rxdb_ch = mbox_request_channel_byname(cl, \"rxdb\");\n\tif (IS_ERR(priv->rxdb_ch)) {\n\t\tret = PTR_ERR(priv->rxdb_ch);\n\t\tdev_dbg(cl->dev, \"failed to request mbox chan rxdb, ret %d\\n\",\n\t\t\tret);\n\t\tgoto free_channel_rx;\n\t}\n\n\treturn 0;\n\nfree_channel_rx:\n\tmbox_free_channel(priv->rx_ch);\nfree_channel_tx:\n\tmbox_free_channel(priv->tx_ch);\n\treturn ret;\n}\n\n \nstatic int imx_dsp_rproc_mbox_no_alloc(struct imx_dsp_rproc *priv)\n{\n\treturn 0;\n}\n\nstatic void imx_dsp_rproc_free_mbox(struct imx_dsp_rproc *priv)\n{\n\tmbox_free_channel(priv->tx_ch);\n\tmbox_free_channel(priv->rx_ch);\n\tmbox_free_channel(priv->rxdb_ch);\n}\n\n \nstatic int imx_dsp_rproc_add_carveout(struct imx_dsp_rproc *priv)\n{\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tconst struct imx_rproc_dcfg *dcfg = dsp_dcfg->dcfg;\n\tstruct rproc *rproc = priv->rproc;\n\tstruct device *dev = rproc->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_iterator it;\n\tstruct rproc_mem_entry *mem;\n\tstruct reserved_mem *rmem;\n\tvoid __iomem *cpu_addr;\n\tint a;\n\tu64 da;\n\n\t \n\tfor (a = 0; a < dcfg->att_size; a++) {\n\t\tconst struct imx_rproc_att *att = &dcfg->att[a];\n\n\t\tif (!(att->flags & ATT_OWN))\n\t\t\tcontinue;\n\n\t\tif (imx_dsp_rproc_sys_to_da(priv, att->sa, att->size, &da))\n\t\t\treturn -EINVAL;\n\n\t\tcpu_addr = devm_ioremap_wc(dev, att->sa, att->size);\n\t\tif (!cpu_addr) {\n\t\t\tdev_err(dev, \"failed to map memory %p\\n\", &att->sa);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tmem = rproc_mem_entry_init(dev, (void __force *)cpu_addr, (dma_addr_t)att->sa,\n\t\t\t\t\t   att->size, da, NULL, NULL, \"dsp_mem\");\n\n\t\tif (mem)\n\t\t\trproc_coredump_add_segment(rproc, da, att->size);\n\t\telse\n\t\t\treturn -ENOMEM;\n\n\t\trproc_add_carveout(rproc, mem);\n\t}\n\n\tof_phandle_iterator_init(&it, np, \"memory-region\", NULL, 0);\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\t\t \n\t\tif (!strcmp(it.node->name, \"vdev0buffer\"))\n\t\t\tcontinue;\n\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(dev, \"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (imx_dsp_rproc_sys_to_da(priv, rmem->base, rmem->size, &da)) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcpu_addr = devm_ioremap_wc(dev, rmem->base, rmem->size);\n\t\tif (!cpu_addr) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(dev, \"failed to map memory %p\\n\", &rmem->base);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t \n\t\tmem = rproc_mem_entry_init(dev, (void __force *)cpu_addr, (dma_addr_t)rmem->base,\n\t\t\t\t\t   rmem->size, da, NULL, NULL, it.node->name);\n\n\t\tif (mem) {\n\t\t\trproc_coredump_add_segment(rproc, da, rmem->size);\n\t\t} else {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_dsp_rproc_prepare(struct rproc *rproc)\n{\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tstruct rproc_mem_entry *carveout;\n\tint ret;\n\n\tret = imx_dsp_rproc_add_carveout(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_dsp_rproc_add_carveout\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\n\t \n\tlist_for_each_entry(carveout, &rproc->carveouts, node) {\n\t\tif (carveout->va)\n\t\t\tmemset(carveout->va, 0, carveout->len);\n\t}\n\n\treturn  0;\n}\n\n \nstatic int imx_dsp_rproc_unprepare(struct rproc *rproc)\n{\n\tpm_runtime_put_sync(rproc->dev.parent);\n\n\treturn  0;\n}\n\n \nstatic void imx_dsp_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tint err;\n\t__u32 mmsg;\n\n\tif (!priv->tx_ch) {\n\t\tdev_err(dev, \"No initialized mbox tx channel\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmmsg = vqid;\n\n\terr = mbox_send_message(priv->tx_ch, (void *)&mmsg);\n\tif (err < 0)\n\t\tdev_err(dev, \"%s: failed (%d, err:%d)\\n\", __func__, vqid, err);\n}\n\n \nstatic int imx_dsp_rproc_memcpy(void *dst, const void *src, size_t size)\n{\n\tvoid __iomem *dest = (void __iomem *)dst;\n\tconst u8 *src_byte = src;\n\tconst u32 *source = src;\n\tu32 affected_mask;\n\tint i, q, r;\n\tu32 tmp;\n\n\t \n\tif (!IS_ALIGNED((uintptr_t)dest, 4))\n\t\treturn -EINVAL;\n\n\tq = size / 4;\n\tr = size % 4;\n\n\t \n\tfor (i = 0; i < q; i++)\n\t\twritel(source[i], dest + i * 4);\n\n\tif (r) {\n\t\taffected_mask = GENMASK(8 * r, 0);\n\n\t\t \n\t\ttmp = readl(dest + q * 4);\n\t\ttmp &= ~affected_mask;\n\n\t\t \n\t\tfor (i = 0; i < r; i++)\n\t\t\ttmp |= (src_byte[q * 4 + i] << (8 * i));\n\n\t\twritel(tmp, dest + q * 4);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_dsp_rproc_memset(void *addr, u8 value, size_t size)\n{\n\tvoid __iomem *tmp_dst = (void __iomem *)addr;\n\tu32 tmp_val = value;\n\tu32 affected_mask;\n\tint q, r;\n\tu32 tmp;\n\n\t \n\tif (!IS_ALIGNED((uintptr_t)addr, 4))\n\t\treturn -EINVAL;\n\n\ttmp_val |= tmp_val << 8;\n\ttmp_val |= tmp_val << 16;\n\n\tq = size / 4;\n\tr = size % 4;\n\n\twhile (q--)\n\t\twritel(tmp_val, tmp_dst++);\n\n\tif (r) {\n\t\taffected_mask = GENMASK(8 * r, 0);\n\n\t\t \n\t\ttmp = readl(tmp_dst);\n\t\ttmp &= ~affected_mask;\n\n\t\ttmp |= (tmp_val & affected_mask);\n\t\twritel(tmp, tmp_dst);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_dsp_rproc_elf_load_segments(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = &rproc->dev;\n\tconst void *ehdr, *phdr;\n\tint i, ret = 0;\n\tu16 phnum;\n\tconst u8 *elf_data = fw->data;\n\tu8 class = fw_elf_get_class(fw);\n\tu32 elf_phdr_get_size = elf_size_of_phdr(class);\n\n\tehdr = elf_data;\n\tphnum = elf_hdr_get_e_phnum(class, ehdr);\n\tphdr = elf_data + elf_hdr_get_e_phoff(class, ehdr);\n\n\t \n\tfor (i = 0; i < phnum; i++, phdr += elf_phdr_get_size) {\n\t\tu64 da = elf_phdr_get_p_paddr(class, phdr);\n\t\tu64 memsz = elf_phdr_get_p_memsz(class, phdr);\n\t\tu64 filesz = elf_phdr_get_p_filesz(class, phdr);\n\t\tu64 offset = elf_phdr_get_p_offset(class, phdr);\n\t\tu32 type = elf_phdr_get_p_type(class, phdr);\n\t\tvoid *ptr;\n\n\t\tif (type != PT_LOAD || !memsz)\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"phdr: type %d da 0x%llx memsz 0x%llx filesz 0x%llx\\n\",\n\t\t\ttype, da, memsz, filesz);\n\n\t\tif (filesz > memsz) {\n\t\t\tdev_err(dev, \"bad phdr filesz 0x%llx memsz 0x%llx\\n\",\n\t\t\t\tfilesz, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offset + filesz > fw->size) {\n\t\t\tdev_err(dev, \"truncated fw: need 0x%llx avail 0x%zx\\n\",\n\t\t\t\toffset + filesz, fw->size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rproc_u64_fit_in_size_t(memsz)) {\n\t\t\tdev_err(dev, \"size (%llx) does not fit in size_t type\\n\",\n\t\t\t\tmemsz);\n\t\t\tret = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tptr = rproc_da_to_va(rproc, da, memsz, NULL);\n\t\tif (!ptr) {\n\t\t\tdev_err(dev, \"bad phdr da 0x%llx mem 0x%llx\\n\", da,\n\t\t\t\tmemsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (filesz) {\n\t\t\tret = imx_dsp_rproc_memcpy(ptr, elf_data + offset, filesz);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"memory copy failed for da 0x%llx memsz 0x%llx\\n\",\n\t\t\t\t\tda, memsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (memsz > filesz) {\n\t\t\tret = imx_dsp_rproc_memset(ptr + filesz, 0, memsz - filesz);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"memset failed for da 0x%llx memsz 0x%llx\\n\",\n\t\t\t\t\tda, memsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int imx_dsp_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tif (rproc_elf_load_rsc_table(rproc, fw))\n\t\tdev_warn(&rproc->dev, \"no resource table found for this firmware\\n\");\n\n\treturn 0;\n}\n\nstatic const struct rproc_ops imx_dsp_rproc_ops = {\n\t.prepare\t= imx_dsp_rproc_prepare,\n\t.unprepare\t= imx_dsp_rproc_unprepare,\n\t.start\t\t= imx_dsp_rproc_start,\n\t.stop\t\t= imx_dsp_rproc_stop,\n\t.kick\t\t= imx_dsp_rproc_kick,\n\t.load\t\t= imx_dsp_rproc_elf_load_segments,\n\t.parse_fw\t= imx_dsp_rproc_parse_fw,\n\t.sanity_check\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n};\n\n \nstatic int imx_dsp_attach_pm_domains(struct imx_dsp_rproc *priv)\n{\n\tstruct device *dev = priv->rproc->dev.parent;\n\tint ret, i;\n\n\tpriv->num_domains = of_count_phandle_with_args(dev->of_node,\n\t\t\t\t\t\t       \"power-domains\",\n\t\t\t\t\t\t       \"#power-domain-cells\");\n\n\t \n\tif (priv->num_domains <= 1)\n\t\treturn 0;\n\n\tpriv->pd_dev = devm_kmalloc_array(dev, priv->num_domains,\n\t\t\t\t\t  sizeof(*priv->pd_dev),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!priv->pd_dev)\n\t\treturn -ENOMEM;\n\n\tpriv->pd_dev_link = devm_kmalloc_array(dev, priv->num_domains,\n\t\t\t\t\t       sizeof(*priv->pd_dev_link),\n\t\t\t\t\t       GFP_KERNEL);\n\tif (!priv->pd_dev_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->num_domains; i++) {\n\t\tpriv->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR(priv->pd_dev[i])) {\n\t\t\tret = PTR_ERR(priv->pd_dev[i]);\n\t\t\tgoto detach_pm;\n\t\t}\n\n\t\t \n\t\tpriv->pd_dev_link[i] = device_link_add(dev,\n\t\t\t\t\t\t       priv->pd_dev[i],\n\t\t\t\t\t\t       DL_FLAG_STATELESS |\n\t\t\t\t\t\t       DL_FLAG_PM_RUNTIME);\n\t\tif (!priv->pd_dev_link[i]) {\n\t\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t\t\tret = -EINVAL;\n\t\t\tgoto detach_pm;\n\t\t}\n\t}\n\n\treturn 0;\n\ndetach_pm:\n\twhile (--i >= 0) {\n\t\tdevice_link_del(priv->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t}\n\n\treturn ret;\n}\n\nstatic int imx_dsp_detach_pm_domains(struct imx_dsp_rproc *priv)\n{\n\tint i;\n\n\tif (priv->num_domains <= 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < priv->num_domains; i++) {\n\t\tdevice_link_del(priv->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx_dsp_rproc_detect_mode(struct imx_dsp_rproc *priv)\n{\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tstruct device *dev = priv->rproc->dev.parent;\n\tstruct regmap *regmap;\n\tint ret = 0;\n\n\tswitch (dsp_dcfg->dcfg->method) {\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_scu_get_handle(&priv->ipc_handle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IMX_RPROC_MMIO:\n\t\tregmap = syscon_regmap_lookup_by_phandle(dev->of_node, \"fsl,dsp-ctrl\");\n\t\tif (IS_ERR(regmap)) {\n\t\t\tdev_err(dev, \"failed to find syscon\\n\");\n\t\t\treturn PTR_ERR(regmap);\n\t\t}\n\n\t\tpriv->regmap = regmap;\n\t\tbreak;\n\tdefault:\n\t\tret = -EOPNOTSUPP;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic const char *imx_dsp_clks_names[DSP_RPROC_CLK_MAX] = {\n\t \n\t\"core\", \"ocram\", \"debug\", \"ipg\", \"mu\",\n};\n\nstatic int imx_dsp_rproc_clk_get(struct imx_dsp_rproc *priv)\n{\n\tstruct device *dev = priv->rproc->dev.parent;\n\tstruct clk_bulk_data *clks = priv->clks;\n\tint i;\n\n\tfor (i = 0; i < DSP_RPROC_CLK_MAX; i++)\n\t\tclks[i].id = imx_dsp_clks_names[i];\n\n\treturn devm_clk_bulk_get_optional(dev, DSP_RPROC_CLK_MAX, clks);\n}\n\nstatic int imx_dsp_rproc_probe(struct platform_device *pdev)\n{\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct imx_dsp_rproc *priv;\n\tstruct rproc *rproc;\n\tconst char *fw_name;\n\tint ret;\n\n\tdsp_dcfg = of_device_get_match_data(dev);\n\tif (!dsp_dcfg)\n\t\treturn -ENODEV;\n\n\tret = rproc_of_parse_firmware(dev, 0, &fw_name);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse firmware-name property, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trproc = rproc_alloc(dev, \"imx-dsp-rproc\", &imx_dsp_rproc_ops, fw_name,\n\t\t\t    sizeof(*priv));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\tpriv = rproc->priv;\n\tpriv->rproc = rproc;\n\tpriv->dsp_dcfg = dsp_dcfg;\n\n\tif (no_mailboxes)\n\t\timx_dsp_rproc_mbox_init = imx_dsp_rproc_mbox_no_alloc;\n\telse\n\t\timx_dsp_rproc_mbox_init = imx_dsp_rproc_mbox_alloc;\n\n\tdev_set_drvdata(dev, rproc);\n\n\tINIT_WORK(&priv->rproc_work, imx_dsp_rproc_vq_work);\n\n\tret = imx_dsp_rproc_detect_mode(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_dsp_rproc_detect_mode\\n\");\n\t\tgoto err_put_rproc;\n\t}\n\n\t \n\tret = imx_dsp_attach_pm_domains(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_dsp_attach_pm_domains\\n\");\n\t\tgoto err_put_rproc;\n\t}\n\t \n\tret = imx_dsp_rproc_clk_get(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_dsp_rproc_clk_get\\n\");\n\t\tgoto err_detach_domains;\n\t}\n\n\tinit_completion(&priv->pm_comp);\n\trproc->auto_boot = false;\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed\\n\");\n\t\tgoto err_detach_domains;\n\t}\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nerr_detach_domains:\n\timx_dsp_detach_pm_domains(priv);\nerr_put_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void imx_dsp_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\n\tpm_runtime_disable(&pdev->dev);\n\trproc_del(rproc);\n\timx_dsp_detach_pm_domains(priv);\n\trproc_free(rproc);\n}\n\n \nstatic int imx_dsp_runtime_resume(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\tconst struct imx_dsp_rproc_dcfg *dsp_dcfg = priv->dsp_dcfg;\n\tint ret;\n\n\t \n\tret = imx_dsp_rproc_mbox_init(priv);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_dsp_rproc_mbox_init\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_bulk_prepare_enable(DSP_RPROC_CLK_MAX, priv->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on clk_bulk_prepare_enable\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (dsp_dcfg->reset)\n\t\tdsp_dcfg->reset(priv);\n\n\treturn 0;\n}\n\nstatic int imx_dsp_runtime_suspend(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\n\tclk_bulk_disable_unprepare(DSP_RPROC_CLK_MAX, priv->clks);\n\n\timx_dsp_rproc_free_mbox(priv);\n\n\treturn 0;\n}\n\nstatic void imx_dsp_load_firmware(const struct firmware *fw, void *context)\n{\n\tstruct rproc *rproc = context;\n\tint ret;\n\n\t \n\tret = rproc_load_segments(rproc, fw);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tret = rproc->ops->start(rproc);\n\tif (ret)\n\t\tgoto out;\n\n\trproc->ops->kick(rproc, 0);\n\nout:\n\trelease_firmware(fw);\n}\n\nstatic int imx_dsp_suspend(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct imx_dsp_rproc *priv = rproc->priv;\n\t__u32 mmsg = RP_MBOX_SUSPEND_SYSTEM;\n\tint ret;\n\n\tif (rproc->state != RPROC_RUNNING)\n\t\tgoto out;\n\n\treinit_completion(&priv->pm_comp);\n\n\t \n\tret = mbox_send_message(priv->tx_ch, (void *)&mmsg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"PM mbox_send_message failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tif (!wait_for_completion_timeout(&priv->pm_comp, msecs_to_jiffies(100)))\n\t\treturn -EBUSY;\n\nout:\n\t \n\treturn pm_runtime_force_suspend(dev);\n}\n\nstatic int imx_dsp_resume(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tret = pm_runtime_force_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (rproc->state != RPROC_RUNNING)\n\t\treturn 0;\n\n\t \n\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT,\n\t\t\t\t      rproc->firmware, dev, GFP_KERNEL,\n\t\t\t\t      rproc, imx_dsp_load_firmware);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"load firmware failed: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\treturn 0;\n\nerr:\n\tpm_runtime_force_suspend(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops imx_dsp_rproc_pm_ops = {\n\tSYSTEM_SLEEP_PM_OPS(imx_dsp_suspend, imx_dsp_resume)\n\tRUNTIME_PM_OPS(imx_dsp_runtime_suspend, imx_dsp_runtime_resume, NULL)\n};\n\nstatic const struct of_device_id imx_dsp_rproc_of_match[] = {\n\t{ .compatible = \"fsl,imx8qxp-hifi4\", .data = &imx_dsp_rproc_cfg_imx8qxp },\n\t{ .compatible = \"fsl,imx8qm-hifi4\",  .data = &imx_dsp_rproc_cfg_imx8qm },\n\t{ .compatible = \"fsl,imx8mp-hifi4\",  .data = &imx_dsp_rproc_cfg_imx8mp },\n\t{ .compatible = \"fsl,imx8ulp-hifi4\", .data = &imx_dsp_rproc_cfg_imx8ulp },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, imx_dsp_rproc_of_match);\n\nstatic struct platform_driver imx_dsp_rproc_driver = {\n\t.probe = imx_dsp_rproc_probe,\n\t.remove_new = imx_dsp_rproc_remove,\n\t.driver = {\n\t\t.name = \"imx-dsp-rproc\",\n\t\t.of_match_table = imx_dsp_rproc_of_match,\n\t\t.pm = pm_ptr(&imx_dsp_rproc_pm_ops),\n\t},\n};\nmodule_platform_driver(imx_dsp_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"i.MX HiFi Core Remote Processor Control Driver\");\nMODULE_AUTHOR(\"Shengjiu Wang <shengjiu.wang@nxp.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}