{
  "module_name": "qcom_q6v5_pas.c",
  "hash_id": "9ef15c84d623b541b7e7e7d3eeadb8001b44c5d5492f9e8a5cd8a1ed40ed518e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_q6v5_pas.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/remoteproc.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\n#include \"qcom_common.h\"\n#include \"qcom_pil_info.h\"\n#include \"qcom_q6v5.h\"\n#include \"remoteproc_internal.h\"\n\n#define ADSP_DECRYPT_SHUTDOWN_DELAY_MS\t100\n\nstruct adsp_data {\n\tint crash_reason_smem;\n\tconst char *firmware_name;\n\tconst char *dtb_firmware_name;\n\tint pas_id;\n\tint dtb_pas_id;\n\tunsigned int minidump_id;\n\tbool auto_boot;\n\tbool decrypt_shutdown;\n\n\tchar **proxy_pd_names;\n\n\tconst char *load_state;\n\tconst char *ssr_name;\n\tconst char *sysmon_name;\n\tint ssctl_id;\n\n\tint region_assign_idx;\n};\n\nstruct qcom_adsp {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\n\tstruct qcom_q6v5 q6v5;\n\n\tstruct clk *xo;\n\tstruct clk *aggre2_clk;\n\n\tstruct regulator *cx_supply;\n\tstruct regulator *px_supply;\n\n\tstruct device *proxy_pds[3];\n\n\tint proxy_pd_count;\n\n\tconst char *dtb_firmware_name;\n\tint pas_id;\n\tint dtb_pas_id;\n\tunsigned int minidump_id;\n\tint crash_reason_smem;\n\tbool decrypt_shutdown;\n\tconst char *info_name;\n\n\tconst struct firmware *firmware;\n\tconst struct firmware *dtb_firmware;\n\n\tstruct completion start_done;\n\tstruct completion stop_done;\n\n\tphys_addr_t mem_phys;\n\tphys_addr_t dtb_mem_phys;\n\tphys_addr_t mem_reloc;\n\tphys_addr_t dtb_mem_reloc;\n\tphys_addr_t region_assign_phys;\n\tvoid *mem_region;\n\tvoid *dtb_mem_region;\n\tsize_t mem_size;\n\tsize_t dtb_mem_size;\n\tsize_t region_assign_size;\n\n\tint region_assign_idx;\n\tu64 region_assign_perms;\n\n\tstruct qcom_rproc_glink glink_subdev;\n\tstruct qcom_rproc_subdev smd_subdev;\n\tstruct qcom_rproc_ssr ssr_subdev;\n\tstruct qcom_sysmon *sysmon;\n\n\tstruct qcom_scm_pas_metadata pas_metadata;\n\tstruct qcom_scm_pas_metadata dtb_pas_metadata;\n};\n\nstatic void adsp_segment_dump(struct rproc *rproc, struct rproc_dump_segment *segment,\n\t\t       void *dest, size_t offset, size_t size)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint total_offset;\n\n\ttotal_offset = segment->da + segment->offset + offset - adsp->mem_phys;\n\tif (total_offset < 0 || total_offset + size > adsp->mem_size) {\n\t\tdev_err(adsp->dev,\n\t\t\t\"invalid copy request for segment %pad with offset %zu and size %zu)\\n\",\n\t\t\t&segment->da, offset, size);\n\t\tmemset(dest, 0xff, size);\n\t\treturn;\n\t}\n\n\tmemcpy_fromio(dest, adsp->mem_region + total_offset, size);\n}\n\nstatic void adsp_minidump(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\n\tif (rproc->dump_conf == RPROC_COREDUMP_DISABLED)\n\t\treturn;\n\n\tqcom_minidump(rproc, adsp->minidump_id, adsp_segment_dump);\n}\n\nstatic int adsp_pds_enable(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t   size_t pd_count)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], INT_MAX);\n\t\tret = pm_runtime_get_sync(pds[i]);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(pds[i]);\n\t\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\t\tgoto unroll_pd_votes;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll_pd_votes:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n\n\treturn ret;\n};\n\nstatic void adsp_pds_disable(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t     size_t pd_count)\n{\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n}\n\nstatic int adsp_shutdown_poll_decrypt(struct qcom_adsp *adsp)\n{\n\tunsigned int retry_num = 50;\n\tint ret;\n\n\tdo {\n\t\tmsleep(ADSP_DECRYPT_SHUTDOWN_DELAY_MS);\n\t\tret = qcom_scm_pas_shutdown(adsp->pas_id);\n\t} while (ret == -EINVAL && --retry_num);\n\n\treturn ret;\n}\n\nstatic int adsp_unprepare(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\n\t \n\tqcom_scm_pas_metadata_release(&adsp->pas_metadata);\n\tif (adsp->dtb_pas_id)\n\t\tqcom_scm_pas_metadata_release(&adsp->dtb_pas_metadata);\n\n\treturn 0;\n}\n\nstatic int adsp_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint ret;\n\n\t \n\tadsp->firmware = fw;\n\n\tif (adsp->dtb_pas_id) {\n\t\tret = request_firmware(&adsp->dtb_firmware, adsp->dtb_firmware_name, adsp->dev);\n\t\tif (ret) {\n\t\t\tdev_err(adsp->dev, \"request_firmware failed for %s: %d\\n\",\n\t\t\t\tadsp->dtb_firmware_name, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = qcom_mdt_pas_init(adsp->dev, adsp->dtb_firmware, adsp->dtb_firmware_name,\n\t\t\t\t\tadsp->dtb_pas_id, adsp->dtb_mem_phys,\n\t\t\t\t\t&adsp->dtb_pas_metadata);\n\t\tif (ret)\n\t\t\tgoto release_dtb_firmware;\n\n\t\tret = qcom_mdt_load_no_init(adsp->dev, adsp->dtb_firmware, adsp->dtb_firmware_name,\n\t\t\t\t\t    adsp->dtb_pas_id, adsp->dtb_mem_region,\n\t\t\t\t\t    adsp->dtb_mem_phys, adsp->dtb_mem_size,\n\t\t\t\t\t    &adsp->dtb_mem_reloc);\n\t\tif (ret)\n\t\t\tgoto release_dtb_metadata;\n\t}\n\n\treturn 0;\n\nrelease_dtb_metadata:\n\tqcom_scm_pas_metadata_release(&adsp->dtb_pas_metadata);\n\nrelease_dtb_firmware:\n\trelease_firmware(adsp->dtb_firmware);\n\n\treturn ret;\n}\n\nstatic int adsp_start(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint ret;\n\n\tret = qcom_q6v5_prepare(&adsp->q6v5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adsp_pds_enable(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n\tif (ret < 0)\n\t\tgoto disable_irqs;\n\n\tret = clk_prepare_enable(adsp->xo);\n\tif (ret)\n\t\tgoto disable_proxy_pds;\n\n\tret = clk_prepare_enable(adsp->aggre2_clk);\n\tif (ret)\n\t\tgoto disable_xo_clk;\n\n\tif (adsp->cx_supply) {\n\t\tret = regulator_enable(adsp->cx_supply);\n\t\tif (ret)\n\t\t\tgoto disable_aggre2_clk;\n\t}\n\n\tif (adsp->px_supply) {\n\t\tret = regulator_enable(adsp->px_supply);\n\t\tif (ret)\n\t\t\tgoto disable_cx_supply;\n\t}\n\n\tif (adsp->dtb_pas_id) {\n\t\tret = qcom_scm_pas_auth_and_reset(adsp->dtb_pas_id);\n\t\tif (ret) {\n\t\t\tdev_err(adsp->dev,\n\t\t\t\t\"failed to authenticate dtb image and release reset\\n\");\n\t\t\tgoto disable_px_supply;\n\t\t}\n\t}\n\n\tret = qcom_mdt_pas_init(adsp->dev, adsp->firmware, rproc->firmware, adsp->pas_id,\n\t\t\t\tadsp->mem_phys, &adsp->pas_metadata);\n\tif (ret)\n\t\tgoto disable_px_supply;\n\n\tret = qcom_mdt_load_no_init(adsp->dev, adsp->firmware, rproc->firmware, adsp->pas_id,\n\t\t\t\t    adsp->mem_region, adsp->mem_phys, adsp->mem_size,\n\t\t\t\t    &adsp->mem_reloc);\n\tif (ret)\n\t\tgoto release_pas_metadata;\n\n\tqcom_pil_info_store(adsp->info_name, adsp->mem_phys, adsp->mem_size);\n\n\tret = qcom_scm_pas_auth_and_reset(adsp->pas_id);\n\tif (ret) {\n\t\tdev_err(adsp->dev,\n\t\t\t\"failed to authenticate image and release reset\\n\");\n\t\tgoto release_pas_metadata;\n\t}\n\n\tret = qcom_q6v5_wait_for_start(&adsp->q6v5, msecs_to_jiffies(5000));\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(adsp->dev, \"start timed out\\n\");\n\t\tqcom_scm_pas_shutdown(adsp->pas_id);\n\t\tgoto release_pas_metadata;\n\t}\n\n\tqcom_scm_pas_metadata_release(&adsp->pas_metadata);\n\tif (adsp->dtb_pas_id)\n\t\tqcom_scm_pas_metadata_release(&adsp->dtb_pas_metadata);\n\n\t \n\tadsp->firmware = NULL;\n\n\treturn 0;\n\nrelease_pas_metadata:\n\tqcom_scm_pas_metadata_release(&adsp->pas_metadata);\n\tif (adsp->dtb_pas_id)\n\t\tqcom_scm_pas_metadata_release(&adsp->dtb_pas_metadata);\ndisable_px_supply:\n\tif (adsp->px_supply)\n\t\tregulator_disable(adsp->px_supply);\ndisable_cx_supply:\n\tif (adsp->cx_supply)\n\t\tregulator_disable(adsp->cx_supply);\ndisable_aggre2_clk:\n\tclk_disable_unprepare(adsp->aggre2_clk);\ndisable_xo_clk:\n\tclk_disable_unprepare(adsp->xo);\ndisable_proxy_pds:\n\tadsp_pds_disable(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\ndisable_irqs:\n\tqcom_q6v5_unprepare(&adsp->q6v5);\n\n\t \n\tadsp->firmware = NULL;\n\n\treturn ret;\n}\n\nstatic void qcom_pas_handover(struct qcom_q6v5 *q6v5)\n{\n\tstruct qcom_adsp *adsp = container_of(q6v5, struct qcom_adsp, q6v5);\n\n\tif (adsp->px_supply)\n\t\tregulator_disable(adsp->px_supply);\n\tif (adsp->cx_supply)\n\t\tregulator_disable(adsp->cx_supply);\n\tclk_disable_unprepare(adsp->aggre2_clk);\n\tclk_disable_unprepare(adsp->xo);\n\tadsp_pds_disable(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n}\n\nstatic int adsp_stop(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint handover;\n\tint ret;\n\n\tret = qcom_q6v5_request_stop(&adsp->q6v5, adsp->sysmon);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(adsp->dev, \"timed out on wait\\n\");\n\n\tret = qcom_scm_pas_shutdown(adsp->pas_id);\n\tif (ret && adsp->decrypt_shutdown)\n\t\tret = adsp_shutdown_poll_decrypt(adsp);\n\n\tif (ret)\n\t\tdev_err(adsp->dev, \"failed to shutdown: %d\\n\", ret);\n\n\tif (adsp->dtb_pas_id) {\n\t\tret = qcom_scm_pas_shutdown(adsp->dtb_pas_id);\n\t\tif (ret)\n\t\t\tdev_err(adsp->dev, \"failed to shutdown dtb: %d\\n\", ret);\n\t}\n\n\thandover = qcom_q6v5_unprepare(&adsp->q6v5);\n\tif (handover)\n\t\tqcom_pas_handover(&adsp->q6v5);\n\n\treturn ret;\n}\n\nstatic void *adsp_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint offset;\n\n\toffset = da - adsp->mem_reloc;\n\tif (offset < 0 || offset + len > adsp->mem_size)\n\t\treturn NULL;\n\n\tif (is_iomem)\n\t\t*is_iomem = true;\n\n\treturn adsp->mem_region + offset;\n}\n\nstatic unsigned long adsp_panic(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\n\treturn qcom_q6v5_panic(&adsp->q6v5);\n}\n\nstatic const struct rproc_ops adsp_ops = {\n\t.unprepare = adsp_unprepare,\n\t.start = adsp_start,\n\t.stop = adsp_stop,\n\t.da_to_va = adsp_da_to_va,\n\t.parse_fw = qcom_register_dump_segments,\n\t.load = adsp_load,\n\t.panic = adsp_panic,\n};\n\nstatic const struct rproc_ops adsp_minidump_ops = {\n\t.unprepare = adsp_unprepare,\n\t.start = adsp_start,\n\t.stop = adsp_stop,\n\t.da_to_va = adsp_da_to_va,\n\t.parse_fw = qcom_register_dump_segments,\n\t.load = adsp_load,\n\t.panic = adsp_panic,\n\t.coredump = adsp_minidump,\n};\n\nstatic int adsp_init_clock(struct qcom_adsp *adsp)\n{\n\tint ret;\n\n\tadsp->xo = devm_clk_get(adsp->dev, \"xo\");\n\tif (IS_ERR(adsp->xo)) {\n\t\tret = PTR_ERR(adsp->xo);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(adsp->dev, \"failed to get xo clock\");\n\t\treturn ret;\n\t}\n\n\tadsp->aggre2_clk = devm_clk_get_optional(adsp->dev, \"aggre2\");\n\tif (IS_ERR(adsp->aggre2_clk)) {\n\t\tret = PTR_ERR(adsp->aggre2_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(adsp->dev,\n\t\t\t\t\"failed to get aggre2 clock\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_init_regulator(struct qcom_adsp *adsp)\n{\n\tadsp->cx_supply = devm_regulator_get_optional(adsp->dev, \"cx\");\n\tif (IS_ERR(adsp->cx_supply)) {\n\t\tif (PTR_ERR(adsp->cx_supply) == -ENODEV)\n\t\t\tadsp->cx_supply = NULL;\n\t\telse\n\t\t\treturn PTR_ERR(adsp->cx_supply);\n\t}\n\n\tif (adsp->cx_supply)\n\t\tregulator_set_load(adsp->cx_supply, 100000);\n\n\tadsp->px_supply = devm_regulator_get_optional(adsp->dev, \"px\");\n\tif (IS_ERR(adsp->px_supply)) {\n\t\tif (PTR_ERR(adsp->px_supply) == -ENODEV)\n\t\t\tadsp->px_supply = NULL;\n\t\telse\n\t\t\treturn PTR_ERR(adsp->px_supply);\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_pds_attach(struct device *dev, struct device **devs,\n\t\t\t   char **pd_names)\n{\n\tsize_t num_pds = 0;\n\tint ret;\n\tint i;\n\n\tif (!pd_names)\n\t\treturn 0;\n\n\t \n\tif (dev->pm_domain) {\n\t\tdevs[0] = dev;\n\t\tpm_runtime_enable(dev);\n\t\treturn 1;\n\t}\n\n\twhile (pd_names[num_pds])\n\t\tnum_pds++;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tdevs[i] = dev_pm_domain_attach_by_name(dev, pd_names[i]);\n\t\tif (IS_ERR_OR_NULL(devs[i])) {\n\t\t\tret = PTR_ERR(devs[i]) ? : -ENODATA;\n\t\t\tgoto unroll_attach;\n\t\t}\n\t}\n\n\treturn num_pds;\n\nunroll_attach:\n\tfor (i--; i >= 0; i--)\n\t\tdev_pm_domain_detach(devs[i], false);\n\n\treturn ret;\n};\n\nstatic void adsp_pds_detach(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t    size_t pd_count)\n{\n\tstruct device *dev = adsp->dev;\n\tint i;\n\n\t \n\tif (dev->pm_domain && pd_count) {\n\t\tpm_runtime_disable(dev);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < pd_count; i++)\n\t\tdev_pm_domain_detach(pds[i], false);\n}\n\nstatic int adsp_alloc_memory_region(struct qcom_adsp *adsp)\n{\n\tstruct reserved_mem *rmem;\n\tstruct device_node *node;\n\n\tnode = of_parse_phandle(adsp->dev->of_node, \"memory-region\", 0);\n\tif (!node) {\n\t\tdev_err(adsp->dev, \"no memory-region specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(adsp->dev, \"unable to resolve memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadsp->mem_phys = adsp->mem_reloc = rmem->base;\n\tadsp->mem_size = rmem->size;\n\tadsp->mem_region = devm_ioremap_wc(adsp->dev, adsp->mem_phys, adsp->mem_size);\n\tif (!adsp->mem_region) {\n\t\tdev_err(adsp->dev, \"unable to map memory region: %pa+%zx\\n\",\n\t\t\t&rmem->base, adsp->mem_size);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!adsp->dtb_pas_id)\n\t\treturn 0;\n\n\tnode = of_parse_phandle(adsp->dev->of_node, \"memory-region\", 1);\n\tif (!node) {\n\t\tdev_err(adsp->dev, \"no dtb memory-region specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(adsp->dev, \"unable to resolve dtb memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadsp->dtb_mem_phys = adsp->dtb_mem_reloc = rmem->base;\n\tadsp->dtb_mem_size = rmem->size;\n\tadsp->dtb_mem_region = devm_ioremap_wc(adsp->dev, adsp->dtb_mem_phys, adsp->dtb_mem_size);\n\tif (!adsp->dtb_mem_region) {\n\t\tdev_err(adsp->dev, \"unable to map dtb memory region: %pa+%zx\\n\",\n\t\t\t&rmem->base, adsp->dtb_mem_size);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_assign_memory_region(struct qcom_adsp *adsp)\n{\n\tstruct reserved_mem *rmem = NULL;\n\tstruct qcom_scm_vmperm perm;\n\tstruct device_node *node;\n\tint ret;\n\n\tif (!adsp->region_assign_idx)\n\t\treturn 0;\n\n\tnode = of_parse_phandle(adsp->dev->of_node, \"memory-region\", adsp->region_assign_idx);\n\tif (node)\n\t\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(adsp->dev, \"unable to resolve shareable memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tperm.vmid = QCOM_SCM_VMID_MSS_MSA;\n\tperm.perm = QCOM_SCM_PERM_RW;\n\n\tadsp->region_assign_phys = rmem->base;\n\tadsp->region_assign_size = rmem->size;\n\tadsp->region_assign_perms = BIT(QCOM_SCM_VMID_HLOS);\n\n\tret = qcom_scm_assign_mem(adsp->region_assign_phys,\n\t\t\t\t  adsp->region_assign_size,\n\t\t\t\t  &adsp->region_assign_perms,\n\t\t\t\t  &perm, 1);\n\tif (ret < 0) {\n\t\tdev_err(adsp->dev, \"assign memory failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void adsp_unassign_memory_region(struct qcom_adsp *adsp)\n{\n\tstruct qcom_scm_vmperm perm;\n\tint ret;\n\n\tif (!adsp->region_assign_idx)\n\t\treturn;\n\n\tperm.vmid = QCOM_SCM_VMID_HLOS;\n\tperm.perm = QCOM_SCM_PERM_RW;\n\n\tret = qcom_scm_assign_mem(adsp->region_assign_phys,\n\t\t\t\t  adsp->region_assign_size,\n\t\t\t\t  &adsp->region_assign_perms,\n\t\t\t\t  &perm, 1);\n\tif (ret < 0)\n\t\tdev_err(adsp->dev, \"unassign memory failed\\n\");\n}\n\nstatic int adsp_probe(struct platform_device *pdev)\n{\n\tconst struct adsp_data *desc;\n\tstruct qcom_adsp *adsp;\n\tstruct rproc *rproc;\n\tconst char *fw_name, *dtb_fw_name = NULL;\n\tconst struct rproc_ops *ops = &adsp_ops;\n\tint ret;\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (!qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tfw_name = desc->firmware_name;\n\tret = of_property_read_string(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t      &fw_name);\n\tif (ret < 0 && ret != -EINVAL)\n\t\treturn ret;\n\n\tif (desc->dtb_firmware_name) {\n\t\tdtb_fw_name = desc->dtb_firmware_name;\n\t\tret = of_property_read_string_index(pdev->dev.of_node, \"firmware-name\", 1,\n\t\t\t\t\t\t    &dtb_fw_name);\n\t\tif (ret < 0 && ret != -EINVAL)\n\t\t\treturn ret;\n\t}\n\n\tif (desc->minidump_id)\n\t\tops = &adsp_minidump_ops;\n\n\trproc = rproc_alloc(&pdev->dev, pdev->name, ops, fw_name, sizeof(*adsp));\n\n\tif (!rproc) {\n\t\tdev_err(&pdev->dev, \"unable to allocate remoteproc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trproc->auto_boot = desc->auto_boot;\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\tadsp = rproc->priv;\n\tadsp->dev = &pdev->dev;\n\tadsp->rproc = rproc;\n\tadsp->minidump_id = desc->minidump_id;\n\tadsp->pas_id = desc->pas_id;\n\tadsp->info_name = desc->sysmon_name;\n\tadsp->decrypt_shutdown = desc->decrypt_shutdown;\n\tadsp->region_assign_idx = desc->region_assign_idx;\n\tif (dtb_fw_name) {\n\t\tadsp->dtb_firmware_name = dtb_fw_name;\n\t\tadsp->dtb_pas_id = desc->dtb_pas_id;\n\t}\n\tplatform_set_drvdata(pdev, adsp);\n\n\tret = device_init_wakeup(adsp->dev, true);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_alloc_memory_region(adsp);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_assign_memory_region(adsp);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_init_clock(adsp);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_init_regulator(adsp);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_pds_attach(&pdev->dev, adsp->proxy_pds,\n\t\t\t      desc->proxy_pd_names);\n\tif (ret < 0)\n\t\tgoto free_rproc;\n\tadsp->proxy_pd_count = ret;\n\n\tret = qcom_q6v5_init(&adsp->q6v5, pdev, rproc, desc->crash_reason_smem, desc->load_state,\n\t\t\t     qcom_pas_handover);\n\tif (ret)\n\t\tgoto detach_proxy_pds;\n\n\tqcom_add_glink_subdev(rproc, &adsp->glink_subdev, desc->ssr_name);\n\tqcom_add_smd_subdev(rproc, &adsp->smd_subdev);\n\tadsp->sysmon = qcom_add_sysmon_subdev(rproc,\n\t\t\t\t\t      desc->sysmon_name,\n\t\t\t\t\t      desc->ssctl_id);\n\tif (IS_ERR(adsp->sysmon)) {\n\t\tret = PTR_ERR(adsp->sysmon);\n\t\tgoto detach_proxy_pds;\n\t}\n\n\tqcom_add_ssr_subdev(rproc, &adsp->ssr_subdev, desc->ssr_name);\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto detach_proxy_pds;\n\n\treturn 0;\n\ndetach_proxy_pds:\n\tadsp_pds_detach(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\nfree_rproc:\n\tdevice_init_wakeup(adsp->dev, false);\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void adsp_remove(struct platform_device *pdev)\n{\n\tstruct qcom_adsp *adsp = platform_get_drvdata(pdev);\n\n\trproc_del(adsp->rproc);\n\n\tqcom_q6v5_deinit(&adsp->q6v5);\n\tadsp_unassign_memory_region(adsp);\n\tqcom_remove_glink_subdev(adsp->rproc, &adsp->glink_subdev);\n\tqcom_remove_sysmon_subdev(adsp->sysmon);\n\tqcom_remove_smd_subdev(adsp->rproc, &adsp->smd_subdev);\n\tqcom_remove_ssr_subdev(adsp->rproc, &adsp->ssr_subdev);\n\tadsp_pds_detach(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n\tdevice_init_wakeup(adsp->dev, false);\n\trproc_free(adsp->rproc);\n}\n\nstatic const struct adsp_data adsp_resource_init = {\n\t\t.crash_reason_smem = 423,\n\t\t.firmware_name = \"adsp.mdt\",\n\t\t.pas_id = 1,\n\t\t.auto_boot = true,\n\t\t.ssr_name = \"lpass\",\n\t\t.sysmon_name = \"adsp\",\n\t\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sdm845_adsp_resource_init = {\n\t\t.crash_reason_smem = 423,\n\t\t.firmware_name = \"adsp.mdt\",\n\t\t.pas_id = 1,\n\t\t.auto_boot = true,\n\t\t.load_state = \"adsp\",\n\t\t.ssr_name = \"lpass\",\n\t\t.sysmon_name = \"adsp\",\n\t\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sm6350_adsp_resource = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.mdt\",\n\t.pas_id = 1,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"lcx\",\n\t\t\"lmx\",\n\t\tNULL\n\t},\n\t.load_state = \"adsp\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sm8150_adsp_resource = {\n\t\t.crash_reason_smem = 423,\n\t\t.firmware_name = \"adsp.mdt\",\n\t\t.pas_id = 1,\n\t\t.auto_boot = true,\n\t\t.proxy_pd_names = (char*[]){\n\t\t\t\"cx\",\n\t\t\tNULL\n\t\t},\n\t\t.load_state = \"adsp\",\n\t\t.ssr_name = \"lpass\",\n\t\t.sysmon_name = \"adsp\",\n\t\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sm8250_adsp_resource = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.mdt\",\n\t.pas_id = 1,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"lcx\",\n\t\t\"lmx\",\n\t\tNULL\n\t},\n\t.load_state = \"adsp\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sm8350_adsp_resource = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.mdt\",\n\t.pas_id = 1,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"lcx\",\n\t\t\"lmx\",\n\t\tNULL\n\t},\n\t.load_state = \"adsp\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data msm8996_adsp_resource = {\n\t\t.crash_reason_smem = 423,\n\t\t.firmware_name = \"adsp.mdt\",\n\t\t.pas_id = 1,\n\t\t.auto_boot = true,\n\t\t.proxy_pd_names = (char*[]){\n\t\t\t\"cx\",\n\t\t\tNULL\n\t\t},\n\t\t.ssr_name = \"lpass\",\n\t\t.sysmon_name = \"adsp\",\n\t\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data cdsp_resource_init = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sdm845_cdsp_resource_init = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sm6350_cdsp_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mx\",\n\t\tNULL\n\t},\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sm8150_cdsp_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sm8250_cdsp_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sc8280xp_nsp0_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"nsp\",\n\t\tNULL\n\t},\n\t.ssr_name = \"cdsp0\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sc8280xp_nsp1_resource = {\n\t.crash_reason_smem = 633,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 30,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"nsp\",\n\t\tNULL\n\t},\n\t.ssr_name = \"cdsp1\",\n\t.sysmon_name = \"cdsp1\",\n\t.ssctl_id = 0x20,\n};\n\nstatic const struct adsp_data sm8350_cdsp_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.pas_id = 18,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mxc\",\n\t\tNULL\n\t},\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data mpss_resource_init = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"modem.mdt\",\n\t.pas_id = 4,\n\t.minidump_id = 3,\n\t.auto_boot = false,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.load_state = \"modem\",\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"modem\",\n\t.ssctl_id = 0x12,\n};\n\nstatic const struct adsp_data sc8180x_mpss_resource = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"modem.mdt\",\n\t.pas_id = 4,\n\t.auto_boot = false,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.load_state = \"modem\",\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"modem\",\n\t.ssctl_id = 0x12,\n};\n\nstatic const struct adsp_data msm8996_slpi_resource_init = {\n\t\t.crash_reason_smem = 424,\n\t\t.firmware_name = \"slpi.mdt\",\n\t\t.pas_id = 12,\n\t\t.auto_boot = true,\n\t\t.proxy_pd_names = (char*[]){\n\t\t\t\"ssc_cx\",\n\t\t\tNULL\n\t\t},\n\t\t.ssr_name = \"dsps\",\n\t\t.sysmon_name = \"slpi\",\n\t\t.ssctl_id = 0x16,\n};\n\nstatic const struct adsp_data sdm845_slpi_resource_init = {\n\t\t.crash_reason_smem = 424,\n\t\t.firmware_name = \"slpi.mdt\",\n\t\t.pas_id = 12,\n\t\t.auto_boot = true,\n\t\t.proxy_pd_names = (char*[]){\n\t\t\t\"lcx\",\n\t\t\t\"lmx\",\n\t\t\tNULL\n\t\t},\n\t\t.load_state = \"slpi\",\n\t\t.ssr_name = \"dsps\",\n\t\t.sysmon_name = \"slpi\",\n\t\t.ssctl_id = 0x16,\n};\n\nstatic const struct adsp_data wcss_resource_init = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"wcnss.mdt\",\n\t.pas_id = 6,\n\t.auto_boot = true,\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"wcnss\",\n\t.ssctl_id = 0x12,\n};\n\nstatic const struct adsp_data sdx55_mpss_resource = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"modem.mdt\",\n\t.pas_id = 4,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"modem\",\n\t.ssctl_id = 0x22,\n};\n\nstatic const struct adsp_data sm8450_mpss_resource = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"modem.mdt\",\n\t.pas_id = 4,\n\t.minidump_id = 3,\n\t.auto_boot = false,\n\t.decrypt_shutdown = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.load_state = \"modem\",\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"modem\",\n\t.ssctl_id = 0x12,\n};\n\nstatic const struct adsp_data sm8550_adsp_resource = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.mdt\",\n\t.dtb_firmware_name = \"adsp_dtb.mdt\",\n\t.pas_id = 1,\n\t.dtb_pas_id = 0x24,\n\t.minidump_id = 5,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"lcx\",\n\t\t\"lmx\",\n\t\tNULL\n\t},\n\t.load_state = \"adsp\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n};\n\nstatic const struct adsp_data sm8550_cdsp_resource = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.dtb_firmware_name = \"cdsp_dtb.mdt\",\n\t.pas_id = 18,\n\t.dtb_pas_id = 0x25,\n\t.minidump_id = 7,\n\t.auto_boot = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mxc\",\n\t\t\"nsp\",\n\t\tNULL\n\t},\n\t.load_state = \"cdsp\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n};\n\nstatic const struct adsp_data sm8550_mpss_resource = {\n\t.crash_reason_smem = 421,\n\t.firmware_name = \"modem.mdt\",\n\t.dtb_firmware_name = \"modem_dtb.mdt\",\n\t.pas_id = 4,\n\t.dtb_pas_id = 0x26,\n\t.minidump_id = 3,\n\t.auto_boot = false,\n\t.decrypt_shutdown = true,\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.load_state = \"modem\",\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"modem\",\n\t.ssctl_id = 0x12,\n\t.region_assign_idx = 2,\n};\n\nstatic const struct of_device_id adsp_of_match[] = {\n\t{ .compatible = \"qcom,msm8226-adsp-pil\", .data = &adsp_resource_init},\n\t{ .compatible = \"qcom,msm8953-adsp-pil\", .data = &msm8996_adsp_resource},\n\t{ .compatible = \"qcom,msm8974-adsp-pil\", .data = &adsp_resource_init},\n\t{ .compatible = \"qcom,msm8996-adsp-pil\", .data = &msm8996_adsp_resource},\n\t{ .compatible = \"qcom,msm8996-slpi-pil\", .data = &msm8996_slpi_resource_init},\n\t{ .compatible = \"qcom,msm8998-adsp-pas\", .data = &msm8996_adsp_resource},\n\t{ .compatible = \"qcom,msm8998-slpi-pas\", .data = &msm8996_slpi_resource_init},\n\t{ .compatible = \"qcom,qcs404-adsp-pas\", .data = &adsp_resource_init },\n\t{ .compatible = \"qcom,qcs404-cdsp-pas\", .data = &cdsp_resource_init },\n\t{ .compatible = \"qcom,qcs404-wcss-pas\", .data = &wcss_resource_init },\n\t{ .compatible = \"qcom,sc7180-mpss-pas\", .data = &mpss_resource_init},\n\t{ .compatible = \"qcom,sc7280-mpss-pas\", .data = &mpss_resource_init},\n\t{ .compatible = \"qcom,sc8180x-adsp-pas\", .data = &sm8150_adsp_resource},\n\t{ .compatible = \"qcom,sc8180x-cdsp-pas\", .data = &sm8150_cdsp_resource},\n\t{ .compatible = \"qcom,sc8180x-mpss-pas\", .data = &sc8180x_mpss_resource},\n\t{ .compatible = \"qcom,sc8280xp-adsp-pas\", .data = &sm8250_adsp_resource},\n\t{ .compatible = \"qcom,sc8280xp-nsp0-pas\", .data = &sc8280xp_nsp0_resource},\n\t{ .compatible = \"qcom,sc8280xp-nsp1-pas\", .data = &sc8280xp_nsp1_resource},\n\t{ .compatible = \"qcom,sdm660-adsp-pas\", .data = &adsp_resource_init},\n\t{ .compatible = \"qcom,sdm845-adsp-pas\", .data = &sdm845_adsp_resource_init},\n\t{ .compatible = \"qcom,sdm845-cdsp-pas\", .data = &sdm845_cdsp_resource_init},\n\t{ .compatible = \"qcom,sdm845-slpi-pas\", .data = &sdm845_slpi_resource_init},\n\t{ .compatible = \"qcom,sdx55-mpss-pas\", .data = &sdx55_mpss_resource},\n\t{ .compatible = \"qcom,sm6115-adsp-pas\", .data = &adsp_resource_init},\n\t{ .compatible = \"qcom,sm6115-cdsp-pas\", .data = &cdsp_resource_init},\n\t{ .compatible = \"qcom,sm6115-mpss-pas\", .data = &sc8180x_mpss_resource},\n\t{ .compatible = \"qcom,sm6350-adsp-pas\", .data = &sm6350_adsp_resource},\n\t{ .compatible = \"qcom,sm6350-cdsp-pas\", .data = &sm6350_cdsp_resource},\n\t{ .compatible = \"qcom,sm6350-mpss-pas\", .data = &mpss_resource_init},\n\t{ .compatible = \"qcom,sm8150-adsp-pas\", .data = &sm8150_adsp_resource},\n\t{ .compatible = \"qcom,sm8150-cdsp-pas\", .data = &sm8150_cdsp_resource},\n\t{ .compatible = \"qcom,sm8150-mpss-pas\", .data = &mpss_resource_init},\n\t{ .compatible = \"qcom,sm8150-slpi-pas\", .data = &sdm845_slpi_resource_init},\n\t{ .compatible = \"qcom,sm8250-adsp-pas\", .data = &sm8250_adsp_resource},\n\t{ .compatible = \"qcom,sm8250-cdsp-pas\", .data = &sm8250_cdsp_resource},\n\t{ .compatible = \"qcom,sm8250-slpi-pas\", .data = &sdm845_slpi_resource_init},\n\t{ .compatible = \"qcom,sm8350-adsp-pas\", .data = &sm8350_adsp_resource},\n\t{ .compatible = \"qcom,sm8350-cdsp-pas\", .data = &sm8350_cdsp_resource},\n\t{ .compatible = \"qcom,sm8350-slpi-pas\", .data = &sdm845_slpi_resource_init},\n\t{ .compatible = \"qcom,sm8350-mpss-pas\", .data = &mpss_resource_init},\n\t{ .compatible = \"qcom,sm8450-adsp-pas\", .data = &sm8350_adsp_resource},\n\t{ .compatible = \"qcom,sm8450-cdsp-pas\", .data = &sm8350_cdsp_resource},\n\t{ .compatible = \"qcom,sm8450-slpi-pas\", .data = &sdm845_slpi_resource_init},\n\t{ .compatible = \"qcom,sm8450-mpss-pas\", .data = &sm8450_mpss_resource},\n\t{ .compatible = \"qcom,sm8550-adsp-pas\", .data = &sm8550_adsp_resource},\n\t{ .compatible = \"qcom,sm8550-cdsp-pas\", .data = &sm8550_cdsp_resource},\n\t{ .compatible = \"qcom,sm8550-mpss-pas\", .data = &sm8550_mpss_resource},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adsp_of_match);\n\nstatic struct platform_driver adsp_driver = {\n\t.probe = adsp_probe,\n\t.remove_new = adsp_remove,\n\t.driver = {\n\t\t.name = \"qcom_q6v5_pas\",\n\t\t.of_match_table = adsp_of_match,\n\t},\n};\n\nmodule_platform_driver(adsp_driver);\nMODULE_DESCRIPTION(\"Qualcomm Hexagon v5 Peripheral Authentication Service driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}