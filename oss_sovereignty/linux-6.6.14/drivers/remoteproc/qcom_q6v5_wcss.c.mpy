{
  "module_name": "qcom_q6v5_wcss.c",
  "hash_id": "b7daea3b2cf62585ccd962812b62afce0d5fe673c10a250661ca4fb6abcf9024",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_q6v5_wcss.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include \"qcom_common.h\"\n#include \"qcom_pil_info.h\"\n#include \"qcom_q6v5.h\"\n\n#define WCSS_CRASH_REASON\t\t421\n\n \n#define Q6SS_RESET_REG\t\t0x014\n#define Q6SS_GFMUX_CTL_REG\t\t0x020\n#define Q6SS_PWR_CTL_REG\t\t0x030\n#define Q6SS_MEM_PWR_CTL\t\t0x0B0\n#define Q6SS_STRAP_ACC\t\t\t0x110\n#define Q6SS_CGC_OVERRIDE\t\t0x034\n#define Q6SS_BCR_REG\t\t\t0x6000\n\n \n#define AXI_HALTREQ_REG\t\t\t0x0\n#define AXI_HALTACK_REG\t\t\t0x4\n#define AXI_IDLE_REG\t\t\t0x8\n\n#define HALT_ACK_TIMEOUT_MS\t\t100\n\n \n#define Q6SS_STOP_CORE\t\t\tBIT(0)\n#define Q6SS_CORE_ARES\t\t\tBIT(1)\n#define Q6SS_BUS_ARES_ENABLE\t\tBIT(2)\n\n \n#define Q6SS_BRC_BLK_ARES\t\tBIT(0)\n\n \n#define Q6SS_CLK_ENABLE\t\t\tBIT(1)\n#define Q6SS_SWITCH_CLK_SRC\t\tBIT(8)\n\n \n#define Q6SS_L2DATA_STBY_N\t\tBIT(18)\n#define Q6SS_SLP_RET_N\t\t\tBIT(19)\n#define Q6SS_CLAMP_IO\t\t\tBIT(20)\n#define QDSS_BHS_ON\t\t\tBIT(21)\n#define QDSS_Q6_MEMORIES\t\tGENMASK(15, 0)\n\n \n#define Q6SS_LDO_BYP\t\tBIT(25)\n#define Q6SS_BHS_ON\t\tBIT(24)\n#define Q6SS_CLAMP_WL\t\tBIT(21)\n#define Q6SS_CLAMP_QMC_MEM\t\tBIT(22)\n#define HALT_CHECK_MAX_LOOPS\t\t200\n#define Q6SS_XO_CBCR\t\tGENMASK(5, 3)\n#define Q6SS_SLEEP_CBCR\t\tGENMASK(5, 2)\n\n \n#define TCSR_GLOBAL_CFG0\t0x0\n#define TCSR_GLOBAL_CFG1\t0x4\n#define SSCAON_CONFIG\t\t0x8\n#define SSCAON_STATUS\t\t0xc\n#define Q6SS_BHS_STATUS\t\t0x78\n#define Q6SS_RST_EVB\t\t0x10\n\n#define BHS_EN_REST_ACK\t\tBIT(0)\n#define SSCAON_ENABLE\t\tBIT(13)\n#define SSCAON_BUS_EN\t\tBIT(15)\n#define SSCAON_BUS_MUX_MASK\tGENMASK(18, 16)\n\n#define MEM_BANKS\t\t19\n#define TCSR_WCSS_CLK_MASK\t0x1F\n#define TCSR_WCSS_CLK_ENABLE\t0x14\n\n#define MAX_HALT_REG\t\t3\nenum {\n\tWCSS_IPQ8074,\n\tWCSS_QCS404,\n};\n\nstruct wcss_data {\n\tconst char *firmware_name;\n\tunsigned int crash_reason_smem;\n\tu32 version;\n\tbool aon_reset_required;\n\tbool wcss_q6_reset_required;\n\tconst char *ssr_name;\n\tconst char *sysmon_name;\n\tint ssctl_id;\n\tconst struct rproc_ops *ops;\n\tbool requires_force_stop;\n};\n\nstruct q6v5_wcss {\n\tstruct device *dev;\n\n\tvoid __iomem *reg_base;\n\tvoid __iomem *rmb_base;\n\n\tstruct regmap *halt_map;\n\tu32 halt_q6;\n\tu32 halt_wcss;\n\tu32 halt_nc;\n\n\tstruct clk *xo;\n\tstruct clk *ahbfabric_cbcr_clk;\n\tstruct clk *gcc_abhs_cbcr;\n\tstruct clk *gcc_axim_cbcr;\n\tstruct clk *lcc_csr_cbcr;\n\tstruct clk *ahbs_cbcr;\n\tstruct clk *tcm_slave_cbcr;\n\tstruct clk *qdsp6ss_abhm_cbcr;\n\tstruct clk *qdsp6ss_sleep_cbcr;\n\tstruct clk *qdsp6ss_axim_cbcr;\n\tstruct clk *qdsp6ss_xo_cbcr;\n\tstruct clk *qdsp6ss_core_gfmux;\n\tstruct clk *lcc_bcr_sleep;\n\tstruct regulator *cx_supply;\n\tstruct qcom_sysmon *sysmon;\n\n\tstruct reset_control *wcss_aon_reset;\n\tstruct reset_control *wcss_reset;\n\tstruct reset_control *wcss_q6_reset;\n\tstruct reset_control *wcss_q6_bcr_reset;\n\n\tstruct qcom_q6v5 q6v5;\n\n\tphys_addr_t mem_phys;\n\tphys_addr_t mem_reloc;\n\tvoid *mem_region;\n\tsize_t mem_size;\n\n\tunsigned int crash_reason_smem;\n\tu32 version;\n\tbool requires_force_stop;\n\n\tstruct qcom_rproc_glink glink_subdev;\n\tstruct qcom_rproc_ssr ssr_subdev;\n};\n\nstatic int q6v5_wcss_reset(struct q6v5_wcss *wcss)\n{\n\tint ret;\n\tu32 val;\n\tint i;\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval |= Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_XO_CBCR);\n\tval |= 0x1;\n\twritel(val, wcss->reg_base + Q6SS_XO_CBCR);\n\n\t \n\tret = readl_poll_timeout(wcss->reg_base + Q6SS_XO_CBCR,\n\t\t\t\t val, !(val & BIT(31)), 1,\n\t\t\t\t HALT_CHECK_MAX_LOOPS);\n\tif (ret) {\n\t\tdev_err(wcss->dev,\n\t\t\t\"xo cbcr enabling timed out (rc:%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval |= Q6SS_BHS_ON;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tudelay(1);\n\n\t \n\tval |= Q6SS_LDO_BYP;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval &= ~Q6SS_CLAMP_QMC_MEM;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval |= Q6SS_L2DATA_STBY_N | Q6SS_SLP_RET_N;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\tfor (i = MEM_BANKS; i >= 0; i--) {\n\t\tval |= BIT(i);\n\t\twritel(val, wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\t\t \n\t\tval |= readl(wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\t\tudelay(1);\n\t}\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval &= ~Q6SS_CLAMP_WL;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval &= ~Q6SS_CLAMP_IO;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval &= ~Q6SS_CORE_ARES;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tval |= Q6SS_CLK_ENABLE;\n\twritel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval &= ~Q6SS_STOP_CORE;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_start(struct rproc *rproc)\n{\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\tint ret;\n\n\tqcom_q6v5_prepare(&wcss->q6v5);\n\n\t \n\tret = reset_control_deassert(wcss->wcss_reset);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"wcss_reset failed\\n\");\n\t\treturn ret;\n\t}\n\n\tret = reset_control_deassert(wcss->wcss_q6_reset);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"wcss_q6_reset failed\\n\");\n\t\tgoto wcss_reset;\n\t}\n\n\t \n\tret = regmap_update_bits(wcss->halt_map,\n\t\t\t\t wcss->halt_nc + TCSR_GLOBAL_CFG0,\n\t\t\t\t TCSR_WCSS_CLK_MASK,\n\t\t\t\t TCSR_WCSS_CLK_ENABLE);\n\tif (ret)\n\t\tgoto wcss_q6_reset;\n\n\tret = regmap_update_bits(wcss->halt_map,\n\t\t\t\t wcss->halt_nc + TCSR_GLOBAL_CFG1,\n\t\t\t\t 1, 0);\n\tif (ret)\n\t\tgoto wcss_q6_reset;\n\n\t \n\twritel(rproc->bootaddr >> 4, wcss->reg_base + Q6SS_RST_EVB);\n\n\tret = q6v5_wcss_reset(wcss);\n\tif (ret)\n\t\tgoto wcss_q6_reset;\n\n\tret = qcom_q6v5_wait_for_start(&wcss->q6v5, 5 * HZ);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(wcss->dev, \"start timed out\\n\");\n\n\treturn ret;\n\nwcss_q6_reset:\n\treset_control_assert(wcss->wcss_q6_reset);\n\nwcss_reset:\n\treset_control_assert(wcss->wcss_reset);\n\n\treturn ret;\n}\n\nstatic int q6v5_wcss_qcs404_power_on(struct q6v5_wcss *wcss)\n{\n\tunsigned long val;\n\tint ret, idx;\n\n\t \n\treset_control_assert(wcss->wcss_reset);\n\tusleep_range(200, 300);\n\treset_control_deassert(wcss->wcss_reset);\n\tusleep_range(200, 300);\n\n\t \n\tret = clk_prepare_enable(wcss->gcc_abhs_cbcr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treset_control_deassert(wcss->wcss_q6_bcr_reset);\n\n\t \n\tret = clk_prepare_enable(wcss->ahbfabric_cbcr_clk);\n\tif (ret)\n\t\tgoto disable_gcc_abhs_cbcr_clk;\n\n\t \n\tret = clk_prepare_enable(wcss->lcc_csr_cbcr);\n\tif (ret)\n\t\tgoto disable_ahbfabric_cbcr_clk;\n\n\t \n\tret = clk_prepare_enable(wcss->ahbs_cbcr);\n\tif (ret)\n\t\tgoto disable_csr_cbcr_clk;\n\n\t \n\tret = clk_prepare_enable(wcss->tcm_slave_cbcr);\n\tif (ret)\n\t\tgoto disable_ahbs_cbcr_clk;\n\n\t \n\tret = clk_prepare_enable(wcss->qdsp6ss_abhm_cbcr);\n\tif (ret)\n\t\tgoto disable_tcm_slave_cbcr_clk;\n\n\t \n\tret = clk_prepare_enable(wcss->qdsp6ss_axim_cbcr);\n\tif (ret)\n\t\tgoto disable_abhm_cbcr_clk;\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_XO_CBCR);\n\tval |= BIT(0);\n\twritel(val, wcss->reg_base + Q6SS_XO_CBCR);\n\t \n\tret = readl_poll_timeout(wcss->reg_base + Q6SS_XO_CBCR,\n\t\t\t\t val, !(val & BIT(31)), 1,\n\t\t\t\t HALT_CHECK_MAX_LOOPS);\n\tif (ret) {\n\t\tdev_err(wcss->dev,\n\t\t\t\"xo cbcr enabling timed out (rc:%d)\\n\", ret);\n\t\tgoto disable_xo_cbcr_clk;\n\t}\n\n\twritel(0, wcss->reg_base + Q6SS_CGC_OVERRIDE);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);\n\tval |= BIT(0);\n\twritel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);\n\n\t \n\tret = clk_prepare_enable(wcss->gcc_axim_cbcr);\n\tif (ret)\n\t\tgoto disable_sleep_cbcr_clk;\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval |= Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\t \n\twritel(0x01700000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\twritel(0x03700000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\twritel(0x03300000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\twritel(0x033C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tfor (idx = 28; idx >= 0; idx--) {\n\t\twritel((readl(wcss->reg_base + Q6SS_MEM_PWR_CTL) |\n\t\t\t(1 << idx)), wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\t}\n\n\twritel(0x031C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\twritel(0x030C0000, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval &= ~Q6SS_CORE_ARES;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tval |= Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC;\n\twritel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\n\t \n\tret = clk_prepare_enable(wcss->lcc_bcr_sleep);\n\tif (ret)\n\t\tgoto disable_core_gfmux_clk;\n\n\treturn 0;\n\ndisable_core_gfmux_clk:\n\tval = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tval &= ~(Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC);\n\twritel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tclk_disable_unprepare(wcss->gcc_axim_cbcr);\ndisable_sleep_cbcr_clk:\n\tval = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);\n\tval &= ~Q6SS_CLK_ENABLE;\n\twritel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);\ndisable_xo_cbcr_clk:\n\tval = readl(wcss->reg_base + Q6SS_XO_CBCR);\n\tval &= ~Q6SS_CLK_ENABLE;\n\twritel(val, wcss->reg_base + Q6SS_XO_CBCR);\n\tclk_disable_unprepare(wcss->qdsp6ss_axim_cbcr);\ndisable_abhm_cbcr_clk:\n\tclk_disable_unprepare(wcss->qdsp6ss_abhm_cbcr);\ndisable_tcm_slave_cbcr_clk:\n\tclk_disable_unprepare(wcss->tcm_slave_cbcr);\ndisable_ahbs_cbcr_clk:\n\tclk_disable_unprepare(wcss->ahbs_cbcr);\ndisable_csr_cbcr_clk:\n\tclk_disable_unprepare(wcss->lcc_csr_cbcr);\ndisable_ahbfabric_cbcr_clk:\n\tclk_disable_unprepare(wcss->ahbfabric_cbcr_clk);\ndisable_gcc_abhs_cbcr_clk:\n\tclk_disable_unprepare(wcss->gcc_abhs_cbcr);\n\n\treturn ret;\n}\n\nstatic inline int q6v5_wcss_qcs404_reset(struct q6v5_wcss *wcss)\n{\n\tunsigned long val;\n\n\twritel(0x80800000, wcss->reg_base + Q6SS_STRAP_ACC);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_RESET_REG);\n\tval &= ~Q6SS_STOP_CORE;\n\twritel(val, wcss->reg_base + Q6SS_RESET_REG);\n\n\treturn 0;\n}\n\nstatic int q6v5_qcs404_wcss_start(struct rproc *rproc)\n{\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\tint ret;\n\n\tret = clk_prepare_enable(wcss->xo);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(wcss->cx_supply);\n\tif (ret)\n\t\tgoto disable_xo_clk;\n\n\tqcom_q6v5_prepare(&wcss->q6v5);\n\n\tret = q6v5_wcss_qcs404_power_on(wcss);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"wcss clk_enable failed\\n\");\n\t\tgoto disable_cx_supply;\n\t}\n\n\twritel(rproc->bootaddr >> 4, wcss->reg_base + Q6SS_RST_EVB);\n\n\tq6v5_wcss_qcs404_reset(wcss);\n\n\tret = qcom_q6v5_wait_for_start(&wcss->q6v5, 5 * HZ);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(wcss->dev, \"start timed out\\n\");\n\t\tgoto disable_cx_supply;\n\t}\n\n\treturn 0;\n\ndisable_cx_supply:\n\tregulator_disable(wcss->cx_supply);\ndisable_xo_clk:\n\tclk_disable_unprepare(wcss->xo);\n\n\treturn ret;\n}\n\nstatic void q6v5_wcss_halt_axi_port(struct q6v5_wcss *wcss,\n\t\t\t\t    struct regmap *halt_map,\n\t\t\t\t    u32 offset)\n{\n\tunsigned long timeout;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\n\tif (!ret && val)\n\t\treturn;\n\n\t \n\tregmap_write(halt_map, offset + AXI_HALTREQ_REG, 1);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(HALT_ACK_TIMEOUT_MS);\n\tfor (;;) {\n\t\tret = regmap_read(halt_map, offset + AXI_HALTACK_REG, &val);\n\t\tif (ret || val || time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\tmsleep(1);\n\t}\n\n\tret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\n\tif (ret || !val)\n\t\tdev_err(wcss->dev, \"port failed halt\\n\");\n\n\t \n\tregmap_write(halt_map, offset + AXI_HALTREQ_REG, 0);\n}\n\nstatic int q6v5_qcs404_wcss_shutdown(struct q6v5_wcss *wcss)\n{\n\tunsigned long val;\n\tint ret;\n\n\tq6v5_wcss_halt_axi_port(wcss, wcss->halt_map, wcss->halt_wcss);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval |= (Q6SS_CLAMP_IO | Q6SS_CLAMP_WL | Q6SS_CLAMP_QMC_MEM);\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\twritel((readl(wcss->reg_base + Q6SS_MEM_PWR_CTL) &\n\t\t~QDSS_Q6_MEMORIES),\n\t\twcss->reg_base + Q6SS_MEM_PWR_CTL);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval &= ~Q6SS_BHS_ON;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\tclk_disable_unprepare(wcss->ahbfabric_cbcr_clk);\n\tclk_disable_unprepare(wcss->lcc_csr_cbcr);\n\tclk_disable_unprepare(wcss->tcm_slave_cbcr);\n\tclk_disable_unprepare(wcss->qdsp6ss_abhm_cbcr);\n\tclk_disable_unprepare(wcss->qdsp6ss_axim_cbcr);\n\n\tval = readl(wcss->reg_base + Q6SS_SLEEP_CBCR);\n\tval &= ~BIT(0);\n\twritel(val, wcss->reg_base + Q6SS_SLEEP_CBCR);\n\n\tval = readl(wcss->reg_base + Q6SS_XO_CBCR);\n\tval &= ~BIT(0);\n\twritel(val, wcss->reg_base + Q6SS_XO_CBCR);\n\n\tclk_disable_unprepare(wcss->ahbs_cbcr);\n\tclk_disable_unprepare(wcss->lcc_bcr_sleep);\n\n\tval = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tval &= ~(Q6SS_CLK_ENABLE | Q6SS_SWITCH_CLK_SRC);\n\twritel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\n\tclk_disable_unprepare(wcss->gcc_abhs_cbcr);\n\n\tret = reset_control_assert(wcss->wcss_reset);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"wcss_reset failed\\n\");\n\t\treturn ret;\n\t}\n\tusleep_range(200, 300);\n\n\tret = reset_control_deassert(wcss->wcss_reset);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"wcss_reset failed\\n\");\n\t\treturn ret;\n\t}\n\tusleep_range(200, 300);\n\n\tclk_disable_unprepare(wcss->gcc_axim_cbcr);\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_powerdown(struct q6v5_wcss *wcss)\n{\n\tint ret;\n\tu32 val;\n\n\t \n\tq6v5_wcss_halt_axi_port(wcss, wcss->halt_map, wcss->halt_wcss);\n\n\t \n\tval = readl(wcss->rmb_base + SSCAON_CONFIG);\n\tval |= SSCAON_ENABLE;\n\twritel(val, wcss->rmb_base + SSCAON_CONFIG);\n\n\t \n\tval |= SSCAON_BUS_EN;\n\tval &= ~SSCAON_BUS_MUX_MASK;\n\twritel(val, wcss->rmb_base + SSCAON_CONFIG);\n\n\t \n\tval |= BIT(1);\n\twritel(val, wcss->rmb_base + SSCAON_CONFIG);\n\n\t \n\tret = readl_poll_timeout(wcss->rmb_base + SSCAON_STATUS,\n\t\t\t\t val, (val & 0xffff) == 0x400, 1000,\n\t\t\t\t HALT_CHECK_MAX_LOOPS);\n\tif (ret) {\n\t\tdev_err(wcss->dev,\n\t\t\t\"can't get SSCAON_STATUS rc:%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treset_control_assert(wcss->wcss_aon_reset);\n\n\t \n\tval = readl(wcss->rmb_base + SSCAON_CONFIG);\n\tval &= ~SSCAON_ENABLE;\n\twritel(val, wcss->rmb_base + SSCAON_CONFIG);\n\n\t \n\treset_control_assert(wcss->wcss_reset);\n\n\treturn 0;\n}\n\nstatic int q6v5_q6_powerdown(struct q6v5_wcss *wcss)\n{\n\tint ret;\n\tu32 val;\n\tint i;\n\n\t \n\tq6v5_wcss_halt_axi_port(wcss, wcss->halt_map, wcss->halt_q6);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\tval &= ~Q6SS_CLK_ENABLE;\n\twritel(val, wcss->reg_base + Q6SS_GFMUX_CTL_REG);\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval |= Q6SS_CLAMP_IO;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval |= QDSS_BHS_ON;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval &= ~Q6SS_L2DATA_STBY_N;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval &= ~Q6SS_SLP_RET_N;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tfor (i = 0; i < 20; i++) {\n\t\tval = readl(wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\t\tval &= ~BIT(i);\n\t\twritel(val, wcss->reg_base + Q6SS_MEM_PWR_CTL);\n\t\tmdelay(1);\n\t}\n\n\t \n\tval = readl(wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tval |= Q6SS_CLAMP_QMC_MEM;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\n\t \n\tval &= ~Q6SS_BHS_ON;\n\twritel(val, wcss->reg_base + Q6SS_PWR_CTL_REG);\n\tudelay(1);\n\n\t \n\tret = readl_poll_timeout(wcss->reg_base + Q6SS_BHS_STATUS,\n\t\t\t\t val, !(val & BHS_EN_REST_ACK), 1000,\n\t\t\t\t HALT_CHECK_MAX_LOOPS);\n\tif (ret) {\n\t\tdev_err(wcss->dev, \"BHS_STATUS not OFF (rc:%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\treset_control_assert(wcss->wcss_reset);\n\n\t \n\treset_control_assert(wcss->wcss_q6_reset);\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_stop(struct rproc *rproc)\n{\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\tint ret;\n\n\t \n\tif (wcss->requires_force_stop) {\n\t\tret = qcom_q6v5_request_stop(&wcss->q6v5, NULL);\n\t\tif (ret == -ETIMEDOUT) {\n\t\t\tdev_err(wcss->dev, \"timed out on wait\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (wcss->version == WCSS_QCS404) {\n\t\tret = q6v5_qcs404_wcss_shutdown(wcss);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = q6v5_wcss_powerdown(wcss);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = q6v5_q6_powerdown(wcss);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tqcom_q6v5_unprepare(&wcss->q6v5);\n\n\treturn 0;\n}\n\nstatic void *q6v5_wcss_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\tint offset;\n\n\toffset = da - wcss->mem_reloc;\n\tif (offset < 0 || offset + len > wcss->mem_size)\n\t\treturn NULL;\n\n\treturn wcss->mem_region + offset;\n}\n\nstatic int q6v5_wcss_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\tint ret;\n\n\tret = qcom_mdt_load_no_init(wcss->dev, fw, rproc->firmware,\n\t\t\t\t    0, wcss->mem_region, wcss->mem_phys,\n\t\t\t\t    wcss->mem_size, &wcss->mem_reloc);\n\tif (ret)\n\t\treturn ret;\n\n\tqcom_pil_info_store(\"wcnss\", wcss->mem_phys, wcss->mem_size);\n\n\treturn ret;\n}\n\nstatic const struct rproc_ops q6v5_wcss_ipq8074_ops = {\n\t.start = q6v5_wcss_start,\n\t.stop = q6v5_wcss_stop,\n\t.da_to_va = q6v5_wcss_da_to_va,\n\t.load = q6v5_wcss_load,\n\t.get_boot_addr = rproc_elf_get_boot_addr,\n};\n\nstatic const struct rproc_ops q6v5_wcss_qcs404_ops = {\n\t.start = q6v5_qcs404_wcss_start,\n\t.stop = q6v5_wcss_stop,\n\t.da_to_va = q6v5_wcss_da_to_va,\n\t.load = q6v5_wcss_load,\n\t.get_boot_addr = rproc_elf_get_boot_addr,\n\t.parse_fw = qcom_register_dump_segments,\n};\n\nstatic int q6v5_wcss_init_reset(struct q6v5_wcss *wcss,\n\t\t\t\tconst struct wcss_data *desc)\n{\n\tstruct device *dev = wcss->dev;\n\n\tif (desc->aon_reset_required) {\n\t\twcss->wcss_aon_reset = devm_reset_control_get_exclusive(dev, \"wcss_aon_reset\");\n\t\tif (IS_ERR(wcss->wcss_aon_reset)) {\n\t\t\tdev_err(wcss->dev, \"fail to acquire wcss_aon_reset\\n\");\n\t\t\treturn PTR_ERR(wcss->wcss_aon_reset);\n\t\t}\n\t}\n\n\twcss->wcss_reset = devm_reset_control_get_exclusive(dev, \"wcss_reset\");\n\tif (IS_ERR(wcss->wcss_reset)) {\n\t\tdev_err(wcss->dev, \"unable to acquire wcss_reset\\n\");\n\t\treturn PTR_ERR(wcss->wcss_reset);\n\t}\n\n\tif (desc->wcss_q6_reset_required) {\n\t\twcss->wcss_q6_reset = devm_reset_control_get_exclusive(dev, \"wcss_q6_reset\");\n\t\tif (IS_ERR(wcss->wcss_q6_reset)) {\n\t\t\tdev_err(wcss->dev, \"unable to acquire wcss_q6_reset\\n\");\n\t\t\treturn PTR_ERR(wcss->wcss_q6_reset);\n\t\t}\n\t}\n\n\twcss->wcss_q6_bcr_reset = devm_reset_control_get_exclusive(dev, \"wcss_q6_bcr_reset\");\n\tif (IS_ERR(wcss->wcss_q6_bcr_reset)) {\n\t\tdev_err(wcss->dev, \"unable to acquire wcss_q6_bcr_reset\\n\");\n\t\treturn PTR_ERR(wcss->wcss_q6_bcr_reset);\n\t}\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_init_mmio(struct q6v5_wcss *wcss,\n\t\t\t       struct platform_device *pdev)\n{\n\tunsigned int halt_reg[MAX_HALT_REG] = {0};\n\tstruct device_node *syscon;\n\tstruct resource *res;\n\tint ret;\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"qdsp6\");\n\tif (!res)\n\t\treturn -EINVAL;\n\n\twcss->reg_base = devm_ioremap(&pdev->dev, res->start,\n\t\t\t\t      resource_size(res));\n\tif (!wcss->reg_base)\n\t\treturn -ENOMEM;\n\n\tif (wcss->version == WCSS_IPQ8074) {\n\t\twcss->rmb_base = devm_platform_ioremap_resource_byname(pdev, \"rmb\");\n\t\tif (IS_ERR(wcss->rmb_base))\n\t\t\treturn PTR_ERR(wcss->rmb_base);\n\t}\n\n\tsyscon = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t  \"qcom,halt-regs\", 0);\n\tif (!syscon) {\n\t\tdev_err(&pdev->dev, \"failed to parse qcom,halt-regs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twcss->halt_map = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(wcss->halt_map))\n\t\treturn PTR_ERR(wcss->halt_map);\n\n\tret = of_property_read_variable_u32_array(pdev->dev.of_node,\n\t\t\t\t\t\t  \"qcom,halt-regs\",\n\t\t\t\t\t\t  halt_reg, 0,\n\t\t\t\t\t\t  MAX_HALT_REG);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to parse qcom,halt-regs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twcss->halt_q6 = halt_reg[0];\n\twcss->halt_wcss = halt_reg[1];\n\twcss->halt_nc = halt_reg[2];\n\n\treturn 0;\n}\n\nstatic int q6v5_alloc_memory_region(struct q6v5_wcss *wcss)\n{\n\tstruct reserved_mem *rmem = NULL;\n\tstruct device_node *node;\n\tstruct device *dev = wcss->dev;\n\n\tnode = of_parse_phandle(dev->of_node, \"memory-region\", 0);\n\tif (node)\n\t\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\n\tif (!rmem) {\n\t\tdev_err(dev, \"unable to acquire memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twcss->mem_phys = rmem->base;\n\twcss->mem_reloc = rmem->base;\n\twcss->mem_size = rmem->size;\n\twcss->mem_region = devm_ioremap_wc(dev, wcss->mem_phys, wcss->mem_size);\n\tif (!wcss->mem_region) {\n\t\tdev_err(dev, \"unable to map memory region: %pa+%pa\\n\",\n\t\t\t&rmem->base, &rmem->size);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_init_clock(struct q6v5_wcss *wcss)\n{\n\tint ret;\n\n\twcss->xo = devm_clk_get(wcss->dev, \"xo\");\n\tif (IS_ERR(wcss->xo)) {\n\t\tret = PTR_ERR(wcss->xo);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get xo clock\");\n\t\treturn ret;\n\t}\n\n\twcss->gcc_abhs_cbcr = devm_clk_get(wcss->dev, \"gcc_abhs_cbcr\");\n\tif (IS_ERR(wcss->gcc_abhs_cbcr)) {\n\t\tret = PTR_ERR(wcss->gcc_abhs_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get gcc abhs clock\");\n\t\treturn ret;\n\t}\n\n\twcss->gcc_axim_cbcr = devm_clk_get(wcss->dev, \"gcc_axim_cbcr\");\n\tif (IS_ERR(wcss->gcc_axim_cbcr)) {\n\t\tret = PTR_ERR(wcss->gcc_axim_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get gcc axim clock\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->ahbfabric_cbcr_clk = devm_clk_get(wcss->dev,\n\t\t\t\t\t\t\"lcc_ahbfabric_cbc\");\n\tif (IS_ERR(wcss->ahbfabric_cbcr_clk)) {\n\t\tret = PTR_ERR(wcss->ahbfabric_cbcr_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get ahbfabric clock\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->lcc_csr_cbcr = devm_clk_get(wcss->dev, \"tcsr_lcc_cbc\");\n\tif (IS_ERR(wcss->lcc_csr_cbcr)) {\n\t\tret = PTR_ERR(wcss->lcc_csr_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get csr cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->ahbs_cbcr = devm_clk_get(wcss->dev,\n\t\t\t\t       \"lcc_abhs_cbc\");\n\tif (IS_ERR(wcss->ahbs_cbcr)) {\n\t\tret = PTR_ERR(wcss->ahbs_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get ahbs_cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->tcm_slave_cbcr = devm_clk_get(wcss->dev,\n\t\t\t\t\t    \"lcc_tcm_slave_cbc\");\n\tif (IS_ERR(wcss->tcm_slave_cbcr)) {\n\t\tret = PTR_ERR(wcss->tcm_slave_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get tcm cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->qdsp6ss_abhm_cbcr = devm_clk_get(wcss->dev, \"lcc_abhm_cbc\");\n\tif (IS_ERR(wcss->qdsp6ss_abhm_cbcr)) {\n\t\tret = PTR_ERR(wcss->qdsp6ss_abhm_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get abhm cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->qdsp6ss_axim_cbcr = devm_clk_get(wcss->dev, \"lcc_axim_cbc\");\n\tif (IS_ERR(wcss->qdsp6ss_axim_cbcr)) {\n\t\tret = PTR_ERR(wcss->qdsp6ss_axim_cbcr);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get axim cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\twcss->lcc_bcr_sleep = devm_clk_get(wcss->dev, \"lcc_bcr_sleep\");\n\tif (IS_ERR(wcss->lcc_bcr_sleep)) {\n\t\tret = PTR_ERR(wcss->lcc_bcr_sleep);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(wcss->dev, \"failed to get bcr cbcr clk\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_init_regulator(struct q6v5_wcss *wcss)\n{\n\twcss->cx_supply = devm_regulator_get(wcss->dev, \"cx\");\n\tif (IS_ERR(wcss->cx_supply))\n\t\treturn PTR_ERR(wcss->cx_supply);\n\n\tregulator_set_load(wcss->cx_supply, 100000);\n\n\treturn 0;\n}\n\nstatic int q6v5_wcss_probe(struct platform_device *pdev)\n{\n\tconst struct wcss_data *desc;\n\tstruct q6v5_wcss *wcss;\n\tstruct rproc *rproc;\n\tint ret;\n\n\tdesc = device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\trproc = rproc_alloc(&pdev->dev, pdev->name, desc->ops,\n\t\t\t    desc->firmware_name, sizeof(*wcss));\n\tif (!rproc) {\n\t\tdev_err(&pdev->dev, \"failed to allocate rproc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\twcss = rproc->priv;\n\twcss->dev = &pdev->dev;\n\twcss->version = desc->version;\n\n\twcss->version = desc->version;\n\twcss->requires_force_stop = desc->requires_force_stop;\n\n\tret = q6v5_wcss_init_mmio(wcss, pdev);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = q6v5_alloc_memory_region(wcss);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tif (wcss->version == WCSS_QCS404) {\n\t\tret = q6v5_wcss_init_clock(wcss);\n\t\tif (ret)\n\t\t\tgoto free_rproc;\n\n\t\tret = q6v5_wcss_init_regulator(wcss);\n\t\tif (ret)\n\t\t\tgoto free_rproc;\n\t}\n\n\tret = q6v5_wcss_init_reset(wcss, desc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = qcom_q6v5_init(&wcss->q6v5, pdev, rproc, desc->crash_reason_smem, NULL, NULL);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tqcom_add_glink_subdev(rproc, &wcss->glink_subdev, \"q6wcss\");\n\tqcom_add_ssr_subdev(rproc, &wcss->ssr_subdev, \"q6wcss\");\n\n\tif (desc->ssctl_id)\n\t\twcss->sysmon = qcom_add_sysmon_subdev(rproc,\n\t\t\t\t\t\t      desc->sysmon_name,\n\t\t\t\t\t\t      desc->ssctl_id);\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\treturn 0;\n\nfree_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void q6v5_wcss_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct q6v5_wcss *wcss = rproc->priv;\n\n\tqcom_q6v5_deinit(&wcss->q6v5);\n\trproc_del(rproc);\n\trproc_free(rproc);\n}\n\nstatic const struct wcss_data wcss_ipq8074_res_init = {\n\t.firmware_name = \"IPQ8074/q6_fw.mdt\",\n\t.crash_reason_smem = WCSS_CRASH_REASON,\n\t.aon_reset_required = true,\n\t.wcss_q6_reset_required = true,\n\t.ops = &q6v5_wcss_ipq8074_ops,\n\t.requires_force_stop = true,\n};\n\nstatic const struct wcss_data wcss_qcs404_res_init = {\n\t.crash_reason_smem = WCSS_CRASH_REASON,\n\t.firmware_name = \"wcnss.mdt\",\n\t.version = WCSS_QCS404,\n\t.aon_reset_required = false,\n\t.wcss_q6_reset_required = false,\n\t.ssr_name = \"mpss\",\n\t.sysmon_name = \"wcnss\",\n\t.ssctl_id = 0x12,\n\t.ops = &q6v5_wcss_qcs404_ops,\n\t.requires_force_stop = false,\n};\n\nstatic const struct of_device_id q6v5_wcss_of_match[] = {\n\t{ .compatible = \"qcom,ipq8074-wcss-pil\", .data = &wcss_ipq8074_res_init },\n\t{ .compatible = \"qcom,qcs404-wcss-pil\", .data = &wcss_qcs404_res_init },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, q6v5_wcss_of_match);\n\nstatic struct platform_driver q6v5_wcss_driver = {\n\t.probe = q6v5_wcss_probe,\n\t.remove_new = q6v5_wcss_remove,\n\t.driver = {\n\t\t.name = \"qcom-q6v5-wcss-pil\",\n\t\t.of_match_table = q6v5_wcss_of_match,\n\t},\n};\nmodule_platform_driver(q6v5_wcss_driver);\n\nMODULE_DESCRIPTION(\"Hexagon WCSS Peripheral Image Loader\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}