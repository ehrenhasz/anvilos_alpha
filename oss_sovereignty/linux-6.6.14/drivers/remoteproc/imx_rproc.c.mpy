{
  "module_name": "imx_rproc.c",
  "hash_id": "7074c8dc35633230fc124714ac66156fe8a2dc9e647ed35cdcf23b25499650e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/imx_rproc.c",
  "human_readable_source": "\n \n\n#include <dt-bindings/firmware/imx/rsrc.h>\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/firmware/imx/sci.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/workqueue.h>\n\n#include \"imx_rproc.h\"\n#include \"remoteproc_internal.h\"\n\n#define IMX7D_SRC_SCR\t\t\t0x0C\n#define IMX7D_ENABLE_M4\t\t\tBIT(3)\n#define IMX7D_SW_M4P_RST\t\tBIT(2)\n#define IMX7D_SW_M4C_RST\t\tBIT(1)\n#define IMX7D_SW_M4C_NON_SCLR_RST\tBIT(0)\n\n#define IMX7D_M4_RST_MASK\t\t(IMX7D_ENABLE_M4 | IMX7D_SW_M4P_RST \\\n\t\t\t\t\t | IMX7D_SW_M4C_RST \\\n\t\t\t\t\t | IMX7D_SW_M4C_NON_SCLR_RST)\n\n#define IMX7D_M4_START\t\t\t(IMX7D_ENABLE_M4 | IMX7D_SW_M4P_RST \\\n\t\t\t\t\t | IMX7D_SW_M4C_RST)\n#define IMX7D_M4_STOP\t\t\t(IMX7D_ENABLE_M4 | IMX7D_SW_M4C_RST | \\\n\t\t\t\t\t IMX7D_SW_M4C_NON_SCLR_RST)\n\n#define IMX8M_M7_STOP\t\t\t(IMX7D_ENABLE_M4 | IMX7D_SW_M4C_RST)\n#define IMX8M_M7_POLL\t\t\tIMX7D_ENABLE_M4\n\n#define IMX8M_GPR22\t\t\t0x58\n#define IMX8M_GPR22_CM7_CPUWAIT\t\tBIT(0)\n\n \n#define IMX6SX_SRC_SCR\t\t\t0x00\n#define IMX6SX_ENABLE_M4\t\tBIT(22)\n#define IMX6SX_SW_M4P_RST\t\tBIT(12)\n#define IMX6SX_SW_M4C_NON_SCLR_RST\tBIT(4)\n#define IMX6SX_SW_M4C_RST\t\tBIT(3)\n\n#define IMX6SX_M4_START\t\t\t(IMX6SX_ENABLE_M4 | IMX6SX_SW_M4P_RST \\\n\t\t\t\t\t | IMX6SX_SW_M4C_RST)\n#define IMX6SX_M4_STOP\t\t\t(IMX6SX_ENABLE_M4 | IMX6SX_SW_M4C_RST | \\\n\t\t\t\t\t IMX6SX_SW_M4C_NON_SCLR_RST)\n#define IMX6SX_M4_RST_MASK\t\t(IMX6SX_ENABLE_M4 | IMX6SX_SW_M4P_RST \\\n\t\t\t\t\t | IMX6SX_SW_M4C_NON_SCLR_RST \\\n\t\t\t\t\t | IMX6SX_SW_M4C_RST)\n\n#define IMX_RPROC_MEM_MAX\t\t32\n\n#define IMX_SIP_RPROC\t\t\t0xC2000005\n#define IMX_SIP_RPROC_START\t\t0x00\n#define IMX_SIP_RPROC_STARTED\t\t0x01\n#define IMX_SIP_RPROC_STOP\t\t0x02\n\n#define IMX_SC_IRQ_GROUP_REBOOTED\t5\n\n \nstruct imx_rproc_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t sys_addr;\n\tsize_t size;\n};\n\n \n \n#define ATT_OWN         BIT(31)\n#define ATT_IOMEM       BIT(30)\n\n#define ATT_CORE_MASK   0xffff\n#define ATT_CORE(I)     BIT((I))\n\nstatic int imx_rproc_xtr_mbox_init(struct rproc *rproc);\nstatic void imx_rproc_free_mbox(struct rproc *rproc);\nstatic int imx_rproc_detach_pd(struct rproc *rproc);\n\nstruct imx_rproc {\n\tstruct device\t\t\t*dev;\n\tstruct regmap\t\t\t*regmap;\n\tstruct regmap\t\t\t*gpr;\n\tstruct rproc\t\t\t*rproc;\n\tconst struct imx_rproc_dcfg\t*dcfg;\n\tstruct imx_rproc_mem\t\tmem[IMX_RPROC_MEM_MAX];\n\tstruct clk\t\t\t*clk;\n\tstruct mbox_client\t\tcl;\n\tstruct mbox_chan\t\t*tx_ch;\n\tstruct mbox_chan\t\t*rx_ch;\n\tstruct work_struct\t\trproc_work;\n\tstruct workqueue_struct\t\t*workqueue;\n\tvoid __iomem\t\t\t*rsc_table;\n\tstruct imx_sc_ipc\t\t*ipc_handle;\n\tstruct notifier_block\t\trproc_nb;\n\tu32\t\t\t\trproc_pt;\t \n\tu32\t\t\t\trsrc_id;\t \n\tu32\t\t\t\tentry;\t\t \n\tint                             num_pd;\n\tu32\t\t\t\tcore_index;\n\tstruct device                   **pd_dev;\n\tstruct device_link              **pd_dev_link;\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx93[] = {\n\t \n\t \n\t{ 0x0FFC0000, 0x201C0000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t{ 0x0FFE0000, 0x201E0000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\n\t \n\t{ 0x1FFC0000, 0x201C0000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t{ 0x1FFE0000, 0x201E0000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\n\t \n\t{ 0x20000000, 0x20200000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t{ 0x20020000, 0x20220000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\n\t \n\t{ 0x30000000, 0x20200000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t{ 0x30020000, 0x20220000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\n\t \n\t{ 0x80000000, 0x80000000, 0x10000000, 0 },\n\t{ 0x90000000, 0x80000000, 0x10000000, 0 },\n\n\t{ 0xC0000000, 0xC0000000, 0x10000000, 0 },\n\t{ 0xD0000000, 0xC0000000, 0x10000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx8qm[] = {\n\t \n\t{ 0x08000000, 0x08000000, 0x10000000, 0},\n\t \n\t{ 0x1FFE0000, 0x34FE0000, 0x00020000, ATT_OWN | ATT_IOMEM | ATT_CORE(0)},\n\t{ 0x1FFE0000, 0x38FE0000, 0x00020000, ATT_OWN | ATT_IOMEM | ATT_CORE(1)},\n\t \n\t{ 0x20000000, 0x35000000, 0x00020000, ATT_OWN | ATT_IOMEM | ATT_CORE(0)},\n\t{ 0x20000000, 0x39000000, 0x00020000, ATT_OWN | ATT_IOMEM | ATT_CORE(1)},\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx8qxp[] = {\n\t{ 0x08000000, 0x08000000, 0x10000000, 0 },\n\t \n\t{ 0x1FFE0000, 0x34FE0000, 0x00040000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x21000000, 0x00100000, 0x00018000, 0 },\n\t \n\t{ 0x21100000, 0x00100000, 0x00040000, 0 },\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx8mn[] = {\n\t \n\t \n\t{ 0x00000000, 0x007E0000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x00180000, 0x00180000, 0x00009000, 0 },\n\t \n\t{ 0x00900000, 0x00900000, 0x00020000, 0 },\n\t \n\t{ 0x00920000, 0x00920000, 0x00020000, 0 },\n\t \n\t{ 0x00940000, 0x00940000, 0x00050000, 0 },\n\t \n\t{ 0x08000000, 0x08000000, 0x08000000, 0 },\n\t \n\t{ 0x10000000, 0x40000000, 0x0FFE0000, 0 },\n\t \n\t{ 0x20000000, 0x00800000, 0x00020000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x20180000, 0x00180000, 0x00008000, ATT_OWN },\n\t \n\t{ 0x20200000, 0x00900000, 0x00020000, ATT_OWN },\n\t \n\t{ 0x20220000, 0x00920000, 0x00020000, ATT_OWN },\n\t \n\t{ 0x20240000, 0x00940000, 0x00040000, ATT_OWN },\n\t \n\t{ 0x40000000, 0x40000000, 0x80000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx8mq[] = {\n\t \n\t \n\t{ 0x00000000, 0x007e0000, 0x00020000, ATT_IOMEM},\n\t \n\t{ 0x00180000, 0x00180000, 0x00008000, 0 },\n\t \n\t{ 0x00900000, 0x00900000, 0x00020000, 0 },\n\t \n\t{ 0x00920000, 0x00920000, 0x00020000, 0 },\n\t \n\t{ 0x08000000, 0x08000000, 0x08000000, 0 },\n\t \n\t{ 0x10000000, 0x80000000, 0x0FFE0000, 0 },\n\t \n\t{ 0x1FFE0000, 0x007E0000, 0x00020000, ATT_OWN  | ATT_IOMEM},\n\t \n\t{ 0x20000000, 0x00800000, 0x00020000, ATT_OWN  | ATT_IOMEM},\n\t \n\t{ 0x20180000, 0x00180000, 0x00008000, ATT_OWN },\n\t \n\t{ 0x20200000, 0x00900000, 0x00020000, ATT_OWN },\n\t \n\t{ 0x20220000, 0x00920000, 0x00020000, ATT_OWN },\n\t \n\t{ 0x40000000, 0x40000000, 0x80000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx8ulp[] = {\n\t{0x1FFC0000, 0x1FFC0000, 0xC0000, ATT_OWN},\n\t{0x21000000, 0x21000000, 0x10000, ATT_OWN},\n\t{0x80000000, 0x80000000, 0x60000000, 0}\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx7ulp[] = {\n\t{0x1FFD0000, 0x1FFD0000, 0x30000, ATT_OWN},\n\t{0x20000000, 0x20000000, 0x10000, ATT_OWN},\n\t{0x2F000000, 0x2F000000, 0x20000, ATT_OWN},\n\t{0x2F020000, 0x2F020000, 0x20000, ATT_OWN},\n\t{0x60000000, 0x60000000, 0x40000000, 0}\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx7d[] = {\n\t \n\t \n\t{ 0x00000000, 0x00180000, 0x00008000, 0 },\n\t \n\t{ 0x00180000, 0x00180000, 0x00008000, ATT_OWN },\n\t \n\t{ 0x00900000, 0x00900000, 0x00020000, 0 },\n\t \n\t{ 0x00920000, 0x00920000, 0x00020000, 0 },\n\t \n\t{ 0x00940000, 0x00940000, 0x00008000, 0 },\n\t \n\t{ 0x1FFF8000, 0x007F8000, 0x00008000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x10000000, 0x80000000, 0x0FFF0000, 0 },\n\n\t \n\t{ 0x20000000, 0x00800000, 0x00008000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x20200000, 0x00900000, 0x00020000, 0 },\n\t \n\t{ 0x20220000, 0x00920000, 0x00020000, 0 },\n\t \n\t{ 0x20240000, 0x00940000, 0x00008000, 0 },\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0 },\n};\n\nstatic const struct imx_rproc_att imx_rproc_att_imx6sx[] = {\n\t \n\t \n\t{ 0x00000000, 0x007F8000, 0x00008000, ATT_IOMEM },\n\t \n\t{ 0x00180000, 0x008F8000, 0x00004000, 0 },\n\t \n\t{ 0x00180000, 0x008FC000, 0x00004000, 0 },\n\t \n\t{ 0x1FFF8000, 0x007F8000, 0x00008000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x10000000, 0x80000000, 0x0FFF8000, 0 },\n\n\t \n\t{ 0x20000000, 0x00800000, 0x00008000, ATT_OWN | ATT_IOMEM },\n\t \n\t{ 0x208F8000, 0x008F8000, 0x00004000, 0 },\n\t \n\t{ 0x80000000, 0x80000000, 0x60000000, 0 },\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8mn_mmio = {\n\t.src_reg\t= IMX7D_SRC_SCR,\n\t.src_mask\t= IMX7D_M4_RST_MASK,\n\t.src_start\t= IMX7D_M4_START,\n\t.src_stop\t= IMX8M_M7_STOP,\n\t.gpr_reg\t= IMX8M_GPR22,\n\t.gpr_wait\t= IMX8M_GPR22_CM7_CPUWAIT,\n\t.att\t\t= imx_rproc_att_imx8mn,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx8mn),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8mn = {\n\t.att\t\t= imx_rproc_att_imx8mn,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx8mn),\n\t.method\t\t= IMX_RPROC_SMC,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8mq = {\n\t.src_reg\t= IMX7D_SRC_SCR,\n\t.src_mask\t= IMX7D_M4_RST_MASK,\n\t.src_start\t= IMX7D_M4_START,\n\t.src_stop\t= IMX7D_M4_STOP,\n\t.att\t\t= imx_rproc_att_imx8mq,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx8mq),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8qm = {\n\t.att            = imx_rproc_att_imx8qm,\n\t.att_size       = ARRAY_SIZE(imx_rproc_att_imx8qm),\n\t.method         = IMX_RPROC_SCU_API,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8qxp = {\n\t.att\t\t= imx_rproc_att_imx8qxp,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx8qxp),\n\t.method\t\t= IMX_RPROC_SCU_API,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx8ulp = {\n\t.att\t\t= imx_rproc_att_imx8ulp,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx8ulp),\n\t.method\t\t= IMX_RPROC_NONE,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx7ulp = {\n\t.att\t\t= imx_rproc_att_imx7ulp,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx7ulp),\n\t.method\t\t= IMX_RPROC_NONE,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx7d = {\n\t.src_reg\t= IMX7D_SRC_SCR,\n\t.src_mask\t= IMX7D_M4_RST_MASK,\n\t.src_start\t= IMX7D_M4_START,\n\t.src_stop\t= IMX7D_M4_STOP,\n\t.att\t\t= imx_rproc_att_imx7d,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx7d),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx6sx = {\n\t.src_reg\t= IMX6SX_SRC_SCR,\n\t.src_mask\t= IMX6SX_M4_RST_MASK,\n\t.src_start\t= IMX6SX_M4_START,\n\t.src_stop\t= IMX6SX_M4_STOP,\n\t.att\t\t= imx_rproc_att_imx6sx,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx6sx),\n\t.method\t\t= IMX_RPROC_MMIO,\n};\n\nstatic const struct imx_rproc_dcfg imx_rproc_cfg_imx93 = {\n\t.att\t\t= imx_rproc_att_imx93,\n\t.att_size\t= ARRAY_SIZE(imx_rproc_att_imx93),\n\t.method\t\t= IMX_RPROC_SMC,\n};\n\nstatic int imx_rproc_start(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = priv->dev;\n\tstruct arm_smccc_res res;\n\tint ret;\n\n\tret = imx_rproc_xtr_mbox_init(rproc);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (dcfg->method) {\n\tcase IMX_RPROC_MMIO:\n\t\tif (priv->gpr) {\n\t\t\tret = regmap_clear_bits(priv->gpr, dcfg->gpr_reg,\n\t\t\t\t\t\tdcfg->gpr_wait);\n\t\t} else {\n\t\t\tret = regmap_update_bits(priv->regmap, dcfg->src_reg,\n\t\t\t\t\t\t dcfg->src_mask,\n\t\t\t\t\t\t dcfg->src_start);\n\t\t}\n\t\tbreak;\n\tcase IMX_RPROC_SMC:\n\t\tarm_smccc_smc(IMX_SIP_RPROC, IMX_SIP_RPROC_START, 0, 0, 0, 0, 0, 0, &res);\n\t\tret = res.a0;\n\t\tbreak;\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_sc_pm_cpu_start(priv->ipc_handle, priv->rsrc_id, true, priv->entry);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to enable remote core!\\n\");\n\n\treturn ret;\n}\n\nstatic int imx_rproc_stop(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = priv->dev;\n\tstruct arm_smccc_res res;\n\tint ret;\n\n\tswitch (dcfg->method) {\n\tcase IMX_RPROC_MMIO:\n\t\tif (priv->gpr) {\n\t\t\tret = regmap_set_bits(priv->gpr, dcfg->gpr_reg,\n\t\t\t\t\t      dcfg->gpr_wait);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(priv->dev,\n\t\t\t\t\t\"Failed to quiescence M4 platform!\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\tret = regmap_update_bits(priv->regmap, dcfg->src_reg, dcfg->src_mask,\n\t\t\t\t\t dcfg->src_stop);\n\t\tbreak;\n\tcase IMX_RPROC_SMC:\n\t\tarm_smccc_smc(IMX_SIP_RPROC, IMX_SIP_RPROC_STOP, 0, 0, 0, 0, 0, 0, &res);\n\t\tret = res.a0;\n\t\tif (res.a1)\n\t\t\tdev_info(dev, \"Not in wfi, force stopped\\n\");\n\t\tbreak;\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_sc_pm_cpu_start(priv->ipc_handle, priv->rsrc_id, false, priv->entry);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to stop remote core\\n\");\n\telse\n\t\timx_rproc_free_mbox(rproc);\n\n\treturn ret;\n}\n\nstatic int imx_rproc_da_to_sys(struct imx_rproc *priv, u64 da,\n\t\t\t       size_t len, u64 *sys, bool *is_iomem)\n{\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tint i;\n\n\t \n\tfor (i = 0; i < dcfg->att_size; i++) {\n\t\tconst struct imx_rproc_att *att = &dcfg->att[i];\n\n\t\t \n\t\tif (att->flags & ATT_CORE_MASK) {\n\t\t\tif (!((BIT(priv->core_index)) & (att->flags & ATT_CORE_MASK)))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (da >= att->da && da + len < att->da + att->size) {\n\t\t\tunsigned int offset = da - att->da;\n\n\t\t\t*sys = att->sa + offset;\n\t\t\tif (is_iomem)\n\t\t\t\t*is_iomem = att->flags & ATT_IOMEM;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_warn(priv->dev, \"Translation failed: da = 0x%llx len = 0x%zx\\n\",\n\t\t da, len);\n\treturn -ENOENT;\n}\n\nstatic void *imx_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tvoid *va = NULL;\n\tu64 sys;\n\tint i;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\t \n\tif (imx_rproc_da_to_sys(priv, da, len, &sys, is_iomem))\n\t\treturn NULL;\n\n\tfor (i = 0; i < IMX_RPROC_MEM_MAX; i++) {\n\t\tif (sys >= priv->mem[i].sys_addr && sys + len <\n\t\t    priv->mem[i].sys_addr +  priv->mem[i].size) {\n\t\t\tunsigned int offset = sys - priv->mem[i].sys_addr;\n\t\t\t \n\t\t\tva = (__force void *)(priv->mem[i].cpu_addr + offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(&rproc->dev, \"da = 0x%llx len = 0x%zx va = 0x%p\\n\",\n\t\tda, len, va);\n\n\treturn va;\n}\n\nstatic int imx_rproc_mem_alloc(struct rproc *rproc,\n\t\t\t       struct rproc_mem_entry *mem)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tvoid *va;\n\n\tdev_dbg(dev, \"map memory: %p+%zx\\n\", &mem->dma, mem->len);\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (IS_ERR_OR_NULL(va)) {\n\t\tdev_err(dev, \"Unable to map memory region: %p+%zx\\n\",\n\t\t\t&mem->dma, mem->len);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmem->va = va;\n\n\treturn 0;\n}\n\nstatic int imx_rproc_mem_release(struct rproc *rproc,\n\t\t\t\t struct rproc_mem_entry *mem)\n{\n\tdev_dbg(rproc->dev.parent, \"unmap memory: %pa\\n\", &mem->dma);\n\tiounmap(mem->va);\n\n\treturn 0;\n}\n\nstatic int imx_rproc_prepare(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tstruct device_node *np = priv->dev->of_node;\n\tstruct of_phandle_iterator it;\n\tstruct rproc_mem_entry *mem;\n\tstruct reserved_mem *rmem;\n\tu32 da;\n\n\t \n\tof_phandle_iterator_init(&it, np, \"memory-region\", NULL, 0);\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\t\t \n\t\tif (!strcmp(it.node->name, \"vdev0buffer\"))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(it.node->name, \"rsc-table\"))\n\t\t\tcontinue;\n\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(priv->dev, \"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tda = rmem->base;\n\n\t\t \n\t\tmem = rproc_mem_entry_init(priv->dev, NULL, (dma_addr_t)rmem->base, rmem->size, da,\n\t\t\t\t\t   imx_rproc_mem_alloc, imx_rproc_mem_release,\n\t\t\t\t\t   it.node->name);\n\n\t\tif (mem) {\n\t\t\trproc_coredump_add_segment(rproc, da, rmem->size);\n\t\t} else {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t}\n\n\treturn  0;\n}\n\nstatic int imx_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tint ret;\n\n\tret = rproc_elf_load_rsc_table(rproc, fw);\n\tif (ret)\n\t\tdev_info(&rproc->dev, \"No resource table in elf\\n\");\n\n\treturn 0;\n}\n\nstatic void imx_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tint err;\n\t__u32 mmsg;\n\n\tif (!priv->tx_ch) {\n\t\tdev_err(priv->dev, \"No initialized mbox tx channel\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmmsg = vqid << 16;\n\n\terr = mbox_send_message(priv->tx_ch, (void *)&mmsg);\n\tif (err < 0)\n\t\tdev_err(priv->dev, \"%s: failed (%d, err:%d)\\n\",\n\t\t\t__func__, vqid, err);\n}\n\nstatic int imx_rproc_attach(struct rproc *rproc)\n{\n\treturn imx_rproc_xtr_mbox_init(rproc);\n}\n\nstatic int imx_rproc_detach(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\n\tif (dcfg->method != IMX_RPROC_SCU_API)\n\t\treturn -EOPNOTSUPP;\n\n\tif (imx_sc_rm_is_resource_owned(priv->ipc_handle, priv->rsrc_id))\n\t\treturn -EOPNOTSUPP;\n\n\timx_rproc_free_mbox(rproc);\n\n\treturn 0;\n}\n\nstatic struct resource_table *imx_rproc_get_loaded_rsc_table(struct rproc *rproc, size_t *table_sz)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\n\t \n\tif (!priv->rsc_table)\n\t\treturn NULL;\n\n\t*table_sz = SZ_1K;\n\treturn (struct resource_table *)priv->rsc_table;\n}\n\nstatic const struct rproc_ops imx_rproc_ops = {\n\t.prepare\t= imx_rproc_prepare,\n\t.attach\t\t= imx_rproc_attach,\n\t.detach\t\t= imx_rproc_detach,\n\t.start\t\t= imx_rproc_start,\n\t.stop\t\t= imx_rproc_stop,\n\t.kick\t\t= imx_rproc_kick,\n\t.da_to_va       = imx_rproc_da_to_va,\n\t.load\t\t= rproc_elf_load_segments,\n\t.parse_fw\t= imx_rproc_parse_fw,\n\t.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,\n\t.get_loaded_rsc_table = imx_rproc_get_loaded_rsc_table,\n\t.sanity_check\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n};\n\nstatic int imx_rproc_addr_init(struct imx_rproc *priv,\n\t\t\t       struct platform_device *pdev)\n{\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tint a, b = 0, err, nph;\n\n\t \n\tfor (a = 0; a < dcfg->att_size; a++) {\n\t\tconst struct imx_rproc_att *att = &dcfg->att[a];\n\n\t\tif (!(att->flags & ATT_OWN))\n\t\t\tcontinue;\n\n\t\tif (b >= IMX_RPROC_MEM_MAX)\n\t\t\tbreak;\n\n\t\tif (att->flags & ATT_IOMEM)\n\t\t\tpriv->mem[b].cpu_addr = devm_ioremap(&pdev->dev,\n\t\t\t\t\t\t\t     att->sa, att->size);\n\t\telse\n\t\t\tpriv->mem[b].cpu_addr = devm_ioremap_wc(&pdev->dev,\n\t\t\t\t\t\t\t\tatt->sa, att->size);\n\t\tif (!priv->mem[b].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to remap %#x bytes from %#x\\n\", att->size, att->sa);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->mem[b].sys_addr = att->sa;\n\t\tpriv->mem[b].size = att->size;\n\t\tb++;\n\t}\n\n\t \n\tnph = of_count_phandle_with_args(np, \"memory-region\", NULL);\n\tif (nph <= 0)\n\t\treturn 0;\n\n\t \n\tfor (a = 0; a < nph; a++) {\n\t\tstruct device_node *node;\n\t\tstruct resource res;\n\n\t\tnode = of_parse_phandle(np, \"memory-region\", a);\n\t\t \n\t\tif (!strncmp(node->name, \"vdev\", strlen(\"vdev\"))) {\n\t\t\tof_node_put(node);\n\t\t\tcontinue;\n\t\t}\n\t\terr = of_address_to_resource(node, 0, &res);\n\t\tof_node_put(node);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to resolve memory region\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tif (b >= IMX_RPROC_MEM_MAX)\n\t\t\tbreak;\n\n\t\t \n\t\tpriv->mem[b].cpu_addr = devm_ioremap_wc(&pdev->dev, res.start, resource_size(&res));\n\t\tif (!priv->mem[b].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to remap %pr\\n\", &res);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tpriv->mem[b].sys_addr = res.start;\n\t\tpriv->mem[b].size = resource_size(&res);\n\t\tif (!strcmp(node->name, \"rsc-table\"))\n\t\t\tpriv->rsc_table = priv->mem[b].cpu_addr;\n\t\tb++;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_rproc_notified_idr_cb(int id, void *ptr, void *data)\n{\n\tstruct rproc *rproc = data;\n\n\trproc_vq_interrupt(rproc, id);\n\n\treturn 0;\n}\n\nstatic void imx_rproc_vq_work(struct work_struct *work)\n{\n\tstruct imx_rproc *priv = container_of(work, struct imx_rproc,\n\t\t\t\t\t      rproc_work);\n\tstruct rproc *rproc = priv->rproc;\n\n\tidr_for_each(&rproc->notifyids, imx_rproc_notified_idr_cb, rproc);\n}\n\nstatic void imx_rproc_rx_callback(struct mbox_client *cl, void *msg)\n{\n\tstruct rproc *rproc = dev_get_drvdata(cl->dev);\n\tstruct imx_rproc *priv = rproc->priv;\n\n\tqueue_work(priv->workqueue, &priv->rproc_work);\n}\n\nstatic int imx_rproc_xtr_mbox_init(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tstruct device *dev = priv->dev;\n\tstruct mbox_client *cl;\n\n\t \n\tif (priv->tx_ch && priv->rx_ch)\n\t\treturn 0;\n\n\tif (!of_get_property(dev->of_node, \"mbox-names\", NULL))\n\t\treturn 0;\n\n\tcl = &priv->cl;\n\tcl->dev = dev;\n\tcl->tx_block = true;\n\tcl->tx_tout = 100;\n\tcl->knows_txdone = false;\n\tcl->rx_callback = imx_rproc_rx_callback;\n\n\tpriv->tx_ch = mbox_request_channel_byname(cl, \"tx\");\n\tif (IS_ERR(priv->tx_ch))\n\t\treturn dev_err_probe(cl->dev, PTR_ERR(priv->tx_ch),\n\t\t\t\t     \"failed to request tx mailbox channel\\n\");\n\n\tpriv->rx_ch = mbox_request_channel_byname(cl, \"rx\");\n\tif (IS_ERR(priv->rx_ch)) {\n\t\tmbox_free_channel(priv->tx_ch);\n\t\treturn dev_err_probe(cl->dev, PTR_ERR(priv->rx_ch),\n\t\t\t\t     \"failed to request rx mailbox channel\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void imx_rproc_free_mbox(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\n\tif (priv->tx_ch) {\n\t\tmbox_free_channel(priv->tx_ch);\n\t\tpriv->tx_ch = NULL;\n\t}\n\n\tif (priv->rx_ch) {\n\t\tmbox_free_channel(priv->rx_ch);\n\t\tpriv->rx_ch = NULL;\n\t}\n}\n\nstatic void imx_rproc_put_scu(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\n\tif (dcfg->method != IMX_RPROC_SCU_API)\n\t\treturn;\n\n\tif (imx_sc_rm_is_resource_owned(priv->ipc_handle, priv->rsrc_id)) {\n\t\timx_rproc_detach_pd(rproc);\n\t\treturn;\n\t}\n\n\timx_scu_irq_group_enable(IMX_SC_IRQ_GROUP_REBOOTED, BIT(priv->rproc_pt), false);\n\timx_scu_irq_unregister_notifier(&priv->rproc_nb);\n}\n\nstatic int imx_rproc_partition_notify(struct notifier_block *nb,\n\t\t\t\t      unsigned long event, void *group)\n{\n\tstruct imx_rproc *priv = container_of(nb, struct imx_rproc, rproc_nb);\n\n\t \n\tif (!((event & BIT(priv->rproc_pt)) && (*(u8 *)group == IMX_SC_IRQ_GROUP_REBOOTED)))\n\t\treturn 0;\n\n\trproc_report_crash(priv->rproc, RPROC_WATCHDOG);\n\n\tpr_info(\"Partition%d reset!\\n\", priv->rproc_pt);\n\n\treturn 0;\n}\n\nstatic int imx_rproc_attach_pd(struct imx_rproc *priv)\n{\n\tstruct device *dev = priv->dev;\n\tint ret, i;\n\n\t \n\tpriv->num_pd = of_count_phandle_with_args(dev->of_node, \"power-domains\",\n\t\t\t\t\t\t  \"#power-domain-cells\");\n\tif (priv->num_pd <= 1)\n\t\treturn 0;\n\n\tpriv->pd_dev = devm_kmalloc_array(dev, priv->num_pd, sizeof(*priv->pd_dev), GFP_KERNEL);\n\tif (!priv->pd_dev)\n\t\treturn -ENOMEM;\n\n\tpriv->pd_dev_link = devm_kmalloc_array(dev, priv->num_pd, sizeof(*priv->pd_dev_link),\n\t\t\t\t\t       GFP_KERNEL);\n\n\tif (!priv->pd_dev_link)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < priv->num_pd; i++) {\n\t\tpriv->pd_dev[i] = dev_pm_domain_attach_by_id(dev, i);\n\t\tif (IS_ERR(priv->pd_dev[i])) {\n\t\t\tret = PTR_ERR(priv->pd_dev[i]);\n\t\t\tgoto detach_pd;\n\t\t}\n\n\t\tpriv->pd_dev_link[i] = device_link_add(dev, priv->pd_dev[i], DL_FLAG_STATELESS |\n\t\t\t\t\t\t       DL_FLAG_PM_RUNTIME | DL_FLAG_RPM_ACTIVE);\n\t\tif (!priv->pd_dev_link[i]) {\n\t\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t\t\tret = -EINVAL;\n\t\t\tgoto detach_pd;\n\t\t}\n\t}\n\n\treturn 0;\n\ndetach_pd:\n\twhile (--i >= 0) {\n\t\tdevice_link_del(priv->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t}\n\n\treturn ret;\n}\n\nstatic int imx_rproc_detach_pd(struct rproc *rproc)\n{\n\tstruct imx_rproc *priv = rproc->priv;\n\tint i;\n\n\t \n\tif (priv->num_pd <= 1)\n\t\treturn 0;\n\n\tfor (i = 0; i < priv->num_pd; i++) {\n\t\tdevice_link_del(priv->pd_dev_link[i]);\n\t\tdev_pm_domain_detach(priv->pd_dev[i], false);\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_rproc_detect_mode(struct imx_rproc *priv)\n{\n\tstruct regmap_config config = { .name = \"imx-rproc\" };\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = priv->dev;\n\tstruct regmap *regmap;\n\tstruct arm_smccc_res res;\n\tint ret;\n\tu32 val;\n\tu8 pt;\n\n\tswitch (dcfg->method) {\n\tcase IMX_RPROC_NONE:\n\t\tpriv->rproc->state = RPROC_DETACHED;\n\t\treturn 0;\n\tcase IMX_RPROC_SMC:\n\t\tarm_smccc_smc(IMX_SIP_RPROC, IMX_SIP_RPROC_STARTED, 0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0)\n\t\t\tpriv->rproc->state = RPROC_DETACHED;\n\t\treturn 0;\n\tcase IMX_RPROC_SCU_API:\n\t\tret = imx_scu_get_handle(&priv->ipc_handle);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = of_property_read_u32(dev->of_node, \"fsl,resource-id\", &priv->rsrc_id);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"No fsl,resource-id property\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (priv->rsrc_id == IMX_SC_R_M4_1_PID0)\n\t\t\tpriv->core_index = 1;\n\t\telse\n\t\t\tpriv->core_index = 0;\n\n\t\t \n\t\tif (imx_sc_rm_is_resource_owned(priv->ipc_handle, priv->rsrc_id)) {\n\t\t\tif (of_property_read_u32(dev->of_node, \"fsl,entry-address\", &priv->entry))\n\t\t\t\treturn -EINVAL;\n\n\t\t\treturn imx_rproc_attach_pd(priv);\n\t\t}\n\n\t\tpriv->rproc->state = RPROC_DETACHED;\n\t\tpriv->rproc->recovery_disabled = false;\n\t\trproc_set_feature(priv->rproc, RPROC_FEAT_ATTACH_ON_RECOVERY);\n\n\t\t \n\t\tret = imx_sc_rm_get_resource_owner(priv->ipc_handle, priv->rsrc_id, &pt);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"not able to get resource owner\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tpriv->rproc_pt = pt;\n\t\tpriv->rproc_nb.notifier_call = imx_rproc_partition_notify;\n\n\t\tret = imx_scu_irq_register_notifier(&priv->rproc_nb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"register scu notifier failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = imx_scu_irq_group_enable(IMX_SC_IRQ_GROUP_REBOOTED, BIT(priv->rproc_pt),\n\t\t\t\t\t       true);\n\t\tif (ret) {\n\t\t\timx_scu_irq_unregister_notifier(&priv->rproc_nb);\n\t\t\tdev_err(dev, \"Enable irq failed, %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tpriv->gpr = syscon_regmap_lookup_by_phandle(dev->of_node, \"fsl,iomuxc-gpr\");\n\tif (IS_ERR(priv->gpr))\n\t\tpriv->gpr = NULL;\n\n\tregmap = syscon_regmap_lookup_by_phandle(dev->of_node, \"syscon\");\n\tif (IS_ERR(regmap)) {\n\t\tdev_err(dev, \"failed to find syscon\\n\");\n\t\treturn PTR_ERR(regmap);\n\t}\n\n\tpriv->regmap = regmap;\n\tregmap_attach_dev(dev, regmap, &config);\n\n\tif (priv->gpr) {\n\t\tret = regmap_read(priv->gpr, dcfg->gpr_reg, &val);\n\t\tif (val & dcfg->gpr_wait) {\n\t\t\t \n\t\t\timx_rproc_stop(priv->rproc);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tret = regmap_read(regmap, dcfg->src_reg, &val);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to read src\\n\");\n\t\treturn ret;\n\t}\n\n\tif ((val & dcfg->src_mask) != dcfg->src_stop)\n\t\tpriv->rproc->state = RPROC_DETACHED;\n\n\treturn 0;\n}\n\nstatic int imx_rproc_clk_enable(struct imx_rproc *priv)\n{\n\tconst struct imx_rproc_dcfg *dcfg = priv->dcfg;\n\tstruct device *dev = priv->dev;\n\tint ret;\n\n\t \n\tif (dcfg->method == IMX_RPROC_NONE)\n\t\treturn 0;\n\n\tpriv->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\tdev_err(dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(priv->clk);\n\t}\n\n\t \n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct imx_rproc *priv;\n\tstruct rproc *rproc;\n\tconst struct imx_rproc_dcfg *dcfg;\n\tint ret;\n\n\t \n\trproc = rproc_alloc(dev, \"imx-rproc\", &imx_rproc_ops,\n\t\t\t    NULL, sizeof(*priv));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\tdcfg = of_device_get_match_data(dev);\n\tif (!dcfg) {\n\t\tret = -EINVAL;\n\t\tgoto err_put_rproc;\n\t}\n\n\tpriv = rproc->priv;\n\tpriv->rproc = rproc;\n\tpriv->dcfg = dcfg;\n\tpriv->dev = dev;\n\n\tdev_set_drvdata(dev, rproc);\n\tpriv->workqueue = create_workqueue(dev_name(dev));\n\tif (!priv->workqueue) {\n\t\tdev_err(dev, \"cannot create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_put_rproc;\n\t}\n\n\tret = imx_rproc_xtr_mbox_init(rproc);\n\tif (ret)\n\t\tgoto err_put_wkq;\n\n\tret = imx_rproc_addr_init(priv, pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"failed on imx_rproc_addr_init\\n\");\n\t\tgoto err_put_mbox;\n\t}\n\n\tret = imx_rproc_detect_mode(priv);\n\tif (ret)\n\t\tgoto err_put_mbox;\n\n\tret = imx_rproc_clk_enable(priv);\n\tif (ret)\n\t\tgoto err_put_scu;\n\n\tINIT_WORK(&priv->rproc_work, imx_rproc_vq_work);\n\n\tif (rproc->state != RPROC_DETACHED)\n\t\trproc->auto_boot = of_property_read_bool(np, \"fsl,auto-boot\");\n\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed\\n\");\n\t\tgoto err_put_clk;\n\t}\n\n\treturn 0;\n\nerr_put_clk:\n\tclk_disable_unprepare(priv->clk);\nerr_put_scu:\n\timx_rproc_put_scu(rproc);\nerr_put_mbox:\n\timx_rproc_free_mbox(rproc);\nerr_put_wkq:\n\tdestroy_workqueue(priv->workqueue);\nerr_put_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void imx_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct imx_rproc *priv = rproc->priv;\n\n\tclk_disable_unprepare(priv->clk);\n\trproc_del(rproc);\n\timx_rproc_put_scu(rproc);\n\timx_rproc_free_mbox(rproc);\n\tdestroy_workqueue(priv->workqueue);\n\trproc_free(rproc);\n}\n\nstatic const struct of_device_id imx_rproc_of_match[] = {\n\t{ .compatible = \"fsl,imx7ulp-cm4\", .data = &imx_rproc_cfg_imx7ulp },\n\t{ .compatible = \"fsl,imx7d-cm4\", .data = &imx_rproc_cfg_imx7d },\n\t{ .compatible = \"fsl,imx6sx-cm4\", .data = &imx_rproc_cfg_imx6sx },\n\t{ .compatible = \"fsl,imx8mq-cm4\", .data = &imx_rproc_cfg_imx8mq },\n\t{ .compatible = \"fsl,imx8mm-cm4\", .data = &imx_rproc_cfg_imx8mq },\n\t{ .compatible = \"fsl,imx8mn-cm7\", .data = &imx_rproc_cfg_imx8mn },\n\t{ .compatible = \"fsl,imx8mp-cm7\", .data = &imx_rproc_cfg_imx8mn },\n\t{ .compatible = \"fsl,imx8mn-cm7-mmio\", .data = &imx_rproc_cfg_imx8mn_mmio },\n\t{ .compatible = \"fsl,imx8mp-cm7-mmio\", .data = &imx_rproc_cfg_imx8mn_mmio },\n\t{ .compatible = \"fsl,imx8qxp-cm4\", .data = &imx_rproc_cfg_imx8qxp },\n\t{ .compatible = \"fsl,imx8qm-cm4\", .data = &imx_rproc_cfg_imx8qm },\n\t{ .compatible = \"fsl,imx8ulp-cm33\", .data = &imx_rproc_cfg_imx8ulp },\n\t{ .compatible = \"fsl,imx93-cm33\", .data = &imx_rproc_cfg_imx93 },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, imx_rproc_of_match);\n\nstatic struct platform_driver imx_rproc_driver = {\n\t.probe = imx_rproc_probe,\n\t.remove_new = imx_rproc_remove,\n\t.driver = {\n\t\t.name = \"imx-rproc\",\n\t\t.of_match_table = imx_rproc_of_match,\n\t},\n};\n\nmodule_platform_driver(imx_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"i.MX remote processor control driver\");\nMODULE_AUTHOR(\"Oleksij Rempel <o.rempel@pengutronix.de>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}