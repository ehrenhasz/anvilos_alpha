{
  "module_name": "qcom_q6v5_adsp.c",
  "hash_id": "eac5984ed2677108bd79d2d764b3bbed3f73aa9557c825da304e7a377ef7fbc4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_q6v5_adsp.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iommu.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\n#include \"qcom_common.h\"\n#include \"qcom_pil_info.h\"\n#include \"qcom_q6v5.h\"\n#include \"remoteproc_internal.h\"\n\n \n#define ACK_TIMEOUT\t\t\t1000\n#define ACK_TIMEOUT_US\t\t\t1000000\n#define BOOT_FSM_TIMEOUT\t\t10000\n \n#define EVB_MASK\t\t\tGENMASK(27, 4)\n \n#define RST_EVB_REG\t\t\t0x10\n#define CORE_START_REG\t\t\t0x400\n#define BOOT_CMD_REG\t\t\t0x404\n#define BOOT_STATUS_REG\t\t\t0x408\n#define RET_CFG_REG\t\t\t0x1C\n \n#define LPASS_MASTER_IDLE_REG\t\t0x8\n#define LPASS_HALTACK_REG\t\t0x4\n#define LPASS_PWR_ON_REG\t\t0x10\n#define LPASS_HALTREQ_REG\t\t0x0\n\n#define SID_MASK_DEFAULT        0xF\n\n#define QDSP6SS_XO_CBCR\t\t0x38\n#define QDSP6SS_CORE_CBCR\t0x20\n#define QDSP6SS_SLEEP_CBCR\t0x3c\n\n#define QCOM_Q6V5_RPROC_PROXY_PD_MAX\t3\n\n#define LPASS_BOOT_CORE_START\tBIT(0)\n#define LPASS_BOOT_CMD_START\tBIT(0)\n#define LPASS_EFUSE_Q6SS_EVB_SEL 0x0\n\nstruct adsp_pil_data {\n\tint crash_reason_smem;\n\tconst char *firmware_name;\n\n\tconst char *ssr_name;\n\tconst char *sysmon_name;\n\tint ssctl_id;\n\tbool is_wpss;\n\tbool has_iommu;\n\tbool auto_boot;\n\n\tconst char **clk_ids;\n\tint num_clks;\n\tconst char **proxy_pd_names;\n\tconst char *load_state;\n};\n\nstruct qcom_adsp {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\n\tstruct qcom_q6v5 q6v5;\n\n\tstruct clk *xo;\n\n\tint num_clks;\n\tstruct clk_bulk_data *clks;\n\n\tvoid __iomem *qdsp6ss_base;\n\tvoid __iomem *lpass_efuse;\n\n\tstruct reset_control *pdc_sync_reset;\n\tstruct reset_control *restart;\n\n\tstruct regmap *halt_map;\n\tunsigned int halt_lpass;\n\n\tint crash_reason_smem;\n\tconst char *info_name;\n\n\tstruct completion start_done;\n\tstruct completion stop_done;\n\n\tphys_addr_t mem_phys;\n\tphys_addr_t mem_reloc;\n\tvoid *mem_region;\n\tsize_t mem_size;\n\tbool has_iommu;\n\n\tstruct device *proxy_pds[QCOM_Q6V5_RPROC_PROXY_PD_MAX];\n\tsize_t proxy_pd_count;\n\n\tstruct qcom_rproc_glink glink_subdev;\n\tstruct qcom_rproc_ssr ssr_subdev;\n\tstruct qcom_sysmon *sysmon;\n\n\tint (*shutdown)(struct qcom_adsp *adsp);\n};\n\nstatic int qcom_rproc_pds_attach(struct device *dev, struct qcom_adsp *adsp,\n\t\t\t\t const char **pd_names)\n{\n\tstruct device **devs = adsp->proxy_pds;\n\tsize_t num_pds = 0;\n\tint ret;\n\tint i;\n\n\tif (!pd_names)\n\t\treturn 0;\n\n\t \n\tif (dev->pm_domain) {\n\t\tdevs[0] = dev;\n\t\tpm_runtime_enable(dev);\n\t\treturn 1;\n\t}\n\n\twhile (pd_names[num_pds])\n\t\tnum_pds++;\n\n\tif (num_pds > ARRAY_SIZE(adsp->proxy_pds))\n\t\treturn -E2BIG;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tdevs[i] = dev_pm_domain_attach_by_name(dev, pd_names[i]);\n\t\tif (IS_ERR_OR_NULL(devs[i])) {\n\t\t\tret = PTR_ERR(devs[i]) ? : -ENODATA;\n\t\t\tgoto unroll_attach;\n\t\t}\n\t}\n\n\treturn num_pds;\n\nunroll_attach:\n\tfor (i--; i >= 0; i--)\n\t\tdev_pm_domain_detach(devs[i], false);\n\n\treturn ret;\n}\n\nstatic void qcom_rproc_pds_detach(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t\t  size_t pd_count)\n{\n\tstruct device *dev = adsp->dev;\n\tint i;\n\n\t \n\tif (dev->pm_domain && pd_count) {\n\t\tpm_runtime_disable(dev);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < pd_count; i++)\n\t\tdev_pm_domain_detach(pds[i], false);\n}\n\nstatic int qcom_rproc_pds_enable(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t\t size_t pd_count)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], INT_MAX);\n\t\tret = pm_runtime_resume_and_get(pds[i]);\n\t\tif (ret < 0) {\n\t\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\t\tgoto unroll_pd_votes;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll_pd_votes:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic void qcom_rproc_pds_disable(struct qcom_adsp *adsp, struct device **pds,\n\t\t\t\t   size_t pd_count)\n{\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n}\n\nstatic int qcom_wpss_shutdown(struct qcom_adsp *adsp)\n{\n\tunsigned int val;\n\n\tregmap_write(adsp->halt_map, adsp->halt_lpass + LPASS_HALTREQ_REG, 1);\n\n\t \n\tregmap_read_poll_timeout(adsp->halt_map,\n\t\t\t\t adsp->halt_lpass + LPASS_HALTACK_REG, val,\n\t\t\t\t val, 1000, ACK_TIMEOUT_US);\n\n\t \n\treset_control_assert(adsp->pdc_sync_reset);\n\n\t \n\treset_control_assert(adsp->restart);\n\n\t \n\tusleep_range(200, 205);\n\n\t \n\treset_control_deassert(adsp->restart);\n\n\t \n\treset_control_deassert(adsp->pdc_sync_reset);\n\n\tusleep_range(100, 105);\n\n\tclk_bulk_disable_unprepare(adsp->num_clks, adsp->clks);\n\n\tregmap_write(adsp->halt_map, adsp->halt_lpass + LPASS_HALTREQ_REG, 0);\n\n\t \n\tregmap_read_poll_timeout(adsp->halt_map,\n\t\t\t\t adsp->halt_lpass + LPASS_HALTACK_REG, val,\n\t\t\t\t !val, 1000, ACK_TIMEOUT_US);\n\n\treturn 0;\n}\n\nstatic int qcom_adsp_shutdown(struct qcom_adsp *adsp)\n{\n\tunsigned long timeout;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tval = readl(adsp->qdsp6ss_base + RET_CFG_REG);\n\tval |= 0x1;\n\twritel(val, adsp->qdsp6ss_base + RET_CFG_REG);\n\n\tclk_bulk_disable_unprepare(adsp->num_clks, adsp->clks);\n\n\t \n\tret = regmap_read(adsp->halt_map,\n\t\t\tadsp->halt_lpass + LPASS_PWR_ON_REG, &val);\n\tif (ret || !val)\n\t\tgoto reset;\n\n\tret = regmap_read(adsp->halt_map,\n\t\t\tadsp->halt_lpass + LPASS_MASTER_IDLE_REG,\n\t\t\t&val);\n\tif (ret || val)\n\t\tgoto reset;\n\n\tregmap_write(adsp->halt_map,\n\t\t\tadsp->halt_lpass + LPASS_HALTREQ_REG, 1);\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(ACK_TIMEOUT);\n\tfor (;;) {\n\t\tret = regmap_read(adsp->halt_map,\n\t\t\tadsp->halt_lpass + LPASS_HALTACK_REG, &val);\n\t\tif (ret || val || time_after(jiffies, timeout))\n\t\t\tbreak;\n\n\t\tusleep_range(1000, 1100);\n\t}\n\n\tret = regmap_read(adsp->halt_map,\n\t\t\tadsp->halt_lpass + LPASS_MASTER_IDLE_REG, &val);\n\tif (ret || !val)\n\t\tdev_err(adsp->dev, \"port failed halt\\n\");\n\nreset:\n\t \n\treset_control_assert(adsp->pdc_sync_reset);\n\t \n\treset_control_assert(adsp->restart);\n\t \n\tusleep_range(200, 300);\n\n\t \n\tregmap_write(adsp->halt_map, adsp->halt_lpass + LPASS_HALTREQ_REG, 0);\n\n\t \n\treset_control_deassert(adsp->pdc_sync_reset);\n\t \n\treset_control_deassert(adsp->restart);\n\t \n\tusleep_range(200, 300);\n\n\treturn 0;\n}\n\nstatic int adsp_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint ret;\n\n\tret = qcom_mdt_load_no_init(adsp->dev, fw, rproc->firmware, 0,\n\t\t\t\t    adsp->mem_region, adsp->mem_phys,\n\t\t\t\t    adsp->mem_size, &adsp->mem_reloc);\n\tif (ret)\n\t\treturn ret;\n\n\tqcom_pil_info_store(adsp->info_name, adsp->mem_phys, adsp->mem_size);\n\n\treturn 0;\n}\n\nstatic void adsp_unmap_carveout(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\n\tif (adsp->has_iommu)\n\t\tiommu_unmap(rproc->domain, adsp->mem_phys, adsp->mem_size);\n}\n\nstatic int adsp_map_carveout(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tstruct of_phandle_args args;\n\tlong long sid;\n\tunsigned long iova;\n\tint ret;\n\n\tif (!adsp->has_iommu)\n\t\treturn 0;\n\n\tif (!rproc->domain)\n\t\treturn -EINVAL;\n\n\tret = of_parse_phandle_with_args(adsp->dev->of_node, \"iommus\", \"#iommu-cells\", 0, &args);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsid = args.args[0] & SID_MASK_DEFAULT;\n\n\t \n\tiova =  adsp->mem_phys | (sid << 32);\n\n\tret = iommu_map(rproc->domain, iova, adsp->mem_phys,\n\t\t\tadsp->mem_size,\tIOMMU_READ | IOMMU_WRITE,\n\t\t\tGFP_KERNEL);\n\tif (ret) {\n\t\tdev_err(adsp->dev, \"Unable to map ADSP Physical Memory\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_start(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint ret;\n\tunsigned int val;\n\n\tret = qcom_q6v5_prepare(&adsp->q6v5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = adsp_map_carveout(rproc);\n\tif (ret) {\n\t\tdev_err(adsp->dev, \"ADSP smmu mapping failed\\n\");\n\t\tgoto disable_irqs;\n\t}\n\n\tret = clk_prepare_enable(adsp->xo);\n\tif (ret)\n\t\tgoto adsp_smmu_unmap;\n\n\tret = qcom_rproc_pds_enable(adsp, adsp->proxy_pds,\n\t\t\t\t    adsp->proxy_pd_count);\n\tif (ret < 0)\n\t\tgoto disable_xo_clk;\n\n\tret = clk_bulk_prepare_enable(adsp->num_clks, adsp->clks);\n\tif (ret) {\n\t\tdev_err(adsp->dev, \"adsp clk_enable failed\\n\");\n\t\tgoto disable_power_domain;\n\t}\n\n\t \n\twritel(1, adsp->qdsp6ss_base + QDSP6SS_XO_CBCR);\n\n\t \n\twritel(1, adsp->qdsp6ss_base + QDSP6SS_SLEEP_CBCR);\n\n\t \n\twritel(1, adsp->qdsp6ss_base + QDSP6SS_CORE_CBCR);\n\n\t \n\twritel(adsp->mem_phys >> 4, adsp->qdsp6ss_base + RST_EVB_REG);\n\n\tif (adsp->lpass_efuse)\n\t\twritel(LPASS_EFUSE_Q6SS_EVB_SEL, adsp->lpass_efuse);\n\n\t \n\twritel(LPASS_BOOT_CORE_START, adsp->qdsp6ss_base + CORE_START_REG);\n\n\t \n\twritel(LPASS_BOOT_CMD_START, adsp->qdsp6ss_base + BOOT_CMD_REG);\n\n\t \n\tret = readl_poll_timeout(adsp->qdsp6ss_base + BOOT_STATUS_REG,\n\t\t\tval, (val & BIT(0)) != 0, 10, BOOT_FSM_TIMEOUT);\n\tif (ret) {\n\t\tdev_err(adsp->dev, \"failed to bootup adsp\\n\");\n\t\tgoto disable_adsp_clks;\n\t}\n\n\tret = qcom_q6v5_wait_for_start(&adsp->q6v5, msecs_to_jiffies(5 * HZ));\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(adsp->dev, \"start timed out\\n\");\n\t\tgoto disable_adsp_clks;\n\t}\n\n\treturn 0;\n\ndisable_adsp_clks:\n\tclk_bulk_disable_unprepare(adsp->num_clks, adsp->clks);\ndisable_power_domain:\n\tqcom_rproc_pds_disable(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\ndisable_xo_clk:\n\tclk_disable_unprepare(adsp->xo);\nadsp_smmu_unmap:\n\tadsp_unmap_carveout(rproc);\ndisable_irqs:\n\tqcom_q6v5_unprepare(&adsp->q6v5);\n\n\treturn ret;\n}\n\nstatic void qcom_adsp_pil_handover(struct qcom_q6v5 *q6v5)\n{\n\tstruct qcom_adsp *adsp = container_of(q6v5, struct qcom_adsp, q6v5);\n\n\tclk_disable_unprepare(adsp->xo);\n\tqcom_rproc_pds_disable(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n}\n\nstatic int adsp_stop(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint handover;\n\tint ret;\n\n\tret = qcom_q6v5_request_stop(&adsp->q6v5, adsp->sysmon);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(adsp->dev, \"timed out on wait\\n\");\n\n\tret = adsp->shutdown(adsp);\n\tif (ret)\n\t\tdev_err(adsp->dev, \"failed to shutdown: %d\\n\", ret);\n\n\tadsp_unmap_carveout(rproc);\n\n\thandover = qcom_q6v5_unprepare(&adsp->q6v5);\n\tif (handover)\n\t\tqcom_adsp_pil_handover(&adsp->q6v5);\n\n\treturn ret;\n}\n\nstatic void *adsp_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint offset;\n\n\toffset = da - adsp->mem_reloc;\n\tif (offset < 0 || offset + len > adsp->mem_size)\n\t\treturn NULL;\n\n\treturn adsp->mem_region + offset;\n}\n\nstatic int adsp_parse_firmware(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\tint ret;\n\n\tret = qcom_register_dump_segments(rproc, fw);\n\tif (ret) {\n\t\tdev_err(&rproc->dev, \"Error in registering dump segments\\n\");\n\t\treturn ret;\n\t}\n\n\tif (adsp->has_iommu) {\n\t\tret = rproc_elf_load_rsc_table(rproc, fw);\n\t\tif (ret) {\n\t\t\tdev_err(&rproc->dev, \"Error in loading resource table\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic unsigned long adsp_panic(struct rproc *rproc)\n{\n\tstruct qcom_adsp *adsp = rproc->priv;\n\n\treturn qcom_q6v5_panic(&adsp->q6v5);\n}\n\nstatic const struct rproc_ops adsp_ops = {\n\t.start = adsp_start,\n\t.stop = adsp_stop,\n\t.da_to_va = adsp_da_to_va,\n\t.parse_fw = adsp_parse_firmware,\n\t.load = adsp_load,\n\t.panic = adsp_panic,\n};\n\nstatic int adsp_init_clock(struct qcom_adsp *adsp, const char **clk_ids)\n{\n\tint num_clks = 0;\n\tint i, ret;\n\n\tadsp->xo = devm_clk_get(adsp->dev, \"xo\");\n\tif (IS_ERR(adsp->xo)) {\n\t\tret = PTR_ERR(adsp->xo);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(adsp->dev, \"failed to get xo clock\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; clk_ids[i]; i++)\n\t\tnum_clks++;\n\n\tadsp->num_clks = num_clks;\n\tadsp->clks = devm_kcalloc(adsp->dev, adsp->num_clks,\n\t\t\t\tsizeof(*adsp->clks), GFP_KERNEL);\n\tif (!adsp->clks)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < adsp->num_clks; i++)\n\t\tadsp->clks[i].id = clk_ids[i];\n\n\treturn devm_clk_bulk_get(adsp->dev, adsp->num_clks, adsp->clks);\n}\n\nstatic int adsp_init_reset(struct qcom_adsp *adsp)\n{\n\tadsp->pdc_sync_reset = devm_reset_control_get_optional_exclusive(adsp->dev,\n\t\t\t\"pdc_sync\");\n\tif (IS_ERR(adsp->pdc_sync_reset)) {\n\t\tdev_err(adsp->dev, \"failed to acquire pdc_sync reset\\n\");\n\t\treturn PTR_ERR(adsp->pdc_sync_reset);\n\t}\n\n\tadsp->restart = devm_reset_control_get_optional_exclusive(adsp->dev, \"restart\");\n\n\t \n\tif (!adsp->restart)\n\t\tadsp->restart = devm_reset_control_get_exclusive(adsp->dev, \"cc_lpass\");\n\n\tif (IS_ERR(adsp->restart)) {\n\t\tdev_err(adsp->dev, \"failed to acquire restart\\n\");\n\t\treturn PTR_ERR(adsp->restart);\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_init_mmio(struct qcom_adsp *adsp,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tstruct resource *efuse_region;\n\tstruct device_node *syscon;\n\tint ret;\n\n\tadsp->qdsp6ss_base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(adsp->qdsp6ss_base)) {\n\t\tdev_err(adsp->dev, \"failed to map QDSP6SS registers\\n\");\n\t\treturn PTR_ERR(adsp->qdsp6ss_base);\n\t}\n\n\tefuse_region = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (!efuse_region) {\n\t\tadsp->lpass_efuse = NULL;\n\t\tdev_dbg(adsp->dev, \"failed to get efuse memory region\\n\");\n\t} else {\n\t\tadsp->lpass_efuse = devm_ioremap_resource(&pdev->dev, efuse_region);\n\t\tif (IS_ERR(adsp->lpass_efuse)) {\n\t\t\tdev_err(adsp->dev, \"failed to map efuse registers\\n\");\n\t\t\treturn PTR_ERR(adsp->lpass_efuse);\n\t\t}\n\t}\n\tsyscon = of_parse_phandle(pdev->dev.of_node, \"qcom,halt-regs\", 0);\n\tif (!syscon) {\n\t\tdev_err(&pdev->dev, \"failed to parse qcom,halt-regs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadsp->halt_map = syscon_node_to_regmap(syscon);\n\tof_node_put(syscon);\n\tif (IS_ERR(adsp->halt_map))\n\t\treturn PTR_ERR(adsp->halt_map);\n\n\tret = of_property_read_u32_index(pdev->dev.of_node, \"qcom,halt-regs\",\n\t\t\t1, &adsp->halt_lpass);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"no offset in syscon\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_alloc_memory_region(struct qcom_adsp *adsp)\n{\n\tstruct reserved_mem *rmem = NULL;\n\tstruct device_node *node;\n\n\tnode = of_parse_phandle(adsp->dev->of_node, \"memory-region\", 0);\n\tif (node)\n\t\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\n\tif (!rmem) {\n\t\tdev_err(adsp->dev, \"unable to resolve memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tadsp->mem_phys = adsp->mem_reloc = rmem->base;\n\tadsp->mem_size = rmem->size;\n\tadsp->mem_region = devm_ioremap_wc(adsp->dev,\n\t\t\t\tadsp->mem_phys, adsp->mem_size);\n\tif (!adsp->mem_region) {\n\t\tdev_err(adsp->dev, \"unable to map memory region: %pa+%zx\\n\",\n\t\t\t&rmem->base, adsp->mem_size);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int adsp_probe(struct platform_device *pdev)\n{\n\tconst struct adsp_pil_data *desc;\n\tconst char *firmware_name;\n\tstruct qcom_adsp *adsp;\n\tstruct rproc *rproc;\n\tint ret;\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tfirmware_name = desc->firmware_name;\n\tret = of_property_read_string(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t      &firmware_name);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(&pdev->dev, \"unable to read firmware-name\\n\");\n\t\treturn ret;\n\t}\n\n\trproc = rproc_alloc(&pdev->dev, pdev->name, &adsp_ops,\n\t\t\t    firmware_name, sizeof(*adsp));\n\tif (!rproc) {\n\t\tdev_err(&pdev->dev, \"unable to allocate remoteproc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trproc->auto_boot = desc->auto_boot;\n\trproc->has_iommu = desc->has_iommu;\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\tadsp = rproc->priv;\n\tadsp->dev = &pdev->dev;\n\tadsp->rproc = rproc;\n\tadsp->info_name = desc->sysmon_name;\n\tadsp->has_iommu = desc->has_iommu;\n\n\tplatform_set_drvdata(pdev, adsp);\n\n\tif (desc->is_wpss)\n\t\tadsp->shutdown = qcom_wpss_shutdown;\n\telse\n\t\tadsp->shutdown = qcom_adsp_shutdown;\n\n\tret = adsp_alloc_memory_region(adsp);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = adsp_init_clock(adsp, desc->clk_ids);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = qcom_rproc_pds_attach(adsp->dev, adsp,\n\t\t\t\t    desc->proxy_pd_names);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to attach proxy power domains\\n\");\n\t\tgoto free_rproc;\n\t}\n\tadsp->proxy_pd_count = ret;\n\n\tret = adsp_init_reset(adsp);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\tret = adsp_init_mmio(adsp, pdev);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\tret = qcom_q6v5_init(&adsp->q6v5, pdev, rproc, desc->crash_reason_smem,\n\t\t\t     desc->load_state, qcom_adsp_pil_handover);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\tqcom_add_glink_subdev(rproc, &adsp->glink_subdev, desc->ssr_name);\n\tqcom_add_ssr_subdev(rproc, &adsp->ssr_subdev, desc->ssr_name);\n\tadsp->sysmon = qcom_add_sysmon_subdev(rproc,\n\t\t\t\t\t      desc->sysmon_name,\n\t\t\t\t\t      desc->ssctl_id);\n\tif (IS_ERR(adsp->sysmon)) {\n\t\tret = PTR_ERR(adsp->sysmon);\n\t\tgoto disable_pm;\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\treturn 0;\n\ndisable_pm:\n\tqcom_rproc_pds_detach(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n\nfree_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void adsp_remove(struct platform_device *pdev)\n{\n\tstruct qcom_adsp *adsp = platform_get_drvdata(pdev);\n\n\trproc_del(adsp->rproc);\n\n\tqcom_q6v5_deinit(&adsp->q6v5);\n\tqcom_remove_glink_subdev(adsp->rproc, &adsp->glink_subdev);\n\tqcom_remove_sysmon_subdev(adsp->sysmon);\n\tqcom_remove_ssr_subdev(adsp->rproc, &adsp->ssr_subdev);\n\tqcom_rproc_pds_detach(adsp, adsp->proxy_pds, adsp->proxy_pd_count);\n\trproc_free(adsp->rproc);\n}\n\nstatic const struct adsp_pil_data adsp_resource_init = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.mdt\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n\t.is_wpss = false,\n\t.auto_boot = true,\n\t.clk_ids = (const char*[]) {\n\t\t\"sway_cbcr\", \"lpass_ahbs_aon_cbcr\", \"lpass_ahbm_aon_cbcr\",\n\t\t\"qdsp6ss_xo\", \"qdsp6ss_sleep\", \"qdsp6ss_core\", NULL\n\t},\n\t.num_clks = 7,\n\t.proxy_pd_names = (const char*[]) {\n\t\t\"cx\", NULL\n\t},\n};\n\nstatic const struct adsp_pil_data adsp_sc7280_resource_init = {\n\t.crash_reason_smem = 423,\n\t.firmware_name = \"adsp.pbn\",\n\t.load_state = \"adsp\",\n\t.ssr_name = \"lpass\",\n\t.sysmon_name = \"adsp\",\n\t.ssctl_id = 0x14,\n\t.has_iommu = true,\n\t.auto_boot = true,\n\t.clk_ids = (const char*[]) {\n\t\t\"gcc_cfg_noc_lpass\", NULL\n\t},\n\t.num_clks = 1,\n};\n\nstatic const struct adsp_pil_data cdsp_resource_init = {\n\t.crash_reason_smem = 601,\n\t.firmware_name = \"cdsp.mdt\",\n\t.ssr_name = \"cdsp\",\n\t.sysmon_name = \"cdsp\",\n\t.ssctl_id = 0x17,\n\t.is_wpss = false,\n\t.auto_boot = true,\n\t.clk_ids = (const char*[]) {\n\t\t\"sway\", \"tbu\", \"bimc\", \"ahb_aon\", \"q6ss_slave\", \"q6ss_master\",\n\t\t\"q6_axim\", NULL\n\t},\n\t.num_clks = 7,\n\t.proxy_pd_names = (const char*[]) {\n\t\t\"cx\", NULL\n\t},\n};\n\nstatic const struct adsp_pil_data wpss_resource_init = {\n\t.crash_reason_smem = 626,\n\t.firmware_name = \"wpss.mdt\",\n\t.ssr_name = \"wpss\",\n\t.sysmon_name = \"wpss\",\n\t.ssctl_id = 0x19,\n\t.is_wpss = true,\n\t.auto_boot = false,\n\t.load_state = \"wpss\",\n\t.clk_ids = (const char*[]) {\n\t\t\"ahb_bdg\", \"ahb\", \"rscp\", NULL\n\t},\n\t.num_clks = 3,\n\t.proxy_pd_names = (const char*[]) {\n\t\t\"cx\", \"mx\", NULL\n\t},\n};\n\nstatic const struct of_device_id adsp_of_match[] = {\n\t{ .compatible = \"qcom,qcs404-cdsp-pil\", .data = &cdsp_resource_init },\n\t{ .compatible = \"qcom,sc7280-adsp-pil\", .data = &adsp_sc7280_resource_init },\n\t{ .compatible = \"qcom,sc7280-wpss-pil\", .data = &wpss_resource_init },\n\t{ .compatible = \"qcom,sdm845-adsp-pil\", .data = &adsp_resource_init },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, adsp_of_match);\n\nstatic struct platform_driver adsp_pil_driver = {\n\t.probe = adsp_probe,\n\t.remove_new = adsp_remove,\n\t.driver = {\n\t\t.name = \"qcom_q6v5_adsp\",\n\t\t.of_match_table = adsp_of_match,\n\t},\n};\n\nmodule_platform_driver(adsp_pil_driver);\nMODULE_DESCRIPTION(\"QTI SDM845 ADSP Peripheral Image Loader\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}