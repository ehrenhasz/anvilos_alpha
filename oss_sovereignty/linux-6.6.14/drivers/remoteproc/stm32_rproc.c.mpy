{
  "module_name": "stm32_rproc.c",
  "hash_id": "9da7f1c873149966954eae70728dc16378560d1741da395dc96a979ac5ce5df6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/stm32_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"remoteproc_internal.h\"\n\n#define HOLD_BOOT\t\t0\n#define RELEASE_BOOT\t\t1\n\n#define MBOX_NB_VQ\t\t2\n#define MBOX_NB_MBX\t\t4\n\n#define STM32_SMC_RCC\t\t0x82001000\n#define STM32_SMC_REG_WRITE\t0x1\n\n#define STM32_MBX_VQ0\t\t\"vq0\"\n#define STM32_MBX_VQ0_ID\t0\n#define STM32_MBX_VQ1\t\t\"vq1\"\n#define STM32_MBX_VQ1_ID\t1\n#define STM32_MBX_SHUTDOWN\t\"shutdown\"\n#define STM32_MBX_DETACH\t\"detach\"\n\n#define RSC_TBL_SIZE\t\t1024\n\n#define M4_STATE_OFF\t\t0\n#define M4_STATE_INI\t\t1\n#define M4_STATE_CRUN\t\t2\n#define M4_STATE_CSTOP\t\t3\n#define M4_STATE_STANDBY\t4\n#define M4_STATE_CRASH\t\t5\n\nstruct stm32_syscon {\n\tstruct regmap *map;\n\tu32 reg;\n\tu32 mask;\n};\n\nstruct stm32_rproc_mem {\n\tchar name[20];\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\nstruct stm32_rproc_mem_ranges {\n\tu32 dev_addr;\n\tu32 bus_addr;\n\tu32 size;\n};\n\nstruct stm32_mbox {\n\tconst unsigned char name[10];\n\tstruct mbox_chan *chan;\n\tstruct mbox_client client;\n\tstruct work_struct vq_work;\n\tint vq_id;\n};\n\nstruct stm32_rproc {\n\tstruct reset_control *rst;\n\tstruct reset_control *hold_boot_rst;\n\tstruct stm32_syscon hold_boot;\n\tstruct stm32_syscon pdds;\n\tstruct stm32_syscon m4_state;\n\tstruct stm32_syscon rsctbl;\n\tint wdg_irq;\n\tu32 nb_rmems;\n\tstruct stm32_rproc_mem *rmems;\n\tstruct stm32_mbox mb[MBOX_NB_MBX];\n\tstruct workqueue_struct *workqueue;\n\tbool hold_boot_smc;\n\tvoid __iomem *rsc_va;\n};\n\nstatic int stm32_rproc_pa_to_da(struct rproc *rproc, phys_addr_t pa, u64 *da)\n{\n\tunsigned int i;\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct stm32_rproc_mem *p_mem;\n\n\tfor (i = 0; i < ddata->nb_rmems; i++) {\n\t\tp_mem = &ddata->rmems[i];\n\n\t\tif (pa < p_mem->bus_addr ||\n\t\t    pa >= p_mem->bus_addr + p_mem->size)\n\t\t\tcontinue;\n\t\t*da = pa - p_mem->bus_addr + p_mem->dev_addr;\n\t\tdev_dbg(rproc->dev.parent, \"pa %pa to da %llx\\n\", &pa, *da);\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_rproc_mem_alloc(struct rproc *rproc,\n\t\t\t\t struct rproc_mem_entry *mem)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tvoid *va;\n\n\tdev_dbg(dev, \"map memory: %pad+%zx\\n\", &mem->dma, mem->len);\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (IS_ERR_OR_NULL(va)) {\n\t\tdev_err(dev, \"Unable to map memory region: %pad+0x%zx\\n\",\n\t\t\t&mem->dma, mem->len);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmem->va = va;\n\n\treturn 0;\n}\n\nstatic int stm32_rproc_mem_release(struct rproc *rproc,\n\t\t\t\t   struct rproc_mem_entry *mem)\n{\n\tdev_dbg(rproc->dev.parent, \"unmap memory: %pa\\n\", &mem->dma);\n\tiounmap(mem->va);\n\n\treturn 0;\n}\n\nstatic int stm32_rproc_of_memory_translations(struct platform_device *pdev,\n\t\t\t\t\t      struct stm32_rproc *ddata)\n{\n\tstruct device *parent, *dev = &pdev->dev;\n\tstruct device_node *np;\n\tstruct stm32_rproc_mem *p_mems;\n\tstruct stm32_rproc_mem_ranges *mem_range;\n\tint cnt, array_size, i, ret = 0;\n\n\tparent = dev->parent;\n\tnp = parent->of_node;\n\n\tcnt = of_property_count_elems_of_size(np, \"dma-ranges\",\n\t\t\t\t\t      sizeof(*mem_range));\n\tif (cnt <= 0) {\n\t\tdev_err(dev, \"%s: dma-ranges property not defined\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tp_mems = devm_kcalloc(dev, cnt, sizeof(*p_mems), GFP_KERNEL);\n\tif (!p_mems)\n\t\treturn -ENOMEM;\n\tmem_range = kcalloc(cnt, sizeof(*mem_range), GFP_KERNEL);\n\tif (!mem_range)\n\t\treturn -ENOMEM;\n\n\tarray_size = cnt * sizeof(struct stm32_rproc_mem_ranges) / sizeof(u32);\n\n\tret = of_property_read_u32_array(np, \"dma-ranges\",\n\t\t\t\t\t (u32 *)mem_range, array_size);\n\tif (ret) {\n\t\tdev_err(dev, \"error while get dma-ranges property: %x\\n\", ret);\n\t\tgoto free_mem;\n\t}\n\n\tfor (i = 0; i < cnt; i++) {\n\t\tp_mems[i].bus_addr = mem_range[i].bus_addr;\n\t\tp_mems[i].dev_addr = mem_range[i].dev_addr;\n\t\tp_mems[i].size     = mem_range[i].size;\n\n\t\tdev_dbg(dev, \"memory range[%i]: da %#x, pa %pa, size %#zx:\\n\",\n\t\t\ti, p_mems[i].dev_addr, &p_mems[i].bus_addr,\n\t\t\tp_mems[i].size);\n\t}\n\n\tddata->rmems = p_mems;\n\tddata->nb_rmems = cnt;\n\nfree_mem:\n\tkfree(mem_range);\n\treturn ret;\n}\n\nstatic int stm32_rproc_mbox_idx(struct rproc *rproc, const unsigned char *name)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ddata->mb); i++) {\n\t\tif (!strncmp(ddata->mb[i].name, name, strlen(name)))\n\t\t\treturn i;\n\t}\n\tdev_err(&rproc->dev, \"mailbox %s not found\\n\", name);\n\n\treturn -EINVAL;\n}\n\nstatic int stm32_rproc_prepare(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_iterator it;\n\tstruct rproc_mem_entry *mem;\n\tstruct reserved_mem *rmem;\n\tu64 da;\n\tint index = 0;\n\n\t \n\tof_phandle_iterator_init(&it, np, \"memory-region\", NULL, 0);\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(dev, \"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (stm32_rproc_pa_to_da(rproc, rmem->base, &da) < 0) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(dev, \"memory region not valid %pa\\n\",\n\t\t\t\t&rmem->base);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (strcmp(it.node->name, \"vdev0buffer\")) {\n\t\t\t \n\t\t\tmem = rproc_mem_entry_init(dev, NULL,\n\t\t\t\t\t\t   (dma_addr_t)rmem->base,\n\t\t\t\t\t\t   rmem->size, da,\n\t\t\t\t\t\t   stm32_rproc_mem_alloc,\n\t\t\t\t\t\t   stm32_rproc_mem_release,\n\t\t\t\t\t\t   it.node->name);\n\n\t\t\tif (mem)\n\t\t\t\trproc_coredump_add_segment(rproc, da,\n\t\t\t\t\t\t\t   rmem->size);\n\t\t} else {\n\t\t\t \n\t\t\tmem = rproc_of_resm_mem_entry_init(dev, index,\n\t\t\t\t\t\t\t   rmem->size,\n\t\t\t\t\t\t\t   rmem->base,\n\t\t\t\t\t\t\t   it.node->name);\n\t\t}\n\n\t\tif (!mem) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t\tindex++;\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tif (rproc_elf_load_rsc_table(rproc, fw))\n\t\tdev_warn(&rproc->dev, \"no resource table found for this firmware\\n\");\n\n\treturn 0;\n}\n\nstatic irqreturn_t stm32_rproc_wdg(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\n\trproc_report_crash(rproc, RPROC_WATCHDOG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void stm32_rproc_mb_vq_work(struct work_struct *work)\n{\n\tstruct stm32_mbox *mb = container_of(work, struct stm32_mbox, vq_work);\n\tstruct rproc *rproc = dev_get_drvdata(mb->client.dev);\n\n\tmutex_lock(&rproc->lock);\n\n\tif (rproc->state != RPROC_RUNNING)\n\t\tgoto unlock_mutex;\n\n\tif (rproc_vq_interrupt(rproc, mb->vq_id) == IRQ_NONE)\n\t\tdev_dbg(&rproc->dev, \"no message found in vq%d\\n\", mb->vq_id);\n\nunlock_mutex:\n\tmutex_unlock(&rproc->lock);\n}\n\nstatic void stm32_rproc_mb_callback(struct mbox_client *cl, void *data)\n{\n\tstruct rproc *rproc = dev_get_drvdata(cl->dev);\n\tstruct stm32_mbox *mb = container_of(cl, struct stm32_mbox, client);\n\tstruct stm32_rproc *ddata = rproc->priv;\n\n\tqueue_work(ddata->workqueue, &mb->vq_work);\n}\n\nstatic void stm32_rproc_free_mbox(struct rproc *rproc)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ddata->mb); i++) {\n\t\tif (ddata->mb[i].chan)\n\t\t\tmbox_free_channel(ddata->mb[i].chan);\n\t\tddata->mb[i].chan = NULL;\n\t}\n}\n\nstatic const struct stm32_mbox stm32_rproc_mbox[MBOX_NB_MBX] = {\n\t{\n\t\t.name = STM32_MBX_VQ0,\n\t\t.vq_id = STM32_MBX_VQ0_ID,\n\t\t.client = {\n\t\t\t.rx_callback = stm32_rproc_mb_callback,\n\t\t\t.tx_block = false,\n\t\t},\n\t},\n\t{\n\t\t.name = STM32_MBX_VQ1,\n\t\t.vq_id = STM32_MBX_VQ1_ID,\n\t\t.client = {\n\t\t\t.rx_callback = stm32_rproc_mb_callback,\n\t\t\t.tx_block = false,\n\t\t},\n\t},\n\t{\n\t\t.name = STM32_MBX_SHUTDOWN,\n\t\t.vq_id = -1,\n\t\t.client = {\n\t\t\t.tx_block = true,\n\t\t\t.tx_done = NULL,\n\t\t\t.tx_tout = 500,  \n\t\t},\n\t},\n\t{\n\t\t.name = STM32_MBX_DETACH,\n\t\t.vq_id = -1,\n\t\t.client = {\n\t\t\t.tx_block = true,\n\t\t\t.tx_done = NULL,\n\t\t\t.tx_tout = 200,  \n\t\t},\n\t}\n};\n\nstatic int stm32_rproc_request_mbox(struct rproc *rproc)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct device *dev = &rproc->dev;\n\tunsigned int i;\n\tint j;\n\tconst unsigned char *name;\n\tstruct mbox_client *cl;\n\n\t \n\tmemcpy(ddata->mb, stm32_rproc_mbox, sizeof(stm32_rproc_mbox));\n\n\tfor (i = 0; i < MBOX_NB_MBX; i++) {\n\t\tname = ddata->mb[i].name;\n\n\t\tcl = &ddata->mb[i].client;\n\t\tcl->dev = dev->parent;\n\n\t\tddata->mb[i].chan = mbox_request_channel_byname(cl, name);\n\t\tif (IS_ERR(ddata->mb[i].chan)) {\n\t\t\tif (PTR_ERR(ddata->mb[i].chan) == -EPROBE_DEFER) {\n\t\t\t\tdev_err_probe(dev->parent,\n\t\t\t\t\t      PTR_ERR(ddata->mb[i].chan),\n\t\t\t\t\t      \"failed to request mailbox %s\\n\",\n\t\t\t\t\t      name);\n\t\t\t\tgoto err_probe;\n\t\t\t}\n\t\t\tdev_warn(dev, \"cannot get %s mbox\\n\", name);\n\t\t\tddata->mb[i].chan = NULL;\n\t\t}\n\t\tif (ddata->mb[i].vq_id >= 0) {\n\t\t\tINIT_WORK(&ddata->mb[i].vq_work,\n\t\t\t\t  stm32_rproc_mb_vq_work);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_probe:\n\tfor (j = i - 1; j >= 0; j--)\n\t\tif (ddata->mb[j].chan)\n\t\t\tmbox_free_channel(ddata->mb[j].chan);\n\treturn -EPROBE_DEFER;\n}\n\nstatic int stm32_rproc_set_hold_boot(struct rproc *rproc, bool hold)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct stm32_syscon hold_boot = ddata->hold_boot;\n\tstruct arm_smccc_res smc_res;\n\tint val, err;\n\n\t \n\n\tval = hold ? HOLD_BOOT : RELEASE_BOOT;\n\n\tif (ddata->hold_boot_rst) {\n\t\t \n\t\tif (!hold)\n\t\t\terr = reset_control_deassert(ddata->hold_boot_rst);\n\t\telse\n\t\t\terr =  reset_control_assert(ddata->hold_boot_rst);\n\t} else if (IS_ENABLED(CONFIG_HAVE_ARM_SMCCC) && ddata->hold_boot_smc) {\n\t\t \n\t\tarm_smccc_smc(STM32_SMC_RCC, STM32_SMC_REG_WRITE,\n\t\t\t      hold_boot.reg, val, 0, 0, 0, 0, &smc_res);\n\t\terr = smc_res.a0;\n\t} else {\n\t\t \n\t\terr = regmap_update_bits(hold_boot.map, hold_boot.reg,\n\t\t\t\t\t hold_boot.mask, val);\n\t}\n\n\tif (err)\n\t\tdev_err(&rproc->dev, \"failed to set hold boot\\n\");\n\n\treturn err;\n}\n\nstatic void stm32_rproc_add_coredump_trace(struct rproc *rproc)\n{\n\tstruct rproc_debug_trace *trace;\n\tstruct rproc_dump_segment *segment;\n\tbool already_added;\n\n\tlist_for_each_entry(trace, &rproc->traces, node) {\n\t\talready_added = false;\n\n\t\tlist_for_each_entry(segment, &rproc->dump_segments, node) {\n\t\t\tif (segment->da == trace->trace_mem.da) {\n\t\t\t\talready_added = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!already_added)\n\t\t\trproc_coredump_add_segment(rproc, trace->trace_mem.da,\n\t\t\t\t\t\t   trace->trace_mem.len);\n\t}\n}\n\nstatic int stm32_rproc_start(struct rproc *rproc)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tint err;\n\n\tstm32_rproc_add_coredump_trace(rproc);\n\n\t \n\tif (ddata->pdds.map) {\n\t\terr = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,\n\t\t\t\t\t ddata->pdds.mask, 0);\n\t\tif (err) {\n\t\t\tdev_err(&rproc->dev, \"failed to clear pdds\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = stm32_rproc_set_hold_boot(rproc, false);\n\tif (err)\n\t\treturn err;\n\n\treturn stm32_rproc_set_hold_boot(rproc, true);\n}\n\nstatic int stm32_rproc_attach(struct rproc *rproc)\n{\n\tstm32_rproc_add_coredump_trace(rproc);\n\n\treturn stm32_rproc_set_hold_boot(rproc, true);\n}\n\nstatic int stm32_rproc_detach(struct rproc *rproc)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tint err, idx;\n\n\t \n\tidx = stm32_rproc_mbox_idx(rproc, STM32_MBX_DETACH);\n\tif (idx >= 0 && ddata->mb[idx].chan) {\n\t\terr = mbox_send_message(ddata->mb[idx].chan, \"stop\");\n\t\tif (err < 0)\n\t\t\tdev_warn(&rproc->dev, \"warning: remote FW detach without ack\\n\");\n\t}\n\n\t \n\treturn stm32_rproc_set_hold_boot(rproc, false);\n}\n\nstatic int stm32_rproc_stop(struct rproc *rproc)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tint err, idx;\n\n\t \n\tif (rproc->state != RPROC_OFFLINE && rproc->state != RPROC_CRASHED) {\n\t\tidx = stm32_rproc_mbox_idx(rproc, STM32_MBX_SHUTDOWN);\n\t\tif (idx >= 0 && ddata->mb[idx].chan) {\n\t\t\terr = mbox_send_message(ddata->mb[idx].chan, \"detach\");\n\t\t\tif (err < 0)\n\t\t\t\tdev_warn(&rproc->dev, \"warning: remote FW shutdown without ack\\n\");\n\t\t}\n\t}\n\n\terr = stm32_rproc_set_hold_boot(rproc, true);\n\tif (err)\n\t\treturn err;\n\n\terr = reset_control_assert(ddata->rst);\n\tif (err) {\n\t\tdev_err(&rproc->dev, \"failed to assert the reset\\n\");\n\t\treturn err;\n\t}\n\n\t \n\tif (ddata->pdds.map) {\n\t\terr = regmap_update_bits(ddata->pdds.map, ddata->pdds.reg,\n\t\t\t\t\t ddata->pdds.mask, 1);\n\t\tif (err) {\n\t\t\tdev_err(&rproc->dev, \"failed to set pdds\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tif (ddata->m4_state.map) {\n\t\terr = regmap_update_bits(ddata->m4_state.map,\n\t\t\t\t\t ddata->m4_state.reg,\n\t\t\t\t\t ddata->m4_state.mask,\n\t\t\t\t\t M4_STATE_OFF);\n\t\tif (err) {\n\t\t\tdev_err(&rproc->dev, \"failed to set copro state\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void stm32_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tunsigned int i;\n\tint err;\n\n\tif (WARN_ON(vqid >= MBOX_NB_VQ))\n\t\treturn;\n\n\tfor (i = 0; i < MBOX_NB_MBX; i++) {\n\t\tif (vqid != ddata->mb[i].vq_id)\n\t\t\tcontinue;\n\t\tif (!ddata->mb[i].chan)\n\t\t\treturn;\n\t\terr = mbox_send_message(ddata->mb[i].chan, \"kick\");\n\t\tif (err < 0)\n\t\t\tdev_err(&rproc->dev, \"%s: failed (%s, err:%d)\\n\",\n\t\t\t\t__func__, ddata->mb[i].name, err);\n\t\treturn;\n\t}\n}\n\nstatic int stm32_rproc_da_to_pa(struct rproc *rproc,\n\t\t\t\tu64 da, phys_addr_t *pa)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tstruct stm32_rproc_mem *p_mem;\n\tunsigned int i;\n\n\tfor (i = 0; i < ddata->nb_rmems; i++) {\n\t\tp_mem = &ddata->rmems[i];\n\n\t\tif (da < p_mem->dev_addr ||\n\t\t    da >= p_mem->dev_addr + p_mem->size)\n\t\t\tcontinue;\n\n\t\t*pa = da - p_mem->dev_addr + p_mem->bus_addr;\n\t\tdev_dbg(dev, \"da %llx to pa %pap\\n\", da, pa);\n\n\t\treturn 0;\n\t}\n\n\tdev_err(dev, \"can't translate da %llx\\n\", da);\n\n\treturn -EINVAL;\n}\n\nstatic struct resource_table *\nstm32_rproc_get_loaded_rsc_table(struct rproc *rproc, size_t *table_sz)\n{\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tphys_addr_t rsc_pa;\n\tu32 rsc_da;\n\tint err;\n\n\t \n\tif (ddata->rsc_va)\n\t\tgoto done;\n\n\terr = regmap_read(ddata->rsctbl.map, ddata->rsctbl.reg, &rsc_da);\n\tif (err) {\n\t\tdev_err(dev, \"failed to read rsc tbl addr\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (!rsc_da)\n\t\t \n\t\treturn ERR_PTR(-ENOENT);\n\n\terr = stm32_rproc_da_to_pa(rproc, rsc_da, &rsc_pa);\n\tif (err)\n\t\treturn ERR_PTR(err);\n\n\tddata->rsc_va = devm_ioremap_wc(dev, rsc_pa, RSC_TBL_SIZE);\n\tif (IS_ERR_OR_NULL(ddata->rsc_va)) {\n\t\tdev_err(dev, \"Unable to map memory region: %pa+%x\\n\",\n\t\t\t&rsc_pa, RSC_TBL_SIZE);\n\t\tddata->rsc_va = NULL;\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\ndone:\n\t \n\t*table_sz = RSC_TBL_SIZE;\n\treturn (struct resource_table *)ddata->rsc_va;\n}\n\nstatic const struct rproc_ops st_rproc_ops = {\n\t.prepare\t= stm32_rproc_prepare,\n\t.start\t\t= stm32_rproc_start,\n\t.stop\t\t= stm32_rproc_stop,\n\t.attach\t\t= stm32_rproc_attach,\n\t.detach\t\t= stm32_rproc_detach,\n\t.kick\t\t= stm32_rproc_kick,\n\t.load\t\t= rproc_elf_load_segments,\n\t.parse_fw\t= stm32_rproc_parse_fw,\n\t.find_loaded_rsc_table = rproc_elf_find_loaded_rsc_table,\n\t.get_loaded_rsc_table = stm32_rproc_get_loaded_rsc_table,\n\t.sanity_check\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n};\n\nstatic const struct of_device_id stm32_rproc_match[] = {\n\t{ .compatible = \"st,stm32mp1-m4\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stm32_rproc_match);\n\nstatic int stm32_rproc_get_syscon(struct device_node *np, const char *prop,\n\t\t\t\t  struct stm32_syscon *syscon)\n{\n\tint err = 0;\n\n\tsyscon->map = syscon_regmap_lookup_by_phandle(np, prop);\n\tif (IS_ERR(syscon->map)) {\n\t\terr = PTR_ERR(syscon->map);\n\t\tsyscon->map = NULL;\n\t\tgoto out;\n\t}\n\n\terr = of_property_read_u32_index(np, prop, 1, &syscon->reg);\n\tif (err)\n\t\tgoto out;\n\n\terr = of_property_read_u32_index(np, prop, 2, &syscon->mask);\n\nout:\n\treturn err;\n}\n\nstatic int stm32_rproc_parse_dt(struct platform_device *pdev,\n\t\t\t\tstruct stm32_rproc *ddata, bool *auto_boot)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct stm32_syscon tz;\n\tunsigned int tzen;\n\tint err, irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq == -EPROBE_DEFER)\n\t\treturn dev_err_probe(dev, irq, \"failed to get interrupt\\n\");\n\n\tif (irq > 0) {\n\t\terr = devm_request_irq(dev, irq, stm32_rproc_wdg, 0,\n\t\t\t\t       dev_name(dev), pdev);\n\t\tif (err)\n\t\t\treturn dev_err_probe(dev, err,\n\t\t\t\t\t     \"failed to request wdg irq\\n\");\n\n\t\tddata->wdg_irq = irq;\n\n\t\tif (of_property_read_bool(np, \"wakeup-source\")) {\n\t\t\tdevice_init_wakeup(dev, true);\n\t\t\tdev_pm_set_wake_irq(dev, irq);\n\t\t}\n\n\t\tdev_info(dev, \"wdg irq registered\\n\");\n\t}\n\n\tddata->rst = devm_reset_control_get_optional(dev, \"mcu_rst\");\n\tif (!ddata->rst) {\n\t\t \n\t\tddata->rst = devm_reset_control_get_by_index(dev, 0);\n\t}\n\tif (IS_ERR(ddata->rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(ddata->rst),\n\t\t\t\t     \"failed to get mcu_reset\\n\");\n\n\t \n\n\tddata->hold_boot_rst = devm_reset_control_get_optional(dev, \"hold_boot\");\n\tif (IS_ERR(ddata->hold_boot_rst))\n\t\treturn dev_err_probe(dev, PTR_ERR(ddata->hold_boot_rst),\n\t\t\t\t     \"failed to get hold_boot reset\\n\");\n\n\tif (!ddata->hold_boot_rst && IS_ENABLED(CONFIG_HAVE_ARM_SMCCC)) {\n\t\t \n\t\terr = stm32_rproc_get_syscon(np, \"st,syscfg-tz\", &tz);\n\t\tif (!err) {\n\t\t\terr = regmap_read(tz.map, tz.reg, &tzen);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev, \"failed to read tzen\\n\");\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tddata->hold_boot_smc = tzen & tz.mask;\n\t\t}\n\t}\n\n\tif (!ddata->hold_boot_rst && !ddata->hold_boot_smc) {\n\t\t \n\t\terr = stm32_rproc_get_syscon(np, \"st,syscfg-holdboot\",\n\t\t\t\t\t     &ddata->hold_boot);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to get hold boot\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\terr = stm32_rproc_get_syscon(np, \"st,syscfg-pdds\", &ddata->pdds);\n\tif (err)\n\t\tdev_info(dev, \"failed to get pdds\\n\");\n\n\t*auto_boot = of_property_read_bool(np, \"st,auto-boot\");\n\n\t \n\terr = stm32_rproc_get_syscon(np, \"st,syscfg-m4-state\",\n\t\t\t\t     &ddata->m4_state);\n\tif (err) {\n\t\t \n\t\tddata->m4_state.map = NULL;\n\t\t \n\t\tdev_warn(dev, \"m4 state not supported\\n\");\n\n\t\t \n\t\treturn 0;\n\t}\n\n\t \n\terr = stm32_rproc_get_syscon(np, \"st,syscfg-rsc-tbl\",\n\t\t\t\t     &ddata->rsctbl);\n\tif (err) {\n\t\t \n\t\tdev_warn(dev, \"rsc tbl syscon not supported\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int stm32_rproc_get_m4_status(struct stm32_rproc *ddata,\n\t\t\t\t     unsigned int *state)\n{\n\t \n\tif (!ddata->m4_state.map) {\n\t\t \n\t\t*state = M4_STATE_OFF;\n\t\treturn 0;\n\t}\n\n\treturn regmap_read(ddata->m4_state.map, ddata->m4_state.reg, state);\n}\n\nstatic int stm32_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct stm32_rproc *ddata;\n\tstruct device_node *np = dev->of_node;\n\tstruct rproc *rproc;\n\tunsigned int state;\n\tint ret;\n\n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\trproc = rproc_alloc(dev, np->name, &st_rproc_ops, NULL, sizeof(*ddata));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\tddata = rproc->priv;\n\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\tret = stm32_rproc_parse_dt(pdev, ddata, &rproc->auto_boot);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = stm32_rproc_of_memory_translations(pdev, ddata);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = stm32_rproc_get_m4_status(ddata, &state);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tif (state == M4_STATE_CRUN)\n\t\trproc->state = RPROC_DETACHED;\n\n\trproc->has_iommu = false;\n\tddata->workqueue = create_workqueue(dev_name(dev));\n\tif (!ddata->workqueue) {\n\t\tdev_err(dev, \"cannot create workqueue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_resources;\n\t}\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\tret = stm32_rproc_request_mbox(rproc);\n\tif (ret)\n\t\tgoto free_wkq;\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto free_mb;\n\n\treturn 0;\n\nfree_mb:\n\tstm32_rproc_free_mbox(rproc);\nfree_wkq:\n\tdestroy_workqueue(ddata->workqueue);\nfree_resources:\n\trproc_resource_cleanup(rproc);\nfree_rproc:\n\tif (device_may_wakeup(dev)) {\n\t\tdev_pm_clear_wake_irq(dev);\n\t\tdevice_init_wakeup(dev, false);\n\t}\n\trproc_free(rproc);\n\treturn ret;\n}\n\nstatic void stm32_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct stm32_rproc *ddata = rproc->priv;\n\tstruct device *dev = &pdev->dev;\n\n\tif (atomic_read(&rproc->power) > 0)\n\t\trproc_shutdown(rproc);\n\n\trproc_del(rproc);\n\tstm32_rproc_free_mbox(rproc);\n\tdestroy_workqueue(ddata->workqueue);\n\n\tif (device_may_wakeup(dev)) {\n\t\tdev_pm_clear_wake_irq(dev);\n\t\tdevice_init_wakeup(dev, false);\n\t}\n\trproc_free(rproc);\n}\n\nstatic int stm32_rproc_suspend(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct stm32_rproc *ddata = rproc->priv;\n\n\tif (device_may_wakeup(dev))\n\t\treturn enable_irq_wake(ddata->wdg_irq);\n\n\treturn 0;\n}\n\nstatic int stm32_rproc_resume(struct device *dev)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\tstruct stm32_rproc *ddata = rproc->priv;\n\n\tif (device_may_wakeup(dev))\n\t\treturn disable_irq_wake(ddata->wdg_irq);\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(stm32_rproc_pm_ops,\n\t\t\t\tstm32_rproc_suspend, stm32_rproc_resume);\n\nstatic struct platform_driver stm32_rproc_driver = {\n\t.probe = stm32_rproc_probe,\n\t.remove_new = stm32_rproc_remove,\n\t.driver = {\n\t\t.name = \"stm32-rproc\",\n\t\t.pm = pm_ptr(&stm32_rproc_pm_ops),\n\t\t.of_match_table = stm32_rproc_match,\n\t},\n};\nmodule_platform_driver(stm32_rproc_driver);\n\nMODULE_DESCRIPTION(\"STM32 Remote Processor Control Driver\");\nMODULE_AUTHOR(\"Ludovic Barre <ludovic.barre@st.com>\");\nMODULE_AUTHOR(\"Fabien Dessenne <fabien.dessenne@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}