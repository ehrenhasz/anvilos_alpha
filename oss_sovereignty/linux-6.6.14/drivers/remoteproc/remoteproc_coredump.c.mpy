{
  "module_name": "remoteproc_coredump.c",
  "hash_id": "816003b43a657e4008e4a605c181b82eb571324638a3684d16997e591100eeb4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_coredump.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/devcoredump.h>\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/remoteproc.h>\n#include \"remoteproc_internal.h\"\n#include \"remoteproc_elf_helpers.h\"\n\nstruct rproc_coredump_state {\n\tstruct rproc *rproc;\n\tvoid *header;\n\tstruct completion dump_done;\n};\n\n \nvoid rproc_coredump_cleanup(struct rproc *rproc)\n{\n\tstruct rproc_dump_segment *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &rproc->dump_segments, node) {\n\t\tlist_del(&entry->node);\n\t\tkfree(entry);\n\t}\n}\nEXPORT_SYMBOL_GPL(rproc_coredump_cleanup);\n\n \nint rproc_coredump_add_segment(struct rproc *rproc, dma_addr_t da, size_t size)\n{\n\tstruct rproc_dump_segment *segment;\n\n\tsegment = kzalloc(sizeof(*segment), GFP_KERNEL);\n\tif (!segment)\n\t\treturn -ENOMEM;\n\n\tsegment->da = da;\n\tsegment->size = size;\n\n\tlist_add_tail(&segment->node, &rproc->dump_segments);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_coredump_add_segment);\n\n \nint rproc_coredump_add_custom_segment(struct rproc *rproc,\n\t\t\t\t      dma_addr_t da, size_t size,\n\t\t\t\t      void (*dumpfn)(struct rproc *rproc,\n\t\t\t\t\t\t     struct rproc_dump_segment *segment,\n\t\t\t\t\t\t     void *dest, size_t offset,\n\t\t\t\t\t\t     size_t size),\n\t\t\t\t      void *priv)\n{\n\tstruct rproc_dump_segment *segment;\n\n\tsegment = kzalloc(sizeof(*segment), GFP_KERNEL);\n\tif (!segment)\n\t\treturn -ENOMEM;\n\n\tsegment->da = da;\n\tsegment->size = size;\n\tsegment->priv = priv;\n\tsegment->dump = dumpfn;\n\n\tlist_add_tail(&segment->node, &rproc->dump_segments);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_coredump_add_custom_segment);\n\n \nint rproc_coredump_set_elf_info(struct rproc *rproc, u8 class, u16 machine)\n{\n\tif (class != ELFCLASS64 && class != ELFCLASS32)\n\t\treturn -EINVAL;\n\n\trproc->elf_class = class;\n\trproc->elf_machine = machine;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_coredump_set_elf_info);\n\nstatic void rproc_coredump_free(void *data)\n{\n\tstruct rproc_coredump_state *dump_state = data;\n\n\tvfree(dump_state->header);\n\tcomplete(&dump_state->dump_done);\n}\n\nstatic void *rproc_coredump_find_segment(loff_t user_offset,\n\t\t\t\t\t struct list_head *segments,\n\t\t\t\t\t size_t *data_left)\n{\n\tstruct rproc_dump_segment *segment;\n\n\tlist_for_each_entry(segment, segments, node) {\n\t\tif (user_offset < segment->size) {\n\t\t\t*data_left = segment->size - user_offset;\n\t\t\treturn segment;\n\t\t}\n\t\tuser_offset -= segment->size;\n\t}\n\n\t*data_left = 0;\n\treturn NULL;\n}\n\nstatic void rproc_copy_segment(struct rproc *rproc, void *dest,\n\t\t\t       struct rproc_dump_segment *segment,\n\t\t\t       size_t offset, size_t size)\n{\n\tbool is_iomem = false;\n\tvoid *ptr;\n\n\tif (segment->dump) {\n\t\tsegment->dump(rproc, segment, dest, offset, size);\n\t} else {\n\t\tptr = rproc_da_to_va(rproc, segment->da + offset, size, &is_iomem);\n\t\tif (!ptr) {\n\t\t\tdev_err(&rproc->dev,\n\t\t\t\t\"invalid copy request for segment %pad with offset %zu and size %zu)\\n\",\n\t\t\t\t&segment->da, offset, size);\n\t\t\tmemset(dest, 0xff, size);\n\t\t} else {\n\t\t\tif (is_iomem)\n\t\t\t\tmemcpy_fromio(dest, (void const __iomem *)ptr, size);\n\t\t\telse\n\t\t\t\tmemcpy(dest, ptr, size);\n\t\t}\n\t}\n}\n\nstatic ssize_t rproc_coredump_read(char *buffer, loff_t offset, size_t count,\n\t\t\t\t   void *data, size_t header_sz)\n{\n\tsize_t seg_data, bytes_left = count;\n\tssize_t copy_sz;\n\tstruct rproc_dump_segment *seg;\n\tstruct rproc_coredump_state *dump_state = data;\n\tstruct rproc *rproc = dump_state->rproc;\n\tvoid *elfcore = dump_state->header;\n\n\t \n\tif (offset < header_sz) {\n\t\tcopy_sz = memory_read_from_buffer(buffer, count, &offset,\n\t\t\t\t\t\t  elfcore, header_sz);\n\n\t\treturn copy_sz;\n\t}\n\n\t \n\twhile (bytes_left) {\n\t\tseg = rproc_coredump_find_segment(offset - header_sz,\n\t\t\t\t\t\t  &rproc->dump_segments,\n\t\t\t\t\t\t  &seg_data);\n\t\t \n\t\tif (!seg) {\n\t\t\tdev_info(&rproc->dev, \"Ramdump done, %lld bytes read\",\n\t\t\t\t offset);\n\t\t\tbreak;\n\t\t}\n\n\t\tcopy_sz = min_t(size_t, bytes_left, seg_data);\n\n\t\trproc_copy_segment(rproc, buffer, seg, seg->size - seg_data,\n\t\t\t\t   copy_sz);\n\n\t\toffset += copy_sz;\n\t\tbuffer += copy_sz;\n\t\tbytes_left -= copy_sz;\n\t}\n\n\treturn count - bytes_left;\n}\n\n \nvoid rproc_coredump(struct rproc *rproc)\n{\n\tstruct rproc_dump_segment *segment;\n\tvoid *phdr;\n\tvoid *ehdr;\n\tsize_t data_size;\n\tsize_t offset;\n\tvoid *data;\n\tu8 class = rproc->elf_class;\n\tint phnum = 0;\n\tstruct rproc_coredump_state dump_state;\n\tenum rproc_dump_mechanism dump_conf = rproc->dump_conf;\n\n\tif (list_empty(&rproc->dump_segments) ||\n\t    dump_conf == RPROC_COREDUMP_DISABLED)\n\t\treturn;\n\n\tif (class == ELFCLASSNONE) {\n\t\tdev_err(&rproc->dev, \"ELF class is not set\\n\");\n\t\treturn;\n\t}\n\n\tdata_size = elf_size_of_hdr(class);\n\tlist_for_each_entry(segment, &rproc->dump_segments, node) {\n\t\t \n\t\tdata_size += elf_size_of_phdr(class);\n\t\tif (dump_conf == RPROC_COREDUMP_ENABLED)\n\t\t\tdata_size += segment->size;\n\n\t\tphnum++;\n\t}\n\n\tdata = vmalloc(data_size);\n\tif (!data)\n\t\treturn;\n\n\tehdr = data;\n\n\tmemset(ehdr, 0, elf_size_of_hdr(class));\n\t \n\telf_hdr_init_ident(ehdr, class);\n\n\telf_hdr_set_e_type(class, ehdr, ET_CORE);\n\telf_hdr_set_e_machine(class, ehdr, rproc->elf_machine);\n\telf_hdr_set_e_version(class, ehdr, EV_CURRENT);\n\telf_hdr_set_e_entry(class, ehdr, rproc->bootaddr);\n\telf_hdr_set_e_phoff(class, ehdr, elf_size_of_hdr(class));\n\telf_hdr_set_e_ehsize(class, ehdr, elf_size_of_hdr(class));\n\telf_hdr_set_e_phentsize(class, ehdr, elf_size_of_phdr(class));\n\telf_hdr_set_e_phnum(class, ehdr, phnum);\n\n\tphdr = data + elf_hdr_get_e_phoff(class, ehdr);\n\toffset = elf_hdr_get_e_phoff(class, ehdr);\n\toffset += elf_size_of_phdr(class) * elf_hdr_get_e_phnum(class, ehdr);\n\n\tlist_for_each_entry(segment, &rproc->dump_segments, node) {\n\t\tmemset(phdr, 0, elf_size_of_phdr(class));\n\t\telf_phdr_set_p_type(class, phdr, PT_LOAD);\n\t\telf_phdr_set_p_offset(class, phdr, offset);\n\t\telf_phdr_set_p_vaddr(class, phdr, segment->da);\n\t\telf_phdr_set_p_paddr(class, phdr, segment->da);\n\t\telf_phdr_set_p_filesz(class, phdr, segment->size);\n\t\telf_phdr_set_p_memsz(class, phdr, segment->size);\n\t\telf_phdr_set_p_flags(class, phdr, PF_R | PF_W | PF_X);\n\t\telf_phdr_set_p_align(class, phdr, 0);\n\n\t\tif (dump_conf == RPROC_COREDUMP_ENABLED)\n\t\t\trproc_copy_segment(rproc, data + offset, segment, 0,\n\t\t\t\t\t   segment->size);\n\n\t\toffset += elf_phdr_get_p_filesz(class, phdr);\n\t\tphdr += elf_size_of_phdr(class);\n\t}\n\tif (dump_conf == RPROC_COREDUMP_ENABLED) {\n\t\tdev_coredumpv(&rproc->dev, data, data_size, GFP_KERNEL);\n\t\treturn;\n\t}\n\n\t \n\tdump_state.rproc = rproc;\n\tdump_state.header = data;\n\tinit_completion(&dump_state.dump_done);\n\n\tdev_coredumpm(&rproc->dev, NULL, &dump_state, data_size, GFP_KERNEL,\n\t\t      rproc_coredump_read, rproc_coredump_free);\n\n\t \n\twait_for_completion(&dump_state.dump_done);\n}\nEXPORT_SYMBOL_GPL(rproc_coredump);\n\n \nvoid rproc_coredump_using_sections(struct rproc *rproc)\n{\n\tstruct rproc_dump_segment *segment;\n\tvoid *shdr;\n\tvoid *ehdr;\n\tsize_t data_size;\n\tsize_t strtbl_size = 0;\n\tsize_t strtbl_index = 1;\n\tsize_t offset;\n\tvoid *data;\n\tu8 class = rproc->elf_class;\n\tint shnum;\n\tstruct rproc_coredump_state dump_state;\n\tunsigned int dump_conf = rproc->dump_conf;\n\tchar *str_tbl = \"STR_TBL\";\n\n\tif (list_empty(&rproc->dump_segments) ||\n\t    dump_conf == RPROC_COREDUMP_DISABLED)\n\t\treturn;\n\n\tif (class == ELFCLASSNONE) {\n\t\tdev_err(&rproc->dev, \"ELF class is not set\\n\");\n\t\treturn;\n\t}\n\n\t \n\tdata_size = elf_size_of_hdr(class) + 2 * elf_size_of_shdr(class);\n\tshnum = 2;\n\n\t \n\tstrtbl_size += strlen(str_tbl) + 2;\n\n\tlist_for_each_entry(segment, &rproc->dump_segments, node) {\n\t\tdata_size += elf_size_of_shdr(class);\n\t\tstrtbl_size += strlen(segment->priv) + 1;\n\t\tif (dump_conf == RPROC_COREDUMP_ENABLED)\n\t\t\tdata_size += segment->size;\n\t\tshnum++;\n\t}\n\n\tdata_size += strtbl_size;\n\n\tdata = vmalloc(data_size);\n\tif (!data)\n\t\treturn;\n\n\tehdr = data;\n\tmemset(ehdr, 0, elf_size_of_hdr(class));\n\t \n\telf_hdr_init_ident(ehdr, class);\n\n\telf_hdr_set_e_type(class, ehdr, ET_CORE);\n\telf_hdr_set_e_machine(class, ehdr, rproc->elf_machine);\n\telf_hdr_set_e_version(class, ehdr, EV_CURRENT);\n\telf_hdr_set_e_entry(class, ehdr, rproc->bootaddr);\n\telf_hdr_set_e_shoff(class, ehdr, elf_size_of_hdr(class));\n\telf_hdr_set_e_ehsize(class, ehdr, elf_size_of_hdr(class));\n\telf_hdr_set_e_shentsize(class, ehdr, elf_size_of_shdr(class));\n\telf_hdr_set_e_shnum(class, ehdr, shnum);\n\telf_hdr_set_e_shstrndx(class, ehdr, 1);\n\n\t \n\tshdr = data + elf_hdr_get_e_shoff(class, ehdr);\n\tmemset(shdr, 0, elf_size_of_shdr(class));\n\tshdr += elf_size_of_shdr(class);\n\n\t \n\toffset = elf_hdr_get_e_shoff(class, ehdr) +\n\t\t elf_size_of_shdr(class) * elf_hdr_get_e_shnum(class, ehdr);\n\tmemset(data + offset, 0, strtbl_size);\n\n\t \n\tmemset(shdr, 0, elf_size_of_shdr(class));\n\telf_shdr_set_sh_type(class, shdr, SHT_STRTAB);\n\telf_shdr_set_sh_offset(class, shdr, offset);\n\telf_shdr_set_sh_size(class, shdr, strtbl_size);\n\telf_shdr_set_sh_entsize(class, shdr, 0);\n\telf_shdr_set_sh_flags(class, shdr, 0);\n\telf_shdr_set_sh_name(class, shdr, elf_strtbl_add(str_tbl, ehdr, class, &strtbl_index));\n\toffset += elf_shdr_get_sh_size(class, shdr);\n\tshdr += elf_size_of_shdr(class);\n\n\tlist_for_each_entry(segment, &rproc->dump_segments, node) {\n\t\tmemset(shdr, 0, elf_size_of_shdr(class));\n\t\telf_shdr_set_sh_type(class, shdr, SHT_PROGBITS);\n\t\telf_shdr_set_sh_offset(class, shdr, offset);\n\t\telf_shdr_set_sh_addr(class, shdr, segment->da);\n\t\telf_shdr_set_sh_size(class, shdr, segment->size);\n\t\telf_shdr_set_sh_entsize(class, shdr, 0);\n\t\telf_shdr_set_sh_flags(class, shdr, SHF_WRITE);\n\t\telf_shdr_set_sh_name(class, shdr,\n\t\t\t\t     elf_strtbl_add(segment->priv, ehdr, class, &strtbl_index));\n\n\t\t \n\t\tif (dump_conf == RPROC_COREDUMP_ENABLED)\n\t\t\trproc_copy_segment(rproc, data + offset, segment, 0,\n\t\t\t\t\t   segment->size);\n\t\toffset += elf_shdr_get_sh_size(class, shdr);\n\t\tshdr += elf_size_of_shdr(class);\n\t}\n\n\tif (dump_conf == RPROC_COREDUMP_ENABLED) {\n\t\tdev_coredumpv(&rproc->dev, data, data_size, GFP_KERNEL);\n\t\treturn;\n\t}\n\n\t \n\tdump_state.rproc = rproc;\n\tdump_state.header = data;\n\tinit_completion(&dump_state.dump_done);\n\n\tdev_coredumpm(&rproc->dev, NULL, &dump_state, data_size, GFP_KERNEL,\n\t\t      rproc_coredump_read, rproc_coredump_free);\n\n\t \n\twait_for_completion(&dump_state.dump_done);\n}\nEXPORT_SYMBOL(rproc_coredump_using_sections);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}