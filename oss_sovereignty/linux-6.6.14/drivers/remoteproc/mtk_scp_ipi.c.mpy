{
  "module_name": "mtk_scp_ipi.c",
  "hash_id": "34f5104a4acbf5c0b252ba9ab15821dbce3b7764f66fcd21bc28a566e336d30a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/mtk_scp_ipi.c",
  "human_readable_source": "\n\n\n\n#include <asm/barrier.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/time64.h>\n#include <linux/remoteproc/mtk_scp.h>\n\n#include \"mtk_common.h\"\n\n#define SCP_TIMEOUT_US\t\t(2000 * USEC_PER_MSEC)\n\n \nint scp_ipi_register(struct mtk_scp *scp,\n\t\t     u32 id,\n\t\t     scp_ipi_handler_t handler,\n\t\t     void *priv)\n{\n\tif (!scp)\n\t\treturn -EPROBE_DEFER;\n\n\tif (WARN_ON(id >= SCP_IPI_MAX) || WARN_ON(handler == NULL))\n\t\treturn -EINVAL;\n\n\tscp_ipi_lock(scp, id);\n\tscp->ipi_desc[id].handler = handler;\n\tscp->ipi_desc[id].priv = priv;\n\tscp_ipi_unlock(scp, id);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(scp_ipi_register);\n\n \nvoid scp_ipi_unregister(struct mtk_scp *scp, u32 id)\n{\n\tif (!scp)\n\t\treturn;\n\n\tif (WARN_ON(id >= SCP_IPI_MAX))\n\t\treturn;\n\n\tscp_ipi_lock(scp, id);\n\tscp->ipi_desc[id].handler = NULL;\n\tscp->ipi_desc[id].priv = NULL;\n\tscp_ipi_unlock(scp, id);\n}\nEXPORT_SYMBOL_GPL(scp_ipi_unregister);\n\n \nvoid scp_memcpy_aligned(void __iomem *dst, const void *src, unsigned int len)\n{\n\tvoid __iomem *ptr;\n\tu32 val;\n\tunsigned int i = 0, remain;\n\n\tif (!IS_ALIGNED((unsigned long)dst, 4)) {\n\t\tptr = (void __iomem *)ALIGN_DOWN((unsigned long)dst, 4);\n\t\ti = 4 - (dst - ptr);\n\t\tval = readl_relaxed(ptr);\n\t\tmemcpy((u8 *)&val + (4 - i), src, i);\n\t\twritel_relaxed(val, ptr);\n\t}\n\n\t__iowrite32_copy(dst + i, src + i, (len - i) / 4);\n\tremain = (len - i) % 4;\n\n\tif (remain > 0) {\n\t\tval = readl_relaxed(dst + len - remain);\n\t\tmemcpy(&val, src + len - remain, remain);\n\t\twritel_relaxed(val, dst + len - remain);\n\t}\n}\nEXPORT_SYMBOL_GPL(scp_memcpy_aligned);\n\n \nvoid scp_ipi_lock(struct mtk_scp *scp, u32 id)\n{\n\tif (WARN_ON(id >= SCP_IPI_MAX))\n\t\treturn;\n\tmutex_lock(&scp->ipi_desc[id].lock);\n}\nEXPORT_SYMBOL_GPL(scp_ipi_lock);\n\n \nvoid scp_ipi_unlock(struct mtk_scp *scp, u32 id)\n{\n\tif (WARN_ON(id >= SCP_IPI_MAX))\n\t\treturn;\n\tmutex_unlock(&scp->ipi_desc[id].lock);\n}\nEXPORT_SYMBOL_GPL(scp_ipi_unlock);\n\n \nint scp_ipi_send(struct mtk_scp *scp, u32 id, void *buf, unsigned int len,\n\t\t unsigned int wait)\n{\n\tstruct mtk_share_obj __iomem *send_obj = scp->send_buf;\n\tu32 val;\n\tint ret;\n\n\tif (WARN_ON(id <= SCP_IPI_INIT) || WARN_ON(id >= SCP_IPI_MAX) ||\n\t    WARN_ON(id == SCP_IPI_NS_SERVICE) ||\n\t    WARN_ON(len > sizeof(send_obj->share_buf)) || WARN_ON(!buf))\n\t\treturn -EINVAL;\n\n\tret = clk_prepare_enable(scp->clk);\n\tif (ret) {\n\t\tdev_err(scp->dev, \"failed to enable clock\\n\");\n\t\treturn ret;\n\t}\n\n\tmutex_lock(&scp->send_lock);\n\n\t  \n\tret = readl_poll_timeout_atomic(scp->reg_base + scp->data->host_to_scp_reg,\n\t\t\t\t\tval, !val, 0, SCP_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(scp->dev, \"%s: IPI timeout!\\n\", __func__);\n\t\tgoto unlock_mutex;\n\t}\n\n\tscp_memcpy_aligned(send_obj->share_buf, buf, len);\n\n\twritel(len, &send_obj->len);\n\twritel(id, &send_obj->id);\n\n\tscp->ipi_id_ack[id] = false;\n\t \n\twritel(scp->data->host_to_scp_int_bit,\n\t       scp->reg_base + scp->data->host_to_scp_reg);\n\n\tif (wait) {\n\t\t \n\t\tret = wait_event_timeout(scp->ack_wq,\n\t\t\t\t\t scp->ipi_id_ack[id],\n\t\t\t\t\t msecs_to_jiffies(wait));\n\t\tscp->ipi_id_ack[id] = false;\n\t\tif (WARN(!ret, \"scp ipi %d ack time out !\", id))\n\t\t\tret = -EIO;\n\t\telse\n\t\t\tret = 0;\n\t}\n\nunlock_mutex:\n\tmutex_unlock(&scp->send_lock);\n\tclk_disable_unprepare(scp->clk);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(scp_ipi_send);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek scp IPI interface\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}