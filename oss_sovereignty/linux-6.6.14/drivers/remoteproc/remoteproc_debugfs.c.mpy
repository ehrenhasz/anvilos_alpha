{
  "module_name": "remoteproc_debugfs.c",
  "hash_id": "4d5b5046bed98514b37603c3859e0fa10a72382c6e39d41f9d2216f43a4d1abb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_debugfs.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    \"%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <linux/remoteproc.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n\n#include \"remoteproc_internal.h\"\n\n \nstatic struct dentry *rproc_dbg;\n\n \nstatic const char * const rproc_coredump_str[] = {\n\t[RPROC_COREDUMP_DISABLED]\t= \"disabled\",\n\t[RPROC_COREDUMP_ENABLED]\t= \"enabled\",\n\t[RPROC_COREDUMP_INLINE]\t\t= \"inline\",\n};\n\n \nstatic ssize_t rproc_coredump_read(struct file *filp, char __user *userbuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\tchar buf[20];\n\tint len;\n\n\tlen = scnprintf(buf, sizeof(buf), \"%s\\n\",\n\t\t\trproc_coredump_str[rproc->dump_conf]);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, len);\n}\n\n \nstatic ssize_t rproc_coredump_write(struct file *filp,\n\t\t\t\t    const char __user *user_buf, size_t count,\n\t\t\t\t    loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\tint ret, err = 0;\n\tchar buf[20];\n\n\tif (count < 1 || count > sizeof(buf))\n\t\treturn -EINVAL;\n\n\tret = copy_from_user(buf, user_buf, count);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t \n\tif (buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\n\tif (rproc->state == RPROC_CRASHED) {\n\t\tdev_err(&rproc->dev, \"can't change coredump configuration\\n\");\n\t\terr = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tif (!strncmp(buf, \"disabled\", count)) {\n\t\trproc->dump_conf = RPROC_COREDUMP_DISABLED;\n\t} else if (!strncmp(buf, \"enabled\", count)) {\n\t\trproc->dump_conf = RPROC_COREDUMP_ENABLED;\n\t} else if (!strncmp(buf, \"inline\", count)) {\n\t\trproc->dump_conf = RPROC_COREDUMP_INLINE;\n\t} else {\n\t\tdev_err(&rproc->dev, \"Invalid coredump configuration\\n\");\n\t\terr = -EINVAL;\n\t}\nout:\n\treturn err ? err : count;\n}\n\nstatic const struct file_operations rproc_coredump_fops = {\n\t.read = rproc_coredump_read,\n\t.write = rproc_coredump_write,\n\t.open = simple_open,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic ssize_t rproc_trace_read(struct file *filp, char __user *userbuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct rproc_debug_trace *data = filp->private_data;\n\tstruct rproc_mem_entry *trace = &data->trace_mem;\n\tvoid *va;\n\tchar buf[100];\n\tint len;\n\n\tva = rproc_da_to_va(data->rproc, trace->da, trace->len, NULL);\n\n\tif (!va) {\n\t\tlen = scnprintf(buf, sizeof(buf), \"Trace %s not available\\n\",\n\t\t\t\ttrace->name);\n\t\tva = buf;\n\t} else {\n\t\tlen = strnlen(va, trace->len);\n\t}\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, va, len);\n}\n\nstatic const struct file_operations trace_rproc_ops = {\n\t.read = rproc_trace_read,\n\t.open = simple_open,\n\t.llseek\t= generic_file_llseek,\n};\n\n \nstatic ssize_t rproc_name_read(struct file *filp, char __user *userbuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\t \n\tchar buf[100];\n\tint i;\n\n\ti = scnprintf(buf, sizeof(buf), \"%.98s\\n\", rproc->name);\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, i);\n}\n\nstatic const struct file_operations rproc_name_ops = {\n\t.read = rproc_name_read,\n\t.open = simple_open,\n\t.llseek\t= generic_file_llseek,\n};\n\n \nstatic ssize_t rproc_recovery_read(struct file *filp, char __user *userbuf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\tchar *buf = rproc->recovery_disabled ? \"disabled\\n\" : \"enabled\\n\";\n\n\treturn simple_read_from_buffer(userbuf, count, ppos, buf, strlen(buf));\n}\n\n \nstatic ssize_t\nrproc_recovery_write(struct file *filp, const char __user *user_buf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\tchar buf[10];\n\tint ret;\n\n\tif (count < 1 || count > sizeof(buf))\n\t\treturn -EINVAL;\n\n\tret = copy_from_user(buf, user_buf, count);\n\tif (ret)\n\t\treturn -EFAULT;\n\n\t \n\tif (buf[count - 1] == '\\n')\n\t\tbuf[count - 1] = '\\0';\n\n\tif (!strncmp(buf, \"enabled\", count)) {\n\t\t \n\t\trproc->recovery_disabled = false;\n\t\trproc_trigger_recovery(rproc);\n\t} else if (!strncmp(buf, \"disabled\", count)) {\n\t\trproc->recovery_disabled = true;\n\t} else if (!strncmp(buf, \"recover\", count)) {\n\t\t \n\t\trproc_trigger_recovery(rproc);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations rproc_recovery_ops = {\n\t.read = rproc_recovery_read,\n\t.write = rproc_recovery_write,\n\t.open = simple_open,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic ssize_t\nrproc_crash_write(struct file *filp, const char __user *user_buf,\n\t\t  size_t count, loff_t *ppos)\n{\n\tstruct rproc *rproc = filp->private_data;\n\tunsigned int type;\n\tint ret;\n\n\tret = kstrtouint_from_user(user_buf, count, 0, &type);\n\tif (ret < 0)\n\t\treturn ret;\n\n\trproc_report_crash(rproc, type);\n\n\treturn count;\n}\n\nstatic const struct file_operations rproc_crash_ops = {\n\t.write = rproc_crash_write,\n\t.open = simple_open,\n\t.llseek = generic_file_llseek,\n};\n\n \nstatic int rproc_rsc_table_show(struct seq_file *seq, void *p)\n{\n\tstatic const char * const types[] = {\"carveout\", \"devmem\", \"trace\", \"vdev\"};\n\tstruct rproc *rproc = seq->private;\n\tstruct resource_table *table = rproc->table_ptr;\n\tstruct fw_rsc_carveout *c;\n\tstruct fw_rsc_devmem *d;\n\tstruct fw_rsc_trace *t;\n\tstruct fw_rsc_vdev *v;\n\tint i, j;\n\n\tif (!table) {\n\t\tseq_puts(seq, \"No resource table found\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < table->num; i++) {\n\t\tint offset = table->offset[i];\n\t\tstruct fw_rsc_hdr *hdr = (void *)table + offset;\n\t\tvoid *rsc = (void *)hdr + sizeof(*hdr);\n\n\t\tswitch (hdr->type) {\n\t\tcase RSC_CARVEOUT:\n\t\t\tc = rsc;\n\t\t\tseq_printf(seq, \"Entry %d is of type %s\\n\", i, types[hdr->type]);\n\t\t\tseq_printf(seq, \"  Device Address 0x%x\\n\", c->da);\n\t\t\tseq_printf(seq, \"  Physical Address 0x%x\\n\", c->pa);\n\t\t\tseq_printf(seq, \"  Length 0x%x Bytes\\n\", c->len);\n\t\t\tseq_printf(seq, \"  Flags 0x%x\\n\", c->flags);\n\t\t\tseq_printf(seq, \"  Reserved (should be zero) [%d]\\n\", c->reserved);\n\t\t\tseq_printf(seq, \"  Name %s\\n\\n\", c->name);\n\t\t\tbreak;\n\t\tcase RSC_DEVMEM:\n\t\t\td = rsc;\n\t\t\tseq_printf(seq, \"Entry %d is of type %s\\n\", i, types[hdr->type]);\n\t\t\tseq_printf(seq, \"  Device Address 0x%x\\n\", d->da);\n\t\t\tseq_printf(seq, \"  Physical Address 0x%x\\n\", d->pa);\n\t\t\tseq_printf(seq, \"  Length 0x%x Bytes\\n\", d->len);\n\t\t\tseq_printf(seq, \"  Flags 0x%x\\n\", d->flags);\n\t\t\tseq_printf(seq, \"  Reserved (should be zero) [%d]\\n\", d->reserved);\n\t\t\tseq_printf(seq, \"  Name %s\\n\\n\", d->name);\n\t\t\tbreak;\n\t\tcase RSC_TRACE:\n\t\t\tt = rsc;\n\t\t\tseq_printf(seq, \"Entry %d is of type %s\\n\", i, types[hdr->type]);\n\t\t\tseq_printf(seq, \"  Device Address 0x%x\\n\", t->da);\n\t\t\tseq_printf(seq, \"  Length 0x%x Bytes\\n\", t->len);\n\t\t\tseq_printf(seq, \"  Reserved (should be zero) [%d]\\n\", t->reserved);\n\t\t\tseq_printf(seq, \"  Name %s\\n\\n\", t->name);\n\t\t\tbreak;\n\t\tcase RSC_VDEV:\n\t\t\tv = rsc;\n\t\t\tseq_printf(seq, \"Entry %d is of type %s\\n\", i, types[hdr->type]);\n\n\t\t\tseq_printf(seq, \"  ID %d\\n\", v->id);\n\t\t\tseq_printf(seq, \"  Notify ID %d\\n\", v->notifyid);\n\t\t\tseq_printf(seq, \"  Device features 0x%x\\n\", v->dfeatures);\n\t\t\tseq_printf(seq, \"  Guest features 0x%x\\n\", v->gfeatures);\n\t\t\tseq_printf(seq, \"  Config length 0x%x\\n\", v->config_len);\n\t\t\tseq_printf(seq, \"  Status 0x%x\\n\", v->status);\n\t\t\tseq_printf(seq, \"  Number of vrings %d\\n\", v->num_of_vrings);\n\t\t\tseq_printf(seq, \"  Reserved (should be zero) [%d][%d]\\n\\n\",\n\t\t\t\t   v->reserved[0], v->reserved[1]);\n\n\t\t\tfor (j = 0; j < v->num_of_vrings; j++) {\n\t\t\t\tseq_printf(seq, \"  Vring %d\\n\", j);\n\t\t\t\tseq_printf(seq, \"    Device Address 0x%x\\n\", v->vring[j].da);\n\t\t\t\tseq_printf(seq, \"    Alignment %d\\n\", v->vring[j].align);\n\t\t\t\tseq_printf(seq, \"    Number of buffers %d\\n\", v->vring[j].num);\n\t\t\t\tseq_printf(seq, \"    Notify ID %d\\n\", v->vring[j].notifyid);\n\t\t\t\tseq_printf(seq, \"    Physical Address 0x%x\\n\\n\",\n\t\t\t\t\t   v->vring[j].pa);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_printf(seq, \"Unknown resource type found: %d [hdr: %pK]\\n\",\n\t\t\t\t   hdr->type, hdr);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rproc_rsc_table);\n\n \nstatic int rproc_carveouts_show(struct seq_file *seq, void *p)\n{\n\tstruct rproc *rproc = seq->private;\n\tstruct rproc_mem_entry *carveout;\n\n\tlist_for_each_entry(carveout, &rproc->carveouts, node) {\n\t\tseq_puts(seq, \"Carveout memory entry:\\n\");\n\t\tseq_printf(seq, \"\\tName: %s\\n\", carveout->name);\n\t\tseq_printf(seq, \"\\tVirtual address: %pK\\n\", carveout->va);\n\t\tseq_printf(seq, \"\\tDMA address: %pad\\n\", &carveout->dma);\n\t\tseq_printf(seq, \"\\tDevice address: 0x%x\\n\", carveout->da);\n\t\tseq_printf(seq, \"\\tLength: 0x%zx Bytes\\n\\n\", carveout->len);\n\t}\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(rproc_carveouts);\n\nvoid rproc_remove_trace_file(struct dentry *tfile)\n{\n\tdebugfs_remove(tfile);\n}\n\nstruct dentry *rproc_create_trace_file(const char *name, struct rproc *rproc,\n\t\t\t\t       struct rproc_debug_trace *trace)\n{\n\treturn debugfs_create_file(name, 0400, rproc->dbg_dir, trace,\n\t\t\t\t    &trace_rproc_ops);\n}\n\nvoid rproc_delete_debug_dir(struct rproc *rproc)\n{\n\tdebugfs_remove_recursive(rproc->dbg_dir);\n}\n\nvoid rproc_create_debug_dir(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\n\tif (!rproc_dbg)\n\t\treturn;\n\n\trproc->dbg_dir = debugfs_create_dir(dev_name(dev), rproc_dbg);\n\n\tdebugfs_create_file(\"name\", 0400, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_name_ops);\n\tdebugfs_create_file(\"recovery\", 0600, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_recovery_ops);\n\tdebugfs_create_file(\"crash\", 0200, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_crash_ops);\n\tdebugfs_create_file(\"resource_table\", 0400, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_rsc_table_fops);\n\tdebugfs_create_file(\"carveout_memories\", 0400, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_carveouts_fops);\n\tdebugfs_create_file(\"coredump\", 0600, rproc->dbg_dir,\n\t\t\t    rproc, &rproc_coredump_fops);\n}\n\nvoid __init rproc_init_debugfs(void)\n{\n\tif (debugfs_initialized())\n\t\trproc_dbg = debugfs_create_dir(KBUILD_MODNAME, NULL);\n}\n\nvoid __exit rproc_exit_debugfs(void)\n{\n\tdebugfs_remove(rproc_dbg);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}