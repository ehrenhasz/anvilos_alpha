{
  "module_name": "st_slim_rproc.c",
  "hash_id": "4c2f3708f5b95a5713fd44fcc30cc290314b13127d563cd53488595db4c2f3e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/st_slim_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/remoteproc/st_slim_rproc.h>\n#include \"remoteproc_internal.h\"\n\n \n#define SLIM_ID_OFST\t\t0x0\n#define SLIM_VER_OFST\t\t0x4\n\n#define SLIM_EN_OFST\t\t0x8\n#define SLIM_EN_RUN\t\t\tBIT(0)\n\n#define SLIM_CLK_GATE_OFST\t0xC\n#define SLIM_CLK_GATE_DIS\t\tBIT(0)\n#define SLIM_CLK_GATE_RESET\t\tBIT(2)\n\n#define SLIM_SLIM_PC_OFST\t0x20\n\n \n#define SLIM_REV_ID_OFST\t0x0\n#define SLIM_REV_ID_MIN_MASK\t\tGENMASK(15, 8)\n#define SLIM_REV_ID_MIN(id)\t\t((id & SLIM_REV_ID_MIN_MASK) >> 8)\n#define SLIM_REV_ID_MAJ_MASK\t\tGENMASK(23, 16)\n#define SLIM_REV_ID_MAJ(id)\t\t((id & SLIM_REV_ID_MAJ_MASK) >> 16)\n\n\n \n#define SLIM_STBUS_SYNC_OFST\t0xF88\n#define SLIM_STBUS_SYNC_DIS\t\tBIT(0)\n\n#define SLIM_INT_SET_OFST\t0xFD4\n#define SLIM_INT_CLR_OFST\t0xFD8\n#define SLIM_INT_MASK_OFST\t0xFDC\n\n#define SLIM_CMD_CLR_OFST\t0xFC8\n#define SLIM_CMD_MASK_OFST\t0xFCC\n\nstatic const char *mem_names[ST_SLIM_MEM_MAX] = {\n\t[ST_SLIM_DMEM]\t= \"dmem\",\n\t[ST_SLIM_IMEM]\t= \"imem\",\n};\n\nstatic int slim_clk_get(struct st_slim_rproc *slim_rproc, struct device *dev)\n{\n\tint clk, err;\n\n\tfor (clk = 0; clk < ST_SLIM_MAX_CLK; clk++) {\n\t\tslim_rproc->clks[clk] = of_clk_get(dev->of_node, clk);\n\t\tif (IS_ERR(slim_rproc->clks[clk])) {\n\t\t\terr = PTR_ERR(slim_rproc->clks[clk]);\n\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\tgoto err_put_clks;\n\t\t\tslim_rproc->clks[clk] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_put_clks:\n\twhile (--clk >= 0)\n\t\tclk_put(slim_rproc->clks[clk]);\n\n\treturn err;\n}\n\nstatic void slim_clk_disable(struct st_slim_rproc *slim_rproc)\n{\n\tint clk;\n\n\tfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++)\n\t\tclk_disable_unprepare(slim_rproc->clks[clk]);\n}\n\nstatic int slim_clk_enable(struct st_slim_rproc *slim_rproc)\n{\n\tint clk, ret;\n\n\tfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++) {\n\t\tret = clk_prepare_enable(slim_rproc->clks[clk]);\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\treturn 0;\n\nerr_disable_clks:\n\twhile (--clk >= 0)\n\t\tclk_disable_unprepare(slim_rproc->clks[clk]);\n\n\treturn ret;\n}\n\n \nstatic int slim_rproc_start(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tstruct st_slim_rproc *slim_rproc = rproc->priv;\n\tunsigned long hw_id, hw_ver, fw_rev;\n\tu32 val;\n\n\t \n\tval = SLIM_CLK_GATE_DIS | SLIM_CLK_GATE_RESET;\n\twritel(val, slim_rproc->slimcore + SLIM_CLK_GATE_OFST);\n\n\t \n\twritel(SLIM_STBUS_SYNC_DIS, slim_rproc->peri + SLIM_STBUS_SYNC_OFST);\n\n\t \n\twritel(!SLIM_CLK_GATE_DIS,\n\t\tslim_rproc->slimcore + SLIM_CLK_GATE_OFST);\n\n\t \n\twritel(~0U, slim_rproc->peri + SLIM_INT_CLR_OFST);\n\twritel(~0U, slim_rproc->peri + SLIM_CMD_CLR_OFST);\n\n\t \n\twritel(~0U, slim_rproc->peri + SLIM_INT_MASK_OFST);\n\twritel(~0U, slim_rproc->peri + SLIM_CMD_MASK_OFST);\n\n\t \n\twritel(SLIM_EN_RUN, slim_rproc->slimcore + SLIM_EN_OFST);\n\n\thw_id = readl_relaxed(slim_rproc->slimcore + SLIM_ID_OFST);\n\thw_ver = readl_relaxed(slim_rproc->slimcore + SLIM_VER_OFST);\n\n\tfw_rev = readl(slim_rproc->mem[ST_SLIM_DMEM].cpu_addr +\n\t\t\tSLIM_REV_ID_OFST);\n\n\tdev_info(dev, \"fw rev:%ld.%ld on SLIM %ld.%ld\\n\",\n\t\t SLIM_REV_ID_MAJ(fw_rev), SLIM_REV_ID_MIN(fw_rev),\n\t\t hw_id, hw_ver);\n\n\treturn 0;\n}\n\nstatic int slim_rproc_stop(struct rproc *rproc)\n{\n\tstruct st_slim_rproc *slim_rproc = rproc->priv;\n\tu32 val;\n\n\t \n\twritel(0UL, slim_rproc->peri + SLIM_INT_MASK_OFST);\n\twritel(0UL, slim_rproc->peri + SLIM_CMD_MASK_OFST);\n\n\t \n\twritel(SLIM_CLK_GATE_DIS, slim_rproc->slimcore + SLIM_CLK_GATE_OFST);\n\n\twritel(!SLIM_EN_RUN, slim_rproc->slimcore + SLIM_EN_OFST);\n\n\tval = readl(slim_rproc->slimcore + SLIM_EN_OFST);\n\tif (val & SLIM_EN_RUN)\n\t\tdev_warn(&rproc->dev, \"Failed to disable SLIM\");\n\n\tdev_dbg(&rproc->dev, \"slim stopped\\n\");\n\n\treturn 0;\n}\n\nstatic void *slim_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct st_slim_rproc *slim_rproc = rproc->priv;\n\tvoid *va = NULL;\n\tint i;\n\n\tfor (i = 0; i < ST_SLIM_MEM_MAX; i++) {\n\t\tif (da != slim_rproc->mem[i].bus_addr)\n\t\t\tcontinue;\n\n\t\tif (len <= slim_rproc->mem[i].size) {\n\t\t\t \n\t\t\tva = (__force void *)slim_rproc->mem[i].cpu_addr;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(&rproc->dev, \"da = 0x%llx len = 0x%zx va = 0x%pK\\n\",\n\t\tda, len, va);\n\n\treturn va;\n}\n\nstatic const struct rproc_ops slim_rproc_ops = {\n\t.start\t\t= slim_rproc_start,\n\t.stop\t\t= slim_rproc_stop,\n\t.da_to_va       = slim_rproc_da_to_va,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n\t.load\t\t= rproc_elf_load_segments,\n\t.sanity_check\t= rproc_elf_sanity_check,\n};\n\n \n\nstruct st_slim_rproc *st_slim_rproc_alloc(struct platform_device *pdev,\n\t\t\t\tchar *fw_name)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct st_slim_rproc *slim_rproc;\n\tstruct device_node *np = dev->of_node;\n\tstruct rproc *rproc;\n\tstruct resource *res;\n\tint err, i;\n\n\tif (!fw_name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!of_device_is_compatible(np, \"st,slim-rproc\"))\n\t\treturn ERR_PTR(-EINVAL);\n\n\trproc = rproc_alloc(dev, np->name, &slim_rproc_ops,\n\t\t\tfw_name, sizeof(*slim_rproc));\n\tif (!rproc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trproc->has_iommu = false;\n\n\tslim_rproc = rproc->priv;\n\tslim_rproc->rproc = rproc;\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(mem_names); i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\tmem_names[i]);\n\n\t\tslim_rproc->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(slim_rproc->mem[i].cpu_addr)) {\n\t\t\tdev_err(&pdev->dev, \"devm_ioremap_resource failed\\n\");\n\t\t\terr = PTR_ERR(slim_rproc->mem[i].cpu_addr);\n\t\t\tgoto err;\n\t\t}\n\t\tslim_rproc->mem[i].bus_addr = res->start;\n\t\tslim_rproc->mem[i].size = resource_size(res);\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"slimcore\");\n\tslim_rproc->slimcore = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(slim_rproc->slimcore)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap slimcore IO\\n\");\n\t\terr = PTR_ERR(slim_rproc->slimcore);\n\t\tgoto err;\n\t}\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"peripherals\");\n\tslim_rproc->peri = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(slim_rproc->peri)) {\n\t\tdev_err(&pdev->dev, \"failed to ioremap peripherals IO\\n\");\n\t\terr = PTR_ERR(slim_rproc->peri);\n\t\tgoto err;\n\t}\n\n\terr = slim_clk_get(slim_rproc, dev);\n\tif (err)\n\t\tgoto err;\n\n\terr = slim_clk_enable(slim_rproc);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to enable clocks\\n\");\n\t\tgoto err_clk_put;\n\t}\n\n\t \n\terr = rproc_add(rproc);\n\tif (err) {\n\t\tdev_err(dev, \"registration of slim remoteproc failed\\n\");\n\t\tgoto err_clk_dis;\n\t}\n\n\treturn slim_rproc;\n\nerr_clk_dis:\n\tslim_clk_disable(slim_rproc);\nerr_clk_put:\n\tfor (i = 0; i < ST_SLIM_MAX_CLK && slim_rproc->clks[i]; i++)\n\t\tclk_put(slim_rproc->clks[i]);\nerr:\n\trproc_free(rproc);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL(st_slim_rproc_alloc);\n\n \nvoid st_slim_rproc_put(struct st_slim_rproc *slim_rproc)\n{\n\tint clk;\n\n\tif (!slim_rproc)\n\t\treturn;\n\n\tslim_clk_disable(slim_rproc);\n\n\tfor (clk = 0; clk < ST_SLIM_MAX_CLK && slim_rproc->clks[clk]; clk++)\n\t\tclk_put(slim_rproc->clks[clk]);\n\n\trproc_del(slim_rproc->rproc);\n\trproc_free(slim_rproc->rproc);\n}\nEXPORT_SYMBOL(st_slim_rproc_put);\n\nMODULE_AUTHOR(\"Peter Griffin <peter.griffin@linaro.org>\");\nMODULE_DESCRIPTION(\"STMicroelectronics SLIM core rproc driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}