{
  "module_name": "st_remoteproc.c",
  "hash_id": "0305ca243304fa9da5d90740cfe1adb0ab3ccd29a6d04c9889ce925c3b8e05cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/st_remoteproc.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_device.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n\n#include \"remoteproc_internal.h\"\n\n#define ST_RPROC_VQ0\t\t0\n#define ST_RPROC_VQ1\t\t1\n#define ST_RPROC_MAX_VRING\t2\n\n#define MBOX_RX\t\t\t0\n#define MBOX_TX\t\t\t1\n#define MBOX_MAX\t\t2\n\nstruct st_rproc_config {\n\tbool\t\t\tsw_reset;\n\tbool\t\t\tpwr_reset;\n\tunsigned long\t\tbootaddr_mask;\n};\n\nstruct st_rproc {\n\tstruct st_rproc_config\t*config;\n\tstruct reset_control\t*sw_reset;\n\tstruct reset_control\t*pwr_reset;\n\tstruct clk\t\t*clk;\n\tu32\t\t\tclk_rate;\n\tstruct regmap\t\t*boot_base;\n\tu32\t\t\tboot_offset;\n\tstruct mbox_chan\t*mbox_chan[ST_RPROC_MAX_VRING * MBOX_MAX];\n\tstruct mbox_client mbox_client_vq0;\n\tstruct mbox_client mbox_client_vq1;\n};\n\nstatic void st_rproc_mbox_callback(struct device *dev, u32 msg)\n{\n\tstruct rproc *rproc = dev_get_drvdata(dev);\n\n\tif (rproc_vq_interrupt(rproc, msg) == IRQ_NONE)\n\t\tdev_dbg(dev, \"no message was found in vqid %d\\n\", msg);\n}\n\nstatic\nvoid st_rproc_mbox_callback_vq0(struct mbox_client *mbox_client, void *data)\n{\n\tst_rproc_mbox_callback(mbox_client->dev, 0);\n}\n\nstatic\nvoid st_rproc_mbox_callback_vq1(struct mbox_client *mbox_client, void *data)\n{\n\tst_rproc_mbox_callback(mbox_client->dev, 1);\n}\n\nstatic void st_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct st_rproc *ddata = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tint ret;\n\n\t \n\tif (WARN_ON(vqid >= ST_RPROC_MAX_VRING))\n\t\treturn;\n\n\tret = mbox_send_message(ddata->mbox_chan[vqid * MBOX_MAX + MBOX_TX],\n\t\t\t\t(void *)&vqid);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to send message via mbox: %d\\n\", ret);\n}\n\nstatic int st_rproc_mem_alloc(struct rproc *rproc,\n\t\t\t      struct rproc_mem_entry *mem)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tvoid *va;\n\n\tva = ioremap_wc(mem->dma, mem->len);\n\tif (!va) {\n\t\tdev_err(dev, \"Unable to map memory region: %pa+%zx\\n\",\n\t\t\t&mem->dma, mem->len);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmem->va = va;\n\n\treturn 0;\n}\n\nstatic int st_rproc_mem_release(struct rproc *rproc,\n\t\t\t\tstruct rproc_mem_entry *mem)\n{\n\tiounmap(mem->va);\n\n\treturn 0;\n}\n\nstatic int st_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct device_node *np = dev->of_node;\n\tstruct rproc_mem_entry *mem;\n\tstruct reserved_mem *rmem;\n\tstruct of_phandle_iterator it;\n\tint index = 0;\n\n\tof_phandle_iterator_init(&it, np, \"memory-region\", NULL, 0);\n\twhile (of_phandle_iterator_next(&it) == 0) {\n\t\trmem = of_reserved_mem_lookup(it.node);\n\t\tif (!rmem) {\n\t\t\tof_node_put(it.node);\n\t\t\tdev_err(dev, \"unable to acquire memory-region\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (strcmp(it.node->name, \"vdev0buffer\")) {\n\t\t\t \n\t\t\tmem = rproc_mem_entry_init(dev, NULL,\n\t\t\t\t\t\t   (dma_addr_t)rmem->base,\n\t\t\t\t\t\t   rmem->size, rmem->base,\n\t\t\t\t\t\t   st_rproc_mem_alloc,\n\t\t\t\t\t\t   st_rproc_mem_release,\n\t\t\t\t\t\t   it.node->name);\n\t\t} else {\n\t\t\t \n\t\t\tmem = rproc_of_resm_mem_entry_init(dev, index,\n\t\t\t\t\t\t\t   rmem->size,\n\t\t\t\t\t\t\t   rmem->base,\n\t\t\t\t\t\t\t   it.node->name);\n\t\t}\n\n\t\tif (!mem) {\n\t\t\tof_node_put(it.node);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\trproc_add_carveout(rproc, mem);\n\t\tindex++;\n\t}\n\n\treturn rproc_elf_load_rsc_table(rproc, fw);\n}\n\nstatic int st_rproc_start(struct rproc *rproc)\n{\n\tstruct st_rproc *ddata = rproc->priv;\n\tint err;\n\n\tregmap_update_bits(ddata->boot_base, ddata->boot_offset,\n\t\t\t   ddata->config->bootaddr_mask, rproc->bootaddr);\n\n\terr = clk_enable(ddata->clk);\n\tif (err) {\n\t\tdev_err(&rproc->dev, \"Failed to enable clock\\n\");\n\t\treturn err;\n\t}\n\n\tif (ddata->config->sw_reset) {\n\t\terr = reset_control_deassert(ddata->sw_reset);\n\t\tif (err) {\n\t\t\tdev_err(&rproc->dev, \"Failed to deassert S/W Reset\\n\");\n\t\t\tgoto sw_reset_fail;\n\t\t}\n\t}\n\n\tif (ddata->config->pwr_reset) {\n\t\terr = reset_control_deassert(ddata->pwr_reset);\n\t\tif (err) {\n\t\t\tdev_err(&rproc->dev, \"Failed to deassert Power Reset\\n\");\n\t\t\tgoto pwr_reset_fail;\n\t\t}\n\t}\n\n\tdev_info(&rproc->dev, \"Started from 0x%llx\\n\", rproc->bootaddr);\n\n\treturn 0;\n\n\npwr_reset_fail:\n\tif (ddata->config->pwr_reset)\n\t\treset_control_assert(ddata->sw_reset);\nsw_reset_fail:\n\tclk_disable(ddata->clk);\n\n\treturn err;\n}\n\nstatic int st_rproc_stop(struct rproc *rproc)\n{\n\tstruct st_rproc *ddata = rproc->priv;\n\tint sw_err = 0, pwr_err = 0;\n\n\tif (ddata->config->sw_reset) {\n\t\tsw_err = reset_control_assert(ddata->sw_reset);\n\t\tif (sw_err)\n\t\t\tdev_err(&rproc->dev, \"Failed to assert S/W Reset\\n\");\n\t}\n\n\tif (ddata->config->pwr_reset) {\n\t\tpwr_err = reset_control_assert(ddata->pwr_reset);\n\t\tif (pwr_err)\n\t\t\tdev_err(&rproc->dev, \"Failed to assert Power Reset\\n\");\n\t}\n\n\tclk_disable(ddata->clk);\n\n\treturn sw_err ?: pwr_err;\n}\n\nstatic const struct rproc_ops st_rproc_ops = {\n\t.kick\t\t\t= st_rproc_kick,\n\t.start\t\t\t= st_rproc_start,\n\t.stop\t\t\t= st_rproc_stop,\n\t.parse_fw\t\t= st_rproc_parse_fw,\n\t.load\t\t\t= rproc_elf_load_segments,\n\t.find_loaded_rsc_table\t= rproc_elf_find_loaded_rsc_table,\n\t.sanity_check\t\t= rproc_elf_sanity_check,\n\t.get_boot_addr\t\t= rproc_elf_get_boot_addr,\n};\n\n \nstatic int st_rproc_state(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct st_rproc *ddata = rproc->priv;\n\tint reset_sw = 0, reset_pwr = 0;\n\n\tif (ddata->config->sw_reset)\n\t\treset_sw = reset_control_status(ddata->sw_reset);\n\n\tif (ddata->config->pwr_reset)\n\t\treset_pwr = reset_control_status(ddata->pwr_reset);\n\n\tif (reset_sw < 0 || reset_pwr < 0)\n\t\treturn -EINVAL;\n\n\treturn !reset_sw && !reset_pwr;\n}\n\nstatic const struct st_rproc_config st40_rproc_cfg = {\n\t.sw_reset = true,\n\t.pwr_reset = true,\n\t.bootaddr_mask = GENMASK(28, 1),\n};\n\nstatic const struct st_rproc_config st231_rproc_cfg = {\n\t.sw_reset = true,\n\t.pwr_reset = false,\n\t.bootaddr_mask = GENMASK(31, 6),\n};\n\nstatic const struct of_device_id st_rproc_match[] = {\n\t{ .compatible = \"st,st40-rproc\", .data = &st40_rproc_cfg },\n\t{ .compatible = \"st,st231-rproc\", .data = &st231_rproc_cfg },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, st_rproc_match);\n\nstatic int st_rproc_parse_dt(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct st_rproc *ddata = rproc->priv;\n\tstruct device_node *np = dev->of_node;\n\tint err;\n\n\tif (ddata->config->sw_reset) {\n\t\tddata->sw_reset = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t   \"sw_reset\");\n\t\tif (IS_ERR(ddata->sw_reset)) {\n\t\t\tdev_err(dev, \"Failed to get S/W Reset\\n\");\n\t\t\treturn PTR_ERR(ddata->sw_reset);\n\t\t}\n\t}\n\n\tif (ddata->config->pwr_reset) {\n\t\tddata->pwr_reset = devm_reset_control_get_exclusive(dev,\n\t\t\t\t\t\t\t\t    \"pwr_reset\");\n\t\tif (IS_ERR(ddata->pwr_reset)) {\n\t\t\tdev_err(dev, \"Failed to get Power Reset\\n\");\n\t\t\treturn PTR_ERR(ddata->pwr_reset);\n\t\t}\n\t}\n\n\tddata->clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(ddata->clk)) {\n\t\tdev_err(dev, \"Failed to get clock\\n\");\n\t\treturn PTR_ERR(ddata->clk);\n\t}\n\n\terr = of_property_read_u32(np, \"clock-frequency\", &ddata->clk_rate);\n\tif (err) {\n\t\tdev_err(dev, \"failed to get clock frequency\\n\");\n\t\treturn err;\n\t}\n\n\tddata->boot_base = syscon_regmap_lookup_by_phandle(np, \"st,syscfg\");\n\tif (IS_ERR(ddata->boot_base)) {\n\t\tdev_err(dev, \"Boot base not found\\n\");\n\t\treturn PTR_ERR(ddata->boot_base);\n\t}\n\n\terr = of_property_read_u32_index(np, \"st,syscfg\", 1,\n\t\t\t\t\t &ddata->boot_offset);\n\tif (err) {\n\t\tdev_err(dev, \"Boot offset not found\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = clk_prepare(ddata->clk);\n\tif (err)\n\t\tdev_err(dev, \"failed to get clock\\n\");\n\n\treturn err;\n}\n\nstatic int st_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tconst struct of_device_id *match;\n\tstruct st_rproc *ddata;\n\tstruct device_node *np = dev->of_node;\n\tstruct rproc *rproc;\n\tstruct mbox_chan *chan;\n\tint enabled;\n\tint ret, i;\n\n\tmatch = of_match_device(st_rproc_match, dev);\n\tif (!match || !match->data) {\n\t\tdev_err(dev, \"No device match found\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trproc = rproc_alloc(dev, np->name, &st_rproc_ops, NULL, sizeof(*ddata));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\trproc->has_iommu = false;\n\tddata = rproc->priv;\n\tddata->config = (struct st_rproc_config *)match->data;\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\tret = st_rproc_parse_dt(pdev);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tenabled = st_rproc_state(pdev);\n\tif (enabled < 0) {\n\t\tret = enabled;\n\t\tgoto free_clk;\n\t}\n\n\tif (enabled) {\n\t\tatomic_inc(&rproc->power);\n\t\trproc->state = RPROC_RUNNING;\n\t} else {\n\t\tclk_set_rate(ddata->clk, ddata->clk_rate);\n\t}\n\n\tif (of_property_present(np, \"mbox-names\")) {\n\t\tddata->mbox_client_vq0.dev\t\t= dev;\n\t\tddata->mbox_client_vq0.tx_done\t\t= NULL;\n\t\tddata->mbox_client_vq0.tx_block\t= false;\n\t\tddata->mbox_client_vq0.knows_txdone\t= false;\n\t\tddata->mbox_client_vq0.rx_callback\t= st_rproc_mbox_callback_vq0;\n\n\t\tddata->mbox_client_vq1.dev\t\t= dev;\n\t\tddata->mbox_client_vq1.tx_done\t\t= NULL;\n\t\tddata->mbox_client_vq1.tx_block\t= false;\n\t\tddata->mbox_client_vq1.knows_txdone\t= false;\n\t\tddata->mbox_client_vq1.rx_callback\t= st_rproc_mbox_callback_vq1;\n\n\t\t \n\t\tchan = mbox_request_channel_byname(&ddata->mbox_client_vq0, \"vq0_rx\");\n\t\tif (IS_ERR(chan)) {\n\t\t\tdev_err(&rproc->dev, \"failed to request mbox chan 0\\n\");\n\t\t\tret = PTR_ERR(chan);\n\t\t\tgoto free_clk;\n\t\t}\n\t\tddata->mbox_chan[ST_RPROC_VQ0 * MBOX_MAX + MBOX_RX] = chan;\n\n\t\tchan = mbox_request_channel_byname(&ddata->mbox_client_vq0, \"vq0_tx\");\n\t\tif (IS_ERR(chan)) {\n\t\t\tdev_err(&rproc->dev, \"failed to request mbox chan 0\\n\");\n\t\t\tret = PTR_ERR(chan);\n\t\t\tgoto free_mbox;\n\t\t}\n\t\tddata->mbox_chan[ST_RPROC_VQ0 * MBOX_MAX + MBOX_TX] = chan;\n\n\t\tchan = mbox_request_channel_byname(&ddata->mbox_client_vq1, \"vq1_rx\");\n\t\tif (IS_ERR(chan)) {\n\t\t\tdev_err(&rproc->dev, \"failed to request mbox chan 1\\n\");\n\t\t\tret = PTR_ERR(chan);\n\t\t\tgoto free_mbox;\n\t\t}\n\t\tddata->mbox_chan[ST_RPROC_VQ1 * MBOX_MAX + MBOX_RX] = chan;\n\n\t\tchan = mbox_request_channel_byname(&ddata->mbox_client_vq1, \"vq1_tx\");\n\t\tif (IS_ERR(chan)) {\n\t\t\tdev_err(&rproc->dev, \"failed to request mbox chan 1\\n\");\n\t\t\tret = PTR_ERR(chan);\n\t\t\tgoto free_mbox;\n\t\t}\n\t\tddata->mbox_chan[ST_RPROC_VQ1 * MBOX_MAX + MBOX_TX] = chan;\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto free_mbox;\n\n\treturn 0;\n\nfree_mbox:\n\tfor (i = 0; i < ST_RPROC_MAX_VRING * MBOX_MAX; i++)\n\t\tmbox_free_channel(ddata->mbox_chan[i]);\nfree_clk:\n\tclk_unprepare(ddata->clk);\nfree_rproc:\n\trproc_free(rproc);\n\treturn ret;\n}\n\nstatic void st_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct st_rproc *ddata = rproc->priv;\n\tint i;\n\n\trproc_del(rproc);\n\n\tclk_disable_unprepare(ddata->clk);\n\n\tfor (i = 0; i < ST_RPROC_MAX_VRING * MBOX_MAX; i++)\n\t\tmbox_free_channel(ddata->mbox_chan[i]);\n\n\trproc_free(rproc);\n}\n\nstatic struct platform_driver st_rproc_driver = {\n\t.probe = st_rproc_probe,\n\t.remove_new = st_rproc_remove,\n\t.driver = {\n\t\t.name = \"st-rproc\",\n\t\t.of_match_table = of_match_ptr(st_rproc_match),\n\t},\n};\nmodule_platform_driver(st_rproc_driver);\n\nMODULE_DESCRIPTION(\"ST Remote Processor Control Driver\");\nMODULE_AUTHOR(\"Ludovic Barre <ludovic.barre@st.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}