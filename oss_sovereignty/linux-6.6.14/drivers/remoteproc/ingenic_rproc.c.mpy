{
  "module_name": "ingenic_rproc.c",
  "hash_id": "701930bd94b9739733f70251473f8953837b0b2749f740fae58640468f1785a7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/ingenic_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n\n#include \"remoteproc_internal.h\"\n\n#define REG_AUX_CTRL\t\t0x0\n#define REG_AUX_MSG_ACK\t\t0x10\n#define REG_AUX_MSG\t\t0x14\n#define REG_CORE_MSG_ACK\t0x18\n#define REG_CORE_MSG\t\t0x1C\n\n#define AUX_CTRL_SLEEP\t\tBIT(31)\n#define AUX_CTRL_MSG_IRQ_EN\tBIT(3)\n#define AUX_CTRL_NMI_RESETS\tBIT(2)\n#define AUX_CTRL_NMI\t\tBIT(1)\n#define AUX_CTRL_SW_RESET\tBIT(0)\n\nstatic bool auto_boot;\nmodule_param(auto_boot, bool, 0400);\nMODULE_PARM_DESC(auto_boot,\n\t\t \"Auto-boot the remote processor [default=false]\");\n\nstruct vpu_mem_map {\n\tconst char *name;\n\tunsigned int da;\n};\n\nstruct vpu_mem_info {\n\tconst struct vpu_mem_map *map;\n\tunsigned long len;\n\tvoid __iomem *base;\n};\n\nstatic const struct vpu_mem_map vpu_mem_map[] = {\n\t{ \"tcsm0\", 0x132b0000 },\n\t{ \"tcsm1\", 0xf4000000 },\n\t{ \"sram\",  0x132f0000 },\n};\n\n \nstruct vpu {\n\tint irq;\n\tstruct clk_bulk_data clks[2];\n\tvoid __iomem *aux_base;\n\tstruct vpu_mem_info mem_info[ARRAY_SIZE(vpu_mem_map)];\n\tstruct device *dev;\n};\n\nstatic int ingenic_rproc_prepare(struct rproc *rproc)\n{\n\tstruct vpu *vpu = rproc->priv;\n\tint ret;\n\n\t \n\tret = clk_bulk_prepare_enable(ARRAY_SIZE(vpu->clks), vpu->clks);\n\tif (ret)\n\t\tdev_err(vpu->dev, \"Unable to start clocks: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ingenic_rproc_unprepare(struct rproc *rproc)\n{\n\tstruct vpu *vpu = rproc->priv;\n\n\tclk_bulk_disable_unprepare(ARRAY_SIZE(vpu->clks), vpu->clks);\n\n\treturn 0;\n}\n\nstatic int ingenic_rproc_start(struct rproc *rproc)\n{\n\tstruct vpu *vpu = rproc->priv;\n\tu32 ctrl;\n\n\tenable_irq(vpu->irq);\n\n\t \n\tctrl = AUX_CTRL_NMI_RESETS | AUX_CTRL_NMI | AUX_CTRL_MSG_IRQ_EN;\n\twritel(ctrl, vpu->aux_base + REG_AUX_CTRL);\n\n\treturn 0;\n}\n\nstatic int ingenic_rproc_stop(struct rproc *rproc)\n{\n\tstruct vpu *vpu = rproc->priv;\n\n\tdisable_irq(vpu->irq);\n\n\t \n\twritel(AUX_CTRL_SW_RESET, vpu->aux_base + REG_AUX_CTRL);\n\n\treturn 0;\n}\n\nstatic void ingenic_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct vpu *vpu = rproc->priv;\n\n\twritel(vqid, vpu->aux_base + REG_CORE_MSG);\n}\n\nstatic void *ingenic_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct vpu *vpu = rproc->priv;\n\tvoid __iomem *va = NULL;\n\tunsigned int i;\n\n\tfor (i = 0; i < ARRAY_SIZE(vpu_mem_map); i++) {\n\t\tconst struct vpu_mem_info *info = &vpu->mem_info[i];\n\t\tconst struct vpu_mem_map *map = info->map;\n\n\t\tif (da >= map->da && (da + len) < (map->da + info->len)) {\n\t\t\tva = info->base + (da - map->da);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn (__force void *)va;\n}\n\nstatic const struct rproc_ops ingenic_rproc_ops = {\n\t.prepare = ingenic_rproc_prepare,\n\t.unprepare = ingenic_rproc_unprepare,\n\t.start = ingenic_rproc_start,\n\t.stop = ingenic_rproc_stop,\n\t.kick = ingenic_rproc_kick,\n\t.da_to_va = ingenic_rproc_da_to_va,\n};\n\nstatic irqreturn_t vpu_interrupt(int irq, void *data)\n{\n\tstruct rproc *rproc = data;\n\tstruct vpu *vpu = rproc->priv;\n\tu32 vring;\n\n\tvring = readl(vpu->aux_base + REG_AUX_MSG);\n\n\t \n\twritel(0, vpu->aux_base + REG_AUX_MSG_ACK);\n\n\treturn rproc_vq_interrupt(rproc, vring);\n}\n\nstatic int ingenic_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *mem;\n\tstruct rproc *rproc;\n\tstruct vpu *vpu;\n\tunsigned int i;\n\tint ret;\n\n\trproc = devm_rproc_alloc(dev, \"ingenic-vpu\",\n\t\t\t\t &ingenic_rproc_ops, NULL, sizeof(*vpu));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\trproc->auto_boot = auto_boot;\n\n\tvpu = rproc->priv;\n\tvpu->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, vpu);\n\n\tmem = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"aux\");\n\tvpu->aux_base = devm_ioremap_resource(dev, mem);\n\tif (IS_ERR(vpu->aux_base)) {\n\t\tdev_err(dev, \"Failed to ioremap\\n\");\n\t\treturn PTR_ERR(vpu->aux_base);\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(vpu_mem_map); i++) {\n\t\tmem = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   vpu_mem_map[i].name);\n\n\t\tvpu->mem_info[i].base = devm_ioremap_resource(dev, mem);\n\t\tif (IS_ERR(vpu->mem_info[i].base)) {\n\t\t\tret = PTR_ERR(vpu->mem_info[i].base);\n\t\t\tdev_err(dev, \"Failed to ioremap\\n\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tvpu->mem_info[i].len = resource_size(mem);\n\t\tvpu->mem_info[i].map = &vpu_mem_map[i];\n\t}\n\n\tvpu->clks[0].id = \"vpu\";\n\tvpu->clks[1].id = \"aux\";\n\n\tret = devm_clk_bulk_get(dev, ARRAY_SIZE(vpu->clks), vpu->clks);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to get clocks\\n\");\n\t\treturn ret;\n\t}\n\n\tvpu->irq = platform_get_irq(pdev, 0);\n\tif (vpu->irq < 0)\n\t\treturn vpu->irq;\n\n\tret = devm_request_irq(dev, vpu->irq, vpu_interrupt, IRQF_NO_AUTOEN,\n\t\t\t       \"VPU\", rproc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\tret = devm_rproc_add(dev, rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to register remote processor\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct of_device_id ingenic_rproc_of_matches[] = {\n\t{ .compatible = \"ingenic,jz4770-vpu-rproc\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, ingenic_rproc_of_matches);\n\nstatic struct platform_driver ingenic_rproc_driver = {\n\t.probe = ingenic_rproc_probe,\n\t.driver = {\n\t\t.name = \"ingenic-vpu\",\n\t\t.of_match_table = ingenic_rproc_of_matches,\n\t},\n};\nmodule_platform_driver(ingenic_rproc_driver);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Paul Cercueil <paul@crapouillou.net>\");\nMODULE_DESCRIPTION(\"Ingenic JZ47xx Remote Processor control driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}