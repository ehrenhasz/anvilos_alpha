{
  "module_name": "qcom_wcnss.c",
  "hash_id": "653d22c443fa06a29a03f2b6542d1af3cf20dbf26d195e86ebb22c3f6939374a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_wcnss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/firmware/qcom/qcom_scm.h>\n#include <linux/regulator/consumer.h>\n#include <linux/remoteproc.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/soc/qcom/smem_state.h>\n\n#include \"qcom_common.h\"\n#include \"remoteproc_internal.h\"\n#include \"qcom_pil_info.h\"\n#include \"qcom_wcnss.h\"\n\n#define WCNSS_CRASH_REASON_SMEM\t\t422\n#define WCNSS_FIRMWARE_NAME\t\t\"wcnss.mdt\"\n#define WCNSS_PAS_ID\t\t\t6\n#define WCNSS_SSCTL_ID\t\t\t0x13\n\n#define WCNSS_SPARE_NVBIN_DLND\t\tBIT(25)\n\n#define WCNSS_PMU_IRIS_XO_CFG\t\tBIT(3)\n#define WCNSS_PMU_IRIS_XO_EN\t\tBIT(4)\n#define WCNSS_PMU_GC_BUS_MUX_SEL_TOP\tBIT(5)\n#define WCNSS_PMU_IRIS_XO_CFG_STS\tBIT(6)  \n\n#define WCNSS_PMU_IRIS_RESET\t\tBIT(7)\n#define WCNSS_PMU_IRIS_RESET_STS\tBIT(8)  \n#define WCNSS_PMU_IRIS_XO_READ\t\tBIT(9)\n#define WCNSS_PMU_IRIS_XO_READ_STS\tBIT(10)\n\n#define WCNSS_PMU_XO_MODE_MASK\t\tGENMASK(2, 1)\n#define WCNSS_PMU_XO_MODE_19p2\t\t0\n#define WCNSS_PMU_XO_MODE_48\t\t3\n\n#define WCNSS_MAX_PDS\t\t\t2\n\nstruct wcnss_data {\n\tsize_t pmu_offset;\n\tsize_t spare_offset;\n\n\tconst char *pd_names[WCNSS_MAX_PDS];\n\tconst struct wcnss_vreg_info *vregs;\n\tsize_t num_vregs, num_pd_vregs;\n};\n\nstruct qcom_wcnss {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\n\tvoid __iomem *pmu_cfg;\n\tvoid __iomem *spare_out;\n\n\tbool use_48mhz_xo;\n\n\tint wdog_irq;\n\tint fatal_irq;\n\tint ready_irq;\n\tint handover_irq;\n\tint stop_ack_irq;\n\n\tstruct qcom_smem_state *state;\n\tunsigned stop_bit;\n\n\tstruct mutex iris_lock;\n\tstruct qcom_iris *iris;\n\n\tstruct device *pds[WCNSS_MAX_PDS];\n\tsize_t num_pds;\n\tstruct regulator_bulk_data *vregs;\n\tsize_t num_vregs;\n\n\tstruct completion start_done;\n\tstruct completion stop_done;\n\n\tphys_addr_t mem_phys;\n\tphys_addr_t mem_reloc;\n\tvoid *mem_region;\n\tsize_t mem_size;\n\n\tstruct qcom_rproc_subdev smd_subdev;\n\tstruct qcom_sysmon *sysmon;\n};\n\nstatic const struct wcnss_data riva_data = {\n\t.pmu_offset = 0x28,\n\t.spare_offset = 0xb4,\n\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddmx\",  1050000, 1150000, 0 },\n\t\t{ \"vddcx\",  1050000, 1150000, 0 },\n\t\t{ \"vddpx\",  1800000, 1800000, 0 },\n\t},\n\t.num_vregs = 3,\n};\n\nstatic const struct wcnss_data pronto_v1_data = {\n\t.pmu_offset = 0x1004,\n\t.spare_offset = 0x1088,\n\n\t.pd_names = { \"mx\", \"cx\" },\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddmx\", 950000, 1150000, 0 },\n\t\t{ \"vddcx\", .super_turbo = true},\n\t\t{ \"vddpx\", 1800000, 1800000, 0 },\n\t},\n\t.num_pd_vregs = 2,\n\t.num_vregs = 1,\n};\n\nstatic const struct wcnss_data pronto_v2_data = {\n\t.pmu_offset = 0x1004,\n\t.spare_offset = 0x1088,\n\n\t.pd_names = { \"mx\", \"cx\" },\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddmx\", 1287500, 1287500, 0 },\n\t\t{ \"vddcx\", .super_turbo = true },\n\t\t{ \"vddpx\", 1800000, 1800000, 0 },\n\t},\n\t.num_pd_vregs = 2,\n\t.num_vregs = 1,\n};\n\nstatic const struct wcnss_data pronto_v3_data = {\n\t.pmu_offset = 0x1004,\n\t.spare_offset = 0x1088,\n\n\t.pd_names = { \"mx\", \"cx\" },\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddpx\", 1800000, 1800000, 0 },\n\t},\n\t.num_vregs = 1,\n};\n\nstatic int wcnss_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct qcom_wcnss *wcnss = rproc->priv;\n\tint ret;\n\n\tret = qcom_mdt_load(wcnss->dev, fw, rproc->firmware, WCNSS_PAS_ID,\n\t\t\t    wcnss->mem_region, wcnss->mem_phys,\n\t\t\t    wcnss->mem_size, &wcnss->mem_reloc);\n\tif (ret)\n\t\treturn ret;\n\n\tqcom_pil_info_store(\"wcnss\", wcnss->mem_phys, wcnss->mem_size);\n\n\treturn 0;\n}\n\nstatic void wcnss_indicate_nv_download(struct qcom_wcnss *wcnss)\n{\n\tu32 val;\n\n\t \n\tval = readl(wcnss->spare_out);\n\tval |= WCNSS_SPARE_NVBIN_DLND;\n\twritel(val, wcnss->spare_out);\n}\n\nstatic void wcnss_configure_iris(struct qcom_wcnss *wcnss)\n{\n\tu32 val;\n\n\t \n\twritel(0, wcnss->pmu_cfg);\n\n\tval = WCNSS_PMU_GC_BUS_MUX_SEL_TOP | WCNSS_PMU_IRIS_XO_EN;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\tval &= ~WCNSS_PMU_XO_MODE_MASK;\n\tif (wcnss->use_48mhz_xo)\n\t\tval |= WCNSS_PMU_XO_MODE_48 << 1;\n\telse\n\t\tval |= WCNSS_PMU_XO_MODE_19p2 << 1;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\tval |= WCNSS_PMU_IRIS_RESET;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\twhile (readl(wcnss->pmu_cfg) & WCNSS_PMU_IRIS_RESET_STS)\n\t\tcpu_relax();\n\n\t \n\tval &= ~WCNSS_PMU_IRIS_RESET;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\tval |= WCNSS_PMU_IRIS_XO_CFG;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\twhile (readl(wcnss->pmu_cfg) & WCNSS_PMU_IRIS_XO_CFG_STS)\n\t\tcpu_relax();\n\n\t \n\tval &= ~WCNSS_PMU_GC_BUS_MUX_SEL_TOP;\n\tval &= ~WCNSS_PMU_IRIS_XO_CFG;\n\twritel(val, wcnss->pmu_cfg);\n\n\t \n\tmsleep(20);\n}\n\nstatic int wcnss_start(struct rproc *rproc)\n{\n\tstruct qcom_wcnss *wcnss = rproc->priv;\n\tint ret, i;\n\n\tmutex_lock(&wcnss->iris_lock);\n\tif (!wcnss->iris) {\n\t\tdev_err(wcnss->dev, \"no iris registered\\n\");\n\t\tret = -EINVAL;\n\t\tgoto release_iris_lock;\n\t}\n\n\tfor (i = 0; i < wcnss->num_pds; i++) {\n\t\tdev_pm_genpd_set_performance_state(wcnss->pds[i], INT_MAX);\n\t\tret = pm_runtime_get_sync(wcnss->pds[i]);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(wcnss->pds[i]);\n\t\t\tgoto disable_pds;\n\t\t}\n\t}\n\n\tret = regulator_bulk_enable(wcnss->num_vregs, wcnss->vregs);\n\tif (ret)\n\t\tgoto disable_pds;\n\n\tret = qcom_iris_enable(wcnss->iris);\n\tif (ret)\n\t\tgoto disable_regulators;\n\n\twcnss_indicate_nv_download(wcnss);\n\twcnss_configure_iris(wcnss);\n\n\tret = qcom_scm_pas_auth_and_reset(WCNSS_PAS_ID);\n\tif (ret) {\n\t\tdev_err(wcnss->dev,\n\t\t\t\"failed to authenticate image and release reset\\n\");\n\t\tgoto disable_iris;\n\t}\n\n\tret = wait_for_completion_timeout(&wcnss->start_done,\n\t\t\t\t\t  msecs_to_jiffies(5000));\n\tif (wcnss->ready_irq > 0 && ret == 0) {\n\t\t \n\t\tdev_err(wcnss->dev, \"start timed out\\n\");\n\t\tqcom_scm_pas_shutdown(WCNSS_PAS_ID);\n\t\tret = -ETIMEDOUT;\n\t\tgoto disable_iris;\n\t}\n\n\tret = 0;\n\ndisable_iris:\n\tqcom_iris_disable(wcnss->iris);\ndisable_regulators:\n\tregulator_bulk_disable(wcnss->num_vregs, wcnss->vregs);\ndisable_pds:\n\tfor (i--; i >= 0; i--) {\n\t\tpm_runtime_put(wcnss->pds[i]);\n\t\tdev_pm_genpd_set_performance_state(wcnss->pds[i], 0);\n\t}\nrelease_iris_lock:\n\tmutex_unlock(&wcnss->iris_lock);\n\n\treturn ret;\n}\n\nstatic int wcnss_stop(struct rproc *rproc)\n{\n\tstruct qcom_wcnss *wcnss = rproc->priv;\n\tint ret;\n\n\tif (wcnss->state) {\n\t\tqcom_smem_state_update_bits(wcnss->state,\n\t\t\t\t\t    BIT(wcnss->stop_bit),\n\t\t\t\t\t    BIT(wcnss->stop_bit));\n\n\t\tret = wait_for_completion_timeout(&wcnss->stop_done,\n\t\t\t\t\t\t  msecs_to_jiffies(5000));\n\t\tif (ret == 0)\n\t\t\tdev_err(wcnss->dev, \"timed out on wait\\n\");\n\n\t\tqcom_smem_state_update_bits(wcnss->state,\n\t\t\t\t\t    BIT(wcnss->stop_bit),\n\t\t\t\t\t    0);\n\t}\n\n\tret = qcom_scm_pas_shutdown(WCNSS_PAS_ID);\n\tif (ret)\n\t\tdev_err(wcnss->dev, \"failed to shutdown: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void *wcnss_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct qcom_wcnss *wcnss = rproc->priv;\n\tint offset;\n\n\toffset = da - wcnss->mem_reloc;\n\tif (offset < 0 || offset + len > wcnss->mem_size)\n\t\treturn NULL;\n\n\treturn wcnss->mem_region + offset;\n}\n\nstatic const struct rproc_ops wcnss_ops = {\n\t.start = wcnss_start,\n\t.stop = wcnss_stop,\n\t.da_to_va = wcnss_da_to_va,\n\t.parse_fw = qcom_register_dump_segments,\n\t.load = wcnss_load,\n};\n\nstatic irqreturn_t wcnss_wdog_interrupt(int irq, void *dev)\n{\n\tstruct qcom_wcnss *wcnss = dev;\n\n\trproc_report_crash(wcnss->rproc, RPROC_WATCHDOG);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcnss_fatal_interrupt(int irq, void *dev)\n{\n\tstruct qcom_wcnss *wcnss = dev;\n\tsize_t len;\n\tchar *msg;\n\n\tmsg = qcom_smem_get(QCOM_SMEM_HOST_ANY, WCNSS_CRASH_REASON_SMEM, &len);\n\tif (!IS_ERR(msg) && len > 0 && msg[0])\n\t\tdev_err(wcnss->dev, \"fatal error received: %s\\n\", msg);\n\n\trproc_report_crash(wcnss->rproc, RPROC_FATAL_ERROR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcnss_ready_interrupt(int irq, void *dev)\n{\n\tstruct qcom_wcnss *wcnss = dev;\n\n\tcomplete(&wcnss->start_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcnss_handover_interrupt(int irq, void *dev)\n{\n\t \n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t wcnss_stop_ack_interrupt(int irq, void *dev)\n{\n\tstruct qcom_wcnss *wcnss = dev;\n\n\tcomplete(&wcnss->stop_done);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int wcnss_init_pds(struct qcom_wcnss *wcnss,\n\t\t\t  const char * const pd_names[WCNSS_MAX_PDS])\n{\n\tint i, ret;\n\n\tfor (i = 0; i < WCNSS_MAX_PDS; i++) {\n\t\tif (!pd_names[i])\n\t\t\tbreak;\n\n\t\twcnss->pds[i] = dev_pm_domain_attach_by_name(wcnss->dev, pd_names[i]);\n\t\tif (IS_ERR_OR_NULL(wcnss->pds[i])) {\n\t\t\tret = PTR_ERR(wcnss->pds[i]) ? : -ENODATA;\n\t\t\tfor (i--; i >= 0; i--)\n\t\t\t\tdev_pm_domain_detach(wcnss->pds[i], false);\n\t\t\treturn ret;\n\t\t}\n\t}\n\twcnss->num_pds = i;\n\n\treturn 0;\n}\n\nstatic void wcnss_release_pds(struct qcom_wcnss *wcnss)\n{\n\tint i;\n\n\tfor (i = 0; i < wcnss->num_pds; i++)\n\t\tdev_pm_domain_detach(wcnss->pds[i], false);\n}\n\nstatic int wcnss_init_regulators(struct qcom_wcnss *wcnss,\n\t\t\t\t const struct wcnss_vreg_info *info,\n\t\t\t\t int num_vregs, int num_pd_vregs)\n{\n\tstruct regulator_bulk_data *bulk;\n\tint ret;\n\tint i;\n\n\t \n\tif (wcnss->num_pds)\n\t\tinfo += num_pd_vregs;\n\telse\n\t\tnum_vregs += num_pd_vregs;\n\n\tbulk = devm_kcalloc(wcnss->dev,\n\t\t\t    num_vregs, sizeof(struct regulator_bulk_data),\n\t\t\t    GFP_KERNEL);\n\tif (!bulk)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_vregs; i++)\n\t\tbulk[i].supply = info[i].name;\n\n\tret = devm_regulator_bulk_get(wcnss->dev, num_vregs, bulk);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_vregs; i++) {\n\t\tif (info[i].max_voltage)\n\t\t\tregulator_set_voltage(bulk[i].consumer,\n\t\t\t\t\t      info[i].min_voltage,\n\t\t\t\t\t      info[i].max_voltage);\n\n\t\tif (info[i].load_uA)\n\t\t\tregulator_set_load(bulk[i].consumer, info[i].load_uA);\n\t}\n\n\twcnss->vregs = bulk;\n\twcnss->num_vregs = num_vregs;\n\n\treturn 0;\n}\n\nstatic int wcnss_request_irq(struct qcom_wcnss *wcnss,\n\t\t\t     struct platform_device *pdev,\n\t\t\t     const char *name,\n\t\t\t     bool optional,\n\t\t\t     irq_handler_t thread_fn)\n{\n\tint ret;\n\tint irq_number;\n\n\tret = platform_get_irq_byname(pdev, name);\n\tif (ret < 0 && optional) {\n\t\tdev_dbg(&pdev->dev, \"no %s IRQ defined, ignoring\\n\", name);\n\t\treturn 0;\n\t} else if (ret < 0) {\n\t\tdev_err(&pdev->dev, \"no %s IRQ defined\\n\", name);\n\t\treturn ret;\n\t}\n\n\tirq_number = ret;\n\n\tret = devm_request_threaded_irq(&pdev->dev, ret,\n\t\t\t\t\tNULL, thread_fn,\n\t\t\t\t\tIRQF_TRIGGER_RISING | IRQF_ONESHOT,\n\t\t\t\t\t\"wcnss\", wcnss);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"request %s IRQ failed\\n\", name);\n\t\treturn ret;\n\t}\n\n\t \n\treturn irq_number;\n}\n\nstatic int wcnss_alloc_memory_region(struct qcom_wcnss *wcnss)\n{\n\tstruct reserved_mem *rmem = NULL;\n\tstruct device_node *node;\n\n\tnode = of_parse_phandle(wcnss->dev->of_node, \"memory-region\", 0);\n\tif (node)\n\t\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\n\tif (!rmem) {\n\t\tdev_err(wcnss->dev, \"unable to resolve memory-region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twcnss->mem_phys = wcnss->mem_reloc = rmem->base;\n\twcnss->mem_size = rmem->size;\n\twcnss->mem_region = devm_ioremap_wc(wcnss->dev, wcnss->mem_phys, wcnss->mem_size);\n\tif (!wcnss->mem_region) {\n\t\tdev_err(wcnss->dev, \"unable to map memory region: %pa+%zx\\n\",\n\t\t\t&rmem->base, wcnss->mem_size);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int wcnss_probe(struct platform_device *pdev)\n{\n\tconst char *fw_name = WCNSS_FIRMWARE_NAME;\n\tconst struct wcnss_data *data;\n\tstruct qcom_wcnss *wcnss;\n\tstruct rproc *rproc;\n\tvoid __iomem *mmio;\n\tint ret;\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\n\tif (!qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tif (!qcom_scm_pas_supported(WCNSS_PAS_ID)) {\n\t\tdev_err(&pdev->dev, \"PAS is not available for WCNSS\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\tret = of_property_read_string(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t      &fw_name);\n\tif (ret < 0 && ret != -EINVAL)\n\t\treturn ret;\n\n\trproc = rproc_alloc(&pdev->dev, pdev->name, &wcnss_ops,\n\t\t\t    fw_name, sizeof(*wcnss));\n\tif (!rproc) {\n\t\tdev_err(&pdev->dev, \"unable to allocate remoteproc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\twcnss = rproc->priv;\n\twcnss->dev = &pdev->dev;\n\twcnss->rproc = rproc;\n\tplatform_set_drvdata(pdev, wcnss);\n\n\tinit_completion(&wcnss->start_done);\n\tinit_completion(&wcnss->stop_done);\n\n\tmutex_init(&wcnss->iris_lock);\n\n\tmmio = devm_platform_ioremap_resource_byname(pdev, \"pmu\");\n\tif (IS_ERR(mmio)) {\n\t\tret = PTR_ERR(mmio);\n\t\tgoto free_rproc;\n\t}\n\n\tret = wcnss_alloc_memory_region(wcnss);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\twcnss->pmu_cfg = mmio + data->pmu_offset;\n\twcnss->spare_out = mmio + data->spare_offset;\n\n\t \n\tret = wcnss_init_pds(wcnss, data->pd_names);\n\tif (ret && (ret != -ENODATA || !data->num_pd_vregs))\n\t\tgoto free_rproc;\n\n\tret = wcnss_init_regulators(wcnss, data->vregs, data->num_vregs,\n\t\t\t\t    data->num_pd_vregs);\n\tif (ret)\n\t\tgoto detach_pds;\n\n\tret = wcnss_request_irq(wcnss, pdev, \"wdog\", false, wcnss_wdog_interrupt);\n\tif (ret < 0)\n\t\tgoto detach_pds;\n\twcnss->wdog_irq = ret;\n\n\tret = wcnss_request_irq(wcnss, pdev, \"fatal\", false, wcnss_fatal_interrupt);\n\tif (ret < 0)\n\t\tgoto detach_pds;\n\twcnss->fatal_irq = ret;\n\n\tret = wcnss_request_irq(wcnss, pdev, \"ready\", true, wcnss_ready_interrupt);\n\tif (ret < 0)\n\t\tgoto detach_pds;\n\twcnss->ready_irq = ret;\n\n\tret = wcnss_request_irq(wcnss, pdev, \"handover\", true, wcnss_handover_interrupt);\n\tif (ret < 0)\n\t\tgoto detach_pds;\n\twcnss->handover_irq = ret;\n\n\tret = wcnss_request_irq(wcnss, pdev, \"stop-ack\", true, wcnss_stop_ack_interrupt);\n\tif (ret < 0)\n\t\tgoto detach_pds;\n\twcnss->stop_ack_irq = ret;\n\n\tif (wcnss->stop_ack_irq) {\n\t\twcnss->state = devm_qcom_smem_state_get(&pdev->dev, \"stop\",\n\t\t\t\t\t\t\t&wcnss->stop_bit);\n\t\tif (IS_ERR(wcnss->state)) {\n\t\t\tret = PTR_ERR(wcnss->state);\n\t\t\tgoto detach_pds;\n\t\t}\n\t}\n\n\tqcom_add_smd_subdev(rproc, &wcnss->smd_subdev);\n\twcnss->sysmon = qcom_add_sysmon_subdev(rproc, \"wcnss\", WCNSS_SSCTL_ID);\n\tif (IS_ERR(wcnss->sysmon)) {\n\t\tret = PTR_ERR(wcnss->sysmon);\n\t\tgoto detach_pds;\n\t}\n\n\twcnss->iris = qcom_iris_probe(&pdev->dev, &wcnss->use_48mhz_xo);\n\tif (IS_ERR(wcnss->iris)) {\n\t\tret = PTR_ERR(wcnss->iris);\n\t\tgoto detach_pds;\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto remove_iris;\n\n\treturn 0;\n\nremove_iris:\n\tqcom_iris_remove(wcnss->iris);\ndetach_pds:\n\twcnss_release_pds(wcnss);\nfree_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void wcnss_remove(struct platform_device *pdev)\n{\n\tstruct qcom_wcnss *wcnss = platform_get_drvdata(pdev);\n\n\tqcom_iris_remove(wcnss->iris);\n\n\trproc_del(wcnss->rproc);\n\n\tqcom_remove_sysmon_subdev(wcnss->sysmon);\n\tqcom_remove_smd_subdev(wcnss->rproc, &wcnss->smd_subdev);\n\twcnss_release_pds(wcnss);\n\trproc_free(wcnss->rproc);\n}\n\nstatic const struct of_device_id wcnss_of_match[] = {\n\t{ .compatible = \"qcom,riva-pil\", &riva_data },\n\t{ .compatible = \"qcom,pronto-v1-pil\", &pronto_v1_data },\n\t{ .compatible = \"qcom,pronto-v2-pil\", &pronto_v2_data },\n\t{ .compatible = \"qcom,pronto-v3-pil\", &pronto_v3_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, wcnss_of_match);\n\nstatic struct platform_driver wcnss_driver = {\n\t.probe = wcnss_probe,\n\t.remove_new = wcnss_remove,\n\t.driver = {\n\t\t.name = \"qcom-wcnss-pil\",\n\t\t.of_match_table = wcnss_of_match,\n\t},\n};\n\nmodule_platform_driver(wcnss_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Peripheral Image Loader for Wireless Subsystem\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}