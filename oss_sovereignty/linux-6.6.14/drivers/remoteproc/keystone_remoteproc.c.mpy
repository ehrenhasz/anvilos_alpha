{
  "module_name": "keystone_remoteproc.c",
  "hash_id": "c99a8747123504abce26ea4b1affe04cc6fc35771c64d59cb7bd7908d4fffd59",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/keystone_remoteproc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/workqueue.h>\n#include <linux/of_address.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regmap.h>\n#include <linux/mfd/syscon.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n\n#include \"remoteproc_internal.h\"\n\n#define KEYSTONE_RPROC_LOCAL_ADDRESS_MASK\t(SZ_16M - 1)\n\n \nstruct keystone_rproc_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\n \nstruct keystone_rproc {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\tstruct keystone_rproc_mem *mem;\n\tint num_mems;\n\tstruct regmap *dev_ctrl;\n\tstruct reset_control *reset;\n\tstruct gpio_desc *kick_gpio;\n\tu32 boot_offset;\n\tint irq_ring;\n\tint irq_fault;\n\tstruct work_struct workqueue;\n};\n\n \nstatic void keystone_rproc_dsp_reset(struct keystone_rproc *ksproc)\n{\n\treset_control_assert(ksproc->reset);\n}\n\n \nstatic int keystone_rproc_dsp_boot(struct keystone_rproc *ksproc, u32 boot_addr)\n{\n\tint ret;\n\n\tif (boot_addr & (SZ_1K - 1)) {\n\t\tdev_err(ksproc->dev, \"invalid boot address 0x%x, must be aligned on a 1KB boundary\\n\",\n\t\t\tboot_addr);\n\t\treturn -EINVAL;\n\t}\n\n\tret = regmap_write(ksproc->dev_ctrl, ksproc->boot_offset, boot_addr);\n\tif (ret) {\n\t\tdev_err(ksproc->dev, \"regmap_write of boot address failed, status = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\treset_control_deassert(ksproc->reset);\n\n\treturn 0;\n}\n\n \nstatic irqreturn_t keystone_rproc_exception_interrupt(int irq, void *dev_id)\n{\n\tstruct keystone_rproc *ksproc = dev_id;\n\n\trproc_report_crash(ksproc->rproc, RPROC_FATAL_ERROR);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void handle_event(struct work_struct *work)\n{\n\tstruct keystone_rproc *ksproc =\n\t\tcontainer_of(work, struct keystone_rproc, workqueue);\n\n\trproc_vq_interrupt(ksproc->rproc, 0);\n\trproc_vq_interrupt(ksproc->rproc, 1);\n}\n\n \nstatic irqreturn_t keystone_rproc_vring_interrupt(int irq, void *dev_id)\n{\n\tstruct keystone_rproc *ksproc = dev_id;\n\n\tschedule_work(&ksproc->workqueue);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int keystone_rproc_start(struct rproc *rproc)\n{\n\tstruct keystone_rproc *ksproc = rproc->priv;\n\tint ret;\n\n\tINIT_WORK(&ksproc->workqueue, handle_event);\n\n\tret = request_irq(ksproc->irq_ring, keystone_rproc_vring_interrupt, 0,\n\t\t\t  dev_name(ksproc->dev), ksproc);\n\tif (ret) {\n\t\tdev_err(ksproc->dev, \"failed to enable vring interrupt, ret = %d\\n\",\n\t\t\tret);\n\t\tgoto out;\n\t}\n\n\tret = request_irq(ksproc->irq_fault, keystone_rproc_exception_interrupt,\n\t\t\t  0, dev_name(ksproc->dev), ksproc);\n\tif (ret) {\n\t\tdev_err(ksproc->dev, \"failed to enable exception interrupt, ret = %d\\n\",\n\t\t\tret);\n\t\tgoto free_vring_irq;\n\t}\n\n\tret = keystone_rproc_dsp_boot(ksproc, rproc->bootaddr);\n\tif (ret)\n\t\tgoto free_exc_irq;\n\n\treturn 0;\n\nfree_exc_irq:\n\tfree_irq(ksproc->irq_fault, ksproc);\nfree_vring_irq:\n\tfree_irq(ksproc->irq_ring, ksproc);\n\tflush_work(&ksproc->workqueue);\nout:\n\treturn ret;\n}\n\n \nstatic int keystone_rproc_stop(struct rproc *rproc)\n{\n\tstruct keystone_rproc *ksproc = rproc->priv;\n\n\tkeystone_rproc_dsp_reset(ksproc);\n\tfree_irq(ksproc->irq_fault, ksproc);\n\tfree_irq(ksproc->irq_ring, ksproc);\n\tflush_work(&ksproc->workqueue);\n\n\treturn 0;\n}\n\n \nstatic void keystone_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct keystone_rproc *ksproc = rproc->priv;\n\n\tif (!ksproc->kick_gpio)\n\t\treturn;\n\n\tgpiod_set_value(ksproc->kick_gpio, 1);\n}\n\n \nstatic void *keystone_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct keystone_rproc *ksproc = rproc->priv;\n\tvoid __iomem *va = NULL;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr, offset;\n\tsize_t size;\n\tint i;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < ksproc->num_mems; i++) {\n\t\tbus_addr = ksproc->mem[i].bus_addr;\n\t\tdev_addr = ksproc->mem[i].dev_addr;\n\t\tsize = ksproc->mem[i].size;\n\n\t\tif (da < KEYSTONE_RPROC_LOCAL_ADDRESS_MASK) {\n\t\t\t \n\t\t\tif ((da >= dev_addr) &&\n\t\t\t    ((da + len) <= (dev_addr + size))) {\n\t\t\t\toffset = da - dev_addr;\n\t\t\t\tva = ksproc->mem[i].cpu_addr + offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif ((da >= bus_addr) &&\n\t\t\t    (da + len) <= (bus_addr + size)) {\n\t\t\t\toffset = da - bus_addr;\n\t\t\t\tva = ksproc->mem[i].cpu_addr + offset;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (__force void *)va;\n}\n\nstatic const struct rproc_ops keystone_rproc_ops = {\n\t.start\t\t= keystone_rproc_start,\n\t.stop\t\t= keystone_rproc_stop,\n\t.kick\t\t= keystone_rproc_kick,\n\t.da_to_va\t= keystone_rproc_da_to_va,\n};\n\nstatic int keystone_rproc_of_get_memories(struct platform_device *pdev,\n\t\t\t\t\t  struct keystone_rproc *ksproc)\n{\n\tstatic const char * const mem_names[] = {\"l2sram\", \"l1pram\", \"l1dram\"};\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint num_mems = 0;\n\tint i;\n\n\tnum_mems = ARRAY_SIZE(mem_names);\n\tksproc->mem = devm_kcalloc(ksproc->dev, num_mems,\n\t\t\t\t   sizeof(*ksproc->mem), GFP_KERNEL);\n\tif (!ksproc->mem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_mems; i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   mem_names[i]);\n\t\tksproc->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(ksproc->mem[i].cpu_addr)) {\n\t\t\tdev_err(dev, \"failed to parse and map %s memory\\n\",\n\t\t\t\tmem_names[i]);\n\t\t\treturn PTR_ERR(ksproc->mem[i].cpu_addr);\n\t\t}\n\t\tksproc->mem[i].bus_addr = res->start;\n\t\tksproc->mem[i].dev_addr =\n\t\t\t\tres->start & KEYSTONE_RPROC_LOCAL_ADDRESS_MASK;\n\t\tksproc->mem[i].size = resource_size(res);\n\n\t\t \n\t\tmemset((__force void *)ksproc->mem[i].cpu_addr, 0,\n\t\t       ksproc->mem[i].size);\n\t}\n\tksproc->num_mems = num_mems;\n\n\treturn 0;\n}\n\nstatic int keystone_rproc_of_get_dev_syscon(struct platform_device *pdev,\n\t\t\t\t\t    struct keystone_rproc *ksproc)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (!of_property_read_bool(np, \"ti,syscon-dev\")) {\n\t\tdev_err(dev, \"ti,syscon-dev property is absent\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tksproc->dev_ctrl =\n\t\tsyscon_regmap_lookup_by_phandle(np, \"ti,syscon-dev\");\n\tif (IS_ERR(ksproc->dev_ctrl)) {\n\t\tret = PTR_ERR(ksproc->dev_ctrl);\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_u32_index(np, \"ti,syscon-dev\", 1,\n\t\t\t\t       &ksproc->boot_offset)) {\n\t\tdev_err(dev, \"couldn't read the boot register offset\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int keystone_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct keystone_rproc *ksproc;\n\tstruct rproc *rproc;\n\tint dsp_id;\n\tchar *fw_name = NULL;\n\tchar *template = \"keystone-dsp%d-fw\";\n\tint name_len = 0;\n\tint ret = 0;\n\n\tif (!np) {\n\t\tdev_err(dev, \"only DT-based devices are supported\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdsp_id = of_alias_get_id(np, \"rproc\");\n\tif (dsp_id < 0) {\n\t\tdev_warn(dev, \"device does not have an alias id\\n\");\n\t\treturn dsp_id;\n\t}\n\n\t \n\tname_len = strlen(template);  \n\tfw_name = devm_kzalloc(dev, name_len, GFP_KERNEL);\n\tif (!fw_name)\n\t\treturn -ENOMEM;\n\tsnprintf(fw_name, name_len, template, dsp_id);\n\n\trproc = rproc_alloc(dev, dev_name(dev), &keystone_rproc_ops, fw_name,\n\t\t\t    sizeof(*ksproc));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\trproc->has_iommu = false;\n\tksproc = rproc->priv;\n\tksproc->rproc = rproc;\n\tksproc->dev = dev;\n\n\tret = keystone_rproc_of_get_dev_syscon(pdev, ksproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tksproc->reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(ksproc->reset)) {\n\t\tret = PTR_ERR(ksproc->reset);\n\t\tgoto free_rproc;\n\t}\n\n\t \n\tpm_runtime_enable(dev);\n\tret = pm_runtime_resume_and_get(dev);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to enable clock, status = %d\\n\", ret);\n\t\tgoto disable_rpm;\n\t}\n\n\tret = keystone_rproc_of_get_memories(pdev, ksproc);\n\tif (ret)\n\t\tgoto disable_clk;\n\n\tksproc->irq_ring = platform_get_irq_byname(pdev, \"vring\");\n\tif (ksproc->irq_ring < 0) {\n\t\tret = ksproc->irq_ring;\n\t\tgoto disable_clk;\n\t}\n\n\tksproc->irq_fault = platform_get_irq_byname(pdev, \"exception\");\n\tif (ksproc->irq_fault < 0) {\n\t\tret = ksproc->irq_fault;\n\t\tgoto disable_clk;\n\t}\n\n\tksproc->kick_gpio = gpiod_get(dev, \"kick\", GPIOD_ASIS);\n\tret = PTR_ERR_OR_ZERO(ksproc->kick_gpio);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get gpio for virtio kicks, status = %d\\n\",\n\t\t\tret);\n\t\tgoto disable_clk;\n\t}\n\n\tif (of_reserved_mem_device_init(dev))\n\t\tdev_warn(dev, \"device does not have specific CMA pool\\n\");\n\n\t \n\tret = reset_control_status(ksproc->reset);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"failed to get reset status, status = %d\\n\", ret);\n\t\tgoto release_mem;\n\t} else if (ret == 0) {\n\t\tWARN(1, \"device is not in reset\\n\");\n\t\tkeystone_rproc_dsp_reset(ksproc);\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add register device with remoteproc core, status = %d\\n\",\n\t\t\tret);\n\t\tgoto release_mem;\n\t}\n\n\tplatform_set_drvdata(pdev, ksproc);\n\n\treturn 0;\n\nrelease_mem:\n\tof_reserved_mem_device_release(dev);\n\tgpiod_put(ksproc->kick_gpio);\ndisable_clk:\n\tpm_runtime_put_sync(dev);\ndisable_rpm:\n\tpm_runtime_disable(dev);\nfree_rproc:\n\trproc_free(rproc);\n\treturn ret;\n}\n\nstatic void keystone_rproc_remove(struct platform_device *pdev)\n{\n\tstruct keystone_rproc *ksproc = platform_get_drvdata(pdev);\n\n\trproc_del(ksproc->rproc);\n\tgpiod_put(ksproc->kick_gpio);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\trproc_free(ksproc->rproc);\n\tof_reserved_mem_device_release(&pdev->dev);\n}\n\nstatic const struct of_device_id keystone_rproc_of_match[] = {\n\t{ .compatible = \"ti,k2hk-dsp\", },\n\t{ .compatible = \"ti,k2l-dsp\", },\n\t{ .compatible = \"ti,k2e-dsp\", },\n\t{ .compatible = \"ti,k2g-dsp\", },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, keystone_rproc_of_match);\n\nstatic struct platform_driver keystone_rproc_driver = {\n\t.probe\t= keystone_rproc_probe,\n\t.remove_new = keystone_rproc_remove,\n\t.driver\t= {\n\t\t.name = \"keystone-rproc\",\n\t\t.of_match_table = keystone_rproc_of_match,\n\t},\n};\n\nmodule_platform_driver(keystone_rproc_driver);\n\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI Keystone DSP Remoteproc driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}