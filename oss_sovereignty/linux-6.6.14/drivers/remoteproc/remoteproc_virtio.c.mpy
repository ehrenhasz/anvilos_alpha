{
  "module_name": "remoteproc_virtio.c",
  "hash_id": "8bf1ddb91b3e3cee842b9ca29ac3e93e55067b2599a06015e034bc66231ba23f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_virtio.c",
  "human_readable_source": "\n \n\n#include <linux/dma-direct.h>\n#include <linux/dma-map-ops.h>\n#include <linux/dma-mapping.h>\n#include <linux/export.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_ring.h>\n#include <linux/err.h>\n#include <linux/kref.h>\n#include <linux/slab.h>\n\n#include \"remoteproc_internal.h\"\n\nstatic int copy_dma_range_map(struct device *to, struct device *from)\n{\n\tconst struct bus_dma_region *map = from->dma_range_map, *new_map, *r;\n\tint num_ranges = 0;\n\n\tif (!map)\n\t\treturn 0;\n\n\tfor (r = map; r->size; r++)\n\t\tnum_ranges++;\n\n\tnew_map = kmemdup(map, array_size(num_ranges + 1, sizeof(*map)),\n\t\t\t  GFP_KERNEL);\n\tif (!new_map)\n\t\treturn -ENOMEM;\n\tto->dma_range_map = new_map;\n\treturn 0;\n}\n\nstatic struct rproc_vdev *vdev_to_rvdev(struct virtio_device *vdev)\n{\n\tstruct platform_device *pdev;\n\n\tpdev = container_of(vdev->dev.parent, struct platform_device, dev);\n\n\treturn platform_get_drvdata(pdev);\n}\n\nstatic  struct rproc *vdev_to_rproc(struct virtio_device *vdev)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\n\treturn rvdev->rproc;\n}\n\n \nstatic bool rproc_virtio_notify(struct virtqueue *vq)\n{\n\tstruct rproc_vring *rvring = vq->priv;\n\tstruct rproc *rproc = rvring->rvdev->rproc;\n\tint notifyid = rvring->notifyid;\n\n\tdev_dbg(&rproc->dev, \"kicking vq index: %d\\n\", notifyid);\n\n\trproc->ops->kick(rproc, notifyid);\n\treturn true;\n}\n\n \nirqreturn_t rproc_vq_interrupt(struct rproc *rproc, int notifyid)\n{\n\tstruct rproc_vring *rvring;\n\n\tdev_dbg(&rproc->dev, \"vq index %d is interrupted\\n\", notifyid);\n\n\trvring = idr_find(&rproc->notifyids, notifyid);\n\tif (!rvring || !rvring->vq)\n\t\treturn IRQ_NONE;\n\n\treturn vring_interrupt(0, rvring->vq);\n}\nEXPORT_SYMBOL(rproc_vq_interrupt);\n\nstatic struct virtqueue *rp_find_vq(struct virtio_device *vdev,\n\t\t\t\t    unsigned int id,\n\t\t\t\t    void (*callback)(struct virtqueue *vq),\n\t\t\t\t    const char *name, bool ctx)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct rproc *rproc = vdev_to_rproc(vdev);\n\tstruct device *dev = &rproc->dev;\n\tstruct rproc_mem_entry *mem;\n\tstruct rproc_vring *rvring;\n\tstruct fw_rsc_vdev *rsc;\n\tstruct virtqueue *vq;\n\tvoid *addr;\n\tint num, size;\n\n\t \n\tif (id >= ARRAY_SIZE(rvdev->vring))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (!name)\n\t\treturn NULL;\n\n\t \n\tmem = rproc_find_carveout_by_name(rproc, \"vdev%dvring%d\", rvdev->index,\n\t\t\t\t\t  id);\n\tif (!mem || !mem->va)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\trvring = &rvdev->vring[id];\n\taddr = mem->va;\n\tnum = rvring->num;\n\n\t \n\tsize = vring_size(num, rvring->align);\n\tmemset(addr, 0, size);\n\n\tdev_dbg(dev, \"vring%d: va %pK qsz %d notifyid %d\\n\",\n\t\tid, addr, num, rvring->notifyid);\n\n\t \n\tvq = vring_new_virtqueue(id, num, rvring->align, vdev, false, ctx,\n\t\t\t\t addr, rproc_virtio_notify, callback, name);\n\tif (!vq) {\n\t\tdev_err(dev, \"vring_new_virtqueue %s failed\\n\", name);\n\t\trproc_free_vring(rvring);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tvq->num_max = num;\n\n\trvring->vq = vq;\n\tvq->priv = rvring;\n\n\t \n\trsc = (void *)rproc->table_ptr + rvdev->rsc_offset;\n\trsc->vring[id].da = mem->da;\n\n\treturn vq;\n}\n\nstatic void __rproc_virtio_del_vqs(struct virtio_device *vdev)\n{\n\tstruct virtqueue *vq, *n;\n\tstruct rproc_vring *rvring;\n\n\tlist_for_each_entry_safe(vq, n, &vdev->vqs, list) {\n\t\trvring = vq->priv;\n\t\trvring->vq = NULL;\n\t\tvring_del_virtqueue(vq);\n\t}\n}\n\nstatic void rproc_virtio_del_vqs(struct virtio_device *vdev)\n{\n\t__rproc_virtio_del_vqs(vdev);\n}\n\nstatic int rproc_virtio_find_vqs(struct virtio_device *vdev, unsigned int nvqs,\n\t\t\t\t struct virtqueue *vqs[],\n\t\t\t\t vq_callback_t *callbacks[],\n\t\t\t\t const char * const names[],\n\t\t\t\t const bool * ctx,\n\t\t\t\t struct irq_affinity *desc)\n{\n\tint i, ret, queue_idx = 0;\n\n\tfor (i = 0; i < nvqs; ++i) {\n\t\tif (!names[i]) {\n\t\t\tvqs[i] = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvqs[i] = rp_find_vq(vdev, queue_idx++, callbacks[i], names[i],\n\t\t\t\t    ctx ? ctx[i] : false);\n\t\tif (IS_ERR(vqs[i])) {\n\t\t\tret = PTR_ERR(vqs[i]);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\treturn 0;\n\nerror:\n\t__rproc_virtio_del_vqs(vdev);\n\treturn ret;\n}\n\nstatic u8 rproc_virtio_get_status(struct virtio_device *vdev)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\n\treturn rsc->status;\n}\n\nstatic void rproc_virtio_set_status(struct virtio_device *vdev, u8 status)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\n\trsc->status = status;\n\tdev_dbg(&vdev->dev, \"status: %d\\n\", status);\n}\n\nstatic void rproc_virtio_reset(struct virtio_device *vdev)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\n\trsc->status = 0;\n\tdev_dbg(&vdev->dev, \"reset !\\n\");\n}\n\n \nstatic u64 rproc_virtio_get_features(struct virtio_device *vdev)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\n\treturn rsc->dfeatures;\n}\n\nstatic void rproc_transport_features(struct virtio_device *vdev)\n{\n\t \n\t__virtio_clear_bit(vdev, VIRTIO_F_RING_PACKED);\n}\n\nstatic int rproc_virtio_finalize_features(struct virtio_device *vdev)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\n\t \n\tvring_transport_features(vdev);\n\n\t \n\trproc_transport_features(vdev);\n\n\t \n\tBUG_ON((u32)vdev->features != vdev->features);\n\n\t \n\trsc->gfeatures = vdev->features;\n\n\treturn 0;\n}\n\nstatic void rproc_virtio_get(struct virtio_device *vdev, unsigned int offset,\n\t\t\t     void *buf, unsigned int len)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\tvoid *cfg;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\tcfg = &rsc->vring[rsc->num_of_vrings];\n\n\tif (offset + len > rsc->config_len || offset + len < len) {\n\t\tdev_err(&vdev->dev, \"rproc_virtio_get: access out of bounds\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(buf, cfg + offset, len);\n}\n\nstatic void rproc_virtio_set(struct virtio_device *vdev, unsigned int offset,\n\t\t\t     const void *buf, unsigned int len)\n{\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\tstruct fw_rsc_vdev *rsc;\n\tvoid *cfg;\n\n\trsc = (void *)rvdev->rproc->table_ptr + rvdev->rsc_offset;\n\tcfg = &rsc->vring[rsc->num_of_vrings];\n\n\tif (offset + len > rsc->config_len || offset + len < len) {\n\t\tdev_err(&vdev->dev, \"rproc_virtio_set: access out of bounds\\n\");\n\t\treturn;\n\t}\n\n\tmemcpy(cfg + offset, buf, len);\n}\n\nstatic const struct virtio_config_ops rproc_virtio_config_ops = {\n\t.get_features\t= rproc_virtio_get_features,\n\t.finalize_features = rproc_virtio_finalize_features,\n\t.find_vqs\t= rproc_virtio_find_vqs,\n\t.del_vqs\t= rproc_virtio_del_vqs,\n\t.reset\t\t= rproc_virtio_reset,\n\t.set_status\t= rproc_virtio_set_status,\n\t.get_status\t= rproc_virtio_get_status,\n\t.get\t\t= rproc_virtio_get,\n\t.set\t\t= rproc_virtio_set,\n};\n\n \nstatic void rproc_virtio_dev_release(struct device *dev)\n{\n\tstruct virtio_device *vdev = dev_to_virtio(dev);\n\tstruct rproc_vdev *rvdev = vdev_to_rvdev(vdev);\n\n\tkfree(vdev);\n\n\tput_device(&rvdev->pdev->dev);\n}\n\n \nstatic int rproc_add_virtio_dev(struct rproc_vdev *rvdev, int id)\n{\n\tstruct rproc *rproc = rvdev->rproc;\n\tstruct device *dev = &rvdev->pdev->dev;\n\tstruct virtio_device *vdev;\n\tstruct rproc_mem_entry *mem;\n\tint ret;\n\n\tif (rproc->ops->kick == NULL) {\n\t\tret = -EINVAL;\n\t\tdev_err(dev, \".kick method not defined for %s\\n\", rproc->name);\n\t\tgoto out;\n\t}\n\n\t \n\tmem = rproc_find_carveout_by_name(rproc, \"vdev%dbuffer\", rvdev->index);\n\tif (mem) {\n\t\tphys_addr_t pa;\n\n\t\tif (mem->of_resm_idx != -1) {\n\t\t\tstruct device_node *np = rproc->dev.parent->of_node;\n\n\t\t\t \n\t\t\tret = of_reserved_mem_device_init_by_idx(dev, np,\n\t\t\t\t\t\t\t\t mem->of_resm_idx);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"Can't associate reserved memory\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mem->va) {\n\t\t\t\tdev_warn(dev, \"vdev %d buffer already mapped\\n\",\n\t\t\t\t\t rvdev->index);\n\t\t\t\tpa = rproc_va_to_pa(mem->va);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tpa = (phys_addr_t)mem->dma;\n\t\t\t}\n\n\t\t\t \n\t\t\tret = dma_declare_coherent_memory(dev, pa,\n\t\t\t\t\t\t\t   mem->da,\n\t\t\t\t\t\t\t   mem->len);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"Failed to associate buffer\\n\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tstruct device_node *np = rproc->dev.parent->of_node;\n\n\t\t \n\t\tof_reserved_mem_device_init_by_idx(dev, np, 0);\n\t}\n\n\t \n\tvdev = kzalloc(sizeof(*vdev), GFP_KERNEL);\n\tif (!vdev) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tvdev->id.device\t= id,\n\tvdev->config = &rproc_virtio_config_ops,\n\tvdev->dev.parent = dev;\n\tvdev->dev.release = rproc_virtio_dev_release;\n\n\t \n\tget_device(dev);\n\n\tret = register_virtio_device(vdev);\n\tif (ret) {\n\t\tput_device(&vdev->dev);\n\t\tdev_err(dev, \"failed to register vdev: %d\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tdev_info(dev, \"registered %s (type %d)\\n\", dev_name(&vdev->dev), id);\n\nout:\n\treturn ret;\n}\n\n \nstatic int rproc_remove_virtio_dev(struct device *dev, void *data)\n{\n\tstruct virtio_device *vdev = dev_to_virtio(dev);\n\n\tunregister_virtio_device(vdev);\n\treturn 0;\n}\n\nstatic int rproc_vdev_do_start(struct rproc_subdev *subdev)\n{\n\tstruct rproc_vdev *rvdev = container_of(subdev, struct rproc_vdev, subdev);\n\n\treturn rproc_add_virtio_dev(rvdev, rvdev->id);\n}\n\nstatic void rproc_vdev_do_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct rproc_vdev *rvdev = container_of(subdev, struct rproc_vdev, subdev);\n\tstruct device *dev = &rvdev->pdev->dev;\n\tint ret;\n\n\tret = device_for_each_child(dev, NULL, rproc_remove_virtio_dev);\n\tif (ret)\n\t\tdev_warn(dev, \"can't remove vdev child device: %d\\n\", ret);\n}\n\nstatic int rproc_virtio_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rproc_vdev_data *rvdev_data = dev->platform_data;\n\tstruct rproc_vdev *rvdev;\n\tstruct rproc *rproc = container_of(dev->parent, struct rproc, dev);\n\tstruct fw_rsc_vdev *rsc;\n\tint i, ret;\n\n\tif (!rvdev_data)\n\t\treturn -EINVAL;\n\n\trvdev = devm_kzalloc(dev, sizeof(*rvdev), GFP_KERNEL);\n\tif (!rvdev)\n\t\treturn -ENOMEM;\n\n\trvdev->id = rvdev_data->id;\n\trvdev->rproc = rproc;\n\trvdev->index = rvdev_data->index;\n\n\tret = copy_dma_range_map(dev, rproc->dev.parent);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tset_dma_ops(dev, get_dma_ops(rproc->dev.parent));\n\n\tret = dma_coerce_mask_and_coherent(dev, dma_get_mask(rproc->dev.parent));\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to set DMA mask %llx. Trying to continue... (%pe)\\n\",\n\t\t\t dma_get_mask(rproc->dev.parent), ERR_PTR(ret));\n\t}\n\n\tplatform_set_drvdata(pdev, rvdev);\n\trvdev->pdev = pdev;\n\n\trsc = rvdev_data->rsc;\n\n\t \n\tfor (i = 0; i < rsc->num_of_vrings; i++) {\n\t\tret = rproc_parse_vring(rvdev, rsc, i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\trvdev->rsc_offset = rvdev_data->rsc_offset;\n\n\t \n\tfor (i = 0; i < rsc->num_of_vrings; i++) {\n\t\tret = rproc_alloc_vring(rvdev, i);\n\t\tif (ret)\n\t\t\tgoto unwind_vring_allocations;\n\t}\n\n\trproc_add_rvdev(rproc, rvdev);\n\n\trvdev->subdev.start = rproc_vdev_do_start;\n\trvdev->subdev.stop = rproc_vdev_do_stop;\n\n\trproc_add_subdev(rproc, &rvdev->subdev);\n\n\t \n\tget_device(&rproc->dev);\n\n\treturn 0;\n\nunwind_vring_allocations:\n\tfor (i--; i >= 0; i--)\n\t\trproc_free_vring(&rvdev->vring[i]);\n\n\treturn ret;\n}\n\nstatic void rproc_virtio_remove(struct platform_device *pdev)\n{\n\tstruct rproc_vdev *rvdev = dev_get_drvdata(&pdev->dev);\n\tstruct rproc *rproc = rvdev->rproc;\n\tstruct rproc_vring *rvring;\n\tint id;\n\n\tfor (id = 0; id < ARRAY_SIZE(rvdev->vring); id++) {\n\t\trvring = &rvdev->vring[id];\n\t\trproc_free_vring(rvring);\n\t}\n\n\trproc_remove_subdev(rproc, &rvdev->subdev);\n\trproc_remove_rvdev(rvdev);\n\n\tof_reserved_mem_device_release(&pdev->dev);\n\tdma_release_coherent_memory(&pdev->dev);\n\n\tput_device(&rproc->dev);\n}\n\n \nstatic struct platform_driver rproc_virtio_driver = {\n\t.probe\t\t= rproc_virtio_probe,\n\t.remove_new\t= rproc_virtio_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"rproc-virtio\",\n\t},\n};\nbuiltin_platform_driver(rproc_virtio_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}