{
  "module_name": "qcom_common.c",
  "hash_id": "37b3cff1d096140f986ebcf516b20380848895531537bc21fef2d57eb959094a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_common.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/remoteproc.h>\n#include <linux/remoteproc/qcom_rproc.h>\n#include <linux/rpmsg/qcom_glink.h>\n#include <linux/rpmsg/qcom_smd.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include <linux/soc/qcom/smem.h>\n\n#include \"remoteproc_internal.h\"\n#include \"qcom_common.h\"\n\n#define to_glink_subdev(d) container_of(d, struct qcom_rproc_glink, subdev)\n#define to_smd_subdev(d) container_of(d, struct qcom_rproc_subdev, subdev)\n#define to_ssr_subdev(d) container_of(d, struct qcom_rproc_ssr, subdev)\n\n#define MAX_NUM_OF_SS           10\n#define MAX_REGION_NAME_LENGTH  16\n#define SBL_MINIDUMP_SMEM_ID\t602\n#define MINIDUMP_REGION_VALID\t\t('V' << 24 | 'A' << 16 | 'L' << 8 | 'I' << 0)\n#define MINIDUMP_SS_ENCR_DONE\t\t('D' << 24 | 'O' << 16 | 'N' << 8 | 'E' << 0)\n#define MINIDUMP_SS_ENABLED\t\t('E' << 24 | 'N' << 16 | 'B' << 8 | 'L' << 0)\n\n \nstruct minidump_region {\n\tchar\tname[MAX_REGION_NAME_LENGTH];\n\t__le32\tseq_num;\n\t__le32\tvalid;\n\t__le64\taddress;\n\t__le64\tsize;\n};\n\n \nstruct minidump_subsystem {\n\t__le32\tstatus;\n\t__le32\tenabled;\n\t__le32\tencryption_status;\n\t__le32\tencryption_required;\n\t__le32\tregion_count;\n\t__le64\tregions_baseptr;\n};\n\n \nstruct minidump_global_toc {\n\t__le32\t\t\t\tstatus;\n\t__le32\t\t\t\tmd_revision;\n\t__le32\t\t\t\tenabled;\n\tstruct minidump_subsystem\tsubsystems[MAX_NUM_OF_SS];\n};\n\nstruct qcom_ssr_subsystem {\n\tconst char *name;\n\tstruct srcu_notifier_head notifier_list;\n\tstruct list_head list;\n};\n\nstatic LIST_HEAD(qcom_ssr_subsystem_list);\nstatic DEFINE_MUTEX(qcom_ssr_subsys_lock);\n\nstatic void qcom_minidump_cleanup(struct rproc *rproc)\n{\n\tstruct rproc_dump_segment *entry, *tmp;\n\n\tlist_for_each_entry_safe(entry, tmp, &rproc->dump_segments, node) {\n\t\tlist_del(&entry->node);\n\t\tkfree(entry->priv);\n\t\tkfree(entry);\n\t}\n}\n\nstatic int qcom_add_minidump_segments(struct rproc *rproc, struct minidump_subsystem *subsystem,\n\t\t\tvoid (*rproc_dumpfn_t)(struct rproc *rproc, struct rproc_dump_segment *segment,\n\t\t\t\tvoid *dest, size_t offset, size_t size))\n{\n\tstruct minidump_region __iomem *ptr;\n\tstruct minidump_region region;\n\tint seg_cnt, i;\n\tdma_addr_t da;\n\tsize_t size;\n\tchar *name;\n\n\tif (WARN_ON(!list_empty(&rproc->dump_segments))) {\n\t\tdev_err(&rproc->dev, \"dump segment list already populated\\n\");\n\t\treturn -EUCLEAN;\n\t}\n\n\tseg_cnt = le32_to_cpu(subsystem->region_count);\n\tptr = ioremap((unsigned long)le64_to_cpu(subsystem->regions_baseptr),\n\t\t      seg_cnt * sizeof(struct minidump_region));\n\tif (!ptr)\n\t\treturn -EFAULT;\n\n\tfor (i = 0; i < seg_cnt; i++) {\n\t\tmemcpy_fromio(&region, ptr + i, sizeof(region));\n\t\tif (le32_to_cpu(region.valid) == MINIDUMP_REGION_VALID) {\n\t\t\tname = kstrndup(region.name, MAX_REGION_NAME_LENGTH - 1, GFP_KERNEL);\n\t\t\tif (!name) {\n\t\t\t\tiounmap(ptr);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tda = le64_to_cpu(region.address);\n\t\t\tsize = le64_to_cpu(region.size);\n\t\t\trproc_coredump_add_custom_segment(rproc, da, size, rproc_dumpfn_t, name);\n\t\t}\n\t}\n\n\tiounmap(ptr);\n\treturn 0;\n}\n\nvoid qcom_minidump(struct rproc *rproc, unsigned int minidump_id,\n\t\tvoid (*rproc_dumpfn_t)(struct rproc *rproc,\n\t\tstruct rproc_dump_segment *segment, void *dest, size_t offset,\n\t\tsize_t size))\n{\n\tint ret;\n\tstruct minidump_subsystem *subsystem;\n\tstruct minidump_global_toc *toc;\n\n\t \n\ttoc = qcom_smem_get(QCOM_SMEM_HOST_ANY, SBL_MINIDUMP_SMEM_ID, NULL);\n\n\t \n\tif (IS_ERR(toc) || !toc->status) {\n\t\tdev_err(&rproc->dev, \"Minidump TOC not found in SMEM\\n\");\n\t\treturn;\n\t}\n\n\t \n\tsubsystem = &toc->subsystems[minidump_id];\n\n\t \n\tif (subsystem->regions_baseptr == 0 ||\n\t    le32_to_cpu(subsystem->status) != 1 ||\n\t    le32_to_cpu(subsystem->enabled) != MINIDUMP_SS_ENABLED) {\n\t\treturn rproc_coredump(rproc);\n\t}\n\n\tif (le32_to_cpu(subsystem->encryption_status) != MINIDUMP_SS_ENCR_DONE) {\n\t\tdev_err(&rproc->dev, \"Minidump not ready, skipping\\n\");\n\t\treturn;\n\t}\n\n\t \n\trproc_coredump_cleanup(rproc);\n\n\tret = qcom_add_minidump_segments(rproc, subsystem, rproc_dumpfn_t);\n\tif (ret) {\n\t\tdev_err(&rproc->dev, \"Failed with error: %d while adding minidump entries\\n\", ret);\n\t\tgoto clean_minidump;\n\t}\n\trproc_coredump_using_sections(rproc);\nclean_minidump:\n\tqcom_minidump_cleanup(rproc);\n}\nEXPORT_SYMBOL_GPL(qcom_minidump);\n\nstatic int glink_subdev_start(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_glink *glink = to_glink_subdev(subdev);\n\n\tglink->edge = qcom_glink_smem_register(glink->dev, glink->node);\n\n\treturn PTR_ERR_OR_ZERO(glink->edge);\n}\n\nstatic void glink_subdev_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct qcom_rproc_glink *glink = to_glink_subdev(subdev);\n\n\tqcom_glink_smem_unregister(glink->edge);\n\tglink->edge = NULL;\n}\n\nstatic void glink_subdev_unprepare(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_glink *glink = to_glink_subdev(subdev);\n\n\tqcom_glink_ssr_notify(glink->ssr_name);\n}\n\n \nvoid qcom_add_glink_subdev(struct rproc *rproc, struct qcom_rproc_glink *glink,\n\t\t\t   const char *ssr_name)\n{\n\tstruct device *dev = &rproc->dev;\n\n\tglink->node = of_get_child_by_name(dev->parent->of_node, \"glink-edge\");\n\tif (!glink->node)\n\t\treturn;\n\n\tglink->ssr_name = kstrdup_const(ssr_name, GFP_KERNEL);\n\tif (!glink->ssr_name)\n\t\treturn;\n\n\tglink->dev = dev;\n\tglink->subdev.start = glink_subdev_start;\n\tglink->subdev.stop = glink_subdev_stop;\n\tglink->subdev.unprepare = glink_subdev_unprepare;\n\n\trproc_add_subdev(rproc, &glink->subdev);\n}\nEXPORT_SYMBOL_GPL(qcom_add_glink_subdev);\n\n \nvoid qcom_remove_glink_subdev(struct rproc *rproc, struct qcom_rproc_glink *glink)\n{\n\tif (!glink->node)\n\t\treturn;\n\n\trproc_remove_subdev(rproc, &glink->subdev);\n\tkfree_const(glink->ssr_name);\n\tof_node_put(glink->node);\n}\nEXPORT_SYMBOL_GPL(qcom_remove_glink_subdev);\n\n \nint qcom_register_dump_segments(struct rproc *rproc,\n\t\t\t\tconst struct firmware *fw)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct elf32_hdr *ehdr;\n\tint ret;\n\tint i;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (phdr->p_type != PT_LOAD)\n\t\t\tcontinue;\n\n\t\tif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\n\t\t\tcontinue;\n\n\t\tif (!phdr->p_memsz)\n\t\t\tcontinue;\n\n\t\tret = rproc_coredump_add_segment(rproc, phdr->p_paddr,\n\t\t\t\t\t\t phdr->p_memsz);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_register_dump_segments);\n\nstatic int smd_subdev_start(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_subdev *smd = to_smd_subdev(subdev);\n\n\tsmd->edge = qcom_smd_register_edge(smd->dev, smd->node);\n\n\treturn PTR_ERR_OR_ZERO(smd->edge);\n}\n\nstatic void smd_subdev_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct qcom_rproc_subdev *smd = to_smd_subdev(subdev);\n\n\tqcom_smd_unregister_edge(smd->edge);\n\tsmd->edge = NULL;\n}\n\n \nvoid qcom_add_smd_subdev(struct rproc *rproc, struct qcom_rproc_subdev *smd)\n{\n\tstruct device *dev = &rproc->dev;\n\n\tsmd->node = of_get_child_by_name(dev->parent->of_node, \"smd-edge\");\n\tif (!smd->node)\n\t\treturn;\n\n\tsmd->dev = dev;\n\tsmd->subdev.start = smd_subdev_start;\n\tsmd->subdev.stop = smd_subdev_stop;\n\n\trproc_add_subdev(rproc, &smd->subdev);\n}\nEXPORT_SYMBOL_GPL(qcom_add_smd_subdev);\n\n \nvoid qcom_remove_smd_subdev(struct rproc *rproc, struct qcom_rproc_subdev *smd)\n{\n\tif (!smd->node)\n\t\treturn;\n\n\trproc_remove_subdev(rproc, &smd->subdev);\n\tof_node_put(smd->node);\n}\nEXPORT_SYMBOL_GPL(qcom_remove_smd_subdev);\n\nstatic struct qcom_ssr_subsystem *qcom_ssr_get_subsys(const char *name)\n{\n\tstruct qcom_ssr_subsystem *info;\n\n\tmutex_lock(&qcom_ssr_subsys_lock);\n\t \n\tlist_for_each_entry(info, &qcom_ssr_subsystem_list, list)\n\t\tif (!strcmp(info->name, name))\n\t\t\tgoto out;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info) {\n\t\tinfo = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\tinfo->name = kstrdup_const(name, GFP_KERNEL);\n\tsrcu_init_notifier_head(&info->notifier_list);\n\n\t \n\tlist_add_tail(&info->list, &qcom_ssr_subsystem_list);\n\nout:\n\tmutex_unlock(&qcom_ssr_subsys_lock);\n\treturn info;\n}\n\n \nvoid *qcom_register_ssr_notifier(const char *name, struct notifier_block *nb)\n{\n\tstruct qcom_ssr_subsystem *info;\n\n\tinfo = qcom_ssr_get_subsys(name);\n\tif (IS_ERR(info))\n\t\treturn info;\n\n\tsrcu_notifier_chain_register(&info->notifier_list, nb);\n\n\treturn &info->notifier_list;\n}\nEXPORT_SYMBOL_GPL(qcom_register_ssr_notifier);\n\n \nint qcom_unregister_ssr_notifier(void *notify, struct notifier_block *nb)\n{\n\treturn srcu_notifier_chain_unregister(notify, nb);\n}\nEXPORT_SYMBOL_GPL(qcom_unregister_ssr_notifier);\n\nstatic int ssr_notify_prepare(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_ssr *ssr = to_ssr_subdev(subdev);\n\tstruct qcom_ssr_notify_data data = {\n\t\t.name = ssr->info->name,\n\t\t.crashed = false,\n\t};\n\n\tsrcu_notifier_call_chain(&ssr->info->notifier_list,\n\t\t\t\t QCOM_SSR_BEFORE_POWERUP, &data);\n\treturn 0;\n}\n\nstatic int ssr_notify_start(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_ssr *ssr = to_ssr_subdev(subdev);\n\tstruct qcom_ssr_notify_data data = {\n\t\t.name = ssr->info->name,\n\t\t.crashed = false,\n\t};\n\n\tsrcu_notifier_call_chain(&ssr->info->notifier_list,\n\t\t\t\t QCOM_SSR_AFTER_POWERUP, &data);\n\treturn 0;\n}\n\nstatic void ssr_notify_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct qcom_rproc_ssr *ssr = to_ssr_subdev(subdev);\n\tstruct qcom_ssr_notify_data data = {\n\t\t.name = ssr->info->name,\n\t\t.crashed = crashed,\n\t};\n\n\tsrcu_notifier_call_chain(&ssr->info->notifier_list,\n\t\t\t\t QCOM_SSR_BEFORE_SHUTDOWN, &data);\n}\n\nstatic void ssr_notify_unprepare(struct rproc_subdev *subdev)\n{\n\tstruct qcom_rproc_ssr *ssr = to_ssr_subdev(subdev);\n\tstruct qcom_ssr_notify_data data = {\n\t\t.name = ssr->info->name,\n\t\t.crashed = false,\n\t};\n\n\tsrcu_notifier_call_chain(&ssr->info->notifier_list,\n\t\t\t\t QCOM_SSR_AFTER_SHUTDOWN, &data);\n}\n\n \nvoid qcom_add_ssr_subdev(struct rproc *rproc, struct qcom_rproc_ssr *ssr,\n\t\t\t const char *ssr_name)\n{\n\tstruct qcom_ssr_subsystem *info;\n\n\tinfo = qcom_ssr_get_subsys(ssr_name);\n\tif (IS_ERR(info)) {\n\t\tdev_err(&rproc->dev, \"Failed to add ssr subdevice\\n\");\n\t\treturn;\n\t}\n\n\tssr->info = info;\n\tssr->subdev.prepare = ssr_notify_prepare;\n\tssr->subdev.start = ssr_notify_start;\n\tssr->subdev.stop = ssr_notify_stop;\n\tssr->subdev.unprepare = ssr_notify_unprepare;\n\n\trproc_add_subdev(rproc, &ssr->subdev);\n}\nEXPORT_SYMBOL_GPL(qcom_add_ssr_subdev);\n\n \nvoid qcom_remove_ssr_subdev(struct rproc *rproc, struct qcom_rproc_ssr *ssr)\n{\n\trproc_remove_subdev(rproc, &ssr->subdev);\n\tssr->info = NULL;\n}\nEXPORT_SYMBOL_GPL(qcom_remove_ssr_subdev);\n\nMODULE_DESCRIPTION(\"Qualcomm Remoteproc helper driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}