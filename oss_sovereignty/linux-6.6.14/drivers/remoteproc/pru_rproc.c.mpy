{
  "module_name": "pru_rproc.c",
  "hash_id": "118e9de68bf63c0cdc9be632426823e579c43a73f71a04a3f576d6099118acef",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/pru_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/debugfs.h>\n#include <linux/irqdomain.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc/pruss.h>\n#include <linux/pruss_driver.h>\n#include <linux/remoteproc.h>\n\n#include \"remoteproc_internal.h\"\n#include \"remoteproc_elf_helpers.h\"\n#include \"pru_rproc.h\"\n\n \n#define PRU_CTRL_CTRL\t\t0x0000\n#define PRU_CTRL_STS\t\t0x0004\n#define PRU_CTRL_WAKEUP_EN\t0x0008\n#define PRU_CTRL_CYCLE\t\t0x000C\n#define PRU_CTRL_STALL\t\t0x0010\n#define PRU_CTRL_CTBIR0\t\t0x0020\n#define PRU_CTRL_CTBIR1\t\t0x0024\n#define PRU_CTRL_CTPPR0\t\t0x0028\n#define PRU_CTRL_CTPPR1\t\t0x002C\n\n \n#define CTRL_CTRL_SOFT_RST_N\tBIT(0)\n#define CTRL_CTRL_EN\t\tBIT(1)\n#define CTRL_CTRL_SLEEPING\tBIT(2)\n#define CTRL_CTRL_CTR_EN\tBIT(3)\n#define CTRL_CTRL_SINGLE_STEP\tBIT(8)\n#define CTRL_CTRL_RUNSTATE\tBIT(15)\n\n \n#define PRU_DEBUG_GPREG(x)\t(0x0000 + (x) * 4)\n#define PRU_DEBUG_CT_REG(x)\t(0x0080 + (x) * 4)\n\n \n#define PRU_IRAM_ADDR_MASK\t0x3ffff\n#define PRU0_IRAM_ADDR_MASK\t0x34000\n#define PRU1_IRAM_ADDR_MASK\t0x38000\n#define RTU0_IRAM_ADDR_MASK\t0x4000\n#define RTU1_IRAM_ADDR_MASK\t0x6000\n#define TX_PRU0_IRAM_ADDR_MASK\t0xa000\n#define TX_PRU1_IRAM_ADDR_MASK\t0xc000\n\n \n#define PRU_IRAM_DA\t0\t \n#define PRU_PDRAM_DA\t0\t \n#define PRU_SDRAM_DA\t0x2000\t \n#define PRU_SHRDRAM_DA\t0x10000  \n\n#define MAX_PRU_SYS_EVENTS 160\n\n \nenum pru_iomem {\n\tPRU_IOMEM_IRAM = 0,\n\tPRU_IOMEM_CTRL,\n\tPRU_IOMEM_DEBUG,\n\tPRU_IOMEM_MAX,\n};\n\n \nstruct pru_private_data {\n\tenum pru_type type;\n\tunsigned int is_k3 : 1;\n};\n\n \nstruct pru_rproc {\n\tint id;\n\tstruct device *dev;\n\tstruct pruss *pruss;\n\tstruct rproc *rproc;\n\tconst struct pru_private_data *data;\n\tstruct pruss_mem_region mem_regions[PRU_IOMEM_MAX];\n\tstruct device_node *client_np;\n\tstruct mutex lock;\n\tconst char *fw_name;\n\tunsigned int *mapped_irq;\n\tstruct pru_irq_rsc *pru_interrupt_map;\n\tsize_t pru_interrupt_map_sz;\n\tspinlock_t rmw_lock;\n\tu32 dbg_single_step;\n\tu32 dbg_continuous;\n\tu8 evt_count;\n\tu8 gpmux_save;\n};\n\nstatic inline u32 pru_control_read_reg(struct pru_rproc *pru, unsigned int reg)\n{\n\treturn readl_relaxed(pru->mem_regions[PRU_IOMEM_CTRL].va + reg);\n}\n\nstatic inline\nvoid pru_control_write_reg(struct pru_rproc *pru, unsigned int reg, u32 val)\n{\n\twritel_relaxed(val, pru->mem_regions[PRU_IOMEM_CTRL].va + reg);\n}\n\nstatic inline\nvoid pru_control_set_reg(struct pru_rproc *pru, unsigned int reg,\n\t\t\t u32 mask, u32 set)\n{\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pru->rmw_lock, flags);\n\n\tval = pru_control_read_reg(pru, reg);\n\tval &= ~mask;\n\tval |= (set & mask);\n\tpru_control_write_reg(pru, reg, val);\n\n\tspin_unlock_irqrestore(&pru->rmw_lock, flags);\n}\n\n \nstatic int pru_rproc_set_firmware(struct rproc *rproc, const char *fw_name)\n{\n\tstruct pru_rproc *pru = rproc->priv;\n\n\tif (!fw_name)\n\t\tfw_name = pru->fw_name;\n\n\treturn rproc_set_firmware(rproc, fw_name);\n}\n\nstatic struct rproc *__pru_rproc_get(struct device_node *np, int index)\n{\n\tstruct rproc *rproc;\n\tphandle rproc_phandle;\n\tint ret;\n\n\tret = of_property_read_u32_index(np, \"ti,prus\", index, &rproc_phandle);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\trproc = rproc_get_by_phandle(rproc_phandle);\n\tif (!rproc) {\n\t\tret = -EPROBE_DEFER;\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t \n\tif (!is_pru_rproc(rproc->dev.parent)) {\n\t\trproc_put(rproc);\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\treturn rproc;\n}\n\n \nstruct rproc *pru_rproc_get(struct device_node *np, int index,\n\t\t\t    enum pruss_pru_id *pru_id)\n{\n\tstruct rproc *rproc;\n\tstruct pru_rproc *pru;\n\tstruct device *dev;\n\tconst char *fw_name;\n\tint ret;\n\tu32 mux;\n\n\trproc = __pru_rproc_get(np, index);\n\tif (IS_ERR(rproc))\n\t\treturn rproc;\n\n\tpru = rproc->priv;\n\tdev = &rproc->dev;\n\n\tmutex_lock(&pru->lock);\n\n\tif (pru->client_np) {\n\t\tmutex_unlock(&pru->lock);\n\t\tret = -EBUSY;\n\t\tgoto err_no_rproc_handle;\n\t}\n\n\tpru->client_np = np;\n\trproc->sysfs_read_only = true;\n\n\tmutex_unlock(&pru->lock);\n\n\tif (pru_id)\n\t\t*pru_id = pru->id;\n\n\tret = pruss_cfg_get_gpmux(pru->pruss, pru->id, &pru->gpmux_save);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get cfg gpmux: %d\\n\", ret);\n\t\tgoto err;\n\t}\n\n\t \n\tret = of_property_read_u32_index(np, \"ti,pruss-gp-mux-sel\", index,\n\t\t\t\t\t &mux);\n\tif (!ret) {\n\t\tret = pruss_cfg_set_gpmux(pru->pruss, pru->id, mux);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set cfg gpmux: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tret = of_property_read_string_index(np, \"firmware-name\", index,\n\t\t\t\t\t    &fw_name);\n\tif (!ret) {\n\t\tret = pru_rproc_set_firmware(rproc, fw_name);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set firmware: %d\\n\", ret);\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn rproc;\n\nerr_no_rproc_handle:\n\trproc_put(rproc);\n\treturn ERR_PTR(ret);\n\nerr:\n\tpru_rproc_put(rproc);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(pru_rproc_get);\n\n \nvoid pru_rproc_put(struct rproc *rproc)\n{\n\tstruct pru_rproc *pru;\n\n\tif (IS_ERR_OR_NULL(rproc) || !is_pru_rproc(rproc->dev.parent))\n\t\treturn;\n\n\tpru = rproc->priv;\n\n\tpruss_cfg_set_gpmux(pru->pruss, pru->id, pru->gpmux_save);\n\n\tpru_rproc_set_firmware(rproc, NULL);\n\n\tmutex_lock(&pru->lock);\n\n\tif (!pru->client_np) {\n\t\tmutex_unlock(&pru->lock);\n\t\treturn;\n\t}\n\n\tpru->client_np = NULL;\n\trproc->sysfs_read_only = false;\n\tmutex_unlock(&pru->lock);\n\n\trproc_put(rproc);\n}\nEXPORT_SYMBOL_GPL(pru_rproc_put);\n\n \nint pru_rproc_set_ctable(struct rproc *rproc, enum pru_ctable_idx c, u32 addr)\n{\n\tstruct pru_rproc *pru = rproc->priv;\n\tunsigned int reg;\n\tu32 mask, set;\n\tu16 idx;\n\tu16 idx_mask;\n\n\tif (IS_ERR_OR_NULL(rproc))\n\t\treturn -EINVAL;\n\n\tif (!rproc->dev.parent || !is_pru_rproc(rproc->dev.parent))\n\t\treturn -ENODEV;\n\n\t \n\tidx_mask = (c >= PRU_C28) ? 0xFFFF : 0xFF;\n\n\t \n\tidx = (addr >> 8) & idx_mask;\n\n\t \n\treg = PRU_CTRL_CTBIR0 + 4 * (c >> 1);\n\tmask = idx_mask << (16 * (c & 1));\n\tset = idx << (16 * (c & 1));\n\n\tpru_control_set_reg(pru, reg, mask, set);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(pru_rproc_set_ctable);\n\nstatic inline u32 pru_debug_read_reg(struct pru_rproc *pru, unsigned int reg)\n{\n\treturn readl_relaxed(pru->mem_regions[PRU_IOMEM_DEBUG].va + reg);\n}\n\nstatic int regs_show(struct seq_file *s, void *data)\n{\n\tstruct rproc *rproc = s->private;\n\tstruct pru_rproc *pru = rproc->priv;\n\tint i, nregs = 32;\n\tu32 pru_sts;\n\tint pru_is_running;\n\n\tseq_puts(s, \"============== Control Registers ==============\\n\");\n\tseq_printf(s, \"CTRL      := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CTRL));\n\tpru_sts = pru_control_read_reg(pru, PRU_CTRL_STS);\n\tseq_printf(s, \"STS (PC)  := 0x%08x (0x%08x)\\n\", pru_sts, pru_sts << 2);\n\tseq_printf(s, \"WAKEUP_EN := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_WAKEUP_EN));\n\tseq_printf(s, \"CYCLE     := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CYCLE));\n\tseq_printf(s, \"STALL     := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_STALL));\n\tseq_printf(s, \"CTBIR0    := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CTBIR0));\n\tseq_printf(s, \"CTBIR1    := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CTBIR1));\n\tseq_printf(s, \"CTPPR0    := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CTPPR0));\n\tseq_printf(s, \"CTPPR1    := 0x%08x\\n\",\n\t\t   pru_control_read_reg(pru, PRU_CTRL_CTPPR1));\n\n\tseq_puts(s, \"=============== Debug Registers ===============\\n\");\n\tpru_is_running = pru_control_read_reg(pru, PRU_CTRL_CTRL) &\n\t\t\t\tCTRL_CTRL_RUNSTATE;\n\tif (pru_is_running) {\n\t\tseq_puts(s, \"PRU is executing, cannot print/access debug registers.\\n\");\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < nregs; i++) {\n\t\tseq_printf(s, \"GPREG%-2d := 0x%08x\\tCT_REG%-2d := 0x%08x\\n\",\n\t\t\t   i, pru_debug_read_reg(pru, PRU_DEBUG_GPREG(i)),\n\t\t\t   i, pru_debug_read_reg(pru, PRU_DEBUG_CT_REG(i)));\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(regs);\n\n \nstatic int pru_rproc_debug_ss_set(void *data, u64 val)\n{\n\tstruct rproc *rproc = data;\n\tstruct pru_rproc *pru = rproc->priv;\n\tu32 reg_val;\n\n\tval = val ? 1 : 0;\n\tif (!val && !pru->dbg_single_step)\n\t\treturn 0;\n\n\treg_val = pru_control_read_reg(pru, PRU_CTRL_CTRL);\n\n\tif (val && !pru->dbg_single_step)\n\t\tpru->dbg_continuous = reg_val;\n\n\tif (val)\n\t\treg_val |= CTRL_CTRL_SINGLE_STEP | CTRL_CTRL_EN;\n\telse\n\t\treg_val = pru->dbg_continuous;\n\n\tpru->dbg_single_step = val;\n\tpru_control_write_reg(pru, PRU_CTRL_CTRL, reg_val);\n\n\treturn 0;\n}\n\nstatic int pru_rproc_debug_ss_get(void *data, u64 *val)\n{\n\tstruct rproc *rproc = data;\n\tstruct pru_rproc *pru = rproc->priv;\n\n\t*val = pru->dbg_single_step;\n\n\treturn 0;\n}\nDEFINE_DEBUGFS_ATTRIBUTE(pru_rproc_debug_ss_fops, pru_rproc_debug_ss_get,\n\t\t\t pru_rproc_debug_ss_set, \"%llu\\n\");\n\n \nstatic void pru_rproc_create_debug_entries(struct rproc *rproc)\n{\n\tif (!rproc->dbg_dir)\n\t\treturn;\n\n\tdebugfs_create_file(\"regs\", 0400, rproc->dbg_dir,\n\t\t\t    rproc, &regs_fops);\n\tdebugfs_create_file(\"single_step\", 0600, rproc->dbg_dir,\n\t\t\t    rproc, &pru_rproc_debug_ss_fops);\n}\n\nstatic void pru_dispose_irq_mapping(struct pru_rproc *pru)\n{\n\tif (!pru->mapped_irq)\n\t\treturn;\n\n\twhile (pru->evt_count) {\n\t\tpru->evt_count--;\n\t\tif (pru->mapped_irq[pru->evt_count] > 0)\n\t\t\tirq_dispose_mapping(pru->mapped_irq[pru->evt_count]);\n\t}\n\n\tkfree(pru->mapped_irq);\n\tpru->mapped_irq = NULL;\n}\n\n \nstatic int pru_handle_intrmap(struct rproc *rproc)\n{\n\tstruct device *dev = rproc->dev.parent;\n\tstruct pru_rproc *pru = rproc->priv;\n\tstruct pru_irq_rsc *rsc = pru->pru_interrupt_map;\n\tstruct irq_fwspec fwspec;\n\tstruct device_node *parent, *irq_parent;\n\tint i, ret = 0;\n\n\t \n\tif (!rsc)\n\t\treturn 0;\n\n\t \n\tif (rsc->type != 0) {\n\t\tdev_err(dev, \"unsupported rsc type: %d\\n\", rsc->type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rsc->num_evts > MAX_PRU_SYS_EVENTS)\n\t\treturn -EINVAL;\n\n\tif (sizeof(*rsc) + rsc->num_evts * sizeof(struct pruss_int_map) !=\n\t    pru->pru_interrupt_map_sz)\n\t\treturn -EINVAL;\n\n\tpru->evt_count = rsc->num_evts;\n\tpru->mapped_irq = kcalloc(pru->evt_count, sizeof(unsigned int),\n\t\t\t\t  GFP_KERNEL);\n\tif (!pru->mapped_irq) {\n\t\tpru->evt_count = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tparent = of_get_parent(dev_of_node(pru->dev));\n\tif (!parent) {\n\t\tkfree(pru->mapped_irq);\n\t\tpru->mapped_irq = NULL;\n\t\tpru->evt_count = 0;\n\t\treturn -ENODEV;\n\t}\n\n\tirq_parent = of_get_child_by_name(parent, \"interrupt-controller\");\n\tof_node_put(parent);\n\tif (!irq_parent) {\n\t\tkfree(pru->mapped_irq);\n\t\tpru->mapped_irq = NULL;\n\t\tpru->evt_count = 0;\n\t\treturn -ENODEV;\n\t}\n\n\tfwspec.fwnode = of_node_to_fwnode(irq_parent);\n\tfwspec.param_count = 3;\n\tfor (i = 0; i < pru->evt_count; i++) {\n\t\tfwspec.param[0] = rsc->pru_intc_map[i].event;\n\t\tfwspec.param[1] = rsc->pru_intc_map[i].chnl;\n\t\tfwspec.param[2] = rsc->pru_intc_map[i].host;\n\n\t\tdev_dbg(dev, \"mapping%d: event %d, chnl %d, host %d\\n\",\n\t\t\ti, fwspec.param[0], fwspec.param[1], fwspec.param[2]);\n\n\t\tpru->mapped_irq[i] = irq_create_fwspec_mapping(&fwspec);\n\t\tif (!pru->mapped_irq[i]) {\n\t\t\tdev_err(dev, \"failed to get virq for fw mapping %d: event %d chnl %d host %d\\n\",\n\t\t\t\ti, fwspec.param[0], fwspec.param[1],\n\t\t\t\tfwspec.param[2]);\n\t\t\tret = -EINVAL;\n\t\t\tgoto map_fail;\n\t\t}\n\t}\n\tof_node_put(irq_parent);\n\n\treturn ret;\n\nmap_fail:\n\tpru_dispose_irq_mapping(pru);\n\tof_node_put(irq_parent);\n\n\treturn ret;\n}\n\nstatic int pru_rproc_start(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tstruct pru_rproc *pru = rproc->priv;\n\tconst char *names[PRU_TYPE_MAX] = { \"PRU\", \"RTU\", \"Tx_PRU\" };\n\tu32 val;\n\tint ret;\n\n\tdev_dbg(dev, \"starting %s%d: entry-point = 0x%llx\\n\",\n\t\tnames[pru->data->type], pru->id, (rproc->bootaddr >> 2));\n\n\tret = pru_handle_intrmap(rproc);\n\t \n\tpru->pru_interrupt_map = NULL;\n\tpru->pru_interrupt_map_sz = 0;\n\tif (ret)\n\t\treturn ret;\n\n\tval = CTRL_CTRL_EN | ((rproc->bootaddr >> 2) << 16);\n\tpru_control_write_reg(pru, PRU_CTRL_CTRL, val);\n\n\treturn 0;\n}\n\nstatic int pru_rproc_stop(struct rproc *rproc)\n{\n\tstruct device *dev = &rproc->dev;\n\tstruct pru_rproc *pru = rproc->priv;\n\tconst char *names[PRU_TYPE_MAX] = { \"PRU\", \"RTU\", \"Tx_PRU\" };\n\tu32 val;\n\n\tdev_dbg(dev, \"stopping %s%d\\n\", names[pru->data->type], pru->id);\n\n\tval = pru_control_read_reg(pru, PRU_CTRL_CTRL);\n\tval &= ~CTRL_CTRL_EN;\n\tpru_control_write_reg(pru, PRU_CTRL_CTRL, val);\n\n\t \n\tpru_dispose_irq_mapping(pru);\n\n\treturn 0;\n}\n\n \nstatic void *pru_d_da_to_va(struct pru_rproc *pru, u32 da, size_t len)\n{\n\tstruct pruss_mem_region dram0, dram1, shrd_ram;\n\tstruct pruss *pruss = pru->pruss;\n\tu32 offset;\n\tvoid *va = NULL;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\tdram0 = pruss->mem_regions[PRUSS_MEM_DRAM0];\n\tdram1 = pruss->mem_regions[PRUSS_MEM_DRAM1];\n\t \n\tif (pru->id == PRUSS_PRU1)\n\t\tswap(dram0, dram1);\n\tshrd_ram = pruss->mem_regions[PRUSS_MEM_SHRD_RAM2];\n\n\tif (da + len <= PRU_PDRAM_DA + dram0.size) {\n\t\toffset = da - PRU_PDRAM_DA;\n\t\tva = (__force void *)(dram0.va + offset);\n\t} else if (da >= PRU_SDRAM_DA &&\n\t\t   da + len <= PRU_SDRAM_DA + dram1.size) {\n\t\toffset = da - PRU_SDRAM_DA;\n\t\tva = (__force void *)(dram1.va + offset);\n\t} else if (da >= PRU_SHRDRAM_DA &&\n\t\t   da + len <= PRU_SHRDRAM_DA + shrd_ram.size) {\n\t\toffset = da - PRU_SHRDRAM_DA;\n\t\tva = (__force void *)(shrd_ram.va + offset);\n\t}\n\n\treturn va;\n}\n\n \nstatic void *pru_i_da_to_va(struct pru_rproc *pru, u32 da, size_t len)\n{\n\tu32 offset;\n\tvoid *va = NULL;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\t \n\tda &= 0xfffff;\n\n\tif (da + len <= PRU_IRAM_DA + pru->mem_regions[PRU_IOMEM_IRAM].size) {\n\t\toffset = da - PRU_IRAM_DA;\n\t\tva = (__force void *)(pru->mem_regions[PRU_IOMEM_IRAM].va +\n\t\t\t\t      offset);\n\t}\n\n\treturn va;\n}\n\n \nstatic void *pru_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct pru_rproc *pru = rproc->priv;\n\n\treturn pru_d_da_to_va(pru, da, len);\n}\n\n \nstatic void *pru_da_to_va(struct rproc *rproc, u64 da, size_t len, bool is_iram)\n{\n\tstruct pru_rproc *pru = rproc->priv;\n\tvoid *va;\n\n\tif (is_iram)\n\t\tva = pru_i_da_to_va(pru, da, len);\n\telse\n\t\tva = pru_d_da_to_va(pru, da, len);\n\n\treturn va;\n}\n\nstatic struct rproc_ops pru_rproc_ops = {\n\t.start\t\t= pru_rproc_start,\n\t.stop\t\t= pru_rproc_stop,\n\t.da_to_va\t= pru_rproc_da_to_va,\n};\n\n \nstatic int pru_rproc_memcpy(void *dest, const void *src, size_t count)\n{\n\tconst u32 *s = src;\n\tu32 *d = dest;\n\tsize_t size = count / 4;\n\tu32 *tmp_src = NULL;\n\n\t \n\tif ((long)dest % 4 || count % 4)\n\t\treturn -EINVAL;\n\n\t \n\tif ((long)src % 4) {\n\t\ttmp_src = kmemdup(src, count, GFP_KERNEL);\n\t\tif (!tmp_src)\n\t\t\treturn -ENOMEM;\n\t\ts = tmp_src;\n\t}\n\n\twhile (size--)\n\t\t*d++ = *s++;\n\n\tkfree(tmp_src);\n\n\treturn 0;\n}\n\nstatic int\npru_rproc_load_elf_segments(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct pru_rproc *pru = rproc->priv;\n\tstruct device *dev = &rproc->dev;\n\tstruct elf32_hdr *ehdr;\n\tstruct elf32_phdr *phdr;\n\tint i, ret = 0;\n\tconst u8 *elf_data = fw->data;\n\n\tehdr = (struct elf32_hdr *)elf_data;\n\tphdr = (struct elf32_phdr *)(elf_data + ehdr->e_phoff);\n\n\t \n\tfor (i = 0; i < ehdr->e_phnum; i++, phdr++) {\n\t\tu32 da = phdr->p_paddr;\n\t\tu32 memsz = phdr->p_memsz;\n\t\tu32 filesz = phdr->p_filesz;\n\t\tu32 offset = phdr->p_offset;\n\t\tbool is_iram;\n\t\tvoid *ptr;\n\n\t\tif (phdr->p_type != PT_LOAD || !filesz)\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"phdr: type %d da 0x%x memsz 0x%x filesz 0x%x\\n\",\n\t\t\tphdr->p_type, da, memsz, filesz);\n\n\t\tif (filesz > memsz) {\n\t\t\tdev_err(dev, \"bad phdr filesz 0x%x memsz 0x%x\\n\",\n\t\t\t\tfilesz, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offset + filesz > fw->size) {\n\t\t\tdev_err(dev, \"truncated fw: need 0x%x avail 0x%zx\\n\",\n\t\t\t\toffset + filesz, fw->size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tis_iram = phdr->p_flags & PF_X;\n\t\tptr = pru_da_to_va(rproc, da, memsz, is_iram);\n\t\tif (!ptr) {\n\t\t\tdev_err(dev, \"bad phdr da 0x%x mem 0x%x\\n\", da, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (pru->data->is_k3) {\n\t\t\tret = pru_rproc_memcpy(ptr, elf_data + phdr->p_offset,\n\t\t\t\t\t       filesz);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev, \"PRU memory copy failed for da 0x%x memsz 0x%x\\n\",\n\t\t\t\t\tda, memsz);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tmemcpy(ptr, elf_data + phdr->p_offset, filesz);\n\t\t}\n\n\t\t \n\t}\n\n\treturn ret;\n}\n\nstatic const void *\npru_rproc_find_interrupt_map(struct device *dev, const struct firmware *fw)\n{\n\tstruct elf32_shdr *shdr, *name_table_shdr;\n\tconst char *name_table;\n\tconst u8 *elf_data = fw->data;\n\tstruct elf32_hdr *ehdr = (struct elf32_hdr *)elf_data;\n\tu16 shnum = ehdr->e_shnum;\n\tu16 shstrndx = ehdr->e_shstrndx;\n\tint i;\n\n\t \n\tshdr = (struct elf32_shdr *)(elf_data + ehdr->e_shoff);\n\t \n\tname_table_shdr = shdr + shstrndx;\n\t \n\tname_table = elf_data + name_table_shdr->sh_offset;\n\n\tfor (i = 0; i < shnum; i++, shdr++) {\n\t\tu32 size = shdr->sh_size;\n\t\tu32 offset = shdr->sh_offset;\n\t\tu32 name = shdr->sh_name;\n\n\t\tif (strcmp(name_table + name, \".pru_irq_map\"))\n\t\t\tcontinue;\n\n\t\t \n\t\tif (offset + size > fw->size || offset + size < size) {\n\t\t\tdev_err(dev, \".pru_irq_map section truncated\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\t \n\t\tif (sizeof(struct pru_irq_rsc) > size) {\n\t\t\tdev_err(dev, \"header-less .pru_irq_map section\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\treturn shdr;\n\t}\n\n\tdev_dbg(dev, \"no .pru_irq_map section found for this fw\\n\");\n\n\treturn NULL;\n}\n\n \nstatic int pru_rproc_parse_fw(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = &rproc->dev;\n\tstruct pru_rproc *pru = rproc->priv;\n\tconst u8 *elf_data = fw->data;\n\tconst void *shdr;\n\tu8 class = fw_elf_get_class(fw);\n\tu64 sh_offset;\n\tint ret;\n\n\t \n\tret = rproc_elf_load_rsc_table(rproc, fw);\n\tif (ret == -EINVAL)\n\t\tdev_dbg(&rproc->dev, \"no resource table found for this fw\\n\");\n\telse if (ret)\n\t\treturn ret;\n\n\t \n\tshdr = pru_rproc_find_interrupt_map(dev, fw);\n\tif (IS_ERR(shdr))\n\t\treturn PTR_ERR(shdr);\n\n\tif (!shdr)\n\t\treturn 0;\n\n\t \n\tsh_offset = elf_shdr_get_sh_offset(class, shdr);\n\tpru->pru_interrupt_map = (struct pru_irq_rsc *)(elf_data + sh_offset);\n\tpru->pru_interrupt_map_sz = elf_shdr_get_sh_size(class, shdr);\n\n\treturn 0;\n}\n\n \nstatic int pru_rproc_set_id(struct pru_rproc *pru)\n{\n\tint ret = 0;\n\n\tswitch (pru->mem_regions[PRU_IOMEM_IRAM].pa & PRU_IRAM_ADDR_MASK) {\n\tcase TX_PRU0_IRAM_ADDR_MASK:\n\t\tfallthrough;\n\tcase RTU0_IRAM_ADDR_MASK:\n\t\tfallthrough;\n\tcase PRU0_IRAM_ADDR_MASK:\n\t\tpru->id = PRUSS_PRU0;\n\t\tbreak;\n\tcase TX_PRU1_IRAM_ADDR_MASK:\n\t\tfallthrough;\n\tcase RTU1_IRAM_ADDR_MASK:\n\t\tfallthrough;\n\tcase PRU1_IRAM_ADDR_MASK:\n\t\tpru->id = PRUSS_PRU1;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic int pru_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct platform_device *ppdev = to_platform_device(dev->parent);\n\tstruct pru_rproc *pru;\n\tconst char *fw_name;\n\tstruct rproc *rproc = NULL;\n\tstruct resource *res;\n\tint i, ret;\n\tconst struct pru_private_data *data;\n\tconst char *mem_names[PRU_IOMEM_MAX] = { \"iram\", \"control\", \"debug\" };\n\n\tdata = of_device_get_match_data(&pdev->dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tret = of_property_read_string(np, \"firmware-name\", &fw_name);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to retrieve firmware-name %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\trproc = devm_rproc_alloc(dev, pdev->name, &pru_rproc_ops, fw_name,\n\t\t\t\t sizeof(*pru));\n\tif (!rproc) {\n\t\tdev_err(dev, \"rproc_alloc failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\t \n\trproc->ops->load = pru_rproc_load_elf_segments;\n\n\t \n\trproc->ops->parse_fw = pru_rproc_parse_fw;\n\n\t \n\trproc->recovery_disabled = true;\n\n\t \n\trproc->auto_boot = false;\n\n\tpru = rproc->priv;\n\tpru->dev = dev;\n\tpru->data = data;\n\tpru->pruss = platform_get_drvdata(ppdev);\n\tpru->rproc = rproc;\n\tpru->fw_name = fw_name;\n\tpru->client_np = NULL;\n\tspin_lock_init(&pru->rmw_lock);\n\tmutex_init(&pru->lock);\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_names); i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   mem_names[i]);\n\t\tpru->mem_regions[i].va = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(pru->mem_regions[i].va)) {\n\t\t\tdev_err(dev, \"failed to parse and map memory resource %d %s\\n\",\n\t\t\t\ti, mem_names[i]);\n\t\t\tret = PTR_ERR(pru->mem_regions[i].va);\n\t\t\treturn ret;\n\t\t}\n\t\tpru->mem_regions[i].pa = res->start;\n\t\tpru->mem_regions[i].size = resource_size(res);\n\n\t\tdev_dbg(dev, \"memory %8s: pa %pa size 0x%zx va %pK\\n\",\n\t\t\tmem_names[i], &pru->mem_regions[i].pa,\n\t\t\tpru->mem_regions[i].size, pru->mem_regions[i].va);\n\t}\n\n\tret = pru_rproc_set_id(pru);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\tret = devm_rproc_add(dev, pru->rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpru_rproc_create_debug_entries(rproc);\n\n\tdev_dbg(dev, \"PRU rproc node %pOF probed successfully\\n\", np);\n\n\treturn 0;\n}\n\nstatic void pru_rproc_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\n\tdev_dbg(dev, \"%s: removing rproc %s\\n\", __func__, rproc->name);\n}\n\nstatic const struct pru_private_data pru_data = {\n\t.type = PRU_TYPE_PRU,\n};\n\nstatic const struct pru_private_data k3_pru_data = {\n\t.type = PRU_TYPE_PRU,\n\t.is_k3 = 1,\n};\n\nstatic const struct pru_private_data k3_rtu_data = {\n\t.type = PRU_TYPE_RTU,\n\t.is_k3 = 1,\n};\n\nstatic const struct pru_private_data k3_tx_pru_data = {\n\t.type = PRU_TYPE_TX_PRU,\n\t.is_k3 = 1,\n};\n\nstatic const struct of_device_id pru_rproc_match[] = {\n\t{ .compatible = \"ti,am3356-pru\",\t.data = &pru_data },\n\t{ .compatible = \"ti,am4376-pru\",\t.data = &pru_data },\n\t{ .compatible = \"ti,am5728-pru\",\t.data = &pru_data },\n\t{ .compatible = \"ti,am642-pru\",\t\t.data = &k3_pru_data },\n\t{ .compatible = \"ti,am642-rtu\",\t\t.data = &k3_rtu_data },\n\t{ .compatible = \"ti,am642-tx-pru\",\t.data = &k3_tx_pru_data },\n\t{ .compatible = \"ti,k2g-pru\",\t\t.data = &pru_data },\n\t{ .compatible = \"ti,am654-pru\",\t\t.data = &k3_pru_data },\n\t{ .compatible = \"ti,am654-rtu\",\t\t.data = &k3_rtu_data },\n\t{ .compatible = \"ti,am654-tx-pru\",\t.data = &k3_tx_pru_data },\n\t{ .compatible = \"ti,j721e-pru\",\t\t.data = &k3_pru_data },\n\t{ .compatible = \"ti,j721e-rtu\",\t\t.data = &k3_rtu_data },\n\t{ .compatible = \"ti,j721e-tx-pru\",\t.data = &k3_tx_pru_data },\n\t{ .compatible = \"ti,am625-pru\",\t\t.data = &k3_pru_data },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, pru_rproc_match);\n\nstatic struct platform_driver pru_rproc_driver = {\n\t.driver = {\n\t\t.name   = PRU_RPROC_DRVNAME,\n\t\t.of_match_table = pru_rproc_match,\n\t\t.suppress_bind_attrs = true,\n\t},\n\t.probe  = pru_rproc_probe,\n\t.remove_new = pru_rproc_remove,\n};\nmodule_platform_driver(pru_rproc_driver);\n\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_AUTHOR(\"Andrew F. Davis <afd@ti.com>\");\nMODULE_AUTHOR(\"Grzegorz Jaszczyk <grzegorz.jaszczyk@linaro.org>\");\nMODULE_AUTHOR(\"Puranjay Mohan <p-mohan@ti.com>\");\nMODULE_AUTHOR(\"Md Danish Anwar <danishanwar@ti.com>\");\nMODULE_DESCRIPTION(\"PRU-ICSS Remote Processor Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}