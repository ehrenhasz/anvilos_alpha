{
  "module_name": "qcom_q6v5_mss.c",
  "hash_id": "df9475bb3c742532c55f52460e360433d0f9775af687878c4aafb72b1f8bee5e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_q6v5_mss.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/devcoredump.h>\n#include <linux/dma-mapping.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/soc/qcom/mdt_loader.h>\n#include <linux/iopoll.h>\n#include <linux/slab.h>\n\n#include \"remoteproc_internal.h\"\n#include \"qcom_common.h\"\n#include \"qcom_pil_info.h\"\n#include \"qcom_q6v5.h\"\n\n#include <linux/firmware/qcom/qcom_scm.h>\n\n#define MPSS_CRASH_REASON_SMEM\t\t421\n\n#define MBA_LOG_SIZE\t\t\tSZ_4K\n\n#define MPSS_PAS_ID\t\t\t5\n\n \n#define RMB_PBL_SUCCESS\t\t\t0x1\n\n#define RMB_MBA_XPU_UNLOCKED\t\t0x1\n#define RMB_MBA_XPU_UNLOCKED_SCRIBBLED\t0x2\n#define RMB_MBA_META_DATA_AUTH_SUCCESS\t0x3\n#define RMB_MBA_AUTH_COMPLETE\t\t0x4\n\n \n#define RMB_MBA_IMAGE_REG\t\t0x00\n#define RMB_PBL_STATUS_REG\t\t0x04\n#define RMB_MBA_COMMAND_REG\t\t0x08\n#define RMB_MBA_STATUS_REG\t\t0x0C\n#define RMB_PMI_META_DATA_REG\t\t0x10\n#define RMB_PMI_CODE_START_REG\t\t0x14\n#define RMB_PMI_CODE_LENGTH_REG\t\t0x18\n#define RMB_MBA_MSS_STATUS\t\t0x40\n#define RMB_MBA_ALT_RESET\t\t0x44\n\n#define RMB_CMD_META_DATA_READY\t\t0x1\n#define RMB_CMD_LOAD_READY\t\t0x2\n\n \n#define QDSP6SS_RESET_REG\t\t0x014\n#define QDSP6SS_GFMUX_CTL_REG\t\t0x020\n#define QDSP6SS_PWR_CTL_REG\t\t0x030\n#define QDSP6SS_MEM_PWR_CTL\t\t0x0B0\n#define QDSP6V6SS_MEM_PWR_CTL\t\t0x034\n#define QDSP6SS_STRAP_ACC\t\t0x110\n#define QDSP6V62SS_BHS_STATUS\t\t0x0C4\n\n \n#define AXI_HALTREQ_REG\t\t\t0x0\n#define AXI_HALTACK_REG\t\t\t0x4\n#define AXI_IDLE_REG\t\t\t0x8\n#define AXI_GATING_VALID_OVERRIDE\tBIT(0)\n\n#define HALT_ACK_TIMEOUT_US\t\t100000\n\n \n#define QACCEPT_ACCEPT_REG\t\t0x0\n#define QACCEPT_ACTIVE_REG\t\t0x4\n#define QACCEPT_DENY_REG\t\t0x8\n#define QACCEPT_REQ_REG\t\t\t0xC\n\n#define QACCEPT_TIMEOUT_US\t\t50\n\n \n#define Q6SS_STOP_CORE\t\t\tBIT(0)\n#define Q6SS_CORE_ARES\t\t\tBIT(1)\n#define Q6SS_BUS_ARES_ENABLE\t\tBIT(2)\n\n \n#define Q6SS_CBCR_CLKEN\t\t\tBIT(0)\n#define Q6SS_CBCR_CLKOFF\t\tBIT(31)\n#define Q6SS_CBCR_TIMEOUT_US\t\t200\n\n \n#define Q6SS_CLK_ENABLE\t\t\tBIT(1)\n\n \n#define Q6SS_L2DATA_SLP_NRET_N_0\tBIT(0)\n#define Q6SS_L2DATA_SLP_NRET_N_1\tBIT(1)\n#define Q6SS_L2DATA_SLP_NRET_N_2\tBIT(2)\n#define Q6SS_L2TAG_SLP_NRET_N\t\tBIT(16)\n#define Q6SS_ETB_SLP_NRET_N\t\tBIT(17)\n#define Q6SS_L2DATA_STBY_N\t\tBIT(18)\n#define Q6SS_SLP_RET_N\t\t\tBIT(19)\n#define Q6SS_CLAMP_IO\t\t\tBIT(20)\n#define QDSS_BHS_ON\t\t\tBIT(21)\n#define QDSS_LDO_BYP\t\t\tBIT(22)\n\n \n#define QDSP6V55_MEM_BITS\t\tGENMASK(16, 8)\n\n \n#define QDSP6v56_LDO_BYP\t\tBIT(25)\n#define QDSP6v56_BHS_ON\t\tBIT(24)\n#define QDSP6v56_CLAMP_WL\t\tBIT(21)\n#define QDSP6v56_CLAMP_QMC_MEM\t\tBIT(22)\n#define QDSP6SS_XO_CBCR\t\t0x0038\n#define QDSP6SS_ACC_OVERRIDE_VAL\t\t0x20\n#define QDSP6v55_BHS_EN_REST_ACK\tBIT(0)\n\n \n#define QDSP6SS_CORE_CBCR\t\t0x20\n#define QDSP6SS_SLEEP                   0x3C\n#define QDSP6SS_BOOT_CORE_START         0x400\n#define QDSP6SS_BOOT_CMD                0x404\n#define BOOT_FSM_TIMEOUT                10000\n#define BHS_CHECK_MAX_LOOPS             200\n\nstruct reg_info {\n\tstruct regulator *reg;\n\tint uV;\n\tint uA;\n};\n\nstruct qcom_mss_reg_res {\n\tconst char *supply;\n\tint uV;\n\tint uA;\n};\n\nstruct rproc_hexagon_res {\n\tconst char *hexagon_mba_image;\n\tstruct qcom_mss_reg_res *proxy_supply;\n\tstruct qcom_mss_reg_res *fallback_proxy_supply;\n\tstruct qcom_mss_reg_res *active_supply;\n\tchar **proxy_clk_names;\n\tchar **reset_clk_names;\n\tchar **active_clk_names;\n\tchar **proxy_pd_names;\n\tint version;\n\tbool need_mem_protection;\n\tbool has_alt_reset;\n\tbool has_mba_logs;\n\tbool has_spare_reg;\n\tbool has_qaccept_regs;\n\tbool has_ext_cntl_regs;\n\tbool has_vq6;\n};\n\nstruct q6v5 {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\n\tvoid __iomem *reg_base;\n\tvoid __iomem *rmb_base;\n\n\tstruct regmap *halt_map;\n\tstruct regmap *conn_map;\n\n\tu32 halt_q6;\n\tu32 halt_modem;\n\tu32 halt_nc;\n\tu32 halt_vq6;\n\tu32 conn_box;\n\n\tu32 qaccept_mdm;\n\tu32 qaccept_cx;\n\tu32 qaccept_axi;\n\n\tu32 axim1_clk_off;\n\tu32 crypto_clk_off;\n\tu32 force_clk_on;\n\tu32 rscc_disable;\n\n\tstruct reset_control *mss_restart;\n\tstruct reset_control *pdc_reset;\n\n\tstruct qcom_q6v5 q6v5;\n\n\tstruct clk *active_clks[8];\n\tstruct clk *reset_clks[4];\n\tstruct clk *proxy_clks[4];\n\tstruct device *proxy_pds[3];\n\tint active_clk_count;\n\tint reset_clk_count;\n\tint proxy_clk_count;\n\tint proxy_pd_count;\n\n\tstruct reg_info active_regs[1];\n\tstruct reg_info proxy_regs[1];\n\tstruct reg_info fallback_proxy_regs[2];\n\tint active_reg_count;\n\tint proxy_reg_count;\n\tint fallback_proxy_reg_count;\n\n\tbool dump_mba_loaded;\n\tsize_t current_dump_size;\n\tsize_t total_dump_size;\n\n\tphys_addr_t mba_phys;\n\tsize_t mba_size;\n\tsize_t dp_size;\n\n\tphys_addr_t mdata_phys;\n\tsize_t mdata_size;\n\n\tphys_addr_t mpss_phys;\n\tphys_addr_t mpss_reloc;\n\tsize_t mpss_size;\n\n\tstruct qcom_rproc_glink glink_subdev;\n\tstruct qcom_rproc_subdev smd_subdev;\n\tstruct qcom_rproc_ssr ssr_subdev;\n\tstruct qcom_sysmon *sysmon;\n\tstruct platform_device *bam_dmux;\n\tbool need_mem_protection;\n\tbool has_alt_reset;\n\tbool has_mba_logs;\n\tbool has_spare_reg;\n\tbool has_qaccept_regs;\n\tbool has_ext_cntl_regs;\n\tbool has_vq6;\n\tu64 mpss_perm;\n\tu64 mba_perm;\n\tconst char *hexagon_mdt_image;\n\tint version;\n};\n\nenum {\n\tMSS_MSM8909,\n\tMSS_MSM8916,\n\tMSS_MSM8953,\n\tMSS_MSM8974,\n\tMSS_MSM8996,\n\tMSS_MSM8998,\n\tMSS_SC7180,\n\tMSS_SC7280,\n\tMSS_SDM660,\n\tMSS_SDM845,\n};\n\nstatic int q6v5_regulator_init(struct device *dev, struct reg_info *regs,\n\t\t\t       const struct qcom_mss_reg_res *reg_res)\n{\n\tint rc;\n\tint i;\n\n\tif (!reg_res)\n\t\treturn 0;\n\n\tfor (i = 0; reg_res[i].supply; i++) {\n\t\tregs[i].reg = devm_regulator_get(dev, reg_res[i].supply);\n\t\tif (IS_ERR(regs[i].reg)) {\n\t\t\trc = PTR_ERR(regs[i].reg);\n\t\t\tif (rc != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get %s\\n regulator\",\n\t\t\t\t\treg_res[i].supply);\n\t\t\treturn rc;\n\t\t}\n\n\t\tregs[i].uV = reg_res[i].uV;\n\t\tregs[i].uA = reg_res[i].uA;\n\t}\n\n\treturn i;\n}\n\nstatic int q6v5_regulator_enable(struct q6v5 *qproc,\n\t\t\t\t struct reg_info *regs, int count)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (regs[i].uV > 0) {\n\t\t\tret = regulator_set_voltage(regs[i].reg,\n\t\t\t\t\tregs[i].uV, INT_MAX);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(qproc->dev,\n\t\t\t\t\t\"Failed to request voltage for %d.\\n\",\n\t\t\t\t\t\ti);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (regs[i].uA > 0) {\n\t\t\tret = regulator_set_load(regs[i].reg,\n\t\t\t\t\t\t regs[i].uA);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(qproc->dev,\n\t\t\t\t\t\"Failed to set regulator mode\\n\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tret = regulator_enable(regs[i].reg);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"Regulator enable failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tfor (; i >= 0; i--) {\n\t\tif (regs[i].uV > 0)\n\t\t\tregulator_set_voltage(regs[i].reg, 0, INT_MAX);\n\n\t\tif (regs[i].uA > 0)\n\t\t\tregulator_set_load(regs[i].reg, 0);\n\n\t\tregulator_disable(regs[i].reg);\n\t}\n\n\treturn ret;\n}\n\nstatic void q6v5_regulator_disable(struct q6v5 *qproc,\n\t\t\t\t   struct reg_info *regs, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (regs[i].uV > 0)\n\t\t\tregulator_set_voltage(regs[i].reg, 0, INT_MAX);\n\n\t\tif (regs[i].uA > 0)\n\t\t\tregulator_set_load(regs[i].reg, 0);\n\n\t\tregulator_disable(regs[i].reg);\n\t}\n}\n\nstatic int q6v5_clk_enable(struct device *dev,\n\t\t\t   struct clk **clks, int count)\n{\n\tint rc;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = clk_prepare_enable(clks[i]);\n\t\tif (rc) {\n\t\t\tdev_err(dev, \"Clock enable failed\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\treturn 0;\nerr:\n\tfor (i--; i >= 0; i--)\n\t\tclk_disable_unprepare(clks[i]);\n\n\treturn rc;\n}\n\nstatic void q6v5_clk_disable(struct device *dev,\n\t\t\t     struct clk **clks, int count)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++)\n\t\tclk_disable_unprepare(clks[i]);\n}\n\nstatic int q6v5_pds_enable(struct q6v5 *qproc, struct device **pds,\n\t\t\t   size_t pd_count)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], INT_MAX);\n\t\tret = pm_runtime_get_sync(pds[i]);\n\t\tif (ret < 0) {\n\t\t\tpm_runtime_put_noidle(pds[i]);\n\t\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\t\tgoto unroll_pd_votes;\n\t\t}\n\t}\n\n\treturn 0;\n\nunroll_pd_votes:\n\tfor (i--; i >= 0; i--) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n\n\treturn ret;\n}\n\nstatic void q6v5_pds_disable(struct q6v5 *qproc, struct device **pds,\n\t\t\t     size_t pd_count)\n{\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++) {\n\t\tdev_pm_genpd_set_performance_state(pds[i], 0);\n\t\tpm_runtime_put(pds[i]);\n\t}\n}\n\nstatic int q6v5_xfer_mem_ownership(struct q6v5 *qproc, u64 *current_perm,\n\t\t\t\t   bool local, bool remote, phys_addr_t addr,\n\t\t\t\t   size_t size)\n{\n\tstruct qcom_scm_vmperm next[2];\n\tint perms = 0;\n\n\tif (!qproc->need_mem_protection)\n\t\treturn 0;\n\n\tif (local == !!(*current_perm & BIT(QCOM_SCM_VMID_HLOS)) &&\n\t    remote == !!(*current_perm & BIT(QCOM_SCM_VMID_MSS_MSA)))\n\t\treturn 0;\n\n\tif (local) {\n\t\tnext[perms].vmid = QCOM_SCM_VMID_HLOS;\n\t\tnext[perms].perm = QCOM_SCM_PERM_RWX;\n\t\tperms++;\n\t}\n\n\tif (remote) {\n\t\tnext[perms].vmid = QCOM_SCM_VMID_MSS_MSA;\n\t\tnext[perms].perm = QCOM_SCM_PERM_RW;\n\t\tperms++;\n\t}\n\n\treturn qcom_scm_assign_mem(addr, ALIGN(size, SZ_4K),\n\t\t\t\t   current_perm, next, perms);\n}\n\nstatic void q6v5_debug_policy_load(struct q6v5 *qproc, void *mba_region)\n{\n\tconst struct firmware *dp_fw;\n\n\tif (request_firmware_direct(&dp_fw, \"msadp\", qproc->dev))\n\t\treturn;\n\n\tif (SZ_1M + dp_fw->size <= qproc->mba_size) {\n\t\tmemcpy(mba_region + SZ_1M, dp_fw->data, dp_fw->size);\n\t\tqproc->dp_size = dp_fw->size;\n\t}\n\n\trelease_firmware(dp_fw);\n}\n\nstatic int q6v5_load(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct q6v5 *qproc = rproc->priv;\n\tvoid *mba_region;\n\n\t \n\tif (fw->size > qproc->mba_size || fw->size > SZ_1M) {\n\t\tdev_err(qproc->dev, \"MBA firmware load failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tmba_region = memremap(qproc->mba_phys, qproc->mba_size, MEMREMAP_WC);\n\tif (!mba_region) {\n\t\tdev_err(qproc->dev, \"unable to map memory region: %pa+%zx\\n\",\n\t\t\t&qproc->mba_phys, qproc->mba_size);\n\t\treturn -EBUSY;\n\t}\n\n\tmemcpy(mba_region, fw->data, fw->size);\n\tq6v5_debug_policy_load(qproc, mba_region);\n\tmemunmap(mba_region);\n\n\treturn 0;\n}\n\nstatic int q6v5_reset_assert(struct q6v5 *qproc)\n{\n\tint ret;\n\n\tif (qproc->has_alt_reset) {\n\t\treset_control_assert(qproc->pdc_reset);\n\t\tret = reset_control_reset(qproc->mss_restart);\n\t\treset_control_deassert(qproc->pdc_reset);\n\t} else if (qproc->has_spare_reg) {\n\t\t \n\t\treset_control_assert(qproc->pdc_reset);\n\t\tregmap_update_bits(qproc->conn_map, qproc->conn_box,\n\t\t\t\t   AXI_GATING_VALID_OVERRIDE, 1);\n\t\treset_control_assert(qproc->mss_restart);\n\t\treset_control_deassert(qproc->pdc_reset);\n\t\tregmap_update_bits(qproc->conn_map, qproc->conn_box,\n\t\t\t\t   AXI_GATING_VALID_OVERRIDE, 0);\n\t\tret = reset_control_deassert(qproc->mss_restart);\n\t} else if (qproc->has_ext_cntl_regs) {\n\t\tregmap_write(qproc->conn_map, qproc->rscc_disable, 0);\n\t\treset_control_assert(qproc->pdc_reset);\n\t\treset_control_assert(qproc->mss_restart);\n\t\treset_control_deassert(qproc->pdc_reset);\n\t\tret = reset_control_deassert(qproc->mss_restart);\n\t} else {\n\t\tret = reset_control_assert(qproc->mss_restart);\n\t}\n\n\treturn ret;\n}\n\nstatic int q6v5_reset_deassert(struct q6v5 *qproc)\n{\n\tint ret;\n\n\tif (qproc->has_alt_reset) {\n\t\treset_control_assert(qproc->pdc_reset);\n\t\twritel(1, qproc->rmb_base + RMB_MBA_ALT_RESET);\n\t\tret = reset_control_reset(qproc->mss_restart);\n\t\twritel(0, qproc->rmb_base + RMB_MBA_ALT_RESET);\n\t\treset_control_deassert(qproc->pdc_reset);\n\t} else if (qproc->has_spare_reg || qproc->has_ext_cntl_regs) {\n\t\tret = reset_control_reset(qproc->mss_restart);\n\t} else {\n\t\tret = reset_control_deassert(qproc->mss_restart);\n\t}\n\n\treturn ret;\n}\n\nstatic int q6v5_rmb_pbl_wait(struct q6v5 *qproc, int ms)\n{\n\tunsigned long timeout;\n\ts32 val;\n\n\ttimeout = jiffies + msecs_to_jiffies(ms);\n\tfor (;;) {\n\t\tval = readl(qproc->rmb_base + RMB_PBL_STATUS_REG);\n\t\tif (val)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tmsleep(1);\n\t}\n\n\treturn val;\n}\n\nstatic int q6v5_rmb_mba_wait(struct q6v5 *qproc, u32 status, int ms)\n{\n\n\tunsigned long timeout;\n\ts32 val;\n\n\ttimeout = jiffies + msecs_to_jiffies(ms);\n\tfor (;;) {\n\t\tval = readl(qproc->rmb_base + RMB_MBA_STATUS_REG);\n\t\tif (val < 0)\n\t\t\tbreak;\n\n\t\tif (!status && val)\n\t\t\tbreak;\n\t\telse if (status && val == status)\n\t\t\tbreak;\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\treturn -ETIMEDOUT;\n\n\t\tmsleep(1);\n\t}\n\n\treturn val;\n}\n\nstatic void q6v5_dump_mba_logs(struct q6v5 *qproc)\n{\n\tstruct rproc *rproc = qproc->rproc;\n\tvoid *data;\n\tvoid *mba_region;\n\n\tif (!qproc->has_mba_logs)\n\t\treturn;\n\n\tif (q6v5_xfer_mem_ownership(qproc, &qproc->mba_perm, true, false, qproc->mba_phys,\n\t\t\t\t    qproc->mba_size))\n\t\treturn;\n\n\tmba_region = memremap(qproc->mba_phys, qproc->mba_size, MEMREMAP_WC);\n\tif (!mba_region)\n\t\treturn;\n\n\tdata = vmalloc(MBA_LOG_SIZE);\n\tif (data) {\n\t\tmemcpy(data, mba_region, MBA_LOG_SIZE);\n\t\tdev_coredumpv(&rproc->dev, data, MBA_LOG_SIZE, GFP_KERNEL);\n\t}\n\tmemunmap(mba_region);\n}\n\nstatic int q6v5proc_reset(struct q6v5 *qproc)\n{\n\tu32 val;\n\tint ret;\n\tint i;\n\n\tif (qproc->version == MSS_SDM845) {\n\t\tval = readl(qproc->reg_base + QDSP6SS_SLEEP);\n\t\tval |= Q6SS_CBCR_CLKEN;\n\t\twritel(val, qproc->reg_base + QDSP6SS_SLEEP);\n\n\t\tret = readl_poll_timeout(qproc->reg_base + QDSP6SS_SLEEP,\n\t\t\t\t\t val, !(val & Q6SS_CBCR_CLKOFF), 1,\n\t\t\t\t\t Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"QDSP6SS Sleep clock timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\twritel(1, qproc->reg_base + QDSP6SS_BOOT_CORE_START);\n\t\t \n\t\twritel(1, qproc->reg_base + QDSP6SS_BOOT_CMD);\n\n\t\tret = readl_poll_timeout(qproc->rmb_base + RMB_MBA_MSS_STATUS,\n\t\t\t\tval, (val & BIT(0)) != 0, 10, BOOT_FSM_TIMEOUT);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"Boot FSM failed to complete.\\n\");\n\t\t\t \n\t\t\tq6v5_reset_deassert(qproc);\n\t\t\treturn ret;\n\t\t}\n\n\t\tgoto pbl_wait;\n\t} else if (qproc->version == MSS_SC7180 || qproc->version == MSS_SC7280) {\n\t\tval = readl(qproc->reg_base + QDSP6SS_SLEEP);\n\t\tval |= Q6SS_CBCR_CLKEN;\n\t\twritel(val, qproc->reg_base + QDSP6SS_SLEEP);\n\n\t\tret = readl_poll_timeout(qproc->reg_base + QDSP6SS_SLEEP,\n\t\t\t\t\t val, !(val & Q6SS_CBCR_CLKOFF), 1,\n\t\t\t\t\t Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"QDSP6SS Sleep clock timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_XO_CBCR);\n\t\tval |= Q6SS_CBCR_CLKEN;\n\t\twritel(val, qproc->reg_base + QDSP6SS_XO_CBCR);\n\n\t\tret = readl_poll_timeout(qproc->reg_base + QDSP6SS_XO_CBCR,\n\t\t\t\t\t val, !(val & Q6SS_CBCR_CLKOFF), 1,\n\t\t\t\t\t Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"QDSP6SS XO clock timed out\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_CORE_CBCR);\n\t\tval |= Q6SS_CBCR_CLKEN;\n\t\twritel(val, qproc->reg_base + QDSP6SS_CORE_CBCR);\n\n\t\t \n\t\twritel(1, qproc->reg_base + QDSP6SS_BOOT_CORE_START);\n\n\t\t \n\t\tusleep_range(10, 20);\n\n\t\t \n\t\twritel(1, qproc->reg_base + QDSP6SS_BOOT_CMD);\n\n\t\t \n\t\tret = readl_poll_timeout(qproc->rmb_base + RMB_MBA_MSS_STATUS,\n\t\t\t\t\t val, (val & BIT(0)) != 0, 10, BOOT_FSM_TIMEOUT);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"Boot FSM failed to complete.\\n\");\n\t\t\t \n\t\t\tq6v5_reset_deassert(qproc);\n\t\t\treturn ret;\n\t\t}\n\t\tgoto pbl_wait;\n\t} else if (qproc->version == MSS_MSM8909 ||\n\t\t   qproc->version == MSS_MSM8953 ||\n\t\t   qproc->version == MSS_MSM8996 ||\n\t\t   qproc->version == MSS_MSM8998 ||\n\t\t   qproc->version == MSS_SDM660) {\n\n\t\tif (qproc->version != MSS_MSM8909 &&\n\t\t    qproc->version != MSS_MSM8953)\n\t\t\t \n\t\t\twritel(QDSP6SS_ACC_OVERRIDE_VAL,\n\t\t\t       qproc->reg_base + QDSP6SS_STRAP_ACC);\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\n\t\tval |= Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE;\n\t\twritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_XO_CBCR);\n\t\tval |= Q6SS_CBCR_CLKEN;\n\t\twritel(val, qproc->reg_base + QDSP6SS_XO_CBCR);\n\n\t\t \n\t\tret = readl_poll_timeout(qproc->reg_base + QDSP6SS_XO_CBCR,\n\t\t\t\t\t val, !(val & Q6SS_CBCR_CLKOFF), 1,\n\t\t\t\t\t Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev,\n\t\t\t\t\"xo cbcr enabling timed out (rc:%d)\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= QDSP6v56_BHS_ON;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tudelay(1);\n\n\t\tif (qproc->version == MSS_SDM660) {\n\t\t\tret = readl_relaxed_poll_timeout(qproc->reg_base + QDSP6V62SS_BHS_STATUS,\n\t\t\t\t\t\t\t i, (i & QDSP6v55_BHS_EN_REST_ACK),\n\t\t\t\t\t\t\t 1, BHS_CHECK_MAX_LOOPS);\n\t\t\tif (ret == -ETIMEDOUT) {\n\t\t\t\tdev_err(qproc->dev, \"BHS_EN_REST_ACK not set!\\n\");\n\t\t\t\treturn -ETIMEDOUT;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tval |= QDSP6v56_LDO_BYP;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\n\t\tif (qproc->version != MSS_MSM8909) {\n\t\t\tint mem_pwr_ctl;\n\n\t\t\t \n\t\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\t\tval &= ~QDSP6v56_CLAMP_QMC_MEM;\n\t\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\n\t\t\t \n\t\t\tval |= Q6SS_L2DATA_STBY_N | Q6SS_SLP_RET_N;\n\t\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\n\t\t\t \n\t\t\tif (qproc->version == MSS_MSM8953 ||\n\t\t\t    qproc->version == MSS_MSM8996) {\n\t\t\t\tmem_pwr_ctl = QDSP6SS_MEM_PWR_CTL;\n\t\t\t\ti = 19;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tmem_pwr_ctl = QDSP6V6SS_MEM_PWR_CTL;\n\t\t\t\ti = 28;\n\t\t\t}\n\t\t\tval = readl(qproc->reg_base + mem_pwr_ctl);\n\t\t\tfor (; i >= 0; i--) {\n\t\t\t\tval |= BIT(i);\n\t\t\t\twritel(val, qproc->reg_base + mem_pwr_ctl);\n\t\t\t\t \n\t\t\t\tval |= readl(qproc->reg_base + mem_pwr_ctl);\n\t\t\t\tudelay(1);\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\t\tval |= Q6SS_SLP_RET_N | Q6SS_L2DATA_STBY_N |\n\t\t\t       Q6SS_ETB_SLP_NRET_N | QDSP6V55_MEM_BITS;\n\t\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\n\t\t\t \n\t\t\tfor (i = 0; i <= 7; i++) {\n\t\t\t\tval |= BIT(i);\n\t\t\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval &= ~QDSP6v56_CLAMP_WL;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t} else {\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\n\t\tval |= Q6SS_CORE_ARES | Q6SS_BUS_ARES_ENABLE | Q6SS_STOP_CORE;\n\t\twritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\n\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= QDSS_BHS_ON | QDSS_LDO_BYP;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tudelay(1);\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= Q6SS_SLP_RET_N | Q6SS_L2TAG_SLP_NRET_N |\n\t\t\tQ6SS_ETB_SLP_NRET_N | Q6SS_L2DATA_STBY_N;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= Q6SS_L2DATA_SLP_NRET_N_2;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= Q6SS_L2DATA_SLP_NRET_N_1;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= Q6SS_L2DATA_SLP_NRET_N_0;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t}\n\t \n\tval &= ~Q6SS_CLAMP_IO;\n\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\n\t \n\tval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\n\tval &= ~Q6SS_CORE_ARES;\n\twritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\n\n\t \n\tval = readl(qproc->reg_base + QDSP6SS_GFMUX_CTL_REG);\n\tval |= Q6SS_CLK_ENABLE;\n\twritel(val, qproc->reg_base + QDSP6SS_GFMUX_CTL_REG);\n\n\t \n\tval = readl(qproc->reg_base + QDSP6SS_RESET_REG);\n\tval &= ~Q6SS_STOP_CORE;\n\twritel(val, qproc->reg_base + QDSP6SS_RESET_REG);\n\npbl_wait:\n\t \n\tret = q6v5_rmb_pbl_wait(qproc, 1000);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(qproc->dev, \"PBL boot timed out\\n\");\n\t} else if (ret != RMB_PBL_SUCCESS) {\n\t\tdev_err(qproc->dev, \"PBL returned unexpected status %d\\n\", ret);\n\t\tret = -EINVAL;\n\t} else {\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int q6v5proc_enable_qchannel(struct q6v5 *qproc, struct regmap *map, u32 offset)\n{\n\tunsigned int val;\n\tint ret;\n\n\tif (!qproc->has_qaccept_regs)\n\t\treturn 0;\n\n\tif (qproc->has_ext_cntl_regs) {\n\t\tregmap_write(qproc->conn_map, qproc->rscc_disable, 0);\n\t\tregmap_write(qproc->conn_map, qproc->force_clk_on, 1);\n\n\t\tret = regmap_read_poll_timeout(qproc->halt_map, qproc->axim1_clk_off, val,\n\t\t\t\t\t       !val, 1, Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev, \"failed to enable axim1 clock\\n\");\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t}\n\n\tregmap_write(map, offset + QACCEPT_REQ_REG, 1);\n\n\t \n\tret = regmap_read_poll_timeout(map, offset + QACCEPT_ACCEPT_REG, val, val, 5,\n\t\t\t\t       QACCEPT_TIMEOUT_US);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"qchannel enable failed\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic void q6v5proc_disable_qchannel(struct q6v5 *qproc, struct regmap *map, u32 offset)\n{\n\tint ret;\n\tunsigned int val, retry;\n\tunsigned int nretry = 10;\n\tbool takedown_complete = false;\n\n\tif (!qproc->has_qaccept_regs)\n\t\treturn;\n\n\twhile (!takedown_complete && nretry) {\n\t\tnretry--;\n\n\t\t \n\t\tregmap_read_poll_timeout(map, offset + QACCEPT_ACTIVE_REG, val, !val, 5,\n\t\t\t\t\t QACCEPT_TIMEOUT_US);\n\n\t\t \n\t\tregmap_write(map, offset + QACCEPT_REQ_REG, 0);\n\n\t\t \n\t\tretry = 10;\n\t\twhile (retry) {\n\t\t\tusleep_range(5, 10);\n\t\t\tretry--;\n\t\t\tret = regmap_read(map, offset + QACCEPT_DENY_REG, &val);\n\t\t\tif (!ret && val) {\n\t\t\t\tregmap_write(map, offset + QACCEPT_REQ_REG, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret = regmap_read(map, offset + QACCEPT_ACCEPT_REG, &val);\n\t\t\tif (!ret && !val) {\n\t\t\t\ttakedown_complete = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!retry)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (!takedown_complete)\n\t\tdev_err(qproc->dev, \"qchannel takedown failed\\n\");\n}\n\nstatic void q6v5proc_halt_axi_port(struct q6v5 *qproc,\n\t\t\t\t   struct regmap *halt_map,\n\t\t\t\t   u32 offset)\n{\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\n\tif (!ret && val)\n\t\treturn;\n\n\t \n\tregmap_write(halt_map, offset + AXI_HALTREQ_REG, 1);\n\n\t \n\tregmap_read_poll_timeout(halt_map, offset + AXI_HALTACK_REG, val,\n\t\t\t\t val, 1000, HALT_ACK_TIMEOUT_US);\n\n\tret = regmap_read(halt_map, offset + AXI_IDLE_REG, &val);\n\tif (ret || !val)\n\t\tdev_err(qproc->dev, \"port failed halt\\n\");\n\n\t \n\tregmap_write(halt_map, offset + AXI_HALTREQ_REG, 0);\n}\n\nstatic int q6v5_mpss_init_image(struct q6v5 *qproc, const struct firmware *fw,\n\t\t\t\tconst char *fw_name)\n{\n\tunsigned long dma_attrs = DMA_ATTR_FORCE_CONTIGUOUS;\n\tdma_addr_t phys;\n\tvoid *metadata;\n\tu64 mdata_perm;\n\tint xferop_ret;\n\tsize_t size;\n\tvoid *ptr;\n\tint ret;\n\n\tmetadata = qcom_mdt_read_metadata(fw, &size, fw_name, qproc->dev);\n\tif (IS_ERR(metadata))\n\t\treturn PTR_ERR(metadata);\n\n\tif (qproc->mdata_phys) {\n\t\tif (size > qproc->mdata_size) {\n\t\t\tret = -EINVAL;\n\t\t\tdev_err(qproc->dev, \"metadata size outside memory range\\n\");\n\t\t\tgoto free_metadata;\n\t\t}\n\n\t\tphys = qproc->mdata_phys;\n\t\tptr = memremap(qproc->mdata_phys, size, MEMREMAP_WC);\n\t\tif (!ptr) {\n\t\t\tret = -EBUSY;\n\t\t\tdev_err(qproc->dev, \"unable to map memory region: %pa+%zx\\n\",\n\t\t\t\t&qproc->mdata_phys, size);\n\t\t\tgoto free_metadata;\n\t\t}\n\t} else {\n\t\tptr = dma_alloc_attrs(qproc->dev, size, &phys, GFP_KERNEL, dma_attrs);\n\t\tif (!ptr) {\n\t\t\tret = -ENOMEM;\n\t\t\tdev_err(qproc->dev, \"failed to allocate mdt buffer\\n\");\n\t\t\tgoto free_metadata;\n\t\t}\n\t}\n\n\tmemcpy(ptr, metadata, size);\n\n\tif (qproc->mdata_phys)\n\t\tmemunmap(ptr);\n\n\t \n\tmdata_perm = BIT(QCOM_SCM_VMID_HLOS);\n\tret = q6v5_xfer_mem_ownership(qproc, &mdata_perm, false, true,\n\t\t\t\t      phys, size);\n\tif (ret) {\n\t\tdev_err(qproc->dev,\n\t\t\t\"assigning Q6 access to metadata failed: %d\\n\", ret);\n\t\tret = -EAGAIN;\n\t\tgoto free_dma_attrs;\n\t}\n\n\twritel(phys, qproc->rmb_base + RMB_PMI_META_DATA_REG);\n\twritel(RMB_CMD_META_DATA_READY, qproc->rmb_base + RMB_MBA_COMMAND_REG);\n\n\tret = q6v5_rmb_mba_wait(qproc, RMB_MBA_META_DATA_AUTH_SUCCESS, 1000);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(qproc->dev, \"MPSS header authentication timed out\\n\");\n\telse if (ret < 0)\n\t\tdev_err(qproc->dev, \"MPSS header authentication failed: %d\\n\", ret);\n\n\t \n\txferop_ret = q6v5_xfer_mem_ownership(qproc, &mdata_perm, true, false,\n\t\t\t\t\t     phys, size);\n\tif (xferop_ret)\n\t\tdev_warn(qproc->dev,\n\t\t\t \"mdt buffer not reclaimed system may become unstable\\n\");\n\nfree_dma_attrs:\n\tif (!qproc->mdata_phys)\n\t\tdma_free_attrs(qproc->dev, size, ptr, phys, dma_attrs);\nfree_metadata:\n\tkfree(metadata);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic bool q6v5_phdr_valid(const struct elf32_phdr *phdr)\n{\n\tif (phdr->p_type != PT_LOAD)\n\t\treturn false;\n\n\tif ((phdr->p_flags & QCOM_MDT_TYPE_MASK) == QCOM_MDT_TYPE_HASH)\n\t\treturn false;\n\n\tif (!phdr->p_memsz)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic int q6v5_mba_load(struct q6v5 *qproc)\n{\n\tint ret;\n\tint xfermemop_ret;\n\tbool mba_load_err = false;\n\n\tret = qcom_q6v5_prepare(&qproc->q6v5);\n\tif (ret)\n\t\treturn ret;\n\n\tret = q6v5_pds_enable(qproc, qproc->proxy_pds, qproc->proxy_pd_count);\n\tif (ret < 0) {\n\t\tdev_err(qproc->dev, \"failed to enable proxy power domains\\n\");\n\t\tgoto disable_irqs;\n\t}\n\n\tret = q6v5_regulator_enable(qproc, qproc->fallback_proxy_regs,\n\t\t\t\t    qproc->fallback_proxy_reg_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable fallback proxy supplies\\n\");\n\t\tgoto disable_proxy_pds;\n\t}\n\n\tret = q6v5_regulator_enable(qproc, qproc->proxy_regs,\n\t\t\t\t    qproc->proxy_reg_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable proxy supplies\\n\");\n\t\tgoto disable_fallback_proxy_reg;\n\t}\n\n\tret = q6v5_clk_enable(qproc->dev, qproc->proxy_clks,\n\t\t\t      qproc->proxy_clk_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable proxy clocks\\n\");\n\t\tgoto disable_proxy_reg;\n\t}\n\n\tret = q6v5_regulator_enable(qproc, qproc->active_regs,\n\t\t\t\t    qproc->active_reg_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable supplies\\n\");\n\t\tgoto disable_proxy_clk;\n\t}\n\n\tret = q6v5_clk_enable(qproc->dev, qproc->reset_clks,\n\t\t\t      qproc->reset_clk_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable reset clocks\\n\");\n\t\tgoto disable_vdd;\n\t}\n\n\tret = q6v5_reset_deassert(qproc);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to deassert mss restart\\n\");\n\t\tgoto disable_reset_clks;\n\t}\n\n\tret = q6v5_clk_enable(qproc->dev, qproc->active_clks,\n\t\t\t      qproc->active_clk_count);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable clocks\\n\");\n\t\tgoto assert_reset;\n\t}\n\n\tret = q6v5proc_enable_qchannel(qproc, qproc->halt_map, qproc->qaccept_axi);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"failed to enable axi bridge\\n\");\n\t\tgoto disable_active_clks;\n\t}\n\n\t \n\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm, false, true,\n\t\t\t\t      qproc->mpss_phys, qproc->mpss_size);\n\tif (ret) {\n\t\tdev_err(qproc->dev, \"assigning Q6 access to mpss memory failed: %d\\n\", ret);\n\t\tgoto disable_active_clks;\n\t}\n\n\t \n\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mba_perm, false, true,\n\t\t\t\t      qproc->mba_phys, qproc->mba_size);\n\tif (ret) {\n\t\tdev_err(qproc->dev,\n\t\t\t\"assigning Q6 access to mba memory failed: %d\\n\", ret);\n\t\tgoto disable_active_clks;\n\t}\n\n\twritel(qproc->mba_phys, qproc->rmb_base + RMB_MBA_IMAGE_REG);\n\tif (qproc->dp_size) {\n\t\twritel(qproc->mba_phys + SZ_1M, qproc->rmb_base + RMB_PMI_CODE_START_REG);\n\t\twritel(qproc->dp_size, qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\n\t}\n\n\tret = q6v5proc_reset(qproc);\n\tif (ret)\n\t\tgoto reclaim_mba;\n\n\tif (qproc->has_mba_logs)\n\t\tqcom_pil_info_store(\"mba\", qproc->mba_phys, MBA_LOG_SIZE);\n\n\tret = q6v5_rmb_mba_wait(qproc, 0, 5000);\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(qproc->dev, \"MBA boot timed out\\n\");\n\t\tgoto halt_axi_ports;\n\t} else if (ret != RMB_MBA_XPU_UNLOCKED &&\n\t\t   ret != RMB_MBA_XPU_UNLOCKED_SCRIBBLED) {\n\t\tdev_err(qproc->dev, \"MBA returned unexpected status %d\\n\", ret);\n\t\tret = -EINVAL;\n\t\tgoto halt_axi_ports;\n\t}\n\n\tqproc->dump_mba_loaded = true;\n\treturn 0;\n\nhalt_axi_ports:\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_q6);\n\tif (qproc->has_vq6)\n\t\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_vq6);\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_modem);\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_nc);\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_mdm);\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_cx);\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_axi);\n\tmba_load_err = true;\nreclaim_mba:\n\txfermemop_ret = q6v5_xfer_mem_ownership(qproc, &qproc->mba_perm, true,\n\t\t\t\t\t\tfalse, qproc->mba_phys,\n\t\t\t\t\t\tqproc->mba_size);\n\tif (xfermemop_ret) {\n\t\tdev_err(qproc->dev,\n\t\t\t\"Failed to reclaim mba buffer, system may become unstable\\n\");\n\t} else if (mba_load_err) {\n\t\tq6v5_dump_mba_logs(qproc);\n\t}\n\ndisable_active_clks:\n\tq6v5_clk_disable(qproc->dev, qproc->active_clks,\n\t\t\t qproc->active_clk_count);\nassert_reset:\n\tq6v5_reset_assert(qproc);\ndisable_reset_clks:\n\tq6v5_clk_disable(qproc->dev, qproc->reset_clks,\n\t\t\t qproc->reset_clk_count);\ndisable_vdd:\n\tq6v5_regulator_disable(qproc, qproc->active_regs,\n\t\t\t       qproc->active_reg_count);\ndisable_proxy_clk:\n\tq6v5_clk_disable(qproc->dev, qproc->proxy_clks,\n\t\t\t qproc->proxy_clk_count);\ndisable_proxy_reg:\n\tq6v5_regulator_disable(qproc, qproc->proxy_regs,\n\t\t\t       qproc->proxy_reg_count);\ndisable_fallback_proxy_reg:\n\tq6v5_regulator_disable(qproc, qproc->fallback_proxy_regs,\n\t\t\t       qproc->fallback_proxy_reg_count);\ndisable_proxy_pds:\n\tq6v5_pds_disable(qproc, qproc->proxy_pds, qproc->proxy_pd_count);\ndisable_irqs:\n\tqcom_q6v5_unprepare(&qproc->q6v5);\n\n\treturn ret;\n}\n\nstatic void q6v5_mba_reclaim(struct q6v5 *qproc)\n{\n\tint ret;\n\tu32 val;\n\n\tqproc->dump_mba_loaded = false;\n\tqproc->dp_size = 0;\n\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_q6);\n\tif (qproc->has_vq6)\n\t\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_vq6);\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_modem);\n\tq6v5proc_halt_axi_port(qproc, qproc->halt_map, qproc->halt_nc);\n\tif (qproc->version == MSS_MSM8996) {\n\t\t \n\t\tval = readl(qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t\tval |= Q6SS_CLAMP_IO | QDSP6v56_CLAMP_WL |\n\t\t\tQDSP6v56_CLAMP_QMC_MEM;\n\t\twritel(val, qproc->reg_base + QDSP6SS_PWR_CTL_REG);\n\t}\n\n\tif (qproc->has_ext_cntl_regs) {\n\t\tregmap_write(qproc->conn_map, qproc->rscc_disable, 1);\n\n\t\tret = regmap_read_poll_timeout(qproc->halt_map, qproc->axim1_clk_off, val,\n\t\t\t\t\t       !val, 1, Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tdev_err(qproc->dev, \"failed to enable axim1 clock\\n\");\n\n\t\tret = regmap_read_poll_timeout(qproc->halt_map, qproc->crypto_clk_off, val,\n\t\t\t\t\t       !val, 1, Q6SS_CBCR_TIMEOUT_US);\n\t\tif (ret)\n\t\t\tdev_err(qproc->dev, \"failed to enable crypto clock\\n\");\n\t}\n\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_mdm);\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_cx);\n\tq6v5proc_disable_qchannel(qproc, qproc->halt_map, qproc->qaccept_axi);\n\n\tq6v5_reset_assert(qproc);\n\n\tq6v5_clk_disable(qproc->dev, qproc->reset_clks,\n\t\t\t qproc->reset_clk_count);\n\tq6v5_clk_disable(qproc->dev, qproc->active_clks,\n\t\t\t qproc->active_clk_count);\n\tq6v5_regulator_disable(qproc, qproc->active_regs,\n\t\t\t       qproc->active_reg_count);\n\n\t \n\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mba_perm, true, false,\n\t\t\t\t      qproc->mba_phys,\n\t\t\t\t      qproc->mba_size);\n\tWARN_ON(ret);\n\n\tret = qcom_q6v5_unprepare(&qproc->q6v5);\n\tif (ret) {\n\t\tq6v5_pds_disable(qproc, qproc->proxy_pds,\n\t\t\t\t qproc->proxy_pd_count);\n\t\tq6v5_clk_disable(qproc->dev, qproc->proxy_clks,\n\t\t\t\t qproc->proxy_clk_count);\n\t\tq6v5_regulator_disable(qproc, qproc->fallback_proxy_regs,\n\t\t\t\t       qproc->fallback_proxy_reg_count);\n\t\tq6v5_regulator_disable(qproc, qproc->proxy_regs,\n\t\t\t\t       qproc->proxy_reg_count);\n\t}\n}\n\nstatic int q6v5_reload_mba(struct rproc *rproc)\n{\n\tstruct q6v5 *qproc = rproc->priv;\n\tconst struct firmware *fw;\n\tint ret;\n\n\tret = request_firmware(&fw, rproc->firmware, qproc->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tq6v5_load(rproc, fw);\n\tret = q6v5_mba_load(qproc);\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int q6v5_mpss_load(struct q6v5 *qproc)\n{\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct firmware *seg_fw;\n\tconst struct firmware *fw;\n\tstruct elf32_hdr *ehdr;\n\tphys_addr_t mpss_reloc;\n\tphys_addr_t boot_addr;\n\tphys_addr_t min_addr = PHYS_ADDR_MAX;\n\tphys_addr_t max_addr = 0;\n\tu32 code_length;\n\tbool relocate = false;\n\tchar *fw_name;\n\tsize_t fw_name_len;\n\tssize_t offset;\n\tsize_t size = 0;\n\tvoid *ptr;\n\tint ret;\n\tint i;\n\n\tfw_name_len = strlen(qproc->hexagon_mdt_image);\n\tif (fw_name_len <= 4)\n\t\treturn -EINVAL;\n\n\tfw_name = kstrdup(qproc->hexagon_mdt_image, GFP_KERNEL);\n\tif (!fw_name)\n\t\treturn -ENOMEM;\n\n\tret = request_firmware(&fw, fw_name, qproc->dev);\n\tif (ret < 0) {\n\t\tdev_err(qproc->dev, \"unable to load %s\\n\", fw_name);\n\t\tgoto out;\n\t}\n\n\t \n\twritel(0, qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\n\n\tret = q6v5_mpss_init_image(qproc, fw, qproc->hexagon_mdt_image);\n\tif (ret)\n\t\tgoto release_firmware;\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!q6v5_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\tif (phdr->p_flags & QCOM_MDT_RELOCATABLE)\n\t\t\trelocate = true;\n\n\t\tif (phdr->p_paddr < min_addr)\n\t\t\tmin_addr = phdr->p_paddr;\n\n\t\tif (phdr->p_paddr + phdr->p_memsz > max_addr)\n\t\t\tmax_addr = ALIGN(phdr->p_paddr + phdr->p_memsz, SZ_4K);\n\t}\n\n\tif (qproc->version == MSS_MSM8953) {\n\t\tret = qcom_scm_pas_mem_setup(MPSS_PAS_ID, qproc->mpss_phys, qproc->mpss_size);\n\t\tif (ret) {\n\t\t\tdev_err(qproc->dev,\n\t\t\t\t\"setting up mpss memory failed: %d\\n\", ret);\n\t\t\tgoto release_firmware;\n\t\t}\n\t}\n\n\t \n\tq6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm, true, false,\n\t\t\t\tqproc->mpss_phys, qproc->mpss_size);\n\n\t \n\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm, true, true,\n\t\t\t\t      qproc->mpss_phys, qproc->mpss_size);\n\tif (ret) {\n\t\tdev_err(qproc->dev,\n\t\t\t\"assigning Q6 access to mpss memory failed: %d\\n\", ret);\n\t\tret = -EAGAIN;\n\t\tgoto release_firmware;\n\t}\n\n\tmpss_reloc = relocate ? min_addr : qproc->mpss_phys;\n\tqproc->mpss_reloc = mpss_reloc;\n\t \n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!q6v5_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\toffset = phdr->p_paddr - mpss_reloc;\n\t\tif (offset < 0 || offset + phdr->p_memsz > qproc->mpss_size) {\n\t\t\tdev_err(qproc->dev, \"segment outside memory range\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto release_firmware;\n\t\t}\n\n\t\tif (phdr->p_filesz > phdr->p_memsz) {\n\t\t\tdev_err(qproc->dev,\n\t\t\t\t\"refusing to load segment %d with p_filesz > p_memsz\\n\",\n\t\t\t\ti);\n\t\t\tret = -EINVAL;\n\t\t\tgoto release_firmware;\n\t\t}\n\n\t\tptr = memremap(qproc->mpss_phys + offset, phdr->p_memsz, MEMREMAP_WC);\n\t\tif (!ptr) {\n\t\t\tdev_err(qproc->dev,\n\t\t\t\t\"unable to map memory region: %pa+%zx-%x\\n\",\n\t\t\t\t&qproc->mpss_phys, offset, phdr->p_memsz);\n\t\t\tgoto release_firmware;\n\t\t}\n\n\t\tif (phdr->p_filesz && phdr->p_offset < fw->size) {\n\t\t\t \n\t\t\tif (phdr->p_offset + phdr->p_filesz > fw->size) {\n\t\t\t\tdev_err(qproc->dev,\n\t\t\t\t\t\"failed to load segment %d from truncated file %s\\n\",\n\t\t\t\t\ti, fw_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tmemunmap(ptr);\n\t\t\t\tgoto release_firmware;\n\t\t\t}\n\n\t\t\tmemcpy(ptr, fw->data + phdr->p_offset, phdr->p_filesz);\n\t\t} else if (phdr->p_filesz) {\n\t\t\t \n\t\t\tsprintf(fw_name + fw_name_len - 3, \"b%02d\", i);\n\t\t\tret = request_firmware_into_buf(&seg_fw, fw_name, qproc->dev,\n\t\t\t\t\t\t\tptr, phdr->p_filesz);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(qproc->dev, \"failed to load %s\\n\", fw_name);\n\t\t\t\tmemunmap(ptr);\n\t\t\t\tgoto release_firmware;\n\t\t\t}\n\n\t\t\tif (seg_fw->size != phdr->p_filesz) {\n\t\t\t\tdev_err(qproc->dev,\n\t\t\t\t\t\"failed to load segment %d from truncated file %s\\n\",\n\t\t\t\t\ti, fw_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\trelease_firmware(seg_fw);\n\t\t\t\tmemunmap(ptr);\n\t\t\t\tgoto release_firmware;\n\t\t\t}\n\n\t\t\trelease_firmware(seg_fw);\n\t\t}\n\n\t\tif (phdr->p_memsz > phdr->p_filesz) {\n\t\t\tmemset(ptr + phdr->p_filesz, 0,\n\t\t\t       phdr->p_memsz - phdr->p_filesz);\n\t\t}\n\t\tmemunmap(ptr);\n\t\tsize += phdr->p_memsz;\n\n\t\tcode_length = readl(qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\n\t\tif (!code_length) {\n\t\t\tboot_addr = relocate ? qproc->mpss_phys : min_addr;\n\t\t\twritel(boot_addr, qproc->rmb_base + RMB_PMI_CODE_START_REG);\n\t\t\twritel(RMB_CMD_LOAD_READY, qproc->rmb_base + RMB_MBA_COMMAND_REG);\n\t\t}\n\t\twritel(size, qproc->rmb_base + RMB_PMI_CODE_LENGTH_REG);\n\n\t\tret = readl(qproc->rmb_base + RMB_MBA_STATUS_REG);\n\t\tif (ret < 0) {\n\t\t\tdev_err(qproc->dev, \"MPSS authentication failed: %d\\n\",\n\t\t\t\tret);\n\t\t\tgoto release_firmware;\n\t\t}\n\t}\n\n\t \n\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm, false, true,\n\t\t\t\t      qproc->mpss_phys, qproc->mpss_size);\n\tif (ret) {\n\t\tdev_err(qproc->dev,\n\t\t\t\"assigning Q6 access to mpss memory failed: %d\\n\", ret);\n\t\tret = -EAGAIN;\n\t\tgoto release_firmware;\n\t}\n\n\tret = q6v5_rmb_mba_wait(qproc, RMB_MBA_AUTH_COMPLETE, 10000);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(qproc->dev, \"MPSS authentication timed out\\n\");\n\telse if (ret < 0)\n\t\tdev_err(qproc->dev, \"MPSS authentication failed: %d\\n\", ret);\n\n\tqcom_pil_info_store(\"modem\", qproc->mpss_phys, qproc->mpss_size);\n\nrelease_firmware:\n\trelease_firmware(fw);\nout:\n\tkfree(fw_name);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic void qcom_q6v5_dump_segment(struct rproc *rproc,\n\t\t\t\t   struct rproc_dump_segment *segment,\n\t\t\t\t   void *dest, size_t cp_offset, size_t size)\n{\n\tint ret = 0;\n\tstruct q6v5 *qproc = rproc->priv;\n\tint offset = segment->da - qproc->mpss_reloc;\n\tvoid *ptr = NULL;\n\n\t \n\tif (!qproc->dump_mba_loaded) {\n\t\tret = q6v5_reload_mba(rproc);\n\t\tif (!ret) {\n\t\t\t \n\t\t\tret = q6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm,\n\t\t\t\t\t\t      true, false,\n\t\t\t\t\t\t      qproc->mpss_phys,\n\t\t\t\t\t\t      qproc->mpss_size);\n\t\t}\n\t}\n\n\tif (!ret)\n\t\tptr = memremap(qproc->mpss_phys + offset + cp_offset, size, MEMREMAP_WC);\n\n\tif (ptr) {\n\t\tmemcpy(dest, ptr, size);\n\t\tmemunmap(ptr);\n\t} else {\n\t\tmemset(dest, 0xff, size);\n\t}\n\n\tqproc->current_dump_size += size;\n\n\t \n\tif (qproc->current_dump_size == qproc->total_dump_size) {\n\t\tif (qproc->dump_mba_loaded) {\n\t\t\t \n\t\t\tq6v5_xfer_mem_ownership(qproc, &qproc->mpss_perm,\n\t\t\t\t\t\tfalse, true,\n\t\t\t\t\t\tqproc->mpss_phys,\n\t\t\t\t\t\tqproc->mpss_size);\n\t\t\tq6v5_mba_reclaim(qproc);\n\t\t}\n\t}\n}\n\nstatic int q6v5_start(struct rproc *rproc)\n{\n\tstruct q6v5 *qproc = rproc->priv;\n\tint xfermemop_ret;\n\tint ret;\n\n\tret = q6v5_mba_load(qproc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(qproc->dev, \"MBA booted with%s debug policy, loading mpss\\n\",\n\t\t qproc->dp_size ? \"\" : \"out\");\n\n\tret = q6v5_mpss_load(qproc);\n\tif (ret)\n\t\tgoto reclaim_mpss;\n\n\tret = qcom_q6v5_wait_for_start(&qproc->q6v5, msecs_to_jiffies(5000));\n\tif (ret == -ETIMEDOUT) {\n\t\tdev_err(qproc->dev, \"start timed out\\n\");\n\t\tgoto reclaim_mpss;\n\t}\n\n\txfermemop_ret = q6v5_xfer_mem_ownership(qproc, &qproc->mba_perm, true,\n\t\t\t\t\t\tfalse, qproc->mba_phys,\n\t\t\t\t\t\tqproc->mba_size);\n\tif (xfermemop_ret)\n\t\tdev_err(qproc->dev,\n\t\t\t\"Failed to reclaim mba buffer system may become unstable\\n\");\n\n\t \n\tqproc->current_dump_size = 0;\n\n\treturn 0;\n\nreclaim_mpss:\n\tq6v5_mba_reclaim(qproc);\n\tq6v5_dump_mba_logs(qproc);\n\n\treturn ret;\n}\n\nstatic int q6v5_stop(struct rproc *rproc)\n{\n\tstruct q6v5 *qproc = rproc->priv;\n\tint ret;\n\n\tret = qcom_q6v5_request_stop(&qproc->q6v5, qproc->sysmon);\n\tif (ret == -ETIMEDOUT)\n\t\tdev_err(qproc->dev, \"timed out on wait\\n\");\n\n\tq6v5_mba_reclaim(qproc);\n\n\treturn 0;\n}\n\nstatic int qcom_q6v5_register_dump_segments(struct rproc *rproc,\n\t\t\t\t\t    const struct firmware *mba_fw)\n{\n\tconst struct firmware *fw;\n\tconst struct elf32_phdr *phdrs;\n\tconst struct elf32_phdr *phdr;\n\tconst struct elf32_hdr *ehdr;\n\tstruct q6v5 *qproc = rproc->priv;\n\tunsigned long i;\n\tint ret;\n\n\tret = request_firmware(&fw, qproc->hexagon_mdt_image, qproc->dev);\n\tif (ret < 0) {\n\t\tdev_err(qproc->dev, \"unable to load %s\\n\",\n\t\t\tqproc->hexagon_mdt_image);\n\t\treturn ret;\n\t}\n\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\tphdrs = (struct elf32_phdr *)(ehdr + 1);\n\tqproc->total_dump_size = 0;\n\n\tfor (i = 0; i < ehdr->e_phnum; i++) {\n\t\tphdr = &phdrs[i];\n\n\t\tif (!q6v5_phdr_valid(phdr))\n\t\t\tcontinue;\n\n\t\tret = rproc_coredump_add_custom_segment(rproc, phdr->p_paddr,\n\t\t\t\t\t\t\tphdr->p_memsz,\n\t\t\t\t\t\t\tqcom_q6v5_dump_segment,\n\t\t\t\t\t\t\tNULL);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tqproc->total_dump_size += phdr->p_memsz;\n\t}\n\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic unsigned long q6v5_panic(struct rproc *rproc)\n{\n\tstruct q6v5 *qproc = rproc->priv;\n\n\treturn qcom_q6v5_panic(&qproc->q6v5);\n}\n\nstatic const struct rproc_ops q6v5_ops = {\n\t.start = q6v5_start,\n\t.stop = q6v5_stop,\n\t.parse_fw = qcom_q6v5_register_dump_segments,\n\t.load = q6v5_load,\n\t.panic = q6v5_panic,\n};\n\nstatic void qcom_msa_handover(struct qcom_q6v5 *q6v5)\n{\n\tstruct q6v5 *qproc = container_of(q6v5, struct q6v5, q6v5);\n\n\tq6v5_clk_disable(qproc->dev, qproc->proxy_clks,\n\t\t\t qproc->proxy_clk_count);\n\tq6v5_regulator_disable(qproc, qproc->proxy_regs,\n\t\t\t       qproc->proxy_reg_count);\n\tq6v5_regulator_disable(qproc, qproc->fallback_proxy_regs,\n\t\t\t       qproc->fallback_proxy_reg_count);\n\tq6v5_pds_disable(qproc, qproc->proxy_pds, qproc->proxy_pd_count);\n}\n\nstatic int q6v5_init_mem(struct q6v5 *qproc, struct platform_device *pdev)\n{\n\tstruct of_phandle_args args;\n\tint halt_cell_cnt = 3;\n\tint ret;\n\n\tqproc->reg_base = devm_platform_ioremap_resource_byname(pdev, \"qdsp6\");\n\tif (IS_ERR(qproc->reg_base))\n\t\treturn PTR_ERR(qproc->reg_base);\n\n\tqproc->rmb_base = devm_platform_ioremap_resource_byname(pdev, \"rmb\");\n\tif (IS_ERR(qproc->rmb_base))\n\t\treturn PTR_ERR(qproc->rmb_base);\n\n\tif (qproc->has_vq6)\n\t\thalt_cell_cnt++;\n\n\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t       \"qcom,halt-regs\", halt_cell_cnt, 0, &args);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to parse qcom,halt-regs\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqproc->halt_map = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tif (IS_ERR(qproc->halt_map))\n\t\treturn PTR_ERR(qproc->halt_map);\n\n\tqproc->halt_q6 = args.args[0];\n\tqproc->halt_modem = args.args[1];\n\tqproc->halt_nc = args.args[2];\n\n\tif (qproc->has_vq6)\n\t\tqproc->halt_vq6 = args.args[3];\n\n\tif (qproc->has_qaccept_regs) {\n\t\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t\t       \"qcom,qaccept-regs\",\n\t\t\t\t\t\t       3, 0, &args);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse qaccept-regs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tqproc->qaccept_mdm = args.args[0];\n\t\tqproc->qaccept_cx = args.args[1];\n\t\tqproc->qaccept_axi = args.args[2];\n\t}\n\n\tif (qproc->has_ext_cntl_regs) {\n\t\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t\t       \"qcom,ext-regs\",\n\t\t\t\t\t\t       2, 0, &args);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse ext-regs index 0\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tqproc->conn_map = syscon_node_to_regmap(args.np);\n\t\tof_node_put(args.np);\n\t\tif (IS_ERR(qproc->conn_map))\n\t\t\treturn PTR_ERR(qproc->conn_map);\n\n\t\tqproc->force_clk_on = args.args[0];\n\t\tqproc->rscc_disable = args.args[1];\n\n\t\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t\t       \"qcom,ext-regs\",\n\t\t\t\t\t\t       2, 1, &args);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse ext-regs index 1\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tqproc->axim1_clk_off = args.args[0];\n\t\tqproc->crypto_clk_off = args.args[1];\n\t}\n\n\tif (qproc->has_spare_reg) {\n\t\tret = of_parse_phandle_with_fixed_args(pdev->dev.of_node,\n\t\t\t\t\t\t       \"qcom,spare-regs\",\n\t\t\t\t\t\t       1, 0, &args);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to parse spare-regs\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tqproc->conn_map = syscon_node_to_regmap(args.np);\n\t\tof_node_put(args.np);\n\t\tif (IS_ERR(qproc->conn_map))\n\t\t\treturn PTR_ERR(qproc->conn_map);\n\n\t\tqproc->conn_box = args.args[0];\n\t}\n\n\treturn 0;\n}\n\nstatic int q6v5_init_clocks(struct device *dev, struct clk **clks,\n\t\tchar **clk_names)\n{\n\tint i;\n\n\tif (!clk_names)\n\t\treturn 0;\n\n\tfor (i = 0; clk_names[i]; i++) {\n\t\tclks[i] = devm_clk_get(dev, clk_names[i]);\n\t\tif (IS_ERR(clks[i])) {\n\t\t\tint rc = PTR_ERR(clks[i]);\n\n\t\t\tif (rc != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Failed to get %s clock\\n\",\n\t\t\t\t\tclk_names[i]);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic int q6v5_pds_attach(struct device *dev, struct device **devs,\n\t\t\t   char **pd_names)\n{\n\tsize_t num_pds = 0;\n\tint ret;\n\tint i;\n\n\tif (!pd_names)\n\t\treturn 0;\n\n\twhile (pd_names[num_pds])\n\t\tnum_pds++;\n\n\tfor (i = 0; i < num_pds; i++) {\n\t\tdevs[i] = dev_pm_domain_attach_by_name(dev, pd_names[i]);\n\t\tif (IS_ERR_OR_NULL(devs[i])) {\n\t\t\tret = PTR_ERR(devs[i]) ? : -ENODATA;\n\t\t\tgoto unroll_attach;\n\t\t}\n\t}\n\n\treturn num_pds;\n\nunroll_attach:\n\tfor (i--; i >= 0; i--)\n\t\tdev_pm_domain_detach(devs[i], false);\n\n\treturn ret;\n}\n\nstatic void q6v5_pds_detach(struct q6v5 *qproc, struct device **pds,\n\t\t\t    size_t pd_count)\n{\n\tint i;\n\n\tfor (i = 0; i < pd_count; i++)\n\t\tdev_pm_domain_detach(pds[i], false);\n}\n\nstatic int q6v5_init_reset(struct q6v5 *qproc)\n{\n\tqproc->mss_restart = devm_reset_control_get_exclusive(qproc->dev,\n\t\t\t\t\t\t\t      \"mss_restart\");\n\tif (IS_ERR(qproc->mss_restart)) {\n\t\tdev_err(qproc->dev, \"failed to acquire mss restart\\n\");\n\t\treturn PTR_ERR(qproc->mss_restart);\n\t}\n\n\tif (qproc->has_alt_reset || qproc->has_spare_reg || qproc->has_ext_cntl_regs) {\n\t\tqproc->pdc_reset = devm_reset_control_get_exclusive(qproc->dev,\n\t\t\t\t\t\t\t\t    \"pdc_reset\");\n\t\tif (IS_ERR(qproc->pdc_reset)) {\n\t\t\tdev_err(qproc->dev, \"failed to acquire pdc reset\\n\");\n\t\t\treturn PTR_ERR(qproc->pdc_reset);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int q6v5_alloc_memory_region(struct q6v5 *qproc)\n{\n\tstruct device_node *child;\n\tstruct reserved_mem *rmem;\n\tstruct device_node *node;\n\n\t \n\tchild = of_get_child_by_name(qproc->dev->of_node, \"mba\");\n\tif (!child) {\n\t\tnode = of_parse_phandle(qproc->dev->of_node,\n\t\t\t\t\t\"memory-region\", 0);\n\t} else {\n\t\tnode = of_parse_phandle(child, \"memory-region\", 0);\n\t\tof_node_put(child);\n\t}\n\n\tif (!node) {\n\t\tdev_err(qproc->dev, \"no mba memory-region specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(qproc->dev, \"unable to resolve mba region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqproc->mba_phys = rmem->base;\n\tqproc->mba_size = rmem->size;\n\n\tif (!child) {\n\t\tnode = of_parse_phandle(qproc->dev->of_node,\n\t\t\t\t\t\"memory-region\", 1);\n\t} else {\n\t\tchild = of_get_child_by_name(qproc->dev->of_node, \"mpss\");\n\t\tnode = of_parse_phandle(child, \"memory-region\", 0);\n\t\tof_node_put(child);\n\t}\n\n\tif (!node) {\n\t\tdev_err(qproc->dev, \"no mpss memory-region specified\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trmem = of_reserved_mem_lookup(node);\n\tof_node_put(node);\n\tif (!rmem) {\n\t\tdev_err(qproc->dev, \"unable to resolve mpss region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqproc->mpss_phys = qproc->mpss_reloc = rmem->base;\n\tqproc->mpss_size = rmem->size;\n\n\tif (!child) {\n\t\tnode = of_parse_phandle(qproc->dev->of_node, \"memory-region\", 2);\n\t} else {\n\t\tchild = of_get_child_by_name(qproc->dev->of_node, \"metadata\");\n\t\tnode = of_parse_phandle(child, \"memory-region\", 0);\n\t\tof_node_put(child);\n\t}\n\n\tif (!node)\n\t\treturn 0;\n\n\trmem = of_reserved_mem_lookup(node);\n\tif (!rmem) {\n\t\tdev_err(qproc->dev, \"unable to resolve metadata region\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqproc->mdata_phys = rmem->base;\n\tqproc->mdata_size = rmem->size;\n\n\treturn 0;\n}\n\nstatic int q6v5_probe(struct platform_device *pdev)\n{\n\tconst struct rproc_hexagon_res *desc;\n\tstruct device_node *node;\n\tstruct q6v5 *qproc;\n\tstruct rproc *rproc;\n\tconst char *mba_image;\n\tint ret;\n\n\tdesc = of_device_get_match_data(&pdev->dev);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\tif (desc->need_mem_protection && !qcom_scm_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tmba_image = desc->hexagon_mba_image;\n\tret = of_property_read_string_index(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t\t    0, &mba_image);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(&pdev->dev, \"unable to read mba firmware-name\\n\");\n\t\treturn ret;\n\t}\n\n\trproc = rproc_alloc(&pdev->dev, pdev->name, &q6v5_ops,\n\t\t\t    mba_image, sizeof(*qproc));\n\tif (!rproc) {\n\t\tdev_err(&pdev->dev, \"failed to allocate rproc\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trproc->auto_boot = false;\n\trproc_coredump_set_elf_info(rproc, ELFCLASS32, EM_NONE);\n\n\tqproc = rproc->priv;\n\tqproc->dev = &pdev->dev;\n\tqproc->rproc = rproc;\n\tqproc->hexagon_mdt_image = \"modem.mdt\";\n\tret = of_property_read_string_index(pdev->dev.of_node, \"firmware-name\",\n\t\t\t\t\t    1, &qproc->hexagon_mdt_image);\n\tif (ret < 0 && ret != -EINVAL) {\n\t\tdev_err(&pdev->dev, \"unable to read mpss firmware-name\\n\");\n\t\tgoto free_rproc;\n\t}\n\n\tplatform_set_drvdata(pdev, qproc);\n\n\tqproc->has_qaccept_regs = desc->has_qaccept_regs;\n\tqproc->has_ext_cntl_regs = desc->has_ext_cntl_regs;\n\tqproc->has_vq6 = desc->has_vq6;\n\tqproc->has_spare_reg = desc->has_spare_reg;\n\tret = q6v5_init_mem(qproc, pdev);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = q6v5_alloc_memory_region(qproc);\n\tif (ret)\n\t\tgoto free_rproc;\n\n\tret = q6v5_init_clocks(&pdev->dev, qproc->proxy_clks,\n\t\t\t       desc->proxy_clk_names);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get proxy clocks.\\n\");\n\t\tgoto free_rproc;\n\t}\n\tqproc->proxy_clk_count = ret;\n\n\tret = q6v5_init_clocks(&pdev->dev, qproc->reset_clks,\n\t\t\t       desc->reset_clk_names);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get reset clocks.\\n\");\n\t\tgoto free_rproc;\n\t}\n\tqproc->reset_clk_count = ret;\n\n\tret = q6v5_init_clocks(&pdev->dev, qproc->active_clks,\n\t\t\t       desc->active_clk_names);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get active clocks.\\n\");\n\t\tgoto free_rproc;\n\t}\n\tqproc->active_clk_count = ret;\n\n\tret = q6v5_regulator_init(&pdev->dev, qproc->proxy_regs,\n\t\t\t\t  desc->proxy_supply);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get proxy regulators.\\n\");\n\t\tgoto free_rproc;\n\t}\n\tqproc->proxy_reg_count = ret;\n\n\tret = q6v5_regulator_init(&pdev->dev,  qproc->active_regs,\n\t\t\t\t  desc->active_supply);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get active regulators.\\n\");\n\t\tgoto free_rproc;\n\t}\n\tqproc->active_reg_count = ret;\n\n\tret = q6v5_pds_attach(&pdev->dev, qproc->proxy_pds,\n\t\t\t      desc->proxy_pd_names);\n\t \n\tif (ret == -ENODATA && desc->fallback_proxy_supply) {\n\t\tret = q6v5_regulator_init(&pdev->dev,\n\t\t\t\t\t  qproc->fallback_proxy_regs,\n\t\t\t\t\t  desc->fallback_proxy_supply);\n\t\tif (ret < 0) {\n\t\t\tdev_err(&pdev->dev, \"Failed to get fallback proxy regulators.\\n\");\n\t\t\tgoto free_rproc;\n\t\t}\n\t\tqproc->fallback_proxy_reg_count = ret;\n\t} else if (ret < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to init power domains\\n\");\n\t\tgoto free_rproc;\n\t} else {\n\t\tqproc->proxy_pd_count = ret;\n\t}\n\n\tqproc->has_alt_reset = desc->has_alt_reset;\n\tret = q6v5_init_reset(qproc);\n\tif (ret)\n\t\tgoto detach_proxy_pds;\n\n\tqproc->version = desc->version;\n\tqproc->need_mem_protection = desc->need_mem_protection;\n\tqproc->has_mba_logs = desc->has_mba_logs;\n\n\tret = qcom_q6v5_init(&qproc->q6v5, pdev, rproc, MPSS_CRASH_REASON_SMEM, \"modem\",\n\t\t\t     qcom_msa_handover);\n\tif (ret)\n\t\tgoto detach_proxy_pds;\n\n\tqproc->mpss_perm = BIT(QCOM_SCM_VMID_HLOS);\n\tqproc->mba_perm = BIT(QCOM_SCM_VMID_HLOS);\n\tqcom_add_glink_subdev(rproc, &qproc->glink_subdev, \"mpss\");\n\tqcom_add_smd_subdev(rproc, &qproc->smd_subdev);\n\tqcom_add_ssr_subdev(rproc, &qproc->ssr_subdev, \"mpss\");\n\tqproc->sysmon = qcom_add_sysmon_subdev(rproc, \"modem\", 0x12);\n\tif (IS_ERR(qproc->sysmon)) {\n\t\tret = PTR_ERR(qproc->sysmon);\n\t\tgoto remove_subdevs;\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto remove_sysmon_subdev;\n\n\tnode = of_get_compatible_child(pdev->dev.of_node, \"qcom,bam-dmux\");\n\tqproc->bam_dmux = of_platform_device_create(node, NULL, &pdev->dev);\n\tof_node_put(node);\n\n\treturn 0;\n\nremove_sysmon_subdev:\n\tqcom_remove_sysmon_subdev(qproc->sysmon);\nremove_subdevs:\n\tqcom_remove_ssr_subdev(rproc, &qproc->ssr_subdev);\n\tqcom_remove_smd_subdev(rproc, &qproc->smd_subdev);\n\tqcom_remove_glink_subdev(rproc, &qproc->glink_subdev);\ndetach_proxy_pds:\n\tq6v5_pds_detach(qproc, qproc->proxy_pds, qproc->proxy_pd_count);\nfree_rproc:\n\trproc_free(rproc);\n\n\treturn ret;\n}\n\nstatic void q6v5_remove(struct platform_device *pdev)\n{\n\tstruct q6v5 *qproc = platform_get_drvdata(pdev);\n\tstruct rproc *rproc = qproc->rproc;\n\n\tif (qproc->bam_dmux)\n\t\tof_platform_device_destroy(&qproc->bam_dmux->dev, NULL);\n\trproc_del(rproc);\n\n\tqcom_q6v5_deinit(&qproc->q6v5);\n\tqcom_remove_sysmon_subdev(qproc->sysmon);\n\tqcom_remove_ssr_subdev(rproc, &qproc->ssr_subdev);\n\tqcom_remove_smd_subdev(rproc, &qproc->smd_subdev);\n\tqcom_remove_glink_subdev(rproc, &qproc->glink_subdev);\n\n\tq6v5_pds_detach(qproc, qproc->proxy_pds, qproc->proxy_pd_count);\n\n\trproc_free(rproc);\n}\n\nstatic const struct rproc_hexagon_res sc7180_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\tNULL\n\t},\n\t.reset_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"bus\",\n\t\t\"snoc_axi\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"mnoc_axi\",\n\t\t\"nav\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = false,\n\t.has_mba_logs = true,\n\t.has_spare_reg = true,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_SC7180,\n};\n\nstatic const struct rproc_hexagon_res sc7280_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\t\"pka\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"offline\",\n\t\t\"snoc_axi\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\"cx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = false,\n\t.has_mba_logs = true,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = true,\n\t.has_ext_cntl_regs = true,\n\t.has_vq6 = true,\n\t.version = MSS_SC7280,\n};\n\nstatic const struct rproc_hexagon_res sdm660_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_clk_names = (char*[]){\n\t\t\t\"xo\",\n\t\t\t\"qdss\",\n\t\t\t\"mem\",\n\t\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\t\"iface\",\n\t\t\t\"bus\",\n\t\t\t\"gpll0_mss\",\n\t\t\t\"mnoc_axi\",\n\t\t\t\"snoc_axi\",\n\t\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\t\"cx\",\n\t\t\t\"mx\",\n\t\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_SDM660,\n};\n\nstatic const struct rproc_hexagon_res sdm845_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_clk_names = (char*[]){\n\t\t\t\"xo\",\n\t\t\t\"prng\",\n\t\t\tNULL\n\t},\n\t.reset_clk_names = (char*[]){\n\t\t\t\"iface\",\n\t\t\t\"snoc_axi\",\n\t\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\t\"bus\",\n\t\t\t\"mem\",\n\t\t\t\"gpll0_mss\",\n\t\t\t\"mnoc_axi\",\n\t\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\t\"cx\",\n\t\t\t\"mx\",\n\t\t\t\"mss\",\n\t\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = true,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_SDM845,\n};\n\nstatic const struct rproc_hexagon_res msm8998_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_clk_names = (char*[]){\n\t\t\t\"xo\",\n\t\t\t\"qdss\",\n\t\t\t\"mem\",\n\t\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\t\"iface\",\n\t\t\t\"bus\",\n\t\t\t\"gpll0_mss\",\n\t\t\t\"mnoc_axi\",\n\t\t\t\"snoc_axi\",\n\t\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\t\"cx\",\n\t\t\t\"mx\",\n\t\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8998,\n};\n\nstatic const struct rproc_hexagon_res msm8996_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"pll\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.proxy_clk_names = (char*[]){\n\t\t\t\"xo\",\n\t\t\t\"pnoc\",\n\t\t\t\"qdss\",\n\t\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\t\"iface\",\n\t\t\t\"bus\",\n\t\t\t\"mem\",\n\t\t\t\"gpll0_mss\",\n\t\t\t\"snoc_axi\",\n\t\t\t\"mnoc_axi\",\n\t\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\t\"mx\",\n\t\t\t\"cx\",\n\t\t\tNULL\n\t},\n\t.need_mem_protection = true,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8996,\n};\n\nstatic const struct rproc_hexagon_res msm8909_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"pll\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"bus\",\n\t\t\"mem\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\"mx\",\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.need_mem_protection = false,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8909,\n};\n\nstatic const struct rproc_hexagon_res msm8916_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"pll\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.fallback_proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"mx\",\n\t\t\t.uV = 1050000,\n\t\t},\n\t\t{\n\t\t\t.supply = \"cx\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"bus\",\n\t\t\"mem\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\"mx\",\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.need_mem_protection = false,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8916,\n};\n\nstatic const struct rproc_hexagon_res msm8953_mss = {\n\t.hexagon_mba_image = \"mba.mbn\",\n\t.proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"pll\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"bus\",\n\t\t\"mem\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]) {\n\t\t\"cx\",\n\t\t\"mx\",\n\t\t\"mss\",\n\t\tNULL\n\t},\n\t.need_mem_protection = false,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8953,\n};\n\nstatic const struct rproc_hexagon_res msm8974_mss = {\n\t.hexagon_mba_image = \"mba.b00\",\n\t.proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"pll\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.fallback_proxy_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"mx\",\n\t\t\t.uV = 1050000,\n\t\t},\n\t\t{\n\t\t\t.supply = \"cx\",\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.active_supply = (struct qcom_mss_reg_res[]) {\n\t\t{\n\t\t\t.supply = \"mss\",\n\t\t\t.uV = 1050000,\n\t\t\t.uA = 100000,\n\t\t},\n\t\t{}\n\t},\n\t.proxy_clk_names = (char*[]){\n\t\t\"xo\",\n\t\tNULL\n\t},\n\t.active_clk_names = (char*[]){\n\t\t\"iface\",\n\t\t\"bus\",\n\t\t\"mem\",\n\t\tNULL\n\t},\n\t.proxy_pd_names = (char*[]){\n\t\t\"mx\",\n\t\t\"cx\",\n\t\tNULL\n\t},\n\t.need_mem_protection = false,\n\t.has_alt_reset = false,\n\t.has_mba_logs = false,\n\t.has_spare_reg = false,\n\t.has_qaccept_regs = false,\n\t.has_ext_cntl_regs = false,\n\t.has_vq6 = false,\n\t.version = MSS_MSM8974,\n};\n\nstatic const struct of_device_id q6v5_of_match[] = {\n\t{ .compatible = \"qcom,q6v5-pil\", .data = &msm8916_mss},\n\t{ .compatible = \"qcom,msm8909-mss-pil\", .data = &msm8909_mss},\n\t{ .compatible = \"qcom,msm8916-mss-pil\", .data = &msm8916_mss},\n\t{ .compatible = \"qcom,msm8953-mss-pil\", .data = &msm8953_mss},\n\t{ .compatible = \"qcom,msm8974-mss-pil\", .data = &msm8974_mss},\n\t{ .compatible = \"qcom,msm8996-mss-pil\", .data = &msm8996_mss},\n\t{ .compatible = \"qcom,msm8998-mss-pil\", .data = &msm8998_mss},\n\t{ .compatible = \"qcom,sc7180-mss-pil\", .data = &sc7180_mss},\n\t{ .compatible = \"qcom,sc7280-mss-pil\", .data = &sc7280_mss},\n\t{ .compatible = \"qcom,sdm660-mss-pil\", .data = &sdm660_mss},\n\t{ .compatible = \"qcom,sdm845-mss-pil\", .data = &sdm845_mss},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, q6v5_of_match);\n\nstatic struct platform_driver q6v5_driver = {\n\t.probe = q6v5_probe,\n\t.remove_new = q6v5_remove,\n\t.driver = {\n\t\t.name = \"qcom-q6v5-mss\",\n\t\t.of_match_table = q6v5_of_match,\n\t},\n};\nmodule_platform_driver(q6v5_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm Self-authenticating modem remoteproc driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}