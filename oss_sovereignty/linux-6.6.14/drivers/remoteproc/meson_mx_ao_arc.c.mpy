{
  "module_name": "meson_mx_ao_arc.c",
  "hash_id": "918f5e67d7350c81e4809ad265de128ff4486cef857cf911b028c7c567b92977",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/meson_mx_ao_arc.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/bitops.h>\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/sizes.h>\n\n#include \"remoteproc_internal.h\"\n\n#define AO_REMAP_REG0\t\t\t\t\t\t0x0\n#define AO_REMAP_REG0_REMAP_AHB_SRAM_BITS_17_14_FOR_ARM_CPU\tGENMASK(3, 0)\n\n#define AO_REMAP_REG1\t\t\t\t\t\t0x4\n#define AO_REMAP_REG1_MOVE_AHB_SRAM_TO_0X0_INSTEAD_OF_DDR\tBIT(4)\n#define AO_REMAP_REG1_REMAP_AHB_SRAM_BITS_17_14_FOR_MEDIA_CPU\tGENMASK(3, 0)\n\n#define AO_CPU_CNTL\t\t\t\t\t\t0x0\n#define AO_CPU_CNTL_AHB_SRAM_BITS_31_20\t\t\t\tGENMASK(28, 16)\n#define AO_CPU_CNTL_HALT\t\t\t\t\tBIT(9)\n#define AO_CPU_CNTL_UNKNONWN\t\t\t\t\tBIT(8)\n#define AO_CPU_CNTL_RUN\t\t\t\t\t\tBIT(0)\n\n#define AO_CPU_STAT\t\t\t\t\t\t0x4\n\n#define AO_SECURE_REG0\t\t\t\t\t\t0x0\n#define AO_SECURE_REG0_AHB_SRAM_BITS_19_12\t\t\tGENMASK(15, 8)\n\n \n#define MESON_AO_RPROC_SRAM_USABLE_BITS\t\t\t\t0xfff3c000ULL\n\n#define MESON_AO_RPROC_MEMORY_OFFSET\t\t\t\t0x10000000\n\nstruct meson_mx_ao_arc_rproc_priv {\n\tvoid __iomem\t\t*remap_base;\n\tvoid __iomem\t\t*cpu_base;\n\tunsigned long\t\tsram_va;\n\tphys_addr_t\t\tsram_pa;\n\tsize_t\t\t\tsram_size;\n\tstruct gen_pool\t\t*sram_pool;\n\tstruct reset_control\t*arc_reset;\n\tstruct clk\t\t*arc_pclk;\n\tstruct regmap\t\t*secbus2_regmap;\n};\n\nstatic int meson_mx_ao_arc_rproc_start(struct rproc *rproc)\n{\n\tstruct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;\n\tphys_addr_t translated_sram_addr;\n\tu32 tmp;\n\tint ret;\n\n\tret = clk_prepare_enable(priv->arc_pclk);\n\tif (ret)\n\t\treturn ret;\n\n\ttmp = FIELD_PREP(AO_REMAP_REG0_REMAP_AHB_SRAM_BITS_17_14_FOR_ARM_CPU,\n\t\t\t priv->sram_pa >> 14);\n\twritel(tmp, priv->remap_base + AO_REMAP_REG0);\n\n\t \n\twritel(0x0, priv->remap_base + AO_REMAP_REG1);\n\n\tregmap_update_bits(priv->secbus2_regmap, AO_SECURE_REG0,\n\t\t\t   AO_SECURE_REG0_AHB_SRAM_BITS_19_12,\n\t\t\t   FIELD_PREP(AO_SECURE_REG0_AHB_SRAM_BITS_19_12,\n\t\t\t\t      priv->sram_pa >> 12));\n\n\tret = reset_control_reset(priv->arc_reset);\n\tif (ret) {\n\t\tclk_disable_unprepare(priv->arc_pclk);\n\t\treturn ret;\n\t}\n\n\tusleep_range(10, 100);\n\n\t \n\ttranslated_sram_addr = priv->sram_pa - MESON_AO_RPROC_MEMORY_OFFSET;\n\n\ttmp = FIELD_PREP(AO_CPU_CNTL_AHB_SRAM_BITS_31_20,\n\t\t\t translated_sram_addr >> 20);\n\ttmp |= AO_CPU_CNTL_UNKNONWN | AO_CPU_CNTL_RUN;\n\twritel(tmp, priv->cpu_base + AO_CPU_CNTL);\n\n\tusleep_range(20, 200);\n\n\treturn 0;\n}\n\nstatic int meson_mx_ao_arc_rproc_stop(struct rproc *rproc)\n{\n\tstruct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;\n\n\twritel(AO_CPU_CNTL_HALT, priv->cpu_base + AO_CPU_CNTL);\n\n\tclk_disable_unprepare(priv->arc_pclk);\n\n\treturn 0;\n}\n\nstatic void *meson_mx_ao_arc_rproc_da_to_va(struct rproc *rproc, u64 da,\n\t\t\t\t\t    size_t len, bool *is_iomem)\n{\n\tstruct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;\n\n\t \n\tif ((da + len) > priv->sram_size)\n\t\treturn NULL;\n\n\treturn (void *)priv->sram_va + da;\n}\n\nstatic struct rproc_ops meson_mx_ao_arc_rproc_ops = {\n\t.start\t\t= meson_mx_ao_arc_rproc_start,\n\t.stop\t\t= meson_mx_ao_arc_rproc_stop,\n\t.da_to_va\t= meson_mx_ao_arc_rproc_da_to_va,\n\t.get_boot_addr\t= rproc_elf_get_boot_addr,\n\t.load\t\t= rproc_elf_load_segments,\n\t.sanity_check\t= rproc_elf_sanity_check,\n};\n\nstatic int meson_mx_ao_arc_rproc_probe(struct platform_device *pdev)\n{\n\tstruct meson_mx_ao_arc_rproc_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tconst char *fw_name = NULL;\n\tstruct rproc *rproc;\n\tint ret;\n\n\tdevice_property_read_string(dev, \"firmware-name\", &fw_name);\n\n\trproc = devm_rproc_alloc(dev, \"meson-mx-ao-arc\",\n\t\t\t\t &meson_mx_ao_arc_rproc_ops, fw_name,\n\t\t\t\t sizeof(*priv));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\trproc->has_iommu = false;\n\tpriv = rproc->priv;\n\n\tpriv->sram_pool = of_gen_pool_get(dev->of_node, \"sram\", 0);\n\tif (!priv->sram_pool) {\n\t\tdev_err(dev, \"Could not get SRAM pool\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv->sram_size = gen_pool_avail(priv->sram_pool);\n\n\tpriv->sram_va = gen_pool_alloc(priv->sram_pool, priv->sram_size);\n\tif (!priv->sram_va) {\n\t\tdev_err(dev, \"Could not alloc memory in SRAM pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->sram_pa = gen_pool_virt_to_phys(priv->sram_pool, priv->sram_va);\n\tif (priv->sram_pa & ~MESON_AO_RPROC_SRAM_USABLE_BITS) {\n\t\tdev_err(dev, \"SRAM address contains unusable bits\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_free_genpool;\n\t}\n\n\tpriv->secbus2_regmap = syscon_regmap_lookup_by_phandle(dev->of_node,\n\t\t\t\t\t\t\t       \"amlogic,secbus2\");\n\tif (IS_ERR(priv->secbus2_regmap)) {\n\t\tdev_err(dev, \"Failed to find SECBUS2 regmap\\n\");\n\t\tret = PTR_ERR(priv->secbus2_regmap);\n\t\tgoto err_free_genpool;\n\t}\n\n\tpriv->remap_base = devm_platform_ioremap_resource_byname(pdev, \"remap\");\n\tif (IS_ERR(priv->remap_base)) {\n\t\tret = PTR_ERR(priv->remap_base);\n\t\tgoto err_free_genpool;\n\t}\n\n\tpriv->cpu_base = devm_platform_ioremap_resource_byname(pdev, \"cpu\");\n\tif (IS_ERR(priv->cpu_base)) {\n\t\tret = PTR_ERR(priv->cpu_base);\n\t\tgoto err_free_genpool;\n\t}\n\n\tpriv->arc_reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(priv->arc_reset)) {\n\t\tdev_err(dev, \"Failed to get ARC reset\\n\");\n\t\tret = PTR_ERR(priv->arc_reset);\n\t\tgoto err_free_genpool;\n\t}\n\n\tpriv->arc_pclk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(priv->arc_pclk)) {\n\t\tdev_err(dev, \"Failed to get the ARC PCLK\\n\");\n\t\tret = PTR_ERR(priv->arc_pclk);\n\t\tgoto err_free_genpool;\n\t}\n\n\tplatform_set_drvdata(pdev, rproc);\n\n\tret = rproc_add(rproc);\n\tif (ret)\n\t\tgoto err_free_genpool;\n\n\treturn 0;\n\nerr_free_genpool:\n\tgen_pool_free(priv->sram_pool, priv->sram_va, priv->sram_size);\n\treturn ret;\n}\n\nstatic void meson_mx_ao_arc_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\tstruct meson_mx_ao_arc_rproc_priv *priv = rproc->priv;\n\n\trproc_del(rproc);\n\tgen_pool_free(priv->sram_pool, priv->sram_va, priv->sram_size);\n}\n\nstatic const struct of_device_id meson_mx_ao_arc_rproc_match[] = {\n\t{ .compatible = \"amlogic,meson8-ao-arc\" },\n\t{ .compatible = \"amlogic,meson8b-ao-arc\" },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, meson_mx_ao_arc_rproc_match);\n\nstatic struct platform_driver meson_mx_ao_arc_rproc_driver = {\n\t.probe = meson_mx_ao_arc_rproc_probe,\n\t.remove_new = meson_mx_ao_arc_rproc_remove,\n\t.driver = {\n\t\t.name = \"meson-mx-ao-arc-rproc\",\n\t\t.of_match_table = meson_mx_ao_arc_rproc_match,\n\t},\n};\nmodule_platform_driver(meson_mx_ao_arc_rproc_driver);\n\nMODULE_DESCRIPTION(\"Amlogic Meson6/8/8b/8m2 AO ARC remote processor driver\");\nMODULE_AUTHOR(\"Martin Blumenstingl <martin.blumenstingl@googlemail.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}