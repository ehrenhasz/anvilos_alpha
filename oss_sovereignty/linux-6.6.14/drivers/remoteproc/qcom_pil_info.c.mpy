{
  "module_name": "qcom_pil_info.c",
  "hash_id": "f6d74c59a20d66c2f3bd45eb8300678268e6adca340996acec1cf3e2e20500b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_pil_info.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_address.h>\n#include \"qcom_pil_info.h\"\n\n \n#define PIL_RELOC_NAME_LEN\t8\n#define PIL_RELOC_ENTRY_SIZE\t(PIL_RELOC_NAME_LEN + sizeof(__le64) + sizeof(__le32))\n\nstruct pil_reloc {\n\tvoid __iomem *base;\n\tsize_t num_entries;\n};\n\nstatic struct pil_reloc _reloc __read_mostly;\nstatic DEFINE_MUTEX(pil_reloc_lock);\n\nstatic int qcom_pil_info_init(void)\n{\n\tstruct device_node *np;\n\tstruct resource imem;\n\tvoid __iomem *base;\n\tint ret;\n\n\t \n\tif (_reloc.base)\n\t\treturn 0;\n\n\tnp = of_find_compatible_node(NULL, NULL, \"qcom,pil-reloc-info\");\n\tif (!np)\n\t\treturn -ENOENT;\n\n\tret = of_address_to_resource(np, 0, &imem);\n\tof_node_put(np);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tbase = ioremap(imem.start, resource_size(&imem));\n\tif (!base) {\n\t\tpr_err(\"failed to map PIL relocation info region\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset_io(base, 0, resource_size(&imem));\n\n\t_reloc.base = base;\n\t_reloc.num_entries = (u32)resource_size(&imem) / PIL_RELOC_ENTRY_SIZE;\n\n\treturn 0;\n}\n\n \nint qcom_pil_info_store(const char *image, phys_addr_t base, size_t size)\n{\n\tchar buf[PIL_RELOC_NAME_LEN];\n\tvoid __iomem *entry;\n\tint ret;\n\tint i;\n\n\tmutex_lock(&pil_reloc_lock);\n\tret = qcom_pil_info_init();\n\tif (ret < 0) {\n\t\tmutex_unlock(&pil_reloc_lock);\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < _reloc.num_entries; i++) {\n\t\tentry = _reloc.base + i * PIL_RELOC_ENTRY_SIZE;\n\n\t\tmemcpy_fromio(buf, entry, PIL_RELOC_NAME_LEN);\n\n\t\t \n\t\tif (!buf[0])\n\t\t\tgoto found_unused;\n\n\t\tif (!strncmp(buf, image, PIL_RELOC_NAME_LEN))\n\t\t\tgoto found_existing;\n\t}\n\n\tpr_warn(\"insufficient PIL info slots\\n\");\n\tmutex_unlock(&pil_reloc_lock);\n\treturn -ENOMEM;\n\nfound_unused:\n\tmemcpy_toio(entry, image, strnlen(image, PIL_RELOC_NAME_LEN));\nfound_existing:\n\t \n\twritel(base, entry + PIL_RELOC_NAME_LEN);\n\twritel((u64)base >> 32, entry + PIL_RELOC_NAME_LEN + 4);\n\twritel(size, entry + PIL_RELOC_NAME_LEN + sizeof(__le64));\n\tmutex_unlock(&pil_reloc_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qcom_pil_info_store);\n\nstatic void __exit pil_reloc_exit(void)\n{\n\tmutex_lock(&pil_reloc_lock);\n\tiounmap(_reloc.base);\n\t_reloc.base = NULL;\n\tmutex_unlock(&pil_reloc_lock);\n}\nmodule_exit(pil_reloc_exit);\n\nMODULE_DESCRIPTION(\"Qualcomm PIL relocation info\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}