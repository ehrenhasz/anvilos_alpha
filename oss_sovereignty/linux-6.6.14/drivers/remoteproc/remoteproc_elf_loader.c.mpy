{
  "module_name": "remoteproc_elf_loader.c",
  "hash_id": "186b7eddfe9c49a288d9f83246ef05701d21e95ec0358a4de0dabc62dbe0274d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/remoteproc_elf_loader.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)    \"%s: \" fmt, __func__\n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/remoteproc.h>\n#include <linux/elf.h>\n\n#include \"remoteproc_internal.h\"\n#include \"remoteproc_elf_helpers.h\"\n\n \nint rproc_elf_sanity_check(struct rproc *rproc, const struct firmware *fw)\n{\n\tconst char *name = rproc->firmware;\n\tstruct device *dev = &rproc->dev;\n\t \n\tstruct elf32_hdr *ehdr;\n\tu32 elf_shdr_get_size;\n\tu64 phoff, shoff;\n\tchar class;\n\tu16 phnum;\n\n\tif (!fw) {\n\t\tdev_err(dev, \"failed to load %s\\n\", name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size < sizeof(struct elf32_hdr)) {\n\t\tdev_err(dev, \"Image is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tehdr = (struct elf32_hdr *)fw->data;\n\n\tif (memcmp(ehdr->e_ident, ELFMAG, SELFMAG)) {\n\t\tdev_err(dev, \"Image is corrupted (bad magic)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tclass = ehdr->e_ident[EI_CLASS];\n\tif (class != ELFCLASS32 && class != ELFCLASS64) {\n\t\tdev_err(dev, \"Unsupported class: %d\\n\", class);\n\t\treturn -EINVAL;\n\t}\n\n\tif (class == ELFCLASS64 && fw->size < sizeof(struct elf64_hdr)) {\n\t\tdev_err(dev, \"elf64 header is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n# ifdef __LITTLE_ENDIAN\n\tif (ehdr->e_ident[EI_DATA] != ELFDATA2LSB) {\n# else  \n\tif (ehdr->e_ident[EI_DATA] != ELFDATA2MSB) {\n# endif\n\t\tdev_err(dev, \"Unsupported firmware endianness\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tphoff = elf_hdr_get_e_phoff(class, fw->data);\n\tshoff = elf_hdr_get_e_shoff(class, fw->data);\n\tphnum =  elf_hdr_get_e_phnum(class, fw->data);\n\telf_shdr_get_size = elf_size_of_shdr(class);\n\n\tif (fw->size < shoff + elf_shdr_get_size) {\n\t\tdev_err(dev, \"Image is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (phnum == 0) {\n\t\tdev_err(dev, \"No loadable segments\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (phoff > fw->size) {\n\t\tdev_err(dev, \"Firmware size is too small\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_dbg(dev, \"Firmware is an elf%d file\\n\",\n\t\tclass == ELFCLASS32 ? 32 : 64);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_elf_sanity_check);\n\n \nu64 rproc_elf_get_boot_addr(struct rproc *rproc, const struct firmware *fw)\n{\n\treturn elf_hdr_get_e_entry(fw_elf_get_class(fw), fw->data);\n}\nEXPORT_SYMBOL(rproc_elf_get_boot_addr);\n\n \nint rproc_elf_load_segments(struct rproc *rproc, const struct firmware *fw)\n{\n\tstruct device *dev = &rproc->dev;\n\tconst void *ehdr, *phdr;\n\tint i, ret = 0;\n\tu16 phnum;\n\tconst u8 *elf_data = fw->data;\n\tu8 class = fw_elf_get_class(fw);\n\tu32 elf_phdr_get_size = elf_size_of_phdr(class);\n\n\tehdr = elf_data;\n\tphnum = elf_hdr_get_e_phnum(class, ehdr);\n\tphdr = elf_data + elf_hdr_get_e_phoff(class, ehdr);\n\n\t \n\tfor (i = 0; i < phnum; i++, phdr += elf_phdr_get_size) {\n\t\tu64 da = elf_phdr_get_p_paddr(class, phdr);\n\t\tu64 memsz = elf_phdr_get_p_memsz(class, phdr);\n\t\tu64 filesz = elf_phdr_get_p_filesz(class, phdr);\n\t\tu64 offset = elf_phdr_get_p_offset(class, phdr);\n\t\tu32 type = elf_phdr_get_p_type(class, phdr);\n\t\tbool is_iomem = false;\n\t\tvoid *ptr;\n\n\t\tif (type != PT_LOAD || !memsz)\n\t\t\tcontinue;\n\n\t\tdev_dbg(dev, \"phdr: type %d da 0x%llx memsz 0x%llx filesz 0x%llx\\n\",\n\t\t\ttype, da, memsz, filesz);\n\n\t\tif (filesz > memsz) {\n\t\t\tdev_err(dev, \"bad phdr filesz 0x%llx memsz 0x%llx\\n\",\n\t\t\t\tfilesz, memsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (offset + filesz > fw->size) {\n\t\t\tdev_err(dev, \"truncated fw: need 0x%llx avail 0x%zx\\n\",\n\t\t\t\toffset + filesz, fw->size);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!rproc_u64_fit_in_size_t(memsz)) {\n\t\t\tdev_err(dev, \"size (%llx) does not fit in size_t type\\n\",\n\t\t\t\tmemsz);\n\t\t\tret = -EOVERFLOW;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tptr = rproc_da_to_va(rproc, da, memsz, &is_iomem);\n\t\tif (!ptr) {\n\t\t\tdev_err(dev, \"bad phdr da 0x%llx mem 0x%llx\\n\", da,\n\t\t\t\tmemsz);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (filesz) {\n\t\t\tif (is_iomem)\n\t\t\t\tmemcpy_toio((void __iomem *)ptr, elf_data + offset, filesz);\n\t\t\telse\n\t\t\t\tmemcpy(ptr, elf_data + offset, filesz);\n\t\t}\n\n\t\t \n\t\tif (memsz > filesz) {\n\t\t\tif (is_iomem)\n\t\t\t\tmemset_io((void __iomem *)(ptr + filesz), 0, memsz - filesz);\n\t\t\telse\n\t\t\t\tmemset(ptr + filesz, 0, memsz - filesz);\n\t\t}\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rproc_elf_load_segments);\n\nstatic const void *\nfind_table(struct device *dev, const struct firmware *fw)\n{\n\tconst void *shdr, *name_table_shdr;\n\tint i;\n\tconst char *name_table;\n\tstruct resource_table *table = NULL;\n\tconst u8 *elf_data = (void *)fw->data;\n\tu8 class = fw_elf_get_class(fw);\n\tsize_t fw_size = fw->size;\n\tconst void *ehdr = elf_data;\n\tu16 shnum = elf_hdr_get_e_shnum(class, ehdr);\n\tu32 elf_shdr_get_size = elf_size_of_shdr(class);\n\tu16 shstrndx = elf_hdr_get_e_shstrndx(class, ehdr);\n\n\t \n\t \n\tshdr = elf_data + elf_hdr_get_e_shoff(class, ehdr);\n\t \n\tname_table_shdr = shdr + (shstrndx * elf_shdr_get_size);\n\t \n\tname_table = elf_data + elf_shdr_get_sh_offset(class, name_table_shdr);\n\n\tfor (i = 0; i < shnum; i++, shdr += elf_shdr_get_size) {\n\t\tu64 size = elf_shdr_get_sh_size(class, shdr);\n\t\tu64 offset = elf_shdr_get_sh_offset(class, shdr);\n\t\tu32 name = elf_shdr_get_sh_name(class, shdr);\n\n\t\tif (strcmp(name_table + name, \".resource_table\"))\n\t\t\tcontinue;\n\n\t\ttable = (struct resource_table *)(elf_data + offset);\n\n\t\t \n\t\tif (offset + size > fw_size || offset + size < size) {\n\t\t\tdev_err(dev, \"resource table truncated\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (sizeof(struct resource_table) > size) {\n\t\t\tdev_err(dev, \"header-less resource table\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (table->ver != 1) {\n\t\t\tdev_err(dev, \"unsupported fw ver: %d\\n\", table->ver);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (table->reserved[0] || table->reserved[1]) {\n\t\t\tdev_err(dev, \"non zero reserved bytes\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tif (struct_size(table, offset, table->num) > size) {\n\t\t\tdev_err(dev, \"resource table incomplete\\n\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\treturn shdr;\n\t}\n\n\treturn NULL;\n}\n\n \nint rproc_elf_load_rsc_table(struct rproc *rproc, const struct firmware *fw)\n{\n\tconst void *shdr;\n\tstruct device *dev = &rproc->dev;\n\tstruct resource_table *table = NULL;\n\tconst u8 *elf_data = fw->data;\n\tsize_t tablesz;\n\tu8 class = fw_elf_get_class(fw);\n\tu64 sh_offset;\n\n\tshdr = find_table(dev, fw);\n\tif (!shdr)\n\t\treturn -EINVAL;\n\n\tsh_offset = elf_shdr_get_sh_offset(class, shdr);\n\ttable = (struct resource_table *)(elf_data + sh_offset);\n\ttablesz = elf_shdr_get_sh_size(class, shdr);\n\n\t \n\trproc->cached_table = kmemdup(table, tablesz, GFP_KERNEL);\n\tif (!rproc->cached_table)\n\t\treturn -ENOMEM;\n\n\trproc->table_ptr = rproc->cached_table;\n\trproc->table_sz = tablesz;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rproc_elf_load_rsc_table);\n\n \nstruct resource_table *rproc_elf_find_loaded_rsc_table(struct rproc *rproc,\n\t\t\t\t\t\t       const struct firmware *fw)\n{\n\tconst void *shdr;\n\tu64 sh_addr, sh_size;\n\tu8 class = fw_elf_get_class(fw);\n\tstruct device *dev = &rproc->dev;\n\n\tshdr = find_table(&rproc->dev, fw);\n\tif (!shdr)\n\t\treturn NULL;\n\n\tsh_addr = elf_shdr_get_sh_addr(class, shdr);\n\tsh_size = elf_shdr_get_sh_size(class, shdr);\n\n\tif (!rproc_u64_fit_in_size_t(sh_size)) {\n\t\tdev_err(dev, \"size (%llx) does not fit in size_t type\\n\",\n\t\t\tsh_size);\n\t\treturn NULL;\n\t}\n\n\treturn rproc_da_to_va(rproc, sh_addr, sh_size, NULL);\n}\nEXPORT_SYMBOL(rproc_elf_find_loaded_rsc_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}