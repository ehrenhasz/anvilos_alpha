{
  "module_name": "wkup_m3_rproc.c",
  "hash_id": "be412e69a21d370310e85710be6ddc629edd5efe42fbe081b4647df419025baa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/wkup_m3_rproc.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n\n#include <linux/platform_data/wkup_m3.h>\n\n#include \"remoteproc_internal.h\"\n\n#define WKUPM3_MEM_MAX\t2\n\n \nstruct wkup_m3_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\n \nstruct wkup_m3_rproc {\n\tstruct rproc *rproc;\n\tstruct platform_device *pdev;\n\tstruct wkup_m3_mem mem[WKUPM3_MEM_MAX];\n\tstruct reset_control *rsts;\n};\n\nstatic int wkup_m3_rproc_start(struct rproc *rproc)\n{\n\tstruct wkup_m3_rproc *wkupm3 = rproc->priv;\n\tstruct platform_device *pdev = wkupm3->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct wkup_m3_platform_data *pdata = dev_get_platdata(dev);\n\tint error = 0;\n\n\terror = reset_control_deassert(wkupm3->rsts);\n\n\tif (!wkupm3->rsts && pdata->deassert_reset(pdev, pdata->reset_name)) {\n\t\tdev_err(dev, \"Unable to reset wkup_m3!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\treturn error;\n}\n\nstatic int wkup_m3_rproc_stop(struct rproc *rproc)\n{\n\tstruct wkup_m3_rproc *wkupm3 = rproc->priv;\n\tstruct platform_device *pdev = wkupm3->pdev;\n\tstruct device *dev = &pdev->dev;\n\tstruct wkup_m3_platform_data *pdata = dev_get_platdata(dev);\n\tint error = 0;\n\n\terror = reset_control_assert(wkupm3->rsts);\n\n\tif (!wkupm3->rsts && pdata->assert_reset(pdev, pdata->reset_name)) {\n\t\tdev_err(dev, \"Unable to assert reset of wkup_m3!\\n\");\n\t\terror = -ENODEV;\n\t}\n\n\treturn error;\n}\n\nstatic void *wkup_m3_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct wkup_m3_rproc *wkupm3 = rproc->priv;\n\tvoid *va = NULL;\n\tint i;\n\tu32 offset;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < WKUPM3_MEM_MAX; i++) {\n\t\tif (da >= wkupm3->mem[i].dev_addr && da + len <=\n\t\t    wkupm3->mem[i].dev_addr +  wkupm3->mem[i].size) {\n\t\t\toffset = da -  wkupm3->mem[i].dev_addr;\n\t\t\t \n\t\t\tva = (__force void *)(wkupm3->mem[i].cpu_addr + offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn va;\n}\n\nstatic const struct rproc_ops wkup_m3_rproc_ops = {\n\t.start\t\t= wkup_m3_rproc_start,\n\t.stop\t\t= wkup_m3_rproc_stop,\n\t.da_to_va\t= wkup_m3_rproc_da_to_va,\n};\n\nstatic const struct of_device_id wkup_m3_rproc_of_match[] = {\n\t{ .compatible = \"ti,am3352-wkup-m3\", },\n\t{ .compatible = \"ti,am4372-wkup-m3\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, wkup_m3_rproc_of_match);\n\nstatic int wkup_m3_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct wkup_m3_platform_data *pdata = dev->platform_data;\n\t \n\tconst char *mem_names[WKUPM3_MEM_MAX] = { \"umem\", \"dmem\" };\n\tstruct wkup_m3_rproc *wkupm3;\n\tconst char *fw_name;\n\tstruct rproc *rproc;\n\tstruct resource *res;\n\tconst __be32 *addrp;\n\tu32 l4_offset = 0;\n\tu64 size;\n\tint ret;\n\tint i;\n\n\tret = of_property_read_string(dev->of_node, \"ti,pm-firmware\",\n\t\t\t\t      &fw_name);\n\tif (ret) {\n\t\tdev_err(dev, \"No firmware filename given\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpm_runtime_enable(&pdev->dev);\n\tret = pm_runtime_get_sync(&pdev->dev);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"pm_runtime_get_sync() failed\\n\");\n\t\tgoto err;\n\t}\n\n\trproc = rproc_alloc(dev, \"wkup_m3\", &wkup_m3_rproc_ops,\n\t\t\t    fw_name, sizeof(*wkupm3));\n\tif (!rproc) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\trproc->auto_boot = false;\n\trproc->sysfs_read_only = true;\n\n\twkupm3 = rproc->priv;\n\twkupm3->rproc = rproc;\n\twkupm3->pdev = pdev;\n\n\twkupm3->rsts = devm_reset_control_get_optional_shared(dev, \"rstctrl\");\n\tif (IS_ERR(wkupm3->rsts))\n\t\treturn PTR_ERR(wkupm3->rsts);\n\tif (!wkupm3->rsts) {\n\t\tif (!(pdata && pdata->deassert_reset && pdata->assert_reset &&\n\t\t      pdata->reset_name)) {\n\t\t\tdev_err(dev, \"Platform data missing!\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto err_put_rproc;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(mem_names); i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   mem_names[i]);\n\t\twkupm3->mem[i].cpu_addr = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(wkupm3->mem[i].cpu_addr)) {\n\t\t\tdev_err(&pdev->dev, \"devm_ioremap_resource failed for resource %d\\n\",\n\t\t\t\ti);\n\t\t\tret = PTR_ERR(wkupm3->mem[i].cpu_addr);\n\t\t\tgoto err_put_rproc;\n\t\t}\n\t\twkupm3->mem[i].bus_addr = res->start;\n\t\twkupm3->mem[i].size = resource_size(res);\n\t\taddrp = of_get_address(dev->of_node, i, &size, NULL);\n\t\t \n\t\tif (!strcmp(mem_names[i], \"umem\"))\n\t\t\tl4_offset = be32_to_cpu(*addrp);\n\t\twkupm3->mem[i].dev_addr = be32_to_cpu(*addrp) - l4_offset;\n\t}\n\n\tdev_set_drvdata(dev, rproc);\n\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"rproc_add failed\\n\");\n\t\tgoto err_put_rproc;\n\t}\n\n\treturn 0;\n\nerr_put_rproc:\n\trproc_free(rproc);\nerr:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void wkup_m3_rproc_remove(struct platform_device *pdev)\n{\n\tstruct rproc *rproc = platform_get_drvdata(pdev);\n\n\trproc_del(rproc);\n\trproc_free(rproc);\n\tpm_runtime_put_sync(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n}\n\n#ifdef CONFIG_PM\nstatic int wkup_m3_rpm_suspend(struct device *dev)\n{\n\treturn -EBUSY;\n}\n\nstatic int wkup_m3_rpm_resume(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic const struct dev_pm_ops wkup_m3_rproc_pm_ops = {\n\tSET_RUNTIME_PM_OPS(wkup_m3_rpm_suspend, wkup_m3_rpm_resume, NULL)\n};\n\nstatic struct platform_driver wkup_m3_rproc_driver = {\n\t.probe = wkup_m3_rproc_probe,\n\t.remove_new = wkup_m3_rproc_remove,\n\t.driver = {\n\t\t.name = \"wkup_m3_rproc\",\n\t\t.of_match_table = wkup_m3_rproc_of_match,\n\t\t.pm = &wkup_m3_rproc_pm_ops,\n\t},\n};\n\nmodule_platform_driver(wkup_m3_rproc_driver);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI Wakeup M3 remote processor control driver\");\nMODULE_AUTHOR(\"Dave Gerlach <d-gerlach@ti.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}