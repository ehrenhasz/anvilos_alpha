{
  "module_name": "qcom_wcnss_iris.c",
  "hash_id": "78d95ebdcefd3d68c079305c88288bf2bd7068e61616e6605d5e98ee5a26a4cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/qcom_wcnss_iris.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n\n#include \"qcom_wcnss.h\"\n\nstruct qcom_iris {\n\tstruct device dev;\n\n\tstruct clk *xo_clk;\n\n\tstruct regulator_bulk_data *vregs;\n\tsize_t num_vregs;\n};\n\nstruct iris_data {\n\tconst struct wcnss_vreg_info *vregs;\n\tsize_t num_vregs;\n\n\tbool use_48mhz_xo;\n};\n\nstatic const struct iris_data wcn3620_data = {\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddxo\",  1800000, 1800000, 10000 },\n\t\t{ \"vddrfa\", 1300000, 1300000, 100000 },\n\t\t{ \"vddpa\",  3300000, 3300000, 515000 },\n\t\t{ \"vdddig\", 1800000, 1800000, 10000 },\n\t},\n\t.num_vregs = 4,\n\t.use_48mhz_xo = false,\n};\n\nstatic const struct iris_data wcn3660_data = {\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddxo\",  1800000, 1800000, 10000 },\n\t\t{ \"vddrfa\", 1300000, 1300000, 100000 },\n\t\t{ \"vddpa\",  2900000, 3000000, 515000 },\n\t\t{ \"vdddig\", 1200000, 1225000, 10000 },\n\t},\n\t.num_vregs = 4,\n\t.use_48mhz_xo = true,\n};\n\nstatic const struct iris_data wcn3680_data = {\n\t.vregs = (struct wcnss_vreg_info[]) {\n\t\t{ \"vddxo\",  1800000, 1800000, 10000 },\n\t\t{ \"vddrfa\", 1300000, 1300000, 100000 },\n\t\t{ \"vddpa\",  3300000, 3300000, 515000 },\n\t\t{ \"vdddig\", 1800000, 1800000, 10000 },\n\t},\n\t.num_vregs = 4,\n\t.use_48mhz_xo = true,\n};\n\nint qcom_iris_enable(struct qcom_iris *iris)\n{\n\tint ret;\n\n\tret = regulator_bulk_enable(iris->num_vregs, iris->vregs);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(iris->xo_clk);\n\tif (ret) {\n\t\tdev_err(&iris->dev, \"failed to enable xo clk\\n\");\n\t\tgoto disable_regulators;\n\t}\n\n\treturn 0;\n\ndisable_regulators:\n\tregulator_bulk_disable(iris->num_vregs, iris->vregs);\n\n\treturn ret;\n}\n\nvoid qcom_iris_disable(struct qcom_iris *iris)\n{\n\tclk_disable_unprepare(iris->xo_clk);\n\tregulator_bulk_disable(iris->num_vregs, iris->vregs);\n}\n\nstatic const struct of_device_id iris_of_match[] = {\n\t{ .compatible = \"qcom,wcn3620\", .data = &wcn3620_data },\n\t{ .compatible = \"qcom,wcn3660\", .data = &wcn3660_data },\n\t{ .compatible = \"qcom,wcn3660b\", .data = &wcn3680_data },\n\t{ .compatible = \"qcom,wcn3680\", .data = &wcn3680_data },\n\t{}\n};\n\nstatic void qcom_iris_release(struct device *dev)\n{\n\tstruct qcom_iris *iris = container_of(dev, struct qcom_iris, dev);\n\n\tof_node_put(iris->dev.of_node);\n\tkfree(iris);\n}\n\nstruct qcom_iris *qcom_iris_probe(struct device *parent, bool *use_48mhz_xo)\n{\n\tconst struct of_device_id *match;\n\tconst struct iris_data *data;\n\tstruct device_node *of_node;\n\tstruct qcom_iris *iris;\n\tint ret;\n\tint i;\n\n\tof_node = of_get_child_by_name(parent->of_node, \"iris\");\n\tif (!of_node) {\n\t\tdev_err(parent, \"No child node \\\"iris\\\" found\\n\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tiris = kzalloc(sizeof(*iris), GFP_KERNEL);\n\tif (!iris) {\n\t\tof_node_put(of_node);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdevice_initialize(&iris->dev);\n\tiris->dev.parent = parent;\n\tiris->dev.release = qcom_iris_release;\n\tiris->dev.of_node = of_node;\n\n\tdev_set_name(&iris->dev, \"%s.iris\", dev_name(parent));\n\n\tret = device_add(&iris->dev);\n\tif (ret) {\n\t\tput_device(&iris->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tmatch = of_match_device(iris_of_match, &iris->dev);\n\tif (!match) {\n\t\tdev_err(&iris->dev, \"no matching compatible for iris\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_device_del;\n\t}\n\n\tdata = match->data;\n\n\tiris->xo_clk = devm_clk_get(&iris->dev, \"xo\");\n\tif (IS_ERR(iris->xo_clk)) {\n\t\tret = PTR_ERR(iris->xo_clk);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&iris->dev, \"failed to acquire xo clk\\n\");\n\t\tgoto err_device_del;\n\t}\n\n\tiris->num_vregs = data->num_vregs;\n\tiris->vregs = devm_kcalloc(&iris->dev,\n\t\t\t\t   iris->num_vregs,\n\t\t\t\t   sizeof(struct regulator_bulk_data),\n\t\t\t\t   GFP_KERNEL);\n\tif (!iris->vregs) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_del;\n\t}\n\n\tfor (i = 0; i < iris->num_vregs; i++)\n\t\tiris->vregs[i].supply = data->vregs[i].name;\n\n\tret = devm_regulator_bulk_get(&iris->dev, iris->num_vregs, iris->vregs);\n\tif (ret) {\n\t\tdev_err(&iris->dev, \"failed to get regulators\\n\");\n\t\tgoto err_device_del;\n\t}\n\n\tfor (i = 0; i < iris->num_vregs; i++) {\n\t\tif (data->vregs[i].max_voltage)\n\t\t\tregulator_set_voltage(iris->vregs[i].consumer,\n\t\t\t\t\t      data->vregs[i].min_voltage,\n\t\t\t\t\t      data->vregs[i].max_voltage);\n\n\t\tif (data->vregs[i].load_uA)\n\t\t\tregulator_set_load(iris->vregs[i].consumer,\n\t\t\t\t\t   data->vregs[i].load_uA);\n\t}\n\n\t*use_48mhz_xo = data->use_48mhz_xo;\n\n\treturn iris;\n\nerr_device_del:\n\tdevice_del(&iris->dev);\n\n\treturn ERR_PTR(ret);\n}\n\nvoid qcom_iris_remove(struct qcom_iris *iris)\n{\n\tdevice_del(&iris->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}