{
  "module_name": "ti_k3_dsp_remoteproc.c",
  "hash_id": "ba303d96fef1f52f52b10094e1ee337a8a4e919e65f38279cfaa445418fbe3f7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/remoteproc/ti_k3_dsp_remoteproc.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_reserved_mem.h>\n#include <linux/omap-mailbox.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n\n#include \"omap_remoteproc.h\"\n#include \"remoteproc_internal.h\"\n#include \"ti_sci_proc.h\"\n\n#define KEYSTONE_RPROC_LOCAL_ADDRESS_MASK\t(SZ_16M - 1)\n\n \nstruct k3_dsp_mem {\n\tvoid __iomem *cpu_addr;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr;\n\tsize_t size;\n};\n\n \nstruct k3_dsp_mem_data {\n\tconst char *name;\n\tconst u32 dev_addr;\n};\n\n \nstruct k3_dsp_dev_data {\n\tconst struct k3_dsp_mem_data *mems;\n\tu32 num_mems;\n\tu32 boot_align_addr;\n\tbool uses_lreset;\n};\n\n \nstruct k3_dsp_rproc {\n\tstruct device *dev;\n\tstruct rproc *rproc;\n\tstruct k3_dsp_mem *mem;\n\tint num_mems;\n\tstruct k3_dsp_mem *rmem;\n\tint num_rmems;\n\tstruct reset_control *reset;\n\tconst struct k3_dsp_dev_data *data;\n\tstruct ti_sci_proc *tsp;\n\tconst struct ti_sci_handle *ti_sci;\n\tu32 ti_sci_id;\n\tstruct mbox_chan *mbox;\n\tstruct mbox_client client;\n};\n\n \nstatic void k3_dsp_rproc_mbox_callback(struct mbox_client *client, void *data)\n{\n\tstruct k3_dsp_rproc *kproc = container_of(client, struct k3_dsp_rproc,\n\t\t\t\t\t\t  client);\n\tstruct device *dev = kproc->rproc->dev.parent;\n\tconst char *name = kproc->rproc->name;\n\tu32 msg = omap_mbox_message(data);\n\n\tdev_dbg(dev, \"mbox msg: 0x%x\\n\", msg);\n\n\tswitch (msg) {\n\tcase RP_MBOX_CRASH:\n\t\t \n\t\tdev_err(dev, \"K3 DSP rproc %s crashed\\n\", name);\n\t\tbreak;\n\tcase RP_MBOX_ECHO_REPLY:\n\t\tdev_info(dev, \"received echo reply from %s\\n\", name);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (msg >= RP_MBOX_READY && msg < RP_MBOX_END_MSG)\n\t\t\treturn;\n\t\tif (msg > kproc->rproc->max_notifyid) {\n\t\t\tdev_dbg(dev, \"dropping unknown message 0x%x\", msg);\n\t\t\treturn;\n\t\t}\n\t\t \n\t\tif (rproc_vq_interrupt(kproc->rproc, msg) == IRQ_NONE)\n\t\t\tdev_dbg(dev, \"no message was found in vqid %d\\n\", msg);\n\t}\n}\n\n \nstatic void k3_dsp_rproc_kick(struct rproc *rproc, int vqid)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = rproc->dev.parent;\n\tmbox_msg_t msg = (mbox_msg_t)vqid;\n\tint ret;\n\n\t \n\tret = mbox_send_message(kproc->mbox, (void *)msg);\n\tif (ret < 0)\n\t\tdev_err(dev, \"failed to send mailbox message, status = %d\\n\",\n\t\t\tret);\n}\n\n \nstatic int k3_dsp_rproc_reset(struct k3_dsp_rproc *kproc)\n{\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tret = reset_control_assert(kproc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"local-reset assert failed, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (kproc->data->uses_lreset)\n\t\treturn ret;\n\n\tret = kproc->ti_sci->ops.dev_ops.put_device(kproc->ti_sci,\n\t\t\t\t\t\t    kproc->ti_sci_id);\n\tif (ret) {\n\t\tdev_err(dev, \"module-reset assert failed, ret = %d\\n\", ret);\n\t\tif (reset_control_deassert(kproc->reset))\n\t\t\tdev_warn(dev, \"local-reset deassert back failed\\n\");\n\t}\n\n\treturn ret;\n}\n\n \nstatic int k3_dsp_rproc_release(struct k3_dsp_rproc *kproc)\n{\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tif (kproc->data->uses_lreset)\n\t\tgoto lreset;\n\n\tret = kproc->ti_sci->ops.dev_ops.get_device(kproc->ti_sci,\n\t\t\t\t\t\t    kproc->ti_sci_id);\n\tif (ret) {\n\t\tdev_err(dev, \"module-reset deassert failed, ret = %d\\n\", ret);\n\t\treturn ret;\n\t}\n\nlreset:\n\tret = reset_control_deassert(kproc->reset);\n\tif (ret) {\n\t\tdev_err(dev, \"local-reset deassert failed, ret = %d\\n\", ret);\n\t\tif (kproc->ti_sci->ops.dev_ops.put_device(kproc->ti_sci,\n\t\t\t\t\t\t\t  kproc->ti_sci_id))\n\t\t\tdev_warn(dev, \"module-reset assert back failed\\n\");\n\t}\n\n\treturn ret;\n}\n\nstatic int k3_dsp_rproc_request_mbox(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct mbox_client *client = &kproc->client;\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tclient->dev = dev;\n\tclient->tx_done = NULL;\n\tclient->rx_callback = k3_dsp_rproc_mbox_callback;\n\tclient->tx_block = false;\n\tclient->knows_txdone = false;\n\n\tkproc->mbox = mbox_request_channel(client, 0);\n\tif (IS_ERR(kproc->mbox)) {\n\t\tret = -EBUSY;\n\t\tdev_err(dev, \"mbox_request_channel failed: %ld\\n\",\n\t\t\tPTR_ERR(kproc->mbox));\n\t\treturn ret;\n\t}\n\n\t \n\tret = mbox_send_message(kproc->mbox, (void *)RP_MBOX_ECHO_REQUEST);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"mbox_send_message failed: %d\\n\", ret);\n\t\tmbox_free_channel(kproc->mbox);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n \nstatic int k3_dsp_rproc_prepare(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tret = kproc->ti_sci->ops.dev_ops.get_device(kproc->ti_sci,\n\t\t\t\t\t\t    kproc->ti_sci_id);\n\tif (ret)\n\t\tdev_err(dev, \"module-reset deassert failed, cannot enable internal RAM loading, ret = %d\\n\",\n\t\t\tret);\n\n\treturn ret;\n}\n\n \nstatic int k3_dsp_rproc_unprepare(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tret = kproc->ti_sci->ops.dev_ops.put_device(kproc->ti_sci,\n\t\t\t\t\t\t    kproc->ti_sci_id);\n\tif (ret)\n\t\tdev_err(dev, \"module-reset assert failed, ret = %d\\n\", ret);\n\n\treturn ret;\n}\n\n \nstatic int k3_dsp_rproc_start(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\tu32 boot_addr;\n\tint ret;\n\n\tret = k3_dsp_rproc_request_mbox(rproc);\n\tif (ret)\n\t\treturn ret;\n\n\tboot_addr = rproc->bootaddr;\n\tif (boot_addr & (kproc->data->boot_align_addr - 1)) {\n\t\tdev_err(dev, \"invalid boot address 0x%x, must be aligned on a 0x%x boundary\\n\",\n\t\t\tboot_addr, kproc->data->boot_align_addr);\n\t\tret = -EINVAL;\n\t\tgoto put_mbox;\n\t}\n\n\tdev_err(dev, \"booting DSP core using boot addr = 0x%x\\n\", boot_addr);\n\tret = ti_sci_proc_set_config(kproc->tsp, boot_addr, 0, 0);\n\tif (ret)\n\t\tgoto put_mbox;\n\n\tret = k3_dsp_rproc_release(kproc);\n\tif (ret)\n\t\tgoto put_mbox;\n\n\treturn 0;\n\nput_mbox:\n\tmbox_free_channel(kproc->mbox);\n\treturn ret;\n}\n\n \nstatic int k3_dsp_rproc_stop(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\n\tmbox_free_channel(kproc->mbox);\n\n\tk3_dsp_rproc_reset(kproc);\n\n\treturn 0;\n}\n\n \nstatic int k3_dsp_rproc_attach(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\tint ret;\n\n\tret = k3_dsp_rproc_request_mbox(rproc);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_info(dev, \"DSP initialized in IPC-only mode\\n\");\n\treturn 0;\n}\n\n \nstatic int k3_dsp_rproc_detach(struct rproc *rproc)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\n\tmbox_free_channel(kproc->mbox);\n\tdev_info(dev, \"DSP deinitialized in IPC-only mode\\n\");\n\treturn 0;\n}\n\n \nstatic struct resource_table *k3_dsp_get_loaded_rsc_table(struct rproc *rproc,\n\t\t\t\t\t\t\t  size_t *rsc_table_sz)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tstruct device *dev = kproc->dev;\n\n\tif (!kproc->rmem[0].cpu_addr) {\n\t\tdev_err(dev, \"memory-region #1 does not exist, loaded rsc table can't be found\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t \n\t*rsc_table_sz = 256;\n\treturn (struct resource_table *)kproc->rmem[0].cpu_addr;\n}\n\n \nstatic void *k3_dsp_rproc_da_to_va(struct rproc *rproc, u64 da, size_t len, bool *is_iomem)\n{\n\tstruct k3_dsp_rproc *kproc = rproc->priv;\n\tvoid __iomem *va = NULL;\n\tphys_addr_t bus_addr;\n\tu32 dev_addr, offset;\n\tsize_t size;\n\tint i;\n\n\tif (len == 0)\n\t\treturn NULL;\n\n\tfor (i = 0; i < kproc->num_mems; i++) {\n\t\tbus_addr = kproc->mem[i].bus_addr;\n\t\tdev_addr = kproc->mem[i].dev_addr;\n\t\tsize = kproc->mem[i].size;\n\n\t\tif (da < KEYSTONE_RPROC_LOCAL_ADDRESS_MASK) {\n\t\t\t \n\t\t\tif (da >= dev_addr &&\n\t\t\t    ((da + len) <= (dev_addr + size))) {\n\t\t\t\toffset = da - dev_addr;\n\t\t\t\tva = kproc->mem[i].cpu_addr + offset;\n\t\t\t\treturn (__force void *)va;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (da >= bus_addr &&\n\t\t\t    (da + len) <= (bus_addr + size)) {\n\t\t\t\toffset = da - bus_addr;\n\t\t\t\tva = kproc->mem[i].cpu_addr + offset;\n\t\t\t\treturn (__force void *)va;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < kproc->num_rmems; i++) {\n\t\tdev_addr = kproc->rmem[i].dev_addr;\n\t\tsize = kproc->rmem[i].size;\n\n\t\tif (da >= dev_addr && ((da + len) <= (dev_addr + size))) {\n\t\t\toffset = da - dev_addr;\n\t\t\tva = kproc->rmem[i].cpu_addr + offset;\n\t\t\treturn (__force void *)va;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct rproc_ops k3_dsp_rproc_ops = {\n\t.start\t\t= k3_dsp_rproc_start,\n\t.stop\t\t= k3_dsp_rproc_stop,\n\t.kick\t\t= k3_dsp_rproc_kick,\n\t.da_to_va\t= k3_dsp_rproc_da_to_va,\n};\n\nstatic int k3_dsp_rproc_of_get_memories(struct platform_device *pdev,\n\t\t\t\t\tstruct k3_dsp_rproc *kproc)\n{\n\tconst struct k3_dsp_dev_data *data = kproc->data;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint num_mems = 0;\n\tint i;\n\n\tnum_mems = kproc->data->num_mems;\n\tkproc->mem = devm_kcalloc(kproc->dev, num_mems,\n\t\t\t\t  sizeof(*kproc->mem), GFP_KERNEL);\n\tif (!kproc->mem)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_mems; i++) {\n\t\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM,\n\t\t\t\t\t\t   data->mems[i].name);\n\t\tif (!res) {\n\t\t\tdev_err(dev, \"found no memory resource for %s\\n\",\n\t\t\t\tdata->mems[i].name);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!devm_request_mem_region(dev, res->start,\n\t\t\t\t\t     resource_size(res),\n\t\t\t\t\t     dev_name(dev))) {\n\t\t\tdev_err(dev, \"could not request %s region for resource\\n\",\n\t\t\t\tdata->mems[i].name);\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tkproc->mem[i].cpu_addr = devm_ioremap_wc(dev, res->start,\n\t\t\t\t\t\t\t resource_size(res));\n\t\tif (!kproc->mem[i].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to map %s memory\\n\",\n\t\t\t\tdata->mems[i].name);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkproc->mem[i].bus_addr = res->start;\n\t\tkproc->mem[i].dev_addr = data->mems[i].dev_addr;\n\t\tkproc->mem[i].size = resource_size(res);\n\n\t\tdev_dbg(dev, \"memory %8s: bus addr %pa size 0x%zx va %pK da 0x%x\\n\",\n\t\t\tdata->mems[i].name, &kproc->mem[i].bus_addr,\n\t\t\tkproc->mem[i].size, kproc->mem[i].cpu_addr,\n\t\t\tkproc->mem[i].dev_addr);\n\t}\n\tkproc->num_mems = num_mems;\n\n\treturn 0;\n}\n\nstatic int k3_dsp_reserved_mem_init(struct k3_dsp_rproc *kproc)\n{\n\tstruct device *dev = kproc->dev;\n\tstruct device_node *np = dev->of_node;\n\tstruct device_node *rmem_np;\n\tstruct reserved_mem *rmem;\n\tint num_rmems;\n\tint ret, i;\n\n\tnum_rmems = of_property_count_elems_of_size(np, \"memory-region\",\n\t\t\t\t\t\t    sizeof(phandle));\n\tif (num_rmems <= 0) {\n\t\tdev_err(dev, \"device does not reserved memory regions, ret = %d\\n\",\n\t\t\tnum_rmems);\n\t\treturn -EINVAL;\n\t}\n\tif (num_rmems < 2) {\n\t\tdev_err(dev, \"device needs at least two memory regions to be defined, num = %d\\n\",\n\t\t\tnum_rmems);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = of_reserved_mem_device_init_by_idx(dev, np, 0);\n\tif (ret) {\n\t\tdev_err(dev, \"device cannot initialize DMA pool, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tnum_rmems--;\n\tkproc->rmem = kcalloc(num_rmems, sizeof(*kproc->rmem), GFP_KERNEL);\n\tif (!kproc->rmem) {\n\t\tret = -ENOMEM;\n\t\tgoto release_rmem;\n\t}\n\n\t \n\tfor (i = 0; i < num_rmems; i++) {\n\t\trmem_np = of_parse_phandle(np, \"memory-region\", i + 1);\n\t\tif (!rmem_np) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unmap_rmem;\n\t\t}\n\n\t\trmem = of_reserved_mem_lookup(rmem_np);\n\t\tif (!rmem) {\n\t\t\tof_node_put(rmem_np);\n\t\t\tret = -EINVAL;\n\t\t\tgoto unmap_rmem;\n\t\t}\n\t\tof_node_put(rmem_np);\n\n\t\tkproc->rmem[i].bus_addr = rmem->base;\n\t\t \n\t\tkproc->rmem[i].dev_addr = (u32)rmem->base;\n\t\tkproc->rmem[i].size = rmem->size;\n\t\tkproc->rmem[i].cpu_addr = ioremap_wc(rmem->base, rmem->size);\n\t\tif (!kproc->rmem[i].cpu_addr) {\n\t\t\tdev_err(dev, \"failed to map reserved memory#%d at %pa of size %pa\\n\",\n\t\t\t\ti + 1, &rmem->base, &rmem->size);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto unmap_rmem;\n\t\t}\n\n\t\tdev_dbg(dev, \"reserved memory%d: bus addr %pa size 0x%zx va %pK da 0x%x\\n\",\n\t\t\ti + 1, &kproc->rmem[i].bus_addr,\n\t\t\tkproc->rmem[i].size, kproc->rmem[i].cpu_addr,\n\t\t\tkproc->rmem[i].dev_addr);\n\t}\n\tkproc->num_rmems = num_rmems;\n\n\treturn 0;\n\nunmap_rmem:\n\tfor (i--; i >= 0; i--)\n\t\tiounmap(kproc->rmem[i].cpu_addr);\n\tkfree(kproc->rmem);\nrelease_rmem:\n\tof_reserved_mem_device_release(kproc->dev);\n\treturn ret;\n}\n\nstatic void k3_dsp_reserved_mem_exit(struct k3_dsp_rproc *kproc)\n{\n\tint i;\n\n\tfor (i = 0; i < kproc->num_rmems; i++)\n\t\tiounmap(kproc->rmem[i].cpu_addr);\n\tkfree(kproc->rmem);\n\n\tof_reserved_mem_device_release(kproc->dev);\n}\n\nstatic\nstruct ti_sci_proc *k3_dsp_rproc_of_get_tsp(struct device *dev,\n\t\t\t\t\t    const struct ti_sci_handle *sci)\n{\n\tstruct ti_sci_proc *tsp;\n\tu32 temp[2];\n\tint ret;\n\n\tret = of_property_read_u32_array(dev->of_node, \"ti,sci-proc-ids\",\n\t\t\t\t\t temp, 2);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\ttsp = kzalloc(sizeof(*tsp), GFP_KERNEL);\n\tif (!tsp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttsp->dev = dev;\n\ttsp->sci = sci;\n\ttsp->ops = &sci->ops.proc_ops;\n\ttsp->proc_id = temp[0];\n\ttsp->host_id = temp[1];\n\n\treturn tsp;\n}\n\nstatic int k3_dsp_rproc_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct k3_dsp_dev_data *data;\n\tstruct k3_dsp_rproc *kproc;\n\tstruct rproc *rproc;\n\tconst char *fw_name;\n\tbool p_state = false;\n\tint ret = 0;\n\tint ret1;\n\n\tdata = of_device_get_match_data(dev);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tret = rproc_of_parse_firmware(dev, 0, &fw_name);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse firmware-name property, ret = %d\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\trproc = rproc_alloc(dev, dev_name(dev), &k3_dsp_rproc_ops, fw_name,\n\t\t\t    sizeof(*kproc));\n\tif (!rproc)\n\t\treturn -ENOMEM;\n\n\trproc->has_iommu = false;\n\trproc->recovery_disabled = true;\n\tif (data->uses_lreset) {\n\t\trproc->ops->prepare = k3_dsp_rproc_prepare;\n\t\trproc->ops->unprepare = k3_dsp_rproc_unprepare;\n\t}\n\tkproc = rproc->priv;\n\tkproc->rproc = rproc;\n\tkproc->dev = dev;\n\tkproc->data = data;\n\n\tkproc->ti_sci = ti_sci_get_by_phandle(np, \"ti,sci\");\n\tif (IS_ERR(kproc->ti_sci)) {\n\t\tret = PTR_ERR(kproc->ti_sci);\n\t\tif (ret != -EPROBE_DEFER) {\n\t\t\tdev_err(dev, \"failed to get ti-sci handle, ret = %d\\n\",\n\t\t\t\tret);\n\t\t}\n\t\tkproc->ti_sci = NULL;\n\t\tgoto free_rproc;\n\t}\n\n\tret = of_property_read_u32(np, \"ti,sci-dev-id\", &kproc->ti_sci_id);\n\tif (ret) {\n\t\tdev_err(dev, \"missing 'ti,sci-dev-id' property\\n\");\n\t\tgoto put_sci;\n\t}\n\n\tkproc->reset = devm_reset_control_get_exclusive(dev, NULL);\n\tif (IS_ERR(kproc->reset)) {\n\t\tret = PTR_ERR(kproc->reset);\n\t\tdev_err(dev, \"failed to get reset, status = %d\\n\", ret);\n\t\tgoto put_sci;\n\t}\n\n\tkproc->tsp = k3_dsp_rproc_of_get_tsp(dev, kproc->ti_sci);\n\tif (IS_ERR(kproc->tsp)) {\n\t\tdev_err(dev, \"failed to construct ti-sci proc control, ret = %d\\n\",\n\t\t\tret);\n\t\tret = PTR_ERR(kproc->tsp);\n\t\tgoto put_sci;\n\t}\n\n\tret = ti_sci_proc_request(kproc->tsp);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"ti_sci_proc_request failed, ret = %d\\n\", ret);\n\t\tgoto free_tsp;\n\t}\n\n\tret = k3_dsp_rproc_of_get_memories(pdev, kproc);\n\tif (ret)\n\t\tgoto release_tsp;\n\n\tret = k3_dsp_reserved_mem_init(kproc);\n\tif (ret) {\n\t\tdev_err(dev, \"reserved memory init failed, ret = %d\\n\", ret);\n\t\tgoto release_tsp;\n\t}\n\n\tret = kproc->ti_sci->ops.dev_ops.is_on(kproc->ti_sci, kproc->ti_sci_id,\n\t\t\t\t\t       NULL, &p_state);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to get initial state, mode cannot be determined, ret = %d\\n\",\n\t\t\tret);\n\t\tgoto release_mem;\n\t}\n\n\t \n\tif (p_state) {\n\t\tdev_info(dev, \"configured DSP for IPC-only mode\\n\");\n\t\trproc->state = RPROC_DETACHED;\n\t\t \n\t\trproc->ops->prepare = NULL;\n\t\trproc->ops->unprepare = NULL;\n\t\trproc->ops->start = NULL;\n\t\trproc->ops->stop = NULL;\n\t\trproc->ops->attach = k3_dsp_rproc_attach;\n\t\trproc->ops->detach = k3_dsp_rproc_detach;\n\t\trproc->ops->get_loaded_rsc_table = k3_dsp_get_loaded_rsc_table;\n\t} else {\n\t\tdev_info(dev, \"configured DSP for remoteproc mode\\n\");\n\t\t \n\t\tif (data->uses_lreset) {\n\t\t\tret = reset_control_status(kproc->reset);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_err(dev, \"failed to get reset status, status = %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto release_mem;\n\t\t\t} else if (ret == 0) {\n\t\t\t\tdev_warn(dev, \"local reset is deasserted for device\\n\");\n\t\t\t\tk3_dsp_rproc_reset(kproc);\n\t\t\t}\n\t\t}\n\t}\n\n\tret = rproc_add(rproc);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add register device with remoteproc core, status = %d\\n\",\n\t\t\tret);\n\t\tgoto release_mem;\n\t}\n\n\tplatform_set_drvdata(pdev, kproc);\n\n\treturn 0;\n\nrelease_mem:\n\tk3_dsp_reserved_mem_exit(kproc);\nrelease_tsp:\n\tret1 = ti_sci_proc_release(kproc->tsp);\n\tif (ret1)\n\t\tdev_err(dev, \"failed to release proc, ret = %d\\n\", ret1);\nfree_tsp:\n\tkfree(kproc->tsp);\nput_sci:\n\tret1 = ti_sci_put_handle(kproc->ti_sci);\n\tif (ret1)\n\t\tdev_err(dev, \"failed to put ti_sci handle, ret = %d\\n\", ret1);\nfree_rproc:\n\trproc_free(rproc);\n\treturn ret;\n}\n\nstatic int k3_dsp_rproc_remove(struct platform_device *pdev)\n{\n\tstruct k3_dsp_rproc *kproc = platform_get_drvdata(pdev);\n\tstruct rproc *rproc = kproc->rproc;\n\tstruct device *dev = &pdev->dev;\n\tint ret;\n\n\tif (rproc->state == RPROC_ATTACHED) {\n\t\tret = rproc_detach(rproc);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to detach proc, ret = %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\trproc_del(kproc->rproc);\n\n\tret = ti_sci_proc_release(kproc->tsp);\n\tif (ret)\n\t\tdev_err(dev, \"failed to release proc, ret = %d\\n\", ret);\n\n\tkfree(kproc->tsp);\n\n\tret = ti_sci_put_handle(kproc->ti_sci);\n\tif (ret)\n\t\tdev_err(dev, \"failed to put ti_sci handle, ret = %d\\n\", ret);\n\n\tk3_dsp_reserved_mem_exit(kproc);\n\trproc_free(kproc->rproc);\n\n\treturn 0;\n}\n\nstatic const struct k3_dsp_mem_data c66_mems[] = {\n\t{ .name = \"l2sram\", .dev_addr = 0x800000 },\n\t{ .name = \"l1pram\", .dev_addr = 0xe00000 },\n\t{ .name = \"l1dram\", .dev_addr = 0xf00000 },\n};\n\n \nstatic const struct k3_dsp_mem_data c71_mems[] = {\n\t{ .name = \"l2sram\", .dev_addr = 0x800000 },\n\t{ .name = \"l1dram\", .dev_addr = 0xe00000 },\n};\n\nstatic const struct k3_dsp_mem_data c7xv_mems[] = {\n\t{ .name = \"l2sram\", .dev_addr = 0x800000 },\n};\n\nstatic const struct k3_dsp_dev_data c66_data = {\n\t.mems = c66_mems,\n\t.num_mems = ARRAY_SIZE(c66_mems),\n\t.boot_align_addr = SZ_1K,\n\t.uses_lreset = true,\n};\n\nstatic const struct k3_dsp_dev_data c71_data = {\n\t.mems = c71_mems,\n\t.num_mems = ARRAY_SIZE(c71_mems),\n\t.boot_align_addr = SZ_2M,\n\t.uses_lreset = false,\n};\n\nstatic const struct k3_dsp_dev_data c7xv_data = {\n\t.mems = c7xv_mems,\n\t.num_mems = ARRAY_SIZE(c7xv_mems),\n\t.boot_align_addr = SZ_2M,\n\t.uses_lreset = false,\n};\n\nstatic const struct of_device_id k3_dsp_of_match[] = {\n\t{ .compatible = \"ti,j721e-c66-dsp\", .data = &c66_data, },\n\t{ .compatible = \"ti,j721e-c71-dsp\", .data = &c71_data, },\n\t{ .compatible = \"ti,j721s2-c71-dsp\", .data = &c71_data, },\n\t{ .compatible = \"ti,am62a-c7xv-dsp\", .data = &c7xv_data, },\n\t{   },\n};\nMODULE_DEVICE_TABLE(of, k3_dsp_of_match);\n\nstatic struct platform_driver k3_dsp_rproc_driver = {\n\t.probe\t= k3_dsp_rproc_probe,\n\t.remove\t= k3_dsp_rproc_remove,\n\t.driver\t= {\n\t\t.name = \"k3-dsp-rproc\",\n\t\t.of_match_table = k3_dsp_of_match,\n\t},\n};\n\nmodule_platform_driver(k3_dsp_rproc_driver);\n\nMODULE_AUTHOR(\"Suman Anna <s-anna@ti.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI K3 DSP Remoteproc driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}