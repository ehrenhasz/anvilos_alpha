{
  "module_name": "tc.c",
  "hash_id": "71778b902105793b3374d83862292f162259a935a578b925d61796b161facfc1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/tc/tc.c",
  "human_readable_source": " \n#include <linux/compiler.h>\n#include <linux/dma-mapping.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/tc.h>\n#include <linux/types.h>\n\n#include <asm/io.h>\n\nstatic struct tc_bus tc_bus = {\n\t.name = \"TURBOchannel\",\n};\n\n \nstatic void __init tc_bus_add_devices(struct tc_bus *tbus)\n{\n\tresource_size_t slotsize = tbus->info.slot_size << 20;\n\tresource_size_t extslotsize = tbus->ext_slot_size;\n\tresource_size_t slotaddr;\n\tresource_size_t extslotaddr;\n\tresource_size_t devsize;\n\tvoid __iomem *module;\n\tstruct tc_dev *tdev;\n\tint i, slot, err;\n\tu8 pattern[4];\n\tlong offset;\n\n\tfor (slot = 0; slot < tbus->num_tcslots; slot++) {\n\t\tslotaddr = tbus->slot_base + slot * slotsize;\n\t\textslotaddr = tbus->ext_slot_base + slot * extslotsize;\n\t\tmodule = ioremap(slotaddr, slotsize);\n\t\tBUG_ON(!module);\n\n\t\toffset = TC_OLDCARD;\n\n\t\terr = 0;\n\t\terr |= tc_preadb(pattern + 0, module + offset + TC_PATTERN0);\n\t\terr |= tc_preadb(pattern + 1, module + offset + TC_PATTERN1);\n\t\terr |= tc_preadb(pattern + 2, module + offset + TC_PATTERN2);\n\t\terr |= tc_preadb(pattern + 3, module + offset + TC_PATTERN3);\n\t\tif (err)\n\t\t\tgoto out_err;\n\n\t\tif (pattern[0] != 0x55 || pattern[1] != 0x00 ||\n\t\t    pattern[2] != 0xaa || pattern[3] != 0xff) {\n\t\t\toffset = TC_NEWCARD;\n\n\t\t\terr = 0;\n\t\t\terr |= tc_preadb(pattern + 0,\n\t\t\t\t\t module + offset + TC_PATTERN0);\n\t\t\terr |= tc_preadb(pattern + 1,\n\t\t\t\t\t module + offset + TC_PATTERN1);\n\t\t\terr |= tc_preadb(pattern + 2,\n\t\t\t\t\t module + offset + TC_PATTERN2);\n\t\t\terr |= tc_preadb(pattern + 3,\n\t\t\t\t\t module + offset + TC_PATTERN3);\n\t\t\tif (err)\n\t\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (pattern[0] != 0x55 || pattern[1] != 0x00 ||\n\t\t    pattern[2] != 0xaa || pattern[3] != 0xff)\n\t\t\tgoto out_err;\n\n\t\t \n\t\ttdev = kzalloc(sizeof(*tdev), GFP_KERNEL);\n\t\tif (!tdev) {\n\t\t\tpr_err(\"tc%x: unable to allocate tc_dev\\n\", slot);\n\t\t\tgoto out_err;\n\t\t}\n\t\tdev_set_name(&tdev->dev, \"tc%x\", slot);\n\t\ttdev->bus = tbus;\n\t\ttdev->dev.parent = &tbus->dev;\n\t\ttdev->dev.bus = &tc_bus_type;\n\t\ttdev->slot = slot;\n\n\t\t \n\t\ttdev->dma_mask = DMA_BIT_MASK(34);\n\t\ttdev->dev.dma_mask = &tdev->dma_mask;\n\t\ttdev->dev.coherent_dma_mask = DMA_BIT_MASK(34);\n\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\ttdev->firmware[i] =\n\t\t\t\treadb(module + offset + TC_FIRM_VER + 4 * i);\n\t\t\ttdev->vendor[i] =\n\t\t\t\treadb(module + offset + TC_VENDOR + 4 * i);\n\t\t\ttdev->name[i] =\n\t\t\t\treadb(module + offset + TC_MODULE + 4 * i);\n\t\t}\n\t\ttdev->firmware[8] = 0;\n\t\ttdev->vendor[8] = 0;\n\t\ttdev->name[8] = 0;\n\n\t\tpr_info(\"%s: %s %s %s\\n\", dev_name(&tdev->dev), tdev->vendor,\n\t\t\ttdev->name, tdev->firmware);\n\n\t\tdevsize = readb(module + offset + TC_SLOT_SIZE);\n\t\tdevsize <<= 22;\n\t\tif (devsize <= slotsize) {\n\t\t\ttdev->resource.start = slotaddr;\n\t\t\ttdev->resource.end = slotaddr + devsize - 1;\n\t\t} else if (devsize <= extslotsize) {\n\t\t\ttdev->resource.start = extslotaddr;\n\t\t\ttdev->resource.end = extslotaddr + devsize - 1;\n\t\t} else {\n\t\t\tpr_err(\"%s: Cannot provide slot space \"\n\t\t\t       \"(%ldMiB required, up to %ldMiB supported)\\n\",\n\t\t\t       dev_name(&tdev->dev), (long)(devsize >> 20),\n\t\t\t       (long)(max(slotsize, extslotsize) >> 20));\n\t\t\tkfree(tdev);\n\t\t\tgoto out_err;\n\t\t}\n\t\ttdev->resource.name = tdev->name;\n\t\ttdev->resource.flags = IORESOURCE_MEM;\n\n\t\ttc_device_get_irq(tdev);\n\n\t\tif (device_register(&tdev->dev)) {\n\t\t\tput_device(&tdev->dev);\n\t\t\tgoto out_err;\n\t\t}\n\t\tlist_add_tail(&tdev->node, &tbus->devices);\n\nout_err:\n\t\tiounmap(module);\n\t}\n}\n\n \nstatic int __init tc_init(void)\n{\n\t \n\tif (tc_bus_get_info(&tc_bus))\n\t\tgoto out_err;\n\n\tINIT_LIST_HEAD(&tc_bus.devices);\n\tdev_set_name(&tc_bus.dev, \"tc\");\n\tif (device_register(&tc_bus.dev))\n\t\tgoto out_err_device;\n\n\tif (tc_bus.info.slot_size) {\n\t\tunsigned int tc_clock = tc_get_speed(&tc_bus) / 100000;\n\n\t\tpr_info(\"tc: TURBOchannel rev. %d at %d.%d MHz \"\n\t\t\t\"(with%s parity)\\n\", tc_bus.info.revision,\n\t\t\ttc_clock / 10, tc_clock % 10,\n\t\t\ttc_bus.info.parity ? \"\" : \"out\");\n\n\t\ttc_bus.resource[0].start = tc_bus.slot_base;\n\t\ttc_bus.resource[0].end = tc_bus.slot_base +\n\t\t\t\t\t (tc_bus.info.slot_size << 20) *\n\t\t\t\t\t tc_bus.num_tcslots - 1;\n\t\ttc_bus.resource[0].name = tc_bus.name;\n\t\ttc_bus.resource[0].flags = IORESOURCE_MEM;\n\t\tif (request_resource(&iomem_resource,\n\t\t\t\t     &tc_bus.resource[0]) < 0) {\n\t\t\tpr_err(\"tc: Cannot reserve resource\\n\");\n\t\t\tgoto out_err_device;\n\t\t}\n\t\tif (tc_bus.ext_slot_size) {\n\t\t\ttc_bus.resource[1].start = tc_bus.ext_slot_base;\n\t\t\ttc_bus.resource[1].end = tc_bus.ext_slot_base +\n\t\t\t\t\t\t tc_bus.ext_slot_size *\n\t\t\t\t\t\t tc_bus.num_tcslots - 1;\n\t\t\ttc_bus.resource[1].name = tc_bus.name;\n\t\t\ttc_bus.resource[1].flags = IORESOURCE_MEM;\n\t\t\tif (request_resource(&iomem_resource,\n\t\t\t\t\t     &tc_bus.resource[1]) < 0) {\n\t\t\t\tpr_err(\"tc: Cannot reserve resource\\n\");\n\t\t\t\tgoto out_err_resource;\n\t\t\t}\n\t\t}\n\n\t\ttc_bus_add_devices(&tc_bus);\n\t}\n\n\treturn 0;\n\nout_err_resource:\n\trelease_resource(&tc_bus.resource[0]);\nout_err_device:\n\tput_device(&tc_bus.dev);\nout_err:\n\treturn 0;\n}\n\nsubsys_initcall(tc_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}