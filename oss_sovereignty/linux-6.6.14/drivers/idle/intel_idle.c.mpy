{
  "module_name": "intel_idle.c",
  "hash_id": "72f2a2ae57075b91839dabda4892afedf01dbb53e4cc76bc2de84634008d00d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/idle/intel_idle.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/acpi.h>\n#include <linux/kernel.h>\n#include <linux/cpuidle.h>\n#include <linux/tick.h>\n#include <trace/events/power.h>\n#include <linux/sched.h>\n#include <linux/sched/smt.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/moduleparam.h>\n#include <asm/cpu_device_id.h>\n#include <asm/intel-family.h>\n#include <asm/nospec-branch.h>\n#include <asm/mwait.h>\n#include <asm/msr.h>\n#include <asm/fpu/api.h>\n\n#define INTEL_IDLE_VERSION \"0.5.1\"\n\nstatic struct cpuidle_driver intel_idle_driver = {\n\t.name = \"intel_idle\",\n\t.owner = THIS_MODULE,\n};\n \nstatic int max_cstate = CPUIDLE_STATE_MAX - 1;\nstatic unsigned int disabled_states_mask __read_mostly;\nstatic unsigned int preferred_states_mask __read_mostly;\nstatic bool force_irq_on __read_mostly;\n\nstatic struct cpuidle_device __percpu *intel_idle_cpuidle_devices;\n\nstatic unsigned long auto_demotion_disable_flags;\n\nstatic enum {\n\tC1E_PROMOTION_PRESERVE,\n\tC1E_PROMOTION_ENABLE,\n\tC1E_PROMOTION_DISABLE\n} c1e_promotion = C1E_PROMOTION_PRESERVE;\n\nstruct idle_cpu {\n\tstruct cpuidle_state *state_table;\n\n\t \n\tunsigned long auto_demotion_disable_flags;\n\tbool byt_auto_demotion_disable_flag;\n\tbool disable_promotion_to_c1e;\n\tbool use_acpi;\n};\n\nstatic const struct idle_cpu *icpu __initdata;\nstatic struct cpuidle_state *cpuidle_state_table __initdata;\n\nstatic unsigned int mwait_substates __initdata;\n\n \n#define CPUIDLE_FLAG_IRQ_ENABLE\t\tBIT(14)\n\n \n#define CPUIDLE_FLAG_ALWAYS_ENABLE\tBIT(15)\n\n \n#define CPUIDLE_FLAG_IBRS\t\tBIT(16)\n\n \n#define CPUIDLE_FLAG_INIT_XSTATE\tBIT(17)\n\n \n#define flg2MWAIT(flags) (((flags) >> 24) & 0xFF)\n#define MWAIT2flg(eax) ((eax & 0xFF) << 24)\n\nstatic __always_inline int __intel_idle(struct cpuidle_device *dev,\n\t\t\t\t\tstruct cpuidle_driver *drv,\n\t\t\t\t\tint index, bool irqoff)\n{\n\tstruct cpuidle_state *state = &drv->states[index];\n\tunsigned long eax = flg2MWAIT(state->flags);\n\tunsigned long ecx = 1*irqoff;  \n\n\tmwait_idle_with_hints(eax, ecx);\n\n\treturn index;\n}\n\n \nstatic __cpuidle int intel_idle(struct cpuidle_device *dev,\n\t\t\t\tstruct cpuidle_driver *drv, int index)\n{\n\treturn __intel_idle(dev, drv, index, true);\n}\n\nstatic __cpuidle int intel_idle_irq(struct cpuidle_device *dev,\n\t\t\t\t    struct cpuidle_driver *drv, int index)\n{\n\treturn __intel_idle(dev, drv, index, false);\n}\n\nstatic __cpuidle int intel_idle_ibrs(struct cpuidle_device *dev,\n\t\t\t\t     struct cpuidle_driver *drv, int index)\n{\n\tbool smt_active = sched_smt_active();\n\tu64 spec_ctrl = spec_ctrl_current();\n\tint ret;\n\n\tif (smt_active)\n\t\tnative_wrmsrl(MSR_IA32_SPEC_CTRL, 0);\n\n\tret = __intel_idle(dev, drv, index, true);\n\n\tif (smt_active)\n\t\tnative_wrmsrl(MSR_IA32_SPEC_CTRL, spec_ctrl);\n\n\treturn ret;\n}\n\nstatic __cpuidle int intel_idle_xstate(struct cpuidle_device *dev,\n\t\t\t\t       struct cpuidle_driver *drv, int index)\n{\n\tfpu_idle_fpregs();\n\treturn __intel_idle(dev, drv, index, true);\n}\n\n \nstatic __cpuidle int intel_idle_s2idle(struct cpuidle_device *dev,\n\t\t\t\t       struct cpuidle_driver *drv, int index)\n{\n\tunsigned long ecx = 1;  \n\tstruct cpuidle_state *state = &drv->states[index];\n\tunsigned long eax = flg2MWAIT(state->flags);\n\n\tif (state->flags & CPUIDLE_FLAG_INIT_XSTATE)\n\t\tfpu_idle_fpregs();\n\n\tmwait_idle_with_hints(eax, ecx);\n\n\treturn 0;\n}\n\n \nstatic struct cpuidle_state nehalem_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 3,\n\t\t.target_residency = 6,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 20,\n\t\t.target_residency = 80,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 200,\n\t\t.target_residency = 800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state snb_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 80,\n\t\t.target_residency = 211,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 104,\n\t\t.target_residency = 345,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7\",\n\t\t.desc = \"MWAIT 0x30\",\n\t\t.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 109,\n\t\t.target_residency = 345,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state byt_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6N\",\n\t\t.desc = \"MWAIT 0x58\",\n\t\t.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 300,\n\t\t.target_residency = 275,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6S\",\n\t\t.desc = \"MWAIT 0x52\",\n\t\t.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 500,\n\t\t.target_residency = 560,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 1200,\n\t\t.target_residency = 4000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7S\",\n\t\t.desc = \"MWAIT 0x64\",\n\t\t.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 10000,\n\t\t.target_residency = 20000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state cht_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6N\",\n\t\t.desc = \"MWAIT 0x58\",\n\t\t.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 80,\n\t\t.target_residency = 275,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6S\",\n\t\t.desc = \"MWAIT 0x52\",\n\t\t.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 200,\n\t\t.target_residency = 560,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 1200,\n\t\t.target_residency = 4000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7S\",\n\t\t.desc = \"MWAIT 0x64\",\n\t\t.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 10000,\n\t\t.target_residency = 20000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state ivb_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 59,\n\t\t.target_residency = 156,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 80,\n\t\t.target_residency = 300,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7\",\n\t\t.desc = \"MWAIT 0x30\",\n\t\t.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 87,\n\t\t.target_residency = 300,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state ivt_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 80,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 59,\n\t\t.target_residency = 156,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 82,\n\t\t.target_residency = 300,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state ivt_cstates_4s[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 250,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 59,\n\t\t.target_residency = 300,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 84,\n\t\t.target_residency = 400,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state ivt_cstates_8s[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 59,\n\t\t.target_residency = 600,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 88,\n\t\t.target_residency = 700,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state hsw_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 33,\n\t\t.target_residency = 100,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 133,\n\t\t.target_residency = 400,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7s\",\n\t\t.desc = \"MWAIT 0x32\",\n\t\t.flags = MWAIT2flg(0x32) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 166,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 300,\n\t\t.target_residency = 900,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C9\",\n\t\t.desc = \"MWAIT 0x50\",\n\t\t.flags = MWAIT2flg(0x50) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 600,\n\t\t.target_residency = 1800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 2600,\n\t\t.target_residency = 7700,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\nstatic struct cpuidle_state bdw_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 40,\n\t\t.target_residency = 100,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 133,\n\t\t.target_residency = 400,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7s\",\n\t\t.desc = \"MWAIT 0x32\",\n\t\t.flags = MWAIT2flg(0x32) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 166,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 300,\n\t\t.target_residency = 900,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C9\",\n\t\t.desc = \"MWAIT 0x50\",\n\t\t.flags = MWAIT2flg(0x50) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 600,\n\t\t.target_residency = 1800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 2600,\n\t\t.target_residency = 7700,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state skl_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C3\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 70,\n\t\t.target_residency = 100,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 85,\n\t\t.target_residency = 200,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7s\",\n\t\t.desc = \"MWAIT 0x33\",\n\t\t.flags = MWAIT2flg(0x33) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 124,\n\t\t.target_residency = 800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 200,\n\t\t.target_residency = 800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C9\",\n\t\t.desc = \"MWAIT 0x50\",\n\t\t.flags = MWAIT2flg(0x50) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 480,\n\t\t.target_residency = 5000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 890,\n\t\t.target_residency = 5000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state skx_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_IRQ_ENABLE,\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_IBRS,\n\t\t.exit_latency = 133,\n\t\t.target_residency = 600,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state icx_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_IRQ_ENABLE,\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 4,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 170,\n\t\t.target_residency = 600,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\n \nstatic struct cpuidle_state adl_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_UNUSABLE,\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 2,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 220,\n\t\t.target_residency = 600,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 280,\n\t\t.target_residency = 800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 680,\n\t\t.target_residency = 2000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state adl_l_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_UNUSABLE,\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 2,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 170,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 200,\n\t\t.target_residency = 600,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 230,\n\t\t.target_residency = 700,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state gmt_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00) | CPUIDLE_FLAG_UNUSABLE,\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 2,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 195,\n\t\t.target_residency = 585,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 260,\n\t\t.target_residency = 1040,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 660,\n\t\t.target_residency = 1980,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state spr_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 1,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 2,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED |\n\t\t\t\t\t   CPUIDLE_FLAG_INIT_XSTATE,\n\t\t.exit_latency = 290,\n\t\t.target_residency = 800,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state atom_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C2\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10),\n\t\t.exit_latency = 20,\n\t\t.target_residency = 80,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C4\",\n\t\t.desc = \"MWAIT 0x30\",\n\t\t.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 100,\n\t\t.target_residency = 400,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x52\",\n\t\t.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 140,\n\t\t.target_residency = 560,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\nstatic struct cpuidle_state tangier_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 4,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C4\",\n\t\t.desc = \"MWAIT 0x30\",\n\t\t.flags = MWAIT2flg(0x30) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 100,\n\t\t.target_residency = 400,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x52\",\n\t\t.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 140,\n\t\t.target_residency = 560,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 1200,\n\t\t.target_residency = 4000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C9\",\n\t\t.desc = \"MWAIT 0x64\",\n\t\t.flags = MWAIT2flg(0x64) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 10000,\n\t\t.target_residency = 20000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\nstatic struct cpuidle_state avn_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x51\",\n\t\t.flags = MWAIT2flg(0x51) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 15,\n\t\t.target_residency = 45,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\nstatic struct cpuidle_state knl_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 1,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x10\",\n\t\t.flags = MWAIT2flg(0x10) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 120,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state bxt_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 133,\n\t\t.target_residency = 133,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C7s\",\n\t\t.desc = \"MWAIT 0x31\",\n\t\t.flags = MWAIT2flg(0x31) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 155,\n\t\t.target_residency = 155,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C8\",\n\t\t.desc = \"MWAIT 0x40\",\n\t\t.flags = MWAIT2flg(0x40) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 1000,\n\t\t.target_residency = 1000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C9\",\n\t\t.desc = \"MWAIT 0x50\",\n\t\t.flags = MWAIT2flg(0x50) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 2000,\n\t\t.target_residency = 2000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C10\",\n\t\t.desc = \"MWAIT 0x60\",\n\t\t.flags = MWAIT2flg(0x60) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 10000,\n\t\t.target_residency = 10000,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic struct cpuidle_state dnv_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 10,\n\t\t.target_residency = 20,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 50,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\n \nstatic struct cpuidle_state snr_cstates[] __initdata = {\n\t{\n\t\t.name = \"C1\",\n\t\t.desc = \"MWAIT 0x00\",\n\t\t.flags = MWAIT2flg(0x00),\n\t\t.exit_latency = 2,\n\t\t.target_residency = 2,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C1E\",\n\t\t.desc = \"MWAIT 0x01\",\n\t\t.flags = MWAIT2flg(0x01) | CPUIDLE_FLAG_ALWAYS_ENABLE,\n\t\t.exit_latency = 15,\n\t\t.target_residency = 25,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.name = \"C6\",\n\t\t.desc = \"MWAIT 0x20\",\n\t\t.flags = MWAIT2flg(0x20) | CPUIDLE_FLAG_TLB_FLUSHED,\n\t\t.exit_latency = 130,\n\t\t.target_residency = 500,\n\t\t.enter = &intel_idle,\n\t\t.enter_s2idle = intel_idle_s2idle, },\n\t{\n\t\t.enter = NULL }\n};\n\nstatic const struct idle_cpu idle_cpu_nehalem __initconst = {\n\t.state_table = nehalem_cstates,\n\t.auto_demotion_disable_flags = NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_nhx __initconst = {\n\t.state_table = nehalem_cstates,\n\t.auto_demotion_disable_flags = NHM_C1_AUTO_DEMOTE | NHM_C3_AUTO_DEMOTE,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_atom __initconst = {\n\t.state_table = atom_cstates,\n};\n\nstatic const struct idle_cpu idle_cpu_tangier __initconst = {\n\t.state_table = tangier_cstates,\n};\n\nstatic const struct idle_cpu idle_cpu_lincroft __initconst = {\n\t.state_table = atom_cstates,\n\t.auto_demotion_disable_flags = ATM_LNC_C6_AUTO_DEMOTE,\n};\n\nstatic const struct idle_cpu idle_cpu_snb __initconst = {\n\t.state_table = snb_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_snx __initconst = {\n\t.state_table = snb_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_byt __initconst = {\n\t.state_table = byt_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.byt_auto_demotion_disable_flag = true,\n};\n\nstatic const struct idle_cpu idle_cpu_cht __initconst = {\n\t.state_table = cht_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.byt_auto_demotion_disable_flag = true,\n};\n\nstatic const struct idle_cpu idle_cpu_ivb __initconst = {\n\t.state_table = ivb_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_ivt __initconst = {\n\t.state_table = ivt_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_hsw __initconst = {\n\t.state_table = hsw_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_hsx __initconst = {\n\t.state_table = hsw_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_bdw __initconst = {\n\t.state_table = bdw_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_bdx __initconst = {\n\t.state_table = bdw_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_skl __initconst = {\n\t.state_table = skl_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_skx __initconst = {\n\t.state_table = skx_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_icx __initconst = {\n\t.state_table = icx_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_adl __initconst = {\n\t.state_table = adl_cstates,\n};\n\nstatic const struct idle_cpu idle_cpu_adl_l __initconst = {\n\t.state_table = adl_l_cstates,\n};\n\nstatic const struct idle_cpu idle_cpu_gmt __initconst = {\n\t.state_table = gmt_cstates,\n};\n\nstatic const struct idle_cpu idle_cpu_spr __initconst = {\n\t.state_table = spr_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_avn __initconst = {\n\t.state_table = avn_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_knl __initconst = {\n\t.state_table = knl_cstates,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_bxt __initconst = {\n\t.state_table = bxt_cstates,\n\t.disable_promotion_to_c1e = true,\n};\n\nstatic const struct idle_cpu idle_cpu_dnv __initconst = {\n\t.state_table = dnv_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct idle_cpu idle_cpu_snr __initconst = {\n\t.state_table = snr_cstates,\n\t.disable_promotion_to_c1e = true,\n\t.use_acpi = true,\n};\n\nstatic const struct x86_cpu_id intel_idle_ids[] __initconst = {\n\tX86_MATCH_INTEL_FAM6_MODEL(NEHALEM_EP,\t\t&idle_cpu_nhx),\n\tX86_MATCH_INTEL_FAM6_MODEL(NEHALEM,\t\t&idle_cpu_nehalem),\n\tX86_MATCH_INTEL_FAM6_MODEL(NEHALEM_G,\t\t&idle_cpu_nehalem),\n\tX86_MATCH_INTEL_FAM6_MODEL(WESTMERE,\t\t&idle_cpu_nehalem),\n\tX86_MATCH_INTEL_FAM6_MODEL(WESTMERE_EP,\t\t&idle_cpu_nhx),\n\tX86_MATCH_INTEL_FAM6_MODEL(NEHALEM_EX,\t\t&idle_cpu_nhx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_BONNELL,\t&idle_cpu_atom),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_BONNELL_MID,\t&idle_cpu_lincroft),\n\tX86_MATCH_INTEL_FAM6_MODEL(WESTMERE_EX,\t\t&idle_cpu_nhx),\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE,\t\t&idle_cpu_snb),\n\tX86_MATCH_INTEL_FAM6_MODEL(SANDYBRIDGE_X,\t&idle_cpu_snx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SALTWELL,\t&idle_cpu_atom),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT,\t&idle_cpu_byt),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_MID,\t&idle_cpu_tangier),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_AIRMONT,\t&idle_cpu_cht),\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE,\t\t&idle_cpu_ivb),\n\tX86_MATCH_INTEL_FAM6_MODEL(IVYBRIDGE_X,\t\t&idle_cpu_ivt),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL,\t\t&idle_cpu_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_X,\t\t&idle_cpu_hsx),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_L,\t\t&idle_cpu_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(HASWELL_G,\t\t&idle_cpu_hsw),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_SILVERMONT_D,\t&idle_cpu_avn),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL,\t\t&idle_cpu_bdw),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_G,\t\t&idle_cpu_bdw),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_X,\t\t&idle_cpu_bdx),\n\tX86_MATCH_INTEL_FAM6_MODEL(BROADWELL_D,\t\t&idle_cpu_bdx),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_L,\t\t&idle_cpu_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE,\t\t&idle_cpu_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE_L,\t\t&idle_cpu_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(KABYLAKE,\t\t&idle_cpu_skl),\n\tX86_MATCH_INTEL_FAM6_MODEL(SKYLAKE_X,\t\t&idle_cpu_skx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_X,\t\t&idle_cpu_icx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ICELAKE_D,\t\t&idle_cpu_icx),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE,\t\t&idle_cpu_adl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L,\t\t&idle_cpu_adl_l),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GRACEMONT,\t&idle_cpu_gmt),\n\tX86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X,\t&idle_cpu_spr),\n\tX86_MATCH_INTEL_FAM6_MODEL(EMERALDRAPIDS_X,\t&idle_cpu_spr),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNL,\t&idle_cpu_knl),\n\tX86_MATCH_INTEL_FAM6_MODEL(XEON_PHI_KNM,\t&idle_cpu_knl),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT,\t&idle_cpu_bxt),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_PLUS,\t&idle_cpu_bxt),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_GOLDMONT_D,\t&idle_cpu_dnv),\n\tX86_MATCH_INTEL_FAM6_MODEL(ATOM_TREMONT_D,\t&idle_cpu_snr),\n\t{}\n};\n\nstatic const struct x86_cpu_id intel_mwait_ids[] __initconst = {\n\tX86_MATCH_VENDOR_FAM_FEATURE(INTEL, 6, X86_FEATURE_MWAIT, NULL),\n\t{}\n};\n\nstatic bool __init intel_idle_max_cstate_reached(int cstate)\n{\n\tif (cstate + 1 > max_cstate) {\n\t\tpr_info(\"max_cstate %d reached\\n\", max_cstate);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool __init intel_idle_state_needs_timer_stop(struct cpuidle_state *state)\n{\n\tunsigned long eax = flg2MWAIT(state->flags);\n\n\tif (boot_cpu_has(X86_FEATURE_ARAT))\n\t\treturn false;\n\n\t \n\treturn !!((eax >> MWAIT_SUBSTATE_SIZE) & MWAIT_CSTATE_MASK);\n}\n\n#ifdef CONFIG_ACPI_PROCESSOR_CSTATE\n#include <acpi/processor.h>\n\nstatic bool no_acpi __read_mostly;\nmodule_param(no_acpi, bool, 0444);\nMODULE_PARM_DESC(no_acpi, \"Do not use ACPI _CST for building the idle states list\");\n\nstatic bool force_use_acpi __read_mostly;  \nmodule_param_named(use_acpi, force_use_acpi, bool, 0444);\nMODULE_PARM_DESC(use_acpi, \"Use ACPI _CST for building the idle states list\");\n\nstatic struct acpi_processor_power acpi_state_table __initdata;\n\n \nstatic bool __init intel_idle_cst_usable(void)\n{\n\tint cstate, limit;\n\n\tlimit = min_t(int, min_t(int, CPUIDLE_STATE_MAX, max_cstate + 1),\n\t\t      acpi_state_table.count);\n\n\tfor (cstate = 1; cstate < limit; cstate++) {\n\t\tstruct acpi_processor_cx *cx = &acpi_state_table.states[cstate];\n\n\t\tif (cx->entry_method != ACPI_CSTATE_FFH)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool __init intel_idle_acpi_cst_extract(void)\n{\n\tunsigned int cpu;\n\n\tif (no_acpi) {\n\t\tpr_debug(\"Not allowed to use ACPI _CST\\n\");\n\t\treturn false;\n\t}\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct acpi_processor *pr = per_cpu(processors, cpu);\n\n\t\tif (!pr)\n\t\t\tcontinue;\n\n\t\tif (acpi_processor_evaluate_cst(pr->handle, cpu, &acpi_state_table))\n\t\t\tcontinue;\n\n\t\tacpi_state_table.count++;\n\n\t\tif (!intel_idle_cst_usable())\n\t\t\tcontinue;\n\n\t\tif (!acpi_processor_claim_cst_control())\n\t\t\tbreak;\n\n\t\treturn true;\n\t}\n\n\tacpi_state_table.count = 0;\n\tpr_debug(\"ACPI _CST not found or not usable\\n\");\n\treturn false;\n}\n\nstatic void __init intel_idle_init_cstates_acpi(struct cpuidle_driver *drv)\n{\n\tint cstate, limit = min_t(int, CPUIDLE_STATE_MAX, acpi_state_table.count);\n\n\t \n\tfor (cstate = 1; cstate < limit; cstate++) {\n\t\tstruct acpi_processor_cx *cx;\n\t\tstruct cpuidle_state *state;\n\n\t\tif (intel_idle_max_cstate_reached(cstate - 1))\n\t\t\tbreak;\n\n\t\tcx = &acpi_state_table.states[cstate];\n\n\t\tstate = &drv->states[drv->state_count++];\n\n\t\tsnprintf(state->name, CPUIDLE_NAME_LEN, \"C%d_ACPI\", cstate);\n\t\tstrscpy(state->desc, cx->desc, CPUIDLE_DESC_LEN);\n\t\tstate->exit_latency = cx->latency;\n\t\t \n\t\tstate->target_residency = cx->latency;\n\t\tif (cx->type > ACPI_STATE_C1)\n\t\t\tstate->target_residency *= 3;\n\n\t\tstate->flags = MWAIT2flg(cx->address);\n\t\tif (cx->type > ACPI_STATE_C2)\n\t\t\tstate->flags |= CPUIDLE_FLAG_TLB_FLUSHED;\n\n\t\tif (disabled_states_mask & BIT(cstate))\n\t\t\tstate->flags |= CPUIDLE_FLAG_OFF;\n\n\t\tif (intel_idle_state_needs_timer_stop(state))\n\t\t\tstate->flags |= CPUIDLE_FLAG_TIMER_STOP;\n\n\t\tstate->enter = intel_idle;\n\t\tstate->enter_s2idle = intel_idle_s2idle;\n\t}\n}\n\nstatic bool __init intel_idle_off_by_default(u32 mwait_hint)\n{\n\tint cstate, limit;\n\n\t \n\tif (!acpi_state_table.count)\n\t\treturn false;\n\n\tlimit = min_t(int, CPUIDLE_STATE_MAX, acpi_state_table.count);\n\t \n\tfor (cstate = 1; cstate < limit; cstate++) {\n\t\tif (acpi_state_table.states[cstate].address == mwait_hint)\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n#else  \n#define force_use_acpi\t(false)\n\nstatic inline bool intel_idle_acpi_cst_extract(void) { return false; }\nstatic inline void intel_idle_init_cstates_acpi(struct cpuidle_driver *drv) { }\nstatic inline bool intel_idle_off_by_default(u32 mwait_hint) { return false; }\n#endif  \n\n \nstatic void __init ivt_idle_state_table_update(void)\n{\n\t \n\tint cpu, package_num, num_sockets = 1;\n\n\tfor_each_online_cpu(cpu) {\n\t\tpackage_num = topology_physical_package_id(cpu);\n\t\tif (package_num + 1 > num_sockets) {\n\t\t\tnum_sockets = package_num + 1;\n\n\t\t\tif (num_sockets > 4) {\n\t\t\t\tcpuidle_state_table = ivt_cstates_8s;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (num_sockets > 2)\n\t\tcpuidle_state_table = ivt_cstates_4s;\n\n\t \n}\n\n \nstatic unsigned long long __init irtl_2_usec(unsigned long long irtl)\n{\n\tstatic const unsigned int irtl_ns_units[] __initconst = {\n\t\t1, 32, 1024, 32768, 1048576, 33554432, 0, 0\n\t};\n\tunsigned long long ns;\n\n\tif (!irtl)\n\t\treturn 0;\n\n\tns = irtl_ns_units[(irtl >> 10) & 0x7];\n\n\treturn div_u64((irtl & 0x3FF) * ns, NSEC_PER_USEC);\n}\n\n \nstatic void __init bxt_idle_state_table_update(void)\n{\n\tunsigned long long msr;\n\tunsigned int usec;\n\n\trdmsrl(MSR_PKGC6_IRTL, msr);\n\tusec = irtl_2_usec(msr);\n\tif (usec) {\n\t\tbxt_cstates[2].exit_latency = usec;\n\t\tbxt_cstates[2].target_residency = usec;\n\t}\n\n\trdmsrl(MSR_PKGC7_IRTL, msr);\n\tusec = irtl_2_usec(msr);\n\tif (usec) {\n\t\tbxt_cstates[3].exit_latency = usec;\n\t\tbxt_cstates[3].target_residency = usec;\n\t}\n\n\trdmsrl(MSR_PKGC8_IRTL, msr);\n\tusec = irtl_2_usec(msr);\n\tif (usec) {\n\t\tbxt_cstates[4].exit_latency = usec;\n\t\tbxt_cstates[4].target_residency = usec;\n\t}\n\n\trdmsrl(MSR_PKGC9_IRTL, msr);\n\tusec = irtl_2_usec(msr);\n\tif (usec) {\n\t\tbxt_cstates[5].exit_latency = usec;\n\t\tbxt_cstates[5].target_residency = usec;\n\t}\n\n\trdmsrl(MSR_PKGC10_IRTL, msr);\n\tusec = irtl_2_usec(msr);\n\tif (usec) {\n\t\tbxt_cstates[6].exit_latency = usec;\n\t\tbxt_cstates[6].target_residency = usec;\n\t}\n\n}\n\n \nstatic void __init sklh_idle_state_table_update(void)\n{\n\tunsigned long long msr;\n\tunsigned int eax, ebx, ecx, edx;\n\n\n\t \n\tif (max_cstate <= 7)\n\t\treturn;\n\n\t \n\tif ((mwait_substates & (0xF << 28)) == 0)\n\t\treturn;\n\n\trdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr);\n\n\t \n\tif ((msr & 0xF) != 8)\n\t\treturn;\n\n\tecx = 0;\n\tcpuid(7, &eax, &ebx, &ecx, &edx);\n\n\t \n\tif (ebx & (1 << 2)) {\n\n\t\trdmsrl(MSR_IA32_FEAT_CTL, msr);\n\n\t\t \n\t\tif (msr & (1 << 18))\n\t\t\treturn;\n\t}\n\n\tskl_cstates[5].flags |= CPUIDLE_FLAG_UNUSABLE;\t \n\tskl_cstates[6].flags |= CPUIDLE_FLAG_UNUSABLE;\t \n}\n\n \nstatic void __init skx_idle_state_table_update(void)\n{\n\tunsigned long long msr;\n\n\trdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr);\n\n\t \n\tif ((msr & 0x7) < 2) {\n\t\t \n\t\tskx_cstates[2].exit_latency = 92;\n\t\tskx_cstates[2].target_residency = 276;\n\t}\n}\n\n \nstatic void __init adl_idle_state_table_update(void)\n{\n\t \n\tif (preferred_states_mask & BIT(1) && !(preferred_states_mask & BIT(2))) {\n\t\tcpuidle_state_table[0].flags &= ~CPUIDLE_FLAG_UNUSABLE;\n\t\tcpuidle_state_table[1].flags |= CPUIDLE_FLAG_UNUSABLE;\n\n\t\t \n\t\tc1e_promotion = C1E_PROMOTION_DISABLE;\n\t\treturn;\n\t}\n\n\t \n\tc1e_promotion = C1E_PROMOTION_ENABLE;\n}\n\n \nstatic void __init spr_idle_state_table_update(void)\n{\n\tunsigned long long msr;\n\n\t \n\trdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr);\n\n\t \n\tif ((msr & 0x7) < 2) {\n\t\tspr_cstates[2].exit_latency = 190;\n\t\tspr_cstates[2].target_residency = 600;\n\t}\n}\n\nstatic bool __init intel_idle_verify_cstate(unsigned int mwait_hint)\n{\n\tunsigned int mwait_cstate = MWAIT_HINT2CSTATE(mwait_hint) + 1;\n\tunsigned int num_substates = (mwait_substates >> mwait_cstate * 4) &\n\t\t\t\t\tMWAIT_SUBSTATE_MASK;\n\n\t \n\tif (num_substates == 0)\n\t\treturn false;\n\n\tif (mwait_cstate > 2 && !boot_cpu_has(X86_FEATURE_NONSTOP_TSC))\n\t\tmark_tsc_unstable(\"TSC halts in idle states deeper than C2\");\n\n\treturn true;\n}\n\nstatic void state_update_enter_method(struct cpuidle_state *state, int cstate)\n{\n\tif (state->flags & CPUIDLE_FLAG_INIT_XSTATE) {\n\t\t \n\t\tWARN_ON_ONCE(state->flags & CPUIDLE_FLAG_IBRS);\n\t\tWARN_ON_ONCE(state->flags & CPUIDLE_FLAG_IRQ_ENABLE);\n\t\tstate->enter = intel_idle_xstate;\n\t\treturn;\n\t}\n\n\tif (cpu_feature_enabled(X86_FEATURE_KERNEL_IBRS) &&\n\t\t\t   state->flags & CPUIDLE_FLAG_IBRS) {\n\t\t \n\t\tWARN_ON_ONCE(state->flags & CPUIDLE_FLAG_IRQ_ENABLE);\n\t\tstate->enter = intel_idle_ibrs;\n\t\treturn;\n\t}\n\n\tif (state->flags & CPUIDLE_FLAG_IRQ_ENABLE) {\n\t\tstate->enter = intel_idle_irq;\n\t\treturn;\n\t}\n\n\tif (force_irq_on) {\n\t\tpr_info(\"forced intel_idle_irq for state %d\\n\", cstate);\n\t\tstate->enter = intel_idle_irq;\n\t}\n}\n\nstatic void __init intel_idle_init_cstates_icpu(struct cpuidle_driver *drv)\n{\n\tint cstate;\n\n\tswitch (boot_cpu_data.x86_model) {\n\tcase INTEL_FAM6_IVYBRIDGE_X:\n\t\tivt_idle_state_table_update();\n\t\tbreak;\n\tcase INTEL_FAM6_ATOM_GOLDMONT:\n\tcase INTEL_FAM6_ATOM_GOLDMONT_PLUS:\n\t\tbxt_idle_state_table_update();\n\t\tbreak;\n\tcase INTEL_FAM6_SKYLAKE:\n\t\tsklh_idle_state_table_update();\n\t\tbreak;\n\tcase INTEL_FAM6_SKYLAKE_X:\n\t\tskx_idle_state_table_update();\n\t\tbreak;\n\tcase INTEL_FAM6_SAPPHIRERAPIDS_X:\n\tcase INTEL_FAM6_EMERALDRAPIDS_X:\n\t\tspr_idle_state_table_update();\n\t\tbreak;\n\tcase INTEL_FAM6_ALDERLAKE:\n\tcase INTEL_FAM6_ALDERLAKE_L:\n\tcase INTEL_FAM6_ATOM_GRACEMONT:\n\t\tadl_idle_state_table_update();\n\t\tbreak;\n\t}\n\n\tfor (cstate = 0; cstate < CPUIDLE_STATE_MAX; ++cstate) {\n\t\tstruct cpuidle_state *state;\n\t\tunsigned int mwait_hint;\n\n\t\tif (intel_idle_max_cstate_reached(cstate))\n\t\t\tbreak;\n\n\t\tif (!cpuidle_state_table[cstate].enter &&\n\t\t    !cpuidle_state_table[cstate].enter_s2idle)\n\t\t\tbreak;\n\n\t\t \n\t\tif (cpuidle_state_table[cstate].flags & CPUIDLE_FLAG_UNUSABLE) {\n\t\t\tpr_debug(\"state %s is disabled\\n\",\n\t\t\t\t cpuidle_state_table[cstate].name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmwait_hint = flg2MWAIT(cpuidle_state_table[cstate].flags);\n\t\tif (!intel_idle_verify_cstate(mwait_hint))\n\t\t\tcontinue;\n\n\t\t \n\t\tdrv->states[drv->state_count] = cpuidle_state_table[cstate];\n\t\tstate = &drv->states[drv->state_count];\n\n\t\tstate_update_enter_method(state, cstate);\n\n\n\t\tif ((disabled_states_mask & BIT(drv->state_count)) ||\n\t\t    ((icpu->use_acpi || force_use_acpi) &&\n\t\t     intel_idle_off_by_default(mwait_hint) &&\n\t\t     !(state->flags & CPUIDLE_FLAG_ALWAYS_ENABLE)))\n\t\t\tstate->flags |= CPUIDLE_FLAG_OFF;\n\n\t\tif (intel_idle_state_needs_timer_stop(state))\n\t\t\tstate->flags |= CPUIDLE_FLAG_TIMER_STOP;\n\n\t\tdrv->state_count++;\n\t}\n\n\tif (icpu->byt_auto_demotion_disable_flag) {\n\t\twrmsrl(MSR_CC6_DEMOTION_POLICY_CONFIG, 0);\n\t\twrmsrl(MSR_MC6_DEMOTION_POLICY_CONFIG, 0);\n\t}\n}\n\n \nstatic void __init intel_idle_cpuidle_driver_init(struct cpuidle_driver *drv)\n{\n\tcpuidle_poll_state_init(drv);\n\n\tif (disabled_states_mask & BIT(0))\n\t\tdrv->states[0].flags |= CPUIDLE_FLAG_OFF;\n\n\tdrv->state_count = 1;\n\n\tif (icpu)\n\t\tintel_idle_init_cstates_icpu(drv);\n\telse\n\t\tintel_idle_init_cstates_acpi(drv);\n}\n\nstatic void auto_demotion_disable(void)\n{\n\tunsigned long long msr_bits;\n\n\trdmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);\n\tmsr_bits &= ~auto_demotion_disable_flags;\n\twrmsrl(MSR_PKG_CST_CONFIG_CONTROL, msr_bits);\n}\n\nstatic void c1e_promotion_enable(void)\n{\n\tunsigned long long msr_bits;\n\n\trdmsrl(MSR_IA32_POWER_CTL, msr_bits);\n\tmsr_bits |= 0x2;\n\twrmsrl(MSR_IA32_POWER_CTL, msr_bits);\n}\n\nstatic void c1e_promotion_disable(void)\n{\n\tunsigned long long msr_bits;\n\n\trdmsrl(MSR_IA32_POWER_CTL, msr_bits);\n\tmsr_bits &= ~0x2;\n\twrmsrl(MSR_IA32_POWER_CTL, msr_bits);\n}\n\n \nstatic int intel_idle_cpu_init(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev;\n\n\tdev = per_cpu_ptr(intel_idle_cpuidle_devices, cpu);\n\tdev->cpu = cpu;\n\n\tif (cpuidle_register_device(dev)) {\n\t\tpr_debug(\"cpuidle_register_device %d failed!\\n\", cpu);\n\t\treturn -EIO;\n\t}\n\n\tif (auto_demotion_disable_flags)\n\t\tauto_demotion_disable();\n\n\tif (c1e_promotion == C1E_PROMOTION_ENABLE)\n\t\tc1e_promotion_enable();\n\telse if (c1e_promotion == C1E_PROMOTION_DISABLE)\n\t\tc1e_promotion_disable();\n\n\treturn 0;\n}\n\nstatic int intel_idle_cpu_online(unsigned int cpu)\n{\n\tstruct cpuidle_device *dev;\n\n\tif (!boot_cpu_has(X86_FEATURE_ARAT))\n\t\ttick_broadcast_enable();\n\n\t \n\tdev = per_cpu_ptr(intel_idle_cpuidle_devices, cpu);\n\tif (!dev->registered)\n\t\treturn intel_idle_cpu_init(cpu);\n\n\treturn 0;\n}\n\n \nstatic void __init intel_idle_cpuidle_devices_uninit(void)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcpuidle_unregister_device(per_cpu_ptr(intel_idle_cpuidle_devices, i));\n}\n\nstatic int __init intel_idle_init(void)\n{\n\tconst struct x86_cpu_id *id;\n\tunsigned int eax, ebx, ecx;\n\tint retval;\n\n\t \n\tif (boot_option_idle_override != IDLE_NO_OVERRIDE)\n\t\treturn -ENODEV;\n\n\tif (max_cstate == 0) {\n\t\tpr_debug(\"disabled\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tid = x86_match_cpu(intel_idle_ids);\n\tif (id) {\n\t\tif (!boot_cpu_has(X86_FEATURE_MWAIT)) {\n\t\t\tpr_debug(\"Please enable MWAIT in BIOS SETUP\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t} else {\n\t\tid = x86_match_cpu(intel_mwait_ids);\n\t\tif (!id)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)\n\t\treturn -ENODEV;\n\n\tcpuid(CPUID_MWAIT_LEAF, &eax, &ebx, &ecx, &mwait_substates);\n\n\tif (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) ||\n\t    !(ecx & CPUID5_ECX_INTERRUPT_BREAK) ||\n\t    !mwait_substates)\n\t\t\treturn -ENODEV;\n\n\tpr_debug(\"MWAIT substates: 0x%x\\n\", mwait_substates);\n\n\ticpu = (const struct idle_cpu *)id->driver_data;\n\tif (icpu) {\n\t\tcpuidle_state_table = icpu->state_table;\n\t\tauto_demotion_disable_flags = icpu->auto_demotion_disable_flags;\n\t\tif (icpu->disable_promotion_to_c1e)\n\t\t\tc1e_promotion = C1E_PROMOTION_DISABLE;\n\t\tif (icpu->use_acpi || force_use_acpi)\n\t\t\tintel_idle_acpi_cst_extract();\n\t} else if (!intel_idle_acpi_cst_extract()) {\n\t\treturn -ENODEV;\n\t}\n\n\tpr_debug(\"v\" INTEL_IDLE_VERSION \" model 0x%X\\n\",\n\t\t boot_cpu_data.x86_model);\n\n\tintel_idle_cpuidle_devices = alloc_percpu(struct cpuidle_device);\n\tif (!intel_idle_cpuidle_devices)\n\t\treturn -ENOMEM;\n\n\tintel_idle_cpuidle_driver_init(&intel_idle_driver);\n\n\tretval = cpuidle_register_driver(&intel_idle_driver);\n\tif (retval) {\n\t\tstruct cpuidle_driver *drv = cpuidle_get_driver();\n\t\tprintk(KERN_DEBUG pr_fmt(\"intel_idle yielding to %s\\n\"),\n\t\t       drv ? drv->name : \"none\");\n\t\tgoto init_driver_fail;\n\t}\n\n\tretval = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, \"idle/intel:online\",\n\t\t\t\t   intel_idle_cpu_online, NULL);\n\tif (retval < 0)\n\t\tgoto hp_setup_fail;\n\n\tpr_debug(\"Local APIC timer is reliable in %s\\n\",\n\t\t boot_cpu_has(X86_FEATURE_ARAT) ? \"all C-states\" : \"C1\");\n\n\treturn 0;\n\nhp_setup_fail:\n\tintel_idle_cpuidle_devices_uninit();\n\tcpuidle_unregister_driver(&intel_idle_driver);\ninit_driver_fail:\n\tfree_percpu(intel_idle_cpuidle_devices);\n\treturn retval;\n\n}\ndevice_initcall(intel_idle_init);\n\n \nmodule_param(max_cstate, int, 0444);\n \nmodule_param_named(states_off, disabled_states_mask, uint, 0444);\nMODULE_PARM_DESC(states_off, \"Mask of disabled idle states\");\n \nmodule_param_named(preferred_cstates, preferred_states_mask, uint, 0444);\nMODULE_PARM_DESC(preferred_cstates, \"Mask of preferred idle states\");\n \nmodule_param(force_irq_on, bool, 0444);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}