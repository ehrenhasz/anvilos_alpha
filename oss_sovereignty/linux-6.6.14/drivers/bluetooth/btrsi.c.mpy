{
  "module_name": "btrsi.c",
  "hash_id": "6428e49482268c833607891d10b26786dbb106d4676e18bda26748e4d02981d6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btrsi.c",
  "human_readable_source": " \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <asm/unaligned.h>\n#include <net/rsi_91x.h>\n\n#define RSI_DMA_ALIGN\t8\n#define RSI_FRAME_DESC_SIZE\t16\n#define RSI_HEADROOM_FOR_BT_HAL\t(RSI_FRAME_DESC_SIZE + RSI_DMA_ALIGN)\n\nstruct rsi_hci_adapter {\n\tvoid *priv;\n\tstruct rsi_proto_ops *proto_ops;\n\tstruct hci_dev *hdev;\n};\n\nstatic int rsi_hci_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int rsi_hci_close(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int rsi_hci_flush(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int rsi_hci_send_pkt(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct rsi_hci_adapter *h_adapter = hci_get_drvdata(hdev);\n\tstruct sk_buff *new_skb = NULL;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\tif (skb_headroom(skb) < RSI_HEADROOM_FOR_BT_HAL) {\n\t\t \n\t\tnew_skb = skb_realloc_headroom(skb, RSI_HEADROOM_FOR_BT_HAL);\n\t\tif (unlikely(!new_skb))\n\t\t\treturn -ENOMEM;\n\t\tbt_cb(new_skb)->pkt_type = hci_skb_pkt_type(skb);\n\t\tkfree_skb(skb);\n\t\tskb = new_skb;\n\t\tif (!IS_ALIGNED((unsigned long)skb->data, RSI_DMA_ALIGN)) {\n\t\t\tu8 *skb_data = skb->data;\n\t\t\tint skb_len = skb->len;\n\n\t\t\tskb_push(skb, RSI_DMA_ALIGN);\n\t\t\tskb_pull(skb, PTR_ALIGN(skb->data,\n\t\t\t\t\t\tRSI_DMA_ALIGN) - skb->data);\n\t\t\tmemmove(skb->data, skb_data, skb_len);\n\t\t\tskb_trim(skb, skb_len);\n\t\t}\n\t}\n\n\treturn h_adapter->proto_ops->coex_send_pkt(h_adapter->priv, skb,\n\t\t\t\t\t\t   RSI_BT_Q);\n}\n\nstatic int rsi_hci_recv_pkt(void *priv, const u8 *pkt)\n{\n\tstruct rsi_hci_adapter *h_adapter = priv;\n\tstruct hci_dev *hdev = h_adapter->hdev;\n\tstruct sk_buff *skb;\n\tint pkt_len = get_unaligned_le16(pkt) & 0x0fff;\n\n\tskb = dev_alloc_skb(pkt_len);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tmemcpy(skb->data, pkt + RSI_FRAME_DESC_SIZE, pkt_len);\n\tskb_put(skb, pkt_len);\n\th_adapter->hdev->stat.byte_rx += skb->len;\n\n\thci_skb_pkt_type(skb) = pkt[14];\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int rsi_hci_attach(void *priv, struct rsi_proto_ops *ops)\n{\n\tstruct rsi_hci_adapter *h_adapter = NULL;\n\tstruct hci_dev *hdev;\n\tint err = 0;\n\n\th_adapter = kzalloc(sizeof(*h_adapter), GFP_KERNEL);\n\tif (!h_adapter)\n\t\treturn -ENOMEM;\n\n\th_adapter->priv = priv;\n\tops->set_bt_context(priv, h_adapter);\n\th_adapter->proto_ops = ops;\n\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Failed to alloc HCI device\");\n\t\tgoto err;\n\t}\n\n\th_adapter->hdev = hdev;\n\n\tif (ops->get_host_intf(priv) == RSI_HOST_INTF_SDIO)\n\t\thdev->bus = HCI_SDIO;\n\telse\n\t\thdev->bus = HCI_USB;\n\n\thci_set_drvdata(hdev, h_adapter);\n\thdev->dev_type = HCI_PRIMARY;\n\thdev->open = rsi_hci_open;\n\thdev->close = rsi_hci_close;\n\thdev->flush = rsi_hci_flush;\n\thdev->send = rsi_hci_send_pkt;\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\tBT_ERR(\"HCI registration failed with errcode %d\", err);\n\t\thci_free_dev(hdev);\n\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\th_adapter->hdev = NULL;\n\tkfree(h_adapter);\n\treturn -EINVAL;\n}\n\nstatic void rsi_hci_detach(void *priv)\n{\n\tstruct rsi_hci_adapter *h_adapter = priv;\n\tstruct hci_dev *hdev;\n\n\tif (!h_adapter)\n\t\treturn;\n\n\thdev = h_adapter->hdev;\n\tif (hdev) {\n\t\thci_unregister_dev(hdev);\n\t\thci_free_dev(hdev);\n\t\th_adapter->hdev = NULL;\n\t}\n\n\tkfree(h_adapter);\n}\n\nconst struct rsi_mod_ops rsi_bt_ops = {\n\t.attach\t= rsi_hci_attach,\n\t.detach\t= rsi_hci_detach,\n\t.recv_pkt = rsi_hci_recv_pkt,\n};\nEXPORT_SYMBOL(rsi_bt_ops);\n\nstatic int rsi_91x_bt_module_init(void)\n{\n\treturn 0;\n}\n\nstatic void rsi_91x_bt_module_exit(void)\n{\n\treturn;\n}\n\nmodule_init(rsi_91x_bt_module_init);\nmodule_exit(rsi_91x_bt_module_exit);\nMODULE_AUTHOR(\"Redpine Signals Inc\");\nMODULE_DESCRIPTION(\"RSI BT driver\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}