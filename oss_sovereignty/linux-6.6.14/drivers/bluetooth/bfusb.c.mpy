{
  "module_name": "bfusb.c",
  "hash_id": "bed266c67abeca0488e5a9475302f1edef6f2b206c014a5f029f27553ae5ad55",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/bfusb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n\n#include <linux/device.h>\n#include <linux/firmware.h>\n\n#include <linux/usb.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#define VERSION \"1.2\"\n\nstatic struct usb_driver bfusb_driver;\n\nstatic const struct usb_device_id bfusb_table[] = {\n\t \n\t{ USB_DEVICE(0x057c, 0x2200) },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, bfusb_table);\n\n#define BFUSB_MAX_BLOCK_SIZE\t256\n\n#define BFUSB_BLOCK_TIMEOUT\t3000\n\n#define BFUSB_TX_PROCESS\t1\n#define BFUSB_TX_WAKEUP\t\t2\n\n#define BFUSB_MAX_BULK_TX\t2\n#define BFUSB_MAX_BULK_RX\t2\n\nstruct bfusb_data {\n\tstruct hci_dev\t\t*hdev;\n\n\tunsigned long\t\tstate;\n\n\tstruct usb_device\t*udev;\n\n\tunsigned int\t\tbulk_in_ep;\n\tunsigned int\t\tbulk_out_ep;\n\tunsigned int\t\tbulk_pkt_size;\n\n\trwlock_t\t\tlock;\n\n\tstruct sk_buff_head\ttransmit_q;\n\n\tstruct sk_buff\t\t*reassembly;\n\n\tatomic_t\t\tpending_tx;\n\tstruct sk_buff_head\tpending_q;\n\tstruct sk_buff_head\tcompleted_q;\n};\n\nstruct bfusb_data_scb {\n\tstruct urb *urb;\n};\n\nstatic void bfusb_tx_complete(struct urb *urb);\nstatic void bfusb_rx_complete(struct urb *urb);\n\nstatic struct urb *bfusb_get_completed(struct bfusb_data *data)\n{\n\tstruct sk_buff *skb;\n\tstruct urb *urb = NULL;\n\n\tBT_DBG(\"bfusb %p\", data);\n\n\tskb = skb_dequeue(&data->completed_q);\n\tif (skb) {\n\t\turb = ((struct bfusb_data_scb *) skb->cb)->urb;\n\t\tkfree_skb(skb);\n\t}\n\n\treturn urb;\n}\n\nstatic void bfusb_unlink_urbs(struct bfusb_data *data)\n{\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\n\tBT_DBG(\"bfusb %p\", data);\n\n\twhile ((skb = skb_dequeue(&data->pending_q))) {\n\t\turb = ((struct bfusb_data_scb *) skb->cb)->urb;\n\t\tusb_kill_urb(urb);\n\t\tskb_queue_tail(&data->completed_q, skb);\n\t}\n\n\twhile ((urb = bfusb_get_completed(data)))\n\t\tusb_free_urb(urb);\n}\n\nstatic int bfusb_send_bulk(struct bfusb_data *data, struct sk_buff *skb)\n{\n\tstruct bfusb_data_scb *scb = (void *) skb->cb;\n\tstruct urb *urb = bfusb_get_completed(data);\n\tint err, pipe;\n\n\tBT_DBG(\"bfusb %p skb %p len %d\", data, skb, skb->len);\n\n\tif (!urb) {\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe, skb->data, skb->len,\n\t\t\tbfusb_tx_complete, skb);\n\n\tscb->urb = urb;\n\n\tskb_queue_tail(&data->pending_q, skb);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tbt_dev_err(data->hdev, \"bulk tx submit failed urb %p err %d\",\n\t\t\t   urb, err);\n\t\tskb_unlink(skb, &data->pending_q);\n\t\tusb_free_urb(urb);\n\t} else\n\t\tatomic_inc(&data->pending_tx);\n\n\treturn err;\n}\n\nstatic void bfusb_tx_wakeup(struct bfusb_data *data)\n{\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"bfusb %p\", data);\n\n\tif (test_and_set_bit(BFUSB_TX_PROCESS, &data->state)) {\n\t\tset_bit(BFUSB_TX_WAKEUP, &data->state);\n\t\treturn;\n\t}\n\n\tdo {\n\t\tclear_bit(BFUSB_TX_WAKEUP, &data->state);\n\n\t\twhile ((atomic_read(&data->pending_tx) < BFUSB_MAX_BULK_TX) &&\n\t\t\t\t(skb = skb_dequeue(&data->transmit_q))) {\n\t\t\tif (bfusb_send_bulk(data, skb) < 0) {\n\t\t\t\tskb_queue_head(&data->transmit_q, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t} while (test_bit(BFUSB_TX_WAKEUP, &data->state));\n\n\tclear_bit(BFUSB_TX_PROCESS, &data->state);\n}\n\nstatic void bfusb_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *) urb->context;\n\tstruct bfusb_data *data = (struct bfusb_data *) skb->dev;\n\n\tBT_DBG(\"bfusb %p urb %p skb %p len %d\", data, urb, skb, skb->len);\n\n\tatomic_dec(&data->pending_tx);\n\n\tif (!test_bit(HCI_RUNNING, &data->hdev->flags))\n\t\treturn;\n\n\tif (!urb->status)\n\t\tdata->hdev->stat.byte_tx += skb->len;\n\telse\n\t\tdata->hdev->stat.err_tx++;\n\n\tread_lock(&data->lock);\n\n\tskb_unlink(skb, &data->pending_q);\n\tskb_queue_tail(&data->completed_q, skb);\n\n\tbfusb_tx_wakeup(data);\n\n\tread_unlock(&data->lock);\n}\n\n\nstatic int bfusb_rx_submit(struct bfusb_data *data, struct urb *urb)\n{\n\tstruct bfusb_data_scb *scb;\n\tstruct sk_buff *skb;\n\tint err, pipe, size = HCI_MAX_FRAME_SIZE + 32;\n\n\tBT_DBG(\"bfusb %p urb %p\", data, urb);\n\n\tif (!urb) {\n\t\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\t\tif (!urb)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tskb = bt_skb_alloc(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb->dev = (void *) data;\n\n\tscb = (struct bfusb_data_scb *) skb->cb;\n\tscb->urb = urb;\n\n\tpipe = usb_rcvbulkpipe(data->udev, data->bulk_in_ep);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe, skb->data, size,\n\t\t\tbfusb_rx_complete, skb);\n\n\tskb_queue_tail(&data->pending_q, skb);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tbt_dev_err(data->hdev, \"bulk rx submit failed urb %p err %d\",\n\t\t\t   urb, err);\n\t\tskb_unlink(skb, &data->pending_q);\n\t\tkfree_skb(skb);\n\t\tusb_free_urb(urb);\n\t}\n\n\treturn err;\n}\n\nstatic inline int bfusb_recv_block(struct bfusb_data *data, int hdr, unsigned char *buf, int len)\n{\n\tBT_DBG(\"bfusb %p hdr 0x%02x data %p len %d\", data, hdr, buf, len);\n\n\tif (hdr & 0x10) {\n\t\tbt_dev_err(data->hdev, \"error in block\");\n\t\tkfree_skb(data->reassembly);\n\t\tdata->reassembly = NULL;\n\t\treturn -EIO;\n\t}\n\n\tif (hdr & 0x04) {\n\t\tstruct sk_buff *skb;\n\t\tunsigned char pkt_type;\n\t\tint pkt_len = 0;\n\n\t\tif (data->reassembly) {\n\t\t\tbt_dev_err(data->hdev, \"unexpected start block\");\n\t\t\tkfree_skb(data->reassembly);\n\t\t\tdata->reassembly = NULL;\n\t\t}\n\n\t\tif (len < 1) {\n\t\t\tbt_dev_err(data->hdev, \"no packet type found\");\n\t\t\treturn -EPROTO;\n\t\t}\n\n\t\tpkt_type = *buf++; len--;\n\n\t\tswitch (pkt_type) {\n\t\tcase HCI_EVENT_PKT:\n\t\t\tif (len >= HCI_EVENT_HDR_SIZE) {\n\t\t\t\tstruct hci_event_hdr *hdr = (struct hci_event_hdr *) buf;\n\t\t\t\tpkt_len = HCI_EVENT_HDR_SIZE + hdr->plen;\n\t\t\t} else {\n\t\t\t\tbt_dev_err(data->hdev, \"event block is too short\");\n\t\t\t\treturn -EILSEQ;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HCI_ACLDATA_PKT:\n\t\t\tif (len >= HCI_ACL_HDR_SIZE) {\n\t\t\t\tstruct hci_acl_hdr *hdr = (struct hci_acl_hdr *) buf;\n\t\t\t\tpkt_len = HCI_ACL_HDR_SIZE + __le16_to_cpu(hdr->dlen);\n\t\t\t} else {\n\t\t\t\tbt_dev_err(data->hdev, \"data block is too short\");\n\t\t\t\treturn -EILSEQ;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase HCI_SCODATA_PKT:\n\t\t\tif (len >= HCI_SCO_HDR_SIZE) {\n\t\t\t\tstruct hci_sco_hdr *hdr = (struct hci_sco_hdr *) buf;\n\t\t\t\tpkt_len = HCI_SCO_HDR_SIZE + hdr->dlen;\n\t\t\t} else {\n\t\t\t\tbt_dev_err(data->hdev, \"audio block is too short\");\n\t\t\t\treturn -EILSEQ;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tskb = bt_skb_alloc(pkt_len, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\tbt_dev_err(data->hdev, \"no memory for the packet\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\n\t\tdata->reassembly = skb;\n\t} else {\n\t\tif (!data->reassembly) {\n\t\t\tbt_dev_err(data->hdev, \"unexpected continuation block\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\tif (len > 0)\n\t\tskb_put_data(data->reassembly, buf, len);\n\n\tif (hdr & 0x08) {\n\t\thci_recv_frame(data->hdev, data->reassembly);\n\t\tdata->reassembly = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic void bfusb_rx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = (struct sk_buff *) urb->context;\n\tstruct bfusb_data *data = (struct bfusb_data *) skb->dev;\n\tunsigned char *buf = urb->transfer_buffer;\n\tint count = urb->actual_length;\n\tint err, hdr, len;\n\n\tBT_DBG(\"bfusb %p urb %p skb %p len %d\", data, urb, skb, skb->len);\n\n\tread_lock(&data->lock);\n\n\tif (!test_bit(HCI_RUNNING, &data->hdev->flags))\n\t\tgoto unlock;\n\n\tif (urb->status || !count)\n\t\tgoto resubmit;\n\n\tdata->hdev->stat.byte_rx += count;\n\n\tskb_put(skb, count);\n\n\twhile (count) {\n\t\thdr = buf[0] | (buf[1] << 8);\n\n\t\tif (hdr & 0x4000) {\n\t\t\tlen = 0;\n\t\t\tcount -= 2;\n\t\t\tbuf   += 2;\n\t\t} else {\n\t\t\tlen = (buf[2] == 0) ? 256 : buf[2];\n\t\t\tcount -= 3;\n\t\t\tbuf   += 3;\n\t\t}\n\n\t\tif (count < len) {\n\t\t\tbt_dev_err(data->hdev, \"block extends over URB buffer ranges\");\n\t\t}\n\n\t\tif ((hdr & 0xe1) == 0xc1)\n\t\t\tbfusb_recv_block(data, hdr, buf, len);\n\n\t\tcount -= len;\n\t\tbuf   += len;\n\t}\n\n\tskb_unlink(skb, &data->pending_q);\n\tkfree_skb(skb);\n\n\tbfusb_rx_submit(data, urb);\n\n\tread_unlock(&data->lock);\n\n\treturn;\n\nresubmit:\n\turb->dev = data->udev;\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tbt_dev_err(data->hdev, \"bulk resubmit failed urb %p err %d\",\n\t\t\t   urb, err);\n\t}\n\nunlock:\n\tread_unlock(&data->lock);\n}\n\nstatic int bfusb_open(struct hci_dev *hdev)\n{\n\tstruct bfusb_data *data = hci_get_drvdata(hdev);\n\tunsigned long flags;\n\tint i, err;\n\n\tBT_DBG(\"hdev %p bfusb %p\", hdev, data);\n\n\twrite_lock_irqsave(&data->lock, flags);\n\n\terr = bfusb_rx_submit(data, NULL);\n\tif (!err) {\n\t\tfor (i = 1; i < BFUSB_MAX_BULK_RX; i++)\n\t\t\tbfusb_rx_submit(data, NULL);\n\t}\n\n\twrite_unlock_irqrestore(&data->lock, flags);\n\n\treturn err;\n}\n\nstatic int bfusb_flush(struct hci_dev *hdev)\n{\n\tstruct bfusb_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hdev %p bfusb %p\", hdev, data);\n\n\tskb_queue_purge(&data->transmit_q);\n\n\treturn 0;\n}\n\nstatic int bfusb_close(struct hci_dev *hdev)\n{\n\tstruct bfusb_data *data = hci_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tBT_DBG(\"hdev %p bfusb %p\", hdev, data);\n\n\twrite_lock_irqsave(&data->lock, flags);\n\twrite_unlock_irqrestore(&data->lock, flags);\n\n\tbfusb_unlink_urbs(data);\n\tbfusb_flush(hdev);\n\n\treturn 0;\n}\n\nstatic int bfusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct bfusb_data *data = hci_get_drvdata(hdev);\n\tstruct sk_buff *nskb;\n\tunsigned char buf[3];\n\tint sent = 0, size, count;\n\n\tBT_DBG(\"hdev %p skb %p type %d len %d\", hdev, skb,\n\t       hci_skb_pkt_type(skb), skb->len);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tcount = skb->len;\n\n\t \n\tnskb = bt_skb_alloc(count + 32, GFP_KERNEL);\n\tif (!nskb) {\n\t\tbt_dev_err(hdev, \"Can't allocate memory for new packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnskb->dev = (void *) data;\n\n\twhile (count) {\n\t\tsize = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE);\n\n\t\tbuf[0] = 0xc1 | ((sent == 0) ? 0x04 : 0) | ((count == size) ? 0x08 : 0);\n\t\tbuf[1] = 0x00;\n\t\tbuf[2] = (size == BFUSB_MAX_BLOCK_SIZE) ? 0 : size;\n\n\t\tskb_put_data(nskb, buf, 3);\n\t\tskb_copy_from_linear_data_offset(skb, sent, skb_put(nskb, size), size);\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\n\t \n\tif ((nskb->len % data->bulk_pkt_size) == 0) {\n\t\tbuf[0] = 0xdd;\n\t\tbuf[1] = 0x00;\n\t\tskb_put_data(nskb, buf, 2);\n\t}\n\n\tread_lock(&data->lock);\n\n\tskb_queue_tail(&data->transmit_q, nskb);\n\tbfusb_tx_wakeup(data);\n\n\tread_unlock(&data->lock);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int bfusb_load_firmware(struct bfusb_data *data,\n\t\t\t       const unsigned char *firmware, int count)\n{\n\tunsigned char *buf;\n\tint err, pipe, len, size, sent = 0;\n\n\tBT_DBG(\"bfusb %p udev %p\", data, data->udev);\n\n\tBT_INFO(\"BlueFRITZ! USB loading firmware\");\n\n\tbuf = kmalloc(BFUSB_MAX_BLOCK_SIZE + 3, GFP_KERNEL);\n\tif (!buf) {\n\t\tBT_ERR(\"Can't allocate memory chunk for firmware\");\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_sndctrlpipe(data->udev, 0);\n\n\tif (usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\n\t\t\t\t0, 1, 0, NULL, 0, USB_CTRL_SET_TIMEOUT) < 0) {\n\t\tBT_ERR(\"Can't change to loading configuration\");\n\t\tkfree(buf);\n\t\treturn -EBUSY;\n\t}\n\n\tdata->udev->toggle[0] = data->udev->toggle[1] = 0;\n\n\tpipe = usb_sndbulkpipe(data->udev, data->bulk_out_ep);\n\n\twhile (count) {\n\t\tsize = min_t(uint, count, BFUSB_MAX_BLOCK_SIZE + 3);\n\n\t\tmemcpy(buf, firmware + sent, size);\n\n\t\terr = usb_bulk_msg(data->udev, pipe, buf, size,\n\t\t\t\t\t&len, BFUSB_BLOCK_TIMEOUT);\n\n\t\tif (err || (len != size)) {\n\t\t\tBT_ERR(\"Error in firmware loading\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\n\terr = usb_bulk_msg(data->udev, pipe, NULL, 0,\n\t\t\t\t\t&len, BFUSB_BLOCK_TIMEOUT);\n\tif (err < 0) {\n\t\tBT_ERR(\"Error in null packet request\");\n\t\tgoto error;\n\t}\n\n\tpipe = usb_sndctrlpipe(data->udev, 0);\n\n\terr = usb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\n\t\t\t\t0, 2, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't change to running configuration\");\n\t\tgoto error;\n\t}\n\n\tdata->udev->toggle[0] = data->udev->toggle[1] = 0;\n\n\tBT_INFO(\"BlueFRITZ! USB device ready\");\n\n\tkfree(buf);\n\treturn 0;\n\nerror:\n\tkfree(buf);\n\n\tpipe = usb_sndctrlpipe(data->udev, 0);\n\n\tusb_control_msg(data->udev, pipe, USB_REQ_SET_CONFIGURATION,\n\t\t\t\t0, 0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\n\treturn err;\n}\n\nstatic int bfusb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tconst struct firmware *firmware;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_endpoint *bulk_out_ep;\n\tstruct usb_host_endpoint *bulk_in_ep;\n\tstruct hci_dev *hdev;\n\tstruct bfusb_data *data;\n\n\tBT_DBG(\"intf %p id %p\", intf, id);\n\n\t \n\tif (intf->cur_altsetting->desc.bNumEndpoints < 2)\n\t\treturn -EIO;\n\n\tbulk_out_ep = &intf->cur_altsetting->endpoint[0];\n\tbulk_in_ep  = &intf->cur_altsetting->endpoint[1];\n\n\tif (!bulk_out_ep || !bulk_in_ep) {\n\t\tBT_ERR(\"Bulk endpoints not found\");\n\t\tgoto done;\n\t}\n\n\t \n\tdata = devm_kzalloc(&intf->dev, sizeof(struct bfusb_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->udev = udev;\n\tdata->bulk_in_ep    = bulk_in_ep->desc.bEndpointAddress;\n\tdata->bulk_out_ep   = bulk_out_ep->desc.bEndpointAddress;\n\tdata->bulk_pkt_size = le16_to_cpu(bulk_out_ep->desc.wMaxPacketSize);\n\n\tif (!data->bulk_pkt_size)\n\t\tgoto done;\n\n\trwlock_init(&data->lock);\n\n\tdata->reassembly = NULL;\n\n\tskb_queue_head_init(&data->transmit_q);\n\tskb_queue_head_init(&data->pending_q);\n\tskb_queue_head_init(&data->completed_q);\n\n\tif (request_firmware(&firmware, \"bfubase.frm\", &udev->dev) < 0) {\n\t\tBT_ERR(\"Firmware request failed\");\n\t\tgoto done;\n\t}\n\n\tBT_DBG(\"firmware data %p size %zu\", firmware->data, firmware->size);\n\n\tif (bfusb_load_firmware(data, firmware->data, firmware->size) < 0) {\n\t\tBT_ERR(\"Firmware loading failed\");\n\t\tgoto release;\n\t}\n\n\trelease_firmware(firmware);\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\tgoto done;\n\t}\n\n\tdata->hdev = hdev;\n\n\thdev->bus = HCI_USB;\n\thci_set_drvdata(hdev, data);\n\tSET_HCIDEV_DEV(hdev, &intf->dev);\n\n\thdev->open  = bfusb_open;\n\thdev->close = bfusb_close;\n\thdev->flush = bfusb_flush;\n\thdev->send  = bfusb_send_frame;\n\n\tset_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks);\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\thci_free_dev(hdev);\n\t\tgoto done;\n\t}\n\n\tusb_set_intfdata(intf, data);\n\n\treturn 0;\n\nrelease:\n\trelease_firmware(firmware);\n\ndone:\n\treturn -EIO;\n}\n\nstatic void bfusb_disconnect(struct usb_interface *intf)\n{\n\tstruct bfusb_data *data = usb_get_intfdata(intf);\n\tstruct hci_dev *hdev = data->hdev;\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (!hdev)\n\t\treturn;\n\n\tusb_set_intfdata(intf, NULL);\n\n\tbfusb_close(hdev);\n\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n}\n\nstatic struct usb_driver bfusb_driver = {\n\t.name\t\t= \"bfusb\",\n\t.probe\t\t= bfusb_probe,\n\t.disconnect\t= bfusb_disconnect,\n\t.id_table\t= bfusb_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(bfusb_driver);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"BlueFRITZ! USB driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"bfubase.frm\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}