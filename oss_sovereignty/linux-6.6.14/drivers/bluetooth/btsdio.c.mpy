{
  "module_name": "btsdio.c",
  "hash_id": "6230a17476c76290854a25d3fa3bc6326088c20b67e3699c2eef3a2fe5c66ca9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btsdio.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#define VERSION \"0.1\"\n\nstatic const struct sdio_device_id btsdio_table[] = {\n\t \n\t{ SDIO_DEVICE_CLASS(SDIO_CLASS_BT_A) },\n\n\t \n\t{ SDIO_DEVICE_CLASS(SDIO_CLASS_BT_B) },\n\n\t \n\t{ SDIO_DEVICE_CLASS(SDIO_CLASS_BT_AMP) },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(sdio, btsdio_table);\n\nstruct btsdio_data {\n\tstruct hci_dev   *hdev;\n\tstruct sdio_func *func;\n\n\tstruct work_struct work;\n\n\tstruct sk_buff_head txq;\n};\n\n#define REG_RDAT     0x00\t \n#define REG_TDAT     0x00\t \n#define REG_PC_RRT   0x10\t \n#define REG_PC_WRT   0x11\t \n#define REG_RTC_STAT 0x12\t \n#define REG_RTC_SET  0x12\t \n#define REG_INTRD    0x13\t \n#define REG_CL_INTRD 0x13\t \n#define REG_EN_INTRD 0x14\t \n#define REG_MD_STAT  0x20\t \n#define REG_MD_SET   0x20\t \n\nstatic int btsdio_tx_packet(struct btsdio_data *data, struct sk_buff *skb)\n{\n\tint err;\n\n\tBT_DBG(\"%s\", data->hdev->name);\n\n\t \n\tskb_push(skb, 4);\n\tskb->data[0] = (skb->len & 0x0000ff);\n\tskb->data[1] = (skb->len & 0x00ff00) >> 8;\n\tskb->data[2] = (skb->len & 0xff0000) >> 16;\n\tskb->data[3] = hci_skb_pkt_type(skb);\n\n\terr = sdio_writesb(data->func, REG_TDAT, skb->data, skb->len);\n\tif (err < 0) {\n\t\tskb_pull(skb, 4);\n\t\tsdio_writeb(data->func, 0x01, REG_PC_WRT, NULL);\n\t\treturn err;\n\t}\n\n\tdata->hdev->stat.byte_tx += skb->len;\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic void btsdio_work(struct work_struct *work)\n{\n\tstruct btsdio_data *data = container_of(work, struct btsdio_data, work);\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"%s\", data->hdev->name);\n\n\tsdio_claim_host(data->func);\n\n\twhile ((skb = skb_dequeue(&data->txq))) {\n\t\terr = btsdio_tx_packet(data, skb);\n\t\tif (err < 0) {\n\t\t\tdata->hdev->stat.err_tx++;\n\t\t\tskb_queue_head(&data->txq, skb);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsdio_release_host(data->func);\n}\n\nstatic int btsdio_rx_packet(struct btsdio_data *data)\n{\n\tu8 hdr[4] __attribute__ ((aligned(4)));\n\tstruct sk_buff *skb;\n\tint err, len;\n\n\tBT_DBG(\"%s\", data->hdev->name);\n\n\terr = sdio_readsb(data->func, hdr, REG_RDAT, 4);\n\tif (err < 0)\n\t\treturn err;\n\n\tlen = hdr[0] | (hdr[1] << 8) | (hdr[2] << 16);\n\tif (len < 4 || len > 65543)\n\t\treturn -EILSEQ;\n\n\tskb = bt_skb_alloc(len - 4, GFP_KERNEL);\n\tif (!skb) {\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put(skb, len - 4);\n\n\terr = sdio_readsb(data->func, skb->data, REG_RDAT, len - 4);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tdata->hdev->stat.byte_rx += len;\n\n\tswitch (hdr[3]) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = hdr[3];\n\t\terr = hci_recv_frame(data->hdev, skb);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\tsdio_writeb(data->func, 0x00, REG_PC_RRT, NULL);\n\n\treturn 0;\n}\n\nstatic void btsdio_interrupt(struct sdio_func *func)\n{\n\tstruct btsdio_data *data = sdio_get_drvdata(func);\n\tint intrd;\n\n\tBT_DBG(\"%s\", data->hdev->name);\n\n\tintrd = sdio_readb(func, REG_INTRD, NULL);\n\tif (intrd & 0x01) {\n\t\tsdio_writeb(func, 0x01, REG_CL_INTRD, NULL);\n\n\t\tif (btsdio_rx_packet(data) < 0) {\n\t\t\tdata->hdev->stat.err_rx++;\n\t\t\tsdio_writeb(data->func, 0x01, REG_PC_RRT, NULL);\n\t\t}\n\t}\n}\n\nstatic int btsdio_open(struct hci_dev *hdev)\n{\n\tstruct btsdio_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tsdio_claim_host(data->func);\n\n\terr = sdio_enable_func(data->func);\n\tif (err < 0)\n\t\tgoto release;\n\n\terr = sdio_claim_irq(data->func, btsdio_interrupt);\n\tif (err < 0) {\n\t\tsdio_disable_func(data->func);\n\t\tgoto release;\n\t}\n\n\tif (data->func->class == SDIO_CLASS_BT_B)\n\t\tsdio_writeb(data->func, 0x00, REG_MD_SET, NULL);\n\n\tsdio_writeb(data->func, 0x01, REG_EN_INTRD, NULL);\n\nrelease:\n\tsdio_release_host(data->func);\n\n\treturn err;\n}\n\nstatic int btsdio_close(struct hci_dev *hdev)\n{\n\tstruct btsdio_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tsdio_claim_host(data->func);\n\n\tsdio_writeb(data->func, 0x00, REG_EN_INTRD, NULL);\n\n\tsdio_release_irq(data->func);\n\tsdio_disable_func(data->func);\n\n\tsdio_release_host(data->func);\n\n\treturn 0;\n}\n\nstatic int btsdio_flush(struct hci_dev *hdev)\n{\n\tstruct btsdio_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tskb_queue_purge(&data->txq);\n\n\treturn 0;\n}\n\nstatic int btsdio_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btsdio_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\n\tskb_queue_tail(&data->txq, skb);\n\n\tschedule_work(&data->work);\n\n\treturn 0;\n}\n\nstatic int btsdio_probe(struct sdio_func *func,\n\t\t\t\tconst struct sdio_device_id *id)\n{\n\tstruct btsdio_data *data;\n\tstruct hci_dev *hdev;\n\tstruct sdio_func_tuple *tuple = func->tuples;\n\tint err;\n\n\tBT_DBG(\"func %p id %p class 0x%04x\", func, id, func->class);\n\n\twhile (tuple) {\n\t\tBT_DBG(\"code 0x%x size %d\", tuple->code, tuple->size);\n\t\ttuple = tuple->next;\n\t}\n\n\t \n\tif (func->vendor == SDIO_VENDOR_ID_BROADCOM &&\n\t    !mmc_card_is_removable(func->card->host)) {\n\t\tswitch (func->device) {\n\t\tcase SDIO_DEVICE_ID_BROADCOM_43341:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_43430:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4345:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_43455:\n\t\tcase SDIO_DEVICE_ID_BROADCOM_4356:\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tdata = devm_kzalloc(&func->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->func = func;\n\n\tINIT_WORK(&data->work, btsdio_work);\n\n\tskb_queue_head_init(&data->txq);\n\n\thdev = hci_alloc_dev();\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\thdev->bus = HCI_SDIO;\n\thci_set_drvdata(hdev, data);\n\n\tif (id->class == SDIO_CLASS_BT_AMP)\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\tdata->hdev = hdev;\n\n\tSET_HCIDEV_DEV(hdev, &func->dev);\n\n\thdev->open     = btsdio_open;\n\thdev->close    = btsdio_close;\n\thdev->flush    = btsdio_flush;\n\thdev->send     = btsdio_send_frame;\n\n\tif (func->vendor == 0x0104 && func->device == 0x00c5)\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\tsdio_set_drvdata(func, data);\n\n\treturn 0;\n}\n\nstatic void btsdio_remove(struct sdio_func *func)\n{\n\tstruct btsdio_data *data = sdio_get_drvdata(func);\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"func %p\", func);\n\n\tif (!data)\n\t\treturn;\n\n\tcancel_work_sync(&data->work);\n\thdev = data->hdev;\n\n\tsdio_set_drvdata(func, NULL);\n\n\thci_unregister_dev(hdev);\n\n\thci_free_dev(hdev);\n}\n\nstatic struct sdio_driver btsdio_driver = {\n\t.name\t\t= \"btsdio\",\n\t.probe\t\t= btsdio_probe,\n\t.remove\t\t= btsdio_remove,\n\t.id_table\t= btsdio_table,\n};\n\nmodule_sdio_driver(btsdio_driver);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Generic Bluetooth SDIO driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}