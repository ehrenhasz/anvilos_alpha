{
  "module_name": "dtl1_cs.c",
  "hash_id": "33ce2ec8302adc47505b9407098ce0a2c8b24779225e195f066bb43dba67c35c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/dtl1_cs.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n#include <linux/moduleparam.h>\n\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/bitops.h>\n#include <asm/io.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n\n\n \n\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth driver for Nokia Connectivity Card DTL-1\");\nMODULE_LICENSE(\"GPL\");\n\n\n\n \n\n\nstruct dtl1_info {\n\tstruct pcmcia_device *p_dev;\n\n\tstruct hci_dev *hdev;\n\n\tspinlock_t lock;\t\t \n\n\tunsigned long flowmask;\t\t \n\tint ri_latch;\n\n\tstruct sk_buff_head txq;\n\tunsigned long tx_state;\n\n\tunsigned long rx_state;\n\tunsigned long rx_count;\n\tstruct sk_buff *rx_skb;\n};\n\n\nstatic int dtl1_config(struct pcmcia_device *link);\n\n\n \n#define XMIT_SENDING  1\n#define XMIT_WAKEUP   2\n#define XMIT_WAITING  8\n\n \n#define RECV_WAIT_NSH   0\n#define RECV_WAIT_DATA  1\n\n\nstruct nsh {\n\tu8 type;\n\tu8 zero;\n\tu16 len;\n} __packed;\t \n\n#define NSHL  4\t\t\t\t \n\n\n\n \n\n\nstatic int dtl1_write(unsigned int iobase, int fifo_size, __u8 *buf, int len)\n{\n\tint actual = 0;\n\n\t \n\tif (!(inb(iobase + UART_LSR) & UART_LSR_THRE))\n\t\treturn 0;\n\n\t \n\twhile ((fifo_size-- > 0) && (actual < len)) {\n\t\t \n\t\toutb(buf[actual], iobase + UART_TX);\n\t\tactual++;\n\t}\n\n\treturn actual;\n}\n\n\nstatic void dtl1_write_wakeup(struct dtl1_info *info)\n{\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tif (test_bit(XMIT_WAITING, &(info->tx_state))) {\n\t\tset_bit(XMIT_WAKEUP, &(info->tx_state));\n\t\treturn;\n\t}\n\n\tif (test_and_set_bit(XMIT_SENDING, &(info->tx_state))) {\n\t\tset_bit(XMIT_WAKEUP, &(info->tx_state));\n\t\treturn;\n\t}\n\n\tdo {\n\t\tunsigned int iobase = info->p_dev->resource[0]->start;\n\t\tregister struct sk_buff *skb;\n\t\tint len;\n\n\t\tclear_bit(XMIT_WAKEUP, &(info->tx_state));\n\n\t\tif (!pcmcia_dev_present(info->p_dev))\n\t\t\treturn;\n\n\t\tskb = skb_dequeue(&(info->txq));\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\t \n\t\tlen = dtl1_write(iobase, 32, skb->data, skb->len);\n\n\t\tif (len == skb->len) {\n\t\t\tset_bit(XMIT_WAITING, &(info->tx_state));\n\t\t\tkfree_skb(skb);\n\t\t} else {\n\t\t\tskb_pull(skb, len);\n\t\t\tskb_queue_head(&(info->txq), skb);\n\t\t}\n\n\t\tinfo->hdev->stat.byte_tx += len;\n\n\t} while (test_bit(XMIT_WAKEUP, &(info->tx_state)));\n\n\tclear_bit(XMIT_SENDING, &(info->tx_state));\n}\n\n\nstatic void dtl1_control(struct dtl1_info *info, struct sk_buff *skb)\n{\n\tu8 flowmask = *(u8 *)skb->data;\n\tint i;\n\n\tprintk(KERN_INFO \"Bluetooth: Nokia control data =\");\n\tfor (i = 0; i < skb->len; i++)\n\t\tprintk(\" %02x\", skb->data[i]);\n\n\tprintk(\"\\n\");\n\n\t \n\tif (((info->flowmask & 0x07) == 0) && ((flowmask & 0x07) != 0)) {\n\t\tclear_bit(XMIT_WAITING, &(info->tx_state));\n\t\tdtl1_write_wakeup(info);\n\t}\n\n\tinfo->flowmask = flowmask;\n\n\tkfree_skb(skb);\n}\n\n\nstatic void dtl1_receive(struct dtl1_info *info)\n{\n\tunsigned int iobase;\n\tstruct nsh *nsh;\n\tint boguscount = 0;\n\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tdo {\n\t\tinfo->hdev->stat.byte_rx++;\n\n\t\t \n\t\tif (info->rx_skb == NULL) {\n\t\t\tinfo->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);\n\t\t\tif (!info->rx_skb) {\n\t\t\t\tBT_ERR(\"Can't allocate mem for new packet\");\n\t\t\t\tinfo->rx_state = RECV_WAIT_NSH;\n\t\t\t\tinfo->rx_count = NSHL;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tskb_put_u8(info->rx_skb, inb(iobase + UART_RX));\n\t\tnsh = (struct nsh *)info->rx_skb->data;\n\n\t\tinfo->rx_count--;\n\n\t\tif (info->rx_count == 0) {\n\n\t\t\tswitch (info->rx_state) {\n\t\t\tcase RECV_WAIT_NSH:\n\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\tinfo->rx_count = nsh->len + (nsh->len & 0x0001);\n\t\t\t\tbreak;\n\t\t\tcase RECV_WAIT_DATA:\n\t\t\t\thci_skb_pkt_type(info->rx_skb) = nsh->type;\n\n\t\t\t\t \n\t\t\t\tif (nsh->len & 0x0001) {\n\t\t\t\t\tinfo->rx_skb->tail--;\n\t\t\t\t\tinfo->rx_skb->len--;\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tskb_pull(info->rx_skb, NSHL);\n\n\t\t\t\tswitch (hci_skb_pkt_type(info->rx_skb)) {\n\t\t\t\tcase 0x80:\n\t\t\t\t\t \n\t\t\t\t\tdtl1_control(info, info->rx_skb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x82:\n\t\t\t\tcase 0x83:\n\t\t\t\tcase 0x84:\n\t\t\t\t\t \n\t\t\t\t\thci_skb_pkt_type(info->rx_skb) &= 0x0f;\n\t\t\t\t\thci_recv_frame(info->hdev, info->rx_skb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t \n\t\t\t\t\tBT_ERR(\"Unknown HCI packet with type 0x%02x received\",\n\t\t\t\t\t       hci_skb_pkt_type(info->rx_skb));\n\t\t\t\t\tkfree_skb(info->rx_skb);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinfo->rx_state = RECV_WAIT_NSH;\n\t\t\t\tinfo->rx_count = NSHL;\n\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\t \n\t\tif (boguscount++ > 32)\n\t\t\tbreak;\n\n\t} while (inb(iobase + UART_LSR) & UART_LSR_DR);\n}\n\n\nstatic irqreturn_t dtl1_interrupt(int irq, void *dev_inst)\n{\n\tstruct dtl1_info *info = dev_inst;\n\tunsigned int iobase;\n\tunsigned char msr;\n\tint boguscount = 0;\n\tint iir, lsr;\n\tirqreturn_t r = IRQ_NONE;\n\n\tif (!info || !info->hdev)\n\t\t \n\t\treturn IRQ_NONE;\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tspin_lock(&(info->lock));\n\n\tiir = inb(iobase + UART_IIR) & UART_IIR_ID;\n\twhile (iir) {\n\n\t\tr = IRQ_HANDLED;\n\t\t \n\t\tlsr = inb(iobase + UART_LSR);\n\n\t\tswitch (iir) {\n\t\tcase UART_IIR_RLSI:\n\t\t\tBT_ERR(\"RLSI\");\n\t\t\tbreak;\n\t\tcase UART_IIR_RDI:\n\t\t\t \n\t\t\tdtl1_receive(info);\n\t\t\tbreak;\n\t\tcase UART_IIR_THRI:\n\t\t\tif (lsr & UART_LSR_THRE) {\n\t\t\t\t \n\t\t\t\tdtl1_write_wakeup(info);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBT_ERR(\"Unhandled IIR=%#x\", iir);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (boguscount++ > 100)\n\t\t\tbreak;\n\n\t\tiir = inb(iobase + UART_IIR) & UART_IIR_ID;\n\n\t}\n\n\tmsr = inb(iobase + UART_MSR);\n\n\tif (info->ri_latch ^ (msr & UART_MSR_RI)) {\n\t\tinfo->ri_latch = msr & UART_MSR_RI;\n\t\tclear_bit(XMIT_WAITING, &(info->tx_state));\n\t\tdtl1_write_wakeup(info);\n\t\tr = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&(info->lock));\n\n\treturn r;\n}\n\n\n\n \n\n\nstatic int dtl1_hci_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\n\nstatic int dtl1_hci_flush(struct hci_dev *hdev)\n{\n\tstruct dtl1_info *info = hci_get_drvdata(hdev);\n\n\t \n\tskb_queue_purge(&(info->txq));\n\n\treturn 0;\n}\n\n\nstatic int dtl1_hci_close(struct hci_dev *hdev)\n{\n\tdtl1_hci_flush(hdev);\n\n\treturn 0;\n}\n\n\nstatic int dtl1_hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct dtl1_info *info = hci_get_drvdata(hdev);\n\tstruct sk_buff *s;\n\tstruct nsh nsh;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tnsh.type = 0x81;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tnsh.type = 0x82;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tnsh.type = 0x83;\n\t\tbreak;\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\n\tnsh.zero = 0;\n\tnsh.len = skb->len;\n\n\ts = bt_skb_alloc(NSHL + skb->len + 1, GFP_ATOMIC);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\tskb_reserve(s, NSHL);\n\tskb_copy_from_linear_data(skb, skb_put(s, skb->len), skb->len);\n\tif (skb->len & 0x0001)\n\t\tskb_put_u8(s, 0);\t \n\n\t \n\tmemcpy(skb_push(s, NSHL), &nsh, NSHL);\n\tskb_queue_tail(&(info->txq), s);\n\n\tdtl1_write_wakeup(info);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n\n\n \n\n\nstatic int dtl1_open(struct dtl1_info *info)\n{\n\tunsigned long flags;\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\tstruct hci_dev *hdev;\n\n\tspin_lock_init(&(info->lock));\n\n\tskb_queue_head_init(&(info->txq));\n\n\tinfo->rx_state = RECV_WAIT_NSH;\n\tinfo->rx_count = NSHL;\n\tinfo->rx_skb = NULL;\n\n\tset_bit(XMIT_WAITING, &(info->tx_state));\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->hdev = hdev;\n\n\thdev->bus = HCI_PCCARD;\n\thci_set_drvdata(hdev, info);\n\tSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\n\n\thdev->open  = dtl1_hci_open;\n\thdev->close = dtl1_hci_close;\n\thdev->flush = dtl1_hci_flush;\n\thdev->send  = dtl1_hci_send_frame;\n\n\tspin_lock_irqsave(&(info->lock), flags);\n\n\t \n\toutb(0, iobase + UART_MCR);\n\n\t \n\toutb(0, iobase + UART_IER);\n\n\t \n\toutb(UART_LCR_WLEN8, iobase + UART_LCR);\t \n\toutb((UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2), iobase + UART_MCR);\n\n\tinfo->ri_latch = inb(info->p_dev->resource[0]->start + UART_MSR)\n\t\t\t\t& UART_MSR_RI;\n\n\t \n\toutb(UART_IER_RLSI | UART_IER_RDI | UART_IER_THRI, iobase + UART_IER);\n\n\tspin_unlock_irqrestore(&(info->lock), flags);\n\n\t \n\tmsleep(2000);\n\n\t \n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tinfo->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int dtl1_close(struct dtl1_info *info)\n{\n\tunsigned long flags;\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\tstruct hci_dev *hdev = info->hdev;\n\n\tif (!hdev)\n\t\treturn -ENODEV;\n\n\tdtl1_hci_close(hdev);\n\n\tspin_lock_irqsave(&(info->lock), flags);\n\n\t \n\toutb(0, iobase + UART_MCR);\n\n\t \n\toutb(0, iobase + UART_IER);\n\n\tspin_unlock_irqrestore(&(info->lock), flags);\n\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n\n\treturn 0;\n}\n\nstatic int dtl1_probe(struct pcmcia_device *link)\n{\n\tstruct dtl1_info *info;\n\n\t \n\tinfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_IO;\n\n\treturn dtl1_config(link);\n}\n\n\nstatic void dtl1_detach(struct pcmcia_device *link)\n{\n\tstruct dtl1_info *info = link->priv;\n\n\tdtl1_close(info);\n\tpcmcia_disable_device(link);\n}\n\nstatic int dtl1_confcheck(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tif ((p_dev->resource[1]->end) || (p_dev->resource[1]->end < 8))\n\t\treturn -ENODEV;\n\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int dtl1_config(struct pcmcia_device *link)\n{\n\tstruct dtl1_info *info = link->priv;\n\tint ret;\n\n\t \n\tlink->resource[0]->end = 8;\n\tret = pcmcia_loop_config(link, dtl1_confcheck, NULL);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_request_irq(link, dtl1_interrupt);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tret = dtl1_open(info);\n\tif (ret)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tdtl1_detach(link);\n\treturn ret;\n}\n\nstatic const struct pcmcia_device_id dtl1_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"Nokia Mobile Phones\", \"DTL-1\", 0xe1bfdd64, 0xe168480d),\n\tPCMCIA_DEVICE_PROD_ID12(\"Nokia Mobile Phones\", \"DTL-4\", 0xe1bfdd64, 0x9102bc82),\n\tPCMCIA_DEVICE_PROD_ID12(\"Socket\", \"CF\", 0xb38bcc2e, 0x44ebf863),\n\tPCMCIA_DEVICE_PROD_ID12(\"Socket\", \"CF+ Personal Network Card\", 0xb38bcc2e, 0xe732bae3),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, dtl1_ids);\n\nstatic struct pcmcia_driver dtl1_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"dtl1_cs\",\n\t.probe\t\t= dtl1_probe,\n\t.remove\t\t= dtl1_detach,\n\t.id_table\t= dtl1_ids,\n};\nmodule_pcmcia_driver(dtl1_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}