{
  "module_name": "hci_ag6xx.c",
  "hash_id": "966fefa64d22d9506199b9de464afa67cd9502cd28a612d28ceef07f6f601fb3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_ag6xx.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n#include \"btintel.h\"\n\nstruct ag6xx_data {\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n};\n\nstruct pbn_entry {\n\t__le32 addr;\n\t__le32 plen;\n\t__u8 data[];\n} __packed;\n\nstatic int ag6xx_open(struct hci_uart *hu)\n{\n\tstruct ag6xx_data *ag6xx;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tag6xx = kzalloc(sizeof(*ag6xx), GFP_KERNEL);\n\tif (!ag6xx)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&ag6xx->txq);\n\n\thu->priv = ag6xx;\n\treturn 0;\n}\n\nstatic int ag6xx_close(struct hci_uart *hu)\n{\n\tstruct ag6xx_data *ag6xx = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ag6xx->txq);\n\tkfree_skb(ag6xx->rx_skb);\n\tkfree(ag6xx);\n\n\thu->priv = NULL;\n\treturn 0;\n}\n\nstatic int ag6xx_flush(struct hci_uart *hu)\n{\n\tstruct ag6xx_data *ag6xx = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ag6xx->txq);\n\treturn 0;\n}\n\nstatic struct sk_buff *ag6xx_dequeue(struct hci_uart *hu)\n{\n\tstruct ag6xx_data *ag6xx = hu->priv;\n\tstruct sk_buff *skb;\n\n\tskb = skb_dequeue(&ag6xx->txq);\n\tif (!skb)\n\t\treturn skb;\n\n\t \n\tmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\n\treturn skb;\n}\n\nstatic int ag6xx_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct ag6xx_data *ag6xx = hu->priv;\n\n\tskb_queue_tail(&ag6xx->txq, skb);\n\treturn 0;\n}\n\nstatic const struct h4_recv_pkt ag6xx_recv_pkts[] = {\n\t{ H4_RECV_ACL,    .recv = hci_recv_frame   },\n\t{ H4_RECV_SCO,    .recv = hci_recv_frame   },\n\t{ H4_RECV_EVENT,  .recv = hci_recv_frame   },\n};\n\nstatic int ag6xx_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct ag6xx_data *ag6xx = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tag6xx->rx_skb = h4_recv_buf(hu->hdev, ag6xx->rx_skb, data, count,\n\t\t\t\t    ag6xx_recv_pkts,\n\t\t\t\t    ARRAY_SIZE(ag6xx_recv_pkts));\n\tif (IS_ERR(ag6xx->rx_skb)) {\n\t\tint err = PTR_ERR(ag6xx->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tag6xx->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic int intel_mem_write(struct hci_dev *hdev, u32 addr, u32 plen,\n\t\t\t   const void *data)\n{\n\t \n\twhile (plen > 0) {\n\t\tstruct sk_buff *skb;\n\t\tu8 cmd_param[253], fragment_len = (plen > 247) ? 247 : plen;\n\t\t__le32 leaddr = cpu_to_le32(addr);\n\n\t\tmemcpy(cmd_param, &leaddr, 4);\n\t\tcmd_param[4] = 0;\n\t\tcmd_param[5] = fragment_len;\n\t\tmemcpy(cmd_param + 6, data, fragment_len);\n\n\t\tskb = __hci_cmd_sync(hdev, 0xfc8e, fragment_len + 6, cmd_param,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\t\tkfree_skb(skb);\n\n\t\tplen -= fragment_len;\n\t\tdata += fragment_len;\n\t\taddr += fragment_len;\n\t}\n\n\treturn 0;\n}\n\nstatic int ag6xx_setup(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\tstruct intel_version ver;\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tchar fwname[64];\n\tbool patched = false;\n\tint err;\n\n\thu->hdev->set_diag = btintel_set_diag;\n\thu->hdev->set_bdaddr = btintel_set_bdaddr;\n\n\terr = btintel_enter_mfg(hdev);\n\tif (err)\n\t\treturn err;\n\n\terr = btintel_read_version(hdev, &ver);\n\tif (err)\n\t\treturn err;\n\n\tbtintel_version_info(hdev, &ver);\n\n\t \n\tif (ver.hw_platform != 0x37) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware platform: 0x%X\",\n\t\t\t   ver.hw_platform);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (ver.hw_variant != 0x0a) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant: 0x%x\",\n\t\t\t   ver.hw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-hw-%x.%x.bddata\",\n\t\t ver.hw_platform, ver.hw_variant);\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to open Intel bddata file: %s (%d)\",\n\t\t\t   fwname, err);\n\t\tgoto patch;\n\t}\n\n\tbt_dev_info(hdev, \"Applying bddata (%s)\", fwname);\n\n\tskb = __hci_cmd_sync_ev(hdev, 0xfc2f, fw->size, fw->data,\n\t\t\t\tHCI_EV_CMD_STATUS, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Applying bddata failed (%ld)\", PTR_ERR(skb));\n\t\trelease_firmware(fw);\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\trelease_firmware(fw);\n\npatch:\n\t \n\tif (ver.fw_patch_num) {\n\t\tbt_dev_info(hdev, \"Device is already patched. patch num: %02x\",\n\t\t\t    ver.fw_patch_num);\n\t\tpatched = true;\n\t\tgoto complete;\n\t}\n\n\tsnprintf(fwname, sizeof(fwname),\n\t\t \"intel/ibt-hw-%x.%x.%x-fw-%x.%x.%x.%x.%x.pbn\",\n\t\t ver.hw_platform, ver.hw_variant, ver.hw_revision,\n\t\t ver.fw_variant,  ver.fw_revision, ver.fw_build_num,\n\t\t ver.fw_build_ww, ver.fw_build_yy);\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to open Intel patch file: %s(%d)\",\n\t\t\t   fwname, err);\n\t\tgoto complete;\n\t}\n\tfw_ptr = fw->data;\n\n\tbt_dev_info(hdev, \"Patching firmware file (%s)\", fwname);\n\n\t \n\twhile (fw->size > fw_ptr - fw->data) {\n\t\tstruct pbn_entry *pbn = (void *)fw_ptr;\n\t\tu32 addr, plen;\n\n\t\tif (pbn->addr == 0xffffffff) {\n\t\t\tbt_dev_info(hdev, \"Patching complete\");\n\t\t\tpatched = true;\n\t\t\tbreak;\n\t\t}\n\n\t\taddr = le32_to_cpu(pbn->addr);\n\t\tplen = le32_to_cpu(pbn->plen);\n\n\t\tif (fw->data + fw->size <= pbn->data + plen) {\n\t\t\tbt_dev_info(hdev, \"Invalid patch len (%d)\", plen);\n\t\t\tbreak;\n\t\t}\n\n\t\tbt_dev_info(hdev, \"Patching %td/%zu\", (fw_ptr - fw->data),\n\t\t\t    fw->size);\n\n\t\terr = intel_mem_write(hdev, addr, plen, pbn->data);\n\t\tif (err) {\n\t\t\tbt_dev_err(hdev, \"Patching failed\");\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_ptr = pbn->data + plen;\n\t}\n\n\trelease_firmware(fw);\n\ncomplete:\n\t \n\terr = btintel_exit_mfg(hdev, true, patched);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbtintel_set_event_mask_mfg(hdev, false);\n\n\tbtintel_check_bdaddr(hdev);\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto ag6xx_proto = {\n\t.id\t\t= HCI_UART_AG6XX,\n\t.name\t\t= \"AG6XX\",\n\t.manufacturer\t= 2,\n\t.open\t\t= ag6xx_open,\n\t.close\t\t= ag6xx_close,\n\t.flush\t\t= ag6xx_flush,\n\t.setup\t\t= ag6xx_setup,\n\t.recv\t\t= ag6xx_recv,\n\t.enqueue\t= ag6xx_enqueue,\n\t.dequeue\t= ag6xx_dequeue,\n};\n\nint __init ag6xx_init(void)\n{\n\treturn hci_uart_register_proto(&ag6xx_proto);\n}\n\nint __exit ag6xx_deinit(void)\n{\n\treturn hci_uart_unregister_proto(&ag6xx_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}