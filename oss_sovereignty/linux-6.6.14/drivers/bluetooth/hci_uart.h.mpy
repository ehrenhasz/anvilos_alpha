{
  "module_name": "hci_uart.h",
  "hash_id": "c0dec87c62062d9157108a0f82870dac5fc05413ccf0e3bc58c8d4eb59a1d833",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_uart.h",
  "human_readable_source": " \n \n\n#ifndef N_HCI\n#define N_HCI\t15\n#endif\n\n \n#define HCIUARTSETPROTO\t\t_IOW('U', 200, int)\n#define HCIUARTGETPROTO\t\t_IOR('U', 201, int)\n#define HCIUARTGETDEVICE\t_IOR('U', 202, int)\n#define HCIUARTSETFLAGS\t\t_IOW('U', 203, int)\n#define HCIUARTGETFLAGS\t\t_IOR('U', 204, int)\n\n \n#define HCI_UART_MAX_PROTO\t12\n\n#define HCI_UART_H4\t0\n#define HCI_UART_BCSP\t1\n#define HCI_UART_3WIRE\t2\n#define HCI_UART_H4DS\t3\n#define HCI_UART_LL\t4\n#define HCI_UART_ATH3K\t5\n#define HCI_UART_INTEL\t6\n#define HCI_UART_BCM\t7\n#define HCI_UART_QCA\t8\n#define HCI_UART_AG6XX\t9\n#define HCI_UART_NOKIA\t10\n#define HCI_UART_MRVL\t11\n\n#define HCI_UART_RAW_DEVICE\t0\n#define HCI_UART_RESET_ON_INIT\t1\n#define HCI_UART_CREATE_AMP\t2\n#define HCI_UART_INIT_PENDING\t3\n#define HCI_UART_EXT_CONFIG\t4\n#define HCI_UART_VND_DETECT\t5\n\nstruct hci_uart;\nstruct serdev_device;\n\nstruct hci_uart_proto {\n\tunsigned int id;\n\tconst char *name;\n\tunsigned int manufacturer;\n\tunsigned int init_speed;\n\tunsigned int oper_speed;\n\tint (*open)(struct hci_uart *hu);\n\tint (*close)(struct hci_uart *hu);\n\tint (*flush)(struct hci_uart *hu);\n\tint (*setup)(struct hci_uart *hu);\n\tint (*set_baudrate)(struct hci_uart *hu, unsigned int speed);\n\tint (*recv)(struct hci_uart *hu, const void *data, int len);\n\tint (*enqueue)(struct hci_uart *hu, struct sk_buff *skb);\n\tstruct sk_buff *(*dequeue)(struct hci_uart *hu);\n};\n\nstruct hci_uart {\n\tstruct tty_struct\t*tty;\n\tstruct serdev_device\t*serdev;\n\tstruct hci_dev\t\t*hdev;\n\tunsigned long\t\tflags;\n\tunsigned long\t\thdev_flags;\n\n\tstruct work_struct\tinit_ready;\n\tstruct work_struct\twrite_work;\n\n\tconst struct hci_uart_proto *proto;\n\tstruct percpu_rw_semaphore proto_lock;\t \n\tvoid\t\t\t*priv;\n\n\tstruct sk_buff\t\t*tx_skb;\n\tunsigned long\t\ttx_state;\n\n\tunsigned int init_speed;\n\tunsigned int oper_speed;\n\n\tu8\t\t\talignment;\n\tu8\t\t\tpadding;\n};\n\n \n#define HCI_UART_PROTO_SET\t\t0\n#define HCI_UART_REGISTERED\t\t1\n#define HCI_UART_PROTO_READY\t\t2\n#define HCI_UART_NO_SUSPEND_NOTIFIER\t3\n\n \n#define HCI_UART_SENDING\t1\n#define HCI_UART_TX_WAKEUP\t2\n\nint hci_uart_register_proto(const struct hci_uart_proto *p);\nint hci_uart_unregister_proto(const struct hci_uart_proto *p);\nint hci_uart_register_device(struct hci_uart *hu, const struct hci_uart_proto *p);\nvoid hci_uart_unregister_device(struct hci_uart *hu);\n\nint hci_uart_tx_wakeup(struct hci_uart *hu);\nint hci_uart_wait_until_sent(struct hci_uart *hu);\nint hci_uart_init_ready(struct hci_uart *hu);\nvoid hci_uart_init_work(struct work_struct *work);\nvoid hci_uart_set_baudrate(struct hci_uart *hu, unsigned int speed);\nbool hci_uart_has_flow_control(struct hci_uart *hu);\nvoid hci_uart_set_flow_control(struct hci_uart *hu, bool enable);\nvoid hci_uart_set_speeds(struct hci_uart *hu, unsigned int init_speed,\n\t\t\t unsigned int oper_speed);\n\n#ifdef CONFIG_BT_HCIUART_H4\nint h4_init(void);\nint h4_deinit(void);\n\nstruct h4_recv_pkt {\n\tu8  type;\t \n\tu8  hlen;\t \n\tu8  loff;\t \n\tu8  lsize;\t \n\tu16 maxlen;\t \n\tint (*recv)(struct hci_dev *hdev, struct sk_buff *skb);\n};\n\n#define H4_RECV_ACL \\\n\t.type = HCI_ACLDATA_PKT, \\\n\t.hlen = HCI_ACL_HDR_SIZE, \\\n\t.loff = 2, \\\n\t.lsize = 2, \\\n\t.maxlen = HCI_MAX_FRAME_SIZE \\\n\n#define H4_RECV_SCO \\\n\t.type = HCI_SCODATA_PKT, \\\n\t.hlen = HCI_SCO_HDR_SIZE, \\\n\t.loff = 2, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_MAX_SCO_SIZE\n\n#define H4_RECV_EVENT \\\n\t.type = HCI_EVENT_PKT, \\\n\t.hlen = HCI_EVENT_HDR_SIZE, \\\n\t.loff = 1, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_MAX_EVENT_SIZE\n\n#define H4_RECV_ISO \\\n\t.type = HCI_ISODATA_PKT, \\\n\t.hlen = HCI_ISO_HDR_SIZE, \\\n\t.loff = 2, \\\n\t.lsize = 2, \\\n\t.maxlen = HCI_MAX_FRAME_SIZE \\\n\nstruct sk_buff *h4_recv_buf(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t    const unsigned char *buffer, int count,\n\t\t\t    const struct h4_recv_pkt *pkts, int pkts_count);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_BCSP\nint bcsp_init(void);\nint bcsp_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_LL\nint ll_init(void);\nint ll_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_ATH3K\nint ath_init(void);\nint ath_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_3WIRE\nint h5_init(void);\nint h5_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_INTEL\nint intel_init(void);\nint intel_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_BCM\nint bcm_init(void);\nint bcm_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_QCA\nint qca_init(void);\nint qca_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_AG6XX\nint ag6xx_init(void);\nint ag6xx_deinit(void);\n#endif\n\n#ifdef CONFIG_BT_HCIUART_MRVL\nint mrvl_init(void);\nint mrvl_deinit(void);\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}