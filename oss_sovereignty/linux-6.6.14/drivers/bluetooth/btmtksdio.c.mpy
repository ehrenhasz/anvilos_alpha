{
  "module_name": "btmtksdio.c",
  "hash_id": "fb21be80930e5903764a7d51017e0e940a0f65171d8a411dafecc71b2de356c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btmtksdio.c",
  "human_readable_source": "\n\n\n \n\n#include <asm/unaligned.h>\n#include <linux/atomic.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/skbuff.h>\n\n#include <linux/mmc/host.h>\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"h4_recv.h\"\n#include \"btmtk.h\"\n\n#define VERSION \"0.1\"\n\n#define MTKBTSDIO_AUTOSUSPEND_DELAY\t1000\n\nstatic bool enable_autosuspend = true;\n\nstruct btmtksdio_data {\n\tconst char *fwname;\n\tu16 chipid;\n\tbool lp_mbox_supported;\n};\n\nstatic const struct btmtksdio_data mt7663_data = {\n\t.fwname = FIRMWARE_MT7663,\n\t.chipid = 0x7663,\n\t.lp_mbox_supported = false,\n};\n\nstatic const struct btmtksdio_data mt7668_data = {\n\t.fwname = FIRMWARE_MT7668,\n\t.chipid = 0x7668,\n\t.lp_mbox_supported = false,\n};\n\nstatic const struct btmtksdio_data mt7921_data = {\n\t.fwname = FIRMWARE_MT7961,\n\t.chipid = 0x7921,\n\t.lp_mbox_supported = true,\n};\n\nstatic const struct sdio_device_id btmtksdio_table[] = {\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7663),\n\t .driver_data = (kernel_ulong_t)&mt7663_data },\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7668),\n\t .driver_data = (kernel_ulong_t)&mt7668_data },\n\t{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, SDIO_DEVICE_ID_MEDIATEK_MT7961),\n\t .driver_data = (kernel_ulong_t)&mt7921_data },\n\t{ }\t \n};\nMODULE_DEVICE_TABLE(sdio, btmtksdio_table);\n\n#define MTK_REG_CHLPCR\t\t0x4\t \n#define C_INT_EN_SET\t\tBIT(0)\n#define C_INT_EN_CLR\t\tBIT(1)\n#define C_FW_OWN_REQ_SET\tBIT(8)   \n#define C_COM_DRV_OWN\t\tBIT(8)   \n#define C_FW_OWN_REQ_CLR\tBIT(9)\n\n#define MTK_REG_CSDIOCSR\t0x8\n#define SDIO_RE_INIT_EN\t\tBIT(0)\n#define SDIO_INT_CTL\t\tBIT(2)\n\n#define MTK_REG_CHCR\t\t0xc\n#define C_INT_CLR_CTRL\t\tBIT(1)\n#define BT_RST_DONE\t\tBIT(8)\n\n \n#define MTK_REG_CHISR\t\t0x10\n#define MTK_REG_CHIER\t\t0x14\n#define FW_OWN_BACK_INT\t\tBIT(0)\n#define RX_DONE_INT\t\tBIT(1)\n#define TX_EMPTY\t\tBIT(2)\n#define TX_FIFO_OVERFLOW\tBIT(8)\n#define FW_MAILBOX_INT\t\tBIT(15)\n#define INT_MASK\t\tGENMASK(15, 0)\n#define RX_PKT_LEN\t\tGENMASK(31, 16)\n\n#define MTK_REG_CSICR\t\t0xc0\n#define CSICR_CLR_MBOX_ACK BIT(0)\n#define MTK_REG_PH2DSM0R\t0xc4\n#define PH2DSM0R_DRIVER_OWN\tBIT(0)\n#define MTK_REG_PD2HRM0R\t0xdc\n#define PD2HRM0R_DRV_OWN\tBIT(0)\n\n#define MTK_REG_CTDR\t\t0x18\n\n#define MTK_REG_CRDR\t\t0x1c\n\n#define MTK_REG_CRPLR\t\t0x24\n\n#define MTK_SDIO_BLOCK_SIZE\t256\n\n#define BTMTKSDIO_TX_WAIT_VND_EVT\t1\n#define BTMTKSDIO_HW_TX_READY\t\t2\n#define BTMTKSDIO_FUNC_ENABLED\t\t3\n#define BTMTKSDIO_PATCH_ENABLED\t\t4\n#define BTMTKSDIO_HW_RESET_ACTIVE\t5\n\nstruct mtkbtsdio_hdr {\n\t__le16\tlen;\n\t__le16\treserved;\n\tu8\tbt_type;\n} __packed;\n\nstruct btmtksdio_dev {\n\tstruct hci_dev *hdev;\n\tstruct sdio_func *func;\n\tstruct device *dev;\n\n\tstruct work_struct txrx_work;\n\tunsigned long tx_state;\n\tstruct sk_buff_head txq;\n\n\tstruct sk_buff *evt_skb;\n\n\tconst struct btmtksdio_data *data;\n\n\tstruct gpio_desc *reset;\n};\n\nstatic int mtk_hci_wmt_sync(struct hci_dev *hdev,\n\t\t\t    struct btmtk_hci_wmt_params *wmt_params)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_evt_funcc *wmt_evt_funcc;\n\tstruct btmtk_hci_wmt_evt_reg *wmt_evt_reg;\n\tu32 hlen, status = BTMTK_WMT_INVALID;\n\tstruct btmtk_hci_wmt_evt *wmt_evt;\n\tstruct btmtk_hci_wmt_cmd *wc;\n\tstruct btmtk_wmt_hdr *hdr;\n\tint err;\n\n\t \n\thlen = sizeof(*hdr) + wmt_params->dlen;\n\tif (hlen > 255)\n\t\treturn -EINVAL;\n\n\twc = kzalloc(hlen, GFP_KERNEL);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\thdr = &wc->hdr;\n\thdr->dir = 1;\n\thdr->op = wmt_params->op;\n\thdr->dlen = cpu_to_le16(wmt_params->dlen + 1);\n\thdr->flag = wmt_params->flag;\n\tmemcpy(wc->data, wmt_params->data, wmt_params->dlen);\n\n\tset_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n\n\terr = __hci_cmd_send(hdev, 0xfc6f, hlen, wc);\n\tif (err < 0) {\n\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\tgoto err_free_wc;\n\t}\n\n\t \n\terr = wait_on_bit_timeout(&bdev->tx_state, BTMTKSDIO_TX_WAIT_VND_EVT,\n\t\t\t\t  TASK_INTERRUPTIBLE, HCI_INIT_TIMEOUT);\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command interrupted\");\n\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\tgoto err_free_wc;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command timed out\");\n\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\terr = -ETIMEDOUT;\n\t\tgoto err_free_wc;\n\t}\n\n\t \n\twmt_evt = (struct btmtk_hci_wmt_evt *)bdev->evt_skb->data;\n\tif (wmt_evt->whdr.op != hdr->op) {\n\t\tbt_dev_err(hdev, \"Wrong op received %d expected %d\",\n\t\t\t   wmt_evt->whdr.op, hdr->op);\n\t\terr = -EIO;\n\t\tgoto err_free_skb;\n\t}\n\n\tswitch (wmt_evt->whdr.op) {\n\tcase BTMTK_WMT_SEMAPHORE:\n\t\tif (wmt_evt->whdr.flag == 2)\n\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n\t\tbreak;\n\tcase BTMTK_WMT_FUNC_CTRL:\n\t\twmt_evt_funcc = (struct btmtk_hci_wmt_evt_funcc *)wmt_evt;\n\t\tif (be16_to_cpu(wmt_evt_funcc->status) == 0x404)\n\t\t\tstatus = BTMTK_WMT_ON_DONE;\n\t\telse if (be16_to_cpu(wmt_evt_funcc->status) == 0x420)\n\t\t\tstatus = BTMTK_WMT_ON_PROGRESS;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_ON_UNDONE;\n\t\tbreak;\n\tcase BTMTK_WMT_PATCH_DWNLD:\n\t\tif (wmt_evt->whdr.flag == 2)\n\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n\t\telse if (wmt_evt->whdr.flag == 1)\n\t\t\tstatus = BTMTK_WMT_PATCH_PROGRESS;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n\t\tbreak;\n\tcase BTMTK_WMT_REGISTER:\n\t\twmt_evt_reg = (struct btmtk_hci_wmt_evt_reg *)wmt_evt;\n\t\tif (le16_to_cpu(wmt_evt->whdr.dlen) == 12)\n\t\t\tstatus = le32_to_cpu(wmt_evt_reg->val);\n\t\tbreak;\n\t}\n\n\tif (wmt_params->status)\n\t\t*wmt_params->status = status;\n\nerr_free_skb:\n\tkfree_skb(bdev->evt_skb);\n\tbdev->evt_skb = NULL;\nerr_free_wc:\n\tkfree(wc);\n\n\treturn err;\n}\n\nstatic int btmtksdio_tx_packet(struct btmtksdio_dev *bdev,\n\t\t\t       struct sk_buff *skb)\n{\n\tstruct mtkbtsdio_hdr *sdio_hdr;\n\tint err;\n\n\t \n\tif (unlikely(skb_headroom(skb) < sizeof(*sdio_hdr))) {\n\t\terr = pskb_expand_head(skb, sizeof(*sdio_hdr), 0,\n\t\t\t\t       GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tskb_push(skb, sizeof(*sdio_hdr));\n\n\tsdio_hdr = (void *)skb->data;\n\tsdio_hdr->len = cpu_to_le16(skb->len);\n\tsdio_hdr->reserved = cpu_to_le16(0);\n\tsdio_hdr->bt_type = hci_skb_pkt_type(skb);\n\n\tclear_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);\n\terr = sdio_writesb(bdev->func, MTK_REG_CTDR, skb->data,\n\t\t\t   round_up(skb->len, MTK_SDIO_BLOCK_SIZE));\n\tif (err < 0)\n\t\tgoto err_skb_pull;\n\n\tbdev->hdev->stat.byte_tx += skb->len;\n\n\tkfree_skb(skb);\n\n\treturn 0;\n\nerr_skb_pull:\n\tskb_pull(skb, sizeof(*sdio_hdr));\n\n\treturn err;\n}\n\nstatic u32 btmtksdio_drv_own_query(struct btmtksdio_dev *bdev)\n{\n\treturn sdio_readl(bdev->func, MTK_REG_CHLPCR, NULL);\n}\n\nstatic u32 btmtksdio_drv_own_query_79xx(struct btmtksdio_dev *bdev)\n{\n\treturn sdio_readl(bdev->func, MTK_REG_PD2HRM0R, NULL);\n}\n\nstatic u32 btmtksdio_chcr_query(struct btmtksdio_dev *bdev)\n{\n\treturn sdio_readl(bdev->func, MTK_REG_CHCR, NULL);\n}\n\nstatic int btmtksdio_fw_pmctrl(struct btmtksdio_dev *bdev)\n{\n\tu32 status;\n\tint err;\n\n\tsdio_claim_host(bdev->func);\n\n\tif (bdev->data->lp_mbox_supported &&\n\t    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state)) {\n\t\tsdio_writel(bdev->func, CSICR_CLR_MBOX_ACK, MTK_REG_CSICR,\n\t\t\t    &err);\n\t\terr = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,\n\t\t\t\t\t status, !(status & PD2HRM0R_DRV_OWN),\n\t\t\t\t\t 2000, 1000000);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(bdev->hdev, \"mailbox ACK not cleared\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t \n\tsdio_writel(bdev->func, C_FW_OWN_REQ_SET, MTK_REG_CHLPCR, &err);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,\n\t\t\t\t !(status & C_COM_DRV_OWN), 2000, 1000000);\n\nout:\n\tsdio_release_host(bdev->func);\n\n\tif (err < 0)\n\t\tbt_dev_err(bdev->hdev, \"Cannot return ownership to device\");\n\n\treturn err;\n}\n\nstatic int btmtksdio_drv_pmctrl(struct btmtksdio_dev *bdev)\n{\n\tu32 status;\n\tint err;\n\n\tsdio_claim_host(bdev->func);\n\n\t \n\tsdio_writel(bdev->func, C_FW_OWN_REQ_CLR, MTK_REG_CHLPCR, &err);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,\n\t\t\t\t status & C_COM_DRV_OWN, 2000, 1000000);\n\n\tif (!err && bdev->data->lp_mbox_supported &&\n\t    test_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state))\n\t\terr = readx_poll_timeout(btmtksdio_drv_own_query_79xx, bdev,\n\t\t\t\t\t status, status & PD2HRM0R_DRV_OWN,\n\t\t\t\t\t 2000, 1000000);\n\nout:\n\tsdio_release_host(bdev->func);\n\n\tif (err < 0)\n\t\tbt_dev_err(bdev->hdev, \"Cannot get ownership from device\");\n\n\treturn err;\n}\n\nstatic int btmtksdio_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tstruct hci_event_hdr *hdr = (void *)skb->data;\n\tu8 evt = hdr->evt;\n\tint err;\n\n\t \n\tif (test_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state)) {\n\t\tbdev->evt_skb = skb_clone(skb, GFP_KERNEL);\n\t\tif (!bdev->evt_skb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terr = hci_recv_frame(hdev, skb);\n\tif (err < 0)\n\t\tgoto err_free_skb;\n\n\tif (evt == HCI_EV_WMT) {\n\t\tif (test_and_clear_bit(BTMTKSDIO_TX_WAIT_VND_EVT,\n\t\t\t\t       &bdev->tx_state)) {\n\t\t\t \n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_bit(&bdev->tx_state, BTMTKSDIO_TX_WAIT_VND_EVT);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_skb:\n\tkfree_skb(bdev->evt_skb);\n\tbdev->evt_skb = NULL;\n\nerr_out:\n\treturn err;\n}\n\nstatic int btmtksdio_recv_acl(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tu16 handle = le16_to_cpu(hci_acl_hdr(skb)->handle);\n\n\tswitch (handle) {\n\tcase 0xfc6f:\n\t\t \n\t\tpm_runtime_forbid(bdev->dev);\n\t\tfallthrough;\n\tcase 0x05ff:\n\tcase 0x05fe:\n\t\t \n\t\treturn hci_recv_diag(hdev, skb);\n\t}\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic const struct h4_recv_pkt mtk_recv_pkts[] = {\n\t{ H4_RECV_ACL,      .recv = btmtksdio_recv_acl },\n\t{ H4_RECV_SCO,      .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,    .recv = btmtksdio_recv_event },\n};\n\nstatic int btmtksdio_rx_packet(struct btmtksdio_dev *bdev, u16 rx_size)\n{\n\tconst struct h4_recv_pkt *pkts = mtk_recv_pkts;\n\tint pkts_count = ARRAY_SIZE(mtk_recv_pkts);\n\tstruct mtkbtsdio_hdr *sdio_hdr;\n\tint err, i, pad_size;\n\tstruct sk_buff *skb;\n\tu16 dlen;\n\n\tif (rx_size < sizeof(*sdio_hdr))\n\t\treturn -EILSEQ;\n\n\t \n\tskb = bt_skb_alloc(rx_size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put(skb, rx_size);\n\n\terr = sdio_readsb(bdev->func, skb->data, MTK_REG_CRDR, rx_size);\n\tif (err < 0)\n\t\tgoto err_kfree_skb;\n\n\tsdio_hdr = (void *)skb->data;\n\n\t \n\terr = -EILSEQ;\n\n\tif (rx_size != le16_to_cpu(sdio_hdr->len)) {\n\t\tbt_dev_err(bdev->hdev, \"Rx size in sdio header is mismatched \");\n\t\tgoto err_kfree_skb;\n\t}\n\n\thci_skb_pkt_type(skb) = sdio_hdr->bt_type;\n\n\t \n\tskb_pull(skb, sizeof(*sdio_hdr));\n\n\t \n\tfor (i = 0; i < pkts_count; i++) {\n\t\tif (sdio_hdr->bt_type == (&pkts[i])->type)\n\t\t\tbreak;\n\t}\n\n\tif (i >= pkts_count) {\n\t\tbt_dev_err(bdev->hdev, \"Invalid bt type 0x%02x\",\n\t\t\t   sdio_hdr->bt_type);\n\t\tgoto err_kfree_skb;\n\t}\n\n\t \n\tif (skb->len < (&pkts[i])->hlen) {\n\t\tbt_dev_err(bdev->hdev, \"The size of bt header is mismatched\");\n\t\tgoto err_kfree_skb;\n\t}\n\n\tswitch ((&pkts[i])->lsize) {\n\tcase 1:\n\t\tdlen = skb->data[(&pkts[i])->loff];\n\t\tbreak;\n\tcase 2:\n\t\tdlen = get_unaligned_le16(skb->data +\n\t\t\t\t\t\t  (&pkts[i])->loff);\n\t\tbreak;\n\tdefault:\n\t\tgoto err_kfree_skb;\n\t}\n\n\tpad_size = skb->len - (&pkts[i])->hlen -  dlen;\n\n\t \n\tif (pad_size < 0) {\n\t\tbt_dev_err(bdev->hdev, \"The size of bt payload is mismatched\");\n\t\tgoto err_kfree_skb;\n\t}\n\n\t \n\tskb_trim(skb, skb->len - pad_size);\n\n\t \n\t(&pkts[i])->recv(bdev->hdev, skb);\n\n\tbdev->hdev->stat.byte_rx += rx_size;\n\n\treturn 0;\n\nerr_kfree_skb:\n\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstatic void btmtksdio_txrx_work(struct work_struct *work)\n{\n\tstruct btmtksdio_dev *bdev = container_of(work, struct btmtksdio_dev,\n\t\t\t\t\t\t  txrx_work);\n\tunsigned long txrx_timeout;\n\tu32 int_status, rx_size;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tpm_runtime_get_sync(bdev->dev);\n\n\tsdio_claim_host(bdev->func);\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, 0);\n\n\ttxrx_timeout = jiffies + 5 * HZ;\n\n\tdo {\n\t\tint_status = sdio_readl(bdev->func, MTK_REG_CHISR, NULL);\n\n\t\t \n\t\tsdio_writel(bdev->func, int_status, MTK_REG_CHISR, NULL);\n\t\tint_status &= INT_MASK;\n\n\t\tif ((int_status & FW_MAILBOX_INT) &&\n\t\t    bdev->data->chipid == 0x7921) {\n\t\t\tsdio_writel(bdev->func, PH2DSM0R_DRIVER_OWN,\n\t\t\t\t    MTK_REG_PH2DSM0R, 0);\n\t\t}\n\n\t\tif (int_status & FW_OWN_BACK_INT)\n\t\t\tbt_dev_dbg(bdev->hdev, \"Get fw own back\");\n\n\t\tif (int_status & TX_EMPTY)\n\t\t\tset_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);\n\n\t\telse if (unlikely(int_status & TX_FIFO_OVERFLOW))\n\t\t\tbt_dev_warn(bdev->hdev, \"Tx fifo overflow\");\n\n\t\tif (test_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state)) {\n\t\t\tskb = skb_dequeue(&bdev->txq);\n\t\t\tif (skb) {\n\t\t\t\terr = btmtksdio_tx_packet(bdev, skb);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tbdev->hdev->stat.err_tx++;\n\t\t\t\t\tskb_queue_head(&bdev->txq, skb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (int_status & RX_DONE_INT) {\n\t\t\trx_size = sdio_readl(bdev->func, MTK_REG_CRPLR, NULL);\n\t\t\trx_size = (rx_size & RX_PKT_LEN) >> 16;\n\t\t\tif (btmtksdio_rx_packet(bdev, rx_size) < 0)\n\t\t\t\tbdev->hdev->stat.err_rx++;\n\t\t}\n\t} while (int_status || time_is_before_jiffies(txrx_timeout));\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_SET, MTK_REG_CHLPCR, 0);\n\n\tsdio_release_host(bdev->func);\n\n\tpm_runtime_mark_last_busy(bdev->dev);\n\tpm_runtime_put_autosuspend(bdev->dev);\n}\n\nstatic void btmtksdio_interrupt(struct sdio_func *func)\n{\n\tstruct btmtksdio_dev *bdev = sdio_get_drvdata(func);\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, 0);\n\n\tschedule_work(&bdev->txrx_work);\n}\n\nstatic int btmtksdio_open(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tu32 val;\n\tint err;\n\n\tsdio_claim_host(bdev->func);\n\n\terr = sdio_enable_func(bdev->func);\n\tif (err < 0)\n\t\tgoto err_release_host;\n\n\tset_bit(BTMTKSDIO_FUNC_ENABLED, &bdev->tx_state);\n\n\terr = btmtksdio_drv_pmctrl(bdev);\n\tif (err < 0)\n\t\tgoto err_disable_func;\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, &err);\n\tif (err < 0)\n\t\tgoto err_disable_func;\n\n\tsdio_writel(bdev->func, 0, MTK_REG_CHIER, &err);\n\tif (err < 0)\n\t\tgoto err_disable_func;\n\n\terr = sdio_claim_irq(bdev->func, btmtksdio_interrupt);\n\tif (err < 0)\n\t\tgoto err_disable_func;\n\n\terr = sdio_set_block_size(bdev->func, MTK_SDIO_BLOCK_SIZE);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\t \n\tval = sdio_readl(bdev->func, MTK_REG_CSDIOCSR, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\tval |= SDIO_INT_CTL;\n\tsdio_writel(bdev->func, val, MTK_REG_CSDIOCSR, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\t \n\tval = sdio_readl(bdev->func, MTK_REG_CHCR, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\tval |= C_INT_CLR_CTRL;\n\tsdio_writel(bdev->func, val, MTK_REG_CHCR, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\t \n\tsdio_writel(bdev->func, RX_DONE_INT | TX_EMPTY | TX_FIFO_OVERFLOW,\n\t\t    MTK_REG_CHIER, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_SET, MTK_REG_CHLPCR, &err);\n\tif (err < 0)\n\t\tgoto err_release_irq;\n\n\tsdio_release_host(bdev->func);\n\n\treturn 0;\n\nerr_release_irq:\n\tsdio_release_irq(bdev->func);\n\nerr_disable_func:\n\tsdio_disable_func(bdev->func);\n\nerr_release_host:\n\tsdio_release_host(bdev->func);\n\n\treturn err;\n}\n\nstatic int btmtksdio_close(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\n\tsdio_claim_host(bdev->func);\n\n\t \n\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, NULL);\n\n\tsdio_release_irq(bdev->func);\n\n\tcancel_work_sync(&bdev->txrx_work);\n\n\tbtmtksdio_fw_pmctrl(bdev);\n\n\tclear_bit(BTMTKSDIO_FUNC_ENABLED, &bdev->tx_state);\n\tsdio_disable_func(bdev->func);\n\n\tsdio_release_host(bdev->func);\n\n\treturn 0;\n}\n\nstatic int btmtksdio_flush(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\n\tskb_queue_purge(&bdev->txq);\n\n\tcancel_work_sync(&bdev->txrx_work);\n\n\treturn 0;\n}\n\nstatic int btmtksdio_func_query(struct hci_dev *hdev)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tint status, err;\n\tu8 param = 0;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 4;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query function status (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn status;\n}\n\nstatic int mt76xx_setup(struct hci_dev *hdev, const char *fwname)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tstruct btmtk_tci_sleep tci_sleep;\n\tstruct sk_buff *skb;\n\tint err, status;\n\tu8 param = 0x1;\n\n\t \n\twmt_params.op = BTMTK_WMT_SEMAPHORE;\n\twmt_params.flag = 1;\n\twmt_params.dlen = 0;\n\twmt_params.data = NULL;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query firmware status (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (status == BTMTK_WMT_PATCH_DONE) {\n\t\tbt_dev_info(hdev, \"Firmware already downloaded\");\n\t\tgoto ignore_setup_fw;\n\t}\n\n\t \n\terr = btmtk_setup_firmware(hdev, fwname, mtk_hci_wmt_sync);\n\tif (err < 0)\n\t\treturn err;\n\nignore_setup_fw:\n\t \n\terr = readx_poll_timeout(btmtksdio_func_query, hdev, status,\n\t\t\t\t status < 0 || status != BTMTK_WMT_ON_PROGRESS,\n\t\t\t\t 2000, 5000000);\n\t \n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (status < 0)\n\t\treturn status;\n\n\tif (status == BTMTK_WMT_ON_DONE) {\n\t\tbt_dev_info(hdev, \"function already on\");\n\t\tgoto ignore_func_on;\n\t}\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\n\tset_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);\n\nignore_func_on:\n\t \n\ttci_sleep.mode = 0x5;\n\ttci_sleep.duration = cpu_to_le16(0x640);\n\ttci_sleep.host_duration = cpu_to_le16(0x640);\n\ttci_sleep.host_wakeup_pin = 0;\n\ttci_sleep.time_compensation = 0;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc7a, sizeof(tci_sleep), &tci_sleep,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Failed to apply low power setting (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int mt79xx_setup(struct hci_dev *hdev, const char *fwname)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tu8 param = 0x1;\n\tint err;\n\n\terr = btmtk_setup_firmware_79xx(hdev, fwname, mtk_hci_wmt_sync);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to setup 79xx firmware (%d)\", err);\n\t\treturn err;\n\t}\n\n\terr = btmtksdio_fw_pmctrl(bdev);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = btmtksdio_drv_pmctrl(bdev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\n\thci_set_msft_opcode(hdev, 0xFD30);\n\thci_set_aosp_capable(hdev);\n\tset_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);\n\n\treturn err;\n}\n\nstatic int btmtksdio_mtk_reg_read(struct hci_dev *hdev, u32 reg, u32 *val)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tstruct reg_read_cmd reg_read = {\n\t\t.type = 1,\n\t\t.num = 1,\n\t};\n\tu32 status;\n\tint err;\n\n\treg_read.addr = cpu_to_le32(reg);\n\twmt_params.op = BTMTK_WMT_REGISTER;\n\twmt_params.flag = BTMTK_WMT_REG_READ;\n\twmt_params.dlen = sizeof(reg_read);\n\twmt_params.data = &reg_read;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to read reg (%d)\", err);\n\t\treturn err;\n\t}\n\n\t*val = status;\n\n\treturn err;\n}\n\nstatic int btmtksdio_mtk_reg_write(struct hci_dev *hdev, u32 reg, u32 val, u32 mask)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tconst struct reg_write_cmd reg_write = {\n\t\t.type = 1,\n\t\t.num = 1,\n\t\t.addr = cpu_to_le32(reg),\n\t\t.data = cpu_to_le32(val),\n\t\t.mask = cpu_to_le32(mask),\n\t};\n\tint err, status;\n\n\twmt_params.op = BTMTK_WMT_REGISTER;\n\twmt_params.flag = BTMTK_WMT_REG_WRITE;\n\twmt_params.dlen = sizeof(reg_write);\n\twmt_params.data = &reg_write;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0)\n\t\tbt_dev_err(hdev, \"Failed to write reg (%d)\", err);\n\n\treturn err;\n}\n\nstatic int btmtksdio_get_data_path_id(struct hci_dev *hdev, __u8 *data_path_id)\n{\n\t \n\t*data_path_id = 1;\n\treturn 0;\n}\n\nstatic int btmtksdio_get_codec_config_data(struct hci_dev *hdev,\n\t\t\t\t\t   __u8 link, struct bt_codec *codec,\n\t\t\t\t\t   __u8 *ven_len, __u8 **ven_data)\n{\n\tint err = 0;\n\n\tif (!ven_data || !ven_len)\n\t\treturn -EINVAL;\n\n\t*ven_len = 0;\n\t*ven_data = NULL;\n\n\tif (link != ESCO_LINK) {\n\t\tbt_dev_err(hdev, \"Invalid link type(%u)\", link);\n\t\treturn -EINVAL;\n\t}\n\n\t*ven_data = kmalloc(sizeof(__u8), GFP_KERNEL);\n\tif (!*ven_data) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (codec->id) {\n\tcase 0x02:\n\t\t**ven_data = 0x00;\n\t\tbreak;\n\tcase 0x05:\n\t\t**ven_data = 0x01;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbt_dev_err(hdev, \"Invalid codec id(%u)\", codec->id);\n\t\tgoto error;\n\t}\n\t \n\t*ven_len = sizeof(__u8);\n\treturn err;\n\nerror:\n\tkfree(*ven_data);\n\t*ven_data = NULL;\n\treturn err;\n}\n\nstatic int btmtksdio_sco_setting(struct hci_dev *hdev)\n{\n\tconst struct btmtk_sco sco_setting = {\n\t\t.clock_config = 0x49,\n\t\t.channel_format_config = 0x80,\n\t};\n\tstruct sk_buff *skb;\n\tu32 val;\n\tint err;\n\n\t \n\tskb =  __hci_cmd_sync(hdev, 0xfc72, sizeof(sco_setting),\n\t\t\t      &sco_setting, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\n\terr = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_0, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= 0x11000000;\n\terr = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_0, val, ~0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= 0x00000101;\n\terr =  btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);\n\tif (err < 0)\n\t\treturn err;\n\n\thdev->get_data_path_id = btmtksdio_get_data_path_id;\n\thdev->get_codec_config_data = btmtksdio_get_codec_config_data;\n\n\treturn err;\n}\n\nstatic int btmtksdio_reset_setting(struct hci_dev *hdev)\n{\n\tint err;\n\tu32 val;\n\n\terr = btmtksdio_mtk_reg_read(hdev, MT7921_PINMUX_1, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= 0x20;  \n\terr = btmtksdio_mtk_reg_write(hdev, MT7921_PINMUX_1, val, ~0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = btmtksdio_mtk_reg_read(hdev, MT7921_BTSYS_RST, &val);\n\tif (err < 0)\n\t\treturn err;\n\n\tval |= MT7921_BTSYS_RST_WITH_GPIO;\n\treturn btmtksdio_mtk_reg_write(hdev, MT7921_BTSYS_RST, val, ~0);\n}\n\nstatic int btmtksdio_setup(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tktime_t calltime, delta, rettime;\n\tunsigned long long duration;\n\tchar fwname[64];\n\tint err, dev_id;\n\tu32 fw_version = 0, val;\n\n\tcalltime = ktime_get();\n\tset_bit(BTMTKSDIO_HW_TX_READY, &bdev->tx_state);\n\n\tswitch (bdev->data->chipid) {\n\tcase 0x7921:\n\t\tif (test_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state)) {\n\t\t\terr = btmtksdio_mtk_reg_read(hdev, MT7921_DLSTATUS,\n\t\t\t\t\t\t     &val);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tval &= ~BT_DL_STATE;\n\t\t\terr = btmtksdio_mtk_reg_write(hdev, MT7921_DLSTATUS,\n\t\t\t\t\t\t      val, ~0);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\n\t\t\tbtmtksdio_fw_pmctrl(bdev);\n\t\t\tmsleep(20);\n\t\t\tbtmtksdio_drv_pmctrl(bdev);\n\n\t\t\tclear_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state);\n\t\t}\n\n\t\terr = btmtksdio_mtk_reg_read(hdev, 0x70010200, &dev_id);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to get device id (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\terr = btmtksdio_mtk_reg_read(hdev, 0x80021004, &fw_version);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to get fw version (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tsnprintf(fwname, sizeof(fwname),\n\t\t\t \"mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin\",\n\t\t\t dev_id & 0xffff, (fw_version & 0xff) + 1);\n\t\terr = mt79xx_setup(hdev, fwname);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\terr = btmtksdio_sco_setting(hdev);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to enable SCO setting (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\n\t\t \n\t\tif (bdev->reset) {\n\t\t\terr = btmtksdio_reset_setting(hdev);\n\t\t\tif (err < 0) {\n\t\t\t\tbt_dev_err(hdev, \"Failed to enable Reset setting (%d)\", err);\n\t\t\t\tdevm_gpiod_put(bdev->dev, bdev->reset);\n\t\t\t\tbdev->reset = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\n\t\tbreak;\n\tcase 0x7663:\n\tcase 0x7668:\n\t\terr = mt76xx_setup(hdev, bdev->data->fwname);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long)ktime_to_ns(delta) >> 10;\n\n\tpm_runtime_set_autosuspend_delay(bdev->dev,\n\t\t\t\t\t MTKBTSDIO_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(bdev->dev);\n\n\terr = pm_runtime_set_active(bdev->dev);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tpm_runtime_forbid(bdev->dev);\n\tpm_runtime_enable(bdev->dev);\n\n\tif (enable_autosuspend)\n\t\tpm_runtime_allow(bdev->dev);\n\n\tbt_dev_info(hdev, \"Device setup in %llu usecs\", duration);\n\n\treturn 0;\n}\n\nstatic int btmtksdio_shutdown(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tu8 param = 0x0;\n\tint err;\n\n\t \n\tpm_runtime_get_sync(bdev->dev);\n\n\t \n\tif (test_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state))\n\t\tgoto ignore_wmt_cmd;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\nignore_wmt_cmd:\n\tpm_runtime_put_noidle(bdev->dev);\n\tpm_runtime_disable(bdev->dev);\n\n\treturn 0;\n}\n\nstatic int btmtksdio_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\n\tskb_queue_tail(&bdev->txq, skb);\n\n\tschedule_work(&bdev->txrx_work);\n\n\treturn 0;\n}\n\nstatic void btmtksdio_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tu32 status;\n\tint err;\n\n\tif (!bdev->reset || bdev->data->chipid != 0x7921)\n\t\treturn;\n\n\tpm_runtime_get_sync(bdev->dev);\n\n\tif (test_and_set_bit(BTMTKSDIO_HW_RESET_ACTIVE, &bdev->tx_state))\n\t\treturn;\n\n\tsdio_claim_host(bdev->func);\n\n\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, NULL);\n\tskb_queue_purge(&bdev->txq);\n\tcancel_work_sync(&bdev->txrx_work);\n\n\tgpiod_set_value_cansleep(bdev->reset, 1);\n\tmsleep(100);\n\tgpiod_set_value_cansleep(bdev->reset, 0);\n\n\terr = readx_poll_timeout(btmtksdio_chcr_query, bdev, status,\n\t\t\t\t status & BT_RST_DONE, 100000, 2000000);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to reset (%d)\", err);\n\t\tgoto err;\n\t}\n\n\tclear_bit(BTMTKSDIO_PATCH_ENABLED, &bdev->tx_state);\nerr:\n\tsdio_release_host(bdev->func);\n\n\tpm_runtime_put_noidle(bdev->dev);\n\tpm_runtime_disable(bdev->dev);\n\n\thci_reset_dev(hdev);\n}\n\nstatic bool btmtksdio_sdio_inband_wakeup(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\n\treturn device_may_wakeup(bdev->dev);\n}\n\nstatic bool btmtksdio_sdio_wakeup(struct hci_dev *hdev)\n{\n\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n\tbool may_wakeup = device_may_wakeup(bdev->dev);\n\tconst struct btmtk_wakeon bt_awake = {\n\t\t.mode = 0x1,\n\t\t.gpo = 0,\n\t\t.active_high = 0x1,\n\t\t.enable_delay = cpu_to_le16(0xc80),\n\t\t.wakeup_delay = cpu_to_le16(0x20),\n\t};\n\n\tif (may_wakeup && bdev->data->chipid == 0x7921) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb =  __hci_cmd_sync(hdev, 0xfc27, sizeof(bt_awake),\n\t\t\t\t      &bt_awake, HCI_CMD_TIMEOUT);\n\t\tif (IS_ERR(skb))\n\t\t\tmay_wakeup = false;\n\t\telse\n\t\t\tkfree_skb(skb);\n\t}\n\n\treturn may_wakeup;\n}\n\nstatic int btmtksdio_probe(struct sdio_func *func,\n\t\t\t   const struct sdio_device_id *id)\n{\n\tstruct btmtksdio_dev *bdev;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tbdev = devm_kzalloc(&func->dev, sizeof(*bdev), GFP_KERNEL);\n\tif (!bdev)\n\t\treturn -ENOMEM;\n\n\tbdev->data = (void *)id->driver_data;\n\tif (!bdev->data)\n\t\treturn -ENODEV;\n\n\tbdev->dev = &func->dev;\n\tbdev->func = func;\n\n\tINIT_WORK(&bdev->txrx_work, btmtksdio_txrx_work);\n\tskb_queue_head_init(&bdev->txq);\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tdev_err(&func->dev, \"Can't allocate HCI device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbdev->hdev = hdev;\n\n\thdev->bus = HCI_SDIO;\n\thci_set_drvdata(hdev, bdev);\n\n\thdev->open     = btmtksdio_open;\n\thdev->close    = btmtksdio_close;\n\thdev->cmd_timeout = btmtksdio_cmd_timeout;\n\thdev->flush    = btmtksdio_flush;\n\thdev->setup    = btmtksdio_setup;\n\thdev->shutdown = btmtksdio_shutdown;\n\thdev->send     = btmtksdio_send_frame;\n\thdev->wakeup   = btmtksdio_sdio_wakeup;\n\t \n\tif (device_can_wakeup(func->card->host->parent))\n\t\thdev->wakeup = btmtksdio_sdio_inband_wakeup;\n\telse\n\t\thdev->wakeup = btmtksdio_sdio_wakeup;\n\thdev->set_bdaddr = btmtk_set_bdaddr;\n\n\tSET_HCIDEV_DEV(hdev, &func->dev);\n\n\thdev->manufacturer = 70;\n\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\n\tsdio_set_drvdata(func, bdev);\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\tdev_err(&func->dev, \"Can't register HCI device\\n\");\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\t \n\tif (pm_runtime_enabled(bdev->dev))\n\t\tpm_runtime_disable(bdev->dev);\n\n\t \n\tpm_runtime_put_noidle(bdev->dev);\n\n\terr = device_init_wakeup(bdev->dev, true);\n\tif (err)\n\t\tbt_dev_err(hdev, \"failed to initialize device wakeup\");\n\n\tbdev->dev->of_node = of_find_compatible_node(NULL, NULL,\n\t\t\t\t\t\t     \"mediatek,mt7921s-bluetooth\");\n\tbdev->reset = devm_gpiod_get_optional(bdev->dev, \"reset\",\n\t\t\t\t\t      GPIOD_OUT_LOW);\n\tif (IS_ERR(bdev->reset))\n\t\terr = PTR_ERR(bdev->reset);\n\n\treturn err;\n}\n\nstatic void btmtksdio_remove(struct sdio_func *func)\n{\n\tstruct btmtksdio_dev *bdev = sdio_get_drvdata(func);\n\tstruct hci_dev *hdev;\n\n\tif (!bdev)\n\t\treturn;\n\n\t \n\tpm_runtime_get_noresume(bdev->dev);\n\n\thdev = bdev->hdev;\n\n\tsdio_set_drvdata(func, NULL);\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n}\n\n#ifdef CONFIG_PM\nstatic int btmtksdio_runtime_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct btmtksdio_dev *bdev;\n\tint err;\n\n\tbdev = sdio_get_drvdata(func);\n\tif (!bdev)\n\t\treturn 0;\n\n\tif (!test_bit(BTMTKSDIO_FUNC_ENABLED, &bdev->tx_state))\n\t\treturn 0;\n\n\tsdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\n\terr = btmtksdio_fw_pmctrl(bdev);\n\n\tbt_dev_dbg(bdev->hdev, \"status (%d) return ownership to device\", err);\n\n\treturn err;\n}\n\nstatic int btmtksdio_runtime_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct btmtksdio_dev *bdev;\n\tint err;\n\n\tbdev = sdio_get_drvdata(func);\n\tif (!bdev)\n\t\treturn 0;\n\n\tif (!test_bit(BTMTKSDIO_FUNC_ENABLED, &bdev->tx_state))\n\t\treturn 0;\n\n\terr = btmtksdio_drv_pmctrl(bdev);\n\n\tbt_dev_dbg(bdev->hdev, \"status (%d) get ownership from device\", err);\n\n\treturn err;\n}\n\nstatic UNIVERSAL_DEV_PM_OPS(btmtksdio_pm_ops, btmtksdio_runtime_suspend,\n\t\t\t    btmtksdio_runtime_resume, NULL);\n#define BTMTKSDIO_PM_OPS (&btmtksdio_pm_ops)\n#else\t \n#define BTMTKSDIO_PM_OPS NULL\n#endif\t \n\nstatic struct sdio_driver btmtksdio_driver = {\n\t.name\t\t= \"btmtksdio\",\n\t.probe\t\t= btmtksdio_probe,\n\t.remove\t\t= btmtksdio_remove,\n\t.id_table\t= btmtksdio_table,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.pm = BTMTKSDIO_PM_OPS,\n\t}\n};\n\nmodule_sdio_driver(btmtksdio_driver);\n\nmodule_param(enable_autosuspend, bool, 0644);\nMODULE_PARM_DESC(enable_autosuspend, \"Enable autosuspend by default\");\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek Bluetooth SDIO driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}