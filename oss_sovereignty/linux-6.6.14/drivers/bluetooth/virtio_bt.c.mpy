{
  "module_name": "virtio_bt.c",
  "hash_id": "ea608c5c904ea2b7fe22d9221aec9d5f753aecb73bc8ab2c48a54a923f2a9aa6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/virtio_bt.c",
  "human_readable_source": "\n\n#include <linux/module.h>\n#include <linux/virtio.h>\n#include <linux/virtio_config.h>\n#include <linux/skbuff.h>\n\n#include <uapi/linux/virtio_ids.h>\n#include <uapi/linux/virtio_bt.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#define VERSION \"0.1\"\n\nenum {\n\tVIRTBT_VQ_TX,\n\tVIRTBT_VQ_RX,\n\tVIRTBT_NUM_VQS,\n};\n\nstruct virtio_bluetooth {\n\tstruct virtio_device *vdev;\n\tstruct virtqueue *vqs[VIRTBT_NUM_VQS];\n\tstruct work_struct rx;\n\tstruct hci_dev *hdev;\n};\n\nstatic int virtbt_add_inbuf(struct virtio_bluetooth *vbt)\n{\n\tstruct virtqueue *vq = vbt->vqs[VIRTBT_VQ_RX];\n\tstruct scatterlist sg[1];\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = alloc_skb(1000, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(sg, skb->data, 1000);\n\n\terr = virtqueue_add_inbuf(vq, sg, 1, skb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int virtbt_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int virtbt_open_vdev(struct virtio_bluetooth *vbt)\n{\n\tif (virtbt_add_inbuf(vbt) < 0)\n\t\treturn -EIO;\n\n\tvirtqueue_kick(vbt->vqs[VIRTBT_VQ_RX]);\n\treturn 0;\n}\n\nstatic int virtbt_close(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int virtbt_close_vdev(struct virtio_bluetooth *vbt)\n{\n\tint i;\n\n\tcancel_work_sync(&vbt->rx);\n\n\tfor (i = 0; i < ARRAY_SIZE(vbt->vqs); i++) {\n\t\tstruct virtqueue *vq = vbt->vqs[i];\n\t\tstruct sk_buff *skb;\n\n\t\twhile ((skb = virtqueue_detach_unused_buf(vq)))\n\t\t\tkfree_skb(skb);\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\nstatic int virtbt_flush(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int virtbt_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct virtio_bluetooth *vbt = hci_get_drvdata(hdev);\n\tstruct scatterlist sg[1];\n\tint err;\n\n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tsg_init_one(sg, skb->data, skb->len);\n\terr = virtqueue_add_outbuf(vbt->vqs[VIRTBT_VQ_TX], sg, 1, skb,\n\t\t\t\t   GFP_KERNEL);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn err;\n\t}\n\n\tvirtqueue_kick(vbt->vqs[VIRTBT_VQ_TX]);\n\treturn 0;\n}\n\nstatic int virtbt_setup_zephyr(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc08, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"%s\", (char *)(skb->data + 1));\n\n\thci_set_fw_info(hdev, \"%s\", skb->data + 1);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int virtbt_set_bdaddr_zephyr(struct hci_dev *hdev,\n\t\t\t\t    const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc06, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int virtbt_setup_intel(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc05, 0, NULL, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int virtbt_set_bdaddr_intel(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc31, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int virtbt_setup_realtek(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"ROM version %u\", *((__u8 *) (skb->data + 1)));\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int virtbt_shutdown_generic(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic void virtbt_rx_handle(struct virtio_bluetooth *vbt, struct sk_buff *skb)\n{\n\t__u8 pkt_type;\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\t\thci_recv_frame(vbt->hdev, skb);\n\t\tbreak;\n\tdefault:\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n}\n\nstatic void virtbt_rx_work(struct work_struct *work)\n{\n\tstruct virtio_bluetooth *vbt = container_of(work,\n\t\t\t\t\t\t    struct virtio_bluetooth, rx);\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\tskb = virtqueue_get_buf(vbt->vqs[VIRTBT_VQ_RX], &len);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put(skb, len);\n\tvirtbt_rx_handle(vbt, skb);\n\n\tif (virtbt_add_inbuf(vbt) < 0)\n\t\treturn;\n\n\tvirtqueue_kick(vbt->vqs[VIRTBT_VQ_RX]);\n}\n\nstatic void virtbt_tx_done(struct virtqueue *vq)\n{\n\tstruct sk_buff *skb;\n\tunsigned int len;\n\n\twhile ((skb = virtqueue_get_buf(vq, &len)))\n\t\tkfree_skb(skb);\n}\n\nstatic void virtbt_rx_done(struct virtqueue *vq)\n{\n\tstruct virtio_bluetooth *vbt = vq->vdev->priv;\n\n\tschedule_work(&vbt->rx);\n}\n\nstatic int virtbt_probe(struct virtio_device *vdev)\n{\n\tvq_callback_t *callbacks[VIRTBT_NUM_VQS] = {\n\t\t[VIRTBT_VQ_TX] = virtbt_tx_done,\n\t\t[VIRTBT_VQ_RX] = virtbt_rx_done,\n\t};\n\tconst char *names[VIRTBT_NUM_VQS] = {\n\t\t[VIRTBT_VQ_TX] = \"tx\",\n\t\t[VIRTBT_VQ_RX] = \"rx\",\n\t};\n\tstruct virtio_bluetooth *vbt;\n\tstruct hci_dev *hdev;\n\tint err;\n\t__u8 type;\n\n\tif (!virtio_has_feature(vdev, VIRTIO_F_VERSION_1))\n\t\treturn -ENODEV;\n\n\ttype = virtio_cread8(vdev, offsetof(struct virtio_bt_config, type));\n\n\tswitch (type) {\n\tcase VIRTIO_BT_CONFIG_TYPE_PRIMARY:\n\tcase VIRTIO_BT_CONFIG_TYPE_AMP:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tvbt = kzalloc(sizeof(*vbt), GFP_KERNEL);\n\tif (!vbt)\n\t\treturn -ENOMEM;\n\n\tvdev->priv = vbt;\n\tvbt->vdev = vdev;\n\n\tINIT_WORK(&vbt->rx, virtbt_rx_work);\n\n\terr = virtio_find_vqs(vdev, VIRTBT_NUM_VQS, vbt->vqs, callbacks,\n\t\t\t      names, NULL);\n\tif (err)\n\t\treturn err;\n\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\terr = -ENOMEM;\n\t\tgoto failed;\n\t}\n\n\tvbt->hdev = hdev;\n\n\thdev->bus = HCI_VIRTIO;\n\thdev->dev_type = type;\n\thci_set_drvdata(hdev, vbt);\n\n\thdev->open  = virtbt_open;\n\thdev->close = virtbt_close;\n\thdev->flush = virtbt_flush;\n\thdev->send  = virtbt_send_frame;\n\n\tif (virtio_has_feature(vdev, VIRTIO_BT_F_VND_HCI)) {\n\t\t__u16 vendor;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_BT_F_CONFIG_V2))\n\t\t\tvirtio_cread(vdev, struct virtio_bt_config_v2,\n\t\t\t\t     vendor, &vendor);\n\t\telse\n\t\t\tvirtio_cread(vdev, struct virtio_bt_config,\n\t\t\t\t     vendor, &vendor);\n\n\t\tswitch (vendor) {\n\t\tcase VIRTIO_BT_CONFIG_VENDOR_ZEPHYR:\n\t\t\thdev->manufacturer = 1521;\n\t\t\thdev->setup = virtbt_setup_zephyr;\n\t\t\thdev->shutdown = virtbt_shutdown_generic;\n\t\t\thdev->set_bdaddr = virtbt_set_bdaddr_zephyr;\n\t\t\tbreak;\n\n\t\tcase VIRTIO_BT_CONFIG_VENDOR_INTEL:\n\t\t\thdev->manufacturer = 2;\n\t\t\thdev->setup = virtbt_setup_intel;\n\t\t\thdev->shutdown = virtbt_shutdown_generic;\n\t\t\thdev->set_bdaddr = virtbt_set_bdaddr_intel;\n\t\t\tset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\n\t\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\t\t\tbreak;\n\n\t\tcase VIRTIO_BT_CONFIG_VENDOR_REALTEK:\n\t\t\thdev->manufacturer = 93;\n\t\t\thdev->setup = virtbt_setup_realtek;\n\t\t\thdev->shutdown = virtbt_shutdown_generic;\n\t\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_BT_F_MSFT_EXT)) {\n\t\t__u16 msft_opcode;\n\n\t\tif (virtio_has_feature(vdev, VIRTIO_BT_F_CONFIG_V2))\n\t\t\tvirtio_cread(vdev, struct virtio_bt_config_v2,\n\t\t\t\t     msft_opcode, &msft_opcode);\n\t\telse\n\t\t\tvirtio_cread(vdev, struct virtio_bt_config,\n\t\t\t\t     msft_opcode, &msft_opcode);\n\n\t\thci_set_msft_opcode(hdev, msft_opcode);\n\t}\n\n\tif (virtio_has_feature(vdev, VIRTIO_BT_F_AOSP_EXT))\n\t\thci_set_aosp_capable(hdev);\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\thci_free_dev(hdev);\n\t\terr = -EBUSY;\n\t\tgoto failed;\n\t}\n\n\tvirtio_device_ready(vdev);\n\terr = virtbt_open_vdev(vbt);\n\tif (err)\n\t\tgoto open_failed;\n\n\treturn 0;\n\nopen_failed:\n\thci_free_dev(hdev);\nfailed:\n\tvdev->config->del_vqs(vdev);\n\treturn err;\n}\n\nstatic void virtbt_remove(struct virtio_device *vdev)\n{\n\tstruct virtio_bluetooth *vbt = vdev->priv;\n\tstruct hci_dev *hdev = vbt->hdev;\n\n\thci_unregister_dev(hdev);\n\tvirtio_reset_device(vdev);\n\tvirtbt_close_vdev(vbt);\n\n\thci_free_dev(hdev);\n\tvbt->hdev = NULL;\n\n\tvdev->config->del_vqs(vdev);\n\tkfree(vbt);\n}\n\nstatic struct virtio_device_id virtbt_table[] = {\n\t{ VIRTIO_ID_BT, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nMODULE_DEVICE_TABLE(virtio, virtbt_table);\n\nstatic const unsigned int virtbt_features[] = {\n\tVIRTIO_BT_F_VND_HCI,\n\tVIRTIO_BT_F_MSFT_EXT,\n\tVIRTIO_BT_F_AOSP_EXT,\n\tVIRTIO_BT_F_CONFIG_V2,\n};\n\nstatic struct virtio_driver virtbt_driver = {\n\t.driver.name         = KBUILD_MODNAME,\n\t.driver.owner        = THIS_MODULE,\n\t.feature_table       = virtbt_features,\n\t.feature_table_size  = ARRAY_SIZE(virtbt_features),\n\t.id_table            = virtbt_table,\n\t.probe               = virtbt_probe,\n\t.remove              = virtbt_remove,\n};\n\nmodule_virtio_driver(virtbt_driver);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Generic Bluetooth VIRTIO driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}