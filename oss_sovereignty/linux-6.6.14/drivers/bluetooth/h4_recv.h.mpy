{
  "module_name": "h4_recv.h",
  "hash_id": "a72dc0e66f69537b5d5702635e9160e7830b6fec0fe2391d21e7b2b9e72947a1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/h4_recv.h",
  "human_readable_source": " \n \n\n#include <asm/unaligned.h>\n\nstruct h4_recv_pkt {\n\tu8  type;\t \n\tu8  hlen;\t \n\tu8  loff;\t \n\tu8  lsize;\t \n\tu16 maxlen;\t \n\tint (*recv)(struct hci_dev *hdev, struct sk_buff *skb);\n};\n\n#define H4_RECV_ACL \\\n\t.type = HCI_ACLDATA_PKT, \\\n\t.hlen = HCI_ACL_HDR_SIZE, \\\n\t.loff = 2, \\\n\t.lsize = 2, \\\n\t.maxlen = HCI_MAX_FRAME_SIZE \\\n\n#define H4_RECV_SCO \\\n\t.type = HCI_SCODATA_PKT, \\\n\t.hlen = HCI_SCO_HDR_SIZE, \\\n\t.loff = 2, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_MAX_SCO_SIZE\n\n#define H4_RECV_EVENT \\\n\t.type = HCI_EVENT_PKT, \\\n\t.hlen = HCI_EVENT_HDR_SIZE, \\\n\t.loff = 1, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_MAX_EVENT_SIZE\n\nstatic inline struct sk_buff *h4_recv_buf(struct hci_dev *hdev,\n\t\t\t\t\t  struct sk_buff *skb,\n\t\t\t\t\t  const unsigned char *buffer,\n\t\t\t\t\t  int count,\n\t\t\t\t\t  const struct h4_recv_pkt *pkts,\n\t\t\t\t\t  int pkts_count)\n{\n\t \n\tif (IS_ERR(skb))\n\t\tskb = NULL;\n\n\twhile (count) {\n\t\tint i, len;\n\n\t\tif (!skb) {\n\t\t\tfor (i = 0; i < pkts_count; i++) {\n\t\t\t\tif (buffer[0] != (&pkts[i])->type)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tskb = bt_skb_alloc((&pkts[i])->maxlen,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (!skb)\n\t\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\t\thci_skb_pkt_type(skb) = (&pkts[i])->type;\n\t\t\t\thci_skb_expect(skb) = (&pkts[i])->hlen;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!skb)\n\t\t\t\treturn ERR_PTR(-EILSEQ);\n\n\t\t\tcount -= 1;\n\t\t\tbuffer += 1;\n\t\t}\n\n\t\tlen = min_t(uint, hci_skb_expect(skb) - skb->len, count);\n\t\tskb_put_data(skb, buffer, len);\n\n\t\tcount -= len;\n\t\tbuffer += len;\n\n\t\t \n\t\tif (skb->len < hci_skb_expect(skb))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < pkts_count; i++) {\n\t\t\tif (hci_skb_pkt_type(skb) == (&pkts[i])->type)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= pkts_count) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn ERR_PTR(-EILSEQ);\n\t\t}\n\n\t\tif (skb->len == (&pkts[i])->hlen) {\n\t\t\tu16 dlen;\n\n\t\t\tswitch ((&pkts[i])->lsize) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tdlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tdlen = skb->data[(&pkts[i])->loff];\n\t\t\t\thci_skb_expect(skb) += dlen;\n\n\t\t\t\tif (skb_tailroom(skb) < dlen) {\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tdlen = get_unaligned_le16(skb->data +\n\t\t\t\t\t\t\t  (&pkts[i])->loff);\n\t\t\t\thci_skb_expect(skb) += dlen;\n\n\t\t\t\tif (skb_tailroom(skb) < dlen) {\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn ERR_PTR(-EILSEQ);\n\t\t\t}\n\n\t\t\tif (!dlen) {\n\t\t\t\t \n\t\t\t\t(&pkts[i])->recv(hdev, skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\t(&pkts[i])->recv(hdev, skb);\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\treturn skb;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}