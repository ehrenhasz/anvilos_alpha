{
  "module_name": "btmrvl_main.c",
  "hash_id": "c882d26c0c02f0ad5fcf313dcfd328d3d422e960f306fc62dfbcae5968f7e157",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btmrvl_main.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <linux/mmc/sdio_func.h>\n\n#include \"btmrvl_drv.h\"\n#include \"btmrvl_sdio.h\"\n\n#define VERSION \"1.0\"\n\n \nvoid btmrvl_interrupt(struct btmrvl_private *priv)\n{\n\tpriv->adapter->ps_state = PS_AWAKE;\n\n\tpriv->adapter->wakeup_tries = 0;\n\n\tpriv->adapter->int_count++;\n\n\tif (priv->adapter->hs_state == HS_ACTIVATED) {\n\t\tBT_DBG(\"BT: HS DEACTIVATED in ISR!\");\n\t\tpriv->adapter->hs_state = HS_DEACTIVATED;\n\t}\n\n\twake_up_interruptible(&priv->main_thread.wait_q);\n}\nEXPORT_SYMBOL_GPL(btmrvl_interrupt);\n\nbool btmrvl_check_evtpkt(struct btmrvl_private *priv, struct sk_buff *skb)\n{\n\tstruct hci_event_hdr *hdr = (void *) skb->data;\n\n\tif (hdr->evt == HCI_EV_CMD_COMPLETE) {\n\t\tstruct hci_ev_cmd_complete *ec;\n\t\tu16 opcode;\n\n\t\tec = (void *) (skb->data + HCI_EVENT_HDR_SIZE);\n\t\topcode = __le16_to_cpu(ec->opcode);\n\n\t\tif (priv->btmrvl_dev.sendcmdflag) {\n\t\t\tpriv->btmrvl_dev.sendcmdflag = false;\n\t\t\tpriv->adapter->cmd_complete = true;\n\t\t\twake_up_interruptible(&priv->adapter->cmd_wait_q);\n\n\t\t\tif (hci_opcode_ogf(opcode) == 0x3F) {\n\t\t\t\tBT_DBG(\"vendor event skipped: opcode=%#4.4x\",\n\t\t\t\t       opcode);\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(btmrvl_check_evtpkt);\n\nint btmrvl_process_event(struct btmrvl_private *priv, struct sk_buff *skb)\n{\n\tstruct btmrvl_adapter *adapter = priv->adapter;\n\tstruct btmrvl_event *event;\n\tint ret = 0;\n\n\tevent = (struct btmrvl_event *) skb->data;\n\tif (event->ec != 0xff) {\n\t\tBT_DBG(\"Not Marvell Event=%x\", event->ec);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\tswitch (event->data[0]) {\n\tcase BT_EVENT_AUTO_SLEEP_MODE:\n\t\tif (!event->data[2]) {\n\t\t\tif (event->data[1] == BT_PS_ENABLE)\n\t\t\t\tadapter->psmode = 1;\n\t\t\telse\n\t\t\t\tadapter->psmode = 0;\n\t\t\tBT_DBG(\"PS Mode:%s\",\n\t\t\t\t(adapter->psmode) ? \"Enable\" : \"Disable\");\n\t\t} else {\n\t\t\tBT_DBG(\"PS Mode command failed\");\n\t\t}\n\t\tbreak;\n\n\tcase BT_EVENT_HOST_SLEEP_CONFIG:\n\t\tif (!event->data[3])\n\t\t\tBT_DBG(\"gpio=%x, gap=%x\", event->data[1],\n\t\t\t\t\t\t\tevent->data[2]);\n\t\telse\n\t\t\tBT_DBG(\"HSCFG command failed\");\n\t\tbreak;\n\n\tcase BT_EVENT_HOST_SLEEP_ENABLE:\n\t\tif (!event->data[1]) {\n\t\t\tadapter->hs_state = HS_ACTIVATED;\n\t\t\tif (adapter->psmode)\n\t\t\t\tadapter->ps_state = PS_SLEEP;\n\t\t\twake_up_interruptible(&adapter->event_hs_wait_q);\n\t\t\tBT_DBG(\"HS ACTIVATED!\");\n\t\t} else {\n\t\t\tBT_DBG(\"HS Enable failed\");\n\t\t}\n\t\tbreak;\n\n\tcase BT_EVENT_MODULE_CFG_REQ:\n\t\tif (priv->btmrvl_dev.sendcmdflag &&\n\t\t\t\tevent->data[1] == MODULE_BRINGUP_REQ) {\n\t\t\tBT_DBG(\"EVENT:%s\",\n\t\t\t\t((event->data[2] == MODULE_BROUGHT_UP) ||\n\t\t\t\t(event->data[2] == MODULE_ALREADY_UP)) ?\n\t\t\t\t\"Bring-up succeed\" : \"Bring-up failed\");\n\n\t\t\tif (event->length > 3 && event->data[3])\n\t\t\t\tpriv->btmrvl_dev.dev_type = HCI_AMP;\n\t\t\telse\n\t\t\t\tpriv->btmrvl_dev.dev_type = HCI_PRIMARY;\n\n\t\t\tBT_DBG(\"dev_type: %d\", priv->btmrvl_dev.dev_type);\n\t\t} else if (priv->btmrvl_dev.sendcmdflag &&\n\t\t\t\tevent->data[1] == MODULE_SHUTDOWN_REQ) {\n\t\t\tBT_DBG(\"EVENT:%s\", (event->data[2]) ?\n\t\t\t\t\"Shutdown failed\" : \"Shutdown succeed\");\n\t\t} else {\n\t\t\tBT_DBG(\"BT_CMD_MODULE_CFG_REQ resp for APP\");\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tbreak;\n\n\tcase BT_EVENT_POWER_STATE:\n\t\tif (event->data[1] == BT_PS_SLEEP)\n\t\t\tadapter->ps_state = PS_SLEEP;\n\t\tBT_DBG(\"EVENT:%s\",\n\t\t\t(adapter->ps_state) ? \"PS_SLEEP\" : \"PS_AWAKE\");\n\t\tbreak;\n\n\tdefault:\n\t\tBT_DBG(\"Unknown Event=%d\", event->data[0]);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nexit:\n\tif (!ret)\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btmrvl_process_event);\n\nstatic int btmrvl_send_sync_cmd(struct btmrvl_private *priv, u16 opcode,\n\t\t\t\tconst void *param, u8 len)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_command_hdr *hdr;\n\n\tif (priv->surprise_removed) {\n\t\tBT_ERR(\"Card is removed\");\n\t\treturn -EFAULT;\n\t}\n\n\tskb = bt_skb_alloc(HCI_COMMAND_HDR_SIZE + len, GFP_KERNEL);\n\tif (!skb) {\n\t\tBT_ERR(\"No free skb\");\n\t\treturn -ENOMEM;\n\t}\n\n\thdr = skb_put(skb, HCI_COMMAND_HDR_SIZE);\n\thdr->opcode = cpu_to_le16(opcode);\n\thdr->plen = len;\n\n\tif (len)\n\t\tskb_put_data(skb, param, len);\n\n\thci_skb_pkt_type(skb) = MRVL_VENDOR_PKT;\n\n\tskb_queue_head(&priv->adapter->tx_queue, skb);\n\n\tpriv->btmrvl_dev.sendcmdflag = true;\n\n\tpriv->adapter->cmd_complete = false;\n\n\twake_up_interruptible(&priv->main_thread.wait_q);\n\n\tif (!wait_event_interruptible_timeout(priv->adapter->cmd_wait_q,\n\t\t\t\t\t      priv->adapter->cmd_complete ||\n\t\t\t\t\t      priv->surprise_removed,\n\t\t\t\t\t      WAIT_UNTIL_CMD_RESP))\n\t\treturn -ETIMEDOUT;\n\n\tif (priv->surprise_removed)\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nint btmrvl_send_module_cfg_cmd(struct btmrvl_private *priv, u8 subcmd)\n{\n\tint ret;\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_MODULE_CFG_REQ, &subcmd, 1);\n\tif (ret)\n\t\tBT_ERR(\"module_cfg_cmd(%x) failed\", subcmd);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btmrvl_send_module_cfg_cmd);\n\nstatic int btmrvl_enable_sco_routing_to_host(struct btmrvl_private *priv)\n{\n\tint ret;\n\tu8 subcmd = 0;\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_ROUTE_SCO_TO_HOST, &subcmd, 1);\n\tif (ret)\n\t\tBT_ERR(\"BT_CMD_ROUTE_SCO_TO_HOST command failed: %#x\", ret);\n\n\treturn ret;\n}\n\nint btmrvl_pscan_window_reporting(struct btmrvl_private *priv, u8 subcmd)\n{\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret;\n\n\tif (!card->support_pscan_win_report)\n\t\treturn 0;\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_PSCAN_WIN_REPORT_ENABLE,\n\t\t\t\t   &subcmd, 1);\n\tif (ret)\n\t\tBT_ERR(\"PSCAN_WIN_REPORT_ENABLE command failed: %#x\", ret);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btmrvl_pscan_window_reporting);\n\nint btmrvl_send_hscfg_cmd(struct btmrvl_private *priv)\n{\n\tint ret;\n\tu8 param[2];\n\n\tparam[0] = (priv->btmrvl_dev.gpio_gap & 0xff00) >> 8;\n\tparam[1] = (u8) (priv->btmrvl_dev.gpio_gap & 0x00ff);\n\n\tBT_DBG(\"Sending HSCFG Command, gpio=0x%x, gap=0x%x\",\n\t       param[0], param[1]);\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_HOST_SLEEP_CONFIG, param, 2);\n\tif (ret)\n\t\tBT_ERR(\"HSCFG command failed\");\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btmrvl_send_hscfg_cmd);\n\nint btmrvl_enable_ps(struct btmrvl_private *priv)\n{\n\tint ret;\n\tu8 param;\n\n\tif (priv->btmrvl_dev.psmode)\n\t\tparam = BT_PS_ENABLE;\n\telse\n\t\tparam = BT_PS_DISABLE;\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_AUTO_SLEEP_MODE, &param, 1);\n\tif (ret)\n\t\tBT_ERR(\"PSMODE command failed\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btmrvl_enable_ps);\n\nint btmrvl_enable_hs(struct btmrvl_private *priv)\n{\n\tstruct btmrvl_adapter *adapter = priv->adapter;\n\tint ret;\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_HOST_SLEEP_ENABLE, NULL, 0);\n\tif (ret) {\n\t\tBT_ERR(\"Host sleep enable command failed\");\n\t\treturn ret;\n\t}\n\n\tret = wait_event_interruptible_timeout(adapter->event_hs_wait_q,\n\t\t\t\t\t       adapter->hs_state ||\n\t\t\t\t\t       priv->surprise_removed,\n\t\t\t\t\t       WAIT_UNTIL_HS_STATE_CHANGED);\n\tif (ret < 0 || priv->surprise_removed) {\n\t\tBT_ERR(\"event_hs_wait_q terminated (%d): %d,%d,%d\",\n\t\t       ret, adapter->hs_state, adapter->ps_state,\n\t\t       adapter->wakeup_tries);\n\t} else if (!ret) {\n\t\tBT_ERR(\"hs_enable timeout: %d,%d,%d\", adapter->hs_state,\n\t\t       adapter->ps_state, adapter->wakeup_tries);\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tBT_DBG(\"host sleep enabled: %d,%d,%d\", adapter->hs_state,\n\t\t       adapter->ps_state, adapter->wakeup_tries);\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btmrvl_enable_hs);\n\nint btmrvl_prepare_command(struct btmrvl_private *priv)\n{\n\tint ret = 0;\n\n\tif (priv->btmrvl_dev.hscfgcmd) {\n\t\tpriv->btmrvl_dev.hscfgcmd = 0;\n\t\tbtmrvl_send_hscfg_cmd(priv);\n\t}\n\n\tif (priv->btmrvl_dev.pscmd) {\n\t\tpriv->btmrvl_dev.pscmd = 0;\n\t\tbtmrvl_enable_ps(priv);\n\t}\n\n\tif (priv->btmrvl_dev.hscmd) {\n\t\tpriv->btmrvl_dev.hscmd = 0;\n\n\t\tif (priv->btmrvl_dev.hsmode) {\n\t\t\tret = btmrvl_enable_hs(priv);\n\t\t} else {\n\t\t\tret = priv->hw_wakeup_firmware(priv);\n\t\t\tpriv->adapter->hs_state = HS_DEACTIVATED;\n\t\t\tBT_DBG(\"BT: HS DEACTIVATED due to host activity!\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int btmrvl_tx_pkt(struct btmrvl_private *priv, struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tif (!skb || !skb->data)\n\t\treturn -EINVAL;\n\n\tif (!skb->len || ((skb->len + BTM_HEADER_LEN) > BTM_UPLD_SIZE)) {\n\t\tBT_ERR(\"Tx Error: Bad skb length %d : %d\",\n\t\t\t\t\t\tskb->len, BTM_UPLD_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tskb_push(skb, BTM_HEADER_LEN);\n\n\t \n\n\tskb->data[0] = (skb->len & 0x0000ff);\n\tskb->data[1] = (skb->len & 0x00ff00) >> 8;\n\tskb->data[2] = (skb->len & 0xff0000) >> 16;\n\tskb->data[3] = hci_skb_pkt_type(skb);\n\n\tif (priv->hw_host_to_card)\n\t\tret = priv->hw_host_to_card(priv, skb->data, skb->len);\n\n\treturn ret;\n}\n\nstatic void btmrvl_init_adapter(struct btmrvl_private *priv)\n{\n\tint buf_size;\n\n\tskb_queue_head_init(&priv->adapter->tx_queue);\n\n\tpriv->adapter->ps_state = PS_AWAKE;\n\n\tbuf_size = ALIGN_SZ(SDIO_BLOCK_SIZE, BTSDIO_DMA_ALIGN);\n\tpriv->adapter->hw_regs_buf = kzalloc(buf_size, GFP_KERNEL);\n\tif (!priv->adapter->hw_regs_buf) {\n\t\tpriv->adapter->hw_regs = NULL;\n\t\tBT_ERR(\"Unable to allocate buffer for hw_regs.\");\n\t} else {\n\t\tpriv->adapter->hw_regs =\n\t\t\t(u8 *)ALIGN_ADDR(priv->adapter->hw_regs_buf,\n\t\t\t\t\t BTSDIO_DMA_ALIGN);\n\t\tBT_DBG(\"hw_regs_buf=%p hw_regs=%p\",\n\t\t       priv->adapter->hw_regs_buf, priv->adapter->hw_regs);\n\t}\n\n\tinit_waitqueue_head(&priv->adapter->cmd_wait_q);\n\tinit_waitqueue_head(&priv->adapter->event_hs_wait_q);\n}\n\nstatic void btmrvl_free_adapter(struct btmrvl_private *priv)\n{\n\tskb_queue_purge(&priv->adapter->tx_queue);\n\n\tkfree(priv->adapter->hw_regs_buf);\n\tkfree(priv->adapter);\n\n\tpriv->adapter = NULL;\n}\n\nstatic int btmrvl_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"type=%d, len=%d\", hci_skb_pkt_type(skb), skb->len);\n\n\tif (priv->adapter->is_suspending || priv->adapter->is_suspended) {\n\t\tBT_ERR(\"%s: Device is suspending or suspended\", __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\tskb_queue_tail(&priv->adapter->tx_queue, skb);\n\n\tif (!priv->adapter->is_suspended)\n\t\twake_up_interruptible(&priv->main_thread.wait_q);\n\n\treturn 0;\n}\n\nstatic int btmrvl_flush(struct hci_dev *hdev)\n{\n\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\n\tskb_queue_purge(&priv->adapter->tx_queue);\n\n\treturn 0;\n}\n\nstatic int btmrvl_close(struct hci_dev *hdev)\n{\n\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\n\tskb_queue_purge(&priv->adapter->tx_queue);\n\n\treturn 0;\n}\n\nstatic int btmrvl_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int btmrvl_download_cal_data(struct btmrvl_private *priv,\n\t\t\t\t    u8 *data, int len)\n{\n\tint ret;\n\n\tdata[0] = 0x00;\n\tdata[1] = 0x00;\n\tdata[2] = 0x00;\n\tdata[3] = len;\n\n\tprint_hex_dump_bytes(\"Calibration data: \",\n\t\t\t     DUMP_PREFIX_OFFSET, data, BT_CAL_HDR_LEN + len);\n\n\tret = btmrvl_send_sync_cmd(priv, BT_CMD_LOAD_CONFIG_DATA, data,\n\t\t\t\t   BT_CAL_HDR_LEN + len);\n\tif (ret)\n\t\tBT_ERR(\"Failed to download calibration data\");\n\n\treturn 0;\n}\n\nstatic int btmrvl_check_device_tree(struct btmrvl_private *priv)\n{\n\tstruct device_node *dt_node;\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tu8 cal_data[BT_CAL_HDR_LEN + BT_CAL_DATA_SIZE];\n\tint ret = 0;\n\tu16 gpio, gap;\n\n\tif (card->plt_of_node) {\n\t\tdt_node = card->plt_of_node;\n\t\tret = of_property_read_u16(dt_node, \"marvell,wakeup-pin\",\n\t\t\t\t\t   &gpio);\n\t\tif (ret)\n\t\t\tgpio = (priv->btmrvl_dev.gpio_gap & 0xff00) >> 8;\n\n\t\tret = of_property_read_u16(dt_node, \"marvell,wakeup-gap-ms\",\n\t\t\t\t\t   &gap);\n\t\tif (ret)\n\t\t\tgap = (u8)(priv->btmrvl_dev.gpio_gap & 0x00ff);\n\n\t\tpriv->btmrvl_dev.gpio_gap = (gpio << 8) + gap;\n\n\t\tret = of_property_read_u8_array(dt_node, \"marvell,cal-data\",\n\t\t\t\t\t\tcal_data + BT_CAL_HDR_LEN,\n\t\t\t\t\t\tBT_CAL_DATA_SIZE);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tBT_DBG(\"Use cal data from device tree\");\n\t\tret = btmrvl_download_cal_data(priv, cal_data,\n\t\t\t\t\t       BT_CAL_DATA_SIZE);\n\t\tif (ret)\n\t\t\tBT_ERR(\"Fail to download calibrate data\");\n\t}\n\n\treturn ret;\n}\n\nstatic int btmrvl_setup(struct hci_dev *hdev)\n{\n\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\tint ret;\n\n\tret = btmrvl_send_module_cfg_cmd(priv, MODULE_BRINGUP_REQ);\n\tif (ret)\n\t\treturn ret;\n\n\tpriv->btmrvl_dev.gpio_gap = 0xfffe;\n\n\tbtmrvl_check_device_tree(priv);\n\n\tbtmrvl_enable_sco_routing_to_host(priv);\n\n\tbtmrvl_pscan_window_reporting(priv, 0x01);\n\n\tpriv->btmrvl_dev.psmode = 1;\n\tbtmrvl_enable_ps(priv);\n\n\tbtmrvl_send_hscfg_cmd(priv);\n\n\treturn 0;\n}\n\nstatic int btmrvl_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tlong ret;\n\tu8 buf[8];\n\n\tbuf[0] = MRVL_VENDOR_PKT;\n\tbuf[1] = sizeof(bdaddr_t);\n\tmemcpy(buf + 2, bdaddr, sizeof(bdaddr_t));\n\n\tskb = __hci_cmd_sync(hdev, BT_CMD_SET_BDADDR, sizeof(buf), buf,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tBT_ERR(\"%s: changing btmrvl device address failed (%ld)\",\n\t\t       hdev->name, ret);\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic bool btmrvl_wakeup(struct hci_dev *hdev)\n{\n\tstruct btmrvl_private *priv = hci_get_drvdata(hdev);\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\n\treturn device_may_wakeup(&card->func->dev);\n}\n\n \nstatic int btmrvl_service_main_thread(void *data)\n{\n\tstruct btmrvl_thread *thread = data;\n\tstruct btmrvl_private *priv = thread->priv;\n\tstruct btmrvl_adapter *adapter = priv->adapter;\n\twait_queue_entry_t wait;\n\tstruct sk_buff *skb;\n\tulong flags;\n\n\tinit_waitqueue_entry(&wait, current);\n\n\tfor (;;) {\n\t\tadd_wait_queue(&thread->wait_q, &wait);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (kthread_should_stop() || priv->surprise_removed) {\n\t\t\tBT_DBG(\"main_thread: break from main thread\");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (adapter->wakeup_tries ||\n\t\t\t\t((!adapter->int_count) &&\n\t\t\t\t(!priv->btmrvl_dev.tx_dnld_rdy ||\n\t\t\t\tskb_queue_empty(&adapter->tx_queue)))) {\n\t\t\tBT_DBG(\"main_thread is sleeping...\");\n\t\t\tschedule();\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tremove_wait_queue(&thread->wait_q, &wait);\n\n\t\tBT_DBG(\"main_thread woke up\");\n\n\t\tif (kthread_should_stop() || priv->surprise_removed) {\n\t\t\tBT_DBG(\"main_thread: break from main thread\");\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irqsave(&priv->driver_lock, flags);\n\t\tif (adapter->int_count) {\n\t\t\tadapter->int_count = 0;\n\t\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\t\tpriv->hw_process_int_status(priv);\n\t\t} else if (adapter->ps_state == PS_SLEEP &&\n\t\t\t\t\t!skb_queue_empty(&adapter->tx_queue)) {\n\t\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\t\tadapter->wakeup_tries++;\n\t\t\tpriv->hw_wakeup_firmware(priv);\n\t\t\tcontinue;\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\t\t}\n\n\t\tif (adapter->ps_state == PS_SLEEP)\n\t\t\tcontinue;\n\n\t\tif (!priv->btmrvl_dev.tx_dnld_rdy ||\n\t\t    priv->adapter->is_suspended)\n\t\t\tcontinue;\n\n\t\tskb = skb_dequeue(&adapter->tx_queue);\n\t\tif (skb) {\n\t\t\tif (btmrvl_tx_pkt(priv, skb))\n\t\t\t\tpriv->btmrvl_dev.hcidev->stat.err_tx++;\n\t\t\telse\n\t\t\t\tpriv->btmrvl_dev.hcidev->stat.byte_tx += skb->len;\n\n\t\t\tkfree_skb(skb);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint btmrvl_register_hdev(struct btmrvl_private *priv)\n{\n\tstruct hci_dev *hdev = NULL;\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret;\n\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can not allocate HCI device\");\n\t\tgoto err_hdev;\n\t}\n\n\tpriv->btmrvl_dev.hcidev = hdev;\n\thci_set_drvdata(hdev, priv);\n\n\thdev->bus   = HCI_SDIO;\n\thdev->open  = btmrvl_open;\n\thdev->close = btmrvl_close;\n\thdev->flush = btmrvl_flush;\n\thdev->send  = btmrvl_send_frame;\n\thdev->setup = btmrvl_setup;\n\thdev->set_bdaddr = btmrvl_set_bdaddr;\n\thdev->wakeup = btmrvl_wakeup;\n\tSET_HCIDEV_DEV(hdev, &card->func->dev);\n\n\thdev->dev_type = priv->btmrvl_dev.dev_type;\n\n\tret = hci_register_dev(hdev);\n\tif (ret < 0) {\n\t\tBT_ERR(\"Can not register HCI device\");\n\t\tgoto err_hci_register_dev;\n\t}\n\n#ifdef CONFIG_DEBUG_FS\n\tbtmrvl_debugfs_init(hdev);\n#endif\n\n\treturn 0;\n\nerr_hci_register_dev:\n\thci_free_dev(hdev);\n\nerr_hdev:\n\t \n\tkthread_stop(priv->main_thread.task);\n\n\tbtmrvl_free_adapter(priv);\n\tkfree(priv);\n\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(btmrvl_register_hdev);\n\nstruct btmrvl_private *btmrvl_add_card(void *card)\n{\n\tstruct btmrvl_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv) {\n\t\tBT_ERR(\"Can not allocate priv\");\n\t\tgoto err_priv;\n\t}\n\n\tpriv->adapter = kzalloc(sizeof(*priv->adapter), GFP_KERNEL);\n\tif (!priv->adapter) {\n\t\tBT_ERR(\"Allocate buffer for btmrvl_adapter failed!\");\n\t\tgoto err_adapter;\n\t}\n\n\tbtmrvl_init_adapter(priv);\n\n\tBT_DBG(\"Starting kthread...\");\n\tpriv->main_thread.priv = priv;\n\tspin_lock_init(&priv->driver_lock);\n\n\tinit_waitqueue_head(&priv->main_thread.wait_q);\n\tpriv->main_thread.task = kthread_run(btmrvl_service_main_thread,\n\t\t\t\t&priv->main_thread, \"btmrvl_main_service\");\n\tif (IS_ERR(priv->main_thread.task))\n\t\tgoto err_thread;\n\n\tpriv->btmrvl_dev.card = card;\n\tpriv->btmrvl_dev.tx_dnld_rdy = true;\n\n\treturn priv;\n\nerr_thread:\n\tbtmrvl_free_adapter(priv);\n\nerr_adapter:\n\tkfree(priv);\n\nerr_priv:\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(btmrvl_add_card);\n\nint btmrvl_remove_card(struct btmrvl_private *priv)\n{\n\tstruct hci_dev *hdev;\n\n\thdev = priv->btmrvl_dev.hcidev;\n\n\twake_up_interruptible(&priv->adapter->cmd_wait_q);\n\twake_up_interruptible(&priv->adapter->event_hs_wait_q);\n\n\tkthread_stop(priv->main_thread.task);\n\n#ifdef CONFIG_DEBUG_FS\n\tbtmrvl_debugfs_remove(hdev);\n#endif\n\n\thci_unregister_dev(hdev);\n\n\thci_free_dev(hdev);\n\n\tpriv->btmrvl_dev.hcidev = NULL;\n\n\tbtmrvl_free_adapter(priv);\n\n\tkfree(priv);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btmrvl_remove_card);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell Bluetooth driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}