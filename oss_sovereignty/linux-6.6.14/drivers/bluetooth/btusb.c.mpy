{
  "module_name": "btusb.c",
  "hash_id": "a866fe25ff920257acc763b5cdfcc74364c4d17364eabaa48165e154fe6224f8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btusb.c",
  "human_readable_source": "\n \n\n#include <linux/dmi.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/quirks.h>\n#include <linux/firmware.h>\n#include <linux/iopoll.h>\n#include <linux/of_device.h>\n#include <linux/of_irq.h>\n#include <linux/suspend.h>\n#include <linux/gpio/consumer.h>\n#include <linux/debugfs.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btintel.h\"\n#include \"btbcm.h\"\n#include \"btrtl.h\"\n#include \"btmtk.h\"\n\n#define VERSION \"0.8\"\n\nstatic bool disable_scofix;\nstatic bool force_scofix;\nstatic bool enable_autosuspend = IS_ENABLED(CONFIG_BT_HCIBTUSB_AUTOSUSPEND);\nstatic bool enable_poll_sync = IS_ENABLED(CONFIG_BT_HCIBTUSB_POLL_SYNC);\nstatic bool reset = true;\n\nstatic struct usb_driver btusb_driver;\n\n#define BTUSB_IGNORE\t\t\tBIT(0)\n#define BTUSB_DIGIANSWER\t\tBIT(1)\n#define BTUSB_CSR\t\t\tBIT(2)\n#define BTUSB_SNIFFER\t\t\tBIT(3)\n#define BTUSB_BCM92035\t\t\tBIT(4)\n#define BTUSB_BROKEN_ISOC\t\tBIT(5)\n#define BTUSB_WRONG_SCO_MTU\t\tBIT(6)\n#define BTUSB_ATH3012\t\t\tBIT(7)\n#define BTUSB_INTEL_COMBINED\t\tBIT(8)\n#define BTUSB_INTEL_BOOT\t\tBIT(9)\n#define BTUSB_BCM_PATCHRAM\t\tBIT(10)\n#define BTUSB_MARVELL\t\t\tBIT(11)\n#define BTUSB_SWAVE\t\t\tBIT(12)\n#define BTUSB_AMP\t\t\tBIT(13)\n#define BTUSB_QCA_ROME\t\t\tBIT(14)\n#define BTUSB_BCM_APPLE\t\t\tBIT(15)\n#define BTUSB_REALTEK\t\t\tBIT(16)\n#define BTUSB_BCM2045\t\t\tBIT(17)\n#define BTUSB_IFNUM_2\t\t\tBIT(18)\n#define BTUSB_CW6622\t\t\tBIT(19)\n#define BTUSB_MEDIATEK\t\t\tBIT(20)\n#define BTUSB_WIDEBAND_SPEECH\t\tBIT(21)\n#define BTUSB_VALID_LE_STATES\t\tBIT(22)\n#define BTUSB_QCA_WCN6855\t\tBIT(23)\n#define BTUSB_INTEL_BROKEN_SHUTDOWN_LED\tBIT(24)\n#define BTUSB_INTEL_BROKEN_INITIAL_NCMD BIT(25)\n#define BTUSB_INTEL_NO_WBS_SUPPORT\tBIT(26)\n#define BTUSB_ACTIONS_SEMI\t\tBIT(27)\n\nstatic const struct usb_device_id btusb_table[] = {\n\t \n\t{ USB_DEVICE_INFO(0xe0, 0x01, 0x01) },\n\n\t \n\t{ USB_DEVICE_INFO(0xe0, 0x01, 0x04), .driver_info = BTUSB_AMP },\n\n\t \n\t{ USB_INTERFACE_INFO(0xe0, 0x01, 0x01) },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x05ac, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_APPLE | BTUSB_IFNUM_2 },\n\n\t \n\t{ USB_DEVICE(0x0e8d, 0x763f) },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x21e1) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x8213) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x8215) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x8218) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x821b) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x821f) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x821a) },\n\n\t \n\t{ USB_DEVICE(0x05ac, 0x8281) },\n\n\t \n\t{ USB_DEVICE(0x057c, 0x3800), .driver_info = BTUSB_SWAVE },\n\n\t \n\t{ USB_DEVICE(0x04bf, 0x030a) },\n\n\t \n\t{ USB_DEVICE(0x044e, 0x3001) },\n\t{ USB_DEVICE(0x044e, 0x3002) },\n\n\t \n\t{ USB_DEVICE(0x0bdb, 0x1002) },\n\n\t \n\t{ USB_DEVICE(0x0c10, 0x0000) },\n\n\t \n\t{ USB_DEVICE(0x19ff, 0x0239), .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x105b, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0bb4, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0489, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x04ca, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0b05, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x050d, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x13d3, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x413c, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0930, 0xff, 0x01, 0x01),\n\t  .driver_info = BTUSB_BCM_PATCHRAM },\n\n\t \n\t{ USB_DEVICE(0x8087, 0x0a5a),\n\t  .driver_info = BTUSB_INTEL_BOOT | BTUSB_BROKEN_ISOC },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, btusb_table);\n\nstatic const struct usb_device_id quirks_table[] = {\n\t \n\t{ USB_DEVICE(0x0a12, 0x0001), .driver_info = BTUSB_CSR },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x2033), .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x2045), .driver_info = BTUSB_BCM2045 },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x0489, 0xe03d), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x04f2, 0xaff1), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x0930, 0x0215), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x0cf3, 0x3002), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x0cf3, 0xe019), .driver_info = BTUSB_IGNORE },\n\t{ USB_DEVICE(0x13d3, 0x3304), .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x03f0, 0x311d), .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe04d), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe04e), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe095), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3006), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3018), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0227), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0b05, 0x17d0), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x0036), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3008), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311d), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311e), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311f), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3121), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x817a), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x817b), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe003), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe005), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe006), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3395), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe036), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe03c), .driver_info = BTUSB_ATH3012 },\n\n\t \n\t{ USB_DEVICE(0x0cf3, 0x535b), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe007), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe009), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe010), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe300), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe301), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe360), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cf3, 0xe500), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0489, 0xe092), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0489, 0xe09f), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0489, 0xe0a2), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x3011), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x3015), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x3016), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x301a), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x3021), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3491), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3496), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3501), .driver_info = BTUSB_QCA_ROME |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x0cf3, 0xe600), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0cc), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0d6), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0e3), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9309), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9409), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0d0), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9108), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9109), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9208), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9209), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9308), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9408), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9508), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9509), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9608), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9609), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x10ab, 0x9f09), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3022), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0c7), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0c9), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0ca), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0cb), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0ce), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0de), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0df), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0e1), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0ea), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0ec), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3023), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3024), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3a22), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3a24), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3a26), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3a27), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x0cf3, 0xe700), .driver_info = BTUSB_QCA_WCN6855 |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x2009), .driver_info = BTUSB_BCM92035 },\n\t{ USB_DEVICE(0x0a5c, 0x200a), .driver_info = BTUSB_WRONG_SCO_MTU },\n\t{ USB_DEVICE(0x0a5c, 0x2035), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x2039), .driver_info = BTUSB_WRONG_SCO_MTU },\n\t{ USB_DEVICE(0x0a5c, 0x2101), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x0a5c, 0x201e), .driver_info = BTUSB_WRONG_SCO_MTU },\n\t{ USB_DEVICE(0x0a5c, 0x2110), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x03f0, 0x171d), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x413c, 0x8126), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x413c, 0x8152), .driver_info = BTUSB_WRONG_SCO_MTU },\n\t{ USB_DEVICE(0x413c, 0x8156), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x050d, 0x0012), .driver_info = BTUSB_WRONG_SCO_MTU },\n\t{ USB_DEVICE(0x050d, 0x0013), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x0b05, 0x1715), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x047d, 0x105e), .driver_info = BTUSB_WRONG_SCO_MTU },\n\n\t \n\t{ USB_DEVICE(0x0400, 0x0807), .driver_info = BTUSB_BROKEN_ISOC },\n\t{ USB_DEVICE(0x0400, 0x080a), .driver_info = BTUSB_BROKEN_ISOC },\n\n\t \n\t{ USB_DEVICE(0x0e5e, 0x6622),\n\t  .driver_info = BTUSB_BROKEN_ISOC | BTUSB_CW6622},\n\n\t \n\t{ USB_DEVICE(0x1310, 0x0001), .driver_info = BTUSB_SWAVE },\n\n\t \n\t{ USB_DEVICE(0x08fd, 0x0001), .driver_info = BTUSB_DIGIANSWER },\n\t{ USB_DEVICE(0x08fd, 0x0002), .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x0a12, 0x0002),\n\t  .driver_info = BTUSB_SNIFFER | BTUSB_BROKEN_ISOC },\n\n\t \n\t{ USB_DEVICE(0x16d3, 0x0002),\n\t  .driver_info = BTUSB_SNIFFER | BTUSB_BROKEN_ISOC },\n\n\t \n\t{ USB_DEVICE(0x1286, 0x2044), .driver_info = BTUSB_MARVELL },\n\t{ USB_DEVICE(0x1286, 0x2046), .driver_info = BTUSB_MARVELL },\n\t{ USB_DEVICE(0x1286, 0x204e), .driver_info = BTUSB_MARVELL },\n\n\t \n\t{ USB_DEVICE(0x8087, 0x0025), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0026), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0029), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0032), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0033), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0035), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0036), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x07da), .driver_info = BTUSB_CSR },\n\t{ USB_DEVICE(0x8087, 0x07dc), .driver_info = BTUSB_INTEL_COMBINED |\n\t\t\t\t\t\t     BTUSB_INTEL_NO_WBS_SUPPORT |\n\t\t\t\t\t\t     BTUSB_INTEL_BROKEN_INITIAL_NCMD |\n\t\t\t\t\t\t     BTUSB_INTEL_BROKEN_SHUTDOWN_LED },\n\t{ USB_DEVICE(0x8087, 0x0a2a), .driver_info = BTUSB_INTEL_COMBINED |\n\t\t\t\t\t\t     BTUSB_INTEL_NO_WBS_SUPPORT |\n\t\t\t\t\t\t     BTUSB_INTEL_BROKEN_SHUTDOWN_LED },\n\t{ USB_DEVICE(0x8087, 0x0a2b), .driver_info = BTUSB_INTEL_COMBINED },\n\t{ USB_DEVICE(0x8087, 0x0aa7), .driver_info = BTUSB_INTEL_COMBINED |\n\t\t\t\t\t\t     BTUSB_INTEL_BROKEN_SHUTDOWN_LED },\n\t{ USB_DEVICE(0x8087, 0x0aaa), .driver_info = BTUSB_INTEL_COMBINED },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x8087, 0xe0, 0x01, 0x01),\n\t  .driver_info = BTUSB_IGNORE },\n\n\t \n\t{ USB_DEVICE(0x13d3, 0x3529), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x0bda, 0xb00c), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0xc822), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x13d3, 0x3549), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x0bda, 0x2852), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0xc852), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0x385a), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0x4852), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04c5, 0x165c), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04ca, 0x4006), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cb8, 0xc549), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x04ca, 0x4007), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04c5, 0x1675), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cb8, 0xc558), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3587), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3586), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3592), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x0cb8, 0xc559), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0x887b), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0xb85b), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3570), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3571), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0bda, 0xe0, 0x01, 0x01),\n\t  .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_VENDOR_AND_INTERFACE_INFO(0x0e8d, 0xe0, 0x01, 0x01),\n\t  .driver_info = BTUSB_MEDIATEK |\n\t\t\t BTUSB_WIDEBAND_SPEECH |\n\t\t\t BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x13d3, 0x3560), .driver_info = BTUSB_MEDIATEK},\n\n\t \n\t{ USB_DEVICE(0x043e, 0x310c), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3801), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x043e, 0x3109), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe0c8), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0e0), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f2), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3802), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3563), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3564), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3567), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3578), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3583), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0cd), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0e8d, 0x0608), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe0d8), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0d9), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f5), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x13d3, 0x3568), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0e2), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0e4), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f1), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f2), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f5), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe0f6), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x0489, 0xe102), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\t{ USB_DEVICE(0x04ca, 0x3804), .driver_info = BTUSB_MEDIATEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH |\n\t\t\t\t\t\t     BTUSB_VALID_LE_STATES },\n\n\t \n\t{ USB_DEVICE(0x0930, 0x021d), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3394), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe085), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x0489, 0xe08b), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x04f2, 0xb49f), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3410), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3416), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3459), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3494), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x7392, 0xa611), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x0bda, 0xb009), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x2ff8, 0xb011), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x2357, 0x0604), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0b05, 0x190e), .driver_info = BTUSB_REALTEK |\n\t  \t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x2550, 0x8761), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0x8771), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x6655, 0x8771), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x7392, 0xc611), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x2b89, 0x8761), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x0b05, 0x17dc), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3414), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3458), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3461), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x13d3, 0x3462), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x13d3, 0x3526), .driver_info = BTUSB_REALTEK },\n\t{ USB_DEVICE(0x0b05, 0x185c), .driver_info = BTUSB_REALTEK },\n\n\t \n\t{ USB_DEVICE(0x04ca, 0x4005), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x04c5, 0x161f), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0b05, 0x18ef), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3548), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3549), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3553), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x13d3, 0x3555), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x2ff8, 0x3051), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x1358, 0xc123), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0bda, 0xc123), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\t{ USB_DEVICE(0x0cb5, 0xc547), .driver_info = BTUSB_REALTEK |\n\t\t\t\t\t\t     BTUSB_WIDEBAND_SPEECH },\n\n\t \n\t{ USB_DEVICE(0x10d7, 0xb012), .driver_info = BTUSB_ACTIONS_SEMI },\n\n\t \n\t{ USB_DEVICE(0x0c10, 0x0000), .driver_info = BTUSB_SWAVE },\n\n\t{ }\t \n};\n\n \nstatic const struct dmi_system_id btusb_needs_reset_resume_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"OptiPlex 3060\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"XPS 13 9360\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Dell Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"Inspiron 5565\"),\n\t\t},\n\t},\n\t{}\n};\n\nstruct qca_dump_info {\n\t \n\tu16 id_vendor;\n\tu16 id_product;\n\tu32 fw_version;\n\tu32 controller_id;\n\tu32 ram_dump_size;\n\tu16 ram_dump_seqno;\n};\n\n#define BTUSB_MAX_ISOC_FRAMES\t10\n\n#define BTUSB_INTR_RUNNING\t0\n#define BTUSB_BULK_RUNNING\t1\n#define BTUSB_ISOC_RUNNING\t2\n#define BTUSB_SUSPENDING\t3\n#define BTUSB_DID_ISO_RESUME\t4\n#define BTUSB_BOOTLOADER\t5\n#define BTUSB_DOWNLOADING\t6\n#define BTUSB_FIRMWARE_LOADED\t7\n#define BTUSB_FIRMWARE_FAILED\t8\n#define BTUSB_BOOTING\t\t9\n#define BTUSB_DIAG_RUNNING\t10\n#define BTUSB_OOB_WAKE_ENABLED\t11\n#define BTUSB_HW_RESET_ACTIVE\t12\n#define BTUSB_TX_WAIT_VND_EVT\t13\n#define BTUSB_WAKEUP_AUTOSUSPEND\t14\n#define BTUSB_USE_ALT3_FOR_WBS\t15\n#define BTUSB_ALT6_CONTINUOUS_TX\t16\n#define BTUSB_HW_SSR_ACTIVE\t17\n\nstruct btusb_data {\n\tstruct hci_dev       *hdev;\n\tstruct usb_device    *udev;\n\tstruct usb_interface *intf;\n\tstruct usb_interface *isoc;\n\tstruct usb_interface *diag;\n\tunsigned isoc_ifnum;\n\n\tunsigned long flags;\n\n\tbool poll_sync;\n\tint intr_interval;\n\tstruct work_struct  work;\n\tstruct work_struct  waker;\n\tstruct delayed_work rx_work;\n\n\tstruct sk_buff_head acl_q;\n\n\tstruct usb_anchor deferred;\n\tstruct usb_anchor tx_anchor;\n\tint tx_in_flight;\n\tspinlock_t txlock;\n\n\tstruct usb_anchor intr_anchor;\n\tstruct usb_anchor bulk_anchor;\n\tstruct usb_anchor isoc_anchor;\n\tstruct usb_anchor diag_anchor;\n\tstruct usb_anchor ctrl_anchor;\n\tspinlock_t rxlock;\n\n\tstruct sk_buff *evt_skb;\n\tstruct sk_buff *acl_skb;\n\tstruct sk_buff *sco_skb;\n\n\tstruct usb_endpoint_descriptor *intr_ep;\n\tstruct usb_endpoint_descriptor *bulk_tx_ep;\n\tstruct usb_endpoint_descriptor *bulk_rx_ep;\n\tstruct usb_endpoint_descriptor *isoc_tx_ep;\n\tstruct usb_endpoint_descriptor *isoc_rx_ep;\n\tstruct usb_endpoint_descriptor *diag_tx_ep;\n\tstruct usb_endpoint_descriptor *diag_rx_ep;\n\n\tstruct gpio_desc *reset_gpio;\n\n\t__u8 cmdreq_type;\n\t__u8 cmdreq;\n\n\tunsigned int sco_num;\n\tunsigned int air_mode;\n\tbool usb_alt6_packet_flow;\n\tint isoc_altsetting;\n\tint suspend_count;\n\n\tint (*recv_event)(struct hci_dev *hdev, struct sk_buff *skb);\n\tint (*recv_acl)(struct hci_dev *hdev, struct sk_buff *skb);\n\tint (*recv_bulk)(struct btusb_data *data, void *buffer, int count);\n\n\tint (*setup_on_usb)(struct hci_dev *hdev);\n\n\tint oob_wake_irq;    \n\tunsigned cmd_timeout_cnt;\n\n\tstruct qca_dump_info qca_dump;\n};\n\nstatic void btusb_reset(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data;\n\tint err;\n\n\tif (hdev->reset) {\n\t\thdev->reset(hdev);\n\t\treturn;\n\t}\n\n\tdata = hci_get_drvdata(hdev);\n\t \n\terr = usb_autopm_get_interface(data->intf);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Failed usb_autopm_get_interface: %d\", err);\n\t\treturn;\n\t}\n\n\tbt_dev_err(hdev, \"Resetting usb device.\");\n\tusb_queue_reset_device(data->intf);\n}\n\nstatic void btusb_intel_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct gpio_desc *reset_gpio = data->reset_gpio;\n\tstruct btintel_data *intel_data = hci_get_priv(hdev);\n\n\tif (++data->cmd_timeout_cnt < 5)\n\t\treturn;\n\n\tif (intel_data->acpi_reset_method) {\n\t\tif (test_and_set_bit(INTEL_ACPI_RESET_ACTIVE, intel_data->flags)) {\n\t\t\tbt_dev_err(hdev, \"acpi: last reset failed ? Not resetting again\");\n\t\t\treturn;\n\t\t}\n\n\t\tbt_dev_err(hdev, \"Initiating acpi reset method\");\n\t\t \n\t\tif (!intel_data->acpi_reset_method(hdev)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!reset_gpio) {\n\t\tbtusb_reset(hdev);\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {\n\t\tbt_dev_err(hdev, \"last reset failed? Not resetting again\");\n\t\treturn;\n\t}\n\n\tbt_dev_err(hdev, \"Initiating HW reset via gpio\");\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\tmsleep(100);\n\tgpiod_set_value_cansleep(reset_gpio, 0);\n}\n\n#define RTK_DEVCOREDUMP_CODE_MEMDUMP\t\t0x01\n#define RTK_DEVCOREDUMP_CODE_HW_ERR\t\t0x02\n#define RTK_DEVCOREDUMP_CODE_CMD_TIMEOUT\t0x03\n\n#define RTK_SUB_EVENT_CODE_COREDUMP\t\t0x34\n\nstruct rtk_dev_coredump_hdr {\n\tu8 type;\n\tu8 code;\n\tu8 reserved[2];\n} __packed;\n\nstatic inline void btusb_rtl_alloc_devcoredump(struct hci_dev *hdev,\n\t\tstruct rtk_dev_coredump_hdr *hdr, u8 *buf, u32 len)\n{\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len + sizeof(*hdr), GFP_ATOMIC);\n\tif (!skb)\n\t\treturn;\n\n\tskb_put_data(skb, hdr, sizeof(*hdr));\n\tif (len)\n\t\tskb_put_data(skb, buf, len);\n\n\tif (!hci_devcd_init(hdev, skb->len)) {\n\t\thci_devcd_append(hdev, skb);\n\t\thci_devcd_complete(hdev);\n\t} else {\n\t\tbt_dev_err(hdev, \"RTL: Failed to generate devcoredump\");\n\t\tkfree_skb(skb);\n\t}\n}\n\nstatic void btusb_rtl_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct gpio_desc *reset_gpio = data->reset_gpio;\n\tstruct rtk_dev_coredump_hdr hdr = {\n\t\t.type = RTK_DEVCOREDUMP_CODE_CMD_TIMEOUT,\n\t};\n\n\tbtusb_rtl_alloc_devcoredump(hdev, &hdr, NULL, 0);\n\n\tif (++data->cmd_timeout_cnt < 5)\n\t\treturn;\n\n\tif (!reset_gpio) {\n\t\tbtusb_reset(hdev);\n\t\treturn;\n\t}\n\n\t \n\tif (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {\n\t\tbt_dev_err(hdev, \"last reset failed? Not resetting again\");\n\t\treturn;\n\t}\n\n\tbt_dev_err(hdev, \"Reset Realtek device via gpio\");\n\tgpiod_set_value_cansleep(reset_gpio, 1);\n\tmsleep(200);\n\tgpiod_set_value_cansleep(reset_gpio, 0);\n}\n\nstatic void btusb_rtl_hw_error(struct hci_dev *hdev, u8 code)\n{\n\tstruct rtk_dev_coredump_hdr hdr = {\n\t\t.type = RTK_DEVCOREDUMP_CODE_HW_ERR,\n\t\t.code = code,\n\t};\n\n\tbt_dev_err(hdev, \"RTL: hw err, trigger devcoredump (%d)\", code);\n\n\tbtusb_rtl_alloc_devcoredump(hdev, &hdr, NULL, 0);\n}\n\nstatic void btusb_qca_cmd_timeout(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct gpio_desc *reset_gpio = data->reset_gpio;\n\n\tif (test_bit(BTUSB_HW_SSR_ACTIVE, &data->flags)) {\n\t\tbt_dev_info(hdev, \"Ramdump in progress, defer cmd_timeout\");\n\t\treturn;\n\t}\n\n\tif (++data->cmd_timeout_cnt < 5)\n\t\treturn;\n\n\tif (reset_gpio) {\n\t\tbt_dev_err(hdev, \"Reset qca device via bt_en gpio\");\n\n\t\t \n\t\tif (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {\n\t\t\tbt_dev_err(hdev, \"last reset failed? Not resetting again\");\n\t\t\treturn;\n\t\t}\n\n\t\tgpiod_set_value_cansleep(reset_gpio, 0);\n\t\tmsleep(200);\n\t\tgpiod_set_value_cansleep(reset_gpio, 1);\n\n\t\treturn;\n\t}\n\n\tbtusb_reset(hdev);\n}\n\nstatic inline void btusb_free_frags(struct btusb_data *data)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&data->rxlock, flags);\n\n\tdev_kfree_skb_irq(data->evt_skb);\n\tdata->evt_skb = NULL;\n\n\tdev_kfree_skb_irq(data->acl_skb);\n\tdata->acl_skb = NULL;\n\n\tdev_kfree_skb_irq(data->sco_skb);\n\tdata->sco_skb = NULL;\n\n\tspin_unlock_irqrestore(&data->rxlock, flags);\n}\n\nstatic int btusb_recv_event(struct btusb_data *data, struct sk_buff *skb)\n{\n\tif (data->intr_interval) {\n\t\t \n\t\tschedule_delayed_work(&data->rx_work, 0);\n\t}\n\n\treturn data->recv_event(data->hdev, skb);\n}\n\nstatic int btusb_recv_intr(struct btusb_data *data, void *buffer, int count)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&data->rxlock, flags);\n\tskb = data->evt_skb;\n\n\twhile (count) {\n\t\tint len;\n\n\t\tif (!skb) {\n\t\t\tskb = bt_skb_alloc(HCI_MAX_EVENT_SIZE, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\t\t\thci_skb_expect(skb) = HCI_EVENT_HDR_SIZE;\n\t\t}\n\n\t\tlen = min_t(uint, hci_skb_expect(skb), count);\n\t\tskb_put_data(skb, buffer, len);\n\n\t\tcount -= len;\n\t\tbuffer += len;\n\t\thci_skb_expect(skb) -= len;\n\n\t\tif (skb->len == HCI_EVENT_HDR_SIZE) {\n\t\t\t \n\t\t\thci_skb_expect(skb) = hci_event_hdr(skb)->plen;\n\n\t\t\tif (skb_tailroom(skb) < hci_skb_expect(skb)) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\n\t\t\t\terr = -EILSEQ;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!hci_skb_expect(skb)) {\n\t\t\t \n\t\t\tbtusb_recv_event(data, skb);\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tdata->evt_skb = skb;\n\tspin_unlock_irqrestore(&data->rxlock, flags);\n\n\treturn err;\n}\n\nstatic int btusb_recv_acl(struct btusb_data *data, struct sk_buff *skb)\n{\n\t \n\tif (!data->intr_interval)\n\t\treturn data->recv_acl(data->hdev, skb);\n\n\tskb_queue_tail(&data->acl_q, skb);\n\tschedule_delayed_work(&data->rx_work, data->intr_interval);\n\n\treturn 0;\n}\n\nstatic int btusb_recv_bulk(struct btusb_data *data, void *buffer, int count)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&data->rxlock, flags);\n\tskb = data->acl_skb;\n\n\twhile (count) {\n\t\tint len;\n\n\t\tif (!skb) {\n\t\t\tskb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thci_skb_pkt_type(skb) = HCI_ACLDATA_PKT;\n\t\t\thci_skb_expect(skb) = HCI_ACL_HDR_SIZE;\n\t\t}\n\n\t\tlen = min_t(uint, hci_skb_expect(skb), count);\n\t\tskb_put_data(skb, buffer, len);\n\n\t\tcount -= len;\n\t\tbuffer += len;\n\t\thci_skb_expect(skb) -= len;\n\n\t\tif (skb->len == HCI_ACL_HDR_SIZE) {\n\t\t\t__le16 dlen = hci_acl_hdr(skb)->dlen;\n\n\t\t\t \n\t\t\thci_skb_expect(skb) = __le16_to_cpu(dlen);\n\n\t\t\tif (skb_tailroom(skb) < hci_skb_expect(skb)) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\n\t\t\t\terr = -EILSEQ;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!hci_skb_expect(skb)) {\n\t\t\t \n\t\t\tbtusb_recv_acl(data, skb);\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tdata->acl_skb = skb;\n\tspin_unlock_irqrestore(&data->rxlock, flags);\n\n\treturn err;\n}\n\nstatic bool btusb_validate_sco_handle(struct hci_dev *hdev,\n\t\t\t\t      struct hci_sco_hdr *hdr)\n{\n\t__u16 handle;\n\n\tif (hci_dev_test_flag(hdev, HCI_USER_CHANNEL))\n\t\t\n\t\treturn true;\n\n\t \n\n\thandle = hci_handle(__le16_to_cpu(hdr->handle));\n\n\tswitch (hci_conn_lookup_type(hdev, handle)) {\n\tcase SCO_LINK:\n\tcase ESCO_LINK:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic int btusb_recv_isoc(struct btusb_data *data, void *buffer, int count)\n{\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\tint err = 0;\n\n\tspin_lock_irqsave(&data->rxlock, flags);\n\tskb = data->sco_skb;\n\n\twhile (count) {\n\t\tint len;\n\n\t\tif (!skb) {\n\t\t\tskb = bt_skb_alloc(HCI_MAX_SCO_SIZE, GFP_ATOMIC);\n\t\t\tif (!skb) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thci_skb_pkt_type(skb) = HCI_SCODATA_PKT;\n\t\t\thci_skb_expect(skb) = HCI_SCO_HDR_SIZE;\n\t\t}\n\n\t\tlen = min_t(uint, hci_skb_expect(skb), count);\n\t\tskb_put_data(skb, buffer, len);\n\n\t\tcount -= len;\n\t\tbuffer += len;\n\t\thci_skb_expect(skb) -= len;\n\n\t\tif (skb->len == HCI_SCO_HDR_SIZE) {\n\t\t\t \n\t\t\tstruct hci_sco_hdr *hdr = hci_sco_hdr(skb);\n\n\t\t\thci_skb_expect(skb) = hdr->dlen;\n\n\t\t\tif (skb_tailroom(skb) < hci_skb_expect(skb) ||\n\t\t\t    !btusb_validate_sco_handle(data->hdev, hdr)) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tskb = NULL;\n\n\t\t\t\terr = -EILSEQ;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!hci_skb_expect(skb)) {\n\t\t\t \n\t\t\thci_recv_frame(data->hdev, skb);\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\tdata->sco_skb = skb;\n\tspin_unlock_irqrestore(&data->rxlock, flags);\n\n\treturn err;\n}\n\nstatic void btusb_intr_complete(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn;\n\n\tif (urb->status == 0) {\n\t\thdev->stat.byte_rx += urb->actual_length;\n\n\t\tif (btusb_recv_intr(data, urb->transfer_buffer,\n\t\t\t\t    urb->actual_length) < 0) {\n\t\t\tbt_dev_err(hdev, \"corrupted event packet\");\n\t\t\thdev->stat.err_rx++;\n\t\t}\n\t} else if (urb->status == -ENOENT) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!test_bit(BTUSB_INTR_RUNNING, &data->flags))\n\t\treturn;\n\n\tusb_mark_last_busy(data->udev);\n\tusb_anchor_urb(urb, &data->intr_anchor);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\",\n\t\t\t\t   urb, -err);\n\t\tif (err != -EPERM)\n\t\t\thci_cmd_sync_cancel(hdev, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic int btusb_submit_intr_urb(struct hci_dev *hdev, gfp_t mem_flags)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tif (!data->intr_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(0, mem_flags);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tsize = le16_to_cpu(data->intr_ep->wMaxPacketSize);\n\n\tbuf = kmalloc(size, mem_flags);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvintpipe(data->udev, data->intr_ep->bEndpointAddress);\n\n\tusb_fill_int_urb(urb, data->udev, pipe, buf, size,\n\t\t\t btusb_intr_complete, hdev, data->intr_ep->bInterval);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &data->intr_anchor);\n\n\terr = usb_submit_urb(urb, mem_flags);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tif (err != -EPERM)\n\t\t\thci_cmd_sync_cancel(hdev, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\t \n\tif (!data->poll_sync)\n\t\tgoto done;\n\n\t \n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\tcase USB_SPEED_SUPER:\t \n\t\tdata->intr_interval = usecs_to_jiffies(urb->interval * 125);\n\t\tbreak;\n\tdefault:\n\t\tdata->intr_interval = msecs_to_jiffies(urb->interval);\n\t\tbreak;\n\t}\n\ndone:\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void btusb_bulk_complete(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn;\n\n\tif (urb->status == 0) {\n\t\thdev->stat.byte_rx += urb->actual_length;\n\n\t\tif (data->recv_bulk(data, urb->transfer_buffer,\n\t\t\t\t    urb->actual_length) < 0) {\n\t\t\tbt_dev_err(hdev, \"corrupted ACL packet\");\n\t\t\thdev->stat.err_rx++;\n\t\t}\n\t} else if (urb->status == -ENOENT) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!test_bit(BTUSB_BULK_RUNNING, &data->flags))\n\t\treturn;\n\n\tusb_anchor_urb(urb, &data->bulk_anchor);\n\tusb_mark_last_busy(data->udev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic int btusb_submit_bulk_urb(struct hci_dev *hdev, gfp_t mem_flags)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size = HCI_MAX_FRAME_SIZE;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tif (!data->bulk_rx_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(0, mem_flags);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(size, mem_flags);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvbulkpipe(data->udev, data->bulk_rx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe, buf, size,\n\t\t\t  btusb_bulk_complete, hdev);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_mark_last_busy(data->udev);\n\tusb_anchor_urb(urb, &data->bulk_anchor);\n\n\terr = usb_submit_urb(urb, mem_flags);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void btusb_isoc_complete(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint i, err;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn;\n\n\tif (urb->status == 0) {\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tunsigned int offset = urb->iso_frame_desc[i].offset;\n\t\t\tunsigned int length = urb->iso_frame_desc[i].actual_length;\n\n\t\t\tif (urb->iso_frame_desc[i].status)\n\t\t\t\tcontinue;\n\n\t\t\thdev->stat.byte_rx += length;\n\n\t\t\tif (btusb_recv_isoc(data, urb->transfer_buffer + offset,\n\t\t\t\t\t    length) < 0) {\n\t\t\t\tbt_dev_err(hdev, \"corrupted SCO packet\");\n\t\t\t\thdev->stat.err_rx++;\n\t\t\t}\n\t\t}\n\t} else if (urb->status == -ENOENT) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!test_bit(BTUSB_ISOC_RUNNING, &data->flags))\n\t\treturn;\n\n\tusb_anchor_urb(urb, &data->isoc_anchor);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic inline void __fill_isoc_descriptor_msbc(struct urb *urb, int len,\n\t\t\t\t\t       int mtu, struct btusb_data *data)\n{\n\tint i = 0, offset = 0;\n\tunsigned int interval;\n\n\tBT_DBG(\"len %d mtu %d\", len, mtu);\n\n\t \n\tif (test_bit(BTUSB_ALT6_CONTINUOUS_TX, &data->flags))\n\t\tgoto ignore_usb_alt6_packet_flow;\n\n\t \n\tif (data->usb_alt6_packet_flow) {\n\t\tinterval = 7;\n\t\tdata->usb_alt6_packet_flow = false;\n\t} else {\n\t\tinterval = 6;\n\t\tdata->usb_alt6_packet_flow = true;\n\t}\n\n\tfor (i = 0; i < interval; i++) {\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length = offset;\n\t}\n\nignore_usb_alt6_packet_flow:\n\tif (len && i < BTUSB_MAX_ISOC_FRAMES) {\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length = len;\n\t\ti++;\n\t}\n\n\turb->number_of_packets = i;\n}\n\nstatic inline void __fill_isoc_descriptor(struct urb *urb, int len, int mtu)\n{\n\tint i, offset = 0;\n\n\tBT_DBG(\"len %d mtu %d\", len, mtu);\n\n\tfor (i = 0; i < BTUSB_MAX_ISOC_FRAMES && len >= mtu;\n\t\t\t\t\ti++, offset += mtu, len -= mtu) {\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length = mtu;\n\t}\n\n\tif (len && i < BTUSB_MAX_ISOC_FRAMES) {\n\t\turb->iso_frame_desc[i].offset = offset;\n\t\turb->iso_frame_desc[i].length = len;\n\t\ti++;\n\t}\n\n\turb->number_of_packets = i;\n}\n\nstatic int btusb_submit_isoc_urb(struct hci_dev *hdev, gfp_t mem_flags)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tif (!data->isoc_rx_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, mem_flags);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tsize = le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize) *\n\t\t\t\t\t\tBTUSB_MAX_ISOC_FRAMES;\n\n\tbuf = kmalloc(size, mem_flags);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvisocpipe(data->udev, data->isoc_rx_ep->bEndpointAddress);\n\n\tusb_fill_int_urb(urb, data->udev, pipe, buf, size, btusb_isoc_complete,\n\t\t\t hdev, data->isoc_rx_ep->bInterval);\n\n\turb->transfer_flags = URB_FREE_BUFFER | URB_ISO_ASAP;\n\n\t__fill_isoc_descriptor(urb, size,\n\t\t\t       le16_to_cpu(data->isoc_rx_ep->wMaxPacketSize));\n\n\tusb_anchor_urb(urb, &data->isoc_anchor);\n\n\terr = usb_submit_urb(urb, mem_flags);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void btusb_diag_complete(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (urb->status == 0) {\n\t\tstruct sk_buff *skb;\n\n\t\tskb = bt_skb_alloc(urb->actual_length, GFP_ATOMIC);\n\t\tif (skb) {\n\t\t\tskb_put_data(skb, urb->transfer_buffer,\n\t\t\t\t     urb->actual_length);\n\t\t\thci_recv_diag(hdev, skb);\n\t\t}\n\t} else if (urb->status == -ENOENT) {\n\t\t \n\t\treturn;\n\t}\n\n\tif (!test_bit(BTUSB_DIAG_RUNNING, &data->flags))\n\t\treturn;\n\n\tusb_anchor_urb(urb, &data->diag_anchor);\n\tusb_mark_last_busy(data->udev);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic int btusb_submit_diag_urb(struct hci_dev *hdev, gfp_t mem_flags)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size = HCI_MAX_FRAME_SIZE;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tif (!data->diag_rx_ep)\n\t\treturn -ENODEV;\n\n\turb = usb_alloc_urb(0, mem_flags);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(size, mem_flags);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvbulkpipe(data->udev, data->diag_rx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe, buf, size,\n\t\t\t  btusb_diag_complete, hdev);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_mark_last_busy(data->udev);\n\tusb_anchor_urb(urb, &data->diag_anchor);\n\n\terr = usb_submit_urb(urb, mem_flags);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic void btusb_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct hci_dev *hdev = (struct hci_dev *)skb->dev;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\tgoto done;\n\n\tif (!urb->status) {\n\t\thdev->stat.byte_tx += urb->transfer_buffer_length;\n\t} else {\n\t\tif (hci_skb_pkt_type(skb) == HCI_COMMAND_PKT)\n\t\t\thci_cmd_sync_cancel(hdev, -urb->status);\n\t\thdev->stat.err_tx++;\n\t}\n\ndone:\n\tspin_lock_irqsave(&data->txlock, flags);\n\tdata->tx_in_flight--;\n\tspin_unlock_irqrestore(&data->txlock, flags);\n\n\tkfree(urb->setup_packet);\n\n\tkfree_skb(skb);\n}\n\nstatic void btusb_isoc_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct hci_dev *hdev = (struct hci_dev *)skb->dev;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name, urb, urb->status,\n\t       urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\tgoto done;\n\n\tif (!urb->status)\n\t\thdev->stat.byte_tx += urb->transfer_buffer_length;\n\telse\n\t\thdev->stat.err_tx++;\n\ndone:\n\tkfree(urb->setup_packet);\n\n\tkfree_skb(skb);\n}\n\nstatic int btusb_open(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\terr = usb_autopm_get_interface(data->intf);\n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (data->setup_on_usb) {\n\t\terr = data->setup_on_usb(hdev);\n\t\tif (err < 0)\n\t\t\tgoto setup_fail;\n\t}\n\n\tdata->intf->needs_remote_wakeup = 1;\n\n\tif (test_and_set_bit(BTUSB_INTR_RUNNING, &data->flags))\n\t\tgoto done;\n\n\terr = btusb_submit_intr_urb(hdev, GFP_KERNEL);\n\tif (err < 0)\n\t\tgoto failed;\n\n\terr = btusb_submit_bulk_urb(hdev, GFP_KERNEL);\n\tif (err < 0) {\n\t\tusb_kill_anchored_urbs(&data->intr_anchor);\n\t\tgoto failed;\n\t}\n\n\tset_bit(BTUSB_BULK_RUNNING, &data->flags);\n\tbtusb_submit_bulk_urb(hdev, GFP_KERNEL);\n\n\tif (data->diag) {\n\t\tif (!btusb_submit_diag_urb(hdev, GFP_KERNEL))\n\t\t\tset_bit(BTUSB_DIAG_RUNNING, &data->flags);\n\t}\n\ndone:\n\tusb_autopm_put_interface(data->intf);\n\treturn 0;\n\nfailed:\n\tclear_bit(BTUSB_INTR_RUNNING, &data->flags);\nsetup_fail:\n\tusb_autopm_put_interface(data->intf);\n\treturn err;\n}\n\nstatic void btusb_stop_traffic(struct btusb_data *data)\n{\n\tusb_kill_anchored_urbs(&data->intr_anchor);\n\tusb_kill_anchored_urbs(&data->bulk_anchor);\n\tusb_kill_anchored_urbs(&data->isoc_anchor);\n\tusb_kill_anchored_urbs(&data->diag_anchor);\n\tusb_kill_anchored_urbs(&data->ctrl_anchor);\n}\n\nstatic int btusb_close(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tcancel_delayed_work(&data->rx_work);\n\tcancel_work_sync(&data->work);\n\tcancel_work_sync(&data->waker);\n\n\tskb_queue_purge(&data->acl_q);\n\n\tclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\n\tclear_bit(BTUSB_BULK_RUNNING, &data->flags);\n\tclear_bit(BTUSB_INTR_RUNNING, &data->flags);\n\tclear_bit(BTUSB_DIAG_RUNNING, &data->flags);\n\n\tbtusb_stop_traffic(data);\n\tbtusb_free_frags(data);\n\n\terr = usb_autopm_get_interface(data->intf);\n\tif (err < 0)\n\t\tgoto failed;\n\n\tdata->intf->needs_remote_wakeup = 0;\n\n\t \n\tif (test_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags))\n\t\tdata->intf->needs_remote_wakeup = 1;\n\n\tusb_autopm_put_interface(data->intf);\n\nfailed:\n\tusb_scuttle_anchored_urbs(&data->deferred);\n\treturn 0;\n}\n\nstatic int btusb_flush(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tcancel_delayed_work(&data->rx_work);\n\n\tskb_queue_purge(&data->acl_q);\n\n\tusb_kill_anchored_urbs(&data->tx_anchor);\n\tbtusb_free_frags(data);\n\n\treturn 0;\n}\n\nstatic struct urb *alloc_ctrl_urb(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tunsigned int pipe;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdr = kmalloc(sizeof(*dr), GFP_KERNEL);\n\tif (!dr) {\n\t\tusb_free_urb(urb);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tdr->bRequestType = data->cmdreq_type;\n\tdr->bRequest     = data->cmdreq;\n\tdr->wIndex       = 0;\n\tdr->wValue       = 0;\n\tdr->wLength      = __cpu_to_le16(skb->len);\n\n\tpipe = usb_sndctrlpipe(data->udev, 0x00);\n\n\tusb_fill_control_urb(urb, data->udev, pipe, (void *)dr,\n\t\t\t     skb->data, skb->len, btusb_tx_complete, skb);\n\n\tskb->dev = (void *)hdev;\n\n\treturn urb;\n}\n\nstatic struct urb *alloc_bulk_urb(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned int pipe;\n\n\tif (!data->bulk_tx_ep)\n\t\treturn ERR_PTR(-ENODEV);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpipe = usb_sndbulkpipe(data->udev, data->bulk_tx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe,\n\t\t\t  skb->data, skb->len, btusb_tx_complete, skb);\n\n\tskb->dev = (void *)hdev;\n\n\treturn urb;\n}\n\nstatic struct urb *alloc_isoc_urb(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned int pipe;\n\n\tif (!data->isoc_tx_ep)\n\t\treturn ERR_PTR(-ENODEV);\n\n\turb = usb_alloc_urb(BTUSB_MAX_ISOC_FRAMES, GFP_KERNEL);\n\tif (!urb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tpipe = usb_sndisocpipe(data->udev, data->isoc_tx_ep->bEndpointAddress);\n\n\tusb_fill_int_urb(urb, data->udev, pipe,\n\t\t\t skb->data, skb->len, btusb_isoc_tx_complete,\n\t\t\t skb, data->isoc_tx_ep->bInterval);\n\n\turb->transfer_flags  = URB_ISO_ASAP;\n\n\tif (data->isoc_altsetting == 6)\n\t\t__fill_isoc_descriptor_msbc(urb, skb->len,\n\t\t\t\t\t    le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize),\n\t\t\t\t\t    data);\n\telse\n\t\t__fill_isoc_descriptor(urb, skb->len,\n\t\t\t\t       le16_to_cpu(data->isoc_tx_ep->wMaxPacketSize));\n\tskb->dev = (void *)hdev;\n\n\treturn urb;\n}\n\nstatic int submit_tx_urb(struct hci_dev *hdev, struct urb *urb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tusb_anchor_urb(urb, &data->tx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tkfree(urb->setup_packet);\n\t\tusb_unanchor_urb(urb);\n\t} else {\n\t\tusb_mark_last_busy(data->udev);\n\t}\n\n\tusb_free_urb(urb);\n\treturn err;\n}\n\nstatic int submit_or_queue_tx_urb(struct hci_dev *hdev, struct urb *urb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tunsigned long flags;\n\tbool suspending;\n\n\tspin_lock_irqsave(&data->txlock, flags);\n\tsuspending = test_bit(BTUSB_SUSPENDING, &data->flags);\n\tif (!suspending)\n\t\tdata->tx_in_flight++;\n\tspin_unlock_irqrestore(&data->txlock, flags);\n\n\tif (!suspending)\n\t\treturn submit_tx_urb(hdev, urb);\n\n\tusb_anchor_urb(urb, &data->deferred);\n\tschedule_work(&data->waker);\n\n\tusb_free_urb(urb);\n\treturn 0;\n}\n\nstatic int btusb_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct urb *urb;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\turb = alloc_ctrl_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.cmd_tx++;\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\n\tcase HCI_ACLDATA_PKT:\n\t\turb = alloc_bulk_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.acl_tx++;\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\n\tcase HCI_SCODATA_PKT:\n\t\tif (hci_conn_num(hdev, SCO_LINK) < 1)\n\t\t\treturn -ENODEV;\n\n\t\turb = alloc_isoc_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.sco_tx++;\n\t\treturn submit_tx_urb(hdev, urb);\n\n\tcase HCI_ISODATA_PKT:\n\t\turb = alloc_bulk_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\t}\n\n\treturn -EILSEQ;\n}\n\nstatic void btusb_notify(struct hci_dev *hdev, unsigned int evt)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s evt %d\", hdev->name, evt);\n\n\tif (hci_conn_num(hdev, SCO_LINK) != data->sco_num) {\n\t\tdata->sco_num = hci_conn_num(hdev, SCO_LINK);\n\t\tdata->air_mode = evt;\n\t\tschedule_work(&data->work);\n\t}\n}\n\nstatic inline int __set_isoc_interface(struct hci_dev *hdev, int altsetting)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct usb_interface *intf = data->isoc;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tint i, err;\n\n\tif (!data->isoc)\n\t\treturn -ENODEV;\n\n\terr = usb_set_interface(data->udev, data->isoc_ifnum, altsetting);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"setting interface failed (%d)\", -err);\n\t\treturn err;\n\t}\n\n\tdata->isoc_altsetting = altsetting;\n\n\tdata->isoc_tx_ep = NULL;\n\tdata->isoc_rx_ep = NULL;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tep_desc = &intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (!data->isoc_tx_ep && usb_endpoint_is_isoc_out(ep_desc)) {\n\t\t\tdata->isoc_tx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->isoc_rx_ep && usb_endpoint_is_isoc_in(ep_desc)) {\n\t\t\tdata->isoc_rx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!data->isoc_tx_ep || !data->isoc_rx_ep) {\n\t\tbt_dev_err(hdev, \"invalid SCO descriptors\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int btusb_switch_alt_setting(struct hci_dev *hdev, int new_alts)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tif (data->isoc_altsetting != new_alts) {\n\t\tunsigned long flags;\n\n\t\tclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\n\t\tusb_kill_anchored_urbs(&data->isoc_anchor);\n\n\t\t \n\t\tspin_lock_irqsave(&data->rxlock, flags);\n\t\tdev_kfree_skb_irq(data->sco_skb);\n\t\tdata->sco_skb = NULL;\n\t\tspin_unlock_irqrestore(&data->rxlock, flags);\n\n\t\terr = __set_isoc_interface(hdev, new_alts);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (!test_and_set_bit(BTUSB_ISOC_RUNNING, &data->flags)) {\n\t\tif (btusb_submit_isoc_urb(hdev, GFP_KERNEL) < 0)\n\t\t\tclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\n\t\telse\n\t\t\tbtusb_submit_isoc_urb(hdev, GFP_KERNEL);\n\t}\n\n\treturn 0;\n}\n\nstatic struct usb_host_interface *btusb_find_altsetting(struct btusb_data *data,\n\t\t\t\t\t\t\tint alt)\n{\n\tstruct usb_interface *intf = data->isoc;\n\tint i;\n\n\tBT_DBG(\"Looking for Alt no :%d\", alt);\n\n\tif (!intf)\n\t\treturn NULL;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tif (intf->altsetting[i].desc.bAlternateSetting == alt)\n\t\t\treturn &intf->altsetting[i];\n\t}\n\n\treturn NULL;\n}\n\nstatic void btusb_work(struct work_struct *work)\n{\n\tstruct btusb_data *data = container_of(work, struct btusb_data, work);\n\tstruct hci_dev *hdev = data->hdev;\n\tint new_alts = 0;\n\tint err;\n\n\tif (data->sco_num > 0) {\n\t\tif (!test_bit(BTUSB_DID_ISO_RESUME, &data->flags)) {\n\t\t\terr = usb_autopm_get_interface(data->isoc ? data->isoc : data->intf);\n\t\t\tif (err < 0) {\n\t\t\t\tclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\n\t\t\t\tusb_kill_anchored_urbs(&data->isoc_anchor);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tset_bit(BTUSB_DID_ISO_RESUME, &data->flags);\n\t\t}\n\n\t\tif (data->air_mode == HCI_NOTIFY_ENABLE_SCO_CVSD) {\n\t\t\tif (hdev->voice_setting & 0x0020) {\n\t\t\t\tstatic const int alts[3] = { 2, 4, 5 };\n\n\t\t\t\tnew_alts = alts[data->sco_num - 1];\n\t\t\t} else {\n\t\t\t\tnew_alts = data->sco_num;\n\t\t\t}\n\t\t} else if (data->air_mode == HCI_NOTIFY_ENABLE_SCO_TRANSP) {\n\t\t\t \n\t\t\tif (btusb_find_altsetting(data, 6))\n\t\t\t\tnew_alts = 6;\n\t\t\telse if (btusb_find_altsetting(data, 3) &&\n\t\t\t\t hdev->sco_mtu >= 72 &&\n\t\t\t\t test_bit(BTUSB_USE_ALT3_FOR_WBS, &data->flags))\n\t\t\t\tnew_alts = 3;\n\t\t\telse\n\t\t\t\tnew_alts = 1;\n\t\t}\n\n\t\tif (btusb_switch_alt_setting(hdev, new_alts) < 0)\n\t\t\tbt_dev_err(hdev, \"set USB alt:(%d) failed!\", new_alts);\n\t} else {\n\t\tusb_kill_anchored_urbs(&data->isoc_anchor);\n\n\t\tif (test_and_clear_bit(BTUSB_ISOC_RUNNING, &data->flags))\n\t\t\t__set_isoc_interface(hdev, 0);\n\n\t\tif (test_and_clear_bit(BTUSB_DID_ISO_RESUME, &data->flags))\n\t\t\tusb_autopm_put_interface(data->isoc ? data->isoc : data->intf);\n\t}\n}\n\nstatic void btusb_waker(struct work_struct *work)\n{\n\tstruct btusb_data *data = container_of(work, struct btusb_data, waker);\n\tint err;\n\n\terr = usb_autopm_get_interface(data->intf);\n\tif (err < 0)\n\t\treturn;\n\n\tusb_autopm_put_interface(data->intf);\n}\n\nstatic void btusb_rx_work(struct work_struct *work)\n{\n\tstruct btusb_data *data = container_of(work, struct btusb_data,\n\t\t\t\t\t       rx_work.work);\n\tstruct sk_buff *skb;\n\n\t \n\twhile ((skb = skb_dequeue(&data->acl_q)))\n\t\tdata->recv_acl(data->hdev, skb);\n}\n\nstatic int btusb_setup_bcm92035(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tu8 val = 0x00;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc3b, 1, &val, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\tbt_dev_err(hdev, \"BCM92035 command failed (%ld)\", PTR_ERR(skb));\n\telse\n\t\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int btusb_setup_csr(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tu16 bcdDevice = le16_to_cpu(data->udev->descriptor.bcdDevice);\n\tstruct hci_rp_read_local_version *rp;\n\tstruct sk_buff *skb;\n\tbool is_fake = false;\n\tint ret;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"CSR: Local version failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\trp = skb_pull_data(skb, sizeof(*rp));\n\tif (!rp) {\n\t\tbt_dev_err(hdev, \"CSR: Local version length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tbt_dev_info(hdev, \"CSR: Setting up dongle with HCI ver=%u rev=%04x\",\n\t\t    rp->hci_ver, le16_to_cpu(rp->hci_rev));\n\n\tbt_dev_info(hdev, \"LMP ver=%u subver=%04x; manufacturer=%u\",\n\t\t    rp->lmp_ver, le16_to_cpu(rp->lmp_subver),\n\t\t    le16_to_cpu(rp->manufacturer));\n\n\t \n\tif (le16_to_cpu(rp->manufacturer) != 10 ||\n\t    le16_to_cpu(rp->hci_rev) != le16_to_cpu(rp->lmp_subver))\n\t\tis_fake = true;\n\n\t \n\telse if (le16_to_cpu(rp->lmp_subver) <= 0x034e &&\n\t\t rp->hci_ver > BLUETOOTH_VER_1_1)\n\t\tis_fake = true;\n\n\telse if (le16_to_cpu(rp->lmp_subver) <= 0x0529 &&\n\t\t rp->hci_ver > BLUETOOTH_VER_1_2)\n\t\tis_fake = true;\n\n\telse if (le16_to_cpu(rp->lmp_subver) <= 0x0c5c &&\n\t\t rp->hci_ver > BLUETOOTH_VER_2_0)\n\t\tis_fake = true;\n\n\telse if (le16_to_cpu(rp->lmp_subver) <= 0x1899 &&\n\t\t rp->hci_ver > BLUETOOTH_VER_2_1)\n\t\tis_fake = true;\n\n\telse if (le16_to_cpu(rp->lmp_subver) <= 0x22bb &&\n\t\t rp->hci_ver > BLUETOOTH_VER_4_0)\n\t\tis_fake = true;\n\n\t \n\telse if (bcdDevice == 0x0134 &&\n\t\t le16_to_cpu(rp->lmp_subver) == 0x0c5c &&\n\t\t rp->hci_ver == BLUETOOTH_VER_2_0)\n\t\tis_fake = true;\n\n\tif (is_fake) {\n\t\tbt_dev_warn(hdev, \"CSR: Unbranded CSR clone detected; adding workarounds and force-suspending once...\");\n\n\t\t \n\t\tset_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_ERR_DATA_REPORTING, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_FILTER_CLEAR_ALL, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_NO_SUSPEND_NOTIFIER, &hdev->quirks);\n\n\t\t \n\t\tclear_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\t\tclear_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\n\t\t \n\t\tpm_runtime_allow(&data->udev->dev);\n\n\t\tret = pm_runtime_suspend(&data->udev->dev);\n\t\tif (ret >= 0)\n\t\t\tmsleep(200);\n\t\telse\n\t\t\tbt_dev_warn(hdev, \"CSR: Couldn't suspend the device for our Barrot 8041a02 receive-issue workaround\");\n\n\t\tpm_runtime_forbid(&data->udev->dev);\n\n\t\tdevice_set_wakeup_capable(&data->udev->dev, false);\n\n\t\t \n\t\tif (enable_autosuspend)\n\t\t\tusb_enable_autosuspend(data->udev);\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int inject_cmd_complete(struct hci_dev *hdev, __u16 opcode)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_event_hdr *hdr;\n\tstruct hci_ev_cmd_complete *evt;\n\n\tskb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->evt = HCI_EV_CMD_COMPLETE;\n\thdr->plen = sizeof(*evt) + 1;\n\n\tevt = skb_put(skb, sizeof(*evt));\n\tevt->ncmd = 0x01;\n\tevt->opcode = cpu_to_le16(opcode);\n\n\tskb_put_u8(skb, 0x00);\n\n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int btusb_recv_bulk_intel(struct btusb_data *data, void *buffer,\n\t\t\t\t int count)\n{\n\tstruct hci_dev *hdev = data->hdev;\n\n\t \n\tif (btintel_test_flag(hdev, INTEL_BOOTLOADER))\n\t\treturn btusb_recv_intr(data, buffer, count);\n\n\treturn btusb_recv_bulk(data, buffer, count);\n}\n\nstatic int btusb_send_frame_intel(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct urb *urb;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\tif (btintel_test_flag(hdev, INTEL_BOOTLOADER)) {\n\t\t\tstruct hci_command_hdr *cmd = (void *)skb->data;\n\t\t\t__u16 opcode = le16_to_cpu(cmd->opcode);\n\n\t\t\t \n\t\t\tif (opcode == 0xfc09)\n\t\t\t\turb = alloc_bulk_urb(hdev, skb);\n\t\t\telse\n\t\t\t\turb = alloc_ctrl_urb(hdev, skb);\n\n\t\t\t \n\t\t\tif (opcode == 0xfc01)\n\t\t\t\tinject_cmd_complete(hdev, opcode);\n\t\t} else {\n\t\t\turb = alloc_ctrl_urb(hdev, skb);\n\t\t}\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.cmd_tx++;\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\n\tcase HCI_ACLDATA_PKT:\n\t\turb = alloc_bulk_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.acl_tx++;\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\n\tcase HCI_SCODATA_PKT:\n\t\tif (hci_conn_num(hdev, SCO_LINK) < 1)\n\t\t\treturn -ENODEV;\n\n\t\turb = alloc_isoc_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\thdev->stat.sco_tx++;\n\t\treturn submit_tx_urb(hdev, urb);\n\n\tcase HCI_ISODATA_PKT:\n\t\turb = alloc_bulk_urb(hdev, skb);\n\t\tif (IS_ERR(urb))\n\t\t\treturn PTR_ERR(urb);\n\n\t\treturn submit_or_queue_tx_urb(hdev, urb);\n\t}\n\n\treturn -EILSEQ;\n}\n\nstatic int btusb_setup_realtek(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tint ret;\n\n\tret = btrtl_setup_realtek(hdev);\n\n\tif (btrealtek_test_flag(data->hdev, REALTEK_ALT6_CONTINUOUS_TX_CHIP))\n\t\tset_bit(BTUSB_ALT6_CONTINUOUS_TX, &data->flags);\n\n\treturn ret;\n}\n\nstatic int btusb_recv_event_realtek(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tif (skb->data[0] == HCI_VENDOR_PKT && skb->data[2] == RTK_SUB_EVENT_CODE_COREDUMP) {\n\t\tstruct rtk_dev_coredump_hdr hdr = {\n\t\t\t.code = RTK_DEVCOREDUMP_CODE_MEMDUMP,\n\t\t};\n\n\t\tbt_dev_dbg(hdev, \"RTL: received coredump vendor evt, len %u\",\n\t\t\tskb->len);\n\n\t\tbtusb_rtl_alloc_devcoredump(hdev, &hdr, skb->data, skb->len);\n\t\tkfree_skb(skb);\n\n\t\treturn 0;\n\t}\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\n \n#define MTK_BT_MISC\t\t0x70002510\n#define MTK_BT_SUBSYS_RST\t0x70002610\n#define MTK_UDMA_INT_STA_BT\t0x74000024\n#define MTK_UDMA_INT_STA_BT1\t0x74000308\n#define MTK_BT_WDT_STATUS\t0x740003A0\n#define MTK_EP_RST_OPT\t\t0x74011890\n#define MTK_EP_RST_IN_OUT_OPT\t0x00010001\n#define MTK_BT_RST_DONE\t\t0x00000100\n#define MTK_BT_RESET_REG_CONNV3\t0x70028610\n#define MTK_BT_READ_DEV_ID\t0x70010200\n\n\nstatic void btusb_mtk_wmt_recv(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (urb->status == 0 && urb->actual_length > 0) {\n\t\thdev->stat.byte_rx += urb->actual_length;\n\n\t\t \n\t\tskb = bt_skb_alloc(HCI_WMT_MAX_EVENT_SIZE, GFP_ATOMIC);\n\t\tif (!skb) {\n\t\t\thdev->stat.err_rx++;\n\t\t\tkfree(urb->setup_packet);\n\t\t\treturn;\n\t\t}\n\n\t\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\t\tskb_put_data(skb, urb->transfer_buffer, urb->actual_length);\n\n\t\t \n\t\tif (test_bit(BTUSB_TX_WAIT_VND_EVT, &data->flags)) {\n\t\t\tdata->evt_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!data->evt_skb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\tkfree(urb->setup_packet);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\terr = hci_recv_frame(hdev, skb);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(data->evt_skb);\n\t\t\tdata->evt_skb = NULL;\n\t\t\tkfree(urb->setup_packet);\n\t\t\treturn;\n\t\t}\n\n\t\tif (test_and_clear_bit(BTUSB_TX_WAIT_VND_EVT,\n\t\t\t\t       &data->flags)) {\n\t\t\t \n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_bit(&data->flags,\n\t\t\t\t    BTUSB_TX_WAIT_VND_EVT);\n\t\t}\n\t\tkfree(urb->setup_packet);\n\t\treturn;\n\t} else if (urb->status == -ENOENT) {\n\t\t \n\t\treturn;\n\t}\n\n\tusb_mark_last_busy(data->udev);\n\n\t \n\tudelay(500);\n\n\tusb_anchor_urb(urb, &data->ctrl_anchor);\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tkfree(urb->setup_packet);\n\t\t \n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic int btusb_mtk_submit_wmt_recv_urb(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct usb_ctrlrequest *dr;\n\tunsigned char *buf;\n\tint err, size = 64;\n\tunsigned int pipe;\n\tstruct urb *urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tdr = kmalloc(sizeof(*dr), GFP_KERNEL);\n\tif (!dr) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tdr->bRequestType = USB_TYPE_VENDOR | USB_DIR_IN;\n\tdr->bRequest     = 1;\n\tdr->wIndex       = cpu_to_le16(0);\n\tdr->wValue       = cpu_to_le16(48);\n\tdr->wLength      = cpu_to_le16(size);\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tkfree(dr);\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvctrlpipe(data->udev, 0);\n\n\tusb_fill_control_urb(urb, data->udev, pipe, (void *)dr,\n\t\t\t     buf, size, btusb_mtk_wmt_recv, hdev);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &data->ctrl_anchor);\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\",\n\t\t\t\t   urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic int btusb_mtk_hci_wmt_sync(struct hci_dev *hdev,\n\t\t\t\t  struct btmtk_hci_wmt_params *wmt_params)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_evt_funcc *wmt_evt_funcc;\n\tu32 hlen, status = BTMTK_WMT_INVALID;\n\tstruct btmtk_hci_wmt_evt *wmt_evt;\n\tstruct btmtk_hci_wmt_cmd *wc;\n\tstruct btmtk_wmt_hdr *hdr;\n\tint err;\n\n\t \n\thlen = sizeof(*hdr) + wmt_params->dlen;\n\tif (hlen > 255)\n\t\treturn -EINVAL;\n\n\twc = kzalloc(hlen, GFP_KERNEL);\n\tif (!wc)\n\t\treturn -ENOMEM;\n\n\thdr = &wc->hdr;\n\thdr->dir = 1;\n\thdr->op = wmt_params->op;\n\thdr->dlen = cpu_to_le16(wmt_params->dlen + 1);\n\thdr->flag = wmt_params->flag;\n\tmemcpy(wc->data, wmt_params->data, wmt_params->dlen);\n\n\tset_bit(BTUSB_TX_WAIT_VND_EVT, &data->flags);\n\n\t \n\terr = usb_autopm_get_interface(data->intf);\n\tif (err < 0)\n\t\tgoto err_free_wc;\n\n\terr = __hci_cmd_send(hdev, 0xfc6f, hlen, wc);\n\n\tif (err < 0) {\n\t\tclear_bit(BTUSB_TX_WAIT_VND_EVT, &data->flags);\n\t\tusb_autopm_put_interface(data->intf);\n\t\tgoto err_free_wc;\n\t}\n\n\t \n\terr = btusb_mtk_submit_wmt_recv_urb(hdev);\n\n\tusb_autopm_put_interface(data->intf);\n\n\tif (err < 0)\n\t\tgoto err_free_wc;\n\n\t \n\terr = wait_on_bit_timeout(&data->flags, BTUSB_TX_WAIT_VND_EVT,\n\t\t\t\t  TASK_INTERRUPTIBLE, HCI_INIT_TIMEOUT);\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command interrupted\");\n\t\tclear_bit(BTUSB_TX_WAIT_VND_EVT, &data->flags);\n\t\tgoto err_free_wc;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command timed out\");\n\t\tclear_bit(BTUSB_TX_WAIT_VND_EVT, &data->flags);\n\t\terr = -ETIMEDOUT;\n\t\tgoto err_free_wc;\n\t}\n\n\tif (data->evt_skb == NULL)\n\t\tgoto err_free_wc;\n\n\t \n\twmt_evt = (struct btmtk_hci_wmt_evt *)data->evt_skb->data;\n\tif (wmt_evt->whdr.op != hdr->op) {\n\t\tbt_dev_err(hdev, \"Wrong op received %d expected %d\",\n\t\t\t   wmt_evt->whdr.op, hdr->op);\n\t\terr = -EIO;\n\t\tgoto err_free_skb;\n\t}\n\n\tswitch (wmt_evt->whdr.op) {\n\tcase BTMTK_WMT_SEMAPHORE:\n\t\tif (wmt_evt->whdr.flag == 2)\n\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n\t\tbreak;\n\tcase BTMTK_WMT_FUNC_CTRL:\n\t\twmt_evt_funcc = (struct btmtk_hci_wmt_evt_funcc *)wmt_evt;\n\t\tif (be16_to_cpu(wmt_evt_funcc->status) == 0x404)\n\t\t\tstatus = BTMTK_WMT_ON_DONE;\n\t\telse if (be16_to_cpu(wmt_evt_funcc->status) == 0x420)\n\t\t\tstatus = BTMTK_WMT_ON_PROGRESS;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_ON_UNDONE;\n\t\tbreak;\n\tcase BTMTK_WMT_PATCH_DWNLD:\n\t\tif (wmt_evt->whdr.flag == 2)\n\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n\t\telse if (wmt_evt->whdr.flag == 1)\n\t\t\tstatus = BTMTK_WMT_PATCH_PROGRESS;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n\t\tbreak;\n\t}\n\n\tif (wmt_params->status)\n\t\t*wmt_params->status = status;\n\nerr_free_skb:\n\tkfree_skb(data->evt_skb);\n\tdata->evt_skb = NULL;\nerr_free_wc:\n\tkfree(wc);\n\treturn err;\n}\n\nstatic int btusb_mtk_func_query(struct hci_dev *hdev)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tint status, err;\n\tu8 param = 0;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 4;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = &status;\n\n\terr = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query function status (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn status;\n}\n\nstatic int btusb_mtk_uhw_reg_write(struct btusb_data *data, u32 reg, u32 val)\n{\n\tstruct hci_dev *hdev = data->hdev;\n\tint pipe, err;\n\tvoid *buf;\n\n\tbuf = kzalloc(4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tput_unaligned_le32(val, buf);\n\n\tpipe = usb_sndctrlpipe(data->udev, 0);\n\terr = usb_control_msg(data->udev, pipe, 0x02,\n\t\t\t      0x5E,\n\t\t\t      reg >> 16, reg & 0xffff,\n\t\t\t      buf, 4, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to write uhw reg(%d)\", err);\n\t\tgoto err_free_buf;\n\t}\n\nerr_free_buf:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int btusb_mtk_uhw_reg_read(struct btusb_data *data, u32 reg, u32 *val)\n{\n\tstruct hci_dev *hdev = data->hdev;\n\tint pipe, err;\n\tvoid *buf;\n\n\tbuf = kzalloc(4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpipe = usb_rcvctrlpipe(data->udev, 0);\n\terr = usb_control_msg(data->udev, pipe, 0x01,\n\t\t\t      0xDE,\n\t\t\t      reg >> 16, reg & 0xffff,\n\t\t\t      buf, 4, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to read uhw reg(%d)\", err);\n\t\tgoto err_free_buf;\n\t}\n\n\t*val = get_unaligned_le32(buf);\n\tbt_dev_dbg(hdev, \"reg=%x, value=0x%08x\", reg, *val);\n\nerr_free_buf:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int btusb_mtk_reg_read(struct btusb_data *data, u32 reg, u32 *val)\n{\n\tint pipe, err, size = sizeof(u32);\n\tvoid *buf;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tpipe = usb_rcvctrlpipe(data->udev, 0);\n\terr = usb_control_msg(data->udev, pipe, 0x63,\n\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      reg >> 16, reg & 0xffff,\n\t\t\t      buf, size, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0)\n\t\tgoto err_free_buf;\n\n\t*val = get_unaligned_le32(buf);\n\nerr_free_buf:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int btusb_mtk_id_get(struct btusb_data *data, u32 reg, u32 *id)\n{\n\treturn btusb_mtk_reg_read(data, reg, id);\n}\n\nstatic u32 btusb_mtk_reset_done(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tu32 val = 0;\n\n\tbtusb_mtk_uhw_reg_read(data, MTK_BT_MISC, &val);\n\n\treturn val & MTK_BT_RST_DONE;\n}\n\nstatic int btusb_mtk_reset(struct hci_dev *hdev, void *rst_data)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct btmediatek_data *mediatek;\n\tu32 val;\n\tint err;\n\n\t \n\tif (test_and_set_bit(BTUSB_HW_RESET_ACTIVE, &data->flags)) {\n\t\tbt_dev_err(hdev, \"last reset failed? Not resetting again\");\n\t\treturn -EBUSY;\n\t}\n\n\terr = usb_autopm_get_interface(data->intf);\n\tif (err < 0)\n\t\treturn err;\n\n\tbtusb_stop_traffic(data);\n\tusb_kill_anchored_urbs(&data->tx_anchor);\n\tmediatek = hci_get_priv(hdev);\n\n\tif (mediatek->dev_id == 0x7925) {\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_BT_RESET_REG_CONNV3, &val);\n\t\tval |= (1 << 5);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_BT_RESET_REG_CONNV3, val);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_BT_RESET_REG_CONNV3, &val);\n\t\tval &= 0xFFFF00FF;\n\t\tval |= (1 << 13);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_BT_RESET_REG_CONNV3, val);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_EP_RST_OPT, 0x00010001);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_BT_RESET_REG_CONNV3, &val);\n\t\tval |= (1 << 0);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_BT_RESET_REG_CONNV3, val);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_UDMA_INT_STA_BT, 0x000000FF);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_UDMA_INT_STA_BT, &val);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_UDMA_INT_STA_BT1, 0x000000FF);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_UDMA_INT_STA_BT1, &val);\n\t\tmsleep(100);\n\t} else {\n\t\t \n\t\tbt_dev_dbg(hdev, \"Initiating reset mechanism via uhw\");\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_EP_RST_OPT, MTK_EP_RST_IN_OUT_OPT);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_BT_WDT_STATUS, &val);\n\n\t\t \n\t\tbtusb_mtk_uhw_reg_write(data, MTK_BT_SUBSYS_RST, 1);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_UDMA_INT_STA_BT, 0x000000FF);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_UDMA_INT_STA_BT, &val);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_UDMA_INT_STA_BT1, 0x000000FF);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_UDMA_INT_STA_BT1, &val);\n\t\t \n\t\tmsleep(20);\n\t\tbtusb_mtk_uhw_reg_write(data, MTK_BT_SUBSYS_RST, 0);\n\t\tbtusb_mtk_uhw_reg_read(data, MTK_BT_SUBSYS_RST, &val);\n\t}\n\n\terr = readx_poll_timeout(btusb_mtk_reset_done, hdev, val,\n\t\t\t\t val & MTK_BT_RST_DONE, 20000, 1000000);\n\tif (err < 0)\n\t\tbt_dev_err(hdev, \"Reset timeout\");\n\n\tbtusb_mtk_id_get(data, 0x70010200, &val);\n\tif (!val)\n\t\tbt_dev_err(hdev, \"Can't get device id, subsys reset fail.\");\n\n\tusb_queue_reset_device(data->intf);\n\n\tclear_bit(BTUSB_HW_RESET_ACTIVE, &data->flags);\n\n\treturn err;\n}\n\nstatic int btusb_mtk_setup(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tktime_t calltime, delta, rettime;\n\tstruct btmtk_tci_sleep tci_sleep;\n\tunsigned long long duration;\n\tstruct sk_buff *skb;\n\tconst char *fwname;\n\tint err, status;\n\tu32 dev_id = 0;\n\tchar fw_bin_name[64];\n\tu32 fw_version = 0;\n\tu8 param;\n\tstruct btmediatek_data *mediatek;\n\n\tcalltime = ktime_get();\n\n\terr = btusb_mtk_id_get(data, 0x80000008, &dev_id);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to get device id (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (!dev_id || dev_id != 0x7663) {\n\t\terr = btusb_mtk_id_get(data, 0x70010200, &dev_id);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to get device id (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t\terr = btusb_mtk_id_get(data, 0x80021004, &fw_version);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to get fw version (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tmediatek = hci_get_priv(hdev);\n\tmediatek->dev_id = dev_id;\n\tmediatek->reset_sync = btusb_mtk_reset;\n\n\terr = btmtk_register_coredump(hdev, btusb_driver.name, fw_version);\n\tif (err < 0)\n\t\tbt_dev_err(hdev, \"Failed to register coredump (%d)\", err);\n\n\tswitch (dev_id) {\n\tcase 0x7663:\n\t\tfwname = FIRMWARE_MT7663;\n\t\tbreak;\n\tcase 0x7668:\n\t\tfwname = FIRMWARE_MT7668;\n\t\tbreak;\n\tcase 0x7922:\n\tcase 0x7961:\n\tcase 0x7925:\n\t\tif (dev_id == 0x7925)\n\t\t\tsnprintf(fw_bin_name, sizeof(fw_bin_name),\n\t\t\t\t \"mediatek/mt%04x/BT_RAM_CODE_MT%04x_1_%x_hdr.bin\",\n\t\t\t\t dev_id & 0xffff, dev_id & 0xffff, (fw_version & 0xff) + 1);\n\t\telse\n\t\t\tsnprintf(fw_bin_name, sizeof(fw_bin_name),\n\t\t\t\t \"mediatek/BT_RAM_CODE_MT%04x_1_%x_hdr.bin\",\n\t\t\t\t dev_id & 0xffff, (fw_version & 0xff) + 1);\n\n\t\terr = btmtk_setup_firmware_79xx(hdev, fw_bin_name,\n\t\t\t\t\t\tbtusb_mtk_hci_wmt_sync);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to set up firmware (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tbtusb_mtk_uhw_reg_write(data, MTK_EP_RST_OPT, MTK_EP_RST_IN_OUT_OPT);\n\n\t\t \n\t\tparam = 1;\n\t\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\t\twmt_params.flag = 0;\n\t\twmt_params.dlen = sizeof(param);\n\t\twmt_params.data = &param;\n\t\twmt_params.status = NULL;\n\n\t\terr = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\thci_set_msft_opcode(hdev, 0xFD30);\n\t\thci_set_aosp_capable(hdev);\n\t\tgoto done;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported hardware variant (%08x)\",\n\t\t\t   dev_id);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\twmt_params.op = BTMTK_WMT_SEMAPHORE;\n\twmt_params.flag = 1;\n\twmt_params.dlen = 0;\n\twmt_params.data = NULL;\n\twmt_params.status = &status;\n\n\terr = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query firmware status (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (status == BTMTK_WMT_PATCH_DONE) {\n\t\tbt_dev_info(hdev, \"firmware already downloaded\");\n\t\tgoto ignore_setup_fw;\n\t}\n\n\t \n\terr = btmtk_setup_firmware(hdev, fwname,\n\t\t\t\t   btusb_mtk_hci_wmt_sync);\n\tif (err < 0)\n\t\treturn err;\n\nignore_setup_fw:\n\terr = readx_poll_timeout(btusb_mtk_func_query, hdev, status,\n\t\t\t\t status < 0 || status != BTMTK_WMT_ON_PROGRESS,\n\t\t\t\t 2000, 5000000);\n\t \n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (status < 0)\n\t\treturn status;\n\n\tif (status == BTMTK_WMT_ON_DONE) {\n\t\tbt_dev_info(hdev, \"function already on\");\n\t\tgoto ignore_func_on;\n\t}\n\n\t \n\tparam = 1;\n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\nignore_func_on:\n\t \n\ttci_sleep.mode = 0x5;\n\ttci_sleep.duration = cpu_to_le16(0x640);\n\ttci_sleep.host_duration = cpu_to_le16(0x640);\n\ttci_sleep.host_wakeup_pin = 0;\n\ttci_sleep.time_compensation = 0;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc7a, sizeof(tci_sleep), &tci_sleep,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Failed to apply low power setting (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\ndone:\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long)ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Device setup in %llu usecs\", duration);\n\n\treturn 0;\n}\n\nstatic int btusb_mtk_shutdown(struct hci_dev *hdev)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tu8 param = 0;\n\tint err;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int btusb_recv_acl_mtk(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tu16 handle = le16_to_cpu(hci_acl_hdr(skb)->handle);\n\tstruct sk_buff *skb_cd;\n\n\tswitch (handle) {\n\tcase 0xfc6f:\t\t \n\t\t \n\t\tusb_disable_autosuspend(data->udev);\n\n\t\t \n\t\tskb_cd = skb_clone(skb, GFP_ATOMIC);\n\t\tif (skb_cd)\n\t\t\tbtmtk_process_coredump(hdev, skb_cd);\n\n\t\tfallthrough;\n\tcase 0x05ff:\t\t \n\tcase 0x05fe:\t\t \n\t\treturn hci_recv_diag(hdev, skb);\n\t}\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\n#ifdef CONFIG_PM\n \nstatic int marvell_config_oob_wake(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct device *dev = &data->udev->dev;\n\tu16 pin, gap, opcode;\n\tint ret;\n\tu8 cmd[5];\n\n\t \n\tif (of_property_read_u16(dev->of_node, \"marvell,wakeup-pin\", &pin) ||\n\t    of_property_read_u16(dev->of_node, \"marvell,wakeup-gap-ms\", &gap))\n\t\treturn 0;\n\n\t \n\topcode = hci_opcode_pack(0x3F, 0x59);\n\tcmd[0] = opcode & 0xFF;\n\tcmd[1] = opcode >> 8;\n\tcmd[2] = 2;  \n\tcmd[3] = pin;\n\tcmd[4] = gap;  \n\n\tskb = bt_skb_alloc(sizeof(cmd), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hdev, \"%s: No memory\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, cmd, sizeof(cmd));\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\tret = btusb_send_frame(hdev, skb);\n\tif (ret) {\n\t\tbt_dev_err(hdev, \"%s: configuration failed\", __func__);\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int btusb_set_bdaddr_marvell(struct hci_dev *hdev,\n\t\t\t\t    const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tu8 buf[8];\n\tlong ret;\n\n\tbuf[0] = 0xfe;\n\tbuf[1] = sizeof(bdaddr_t);\n\tmemcpy(buf + 2, bdaddr, sizeof(bdaddr_t));\n\n\tskb = __hci_cmd_sync(hdev, 0xfc22, sizeof(buf), buf, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"changing Marvell device address failed (%ld)\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int btusb_set_bdaddr_ath3012(struct hci_dev *hdev,\n\t\t\t\t    const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tu8 buf[10];\n\tlong ret;\n\n\tbuf[0] = 0x01;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tbuf[3] = sizeof(bdaddr_t);\n\tmemcpy(buf + 4, bdaddr, sizeof(bdaddr_t));\n\n\tskb = __hci_cmd_sync(hdev, 0xfc0b, sizeof(buf), buf, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Change address command failed (%ld)\", ret);\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int btusb_set_bdaddr_wcn6855(struct hci_dev *hdev,\n\t\t\t\tconst bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tu8 buf[6];\n\tlong ret;\n\n\tmemcpy(buf, bdaddr, sizeof(bdaddr_t));\n\n\tskb = __hci_cmd_sync_ev(hdev, 0xfc14, sizeof(buf), buf,\n\t\t\t\tHCI_EV_CMD_COMPLETE, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Change address command failed (%ld)\", ret);\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n#define QCA_MEMDUMP_ACL_HANDLE 0x2EDD\n#define QCA_MEMDUMP_SIZE_MAX  0x100000\n#define QCA_MEMDUMP_VSE_CLASS 0x01\n#define QCA_MEMDUMP_MSG_TYPE 0x08\n#define QCA_MEMDUMP_PKT_SIZE 248\n#define QCA_LAST_SEQUENCE_NUM 0xffff\n\nstruct qca_dump_hdr {\n\tu8 vse_class;\n\tu8 msg_type;\n\t__le16 seqno;\n\tu8 reserved;\n\tunion {\n\t\tu8 data[0];\n\t\tstruct {\n\t\t\t__le32 ram_dump_size;\n\t\t\tu8 data0[0];\n\t\t} __packed;\n\t};\n} __packed;\n\n\nstatic void btusb_dump_hdr_qca(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tchar buf[128];\n\tstruct btusb_data *btdata = hci_get_drvdata(hdev);\n\n\tsnprintf(buf, sizeof(buf), \"Controller Name: 0x%x\\n\",\n\t\t\tbtdata->qca_dump.controller_id);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Firmware Version: 0x%x\\n\",\n\t\t\tbtdata->qca_dump.fw_version);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Driver: %s\\nVendor: qca\\n\",\n\t\t\tbtusb_driver.name);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"VID: 0x%x\\nPID:0x%x\\n\",\n\t\t\tbtdata->qca_dump.id_vendor, btdata->qca_dump.id_product);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Lmp Subversion: 0x%x\\n\",\n\t\t\thdev->lmp_subver);\n\tskb_put_data(skb, buf, strlen(buf));\n}\n\nstatic void btusb_coredump_qca(struct hci_dev *hdev)\n{\n\tstatic const u8 param[] = { 0x26 };\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc0c, 1, param, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\tbt_dev_err(hdev, \"%s: triggle crash failed (%ld)\", __func__, PTR_ERR(skb));\n\tkfree_skb(skb);\n}\n\n \nstatic int handle_dump_pkt_qca(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tint ret = 1;\n\tu8 pkt_type;\n\tu8 *sk_ptr;\n\tunsigned int sk_len;\n\tu16 seqno;\n\tu32 dump_size;\n\n\tstruct hci_event_hdr *event_hdr;\n\tstruct hci_acl_hdr *acl_hdr;\n\tstruct qca_dump_hdr *dump_hdr;\n\tstruct btusb_data *btdata = hci_get_drvdata(hdev);\n\tstruct usb_device *udev = btdata->udev;\n\n\tpkt_type = hci_skb_pkt_type(skb);\n\tsk_ptr = skb->data;\n\tsk_len = skb->len;\n\n\tif (pkt_type == HCI_ACLDATA_PKT) {\n\t\tacl_hdr = hci_acl_hdr(skb);\n\t\tif (le16_to_cpu(acl_hdr->handle) != QCA_MEMDUMP_ACL_HANDLE)\n\t\t\treturn 0;\n\t\tsk_ptr += HCI_ACL_HDR_SIZE;\n\t\tsk_len -= HCI_ACL_HDR_SIZE;\n\t\tevent_hdr = (struct hci_event_hdr *)sk_ptr;\n\t} else {\n\t\tevent_hdr = hci_event_hdr(skb);\n\t}\n\n\tif ((event_hdr->evt != HCI_VENDOR_PKT)\n\t\t|| (event_hdr->plen != (sk_len - HCI_EVENT_HDR_SIZE)))\n\t\treturn 0;\n\n\tsk_ptr += HCI_EVENT_HDR_SIZE;\n\tsk_len -= HCI_EVENT_HDR_SIZE;\n\n\tdump_hdr = (struct qca_dump_hdr *)sk_ptr;\n\tif ((sk_len < offsetof(struct qca_dump_hdr, data))\n\t\t|| (dump_hdr->vse_class != QCA_MEMDUMP_VSE_CLASS)\n\t    || (dump_hdr->msg_type != QCA_MEMDUMP_MSG_TYPE))\n\t\treturn 0;\n\n\t \n\tseqno = le16_to_cpu(dump_hdr->seqno);\n\tif (seqno == 0) {\n\t\tset_bit(BTUSB_HW_SSR_ACTIVE, &btdata->flags);\n\t\tdump_size = le32_to_cpu(dump_hdr->ram_dump_size);\n\t\tif (!dump_size || (dump_size > QCA_MEMDUMP_SIZE_MAX)) {\n\t\t\tret = -EILSEQ;\n\t\t\tbt_dev_err(hdev, \"Invalid memdump size(%u)\",\n\t\t\t\t   dump_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = hci_devcd_init(hdev, dump_size);\n\t\tif (ret < 0) {\n\t\t\tbt_dev_err(hdev, \"memdump init error(%d)\", ret);\n\t\t\tgoto out;\n\t\t}\n\n\t\tbtdata->qca_dump.ram_dump_size = dump_size;\n\t\tbtdata->qca_dump.ram_dump_seqno = 0;\n\t\tsk_ptr += offsetof(struct qca_dump_hdr, data0);\n\t\tsk_len -= offsetof(struct qca_dump_hdr, data0);\n\n\t\tusb_disable_autosuspend(udev);\n\t\tbt_dev_info(hdev, \"%s memdump size(%u)\\n\",\n\t\t\t    (pkt_type == HCI_ACLDATA_PKT) ? \"ACL\" : \"event\",\n\t\t\t    dump_size);\n\t} else {\n\t\tsk_ptr += offsetof(struct qca_dump_hdr, data);\n\t\tsk_len -= offsetof(struct qca_dump_hdr, data);\n\t}\n\n\tif (!btdata->qca_dump.ram_dump_size) {\n\t\tret = -EINVAL;\n\t\tbt_dev_err(hdev, \"memdump is not active\");\n\t\tgoto out;\n\t}\n\n\tif ((seqno > btdata->qca_dump.ram_dump_seqno + 1) && (seqno != QCA_LAST_SEQUENCE_NUM)) {\n\t\tdump_size = QCA_MEMDUMP_PKT_SIZE * (seqno - btdata->qca_dump.ram_dump_seqno - 1);\n\t\thci_devcd_append_pattern(hdev, 0x0, dump_size);\n\t\tbt_dev_err(hdev,\n\t\t\t   \"expected memdump seqno(%u) is not received(%u)\\n\",\n\t\t\t   btdata->qca_dump.ram_dump_seqno, seqno);\n\t\tbtdata->qca_dump.ram_dump_seqno = seqno;\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\tskb_pull(skb, skb->len - sk_len);\n\thci_devcd_append(hdev, skb);\n\tbtdata->qca_dump.ram_dump_seqno++;\n\tif (seqno == QCA_LAST_SEQUENCE_NUM) {\n\t\tbt_dev_info(hdev,\n\t\t\t\t\"memdump done: pkts(%u), total(%u)\\n\",\n\t\t\t\tbtdata->qca_dump.ram_dump_seqno, btdata->qca_dump.ram_dump_size);\n\n\t\thci_devcd_complete(hdev);\n\t\tgoto out;\n\t}\n\treturn ret;\n\nout:\n\tif (btdata->qca_dump.ram_dump_size)\n\t\tusb_enable_autosuspend(udev);\n\tbtdata->qca_dump.ram_dump_size = 0;\n\tbtdata->qca_dump.ram_dump_seqno = 0;\n\tclear_bit(BTUSB_HW_SSR_ACTIVE, &btdata->flags);\n\n\tif (ret < 0)\n\t\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int btusb_recv_acl_qca(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tif (handle_dump_pkt_qca(hdev, skb))\n\t\treturn 0;\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int btusb_recv_evt_qca(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tif (handle_dump_pkt_qca(hdev, skb))\n\t\treturn 0;\n\treturn hci_recv_frame(hdev, skb);\n}\n\n\n#define QCA_DFU_PACKET_LEN\t4096\n\n#define QCA_GET_TARGET_VERSION\t0x09\n#define QCA_CHECK_STATUS\t0x05\n#define QCA_DFU_DOWNLOAD\t0x01\n\n#define QCA_SYSCFG_UPDATED\t0x40\n#define QCA_PATCH_UPDATED\t0x80\n#define QCA_DFU_TIMEOUT\t\t3000\n#define QCA_FLAG_MULTI_NVM      0x80\n#define QCA_BT_RESET_WAIT_MS    100\n\n#define WCN6855_2_0_RAM_VERSION_GF 0x400c1200\n#define WCN6855_2_1_RAM_VERSION_GF 0x400c1211\n\nstruct qca_version {\n\t__le32\trom_version;\n\t__le32\tpatch_version;\n\t__le32\tram_version;\n\t__u8\tchip_id;\n\t__u8\tplatform_id;\n\t__le16\tflag;\n\t__u8\treserved[4];\n} __packed;\n\nstruct qca_rampatch_version {\n\t__le16\trom_version_high;\n\t__le16  rom_version_low;\n\t__le16\tpatch_version;\n} __packed;\n\nstruct qca_device_info {\n\tu32\trom_version;\n\tu8\trampatch_hdr;\t \n\tu8\tnvm_hdr;\t \n\tu8\tver_offset;\t \n};\n\nstatic const struct qca_device_info qca_devices_table[] = {\n\t{ 0x00000100, 20, 4,  8 },  \n\t{ 0x00000101, 20, 4,  8 },  \n\t{ 0x00000200, 28, 4, 16 },  \n\t{ 0x00000201, 28, 4, 16 },  \n\t{ 0x00000300, 28, 4, 16 },  \n\t{ 0x00000302, 28, 4, 16 },  \n\t{ 0x00130100, 40, 4, 16 },  \n\t{ 0x00130200, 40, 4, 16 },  \n\t{ 0x00130201, 40, 4, 16 },  \n\t{ 0x00190200, 40, 4, 16 },  \n};\n\nstatic int btusb_qca_send_vendor_req(struct usb_device *udev, u8 request,\n\t\t\t\t     void *data, u16 size)\n{\n\tint pipe, err;\n\tu8 *buf;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tpipe = usb_rcvctrlpipe(udev, 0);\n\terr = usb_control_msg(udev, pipe, request, USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t      0, 0, buf, size, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n\t\tdev_err(&udev->dev, \"Failed to access otp area (%d)\", err);\n\t\tgoto done;\n\t}\n\n\tmemcpy(data, buf, size);\n\ndone:\n\tkfree(buf);\n\n\treturn err;\n}\n\nstatic int btusb_setup_qca_download_fw(struct hci_dev *hdev,\n\t\t\t\t       const struct firmware *firmware,\n\t\t\t\t       size_t hdr_size)\n{\n\tstruct btusb_data *btdata = hci_get_drvdata(hdev);\n\tstruct usb_device *udev = btdata->udev;\n\tsize_t count, size, sent = 0;\n\tint pipe, len, err;\n\tu8 *buf;\n\n\tbuf = kmalloc(QCA_DFU_PACKET_LEN, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tcount = firmware->size;\n\n\tsize = min_t(size_t, count, hdr_size);\n\tmemcpy(buf, firmware->data, size);\n\n\t \n\tpipe = usb_sndctrlpipe(udev, 0);\n\terr = usb_control_msg(udev, pipe, QCA_DFU_DOWNLOAD, USB_TYPE_VENDOR,\n\t\t\t      0, 0, buf, size, USB_CTRL_SET_TIMEOUT);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send headers (%d)\", err);\n\t\tgoto done;\n\t}\n\n\tsent += size;\n\tcount -= size;\n\n\t \n\tmsleep(20);\n\n\twhile (count) {\n\t\tsize = min_t(size_t, count, QCA_DFU_PACKET_LEN);\n\n\t\tmemcpy(buf, firmware->data + sent, size);\n\n\t\tpipe = usb_sndbulkpipe(udev, 0x02);\n\t\terr = usb_bulk_msg(udev, pipe, buf, size, &len,\n\t\t\t\t   QCA_DFU_TIMEOUT);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to send body at %zd of %zd (%d)\",\n\t\t\t\t   sent, firmware->size, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (size != len) {\n\t\t\tbt_dev_err(hdev, \"Failed to get bulk buffer\");\n\t\t\terr = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\ndone:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic int btusb_setup_qca_load_rampatch(struct hci_dev *hdev,\n\t\t\t\t\t struct qca_version *ver,\n\t\t\t\t\t const struct qca_device_info *info)\n{\n\tstruct qca_rampatch_version *rver;\n\tconst struct firmware *fw;\n\tu32 ver_rom, ver_patch, rver_rom;\n\tu16 rver_rom_low, rver_rom_high, rver_patch;\n\tchar fwname[64];\n\tint err;\n\n\tver_rom = le32_to_cpu(ver->rom_version);\n\tver_patch = le32_to_cpu(ver->patch_version);\n\n\tsnprintf(fwname, sizeof(fwname), \"qca/rampatch_usb_%08x.bin\", ver_rom);\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"failed to request rampatch file: %s (%d)\",\n\t\t\t   fwname, err);\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"using rampatch file: %s\", fwname);\n\n\trver = (struct qca_rampatch_version *)(fw->data + info->ver_offset);\n\trver_rom_low = le16_to_cpu(rver->rom_version_low);\n\trver_patch = le16_to_cpu(rver->patch_version);\n\n\tif (ver_rom & ~0xffffU) {\n\t\trver_rom_high = le16_to_cpu(rver->rom_version_high);\n\t\trver_rom = rver_rom_high << 16 | rver_rom_low;\n\t} else {\n\t\trver_rom = rver_rom_low;\n\t}\n\n\tbt_dev_info(hdev, \"QCA: patch rome 0x%x build 0x%x, \"\n\t\t    \"firmware rome 0x%x build 0x%x\",\n\t\t    rver_rom, rver_patch, ver_rom, ver_patch);\n\n\tif (rver_rom != ver_rom || rver_patch <= ver_patch) {\n\t\tbt_dev_err(hdev, \"rampatch file version did not match with firmware\");\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\terr = btusb_setup_qca_download_fw(hdev, fw, info->rampatch_hdr);\n\ndone:\n\trelease_firmware(fw);\n\n\treturn err;\n}\n\nstatic void btusb_generate_qca_nvm_name(char *fwname, size_t max_size,\n\t\t\t\t\tconst struct qca_version *ver)\n{\n\tu32 rom_version = le32_to_cpu(ver->rom_version);\n\tu16 flag = le16_to_cpu(ver->flag);\n\n\tif (((flag >> 8) & 0xff) == QCA_FLAG_MULTI_NVM) {\n\t\t \n\t\tu16 board_id = (ver->chip_id << 8) + ver->platform_id;\n\t\tconst char *variant;\n\n\t\tswitch (le32_to_cpu(ver->ram_version)) {\n\t\tcase WCN6855_2_0_RAM_VERSION_GF:\n\t\tcase WCN6855_2_1_RAM_VERSION_GF:\n\t\t\tvariant = \"_gf\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tvariant = \"\";\n\t\t\tbreak;\n\t\t}\n\n\t\tif (board_id == 0) {\n\t\t\tsnprintf(fwname, max_size, \"qca/nvm_usb_%08x%s.bin\",\n\t\t\t\trom_version, variant);\n\t\t} else {\n\t\t\tsnprintf(fwname, max_size, \"qca/nvm_usb_%08x%s_%04x.bin\",\n\t\t\t\trom_version, variant, board_id);\n\t\t}\n\t} else {\n\t\tsnprintf(fwname, max_size, \"qca/nvm_usb_%08x.bin\",\n\t\t\trom_version);\n\t}\n\n}\n\nstatic int btusb_setup_qca_load_nvm(struct hci_dev *hdev,\n\t\t\t\t    struct qca_version *ver,\n\t\t\t\t    const struct qca_device_info *info)\n{\n\tconst struct firmware *fw;\n\tchar fwname[64];\n\tint err;\n\n\tbtusb_generate_qca_nvm_name(fwname, sizeof(fwname), ver);\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"failed to request NVM file: %s (%d)\",\n\t\t\t   fwname, err);\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"using NVM file: %s\", fwname);\n\n\terr = btusb_setup_qca_download_fw(hdev, fw, info->nvm_hdr);\n\n\trelease_firmware(fw);\n\n\treturn err;\n}\n\n \nstatic bool btusb_qca_need_patch(struct usb_device *udev)\n{\n\tstruct qca_version ver;\n\n\tif (btusb_qca_send_vendor_req(udev, QCA_GET_TARGET_VERSION, &ver,\n\t\t\t\t      sizeof(ver)) < 0)\n\t\treturn false;\n\t \n\treturn !(le32_to_cpu(ver.rom_version) & ~0xffffU);\n}\n\nstatic int btusb_setup_qca(struct hci_dev *hdev)\n{\n\tstruct btusb_data *btdata = hci_get_drvdata(hdev);\n\tstruct usb_device *udev = btdata->udev;\n\tconst struct qca_device_info *info = NULL;\n\tstruct qca_version ver;\n\tu32 ver_rom;\n\tu8 status;\n\tint i, err;\n\n\terr = btusb_qca_send_vendor_req(udev, QCA_GET_TARGET_VERSION, &ver,\n\t\t\t\t\tsizeof(ver));\n\tif (err < 0)\n\t\treturn err;\n\n\tver_rom = le32_to_cpu(ver.rom_version);\n\n\tfor (i = 0; i < ARRAY_SIZE(qca_devices_table); i++) {\n\t\tif (ver_rom == qca_devices_table[i].rom_version)\n\t\t\tinfo = &qca_devices_table[i];\n\t}\n\tif (!info) {\n\t\t \n\t\tif (ver_rom & ~0xffffU)\n\t\t\treturn 0;\n\n\t\tbt_dev_err(hdev, \"don't support firmware rome 0x%x\", ver_rom);\n\t\treturn -ENODEV;\n\t}\n\n\terr = btusb_qca_send_vendor_req(udev, QCA_CHECK_STATUS, &status,\n\t\t\t\t\tsizeof(status));\n\tif (err < 0)\n\t\treturn err;\n\n\tif (!(status & QCA_PATCH_UPDATED)) {\n\t\terr = btusb_setup_qca_load_rampatch(hdev, &ver, info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\terr = btusb_qca_send_vendor_req(udev, QCA_GET_TARGET_VERSION, &ver,\n\t\t\t\t\tsizeof(ver));\n\tif (err < 0)\n\t\treturn err;\n\n\tbtdata->qca_dump.fw_version = le32_to_cpu(ver.patch_version);\n\tbtdata->qca_dump.controller_id = le32_to_cpu(ver.rom_version);\n\n\tif (!(status & QCA_SYSCFG_UPDATED)) {\n\t\terr = btusb_setup_qca_load_nvm(hdev, &ver, info);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t \n\t\tif (info->rom_version >= 0x00130201)\n\t\t\tmsleep(QCA_BT_RESET_WAIT_MS);\n\t}\n\n\t \n\tset_bit(HCI_QUIRK_BROKEN_ENHANCED_SETUP_SYNC_CONN, &hdev->quirks);\n\n\treturn 0;\n}\n\nstatic inline int __set_diag_interface(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct usb_interface *intf = data->diag;\n\tint i;\n\n\tif (!data->diag)\n\t\treturn -ENODEV;\n\n\tdata->diag_tx_ep = NULL;\n\tdata->diag_rx_ep = NULL;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tstruct usb_endpoint_descriptor *ep_desc;\n\n\t\tep_desc = &intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (!data->diag_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {\n\t\t\tdata->diag_tx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->diag_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\tdata->diag_rx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!data->diag_tx_ep || !data->diag_rx_ep) {\n\t\tbt_dev_err(hdev, \"invalid diagnostic descriptors\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic struct urb *alloc_diag_urb(struct hci_dev *hdev, bool enable)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct sk_buff *skb;\n\tstruct urb *urb;\n\tunsigned int pipe;\n\n\tif (!data->diag_tx_ep)\n\t\treturn ERR_PTR(-ENODEV);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tskb = bt_skb_alloc(2, GFP_KERNEL);\n\tif (!skb) {\n\t\tusb_free_urb(urb);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskb_put_u8(skb, 0xf0);\n\tskb_put_u8(skb, enable);\n\n\tpipe = usb_sndbulkpipe(data->udev, data->diag_tx_ep->bEndpointAddress);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe,\n\t\t\t  skb->data, skb->len, btusb_tx_complete, skb);\n\n\tskb->dev = (void *)hdev;\n\n\treturn urb;\n}\n\nstatic int btusb_bcm_set_diag(struct hci_dev *hdev, bool enable)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\n\tif (!data->diag)\n\t\treturn -ENODEV;\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\turb = alloc_diag_urb(hdev, enable);\n\tif (IS_ERR(urb))\n\t\treturn PTR_ERR(urb);\n\n\treturn submit_or_queue_tx_urb(hdev, urb);\n}\n\n#ifdef CONFIG_PM\nstatic irqreturn_t btusb_oob_wake_handler(int irq, void *priv)\n{\n\tstruct btusb_data *data = priv;\n\n\tpm_wakeup_event(&data->udev->dev, 0);\n\tpm_system_wakeup();\n\n\t \n\tif (test_and_clear_bit(BTUSB_OOB_WAKE_ENABLED, &data->flags)) {\n\t\tdisable_irq_nosync(irq);\n\t\tdisable_irq_wake(irq);\n\t}\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id btusb_match_table[] = {\n\t{ .compatible = \"usb1286,204e\" },\n\t{ .compatible = \"usbcf3,e300\" },  \n\t{ .compatible = \"usb4ca,301a\" },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(of, btusb_match_table);\n\n \nstatic int btusb_config_oob_wake(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\tstruct device *dev = &data->udev->dev;\n\tint irq, ret;\n\n\tclear_bit(BTUSB_OOB_WAKE_ENABLED, &data->flags);\n\n\tif (!of_match_device(btusb_match_table, dev))\n\t\treturn 0;\n\n\t \n\tirq = of_irq_get_byname(dev->of_node, \"wakeup\");\n\tif (irq <= 0) {\n\t\tbt_dev_dbg(hdev, \"%s: no OOB Wakeup IRQ in DT\", __func__);\n\t\treturn 0;\n\t}\n\n\tirq_set_status_flags(irq, IRQ_NOAUTOEN);\n\tret = devm_request_irq(&hdev->dev, irq, btusb_oob_wake_handler,\n\t\t\t       0, \"OOB Wake-on-BT\", data);\n\tif (ret) {\n\t\tbt_dev_err(hdev, \"%s: IRQ request failed\", __func__);\n\t\treturn ret;\n\t}\n\n\tret = device_init_wakeup(dev, true);\n\tif (ret) {\n\t\tbt_dev_err(hdev, \"%s: failed to init_wakeup\", __func__);\n\t\treturn ret;\n\t}\n\n\tdata->oob_wake_irq = irq;\n\tbt_dev_info(hdev, \"OOB Wake-on-BT configured at IRQ %u\", irq);\n\treturn 0;\n}\n#endif\n\nstatic void btusb_check_needs_reset_resume(struct usb_interface *intf)\n{\n\tif (dmi_check_system(btusb_needs_reset_resume_table))\n\t\tinterface_to_usbdev(intf)->quirks |= USB_QUIRK_RESET_RESUME;\n}\n\nstatic bool btusb_wakeup(struct hci_dev *hdev)\n{\n\tstruct btusb_data *data = hci_get_drvdata(hdev);\n\n\treturn device_may_wakeup(&data->udev->dev);\n}\n\nstatic int btusb_shutdown_qca(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"HCI reset during shutdown failed\");\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic ssize_t force_poll_sync_read(struct file *file, char __user *user_buf,\n\t\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct btusb_data *data = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = data->poll_sync ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t force_poll_sync_write(struct file *file,\n\t\t\t\t     const char __user *user_buf,\n\t\t\t\t     size_t count, loff_t *ppos)\n{\n\tstruct btusb_data *data = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (test_bit(HCI_UP, &data->hdev->flags))\n\t\treturn -EPERM;\n\n\tif (data->poll_sync == enable)\n\t\treturn -EALREADY;\n\n\tdata->poll_sync = enable;\n\n\treturn count;\n}\n\nstatic const struct file_operations force_poll_sync_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_poll_sync_read,\n\t.write\t\t= force_poll_sync_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int btusb_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tstruct gpio_desc *reset_gpio;\n\tstruct btusb_data *data;\n\tstruct hci_dev *hdev;\n\tunsigned ifnum_base;\n\tint i, err, priv_size;\n\n\tBT_DBG(\"intf %p id %p\", intf, id);\n\n\tif ((id->driver_info & BTUSB_IFNUM_2) &&\n\t    (intf->cur_altsetting->desc.bInterfaceNumber != 0) &&\n\t    (intf->cur_altsetting->desc.bInterfaceNumber != 2))\n\t\treturn -ENODEV;\n\n\tifnum_base = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (!id->driver_info) {\n\t\tconst struct usb_device_id *match;\n\n\t\tmatch = usb_match_id(intf, quirks_table);\n\t\tif (match)\n\t\t\tid = match;\n\t}\n\n\tif (id->driver_info == BTUSB_IGNORE)\n\t\treturn -ENODEV;\n\n\tif (id->driver_info & BTUSB_ATH3012) {\n\t\tstruct usb_device *udev = interface_to_usbdev(intf);\n\n\t\t \n\t\tif (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x0001 &&\n\t\t    !btusb_qca_need_patch(udev))\n\t\t\treturn -ENODEV;\n\t}\n\n\tdata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tep_desc = &intf->cur_altsetting->endpoint[i].desc;\n\n\t\tif (!data->intr_ep && usb_endpoint_is_int_in(ep_desc)) {\n\t\t\tdata->intr_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->bulk_tx_ep && usb_endpoint_is_bulk_out(ep_desc)) {\n\t\t\tdata->bulk_tx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!data->bulk_rx_ep && usb_endpoint_is_bulk_in(ep_desc)) {\n\t\t\tdata->bulk_rx_ep = ep_desc;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (!data->intr_ep || !data->bulk_tx_ep || !data->bulk_rx_ep)\n\t\treturn -ENODEV;\n\n\tif (id->driver_info & BTUSB_AMP) {\n\t\tdata->cmdreq_type = USB_TYPE_CLASS | 0x01;\n\t\tdata->cmdreq = 0x2b;\n\t} else {\n\t\tdata->cmdreq_type = USB_TYPE_CLASS;\n\t\tdata->cmdreq = 0x00;\n\t}\n\n\tdata->udev = interface_to_usbdev(intf);\n\tdata->intf = intf;\n\n\tINIT_WORK(&data->work, btusb_work);\n\tINIT_WORK(&data->waker, btusb_waker);\n\tINIT_DELAYED_WORK(&data->rx_work, btusb_rx_work);\n\n\tskb_queue_head_init(&data->acl_q);\n\n\tinit_usb_anchor(&data->deferred);\n\tinit_usb_anchor(&data->tx_anchor);\n\tspin_lock_init(&data->txlock);\n\n\tinit_usb_anchor(&data->intr_anchor);\n\tinit_usb_anchor(&data->bulk_anchor);\n\tinit_usb_anchor(&data->isoc_anchor);\n\tinit_usb_anchor(&data->diag_anchor);\n\tinit_usb_anchor(&data->ctrl_anchor);\n\tspin_lock_init(&data->rxlock);\n\n\tpriv_size = 0;\n\n\tdata->recv_event = hci_recv_frame;\n\tdata->recv_bulk = btusb_recv_bulk;\n\n\tif (id->driver_info & BTUSB_INTEL_COMBINED) {\n\t\t \n\t\tpriv_size += sizeof(struct btintel_data);\n\n\t\t \n\t\tdata->recv_event = btintel_recv_event;\n\t\tdata->recv_bulk = btusb_recv_bulk_intel;\n\t} else if (id->driver_info & BTUSB_REALTEK) {\n\t\t \n\t\tpriv_size += sizeof(struct btrealtek_data);\n\n\t\tdata->recv_event = btusb_recv_event_realtek;\n\t} else if (id->driver_info & BTUSB_MEDIATEK) {\n\t\t \n\t\tpriv_size += sizeof(struct btmediatek_data);\n\t}\n\n\tdata->recv_acl = hci_recv_frame;\n\n\thdev = hci_alloc_dev_priv(priv_size);\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\thdev->bus = HCI_USB;\n\thci_set_drvdata(hdev, data);\n\n\tif (id->driver_info & BTUSB_AMP)\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\tdata->hdev = hdev;\n\n\tSET_HCIDEV_DEV(hdev, &intf->dev);\n\n\treset_gpio = gpiod_get_optional(&data->udev->dev, \"reset\",\n\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(reset_gpio)) {\n\t\terr = PTR_ERR(reset_gpio);\n\t\tgoto out_free_dev;\n\t} else if (reset_gpio) {\n\t\tdata->reset_gpio = reset_gpio;\n\t}\n\n\thdev->open   = btusb_open;\n\thdev->close  = btusb_close;\n\thdev->flush  = btusb_flush;\n\thdev->send   = btusb_send_frame;\n\thdev->notify = btusb_notify;\n\thdev->wakeup = btusb_wakeup;\n\n#ifdef CONFIG_PM\n\terr = btusb_config_oob_wake(hdev);\n\tif (err)\n\t\tgoto out_free_dev;\n\n\t \n\tif (id->driver_info & BTUSB_MARVELL && data->oob_wake_irq) {\n\t\terr = marvell_config_oob_wake(hdev);\n\t\tif (err)\n\t\t\tgoto out_free_dev;\n\t}\n#endif\n\tif (id->driver_info & BTUSB_CW6622)\n\t\tset_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks);\n\n\tif (id->driver_info & BTUSB_BCM2045)\n\t\tset_bit(HCI_QUIRK_BROKEN_STORED_LINK_KEY, &hdev->quirks);\n\n\tif (id->driver_info & BTUSB_BCM92035)\n\t\thdev->setup = btusb_setup_bcm92035;\n\n\tif (IS_ENABLED(CONFIG_BT_HCIBTUSB_BCM) &&\n\t    (id->driver_info & BTUSB_BCM_PATCHRAM)) {\n\t\thdev->manufacturer = 15;\n\t\thdev->setup = btbcm_setup_patchram;\n\t\thdev->set_diag = btusb_bcm_set_diag;\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\n\t\t \n\t\tdata->diag = usb_ifnum_to_if(data->udev, ifnum_base + 2);\n\t}\n\n\tif (IS_ENABLED(CONFIG_BT_HCIBTUSB_BCM) &&\n\t    (id->driver_info & BTUSB_BCM_APPLE)) {\n\t\thdev->manufacturer = 15;\n\t\thdev->setup = btbcm_setup_apple;\n\t\thdev->set_diag = btusb_bcm_set_diag;\n\n\t\t \n\t\tdata->diag = usb_ifnum_to_if(data->udev, ifnum_base + 2);\n\t}\n\n\t \n\tif (id->driver_info & BTUSB_INTEL_COMBINED) {\n\t\terr = btintel_configure_setup(hdev, btusb_driver.name);\n\t\tif (err)\n\t\t\tgoto out_free_dev;\n\n\t\t \n\t\thdev->send = btusb_send_frame_intel;\n\t\thdev->cmd_timeout = btusb_intel_cmd_timeout;\n\n\t\tif (id->driver_info & BTUSB_INTEL_NO_WBS_SUPPORT)\n\t\t\tbtintel_set_flag(hdev, INTEL_ROM_LEGACY_NO_WBS_SUPPORT);\n\n\t\tif (id->driver_info & BTUSB_INTEL_BROKEN_INITIAL_NCMD)\n\t\t\tbtintel_set_flag(hdev, INTEL_BROKEN_INITIAL_NCMD);\n\n\t\tif (id->driver_info & BTUSB_INTEL_BROKEN_SHUTDOWN_LED)\n\t\t\tbtintel_set_flag(hdev, INTEL_BROKEN_SHUTDOWN_LED);\n\t}\n\n\tif (id->driver_info & BTUSB_MARVELL)\n\t\thdev->set_bdaddr = btusb_set_bdaddr_marvell;\n\n\tif (IS_ENABLED(CONFIG_BT_HCIBTUSB_MTK) &&\n\t    (id->driver_info & BTUSB_MEDIATEK)) {\n\t\thdev->setup = btusb_mtk_setup;\n\t\thdev->shutdown = btusb_mtk_shutdown;\n\t\thdev->manufacturer = 70;\n\t\thdev->cmd_timeout = btmtk_reset_sync;\n\t\thdev->set_bdaddr = btmtk_set_bdaddr;\n\t\tset_bit(HCI_QUIRK_BROKEN_ENHANCED_SETUP_SYNC_CONN, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\t\tdata->recv_acl = btusb_recv_acl_mtk;\n\t}\n\n\tif (id->driver_info & BTUSB_SWAVE) {\n\t\tset_bit(HCI_QUIRK_FIXUP_INQUIRY_MODE, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_INTEL_BOOT) {\n\t\thdev->manufacturer = 2;\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_ATH3012) {\n\t\tdata->setup_on_usb = btusb_setup_qca;\n\t\thdev->set_bdaddr = btusb_set_bdaddr_ath3012;\n\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_QCA_ROME) {\n\t\tdata->setup_on_usb = btusb_setup_qca;\n\t\thdev->shutdown = btusb_shutdown_qca;\n\t\thdev->set_bdaddr = btusb_set_bdaddr_ath3012;\n\t\thdev->cmd_timeout = btusb_qca_cmd_timeout;\n\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\t\tbtusb_check_needs_reset_resume(intf);\n\t}\n\n\tif (id->driver_info & BTUSB_QCA_WCN6855) {\n\t\tdata->qca_dump.id_vendor = id->idVendor;\n\t\tdata->qca_dump.id_product = id->idProduct;\n\t\tdata->recv_event = btusb_recv_evt_qca;\n\t\tdata->recv_acl = btusb_recv_acl_qca;\n\t\thci_devcd_register(hdev, btusb_coredump_qca, btusb_dump_hdr_qca, NULL);\n\t\tdata->setup_on_usb = btusb_setup_qca;\n\t\thdev->shutdown = btusb_shutdown_qca;\n\t\thdev->set_bdaddr = btusb_set_bdaddr_wcn6855;\n\t\thdev->cmd_timeout = btusb_qca_cmd_timeout;\n\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\t\thci_set_msft_opcode(hdev, 0xFD70);\n\t}\n\n\tif (id->driver_info & BTUSB_AMP) {\n\t\t \n\t\tdata->isoc = NULL;\n\t} else {\n\t\t \n\t\tdata->isoc = usb_ifnum_to_if(data->udev, ifnum_base + 1);\n\t\tdata->isoc_ifnum = ifnum_base + 1;\n\t}\n\n\tif (IS_ENABLED(CONFIG_BT_HCIBTUSB_RTL) &&\n\t    (id->driver_info & BTUSB_REALTEK)) {\n\t\tbtrtl_set_driver_name(hdev, btusb_driver.name);\n\t\thdev->setup = btusb_setup_realtek;\n\t\thdev->shutdown = btrtl_shutdown_realtek;\n\t\thdev->cmd_timeout = btusb_rtl_cmd_timeout;\n\t\thdev->hw_error = btusb_rtl_hw_error;\n\n\t\t \n\t\tset_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags);\n\t\tset_bit(BTUSB_USE_ALT3_FOR_WBS, &data->flags);\n\t}\n\n\tif (id->driver_info & BTUSB_ACTIONS_SEMI) {\n\t\t \n\t\tset_bit(HCI_QUIRK_BROKEN_ERR_DATA_REPORTING, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_READ_TRANSMIT_POWER, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_SET_RPA_TIMEOUT, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_BROKEN_EXT_SCAN, &hdev->quirks);\n\t}\n\n\tif (!reset)\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\tif (force_scofix || id->driver_info & BTUSB_WRONG_SCO_MTU) {\n\t\tif (!disable_scofix)\n\t\t\tset_bit(HCI_QUIRK_FIXUP_BUFFER_SIZE, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_BROKEN_ISOC)\n\t\tdata->isoc = NULL;\n\n\tif (id->driver_info & BTUSB_WIDEBAND_SPEECH)\n\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\n\tif (id->driver_info & BTUSB_VALID_LE_STATES)\n\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\n\tif (id->driver_info & BTUSB_DIGIANSWER) {\n\t\tdata->cmdreq_type = USB_TYPE_VENDOR;\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_CSR) {\n\t\tstruct usb_device *udev = data->udev;\n\t\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\t\t \n\t\tif (bcdDevice < 0x117)\n\t\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\t\t \n\t\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\n\t\t \n\t\tif (le16_to_cpu(udev->descriptor.idVendor)  == 0x0a12 &&\n\t\t    le16_to_cpu(udev->descriptor.idProduct) == 0x0001)\n\t\t\thdev->setup = btusb_setup_csr;\n\t}\n\n\tif (id->driver_info & BTUSB_SNIFFER) {\n\t\tstruct usb_device *udev = data->udev;\n\n\t\t \n\t\tif (le16_to_cpu(udev->descriptor.bcdDevice) > 0x997)\n\t\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\t}\n\n\tif (id->driver_info & BTUSB_INTEL_BOOT) {\n\t\t \n\t\terr = usb_set_interface(data->udev, 0, 0);\n\t\tif (err < 0) {\n\t\t\tBT_ERR(\"failed to set interface 0, alt 0 %d\", err);\n\t\t\tgoto out_free_dev;\n\t\t}\n\t}\n\n\tif (data->isoc) {\n\t\terr = usb_driver_claim_interface(&btusb_driver,\n\t\t\t\t\t\t data->isoc, data);\n\t\tif (err < 0)\n\t\t\tgoto out_free_dev;\n\t}\n\n\tif (IS_ENABLED(CONFIG_BT_HCIBTUSB_BCM) && data->diag) {\n\t\tif (!usb_driver_claim_interface(&btusb_driver,\n\t\t\t\t\t\tdata->diag, data))\n\t\t\t__set_diag_interface(hdev);\n\t\telse\n\t\t\tdata->diag = NULL;\n\t}\n\n\tif (enable_autosuspend)\n\t\tusb_enable_autosuspend(data->udev);\n\n\tdata->poll_sync = enable_poll_sync;\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0)\n\t\tgoto out_free_dev;\n\n\tusb_set_intfdata(intf, data);\n\n\tdebugfs_create_file(\"force_poll_sync\", 0644, hdev->debugfs, data,\n\t\t\t    &force_poll_sync_fops);\n\n\treturn 0;\n\nout_free_dev:\n\tif (data->reset_gpio)\n\t\tgpiod_put(data->reset_gpio);\n\thci_free_dev(hdev);\n\treturn err;\n}\n\nstatic void btusb_disconnect(struct usb_interface *intf)\n{\n\tstruct btusb_data *data = usb_get_intfdata(intf);\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (!data)\n\t\treturn;\n\n\thdev = data->hdev;\n\tusb_set_intfdata(data->intf, NULL);\n\n\tif (data->isoc)\n\t\tusb_set_intfdata(data->isoc, NULL);\n\n\tif (data->diag)\n\t\tusb_set_intfdata(data->diag, NULL);\n\n\thci_unregister_dev(hdev);\n\n\tif (intf == data->intf) {\n\t\tif (data->isoc)\n\t\t\tusb_driver_release_interface(&btusb_driver, data->isoc);\n\t\tif (data->diag)\n\t\t\tusb_driver_release_interface(&btusb_driver, data->diag);\n\t} else if (intf == data->isoc) {\n\t\tif (data->diag)\n\t\t\tusb_driver_release_interface(&btusb_driver, data->diag);\n\t\tusb_driver_release_interface(&btusb_driver, data->intf);\n\t} else if (intf == data->diag) {\n\t\tusb_driver_release_interface(&btusb_driver, data->intf);\n\t\tif (data->isoc)\n\t\t\tusb_driver_release_interface(&btusb_driver, data->isoc);\n\t}\n\n\tif (data->oob_wake_irq)\n\t\tdevice_init_wakeup(&data->udev->dev, false);\n\n\tif (data->reset_gpio)\n\t\tgpiod_put(data->reset_gpio);\n\n\thci_free_dev(hdev);\n}\n\n#ifdef CONFIG_PM\nstatic int btusb_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct btusb_data *data = usb_get_intfdata(intf);\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (data->suspend_count++)\n\t\treturn 0;\n\n\tspin_lock_irq(&data->txlock);\n\tif (!(PMSG_IS_AUTO(message) && data->tx_in_flight)) {\n\t\tset_bit(BTUSB_SUSPENDING, &data->flags);\n\t\tspin_unlock_irq(&data->txlock);\n\t} else {\n\t\tspin_unlock_irq(&data->txlock);\n\t\tdata->suspend_count--;\n\t\treturn -EBUSY;\n\t}\n\n\tcancel_work_sync(&data->work);\n\n\tbtusb_stop_traffic(data);\n\tusb_kill_anchored_urbs(&data->tx_anchor);\n\n\tif (data->oob_wake_irq && device_may_wakeup(&data->udev->dev)) {\n\t\tset_bit(BTUSB_OOB_WAKE_ENABLED, &data->flags);\n\t\tenable_irq_wake(data->oob_wake_irq);\n\t\tenable_irq(data->oob_wake_irq);\n\t}\n\n\t \n\tif (test_bit(BTUSB_WAKEUP_AUTOSUSPEND, &data->flags)) {\n\t\tif (PMSG_IS_AUTO(message) &&\n\t\t    device_can_wakeup(&data->udev->dev))\n\t\t\tdata->udev->do_remote_wakeup = 1;\n\t\telse if (!PMSG_IS_AUTO(message) &&\n\t\t\t !device_may_wakeup(&data->udev->dev)) {\n\t\t\tdata->udev->do_remote_wakeup = 0;\n\t\t\tdata->udev->reset_resume = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void play_deferred(struct btusb_data *data)\n{\n\tstruct urb *urb;\n\tint err;\n\n\twhile ((urb = usb_get_from_anchor(&data->deferred))) {\n\t\tusb_anchor_urb(urb, &data->tx_anchor);\n\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err < 0) {\n\t\t\tif (err != -EPERM && err != -ENODEV)\n\t\t\t\tBT_ERR(\"%s urb %p submission failed (%d)\",\n\t\t\t\t       data->hdev->name, urb, -err);\n\t\t\tkfree(urb->setup_packet);\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tusb_free_urb(urb);\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->tx_in_flight++;\n\t\tusb_free_urb(urb);\n\t}\n\n\t \n\twhile ((urb = usb_get_from_anchor(&data->deferred))) {\n\t\tkfree(urb->setup_packet);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic int btusb_resume(struct usb_interface *intf)\n{\n\tstruct btusb_data *data = usb_get_intfdata(intf);\n\tstruct hci_dev *hdev = data->hdev;\n\tint err = 0;\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (--data->suspend_count)\n\t\treturn 0;\n\n\t \n\tif (test_and_clear_bit(BTUSB_OOB_WAKE_ENABLED, &data->flags)) {\n\t\tdisable_irq(data->oob_wake_irq);\n\t\tdisable_irq_wake(data->oob_wake_irq);\n\t}\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\tgoto done;\n\n\tif (test_bit(BTUSB_INTR_RUNNING, &data->flags)) {\n\t\terr = btusb_submit_intr_urb(hdev, GFP_NOIO);\n\t\tif (err < 0) {\n\t\t\tclear_bit(BTUSB_INTR_RUNNING, &data->flags);\n\t\t\tgoto failed;\n\t\t}\n\t}\n\n\tif (test_bit(BTUSB_BULK_RUNNING, &data->flags)) {\n\t\terr = btusb_submit_bulk_urb(hdev, GFP_NOIO);\n\t\tif (err < 0) {\n\t\t\tclear_bit(BTUSB_BULK_RUNNING, &data->flags);\n\t\t\tgoto failed;\n\t\t}\n\n\t\tbtusb_submit_bulk_urb(hdev, GFP_NOIO);\n\t}\n\n\tif (test_bit(BTUSB_ISOC_RUNNING, &data->flags)) {\n\t\tif (btusb_submit_isoc_urb(hdev, GFP_NOIO) < 0)\n\t\t\tclear_bit(BTUSB_ISOC_RUNNING, &data->flags);\n\t\telse\n\t\t\tbtusb_submit_isoc_urb(hdev, GFP_NOIO);\n\t}\n\n\tspin_lock_irq(&data->txlock);\n\tplay_deferred(data);\n\tclear_bit(BTUSB_SUSPENDING, &data->flags);\n\tspin_unlock_irq(&data->txlock);\n\tschedule_work(&data->work);\n\n\treturn 0;\n\nfailed:\n\tusb_scuttle_anchored_urbs(&data->deferred);\ndone:\n\tspin_lock_irq(&data->txlock);\n\tclear_bit(BTUSB_SUSPENDING, &data->flags);\n\tspin_unlock_irq(&data->txlock);\n\n\treturn err;\n}\n#endif\n\n#ifdef CONFIG_DEV_COREDUMP\nstatic void btusb_coredump(struct device *dev)\n{\n\tstruct btusb_data *data = dev_get_drvdata(dev);\n\tstruct hci_dev *hdev = data->hdev;\n\n\tif (hdev->dump.coredump)\n\t\thdev->dump.coredump(hdev);\n}\n#endif\n\nstatic struct usb_driver btusb_driver = {\n\t.name\t\t= \"btusb\",\n\t.probe\t\t= btusb_probe,\n\t.disconnect\t= btusb_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t= btusb_suspend,\n\t.resume\t\t= btusb_resume,\n#endif\n\t.id_table\t= btusb_table,\n\t.supports_autosuspend = 1,\n\t.disable_hub_initiated_lpm = 1,\n\n#ifdef CONFIG_DEV_COREDUMP\n\t.drvwrap = {\n\t\t.driver = {\n\t\t\t.coredump = btusb_coredump,\n\t\t},\n\t},\n#endif\n};\n\nmodule_usb_driver(btusb_driver);\n\nmodule_param(disable_scofix, bool, 0644);\nMODULE_PARM_DESC(disable_scofix, \"Disable fixup of wrong SCO buffer size\");\n\nmodule_param(force_scofix, bool, 0644);\nMODULE_PARM_DESC(force_scofix, \"Force fixup of wrong SCO buffers size\");\n\nmodule_param(enable_autosuspend, bool, 0644);\nMODULE_PARM_DESC(enable_autosuspend, \"Enable USB autosuspend by default\");\n\nmodule_param(reset, bool, 0644);\nMODULE_PARM_DESC(reset, \"Send HCI reset command on initialization\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Generic Bluetooth USB driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}