{
  "module_name": "ath3k.c",
  "hash_id": "e680a2aa49238f4f0941e19603cdeca8f0117f3fa7d405a29e9d85466db4758c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/ath3k.c",
  "human_readable_source": "\n \n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/usb.h>\n#include <asm/unaligned.h>\n#include <net/bluetooth/bluetooth.h>\n\n#define VERSION \"1.0\"\n#define ATH3K_FIRMWARE\t\"ath3k-1.fw\"\n\n#define ATH3K_DNLOAD\t\t\t\t0x01\n#define ATH3K_GETSTATE\t\t\t\t0x05\n#define ATH3K_SET_NORMAL_MODE\t\t\t0x07\n#define ATH3K_GETVERSION\t\t\t0x09\n#define USB_REG_SWITCH_VID_PID\t\t\t0x0a\n\n#define ATH3K_MODE_MASK\t\t\t\t0x3F\n#define ATH3K_NORMAL_MODE\t\t\t0x0E\n\n#define ATH3K_PATCH_UPDATE\t\t\t0x80\n#define ATH3K_SYSCFG_UPDATE\t\t\t0x40\n\n#define ATH3K_XTAL_FREQ_26M\t\t\t0x00\n#define ATH3K_XTAL_FREQ_40M\t\t\t0x01\n#define ATH3K_XTAL_FREQ_19P2\t\t\t0x02\n#define ATH3K_NAME_LEN\t\t\t\t0xFF\n\nstruct ath3k_version {\n\t__le32\trom_version;\n\t__le32\tbuild_version;\n\t__le32\tram_version;\n\t__u8\tref_clock;\n\t__u8\treserved[7];\n} __packed;\n\nstatic const struct usb_device_id ath3k_table[] = {\n\t \n\t{ USB_DEVICE(0x0CF3, 0x3000) },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xE027) },\n\t{ USB_DEVICE(0x0489, 0xE03D) },\n\t{ USB_DEVICE(0x04F2, 0xAFF1) },\n\t{ USB_DEVICE(0x0930, 0x0215) },\n\t{ USB_DEVICE(0x0CF3, 0x3002) },\n\t{ USB_DEVICE(0x0CF3, 0xE019) },\n\t{ USB_DEVICE(0x13d3, 0x3304) },\n\n\t \n\t{ USB_DEVICE(0x03F0, 0x311D) },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe04d) },\n\t{ USB_DEVICE(0x0489, 0xe04e) },\n\t{ USB_DEVICE(0x0489, 0xe057) },\n\t{ USB_DEVICE(0x0489, 0xe056) },\n\t{ USB_DEVICE(0x0489, 0xe05f) },\n\t{ USB_DEVICE(0x0489, 0xe076) },\n\t{ USB_DEVICE(0x0489, 0xe078) },\n\t{ USB_DEVICE(0x0489, 0xe095) },\n\t{ USB_DEVICE(0x04c5, 0x1330) },\n\t{ USB_DEVICE(0x04CA, 0x3004) },\n\t{ USB_DEVICE(0x04CA, 0x3005) },\n\t{ USB_DEVICE(0x04CA, 0x3006) },\n\t{ USB_DEVICE(0x04CA, 0x3007) },\n\t{ USB_DEVICE(0x04CA, 0x3008) },\n\t{ USB_DEVICE(0x04CA, 0x300b) },\n\t{ USB_DEVICE(0x04CA, 0x300d) },\n\t{ USB_DEVICE(0x04CA, 0x300f) },\n\t{ USB_DEVICE(0x04CA, 0x3010) },\n\t{ USB_DEVICE(0x04CA, 0x3014) },\n\t{ USB_DEVICE(0x04CA, 0x3018) },\n\t{ USB_DEVICE(0x0930, 0x0219) },\n\t{ USB_DEVICE(0x0930, 0x021c) },\n\t{ USB_DEVICE(0x0930, 0x0220) },\n\t{ USB_DEVICE(0x0930, 0x0227) },\n\t{ USB_DEVICE(0x0b05, 0x17d0) },\n\t{ USB_DEVICE(0x0CF3, 0x0036) },\n\t{ USB_DEVICE(0x0CF3, 0x3004) },\n\t{ USB_DEVICE(0x0CF3, 0x3008) },\n\t{ USB_DEVICE(0x0CF3, 0x311D) },\n\t{ USB_DEVICE(0x0CF3, 0x311E) },\n\t{ USB_DEVICE(0x0CF3, 0x311F) },\n\t{ USB_DEVICE(0x0cf3, 0x3121) },\n\t{ USB_DEVICE(0x0CF3, 0x817a) },\n\t{ USB_DEVICE(0x0CF3, 0x817b) },\n\t{ USB_DEVICE(0x0cf3, 0xe003) },\n\t{ USB_DEVICE(0x0CF3, 0xE004) },\n\t{ USB_DEVICE(0x0CF3, 0xE005) },\n\t{ USB_DEVICE(0x0CF3, 0xE006) },\n\t{ USB_DEVICE(0x13d3, 0x3362) },\n\t{ USB_DEVICE(0x13d3, 0x3375) },\n\t{ USB_DEVICE(0x13d3, 0x3393) },\n\t{ USB_DEVICE(0x13d3, 0x3395) },\n\t{ USB_DEVICE(0x13d3, 0x3402) },\n\t{ USB_DEVICE(0x13d3, 0x3408) },\n\t{ USB_DEVICE(0x13d3, 0x3423) },\n\t{ USB_DEVICE(0x13d3, 0x3432) },\n\t{ USB_DEVICE(0x13d3, 0x3472) },\n\t{ USB_DEVICE(0x13d3, 0x3474) },\n\t{ USB_DEVICE(0x13d3, 0x3487) },\n\t{ USB_DEVICE(0x13d3, 0x3490) },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xE02C) },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xE036) },\n\t{ USB_DEVICE(0x0489, 0xE03C) },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, ath3k_table);\n\n#define BTUSB_ATH3012\t\t0x80\n \nstatic const struct usb_device_id ath3k_blist_tbl[] = {\n\n\t \n\t{ USB_DEVICE(0x0489, 0xe04e), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe04d), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xe095), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3006), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3014), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x04ca, 0x3018), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x021c), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0930, 0x0227), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0b05, 0x17d0), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0CF3, 0x0036), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3008), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311D), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311E), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x311F), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0x3121), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0CF3, 0x817a), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0CF3, 0x817b), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe004), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe005), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe006), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0cf3, 0xe003), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3362), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3375), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3395), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3472), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3487), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x13d3, 0x3490), .driver_info = BTUSB_ATH3012 },\n\n\t \n\t{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },\n\t{ USB_DEVICE(0x0489, 0xE03C), .driver_info = BTUSB_ATH3012 },\n\n\t{ }\t \n};\n\nstatic inline void ath3k_log_failed_loading(int err, int len, int size,\n\t\t\t\t\t    int count)\n{\n\tBT_ERR(\"Firmware loading err = %d, len = %d, size = %d, count = %d\",\n\t       err, len, size, count);\n}\n\n#define USB_REQ_DFU_DNLOAD\t1\n#define BULK_SIZE\t\t4096\n#define FW_HDR_SIZE\t\t20\n#define TIMEGAP_USEC_MIN\t50\n#define TIMEGAP_USEC_MAX\t100\n\nstatic int ath3k_load_firmware(struct usb_device *udev,\n\t\t\t\tconst struct firmware *firmware)\n{\n\tu8 *send_buf;\n\tint len = 0;\n\tint err, pipe, size, sent = 0;\n\tint count = firmware->size;\n\n\tBT_DBG(\"udev %p\", udev);\n\n\tsend_buf = kmalloc(BULK_SIZE, GFP_KERNEL);\n\tif (!send_buf) {\n\t\tBT_ERR(\"Can't allocate memory chunk for firmware\");\n\t\treturn -ENOMEM;\n\t}\n\n\terr = usb_control_msg_send(udev, 0, USB_REQ_DFU_DNLOAD, USB_TYPE_VENDOR,\n\t\t\t\t   0, 0, firmware->data, FW_HDR_SIZE,\n\t\t\t\t   USB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n\tif (err) {\n\t\tBT_ERR(\"Can't change to loading configuration err\");\n\t\tgoto error;\n\t}\n\tsent += FW_HDR_SIZE;\n\tcount -= FW_HDR_SIZE;\n\n\tpipe = usb_sndbulkpipe(udev, 0x02);\n\n\twhile (count) {\n\t\t \n\t\tusleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);\n\n\t\tsize = min_t(uint, count, BULK_SIZE);\n\t\tmemcpy(send_buf, firmware->data + sent, size);\n\n\t\terr = usb_bulk_msg(udev, pipe, send_buf, size,\n\t\t\t\t\t&len, 3000);\n\n\t\tif (err || (len != size)) {\n\t\t\tath3k_log_failed_loading(err, len, size, count);\n\t\t\tgoto error;\n\t\t}\n\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\nerror:\n\tkfree(send_buf);\n\treturn err;\n}\n\nstatic int ath3k_get_state(struct usb_device *udev, unsigned char *state)\n{\n\treturn usb_control_msg_recv(udev, 0, ATH3K_GETSTATE,\n\t\t\t\t    USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\n\t\t\t\t    state, 1, USB_CTRL_SET_TIMEOUT,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic int ath3k_get_version(struct usb_device *udev,\n\t\t\tstruct ath3k_version *version)\n{\n\treturn usb_control_msg_recv(udev, 0, ATH3K_GETVERSION,\n\t\t\t\t    USB_TYPE_VENDOR | USB_DIR_IN, 0, 0,\n\t\t\t\t    version, sizeof(*version), USB_CTRL_SET_TIMEOUT,\n\t\t\t\t    GFP_KERNEL);\n}\n\nstatic int ath3k_load_fwfile(struct usb_device *udev,\n\t\tconst struct firmware *firmware)\n{\n\tu8 *send_buf;\n\tint len = 0;\n\tint err, pipe, size, count, sent = 0;\n\tint ret;\n\n\tcount = firmware->size;\n\n\tsend_buf = kmalloc(BULK_SIZE, GFP_KERNEL);\n\tif (!send_buf) {\n\t\tBT_ERR(\"Can't allocate memory chunk for firmware\");\n\t\treturn -ENOMEM;\n\t}\n\n\tsize = min_t(uint, count, FW_HDR_SIZE);\n\n\tret = usb_control_msg_send(udev, 0, ATH3K_DNLOAD, USB_TYPE_VENDOR, 0, 0,\n\t\t\t\t   firmware->data, size, USB_CTRL_SET_TIMEOUT,\n\t\t\t\t   GFP_KERNEL);\n\tif (ret) {\n\t\tBT_ERR(\"Can't change to loading configuration err\");\n\t\tkfree(send_buf);\n\t\treturn ret;\n\t}\n\n\tsent += size;\n\tcount -= size;\n\n\tpipe = usb_sndbulkpipe(udev, 0x02);\n\n\twhile (count) {\n\t\t \n\t\tusleep_range(TIMEGAP_USEC_MIN, TIMEGAP_USEC_MAX);\n\n\t\tsize = min_t(uint, count, BULK_SIZE);\n\t\tmemcpy(send_buf, firmware->data + sent, size);\n\n\t\terr = usb_bulk_msg(udev, pipe, send_buf, size,\n\t\t\t\t\t&len, 3000);\n\t\tif (err || (len != size)) {\n\t\t\tath3k_log_failed_loading(err, len, size, count);\n\t\t\tkfree(send_buf);\n\t\t\treturn err;\n\t\t}\n\t\tsent  += size;\n\t\tcount -= size;\n\t}\n\n\tkfree(send_buf);\n\treturn 0;\n}\n\nstatic void ath3k_switch_pid(struct usb_device *udev)\n{\n\tusb_control_msg_send(udev, 0, USB_REG_SWITCH_VID_PID, USB_TYPE_VENDOR,\n\t\t\t     0, 0, NULL, 0, USB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n}\n\nstatic int ath3k_set_normal_mode(struct usb_device *udev)\n{\n\tunsigned char fw_state;\n\tint ret;\n\n\tret = ath3k_get_state(udev, &fw_state);\n\tif (ret) {\n\t\tBT_ERR(\"Can't get state to change to normal mode err\");\n\t\treturn ret;\n\t}\n\n\tif ((fw_state & ATH3K_MODE_MASK) == ATH3K_NORMAL_MODE) {\n\t\tBT_DBG(\"firmware was already in normal mode\");\n\t\treturn 0;\n\t}\n\n\treturn usb_control_msg_send(udev, 0, ATH3K_SET_NORMAL_MODE,\n\t\t\t\t    USB_TYPE_VENDOR, 0, 0, NULL, 0,\n\t\t\t\t    USB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n}\n\nstatic int ath3k_load_patch(struct usb_device *udev)\n{\n\tunsigned char fw_state;\n\tchar filename[ATH3K_NAME_LEN];\n\tconst struct firmware *firmware;\n\tstruct ath3k_version fw_version;\n\t__u32 pt_rom_version, pt_build_version;\n\tint ret;\n\n\tret = ath3k_get_state(udev, &fw_state);\n\tif (ret) {\n\t\tBT_ERR(\"Can't get state to change to load ram patch err\");\n\t\treturn ret;\n\t}\n\n\tif (fw_state & ATH3K_PATCH_UPDATE) {\n\t\tBT_DBG(\"Patch was already downloaded\");\n\t\treturn 0;\n\t}\n\n\tret = ath3k_get_version(udev, &fw_version);\n\tif (ret) {\n\t\tBT_ERR(\"Can't get version to change to load ram patch err\");\n\t\treturn ret;\n\t}\n\n\tsnprintf(filename, ATH3K_NAME_LEN, \"ar3k/AthrBT_0x%08x.dfu\",\n\t\t le32_to_cpu(fw_version.rom_version));\n\n\tret = request_firmware(&firmware, filename, &udev->dev);\n\tif (ret < 0) {\n\t\tBT_ERR(\"Patch file not found %s\", filename);\n\t\treturn ret;\n\t}\n\n\tpt_rom_version = get_unaligned_le32(firmware->data +\n\t\t\t\t\t    firmware->size - 8);\n\tpt_build_version = get_unaligned_le32(firmware->data +\n\t\t\t\t\t      firmware->size - 4);\n\n\tif (pt_rom_version != le32_to_cpu(fw_version.rom_version) ||\n\t    pt_build_version <= le32_to_cpu(fw_version.build_version)) {\n\t\tBT_ERR(\"Patch file version did not match with firmware\");\n\t\trelease_firmware(firmware);\n\t\treturn -EINVAL;\n\t}\n\n\tret = ath3k_load_fwfile(udev, firmware);\n\trelease_firmware(firmware);\n\n\treturn ret;\n}\n\nstatic int ath3k_load_syscfg(struct usb_device *udev)\n{\n\tunsigned char fw_state;\n\tchar filename[ATH3K_NAME_LEN];\n\tconst struct firmware *firmware;\n\tstruct ath3k_version fw_version;\n\tint clk_value, ret;\n\n\tret = ath3k_get_state(udev, &fw_state);\n\tif (ret) {\n\t\tBT_ERR(\"Can't get state to change to load configuration err\");\n\t\treturn -EBUSY;\n\t}\n\n\tret = ath3k_get_version(udev, &fw_version);\n\tif (ret) {\n\t\tBT_ERR(\"Can't get version to change to load ram patch err\");\n\t\treturn ret;\n\t}\n\n\tswitch (fw_version.ref_clock) {\n\n\tcase ATH3K_XTAL_FREQ_26M:\n\t\tclk_value = 26;\n\t\tbreak;\n\tcase ATH3K_XTAL_FREQ_40M:\n\t\tclk_value = 40;\n\t\tbreak;\n\tcase ATH3K_XTAL_FREQ_19P2:\n\t\tclk_value = 19;\n\t\tbreak;\n\tdefault:\n\t\tclk_value = 0;\n\t\tbreak;\n\t}\n\n\tsnprintf(filename, ATH3K_NAME_LEN, \"ar3k/ramps_0x%08x_%d%s\",\n\t\tle32_to_cpu(fw_version.rom_version), clk_value, \".dfu\");\n\n\tret = request_firmware(&firmware, filename, &udev->dev);\n\tif (ret < 0) {\n\t\tBT_ERR(\"Configuration file not found %s\", filename);\n\t\treturn ret;\n\t}\n\n\tret = ath3k_load_fwfile(udev, firmware);\n\trelease_firmware(firmware);\n\n\treturn ret;\n}\n\nstatic int ath3k_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tconst struct firmware *firmware;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tint ret;\n\n\tBT_DBG(\"intf %p id %p\", intf, id);\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\t \n\tif (!id->driver_info) {\n\t\tconst struct usb_device_id *match;\n\n\t\tmatch = usb_match_id(intf, ath3k_blist_tbl);\n\t\tif (match)\n\t\t\tid = match;\n\t}\n\n\t \n\tif (id->driver_info & BTUSB_ATH3012) {\n\t\t \n\t\tif (le16_to_cpu(udev->descriptor.bcdDevice) > 0x0001)\n\t\t\treturn -ENODEV;\n\n\t\tret = ath3k_load_patch(udev);\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"Loading patch file failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = ath3k_load_syscfg(udev);\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"Loading sysconfig file failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tret = ath3k_set_normal_mode(udev);\n\t\tif (ret) {\n\t\t\tBT_ERR(\"Set normal mode failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tath3k_switch_pid(udev);\n\t\treturn 0;\n\t}\n\n\tret = request_firmware(&firmware, ATH3K_FIRMWARE, &udev->dev);\n\tif (ret < 0) {\n\t\tif (ret == -ENOENT)\n\t\t\tBT_ERR(\"Firmware file \\\"%s\\\" not found\",\n\t\t\t\t\t\t\tATH3K_FIRMWARE);\n\t\telse\n\t\t\tBT_ERR(\"Firmware file \\\"%s\\\" request failed (err=%d)\",\n\t\t\t\t\t\t\tATH3K_FIRMWARE, ret);\n\t\treturn ret;\n\t}\n\n\tret = ath3k_load_firmware(udev, firmware);\n\trelease_firmware(firmware);\n\n\treturn ret;\n}\n\nstatic void ath3k_disconnect(struct usb_interface *intf)\n{\n\tBT_DBG(\"%s intf %p\", __func__, intf);\n}\n\nstatic struct usb_driver ath3k_driver = {\n\t.name\t\t= \"ath3k\",\n\t.probe\t\t= ath3k_probe,\n\t.disconnect\t= ath3k_disconnect,\n\t.id_table\t= ath3k_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(ath3k_driver);\n\nMODULE_AUTHOR(\"Atheros Communications\");\nMODULE_DESCRIPTION(\"Atheros AR30xx firmware driver\");\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(ATH3K_FIRMWARE);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}