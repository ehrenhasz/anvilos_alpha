{
  "module_name": "hci_intel.c",
  "hash_id": "766031d733ea81b63065f75c42eb12733d71f5a47dbd045a9d116b335babf4e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_intel.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/wait.h>\n#include <linux/tty.h>\n#include <linux/platform_device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/acpi.h>\n#include <linux/interrupt.h>\n#include <linux/pm_runtime.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n#include \"btintel.h\"\n\n#define STATE_BOOTLOADER\t0\n#define STATE_DOWNLOADING\t1\n#define STATE_FIRMWARE_LOADED\t2\n#define STATE_FIRMWARE_FAILED\t3\n#define STATE_BOOTING\t\t4\n#define STATE_LPM_ENABLED\t5\n#define STATE_TX_ACTIVE\t\t6\n#define STATE_SUSPENDED\t\t7\n#define STATE_LPM_TRANSACTION\t8\n\n#define HCI_LPM_WAKE_PKT 0xf0\n#define HCI_LPM_PKT 0xf1\n#define HCI_LPM_MAX_SIZE 10\n#define HCI_LPM_HDR_SIZE HCI_EVENT_HDR_SIZE\n\n#define LPM_OP_TX_NOTIFY 0x00\n#define LPM_OP_SUSPEND_ACK 0x02\n#define LPM_OP_RESUME_ACK 0x03\n\n#define LPM_SUSPEND_DELAY_MS 1000\n\nstruct hci_lpm_pkt {\n\t__u8 opcode;\n\t__u8 dlen;\n\t__u8 data[];\n} __packed;\n\nstruct intel_device {\n\tstruct list_head list;\n\tstruct platform_device *pdev;\n\tstruct gpio_desc *reset;\n\tstruct hci_uart *hu;\n\tstruct mutex hu_lock;\n\tint irq;\n};\n\nstatic LIST_HEAD(intel_device_list);\nstatic DEFINE_MUTEX(intel_device_list_lock);\n\nstruct intel_data {\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct work_struct busy_work;\n\tstruct hci_uart *hu;\n\tunsigned long flags;\n};\n\nstatic u8 intel_convert_speed(unsigned int speed)\n{\n\tswitch (speed) {\n\tcase 9600:\n\t\treturn 0x00;\n\tcase 19200:\n\t\treturn 0x01;\n\tcase 38400:\n\t\treturn 0x02;\n\tcase 57600:\n\t\treturn 0x03;\n\tcase 115200:\n\t\treturn 0x04;\n\tcase 230400:\n\t\treturn 0x05;\n\tcase 460800:\n\t\treturn 0x06;\n\tcase 921600:\n\t\treturn 0x07;\n\tcase 1843200:\n\t\treturn 0x08;\n\tcase 3250000:\n\t\treturn 0x09;\n\tcase 2000000:\n\t\treturn 0x0a;\n\tcase 3000000:\n\t\treturn 0x0b;\n\tdefault:\n\t\treturn 0xff;\n\t}\n}\n\nstatic int intel_wait_booting(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\tint err;\n\n\terr = wait_on_bit_timeout(&intel->flags, STATE_BOOTING,\n\t\t\t\t  TASK_INTERRUPTIBLE,\n\t\t\t\t  msecs_to_jiffies(1000));\n\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hu->hdev, \"Device boot interrupted\");\n\t\treturn -EINTR;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hu->hdev, \"Device boot timeout\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic int intel_wait_lpm_transaction(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\tint err;\n\n\terr = wait_on_bit_timeout(&intel->flags, STATE_LPM_TRANSACTION,\n\t\t\t\t  TASK_INTERRUPTIBLE,\n\t\t\t\t  msecs_to_jiffies(1000));\n\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hu->hdev, \"LPM transaction interrupted\");\n\t\treturn -EINTR;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hu->hdev, \"LPM transaction timeout\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn err;\n}\n\nstatic int intel_lpm_suspend(struct hci_uart *hu)\n{\n\tstatic const u8 suspend[] = { 0x01, 0x01, 0x01 };\n\tstruct intel_data *intel = hu->priv;\n\tstruct sk_buff *skb;\n\n\tif (!test_bit(STATE_LPM_ENABLED, &intel->flags) ||\n\t    test_bit(STATE_SUSPENDED, &intel->flags))\n\t\treturn 0;\n\n\tif (test_bit(STATE_TX_ACTIVE, &intel->flags))\n\t\treturn -EAGAIN;\n\n\tbt_dev_dbg(hu->hdev, \"Suspending\");\n\n\tskb = bt_skb_alloc(sizeof(suspend), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Failed to alloc memory for LPM packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, suspend, sizeof(suspend));\n\thci_skb_pkt_type(skb) = HCI_LPM_PKT;\n\n\tset_bit(STATE_LPM_TRANSACTION, &intel->flags);\n\n\t \n\tskb_queue_head(&intel->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\tintel_wait_lpm_transaction(hu);\n\t \n\n\tclear_bit(STATE_LPM_TRANSACTION, &intel->flags);\n\n\tif (!test_bit(STATE_SUSPENDED, &intel->flags)) {\n\t\tbt_dev_err(hu->hdev, \"Device suspend error\");\n\t\treturn -EINVAL;\n\t}\n\n\tbt_dev_dbg(hu->hdev, \"Suspended\");\n\n\thci_uart_set_flow_control(hu, true);\n\n\treturn 0;\n}\n\nstatic int intel_lpm_resume(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\tstruct sk_buff *skb;\n\n\tif (!test_bit(STATE_LPM_ENABLED, &intel->flags) ||\n\t    !test_bit(STATE_SUSPENDED, &intel->flags))\n\t\treturn 0;\n\n\tbt_dev_dbg(hu->hdev, \"Resuming\");\n\n\thci_uart_set_flow_control(hu, false);\n\n\tskb = bt_skb_alloc(0, GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Failed to alloc memory for LPM packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\thci_skb_pkt_type(skb) = HCI_LPM_WAKE_PKT;\n\n\tset_bit(STATE_LPM_TRANSACTION, &intel->flags);\n\n\t \n\tskb_queue_head(&intel->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\tintel_wait_lpm_transaction(hu);\n\t \n\n\tclear_bit(STATE_LPM_TRANSACTION, &intel->flags);\n\n\tif (test_bit(STATE_SUSPENDED, &intel->flags)) {\n\t\tbt_dev_err(hu->hdev, \"Device resume error\");\n\t\treturn -EINVAL;\n\t}\n\n\tbt_dev_dbg(hu->hdev, \"Resumed\");\n\n\treturn 0;\n}\n#endif  \n\nstatic int intel_lpm_host_wake(struct hci_uart *hu)\n{\n\tstatic const u8 lpm_resume_ack[] = { LPM_OP_RESUME_ACK, 0x00 };\n\tstruct intel_data *intel = hu->priv;\n\tstruct sk_buff *skb;\n\n\thci_uart_set_flow_control(hu, false);\n\n\tclear_bit(STATE_SUSPENDED, &intel->flags);\n\n\tskb = bt_skb_alloc(sizeof(lpm_resume_ack), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Failed to alloc memory for LPM packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, lpm_resume_ack, sizeof(lpm_resume_ack));\n\thci_skb_pkt_type(skb) = HCI_LPM_PKT;\n\n\t \n\tskb_queue_head(&intel->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\tbt_dev_dbg(hu->hdev, \"Resumed by controller\");\n\n\treturn 0;\n}\n\nstatic irqreturn_t intel_irq(int irq, void *dev_id)\n{\n\tstruct intel_device *idev = dev_id;\n\n\tdev_info(&idev->pdev->dev, \"hci_intel irq\\n\");\n\n\tmutex_lock(&idev->hu_lock);\n\tif (idev->hu)\n\t\tintel_lpm_host_wake(idev->hu);\n\tmutex_unlock(&idev->hu_lock);\n\n\t \n\tpm_runtime_get(&idev->pdev->dev);\n\tpm_runtime_mark_last_busy(&idev->pdev->dev);\n\tpm_runtime_put_autosuspend(&idev->pdev->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int intel_set_power(struct hci_uart *hu, bool powered)\n{\n\tstruct intel_device *idev;\n\tint err = -ENODEV;\n\n\tif (!hu->tty->dev)\n\t\treturn err;\n\n\tmutex_lock(&intel_device_list_lock);\n\n\tlist_for_each_entry(idev, &intel_device_list, list) {\n\t\t \n\t\tif (hu->tty->dev->parent != idev->pdev->dev.parent)\n\t\t\tcontinue;\n\n\t\tif (!idev->reset) {\n\t\t\terr = -ENOTSUPP;\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_INFO(\"hu %p, Switching compatible pm device (%s) to %u\",\n\t\t\thu, dev_name(&idev->pdev->dev), powered);\n\n\t\tgpiod_set_value(idev->reset, powered);\n\n\t\t \n\t\tmutex_lock(&idev->hu_lock);\n\t\tidev->hu = powered ? hu : NULL;\n\t\tmutex_unlock(&idev->hu_lock);\n\n\t\tif (idev->irq < 0)\n\t\t\tbreak;\n\n\t\tif (powered && device_can_wakeup(&idev->pdev->dev)) {\n\t\t\terr = devm_request_threaded_irq(&idev->pdev->dev,\n\t\t\t\t\t\t\tidev->irq, NULL,\n\t\t\t\t\t\t\tintel_irq,\n\t\t\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\t\t\"bt-host-wake\", idev);\n\t\t\tif (err) {\n\t\t\t\tBT_ERR(\"hu %p, unable to allocate irq-%d\",\n\t\t\t\t       hu, idev->irq);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdevice_wakeup_enable(&idev->pdev->dev);\n\n\t\t\tpm_runtime_set_active(&idev->pdev->dev);\n\t\t\tpm_runtime_use_autosuspend(&idev->pdev->dev);\n\t\t\tpm_runtime_set_autosuspend_delay(&idev->pdev->dev,\n\t\t\t\t\t\t\t LPM_SUSPEND_DELAY_MS);\n\t\t\tpm_runtime_enable(&idev->pdev->dev);\n\t\t} else if (!powered && device_may_wakeup(&idev->pdev->dev)) {\n\t\t\tdevm_free_irq(&idev->pdev->dev, idev->irq, idev);\n\t\t\tdevice_wakeup_disable(&idev->pdev->dev);\n\n\t\t\tpm_runtime_disable(&idev->pdev->dev);\n\t\t}\n\t}\n\n\tmutex_unlock(&intel_device_list_lock);\n\n\treturn err;\n}\n\nstatic void intel_busy_work(struct work_struct *work)\n{\n\tstruct intel_data *intel = container_of(work, struct intel_data,\n\t\t\t\t\t\tbusy_work);\n\tstruct intel_device *idev;\n\n\tif (!intel->hu->tty->dev)\n\t\treturn;\n\n\t \n\tmutex_lock(&intel_device_list_lock);\n\tlist_for_each_entry(idev, &intel_device_list, list) {\n\t\tif (intel->hu->tty->dev->parent == idev->pdev->dev.parent) {\n\t\t\tpm_runtime_get(&idev->pdev->dev);\n\t\t\tpm_runtime_mark_last_busy(&idev->pdev->dev);\n\t\t\tpm_runtime_put_autosuspend(&idev->pdev->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&intel_device_list_lock);\n}\n\nstatic int intel_open(struct hci_uart *hu)\n{\n\tstruct intel_data *intel;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tintel = kzalloc(sizeof(*intel), GFP_KERNEL);\n\tif (!intel)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&intel->txq);\n\tINIT_WORK(&intel->busy_work, intel_busy_work);\n\n\tintel->hu = hu;\n\n\thu->priv = intel;\n\n\tif (!intel_set_power(hu, true))\n\t\tset_bit(STATE_BOOTING, &intel->flags);\n\n\treturn 0;\n}\n\nstatic int intel_close(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tcancel_work_sync(&intel->busy_work);\n\n\tintel_set_power(hu, false);\n\n\tskb_queue_purge(&intel->txq);\n\tkfree_skb(intel->rx_skb);\n\tkfree(intel);\n\n\thu->priv = NULL;\n\treturn 0;\n}\n\nstatic int intel_flush(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&intel->txq);\n\n\treturn 0;\n}\n\nstatic int inject_cmd_complete(struct hci_dev *hdev, __u16 opcode)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_event_hdr *hdr;\n\tstruct hci_ev_cmd_complete *evt;\n\n\tskb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->evt = HCI_EV_CMD_COMPLETE;\n\thdr->plen = sizeof(*evt) + 1;\n\n\tevt = skb_put(skb, sizeof(*evt));\n\tevt->ncmd = 0x01;\n\tevt->opcode = cpu_to_le16(opcode);\n\n\tskb_put_u8(skb, 0x00);\n\n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int intel_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tstruct intel_data *intel = hu->priv;\n\tstruct hci_dev *hdev = hu->hdev;\n\tu8 speed_cmd[] = { 0x06, 0xfc, 0x01, 0x00 };\n\tstruct sk_buff *skb;\n\tint err;\n\n\t \n\terr = intel_wait_booting(hu);\n\n\tclear_bit(STATE_BOOTING, &intel->flags);\n\n\t \n\tif (err && err != -ETIMEDOUT)\n\t\treturn err;\n\n\tbt_dev_info(hdev, \"Change controller speed to %d\", speed);\n\n\tspeed_cmd[3] = intel_convert_speed(speed);\n\tif (speed_cmd[3] == 0xff) {\n\t\tbt_dev_err(hdev, \"Unsupported speed\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc05, 0, NULL, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading Intel version information failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tskb = bt_skb_alloc(sizeof(speed_cmd), GFP_KERNEL);\n\tif (!skb) {\n\t\tbt_dev_err(hdev, \"Failed to alloc memory for baudrate packet\");\n\t\treturn -ENOMEM;\n\t}\n\n\tskb_put_data(skb, speed_cmd, sizeof(speed_cmd));\n\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\thci_uart_set_flow_control(hu, true);\n\n\tskb_queue_tail(&intel->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\t \n\tmsleep(100);\n\n\thci_uart_set_baudrate(hu, speed);\n\thci_uart_set_flow_control(hu, false);\n\n\treturn 0;\n}\n\nstatic int intel_setup(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\tstruct intel_version ver;\n\tstruct intel_boot_params params;\n\tstruct intel_device *idev;\n\tconst struct firmware *fw;\n\tchar fwname[64];\n\tu32 boot_param;\n\tktime_t calltime, delta, rettime;\n\tunsigned long long duration;\n\tunsigned int init_speed, oper_speed;\n\tint speed_change = 0;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"start intel_setup\");\n\n\thu->hdev->set_diag = btintel_set_diag;\n\thu->hdev->set_bdaddr = btintel_set_bdaddr;\n\n\t \n\tboot_param = 0x00000000;\n\n\tcalltime = ktime_get();\n\n\tif (hu->init_speed)\n\t\tinit_speed = hu->init_speed;\n\telse\n\t\tinit_speed = hu->proto->init_speed;\n\n\tif (hu->oper_speed)\n\t\toper_speed = hu->oper_speed;\n\telse\n\t\toper_speed = hu->proto->oper_speed;\n\n\tif (oper_speed && init_speed && oper_speed != init_speed)\n\t\tspeed_change = 1;\n\n\t \n\terr = intel_wait_booting(hu);\n\n\tclear_bit(STATE_BOOTING, &intel->flags);\n\n\t \n\tif (err && err != -ETIMEDOUT)\n\t\treturn err;\n\n\tset_bit(STATE_BOOTLOADER, &intel->flags);\n\n\t \n\terr = btintel_read_version(hdev, &ver);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (ver.hw_platform != 0x37) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware platform (%u)\",\n\t\t\t   ver.hw_platform);\n\t\treturn -EINVAL;\n\t}\n\n         \n\tswitch (ver.hw_variant) {\n\tcase 0x0b:\t \n\tcase 0x0c:\t \n\tcase 0x12:\t \n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant (%u)\",\n\t\t\t   ver.hw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\tbtintel_version_info(hdev, &ver);\n\n\t \n\tif (ver.fw_variant == 0x23) {\n\t\tclear_bit(STATE_BOOTLOADER, &intel->flags);\n\t\tbtintel_check_bdaddr(hdev);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ver.fw_variant != 0x06) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel firmware variant (%u)\",\n\t\t\t   ver.fw_variant);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\terr = btintel_read_boot_params(hdev, &params);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (params.limited_cce != 0x00) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel firmware loading method (%u)\",\n\t\t\t   params.limited_cce);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!bacmp(&params.otp_bdaddr, BDADDR_ANY)) {\n\t\tbt_dev_info(hdev, \"No device address configured\");\n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\n\t}\n\n\t \n\tswitch (ver.hw_variant) {\n\tcase 0x0b:       \n\tcase 0x0c:       \n\t\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-%u-%u.sfi\",\n\t\t\t ver.hw_variant, le16_to_cpu(params.dev_revid));\n\t\tbreak;\n\tcase 0x12:       \n\t\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-%u-%u-%u.sfi\",\n\t\t\t ver.hw_variant, ver.hw_revision, ver.fw_revision);\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant (%u)\",\n\t\t\t   ver.hw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to load Intel firmware file (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"Found device firmware: %s\", fwname);\n\n\t \n\tswitch (ver.hw_variant) {\n\tcase 0x0b:       \n\tcase 0x0c:       \n\t\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-%u-%u.ddc\",\n\t\t\t ver.hw_variant, le16_to_cpu(params.dev_revid));\n\t\tbreak;\n\tcase 0x12:       \n\t\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-%u-%u-%u.ddc\",\n\t\t\t ver.hw_variant, ver.hw_revision, ver.fw_revision);\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant (%u)\",\n\t\t\t   ver.hw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\tif (fw->size < 644) {\n\t\tbt_dev_err(hdev, \"Invalid size of firmware file (%zu)\",\n\t\t\t   fw->size);\n\t\terr = -EBADF;\n\t\tgoto done;\n\t}\n\n\tset_bit(STATE_DOWNLOADING, &intel->flags);\n\n\t \n\terr = btintel_download_firmware(hdev, &ver, fw, &boot_param);\n\tif (err < 0)\n\t\tgoto done;\n\n\tset_bit(STATE_FIRMWARE_LOADED, &intel->flags);\n\n\tbt_dev_info(hdev, \"Waiting for firmware download to complete\");\n\n\t \n\terr = wait_on_bit_timeout(&intel->flags, STATE_DOWNLOADING,\n\t\t\t\t  TASK_INTERRUPTIBLE,\n\t\t\t\t  msecs_to_jiffies(5000));\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Firmware loading interrupted\");\n\t\terr = -EINTR;\n\t\tgoto done;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Firmware loading timeout\");\n\t\terr = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tif (test_bit(STATE_FIRMWARE_FAILED, &intel->flags)) {\n\t\tbt_dev_err(hdev, \"Firmware loading failed\");\n\t\terr = -ENOEXEC;\n\t\tgoto done;\n\t}\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long) ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Firmware loaded in %llu usecs\", duration);\n\ndone:\n\trelease_firmware(fw);\n\n\t \n\tif (err < 0 && err != -EALREADY)\n\t\treturn err;\n\n\t \n\tif (speed_change) {\n\t\terr = intel_set_baudrate(hu, init_speed);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tcalltime = ktime_get();\n\n\tset_bit(STATE_BOOTING, &intel->flags);\n\n\terr = btintel_send_intel_reset(hdev, boot_param);\n\tif (err)\n\t\treturn err;\n\n\t \n\tbt_dev_info(hdev, \"Waiting for device to boot\");\n\n\terr = intel_wait_booting(hu);\n\tif (err)\n\t\treturn err;\n\n\tclear_bit(STATE_BOOTING, &intel->flags);\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long) ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Device booted in %llu usecs\", duration);\n\n\t \n\tmutex_lock(&intel_device_list_lock);\n\tlist_for_each_entry(idev, &intel_device_list, list) {\n\t\tif (!hu->tty->dev)\n\t\t\tbreak;\n\t\tif (hu->tty->dev->parent == idev->pdev->dev.parent) {\n\t\t\tif (device_may_wakeup(&idev->pdev->dev)) {\n\t\t\t\tset_bit(STATE_LPM_ENABLED, &intel->flags);\n\t\t\t\tset_bit(STATE_TX_ACTIVE, &intel->flags);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&intel_device_list_lock);\n\n\t \n\tbtintel_load_ddc_config(hdev, fwname);\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\tkfree_skb(skb);\n\n\tif (speed_change) {\n\t\terr = intel_set_baudrate(hu, oper_speed);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"Setup complete\");\n\n\tclear_bit(STATE_BOOTLOADER, &intel->flags);\n\n\treturn 0;\n}\n\nstatic int intel_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct intel_data *intel = hu->priv;\n\tstruct hci_event_hdr *hdr;\n\n\tif (!test_bit(STATE_BOOTLOADER, &intel->flags) &&\n\t    !test_bit(STATE_BOOTING, &intel->flags))\n\t\tgoto recv;\n\n\thdr = (void *)skb->data;\n\n\t \n\tif (skb->len == 7 && hdr->evt == 0xff && hdr->plen == 0x05 &&\n\t    skb->data[2] == 0x06) {\n\t\tif (skb->data[3] != 0x00)\n\t\t\tset_bit(STATE_FIRMWARE_FAILED, &intel->flags);\n\n\t\tif (test_and_clear_bit(STATE_DOWNLOADING, &intel->flags) &&\n\t\t    test_bit(STATE_FIRMWARE_LOADED, &intel->flags))\n\t\t\twake_up_bit(&intel->flags, STATE_DOWNLOADING);\n\n\t \n\t} else if (skb->len == 9 && hdr->evt == 0xff && hdr->plen == 0x07 &&\n\t\t   skb->data[2] == 0x02) {\n\t\tif (test_and_clear_bit(STATE_BOOTING, &intel->flags))\n\t\t\twake_up_bit(&intel->flags, STATE_BOOTING);\n\t}\nrecv:\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic void intel_recv_lpm_notify(struct hci_dev *hdev, int value)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct intel_data *intel = hu->priv;\n\n\tbt_dev_dbg(hdev, \"TX idle notification (%d)\", value);\n\n\tif (value) {\n\t\tset_bit(STATE_TX_ACTIVE, &intel->flags);\n\t\tschedule_work(&intel->busy_work);\n\t} else {\n\t\tclear_bit(STATE_TX_ACTIVE, &intel->flags);\n\t}\n}\n\nstatic int intel_recv_lpm(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_lpm_pkt *lpm = (void *)skb->data;\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct intel_data *intel = hu->priv;\n\n\tswitch (lpm->opcode) {\n\tcase LPM_OP_TX_NOTIFY:\n\t\tif (lpm->dlen < 1) {\n\t\t\tbt_dev_err(hu->hdev, \"Invalid LPM notification packet\");\n\t\t\tbreak;\n\t\t}\n\t\tintel_recv_lpm_notify(hdev, lpm->data[0]);\n\t\tbreak;\n\tcase LPM_OP_SUSPEND_ACK:\n\t\tset_bit(STATE_SUSPENDED, &intel->flags);\n\t\tif (test_and_clear_bit(STATE_LPM_TRANSACTION, &intel->flags))\n\t\t\twake_up_bit(&intel->flags, STATE_LPM_TRANSACTION);\n\t\tbreak;\n\tcase LPM_OP_RESUME_ACK:\n\t\tclear_bit(STATE_SUSPENDED, &intel->flags);\n\t\tif (test_and_clear_bit(STATE_LPM_TRANSACTION, &intel->flags))\n\t\t\twake_up_bit(&intel->flags, STATE_LPM_TRANSACTION);\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unknown LPM opcode (%02x)\", lpm->opcode);\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n#define INTEL_RECV_LPM \\\n\t.type = HCI_LPM_PKT, \\\n\t.hlen = HCI_LPM_HDR_SIZE, \\\n\t.loff = 1, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_LPM_MAX_SIZE\n\nstatic const struct h4_recv_pkt intel_recv_pkts[] = {\n\t{ H4_RECV_ACL,    .recv = hci_recv_frame   },\n\t{ H4_RECV_SCO,    .recv = hci_recv_frame   },\n\t{ H4_RECV_EVENT,  .recv = intel_recv_event },\n\t{ INTEL_RECV_LPM, .recv = intel_recv_lpm   },\n};\n\nstatic int intel_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct intel_data *intel = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tintel->rx_skb = h4_recv_buf(hu->hdev, intel->rx_skb, data, count,\n\t\t\t\t    intel_recv_pkts,\n\t\t\t\t    ARRAY_SIZE(intel_recv_pkts));\n\tif (IS_ERR(intel->rx_skb)) {\n\t\tint err = PTR_ERR(intel->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tintel->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic int intel_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct intel_data *intel = hu->priv;\n\tstruct intel_device *idev;\n\n\tBT_DBG(\"hu %p skb %p\", hu, skb);\n\n\tif (!hu->tty->dev)\n\t\tgoto out_enqueue;\n\n\t \n\tmutex_lock(&intel_device_list_lock);\n\tlist_for_each_entry(idev, &intel_device_list, list) {\n\t\tif (hu->tty->dev->parent == idev->pdev->dev.parent) {\n\t\t\tpm_runtime_get_sync(&idev->pdev->dev);\n\t\t\tpm_runtime_mark_last_busy(&idev->pdev->dev);\n\t\t\tpm_runtime_put_autosuspend(&idev->pdev->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&intel_device_list_lock);\nout_enqueue:\n\tskb_queue_tail(&intel->txq, skb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *intel_dequeue(struct hci_uart *hu)\n{\n\tstruct intel_data *intel = hu->priv;\n\tstruct sk_buff *skb;\n\n\tskb = skb_dequeue(&intel->txq);\n\tif (!skb)\n\t\treturn skb;\n\n\tif (test_bit(STATE_BOOTLOADER, &intel->flags) &&\n\t    (hci_skb_pkt_type(skb) == HCI_COMMAND_PKT)) {\n\t\tstruct hci_command_hdr *cmd = (void *)skb->data;\n\t\t__u16 opcode = le16_to_cpu(cmd->opcode);\n\n\t\t \n\t\tif (opcode == 0xfc01)\n\t\t\tinject_cmd_complete(hu->hdev, opcode);\n\t}\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\treturn skb;\n}\n\nstatic const struct hci_uart_proto intel_proto = {\n\t.id\t\t= HCI_UART_INTEL,\n\t.name\t\t= \"Intel\",\n\t.manufacturer\t= 2,\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= intel_open,\n\t.close\t\t= intel_close,\n\t.flush\t\t= intel_flush,\n\t.setup\t\t= intel_setup,\n\t.set_baudrate\t= intel_set_baudrate,\n\t.recv\t\t= intel_recv,\n\t.enqueue\t= intel_enqueue,\n\t.dequeue\t= intel_dequeue,\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id intel_acpi_match[] = {\n\t{ \"INT33E1\", 0 },\n\t{ \"INT33E3\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, intel_acpi_match);\n#endif\n\n#ifdef CONFIG_PM\nstatic int intel_suspend_device(struct device *dev)\n{\n\tstruct intel_device *idev = dev_get_drvdata(dev);\n\n\tmutex_lock(&idev->hu_lock);\n\tif (idev->hu)\n\t\tintel_lpm_suspend(idev->hu);\n\tmutex_unlock(&idev->hu_lock);\n\n\treturn 0;\n}\n\nstatic int intel_resume_device(struct device *dev)\n{\n\tstruct intel_device *idev = dev_get_drvdata(dev);\n\n\tmutex_lock(&idev->hu_lock);\n\tif (idev->hu)\n\t\tintel_lpm_resume(idev->hu);\n\tmutex_unlock(&idev->hu_lock);\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\nstatic int intel_suspend(struct device *dev)\n{\n\tstruct intel_device *idev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tenable_irq_wake(idev->irq);\n\n\treturn intel_suspend_device(dev);\n}\n\nstatic int intel_resume(struct device *dev)\n{\n\tstruct intel_device *idev = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(idev->irq);\n\n\treturn intel_resume_device(dev);\n}\n#endif\n\nstatic const struct dev_pm_ops intel_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(intel_suspend, intel_resume)\n\tSET_RUNTIME_PM_OPS(intel_suspend_device, intel_resume_device, NULL)\n};\n\nstatic const struct acpi_gpio_params reset_gpios = { 0, 0, false };\nstatic const struct acpi_gpio_params host_wake_gpios = { 1, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_hci_intel_gpios[] = {\n\t{ \"reset-gpios\", &reset_gpios, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ \"host-wake-gpios\", &host_wake_gpios, 1, ACPI_GPIO_QUIRK_ONLY_GPIOIO },\n\t{ }\n};\n\nstatic int intel_probe(struct platform_device *pdev)\n{\n\tstruct intel_device *idev;\n\tint ret;\n\n\tidev = devm_kzalloc(&pdev->dev, sizeof(*idev), GFP_KERNEL);\n\tif (!idev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&idev->hu_lock);\n\n\tidev->pdev = pdev;\n\n\tret = devm_acpi_dev_add_driver_gpios(&pdev->dev, acpi_hci_intel_gpios);\n\tif (ret)\n\t\tdev_dbg(&pdev->dev, \"Unable to add GPIO mapping table\\n\");\n\n\tidev->reset = devm_gpiod_get(&pdev->dev, \"reset\", GPIOD_OUT_LOW);\n\tif (IS_ERR(idev->reset)) {\n\t\tdev_err(&pdev->dev, \"Unable to retrieve gpio\\n\");\n\t\treturn PTR_ERR(idev->reset);\n\t}\n\n\tidev->irq = platform_get_irq(pdev, 0);\n\tif (idev->irq < 0) {\n\t\tstruct gpio_desc *host_wake;\n\n\t\tdev_err(&pdev->dev, \"No IRQ, falling back to gpio-irq\\n\");\n\n\t\thost_wake = devm_gpiod_get(&pdev->dev, \"host-wake\", GPIOD_IN);\n\t\tif (IS_ERR(host_wake)) {\n\t\t\tdev_err(&pdev->dev, \"Unable to retrieve IRQ\\n\");\n\t\t\tgoto no_irq;\n\t\t}\n\n\t\tidev->irq = gpiod_to_irq(host_wake);\n\t\tif (idev->irq < 0) {\n\t\t\tdev_err(&pdev->dev, \"No corresponding irq for gpio\\n\");\n\t\t\tgoto no_irq;\n\t\t}\n\t}\n\n\t \n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\tdevice_wakeup_disable(&pdev->dev);\n\nno_irq:\n\tplatform_set_drvdata(pdev, idev);\n\n\t \n\tmutex_lock(&intel_device_list_lock);\n\tlist_add_tail(&idev->list, &intel_device_list);\n\tmutex_unlock(&intel_device_list_lock);\n\n\tdev_info(&pdev->dev, \"registered, gpio(%d)/irq(%d).\\n\",\n\t\t desc_to_gpio(idev->reset), idev->irq);\n\n\treturn 0;\n}\n\nstatic int intel_remove(struct platform_device *pdev)\n{\n\tstruct intel_device *idev = platform_get_drvdata(pdev);\n\n\tdevice_wakeup_disable(&pdev->dev);\n\n\tmutex_lock(&intel_device_list_lock);\n\tlist_del(&idev->list);\n\tmutex_unlock(&intel_device_list_lock);\n\n\tdev_info(&pdev->dev, \"unregistered.\\n\");\n\n\treturn 0;\n}\n\nstatic struct platform_driver intel_driver = {\n\t.probe = intel_probe,\n\t.remove = intel_remove,\n\t.driver = {\n\t\t.name = \"hci_intel\",\n\t\t.acpi_match_table = ACPI_PTR(intel_acpi_match),\n\t\t.pm = &intel_pm_ops,\n\t},\n};\n\nint __init intel_init(void)\n{\n\tint err;\n\n\terr = platform_driver_register(&intel_driver);\n\tif (err)\n\t\treturn err;\n\n\treturn hci_uart_register_proto(&intel_proto);\n}\n\nint __exit intel_deinit(void)\n{\n\tplatform_driver_unregister(&intel_driver);\n\n\treturn hci_uart_unregister_proto(&intel_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}