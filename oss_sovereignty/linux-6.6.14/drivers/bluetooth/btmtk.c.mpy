{
  "module_name": "btmtk.c",
  "hash_id": "d615340f99227d4ba7bc958a5c7647f6567afc47466c48d0cdbaa89609db0664",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btmtk.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/firmware.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btmtk.h\"\n\n#define VERSION \"0.1\"\n\n \n#define MTK_FW_ROM_PATCH_HEADER_SIZE\t32\n#define MTK_FW_ROM_PATCH_GD_SIZE\t64\n#define MTK_FW_ROM_PATCH_SEC_MAP_SIZE\t64\n#define MTK_SEC_MAP_COMMON_SIZE\t12\n#define MTK_SEC_MAP_NEED_SEND_SIZE\t52\n\nstruct btmtk_patch_header {\n\tu8 datetime[16];\n\tu8 platform[4];\n\t__le16 hwver;\n\t__le16 swver;\n\t__le32 magicnum;\n} __packed;\n\nstruct btmtk_global_desc {\n\t__le32 patch_ver;\n\t__le32 sub_sys;\n\t__le32 feature_opt;\n\t__le32 section_num;\n} __packed;\n\nstruct btmtk_section_map {\n\t__le32 sectype;\n\t__le32 secoffset;\n\t__le32 secsize;\n\tunion {\n\t\t__le32 u4SecSpec[13];\n\t\tstruct {\n\t\t\t__le32 dlAddr;\n\t\t\t__le32 dlsize;\n\t\t\t__le32 seckeyidx;\n\t\t\t__le32 alignlen;\n\t\t\t__le32 sectype;\n\t\t\t__le32 dlmodecrctype;\n\t\t\t__le32 crc;\n\t\t\t__le32 reserved[6];\n\t\t} bin_info_spec;\n\t};\n} __packed;\n\nstatic void btmtk_coredump(struct hci_dev *hdev)\n{\n\tint err;\n\n\terr = __hci_cmd_send(hdev, 0xfd5b, 0, NULL);\n\tif (err < 0)\n\t\tbt_dev_err(hdev, \"Coredump failed (%d)\", err);\n}\n\nstatic void btmtk_coredump_hdr(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmediatek_data *data = hci_get_priv(hdev);\n\tchar buf[80];\n\n\tsnprintf(buf, sizeof(buf), \"Controller Name: 0x%X\\n\",\n\t\t data->dev_id);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Firmware Version: 0x%X\\n\",\n\t\t data->cd_info.fw_version);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Driver: %s\\n\",\n\t\t data->cd_info.driver_name);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Vendor: MediaTek\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n}\n\nstatic void btmtk_coredump_notify(struct hci_dev *hdev, int state)\n{\n\tstruct btmediatek_data *data = hci_get_priv(hdev);\n\n\tswitch (state) {\n\tcase HCI_DEVCOREDUMP_IDLE:\n\t\tdata->cd_info.state = HCI_DEVCOREDUMP_IDLE;\n\t\tbreak;\n\tcase HCI_DEVCOREDUMP_ACTIVE:\n\t\tdata->cd_info.state = HCI_DEVCOREDUMP_ACTIVE;\n\t\tbreak;\n\tcase HCI_DEVCOREDUMP_TIMEOUT:\n\tcase HCI_DEVCOREDUMP_ABORT:\n\tcase HCI_DEVCOREDUMP_DONE:\n\t\tdata->cd_info.state = HCI_DEVCOREDUMP_IDLE;\n\t\tbtmtk_reset_sync(hdev);\n\t\tbreak;\n\t}\n}\n\nint btmtk_setup_firmware_79xx(struct hci_dev *hdev, const char *fwname,\n\t\t\t      wmt_cmd_sync_func_t wmt_cmd_sync)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tstruct btmtk_patch_header *hdr;\n\tstruct btmtk_global_desc *globaldesc = NULL;\n\tstruct btmtk_section_map *sectionmap;\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tconst u8 *fw_bin_ptr;\n\tint err, dlen, i, status;\n\tu8 flag, first_block, retry;\n\tu32 section_num, dl_size, section_offset;\n\tu8 cmd[64];\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to load firmware file (%d)\", err);\n\t\treturn err;\n\t}\n\n\tfw_ptr = fw->data;\n\tfw_bin_ptr = fw_ptr;\n\thdr = (struct btmtk_patch_header *)fw_ptr;\n\tglobaldesc = (struct btmtk_global_desc *)(fw_ptr + MTK_FW_ROM_PATCH_HEADER_SIZE);\n\tsection_num = le32_to_cpu(globaldesc->section_num);\n\n\tbt_dev_info(hdev, \"HW/SW Version: 0x%04x%04x, Build Time: %s\",\n\t\t    le16_to_cpu(hdr->hwver), le16_to_cpu(hdr->swver), hdr->datetime);\n\n\tfor (i = 0; i < section_num; i++) {\n\t\tfirst_block = 1;\n\t\tfw_ptr = fw_bin_ptr;\n\t\tsectionmap = (struct btmtk_section_map *)(fw_ptr + MTK_FW_ROM_PATCH_HEADER_SIZE +\n\t\t\t      MTK_FW_ROM_PATCH_GD_SIZE + MTK_FW_ROM_PATCH_SEC_MAP_SIZE * i);\n\n\t\tsection_offset = le32_to_cpu(sectionmap->secoffset);\n\t\tdl_size = le32_to_cpu(sectionmap->bin_info_spec.dlsize);\n\n\t\tif (dl_size > 0) {\n\t\t\tretry = 20;\n\t\t\twhile (retry > 0) {\n\t\t\t\tcmd[0] = 0;  \n\t\t\t\tmemcpy(cmd + 1,\n\t\t\t\t       fw_ptr + MTK_FW_ROM_PATCH_HEADER_SIZE +\n\t\t\t\t       MTK_FW_ROM_PATCH_GD_SIZE +\n\t\t\t\t       MTK_FW_ROM_PATCH_SEC_MAP_SIZE * i +\n\t\t\t\t       MTK_SEC_MAP_COMMON_SIZE,\n\t\t\t\t       MTK_SEC_MAP_NEED_SEND_SIZE + 1);\n\n\t\t\t\twmt_params.op = BTMTK_WMT_PATCH_DWNLD;\n\t\t\t\twmt_params.status = &status;\n\t\t\t\twmt_params.flag = 0;\n\t\t\t\twmt_params.dlen = MTK_SEC_MAP_NEED_SEND_SIZE + 1;\n\t\t\t\twmt_params.data = &cmd;\n\n\t\t\t\terr = wmt_cmd_sync(hdev, &wmt_params);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tbt_dev_err(hdev, \"Failed to send wmt patch dwnld (%d)\",\n\t\t\t\t\t\t   err);\n\t\t\t\t\tgoto err_release_fw;\n\t\t\t\t}\n\n\t\t\t\tif (status == BTMTK_WMT_PATCH_UNDONE) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (status == BTMTK_WMT_PATCH_PROGRESS) {\n\t\t\t\t\tmsleep(100);\n\t\t\t\t\tretry--;\n\t\t\t\t} else if (status == BTMTK_WMT_PATCH_DONE) {\n\t\t\t\t\tgoto next_section;\n\t\t\t\t} else {\n\t\t\t\t\tbt_dev_err(hdev, \"Failed wmt patch dwnld status (%d)\",\n\t\t\t\t\t\t   status);\n\t\t\t\t\terr = -EIO;\n\t\t\t\t\tgoto err_release_fw;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfw_ptr += section_offset;\n\t\t\twmt_params.op = BTMTK_WMT_PATCH_DWNLD;\n\t\t\twmt_params.status = NULL;\n\n\t\t\twhile (dl_size > 0) {\n\t\t\t\tdlen = min_t(int, 250, dl_size);\n\t\t\t\tif (first_block == 1) {\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tfirst_block = 0;\n\t\t\t\t} else if (dl_size - dlen <= 0) {\n\t\t\t\t\tflag = 3;\n\t\t\t\t} else {\n\t\t\t\t\tflag = 2;\n\t\t\t\t}\n\n\t\t\t\twmt_params.flag = flag;\n\t\t\t\twmt_params.dlen = dlen;\n\t\t\t\twmt_params.data = fw_ptr;\n\n\t\t\t\terr = wmt_cmd_sync(hdev, &wmt_params);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tbt_dev_err(hdev, \"Failed to send wmt patch dwnld (%d)\",\n\t\t\t\t\t\t   err);\n\t\t\t\t\tgoto err_release_fw;\n\t\t\t\t}\n\n\t\t\t\tdl_size -= dlen;\n\t\t\t\tfw_ptr += dlen;\n\t\t\t}\n\t\t}\nnext_section:\n\t\tcontinue;\n\t}\n\t \n\tusleep_range(100000, 120000);\n\nerr_release_fw:\n\trelease_firmware(fw);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(btmtk_setup_firmware_79xx);\n\nint btmtk_setup_firmware(struct hci_dev *hdev, const char *fwname,\n\t\t\t wmt_cmd_sync_func_t wmt_cmd_sync)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tsize_t fw_size;\n\tint err, dlen;\n\tu8 flag, param;\n\n\terr = request_firmware(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to load firmware file (%d)\", err);\n\t\treturn err;\n\t}\n\n\t \n\tparam = 1;\n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 3;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = wmt_cmd_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to power on data RAM (%d)\", err);\n\t\tgoto err_release_fw;\n\t}\n\n\tfw_ptr = fw->data;\n\tfw_size = fw->size;\n\n\t \n\tif (fw_size < 30) {\n\t\terr = -EINVAL;\n\t\tgoto err_release_fw;\n\t}\n\n\tfw_size -= 30;\n\tfw_ptr += 30;\n\tflag = 1;\n\n\twmt_params.op = BTMTK_WMT_PATCH_DWNLD;\n\twmt_params.status = NULL;\n\n\twhile (fw_size > 0) {\n\t\tdlen = min_t(int, 250, fw_size);\n\n\t\t \n\t\tif (fw_size - dlen <= 0)\n\t\t\tflag = 3;\n\t\telse if (fw_size < fw->size - 30)\n\t\t\tflag = 2;\n\n\t\twmt_params.flag = flag;\n\t\twmt_params.dlen = dlen;\n\t\twmt_params.data = fw_ptr;\n\n\t\terr = wmt_cmd_sync(hdev, &wmt_params);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to send wmt patch dwnld (%d)\",\n\t\t\t\t   err);\n\t\t\tgoto err_release_fw;\n\t\t}\n\n\t\tfw_size -= dlen;\n\t\tfw_ptr += dlen;\n\t}\n\n\twmt_params.op = BTMTK_WMT_RST;\n\twmt_params.flag = 4;\n\twmt_params.dlen = 0;\n\twmt_params.data = NULL;\n\twmt_params.status = NULL;\n\n\t \n\terr = wmt_cmd_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt rst (%d)\", err);\n\t\tgoto err_release_fw;\n\t}\n\n\t \n\tusleep_range(10000, 12000);\n\nerr_release_fw:\n\trelease_firmware(fw);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(btmtk_setup_firmware);\n\nint btmtk_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tlong ret;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc1a, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"changing Mediatek device address failed (%ld)\",\n\t\t\t   ret);\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btmtk_set_bdaddr);\n\nvoid btmtk_reset_sync(struct hci_dev *hdev)\n{\n\tstruct btmediatek_data *reset_work = hci_get_priv(hdev);\n\tint err;\n\n\thci_dev_lock(hdev);\n\n\terr = hci_cmd_sync_queue(hdev, reset_work->reset_sync, NULL, NULL);\n\tif (err)\n\t\tbt_dev_err(hdev, \"failed to reset (%d)\", err);\n\n\thci_dev_unlock(hdev);\n}\nEXPORT_SYMBOL_GPL(btmtk_reset_sync);\n\nint btmtk_register_coredump(struct hci_dev *hdev, const char *name,\n\t\t\t    u32 fw_version)\n{\n\tstruct btmediatek_data *data = hci_get_priv(hdev);\n\n\tif (!IS_ENABLED(CONFIG_DEV_COREDUMP))\n\t\treturn -EOPNOTSUPP;\n\n\tdata->cd_info.fw_version = fw_version;\n\tdata->cd_info.state = HCI_DEVCOREDUMP_IDLE;\n\tdata->cd_info.driver_name = name;\n\n\treturn hci_devcd_register(hdev, btmtk_coredump, btmtk_coredump_hdr,\n\t\t\t\t  btmtk_coredump_notify);\n}\nEXPORT_SYMBOL_GPL(btmtk_register_coredump);\n\nint btmtk_process_coredump(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmediatek_data *data = hci_get_priv(hdev);\n\tint err;\n\n\tif (!IS_ENABLED(CONFIG_DEV_COREDUMP))\n\t\treturn 0;\n\n\tswitch (data->cd_info.state) {\n\tcase HCI_DEVCOREDUMP_IDLE:\n\t\terr = hci_devcd_init(hdev, MTK_COREDUMP_SIZE);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tdata->cd_info.cnt = 0;\n\n\t\t \n\t\tschedule_delayed_work(&hdev->dump.dump_timeout,\n\t\t\t\t      msecs_to_jiffies(5000));\n\t\tfallthrough;\n\tcase HCI_DEVCOREDUMP_ACTIVE:\n\tdefault:\n\t\terr = hci_devcd_append(hdev, skb);\n\t\tif (err < 0)\n\t\t\tbreak;\n\t\tdata->cd_info.cnt++;\n\n\t\t \n\t\tif (data->cd_info.cnt > MTK_COREDUMP_NUM &&\n\t\t    skb->len > MTK_COREDUMP_END_LEN)\n\t\t\tif (!memcmp((char *)&skb->data[skb->len - MTK_COREDUMP_END_LEN],\n\t\t\t\t    MTK_COREDUMP_END, MTK_COREDUMP_END_LEN - 1)) {\n\t\t\t\tbt_dev_info(hdev, \"Mediatek coredump end\");\n\t\t\t\thci_devcd_complete(hdev);\n\t\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (err < 0)\n\t\tkfree_skb(skb);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(btmtk_process_coredump);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_AUTHOR(\"Mark Chen <mark-yw.chen@mediatek.com>\");\nMODULE_DESCRIPTION(\"Bluetooth support for MediaTek devices ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(FIRMWARE_MT7622);\nMODULE_FIRMWARE(FIRMWARE_MT7663);\nMODULE_FIRMWARE(FIRMWARE_MT7668);\nMODULE_FIRMWARE(FIRMWARE_MT7961);\nMODULE_FIRMWARE(FIRMWARE_MT7925);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}