{
  "module_name": "bcm203x.c",
  "hash_id": "d5d0a06e5ed947c167db71571fe4946dc5c99dcdbfa2f8bf64591725ff1c6659",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/bcm203x.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n\n#include <linux/device.h>\n#include <linux/firmware.h>\n\n#include <linux/usb.h>\n\n#include <net/bluetooth/bluetooth.h>\n\n#define VERSION \"1.2\"\n\nstatic const struct usb_device_id bcm203x_table[] = {\n\t \n\t{ USB_DEVICE(0x0a5c, 0x2033) },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, bcm203x_table);\n\n#define BCM203X_ERROR\t\t0\n#define BCM203X_RESET\t\t1\n#define BCM203X_LOAD_MINIDRV\t2\n#define BCM203X_SELECT_MEMORY\t3\n#define BCM203X_CHECK_MEMORY\t4\n#define BCM203X_LOAD_FIRMWARE\t5\n#define BCM203X_CHECK_FIRMWARE\t6\n\n#define BCM203X_IN_EP\t\t0x81\n#define BCM203X_OUT_EP\t\t0x02\n\nstruct bcm203x_data {\n\tstruct usb_device\t*udev;\n\n\tunsigned long\t\tstate;\n\n\tstruct work_struct\twork;\n\tatomic_t\t\tshutdown;\n\n\tstruct urb\t\t*urb;\n\tunsigned char\t\t*buffer;\n\n\tunsigned char\t\t*fw_data;\n\tunsigned int\t\tfw_size;\n\tunsigned int\t\tfw_sent;\n};\n\nstatic void bcm203x_complete(struct urb *urb)\n{\n\tstruct bcm203x_data *data = urb->context;\n\tstruct usb_device *udev = urb->dev;\n\tint len;\n\n\tBT_DBG(\"udev %p urb %p\", udev, urb);\n\n\tif (urb->status) {\n\t\tBT_ERR(\"URB failed with status %d\", urb->status);\n\t\tdata->state = BCM203X_ERROR;\n\t\treturn;\n\t}\n\n\tswitch (data->state) {\n\tcase BCM203X_LOAD_MINIDRV:\n\t\tmemcpy(data->buffer, \"#\", 1);\n\n\t\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\n\t\t\t\tdata->buffer, 1, bcm203x_complete, data);\n\n\t\tdata->state = BCM203X_SELECT_MEMORY;\n\n\t\t \n\t\tschedule_work(&data->work);\n\t\tbreak;\n\n\tcase BCM203X_SELECT_MEMORY:\n\t\tusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),\n\t\t\t\tdata->buffer, 32, bcm203x_complete, data, 1);\n\n\t\tdata->state = BCM203X_CHECK_MEMORY;\n\n\t\tif (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)\n\t\t\tBT_ERR(\"Can't submit URB\");\n\t\tbreak;\n\n\tcase BCM203X_CHECK_MEMORY:\n\t\tif (data->buffer[0] != '#') {\n\t\t\tBT_ERR(\"Memory select failed\");\n\t\t\tdata->state = BCM203X_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->state = BCM203X_LOAD_FIRMWARE;\n\t\tfallthrough;\n\tcase BCM203X_LOAD_FIRMWARE:\n\t\tif (data->fw_sent == data->fw_size) {\n\t\t\tusb_fill_int_urb(urb, udev, usb_rcvintpipe(udev, BCM203X_IN_EP),\n\t\t\t\tdata->buffer, 32, bcm203x_complete, data, 1);\n\n\t\t\tdata->state = BCM203X_CHECK_FIRMWARE;\n\t\t} else {\n\t\t\tlen = min_t(uint, data->fw_size - data->fw_sent, 4096);\n\n\t\t\tusb_fill_bulk_urb(urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\n\t\t\t\tdata->fw_data + data->fw_sent, len, bcm203x_complete, data);\n\n\t\t\tdata->fw_sent += len;\n\t\t}\n\n\t\tif (usb_submit_urb(data->urb, GFP_ATOMIC) < 0)\n\t\t\tBT_ERR(\"Can't submit URB\");\n\t\tbreak;\n\n\tcase BCM203X_CHECK_FIRMWARE:\n\t\tif (data->buffer[0] != '.') {\n\t\t\tBT_ERR(\"Firmware loading failed\");\n\t\t\tdata->state = BCM203X_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata->state = BCM203X_RESET;\n\t\tbreak;\n\t}\n}\n\nstatic void bcm203x_work(struct work_struct *work)\n{\n\tstruct bcm203x_data *data =\n\t\tcontainer_of(work, struct bcm203x_data, work);\n\n\tif (atomic_read(&data->shutdown))\n\t\treturn;\n\n\tif (usb_submit_urb(data->urb, GFP_KERNEL) < 0)\n\t\tBT_ERR(\"Can't submit URB\");\n}\n\nstatic int bcm203x_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tconst struct firmware *firmware;\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct bcm203x_data *data;\n\tint size;\n\n\tBT_DBG(\"intf %p id %p\", intf, id);\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->udev  = udev;\n\tdata->state = BCM203X_LOAD_MINIDRV;\n\n\tdata->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!data->urb)\n\t\treturn -ENOMEM;\n\n\tif (request_firmware(&firmware, \"BCM2033-MD.hex\", &udev->dev) < 0) {\n\t\tBT_ERR(\"Mini driver request failed\");\n\t\tusb_free_urb(data->urb);\n\t\treturn -EIO;\n\t}\n\n\tBT_DBG(\"minidrv data %p size %zu\", firmware->data, firmware->size);\n\n\tsize = max_t(uint, firmware->size, 4096);\n\n\tdata->buffer = kmalloc(size, GFP_KERNEL);\n\tif (!data->buffer) {\n\t\tBT_ERR(\"Can't allocate memory for mini driver\");\n\t\trelease_firmware(firmware);\n\t\tusb_free_urb(data->urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(data->buffer, firmware->data, firmware->size);\n\n\tusb_fill_bulk_urb(data->urb, udev, usb_sndbulkpipe(udev, BCM203X_OUT_EP),\n\t\t\tdata->buffer, firmware->size, bcm203x_complete, data);\n\n\trelease_firmware(firmware);\n\n\tif (request_firmware(&firmware, \"BCM2033-FW.bin\", &udev->dev) < 0) {\n\t\tBT_ERR(\"Firmware request failed\");\n\t\tusb_free_urb(data->urb);\n\t\tkfree(data->buffer);\n\t\treturn -EIO;\n\t}\n\n\tBT_DBG(\"firmware data %p size %zu\", firmware->data, firmware->size);\n\n\tdata->fw_data = kmemdup(firmware->data, firmware->size, GFP_KERNEL);\n\tif (!data->fw_data) {\n\t\tBT_ERR(\"Can't allocate memory for firmware image\");\n\t\trelease_firmware(firmware);\n\t\tusb_free_urb(data->urb);\n\t\tkfree(data->buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->fw_size = firmware->size;\n\tdata->fw_sent = 0;\n\n\trelease_firmware(firmware);\n\n\tINIT_WORK(&data->work, bcm203x_work);\n\n\tusb_set_intfdata(intf, data);\n\n\t \n\tschedule_work(&data->work);\n\n\treturn 0;\n}\n\nstatic void bcm203x_disconnect(struct usb_interface *intf)\n{\n\tstruct bcm203x_data *data = usb_get_intfdata(intf);\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tatomic_inc(&data->shutdown);\n\tcancel_work_sync(&data->work);\n\n\tusb_kill_urb(data->urb);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tusb_free_urb(data->urb);\n\tkfree(data->fw_data);\n\tkfree(data->buffer);\n}\n\nstatic struct usb_driver bcm203x_driver = {\n\t.name\t\t= \"bcm203x\",\n\t.probe\t\t= bcm203x_probe,\n\t.disconnect\t= bcm203x_disconnect,\n\t.id_table\t= bcm203x_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(bcm203x_driver);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Broadcom Blutonium firmware driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"BCM2033-MD.hex\");\nMODULE_FIRMWARE(\"BCM2033-FW.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}