{
  "module_name": "btmtkuart.c",
  "hash_id": "3b26c03d21f59cd387814779e509a60fdda9565505ebb8284d5f3ebd4357acfd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btmtkuart.c",
  "human_readable_source": "\n\n\n \n\n#include <asm/unaligned.h>\n#include <linux/atomic.h>\n#include <linux/clk.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"h4_recv.h\"\n#include \"btmtk.h\"\n\n#define VERSION \"0.2\"\n\n#define MTK_STP_TLR_SIZE\t2\n\n#define BTMTKUART_TX_STATE_ACTIVE\t1\n#define BTMTKUART_TX_STATE_WAKEUP\t2\n#define BTMTKUART_TX_WAIT_VND_EVT\t3\n#define BTMTKUART_REQUIRED_WAKEUP\t4\n\n#define BTMTKUART_FLAG_STANDALONE_HW\t BIT(0)\n\nstruct mtk_stp_hdr {\n\tu8\tprefix;\n\t__be16\tdlen;\n\tu8\tcs;\n} __packed;\n\nstruct btmtkuart_data {\n\tunsigned int flags;\n\tconst char *fwname;\n};\n\nstruct btmtkuart_dev {\n\tstruct hci_dev *hdev;\n\tstruct serdev_device *serdev;\n\n\tstruct clk *clk;\n\tstruct clk *osc;\n\tstruct regulator *vcc;\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *boot;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pins_runtime;\n\tstruct pinctrl_state *pins_boot;\n\tspeed_t\tdesired_speed;\n\tspeed_t\tcurr_speed;\n\n\tstruct work_struct tx_work;\n\tunsigned long tx_state;\n\tstruct sk_buff_head txq;\n\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff *evt_skb;\n\n\tu8\tstp_pad[6];\n\tu8\tstp_cursor;\n\tu16\tstp_dlen;\n\n\tconst struct btmtkuart_data *data;\n};\n\n#define btmtkuart_is_standalone(bdev)\t\\\n\t((bdev)->data->flags & BTMTKUART_FLAG_STANDALONE_HW)\n#define btmtkuart_is_builtin_soc(bdev)\t\\\n\t!((bdev)->data->flags & BTMTKUART_FLAG_STANDALONE_HW)\n\nstatic int mtk_hci_wmt_sync(struct hci_dev *hdev,\n\t\t\t    struct btmtk_hci_wmt_params *wmt_params)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_evt_funcc *wmt_evt_funcc;\n\tu32 hlen, status = BTMTK_WMT_INVALID;\n\tstruct btmtk_hci_wmt_evt *wmt_evt;\n\tstruct btmtk_hci_wmt_cmd *wc;\n\tstruct btmtk_wmt_hdr *hdr;\n\tint err;\n\n\t \n\thlen = sizeof(*hdr) + wmt_params->dlen;\n\tif (hlen > 255) {\n\t\terr = -EINVAL;\n\t\tgoto err_free_skb;\n\t}\n\n\twc = kzalloc(hlen, GFP_KERNEL);\n\tif (!wc) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_skb;\n\t}\n\n\thdr = &wc->hdr;\n\thdr->dir = 1;\n\thdr->op = wmt_params->op;\n\thdr->dlen = cpu_to_le16(wmt_params->dlen + 1);\n\thdr->flag = wmt_params->flag;\n\tmemcpy(wc->data, wmt_params->data, wmt_params->dlen);\n\n\tset_bit(BTMTKUART_TX_WAIT_VND_EVT, &bdev->tx_state);\n\n\terr = __hci_cmd_send(hdev, 0xfc6f, hlen, wc);\n\tif (err < 0) {\n\t\tclear_bit(BTMTKUART_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\tgoto err_free_wc;\n\t}\n\n\t \n\terr = wait_on_bit_timeout(&bdev->tx_state, BTMTKUART_TX_WAIT_VND_EVT,\n\t\t\t\t  TASK_INTERRUPTIBLE, HCI_INIT_TIMEOUT);\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command interrupted\");\n\t\tclear_bit(BTMTKUART_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\tgoto err_free_wc;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Execution of wmt command timed out\");\n\t\tclear_bit(BTMTKUART_TX_WAIT_VND_EVT, &bdev->tx_state);\n\t\terr = -ETIMEDOUT;\n\t\tgoto err_free_wc;\n\t}\n\n\t \n\twmt_evt = (struct btmtk_hci_wmt_evt *)bdev->evt_skb->data;\n\tif (wmt_evt->whdr.op != hdr->op) {\n\t\tbt_dev_err(hdev, \"Wrong op received %d expected %d\",\n\t\t\t   wmt_evt->whdr.op, hdr->op);\n\t\terr = -EIO;\n\t\tgoto err_free_wc;\n\t}\n\n\tswitch (wmt_evt->whdr.op) {\n\tcase BTMTK_WMT_SEMAPHORE:\n\t\tif (wmt_evt->whdr.flag == 2)\n\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n\t\tbreak;\n\tcase BTMTK_WMT_FUNC_CTRL:\n\t\twmt_evt_funcc = (struct btmtk_hci_wmt_evt_funcc *)wmt_evt;\n\t\tif (be16_to_cpu(wmt_evt_funcc->status) == 0x404)\n\t\t\tstatus = BTMTK_WMT_ON_DONE;\n\t\telse if (be16_to_cpu(wmt_evt_funcc->status) == 0x420)\n\t\t\tstatus = BTMTK_WMT_ON_PROGRESS;\n\t\telse\n\t\t\tstatus = BTMTK_WMT_ON_UNDONE;\n\t\tbreak;\n\t}\n\n\tif (wmt_params->status)\n\t\t*wmt_params->status = status;\n\nerr_free_wc:\n\tkfree(wc);\nerr_free_skb:\n\tkfree_skb(bdev->evt_skb);\n\tbdev->evt_skb = NULL;\n\n\treturn err;\n}\n\nstatic int btmtkuart_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct hci_event_hdr *hdr = (void *)skb->data;\n\tint err;\n\n\t \n\tif (test_bit(BTMTKUART_TX_WAIT_VND_EVT, &bdev->tx_state)) {\n\t\tbdev->evt_skb = skb_clone(skb, GFP_KERNEL);\n\t\tif (!bdev->evt_skb) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\terr = hci_recv_frame(hdev, skb);\n\tif (err < 0)\n\t\tgoto err_free_skb;\n\n\tif (hdr->evt == HCI_EV_WMT) {\n\t\tif (test_and_clear_bit(BTMTKUART_TX_WAIT_VND_EVT,\n\t\t\t\t       &bdev->tx_state)) {\n\t\t\t \n\t\t\tsmp_mb__after_atomic();\n\t\t\twake_up_bit(&bdev->tx_state, BTMTKUART_TX_WAIT_VND_EVT);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr_free_skb:\n\tkfree_skb(bdev->evt_skb);\n\tbdev->evt_skb = NULL;\n\nerr_out:\n\treturn err;\n}\n\nstatic const struct h4_recv_pkt mtk_recv_pkts[] = {\n\t{ H4_RECV_ACL,      .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,      .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,    .recv = btmtkuart_recv_event },\n};\n\nstatic void btmtkuart_tx_work(struct work_struct *work)\n{\n\tstruct btmtkuart_dev *bdev = container_of(work, struct btmtkuart_dev,\n\t\t\t\t\t\t   tx_work);\n\tstruct serdev_device *serdev = bdev->serdev;\n\tstruct hci_dev *hdev = bdev->hdev;\n\n\twhile (1) {\n\t\tclear_bit(BTMTKUART_TX_STATE_WAKEUP, &bdev->tx_state);\n\n\t\twhile (1) {\n\t\t\tstruct sk_buff *skb = skb_dequeue(&bdev->txq);\n\t\t\tint len;\n\n\t\t\tif (!skb)\n\t\t\t\tbreak;\n\n\t\t\tlen = serdev_device_write_buf(serdev, skb->data,\n\t\t\t\t\t\t      skb->len);\n\t\t\thdev->stat.byte_tx += len;\n\n\t\t\tskb_pull(skb, len);\n\t\t\tif (skb->len > 0) {\n\t\t\t\tskb_queue_head(&bdev->txq, skb);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (hci_skb_pkt_type(skb)) {\n\t\t\tcase HCI_COMMAND_PKT:\n\t\t\t\thdev->stat.cmd_tx++;\n\t\t\t\tbreak;\n\t\t\tcase HCI_ACLDATA_PKT:\n\t\t\t\thdev->stat.acl_tx++;\n\t\t\t\tbreak;\n\t\t\tcase HCI_SCODATA_PKT:\n\t\t\t\thdev->stat.sco_tx++;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tif (!test_bit(BTMTKUART_TX_STATE_WAKEUP, &bdev->tx_state))\n\t\t\tbreak;\n\t}\n\n\tclear_bit(BTMTKUART_TX_STATE_ACTIVE, &bdev->tx_state);\n}\n\nstatic void btmtkuart_tx_wakeup(struct btmtkuart_dev *bdev)\n{\n\tif (test_and_set_bit(BTMTKUART_TX_STATE_ACTIVE, &bdev->tx_state))\n\t\tset_bit(BTMTKUART_TX_STATE_WAKEUP, &bdev->tx_state);\n\n\tschedule_work(&bdev->tx_work);\n}\n\nstatic const unsigned char *\nmtk_stp_split(struct btmtkuart_dev *bdev, const unsigned char *data, int count,\n\t      int *sz_h4)\n{\n\tstruct mtk_stp_hdr *shdr;\n\n\t \n\tif (!bdev->stp_dlen && bdev->stp_cursor >= 6)\n\t\tbdev->stp_cursor = 0;\n\n\t \n\twhile (bdev->stp_cursor < 6 && count > 0) {\n\t\tbdev->stp_pad[bdev->stp_cursor] = *data;\n\t\tbdev->stp_cursor++;\n\t\tdata++;\n\t\tcount--;\n\t}\n\n\t \n\tif (!bdev->stp_dlen && bdev->stp_cursor >= 6) {\n\t\tshdr = (struct mtk_stp_hdr *)&bdev->stp_pad[2];\n\t\tbdev->stp_dlen = be16_to_cpu(shdr->dlen) & 0x0fff;\n\n\t\t \n\t\tif (shdr->prefix != 0x80 || bdev->stp_dlen > 2048) {\n\t\t\tbt_dev_err(bdev->hdev, \"stp format unexpect (%d, %d)\",\n\t\t\t\t   shdr->prefix, bdev->stp_dlen);\n\t\t\tbdev->stp_cursor = 2;\n\t\t\tbdev->stp_dlen = 0;\n\t\t}\n\t}\n\n\t \n\tif (count <= 0)\n\t\treturn NULL;\n\n\t \n\t*sz_h4 = min_t(int, count, bdev->stp_dlen);\n\n\t \n\tbdev->stp_dlen -= *sz_h4;\n\n\t \n\treturn data;\n}\n\nstatic void btmtkuart_recv(struct hci_dev *hdev, const u8 *data, size_t count)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tconst unsigned char *p_left = data, *p_h4;\n\tint sz_left = count, sz_h4, adv;\n\tint err;\n\n\twhile (sz_left > 0) {\n\t\t \n\n\t\tp_h4 = mtk_stp_split(bdev, p_left, sz_left, &sz_h4);\n\t\tif (!p_h4)\n\t\t\tbreak;\n\n\t\tadv = p_h4 - p_left;\n\t\tsz_left -= adv;\n\t\tp_left += adv;\n\n\t\tbdev->rx_skb = h4_recv_buf(bdev->hdev, bdev->rx_skb, p_h4,\n\t\t\t\t\t   sz_h4, mtk_recv_pkts,\n\t\t\t\t\t   ARRAY_SIZE(mtk_recv_pkts));\n\t\tif (IS_ERR(bdev->rx_skb)) {\n\t\t\terr = PTR_ERR(bdev->rx_skb);\n\t\t\tbt_dev_err(bdev->hdev,\n\t\t\t\t   \"Frame reassembly failed (%d)\", err);\n\t\t\tbdev->rx_skb = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tsz_left -= sz_h4;\n\t\tp_left += sz_h4;\n\t}\n}\n\nstatic int btmtkuart_receive_buf(struct serdev_device *serdev, const u8 *data,\n\t\t\t\t size_t count)\n{\n\tstruct btmtkuart_dev *bdev = serdev_device_get_drvdata(serdev);\n\n\tbtmtkuart_recv(bdev->hdev, data, count);\n\n\tbdev->hdev->stat.byte_rx += count;\n\n\treturn count;\n}\n\nstatic void btmtkuart_write_wakeup(struct serdev_device *serdev)\n{\n\tstruct btmtkuart_dev *bdev = serdev_device_get_drvdata(serdev);\n\n\tbtmtkuart_tx_wakeup(bdev);\n}\n\nstatic const struct serdev_device_ops btmtkuart_client_ops = {\n\t.receive_buf = btmtkuart_receive_buf,\n\t.write_wakeup = btmtkuart_write_wakeup,\n};\n\nstatic int btmtkuart_open(struct hci_dev *hdev)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct device *dev;\n\tint err;\n\n\terr = serdev_device_open(bdev->serdev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to open UART device %s\",\n\t\t\t   dev_name(&bdev->serdev->dev));\n\t\tgoto err_open;\n\t}\n\n\tif (btmtkuart_is_standalone(bdev)) {\n\t\tif (bdev->curr_speed != bdev->desired_speed)\n\t\t\terr = serdev_device_set_baudrate(bdev->serdev,\n\t\t\t\t\t\t\t 115200);\n\t\telse\n\t\t\terr = serdev_device_set_baudrate(bdev->serdev,\n\t\t\t\t\t\t\t bdev->desired_speed);\n\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Unable to set baudrate UART device %s\",\n\t\t\t\t   dev_name(&bdev->serdev->dev));\n\t\t\tgoto  err_serdev_close;\n\t\t}\n\n\t\tserdev_device_set_flow_control(bdev->serdev, false);\n\t}\n\n\tbdev->stp_cursor = 2;\n\tbdev->stp_dlen = 0;\n\n\tdev = &bdev->serdev->dev;\n\n\t \n\tpm_runtime_enable(dev);\n\terr = pm_runtime_resume_and_get(dev);\n\tif (err < 0)\n\t\tgoto err_disable_rpm;\n\n\terr = clk_prepare_enable(bdev->clk);\n\tif (err < 0)\n\t\tgoto err_put_rpm;\n\n\treturn 0;\n\nerr_put_rpm:\n\tpm_runtime_put_sync(dev);\nerr_disable_rpm:\n\tpm_runtime_disable(dev);\nerr_serdev_close:\n\tserdev_device_close(bdev->serdev);\nerr_open:\n\treturn err;\n}\n\nstatic int btmtkuart_close(struct hci_dev *hdev)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct device *dev = &bdev->serdev->dev;\n\n\t \n\tclk_disable_unprepare(bdev->clk);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\tserdev_device_close(bdev->serdev);\n\n\treturn 0;\n}\n\nstatic int btmtkuart_flush(struct hci_dev *hdev)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\n\t \n\tserdev_device_write_flush(bdev->serdev);\n\tskb_queue_purge(&bdev->txq);\n\n\tcancel_work_sync(&bdev->tx_work);\n\n\tkfree_skb(bdev->rx_skb);\n\tbdev->rx_skb = NULL;\n\n\tbdev->stp_cursor = 2;\n\tbdev->stp_dlen = 0;\n\n\treturn 0;\n}\n\nstatic int btmtkuart_func_query(struct hci_dev *hdev)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tint status, err;\n\tu8 param = 0;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 4;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query function status (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn status;\n}\n\nstatic int btmtkuart_change_baudrate(struct hci_dev *hdev)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\t__le32 baudrate;\n\tu8 param;\n\tint err;\n\n\t \n\tbaudrate = cpu_to_le32(bdev->desired_speed);\n\twmt_params.op = BTMTK_WMT_HIF;\n\twmt_params.flag = 1;\n\twmt_params.dlen = 4;\n\twmt_params.data = &baudrate;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to device baudrate (%d)\", err);\n\t\treturn err;\n\t}\n\n\terr = serdev_device_set_baudrate(bdev->serdev,\n\t\t\t\t\t bdev->desired_speed);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to set up host baudrate (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tserdev_device_set_flow_control(bdev->serdev, false);\n\n\t \n\tparam = 0xff;\n\terr = serdev_device_write_buf(bdev->serdev, &param, sizeof(param));\n\tif (err < 0 || err < sizeof(param))\n\t\treturn err;\n\n\tserdev_device_wait_until_sent(bdev->serdev, 0);\n\n\t \n\tusleep_range(20000, 22000);\n\n\t \n\twmt_params.op = BTMTK_WMT_TEST;\n\twmt_params.flag = 7;\n\twmt_params.dlen = 0;\n\twmt_params.data = NULL;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to test new baudrate (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tbdev->curr_speed = bdev->desired_speed;\n\n\treturn 0;\n}\n\nstatic int btmtkuart_setup(struct hci_dev *hdev)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tktime_t calltime, delta, rettime;\n\tstruct btmtk_tci_sleep tci_sleep;\n\tunsigned long long duration;\n\tstruct sk_buff *skb;\n\tint err, status;\n\tu8 param = 0x1;\n\n\tcalltime = ktime_get();\n\n\t \n\tif (test_bit(BTMTKUART_REQUIRED_WAKEUP, &bdev->tx_state)) {\n\t\twmt_params.op = BTMTK_WMT_WAKEUP;\n\t\twmt_params.flag = 3;\n\t\twmt_params.dlen = 0;\n\t\twmt_params.data = NULL;\n\t\twmt_params.status = NULL;\n\n\t\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Failed to wakeup the chip (%d)\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\tclear_bit(BTMTKUART_REQUIRED_WAKEUP, &bdev->tx_state);\n\t}\n\n\tif (btmtkuart_is_standalone(bdev))\n\t\tbtmtkuart_change_baudrate(hdev);\n\n\t \n\twmt_params.op = BTMTK_WMT_SEMAPHORE;\n\twmt_params.flag = 1;\n\twmt_params.dlen = 0;\n\twmt_params.data = NULL;\n\twmt_params.status = &status;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to query firmware status (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (status == BTMTK_WMT_PATCH_DONE) {\n\t\tbt_dev_info(hdev, \"Firmware already downloaded\");\n\t\tgoto ignore_setup_fw;\n\t}\n\n\t \n\terr = btmtk_setup_firmware(hdev, bdev->data->fwname, mtk_hci_wmt_sync);\n\tif (err < 0)\n\t\treturn err;\n\nignore_setup_fw:\n\t \n\terr = readx_poll_timeout(btmtkuart_func_query, hdev, status,\n\t\t\t\t status < 0 || status != BTMTK_WMT_ON_PROGRESS,\n\t\t\t\t 2000, 5000000);\n\t \n\tif (err < 0)\n\t\treturn err;\n\n\t \n\tif (status < 0)\n\t\treturn status;\n\n\tif (status == BTMTK_WMT_ON_DONE) {\n\t\tbt_dev_info(hdev, \"function already on\");\n\t\tgoto ignore_func_on;\n\t}\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\nignore_func_on:\n\t \n\ttci_sleep.mode = 0x5;\n\ttci_sleep.duration = cpu_to_le16(0x640);\n\ttci_sleep.host_duration = cpu_to_le16(0x640);\n\ttci_sleep.host_wakeup_pin = 0;\n\ttci_sleep.time_compensation = 0;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc7a, sizeof(tci_sleep), &tci_sleep,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Failed to apply low power setting (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long)ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Device setup in %llu usecs\", duration);\n\n\treturn 0;\n}\n\nstatic int btmtkuart_shutdown(struct hci_dev *hdev)\n{\n\tstruct btmtk_hci_wmt_params wmt_params;\n\tu8 param = 0x0;\n\tint err;\n\n\t \n\twmt_params.op = BTMTK_WMT_FUNC_CTRL;\n\twmt_params.flag = 0;\n\twmt_params.dlen = sizeof(param);\n\twmt_params.data = &param;\n\twmt_params.status = NULL;\n\n\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int btmtkuart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btmtkuart_dev *bdev = hci_get_drvdata(hdev);\n\tstruct mtk_stp_hdr *shdr;\n\tint err, dlen, type = 0;\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\t \n\tif (unlikely(skb_headroom(skb) < sizeof(*shdr)) ||\n\t    (skb_tailroom(skb) < MTK_STP_TLR_SIZE)) {\n\t\terr = pskb_expand_head(skb, sizeof(*shdr), MTK_STP_TLR_SIZE,\n\t\t\t\t       GFP_ATOMIC);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t \n\tdlen = skb->len;\n\tshdr = skb_push(skb, sizeof(*shdr));\n\tshdr->prefix = 0x80;\n\tshdr->dlen = cpu_to_be16((dlen & 0x0fff) | (type << 12));\n\tshdr->cs = 0;\t\t \n\n\t \n\tskb_put_zero(skb, MTK_STP_TLR_SIZE);\n\n\tskb_queue_tail(&bdev->txq, skb);\n\n\tbtmtkuart_tx_wakeup(bdev);\n\treturn 0;\n}\n\nstatic int btmtkuart_parse_dt(struct serdev_device *serdev)\n{\n\tstruct btmtkuart_dev *bdev = serdev_device_get_drvdata(serdev);\n\tstruct device_node *node = serdev->dev.of_node;\n\tu32 speed = 921600;\n\tint err;\n\n\tif (btmtkuart_is_standalone(bdev)) {\n\t\tof_property_read_u32(node, \"current-speed\", &speed);\n\n\t\tbdev->desired_speed = speed;\n\n\t\tbdev->vcc = devm_regulator_get(&serdev->dev, \"vcc\");\n\t\tif (IS_ERR(bdev->vcc)) {\n\t\t\terr = PTR_ERR(bdev->vcc);\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->osc = devm_clk_get_optional(&serdev->dev, \"osc\");\n\t\tif (IS_ERR(bdev->osc)) {\n\t\t\terr = PTR_ERR(bdev->osc);\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->boot = devm_gpiod_get_optional(&serdev->dev, \"boot\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\t\tif (IS_ERR(bdev->boot)) {\n\t\t\terr = PTR_ERR(bdev->boot);\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->pinctrl = devm_pinctrl_get(&serdev->dev);\n\t\tif (IS_ERR(bdev->pinctrl)) {\n\t\t\terr = PTR_ERR(bdev->pinctrl);\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->pins_boot = pinctrl_lookup_state(bdev->pinctrl,\n\t\t\t\t\t\t       \"default\");\n\t\tif (IS_ERR(bdev->pins_boot) && !bdev->boot) {\n\t\t\terr = PTR_ERR(bdev->pins_boot);\n\t\t\tdev_err(&serdev->dev,\n\t\t\t\t\"Should assign RXD to LOW at boot stage\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->pins_runtime = pinctrl_lookup_state(bdev->pinctrl,\n\t\t\t\t\t\t\t  \"runtime\");\n\t\tif (IS_ERR(bdev->pins_runtime)) {\n\t\t\terr = PTR_ERR(bdev->pins_runtime);\n\t\t\treturn err;\n\t\t}\n\n\t\tbdev->reset = devm_gpiod_get_optional(&serdev->dev, \"reset\",\n\t\t\t\t\t\t      GPIOD_OUT_LOW);\n\t\tif (IS_ERR(bdev->reset)) {\n\t\t\terr = PTR_ERR(bdev->reset);\n\t\t\treturn err;\n\t\t}\n\t} else if (btmtkuart_is_builtin_soc(bdev)) {\n\t\tbdev->clk = devm_clk_get(&serdev->dev, \"ref\");\n\t\tif (IS_ERR(bdev->clk))\n\t\t\treturn PTR_ERR(bdev->clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int btmtkuart_probe(struct serdev_device *serdev)\n{\n\tstruct btmtkuart_dev *bdev;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tbdev = devm_kzalloc(&serdev->dev, sizeof(*bdev), GFP_KERNEL);\n\tif (!bdev)\n\t\treturn -ENOMEM;\n\n\tbdev->data = of_device_get_match_data(&serdev->dev);\n\tif (!bdev->data)\n\t\treturn -ENODEV;\n\n\tbdev->serdev = serdev;\n\tserdev_device_set_drvdata(serdev, bdev);\n\n\tserdev_device_set_client_ops(serdev, &btmtkuart_client_ops);\n\n\terr = btmtkuart_parse_dt(serdev);\n\tif (err < 0)\n\t\treturn err;\n\n\tINIT_WORK(&bdev->tx_work, btmtkuart_tx_work);\n\tskb_queue_head_init(&bdev->txq);\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tdev_err(&serdev->dev, \"Can't allocate HCI device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tbdev->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, bdev);\n\n\thdev->open     = btmtkuart_open;\n\thdev->close    = btmtkuart_close;\n\thdev->flush    = btmtkuart_flush;\n\thdev->setup    = btmtkuart_setup;\n\thdev->shutdown = btmtkuart_shutdown;\n\thdev->send     = btmtkuart_send_frame;\n\thdev->set_bdaddr = btmtk_set_bdaddr;\n\tSET_HCIDEV_DEV(hdev, &serdev->dev);\n\n\thdev->manufacturer = 70;\n\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\n\tif (btmtkuart_is_standalone(bdev)) {\n\t\terr = clk_prepare_enable(bdev->osc);\n\t\tif (err < 0)\n\t\t\tgoto err_hci_free_dev;\n\n\t\tif (bdev->boot) {\n\t\t\tgpiod_set_value_cansleep(bdev->boot, 1);\n\t\t} else {\n\t\t\t \n\t\t\tpinctrl_select_state(bdev->pinctrl, bdev->pins_boot);\n\t\t}\n\n\t\t \n\t\terr = regulator_enable(bdev->vcc);\n\t\tif (err < 0)\n\t\t\tgoto err_clk_disable_unprepare;\n\n\t\t \n\t\tif (bdev->reset) {\n\t\t\tgpiod_set_value_cansleep(bdev->reset, 1);\n\t\t\tusleep_range(1000, 2000);\n\t\t\tgpiod_set_value_cansleep(bdev->reset, 0);\n\t\t}\n\n\t\t \n\t\tmsleep(50);\n\n\t\tif (bdev->boot)\n\t\t\tdevm_gpiod_put(&serdev->dev, bdev->boot);\n\n\t\tpinctrl_select_state(bdev->pinctrl, bdev->pins_runtime);\n\n\t\t \n\t\tpm_runtime_no_callbacks(&serdev->dev);\n\n\t\tset_bit(BTMTKUART_REQUIRED_WAKEUP, &bdev->tx_state);\n\t}\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\tdev_err(&serdev->dev, \"Can't register HCI device\\n\");\n\t\tgoto err_regulator_disable;\n\t}\n\n\treturn 0;\n\nerr_regulator_disable:\n\tif (btmtkuart_is_standalone(bdev))\n\t\tregulator_disable(bdev->vcc);\nerr_clk_disable_unprepare:\n\tif (btmtkuart_is_standalone(bdev))\n\t\tclk_disable_unprepare(bdev->osc);\nerr_hci_free_dev:\n\thci_free_dev(hdev);\n\n\treturn err;\n}\n\nstatic void btmtkuart_remove(struct serdev_device *serdev)\n{\n\tstruct btmtkuart_dev *bdev = serdev_device_get_drvdata(serdev);\n\tstruct hci_dev *hdev = bdev->hdev;\n\n\tif (btmtkuart_is_standalone(bdev)) {\n\t\tregulator_disable(bdev->vcc);\n\t\tclk_disable_unprepare(bdev->osc);\n\t}\n\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n}\n\nstatic const struct btmtkuart_data mt7622_data __maybe_unused = {\n\t.fwname = FIRMWARE_MT7622,\n};\n\nstatic const struct btmtkuart_data mt7663_data __maybe_unused = {\n\t.flags = BTMTKUART_FLAG_STANDALONE_HW,\n\t.fwname = FIRMWARE_MT7663,\n};\n\nstatic const struct btmtkuart_data mt7668_data __maybe_unused = {\n\t.flags = BTMTKUART_FLAG_STANDALONE_HW,\n\t.fwname = FIRMWARE_MT7668,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id mtk_of_match_table[] = {\n\t{ .compatible = \"mediatek,mt7622-bluetooth\", .data = &mt7622_data},\n\t{ .compatible = \"mediatek,mt7663u-bluetooth\", .data = &mt7663_data},\n\t{ .compatible = \"mediatek,mt7668u-bluetooth\", .data = &mt7668_data},\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, mtk_of_match_table);\n#endif\n\nstatic struct serdev_device_driver btmtkuart_driver = {\n\t.probe = btmtkuart_probe,\n\t.remove = btmtkuart_remove,\n\t.driver = {\n\t\t.name = \"btmtkuart\",\n\t\t.of_match_table = of_match_ptr(mtk_of_match_table),\n\t},\n};\n\nmodule_serdev_device_driver(btmtkuart_driver);\n\nMODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek Bluetooth Serial driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}