{
  "module_name": "hci_ath.c",
  "hash_id": "3c266ff4cb4a4e9f05d6926cf5d38e3e943ba899cc5b40f4cec52a631f9c7519",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_ath.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n\nstruct ath_struct {\n\tstruct hci_uart *hu;\n\tunsigned int cur_sleep;\n\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct work_struct ctxtsw;\n};\n\n#define OP_WRITE_TAG\t0x01\n\n#define INDEX_BDADDR\t0x01\n\nstruct ath_vendor_cmd {\n\t__u8 opcode;\n\t__le16 index;\n\t__u8 len;\n\t__u8 data[251];\n} __packed;\n\nstatic int ath_wakeup_ar3k(struct tty_struct *tty)\n{\n\tint status = tty->driver->ops->tiocmget(tty);\n\n\tif (status & TIOCM_CTS)\n\t\treturn status;\n\n\t \n\ttty->driver->ops->tiocmget(tty);\n\ttty->driver->ops->tiocmset(tty, 0x00, TIOCM_RTS);\n\tmsleep(20);\n\n\t \n\ttty->driver->ops->tiocmget(tty);\n\ttty->driver->ops->tiocmset(tty, TIOCM_RTS, 0x00);\n\tmsleep(20);\n\n\tstatus = tty->driver->ops->tiocmget(tty);\n\treturn status;\n}\n\nstatic void ath_hci_uart_work(struct work_struct *work)\n{\n\tint status;\n\tstruct ath_struct *ath;\n\tstruct hci_uart *hu;\n\tstruct tty_struct *tty;\n\n\tath = container_of(work, struct ath_struct, ctxtsw);\n\n\thu = ath->hu;\n\ttty = hu->tty;\n\n\t \n\tif (ath->cur_sleep) {\n\t\tstatus = ath_wakeup_ar3k(tty);\n\t\tif (!(status & TIOCM_CTS))\n\t\t\treturn;\n\t}\n\n\t \n\tclear_bit(HCI_UART_SENDING, &hu->tx_state);\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic int ath_open(struct hci_uart *hu)\n{\n\tstruct ath_struct *ath;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tath = kzalloc(sizeof(*ath), GFP_KERNEL);\n\tif (!ath)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&ath->txq);\n\n\thu->priv = ath;\n\tath->hu = hu;\n\n\tINIT_WORK(&ath->ctxtsw, ath_hci_uart_work);\n\n\treturn 0;\n}\n\nstatic int ath_close(struct hci_uart *hu)\n{\n\tstruct ath_struct *ath = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ath->txq);\n\n\tkfree_skb(ath->rx_skb);\n\n\tcancel_work_sync(&ath->ctxtsw);\n\n\thu->priv = NULL;\n\tkfree(ath);\n\n\treturn 0;\n}\n\nstatic int ath_flush(struct hci_uart *hu)\n{\n\tstruct ath_struct *ath = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ath->txq);\n\n\treturn 0;\n}\n\nstatic int ath_vendor_cmd(struct hci_dev *hdev, uint8_t opcode, uint16_t index,\n\t\t\t  const void *data, size_t dlen)\n{\n\tstruct sk_buff *skb;\n\tstruct ath_vendor_cmd cmd;\n\n\tif (dlen > sizeof(cmd.data))\n\t\treturn -EINVAL;\n\n\tcmd.opcode = opcode;\n\tcmd.index = cpu_to_le16(index);\n\tcmd.len = dlen;\n\tmemcpy(cmd.data, data, dlen);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc0b, dlen + 4, &cmd, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int ath_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\treturn ath_vendor_cmd(hdev, OP_WRITE_TAG, INDEX_BDADDR, bdaddr,\n\t\t\t      sizeof(*bdaddr));\n}\n\nstatic int ath_setup(struct hci_uart *hu)\n{\n\tBT_DBG(\"hu %p\", hu);\n\n\thu->hdev->set_bdaddr = ath_set_bdaddr;\n\n\treturn 0;\n}\n\nstatic const struct h4_recv_pkt ath_recv_pkts[] = {\n\t{ H4_RECV_ACL,   .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,   .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT, .recv = hci_recv_frame },\n};\n\nstatic int ath_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct ath_struct *ath = hu->priv;\n\n\tath->rx_skb = h4_recv_buf(hu->hdev, ath->rx_skb, data, count,\n\t\t\t\t  ath_recv_pkts, ARRAY_SIZE(ath_recv_pkts));\n\tif (IS_ERR(ath->rx_skb)) {\n\t\tint err = PTR_ERR(ath->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tath->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\n#define HCI_OP_ATH_SLEEP 0xFC04\n\nstatic int ath_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct ath_struct *ath = hu->priv;\n\n\tif (hci_skb_pkt_type(skb) == HCI_SCODATA_PKT) {\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\t \n\tif (hci_skb_pkt_type(skb) == HCI_COMMAND_PKT) {\n\t\tstruct hci_command_hdr *hdr = (void *)skb->data;\n\n\t\tif (__le16_to_cpu(hdr->opcode) == HCI_OP_ATH_SLEEP)\n\t\t\tath->cur_sleep = skb->data[HCI_COMMAND_HDR_SIZE];\n\t}\n\n\tBT_DBG(\"hu %p skb %p\", hu, skb);\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tskb_queue_tail(&ath->txq, skb);\n\tset_bit(HCI_UART_SENDING, &hu->tx_state);\n\n\tschedule_work(&ath->ctxtsw);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *ath_dequeue(struct hci_uart *hu)\n{\n\tstruct ath_struct *ath = hu->priv;\n\n\treturn skb_dequeue(&ath->txq);\n}\n\nstatic const struct hci_uart_proto athp = {\n\t.id\t\t= HCI_UART_ATH3K,\n\t.name\t\t= \"ATH3K\",\n\t.manufacturer\t= 69,\n\t.open\t\t= ath_open,\n\t.close\t\t= ath_close,\n\t.flush\t\t= ath_flush,\n\t.setup\t\t= ath_setup,\n\t.recv\t\t= ath_recv,\n\t.enqueue\t= ath_enqueue,\n\t.dequeue\t= ath_dequeue,\n};\n\nint __init ath_init(void)\n{\n\treturn hci_uart_register_proto(&athp);\n}\n\nint __exit ath_deinit(void)\n{\n\treturn hci_uart_unregister_proto(&athp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}