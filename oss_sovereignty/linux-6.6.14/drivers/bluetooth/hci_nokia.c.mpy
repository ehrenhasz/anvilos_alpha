{
  "module_name": "hci_nokia.c",
  "hash_id": "a906d4170ec806a18dc585eb48ac335c7a2a54d44a7e0ef2abe55a55618be5de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_nokia.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <asm/unaligned.h>\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n#include \"btbcm.h\"\n\n#define VERSION \"0.1\"\n\n#define NOKIA_ID_BCM2048\t0x04\n#define NOKIA_ID_TI1271\t\t0x31\n\n#define FIRMWARE_BCM2048\t\"nokia/bcmfw.bin\"\n#define FIRMWARE_TI1271\t\t\"nokia/ti1273.bin\"\n\n#define HCI_NOKIA_NEG_PKT\t0x06\n#define HCI_NOKIA_ALIVE_PKT\t0x07\n#define HCI_NOKIA_RADIO_PKT\t0x08\n\n#define HCI_NOKIA_NEG_HDR_SIZE\t\t1\n#define HCI_NOKIA_MAX_NEG_SIZE\t\t255\n#define HCI_NOKIA_ALIVE_HDR_SIZE\t1\n#define HCI_NOKIA_MAX_ALIVE_SIZE\t255\n#define HCI_NOKIA_RADIO_HDR_SIZE\t2\n#define HCI_NOKIA_MAX_RADIO_SIZE\t255\n\n#define NOKIA_PROTO_PKT\t\t0x44\n#define NOKIA_PROTO_BYTE\t0x4c\n\n#define NOKIA_NEG_REQ\t\t0x00\n#define NOKIA_NEG_ACK\t\t0x20\n#define NOKIA_NEG_NAK\t\t0x40\n\n#define H4_TYPE_SIZE\t\t1\n\n#define NOKIA_RECV_ALIVE \\\n\t.type = HCI_NOKIA_ALIVE_PKT, \\\n\t.hlen = HCI_NOKIA_ALIVE_HDR_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_NOKIA_MAX_ALIVE_SIZE \\\n\n#define NOKIA_RECV_NEG \\\n\t.type = HCI_NOKIA_NEG_PKT, \\\n\t.hlen = HCI_NOKIA_NEG_HDR_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_NOKIA_MAX_NEG_SIZE \\\n\n#define NOKIA_RECV_RADIO \\\n\t.type = HCI_NOKIA_RADIO_PKT, \\\n\t.hlen = HCI_NOKIA_RADIO_HDR_SIZE, \\\n\t.loff = 1, \\\n\t.lsize = 1, \\\n\t.maxlen = HCI_NOKIA_MAX_RADIO_SIZE \\\n\nstruct hci_nokia_neg_hdr {\n\tu8\tdlen;\n} __packed;\n\nstruct hci_nokia_neg_cmd {\n\tu8\tack;\n\tu16\tbaud;\n\tu16\tunused1;\n\tu8\tproto;\n\tu16\tsys_clk;\n\tu16\tunused2;\n} __packed;\n\n#define NOKIA_ALIVE_REQ   0x55\n#define NOKIA_ALIVE_RESP  0xcc\n\nstruct hci_nokia_alive_hdr {\n\tu8\tdlen;\n} __packed;\n\nstruct hci_nokia_alive_pkt {\n\tu8\tmid;\n\tu8\tunused;\n} __packed;\n\nstruct hci_nokia_neg_evt {\n\tu8\tack;\n\tu16\tbaud;\n\tu16\tunused1;\n\tu8\tproto;\n\tu16\tsys_clk;\n\tu16\tunused2;\n\tu8\tman_id;\n\tu8\tver_id;\n} __packed;\n\n#define MAX_BAUD_RATE\t\t3692300\n#define SETUP_BAUD_RATE\t\t921600\n#define INIT_BAUD_RATE\t\t120000\n\nstruct hci_nokia_radio_hdr {\n\tu8\tevt;\n\tu8\tdlen;\n} __packed;\n\nstruct nokia_bt_dev {\n\tstruct hci_uart hu;\n\tstruct serdev_device *serdev;\n\n\tstruct gpio_desc *reset;\n\tstruct gpio_desc *wakeup_host;\n\tstruct gpio_desc *wakeup_bt;\n\tunsigned long sysclk_speed;\n\n\tint wake_irq;\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tbdaddr_t bdaddr;\n\n\tint init_error;\n\tstruct completion init_completion;\n\n\tu8 man_id;\n\tu8 ver_id;\n\n\tbool initialized;\n\tbool tx_enabled;\n\tbool rx_enabled;\n};\n\nstatic int nokia_enqueue(struct hci_uart *hu, struct sk_buff *skb);\n\nstatic void nokia_flow_control(struct serdev_device *serdev, bool enable)\n{\n\tif (enable) {\n\t\tserdev_device_set_rts(serdev, true);\n\t\tserdev_device_set_flow_control(serdev, true);\n\t} else {\n\t\tserdev_device_set_flow_control(serdev, false);\n\t\tserdev_device_set_rts(serdev, false);\n\t}\n}\n\nstatic irqreturn_t wakeup_handler(int irq, void *data)\n{\n\tstruct nokia_bt_dev *btdev = data;\n\tstruct device *dev = &btdev->serdev->dev;\n\tint wake_state = gpiod_get_value(btdev->wakeup_host);\n\n\tif (btdev->rx_enabled == wake_state)\n\t\treturn IRQ_HANDLED;\n\n\tif (wake_state)\n\t\tpm_runtime_get(dev);\n\telse\n\t\tpm_runtime_put(dev);\n\n\tbtdev->rx_enabled = wake_state;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int nokia_reset(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tint err;\n\n\t \n\tgpiod_set_value_cansleep(btdev->reset, 1);\n\tgpiod_set_value_cansleep(btdev->wakeup_bt, 1);\n\n\tmsleep(100);\n\n\t \n\terr = gpiod_get_value_cansleep(btdev->wakeup_host);\n\tif (err == 1) {\n\t\tdev_err(dev, \"reset: host wakeup not low!\");\n\t\treturn -EPROTO;\n\t}\n\n\t \n\tserdev_device_write_flush(btdev->serdev);\n\n\t \n\tnokia_flow_control(btdev->serdev, false);\n\tserdev_device_set_baudrate(btdev->serdev, INIT_BAUD_RATE);\n\n\tgpiod_set_value_cansleep(btdev->reset, 0);\n\n\t \n\terr = serdev_device_wait_for_cts(btdev->serdev, true, 200);\n\tif (err < 0) {\n\t\tdev_err(dev, \"CTS not received: %d\", err);\n\t\treturn err;\n\t}\n\n\tnokia_flow_control(btdev->serdev, true);\n\n\treturn 0;\n}\n\nstatic int nokia_send_alive_packet(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tstruct hci_nokia_alive_hdr *hdr;\n\tstruct hci_nokia_alive_pkt *pkt;\n\tstruct sk_buff *skb;\n\tint len;\n\n\tinit_completion(&btdev->init_completion);\n\n\tlen = H4_TYPE_SIZE + sizeof(*hdr) + sizeof(*pkt);\n\tskb = bt_skb_alloc(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thci_skb_pkt_type(skb) = HCI_NOKIA_ALIVE_PKT;\n\tmemset(skb->data, 0x00, len);\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->dlen = sizeof(*pkt);\n\tpkt = skb_put(skb, sizeof(*pkt));\n\tpkt->mid = NOKIA_ALIVE_REQ;\n\n\tnokia_enqueue(hu, skb);\n\thci_uart_tx_wakeup(hu);\n\n\tdev_dbg(dev, \"Alive sent\");\n\n\tif (!wait_for_completion_interruptible_timeout(&btdev->init_completion,\n\t\tmsecs_to_jiffies(1000))) {\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (btdev->init_error < 0)\n\t\treturn btdev->init_error;\n\n\treturn 0;\n}\n\nstatic int nokia_send_negotiation(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tstruct hci_nokia_neg_cmd *neg_cmd;\n\tstruct hci_nokia_neg_hdr *neg_hdr;\n\tstruct sk_buff *skb;\n\tint len, err;\n\tu16 baud = DIV_ROUND_CLOSEST(btdev->sysclk_speed * 10, SETUP_BAUD_RATE);\n\tint sysclk = btdev->sysclk_speed / 1000;\n\n\tlen = H4_TYPE_SIZE + sizeof(*neg_hdr) + sizeof(*neg_cmd);\n\tskb = bt_skb_alloc(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thci_skb_pkt_type(skb) = HCI_NOKIA_NEG_PKT;\n\n\tneg_hdr = skb_put(skb, sizeof(*neg_hdr));\n\tneg_hdr->dlen = sizeof(*neg_cmd);\n\n\tneg_cmd = skb_put(skb, sizeof(*neg_cmd));\n\tneg_cmd->ack = NOKIA_NEG_REQ;\n\tneg_cmd->baud = cpu_to_le16(baud);\n\tneg_cmd->unused1 = 0x0000;\n\tneg_cmd->proto = NOKIA_PROTO_BYTE;\n\tneg_cmd->sys_clk = cpu_to_le16(sysclk);\n\tneg_cmd->unused2 = 0x0000;\n\n\tbtdev->init_error = 0;\n\tinit_completion(&btdev->init_completion);\n\n\tnokia_enqueue(hu, skb);\n\thci_uart_tx_wakeup(hu);\n\n\tdev_dbg(dev, \"Negotiation sent\");\n\n\tif (!wait_for_completion_interruptible_timeout(&btdev->init_completion,\n\t\tmsecs_to_jiffies(10000))) {\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (btdev->init_error < 0)\n\t\treturn btdev->init_error;\n\n\t \n\tnokia_flow_control(btdev->serdev, false);\n\tserdev_device_set_baudrate(btdev->serdev, SETUP_BAUD_RATE);\n\terr = serdev_device_wait_for_cts(btdev->serdev, true, 200);\n\tif (err < 0) {\n\t\tdev_err(dev, \"CTS not received: %d\", err);\n\t\treturn err;\n\t}\n\tnokia_flow_control(btdev->serdev, true);\n\n\tdev_dbg(dev, \"Negotiation successful\");\n\n\treturn 0;\n}\n\nstatic int nokia_setup_fw(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tconst char *fwname;\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tsize_t fw_size;\n\tint err;\n\n\tdev_dbg(dev, \"setup firmware\");\n\n\tif (btdev->man_id == NOKIA_ID_BCM2048) {\n\t\tfwname = FIRMWARE_BCM2048;\n\t} else if (btdev->man_id == NOKIA_ID_TI1271) {\n\t\tfwname = FIRMWARE_TI1271;\n\t} else {\n\t\tdev_err(dev, \"Unsupported bluetooth device!\");\n\t\treturn -ENODEV;\n\t}\n\n\terr = request_firmware(&fw, fwname, dev);\n\tif (err < 0) {\n\t\tdev_err(dev, \"%s: Failed to load Nokia firmware file (%d)\",\n\t\t\thu->hdev->name, err);\n\t\treturn err;\n\t}\n\n\tfw_ptr = fw->data;\n\tfw_size = fw->size;\n\n\twhile (fw_size >= 4) {\n\t\tu16 pkt_size = get_unaligned_le16(fw_ptr);\n\t\tu8 pkt_type = fw_ptr[2];\n\t\tconst struct hci_command_hdr *cmd;\n\t\tu16 opcode;\n\t\tstruct sk_buff *skb;\n\n\t\tswitch (pkt_type) {\n\t\tcase HCI_COMMAND_PKT:\n\t\t\tcmd = (struct hci_command_hdr *)(fw_ptr + 3);\n\t\t\topcode = le16_to_cpu(cmd->opcode);\n\n\t\t\tskb = __hci_cmd_sync(hu->hdev, opcode, cmd->plen,\n\t\t\t\t\t     fw_ptr + 3 + HCI_COMMAND_HDR_SIZE,\n\t\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\t\tif (IS_ERR(skb)) {\n\t\t\t\terr = PTR_ERR(skb);\n\t\t\t\tdev_err(dev, \"%s: FW command %04x failed (%d)\",\n\t\t\t\t       hu->hdev->name, opcode, err);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\tcase HCI_NOKIA_RADIO_PKT:\n\t\tcase HCI_NOKIA_NEG_PKT:\n\t\tcase HCI_NOKIA_ALIVE_PKT:\n\t\t\tbreak;\n\t\t}\n\n\t\tfw_ptr += pkt_size + 2;\n\t\tfw_size -= pkt_size + 2;\n\t}\n\ndone:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int nokia_setup(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tint err;\n\n\tbtdev->initialized = false;\n\n\tnokia_flow_control(btdev->serdev, false);\n\n\tpm_runtime_get_sync(dev);\n\n\tif (btdev->tx_enabled) {\n\t\tgpiod_set_value_cansleep(btdev->wakeup_bt, 0);\n\t\tpm_runtime_put(&btdev->serdev->dev);\n\t\tbtdev->tx_enabled = false;\n\t}\n\n\tdev_dbg(dev, \"protocol setup\");\n\n\t \n\terr = nokia_reset(hu);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Reset failed: %d\", err);\n\t\tgoto out;\n\t}\n\n\t \n\terr = nokia_send_negotiation(hu);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Negotiation failed: %d\", err);\n\t\tgoto out;\n\t}\n\n\t \n\terr = nokia_send_alive_packet(hu);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Alive check failed: %d\", err);\n\t\tgoto out;\n\t}\n\n\t \n\terr = nokia_setup_fw(hu);\n\tif (err < 0) {\n\t\tdev_err(dev, \"Could not setup FW: %d\", err);\n\t\tgoto out;\n\t}\n\n\tnokia_flow_control(btdev->serdev, false);\n\tserdev_device_set_baudrate(btdev->serdev, MAX_BAUD_RATE);\n\tnokia_flow_control(btdev->serdev, true);\n\n\tif (btdev->man_id == NOKIA_ID_BCM2048) {\n\t\thu->hdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hu->hdev->quirks);\n\t\tdev_dbg(dev, \"bcm2048 has invalid bluetooth address!\");\n\t}\n\n\tdev_dbg(dev, \"protocol setup done!\");\n\n\tgpiod_set_value_cansleep(btdev->wakeup_bt, 0);\n\tpm_runtime_put(dev);\n\tbtdev->tx_enabled = false;\n\tbtdev->initialized = true;\n\n\treturn 0;\nout:\n\tpm_runtime_put(dev);\n\n\treturn err;\n}\n\nstatic int nokia_open(struct hci_uart *hu)\n{\n\tstruct device *dev = &hu->serdev->dev;\n\n\tdev_dbg(dev, \"protocol open\");\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int nokia_flush(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\n\tdev_dbg(&btdev->serdev->dev, \"flush device\");\n\n\tskb_queue_purge(&btdev->txq);\n\n\treturn 0;\n}\n\nstatic int nokia_close(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\n\tdev_dbg(dev, \"close device\");\n\n\tbtdev->initialized = false;\n\n\tskb_queue_purge(&btdev->txq);\n\n\tkfree_skb(btdev->rx_skb);\n\n\t \n\tgpiod_set_value(btdev->reset, 1);\n\tgpiod_set_value(btdev->wakeup_bt, 0);\n\n\tpm_runtime_disable(&btdev->serdev->dev);\n\n\treturn 0;\n}\n\n \nstatic int nokia_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tint err;\n\n\t \n\tmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\n\n\t \n\tif (skb->len % 2) {\n\t\terr = skb_pad(skb, 1);\n\t\tif (err)\n\t\t\treturn err;\n\t\tskb_put(skb, 1);\n\t}\n\n\tskb_queue_tail(&btdev->txq, skb);\n\n\treturn 0;\n}\n\nstatic int nokia_recv_negotiation_packet(struct hci_dev *hdev,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tstruct hci_nokia_neg_hdr *hdr;\n\tstruct hci_nokia_neg_evt *evt;\n\tint ret = 0;\n\n\thdr = (struct hci_nokia_neg_hdr *)skb->data;\n\tif (hdr->dlen != sizeof(*evt)) {\n\t\tbtdev->init_error = -EIO;\n\t\tret = -EIO;\n\t\tgoto finish_neg;\n\t}\n\n\tevt = skb_pull(skb, sizeof(*hdr));\n\n\tif (evt->ack != NOKIA_NEG_ACK) {\n\t\tdev_err(dev, \"Negotiation received: wrong reply\");\n\t\tbtdev->init_error = -EINVAL;\n\t\tret = -EINVAL;\n\t\tgoto finish_neg;\n\t}\n\n\tbtdev->man_id = evt->man_id;\n\tbtdev->ver_id = evt->ver_id;\n\n\tdev_dbg(dev, \"Negotiation received: baud=%u:clk=%u:manu=%u:vers=%u\",\n\t\tevt->baud, evt->sys_clk, evt->man_id, evt->ver_id);\n\nfinish_neg:\n\tcomplete(&btdev->init_completion);\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int nokia_recv_alive_packet(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tstruct hci_nokia_alive_hdr *hdr;\n\tstruct hci_nokia_alive_pkt *pkt;\n\tint ret = 0;\n\n\thdr = (struct hci_nokia_alive_hdr *)skb->data;\n\tif (hdr->dlen != sizeof(*pkt)) {\n\t\tdev_err(dev, \"Corrupted alive message\");\n\t\tbtdev->init_error = -EIO;\n\t\tret = -EIO;\n\t\tgoto finish_alive;\n\t}\n\n\tpkt = skb_pull(skb, sizeof(*hdr));\n\n\tif (pkt->mid != NOKIA_ALIVE_RESP) {\n\t\tdev_err(dev, \"Alive received: invalid response: 0x%02x!\",\n\t\t\tpkt->mid);\n\t\tbtdev->init_error = -EINVAL;\n\t\tret = -EINVAL;\n\t\tgoto finish_alive;\n\t}\n\n\tdev_dbg(dev, \"Alive received\");\n\nfinish_alive:\n\tcomplete(&btdev->init_completion);\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int nokia_recv_radio(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\t \n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\treturn hci_recv_frame(hdev, skb);\n}\n\n \nstatic const struct h4_recv_pkt nokia_recv_pkts[] = {\n\t{ H4_RECV_ACL,\t\t.recv = hci_recv_frame },\n\t{ H4_RECV_SCO,\t\t.recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,\t.recv = hci_recv_frame },\n\t{ NOKIA_RECV_ALIVE,\t.recv = nokia_recv_alive_packet },\n\t{ NOKIA_RECV_NEG,\t.recv = nokia_recv_negotiation_packet },\n\t{ NOKIA_RECV_RADIO,\t.recv = nokia_recv_radio },\n};\n\nstatic int nokia_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tint err;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tbtdev->rx_skb = h4_recv_buf(hu->hdev, btdev->rx_skb, data, count,\n\t\t\t\t  nokia_recv_pkts, ARRAY_SIZE(nokia_recv_pkts));\n\tif (IS_ERR(btdev->rx_skb)) {\n\t\terr = PTR_ERR(btdev->rx_skb);\n\t\tdev_err(dev, \"Frame reassembly failed (%d)\", err);\n\t\tbtdev->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *nokia_dequeue(struct hci_uart *hu)\n{\n\tstruct nokia_bt_dev *btdev = hu->priv;\n\tstruct device *dev = &btdev->serdev->dev;\n\tstruct sk_buff *result = skb_dequeue(&btdev->txq);\n\n\tif (!btdev->initialized)\n\t\treturn result;\n\n\tif (btdev->tx_enabled == !!result)\n\t\treturn result;\n\n\tif (result) {\n\t\tpm_runtime_get_sync(dev);\n\t\tgpiod_set_value_cansleep(btdev->wakeup_bt, 1);\n\t} else {\n\t\tserdev_device_wait_until_sent(btdev->serdev, 0);\n\t\tgpiod_set_value_cansleep(btdev->wakeup_bt, 0);\n\t\tpm_runtime_put(dev);\n\t}\n\n\tbtdev->tx_enabled = !!result;\n\n\treturn result;\n}\n\nstatic const struct hci_uart_proto nokia_proto = {\n\t.id\t\t= HCI_UART_NOKIA,\n\t.name\t\t= \"Nokia\",\n\t.open\t\t= nokia_open,\n\t.close\t\t= nokia_close,\n\t.recv\t\t= nokia_recv,\n\t.enqueue\t= nokia_enqueue,\n\t.dequeue\t= nokia_dequeue,\n\t.flush\t\t= nokia_flush,\n\t.setup\t\t= nokia_setup,\n\t.manufacturer\t= 1,\n};\n\nstatic int nokia_bluetooth_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct nokia_bt_dev *btdev;\n\tstruct clk *sysclk;\n\tint err = 0;\n\n\tbtdev = devm_kzalloc(dev, sizeof(*btdev), GFP_KERNEL);\n\tif (!btdev)\n\t\treturn -ENOMEM;\n\n\tbtdev->hu.serdev = btdev->serdev = serdev;\n\tserdev_device_set_drvdata(serdev, btdev);\n\n\tbtdev->reset = devm_gpiod_get(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(btdev->reset)) {\n\t\terr = PTR_ERR(btdev->reset);\n\t\tdev_err(dev, \"could not get reset gpio: %d\", err);\n\t\treturn err;\n\t}\n\n\tbtdev->wakeup_host = devm_gpiod_get(dev, \"host-wakeup\", GPIOD_IN);\n\tif (IS_ERR(btdev->wakeup_host)) {\n\t\terr = PTR_ERR(btdev->wakeup_host);\n\t\tdev_err(dev, \"could not get host wakeup gpio: %d\", err);\n\t\treturn err;\n\t}\n\n\tbtdev->wake_irq = gpiod_to_irq(btdev->wakeup_host);\n\n\terr = devm_request_threaded_irq(dev, btdev->wake_irq, NULL,\n\t\twakeup_handler,\n\t\tIRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\"wakeup\", btdev);\n\tif (err) {\n\t\tdev_err(dev, \"could request wakeup irq: %d\", err);\n\t\treturn err;\n\t}\n\n\tbtdev->wakeup_bt = devm_gpiod_get(dev, \"bluetooth-wakeup\",\n\t\t\t\t\t   GPIOD_OUT_LOW);\n\tif (IS_ERR(btdev->wakeup_bt)) {\n\t\terr = PTR_ERR(btdev->wakeup_bt);\n\t\tdev_err(dev, \"could not get BT wakeup gpio: %d\", err);\n\t\treturn err;\n\t}\n\n\tsysclk = devm_clk_get(dev, \"sysclk\");\n\tif (IS_ERR(sysclk)) {\n\t\terr = PTR_ERR(sysclk);\n\t\tdev_err(dev, \"could not get sysclk: %d\", err);\n\t\treturn err;\n\t}\n\n\terr = clk_prepare_enable(sysclk);\n\tif (err) {\n\t\tdev_err(dev, \"could not enable sysclk: %d\", err);\n\t\treturn err;\n\t}\n\tbtdev->sysclk_speed = clk_get_rate(sysclk);\n\tclk_disable_unprepare(sysclk);\n\n\tskb_queue_head_init(&btdev->txq);\n\n\tbtdev->hu.priv = btdev;\n\tbtdev->hu.alignment = 2;  \n\n\terr = hci_uart_register_device(&btdev->hu, &nokia_proto);\n\tif (err) {\n\t\tdev_err(dev, \"could not register bluetooth uart: %d\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void nokia_bluetooth_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct nokia_bt_dev *btdev = serdev_device_get_drvdata(serdev);\n\n\thci_uart_unregister_device(&btdev->hu);\n}\n\nstatic int nokia_bluetooth_runtime_suspend(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\n\tnokia_flow_control(serdev, false);\n\treturn 0;\n}\n\nstatic int nokia_bluetooth_runtime_resume(struct device *dev)\n{\n\tstruct serdev_device *serdev = to_serdev_device(dev);\n\n\tnokia_flow_control(serdev, true);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops nokia_bluetooth_pm_ops = {\n\tSET_RUNTIME_PM_OPS(nokia_bluetooth_runtime_suspend,\n\t\t\t   nokia_bluetooth_runtime_resume,\n\t\t\t   NULL)\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id nokia_bluetooth_of_match[] = {\n\t{ .compatible = \"nokia,h4p-bluetooth\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, nokia_bluetooth_of_match);\n#endif\n\nstatic struct serdev_device_driver nokia_bluetooth_serdev_driver = {\n\t.probe = nokia_bluetooth_serdev_probe,\n\t.remove = nokia_bluetooth_serdev_remove,\n\t.driver = {\n\t\t.name = \"nokia-bluetooth\",\n\t\t.pm = &nokia_bluetooth_pm_ops,\n\t\t.of_match_table = of_match_ptr(nokia_bluetooth_of_match),\n\t},\n};\n\nmodule_serdev_device_driver(nokia_bluetooth_serdev_driver);\n\nMODULE_AUTHOR(\"Sebastian Reichel <sre@kernel.org>\");\nMODULE_DESCRIPTION(\"Bluetooth HCI UART Nokia H4+ driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}