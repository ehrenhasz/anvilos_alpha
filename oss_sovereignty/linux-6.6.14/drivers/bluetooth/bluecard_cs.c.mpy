{
  "module_name": "bluecard_cs.c",
  "hash_id": "4353bd53d9fe28b87c82c05eb759d5ca08a3225f49f0a544d9cfa3b3de3da6c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/bluecard_cs.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/delay.h>\n#include <linux/timer.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n#include <linux/moduleparam.h>\n#include <linux/wait.h>\n\n#include <linux/skbuff.h>\n#include <linux/io.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n\n\n \n\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth driver for the Anycom BlueCard (LSE039/LSE041)\");\nMODULE_LICENSE(\"GPL\");\n\n\n\n \n\n\nstruct bluecard_info {\n\tstruct pcmcia_device *p_dev;\n\n\tstruct hci_dev *hdev;\n\n\tspinlock_t lock;\t\t \n\tstruct timer_list timer;\t \n\n\tstruct sk_buff_head txq;\n\tunsigned long tx_state;\n\n\tunsigned long rx_state;\n\tunsigned long rx_count;\n\tstruct sk_buff *rx_skb;\n\n\tunsigned char ctrl_reg;\n\tunsigned long hw_state;\t\t \n};\n\n\nstatic int bluecard_config(struct pcmcia_device *link);\nstatic void bluecard_release(struct pcmcia_device *link);\n\nstatic void bluecard_detach(struct pcmcia_device *p_dev);\n\n\n \n#define DEFAULT_BAUD_RATE  230400\n\n\n \n#define CARD_READY             1\n#define CARD_ACTIVITY\t       2\n#define CARD_HAS_PCCARD_ID     4\n#define CARD_HAS_POWER_LED     5\n#define CARD_HAS_ACTIVITY_LED  6\n\n \n#define XMIT_SENDING         1\n#define XMIT_WAKEUP          2\n#define XMIT_BUFFER_NUMBER   5\t \n#define XMIT_BUF_ONE_READY   6\n#define XMIT_BUF_TWO_READY   7\n#define XMIT_SENDING_READY   8\n\n \n#define RECV_WAIT_PACKET_TYPE   0\n#define RECV_WAIT_EVENT_HEADER  1\n#define RECV_WAIT_ACL_HEADER    2\n#define RECV_WAIT_SCO_HEADER    3\n#define RECV_WAIT_DATA          4\n\n \n#define PKT_BAUD_RATE_57600   0x80\n#define PKT_BAUD_RATE_115200  0x81\n#define PKT_BAUD_RATE_230400  0x82\n#define PKT_BAUD_RATE_460800  0x83\n\n\n \n#define REG_COMMAND     0x20\n#define REG_INTERRUPT   0x21\n#define REG_CONTROL     0x22\n#define REG_RX_CONTROL  0x24\n#define REG_CARD_RESET  0x30\n#define REG_LED_CTRL    0x30\n\n \n#define REG_COMMAND_TX_BUF_ONE  0x01\n#define REG_COMMAND_TX_BUF_TWO  0x02\n#define REG_COMMAND_RX_BUF_ONE  0x04\n#define REG_COMMAND_RX_BUF_TWO  0x08\n#define REG_COMMAND_RX_WIN_ONE  0x00\n#define REG_COMMAND_RX_WIN_TWO  0x10\n\n \n#define REG_CONTROL_BAUD_RATE_57600   0x00\n#define REG_CONTROL_BAUD_RATE_115200  0x01\n#define REG_CONTROL_BAUD_RATE_230400  0x02\n#define REG_CONTROL_BAUD_RATE_460800  0x03\n#define REG_CONTROL_RTS               0x04\n#define REG_CONTROL_BT_ON             0x08\n#define REG_CONTROL_BT_RESET          0x10\n#define REG_CONTROL_BT_RES_PU         0x20\n#define REG_CONTROL_INTERRUPT         0x40\n#define REG_CONTROL_CARD_RESET        0x80\n\n \n#define RTS_LEVEL_SHIFT_BITS  0x02\n\n\n\n \n\n\nstatic void bluecard_activity_led_timeout(struct timer_list *t)\n{\n\tstruct bluecard_info *info = from_timer(info, t, timer);\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\n\tif (test_bit(CARD_ACTIVITY, &(info->hw_state))) {\n\t\t \n\t\tclear_bit(CARD_ACTIVITY, &(info->hw_state));\n\t\tmod_timer(&(info->timer), jiffies + HZ / 10);\n\t}\n\n\t \n\toutb(0x08 | 0x20, iobase + 0x30);\n}\n\n\nstatic void bluecard_enable_activity_led(struct bluecard_info *info)\n{\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\n\t \n\tif (timer_pending(&(info->timer)))\n\t\treturn;\n\n\tset_bit(CARD_ACTIVITY, &(info->hw_state));\n\n\tif (test_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state))) {\n\t\t \n\t\toutb(0x18 | 0x60, iobase + 0x30);\n\t} else {\n\t\t \n\t\toutb(0x00, iobase + 0x30);\n\t}\n\n\t \n\tmod_timer(&(info->timer), jiffies + HZ / 10);\n}\n\n\n\n \n\n\nstatic int bluecard_write(unsigned int iobase, unsigned int offset, __u8 *buf, int len)\n{\n\tint i, actual;\n\n\tactual = (len > 15) ? 15 : len;\n\n\toutb_p(actual, iobase + offset);\n\n\tfor (i = 0; i < actual; i++)\n\t\toutb_p(buf[i], iobase + offset + i + 1);\n\n\treturn actual;\n}\n\n\nstatic void bluecard_write_wakeup(struct bluecard_info *info)\n{\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tif (!test_bit(XMIT_SENDING_READY, &(info->tx_state)))\n\t\treturn;\n\n\tif (test_and_set_bit(XMIT_SENDING, &(info->tx_state))) {\n\t\tset_bit(XMIT_WAKEUP, &(info->tx_state));\n\t\treturn;\n\t}\n\n\tdo {\n\t\tunsigned int iobase = info->p_dev->resource[0]->start;\n\t\tunsigned int offset;\n\t\tunsigned char command;\n\t\tunsigned long ready_bit;\n\t\tregister struct sk_buff *skb;\n\t\tint len;\n\n\t\tclear_bit(XMIT_WAKEUP, &(info->tx_state));\n\n\t\tif (!pcmcia_dev_present(info->p_dev))\n\t\t\treturn;\n\n\t\tif (test_bit(XMIT_BUFFER_NUMBER, &(info->tx_state))) {\n\t\t\tif (!test_bit(XMIT_BUF_TWO_READY, &(info->tx_state)))\n\t\t\t\tbreak;\n\t\t\toffset = 0x10;\n\t\t\tcommand = REG_COMMAND_TX_BUF_TWO;\n\t\t\tready_bit = XMIT_BUF_TWO_READY;\n\t\t} else {\n\t\t\tif (!test_bit(XMIT_BUF_ONE_READY, &(info->tx_state)))\n\t\t\t\tbreak;\n\t\t\toffset = 0x00;\n\t\t\tcommand = REG_COMMAND_TX_BUF_ONE;\n\t\t\tready_bit = XMIT_BUF_ONE_READY;\n\t\t}\n\n\t\tskb = skb_dequeue(&(info->txq));\n\t\tif (!skb)\n\t\t\tbreak;\n\n\t\tif (hci_skb_pkt_type(skb) & 0x80) {\n\t\t\t \n\t\t\tinfo->ctrl_reg |= REG_CONTROL_RTS;\n\t\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\t\t}\n\n\t\t \n\t\tbluecard_enable_activity_led(info);\n\n\t\t \n\t\tlen = bluecard_write(iobase, offset, skb->data, skb->len);\n\n\t\t \n\t\toutb_p(command, iobase + REG_COMMAND);\n\n\t\t \n\t\tclear_bit(ready_bit, &(info->tx_state));\n\n\t\tif (hci_skb_pkt_type(skb) & 0x80) {\n\t\t\tDECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq);\n\t\t\tDEFINE_WAIT(wait);\n\n\t\t\tunsigned char baud_reg;\n\n\t\t\tswitch (hci_skb_pkt_type(skb)) {\n\t\t\tcase PKT_BAUD_RATE_460800:\n\t\t\t\tbaud_reg = REG_CONTROL_BAUD_RATE_460800;\n\t\t\t\tbreak;\n\t\t\tcase PKT_BAUD_RATE_230400:\n\t\t\t\tbaud_reg = REG_CONTROL_BAUD_RATE_230400;\n\t\t\t\tbreak;\n\t\t\tcase PKT_BAUD_RATE_115200:\n\t\t\t\tbaud_reg = REG_CONTROL_BAUD_RATE_115200;\n\t\t\t\tbreak;\n\t\t\tcase PKT_BAUD_RATE_57600:\n\t\t\tdefault:\n\t\t\t\tbaud_reg = REG_CONTROL_BAUD_RATE_57600;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tmdelay(100);\n\n\t\t\t \n\t\t\tinfo->ctrl_reg &= ~0x03;\n\t\t\tinfo->ctrl_reg |= baud_reg;\n\t\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t\t\t \n\t\t\tinfo->ctrl_reg &= ~REG_CONTROL_RTS;\n\t\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t\t\t \n\t\t\tmdelay(1000);\n\t\t}\n\n\t\tif (len == skb->len) {\n\t\t\tkfree_skb(skb);\n\t\t} else {\n\t\t\tskb_pull(skb, len);\n\t\t\tskb_queue_head(&(info->txq), skb);\n\t\t}\n\n\t\tinfo->hdev->stat.byte_tx += len;\n\n\t\t \n\t\tchange_bit(XMIT_BUFFER_NUMBER, &(info->tx_state));\n\n\t} while (test_bit(XMIT_WAKEUP, &(info->tx_state)));\n\n\tclear_bit(XMIT_SENDING, &(info->tx_state));\n}\n\n\nstatic int bluecard_read(unsigned int iobase, unsigned int offset, __u8 *buf, int size)\n{\n\tint i, n, len;\n\n\toutb(REG_COMMAND_RX_WIN_ONE, iobase + REG_COMMAND);\n\n\tlen = inb(iobase + offset);\n\tn = 0;\n\ti = 1;\n\n\twhile (n < len) {\n\n\t\tif (i == 16) {\n\t\t\toutb(REG_COMMAND_RX_WIN_TWO, iobase + REG_COMMAND);\n\t\t\ti = 0;\n\t\t}\n\n\t\tbuf[n] = inb(iobase + offset + i);\n\n\t\tn++;\n\t\ti++;\n\n\t}\n\n\treturn len;\n}\n\n\nstatic void bluecard_receive(struct bluecard_info *info,\n\t\t\t     unsigned int offset)\n{\n\tunsigned int iobase;\n\tunsigned char buf[31];\n\tint i, len;\n\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tif (test_bit(XMIT_SENDING_READY, &(info->tx_state)))\n\t\tbluecard_enable_activity_led(info);\n\n\tlen = bluecard_read(iobase, offset, buf, sizeof(buf));\n\n\tfor (i = 0; i < len; i++) {\n\n\t\t \n\t\tif (!info->rx_skb) {\n\t\t\tinfo->rx_state = RECV_WAIT_PACKET_TYPE;\n\t\t\tinfo->rx_count = 0;\n\t\t\tinfo->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);\n\t\t\tif (!info->rx_skb) {\n\t\t\t\tBT_ERR(\"Can't allocate mem for new packet\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (info->rx_state == RECV_WAIT_PACKET_TYPE) {\n\n\t\t\thci_skb_pkt_type(info->rx_skb) = buf[i];\n\n\t\t\tswitch (hci_skb_pkt_type(info->rx_skb)) {\n\n\t\t\tcase 0x00:\n\t\t\t\t \n\t\t\t\tif (offset != 0x00) {\n\t\t\t\t\tset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\n\t\t\t\t\tset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\n\t\t\t\t\tset_bit(XMIT_SENDING_READY, &(info->tx_state));\n\t\t\t\t\tbluecard_write_wakeup(info);\n\t\t\t\t}\n\n\t\t\t\tkfree_skb(info->rx_skb);\n\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\tbreak;\n\n\t\t\tcase HCI_EVENT_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_EVENT_HEADER;\n\t\t\t\tinfo->rx_count = HCI_EVENT_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tcase HCI_ACLDATA_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_ACL_HEADER;\n\t\t\t\tinfo->rx_count = HCI_ACL_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tcase HCI_SCODATA_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_SCO_HEADER;\n\t\t\t\tinfo->rx_count = HCI_SCO_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tBT_ERR(\"Unknown HCI packet with type 0x%02x received\",\n\t\t\t\t       hci_skb_pkt_type(info->rx_skb));\n\t\t\t\tinfo->hdev->stat.err_rx++;\n\n\t\t\t\tkfree_skb(info->rx_skb);\n\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tskb_put_u8(info->rx_skb, buf[i]);\n\t\t\tinfo->rx_count--;\n\n\t\t\tif (info->rx_count == 0) {\n\n\t\t\t\tint dlen;\n\t\t\t\tstruct hci_event_hdr *eh;\n\t\t\t\tstruct hci_acl_hdr *ah;\n\t\t\t\tstruct hci_sco_hdr *sh;\n\n\t\t\t\tswitch (info->rx_state) {\n\n\t\t\t\tcase RECV_WAIT_EVENT_HEADER:\n\t\t\t\t\teh = hci_event_hdr(info->rx_skb);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = eh->plen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_ACL_HEADER:\n\t\t\t\t\tah = hci_acl_hdr(info->rx_skb);\n\t\t\t\t\tdlen = __le16_to_cpu(ah->dlen);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = dlen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_SCO_HEADER:\n\t\t\t\t\tsh = hci_sco_hdr(info->rx_skb);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = sh->dlen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_DATA:\n\t\t\t\t\thci_recv_frame(info->hdev, info->rx_skb);\n\t\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\tinfo->hdev->stat.byte_rx += len;\n}\n\n\nstatic irqreturn_t bluecard_interrupt(int irq, void *dev_inst)\n{\n\tstruct bluecard_info *info = dev_inst;\n\tunsigned int iobase;\n\tunsigned char reg;\n\n\tif (!info || !info->hdev)\n\t\t \n\t\treturn IRQ_NONE;\n\n\tif (!test_bit(CARD_READY, &(info->hw_state)))\n\t\treturn IRQ_HANDLED;\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tspin_lock(&(info->lock));\n\n\t \n\tinfo->ctrl_reg &= ~REG_CONTROL_INTERRUPT;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\treg = inb(iobase + REG_INTERRUPT);\n\n\tif ((reg != 0x00) && (reg != 0xff)) {\n\n\t\tif (reg & 0x04) {\n\t\t\tbluecard_receive(info, 0x00);\n\t\t\toutb(0x04, iobase + REG_INTERRUPT);\n\t\t\toutb(REG_COMMAND_RX_BUF_ONE, iobase + REG_COMMAND);\n\t\t}\n\n\t\tif (reg & 0x08) {\n\t\t\tbluecard_receive(info, 0x10);\n\t\t\toutb(0x08, iobase + REG_INTERRUPT);\n\t\t\toutb(REG_COMMAND_RX_BUF_TWO, iobase + REG_COMMAND);\n\t\t}\n\n\t\tif (reg & 0x01) {\n\t\t\tset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\n\t\t\toutb(0x01, iobase + REG_INTERRUPT);\n\t\t\tbluecard_write_wakeup(info);\n\t\t}\n\n\t\tif (reg & 0x02) {\n\t\t\tset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\n\t\t\toutb(0x02, iobase + REG_INTERRUPT);\n\t\t\tbluecard_write_wakeup(info);\n\t\t}\n\n\t}\n\n\t \n\tinfo->ctrl_reg |= REG_CONTROL_INTERRUPT;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\tspin_unlock(&(info->lock));\n\n\treturn IRQ_HANDLED;\n}\n\n\n\n \n\n\nstatic int bluecard_hci_set_baud_rate(struct hci_dev *hdev, int baud)\n{\n\tstruct bluecard_info *info = hci_get_drvdata(hdev);\n\tstruct sk_buff *skb;\n\n\t \n\tunsigned char cmd[] = { HCI_COMMAND_PKT, 0x09, 0xfc, 0x01, 0x03 };\n\n\tskb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_KERNEL);\n\tif (!skb) {\n\t\tBT_ERR(\"Can't allocate mem for new packet\");\n\t\treturn -1;\n\t}\n\n\tswitch (baud) {\n\tcase 460800:\n\t\tcmd[4] = 0x00;\n\t\thci_skb_pkt_type(skb) = PKT_BAUD_RATE_460800;\n\t\tbreak;\n\tcase 230400:\n\t\tcmd[4] = 0x01;\n\t\thci_skb_pkt_type(skb) = PKT_BAUD_RATE_230400;\n\t\tbreak;\n\tcase 115200:\n\t\tcmd[4] = 0x02;\n\t\thci_skb_pkt_type(skb) = PKT_BAUD_RATE_115200;\n\t\tbreak;\n\tcase 57600:\n\tdefault:\n\t\tcmd[4] = 0x03;\n\t\thci_skb_pkt_type(skb) = PKT_BAUD_RATE_57600;\n\t\tbreak;\n\t}\n\n\tskb_put_data(skb, cmd, sizeof(cmd));\n\n\tskb_queue_tail(&(info->txq), skb);\n\n\tbluecard_write_wakeup(info);\n\n\treturn 0;\n}\n\n\n\n \n\n\nstatic int bluecard_hci_flush(struct hci_dev *hdev)\n{\n\tstruct bluecard_info *info = hci_get_drvdata(hdev);\n\n\t \n\tskb_queue_purge(&(info->txq));\n\n\treturn 0;\n}\n\n\nstatic int bluecard_hci_open(struct hci_dev *hdev)\n{\n\tstruct bluecard_info *info = hci_get_drvdata(hdev);\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\n\tif (test_bit(CARD_HAS_PCCARD_ID, &(info->hw_state)))\n\t\tbluecard_hci_set_baud_rate(hdev, DEFAULT_BAUD_RATE);\n\n\t \n\toutb(0x08 | 0x20, iobase + 0x30);\n\n\treturn 0;\n}\n\n\nstatic int bluecard_hci_close(struct hci_dev *hdev)\n{\n\tstruct bluecard_info *info = hci_get_drvdata(hdev);\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\n\tbluecard_hci_flush(hdev);\n\n\t \n\tdel_timer_sync(&(info->timer));\n\n\t \n\toutb(0x00, iobase + 0x30);\n\n\treturn 0;\n}\n\n\nstatic int bluecard_hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct bluecard_info *info = hci_get_drvdata(hdev);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\tskb_queue_tail(&(info->txq), skb);\n\n\tbluecard_write_wakeup(info);\n\n\treturn 0;\n}\n\n\n\n \n\n\nstatic int bluecard_open(struct bluecard_info *info)\n{\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\tstruct hci_dev *hdev;\n\tunsigned char id;\n\n\tspin_lock_init(&(info->lock));\n\n\ttimer_setup(&info->timer, bluecard_activity_led_timeout, 0);\n\n\tskb_queue_head_init(&(info->txq));\n\n\tinfo->rx_state = RECV_WAIT_PACKET_TYPE;\n\tinfo->rx_count = 0;\n\tinfo->rx_skb = NULL;\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->hdev = hdev;\n\n\thdev->bus = HCI_PCCARD;\n\thci_set_drvdata(hdev, info);\n\tSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\n\n\thdev->open  = bluecard_hci_open;\n\thdev->close = bluecard_hci_close;\n\thdev->flush = bluecard_hci_flush;\n\thdev->send  = bluecard_hci_send_frame;\n\n\tid = inb(iobase + 0x30);\n\n\tif ((id & 0x0f) == 0x02)\n\t\tset_bit(CARD_HAS_PCCARD_ID, &(info->hw_state));\n\n\tif (id & 0x10)\n\t\tset_bit(CARD_HAS_POWER_LED, &(info->hw_state));\n\n\tif (id & 0x20)\n\t\tset_bit(CARD_HAS_ACTIVITY_LED, &(info->hw_state));\n\n\t \n\tinfo->ctrl_reg = REG_CONTROL_BT_RESET | REG_CONTROL_CARD_RESET;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t \n\toutb(0x80, iobase + 0x30);\n\n\t \n\tmsleep(10);\n\n\t \n\toutb(0x00, iobase + 0x30);\n\n\t \n\tinfo->ctrl_reg = REG_CONTROL_BT_ON | REG_CONTROL_BT_RES_PU;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t \n\toutb(0xff, iobase + REG_INTERRUPT);\n\tinfo->ctrl_reg |= REG_CONTROL_INTERRUPT;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\tif ((id & 0x0f) == 0x03) {\n\t\t \n\t\tinfo->ctrl_reg |= REG_CONTROL_RTS;\n\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t\t \n\t\tinfo->ctrl_reg |= 0x03;\n\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t\t \n\t\tinfo->ctrl_reg &= ~REG_CONTROL_RTS;\n\t\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t\tset_bit(XMIT_BUF_ONE_READY, &(info->tx_state));\n\t\tset_bit(XMIT_BUF_TWO_READY, &(info->tx_state));\n\t\tset_bit(XMIT_SENDING_READY, &(info->tx_state));\n\t}\n\n\t \n\toutb(REG_COMMAND_RX_BUF_ONE, iobase + REG_COMMAND);\n\toutb(REG_COMMAND_RX_BUF_TWO, iobase + REG_COMMAND);\n\n\t \n\tset_bit(CARD_READY, &(info->hw_state));\n\n\t \n\tskb_queue_purge(&(info->txq));\n\n\t \n\toutb((0x0f << RTS_LEVEL_SHIFT_BITS) | 1, iobase + REG_RX_CONTROL);\n\n\t \n\tmsleep(1250);\n\n\t \n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tinfo->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int bluecard_close(struct bluecard_info *info)\n{\n\tunsigned int iobase = info->p_dev->resource[0]->start;\n\tstruct hci_dev *hdev = info->hdev;\n\n\tif (!hdev)\n\t\treturn -ENODEV;\n\n\tbluecard_hci_close(hdev);\n\n\tclear_bit(CARD_READY, &(info->hw_state));\n\n\t \n\tinfo->ctrl_reg = REG_CONTROL_BT_RESET | REG_CONTROL_CARD_RESET;\n\toutb(info->ctrl_reg, iobase + REG_CONTROL);\n\n\t \n\toutb(0x80, iobase + 0x30);\n\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n\n\treturn 0;\n}\n\nstatic int bluecard_probe(struct pcmcia_device *link)\n{\n\tstruct bluecard_info *info;\n\n\t \n\tinfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\n\tlink->config_flags |= CONF_ENABLE_IRQ;\n\n\treturn bluecard_config(link);\n}\n\n\nstatic void bluecard_detach(struct pcmcia_device *link)\n{\n\tbluecard_release(link);\n}\n\n\nstatic int bluecard_config(struct pcmcia_device *link)\n{\n\tstruct bluecard_info *info = link->priv;\n\tint i, n;\n\n\tlink->config_index = 0x20;\n\n\tlink->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tlink->resource[0]->end = 64;\n\tlink->io_lines = 6;\n\n\tfor (n = 0; n < 0x400; n += 0x40) {\n\t\tlink->resource[0]->start = n ^ 0x300;\n\t\ti = pcmcia_request_io(link);\n\t\tif (i == 0)\n\t\t\tbreak;\n\t}\n\n\tif (i != 0)\n\t\tgoto failed;\n\n\ti = pcmcia_request_irq(link, bluecard_interrupt);\n\tif (i != 0)\n\t\tgoto failed;\n\n\ti = pcmcia_enable_device(link);\n\tif (i != 0)\n\t\tgoto failed;\n\n\tif (bluecard_open(info) != 0)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tbluecard_release(link);\n\treturn -ENODEV;\n}\n\n\nstatic void bluecard_release(struct pcmcia_device *link)\n{\n\tstruct bluecard_info *info = link->priv;\n\n\tbluecard_close(info);\n\n\tdel_timer_sync(&(info->timer));\n\n\tpcmcia_disable_device(link);\n}\n\nstatic const struct pcmcia_device_id bluecard_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID12(\"BlueCard\", \"LSE041\", 0xbaf16fbf, 0x657cc15e),\n\tPCMCIA_DEVICE_PROD_ID12(\"BTCFCARD\", \"LSE139\", 0xe3987764, 0x2524b59c),\n\tPCMCIA_DEVICE_PROD_ID12(\"WSS\", \"LSE039\", 0x0a0736ec, 0x24e6dfab),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, bluecard_ids);\n\nstatic struct pcmcia_driver bluecard_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bluecard_cs\",\n\t.probe\t\t= bluecard_probe,\n\t.remove\t\t= bluecard_detach,\n\t.id_table\t= bluecard_ids,\n};\nmodule_pcmcia_driver(bluecard_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}