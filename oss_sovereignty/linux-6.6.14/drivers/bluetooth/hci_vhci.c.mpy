{
  "module_name": "hci_vhci.c",
  "hash_id": "ff92963a747795b815579dad2c1821b89a30912231e663a40dc64b73f3920cb1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_vhci.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <asm/unaligned.h>\n\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/poll.h>\n\n#include <linux/skbuff.h>\n#include <linux/miscdevice.h>\n#include <linux/debugfs.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#define VERSION \"1.5\"\n\nstatic bool amp;\n\nstruct vhci_data {\n\tstruct hci_dev *hdev;\n\n\twait_queue_head_t read_wait;\n\tstruct sk_buff_head readq;\n\n\tstruct mutex open_mutex;\n\tstruct delayed_work open_timeout;\n\tstruct work_struct suspend_work;\n\n\tbool suspended;\n\tbool wakeup;\n\t__u16 msft_opcode;\n\tbool aosp_capable;\n\tatomic_t initialized;\n};\n\nstatic int vhci_open_dev(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int vhci_close_dev(struct hci_dev *hdev)\n{\n\tstruct vhci_data *data = hci_get_drvdata(hdev);\n\n\tskb_queue_purge(&data->readq);\n\n\treturn 0;\n}\n\nstatic int vhci_flush(struct hci_dev *hdev)\n{\n\tstruct vhci_data *data = hci_get_drvdata(hdev);\n\n\tskb_queue_purge(&data->readq);\n\n\treturn 0;\n}\n\nstatic int vhci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct vhci_data *data = hci_get_drvdata(hdev);\n\n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\tskb_queue_tail(&data->readq, skb);\n\n\tif (atomic_read(&data->initialized))\n\t\twake_up_interruptible(&data->read_wait);\n\treturn 0;\n}\n\nstatic int vhci_get_data_path_id(struct hci_dev *hdev, u8 *data_path_id)\n{\n\t*data_path_id = 0;\n\treturn 0;\n}\n\nstatic int vhci_get_codec_config_data(struct hci_dev *hdev, __u8 type,\n\t\t\t\t      struct bt_codec *codec, __u8 *vnd_len,\n\t\t\t\t      __u8 **vnd_data)\n{\n\tif (type != ESCO_LINK)\n\t\treturn -EINVAL;\n\n\t*vnd_len = 0;\n\t*vnd_data = NULL;\n\treturn 0;\n}\n\nstatic bool vhci_wakeup(struct hci_dev *hdev)\n{\n\tstruct vhci_data *data = hci_get_drvdata(hdev);\n\n\treturn data->wakeup;\n}\n\nstatic ssize_t force_suspend_read(struct file *file, char __user *user_buf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = data->suspended ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic void vhci_suspend_work(struct work_struct *work)\n{\n\tstruct vhci_data *data = container_of(work, struct vhci_data,\n\t\t\t\t\t      suspend_work);\n\n\tif (data->suspended)\n\t\thci_suspend_dev(data->hdev);\n\telse\n\t\thci_resume_dev(data->hdev);\n}\n\nstatic ssize_t force_suspend_write(struct file *file,\n\t\t\t\t   const char __user *user_buf,\n\t\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (data->suspended == enable)\n\t\treturn -EALREADY;\n\n\tdata->suspended = enable;\n\n\tschedule_work(&data->suspend_work);\n\n\treturn count;\n}\n\nstatic const struct file_operations force_suspend_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_suspend_read,\n\t.write\t\t= force_suspend_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic ssize_t force_wakeup_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = data->wakeup ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t force_wakeup_write(struct file *file,\n\t\t\t\t  const char __user *user_buf, size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (data->wakeup == enable)\n\t\treturn -EALREADY;\n\n\tdata->wakeup = enable;\n\n\treturn count;\n}\n\nstatic const struct file_operations force_wakeup_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= force_wakeup_read,\n\t.write\t\t= force_wakeup_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int msft_opcode_set(void *data, u64 val)\n{\n\tstruct vhci_data *vhci = data;\n\n\tif (val > 0xffff || hci_opcode_ogf(val) != 0x3f)\n\t\treturn -EINVAL;\n\n\tif (vhci->msft_opcode)\n\t\treturn -EALREADY;\n\n\tvhci->msft_opcode = val;\n\n\treturn 0;\n}\n\nstatic int msft_opcode_get(void *data, u64 *val)\n{\n\tstruct vhci_data *vhci = data;\n\n\t*val = vhci->msft_opcode;\n\n\treturn 0;\n}\n\nDEFINE_DEBUGFS_ATTRIBUTE(msft_opcode_fops, msft_opcode_get, msft_opcode_set,\n\t\t\t \"%llu\\n\");\n\nstatic ssize_t aosp_capable_read(struct file *file, char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct vhci_data *vhci = file->private_data;\n\tchar buf[3];\n\n\tbuf[0] = vhci->aosp_capable ? 'Y' : 'N';\n\tbuf[1] = '\\n';\n\tbuf[2] = '\\0';\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t aosp_capable_write(struct file *file,\n\t\t\t\t  const char __user *user_buf, size_t count,\n\t\t\t\t  loff_t *ppos)\n{\n\tstruct vhci_data *vhci = file->private_data;\n\tbool enable;\n\tint err;\n\n\terr = kstrtobool_from_user(user_buf, count, &enable);\n\tif (err)\n\t\treturn err;\n\n\tif (!enable)\n\t\treturn -EINVAL;\n\n\tif (vhci->aosp_capable)\n\t\treturn -EALREADY;\n\n\tvhci->aosp_capable = enable;\n\n\treturn count;\n}\n\nstatic const struct file_operations aosp_capable_fops = {\n\t.open\t\t= simple_open,\n\t.read\t\t= aosp_capable_read,\n\t.write\t\t= aosp_capable_write,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int vhci_setup(struct hci_dev *hdev)\n{\n\tstruct vhci_data *vhci = hci_get_drvdata(hdev);\n\n\tif (vhci->msft_opcode)\n\t\thci_set_msft_opcode(hdev, vhci->msft_opcode);\n\n\tif (vhci->aosp_capable)\n\t\thci_set_aosp_capable(hdev);\n\n\treturn 0;\n}\n\nstatic void vhci_coredump(struct hci_dev *hdev)\n{\n\t \n}\n\nstatic void vhci_coredump_hdr(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tchar buf[80];\n\n\tsnprintf(buf, sizeof(buf), \"Controller Name: vhci_ctrl\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Firmware Version: vhci_fw\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Driver: vhci_drv\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Vendor: vhci\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n}\n\n#define MAX_COREDUMP_LINE_LEN\t40\n\nstruct devcoredump_test_data {\n\tenum devcoredump_state state;\n\tunsigned int timeout;\n\tchar data[MAX_COREDUMP_LINE_LEN];\n};\n\nstatic inline void force_devcd_timeout(struct hci_dev *hdev,\n\t\t\t\t       unsigned int timeout)\n{\n#ifdef CONFIG_DEV_COREDUMP\n\thdev->dump.timeout = msecs_to_jiffies(timeout * 1000);\n#endif\n}\n\nstatic ssize_t force_devcd_write(struct file *file, const char __user *user_buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tstruct hci_dev *hdev = data->hdev;\n\tstruct sk_buff *skb = NULL;\n\tstruct devcoredump_test_data dump_data;\n\tsize_t data_size;\n\tint ret;\n\n\tif (count < offsetof(struct devcoredump_test_data, data) ||\n\t    count > sizeof(dump_data))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&dump_data, user_buf, count))\n\t\treturn -EFAULT;\n\n\tdata_size = count - offsetof(struct devcoredump_test_data, data);\n\tskb = alloc_skb(data_size, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\tskb_put_data(skb, &dump_data.data, data_size);\n\n\thci_devcd_register(hdev, vhci_coredump, vhci_coredump_hdr, NULL);\n\n\t \n\tif (dump_data.timeout)\n\t\tforce_devcd_timeout(hdev, dump_data.timeout);\n\n\tret = hci_devcd_init(hdev, skb->len);\n\tif (ret) {\n\t\tBT_ERR(\"Failed to generate devcoredump\");\n\t\tkfree_skb(skb);\n\t\treturn ret;\n\t}\n\n\thci_devcd_append(hdev, skb);\n\n\tswitch (dump_data.state) {\n\tcase HCI_DEVCOREDUMP_DONE:\n\t\thci_devcd_complete(hdev);\n\t\tbreak;\n\tcase HCI_DEVCOREDUMP_ABORT:\n\t\thci_devcd_abort(hdev);\n\t\tbreak;\n\tcase HCI_DEVCOREDUMP_TIMEOUT:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations force_devcoredump_fops = {\n\t.open\t\t= simple_open,\n\t.write\t\t= force_devcd_write,\n};\n\nstatic int __vhci_create_device(struct vhci_data *data, __u8 opcode)\n{\n\tstruct hci_dev *hdev;\n\tstruct sk_buff *skb;\n\t__u8 dev_type;\n\n\tif (data->hdev)\n\t\treturn -EBADFD;\n\n\t \n\tdev_type = opcode & 0x03;\n\n\tif (dev_type != HCI_PRIMARY && dev_type != HCI_AMP)\n\t\treturn -EINVAL;\n\n\t \n\tif (opcode & 0x3c)\n\t\treturn -EINVAL;\n\n\tskb = bt_skb_alloc(4, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tkfree_skb(skb);\n\t\treturn -ENOMEM;\n\t}\n\n\tdata->hdev = hdev;\n\n\thdev->bus = HCI_VIRTUAL;\n\thdev->dev_type = dev_type;\n\thci_set_drvdata(hdev, data);\n\n\thdev->open  = vhci_open_dev;\n\thdev->close = vhci_close_dev;\n\thdev->flush = vhci_flush;\n\thdev->send  = vhci_send_frame;\n\thdev->get_data_path_id = vhci_get_data_path_id;\n\thdev->get_codec_config_data = vhci_get_codec_config_data;\n\thdev->wakeup = vhci_wakeup;\n\thdev->setup = vhci_setup;\n\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n\n\t \n\tif (opcode & 0x40)\n\t\tset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\n\n\t \n\tif (opcode & 0x80)\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\n\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\thci_free_dev(hdev);\n\t\tdata->hdev = NULL;\n\t\tkfree_skb(skb);\n\t\treturn -EBUSY;\n\t}\n\n\tdebugfs_create_file(\"force_suspend\", 0644, hdev->debugfs, data,\n\t\t\t    &force_suspend_fops);\n\n\tdebugfs_create_file(\"force_wakeup\", 0644, hdev->debugfs, data,\n\t\t\t    &force_wakeup_fops);\n\n\tif (IS_ENABLED(CONFIG_BT_MSFTEXT))\n\t\tdebugfs_create_file(\"msft_opcode\", 0644, hdev->debugfs, data,\n\t\t\t\t    &msft_opcode_fops);\n\n\tif (IS_ENABLED(CONFIG_BT_AOSPEXT))\n\t\tdebugfs_create_file(\"aosp_capable\", 0644, hdev->debugfs, data,\n\t\t\t\t    &aosp_capable_fops);\n\n\tdebugfs_create_file(\"force_devcoredump\", 0644, hdev->debugfs, data,\n\t\t\t    &force_devcoredump_fops);\n\n\thci_skb_pkt_type(skb) = HCI_VENDOR_PKT;\n\n\tskb_put_u8(skb, 0xff);\n\tskb_put_u8(skb, opcode);\n\tput_unaligned_le16(hdev->id, skb_put(skb, 2));\n\tskb_queue_head(&data->readq, skb);\n\tatomic_inc(&data->initialized);\n\n\twake_up_interruptible(&data->read_wait);\n\treturn 0;\n}\n\nstatic int vhci_create_device(struct vhci_data *data, __u8 opcode)\n{\n\tint err;\n\n\tmutex_lock(&data->open_mutex);\n\terr = __vhci_create_device(data, opcode);\n\tmutex_unlock(&data->open_mutex);\n\n\treturn err;\n}\n\nstatic inline ssize_t vhci_get_user(struct vhci_data *data,\n\t\t\t\t    struct iov_iter *from)\n{\n\tsize_t len = iov_iter_count(from);\n\tstruct sk_buff *skb;\n\t__u8 pkt_type, opcode;\n\tint ret;\n\n\tif (len < 2 || len > HCI_MAX_FRAME_SIZE)\n\t\treturn -EINVAL;\n\n\tskb = bt_skb_alloc(len, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(skb_put(skb, len), len, from)) {\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tpkt_type = *((__u8 *) skb->data);\n\tskb_pull(skb, 1);\n\n\tswitch (pkt_type) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\tif (!data->hdev) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\thci_skb_pkt_type(skb) = pkt_type;\n\n\t\tret = hci_recv_frame(data->hdev, skb);\n\t\tbreak;\n\n\tcase HCI_VENDOR_PKT:\n\t\tcancel_delayed_work_sync(&data->open_timeout);\n\n\t\topcode = *((__u8 *) skb->data);\n\t\tskb_pull(skb, 1);\n\n\t\tif (skb->len > 0) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tkfree_skb(skb);\n\n\t\tret = vhci_create_device(data, opcode);\n\t\tbreak;\n\n\tdefault:\n\t\tkfree_skb(skb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn (ret < 0) ? ret : len;\n}\n\nstatic inline ssize_t vhci_put_user(struct vhci_data *data,\n\t\t\t\t    struct sk_buff *skb,\n\t\t\t\t    char __user *buf, int count)\n{\n\tchar __user *ptr = buf;\n\tint len;\n\n\tlen = min_t(unsigned int, skb->len, count);\n\n\tif (copy_to_user(ptr, skb->data, len))\n\t\treturn -EFAULT;\n\n\tif (!data->hdev)\n\t\treturn len;\n\n\tdata->hdev->stat.byte_tx += len;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\tdata->hdev->stat.cmd_tx++;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\tdata->hdev->stat.acl_tx++;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\tdata->hdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t vhci_read(struct file *file,\n\t\t\t char __user *buf, size_t count, loff_t *pos)\n{\n\tstruct vhci_data *data = file->private_data;\n\tstruct sk_buff *skb;\n\tssize_t ret = 0;\n\n\twhile (count) {\n\t\tskb = skb_dequeue(&data->readq);\n\t\tif (skb) {\n\t\t\tret = vhci_put_user(data, skb, buf, count);\n\t\t\tif (ret < 0)\n\t\t\t\tskb_queue_head(&data->readq, skb);\n\t\t\telse\n\t\t\t\tkfree_skb(skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = wait_event_interruptible(data->read_wait,\n\t\t\t\t\t       !skb_queue_empty(&data->readq));\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic ssize_t vhci_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct vhci_data *data = file->private_data;\n\n\treturn vhci_get_user(data, from);\n}\n\nstatic __poll_t vhci_poll(struct file *file, poll_table *wait)\n{\n\tstruct vhci_data *data = file->private_data;\n\n\tpoll_wait(file, &data->read_wait, wait);\n\n\tif (!skb_queue_empty(&data->readq))\n\t\treturn EPOLLIN | EPOLLRDNORM;\n\n\treturn EPOLLOUT | EPOLLWRNORM;\n}\n\nstatic void vhci_open_timeout(struct work_struct *work)\n{\n\tstruct vhci_data *data = container_of(work, struct vhci_data,\n\t\t\t\t\t      open_timeout.work);\n\n\tvhci_create_device(data, amp ? HCI_AMP : HCI_PRIMARY);\n}\n\nstatic int vhci_open(struct inode *inode, struct file *file)\n{\n\tstruct vhci_data *data;\n\n\tdata = kzalloc(sizeof(struct vhci_data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&data->readq);\n\tinit_waitqueue_head(&data->read_wait);\n\n\tmutex_init(&data->open_mutex);\n\tINIT_DELAYED_WORK(&data->open_timeout, vhci_open_timeout);\n\tINIT_WORK(&data->suspend_work, vhci_suspend_work);\n\n\tfile->private_data = data;\n\tnonseekable_open(inode, file);\n\n\tschedule_delayed_work(&data->open_timeout, msecs_to_jiffies(1000));\n\n\treturn 0;\n}\n\nstatic int vhci_release(struct inode *inode, struct file *file)\n{\n\tstruct vhci_data *data = file->private_data;\n\tstruct hci_dev *hdev;\n\n\tcancel_delayed_work_sync(&data->open_timeout);\n\tflush_work(&data->suspend_work);\n\n\thdev = data->hdev;\n\n\tif (hdev) {\n\t\thci_unregister_dev(hdev);\n\t\thci_free_dev(hdev);\n\t}\n\n\tskb_queue_purge(&data->readq);\n\tfile->private_data = NULL;\n\tkfree(data);\n\n\treturn 0;\n}\n\nstatic const struct file_operations vhci_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= vhci_read,\n\t.write_iter\t= vhci_write,\n\t.poll\t\t= vhci_poll,\n\t.open\t\t= vhci_open,\n\t.release\t= vhci_release,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic struct miscdevice vhci_miscdev = {\n\t.name\t= \"vhci\",\n\t.fops\t= &vhci_fops,\n\t.minor\t= VHCI_MINOR,\n};\nmodule_misc_device(vhci_miscdev);\n\nmodule_param(amp, bool, 0644);\nMODULE_PARM_DESC(amp, \"Create AMP controller device\");\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth virtual HCI driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"devname:vhci\");\nMODULE_ALIAS_MISCDEV(VHCI_MINOR);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}