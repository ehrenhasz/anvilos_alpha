{
  "module_name": "btintel.c",
  "hash_id": "ef329c14816bf03d7c47ccd998f1e31b45e715c7a63907704353e03878b60b1f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btintel.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/regmap.h>\n#include <linux/acpi.h>\n#include <acpi/acpi_bus.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btintel.h\"\n\n#define VERSION \"0.1\"\n\n#define BDADDR_INTEL\t\t(&(bdaddr_t){{0x00, 0x8b, 0x9e, 0x19, 0x03, 0x00}})\n#define RSA_HEADER_LEN\t\t644\n#define CSS_HEADER_OFFSET\t8\n#define ECDSA_OFFSET\t\t644\n#define ECDSA_HEADER_LEN\t320\n\n#define BTINTEL_PPAG_NAME   \"PPAG\"\n\nenum {\n\tDSM_SET_WDISABLE2_DELAY = 1,\n\tDSM_SET_RESET_METHOD = 3,\n};\n\n \nstruct btintel_ppag {\n\tu32\tdomain;\n\tu32     mode;\n\tacpi_status status;\n\tstruct hci_dev *hdev;\n};\n\n#define CMD_WRITE_BOOT_PARAMS\t0xfc0e\nstruct cmd_write_boot_params {\n\t__le32 boot_addr;\n\tu8  fw_build_num;\n\tu8  fw_build_ww;\n\tu8  fw_build_yy;\n} __packed;\n\nstatic struct {\n\tconst char *driver_name;\n\tu8         hw_variant;\n\tu32        fw_build_num;\n} coredump_info;\n\nstatic const guid_t btintel_guid_dsm =\n\tGUID_INIT(0xaa10f4e0, 0x81ac, 0x4233,\n\t\t  0xab, 0xf6, 0x3b, 0x2a, 0xc5, 0x0e, 0x28, 0xd9);\n\nint btintel_check_bdaddr(struct hci_dev *hdev)\n{\n\tstruct hci_rp_read_bd_addr *bda;\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_BD_ADDR, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Reading Intel device address failed (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != sizeof(*bda)) {\n\t\tbt_dev_err(hdev, \"Intel device address length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tbda = (struct hci_rp_read_bd_addr *)skb->data;\n\n\t \n\tif (!bacmp(&bda->bdaddr, BDADDR_INTEL)) {\n\t\tbt_dev_err(hdev, \"Found Intel default device address (%pMR)\",\n\t\t\t   &bda->bdaddr);\n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_check_bdaddr);\n\nint btintel_enter_mfg(struct hci_dev *hdev)\n{\n\tstatic const u8 param[] = { 0x01, 0x00 };\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc11, 2, param, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Entering manufacturer mode failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_enter_mfg);\n\nint btintel_exit_mfg(struct hci_dev *hdev, bool reset, bool patched)\n{\n\tu8 param[] = { 0x00, 0x00 };\n\tstruct sk_buff *skb;\n\n\t \n\tif (reset)\n\t\tparam[1] |= patched ? 0x02 : 0x01;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc11, 2, param, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Exiting manufacturer mode failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_exit_mfg);\n\nint btintel_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc31, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Changing Intel device address failed (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_set_bdaddr);\n\nstatic int btintel_set_event_mask(struct hci_dev *hdev, bool debug)\n{\n\tu8 mask[8] = { 0x87, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\tstruct sk_buff *skb;\n\tint err;\n\n\tif (debug)\n\t\tmask[1] |= 0x62;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc52, 8, mask, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Setting Intel event mask failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nint btintel_set_diag(struct hci_dev *hdev, bool enable)\n{\n\tstruct sk_buff *skb;\n\tu8 param[3];\n\tint err;\n\n\tif (enable) {\n\t\tparam[0] = 0x03;\n\t\tparam[1] = 0x03;\n\t\tparam[2] = 0x03;\n\t} else {\n\t\tparam[0] = 0x00;\n\t\tparam[1] = 0x00;\n\t\tparam[2] = 0x00;\n\t}\n\n\tskb = __hci_cmd_sync(hdev, 0xfc43, 3, param, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tif (err == -ENODATA)\n\t\t\tgoto done;\n\t\tbt_dev_err(hdev, \"Changing Intel diagnostic mode failed (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\ndone:\n\tbtintel_set_event_mask(hdev, enable);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_set_diag);\n\nstatic int btintel_set_diag_mfg(struct hci_dev *hdev, bool enable)\n{\n\tint err, ret;\n\n\terr = btintel_enter_mfg(hdev);\n\tif (err)\n\t\treturn err;\n\n\tret = btintel_set_diag(hdev, enable);\n\n\terr = btintel_exit_mfg(hdev, false, false);\n\tif (err)\n\t\treturn err;\n\n\treturn ret;\n}\n\nstatic int btintel_set_diag_combined(struct hci_dev *hdev, bool enable)\n{\n\tint ret;\n\n\t \n\tif (btintel_test_flag(hdev, INTEL_ROM_LEGACY))\n\t\tret = btintel_set_diag_mfg(hdev, enable);\n\telse\n\t\tret = btintel_set_diag(hdev, enable);\n\n\treturn ret;\n}\n\nstatic void btintel_hw_error(struct hci_dev *hdev, u8 code)\n{\n\tstruct sk_buff *skb;\n\tu8 type = 0x00;\n\n\tbt_dev_err(hdev, \"Hardware error 0x%2.2x\", code);\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reset after hardware error failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn;\n\t}\n\tkfree_skb(skb);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc22, 1, &type, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Retrieving Intel exception info failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn;\n\t}\n\n\tif (skb->len != 13) {\n\t\tbt_dev_err(hdev, \"Exception info size mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn;\n\t}\n\n\tbt_dev_err(hdev, \"Exception info %s\", (char *)(skb->data + 1));\n\n\tkfree_skb(skb);\n}\n\nint btintel_version_info(struct hci_dev *hdev, struct intel_version *ver)\n{\n\tconst char *variant;\n\n\t \n\tif (ver->hw_platform != 0x37) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware platform (%u)\",\n\t\t\t   ver->hw_platform);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (ver->hw_variant) {\n\tcase 0x07:\t \n\tcase 0x08:\t \n\tcase 0x0b:       \n\tcase 0x0c:       \n\tcase 0x11:       \n\tcase 0x12:       \n\tcase 0x13:       \n\tcase 0x14:       \n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant (%u)\",\n\t\t\t   ver->hw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ver->fw_variant) {\n\tcase 0x01:\n\t\tvariant = \"Legacy ROM 2.5\";\n\t\tbreak;\n\tcase 0x06:\n\t\tvariant = \"Bootloader\";\n\t\tbreak;\n\tcase 0x22:\n\t\tvariant = \"Legacy ROM 2.x\";\n\t\tbreak;\n\tcase 0x23:\n\t\tvariant = \"Firmware\";\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported firmware variant(%02x)\", ver->fw_variant);\n\t\treturn -EINVAL;\n\t}\n\n\tcoredump_info.hw_variant = ver->hw_variant;\n\tcoredump_info.fw_build_num = ver->fw_build_num;\n\n\tbt_dev_info(hdev, \"%s revision %u.%u build %u week %u %u\",\n\t\t    variant, ver->fw_revision >> 4, ver->fw_revision & 0x0f,\n\t\t    ver->fw_build_num, ver->fw_build_ww,\n\t\t    2000 + ver->fw_build_yy);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_version_info);\n\nstatic int btintel_secure_send(struct hci_dev *hdev, u8 fragment_type, u32 plen,\n\t\t\t       const void *param)\n{\n\twhile (plen > 0) {\n\t\tstruct sk_buff *skb;\n\t\tu8 cmd_param[253], fragment_len = (plen > 252) ? 252 : plen;\n\n\t\tcmd_param[0] = fragment_type;\n\t\tmemcpy(cmd_param + 1, param, fragment_len);\n\n\t\tskb = __hci_cmd_sync(hdev, 0xfc09, fragment_len + 1,\n\t\t\t\t     cmd_param, HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\tkfree_skb(skb);\n\n\t\tplen -= fragment_len;\n\t\tparam += fragment_len;\n\t}\n\n\treturn 0;\n}\n\nint btintel_load_ddc_config(struct hci_dev *hdev, const char *ddc_name)\n{\n\tconst struct firmware *fw;\n\tstruct sk_buff *skb;\n\tconst u8 *fw_ptr;\n\tint err;\n\n\terr = request_firmware_direct(&fw, ddc_name, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to load Intel DDC file %s (%d)\",\n\t\t\t   ddc_name, err);\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"Found Intel DDC parameters: %s\", ddc_name);\n\n\tfw_ptr = fw->data;\n\n\t \n\twhile (fw->size > fw_ptr - fw->data) {\n\t\tu8 cmd_plen = fw_ptr[0] + sizeof(u8);\n\n\t\tskb = __hci_cmd_sync(hdev, 0xfc8b, cmd_plen, fw_ptr,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\tbt_dev_err(hdev, \"Failed to send Intel_Write_DDC (%ld)\",\n\t\t\t\t   PTR_ERR(skb));\n\t\t\trelease_firmware(fw);\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\n\t\tfw_ptr += cmd_plen;\n\t\tkfree_skb(skb);\n\t}\n\n\trelease_firmware(fw);\n\n\tbt_dev_info(hdev, \"Applying Intel DDC parameters completed\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_load_ddc_config);\n\nint btintel_set_event_mask_mfg(struct hci_dev *hdev, bool debug)\n{\n\tint err, ret;\n\n\terr = btintel_enter_mfg(hdev);\n\tif (err)\n\t\treturn err;\n\n\tret = btintel_set_event_mask(hdev, debug);\n\n\terr = btintel_exit_mfg(hdev, false, false);\n\tif (err)\n\t\treturn err;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btintel_set_event_mask_mfg);\n\nint btintel_read_version(struct hci_dev *hdev, struct intel_version *ver)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc05, 0, NULL, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading Intel version information failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tbt_dev_err(hdev, \"Intel version event size mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EILSEQ;\n\t}\n\n\tmemcpy(ver, skb->data, sizeof(*ver));\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_read_version);\n\nstatic int btintel_version_info_tlv(struct hci_dev *hdev,\n\t\t\t\t    struct intel_version_tlv *version)\n{\n\tconst char *variant;\n\n\t \n\tif (INTEL_HW_PLATFORM(version->cnvi_bt) != 0x37) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware platform (0x%2x)\",\n\t\t\t   INTEL_HW_PLATFORM(version->cnvi_bt));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tswitch (INTEL_HW_VARIANT(version->cnvi_bt)) {\n\tcase 0x17:\t \n\tcase 0x18:\t \n\tcase 0x19:\t \n\tcase 0x1b:       \n\tcase 0x1c:\t \n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware variant (0x%x)\",\n\t\t\t   INTEL_HW_VARIANT(version->cnvi_bt));\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (version->img_type) {\n\tcase 0x01:\n\t\tvariant = \"Bootloader\";\n\t\t \n\t\tif (version->limited_cce != 0x00) {\n\t\t\tbt_dev_err(hdev, \"Unsupported Intel firmware loading method (0x%x)\",\n\t\t\t\t   version->limited_cce);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tif (version->sbe_type > 0x01) {\n\t\t\tbt_dev_err(hdev, \"Unsupported Intel secure boot engine type (0x%x)\",\n\t\t\t\t   version->sbe_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tbt_dev_info(hdev, \"Device revision is %u\", version->dev_rev_id);\n\t\tbt_dev_info(hdev, \"Secure boot is %s\",\n\t\t\t    version->secure_boot ? \"enabled\" : \"disabled\");\n\t\tbt_dev_info(hdev, \"OTP lock is %s\",\n\t\t\t    version->otp_lock ? \"enabled\" : \"disabled\");\n\t\tbt_dev_info(hdev, \"API lock is %s\",\n\t\t\t    version->api_lock ? \"enabled\" : \"disabled\");\n\t\tbt_dev_info(hdev, \"Debug lock is %s\",\n\t\t\t    version->debug_lock ? \"enabled\" : \"disabled\");\n\t\tbt_dev_info(hdev, \"Minimum firmware build %u week %u %u\",\n\t\t\t    version->min_fw_build_nn, version->min_fw_build_cw,\n\t\t\t    2000 + version->min_fw_build_yy);\n\t\tbreak;\n\tcase 0x03:\n\t\tvariant = \"Firmware\";\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported image type(%02x)\", version->img_type);\n\t\treturn -EINVAL;\n\t}\n\n\tcoredump_info.hw_variant = INTEL_HW_VARIANT(version->cnvi_bt);\n\tcoredump_info.fw_build_num = version->build_num;\n\n\tbt_dev_info(hdev, \"%s timestamp %u.%u buildtype %u build %u\", variant,\n\t\t    2000 + (version->timestamp >> 8), version->timestamp & 0xff,\n\t\t    version->build_type, version->build_num);\n\n\treturn 0;\n}\n\nstatic int btintel_parse_version_tlv(struct hci_dev *hdev,\n\t\t\t\t     struct intel_version_tlv *version,\n\t\t\t\t     struct sk_buff *skb)\n{\n\t \n\tskb_pull(skb, 1);\n\n\t \n\twhile (skb->len) {\n\t\tstruct intel_tlv *tlv;\n\n\t\t \n\t\tif (skb->len < sizeof(*tlv))\n\t\t\treturn -EINVAL;\n\n\t\ttlv = (struct intel_tlv *)skb->data;\n\n\t\t \n\t\tif (skb->len < tlv->len + sizeof(*tlv))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (tlv->type) {\n\t\tcase INTEL_TLV_CNVI_TOP:\n\t\t\tversion->cnvi_top = get_unaligned_le32(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_CNVR_TOP:\n\t\t\tversion->cnvr_top = get_unaligned_le32(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_CNVI_BT:\n\t\t\tversion->cnvi_bt = get_unaligned_le32(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_CNVR_BT:\n\t\t\tversion->cnvr_bt = get_unaligned_le32(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_DEV_REV_ID:\n\t\t\tversion->dev_rev_id = get_unaligned_le16(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_IMAGE_TYPE:\n\t\t\tversion->img_type = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_TIME_STAMP:\n\t\t\t \n\t\t\tversion->min_fw_build_cw = tlv->val[0];\n\t\t\tversion->min_fw_build_yy = tlv->val[1];\n\t\t\tversion->timestamp = get_unaligned_le16(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_BUILD_TYPE:\n\t\t\tversion->build_type = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_BUILD_NUM:\n\t\t\t \n\t\t\tversion->min_fw_build_nn = tlv->val[0];\n\t\t\tversion->build_num = get_unaligned_le32(tlv->val);\n\t\t\tbreak;\n\t\tcase INTEL_TLV_SECURE_BOOT:\n\t\t\tversion->secure_boot = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_OTP_LOCK:\n\t\t\tversion->otp_lock = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_API_LOCK:\n\t\t\tversion->api_lock = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_DEBUG_LOCK:\n\t\t\tversion->debug_lock = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_MIN_FW:\n\t\t\tversion->min_fw_build_nn = tlv->val[0];\n\t\t\tversion->min_fw_build_cw = tlv->val[1];\n\t\t\tversion->min_fw_build_yy = tlv->val[2];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_LIMITED_CCE:\n\t\t\tversion->limited_cce = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_SBE_TYPE:\n\t\t\tversion->sbe_type = tlv->val[0];\n\t\t\tbreak;\n\t\tcase INTEL_TLV_OTP_BDADDR:\n\t\t\tmemcpy(&version->otp_bd_addr, tlv->val,\n\t\t\t\t\t\t\tsizeof(bdaddr_t));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tskb_pull(skb, tlv->len + sizeof(*tlv));\n\t}\n\n\treturn 0;\n}\n\nstatic int btintel_read_version_tlv(struct hci_dev *hdev,\n\t\t\t\t    struct intel_version_tlv *version)\n{\n\tstruct sk_buff *skb;\n\tconst u8 param[1] = { 0xFF };\n\n\tif (!version)\n\t\treturn -EINVAL;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc05, 1, param, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading Intel version information failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->data[0]) {\n\t\tbt_dev_err(hdev, \"Intel Read Version command failed (%02x)\",\n\t\t\t   skb->data[0]);\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tbtintel_parse_version_tlv(hdev, version, skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \n\n#define IBT_REG_MODE_8BIT  0x00\n#define IBT_REG_MODE_16BIT 0x01\n#define IBT_REG_MODE_32BIT 0x02\n\nstruct regmap_ibt_context {\n\tstruct hci_dev *hdev;\n\t__u16 op_write;\n\t__u16 op_read;\n};\n\nstruct ibt_cp_reg_access {\n\t__le32  addr;\n\t__u8    mode;\n\t__u8    len;\n\t__u8    data[];\n} __packed;\n\nstruct ibt_rp_reg_access {\n\t__u8    status;\n\t__le32  addr;\n\t__u8    data[];\n} __packed;\n\nstatic int regmap_ibt_read(void *context, const void *addr, size_t reg_size,\n\t\t\t   void *val, size_t val_size)\n{\n\tstruct regmap_ibt_context *ctx = context;\n\tstruct ibt_cp_reg_access cp;\n\tstruct ibt_rp_reg_access *rp;\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tif (reg_size != sizeof(__le32))\n\t\treturn -EINVAL;\n\n\tswitch (val_size) {\n\tcase 1:\n\t\tcp.mode = IBT_REG_MODE_8BIT;\n\t\tbreak;\n\tcase 2:\n\t\tcp.mode = IBT_REG_MODE_16BIT;\n\t\tbreak;\n\tcase 4:\n\t\tcp.mode = IBT_REG_MODE_32BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tcp.addr = *(__le32 *)addr;\n\tcp.len = val_size;\n\n\tbt_dev_dbg(ctx->hdev, \"Register (0x%x) read\", le32_to_cpu(cp.addr));\n\n\tskb = hci_cmd_sync(ctx->hdev, ctx->op_read, sizeof(cp), &cp,\n\t\t\t   HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(ctx->hdev, \"regmap: Register (0x%x) read error (%d)\",\n\t\t\t   le32_to_cpu(cp.addr), err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != sizeof(*rp) + val_size) {\n\t\tbt_dev_err(ctx->hdev, \"regmap: Register (0x%x) read error, bad len\",\n\t\t\t   le32_to_cpu(cp.addr));\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\trp = (struct ibt_rp_reg_access *)skb->data;\n\n\tif (rp->addr != cp.addr) {\n\t\tbt_dev_err(ctx->hdev, \"regmap: Register (0x%x) read error, bad addr\",\n\t\t\t   le32_to_cpu(rp->addr));\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmemcpy(val, rp->data, val_size);\n\ndone:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int regmap_ibt_gather_write(void *context,\n\t\t\t\t   const void *addr, size_t reg_size,\n\t\t\t\t   const void *val, size_t val_size)\n{\n\tstruct regmap_ibt_context *ctx = context;\n\tstruct ibt_cp_reg_access *cp;\n\tstruct sk_buff *skb;\n\tint plen = sizeof(*cp) + val_size;\n\tu8 mode;\n\tint err = 0;\n\n\tif (reg_size != sizeof(__le32))\n\t\treturn -EINVAL;\n\n\tswitch (val_size) {\n\tcase 1:\n\t\tmode = IBT_REG_MODE_8BIT;\n\t\tbreak;\n\tcase 2:\n\t\tmode = IBT_REG_MODE_16BIT;\n\t\tbreak;\n\tcase 4:\n\t\tmode = IBT_REG_MODE_32BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tcp = kmalloc(plen, GFP_KERNEL);\n\tif (!cp)\n\t\treturn -ENOMEM;\n\n\t \n\tcp->addr = *(__le32 *)addr;\n\tcp->mode = mode;\n\tcp->len = val_size;\n\tmemcpy(&cp->data, val, val_size);\n\n\tbt_dev_dbg(ctx->hdev, \"Register (0x%x) write\", le32_to_cpu(cp->addr));\n\n\tskb = hci_cmd_sync(ctx->hdev, ctx->op_write, plen, cp, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(ctx->hdev, \"regmap: Register (0x%x) write error (%d)\",\n\t\t\t   le32_to_cpu(cp->addr), err);\n\t\tgoto done;\n\t}\n\tkfree_skb(skb);\n\ndone:\n\tkfree(cp);\n\treturn err;\n}\n\nstatic int regmap_ibt_write(void *context, const void *data, size_t count)\n{\n\t \n\tif (WARN_ONCE(count < 4, \"Invalid register access\"))\n\t\treturn -EINVAL;\n\n\treturn regmap_ibt_gather_write(context, data, 4, data + 4, count - 4);\n}\n\nstatic void regmap_ibt_free_context(void *context)\n{\n\tkfree(context);\n}\n\nstatic const struct regmap_bus regmap_ibt = {\n\t.read = regmap_ibt_read,\n\t.write = regmap_ibt_write,\n\t.gather_write = regmap_ibt_gather_write,\n\t.free_context = regmap_ibt_free_context,\n\t.reg_format_endian_default = REGMAP_ENDIAN_LITTLE,\n\t.val_format_endian_default = REGMAP_ENDIAN_LITTLE,\n};\n\n \nstatic const struct regmap_config regmap_ibt_cfg = {\n\t.name      = \"btintel_regmap\",\n\t.reg_bits  = 32,\n\t.val_bits  = 32,\n};\n\nstruct regmap *btintel_regmap_init(struct hci_dev *hdev, u16 opcode_read,\n\t\t\t\t   u16 opcode_write)\n{\n\tstruct regmap_ibt_context *ctx;\n\n\tbt_dev_info(hdev, \"regmap: Init R%x-W%x region\", opcode_read,\n\t\t    opcode_write);\n\n\tctx = kzalloc(sizeof(*ctx), GFP_KERNEL);\n\tif (!ctx)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tctx->op_read = opcode_read;\n\tctx->op_write = opcode_write;\n\tctx->hdev = hdev;\n\n\treturn regmap_init(&hdev->dev, &regmap_ibt, ctx, &regmap_ibt_cfg);\n}\nEXPORT_SYMBOL_GPL(btintel_regmap_init);\n\nint btintel_send_intel_reset(struct hci_dev *hdev, u32 boot_param)\n{\n\tstruct intel_reset params = { 0x00, 0x01, 0x00, 0x01, 0x00000000 };\n\tstruct sk_buff *skb;\n\n\tparams.boot_param = cpu_to_le32(boot_param);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc01, sizeof(params), &params,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Failed to send Intel Reset command\");\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_send_intel_reset);\n\nint btintel_read_boot_params(struct hci_dev *hdev,\n\t\t\t     struct intel_boot_params *params)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc0d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading Intel boot parameters failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->len != sizeof(*params)) {\n\t\tbt_dev_err(hdev, \"Intel boot parameters size mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EILSEQ;\n\t}\n\n\tmemcpy(params, skb->data, sizeof(*params));\n\n\tkfree_skb(skb);\n\n\tif (params->status) {\n\t\tbt_dev_err(hdev, \"Intel boot parameters command failed (%02x)\",\n\t\t\t   params->status);\n\t\treturn -bt_to_errno(params->status);\n\t}\n\n\tbt_dev_info(hdev, \"Device revision is %u\",\n\t\t    le16_to_cpu(params->dev_revid));\n\n\tbt_dev_info(hdev, \"Secure boot is %s\",\n\t\t    params->secure_boot ? \"enabled\" : \"disabled\");\n\n\tbt_dev_info(hdev, \"OTP lock is %s\",\n\t\t    params->otp_lock ? \"enabled\" : \"disabled\");\n\n\tbt_dev_info(hdev, \"API lock is %s\",\n\t\t    params->api_lock ? \"enabled\" : \"disabled\");\n\n\tbt_dev_info(hdev, \"Debug lock is %s\",\n\t\t    params->debug_lock ? \"enabled\" : \"disabled\");\n\n\tbt_dev_info(hdev, \"Minimum firmware build %u week %u %u\",\n\t\t    params->min_fw_build_nn, params->min_fw_build_cw,\n\t\t    2000 + params->min_fw_build_yy);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_read_boot_params);\n\nstatic int btintel_sfi_rsa_header_secure_send(struct hci_dev *hdev,\n\t\t\t\t\t      const struct firmware *fw)\n{\n\tint err;\n\n\t \n\terr = btintel_secure_send(hdev, 0x00, 128, fw->data);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware header (%d)\", err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = btintel_secure_send(hdev, 0x03, 256, fw->data + 128);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware pkey (%d)\", err);\n\t\tgoto done;\n\t}\n\n\t \n\terr = btintel_secure_send(hdev, 0x02, 256, fw->data + 388);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware signature (%d)\", err);\n\t\tgoto done;\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic int btintel_sfi_ecdsa_header_secure_send(struct hci_dev *hdev,\n\t\t\t\t\t\tconst struct firmware *fw)\n{\n\tint err;\n\n\t \n\terr = btintel_secure_send(hdev, 0x00, 128, fw->data + 644);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware header (%d)\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = btintel_secure_send(hdev, 0x03, 96, fw->data + 644 + 128);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware pkey (%d)\", err);\n\t\treturn err;\n\t}\n\n\t \n\terr = btintel_secure_send(hdev, 0x02, 96, fw->data + 644 + 224);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to send firmware signature (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\treturn 0;\n}\n\nstatic int btintel_download_firmware_payload(struct hci_dev *hdev,\n\t\t\t\t\t     const struct firmware *fw,\n\t\t\t\t\t     size_t offset)\n{\n\tint err;\n\tconst u8 *fw_ptr;\n\tu32 frag_len;\n\n\tfw_ptr = fw->data + offset;\n\tfrag_len = 0;\n\terr = -EINVAL;\n\n\twhile (fw_ptr - fw->data < fw->size) {\n\t\tstruct hci_command_hdr *cmd = (void *)(fw_ptr + frag_len);\n\n\t\tfrag_len += sizeof(*cmd) + cmd->plen;\n\n\t\t \n\t\tif (!(frag_len % 4)) {\n\t\t\terr = btintel_secure_send(hdev, 0x01, frag_len, fw_ptr);\n\t\t\tif (err < 0) {\n\t\t\t\tbt_dev_err(hdev,\n\t\t\t\t\t   \"Failed to send firmware data (%d)\",\n\t\t\t\t\t   err);\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tfw_ptr += frag_len;\n\t\t\tfrag_len = 0;\n\t\t}\n\t}\n\ndone:\n\treturn err;\n}\n\nstatic bool btintel_firmware_version(struct hci_dev *hdev,\n\t\t\t\t     u8 num, u8 ww, u8 yy,\n\t\t\t\t     const struct firmware *fw,\n\t\t\t\t     u32 *boot_addr)\n{\n\tconst u8 *fw_ptr;\n\n\tfw_ptr = fw->data;\n\n\twhile (fw_ptr - fw->data < fw->size) {\n\t\tstruct hci_command_hdr *cmd = (void *)(fw_ptr);\n\n\t\t \n\t\tif (le16_to_cpu(cmd->opcode) == CMD_WRITE_BOOT_PARAMS) {\n\t\t\tstruct cmd_write_boot_params *params;\n\n\t\t\tparams = (void *)(fw_ptr + sizeof(*cmd));\n\n\t\t\t*boot_addr = le32_to_cpu(params->boot_addr);\n\n\t\t\tbt_dev_info(hdev, \"Boot Address: 0x%x\", *boot_addr);\n\n\t\t\tbt_dev_info(hdev, \"Firmware Version: %u-%u.%u\",\n\t\t\t\t    params->fw_build_num, params->fw_build_ww,\n\t\t\t\t    params->fw_build_yy);\n\n\t\t\treturn (num == params->fw_build_num &&\n\t\t\t\tww == params->fw_build_ww &&\n\t\t\t\tyy == params->fw_build_yy);\n\t\t}\n\n\t\tfw_ptr += sizeof(*cmd) + cmd->plen;\n\t}\n\n\treturn false;\n}\n\nint btintel_download_firmware(struct hci_dev *hdev,\n\t\t\t      struct intel_version *ver,\n\t\t\t      const struct firmware *fw,\n\t\t\t      u32 *boot_param)\n{\n\tint err;\n\n\t \n\tswitch (ver->hw_variant) {\n\tcase 0x0b:\t \n\tcase 0x0c:\t \n\t\t \n\t\tbreak;\n\tdefault:\n\n\t\t \n\t\tif (btintel_firmware_version(hdev, ver->fw_build_num,\n\t\t\t\t\t     ver->fw_build_ww, ver->fw_build_yy,\n\t\t\t\t\t     fw, boot_param)) {\n\t\t\tbt_dev_info(hdev, \"Firmware already loaded\");\n\t\t\t \n\t\t\treturn -EALREADY;\n\t\t}\n\t}\n\n\t \n\tif (ver->fw_variant == 0x23)\n\t\treturn -EINVAL;\n\n\terr = btintel_sfi_rsa_header_secure_send(hdev, fw);\n\tif (err)\n\t\treturn err;\n\n\treturn btintel_download_firmware_payload(hdev, fw, RSA_HEADER_LEN);\n}\nEXPORT_SYMBOL_GPL(btintel_download_firmware);\n\nstatic int btintel_download_fw_tlv(struct hci_dev *hdev,\n\t\t\t\t   struct intel_version_tlv *ver,\n\t\t\t\t   const struct firmware *fw, u32 *boot_param,\n\t\t\t\t   u8 hw_variant, u8 sbe_type)\n{\n\tint err;\n\tu32 css_header_ver;\n\n\t \n\tif (btintel_firmware_version(hdev, ver->min_fw_build_nn,\n\t\t\t\t     ver->min_fw_build_cw,\n\t\t\t\t     ver->min_fw_build_yy,\n\t\t\t\t     fw, boot_param)) {\n\t\tbt_dev_info(hdev, \"Firmware already loaded\");\n\t\t \n\t\treturn -EALREADY;\n\t}\n\n\t \n\tif (ver->img_type == 0x03)\n\t\treturn -EINVAL;\n\n\t \n\tcss_header_ver = get_unaligned_le32(fw->data + CSS_HEADER_OFFSET);\n\tif (css_header_ver != 0x00010000) {\n\t\tbt_dev_err(hdev, \"Invalid CSS Header version\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hw_variant <= 0x14) {\n\t\tif (sbe_type != 0x00) {\n\t\t\tbt_dev_err(hdev, \"Invalid SBE type for hardware variant (%d)\",\n\t\t\t\t   hw_variant);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\terr = btintel_sfi_rsa_header_secure_send(hdev, fw);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = btintel_download_firmware_payload(hdev, fw, RSA_HEADER_LEN);\n\t\tif (err)\n\t\t\treturn err;\n\t} else if (hw_variant >= 0x17) {\n\t\t \n\t\tif (fw->data[ECDSA_OFFSET] != 0x06)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tcss_header_ver = get_unaligned_le32(fw->data + ECDSA_OFFSET + CSS_HEADER_OFFSET);\n\t\tif (css_header_ver != 0x00020000) {\n\t\t\tbt_dev_err(hdev, \"Invalid CSS Header version\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (sbe_type == 0x00) {\n\t\t\terr = btintel_sfi_rsa_header_secure_send(hdev, fw);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = btintel_download_firmware_payload(hdev, fw,\n\t\t\t\t\t\t\t\tRSA_HEADER_LEN + ECDSA_HEADER_LEN);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else if (sbe_type == 0x01) {\n\t\t\terr = btintel_sfi_ecdsa_header_secure_send(hdev, fw);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t\terr = btintel_download_firmware_payload(hdev, fw,\n\t\t\t\t\t\t\t\tRSA_HEADER_LEN + ECDSA_HEADER_LEN);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void btintel_reset_to_bootloader(struct hci_dev *hdev)\n{\n\tstruct intel_reset params;\n\tstruct sk_buff *skb;\n\n\t \n\tparams.reset_type = 0x01;\n\tparams.patch_enable = 0x01;\n\tparams.ddc_reload = 0x01;\n\tparams.boot_option = 0x00;\n\tparams.boot_param = cpu_to_le32(0x00000000);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc01, sizeof(params),\n\t\t\t     &params, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"FW download error recovery failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn;\n\t}\n\tbt_dev_info(hdev, \"Intel reset sent to retry FW download\");\n\tkfree_skb(skb);\n\n\t \n\tmsleep(150);\n}\n\nstatic int btintel_read_debug_features(struct hci_dev *hdev,\n\t\t\t\t       struct intel_debug_features *features)\n{\n\tstruct sk_buff *skb;\n\tu8 page_no = 1;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfca6, sizeof(page_no), &page_no,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading supported features failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->len != (sizeof(features->page1) + 3)) {\n\t\tbt_dev_err(hdev, \"Supported features event size mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EILSEQ;\n\t}\n\n\tmemcpy(features->page1, skb->data + 3, sizeof(features->page1));\n\n\t \n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic acpi_status btintel_ppag_callback(acpi_handle handle, u32 lvl, void *data,\n\t\t\t\t\t void **ret)\n{\n\tacpi_status status;\n\tsize_t len;\n\tstruct btintel_ppag *ppag = data;\n\tunion acpi_object *p, *elements;\n\tstruct acpi_buffer string = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};\n\tstruct hci_dev *hdev = ppag->hdev;\n\n\tstatus = acpi_get_name(handle, ACPI_FULL_PATHNAME, &string);\n\tif (ACPI_FAILURE(status)) {\n\t\tbt_dev_warn(hdev, \"PPAG-BT: ACPI Failure: %s\", acpi_format_exception(status));\n\t\treturn status;\n\t}\n\n\tlen = strlen(string.pointer);\n\tif (len < strlen(BTINTEL_PPAG_NAME)) {\n\t\tkfree(string.pointer);\n\t\treturn AE_OK;\n\t}\n\n\tif (strncmp((char *)string.pointer + len - 4, BTINTEL_PPAG_NAME, 4)) {\n\t\tkfree(string.pointer);\n\t\treturn AE_OK;\n\t}\n\tkfree(string.pointer);\n\n\tstatus = acpi_evaluate_object(handle, NULL, NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tppag->status = status;\n\t\tbt_dev_warn(hdev, \"PPAG-BT: ACPI Failure: %s\", acpi_format_exception(status));\n\t\treturn status;\n\t}\n\n\tp = buffer.pointer;\n\tppag = (struct btintel_ppag *)data;\n\n\tif (p->type != ACPI_TYPE_PACKAGE || p->package.count != 2) {\n\t\tkfree(buffer.pointer);\n\t\tbt_dev_warn(hdev, \"PPAG-BT: Invalid object type: %d or package count: %d\",\n\t\t\t    p->type, p->package.count);\n\t\tppag->status = AE_ERROR;\n\t\treturn AE_ERROR;\n\t}\n\n\telements = p->package.elements;\n\n\t \n\tp = &elements[1];\n\n\tppag->domain = (u32)p->package.elements[0].integer.value;\n\tppag->mode = (u32)p->package.elements[1].integer.value;\n\tppag->status = AE_OK;\n\tkfree(buffer.pointer);\n\treturn AE_CTRL_TERMINATE;\n}\n\nstatic int btintel_set_debug_features(struct hci_dev *hdev,\n\t\t\t       const struct intel_debug_features *features)\n{\n\tu8 mask[11] = { 0x0a, 0x92, 0x02, 0x7f, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00 };\n\tu8 period[5] = { 0x04, 0x91, 0x02, 0x05, 0x00 };\n\tu8 trace_enable = 0x02;\n\tstruct sk_buff *skb;\n\n\tif (!features) {\n\t\tbt_dev_warn(hdev, \"Debug features not read\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(features->page1[0] & 0x3f)) {\n\t\tbt_dev_info(hdev, \"Telemetry exception format not supported\");\n\t\treturn 0;\n\t}\n\n\tskb = __hci_cmd_sync(hdev, 0xfc8b, 11, mask, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting Intel telemetry ddc write event mask failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc8b, 5, period, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting periodicity for link statistics traces failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tskb = __hci_cmd_sync(hdev, 0xfca1, 1, &trace_enable, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Enable tracing of link statistics events failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tbt_dev_info(hdev, \"set debug features: trace_enable 0x%02x mask 0x%02x\",\n\t\t    trace_enable, mask[3]);\n\n\treturn 0;\n}\n\nstatic int btintel_reset_debug_features(struct hci_dev *hdev,\n\t\t\t\t const struct intel_debug_features *features)\n{\n\tu8 mask[11] = { 0x0a, 0x92, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t0x00, 0x00, 0x00 };\n\tu8 trace_enable = 0x00;\n\tstruct sk_buff *skb;\n\n\tif (!features) {\n\t\tbt_dev_warn(hdev, \"Debug features not read\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(features->page1[0] & 0x3f)) {\n\t\tbt_dev_info(hdev, \"Telemetry exception format not supported\");\n\t\treturn 0;\n\t}\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfca1, 1, &trace_enable, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Stop tracing of link statistics events failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tskb = __hci_cmd_sync(hdev, 0xfc8b, 11, mask, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting Intel telemetry ddc write event mask failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\tbt_dev_info(hdev, \"reset debug features: trace_enable 0x%02x mask 0x%02x\",\n\t\t    trace_enable, mask[3]);\n\n\treturn 0;\n}\n\nint btintel_set_quality_report(struct hci_dev *hdev, bool enable)\n{\n\tstruct intel_debug_features features;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"enable %d\", enable);\n\n\t \n\terr = btintel_read_debug_features(hdev, &features);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (enable)\n\t\terr = btintel_set_debug_features(hdev, &features);\n\telse\n\t\terr = btintel_reset_debug_features(hdev, &features);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(btintel_set_quality_report);\n\nstatic void btintel_coredump(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc4e, 0, NULL, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Coredump failed (%ld)\", PTR_ERR(skb));\n\t\treturn;\n\t}\n\n\tkfree_skb(skb);\n}\n\nstatic void btintel_dmp_hdr(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tchar buf[80];\n\n\tsnprintf(buf, sizeof(buf), \"Controller Name: 0x%X\\n\",\n\t\t coredump_info.hw_variant);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Firmware Version: 0x%X\\n\",\n\t\t coredump_info.fw_build_num);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Driver: %s\\n\", coredump_info.driver_name);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Vendor: Intel\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n}\n\nstatic int btintel_register_devcoredump_support(struct hci_dev *hdev)\n{\n\tstruct intel_debug_features features;\n\tint err;\n\n\terr = btintel_read_debug_features(hdev, &features);\n\tif (err) {\n\t\tbt_dev_info(hdev, \"Error reading debug features\");\n\t\treturn err;\n\t}\n\n\tif (!(features.page1[0] & 0x3f)) {\n\t\tbt_dev_dbg(hdev, \"Telemetry exception format not supported\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\thci_devcd_register(hdev, btintel_coredump, btintel_dmp_hdr, NULL);\n\n\treturn err;\n}\n\nstatic const struct firmware *btintel_legacy_rom_get_fw(struct hci_dev *hdev,\n\t\t\t\t\t       struct intel_version *ver)\n{\n\tconst struct firmware *fw;\n\tchar fwname[64];\n\tint ret;\n\n\tsnprintf(fwname, sizeof(fwname),\n\t\t \"intel/ibt-hw-%x.%x.%x-fw-%x.%x.%x.%x.%x.bseq\",\n\t\t ver->hw_platform, ver->hw_variant, ver->hw_revision,\n\t\t ver->fw_variant,  ver->fw_revision, ver->fw_build_num,\n\t\t ver->fw_build_ww, ver->fw_build_yy);\n\n\tret = request_firmware(&fw, fwname, &hdev->dev);\n\tif (ret < 0) {\n\t\tif (ret == -EINVAL) {\n\t\t\tbt_dev_err(hdev, \"Intel firmware file request failed (%d)\",\n\t\t\t\t   ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbt_dev_err(hdev, \"failed to open Intel firmware file: %s (%d)\",\n\t\t\t   fwname, ret);\n\n\t\t \n\t\tsnprintf(fwname, sizeof(fwname), \"intel/ibt-hw-%x.%x.bseq\",\n\t\t\t ver->hw_platform, ver->hw_variant);\n\t\tif (request_firmware(&fw, fwname, &hdev->dev) < 0) {\n\t\t\tbt_dev_err(hdev, \"failed to open default fw file: %s\",\n\t\t\t\t   fwname);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tbt_dev_info(hdev, \"Intel Bluetooth firmware file: %s\", fwname);\n\n\treturn fw;\n}\n\nstatic int btintel_legacy_rom_patching(struct hci_dev *hdev,\n\t\t\t\t      const struct firmware *fw,\n\t\t\t\t      const u8 **fw_ptr, int *disable_patch)\n{\n\tstruct sk_buff *skb;\n\tstruct hci_command_hdr *cmd;\n\tconst u8 *cmd_param;\n\tstruct hci_event_hdr *evt = NULL;\n\tconst u8 *evt_param = NULL;\n\tint remain = fw->size - (*fw_ptr - fw->data);\n\n\t \n\tif (remain > HCI_COMMAND_HDR_SIZE && *fw_ptr[0] != 0x01) {\n\t\tbt_dev_err(hdev, \"Intel fw corrupted: invalid cmd read\");\n\t\treturn -EINVAL;\n\t}\n\t(*fw_ptr)++;\n\tremain--;\n\n\tcmd = (struct hci_command_hdr *)(*fw_ptr);\n\t*fw_ptr += sizeof(*cmd);\n\tremain -= sizeof(*cmd);\n\n\t \n\tif (remain < cmd->plen) {\n\t\tbt_dev_err(hdev, \"Intel fw corrupted: invalid cmd len\");\n\t\treturn -EFAULT;\n\t}\n\n\t \n\tif (*disable_patch && le16_to_cpu(cmd->opcode) == 0xfc8e)\n\t\t*disable_patch = 0;\n\n\tcmd_param = *fw_ptr;\n\t*fw_ptr += cmd->plen;\n\tremain -= cmd->plen;\n\n\t \n\twhile (remain > HCI_EVENT_HDR_SIZE && *fw_ptr[0] == 0x02) {\n\t\t(*fw_ptr)++;\n\t\tremain--;\n\n\t\tevt = (struct hci_event_hdr *)(*fw_ptr);\n\t\t*fw_ptr += sizeof(*evt);\n\t\tremain -= sizeof(*evt);\n\n\t\tif (remain < evt->plen) {\n\t\t\tbt_dev_err(hdev, \"Intel fw corrupted: invalid evt len\");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tevt_param = *fw_ptr;\n\t\t*fw_ptr += evt->plen;\n\t\tremain -= evt->plen;\n\t}\n\n\t \n\tif (!evt || !evt_param || remain < 0) {\n\t\tbt_dev_err(hdev, \"Intel fw corrupted: invalid evt read\");\n\t\treturn -EFAULT;\n\t}\n\n\tskb = __hci_cmd_sync_ev(hdev, le16_to_cpu(cmd->opcode), cmd->plen,\n\t\t\t\tcmd_param, evt->evt, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"sending Intel patch command (0x%4.4x) failed (%ld)\",\n\t\t\t   cmd->opcode, PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\t \n\tif (skb->len != evt->plen) {\n\t\tbt_dev_err(hdev, \"mismatch event length (opcode 0x%4.4x)\",\n\t\t\t   le16_to_cpu(cmd->opcode));\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (memcmp(skb->data, evt_param, evt->plen)) {\n\t\tbt_dev_err(hdev, \"mismatch event parameter (opcode 0x%4.4x)\",\n\t\t\t   le16_to_cpu(cmd->opcode));\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int btintel_legacy_rom_setup(struct hci_dev *hdev,\n\t\t\t\t    struct intel_version *ver)\n{\n\tconst struct firmware *fw;\n\tconst u8 *fw_ptr;\n\tint disable_patch, err;\n\tstruct intel_version new_ver;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\t \n\tif (ver->fw_patch_num) {\n\t\tbt_dev_info(hdev,\n\t\t\t    \"Intel device is already patched. patch num: %02x\",\n\t\t\t    ver->fw_patch_num);\n\t\tgoto complete;\n\t}\n\n\t \n\tfw = btintel_legacy_rom_get_fw(hdev, ver);\n\tif (!fw)\n\t\tgoto complete;\n\tfw_ptr = fw->data;\n\n\t \n\terr = btintel_enter_mfg(hdev);\n\tif (err) {\n\t\trelease_firmware(fw);\n\t\treturn err;\n\t}\n\n\tdisable_patch = 1;\n\n\t \n\twhile (fw->size > fw_ptr - fw->data) {\n\t\tint ret;\n\n\t\tret = btintel_legacy_rom_patching(hdev, fw, &fw_ptr,\n\t\t\t\t\t\t &disable_patch);\n\t\tif (ret < 0)\n\t\t\tgoto exit_mfg_deactivate;\n\t}\n\n\trelease_firmware(fw);\n\n\tif (disable_patch)\n\t\tgoto exit_mfg_disable;\n\n\t \n\terr = btintel_exit_mfg(hdev, true, true);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = btintel_read_version(hdev, &new_ver);\n\tif (err)\n\t\treturn err;\n\n\tbt_dev_info(hdev, \"Intel BT fw patch 0x%02x completed & activated\",\n\t\t    new_ver.fw_patch_num);\n\n\tgoto complete;\n\nexit_mfg_disable:\n\t \n\terr = btintel_exit_mfg(hdev, false, false);\n\tif (err)\n\t\treturn err;\n\n\tbt_dev_info(hdev, \"Intel firmware patch completed\");\n\n\tgoto complete;\n\nexit_mfg_deactivate:\n\trelease_firmware(fw);\n\n\t \n\terr = btintel_exit_mfg(hdev, true, false);\n\tif (err)\n\t\treturn err;\n\n\tbt_dev_info(hdev, \"Intel firmware patch completed and deactivated\");\n\ncomplete:\n\t \n\tbtintel_set_event_mask_mfg(hdev, false);\n\n\tbtintel_check_bdaddr(hdev);\n\n\treturn 0;\n}\n\nstatic int btintel_download_wait(struct hci_dev *hdev, ktime_t calltime, int msec)\n{\n\tktime_t delta, rettime;\n\tunsigned long long duration;\n\tint err;\n\n\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\n\tbt_dev_info(hdev, \"Waiting for firmware download to complete\");\n\n\terr = btintel_wait_on_flag_timeout(hdev, INTEL_DOWNLOADING,\n\t\t\t\t\t   TASK_INTERRUPTIBLE,\n\t\t\t\t\t   msecs_to_jiffies(msec));\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Firmware loading interrupted\");\n\t\treturn err;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Firmware loading timeout\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tif (btintel_test_flag(hdev, INTEL_FIRMWARE_FAILED)) {\n\t\tbt_dev_err(hdev, \"Firmware loading failed\");\n\t\treturn -ENOEXEC;\n\t}\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long)ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Firmware loaded in %llu usecs\", duration);\n\n\treturn 0;\n}\n\nstatic int btintel_boot_wait(struct hci_dev *hdev, ktime_t calltime, int msec)\n{\n\tktime_t delta, rettime;\n\tunsigned long long duration;\n\tint err;\n\n\tbt_dev_info(hdev, \"Waiting for device to boot\");\n\n\terr = btintel_wait_on_flag_timeout(hdev, INTEL_BOOTING,\n\t\t\t\t\t   TASK_INTERRUPTIBLE,\n\t\t\t\t\t   msecs_to_jiffies(msec));\n\tif (err == -EINTR) {\n\t\tbt_dev_err(hdev, \"Device boot interrupted\");\n\t\treturn -EINTR;\n\t}\n\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Device boot timeout\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\trettime = ktime_get();\n\tdelta = ktime_sub(rettime, calltime);\n\tduration = (unsigned long long) ktime_to_ns(delta) >> 10;\n\n\tbt_dev_info(hdev, \"Device booted in %llu usecs\", duration);\n\n\treturn 0;\n}\n\nstatic int btintel_boot(struct hci_dev *hdev, u32 boot_addr)\n{\n\tktime_t calltime;\n\tint err;\n\n\tcalltime = ktime_get();\n\n\tbtintel_set_flag(hdev, INTEL_BOOTING);\n\n\terr = btintel_send_intel_reset(hdev, boot_addr);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Intel Soft Reset failed (%d)\", err);\n\t\tbtintel_reset_to_bootloader(hdev);\n\t\treturn err;\n\t}\n\n\t \n\terr = btintel_boot_wait(hdev, calltime, 1000);\n\tif (err == -ETIMEDOUT)\n\t\tbtintel_reset_to_bootloader(hdev);\n\n\treturn err;\n}\n\nstatic int btintel_get_fw_name(struct intel_version *ver,\n\t\t\t\t\t     struct intel_boot_params *params,\n\t\t\t\t\t     char *fw_name, size_t len,\n\t\t\t\t\t     const char *suffix)\n{\n\tswitch (ver->hw_variant) {\n\tcase 0x0b:\t \n\tcase 0x0c:\t \n\t\tsnprintf(fw_name, len, \"intel/ibt-%u-%u.%s\",\n\t\t\t ver->hw_variant,\n\t\t\t le16_to_cpu(params->dev_revid),\n\t\t\t suffix);\n\t\tbreak;\n\tcase 0x11:\t \n\tcase 0x12:\t \n\tcase 0x13:\t \n\tcase 0x14:\t \n\t\tsnprintf(fw_name, len, \"intel/ibt-%u-%u-%u.%s\",\n\t\t\t ver->hw_variant,\n\t\t\t ver->hw_revision,\n\t\t\t ver->fw_revision,\n\t\t\t suffix);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int btintel_download_fw(struct hci_dev *hdev,\n\t\t\t\t\t struct intel_version *ver,\n\t\t\t\t\t struct intel_boot_params *params,\n\t\t\t\t\t u32 *boot_param)\n{\n\tconst struct firmware *fw;\n\tchar fwname[64];\n\tint err;\n\tktime_t calltime;\n\n\tif (!ver || !params)\n\t\treturn -EINVAL;\n\n\t \n\tif (ver->fw_variant == 0x23) {\n\t\tbtintel_clear_flag(hdev, INTEL_BOOTLOADER);\n\t\tbtintel_check_bdaddr(hdev);\n\n\t\t \n\t\tswitch (ver->hw_variant) {\n\t\tcase 0x0b:\t \n\t\tcase 0x0c:\t \n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tgoto download;\n\t}\n\n\t \n\terr = btintel_read_boot_params(hdev, params);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (params->limited_cce != 0x00) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel firmware loading method (%u)\",\n\t\t\t   params->limited_cce);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (!bacmp(&params->otp_bdaddr, BDADDR_ANY)) {\n\t\tbt_dev_info(hdev, \"No device address configured\");\n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\n\t}\n\ndownload:\n\t \n\terr = btintel_get_fw_name(ver, params, fwname, sizeof(fwname), \"sfi\");\n\tif (err < 0) {\n\t\tif (!btintel_test_flag(hdev, INTEL_BOOTLOADER)) {\n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbt_dev_err(hdev, \"Unsupported Intel firmware naming\");\n\t\treturn -EINVAL;\n\t}\n\n\terr = firmware_request_nowarn(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tif (!btintel_test_flag(hdev, INTEL_BOOTLOADER)) {\n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbt_dev_err(hdev, \"Failed to load Intel firmware file %s (%d)\",\n\t\t\t   fwname, err);\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"Found device firmware: %s\", fwname);\n\n\tif (fw->size < 644) {\n\t\tbt_dev_err(hdev, \"Invalid size of firmware file (%zu)\",\n\t\t\t   fw->size);\n\t\terr = -EBADF;\n\t\tgoto done;\n\t}\n\n\tcalltime = ktime_get();\n\n\tbtintel_set_flag(hdev, INTEL_DOWNLOADING);\n\n\t \n\terr = btintel_download_firmware(hdev, ver, fw, boot_param);\n\tif (err < 0) {\n\t\tif (err == -EALREADY) {\n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\t\t\terr = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tbtintel_reset_to_bootloader(hdev);\n\t\tgoto done;\n\t}\n\n\t \n\terr = btintel_download_wait(hdev, calltime, 5000);\n\tif (err == -ETIMEDOUT)\n\t\tbtintel_reset_to_bootloader(hdev);\n\ndone:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int btintel_bootloader_setup(struct hci_dev *hdev,\n\t\t\t\t    struct intel_version *ver)\n{\n\tstruct intel_version new_ver;\n\tstruct intel_boot_params params;\n\tu32 boot_param;\n\tchar ddcname[64];\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\t \n\tboot_param = 0x00000000;\n\n\tbtintel_set_flag(hdev, INTEL_BOOTLOADER);\n\n\terr = btintel_download_fw(hdev, ver, &params, &boot_param);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (ver->fw_variant == 0x23)\n\t\tgoto finish;\n\n\terr = btintel_boot(hdev, boot_param);\n\tif (err)\n\t\treturn err;\n\n\tbtintel_clear_flag(hdev, INTEL_BOOTLOADER);\n\n\terr = btintel_get_fw_name(ver, &params, ddcname,\n\t\t\t\t\t\tsizeof(ddcname), \"ddc\");\n\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel firmware naming\");\n\t} else {\n\t\t \n\t\tbtintel_load_ddc_config(hdev, ddcname);\n\t}\n\n\thci_dev_clear_flag(hdev, HCI_QUALITY_REPORT);\n\n\t \n\terr = btintel_read_version(hdev, &new_ver);\n\tif (err)\n\t\treturn err;\n\n\tbtintel_version_info(hdev, &new_ver);\n\nfinish:\n\t \n\tbtintel_set_event_mask(hdev, false);\n\n\treturn 0;\n}\n\nstatic void btintel_get_fw_name_tlv(const struct intel_version_tlv *ver,\n\t\t\t\t    char *fw_name, size_t len,\n\t\t\t\t    const char *suffix)\n{\n\t \n\tsnprintf(fw_name, len, \"intel/ibt-%04x-%04x.%s\",\n\t\t INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver->cnvi_top),\n\t\t\t\t\t  INTEL_CNVX_TOP_STEP(ver->cnvi_top)),\n\t\t INTEL_CNVX_TOP_PACK_SWAB(INTEL_CNVX_TOP_TYPE(ver->cnvr_top),\n\t\t\t\t\t  INTEL_CNVX_TOP_STEP(ver->cnvr_top)),\n\t\t suffix);\n}\n\nstatic int btintel_prepare_fw_download_tlv(struct hci_dev *hdev,\n\t\t\t\t\t   struct intel_version_tlv *ver,\n\t\t\t\t\t   u32 *boot_param)\n{\n\tconst struct firmware *fw;\n\tchar fwname[64];\n\tint err;\n\tktime_t calltime;\n\n\tif (!ver || !boot_param)\n\t\treturn -EINVAL;\n\n\t \n\tif (ver->img_type == 0x03) {\n\t\tbtintel_clear_flag(hdev, INTEL_BOOTLOADER);\n\t\tbtintel_check_bdaddr(hdev);\n\t} else {\n\t\t \n\t\tif (!bacmp(&ver->otp_bd_addr, BDADDR_ANY)) {\n\t\t\tbt_dev_info(hdev, \"No device address configured\");\n\t\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\n\t\t}\n\t}\n\n\tbtintel_get_fw_name_tlv(ver, fwname, sizeof(fwname), \"sfi\");\n\terr = firmware_request_nowarn(&fw, fwname, &hdev->dev);\n\tif (err < 0) {\n\t\tif (!btintel_test_flag(hdev, INTEL_BOOTLOADER)) {\n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\t\t\treturn 0;\n\t\t}\n\n\t\tbt_dev_err(hdev, \"Failed to load Intel firmware file %s (%d)\",\n\t\t\t   fwname, err);\n\n\t\treturn err;\n\t}\n\n\tbt_dev_info(hdev, \"Found device firmware: %s\", fwname);\n\n\tif (fw->size < 644) {\n\t\tbt_dev_err(hdev, \"Invalid size of firmware file (%zu)\",\n\t\t\t   fw->size);\n\t\terr = -EBADF;\n\t\tgoto done;\n\t}\n\n\tcalltime = ktime_get();\n\n\tbtintel_set_flag(hdev, INTEL_DOWNLOADING);\n\n\t \n\terr = btintel_download_fw_tlv(hdev, ver, fw, boot_param,\n\t\t\t\t\t       INTEL_HW_VARIANT(ver->cnvi_bt),\n\t\t\t\t\t       ver->sbe_type);\n\tif (err < 0) {\n\t\tif (err == -EALREADY) {\n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_LOADED);\n\t\t\terr = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tbtintel_reset_to_bootloader(hdev);\n\t\tgoto done;\n\t}\n\n\t \n\terr = btintel_download_wait(hdev, calltime, 5000);\n\tif (err == -ETIMEDOUT)\n\t\tbtintel_reset_to_bootloader(hdev);\n\ndone:\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int btintel_get_codec_config_data(struct hci_dev *hdev,\n\t\t\t\t\t __u8 link, struct bt_codec *codec,\n\t\t\t\t\t __u8 *ven_len, __u8 **ven_data)\n{\n\tint err = 0;\n\n\tif (!ven_data || !ven_len)\n\t\treturn -EINVAL;\n\n\t*ven_len = 0;\n\t*ven_data = NULL;\n\n\tif (link != ESCO_LINK) {\n\t\tbt_dev_err(hdev, \"Invalid link type(%u)\", link);\n\t\treturn -EINVAL;\n\t}\n\n\t*ven_data = kmalloc(sizeof(__u8), GFP_KERNEL);\n\tif (!*ven_data) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tswitch (codec->id) {\n\tcase 0x02:\n\t\t**ven_data = 0x00;\n\t\tbreak;\n\tcase 0x05:\n\t\t**ven_data = 0x01;\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbt_dev_err(hdev, \"Invalid codec id(%u)\", codec->id);\n\t\tgoto error;\n\t}\n\t \n\t*ven_len = sizeof(__u8);\n\treturn err;\n\nerror:\n\tkfree(*ven_data);\n\t*ven_data = NULL;\n\treturn err;\n}\n\nstatic int btintel_get_data_path_id(struct hci_dev *hdev, __u8 *data_path_id)\n{\n\t \n\t*data_path_id = 1;\n\treturn 0;\n}\n\nstatic int btintel_configure_offload(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\tstruct intel_offload_use_cases *use_cases;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc86, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading offload use cases failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->len < sizeof(*use_cases)) {\n\t\terr = -EIO;\n\t\tgoto error;\n\t}\n\n\tuse_cases = (void *)skb->data;\n\n\tif (use_cases->status) {\n\t\terr = -bt_to_errno(skb->data[0]);\n\t\tgoto error;\n\t}\n\n\tif (use_cases->preset[0] & 0x03) {\n\t\thdev->get_data_path_id = btintel_get_data_path_id;\n\t\thdev->get_codec_config_data = btintel_get_codec_config_data;\n\t}\nerror:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic void btintel_set_ppag(struct hci_dev *hdev, struct intel_version_tlv *ver)\n{\n\tstruct btintel_ppag ppag;\n\tstruct sk_buff *skb;\n\tstruct hci_ppag_enable_cmd ppag_cmd;\n\tacpi_handle handle;\n\n\t \n\tswitch (ver->cnvr_top & 0xFFF) {\n\tcase 0x504:      \n\tcase 0x202:      \n\tcase 0x201:      \n\t\tbt_dev_dbg(hdev, \"PPAG not supported for Intel CNVr (0x%3x)\",\n\t\t\t   ver->cnvr_top & 0xFFF);\n\t\treturn;\n\t}\n\n\thandle = ACPI_HANDLE(GET_HCIDEV_DEV(hdev));\n\tif (!handle) {\n\t\tbt_dev_info(hdev, \"No support for BT device in ACPI firmware\");\n\t\treturn;\n\t}\n\n\tmemset(&ppag, 0, sizeof(ppag));\n\n\tppag.hdev = hdev;\n\tppag.status = AE_NOT_FOUND;\n\tacpi_walk_namespace(ACPI_TYPE_PACKAGE, handle, 1, NULL,\n\t\t\t    btintel_ppag_callback, &ppag, NULL);\n\n\tif (ACPI_FAILURE(ppag.status)) {\n\t\tif (ppag.status == AE_NOT_FOUND) {\n\t\t\tbt_dev_dbg(hdev, \"PPAG-BT: ACPI entry not found\");\n\t\t\treturn;\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ppag.domain != 0x12) {\n\t\tbt_dev_dbg(hdev, \"PPAG-BT: Bluetooth domain is disabled in ACPI firmware\");\n\t\treturn;\n\t}\n\n\t \n\tif ((ppag.mode & 0x01) != BIT(0) && (ppag.mode & 0x02) != BIT(1)) {\n\t\tbt_dev_dbg(hdev, \"PPAG-BT: EU, China mode are disabled in CB/BIOS\");\n\t\treturn;\n\t}\n\n\tppag_cmd.ppag_enable_flags = cpu_to_le32(ppag.mode);\n\n\tskb = __hci_cmd_sync(hdev, INTEL_OP_PPAG_CMD, sizeof(ppag_cmd), &ppag_cmd, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_warn(hdev, \"Failed to send PPAG Enable (%ld)\", PTR_ERR(skb));\n\t\treturn;\n\t}\n\tbt_dev_info(hdev, \"PPAG-BT: Enabled (Mode %d)\", ppag.mode);\n\tkfree_skb(skb);\n}\n\nstatic int btintel_acpi_reset_method(struct hci_dev *hdev)\n{\n\tint ret = 0;\n\tacpi_status status;\n\tunion acpi_object *p, *ref;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\n\tstatus = acpi_evaluate_object(ACPI_HANDLE(GET_HCIDEV_DEV(hdev)), \"_PRR\", NULL, &buffer);\n\tif (ACPI_FAILURE(status)) {\n\t\tbt_dev_err(hdev, \"Failed to run _PRR method\");\n\t\tret = -ENODEV;\n\t\treturn ret;\n\t}\n\tp = buffer.pointer;\n\n\tif (p->package.count != 1 || p->type != ACPI_TYPE_PACKAGE) {\n\t\tbt_dev_err(hdev, \"Invalid arguments\");\n\t\tret = -EINVAL;\n\t\tgoto exit_on_error;\n\t}\n\n\tref = &p->package.elements[0];\n\tif (ref->type != ACPI_TYPE_LOCAL_REFERENCE) {\n\t\tbt_dev_err(hdev, \"Invalid object type: 0x%x\", ref->type);\n\t\tret = -EINVAL;\n\t\tgoto exit_on_error;\n\t}\n\n\tstatus = acpi_evaluate_object(ref->reference.handle, \"_RST\", NULL, NULL);\n\tif (ACPI_FAILURE(status)) {\n\t\tbt_dev_err(hdev, \"Failed to run_RST method\");\n\t\tret = -ENODEV;\n\t\tgoto exit_on_error;\n\t}\n\nexit_on_error:\n\tkfree(buffer.pointer);\n\treturn ret;\n}\n\nstatic void btintel_set_dsm_reset_method(struct hci_dev *hdev,\n\t\t\t\t\t struct intel_version_tlv *ver_tlv)\n{\n\tstruct btintel_data *data = hci_get_priv(hdev);\n\tacpi_handle handle = ACPI_HANDLE(GET_HCIDEV_DEV(hdev));\n\tu8 reset_payload[4] = {0x01, 0x00, 0x01, 0x00};\n\tunion acpi_object *obj, argv4;\n\tenum {\n\t\tRESET_TYPE_WDISABLE2,\n\t\tRESET_TYPE_VSEC\n\t};\n\n\thandle = ACPI_HANDLE(GET_HCIDEV_DEV(hdev));\n\n\tif (!handle) {\n\t\tbt_dev_dbg(hdev, \"No support for bluetooth device in ACPI firmware\");\n\t\treturn;\n\t}\n\n\tif (!acpi_has_method(handle, \"_PRR\")) {\n\t\tbt_dev_err(hdev, \"No support for _PRR ACPI method\");\n\t\treturn;\n\t}\n\n\tswitch (ver_tlv->cnvi_top & 0xfff) {\n\tcase 0x910:  \n\t\treset_payload[2] = RESET_TYPE_VSEC;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treset_payload[2] = RESET_TYPE_WDISABLE2;\n\n\t\tif (!acpi_check_dsm(handle, &btintel_guid_dsm, 0,\n\t\t\t\t    BIT(DSM_SET_WDISABLE2_DELAY))) {\n\t\t\tbt_dev_err(hdev, \"No dsm support to set reset delay\");\n\t\t\treturn;\n\t\t}\n\t\targv4.integer.type = ACPI_TYPE_INTEGER;\n\t\t \n\t\targv4.integer.value = 160;\n\t\tobj = acpi_evaluate_dsm(handle, &btintel_guid_dsm, 0,\n\t\t\t\t\tDSM_SET_WDISABLE2_DELAY, &argv4);\n\t\tif (!obj) {\n\t\t\tbt_dev_err(hdev, \"Failed to call dsm to set reset delay\");\n\t\t\treturn;\n\t\t}\n\t\tACPI_FREE(obj);\n\t}\n\n\tbt_dev_info(hdev, \"DSM reset method type: 0x%02x\", reset_payload[2]);\n\n\tif (!acpi_check_dsm(handle, &btintel_guid_dsm, 0,\n\t\t\t    DSM_SET_RESET_METHOD)) {\n\t\tbt_dev_warn(hdev, \"No support for dsm to set reset method\");\n\t\treturn;\n\t}\n\targv4.buffer.type = ACPI_TYPE_BUFFER;\n\targv4.buffer.length = sizeof(reset_payload);\n\targv4.buffer.pointer = reset_payload;\n\n\tobj = acpi_evaluate_dsm(handle, &btintel_guid_dsm, 0,\n\t\t\t\tDSM_SET_RESET_METHOD, &argv4);\n\tif (!obj) {\n\t\tbt_dev_err(hdev, \"Failed to call dsm to set reset method\");\n\t\treturn;\n\t}\n\tACPI_FREE(obj);\n\tdata->acpi_reset_method = btintel_acpi_reset_method;\n}\n\nstatic int btintel_bootloader_setup_tlv(struct hci_dev *hdev,\n\t\t\t\t\tstruct intel_version_tlv *ver)\n{\n\tu32 boot_param;\n\tchar ddcname[64];\n\tint err;\n\tstruct intel_version_tlv new_ver;\n\n\tbt_dev_dbg(hdev, \"\");\n\n\t \n\tboot_param = 0x00000000;\n\n\tbtintel_set_flag(hdev, INTEL_BOOTLOADER);\n\n\terr = btintel_prepare_fw_download_tlv(hdev, ver, &boot_param);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (ver->img_type == 0x03)\n\t\tgoto finish;\n\n\terr = btintel_boot(hdev, boot_param);\n\tif (err)\n\t\treturn err;\n\n\tbtintel_clear_flag(hdev, INTEL_BOOTLOADER);\n\n\tbtintel_get_fw_name_tlv(ver, ddcname, sizeof(ddcname), \"ddc\");\n\t \n\tbtintel_load_ddc_config(hdev, ddcname);\n\n\t \n\tbtintel_configure_offload(hdev);\n\n\thci_dev_clear_flag(hdev, HCI_QUALITY_REPORT);\n\n\t \n\tbtintel_set_ppag(hdev, ver);\n\n\t \n\terr = btintel_read_version_tlv(hdev, &new_ver);\n\tif (err)\n\t\treturn err;\n\n\tbtintel_version_info_tlv(hdev, &new_ver);\n\nfinish:\n\t \n\tbtintel_set_event_mask(hdev, false);\n\n\treturn 0;\n}\n\nstatic void btintel_set_msft_opcode(struct hci_dev *hdev, u8 hw_variant)\n{\n\tswitch (hw_variant) {\n\t \n\tcase 0x11:\t \n\tcase 0x12:\t \n\tcase 0x13:\t \n\tcase 0x14:\t \n\t \n\tcase 0x17:\n\tcase 0x18:\n\tcase 0x19:\n\tcase 0x1b:\n\tcase 0x1c:\n\t\thci_set_msft_opcode(hdev, 0xFC1E);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tbreak;\n\t}\n}\n\nstatic int btintel_setup_combined(struct hci_dev *hdev)\n{\n\tconst u8 param[1] = { 0xFF };\n\tstruct intel_version ver;\n\tstruct intel_version_tlv ver_tlv;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\t \n\tif (btintel_test_flag(hdev, INTEL_BROKEN_INITIAL_NCMD) ||\n\t    btintel_test_flag(hdev, INTEL_BROKEN_SHUTDOWN_LED)) {\n\t\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\tbt_dev_err(hdev,\n\t\t\t\t   \"sending initial HCI reset failed (%ld)\",\n\t\t\t\t   PTR_ERR(skb));\n\t\t\treturn PTR_ERR(skb);\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc05, 1, param, HCI_CMD_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading Intel version command failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\t \n\tif (skb->data[0]) {\n\t\tbt_dev_err(hdev, \"Intel Read Version command failed (%02x)\",\n\t\t\t   skb->data[0]);\n\t\terr = -EIO;\n\t\tgoto exit_error;\n\t}\n\n\t \n\tset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\n\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\tset_bit(HCI_QUIRK_NON_PERSISTENT_DIAG, &hdev->quirks);\n\n\t \n\thdev->set_quality_report = btintel_set_quality_report;\n\n\t \n\tif (skb->len == sizeof(ver) && skb->data[1] == 0x37) {\n\t\tbt_dev_dbg(hdev, \"Read the legacy Intel version information\");\n\n\t\tmemcpy(&ver, skb->data, sizeof(ver));\n\n\t\t \n\t\tbtintel_version_info(hdev, &ver);\n\n\t\t \n\t\tswitch (ver.hw_variant) {\n\t\tcase 0x07:\t \n\t\tcase 0x08:\t \n\t\t\t \n\t\t\tbtintel_set_flag(hdev, INTEL_ROM_LEGACY);\n\n\t\t\t \n\t\t\tif (!btintel_test_flag(hdev,\n\t\t\t\t\t       INTEL_ROM_LEGACY_NO_WBS_SUPPORT))\n\t\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t\t\t&hdev->quirks);\n\t\t\tif (ver.hw_variant == 0x08 && ver.fw_variant == 0x22)\n\t\t\t\tset_bit(HCI_QUIRK_VALID_LE_STATES,\n\t\t\t\t\t&hdev->quirks);\n\n\t\t\terr = btintel_legacy_rom_setup(hdev, &ver);\n\t\t\tbreak;\n\t\tcase 0x0b:       \n\t\tcase 0x11:       \n\t\tcase 0x12:       \n\t\tcase 0x13:       \n\t\tcase 0x14:       \n\t\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\t\t\tfallthrough;\n\t\tcase 0x0c:\t \n\t\t\t \n\t\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED,\n\t\t\t\t&hdev->quirks);\n\n\t\t\t \n\t\t\tset_bit(HCI_QUIRK_BROKEN_LE_CODED, &hdev->quirks);\n\n\t\t\t \n\t\t\tbtintel_set_msft_opcode(hdev, ver.hw_variant);\n\n\t\t\terr = btintel_bootloader_setup(hdev, &ver);\n\t\t\tbtintel_register_devcoredump_support(hdev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbt_dev_err(hdev, \"Unsupported Intel hw variant (%u)\",\n\t\t\t\t   ver.hw_variant);\n\t\t\terr = -EINVAL;\n\t\t}\n\n\t\tgoto exit_error;\n\t}\n\n\t \n\tmemset(&ver_tlv, 0, sizeof(ver_tlv));\n\t \n\terr = btintel_parse_version_tlv(hdev, &ver_tlv, skb);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Failed to parse TLV version information\");\n\t\tgoto exit_error;\n\t}\n\n\tif (INTEL_HW_PLATFORM(ver_tlv.cnvi_bt) != 0x37) {\n\t\tbt_dev_err(hdev, \"Unsupported Intel hardware platform (0x%2x)\",\n\t\t\t   INTEL_HW_PLATFORM(ver_tlv.cnvi_bt));\n\t\terr = -EINVAL;\n\t\tgoto exit_error;\n\t}\n\n\t \n\tswitch (INTEL_HW_VARIANT(ver_tlv.cnvi_bt)) {\n\tcase 0x11:       \n\tcase 0x12:       \n\tcase 0x13:       \n\tcase 0x14:       \n\t\t \n\t\terr = btintel_read_version(hdev, &ver);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\t \n\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\n\t\t \n\t\tset_bit(HCI_QUIRK_BROKEN_LE_CODED, &hdev->quirks);\n\n\t\t \n\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\n\t\t \n\t\tbtintel_set_msft_opcode(hdev, ver.hw_variant);\n\n\t\terr = btintel_bootloader_setup(hdev, &ver);\n\t\tbtintel_register_devcoredump_support(hdev);\n\t\tbreak;\n\tcase 0x17:\n\tcase 0x18:\n\tcase 0x19:\n\tcase 0x1b:\n\tcase 0x1c:\n\t\t \n\t\tbtintel_version_info_tlv(hdev, &ver_tlv);\n\n\t\t \n\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\n\t\t \n\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\n\t\t \n\t\tbtintel_set_msft_opcode(hdev,\n\t\t\t\t\tINTEL_HW_VARIANT(ver_tlv.cnvi_bt));\n\t\tbtintel_set_dsm_reset_method(hdev, &ver_tlv);\n\n\t\terr = btintel_bootloader_setup_tlv(hdev, &ver_tlv);\n\t\tbtintel_register_devcoredump_support(hdev);\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unsupported Intel hw variant (%u)\",\n\t\t\t   INTEL_HW_VARIANT(ver_tlv.cnvi_bt));\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\nexit_error:\n\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstatic int btintel_shutdown_combined(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\t \n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"HCI reset during shutdown failed\");\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\n\n\t \n\tif (btintel_test_flag(hdev, INTEL_BROKEN_SHUTDOWN_LED)) {\n\t\tskb = __hci_cmd_sync(hdev, 0xfc3f, 0, NULL, HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\tret = PTR_ERR(skb);\n\t\t\tbt_dev_err(hdev, \"turning off Intel device LED failed\");\n\t\t\treturn ret;\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\n\treturn 0;\n}\n\nint btintel_configure_setup(struct hci_dev *hdev, const char *driver_name)\n{\n\thdev->manufacturer = 2;\n\thdev->setup = btintel_setup_combined;\n\thdev->shutdown = btintel_shutdown_combined;\n\thdev->hw_error = btintel_hw_error;\n\thdev->set_diag = btintel_set_diag_combined;\n\thdev->set_bdaddr = btintel_set_bdaddr;\n\n\tcoredump_info.driver_name = driver_name;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btintel_configure_setup);\n\nstatic int btintel_diagnostics(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct intel_tlv *tlv = (void *)&skb->data[5];\n\n\t \n\tif (tlv->type != INTEL_TLV_TYPE_ID)\n\t\tgoto recv_frame;\n\n\tswitch (tlv->val[0]) {\n\tcase INTEL_TLV_SYSTEM_EXCEPTION:\n\tcase INTEL_TLV_FATAL_EXCEPTION:\n\tcase INTEL_TLV_DEBUG_EXCEPTION:\n\tcase INTEL_TLV_TEST_EXCEPTION:\n\t\t \n\t\tif (!hci_devcd_init(hdev, skb->len)) {\n\t\t\thci_devcd_append(hdev, skb);\n\t\t\thci_devcd_complete(hdev);\n\t\t} else {\n\t\t\tbt_dev_err(hdev, \"Failed to generate devcoredump\");\n\t\t\tkfree_skb(skb);\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Invalid exception type %02X\", tlv->val[0]);\n\t}\n\nrecv_frame:\n\treturn hci_recv_frame(hdev, skb);\n}\n\nint btintel_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_event_hdr *hdr = (void *)skb->data;\n\tconst char diagnostics_hdr[] = { 0x87, 0x80, 0x03 };\n\n\tif (skb->len > HCI_EVENT_HDR_SIZE && hdr->evt == 0xff &&\n\t    hdr->plen > 0) {\n\t\tconst void *ptr = skb->data + HCI_EVENT_HDR_SIZE + 1;\n\t\tunsigned int len = skb->len - HCI_EVENT_HDR_SIZE - 1;\n\n\t\tif (btintel_test_flag(hdev, INTEL_BOOTLOADER)) {\n\t\t\tswitch (skb->data[2]) {\n\t\t\tcase 0x02:\n\t\t\t\t \n\t\t\t\tbtintel_bootup(hdev, ptr, len);\n\t\t\t\tbreak;\n\t\t\tcase 0x06:\n\t\t\t\t \n\t\t\t\tbtintel_secure_send_result(hdev, ptr, len);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (len >= sizeof(diagnostics_hdr) &&\n\t\t    memcmp(&skb->data[2], diagnostics_hdr,\n\t\t\t   sizeof(diagnostics_hdr)) == 0) {\n\t\t\treturn btintel_diagnostics(hdev, skb);\n\t\t}\n\t}\n\n\treturn hci_recv_frame(hdev, skb);\n}\nEXPORT_SYMBOL_GPL(btintel_recv_event);\n\nvoid btintel_bootup(struct hci_dev *hdev, const void *ptr, unsigned int len)\n{\n\tconst struct intel_bootup *evt = ptr;\n\n\tif (len != sizeof(*evt))\n\t\treturn;\n\n\tif (btintel_test_and_clear_flag(hdev, INTEL_BOOTING))\n\t\tbtintel_wake_up_flag(hdev, INTEL_BOOTING);\n}\nEXPORT_SYMBOL_GPL(btintel_bootup);\n\nvoid btintel_secure_send_result(struct hci_dev *hdev,\n\t\t\t\tconst void *ptr, unsigned int len)\n{\n\tconst struct intel_secure_send_result *evt = ptr;\n\n\tif (len != sizeof(*evt))\n\t\treturn;\n\n\tif (evt->result)\n\t\tbtintel_set_flag(hdev, INTEL_FIRMWARE_FAILED);\n\n\tif (btintel_test_and_clear_flag(hdev, INTEL_DOWNLOADING) &&\n\t    btintel_test_flag(hdev, INTEL_FIRMWARE_LOADED))\n\t\tbtintel_wake_up_flag(hdev, INTEL_DOWNLOADING);\n}\nEXPORT_SYMBOL_GPL(btintel_secure_send_result);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth support for Intel devices ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"intel/ibt-11-5.sfi\");\nMODULE_FIRMWARE(\"intel/ibt-11-5.ddc\");\nMODULE_FIRMWARE(\"intel/ibt-12-16.sfi\");\nMODULE_FIRMWARE(\"intel/ibt-12-16.ddc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}