{
  "module_name": "bt3c_cs.c",
  "hash_id": "e0ac662e67f730e2dad6b9413eeffdec1973424c2b23f374df63334ffa0fb1d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/bt3c_cs.c",
  "human_readable_source": " \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/spinlock.h>\n#include <linux/moduleparam.h>\n\n#include <linux/skbuff.h>\n#include <linux/string.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/bitops.h>\n#include <asm/io.h>\n\n#include <linux/device.h>\n#include <linux/firmware.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/ciscode.h>\n#include <pcmcia/ds.h>\n#include <pcmcia/cisreg.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n\n\n \n\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth driver for the 3Com Bluetooth PCMCIA card\");\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"BT3CPCC.bin\");\n\n\n\n \n\n\nstruct bt3c_info {\n\tstruct pcmcia_device *p_dev;\n\n\tstruct hci_dev *hdev;\n\n\tspinlock_t lock;\t\t \n\n\tstruct sk_buff_head txq;\n\tunsigned long tx_state;\n\n\tunsigned long rx_state;\n\tunsigned long rx_count;\n\tstruct sk_buff *rx_skb;\n};\n\n\nstatic int bt3c_config(struct pcmcia_device *link);\nstatic void bt3c_release(struct pcmcia_device *link);\n\nstatic void bt3c_detach(struct pcmcia_device *p_dev);\n\n\n \n#define XMIT_SENDING  1\n#define XMIT_WAKEUP   2\n#define XMIT_WAITING  8\n\n \n#define RECV_WAIT_PACKET_TYPE   0\n#define RECV_WAIT_EVENT_HEADER  1\n#define RECV_WAIT_ACL_HEADER    2\n#define RECV_WAIT_SCO_HEADER    3\n#define RECV_WAIT_DATA          4\n\n\n\n \n\n\n#define DATA_L   0\n#define DATA_H   1\n#define ADDR_L   2\n#define ADDR_H   3\n#define CONTROL  4\n\n\nstatic inline void bt3c_address(unsigned int iobase, unsigned short addr)\n{\n\toutb(addr & 0xff, iobase + ADDR_L);\n\toutb((addr >> 8) & 0xff, iobase + ADDR_H);\n}\n\n\nstatic inline void bt3c_put(unsigned int iobase, unsigned short value)\n{\n\toutb(value & 0xff, iobase + DATA_L);\n\toutb((value >> 8) & 0xff, iobase + DATA_H);\n}\n\n\nstatic inline void bt3c_io_write(unsigned int iobase, unsigned short addr, unsigned short value)\n{\n\tbt3c_address(iobase, addr);\n\tbt3c_put(iobase, value);\n}\n\n\nstatic inline unsigned short bt3c_get(unsigned int iobase)\n{\n\tunsigned short value = inb(iobase + DATA_L);\n\n\tvalue |= inb(iobase + DATA_H) << 8;\n\n\treturn value;\n}\n\n\nstatic inline unsigned short bt3c_read(unsigned int iobase, unsigned short addr)\n{\n\tbt3c_address(iobase, addr);\n\n\treturn bt3c_get(iobase);\n}\n\n\n\n \n\n\nstatic int bt3c_write(unsigned int iobase, int fifo_size, __u8 *buf, int len)\n{\n\tint actual = 0;\n\n\tbt3c_address(iobase, 0x7080);\n\n\t \n\twhile (actual < len) {\n\t\t \n\t\tbt3c_put(iobase, buf[actual]);\n\t\tactual++;\n\t}\n\n\tbt3c_io_write(iobase, 0x7005, actual);\n\n\treturn actual;\n}\n\n\nstatic void bt3c_write_wakeup(struct bt3c_info *info)\n{\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tif (test_and_set_bit(XMIT_SENDING, &(info->tx_state)))\n\t\treturn;\n\n\tdo {\n\t\tunsigned int iobase = info->p_dev->resource[0]->start;\n\t\tregister struct sk_buff *skb;\n\t\tint len;\n\n\t\tif (!pcmcia_dev_present(info->p_dev))\n\t\t\tbreak;\n\n\t\tskb = skb_dequeue(&(info->txq));\n\t\tif (!skb) {\n\t\t\tclear_bit(XMIT_SENDING, &(info->tx_state));\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tlen = bt3c_write(iobase, 256, skb->data, skb->len);\n\n\t\tif (len != skb->len)\n\t\t\tBT_ERR(\"Very strange\");\n\n\t\tkfree_skb(skb);\n\n\t\tinfo->hdev->stat.byte_tx += len;\n\n\t} while (0);\n}\n\n\nstatic void bt3c_receive(struct bt3c_info *info)\n{\n\tunsigned int iobase;\n\tint size = 0, avail;\n\n\tif (!info) {\n\t\tBT_ERR(\"Unknown device\");\n\t\treturn;\n\t}\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tavail = bt3c_read(iobase, 0x7006);\n\n\tbt3c_address(iobase, 0x7480);\n\twhile (size < avail) {\n\t\tsize++;\n\t\tinfo->hdev->stat.byte_rx++;\n\n\t\t \n\t\tif (!info->rx_skb) {\n\t\t\tinfo->rx_state = RECV_WAIT_PACKET_TYPE;\n\t\t\tinfo->rx_count = 0;\n\t\t\tinfo->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);\n\t\t\tif (!info->rx_skb) {\n\t\t\t\tBT_ERR(\"Can't allocate mem for new packet\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n\t\tif (info->rx_state == RECV_WAIT_PACKET_TYPE) {\n\n\t\t\thci_skb_pkt_type(info->rx_skb) = inb(iobase + DATA_L);\n\t\t\tinb(iobase + DATA_H);\n\n\t\t\tswitch (hci_skb_pkt_type(info->rx_skb)) {\n\n\t\t\tcase HCI_EVENT_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_EVENT_HEADER;\n\t\t\t\tinfo->rx_count = HCI_EVENT_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tcase HCI_ACLDATA_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_ACL_HEADER;\n\t\t\t\tinfo->rx_count = HCI_ACL_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tcase HCI_SCODATA_PKT:\n\t\t\t\tinfo->rx_state = RECV_WAIT_SCO_HEADER;\n\t\t\t\tinfo->rx_count = HCI_SCO_HDR_SIZE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tBT_ERR(\"Unknown HCI packet with type 0x%02x received\",\n\t\t\t\t       hci_skb_pkt_type(info->rx_skb));\n\t\t\t\tinfo->hdev->stat.err_rx++;\n\n\t\t\t\tkfree_skb(info->rx_skb);\n\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t__u8 x = inb(iobase + DATA_L);\n\n\t\t\tskb_put_u8(info->rx_skb, x);\n\t\t\tinb(iobase + DATA_H);\n\t\t\tinfo->rx_count--;\n\n\t\t\tif (info->rx_count == 0) {\n\n\t\t\t\tint dlen;\n\t\t\t\tstruct hci_event_hdr *eh;\n\t\t\t\tstruct hci_acl_hdr *ah;\n\t\t\t\tstruct hci_sco_hdr *sh;\n\n\t\t\t\tswitch (info->rx_state) {\n\n\t\t\t\tcase RECV_WAIT_EVENT_HEADER:\n\t\t\t\t\teh = hci_event_hdr(info->rx_skb);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = eh->plen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_ACL_HEADER:\n\t\t\t\t\tah = hci_acl_hdr(info->rx_skb);\n\t\t\t\t\tdlen = __le16_to_cpu(ah->dlen);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = dlen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_SCO_HEADER:\n\t\t\t\t\tsh = hci_sco_hdr(info->rx_skb);\n\t\t\t\t\tinfo->rx_state = RECV_WAIT_DATA;\n\t\t\t\t\tinfo->rx_count = sh->dlen;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase RECV_WAIT_DATA:\n\t\t\t\t\thci_recv_frame(info->hdev, info->rx_skb);\n\t\t\t\t\tinfo->rx_skb = NULL;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tbt3c_io_write(iobase, 0x7006, 0x0000);\n}\n\n\nstatic irqreturn_t bt3c_interrupt(int irq, void *dev_inst)\n{\n\tstruct bt3c_info *info = dev_inst;\n\tunsigned int iobase;\n\tint iir;\n\tirqreturn_t r = IRQ_NONE;\n\n\tif (!info || !info->hdev)\n\t\t \n\t\treturn IRQ_NONE;\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\tspin_lock(&(info->lock));\n\n\tiir = inb(iobase + CONTROL);\n\tif (iir & 0x80) {\n\t\tint stat = bt3c_read(iobase, 0x7001);\n\n\t\tif ((stat & 0xff) == 0x7f) {\n\t\t\tBT_ERR(\"Very strange (stat=0x%04x)\", stat);\n\t\t} else if ((stat & 0xff) != 0xff) {\n\t\t\tif (stat & 0x0020) {\n\t\t\t\tint status = bt3c_read(iobase, 0x7002) & 0x10;\n\t\t\t\tbt_dev_info(info->hdev, \"Antenna %s\",\n\t\t\t\t\t\t\tstatus ? \"out\" : \"in\");\n\t\t\t}\n\t\t\tif (stat & 0x0001)\n\t\t\t\tbt3c_receive(info);\n\t\t\tif (stat & 0x0002) {\n\t\t\t\tclear_bit(XMIT_SENDING, &(info->tx_state));\n\t\t\t\tbt3c_write_wakeup(info);\n\t\t\t}\n\n\t\t\tbt3c_io_write(iobase, 0x7001, 0x0000);\n\n\t\t\toutb(iir, iobase + CONTROL);\n\t\t}\n\t\tr = IRQ_HANDLED;\n\t}\n\n\tspin_unlock(&(info->lock));\n\n\treturn r;\n}\n\n\n\n \n\n\nstatic int bt3c_hci_flush(struct hci_dev *hdev)\n{\n\tstruct bt3c_info *info = hci_get_drvdata(hdev);\n\n\t \n\tskb_queue_purge(&(info->txq));\n\n\treturn 0;\n}\n\n\nstatic int bt3c_hci_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\n\nstatic int bt3c_hci_close(struct hci_dev *hdev)\n{\n\tbt3c_hci_flush(hdev);\n\n\treturn 0;\n}\n\n\nstatic int bt3c_hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct bt3c_info *info = hci_get_drvdata(hdev);\n\tunsigned long flags;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\tskb_queue_tail(&(info->txq), skb);\n\n\tspin_lock_irqsave(&(info->lock), flags);\n\n\tbt3c_write_wakeup(info);\n\n\tspin_unlock_irqrestore(&(info->lock), flags);\n\n\treturn 0;\n}\n\n\n\n \n\n\nstatic int bt3c_load_firmware(struct bt3c_info *info,\n\t\t\t      const unsigned char *firmware,\n\t\t\t      int count)\n{\n\tchar *ptr = (char *) firmware;\n\tchar b[9];\n\tunsigned int iobase, tmp, tn;\n\tunsigned long size, addr, fcs;\n\tint i, err = 0;\n\n\tiobase = info->p_dev->resource[0]->start;\n\n\t \n\tbt3c_io_write(iobase, 0x8040, 0x0404);\n\tbt3c_io_write(iobase, 0x8040, 0x0400);\n\n\tudelay(1);\n\n\tbt3c_io_write(iobase, 0x8040, 0x0404);\n\n\tudelay(17);\n\n\t \n\twhile (count) {\n\t\tif (ptr[0] != 'S') {\n\t\t\tBT_ERR(\"Bad address in firmware\");\n\t\t\terr = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemcpy(b, ptr + 2, 2);\n\t\tif (kstrtoul(b, 16, &size) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemcpy(b, ptr + 4, 8);\n\t\tif (kstrtoul(b, 16, &addr) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemcpy(b, ptr + (size * 2) + 2, 2);\n\t\tif (kstrtoul(b, 16, &fcs) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tmemset(b, 0, sizeof(b));\n\t\tfor (tmp = 0, i = 0; i < size; i++) {\n\t\t\tmemcpy(b, ptr + (i * 2) + 2, 2);\n\t\t\tif (kstrtouint(b, 16, &tn))\n\t\t\t\treturn -EINVAL;\n\t\t\ttmp += tn;\n\t\t}\n\n\t\tif (((tmp + fcs) & 0xff) != 0xff) {\n\t\t\tBT_ERR(\"Checksum error in firmware\");\n\t\t\terr = -EILSEQ;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (ptr[1] == '3') {\n\t\t\tbt3c_address(iobase, addr);\n\n\t\t\tmemset(b, 0, sizeof(b));\n\t\t\tfor (i = 0; i < (size - 4) / 2; i++) {\n\t\t\t\tmemcpy(b, ptr + (i * 4) + 12, 4);\n\t\t\t\tif (kstrtouint(b, 16, &tmp))\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\tbt3c_put(iobase, tmp);\n\t\t\t}\n\t\t}\n\n\t\tptr   += (size * 2) + 6;\n\t\tcount -= (size * 2) + 6;\n\t}\n\n\tudelay(17);\n\n\t \n\tbt3c_address(iobase, 0x3000);\n\toutb(inb(iobase + CONTROL) | 0x40, iobase + CONTROL);\n\nerror:\n\tudelay(17);\n\n\t \n\tbt3c_io_write(iobase, 0x7006, 0x0000);\n\tbt3c_io_write(iobase, 0x7005, 0x0000);\n\tbt3c_io_write(iobase, 0x7001, 0x0000);\n\n\treturn err;\n}\n\n\nstatic int bt3c_open(struct bt3c_info *info)\n{\n\tconst struct firmware *firmware;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tspin_lock_init(&(info->lock));\n\n\tskb_queue_head_init(&(info->txq));\n\n\tinfo->rx_state = RECV_WAIT_PACKET_TYPE;\n\tinfo->rx_count = 0;\n\tinfo->rx_skb = NULL;\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinfo->hdev = hdev;\n\n\thdev->bus = HCI_PCCARD;\n\thci_set_drvdata(hdev, info);\n\tSET_HCIDEV_DEV(hdev, &info->p_dev->dev);\n\n\thdev->open  = bt3c_hci_open;\n\thdev->close = bt3c_hci_close;\n\thdev->flush = bt3c_hci_flush;\n\thdev->send  = bt3c_hci_send_frame;\n\n\t \n\terr = request_firmware(&firmware, \"BT3CPCC.bin\", &info->p_dev->dev);\n\tif (err < 0) {\n\t\tBT_ERR(\"Firmware request failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt3c_load_firmware(info, firmware->data, firmware->size);\n\n\trelease_firmware(firmware);\n\n\tif (err < 0) {\n\t\tBT_ERR(\"Firmware loading failed\");\n\t\tgoto error;\n\t}\n\n\t \n\tmsleep(1000);\n\n\t \n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tgoto error;\n\t}\n\n\treturn 0;\n\nerror:\n\tinfo->hdev = NULL;\n\thci_free_dev(hdev);\n\treturn err;\n}\n\n\nstatic int bt3c_close(struct bt3c_info *info)\n{\n\tstruct hci_dev *hdev = info->hdev;\n\n\tif (!hdev)\n\t\treturn -ENODEV;\n\n\tbt3c_hci_close(hdev);\n\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n\n\treturn 0;\n}\n\nstatic int bt3c_probe(struct pcmcia_device *link)\n{\n\tstruct bt3c_info *info;\n\n\t \n\tinfo = devm_kzalloc(&link->dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->p_dev = link;\n\tlink->priv = info;\n\n\tlink->config_flags |= CONF_ENABLE_IRQ | CONF_AUTO_SET_VPP |\n\t\tCONF_AUTO_SET_IO;\n\n\treturn bt3c_config(link);\n}\n\n\nstatic void bt3c_detach(struct pcmcia_device *link)\n{\n\tbt3c_release(link);\n}\n\nstatic int bt3c_check_config(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tint *try = priv_data;\n\n\tif (!try)\n\t\tp_dev->io_lines = 16;\n\n\tif ((p_dev->resource[0]->end != 8) || (p_dev->resource[0]->start == 0))\n\t\treturn -EINVAL;\n\n\tp_dev->resource[0]->end = 8;\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\nstatic int bt3c_check_config_notpicky(struct pcmcia_device *p_dev,\n\t\t\t\t      void *priv_data)\n{\n\tstatic unsigned int base[5] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8, 0x0 };\n\tint j;\n\n\tif (p_dev->io_lines > 3)\n\t\treturn -ENODEV;\n\n\tp_dev->resource[0]->flags &= ~IO_DATA_PATH_WIDTH;\n\tp_dev->resource[0]->flags |= IO_DATA_PATH_WIDTH_8;\n\tp_dev->resource[0]->end = 8;\n\n\tfor (j = 0; j < 5; j++) {\n\t\tp_dev->resource[0]->start = base[j];\n\t\tp_dev->io_lines = base[j] ? 16 : 3;\n\t\tif (!pcmcia_request_io(p_dev))\n\t\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\nstatic int bt3c_config(struct pcmcia_device *link)\n{\n\tstruct bt3c_info *info = link->priv;\n\tint i;\n\tunsigned long try;\n\n\t \n\tfor (try = 0; try < 2; try++)\n\t\tif (!pcmcia_loop_config(link, bt3c_check_config, (void *) try))\n\t\t\tgoto found_port;\n\n\t \n\tif (!pcmcia_loop_config(link, bt3c_check_config_notpicky, NULL))\n\t\tgoto found_port;\n\n\tBT_ERR(\"No usable port range found\");\n\tgoto failed;\n\nfound_port:\n\ti = pcmcia_request_irq(link, &bt3c_interrupt);\n\tif (i != 0)\n\t\tgoto failed;\n\n\ti = pcmcia_enable_device(link);\n\tif (i != 0)\n\t\tgoto failed;\n\n\tif (bt3c_open(info) != 0)\n\t\tgoto failed;\n\n\treturn 0;\n\nfailed:\n\tbt3c_release(link);\n\treturn -ENODEV;\n}\n\n\nstatic void bt3c_release(struct pcmcia_device *link)\n{\n\tstruct bt3c_info *info = link->priv;\n\n\tbt3c_close(info);\n\n\tpcmcia_disable_device(link);\n}\n\n\nstatic const struct pcmcia_device_id bt3c_ids[] = {\n\tPCMCIA_DEVICE_PROD_ID13(\"3COM\", \"Bluetooth PC Card\", 0xefce0a31, 0xd4ce9b02),\n\tPCMCIA_DEVICE_NULL\n};\nMODULE_DEVICE_TABLE(pcmcia, bt3c_ids);\n\nstatic struct pcmcia_driver bt3c_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"bt3c_cs\",\n\t.probe\t\t= bt3c_probe,\n\t.remove\t\t= bt3c_detach,\n\t.id_table\t= bt3c_ids,\n};\nmodule_pcmcia_driver(bt3c_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}