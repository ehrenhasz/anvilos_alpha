{
  "module_name": "hci_serdev.c",
  "hash_id": "e22cdbcc5df1aef7730a3f838357fdf7dcb42fe9c6fc8a06ed8f3b2e981b6e56",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_serdev.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\n\t \n\tswitch (pkt_type) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n}\n\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\n{\n\tstruct sk_buff *skb = hu->tx_skb;\n\n\tif (!skb) {\n\t\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\t\tskb = hu->proto->dequeue(hu);\n\t} else\n\t\thu->tx_skb = NULL;\n\n\treturn skb;\n}\n\nstatic void hci_uart_write_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\n\tstruct serdev_device *serdev = hu->serdev;\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\n\t \n\tdo {\n\t\tclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\n\t\twhile ((skb = hci_uart_dequeue(hu))) {\n\t\t\tint len;\n\n\t\t\tlen = serdev_device_write_buf(serdev,\n\t\t\t\t\t\t      skb->data, skb->len);\n\t\t\thdev->stat.byte_tx += len;\n\n\t\t\tskb_pull(skb, len);\n\t\t\tif (skb->len) {\n\t\t\t\thu->tx_skb = skb;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\thci_uart_tx_complete(hu, hci_skb_pkt_type(skb));\n\t\t\tkfree_skb(skb);\n\t\t}\n\n\t\tclear_bit(HCI_UART_SENDING, &hu->tx_state);\n\t} while (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state));\n}\n\n \n\n \nstatic int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hdev %p serdev %p\", hdev, hu->serdev);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t \n\tserdev_device_write_flush(hu->serdev);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_open(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s %p\", hdev->name, hdev);\n\n\t \n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\terr = serdev_device_open(hu->serdev);\n\t\tif (err)\n\t\t\treturn err;\n\t\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t}\n\n\t \n\thdev->flush = hci_uart_flush;\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_close(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"hdev %p\", hdev);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\treturn 0;\n\n\thci_uart_flush(hdev);\n\thdev->flush = NULL;\n\n\t \n\tif (test_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks)) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\tserdev_device_close(hu->serdev);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s: type %d len %d\", hdev->name, hci_skb_pkt_type(skb),\n\t       skb->len);\n\n\thu->proto->enqueue(hu, skb);\n\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\nstatic int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t \n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\tserdev_device_set_baudrate(hu->serdev, speed);\n\n\t \n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (err)\n\t\t\tbt_dev_err(hdev, \"Failed to set baudrate\");\n\t\telse\n\t\t\tserdev_device_set_baudrate(hu->serdev, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading local version info failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver))\n\t\tbt_dev_err(hdev, \"Event length mismatch for version info\");\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic bool hci_uart_wakeup(struct hci_dev *hdev)\n{\n\t \n\treturn true;\n}\n\n \nstatic void hci_uart_write_wakeup(struct serdev_device *serdev)\n{\n\tstruct hci_uart *hu = serdev_device_get_drvdata(serdev);\n\n\tBT_DBG(\"\");\n\n\tif (!hu || serdev != hu->serdev) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thci_uart_tx_wakeup(hu);\n}\n\n \nstatic int hci_uart_receive_buf(struct serdev_device *serdev, const u8 *data,\n\t\t\t\t   size_t count)\n{\n\tstruct hci_uart *hu = serdev_device_get_drvdata(serdev);\n\n\tif (!hu || serdev != hu->serdev) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\treturn 0;\n\n\t \n\thu->proto->recv(hu, data, count);\n\n\tif (hu->hdev)\n\t\thu->hdev->stat.byte_rx += count;\n\n\treturn count;\n}\n\nstatic const struct serdev_device_ops hci_serdev_client_ops = {\n\t.receive_buf = hci_uart_receive_buf,\n\t.write_wakeup = hci_uart_write_wakeup,\n};\n\nint hci_uart_register_device(struct hci_uart *hu,\n\t\t\t     const struct hci_uart_proto *p)\n{\n\tint err;\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"\");\n\n\tserdev_device_set_client_ops(hu->serdev, &hci_serdev_client_ops);\n\n\tif (percpu_init_rwsem(&hu->proto_lock))\n\t\treturn -ENOMEM;\n\n\terr = serdev_device_open(hu->serdev);\n\tif (err)\n\t\tgoto err_rwsem;\n\n\terr = p->open(hu);\n\tif (err)\n\t\tgoto err_open;\n\n\thu->proto = p;\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\terr = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\thu->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, hu);\n\n\tINIT_WORK(&hu->init_ready, hci_uart_init_work);\n\tINIT_WORK(&hu->write_work, hci_uart_write_work);\n\n\t \n\tif (hu->proto->setup)\n\t\thdev->manufacturer = hu->proto->manufacturer;\n\n\thdev->open  = hci_uart_open;\n\thdev->close = hci_uart_close;\n\thdev->flush = hci_uart_flush;\n\thdev->send  = hci_uart_send_frame;\n\thdev->setup = hci_uart_setup;\n\tif (!hdev->wakeup)\n\t\thdev->wakeup = hci_uart_wakeup;\n\tSET_HCIDEV_DEV(hdev, &hu->serdev->dev);\n\n\tif (test_bit(HCI_UART_NO_SUSPEND_NOTIFIER, &hu->flags))\n\t\tset_bit(HCI_QUIRK_NO_SUSPEND_NOTIFIER, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\tif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn 0;\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\terr = -ENODEV;\n\t\tgoto err_register;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n\n\treturn 0;\n\nerr_register:\n\thci_free_dev(hdev);\nerr_alloc:\n\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\tp->close(hu);\nerr_open:\n\tserdev_device_close(hu->serdev);\nerr_rwsem:\n\tpercpu_free_rwsem(&hu->proto_lock);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(hci_uart_register_device);\n\nvoid hci_uart_unregister_device(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\n\tcancel_work_sync(&hu->init_ready);\n\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n\n\tcancel_work_sync(&hu->write_work);\n\n\thu->proto->close(hu);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\tserdev_device_close(hu->serdev);\n\t}\n\tpercpu_free_rwsem(&hu->proto_lock);\n}\nEXPORT_SYMBOL_GPL(hci_uart_unregister_device);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}