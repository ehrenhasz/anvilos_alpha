{
  "module_name": "btmrvl_sdio.c",
  "hash_id": "7de05c0772747ea8a28184b21ada172f72524479b9ec35267c43d2481f319408",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btmrvl_sdio.c",
  "human_readable_source": "\n \n\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n\n#include <linux/mmc/sdio_ids.h>\n#include <linux/mmc/sdio_func.h>\n#include <linux/module.h>\n#include <linux/devcoredump.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btmrvl_drv.h\"\n#include \"btmrvl_sdio.h\"\n\n#define VERSION \"1.0\"\n\nstatic struct memory_type_mapping mem_type_mapping_tbl[] = {\n\t{\"ITCM\", NULL, 0, 0xF0},\n\t{\"DTCM\", NULL, 0, 0xF1},\n\t{\"SQRAM\", NULL, 0, 0xF2},\n\t{\"APU\", NULL, 0, 0xF3},\n\t{\"CIU\", NULL, 0, 0xF4},\n\t{\"ICU\", NULL, 0, 0xF5},\n\t{\"MAC\", NULL, 0, 0xF6},\n\t{\"EXT7\", NULL, 0, 0xF7},\n\t{\"EXT8\", NULL, 0, 0xF8},\n\t{\"EXT9\", NULL, 0, 0xF9},\n\t{\"EXT10\", NULL, 0, 0xFA},\n\t{\"EXT11\", NULL, 0, 0xFB},\n\t{\"EXT12\", NULL, 0, 0xFC},\n\t{\"EXT13\", NULL, 0, 0xFD},\n\t{\"EXTLAST\", NULL, 0, 0xFE},\n};\n\nstatic const struct of_device_id btmrvl_sdio_of_match_table[] __maybe_unused = {\n\t{ .compatible = \"marvell,sd8897-bt\" },\n\t{ .compatible = \"marvell,sd8997-bt\" },\n\t{ }\n};\n\nstatic irqreturn_t btmrvl_wake_irq_bt(int irq, void *priv)\n{\n\tstruct btmrvl_sdio_card *card = priv;\n\tstruct device *dev = &card->func->dev;\n\tstruct btmrvl_plt_wake_cfg *cfg = card->plt_wake_cfg;\n\n\tdev_info(dev, \"wake by bt\\n\");\n\tcfg->wake_by_bt = true;\n\tdisable_irq_nosync(irq);\n\n\tpm_wakeup_event(dev, 0);\n\tpm_system_wakeup();\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic int btmrvl_sdio_probe_of(struct device *dev,\n\t\t\t\tstruct btmrvl_sdio_card *card)\n{\n\tstruct btmrvl_plt_wake_cfg *cfg;\n\tint ret;\n\n\tif (!dev->of_node ||\n\t    !of_match_node(btmrvl_sdio_of_match_table, dev->of_node)) {\n\t\tdev_info(dev, \"sdio device tree data not available\\n\");\n\t\treturn -1;\n\t}\n\n\tcard->plt_of_node = dev->of_node;\n\n\tcard->plt_wake_cfg = devm_kzalloc(dev, sizeof(*card->plt_wake_cfg),\n\t\t\t\t\t  GFP_KERNEL);\n\tcfg = card->plt_wake_cfg;\n\tif (cfg && card->plt_of_node) {\n\t\tcfg->irq_bt = irq_of_parse_and_map(card->plt_of_node, 0);\n\t\tif (!cfg->irq_bt) {\n\t\t\tdev_err(dev, \"fail to parse irq_bt from device tree\\n\");\n\t\t\tcfg->irq_bt = -1;\n\t\t} else {\n\t\t\tret = devm_request_irq(dev, cfg->irq_bt,\n\t\t\t\t\t       btmrvl_wake_irq_bt,\n\t\t\t\t\t       0, \"bt_wake\", card);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to request irq_bt %d (%d)\\n\",\n\t\t\t\t\tcfg->irq_bt, ret);\n\t\t\t}\n\n\t\t\t \n\t\t\tdevice_init_wakeup(dev, true);\n\t\t\tdisable_irq(cfg->irq_bt);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic u8 user_rmmod;\nstatic u8 sdio_ireg;\n\nstatic const struct btmrvl_sdio_card_reg btmrvl_reg_8688 = {\n\t.cfg = 0x03,\n\t.host_int_mask = 0x04,\n\t.host_intstatus = 0x05,\n\t.card_status = 0x20,\n\t.sq_read_base_addr_a0 = 0x10,\n\t.sq_read_base_addr_a1 = 0x11,\n\t.card_fw_status0 = 0x40,\n\t.card_fw_status1 = 0x41,\n\t.card_rx_len = 0x42,\n\t.card_rx_unit = 0x43,\n\t.io_port_0 = 0x00,\n\t.io_port_1 = 0x01,\n\t.io_port_2 = 0x02,\n\t.int_read_to_clear = false,\n};\nstatic const struct btmrvl_sdio_card_reg btmrvl_reg_87xx = {\n\t.cfg = 0x00,\n\t.host_int_mask = 0x02,\n\t.host_intstatus = 0x03,\n\t.card_status = 0x30,\n\t.sq_read_base_addr_a0 = 0x40,\n\t.sq_read_base_addr_a1 = 0x41,\n\t.card_revision = 0x5c,\n\t.card_fw_status0 = 0x60,\n\t.card_fw_status1 = 0x61,\n\t.card_rx_len = 0x62,\n\t.card_rx_unit = 0x63,\n\t.io_port_0 = 0x78,\n\t.io_port_1 = 0x79,\n\t.io_port_2 = 0x7a,\n\t.int_read_to_clear = false,\n};\n\nstatic const struct btmrvl_sdio_card_reg btmrvl_reg_8887 = {\n\t.cfg = 0x00,\n\t.host_int_mask = 0x08,\n\t.host_intstatus = 0x0C,\n\t.card_status = 0x5C,\n\t.sq_read_base_addr_a0 = 0x6C,\n\t.sq_read_base_addr_a1 = 0x6D,\n\t.card_revision = 0xC8,\n\t.card_fw_status0 = 0x88,\n\t.card_fw_status1 = 0x89,\n\t.card_rx_len = 0x8A,\n\t.card_rx_unit = 0x8B,\n\t.io_port_0 = 0xE4,\n\t.io_port_1 = 0xE5,\n\t.io_port_2 = 0xE6,\n\t.int_read_to_clear = true,\n\t.host_int_rsr = 0x04,\n\t.card_misc_cfg = 0xD8,\n};\n\nstatic const struct btmrvl_sdio_card_reg btmrvl_reg_8897 = {\n\t.cfg = 0x00,\n\t.host_int_mask = 0x02,\n\t.host_intstatus = 0x03,\n\t.card_status = 0x50,\n\t.sq_read_base_addr_a0 = 0x60,\n\t.sq_read_base_addr_a1 = 0x61,\n\t.card_revision = 0xbc,\n\t.card_fw_status0 = 0xc0,\n\t.card_fw_status1 = 0xc1,\n\t.card_rx_len = 0xc2,\n\t.card_rx_unit = 0xc3,\n\t.io_port_0 = 0xd8,\n\t.io_port_1 = 0xd9,\n\t.io_port_2 = 0xda,\n\t.int_read_to_clear = true,\n\t.host_int_rsr = 0x01,\n\t.card_misc_cfg = 0xcc,\n\t.fw_dump_ctrl = 0xe2,\n\t.fw_dump_start = 0xe3,\n\t.fw_dump_end = 0xea,\n};\n\nstatic const struct btmrvl_sdio_card_reg btmrvl_reg_89xx = {\n\t.cfg = 0x00,\n\t.host_int_mask = 0x08,\n\t.host_intstatus = 0x0c,\n\t.card_status = 0x5c,\n\t.sq_read_base_addr_a0 = 0xf8,\n\t.sq_read_base_addr_a1 = 0xf9,\n\t.card_revision = 0xc8,\n\t.card_fw_status0 = 0xe8,\n\t.card_fw_status1 = 0xe9,\n\t.card_rx_len = 0xea,\n\t.card_rx_unit = 0xeb,\n\t.io_port_0 = 0xe4,\n\t.io_port_1 = 0xe5,\n\t.io_port_2 = 0xe6,\n\t.int_read_to_clear = true,\n\t.host_int_rsr = 0x04,\n\t.card_misc_cfg = 0xd8,\n\t.fw_dump_ctrl = 0xf0,\n\t.fw_dump_start = 0xf1,\n\t.fw_dump_end = 0xf8,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8688 = {\n\t.helper\t\t= \"mrvl/sd8688_helper.bin\",\n\t.firmware\t= \"mrvl/sd8688.bin\",\n\t.reg\t\t= &btmrvl_reg_8688,\n\t.support_pscan_win_report = false,\n\t.sd_blksz_fw_dl\t= 64,\n\t.supports_fw_dump = false,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8787 = {\n\t.helper\t\t= NULL,\n\t.firmware\t= \"mrvl/sd8787_uapsta.bin\",\n\t.reg\t\t= &btmrvl_reg_87xx,\n\t.support_pscan_win_report = false,\n\t.sd_blksz_fw_dl\t= 256,\n\t.supports_fw_dump = false,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8797 = {\n\t.helper\t\t= NULL,\n\t.firmware\t= \"mrvl/sd8797_uapsta.bin\",\n\t.reg\t\t= &btmrvl_reg_87xx,\n\t.support_pscan_win_report = false,\n\t.sd_blksz_fw_dl\t= 256,\n\t.supports_fw_dump = false,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8887 = {\n\t.helper\t\t= NULL,\n\t.firmware\t= \"mrvl/sd8887_uapsta.bin\",\n\t.reg\t\t= &btmrvl_reg_8887,\n\t.support_pscan_win_report = true,\n\t.sd_blksz_fw_dl\t= 256,\n\t.supports_fw_dump = false,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8897 = {\n\t.helper\t\t= NULL,\n\t.firmware\t= \"mrvl/sd8897_uapsta.bin\",\n\t.reg\t\t= &btmrvl_reg_8897,\n\t.support_pscan_win_report = true,\n\t.sd_blksz_fw_dl\t= 256,\n\t.supports_fw_dump = true,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8977 = {\n\t.helper         = NULL,\n\t.firmware       = \"mrvl/sdsd8977_combo_v2.bin\",\n\t.reg            = &btmrvl_reg_89xx,\n\t.support_pscan_win_report = true,\n\t.sd_blksz_fw_dl = 256,\n\t.supports_fw_dump = true,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8987 = {\n\t.helper\t\t= NULL,\n\t.firmware\t= \"mrvl/sd8987_uapsta.bin\",\n\t.reg\t\t= &btmrvl_reg_89xx,\n\t.support_pscan_win_report = true,\n\t.sd_blksz_fw_dl\t= 256,\n\t.supports_fw_dump = true,\n};\n\nstatic const struct btmrvl_sdio_device btmrvl_sdio_sd8997 = {\n\t.helper         = NULL,\n\t.firmware       = \"mrvl/sdsd8997_combo_v4.bin\",\n\t.reg            = &btmrvl_reg_89xx,\n\t.support_pscan_win_report = true,\n\t.sd_blksz_fw_dl = 256,\n\t.supports_fw_dump = true,\n};\n\nstatic const struct sdio_device_id btmrvl_sdio_ids[] = {\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8688_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8688 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8787 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8787_BT_AMP),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8787 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8797_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8797 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8887_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8887 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8897_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8897 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8977_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8977 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8987_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8987 },\n\t \n\t{ SDIO_DEVICE(SDIO_VENDOR_ID_MARVELL, SDIO_DEVICE_ID_MARVELL_8997_BT),\n\t\t\t.driver_data = (unsigned long)&btmrvl_sdio_sd8997 },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(sdio, btmrvl_sdio_ids);\n\nstatic int btmrvl_sdio_get_rx_unit(struct btmrvl_sdio_card *card)\n{\n\tu8 reg;\n\tint ret;\n\n\treg = sdio_readb(card->func, card->reg->card_rx_unit, &ret);\n\tif (!ret)\n\t\tcard->rx_unit = reg;\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_read_fw_status(struct btmrvl_sdio_card *card, u16 *dat)\n{\n\tu8 fws0, fws1;\n\tint ret;\n\n\t*dat = 0;\n\n\tfws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);\n\tif (ret)\n\t\treturn -EIO;\n\n\tfws1 = sdio_readb(card->func, card->reg->card_fw_status1, &ret);\n\tif (ret)\n\t\treturn -EIO;\n\n\t*dat = (((u16) fws1) << 8) | fws0;\n\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_read_rx_len(struct btmrvl_sdio_card *card, u16 *dat)\n{\n\tu8 reg;\n\tint ret;\n\n\treg = sdio_readb(card->func, card->reg->card_rx_len, &ret);\n\tif (!ret)\n\t\t*dat = (u16) reg << card->rx_unit;\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_enable_host_int_mask(struct btmrvl_sdio_card *card,\n\t\t\t\t\t\t\t\tu8 mask)\n{\n\tint ret;\n\n\tsdio_writeb(card->func, mask, card->reg->host_int_mask, &ret);\n\tif (ret) {\n\t\tBT_ERR(\"Unable to enable the host interrupt!\");\n\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_disable_host_int_mask(struct btmrvl_sdio_card *card,\n\t\t\t\t\t\t\t\tu8 mask)\n{\n\tu8 host_int_mask;\n\tint ret;\n\n\thost_int_mask = sdio_readb(card->func, card->reg->host_int_mask, &ret);\n\tif (ret)\n\t\treturn -EIO;\n\n\thost_int_mask &= ~mask;\n\n\tsdio_writeb(card->func, host_int_mask, card->reg->host_int_mask, &ret);\n\tif (ret < 0) {\n\t\tBT_ERR(\"Unable to disable the host interrupt!\");\n\t\treturn -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_poll_card_status(struct btmrvl_sdio_card *card, u8 bits)\n{\n\tunsigned int tries;\n\tu8 status;\n\tint ret;\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES * 1000; tries++) {\n\t\tstatus = sdio_readb(card->func, card->reg->card_status,\t&ret);\n\t\tif (ret)\n\t\t\tgoto failed;\n\t\tif ((status & bits) == bits)\n\t\t\treturn ret;\n\n\t\tudelay(1);\n\t}\n\n\tret = -ETIMEDOUT;\n\nfailed:\n\tBT_ERR(\"FAILED! ret=%d\", ret);\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_verify_fw_download(struct btmrvl_sdio_card *card,\n\t\t\t\t\t\t\t\tint pollnum)\n{\n\tu16 firmwarestat;\n\tint tries, ret;\n\n\t  \n\tfor (tries = 0; tries < pollnum; tries++) {\n\t\tsdio_claim_host(card->func);\n\t\tret = btmrvl_sdio_read_fw_status(card, &firmwarestat);\n\t\tsdio_release_host(card->func);\n\t\tif (ret < 0)\n\t\t\tcontinue;\n\n\t\tif (firmwarestat == FIRMWARE_READY)\n\t\t\treturn 0;\n\n\t\tmsleep(100);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int btmrvl_sdio_download_helper(struct btmrvl_sdio_card *card)\n{\n\tconst struct firmware *fw_helper = NULL;\n\tconst u8 *helper = NULL;\n\tint ret;\n\tvoid *tmphlprbuf = NULL;\n\tint tmphlprbufsz, hlprblknow, helperlen;\n\tu8 *helperbuf;\n\tu32 tx_len;\n\n\tret = request_firmware(&fw_helper, card->helper,\n\t\t\t\t\t\t&card->func->dev);\n\tif ((ret < 0) || !fw_helper) {\n\t\tBT_ERR(\"request_firmware(helper) failed, error code = %d\",\n\t\t\t\t\t\t\t\t\tret);\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\thelper = fw_helper->data;\n\thelperlen = fw_helper->size;\n\n\tBT_DBG(\"Downloading helper image (%d bytes), block size %d bytes\",\n\t\t\t\t\t\thelperlen, SDIO_BLOCK_SIZE);\n\n\ttmphlprbufsz = ALIGN_SZ(BTM_UPLD_SIZE, BTSDIO_DMA_ALIGN);\n\n\ttmphlprbuf = kzalloc(tmphlprbufsz, GFP_KERNEL);\n\tif (!tmphlprbuf) {\n\t\tBT_ERR(\"Unable to allocate buffer for helper.\"\n\t\t\t\" Terminating download\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\thelperbuf = (u8 *) ALIGN_ADDR(tmphlprbuf, BTSDIO_DMA_ALIGN);\n\n\t \n\ttx_len = (FIRMWARE_TRANSFER_NBLOCK * SDIO_BLOCK_SIZE)\n\t\t\t- SDIO_HEADER_LEN;\n\thlprblknow = 0;\n\n\tdo {\n\t\tret = btmrvl_sdio_poll_card_status(card,\n\t\t\t\t\t    CARD_IO_READY | DN_LD_CARD_RDY);\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"Helper download poll status timeout @ %d\",\n\t\t\t\thlprblknow);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (hlprblknow >= helperlen)\n\t\t\tbreak;\n\n\t\tif (helperlen - hlprblknow < tx_len)\n\t\t\ttx_len = helperlen - hlprblknow;\n\n\t\t \n\t\thelperbuf[0] = ((tx_len & 0x000000ff) >> 0);\n\t\thelperbuf[1] = ((tx_len & 0x0000ff00) >> 8);\n\t\thelperbuf[2] = ((tx_len & 0x00ff0000) >> 16);\n\t\thelperbuf[3] = ((tx_len & 0xff000000) >> 24);\n\n\t\tmemcpy(&helperbuf[SDIO_HEADER_LEN], &helper[hlprblknow],\n\t\t\t\ttx_len);\n\n\t\t \n\t\tret = sdio_writesb(card->func, card->ioport, helperbuf,\n\t\t\t\tFIRMWARE_TRANSFER_NBLOCK * SDIO_BLOCK_SIZE);\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"IO error during helper download @ %d\",\n\t\t\t\thlprblknow);\n\t\t\tgoto done;\n\t\t}\n\n\t\thlprblknow += tx_len;\n\t} while (true);\n\n\tBT_DBG(\"Transferring helper image EOF block\");\n\n\tmemset(helperbuf, 0x0, SDIO_BLOCK_SIZE);\n\n\tret = sdio_writesb(card->func, card->ioport, helperbuf,\n\t\t\t\t\t\t\tSDIO_BLOCK_SIZE);\n\tif (ret < 0) {\n\t\tBT_ERR(\"IO error in writing helper image EOF block\");\n\t\tgoto done;\n\t}\n\n\tret = 0;\n\ndone:\n\tkfree(tmphlprbuf);\n\trelease_firmware(fw_helper);\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_download_fw_w_helper(struct btmrvl_sdio_card *card)\n{\n\tconst struct firmware *fw_firmware = NULL;\n\tconst u8 *firmware = NULL;\n\tint firmwarelen, tmpfwbufsz, ret;\n\tunsigned int tries, offset;\n\tu8 base0, base1;\n\tvoid *tmpfwbuf = NULL;\n\tu8 *fwbuf;\n\tu16 len, blksz_dl = card->sd_blksz_fw_dl;\n\tint txlen = 0, tx_blocks = 0, count = 0;\n\n\tret = request_firmware(&fw_firmware, card->firmware,\n\t\t\t\t\t\t\t&card->func->dev);\n\tif ((ret < 0) || !fw_firmware) {\n\t\tBT_ERR(\"request_firmware(firmware) failed, error code = %d\",\n\t\t\t\t\t\t\t\t\tret);\n\t\tret = -ENOENT;\n\t\tgoto done;\n\t}\n\n\tfirmware = fw_firmware->data;\n\tfirmwarelen = fw_firmware->size;\n\n\tBT_DBG(\"Downloading FW image (%d bytes)\", firmwarelen);\n\n\ttmpfwbufsz = ALIGN_SZ(BTM_UPLD_SIZE, BTSDIO_DMA_ALIGN);\n\ttmpfwbuf = kzalloc(tmpfwbufsz, GFP_KERNEL);\n\tif (!tmpfwbuf) {\n\t\tBT_ERR(\"Unable to allocate buffer for firmware.\"\n\t\t       \" Terminating download\");\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tfwbuf = (u8 *) ALIGN_ADDR(tmpfwbuf, BTSDIO_DMA_ALIGN);\n\n\t \n\toffset = 0;\n\tdo {\n\t\tret = btmrvl_sdio_poll_card_status(card,\n\t\t\t\t\tCARD_IO_READY | DN_LD_CARD_RDY);\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"FW download with helper poll status\"\n\t\t\t\t\t\t\" timeout @ %d\", offset);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (offset >= firmwarelen)\n\t\t\tbreak;\n\n\t\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\t\tbase0 = sdio_readb(card->func,\n\t\t\t\t\tcard->reg->sq_read_base_addr_a0, &ret);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"BASE0 register read failed:\"\n\t\t\t\t\t\" base0 = 0x%04X(%d).\"\n\t\t\t\t\t\" Terminating download\",\n\t\t\t\t\tbase0, base0);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbase1 = sdio_readb(card->func,\n\t\t\t\t\tcard->reg->sq_read_base_addr_a1, &ret);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"BASE1 register read failed:\"\n\t\t\t\t\t\" base1 = 0x%04X(%d).\"\n\t\t\t\t\t\" Terminating download\",\n\t\t\t\t\tbase1, base1);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\n\t\t\tlen = (((u16) base1) << 8) | base0;\n\t\t\tif (len)\n\t\t\t\tbreak;\n\n\t\t\tudelay(10);\n\t\t}\n\n\t\tif (!len)\n\t\t\tbreak;\n\t\telse if (len > BTM_UPLD_SIZE) {\n\t\t\tBT_ERR(\"FW download failure @%d, invalid length %d\",\n\t\t\t\t\t\t\t\toffset, len);\n\t\t\tret = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttxlen = len;\n\n\t\tif (len & BIT(0)) {\n\t\t\tcount++;\n\t\t\tif (count > MAX_WRITE_IOMEM_RETRY) {\n\t\t\t\tBT_ERR(\"FW download failure @%d, \"\n\t\t\t\t\t\"over max retry count\", offset);\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tBT_ERR(\"FW CRC error indicated by the helper: \"\n\t\t\t\t\"len = 0x%04X, txlen = %d\", len, txlen);\n\t\t\tlen &= ~BIT(0);\n\t\t\t \n\t\t\ttxlen = 0;\n\t\t} else {\n\t\t\tcount = 0;\n\n\t\t\t \n\t\t\tif (firmwarelen - offset < txlen)\n\t\t\t\ttxlen = firmwarelen - offset;\n\n\t\t\ttx_blocks = DIV_ROUND_UP(txlen, blksz_dl);\n\n\t\t\tmemcpy(fwbuf, &firmware[offset], txlen);\n\t\t}\n\n\t\tret = sdio_writesb(card->func, card->ioport, fwbuf,\n\t\t\t\t\t\ttx_blocks * blksz_dl);\n\n\t\tif (ret < 0) {\n\t\t\tBT_ERR(\"FW download, writesb(%d) failed @%d\",\n\t\t\t\t\t\t\tcount, offset);\n\t\t\tsdio_writeb(card->func, HOST_CMD53_FIN,\n\t\t\t\t\t\tcard->reg->cfg, &ret);\n\t\t\tif (ret)\n\t\t\t\tBT_ERR(\"writeb failed (CFG)\");\n\t\t}\n\n\t\toffset += txlen;\n\t} while (true);\n\n\tBT_INFO(\"FW download over, size %d bytes\", offset);\n\n\tret = 0;\n\ndone:\n\tkfree(tmpfwbuf);\n\trelease_firmware(fw_firmware);\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_card_to_host(struct btmrvl_private *priv)\n{\n\tu16 buf_len = 0;\n\tint ret, num_blocks, blksz;\n\tstruct sk_buff *skb = NULL;\n\tu32 type;\n\tu8 *payload;\n\tstruct hci_dev *hdev = priv->btmrvl_dev.hcidev;\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\n\tif (!card || !card->func) {\n\t\tBT_ERR(\"card or function is NULL!\");\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tret = btmrvl_sdio_read_rx_len(card, &buf_len);\n\tif (ret < 0) {\n\t\tBT_ERR(\"read rx_len failed\");\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\tblksz = SDIO_BLOCK_SIZE;\n\tnum_blocks = DIV_ROUND_UP(buf_len, blksz);\n\n\tif (buf_len <= SDIO_HEADER_LEN\n\t    || (num_blocks * blksz) > ALLOC_BUF_SIZE) {\n\t\tBT_ERR(\"invalid packet length: %d\", buf_len);\n\t\tret = -EINVAL;\n\t\tgoto exit;\n\t}\n\n\t \n\tskb = bt_skb_alloc(num_blocks * blksz + BTSDIO_DMA_ALIGN, GFP_KERNEL);\n\tif (!skb) {\n\t\tBT_ERR(\"No free skb\");\n\t\tret = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tif ((unsigned long) skb->data & (BTSDIO_DMA_ALIGN - 1)) {\n\t\tskb_put(skb, (unsigned long) skb->data &\n\t\t\t\t\t(BTSDIO_DMA_ALIGN - 1));\n\t\tskb_pull(skb, (unsigned long) skb->data &\n\t\t\t\t\t(BTSDIO_DMA_ALIGN - 1));\n\t}\n\n\tpayload = skb->data;\n\n\tret = sdio_readsb(card->func, payload, card->ioport,\n\t\t\t  num_blocks * blksz);\n\tif (ret < 0) {\n\t\tBT_ERR(\"readsb failed: %d\", ret);\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\t \n\n\tbuf_len = payload[0];\n\tbuf_len |= payload[1] << 8;\n\tbuf_len |= payload[2] << 16;\n\n\tif (buf_len > blksz * num_blocks) {\n\t\tBT_ERR(\"Skip incorrect packet: hdrlen %d buffer %d\",\n\t\t       buf_len, blksz * num_blocks);\n\t\tret = -EIO;\n\t\tgoto exit;\n\t}\n\n\ttype = payload[3];\n\n\tswitch (type) {\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_EVENT_PKT:\n\t\thci_skb_pkt_type(skb) = type;\n\t\tskb_put(skb, buf_len);\n\t\tskb_pull(skb, SDIO_HEADER_LEN);\n\n\t\tif (type == HCI_EVENT_PKT) {\n\t\t\tif (btmrvl_check_evtpkt(priv, skb))\n\t\t\t\thci_recv_frame(hdev, skb);\n\t\t} else {\n\t\t\thci_recv_frame(hdev, skb);\n\t\t}\n\n\t\thdev->stat.byte_rx += buf_len;\n\t\tbreak;\n\n\tcase MRVL_VENDOR_PKT:\n\t\thci_skb_pkt_type(skb) = HCI_VENDOR_PKT;\n\t\tskb_put(skb, buf_len);\n\t\tskb_pull(skb, SDIO_HEADER_LEN);\n\n\t\tif (btmrvl_process_event(priv, skb))\n\t\t\thci_recv_frame(hdev, skb);\n\n\t\thdev->stat.byte_rx += buf_len;\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown packet type:%d\", type);\n\t\tBT_ERR(\"hex: %*ph\", blksz * num_blocks, payload);\n\n\t\tkfree_skb(skb);\n\t\tskb = NULL;\n\t\tbreak;\n\t}\n\nexit:\n\tif (ret) {\n\t\thdev->stat.err_rx++;\n\t\tkfree_skb(skb);\n\t}\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_process_int_status(struct btmrvl_private *priv)\n{\n\tulong flags;\n\tu8 ireg;\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tireg = sdio_ireg;\n\tsdio_ireg = 0;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tsdio_claim_host(card->func);\n\tif (ireg & DN_LD_HOST_INT_STATUS) {\n\t\tif (priv->btmrvl_dev.tx_dnld_rdy)\n\t\t\tBT_DBG(\"tx_done already received: \"\n\t\t\t\t\" int_status=0x%x\", ireg);\n\t\telse\n\t\t\tpriv->btmrvl_dev.tx_dnld_rdy = true;\n\t}\n\n\tif (ireg & UP_LD_HOST_INT_STATUS)\n\t\tbtmrvl_sdio_card_to_host(priv);\n\n\tsdio_release_host(card->func);\n\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_read_to_clear(struct btmrvl_sdio_card *card, u8 *ireg)\n{\n\tstruct btmrvl_adapter *adapter = card->priv->adapter;\n\tint ret;\n\n\tret = sdio_readsb(card->func, adapter->hw_regs, 0, SDIO_BLOCK_SIZE);\n\tif (ret) {\n\t\tBT_ERR(\"sdio_readsb: read int hw_regs failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\t*ireg = adapter->hw_regs[card->reg->host_intstatus];\n\tBT_DBG(\"hw_regs[%#x]=%#x\", card->reg->host_intstatus, *ireg);\n\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_write_to_clear(struct btmrvl_sdio_card *card, u8 *ireg)\n{\n\tint ret;\n\n\t*ireg = sdio_readb(card->func, card->reg->host_intstatus, &ret);\n\tif (ret) {\n\t\tBT_ERR(\"sdio_readb: read int status failed: %d\", ret);\n\t\treturn ret;\n\t}\n\n\tif (*ireg) {\n\t\t \n\t\tBT_DBG(\"int_status = 0x%x\", *ireg);\n\n\t\tsdio_writeb(card->func, ~(*ireg) & (DN_LD_HOST_INT_STATUS |\n\t\t\t\t\t\t    UP_LD_HOST_INT_STATUS),\n\t\t\t    card->reg->host_intstatus, &ret);\n\t\tif (ret) {\n\t\t\tBT_ERR(\"sdio_writeb: clear int status failed: %d\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void btmrvl_sdio_interrupt(struct sdio_func *func)\n{\n\tstruct btmrvl_private *priv;\n\tstruct btmrvl_sdio_card *card;\n\tulong flags;\n\tu8 ireg = 0;\n\tint ret;\n\n\tcard = sdio_get_drvdata(func);\n\tif (!card || !card->priv) {\n\t\tBT_ERR(\"sbi_interrupt(%p) card or priv is NULL, card=%p\",\n\t\t       func, card);\n\t\treturn;\n\t}\n\n\tpriv = card->priv;\n\n\tif (priv->surprise_removed)\n\t\treturn;\n\n\tif (card->reg->int_read_to_clear)\n\t\tret = btmrvl_sdio_read_to_clear(card, &ireg);\n\telse\n\t\tret = btmrvl_sdio_write_to_clear(card, &ireg);\n\n\tif (ret)\n\t\treturn;\n\n\tspin_lock_irqsave(&priv->driver_lock, flags);\n\tsdio_ireg |= ireg;\n\tspin_unlock_irqrestore(&priv->driver_lock, flags);\n\n\tbtmrvl_interrupt(priv);\n}\n\nstatic int btmrvl_sdio_register_dev(struct btmrvl_sdio_card *card)\n{\n\tstruct sdio_func *func;\n\tu8 reg;\n\tint ret;\n\n\tif (!card || !card->func) {\n\t\tBT_ERR(\"Error: card or function is NULL!\");\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\tfunc = card->func;\n\n\tsdio_claim_host(func);\n\n\tret = sdio_enable_func(func);\n\tif (ret) {\n\t\tBT_ERR(\"sdio_enable_func() failed: ret=%d\", ret);\n\t\tret = -EIO;\n\t\tgoto release_host;\n\t}\n\n\tret = sdio_claim_irq(func, btmrvl_sdio_interrupt);\n\tif (ret) {\n\t\tBT_ERR(\"sdio_claim_irq failed: ret=%d\", ret);\n\t\tret = -EIO;\n\t\tgoto disable_func;\n\t}\n\n\tret = sdio_set_block_size(card->func, SDIO_BLOCK_SIZE);\n\tif (ret) {\n\t\tBT_ERR(\"cannot set SDIO block size\");\n\t\tret = -EIO;\n\t\tgoto release_irq;\n\t}\n\n\treg = sdio_readb(func, card->reg->io_port_0, &ret);\n\tif (ret < 0) {\n\t\tret = -EIO;\n\t\tgoto release_irq;\n\t}\n\n\tcard->ioport = reg;\n\n\treg = sdio_readb(func, card->reg->io_port_1, &ret);\n\tif (ret < 0) {\n\t\tret = -EIO;\n\t\tgoto release_irq;\n\t}\n\n\tcard->ioport |= (reg << 8);\n\n\treg = sdio_readb(func, card->reg->io_port_2, &ret);\n\tif (ret < 0) {\n\t\tret = -EIO;\n\t\tgoto release_irq;\n\t}\n\n\tcard->ioport |= (reg << 16);\n\n\tBT_DBG(\"SDIO FUNC%d IO port: 0x%x\", func->num, card->ioport);\n\n\tif (card->reg->int_read_to_clear) {\n\t\treg = sdio_readb(func, card->reg->host_int_rsr, &ret);\n\t\tif (ret < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_irq;\n\t\t}\n\t\tsdio_writeb(func, reg | 0x3f, card->reg->host_int_rsr, &ret);\n\t\tif (ret < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_irq;\n\t\t}\n\n\t\treg = sdio_readb(func, card->reg->card_misc_cfg, &ret);\n\t\tif (ret < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_irq;\n\t\t}\n\t\tsdio_writeb(func, reg | 0x10, card->reg->card_misc_cfg, &ret);\n\t\tif (ret < 0) {\n\t\t\tret = -EIO;\n\t\t\tgoto release_irq;\n\t\t}\n\t}\n\n\tsdio_set_drvdata(func, card);\n\n\tsdio_release_host(func);\n\n\treturn 0;\n\nrelease_irq:\n\tsdio_release_irq(func);\n\ndisable_func:\n\tsdio_disable_func(func);\n\nrelease_host:\n\tsdio_release_host(func);\n\nfailed:\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_unregister_dev(struct btmrvl_sdio_card *card)\n{\n\tif (card && card->func) {\n\t\tsdio_claim_host(card->func);\n\t\tsdio_release_irq(card->func);\n\t\tsdio_disable_func(card->func);\n\t\tsdio_release_host(card->func);\n\t\tsdio_set_drvdata(card->func, NULL);\n\t}\n\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_enable_host_int(struct btmrvl_sdio_card *card)\n{\n\tint ret;\n\n\tif (!card || !card->func)\n\t\treturn -EINVAL;\n\n\tsdio_claim_host(card->func);\n\n\tret = btmrvl_sdio_enable_host_int_mask(card, HIM_ENABLE);\n\n\tbtmrvl_sdio_get_rx_unit(card);\n\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_disable_host_int(struct btmrvl_sdio_card *card)\n{\n\tint ret;\n\n\tif (!card || !card->func)\n\t\treturn -EINVAL;\n\n\tsdio_claim_host(card->func);\n\n\tret = btmrvl_sdio_disable_host_int_mask(card, HIM_DISABLE);\n\n\tsdio_release_host(card->func);\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_host_to_card(struct btmrvl_private *priv,\n\t\t\t\tu8 *payload, u16 nb)\n{\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret = 0;\n\tint blksz;\n\tint i = 0;\n\tu8 *buf = NULL;\n\tvoid *tmpbuf = NULL;\n\tint tmpbufsz;\n\n\tif (!card || !card->func) {\n\t\tBT_ERR(\"card or function is NULL!\");\n\t\treturn -EINVAL;\n\t}\n\n\tblksz = DIV_ROUND_UP(nb, SDIO_BLOCK_SIZE) * SDIO_BLOCK_SIZE;\n\n\tbuf = payload;\n\tif ((unsigned long) payload & (BTSDIO_DMA_ALIGN - 1) ||\n\t    nb < blksz) {\n\t\ttmpbufsz = ALIGN_SZ(blksz, BTSDIO_DMA_ALIGN) +\n\t\t\t   BTSDIO_DMA_ALIGN;\n\t\ttmpbuf = kzalloc(tmpbufsz, GFP_KERNEL);\n\t\tif (!tmpbuf)\n\t\t\treturn -ENOMEM;\n\t\tbuf = (u8 *) ALIGN_ADDR(tmpbuf, BTSDIO_DMA_ALIGN);\n\t\tmemcpy(buf, payload, nb);\n\t}\n\n\tsdio_claim_host(card->func);\n\n\tdo {\n\t\t \n\t\tret = sdio_writesb(card->func, card->ioport, buf,\n\t\t\t\t   blksz);\n\t\tif (ret < 0) {\n\t\t\ti++;\n\t\t\tBT_ERR(\"i=%d writesb failed: %d\", i, ret);\n\t\t\tBT_ERR(\"hex: %*ph\", nb, payload);\n\t\t\tret = -EIO;\n\t\t\tif (i > MAX_WRITE_IOMEM_RETRY)\n\t\t\t\tgoto exit;\n\t\t}\n\t} while (ret);\n\n\tpriv->btmrvl_dev.tx_dnld_rdy = false;\n\nexit:\n\tsdio_release_host(card->func);\n\tkfree(tmpbuf);\n\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_download_fw(struct btmrvl_sdio_card *card)\n{\n\tint ret;\n\tu8 fws0;\n\tint pollnum = MAX_POLL_TRIES;\n\n\tif (!card || !card->func) {\n\t\tBT_ERR(\"card or function is NULL!\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!btmrvl_sdio_verify_fw_download(card, 1)) {\n\t\tBT_DBG(\"Firmware already downloaded!\");\n\t\treturn 0;\n\t}\n\n\tsdio_claim_host(card->func);\n\n\t \n\tfws0 = sdio_readb(card->func, card->reg->card_fw_status0, &ret);\n\tif (ret) {\n\t\tBT_ERR(\"Failed to read FW downloading status!\");\n\t\tret = -EIO;\n\t\tgoto done;\n\t}\n\tif (fws0) {\n\t\tBT_DBG(\"BT not the winner (%#x). Skip FW downloading\", fws0);\n\n\t\t \n\t\tpollnum *= 10;\n\t} else {\n\t\tif (card->helper) {\n\t\t\tret = btmrvl_sdio_download_helper(card);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"Failed to download helper!\");\n\t\t\t\tret = -EIO;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (btmrvl_sdio_download_fw_w_helper(card)) {\n\t\t\tBT_ERR(\"Failed to download firmware!\");\n\t\t\tret = -EIO;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t \n\tif (btmrvl_sdio_verify_fw_download(card, pollnum)) {\n\t\tBT_ERR(\"FW failed to be active in time!\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto done;\n\t}\n\n\tsdio_release_host(card->func);\n\n\treturn 0;\n\ndone:\n\tsdio_release_host(card->func);\n\treturn ret;\n}\n\nstatic int btmrvl_sdio_wakeup_fw(struct btmrvl_private *priv)\n{\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret = 0;\n\n\tif (!card || !card->func) {\n\t\tBT_ERR(\"card or function is NULL!\");\n\t\treturn -EINVAL;\n\t}\n\n\tsdio_claim_host(card->func);\n\n\tsdio_writeb(card->func, HOST_POWER_UP, card->reg->cfg, &ret);\n\n\tsdio_release_host(card->func);\n\n\tBT_DBG(\"wake up firmware\");\n\n\treturn ret;\n}\n\nstatic void btmrvl_sdio_dump_regs(struct btmrvl_private *priv)\n{\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret = 0;\n\tunsigned int reg, reg_start, reg_end;\n\tchar buf[256], *ptr;\n\tu8 loop, func, data;\n\tint MAX_LOOP = 2;\n\n\tbtmrvl_sdio_wakeup_fw(priv);\n\tsdio_claim_host(card->func);\n\n\tfor (loop = 0; loop < MAX_LOOP; loop++) {\n\t\tmemset(buf, 0, sizeof(buf));\n\t\tptr = buf;\n\n\t\tif (loop == 0) {\n\t\t\t \n\t\t\tfunc = loop;\n\t\t\treg_start = 0;\n\t\t\treg_end = 9;\n\t\t} else {\n\t\t\tfunc = 2;\n\t\t\treg_start = 0;\n\t\t\treg_end = 0x09;\n\t\t}\n\n\t\tptr += sprintf(ptr, \"SDIO Func%d (%#x-%#x): \",\n\t\t\t       func, reg_start, reg_end);\n\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\tif (func == 0)\n\t\t\t\tdata = sdio_f0_readb(card->func, reg, &ret);\n\t\t\telse\n\t\t\t\tdata = sdio_readb(card->func, reg, &ret);\n\n\t\t\tif (!ret) {\n\t\t\t\tptr += sprintf(ptr, \"%02x \", data);\n\t\t\t} else {\n\t\t\t\tptr += sprintf(ptr, \"ERR\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tBT_INFO(\"%s\", buf);\n\t}\n\n\tsdio_release_host(card->func);\n}\n\n \nstatic enum\nrdwr_status btmrvl_sdio_rdwr_firmware(struct btmrvl_private *priv,\n\t\t\t\t      u8 doneflag)\n{\n\tstruct btmrvl_sdio_card *card = priv->btmrvl_dev.card;\n\tint ret, tries;\n\tu8 ctrl_data = 0;\n\n\tsdio_writeb(card->func, FW_DUMP_HOST_READY, card->reg->fw_dump_ctrl,\n\t\t    &ret);\n\n\tif (ret) {\n\t\tBT_ERR(\"SDIO write err\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\tfor (tries = 0; tries < MAX_POLL_TRIES; tries++) {\n\t\tctrl_data = sdio_readb(card->func, card->reg->fw_dump_ctrl,\n\t\t\t\t       &ret);\n\n\t\tif (ret) {\n\t\t\tBT_ERR(\"SDIO read err\");\n\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t}\n\n\t\tif (ctrl_data == FW_DUMP_DONE)\n\t\t\tbreak;\n\t\tif (doneflag && ctrl_data == doneflag)\n\t\t\treturn RDWR_STATUS_DONE;\n\t\tif (ctrl_data != FW_DUMP_HOST_READY) {\n\t\t\tBT_INFO(\"The ctrl reg was changed, re-try again!\");\n\t\t\tsdio_writeb(card->func, FW_DUMP_HOST_READY,\n\t\t\t\t    card->reg->fw_dump_ctrl, &ret);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"SDIO write err\");\n\t\t\t\treturn RDWR_STATUS_FAILURE;\n\t\t\t}\n\t\t}\n\t\tusleep_range(100, 200);\n\t}\n\n\tif (ctrl_data == FW_DUMP_HOST_READY) {\n\t\tBT_ERR(\"Fail to pull ctrl_data\");\n\t\treturn RDWR_STATUS_FAILURE;\n\t}\n\n\treturn RDWR_STATUS_SUCCESS;\n}\n\n \nstatic void btmrvl_sdio_coredump(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct btmrvl_sdio_card *card;\n\tstruct btmrvl_private *priv;\n\tint ret = 0;\n\tunsigned int reg, reg_start, reg_end;\n\tenum rdwr_status stat;\n\tu8 *dbg_ptr, *end_ptr, *fw_dump_data, *fw_dump_ptr;\n\tu8 dump_num = 0, idx, i, read_reg, doneflag = 0;\n\tu32 memory_size, fw_dump_len = 0;\n\tint size = 0;\n\n\tcard = sdio_get_drvdata(func);\n\tpriv = card->priv;\n\n\t \n\tbtmrvl_sdio_dump_regs(priv);\n\n\tif (!card->supports_fw_dump) {\n\t\tBT_ERR(\"Firmware dump not supported for this card!\");\n\t\treturn;\n\t}\n\n\tfor (idx = 0; idx < ARRAY_SIZE(mem_type_mapping_tbl); idx++) {\n\t\tstruct memory_type_mapping *entry = &mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tvfree(entry->mem_ptr);\n\t\t\tentry->mem_ptr = NULL;\n\t\t}\n\t\tentry->mem_size = 0;\n\t}\n\n\tbtmrvl_sdio_wakeup_fw(priv);\n\tsdio_claim_host(card->func);\n\n\tBT_INFO(\"== btmrvl firmware dump start ==\");\n\n\tstat = btmrvl_sdio_rdwr_firmware(priv, doneflag);\n\tif (stat == RDWR_STATUS_FAILURE)\n\t\tgoto done;\n\n\treg = card->reg->fw_dump_start;\n\t \n\tdump_num = sdio_readb(card->func, reg, &ret);\n\n\tif (ret) {\n\t\tBT_ERR(\"SDIO read memory length err\");\n\t\tgoto done;\n\t}\n\n\t \n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry = &mem_type_mapping_tbl[idx];\n\n\t\tstat = btmrvl_sdio_rdwr_firmware(priv, doneflag);\n\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\tgoto done;\n\n\t\tmemory_size = 0;\n\t\treg = card->reg->fw_dump_start;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tread_reg = sdio_readb(card->func, reg, &ret);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"SDIO read err\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tmemory_size |= (read_reg << i*8);\n\t\t\treg++;\n\t\t}\n\n\t\tif (memory_size == 0) {\n\t\t\tBT_INFO(\"Firmware dump finished!\");\n\t\t\tsdio_writeb(card->func, FW_DUMP_READ_DONE,\n\t\t\t\t    card->reg->fw_dump_ctrl, &ret);\n\t\t\tif (ret) {\n\t\t\t\tBT_ERR(\"SDIO Write MEMDUMP_FINISH ERR\");\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tBT_INFO(\"%s_SIZE=0x%x\", entry->mem_name, memory_size);\n\t\tentry->mem_ptr = vzalloc(memory_size + 1);\n\t\tentry->mem_size = memory_size;\n\t\tif (!entry->mem_ptr) {\n\t\t\tBT_ERR(\"Vzalloc %s failed\", entry->mem_name);\n\t\t\tgoto done;\n\t\t}\n\n\t\tfw_dump_len += (strlen(\"========Start dump \") +\n\t\t\t\tstrlen(entry->mem_name) +\n\t\t\t\tstrlen(\"========\\n\") +\n\t\t\t\t(memory_size + 1) +\n\t\t\t\tstrlen(\"\\n========End dump========\\n\"));\n\n\t\tdbg_ptr = entry->mem_ptr;\n\t\tend_ptr = dbg_ptr + memory_size;\n\n\t\tdoneflag = entry->done_flag;\n\t\tBT_INFO(\"Start %s output, please wait...\",\n\t\t\tentry->mem_name);\n\n\t\tdo {\n\t\t\tstat = btmrvl_sdio_rdwr_firmware(priv, doneflag);\n\t\t\tif (stat == RDWR_STATUS_FAILURE)\n\t\t\t\tgoto done;\n\n\t\t\treg_start = card->reg->fw_dump_start;\n\t\t\treg_end = card->reg->fw_dump_end;\n\t\t\tfor (reg = reg_start; reg <= reg_end; reg++) {\n\t\t\t\t*dbg_ptr = sdio_readb(card->func, reg, &ret);\n\t\t\t\tif (ret) {\n\t\t\t\t\tBT_ERR(\"SDIO read err\");\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t\tif (dbg_ptr < end_ptr)\n\t\t\t\t\tdbg_ptr++;\n\t\t\t\telse\n\t\t\t\t\tBT_ERR(\"Allocated buffer not enough\");\n\t\t\t}\n\n\t\t\tif (stat == RDWR_STATUS_DONE) {\n\t\t\t\tBT_INFO(\"%s done: size=0x%tx\",\n\t\t\t\t\tentry->mem_name,\n\t\t\t\t\tdbg_ptr - entry->mem_ptr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (1);\n\t}\n\n\tBT_INFO(\"== btmrvl firmware dump end ==\");\n\ndone:\n\tsdio_release_host(card->func);\n\n\tif (fw_dump_len == 0)\n\t\treturn;\n\n\tfw_dump_data = vzalloc(fw_dump_len + 1);\n\tif (!fw_dump_data) {\n\t\tBT_ERR(\"Vzalloc fw_dump_data fail!\");\n\t\treturn;\n\t}\n\tfw_dump_ptr = fw_dump_data;\n\n\t \n\tBT_INFO(\"== btmrvl firmware dump to /sys/class/devcoredump start\");\n\tfor (idx = 0; idx < dump_num; idx++) {\n\t\tstruct memory_type_mapping *entry = &mem_type_mapping_tbl[idx];\n\n\t\tif (entry->mem_ptr) {\n\t\t\tsize += scnprintf(fw_dump_ptr + size,\n\t\t\t\t\t  fw_dump_len + 1 - size,\n\t\t\t\t\t  \"========Start dump %s========\\n\",\n\t\t\t\t\t  entry->mem_name);\n\n\t\t\tmemcpy(fw_dump_ptr + size, entry->mem_ptr,\n\t\t\t       entry->mem_size);\n\t\t\tsize += entry->mem_size;\n\n\t\t\tsize += scnprintf(fw_dump_ptr + size,\n\t\t\t\t\t  fw_dump_len + 1 - size,\n\t\t\t\t\t  \"\\n========End dump========\\n\");\n\n\t\t\tvfree(mem_type_mapping_tbl[idx].mem_ptr);\n\t\t\tmem_type_mapping_tbl[idx].mem_ptr = NULL;\n\t\t}\n\t}\n\n\t \n\tdev_coredumpv(&card->func->dev, fw_dump_data, fw_dump_len, GFP_KERNEL);\n\tBT_INFO(\"== btmrvl firmware dump to /sys/class/devcoredump end\");\n}\n\nstatic int btmrvl_sdio_probe(struct sdio_func *func,\n\t\t\t\t\tconst struct sdio_device_id *id)\n{\n\tint ret = 0;\n\tstruct btmrvl_private *priv = NULL;\n\tstruct btmrvl_sdio_card *card = NULL;\n\n\tBT_INFO(\"vendor=0x%x, device=0x%x, class=%d, fn=%d\",\n\t\t\tid->vendor, id->device, id->class, func->num);\n\n\tcard = devm_kzalloc(&func->dev, sizeof(*card), GFP_KERNEL);\n\tif (!card)\n\t\treturn -ENOMEM;\n\n\tcard->func = func;\n\n\tif (id->driver_data) {\n\t\tstruct btmrvl_sdio_device *data = (void *) id->driver_data;\n\t\tcard->helper = data->helper;\n\t\tcard->firmware = data->firmware;\n\t\tcard->reg = data->reg;\n\t\tcard->sd_blksz_fw_dl = data->sd_blksz_fw_dl;\n\t\tcard->support_pscan_win_report = data->support_pscan_win_report;\n\t\tcard->supports_fw_dump = data->supports_fw_dump;\n\t}\n\n\tif (btmrvl_sdio_register_dev(card) < 0) {\n\t\tBT_ERR(\"Failed to register BT device!\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tbtmrvl_sdio_disable_host_int(card);\n\n\tif (btmrvl_sdio_download_fw(card)) {\n\t\tBT_ERR(\"Downloading firmware failed!\");\n\t\tret = -ENODEV;\n\t\tgoto unreg_dev;\n\t}\n\n\tbtmrvl_sdio_enable_host_int(card);\n\n\t \n\tbtmrvl_sdio_probe_of(&func->dev, card);\n\n\tpriv = btmrvl_add_card(card);\n\tif (!priv) {\n\t\tBT_ERR(\"Initializing card failed!\");\n\t\tret = -ENODEV;\n\t\tgoto disable_host_int;\n\t}\n\n\tcard->priv = priv;\n\n\t \n\tpriv->hw_host_to_card = btmrvl_sdio_host_to_card;\n\tpriv->hw_wakeup_firmware = btmrvl_sdio_wakeup_fw;\n\tpriv->hw_process_int_status = btmrvl_sdio_process_int_status;\n\n\tif (btmrvl_register_hdev(priv)) {\n\t\tBT_ERR(\"Register hdev failed!\");\n\t\tret = -ENODEV;\n\t\tgoto disable_host_int;\n\t}\n\n\treturn 0;\n\ndisable_host_int:\n\tbtmrvl_sdio_disable_host_int(card);\nunreg_dev:\n\tbtmrvl_sdio_unregister_dev(card);\n\treturn ret;\n}\n\nstatic void btmrvl_sdio_remove(struct sdio_func *func)\n{\n\tstruct btmrvl_sdio_card *card;\n\n\tif (func) {\n\t\tcard = sdio_get_drvdata(func);\n\t\tif (card) {\n\t\t\t \n\t\t\tif (user_rmmod) {\n\t\t\t\tbtmrvl_send_module_cfg_cmd(card->priv,\n\t\t\t\t\t\t\tMODULE_SHUTDOWN_REQ);\n\t\t\t\tbtmrvl_sdio_disable_host_int(card);\n\t\t\t}\n\n\t\t\tBT_DBG(\"unregister dev\");\n\t\t\tcard->priv->surprise_removed = true;\n\t\t\tbtmrvl_sdio_unregister_dev(card);\n\t\t\tbtmrvl_remove_card(card->priv);\n\t\t}\n\t}\n}\n\nstatic int btmrvl_sdio_suspend(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct btmrvl_sdio_card *card;\n\tstruct btmrvl_private *priv;\n\tmmc_pm_flag_t pm_flags;\n\tstruct hci_dev *hcidev;\n\n\tif (func) {\n\t\tpm_flags = sdio_get_host_pm_caps(func);\n\t\tBT_DBG(\"%s: suspend: PM flags = 0x%x\", sdio_func_id(func),\n\t\t       pm_flags);\n\t\tif (!(pm_flags & MMC_PM_KEEP_POWER)) {\n\t\t\tBT_ERR(\"%s: cannot remain alive while suspended\",\n\t\t\t       sdio_func_id(func));\n\t\t\treturn -ENOSYS;\n\t\t}\n\t\tcard = sdio_get_drvdata(func);\n\t\tif (!card || !card->priv) {\n\t\t\tBT_ERR(\"card or priv structure is not valid\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tBT_ERR(\"sdio_func is not specified\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (card->plt_wake_cfg && card->plt_wake_cfg->irq_bt >= 0 &&\n\t    device_may_wakeup(dev)) {\n\t\tcard->plt_wake_cfg->wake_by_bt = false;\n\t\tenable_irq(card->plt_wake_cfg->irq_bt);\n\t\tenable_irq_wake(card->plt_wake_cfg->irq_bt);\n\t}\n\n\tpriv = card->priv;\n\tpriv->adapter->is_suspending = true;\n\thcidev = priv->btmrvl_dev.hcidev;\n\tBT_DBG(\"%s: SDIO suspend\", hcidev->name);\n\thci_suspend_dev(hcidev);\n\n\tif (priv->adapter->hs_state != HS_ACTIVATED) {\n\t\tif (btmrvl_enable_hs(priv)) {\n\t\t\tBT_ERR(\"HS not activated, suspend failed!\");\n\t\t\t \n\t\t\tif (card->plt_wake_cfg &&\n\t\t\t    card->plt_wake_cfg->irq_bt >= 0 &&\n\t\t\t    device_may_wakeup(dev)) {\n\t\t\t\tdisable_irq_wake(card->plt_wake_cfg->irq_bt);\n\t\t\t\tdisable_irq(card->plt_wake_cfg->irq_bt);\n\t\t\t}\n\n\t\t\tpriv->adapter->is_suspending = false;\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tpriv->adapter->is_suspending = false;\n\tpriv->adapter->is_suspended = true;\n\n\t \n\tif (priv->adapter->hs_state == HS_ACTIVATED) {\n\t\tBT_DBG(\"suspend with MMC_PM_KEEP_POWER\");\n\t\treturn sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);\n\t}\n\n\tBT_DBG(\"suspend without MMC_PM_KEEP_POWER\");\n\treturn 0;\n}\n\nstatic int btmrvl_sdio_resume(struct device *dev)\n{\n\tstruct sdio_func *func = dev_to_sdio_func(dev);\n\tstruct btmrvl_sdio_card *card;\n\tstruct btmrvl_private *priv;\n\tmmc_pm_flag_t pm_flags;\n\tstruct hci_dev *hcidev;\n\n\tif (func) {\n\t\tpm_flags = sdio_get_host_pm_caps(func);\n\t\tBT_DBG(\"%s: resume: PM flags = 0x%x\", sdio_func_id(func),\n\t\t       pm_flags);\n\t\tcard = sdio_get_drvdata(func);\n\t\tif (!card || !card->priv) {\n\t\t\tBT_ERR(\"card or priv structure is not valid\");\n\t\t\treturn 0;\n\t\t}\n\t} else {\n\t\tBT_ERR(\"sdio_func is not specified\");\n\t\treturn 0;\n\t}\n\tpriv = card->priv;\n\n\tif (!priv->adapter->is_suspended) {\n\t\tBT_DBG(\"device already resumed\");\n\t\treturn 0;\n\t}\n\n\tpriv->hw_wakeup_firmware(priv);\n\tpriv->adapter->hs_state = HS_DEACTIVATED;\n\thcidev = priv->btmrvl_dev.hcidev;\n\tBT_DBG(\"%s: HS DEACTIVATED in resume!\", hcidev->name);\n\tpriv->adapter->is_suspended = false;\n\tBT_DBG(\"%s: SDIO resume\", hcidev->name);\n\thci_resume_dev(hcidev);\n\n\t \n\tif (card->plt_wake_cfg && card->plt_wake_cfg->irq_bt >= 0 &&\n\t    device_may_wakeup(dev)) {\n\t\tdisable_irq_wake(card->plt_wake_cfg->irq_bt);\n\t\tdisable_irq(card->plt_wake_cfg->irq_bt);\n\t\tif (card->plt_wake_cfg->wake_by_bt)\n\t\t\t \n\t\t\tenable_irq(card->plt_wake_cfg->irq_bt);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops btmrvl_sdio_pm_ops = {\n\t.suspend\t= btmrvl_sdio_suspend,\n\t.resume\t\t= btmrvl_sdio_resume,\n};\n\nstatic struct sdio_driver bt_mrvl_sdio = {\n\t.name\t\t= \"btmrvl_sdio\",\n\t.id_table\t= btmrvl_sdio_ids,\n\t.probe\t\t= btmrvl_sdio_probe,\n\t.remove\t\t= btmrvl_sdio_remove,\n\t.drv = {\n\t\t.owner = THIS_MODULE,\n\t\t.coredump = btmrvl_sdio_coredump,\n\t\t.pm = &btmrvl_sdio_pm_ops,\n\t}\n};\n\nstatic int __init btmrvl_sdio_init_module(void)\n{\n\tif (sdio_register_driver(&bt_mrvl_sdio) != 0) {\n\t\tBT_ERR(\"SDIO Driver Registration Failed\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tuser_rmmod = 0;\n\n\treturn 0;\n}\n\nstatic void __exit btmrvl_sdio_exit_module(void)\n{\n\t \n\tuser_rmmod = 1;\n\n\tsdio_unregister_driver(&bt_mrvl_sdio);\n}\n\nmodule_init(btmrvl_sdio_init_module);\nmodule_exit(btmrvl_sdio_exit_module);\n\nMODULE_AUTHOR(\"Marvell International Ltd.\");\nMODULE_DESCRIPTION(\"Marvell BT-over-SDIO driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL v2\");\nMODULE_FIRMWARE(\"mrvl/sd8688_helper.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8688.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8787_uapsta.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8797_uapsta.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8887_uapsta.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8897_uapsta.bin\");\nMODULE_FIRMWARE(\"mrvl/sdsd8977_combo_v2.bin\");\nMODULE_FIRMWARE(\"mrvl/sd8987_uapsta.bin\");\nMODULE_FIRMWARE(\"mrvl/sdsd8997_combo_v4.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}