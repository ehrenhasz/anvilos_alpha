{
  "module_name": "bpa10x.c",
  "hash_id": "e02f4a379a5fe69e3916d27320af248991d0f1a6d4318f8de226592f5d4dde16",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/bpa10x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n\n#include <linux/usb.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"h4_recv.h\"\n\n#define VERSION \"0.11\"\n\nstatic const struct usb_device_id bpa10x_table[] = {\n\t \n\t{ USB_DEVICE(0x08fd, 0x0002) },\n\n\t{ }\t \n};\n\nMODULE_DEVICE_TABLE(usb, bpa10x_table);\n\nstruct bpa10x_data {\n\tstruct hci_dev    *hdev;\n\tstruct usb_device *udev;\n\n\tstruct usb_anchor tx_anchor;\n\tstruct usb_anchor rx_anchor;\n\n\tstruct sk_buff *rx_skb[2];\n};\n\nstatic void bpa10x_tx_complete(struct urb *urb)\n{\n\tstruct sk_buff *skb = urb->context;\n\tstruct hci_dev *hdev = (struct hci_dev *) skb->dev;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name,\n\t\t\t\t\turb, urb->status, urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\tgoto done;\n\n\tif (!urb->status)\n\t\thdev->stat.byte_tx += urb->transfer_buffer_length;\n\telse\n\t\thdev->stat.err_tx++;\n\ndone:\n\tkfree(urb->setup_packet);\n\n\tkfree_skb(skb);\n}\n\n#define HCI_VENDOR_HDR_SIZE 5\n\n#define HCI_RECV_VENDOR \\\n\t.type = HCI_VENDOR_PKT, \\\n\t.hlen = HCI_VENDOR_HDR_SIZE, \\\n\t.loff = 3, \\\n\t.lsize = 2, \\\n\t.maxlen = HCI_MAX_FRAME_SIZE\n\nstatic const struct h4_recv_pkt bpa10x_recv_pkts[] = {\n\t{ H4_RECV_ACL,     .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,     .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,   .recv = hci_recv_frame },\n\t{ HCI_RECV_VENDOR, .recv = hci_recv_diag  },\n};\n\nstatic void bpa10x_rx_complete(struct urb *urb)\n{\n\tstruct hci_dev *hdev = urb->context;\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s urb %p status %d count %d\", hdev->name,\n\t\t\t\t\turb, urb->status, urb->actual_length);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn;\n\n\tif (urb->status == 0) {\n\t\tbool idx = usb_pipebulk(urb->pipe);\n\n\t\tdata->rx_skb[idx] = h4_recv_buf(hdev, data->rx_skb[idx],\n\t\t\t\t\t\turb->transfer_buffer,\n\t\t\t\t\t\turb->actual_length,\n\t\t\t\t\t\tbpa10x_recv_pkts,\n\t\t\t\t\t\tARRAY_SIZE(bpa10x_recv_pkts));\n\t\tif (IS_ERR(data->rx_skb[idx])) {\n\t\t\tbt_dev_err(hdev, \"corrupted event packet\");\n\t\t\thdev->stat.err_rx++;\n\t\t\tdata->rx_skb[idx] = NULL;\n\t\t}\n\t}\n\n\tusb_anchor_urb(urb, &data->rx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"urb %p failed to resubmit (%d)\", urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n}\n\nstatic inline int bpa10x_submit_intr_urb(struct hci_dev *hdev)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size = 16;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvintpipe(data->udev, 0x81);\n\n\tusb_fill_int_urb(urb, data->udev, pipe, buf, size,\n\t\t\t\t\t\tbpa10x_rx_complete, hdev, 1);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &data->rx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\", urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic inline int bpa10x_submit_bulk_urb(struct hci_dev *hdev)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\tstruct urb *urb;\n\tunsigned char *buf;\n\tunsigned int pipe;\n\tint err, size = 64;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tbuf = kmalloc(size, GFP_KERNEL);\n\tif (!buf) {\n\t\tusb_free_urb(urb);\n\t\treturn -ENOMEM;\n\t}\n\n\tpipe = usb_rcvbulkpipe(data->udev, 0x82);\n\n\tusb_fill_bulk_urb(urb, data->udev, pipe,\n\t\t\t\t\tbuf, size, bpa10x_rx_complete, hdev);\n\n\turb->transfer_flags |= URB_FREE_BUFFER;\n\n\tusb_anchor_urb(urb, &data->rx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"urb %p submission failed (%d)\", urb, -err);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic int bpa10x_open(struct hci_dev *hdev)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\terr = bpa10x_submit_intr_urb(hdev);\n\tif (err < 0)\n\t\tgoto error;\n\n\terr = bpa10x_submit_bulk_urb(hdev);\n\tif (err < 0)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tusb_kill_anchored_urbs(&data->rx_anchor);\n\n\treturn err;\n}\n\nstatic int bpa10x_close(struct hci_dev *hdev)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tusb_kill_anchored_urbs(&data->rx_anchor);\n\n\treturn 0;\n}\n\nstatic int bpa10x_flush(struct hci_dev *hdev)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tusb_kill_anchored_urbs(&data->tx_anchor);\n\n\treturn 0;\n}\n\nstatic int bpa10x_setup(struct hci_dev *hdev)\n{\n\tstatic const u8 req[] = { 0x07 };\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc0e, sizeof(req), req, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"%s\", (char *)(skb->data + 1));\n\n\thci_set_fw_info(hdev, \"%s\", skb->data + 1);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int bpa10x_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct bpa10x_data *data = hci_get_drvdata(hdev);\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tunsigned int pipe;\n\tint err;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tskb->dev = (void *) hdev;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\t \n\t*(u8 *)skb_push(skb, 1) = hci_skb_pkt_type(skb);\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\tdr = kmalloc(sizeof(*dr), GFP_KERNEL);\n\t\tif (!dr) {\n\t\t\tusb_free_urb(urb);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tdr->bRequestType = USB_TYPE_VENDOR;\n\t\tdr->bRequest     = 0;\n\t\tdr->wIndex       = 0;\n\t\tdr->wValue       = 0;\n\t\tdr->wLength      = __cpu_to_le16(skb->len);\n\n\t\tpipe = usb_sndctrlpipe(data->udev, 0x00);\n\n\t\tusb_fill_control_urb(urb, data->udev, pipe, (void *) dr,\n\t\t\t\tskb->data, skb->len, bpa10x_tx_complete, skb);\n\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\tpipe = usb_sndbulkpipe(data->udev, 0x02);\n\n\t\tusb_fill_bulk_urb(urb, data->udev, pipe,\n\t\t\t\tskb->data, skb->len, bpa10x_tx_complete, skb);\n\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\tpipe = usb_sndbulkpipe(data->udev, 0x02);\n\n\t\tusb_fill_bulk_urb(urb, data->udev, pipe,\n\t\t\t\tskb->data, skb->len, bpa10x_tx_complete, skb);\n\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\n\tdefault:\n\t\tusb_free_urb(urb);\n\t\treturn -EILSEQ;\n\t}\n\n\tusb_anchor_urb(urb, &data->tx_anchor);\n\n\terr = usb_submit_urb(urb, GFP_KERNEL);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"urb %p submission failed\", urb);\n\t\tkfree(urb->setup_packet);\n\t\tusb_unanchor_urb(urb);\n\t}\n\n\tusb_free_urb(urb);\n\n\treturn err;\n}\n\nstatic int bpa10x_set_diag(struct hci_dev *hdev, bool enable)\n{\n\tconst u8 req[] = { 0x00, enable };\n\tstruct sk_buff *skb;\n\n\tBT_DBG(\"%s\", hdev->name);\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc0e, sizeof(req), req, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int bpa10x_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct bpa10x_data *data;\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"intf %p id %p\", intf, id);\n\n\tif (intf->cur_altsetting->desc.bInterfaceNumber != 0)\n\t\treturn -ENODEV;\n\n\tdata = devm_kzalloc(&intf->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->udev = interface_to_usbdev(intf);\n\n\tinit_usb_anchor(&data->tx_anchor);\n\tinit_usb_anchor(&data->rx_anchor);\n\n\thdev = hci_alloc_dev();\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\n\thdev->bus = HCI_USB;\n\thci_set_drvdata(hdev, data);\n\n\tdata->hdev = hdev;\n\n\tSET_HCIDEV_DEV(hdev, &intf->dev);\n\n\thdev->open     = bpa10x_open;\n\thdev->close    = bpa10x_close;\n\thdev->flush    = bpa10x_flush;\n\thdev->setup    = bpa10x_setup;\n\thdev->send     = bpa10x_send_frame;\n\thdev->set_diag = bpa10x_set_diag;\n\n\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\terr = hci_register_dev(hdev);\n\tif (err < 0) {\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\tusb_set_intfdata(intf, data);\n\n\treturn 0;\n}\n\nstatic void bpa10x_disconnect(struct usb_interface *intf)\n{\n\tstruct bpa10x_data *data = usb_get_intfdata(intf);\n\n\tBT_DBG(\"intf %p\", intf);\n\n\tif (!data)\n\t\treturn;\n\n\tusb_set_intfdata(intf, NULL);\n\n\thci_unregister_dev(data->hdev);\n\n\thci_free_dev(data->hdev);\n\tkfree_skb(data->rx_skb[0]);\n\tkfree_skb(data->rx_skb[1]);\n}\n\nstatic struct usb_driver bpa10x_driver = {\n\t.name\t\t= \"bpa10x\",\n\t.probe\t\t= bpa10x_probe,\n\t.disconnect\t= bpa10x_disconnect,\n\t.id_table\t= bpa10x_table,\n\t.disable_hub_initiated_lpm = 1,\n};\n\nmodule_usb_driver(bpa10x_driver);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Digianswer Bluetooth USB driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}