{
  "module_name": "hci_h4.c",
  "hash_id": "2002ced3ecd8ae03db63b453c1bec735104c55d84e2e6fb6b48064908b5640ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_h4.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n\nstruct h4_struct {\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n};\n\n \nstatic int h4_open(struct hci_uart *hu)\n{\n\tstruct h4_struct *h4;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\th4 = kzalloc(sizeof(*h4), GFP_KERNEL);\n\tif (!h4)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&h4->txq);\n\n\thu->priv = h4;\n\treturn 0;\n}\n\n \nstatic int h4_flush(struct hci_uart *hu)\n{\n\tstruct h4_struct *h4 = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&h4->txq);\n\n\treturn 0;\n}\n\n \nstatic int h4_close(struct hci_uart *hu)\n{\n\tstruct h4_struct *h4 = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&h4->txq);\n\n\tkfree_skb(h4->rx_skb);\n\n\thu->priv = NULL;\n\tkfree(h4);\n\n\treturn 0;\n}\n\n \nstatic int h4_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct h4_struct *h4 = hu->priv;\n\n\tBT_DBG(\"hu %p skb %p\", hu, skb);\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\tskb_queue_tail(&h4->txq, skb);\n\n\treturn 0;\n}\n\nstatic const struct h4_recv_pkt h4_recv_pkts[] = {\n\t{ H4_RECV_ACL,   .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,   .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT, .recv = hci_recv_frame },\n\t{ H4_RECV_ISO,   .recv = hci_recv_frame },\n};\n\n \nstatic int h4_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct h4_struct *h4 = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\th4->rx_skb = h4_recv_buf(hu->hdev, h4->rx_skb, data, count,\n\t\t\t\t h4_recv_pkts, ARRAY_SIZE(h4_recv_pkts));\n\tif (IS_ERR(h4->rx_skb)) {\n\t\tint err = PTR_ERR(h4->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\th4->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *h4_dequeue(struct hci_uart *hu)\n{\n\tstruct h4_struct *h4 = hu->priv;\n\treturn skb_dequeue(&h4->txq);\n}\n\nstatic const struct hci_uart_proto h4p = {\n\t.id\t\t= HCI_UART_H4,\n\t.name\t\t= \"H4\",\n\t.open\t\t= h4_open,\n\t.close\t\t= h4_close,\n\t.recv\t\t= h4_recv,\n\t.enqueue\t= h4_enqueue,\n\t.dequeue\t= h4_dequeue,\n\t.flush\t\t= h4_flush,\n};\n\nint __init h4_init(void)\n{\n\treturn hci_uart_register_proto(&h4p);\n}\n\nint __exit h4_deinit(void)\n{\n\treturn hci_uart_unregister_proto(&h4p);\n}\n\nstruct sk_buff *h4_recv_buf(struct hci_dev *hdev, struct sk_buff *skb,\n\t\t\t    const unsigned char *buffer, int count,\n\t\t\t    const struct h4_recv_pkt *pkts, int pkts_count)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tu8 alignment = hu->alignment ? hu->alignment : 1;\n\n\t \n\tif (IS_ERR(skb))\n\t\tskb = NULL;\n\n\twhile (count) {\n\t\tint i, len;\n\n\t\t \n\t\tfor (; hu->padding && count > 0; hu->padding--) {\n\t\t\tcount--;\n\t\t\tbuffer++;\n\t\t}\n\t\tif (!count)\n\t\t\tbreak;\n\n\t\tif (!skb) {\n\t\t\tfor (i = 0; i < pkts_count; i++) {\n\t\t\t\tif (buffer[0] != (&pkts[i])->type)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tskb = bt_skb_alloc((&pkts[i])->maxlen,\n\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (!skb)\n\t\t\t\t\treturn ERR_PTR(-ENOMEM);\n\n\t\t\t\thci_skb_pkt_type(skb) = (&pkts[i])->type;\n\t\t\t\thci_skb_expect(skb) = (&pkts[i])->hlen;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (!skb)\n\t\t\t\treturn ERR_PTR(-EILSEQ);\n\n\t\t\tcount -= 1;\n\t\t\tbuffer += 1;\n\t\t}\n\n\t\tlen = min_t(uint, hci_skb_expect(skb) - skb->len, count);\n\t\tskb_put_data(skb, buffer, len);\n\n\t\tcount -= len;\n\t\tbuffer += len;\n\n\t\t \n\t\tif (skb->len < hci_skb_expect(skb))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < pkts_count; i++) {\n\t\t\tif (hci_skb_pkt_type(skb) == (&pkts[i])->type)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i >= pkts_count) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn ERR_PTR(-EILSEQ);\n\t\t}\n\n\t\tif (skb->len == (&pkts[i])->hlen) {\n\t\t\tu16 dlen;\n\n\t\t\tswitch ((&pkts[i])->lsize) {\n\t\t\tcase 0:\n\t\t\t\t \n\t\t\t\tdlen = 0;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t \n\t\t\t\tdlen = skb->data[(&pkts[i])->loff];\n\t\t\t\thci_skb_expect(skb) += dlen;\n\n\t\t\t\tif (skb_tailroom(skb) < dlen) {\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t \n\t\t\t\tdlen = get_unaligned_le16(skb->data +\n\t\t\t\t\t\t\t  (&pkts[i])->loff);\n\t\t\t\thci_skb_expect(skb) += dlen;\n\n\t\t\t\tif (skb_tailroom(skb) < dlen) {\n\t\t\t\t\tkfree_skb(skb);\n\t\t\t\t\treturn ERR_PTR(-EMSGSIZE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn ERR_PTR(-EILSEQ);\n\t\t\t}\n\n\t\t\tif (!dlen) {\n\t\t\t\thu->padding = (skb->len + 1) % alignment;\n\t\t\t\thu->padding = (alignment - hu->padding) % alignment;\n\n\t\t\t\t \n\t\t\t\t(&pkts[i])->recv(hdev, skb);\n\t\t\t\tskb = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\thu->padding = (skb->len + 1) % alignment;\n\t\t\thu->padding = (alignment - hu->padding) % alignment;\n\n\t\t\t \n\t\t\t(&pkts[i])->recv(hdev, skb);\n\t\t\tskb = NULL;\n\t\t}\n\t}\n\n\treturn skb;\n}\nEXPORT_SYMBOL_GPL(h4_recv_buf);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}