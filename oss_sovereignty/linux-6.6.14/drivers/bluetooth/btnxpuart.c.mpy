{
  "module_name": "btnxpuart.c",
  "hash_id": "ee91843550f130f15eeddf7e374ef7add5eab5b312c909d9acc724e98ae98daa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btnxpuart.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <linux/serdev.h>\n#include <linux/of.h>\n#include <linux/skbuff.h>\n#include <asm/unaligned.h>\n#include <linux/firmware.h>\n#include <linux/string.h>\n#include <linux/crc8.h>\n#include <linux/crc32.h>\n#include <linux/string_helpers.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"h4_recv.h\"\n\n#define MANUFACTURER_NXP\t\t37\n\n#define BTNXPUART_TX_STATE_ACTIVE\t1\n#define BTNXPUART_FW_DOWNLOADING\t2\n#define BTNXPUART_CHECK_BOOT_SIGNATURE\t3\n#define BTNXPUART_SERDEV_OPEN\t\t4\n#define BTNXPUART_IR_IN_PROGRESS\t5\n\n \n#define BTNXPUART_IR_HW_ERR\t\t0xb0\n\n#define FIRMWARE_W8987\t\t\"nxp/uartuart8987_bt.bin\"\n#define FIRMWARE_W8997\t\t\"nxp/uartuart8997_bt_v4.bin\"\n#define FIRMWARE_W9098\t\t\"nxp/uartuart9098_bt_v1.bin\"\n#define FIRMWARE_IW416\t\t\"nxp/uartiw416_bt_v0.bin\"\n#define FIRMWARE_IW612\t\t\"nxp/uartspi_n61x_v1.bin.se\"\n#define FIRMWARE_IW624\t\t\"nxp/uartiw624_bt.bin\"\n#define FIRMWARE_SECURE_IW624\t\"nxp/uartiw624_bt.bin.se\"\n#define FIRMWARE_AW693\t\t\"nxp/uartaw693_bt.bin\"\n#define FIRMWARE_SECURE_AW693\t\"nxp/uartaw693_bt.bin.se\"\n#define FIRMWARE_HELPER\t\t\"nxp/helper_uart_3000000.bin\"\n\n#define CHIP_ID_W9098\t\t0x5c03\n#define CHIP_ID_IW416\t\t0x7201\n#define CHIP_ID_IW612\t\t0x7601\n#define CHIP_ID_IW624a\t\t0x8000\n#define CHIP_ID_IW624c\t\t0x8001\n#define CHIP_ID_AW693\t\t0x8200\n\n#define FW_SECURE_MASK\t\t0xc0\n#define FW_OPEN\t\t\t0x00\n#define FW_AUTH_ILLEGAL\t\t0x40\n#define FW_AUTH_PLAIN\t\t0x80\n#define FW_AUTH_ENC\t\t0xc0\n\n#define HCI_NXP_PRI_BAUDRATE\t115200\n#define HCI_NXP_SEC_BAUDRATE\t3000000\n\n#define MAX_FW_FILE_NAME_LEN    50\n\n \n#define PS_DEFAULT_TIMEOUT_PERIOD_MS     2000\n\n \n#define WAKEUP_METHOD_DTR       0\n#define WAKEUP_METHOD_BREAK     1\n#define WAKEUP_METHOD_EXT_BREAK 2\n#define WAKEUP_METHOD_RTS       3\n#define WAKEUP_METHOD_INVALID   0xff\n\n \n#define PS_MODE_DISABLE         0\n#define PS_MODE_ENABLE          1\n\n \n#define PS_CMD_EXIT_PS          1\n#define PS_CMD_ENTER_PS         2\n\n \n#define PS_STATE_AWAKE          0\n#define PS_STATE_SLEEP          1\n\n \n#define HCI_NXP_AUTO_SLEEP_MODE\t0xfc23\n \n#define HCI_NXP_WAKEUP_METHOD\t0xfc53\n \n#define HCI_NXP_SET_OPER_SPEED\t0xfc09\n \n#define HCI_NXP_IND_RESET\t0xfcfc\n\n \n#define BT_PS_ENABLE\t\t\t0x02\n#define BT_PS_DISABLE\t\t\t0x03\n\n \n#define BT_HOST_WAKEUP_METHOD_NONE      0x00\n#define BT_HOST_WAKEUP_METHOD_DTR       0x01\n#define BT_HOST_WAKEUP_METHOD_BREAK     0x02\n#define BT_HOST_WAKEUP_METHOD_GPIO      0x03\n\n \n#define BT_CTRL_WAKEUP_METHOD_DSR       0x00\n#define BT_CTRL_WAKEUP_METHOD_BREAK     0x01\n#define BT_CTRL_WAKEUP_METHOD_GPIO      0x02\n#define BT_CTRL_WAKEUP_METHOD_EXT_BREAK 0x04\n#define BT_CTRL_WAKEUP_METHOD_RTS       0x05\n\nstruct ps_data {\n\tu8    target_ps_mode;\t \n\tu8    cur_psmode;\t \n\tu8    ps_state;\t\t \n\tu8    ps_cmd;\n\tu8    h2c_wakeupmode;\n\tu8    cur_h2c_wakeupmode;\n\tu8    c2h_wakeupmode;\n\tu8    c2h_wakeup_gpio;\n\tu8    h2c_wakeup_gpio;\n\tbool  driver_sent_cmd;\n\tu16   h2c_ps_interval;\n\tu16   c2h_ps_interval;\n\tstruct hci_dev *hdev;\n\tstruct work_struct work;\n\tstruct timer_list ps_timer;\n};\n\nstruct wakeup_cmd_payload {\n\tu8 c2h_wakeupmode;\n\tu8 c2h_wakeup_gpio;\n\tu8 h2c_wakeupmode;\n\tu8 h2c_wakeup_gpio;\n} __packed;\n\nstruct psmode_cmd_payload {\n\tu8 ps_cmd;\n\t__le16 c2h_ps_interval;\n} __packed;\n\nstruct btnxpuart_data {\n\tconst char *helper_fw_name;\n\tconst char *fw_name;\n};\n\nstruct btnxpuart_dev {\n\tstruct hci_dev *hdev;\n\tstruct serdev_device *serdev;\n\n\tstruct work_struct tx_work;\n\tunsigned long tx_state;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff *rx_skb;\n\n\tconst struct firmware *fw;\n\tu8 fw_name[MAX_FW_FILE_NAME_LEN];\n\tu32 fw_dnld_v1_offset;\n\tu32 fw_v1_sent_bytes;\n\tu32 fw_v3_offset_correction;\n\tu32 fw_v1_expected_len;\n\tu32 boot_reg_offset;\n\twait_queue_head_t fw_dnld_done_wait_q;\n\twait_queue_head_t check_boot_sign_wait_q;\n\n\tu32 new_baudrate;\n\tu32 current_baudrate;\n\tu32 fw_init_baudrate;\n\tbool timeout_changed;\n\tbool baudrate_changed;\n\tbool helper_downloaded;\n\n\tstruct ps_data psdata;\n\tstruct btnxpuart_data *nxp_data;\n};\n\n#define NXP_V1_FW_REQ_PKT\t0xa5\n#define NXP_V1_CHIP_VER_PKT\t0xaa\n#define NXP_V3_FW_REQ_PKT\t0xa7\n#define NXP_V3_CHIP_VER_PKT\t0xab\n\n#define NXP_ACK_V1\t\t0x5a\n#define NXP_NAK_V1\t\t0xbf\n#define NXP_ACK_V3\t\t0x7a\n#define NXP_NAK_V3\t\t0x7b\n#define NXP_CRC_ERROR_V3\t0x7c\n\n#define HDR_LEN\t\t\t16\n\n#define NXP_RECV_CHIP_VER_V1 \\\n\t.type = NXP_V1_CHIP_VER_PKT, \\\n\t.hlen = 4, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 4\n\n#define NXP_RECV_FW_REQ_V1 \\\n\t.type = NXP_V1_FW_REQ_PKT, \\\n\t.hlen = 4, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 4\n\n#define NXP_RECV_CHIP_VER_V3 \\\n\t.type = NXP_V3_CHIP_VER_PKT, \\\n\t.hlen = 4, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 4\n\n#define NXP_RECV_FW_REQ_V3 \\\n\t.type = NXP_V3_FW_REQ_PKT, \\\n\t.hlen = 9, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 9\n\nstruct v1_data_req {\n\t__le16 len;\n\t__le16 len_comp;\n} __packed;\n\nstruct v1_start_ind {\n\t__le16 chip_id;\n\t__le16 chip_id_comp;\n} __packed;\n\nstruct v3_data_req {\n\t__le16 len;\n\t__le32 offset;\n\t__le16 error;\n\tu8 crc;\n} __packed;\n\nstruct v3_start_ind {\n\t__le16 chip_id;\n\tu8 loader_ver;\n\tu8 crc;\n} __packed;\n\n \n#define CLKDIVADDR\t0x7f00008f\n#define UARTDIVADDR\t0x7f000090\n#define UARTMCRADDR\t0x7f000091\n#define UARTREINITADDR\t0x7f000092\n#define UARTICRADDR\t0x7f000093\n#define UARTFCRADDR\t0x7f000094\n\n#define MCR\t\t0x00000022\n#define INIT\t\t0x00000001\n#define ICR\t\t0x000000c7\n#define FCR\t\t0x000000c7\n\n#define POLYNOMIAL8\t0x07\n\nstruct uart_reg {\n\t__le32 address;\n\t__le32 value;\n} __packed;\n\nstruct uart_config {\n\tstruct uart_reg clkdiv;\n\tstruct uart_reg uartdiv;\n\tstruct uart_reg mcr;\n\tstruct uart_reg re_init;\n\tstruct uart_reg icr;\n\tstruct uart_reg fcr;\n\t__be32 crc;\n} __packed;\n\nstruct nxp_bootloader_cmd {\n\t__le32 header;\n\t__le32 arg;\n\t__le32 payload_len;\n\t__be32 crc;\n} __packed;\n\nstatic u8 crc8_table[CRC8_TABLE_SIZE];\n\n \n#define DEFAULT_H2C_WAKEUP_MODE\tWAKEUP_METHOD_BREAK\n#define DEFAULT_PS_MODE\t\tPS_MODE_DISABLE\n#define FW_INIT_BAUDRATE\tHCI_NXP_PRI_BAUDRATE\n\nstatic struct sk_buff *nxp_drv_send_cmd(struct hci_dev *hdev, u16 opcode,\n\t\t\t\t\tu32 plen,\n\t\t\t\t\tvoid *param)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tstruct sk_buff *skb;\n\n\t \n\tpsdata->driver_sent_cmd = true;\n\tskb = __hci_cmd_sync(hdev, opcode, plen, param, HCI_CMD_TIMEOUT);\n\tpsdata->driver_sent_cmd = false;\n\n\treturn skb;\n}\n\nstatic void btnxpuart_tx_wakeup(struct btnxpuart_dev *nxpdev)\n{\n\tif (schedule_work(&nxpdev->tx_work))\n\t\tset_bit(BTNXPUART_TX_STATE_ACTIVE, &nxpdev->tx_state);\n}\n\n \nstatic void ps_start_timer(struct btnxpuart_dev *nxpdev)\n{\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\n\tif (!psdata)\n\t\treturn;\n\n\tif (psdata->cur_psmode == PS_MODE_ENABLE)\n\t\tmod_timer(&psdata->ps_timer, jiffies + msecs_to_jiffies(psdata->h2c_ps_interval));\n}\n\nstatic void ps_cancel_timer(struct btnxpuart_dev *nxpdev)\n{\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\n\tflush_work(&psdata->work);\n\tdel_timer_sync(&psdata->ps_timer);\n}\n\nstatic void ps_control(struct hci_dev *hdev, u8 ps_state)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tint status;\n\n\tif (psdata->ps_state == ps_state ||\n\t    !test_bit(BTNXPUART_SERDEV_OPEN, &nxpdev->tx_state))\n\t\treturn;\n\n\tswitch (psdata->cur_h2c_wakeupmode) {\n\tcase WAKEUP_METHOD_DTR:\n\t\tif (ps_state == PS_STATE_AWAKE)\n\t\t\tstatus = serdev_device_set_tiocm(nxpdev->serdev, TIOCM_DTR, 0);\n\t\telse\n\t\t\tstatus = serdev_device_set_tiocm(nxpdev->serdev, 0, TIOCM_DTR);\n\t\tbreak;\n\tcase WAKEUP_METHOD_BREAK:\n\tdefault:\n\t\tif (ps_state == PS_STATE_AWAKE)\n\t\t\tstatus = serdev_device_break_ctl(nxpdev->serdev, 0);\n\t\telse\n\t\t\tstatus = serdev_device_break_ctl(nxpdev->serdev, -1);\n\t\tbt_dev_dbg(hdev, \"Set UART break: %s, status=%d\",\n\t\t\t   str_on_off(ps_state == PS_STATE_SLEEP), status);\n\t\tbreak;\n\t}\n\tif (!status)\n\t\tpsdata->ps_state = ps_state;\n\tif (ps_state == PS_STATE_AWAKE)\n\t\tbtnxpuart_tx_wakeup(nxpdev);\n}\n\nstatic void ps_work_func(struct work_struct *work)\n{\n\tstruct ps_data *data = container_of(work, struct ps_data, work);\n\n\tif (data->ps_cmd == PS_CMD_ENTER_PS && data->cur_psmode == PS_MODE_ENABLE)\n\t\tps_control(data->hdev, PS_STATE_SLEEP);\n\telse if (data->ps_cmd == PS_CMD_EXIT_PS)\n\t\tps_control(data->hdev, PS_STATE_AWAKE);\n}\n\nstatic void ps_timeout_func(struct timer_list *t)\n{\n\tstruct ps_data *data = from_timer(data, t, ps_timer);\n\tstruct hci_dev *hdev = data->hdev;\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\tif (test_bit(BTNXPUART_TX_STATE_ACTIVE, &nxpdev->tx_state)) {\n\t\tps_start_timer(nxpdev);\n\t} else {\n\t\tdata->ps_cmd = PS_CMD_ENTER_PS;\n\t\tschedule_work(&data->work);\n\t}\n}\n\nstatic void ps_setup(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\n\tpsdata->hdev = hdev;\n\tINIT_WORK(&psdata->work, ps_work_func);\n\ttimer_setup(&psdata->ps_timer, ps_timeout_func, 0);\n}\n\nstatic void ps_wakeup(struct btnxpuart_dev *nxpdev)\n{\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\n\tif (psdata->ps_state != PS_STATE_AWAKE) {\n\t\tpsdata->ps_cmd = PS_CMD_EXIT_PS;\n\t\tschedule_work(&psdata->work);\n\t}\n}\n\nstatic int send_ps_cmd(struct hci_dev *hdev, void *data)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tstruct psmode_cmd_payload pcmd;\n\tstruct sk_buff *skb;\n\tu8 *status;\n\n\tif (psdata->target_ps_mode == PS_MODE_ENABLE)\n\t\tpcmd.ps_cmd = BT_PS_ENABLE;\n\telse\n\t\tpcmd.ps_cmd = BT_PS_DISABLE;\n\tpcmd.c2h_ps_interval = __cpu_to_le16(psdata->c2h_ps_interval);\n\n\tskb = nxp_drv_send_cmd(hdev, HCI_NXP_AUTO_SLEEP_MODE, sizeof(pcmd), &pcmd);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting Power Save mode failed (%ld)\", PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tstatus = skb_pull_data(skb, 1);\n\tif (status) {\n\t\tif (!*status)\n\t\t\tpsdata->cur_psmode = psdata->target_ps_mode;\n\t\telse\n\t\t\tpsdata->target_ps_mode = psdata->cur_psmode;\n\t\tif (psdata->cur_psmode == PS_MODE_ENABLE)\n\t\t\tps_start_timer(nxpdev);\n\t\telse\n\t\t\tps_wakeup(nxpdev);\n\t\tbt_dev_dbg(hdev, \"Power Save mode response: status=%d, ps_mode=%d\",\n\t\t\t   *status, psdata->cur_psmode);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int send_wakeup_method_cmd(struct hci_dev *hdev, void *data)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tstruct wakeup_cmd_payload pcmd;\n\tstruct sk_buff *skb;\n\tu8 *status;\n\n\tpcmd.c2h_wakeupmode = psdata->c2h_wakeupmode;\n\tpcmd.c2h_wakeup_gpio = psdata->c2h_wakeup_gpio;\n\tswitch (psdata->h2c_wakeupmode) {\n\tcase WAKEUP_METHOD_DTR:\n\t\tpcmd.h2c_wakeupmode = BT_CTRL_WAKEUP_METHOD_DSR;\n\t\tbreak;\n\tcase WAKEUP_METHOD_BREAK:\n\tdefault:\n\t\tpcmd.h2c_wakeupmode = BT_CTRL_WAKEUP_METHOD_BREAK;\n\t\tbreak;\n\t}\n\tpcmd.h2c_wakeup_gpio = 0xff;\n\n\tskb = nxp_drv_send_cmd(hdev, HCI_NXP_WAKEUP_METHOD, sizeof(pcmd), &pcmd);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting wake-up method failed (%ld)\", PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tstatus = skb_pull_data(skb, 1);\n\tif (status) {\n\t\tif (*status == 0)\n\t\t\tpsdata->cur_h2c_wakeupmode = psdata->h2c_wakeupmode;\n\t\telse\n\t\t\tpsdata->h2c_wakeupmode = psdata->cur_h2c_wakeupmode;\n\t\tbt_dev_dbg(hdev, \"Set Wakeup Method response: status=%d, h2c_wakeupmode=%d\",\n\t\t\t   *status, psdata->cur_h2c_wakeupmode);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic void ps_init(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\n\tserdev_device_set_tiocm(nxpdev->serdev, 0, TIOCM_RTS);\n\tusleep_range(5000, 10000);\n\tserdev_device_set_tiocm(nxpdev->serdev, TIOCM_RTS, 0);\n\tusleep_range(5000, 10000);\n\n\tpsdata->ps_state = PS_STATE_AWAKE;\n\tpsdata->c2h_wakeupmode = BT_HOST_WAKEUP_METHOD_NONE;\n\tpsdata->c2h_wakeup_gpio = 0xff;\n\n\tpsdata->cur_h2c_wakeupmode = WAKEUP_METHOD_INVALID;\n\tpsdata->h2c_ps_interval = PS_DEFAULT_TIMEOUT_PERIOD_MS;\n\tswitch (DEFAULT_H2C_WAKEUP_MODE) {\n\tcase WAKEUP_METHOD_DTR:\n\t\tpsdata->h2c_wakeupmode = WAKEUP_METHOD_DTR;\n\t\tserdev_device_set_tiocm(nxpdev->serdev, 0, TIOCM_DTR);\n\t\tserdev_device_set_tiocm(nxpdev->serdev, TIOCM_DTR, 0);\n\t\tbreak;\n\tcase WAKEUP_METHOD_BREAK:\n\tdefault:\n\t\tpsdata->h2c_wakeupmode = WAKEUP_METHOD_BREAK;\n\t\tserdev_device_break_ctl(nxpdev->serdev, -1);\n\t\tusleep_range(5000, 10000);\n\t\tserdev_device_break_ctl(nxpdev->serdev, 0);\n\t\tusleep_range(5000, 10000);\n\t\tbreak;\n\t}\n\n\tpsdata->cur_psmode = PS_MODE_DISABLE;\n\tpsdata->target_ps_mode = DEFAULT_PS_MODE;\n\n\tif (psdata->cur_h2c_wakeupmode != psdata->h2c_wakeupmode)\n\t\thci_cmd_sync_queue(hdev, send_wakeup_method_cmd, NULL, NULL);\n\tif (psdata->cur_psmode != psdata->target_ps_mode)\n\t\thci_cmd_sync_queue(hdev, send_ps_cmd, NULL, NULL);\n}\n\n \nstatic int nxp_download_firmware(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tint err = 0;\n\n\tnxpdev->fw_dnld_v1_offset = 0;\n\tnxpdev->fw_v1_sent_bytes = 0;\n\tnxpdev->fw_v1_expected_len = HDR_LEN;\n\tnxpdev->boot_reg_offset = 0;\n\tnxpdev->fw_v3_offset_correction = 0;\n\tnxpdev->baudrate_changed = false;\n\tnxpdev->timeout_changed = false;\n\tnxpdev->helper_downloaded = false;\n\n\tserdev_device_set_baudrate(nxpdev->serdev, HCI_NXP_PRI_BAUDRATE);\n\tserdev_device_set_flow_control(nxpdev->serdev, false);\n\tnxpdev->current_baudrate = HCI_NXP_PRI_BAUDRATE;\n\n\t \n\terr = wait_event_interruptible_timeout(nxpdev->fw_dnld_done_wait_q,\n\t\t\t\t\t       !test_bit(BTNXPUART_FW_DOWNLOADING,\n\t\t\t\t\t\t\t &nxpdev->tx_state),\n\t\t\t\t\t       msecs_to_jiffies(60000));\n\tif (err == 0) {\n\t\tbt_dev_err(hdev, \"FW Download Timeout.\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\tserdev_device_set_flow_control(nxpdev->serdev, true);\n\trelease_firmware(nxpdev->fw);\n\tmemset(nxpdev->fw_name, 0, sizeof(nxpdev->fw_name));\n\n\t \n\tmsleep(1200);\n\n\treturn 0;\n}\n\nstatic void nxp_send_ack(u8 ack, struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tu8 ack_nak[2];\n\tint len = 1;\n\n\tack_nak[0] = ack;\n\tif (ack == NXP_ACK_V3) {\n\t\tack_nak[1] = crc8(crc8_table, ack_nak, 1, 0xff);\n\t\tlen = 2;\n\t}\n\tserdev_device_write_buf(nxpdev->serdev, ack_nak, len);\n}\n\nstatic bool nxp_fw_change_baudrate(struct hci_dev *hdev, u16 req_len)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct nxp_bootloader_cmd nxp_cmd5;\n\tstruct uart_config uart_config;\n\tu32 clkdivaddr = CLKDIVADDR - nxpdev->boot_reg_offset;\n\tu32 uartdivaddr = UARTDIVADDR - nxpdev->boot_reg_offset;\n\tu32 uartmcraddr = UARTMCRADDR - nxpdev->boot_reg_offset;\n\tu32 uartreinitaddr = UARTREINITADDR - nxpdev->boot_reg_offset;\n\tu32 uarticraddr = UARTICRADDR - nxpdev->boot_reg_offset;\n\tu32 uartfcraddr = UARTFCRADDR - nxpdev->boot_reg_offset;\n\n\tif (req_len == sizeof(nxp_cmd5)) {\n\t\tnxp_cmd5.header = __cpu_to_le32(5);\n\t\tnxp_cmd5.arg = 0;\n\t\tnxp_cmd5.payload_len = __cpu_to_le32(sizeof(uart_config));\n\t\t \n\t\tnxp_cmd5.crc = __cpu_to_be32(crc32_be(0UL, (char *)&nxp_cmd5,\n\t\t\t\t\t\t      sizeof(nxp_cmd5) - 4));\n\n\t\tserdev_device_write_buf(nxpdev->serdev, (u8 *)&nxp_cmd5, sizeof(nxp_cmd5));\n\t\tnxpdev->fw_v3_offset_correction += req_len;\n\t} else if (req_len == sizeof(uart_config)) {\n\t\tuart_config.clkdiv.address = __cpu_to_le32(clkdivaddr);\n\t\tuart_config.clkdiv.value = __cpu_to_le32(0x00c00000);\n\t\tuart_config.uartdiv.address = __cpu_to_le32(uartdivaddr);\n\t\tuart_config.uartdiv.value = __cpu_to_le32(1);\n\t\tuart_config.mcr.address = __cpu_to_le32(uartmcraddr);\n\t\tuart_config.mcr.value = __cpu_to_le32(MCR);\n\t\tuart_config.re_init.address = __cpu_to_le32(uartreinitaddr);\n\t\tuart_config.re_init.value = __cpu_to_le32(INIT);\n\t\tuart_config.icr.address = __cpu_to_le32(uarticraddr);\n\t\tuart_config.icr.value = __cpu_to_le32(ICR);\n\t\tuart_config.fcr.address = __cpu_to_le32(uartfcraddr);\n\t\tuart_config.fcr.value = __cpu_to_le32(FCR);\n\t\t \n\t\tuart_config.crc = __cpu_to_be32(crc32_be(0UL, (char *)&uart_config,\n\t\t\t\t\t\t\t sizeof(uart_config) - 4));\n\n\t\tserdev_device_write_buf(nxpdev->serdev, (u8 *)&uart_config, sizeof(uart_config));\n\t\tserdev_device_wait_until_sent(nxpdev->serdev, 0);\n\t\tnxpdev->fw_v3_offset_correction += req_len;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic bool nxp_fw_change_timeout(struct hci_dev *hdev, u16 req_len)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct nxp_bootloader_cmd nxp_cmd7;\n\n\tif (req_len != sizeof(nxp_cmd7))\n\t\treturn false;\n\n\tnxp_cmd7.header = __cpu_to_le32(7);\n\tnxp_cmd7.arg = __cpu_to_le32(0x70);\n\tnxp_cmd7.payload_len = 0;\n\t \n\tnxp_cmd7.crc = __cpu_to_be32(crc32_be(0UL, (char *)&nxp_cmd7,\n\t\t\t\t\t      sizeof(nxp_cmd7) - 4));\n\tserdev_device_write_buf(nxpdev->serdev, (u8 *)&nxp_cmd7, sizeof(nxp_cmd7));\n\tserdev_device_wait_until_sent(nxpdev->serdev, 0);\n\tnxpdev->fw_v3_offset_correction += req_len;\n\treturn true;\n}\n\nstatic u32 nxp_get_data_len(const u8 *buf)\n{\n\tstruct nxp_bootloader_cmd *hdr = (struct nxp_bootloader_cmd *)buf;\n\n\treturn __le32_to_cpu(hdr->payload_len);\n}\n\nstatic bool is_fw_downloading(struct btnxpuart_dev *nxpdev)\n{\n\treturn test_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n}\n\nstatic bool process_boot_signature(struct btnxpuart_dev *nxpdev)\n{\n\tif (test_bit(BTNXPUART_CHECK_BOOT_SIGNATURE, &nxpdev->tx_state)) {\n\t\tclear_bit(BTNXPUART_CHECK_BOOT_SIGNATURE, &nxpdev->tx_state);\n\t\twake_up_interruptible(&nxpdev->check_boot_sign_wait_q);\n\t\treturn false;\n\t}\n\treturn is_fw_downloading(nxpdev);\n}\n\nstatic int nxp_request_firmware(struct hci_dev *hdev, const char *fw_name)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tint err = 0;\n\n\tif (!fw_name)\n\t\treturn -ENOENT;\n\n\tif (!strlen(nxpdev->fw_name)) {\n\t\tsnprintf(nxpdev->fw_name, MAX_FW_FILE_NAME_LEN, \"%s\", fw_name);\n\n\t\tbt_dev_dbg(hdev, \"Request Firmware: %s\", nxpdev->fw_name);\n\t\terr = request_firmware(&nxpdev->fw, nxpdev->fw_name, &hdev->dev);\n\t\tif (err < 0) {\n\t\t\tbt_dev_err(hdev, \"Firmware file %s not found\", nxpdev->fw_name);\n\t\t\tclear_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\t\t}\n\t}\n\treturn err;\n}\n\n \nstatic int nxp_recv_chip_ver_v1(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct v1_start_ind *req;\n\t__u16 chip_id;\n\n\treq = skb_pull_data(skb, sizeof(*req));\n\tif (!req)\n\t\tgoto free_skb;\n\n\tchip_id = le16_to_cpu(req->chip_id ^ req->chip_id_comp);\n\tif (chip_id == 0xffff && nxpdev->fw_dnld_v1_offset) {\n\t\tnxpdev->fw_dnld_v1_offset = 0;\n\t\tnxpdev->fw_v1_sent_bytes = 0;\n\t\tnxpdev->fw_v1_expected_len = HDR_LEN;\n\t\trelease_firmware(nxpdev->fw);\n\t\tmemset(nxpdev->fw_name, 0, sizeof(nxpdev->fw_name));\n\t\tnxp_send_ack(NXP_ACK_V1, hdev);\n\t}\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int nxp_recv_fw_req_v1(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct btnxpuart_data *nxp_data = nxpdev->nxp_data;\n\tstruct v1_data_req *req;\n\t__u16 len;\n\n\tif (!process_boot_signature(nxpdev))\n\t\tgoto free_skb;\n\n\treq = skb_pull_data(skb, sizeof(*req));\n\tif (!req)\n\t\tgoto free_skb;\n\n\tlen = __le16_to_cpu(req->len ^ req->len_comp);\n\tif (len != 0xffff) {\n\t\tbt_dev_dbg(hdev, \"ERR: Send NAK\");\n\t\tnxp_send_ack(NXP_NAK_V1, hdev);\n\t\tgoto free_skb;\n\t}\n\tnxp_send_ack(NXP_ACK_V1, hdev);\n\n\tlen = __le16_to_cpu(req->len);\n\n\tif (!nxp_data->helper_fw_name) {\n\t\tif (!nxpdev->timeout_changed) {\n\t\t\tnxpdev->timeout_changed = nxp_fw_change_timeout(hdev,\n\t\t\t\t\t\t\t\t\tlen);\n\t\t\tgoto free_skb;\n\t\t}\n\t\tif (!nxpdev->baudrate_changed) {\n\t\t\tnxpdev->baudrate_changed = nxp_fw_change_baudrate(hdev,\n\t\t\t\t\t\t\t\t\t  len);\n\t\t\tif (nxpdev->baudrate_changed) {\n\t\t\t\tserdev_device_set_baudrate(nxpdev->serdev,\n\t\t\t\t\t\t\t   HCI_NXP_SEC_BAUDRATE);\n\t\t\t\tserdev_device_set_flow_control(nxpdev->serdev, true);\n\t\t\t\tnxpdev->current_baudrate = HCI_NXP_SEC_BAUDRATE;\n\t\t\t}\n\t\t\tgoto free_skb;\n\t\t}\n\t}\n\n\tif (!nxp_data->helper_fw_name || nxpdev->helper_downloaded) {\n\t\tif (nxp_request_firmware(hdev, nxp_data->fw_name))\n\t\t\tgoto free_skb;\n\t} else if (nxp_data->helper_fw_name && !nxpdev->helper_downloaded) {\n\t\tif (nxp_request_firmware(hdev, nxp_data->helper_fw_name))\n\t\t\tgoto free_skb;\n\t}\n\n\tif (!len) {\n\t\tbt_dev_dbg(hdev, \"FW Downloaded Successfully: %zu bytes\",\n\t\t\t   nxpdev->fw->size);\n\t\tif (nxp_data->helper_fw_name && !nxpdev->helper_downloaded) {\n\t\t\tnxpdev->helper_downloaded = true;\n\t\t\tserdev_device_wait_until_sent(nxpdev->serdev, 0);\n\t\t\tserdev_device_set_baudrate(nxpdev->serdev,\n\t\t\t\t\t\t   HCI_NXP_SEC_BAUDRATE);\n\t\t\tserdev_device_set_flow_control(nxpdev->serdev, true);\n\t\t} else {\n\t\t\tclear_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\t\t\twake_up_interruptible(&nxpdev->fw_dnld_done_wait_q);\n\t\t}\n\t\tgoto free_skb;\n\t}\n\tif (len & 0x01) {\n\t\t \n\t\tlen = nxpdev->fw_v1_sent_bytes;\n\t\tbt_dev_dbg(hdev, \"CRC error. Resend %d bytes of FW.\", len);\n\t} else {\n\t\tnxpdev->fw_dnld_v1_offset += nxpdev->fw_v1_sent_bytes;\n\n\t\t \n\t\tif (len == nxpdev->fw_v1_expected_len) {\n\t\t\tif (len == HDR_LEN)\n\t\t\t\tnxpdev->fw_v1_expected_len = nxp_get_data_len(nxpdev->fw->data +\n\t\t\t\t\t\t\t\t\tnxpdev->fw_dnld_v1_offset);\n\t\t\telse\n\t\t\t\tnxpdev->fw_v1_expected_len = HDR_LEN;\n\t\t} else if (len == HDR_LEN) {\n\t\t\t \n\t\t\tnxpdev->fw_dnld_v1_offset -= nxpdev->fw_v1_sent_bytes;\n\t\t\tnxpdev->fw_v1_expected_len = HDR_LEN;\n\t\t}\n\t}\n\n\tif (nxpdev->fw_dnld_v1_offset + len <= nxpdev->fw->size)\n\t\tserdev_device_write_buf(nxpdev->serdev, nxpdev->fw->data +\n\t\t\t\t\tnxpdev->fw_dnld_v1_offset, len);\n\tnxpdev->fw_v1_sent_bytes = len;\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic char *nxp_get_fw_name_from_chipid(struct hci_dev *hdev, u16 chipid,\n\t\t\t\t\t u8 loader_ver)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tchar *fw_name = NULL;\n\n\tswitch (chipid) {\n\tcase CHIP_ID_W9098:\n\t\tfw_name = FIRMWARE_W9098;\n\t\tbreak;\n\tcase CHIP_ID_IW416:\n\t\tfw_name = FIRMWARE_IW416;\n\t\tbreak;\n\tcase CHIP_ID_IW612:\n\t\tfw_name = FIRMWARE_IW612;\n\t\tbreak;\n\tcase CHIP_ID_IW624a:\n\tcase CHIP_ID_IW624c:\n\t\tnxpdev->boot_reg_offset = 1;\n\t\tif ((loader_ver & FW_SECURE_MASK) == FW_OPEN)\n\t\t\tfw_name = FIRMWARE_IW624;\n\t\telse if ((loader_ver & FW_SECURE_MASK) != FW_AUTH_ILLEGAL)\n\t\t\tfw_name = FIRMWARE_SECURE_IW624;\n\t\telse\n\t\t\tbt_dev_err(hdev, \"Illegal loader version %02x\", loader_ver);\n\t\tbreak;\n\tcase CHIP_ID_AW693:\n\t\tif ((loader_ver & FW_SECURE_MASK) == FW_OPEN)\n\t\t\tfw_name = FIRMWARE_AW693;\n\t\telse if ((loader_ver & FW_SECURE_MASK) != FW_AUTH_ILLEGAL)\n\t\t\tfw_name = FIRMWARE_SECURE_AW693;\n\t\telse\n\t\t\tbt_dev_err(hdev, \"Illegal loader version %02x\", loader_ver);\n\t\tbreak;\n\tdefault:\n\t\tbt_dev_err(hdev, \"Unknown chip signature %04x\", chipid);\n\t\tbreak;\n\t}\n\treturn fw_name;\n}\n\nstatic int nxp_recv_chip_ver_v3(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct v3_start_ind *req = skb_pull_data(skb, sizeof(*req));\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tu16 chip_id;\n\tu8 loader_ver;\n\n\tif (!process_boot_signature(nxpdev))\n\t\tgoto free_skb;\n\n\tchip_id = le16_to_cpu(req->chip_id);\n\tloader_ver = req->loader_ver;\n\tif (!nxp_request_firmware(hdev, nxp_get_fw_name_from_chipid(hdev,\n\t\t\t\t\t\t\t\t    chip_id, loader_ver)))\n\t\tnxp_send_ack(NXP_ACK_V3, hdev);\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int nxp_recv_fw_req_v3(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct v3_data_req *req;\n\t__u16 len;\n\t__u32 offset;\n\n\tif (!process_boot_signature(nxpdev))\n\t\tgoto free_skb;\n\n\treq = skb_pull_data(skb, sizeof(*req));\n\tif (!req || !nxpdev->fw)\n\t\tgoto free_skb;\n\n\tnxp_send_ack(NXP_ACK_V3, hdev);\n\n\tlen = __le16_to_cpu(req->len);\n\n\tif (!nxpdev->timeout_changed) {\n\t\tnxpdev->timeout_changed = nxp_fw_change_timeout(hdev, len);\n\t\tgoto free_skb;\n\t}\n\n\tif (!nxpdev->baudrate_changed) {\n\t\tnxpdev->baudrate_changed = nxp_fw_change_baudrate(hdev, len);\n\t\tif (nxpdev->baudrate_changed) {\n\t\t\tserdev_device_set_baudrate(nxpdev->serdev,\n\t\t\t\t\t\t   HCI_NXP_SEC_BAUDRATE);\n\t\t\tserdev_device_set_flow_control(nxpdev->serdev, true);\n\t\t\tnxpdev->current_baudrate = HCI_NXP_SEC_BAUDRATE;\n\t\t}\n\t\tgoto free_skb;\n\t}\n\n\tif (req->len == 0) {\n\t\tbt_dev_dbg(hdev, \"FW Downloaded Successfully: %zu bytes\",\n\t\t\t   nxpdev->fw->size);\n\t\tclear_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\t\twake_up_interruptible(&nxpdev->fw_dnld_done_wait_q);\n\t\tgoto free_skb;\n\t}\n\tif (req->error)\n\t\tbt_dev_dbg(hdev, \"FW Download received err 0x%02x from chip\",\n\t\t\t   req->error);\n\n\toffset = __le32_to_cpu(req->offset);\n\tif (offset < nxpdev->fw_v3_offset_correction) {\n\t\t \n\t\tbt_dev_err(hdev, \"Something went wrong during FW download\");\n\t\tbt_dev_err(hdev, \"Please power cycle and try again\");\n\t\tgoto free_skb;\n\t}\n\n\tserdev_device_write_buf(nxpdev->serdev, nxpdev->fw->data + offset -\n\t\t\t\tnxpdev->fw_v3_offset_correction, len);\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int nxp_set_baudrate_cmd(struct hci_dev *hdev, void *data)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\t__le32 new_baudrate = __cpu_to_le32(nxpdev->new_baudrate);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tstruct sk_buff *skb;\n\tu8 *status;\n\n\tif (!psdata)\n\t\treturn 0;\n\n\tskb = nxp_drv_send_cmd(hdev, HCI_NXP_SET_OPER_SPEED, 4, (u8 *)&new_baudrate);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Setting baudrate failed (%ld)\", PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tstatus = (u8 *)skb_pull_data(skb, 1);\n\tif (status) {\n\t\tif (*status == 0) {\n\t\t\tserdev_device_set_baudrate(nxpdev->serdev, nxpdev->new_baudrate);\n\t\t\tnxpdev->current_baudrate = nxpdev->new_baudrate;\n\t\t}\n\t\tbt_dev_dbg(hdev, \"Set baudrate response: status=%d, baudrate=%d\",\n\t\t\t   *status, nxpdev->new_baudrate);\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int nxp_check_boot_sign(struct btnxpuart_dev *nxpdev)\n{\n\tserdev_device_set_baudrate(nxpdev->serdev, HCI_NXP_PRI_BAUDRATE);\n\tif (test_bit(BTNXPUART_IR_IN_PROGRESS, &nxpdev->tx_state))\n\t\tserdev_device_set_flow_control(nxpdev->serdev, false);\n\telse\n\t\tserdev_device_set_flow_control(nxpdev->serdev, true);\n\tset_bit(BTNXPUART_CHECK_BOOT_SIGNATURE, &nxpdev->tx_state);\n\n\treturn wait_event_interruptible_timeout(nxpdev->check_boot_sign_wait_q,\n\t\t\t\t\t       !test_bit(BTNXPUART_CHECK_BOOT_SIGNATURE,\n\t\t\t\t\t\t\t &nxpdev->tx_state),\n\t\t\t\t\t       msecs_to_jiffies(1000));\n}\n\nstatic int nxp_set_ind_reset(struct hci_dev *hdev, void *data)\n{\n\tstatic const u8 ir_hw_err[] = { HCI_EV_HARDWARE_ERROR,\n\t\t\t\t\t0x01, BTNXPUART_IR_HW_ERR };\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(3, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\tskb_put_data(skb, ir_hw_err, 3);\n\n\t \n\treturn hci_recv_frame(hdev, skb);\n}\n\n \nstatic int nxp_setup(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tint err = 0;\n\n\tif (nxp_check_boot_sign(nxpdev)) {\n\t\tbt_dev_dbg(hdev, \"Need FW Download.\");\n\t\terr = nxp_download_firmware(hdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t} else {\n\t\tbt_dev_dbg(hdev, \"FW already running.\");\n\t\tclear_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\t}\n\n\tserdev_device_set_baudrate(nxpdev->serdev, nxpdev->fw_init_baudrate);\n\tnxpdev->current_baudrate = nxpdev->fw_init_baudrate;\n\n\tif (nxpdev->current_baudrate != HCI_NXP_SEC_BAUDRATE) {\n\t\tnxpdev->new_baudrate = HCI_NXP_SEC_BAUDRATE;\n\t\thci_cmd_sync_queue(hdev, nxp_set_baudrate_cmd, NULL, NULL);\n\t}\n\n\tps_init(hdev);\n\n\tif (test_and_clear_bit(BTNXPUART_IR_IN_PROGRESS, &nxpdev->tx_state))\n\t\thci_dev_clear_flag(hdev, HCI_SETUP);\n\n\treturn 0;\n}\n\nstatic void nxp_hw_err(struct hci_dev *hdev, u8 code)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\tswitch (code) {\n\tcase BTNXPUART_IR_HW_ERR:\n\t\tset_bit(BTNXPUART_IR_IN_PROGRESS, &nxpdev->tx_state);\n\t\thci_dev_set_flag(hdev, HCI_SETUP);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int nxp_shutdown(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct sk_buff *skb;\n\tu8 *status;\n\tu8 pcmd = 0;\n\n\tif (test_bit(BTNXPUART_IR_IN_PROGRESS, &nxpdev->tx_state)) {\n\t\tskb = nxp_drv_send_cmd(hdev, HCI_NXP_IND_RESET, 1, &pcmd);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\tstatus = skb_pull_data(skb, 1);\n\t\tif (status) {\n\t\t\tserdev_device_set_flow_control(nxpdev->serdev, false);\n\t\t\tset_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\n\treturn 0;\n}\n\nstatic int btnxpuart_queue_skb(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\tskb_queue_tail(&nxpdev->txq, skb);\n\tbtnxpuart_tx_wakeup(nxpdev);\n\treturn 0;\n}\n\nstatic int nxp_enqueue(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tstruct ps_data *psdata = &nxpdev->psdata;\n\tstruct hci_command_hdr *hdr;\n\tstruct psmode_cmd_payload ps_parm;\n\tstruct wakeup_cmd_payload wakeup_parm;\n\t__le32 baudrate_parm;\n\n\t \n\tif (bt_cb(skb)->pkt_type == HCI_COMMAND_PKT && !psdata->driver_sent_cmd) {\n\t\thdr = (struct hci_command_hdr *)skb->data;\n\t\tif (hdr->plen != (skb->len - HCI_COMMAND_HDR_SIZE))\n\t\t\treturn btnxpuart_queue_skb(hdev, skb);\n\n\t\tswitch (__le16_to_cpu(hdr->opcode)) {\n\t\tcase HCI_NXP_AUTO_SLEEP_MODE:\n\t\t\tif (hdr->plen == sizeof(ps_parm)) {\n\t\t\t\tmemcpy(&ps_parm, skb->data + HCI_COMMAND_HDR_SIZE, hdr->plen);\n\t\t\t\tif (ps_parm.ps_cmd == BT_PS_ENABLE)\n\t\t\t\t\tpsdata->target_ps_mode = PS_MODE_ENABLE;\n\t\t\t\telse if (ps_parm.ps_cmd == BT_PS_DISABLE)\n\t\t\t\t\tpsdata->target_ps_mode = PS_MODE_DISABLE;\n\t\t\t\tpsdata->c2h_ps_interval = __le16_to_cpu(ps_parm.c2h_ps_interval);\n\t\t\t\thci_cmd_sync_queue(hdev, send_ps_cmd, NULL, NULL);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HCI_NXP_WAKEUP_METHOD:\n\t\t\tif (hdr->plen == sizeof(wakeup_parm)) {\n\t\t\t\tmemcpy(&wakeup_parm, skb->data + HCI_COMMAND_HDR_SIZE, hdr->plen);\n\t\t\t\tpsdata->c2h_wakeupmode = wakeup_parm.c2h_wakeupmode;\n\t\t\t\tpsdata->c2h_wakeup_gpio = wakeup_parm.c2h_wakeup_gpio;\n\t\t\t\tpsdata->h2c_wakeup_gpio = wakeup_parm.h2c_wakeup_gpio;\n\t\t\t\tswitch (wakeup_parm.h2c_wakeupmode) {\n\t\t\t\tcase BT_CTRL_WAKEUP_METHOD_DSR:\n\t\t\t\t\tpsdata->h2c_wakeupmode = WAKEUP_METHOD_DTR;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BT_CTRL_WAKEUP_METHOD_BREAK:\n\t\t\t\tdefault:\n\t\t\t\t\tpsdata->h2c_wakeupmode = WAKEUP_METHOD_BREAK;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\thci_cmd_sync_queue(hdev, send_wakeup_method_cmd, NULL, NULL);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HCI_NXP_SET_OPER_SPEED:\n\t\t\tif (hdr->plen == sizeof(baudrate_parm)) {\n\t\t\t\tmemcpy(&baudrate_parm, skb->data + HCI_COMMAND_HDR_SIZE, hdr->plen);\n\t\t\t\tnxpdev->new_baudrate = __le32_to_cpu(baudrate_parm);\n\t\t\t\thci_cmd_sync_queue(hdev, nxp_set_baudrate_cmd, NULL, NULL);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HCI_NXP_IND_RESET:\n\t\t\tif (hdr->plen == 1) {\n\t\t\t\thci_cmd_sync_queue(hdev, nxp_set_ind_reset, NULL, NULL);\n\t\t\t\tgoto free_skb;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn btnxpuart_queue_skb(hdev, skb);\n\nfree_skb:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic struct sk_buff *nxp_dequeue(void *data)\n{\n\tstruct btnxpuart_dev *nxpdev = (struct btnxpuart_dev *)data;\n\n\tps_wakeup(nxpdev);\n\tps_start_timer(nxpdev);\n\treturn skb_dequeue(&nxpdev->txq);\n}\n\n \nstatic void btnxpuart_tx_work(struct work_struct *work)\n{\n\tstruct btnxpuart_dev *nxpdev = container_of(work, struct btnxpuart_dev,\n\t\t\t\t\t\t   tx_work);\n\tstruct serdev_device *serdev = nxpdev->serdev;\n\tstruct hci_dev *hdev = nxpdev->hdev;\n\tstruct sk_buff *skb;\n\tint len;\n\n\twhile ((skb = nxp_dequeue(nxpdev))) {\n\t\tlen = serdev_device_write_buf(serdev, skb->data, skb->len);\n\t\thdev->stat.byte_tx += len;\n\n\t\tskb_pull(skb, len);\n\t\tif (skb->len > 0) {\n\t\t\tskb_queue_head(&nxpdev->txq, skb);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (hci_skb_pkt_type(skb)) {\n\t\tcase HCI_COMMAND_PKT:\n\t\t\thdev->stat.cmd_tx++;\n\t\t\tbreak;\n\t\tcase HCI_ACLDATA_PKT:\n\t\t\thdev->stat.acl_tx++;\n\t\t\tbreak;\n\t\tcase HCI_SCODATA_PKT:\n\t\t\thdev->stat.sco_tx++;\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\tclear_bit(BTNXPUART_TX_STATE_ACTIVE, &nxpdev->tx_state);\n}\n\nstatic int btnxpuart_open(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\tint err = 0;\n\n\terr = serdev_device_open(nxpdev->serdev);\n\tif (err) {\n\t\tbt_dev_err(hdev, \"Unable to open UART device %s\",\n\t\t\t   dev_name(&nxpdev->serdev->dev));\n\t} else {\n\t\tset_bit(BTNXPUART_SERDEV_OPEN, &nxpdev->tx_state);\n\t}\n\treturn err;\n}\n\nstatic int btnxpuart_close(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\tps_wakeup(nxpdev);\n\tserdev_device_close(nxpdev->serdev);\n\tclear_bit(BTNXPUART_SERDEV_OPEN, &nxpdev->tx_state);\n\treturn 0;\n}\n\nstatic int btnxpuart_flush(struct hci_dev *hdev)\n{\n\tstruct btnxpuart_dev *nxpdev = hci_get_drvdata(hdev);\n\n\t \n\tserdev_device_write_flush(nxpdev->serdev);\n\tskb_queue_purge(&nxpdev->txq);\n\n\tcancel_work_sync(&nxpdev->tx_work);\n\n\tkfree_skb(nxpdev->rx_skb);\n\tnxpdev->rx_skb = NULL;\n\n\treturn 0;\n}\n\nstatic const struct h4_recv_pkt nxp_recv_pkts[] = {\n\t{ H4_RECV_ACL,          .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,          .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,        .recv = hci_recv_frame },\n\t{ NXP_RECV_CHIP_VER_V1, .recv = nxp_recv_chip_ver_v1 },\n\t{ NXP_RECV_FW_REQ_V1,   .recv = nxp_recv_fw_req_v1 },\n\t{ NXP_RECV_CHIP_VER_V3, .recv = nxp_recv_chip_ver_v3 },\n\t{ NXP_RECV_FW_REQ_V3,   .recv = nxp_recv_fw_req_v3 },\n};\n\nstatic int btnxpuart_receive_buf(struct serdev_device *serdev, const u8 *data,\n\t\t\t\t size_t count)\n{\n\tstruct btnxpuart_dev *nxpdev = serdev_device_get_drvdata(serdev);\n\n\tps_start_timer(nxpdev);\n\n\tnxpdev->rx_skb = h4_recv_buf(nxpdev->hdev, nxpdev->rx_skb, data, count,\n\t\t\t\t     nxp_recv_pkts, ARRAY_SIZE(nxp_recv_pkts));\n\tif (IS_ERR(nxpdev->rx_skb)) {\n\t\tint err = PTR_ERR(nxpdev->rx_skb);\n\t\t \n\t\tif (!is_fw_downloading(nxpdev))\n\t\t\tbt_dev_err(nxpdev->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tnxpdev->rx_skb = NULL;\n\t\treturn count;\n\t}\n\tif (!is_fw_downloading(nxpdev))\n\t\tnxpdev->hdev->stat.byte_rx += count;\n\treturn count;\n}\n\nstatic void btnxpuart_write_wakeup(struct serdev_device *serdev)\n{\n\tserdev_device_write_wakeup(serdev);\n}\n\nstatic const struct serdev_device_ops btnxpuart_client_ops = {\n\t.receive_buf = btnxpuart_receive_buf,\n\t.write_wakeup = btnxpuart_write_wakeup,\n};\n\nstatic int nxp_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct hci_dev *hdev;\n\tstruct btnxpuart_dev *nxpdev;\n\n\tnxpdev = devm_kzalloc(&serdev->dev, sizeof(*nxpdev), GFP_KERNEL);\n\tif (!nxpdev)\n\t\treturn -ENOMEM;\n\n\tnxpdev->nxp_data = (struct btnxpuart_data *)device_get_match_data(&serdev->dev);\n\n\tnxpdev->serdev = serdev;\n\tserdev_device_set_drvdata(serdev, nxpdev);\n\n\tserdev_device_set_client_ops(serdev, &btnxpuart_client_ops);\n\n\tINIT_WORK(&nxpdev->tx_work, btnxpuart_tx_work);\n\tskb_queue_head_init(&nxpdev->txq);\n\n\tinit_waitqueue_head(&nxpdev->fw_dnld_done_wait_q);\n\tinit_waitqueue_head(&nxpdev->check_boot_sign_wait_q);\n\n\tdevice_property_read_u32(&nxpdev->serdev->dev, \"fw-init-baudrate\",\n\t\t\t\t &nxpdev->fw_init_baudrate);\n\tif (!nxpdev->fw_init_baudrate)\n\t\tnxpdev->fw_init_baudrate = FW_INIT_BAUDRATE;\n\n\tset_bit(BTNXPUART_FW_DOWNLOADING, &nxpdev->tx_state);\n\n\tcrc8_populate_msb(crc8_table, POLYNOMIAL8);\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tdev_err(&serdev->dev, \"Can't allocate HCI device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tnxpdev->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, nxpdev);\n\n\thdev->manufacturer = MANUFACTURER_NXP;\n\thdev->open  = btnxpuart_open;\n\thdev->close = btnxpuart_close;\n\thdev->flush = btnxpuart_flush;\n\thdev->setup = nxp_setup;\n\thdev->send  = nxp_enqueue;\n\thdev->hw_error = nxp_hw_err;\n\thdev->shutdown = nxp_shutdown;\n\tSET_HCIDEV_DEV(hdev, &serdev->dev);\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tdev_err(&serdev->dev, \"Can't register HCI device\\n\");\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\tps_setup(hdev);\n\n\treturn 0;\n}\n\nstatic void nxp_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct btnxpuart_dev *nxpdev = serdev_device_get_drvdata(serdev);\n\tstruct hci_dev *hdev = nxpdev->hdev;\n\n\t \n\tif (nxpdev->current_baudrate != nxpdev->fw_init_baudrate) {\n\t\tnxpdev->new_baudrate = nxpdev->fw_init_baudrate;\n\t\tnxp_set_baudrate_cmd(hdev, NULL);\n\t}\n\n\tps_cancel_timer(nxpdev);\n\thci_unregister_dev(hdev);\n\thci_free_dev(hdev);\n}\n\nstatic struct btnxpuart_data w8987_data __maybe_unused = {\n\t.helper_fw_name = NULL,\n\t.fw_name = FIRMWARE_W8987,\n};\n\nstatic struct btnxpuart_data w8997_data __maybe_unused = {\n\t.helper_fw_name = FIRMWARE_HELPER,\n\t.fw_name = FIRMWARE_W8997,\n};\n\nstatic const struct of_device_id nxpuart_of_match_table[] __maybe_unused = {\n\t{ .compatible = \"nxp,88w8987-bt\", .data = &w8987_data },\n\t{ .compatible = \"nxp,88w8997-bt\", .data = &w8997_data },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, nxpuart_of_match_table);\n\nstatic struct serdev_device_driver nxp_serdev_driver = {\n\t.probe = nxp_serdev_probe,\n\t.remove = nxp_serdev_remove,\n\t.driver = {\n\t\t.name = \"btnxpuart\",\n\t\t.of_match_table = of_match_ptr(nxpuart_of_match_table),\n\t},\n};\n\nmodule_serdev_device_driver(nxp_serdev_driver);\n\nMODULE_AUTHOR(\"Neeraj Sanjay Kale <neeraj.sanjaykale@nxp.com>\");\nMODULE_DESCRIPTION(\"NXP Bluetooth Serial driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}