{
  "module_name": "hci_h5.c",
  "hash_id": "15edae86e940313e875ba457c30f6e6c55a10d7cdd44eba60a6a07b9fe0bb5bb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_h5.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/errno.h>\n#include <linux/gpio/consumer.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/of.h>\n#include <linux/pm_runtime.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btrtl.h\"\n#include \"hci_uart.h\"\n\n#define SUSPEND_TIMEOUT_MS\t6000\n\n#define HCI_3WIRE_ACK_PKT\t0\n#define HCI_3WIRE_LINK_PKT\t15\n\n \n#define H5_TX_WIN_MAX\t\t4\n\n#define H5_ACK_TIMEOUT\tmsecs_to_jiffies(250)\n#define H5_SYNC_TIMEOUT\tmsecs_to_jiffies(100)\n\n \n#define H5_MAX_LEN (4 + 0xfff + 2)\n\n \n#define H5_HDR_SEQ(hdr)\t\t((hdr)[0] & 0x07)\n#define H5_HDR_ACK(hdr)\t\t(((hdr)[0] >> 3) & 0x07)\n#define H5_HDR_CRC(hdr)\t\t(((hdr)[0] >> 6) & 0x01)\n#define H5_HDR_RELIABLE(hdr)\t(((hdr)[0] >> 7) & 0x01)\n#define H5_HDR_PKT_TYPE(hdr)\t((hdr)[1] & 0x0f)\n#define H5_HDR_LEN(hdr)\t\t((((hdr)[1] >> 4) & 0x0f) + ((hdr)[2] << 4))\n\n#define SLIP_DELIMITER\t0xc0\n#define SLIP_ESC\t0xdb\n#define SLIP_ESC_DELIM\t0xdc\n#define SLIP_ESC_ESC\t0xdd\n\n \nenum {\n\tH5_RX_ESC,\t\t \n\tH5_TX_ACK_REQ,\t\t \n\tH5_WAKEUP_DISABLE,\t \n\tH5_HW_FLOW_CONTROL,\t \n};\n\nstruct h5 {\n\t \n\tstruct hci_uart\t\tserdev_hu;\n\n\tstruct sk_buff_head\tunack;\t\t \n\tstruct sk_buff_head\trel;\t\t \n\tstruct sk_buff_head\tunrel;\t\t \n\n\tunsigned long\t\tflags;\n\n\tstruct sk_buff\t\t*rx_skb;\t \n\tsize_t\t\t\trx_pending;\t \n\tu8\t\t\trx_ack;\t\t \n\n\tint\t\t\t(*rx_func)(struct hci_uart *hu, u8 c);\n\n\tstruct timer_list\ttimer;\t\t \n\tstruct hci_uart\t\t*hu;\t\t \n\n\tu8\t\t\ttx_seq;\t\t \n\tu8\t\t\ttx_ack;\t\t \n\tu8\t\t\ttx_win;\t\t \n\n\tenum {\n\t\tH5_UNINITIALIZED,\n\t\tH5_INITIALIZED,\n\t\tH5_ACTIVE,\n\t} state;\n\n\tenum {\n\t\tH5_AWAKE,\n\t\tH5_SLEEPING,\n\t\tH5_WAKING_UP,\n\t} sleep;\n\n\tconst struct h5_vnd *vnd;\n\tconst char *id;\n\n\tstruct gpio_desc *enable_gpio;\n\tstruct gpio_desc *device_wake_gpio;\n};\n\nenum h5_driver_info {\n\tH5_INFO_WAKEUP_DISABLE = BIT(0),\n};\n\nstruct h5_vnd {\n\tint (*setup)(struct h5 *h5);\n\tvoid (*open)(struct h5 *h5);\n\tvoid (*close)(struct h5 *h5);\n\tint (*suspend)(struct h5 *h5);\n\tint (*resume)(struct h5 *h5);\n\tconst struct acpi_gpio_mapping *acpi_gpio_map;\n};\n\nstruct h5_device_data {\n\tuint32_t driver_info;\n\tstruct h5_vnd *vnd;\n};\n\nstatic void h5_reset_rx(struct h5 *h5);\n\nstatic void h5_link_control(struct hci_uart *hu, const void *data, size_t len)\n{\n\tstruct h5 *h5 = hu->priv;\n\tstruct sk_buff *nskb;\n\n\tnskb = alloc_skb(3, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn;\n\n\thci_skb_pkt_type(nskb) = HCI_3WIRE_LINK_PKT;\n\n\tskb_put_data(nskb, data, len);\n\n\tskb_queue_tail(&h5->unrel, nskb);\n}\n\nstatic u8 h5_cfg_field(struct h5 *h5)\n{\n\t \n\treturn h5->tx_win & 0x07;\n}\n\nstatic void h5_timed_event(struct timer_list *t)\n{\n\tconst unsigned char sync_req[] = { 0x01, 0x7e };\n\tunsigned char conf_req[3] = { 0x03, 0xfc };\n\tstruct h5 *h5 = from_timer(h5, t, timer);\n\tstruct hci_uart *hu = h5->hu;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tBT_DBG(\"%s\", hu->hdev->name);\n\n\tif (h5->state == H5_UNINITIALIZED)\n\t\th5_link_control(hu, sync_req, sizeof(sync_req));\n\n\tif (h5->state == H5_INITIALIZED) {\n\t\tconf_req[2] = h5_cfg_field(h5);\n\t\th5_link_control(hu, conf_req, sizeof(conf_req));\n\t}\n\n\tif (h5->state != H5_ACTIVE) {\n\t\tmod_timer(&h5->timer, jiffies + H5_SYNC_TIMEOUT);\n\t\tgoto wakeup;\n\t}\n\n\tif (h5->sleep != H5_AWAKE) {\n\t\th5->sleep = H5_SLEEPING;\n\t\tgoto wakeup;\n\t}\n\n\tBT_DBG(\"hu %p retransmitting %u pkts\", hu, h5->unack.qlen);\n\n\tspin_lock_irqsave_nested(&h5->unack.lock, flags, SINGLE_DEPTH_NESTING);\n\n\twhile ((skb = __skb_dequeue_tail(&h5->unack)) != NULL) {\n\t\th5->tx_seq = (h5->tx_seq - 1) & 0x07;\n\t\tskb_queue_head(&h5->rel, skb);\n\t}\n\n\tspin_unlock_irqrestore(&h5->unack.lock, flags);\n\nwakeup:\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void h5_peer_reset(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tbt_dev_err(hu->hdev, \"Peer device has reset\");\n\n\th5->state = H5_UNINITIALIZED;\n\n\tdel_timer(&h5->timer);\n\n\tskb_queue_purge(&h5->rel);\n\tskb_queue_purge(&h5->unrel);\n\tskb_queue_purge(&h5->unack);\n\n\th5->tx_seq = 0;\n\th5->tx_ack = 0;\n\n\t \n\thci_reset_dev(hu->hdev);\n}\n\nstatic int h5_open(struct hci_uart *hu)\n{\n\tstruct h5 *h5;\n\tconst unsigned char sync[] = { 0x01, 0x7e };\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tif (hu->serdev) {\n\t\th5 = serdev_device_get_drvdata(hu->serdev);\n\t} else {\n\t\th5 = kzalloc(sizeof(*h5), GFP_KERNEL);\n\t\tif (!h5)\n\t\t\treturn -ENOMEM;\n\t}\n\n\thu->priv = h5;\n\th5->hu = hu;\n\n\tskb_queue_head_init(&h5->unack);\n\tskb_queue_head_init(&h5->rel);\n\tskb_queue_head_init(&h5->unrel);\n\n\th5_reset_rx(h5);\n\n\ttimer_setup(&h5->timer, h5_timed_event, 0);\n\n\th5->tx_win = H5_TX_WIN_MAX;\n\n\tif (h5->vnd && h5->vnd->open)\n\t\th5->vnd->open(h5);\n\n\tset_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags);\n\n\t \n\th5_link_control(hu, sync, sizeof(sync));\n\tmod_timer(&h5->timer, jiffies + H5_SYNC_TIMEOUT);\n\n\treturn 0;\n}\n\nstatic int h5_close(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tdel_timer_sync(&h5->timer);\n\n\tskb_queue_purge(&h5->unack);\n\tskb_queue_purge(&h5->rel);\n\tskb_queue_purge(&h5->unrel);\n\n\tkfree_skb(h5->rx_skb);\n\th5->rx_skb = NULL;\n\n\tif (h5->vnd && h5->vnd->close)\n\t\th5->vnd->close(h5);\n\n\tif (!hu->serdev)\n\t\tkfree(h5);\n\n\treturn 0;\n}\n\nstatic int h5_setup(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tif (h5->vnd && h5->vnd->setup)\n\t\treturn h5->vnd->setup(h5);\n\n\treturn 0;\n}\n\nstatic void h5_pkt_cull(struct h5 *h5)\n{\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\tint i, to_remove;\n\tu8 seq;\n\n\tspin_lock_irqsave(&h5->unack.lock, flags);\n\n\tto_remove = skb_queue_len(&h5->unack);\n\tif (to_remove == 0)\n\t\tgoto unlock;\n\n\tseq = h5->tx_seq;\n\n\twhile (to_remove > 0) {\n\t\tif (h5->rx_ack == seq)\n\t\t\tbreak;\n\n\t\tto_remove--;\n\t\tseq = (seq - 1) & 0x07;\n\t}\n\n\tif (seq != h5->rx_ack)\n\t\tBT_ERR(\"Controller acked invalid packet\");\n\n\ti = 0;\n\tskb_queue_walk_safe(&h5->unack, skb, tmp) {\n\t\tif (i++ >= to_remove)\n\t\t\tbreak;\n\n\t\t__skb_unlink(skb, &h5->unack);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\n\tif (skb_queue_empty(&h5->unack))\n\t\tdel_timer(&h5->timer);\n\nunlock:\n\tspin_unlock_irqrestore(&h5->unack.lock, flags);\n}\n\nstatic void h5_handle_internal_rx(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\tconst unsigned char sync_req[] = { 0x01, 0x7e };\n\tconst unsigned char sync_rsp[] = { 0x02, 0x7d };\n\tunsigned char conf_req[3] = { 0x03, 0xfc };\n\tconst unsigned char conf_rsp[] = { 0x04, 0x7b };\n\tconst unsigned char wakeup_req[] = { 0x05, 0xfa };\n\tconst unsigned char woken_req[] = { 0x06, 0xf9 };\n\tconst unsigned char sleep_req[] = { 0x07, 0x78 };\n\tconst unsigned char *hdr = h5->rx_skb->data;\n\tconst unsigned char *data = &h5->rx_skb->data[4];\n\n\tBT_DBG(\"%s\", hu->hdev->name);\n\n\tif (H5_HDR_PKT_TYPE(hdr) != HCI_3WIRE_LINK_PKT)\n\t\treturn;\n\n\tif (H5_HDR_LEN(hdr) < 2)\n\t\treturn;\n\n\tconf_req[2] = h5_cfg_field(h5);\n\n\tif (memcmp(data, sync_req, 2) == 0) {\n\t\tif (h5->state == H5_ACTIVE)\n\t\t\th5_peer_reset(hu);\n\t\th5_link_control(hu, sync_rsp, 2);\n\t} else if (memcmp(data, sync_rsp, 2) == 0) {\n\t\tif (h5->state == H5_ACTIVE)\n\t\t\th5_peer_reset(hu);\n\t\th5->state = H5_INITIALIZED;\n\t\th5_link_control(hu, conf_req, 3);\n\t} else if (memcmp(data, conf_req, 2) == 0) {\n\t\th5_link_control(hu, conf_rsp, 2);\n\t\th5_link_control(hu, conf_req, 3);\n\t} else if (memcmp(data, conf_rsp, 2) == 0) {\n\t\tif (H5_HDR_LEN(hdr) > 2)\n\t\t\th5->tx_win = (data[2] & 0x07);\n\t\tBT_DBG(\"Three-wire init complete. tx_win %u\", h5->tx_win);\n\t\th5->state = H5_ACTIVE;\n\t\thci_uart_init_ready(hu);\n\t\treturn;\n\t} else if (memcmp(data, sleep_req, 2) == 0) {\n\t\tBT_DBG(\"Peer went to sleep\");\n\t\th5->sleep = H5_SLEEPING;\n\t\treturn;\n\t} else if (memcmp(data, woken_req, 2) == 0) {\n\t\tBT_DBG(\"Peer woke up\");\n\t\th5->sleep = H5_AWAKE;\n\t} else if (memcmp(data, wakeup_req, 2) == 0) {\n\t\tBT_DBG(\"Peer requested wakeup\");\n\t\th5_link_control(hu, woken_req, 2);\n\t\th5->sleep = H5_AWAKE;\n\t} else {\n\t\tBT_DBG(\"Link Control: 0x%02hhx 0x%02hhx\", data[0], data[1]);\n\t\treturn;\n\t}\n\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic void h5_complete_rx_pkt(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\tconst unsigned char *hdr = h5->rx_skb->data;\n\n\tif (H5_HDR_RELIABLE(hdr)) {\n\t\th5->tx_ack = (h5->tx_ack + 1) % 8;\n\t\tset_bit(H5_TX_ACK_REQ, &h5->flags);\n\t\thci_uart_tx_wakeup(hu);\n\t}\n\n\th5->rx_ack = H5_HDR_ACK(hdr);\n\n\th5_pkt_cull(h5);\n\n\tswitch (H5_HDR_PKT_TYPE(hdr)) {\n\tcase HCI_EVENT_PKT:\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\thci_skb_pkt_type(h5->rx_skb) = H5_HDR_PKT_TYPE(hdr);\n\n\t\t \n\t\tskb_pull(h5->rx_skb, 4);\n\n\t\thci_recv_frame(hu->hdev, h5->rx_skb);\n\t\th5->rx_skb = NULL;\n\n\t\tbreak;\n\n\tdefault:\n\t\th5_handle_internal_rx(hu);\n\t\tbreak;\n\t}\n\n\th5_reset_rx(h5);\n}\n\nstatic int h5_rx_crc(struct hci_uart *hu, unsigned char c)\n{\n\th5_complete_rx_pkt(hu);\n\n\treturn 0;\n}\n\nstatic int h5_rx_payload(struct hci_uart *hu, unsigned char c)\n{\n\tstruct h5 *h5 = hu->priv;\n\tconst unsigned char *hdr = h5->rx_skb->data;\n\n\tif (H5_HDR_CRC(hdr)) {\n\t\th5->rx_func = h5_rx_crc;\n\t\th5->rx_pending = 2;\n\t} else {\n\t\th5_complete_rx_pkt(hu);\n\t}\n\n\treturn 0;\n}\n\nstatic int h5_rx_3wire_hdr(struct hci_uart *hu, unsigned char c)\n{\n\tstruct h5 *h5 = hu->priv;\n\tconst unsigned char *hdr = h5->rx_skb->data;\n\n\tBT_DBG(\"%s rx: seq %u ack %u crc %u rel %u type %u len %u\",\n\t       hu->hdev->name, H5_HDR_SEQ(hdr), H5_HDR_ACK(hdr),\n\t       H5_HDR_CRC(hdr), H5_HDR_RELIABLE(hdr), H5_HDR_PKT_TYPE(hdr),\n\t       H5_HDR_LEN(hdr));\n\n\tif (((hdr[0] + hdr[1] + hdr[2] + hdr[3]) & 0xff) != 0xff) {\n\t\tbt_dev_err(hu->hdev, \"Invalid header checksum\");\n\t\th5_reset_rx(h5);\n\t\treturn 0;\n\t}\n\n\tif (H5_HDR_RELIABLE(hdr) && H5_HDR_SEQ(hdr) != h5->tx_ack) {\n\t\tbt_dev_err(hu->hdev, \"Out-of-order packet arrived (%u != %u)\",\n\t\t\t   H5_HDR_SEQ(hdr), h5->tx_ack);\n\t\tset_bit(H5_TX_ACK_REQ, &h5->flags);\n\t\thci_uart_tx_wakeup(hu);\n\t\th5_reset_rx(h5);\n\t\treturn 0;\n\t}\n\n\tif (h5->state != H5_ACTIVE &&\n\t    H5_HDR_PKT_TYPE(hdr) != HCI_3WIRE_LINK_PKT) {\n\t\tbt_dev_err(hu->hdev, \"Non-link packet received in non-active state\");\n\t\th5_reset_rx(h5);\n\t\treturn 0;\n\t}\n\n\th5->rx_func = h5_rx_payload;\n\th5->rx_pending = H5_HDR_LEN(hdr);\n\n\treturn 0;\n}\n\nstatic int h5_rx_pkt_start(struct hci_uart *hu, unsigned char c)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tif (c == SLIP_DELIMITER)\n\t\treturn 1;\n\n\th5->rx_func = h5_rx_3wire_hdr;\n\th5->rx_pending = 4;\n\n\th5->rx_skb = bt_skb_alloc(H5_MAX_LEN, GFP_ATOMIC);\n\tif (!h5->rx_skb) {\n\t\tbt_dev_err(hu->hdev, \"Can't allocate mem for new packet\");\n\t\th5_reset_rx(h5);\n\t\treturn -ENOMEM;\n\t}\n\n\th5->rx_skb->dev = (void *)hu->hdev;\n\n\treturn 0;\n}\n\nstatic int h5_rx_delimiter(struct hci_uart *hu, unsigned char c)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tif (c == SLIP_DELIMITER)\n\t\th5->rx_func = h5_rx_pkt_start;\n\n\treturn 1;\n}\n\nstatic void h5_unslip_one_byte(struct h5 *h5, unsigned char c)\n{\n\tconst u8 delim = SLIP_DELIMITER, esc = SLIP_ESC;\n\tconst u8 *byte = &c;\n\n\tif (!test_bit(H5_RX_ESC, &h5->flags) && c == SLIP_ESC) {\n\t\tset_bit(H5_RX_ESC, &h5->flags);\n\t\treturn;\n\t}\n\n\tif (test_and_clear_bit(H5_RX_ESC, &h5->flags)) {\n\t\tswitch (c) {\n\t\tcase SLIP_ESC_DELIM:\n\t\t\tbyte = &delim;\n\t\t\tbreak;\n\t\tcase SLIP_ESC_ESC:\n\t\t\tbyte = &esc;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBT_ERR(\"Invalid esc byte 0x%02hhx\", c);\n\t\t\th5_reset_rx(h5);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb_put_data(h5->rx_skb, byte, 1);\n\th5->rx_pending--;\n\n\tBT_DBG(\"unslipped 0x%02hhx, rx_pending %zu\", *byte, h5->rx_pending);\n}\n\nstatic void h5_reset_rx(struct h5 *h5)\n{\n\tif (h5->rx_skb) {\n\t\tkfree_skb(h5->rx_skb);\n\t\th5->rx_skb = NULL;\n\t}\n\n\th5->rx_func = h5_rx_delimiter;\n\th5->rx_pending = 0;\n\tclear_bit(H5_RX_ESC, &h5->flags);\n}\n\nstatic int h5_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct h5 *h5 = hu->priv;\n\tconst unsigned char *ptr = data;\n\n\tBT_DBG(\"%s pending %zu count %d\", hu->hdev->name, h5->rx_pending,\n\t       count);\n\n\twhile (count > 0) {\n\t\tint processed;\n\n\t\tif (h5->rx_pending > 0) {\n\t\t\tif (*ptr == SLIP_DELIMITER) {\n\t\t\t\tbt_dev_err(hu->hdev, \"Too short H5 packet\");\n\t\t\t\th5_reset_rx(h5);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\th5_unslip_one_byte(h5, *ptr);\n\n\t\t\tptr++; count--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tprocessed = h5->rx_func(hu, *ptr);\n\t\tif (processed < 0)\n\t\t\treturn processed;\n\n\t\tptr += processed;\n\t\tcount -= processed;\n\t}\n\n\tif (hu->serdev) {\n\t\tpm_runtime_get(&hu->serdev->dev);\n\t\tpm_runtime_mark_last_busy(&hu->serdev->dev);\n\t\tpm_runtime_put_autosuspend(&hu->serdev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic int h5_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct h5 *h5 = hu->priv;\n\n\tif (skb->len > 0xfff) {\n\t\tbt_dev_err(hu->hdev, \"Packet too long (%u bytes)\", skb->len);\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tif (h5->state != H5_ACTIVE) {\n\t\tbt_dev_err(hu->hdev, \"Ignoring HCI data in non-active state\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_COMMAND_PKT:\n\t\tskb_queue_tail(&h5->rel, skb);\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\t\tskb_queue_tail(&h5->unrel, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tbt_dev_err(hu->hdev, \"Unknown packet type %u\", hci_skb_pkt_type(skb));\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tif (hu->serdev) {\n\t\tpm_runtime_get_sync(&hu->serdev->dev);\n\t\tpm_runtime_mark_last_busy(&hu->serdev->dev);\n\t\tpm_runtime_put_autosuspend(&hu->serdev->dev);\n\t}\n\n\treturn 0;\n}\n\nstatic void h5_slip_delim(struct sk_buff *skb)\n{\n\tconst char delim = SLIP_DELIMITER;\n\n\tskb_put_data(skb, &delim, 1);\n}\n\nstatic void h5_slip_one_byte(struct sk_buff *skb, u8 c)\n{\n\tconst char esc_delim[2] = { SLIP_ESC, SLIP_ESC_DELIM };\n\tconst char esc_esc[2] = { SLIP_ESC, SLIP_ESC_ESC };\n\n\tswitch (c) {\n\tcase SLIP_DELIMITER:\n\t\tskb_put_data(skb, &esc_delim, 2);\n\t\tbreak;\n\tcase SLIP_ESC:\n\t\tskb_put_data(skb, &esc_esc, 2);\n\t\tbreak;\n\tdefault:\n\t\tskb_put_data(skb, &c, 1);\n\t}\n}\n\nstatic bool valid_packet_type(u8 type)\n{\n\tswitch (type) {\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_COMMAND_PKT:\n\tcase HCI_SCODATA_PKT:\n\tcase HCI_ISODATA_PKT:\n\tcase HCI_3WIRE_LINK_PKT:\n\tcase HCI_3WIRE_ACK_PKT:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic struct sk_buff *h5_prepare_pkt(struct hci_uart *hu, u8 pkt_type,\n\t\t\t\t      const u8 *data, size_t len)\n{\n\tstruct h5 *h5 = hu->priv;\n\tstruct sk_buff *nskb;\n\tu8 hdr[4];\n\tint i;\n\n\tif (!valid_packet_type(pkt_type)) {\n\t\tbt_dev_err(hu->hdev, \"Unknown packet type %u\", pkt_type);\n\t\treturn NULL;\n\t}\n\n\t \n\tnskb = alloc_skb((len + 6) * 2 + 2, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\thci_skb_pkt_type(nskb) = pkt_type;\n\n\th5_slip_delim(nskb);\n\n\thdr[0] = h5->tx_ack << 3;\n\tclear_bit(H5_TX_ACK_REQ, &h5->flags);\n\n\t \n\tif (pkt_type == HCI_ACLDATA_PKT || pkt_type == HCI_COMMAND_PKT) {\n\t\thdr[0] |= 1 << 7;\n\t\thdr[0] |= h5->tx_seq;\n\t\th5->tx_seq = (h5->tx_seq + 1) % 8;\n\t}\n\n\thdr[1] = pkt_type | ((len & 0x0f) << 4);\n\thdr[2] = len >> 4;\n\thdr[3] = ~((hdr[0] + hdr[1] + hdr[2]) & 0xff);\n\n\tBT_DBG(\"%s tx: seq %u ack %u crc %u rel %u type %u len %u\",\n\t       hu->hdev->name, H5_HDR_SEQ(hdr), H5_HDR_ACK(hdr),\n\t       H5_HDR_CRC(hdr), H5_HDR_RELIABLE(hdr), H5_HDR_PKT_TYPE(hdr),\n\t       H5_HDR_LEN(hdr));\n\n\tfor (i = 0; i < 4; i++)\n\t\th5_slip_one_byte(nskb, hdr[i]);\n\n\tfor (i = 0; i < len; i++)\n\t\th5_slip_one_byte(nskb, data[i]);\n\n\th5_slip_delim(nskb);\n\n\treturn nskb;\n}\n\nstatic struct sk_buff *h5_dequeue(struct hci_uart *hu)\n{\n\tstruct h5 *h5 = hu->priv;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *nskb;\n\n\tif (h5->sleep != H5_AWAKE) {\n\t\tconst unsigned char wakeup_req[] = { 0x05, 0xfa };\n\n\t\tif (h5->sleep == H5_WAKING_UP)\n\t\t\treturn NULL;\n\n\t\th5->sleep = H5_WAKING_UP;\n\t\tBT_DBG(\"Sending wakeup request\");\n\n\t\tmod_timer(&h5->timer, jiffies + HZ / 100);\n\t\treturn h5_prepare_pkt(hu, HCI_3WIRE_LINK_PKT, wakeup_req, 2);\n\t}\n\n\tskb = skb_dequeue(&h5->unrel);\n\tif (skb) {\n\t\tnskb = h5_prepare_pkt(hu, hci_skb_pkt_type(skb),\n\t\t\t\t      skb->data, skb->len);\n\t\tif (nskb) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn nskb;\n\t\t}\n\n\t\tskb_queue_head(&h5->unrel, skb);\n\t\tbt_dev_err(hu->hdev, \"Could not dequeue pkt because alloc_skb failed\");\n\t}\n\n\tspin_lock_irqsave_nested(&h5->unack.lock, flags, SINGLE_DEPTH_NESTING);\n\n\tif (h5->unack.qlen >= h5->tx_win)\n\t\tgoto unlock;\n\n\tskb = skb_dequeue(&h5->rel);\n\tif (skb) {\n\t\tnskb = h5_prepare_pkt(hu, hci_skb_pkt_type(skb),\n\t\t\t\t      skb->data, skb->len);\n\t\tif (nskb) {\n\t\t\t__skb_queue_tail(&h5->unack, skb);\n\t\t\tmod_timer(&h5->timer, jiffies + H5_ACK_TIMEOUT);\n\t\t\tspin_unlock_irqrestore(&h5->unack.lock, flags);\n\t\t\treturn nskb;\n\t\t}\n\n\t\tskb_queue_head(&h5->rel, skb);\n\t\tbt_dev_err(hu->hdev, \"Could not dequeue pkt because alloc_skb failed\");\n\t}\n\nunlock:\n\tspin_unlock_irqrestore(&h5->unack.lock, flags);\n\n\tif (test_bit(H5_TX_ACK_REQ, &h5->flags))\n\t\treturn h5_prepare_pkt(hu, HCI_3WIRE_ACK_PKT, NULL, 0);\n\n\treturn NULL;\n}\n\nstatic int h5_flush(struct hci_uart *hu)\n{\n\tBT_DBG(\"hu %p\", hu);\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto h5p = {\n\t.id\t\t= HCI_UART_3WIRE,\n\t.name\t\t= \"Three-wire (H5)\",\n\t.open\t\t= h5_open,\n\t.close\t\t= h5_close,\n\t.setup\t\t= h5_setup,\n\t.recv\t\t= h5_recv,\n\t.enqueue\t= h5_enqueue,\n\t.dequeue\t= h5_dequeue,\n\t.flush\t\t= h5_flush,\n};\n\nstatic int h5_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct device *dev = &serdev->dev;\n\tstruct h5 *h5;\n\tconst struct h5_device_data *data;\n\n\th5 = devm_kzalloc(dev, sizeof(*h5), GFP_KERNEL);\n\tif (!h5)\n\t\treturn -ENOMEM;\n\n\th5->hu = &h5->serdev_hu;\n\th5->serdev_hu.serdev = serdev;\n\tserdev_device_set_drvdata(serdev, h5);\n\n\tif (has_acpi_companion(dev)) {\n\t\tconst struct acpi_device_id *match;\n\n\t\tmatch = acpi_match_device(dev->driver->acpi_match_table, dev);\n\t\tif (!match)\n\t\t\treturn -ENODEV;\n\n\t\tdata = (const struct h5_device_data *)match->driver_data;\n\t\th5->vnd = data->vnd;\n\t\th5->id  = (char *)match->id;\n\n\t\tif (h5->vnd->acpi_gpio_map)\n\t\t\tdevm_acpi_dev_add_driver_gpios(dev,\n\t\t\t\t\t\t       h5->vnd->acpi_gpio_map);\n\t} else {\n\t\tdata = of_device_get_match_data(dev);\n\t\tif (!data)\n\t\t\treturn -ENODEV;\n\n\t\th5->vnd = data->vnd;\n\t}\n\n\tif (data->driver_info & H5_INFO_WAKEUP_DISABLE)\n\t\tset_bit(H5_WAKEUP_DISABLE, &h5->flags);\n\n\th5->enable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(h5->enable_gpio))\n\t\treturn PTR_ERR(h5->enable_gpio);\n\n\th5->device_wake_gpio = devm_gpiod_get_optional(dev, \"device-wake\",\n\t\t\t\t\t\t       GPIOD_OUT_LOW);\n\tif (IS_ERR(h5->device_wake_gpio))\n\t\treturn PTR_ERR(h5->device_wake_gpio);\n\n\treturn hci_uart_register_device(&h5->serdev_hu, &h5p);\n}\n\nstatic void h5_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct h5 *h5 = serdev_device_get_drvdata(serdev);\n\n\thci_uart_unregister_device(&h5->serdev_hu);\n}\n\nstatic int __maybe_unused h5_serdev_suspend(struct device *dev)\n{\n\tstruct h5 *h5 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (h5->vnd && h5->vnd->suspend)\n\t\tret = h5->vnd->suspend(h5);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused h5_serdev_resume(struct device *dev)\n{\n\tstruct h5 *h5 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (h5->vnd && h5->vnd->resume)\n\t\tret = h5->vnd->resume(h5);\n\n\treturn ret;\n}\n\n#ifdef CONFIG_BT_HCIUART_RTL\nstatic int h5_btrtl_setup(struct h5 *h5)\n{\n\tstruct btrtl_device_info *btrtl_dev;\n\tstruct sk_buff *skb;\n\t__le32 baudrate_data;\n\tu32 device_baudrate;\n\tunsigned int controller_baudrate;\n\tbool flow_control;\n\tint err;\n\n\tbtrtl_dev = btrtl_initialize(h5->hu->hdev, h5->id);\n\tif (IS_ERR(btrtl_dev))\n\t\treturn PTR_ERR(btrtl_dev);\n\n\terr = btrtl_get_uart_settings(h5->hu->hdev, btrtl_dev,\n\t\t\t\t      &controller_baudrate, &device_baudrate,\n\t\t\t\t      &flow_control);\n\tif (err)\n\t\tgoto out_free;\n\n\tbaudrate_data = cpu_to_le32(device_baudrate);\n\tskb = __hci_cmd_sync(h5->hu->hdev, 0xfc17, sizeof(baudrate_data),\n\t\t\t     &baudrate_data, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\trtl_dev_err(h5->hu->hdev, \"set baud rate command failed\\n\");\n\t\terr = PTR_ERR(skb);\n\t\tgoto out_free;\n\t} else {\n\t\tkfree_skb(skb);\n\t}\n\t \n\tusleep_range(10000, 20000);\n\n\tserdev_device_set_baudrate(h5->hu->serdev, controller_baudrate);\n\tserdev_device_set_flow_control(h5->hu->serdev, flow_control);\n\n\tif (flow_control)\n\t\tset_bit(H5_HW_FLOW_CONTROL, &h5->flags);\n\n\terr = btrtl_download_firmware(h5->hu->hdev, btrtl_dev);\n\t \n\tusleep_range(10000, 20000);\n\tif (err)\n\t\tgoto out_free;\n\n\tbtrtl_set_quirks(h5->hu->hdev, btrtl_dev);\n\nout_free:\n\tbtrtl_free(btrtl_dev);\n\n\treturn err;\n}\n\nstatic void h5_btrtl_open(struct h5 *h5)\n{\n\t \n\tif (test_bit(H5_WAKEUP_DISABLE, &h5->flags))\n\t\tset_bit(HCI_UART_NO_SUSPEND_NOTIFIER, &h5->hu->flags);\n\n\t \n\tserdev_device_set_flow_control(h5->hu->serdev, false);\n\tserdev_device_set_parity(h5->hu->serdev, SERDEV_PARITY_EVEN);\n\tserdev_device_set_baudrate(h5->hu->serdev, 115200);\n\n\tif (!test_bit(H5_WAKEUP_DISABLE, &h5->flags)) {\n\t\tpm_runtime_set_active(&h5->hu->serdev->dev);\n\t\tpm_runtime_use_autosuspend(&h5->hu->serdev->dev);\n\t\tpm_runtime_set_autosuspend_delay(&h5->hu->serdev->dev,\n\t\t\t\t\t\t SUSPEND_TIMEOUT_MS);\n\t\tpm_runtime_enable(&h5->hu->serdev->dev);\n\t}\n\n\t \n\tgpiod_set_value_cansleep(h5->enable_gpio, 0);\n\tgpiod_set_value_cansleep(h5->device_wake_gpio, 0);\n\tmsleep(100);\n\n\t \n\tgpiod_set_value_cansleep(h5->enable_gpio, 1);\n\tgpiod_set_value_cansleep(h5->device_wake_gpio, 1);\n\tmsleep(500);\n}\n\nstatic void h5_btrtl_close(struct h5 *h5)\n{\n\tif (!test_bit(H5_WAKEUP_DISABLE, &h5->flags))\n\t\tpm_runtime_disable(&h5->hu->serdev->dev);\n\n\tgpiod_set_value_cansleep(h5->device_wake_gpio, 0);\n\tgpiod_set_value_cansleep(h5->enable_gpio, 0);\n}\n\n \nstatic int h5_btrtl_suspend(struct h5 *h5)\n{\n\tserdev_device_set_flow_control(h5->hu->serdev, false);\n\tgpiod_set_value_cansleep(h5->device_wake_gpio, 0);\n\n\tif (test_bit(H5_WAKEUP_DISABLE, &h5->flags))\n\t\tgpiod_set_value_cansleep(h5->enable_gpio, 0);\n\n\treturn 0;\n}\n\nstruct h5_btrtl_reprobe {\n\tstruct device *dev;\n\tstruct work_struct work;\n};\n\nstatic void h5_btrtl_reprobe_worker(struct work_struct *work)\n{\n\tstruct h5_btrtl_reprobe *reprobe =\n\t\tcontainer_of(work, struct h5_btrtl_reprobe, work);\n\tint ret;\n\n\tret = device_reprobe(reprobe->dev);\n\tif (ret && ret != -EPROBE_DEFER)\n\t\tdev_err(reprobe->dev, \"Reprobe error %d\\n\", ret);\n\n\tput_device(reprobe->dev);\n\tkfree(reprobe);\n\tmodule_put(THIS_MODULE);\n}\n\nstatic int h5_btrtl_resume(struct h5 *h5)\n{\n\tif (test_bit(H5_WAKEUP_DISABLE, &h5->flags)) {\n\t\tstruct h5_btrtl_reprobe *reprobe;\n\n\t\treprobe = kzalloc(sizeof(*reprobe), GFP_KERNEL);\n\t\tif (!reprobe)\n\t\t\treturn -ENOMEM;\n\n\t\t__module_get(THIS_MODULE);\n\n\t\tINIT_WORK(&reprobe->work, h5_btrtl_reprobe_worker);\n\t\treprobe->dev = get_device(&h5->hu->serdev->dev);\n\t\tqueue_work(system_long_wq, &reprobe->work);\n\t} else {\n\t\tgpiod_set_value_cansleep(h5->device_wake_gpio, 1);\n\n\t\tif (test_bit(H5_HW_FLOW_CONTROL, &h5->flags))\n\t\t\tserdev_device_set_flow_control(h5->hu->serdev, true);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct acpi_gpio_params btrtl_device_wake_gpios = { 0, 0, false };\nstatic const struct acpi_gpio_params btrtl_enable_gpios = { 1, 0, false };\nstatic const struct acpi_gpio_params btrtl_host_wake_gpios = { 2, 0, false };\nstatic const struct acpi_gpio_mapping acpi_btrtl_gpios[] = {\n\t{ \"device-wake-gpios\", &btrtl_device_wake_gpios, 1 },\n\t{ \"enable-gpios\", &btrtl_enable_gpios, 1 },\n\t{ \"host-wake-gpios\", &btrtl_host_wake_gpios, 1 },\n\t{},\n};\n\nstatic struct h5_vnd rtl_vnd = {\n\t.setup\t\t= h5_btrtl_setup,\n\t.open\t\t= h5_btrtl_open,\n\t.close\t\t= h5_btrtl_close,\n\t.suspend\t= h5_btrtl_suspend,\n\t.resume\t\t= h5_btrtl_resume,\n\t.acpi_gpio_map\t= acpi_btrtl_gpios,\n};\n\nstatic const struct h5_device_data h5_data_rtl8822cs = {\n\t.vnd = &rtl_vnd,\n};\n\nstatic const struct h5_device_data h5_data_rtl8723bs = {\n\t.driver_info = H5_INFO_WAKEUP_DISABLE,\n\t.vnd = &rtl_vnd,\n};\n#endif\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id h5_acpi_match[] = {\n#ifdef CONFIG_BT_HCIUART_RTL\n\t{ \"OBDA0623\", (kernel_ulong_t)&h5_data_rtl8723bs },\n\t{ \"OBDA8723\", (kernel_ulong_t)&h5_data_rtl8723bs },\n#endif\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, h5_acpi_match);\n#endif\n\nstatic const struct dev_pm_ops h5_serdev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(h5_serdev_suspend, h5_serdev_resume)\n\tSET_RUNTIME_PM_OPS(h5_serdev_suspend, h5_serdev_resume, NULL)\n};\n\nstatic const struct of_device_id rtl_bluetooth_of_match[] = {\n#ifdef CONFIG_BT_HCIUART_RTL\n\t{ .compatible = \"realtek,rtl8822cs-bt\",\n\t  .data = (const void *)&h5_data_rtl8822cs },\n\t{ .compatible = \"realtek,rtl8723bs-bt\",\n\t  .data = (const void *)&h5_data_rtl8723bs },\n\t{ .compatible = \"realtek,rtl8723cs-bt\",\n\t  .data = (const void *)&h5_data_rtl8723bs },\n\t{ .compatible = \"realtek,rtl8723ds-bt\",\n\t  .data = (const void *)&h5_data_rtl8723bs },\n#endif\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, rtl_bluetooth_of_match);\n\nstatic struct serdev_device_driver h5_serdev_driver = {\n\t.probe = h5_serdev_probe,\n\t.remove = h5_serdev_remove,\n\t.driver = {\n\t\t.name = \"hci_uart_h5\",\n\t\t.acpi_match_table = ACPI_PTR(h5_acpi_match),\n\t\t.pm = &h5_serdev_pm_ops,\n\t\t.of_match_table = rtl_bluetooth_of_match,\n\t},\n};\n\nint __init h5_init(void)\n{\n\tserdev_device_driver_register(&h5_serdev_driver);\n\treturn hci_uart_register_proto(&h5p);\n}\n\nint __exit h5_deinit(void)\n{\n\tserdev_device_driver_unregister(&h5_serdev_driver);\n\treturn hci_uart_unregister_proto(&h5p);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}