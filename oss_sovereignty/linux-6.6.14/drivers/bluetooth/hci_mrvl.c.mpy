{
  "module_name": "hci_mrvl.c",
  "hash_id": "b71acea0dd1c87193e1f45491bb47cb8864c6d4653e50744eebc8c132b1e4acf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_mrvl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/tty.h>\n#include <linux/of.h>\n#include <linux/serdev.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n\n#define HCI_FW_REQ_PKT 0xA5\n#define HCI_CHIP_VER_PKT 0xAA\n\n#define MRVL_ACK 0x5A\n#define MRVL_NAK 0xBF\n#define MRVL_RAW_DATA 0x1F\n#define MRVL_SET_BAUDRATE 0xFC09\n\nenum {\n\tSTATE_CHIP_VER_PENDING,\n\tSTATE_FW_REQ_PENDING,\n\tSTATE_FW_LOADED,\n};\n\nstruct mrvl_data {\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tstruct sk_buff_head rawq;\n\tunsigned long flags;\n\tunsigned int tx_len;\n\tu8 id, rev;\n};\n\nstruct mrvl_serdev {\n\tstruct hci_uart hu;\n};\n\nstruct hci_mrvl_pkt {\n\t__le16 lhs;\n\t__le16 rhs;\n} __packed;\n#define HCI_MRVL_PKT_SIZE 4\n\nstatic int mrvl_open(struct hci_uart *hu)\n{\n\tstruct mrvl_data *mrvl;\n\tint ret;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tmrvl = kzalloc(sizeof(*mrvl), GFP_KERNEL);\n\tif (!mrvl)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&mrvl->txq);\n\tskb_queue_head_init(&mrvl->rawq);\n\n\tset_bit(STATE_CHIP_VER_PENDING, &mrvl->flags);\n\n\thu->priv = mrvl;\n\n\tif (hu->serdev) {\n\t\tret = serdev_device_open(hu->serdev);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tkfree(mrvl);\n\n\treturn ret;\n}\n\nstatic int mrvl_close(struct hci_uart *hu)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tif (hu->serdev)\n\t\tserdev_device_close(hu->serdev);\n\n\tskb_queue_purge(&mrvl->txq);\n\tskb_queue_purge(&mrvl->rawq);\n\tkfree_skb(mrvl->rx_skb);\n\tkfree(mrvl);\n\n\thu->priv = NULL;\n\treturn 0;\n}\n\nstatic int mrvl_flush(struct hci_uart *hu)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&mrvl->txq);\n\tskb_queue_purge(&mrvl->rawq);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *mrvl_dequeue(struct hci_uart *hu)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\tstruct sk_buff *skb;\n\n\tskb = skb_dequeue(&mrvl->txq);\n\tif (!skb) {\n\t\t \n\t\tskb = skb_dequeue(&mrvl->rawq);\n\t} else {\n\t\t \n\t\tmemcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);\n\t}\n\n\treturn skb;\n}\n\nstatic int mrvl_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\n\tskb_queue_tail(&mrvl->txq, skb);\n\treturn 0;\n}\n\nstatic void mrvl_send_ack(struct hci_uart *hu, unsigned char type)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\tstruct sk_buff *skb;\n\n\t \n\tskb = bt_skb_alloc(0, GFP_ATOMIC);\n\tif (!skb) {\n\t\tbt_dev_err(hu->hdev, \"Unable to alloc ack/nak packet\");\n\t\treturn;\n\t}\n\thci_skb_pkt_type(skb) = type;\n\n\tskb_queue_tail(&mrvl->txq, skb);\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic int mrvl_recv_fw_req(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_mrvl_pkt *pkt = (void *)skb->data;\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct mrvl_data *mrvl = hu->priv;\n\tint ret = 0;\n\n\tif ((pkt->lhs ^ pkt->rhs) != 0xffff) {\n\t\tbt_dev_err(hdev, \"Corrupted mrvl header\");\n\t\tmrvl_send_ack(hu, MRVL_NAK);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tmrvl_send_ack(hu, MRVL_ACK);\n\n\tif (!test_bit(STATE_FW_REQ_PENDING, &mrvl->flags)) {\n\t\tbt_dev_err(hdev, \"Received unexpected firmware request\");\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmrvl->tx_len = le16_to_cpu(pkt->lhs);\n\n\tclear_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&mrvl->flags, STATE_FW_REQ_PENDING);\n\ndone:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int mrvl_recv_chip_ver(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_mrvl_pkt *pkt = (void *)skb->data;\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct mrvl_data *mrvl = hu->priv;\n\tu16 version = le16_to_cpu(pkt->lhs);\n\tint ret = 0;\n\n\tif ((pkt->lhs ^ pkt->rhs) != 0xffff) {\n\t\tbt_dev_err(hdev, \"Corrupted mrvl header\");\n\t\tmrvl_send_ack(hu, MRVL_NAK);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tmrvl_send_ack(hu, MRVL_ACK);\n\n\tif (!test_bit(STATE_CHIP_VER_PENDING, &mrvl->flags)) {\n\t\tbt_dev_err(hdev, \"Received unexpected chip version\");\n\t\tgoto done;\n\t}\n\n\tmrvl->id = version;\n\tmrvl->rev = version >> 8;\n\n\tbt_dev_info(hdev, \"Controller id = %x, rev = %x\", mrvl->id, mrvl->rev);\n\n\tclear_bit(STATE_CHIP_VER_PENDING, &mrvl->flags);\n\tsmp_mb__after_atomic();\n\twake_up_bit(&mrvl->flags, STATE_CHIP_VER_PENDING);\n\ndone:\n\tkfree_skb(skb);\n\treturn ret;\n}\n\n#define HCI_RECV_CHIP_VER \\\n\t.type = HCI_CHIP_VER_PKT, \\\n\t.hlen = HCI_MRVL_PKT_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MRVL_PKT_SIZE\n\n#define HCI_RECV_FW_REQ \\\n\t.type = HCI_FW_REQ_PKT, \\\n\t.hlen = HCI_MRVL_PKT_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = HCI_MRVL_PKT_SIZE\n\nstatic const struct h4_recv_pkt mrvl_recv_pkts[] = {\n\t{ H4_RECV_ACL,       .recv = hci_recv_frame     },\n\t{ H4_RECV_SCO,       .recv = hci_recv_frame     },\n\t{ H4_RECV_EVENT,     .recv = hci_recv_frame     },\n\t{ HCI_RECV_FW_REQ,   .recv = mrvl_recv_fw_req   },\n\t{ HCI_RECV_CHIP_VER, .recv = mrvl_recv_chip_ver },\n};\n\nstatic int mrvl_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct mrvl_data *mrvl = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\t \n\tif (!test_bit(STATE_FW_REQ_PENDING, &mrvl->flags) &&\n\t\t\t\t!test_bit(STATE_FW_LOADED, &mrvl->flags))\n\t\treturn count;\n\n\tmrvl->rx_skb = h4_recv_buf(hu->hdev, mrvl->rx_skb, data, count,\n\t\t\t\t    mrvl_recv_pkts,\n\t\t\t\t    ARRAY_SIZE(mrvl_recv_pkts));\n\tif (IS_ERR(mrvl->rx_skb)) {\n\t\tint err = PTR_ERR(mrvl->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tmrvl->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic int mrvl_load_firmware(struct hci_dev *hdev, const char *name)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct mrvl_data *mrvl = hu->priv;\n\tconst struct firmware *fw = NULL;\n\tconst u8 *fw_ptr, *fw_max;\n\tint err;\n\n\terr = request_firmware(&fw, name, &hdev->dev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"Failed to load firmware file %s\", name);\n\t\treturn err;\n\t}\n\n\tfw_ptr = fw->data;\n\tfw_max = fw->data + fw->size;\n\n\tbt_dev_info(hdev, \"Loading %s\", name);\n\n\tset_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\n\n\twhile (fw_ptr <= fw_max) {\n\t\tstruct sk_buff *skb;\n\n\t\t \n\t\terr = wait_on_bit_timeout(&mrvl->flags, STATE_FW_REQ_PENDING,\n\t\t\t\t\t  TASK_INTERRUPTIBLE,\n\t\t\t\t\t  msecs_to_jiffies(2000));\n\t\tif (err == 1) {\n\t\t\tbt_dev_err(hdev, \"Firmware load interrupted\");\n\t\t\terr = -EINTR;\n\t\t\tbreak;\n\t\t} else if (err) {\n\t\t\tbt_dev_err(hdev, \"Firmware request timeout\");\n\t\t\terr = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\n\t\tbt_dev_dbg(hdev, \"Firmware request, expecting %d bytes\",\n\t\t\t   mrvl->tx_len);\n\n\t\tif (fw_ptr == fw_max) {\n\t\t\t \n\t\t\tif (!mrvl->tx_len) {\n\t\t\t\tbt_dev_info(hdev, \"Firmware loading complete\");\n\t\t\t} else {\n\t\t\t\tbt_dev_err(hdev, \"Firmware loading failure\");\n\t\t\t\terr = -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tif (fw_ptr + mrvl->tx_len > fw_max) {\n\t\t\tmrvl->tx_len = fw_max - fw_ptr;\n\t\t\tbt_dev_dbg(hdev, \"Adjusting tx_len to %d\",\n\t\t\t\t   mrvl->tx_len);\n\t\t}\n\n\t\tskb = bt_skb_alloc(mrvl->tx_len, GFP_KERNEL);\n\t\tif (!skb) {\n\t\t\tbt_dev_err(hdev, \"Failed to alloc mem for FW packet\");\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tbt_cb(skb)->pkt_type = MRVL_RAW_DATA;\n\n\t\tskb_put_data(skb, fw_ptr, mrvl->tx_len);\n\t\tfw_ptr += mrvl->tx_len;\n\n\t\tset_bit(STATE_FW_REQ_PENDING, &mrvl->flags);\n\n\t\tskb_queue_tail(&mrvl->rawq, skb);\n\t\thci_uart_tx_wakeup(hu);\n\t}\n\n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int mrvl_setup(struct hci_uart *hu)\n{\n\tint err;\n\tstruct mrvl_data *mrvl = hu->priv;\n\n\thci_uart_set_flow_control(hu, true);\n\n\terr = mrvl_load_firmware(hu->hdev, \"mrvl/helper_uart_3000000.bin\");\n\tif (err) {\n\t\tbt_dev_err(hu->hdev, \"Unable to download firmware helper\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\thci_uart_wait_until_sent(hu);\n\n\tif (hu->serdev)\n\t\tserdev_device_set_baudrate(hu->serdev, hu->oper_speed);\n\telse\n\t\thci_uart_set_baudrate(hu, hu->oper_speed);\n\n\thci_uart_set_flow_control(hu, false);\n\n\terr = mrvl_load_firmware(hu->hdev, \"mrvl/uart8897_bt.bin\");\n\tif (err)\n\t\treturn err;\n\n\tset_bit(STATE_FW_LOADED, &mrvl->flags);\n\n\treturn 0;\n}\n\nstatic int mrvl_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tint err;\n\tstruct mrvl_data *mrvl = hu->priv;\n\t__le32 speed_le = cpu_to_le32(speed);\n\n\t \n\terr = serdev_device_wait_for_cts(hu->serdev, true, 10000);\n\tif (err) {\n\t\tbt_dev_err(hu->hdev, \"Wait for CTS failed with %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tset_bit(STATE_FW_LOADED, &mrvl->flags);\n\n\terr = __hci_cmd_sync_status(hu->hdev, MRVL_SET_BAUDRATE,\n\t\t\t\t    sizeof(speed_le), &speed_le,\n\t\t\t\t    HCI_INIT_TIMEOUT);\n\tif (err) {\n\t\tbt_dev_err(hu->hdev, \"send command failed: %d\", err);\n\t\treturn err;\n\t}\n\n\tserdev_device_set_baudrate(hu->serdev, speed);\n\n\t \n\tset_bit(HCI_UART_VND_DETECT, &hu->hdev_flags);\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto mrvl_proto_8897 = {\n\t.id\t\t= HCI_UART_MRVL,\n\t.name\t\t= \"Marvell\",\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= mrvl_open,\n\t.close\t\t= mrvl_close,\n\t.flush\t\t= mrvl_flush,\n\t.setup\t\t= mrvl_setup,\n\t.recv\t\t= mrvl_recv,\n\t.enqueue\t= mrvl_enqueue,\n\t.dequeue\t= mrvl_dequeue,\n};\n\nstatic const struct hci_uart_proto mrvl_proto_8997 = {\n\t.id\t\t= HCI_UART_MRVL,\n\t.name\t\t= \"Marvell 8997\",\n\t.init_speed\t= 115200,\n\t.oper_speed\t= 3000000,\n\t.open\t\t= mrvl_open,\n\t.close\t\t= mrvl_close,\n\t.flush\t\t= mrvl_flush,\n\t.set_baudrate   = mrvl_set_baudrate,\n\t.recv\t\t= mrvl_recv,\n\t.enqueue\t= mrvl_enqueue,\n\t.dequeue\t= mrvl_dequeue,\n};\n\nstatic int mrvl_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct mrvl_serdev *mrvldev;\n\tconst struct hci_uart_proto *mrvl_proto = device_get_match_data(&serdev->dev);\n\n\tmrvldev = devm_kzalloc(&serdev->dev, sizeof(*mrvldev), GFP_KERNEL);\n\tif (!mrvldev)\n\t\treturn -ENOMEM;\n\n\tmrvldev->hu.oper_speed = mrvl_proto->oper_speed;\n\tif (mrvl_proto->set_baudrate)\n\t\tof_property_read_u32(serdev->dev.of_node, \"max-speed\", &mrvldev->hu.oper_speed);\n\n\tmrvldev->hu.serdev = serdev;\n\tserdev_device_set_drvdata(serdev, mrvldev);\n\n\treturn hci_uart_register_device(&mrvldev->hu, mrvl_proto);\n}\n\nstatic void mrvl_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct mrvl_serdev *mrvldev = serdev_device_get_drvdata(serdev);\n\n\thci_uart_unregister_device(&mrvldev->hu);\n}\n\nstatic const struct of_device_id __maybe_unused mrvl_bluetooth_of_match[] = {\n\t{ .compatible = \"mrvl,88w8897\", .data = &mrvl_proto_8897},\n\t{ .compatible = \"mrvl,88w8997\", .data = &mrvl_proto_8997},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mrvl_bluetooth_of_match);\n\nstatic struct serdev_device_driver mrvl_serdev_driver = {\n\t.probe = mrvl_serdev_probe,\n\t.remove = mrvl_serdev_remove,\n\t.driver = {\n\t\t.name = \"hci_uart_mrvl\",\n\t\t.of_match_table = of_match_ptr(mrvl_bluetooth_of_match),\n\t},\n};\n\nint __init mrvl_init(void)\n{\n\tserdev_device_driver_register(&mrvl_serdev_driver);\n\n\treturn hci_uart_register_proto(&mrvl_proto_8897);\n}\n\nint __exit mrvl_deinit(void)\n{\n\tserdev_device_driver_unregister(&mrvl_serdev_driver);\n\n\treturn hci_uart_unregister_proto(&mrvl_proto_8897);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}