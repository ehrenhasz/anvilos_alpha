{
  "module_name": "hci_bcm4377.c",
  "hash_id": "4b07718ef5d2b0857d57208390041d4eb7c5d1c496e52c3b7a972b395c3e2d4c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_bcm4377.c",
  "human_readable_source": "\n \n\n#include <linux/async.h>\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmi.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/of.h>\n#include <linux/pci.h>\n#include <linux/printk.h>\n\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\nenum bcm4377_chip {\n\tBCM4377 = 0,\n\tBCM4378,\n\tBCM4387,\n};\n\n#define BCM4377_DEVICE_ID 0x5fa0\n#define BCM4378_DEVICE_ID 0x5f69\n#define BCM4387_DEVICE_ID 0x5f71\n\n#define BCM4377_TIMEOUT 1000\n\n \n#define BCM4377_DMA_MASK 0xfffffe00\n\n#define BCM4377_PCIECFG_BAR0_WINDOW1\t   0x80\n#define BCM4377_PCIECFG_BAR0_WINDOW2\t   0x70\n#define BCM4377_PCIECFG_BAR0_CORE2_WINDOW1 0x74\n#define BCM4377_PCIECFG_BAR0_CORE2_WINDOW2 0x78\n#define BCM4377_PCIECFG_BAR2_WINDOW\t   0x84\n\n#define BCM4377_PCIECFG_BAR0_CORE2_WINDOW1_DEFAULT 0x18011000\n#define BCM4377_PCIECFG_BAR2_WINDOW_DEFAULT\t   0x19000000\n\n#define BCM4377_PCIECFG_SUBSYSTEM_CTRL 0x88\n\n#define BCM4377_BAR0_FW_DOORBELL 0x140\n#define BCM4377_BAR0_RTI_CONTROL 0x144\n\n#define BCM4377_BAR0_SLEEP_CONTROL\t      0x150\n#define BCM4377_BAR0_SLEEP_CONTROL_UNQUIESCE  0\n#define BCM4377_BAR0_SLEEP_CONTROL_AWAKE      2\n#define BCM4377_BAR0_SLEEP_CONTROL_QUIESCE    3\n\n#define BCM4377_BAR0_DOORBELL\t    0x174\n#define BCM4377_BAR0_DOORBELL_VALUE GENMASK(31, 16)\n#define BCM4377_BAR0_DOORBELL_IDX   GENMASK(15, 8)\n#define BCM4377_BAR0_DOORBELL_RING  BIT(5)\n\n#define BCM4377_BAR0_HOST_WINDOW_LO   0x590\n#define BCM4377_BAR0_HOST_WINDOW_HI   0x594\n#define BCM4377_BAR0_HOST_WINDOW_SIZE 0x598\n\n#define BCM4377_BAR2_BOOTSTAGE 0x200454\n\n#define BCM4377_BAR2_FW_LO   0x200478\n#define BCM4377_BAR2_FW_HI   0x20047c\n#define BCM4377_BAR2_FW_SIZE 0x200480\n\n#define BCM4377_BAR2_CONTEXT_ADDR_LO 0x20048c\n#define BCM4377_BAR2_CONTEXT_ADDR_HI 0x200450\n\n#define BCM4377_BAR2_RTI_STATUS\t     0x20045c\n#define BCM4377_BAR2_RTI_WINDOW_LO   0x200494\n#define BCM4377_BAR2_RTI_WINDOW_HI   0x200498\n#define BCM4377_BAR2_RTI_WINDOW_SIZE 0x20049c\n\n#define BCM4377_OTP_SIZE\t  0xe0\n#define BCM4377_OTP_SYS_VENDOR\t  0x15\n#define BCM4377_OTP_CIS\t\t  0x80\n#define BCM4377_OTP_VENDOR_HDR\t  0x00000008\n#define BCM4377_OTP_MAX_PARAM_LEN 16\n\n#define BCM4377_N_TRANSFER_RINGS   9\n#define BCM4377_N_COMPLETION_RINGS 6\n\n#define BCM4377_MAX_RING_SIZE 256\n\n#define BCM4377_MSGID_GENERATION GENMASK(15, 8)\n#define BCM4377_MSGID_ID\t GENMASK(7, 0)\n\n#define BCM4377_RING_N_ENTRIES 128\n\n#define BCM4377_CONTROL_MSG_SIZE\t\t   0x34\n#define BCM4377_XFER_RING_MAX_INPLACE_PAYLOAD_SIZE (4 * 0xff)\n\n#define MAX_ACL_PAYLOAD_SIZE   (HCI_MAX_FRAME_SIZE + HCI_ACL_HDR_SIZE)\n#define MAX_SCO_PAYLOAD_SIZE   (HCI_MAX_SCO_SIZE + HCI_SCO_HDR_SIZE)\n#define MAX_EVENT_PAYLOAD_SIZE (HCI_MAX_EVENT_SIZE + HCI_EVENT_HDR_SIZE)\n\nenum bcm4377_otp_params_type {\n\tBCM4377_OTP_BOARD_PARAMS,\n\tBCM4377_OTP_CHIP_PARAMS\n};\n\nenum bcm4377_transfer_ring_id {\n\tBCM4377_XFER_RING_CONTROL = 0,\n\tBCM4377_XFER_RING_HCI_H2D = 1,\n\tBCM4377_XFER_RING_HCI_D2H = 2,\n\tBCM4377_XFER_RING_SCO_H2D = 3,\n\tBCM4377_XFER_RING_SCO_D2H = 4,\n\tBCM4377_XFER_RING_ACL_H2D = 5,\n\tBCM4377_XFER_RING_ACL_D2H = 6,\n};\n\nenum bcm4377_completion_ring_id {\n\tBCM4377_ACK_RING_CONTROL = 0,\n\tBCM4377_ACK_RING_HCI_ACL = 1,\n\tBCM4377_EVENT_RING_HCI_ACL = 2,\n\tBCM4377_ACK_RING_SCO = 3,\n\tBCM4377_EVENT_RING_SCO = 4,\n};\n\nenum bcm4377_doorbell {\n\tBCM4377_DOORBELL_CONTROL = 0,\n\tBCM4377_DOORBELL_HCI_H2D = 1,\n\tBCM4377_DOORBELL_HCI_D2H = 2,\n\tBCM4377_DOORBELL_ACL_H2D = 3,\n\tBCM4377_DOORBELL_ACL_D2H = 4,\n\tBCM4377_DOORBELL_SCO = 6,\n};\n\n \nstruct bcm4377_xfer_ring_entry {\n#define BCM4377_XFER_RING_FLAG_PAYLOAD_MAPPED\t BIT(0)\n#define BCM4377_XFER_RING_FLAG_PAYLOAD_IN_FOOTER BIT(1)\n\tu8 flags;\n\t__le16 len;\n\tu8 _unk0;\n\t__le64 payload;\n\t__le16 id;\n\tu8 _unk1[2];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_xfer_ring_entry) == 0x10);\n\n \nstruct bcm4377_completion_ring_entry {\n\tu8 flags;\n\tu8 _unk0;\n\t__le16 ring_id;\n\t__le16 msg_id;\n\t__le32 len;\n\tu8 _unk1[6];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_completion_ring_entry) == 0x10);\n\nenum bcm4377_control_message_type {\n\tBCM4377_CONTROL_MSG_CREATE_XFER_RING = 1,\n\tBCM4377_CONTROL_MSG_CREATE_COMPLETION_RING = 2,\n\tBCM4377_CONTROL_MSG_DESTROY_XFER_RING = 3,\n\tBCM4377_CONTROL_MSG_DESTROY_COMPLETION_RING = 4,\n};\n\n \nstruct bcm4377_create_completion_ring_msg {\n\tu8 msg_type;\n\tu8 header_size;\n\tu8 footer_size;\n\tu8 _unk0;\n\t__le16 id;\n\t__le16 id_again;\n\t__le64 ring_iova;\n\t__le16 n_elements;\n\t__le32 unk;\n\tu8 _unk1[6];\n\t__le16 msi;\n\t__le16 intmod_delay;\n\t__le32 intmod_bytes;\n\t__le16 _unk2;\n\t__le32 _unk3;\n\tu8 _unk4[10];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_create_completion_ring_msg) ==\n\t      BCM4377_CONTROL_MSG_SIZE);\n\n \nstruct bcm4377_destroy_completion_ring_msg {\n\tu8 msg_type;\n\tu8 _pad0;\n\t__le16 ring_id;\n\tu8 _pad1[48];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_destroy_completion_ring_msg) ==\n\t      BCM4377_CONTROL_MSG_SIZE);\n\n \nstruct bcm4377_create_transfer_ring_msg {\n\tu8 msg_type;\n\tu8 header_size;\n\tu8 footer_size;\n\tu8 _unk0;\n\t__le16 ring_id;\n\t__le16 ring_id_again;\n\t__le64 ring_iova;\n\tu8 _unk1[8];\n\t__le16 n_elements;\n\t__le16 completion_ring_id;\n\t__le16 doorbell;\n#define BCM4377_XFER_RING_FLAG_VIRTUAL BIT(7)\n#define BCM4377_XFER_RING_FLAG_SYNC    BIT(8)\n\t__le16 flags;\n\tu8 _unk2[20];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_create_transfer_ring_msg) ==\n\t      BCM4377_CONTROL_MSG_SIZE);\n\n \nstruct bcm4377_destroy_transfer_ring_msg {\n\tu8 msg_type;\n\tu8 _pad0;\n\t__le16 ring_id;\n\tu8 _pad1[48];\n} __packed;\nstatic_assert(sizeof(struct bcm4377_destroy_transfer_ring_msg) ==\n\t      BCM4377_CONTROL_MSG_SIZE);\n\n \nstruct bcm4377_context {\n\t__le16 version;\n\t__le16 size;\n\t__le32 enabled_caps;\n\n\t__le64 peripheral_info_addr;\n\n\t \n\t__le64 completion_ring_heads_addr;\n\t__le64 xfer_ring_tails_addr;\n\t__le64 completion_ring_tails_addr;\n\t__le64 xfer_ring_heads_addr;\n\t__le16 n_completion_rings;\n\t__le16 n_xfer_rings;\n\n\t \n\t__le64 control_completion_ring_addr;\n\t__le64 control_xfer_ring_addr;\n\t__le16 control_xfer_ring_n_entries;\n\t__le16 control_completion_ring_n_entries;\n\t__le16 control_xfer_ring_doorbell;\n\t__le16 control_completion_ring_doorbell;\n\t__le16 control_xfer_ring_msi;\n\t__le16 control_completion_ring_msi;\n\tu8 control_xfer_ring_header_size;\n\tu8 control_xfer_ring_footer_size;\n\tu8 control_completion_ring_header_size;\n\tu8 control_completion_ring_footer_size;\n\n\t__le16 _unk0;\n\t__le16 _unk1;\n\n\t__le64 scratch_pad;\n\t__le32 scratch_pad_size;\n\n\t__le32 _unk3;\n} __packed;\nstatic_assert(sizeof(struct bcm4377_context) == 0x68);\n\n#define BCM4378_CALIBRATION_CHUNK_SIZE 0xe6\nstruct bcm4378_hci_send_calibration_cmd {\n\tu8 unk;\n\t__le16 blocks_left;\n\tu8 data[BCM4378_CALIBRATION_CHUNK_SIZE];\n} __packed;\n\n#define BCM4378_PTB_CHUNK_SIZE 0xcf\nstruct bcm4378_hci_send_ptb_cmd {\n\t__le16 blocks_left;\n\tu8 data[BCM4378_PTB_CHUNK_SIZE];\n} __packed;\n\n \nstruct bcm4377_ring_state {\n\t__le16 completion_ring_head[BCM4377_N_COMPLETION_RINGS];\n\t__le16 completion_ring_tail[BCM4377_N_COMPLETION_RINGS];\n\t__le16 xfer_ring_head[BCM4377_N_TRANSFER_RINGS];\n\t__le16 xfer_ring_tail[BCM4377_N_TRANSFER_RINGS];\n};\n\n \nstruct bcm4377_transfer_ring {\n\tenum bcm4377_transfer_ring_id ring_id;\n\tenum bcm4377_doorbell doorbell;\n\tsize_t payload_size;\n\tsize_t mapped_payload_size;\n\tu8 completion_ring;\n\tu16 n_entries;\n\tu8 generation;\n\n\tbool sync;\n\tbool virtual;\n\tbool d2h_buffers_only;\n\tbool allow_wait;\n\tbool enabled;\n\n\tvoid *ring;\n\tdma_addr_t ring_dma;\n\n\tvoid *payloads;\n\tdma_addr_t payloads_dma;\n\n\tstruct completion **events;\n\tDECLARE_BITMAP(msgids, BCM4377_MAX_RING_SIZE);\n\tspinlock_t lock;\n};\n\n \nstruct bcm4377_completion_ring {\n\tenum bcm4377_completion_ring_id ring_id;\n\tu16 payload_size;\n\tu16 delay;\n\tu16 n_entries;\n\tbool enabled;\n\n\tvoid *ring;\n\tdma_addr_t ring_dma;\n\n\tunsigned long transfer_rings;\n};\n\nstruct bcm4377_data;\n\n \nstruct bcm4377_hw {\n\tunsigned int id;\n\n\tu32 otp_offset;\n\n\tu32 bar0_window1;\n\tu32 bar0_window2;\n\tu32 bar0_core2_window2;\n\n\tunsigned long has_bar0_core2_window2 : 1;\n\tunsigned long clear_pciecfg_subsystem_ctrl_bit19 : 1;\n\tunsigned long disable_aspm : 1;\n\tunsigned long broken_ext_scan : 1;\n\tunsigned long broken_mws_transport_config : 1;\n\tunsigned long broken_le_coded : 1;\n\n\tint (*send_calibration)(struct bcm4377_data *bcm4377);\n\tint (*send_ptb)(struct bcm4377_data *bcm4377,\n\t\t\tconst struct firmware *fw);\n};\n\nstatic const struct bcm4377_hw bcm4377_hw_variants[];\nstatic const struct dmi_system_id bcm4377_dmi_board_table[];\n\n \nstruct bcm4377_data {\n\tstruct pci_dev *pdev;\n\tstruct hci_dev *hdev;\n\n\tvoid __iomem *bar0;\n\tvoid __iomem *bar2;\n\n\tu32 bootstage;\n\tu32 rti_status;\n\n\tconst struct bcm4377_hw *hw;\n\n\tconst void *taurus_cal_blob;\n\tint taurus_cal_size;\n\tconst void *taurus_beamforming_cal_blob;\n\tint taurus_beamforming_cal_size;\n\n\tchar stepping[BCM4377_OTP_MAX_PARAM_LEN];\n\tchar vendor[BCM4377_OTP_MAX_PARAM_LEN];\n\tconst char *board_type;\n\n\tstruct completion event;\n\n\tstruct bcm4377_context *ctx;\n\tdma_addr_t ctx_dma;\n\n\tstruct bcm4377_ring_state *ring_state;\n\tdma_addr_t ring_state_dma;\n\n\t \n\tstruct bcm4377_completion_ring control_ack_ring;\n\tstruct bcm4377_completion_ring hci_acl_ack_ring;\n\tstruct bcm4377_completion_ring hci_acl_event_ring;\n\tstruct bcm4377_completion_ring sco_ack_ring;\n\tstruct bcm4377_completion_ring sco_event_ring;\n\n\tstruct bcm4377_transfer_ring control_h2d_ring;\n\tstruct bcm4377_transfer_ring hci_h2d_ring;\n\tstruct bcm4377_transfer_ring hci_d2h_ring;\n\tstruct bcm4377_transfer_ring sco_h2d_ring;\n\tstruct bcm4377_transfer_ring sco_d2h_ring;\n\tstruct bcm4377_transfer_ring acl_h2d_ring;\n\tstruct bcm4377_transfer_ring acl_d2h_ring;\n};\n\nstatic void bcm4377_ring_doorbell(struct bcm4377_data *bcm4377, u8 doorbell,\n\t\t\t\t  u16 val)\n{\n\tu32 db = 0;\n\n\tdb |= FIELD_PREP(BCM4377_BAR0_DOORBELL_VALUE, val);\n\tdb |= FIELD_PREP(BCM4377_BAR0_DOORBELL_IDX, doorbell);\n\tdb |= BCM4377_BAR0_DOORBELL_RING;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"write %d to doorbell #%d (0x%x)\\n\", val,\n\t\tdoorbell, db);\n\tiowrite32(db, bcm4377->bar0 + BCM4377_BAR0_DOORBELL);\n}\n\nstatic int bcm4377_extract_msgid(struct bcm4377_data *bcm4377,\n\t\t\t\t struct bcm4377_transfer_ring *ring,\n\t\t\t\t u16 raw_msgid, u8 *msgid)\n{\n\tu8 generation = FIELD_GET(BCM4377_MSGID_GENERATION, raw_msgid);\n\t*msgid = FIELD_GET(BCM4377_MSGID_ID, raw_msgid);\n\n\tif (generation != ring->generation) {\n\t\tdev_warn(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\t\"invalid message generation %d should be %d in entry for ring %d\\n\",\n\t\t\tgeneration, ring->generation, ring->ring_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (*msgid >= ring->n_entries) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"invalid message id in entry for ring %d: %d > %d\\n\",\n\t\t\t ring->ring_id, *msgid, ring->n_entries);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm4377_handle_event(struct bcm4377_data *bcm4377,\n\t\t\t\t struct bcm4377_transfer_ring *ring,\n\t\t\t\t u16 raw_msgid, u8 entry_flags, u8 type,\n\t\t\t\t void *payload, size_t len)\n{\n\tstruct sk_buff *skb;\n\tu16 head;\n\tu8 msgid;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\tif (!ring->enabled) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"event for disabled transfer ring %d\\n\",\n\t\t\t ring->ring_id);\n\t\tgoto out;\n\t}\n\n\tif (ring->d2h_buffers_only &&\n\t    entry_flags & BCM4377_XFER_RING_FLAG_PAYLOAD_MAPPED) {\n\t\tif (bcm4377_extract_msgid(bcm4377, ring, raw_msgid, &msgid))\n\t\t\tgoto out;\n\n\t\tif (len > ring->mapped_payload_size) {\n\t\t\tdev_warn(\n\t\t\t\t&bcm4377->pdev->dev,\n\t\t\t\t\"invalid payload len in event for ring %d: %zu > %zu\\n\",\n\t\t\t\tring->ring_id, len, ring->mapped_payload_size);\n\t\t\tgoto out;\n\t\t}\n\n\t\tpayload = ring->payloads + msgid * ring->mapped_payload_size;\n\t}\n\n\tskb = bt_skb_alloc(len, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tmemcpy(skb_put(skb, len), payload, len);\n\thci_skb_pkt_type(skb) = type;\n\thci_recv_frame(bcm4377->hdev, skb);\n\nout:\n\thead = le16_to_cpu(bcm4377->ring_state->xfer_ring_head[ring->ring_id]);\n\thead = (head + 1) % ring->n_entries;\n\tbcm4377->ring_state->xfer_ring_head[ring->ring_id] = cpu_to_le16(head);\n\n\tbcm4377_ring_doorbell(bcm4377, ring->doorbell, head);\n\n\tspin_unlock_irqrestore(&ring->lock, flags);\n}\n\nstatic void bcm4377_handle_ack(struct bcm4377_data *bcm4377,\n\t\t\t       struct bcm4377_transfer_ring *ring,\n\t\t\t       u16 raw_msgid)\n{\n\tunsigned long flags;\n\tu8 msgid;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\n\tif (bcm4377_extract_msgid(bcm4377, ring, raw_msgid, &msgid))\n\t\tgoto unlock;\n\n\tif (!test_bit(msgid, ring->msgids)) {\n\t\tdev_warn(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\t\"invalid message id in ack for ring %d: %d is not used\\n\",\n\t\t\tring->ring_id, msgid);\n\t\tgoto unlock;\n\t}\n\n\tif (ring->allow_wait && ring->events[msgid]) {\n\t\tcomplete(ring->events[msgid]);\n\t\tring->events[msgid] = NULL;\n\t}\n\n\tbitmap_release_region(ring->msgids, msgid, ring->n_entries);\n\nunlock:\n\tspin_unlock_irqrestore(&ring->lock, flags);\n}\n\nstatic void bcm4377_handle_completion(struct bcm4377_data *bcm4377,\n\t\t\t\t      struct bcm4377_completion_ring *ring,\n\t\t\t\t      u16 pos)\n{\n\tstruct bcm4377_completion_ring_entry *entry;\n\tu16 msg_id, transfer_ring;\n\tsize_t entry_size, data_len;\n\tvoid *data;\n\n\tif (pos >= ring->n_entries) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"invalid offset %d for completion ring %d\\n\", pos,\n\t\t\t ring->ring_id);\n\t\treturn;\n\t}\n\n\tentry_size = sizeof(*entry) + ring->payload_size;\n\tentry = ring->ring + pos * entry_size;\n\tdata = ring->ring + pos * entry_size + sizeof(*entry);\n\tdata_len = le32_to_cpu(entry->len);\n\tmsg_id = le16_to_cpu(entry->msg_id);\n\ttransfer_ring = le16_to_cpu(entry->ring_id);\n\n\tif ((ring->transfer_rings & BIT(transfer_ring)) == 0) {\n\t\tdev_warn(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\t\"invalid entry at offset %d for transfer ring %d in completion ring %d\\n\",\n\t\t\tpos, transfer_ring, ring->ring_id);\n\t\treturn;\n\t}\n\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"entry in completion ring %d for transfer ring %d with msg_id %d\\n\",\n\t\tring->ring_id, transfer_ring, msg_id);\n\n\tswitch (transfer_ring) {\n\tcase BCM4377_XFER_RING_CONTROL:\n\t\tbcm4377_handle_ack(bcm4377, &bcm4377->control_h2d_ring, msg_id);\n\t\tbreak;\n\tcase BCM4377_XFER_RING_HCI_H2D:\n\t\tbcm4377_handle_ack(bcm4377, &bcm4377->hci_h2d_ring, msg_id);\n\t\tbreak;\n\tcase BCM4377_XFER_RING_SCO_H2D:\n\t\tbcm4377_handle_ack(bcm4377, &bcm4377->sco_h2d_ring, msg_id);\n\t\tbreak;\n\tcase BCM4377_XFER_RING_ACL_H2D:\n\t\tbcm4377_handle_ack(bcm4377, &bcm4377->acl_h2d_ring, msg_id);\n\t\tbreak;\n\n\tcase BCM4377_XFER_RING_HCI_D2H:\n\t\tbcm4377_handle_event(bcm4377, &bcm4377->hci_d2h_ring, msg_id,\n\t\t\t\t     entry->flags, HCI_EVENT_PKT, data,\n\t\t\t\t     data_len);\n\t\tbreak;\n\tcase BCM4377_XFER_RING_SCO_D2H:\n\t\tbcm4377_handle_event(bcm4377, &bcm4377->sco_d2h_ring, msg_id,\n\t\t\t\t     entry->flags, HCI_SCODATA_PKT, data,\n\t\t\t\t     data_len);\n\t\tbreak;\n\tcase BCM4377_XFER_RING_ACL_D2H:\n\t\tbcm4377_handle_event(bcm4377, &bcm4377->acl_d2h_ring, msg_id,\n\t\t\t\t     entry->flags, HCI_ACLDATA_PKT, data,\n\t\t\t\t     data_len);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\t\"entry in completion ring %d for unknown transfer ring %d with msg_id %d\\n\",\n\t\t\tring->ring_id, transfer_ring, msg_id);\n\t}\n}\n\nstatic void bcm4377_poll_completion_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\t struct bcm4377_completion_ring *ring)\n{\n\tu16 tail;\n\t__le16 *heads = bcm4377->ring_state->completion_ring_head;\n\t__le16 *tails = bcm4377->ring_state->completion_ring_tail;\n\n\tif (!ring->enabled)\n\t\treturn;\n\n\ttail = le16_to_cpu(tails[ring->ring_id]);\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"completion ring #%d: head: %d, tail: %d\\n\", ring->ring_id,\n\t\tle16_to_cpu(heads[ring->ring_id]), tail);\n\n\twhile (tail != le16_to_cpu(READ_ONCE(heads[ring->ring_id]))) {\n\t\t \n\t\tdma_rmb();\n\n\t\tbcm4377_handle_completion(bcm4377, ring, tail);\n\n\t\ttail = (tail + 1) % ring->n_entries;\n\t\ttails[ring->ring_id] = cpu_to_le16(tail);\n\t}\n}\n\nstatic irqreturn_t bcm4377_irq(int irq, void *data)\n{\n\tstruct bcm4377_data *bcm4377 = data;\n\tu32 bootstage, rti_status;\n\n\tbootstage = ioread32(bcm4377->bar2 + BCM4377_BAR2_BOOTSTAGE);\n\trti_status = ioread32(bcm4377->bar2 + BCM4377_BAR2_RTI_STATUS);\n\n\tif (bootstage != bcm4377->bootstage ||\n\t    rti_status != bcm4377->rti_status) {\n\t\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\t\"bootstage = %d -> %d, rti state = %d -> %d\\n\",\n\t\t\tbcm4377->bootstage, bootstage, bcm4377->rti_status,\n\t\t\trti_status);\n\t\tcomplete(&bcm4377->event);\n\t\tbcm4377->bootstage = bootstage;\n\t\tbcm4377->rti_status = rti_status;\n\t}\n\n\tif (rti_status > 2)\n\t\tdev_err(&bcm4377->pdev->dev, \"RTI status is %d\\n\", rti_status);\n\n\tbcm4377_poll_completion_ring(bcm4377, &bcm4377->control_ack_ring);\n\tbcm4377_poll_completion_ring(bcm4377, &bcm4377->hci_acl_event_ring);\n\tbcm4377_poll_completion_ring(bcm4377, &bcm4377->hci_acl_ack_ring);\n\tbcm4377_poll_completion_ring(bcm4377, &bcm4377->sco_ack_ring);\n\tbcm4377_poll_completion_ring(bcm4377, &bcm4377->sco_event_ring);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm4377_enqueue(struct bcm4377_data *bcm4377,\n\t\t\t   struct bcm4377_transfer_ring *ring, void *data,\n\t\t\t   size_t len, bool wait)\n{\n\tunsigned long flags;\n\tstruct bcm4377_xfer_ring_entry *entry;\n\tvoid *payload;\n\tsize_t offset;\n\tu16 head, tail, new_head;\n\tu16 raw_msgid;\n\tint ret, msgid;\n\tDECLARE_COMPLETION_ONSTACK(event);\n\n\tif (len > ring->payload_size && len > ring->mapped_payload_size) {\n\t\tdev_warn(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\t\"payload len %zu is too large for ring %d (max is %zu or %zu)\\n\",\n\t\t\tlen, ring->ring_id, ring->payload_size,\n\t\t\tring->mapped_payload_size);\n\t\treturn -EINVAL;\n\t}\n\tif (wait && !ring->allow_wait)\n\t\treturn -EINVAL;\n\tif (ring->virtual)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ring->lock, flags);\n\n\thead = le16_to_cpu(bcm4377->ring_state->xfer_ring_head[ring->ring_id]);\n\ttail = le16_to_cpu(bcm4377->ring_state->xfer_ring_tail[ring->ring_id]);\n\n\tnew_head = (head + 1) % ring->n_entries;\n\n\tif (new_head == tail) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"can't send message because ring %d is full\\n\",\n\t\t\t ring->ring_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmsgid = bitmap_find_free_region(ring->msgids, ring->n_entries, 0);\n\tif (msgid < 0) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"can't find message id for ring %d\\n\", ring->ring_id);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\traw_msgid = FIELD_PREP(BCM4377_MSGID_GENERATION, ring->generation);\n\traw_msgid |= FIELD_PREP(BCM4377_MSGID_ID, msgid);\n\n\toffset = head * (sizeof(*entry) + ring->payload_size);\n\tentry = ring->ring + offset;\n\n\tmemset(entry, 0, sizeof(*entry));\n\tentry->id = cpu_to_le16(raw_msgid);\n\tentry->len = cpu_to_le16(len);\n\n\tif (len <= ring->payload_size) {\n\t\tentry->flags = BCM4377_XFER_RING_FLAG_PAYLOAD_IN_FOOTER;\n\t\tpayload = ring->ring + offset + sizeof(*entry);\n\t} else {\n\t\tentry->flags = BCM4377_XFER_RING_FLAG_PAYLOAD_MAPPED;\n\t\tentry->payload = cpu_to_le64(ring->payloads_dma +\n\t\t\t\t\t     msgid * ring->mapped_payload_size);\n\t\tpayload = ring->payloads + msgid * ring->mapped_payload_size;\n\t}\n\n\tmemcpy(payload, data, len);\n\n\tif (wait)\n\t\tring->events[msgid] = &event;\n\n\t \n\tiowrite32(BCM4377_BAR0_SLEEP_CONTROL_AWAKE,\n\t\t  bcm4377->bar0 + BCM4377_BAR0_SLEEP_CONTROL);\n\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"updating head for transfer queue #%d to %d\\n\", ring->ring_id,\n\t\tnew_head);\n\tbcm4377->ring_state->xfer_ring_head[ring->ring_id] =\n\t\tcpu_to_le16(new_head);\n\n\tif (!ring->sync)\n\t\tbcm4377_ring_doorbell(bcm4377, ring->doorbell, new_head);\n\tret = 0;\n\nout:\n\tspin_unlock_irqrestore(&ring->lock, flags);\n\n\tif (ret == 0 && wait) {\n\t\tret = wait_for_completion_interruptible_timeout(\n\t\t\t&event, BCM4377_TIMEOUT);\n\t\tif (ret == 0)\n\t\t\tret = -ETIMEDOUT;\n\t\telse if (ret > 0)\n\t\t\tret = 0;\n\n\t\tspin_lock_irqsave(&ring->lock, flags);\n\t\tring->events[msgid] = NULL;\n\t\tspin_unlock_irqrestore(&ring->lock, flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int bcm4377_create_completion_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\t  struct bcm4377_completion_ring *ring)\n{\n\tstruct bcm4377_create_completion_ring_msg msg;\n\tint ret;\n\n\tif (ring->enabled) {\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"completion ring %d already enabled\\n\", ring->ring_id);\n\t\treturn 0;\n\t}\n\n\tmemset(ring->ring, 0,\n\t       ring->n_entries * (sizeof(struct bcm4377_completion_ring_entry) +\n\t\t\t\t  ring->payload_size));\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_type = BCM4377_CONTROL_MSG_CREATE_COMPLETION_RING;\n\tmsg.id = cpu_to_le16(ring->ring_id);\n\tmsg.id_again = cpu_to_le16(ring->ring_id);\n\tmsg.ring_iova = cpu_to_le64(ring->ring_dma);\n\tmsg.n_elements = cpu_to_le16(ring->n_entries);\n\tmsg.intmod_bytes = cpu_to_le32(0xffffffff);\n\tmsg.unk = cpu_to_le32(0xffffffff);\n\tmsg.intmod_delay = cpu_to_le16(ring->delay);\n\tmsg.footer_size = ring->payload_size / 4;\n\n\tret = bcm4377_enqueue(bcm4377, &bcm4377->control_h2d_ring, &msg,\n\t\t\t      sizeof(msg), true);\n\tif (!ret)\n\t\tring->enabled = true;\n\n\treturn ret;\n}\n\nstatic int bcm4377_destroy_completion_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\t   struct bcm4377_completion_ring *ring)\n{\n\tstruct bcm4377_destroy_completion_ring_msg msg;\n\tint ret;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_type = BCM4377_CONTROL_MSG_DESTROY_COMPLETION_RING;\n\tmsg.ring_id = cpu_to_le16(ring->ring_id);\n\n\tret = bcm4377_enqueue(bcm4377, &bcm4377->control_h2d_ring, &msg,\n\t\t\t      sizeof(msg), true);\n\tif (ret)\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"failed to destroy completion ring %d\\n\",\n\t\t\t ring->ring_id);\n\n\tring->enabled = false;\n\treturn ret;\n}\n\nstatic int bcm4377_create_transfer_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\tstruct bcm4377_transfer_ring *ring)\n{\n\tstruct bcm4377_create_transfer_ring_msg msg;\n\tu16 flags = 0;\n\tint ret, i;\n\tunsigned long spinlock_flags;\n\n\tif (ring->virtual)\n\t\tflags |= BCM4377_XFER_RING_FLAG_VIRTUAL;\n\tif (ring->sync)\n\t\tflags |= BCM4377_XFER_RING_FLAG_SYNC;\n\n\tspin_lock_irqsave(&ring->lock, spinlock_flags);\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_type = BCM4377_CONTROL_MSG_CREATE_XFER_RING;\n\tmsg.ring_id = cpu_to_le16(ring->ring_id);\n\tmsg.ring_id_again = cpu_to_le16(ring->ring_id);\n\tmsg.ring_iova = cpu_to_le64(ring->ring_dma);\n\tmsg.n_elements = cpu_to_le16(ring->n_entries);\n\tmsg.completion_ring_id = cpu_to_le16(ring->completion_ring);\n\tmsg.doorbell = cpu_to_le16(ring->doorbell);\n\tmsg.flags = cpu_to_le16(flags);\n\tmsg.footer_size = ring->payload_size / 4;\n\n\tbcm4377->ring_state->xfer_ring_head[ring->ring_id] = 0;\n\tbcm4377->ring_state->xfer_ring_tail[ring->ring_id] = 0;\n\tring->generation++;\n\tspin_unlock_irqrestore(&ring->lock, spinlock_flags);\n\n\tret = bcm4377_enqueue(bcm4377, &bcm4377->control_h2d_ring, &msg,\n\t\t\t      sizeof(msg), true);\n\n\tspin_lock_irqsave(&ring->lock, spinlock_flags);\n\n\tif (ring->d2h_buffers_only) {\n\t\tfor (i = 0; i < ring->n_entries; ++i) {\n\t\t\tstruct bcm4377_xfer_ring_entry *entry =\n\t\t\t\tring->ring + i * sizeof(*entry);\n\t\t\tu16 raw_msgid = FIELD_PREP(BCM4377_MSGID_GENERATION,\n\t\t\t\t\t\t   ring->generation);\n\t\t\traw_msgid |= FIELD_PREP(BCM4377_MSGID_ID, i);\n\n\t\t\tmemset(entry, 0, sizeof(*entry));\n\t\t\tentry->id = cpu_to_le16(raw_msgid);\n\t\t\tentry->len = cpu_to_le16(ring->mapped_payload_size);\n\t\t\tentry->flags = BCM4377_XFER_RING_FLAG_PAYLOAD_MAPPED;\n\t\t\tentry->payload =\n\t\t\t\tcpu_to_le64(ring->payloads_dma +\n\t\t\t\t\t    i * ring->mapped_payload_size);\n\t\t}\n\t}\n\n\t \n\tif (ring->virtual || ring->d2h_buffers_only) {\n\t\tbcm4377->ring_state->xfer_ring_head[ring->ring_id] =\n\t\t\tcpu_to_le16(0xf);\n\t\tbcm4377_ring_doorbell(bcm4377, ring->doorbell, 0xf);\n\t}\n\n\tring->enabled = true;\n\tspin_unlock_irqrestore(&ring->lock, spinlock_flags);\n\n\treturn ret;\n}\n\nstatic int bcm4377_destroy_transfer_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\t struct bcm4377_transfer_ring *ring)\n{\n\tstruct bcm4377_destroy_transfer_ring_msg msg;\n\tint ret;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.msg_type = BCM4377_CONTROL_MSG_DESTROY_XFER_RING;\n\tmsg.ring_id = cpu_to_le16(ring->ring_id);\n\n\tret = bcm4377_enqueue(bcm4377, &bcm4377->control_h2d_ring, &msg,\n\t\t\t      sizeof(msg), true);\n\tif (ret)\n\t\tdev_warn(&bcm4377->pdev->dev,\n\t\t\t \"failed to destroy transfer ring %d\\n\", ring->ring_id);\n\n\tring->enabled = false;\n\treturn ret;\n}\n\nstatic int __bcm4378_send_calibration_chunk(struct bcm4377_data *bcm4377,\n\t\t\t\t\t    const void *data, size_t data_len,\n\t\t\t\t\t    u16 blocks_left)\n{\n\tstruct bcm4378_hci_send_calibration_cmd cmd;\n\tstruct sk_buff *skb;\n\n\tif (data_len > sizeof(cmd.data))\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.unk = 0x03;\n\tcmd.blocks_left = cpu_to_le16(blocks_left);\n\tmemcpy(cmd.data, data, data_len);\n\n\tskb = __hci_cmd_sync(bcm4377->hdev, 0xfd97, sizeof(cmd), &cmd,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int __bcm4378_send_calibration(struct bcm4377_data *bcm4377,\n\t\t\t\t      const void *data, size_t data_size)\n{\n\tint ret;\n\tsize_t i, left, transfer_len;\n\tsize_t blocks =\n\t\tDIV_ROUND_UP(data_size, (size_t)BCM4378_CALIBRATION_CHUNK_SIZE);\n\n\tif (!data) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"no calibration data available.\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tfor (i = 0, left = data_size; i < blocks; ++i, left -= transfer_len) {\n\t\ttransfer_len =\n\t\t\tmin_t(size_t, left, BCM4378_CALIBRATION_CHUNK_SIZE);\n\n\t\tret = __bcm4378_send_calibration_chunk(\n\t\t\tbcm4377, data + i * BCM4378_CALIBRATION_CHUNK_SIZE,\n\t\t\ttransfer_len, blocks - i - 1);\n\t\tif (ret) {\n\t\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\t\"send calibration chunk failed with %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm4378_send_calibration(struct bcm4377_data *bcm4377)\n{\n\tif ((strcmp(bcm4377->stepping, \"b1\") == 0) ||\n\t    strcmp(bcm4377->stepping, \"b3\") == 0)\n\t\treturn __bcm4378_send_calibration(\n\t\t\tbcm4377, bcm4377->taurus_beamforming_cal_blob,\n\t\t\tbcm4377->taurus_beamforming_cal_size);\n\telse\n\t\treturn __bcm4378_send_calibration(bcm4377,\n\t\t\t\t\t\t  bcm4377->taurus_cal_blob,\n\t\t\t\t\t\t  bcm4377->taurus_cal_size);\n}\n\nstatic int bcm4387_send_calibration(struct bcm4377_data *bcm4377)\n{\n\tif (strcmp(bcm4377->stepping, \"c2\") == 0)\n\t\treturn __bcm4378_send_calibration(\n\t\t\tbcm4377, bcm4377->taurus_beamforming_cal_blob,\n\t\t\tbcm4377->taurus_beamforming_cal_size);\n\telse\n\t\treturn __bcm4378_send_calibration(bcm4377,\n\t\t\t\t\t\t  bcm4377->taurus_cal_blob,\n\t\t\t\t\t\t  bcm4377->taurus_cal_size);\n}\n\nstatic const struct firmware *bcm4377_request_blob(struct bcm4377_data *bcm4377,\n\t\t\t\t\t\t   const char *suffix)\n{\n\tconst struct firmware *fw;\n\tchar name0[64], name1[64];\n\tint ret;\n\n\tsnprintf(name0, sizeof(name0), \"brcm/brcmbt%04x%s-%s-%s.%s\",\n\t\t bcm4377->hw->id, bcm4377->stepping, bcm4377->board_type,\n\t\t bcm4377->vendor, suffix);\n\tsnprintf(name1, sizeof(name1), \"brcm/brcmbt%04x%s-%s.%s\",\n\t\t bcm4377->hw->id, bcm4377->stepping, bcm4377->board_type,\n\t\t suffix);\n\tdev_dbg(&bcm4377->pdev->dev, \"Trying to load firmware: '%s' or '%s'\\n\",\n\t\tname0, name1);\n\n\tret = firmware_request_nowarn(&fw, name0, &bcm4377->pdev->dev);\n\tif (!ret)\n\t\treturn fw;\n\tret = firmware_request_nowarn(&fw, name1, &bcm4377->pdev->dev);\n\tif (!ret)\n\t\treturn fw;\n\n\tdev_err(&bcm4377->pdev->dev,\n\t\t\"Unable to load firmware; tried '%s' and '%s'\\n\", name0, name1);\n\treturn NULL;\n}\n\nstatic int bcm4377_send_ptb(struct bcm4377_data *bcm4377,\n\t\t\t    const struct firmware *fw)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(bcm4377->hdev, 0xfd98, fw->size, fw->data,\n\t\t\t     HCI_INIT_TIMEOUT);\n\t \n\tif (!IS_ERR(skb))\n\t\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int bcm4378_send_ptb_chunk(struct bcm4377_data *bcm4377,\n\t\t\t\t  const void *data, size_t data_len,\n\t\t\t\t  u16 blocks_left)\n{\n\tstruct bcm4378_hci_send_ptb_cmd cmd;\n\tstruct sk_buff *skb;\n\n\tif (data_len > BCM4378_PTB_CHUNK_SIZE)\n\t\treturn -EINVAL;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.blocks_left = cpu_to_le16(blocks_left);\n\tmemcpy(cmd.data, data, data_len);\n\n\tskb = __hci_cmd_sync(bcm4377->hdev, 0xfe0d, sizeof(cmd), &cmd,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int bcm4378_send_ptb(struct bcm4377_data *bcm4377,\n\t\t\t    const struct firmware *fw)\n{\n\tsize_t chunks = DIV_ROUND_UP(fw->size, (size_t)BCM4378_PTB_CHUNK_SIZE);\n\tsize_t i, left, transfer_len;\n\tint ret;\n\n\tfor (i = 0, left = fw->size; i < chunks; ++i, left -= transfer_len) {\n\t\ttransfer_len = min_t(size_t, left, BCM4378_PTB_CHUNK_SIZE);\n\n\t\tdev_dbg(&bcm4377->pdev->dev, \"sending ptb chunk %zu/%zu\\n\",\n\t\t\ti + 1, chunks);\n\t\tret = bcm4378_send_ptb_chunk(\n\t\t\tbcm4377, fw->data + i * BCM4378_PTB_CHUNK_SIZE,\n\t\t\ttransfer_len, chunks - i - 1);\n\t\tif (ret) {\n\t\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\t\"sending ptb chunk %zu failed (%d)\", i, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm4377_hci_open(struct hci_dev *hdev)\n{\n\tstruct bcm4377_data *bcm4377 = hci_get_drvdata(hdev);\n\tint ret;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"creating rings\\n\");\n\n\tret = bcm4377_create_completion_ring(bcm4377,\n\t\t\t\t\t     &bcm4377->hci_acl_ack_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_create_completion_ring(bcm4377,\n\t\t\t\t\t     &bcm4377->hci_acl_event_ring);\n\tif (ret)\n\t\tgoto destroy_hci_acl_ack;\n\tret = bcm4377_create_completion_ring(bcm4377, &bcm4377->sco_ack_ring);\n\tif (ret)\n\t\tgoto destroy_hci_acl_event;\n\tret = bcm4377_create_completion_ring(bcm4377, &bcm4377->sco_event_ring);\n\tif (ret)\n\t\tgoto destroy_sco_ack;\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"all completion rings successfully created!\\n\");\n\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->hci_h2d_ring);\n\tif (ret)\n\t\tgoto destroy_sco_event;\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->hci_d2h_ring);\n\tif (ret)\n\t\tgoto destroy_hci_h2d;\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->sco_h2d_ring);\n\tif (ret)\n\t\tgoto destroy_hci_d2h;\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->sco_d2h_ring);\n\tif (ret)\n\t\tgoto destroy_sco_h2d;\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->acl_h2d_ring);\n\tif (ret)\n\t\tgoto destroy_sco_d2h;\n\tret = bcm4377_create_transfer_ring(bcm4377, &bcm4377->acl_d2h_ring);\n\tif (ret)\n\t\tgoto destroy_acl_h2d;\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"all transfer rings successfully created!\\n\");\n\n\treturn 0;\n\ndestroy_acl_h2d:\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->acl_h2d_ring);\ndestroy_sco_d2h:\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->sco_d2h_ring);\ndestroy_sco_h2d:\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->sco_h2d_ring);\ndestroy_hci_d2h:\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->hci_h2d_ring);\ndestroy_hci_h2d:\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->hci_d2h_ring);\ndestroy_sco_event:\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->sco_event_ring);\ndestroy_sco_ack:\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->sco_ack_ring);\ndestroy_hci_acl_event:\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->hci_acl_event_ring);\ndestroy_hci_acl_ack:\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->hci_acl_ack_ring);\n\n\tdev_err(&bcm4377->pdev->dev, \"Creating rings failed with %d\\n\", ret);\n\treturn ret;\n}\n\nstatic int bcm4377_hci_close(struct hci_dev *hdev)\n{\n\tstruct bcm4377_data *bcm4377 = hci_get_drvdata(hdev);\n\n\tdev_dbg(&bcm4377->pdev->dev, \"destroying rings in hci_close\\n\");\n\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->acl_d2h_ring);\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->acl_h2d_ring);\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->sco_d2h_ring);\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->sco_h2d_ring);\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->hci_d2h_ring);\n\tbcm4377_destroy_transfer_ring(bcm4377, &bcm4377->hci_h2d_ring);\n\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->sco_event_ring);\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->sco_ack_ring);\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->hci_acl_event_ring);\n\tbcm4377_destroy_completion_ring(bcm4377, &bcm4377->hci_acl_ack_ring);\n\n\treturn 0;\n}\n\nstatic bool bcm4377_is_valid_bdaddr(struct bcm4377_data *bcm4377,\n\t\t\t\t    bdaddr_t *addr)\n{\n\tif (addr->b[0] != 0x93)\n\t\treturn true;\n\tif (addr->b[1] != 0x76)\n\t\treturn true;\n\tif (addr->b[2] != 0x00)\n\t\treturn true;\n\tif (addr->b[4] != (bcm4377->hw->id & 0xff))\n\t\treturn true;\n\tif (addr->b[5] != (bcm4377->hw->id >> 8))\n\t\treturn true;\n\treturn false;\n}\n\nstatic int bcm4377_check_bdaddr(struct bcm4377_data *bcm4377)\n{\n\tstruct hci_rp_read_bd_addr *bda;\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(bcm4377->hdev, HCI_OP_READ_BD_ADDR, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\n\t\tdev_err(&bcm4377->pdev->dev, \"HCI_OP_READ_BD_ADDR failed (%d)\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\tif (skb->len != sizeof(*bda)) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"HCI_OP_READ_BD_ADDR reply length invalid\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tbda = (struct hci_rp_read_bd_addr *)skb->data;\n\tif (!bcm4377_is_valid_bdaddr(bcm4377, &bda->bdaddr))\n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &bcm4377->hdev->quirks);\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int bcm4377_hci_setup(struct hci_dev *hdev)\n{\n\tstruct bcm4377_data *bcm4377 = hci_get_drvdata(hdev);\n\tconst struct firmware *fw;\n\tint ret;\n\n\tif (bcm4377->hw->send_calibration) {\n\t\tret = bcm4377->hw->send_calibration(bcm4377);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfw = bcm4377_request_blob(bcm4377, \"ptb\");\n\tif (!fw) {\n\t\tdev_err(&bcm4377->pdev->dev, \"failed to load PTB data\");\n\t\treturn -ENOENT;\n\t}\n\n\tret = bcm4377->hw->send_ptb(bcm4377, fw);\n\trelease_firmware(fw);\n\tif (ret)\n\t\treturn ret;\n\n\treturn bcm4377_check_bdaddr(bcm4377);\n}\n\nstatic int bcm4377_hci_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct bcm4377_data *bcm4377 = hci_get_drvdata(hdev);\n\tstruct bcm4377_transfer_ring *ring;\n\tint ret;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tring = &bcm4377->hci_h2d_ring;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tring = &bcm4377->acl_h2d_ring;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tring = &bcm4377->sco_h2d_ring;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EILSEQ;\n\t}\n\n\tret = bcm4377_enqueue(bcm4377, ring, skb->data, skb->len, false);\n\tif (ret < 0) {\n\t\thdev->stat.err_tx++;\n\t\treturn ret;\n\t}\n\n\thdev->stat.byte_tx += skb->len;\n\tkfree_skb(skb);\n\treturn ret;\n}\n\nstatic int bcm4377_hci_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct bcm4377_data *bcm4377 = hci_get_drvdata(hdev);\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc01, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"Change address command failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int bcm4377_alloc_transfer_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t       struct bcm4377_transfer_ring *ring)\n{\n\tsize_t entry_size;\n\n\tspin_lock_init(&ring->lock);\n\tring->payload_size = ALIGN(ring->payload_size, 4);\n\tring->mapped_payload_size = ALIGN(ring->mapped_payload_size, 4);\n\n\tif (ring->payload_size > BCM4377_XFER_RING_MAX_INPLACE_PAYLOAD_SIZE)\n\t\treturn -EINVAL;\n\tif (ring->n_entries > BCM4377_MAX_RING_SIZE)\n\t\treturn -EINVAL;\n\tif (ring->virtual && ring->allow_wait)\n\t\treturn -EINVAL;\n\n\tif (ring->d2h_buffers_only) {\n\t\tif (ring->virtual)\n\t\t\treturn -EINVAL;\n\t\tif (ring->payload_size)\n\t\t\treturn -EINVAL;\n\t\tif (!ring->mapped_payload_size)\n\t\t\treturn -EINVAL;\n\t}\n\tif (ring->virtual)\n\t\treturn 0;\n\n\tentry_size =\n\t\tring->payload_size + sizeof(struct bcm4377_xfer_ring_entry);\n\tring->ring = dmam_alloc_coherent(&bcm4377->pdev->dev,\n\t\t\t\t\t ring->n_entries * entry_size,\n\t\t\t\t\t &ring->ring_dma, GFP_KERNEL);\n\tif (!ring->ring)\n\t\treturn -ENOMEM;\n\n\tif (ring->allow_wait) {\n\t\tring->events = devm_kcalloc(&bcm4377->pdev->dev,\n\t\t\t\t\t    ring->n_entries,\n\t\t\t\t\t    sizeof(*ring->events), GFP_KERNEL);\n\t\tif (!ring->events)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (ring->mapped_payload_size) {\n\t\tring->payloads = dmam_alloc_coherent(\n\t\t\t&bcm4377->pdev->dev,\n\t\t\tring->n_entries * ring->mapped_payload_size,\n\t\t\t&ring->payloads_dma, GFP_KERNEL);\n\t\tif (!ring->payloads)\n\t\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm4377_alloc_completion_ring(struct bcm4377_data *bcm4377,\n\t\t\t\t\t struct bcm4377_completion_ring *ring)\n{\n\tsize_t entry_size;\n\n\tring->payload_size = ALIGN(ring->payload_size, 4);\n\tif (ring->payload_size > BCM4377_XFER_RING_MAX_INPLACE_PAYLOAD_SIZE)\n\t\treturn -EINVAL;\n\tif (ring->n_entries > BCM4377_MAX_RING_SIZE)\n\t\treturn -EINVAL;\n\n\tentry_size = ring->payload_size +\n\t\t     sizeof(struct bcm4377_completion_ring_entry);\n\n\tring->ring = dmam_alloc_coherent(&bcm4377->pdev->dev,\n\t\t\t\t\t ring->n_entries * entry_size,\n\t\t\t\t\t &ring->ring_dma, GFP_KERNEL);\n\tif (!ring->ring)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int bcm4377_init_context(struct bcm4377_data *bcm4377)\n{\n\tstruct device *dev = &bcm4377->pdev->dev;\n\tdma_addr_t peripheral_info_dma;\n\n\tbcm4377->ctx = dmam_alloc_coherent(dev, sizeof(*bcm4377->ctx),\n\t\t\t\t\t   &bcm4377->ctx_dma, GFP_KERNEL);\n\tif (!bcm4377->ctx)\n\t\treturn -ENOMEM;\n\tmemset(bcm4377->ctx, 0, sizeof(*bcm4377->ctx));\n\n\tbcm4377->ring_state =\n\t\tdmam_alloc_coherent(dev, sizeof(*bcm4377->ring_state),\n\t\t\t\t    &bcm4377->ring_state_dma, GFP_KERNEL);\n\tif (!bcm4377->ring_state)\n\t\treturn -ENOMEM;\n\tmemset(bcm4377->ring_state, 0, sizeof(*bcm4377->ring_state));\n\n\tbcm4377->ctx->version = cpu_to_le16(1);\n\tbcm4377->ctx->size = cpu_to_le16(sizeof(*bcm4377->ctx));\n\tbcm4377->ctx->enabled_caps = cpu_to_le32(2);\n\n\t \n\tif (!dmam_alloc_coherent(&bcm4377->pdev->dev, 0x20,\n\t\t\t\t &peripheral_info_dma, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tbcm4377->ctx->peripheral_info_addr = cpu_to_le64(peripheral_info_dma);\n\n\tbcm4377->ctx->xfer_ring_heads_addr = cpu_to_le64(\n\t\tbcm4377->ring_state_dma +\n\t\toffsetof(struct bcm4377_ring_state, xfer_ring_head));\n\tbcm4377->ctx->xfer_ring_tails_addr = cpu_to_le64(\n\t\tbcm4377->ring_state_dma +\n\t\toffsetof(struct bcm4377_ring_state, xfer_ring_tail));\n\tbcm4377->ctx->completion_ring_heads_addr = cpu_to_le64(\n\t\tbcm4377->ring_state_dma +\n\t\toffsetof(struct bcm4377_ring_state, completion_ring_head));\n\tbcm4377->ctx->completion_ring_tails_addr = cpu_to_le64(\n\t\tbcm4377->ring_state_dma +\n\t\toffsetof(struct bcm4377_ring_state, completion_ring_tail));\n\n\tbcm4377->ctx->n_completion_rings =\n\t\tcpu_to_le16(BCM4377_N_COMPLETION_RINGS);\n\tbcm4377->ctx->n_xfer_rings = cpu_to_le16(BCM4377_N_TRANSFER_RINGS);\n\n\tbcm4377->ctx->control_completion_ring_addr =\n\t\tcpu_to_le64(bcm4377->control_ack_ring.ring_dma);\n\tbcm4377->ctx->control_completion_ring_n_entries =\n\t\tcpu_to_le16(bcm4377->control_ack_ring.n_entries);\n\tbcm4377->ctx->control_completion_ring_doorbell = cpu_to_le16(0xffff);\n\tbcm4377->ctx->control_completion_ring_msi = 0;\n\tbcm4377->ctx->control_completion_ring_header_size = 0;\n\tbcm4377->ctx->control_completion_ring_footer_size = 0;\n\n\tbcm4377->ctx->control_xfer_ring_addr =\n\t\tcpu_to_le64(bcm4377->control_h2d_ring.ring_dma);\n\tbcm4377->ctx->control_xfer_ring_n_entries =\n\t\tcpu_to_le16(bcm4377->control_h2d_ring.n_entries);\n\tbcm4377->ctx->control_xfer_ring_doorbell =\n\t\tcpu_to_le16(bcm4377->control_h2d_ring.doorbell);\n\tbcm4377->ctx->control_xfer_ring_msi = 0;\n\tbcm4377->ctx->control_xfer_ring_header_size = 0;\n\tbcm4377->ctx->control_xfer_ring_footer_size =\n\t\tbcm4377->control_h2d_ring.payload_size / 4;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"context initialized at IOVA %pad\",\n\t\t&bcm4377->ctx_dma);\n\n\treturn 0;\n}\n\nstatic int bcm4377_prepare_rings(struct bcm4377_data *bcm4377)\n{\n\tint ret;\n\n\t \n\tbcm4377->control_ack_ring.ring_id = BCM4377_ACK_RING_CONTROL;\n\tbcm4377->control_ack_ring.n_entries = 32;\n\tbcm4377->control_ack_ring.transfer_rings =\n\t\tBIT(BCM4377_XFER_RING_CONTROL);\n\n\tbcm4377->hci_acl_ack_ring.ring_id = BCM4377_ACK_RING_HCI_ACL;\n\tbcm4377->hci_acl_ack_ring.n_entries = 2 * BCM4377_RING_N_ENTRIES;\n\tbcm4377->hci_acl_ack_ring.transfer_rings =\n\t\tBIT(BCM4377_XFER_RING_HCI_H2D) | BIT(BCM4377_XFER_RING_ACL_H2D);\n\tbcm4377->hci_acl_ack_ring.delay = 1000;\n\n\t \n\tbcm4377->hci_acl_event_ring.ring_id = BCM4377_EVENT_RING_HCI_ACL;\n\tbcm4377->hci_acl_event_ring.payload_size = MAX_EVENT_PAYLOAD_SIZE;\n\tbcm4377->hci_acl_event_ring.n_entries = 2 * BCM4377_RING_N_ENTRIES;\n\tbcm4377->hci_acl_event_ring.transfer_rings =\n\t\tBIT(BCM4377_XFER_RING_HCI_D2H) | BIT(BCM4377_XFER_RING_ACL_D2H);\n\tbcm4377->hci_acl_event_ring.delay = 1000;\n\n\tbcm4377->sco_ack_ring.ring_id = BCM4377_ACK_RING_SCO;\n\tbcm4377->sco_ack_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\tbcm4377->sco_ack_ring.transfer_rings = BIT(BCM4377_XFER_RING_SCO_H2D);\n\n\tbcm4377->sco_event_ring.ring_id = BCM4377_EVENT_RING_SCO;\n\tbcm4377->sco_event_ring.payload_size = MAX_SCO_PAYLOAD_SIZE;\n\tbcm4377->sco_event_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\tbcm4377->sco_event_ring.transfer_rings = BIT(BCM4377_XFER_RING_SCO_D2H);\n\n\tbcm4377->control_h2d_ring.ring_id = BCM4377_XFER_RING_CONTROL;\n\tbcm4377->control_h2d_ring.doorbell = BCM4377_DOORBELL_CONTROL;\n\tbcm4377->control_h2d_ring.payload_size = BCM4377_CONTROL_MSG_SIZE;\n\tbcm4377->control_h2d_ring.completion_ring = BCM4377_ACK_RING_CONTROL;\n\tbcm4377->control_h2d_ring.allow_wait = true;\n\tbcm4377->control_h2d_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\tbcm4377->hci_h2d_ring.ring_id = BCM4377_XFER_RING_HCI_H2D;\n\tbcm4377->hci_h2d_ring.doorbell = BCM4377_DOORBELL_HCI_H2D;\n\tbcm4377->hci_h2d_ring.payload_size = MAX_EVENT_PAYLOAD_SIZE;\n\tbcm4377->hci_h2d_ring.completion_ring = BCM4377_ACK_RING_HCI_ACL;\n\tbcm4377->hci_h2d_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\tbcm4377->hci_d2h_ring.ring_id = BCM4377_XFER_RING_HCI_D2H;\n\tbcm4377->hci_d2h_ring.doorbell = BCM4377_DOORBELL_HCI_D2H;\n\tbcm4377->hci_d2h_ring.completion_ring = BCM4377_EVENT_RING_HCI_ACL;\n\tbcm4377->hci_d2h_ring.virtual = true;\n\tbcm4377->hci_d2h_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\tbcm4377->sco_h2d_ring.ring_id = BCM4377_XFER_RING_SCO_H2D;\n\tbcm4377->sco_h2d_ring.doorbell = BCM4377_DOORBELL_SCO;\n\tbcm4377->sco_h2d_ring.payload_size = MAX_SCO_PAYLOAD_SIZE;\n\tbcm4377->sco_h2d_ring.completion_ring = BCM4377_ACK_RING_SCO;\n\tbcm4377->sco_h2d_ring.sync = true;\n\tbcm4377->sco_h2d_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\tbcm4377->sco_d2h_ring.ring_id = BCM4377_XFER_RING_SCO_D2H;\n\tbcm4377->sco_d2h_ring.doorbell = BCM4377_DOORBELL_SCO;\n\tbcm4377->sco_d2h_ring.completion_ring = BCM4377_EVENT_RING_SCO;\n\tbcm4377->sco_d2h_ring.virtual = true;\n\tbcm4377->sco_d2h_ring.sync = true;\n\tbcm4377->sco_d2h_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\t \n\tbcm4377->acl_h2d_ring.ring_id = BCM4377_XFER_RING_ACL_H2D;\n\tbcm4377->acl_h2d_ring.doorbell = BCM4377_DOORBELL_ACL_H2D;\n\tbcm4377->acl_h2d_ring.mapped_payload_size = MAX_ACL_PAYLOAD_SIZE;\n\tbcm4377->acl_h2d_ring.completion_ring = BCM4377_ACK_RING_HCI_ACL;\n\tbcm4377->acl_h2d_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\t \n\tbcm4377->acl_d2h_ring.ring_id = BCM4377_XFER_RING_ACL_D2H;\n\tbcm4377->acl_d2h_ring.doorbell = BCM4377_DOORBELL_ACL_D2H;\n\tbcm4377->acl_d2h_ring.completion_ring = BCM4377_EVENT_RING_HCI_ACL;\n\tbcm4377->acl_d2h_ring.d2h_buffers_only = true;\n\tbcm4377->acl_d2h_ring.mapped_payload_size = MAX_ACL_PAYLOAD_SIZE;\n\tbcm4377->acl_d2h_ring.n_entries = BCM4377_RING_N_ENTRIES;\n\n\t \n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->control_h2d_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->hci_h2d_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->hci_d2h_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->sco_h2d_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->sco_d2h_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->acl_h2d_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_transfer_ring(bcm4377, &bcm4377->acl_d2h_ring);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm4377_alloc_completion_ring(bcm4377,\n\t\t\t\t\t    &bcm4377->control_ack_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_completion_ring(bcm4377,\n\t\t\t\t\t    &bcm4377->hci_acl_ack_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_completion_ring(bcm4377,\n\t\t\t\t\t    &bcm4377->hci_acl_event_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_completion_ring(bcm4377, &bcm4377->sco_ack_ring);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_alloc_completion_ring(bcm4377, &bcm4377->sco_event_ring);\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"all rings allocated and prepared\\n\");\n\n\treturn 0;\n}\n\nstatic int bcm4377_boot(struct bcm4377_data *bcm4377)\n{\n\tconst struct firmware *fw;\n\tvoid *bfr;\n\tdma_addr_t fw_dma;\n\tint ret = 0;\n\tu32 bootstage, rti_status;\n\n\tbootstage = ioread32(bcm4377->bar2 + BCM4377_BAR2_BOOTSTAGE);\n\trti_status = ioread32(bcm4377->bar2 + BCM4377_BAR2_RTI_STATUS);\n\n\tif (bootstage != 0) {\n\t\tdev_err(&bcm4377->pdev->dev, \"bootstage is %d and not 0\\n\",\n\t\t\tbootstage);\n\t\treturn -EINVAL;\n\t}\n\n\tif (rti_status != 0) {\n\t\tdev_err(&bcm4377->pdev->dev, \"RTI status is %d and not 0\\n\",\n\t\t\trti_status);\n\t\treturn -EINVAL;\n\t}\n\n\tfw = bcm4377_request_blob(bcm4377, \"bin\");\n\tif (!fw) {\n\t\tdev_err(&bcm4377->pdev->dev, \"Failed to load firmware\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\tbfr = dma_alloc_coherent(&bcm4377->pdev->dev, fw->size, &fw_dma,\n\t\t\t\t GFP_KERNEL);\n\tif (!bfr) {\n\t\tret = -ENOMEM;\n\t\tgoto out_release_fw;\n\t}\n\n\tmemcpy(bfr, fw->data, fw->size);\n\n\tiowrite32(0, bcm4377->bar0 + BCM4377_BAR0_HOST_WINDOW_LO);\n\tiowrite32(0, bcm4377->bar0 + BCM4377_BAR0_HOST_WINDOW_HI);\n\tiowrite32(BCM4377_DMA_MASK,\n\t\t  bcm4377->bar0 + BCM4377_BAR0_HOST_WINDOW_SIZE);\n\n\tiowrite32(lower_32_bits(fw_dma), bcm4377->bar2 + BCM4377_BAR2_FW_LO);\n\tiowrite32(upper_32_bits(fw_dma), bcm4377->bar2 + BCM4377_BAR2_FW_HI);\n\tiowrite32(fw->size, bcm4377->bar2 + BCM4377_BAR2_FW_SIZE);\n\tiowrite32(0, bcm4377->bar0 + BCM4377_BAR0_FW_DOORBELL);\n\n\tdev_dbg(&bcm4377->pdev->dev, \"waiting for firmware to boot\\n\");\n\n\tret = wait_for_completion_interruptible_timeout(&bcm4377->event,\n\t\t\t\t\t\t\tBCM4377_TIMEOUT);\n\tif (ret == 0) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto out_dma_free;\n\t} else if (ret < 0) {\n\t\tgoto out_dma_free;\n\t}\n\n\tif (bcm4377->bootstage != 2) {\n\t\tdev_err(&bcm4377->pdev->dev, \"boostage %d != 2\\n\",\n\t\t\tbcm4377->bootstage);\n\t\tret = -ENXIO;\n\t\tgoto out_dma_free;\n\t}\n\n\tdev_dbg(&bcm4377->pdev->dev, \"firmware has booted (stage = %x)\\n\",\n\t\tbcm4377->bootstage);\n\tret = 0;\n\nout_dma_free:\n\tdma_free_coherent(&bcm4377->pdev->dev, fw->size, bfr, fw_dma);\nout_release_fw:\n\trelease_firmware(fw);\n\treturn ret;\n}\n\nstatic int bcm4377_setup_rti(struct bcm4377_data *bcm4377)\n{\n\tint ret;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"starting RTI\\n\");\n\tiowrite32(1, bcm4377->bar0 + BCM4377_BAR0_RTI_CONTROL);\n\n\tret = wait_for_completion_interruptible_timeout(&bcm4377->event,\n\t\t\t\t\t\t\tBCM4377_TIMEOUT);\n\tif (ret == 0) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"timed out while waiting for RTI to transition to state 1\");\n\t\treturn -ETIMEDOUT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (bcm4377->rti_status != 1) {\n\t\tdev_err(&bcm4377->pdev->dev, \"RTI did not ack state 1 (%d)\\n\",\n\t\t\tbcm4377->rti_status);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&bcm4377->pdev->dev, \"RTI is in state 1\\n\");\n\n\t \n\tiowrite32(0, bcm4377->bar2 + BCM4377_BAR2_RTI_WINDOW_LO);\n\tiowrite32(0, bcm4377->bar2 + BCM4377_BAR2_RTI_WINDOW_HI);\n\tiowrite32(BCM4377_DMA_MASK,\n\t\t  bcm4377->bar2 + BCM4377_BAR2_RTI_WINDOW_SIZE);\n\n\t \n\tiowrite32(lower_32_bits(bcm4377->ctx_dma),\n\t\t  bcm4377->bar2 + BCM4377_BAR2_CONTEXT_ADDR_LO);\n\tiowrite32(upper_32_bits(bcm4377->ctx_dma),\n\t\t  bcm4377->bar2 + BCM4377_BAR2_CONTEXT_ADDR_HI);\n\tiowrite32(2, bcm4377->bar0 + BCM4377_BAR0_RTI_CONTROL);\n\n\tret = wait_for_completion_interruptible_timeout(&bcm4377->event,\n\t\t\t\t\t\t\tBCM4377_TIMEOUT);\n\tif (ret == 0) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"timed out while waiting for RTI to transition to state 2\");\n\t\treturn -ETIMEDOUT;\n\t} else if (ret < 0) {\n\t\treturn ret;\n\t}\n\n\tif (bcm4377->rti_status != 2) {\n\t\tdev_err(&bcm4377->pdev->dev, \"RTI did not ack state 2 (%d)\\n\",\n\t\t\tbcm4377->rti_status);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"RTI is in state 2; control ring is ready\\n\");\n\tbcm4377->control_ack_ring.enabled = true;\n\n\treturn 0;\n}\n\nstatic int bcm4377_parse_otp_board_params(struct bcm4377_data *bcm4377,\n\t\t\t\t\t  char tag, const char *val, size_t len)\n{\n\tif (tag != 'V')\n\t\treturn 0;\n\tif (len >= sizeof(bcm4377->vendor))\n\t\treturn -EINVAL;\n\n\tstrscpy(bcm4377->vendor, val, len + 1);\n\treturn 0;\n}\n\nstatic int bcm4377_parse_otp_chip_params(struct bcm4377_data *bcm4377, char tag,\n\t\t\t\t\t const char *val, size_t len)\n{\n\tsize_t idx = 0;\n\n\tif (tag != 's')\n\t\treturn 0;\n\tif (len >= sizeof(bcm4377->stepping))\n\t\treturn -EINVAL;\n\n\twhile (len != 0) {\n\t\tbcm4377->stepping[idx] = tolower(val[idx]);\n\t\tif (val[idx] == '\\0')\n\t\t\treturn 0;\n\n\t\tidx++;\n\t\tlen--;\n\t}\n\n\tbcm4377->stepping[idx] = '\\0';\n\treturn 0;\n}\n\nstatic int bcm4377_parse_otp_str(struct bcm4377_data *bcm4377, const u8 *str,\n\t\t\t\t enum bcm4377_otp_params_type type)\n{\n\tconst char *p;\n\tint ret;\n\n\tp = skip_spaces(str);\n\twhile (*p) {\n\t\tchar tag = *p++;\n\t\tconst char *end;\n\t\tsize_t len;\n\n\t\tif (*p++ != '=')  \n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tend = strchrnul(p, ' ');\n\t\tlen = end - p;\n\n\t\t \n\t\tif (len > (BCM4377_OTP_MAX_PARAM_LEN - 1))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (type) {\n\t\tcase BCM4377_OTP_BOARD_PARAMS:\n\t\t\tret = bcm4377_parse_otp_board_params(bcm4377, tag, p,\n\t\t\t\t\t\t\t     len);\n\t\t\tbreak;\n\t\tcase BCM4377_OTP_CHIP_PARAMS:\n\t\t\tret = bcm4377_parse_otp_chip_params(bcm4377, tag, p,\n\t\t\t\t\t\t\t    len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tp = skip_spaces(end);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm4377_parse_otp_sys_vendor(struct bcm4377_data *bcm4377, u8 *otp,\n\t\t\t\t\tsize_t size)\n{\n\tint idx = 4;\n\tconst char *chip_params;\n\tconst char *board_params;\n\tint ret;\n\n\t \n\tif (size < 6)\n\t\treturn -EINVAL;\n\n\tif (get_unaligned_le32(otp) != BCM4377_OTP_VENDOR_HDR)\n\t\treturn -EINVAL;\n\n\tchip_params = &otp[idx];\n\n\t \n\tidx += strnlen(chip_params, size - idx) + 1;\n\tif (idx >= size)\n\t\treturn -EINVAL;\n\n\tboard_params = &otp[idx];\n\n\t \n\tidx += strnlen(board_params, size - idx);\n\tif (idx >= size)\n\t\treturn -EINVAL;\n\n\t \n\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\"OTP: chip_params='%s' board_params='%s'\\n\", chip_params,\n\t\tboard_params);\n\n\tret = bcm4377_parse_otp_str(bcm4377, chip_params,\n\t\t\t\t    BCM4377_OTP_CHIP_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm4377_parse_otp_str(bcm4377, board_params,\n\t\t\t\t    BCM4377_OTP_BOARD_PARAMS);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!bcm4377->stepping[0] || !bcm4377->vendor[0])\n\t\treturn -EINVAL;\n\n\tdev_dbg(&bcm4377->pdev->dev, \"OTP: stepping=%s, vendor=%s\\n\",\n\t\tbcm4377->stepping, bcm4377->vendor);\n\treturn 0;\n}\n\nstatic int bcm4377_parse_otp(struct bcm4377_data *bcm4377)\n{\n\tu8 *otp;\n\tint i;\n\tint ret = -ENOENT;\n\n\totp = kzalloc(BCM4377_OTP_SIZE, GFP_KERNEL);\n\tif (!otp)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < BCM4377_OTP_SIZE; ++i)\n\t\totp[i] = ioread8(bcm4377->bar0 + bcm4377->hw->otp_offset + i);\n\n\ti = 0;\n\twhile (i < (BCM4377_OTP_SIZE - 1)) {\n\t\tu8 type = otp[i];\n\t\tu8 length = otp[i + 1];\n\n\t\tif (type == 0)\n\t\t\tbreak;\n\n\t\tif ((i + 2 + length) > BCM4377_OTP_SIZE)\n\t\t\tbreak;\n\n\t\tswitch (type) {\n\t\tcase BCM4377_OTP_SYS_VENDOR:\n\t\t\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\t\t\"OTP @ 0x%x (%d): SYS_VENDOR\", i, length);\n\t\t\tret = bcm4377_parse_otp_sys_vendor(bcm4377, &otp[i + 2],\n\t\t\t\t\t\t\t   length);\n\t\t\tbreak;\n\t\tcase BCM4377_OTP_CIS:\n\t\t\tdev_dbg(&bcm4377->pdev->dev, \"OTP @ 0x%x (%d): CIS\", i,\n\t\t\t\tlength);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&bcm4377->pdev->dev, \"OTP @ 0x%x (%d): unknown\",\n\t\t\t\ti, length);\n\t\t\tbreak;\n\t\t}\n\n\t\ti += 2 + length;\n\t}\n\n\tkfree(otp);\n\treturn ret;\n}\n\nstatic int bcm4377_init_cfg(struct bcm4377_data *bcm4377)\n{\n\tint ret;\n\tu32 ctrl;\n\n\tret = pci_write_config_dword(bcm4377->pdev,\n\t\t\t\t     BCM4377_PCIECFG_BAR0_WINDOW1,\n\t\t\t\t     bcm4377->hw->bar0_window1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_write_config_dword(bcm4377->pdev,\n\t\t\t\t     BCM4377_PCIECFG_BAR0_WINDOW2,\n\t\t\t\t     bcm4377->hw->bar0_window2);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_write_config_dword(\n\t\tbcm4377->pdev, BCM4377_PCIECFG_BAR0_CORE2_WINDOW1,\n\t\tBCM4377_PCIECFG_BAR0_CORE2_WINDOW1_DEFAULT);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bcm4377->hw->has_bar0_core2_window2) {\n\t\tret = pci_write_config_dword(bcm4377->pdev,\n\t\t\t\t\t     BCM4377_PCIECFG_BAR0_CORE2_WINDOW2,\n\t\t\t\t\t     bcm4377->hw->bar0_core2_window2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = pci_write_config_dword(bcm4377->pdev, BCM4377_PCIECFG_BAR2_WINDOW,\n\t\t\t\t     BCM4377_PCIECFG_BAR2_WINDOW_DEFAULT);\n\tif (ret)\n\t\treturn ret;\n\n\tret = pci_read_config_dword(bcm4377->pdev,\n\t\t\t\t    BCM4377_PCIECFG_SUBSYSTEM_CTRL, &ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\tif (bcm4377->hw->clear_pciecfg_subsystem_ctrl_bit19)\n\t\tctrl &= ~BIT(19);\n\tctrl |= BIT(16);\n\n\treturn pci_write_config_dword(bcm4377->pdev,\n\t\t\t\t      BCM4377_PCIECFG_SUBSYSTEM_CTRL, ctrl);\n}\n\nstatic int bcm4377_probe_dmi(struct bcm4377_data *bcm4377)\n{\n\tconst struct dmi_system_id *board_type_dmi_id;\n\n\tboard_type_dmi_id = dmi_first_match(bcm4377_dmi_board_table);\n\tif (board_type_dmi_id && board_type_dmi_id->driver_data) {\n\t\tbcm4377->board_type = board_type_dmi_id->driver_data;\n\t\tdev_dbg(&bcm4377->pdev->dev,\n\t\t\t\"found board type via DMI match: %s\\n\",\n\t\t\tbcm4377->board_type);\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm4377_probe_of(struct bcm4377_data *bcm4377)\n{\n\tstruct device_node *np = bcm4377->pdev->dev.of_node;\n\tint ret;\n\n\tif (!np)\n\t\treturn 0;\n\n\tret = of_property_read_string(np, \"brcm,board-type\",\n\t\t\t\t      &bcm4377->board_type);\n\tif (ret) {\n\t\tdev_err(&bcm4377->pdev->dev, \"no brcm,board-type property\\n\");\n\t\treturn ret;\n\t}\n\n\tbcm4377->taurus_beamforming_cal_blob =\n\t\tof_get_property(np, \"brcm,taurus-bf-cal-blob\",\n\t\t\t\t&bcm4377->taurus_beamforming_cal_size);\n\tif (!bcm4377->taurus_beamforming_cal_blob) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"no brcm,taurus-bf-cal-blob property\\n\");\n\t\treturn -ENOENT;\n\t}\n\tbcm4377->taurus_cal_blob = of_get_property(np, \"brcm,taurus-cal-blob\",\n\t\t\t\t\t\t   &bcm4377->taurus_cal_size);\n\tif (!bcm4377->taurus_cal_blob) {\n\t\tdev_err(&bcm4377->pdev->dev,\n\t\t\t\"no brcm,taurus-cal-blob property\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\treturn 0;\n}\n\nstatic void bcm4377_disable_aspm(struct bcm4377_data *bcm4377)\n{\n\tpci_disable_link_state(bcm4377->pdev,\n\t\t\t       PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1);\n\n\t \n\tpcie_capability_clear_word(bcm4377->pdev, PCI_EXP_LNKCTL,\n\t\t\t\t   PCI_EXP_LNKCTL_ASPMC);\n}\n\nstatic void bcm4377_pci_free_irq_vectors(void *data)\n{\n\tpci_free_irq_vectors(data);\n}\n\nstatic void bcm4377_hci_free_dev(void *data)\n{\n\thci_free_dev(data);\n}\n\nstatic void bcm4377_hci_unregister_dev(void *data)\n{\n\thci_unregister_dev(data);\n}\n\nstatic int bcm4377_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tstruct bcm4377_data *bcm4377;\n\tstruct hci_dev *hdev;\n\tint ret, irq;\n\n\tret = dma_set_mask_and_coherent(&pdev->dev, BCM4377_DMA_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\tbcm4377 = devm_kzalloc(&pdev->dev, sizeof(*bcm4377), GFP_KERNEL);\n\tif (!bcm4377)\n\t\treturn -ENOMEM;\n\n\tbcm4377->pdev = pdev;\n\tbcm4377->hw = &bcm4377_hw_variants[id->driver_data];\n\tinit_completion(&bcm4377->event);\n\n\tret = bcm4377_prepare_rings(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm4377_init_context(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm4377_probe_dmi(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\tret = bcm4377_probe_of(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\tif (!bcm4377->board_type) {\n\t\tdev_err(&pdev->dev, \"unable to determine board type\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (bcm4377->hw->disable_aspm)\n\t\tbcm4377_disable_aspm(bcm4377);\n\n\tret = pci_reset_function_locked(pdev);\n\tif (ret)\n\t\tdev_warn(\n\t\t\t&pdev->dev,\n\t\t\t\"function level reset failed with %d; trying to continue anyway\\n\",\n\t\t\tret);\n\n\t \n\tmsleep(100);\n\n\tret = pcim_enable_device(pdev);\n\tif (ret)\n\t\treturn ret;\n\tpci_set_master(pdev);\n\n\tret = bcm4377_init_cfg(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\tbcm4377->bar0 = pcim_iomap(pdev, 0, 0);\n\tif (!bcm4377->bar0)\n\t\treturn -EBUSY;\n\tbcm4377->bar2 = pcim_iomap(pdev, 2, 0);\n\tif (!bcm4377->bar2)\n\t\treturn -EBUSY;\n\n\tret = bcm4377_parse_otp(bcm4377);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Reading OTP failed with %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t \n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\tret = devm_add_action_or_reset(&pdev->dev, bcm4377_pci_free_irq_vectors,\n\t\t\t\t       pdev);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = pci_irq_vector(pdev, 0);\n\tif (irq <= 0)\n\t\treturn -ENODEV;\n\n\tret = devm_request_irq(&pdev->dev, irq, bcm4377_irq, 0, \"bcm4377\",\n\t\t\t       bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\thdev = hci_alloc_dev();\n\tif (!hdev)\n\t\treturn -ENOMEM;\n\tret = devm_add_action_or_reset(&pdev->dev, bcm4377_hci_free_dev, hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tbcm4377->hdev = hdev;\n\n\thdev->bus = HCI_PCI;\n\thdev->dev_type = HCI_PRIMARY;\n\thdev->open = bcm4377_hci_open;\n\thdev->close = bcm4377_hci_close;\n\thdev->send = bcm4377_hci_send_frame;\n\thdev->set_bdaddr = bcm4377_hci_set_bdaddr;\n\thdev->setup = bcm4377_hci_setup;\n\n\tset_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);\n\tif (bcm4377->hw->broken_mws_transport_config)\n\t\tset_bit(HCI_QUIRK_BROKEN_MWS_TRANSPORT_CONFIG, &hdev->quirks);\n\tif (bcm4377->hw->broken_ext_scan)\n\t\tset_bit(HCI_QUIRK_BROKEN_EXT_SCAN, &hdev->quirks);\n\tif (bcm4377->hw->broken_le_coded)\n\t\tset_bit(HCI_QUIRK_BROKEN_LE_CODED, &hdev->quirks);\n\n\tpci_set_drvdata(pdev, bcm4377);\n\thci_set_drvdata(hdev, bcm4377);\n\tSET_HCIDEV_DEV(hdev, &pdev->dev);\n\n\tret = bcm4377_boot(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\tret = bcm4377_setup_rti(bcm4377);\n\tif (ret)\n\t\treturn ret;\n\n\tret = hci_register_dev(hdev);\n\tif (ret)\n\t\treturn ret;\n\treturn devm_add_action_or_reset(&pdev->dev, bcm4377_hci_unregister_dev,\n\t\t\t\t\thdev);\n}\n\nstatic int bcm4377_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct bcm4377_data *bcm4377 = pci_get_drvdata(pdev);\n\tint ret;\n\n\tret = hci_suspend_dev(bcm4377->hdev);\n\tif (ret)\n\t\treturn ret;\n\n\tiowrite32(BCM4377_BAR0_SLEEP_CONTROL_QUIESCE,\n\t\t  bcm4377->bar0 + BCM4377_BAR0_SLEEP_CONTROL);\n\n\treturn 0;\n}\n\nstatic int bcm4377_resume(struct pci_dev *pdev)\n{\n\tstruct bcm4377_data *bcm4377 = pci_get_drvdata(pdev);\n\n\tiowrite32(BCM4377_BAR0_SLEEP_CONTROL_UNQUIESCE,\n\t\t  bcm4377->bar0 + BCM4377_BAR0_SLEEP_CONTROL);\n\n\treturn hci_resume_dev(bcm4377->hdev);\n}\n\nstatic const struct dmi_system_id bcm4377_dmi_board_table[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookAir9,1\"),\n\t\t},\n\t\t.driver_data = \"apple,formosa\",\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro15,4\"),\n\t\t},\n\t\t.driver_data = \"apple,formosa\",\n\t},\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro16,3\"),\n\t\t},\n\t\t.driver_data = \"apple,formosa\",\n\t},\n\t{}\n};\n\nstatic const struct bcm4377_hw bcm4377_hw_variants[] = {\n\t[BCM4377] = {\n\t\t.id = 0x4377,\n\t\t.otp_offset = 0x4120,\n\t\t.bar0_window1 = 0x1800b000,\n\t\t.bar0_window2 = 0x1810c000,\n\t\t.disable_aspm = true,\n\t\t.broken_ext_scan = true,\n\t\t.send_ptb = bcm4377_send_ptb,\n\t},\n\n\t[BCM4378] = {\n\t\t.id = 0x4378,\n\t\t.otp_offset = 0x4120,\n\t\t.bar0_window1 = 0x18002000,\n\t\t.bar0_window2 = 0x1810a000,\n\t\t.bar0_core2_window2 = 0x18107000,\n\t\t.has_bar0_core2_window2 = true,\n\t\t.broken_mws_transport_config = true,\n\t\t.broken_le_coded = true,\n\t\t.send_calibration = bcm4378_send_calibration,\n\t\t.send_ptb = bcm4378_send_ptb,\n\t},\n\n\t[BCM4387] = {\n\t\t.id = 0x4387,\n\t\t.otp_offset = 0x413c,\n\t\t.bar0_window1 = 0x18002000,\n\t\t.bar0_window2 = 0x18109000,\n\t\t.bar0_core2_window2 = 0x18106000,\n\t\t.has_bar0_core2_window2 = true,\n\t\t.clear_pciecfg_subsystem_ctrl_bit19 = true,\n\t\t.broken_mws_transport_config = true,\n\t\t.broken_le_coded = true,\n\t\t.send_calibration = bcm4387_send_calibration,\n\t\t.send_ptb = bcm4378_send_ptb,\n\t},\n};\n\n#define BCM4377_DEVID_ENTRY(id)                                             \\\n\t{                                                                   \\\n\t\tPCI_VENDOR_ID_BROADCOM, BCM##id##_DEVICE_ID, PCI_ANY_ID,    \\\n\t\t\tPCI_ANY_ID, PCI_CLASS_NETWORK_OTHER << 8, 0xffff00, \\\n\t\t\tBCM##id                                             \\\n\t}\n\nstatic const struct pci_device_id bcm4377_devid_table[] = {\n\tBCM4377_DEVID_ENTRY(4377),\n\tBCM4377_DEVID_ENTRY(4378),\n\tBCM4377_DEVID_ENTRY(4387),\n\t{},\n};\nMODULE_DEVICE_TABLE(pci, bcm4377_devid_table);\n\nstatic struct pci_driver bcm4377_pci_driver = {\n\t.name = \"hci_bcm4377\",\n\t.id_table = bcm4377_devid_table,\n\t.probe = bcm4377_probe,\n\t.suspend = bcm4377_suspend,\n\t.resume = bcm4377_resume,\n};\nmodule_pci_driver(bcm4377_pci_driver);\n\nMODULE_AUTHOR(\"Sven Peter <sven@svenpeter.dev>\");\nMODULE_DESCRIPTION(\"Bluetooth support for Broadcom 4377/4378/4387 devices\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_FIRMWARE(\"brcm/brcmbt4377*.bin\");\nMODULE_FIRMWARE(\"brcm/brcmbt4377*.ptb\");\nMODULE_FIRMWARE(\"brcm/brcmbt4378*.bin\");\nMODULE_FIRMWARE(\"brcm/brcmbt4378*.ptb\");\nMODULE_FIRMWARE(\"brcm/brcmbt4387*.bin\");\nMODULE_FIRMWARE(\"brcm/brcmbt4387*.ptb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}