{
  "module_name": "hci_ldisc.c",
  "hash_id": "e2760cdac2ca25ff20d0decf79249b329f937dff1a08050a2877e1806e21cbc7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_ldisc.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/serdev.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btintel.h\"\n#include \"btbcm.h\"\n#include \"hci_uart.h\"\n\n#define VERSION \"2.3\"\n\nstatic const struct hci_uart_proto *hup[HCI_UART_MAX_PROTO];\n\nint hci_uart_register_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (hup[p->id])\n\t\treturn -EEXIST;\n\n\thup[p->id] = p;\n\n\tBT_INFO(\"HCI UART protocol %s registered\", p->name);\n\n\treturn 0;\n}\n\nint hci_uart_unregister_proto(const struct hci_uart_proto *p)\n{\n\tif (p->id >= HCI_UART_MAX_PROTO)\n\t\treturn -EINVAL;\n\n\tif (!hup[p->id])\n\t\treturn -EINVAL;\n\n\thup[p->id] = NULL;\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto *hci_uart_get_proto(unsigned int id)\n{\n\tif (id >= HCI_UART_MAX_PROTO)\n\t\treturn NULL;\n\n\treturn hup[id];\n}\n\nstatic inline void hci_uart_tx_complete(struct hci_uart *hu, int pkt_type)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\n\t \n\tswitch (pkt_type) {\n\tcase HCI_COMMAND_PKT:\n\t\thdev->stat.cmd_tx++;\n\t\tbreak;\n\n\tcase HCI_ACLDATA_PKT:\n\t\thdev->stat.acl_tx++;\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\thdev->stat.sco_tx++;\n\t\tbreak;\n\t}\n}\n\nstatic inline struct sk_buff *hci_uart_dequeue(struct hci_uart *hu)\n{\n\tstruct sk_buff *skb = hu->tx_skb;\n\n\tif (!skb) {\n\t\tpercpu_down_read(&hu->proto_lock);\n\n\t\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\t\tskb = hu->proto->dequeue(hu);\n\n\t\tpercpu_up_read(&hu->proto_lock);\n\t} else {\n\t\thu->tx_skb = NULL;\n\t}\n\n\treturn skb;\n}\n\nint hci_uart_tx_wakeup(struct hci_uart *hu)\n{\n\t \n\tif (!percpu_down_read_trylock(&hu->proto_lock))\n\t\treturn 0;\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\tgoto no_schedule;\n\n\tset_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\tif (test_and_set_bit(HCI_UART_SENDING, &hu->tx_state))\n\t\tgoto no_schedule;\n\n\tBT_DBG(\"\");\n\n\tschedule_work(&hu->write_work);\n\nno_schedule:\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(hci_uart_tx_wakeup);\n\nstatic void hci_uart_write_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, write_work);\n\tstruct tty_struct *tty = hu->tty;\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct sk_buff *skb;\n\n\t \n\nrestart:\n\tclear_bit(HCI_UART_TX_WAKEUP, &hu->tx_state);\n\n\twhile ((skb = hci_uart_dequeue(hu))) {\n\t\tint len;\n\n\t\tset_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\t\tlen = tty->ops->write(tty, skb->data, skb->len);\n\t\thdev->stat.byte_tx += len;\n\n\t\tskb_pull(skb, len);\n\t\tif (skb->len) {\n\t\t\thu->tx_skb = skb;\n\t\t\tbreak;\n\t\t}\n\n\t\thci_uart_tx_complete(hu, hci_skb_pkt_type(skb));\n\t\tkfree_skb(skb);\n\t}\n\n\tclear_bit(HCI_UART_SENDING, &hu->tx_state);\n\tif (test_bit(HCI_UART_TX_WAKEUP, &hu->tx_state))\n\t\tgoto restart;\n\n\twake_up_bit(&hu->tx_state, HCI_UART_SENDING);\n}\n\nvoid hci_uart_init_work(struct work_struct *work)\n{\n\tstruct hci_uart *hu = container_of(work, struct hci_uart, init_ready);\n\tint err;\n\tstruct hci_dev *hdev;\n\n\tif (!test_and_clear_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn;\n\n\terr = hci_register_dev(hu->hdev);\n\tif (err < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\thu->proto->close(hu);\n\t\thdev = hu->hdev;\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n}\n\nint hci_uart_init_ready(struct hci_uart *hu)\n{\n\tif (!test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn -EALREADY;\n\n\tschedule_work(&hu->init_ready);\n\n\treturn 0;\n}\n\nint hci_uart_wait_until_sent(struct hci_uart *hu)\n{\n\treturn wait_on_bit_timeout(&hu->tx_state, HCI_UART_SENDING,\n\t\t\t\t   TASK_INTERRUPTIBLE,\n\t\t\t\t   msecs_to_jiffies(2000));\n}\n\n \n \nstatic int hci_uart_flush(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu  = hci_get_drvdata(hdev);\n\tstruct tty_struct *tty = hu->tty;\n\n\tBT_DBG(\"hdev %p tty %p\", hdev, tty);\n\n\tif (hu->tx_skb) {\n\t\tkfree_skb(hu->tx_skb); hu->tx_skb = NULL;\n\t}\n\n\t \n\ttty_ldisc_flush(tty);\n\ttty_driver_flush_buffer(tty);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thu->proto->flush(hu);\n\n\tpercpu_up_read(&hu->proto_lock);\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_open(struct hci_dev *hdev)\n{\n\tBT_DBG(\"%s %p\", hdev->name, hdev);\n\n\t \n\thdev->flush = hci_uart_flush;\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_close(struct hci_dev *hdev)\n{\n\tBT_DBG(\"hdev %p\", hdev);\n\n\thci_uart_flush(hdev);\n\thdev->flush = NULL;\n\treturn 0;\n}\n\n \nstatic int hci_uart_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\n\tBT_DBG(\"%s: type %d len %d\", hdev->name, hci_skb_pkt_type(skb),\n\t       skb->len);\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn -EUNATCH;\n\t}\n\n\thu->proto->enqueue(hu, skb);\n\tpercpu_up_read(&hu->proto_lock);\n\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\n \nbool hci_uart_has_flow_control(struct hci_uart *hu)\n{\n\t \n\tif (hu->serdev)\n\t\treturn true;\n\n\tif (hu->tty->driver->ops->tiocmget && hu->tty->driver->ops->tiocmset)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nvoid hci_uart_set_flow_control(struct hci_uart *hu, bool enable)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\tint status;\n\tunsigned int set = 0;\n\tunsigned int clear = 0;\n\n\tif (hu->serdev) {\n\t\tserdev_device_set_flow_control(hu->serdev, !enable);\n\t\tserdev_device_set_rts(hu->serdev, !enable);\n\t\treturn;\n\t}\n\n\tif (enable) {\n\t\t \n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag &= ~CRTSCTS;\n\t\ttty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Disabling hardware flow control: %s\",\n\t\t       (tty->termios.c_cflag & CRTSCTS) ? \"failed\" : \"success\");\n\n\t\t \n\t\t \n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset &= ~(TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Clearing RTS: %s\", status ? \"failed\" : \"success\");\n\t} else {\n\t\t \n\t\tstatus = tty->driver->ops->tiocmget(tty);\n\t\tBT_DBG(\"Current tiocm 0x%x\", status);\n\n\t\tset |= (TIOCM_OUT2 | TIOCM_RTS);\n\t\tclear = ~set;\n\t\tset &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t       TIOCM_OUT2 | TIOCM_LOOP;\n\t\tclear &= TIOCM_DTR | TIOCM_RTS | TIOCM_OUT1 |\n\t\t\t TIOCM_OUT2 | TIOCM_LOOP;\n\t\tstatus = tty->driver->ops->tiocmset(tty, set, clear);\n\t\tBT_DBG(\"Setting RTS: %s\", status ? \"failed\" : \"success\");\n\n\t\t \n\t\tktermios = tty->termios;\n\t\tktermios.c_cflag |= CRTSCTS;\n\t\ttty_set_termios(tty, &ktermios);\n\t\tBT_DBG(\"Enabling hardware flow control: %s\",\n\t\t       !(tty->termios.c_cflag & CRTSCTS) ? \"failed\" : \"success\");\n\t}\n}\n\nvoid hci_uart_set_speeds(struct hci_uart *hu, unsigned int init_speed,\n\t\t\t unsigned int oper_speed)\n{\n\thu->init_speed = init_speed;\n\thu->oper_speed = oper_speed;\n}\n\nvoid hci_uart_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tstruct tty_struct *tty = hu->tty;\n\tstruct ktermios ktermios;\n\n\tktermios = tty->termios;\n\tktermios.c_cflag &= ~CBAUD;\n\ttty_termios_encode_baud_rate(&ktermios, speed, speed);\n\n\t \n\ttty_set_termios(tty, &ktermios);\n\n\tBT_DBG(\"%s: New tty speeds: %d/%d\", hu->hdev->name,\n\t       tty->termios.c_ispeed, tty->termios.c_ospeed);\n}\n\nstatic int hci_uart_setup(struct hci_dev *hdev)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct hci_rp_read_local_version *ver;\n\tstruct sk_buff *skb;\n\tunsigned int speed;\n\tint err;\n\n\t \n\tif (hu->init_speed)\n\t\tspeed = hu->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thci_uart_set_baudrate(hu, speed);\n\n\t \n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (hu->proto->set_baudrate && speed) {\n\t\terr = hu->proto->set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thci_uart_set_baudrate(hu, speed);\n\t}\n\n\tif (hu->proto->setup)\n\t\treturn hu->proto->setup(hu);\n\n\tif (!test_bit(HCI_UART_VND_DETECT, &hu->hdev_flags))\n\t\treturn 0;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tBT_ERR(\"%s: Reading local version information failed (%ld)\",\n\t\t       hdev->name, PTR_ERR(skb));\n\t\treturn 0;\n\t}\n\n\tif (skb->len != sizeof(*ver)) {\n\t\tBT_ERR(\"%s: Event length mismatch for version information\",\n\t\t       hdev->name);\n\t\tgoto done;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\n\tswitch (le16_to_cpu(ver->manufacturer)) {\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tcase 2:\n\t\thdev->set_bdaddr = btintel_set_bdaddr;\n\t\tbtintel_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tcase 15:\n\t\thdev->set_bdaddr = btbcm_set_bdaddr;\n\t\tbtbcm_check_bdaddr(hdev);\n\t\tbreak;\n#endif\n\tdefault:\n\t\tbreak;\n\t}\n\ndone:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \n \nstatic int hci_uart_tty_open(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\t \n\tif (tty->ops->write == NULL)\n\t\treturn -EOPNOTSUPP;\n\n\thu = kzalloc(sizeof(struct hci_uart), GFP_KERNEL);\n\tif (!hu) {\n\t\tBT_ERR(\"Can't allocate control structure\");\n\t\treturn -ENFILE;\n\t}\n\tif (percpu_init_rwsem(&hu->proto_lock)) {\n\t\tBT_ERR(\"Can't allocate semaphore structure\");\n\t\tkfree(hu);\n\t\treturn -ENOMEM;\n\t}\n\n\ttty->disc_data = hu;\n\thu->tty = tty;\n\ttty->receive_room = 65536;\n\n\t \n\thu->alignment = 1;\n\thu->padding = 0;\n\n\tINIT_WORK(&hu->init_ready, hci_uart_init_work);\n\tINIT_WORK(&hu->write_work, hci_uart_write_work);\n\n\t \n\ttty_driver_flush_buffer(tty);\n\n\treturn 0;\n}\n\n \nstatic void hci_uart_tty_close(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tstruct hci_dev *hdev;\n\n\tBT_DBG(\"tty %p\", tty);\n\n\t \n\ttty->disc_data = NULL;\n\n\tif (!hu)\n\t\treturn;\n\n\thdev = hu->hdev;\n\tif (hdev)\n\t\thci_uart_close(hdev);\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_down_write(&hu->proto_lock);\n\t\tclear_bit(HCI_UART_PROTO_READY, &hu->flags);\n\t\tpercpu_up_write(&hu->proto_lock);\n\n\t\tcancel_work_sync(&hu->init_ready);\n\t\tcancel_work_sync(&hu->write_work);\n\n\t\tif (hdev) {\n\t\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\t\thci_unregister_dev(hdev);\n\t\t\thci_free_dev(hdev);\n\t\t}\n\t\thu->proto->close(hu);\n\t}\n\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\n\tpercpu_free_rwsem(&hu->proto_lock);\n\n\tkfree(hu);\n}\n\n \nstatic void hci_uart_tty_wakeup(struct tty_struct *tty)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tBT_DBG(\"\");\n\n\tif (!hu)\n\t\treturn;\n\n\tclear_bit(TTY_DO_WRITE_WAKEUP, &tty->flags);\n\n\tif (tty != hu->tty)\n\t\treturn;\n\n\tif (test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\thci_uart_tx_wakeup(hu);\n}\n\n \nstatic void hci_uart_tty_receive(struct tty_struct *tty, const u8 *data,\n\t\t\t\t const u8 *flags, size_t count)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\n\tif (!hu || tty != hu->tty)\n\t\treturn;\n\n\tpercpu_down_read(&hu->proto_lock);\n\n\tif (!test_bit(HCI_UART_PROTO_READY, &hu->flags)) {\n\t\tpercpu_up_read(&hu->proto_lock);\n\t\treturn;\n\t}\n\n\t \n\thu->proto->recv(hu, data, count);\n\tpercpu_up_read(&hu->proto_lock);\n\n\tif (hu->hdev)\n\t\thu->hdev->stat.byte_rx += count;\n\n\ttty_unthrottle(tty);\n}\n\nstatic int hci_uart_register_dev(struct hci_uart *hu)\n{\n\tstruct hci_dev *hdev;\n\tint err;\n\n\tBT_DBG(\"\");\n\n\t \n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tBT_ERR(\"Can't allocate HCI device\");\n\t\treturn -ENOMEM;\n\t}\n\n\thu->hdev = hdev;\n\n\thdev->bus = HCI_UART;\n\thci_set_drvdata(hdev, hu);\n\n\t \n\tif (hu->proto->setup)\n\t\thdev->manufacturer = hu->proto->manufacturer;\n\n\thdev->open  = hci_uart_open;\n\thdev->close = hci_uart_close;\n\thdev->flush = hci_uart_flush;\n\thdev->send  = hci_uart_send_frame;\n\thdev->setup = hci_uart_setup;\n\tSET_HCIDEV_DEV(hdev, hu->tty->dev);\n\n\tif (test_bit(HCI_UART_RAW_DEVICE, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_EXT_CONFIG, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_EXTERNAL_CONFIG, &hdev->quirks);\n\n\tif (!test_bit(HCI_UART_RESET_ON_INIT, &hu->hdev_flags))\n\t\tset_bit(HCI_QUIRK_RESET_ON_CLOSE, &hdev->quirks);\n\n\tif (test_bit(HCI_UART_CREATE_AMP, &hu->hdev_flags))\n\t\thdev->dev_type = HCI_AMP;\n\telse\n\t\thdev->dev_type = HCI_PRIMARY;\n\n\t \n\terr = hu->proto->open(hu);\n\tif (err) {\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn err;\n\t}\n\n\tif (test_bit(HCI_UART_INIT_PENDING, &hu->hdev_flags))\n\t\treturn 0;\n\n\tif (hci_register_dev(hdev) < 0) {\n\t\tBT_ERR(\"Can't register HCI device\");\n\t\thu->proto->close(hu);\n\t\thu->hdev = NULL;\n\t\thci_free_dev(hdev);\n\t\treturn -ENODEV;\n\t}\n\n\tset_bit(HCI_UART_REGISTERED, &hu->flags);\n\n\treturn 0;\n}\n\nstatic int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}\n\nstatic int hci_uart_set_flags(struct hci_uart *hu, unsigned long flags)\n{\n\tunsigned long valid_flags = BIT(HCI_UART_RAW_DEVICE) |\n\t\t\t\t    BIT(HCI_UART_RESET_ON_INIT) |\n\t\t\t\t    BIT(HCI_UART_CREATE_AMP) |\n\t\t\t\t    BIT(HCI_UART_INIT_PENDING) |\n\t\t\t\t    BIT(HCI_UART_EXT_CONFIG) |\n\t\t\t\t    BIT(HCI_UART_VND_DETECT);\n\n\tif (flags & ~valid_flags)\n\t\treturn -EINVAL;\n\n\thu->hdev_flags = flags;\n\n\treturn 0;\n}\n\n \nstatic int hci_uart_tty_ioctl(struct tty_struct *tty, unsigned int cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct hci_uart *hu = tty->disc_data;\n\tint err = 0;\n\n\tBT_DBG(\"\");\n\n\t \n\tif (!hu)\n\t\treturn -EBADF;\n\n\tswitch (cmd) {\n\tcase HCIUARTSETPROTO:\n\t\tif (!test_and_set_bit(HCI_UART_PROTO_SET, &hu->flags)) {\n\t\t\terr = hci_uart_set_proto(hu, arg);\n\t\t\tif (err)\n\t\t\t\tclear_bit(HCI_UART_PROTO_SET, &hu->flags);\n\t\t} else\n\t\t\terr = -EBUSY;\n\t\tbreak;\n\n\tcase HCIUARTGETPROTO:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags) &&\n\t\t    test_bit(HCI_UART_PROTO_READY, &hu->flags))\n\t\t\terr = hu->proto->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTGETDEVICE:\n\t\tif (test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\t\terr = hu->hdev->id;\n\t\telse\n\t\t\terr = -EUNATCH;\n\t\tbreak;\n\n\tcase HCIUARTSETFLAGS:\n\t\tif (test_bit(HCI_UART_PROTO_SET, &hu->flags))\n\t\t\terr = -EBUSY;\n\t\telse\n\t\t\terr = hci_uart_set_flags(hu, arg);\n\t\tbreak;\n\n\tcase HCIUARTGETFLAGS:\n\t\terr = hu->hdev_flags;\n\t\tbreak;\n\n\tdefault:\n\t\terr = n_tty_ioctl_helper(tty, cmd, arg);\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n \nstatic ssize_t hci_uart_tty_read(struct tty_struct *tty, struct file *file,\n\t\t\t\t u8 *buf, size_t nr, void **cookie,\n\t\t\t\t unsigned long offset)\n{\n\treturn 0;\n}\n\nstatic ssize_t hci_uart_tty_write(struct tty_struct *tty, struct file *file,\n\t\t\t\t  const u8 *data, size_t count)\n{\n\treturn 0;\n}\n\nstatic struct tty_ldisc_ops hci_uart_ldisc = {\n\t.owner\t\t= THIS_MODULE,\n\t.num\t\t= N_HCI,\n\t.name\t\t= \"n_hci\",\n\t.open\t\t= hci_uart_tty_open,\n\t.close\t\t= hci_uart_tty_close,\n\t.read\t\t= hci_uart_tty_read,\n\t.write\t\t= hci_uart_tty_write,\n\t.ioctl\t\t= hci_uart_tty_ioctl,\n\t.compat_ioctl\t= hci_uart_tty_ioctl,\n\t.receive_buf\t= hci_uart_tty_receive,\n\t.write_wakeup\t= hci_uart_tty_wakeup,\n};\n\nstatic int __init hci_uart_init(void)\n{\n\tint err;\n\n\tBT_INFO(\"HCI UART driver ver %s\", VERSION);\n\n\t \n\terr = tty_register_ldisc(&hci_uart_ldisc);\n\tif (err) {\n\t\tBT_ERR(\"HCI line discipline registration failed. (%d)\", err);\n\t\treturn err;\n\t}\n\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_init();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_init();\n#endif\n\n\treturn 0;\n}\n\nstatic void __exit hci_uart_exit(void)\n{\n#ifdef CONFIG_BT_HCIUART_H4\n\th4_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCSP\n\tbcsp_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_LL\n\tll_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_ATH3K\n\tath_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_3WIRE\n\th5_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_INTEL\n\tintel_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_BCM\n\tbcm_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_QCA\n\tqca_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_AG6XX\n\tag6xx_deinit();\n#endif\n#ifdef CONFIG_BT_HCIUART_MRVL\n\tmrvl_deinit();\n#endif\n\n\ttty_unregister_ldisc(&hci_uart_ldisc);\n}\n\nmodule_init(hci_uart_init);\nmodule_exit(hci_uart_exit);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth HCI UART driver ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_LDISC(N_HCI);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}