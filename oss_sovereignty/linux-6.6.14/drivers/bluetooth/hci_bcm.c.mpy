{
  "module_name": "hci_bcm.c",
  "hash_id": "2064ec2ac61f6af2ae188aac4032a095f337ef1d122878e86da3a0410cd7db72",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_bcm.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/skbuff.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/property.h>\n#include <linux/platform_data/x86/apple.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/machine.h>\n#include <linux/tty.h>\n#include <linux/interrupt.h>\n#include <linux/dmi.h>\n#include <linux/pm_runtime.h>\n#include <linux/serdev.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btbcm.h\"\n#include \"hci_uart.h\"\n\n#define BCM_NULL_PKT 0x00\n#define BCM_NULL_SIZE 0\n\n#define BCM_LM_DIAG_PKT 0x07\n#define BCM_LM_DIAG_SIZE 63\n\n#define BCM_TYPE49_PKT 0x31\n#define BCM_TYPE49_SIZE 0\n\n#define BCM_TYPE52_PKT 0x34\n#define BCM_TYPE52_SIZE 0\n\n#define BCM_AUTOSUSPEND_DELAY\t5000  \n\n#define BCM_NUM_SUPPLIES 2\n\n \nstruct bcm_device_data {\n\tbool\tno_early_set_baudrate;\n\tbool\tdrive_rts_on_open;\n\tbool\tno_uart_clock_set;\n\tu32\tmax_autobaud_speed;\n\tu32\tmax_speed;\n};\n\n \nstruct bcm_device {\n\t \n\tstruct hci_uart\t\tserdev_hu;\n\tstruct list_head\tlist;\n\n\tstruct device\t\t*dev;\n\n\tconst char\t\t*name;\n\tstruct gpio_desc\t*device_wakeup;\n\tstruct gpio_desc\t*shutdown;\n\tstruct gpio_desc\t*reset;\n\tint\t\t\t(*set_device_wakeup)(struct bcm_device *, bool);\n\tint\t\t\t(*set_shutdown)(struct bcm_device *, bool);\n#ifdef CONFIG_ACPI\n\tacpi_handle\t\tbtlp, btpu, btpd;\n\tint\t\t\tgpio_count;\n\tint\t\t\tgpio_int_idx;\n#endif\n\n\tstruct clk\t\t*txco_clk;\n\tstruct clk\t\t*lpo_clk;\n\tstruct regulator_bulk_data supplies[BCM_NUM_SUPPLIES];\n\tbool\t\t\tres_enabled;\n\n\tu32\t\t\tinit_speed;\n\tu32\t\t\toper_speed;\n\tint\t\t\tirq;\n\tbool\t\t\tirq_active_low;\n\tbool\t\t\tirq_acquired;\n\n#ifdef CONFIG_PM\n\tstruct hci_uart\t\t*hu;\n\tbool\t\t\tis_suspended;\n#endif\n\tbool\t\t\tno_early_set_baudrate;\n\tbool\t\t\tdrive_rts_on_open;\n\tbool\t\t\tno_uart_clock_set;\n\tbool\t\t\tuse_autobaud_mode;\n\tu8\t\t\tpcm_int_params[5];\n\tu32\t\t\tmax_autobaud_speed;\n};\n\n \nstruct bcm_data {\n\tstruct sk_buff\t\t*rx_skb;\n\tstruct sk_buff_head\ttxq;\n\n\tstruct bcm_device\t*dev;\n};\n\n \nstatic DEFINE_MUTEX(bcm_device_lock);\nstatic LIST_HEAD(bcm_device_list);\n\nstatic int irq_polarity = -1;\nmodule_param(irq_polarity, int, 0444);\nMODULE_PARM_DESC(irq_polarity, \"IRQ polarity 0: active-high 1: active-low\");\n\nstatic inline void host_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tif (hu->serdev)\n\t\tserdev_device_set_baudrate(hu->serdev, speed);\n\telse\n\t\thci_uart_set_baudrate(hu, speed);\n}\n\nstatic int bcm_set_baudrate(struct hci_uart *hu, unsigned int speed)\n{\n\tstruct hci_dev *hdev = hu->hdev;\n\tstruct bcm_data *bcm = hu->priv;\n\tstruct sk_buff *skb;\n\tstruct bcm_update_uart_baud_rate param;\n\n\tif (speed > 3000000 && !bcm->dev->no_uart_clock_set) {\n\t\tstruct bcm_write_uart_clock_setting clock;\n\n\t\tclock.type = BCM_UART_CLOCK_48MHZ;\n\n\t\tbt_dev_dbg(hdev, \"Set Controller clock (%d)\", clock.type);\n\n\t\t \n\t\tskb = __hci_cmd_sync(hdev, 0xfc45, 1, &clock, HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\tint err = PTR_ERR(skb);\n\t\t\tbt_dev_err(hdev, \"BCM: failed to write clock (%d)\",\n\t\t\t\t   err);\n\t\t\treturn err;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\tbt_dev_dbg(hdev, \"Set Controller UART speed to %d bit/s\", speed);\n\n\tparam.zero = cpu_to_le16(0);\n\tparam.baud_rate = cpu_to_le32(speed);\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc18, sizeof(param), &param,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"BCM: failed to write update baudrate (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\n \nstatic bool bcm_device_exists(struct bcm_device *device)\n{\n\tstruct list_head *p;\n\n#ifdef CONFIG_PM\n\t \n\tif (device && device->hu && device->hu->serdev)\n\t\treturn true;\n#endif\n\n\tlist_for_each(p, &bcm_device_list) {\n\t\tstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\n\n\t\tif (device == dev)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int bcm_gpio_set_power(struct bcm_device *dev, bool powered)\n{\n\tint err;\n\n\tif (powered && !dev->res_enabled) {\n\t\t \n\t\tif (dev->supplies[0].supply) {\n\t\t\terr = regulator_bulk_enable(BCM_NUM_SUPPLIES,\n\t\t\t\t\t\t    dev->supplies);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = clk_set_rate(dev->lpo_clk, 32768);\n\t\tif (err) {\n\t\t\tdev_err(dev->dev, \"Could not set LPO clock rate\\n\");\n\t\t\tgoto err_regulator_disable;\n\t\t}\n\n\t\terr = clk_prepare_enable(dev->lpo_clk);\n\t\tif (err)\n\t\t\tgoto err_regulator_disable;\n\n\t\terr = clk_prepare_enable(dev->txco_clk);\n\t\tif (err)\n\t\t\tgoto err_lpo_clk_disable;\n\t}\n\n\terr = dev->set_shutdown(dev, powered);\n\tif (err)\n\t\tgoto err_txco_clk_disable;\n\n\terr = dev->set_device_wakeup(dev, powered);\n\tif (err)\n\t\tgoto err_revert_shutdown;\n\n\tif (!powered && dev->res_enabled) {\n\t\tclk_disable_unprepare(dev->txco_clk);\n\t\tclk_disable_unprepare(dev->lpo_clk);\n\n\t\t \n\t\tif (dev->supplies[0].supply)\n\t\t\tregulator_bulk_disable(BCM_NUM_SUPPLIES,\n\t\t\t\t\t       dev->supplies);\n\t}\n\n\t \n\tusleep_range(100000, 120000);\n\n\tdev->res_enabled = powered;\n\n\treturn 0;\n\nerr_revert_shutdown:\n\tdev->set_shutdown(dev, !powered);\nerr_txco_clk_disable:\n\tif (powered && !dev->res_enabled)\n\t\tclk_disable_unprepare(dev->txco_clk);\nerr_lpo_clk_disable:\n\tif (powered && !dev->res_enabled)\n\t\tclk_disable_unprepare(dev->lpo_clk);\nerr_regulator_disable:\n\tif (powered && !dev->res_enabled)\n\t\tregulator_bulk_disable(BCM_NUM_SUPPLIES, dev->supplies);\n\treturn err;\n}\n\n#ifdef CONFIG_PM\nstatic irqreturn_t bcm_host_wake(int irq, void *data)\n{\n\tstruct bcm_device *bdev = data;\n\n\tbt_dev_dbg(bdev, \"Host wake IRQ\");\n\n\tpm_runtime_get(bdev->dev);\n\tpm_runtime_mark_last_busy(bdev->dev);\n\tpm_runtime_put_autosuspend(bdev->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int bcm_request_irq(struct bcm_data *bcm)\n{\n\tstruct bcm_device *bdev = bcm->dev;\n\tint err;\n\n\tmutex_lock(&bcm_device_lock);\n\tif (!bcm_device_exists(bdev)) {\n\t\terr = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (bdev->irq <= 0) {\n\t\terr = -EOPNOTSUPP;\n\t\tgoto unlock;\n\t}\n\n\terr = devm_request_irq(bdev->dev, bdev->irq, bcm_host_wake,\n\t\t\t       bdev->irq_active_low ? IRQF_TRIGGER_FALLING :\n\t\t\t\t\t\t      IRQF_TRIGGER_RISING,\n\t\t\t       \"host_wake\", bdev);\n\tif (err) {\n\t\tbdev->irq = err;\n\t\tgoto unlock;\n\t}\n\n\tbdev->irq_acquired = true;\n\n\tdevice_init_wakeup(bdev->dev, true);\n\n\tpm_runtime_set_autosuspend_delay(bdev->dev,\n\t\t\t\t\t BCM_AUTOSUSPEND_DELAY);\n\tpm_runtime_use_autosuspend(bdev->dev);\n\tpm_runtime_set_active(bdev->dev);\n\tpm_runtime_enable(bdev->dev);\n\nunlock:\n\tmutex_unlock(&bcm_device_lock);\n\n\treturn err;\n}\n\nstatic const struct bcm_set_sleep_mode default_sleep_params = {\n\t.sleep_mode = 1,\t \n\t.idle_host = 2,\t\t \n\t.idle_dev = 2,\t\t \n\t.bt_wake_active = 1,\t \n\t.host_wake_active = 0,\t \n\t.allow_host_sleep = 1,\t \n\t.combine_modes = 1,\t \n\t.tristate_control = 0,\t \n\t \n\t.usb_auto_sleep = 0,\n\t.usb_resume_timeout = 0,\n\t.break_to_host = 0,\n\t.pulsed_host_wake = 1,\n};\n\nstatic int bcm_setup_sleep(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\tstruct sk_buff *skb;\n\tstruct bcm_set_sleep_mode sleep_params = default_sleep_params;\n\n\tsleep_params.host_wake_active = !bcm->dev->irq_active_low;\n\n\tskb = __hci_cmd_sync(hu->hdev, 0xfc27, sizeof(sleep_params),\n\t\t\t     &sleep_params, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\t\tbt_dev_err(hu->hdev, \"Sleep VSC failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\tbt_dev_dbg(hu->hdev, \"Set Sleep Parameters VSC succeeded\");\n\n\treturn 0;\n}\n#else\nstatic inline int bcm_request_irq(struct bcm_data *bcm) { return 0; }\nstatic inline int bcm_setup_sleep(struct hci_uart *hu) { return 0; }\n#endif\n\nstatic int bcm_set_diag(struct hci_dev *hdev, bool enable)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct bcm_data *bcm = hu->priv;\n\tstruct sk_buff *skb;\n\n\tif (!test_bit(HCI_RUNNING, &hdev->flags))\n\t\treturn -ENETDOWN;\n\n\tskb = bt_skb_alloc(3, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_u8(skb, BCM_LM_DIAG_PKT);\n\tskb_put_u8(skb, 0xf0);\n\tskb_put_u8(skb, enable);\n\n\tskb_queue_tail(&bcm->txq, skb);\n\thci_uart_tx_wakeup(hu);\n\n\treturn 0;\n}\n\nstatic int bcm_open(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm;\n\tstruct list_head *p;\n\tint err;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\tif (!hci_uart_has_flow_control(hu))\n\t\treturn -EOPNOTSUPP;\n\n\tbcm = kzalloc(sizeof(*bcm), GFP_KERNEL);\n\tif (!bcm)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&bcm->txq);\n\n\thu->priv = bcm;\n\n\tmutex_lock(&bcm_device_lock);\n\n\tif (hu->serdev) {\n\t\tbcm->dev = serdev_device_get_drvdata(hu->serdev);\n\t\tgoto out;\n\t}\n\n\tif (!hu->tty->dev)\n\t\tgoto out;\n\n\tlist_for_each(p, &bcm_device_list) {\n\t\tstruct bcm_device *dev = list_entry(p, struct bcm_device, list);\n\n\t\t \n\t\tif (hu->tty->dev->parent == dev->dev->parent) {\n\t\t\tbcm->dev = dev;\n#ifdef CONFIG_PM\n\t\t\tdev->hu = hu;\n#endif\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (bcm->dev) {\n\t\tif (bcm->dev->use_autobaud_mode)\n\t\t\thci_uart_set_flow_control(hu, false);\t \n\t\telse if (bcm->dev->drive_rts_on_open)\n\t\t\thci_uart_set_flow_control(hu, true);\n\n\t\tif (bcm->dev->use_autobaud_mode && bcm->dev->max_autobaud_speed)\n\t\t\thu->init_speed = min(bcm->dev->oper_speed, bcm->dev->max_autobaud_speed);\n\t\telse\n\t\t\thu->init_speed = bcm->dev->init_speed;\n\n\t\t \n\t\tif (!bcm->dev->no_early_set_baudrate && !bcm->dev->use_autobaud_mode)\n\t\t\thu->oper_speed = bcm->dev->oper_speed;\n\n\t\terr = bcm_gpio_set_power(bcm->dev, true);\n\n\t\tif (bcm->dev->drive_rts_on_open)\n\t\t\thci_uart_set_flow_control(hu, false);\n\n\t\tif (err)\n\t\t\tgoto err_unset_hu;\n\t}\n\n\tmutex_unlock(&bcm_device_lock);\n\treturn 0;\n\nerr_unset_hu:\n#ifdef CONFIG_PM\n\tif (!hu->serdev)\n\t\tbcm->dev->hu = NULL;\n#endif\n\tmutex_unlock(&bcm_device_lock);\n\thu->priv = NULL;\n\tkfree(bcm);\n\treturn err;\n}\n\nstatic int bcm_close(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\tstruct bcm_device *bdev = NULL;\n\tint err;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\t \n\tmutex_lock(&bcm_device_lock);\n\n\tif (hu->serdev) {\n\t\tbdev = serdev_device_get_drvdata(hu->serdev);\n\t} else if (bcm_device_exists(bcm->dev)) {\n\t\tbdev = bcm->dev;\n#ifdef CONFIG_PM\n\t\tbdev->hu = NULL;\n#endif\n\t}\n\n\tif (bdev) {\n\t\tif (IS_ENABLED(CONFIG_PM) && bdev->irq_acquired) {\n\t\t\tdevm_free_irq(bdev->dev, bdev->irq, bdev);\n\t\t\tdevice_init_wakeup(bdev->dev, false);\n\t\t\tpm_runtime_disable(bdev->dev);\n\t\t}\n\n\t\terr = bcm_gpio_set_power(bdev, false);\n\t\tif (err)\n\t\t\tbt_dev_err(hu->hdev, \"Failed to power down\");\n\t\telse\n\t\t\tpm_runtime_set_suspended(bdev->dev);\n\t}\n\tmutex_unlock(&bcm_device_lock);\n\n\tskb_queue_purge(&bcm->txq);\n\tkfree_skb(bcm->rx_skb);\n\tkfree(bcm);\n\n\thu->priv = NULL;\n\treturn 0;\n}\n\nstatic int bcm_flush(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\tskb_queue_purge(&bcm->txq);\n\n\treturn 0;\n}\n\nstatic int bcm_setup(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\tbool fw_load_done = false;\n\tbool use_autobaud_mode = (bcm->dev ? bcm->dev->use_autobaud_mode : 0);\n\tunsigned int speed;\n\tint err;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p\", hu);\n\n\thu->hdev->set_diag = bcm_set_diag;\n\thu->hdev->set_bdaddr = btbcm_set_bdaddr;\n\n\terr = btbcm_initialize(hu->hdev, &fw_load_done, use_autobaud_mode);\n\tif (err)\n\t\treturn err;\n\n\tif (!fw_load_done)\n\t\treturn 0;\n\n\t \n\tif (bcm->dev && bcm->dev->init_speed)\n\t\tspeed = bcm->dev->init_speed;\n\telse if (hu->proto->init_speed)\n\t\tspeed = hu->proto->init_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed)\n\t\thost_set_baudrate(hu, speed);\n\n\t \n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (bcm->dev && bcm->dev->oper_speed)\n\t\tspeed = bcm->dev->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed) {\n\t\terr = bcm_set_baudrate(hu, speed);\n\t\tif (!err)\n\t\t\thost_set_baudrate(hu, speed);\n\t}\n\n\t \n\tif (bcm->dev && bcm->dev->pcm_int_params[0] != 0xff) {\n\t\tstruct bcm_set_pcm_int_params params;\n\n\t\tbtbcm_read_pcm_int_params(hu->hdev, &params);\n\n\t\tmemcpy(&params, bcm->dev->pcm_int_params, 5);\n\t\tbtbcm_write_pcm_int_params(hu->hdev, &params);\n\t}\n\n\terr = btbcm_finalize(hu->hdev, &fw_load_done, use_autobaud_mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (test_bit(HCI_QUIRK_INVALID_BDADDR, &hu->hdev->quirks))\n\t\tset_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hu->hdev->quirks);\n\n\tif (!bcm_request_irq(bcm))\n\t\terr = bcm_setup_sleep(hu);\n\n\treturn err;\n}\n\n#define BCM_RECV_LM_DIAG \\\n\t.type = BCM_LM_DIAG_PKT, \\\n\t.hlen = BCM_LM_DIAG_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = BCM_LM_DIAG_SIZE\n\n#define BCM_RECV_NULL \\\n\t.type = BCM_NULL_PKT, \\\n\t.hlen = BCM_NULL_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = BCM_NULL_SIZE\n\n#define BCM_RECV_TYPE49 \\\n\t.type = BCM_TYPE49_PKT, \\\n\t.hlen = BCM_TYPE49_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = BCM_TYPE49_SIZE\n\n#define BCM_RECV_TYPE52 \\\n\t.type = BCM_TYPE52_PKT, \\\n\t.hlen = BCM_TYPE52_SIZE, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = BCM_TYPE52_SIZE\n\nstatic const struct h4_recv_pkt bcm_recv_pkts[] = {\n\t{ H4_RECV_ACL,      .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,      .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,    .recv = hci_recv_frame },\n\t{ H4_RECV_ISO,      .recv = hci_recv_frame },\n\t{ BCM_RECV_LM_DIAG, .recv = hci_recv_diag  },\n\t{ BCM_RECV_NULL,    .recv = hci_recv_diag  },\n\t{ BCM_RECV_TYPE49,  .recv = hci_recv_diag  },\n\t{ BCM_RECV_TYPE52,  .recv = hci_recv_diag  },\n};\n\nstatic int bcm_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tbcm->rx_skb = h4_recv_buf(hu->hdev, bcm->rx_skb, data, count,\n\t\t\t\t  bcm_recv_pkts, ARRAY_SIZE(bcm_recv_pkts));\n\tif (IS_ERR(bcm->rx_skb)) {\n\t\tint err = PTR_ERR(bcm->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tbcm->rx_skb = NULL;\n\t\treturn err;\n\t} else if (!bcm->rx_skb) {\n\t\t \n\t\tmutex_lock(&bcm_device_lock);\n\t\tif (bcm->dev && bcm_device_exists(bcm->dev)) {\n\t\t\tpm_runtime_get(bcm->dev->dev);\n\t\t\tpm_runtime_mark_last_busy(bcm->dev->dev);\n\t\t\tpm_runtime_put_autosuspend(bcm->dev->dev);\n\t\t}\n\t\tmutex_unlock(&bcm_device_lock);\n\t}\n\n\treturn count;\n}\n\nstatic int bcm_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\n\tbt_dev_dbg(hu->hdev, \"hu %p skb %p\", hu, skb);\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\tskb_queue_tail(&bcm->txq, skb);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *bcm_dequeue(struct hci_uart *hu)\n{\n\tstruct bcm_data *bcm = hu->priv;\n\tstruct sk_buff *skb = NULL;\n\tstruct bcm_device *bdev = NULL;\n\n\tmutex_lock(&bcm_device_lock);\n\n\tif (bcm_device_exists(bcm->dev)) {\n\t\tbdev = bcm->dev;\n\t\tpm_runtime_get_sync(bdev->dev);\n\t\t \n\t}\n\n\tskb = skb_dequeue(&bcm->txq);\n\n\tif (bdev) {\n\t\tpm_runtime_mark_last_busy(bdev->dev);\n\t\tpm_runtime_put_autosuspend(bdev->dev);\n\t}\n\n\tmutex_unlock(&bcm_device_lock);\n\n\treturn skb;\n}\n\n#ifdef CONFIG_PM\nstatic int bcm_suspend_device(struct device *dev)\n{\n\tstruct bcm_device *bdev = dev_get_drvdata(dev);\n\tint err;\n\n\tbt_dev_dbg(bdev, \"\");\n\n\tif (!bdev->is_suspended && bdev->hu) {\n\t\thci_uart_set_flow_control(bdev->hu, true);\n\n\t\t \n\t\tbdev->is_suspended = true;\n\t}\n\n\t \n\terr = bdev->set_device_wakeup(bdev, false);\n\tif (err) {\n\t\tif (bdev->is_suspended && bdev->hu) {\n\t\t\tbdev->is_suspended = false;\n\t\t\thci_uart_set_flow_control(bdev->hu, false);\n\t\t}\n\t\treturn -EBUSY;\n\t}\n\n\tbt_dev_dbg(bdev, \"suspend, delaying 15 ms\");\n\tmsleep(15);\n\n\treturn 0;\n}\n\nstatic int bcm_resume_device(struct device *dev)\n{\n\tstruct bcm_device *bdev = dev_get_drvdata(dev);\n\tint err;\n\n\tbt_dev_dbg(bdev, \"\");\n\n\terr = bdev->set_device_wakeup(bdev, true);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to power up\\n\");\n\t\treturn err;\n\t}\n\n\tbt_dev_dbg(bdev, \"resume, delaying 15 ms\");\n\tmsleep(15);\n\n\t \n\tif (bdev->is_suspended && bdev->hu) {\n\t\tbdev->is_suspended = false;\n\n\t\thci_uart_set_flow_control(bdev->hu, false);\n\t}\n\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PM_SLEEP\n \nstatic int bcm_suspend(struct device *dev)\n{\n\tstruct bcm_device *bdev = dev_get_drvdata(dev);\n\tint error;\n\n\tbt_dev_dbg(bdev, \"suspend: is_suspended %d\", bdev->is_suspended);\n\n\t \n\tmutex_lock(&bcm_device_lock);\n\n\tif (!bdev->hu)\n\t\tgoto unlock;\n\n\tif (pm_runtime_active(dev))\n\t\tbcm_suspend_device(dev);\n\n\tif (device_may_wakeup(dev) && bdev->irq > 0) {\n\t\terror = enable_irq_wake(bdev->irq);\n\t\tif (!error)\n\t\t\tbt_dev_dbg(bdev, \"BCM irq: enabled\");\n\t}\n\nunlock:\n\tmutex_unlock(&bcm_device_lock);\n\n\treturn 0;\n}\n\n \nstatic int bcm_resume(struct device *dev)\n{\n\tstruct bcm_device *bdev = dev_get_drvdata(dev);\n\tint err = 0;\n\n\tbt_dev_dbg(bdev, \"resume: is_suspended %d\", bdev->is_suspended);\n\n\t \n\tmutex_lock(&bcm_device_lock);\n\n\tif (!bdev->hu)\n\t\tgoto unlock;\n\n\tif (device_may_wakeup(dev) && bdev->irq > 0) {\n\t\tdisable_irq_wake(bdev->irq);\n\t\tbt_dev_dbg(bdev, \"BCM irq: disabled\");\n\t}\n\n\terr = bcm_resume_device(dev);\n\nunlock:\n\tmutex_unlock(&bcm_device_lock);\n\n\tif (!err) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn 0;\n}\n#endif\n\n \nstatic struct gpiod_lookup_table irq_on_int33fc02_pin17_gpios = {\n\t.dev_id = \"serial0-0\",\n\t.table = {\n\t\tGPIO_LOOKUP(\"INT33FC:02\", 17, \"host-wakeup-alt\", GPIO_ACTIVE_HIGH),\n\t\t{ }\n\t},\n};\n\nstatic const struct dmi_system_id bcm_broken_irq_dmi_table[] = {\n\t{\n\t\t.ident = \"Acer Iconia One 7 B1-750\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Insyde\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VESPA2\"),\n\t\t},\n\t\t.driver_data = &irq_on_int33fc02_pin17_gpios,\n\t},\n\t{\n\t\t.ident = \"Asus TF103C\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TF103C\"),\n\t\t},\n\t\t.driver_data = &irq_on_int33fc02_pin17_gpios,\n\t},\n\t{\n\t\t.ident = \"Lenovo Yoga Tablet 2 830F/L / 1050F/L\",\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"Intel Corp.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"VALLEYVIEW C0 PLATFORM\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"BYT-T FFD8\"),\n\t\t\t \n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"BLADE_21\"),\n\t\t},\n\t\t.driver_data = &irq_on_int33fc02_pin17_gpios,\n\t},\n\t{\n\t\t.ident = \"Meegopad T08\",\n\t\t.matches = {\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VENDOR,\n\t\t\t\t\t\"To be filled by OEM.\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_NAME, \"T3 MRD\"),\n\t\t\tDMI_EXACT_MATCH(DMI_BOARD_VERSION, \"V1.1\"),\n\t\t},\n\t},\n\t{ }\n};\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_gpio_params first_gpio = { 0, 0, false };\nstatic const struct acpi_gpio_params second_gpio = { 1, 0, false };\nstatic const struct acpi_gpio_params third_gpio = { 2, 0, false };\n\nstatic const struct acpi_gpio_mapping acpi_bcm_int_last_gpios[] = {\n\t{ \"device-wakeup-gpios\", &first_gpio, 1 },\n\t{ \"shutdown-gpios\", &second_gpio, 1 },\n\t{ \"host-wakeup-gpios\", &third_gpio, 1 },\n\t{ },\n};\n\nstatic const struct acpi_gpio_mapping acpi_bcm_int_first_gpios[] = {\n\t{ \"host-wakeup-gpios\", &first_gpio, 1 },\n\t{ \"device-wakeup-gpios\", &second_gpio, 1 },\n\t{ \"shutdown-gpios\", &third_gpio, 1 },\n\t{ },\n};\n\nstatic int bcm_resource(struct acpi_resource *ares, void *data)\n{\n\tstruct bcm_device *dev = data;\n\tstruct acpi_resource_extended_irq *irq;\n\tstruct acpi_resource_gpio *gpio;\n\tstruct acpi_resource_uart_serialbus *sb;\n\n\tswitch (ares->type) {\n\tcase ACPI_RESOURCE_TYPE_EXTENDED_IRQ:\n\t\tirq = &ares->data.extended_irq;\n\t\tif (irq->polarity != ACPI_ACTIVE_LOW)\n\t\t\tdev_info(dev->dev, \"ACPI Interrupt resource is active-high, this is usually wrong, treating the IRQ as active-low\\n\");\n\t\tdev->irq_active_low = true;\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_GPIO:\n\t\tgpio = &ares->data.gpio;\n\t\tif (gpio->connection_type == ACPI_RESOURCE_GPIO_TYPE_INT) {\n\t\t\tdev->gpio_int_idx = dev->gpio_count;\n\t\t\tdev->irq_active_low = gpio->polarity == ACPI_ACTIVE_LOW;\n\t\t}\n\t\tdev->gpio_count++;\n\t\tbreak;\n\n\tcase ACPI_RESOURCE_TYPE_SERIAL_BUS:\n\t\tsb = &ares->data.uart_serial_bus;\n\t\tif (sb->type == ACPI_RESOURCE_SERIAL_TYPE_UART) {\n\t\t\tdev->init_speed = sb->default_baud_rate;\n\t\t\tdev->oper_speed = 4000000;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int bcm_apple_set_device_wakeup(struct bcm_device *dev, bool awake)\n{\n\tif (ACPI_FAILURE(acpi_execute_simple_method(dev->btlp, NULL, !awake)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int bcm_apple_set_shutdown(struct bcm_device *dev, bool powered)\n{\n\tif (ACPI_FAILURE(acpi_evaluate_object(powered ? dev->btpu : dev->btpd,\n\t\t\t\t\t      NULL, NULL, NULL)))\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int bcm_apple_get_resources(struct bcm_device *dev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(dev->dev);\n\tconst union acpi_object *obj;\n\n\tif (!adev ||\n\t    ACPI_FAILURE(acpi_get_handle(adev->handle, \"BTLP\", &dev->btlp)) ||\n\t    ACPI_FAILURE(acpi_get_handle(adev->handle, \"BTPU\", &dev->btpu)) ||\n\t    ACPI_FAILURE(acpi_get_handle(adev->handle, \"BTPD\", &dev->btpd)))\n\t\treturn -ENODEV;\n\n\tif (!acpi_dev_get_property(adev, \"baud\", ACPI_TYPE_BUFFER, &obj) &&\n\t    obj->buffer.length == 8)\n\t\tdev->init_speed = *(u64 *)obj->buffer.pointer;\n\n\tdev->set_device_wakeup = bcm_apple_set_device_wakeup;\n\tdev->set_shutdown = bcm_apple_set_shutdown;\n\n\treturn 0;\n}\n#else\nstatic inline int bcm_apple_get_resources(struct bcm_device *dev)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif  \n\nstatic int bcm_gpio_set_device_wakeup(struct bcm_device *dev, bool awake)\n{\n\tgpiod_set_value_cansleep(dev->device_wakeup, awake);\n\treturn 0;\n}\n\nstatic int bcm_gpio_set_shutdown(struct bcm_device *dev, bool powered)\n{\n\tgpiod_set_value_cansleep(dev->shutdown, powered);\n\tif (dev->reset)\n\t\t \n\t\tgpiod_set_value_cansleep(dev->reset, !powered);\n\treturn 0;\n}\n\n \nstatic struct clk *bcm_get_txco(struct device *dev)\n{\n\tstruct clk *clk;\n\n\t \n\tclk = devm_clk_get(dev, \"txco\");\n\tif (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)\n\t\treturn clk;\n\n\t \n\tclk = devm_clk_get(dev, \"extclk\");\n\tif (!IS_ERR(clk) || PTR_ERR(clk) == -EPROBE_DEFER)\n\t\treturn clk;\n\n\t \n\treturn devm_clk_get(dev, NULL);\n}\n\nstatic int bcm_get_resources(struct bcm_device *dev)\n{\n\tconst struct dmi_system_id *broken_irq_dmi_id;\n\tconst char *irq_con_id = \"host-wakeup\";\n\tint err;\n\n\tdev->name = dev_name(dev->dev);\n\n\tif (x86_apple_machine && !bcm_apple_get_resources(dev))\n\t\treturn 0;\n\n\tdev->txco_clk = bcm_get_txco(dev->dev);\n\n\t \n\tif (dev->txco_clk == ERR_PTR(-EPROBE_DEFER))\n\t\treturn PTR_ERR(dev->txco_clk);\n\n\t \n\tif (IS_ERR(dev->txco_clk))\n\t\tdev->txco_clk = NULL;\n\n\tdev->lpo_clk = devm_clk_get(dev->dev, \"lpo\");\n\tif (dev->lpo_clk == ERR_PTR(-EPROBE_DEFER))\n\t\treturn PTR_ERR(dev->lpo_clk);\n\n\tif (IS_ERR(dev->lpo_clk))\n\t\tdev->lpo_clk = NULL;\n\n\t \n\tif (dev->lpo_clk && clk_is_match(dev->lpo_clk, dev->txco_clk)) {\n\t\tdevm_clk_put(dev->dev, dev->txco_clk);\n\t\tdev->txco_clk = NULL;\n\t}\n\n\tdev->device_wakeup = devm_gpiod_get_optional(dev->dev, \"device-wakeup\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(dev->device_wakeup))\n\t\treturn PTR_ERR(dev->device_wakeup);\n\n\tdev->shutdown = devm_gpiod_get_optional(dev->dev, \"shutdown\",\n\t\t\t\t\t\tGPIOD_OUT_LOW);\n\tif (IS_ERR(dev->shutdown))\n\t\treturn PTR_ERR(dev->shutdown);\n\n\tdev->reset = devm_gpiod_get_optional(dev->dev, \"reset\",\n\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(dev->reset))\n\t\treturn PTR_ERR(dev->reset);\n\n\tdev->set_device_wakeup = bcm_gpio_set_device_wakeup;\n\tdev->set_shutdown = bcm_gpio_set_shutdown;\n\n\tdev->supplies[0].supply = \"vbat\";\n\tdev->supplies[1].supply = \"vddio\";\n\terr = devm_regulator_bulk_get(dev->dev, BCM_NUM_SUPPLIES,\n\t\t\t\t      dev->supplies);\n\tif (err)\n\t\treturn err;\n\n\tbroken_irq_dmi_id = dmi_first_match(bcm_broken_irq_dmi_table);\n\tif (broken_irq_dmi_id && broken_irq_dmi_id->driver_data) {\n\t\tgpiod_add_lookup_table(broken_irq_dmi_id->driver_data);\n\t\tirq_con_id = \"host-wakeup-alt\";\n\t\tdev->irq_active_low = false;\n\t\tdev->irq = 0;\n\t}\n\n\t \n\tif (dev->irq <= 0) {\n\t\tstruct gpio_desc *gpio;\n\n\t\tgpio = devm_gpiod_get_optional(dev->dev, irq_con_id, GPIOD_IN);\n\t\tif (IS_ERR(gpio))\n\t\t\treturn PTR_ERR(gpio);\n\n\t\tdev->irq = gpiod_to_irq(gpio);\n\t}\n\n\tif (broken_irq_dmi_id) {\n\t\tif (broken_irq_dmi_id->driver_data) {\n\t\t\tgpiod_remove_lookup_table(broken_irq_dmi_id->driver_data);\n\t\t} else {\n\t\t\tdev_info(dev->dev, \"%s: Has a broken IRQ config, disabling IRQ support / runtime-pm\\n\",\n\t\t\t\t broken_irq_dmi_id->ident);\n\t\t\tdev->irq = 0;\n\t\t}\n\t}\n\n\tdev_dbg(dev->dev, \"BCM irq: %d\\n\", dev->irq);\n\treturn 0;\n}\n\n#ifdef CONFIG_ACPI\nstatic int bcm_acpi_probe(struct bcm_device *dev)\n{\n\tLIST_HEAD(resources);\n\tconst struct acpi_gpio_mapping *gpio_mapping = acpi_bcm_int_last_gpios;\n\tstruct resource_entry *entry;\n\tint ret;\n\n\t \n\tdev->gpio_int_idx = -1;\n\tret = acpi_dev_get_resources(ACPI_COMPANION(dev->dev),\n\t\t\t\t     &resources, bcm_resource, dev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tresource_list_for_each_entry(entry, &resources) {\n\t\tif (resource_type(entry->res) == IORESOURCE_IRQ) {\n\t\t\tdev->irq = entry->res->start;\n\t\t\tbreak;\n\t\t}\n\t}\n\tacpi_dev_free_resource_list(&resources);\n\n\t \n\tif (dev->irq)\n\t\tgpio_mapping = acpi_bcm_int_last_gpios;\n\telse if (dev->gpio_int_idx == 0)\n\t\tgpio_mapping = acpi_bcm_int_first_gpios;\n\telse if (dev->gpio_int_idx == 2)\n\t\tgpio_mapping = acpi_bcm_int_last_gpios;\n\telse\n\t\tdev_warn(dev->dev, \"Unexpected ACPI gpio_int_idx: %d\\n\",\n\t\t\t dev->gpio_int_idx);\n\n\t \n\tif (dev->gpio_count != (dev->irq ? 2 : 3))\n\t\tdev_warn(dev->dev, \"Unexpected number of ACPI GPIOs: %d\\n\",\n\t\t\t dev->gpio_count);\n\n\tret = devm_acpi_dev_add_driver_gpios(dev->dev, gpio_mapping);\n\tif (ret)\n\t\treturn ret;\n\n\tif (irq_polarity != -1) {\n\t\tdev->irq_active_low = irq_polarity;\n\t\tdev_warn(dev->dev, \"Overwriting IRQ polarity to active %s by module-param\\n\",\n\t\t\t dev->irq_active_low ? \"low\" : \"high\");\n\t}\n\n\treturn 0;\n}\n#else\nstatic int bcm_acpi_probe(struct bcm_device *dev)\n{\n\treturn -EINVAL;\n}\n#endif  \n\nstatic int bcm_of_probe(struct bcm_device *bdev)\n{\n\tbdev->use_autobaud_mode = device_property_read_bool(bdev->dev,\n\t\t\t\t\t\t\t    \"brcm,requires-autobaud-mode\");\n\tdevice_property_read_u32(bdev->dev, \"max-speed\", &bdev->oper_speed);\n\tdevice_property_read_u8_array(bdev->dev, \"brcm,bt-pcm-int-params\",\n\t\t\t\t      bdev->pcm_int_params, 5);\n\tbdev->irq = of_irq_get_byname(bdev->dev->of_node, \"host-wakeup\");\n\tbdev->irq_active_low = irq_get_trigger_type(bdev->irq)\n\t\t\t     & (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_LEVEL_LOW);\n\treturn 0;\n}\n\nstatic int bcm_probe(struct platform_device *pdev)\n{\n\tstruct bcm_device *dev;\n\tint ret;\n\n\tdev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tdev->dev = &pdev->dev;\n\n\tret = platform_get_irq(pdev, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tdev->irq = ret;\n\n\t \n\tdev->pcm_int_params[0] = 0xff;\n\n\tif (has_acpi_companion(&pdev->dev)) {\n\t\tret = bcm_acpi_probe(dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = bcm_get_resources(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tplatform_set_drvdata(pdev, dev);\n\n\tdev_info(&pdev->dev, \"%s device registered.\\n\", dev->name);\n\n\t \n\tmutex_lock(&bcm_device_lock);\n\tlist_add_tail(&dev->list, &bcm_device_list);\n\tmutex_unlock(&bcm_device_lock);\n\n\tret = bcm_gpio_set_power(dev, false);\n\tif (ret)\n\t\tdev_err(&pdev->dev, \"Failed to power down\\n\");\n\n\treturn 0;\n}\n\nstatic int bcm_remove(struct platform_device *pdev)\n{\n\tstruct bcm_device *dev = platform_get_drvdata(pdev);\n\n\tmutex_lock(&bcm_device_lock);\n\tlist_del(&dev->list);\n\tmutex_unlock(&bcm_device_lock);\n\n\tdev_info(&pdev->dev, \"%s device unregistered.\\n\", dev->name);\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto bcm_proto = {\n\t.id\t\t= HCI_UART_BCM,\n\t.name\t\t= \"Broadcom\",\n\t.manufacturer\t= 15,\n\t.init_speed\t= 115200,\n\t.open\t\t= bcm_open,\n\t.close\t\t= bcm_close,\n\t.flush\t\t= bcm_flush,\n\t.setup\t\t= bcm_setup,\n\t.set_baudrate\t= bcm_set_baudrate,\n\t.recv\t\t= bcm_recv,\n\t.enqueue\t= bcm_enqueue,\n\t.dequeue\t= bcm_dequeue,\n};\n\n#ifdef CONFIG_ACPI\n\n \nstatic struct bcm_device_data bcm43430_device_data = {\n\t.max_speed = 2000000,\n};\n\nstatic const struct acpi_device_id bcm_acpi_match[] = {\n\t{ \"BCM2E00\" },\n\t{ \"BCM2E01\" },\n\t{ \"BCM2E02\" },\n\t{ \"BCM2E03\" },\n\t{ \"BCM2E04\" },\n\t{ \"BCM2E05\" },\n\t{ \"BCM2E06\" },\n\t{ \"BCM2E07\" },\n\t{ \"BCM2E08\" },\n\t{ \"BCM2E09\" },\n\t{ \"BCM2E0A\" },\n\t{ \"BCM2E0B\" },\n\t{ \"BCM2E0C\" },\n\t{ \"BCM2E0D\" },\n\t{ \"BCM2E0E\" },\n\t{ \"BCM2E0F\" },\n\t{ \"BCM2E10\" },\n\t{ \"BCM2E11\" },\n\t{ \"BCM2E12\" },\n\t{ \"BCM2E13\" },\n\t{ \"BCM2E14\" },\n\t{ \"BCM2E15\" },\n\t{ \"BCM2E16\" },\n\t{ \"BCM2E17\" },\n\t{ \"BCM2E18\" },\n\t{ \"BCM2E19\" },\n\t{ \"BCM2E1A\" },\n\t{ \"BCM2E1B\" },\n\t{ \"BCM2E1C\" },\n\t{ \"BCM2E1D\" },\n\t{ \"BCM2E1F\" },\n\t{ \"BCM2E20\" },\n\t{ \"BCM2E21\" },\n\t{ \"BCM2E22\" },\n\t{ \"BCM2E23\" },\n\t{ \"BCM2E24\" },\n\t{ \"BCM2E25\" },\n\t{ \"BCM2E26\" },\n\t{ \"BCM2E27\" },\n\t{ \"BCM2E28\" },\n\t{ \"BCM2E29\" },\n\t{ \"BCM2E2A\" },\n\t{ \"BCM2E2B\" },\n\t{ \"BCM2E2C\" },\n\t{ \"BCM2E2D\" },\n\t{ \"BCM2E2E\" },\n\t{ \"BCM2E2F\" },\n\t{ \"BCM2E30\" },\n\t{ \"BCM2E31\" },\n\t{ \"BCM2E32\" },\n\t{ \"BCM2E33\" },\n\t{ \"BCM2E34\" },\n\t{ \"BCM2E35\" },\n\t{ \"BCM2E36\" },\n\t{ \"BCM2E37\" },\n\t{ \"BCM2E38\" },\n\t{ \"BCM2E39\" },\n\t{ \"BCM2E3A\" },\n\t{ \"BCM2E3B\" },\n\t{ \"BCM2E3C\" },\n\t{ \"BCM2E3D\" },\n\t{ \"BCM2E3E\" },\n\t{ \"BCM2E3F\" },\n\t{ \"BCM2E40\" },\n\t{ \"BCM2E41\" },\n\t{ \"BCM2E42\" },\n\t{ \"BCM2E43\" },\n\t{ \"BCM2E44\" },\n\t{ \"BCM2E45\" },\n\t{ \"BCM2E46\" },\n\t{ \"BCM2E47\" },\n\t{ \"BCM2E48\" },\n\t{ \"BCM2E49\" },\n\t{ \"BCM2E4A\" },\n\t{ \"BCM2E4B\" },\n\t{ \"BCM2E4C\" },\n\t{ \"BCM2E4D\" },\n\t{ \"BCM2E4E\" },\n\t{ \"BCM2E4F\" },\n\t{ \"BCM2E50\" },\n\t{ \"BCM2E51\" },\n\t{ \"BCM2E52\" },\n\t{ \"BCM2E53\" },\n\t{ \"BCM2E54\" },\n\t{ \"BCM2E55\" },\n\t{ \"BCM2E56\" },\n\t{ \"BCM2E57\" },\n\t{ \"BCM2E58\" },\n\t{ \"BCM2E59\" },\n\t{ \"BCM2E5A\" },\n\t{ \"BCM2E5B\" },\n\t{ \"BCM2E5C\" },\n\t{ \"BCM2E5D\" },\n\t{ \"BCM2E5E\" },\n\t{ \"BCM2E5F\" },\n\t{ \"BCM2E60\" },\n\t{ \"BCM2E61\" },\n\t{ \"BCM2E62\" },\n\t{ \"BCM2E63\" },\n\t{ \"BCM2E64\" },\n\t{ \"BCM2E65\" },\n\t{ \"BCM2E66\" },\n\t{ \"BCM2E67\" },\n\t{ \"BCM2E68\" },\n\t{ \"BCM2E69\" },\n\t{ \"BCM2E6B\" },\n\t{ \"BCM2E6D\" },\n\t{ \"BCM2E6E\" },\n\t{ \"BCM2E6F\" },\n\t{ \"BCM2E70\" },\n\t{ \"BCM2E71\" },\n\t{ \"BCM2E72\" },\n\t{ \"BCM2E73\" },\n\t{ \"BCM2E74\", (long)&bcm43430_device_data },\n\t{ \"BCM2E75\", (long)&bcm43430_device_data },\n\t{ \"BCM2E76\" },\n\t{ \"BCM2E77\" },\n\t{ \"BCM2E78\" },\n\t{ \"BCM2E79\" },\n\t{ \"BCM2E7A\" },\n\t{ \"BCM2E7B\", (long)&bcm43430_device_data },\n\t{ \"BCM2E7C\" },\n\t{ \"BCM2E7D\" },\n\t{ \"BCM2E7E\" },\n\t{ \"BCM2E7F\" },\n\t{ \"BCM2E80\", (long)&bcm43430_device_data },\n\t{ \"BCM2E81\" },\n\t{ \"BCM2E82\" },\n\t{ \"BCM2E83\" },\n\t{ \"BCM2E84\" },\n\t{ \"BCM2E85\" },\n\t{ \"BCM2E86\" },\n\t{ \"BCM2E87\" },\n\t{ \"BCM2E88\" },\n\t{ \"BCM2E89\", (long)&bcm43430_device_data },\n\t{ \"BCM2E8A\" },\n\t{ \"BCM2E8B\" },\n\t{ \"BCM2E8C\" },\n\t{ \"BCM2E8D\" },\n\t{ \"BCM2E8E\" },\n\t{ \"BCM2E90\" },\n\t{ \"BCM2E92\" },\n\t{ \"BCM2E93\" },\n\t{ \"BCM2E94\", (long)&bcm43430_device_data },\n\t{ \"BCM2E95\" },\n\t{ \"BCM2E96\" },\n\t{ \"BCM2E97\" },\n\t{ \"BCM2E98\" },\n\t{ \"BCM2E99\", (long)&bcm43430_device_data },\n\t{ \"BCM2E9A\" },\n\t{ \"BCM2E9B\", (long)&bcm43430_device_data },\n\t{ \"BCM2E9C\" },\n\t{ \"BCM2E9D\" },\n\t{ \"BCM2E9F\", (long)&bcm43430_device_data },\n\t{ \"BCM2EA0\" },\n\t{ \"BCM2EA1\" },\n\t{ \"BCM2EA2\", (long)&bcm43430_device_data },\n\t{ \"BCM2EA3\", (long)&bcm43430_device_data },\n\t{ \"BCM2EA4\" },\n\t{ \"BCM2EA5\" },\n\t{ \"BCM2EA6\" },\n\t{ \"BCM2EA7\" },\n\t{ \"BCM2EA8\" },\n\t{ \"BCM2EA9\" },\n\t{ \"BCM2EAA\", (long)&bcm43430_device_data },\n\t{ \"BCM2EAB\", (long)&bcm43430_device_data },\n\t{ \"BCM2EAC\", (long)&bcm43430_device_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, bcm_acpi_match);\n#endif\n\n \nstatic const struct dev_pm_ops bcm_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(bcm_suspend, bcm_resume)\n\tSET_RUNTIME_PM_OPS(bcm_suspend_device, bcm_resume_device, NULL)\n};\n\nstatic struct platform_driver bcm_driver = {\n\t.probe = bcm_probe,\n\t.remove = bcm_remove,\n\t.driver = {\n\t\t.name = \"hci_bcm\",\n\t\t.acpi_match_table = ACPI_PTR(bcm_acpi_match),\n\t\t.pm = &bcm_pm_ops,\n\t},\n};\n\nstatic int bcm_serdev_probe(struct serdev_device *serdev)\n{\n\tstruct bcm_device *bcmdev;\n\tconst struct bcm_device_data *data;\n\tint err;\n\n\tbcmdev = devm_kzalloc(&serdev->dev, sizeof(*bcmdev), GFP_KERNEL);\n\tif (!bcmdev)\n\t\treturn -ENOMEM;\n\n\tbcmdev->dev = &serdev->dev;\n#ifdef CONFIG_PM\n\tbcmdev->hu = &bcmdev->serdev_hu;\n#endif\n\tbcmdev->serdev_hu.serdev = serdev;\n\tserdev_device_set_drvdata(serdev, bcmdev);\n\n\t \n\tbcmdev->pcm_int_params[0] = 0xff;\n\n\tif (has_acpi_companion(&serdev->dev))\n\t\terr = bcm_acpi_probe(bcmdev);\n\telse\n\t\terr = bcm_of_probe(bcmdev);\n\tif (err)\n\t\treturn err;\n\n\terr = bcm_get_resources(bcmdev);\n\tif (err)\n\t\treturn err;\n\n\tif (!bcmdev->shutdown) {\n\t\tdev_warn(&serdev->dev,\n\t\t\t \"No reset resource, using default baud rate\\n\");\n\t\tbcmdev->oper_speed = bcmdev->init_speed;\n\t}\n\n\terr = bcm_gpio_set_power(bcmdev, false);\n\tif (err)\n\t\tdev_err(&serdev->dev, \"Failed to power down\\n\");\n\n\tdata = device_get_match_data(bcmdev->dev);\n\tif (data) {\n\t\tbcmdev->max_autobaud_speed = data->max_autobaud_speed;\n\t\tbcmdev->no_early_set_baudrate = data->no_early_set_baudrate;\n\t\tbcmdev->drive_rts_on_open = data->drive_rts_on_open;\n\t\tbcmdev->no_uart_clock_set = data->no_uart_clock_set;\n\t\tif (data->max_speed && bcmdev->oper_speed > data->max_speed)\n\t\t\tbcmdev->oper_speed = data->max_speed;\n\t}\n\n\treturn hci_uart_register_device(&bcmdev->serdev_hu, &bcm_proto);\n}\n\nstatic void bcm_serdev_remove(struct serdev_device *serdev)\n{\n\tstruct bcm_device *bcmdev = serdev_device_get_drvdata(serdev);\n\n\thci_uart_unregister_device(&bcmdev->serdev_hu);\n}\n\n#ifdef CONFIG_OF\nstatic struct bcm_device_data bcm4354_device_data = {\n\t.no_early_set_baudrate = true,\n};\n\nstatic struct bcm_device_data bcm43438_device_data = {\n\t.drive_rts_on_open = true,\n};\n\nstatic struct bcm_device_data cyw4373a0_device_data = {\n\t.no_uart_clock_set = true,\n};\n\nstatic struct bcm_device_data cyw55572_device_data = {\n\t.max_autobaud_speed = 921600,\n};\n\nstatic const struct of_device_id bcm_bluetooth_of_match[] = {\n\t{ .compatible = \"brcm,bcm20702a1\" },\n\t{ .compatible = \"brcm,bcm4329-bt\" },\n\t{ .compatible = \"brcm,bcm4330-bt\" },\n\t{ .compatible = \"brcm,bcm4334-bt\" },\n\t{ .compatible = \"brcm,bcm4345c5\" },\n\t{ .compatible = \"brcm,bcm43430a0-bt\" },\n\t{ .compatible = \"brcm,bcm43430a1-bt\" },\n\t{ .compatible = \"brcm,bcm43438-bt\", .data = &bcm43438_device_data },\n\t{ .compatible = \"brcm,bcm4349-bt\", .data = &bcm43438_device_data },\n\t{ .compatible = \"brcm,bcm43540-bt\", .data = &bcm4354_device_data },\n\t{ .compatible = \"brcm,bcm4335a0\" },\n\t{ .compatible = \"cypress,cyw4373a0-bt\", .data = &cyw4373a0_device_data },\n\t{ .compatible = \"infineon,cyw55572-bt\", .data = &cyw55572_device_data },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, bcm_bluetooth_of_match);\n#endif\n\nstatic struct serdev_device_driver bcm_serdev_driver = {\n\t.probe = bcm_serdev_probe,\n\t.remove = bcm_serdev_remove,\n\t.driver = {\n\t\t.name = \"hci_uart_bcm\",\n\t\t.of_match_table = of_match_ptr(bcm_bluetooth_of_match),\n\t\t.acpi_match_table = ACPI_PTR(bcm_acpi_match),\n\t\t.pm = &bcm_pm_ops,\n\t},\n};\n\nint __init bcm_init(void)\n{\n\t \n\tplatform_driver_register(&bcm_driver);\n\tserdev_device_driver_register(&bcm_serdev_driver);\n\n\treturn hci_uart_register_proto(&bcm_proto);\n}\n\nint __exit bcm_deinit(void)\n{\n\tplatform_driver_unregister(&bcm_driver);\n\tserdev_device_driver_unregister(&bcm_serdev_driver);\n\n\treturn hci_uart_unregister_proto(&bcm_proto);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}