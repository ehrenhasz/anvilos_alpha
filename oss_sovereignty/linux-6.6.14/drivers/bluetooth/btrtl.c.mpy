{
  "module_name": "btrtl.c",
  "hash_id": "eeddb2729ddcf8824b35a17091f0ff1da1eb5122dc161e2a36bbaa34b743644c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btrtl.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <asm/unaligned.h>\n#include <linux/usb.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btrtl.h\"\n\n#define VERSION \"0.1\"\n\n#define RTL_CHIP_8723CS_CG\t3\n#define RTL_CHIP_8723CS_VF\t4\n#define RTL_CHIP_8723CS_XX\t5\n#define RTL_EPATCH_SIGNATURE\t\"Realtech\"\n#define RTL_EPATCH_SIGNATURE_V2\t\"RTBTCore\"\n#define RTL_ROM_LMP_8703B\t0x8703\n#define RTL_ROM_LMP_8723A\t0x1200\n#define RTL_ROM_LMP_8723B\t0x8723\n#define RTL_ROM_LMP_8821A\t0x8821\n#define RTL_ROM_LMP_8761A\t0x8761\n#define RTL_ROM_LMP_8822B\t0x8822\n#define RTL_ROM_LMP_8852A\t0x8852\n#define RTL_ROM_LMP_8851B\t0x8851\n#define RTL_CONFIG_MAGIC\t0x8723ab55\n\n#define RTL_VSC_OP_COREDUMP\t0xfcff\n\n#define IC_MATCH_FL_LMPSUBV\t(1 << 0)\n#define IC_MATCH_FL_HCIREV\t(1 << 1)\n#define IC_MATCH_FL_HCIVER\t(1 << 2)\n#define IC_MATCH_FL_HCIBUS\t(1 << 3)\n#define IC_MATCH_FL_CHIP_TYPE\t(1 << 4)\n#define IC_INFO(lmps, hcir, hciv, bus) \\\n\t.match_flags = IC_MATCH_FL_LMPSUBV | IC_MATCH_FL_HCIREV | \\\n\t\t       IC_MATCH_FL_HCIVER | IC_MATCH_FL_HCIBUS, \\\n\t.lmp_subver = (lmps), \\\n\t.hci_rev = (hcir), \\\n\t.hci_ver = (hciv), \\\n\t.hci_bus = (bus)\n\n#define\tRTL_CHIP_SUBVER (&(struct rtl_vendor_cmd) {{0x10, 0x38, 0x04, 0x28, 0x80}})\n#define\tRTL_CHIP_REV    (&(struct rtl_vendor_cmd) {{0x10, 0x3A, 0x04, 0x28, 0x80}})\n#define\tRTL_SEC_PROJ    (&(struct rtl_vendor_cmd) {{0x10, 0xA4, 0x0D, 0x00, 0xb0}})\n\n#define RTL_PATCH_SNIPPETS\t\t0x01\n#define RTL_PATCH_DUMMY_HEADER\t\t0x02\n#define RTL_PATCH_SECURITY_HEADER\t0x03\n\nenum btrtl_chip_id {\n\tCHIP_ID_8723A,\n\tCHIP_ID_8723B,\n\tCHIP_ID_8821A,\n\tCHIP_ID_8761A,\n\tCHIP_ID_8822B = 8,\n\tCHIP_ID_8723D,\n\tCHIP_ID_8821C,\n\tCHIP_ID_8822C = 13,\n\tCHIP_ID_8761B,\n\tCHIP_ID_8852A = 18,\n\tCHIP_ID_8852B = 20,\n\tCHIP_ID_8852C = 25,\n\tCHIP_ID_8851B = 36,\n};\n\nstruct id_table {\n\t__u16 match_flags;\n\t__u16 lmp_subver;\n\t__u16 hci_rev;\n\t__u8 hci_ver;\n\t__u8 hci_bus;\n\t__u8 chip_type;\n\tbool config_needed;\n\tbool has_rom_version;\n\tbool has_msft_ext;\n\tchar *fw_name;\n\tchar *cfg_name;\n\tchar *hw_info;\n};\n\nstruct btrtl_device_info {\n\tconst struct id_table *ic_info;\n\tu8 rom_version;\n\tu8 *fw_data;\n\tint fw_len;\n\tu8 *cfg_data;\n\tint cfg_len;\n\tbool drop_fw;\n\tint project_id;\n\tu8 key_id;\n\tstruct list_head patch_subsecs;\n};\n\nstatic const struct id_table ic_id_table[] = {\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8723A, 0xb, 0x6, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = false,\n\t  .fw_name = \"rtl_bt/rtl8723a_fw\",\n\t  .cfg_name = NULL,\n\t  .hw_info = \"rtl8723au\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8723B, 0xb, 0x6, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723bs_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723bs_config\",\n\t  .hw_info  = \"rtl8723bs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8723B, 0xb, 0x6, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723b_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723b_config\",\n\t  .hw_info  = \"rtl8723bu\" },\n\n\t \n\t{ .match_flags = IC_MATCH_FL_LMPSUBV | IC_MATCH_FL_CHIP_TYPE |\n\t\t\t IC_MATCH_FL_HCIBUS,\n\t  .lmp_subver = RTL_ROM_LMP_8703B,\n\t  .chip_type = RTL_CHIP_8723CS_CG,\n\t  .hci_bus = HCI_UART,\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723cs_cg_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723cs_cg_config\",\n\t  .hw_info  = \"rtl8723cs-cg\" },\n\n\t \n\t{ .match_flags = IC_MATCH_FL_LMPSUBV | IC_MATCH_FL_CHIP_TYPE |\n\t\t\t IC_MATCH_FL_HCIBUS,\n\t  .lmp_subver = RTL_ROM_LMP_8703B,\n\t  .chip_type = RTL_CHIP_8723CS_VF,\n\t  .hci_bus = HCI_UART,\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723cs_vf_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723cs_vf_config\",\n\t  .hw_info  = \"rtl8723cs-vf\" },\n\n\t \n\t{ .match_flags = IC_MATCH_FL_LMPSUBV | IC_MATCH_FL_CHIP_TYPE |\n\t\t\t IC_MATCH_FL_HCIBUS,\n\t  .lmp_subver = RTL_ROM_LMP_8703B,\n\t  .chip_type = RTL_CHIP_8723CS_XX,\n\t  .hci_bus = HCI_UART,\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723cs_xx_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723cs_xx_config\",\n\t  .hw_info  = \"rtl8723cs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8723B, 0xd, 0x8, HCI_USB),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723d_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723d_config\",\n\t  .hw_info  = \"rtl8723du\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8723B, 0xd, 0x8, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8723ds_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8723ds_config\",\n\t  .hw_info  = \"rtl8723ds\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8821A, 0xa, 0x6, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8821a_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8821a_config\",\n\t  .hw_info  = \"rtl8821au\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8821A, 0xc, 0x8, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8821c_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8821c_config\",\n\t  .hw_info  = \"rtl8821cu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8821A, 0xc, 0x8, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8821cs_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8821cs_config\",\n\t  .hw_info  = \"rtl8821cs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8761A, 0xa, 0x6, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8761a_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8761a_config\",\n\t  .hw_info  = \"rtl8761au\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8761A, 0xb, 0xa, HCI_UART),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8761b_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8761b_config\",\n\t  .hw_info  = \"rtl8761btv\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8761A, 0xb, 0xa, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .fw_name  = \"rtl_bt/rtl8761bu_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8761bu_config\",\n\t  .hw_info  = \"rtl8761bu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8822B, 0xc, 0x8, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8822cs_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8822cs_config\",\n\t  .hw_info  = \"rtl8822cs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8822B, 0xc, 0xa, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8822cs_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8822cs_config\",\n\t  .hw_info  = \"rtl8822cs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8822B, 0xc, 0xa, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8822cu_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8822cu_config\",\n\t  .hw_info  = \"rtl8822cu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8822B, 0xb, 0x7, HCI_USB),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8822b_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8822b_config\",\n\t  .hw_info  = \"rtl8822bu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8852A, 0xa, 0xb, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8852au_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8852au_config\",\n\t  .hw_info  = \"rtl8852au\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8852A, 0xb, 0xb, HCI_UART),\n\t  .config_needed = true,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8852bs_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8852bs_config\",\n\t  .hw_info  = \"rtl8852bs\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8852A, 0xb, 0xb, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8852bu_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8852bu_config\",\n\t  .hw_info  = \"rtl8852bu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8852A, 0xc, 0xc, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = true,\n\t  .fw_name  = \"rtl_bt/rtl8852cu_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8852cu_config\",\n\t  .hw_info  = \"rtl8852cu\" },\n\n\t \n\t{ IC_INFO(RTL_ROM_LMP_8851B, 0xb, 0xc, HCI_USB),\n\t  .config_needed = false,\n\t  .has_rom_version = true,\n\t  .has_msft_ext = false,\n\t  .fw_name  = \"rtl_bt/rtl8851bu_fw\",\n\t  .cfg_name = \"rtl_bt/rtl8851bu_config\",\n\t  .hw_info  = \"rtl8851bu\" },\n\t};\n\nstatic const struct id_table *btrtl_match_ic(u16 lmp_subver, u16 hci_rev,\n\t\t\t\t\t     u8 hci_ver, u8 hci_bus,\n\t\t\t\t\t     u8 chip_type)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(ic_id_table); i++) {\n\t\tif ((ic_id_table[i].match_flags & IC_MATCH_FL_LMPSUBV) &&\n\t\t    (ic_id_table[i].lmp_subver != lmp_subver))\n\t\t\tcontinue;\n\t\tif ((ic_id_table[i].match_flags & IC_MATCH_FL_HCIREV) &&\n\t\t    (ic_id_table[i].hci_rev != hci_rev))\n\t\t\tcontinue;\n\t\tif ((ic_id_table[i].match_flags & IC_MATCH_FL_HCIVER) &&\n\t\t    (ic_id_table[i].hci_ver != hci_ver))\n\t\t\tcontinue;\n\t\tif ((ic_id_table[i].match_flags & IC_MATCH_FL_HCIBUS) &&\n\t\t    (ic_id_table[i].hci_bus != hci_bus))\n\t\t\tcontinue;\n\t\tif ((ic_id_table[i].match_flags & IC_MATCH_FL_CHIP_TYPE) &&\n\t\t    (ic_id_table[i].chip_type != chip_type))\n\t\t\tcontinue;\n\n\t\tbreak;\n\t}\n\tif (i >= ARRAY_SIZE(ic_id_table))\n\t\treturn NULL;\n\n\treturn &ic_id_table[i];\n}\n\nstatic struct sk_buff *btrtl_read_local_version(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\trtl_dev_err(hdev, \"HCI_OP_READ_LOCAL_VERSION failed (%ld)\",\n\t\t\t    PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != sizeof(struct hci_rp_read_local_version)) {\n\t\trtl_dev_err(hdev, \"HCI_OP_READ_LOCAL_VERSION event length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic int rtl_read_rom_version(struct hci_dev *hdev, u8 *version)\n{\n\tstruct rtl_rom_version_evt *rom_version;\n\tstruct sk_buff *skb;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\trtl_dev_err(hdev, \"Read ROM version failed (%ld)\",\n\t\t\t    PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb->len != sizeof(*rom_version)) {\n\t\trtl_dev_err(hdev, \"version event length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\trom_version = (struct rtl_rom_version_evt *)skb->data;\n\trtl_dev_info(hdev, \"rom_version status=%x version=%x\",\n\t\t     rom_version->status, rom_version->version);\n\n\t*version = rom_version->version;\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nstatic int btrtl_vendor_read_reg16(struct hci_dev *hdev,\n\t\t\t\t   struct rtl_vendor_cmd *cmd, u8 *rp)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc61, sizeof(*cmd), cmd,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\trtl_dev_err(hdev, \"RTL: Read reg16 failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != 3 || skb->data[0]) {\n\t\tbt_dev_err(hdev, \"RTL: Read reg16 length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tif (rp)\n\t\tmemcpy(rp, skb->data + 1, 2);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic void *rtl_iov_pull_data(struct rtl_iovec *iov, u32 len)\n{\n\tvoid *data = iov->data;\n\n\tif (iov->len < len)\n\t\treturn NULL;\n\n\tiov->data += len;\n\tiov->len  -= len;\n\n\treturn data;\n}\n\nstatic void btrtl_insert_ordered_subsec(struct rtl_subsection *node,\n\t\t\t\t\tstruct btrtl_device_info *btrtl_dev)\n{\n\tstruct list_head *pos;\n\tstruct list_head *next;\n\tstruct rtl_subsection *subsec;\n\n\tlist_for_each_safe(pos, next, &btrtl_dev->patch_subsecs) {\n\t\tsubsec = list_entry(pos, struct rtl_subsection, list);\n\t\tif (subsec->prio >= node->prio)\n\t\t\tbreak;\n\t}\n\t__list_add(&node->list, pos->prev, pos);\n}\n\nstatic int btrtl_parse_section(struct hci_dev *hdev,\n\t\t\t       struct btrtl_device_info *btrtl_dev, u32 opcode,\n\t\t\t       u8 *data, u32 len)\n{\n\tstruct rtl_section_hdr *hdr;\n\tstruct rtl_subsection *subsec;\n\tstruct rtl_common_subsec *common_subsec;\n\tstruct rtl_sec_hdr *sec_hdr;\n\tint i;\n\tu8 *ptr;\n\tu16 num_subsecs;\n\tu32 subsec_len;\n\tint rc = 0;\n\tstruct rtl_iovec iov = {\n\t\t.data = data,\n\t\t.len  = len,\n\t};\n\n\thdr = rtl_iov_pull_data(&iov, sizeof(*hdr));\n\tif (!hdr)\n\t\treturn -EINVAL;\n\tnum_subsecs = le16_to_cpu(hdr->num);\n\n\tfor (i = 0; i < num_subsecs; i++) {\n\t\tcommon_subsec = rtl_iov_pull_data(&iov, sizeof(*common_subsec));\n\t\tif (!common_subsec)\n\t\t\tbreak;\n\t\tsubsec_len = le32_to_cpu(common_subsec->len);\n\n\t\trtl_dev_dbg(hdev, \"subsec, eco 0x%02x, len %08x\",\n\t\t\t    common_subsec->eco, subsec_len);\n\n\t\tptr = rtl_iov_pull_data(&iov, subsec_len);\n\t\tif (!ptr)\n\t\t\tbreak;\n\n\t\tif (common_subsec->eco != btrtl_dev->rom_version + 1)\n\t\t\tcontinue;\n\n\t\tswitch (opcode) {\n\t\tcase RTL_PATCH_SECURITY_HEADER:\n\t\t\tsec_hdr = (void *)common_subsec;\n\t\t\tif (sec_hdr->key_id != btrtl_dev->key_id)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\n\t\tsubsec = kzalloc(sizeof(*subsec), GFP_KERNEL);\n\t\tif (!subsec)\n\t\t\treturn -ENOMEM;\n\t\tsubsec->opcode = opcode;\n\t\tsubsec->prio = common_subsec->prio;\n\t\tsubsec->len  = subsec_len;\n\t\tsubsec->data = ptr;\n\t\tbtrtl_insert_ordered_subsec(subsec, btrtl_dev);\n\t\trc  += subsec_len;\n\t}\n\n\treturn rc;\n}\n\nstatic int rtlbt_parse_firmware_v2(struct hci_dev *hdev,\n\t\t\t\t   struct btrtl_device_info *btrtl_dev,\n\t\t\t\t   unsigned char **_buf)\n{\n\tstruct rtl_epatch_header_v2 *hdr;\n\tint rc;\n\tu8 reg_val[2];\n\tu8 key_id;\n\tu32 num_sections;\n\tstruct rtl_section *section;\n\tstruct rtl_subsection *entry, *tmp;\n\tu32 section_len;\n\tu32 opcode;\n\tint len = 0;\n\tint i;\n\tu8 *ptr;\n\tstruct rtl_iovec iov = {\n\t\t.data = btrtl_dev->fw_data,\n\t\t.len  = btrtl_dev->fw_len - 7,  \n\t};\n\n\trc = btrtl_vendor_read_reg16(hdev, RTL_SEC_PROJ, reg_val);\n\tif (rc < 0)\n\t\treturn -EIO;\n\tkey_id = reg_val[0];\n\n\trtl_dev_dbg(hdev, \"%s: key id %u\", __func__, key_id);\n\n\tbtrtl_dev->key_id = key_id;\n\n\thdr = rtl_iov_pull_data(&iov, sizeof(*hdr));\n\tif (!hdr)\n\t\treturn -EINVAL;\n\tnum_sections = le32_to_cpu(hdr->num_sections);\n\n\trtl_dev_dbg(hdev, \"FW version %08x-%08x\", *((u32 *)hdr->fw_version),\n\t\t    *((u32 *)(hdr->fw_version + 4)));\n\n\tfor (i = 0; i < num_sections; i++) {\n\t\tsection = rtl_iov_pull_data(&iov, sizeof(*section));\n\t\tif (!section)\n\t\t\tbreak;\n\t\tsection_len = le32_to_cpu(section->len);\n\t\topcode      = le32_to_cpu(section->opcode);\n\n\t\trtl_dev_dbg(hdev, \"opcode 0x%04x\", section->opcode);\n\n\t\tptr = rtl_iov_pull_data(&iov, section_len);\n\t\tif (!ptr)\n\t\t\tbreak;\n\n\t\tswitch (opcode) {\n\t\tcase RTL_PATCH_SNIPPETS:\n\t\t\trc = btrtl_parse_section(hdev, btrtl_dev, opcode,\n\t\t\t\t\t\t ptr, section_len);\n\t\t\tbreak;\n\t\tcase RTL_PATCH_SECURITY_HEADER:\n\t\t\t \n\t\t\tif (!key_id)\n\t\t\t\tbreak;\n\t\t\trc = btrtl_parse_section(hdev, btrtl_dev, opcode,\n\t\t\t\t\t\t ptr, section_len);\n\t\t\tbreak;\n\t\tcase RTL_PATCH_DUMMY_HEADER:\n\t\t\trc = btrtl_parse_section(hdev, btrtl_dev, opcode,\n\t\t\t\t\t\t ptr, section_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (rc < 0) {\n\t\t\trtl_dev_err(hdev, \"RTL: Parse section (%u) err %d\",\n\t\t\t\t    opcode, rc);\n\t\t\treturn rc;\n\t\t}\n\t\tlen += rc;\n\t}\n\n\tif (!len)\n\t\treturn -ENODATA;\n\n\t \n\tptr = kvmalloc(len, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\tlen = 0;\n\tlist_for_each_entry_safe(entry, tmp, &btrtl_dev->patch_subsecs, list) {\n\t\trtl_dev_dbg(hdev, \"RTL: opcode %08x, addr %p, len 0x%x\",\n\t\t\t    entry->opcode, entry->data, entry->len);\n\t\tmemcpy(ptr + len, entry->data, entry->len);\n\t\tlen += entry->len;\n\t}\n\n\tif (!len)\n\t\treturn -EPERM;\n\n\t*_buf = ptr;\n\treturn len;\n}\n\nstatic int rtlbt_parse_firmware(struct hci_dev *hdev,\n\t\t\t\tstruct btrtl_device_info *btrtl_dev,\n\t\t\t\tunsigned char **_buf)\n{\n\tstatic const u8 extension_sig[] = { 0x51, 0x04, 0xfd, 0x77 };\n\tstruct btrealtek_data *coredump_info = hci_get_priv(hdev);\n\tstruct rtl_epatch_header *epatch_info;\n\tunsigned char *buf;\n\tint i, len;\n\tsize_t min_size;\n\tu8 opcode, length, data;\n\tint project_id = -1;\n\tconst unsigned char *fwptr, *chip_id_base;\n\tconst unsigned char *patch_length_base, *patch_offset_base;\n\tu32 patch_offset = 0;\n\tu16 patch_length, num_patches;\n\tstatic const struct {\n\t\t__u16 lmp_subver;\n\t\t__u8 id;\n\t} project_id_to_lmp_subver[] = {\n\t\t{ RTL_ROM_LMP_8723A, 0 },\n\t\t{ RTL_ROM_LMP_8723B, 1 },\n\t\t{ RTL_ROM_LMP_8821A, 2 },\n\t\t{ RTL_ROM_LMP_8761A, 3 },\n\t\t{ RTL_ROM_LMP_8703B, 7 },\n\t\t{ RTL_ROM_LMP_8822B, 8 },\n\t\t{ RTL_ROM_LMP_8723B, 9 },\t \n\t\t{ RTL_ROM_LMP_8821A, 10 },\t \n\t\t{ RTL_ROM_LMP_8822B, 13 },\t \n\t\t{ RTL_ROM_LMP_8761A, 14 },\t \n\t\t{ RTL_ROM_LMP_8852A, 18 },\t \n\t\t{ RTL_ROM_LMP_8852A, 20 },\t \n\t\t{ RTL_ROM_LMP_8852A, 25 },\t \n\t\t{ RTL_ROM_LMP_8851B, 36 },\t \n\t};\n\n\tif (btrtl_dev->fw_len <= 8)\n\t\treturn -EINVAL;\n\n\tif (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE, 8))\n\t\tmin_size = sizeof(struct rtl_epatch_header) +\n\t\t\t\tsizeof(extension_sig) + 3;\n\telse if (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE_V2, 8))\n\t\tmin_size = sizeof(struct rtl_epatch_header_v2) +\n\t\t\t\tsizeof(extension_sig) + 3;\n\telse\n\t\treturn -EINVAL;\n\n\tif (btrtl_dev->fw_len < min_size)\n\t\treturn -EINVAL;\n\n\tfwptr = btrtl_dev->fw_data + btrtl_dev->fw_len - sizeof(extension_sig);\n\tif (memcmp(fwptr, extension_sig, sizeof(extension_sig)) != 0) {\n\t\trtl_dev_err(hdev, \"extension section signature mismatch\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\twhile (fwptr >= btrtl_dev->fw_data + (sizeof(*epatch_info) + 3)) {\n\t\topcode = *--fwptr;\n\t\tlength = *--fwptr;\n\t\tdata = *--fwptr;\n\n\t\tBT_DBG(\"check op=%x len=%x data=%x\", opcode, length, data);\n\n\t\tif (opcode == 0xff)  \n\t\t\tbreak;\n\n\t\tif (length == 0) {\n\t\t\trtl_dev_err(hdev, \"found instruction with length 0\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (opcode == 0 && length == 1) {\n\t\t\tproject_id = data;\n\t\t\tbreak;\n\t\t}\n\n\t\tfwptr -= length;\n\t}\n\n\tif (project_id < 0) {\n\t\trtl_dev_err(hdev, \"failed to find version instruction\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(project_id_to_lmp_subver); i++) {\n\t\tif (project_id == project_id_to_lmp_subver[i].id) {\n\t\t\tbtrtl_dev->project_id = project_id;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i >= ARRAY_SIZE(project_id_to_lmp_subver)) {\n\t\trtl_dev_err(hdev, \"unknown project id %d\", project_id);\n\t\treturn -EINVAL;\n\t}\n\n\tif (btrtl_dev->ic_info->lmp_subver !=\n\t\t\t\tproject_id_to_lmp_subver[i].lmp_subver) {\n\t\trtl_dev_err(hdev, \"firmware is for %x but this is a %x\",\n\t\t\t    project_id_to_lmp_subver[i].lmp_subver,\n\t\t\t    btrtl_dev->ic_info->lmp_subver);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE, 8) != 0) {\n\t\tif (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE_V2, 8))\n\t\t\treturn rtlbt_parse_firmware_v2(hdev, btrtl_dev, _buf);\n\t\trtl_dev_err(hdev, \"bad EPATCH signature\");\n\t\treturn -EINVAL;\n\t}\n\n\tepatch_info = (struct rtl_epatch_header *)btrtl_dev->fw_data;\n\tnum_patches = le16_to_cpu(epatch_info->num_patches);\n\n\tBT_DBG(\"fw_version=%x, num_patches=%d\",\n\t       le32_to_cpu(epatch_info->fw_version), num_patches);\n\tcoredump_info->rtl_dump.fw_version = le32_to_cpu(epatch_info->fw_version);\n\n\t \n\tmin_size += 8 * num_patches;\n\tif (btrtl_dev->fw_len < min_size)\n\t\treturn -EINVAL;\n\n\tchip_id_base = btrtl_dev->fw_data + sizeof(struct rtl_epatch_header);\n\tpatch_length_base = chip_id_base + (sizeof(u16) * num_patches);\n\tpatch_offset_base = patch_length_base + (sizeof(u16) * num_patches);\n\tfor (i = 0; i < num_patches; i++) {\n\t\tu16 chip_id = get_unaligned_le16(chip_id_base +\n\t\t\t\t\t\t (i * sizeof(u16)));\n\t\tif (chip_id == btrtl_dev->rom_version + 1) {\n\t\t\tpatch_length = get_unaligned_le16(patch_length_base +\n\t\t\t\t\t\t\t  (i * sizeof(u16)));\n\t\t\tpatch_offset = get_unaligned_le32(patch_offset_base +\n\t\t\t\t\t\t\t  (i * sizeof(u32)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!patch_offset) {\n\t\trtl_dev_err(hdev, \"didn't find patch for chip id %d\",\n\t\t\t    btrtl_dev->rom_version);\n\t\treturn -EINVAL;\n\t}\n\n\tBT_DBG(\"length=%x offset=%x index %d\", patch_length, patch_offset, i);\n\tmin_size = patch_offset + patch_length;\n\tif (btrtl_dev->fw_len < min_size)\n\t\treturn -EINVAL;\n\n\t \n\tlen = patch_length;\n\tbuf = kvmalloc(patch_length, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tmemcpy(buf, btrtl_dev->fw_data + patch_offset, patch_length - 4);\n\tmemcpy(buf + patch_length - 4, &epatch_info->fw_version, 4);\n\n\t*_buf = buf;\n\treturn len;\n}\n\nstatic int rtl_download_firmware(struct hci_dev *hdev,\n\t\t\t\t const unsigned char *data, int fw_len)\n{\n\tstruct rtl_download_cmd *dl_cmd;\n\tint frag_num = fw_len / RTL_FRAG_LEN + 1;\n\tint frag_len = RTL_FRAG_LEN;\n\tint ret = 0;\n\tint i;\n\tint j = 0;\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_version *rp;\n\n\tdl_cmd = kmalloc(sizeof(struct rtl_download_cmd), GFP_KERNEL);\n\tif (!dl_cmd)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < frag_num; i++) {\n\t\tstruct sk_buff *skb;\n\n\t\tdl_cmd->index = j++;\n\t\tif (dl_cmd->index == 0x7f)\n\t\t\tj = 1;\n\n\t\tif (i == (frag_num - 1)) {\n\t\t\tdl_cmd->index |= 0x80;  \n\t\t\tfrag_len = fw_len % RTL_FRAG_LEN;\n\t\t}\n\t\trtl_dev_dbg(hdev, \"download fw (%d/%d). index = %d\", i,\n\t\t\t\tfrag_num, dl_cmd->index);\n\t\tmemcpy(dl_cmd->data, data, frag_len);\n\n\t\t \n\t\tskb = __hci_cmd_sync(hdev, 0xfc20, frag_len + 1, dl_cmd,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\trtl_dev_err(hdev, \"download fw command failed (%ld)\",\n\t\t\t\t    PTR_ERR(skb));\n\t\t\tret = PTR_ERR(skb);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (skb->len != sizeof(struct rtl_download_response)) {\n\t\t\trtl_dev_err(hdev, \"download fw event length mismatch\");\n\t\t\tkfree_skb(skb);\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t\tdata += RTL_FRAG_LEN;\n\t}\n\n\tskb = btrtl_read_local_version(hdev);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\trtl_dev_err(hdev, \"read local version failed\");\n\t\tgoto out;\n\t}\n\n\trp = (struct hci_rp_read_local_version *)skb->data;\n\trtl_dev_info(hdev, \"fw version 0x%04x%04x\",\n\t\t     __le16_to_cpu(rp->hci_rev), __le16_to_cpu(rp->lmp_subver));\n\tkfree_skb(skb);\n\nout:\n\tkfree(dl_cmd);\n\treturn ret;\n}\n\nstatic int rtl_load_file(struct hci_dev *hdev, const char *name, u8 **buff)\n{\n\tconst struct firmware *fw;\n\tint ret;\n\n\trtl_dev_info(hdev, \"loading %s\", name);\n\tret = request_firmware(&fw, name, &hdev->dev);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fw->size;\n\t*buff = kvmalloc(fw->size, GFP_KERNEL);\n\tif (*buff)\n\t\tmemcpy(*buff, fw->data, ret);\n\telse\n\t\tret = -ENOMEM;\n\n\trelease_firmware(fw);\n\n\treturn ret;\n}\n\nstatic int btrtl_setup_rtl8723a(struct hci_dev *hdev,\n\t\t\t\tstruct btrtl_device_info *btrtl_dev)\n{\n\tif (btrtl_dev->fw_len < 8)\n\t\treturn -EINVAL;\n\n\t \n\tif (!memcmp(btrtl_dev->fw_data, RTL_EPATCH_SIGNATURE, 8)) {\n\t\trtl_dev_err(hdev, \"unexpected EPATCH signature!\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn rtl_download_firmware(hdev, btrtl_dev->fw_data,\n\t\t\t\t     btrtl_dev->fw_len);\n}\n\nstatic int btrtl_setup_rtl8723b(struct hci_dev *hdev,\n\t\t\t\tstruct btrtl_device_info *btrtl_dev)\n{\n\tunsigned char *fw_data = NULL;\n\tint ret;\n\tu8 *tbuff;\n\n\tret = rtlbt_parse_firmware(hdev, btrtl_dev, &fw_data);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (btrtl_dev->cfg_len > 0) {\n\t\ttbuff = kvzalloc(ret + btrtl_dev->cfg_len, GFP_KERNEL);\n\t\tif (!tbuff) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(tbuff, fw_data, ret);\n\t\tkvfree(fw_data);\n\n\t\tmemcpy(tbuff + ret, btrtl_dev->cfg_data, btrtl_dev->cfg_len);\n\t\tret += btrtl_dev->cfg_len;\n\n\t\tfw_data = tbuff;\n\t}\n\n\trtl_dev_info(hdev, \"cfg_sz %d, total sz %d\", btrtl_dev->cfg_len, ret);\n\n\tret = rtl_download_firmware(hdev, fw_data, ret);\n\nout:\n\tkvfree(fw_data);\n\treturn ret;\n}\n\nstatic void btrtl_coredump(struct hci_dev *hdev)\n{\n\tstatic const u8 param[] = { 0x00, 0x00 };\n\n\t__hci_cmd_send(hdev, RTL_VSC_OP_COREDUMP, sizeof(param), param);\n}\n\nstatic void btrtl_dmp_hdr(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btrealtek_data *coredump_info = hci_get_priv(hdev);\n\tchar buf[80];\n\n\tif (coredump_info->rtl_dump.controller)\n\t\tsnprintf(buf, sizeof(buf), \"Controller Name: %s\\n\",\n\t\t\t coredump_info->rtl_dump.controller);\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"Controller Name: Unknown\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Firmware Version: 0x%X\\n\",\n\t\t coredump_info->rtl_dump.fw_version);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Driver: %s\\n\", coredump_info->rtl_dump.driver_name);\n\tskb_put_data(skb, buf, strlen(buf));\n\n\tsnprintf(buf, sizeof(buf), \"Vendor: Realtek\\n\");\n\tskb_put_data(skb, buf, strlen(buf));\n}\n\nstatic void btrtl_register_devcoredump_support(struct hci_dev *hdev)\n{\n\thci_devcd_register(hdev, btrtl_coredump, btrtl_dmp_hdr, NULL);\n\n}\n\nvoid btrtl_set_driver_name(struct hci_dev *hdev, const char *driver_name)\n{\n\tstruct btrealtek_data *coredump_info = hci_get_priv(hdev);\n\n\tcoredump_info->rtl_dump.driver_name = driver_name;\n}\nEXPORT_SYMBOL_GPL(btrtl_set_driver_name);\n\nstatic bool rtl_has_chip_type(u16 lmp_subver)\n{\n\tswitch (lmp_subver) {\n\tcase RTL_ROM_LMP_8703B:\n\t\treturn true;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn  false;\n}\n\nstatic int rtl_read_chip_type(struct hci_dev *hdev, u8 *type)\n{\n\tstruct rtl_chip_type_evt *chip_type;\n\tstruct sk_buff *skb;\n\tconst unsigned char cmd_buf[] = {0x00, 0x94, 0xa0, 0x00, 0xb0};\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc61, 5, cmd_buf, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\trtl_dev_err(hdev, \"Read chip type failed (%ld)\",\n\t\t\t    PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tchip_type = skb_pull_data(skb, sizeof(*chip_type));\n\tif (!chip_type) {\n\t\trtl_dev_err(hdev, \"RTL chip type event length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\trtl_dev_info(hdev, \"chip_type status=%x type=%x\",\n\t\t     chip_type->status, chip_type->type);\n\n\t*type = chip_type->type & 0x0f;\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\nvoid btrtl_free(struct btrtl_device_info *btrtl_dev)\n{\n\tstruct rtl_subsection *entry, *tmp;\n\n\tkvfree(btrtl_dev->fw_data);\n\tkvfree(btrtl_dev->cfg_data);\n\n\tlist_for_each_entry_safe(entry, tmp, &btrtl_dev->patch_subsecs, list) {\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n\n\tkfree(btrtl_dev);\n}\nEXPORT_SYMBOL_GPL(btrtl_free);\n\nstruct btrtl_device_info *btrtl_initialize(struct hci_dev *hdev,\n\t\t\t\t\t   const char *postfix)\n{\n\tstruct btrealtek_data *coredump_info = hci_get_priv(hdev);\n\tstruct btrtl_device_info *btrtl_dev;\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_version *resp;\n\tstruct hci_command_hdr *cmd;\n\tchar fw_name[40];\n\tchar cfg_name[40];\n\tu16 hci_rev, lmp_subver;\n\tu8 hci_ver, lmp_ver, chip_type = 0;\n\tint ret;\n\tu8 reg_val[2];\n\n\tbtrtl_dev = kzalloc(sizeof(*btrtl_dev), GFP_KERNEL);\n\tif (!btrtl_dev) {\n\t\tret = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tINIT_LIST_HEAD(&btrtl_dev->patch_subsecs);\n\ncheck_version:\n\tret = btrtl_vendor_read_reg16(hdev, RTL_CHIP_SUBVER, reg_val);\n\tif (ret < 0)\n\t\tgoto err_free;\n\tlmp_subver = get_unaligned_le16(reg_val);\n\n\tif (lmp_subver == RTL_ROM_LMP_8822B) {\n\t\tret = btrtl_vendor_read_reg16(hdev, RTL_CHIP_REV, reg_val);\n\t\tif (ret < 0)\n\t\t\tgoto err_free;\n\t\thci_rev = get_unaligned_le16(reg_val);\n\n\t\t \n\t\tif (hci_rev == 0x000e) {\n\t\t\thci_ver = 0x0c;\n\t\t\tlmp_ver = 0x0c;\n\t\t\tbtrtl_dev->ic_info = btrtl_match_ic(lmp_subver, hci_rev,\n\t\t\t\t\t\t\t    hci_ver, hdev->bus,\n\t\t\t\t\t\t\t    chip_type);\n\t\t\tgoto next;\n\t\t}\n\t}\n\n\tskb = btrtl_read_local_version(hdev);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tgoto err_free;\n\t}\n\n\tresp = (struct hci_rp_read_local_version *)skb->data;\n\n\thci_ver    = resp->hci_ver;\n\thci_rev    = le16_to_cpu(resp->hci_rev);\n\tlmp_ver    = resp->lmp_ver;\n\tlmp_subver = le16_to_cpu(resp->lmp_subver);\n\n\tkfree_skb(skb);\n\n\tif (rtl_has_chip_type(lmp_subver)) {\n\t\tret = rtl_read_chip_type(hdev, &chip_type);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t}\n\n\tbtrtl_dev->ic_info = btrtl_match_ic(lmp_subver, hci_rev, hci_ver,\n\t\t\t\t\t    hdev->bus, chip_type);\n\nnext:\n\trtl_dev_info(hdev, \"examining hci_ver=%02x hci_rev=%04x lmp_ver=%02x lmp_subver=%04x\",\n\t\t     hci_ver, hci_rev,\n\t\t     lmp_ver, lmp_subver);\n\n\tif (!btrtl_dev->ic_info && !btrtl_dev->drop_fw)\n\t\tbtrtl_dev->drop_fw = true;\n\telse\n\t\tbtrtl_dev->drop_fw = false;\n\n\tif (btrtl_dev->drop_fw) {\n\t\tskb = bt_skb_alloc(sizeof(*cmd), GFP_KERNEL);\n\t\tif (!skb)\n\t\t\tgoto err_free;\n\n\t\tcmd = skb_put(skb, HCI_COMMAND_HDR_SIZE);\n\t\tcmd->opcode = cpu_to_le16(0xfc66);\n\t\tcmd->plen = 0;\n\n\t\thci_skb_pkt_type(skb) = HCI_COMMAND_PKT;\n\n\t\tret = hdev->send(hdev, skb);\n\t\tif (ret < 0) {\n\t\t\tbt_dev_err(hdev, \"sending frame failed (%d)\", ret);\n\t\t\tkfree_skb(skb);\n\t\t\tgoto err_free;\n\t\t}\n\n\t\t \n\t\tmsleep(200);\n\n\t\tgoto check_version;\n\t}\n\n\tif (!btrtl_dev->ic_info) {\n\t\trtl_dev_info(hdev, \"unknown IC info, lmp subver %04x, hci rev %04x, hci ver %04x\",\n\t\t\t    lmp_subver, hci_rev, hci_ver);\n\t\treturn btrtl_dev;\n\t}\n\n\tif (btrtl_dev->ic_info->has_rom_version) {\n\t\tret = rtl_read_rom_version(hdev, &btrtl_dev->rom_version);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t}\n\n\tif (!btrtl_dev->ic_info->fw_name) {\n\t\tret = -ENOMEM;\n\t\tgoto err_free;\n\t}\n\n\tbtrtl_dev->fw_len = -EIO;\n\tif (lmp_subver == RTL_ROM_LMP_8852A && hci_rev == 0x000c) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"%s_v2.bin\",\n\t\t\t\tbtrtl_dev->ic_info->fw_name);\n\t\tbtrtl_dev->fw_len = rtl_load_file(hdev, fw_name,\n\t\t\t\t&btrtl_dev->fw_data);\n\t}\n\n\tif (btrtl_dev->fw_len < 0) {\n\t\tsnprintf(fw_name, sizeof(fw_name), \"%s.bin\",\n\t\t\t\tbtrtl_dev->ic_info->fw_name);\n\t\tbtrtl_dev->fw_len = rtl_load_file(hdev, fw_name,\n\t\t\t\t&btrtl_dev->fw_data);\n\t}\n\n\tif (btrtl_dev->fw_len < 0) {\n\t\trtl_dev_err(hdev, \"firmware file %s not found\",\n\t\t\t    btrtl_dev->ic_info->fw_name);\n\t\tret = btrtl_dev->fw_len;\n\t\tgoto err_free;\n\t}\n\n\tif (btrtl_dev->ic_info->cfg_name) {\n\t\tif (postfix) {\n\t\t\tsnprintf(cfg_name, sizeof(cfg_name), \"%s-%s.bin\",\n\t\t\t\t btrtl_dev->ic_info->cfg_name, postfix);\n\t\t} else {\n\t\t\tsnprintf(cfg_name, sizeof(cfg_name), \"%s.bin\",\n\t\t\t\t btrtl_dev->ic_info->cfg_name);\n\t\t}\n\t\tbtrtl_dev->cfg_len = rtl_load_file(hdev, cfg_name,\n\t\t\t\t\t\t   &btrtl_dev->cfg_data);\n\t\tif (btrtl_dev->ic_info->config_needed &&\n\t\t    btrtl_dev->cfg_len <= 0) {\n\t\t\trtl_dev_err(hdev, \"mandatory config file %s not found\",\n\t\t\t\t    btrtl_dev->ic_info->cfg_name);\n\t\t\tret = btrtl_dev->cfg_len;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\n\t \n\tif (btrtl_dev->ic_info->has_msft_ext)\n\t\thci_set_msft_opcode(hdev, 0xFCF0);\n\n\tif (btrtl_dev->ic_info)\n\t\tcoredump_info->rtl_dump.controller = btrtl_dev->ic_info->hw_info;\n\n\treturn btrtl_dev;\n\nerr_free:\n\tbtrtl_free(btrtl_dev);\nerr_alloc:\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(btrtl_initialize);\n\nint btrtl_download_firmware(struct hci_dev *hdev,\n\t\t\t    struct btrtl_device_info *btrtl_dev)\n{\n\tint err = 0;\n\n\t \n\tif (!btrtl_dev->ic_info) {\n\t\trtl_dev_info(hdev, \"assuming no firmware upload needed\");\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\n\tswitch (btrtl_dev->ic_info->lmp_subver) {\n\tcase RTL_ROM_LMP_8723A:\n\t\terr = btrtl_setup_rtl8723a(hdev, btrtl_dev);\n\t\tbreak;\n\tcase RTL_ROM_LMP_8723B:\n\tcase RTL_ROM_LMP_8821A:\n\tcase RTL_ROM_LMP_8761A:\n\tcase RTL_ROM_LMP_8822B:\n\tcase RTL_ROM_LMP_8852A:\n\tcase RTL_ROM_LMP_8703B:\n\tcase RTL_ROM_LMP_8851B:\n\t\terr = btrtl_setup_rtl8723b(hdev, btrtl_dev);\n\t\tbreak;\n\tdefault:\n\t\trtl_dev_info(hdev, \"assuming no firmware upload needed\");\n\t\tbreak;\n\t}\n\ndone:\n\tbtrtl_register_devcoredump_support(hdev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(btrtl_download_firmware);\n\nvoid btrtl_set_quirks(struct hci_dev *hdev, struct btrtl_device_info *btrtl_dev)\n{\n\t \n\tset_bit(HCI_QUIRK_SIMULTANEOUS_DISCOVERY, &hdev->quirks);\n\n\t \n\t \n\tswitch (btrtl_dev->project_id) {\n\tcase CHIP_ID_8822C:\n\tcase CHIP_ID_8852A:\n\tcase CHIP_ID_8852B:\n\tcase CHIP_ID_8852C:\n\tcase CHIP_ID_8851B:\n\t\tset_bit(HCI_QUIRK_VALID_LE_STATES, &hdev->quirks);\n\t\tset_bit(HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED, &hdev->quirks);\n\n\t\t \n\t\tif (btrtl_dev->project_id == CHIP_ID_8852C)\n\t\t\tbtrealtek_set_flag(hdev, REALTEK_ALT6_CONTINUOUS_TX_CHIP);\n\n\t\tif (btrtl_dev->project_id == CHIP_ID_8852A ||\n\t\t    btrtl_dev->project_id == CHIP_ID_8852C)\n\t\t\tset_bit(HCI_QUIRK_USE_MSFT_EXT_ADDRESS_FILTER, &hdev->quirks);\n\n\t\thci_set_aosp_capable(hdev);\n\t\tbreak;\n\tdefault:\n\t\trtl_dev_dbg(hdev, \"Central-peripheral role not enabled.\");\n\t\trtl_dev_dbg(hdev, \"WBS supported not enabled.\");\n\t\tbreak;\n\t}\n\n\tif (!btrtl_dev->ic_info)\n\t\treturn;\n\n\tswitch (btrtl_dev->ic_info->lmp_subver) {\n\tcase RTL_ROM_LMP_8703B:\n\t\t \n\t\tset_bit(HCI_QUIRK_BROKEN_LOCAL_EXT_FEATURES_PAGE_2,\n\t\t\t&hdev->quirks);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(btrtl_set_quirks);\n\nint btrtl_setup_realtek(struct hci_dev *hdev)\n{\n\tstruct btrtl_device_info *btrtl_dev;\n\tint ret;\n\n\tbtrtl_dev = btrtl_initialize(hdev, NULL);\n\tif (IS_ERR(btrtl_dev))\n\t\treturn PTR_ERR(btrtl_dev);\n\n\tret = btrtl_download_firmware(hdev, btrtl_dev);\n\n\tbtrtl_set_quirks(hdev, btrtl_dev);\n\n\tbtrtl_free(btrtl_dev);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(btrtl_setup_realtek);\n\nint btrtl_shutdown_realtek(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint ret;\n\n\t \n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tret = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"HCI reset during shutdown failed\");\n\t\treturn ret;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btrtl_shutdown_realtek);\n\nstatic unsigned int btrtl_convert_baudrate(u32 device_baudrate)\n{\n\tswitch (device_baudrate) {\n\tcase 0x0252a00a:\n\t\treturn 230400;\n\n\tcase 0x05f75004:\n\t\treturn 921600;\n\n\tcase 0x00005004:\n\t\treturn 1000000;\n\n\tcase 0x04928002:\n\tcase 0x01128002:\n\t\treturn 1500000;\n\n\tcase 0x00005002:\n\t\treturn 2000000;\n\n\tcase 0x0000b001:\n\t\treturn 2500000;\n\n\tcase 0x04928001:\n\t\treturn 3000000;\n\n\tcase 0x052a6001:\n\t\treturn 3500000;\n\n\tcase 0x00005001:\n\t\treturn 4000000;\n\n\tcase 0x0252c014:\n\tdefault:\n\t\treturn 115200;\n\t}\n}\n\nint btrtl_get_uart_settings(struct hci_dev *hdev,\n\t\t\t    struct btrtl_device_info *btrtl_dev,\n\t\t\t    unsigned int *controller_baudrate,\n\t\t\t    u32 *device_baudrate, bool *flow_control)\n{\n\tstruct rtl_vendor_config *config;\n\tstruct rtl_vendor_config_entry *entry;\n\tint i, total_data_len;\n\tbool found = false;\n\n\ttotal_data_len = btrtl_dev->cfg_len - sizeof(*config);\n\tif (total_data_len <= 0) {\n\t\trtl_dev_warn(hdev, \"no config loaded\");\n\t\treturn -EINVAL;\n\t}\n\n\tconfig = (struct rtl_vendor_config *)btrtl_dev->cfg_data;\n\tif (le32_to_cpu(config->signature) != RTL_CONFIG_MAGIC) {\n\t\trtl_dev_err(hdev, \"invalid config magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (total_data_len < le16_to_cpu(config->total_len)) {\n\t\trtl_dev_err(hdev, \"config is too short\");\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < total_data_len; ) {\n\t\tentry = ((void *)config->entry) + i;\n\n\t\tswitch (le16_to_cpu(entry->offset)) {\n\t\tcase 0xc:\n\t\t\tif (entry->len < sizeof(*device_baudrate)) {\n\t\t\t\trtl_dev_err(hdev, \"invalid UART config entry\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\n\t\t\t*device_baudrate = get_unaligned_le32(entry->data);\n\t\t\t*controller_baudrate = btrtl_convert_baudrate(\n\t\t\t\t\t\t\t*device_baudrate);\n\n\t\t\tif (entry->len >= 13)\n\t\t\t\t*flow_control = !!(entry->data[12] & BIT(2));\n\t\t\telse\n\t\t\t\t*flow_control = false;\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trtl_dev_dbg(hdev, \"skipping config entry 0x%x (len %u)\",\n\t\t\t\t   le16_to_cpu(entry->offset), entry->len);\n\t\t\tbreak;\n\t\t}\n\n\t\ti += sizeof(*entry) + entry->len;\n\t}\n\n\tif (!found) {\n\t\trtl_dev_err(hdev, \"no UART config entry found\");\n\t\treturn -ENOENT;\n\t}\n\n\trtl_dev_dbg(hdev, \"device baudrate = 0x%08x\", *device_baudrate);\n\trtl_dev_dbg(hdev, \"controller baudrate = %u\", *controller_baudrate);\n\trtl_dev_dbg(hdev, \"flow control %d\", *flow_control);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btrtl_get_uart_settings);\n\nMODULE_AUTHOR(\"Daniel Drake <drake@endlessm.com>\");\nMODULE_DESCRIPTION(\"Bluetooth support for Realtek devices ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723a_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723b_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723b_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723bs_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723bs_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_cg_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_cg_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_vf_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_vf_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_xx_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723cs_xx_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723d_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723d_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723ds_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8723ds_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761a_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761a_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761b_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761b_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761bu_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8761bu_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821a_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821a_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821c_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821c_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821cs_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8821cs_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822b_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822b_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822cs_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822cs_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822cu_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8822cu_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8851bu_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8851bu_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852au_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852au_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852bs_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852bs_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852bu_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852bu_config.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852cu_fw.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852cu_fw_v2.bin\");\nMODULE_FIRMWARE(\"rtl_bt/rtl8852cu_config.bin\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}