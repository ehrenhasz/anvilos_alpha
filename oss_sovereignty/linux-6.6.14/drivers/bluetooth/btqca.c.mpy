{
  "module_name": "btqca.c",
  "hash_id": "0c5e94d8c2123c87c818c9dfaf15c434441b3f9a4c804da17b2431e27b9345fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btqca.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/vmalloc.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btqca.h\"\n\n#define VERSION \"0.1\"\n\nint qca_read_soc_version(struct hci_dev *hdev, struct qca_btsoc_version *ver,\n\t\t\t enum qca_btsoc_type soc_type)\n{\n\tstruct sk_buff *skb;\n\tstruct edl_event_hdr *edl;\n\tchar cmd;\n\tint err = 0;\n\tu8 event_type = HCI_EV_VENDOR;\n\tu8 rlen = sizeof(*edl) + sizeof(*ver);\n\tu8 rtype = EDL_APP_VER_RES_EVT;\n\n\tbt_dev_dbg(hdev, \"QCA Version Request\");\n\n\t \n\tif (soc_type >= QCA_WCN3991) {\n\t\tevent_type = 0;\n\t\trlen += 1;\n\t\trtype = EDL_PATCH_VER_REQ_CMD;\n\t}\n\n\tcmd = EDL_PATCH_VER_REQ_CMD;\n\tskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, EDL_PATCH_CMD_LEN,\n\t\t\t\t&cmd, event_type, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Reading QCA version information failed (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != rlen) {\n\t\tbt_dev_err(hdev, \"QCA Version size mismatch len %d\", skb->len);\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tedl = (struct edl_event_hdr *)(skb->data);\n\tif (!edl) {\n\t\tbt_dev_err(hdev, \"QCA TLV with no header\");\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (edl->cresp != EDL_CMD_REQ_RES_EVT ||\n\t    edl->rtype != rtype) {\n\t\tbt_dev_err(hdev, \"QCA Wrong packet received %d %d\", edl->cresp,\n\t\t\t   edl->rtype);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tif (soc_type >= QCA_WCN3991)\n\t\tmemcpy(ver, edl->data + 1, sizeof(*ver));\n\telse\n\t\tmemcpy(ver, &edl->data, sizeof(*ver));\n\n\tbt_dev_info(hdev, \"QCA Product ID   :0x%08x\",\n\t\t    le32_to_cpu(ver->product_id));\n\tbt_dev_info(hdev, \"QCA SOC Version  :0x%08x\",\n\t\t    le32_to_cpu(ver->soc_id));\n\tbt_dev_info(hdev, \"QCA ROM Version  :0x%08x\",\n\t\t    le16_to_cpu(ver->rom_ver));\n\tbt_dev_info(hdev, \"QCA Patch Version:0x%08x\",\n\t\t    le16_to_cpu(ver->patch_ver));\n\n\tif (ver->soc_id == 0 || ver->rom_ver == 0)\n\t\terr = -EILSEQ;\n\nout:\n\tkfree_skb(skb);\n\tif (err)\n\t\tbt_dev_err(hdev, \"QCA Failed to get version (%d)\", err);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(qca_read_soc_version);\n\nstatic int qca_read_fw_build_info(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tstruct edl_event_hdr *edl;\n\tchar cmd, build_label[QCA_FW_BUILD_VER_LEN];\n\tint build_lbl_len, err = 0;\n\n\tbt_dev_dbg(hdev, \"QCA read fw build info\");\n\n\tcmd = EDL_GET_BUILD_INFO_CMD;\n\tskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, EDL_PATCH_CMD_LEN,\n\t\t\t\t&cmd, 0, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Reading QCA fw build info failed (%d)\",\n\t\t\t   err);\n\t\treturn err;\n\t}\n\n\tedl = (struct edl_event_hdr *)(skb->data);\n\tif (!edl) {\n\t\tbt_dev_err(hdev, \"QCA read fw build info with no header\");\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (edl->cresp != EDL_CMD_REQ_RES_EVT ||\n\t    edl->rtype != EDL_GET_BUILD_INFO_CMD) {\n\t\tbt_dev_err(hdev, \"QCA Wrong packet received %d %d\", edl->cresp,\n\t\t\t   edl->rtype);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\tbuild_lbl_len = edl->data[0];\n\tif (build_lbl_len <= QCA_FW_BUILD_VER_LEN - 1) {\n\t\tmemcpy(build_label, edl->data + 1, build_lbl_len);\n\t\t*(build_label + build_lbl_len) = '\\0';\n\t}\n\n\thci_set_fw_info(hdev, \"%s\", build_label);\n\nout:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int qca_send_patch_config_cmd(struct hci_dev *hdev)\n{\n\tconst u8 cmd[] = { EDL_PATCH_CONFIG_CMD, 0x01, 0, 0, 0 };\n\tstruct sk_buff *skb;\n\tstruct edl_event_hdr *edl;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"QCA Patch config\");\n\n\tskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, sizeof(cmd),\n\t\t\t\tcmd, HCI_EV_VENDOR, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"Sending QCA Patch config failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != 2) {\n\t\tbt_dev_err(hdev, \"QCA Patch config cmd size mismatch len %d\", skb->len);\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tedl = (struct edl_event_hdr *)(skb->data);\n\tif (!edl) {\n\t\tbt_dev_err(hdev, \"QCA Patch config with no header\");\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (edl->cresp != EDL_PATCH_CONFIG_RES_EVT || edl->rtype != EDL_PATCH_CONFIG_CMD) {\n\t\tbt_dev_err(hdev, \"QCA Wrong packet received %d %d\", edl->cresp,\n\t\t\t   edl->rtype);\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int qca_send_reset(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"QCA HCI_RESET\");\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA Reset failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nint qca_send_pre_shutdown_cmd(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tbt_dev_dbg(hdev, \"QCA pre shutdown cmd\");\n\n\tskb = __hci_cmd_sync_ev(hdev, QCA_PRE_SHUTDOWN_CMD, 0,\n\t\t\t\tNULL, HCI_EV_CMD_COMPLETE, HCI_INIT_TIMEOUT);\n\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA preshutdown_cmd failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qca_send_pre_shutdown_cmd);\n\nstatic void qca_tlv_check_data(struct hci_dev *hdev,\n\t\t\t       struct qca_fw_config *config,\n\t\tu8 *fw_data, enum qca_btsoc_type soc_type)\n{\n\tconst u8 *data;\n\tu32 type_len;\n\tu16 tag_id, tag_len;\n\tint idx, length;\n\tstruct tlv_type_hdr *tlv;\n\tstruct tlv_type_patch *tlv_patch;\n\tstruct tlv_type_nvm *tlv_nvm;\n\tuint8_t nvm_baud_rate = config->user_baud_rate;\n\n\tconfig->dnld_mode = QCA_SKIP_EVT_NONE;\n\tconfig->dnld_type = QCA_SKIP_EVT_NONE;\n\n\tswitch (config->type) {\n\tcase ELF_TYPE_PATCH:\n\t\tconfig->dnld_mode = QCA_SKIP_EVT_VSE_CC;\n\t\tconfig->dnld_type = QCA_SKIP_EVT_VSE_CC;\n\n\t\tbt_dev_dbg(hdev, \"File Class        : 0x%x\", fw_data[4]);\n\t\tbt_dev_dbg(hdev, \"Data Encoding     : 0x%x\", fw_data[5]);\n\t\tbt_dev_dbg(hdev, \"File version      : 0x%x\", fw_data[6]);\n\t\tbreak;\n\tcase TLV_TYPE_PATCH:\n\t\ttlv = (struct tlv_type_hdr *)fw_data;\n\t\ttype_len = le32_to_cpu(tlv->type_len);\n\t\ttlv_patch = (struct tlv_type_patch *)tlv->data;\n\n\t\t \n\t\tconfig->dnld_mode = tlv_patch->download_mode;\n\t\tconfig->dnld_type = config->dnld_mode;\n\n\t\tBT_DBG(\"TLV Type\\t\\t : 0x%x\", type_len & 0x000000ff);\n\t\tBT_DBG(\"Total Length           : %d bytes\",\n\t\t       le32_to_cpu(tlv_patch->total_size));\n\t\tBT_DBG(\"Patch Data Length      : %d bytes\",\n\t\t       le32_to_cpu(tlv_patch->data_length));\n\t\tBT_DBG(\"Signing Format Version : 0x%x\",\n\t\t       tlv_patch->format_version);\n\t\tBT_DBG(\"Signature Algorithm    : 0x%x\",\n\t\t       tlv_patch->signature);\n\t\tBT_DBG(\"Download mode          : 0x%x\",\n\t\t       tlv_patch->download_mode);\n\t\tBT_DBG(\"Reserved               : 0x%x\",\n\t\t       tlv_patch->reserved1);\n\t\tBT_DBG(\"Product ID             : 0x%04x\",\n\t\t       le16_to_cpu(tlv_patch->product_id));\n\t\tBT_DBG(\"Rom Build Version      : 0x%04x\",\n\t\t       le16_to_cpu(tlv_patch->rom_build));\n\t\tBT_DBG(\"Patch Version          : 0x%04x\",\n\t\t       le16_to_cpu(tlv_patch->patch_version));\n\t\tBT_DBG(\"Reserved               : 0x%x\",\n\t\t       le16_to_cpu(tlv_patch->reserved2));\n\t\tBT_DBG(\"Patch Entry Address    : 0x%x\",\n\t\t       le32_to_cpu(tlv_patch->entry));\n\t\tbreak;\n\n\tcase TLV_TYPE_NVM:\n\t\ttlv = (struct tlv_type_hdr *)fw_data;\n\n\t\ttype_len = le32_to_cpu(tlv->type_len);\n\t\tlength = (type_len >> 8) & 0x00ffffff;\n\n\t\tBT_DBG(\"TLV Type\\t\\t : 0x%x\", type_len & 0x000000ff);\n\t\tBT_DBG(\"Length\\t\\t : %d bytes\", length);\n\n\t\tidx = 0;\n\t\tdata = tlv->data;\n\t\twhile (idx < length) {\n\t\t\ttlv_nvm = (struct tlv_type_nvm *)(data + idx);\n\n\t\t\ttag_id = le16_to_cpu(tlv_nvm->tag_id);\n\t\t\ttag_len = le16_to_cpu(tlv_nvm->tag_len);\n\n\t\t\t \n\t\t\tswitch (tag_id) {\n\t\t\tcase EDL_TAG_ID_HCI:\n\t\t\t\t \n\t\t\t\ttlv_nvm->data[0] |= 0x80;\n\n\t\t\t\t \n\t\t\t\tif (soc_type >= QCA_WCN3991)\n\t\t\t\t\ttlv_nvm->data[1] = nvm_baud_rate;\n\t\t\t\telse\n\t\t\t\t\ttlv_nvm->data[2] = nvm_baud_rate;\n\n\t\t\t\tbreak;\n\n\t\t\tcase EDL_TAG_ID_DEEP_SLEEP:\n\t\t\t\t \n\t\t\t\ttlv_nvm->data[0] |= 0x01;\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tidx += (sizeof(u16) + sizeof(u16) + 8 + tag_len);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown TLV type %d\", config->type);\n\t\tbreak;\n\t}\n}\n\nstatic int qca_tlv_send_segment(struct hci_dev *hdev, int seg_size,\n\t\t\t\tconst u8 *data, enum qca_tlv_dnld_mode mode,\n\t\t\t\tenum qca_btsoc_type soc_type)\n{\n\tstruct sk_buff *skb;\n\tstruct edl_event_hdr *edl;\n\tstruct tlv_seg_resp *tlv_resp;\n\tu8 cmd[MAX_SIZE_PER_TLV_SEGMENT + 2];\n\tint err = 0;\n\tu8 event_type = HCI_EV_VENDOR;\n\tu8 rlen = (sizeof(*edl) + sizeof(*tlv_resp));\n\tu8 rtype = EDL_TVL_DNLD_RES_EVT;\n\n\tcmd[0] = EDL_PATCH_TLV_REQ_CMD;\n\tcmd[1] = seg_size;\n\tmemcpy(cmd + 2, data, seg_size);\n\n\tif (mode == QCA_SKIP_EVT_VSE_CC || mode == QCA_SKIP_EVT_VSE)\n\t\treturn __hci_cmd_send(hdev, EDL_PATCH_CMD_OPCODE, seg_size + 2,\n\t\t\t\t      cmd);\n\n\t \n\tif (soc_type >= QCA_WCN3991) {\n\t\tevent_type = 0;\n\t\trlen = sizeof(*edl);\n\t\trtype = EDL_PATCH_TLV_REQ_CMD;\n\t}\n\n\tskb = __hci_cmd_sync_ev(hdev, EDL_PATCH_CMD_OPCODE, seg_size + 2, cmd,\n\t\t\t\tevent_type, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA Failed to send TLV segment (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != rlen) {\n\t\tbt_dev_err(hdev, \"QCA TLV response size mismatch\");\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tedl = (struct edl_event_hdr *)(skb->data);\n\tif (!edl) {\n\t\tbt_dev_err(hdev, \"TLV with no header\");\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tif (edl->cresp != EDL_CMD_REQ_RES_EVT || edl->rtype != rtype) {\n\t\tbt_dev_err(hdev, \"QCA TLV with error stat 0x%x rtype 0x%x\",\n\t\t\t   edl->cresp, edl->rtype);\n\t\terr = -EIO;\n\t}\n\n\tif (soc_type >= QCA_WCN3991)\n\t\tgoto out;\n\n\ttlv_resp = (struct tlv_seg_resp *)(edl->data);\n\tif (tlv_resp->result) {\n\t\tbt_dev_err(hdev, \"QCA TLV with error stat 0x%x rtype 0x%x (0x%x)\",\n\t\t\t   edl->cresp, edl->rtype, tlv_resp->result);\n\t}\n\nout:\n\tkfree_skb(skb);\n\n\treturn err;\n}\n\nstatic int qca_inject_cmd_complete_event(struct hci_dev *hdev)\n{\n\tstruct hci_event_hdr *hdr;\n\tstruct hci_ev_cmd_complete *evt;\n\tstruct sk_buff *skb;\n\n\tskb = bt_skb_alloc(sizeof(*hdr) + sizeof(*evt) + 1, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\thdr = skb_put(skb, sizeof(*hdr));\n\thdr->evt = HCI_EV_CMD_COMPLETE;\n\thdr->plen = sizeof(*evt) + 1;\n\n\tevt = skb_put(skb, sizeof(*evt));\n\tevt->ncmd = 1;\n\tevt->opcode = cpu_to_le16(QCA_HCI_CC_OPCODE);\n\n\tskb_put_u8(skb, QCA_HCI_CC_SUCCESS);\n\n\thci_skb_pkt_type(skb) = HCI_EVENT_PKT;\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int qca_download_firmware(struct hci_dev *hdev,\n\t\t\t\t struct qca_fw_config *config,\n\t\t\t\t enum qca_btsoc_type soc_type,\n\t\t\t\t u8 rom_ver)\n{\n\tconst struct firmware *fw;\n\tu8 *data;\n\tconst u8 *segment;\n\tint ret, size, remain, i = 0;\n\n\tbt_dev_info(hdev, \"QCA Downloading %s\", config->fwname);\n\n\tret = request_firmware(&fw, config->fwname, &hdev->dev);\n\tif (ret) {\n\t\t \n\t\tif (soc_type == QCA_WCN6750 && config->type == ELF_TYPE_PATCH) {\n\t\t\tbt_dev_dbg(hdev, \"QCA Failed to request file: %s (%d)\",\n\t\t\t\t   config->fwname, ret);\n\t\t\tconfig->type = TLV_TYPE_PATCH;\n\t\t\tsnprintf(config->fwname, sizeof(config->fwname),\n\t\t\t\t \"qca/msbtfw%02x.tlv\", rom_ver);\n\t\t\tbt_dev_info(hdev, \"QCA Downloading %s\", config->fwname);\n\t\t\tret = request_firmware(&fw, config->fwname, &hdev->dev);\n\t\t\tif (ret) {\n\t\t\t\tbt_dev_err(hdev, \"QCA Failed to request file: %s (%d)\",\n\t\t\t\t\t   config->fwname, ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tbt_dev_err(hdev, \"QCA Failed to request file: %s (%d)\",\n\t\t\t\t   config->fwname, ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tsize = fw->size;\n\tdata = vmalloc(fw->size);\n\tif (!data) {\n\t\tbt_dev_err(hdev, \"QCA Failed to allocate memory for file: %s\",\n\t\t\t   config->fwname);\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(data, fw->data, size);\n\trelease_firmware(fw);\n\n\tqca_tlv_check_data(hdev, config, data, soc_type);\n\n\tsegment = data;\n\tremain = size;\n\twhile (remain > 0) {\n\t\tint segsize = min(MAX_SIZE_PER_TLV_SEGMENT, remain);\n\n\t\tbt_dev_dbg(hdev, \"Send segment %d, size %d\", i++, segsize);\n\n\t\tremain -= segsize;\n\t\t \n\t\tif (!remain || segsize < MAX_SIZE_PER_TLV_SEGMENT)\n\t\t\tconfig->dnld_mode = QCA_SKIP_EVT_NONE;\n\n\t\tret = qca_tlv_send_segment(hdev, segsize, segment,\n\t\t\t\t\t   config->dnld_mode, soc_type);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tsegment += segsize;\n\t}\n\n\t \n\tif (config->dnld_type == QCA_SKIP_EVT_VSE_CC ||\n\t    config->dnld_type == QCA_SKIP_EVT_VSE)\n\t\tret = qca_inject_cmd_complete_event(hdev);\n\nout:\n\tvfree(data);\n\n\treturn ret;\n}\n\nstatic int qca_disable_soc_logging(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tu8 cmd[2];\n\tint err;\n\n\tcmd[0] = QCA_DISABLE_LOGGING_SUB_OP;\n\tcmd[1] = 0x00;\n\tskb = __hci_cmd_sync_ev(hdev, QCA_DISABLE_LOGGING, sizeof(cmd), cmd,\n\t\t\t\tHCI_EV_CMD_COMPLETE, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA Failed to disable soc logging(%d)\", err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nint qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tu8 cmd[9];\n\tint err;\n\n\tcmd[0] = EDL_NVM_ACCESS_SET_REQ_CMD;\n\tcmd[1] = 0x02; \t\t\t \n\tcmd[2] = sizeof(bdaddr_t);\t \n\tmemcpy(cmd + 3, bdaddr, sizeof(bdaddr_t));\n\tskb = __hci_cmd_sync_ev(hdev, EDL_NVM_ACCESS_OPCODE, sizeof(cmd), cmd,\n\t\t\t\tHCI_EV_VENDOR, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA Change address command failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qca_set_bdaddr_rome);\n\nint qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,\n\t\t   enum qca_btsoc_type soc_type, struct qca_btsoc_version ver,\n\t\t   const char *firmware_name)\n{\n\tstruct qca_fw_config config;\n\tint err;\n\tu8 rom_ver = 0;\n\tu32 soc_ver;\n\n\tbt_dev_dbg(hdev, \"QCA setup on UART\");\n\n\tsoc_ver = get_soc_ver(ver.soc_id, ver.rom_ver);\n\n\tbt_dev_info(hdev, \"QCA controller version 0x%08x\", soc_ver);\n\n\tconfig.user_baud_rate = baudrate;\n\n\t \n\tif (soc_type == QCA_WCN3988)\n\t\trom_ver = ((soc_ver & 0x00000f00) >> 0x05) | (soc_ver & 0x0000000f);\n\telse\n\t\trom_ver = ((soc_ver & 0x00000f00) >> 0x04) | (soc_ver & 0x0000000f);\n\n\tif (soc_type == QCA_WCN6750)\n\t\tqca_send_patch_config_cmd(hdev);\n\n\t \n\tconfig.type = TLV_TYPE_PATCH;\n\tswitch (soc_type) {\n\tcase QCA_WCN3990:\n\tcase QCA_WCN3991:\n\tcase QCA_WCN3998:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/crbtfw%02x.tlv\", rom_ver);\n\t\tbreak;\n\tcase QCA_WCN3988:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/apbtfw%02x.tlv\", rom_ver);\n\t\tbreak;\n\tcase QCA_QCA6390:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/htbtfw%02x.tlv\", rom_ver);\n\t\tbreak;\n\tcase QCA_WCN6750:\n\t\t \n\t\tconfig.type = ELF_TYPE_PATCH;\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/msbtfw%02x.mbn\", rom_ver);\n\t\tbreak;\n\tcase QCA_WCN6855:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/hpbtfw%02x.tlv\", rom_ver);\n\t\tbreak;\n\tcase QCA_WCN7850:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/hmtbtfw%02x.tlv\", rom_ver);\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/rampatch_%08x.bin\", soc_ver);\n\t}\n\n\terr = qca_download_firmware(hdev, &config, soc_type, rom_ver);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"QCA Failed to download patch (%d)\", err);\n\t\treturn err;\n\t}\n\n\t \n\tmsleep(10);\n\n\t \n\tconfig.type = TLV_TYPE_NVM;\n\tif (firmware_name) {\n\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t \"qca/%s\", firmware_name);\n\t} else {\n\t\tswitch (soc_type) {\n\t\tcase QCA_WCN3990:\n\t\tcase QCA_WCN3991:\n\t\tcase QCA_WCN3998:\n\t\t\tif (le32_to_cpu(ver.soc_id) == QCA_WCN3991_SOC_ID) {\n\t\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t\t \"qca/crnv%02xu.bin\", rom_ver);\n\t\t\t} else {\n\t\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t\t \"qca/crnv%02x.bin\", rom_ver);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase QCA_WCN3988:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/apnv%02x.bin\", rom_ver);\n\t\t\tbreak;\n\t\tcase QCA_QCA6390:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/htnv%02x.bin\", rom_ver);\n\t\t\tbreak;\n\t\tcase QCA_WCN6750:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/msnv%02x.bin\", rom_ver);\n\t\t\tbreak;\n\t\tcase QCA_WCN6855:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/hpnv%02x.bin\", rom_ver);\n\t\t\tbreak;\n\t\tcase QCA_WCN7850:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/hmtnv%02x.bin\", rom_ver);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tsnprintf(config.fwname, sizeof(config.fwname),\n\t\t\t\t \"qca/nvm_%08x.bin\", soc_ver);\n\t\t}\n\t}\n\n\terr = qca_download_firmware(hdev, &config, soc_type, rom_ver);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"QCA Failed to download NVM (%d)\", err);\n\t\treturn err;\n\t}\n\n\tswitch (soc_type) {\n\tcase QCA_WCN3991:\n\tcase QCA_QCA6390:\n\tcase QCA_WCN6750:\n\tcase QCA_WCN6855:\n\tcase QCA_WCN7850:\n\t\terr = qca_disable_soc_logging(hdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tswitch (soc_type) {\n\tcase QCA_WCN3988:\n\tcase QCA_WCN3990:\n\tcase QCA_WCN3991:\n\tcase QCA_WCN3998:\n\tcase QCA_WCN6750:\n\t\thci_set_msft_opcode(hdev, 0xFD70);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\terr = qca_send_reset(hdev);\n\tif (err < 0) {\n\t\tbt_dev_err(hdev, \"QCA Failed to run HCI_RESET (%d)\", err);\n\t\treturn err;\n\t}\n\n\tswitch (soc_type) {\n\tcase QCA_WCN3991:\n\tcase QCA_WCN6750:\n\tcase QCA_WCN6855:\n\tcase QCA_WCN7850:\n\t\t \n\t\terr = qca_read_fw_build_info(hdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tbt_dev_info(hdev, \"QCA setup on UART is completed\");\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qca_uart_setup);\n\nint qca_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = __hci_cmd_sync_ev(hdev, EDL_WRITE_BD_ADDR_OPCODE, 6, bdaddr,\n\t\t\t\tHCI_EV_VENDOR, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"QCA Change address cmd failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(qca_set_bdaddr);\n\n\nMODULE_AUTHOR(\"Ben Young Tae Kim <ytkim@qca.qualcomm.com>\");\nMODULE_DESCRIPTION(\"Bluetooth support for Qualcomm Atheros family ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}