{
  "module_name": "btbcm.c",
  "hash_id": "8bb758f35e8f94f0b937670dcb5016f29f0bcf634c5de8e3008993157315e4e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btbcm.c",
  "human_readable_source": "\n \n\n#include <linux/efi.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/dmi.h>\n#include <linux/of.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btbcm.h\"\n\n#define VERSION \"0.1\"\n\n#define BDADDR_BCM20702A0 (&(bdaddr_t) {{0x00, 0xa0, 0x02, 0x70, 0x20, 0x00}})\n#define BDADDR_BCM20702A1 (&(bdaddr_t) {{0x00, 0x00, 0xa0, 0x02, 0x70, 0x20}})\n#define BDADDR_BCM2076B1 (&(bdaddr_t) {{0x79, 0x56, 0x00, 0xa0, 0x76, 0x20}})\n#define BDADDR_BCM43430A0 (&(bdaddr_t) {{0xac, 0x1f, 0x12, 0xa0, 0x43, 0x43}})\n#define BDADDR_BCM43430A1 (&(bdaddr_t) {{0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}})\n#define BDADDR_BCM4324B3 (&(bdaddr_t) {{0x00, 0x00, 0x00, 0xb3, 0x24, 0x43}})\n#define BDADDR_BCM4330B1 (&(bdaddr_t) {{0x00, 0x00, 0x00, 0xb1, 0x30, 0x43}})\n#define BDADDR_BCM4334B0 (&(bdaddr_t) {{0x00, 0x00, 0x00, 0xb0, 0x34, 0x43}})\n#define BDADDR_BCM4345C5 (&(bdaddr_t) {{0xac, 0x1f, 0x00, 0xc5, 0x45, 0x43}})\n#define BDADDR_BCM43341B (&(bdaddr_t) {{0xac, 0x1f, 0x00, 0x1b, 0x34, 0x43}})\n\n#define BCM_FW_NAME_LEN\t\t\t64\n#define BCM_FW_NAME_COUNT_MAX\t\t4\n \ntypedef char bcm_fw_name[BCM_FW_NAME_LEN];\n\n#ifdef CONFIG_EFI\nstatic int btbcm_set_bdaddr_from_efi(struct hci_dev *hdev)\n{\n\tefi_guid_t guid = EFI_GUID(0x74b00bd9, 0x805a, 0x4d61, 0xb5, 0x1f,\n\t\t\t\t   0x43, 0x26, 0x81, 0x23, 0xd1, 0x13);\n\tbdaddr_t efi_bdaddr, bdaddr;\n\tefi_status_t status;\n\tunsigned long len;\n\tint ret;\n\n\tif (!efi_rt_services_supported(EFI_RT_SUPPORTED_GET_VARIABLE))\n\t\treturn -EOPNOTSUPP;\n\n\tlen = sizeof(efi_bdaddr);\n\tstatus = efi.get_variable(L\"BDADDR\", &guid, NULL, &len, &efi_bdaddr);\n\tif (status != EFI_SUCCESS)\n\t\treturn -ENXIO;\n\n\tif (len != sizeof(efi_bdaddr))\n\t\treturn -EIO;\n\n\tbaswap(&bdaddr, &efi_bdaddr);\n\n\tret = btbcm_set_bdaddr(hdev, &bdaddr);\n\tif (ret)\n\t\treturn ret;\n\n\tbt_dev_info(hdev, \"BCM: Using EFI device address (%pMR)\", &bdaddr);\n\treturn 0;\n}\n#else\nstatic int btbcm_set_bdaddr_from_efi(struct hci_dev *hdev)\n{\n\treturn -EOPNOTSUPP;\n}\n#endif\n\nint btbcm_check_bdaddr(struct hci_dev *hdev)\n{\n\tstruct hci_rp_read_bd_addr *bda;\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_BD_ADDR, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\n\t\tbt_dev_err(hdev, \"BCM: Reading device address failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != sizeof(*bda)) {\n\t\tbt_dev_err(hdev, \"BCM: Device address length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tbda = (struct hci_rp_read_bd_addr *)skb->data;\n\n\t \n\tif (!bacmp(&bda->bdaddr, BDADDR_BCM20702A0) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM20702A1) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM2076B1) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM4324B3) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM4330B1) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM4334B0) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM4345C5) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM43430A0) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM43430A1) ||\n\t    !bacmp(&bda->bdaddr, BDADDR_BCM43341B)) {\n\t\t \n\t\tif (btbcm_set_bdaddr_from_efi(hdev) != 0) {\n\t\t\tbt_dev_info(hdev, \"BCM: Using default device address (%pMR)\",\n\t\t\t\t    &bda->bdaddr);\n\t\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hdev->quirks);\n\t\t}\n\t}\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_check_bdaddr);\n\nint btbcm_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc01, 6, bdaddr, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"BCM: Change address command failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_set_bdaddr);\n\nint btbcm_read_pcm_int_params(struct hci_dev *hdev,\n\t\t\t      struct bcm_set_pcm_int_params *params)\n{\n\tstruct sk_buff *skb;\n\tint err = 0;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc1d, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"BCM: Read PCM int params failed (%d)\", err);\n\t\treturn err;\n\t}\n\n\tif (skb->len != 6 || skb->data[0]) {\n\t\tbt_dev_err(hdev, \"BCM: Read PCM int params length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn -EIO;\n\t}\n\n\tif (params)\n\t\tmemcpy(params, skb->data + 1, 5);\n\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_read_pcm_int_params);\n\nint btbcm_write_pcm_int_params(struct hci_dev *hdev,\n\t\t\t       const struct bcm_set_pcm_int_params *params)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc1c, 5, params, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"BCM: Write PCM int params failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_write_pcm_int_params);\n\nint btbcm_patchram(struct hci_dev *hdev, const struct firmware *fw)\n{\n\tconst struct hci_command_hdr *cmd;\n\tconst u8 *fw_ptr;\n\tsize_t fw_size;\n\tstruct sk_buff *skb;\n\tu16 opcode;\n\tint err = 0;\n\n\t \n\tskb = __hci_cmd_sync(hdev, 0xfc2e, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\terr = PTR_ERR(skb);\n\t\tbt_dev_err(hdev, \"BCM: Download Minidrv command failed (%d)\",\n\t\t\t   err);\n\t\tgoto done;\n\t}\n\tkfree_skb(skb);\n\n\t \n\tmsleep(50);\n\n\tfw_ptr = fw->data;\n\tfw_size = fw->size;\n\n\twhile (fw_size >= sizeof(*cmd)) {\n\t\tconst u8 *cmd_param;\n\n\t\tcmd = (struct hci_command_hdr *)fw_ptr;\n\t\tfw_ptr += sizeof(*cmd);\n\t\tfw_size -= sizeof(*cmd);\n\n\t\tif (fw_size < cmd->plen) {\n\t\t\tbt_dev_err(hdev, \"BCM: Patch is corrupted\");\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\n\t\tcmd_param = fw_ptr;\n\t\tfw_ptr += cmd->plen;\n\t\tfw_size -= cmd->plen;\n\n\t\topcode = le16_to_cpu(cmd->opcode);\n\n\t\tskb = __hci_cmd_sync(hdev, opcode, cmd->plen, cmd_param,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (IS_ERR(skb)) {\n\t\t\terr = PTR_ERR(skb);\n\t\t\tbt_dev_err(hdev, \"BCM: Patch command %04x failed (%d)\",\n\t\t\t\t   opcode, err);\n\t\t\tgoto done;\n\t\t}\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tmsleep(250);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(btbcm_patchram);\n\nstatic int btbcm_reset(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tint err = PTR_ERR(skb);\n\n\t\tbt_dev_err(hdev, \"BCM: Reset failed (%d)\", err);\n\t\treturn err;\n\t}\n\tkfree_skb(skb);\n\n\t \n\tmsleep(100);\n\n\treturn 0;\n}\n\nstatic struct sk_buff *btbcm_read_local_name(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_NAME, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"BCM: Reading local name failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != sizeof(struct hci_rp_read_local_name)) {\n\t\tbt_dev_err(hdev, \"BCM: Local name length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *btbcm_read_local_version(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"BCM: Reading local version info failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != sizeof(struct hci_rp_read_local_version)) {\n\t\tbt_dev_err(hdev, \"BCM: Local version length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *btbcm_read_verbose_config(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc79, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"BCM: Read verbose config info failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != 7) {\n\t\tbt_dev_err(hdev, \"BCM: Verbose config length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *btbcm_read_controller_features(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc6e, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"BCM: Read controller features failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != 9) {\n\t\tbt_dev_err(hdev, \"BCM: Controller features length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic struct sk_buff *btbcm_read_usb_product(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, 0xfc5a, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"BCM: Read USB product info failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn skb;\n\t}\n\n\tif (skb->len != 5) {\n\t\tbt_dev_err(hdev, \"BCM: USB product length mismatch\");\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-EIO);\n\t}\n\n\treturn skb;\n}\n\nstatic const struct dmi_system_id disable_broken_read_transmit_power[] = {\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro16,1\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro16,2\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookPro16,4\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookAir8,1\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"MacBookAir8,2\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"iMac20,1\"),\n\t\t},\n\t},\n\t{\n\t\t .matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"Apple Inc.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"iMac20,2\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic int btbcm_read_info(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = btbcm_read_verbose_config(hdev);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"BCM: chip id %u\", skb->data[1]);\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstatic int btbcm_print_controller_features(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = btbcm_read_controller_features(hdev);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"BCM: features 0x%2.2x\", skb->data[1]);\n\tkfree_skb(skb);\n\n\t \n\tif (dmi_first_match(disable_broken_read_transmit_power))\n\t\tset_bit(HCI_QUIRK_BROKEN_READ_TRANSMIT_POWER, &hdev->quirks);\n\n\treturn 0;\n}\n\nstatic int btbcm_print_local_name(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = btbcm_read_local_name(hdev);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tbt_dev_info(hdev, \"%s\", (char *)(skb->data + 1));\n\tkfree_skb(skb);\n\n\treturn 0;\n}\n\nstruct bcm_subver_table {\n\tu16 subver;\n\tconst char *name;\n};\n\nstatic const struct bcm_subver_table bcm_uart_subver_table[] = {\n\t{ 0x1111, \"BCM4362A2\"\t},\t \n\t{ 0x4103, \"BCM4330B1\"\t},\t \n\t{ 0x410d, \"BCM4334B0\"\t},\t \n\t{ 0x410e, \"BCM43341B0\"\t},\t \n\t{ 0x4204, \"BCM2076B1\"\t},\t \n\t{ 0x4406, \"BCM4324B3\"\t},\t \n\t{ 0x4606, \"BCM4324B5\"\t},\t \n\t{ 0x6109, \"BCM4335C0\"\t},\t \n\t{ 0x610c, \"BCM4354\"\t},\t \n\t{ 0x2122, \"BCM4343A0\"\t},\t \n\t{ 0x2209, \"BCM43430A1\"  },\t \n\t{ 0x6119, \"BCM4345C0\"\t},\t \n\t{ 0x6606, \"BCM4345C5\"\t},\t \n\t{ 0x230f, \"BCM4356A2\"\t},\t \n\t{ 0x220e, \"BCM20702A1\"  },\t \n\t{ 0x420d, \"BCM4349B1\"\t},\t \n\t{ 0x420e, \"BCM4349B1\"\t},\t \n\t{ 0x4217, \"BCM4329B1\"   },\t \n\t{ 0x6106, \"BCM4359C0\"\t},\t \n\t{ 0x4106, \"BCM4335A0\"\t},\t \n\t{ 0x410c, \"BCM43430B0\"\t},\t \n\t{ 0x2119, \"BCM4373A0\"\t},\t \n\t{ }\n};\n\nstatic const struct bcm_subver_table bcm_usb_subver_table[] = {\n\t{ 0x2105, \"BCM20703A1\"\t},\t \n\t{ 0x210b, \"BCM43142A0\"\t},\t \n\t{ 0x2112, \"BCM4314A0\"\t},\t \n\t{ 0x2118, \"BCM20702A0\"\t},\t \n\t{ 0x2126, \"BCM4335A0\"\t},\t \n\t{ 0x220e, \"BCM20702A1\"\t},\t \n\t{ 0x230f, \"BCM4356A2\"\t},\t \n\t{ 0x4106, \"BCM4335B0\"\t},\t \n\t{ 0x410e, \"BCM20702B0\"\t},\t \n\t{ 0x6109, \"BCM4335C0\"\t},\t \n\t{ 0x610c, \"BCM4354\"\t},\t \n\t{ 0x6607, \"BCM4350C5\"\t},\t \n\t{ }\n};\n\n \nstatic const char *btbcm_get_board_name(struct device *dev)\n{\n#ifdef CONFIG_OF\n\tstruct device_node *root;\n\tchar *board_type;\n\tconst char *tmp;\n\tint len;\n\tint i;\n\n\troot = of_find_node_by_path(\"/\");\n\tif (!root)\n\t\treturn NULL;\n\n\tif (of_property_read_string_index(root, \"compatible\", 0, &tmp))\n\t\treturn NULL;\n\n\t \n\tlen = strlen(tmp) + 1;\n\tboard_type = devm_kzalloc(dev, len, GFP_KERNEL);\n\tstrscpy(board_type, tmp, len);\n\tfor (i = 0; i < len; i++) {\n\t\tif (board_type[i] == '/')\n\t\t\tboard_type[i] = '-';\n\t}\n\tof_node_put(root);\n\n\treturn board_type;\n#else\n\treturn NULL;\n#endif\n}\n\nint btbcm_initialize(struct hci_dev *hdev, bool *fw_load_done, bool use_autobaud_mode)\n{\n\tu16 subver, rev, pid, vid;\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_version *ver;\n\tconst struct bcm_subver_table *bcm_subver_table;\n\tconst char *hw_name = NULL;\n\tconst char *board_name;\n\tchar postfix[16] = \"\";\n\tint fw_name_count = 0;\n\tbcm_fw_name *fw_name;\n\tconst struct firmware *fw;\n\tint i, err;\n\n\tboard_name = btbcm_get_board_name(&hdev->dev);\n\n\t \n\terr = btbcm_reset(hdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tskb = btbcm_read_local_version(hdev);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\trev = le16_to_cpu(ver->hci_rev);\n\tsubver = le16_to_cpu(ver->lmp_subver);\n\tkfree_skb(skb);\n\n\t \n\tif (!(*fw_load_done)) {\n\t\terr = btbcm_read_info(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!use_autobaud_mode) {\n\t\terr = btbcm_print_controller_features(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = btbcm_print_local_name(hdev);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbcm_subver_table = (hdev->bus == HCI_USB) ? bcm_usb_subver_table :\n\t\t\t\t\t\t    bcm_uart_subver_table;\n\n\tfor (i = 0; bcm_subver_table[i].name; i++) {\n\t\tif (subver == bcm_subver_table[i].subver) {\n\t\t\thw_name = bcm_subver_table[i].name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbt_dev_info(hdev, \"%s (%3.3u.%3.3u.%3.3u) build %4.4u\",\n\t\t    hw_name ? hw_name : \"BCM\", (subver & 0xe000) >> 13,\n\t\t    (subver & 0x1f00) >> 8, (subver & 0x00ff), rev & 0x0fff);\n\n\tif (*fw_load_done)\n\t\treturn 0;\n\n\tif (hdev->bus == HCI_USB) {\n\t\t \n\t\tskb = btbcm_read_usb_product(hdev);\n\t\tif (IS_ERR(skb))\n\t\t\treturn PTR_ERR(skb);\n\n\t\tvid = get_unaligned_le16(skb->data + 1);\n\t\tpid = get_unaligned_le16(skb->data + 3);\n\t\tkfree_skb(skb);\n\n\t\tsnprintf(postfix, sizeof(postfix), \"-%4.4x-%4.4x\", vid, pid);\n\t}\n\n\tfw_name = kmalloc(BCM_FW_NAME_COUNT_MAX * BCM_FW_NAME_LEN, GFP_KERNEL);\n\tif (!fw_name)\n\t\treturn -ENOMEM;\n\n\tif (hw_name) {\n\t\tif (board_name) {\n\t\t\tsnprintf(fw_name[fw_name_count], BCM_FW_NAME_LEN,\n\t\t\t\t \"brcm/%s%s.%s.hcd\", hw_name, postfix, board_name);\n\t\t\tfw_name_count++;\n\t\t}\n\t\tsnprintf(fw_name[fw_name_count], BCM_FW_NAME_LEN,\n\t\t\t \"brcm/%s%s.hcd\", hw_name, postfix);\n\t\tfw_name_count++;\n\t}\n\n\tif (board_name) {\n\t\tsnprintf(fw_name[fw_name_count], BCM_FW_NAME_LEN,\n\t\t\t \"brcm/BCM%s.%s.hcd\", postfix, board_name);\n\t\tfw_name_count++;\n\t}\n\tsnprintf(fw_name[fw_name_count], BCM_FW_NAME_LEN,\n\t\t \"brcm/BCM%s.hcd\", postfix);\n\tfw_name_count++;\n\n\tfor (i = 0; i < fw_name_count; i++) {\n\t\terr = firmware_request_nowarn(&fw, fw_name[i], &hdev->dev);\n\t\tif (err == 0) {\n\t\t\tbt_dev_info(hdev, \"%s '%s' Patch\",\n\t\t\t\t    hw_name ? hw_name : \"BCM\", fw_name[i]);\n\t\t\t*fw_load_done = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (*fw_load_done) {\n\t\terr = btbcm_patchram(hdev, fw);\n\t\tif (err)\n\t\t\tbt_dev_info(hdev, \"BCM: Patch failed (%d)\", err);\n\n\t\trelease_firmware(fw);\n\t} else {\n\t\tbt_dev_err(hdev, \"BCM: firmware Patch file not found, tried:\");\n\t\tfor (i = 0; i < fw_name_count; i++)\n\t\t\tbt_dev_err(hdev, \"BCM: '%s'\", fw_name[i]);\n\t}\n\n\tkfree(fw_name);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_initialize);\n\nint btbcm_finalize(struct hci_dev *hdev, bool *fw_load_done, bool use_autobaud_mode)\n{\n\tint err;\n\n\t \n\tif (*fw_load_done) {\n\t\terr = btbcm_initialize(hdev, fw_load_done, use_autobaud_mode);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tbtbcm_check_bdaddr(hdev);\n\n\tset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_finalize);\n\nint btbcm_setup_patchram(struct hci_dev *hdev)\n{\n\tbool fw_load_done = false;\n\tbool use_autobaud_mode = false;\n\tint err;\n\n\t \n\terr = btbcm_initialize(hdev, &fw_load_done, use_autobaud_mode);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn btbcm_finalize(hdev, &fw_load_done, use_autobaud_mode);\n}\nEXPORT_SYMBOL_GPL(btbcm_setup_patchram);\n\nint btbcm_setup_apple(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\tint err;\n\n\t \n\terr = btbcm_reset(hdev);\n\tif (err)\n\t\treturn err;\n\n\t \n\tskb = btbcm_read_verbose_config(hdev);\n\tif (!IS_ERR(skb)) {\n\t\tbt_dev_info(hdev, \"BCM: chip id %u build %4.4u\",\n\t\t\t    skb->data[1], get_unaligned_le16(skb->data + 5));\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tskb = btbcm_read_usb_product(hdev);\n\tif (!IS_ERR(skb)) {\n\t\tbt_dev_info(hdev, \"BCM: product %4.4x:%4.4x\",\n\t\t\t    get_unaligned_le16(skb->data + 1),\n\t\t\t    get_unaligned_le16(skb->data + 3));\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tskb = btbcm_read_controller_features(hdev);\n\tif (!IS_ERR(skb)) {\n\t\tbt_dev_info(hdev, \"BCM: features 0x%2.2x\", skb->data[1]);\n\t\tkfree_skb(skb);\n\t}\n\n\t \n\tskb = btbcm_read_local_name(hdev);\n\tif (!IS_ERR(skb)) {\n\t\tbt_dev_info(hdev, \"%s\", (char *)(skb->data + 1));\n\t\tkfree_skb(skb);\n\t}\n\n\tset_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &hdev->quirks);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(btbcm_setup_apple);\n\nMODULE_AUTHOR(\"Marcel Holtmann <marcel@holtmann.org>\");\nMODULE_DESCRIPTION(\"Bluetooth support for Broadcom devices ver \" VERSION);\nMODULE_VERSION(VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}