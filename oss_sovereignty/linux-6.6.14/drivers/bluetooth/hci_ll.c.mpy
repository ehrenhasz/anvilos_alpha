{
  "module_name": "hci_ll.c",
  "hash_id": "d7b4017b2fe05637dc5f692e6e01ab37cb3f540fc3613206ac6a2ff765442c3d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_ll.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/of.h>\n#include <linux/serdev.h>\n#include <linux/skbuff.h>\n#include <linux/ti_wilink_st.h>\n#include <linux/clk.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <linux/gpio/consumer.h>\n#include <linux/nvmem-consumer.h>\n\n#include \"hci_uart.h\"\n\n \n#define HCI_VS_WRITE_BD_ADDR\t\t\t0xfc06\n#define HCI_VS_UPDATE_UART_HCI_BAUDRATE\t\t0xff36\n\n \n#define HCILL_GO_TO_SLEEP_IND\t0x30\n#define HCILL_GO_TO_SLEEP_ACK\t0x31\n#define HCILL_WAKE_UP_IND\t0x32\n#define HCILL_WAKE_UP_ACK\t0x33\n\n \nenum hcill_states_e {\n\tHCILL_ASLEEP,\n\tHCILL_ASLEEP_TO_AWAKE,\n\tHCILL_AWAKE,\n\tHCILL_AWAKE_TO_ASLEEP\n};\n\nstruct ll_device {\n\tstruct hci_uart hu;\n\tstruct serdev_device *serdev;\n\tstruct gpio_desc *enable_gpio;\n\tstruct clk *ext_clk;\n\tbdaddr_t bdaddr;\n};\n\nstruct ll_struct {\n\tstruct sk_buff *rx_skb;\n\tstruct sk_buff_head txq;\n\tspinlock_t hcill_lock;\t\t \n\tunsigned long hcill_state;\t \n\tstruct sk_buff_head tx_wait_q;\t \n};\n\n \nstatic int send_hcill_cmd(u8 cmd, struct hci_uart *hu)\n{\n\tint err = 0;\n\tstruct sk_buff *skb = NULL;\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p cmd 0x%x\", hu, cmd);\n\n\t \n\tskb = bt_skb_alloc(1, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"cannot allocate memory for HCILL packet\");\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\t \n\tskb_put_u8(skb, cmd);\n\n\t \n\tskb_queue_tail(&ll->txq, skb);\nout:\n\treturn err;\n}\n\n \nstatic int ll_open(struct hci_uart *hu)\n{\n\tstruct ll_struct *ll;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tll = kzalloc(sizeof(*ll), GFP_KERNEL);\n\tif (!ll)\n\t\treturn -ENOMEM;\n\n\tskb_queue_head_init(&ll->txq);\n\tskb_queue_head_init(&ll->tx_wait_q);\n\tspin_lock_init(&ll->hcill_lock);\n\n\tll->hcill_state = HCILL_AWAKE;\n\n\thu->priv = ll;\n\n\tif (hu->serdev) {\n\t\tstruct ll_device *lldev = serdev_device_get_drvdata(hu->serdev);\n\n\t\tif (!IS_ERR(lldev->ext_clk))\n\t\t\tclk_prepare_enable(lldev->ext_clk);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ll_flush(struct hci_uart *hu)\n{\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ll->tx_wait_q);\n\tskb_queue_purge(&ll->txq);\n\n\treturn 0;\n}\n\n \nstatic int ll_close(struct hci_uart *hu)\n{\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&ll->tx_wait_q);\n\tskb_queue_purge(&ll->txq);\n\n\tkfree_skb(ll->rx_skb);\n\n\tif (hu->serdev) {\n\t\tstruct ll_device *lldev = serdev_device_get_drvdata(hu->serdev);\n\n\t\tgpiod_set_value_cansleep(lldev->enable_gpio, 0);\n\n\t\tclk_disable_unprepare(lldev->ext_clk);\n\t}\n\n\thu->priv = NULL;\n\n\tkfree(ll);\n\n\treturn 0;\n}\n\n \nstatic void __ll_do_awake(struct ll_struct *ll)\n{\n\tstruct sk_buff *skb = NULL;\n\n\twhile ((skb = skb_dequeue(&ll->tx_wait_q)))\n\t\tskb_queue_tail(&ll->txq, skb);\n\n\tll->hcill_state = HCILL_AWAKE;\n}\n\n \nstatic void ll_device_want_to_wakeup(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\t \n\tspin_lock_irqsave(&ll->hcill_lock, flags);\n\n\tswitch (ll->hcill_state) {\n\tcase HCILL_ASLEEP_TO_AWAKE:\n\t\t \n\t\tBT_DBG(\"dual wake-up-indication\");\n\t\tfallthrough;\n\tcase HCILL_ASLEEP:\n\t\t \n\t\tif (send_hcill_cmd(HCILL_WAKE_UP_ACK, hu) < 0) {\n\t\t\tBT_ERR(\"cannot acknowledge device wake up\");\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tBT_ERR(\"received HCILL_WAKE_UP_IND in state %ld\",\n\t\t       ll->hcill_state);\n\t\tbreak;\n\t}\n\n\t \n\t__ll_do_awake(ll);\n\nout:\n\tspin_unlock_irqrestore(&ll->hcill_lock, flags);\n\n\t \n\thci_uart_tx_wakeup(hu);\n}\n\n \nstatic void ll_device_want_to_sleep(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\t \n\tspin_lock_irqsave(&ll->hcill_lock, flags);\n\n\t \n\tif (ll->hcill_state != HCILL_AWAKE)\n\t\tBT_ERR(\"ERR: HCILL_GO_TO_SLEEP_IND in state %ld\",\n\t\t       ll->hcill_state);\n\n\t \n\tif (send_hcill_cmd(HCILL_GO_TO_SLEEP_ACK, hu) < 0) {\n\t\tBT_ERR(\"cannot acknowledge device sleep\");\n\t\tgoto out;\n\t}\n\n\t \n\tll->hcill_state = HCILL_ASLEEP;\n\nout:\n\tspin_unlock_irqrestore(&ll->hcill_lock, flags);\n\n\t \n\thci_uart_tx_wakeup(hu);\n}\n\n \nstatic void ll_device_woke_up(struct hci_uart *hu)\n{\n\tunsigned long flags;\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\t \n\tspin_lock_irqsave(&ll->hcill_lock, flags);\n\n\t \n\tif (ll->hcill_state != HCILL_ASLEEP_TO_AWAKE)\n\t\tBT_ERR(\"received HCILL_WAKE_UP_ACK in state %ld\",\n\t\t       ll->hcill_state);\n\n\t \n\t__ll_do_awake(ll);\n\n\tspin_unlock_irqrestore(&ll->hcill_lock, flags);\n\n\t \n\thci_uart_tx_wakeup(hu);\n}\n\n \n \nstatic int ll_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tunsigned long flags = 0;\n\tstruct ll_struct *ll = hu->priv;\n\n\tBT_DBG(\"hu %p skb %p\", hu, skb);\n\n\t \n\tmemcpy(skb_push(skb, 1), &hci_skb_pkt_type(skb), 1);\n\n\t \n\tspin_lock_irqsave(&ll->hcill_lock, flags);\n\n\t \n\tswitch (ll->hcill_state) {\n\tcase HCILL_AWAKE:\n\t\tBT_DBG(\"device awake, sending normally\");\n\t\tskb_queue_tail(&ll->txq, skb);\n\t\tbreak;\n\tcase HCILL_ASLEEP:\n\t\tBT_DBG(\"device asleep, waking up and queueing packet\");\n\t\t \n\t\tskb_queue_tail(&ll->tx_wait_q, skb);\n\t\t \n\t\tif (send_hcill_cmd(HCILL_WAKE_UP_IND, hu) < 0) {\n\t\t\tBT_ERR(\"cannot wake up device\");\n\t\t\tbreak;\n\t\t}\n\t\tll->hcill_state = HCILL_ASLEEP_TO_AWAKE;\n\t\tbreak;\n\tcase HCILL_ASLEEP_TO_AWAKE:\n\t\tBT_DBG(\"device waking up, queueing packet\");\n\t\t \n\t\tskb_queue_tail(&ll->tx_wait_q, skb);\n\t\tbreak;\n\tdefault:\n\t\tBT_ERR(\"illegal hcill state: %ld (losing packet)\",\n\t\t       ll->hcill_state);\n\t\tdev_kfree_skb_irq(skb);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&ll->hcill_lock, flags);\n\n\treturn 0;\n}\n\nstatic int ll_recv_frame(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct hci_uart *hu = hci_get_drvdata(hdev);\n\tstruct ll_struct *ll = hu->priv;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCILL_GO_TO_SLEEP_IND:\n\t\tBT_DBG(\"HCILL_GO_TO_SLEEP_IND packet\");\n\t\tll_device_want_to_sleep(hu);\n\t\tbreak;\n\tcase HCILL_GO_TO_SLEEP_ACK:\n\t\t \n\t\tbt_dev_err(hdev, \"received HCILL_GO_TO_SLEEP_ACK in state %ld\",\n\t\t\t   ll->hcill_state);\n\t\tbreak;\n\tcase HCILL_WAKE_UP_IND:\n\t\tBT_DBG(\"HCILL_WAKE_UP_IND packet\");\n\t\tll_device_want_to_wakeup(hu);\n\t\tbreak;\n\tcase HCILL_WAKE_UP_ACK:\n\t\tBT_DBG(\"HCILL_WAKE_UP_ACK packet\");\n\t\tll_device_woke_up(hu);\n\t\tbreak;\n\t}\n\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#define LL_RECV_SLEEP_IND \\\n\t.type = HCILL_GO_TO_SLEEP_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 0\n\n#define LL_RECV_SLEEP_ACK \\\n\t.type = HCILL_GO_TO_SLEEP_ACK, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 0\n\n#define LL_RECV_WAKE_IND \\\n\t.type = HCILL_WAKE_UP_IND, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 0\n\n#define LL_RECV_WAKE_ACK \\\n\t.type = HCILL_WAKE_UP_ACK, \\\n\t.hlen = 0, \\\n\t.loff = 0, \\\n\t.lsize = 0, \\\n\t.maxlen = 0\n\nstatic const struct h4_recv_pkt ll_recv_pkts[] = {\n\t{ H4_RECV_ACL,       .recv = hci_recv_frame },\n\t{ H4_RECV_SCO,       .recv = hci_recv_frame },\n\t{ H4_RECV_EVENT,     .recv = hci_recv_frame },\n\t{ LL_RECV_SLEEP_IND, .recv = ll_recv_frame  },\n\t{ LL_RECV_SLEEP_ACK, .recv = ll_recv_frame  },\n\t{ LL_RECV_WAKE_IND,  .recv = ll_recv_frame  },\n\t{ LL_RECV_WAKE_ACK,  .recv = ll_recv_frame  },\n};\n\n \nstatic int ll_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct ll_struct *ll = hu->priv;\n\n\tif (!test_bit(HCI_UART_REGISTERED, &hu->flags))\n\t\treturn -EUNATCH;\n\n\tll->rx_skb = h4_recv_buf(hu->hdev, ll->rx_skb, data, count,\n\t\t\t\t ll_recv_pkts, ARRAY_SIZE(ll_recv_pkts));\n\tif (IS_ERR(ll->rx_skb)) {\n\t\tint err = PTR_ERR(ll->rx_skb);\n\t\tbt_dev_err(hu->hdev, \"Frame reassembly failed (%d)\", err);\n\t\tll->rx_skb = NULL;\n\t\treturn err;\n\t}\n\n\treturn count;\n}\n\nstatic struct sk_buff *ll_dequeue(struct hci_uart *hu)\n{\n\tstruct ll_struct *ll = hu->priv;\n\n\treturn skb_dequeue(&ll->txq);\n}\n\n#if IS_ENABLED(CONFIG_SERIAL_DEV_BUS)\nstatic int read_local_version(struct hci_dev *hdev)\n{\n\tint err = 0;\n\tunsigned short version = 0;\n\tstruct sk_buff *skb;\n\tstruct hci_rp_read_local_version *ver;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_READ_LOCAL_VERSION, 0, NULL,\n\t\t\t     HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(hdev, \"Reading TI version information failed (%ld)\",\n\t\t\t   PTR_ERR(skb));\n\t\treturn PTR_ERR(skb);\n\t}\n\tif (skb->len != sizeof(*ver)) {\n\t\terr = -EILSEQ;\n\t\tgoto out;\n\t}\n\n\tver = (struct hci_rp_read_local_version *)skb->data;\n\tif (le16_to_cpu(ver->manufacturer) != 13) {\n\t\terr = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tversion = le16_to_cpu(ver->lmp_subver);\n\nout:\n\tif (err)\n\t\tbt_dev_err(hdev, \"Failed to read TI version info: %d\", err);\n\tkfree_skb(skb);\n\treturn err ? err : version;\n}\n\nstatic int send_command_from_firmware(struct ll_device *lldev,\n\t\t\t\t      struct hci_command *cmd)\n{\n\tstruct sk_buff *skb;\n\n\tif (cmd->opcode == HCI_VS_UPDATE_UART_HCI_BAUDRATE) {\n\t\t \n\t\tbt_dev_warn(lldev->hu.hdev,\n\t\t\t    \"change remote baud rate command in firmware\");\n\t\treturn 0;\n\t}\n\tif (cmd->prefix != 1)\n\t\tbt_dev_dbg(lldev->hu.hdev, \"command type %d\", cmd->prefix);\n\n\tskb = __hci_cmd_sync(lldev->hu.hdev, cmd->opcode, cmd->plen,\n\t\t\t     &cmd->speed, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb)) {\n\t\tbt_dev_err(lldev->hu.hdev, \"send command failed\");\n\t\treturn PTR_ERR(skb);\n\t}\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n \nstatic int download_firmware(struct ll_device *lldev)\n{\n\tunsigned short chip, min_ver, maj_ver;\n\tint version, err, len;\n\tunsigned char *ptr, *action_ptr;\n\tunsigned char bts_scr_name[40];\t \n\tconst struct firmware *fw;\n\tstruct hci_command *cmd;\n\n\tversion = read_local_version(lldev->hu.hdev);\n\tif (version < 0)\n\t\treturn version;\n\n\tchip = (version & 0x7C00) >> 10;\n\tmin_ver = (version & 0x007F);\n\tmaj_ver = (version & 0x0380) >> 7;\n\tif (version & 0x8000)\n\t\tmaj_ver |= 0x0008;\n\n\tsnprintf(bts_scr_name, sizeof(bts_scr_name),\n\t\t \"ti-connectivity/TIInit_%d.%d.%d.bts\",\n\t\t chip, maj_ver, min_ver);\n\n\terr = request_firmware(&fw, bts_scr_name, &lldev->serdev->dev);\n\tif (err || !fw->data || !fw->size) {\n\t\tbt_dev_err(lldev->hu.hdev, \"request_firmware failed(errno %d) for %s\",\n\t\t\t   err, bts_scr_name);\n\t\treturn -EINVAL;\n\t}\n\tptr = (void *)fw->data;\n\tlen = fw->size;\n\t \n\tptr += sizeof(struct bts_header);\n\tlen -= sizeof(struct bts_header);\n\n\twhile (len > 0 && ptr) {\n\t\tbt_dev_dbg(lldev->hu.hdev, \" action size %d, type %d \",\n\t\t\t   ((struct bts_action *)ptr)->size,\n\t\t\t   ((struct bts_action *)ptr)->type);\n\n\t\taction_ptr = &(((struct bts_action *)ptr)->data[0]);\n\n\t\tswitch (((struct bts_action *)ptr)->type) {\n\t\tcase ACTION_SEND_COMMAND:\t \n\t\t\tbt_dev_dbg(lldev->hu.hdev, \"S\");\n\t\t\tcmd = (struct hci_command *)action_ptr;\n\t\t\terr = send_command_from_firmware(lldev, cmd);\n\t\t\tif (err)\n\t\t\t\tgoto out_rel_fw;\n\t\t\tbreak;\n\t\tcase ACTION_WAIT_EVENT:   \n\t\t\t \n\t\t\tbt_dev_dbg(lldev->hu.hdev, \"W\");\n\t\t\tbreak;\n\t\tcase ACTION_DELAY:\t \n\t\t\tbt_dev_info(lldev->hu.hdev, \"sleep command in scr\");\n\t\t\tmsleep(((struct bts_action_delay *)action_ptr)->msec);\n\t\t\tbreak;\n\t\t}\n\t\tlen -= (sizeof(struct bts_action) +\n\t\t\t((struct bts_action *)ptr)->size);\n\t\tptr += sizeof(struct bts_action) +\n\t\t\t((struct bts_action *)ptr)->size;\n\t}\n\nout_rel_fw:\n\t \n\trelease_firmware(fw);\n\treturn err;\n}\n\nstatic int ll_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tbdaddr_t bdaddr_swapped;\n\tstruct sk_buff *skb;\n\n\t \n\tbaswap(&bdaddr_swapped, bdaddr);\n\tskb = __hci_cmd_sync(hdev, HCI_VS_WRITE_BD_ADDR, sizeof(bdaddr_t),\n\t\t\t     &bdaddr_swapped, HCI_INIT_TIMEOUT);\n\tif (!IS_ERR(skb))\n\t\tkfree_skb(skb);\n\n\treturn PTR_ERR_OR_ZERO(skb);\n}\n\nstatic int ll_setup(struct hci_uart *hu)\n{\n\tint err, retry = 3;\n\tstruct ll_device *lldev;\n\tstruct serdev_device *serdev = hu->serdev;\n\tu32 speed;\n\n\tif (!serdev)\n\t\treturn 0;\n\n\tlldev = serdev_device_get_drvdata(serdev);\n\n\thu->hdev->set_bdaddr = ll_set_bdaddr;\n\n\tserdev_device_set_flow_control(serdev, true);\n\n\tdo {\n\t\t \n\t\tgpiod_set_value_cansleep(lldev->enable_gpio, 0);\n\t\tmsleep(5);\n\t\tgpiod_set_value_cansleep(lldev->enable_gpio, 1);\n\t\tmdelay(100);\n\t\terr = serdev_device_wait_for_cts(serdev, true, 200);\n\t\tif (err) {\n\t\t\tbt_dev_err(hu->hdev, \"Failed to get CTS\");\n\t\t\treturn err;\n\t\t}\n\n\t\terr = download_firmware(lldev);\n\t\tif (!err)\n\t\t\tbreak;\n\n\t\t \n\t\tbt_dev_err(hu->hdev, \"download firmware failed, retrying...\");\n\t} while (retry--);\n\n\tif (err)\n\t\treturn err;\n\n\t \n\tif (!bacmp(&lldev->bdaddr, BDADDR_NONE)) {\n\t\t \n\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hu->hdev->quirks);\n\t} else if (bacmp(&lldev->bdaddr, BDADDR_ANY)) {\n\t\terr = ll_set_bdaddr(hu->hdev, &lldev->bdaddr);\n\t\tif (err)\n\t\t\tset_bit(HCI_QUIRK_INVALID_BDADDR, &hu->hdev->quirks);\n\t}\n\n\t \n\tif (hu->oper_speed)\n\t\tspeed = hu->oper_speed;\n\telse if (hu->proto->oper_speed)\n\t\tspeed = hu->proto->oper_speed;\n\telse\n\t\tspeed = 0;\n\n\tif (speed) {\n\t\t__le32 speed_le = cpu_to_le32(speed);\n\t\tstruct sk_buff *skb;\n\n\t\tskb = __hci_cmd_sync(hu->hdev, HCI_VS_UPDATE_UART_HCI_BAUDRATE,\n\t\t\t\t     sizeof(speed_le), &speed_le,\n\t\t\t\t     HCI_INIT_TIMEOUT);\n\t\tif (!IS_ERR(skb)) {\n\t\t\tkfree_skb(skb);\n\t\t\tserdev_device_set_baudrate(serdev, speed);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto llp;\n\nstatic int hci_ti_probe(struct serdev_device *serdev)\n{\n\tstruct hci_uart *hu;\n\tstruct ll_device *lldev;\n\tstruct nvmem_cell *bdaddr_cell;\n\tu32 max_speed = 3000000;\n\n\tlldev = devm_kzalloc(&serdev->dev, sizeof(struct ll_device), GFP_KERNEL);\n\tif (!lldev)\n\t\treturn -ENOMEM;\n\thu = &lldev->hu;\n\n\tserdev_device_set_drvdata(serdev, lldev);\n\tlldev->serdev = hu->serdev = serdev;\n\n\tlldev->enable_gpio = devm_gpiod_get_optional(&serdev->dev,\n\t\t\t\t\t\t     \"enable\",\n\t\t\t\t\t\t     GPIOD_OUT_LOW);\n\tif (IS_ERR(lldev->enable_gpio))\n\t\treturn PTR_ERR(lldev->enable_gpio);\n\n\tlldev->ext_clk = devm_clk_get(&serdev->dev, \"ext_clock\");\n\tif (IS_ERR(lldev->ext_clk) && PTR_ERR(lldev->ext_clk) != -ENOENT)\n\t\treturn PTR_ERR(lldev->ext_clk);\n\n\tof_property_read_u32(serdev->dev.of_node, \"max-speed\", &max_speed);\n\thci_uart_set_speeds(hu, 115200, max_speed);\n\n\t \n\tbdaddr_cell = nvmem_cell_get(&serdev->dev, \"bd-address\");\n\tif (IS_ERR(bdaddr_cell)) {\n\t\tint err = PTR_ERR(bdaddr_cell);\n\n\t\tif (err == -EPROBE_DEFER)\n\t\t\treturn err;\n\n\t\t \n\t\tif (err != -ENOENT && err != -ENOSYS) {\n\t\t\t \n\t\t\tdev_warn(&serdev->dev,\n\t\t\t\t \"Failed to get \\\"bd-address\\\" nvmem cell (%d)\\n\",\n\t\t\t\t err);\n\t\t\tbacpy(&lldev->bdaddr, BDADDR_NONE);\n\t\t}\n\t} else {\n\t\tbdaddr_t *bdaddr;\n\t\tsize_t len;\n\n\t\tbdaddr = nvmem_cell_read(bdaddr_cell, &len);\n\t\tnvmem_cell_put(bdaddr_cell);\n\t\tif (IS_ERR(bdaddr)) {\n\t\t\tdev_err(&serdev->dev, \"Failed to read nvmem bd-address\\n\");\n\t\t\treturn PTR_ERR(bdaddr);\n\t\t}\n\t\tif (len != sizeof(bdaddr_t)) {\n\t\t\tdev_err(&serdev->dev, \"Invalid nvmem bd-address length\\n\");\n\t\t\tkfree(bdaddr);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tbaswap(&lldev->bdaddr, bdaddr);\n\t\tkfree(bdaddr);\n\t}\n\n\treturn hci_uart_register_device(hu, &llp);\n}\n\nstatic void hci_ti_remove(struct serdev_device *serdev)\n{\n\tstruct ll_device *lldev = serdev_device_get_drvdata(serdev);\n\n\thci_uart_unregister_device(&lldev->hu);\n}\n\nstatic const struct of_device_id hci_ti_of_match[] = {\n\t{ .compatible = \"ti,cc2560\" },\n\t{ .compatible = \"ti,wl1271-st\" },\n\t{ .compatible = \"ti,wl1273-st\" },\n\t{ .compatible = \"ti,wl1281-st\" },\n\t{ .compatible = \"ti,wl1283-st\" },\n\t{ .compatible = \"ti,wl1285-st\" },\n\t{ .compatible = \"ti,wl1801-st\" },\n\t{ .compatible = \"ti,wl1805-st\" },\n\t{ .compatible = \"ti,wl1807-st\" },\n\t{ .compatible = \"ti,wl1831-st\" },\n\t{ .compatible = \"ti,wl1835-st\" },\n\t{ .compatible = \"ti,wl1837-st\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, hci_ti_of_match);\n\nstatic struct serdev_device_driver hci_ti_drv = {\n\t.driver\t\t= {\n\t\t.name\t= \"hci-ti\",\n\t\t.of_match_table = hci_ti_of_match,\n\t},\n\t.probe\t= hci_ti_probe,\n\t.remove\t= hci_ti_remove,\n};\n#else\n#define ll_setup NULL\n#endif\n\nstatic const struct hci_uart_proto llp = {\n\t.id\t\t= HCI_UART_LL,\n\t.name\t\t= \"LL\",\n\t.setup\t\t= ll_setup,\n\t.open\t\t= ll_open,\n\t.close\t\t= ll_close,\n\t.recv\t\t= ll_recv,\n\t.enqueue\t= ll_enqueue,\n\t.dequeue\t= ll_dequeue,\n\t.flush\t\t= ll_flush,\n};\n\nint __init ll_init(void)\n{\n\tserdev_device_driver_register(&hci_ti_drv);\n\n\treturn hci_uart_register_proto(&llp);\n}\n\nint __exit ll_deinit(void)\n{\n\tserdev_device_driver_unregister(&hci_ti_drv);\n\n\treturn hci_uart_unregister_proto(&llp);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}