{
  "module_name": "hci_bcsp.c",
  "hash_id": "29b290dfd075723dded9330dc0a545d74a6ed5569e5c36815377a20d5aedf963",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/hci_bcsp.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/poll.h>\n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/signal.h>\n#include <linux/ioctl.h>\n#include <linux/skbuff.h>\n#include <linux/bitrev.h>\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"hci_uart.h\"\n\nstatic bool txcrc = true;\nstatic bool hciextn = true;\n\n#define BCSP_TXWINSIZE\t4\n\n#define BCSP_ACK_PKT\t0x05\n#define BCSP_LE_PKT\t0x06\n\nstruct bcsp_struct {\n\tstruct sk_buff_head unack;\t \n\tstruct sk_buff_head rel;\t \n\tstruct sk_buff_head unrel;\t \n\n\tunsigned long rx_count;\n\tstruct\tsk_buff *rx_skb;\n\tu8\trxseq_txack;\t\t \n\tu8\trxack;\t\t\t \n\tstruct\ttimer_list tbcsp;\n\tstruct\thci_uart *hu;\n\n\tenum {\n\t\tBCSP_W4_PKT_DELIMITER,\n\t\tBCSP_W4_PKT_START,\n\t\tBCSP_W4_BCSP_HDR,\n\t\tBCSP_W4_DATA,\n\t\tBCSP_W4_CRC\n\t} rx_state;\n\n\tenum {\n\t\tBCSP_ESCSTATE_NOESC,\n\t\tBCSP_ESCSTATE_ESC\n\t} rx_esc_state;\n\n\tu8\tuse_crc;\n\tu16\tmessage_crc;\n\tu8\ttxack_req;\t\t \n\n\t \n\tu8\tmsgq_txseq;\n};\n\n \n\n \n\nstatic const u16 crc_table[] = {\n\t0x0000, 0x1081, 0x2102, 0x3183,\n\t0x4204, 0x5285, 0x6306, 0x7387,\n\t0x8408, 0x9489, 0xa50a, 0xb58b,\n\t0xc60c, 0xd68d, 0xe70e, 0xf78f\n};\n\n \n#define BCSP_CRC_INIT(x) x = 0xffff\n\n \nstatic void bcsp_crc_update(u16 *crc, u8 d)\n{\n\tu16 reg = *crc;\n\n\treg = (reg >> 4) ^ crc_table[(reg ^ d) & 0x000f];\n\treg = (reg >> 4) ^ crc_table[(reg ^ (d >> 4)) & 0x000f];\n\n\t*crc = reg;\n}\n\n \n\nstatic void bcsp_slip_msgdelim(struct sk_buff *skb)\n{\n\tconst char pkt_delim = 0xc0;\n\n\tskb_put_data(skb, &pkt_delim, 1);\n}\n\nstatic void bcsp_slip_one_byte(struct sk_buff *skb, u8 c)\n{\n\tconst char esc_c0[2] = { 0xdb, 0xdc };\n\tconst char esc_db[2] = { 0xdb, 0xdd };\n\n\tswitch (c) {\n\tcase 0xc0:\n\t\tskb_put_data(skb, &esc_c0, 2);\n\t\tbreak;\n\tcase 0xdb:\n\t\tskb_put_data(skb, &esc_db, 2);\n\t\tbreak;\n\tdefault:\n\t\tskb_put_data(skb, &c, 1);\n\t}\n}\n\nstatic int bcsp_enqueue(struct hci_uart *hu, struct sk_buff *skb)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\n\tif (skb->len > 0xFFF) {\n\t\tBT_ERR(\"Packet too long\");\n\t\tkfree_skb(skb);\n\t\treturn 0;\n\t}\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_ACLDATA_PKT:\n\tcase HCI_COMMAND_PKT:\n\t\tskb_queue_tail(&bcsp->rel, skb);\n\t\tbreak;\n\n\tcase HCI_SCODATA_PKT:\n\t\tskb_queue_tail(&bcsp->unrel, skb);\n\t\tbreak;\n\n\tdefault:\n\t\tBT_ERR(\"Unknown packet type\");\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct sk_buff *bcsp_prepare_pkt(struct bcsp_struct *bcsp, u8 *data,\n\t\t\t\t\tint len, int pkt_type)\n{\n\tstruct sk_buff *nskb;\n\tu8 hdr[4], chan;\n\tu16 BCSP_CRC_INIT(bcsp_txmsg_crc);\n\tint rel, i;\n\n\tswitch (pkt_type) {\n\tcase HCI_ACLDATA_PKT:\n\t\tchan = 6;\t \n\t\trel = 1;\t \n\t\tbreak;\n\tcase HCI_COMMAND_PKT:\n\t\tchan = 5;\t \n\t\trel = 1;\t \n\t\tbreak;\n\tcase HCI_SCODATA_PKT:\n\t\tchan = 7;\t \n\t\trel = 0;\t \n\t\tbreak;\n\tcase BCSP_LE_PKT:\n\t\tchan = 1;\t \n\t\trel = 0;\t \n\t\tbreak;\n\tcase BCSP_ACK_PKT:\n\t\tchan = 0;\t \n\t\trel = 0;\t \n\t\tbreak;\n\tdefault:\n\t\tBT_ERR(\"Unknown packet type\");\n\t\treturn NULL;\n\t}\n\n\tif (hciextn && chan == 5) {\n\t\t__le16 opcode = ((struct hci_command_hdr *)data)->opcode;\n\n\t\t \n\t\tif (hci_opcode_ogf(__le16_to_cpu(opcode)) == 0x3f) {\n\t\t\tu8 desc = *(data + HCI_COMMAND_HDR_SIZE);\n\n\t\t\tif ((desc & 0xf0) == 0xc0) {\n\t\t\t\tdata += HCI_COMMAND_HDR_SIZE + 1;\n\t\t\t\tlen  -= HCI_COMMAND_HDR_SIZE + 1;\n\t\t\t\tchan = desc & 0x0f;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\n\tnskb = alloc_skb((len + 6) * 2 + 2, GFP_ATOMIC);\n\tif (!nskb)\n\t\treturn NULL;\n\n\thci_skb_pkt_type(nskb) = pkt_type;\n\n\tbcsp_slip_msgdelim(nskb);\n\n\thdr[0] = bcsp->rxseq_txack << 3;\n\tbcsp->txack_req = 0;\n\tBT_DBG(\"We request packet no %u to card\", bcsp->rxseq_txack);\n\n\tif (rel) {\n\t\thdr[0] |= 0x80 + bcsp->msgq_txseq;\n\t\tBT_DBG(\"Sending packet with seqno %u\", bcsp->msgq_txseq);\n\t\tbcsp->msgq_txseq = (bcsp->msgq_txseq + 1) & 0x07;\n\t}\n\n\tif (bcsp->use_crc)\n\t\thdr[0] |= 0x40;\n\n\thdr[1] = ((len << 4) & 0xff) | chan;\n\thdr[2] = len >> 4;\n\thdr[3] = ~(hdr[0] + hdr[1] + hdr[2]);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tbcsp_slip_one_byte(nskb, hdr[i]);\n\n\t\tif (bcsp->use_crc)\n\t\t\tbcsp_crc_update(&bcsp_txmsg_crc, hdr[i]);\n\t}\n\n\t \n\tfor (i = 0; i < len; i++) {\n\t\tbcsp_slip_one_byte(nskb, data[i]);\n\n\t\tif (bcsp->use_crc)\n\t\t\tbcsp_crc_update(&bcsp_txmsg_crc, data[i]);\n\t}\n\n\t \n\tif (bcsp->use_crc) {\n\t\tbcsp_txmsg_crc = bitrev16(bcsp_txmsg_crc);\n\t\tbcsp_slip_one_byte(nskb, (u8)((bcsp_txmsg_crc >> 8) & 0x00ff));\n\t\tbcsp_slip_one_byte(nskb, (u8)(bcsp_txmsg_crc & 0x00ff));\n\t}\n\n\tbcsp_slip_msgdelim(nskb);\n\treturn nskb;\n}\n\n \nstatic struct sk_buff *bcsp_dequeue(struct hci_uart *hu)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\n\t \n\n\tskb = skb_dequeue(&bcsp->unrel);\n\tif (skb != NULL) {\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = bcsp_prepare_pkt(bcsp, skb->data, skb->len,\n\t\t\t\t\thci_skb_pkt_type(skb));\n\t\tif (nskb) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn nskb;\n\t\t} else {\n\t\t\tskb_queue_head(&bcsp->unrel, skb);\n\t\t\tBT_ERR(\"Could not dequeue pkt because alloc_skb failed\");\n\t\t}\n\t}\n\n\t \n\n\tspin_lock_irqsave_nested(&bcsp->unack.lock, flags, SINGLE_DEPTH_NESTING);\n\n\tif (bcsp->unack.qlen < BCSP_TXWINSIZE) {\n\t\tskb = skb_dequeue(&bcsp->rel);\n\t\tif (skb != NULL) {\n\t\t\tstruct sk_buff *nskb;\n\n\t\t\tnskb = bcsp_prepare_pkt(bcsp, skb->data, skb->len,\n\t\t\t\t\t\thci_skb_pkt_type(skb));\n\t\t\tif (nskb) {\n\t\t\t\t__skb_queue_tail(&bcsp->unack, skb);\n\t\t\t\tmod_timer(&bcsp->tbcsp, jiffies + HZ / 4);\n\t\t\t\tspin_unlock_irqrestore(&bcsp->unack.lock, flags);\n\t\t\t\treturn nskb;\n\t\t\t} else {\n\t\t\t\tskb_queue_head(&bcsp->rel, skb);\n\t\t\t\tBT_ERR(\"Could not dequeue pkt because alloc_skb failed\");\n\t\t\t}\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&bcsp->unack.lock, flags);\n\n\t \n\n\tif (bcsp->txack_req) {\n\t\t \n\t\tstruct sk_buff *nskb = bcsp_prepare_pkt(bcsp, NULL, 0, BCSP_ACK_PKT);\n\t\treturn nskb;\n\t}\n\n\t \n\treturn NULL;\n}\n\nstatic int bcsp_flush(struct hci_uart *hu)\n{\n\tBT_DBG(\"hu %p\", hu);\n\treturn 0;\n}\n\n \nstatic void bcsp_pkt_cull(struct bcsp_struct *bcsp)\n{\n\tstruct sk_buff *skb, *tmp;\n\tunsigned long flags;\n\tint i, pkts_to_be_removed;\n\tu8 seqno;\n\n\tspin_lock_irqsave(&bcsp->unack.lock, flags);\n\n\tpkts_to_be_removed = skb_queue_len(&bcsp->unack);\n\tseqno = bcsp->msgq_txseq;\n\n\twhile (pkts_to_be_removed) {\n\t\tif (bcsp->rxack == seqno)\n\t\t\tbreak;\n\t\tpkts_to_be_removed--;\n\t\tseqno = (seqno - 1) & 0x07;\n\t}\n\n\tif (bcsp->rxack != seqno)\n\t\tBT_ERR(\"Peer acked invalid packet\");\n\n\tBT_DBG(\"Removing %u pkts out of %u, up to seqno %u\",\n\t       pkts_to_be_removed, skb_queue_len(&bcsp->unack),\n\t       (seqno - 1) & 0x07);\n\n\ti = 0;\n\tskb_queue_walk_safe(&bcsp->unack, skb, tmp) {\n\t\tif (i >= pkts_to_be_removed)\n\t\t\tbreak;\n\t\ti++;\n\n\t\t__skb_unlink(skb, &bcsp->unack);\n\t\tdev_kfree_skb_irq(skb);\n\t}\n\n\tif (skb_queue_empty(&bcsp->unack))\n\t\tdel_timer(&bcsp->tbcsp);\n\n\tspin_unlock_irqrestore(&bcsp->unack.lock, flags);\n\n\tif (i != pkts_to_be_removed)\n\t\tBT_ERR(\"Removed only %u out of %u pkts\", i, pkts_to_be_removed);\n}\n\n \nstatic void bcsp_handle_le_pkt(struct hci_uart *hu)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\tu8 conf_pkt[4]     = { 0xad, 0xef, 0xac, 0xed };\n\tu8 conf_rsp_pkt[4] = { 0xde, 0xad, 0xd0, 0xd0 };\n\tu8 sync_pkt[4]     = { 0xda, 0xdc, 0xed, 0xed };\n\n\t \n\tif (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0 &&\n\t    !memcmp(&bcsp->rx_skb->data[4], conf_pkt, 4)) {\n\t\tstruct sk_buff *nskb = alloc_skb(4, GFP_ATOMIC);\n\n\t\tBT_DBG(\"Found a LE conf pkt\");\n\t\tif (!nskb)\n\t\t\treturn;\n\t\tskb_put_data(nskb, conf_rsp_pkt, 4);\n\t\thci_skb_pkt_type(nskb) = BCSP_LE_PKT;\n\n\t\tskb_queue_head(&bcsp->unrel, nskb);\n\t\thci_uart_tx_wakeup(hu);\n\t}\n\t \n\telse if (bcsp->rx_skb->data[1] >> 4 == 4 && bcsp->rx_skb->data[2] == 0 &&\n\t\t !memcmp(&bcsp->rx_skb->data[4], sync_pkt, 4)) {\n\t\tBT_ERR(\"Found a LE sync pkt, card has reset\");\n\t}\n}\n\nstatic inline void bcsp_unslip_one_byte(struct bcsp_struct *bcsp, unsigned char byte)\n{\n\tconst u8 c0 = 0xc0, db = 0xdb;\n\n\tswitch (bcsp->rx_esc_state) {\n\tcase BCSP_ESCSTATE_NOESC:\n\t\tswitch (byte) {\n\t\tcase 0xdb:\n\t\t\tbcsp->rx_esc_state = BCSP_ESCSTATE_ESC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tskb_put_data(bcsp->rx_skb, &byte, 1);\n\t\t\tif ((bcsp->rx_skb->data[0] & 0x40) != 0 &&\n\t\t\t    bcsp->rx_state != BCSP_W4_CRC)\n\t\t\t\tbcsp_crc_update(&bcsp->message_crc, byte);\n\t\t\tbcsp->rx_count--;\n\t\t}\n\t\tbreak;\n\n\tcase BCSP_ESCSTATE_ESC:\n\t\tswitch (byte) {\n\t\tcase 0xdc:\n\t\t\tskb_put_data(bcsp->rx_skb, &c0, 1);\n\t\t\tif ((bcsp->rx_skb->data[0] & 0x40) != 0 &&\n\t\t\t    bcsp->rx_state != BCSP_W4_CRC)\n\t\t\t\tbcsp_crc_update(&bcsp->message_crc, 0xc0);\n\t\t\tbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\n\t\t\tbcsp->rx_count--;\n\t\t\tbreak;\n\n\t\tcase 0xdd:\n\t\t\tskb_put_data(bcsp->rx_skb, &db, 1);\n\t\t\tif ((bcsp->rx_skb->data[0] & 0x40) != 0 &&\n\t\t\t    bcsp->rx_state != BCSP_W4_CRC)\n\t\t\t\tbcsp_crc_update(&bcsp->message_crc, 0xdb);\n\t\t\tbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\n\t\t\tbcsp->rx_count--;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tBT_ERR(\"Invalid byte %02x after esc byte\", byte);\n\t\t\tkfree_skb(bcsp->rx_skb);\n\t\t\tbcsp->rx_skb = NULL;\n\t\t\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\t\t\tbcsp->rx_count = 0;\n\t\t}\n\t}\n}\n\nstatic void bcsp_complete_rx_pkt(struct hci_uart *hu)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\tint pass_up = 0;\n\n\tif (bcsp->rx_skb->data[0] & 0x80) {\t \n\t\tBT_DBG(\"Received seqno %u from card\", bcsp->rxseq_txack);\n\n\t\t \n\t\tif ((bcsp->rx_skb->data[0] & 0x07) == bcsp->rxseq_txack) {\n\t\t\tbcsp->rxseq_txack++;\n\t\t\tbcsp->rxseq_txack %= 0x8;\n\t\t} else {\n\t\t\t \n\t\t\tBT_ERR(\"Out-of-order packet arrived, got %u expected %u\",\n\t\t\t       bcsp->rx_skb->data[0] & 0x07, bcsp->rxseq_txack);\n\n\t\t\t \n\t\t\tpass_up = 2;\n\t\t}\n\n\t\t \n\t\tbcsp->txack_req = 1;\n\n\t\t \n\t\thci_uart_tx_wakeup(hu);\n\t}\n\n\tbcsp->rxack = (bcsp->rx_skb->data[0] >> 3) & 0x07;\n\tBT_DBG(\"Request for pkt %u from card\", bcsp->rxack);\n\n\t \n\tbcsp_pkt_cull(bcsp);\n\n\tif (pass_up != 2) {\n\t\tif ((bcsp->rx_skb->data[1] & 0x0f) == 6 &&\n\t\t    (bcsp->rx_skb->data[0] & 0x80)) {\n\t\t\thci_skb_pkt_type(bcsp->rx_skb) = HCI_ACLDATA_PKT;\n\t\t\tpass_up = 1;\n\t\t} else if ((bcsp->rx_skb->data[1] & 0x0f) == 5 &&\n\t\t\t   (bcsp->rx_skb->data[0] & 0x80)) {\n\t\t\thci_skb_pkt_type(bcsp->rx_skb) = HCI_EVENT_PKT;\n\t\t\tpass_up = 1;\n\t\t} else if ((bcsp->rx_skb->data[1] & 0x0f) == 7) {\n\t\t\thci_skb_pkt_type(bcsp->rx_skb) = HCI_SCODATA_PKT;\n\t\t\tpass_up = 1;\n\t\t} else if ((bcsp->rx_skb->data[1] & 0x0f) == 1 &&\n\t\t\t   !(bcsp->rx_skb->data[0] & 0x80)) {\n\t\t\tbcsp_handle_le_pkt(hu);\n\t\t\tpass_up = 0;\n\t\t} else {\n\t\t\tpass_up = 0;\n\t\t}\n\t}\n\n\tif (pass_up == 0) {\n\t\tstruct hci_event_hdr hdr;\n\t\tu8 desc = (bcsp->rx_skb->data[1] & 0x0f);\n\n\t\tif (desc != 0 && desc != 1) {\n\t\t\tif (hciextn) {\n\t\t\t\tdesc |= 0xc0;\n\t\t\t\tskb_pull(bcsp->rx_skb, 4);\n\t\t\t\tmemcpy(skb_push(bcsp->rx_skb, 1), &desc, 1);\n\n\t\t\t\thdr.evt = 0xff;\n\t\t\t\thdr.plen = bcsp->rx_skb->len;\n\t\t\t\tmemcpy(skb_push(bcsp->rx_skb, HCI_EVENT_HDR_SIZE), &hdr, HCI_EVENT_HDR_SIZE);\n\t\t\t\thci_skb_pkt_type(bcsp->rx_skb) = HCI_EVENT_PKT;\n\n\t\t\t\thci_recv_frame(hu->hdev, bcsp->rx_skb);\n\t\t\t} else {\n\t\t\t\tBT_ERR(\"Packet for unknown channel (%u %s)\",\n\t\t\t\t       bcsp->rx_skb->data[1] & 0x0f,\n\t\t\t\t       bcsp->rx_skb->data[0] & 0x80 ?\n\t\t\t\t       \"reliable\" : \"unreliable\");\n\t\t\t\tkfree_skb(bcsp->rx_skb);\n\t\t\t}\n\t\t} else\n\t\t\tkfree_skb(bcsp->rx_skb);\n\t} else if (pass_up == 1) {\n\t\t \n\t\tskb_pull(bcsp->rx_skb, 4);\n\n\t\thci_recv_frame(hu->hdev, bcsp->rx_skb);\n\t} else {\n\t\t \n\t\tkfree_skb(bcsp->rx_skb);\n\t}\n\n\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\tbcsp->rx_skb = NULL;\n}\n\nstatic u16 bscp_get_crc(struct bcsp_struct *bcsp)\n{\n\treturn get_unaligned_be16(&bcsp->rx_skb->data[bcsp->rx_skb->len - 2]);\n}\n\n \nstatic int bcsp_recv(struct hci_uart *hu, const void *data, int count)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\tconst unsigned char *ptr;\n\n\tBT_DBG(\"hu %p count %d rx_state %d rx_count %ld\",\n\t       hu, count, bcsp->rx_state, bcsp->rx_count);\n\n\tptr = data;\n\twhile (count) {\n\t\tif (bcsp->rx_count) {\n\t\t\tif (*ptr == 0xc0) {\n\t\t\t\tBT_ERR(\"Short BCSP packet\");\n\t\t\t\tkfree_skb(bcsp->rx_skb);\n\t\t\t\tbcsp->rx_skb = NULL;\n\t\t\t\tbcsp->rx_state = BCSP_W4_PKT_START;\n\t\t\t\tbcsp->rx_count = 0;\n\t\t\t} else\n\t\t\t\tbcsp_unslip_one_byte(bcsp, *ptr);\n\n\t\t\tptr++; count--;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (bcsp->rx_state) {\n\t\tcase BCSP_W4_BCSP_HDR:\n\t\t\tif ((0xff & (u8)~(bcsp->rx_skb->data[0] + bcsp->rx_skb->data[1] +\n\t\t\t    bcsp->rx_skb->data[2])) != bcsp->rx_skb->data[3]) {\n\t\t\t\tBT_ERR(\"Error in BCSP hdr checksum\");\n\t\t\t\tkfree_skb(bcsp->rx_skb);\n\t\t\t\tbcsp->rx_skb = NULL;\n\t\t\t\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\t\t\t\tbcsp->rx_count = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbcsp->rx_state = BCSP_W4_DATA;\n\t\t\tbcsp->rx_count = (bcsp->rx_skb->data[1] >> 4) +\n\t\t\t\t\t(bcsp->rx_skb->data[2] << 4);\t \n\t\t\tcontinue;\n\n\t\tcase BCSP_W4_DATA:\n\t\t\tif (bcsp->rx_skb->data[0] & 0x40) {\t \n\t\t\t\tbcsp->rx_state = BCSP_W4_CRC;\n\t\t\t\tbcsp->rx_count = 2;\n\t\t\t} else\n\t\t\t\tbcsp_complete_rx_pkt(hu);\n\t\t\tcontinue;\n\n\t\tcase BCSP_W4_CRC:\n\t\t\tif (bitrev16(bcsp->message_crc) != bscp_get_crc(bcsp)) {\n\t\t\t\tBT_ERR(\"Checksum failed: computed %04x received %04x\",\n\t\t\t\t       bitrev16(bcsp->message_crc),\n\t\t\t\t       bscp_get_crc(bcsp));\n\n\t\t\t\tkfree_skb(bcsp->rx_skb);\n\t\t\t\tbcsp->rx_skb = NULL;\n\t\t\t\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\t\t\t\tbcsp->rx_count = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tskb_trim(bcsp->rx_skb, bcsp->rx_skb->len - 2);\n\t\t\tbcsp_complete_rx_pkt(hu);\n\t\t\tcontinue;\n\n\t\tcase BCSP_W4_PKT_DELIMITER:\n\t\t\tswitch (*ptr) {\n\t\t\tcase 0xc0:\n\t\t\t\tbcsp->rx_state = BCSP_W4_PKT_START;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tptr++; count--;\n\t\t\tbreak;\n\n\t\tcase BCSP_W4_PKT_START:\n\t\t\tswitch (*ptr) {\n\t\t\tcase 0xc0:\n\t\t\t\tptr++; count--;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbcsp->rx_state = BCSP_W4_BCSP_HDR;\n\t\t\t\tbcsp->rx_count = 4;\n\t\t\t\tbcsp->rx_esc_state = BCSP_ESCSTATE_NOESC;\n\t\t\t\tBCSP_CRC_INIT(bcsp->message_crc);\n\n\t\t\t\t \n\n\t\t\t\tbcsp->rx_skb = bt_skb_alloc(0x1005, GFP_ATOMIC);\n\t\t\t\tif (!bcsp->rx_skb) {\n\t\t\t\t\tBT_ERR(\"Can't allocate mem for new packet\");\n\t\t\t\t\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\t\t\t\t\tbcsp->rx_count = 0;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn count;\n}\n\n\t \nstatic void bcsp_timed_event(struct timer_list *t)\n{\n\tstruct bcsp_struct *bcsp = from_timer(bcsp, t, tbcsp);\n\tstruct hci_uart *hu = bcsp->hu;\n\tstruct sk_buff *skb;\n\tunsigned long flags;\n\n\tBT_DBG(\"hu %p retransmitting %u pkts\", hu, bcsp->unack.qlen);\n\n\tspin_lock_irqsave_nested(&bcsp->unack.lock, flags, SINGLE_DEPTH_NESTING);\n\n\twhile ((skb = __skb_dequeue_tail(&bcsp->unack)) != NULL) {\n\t\tbcsp->msgq_txseq = (bcsp->msgq_txseq - 1) & 0x07;\n\t\tskb_queue_head(&bcsp->rel, skb);\n\t}\n\n\tspin_unlock_irqrestore(&bcsp->unack.lock, flags);\n\n\thci_uart_tx_wakeup(hu);\n}\n\nstatic int bcsp_open(struct hci_uart *hu)\n{\n\tstruct bcsp_struct *bcsp;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tbcsp = kzalloc(sizeof(*bcsp), GFP_KERNEL);\n\tif (!bcsp)\n\t\treturn -ENOMEM;\n\n\thu->priv = bcsp;\n\tbcsp->hu = hu;\n\tskb_queue_head_init(&bcsp->unack);\n\tskb_queue_head_init(&bcsp->rel);\n\tskb_queue_head_init(&bcsp->unrel);\n\n\ttimer_setup(&bcsp->tbcsp, bcsp_timed_event, 0);\n\n\tbcsp->rx_state = BCSP_W4_PKT_DELIMITER;\n\n\tif (txcrc)\n\t\tbcsp->use_crc = 1;\n\n\treturn 0;\n}\n\nstatic int bcsp_close(struct hci_uart *hu)\n{\n\tstruct bcsp_struct *bcsp = hu->priv;\n\n\ttimer_shutdown_sync(&bcsp->tbcsp);\n\n\thu->priv = NULL;\n\n\tBT_DBG(\"hu %p\", hu);\n\n\tskb_queue_purge(&bcsp->unack);\n\tskb_queue_purge(&bcsp->rel);\n\tskb_queue_purge(&bcsp->unrel);\n\n\tif (bcsp->rx_skb) {\n\t\tkfree_skb(bcsp->rx_skb);\n\t\tbcsp->rx_skb = NULL;\n\t}\n\n\tkfree(bcsp);\n\treturn 0;\n}\n\nstatic const struct hci_uart_proto bcsp = {\n\t.id\t\t= HCI_UART_BCSP,\n\t.name\t\t= \"BCSP\",\n\t.open\t\t= bcsp_open,\n\t.close\t\t= bcsp_close,\n\t.enqueue\t= bcsp_enqueue,\n\t.dequeue\t= bcsp_dequeue,\n\t.recv\t\t= bcsp_recv,\n\t.flush\t\t= bcsp_flush\n};\n\nint __init bcsp_init(void)\n{\n\treturn hci_uart_register_proto(&bcsp);\n}\n\nint __exit bcsp_deinit(void)\n{\n\treturn hci_uart_unregister_proto(&bcsp);\n}\n\nmodule_param(txcrc, bool, 0644);\nMODULE_PARM_DESC(txcrc, \"Transmit CRC with every BCSP packet\");\n\nmodule_param(hciextn, bool, 0644);\nMODULE_PARM_DESC(hciextn, \"Convert HCI Extensions into BCSP packets\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}