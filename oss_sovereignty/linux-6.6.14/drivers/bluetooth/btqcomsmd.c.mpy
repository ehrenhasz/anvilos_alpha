{
  "module_name": "btqcomsmd.c",
  "hash_id": "0edaa16be46cd436044bd0ae28672cac8ba4d43f0c7ecb04d5519db8b75b11ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/bluetooth/btqcomsmd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/rpmsg.h>\n#include <linux/of.h>\n\n#include <linux/soc/qcom/wcnss_ctrl.h>\n#include <linux/platform_device.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n\n#include \"btqca.h\"\n\nstruct btqcomsmd {\n\tstruct hci_dev *hdev;\n\n\tstruct rpmsg_endpoint *acl_channel;\n\tstruct rpmsg_endpoint *cmd_channel;\n};\n\nstatic int btqcomsmd_recv(struct hci_dev *hdev, unsigned int type,\n\t\t\t   const void *data, size_t count)\n{\n\tstruct sk_buff *skb;\n\n\t \n\tskb = bt_skb_alloc(count, GFP_ATOMIC);\n\tif (!skb) {\n\t\thdev->stat.err_rx++;\n\t\treturn -ENOMEM;\n\t}\n\n\thci_skb_pkt_type(skb) = type;\n\tskb_put_data(skb, data, count);\n\n\treturn hci_recv_frame(hdev, skb);\n}\n\nstatic int btqcomsmd_acl_callback(struct rpmsg_device *rpdev, void *data,\n\t\t\t\t  int count, void *priv, u32 addr)\n{\n\tstruct btqcomsmd *btq = priv;\n\n\tbtq->hdev->stat.byte_rx += count;\n\treturn btqcomsmd_recv(btq->hdev, HCI_ACLDATA_PKT, data, count);\n}\n\nstatic int btqcomsmd_cmd_callback(struct rpmsg_device *rpdev, void *data,\n\t\t\t\t  int count, void *priv, u32 addr)\n{\n\tstruct btqcomsmd *btq = priv;\n\n\tbtq->hdev->stat.byte_rx += count;\n\treturn btqcomsmd_recv(btq->hdev, HCI_EVENT_PKT, data, count);\n}\n\nstatic int btqcomsmd_send(struct hci_dev *hdev, struct sk_buff *skb)\n{\n\tstruct btqcomsmd *btq = hci_get_drvdata(hdev);\n\tint ret;\n\n\tswitch (hci_skb_pkt_type(skb)) {\n\tcase HCI_ACLDATA_PKT:\n\t\tret = rpmsg_send(btq->acl_channel, skb->data, skb->len);\n\t\tif (ret) {\n\t\t\thdev->stat.err_tx++;\n\t\t\tbreak;\n\t\t}\n\t\thdev->stat.acl_tx++;\n\t\thdev->stat.byte_tx += skb->len;\n\t\tbreak;\n\tcase HCI_COMMAND_PKT:\n\t\tret = rpmsg_send(btq->cmd_channel, skb->data, skb->len);\n\t\tif (ret) {\n\t\t\thdev->stat.err_tx++;\n\t\t\tbreak;\n\t\t}\n\t\thdev->stat.cmd_tx++;\n\t\thdev->stat.byte_tx += skb->len;\n\t\tbreak;\n\tdefault:\n\t\tret = -EILSEQ;\n\t\tbreak;\n\t}\n\n\tif (!ret)\n\t\tkfree_skb(skb);\n\n\treturn ret;\n}\n\nstatic int btqcomsmd_open(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int btqcomsmd_close(struct hci_dev *hdev)\n{\n\treturn 0;\n}\n\nstatic int btqcomsmd_setup(struct hci_dev *hdev)\n{\n\tstruct sk_buff *skb;\n\n\tskb = __hci_cmd_sync(hdev, HCI_OP_RESET, 0, NULL, HCI_INIT_TIMEOUT);\n\tif (IS_ERR(skb))\n\t\treturn PTR_ERR(skb);\n\tkfree_skb(skb);\n\n\t \n\tset_bit(HCI_QUIRK_USE_BDADDR_PROPERTY, &hdev->quirks);\n\n\treturn 0;\n}\n\nstatic int btqcomsmd_set_bdaddr(struct hci_dev *hdev, const bdaddr_t *bdaddr)\n{\n\tint ret;\n\n\tret = qca_set_bdaddr_rome(hdev, bdaddr);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tusleep_range(1000, 10000);\n\treturn 0;\n}\n\nstatic int btqcomsmd_probe(struct platform_device *pdev)\n{\n\tstruct btqcomsmd *btq;\n\tstruct hci_dev *hdev;\n\tvoid *wcnss;\n\tint ret;\n\n\tbtq = devm_kzalloc(&pdev->dev, sizeof(*btq), GFP_KERNEL);\n\tif (!btq)\n\t\treturn -ENOMEM;\n\n\twcnss = dev_get_drvdata(pdev->dev.parent);\n\n\tbtq->acl_channel = qcom_wcnss_open_channel(wcnss, \"APPS_RIVA_BT_ACL\",\n\t\t\t\t\t\t   btqcomsmd_acl_callback, btq);\n\tif (IS_ERR(btq->acl_channel))\n\t\treturn PTR_ERR(btq->acl_channel);\n\n\tbtq->cmd_channel = qcom_wcnss_open_channel(wcnss, \"APPS_RIVA_BT_CMD\",\n\t\t\t\t\t\t   btqcomsmd_cmd_callback, btq);\n\tif (IS_ERR(btq->cmd_channel)) {\n\t\tret = PTR_ERR(btq->cmd_channel);\n\t\tgoto destroy_acl_channel;\n\t}\n\n\thdev = hci_alloc_dev();\n\tif (!hdev) {\n\t\tret = -ENOMEM;\n\t\tgoto destroy_cmd_channel;\n\t}\n\n\thci_set_drvdata(hdev, btq);\n\tbtq->hdev = hdev;\n\tSET_HCIDEV_DEV(hdev, &pdev->dev);\n\n\thdev->bus = HCI_SMD;\n\thdev->open = btqcomsmd_open;\n\thdev->close = btqcomsmd_close;\n\thdev->send = btqcomsmd_send;\n\thdev->setup = btqcomsmd_setup;\n\thdev->set_bdaddr = btqcomsmd_set_bdaddr;\n\n\tret = hci_register_dev(hdev);\n\tif (ret < 0)\n\t\tgoto hci_free_dev;\n\n\tplatform_set_drvdata(pdev, btq);\n\n\treturn 0;\n\nhci_free_dev:\n\thci_free_dev(hdev);\ndestroy_cmd_channel:\n\trpmsg_destroy_ept(btq->cmd_channel);\ndestroy_acl_channel:\n\trpmsg_destroy_ept(btq->acl_channel);\n\n\treturn ret;\n}\n\nstatic int btqcomsmd_remove(struct platform_device *pdev)\n{\n\tstruct btqcomsmd *btq = platform_get_drvdata(pdev);\n\n\thci_unregister_dev(btq->hdev);\n\thci_free_dev(btq->hdev);\n\n\trpmsg_destroy_ept(btq->cmd_channel);\n\trpmsg_destroy_ept(btq->acl_channel);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id btqcomsmd_of_match[] = {\n\t{ .compatible = \"qcom,wcnss-bt\", },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, btqcomsmd_of_match);\n\nstatic struct platform_driver btqcomsmd_driver = {\n\t.probe = btqcomsmd_probe,\n\t.remove = btqcomsmd_remove,\n\t.driver  = {\n\t\t.name  = \"btqcomsmd\",\n\t\t.of_match_table = btqcomsmd_of_match,\n\t},\n};\n\nmodule_platform_driver(btqcomsmd_driver);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@sonymobile.com>\");\nMODULE_DESCRIPTION(\"Qualcomm SMD HCI driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}