{
  "module_name": "rpmsg_char.c",
  "hash_id": "6b80a5b61d932f56ced4916df6886096441b13546a4ff166c89e72fc8cd88794",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/rpmsg_char.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/poll.h>\n#include <linux/rpmsg.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/rpmsg.h>\n\n#include \"rpmsg_char.h\"\n#include \"rpmsg_internal.h\"\n\n#define RPMSG_DEV_MAX\t(MINORMASK + 1)\n\nstatic dev_t rpmsg_major;\n\nstatic DEFINE_IDA(rpmsg_ept_ida);\nstatic DEFINE_IDA(rpmsg_minor_ida);\n\n#define dev_to_eptdev(dev) container_of(dev, struct rpmsg_eptdev, dev)\n#define cdev_to_eptdev(i_cdev) container_of(i_cdev, struct rpmsg_eptdev, cdev)\n\n \nstruct rpmsg_eptdev {\n\tstruct device dev;\n\tstruct cdev cdev;\n\n\tstruct rpmsg_device *rpdev;\n\tstruct rpmsg_channel_info chinfo;\n\n\tstruct mutex ept_lock;\n\tstruct rpmsg_endpoint *ept;\n\tstruct rpmsg_endpoint *default_ept;\n\n\tspinlock_t queue_lock;\n\tstruct sk_buff_head queue;\n\twait_queue_head_t readq;\n\n\tbool remote_flow_restricted;\n\tbool remote_flow_updated;\n};\n\nint rpmsg_chrdev_eptdev_destroy(struct device *dev, void *data)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tmutex_lock(&eptdev->ept_lock);\n\teptdev->rpdev = NULL;\n\tif (eptdev->ept) {\n\t\t \n\t\tif (!eptdev->default_ept)\n\t\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\n\t \n\twake_up_interruptible(&eptdev->readq);\n\n\tcdev_device_del(&eptdev->cdev, &eptdev->dev);\n\tput_device(&eptdev->dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rpmsg_chrdev_eptdev_destroy);\n\nstatic int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,\n\t\t\tvoid *priv, u32 addr)\n{\n\tstruct rpmsg_eptdev *eptdev = priv;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(len, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tskb_put_data(skb, buf, len);\n\n\tspin_lock(&eptdev->queue_lock);\n\tskb_queue_tail(&eptdev->queue, skb);\n\tspin_unlock(&eptdev->queue_lock);\n\n\t \n\twake_up_interruptible(&eptdev->readq);\n\n\treturn 0;\n}\n\nstatic int rpmsg_ept_flow_cb(struct rpmsg_device *rpdev, void *priv, bool enable)\n{\n\tstruct rpmsg_eptdev *eptdev = priv;\n\n\teptdev->remote_flow_restricted = enable;\n\teptdev->remote_flow_updated = true;\n\n\twake_up_interruptible(&eptdev->readq);\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct rpmsg_endpoint *ept;\n\tstruct rpmsg_device *rpdev = eptdev->rpdev;\n\tstruct device *dev = &eptdev->dev;\n\n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\tmutex_unlock(&eptdev->ept_lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!eptdev->rpdev) {\n\t\tmutex_unlock(&eptdev->ept_lock);\n\t\treturn -ENETRESET;\n\t}\n\n\tget_device(dev);\n\n\t \n\tif (eptdev->default_ept)\n\t\tept = eptdev->default_ept;\n\telse\n\t\tept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);\n\n\tif (!ept) {\n\t\tdev_err(dev, \"failed to open %s\\n\", eptdev->chinfo.name);\n\t\tput_device(dev);\n\t\tmutex_unlock(&eptdev->ept_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tept->flow_cb = rpmsg_ept_flow_cb;\n\teptdev->ept = ept;\n\tfilp->private_data = eptdev;\n\tmutex_unlock(&eptdev->ept_lock);\n\n\treturn 0;\n}\n\nstatic int rpmsg_eptdev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);\n\tstruct device *dev = &eptdev->dev;\n\n\t \n\tmutex_lock(&eptdev->ept_lock);\n\tif (eptdev->ept) {\n\t\tif (!eptdev->default_ept)\n\t\t\trpmsg_destroy_ept(eptdev->ept);\n\t\teptdev->ept = NULL;\n\t}\n\tmutex_unlock(&eptdev->ept_lock);\n\teptdev->remote_flow_updated = false;\n\n\t \n\tskb_queue_purge(&eptdev->queue);\n\n\tput_device(dev);\n\n\treturn 0;\n}\n\nstatic ssize_t rpmsg_eptdev_read_iter(struct kiocb *iocb, struct iov_iter *to)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tunsigned long flags;\n\tstruct sk_buff *skb;\n\tint use;\n\n\tif (!eptdev->ept)\n\t\treturn -EPIPE;\n\n\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\n\t \n\tif (skb_queue_empty(&eptdev->queue)) {\n\t\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\t \n\t\tif (wait_event_interruptible(eptdev->readq,\n\t\t\t\t\t     !skb_queue_empty(&eptdev->queue) ||\n\t\t\t\t\t     !eptdev->ept))\n\t\t\treturn -ERESTARTSYS;\n\n\t\t \n\t\tif (!eptdev->ept)\n\t\t\treturn -EPIPE;\n\n\t\tspin_lock_irqsave(&eptdev->queue_lock, flags);\n\t}\n\n\tskb = skb_dequeue(&eptdev->queue);\n\tspin_unlock_irqrestore(&eptdev->queue_lock, flags);\n\tif (!skb)\n\t\treturn -EFAULT;\n\n\tuse = min_t(size_t, iov_iter_count(to), skb->len);\n\tif (copy_to_iter(skb->data, use, to) != use)\n\t\tuse = -EFAULT;\n\n\tkfree_skb(skb);\n\n\treturn use;\n}\n\nstatic ssize_t rpmsg_eptdev_write_iter(struct kiocb *iocb,\n\t\t\t\t       struct iov_iter *from)\n{\n\tstruct file *filp = iocb->ki_filp;\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\tsize_t len = iov_iter_count(from);\n\tvoid *kbuf;\n\tint ret;\n\n\tkbuf = kzalloc(len, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\tif (!copy_from_iter_full(kbuf, len, from)) {\n\t\tret = -EFAULT;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (mutex_lock_interruptible(&eptdev->ept_lock)) {\n\t\tret = -ERESTARTSYS;\n\t\tgoto free_kbuf;\n\t}\n\n\tif (!eptdev->ept) {\n\t\tret = -EPIPE;\n\t\tgoto unlock_eptdev;\n\t}\n\n\tif (filp->f_flags & O_NONBLOCK) {\n\t\tret = rpmsg_trysendto(eptdev->ept, kbuf, len, eptdev->chinfo.dst);\n\t\tif (ret == -ENOMEM)\n\t\t\tret = -EAGAIN;\n\t} else {\n\t\tret = rpmsg_sendto(eptdev->ept, kbuf, len, eptdev->chinfo.dst);\n\t}\n\nunlock_eptdev:\n\tmutex_unlock(&eptdev->ept_lock);\n\nfree_kbuf:\n\tkfree(kbuf);\n\treturn ret < 0 ? ret : len;\n}\n\nstatic __poll_t rpmsg_eptdev_poll(struct file *filp, poll_table *wait)\n{\n\tstruct rpmsg_eptdev *eptdev = filp->private_data;\n\t__poll_t mask = 0;\n\n\tif (!eptdev->ept)\n\t\treturn EPOLLERR;\n\n\tpoll_wait(filp, &eptdev->readq, wait);\n\n\tif (!skb_queue_empty(&eptdev->queue))\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (eptdev->remote_flow_updated)\n\t\tmask |= EPOLLPRI;\n\n\tmutex_lock(&eptdev->ept_lock);\n\tmask |= rpmsg_poll(eptdev->ept, filp, wait);\n\tmutex_unlock(&eptdev->ept_lock);\n\n\treturn mask;\n}\n\nstatic long rpmsg_eptdev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t       unsigned long arg)\n{\n\tstruct rpmsg_eptdev *eptdev = fp->private_data;\n\n\tbool set;\n\tint ret;\n\n\tswitch (cmd) {\n\tcase RPMSG_GET_OUTGOING_FLOWCONTROL:\n\t\teptdev->remote_flow_updated = false;\n\t\tret = put_user(eptdev->remote_flow_restricted, (int __user *)arg);\n\t\tbreak;\n\tcase RPMSG_SET_INCOMING_FLOWCONTROL:\n\t\tif (arg > 1) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tset = !!arg;\n\t\tret = rpmsg_set_flow_control(eptdev->ept, set, eptdev->chinfo.dst);\n\t\tbreak;\n\tcase RPMSG_DESTROY_EPT_IOCTL:\n\t\t \n\t\tif (eptdev->default_ept) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = rpmsg_chrdev_eptdev_destroy(&eptdev->dev, NULL);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret;\n}\n\nstatic const struct file_operations rpmsg_eptdev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_eptdev_open,\n\t.release = rpmsg_eptdev_release,\n\t.read_iter = rpmsg_eptdev_read_iter,\n\t.write_iter = rpmsg_eptdev_write_iter,\n\t.poll = rpmsg_eptdev_poll,\n\t.unlocked_ioctl = rpmsg_eptdev_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic ssize_t name_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%s\\n\", eptdev->chinfo.name);\n}\nstatic DEVICE_ATTR_RO(name);\n\nstatic ssize_t src_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.src);\n}\nstatic DEVICE_ATTR_RO(src);\n\nstatic ssize_t dst_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_get_drvdata(dev);\n\n\treturn sprintf(buf, \"%d\\n\", eptdev->chinfo.dst);\n}\nstatic DEVICE_ATTR_RO(dst);\n\nstatic struct attribute *rpmsg_eptdev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_src.attr,\n\t&dev_attr_dst.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(rpmsg_eptdev);\n\nstatic void rpmsg_eptdev_release_device(struct device *dev)\n{\n\tstruct rpmsg_eptdev *eptdev = dev_to_eptdev(dev);\n\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(eptdev->dev.devt));\n\tkfree(eptdev);\n}\n\nstatic struct rpmsg_eptdev *rpmsg_chrdev_eptdev_alloc(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t      struct device *parent)\n{\n\tstruct rpmsg_eptdev *eptdev;\n\tstruct device *dev;\n\n\teptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);\n\tif (!eptdev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = &eptdev->dev;\n\teptdev->rpdev = rpdev;\n\n\tmutex_init(&eptdev->ept_lock);\n\tspin_lock_init(&eptdev->queue_lock);\n\tskb_queue_head_init(&eptdev->queue);\n\tinit_waitqueue_head(&eptdev->readq);\n\n\tdevice_initialize(dev);\n\tdev->class = rpmsg_class;\n\tdev->parent = parent;\n\tdev->groups = rpmsg_eptdev_groups;\n\tdev_set_drvdata(dev, eptdev);\n\n\tcdev_init(&eptdev->cdev, &rpmsg_eptdev_fops);\n\teptdev->cdev.owner = THIS_MODULE;\n\n\treturn eptdev;\n}\n\nstatic int rpmsg_chrdev_eptdev_add(struct rpmsg_eptdev *eptdev, struct rpmsg_channel_info chinfo)\n{\n\tstruct device *dev = &eptdev->dev;\n\tint ret;\n\n\teptdev->chinfo = chinfo;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_eptdev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ept_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(dev, \"rpmsg%d\", ret);\n\n\tret = cdev_device_add(&eptdev->cdev, &eptdev->dev);\n\tif (ret)\n\t\tgoto free_ept_ida;\n\n\t \n\tdev->release = rpmsg_eptdev_release_device;\n\n\treturn ret;\n\nfree_ept_ida:\n\tida_simple_remove(&rpmsg_ept_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_eptdev:\n\tput_device(dev);\n\tkfree(eptdev);\n\n\treturn ret;\n}\n\nint rpmsg_chrdev_eptdev_create(struct rpmsg_device *rpdev, struct device *parent,\n\t\t\t       struct rpmsg_channel_info chinfo)\n{\n\tstruct rpmsg_eptdev *eptdev;\n\n\teptdev = rpmsg_chrdev_eptdev_alloc(rpdev, parent);\n\tif (IS_ERR(eptdev))\n\t\treturn PTR_ERR(eptdev);\n\n\treturn rpmsg_chrdev_eptdev_add(eptdev, chinfo);\n}\nEXPORT_SYMBOL(rpmsg_chrdev_eptdev_create);\n\nstatic int rpmsg_chrdev_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_channel_info chinfo;\n\tstruct rpmsg_eptdev *eptdev;\n\tstruct device *dev = &rpdev->dev;\n\n\tmemcpy(chinfo.name, rpdev->id.name, RPMSG_NAME_SIZE);\n\tchinfo.src = rpdev->src;\n\tchinfo.dst = rpdev->dst;\n\n\teptdev = rpmsg_chrdev_eptdev_alloc(rpdev, dev);\n\tif (IS_ERR(eptdev))\n\t\treturn PTR_ERR(eptdev);\n\n\t \n\teptdev->default_ept = rpdev->ept;\n\n\t \n\teptdev->default_ept->priv = eptdev;\n\n\treturn rpmsg_chrdev_eptdev_add(eptdev, chinfo);\n}\n\nstatic void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)\n{\n\tint ret;\n\n\tret = device_for_each_child(&rpdev->dev, NULL, rpmsg_chrdev_eptdev_destroy);\n\tif (ret)\n\t\tdev_warn(&rpdev->dev, \"failed to destroy endpoints: %d\\n\", ret);\n}\n\nstatic struct rpmsg_device_id rpmsg_chrdev_id_table[] = {\n\t{ .name\t= \"rpmsg-raw\" },\n\t{ },\n};\n\nstatic struct rpmsg_driver rpmsg_chrdev_driver = {\n\t.probe = rpmsg_chrdev_probe,\n\t.remove = rpmsg_chrdev_remove,\n\t.callback = rpmsg_ept_cb,\n\t.id_table = rpmsg_chrdev_id_table,\n\t.drv.name = \"rpmsg_chrdev\",\n};\n\nstatic int rpmsg_chrdev_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg_char\");\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_chrdev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"rpmsg: failed to register rpmsg raw driver\\n\");\n\t\tgoto free_region;\n\t}\n\n\treturn 0;\n\nfree_region:\n\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\n\treturn ret;\n}\npostcore_initcall(rpmsg_chrdev_init);\n\nstatic void rpmsg_chrdev_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_chrdev_driver);\n\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n}\nmodule_exit(rpmsg_chrdev_exit);\n\nMODULE_ALIAS(\"rpmsg:rpmsg_chrdev\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}