{
  "module_name": "qcom_glink_ssr.c",
  "hash_id": "10fd906e016c0c500799936bf4262355d2b64f018ab28f5ec9c97a1ba1614150",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/qcom_glink_ssr.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/rpmsg.h>\n#include <linux/rpmsg/qcom_glink.h>\n#include <linux/remoteproc/qcom_rproc.h>\n\n \nstruct do_cleanup_msg {\n\t__le32 version;\n\t__le32 command;\n\t__le32 seq_num;\n\t__le32 name_len;\n\tchar name[32];\n};\n\n \nstruct cleanup_done_msg {\n\t__le32 version;\n\t__le32 response;\n\t__le32 seq_num;\n};\n\n \n#define GLINK_SSR_DO_CLEANUP\t0\n#define GLINK_SSR_CLEANUP_DONE\t1\n\nstruct glink_ssr {\n\tstruct device *dev;\n\tstruct rpmsg_endpoint *ept;\n\n\tstruct notifier_block nb;\n\n\tu32 seq_num;\n\tstruct completion completion;\n};\n\n \nstatic BLOCKING_NOTIFIER_HEAD(ssr_notifiers);\n\n \nvoid qcom_glink_ssr_notify(const char *ssr_name)\n{\n\tblocking_notifier_call_chain(&ssr_notifiers, 0, (void *)ssr_name);\n}\nEXPORT_SYMBOL_GPL(qcom_glink_ssr_notify);\n\nstatic int qcom_glink_ssr_callback(struct rpmsg_device *rpdev,\n\t\t\t\t   void *data, int len, void *priv, u32 addr)\n{\n\tstruct cleanup_done_msg *msg = data;\n\tstruct glink_ssr *ssr = dev_get_drvdata(&rpdev->dev);\n\n\tif (len < sizeof(*msg)) {\n\t\tdev_err(ssr->dev, \"message too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (le32_to_cpu(msg->version) != 0)\n\t\treturn -EINVAL;\n\n\tif (le32_to_cpu(msg->response) != GLINK_SSR_CLEANUP_DONE)\n\t\treturn 0;\n\n\tif (le32_to_cpu(msg->seq_num) != ssr->seq_num) {\n\t\tdev_err(ssr->dev, \"invalid sequence number of response\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcomplete(&ssr->completion);\n\n\treturn 0;\n}\n\nstatic int qcom_glink_ssr_notifier_call(struct notifier_block *nb,\n\t\t\t\t\tunsigned long event,\n\t\t\t\t\tvoid *data)\n{\n\tstruct glink_ssr *ssr = container_of(nb, struct glink_ssr, nb);\n\tstruct do_cleanup_msg msg;\n\tchar *ssr_name = data;\n\tint ret;\n\n\tssr->seq_num++;\n\treinit_completion(&ssr->completion);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.command = cpu_to_le32(GLINK_SSR_DO_CLEANUP);\n\tmsg.seq_num = cpu_to_le32(ssr->seq_num);\n\tmsg.name_len = cpu_to_le32(strlen(ssr_name));\n\tstrscpy(msg.name, ssr_name, sizeof(msg.name));\n\n\tret = rpmsg_send(ssr->ept, &msg, sizeof(msg));\n\tif (ret < 0)\n\t\tdev_err(ssr->dev, \"failed to send cleanup message\\n\");\n\n\tret = wait_for_completion_timeout(&ssr->completion, HZ);\n\tif (!ret)\n\t\tdev_err(ssr->dev, \"timeout waiting for cleanup done message\\n\");\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int qcom_glink_ssr_probe(struct rpmsg_device *rpdev)\n{\n\tstruct glink_ssr *ssr;\n\n\tssr = devm_kzalloc(&rpdev->dev, sizeof(*ssr), GFP_KERNEL);\n\tif (!ssr)\n\t\treturn -ENOMEM;\n\n\tinit_completion(&ssr->completion);\n\n\tssr->dev = &rpdev->dev;\n\tssr->ept = rpdev->ept;\n\tssr->nb.notifier_call = qcom_glink_ssr_notifier_call;\n\n\tdev_set_drvdata(&rpdev->dev, ssr);\n\n\treturn blocking_notifier_chain_register(&ssr_notifiers, &ssr->nb);\n}\n\nstatic void qcom_glink_ssr_remove(struct rpmsg_device *rpdev)\n{\n\tstruct glink_ssr *ssr = dev_get_drvdata(&rpdev->dev);\n\n\tblocking_notifier_chain_unregister(&ssr_notifiers, &ssr->nb);\n}\n\nstatic const struct rpmsg_device_id qcom_glink_ssr_match[] = {\n\t{ \"glink_ssr\" },\n\t{}\n};\n\nstatic struct rpmsg_driver qcom_glink_ssr_driver = {\n\t.probe = qcom_glink_ssr_probe,\n\t.remove = qcom_glink_ssr_remove,\n\t.callback = qcom_glink_ssr_callback,\n\t.id_table = qcom_glink_ssr_match,\n\t.drv = {\n\t\t.name = \"qcom_glink_ssr\",\n\t},\n};\nmodule_rpmsg_driver(qcom_glink_ssr_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}