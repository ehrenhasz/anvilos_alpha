{
  "module_name": "qcom_glink_smem.c",
  "hash_id": "eb84a08dcc7e03f560a494d0fade0a766233fbf04aac8d4b876acf31e381f6d9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/qcom_glink_smem.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/slab.h>\n#include <linux/rpmsg.h>\n#include <linux/idr.h>\n#include <linux/circ_buf.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/sizes.h>\n#include <linux/delay.h>\n#include <linux/regmap.h>\n#include <linux/workqueue.h>\n#include <linux/list.h>\n\n#include <linux/rpmsg/qcom_glink.h>\n\n#include \"qcom_glink_native.h\"\n\n#define FIFO_FULL_RESERVE 8\n#define FIFO_ALIGNMENT 8\n#define TX_BLOCKED_CMD_RESERVE 8  \n\n#define SMEM_GLINK_NATIVE_XPRT_DESCRIPTOR\t478\n#define SMEM_GLINK_NATIVE_XPRT_FIFO_0\t\t479\n#define SMEM_GLINK_NATIVE_XPRT_FIFO_1\t\t480\n\nstruct qcom_glink_smem {\n\tstruct device dev;\n\n\tint irq;\n\tstruct qcom_glink *glink;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tu32 remote_pid;\n};\n\nstruct glink_smem_pipe {\n\tstruct qcom_glink_pipe native;\n\n\t__le32 *tail;\n\t__le32 *head;\n\n\tvoid *fifo;\n\n\tstruct qcom_glink_smem *smem;\n};\n\n#define to_smem_pipe(p) container_of(p, struct glink_smem_pipe, native)\n\nstatic size_t glink_smem_rx_avail(struct qcom_glink_pipe *np)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(np);\n\tstruct qcom_glink_smem *smem = pipe->smem;\n\tsize_t len;\n\tvoid *fifo;\n\tu32 head;\n\tu32 tail;\n\n\tif (!pipe->fifo) {\n\t\tfifo = qcom_smem_get(smem->remote_pid,\n\t\t\t\t     SMEM_GLINK_NATIVE_XPRT_FIFO_1, &len);\n\t\tif (IS_ERR(fifo)) {\n\t\t\tpr_err(\"failed to acquire RX fifo handle: %ld\\n\",\n\t\t\t       PTR_ERR(fifo));\n\t\t\treturn 0;\n\t\t}\n\n\t\tpipe->fifo = fifo;\n\t\tpipe->native.length = len;\n\t}\n\n\thead = le32_to_cpu(*pipe->head);\n\ttail = le32_to_cpu(*pipe->tail);\n\n\tif (head < tail)\n\t\treturn pipe->native.length - tail + head;\n\telse\n\t\treturn head - tail;\n}\n\nstatic void glink_smem_rx_peek(struct qcom_glink_pipe *np,\n\t\t\t       void *data, unsigned int offset, size_t count)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(np);\n\tsize_t len;\n\tu32 tail;\n\n\ttail = le32_to_cpu(*pipe->tail);\n\ttail += offset;\n\tif (tail >= pipe->native.length)\n\t\ttail -= pipe->native.length;\n\n\tlen = min_t(size_t, count, pipe->native.length - tail);\n\tif (len)\n\t\tmemcpy_fromio(data, pipe->fifo + tail, len);\n\n\tif (len != count)\n\t\tmemcpy_fromio(data + len, pipe->fifo, (count - len));\n}\n\nstatic void glink_smem_rx_advance(struct qcom_glink_pipe *np,\n\t\t\t\t  size_t count)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(np);\n\tu32 tail;\n\n\ttail = le32_to_cpu(*pipe->tail);\n\n\ttail += count;\n\tif (tail >= pipe->native.length)\n\t\ttail -= pipe->native.length;\n\n\t*pipe->tail = cpu_to_le32(tail);\n}\n\nstatic size_t glink_smem_tx_avail(struct qcom_glink_pipe *np)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(np);\n\tu32 head;\n\tu32 tail;\n\tu32 avail;\n\n\thead = le32_to_cpu(*pipe->head);\n\ttail = le32_to_cpu(*pipe->tail);\n\n\tif (tail <= head)\n\t\tavail = pipe->native.length - head + tail;\n\telse\n\t\tavail = tail - head;\n\n\tif (avail < (FIFO_FULL_RESERVE + TX_BLOCKED_CMD_RESERVE))\n\t\tavail = 0;\n\telse\n\t\tavail -= FIFO_FULL_RESERVE + TX_BLOCKED_CMD_RESERVE;\n\n\treturn avail;\n}\n\nstatic unsigned int glink_smem_tx_write_one(struct glink_smem_pipe *pipe,\n\t\t\t\t\t    unsigned int head,\n\t\t\t\t\t    const void *data, size_t count)\n{\n\tsize_t len;\n\n\tlen = min_t(size_t, count, pipe->native.length - head);\n\tif (len)\n\t\tmemcpy(pipe->fifo + head, data, len);\n\n\tif (len != count)\n\t\tmemcpy(pipe->fifo, data + len, count - len);\n\n\thead += count;\n\tif (head >= pipe->native.length)\n\t\thead -= pipe->native.length;\n\n\treturn head;\n}\n\nstatic void glink_smem_tx_write(struct qcom_glink_pipe *glink_pipe,\n\t\t\t\tconst void *hdr, size_t hlen,\n\t\t\t\tconst void *data, size_t dlen)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(glink_pipe);\n\tunsigned int head;\n\n\thead = le32_to_cpu(*pipe->head);\n\n\thead = glink_smem_tx_write_one(pipe, head, hdr, hlen);\n\thead = glink_smem_tx_write_one(pipe, head, data, dlen);\n\n\t \n\thead = ALIGN(head, 8);\n\tif (head >= pipe->native.length)\n\t\thead -= pipe->native.length;\n\n\t \n\twmb();\n\n\t*pipe->head = cpu_to_le32(head);\n}\n\nstatic void glink_smem_tx_kick(struct qcom_glink_pipe *glink_pipe)\n{\n\tstruct glink_smem_pipe *pipe = to_smem_pipe(glink_pipe);\n\tstruct qcom_glink_smem *smem = pipe->smem;\n\n\tmbox_send_message(smem->mbox_chan, NULL);\n\tmbox_client_txdone(smem->mbox_chan, 0);\n}\n\nstatic irqreturn_t qcom_glink_smem_intr(int irq, void *data)\n{\n\tstruct qcom_glink_smem *smem = data;\n\n\tqcom_glink_native_rx(smem->glink);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void qcom_glink_smem_release(struct device *dev)\n{\n\tstruct qcom_glink_smem *smem = container_of(dev, struct qcom_glink_smem, dev);\n\n\tkfree(smem);\n}\n\nstruct qcom_glink_smem *qcom_glink_smem_register(struct device *parent,\n\t\t\t\t\t\t struct device_node *node)\n{\n\tstruct glink_smem_pipe *rx_pipe;\n\tstruct glink_smem_pipe *tx_pipe;\n\tstruct qcom_glink_smem *smem;\n\tstruct qcom_glink *glink;\n\tstruct device *dev;\n\tu32 remote_pid;\n\t__le32 *descs;\n\tsize_t size;\n\tint ret;\n\n\tsmem = kzalloc(sizeof(*smem), GFP_KERNEL);\n\tif (!smem)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdev = &smem->dev;\n\n\tdev->parent = parent;\n\tdev->of_node = node;\n\tdev->release = qcom_glink_smem_release;\n\tdev_set_name(dev, \"%s:%pOFn\", dev_name(parent->parent), node);\n\tret = device_register(dev);\n\tif (ret) {\n\t\tpr_err(\"failed to register glink edge\\n\");\n\t\tput_device(dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"qcom,remote-pid\",\n\t\t\t\t   &remote_pid);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse qcom,remote-pid\\n\");\n\t\tgoto err_put_dev;\n\t}\n\n\tsmem->remote_pid = remote_pid;\n\n\trx_pipe = devm_kzalloc(dev, sizeof(*rx_pipe), GFP_KERNEL);\n\ttx_pipe = devm_kzalloc(dev, sizeof(*tx_pipe), GFP_KERNEL);\n\tif (!rx_pipe || !tx_pipe) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_dev;\n\t}\n\n\tret = qcom_smem_alloc(remote_pid,\n\t\t\t      SMEM_GLINK_NATIVE_XPRT_DESCRIPTOR, 32);\n\tif (ret && ret != -EEXIST) {\n\t\tdev_err(dev, \"failed to allocate glink descriptors\\n\");\n\t\tgoto err_put_dev;\n\t}\n\n\tdescs = qcom_smem_get(remote_pid,\n\t\t\t      SMEM_GLINK_NATIVE_XPRT_DESCRIPTOR, &size);\n\tif (IS_ERR(descs)) {\n\t\tdev_err(dev, \"failed to acquire xprt descriptor\\n\");\n\t\tret = PTR_ERR(descs);\n\t\tgoto err_put_dev;\n\t}\n\n\tif (size != 32) {\n\t\tdev_err(dev, \"glink descriptor of invalid size\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_put_dev;\n\t}\n\n\ttx_pipe->tail = &descs[0];\n\ttx_pipe->head = &descs[1];\n\trx_pipe->tail = &descs[2];\n\trx_pipe->head = &descs[3];\n\n\tret = qcom_smem_alloc(remote_pid, SMEM_GLINK_NATIVE_XPRT_FIFO_0,\n\t\t\t      SZ_16K);\n\tif (ret && ret != -EEXIST) {\n\t\tdev_err(dev, \"failed to allocate TX fifo\\n\");\n\t\tgoto err_put_dev;\n\t}\n\n\ttx_pipe->fifo = qcom_smem_get(remote_pid, SMEM_GLINK_NATIVE_XPRT_FIFO_0,\n\t\t\t\t      &tx_pipe->native.length);\n\tif (IS_ERR(tx_pipe->fifo)) {\n\t\tdev_err(dev, \"failed to acquire TX fifo\\n\");\n\t\tret = PTR_ERR(tx_pipe->fifo);\n\t\tgoto err_put_dev;\n\t}\n\n\tsmem->irq = of_irq_get(smem->dev.of_node, 0);\n\tret = devm_request_irq(&smem->dev, smem->irq, qcom_glink_smem_intr,\n\t\t\t       IRQF_NO_SUSPEND | IRQF_NO_AUTOEN,\n\t\t\t       \"glink-smem\", smem);\n\tif (ret) {\n\t\tdev_err(&smem->dev, \"failed to request IRQ\\n\");\n\t\tgoto err_put_dev;\n\t}\n\n\tsmem->mbox_client.dev = &smem->dev;\n\tsmem->mbox_client.knows_txdone = true;\n\tsmem->mbox_chan = mbox_request_channel(&smem->mbox_client, 0);\n\tif (IS_ERR(smem->mbox_chan)) {\n\t\tret = dev_err_probe(&smem->dev, PTR_ERR(smem->mbox_chan),\n\t\t\t\t    \"failed to acquire IPC channel\\n\");\n\t\tgoto err_put_dev;\n\t}\n\n\trx_pipe->smem = smem;\n\trx_pipe->native.avail = glink_smem_rx_avail;\n\trx_pipe->native.peek = glink_smem_rx_peek;\n\trx_pipe->native.advance = glink_smem_rx_advance;\n\n\ttx_pipe->smem = smem;\n\ttx_pipe->native.avail = glink_smem_tx_avail;\n\ttx_pipe->native.write = glink_smem_tx_write;\n\ttx_pipe->native.kick = glink_smem_tx_kick;\n\n\t*rx_pipe->tail = 0;\n\t*tx_pipe->head = 0;\n\n\tglink = qcom_glink_native_probe(dev,\n\t\t\t\t\tGLINK_FEATURE_INTENT_REUSE,\n\t\t\t\t\t&rx_pipe->native, &tx_pipe->native,\n\t\t\t\t\tfalse);\n\tif (IS_ERR(glink)) {\n\t\tret = PTR_ERR(glink);\n\t\tgoto err_free_mbox;\n\t}\n\n\tsmem->glink = glink;\n\n\tenable_irq(smem->irq);\n\n\treturn smem;\n\nerr_free_mbox:\n\tmbox_free_channel(smem->mbox_chan);\n\nerr_put_dev:\n\tdevice_unregister(dev);\n\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(qcom_glink_smem_register);\n\nvoid qcom_glink_smem_unregister(struct qcom_glink_smem *smem)\n{\n\tstruct qcom_glink *glink = smem->glink;\n\n\tdisable_irq(smem->irq);\n\n\tqcom_glink_native_remove(glink);\n\n\tmbox_free_channel(smem->mbox_chan);\n\tdevice_unregister(&smem->dev);\n}\nEXPORT_SYMBOL_GPL(qcom_glink_smem_unregister);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm GLINK SMEM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}