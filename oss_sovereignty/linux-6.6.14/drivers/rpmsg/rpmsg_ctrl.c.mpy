{
  "module_name": "rpmsg_ctrl.c",
  "hash_id": "5f5cea5675a5c0460fa2f4c183839763f782e42287f72a622810113a74a3890d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/rpmsg_ctrl.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt)\t\tKBUILD_MODNAME \": \" fmt\n\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/fs.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rpmsg.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <uapi/linux/rpmsg.h>\n\n#include \"rpmsg_char.h\"\n#include \"rpmsg_internal.h\"\n\n#define RPMSG_DEV_MAX\t(MINORMASK + 1)\n\nstatic dev_t rpmsg_major;\n\nstatic DEFINE_IDA(rpmsg_ctrl_ida);\nstatic DEFINE_IDA(rpmsg_minor_ida);\n\n#define dev_to_ctrldev(dev) container_of(dev, struct rpmsg_ctrldev, dev)\n#define cdev_to_ctrldev(i_cdev) container_of(i_cdev, struct rpmsg_ctrldev, cdev)\n\n \nstruct rpmsg_ctrldev {\n\tstruct rpmsg_device *rpdev;\n\tstruct cdev cdev;\n\tstruct device dev;\n\tstruct mutex ctrl_lock;\n};\n\nstatic int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tget_device(&ctrldev->dev);\n\tfilp->private_data = ctrldev;\n\n\treturn 0;\n}\n\nstatic int rpmsg_ctrldev_release(struct inode *inode, struct file *filp)\n{\n\tstruct rpmsg_ctrldev *ctrldev = cdev_to_ctrldev(inode->i_cdev);\n\n\tput_device(&ctrldev->dev);\n\n\treturn 0;\n}\n\nstatic long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,\n\t\t\t\tunsigned long arg)\n{\n\tstruct rpmsg_ctrldev *ctrldev = fp->private_data;\n\tvoid __user *argp = (void __user *)arg;\n\tstruct rpmsg_endpoint_info eptinfo;\n\tstruct rpmsg_channel_info chinfo;\n\tstruct rpmsg_device *rpdev;\n\tint ret = 0;\n\n\tif (copy_from_user(&eptinfo, argp, sizeof(eptinfo)))\n\t\treturn -EFAULT;\n\n\tmemcpy(chinfo.name, eptinfo.name, RPMSG_NAME_SIZE);\n\tchinfo.name[RPMSG_NAME_SIZE - 1] = '\\0';\n\tchinfo.src = eptinfo.src;\n\tchinfo.dst = eptinfo.dst;\n\n\tmutex_lock(&ctrldev->ctrl_lock);\n\tswitch (cmd) {\n\tcase RPMSG_CREATE_EPT_IOCTL:\n\t\tret = rpmsg_chrdev_eptdev_create(ctrldev->rpdev, &ctrldev->dev, chinfo);\n\t\tbreak;\n\n\tcase RPMSG_CREATE_DEV_IOCTL:\n\t\trpdev = rpmsg_create_channel(ctrldev->rpdev, &chinfo);\n\t\tif (!rpdev) {\n\t\t\tdev_err(&ctrldev->dev, \"failed to create %s channel\\n\", chinfo.name);\n\t\t\tret = -ENXIO;\n\t\t}\n\t\tbreak;\n\n\tcase RPMSG_RELEASE_DEV_IOCTL:\n\t\tret = rpmsg_release_channel(ctrldev->rpdev, &chinfo);\n\t\tif (ret)\n\t\t\tdev_err(&ctrldev->dev, \"failed to release %s channel (%d)\\n\",\n\t\t\t\tchinfo.name, ret);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&ctrldev->ctrl_lock);\n\n\treturn ret;\n};\n\nstatic const struct file_operations rpmsg_ctrldev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = rpmsg_ctrldev_open,\n\t.release = rpmsg_ctrldev_release,\n\t.unlocked_ioctl = rpmsg_ctrldev_ioctl,\n\t.compat_ioctl = compat_ptr_ioctl,\n};\n\nstatic void rpmsg_ctrldev_release_device(struct device *dev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_to_ctrldev(dev);\n\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\n\tkfree(ctrldev);\n}\n\nstatic int rpmsg_ctrldev_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev;\n\tstruct device *dev;\n\tint ret;\n\n\tctrldev = kzalloc(sizeof(*ctrldev), GFP_KERNEL);\n\tif (!ctrldev)\n\t\treturn -ENOMEM;\n\n\tctrldev->rpdev = rpdev;\n\n\tdev = &ctrldev->dev;\n\tdevice_initialize(dev);\n\tdev->parent = &rpdev->dev;\n\tdev->class = rpmsg_class;\n\n\tmutex_init(&ctrldev->ctrl_lock);\n\tcdev_init(&ctrldev->cdev, &rpmsg_ctrldev_fops);\n\tctrldev->cdev.owner = THIS_MODULE;\n\n\tret = ida_simple_get(&rpmsg_minor_ida, 0, RPMSG_DEV_MAX, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_ctrldev;\n\tdev->devt = MKDEV(MAJOR(rpmsg_major), ret);\n\n\tret = ida_simple_get(&rpmsg_ctrl_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0)\n\t\tgoto free_minor_ida;\n\tdev->id = ret;\n\tdev_set_name(&ctrldev->dev, \"rpmsg_ctrl%d\", ret);\n\n\tret = cdev_device_add(&ctrldev->cdev, &ctrldev->dev);\n\tif (ret)\n\t\tgoto free_ctrl_ida;\n\n\t \n\tdev->release = rpmsg_ctrldev_release_device;\n\n\tdev_set_drvdata(&rpdev->dev, ctrldev);\n\n\treturn ret;\n\nfree_ctrl_ida:\n\tida_simple_remove(&rpmsg_ctrl_ida, dev->id);\nfree_minor_ida:\n\tida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));\nfree_ctrldev:\n\tput_device(dev);\n\tkfree(ctrldev);\n\n\treturn ret;\n}\n\nstatic void rpmsg_ctrldev_remove(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_ctrldev *ctrldev = dev_get_drvdata(&rpdev->dev);\n\tint ret;\n\n\tmutex_lock(&ctrldev->ctrl_lock);\n\t \n\tret = device_for_each_child(&ctrldev->dev, NULL, rpmsg_chrdev_eptdev_destroy);\n\tif (ret)\n\t\tdev_warn(&rpdev->dev, \"failed to nuke endpoints: %d\\n\", ret);\n\tmutex_unlock(&ctrldev->ctrl_lock);\n\n\tcdev_device_del(&ctrldev->cdev, &ctrldev->dev);\n\tput_device(&ctrldev->dev);\n}\n\nstatic struct rpmsg_driver rpmsg_ctrldev_driver = {\n\t.probe = rpmsg_ctrldev_probe,\n\t.remove = rpmsg_ctrldev_remove,\n\t.drv = {\n\t\t.name = \"rpmsg_ctrl\",\n\t},\n};\n\nstatic int rpmsg_ctrldev_init(void)\n{\n\tint ret;\n\n\tret = alloc_chrdev_region(&rpmsg_major, 0, RPMSG_DEV_MAX, \"rpmsg_ctrl\");\n\tif (ret < 0) {\n\t\tpr_err(\"failed to allocate char dev region\\n\");\n\t\treturn ret;\n\t}\n\n\tret = register_rpmsg_driver(&rpmsg_ctrldev_driver);\n\tif (ret < 0) {\n\t\tpr_err(\"failed to register rpmsg driver\\n\");\n\t\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n\t}\n\n\treturn ret;\n}\npostcore_initcall(rpmsg_ctrldev_init);\n\nstatic void rpmsg_ctrldev_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_ctrldev_driver);\n\tunregister_chrdev_region(rpmsg_major, RPMSG_DEV_MAX);\n}\nmodule_exit(rpmsg_ctrldev_exit);\n\nMODULE_DESCRIPTION(\"rpmsg control interface\");\nMODULE_ALIAS(\"rpmsg:\" KBUILD_MODNAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}