{
  "module_name": "rpmsg_ns.c",
  "hash_id": "97cfbf14d2fe68bab8d50fe19ecbbfb70888b740db86710764e4141074292e66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/rpmsg_ns.c",
  "human_readable_source": "\n \n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rpmsg.h>\n#include <linux/rpmsg/ns.h>\n#include <linux/slab.h>\n\n#include \"rpmsg_internal.h\"\n\n \nint rpmsg_ns_register_device(struct rpmsg_device *rpdev)\n{\n\trpdev->src = RPMSG_NS_ADDR;\n\trpdev->dst = RPMSG_NS_ADDR;\n\n\treturn rpmsg_register_device_override(rpdev, \"rpmsg_ns\");\n}\nEXPORT_SYMBOL(rpmsg_ns_register_device);\n\n \nstatic int rpmsg_ns_cb(struct rpmsg_device *rpdev, void *data, int len,\n\t\t       void *priv, u32 src)\n{\n\tstruct rpmsg_ns_msg *msg = data;\n\tstruct rpmsg_device *newch;\n\tstruct rpmsg_channel_info chinfo;\n\tstruct device *dev = rpdev->dev.parent;\n\tint ret;\n\n#if defined(CONFIG_DYNAMIC_DEBUG)\n\tdynamic_hex_dump(\"NS announcement: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t data, len, true);\n#endif\n\n\tif (len != sizeof(*msg)) {\n\t\tdev_err(dev, \"malformed ns msg (%d)\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmsg->name[RPMSG_NAME_SIZE - 1] = '\\0';\n\n\tstrncpy(chinfo.name, msg->name, sizeof(chinfo.name));\n\tchinfo.src = RPMSG_ADDR_ANY;\n\tchinfo.dst = rpmsg32_to_cpu(rpdev, msg->addr);\n\n\tdev_info(dev, \"%sing channel %s addr 0x%x\\n\",\n\t\t rpmsg32_to_cpu(rpdev, msg->flags) & RPMSG_NS_DESTROY ?\n\t\t \"destroy\" : \"creat\", msg->name, chinfo.dst);\n\n\tif (rpmsg32_to_cpu(rpdev, msg->flags) & RPMSG_NS_DESTROY) {\n\t\tret = rpmsg_release_channel(rpdev, &chinfo);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"rpmsg_destroy_channel failed: %d\\n\", ret);\n\t} else {\n\t\tnewch = rpmsg_create_channel(rpdev, &chinfo);\n\t\tif (!newch)\n\t\t\tdev_err(dev, \"rpmsg_create_channel failed\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic int rpmsg_ns_probe(struct rpmsg_device *rpdev)\n{\n\tstruct rpmsg_endpoint *ns_ept;\n\tstruct rpmsg_channel_info ns_chinfo = {\n\t\t.src = RPMSG_NS_ADDR,\n\t\t.dst = RPMSG_NS_ADDR,\n\t\t.name = \"name_service\",\n\t};\n\n\t \n\tns_ept = rpmsg_create_ept(rpdev, rpmsg_ns_cb, NULL, ns_chinfo);\n\tif (!ns_ept) {\n\t\tdev_err(&rpdev->dev, \"failed to create the ns ept\\n\");\n\t\treturn -ENOMEM;\n\t}\n\trpdev->ept = ns_ept;\n\n\treturn 0;\n}\n\nstatic struct rpmsg_driver rpmsg_ns_driver = {\n\t.drv.name = KBUILD_MODNAME,\n\t.probe = rpmsg_ns_probe,\n};\n\nstatic int rpmsg_ns_init(void)\n{\n\tint ret;\n\n\tret = register_rpmsg_driver(&rpmsg_ns_driver);\n\tif (ret < 0)\n\t\tpr_err(\"%s: Failed to register rpmsg driver\\n\", __func__);\n\n\treturn ret;\n}\npostcore_initcall(rpmsg_ns_init);\n\nstatic void rpmsg_ns_exit(void)\n{\n\tunregister_rpmsg_driver(&rpmsg_ns_driver);\n}\nmodule_exit(rpmsg_ns_exit);\n\nMODULE_DESCRIPTION(\"Name service announcement rpmsg driver\");\nMODULE_AUTHOR(\"Arnaud Pouliquen <arnaud.pouliquen@st.com>\");\nMODULE_ALIAS(\"rpmsg:\" KBUILD_MODNAME);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}