{
  "module_name": "mtk_rpmsg.c",
  "hash_id": "176aa6d3647c2f4d4e049ec695a6aa59b8a0279c9bd9119e2fc4ecbd29d91290",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/mtk_rpmsg.c",
  "human_readable_source": "\n\n\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/remoteproc.h>\n#include <linux/rpmsg/mtk_rpmsg.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"rpmsg_internal.h\"\n\nstruct mtk_rpmsg_rproc_subdev {\n\tstruct platform_device *pdev;\n\tstruct mtk_rpmsg_info *info;\n\tstruct rpmsg_endpoint *ns_ept;\n\tstruct rproc_subdev subdev;\n\n\tstruct work_struct register_work;\n\tstruct list_head channels;\n\tstruct mutex channels_lock;\n};\n\n#define to_mtk_subdev(d) container_of(d, struct mtk_rpmsg_rproc_subdev, subdev)\n\nstruct mtk_rpmsg_channel_info {\n\tstruct rpmsg_channel_info info;\n\tbool registered;\n\tstruct list_head list;\n};\n\n \nstruct rpmsg_ns_msg {\n\tchar name[RPMSG_NAME_SIZE];\n\tu32 addr;\n} __packed;\n\nstruct mtk_rpmsg_device {\n\tstruct rpmsg_device rpdev;\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev;\n};\n\nstruct mtk_rpmsg_endpoint {\n\tstruct rpmsg_endpoint ept;\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev;\n};\n\n#define to_mtk_rpmsg_device(r) container_of(r, struct mtk_rpmsg_device, rpdev)\n#define to_mtk_rpmsg_endpoint(r) container_of(r, struct mtk_rpmsg_endpoint, ept)\n\nstatic const struct rpmsg_endpoint_ops mtk_rpmsg_endpoint_ops;\n\nstatic void __mtk_ept_release(struct kref *kref)\n{\n\tstruct rpmsg_endpoint *ept = container_of(kref, struct rpmsg_endpoint,\n\t\t\t\t\t\t  refcount);\n\tkfree(to_mtk_rpmsg_endpoint(ept));\n}\n\nstatic void mtk_rpmsg_ipi_handler(void *data, unsigned int len, void *priv)\n{\n\tstruct mtk_rpmsg_endpoint *mept = priv;\n\tstruct rpmsg_endpoint *ept = &mept->ept;\n\tint ret;\n\n\tret = (*ept->cb)(ept->rpdev, data, len, ept->priv, ept->addr);\n\tif (ret)\n\t\tdev_warn(&ept->rpdev->dev, \"rpmsg handler return error = %d\",\n\t\t\t ret);\n}\n\nstatic struct rpmsg_endpoint *\n__mtk_create_ept(struct mtk_rpmsg_rproc_subdev *mtk_subdev,\n\t\t struct rpmsg_device *rpdev, rpmsg_rx_cb_t cb, void *priv,\n\t\t u32 id)\n{\n\tstruct mtk_rpmsg_endpoint *mept;\n\tstruct rpmsg_endpoint *ept;\n\tstruct platform_device *pdev = mtk_subdev->pdev;\n\tint ret;\n\n\tmept = kzalloc(sizeof(*mept), GFP_KERNEL);\n\tif (!mept)\n\t\treturn NULL;\n\tmept->mtk_subdev = mtk_subdev;\n\n\tept = &mept->ept;\n\tkref_init(&ept->refcount);\n\n\tept->rpdev = rpdev;\n\tept->cb = cb;\n\tept->priv = priv;\n\tept->ops = &mtk_rpmsg_endpoint_ops;\n\tept->addr = id;\n\n\tret = mtk_subdev->info->register_ipi(pdev, id, mtk_rpmsg_ipi_handler,\n\t\t\t\t\t     mept);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"IPI register failed, id = %d\", id);\n\t\tkref_put(&ept->refcount, __mtk_ept_release);\n\t\treturn NULL;\n\t}\n\n\treturn ept;\n}\n\nstatic struct rpmsg_endpoint *\nmtk_rpmsg_create_ept(struct rpmsg_device *rpdev, rpmsg_rx_cb_t cb, void *priv,\n\t\t     struct rpmsg_channel_info chinfo)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev =\n\t\tto_mtk_rpmsg_device(rpdev)->mtk_subdev;\n\n\treturn __mtk_create_ept(mtk_subdev, rpdev, cb, priv, chinfo.src);\n}\n\nstatic void mtk_rpmsg_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev =\n\t\tto_mtk_rpmsg_endpoint(ept)->mtk_subdev;\n\n\tmtk_subdev->info->unregister_ipi(mtk_subdev->pdev, ept->addr);\n\tkref_put(&ept->refcount, __mtk_ept_release);\n}\n\nstatic int mtk_rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev =\n\t\tto_mtk_rpmsg_endpoint(ept)->mtk_subdev;\n\n\treturn mtk_subdev->info->send_ipi(mtk_subdev->pdev, ept->addr, data,\n\t\t\t\t\t  len, 0);\n}\n\nstatic int mtk_rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev =\n\t\tto_mtk_rpmsg_endpoint(ept)->mtk_subdev;\n\n\t \n\treturn mtk_subdev->info->send_ipi(mtk_subdev->pdev, ept->addr, data,\n\t\t\t\t\t  len, 0);\n}\n\nstatic const struct rpmsg_endpoint_ops mtk_rpmsg_endpoint_ops = {\n\t.destroy_ept = mtk_rpmsg_destroy_ept,\n\t.send = mtk_rpmsg_send,\n\t.trysend = mtk_rpmsg_trysend,\n};\n\nstatic void mtk_rpmsg_release_device(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct mtk_rpmsg_device *mdev = to_mtk_rpmsg_device(rpdev);\n\n\tkfree(mdev);\n}\n\nstatic const struct rpmsg_device_ops mtk_rpmsg_device_ops = {\n\t.create_ept = mtk_rpmsg_create_ept,\n};\n\nstatic struct device_node *\nmtk_rpmsg_match_device_subnode(struct device_node *node, const char *channel)\n{\n\tstruct device_node *child;\n\tconst char *name;\n\tint ret;\n\n\tfor_each_available_child_of_node(node, child) {\n\t\tret = of_property_read_string(child, \"mediatek,rpmsg-name\", &name);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, channel) == 0)\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\nstatic int mtk_rpmsg_register_device(struct mtk_rpmsg_rproc_subdev *mtk_subdev,\n\t\t\t\t     struct rpmsg_channel_info *info)\n{\n\tstruct rpmsg_device *rpdev;\n\tstruct mtk_rpmsg_device *mdev;\n\tstruct platform_device *pdev = mtk_subdev->pdev;\n\n\tmdev = kzalloc(sizeof(*mdev), GFP_KERNEL);\n\tif (!mdev)\n\t\treturn -ENOMEM;\n\n\tmdev->mtk_subdev = mtk_subdev;\n\n\trpdev = &mdev->rpdev;\n\trpdev->ops = &mtk_rpmsg_device_ops;\n\trpdev->src = info->src;\n\trpdev->dst = info->dst;\n\tstrscpy(rpdev->id.name, info->name, RPMSG_NAME_SIZE);\n\n\trpdev->dev.of_node =\n\t\tmtk_rpmsg_match_device_subnode(pdev->dev.of_node, info->name);\n\trpdev->dev.parent = &pdev->dev;\n\trpdev->dev.release = mtk_rpmsg_release_device;\n\n\treturn rpmsg_register_device(rpdev);\n}\n\nstatic void mtk_register_device_work_function(struct work_struct *register_work)\n{\n\tstruct mtk_rpmsg_rproc_subdev *subdev = container_of(\n\t\tregister_work, struct mtk_rpmsg_rproc_subdev, register_work);\n\tstruct platform_device *pdev = subdev->pdev;\n\tstruct mtk_rpmsg_channel_info *info;\n\tint ret;\n\n\tmutex_lock(&subdev->channels_lock);\n\tlist_for_each_entry(info, &subdev->channels, list) {\n\t\tif (info->registered)\n\t\t\tcontinue;\n\n\t\tmutex_unlock(&subdev->channels_lock);\n\t\tret = mtk_rpmsg_register_device(subdev, &info->info);\n\t\tmutex_lock(&subdev->channels_lock);\n\t\tif (ret) {\n\t\t\tdev_err(&pdev->dev, \"Can't create rpmsg_device\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tinfo->registered = true;\n\t}\n\tmutex_unlock(&subdev->channels_lock);\n}\n\nstatic int mtk_rpmsg_create_device(struct mtk_rpmsg_rproc_subdev *mtk_subdev,\n\t\t\t\t   char *name, u32 addr)\n{\n\tstruct mtk_rpmsg_channel_info *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tstrscpy(info->info.name, name, RPMSG_NAME_SIZE);\n\tinfo->info.src = addr;\n\tinfo->info.dst = RPMSG_ADDR_ANY;\n\tmutex_lock(&mtk_subdev->channels_lock);\n\tlist_add(&info->list, &mtk_subdev->channels);\n\tmutex_unlock(&mtk_subdev->channels_lock);\n\n\tschedule_work(&mtk_subdev->register_work);\n\treturn 0;\n}\n\nstatic int mtk_rpmsg_ns_cb(struct rpmsg_device *rpdev, void *data, int len,\n\t\t\t   void *priv, u32 src)\n{\n\tstruct rpmsg_ns_msg *msg = data;\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev = priv;\n\tstruct device *dev = &mtk_subdev->pdev->dev;\n\n\tint ret;\n\n\tif (len != sizeof(*msg)) {\n\t\tdev_err(dev, \"malformed ns msg (%d)\\n\", len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (rpdev) {\n\t\tdev_err(dev, \"anomaly: ns ept has an rpdev handle\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmsg->name[RPMSG_NAME_SIZE - 1] = '\\0';\n\n\tdev_info(dev, \"creating channel %s addr 0x%x\\n\", msg->name, msg->addr);\n\n\tret = mtk_rpmsg_create_device(mtk_subdev, msg->name, msg->addr);\n\tif (ret) {\n\t\tdev_err(dev, \"create rpmsg device failed\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtk_rpmsg_prepare(struct rproc_subdev *subdev)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev = to_mtk_subdev(subdev);\n\n\t \n\tif (mtk_subdev->info->ns_ipi_id >= 0) {\n\t\tmtk_subdev->ns_ept =\n\t\t\t__mtk_create_ept(mtk_subdev, NULL, mtk_rpmsg_ns_cb,\n\t\t\t\t\t mtk_subdev,\n\t\t\t\t\t mtk_subdev->info->ns_ipi_id);\n\t\tif (!mtk_subdev->ns_ept) {\n\t\t\tdev_err(&mtk_subdev->pdev->dev,\n\t\t\t\t\"failed to create name service endpoint\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void mtk_rpmsg_unprepare(struct rproc_subdev *subdev)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev = to_mtk_subdev(subdev);\n\n\tif (mtk_subdev->ns_ept) {\n\t\tmtk_rpmsg_destroy_ept(mtk_subdev->ns_ept);\n\t\tmtk_subdev->ns_ept = NULL;\n\t}\n}\n\nstatic void mtk_rpmsg_stop(struct rproc_subdev *subdev, bool crashed)\n{\n\tstruct mtk_rpmsg_channel_info *info, *next;\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev = to_mtk_subdev(subdev);\n\tstruct device *dev = &mtk_subdev->pdev->dev;\n\n\t \n\tif (mtk_subdev->ns_ept) {\n\t\tmtk_rpmsg_destroy_ept(mtk_subdev->ns_ept);\n\t\tmtk_subdev->ns_ept = NULL;\n\t}\n\n\tcancel_work_sync(&mtk_subdev->register_work);\n\n\tmutex_lock(&mtk_subdev->channels_lock);\n\tlist_for_each_entry(info, &mtk_subdev->channels, list) {\n\t\tif (!info->registered)\n\t\t\tcontinue;\n\t\tif (rpmsg_unregister_device(dev, &info->info)) {\n\t\t\tdev_warn(\n\t\t\t\tdev,\n\t\t\t\t\"rpmsg_unregister_device failed for %s.%d.%d\\n\",\n\t\t\t\tinfo->info.name, info->info.src,\n\t\t\t\tinfo->info.dst);\n\t\t}\n\t}\n\n\tlist_for_each_entry_safe(info, next,\n\t\t\t\t &mtk_subdev->channels, list) {\n\t\tlist_del(&info->list);\n\t\tkfree(info);\n\t}\n\tmutex_unlock(&mtk_subdev->channels_lock);\n}\n\nstruct rproc_subdev *\nmtk_rpmsg_create_rproc_subdev(struct platform_device *pdev,\n\t\t\t      struct mtk_rpmsg_info *info)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev;\n\n\tmtk_subdev = kzalloc(sizeof(*mtk_subdev), GFP_KERNEL);\n\tif (!mtk_subdev)\n\t\treturn NULL;\n\n\tmtk_subdev->pdev = pdev;\n\tmtk_subdev->subdev.prepare = mtk_rpmsg_prepare;\n\tmtk_subdev->subdev.stop = mtk_rpmsg_stop;\n\tmtk_subdev->subdev.unprepare = mtk_rpmsg_unprepare;\n\tmtk_subdev->info = info;\n\tINIT_LIST_HEAD(&mtk_subdev->channels);\n\tINIT_WORK(&mtk_subdev->register_work,\n\t\t  mtk_register_device_work_function);\n\tmutex_init(&mtk_subdev->channels_lock);\n\n\treturn &mtk_subdev->subdev;\n}\nEXPORT_SYMBOL_GPL(mtk_rpmsg_create_rproc_subdev);\n\nvoid mtk_rpmsg_destroy_rproc_subdev(struct rproc_subdev *subdev)\n{\n\tstruct mtk_rpmsg_rproc_subdev *mtk_subdev = to_mtk_subdev(subdev);\n\n\tkfree(mtk_subdev);\n}\nEXPORT_SYMBOL_GPL(mtk_rpmsg_destroy_rproc_subdev);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek scp rpmsg driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}