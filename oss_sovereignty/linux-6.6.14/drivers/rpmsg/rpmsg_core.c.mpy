{
  "module_name": "rpmsg_core.c",
  "hash_id": "9c4a5bce1974f89236db6bbed8d07edc6b1005f21e4419f10e80e67bfc9abb30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/rpmsg_core.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/rpmsg.h>\n#include <linux/of_device.h>\n#include <linux/pm_domain.h>\n#include <linux/slab.h>\n\n#include \"rpmsg_internal.h\"\n\nstruct class *rpmsg_class;\nEXPORT_SYMBOL(rpmsg_class);\n\n \nstruct rpmsg_device *rpmsg_create_channel(struct rpmsg_device *rpdev,\n\t\t\t\t\t  struct rpmsg_channel_info *chinfo)\n{\n\tif (WARN_ON(!rpdev))\n\t\treturn NULL;\n\tif (!rpdev->ops || !rpdev->ops->create_channel) {\n\t\tdev_err(&rpdev->dev, \"no create_channel ops found\\n\");\n\t\treturn NULL;\n\t}\n\n\treturn rpdev->ops->create_channel(rpdev, chinfo);\n}\nEXPORT_SYMBOL(rpmsg_create_channel);\n\n \nint rpmsg_release_channel(struct rpmsg_device *rpdev,\n\t\t\t  struct rpmsg_channel_info *chinfo)\n{\n\tif (WARN_ON(!rpdev))\n\t\treturn -EINVAL;\n\tif (!rpdev->ops || !rpdev->ops->release_channel) {\n\t\tdev_err(&rpdev->dev, \"no release_channel ops found\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn rpdev->ops->release_channel(rpdev, chinfo);\n}\nEXPORT_SYMBOL(rpmsg_release_channel);\n\n \nstruct rpmsg_endpoint *rpmsg_create_ept(struct rpmsg_device *rpdev,\n\t\t\t\t\trpmsg_rx_cb_t cb, void *priv,\n\t\t\t\t\tstruct rpmsg_channel_info chinfo)\n{\n\tif (WARN_ON(!rpdev))\n\t\treturn NULL;\n\n\treturn rpdev->ops->create_ept(rpdev, cb, priv, chinfo);\n}\nEXPORT_SYMBOL(rpmsg_create_ept);\n\n \nvoid rpmsg_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\tif (ept && ept->ops)\n\t\tept->ops->destroy_ept(ept);\n}\nEXPORT_SYMBOL(rpmsg_destroy_ept);\n\n \nint rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->send)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->send(ept, data, len);\n}\nEXPORT_SYMBOL(rpmsg_send);\n\n \nint rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->sendto)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->sendto(ept, data, len, dst);\n}\nEXPORT_SYMBOL(rpmsg_sendto);\n\n \nint rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,\n\t\t\t  void *data, int len)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->send_offchannel)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->send_offchannel(ept, src, dst, data, len);\n}\nEXPORT_SYMBOL(rpmsg_send_offchannel);\n\n \nint rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->trysend)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->trysend(ept, data, len);\n}\nEXPORT_SYMBOL(rpmsg_trysend);\n\n \nint rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->trysendto)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->trysendto(ept, data, len, dst);\n}\nEXPORT_SYMBOL(rpmsg_trysendto);\n\n \n__poll_t rpmsg_poll(struct rpmsg_endpoint *ept, struct file *filp,\n\t\t\tpoll_table *wait)\n{\n\tif (WARN_ON(!ept))\n\t\treturn 0;\n\tif (!ept->ops->poll)\n\t\treturn 0;\n\n\treturn ept->ops->poll(ept, filp, wait);\n}\nEXPORT_SYMBOL(rpmsg_poll);\n\n \nint rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src, u32 dst,\n\t\t\t     void *data, int len)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->trysend_offchannel)\n\t\treturn -ENXIO;\n\n\treturn ept->ops->trysend_offchannel(ept, src, dst, data, len);\n}\nEXPORT_SYMBOL(rpmsg_trysend_offchannel);\n\n \nint rpmsg_set_flow_control(struct rpmsg_endpoint *ept, bool pause, u32 dst)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->set_flow_control)\n\t\treturn -EOPNOTSUPP;\n\n\treturn ept->ops->set_flow_control(ept, pause, dst);\n}\nEXPORT_SYMBOL_GPL(rpmsg_set_flow_control);\n\n \n\nssize_t rpmsg_get_mtu(struct rpmsg_endpoint *ept)\n{\n\tif (WARN_ON(!ept))\n\t\treturn -EINVAL;\n\tif (!ept->ops->get_mtu)\n\t\treturn -ENOTSUPP;\n\n\treturn ept->ops->get_mtu(ept);\n}\nEXPORT_SYMBOL(rpmsg_get_mtu);\n\n \nstatic int rpmsg_device_match(struct device *dev, void *data)\n{\n\tstruct rpmsg_channel_info *chinfo = data;\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\n\tif (chinfo->src != RPMSG_ADDR_ANY && chinfo->src != rpdev->src)\n\t\treturn 0;\n\n\tif (chinfo->dst != RPMSG_ADDR_ANY && chinfo->dst != rpdev->dst)\n\t\treturn 0;\n\n\tif (strncmp(chinfo->name, rpdev->id.name, RPMSG_NAME_SIZE))\n\t\treturn 0;\n\n\t \n\treturn 1;\n}\n\nstruct device *rpmsg_find_device(struct device *parent,\n\t\t\t\t struct rpmsg_channel_info *chinfo)\n{\n\treturn device_find_child(parent, chinfo, rpmsg_device_match);\n\n}\nEXPORT_SYMBOL(rpmsg_find_device);\n\n \n#define rpmsg_show_attr(field, path, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev,\t\t\t\t\t\\\n\t\t\tstruct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, format_string, rpdev->path);\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field);\n\n#define rpmsg_string_attr(field, member)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_store(struct device *dev, struct device_attribute *attr,\t\\\n\t      const char *buf, size_t sz)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\t\t\\\n\tconst char *old;\t\t\t\t\t\t\\\n\tchar *new;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tnew = kstrndup(buf, sz, GFP_KERNEL);\t\t\t\t\\\n\tif (!new)\t\t\t\t\t\t\t\\\n\t\treturn -ENOMEM;\t\t\t\t\t\t\\\n\tnew[strcspn(new, \"\\n\")] = '\\0';\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdevice_lock(dev);\t\t\t\t\t\t\\\n\told = rpdev->member;\t\t\t\t\t\t\\\n\tif (strlen(new)) {\t\t\t\t\t\t\\\n\t\trpdev->member = new;\t\t\t\t\t\\\n\t} else {\t\t\t\t\t\t\t\\\n\t\tkfree(new);\t\t\t\t\t\t\\\n\t\trpdev->member = NULL;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tdevice_unlock(dev);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tkfree(old);\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sz;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev,\t\t\t\t\t\\\n\t     struct device_attribute *attr, char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%s\\n\", rpdev->member);\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(field)\n\n \nrpmsg_show_attr(name, id.name, \"%s\\n\");\nrpmsg_show_attr(src, src, \"0x%x\\n\");\nrpmsg_show_attr(dst, dst, \"0x%x\\n\");\nrpmsg_show_attr(announce, announce ? \"true\" : \"false\", \"%s\\n\");\nrpmsg_string_attr(driver_override, driver_override);\n\nstatic ssize_t modalias_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tssize_t len;\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn sprintf(buf, RPMSG_DEVICE_MODALIAS_FMT \"\\n\", rpdev->id.name);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *rpmsg_dev_attrs[] = {\n\t&dev_attr_name.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_dst.attr,\n\t&dev_attr_src.attr,\n\t&dev_attr_announce.attr,\n\t&dev_attr_driver_override.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(rpmsg_dev);\n\n \nstatic inline int rpmsg_id_match(const struct rpmsg_device *rpdev,\n\t\t\t\t  const struct rpmsg_device_id *id)\n{\n\treturn strncmp(id->name, rpdev->id.name, RPMSG_NAME_SIZE) == 0;\n}\n\n \nstatic int rpmsg_dev_match(struct device *dev, struct device_driver *drv)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct rpmsg_driver *rpdrv = to_rpmsg_driver(drv);\n\tconst struct rpmsg_device_id *ids = rpdrv->id_table;\n\tunsigned int i;\n\n\tif (rpdev->driver_override)\n\t\treturn !strcmp(rpdev->driver_override, drv->name);\n\n\tif (ids)\n\t\tfor (i = 0; ids[i].name[0]; i++)\n\t\t\tif (rpmsg_id_match(rpdev, &ids[i])) {\n\t\t\t\trpdev->id.driver_data = ids[i].driver_data;\n\t\t\t\treturn 1;\n\t\t\t}\n\n\treturn of_driver_match_device(dev, drv);\n}\n\nstatic int rpmsg_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tint ret;\n\n\tret = of_device_uevent_modalias(dev, env);\n\tif (ret != -ENODEV)\n\t\treturn ret;\n\n\treturn add_uevent_var(env, \"MODALIAS=\" RPMSG_DEVICE_MODALIAS_FMT,\n\t\t\t\t\trpdev->id.name);\n}\n\n \nstatic int rpmsg_dev_probe(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);\n\tstruct rpmsg_channel_info chinfo = {};\n\tstruct rpmsg_endpoint *ept = NULL;\n\tint err;\n\n\terr = dev_pm_domain_attach(dev, true);\n\tif (err)\n\t\tgoto out;\n\n\tif (rpdrv->callback) {\n\t\tstrncpy(chinfo.name, rpdev->id.name, RPMSG_NAME_SIZE);\n\t\tchinfo.src = rpdev->src;\n\t\tchinfo.dst = RPMSG_ADDR_ANY;\n\n\t\tept = rpmsg_create_ept(rpdev, rpdrv->callback, NULL, chinfo);\n\t\tif (!ept) {\n\t\t\tdev_err(dev, \"failed to create endpoint\\n\");\n\t\t\terr = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\trpdev->ept = ept;\n\t\trpdev->src = ept->addr;\n\n\t\tept->flow_cb = rpdrv->flowcontrol;\n\t}\n\n\terr = rpdrv->probe(rpdev);\n\tif (err) {\n\t\tdev_err(dev, \"%s: failed: %d\\n\", __func__, err);\n\t\tgoto destroy_ept;\n\t}\n\n\tif (ept && rpdev->ops->announce_create) {\n\t\terr = rpdev->ops->announce_create(rpdev);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to announce creation\\n\");\n\t\t\tgoto remove_rpdev;\n\t\t}\n\t}\n\n\treturn 0;\n\nremove_rpdev:\n\tif (rpdrv->remove)\n\t\trpdrv->remove(rpdev);\ndestroy_ept:\n\tif (ept)\n\t\trpmsg_destroy_ept(ept);\nout:\n\treturn err;\n}\n\nstatic void rpmsg_dev_remove(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct rpmsg_driver *rpdrv = to_rpmsg_driver(rpdev->dev.driver);\n\n\tif (rpdev->ops->announce_destroy)\n\t\trpdev->ops->announce_destroy(rpdev);\n\n\tif (rpdrv->remove)\n\t\trpdrv->remove(rpdev);\n\n\tdev_pm_domain_detach(dev, true);\n\n\tif (rpdev->ept)\n\t\trpmsg_destroy_ept(rpdev->ept);\n}\n\nstatic struct bus_type rpmsg_bus = {\n\t.name\t\t= \"rpmsg\",\n\t.match\t\t= rpmsg_dev_match,\n\t.dev_groups\t= rpmsg_dev_groups,\n\t.uevent\t\t= rpmsg_uevent,\n\t.probe\t\t= rpmsg_dev_probe,\n\t.remove\t\t= rpmsg_dev_remove,\n};\n\n \nint rpmsg_register_device_override(struct rpmsg_device *rpdev,\n\t\t\t\t   const char *driver_override)\n{\n\tstruct device *dev = &rpdev->dev;\n\tint ret;\n\n\tif (driver_override)\n\t\tstrscpy_pad(rpdev->id.name, driver_override, RPMSG_NAME_SIZE);\n\n\tdev_set_name(dev, \"%s.%s.%d.%d\", dev_name(dev->parent),\n\t\t     rpdev->id.name, rpdev->src, rpdev->dst);\n\n\tdev->bus = &rpmsg_bus;\n\n\tdevice_initialize(dev);\n\tif (driver_override) {\n\t\tret = driver_set_override(dev, &rpdev->driver_override,\n\t\t\t\t\t  driver_override,\n\t\t\t\t\t  strlen(driver_override));\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"device_set_override failed: %d\\n\", ret);\n\t\t\tput_device(dev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = device_add(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"device_add failed: %d\\n\", ret);\n\t\tkfree(rpdev->driver_override);\n\t\trpdev->driver_override = NULL;\n\t\tput_device(dev);\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL(rpmsg_register_device_override);\n\nint rpmsg_register_device(struct rpmsg_device *rpdev)\n{\n\treturn rpmsg_register_device_override(rpdev, NULL);\n}\nEXPORT_SYMBOL(rpmsg_register_device);\n\n \nint rpmsg_unregister_device(struct device *parent,\n\t\t\t    struct rpmsg_channel_info *chinfo)\n{\n\tstruct device *dev;\n\n\tdev = rpmsg_find_device(parent, chinfo);\n\tif (!dev)\n\t\treturn -EINVAL;\n\n\tdevice_unregister(dev);\n\n\tput_device(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(rpmsg_unregister_device);\n\n \nint __register_rpmsg_driver(struct rpmsg_driver *rpdrv, struct module *owner)\n{\n\trpdrv->drv.bus = &rpmsg_bus;\n\trpdrv->drv.owner = owner;\n\treturn driver_register(&rpdrv->drv);\n}\nEXPORT_SYMBOL(__register_rpmsg_driver);\n\n \nvoid unregister_rpmsg_driver(struct rpmsg_driver *rpdrv)\n{\n\tdriver_unregister(&rpdrv->drv);\n}\nEXPORT_SYMBOL(unregister_rpmsg_driver);\n\n\nstatic int __init rpmsg_init(void)\n{\n\tint ret;\n\n\trpmsg_class = class_create(\"rpmsg\");\n\tif (IS_ERR(rpmsg_class)) {\n\t\tpr_err(\"failed to create rpmsg class\\n\");\n\t\treturn PTR_ERR(rpmsg_class);\n\t}\n\n\tret = bus_register(&rpmsg_bus);\n\tif (ret) {\n\t\tpr_err(\"failed to register rpmsg bus: %d\\n\", ret);\n\t\tclass_destroy(rpmsg_class);\n\t}\n\treturn ret;\n}\npostcore_initcall(rpmsg_init);\n\nstatic void __exit rpmsg_fini(void)\n{\n\tbus_unregister(&rpmsg_bus);\n\tclass_destroy(rpmsg_class);\n}\nmodule_exit(rpmsg_fini);\n\nMODULE_DESCRIPTION(\"remote processor messaging bus\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}