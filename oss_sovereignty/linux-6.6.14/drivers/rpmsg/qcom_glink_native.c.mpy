{
  "module_name": "qcom_glink_native.c",
  "hash_id": "bd4a4363f3e004a604dd28ff418b4041d9ff9768784aa41f7187aa15b8251722",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/qcom_glink_native.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rpmsg.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/wait.h>\n#include <linux/workqueue.h>\n#include <linux/mailbox_client.h>\n\n#include \"rpmsg_internal.h\"\n#include \"qcom_glink_native.h\"\n\n#define GLINK_NAME_SIZE\t\t32\n#define GLINK_VERSION_1\t\t1\n\n#define RPM_GLINK_CID_MIN\t1\n#define RPM_GLINK_CID_MAX\t65536\n\nstruct glink_msg {\n\t__le16 cmd;\n\t__le16 param1;\n\t__le32 param2;\n\tu8 data[];\n} __packed;\n\n \nstruct glink_defer_cmd {\n\tstruct list_head node;\n\n\tstruct glink_msg msg;\n\tu8 data[];\n};\n\n \nstruct glink_core_rx_intent {\n\tvoid *data;\n\tu32 id;\n\tsize_t size;\n\tbool reuse;\n\tbool in_use;\n\tu32 offset;\n\n\tstruct list_head node;\n};\n\n \nstruct qcom_glink {\n\tstruct device *dev;\n\n\tstruct qcom_glink_pipe *rx_pipe;\n\tstruct qcom_glink_pipe *tx_pipe;\n\n\tstruct work_struct rx_work;\n\tspinlock_t rx_lock;\n\tstruct list_head rx_queue;\n\n\tspinlock_t tx_lock;\n\n\tspinlock_t idr_lock;\n\tstruct idr lcids;\n\tstruct idr rcids;\n\tunsigned long features;\n\n\tbool intentless;\n\twait_queue_head_t tx_avail_notify;\n\tbool sent_read_notify;\n\n\tbool abort_tx;\n};\n\nenum {\n\tGLINK_STATE_CLOSED,\n\tGLINK_STATE_OPENING,\n\tGLINK_STATE_OPEN,\n\tGLINK_STATE_CLOSING,\n};\n\n \nstruct glink_channel {\n\tstruct rpmsg_endpoint ept;\n\n\tstruct rpmsg_device *rpdev;\n\tstruct qcom_glink *glink;\n\n\tstruct kref refcount;\n\n\tspinlock_t recv_lock;\n\n\tchar *name;\n\tunsigned int lcid;\n\tunsigned int rcid;\n\n\tspinlock_t intent_lock;\n\tstruct idr liids;\n\tstruct idr riids;\n\tstruct work_struct intent_work;\n\tstruct list_head done_intents;\n\n\tstruct glink_core_rx_intent *buf;\n\tint buf_offset;\n\tint buf_size;\n\n\tstruct completion open_ack;\n\tstruct completion open_req;\n\n\tstruct mutex intent_req_lock;\n\tint intent_req_result;\n\tbool intent_received;\n\twait_queue_head_t intent_req_wq;\n};\n\n#define to_glink_channel(_ept) container_of(_ept, struct glink_channel, ept)\n\nstatic const struct rpmsg_endpoint_ops glink_endpoint_ops;\n\n#define GLINK_CMD_VERSION\t\t0\n#define GLINK_CMD_VERSION_ACK\t\t1\n#define GLINK_CMD_OPEN\t\t\t2\n#define GLINK_CMD_CLOSE\t\t\t3\n#define GLINK_CMD_OPEN_ACK\t\t4\n#define GLINK_CMD_INTENT\t\t5\n#define GLINK_CMD_RX_DONE\t\t6\n#define GLINK_CMD_RX_INTENT_REQ\t\t7\n#define GLINK_CMD_RX_INTENT_REQ_ACK\t8\n#define GLINK_CMD_TX_DATA\t\t9\n#define GLINK_CMD_CLOSE_ACK\t\t11\n#define GLINK_CMD_TX_DATA_CONT\t\t12\n#define GLINK_CMD_READ_NOTIF\t\t13\n#define GLINK_CMD_RX_DONE_W_REUSE\t14\n#define GLINK_CMD_SIGNALS\t\t15\n\n#define GLINK_FEATURE_INTENTLESS\tBIT(1)\n\n#define NATIVE_DTR_SIG\t\t\tNATIVE_DSR_SIG\n#define NATIVE_DSR_SIG\t\t\tBIT(31)\n#define NATIVE_RTS_SIG\t\t\tNATIVE_CTS_SIG\n#define NATIVE_CTS_SIG\t\t\tBIT(30)\n\nstatic void qcom_glink_rx_done_work(struct work_struct *work);\n\nstatic struct glink_channel *qcom_glink_alloc_channel(struct qcom_glink *glink,\n\t\t\t\t\t\t      const char *name)\n{\n\tstruct glink_channel *channel;\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tspin_lock_init(&channel->recv_lock);\n\tspin_lock_init(&channel->intent_lock);\n\tmutex_init(&channel->intent_req_lock);\n\n\tchannel->glink = glink;\n\tchannel->name = kstrdup(name, GFP_KERNEL);\n\tif (!channel->name) {\n\t\tkfree(channel);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinit_completion(&channel->open_req);\n\tinit_completion(&channel->open_ack);\n\tinit_waitqueue_head(&channel->intent_req_wq);\n\n\tINIT_LIST_HEAD(&channel->done_intents);\n\tINIT_WORK(&channel->intent_work, qcom_glink_rx_done_work);\n\n\tidr_init(&channel->liids);\n\tidr_init(&channel->riids);\n\tkref_init(&channel->refcount);\n\n\treturn channel;\n}\n\nstatic void qcom_glink_channel_release(struct kref *ref)\n{\n\tstruct glink_channel *channel = container_of(ref, struct glink_channel,\n\t\t\t\t\t\t     refcount);\n\tstruct glink_core_rx_intent *intent;\n\tstruct glink_core_rx_intent *tmp;\n\tunsigned long flags;\n\tint iid;\n\n\t \n\tcancel_work_sync(&channel->intent_work);\n\n\tspin_lock_irqsave(&channel->intent_lock, flags);\n\t \n\tlist_for_each_entry_safe(intent, tmp, &channel->done_intents, node) {\n\t\tif (!intent->reuse) {\n\t\t\tkfree(intent->data);\n\t\t\tkfree(intent);\n\t\t}\n\t}\n\n\tidr_for_each_entry(&channel->liids, tmp, iid) {\n\t\tkfree(tmp->data);\n\t\tkfree(tmp);\n\t}\n\tidr_destroy(&channel->liids);\n\n\tidr_for_each_entry(&channel->riids, tmp, iid)\n\t\tkfree(tmp);\n\tidr_destroy(&channel->riids);\n\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\tkfree(channel->name);\n\tkfree(channel);\n}\n\nstatic size_t qcom_glink_rx_avail(struct qcom_glink *glink)\n{\n\treturn glink->rx_pipe->avail(glink->rx_pipe);\n}\n\nstatic void qcom_glink_rx_peek(struct qcom_glink *glink,\n\t\t\t       void *data, unsigned int offset, size_t count)\n{\n\tglink->rx_pipe->peek(glink->rx_pipe, data, offset, count);\n}\n\nstatic void qcom_glink_rx_advance(struct qcom_glink *glink, size_t count)\n{\n\tglink->rx_pipe->advance(glink->rx_pipe, count);\n}\n\nstatic size_t qcom_glink_tx_avail(struct qcom_glink *glink)\n{\n\treturn glink->tx_pipe->avail(glink->tx_pipe);\n}\n\nstatic void qcom_glink_tx_write(struct qcom_glink *glink,\n\t\t\t\tconst void *hdr, size_t hlen,\n\t\t\t\tconst void *data, size_t dlen)\n{\n\tglink->tx_pipe->write(glink->tx_pipe, hdr, hlen, data, dlen);\n}\n\nstatic void qcom_glink_tx_kick(struct qcom_glink *glink)\n{\n\tglink->tx_pipe->kick(glink->tx_pipe);\n}\n\nstatic void qcom_glink_send_read_notify(struct qcom_glink *glink)\n{\n\tstruct glink_msg msg;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_READ_NOTIF);\n\tmsg.param1 = 0;\n\tmsg.param2 = 0;\n\n\tqcom_glink_tx_write(glink, &msg, sizeof(msg), NULL, 0);\n\n\tqcom_glink_tx_kick(glink);\n}\n\nstatic int qcom_glink_tx(struct qcom_glink *glink,\n\t\t\t const void *hdr, size_t hlen,\n\t\t\t const void *data, size_t dlen, bool wait)\n{\n\tunsigned int tlen = hlen + dlen;\n\tunsigned long flags;\n\tint ret = 0;\n\n\t \n\tif (tlen >= glink->tx_pipe->length)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&glink->tx_lock, flags);\n\n\tif (glink->abort_tx) {\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\twhile (qcom_glink_tx_avail(glink) < tlen) {\n\t\tif (!wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (glink->abort_tx) {\n\t\t\tret = -EIO;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!glink->sent_read_notify) {\n\t\t\tglink->sent_read_notify = true;\n\t\t\tqcom_glink_send_read_notify(glink);\n\t\t}\n\n\t\t \n\t\tspin_unlock_irqrestore(&glink->tx_lock, flags);\n\n\t\twait_event_timeout(glink->tx_avail_notify,\n\t\t\t\t   qcom_glink_tx_avail(glink) >= tlen, 10 * HZ);\n\n\t\tspin_lock_irqsave(&glink->tx_lock, flags);\n\n\t\tif (qcom_glink_tx_avail(glink) >= tlen)\n\t\t\tglink->sent_read_notify = false;\n\t}\n\n\tqcom_glink_tx_write(glink, hdr, hlen, data, dlen);\n\tqcom_glink_tx_kick(glink);\n\nout:\n\tspin_unlock_irqrestore(&glink->tx_lock, flags);\n\n\treturn ret;\n}\n\nstatic int qcom_glink_send_version(struct qcom_glink *glink)\n{\n\tstruct glink_msg msg;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_VERSION);\n\tmsg.param1 = cpu_to_le16(GLINK_VERSION_1);\n\tmsg.param2 = cpu_to_le32(glink->features);\n\n\treturn qcom_glink_tx(glink, &msg, sizeof(msg), NULL, 0, true);\n}\n\nstatic void qcom_glink_send_version_ack(struct qcom_glink *glink)\n{\n\tstruct glink_msg msg;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_VERSION_ACK);\n\tmsg.param1 = cpu_to_le16(GLINK_VERSION_1);\n\tmsg.param2 = cpu_to_le32(glink->features);\n\n\tqcom_glink_tx(glink, &msg, sizeof(msg), NULL, 0, true);\n}\n\nstatic void qcom_glink_send_open_ack(struct qcom_glink *glink,\n\t\t\t\t     struct glink_channel *channel)\n{\n\tstruct glink_msg msg;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_OPEN_ACK);\n\tmsg.param1 = cpu_to_le16(channel->rcid);\n\tmsg.param2 = cpu_to_le32(0);\n\n\tqcom_glink_tx(glink, &msg, sizeof(msg), NULL, 0, true);\n}\n\nstatic void qcom_glink_handle_intent_req_ack(struct qcom_glink *glink,\n\t\t\t\t\t     unsigned int cid, bool granted)\n{\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, cid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (!channel) {\n\t\tdev_err(glink->dev, \"unable to find channel\\n\");\n\t\treturn;\n\t}\n\n\tWRITE_ONCE(channel->intent_req_result, granted);\n\twake_up_all(&channel->intent_req_wq);\n}\n\nstatic void qcom_glink_intent_req_abort(struct glink_channel *channel)\n{\n\tWRITE_ONCE(channel->intent_req_result, 0);\n\twake_up_all(&channel->intent_req_wq);\n}\n\n \nstatic int qcom_glink_send_open_req(struct qcom_glink *glink,\n\t\t\t\t    struct glink_channel *channel)\n{\n\tstruct {\n\t\tstruct glink_msg msg;\n\t\tu8 name[GLINK_NAME_SIZE];\n\t} __packed req;\n\tint name_len = strlen(channel->name) + 1;\n\tint req_len = ALIGN(sizeof(req.msg) + name_len, 8);\n\tint ret;\n\tunsigned long flags;\n\n\tkref_get(&channel->refcount);\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tret = idr_alloc_cyclic(&glink->lcids, channel,\n\t\t\t       RPM_GLINK_CID_MIN, RPM_GLINK_CID_MAX,\n\t\t\t       GFP_ATOMIC);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchannel->lcid = ret;\n\n\treq.msg.cmd = cpu_to_le16(GLINK_CMD_OPEN);\n\treq.msg.param1 = cpu_to_le16(channel->lcid);\n\treq.msg.param2 = cpu_to_le32(name_len);\n\tstrcpy(req.name, channel->name);\n\n\tret = qcom_glink_tx(glink, &req, req_len, NULL, 0, true);\n\tif (ret)\n\t\tgoto remove_idr;\n\n\treturn 0;\n\nremove_idr:\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_remove(&glink->lcids, channel->lcid);\n\tchannel->lcid = 0;\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\treturn ret;\n}\n\nstatic void qcom_glink_send_close_req(struct qcom_glink *glink,\n\t\t\t\t      struct glink_channel *channel)\n{\n\tstruct glink_msg req;\n\n\treq.cmd = cpu_to_le16(GLINK_CMD_CLOSE);\n\treq.param1 = cpu_to_le16(channel->lcid);\n\treq.param2 = 0;\n\n\tqcom_glink_tx(glink, &req, sizeof(req), NULL, 0, true);\n}\n\nstatic void qcom_glink_send_close_ack(struct qcom_glink *glink,\n\t\t\t\t      unsigned int rcid)\n{\n\tstruct glink_msg req;\n\n\treq.cmd = cpu_to_le16(GLINK_CMD_CLOSE_ACK);\n\treq.param1 = cpu_to_le16(rcid);\n\treq.param2 = 0;\n\n\tqcom_glink_tx(glink, &req, sizeof(req), NULL, 0, true);\n}\n\nstatic void qcom_glink_rx_done_work(struct work_struct *work)\n{\n\tstruct glink_channel *channel = container_of(work, struct glink_channel,\n\t\t\t\t\t\t     intent_work);\n\tstruct qcom_glink *glink = channel->glink;\n\tstruct glink_core_rx_intent *intent, *tmp;\n\tstruct {\n\t\tu16 id;\n\t\tu16 lcid;\n\t\tu32 liid;\n\t} __packed cmd;\n\n\tunsigned int cid = channel->lcid;\n\tunsigned int iid;\n\tbool reuse;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->intent_lock, flags);\n\tlist_for_each_entry_safe(intent, tmp, &channel->done_intents, node) {\n\t\tlist_del(&intent->node);\n\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\t\tiid = intent->id;\n\t\treuse = intent->reuse;\n\n\t\tcmd.id = reuse ? GLINK_CMD_RX_DONE_W_REUSE : GLINK_CMD_RX_DONE;\n\t\tcmd.lcid = cid;\n\t\tcmd.liid = iid;\n\n\t\tqcom_glink_tx(glink, &cmd, sizeof(cmd), NULL, 0, true);\n\t\tif (!reuse) {\n\t\t\tkfree(intent->data);\n\t\t\tkfree(intent);\n\t\t}\n\t\tspin_lock_irqsave(&channel->intent_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n}\n\nstatic void qcom_glink_rx_done(struct qcom_glink *glink,\n\t\t\t       struct glink_channel *channel,\n\t\t\t       struct glink_core_rx_intent *intent)\n{\n\t \n\tif (glink->intentless) {\n\t\tkfree(intent->data);\n\t\tkfree(intent);\n\t\treturn;\n\t}\n\n\t \n\tif (!intent->reuse) {\n\t\tspin_lock(&channel->intent_lock);\n\t\tidr_remove(&channel->liids, intent->id);\n\t\tspin_unlock(&channel->intent_lock);\n\t}\n\n\t \n\tspin_lock(&channel->intent_lock);\n\tlist_add_tail(&intent->node, &channel->done_intents);\n\tspin_unlock(&channel->intent_lock);\n\n\tschedule_work(&channel->intent_work);\n}\n\n \nstatic void qcom_glink_receive_version(struct qcom_glink *glink,\n\t\t\t\t       u32 version,\n\t\t\t\t       u32 features)\n{\n\tswitch (version) {\n\tcase 0:\n\t\tbreak;\n\tcase GLINK_VERSION_1:\n\t\tglink->features &= features;\n\t\tfallthrough;\n\tdefault:\n\t\tqcom_glink_send_version_ack(glink);\n\t\tbreak;\n\t}\n}\n\n \nstatic void qcom_glink_receive_version_ack(struct qcom_glink *glink,\n\t\t\t\t\t   u32 version,\n\t\t\t\t\t   u32 features)\n{\n\tswitch (version) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase GLINK_VERSION_1:\n\t\tif (features == glink->features)\n\t\t\tbreak;\n\n\t\tglink->features &= features;\n\t\tfallthrough;\n\tdefault:\n\t\tqcom_glink_send_version(glink);\n\t\tbreak;\n\t}\n}\n\n \nstatic int qcom_glink_send_intent_req_ack(struct qcom_glink *glink,\n\t\t\t\t\t  struct glink_channel *channel,\n\t\t\t\t\t  bool granted)\n{\n\tstruct glink_msg msg;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_RX_INTENT_REQ_ACK);\n\tmsg.param1 = cpu_to_le16(channel->lcid);\n\tmsg.param2 = cpu_to_le32(granted);\n\n\tqcom_glink_tx(glink, &msg, sizeof(msg), NULL, 0, true);\n\n\treturn 0;\n}\n\n \nstatic int qcom_glink_advertise_intent(struct qcom_glink *glink,\n\t\t\t\t       struct glink_channel *channel,\n\t\t\t\t       struct glink_core_rx_intent *intent)\n{\n\tstruct command {\n\t\t__le16 id;\n\t\t__le16 lcid;\n\t\t__le32 count;\n\t\t__le32 size;\n\t\t__le32 liid;\n\t} __packed;\n\tstruct command cmd;\n\n\tcmd.id = cpu_to_le16(GLINK_CMD_INTENT);\n\tcmd.lcid = cpu_to_le16(channel->lcid);\n\tcmd.count = cpu_to_le32(1);\n\tcmd.size = cpu_to_le32(intent->size);\n\tcmd.liid = cpu_to_le32(intent->id);\n\n\tqcom_glink_tx(glink, &cmd, sizeof(cmd), NULL, 0, true);\n\n\treturn 0;\n}\n\nstatic struct glink_core_rx_intent *\nqcom_glink_alloc_intent(struct qcom_glink *glink,\n\t\t\tstruct glink_channel *channel,\n\t\t\tsize_t size,\n\t\t\tbool reuseable)\n{\n\tstruct glink_core_rx_intent *intent;\n\tint ret;\n\tunsigned long flags;\n\n\tintent = kzalloc(sizeof(*intent), GFP_KERNEL);\n\tif (!intent)\n\t\treturn NULL;\n\n\tintent->data = kzalloc(size, GFP_KERNEL);\n\tif (!intent->data)\n\t\tgoto free_intent;\n\n\tspin_lock_irqsave(&channel->intent_lock, flags);\n\tret = idr_alloc_cyclic(&channel->liids, intent, 1, -1, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\t\tgoto free_data;\n\t}\n\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\tintent->id = ret;\n\tintent->size = size;\n\tintent->reuse = reuseable;\n\n\treturn intent;\n\nfree_data:\n\tkfree(intent->data);\nfree_intent:\n\tkfree(intent);\n\treturn NULL;\n}\n\nstatic void qcom_glink_handle_rx_done(struct qcom_glink *glink,\n\t\t\t\t      u32 cid, uint32_t iid,\n\t\t\t\t      bool reuse)\n{\n\tstruct glink_core_rx_intent *intent;\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, cid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (!channel) {\n\t\tdev_err(glink->dev, \"invalid channel id received\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&channel->intent_lock, flags);\n\tintent = idr_find(&channel->riids, iid);\n\n\tif (!intent) {\n\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\t\tdev_err(glink->dev, \"invalid intent id received\\n\");\n\t\treturn;\n\t}\n\n\tintent->in_use = false;\n\n\tif (!reuse) {\n\t\tidr_remove(&channel->riids, intent->id);\n\t\tkfree(intent);\n\t}\n\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\tif (reuse) {\n\t\tWRITE_ONCE(channel->intent_received, true);\n\t\twake_up_all(&channel->intent_req_wq);\n\t}\n}\n\n \nstatic void qcom_glink_handle_intent_req(struct qcom_glink *glink,\n\t\t\t\t\t u32 cid, size_t size)\n{\n\tstruct glink_core_rx_intent *intent;\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, cid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tif (!channel) {\n\t\tpr_err(\"%s channel not found for cid %d\\n\", __func__, cid);\n\t\treturn;\n\t}\n\n\tintent = qcom_glink_alloc_intent(glink, channel, size, false);\n\tif (intent)\n\t\tqcom_glink_advertise_intent(glink, channel, intent);\n\n\tqcom_glink_send_intent_req_ack(glink, channel, !!intent);\n}\n\nstatic int qcom_glink_rx_defer(struct qcom_glink *glink, size_t extra)\n{\n\tstruct glink_defer_cmd *dcmd;\n\n\textra = ALIGN(extra, 8);\n\n\tif (qcom_glink_rx_avail(glink) < sizeof(struct glink_msg) + extra) {\n\t\tdev_dbg(glink->dev, \"Insufficient data in rx fifo\");\n\t\treturn -ENXIO;\n\t}\n\n\tdcmd = kzalloc(struct_size(dcmd, data, extra), GFP_ATOMIC);\n\tif (!dcmd)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dcmd->node);\n\n\tqcom_glink_rx_peek(glink, &dcmd->msg, 0, sizeof(dcmd->msg) + extra);\n\n\tspin_lock(&glink->rx_lock);\n\tlist_add_tail(&dcmd->node, &glink->rx_queue);\n\tspin_unlock(&glink->rx_lock);\n\n\tschedule_work(&glink->rx_work);\n\tqcom_glink_rx_advance(glink, sizeof(dcmd->msg) + extra);\n\n\treturn 0;\n}\n\nstatic int qcom_glink_rx_data(struct qcom_glink *glink, size_t avail)\n{\n\tstruct glink_core_rx_intent *intent;\n\tstruct glink_channel *channel;\n\tstruct {\n\t\tstruct glink_msg msg;\n\t\t__le32 chunk_size;\n\t\t__le32 left_size;\n\t} __packed hdr;\n\tunsigned int chunk_size;\n\tunsigned int left_size;\n\tunsigned int rcid;\n\tunsigned int liid;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tif (avail < sizeof(hdr)) {\n\t\tdev_dbg(glink->dev, \"Not enough data in fifo\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\tqcom_glink_rx_peek(glink, &hdr, 0, sizeof(hdr));\n\tchunk_size = le32_to_cpu(hdr.chunk_size);\n\tleft_size = le32_to_cpu(hdr.left_size);\n\n\tif (avail < sizeof(hdr) + chunk_size) {\n\t\tdev_dbg(glink->dev, \"Payload not yet in fifo\\n\");\n\t\treturn -EAGAIN;\n\t}\n\n\trcid = le16_to_cpu(hdr.msg.param1);\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, rcid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (!channel) {\n\t\tdev_dbg(glink->dev, \"Data on non-existing channel\\n\");\n\n\t\t \n\t\tgoto advance_rx;\n\t}\n\n\tif (glink->intentless) {\n\t\t \n\t\tif (!channel->buf) {\n\t\t\tintent = kzalloc(sizeof(*intent), GFP_ATOMIC);\n\t\t\tif (!intent)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tintent->data = kmalloc(chunk_size + left_size,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\t\tif (!intent->data) {\n\t\t\t\tkfree(intent);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\n\t\t\tintent->id = 0xbabababa;\n\t\t\tintent->size = chunk_size + left_size;\n\t\t\tintent->offset = 0;\n\n\t\t\tchannel->buf = intent;\n\t\t} else {\n\t\t\tintent = channel->buf;\n\t\t}\n\t} else {\n\t\tliid = le32_to_cpu(hdr.msg.param2);\n\n\t\tspin_lock_irqsave(&channel->intent_lock, flags);\n\t\tintent = idr_find(&channel->liids, liid);\n\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\t\tif (!intent) {\n\t\t\tdev_err(glink->dev,\n\t\t\t\t\"no intent found for channel %s intent %d\",\n\t\t\t\tchannel->name, liid);\n\t\t\tret = -ENOENT;\n\t\t\tgoto advance_rx;\n\t\t}\n\t}\n\n\tif (intent->size - intent->offset < chunk_size) {\n\t\tdev_err(glink->dev, \"Insufficient space in intent\\n\");\n\n\t\t \n\t\tgoto advance_rx;\n\t}\n\n\tqcom_glink_rx_peek(glink, intent->data + intent->offset,\n\t\t\t   sizeof(hdr), chunk_size);\n\tintent->offset += chunk_size;\n\n\t \n\tif (!left_size) {\n\t\tspin_lock(&channel->recv_lock);\n\t\tif (channel->ept.cb) {\n\t\t\tchannel->ept.cb(channel->ept.rpdev,\n\t\t\t\t\tintent->data,\n\t\t\t\t\tintent->offset,\n\t\t\t\t\tchannel->ept.priv,\n\t\t\t\t\tRPMSG_ADDR_ANY);\n\t\t}\n\t\tspin_unlock(&channel->recv_lock);\n\n\t\tintent->offset = 0;\n\t\tchannel->buf = NULL;\n\n\t\tqcom_glink_rx_done(glink, channel, intent);\n\t}\n\nadvance_rx:\n\tqcom_glink_rx_advance(glink, ALIGN(sizeof(hdr) + chunk_size, 8));\n\n\treturn ret;\n}\n\nstatic void qcom_glink_handle_intent(struct qcom_glink *glink,\n\t\t\t\t     unsigned int cid,\n\t\t\t\t     unsigned int count,\n\t\t\t\t     size_t avail)\n{\n\tstruct glink_core_rx_intent *intent;\n\tstruct glink_channel *channel;\n\tstruct intent_pair {\n\t\t__le32 size;\n\t\t__le32 iid;\n\t};\n\n\tstruct {\n\t\tstruct glink_msg msg;\n\t\tstruct intent_pair intents[];\n\t} __packed * msg;\n\n\tconst size_t msglen = struct_size(msg, intents, count);\n\tint ret;\n\tint i;\n\tunsigned long flags;\n\n\tif (avail < msglen) {\n\t\tdev_dbg(glink->dev, \"Not enough data in fifo\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, cid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (!channel) {\n\t\tdev_err(glink->dev, \"intents for non-existing channel\\n\");\n\t\tqcom_glink_rx_advance(glink, ALIGN(msglen, 8));\n\t\treturn;\n\t}\n\n\tmsg = kmalloc(msglen, GFP_ATOMIC);\n\tif (!msg)\n\t\treturn;\n\n\tqcom_glink_rx_peek(glink, msg, 0, msglen);\n\n\tfor (i = 0; i < count; ++i) {\n\t\tintent = kzalloc(sizeof(*intent), GFP_ATOMIC);\n\t\tif (!intent)\n\t\t\tbreak;\n\n\t\tintent->id = le32_to_cpu(msg->intents[i].iid);\n\t\tintent->size = le32_to_cpu(msg->intents[i].size);\n\n\t\tspin_lock_irqsave(&channel->intent_lock, flags);\n\t\tret = idr_alloc(&channel->riids, intent,\n\t\t\t\tintent->id, intent->id + 1, GFP_ATOMIC);\n\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\t\tif (ret < 0)\n\t\t\tdev_err(glink->dev, \"failed to store remote intent\\n\");\n\t}\n\n\tWRITE_ONCE(channel->intent_received, true);\n\twake_up_all(&channel->intent_req_wq);\n\n\tkfree(msg);\n\tqcom_glink_rx_advance(glink, ALIGN(msglen, 8));\n}\n\nstatic int qcom_glink_rx_open_ack(struct qcom_glink *glink, unsigned int lcid)\n{\n\tstruct glink_channel *channel;\n\n\tspin_lock(&glink->idr_lock);\n\tchannel = idr_find(&glink->lcids, lcid);\n\tspin_unlock(&glink->idr_lock);\n\tif (!channel) {\n\t\tdev_err(glink->dev, \"Invalid open ack packet\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tcomplete_all(&channel->open_ack);\n\n\treturn 0;\n}\n\n \nstatic int qcom_glink_set_flow_control(struct rpmsg_endpoint *ept, bool pause, u32 dst)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\tstruct qcom_glink *glink = channel->glink;\n\tstruct glink_msg msg;\n\tu32 sigs = 0;\n\n\tif (pause)\n\t\tsigs |= NATIVE_DTR_SIG | NATIVE_RTS_SIG;\n\n\tmsg.cmd = cpu_to_le16(GLINK_CMD_SIGNALS);\n\tmsg.param1 = cpu_to_le16(channel->lcid);\n\tmsg.param2 = cpu_to_le32(sigs);\n\n\treturn qcom_glink_tx(glink, &msg, sizeof(msg), NULL, 0, true);\n}\n\nstatic void qcom_glink_handle_signals(struct qcom_glink *glink,\n\t\t\t\t      unsigned int rcid, unsigned int sigs)\n{\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\tbool enable;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, rcid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (!channel) {\n\t\tdev_err(glink->dev, \"signal for non-existing channel\\n\");\n\t\treturn;\n\t}\n\n\tenable = sigs & NATIVE_DSR_SIG || sigs & NATIVE_CTS_SIG;\n\n\tif (channel->ept.flow_cb)\n\t\tchannel->ept.flow_cb(channel->ept.rpdev, channel->ept.priv, enable);\n}\n\nvoid qcom_glink_native_rx(struct qcom_glink *glink)\n{\n\tstruct glink_msg msg;\n\tunsigned int param1;\n\tunsigned int param2;\n\tunsigned int avail;\n\tunsigned int cmd;\n\tint ret = 0;\n\n\t \n\twake_up_all(&glink->tx_avail_notify);\n\n\tfor (;;) {\n\t\tavail = qcom_glink_rx_avail(glink);\n\t\tif (avail < sizeof(msg))\n\t\t\tbreak;\n\n\t\tqcom_glink_rx_peek(glink, &msg, 0, sizeof(msg));\n\n\t\tcmd = le16_to_cpu(msg.cmd);\n\t\tparam1 = le16_to_cpu(msg.param1);\n\t\tparam2 = le32_to_cpu(msg.param2);\n\n\t\tswitch (cmd) {\n\t\tcase GLINK_CMD_VERSION:\n\t\tcase GLINK_CMD_VERSION_ACK:\n\t\tcase GLINK_CMD_CLOSE:\n\t\tcase GLINK_CMD_CLOSE_ACK:\n\t\tcase GLINK_CMD_RX_INTENT_REQ:\n\t\t\tret = qcom_glink_rx_defer(glink, 0);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_OPEN_ACK:\n\t\t\tret = qcom_glink_rx_open_ack(glink, param1);\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tbreak;\n\t\tcase GLINK_CMD_OPEN:\n\t\t\tret = qcom_glink_rx_defer(glink, param2);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_TX_DATA:\n\t\tcase GLINK_CMD_TX_DATA_CONT:\n\t\t\tret = qcom_glink_rx_data(glink, avail);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_READ_NOTIF:\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tqcom_glink_tx_kick(glink);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_INTENT:\n\t\t\tqcom_glink_handle_intent(glink, param1, param2, avail);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_RX_DONE:\n\t\t\tqcom_glink_handle_rx_done(glink, param1, param2, false);\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tbreak;\n\t\tcase GLINK_CMD_RX_DONE_W_REUSE:\n\t\t\tqcom_glink_handle_rx_done(glink, param1, param2, true);\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tbreak;\n\t\tcase GLINK_CMD_RX_INTENT_REQ_ACK:\n\t\t\tqcom_glink_handle_intent_req_ack(glink, param1, param2);\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tbreak;\n\t\tcase GLINK_CMD_SIGNALS:\n\t\t\tqcom_glink_handle_signals(glink, param1, param2);\n\t\t\tqcom_glink_rx_advance(glink, ALIGN(sizeof(msg), 8));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(glink->dev, \"unhandled rx cmd: %d\\n\", cmd);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL(qcom_glink_native_rx);\n\n \nstatic struct glink_channel *qcom_glink_create_local(struct qcom_glink *glink,\n\t\t\t\t\t\t     const char *name)\n{\n\tstruct glink_channel *channel;\n\tint ret;\n\tunsigned long flags;\n\n\tchannel = qcom_glink_alloc_channel(glink, name);\n\tif (IS_ERR(channel))\n\t\treturn ERR_CAST(channel);\n\n\tret = qcom_glink_send_open_req(glink, channel);\n\tif (ret)\n\t\tgoto release_channel;\n\n\tret = wait_for_completion_timeout(&channel->open_ack, 5 * HZ);\n\tif (!ret)\n\t\tgoto err_timeout;\n\n\tret = wait_for_completion_timeout(&channel->open_req, 5 * HZ);\n\tif (!ret)\n\t\tgoto err_timeout;\n\n\tqcom_glink_send_open_ack(glink, channel);\n\n\treturn channel;\n\nerr_timeout:\n\t \n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_remove(&glink->lcids, channel->lcid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\nrelease_channel:\n\t \n\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\t \n\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\n\treturn ERR_PTR(-ETIMEDOUT);\n}\n\n \nstatic int qcom_glink_create_remote(struct qcom_glink *glink,\n\t\t\t\t    struct glink_channel *channel)\n{\n\tint ret;\n\n\tqcom_glink_send_open_ack(glink, channel);\n\n\tret = qcom_glink_send_open_req(glink, channel);\n\tif (ret)\n\t\tgoto close_link;\n\n\tret = wait_for_completion_timeout(&channel->open_ack, 5 * HZ);\n\tif (!ret) {\n\t\tret = -ETIMEDOUT;\n\t\tgoto close_link;\n\t}\n\n\treturn 0;\n\nclose_link:\n\t \n\tqcom_glink_send_close_req(glink, channel);\n\n\treturn ret;\n}\n\nstatic struct rpmsg_endpoint *qcom_glink_create_ept(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t    rpmsg_rx_cb_t cb,\n\t\t\t\t\t\t    void *priv,\n\t\t\t\t\t\t    struct rpmsg_channel_info\n\t\t\t\t\t\t\t\t\tchinfo)\n{\n\tstruct glink_channel *parent = to_glink_channel(rpdev->ept);\n\tstruct glink_channel *channel;\n\tstruct qcom_glink *glink = parent->glink;\n\tstruct rpmsg_endpoint *ept;\n\tconst char *name = chinfo.name;\n\tint cid;\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_for_each_entry(&glink->rcids, channel, cid) {\n\t\tif (!strcmp(channel->name, name))\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tif (!channel) {\n\t\tchannel = qcom_glink_create_local(glink, name);\n\t\tif (IS_ERR(channel))\n\t\t\treturn NULL;\n\t} else {\n\t\tret = qcom_glink_create_remote(glink, channel);\n\t\tif (ret)\n\t\t\treturn NULL;\n\t}\n\n\tept = &channel->ept;\n\tept->rpdev = rpdev;\n\tept->cb = cb;\n\tept->priv = priv;\n\tept->ops = &glink_endpoint_ops;\n\n\treturn ept;\n}\n\nstatic int qcom_glink_announce_create(struct rpmsg_device *rpdev)\n{\n\tstruct glink_channel *channel = to_glink_channel(rpdev->ept);\n\tstruct device_node *np = rpdev->dev.of_node;\n\tstruct qcom_glink *glink = channel->glink;\n\tstruct glink_core_rx_intent *intent;\n\tconst struct property *prop = NULL;\n\t__be32 defaults[] = { cpu_to_be32(SZ_1K), cpu_to_be32(5) };\n\tint num_intents;\n\tint num_groups = 1;\n\t__be32 *val = defaults;\n\tint size;\n\n\tif (glink->intentless || !completion_done(&channel->open_ack))\n\t\treturn 0;\n\n\tprop = of_find_property(np, \"qcom,intents\", NULL);\n\tif (prop) {\n\t\tval = prop->value;\n\t\tnum_groups = prop->length / sizeof(u32) / 2;\n\t}\n\n\t \n\twhile (num_groups--) {\n\t\tsize = be32_to_cpup(val++);\n\t\tnum_intents = be32_to_cpup(val++);\n\t\twhile (num_intents--) {\n\t\t\tintent = qcom_glink_alloc_intent(glink, channel, size,\n\t\t\t\t\t\t\t true);\n\t\t\tif (!intent)\n\t\t\t\tbreak;\n\n\t\t\tqcom_glink_advertise_intent(glink, channel, intent);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void qcom_glink_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\tstruct qcom_glink *glink = channel->glink;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->recv_lock, flags);\n\tchannel->ept.cb = NULL;\n\tspin_unlock_irqrestore(&channel->recv_lock, flags);\n\n\t \n\tchannel->rpdev = NULL;\n\n\tqcom_glink_send_close_req(glink, channel);\n}\n\nstatic int qcom_glink_request_intent(struct qcom_glink *glink,\n\t\t\t\t     struct glink_channel *channel,\n\t\t\t\t     size_t size)\n{\n\tstruct {\n\t\tu16 id;\n\t\tu16 cid;\n\t\tu32 size;\n\t} __packed cmd;\n\n\tint ret;\n\n\tmutex_lock(&channel->intent_req_lock);\n\n\tWRITE_ONCE(channel->intent_req_result, -1);\n\tWRITE_ONCE(channel->intent_received, false);\n\n\tcmd.id = GLINK_CMD_RX_INTENT_REQ;\n\tcmd.cid = channel->lcid;\n\tcmd.size = size;\n\n\tret = qcom_glink_tx(glink, &cmd, sizeof(cmd), NULL, 0, true);\n\tif (ret)\n\t\tgoto unlock;\n\n\tret = wait_event_timeout(channel->intent_req_wq,\n\t\t\t\t READ_ONCE(channel->intent_req_result) >= 0 &&\n\t\t\t\t READ_ONCE(channel->intent_received),\n\t\t\t\t 10 * HZ);\n\tif (!ret) {\n\t\tdev_err(glink->dev, \"intent request timed out\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else {\n\t\tret = READ_ONCE(channel->intent_req_result) ? 0 : -ECANCELED;\n\t}\n\nunlock:\n\tmutex_unlock(&channel->intent_req_lock);\n\treturn ret;\n}\n\nstatic int __qcom_glink_send(struct glink_channel *channel,\n\t\t\t     void *data, int len, bool wait)\n{\n\tstruct qcom_glink *glink = channel->glink;\n\tstruct glink_core_rx_intent *intent = NULL;\n\tstruct glink_core_rx_intent *tmp;\n\tint iid = 0;\n\tstruct {\n\t\tstruct glink_msg msg;\n\t\t__le32 chunk_size;\n\t\t__le32 left_size;\n\t} __packed req;\n\tint ret;\n\tunsigned long flags;\n\tint chunk_size = len;\n\tsize_t offset = 0;\n\n\tif (!glink->intentless) {\n\t\twhile (!intent) {\n\t\t\tspin_lock_irqsave(&channel->intent_lock, flags);\n\t\t\tidr_for_each_entry(&channel->riids, tmp, iid) {\n\t\t\t\tif (tmp->size >= len && !tmp->in_use) {\n\t\t\t\t\tif (!intent)\n\t\t\t\t\t\tintent = tmp;\n\t\t\t\t\telse if (intent->size > tmp->size)\n\t\t\t\t\t\tintent = tmp;\n\t\t\t\t\tif (intent->size == len)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (intent)\n\t\t\t\tintent->in_use = true;\n\t\t\tspin_unlock_irqrestore(&channel->intent_lock, flags);\n\n\t\t\t \n\t\t\tif (intent)\n\t\t\t\tbreak;\n\n\t\t\tif (!wait)\n\t\t\t\treturn -EBUSY;\n\n\t\t\tret = qcom_glink_request_intent(glink, channel, len);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\n\t\tiid = intent->id;\n\t}\n\n\twhile (offset < len) {\n\t\tchunk_size = len - offset;\n\t\tif (chunk_size > SZ_8K && wait)\n\t\t\tchunk_size = SZ_8K;\n\n\t\treq.msg.cmd = cpu_to_le16(offset == 0 ? GLINK_CMD_TX_DATA : GLINK_CMD_TX_DATA_CONT);\n\t\treq.msg.param1 = cpu_to_le16(channel->lcid);\n\t\treq.msg.param2 = cpu_to_le32(iid);\n\t\treq.chunk_size = cpu_to_le32(chunk_size);\n\t\treq.left_size = cpu_to_le32(len - offset - chunk_size);\n\n\t\tret = qcom_glink_tx(glink, &req, sizeof(req), data + offset, chunk_size, wait);\n\t\tif (ret) {\n\t\t\t \n\t\t\tif (intent)\n\t\t\t\tintent->in_use = false;\n\t\t\treturn ret;\n\t\t}\n\n\t\toffset += chunk_size;\n\t}\n\n\treturn 0;\n}\n\nstatic int qcom_glink_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\n\treturn __qcom_glink_send(channel, data, len, true);\n}\n\nstatic int qcom_glink_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\n\treturn __qcom_glink_send(channel, data, len, false);\n}\n\nstatic int qcom_glink_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\n\treturn __qcom_glink_send(channel, data, len, true);\n}\n\nstatic int qcom_glink_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tstruct glink_channel *channel = to_glink_channel(ept);\n\n\treturn __qcom_glink_send(channel, data, len, false);\n}\n\n \nstatic struct device_node *qcom_glink_match_channel(struct device_node *node,\n\t\t\t\t\t\t    const char *channel)\n{\n\tstruct device_node *child;\n\tconst char *name;\n\tconst char *key;\n\tint ret;\n\n\tfor_each_available_child_of_node(node, child) {\n\t\tkey = \"qcom,glink-channels\";\n\t\tret = of_property_read_string(child, key, &name);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, channel) == 0)\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\nstatic const struct rpmsg_device_ops glink_device_ops = {\n\t.create_ept = qcom_glink_create_ept,\n\t.announce_create = qcom_glink_announce_create,\n};\n\nstatic const struct rpmsg_endpoint_ops glink_endpoint_ops = {\n\t.destroy_ept = qcom_glink_destroy_ept,\n\t.send = qcom_glink_send,\n\t.sendto = qcom_glink_sendto,\n\t.trysend = qcom_glink_trysend,\n\t.trysendto = qcom_glink_trysendto,\n\t.set_flow_control = qcom_glink_set_flow_control,\n};\n\nstatic void qcom_glink_rpdev_release(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\n\tkfree(rpdev->driver_override);\n\tkfree(rpdev);\n}\n\nstatic int qcom_glink_rx_open(struct qcom_glink *glink, unsigned int rcid,\n\t\t\t      char *name)\n{\n\tstruct glink_channel *channel;\n\tstruct rpmsg_device *rpdev;\n\tbool create_device = false;\n\tstruct device_node *node;\n\tint lcid;\n\tint ret;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_for_each_entry(&glink->lcids, channel, lcid) {\n\t\tif (!strcmp(channel->name, name))\n\t\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tif (!channel) {\n\t\tchannel = qcom_glink_alloc_channel(glink, name);\n\t\tif (IS_ERR(channel))\n\t\t\treturn PTR_ERR(channel);\n\n\t\t \n\t\tcreate_device = true;\n\t}\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tret = idr_alloc(&glink->rcids, channel, rcid, rcid + 1, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tdev_err(glink->dev, \"Unable to insert channel into rcid list\\n\");\n\t\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\t\tgoto free_channel;\n\t}\n\tchannel->rcid = ret;\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tcomplete_all(&channel->open_req);\n\n\tif (create_device) {\n\t\trpdev = kzalloc(sizeof(*rpdev), GFP_KERNEL);\n\t\tif (!rpdev) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto rcid_remove;\n\t\t}\n\n\t\trpdev->ept = &channel->ept;\n\t\tstrscpy_pad(rpdev->id.name, name, RPMSG_NAME_SIZE);\n\t\trpdev->src = RPMSG_ADDR_ANY;\n\t\trpdev->dst = RPMSG_ADDR_ANY;\n\t\trpdev->ops = &glink_device_ops;\n\n\t\tnode = qcom_glink_match_channel(glink->dev->of_node, name);\n\t\trpdev->dev.of_node = node;\n\t\trpdev->dev.parent = glink->dev;\n\t\trpdev->dev.release = qcom_glink_rpdev_release;\n\n\t\tret = rpmsg_register_device(rpdev);\n\t\tif (ret)\n\t\t\tgoto rcid_remove;\n\n\t\tchannel->rpdev = rpdev;\n\t}\n\n\treturn 0;\n\nrcid_remove:\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_remove(&glink->rcids, channel->rcid);\n\tchannel->rcid = 0;\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\nfree_channel:\n\t \n\tif (create_device)\n\t\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\n\treturn ret;\n}\n\nstatic void qcom_glink_rx_close(struct qcom_glink *glink, unsigned int rcid)\n{\n\tstruct rpmsg_channel_info chinfo;\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->rcids, rcid);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\tif (WARN(!channel, \"close request on unknown channel\\n\"))\n\t\treturn;\n\n\t \n\tcancel_work_sync(&channel->intent_work);\n\n\tif (channel->rpdev) {\n\t\tstrscpy_pad(chinfo.name, channel->name, sizeof(chinfo.name));\n\t\tchinfo.src = RPMSG_ADDR_ANY;\n\t\tchinfo.dst = RPMSG_ADDR_ANY;\n\n\t\trpmsg_unregister_device(glink->dev, &chinfo);\n\t}\n\tchannel->rpdev = NULL;\n\n\tqcom_glink_send_close_ack(glink, channel->rcid);\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_remove(&glink->rcids, channel->rcid);\n\tchannel->rcid = 0;\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tkref_put(&channel->refcount, qcom_glink_channel_release);\n}\n\nstatic void qcom_glink_rx_close_ack(struct qcom_glink *glink, unsigned int lcid)\n{\n\tstruct rpmsg_channel_info chinfo;\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\n\t \n\twake_up_all(&glink->tx_avail_notify);\n\n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tchannel = idr_find(&glink->lcids, lcid);\n\tif (WARN(!channel, \"close ack on unknown channel\\n\")) {\n\t\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\t\treturn;\n\t}\n\n\tidr_remove(&glink->lcids, channel->lcid);\n\tchannel->lcid = 0;\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\t \n\tif (channel->rpdev) {\n\t\tstrscpy(chinfo.name, channel->name, sizeof(chinfo.name));\n\t\tchinfo.src = RPMSG_ADDR_ANY;\n\t\tchinfo.dst = RPMSG_ADDR_ANY;\n\n\t\trpmsg_unregister_device(glink->dev, &chinfo);\n\t}\n\tchannel->rpdev = NULL;\n\n\tkref_put(&channel->refcount, qcom_glink_channel_release);\n}\n\nstatic void qcom_glink_work(struct work_struct *work)\n{\n\tstruct qcom_glink *glink = container_of(work, struct qcom_glink,\n\t\t\t\t\t\trx_work);\n\tstruct glink_defer_cmd *dcmd;\n\tstruct glink_msg *msg;\n\tunsigned long flags;\n\tunsigned int param1;\n\tunsigned int param2;\n\tunsigned int cmd;\n\n\tfor (;;) {\n\t\tspin_lock_irqsave(&glink->rx_lock, flags);\n\t\tif (list_empty(&glink->rx_queue)) {\n\t\t\tspin_unlock_irqrestore(&glink->rx_lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\tdcmd = list_first_entry(&glink->rx_queue,\n\t\t\t\t\tstruct glink_defer_cmd, node);\n\t\tlist_del(&dcmd->node);\n\t\tspin_unlock_irqrestore(&glink->rx_lock, flags);\n\n\t\tmsg = &dcmd->msg;\n\t\tcmd = le16_to_cpu(msg->cmd);\n\t\tparam1 = le16_to_cpu(msg->param1);\n\t\tparam2 = le32_to_cpu(msg->param2);\n\n\t\tswitch (cmd) {\n\t\tcase GLINK_CMD_VERSION:\n\t\t\tqcom_glink_receive_version(glink, param1, param2);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_VERSION_ACK:\n\t\t\tqcom_glink_receive_version_ack(glink, param1, param2);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_OPEN:\n\t\t\tqcom_glink_rx_open(glink, param1, msg->data);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_CLOSE:\n\t\t\tqcom_glink_rx_close(glink, param1);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_CLOSE_ACK:\n\t\t\tqcom_glink_rx_close_ack(glink, param1);\n\t\t\tbreak;\n\t\tcase GLINK_CMD_RX_INTENT_REQ:\n\t\t\tqcom_glink_handle_intent_req(glink, param1, param2);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"Unknown defer object %d\\n\", cmd);\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree(dcmd);\n\t}\n}\n\nstatic void qcom_glink_cancel_rx_work(struct qcom_glink *glink)\n{\n\tstruct glink_defer_cmd *dcmd;\n\tstruct glink_defer_cmd *tmp;\n\n\t \n\tcancel_work_sync(&glink->rx_work);\n\n\tlist_for_each_entry_safe(dcmd, tmp, &glink->rx_queue, node)\n\t\tkfree(dcmd);\n}\n\nstatic ssize_t rpmsg_name_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tint ret = 0;\n\tconst char *name;\n\n\tret = of_property_read_string(dev->of_node, \"label\", &name);\n\tif (ret < 0)\n\t\tname = dev->of_node->name;\n\n\treturn sysfs_emit(buf, \"%s\\n\", name);\n}\nstatic DEVICE_ATTR_RO(rpmsg_name);\n\nstatic struct attribute *qcom_glink_attrs[] = {\n\t&dev_attr_rpmsg_name.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(qcom_glink);\n\nstatic void qcom_glink_device_release(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct glink_channel *channel = to_glink_channel(rpdev->ept);\n\n\t \n\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\tkfree(rpdev->driver_override);\n\tkfree(rpdev);\n}\n\nstatic int qcom_glink_create_chrdev(struct qcom_glink *glink)\n{\n\tstruct rpmsg_device *rpdev;\n\tstruct glink_channel *channel;\n\n\trpdev = kzalloc(sizeof(*rpdev), GFP_KERNEL);\n\tif (!rpdev)\n\t\treturn -ENOMEM;\n\n\tchannel = qcom_glink_alloc_channel(glink, \"rpmsg_chrdev\");\n\tif (IS_ERR(channel)) {\n\t\tkfree(rpdev);\n\t\treturn PTR_ERR(channel);\n\t}\n\tchannel->rpdev = rpdev;\n\n\trpdev->ept = &channel->ept;\n\trpdev->ops = &glink_device_ops;\n\trpdev->dev.parent = glink->dev;\n\trpdev->dev.release = qcom_glink_device_release;\n\n\treturn rpmsg_ctrldev_register_device(rpdev);\n}\n\nstruct qcom_glink *qcom_glink_native_probe(struct device *dev,\n\t\t\t\t\t   unsigned long features,\n\t\t\t\t\t   struct qcom_glink_pipe *rx,\n\t\t\t\t\t   struct qcom_glink_pipe *tx,\n\t\t\t\t\t   bool intentless)\n{\n\tint ret;\n\tstruct qcom_glink *glink;\n\n\tglink = devm_kzalloc(dev, sizeof(*glink), GFP_KERNEL);\n\tif (!glink)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tglink->dev = dev;\n\tglink->tx_pipe = tx;\n\tglink->rx_pipe = rx;\n\n\tglink->features = features;\n\tglink->intentless = intentless;\n\n\tspin_lock_init(&glink->tx_lock);\n\tspin_lock_init(&glink->rx_lock);\n\tINIT_LIST_HEAD(&glink->rx_queue);\n\tINIT_WORK(&glink->rx_work, qcom_glink_work);\n\tinit_waitqueue_head(&glink->tx_avail_notify);\n\n\tspin_lock_init(&glink->idr_lock);\n\tidr_init(&glink->lcids);\n\tidr_init(&glink->rcids);\n\n\tglink->dev->groups = qcom_glink_groups;\n\n\tret = device_add_groups(dev, qcom_glink_groups);\n\tif (ret)\n\t\tdev_err(dev, \"failed to add groups\\n\");\n\n\tret = qcom_glink_send_version(glink);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tret = qcom_glink_create_chrdev(glink);\n\tif (ret)\n\t\tdev_err(glink->dev, \"failed to register chrdev\\n\");\n\n\treturn glink;\n}\nEXPORT_SYMBOL_GPL(qcom_glink_native_probe);\n\nstatic int qcom_glink_remove_device(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nvoid qcom_glink_native_remove(struct qcom_glink *glink)\n{\n\tstruct glink_channel *channel;\n\tunsigned long flags;\n\tint cid;\n\tint ret;\n\n\tqcom_glink_cancel_rx_work(glink);\n\n\t \n\tspin_lock_irqsave(&glink->tx_lock, flags);\n\tglink->abort_tx = true;\n\twake_up_all(&glink->tx_avail_notify);\n\tspin_unlock_irqrestore(&glink->tx_lock, flags);\n\n\t \n\tspin_lock_irqsave(&glink->idr_lock, flags);\n\tidr_for_each_entry(&glink->lcids, channel, cid)\n\t\tqcom_glink_intent_req_abort(channel);\n\tspin_unlock_irqrestore(&glink->idr_lock, flags);\n\n\tret = device_for_each_child(glink->dev, NULL, qcom_glink_remove_device);\n\tif (ret)\n\t\tdev_warn(glink->dev, \"Can't remove GLINK devices: %d\\n\", ret);\n\n\t \n\tidr_for_each_entry(&glink->lcids, channel, cid)\n\t\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\n\t \n\tidr_for_each_entry(&glink->rcids, channel, cid)\n\t\tkref_put(&channel->refcount, qcom_glink_channel_release);\n\n\tidr_destroy(&glink->lcids);\n\tidr_destroy(&glink->rcids);\n}\nEXPORT_SYMBOL_GPL(qcom_glink_native_remove);\n\nMODULE_DESCRIPTION(\"Qualcomm GLINK driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}