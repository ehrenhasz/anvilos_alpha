{
  "module_name": "qcom_smd.c",
  "hash_id": "ca1cfde58c6e9784193dc6de24d82ab140d55325425966927c8f9558d2a13d7d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/qcom_smd.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/mailbox_client.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of_irq.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/sched.h>\n#include <linux/sizes.h>\n#include <linux/slab.h>\n#include <linux/soc/qcom/smem.h>\n#include <linux/wait.h>\n#include <linux/rpmsg.h>\n#include <linux/rpmsg/qcom_smd.h>\n\n#include \"rpmsg_internal.h\"\n\n \n\nstruct smd_channel_info;\nstruct smd_channel_info_pair;\nstruct smd_channel_info_word;\nstruct smd_channel_info_word_pair;\n\nstatic const struct rpmsg_endpoint_ops qcom_smd_endpoint_ops;\n\n#define SMD_ALLOC_TBL_COUNT\t2\n#define SMD_ALLOC_TBL_SIZE\t64\n\n \nstatic const struct {\n\tunsigned alloc_tbl_id;\n\tunsigned info_base_id;\n\tunsigned fifo_base_id;\n} smem_items[SMD_ALLOC_TBL_COUNT] = {\n\t{\n\t\t.alloc_tbl_id = 13,\n\t\t.info_base_id = 14,\n\t\t.fifo_base_id = 338\n\t},\n\t{\n\t\t.alloc_tbl_id = 266,\n\t\t.info_base_id = 138,\n\t\t.fifo_base_id = 202,\n\t},\n};\n\n \nstruct qcom_smd_edge {\n\tstruct device dev;\n\n\tconst char *name;\n\n\tstruct device_node *of_node;\n\tunsigned edge_id;\n\tunsigned remote_pid;\n\n\tint irq;\n\n\tstruct regmap *ipc_regmap;\n\tint ipc_offset;\n\tint ipc_bit;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tstruct list_head channels;\n\tspinlock_t channels_lock;\n\n\tDECLARE_BITMAP(allocated[SMD_ALLOC_TBL_COUNT], SMD_ALLOC_TBL_SIZE);\n\n\tunsigned smem_available;\n\n\twait_queue_head_t new_channel_event;\n\n\tstruct work_struct scan_work;\n\tstruct work_struct state_work;\n};\n\n \nenum smd_channel_state {\n\tSMD_CHANNEL_CLOSED,\n\tSMD_CHANNEL_OPENING,\n\tSMD_CHANNEL_OPENED,\n\tSMD_CHANNEL_FLUSHING,\n\tSMD_CHANNEL_CLOSING,\n\tSMD_CHANNEL_RESET,\n\tSMD_CHANNEL_RESET_OPENING\n};\n\nstruct qcom_smd_device {\n\tstruct rpmsg_device rpdev;\n\n\tstruct qcom_smd_edge *edge;\n};\n\nstruct qcom_smd_endpoint {\n\tstruct rpmsg_endpoint ept;\n\n\tstruct qcom_smd_channel *qsch;\n};\n\n#define to_smd_device(r)\tcontainer_of(r, struct qcom_smd_device, rpdev)\n#define to_smd_edge(d)\t\tcontainer_of(d, struct qcom_smd_edge, dev)\n#define to_smd_endpoint(e)\tcontainer_of(e, struct qcom_smd_endpoint, ept)\n\n \nstruct qcom_smd_channel {\n\tstruct qcom_smd_edge *edge;\n\n\tstruct qcom_smd_endpoint *qsept;\n\tbool registered;\n\n\tchar *name;\n\tenum smd_channel_state state;\n\tenum smd_channel_state remote_state;\n\twait_queue_head_t state_change_event;\n\n\tstruct smd_channel_info_pair *info;\n\tstruct smd_channel_info_word_pair *info_word;\n\n\tspinlock_t tx_lock;\n\twait_queue_head_t fblockread_event;\n\n\tvoid *tx_fifo;\n\tvoid *rx_fifo;\n\tint fifo_size;\n\n\tvoid *bounce_buffer;\n\n\tspinlock_t recv_lock;\n\n\tint pkt_size;\n\n\tvoid *drvdata;\n\n\tstruct list_head list;\n};\n\n \nstruct smd_channel_info {\n\t__le32 state;\n\tu8  fDSR;\n\tu8  fCTS;\n\tu8  fCD;\n\tu8  fRI;\n\tu8  fHEAD;\n\tu8  fTAIL;\n\tu8  fSTATE;\n\tu8  fBLOCKREADINTR;\n\t__le32 tail;\n\t__le32 head;\n};\n\nstruct smd_channel_info_pair {\n\tstruct smd_channel_info tx;\n\tstruct smd_channel_info rx;\n};\n\n \nstruct smd_channel_info_word {\n\t__le32 state;\n\t__le32 fDSR;\n\t__le32 fCTS;\n\t__le32 fCD;\n\t__le32 fRI;\n\t__le32 fHEAD;\n\t__le32 fTAIL;\n\t__le32 fSTATE;\n\t__le32 fBLOCKREADINTR;\n\t__le32 tail;\n\t__le32 head;\n};\n\nstruct smd_channel_info_word_pair {\n\tstruct smd_channel_info_word tx;\n\tstruct smd_channel_info_word rx;\n};\n\n#define GET_RX_CHANNEL_FLAG(channel, param)\t\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->rx.param) != sizeof(u8)); \\\n\t\tchannel->info_word ?\t\t\t\t\t     \\\n\t\t\tle32_to_cpu(channel->info_word->rx.param) :\t     \\\n\t\t\tchannel->info->rx.param;\t\t\t     \\\n\t})\n\n#define GET_RX_CHANNEL_INFO(channel, param)\t\t\t\t      \\\n\t({\t\t\t\t\t\t\t\t      \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->rx.param) != sizeof(u32)); \\\n\t\tle32_to_cpu(channel->info_word ?\t\t\t      \\\n\t\t\tchannel->info_word->rx.param :\t\t\t      \\\n\t\t\tchannel->info->rx.param);\t\t\t      \\\n\t})\n\n#define SET_RX_CHANNEL_FLAG(channel, param, value)\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->rx.param) != sizeof(u8)); \\\n\t\tif (channel->info_word)\t\t\t\t\t     \\\n\t\t\tchannel->info_word->rx.param = cpu_to_le32(value);   \\\n\t\telse\t\t\t\t\t\t\t     \\\n\t\t\tchannel->info->rx.param = value;\t\t     \\\n\t})\n\n#define SET_RX_CHANNEL_INFO(channel, param, value)\t\t\t      \\\n\t({\t\t\t\t\t\t\t\t      \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->rx.param) != sizeof(u32)); \\\n\t\tif (channel->info_word)\t\t\t\t\t      \\\n\t\t\tchannel->info_word->rx.param = cpu_to_le32(value);    \\\n\t\telse\t\t\t\t\t\t\t      \\\n\t\t\tchannel->info->rx.param = cpu_to_le32(value);\t      \\\n\t})\n\n#define GET_TX_CHANNEL_FLAG(channel, param)\t\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->tx.param) != sizeof(u8)); \\\n\t\tchannel->info_word ?\t\t\t\t\t     \\\n\t\t\tle32_to_cpu(channel->info_word->tx.param) :          \\\n\t\t\tchannel->info->tx.param;\t\t\t     \\\n\t})\n\n#define GET_TX_CHANNEL_INFO(channel, param)\t\t\t\t      \\\n\t({\t\t\t\t\t\t\t\t      \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->tx.param) != sizeof(u32)); \\\n\t\tle32_to_cpu(channel->info_word ?\t\t\t      \\\n\t\t\tchannel->info_word->tx.param :\t\t\t      \\\n\t\t\tchannel->info->tx.param);\t\t\t      \\\n\t})\n\n#define SET_TX_CHANNEL_FLAG(channel, param, value)\t\t\t     \\\n\t({\t\t\t\t\t\t\t\t     \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->tx.param) != sizeof(u8)); \\\n\t\tif (channel->info_word)\t\t\t\t\t     \\\n\t\t\tchannel->info_word->tx.param = cpu_to_le32(value);   \\\n\t\telse\t\t\t\t\t\t\t     \\\n\t\t\tchannel->info->tx.param = value;\t\t     \\\n\t})\n\n#define SET_TX_CHANNEL_INFO(channel, param, value)\t\t\t      \\\n\t({\t\t\t\t\t\t\t\t      \\\n\t\tBUILD_BUG_ON(sizeof(channel->info->tx.param) != sizeof(u32)); \\\n\t\tif (channel->info_word)\t\t\t\t\t      \\\n\t\t\tchannel->info_word->tx.param = cpu_to_le32(value);   \\\n\t\telse\t\t\t\t\t\t\t      \\\n\t\t\tchannel->info->tx.param = cpu_to_le32(value);\t      \\\n\t})\n\n \nstruct qcom_smd_alloc_entry {\n\tu8 name[20];\n\t__le32 cid;\n\t__le32 flags;\n\t__le32 ref_count;\n} __packed;\n\n#define SMD_CHANNEL_FLAGS_EDGE_MASK\t0xff\n#define SMD_CHANNEL_FLAGS_STREAM\tBIT(8)\n#define SMD_CHANNEL_FLAGS_PACKET\tBIT(9)\n\n \n#define SMD_PACKET_HEADER_LEN\t20\n\n \nstatic void qcom_smd_signal_channel(struct qcom_smd_channel *channel)\n{\n\tstruct qcom_smd_edge *edge = channel->edge;\n\n\tif (edge->mbox_chan) {\n\t\t \n\t\tmbox_send_message(edge->mbox_chan, NULL);\n\t\tmbox_client_txdone(edge->mbox_chan, 0);\n\t} else {\n\t\tregmap_write(edge->ipc_regmap, edge->ipc_offset, BIT(edge->ipc_bit));\n\t}\n}\n\n \nstatic void qcom_smd_channel_reset(struct qcom_smd_channel *channel)\n{\n\tSET_TX_CHANNEL_INFO(channel, state, SMD_CHANNEL_CLOSED);\n\tSET_TX_CHANNEL_FLAG(channel, fDSR, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fCTS, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fCD, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fRI, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fHEAD, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fTAIL, 0);\n\tSET_TX_CHANNEL_FLAG(channel, fSTATE, 1);\n\tSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 1);\n\tSET_TX_CHANNEL_INFO(channel, head, 0);\n\tSET_RX_CHANNEL_INFO(channel, tail, 0);\n\n\tqcom_smd_signal_channel(channel);\n\n\tchannel->state = SMD_CHANNEL_CLOSED;\n\tchannel->pkt_size = 0;\n}\n\n \nstatic void qcom_smd_channel_set_callback(struct qcom_smd_channel *channel,\n\t\t\t\t\t  rpmsg_rx_cb_t cb)\n{\n\tstruct rpmsg_endpoint *ept = &channel->qsept->ept;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&channel->recv_lock, flags);\n\tept->cb = cb;\n\tspin_unlock_irqrestore(&channel->recv_lock, flags);\n};\n\n \nstatic size_t qcom_smd_channel_get_rx_avail(struct qcom_smd_channel *channel)\n{\n\tunsigned head;\n\tunsigned tail;\n\n\thead = GET_RX_CHANNEL_INFO(channel, head);\n\ttail = GET_RX_CHANNEL_INFO(channel, tail);\n\n\treturn (head - tail) & (channel->fifo_size - 1);\n}\n\n \nstatic void qcom_smd_channel_set_state(struct qcom_smd_channel *channel,\n\t\t\t\t       int state)\n{\n\tstruct qcom_smd_edge *edge = channel->edge;\n\tbool is_open = state == SMD_CHANNEL_OPENED;\n\n\tif (channel->state == state)\n\t\treturn;\n\n\tdev_dbg(&edge->dev, \"set_state(%s, %d)\\n\", channel->name, state);\n\n\tSET_TX_CHANNEL_FLAG(channel, fDSR, is_open);\n\tSET_TX_CHANNEL_FLAG(channel, fCTS, is_open);\n\tSET_TX_CHANNEL_FLAG(channel, fCD, is_open);\n\n\tSET_TX_CHANNEL_INFO(channel, state, state);\n\tSET_TX_CHANNEL_FLAG(channel, fSTATE, 1);\n\n\tchannel->state = state;\n\tqcom_smd_signal_channel(channel);\n}\n\n \nstatic void smd_copy_to_fifo(void __iomem *dst,\n\t\t\t     const void *src,\n\t\t\t     size_t count,\n\t\t\t     bool word_aligned)\n{\n\tif (word_aligned) {\n\t\t__iowrite32_copy(dst, src, count / sizeof(u32));\n\t} else {\n\t\tmemcpy_toio(dst, src, count);\n\t}\n}\n\n \nstatic void smd_copy_from_fifo(void *dst,\n\t\t\t       const void __iomem *src,\n\t\t\t       size_t count,\n\t\t\t       bool word_aligned)\n{\n\tif (word_aligned) {\n\t\t__ioread32_copy(dst, src, count / sizeof(u32));\n\t} else {\n\t\tmemcpy_fromio(dst, src, count);\n\t}\n}\n\n \nstatic size_t qcom_smd_channel_peek(struct qcom_smd_channel *channel,\n\t\t\t\t    void *buf, size_t count)\n{\n\tbool word_aligned;\n\tunsigned tail;\n\tsize_t len;\n\n\tword_aligned = channel->info_word;\n\ttail = GET_RX_CHANNEL_INFO(channel, tail);\n\n\tlen = min_t(size_t, count, channel->fifo_size - tail);\n\tif (len) {\n\t\tsmd_copy_from_fifo(buf,\n\t\t\t\t   channel->rx_fifo + tail,\n\t\t\t\t   len,\n\t\t\t\t   word_aligned);\n\t}\n\n\tif (len != count) {\n\t\tsmd_copy_from_fifo(buf + len,\n\t\t\t\t   channel->rx_fifo,\n\t\t\t\t   count - len,\n\t\t\t\t   word_aligned);\n\t}\n\n\treturn count;\n}\n\n \nstatic void qcom_smd_channel_advance(struct qcom_smd_channel *channel,\n\t\t\t\t     size_t count)\n{\n\tunsigned tail;\n\n\ttail = GET_RX_CHANNEL_INFO(channel, tail);\n\ttail += count;\n\ttail &= (channel->fifo_size - 1);\n\tSET_RX_CHANNEL_INFO(channel, tail, tail);\n}\n\n \nstatic int qcom_smd_channel_recv_single(struct qcom_smd_channel *channel)\n{\n\tstruct rpmsg_endpoint *ept = &channel->qsept->ept;\n\tunsigned tail;\n\tsize_t len;\n\tvoid *ptr;\n\tint ret;\n\n\ttail = GET_RX_CHANNEL_INFO(channel, tail);\n\n\t \n\tif (tail + channel->pkt_size >= channel->fifo_size) {\n\t\tptr = channel->bounce_buffer;\n\t\tlen = qcom_smd_channel_peek(channel, ptr, channel->pkt_size);\n\t} else {\n\t\tptr = channel->rx_fifo + tail;\n\t\tlen = channel->pkt_size;\n\t}\n\n\tret = ept->cb(ept->rpdev, ptr, len, ept->priv, RPMSG_ADDR_ANY);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tqcom_smd_channel_advance(channel, len);\n\n\tchannel->pkt_size = 0;\n\n\treturn 0;\n}\n\n \nstatic bool qcom_smd_channel_intr(struct qcom_smd_channel *channel)\n{\n\tbool need_state_scan = false;\n\tint remote_state;\n\t__le32 pktlen;\n\tint avail;\n\tint ret;\n\n\t \n\tremote_state = GET_RX_CHANNEL_INFO(channel, state);\n\tif (remote_state != channel->remote_state) {\n\t\tchannel->remote_state = remote_state;\n\t\tneed_state_scan = true;\n\n\t\twake_up_interruptible_all(&channel->state_change_event);\n\t}\n\t \n\tSET_RX_CHANNEL_FLAG(channel, fSTATE, 0);\n\n\t \n\tif (!GET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR))\n\t\twake_up_interruptible_all(&channel->fblockread_event);\n\n\t \n\tif (channel->state != SMD_CHANNEL_OPENED)\n\t\tgoto out;\n\n\t \n\tSET_RX_CHANNEL_FLAG(channel, fHEAD, 0);\n\n\t \n\tfor (;;) {\n\t\tavail = qcom_smd_channel_get_rx_avail(channel);\n\n\t\tif (!channel->pkt_size && avail >= SMD_PACKET_HEADER_LEN) {\n\t\t\tqcom_smd_channel_peek(channel, &pktlen, sizeof(pktlen));\n\t\t\tqcom_smd_channel_advance(channel, SMD_PACKET_HEADER_LEN);\n\t\t\tchannel->pkt_size = le32_to_cpu(pktlen);\n\t\t} else if (channel->pkt_size && avail >= channel->pkt_size) {\n\t\t\tret = qcom_smd_channel_recv_single(channel);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tSET_RX_CHANNEL_FLAG(channel, fTAIL, 1);\n\n\t \n\tif (!GET_RX_CHANNEL_FLAG(channel, fBLOCKREADINTR)) {\n\t\t \n\t\twmb();\n\n\t\tqcom_smd_signal_channel(channel);\n\t}\n\nout:\n\treturn need_state_scan;\n}\n\n \nstatic irqreturn_t qcom_smd_edge_intr(int irq, void *data)\n{\n\tstruct qcom_smd_edge *edge = data;\n\tstruct qcom_smd_channel *channel;\n\tunsigned available;\n\tbool kick_scanner = false;\n\tbool kick_state = false;\n\n\t \n\tspin_lock(&edge->channels_lock);\n\tlist_for_each_entry(channel, &edge->channels, list) {\n\t\tspin_lock(&channel->recv_lock);\n\t\tkick_state |= qcom_smd_channel_intr(channel);\n\t\tspin_unlock(&channel->recv_lock);\n\t}\n\tspin_unlock(&edge->channels_lock);\n\n\t \n\tavailable = qcom_smem_get_free_space(edge->remote_pid);\n\tif (available != edge->smem_available) {\n\t\tedge->smem_available = available;\n\t\tkick_scanner = true;\n\t}\n\n\tif (kick_scanner)\n\t\tschedule_work(&edge->scan_work);\n\tif (kick_state)\n\t\tschedule_work(&edge->state_work);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic size_t qcom_smd_get_tx_avail(struct qcom_smd_channel *channel)\n{\n\tunsigned head;\n\tunsigned tail;\n\tunsigned mask = channel->fifo_size - 1;\n\n\thead = GET_TX_CHANNEL_INFO(channel, head);\n\ttail = GET_TX_CHANNEL_INFO(channel, tail);\n\n\treturn mask - ((head - tail) & mask);\n}\n\n \nstatic int qcom_smd_write_fifo(struct qcom_smd_channel *channel,\n\t\t\t       const void *data,\n\t\t\t       size_t count)\n{\n\tbool word_aligned;\n\tunsigned head;\n\tsize_t len;\n\n\tword_aligned = channel->info_word;\n\thead = GET_TX_CHANNEL_INFO(channel, head);\n\n\tlen = min_t(size_t, count, channel->fifo_size - head);\n\tif (len) {\n\t\tsmd_copy_to_fifo(channel->tx_fifo + head,\n\t\t\t\t data,\n\t\t\t\t len,\n\t\t\t\t word_aligned);\n\t}\n\n\tif (len != count) {\n\t\tsmd_copy_to_fifo(channel->tx_fifo,\n\t\t\t\t data + len,\n\t\t\t\t count - len,\n\t\t\t\t word_aligned);\n\t}\n\n\thead += count;\n\thead &= (channel->fifo_size - 1);\n\tSET_TX_CHANNEL_INFO(channel, head, head);\n\n\treturn count;\n}\n\n \nstatic int __qcom_smd_send(struct qcom_smd_channel *channel, const void *data,\n\t\t\t   int len, bool wait)\n{\n\t__le32 hdr[5] = { cpu_to_le32(len), };\n\tint tlen = sizeof(hdr) + len;\n\tunsigned long flags;\n\tint ret;\n\n\t \n\tif (channel->info_word && len % 4)\n\t\treturn -EINVAL;\n\n\t \n\tif (tlen >= channel->fifo_size)\n\t\treturn -EINVAL;\n\n\t \n\tif (wait)\n\t\tmight_sleep();\n\n\tspin_lock_irqsave(&channel->tx_lock, flags);\n\n\twhile (qcom_smd_get_tx_avail(channel) < tlen &&\n\t       channel->state == SMD_CHANNEL_OPENED) {\n\t\tif (!wait) {\n\t\t\tret = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 0);\n\n\t\t \n\t\tspin_unlock_irqrestore(&channel->tx_lock, flags);\n\n\t\tret = wait_event_interruptible(channel->fblockread_event,\n\t\t\t\t       qcom_smd_get_tx_avail(channel) >= tlen ||\n\t\t\t\t       channel->state != SMD_CHANNEL_OPENED);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tspin_lock_irqsave(&channel->tx_lock, flags);\n\n\t\tSET_TX_CHANNEL_FLAG(channel, fBLOCKREADINTR, 1);\n\t}\n\n\t \n\tif (channel->state != SMD_CHANNEL_OPENED) {\n\t\tret = -EPIPE;\n\t\tgoto out_unlock;\n\t}\n\n\tSET_TX_CHANNEL_FLAG(channel, fTAIL, 0);\n\n\tqcom_smd_write_fifo(channel, hdr, sizeof(hdr));\n\tqcom_smd_write_fifo(channel, data, len);\n\n\tSET_TX_CHANNEL_FLAG(channel, fHEAD, 1);\n\n\t \n\twmb();\n\n\tqcom_smd_signal_channel(channel);\n\nout_unlock:\n\tspin_unlock_irqrestore(&channel->tx_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int qcom_smd_channel_open(struct qcom_smd_channel *channel,\n\t\t\t\t rpmsg_rx_cb_t cb)\n{\n\tstruct qcom_smd_edge *edge = channel->edge;\n\tsize_t bb_size;\n\tint ret;\n\n\t \n\tbb_size = min(channel->fifo_size, SZ_4K);\n\tchannel->bounce_buffer = kmalloc(bb_size, GFP_KERNEL);\n\tif (!channel->bounce_buffer)\n\t\treturn -ENOMEM;\n\n\tqcom_smd_channel_set_callback(channel, cb);\n\tqcom_smd_channel_set_state(channel, SMD_CHANNEL_OPENING);\n\n\t \n\tret = wait_event_interruptible_timeout(channel->state_change_event,\n\t\t\tchannel->remote_state == SMD_CHANNEL_OPENING ||\n\t\t\tchannel->remote_state == SMD_CHANNEL_OPENED,\n\t\t\tHZ);\n\tif (!ret) {\n\t\tdev_err(&edge->dev, \"remote side did not enter opening state\\n\");\n\t\tgoto out_close_timeout;\n\t}\n\n\tqcom_smd_channel_set_state(channel, SMD_CHANNEL_OPENED);\n\n\t \n\tret = wait_event_interruptible_timeout(channel->state_change_event,\n\t\t\tchannel->remote_state == SMD_CHANNEL_OPENED,\n\t\t\tHZ);\n\tif (!ret) {\n\t\tdev_err(&edge->dev, \"remote side did not enter open state\\n\");\n\t\tgoto out_close_timeout;\n\t}\n\n\treturn 0;\n\nout_close_timeout:\n\tqcom_smd_channel_set_state(channel, SMD_CHANNEL_CLOSED);\n\treturn -ETIMEDOUT;\n}\n\n \nstatic void qcom_smd_channel_close(struct qcom_smd_channel *channel)\n{\n\tqcom_smd_channel_set_callback(channel, NULL);\n\n\tkfree(channel->bounce_buffer);\n\tchannel->bounce_buffer = NULL;\n\n\tqcom_smd_channel_set_state(channel, SMD_CHANNEL_CLOSED);\n\tqcom_smd_channel_reset(channel);\n}\n\nstatic struct qcom_smd_channel *\nqcom_smd_find_channel(struct qcom_smd_edge *edge, const char *name)\n{\n\tstruct qcom_smd_channel *channel;\n\tstruct qcom_smd_channel *ret = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge->channels_lock, flags);\n\tlist_for_each_entry(channel, &edge->channels, list) {\n\t\tif (!strcmp(channel->name, name)) {\n\t\t\tret = channel;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&edge->channels_lock, flags);\n\n\treturn ret;\n}\n\nstatic void __ept_release(struct kref *kref)\n{\n\tstruct rpmsg_endpoint *ept = container_of(kref, struct rpmsg_endpoint,\n\t\t\t\t\t\t  refcount);\n\tkfree(to_smd_endpoint(ept));\n}\n\nstatic struct rpmsg_endpoint *qcom_smd_create_ept(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t  rpmsg_rx_cb_t cb, void *priv,\n\t\t\t\t\t\t  struct rpmsg_channel_info chinfo)\n{\n\tstruct qcom_smd_endpoint *qsept;\n\tstruct qcom_smd_channel *channel;\n\tstruct qcom_smd_device *qsdev = to_smd_device(rpdev);\n\tstruct qcom_smd_edge *edge = qsdev->edge;\n\tstruct rpmsg_endpoint *ept;\n\tconst char *name = chinfo.name;\n\tint ret;\n\n\t \n\tret = wait_event_interruptible_timeout(edge->new_channel_event,\n\t\t\t(channel = qcom_smd_find_channel(edge, name)) != NULL,\n\t\t\tHZ);\n\tif (!ret)\n\t\treturn NULL;\n\n\tif (channel->state != SMD_CHANNEL_CLOSED) {\n\t\tdev_err(&rpdev->dev, \"channel %s is busy\\n\", channel->name);\n\t\treturn NULL;\n\t}\n\n\tqsept = kzalloc(sizeof(*qsept), GFP_KERNEL);\n\tif (!qsept)\n\t\treturn NULL;\n\n\tept = &qsept->ept;\n\n\tkref_init(&ept->refcount);\n\n\tept->rpdev = rpdev;\n\tept->cb = cb;\n\tept->priv = priv;\n\tept->ops = &qcom_smd_endpoint_ops;\n\n\tchannel->qsept = qsept;\n\tqsept->qsch = channel;\n\n\tret = qcom_smd_channel_open(channel, cb);\n\tif (ret)\n\t\tgoto free_ept;\n\n\treturn ept;\n\nfree_ept:\n\tchannel->qsept = NULL;\n\tkref_put(&ept->refcount, __ept_release);\n\treturn NULL;\n}\n\nstatic void qcom_smd_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\tstruct qcom_smd_channel *ch = qsept->qsch;\n\n\tqcom_smd_channel_close(ch);\n\tch->qsept = NULL;\n\tkref_put(&ept->refcount, __ept_release);\n}\n\nstatic int qcom_smd_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\n\treturn __qcom_smd_send(qsept->qsch, data, len, true);\n}\n\nstatic int qcom_smd_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\n\treturn __qcom_smd_send(qsept->qsch, data, len, false);\n}\n\nstatic int qcom_smd_sendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\n\treturn __qcom_smd_send(qsept->qsch, data, len, true);\n}\n\nstatic int qcom_smd_trysendto(struct rpmsg_endpoint *ept, void *data, int len, u32 dst)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\n\treturn __qcom_smd_send(qsept->qsch, data, len, false);\n}\n\nstatic __poll_t qcom_smd_poll(struct rpmsg_endpoint *ept,\n\t\t\t\t  struct file *filp, poll_table *wait)\n{\n\tstruct qcom_smd_endpoint *qsept = to_smd_endpoint(ept);\n\tstruct qcom_smd_channel *channel = qsept->qsch;\n\t__poll_t mask = 0;\n\n\tpoll_wait(filp, &channel->fblockread_event, wait);\n\n\tif (qcom_smd_get_tx_avail(channel) > 20)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn mask;\n}\n\n \nstatic struct device_node *qcom_smd_match_channel(struct device_node *edge_node,\n\t\t\t\t\t\t  const char *channel)\n{\n\tstruct device_node *child;\n\tconst char *name;\n\tconst char *key;\n\tint ret;\n\n\tfor_each_available_child_of_node(edge_node, child) {\n\t\tkey = \"qcom,smd-channels\";\n\t\tret = of_property_read_string(child, key, &name);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, channel) == 0)\n\t\t\treturn child;\n\t}\n\n\treturn NULL;\n}\n\nstatic int qcom_smd_announce_create(struct rpmsg_device *rpdev)\n{\n\tstruct qcom_smd_endpoint *qept = to_smd_endpoint(rpdev->ept);\n\tstruct qcom_smd_channel *channel = qept->qsch;\n\tunsigned long flags;\n\tbool kick_state;\n\n\tspin_lock_irqsave(&channel->recv_lock, flags);\n\tkick_state = qcom_smd_channel_intr(channel);\n\tspin_unlock_irqrestore(&channel->recv_lock, flags);\n\n\tif (kick_state)\n\t\tschedule_work(&channel->edge->state_work);\n\n\treturn 0;\n}\n\nstatic const struct rpmsg_device_ops qcom_smd_device_ops = {\n\t.create_ept = qcom_smd_create_ept,\n\t.announce_create = qcom_smd_announce_create,\n};\n\nstatic const struct rpmsg_endpoint_ops qcom_smd_endpoint_ops = {\n\t.destroy_ept = qcom_smd_destroy_ept,\n\t.send = qcom_smd_send,\n\t.sendto = qcom_smd_sendto,\n\t.trysend = qcom_smd_trysend,\n\t.trysendto = qcom_smd_trysendto,\n\t.poll = qcom_smd_poll,\n};\n\nstatic void qcom_smd_release_device(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct qcom_smd_device *qsdev = to_smd_device(rpdev);\n\n\tkfree(qsdev);\n}\n\n \nstatic int qcom_smd_create_device(struct qcom_smd_channel *channel)\n{\n\tstruct qcom_smd_device *qsdev;\n\tstruct rpmsg_device *rpdev;\n\tstruct qcom_smd_edge *edge = channel->edge;\n\n\tdev_dbg(&edge->dev, \"registering '%s'\\n\", channel->name);\n\n\tqsdev = kzalloc(sizeof(*qsdev), GFP_KERNEL);\n\tif (!qsdev)\n\t\treturn -ENOMEM;\n\n\t \n\tqsdev->edge = edge;\n\n\t \n\tqsdev->rpdev.ops = &qcom_smd_device_ops;\n\n\t \n\trpdev = &qsdev->rpdev;\n\tstrscpy_pad(rpdev->id.name, channel->name, RPMSG_NAME_SIZE);\n\trpdev->src = RPMSG_ADDR_ANY;\n\trpdev->dst = RPMSG_ADDR_ANY;\n\n\trpdev->dev.of_node = qcom_smd_match_channel(edge->of_node, channel->name);\n\trpdev->dev.parent = &edge->dev;\n\trpdev->dev.release = qcom_smd_release_device;\n\n\treturn rpmsg_register_device(rpdev);\n}\n\nstatic int qcom_smd_create_chrdev(struct qcom_smd_edge *edge)\n{\n\tstruct qcom_smd_device *qsdev;\n\n\tqsdev = kzalloc(sizeof(*qsdev), GFP_KERNEL);\n\tif (!qsdev)\n\t\treturn -ENOMEM;\n\n\tqsdev->edge = edge;\n\tqsdev->rpdev.ops = &qcom_smd_device_ops;\n\tqsdev->rpdev.dev.parent = &edge->dev;\n\tqsdev->rpdev.dev.release = qcom_smd_release_device;\n\n\treturn rpmsg_ctrldev_register_device(&qsdev->rpdev);\n}\n\n \nstatic struct qcom_smd_channel *qcom_smd_create_channel(struct qcom_smd_edge *edge,\n\t\t\t\t\t\t\tunsigned smem_info_item,\n\t\t\t\t\t\t\tunsigned smem_fifo_item,\n\t\t\t\t\t\t\tchar *name)\n{\n\tstruct qcom_smd_channel *channel;\n\tsize_t fifo_size;\n\tsize_t info_size;\n\tvoid *fifo_base;\n\tvoid *info;\n\tint ret;\n\n\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\tif (!channel)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tchannel->edge = edge;\n\tchannel->name = kstrdup(name, GFP_KERNEL);\n\tif (!channel->name) {\n\t\tret = -ENOMEM;\n\t\tgoto free_channel;\n\t}\n\n\tspin_lock_init(&channel->tx_lock);\n\tspin_lock_init(&channel->recv_lock);\n\tinit_waitqueue_head(&channel->fblockread_event);\n\tinit_waitqueue_head(&channel->state_change_event);\n\n\tinfo = qcom_smem_get(edge->remote_pid, smem_info_item, &info_size);\n\tif (IS_ERR(info)) {\n\t\tret = PTR_ERR(info);\n\t\tgoto free_name_and_channel;\n\t}\n\n\t \n\tif (info_size == 2 * sizeof(struct smd_channel_info_word)) {\n\t\tchannel->info_word = info;\n\t} else if (info_size == 2 * sizeof(struct smd_channel_info)) {\n\t\tchannel->info = info;\n\t} else {\n\t\tdev_err(&edge->dev,\n\t\t\t\"channel info of size %zu not supported\\n\", info_size);\n\t\tret = -EINVAL;\n\t\tgoto free_name_and_channel;\n\t}\n\n\tfifo_base = qcom_smem_get(edge->remote_pid, smem_fifo_item, &fifo_size);\n\tif (IS_ERR(fifo_base)) {\n\t\tret =  PTR_ERR(fifo_base);\n\t\tgoto free_name_and_channel;\n\t}\n\n\t \n\tfifo_size /= 2;\n\n\tdev_dbg(&edge->dev, \"new channel '%s' info-size: %zu fifo-size: %zu\\n\",\n\t\t\t  name, info_size, fifo_size);\n\n\tchannel->tx_fifo = fifo_base;\n\tchannel->rx_fifo = fifo_base + fifo_size;\n\tchannel->fifo_size = fifo_size;\n\n\tqcom_smd_channel_reset(channel);\n\n\treturn channel;\n\nfree_name_and_channel:\n\tkfree(channel->name);\nfree_channel:\n\tkfree(channel);\n\n\treturn ERR_PTR(ret);\n}\n\n \nstatic void qcom_channel_scan_worker(struct work_struct *work)\n{\n\tstruct qcom_smd_edge *edge = container_of(work, struct qcom_smd_edge, scan_work);\n\tstruct qcom_smd_alloc_entry *alloc_tbl;\n\tstruct qcom_smd_alloc_entry *entry;\n\tstruct qcom_smd_channel *channel;\n\tunsigned long flags;\n\tunsigned fifo_id;\n\tunsigned info_id;\n\tint tbl;\n\tint i;\n\tu32 eflags, cid;\n\n\tfor (tbl = 0; tbl < SMD_ALLOC_TBL_COUNT; tbl++) {\n\t\talloc_tbl = qcom_smem_get(edge->remote_pid,\n\t\t\t\t    smem_items[tbl].alloc_tbl_id, NULL);\n\t\tif (IS_ERR(alloc_tbl))\n\t\t\tcontinue;\n\n\t\tfor (i = 0; i < SMD_ALLOC_TBL_SIZE; i++) {\n\t\t\tentry = &alloc_tbl[i];\n\t\t\teflags = le32_to_cpu(entry->flags);\n\t\t\tif (test_bit(i, edge->allocated[tbl]))\n\t\t\t\tcontinue;\n\n\t\t\tif (entry->ref_count == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!entry->name[0])\n\t\t\t\tcontinue;\n\n\t\t\tif (!(eflags & SMD_CHANNEL_FLAGS_PACKET))\n\t\t\t\tcontinue;\n\n\t\t\tif ((eflags & SMD_CHANNEL_FLAGS_EDGE_MASK) != edge->edge_id)\n\t\t\t\tcontinue;\n\n\t\t\tcid = le32_to_cpu(entry->cid);\n\t\t\tinfo_id = smem_items[tbl].info_base_id + cid;\n\t\t\tfifo_id = smem_items[tbl].fifo_base_id + cid;\n\n\t\t\tchannel = qcom_smd_create_channel(edge, info_id, fifo_id, entry->name);\n\t\t\tif (IS_ERR(channel))\n\t\t\t\tcontinue;\n\n\t\t\tspin_lock_irqsave(&edge->channels_lock, flags);\n\t\t\tlist_add(&channel->list, &edge->channels);\n\t\t\tspin_unlock_irqrestore(&edge->channels_lock, flags);\n\n\t\t\tdev_dbg(&edge->dev, \"new channel found: '%s'\\n\", channel->name);\n\t\t\tset_bit(i, edge->allocated[tbl]);\n\n\t\t\twake_up_interruptible_all(&edge->new_channel_event);\n\t\t}\n\t}\n\n\tschedule_work(&edge->state_work);\n}\n\n \nstatic void qcom_channel_state_worker(struct work_struct *work)\n{\n\tstruct qcom_smd_channel *channel;\n\tstruct qcom_smd_edge *edge = container_of(work,\n\t\t\t\t\t\t  struct qcom_smd_edge,\n\t\t\t\t\t\t  state_work);\n\tstruct rpmsg_channel_info chinfo;\n\tunsigned remote_state;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&edge->channels_lock, flags);\n\tlist_for_each_entry(channel, &edge->channels, list) {\n\t\tif (channel->state != SMD_CHANNEL_CLOSED)\n\t\t\tcontinue;\n\n\t\t \n\t\tremote_state = GET_RX_CHANNEL_INFO(channel, state);\n\t\tif (remote_state != SMD_CHANNEL_OPENING &&\n\t\t    remote_state != SMD_CHANNEL_OPENED &&\n\t\t    strcmp(channel->name, \"rpm_requests\"))\n\t\t\tcontinue;\n\n\t\tif (channel->registered)\n\t\t\tcontinue;\n\n\t\tspin_unlock_irqrestore(&edge->channels_lock, flags);\n\t\tqcom_smd_create_device(channel);\n\t\tspin_lock_irqsave(&edge->channels_lock, flags);\n\t\tchannel->registered = true;\n\t}\n\n\t \n\tlist_for_each_entry(channel, &edge->channels, list) {\n\t\tif (channel->state != SMD_CHANNEL_OPENING &&\n\t\t    channel->state != SMD_CHANNEL_OPENED)\n\t\t\tcontinue;\n\n\t\tremote_state = GET_RX_CHANNEL_INFO(channel, state);\n\t\tif (remote_state == SMD_CHANNEL_OPENING ||\n\t\t    remote_state == SMD_CHANNEL_OPENED)\n\t\t\tcontinue;\n\n\t\tspin_unlock_irqrestore(&edge->channels_lock, flags);\n\n\t\tstrscpy_pad(chinfo.name, channel->name, sizeof(chinfo.name));\n\t\tchinfo.src = RPMSG_ADDR_ANY;\n\t\tchinfo.dst = RPMSG_ADDR_ANY;\n\t\trpmsg_unregister_device(&edge->dev, &chinfo);\n\t\tchannel->registered = false;\n\t\tspin_lock_irqsave(&edge->channels_lock, flags);\n\t}\n\tspin_unlock_irqrestore(&edge->channels_lock, flags);\n}\n\n \nstatic int qcom_smd_parse_edge(struct device *dev,\n\t\t\t       struct device_node *node,\n\t\t\t       struct qcom_smd_edge *edge)\n{\n\tstruct device_node *syscon_np;\n\tconst char *key;\n\tint irq;\n\tint ret;\n\n\tINIT_LIST_HEAD(&edge->channels);\n\tspin_lock_init(&edge->channels_lock);\n\n\tINIT_WORK(&edge->scan_work, qcom_channel_scan_worker);\n\tINIT_WORK(&edge->state_work, qcom_channel_state_worker);\n\n\tedge->of_node = of_node_get(node);\n\n\tkey = \"qcom,smd-edge\";\n\tret = of_property_read_u32(node, key, &edge->edge_id);\n\tif (ret) {\n\t\tdev_err(dev, \"edge missing %s property\\n\", key);\n\t\tgoto put_node;\n\t}\n\n\tedge->remote_pid = QCOM_SMEM_HOST_ANY;\n\tkey = \"qcom,remote-pid\";\n\tof_property_read_u32(node, key, &edge->remote_pid);\n\n\tedge->mbox_client.dev = dev;\n\tedge->mbox_client.knows_txdone = true;\n\tedge->mbox_chan = mbox_request_channel(&edge->mbox_client, 0);\n\tif (IS_ERR(edge->mbox_chan)) {\n\t\tif (PTR_ERR(edge->mbox_chan) != -ENODEV) {\n\t\t\tret = PTR_ERR(edge->mbox_chan);\n\t\t\tgoto put_node;\n\t\t}\n\n\t\tedge->mbox_chan = NULL;\n\n\t\tsyscon_np = of_parse_phandle(node, \"qcom,ipc\", 0);\n\t\tif (!syscon_np) {\n\t\t\tdev_err(dev, \"no qcom,ipc node\\n\");\n\t\t\tret = -ENODEV;\n\t\t\tgoto put_node;\n\t\t}\n\n\t\tedge->ipc_regmap = syscon_node_to_regmap(syscon_np);\n\t\tof_node_put(syscon_np);\n\t\tif (IS_ERR(edge->ipc_regmap)) {\n\t\t\tret = PTR_ERR(edge->ipc_regmap);\n\t\t\tgoto put_node;\n\t\t}\n\n\t\tkey = \"qcom,ipc\";\n\t\tret = of_property_read_u32_index(node, key, 1, &edge->ipc_offset);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"no offset in %s\\n\", key);\n\t\t\tgoto put_node;\n\t\t}\n\n\t\tret = of_property_read_u32_index(node, key, 2, &edge->ipc_bit);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"no bit in %s\\n\", key);\n\t\t\tgoto put_node;\n\t\t}\n\t}\n\n\tret = of_property_read_string(node, \"label\", &edge->name);\n\tif (ret < 0)\n\t\tedge->name = node->name;\n\n\tirq = irq_of_parse_and_map(node, 0);\n\tif (!irq) {\n\t\tdev_err(dev, \"required smd interrupt missing\\n\");\n\t\tret = -EINVAL;\n\t\tgoto put_node;\n\t}\n\n\tret = devm_request_irq(dev, irq,\n\t\t\t       qcom_smd_edge_intr, IRQF_TRIGGER_RISING,\n\t\t\t       node->name, edge);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request smd irq\\n\");\n\t\tgoto put_node;\n\t}\n\n\tedge->irq = irq;\n\n\treturn 0;\n\nput_node:\n\tof_node_put(node);\n\tedge->of_node = NULL;\n\n\treturn ret;\n}\n\n \nstatic void qcom_smd_edge_release(struct device *dev)\n{\n\tstruct qcom_smd_channel *channel, *tmp;\n\tstruct qcom_smd_edge *edge = to_smd_edge(dev);\n\n\tlist_for_each_entry_safe(channel, tmp, &edge->channels, list) {\n\t\tlist_del(&channel->list);\n\t\tkfree(channel->name);\n\t\tkfree(channel);\n\t}\n\n\tkfree(edge);\n}\n\nstatic ssize_t rpmsg_name_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct qcom_smd_edge *edge = to_smd_edge(dev);\n\n\treturn sprintf(buf, \"%s\\n\", edge->name);\n}\nstatic DEVICE_ATTR_RO(rpmsg_name);\n\nstatic struct attribute *qcom_smd_edge_attrs[] = {\n\t&dev_attr_rpmsg_name.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(qcom_smd_edge);\n\n \nstruct qcom_smd_edge *qcom_smd_register_edge(struct device *parent,\n\t\t\t\t\t     struct device_node *node)\n{\n\tstruct qcom_smd_edge *edge;\n\tint ret;\n\n\tif (!qcom_smem_is_available())\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tedge = kzalloc(sizeof(*edge), GFP_KERNEL);\n\tif (!edge)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinit_waitqueue_head(&edge->new_channel_event);\n\n\tedge->dev.parent = parent;\n\tedge->dev.release = qcom_smd_edge_release;\n\tedge->dev.of_node = node;\n\tedge->dev.groups = qcom_smd_edge_groups;\n\tdev_set_name(&edge->dev, \"%s:%pOFn\", dev_name(parent), node);\n\tret = device_register(&edge->dev);\n\tif (ret) {\n\t\tpr_err(\"failed to register smd edge\\n\");\n\t\tput_device(&edge->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = qcom_smd_parse_edge(&edge->dev, node, edge);\n\tif (ret) {\n\t\tdev_err(&edge->dev, \"failed to parse smd edge\\n\");\n\t\tgoto unregister_dev;\n\t}\n\n\tret = qcom_smd_create_chrdev(edge);\n\tif (ret) {\n\t\tdev_err(&edge->dev, \"failed to register chrdev for edge\\n\");\n\t\tgoto unregister_dev;\n\t}\n\n\tschedule_work(&edge->scan_work);\n\n\treturn edge;\n\nunregister_dev:\n\tif (!IS_ERR_OR_NULL(edge->mbox_chan))\n\t\tmbox_free_channel(edge->mbox_chan);\n\n\tdevice_unregister(&edge->dev);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL(qcom_smd_register_edge);\n\nstatic int qcom_smd_remove_device(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\n \nvoid qcom_smd_unregister_edge(struct qcom_smd_edge *edge)\n{\n\tint ret;\n\n\tdisable_irq(edge->irq);\n\tcancel_work_sync(&edge->scan_work);\n\tcancel_work_sync(&edge->state_work);\n\n\tret = device_for_each_child(&edge->dev, NULL, qcom_smd_remove_device);\n\tif (ret)\n\t\tdev_warn(&edge->dev, \"can't remove smd device: %d\\n\", ret);\n\n\tmbox_free_channel(edge->mbox_chan);\n\tdevice_unregister(&edge->dev);\n}\nEXPORT_SYMBOL(qcom_smd_unregister_edge);\n\nstatic int qcom_smd_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node;\n\n\tif (!qcom_smem_is_available())\n\t\treturn -EPROBE_DEFER;\n\n\tfor_each_available_child_of_node(pdev->dev.of_node, node)\n\t\tqcom_smd_register_edge(&pdev->dev, node);\n\n\treturn 0;\n}\n\nstatic int qcom_smd_remove_edge(struct device *dev, void *data)\n{\n\tstruct qcom_smd_edge *edge = to_smd_edge(dev);\n\n\tqcom_smd_unregister_edge(edge);\n\n\treturn 0;\n}\n\n \nstatic void qcom_smd_remove(struct platform_device *pdev)\n{\n\t \n\tdevice_for_each_child(&pdev->dev, NULL, qcom_smd_remove_edge);\n}\n\nstatic const struct of_device_id qcom_smd_of_match[] = {\n\t{ .compatible = \"qcom,smd\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, qcom_smd_of_match);\n\nstatic struct platform_driver qcom_smd_driver = {\n\t.probe = qcom_smd_probe,\n\t.remove_new = qcom_smd_remove,\n\t.driver = {\n\t\t.name = \"qcom-smd\",\n\t\t.of_match_table = qcom_smd_of_match,\n\t},\n};\n\nstatic int __init qcom_smd_init(void)\n{\n\treturn platform_driver_register(&qcom_smd_driver);\n}\narch_initcall(qcom_smd_init);\n\nstatic void __exit qcom_smd_exit(void)\n{\n\tplatform_driver_unregister(&qcom_smd_driver);\n}\nmodule_exit(qcom_smd_exit);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@sonymobile.com>\");\nMODULE_DESCRIPTION(\"Qualcomm Shared Memory Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}