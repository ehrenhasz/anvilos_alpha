{
  "module_name": "qcom_glink_rpm.c",
  "hash_id": "aeaf8f990a2ce5c711528befaefc53bce0cc6c497be07aafd0a3bba8f3fb849e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/qcom_glink_rpm.c",
  "human_readable_source": "\n \n\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/list.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/rpmsg.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/mailbox_client.h>\n\n#include \"rpmsg_internal.h\"\n#include \"qcom_glink_native.h\"\n\n#define RPM_TOC_SIZE\t\t256\n#define RPM_TOC_MAGIC\t\t0x67727430  \n#define RPM_TOC_MAX_ENTRIES\t((RPM_TOC_SIZE - sizeof(struct rpm_toc)) / \\\n\t\t\t\t sizeof(struct rpm_toc_entry))\n\n#define RPM_TX_FIFO_ID\t\t0x61703272  \n#define RPM_RX_FIFO_ID\t\t0x72326170  \n\n#define to_rpm_pipe(p) container_of(p, struct glink_rpm_pipe, native)\n\nstruct rpm_toc_entry {\n\t__le32 id;\n\t__le32 offset;\n\t__le32 size;\n} __packed;\n\nstruct rpm_toc {\n\t__le32 magic;\n\t__le32 count;\n\n\tstruct rpm_toc_entry entries[];\n} __packed;\n\nstruct glink_rpm_pipe {\n\tstruct qcom_glink_pipe native;\n\n\tvoid __iomem *tail;\n\tvoid __iomem *head;\n\n\tvoid __iomem *fifo;\n};\n\nstruct glink_rpm {\n\tstruct qcom_glink *glink;\n\n\tint irq;\n\n\tstruct mbox_client mbox_client;\n\tstruct mbox_chan *mbox_chan;\n\n\tstruct glink_rpm_pipe rx_pipe;\n\tstruct glink_rpm_pipe tx_pipe;\n};\n\nstatic size_t glink_rpm_rx_avail(struct qcom_glink_pipe *glink_pipe)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tunsigned int head;\n\tunsigned int tail;\n\n\thead = readl(pipe->head);\n\ttail = readl(pipe->tail);\n\n\tif (head < tail)\n\t\treturn pipe->native.length - tail + head;\n\telse\n\t\treturn head - tail;\n}\n\nstatic void glink_rpm_rx_peek(struct qcom_glink_pipe *glink_pipe,\n\t\t\t      void *data, unsigned int offset, size_t count)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tunsigned int tail;\n\tsize_t len;\n\n\ttail = readl(pipe->tail);\n\ttail += offset;\n\tif (tail >= pipe->native.length)\n\t\ttail -= pipe->native.length;\n\n\tlen = min_t(size_t, count, pipe->native.length - tail);\n\tif (len) {\n\t\t__ioread32_copy(data, pipe->fifo + tail,\n\t\t\t\tlen / sizeof(u32));\n\t}\n\n\tif (len != count) {\n\t\t__ioread32_copy(data + len, pipe->fifo,\n\t\t\t\t(count - len) / sizeof(u32));\n\t}\n}\n\nstatic void glink_rpm_rx_advance(struct qcom_glink_pipe *glink_pipe,\n\t\t\t\t size_t count)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tunsigned int tail;\n\n\ttail = readl(pipe->tail);\n\n\ttail += count;\n\tif (tail >= pipe->native.length)\n\t\ttail -= pipe->native.length;\n\n\twritel(tail, pipe->tail);\n}\n\nstatic size_t glink_rpm_tx_avail(struct qcom_glink_pipe *glink_pipe)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tunsigned int head;\n\tunsigned int tail;\n\n\thead = readl(pipe->head);\n\ttail = readl(pipe->tail);\n\n\tif (tail <= head)\n\t\treturn pipe->native.length - head + tail;\n\telse\n\t\treturn tail - head;\n}\n\nstatic unsigned int glink_rpm_tx_write_one(struct glink_rpm_pipe *pipe,\n\t\t\t\t\t   unsigned int head,\n\t\t\t\t\t   const void *data, size_t count)\n{\n\tsize_t len;\n\n\tlen = min_t(size_t, count, pipe->native.length - head);\n\tif (len) {\n\t\t__iowrite32_copy(pipe->fifo + head, data,\n\t\t\t\t len / sizeof(u32));\n\t}\n\n\tif (len != count) {\n\t\t__iowrite32_copy(pipe->fifo, data + len,\n\t\t\t\t (count - len) / sizeof(u32));\n\t}\n\n\thead += count;\n\tif (head >= pipe->native.length)\n\t\thead -= pipe->native.length;\n\n\treturn head;\n}\n\nstatic void glink_rpm_tx_write(struct qcom_glink_pipe *glink_pipe,\n\t\t\t       const void *hdr, size_t hlen,\n\t\t\t       const void *data, size_t dlen)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tsize_t tlen = hlen + dlen;\n\tsize_t aligned_dlen;\n\tunsigned int head;\n\tchar padding[8] = {0};\n\tsize_t pad;\n\n\t \n\tif (WARN(hlen % 4, \"Glink Header length must be 4 bytes aligned\\n\"))\n\t\treturn;\n\n\t \n\taligned_dlen = ALIGN_DOWN(dlen, 4);\n\tif (aligned_dlen != dlen)\n\t\tmemcpy(padding, data + aligned_dlen, dlen - aligned_dlen);\n\n\thead = readl(pipe->head);\n\thead = glink_rpm_tx_write_one(pipe, head, hdr, hlen);\n\thead = glink_rpm_tx_write_one(pipe, head, data, aligned_dlen);\n\n\tpad = ALIGN(tlen, 8) - ALIGN_DOWN(tlen, 4);\n\tif (pad)\n\t\thead = glink_rpm_tx_write_one(pipe, head, padding, pad);\n\twritel(head, pipe->head);\n}\n\nstatic void glink_rpm_tx_kick(struct qcom_glink_pipe *glink_pipe)\n{\n\tstruct glink_rpm_pipe *pipe = to_rpm_pipe(glink_pipe);\n\tstruct glink_rpm *rpm = container_of(pipe, struct glink_rpm, tx_pipe);\n\n\tmbox_send_message(rpm->mbox_chan, NULL);\n\tmbox_client_txdone(rpm->mbox_chan, 0);\n}\n\nstatic irqreturn_t qcom_glink_rpm_intr(int irq, void *data)\n{\n\tstruct glink_rpm *rpm = data;\n\n\tqcom_glink_native_rx(rpm->glink);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int glink_rpm_parse_toc(struct device *dev,\n\t\t\t       void __iomem *msg_ram,\n\t\t\t       size_t msg_ram_size,\n\t\t\t       struct glink_rpm_pipe *rx,\n\t\t\t       struct glink_rpm_pipe *tx)\n{\n\tstruct rpm_toc *toc;\n\tint num_entries;\n\tunsigned int id;\n\tsize_t offset;\n\tsize_t size;\n\tvoid *buf;\n\tint i;\n\n\tbuf = kzalloc(RPM_TOC_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t__ioread32_copy(buf, msg_ram + msg_ram_size - RPM_TOC_SIZE,\n\t\t\tRPM_TOC_SIZE / sizeof(u32));\n\n\ttoc = buf;\n\n\tif (le32_to_cpu(toc->magic) != RPM_TOC_MAGIC) {\n\t\tdev_err(dev, \"RPM TOC has invalid magic\\n\");\n\t\tgoto err_inval;\n\t}\n\n\tnum_entries = le32_to_cpu(toc->count);\n\tif (num_entries > RPM_TOC_MAX_ENTRIES) {\n\t\tdev_err(dev, \"Invalid number of toc entries\\n\");\n\t\tgoto err_inval;\n\t}\n\n\tfor (i = 0; i < num_entries; i++) {\n\t\tid = le32_to_cpu(toc->entries[i].id);\n\t\toffset = le32_to_cpu(toc->entries[i].offset);\n\t\tsize = le32_to_cpu(toc->entries[i].size);\n\n\t\tif (offset > msg_ram_size || offset + size > msg_ram_size) {\n\t\t\tdev_err(dev, \"TOC entry with invalid size\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (id) {\n\t\tcase RPM_RX_FIFO_ID:\n\t\t\trx->native.length = size;\n\n\t\t\trx->tail = msg_ram + offset;\n\t\t\trx->head = msg_ram + offset + sizeof(u32);\n\t\t\trx->fifo = msg_ram + offset + 2 * sizeof(u32);\n\t\t\tbreak;\n\t\tcase RPM_TX_FIFO_ID:\n\t\t\ttx->native.length = size;\n\n\t\t\ttx->tail = msg_ram + offset;\n\t\t\ttx->head = msg_ram + offset + sizeof(u32);\n\t\t\ttx->fifo = msg_ram + offset + 2 * sizeof(u32);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!rx->fifo || !tx->fifo) {\n\t\tdev_err(dev, \"Unable to find rx and tx descriptors\\n\");\n\t\tgoto err_inval;\n\t}\n\n\tkfree(buf);\n\treturn 0;\n\nerr_inval:\n\tkfree(buf);\n\treturn -EINVAL;\n}\n\nstatic int glink_rpm_probe(struct platform_device *pdev)\n{\n\tstruct qcom_glink *glink;\n\tstruct glink_rpm *rpm;\n\tstruct device_node *np;\n\tvoid __iomem *msg_ram;\n\tsize_t msg_ram_size;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource r;\n\tint ret;\n\n\trpm = devm_kzalloc(&pdev->dev, sizeof(*rpm), GFP_KERNEL);\n\tif (!rpm)\n\t\treturn -ENOMEM;\n\n\tnp = of_parse_phandle(dev->of_node, \"qcom,rpm-msg-ram\", 0);\n\tret = of_address_to_resource(np, 0, &r);\n\tof_node_put(np);\n\tif (ret)\n\t\treturn ret;\n\n\tmsg_ram = devm_ioremap(dev, r.start, resource_size(&r));\n\tmsg_ram_size = resource_size(&r);\n\tif (!msg_ram)\n\t\treturn -ENOMEM;\n\n\tret = glink_rpm_parse_toc(dev, msg_ram, msg_ram_size,\n\t\t\t\t  &rpm->rx_pipe, &rpm->tx_pipe);\n\tif (ret)\n\t\treturn ret;\n\n\trpm->irq = of_irq_get(dev->of_node, 0);\n\tret = devm_request_irq(dev, rpm->irq, qcom_glink_rpm_intr,\n\t\t\t       IRQF_NO_SUSPEND | IRQF_NO_AUTOEN,\n\t\t\t       \"glink-rpm\", rpm);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request IRQ\\n\");\n\t\treturn ret;\n\t}\n\n\trpm->mbox_client.dev = dev;\n\trpm->mbox_client.knows_txdone = true;\n\trpm->mbox_chan = mbox_request_channel(&rpm->mbox_client, 0);\n\tif (IS_ERR(rpm->mbox_chan))\n\t\treturn dev_err_probe(dev, PTR_ERR(rpm->mbox_chan), \"failed to acquire IPC channel\\n\");\n\n\t \n\trpm->rx_pipe.native.avail = glink_rpm_rx_avail;\n\trpm->rx_pipe.native.peek = glink_rpm_rx_peek;\n\trpm->rx_pipe.native.advance = glink_rpm_rx_advance;\n\trpm->tx_pipe.native.avail = glink_rpm_tx_avail;\n\trpm->tx_pipe.native.write = glink_rpm_tx_write;\n\trpm->tx_pipe.native.kick = glink_rpm_tx_kick;\n\n\twritel(0, rpm->tx_pipe.head);\n\twritel(0, rpm->rx_pipe.tail);\n\n\tglink = qcom_glink_native_probe(dev,\n\t\t\t\t\t0,\n\t\t\t\t\t&rpm->rx_pipe.native,\n\t\t\t\t\t&rpm->tx_pipe.native,\n\t\t\t\t\ttrue);\n\tif (IS_ERR(glink)) {\n\t\tmbox_free_channel(rpm->mbox_chan);\n\t\treturn PTR_ERR(glink);\n\t}\n\n\trpm->glink = glink;\n\n\tplatform_set_drvdata(pdev, rpm);\n\n\tenable_irq(rpm->irq);\n\n\treturn 0;\n}\n\nstatic void glink_rpm_remove(struct platform_device *pdev)\n{\n\tstruct glink_rpm *rpm = platform_get_drvdata(pdev);\n\tstruct qcom_glink *glink = rpm->glink;\n\n\tdisable_irq(rpm->irq);\n\n\tqcom_glink_native_remove(glink);\n\n\tmbox_free_channel(rpm->mbox_chan);\n}\n\nstatic const struct of_device_id glink_rpm_of_match[] = {\n\t{ .compatible = \"qcom,glink-rpm\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, glink_rpm_of_match);\n\nstatic struct platform_driver glink_rpm_driver = {\n\t.probe = glink_rpm_probe,\n\t.remove_new = glink_rpm_remove,\n\t.driver = {\n\t\t.name = \"qcom_glink_rpm\",\n\t\t.of_match_table = glink_rpm_of_match,\n\t},\n};\n\nstatic int __init glink_rpm_init(void)\n{\n\treturn platform_driver_register(&glink_rpm_driver);\n}\nsubsys_initcall(glink_rpm_init);\n\nstatic void __exit glink_rpm_exit(void)\n{\n\tplatform_driver_unregister(&glink_rpm_driver);\n}\nmodule_exit(glink_rpm_exit);\n\nMODULE_AUTHOR(\"Bjorn Andersson <bjorn.andersson@linaro.org>\");\nMODULE_DESCRIPTION(\"Qualcomm GLINK RPM driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}