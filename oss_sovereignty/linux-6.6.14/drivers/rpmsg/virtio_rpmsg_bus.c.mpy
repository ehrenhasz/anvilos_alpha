{
  "module_name": "virtio_rpmsg_bus.c",
  "hash_id": "3185852f17ceb8b968cf66409b004d307fed778a41c7ef35e7ef7bcb2b17c4e2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/rpmsg/virtio_rpmsg_bus.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) \"%s: \" fmt, __func__\n\n#include <linux/dma-mapping.h>\n#include <linux/idr.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/rpmsg.h>\n#include <linux/rpmsg/byteorder.h>\n#include <linux/rpmsg/ns.h>\n#include <linux/scatterlist.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/virtio.h>\n#include <linux/virtio_ids.h>\n#include <linux/virtio_config.h>\n#include <linux/wait.h>\n\n#include \"rpmsg_internal.h\"\n\n \nstruct virtproc_info {\n\tstruct virtio_device *vdev;\n\tstruct virtqueue *rvq, *svq;\n\tvoid *rbufs, *sbufs;\n\tunsigned int num_bufs;\n\tunsigned int buf_size;\n\tint last_sbuf;\n\tdma_addr_t bufs_dma;\n\tstruct mutex tx_lock;\n\tstruct idr endpoints;\n\tstruct mutex endpoints_lock;\n\twait_queue_head_t sendq;\n\tatomic_t sleepers;\n};\n\n \n#define VIRTIO_RPMSG_F_NS\t0  \n\n \nstruct rpmsg_hdr {\n\t__rpmsg32 src;\n\t__rpmsg32 dst;\n\t__rpmsg32 reserved;\n\t__rpmsg16 len;\n\t__rpmsg16 flags;\n\tu8 data[];\n} __packed;\n\n\n \nstruct virtio_rpmsg_channel {\n\tstruct rpmsg_device rpdev;\n\n\tstruct virtproc_info *vrp;\n};\n\n#define to_virtio_rpmsg_channel(_rpdev) \\\n\tcontainer_of(_rpdev, struct virtio_rpmsg_channel, rpdev)\n\n \n#define MAX_RPMSG_NUM_BUFS\t(512)\n#define MAX_RPMSG_BUF_SIZE\t(512)\n\n \n#define RPMSG_RESERVED_ADDRESSES\t(1024)\n\nstatic void virtio_rpmsg_destroy_ept(struct rpmsg_endpoint *ept);\nstatic int virtio_rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len);\nstatic int virtio_rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len,\n\t\t\t       u32 dst);\nstatic int virtio_rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\tu32 dst, void *data, int len);\nstatic int virtio_rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len);\nstatic int virtio_rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data,\n\t\t\t\t  int len, u32 dst);\nstatic int virtio_rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\t   u32 dst, void *data, int len);\nstatic ssize_t virtio_rpmsg_get_mtu(struct rpmsg_endpoint *ept);\nstatic struct rpmsg_device *__rpmsg_create_channel(struct virtproc_info *vrp,\n\t\t\t\t\t\t   struct rpmsg_channel_info *chinfo);\n\nstatic const struct rpmsg_endpoint_ops virtio_endpoint_ops = {\n\t.destroy_ept = virtio_rpmsg_destroy_ept,\n\t.send = virtio_rpmsg_send,\n\t.sendto = virtio_rpmsg_sendto,\n\t.send_offchannel = virtio_rpmsg_send_offchannel,\n\t.trysend = virtio_rpmsg_trysend,\n\t.trysendto = virtio_rpmsg_trysendto,\n\t.trysend_offchannel = virtio_rpmsg_trysend_offchannel,\n\t.get_mtu = virtio_rpmsg_get_mtu,\n};\n\n \nstatic void\nrpmsg_sg_init(struct scatterlist *sg, void *cpu_addr, unsigned int len)\n{\n\tif (is_vmalloc_addr(cpu_addr)) {\n\t\tsg_init_table(sg, 1);\n\t\tsg_set_page(sg, vmalloc_to_page(cpu_addr), len,\n\t\t\t    offset_in_page(cpu_addr));\n\t} else {\n\t\tWARN_ON(!virt_addr_valid(cpu_addr));\n\t\tsg_init_one(sg, cpu_addr, len);\n\t}\n}\n\n \nstatic void __ept_release(struct kref *kref)\n{\n\tstruct rpmsg_endpoint *ept = container_of(kref, struct rpmsg_endpoint,\n\t\t\t\t\t\t  refcount);\n\t \n\tkfree(ept);\n}\n\n \nstatic struct rpmsg_endpoint *__rpmsg_create_ept(struct virtproc_info *vrp,\n\t\t\t\t\t\t struct rpmsg_device *rpdev,\n\t\t\t\t\t\t rpmsg_rx_cb_t cb,\n\t\t\t\t\t\t void *priv, u32 addr)\n{\n\tint id_min, id_max, id;\n\tstruct rpmsg_endpoint *ept;\n\tstruct device *dev = rpdev ? &rpdev->dev : &vrp->vdev->dev;\n\n\tept = kzalloc(sizeof(*ept), GFP_KERNEL);\n\tif (!ept)\n\t\treturn NULL;\n\n\tkref_init(&ept->refcount);\n\tmutex_init(&ept->cb_lock);\n\n\tept->rpdev = rpdev;\n\tept->cb = cb;\n\tept->priv = priv;\n\tept->ops = &virtio_endpoint_ops;\n\n\t \n\tif (addr == RPMSG_ADDR_ANY) {\n\t\tid_min = RPMSG_RESERVED_ADDRESSES;\n\t\tid_max = 0;\n\t} else {\n\t\tid_min = addr;\n\t\tid_max = addr + 1;\n\t}\n\n\tmutex_lock(&vrp->endpoints_lock);\n\n\t \n\tid = idr_alloc(&vrp->endpoints, ept, id_min, id_max, GFP_KERNEL);\n\tif (id < 0) {\n\t\tdev_err(dev, \"idr_alloc failed: %d\\n\", id);\n\t\tgoto free_ept;\n\t}\n\tept->addr = id;\n\n\tmutex_unlock(&vrp->endpoints_lock);\n\n\treturn ept;\n\nfree_ept:\n\tmutex_unlock(&vrp->endpoints_lock);\n\tkref_put(&ept->refcount, __ept_release);\n\treturn NULL;\n}\n\nstatic struct rpmsg_device *virtio_rpmsg_create_channel(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t\tstruct rpmsg_channel_info *chinfo)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\tstruct virtproc_info *vrp = vch->vrp;\n\n\treturn __rpmsg_create_channel(vrp, chinfo);\n}\n\nstatic int virtio_rpmsg_release_channel(struct rpmsg_device *rpdev,\n\t\t\t\t\tstruct rpmsg_channel_info *chinfo)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\tstruct virtproc_info *vrp = vch->vrp;\n\n\treturn rpmsg_unregister_device(&vrp->vdev->dev, chinfo);\n}\n\nstatic struct rpmsg_endpoint *virtio_rpmsg_create_ept(struct rpmsg_device *rpdev,\n\t\t\t\t\t\t      rpmsg_rx_cb_t cb,\n\t\t\t\t\t\t      void *priv,\n\t\t\t\t\t\t      struct rpmsg_channel_info chinfo)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\n\treturn __rpmsg_create_ept(vch->vrp, rpdev, cb, priv, chinfo.src);\n}\n\n \nstatic void\n__rpmsg_destroy_ept(struct virtproc_info *vrp, struct rpmsg_endpoint *ept)\n{\n\t \n\tmutex_lock(&vrp->endpoints_lock);\n\tidr_remove(&vrp->endpoints, ept->addr);\n\tmutex_unlock(&vrp->endpoints_lock);\n\n\t \n\tmutex_lock(&ept->cb_lock);\n\tept->cb = NULL;\n\tmutex_unlock(&ept->cb_lock);\n\n\tkref_put(&ept->refcount, __ept_release);\n}\n\nstatic void virtio_rpmsg_destroy_ept(struct rpmsg_endpoint *ept)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(ept->rpdev);\n\n\t__rpmsg_destroy_ept(vch->vrp, ept);\n}\n\nstatic int virtio_rpmsg_announce_create(struct rpmsg_device *rpdev)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\tstruct virtproc_info *vrp = vch->vrp;\n\tstruct device *dev = &rpdev->dev;\n\tint err = 0;\n\n\t \n\tif (rpdev->announce && rpdev->ept &&\n\t    virtio_has_feature(vrp->vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tstruct rpmsg_ns_msg nsm;\n\n\t\tstrncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);\n\t\tnsm.addr = cpu_to_rpmsg32(rpdev, rpdev->ept->addr);\n\t\tnsm.flags = cpu_to_rpmsg32(rpdev, RPMSG_NS_CREATE);\n\n\t\terr = rpmsg_sendto(rpdev->ept, &nsm, sizeof(nsm), RPMSG_NS_ADDR);\n\t\tif (err)\n\t\t\tdev_err(dev, \"failed to announce service %d\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic int virtio_rpmsg_announce_destroy(struct rpmsg_device *rpdev)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\tstruct virtproc_info *vrp = vch->vrp;\n\tstruct device *dev = &rpdev->dev;\n\tint err = 0;\n\n\t \n\tif (rpdev->announce && rpdev->ept &&\n\t    virtio_has_feature(vrp->vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tstruct rpmsg_ns_msg nsm;\n\n\t\tstrncpy(nsm.name, rpdev->id.name, RPMSG_NAME_SIZE);\n\t\tnsm.addr = cpu_to_rpmsg32(rpdev, rpdev->ept->addr);\n\t\tnsm.flags = cpu_to_rpmsg32(rpdev, RPMSG_NS_DESTROY);\n\n\t\terr = rpmsg_sendto(rpdev->ept, &nsm, sizeof(nsm), RPMSG_NS_ADDR);\n\t\tif (err)\n\t\t\tdev_err(dev, \"failed to announce service %d\\n\", err);\n\t}\n\n\treturn err;\n}\n\nstatic const struct rpmsg_device_ops virtio_rpmsg_ops = {\n\t.create_channel = virtio_rpmsg_create_channel,\n\t.release_channel = virtio_rpmsg_release_channel,\n\t.create_ept = virtio_rpmsg_create_ept,\n\t.announce_create = virtio_rpmsg_announce_create,\n\t.announce_destroy = virtio_rpmsg_announce_destroy,\n};\n\nstatic void virtio_rpmsg_release_device(struct device *dev)\n{\n\tstruct rpmsg_device *rpdev = to_rpmsg_device(dev);\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\n\tkfree(vch);\n}\n\n \nstatic struct rpmsg_device *__rpmsg_create_channel(struct virtproc_info *vrp,\n\t\t\t\t\t\t   struct rpmsg_channel_info *chinfo)\n{\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev;\n\tstruct device *tmp, *dev = &vrp->vdev->dev;\n\tint ret;\n\n\t \n\ttmp = rpmsg_find_device(dev, chinfo);\n\tif (tmp) {\n\t\t \n\t\tput_device(tmp);\n\t\tdev_err(dev, \"channel %s:%x:%x already exist\\n\",\n\t\t\t\tchinfo->name, chinfo->src, chinfo->dst);\n\t\treturn NULL;\n\t}\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn NULL;\n\n\t \n\tvch->vrp = vrp;\n\n\t \n\trpdev = &vch->rpdev;\n\trpdev->src = chinfo->src;\n\trpdev->dst = chinfo->dst;\n\trpdev->ops = &virtio_rpmsg_ops;\n\trpdev->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\t \n\trpdev->announce = rpdev->src != RPMSG_ADDR_ANY;\n\n\tstrncpy(rpdev->id.name, chinfo->name, RPMSG_NAME_SIZE);\n\n\trpdev->dev.parent = &vrp->vdev->dev;\n\trpdev->dev.release = virtio_rpmsg_release_device;\n\tret = rpmsg_register_device(rpdev);\n\tif (ret)\n\t\treturn NULL;\n\n\treturn rpdev;\n}\n\n \nstatic void *get_a_tx_buf(struct virtproc_info *vrp)\n{\n\tunsigned int len;\n\tvoid *ret;\n\n\t \n\tmutex_lock(&vrp->tx_lock);\n\n\t \n\tif (vrp->last_sbuf < vrp->num_bufs / 2)\n\t\tret = vrp->sbufs + vrp->buf_size * vrp->last_sbuf++;\n\t \n\telse\n\t\tret = virtqueue_get_buf(vrp->svq, &len);\n\n\tmutex_unlock(&vrp->tx_lock);\n\n\treturn ret;\n}\n\n \nstatic void rpmsg_upref_sleepers(struct virtproc_info *vrp)\n{\n\t \n\tmutex_lock(&vrp->tx_lock);\n\n\t \n\tif (atomic_inc_return(&vrp->sleepers) == 1)\n\t\t \n\t\tvirtqueue_enable_cb(vrp->svq);\n\n\tmutex_unlock(&vrp->tx_lock);\n}\n\n \nstatic void rpmsg_downref_sleepers(struct virtproc_info *vrp)\n{\n\t \n\tmutex_lock(&vrp->tx_lock);\n\n\t \n\tif (atomic_dec_and_test(&vrp->sleepers))\n\t\t \n\t\tvirtqueue_disable_cb(vrp->svq);\n\n\tmutex_unlock(&vrp->tx_lock);\n}\n\n \nstatic int rpmsg_send_offchannel_raw(struct rpmsg_device *rpdev,\n\t\t\t\t     u32 src, u32 dst,\n\t\t\t\t     void *data, int len, bool wait)\n{\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\tstruct virtproc_info *vrp = vch->vrp;\n\tstruct device *dev = &rpdev->dev;\n\tstruct scatterlist sg;\n\tstruct rpmsg_hdr *msg;\n\tint err;\n\n\t \n\tif (src == RPMSG_ADDR_ANY || dst == RPMSG_ADDR_ANY) {\n\t\tdev_err(dev, \"invalid addr (src 0x%x, dst 0x%x)\\n\", src, dst);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (len > vrp->buf_size - sizeof(struct rpmsg_hdr)) {\n\t\tdev_err(dev, \"message is too big (%d)\\n\", len);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tmsg = get_a_tx_buf(vrp);\n\tif (!msg && !wait)\n\t\treturn -ENOMEM;\n\n\t \n\twhile (!msg) {\n\t\t \n\t\trpmsg_upref_sleepers(vrp);\n\n\t\t \n\t\terr = wait_event_interruptible_timeout(vrp->sendq,\n\t\t\t\t\t(msg = get_a_tx_buf(vrp)),\n\t\t\t\t\tmsecs_to_jiffies(15000));\n\n\t\t \n\t\trpmsg_downref_sleepers(vrp);\n\n\t\t \n\t\tif (!err) {\n\t\t\tdev_err(dev, \"timeout waiting for a tx buffer\\n\");\n\t\t\treturn -ERESTARTSYS;\n\t\t}\n\t}\n\n\tmsg->len = cpu_to_rpmsg16(rpdev, len);\n\tmsg->flags = 0;\n\tmsg->src = cpu_to_rpmsg32(rpdev, src);\n\tmsg->dst = cpu_to_rpmsg32(rpdev, dst);\n\tmsg->reserved = 0;\n\tmemcpy(msg->data, data, len);\n\n\tdev_dbg(dev, \"TX From 0x%x, To 0x%x, Len %d, Flags %d, Reserved %d\\n\",\n\t\tsrc, dst, len, msg->flags, msg->reserved);\n#if defined(CONFIG_DYNAMIC_DEBUG)\n\tdynamic_hex_dump(\"rpmsg_virtio TX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t msg, sizeof(*msg) + len, true);\n#endif\n\n\trpmsg_sg_init(&sg, msg, sizeof(*msg) + len);\n\n\tmutex_lock(&vrp->tx_lock);\n\n\t \n\terr = virtqueue_add_outbuf(vrp->svq, &sg, 1, msg, GFP_KERNEL);\n\tif (err) {\n\t\t \n\t\tdev_err(dev, \"virtqueue_add_outbuf failed: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\t \n\tvirtqueue_kick(vrp->svq);\nout:\n\tmutex_unlock(&vrp->tx_lock);\n\treturn err;\n}\n\nstatic int virtio_rpmsg_send(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\tu32 src = ept->addr, dst = rpdev->dst;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, true);\n}\n\nstatic int virtio_rpmsg_sendto(struct rpmsg_endpoint *ept, void *data, int len,\n\t\t\t       u32 dst)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\tu32 src = ept->addr;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, true);\n}\n\nstatic int virtio_rpmsg_send_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\tu32 dst, void *data, int len)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, true);\n}\n\nstatic int virtio_rpmsg_trysend(struct rpmsg_endpoint *ept, void *data, int len)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\tu32 src = ept->addr, dst = rpdev->dst;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, false);\n}\n\nstatic int virtio_rpmsg_trysendto(struct rpmsg_endpoint *ept, void *data,\n\t\t\t\t  int len, u32 dst)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\tu32 src = ept->addr;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, false);\n}\n\nstatic int virtio_rpmsg_trysend_offchannel(struct rpmsg_endpoint *ept, u32 src,\n\t\t\t\t\t   u32 dst, void *data, int len)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\n\treturn rpmsg_send_offchannel_raw(rpdev, src, dst, data, len, false);\n}\n\nstatic ssize_t virtio_rpmsg_get_mtu(struct rpmsg_endpoint *ept)\n{\n\tstruct rpmsg_device *rpdev = ept->rpdev;\n\tstruct virtio_rpmsg_channel *vch = to_virtio_rpmsg_channel(rpdev);\n\n\treturn vch->vrp->buf_size - sizeof(struct rpmsg_hdr);\n}\n\nstatic int rpmsg_recv_single(struct virtproc_info *vrp, struct device *dev,\n\t\t\t     struct rpmsg_hdr *msg, unsigned int len)\n{\n\tstruct rpmsg_endpoint *ept;\n\tstruct scatterlist sg;\n\tbool little_endian = virtio_is_little_endian(vrp->vdev);\n\tunsigned int msg_len = __rpmsg16_to_cpu(little_endian, msg->len);\n\tint err;\n\n\tdev_dbg(dev, \"From: 0x%x, To: 0x%x, Len: %d, Flags: %d, Reserved: %d\\n\",\n\t\t__rpmsg32_to_cpu(little_endian, msg->src),\n\t\t__rpmsg32_to_cpu(little_endian, msg->dst), msg_len,\n\t\t__rpmsg16_to_cpu(little_endian, msg->flags),\n\t\t__rpmsg32_to_cpu(little_endian, msg->reserved));\n#if defined(CONFIG_DYNAMIC_DEBUG)\n\tdynamic_hex_dump(\"rpmsg_virtio RX: \", DUMP_PREFIX_NONE, 16, 1,\n\t\t\t msg, sizeof(*msg) + msg_len, true);\n#endif\n\n\t \n\tif (len > vrp->buf_size ||\n\t    msg_len > (len - sizeof(struct rpmsg_hdr))) {\n\t\tdev_warn(dev, \"inbound msg too big: (%d, %d)\\n\", len, msg_len);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tmutex_lock(&vrp->endpoints_lock);\n\n\tept = idr_find(&vrp->endpoints, __rpmsg32_to_cpu(little_endian, msg->dst));\n\n\t \n\tif (ept)\n\t\tkref_get(&ept->refcount);\n\n\tmutex_unlock(&vrp->endpoints_lock);\n\n\tif (ept) {\n\t\t \n\t\tmutex_lock(&ept->cb_lock);\n\n\t\tif (ept->cb)\n\t\t\tept->cb(ept->rpdev, msg->data, msg_len, ept->priv,\n\t\t\t\t__rpmsg32_to_cpu(little_endian, msg->src));\n\n\t\tmutex_unlock(&ept->cb_lock);\n\n\t\t \n\t\tkref_put(&ept->refcount, __ept_release);\n\t} else\n\t\tdev_warn_ratelimited(dev, \"msg received with no recipient\\n\");\n\n\t \n\trpmsg_sg_init(&sg, msg, vrp->buf_size);\n\n\t \n\terr = virtqueue_add_inbuf(vrp->rvq, &sg, 1, msg, GFP_KERNEL);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to add a virtqueue buffer: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void rpmsg_recv_done(struct virtqueue *rvq)\n{\n\tstruct virtproc_info *vrp = rvq->vdev->priv;\n\tstruct device *dev = &rvq->vdev->dev;\n\tstruct rpmsg_hdr *msg;\n\tunsigned int len, msgs_received = 0;\n\tint err;\n\n\tmsg = virtqueue_get_buf(rvq, &len);\n\tif (!msg) {\n\t\tdev_err(dev, \"uhm, incoming signal, but no used buffer ?\\n\");\n\t\treturn;\n\t}\n\n\twhile (msg) {\n\t\terr = rpmsg_recv_single(vrp, dev, msg, len);\n\t\tif (err)\n\t\t\tbreak;\n\n\t\tmsgs_received++;\n\n\t\tmsg = virtqueue_get_buf(rvq, &len);\n\t}\n\n\tdev_dbg(dev, \"Received %u messages\\n\", msgs_received);\n\n\t \n\tif (msgs_received)\n\t\tvirtqueue_kick(vrp->rvq);\n}\n\n \nstatic void rpmsg_xmit_done(struct virtqueue *svq)\n{\n\tstruct virtproc_info *vrp = svq->vdev->priv;\n\n\tdev_dbg(&svq->vdev->dev, \"%s\\n\", __func__);\n\n\t \n\twake_up_interruptible(&vrp->sendq);\n}\n\n \nstatic struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t \n\tvch->vrp = vrp;\n\n\t \n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\t \n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}\n\nstatic void rpmsg_virtio_del_ctrl_dev(struct rpmsg_device *rpdev_ctrl)\n{\n\tif (!rpdev_ctrl)\n\t\treturn;\n\tdevice_unregister(&rpdev_ctrl->dev);\n}\n\nstatic int rpmsg_probe(struct virtio_device *vdev)\n{\n\tvq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };\n\tstatic const char * const names[] = { \"input\", \"output\" };\n\tstruct virtqueue *vqs[2];\n\tstruct virtproc_info *vrp;\n\tstruct virtio_rpmsg_channel *vch = NULL;\n\tstruct rpmsg_device *rpdev_ns, *rpdev_ctrl;\n\tvoid *bufs_va;\n\tint err = 0, i;\n\tsize_t total_buf_space;\n\tbool notify;\n\n\tvrp = kzalloc(sizeof(*vrp), GFP_KERNEL);\n\tif (!vrp)\n\t\treturn -ENOMEM;\n\n\tvrp->vdev = vdev;\n\n\tidr_init(&vrp->endpoints);\n\tmutex_init(&vrp->endpoints_lock);\n\tmutex_init(&vrp->tx_lock);\n\tinit_waitqueue_head(&vrp->sendq);\n\n\t \n\terr = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);\n\tif (err)\n\t\tgoto free_vrp;\n\n\tvrp->rvq = vqs[0];\n\tvrp->svq = vqs[1];\n\n\t \n\tWARN_ON(virtqueue_get_vring_size(vrp->rvq) !=\n\t\tvirtqueue_get_vring_size(vrp->svq));\n\n\t \n\tif (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2)\n\t\tvrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2;\n\telse\n\t\tvrp->num_bufs = MAX_RPMSG_NUM_BUFS;\n\n\tvrp->buf_size = MAX_RPMSG_BUF_SIZE;\n\n\ttotal_buf_space = vrp->num_bufs * vrp->buf_size;\n\n\t \n\tbufs_va = dma_alloc_coherent(vdev->dev.parent,\n\t\t\t\t     total_buf_space, &vrp->bufs_dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!bufs_va) {\n\t\terr = -ENOMEM;\n\t\tgoto vqs_del;\n\t}\n\n\tdev_dbg(&vdev->dev, \"buffers: va %pK, dma %pad\\n\",\n\t\tbufs_va, &vrp->bufs_dma);\n\n\t \n\tvrp->rbufs = bufs_va;\n\n\t \n\tvrp->sbufs = bufs_va + total_buf_space / 2;\n\n\t \n\tfor (i = 0; i < vrp->num_bufs / 2; i++) {\n\t\tstruct scatterlist sg;\n\t\tvoid *cpu_addr = vrp->rbufs + i * vrp->buf_size;\n\n\t\trpmsg_sg_init(&sg, cpu_addr, vrp->buf_size);\n\n\t\terr = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tWARN_ON(err);  \n\t}\n\n\t \n\tvirtqueue_disable_cb(vrp->svq);\n\n\tvdev->priv = vrp;\n\n\trpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev);\n\tif (IS_ERR(rpdev_ctrl)) {\n\t\terr = PTR_ERR(rpdev_ctrl);\n\t\tgoto free_coherent;\n\t}\n\n\t \n\tif (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\t\tif (!vch) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_ctrldev;\n\t\t}\n\n\t\t \n\t\tvch->vrp = vrp;\n\n\t\t \n\t\trpdev_ns = &vch->rpdev;\n\t\trpdev_ns->ops = &virtio_rpmsg_ops;\n\t\trpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\t\trpdev_ns->dev.parent = &vrp->vdev->dev;\n\t\trpdev_ns->dev.release = virtio_rpmsg_release_device;\n\n\t\terr = rpmsg_ns_register_device(rpdev_ns);\n\t\tif (err)\n\t\t\t \n\t\t\tgoto free_ctrldev;\n\t}\n\n\t \n\tnotify = virtqueue_kick_prepare(vrp->rvq);\n\n\t \n\tvirtio_device_ready(vdev);\n\n\t \n\t \n\tif (notify)\n\t\tvirtqueue_notify(vrp->rvq);\n\n\tdev_info(&vdev->dev, \"rpmsg host is online\\n\");\n\n\treturn 0;\n\nfree_ctrldev:\n\trpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\nfree_coherent:\n\tdma_free_coherent(vdev->dev.parent, total_buf_space,\n\t\t\t  bufs_va, vrp->bufs_dma);\nvqs_del:\n\tvdev->config->del_vqs(vrp->vdev);\nfree_vrp:\n\tkfree(vrp);\n\treturn err;\n}\n\nstatic int rpmsg_remove_device(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\n\treturn 0;\n}\n\nstatic void rpmsg_remove(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tsize_t total_buf_space = vrp->num_bufs * vrp->buf_size;\n\tint ret;\n\n\tvirtio_reset_device(vdev);\n\n\tret = device_for_each_child(&vdev->dev, NULL, rpmsg_remove_device);\n\tif (ret)\n\t\tdev_warn(&vdev->dev, \"can't remove rpmsg device: %d\\n\", ret);\n\n\tidr_destroy(&vrp->endpoints);\n\n\tvdev->config->del_vqs(vrp->vdev);\n\n\tdma_free_coherent(vdev->dev.parent, total_buf_space,\n\t\t\t  vrp->rbufs, vrp->bufs_dma);\n\n\tkfree(vrp);\n}\n\nstatic struct virtio_device_id id_table[] = {\n\t{ VIRTIO_ID_RPMSG, VIRTIO_DEV_ANY_ID },\n\t{ 0 },\n};\n\nstatic unsigned int features[] = {\n\tVIRTIO_RPMSG_F_NS,\n};\n\nstatic struct virtio_driver virtio_ipc_driver = {\n\t.feature_table\t= features,\n\t.feature_table_size = ARRAY_SIZE(features),\n\t.driver.name\t= KBUILD_MODNAME,\n\t.driver.owner\t= THIS_MODULE,\n\t.id_table\t= id_table,\n\t.probe\t\t= rpmsg_probe,\n\t.remove\t\t= rpmsg_remove,\n};\n\nstatic int __init rpmsg_init(void)\n{\n\tint ret;\n\n\tret = register_virtio_driver(&virtio_ipc_driver);\n\tif (ret)\n\t\tpr_err(\"failed to register virtio driver: %d\\n\", ret);\n\n\treturn ret;\n}\nsubsys_initcall(rpmsg_init);\n\nstatic void __exit rpmsg_fini(void)\n{\n\tunregister_virtio_driver(&virtio_ipc_driver);\n}\nmodule_exit(rpmsg_fini);\n\nMODULE_DEVICE_TABLE(virtio, id_table);\nMODULE_DESCRIPTION(\"Virtio-based remote processor messaging bus\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}