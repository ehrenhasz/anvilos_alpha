{
  "module_name": "urb.c",
  "hash_id": "f02a49dfa624a26eb3448bd8d7c8214ce8e0a33f8114bb71b580202e4a4b4e45",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/urb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/log2.h>\n#include <linux/kmsan.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/usb/hcd.h>\n#include <linux/scatterlist.h>\n\n#define to_urb(d) container_of(d, struct urb, kref)\n\n\nstatic void urb_destroy(struct kref *kref)\n{\n\tstruct urb *urb = to_urb(kref);\n\n\tif (urb->transfer_flags & URB_FREE_BUFFER)\n\t\tkfree(urb->transfer_buffer);\n\n\tkfree(urb);\n}\n\n \nvoid usb_init_urb(struct urb *urb)\n{\n\tif (urb) {\n\t\tmemset(urb, 0, sizeof(*urb));\n\t\tkref_init(&urb->kref);\n\t\tINIT_LIST_HEAD(&urb->urb_list);\n\t\tINIT_LIST_HEAD(&urb->anchor_list);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_init_urb);\n\n \nstruct urb *usb_alloc_urb(int iso_packets, gfp_t mem_flags)\n{\n\tstruct urb *urb;\n\n\turb = kmalloc(struct_size(urb, iso_frame_desc, iso_packets),\n\t\t      mem_flags);\n\tif (!urb)\n\t\treturn NULL;\n\tusb_init_urb(urb);\n\treturn urb;\n}\nEXPORT_SYMBOL_GPL(usb_alloc_urb);\n\n \nvoid usb_free_urb(struct urb *urb)\n{\n\tif (urb)\n\t\tkref_put(&urb->kref, urb_destroy);\n}\nEXPORT_SYMBOL_GPL(usb_free_urb);\n\n \nstruct urb *usb_get_urb(struct urb *urb)\n{\n\tif (urb)\n\t\tkref_get(&urb->kref);\n\treturn urb;\n}\nEXPORT_SYMBOL_GPL(usb_get_urb);\n\n \nvoid usb_anchor_urb(struct urb *urb, struct usb_anchor *anchor)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&anchor->lock, flags);\n\tusb_get_urb(urb);\n\tlist_add_tail(&urb->anchor_list, &anchor->urb_list);\n\turb->anchor = anchor;\n\n\tif (unlikely(anchor->poisoned))\n\t\tatomic_inc(&urb->reject);\n\n\tspin_unlock_irqrestore(&anchor->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_anchor_urb);\n\nstatic int usb_anchor_check_wakeup(struct usb_anchor *anchor)\n{\n\treturn atomic_read(&anchor->suspend_wakeups) == 0 &&\n\t\tlist_empty(&anchor->urb_list);\n}\n\n \nstatic void __usb_unanchor_urb(struct urb *urb, struct usb_anchor *anchor)\n{\n\turb->anchor = NULL;\n\tlist_del(&urb->anchor_list);\n\tusb_put_urb(urb);\n\tif (usb_anchor_check_wakeup(anchor))\n\t\twake_up(&anchor->wait);\n}\n\n \nvoid usb_unanchor_urb(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_anchor *anchor;\n\n\tif (!urb)\n\t\treturn;\n\n\tanchor = urb->anchor;\n\tif (!anchor)\n\t\treturn;\n\n\tspin_lock_irqsave(&anchor->lock, flags);\n\t \n\tif (likely(anchor == urb->anchor))\n\t\t__usb_unanchor_urb(urb, anchor);\n\tspin_unlock_irqrestore(&anchor->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_unanchor_urb);\n\n \n\nstatic const int pipetypes[4] = {\n\tPIPE_CONTROL, PIPE_ISOCHRONOUS, PIPE_BULK, PIPE_INTERRUPT\n};\n\n \nint usb_pipe_type_check(struct usb_device *dev, unsigned int pipe)\n{\n\tconst struct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (!ep)\n\t\treturn -EINVAL;\n\tif (usb_pipetype(pipe) != pipetypes[usb_endpoint_type(&ep->desc)])\n\t\treturn -EINVAL;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_pipe_type_check);\n\n \nint usb_urb_ep_type_check(const struct urb *urb)\n{\n\treturn usb_pipe_type_check(urb->dev, urb->pipe);\n}\nEXPORT_SYMBOL_GPL(usb_urb_ep_type_check);\n\n \nint usb_submit_urb(struct urb *urb, gfp_t mem_flags)\n{\n\tint\t\t\t\txfertype, max;\n\tstruct usb_device\t\t*dev;\n\tstruct usb_host_endpoint\t*ep;\n\tint\t\t\t\tis_out;\n\tunsigned int\t\t\tallowed;\n\n\tif (!urb || !urb->complete)\n\t\treturn -EINVAL;\n\tif (urb->hcpriv) {\n\t\tWARN_ONCE(1, \"URB %pK submitted while active\\n\", urb);\n\t\treturn -EBUSY;\n\t}\n\n\tdev = urb->dev;\n\tif ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))\n\t\treturn -ENODEV;\n\n\t \n\tep = usb_pipe_endpoint(dev, urb->pipe);\n\tif (!ep)\n\t\treturn -ENOENT;\n\n\turb->ep = ep;\n\turb->status = -EINPROGRESS;\n\turb->actual_length = 0;\n\n\t \n\txfertype = usb_endpoint_type(&ep->desc);\n\tif (xfertype == USB_ENDPOINT_XFER_CONTROL) {\n\t\tstruct usb_ctrlrequest *setup =\n\t\t\t\t(struct usb_ctrlrequest *) urb->setup_packet;\n\n\t\tif (!setup)\n\t\t\treturn -ENOEXEC;\n\t\tis_out = !(setup->bRequestType & USB_DIR_IN) ||\n\t\t\t\t!setup->wLength;\n\t\tdev_WARN_ONCE(&dev->dev, (usb_pipeout(urb->pipe) != is_out),\n\t\t\t\t\"BOGUS control dir, pipe %x doesn't match bRequestType %x\\n\",\n\t\t\t\turb->pipe, setup->bRequestType);\n\t\tif (le16_to_cpu(setup->wLength) != urb->transfer_buffer_length) {\n\t\t\tdev_dbg(&dev->dev, \"BOGUS control len %d doesn't match transfer length %d\\n\",\n\t\t\t\t\tle16_to_cpu(setup->wLength),\n\t\t\t\t\turb->transfer_buffer_length);\n\t\t\treturn -EBADR;\n\t\t}\n\t} else {\n\t\tis_out = usb_endpoint_dir_out(&ep->desc);\n\t}\n\n\t \n\turb->transfer_flags &= ~(URB_DIR_MASK | URB_DMA_MAP_SINGLE |\n\t\t\tURB_DMA_MAP_PAGE | URB_DMA_MAP_SG | URB_MAP_LOCAL |\n\t\t\tURB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL |\n\t\t\tURB_DMA_SG_COMBINED);\n\turb->transfer_flags |= (is_out ? URB_DIR_OUT : URB_DIR_IN);\n\tkmsan_handle_urb(urb, is_out);\n\n\tif (xfertype != USB_ENDPOINT_XFER_CONTROL &&\n\t\t\tdev->state < USB_STATE_CONFIGURED)\n\t\treturn -ENODEV;\n\n\tmax = usb_endpoint_maxp(&ep->desc);\n\tif (max <= 0) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"bogus endpoint ep%d%s in %s (bad maxpacket %d)\\n\",\n\t\t\tusb_endpoint_num(&ep->desc), is_out ? \"out\" : \"in\",\n\t\t\t__func__, max);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\tint\tn, len;\n\n\t\t \n\t\tif (dev->speed >= USB_SPEED_SUPER) {\n\t\t\tint     burst = 1 + ep->ss_ep_comp.bMaxBurst;\n\t\t\tint     mult = USB_SS_MULT(ep->ss_ep_comp.bmAttributes);\n\t\t\tmax *= burst;\n\t\t\tmax *= mult;\n\t\t}\n\n\t\tif (dev->speed == USB_SPEED_SUPER_PLUS &&\n\t\t    USB_SS_SSP_ISOC_COMP(ep->ss_ep_comp.bmAttributes)) {\n\t\t\tstruct usb_ssp_isoc_ep_comp_descriptor *isoc_ep_comp;\n\n\t\t\tisoc_ep_comp = &ep->ssp_isoc_ep_comp;\n\t\t\tmax = le32_to_cpu(isoc_ep_comp->dwBytesPerInterval);\n\t\t}\n\n\t\t \n\t\tif (dev->speed == USB_SPEED_HIGH)\n\t\t\tmax *= usb_endpoint_maxp_mult(&ep->desc);\n\n\t\tif (urb->number_of_packets <= 0)\n\t\t\treturn -EINVAL;\n\t\tfor (n = 0; n < urb->number_of_packets; n++) {\n\t\t\tlen = urb->iso_frame_desc[n].length;\n\t\t\tif (len < 0 || len > max)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\turb->iso_frame_desc[n].status = -EXDEV;\n\t\t\turb->iso_frame_desc[n].actual_length = 0;\n\t\t}\n\t} else if (urb->num_sgs && !urb->dev->bus->no_sg_constraint) {\n\t\tstruct scatterlist *sg;\n\t\tint i;\n\n\t\tfor_each_sg(urb->sg, sg, urb->num_sgs - 1, i)\n\t\t\tif (sg->length % max)\n\t\t\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (urb->transfer_buffer_length > INT_MAX)\n\t\treturn -EMSGSIZE;\n\n\t \n\n\t \n\tif (usb_pipe_type_check(urb->dev, urb->pipe))\n\t\tdev_WARN(&dev->dev, \"BOGUS urb xfer, pipe %x != type %x\\n\",\n\t\t\tusb_pipetype(urb->pipe), pipetypes[xfertype]);\n\n\t \n\tallowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT | URB_DIR_MASK |\n\t\t\tURB_FREE_BUFFER);\n\tswitch (xfertype) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (is_out)\n\t\t\tallowed |= URB_ZERO_PACKET;\n\t\tfallthrough;\n\tdefault:\t\t\t \n\t\tif (!is_out)\n\t\t\tallowed |= URB_SHORT_NOT_OK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tallowed |= URB_ISO_ASAP;\n\t\tbreak;\n\t}\n\tallowed &= urb->transfer_flags;\n\n\t \n\tif (allowed != urb->transfer_flags)\n\t\tdev_WARN(&dev->dev, \"BOGUS urb flags, %x --> %x\\n\",\n\t\t\turb->transfer_flags, allowed);\n\n\t \n\tswitch (xfertype) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t \n\t\tif (urb->interval <= 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tswitch (dev->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\t \n\t\t\t \n\t\t\tif (urb->interval > (1 << 15))\n\t\t\t\treturn -EINVAL;\n\t\t\tmax = 1 << 15;\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\t \n\t\t\t \n\t\t\tif (urb->interval > (1024 * 8))\n\t\t\t\turb->interval = 1024 * 8;\n\t\t\tmax = 1024 * 8;\n\t\t\tbreak;\n\t\tcase USB_SPEED_FULL:\t \n\t\tcase USB_SPEED_LOW:\n\t\t\tif (xfertype == USB_ENDPOINT_XFER_INT) {\n\t\t\t\tif (urb->interval > 255)\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t \n\t\t\t\tmax = 128;\n\t\t\t} else {\n\t\t\t\tif (urb->interval > 1024)\n\t\t\t\t\turb->interval = 1024;\n\t\t\t\t \n\t\t\t\tmax = 1024;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\turb->interval = min(max, 1 << ilog2(urb->interval));\n\t}\n\n\treturn usb_hcd_submit_urb(urb, mem_flags);\n}\nEXPORT_SYMBOL_GPL(usb_submit_urb);\n\n \n\n \nint usb_unlink_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn -EINVAL;\n\tif (!urb->dev)\n\t\treturn -ENODEV;\n\tif (!urb->ep)\n\t\treturn -EIDRM;\n\treturn usb_hcd_unlink_urb(urb, -ECONNRESET);\n}\nEXPORT_SYMBOL_GPL(usb_unlink_urb);\n\n \nvoid usb_kill_urb(struct urb *urb)\n{\n\tmight_sleep();\n\tif (!(urb && urb->dev && urb->ep))\n\t\treturn;\n\tatomic_inc(&urb->reject);\n\t \n\tsmp_mb__after_atomic();\n\n\tusb_hcd_unlink_urb(urb, -ENOENT);\n\twait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);\n\n\tatomic_dec(&urb->reject);\n}\nEXPORT_SYMBOL_GPL(usb_kill_urb);\n\n \nvoid usb_poison_urb(struct urb *urb)\n{\n\tmight_sleep();\n\tif (!urb)\n\t\treturn;\n\tatomic_inc(&urb->reject);\n\t \n\tsmp_mb__after_atomic();\n\n\tif (!urb->dev || !urb->ep)\n\t\treturn;\n\n\tusb_hcd_unlink_urb(urb, -ENOENT);\n\twait_event(usb_kill_urb_queue, atomic_read(&urb->use_count) == 0);\n}\nEXPORT_SYMBOL_GPL(usb_poison_urb);\n\nvoid usb_unpoison_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\n\tatomic_dec(&urb->reject);\n}\nEXPORT_SYMBOL_GPL(usb_unpoison_urb);\n\n \nvoid usb_block_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\n\tatomic_inc(&urb->reject);\n}\nEXPORT_SYMBOL_GPL(usb_block_urb);\n\n \nvoid usb_kill_anchored_urbs(struct usb_anchor *anchor)\n{\n\tstruct urb *victim;\n\tint surely_empty;\n\n\tdo {\n\t\tspin_lock_irq(&anchor->lock);\n\t\twhile (!list_empty(&anchor->urb_list)) {\n\t\t\tvictim = list_entry(anchor->urb_list.prev,\n\t\t\t\t\t    struct urb, anchor_list);\n\t\t\t \n\t\t\tusb_get_urb(victim);\n\t\t\tspin_unlock_irq(&anchor->lock);\n\t\t\t \n\t\t\tusb_kill_urb(victim);\n\t\t\tusb_put_urb(victim);\n\t\t\tspin_lock_irq(&anchor->lock);\n\t\t}\n\t\tsurely_empty = usb_anchor_check_wakeup(anchor);\n\n\t\tspin_unlock_irq(&anchor->lock);\n\t\tcpu_relax();\n\t} while (!surely_empty);\n}\nEXPORT_SYMBOL_GPL(usb_kill_anchored_urbs);\n\n\n \nvoid usb_poison_anchored_urbs(struct usb_anchor *anchor)\n{\n\tstruct urb *victim;\n\tint surely_empty;\n\n\tdo {\n\t\tspin_lock_irq(&anchor->lock);\n\t\tanchor->poisoned = 1;\n\t\twhile (!list_empty(&anchor->urb_list)) {\n\t\t\tvictim = list_entry(anchor->urb_list.prev,\n\t\t\t\t\t    struct urb, anchor_list);\n\t\t\t \n\t\t\tusb_get_urb(victim);\n\t\t\tspin_unlock_irq(&anchor->lock);\n\t\t\t \n\t\t\tusb_poison_urb(victim);\n\t\t\tusb_put_urb(victim);\n\t\t\tspin_lock_irq(&anchor->lock);\n\t\t}\n\t\tsurely_empty = usb_anchor_check_wakeup(anchor);\n\n\t\tspin_unlock_irq(&anchor->lock);\n\t\tcpu_relax();\n\t} while (!surely_empty);\n}\nEXPORT_SYMBOL_GPL(usb_poison_anchored_urbs);\n\n \nvoid usb_unpoison_anchored_urbs(struct usb_anchor *anchor)\n{\n\tunsigned long flags;\n\tstruct urb *lazarus;\n\n\tspin_lock_irqsave(&anchor->lock, flags);\n\tlist_for_each_entry(lazarus, &anchor->urb_list, anchor_list) {\n\t\tusb_unpoison_urb(lazarus);\n\t}\n\tanchor->poisoned = 0;\n\tspin_unlock_irqrestore(&anchor->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_unpoison_anchored_urbs);\n \nvoid usb_unlink_anchored_urbs(struct usb_anchor *anchor)\n{\n\tstruct urb *victim;\n\n\twhile ((victim = usb_get_from_anchor(anchor)) != NULL) {\n\t\tusb_unlink_urb(victim);\n\t\tusb_put_urb(victim);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_unlink_anchored_urbs);\n\n \nvoid usb_anchor_suspend_wakeups(struct usb_anchor *anchor)\n{\n\tif (anchor)\n\t\tatomic_inc(&anchor->suspend_wakeups);\n}\nEXPORT_SYMBOL_GPL(usb_anchor_suspend_wakeups);\n\n \nvoid usb_anchor_resume_wakeups(struct usb_anchor *anchor)\n{\n\tif (!anchor)\n\t\treturn;\n\n\tatomic_dec(&anchor->suspend_wakeups);\n\tif (usb_anchor_check_wakeup(anchor))\n\t\twake_up(&anchor->wait);\n}\nEXPORT_SYMBOL_GPL(usb_anchor_resume_wakeups);\n\n \nint usb_wait_anchor_empty_timeout(struct usb_anchor *anchor,\n\t\t\t\t  unsigned int timeout)\n{\n\treturn wait_event_timeout(anchor->wait,\n\t\t\t\t  usb_anchor_check_wakeup(anchor),\n\t\t\t\t  msecs_to_jiffies(timeout));\n}\nEXPORT_SYMBOL_GPL(usb_wait_anchor_empty_timeout);\n\n \nstruct urb *usb_get_from_anchor(struct usb_anchor *anchor)\n{\n\tstruct urb *victim;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&anchor->lock, flags);\n\tif (!list_empty(&anchor->urb_list)) {\n\t\tvictim = list_entry(anchor->urb_list.next, struct urb,\n\t\t\t\t    anchor_list);\n\t\tusb_get_urb(victim);\n\t\t__usb_unanchor_urb(victim, anchor);\n\t} else {\n\t\tvictim = NULL;\n\t}\n\tspin_unlock_irqrestore(&anchor->lock, flags);\n\n\treturn victim;\n}\n\nEXPORT_SYMBOL_GPL(usb_get_from_anchor);\n\n \nvoid usb_scuttle_anchored_urbs(struct usb_anchor *anchor)\n{\n\tstruct urb *victim;\n\tunsigned long flags;\n\tint surely_empty;\n\n\tdo {\n\t\tspin_lock_irqsave(&anchor->lock, flags);\n\t\twhile (!list_empty(&anchor->urb_list)) {\n\t\t\tvictim = list_entry(anchor->urb_list.prev,\n\t\t\t\t\t    struct urb, anchor_list);\n\t\t\t__usb_unanchor_urb(victim, anchor);\n\t\t}\n\t\tsurely_empty = usb_anchor_check_wakeup(anchor);\n\n\t\tspin_unlock_irqrestore(&anchor->lock, flags);\n\t\tcpu_relax();\n\t} while (!surely_empty);\n}\n\nEXPORT_SYMBOL_GPL(usb_scuttle_anchored_urbs);\n\n \nint usb_anchor_empty(struct usb_anchor *anchor)\n{\n\treturn list_empty(&anchor->urb_list);\n}\n\nEXPORT_SYMBOL_GPL(usb_anchor_empty);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}