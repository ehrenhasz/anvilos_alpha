{
  "module_name": "generic.c",
  "hash_id": "0f36cee6e1f966647d79cb72c76913259a720c412ec29b85dd5058e49eedf389",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/generic.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <uapi/linux/usb/audio.h>\n#include \"usb.h\"\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int is_rndis(struct usb_interface_descriptor *desc)\n{\n\treturn desc->bInterfaceClass == USB_CLASS_COMM\n\t\t&& desc->bInterfaceSubClass == 2\n\t\t&& desc->bInterfaceProtocol == 0xff;\n}\n\nstatic int is_activesync(struct usb_interface_descriptor *desc)\n{\n\treturn desc->bInterfaceClass == USB_CLASS_MISC\n\t\t&& desc->bInterfaceSubClass == 1\n\t\t&& desc->bInterfaceProtocol == 1;\n}\n\nstatic bool is_audio(struct usb_interface_descriptor *desc)\n{\n\treturn desc->bInterfaceClass == USB_CLASS_AUDIO;\n}\n\nstatic bool is_uac3_config(struct usb_interface_descriptor *desc)\n{\n\treturn desc->bInterfaceProtocol == UAC_VERSION_3;\n}\n\nint usb_choose_configuration(struct usb_device *udev)\n{\n\tint i;\n\tint num_configs;\n\tint insufficient_power = 0;\n\tstruct usb_host_config *c, *best;\n\n\tif (usb_device_is_owned(udev))\n\t\treturn 0;\n\n\tbest = NULL;\n\tc = udev->config;\n\tnum_configs = udev->descriptor.bNumConfigurations;\n\tfor (i = 0; i < num_configs; (i++, c++)) {\n\t\tstruct usb_interface_descriptor\t*desc = NULL;\n\n\t\t \n\t\tif (c->desc.bNumInterfaces > 0)\n\t\t\tdesc = &c->intf_cache[0]->altsetting->desc;\n\n\t\t \n#if 0\n\t\t \n\t\tif (bus_powered && (c->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_SELFPOWER))\n\t\t\tcontinue;\n#endif\n\n\t\t \n\n\t\t \n\t\tif (usb_get_max_power(udev, c) > udev->bus_mA) {\n\t\t\tinsufficient_power++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (desc && is_audio(desc)) {\n\t\t\t \n\t\t\tif (is_uac3_config(desc)) {\n\t\t\t\tbest = c;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (i == 0)\n\t\t\t\tbest = c;\n\n\t\t\t \n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (i == 0 && num_configs > 1 && desc &&\n\t\t\t\t(is_rndis(desc) || is_activesync(desc))) {\n#if !defined(CONFIG_USB_NET_RNDIS_HOST) && !defined(CONFIG_USB_NET_RNDIS_HOST_MODULE)\n\t\t\tcontinue;\n#else\n\t\t\tbest = c;\n#endif\n\t\t}\n\n\t\t \n\t\telse if (udev->descriptor.bDeviceClass !=\n\t\t\t\t\t\tUSB_CLASS_VENDOR_SPEC &&\n\t\t\t\t(desc && desc->bInterfaceClass !=\n\t\t\t\t\t\tUSB_CLASS_VENDOR_SPEC)) {\n\t\t\tbest = c;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\telse if (!best)\n\t\t\tbest = c;\n\t}\n\n\tif (insufficient_power > 0)\n\t\tdev_info(&udev->dev, \"rejected %d configuration%s \"\n\t\t\t\"due to insufficient available bus power\\n\",\n\t\t\tinsufficient_power, plural(insufficient_power));\n\n\tif (best) {\n\t\ti = best->desc.bConfigurationValue;\n\t\tdev_dbg(&udev->dev,\n\t\t\t\"configuration #%d chosen from %d choice%s\\n\",\n\t\t\ti, num_configs, plural(num_configs));\n\t} else {\n\t\ti = -1;\n\t\tdev_warn(&udev->dev,\n\t\t\t\"no configuration chosen from %d choice%s\\n\",\n\t\t\tnum_configs, plural(num_configs));\n\t}\n\treturn i;\n}\nEXPORT_SYMBOL_GPL(usb_choose_configuration);\n\nstatic int __check_for_non_generic_match(struct device_driver *drv, void *data)\n{\n\tstruct usb_device *udev = data;\n\tstruct usb_device_driver *udrv;\n\n\tif (!is_usb_device_driver(drv))\n\t\treturn 0;\n\tudrv = to_usb_device_driver(drv);\n\tif (udrv == &usb_generic_driver)\n\t\treturn 0;\n\treturn usb_driver_applicable(udev, udrv);\n}\n\nstatic bool usb_generic_driver_match(struct usb_device *udev)\n{\n\tif (udev->use_generic_driver)\n\t\treturn true;\n\n\t \n\tif (bus_for_each_drv(&usb_bus_type, NULL, udev, __check_for_non_generic_match))\n\t\treturn false;\n\n\treturn true;\n}\n\nint usb_generic_driver_probe(struct usb_device *udev)\n{\n\tint err, c;\n\n\t \n\tif (udev->authorized == 0)\n\t\tdev_err(&udev->dev, \"Device is not authorized for usage\\n\");\n\telse {\n\t\tc = usb_choose_configuration(udev);\n\t\tif (c >= 0) {\n\t\t\terr = usb_set_configuration(udev, c);\n\t\t\tif (err && err != -ENODEV) {\n\t\t\t\tdev_err(&udev->dev, \"can't set config #%d, error %d\\n\",\n\t\t\t\t\tc, err);\n\t\t\t\t \n\t\t\t}\n\t\t}\n\t}\n\t \n\tusb_notify_add_device(udev);\n\n\treturn 0;\n}\n\nvoid usb_generic_driver_disconnect(struct usb_device *udev)\n{\n\tusb_notify_remove_device(udev);\n\n\t \n\tif (udev->actconfig)\n\t\tusb_set_configuration(udev, -1);\n}\n\n#ifdef\tCONFIG_PM\n\nint usb_generic_driver_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tint rc;\n\n\t \n\tif (!udev->parent)\n\t\trc = hcd_bus_suspend(udev, msg);\n\n\t \n\telse if ((msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_PRETHAW)\n\t\t && (udev->speed < USB_SPEED_SUPER))\n\t\trc = 0;\n\telse\n\t\trc = usb_port_suspend(udev, msg);\n\n\tif (rc == 0)\n\t\tusbfs_notify_suspend(udev);\n\treturn rc;\n}\n\nint usb_generic_driver_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tint rc;\n\n\t \n\tif (!udev->parent)\n\t\trc = hcd_bus_resume(udev, msg);\n\telse\n\t\trc = usb_port_resume(udev, msg);\n\n\tif (rc == 0)\n\t\tusbfs_notify_resume(udev);\n\treturn rc;\n}\n\n#endif\t \n\nstruct usb_device_driver usb_generic_driver = {\n\t.name =\t\"usb\",\n\t.match = usb_generic_driver_match,\n\t.probe = usb_generic_driver_probe,\n\t.disconnect = usb_generic_driver_disconnect,\n#ifdef\tCONFIG_PM\n\t.suspend = usb_generic_driver_suspend,\n\t.resume = usb_generic_driver_resume,\n#endif\n\t.supports_autosuspend = 1,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}