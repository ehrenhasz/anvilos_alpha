{
  "module_name": "usb-acpi.c",
  "hash_id": "80d6ff10956adce553a15b57b1af1e97e6e6419126f1b8b8873091e55fb72bcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/usb-acpi.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/device.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/acpi.h>\n#include <linux/pci.h>\n#include <linux/usb/hcd.h>\n\n#include \"hub.h\"\n\n \nbool usb_acpi_power_manageable(struct usb_device *hdev, int index)\n{\n\tacpi_handle port_handle;\n\tint port1 = index + 1;\n\n\tport_handle = usb_get_hub_port_acpi_handle(hdev,\n\t\tport1);\n\tif (port_handle)\n\t\treturn acpi_bus_power_manageable(port_handle);\n\telse\n\t\treturn false;\n}\nEXPORT_SYMBOL_GPL(usb_acpi_power_manageable);\n\n#define UUID_USB_CONTROLLER_DSM \"ce2ee385-00e6-48cb-9f05-2edb927c4899\"\n#define USB_DSM_DISABLE_U1_U2_FOR_PORT\t5\n\n \n\nint usb_acpi_port_lpm_incapable(struct usb_device *hdev, int index)\n{\n\tunion acpi_object *obj;\n\tacpi_handle port_handle;\n\tint port1 = index + 1;\n\tguid_t guid;\n\tint ret;\n\n\tret = guid_parse(UUID_USB_CONTROLLER_DSM, &guid);\n\tif (ret)\n\t\treturn ret;\n\n\tport_handle = usb_get_hub_port_acpi_handle(hdev, port1);\n\tif (!port_handle) {\n\t\tdev_dbg(&hdev->dev, \"port-%d no acpi handle\\n\", port1);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!acpi_check_dsm(port_handle, &guid, 0,\n\t\t\t    BIT(USB_DSM_DISABLE_U1_U2_FOR_PORT))) {\n\t\tdev_dbg(&hdev->dev, \"port-%d no _DSM function %d\\n\",\n\t\t\tport1, USB_DSM_DISABLE_U1_U2_FOR_PORT);\n\t\treturn -ENODEV;\n\t}\n\n\tobj = acpi_evaluate_dsm_typed(port_handle, &guid, 0,\n\t\t\t\t      USB_DSM_DISABLE_U1_U2_FOR_PORT, NULL,\n\t\t\t\t      ACPI_TYPE_INTEGER);\n\tif (!obj) {\n\t\tdev_dbg(&hdev->dev, \"evaluate port-%d _DSM failed\\n\", port1);\n\t\treturn -EINVAL;\n\t}\n\n\tif (obj->integer.value == 0x01)\n\t\tret = 1;\n\n\tACPI_FREE(obj);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_acpi_port_lpm_incapable);\n\n \nint usb_acpi_set_power_state(struct usb_device *hdev, int index, bool enable)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_port *port_dev;\n\tacpi_handle port_handle;\n\tunsigned char state;\n\tint port1 = index + 1;\n\tint error = -EINVAL;\n\n\tif (!hub)\n\t\treturn -ENODEV;\n\tport_dev = hub->ports[port1 - 1];\n\n\tport_handle = (acpi_handle) usb_get_hub_port_acpi_handle(hdev, port1);\n\tif (!port_handle)\n\t\treturn error;\n\n\tif (enable)\n\t\tstate = ACPI_STATE_D0;\n\telse\n\t\tstate = ACPI_STATE_D3_COLD;\n\n\terror = acpi_bus_set_power(port_handle, state);\n\tif (!error)\n\t\tdev_dbg(&port_dev->dev, \"acpi: power was set to %d\\n\", enable);\n\telse\n\t\tdev_dbg(&port_dev->dev, \"acpi: power failed to be set\\n\");\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(usb_acpi_set_power_state);\n\nstatic enum usb_port_connect_type usb_acpi_get_connect_type(acpi_handle handle,\n\t\tstruct acpi_pld_info *pld)\n{\n\tenum usb_port_connect_type connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\tstruct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };\n\tunion acpi_object *upc = NULL;\n\tacpi_status status;\n\n\t \n\tstatus = acpi_evaluate_object(handle, \"_UPC\", NULL, &buffer);\n\tif (ACPI_FAILURE(status))\n\t\tgoto out;\n\n\tupc = buffer.pointer;\n\tif (!upc || (upc->type != ACPI_TYPE_PACKAGE) || upc->package.count != 4)\n\t\tgoto out;\n\n\tif (upc->package.elements[0].integer.value)\n\t\tif (pld->user_visible)\n\t\t\tconnect_type = USB_PORT_CONNECT_TYPE_HOT_PLUG;\n\t\telse\n\t\t\tconnect_type = USB_PORT_CONNECT_TYPE_HARD_WIRED;\n\telse if (!pld->user_visible)\n\t\tconnect_type = USB_PORT_NOT_USED;\nout:\n\tkfree(upc);\n\treturn connect_type;\n}\n\n\n \n#define USB_ACPI_LOCATION_VALID (1 << 31)\n\nstatic struct acpi_device *\nusb_acpi_get_companion_for_port(struct usb_port *port_dev)\n{\n\tstruct usb_device *udev;\n\tstruct acpi_device *adev;\n\tacpi_handle *parent_handle;\n\tint port1;\n\n\t \n\tudev = to_usb_device(port_dev->dev.parent->parent);\n\n\t \n\tif (!udev->parent) {\n\t\tadev = ACPI_COMPANION(&udev->dev);\n\t\tport1 = usb_hcd_find_raw_port_number(bus_to_hcd(udev->bus),\n\t\t\t\t\t\t     port_dev->portnum);\n\t} else {\n\t\tparent_handle = usb_get_hub_port_acpi_handle(udev->parent,\n\t\t\t\t\t\t\t     udev->portnum);\n\t\tif (!parent_handle)\n\t\t\treturn NULL;\n\n\t\tadev = acpi_fetch_acpi_dev(parent_handle);\n\t\tport1 = port_dev->portnum;\n\t}\n\n\treturn acpi_find_child_by_adr(adev, port1);\n}\n\nstatic struct acpi_device *\nusb_acpi_find_companion_for_port(struct usb_port *port_dev)\n{\n\tstruct acpi_device *adev;\n\tstruct acpi_pld_info *pld;\n\tacpi_handle *handle;\n\tacpi_status status;\n\n\tadev = usb_acpi_get_companion_for_port(port_dev);\n\tif (!adev)\n\t\treturn NULL;\n\n\thandle = adev->handle;\n\tstatus = acpi_get_physical_device_location(handle, &pld);\n\tif (ACPI_SUCCESS(status) && pld) {\n\t\tport_dev->location = USB_ACPI_LOCATION_VALID\n\t\t\t| pld->group_token << 8 | pld->group_position;\n\t\tport_dev->connect_type = usb_acpi_get_connect_type(handle, pld);\n\t\tACPI_FREE(pld);\n\t}\n\n\treturn adev;\n}\n\nstatic struct acpi_device *\nusb_acpi_find_companion_for_device(struct usb_device *udev)\n{\n\tstruct acpi_device *adev;\n\tstruct usb_port *port_dev;\n\tstruct usb_hub *hub;\n\n\tif (!udev->parent) {\n\t\t \n\t\tadev = ACPI_COMPANION(udev->bus->sysdev);\n\t\treturn acpi_find_child_device(adev, 0, false);\n\t}\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tif (!hub)\n\t\treturn NULL;\n\n\t \n\tport_dev = hub->ports[udev->portnum - 1];\n\treturn usb_acpi_get_companion_for_port(port_dev);\n}\n\nstatic struct acpi_device *usb_acpi_find_companion(struct device *dev)\n{\n\t \n\tif (is_usb_device(dev))\n\t\treturn usb_acpi_find_companion_for_device(to_usb_device(dev));\n\telse if (is_usb_port(dev))\n\t\treturn usb_acpi_find_companion_for_port(to_usb_port(dev));\n\n\treturn NULL;\n}\n\nstatic bool usb_acpi_bus_match(struct device *dev)\n{\n\treturn is_usb_device(dev) || is_usb_port(dev);\n}\n\nstatic struct acpi_bus_type usb_acpi_bus = {\n\t.name = \"USB\",\n\t.match = usb_acpi_bus_match,\n\t.find_companion = usb_acpi_find_companion,\n};\n\nint usb_acpi_register(void)\n{\n\treturn register_acpi_bus_type(&usb_acpi_bus);\n}\n\nvoid usb_acpi_unregister(void)\n{\n\tunregister_acpi_bus_type(&usb_acpi_bus);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}