{
  "module_name": "otg_productlist.h",
  "hash_id": "ea16892e4f2a378e5f58748f86a3ca624c0bc9785fe0779a1aa304b80e336657",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/otg_productlist.h",
  "human_readable_source": " \n \n\n \n\nstatic struct usb_device_id productlist_table[] = {\n\n \n{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 0), },\n{ USB_DEVICE_INFO(USB_CLASS_HUB, 0, 1), },\n\n#ifdef\tCONFIG_USB_PRINTER\t\t \n \n{ USB_DEVICE_INFO(7, 1, 1) },\n{ USB_DEVICE_INFO(7, 1, 2) },\n{ USB_DEVICE_INFO(7, 1, 3) },\n#endif\n\n#ifdef\tCONFIG_USB_NET_CDCETHER\n \n{ USB_DEVICE(0x0525, 0xa4a1), },\n \n{ USB_DEVICE(0x0525, 0xa4a2), },\n#endif\n\n#if\tIS_ENABLED(CONFIG_USB_TEST)\n \n{ USB_DEVICE(0x0525, 0xa4a0), },\n#endif\n\n{ }\t \n};\n\nstatic int is_targeted(struct usb_device *dev)\n{\n\tstruct usb_device_id\t*id = productlist_table;\n\n\t \n\tif ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&\n\t     le16_to_cpu(dev->descriptor.idProduct) == 0xbadd))\n\t\treturn 0;\n\n\t \n\tif ((le16_to_cpu(dev->descriptor.idVendor) == 0x1a0a &&\n\t     le16_to_cpu(dev->descriptor.idProduct) == 0x0200))\n\t\treturn 1;\n\n\t \n\tfor (id = productlist_table; id->match_flags; id++) {\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&\n\t\t    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&\n\t\t    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))\n\t\t\tcontinue;\n\n\t\t \n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&\n\t\t    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&\n\t\t    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&\n\t\t    (id->bDeviceClass != dev->descriptor.bDeviceClass))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&\n\t\t    (id->bDeviceSubClass != dev->descriptor.bDeviceSubClass))\n\t\t\tcontinue;\n\n\t\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&\n\t\t    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))\n\t\t\tcontinue;\n\n\t\treturn 1;\n\t}\n\n\t \n\n\n\t \n\tdev_err(&dev->dev, \"device v%04x p%04x is not supported\\n\",\n\t\tle16_to_cpu(dev->descriptor.idVendor),\n\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\treturn 0;\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}