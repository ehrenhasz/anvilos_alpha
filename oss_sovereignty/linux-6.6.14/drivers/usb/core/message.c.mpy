{
  "module_name": "message.c",
  "hash_id": "268354ebeb7ccb00278f01212d47cc235df79965f9296c477ae4553f9b1a455b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/message.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/pci.h>\t \n#include <linux/usb.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/timer.h>\n#include <linux/ctype.h>\n#include <linux/nls.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/quirks.h>\n#include <linux/usb/hcd.h>\t \n#include <linux/usb/of.h>\n#include <asm/byteorder.h>\n\n#include \"usb.h\"\n\nstatic void cancel_async_set_config(struct usb_device *udev);\n\nstruct api_context {\n\tstruct completion\tdone;\n\tint\t\t\tstatus;\n};\n\nstatic void usb_api_blocking_completion(struct urb *urb)\n{\n\tstruct api_context *ctx = urb->context;\n\n\tctx->status = urb->status;\n\tcomplete(&ctx->done);\n}\n\n\n \nstatic int usb_start_wait_urb(struct urb *urb, int timeout, int *actual_length)\n{\n\tstruct api_context ctx;\n\tunsigned long expire;\n\tint retval;\n\n\tinit_completion(&ctx.done);\n\turb->context = &ctx;\n\turb->actual_length = 0;\n\tretval = usb_submit_urb(urb, GFP_NOIO);\n\tif (unlikely(retval))\n\t\tgoto out;\n\n\texpire = timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT;\n\tif (!wait_for_completion_timeout(&ctx.done, expire)) {\n\t\tusb_kill_urb(urb);\n\t\tretval = (ctx.status == -ENOENT ? -ETIMEDOUT : ctx.status);\n\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s timed out on ep%d%s len=%u/%u\\n\",\n\t\t\tcurrent->comm,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\turb->actual_length,\n\t\t\turb->transfer_buffer_length);\n\t} else\n\t\tretval = ctx.status;\nout:\n\tif (actual_length)\n\t\t*actual_length = urb->actual_length;\n\n\tusb_free_urb(urb);\n\treturn retval;\n}\n\n \n \nstatic int usb_internal_control_msg(struct usb_device *usb_dev,\n\t\t\t\t    unsigned int pipe,\n\t\t\t\t    struct usb_ctrlrequest *cmd,\n\t\t\t\t    void *data, int len, int timeout)\n{\n\tstruct urb *urb;\n\tint retv;\n\tint length;\n\n\turb = usb_alloc_urb(0, GFP_NOIO);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_control_urb(urb, usb_dev, pipe, (unsigned char *)cmd, data,\n\t\t\t     len, usb_api_blocking_completion, NULL);\n\n\tretv = usb_start_wait_urb(urb, timeout, &length);\n\tif (retv < 0)\n\t\treturn retv;\n\telse\n\t\treturn length;\n}\n\n \nint usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,\n\t\t    __u8 requesttype, __u16 value, __u16 index, void *data,\n\t\t    __u16 size, int timeout)\n{\n\tstruct usb_ctrlrequest *dr;\n\tint ret;\n\n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\n\tif (!dr)\n\t\treturn -ENOMEM;\n\n\tdr->bRequestType = requesttype;\n\tdr->bRequest = request;\n\tdr->wValue = cpu_to_le16(value);\n\tdr->wIndex = cpu_to_le16(index);\n\tdr->wLength = cpu_to_le16(size);\n\n\tret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);\n\n\t \n\tif (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)\n\t\tmsleep(200);\n\n\tkfree(dr);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_control_msg);\n\n \nint usb_control_msg_send(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t const void *driver_data, __u16 size, int timeout,\n\t\t\t gfp_t memflags)\n{\n\tunsigned int pipe = usb_sndctrlpipe(dev, endpoint);\n\tint ret;\n\tu8 *data = NULL;\n\n\tif (size) {\n\t\tdata = kmemdup(driver_data, size, memflags);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tret = usb_control_msg(dev, pipe, request, requesttype, value, index,\n\t\t\t      data, size, timeout);\n\tkfree(data);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_control_msg_send);\n\n \nint usb_control_msg_recv(struct usb_device *dev, __u8 endpoint, __u8 request,\n\t\t\t __u8 requesttype, __u16 value, __u16 index,\n\t\t\t void *driver_data, __u16 size, int timeout,\n\t\t\t gfp_t memflags)\n{\n\tunsigned int pipe = usb_rcvctrlpipe(dev, endpoint);\n\tint ret;\n\tu8 *data;\n\n\tif (!size || !driver_data)\n\t\treturn -EINVAL;\n\n\tdata = kmalloc(size, memflags);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, pipe, request, requesttype, value, index,\n\t\t\t      data, size, timeout);\n\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif (ret == size) {\n\t\tmemcpy(driver_data, data, size);\n\t\tret = 0;\n\t} else {\n\t\tret = -EREMOTEIO;\n\t}\n\nexit:\n\tkfree(data);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_control_msg_recv);\n\n \nint usb_interrupt_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t      void *data, int len, int *actual_length, int timeout)\n{\n\treturn usb_bulk_msg(usb_dev, pipe, data, len, actual_length, timeout);\n}\nEXPORT_SYMBOL_GPL(usb_interrupt_msg);\n\n \nint usb_bulk_msg(struct usb_device *usb_dev, unsigned int pipe,\n\t\t void *data, int len, int *actual_length, int timeout)\n{\n\tstruct urb *urb;\n\tstruct usb_host_endpoint *ep;\n\n\tep = usb_pipe_endpoint(usb_dev, pipe);\n\tif (!ep || len < 0)\n\t\treturn -EINVAL;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tif ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_INT) {\n\t\tpipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\n\t\tusb_fill_int_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL,\n\t\t\t\tep->desc.bInterval);\n\t} else\n\t\tusb_fill_bulk_urb(urb, usb_dev, pipe, data, len,\n\t\t\t\tusb_api_blocking_completion, NULL);\n\n\treturn usb_start_wait_urb(urb, timeout, actual_length);\n}\nEXPORT_SYMBOL_GPL(usb_bulk_msg);\n\n \n\nstatic void sg_clean(struct usb_sg_request *io)\n{\n\tif (io->urbs) {\n\t\twhile (io->entries--)\n\t\t\tusb_free_urb(io->urbs[io->entries]);\n\t\tkfree(io->urbs);\n\t\tio->urbs = NULL;\n\t}\n\tio->dev = NULL;\n}\n\nstatic void sg_complete(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_sg_request *io = urb->context;\n\tint status = urb->status;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\n\t \n\tif (io->status\n\t\t\t&& (io->status != -ECONNRESET\n\t\t\t\t|| status != -ECONNRESET)\n\t\t\t&& urb->actual_length) {\n\t\tdev_err(io->dev->bus->controller,\n\t\t\t\"dev %s ep%d%s scatterlist error %d/%d\\n\",\n\t\t\tio->dev->devpath,\n\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\tusb_urb_dir_in(urb) ? \"in\" : \"out\",\n\t\t\tstatus, io->status);\n\t\t \n\t}\n\n\tif (io->status == 0 && status && status != -ECONNRESET) {\n\t\tint i, found, retval;\n\n\t\tio->status = status;\n\n\t\t \n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\tfor (i = 0, found = 0; i < io->entries; i++) {\n\t\t\tif (!io->urbs[i])\n\t\t\t\tcontinue;\n\t\t\tif (found) {\n\t\t\t\tusb_block_urb(io->urbs[i]);\n\t\t\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\t\t\tif (retval != -EINPROGRESS &&\n\t\t\t\t    retval != -ENODEV &&\n\t\t\t\t    retval != -EBUSY &&\n\t\t\t\t    retval != -EIDRM)\n\t\t\t\t\tdev_err(&io->dev->dev,\n\t\t\t\t\t\t\"%s, unlink --> %d\\n\",\n\t\t\t\t\t\t__func__, retval);\n\t\t\t} else if (urb == io->urbs[i])\n\t\t\t\tfound = 1;\n\t\t}\n\t\tspin_lock_irqsave(&io->lock, flags);\n\t}\n\n\t \n\tio->bytes += urb->actual_length;\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\n\n\n \nint usb_sg_init(struct usb_sg_request *io, struct usb_device *dev,\n\t\tunsigned pipe, unsigned\tperiod, struct scatterlist *sg,\n\t\tint nents, size_t length, gfp_t mem_flags)\n{\n\tint i;\n\tint urb_flags;\n\tint use_sg;\n\n\tif (!io || !dev || !sg\n\t\t\t|| usb_pipecontrol(pipe)\n\t\t\t|| usb_pipeisoc(pipe)\n\t\t\t|| nents <= 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_init(&io->lock);\n\tio->dev = dev;\n\tio->pipe = pipe;\n\n\tif (dev->bus->sg_tablesize > 0) {\n\t\tuse_sg = true;\n\t\tio->entries = 1;\n\t} else {\n\t\tuse_sg = false;\n\t\tio->entries = nents;\n\t}\n\n\t \n\tio->urbs = kmalloc_array(io->entries, sizeof(*io->urbs), mem_flags);\n\tif (!io->urbs)\n\t\tgoto nomem;\n\n\turb_flags = URB_NO_INTERRUPT;\n\tif (usb_pipein(pipe))\n\t\turb_flags |= URB_SHORT_NOT_OK;\n\n\tfor_each_sg(sg, sg, io->entries, i) {\n\t\tstruct urb *urb;\n\t\tunsigned len;\n\n\t\turb = usb_alloc_urb(0, mem_flags);\n\t\tif (!urb) {\n\t\t\tio->entries = i;\n\t\t\tgoto nomem;\n\t\t}\n\t\tio->urbs[i] = urb;\n\n\t\turb->dev = NULL;\n\t\turb->pipe = pipe;\n\t\turb->interval = period;\n\t\turb->transfer_flags = urb_flags;\n\t\turb->complete = sg_complete;\n\t\turb->context = io;\n\t\turb->sg = sg;\n\n\t\tif (use_sg) {\n\t\t\t \n\t\t\turb->transfer_buffer = NULL;\n\t\t\turb->num_sgs = nents;\n\n\t\t\t \n\t\t\tlen = length;\n\t\t\tif (len == 0) {\n\t\t\t\tstruct scatterlist\t*sg2;\n\t\t\t\tint\t\t\tj;\n\n\t\t\t\tfor_each_sg(sg, sg2, nents, j)\n\t\t\t\t\tlen += sg2->length;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tif (!PageHighMem(sg_page(sg)))\n\t\t\t\turb->transfer_buffer = sg_virt(sg);\n\t\t\telse\n\t\t\t\turb->transfer_buffer = NULL;\n\n\t\t\tlen = sg->length;\n\t\t\tif (length) {\n\t\t\t\tlen = min_t(size_t, len, length);\n\t\t\t\tlength -= len;\n\t\t\t\tif (length == 0)\n\t\t\t\t\tio->entries = i + 1;\n\t\t\t}\n\t\t}\n\t\turb->transfer_buffer_length = len;\n\t}\n\tio->urbs[--i]->transfer_flags &= ~URB_NO_INTERRUPT;\n\n\t \n\tio->count = io->entries;\n\tio->status = 0;\n\tio->bytes = 0;\n\tinit_completion(&io->complete);\n\treturn 0;\n\nnomem:\n\tsg_clean(io);\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_sg_init);\n\n \nvoid usb_sg_wait(struct usb_sg_request *io)\n{\n\tint i;\n\tint entries = io->entries;\n\n\t \n\tspin_lock_irq(&io->lock);\n\ti = 0;\n\twhile (i < entries && !io->status) {\n\t\tint retval;\n\n\t\tio->urbs[i]->dev = io->dev;\n\t\tspin_unlock_irq(&io->lock);\n\n\t\tretval = usb_submit_urb(io->urbs[i], GFP_NOIO);\n\n\t\tswitch (retval) {\n\t\t\t \n\t\tcase -ENXIO:\t \n\t\tcase -EAGAIN:\n\t\tcase -ENOMEM:\n\t\t\tretval = 0;\n\t\t\tyield();\n\t\t\tbreak;\n\n\t\t\t \n\t\tcase 0:\n\t\t\t++i;\n\t\t\tcpu_relax();\n\t\t\tbreak;\n\n\t\t\t \n\t\tdefault:\n\t\t\tio->urbs[i]->status = retval;\n\t\t\tdev_dbg(&io->dev->dev, \"%s, submit --> %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tusb_sg_cancel(io);\n\t\t}\n\t\tspin_lock_irq(&io->lock);\n\t\tif (retval && (io->status == 0 || io->status == -ECONNRESET))\n\t\t\tio->status = retval;\n\t}\n\tio->count -= entries - i;\n\tif (io->count == 0)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irq(&io->lock);\n\n\t \n\twait_for_completion(&io->complete);\n\n\tsg_clean(io);\n}\nEXPORT_SYMBOL_GPL(usb_sg_wait);\n\n \nvoid usb_sg_cancel(struct usb_sg_request *io)\n{\n\tunsigned long flags;\n\tint i, retval;\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tif (io->status || io->count == 0) {\n\t\tspin_unlock_irqrestore(&io->lock, flags);\n\t\treturn;\n\t}\n\t \n\tio->status = -ECONNRESET;\n\tio->count++;\t\t \n\tspin_unlock_irqrestore(&io->lock, flags);\n\n\tfor (i = io->entries - 1; i >= 0; --i) {\n\t\tusb_block_urb(io->urbs[i]);\n\n\t\tretval = usb_unlink_urb(io->urbs[i]);\n\t\tif (retval != -EINPROGRESS\n\t\t    && retval != -ENODEV\n\t\t    && retval != -EBUSY\n\t\t    && retval != -EIDRM)\n\t\t\tdev_warn(&io->dev->dev, \"%s, unlink --> %d\\n\",\n\t\t\t\t __func__, retval);\n\t}\n\n\tspin_lock_irqsave(&io->lock, flags);\n\tio->count--;\n\tif (!io->count)\n\t\tcomplete(&io->complete);\n\tspin_unlock_irqrestore(&io->lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_sg_cancel);\n\n \n\n \nint usb_get_descriptor(struct usb_device *dev, unsigned char type,\n\t\t       unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tif (size <= 0)\t\t \n\t\treturn -EINVAL;\n\n\tmemset(buf, 0, size);\t \n\n\tfor (i = 0; i < 3; ++i) {\n\t\t \n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t(type << 8) + index, 0, buf, size,\n\t\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result <= 0 && result != -ETIMEDOUT)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *)buf)[1] != type) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_get_descriptor);\n\n \nstatic int usb_get_string(struct usb_device *dev, unsigned short langid,\n\t\t\t  unsigned char index, void *buf, int size)\n{\n\tint i;\n\tint result;\n\n\tif (size <= 0)\t\t \n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\t \n\t\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t(USB_DT_STRING << 8) + index, langid, buf, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (result == 0 || result == -EPIPE)\n\t\t\tcontinue;\n\t\tif (result > 1 && ((u8 *) buf)[1] != USB_DT_STRING) {\n\t\t\tresult = -ENODATA;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\treturn result;\n}\n\nstatic void usb_try_string_workarounds(unsigned char *buf, int *length)\n{\n\tint newlength, oldlength = *length;\n\n\tfor (newlength = 2; newlength + 1 < oldlength; newlength += 2)\n\t\tif (!isprint(buf[newlength]) || buf[newlength + 1])\n\t\t\tbreak;\n\n\tif (newlength > 2) {\n\t\tbuf[0] = newlength;\n\t\t*length = newlength;\n\t}\n}\n\nstatic int usb_string_sub(struct usb_device *dev, unsigned int langid,\n\t\t\t  unsigned int index, unsigned char *buf)\n{\n\tint rc;\n\n\t \n\tif (dev->quirks & USB_QUIRK_STRING_FETCH_255)\n\t\trc = -EIO;\n\telse\n\t\trc = usb_get_string(dev, langid, index, buf, 255);\n\n\t \n\tif (rc < 2) {\n\t\trc = usb_get_string(dev, langid, index, buf, 2);\n\t\tif (rc == 2)\n\t\t\trc = usb_get_string(dev, langid, index, buf, buf[0]);\n\t}\n\n\tif (rc >= 2) {\n\t\tif (!buf[0] && !buf[1])\n\t\t\tusb_try_string_workarounds(buf, &rc);\n\n\t\t \n\t\tif (buf[0] < rc)\n\t\t\trc = buf[0];\n\n\t\trc = rc - (rc & 1);  \n\t}\n\n\tif (rc < 2)\n\t\trc = (rc < 0 ? rc : -EINVAL);\n\n\treturn rc;\n}\n\nstatic int usb_get_langid(struct usb_device *dev, unsigned char *tbuf)\n{\n\tint err;\n\n\tif (dev->have_langid)\n\t\treturn 0;\n\n\tif (dev->string_langid < 0)\n\t\treturn -EPIPE;\n\n\terr = usb_string_sub(dev, 0, 0, tbuf);\n\n\t \n\tif (err == -ENODATA || (err > 0 && err < 4)) {\n\t\tdev->string_langid = 0x0409;\n\t\tdev->have_langid = 1;\n\t\tdev_err(&dev->dev,\n\t\t\t\"language id specifier not provided by device, defaulting to English\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (err < 0) {\n\t\tdev_info(&dev->dev, \"string descriptor 0 read error: %d\\n\",\n\t\t\t\t\terr);\n\t\tdev->string_langid = -1;\n\t\treturn -EPIPE;\n\t}\n\n\t \n\tdev->string_langid = tbuf[2] | (tbuf[3] << 8);\n\tdev->have_langid = 1;\n\tdev_dbg(&dev->dev, \"default language 0x%04x\\n\",\n\t\t\t\tdev->string_langid);\n\treturn 0;\n}\n\n \nint usb_string(struct usb_device *dev, int index, char *buf, size_t size)\n{\n\tunsigned char *tbuf;\n\tint err;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (size <= 0 || !buf)\n\t\treturn -EINVAL;\n\tbuf[0] = 0;\n\tif (index <= 0 || index >= 256)\n\t\treturn -EINVAL;\n\ttbuf = kmalloc(256, GFP_NOIO);\n\tif (!tbuf)\n\t\treturn -ENOMEM;\n\n\terr = usb_get_langid(dev, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\terr = usb_string_sub(dev, dev->string_langid, index, tbuf);\n\tif (err < 0)\n\t\tgoto errout;\n\n\tsize--;\t\t \n\terr = utf16s_to_utf8s((wchar_t *) &tbuf[2], (err - 2) / 2,\n\t\t\tUTF16_LITTLE_ENDIAN, buf, size);\n\tbuf[err] = 0;\n\n\tif (tbuf[1] != USB_DT_STRING)\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"wrong descriptor type %02x for string %d (\\\"%s\\\")\\n\",\n\t\t\ttbuf[1], index, buf);\n\n errout:\n\tkfree(tbuf);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(usb_string);\n\n \n#define MAX_USB_STRING_SIZE (127 * 3 + 1)\n\n \nchar *usb_cache_string(struct usb_device *udev, int index)\n{\n\tchar *buf;\n\tchar *smallbuf = NULL;\n\tint len;\n\n\tif (index <= 0)\n\t\treturn NULL;\n\n\tbuf = kmalloc(MAX_USB_STRING_SIZE, GFP_NOIO);\n\tif (buf) {\n\t\tlen = usb_string(udev, index, buf, MAX_USB_STRING_SIZE);\n\t\tif (len > 0) {\n\t\t\tsmallbuf = kmalloc(++len, GFP_NOIO);\n\t\t\tif (!smallbuf)\n\t\t\t\treturn buf;\n\t\t\tmemcpy(smallbuf, buf, len);\n\t\t}\n\t\tkfree(buf);\n\t}\n\treturn smallbuf;\n}\nEXPORT_SYMBOL_GPL(usb_cache_string);\n\n \nstruct usb_device_descriptor *usb_get_device_descriptor(struct usb_device *udev)\n{\n\tstruct usb_device_descriptor *desc;\n\tint ret;\n\n\tdesc = kmalloc(sizeof(*desc), GFP_NOIO);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = usb_get_descriptor(udev, USB_DT_DEVICE, 0, desc, sizeof(*desc));\n\tif (ret == sizeof(*desc))\n\t\treturn desc;\n\n\tif (ret >= 0)\n\t\tret = -EMSGSIZE;\n\tkfree(desc);\n\treturn ERR_PTR(ret);\n}\n\n \nint usb_set_isoch_delay(struct usb_device *dev)\n{\n\t \n\tif (dev->descriptor.bDeviceClass == USB_CLASS_HUB)\n\t\treturn 0;\n\n\t \n\tif (dev->speed < USB_SPEED_SUPER)\n\t\treturn 0;\n\n\treturn usb_control_msg_send(dev, 0,\n\t\t\tUSB_REQ_SET_ISOCH_DELAY,\n\t\t\tUSB_DIR_OUT | USB_TYPE_STANDARD | USB_RECIP_DEVICE,\n\t\t\tdev->hub_delay, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT,\n\t\t\tGFP_NOIO);\n}\n\n \nint usb_get_status(struct usb_device *dev, int recip, int type, int target,\n\t\tvoid *data)\n{\n\tint ret;\n\tvoid *status;\n\tint length;\n\n\tswitch (type) {\n\tcase USB_STATUS_TYPE_STANDARD:\n\t\tlength = 2;\n\t\tbreak;\n\tcase USB_STATUS_TYPE_PTM:\n\t\tif (recip != USB_RECIP_DEVICE)\n\t\t\treturn -EINVAL;\n\n\t\tlength = 4;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tstatus =  kmalloc(length, GFP_KERNEL);\n\tif (!status)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | recip, USB_STATUS_TYPE_STANDARD,\n\t\ttarget, status, length, USB_CTRL_GET_TIMEOUT);\n\n\tswitch (ret) {\n\tcase 4:\n\t\tif (type != USB_STATUS_TYPE_PTM) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u32 *) data = le32_to_cpu(*(__le32 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tcase 2:\n\t\tif (type != USB_STATUS_TYPE_STANDARD) {\n\t\t\tret = -EIO;\n\t\t\tbreak;\n\t\t}\n\n\t\t*(u16 *) data = le16_to_cpu(*(__le16 *) status);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EIO;\n\t}\n\n\tkfree(status);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_get_status);\n\n \nint usb_clear_halt(struct usb_device *dev, int pipe)\n{\n\tint result;\n\tint endp = usb_pipeendpoint(pipe);\n\n\tif (usb_pipein(pipe))\n\t\tendp |= USB_DIR_IN;\n\n\t \n\tresult = usb_control_msg_send(dev, 0,\n\t\t\t\t      USB_REQ_CLEAR_FEATURE, USB_RECIP_ENDPOINT,\n\t\t\t\t      USB_ENDPOINT_HALT, endp, NULL, 0,\n\t\t\t\t      USB_CTRL_SET_TIMEOUT, GFP_NOIO);\n\n\t \n\tif (result)\n\t\treturn result;\n\n\t \n\n\tusb_reset_endpoint(dev, endp);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_clear_halt);\n\nstatic int create_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (intf->ep_devs_created || intf->unregistering)\n\t\treturn 0;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\t(void) usb_create_ep_devs(&intf->dev, &alt->endpoint[i], udev);\n\tintf->ep_devs_created = 1;\n\treturn 0;\n}\n\nstatic void remove_intf_ep_devs(struct usb_interface *intf)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tif (!intf->ep_devs_created)\n\t\treturn;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_remove_ep_devs(&alt->endpoint[i]);\n\tintf->ep_devs_created = 0;\n}\n\n \nvoid usb_disable_endpoint(struct usb_device *dev, unsigned int epaddr,\n\t\tbool reset_hardware)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (!dev)\n\t\treturn;\n\n\tif (usb_endpoint_out(epaddr)) {\n\t\tep = dev->ep_out[epnum];\n\t\tif (reset_hardware && epnum != 0)\n\t\t\tdev->ep_out[epnum] = NULL;\n\t} else {\n\t\tep = dev->ep_in[epnum];\n\t\tif (reset_hardware && epnum != 0)\n\t\t\tdev->ep_in[epnum] = NULL;\n\t}\n\tif (ep) {\n\t\tep->enabled = 0;\n\t\tusb_hcd_flush_endpoint(dev, ep);\n\t\tif (reset_hardware)\n\t\t\tusb_hcd_disable_endpoint(dev, ep);\n\t}\n}\n\n \nvoid usb_reset_endpoint(struct usb_device *dev, unsigned int epaddr)\n{\n\tunsigned int epnum = epaddr & USB_ENDPOINT_NUMBER_MASK;\n\tstruct usb_host_endpoint *ep;\n\n\tif (usb_endpoint_out(epaddr))\n\t\tep = dev->ep_out[epnum];\n\telse\n\t\tep = dev->ep_in[epnum];\n\tif (ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n}\nEXPORT_SYMBOL_GPL(usb_reset_endpoint);\n\n\n \nvoid usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,\n\t\tbool reset_hardware)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tusb_disable_endpoint(dev,\n\t\t\t\talt->endpoint[i].desc.bEndpointAddress,\n\t\t\t\treset_hardware);\n\t}\n}\n\n \nstatic void usb_disable_device_endpoints(struct usb_device *dev, int skip_ep0)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint i;\n\n\tif (hcd->driver->check_bandwidth) {\n\t\t \n\t\tfor (i = skip_ep0; i < 16; ++i) {\n\t\t\tusb_disable_endpoint(dev, i, false);\n\t\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, false);\n\t\t}\n\t\t \n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t}\n\t \n\tfor (i = skip_ep0; i < 16; ++i) {\n\t\tusb_disable_endpoint(dev, i, true);\n\t\tusb_disable_endpoint(dev, i + USB_DIR_IN, true);\n\t}\n}\n\n \nvoid usb_disable_device(struct usb_device *dev, int skip_ep0)\n{\n\tint i;\n\n\t \n\tif (dev->actconfig) {\n\t\t \n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++)\n\t\t\tdev->actconfig->interface[i]->unregistering = 1;\n\n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tstruct usb_interface\t*interface;\n\n\t\t\t \n\t\t\tinterface = dev->actconfig->interface[i];\n\t\t\tif (!device_is_registered(&interface->dev))\n\t\t\t\tcontinue;\n\t\t\tdev_dbg(&dev->dev, \"unregistering interface %s\\n\",\n\t\t\t\tdev_name(&interface->dev));\n\t\t\tremove_intf_ep_devs(interface);\n\t\t\tdevice_del(&interface->dev);\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tput_device(&dev->actconfig->interface[i]->dev);\n\t\t\tdev->actconfig->interface[i] = NULL;\n\t\t}\n\n\t\tusb_disable_usb2_hardware_lpm(dev);\n\t\tusb_unlocked_disable_lpm(dev);\n\t\tusb_disable_ltm(dev);\n\n\t\tdev->actconfig = NULL;\n\t\tif (dev->state == USB_STATE_CONFIGURED)\n\t\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\t}\n\n\tdev_dbg(&dev->dev, \"%s nuking %s URBs\\n\", __func__,\n\t\tskip_ep0 ? \"non-ep0\" : \"all\");\n\n\tusb_disable_device_endpoints(dev, skip_ep0);\n}\n\n \nvoid usb_enable_endpoint(struct usb_device *dev, struct usb_host_endpoint *ep,\n\t\tbool reset_ep)\n{\n\tint epnum = usb_endpoint_num(&ep->desc);\n\tint is_out = usb_endpoint_dir_out(&ep->desc);\n\tint is_control = usb_endpoint_xfer_control(&ep->desc);\n\n\tif (reset_ep)\n\t\tusb_hcd_reset_endpoint(dev, ep);\n\tif (is_out || is_control)\n\t\tdev->ep_out[epnum] = ep;\n\tif (!is_out || is_control)\n\t\tdev->ep_in[epnum] = ep;\n\tep->enabled = 1;\n}\n\n \nvoid usb_enable_interface(struct usb_device *dev,\n\t\tstruct usb_interface *intf, bool reset_eps)\n{\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\tint i;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i)\n\t\tusb_enable_endpoint(dev, &alt->endpoint[i], reset_eps);\n}\n\n \nint usb_set_interface(struct usb_device *dev, int interface, int alternate)\n{\n\tstruct usb_interface *iface;\n\tstruct usb_host_interface *alt;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint i, ret, manual = 0;\n\tunsigned int epaddr;\n\tunsigned int pipe;\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\tiface = usb_ifnum_to_if(dev, interface);\n\tif (!iface) {\n\t\tdev_dbg(&dev->dev, \"selecting invalid interface %d\\n\",\n\t\t\tinterface);\n\t\treturn -EINVAL;\n\t}\n\tif (iface->unregistering)\n\t\treturn -ENODEV;\n\n\talt = usb_altnum_to_altsetting(iface, alternate);\n\tif (!alt) {\n\t\tdev_warn(&dev->dev, \"selecting invalid altsetting %d\\n\",\n\t\t\t alternate);\n\t\treturn -EINVAL;\n\t}\n\t \n\tusb_disable_interface(dev, iface, false);\n\n\t \n\tmutex_lock(hcd->bandwidth_mutex);\n\t \n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&iface->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tfor (i = 0; i < iface->cur_altsetting->desc.bNumEndpoints; i++)\n\t\tiface->cur_altsetting->endpoint[i].streams = 0;\n\n\tret = usb_hcd_alloc_bandwidth(dev, NULL, iface->cur_altsetting, alt);\n\tif (ret < 0) {\n\t\tdev_info(&dev->dev, \"Not enough bandwidth for altsetting %d\\n\",\n\t\t\t\talternate);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\n\tif (dev->quirks & USB_QUIRK_NO_SET_INTF)\n\t\tret = -EPIPE;\n\telse\n\t\tret = usb_control_msg_send(dev, 0,\n\t\t\t\t\t   USB_REQ_SET_INTERFACE,\n\t\t\t\t\t   USB_RECIP_INTERFACE, alternate,\n\t\t\t\t\t   interface, NULL, 0, 5000,\n\t\t\t\t\t   GFP_NOIO);\n\n\t \n\tif (ret == -EPIPE && iface->num_altsetting == 1) {\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"manual set_interface for iface %d, alt %d\\n\",\n\t\t\tinterface, alternate);\n\t\tmanual = 1;\n\t} else if (ret) {\n\t\t \n\t\tusb_hcd_alloc_bandwidth(dev, NULL, alt, iface->cur_altsetting);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn ret;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t \n\n\t \n\tif (iface->cur_altsetting != alt) {\n\t\tremove_intf_ep_devs(iface);\n\t\tusb_remove_sysfs_intf_files(iface);\n\t}\n\tusb_disable_interface(dev, iface, true);\n\n\tiface->cur_altsetting = alt;\n\n\t \n\tusb_unlocked_enable_lpm(dev);\n\n\t \n\tif (manual) {\n\t\tfor (i = 0; i < alt->desc.bNumEndpoints; i++) {\n\t\t\tepaddr = alt->endpoint[i].desc.bEndpointAddress;\n\t\t\tpipe = __create_pipe(dev,\n\t\t\t\t\tUSB_ENDPOINT_NUMBER_MASK & epaddr) |\n\t\t\t\t\t(usb_endpoint_out(epaddr) ?\n\t\t\t\t\tUSB_DIR_OUT : USB_DIR_IN);\n\n\t\t\tusb_clear_halt(dev, pipe);\n\t\t}\n\t}\n\n\t \n\tusb_enable_interface(dev, iface, true);\n\tif (device_is_registered(&iface->dev)) {\n\t\tusb_create_sysfs_intf_files(iface);\n\t\tcreate_intf_ep_devs(iface);\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_interface);\n\n \nint usb_reset_configuration(struct usb_device *dev)\n{\n\tint\t\t\ti, retval;\n\tstruct usb_host_config\t*config;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\n\tif (dev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\n\t \n\n\tusb_disable_device_endpoints(dev, 1);  \n\n\tconfig = dev->actconfig;\n\tretval = 0;\n\tmutex_lock(hcd->bandwidth_mutex);\n\t \n\tif (usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tretval = usb_hcd_alloc_bandwidth(dev, config, NULL, NULL);\n\tif (retval < 0) {\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tretval = usb_control_msg_send(dev, 0, USB_REQ_SET_CONFIGURATION, 0,\n\t\t\t\t      config->desc.bConfigurationValue, 0,\n\t\t\t\t      NULL, 0, USB_CTRL_SET_TIMEOUT,\n\t\t\t\t      GFP_NOIO);\n\tif (retval) {\n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\treturn retval;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\t \n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t \n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tif (alt != intf->cur_altsetting) {\n\t\t\tremove_intf_ep_devs(intf);\n\t\t\tusb_remove_sysfs_intf_files(intf);\n\t\t}\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tif (device_is_registered(&intf->dev)) {\n\t\t\tusb_create_sysfs_intf_files(intf);\n\t\t\tcreate_intf_ep_devs(intf);\n\t\t}\n\t}\n\t \n\tusb_unlocked_enable_lpm(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_reset_configuration);\n\nstatic void usb_release_interface(struct device *dev)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_interface_cache *intfc =\n\t\t\taltsetting_to_usb_interface_cache(intf->altsetting);\n\n\tkref_put(&intfc->ref, usb_release_interface_cache);\n\tusb_put_dev(interface_to_usbdev(intf));\n\tof_node_put(dev->of_node);\n\tkfree(intf);\n}\n\n \nvoid usb_deauthorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tdevice_lock(dev->parent);\n\n\tif (intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 0;\n\t\tdevice_unlock(dev);\n\n\t\tusb_forced_unbind_intf(intf);\n\t}\n\n\tdevice_unlock(dev->parent);\n}\n\n \nvoid usb_authorize_interface(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\n\tif (!intf->authorized) {\n\t\tdevice_lock(dev);\n\t\tintf->authorized = 1;  \n\t\tdevice_unlock(dev);\n\t}\n}\n\nstatic int usb_if_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct usb_device *usb_dev;\n\tconst struct usb_interface *intf;\n\tconst struct usb_host_interface *alt;\n\n\tintf = to_usb_interface(dev);\n\tusb_dev = interface_to_usbdev(intf);\n\talt = intf->cur_altsetting;\n\n\tif (add_uevent_var(env, \"INTERFACE=%d/%d/%d\",\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env,\n\t\t   \"MODALIAS=usb:\"\n\t\t   \"v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02Xic%02Xisc%02Xip%02Xin%02X\",\n\t\t   le16_to_cpu(usb_dev->descriptor.idVendor),\n\t\t   le16_to_cpu(usb_dev->descriptor.idProduct),\n\t\t   le16_to_cpu(usb_dev->descriptor.bcdDevice),\n\t\t   usb_dev->descriptor.bDeviceClass,\n\t\t   usb_dev->descriptor.bDeviceSubClass,\n\t\t   usb_dev->descriptor.bDeviceProtocol,\n\t\t   alt->desc.bInterfaceClass,\n\t\t   alt->desc.bInterfaceSubClass,\n\t\t   alt->desc.bInterfaceProtocol,\n\t\t   alt->desc.bInterfaceNumber))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstruct device_type usb_if_device_type = {\n\t.name =\t\t\"usb_interface\",\n\t.release =\tusb_release_interface,\n\t.uevent =\tusb_if_uevent,\n};\n\nstatic struct usb_interface_assoc_descriptor *find_iad(struct usb_device *dev,\n\t\t\t\t\t\tstruct usb_host_config *config,\n\t\t\t\t\t\tu8 inum)\n{\n\tstruct usb_interface_assoc_descriptor *retval = NULL;\n\tstruct usb_interface_assoc_descriptor *intf_assoc;\n\tint first_intf;\n\tint last_intf;\n\tint i;\n\n\tfor (i = 0; (i < USB_MAXIADS && config->intf_assoc[i]); i++) {\n\t\tintf_assoc = config->intf_assoc[i];\n\t\tif (intf_assoc->bInterfaceCount == 0)\n\t\t\tcontinue;\n\n\t\tfirst_intf = intf_assoc->bFirstInterface;\n\t\tlast_intf = first_intf + (intf_assoc->bInterfaceCount - 1);\n\t\tif (inum >= first_intf && inum <= last_intf) {\n\t\t\tif (!retval)\n\t\t\t\tretval = intf_assoc;\n\t\t\telse\n\t\t\t\tdev_err(&dev->dev, \"Interface #%d referenced\"\n\t\t\t\t\t\" by multiple IADs\\n\", inum);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n\n \nstatic void __usb_queue_reset_device(struct work_struct *ws)\n{\n\tint rc;\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, reset_ws);\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\n\trc = usb_lock_device_for_reset(udev, iface);\n\tif (rc >= 0) {\n\t\tusb_reset_device(udev);\n\t\tusb_unlock_device(udev);\n\t}\n\tusb_put_intf(iface);\t \n}\n\n \nstatic void __usb_wireless_status_intf(struct work_struct *ws)\n{\n\tstruct usb_interface *iface =\n\t\tcontainer_of(ws, struct usb_interface, wireless_status_work);\n\n\tdevice_lock(iface->dev.parent);\n\tif (iface->sysfs_files_created)\n\t\tusb_update_wireless_status_attr(iface);\n\tdevice_unlock(iface->dev.parent);\n\tusb_put_intf(iface);\t \n}\n\n \nint usb_set_wireless_status(struct usb_interface *iface,\n\t\tenum usb_wireless_status status)\n{\n\tif (iface->wireless_status == status)\n\t\treturn -EALREADY;\n\n\tusb_get_intf(iface);\n\tiface->wireless_status = status;\n\tschedule_work(&iface->wireless_status_work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_wireless_status);\n\n \nint usb_set_configuration(struct usb_device *dev, int configuration)\n{\n\tint i, ret;\n\tstruct usb_host_config *cp = NULL;\n\tstruct usb_interface **new_interfaces = NULL;\n\tstruct usb_hcd *hcd = bus_to_hcd(dev->bus);\n\tint n, nintf;\n\n\tif (dev->authorized == 0 || configuration == -1)\n\t\tconfiguration = 0;\n\telse {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\t\tif (dev->config[i].desc.bConfigurationValue ==\n\t\t\t\t\tconfiguration) {\n\t\t\t\tcp = &dev->config[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif ((!cp && configuration != 0))\n\t\treturn -EINVAL;\n\n\t \n\tif (cp && configuration == 0)\n\t\tdev_warn(&dev->dev, \"config 0 descriptor??\\n\");\n\n\t \n\tn = nintf = 0;\n\tif (cp) {\n\t\tnintf = cp->desc.bNumInterfaces;\n\t\tnew_interfaces = kmalloc_array(nintf, sizeof(*new_interfaces),\n\t\t\t\t\t       GFP_NOIO);\n\t\tif (!new_interfaces)\n\t\t\treturn -ENOMEM;\n\n\t\tfor (; n < nintf; ++n) {\n\t\t\tnew_interfaces[n] = kzalloc(\n\t\t\t\t\tsizeof(struct usb_interface),\n\t\t\t\t\tGFP_NOIO);\n\t\t\tif (!new_interfaces[n]) {\n\t\t\t\tret = -ENOMEM;\nfree_interfaces:\n\t\t\t\twhile (--n >= 0)\n\t\t\t\t\tkfree(new_interfaces[n]);\n\t\t\t\tkfree(new_interfaces);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\n\t\ti = dev->bus_mA - usb_get_max_power(dev, cp);\n\t\tif (i < 0)\n\t\t\tdev_warn(&dev->dev, \"new config #%d exceeds power \"\n\t\t\t\t\t\"limit by %dmA\\n\",\n\t\t\t\t\tconfiguration, -i);\n\t}\n\n\t \n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto free_interfaces;\n\n\t \n\tif (dev->state != USB_STATE_ADDRESS)\n\t\tusb_disable_device(dev, 1);\t \n\n\t \n\tcancel_async_set_config(dev);\n\n\t \n\tmutex_lock(hcd->bandwidth_mutex);\n\t \n\tif (dev->actconfig && usb_disable_lpm(dev)) {\n\t\tdev_err(&dev->dev, \"%s Failed to disable LPM\\n\", __func__);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tret = -ENOMEM;\n\t\tgoto free_interfaces;\n\t}\n\tret = usb_hcd_alloc_bandwidth(dev, cp, NULL, NULL);\n\tif (ret < 0) {\n\t\tif (dev->actconfig)\n\t\t\tusb_enable_lpm(dev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tusb_autosuspend_device(dev);\n\t\tgoto free_interfaces;\n\t}\n\n\t \n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface_cache *intfc;\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_host_interface *alt;\n\t\tu8 ifnum;\n\n\t\tcp->interface[i] = intf = new_interfaces[i];\n\t\tintfc = cp->intf_cache[i];\n\t\tintf->altsetting = intfc->altsetting;\n\t\tintf->num_altsetting = intfc->num_altsetting;\n\t\tintf->authorized = !!HCD_INTF_AUTHORIZED(hcd);\n\t\tkref_get(&intfc->ref);\n\n\t\talt = usb_altnum_to_altsetting(intf, 0);\n\n\t\t \n\t\tif (!alt)\n\t\t\talt = &intf->altsetting[0];\n\n\t\tifnum = alt->desc.bInterfaceNumber;\n\t\tintf->intf_assoc = find_iad(dev, cp, ifnum);\n\t\tintf->cur_altsetting = alt;\n\t\tusb_enable_interface(dev, intf, true);\n\t\tintf->dev.parent = &dev->dev;\n\t\tif (usb_of_has_combined_node(dev)) {\n\t\t\tdevice_set_of_node_from_dev(&intf->dev, &dev->dev);\n\t\t} else {\n\t\t\tintf->dev.of_node = usb_of_get_interface_node(dev,\n\t\t\t\t\tconfiguration, ifnum);\n\t\t}\n\t\tACPI_COMPANION_SET(&intf->dev, ACPI_COMPANION(&dev->dev));\n\t\tintf->dev.driver = NULL;\n\t\tintf->dev.bus = &usb_bus_type;\n\t\tintf->dev.type = &usb_if_device_type;\n\t\tintf->dev.groups = usb_interface_groups;\n\t\tINIT_WORK(&intf->reset_ws, __usb_queue_reset_device);\n\t\tINIT_WORK(&intf->wireless_status_work, __usb_wireless_status_intf);\n\t\tintf->minor = -1;\n\t\tdevice_initialize(&intf->dev);\n\t\tpm_runtime_no_callbacks(&intf->dev);\n\t\tdev_set_name(&intf->dev, \"%d-%s:%d.%d\", dev->bus->busnum,\n\t\t\t\tdev->devpath, configuration, ifnum);\n\t\tusb_get_dev(dev);\n\t}\n\tkfree(new_interfaces);\n\n\tret = usb_control_msg_send(dev, 0, USB_REQ_SET_CONFIGURATION, 0,\n\t\t\t\t   configuration, 0, NULL, 0,\n\t\t\t\t   USB_CTRL_SET_TIMEOUT, GFP_NOIO);\n\tif (ret && cp) {\n\t\t \n\t\tusb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);\n\t\tfor (i = 0; i < nintf; ++i) {\n\t\t\tusb_disable_interface(dev, cp->interface[i], true);\n\t\t\tput_device(&cp->interface[i]->dev);\n\t\t\tcp->interface[i] = NULL;\n\t\t}\n\t\tcp = NULL;\n\t}\n\n\tdev->actconfig = cp;\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\tif (!cp) {\n\t\tusb_set_device_state(dev, USB_STATE_ADDRESS);\n\n\t\t \n\t\tusb_autosuspend_device(dev);\n\t\treturn ret;\n\t}\n\tusb_set_device_state(dev, USB_STATE_CONFIGURED);\n\n\tif (cp->string == NULL &&\n\t\t\t!(dev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\n\t\tcp->string = usb_cache_string(dev, cp->desc.iConfiguration);\n\n\t \n\tusb_unlocked_enable_lpm(dev);\n\t \n\tusb_enable_ltm(dev);\n\n\t \n\tfor (i = 0; i < nintf; ++i) {\n\t\tstruct usb_interface *intf = cp->interface[i];\n\n\t\tif (intf->dev.of_node &&\n\t\t    !of_device_is_available(intf->dev.of_node)) {\n\t\t\tdev_info(&dev->dev, \"skipping disabled interface %d\\n\",\n\t\t\t\t intf->cur_altsetting->desc.bInterfaceNumber);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdev_dbg(&dev->dev,\n\t\t\t\"adding %s (config #%d, interface %d)\\n\",\n\t\t\tdev_name(&intf->dev), configuration,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\tdevice_enable_async_suspend(&intf->dev);\n\t\tret = device_add(&intf->dev);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&dev->dev, \"device_add(%s) --> %d\\n\",\n\t\t\t\tdev_name(&intf->dev), ret);\n\t\t\tcontinue;\n\t\t}\n\t\tcreate_intf_ep_devs(intf);\n\t}\n\n\tusb_autosuspend_device(dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_set_configuration);\n\nstatic LIST_HEAD(set_config_list);\nstatic DEFINE_SPINLOCK(set_config_lock);\n\nstruct set_config_request {\n\tstruct usb_device\t*udev;\n\tint\t\t\tconfig;\n\tstruct work_struct\twork;\n\tstruct list_head\tnode;\n};\n\n \nstatic void driver_set_config_work(struct work_struct *work)\n{\n\tstruct set_config_request *req =\n\t\tcontainer_of(work, struct set_config_request, work);\n\tstruct usb_device *udev = req->udev;\n\n\tusb_lock_device(udev);\n\tspin_lock(&set_config_lock);\n\tlist_del(&req->node);\n\tspin_unlock(&set_config_lock);\n\n\tif (req->config >= -1)\t\t \n\t\tusb_set_configuration(udev, req->config);\n\tusb_unlock_device(udev);\n\tusb_put_dev(udev);\n\tkfree(req);\n}\n\n \nstatic void cancel_async_set_config(struct usb_device *udev)\n{\n\tstruct set_config_request *req;\n\n\tspin_lock(&set_config_lock);\n\tlist_for_each_entry(req, &set_config_list, node) {\n\t\tif (req->udev == udev)\n\t\t\treq->config = -999;\t \n\t}\n\tspin_unlock(&set_config_lock);\n}\n\n \nint usb_driver_set_configuration(struct usb_device *udev, int config)\n{\n\tstruct set_config_request *req;\n\n\treq = kmalloc(sizeof(*req), GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\treq->udev = udev;\n\treq->config = config;\n\tINIT_WORK(&req->work, driver_set_config_work);\n\n\tspin_lock(&set_config_lock);\n\tlist_add(&req->node, &set_config_list);\n\tspin_unlock(&set_config_lock);\n\n\tusb_get_dev(udev);\n\tschedule_work(&req->work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_driver_set_configuration);\n\n \n\nint cdc_parse_cdc_header(struct usb_cdc_parsed_header *hdr,\n\t\t\t\tstruct usb_interface *intf,\n\t\t\t\tu8 *buffer,\n\t\t\t\tint buflen)\n{\n\t \n\tstruct usb_cdc_union_desc *union_header = NULL;\n\n\t \n\tstruct usb_cdc_header_desc *header = NULL;\n\tstruct usb_cdc_ether_desc *ether = NULL;\n\tstruct usb_cdc_mdlm_detail_desc *detail = NULL;\n\tstruct usb_cdc_mdlm_desc *desc = NULL;\n\n\tunsigned int elength;\n\tint cnt = 0;\n\n\tmemset(hdr, 0x00, sizeof(struct usb_cdc_parsed_header));\n\thdr->phonet_magic_present = false;\n\twhile (buflen > 0) {\n\t\telength = buffer[0];\n\t\tif (!elength) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage byte\\n\");\n\t\t\telength = 1;\n\t\t\tgoto next_desc;\n\t\t}\n\t\tif ((buflen < elength) || (elength < 3)) {\n\t\t\tdev_err(&intf->dev, \"invalid descriptor buffer length\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (buffer[1] != USB_DT_CS_INTERFACE) {\n\t\t\tdev_err(&intf->dev, \"skipping garbage\\n\");\n\t\t\tgoto next_desc;\n\t\t}\n\n\t\tswitch (buffer[2]) {\n\t\tcase USB_CDC_UNION_TYPE:  \n\t\t\tif (elength < sizeof(struct usb_cdc_union_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (union_header) {\n\t\t\t\tdev_err(&intf->dev, \"More than one union descriptor, skipping ...\\n\");\n\t\t\t\tgoto next_desc;\n\t\t\t}\n\t\t\tunion_header = (struct usb_cdc_union_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_COUNTRY_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_country_functional_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_country_functional_desc =\n\t\t\t\t(struct usb_cdc_country_functional_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_HEADER_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_header_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (header)\n\t\t\t\treturn -EINVAL;\n\t\t\theader = (struct usb_cdc_header_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ACM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_acm_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_acm_descriptor =\n\t\t\t\t(struct usb_cdc_acm_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_ETHERNET_TYPE:\n\t\t\tif (elength != sizeof(struct usb_cdc_ether_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (ether)\n\t\t\t\treturn -EINVAL;\n\t\t\tether = (struct usb_cdc_ether_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_CALL_MANAGEMENT_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_call_mgmt_descriptor))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_call_mgmt_descriptor =\n\t\t\t\t(struct usb_cdc_call_mgmt_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_DMM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_dmm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_dmm_desc =\n\t\t\t\t(struct usb_cdc_dmm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (desc)\n\t\t\t\treturn -EINVAL;\n\t\t\tdesc = (struct usb_cdc_mdlm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MDLM_DETAIL_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mdlm_detail_desc))\n\t\t\t\tgoto next_desc;\n\t\t\tif (detail)\n\t\t\t\treturn -EINVAL;\n\t\t\tdetail = (struct usb_cdc_mdlm_detail_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_NCM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_ncm_desc))\n\t\t\t\tgoto next_desc;\n\t\t\thdr->usb_cdc_ncm_desc = (struct usb_cdc_ncm_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_desc))\n\t\t\t\tgoto next_desc;\n\n\t\t\thdr->usb_cdc_mbim_desc = (struct usb_cdc_mbim_desc *)buffer;\n\t\t\tbreak;\n\t\tcase USB_CDC_MBIM_EXTENDED_TYPE:\n\t\t\tif (elength < sizeof(struct usb_cdc_mbim_extended_desc))\n\t\t\t\tbreak;\n\t\t\thdr->usb_cdc_mbim_extended_desc =\n\t\t\t\t(struct usb_cdc_mbim_extended_desc *)buffer;\n\t\t\tbreak;\n\t\tcase CDC_PHONET_MAGIC_NUMBER:\n\t\t\thdr->phonet_magic_present = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tdev_dbg(&intf->dev, \"Ignoring descriptor: type %02x, length %ud\\n\",\n\t\t\t\t\tbuffer[2], elength);\n\t\t\tgoto next_desc;\n\t\t}\n\t\tcnt++;\nnext_desc:\n\t\tbuflen -= elength;\n\t\tbuffer += elength;\n\t}\n\thdr->usb_cdc_union_desc = union_header;\n\thdr->usb_cdc_header_desc = header;\n\thdr->usb_cdc_mdlm_detail_desc = detail;\n\thdr->usb_cdc_mdlm_desc = desc;\n\thdr->usb_cdc_ether_desc = ether;\n\treturn cnt;\n}\n\nEXPORT_SYMBOL(cdc_parse_cdc_header);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}