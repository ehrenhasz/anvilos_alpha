{
  "module_name": "hub.c",
  "hash_id": "534968a843254f3d04031874392fb16f900b1bf9a21bb449ad7608dcd394d1e8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/hub.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/sched/mm.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/kcov.h>\n#include <linux/ioctl.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/onboard_hub.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/quirks.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/pm_qos.h>\n#include <linux/kobject.h>\n\n#include <linux/bitfield.h>\n#include <linux/uaccess.h>\n#include <asm/byteorder.h>\n\n#include \"hub.h\"\n#include \"otg_productlist.h\"\n\n#define USB_VENDOR_GENESYS_LOGIC\t\t0x05e3\n#define USB_VENDOR_SMSC\t\t\t\t0x0424\n#define USB_PRODUCT_USB5534B\t\t\t0x5534\n#define USB_VENDOR_CYPRESS\t\t\t0x04b4\n#define USB_PRODUCT_CY7C65632\t\t\t0x6570\n#define USB_VENDOR_TEXAS_INSTRUMENTS\t\t0x0451\n#define USB_PRODUCT_TUSB8041_USB3\t\t0x8140\n#define USB_PRODUCT_TUSB8041_USB2\t\t0x8142\n#define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND\t0x01\n#define HUB_QUIRK_DISABLE_AUTOSUSPEND\t\t0x02\n\n#define USB_TP_TRANSMISSION_DELAY\t40\t \n#define USB_TP_TRANSMISSION_DELAY_MAX\t65535\t \n#define USB_PING_RESPONSE_TIME\t\t400\t \n\n \nstatic DEFINE_SPINLOCK(device_state_lock);\n\n \nstatic struct workqueue_struct *hub_wq;\nstatic void hub_event(struct work_struct *work);\n\n \nDEFINE_MUTEX(usb_port_peer_mutex);\n\n \nstatic bool blinkenlights;\nmodule_param(blinkenlights, bool, S_IRUGO);\nMODULE_PARM_DESC(blinkenlights, \"true to cycle leds on hubs\");\n\n \n \nstatic int initial_descriptor_timeout = USB_CTRL_GET_TIMEOUT;\nmodule_param(initial_descriptor_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(initial_descriptor_timeout,\n\t\t\"initial 64-byte descriptor request timeout in milliseconds \"\n\t\t\"(default 5000 - 5.0 seconds)\");\n\n \nstatic bool old_scheme_first;\nmodule_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(old_scheme_first,\n\t\t \"start with the old device initialization scheme\");\n\nstatic bool use_both_schemes = true;\nmodule_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(use_both_schemes,\n\t\t\"try the other device initialization scheme if the \"\n\t\t\"first one fails\");\n\n \nDECLARE_RWSEM(ehci_cf_port_reset_rwsem);\nEXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);\n\n#define HUB_DEBOUNCE_TIMEOUT\t2000\n#define HUB_DEBOUNCE_STEP\t  25\n#define HUB_DEBOUNCE_STABLE\t 100\n\nstatic void hub_release(struct kref *kref);\nstatic int usb_reset_and_verify_device(struct usb_device *udev);\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state);\nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus);\n\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\n{\n\tif (hub_is_superspeedplus(hub->hdev))\n\t\treturn \"10.0 Gb/s\";\n\tif (hub_is_superspeed(hub->hdev))\n\t\treturn \"5.0 Gb/s\";\n\tif (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\treturn \"480 Mb/s\";\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\treturn \"1.5 Mb/s\";\n\telse\n\t\treturn \"12 Mb/s\";\n}\n\n \nstruct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)\n{\n\tif (!hdev || !hdev->actconfig || !hdev->maxchild)\n\t\treturn NULL;\n\treturn usb_get_intfdata(hdev->actconfig->interface[0]);\n}\n\nint usb_device_supports_lpm(struct usb_device *udev)\n{\n\t \n\tif (udev->quirks & USB_QUIRK_NO_LPM)\n\t\treturn 0;\n\n\t \n\tif (!udev->bos)\n\t\treturn 0;\n\n\t \n\tif (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n\t\tif (udev->bos->ext_cap &&\n\t\t\t(USB_LPM_SUPPORT &\n\t\t\t le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\t \n\tif (!udev->bos->ss_cap) {\n\t\tdev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bos->ss_cap->bU1devExitLat == 0 &&\n\t\t\tudev->bos->ss_cap->bU2DevExitLat == 0) {\n\t\tif (udev->parent)\n\t\t\tdev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n\t\telse\n\t\t\tdev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!udev->parent || udev->parent->lpm_capable)\n\t\treturn 1;\n\treturn 0;\n}\n\n \nstatic void usb_set_lpm_mel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency)\n{\n\tunsigned int total_mel;\n\n\t \n\ttotal_mel = hub_lpm_params->mel +\n\t\tmax(udev_exit_latency, hub_exit_latency) * 1000 +\n\t\thub->descriptor->u.ss.bHubHdrDecLat * 100;\n\n\t \n\ttotal_mel += (__le16_to_cpu(hub->descriptor->u.ss.wHubDelay) +\n\t\t      USB_TP_TRANSMISSION_DELAY) * 2;\n\n\t \n\tif (!hub->hdev->parent)\n\t\ttotal_mel += USB_PING_RESPONSE_TIME + 2100;\n\n\tudev_lpm_params->mel = total_mel;\n}\n\n \nstatic void usb_set_lpm_pel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency,\n\t\tunsigned int port_to_port_exit_latency)\n{\n\tunsigned int first_link_pel;\n\tunsigned int hub_pel;\n\n\t \n\tif (udev_exit_latency > hub_exit_latency)\n\t\tfirst_link_pel = udev_exit_latency * 1000;\n\telse\n\t\tfirst_link_pel = hub_exit_latency * 1000;\n\n\t \n\thub_pel = port_to_port_exit_latency * 1000 + hub_lpm_params->pel;\n\n\t \n\tif (first_link_pel > hub_pel)\n\t\tudev_lpm_params->pel = first_link_pel;\n\telse\n\t\tudev_lpm_params->pel = hub_pel;\n}\n\n \nstatic void usb_set_lpm_sel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params)\n{\n\tstruct usb_device *parent;\n\tunsigned int num_hubs;\n\tunsigned int total_sel;\n\n\t \n\ttotal_sel = udev_lpm_params->pel;\n\t \n\tfor (parent = udev->parent, num_hubs = 0; parent->parent;\n\t\t\tparent = parent->parent)\n\t\tnum_hubs++;\n\t \n\tif (num_hubs > 0)\n\t\ttotal_sel += 2100 + 250 * (num_hubs - 1);\n\n\t \n\ttotal_sel += 250 * num_hubs;\n\n\tudev_lpm_params->sel = total_sel;\n}\n\nstatic void usb_set_lpm_parameters(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tunsigned int port_to_port_delay;\n\tunsigned int udev_u1_del;\n\tunsigned int udev_u2_del;\n\tunsigned int hub_u1_del;\n\tunsigned int hub_u2_del;\n\n\tif (!udev->lpm_capable || udev->speed < USB_SPEED_SUPER)\n\t\treturn;\n\n\t \n\tif (!udev->bos)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\t \n\tif (!hub)\n\t\treturn;\n\n\tudev_u1_del = udev->bos->ss_cap->bU1devExitLat;\n\tudev_u2_del = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat);\n\thub_u1_del = udev->parent->bos->ss_cap->bU1devExitLat;\n\thub_u2_del = le16_to_cpu(udev->parent->bos->ss_cap->bU2DevExitLat);\n\n\tusb_set_lpm_mel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del);\n\n\tusb_set_lpm_mel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del);\n\n\t \n\tport_to_port_delay = 1;\n\n\tusb_set_lpm_pel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del,\n\t\t\tport_to_port_delay);\n\n\tif (hub_u2_del > hub_u1_del)\n\t\tport_to_port_delay = 1 + hub_u2_del - hub_u1_del;\n\telse\n\t\tport_to_port_delay = 1 + hub_u1_del;\n\n\tusb_set_lpm_pel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del,\n\t\t\tport_to_port_delay);\n\n\t \n\tusb_set_lpm_sel(udev, &udev->u1_params);\n\tusb_set_lpm_sel(udev, &udev->u2_params);\n}\n\n \nstatic int get_hub_descriptor(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint i, ret, size;\n\tunsigned dtype;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tdtype = USB_DT_SS_HUB;\n\t\tsize = USB_DT_SS_HUB_SIZE;\n\t} else {\n\t\tdtype = USB_DT_HUB;\n\t\tsize = sizeof(struct usb_hub_descriptor);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tdtype << 8, 0, desc, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (hub_is_superspeed(hdev)) {\n\t\t\tif (ret == size)\n\t\t\t\treturn ret;\n\t\t} else if (ret >= USB_DT_HUB_NONVAR_SIZE + 2) {\n\t\t\t \n\t\t\tsize = USB_DT_HUB_NONVAR_SIZE + desc->bNbrPorts / 8 + 1;\n\t\t\tif (ret < size)\n\t\t\t\treturn -EMSGSIZE;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn -EINVAL;\n}\n\n \nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\n}\n\n \nint usb_clear_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\n \nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic char *to_led_name(int selector)\n{\n\tswitch (selector) {\n\tcase HUB_LED_AMBER:\n\t\treturn \"amber\";\n\tcase HUB_LED_GREEN:\n\t\treturn \"green\";\n\tcase HUB_LED_OFF:\n\t\treturn \"off\";\n\tcase HUB_LED_AUTO:\n\t\treturn \"auto\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n \nstatic void set_port_led(struct usb_hub *hub, int port1, int selector)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint status;\n\n\tstatus = set_port_feature(hub->hdev, (selector << 8) | port1,\n\t\t\tUSB_PORT_FEAT_INDICATOR);\n\tdev_dbg(&port_dev->dev, \"indicator %s status %d\\n\",\n\t\tto_led_name(selector), status);\n}\n\n#define\tLED_CYCLE_PERIOD\t((2*HZ)/3)\n\nstatic void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t \n\n\t\tswitch (hub->indicator[i]) {\n\t\t \n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t \n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t \n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t \n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n\n \n#define\tUSB_STS_TIMEOUT\t\t1000\n#define\tUSB_STS_RETRIES\t\t5\n\n \nstatic int get_hub_status(struct usb_device *hdev,\n\t\tstruct usb_hub_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\n \nstatic int get_port_status(struct usb_device *hdev, int port1,\n\t\t\t   void *data, u16 value, u16 length)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, value,\n\t\t\tport1, data, length, USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\nstatic int hub_ext_port_status(struct usb_hub *hub, int port1, int type,\n\t\t\t       u16 *status, u16 *change, u32 *ext_status)\n{\n\tint ret;\n\tint len = 4;\n\n\tif (type != HUB_PORT_STATUS)\n\t\tlen = 8;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port, type, len);\n\tif (ret < len) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->port.wPortStatus);\n\t\t*change = le16_to_cpu(hub->status->port.wPortChange);\n\t\tif (type != HUB_PORT_STATUS && ext_status)\n\t\t\t*ext_status = le32_to_cpu(\n\t\t\t\thub->status->port.dwExtPortStatus);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nint usb_hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change)\n{\n\treturn hub_ext_port_status(hub, port1, HUB_PORT_STATUS,\n\t\t\t\t   status, change, NULL);\n}\n\nstatic void hub_resubmit_irq_urb(struct usb_hub *hub)\n{\n\tunsigned long flags;\n\tint status;\n\n\tspin_lock_irqsave(&hub->irq_urb_lock, flags);\n\n\tif (hub->quiescing) {\n\t\tspin_unlock_irqrestore(&hub->irq_urb_lock, flags);\n\t\treturn;\n\t}\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status && status != -ENODEV && status != -EPERM &&\n\t    status != -ESHUTDOWN) {\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n\t\tmod_timer(&hub->irq_urb_retry, jiffies + HZ);\n\t}\n\n\tspin_unlock_irqrestore(&hub->irq_urb_lock, flags);\n}\n\nstatic void hub_retry_irq_urb(struct timer_list *t)\n{\n\tstruct usb_hub *hub = from_timer(hub, t, irq_urb_retry);\n\n\thub_resubmit_irq_urb(hub);\n}\n\n\nstatic void kick_hub_wq(struct usb_hub *hub)\n{\n\tstruct usb_interface *intf;\n\n\tif (hub->disconnected || work_pending(&hub->events))\n\t\treturn;\n\n\t \n\tintf = to_usb_interface(hub->intfdev);\n\tusb_autopm_get_interface_no_resume(intf);\n\tkref_get(&hub->kref);\n\n\tif (queue_work(hub_wq, &hub->events))\n\t\treturn;\n\n\t \n\tusb_autopm_put_interface_async(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nvoid usb_kick_hub_wq(struct usb_device *hdev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hub)\n\t\tkick_hub_wq(hub);\n}\n\n \nvoid usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tport_dev = hub->ports[portnum - 1];\n\t\tif (port_dev && port_dev->child)\n\t\t\tpm_wakeup_event(&port_dev->child->dev, 0);\n\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_notification);\n\n \nstatic void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t \n\tcase -ECONNRESET:\t \n\tcase -ESHUTDOWN:\t \n\t\treturn;\n\n\tdefault:\t\t \n\t\t \n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\tfallthrough;\n\n\t \n\tcase 0:\t\t\t \n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t \n\tkick_hub_wq(hub);\n\nresubmit:\n\thub_resubmit_irq_urb(hub);\n}\n\n \nstatic inline int\nhub_clear_tt_buffer(struct usb_device *hdev, u16 devinfo, u16 tt)\n{\n\t \n\tif (((devinfo >> 11) & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\tint status = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\tHUB_CLEAR_TT_BUFFER, USB_RT_PORT,\n\t\t\t\tdevinfo ^ 0x8000, tt, NULL, 0, 1000);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\n\t\t\t       tt, NULL, 0, 1000);\n}\n\n \nstatic void hub_tt_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, tt.clear_work);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hub->tt.lock, flags);\n\twhile (!list_empty(&hub->tt.clear_list)) {\n\t\tstruct list_head\t*next;\n\t\tstruct usb_tt_clear\t*clear;\n\t\tstruct usb_device\t*hdev = hub->hdev;\n\t\tconst struct hc_driver\t*drv;\n\t\tint\t\t\tstatus;\n\n\t\tnext = hub->tt.clear_list.next;\n\t\tclear = list_entry(next, struct usb_tt_clear, clear_list);\n\t\tlist_del(&clear->clear_list);\n\n\t\t \n\t\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n\t\tstatus = hub_clear_tt_buffer(hdev, clear->devinfo, clear->tt);\n\t\tif (status && status != -ENODEV)\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"clear tt %d (%04x) error %d\\n\",\n\t\t\t\tclear->tt, clear->devinfo, status);\n\n\t\t \n\t\tdrv = clear->hcd->driver;\n\t\tif (drv->clear_tt_buffer_complete)\n\t\t\t(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\n\n\t\tkfree(clear);\n\t\tspin_lock_irqsave(&hub->tt.lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n}\n\n \nint usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\t\t   int port1, bool set)\n{\n\tint ret;\n\n\tif (set)\n\t\tret = set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\telse\n\t\tret = usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tset_bit(port1, hub->power_bits);\n\telse\n\t\tclear_bit(port1, hub->power_bits);\n\treturn 0;\n}\n\n \nint usb_hub_clear_tt_buffer(struct urb *urb)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tpipe = urb->pipe;\n\tstruct usb_tt\t\t*tt = udev->tt;\n\tunsigned long\t\tflags;\n\tstruct usb_tt_clear\t*clear;\n\n\t \n\tclear = kmalloc(sizeof *clear, GFP_ATOMIC);\n\tif (clear == NULL) {\n\t\tdev_err(&udev->dev, \"can't save CLEAR_TT_BUFFER state\\n\");\n\t\t \n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tclear->tt = tt->multi ? udev->ttport : 1;\n\tclear->devinfo = usb_pipeendpoint (pipe);\n\tclear->devinfo |= ((u16)udev->devaddr) << 4;\n\tclear->devinfo |= usb_pipecontrol(pipe)\n\t\t\t? (USB_ENDPOINT_XFER_CONTROL << 11)\n\t\t\t: (USB_ENDPOINT_XFER_BULK << 11);\n\tif (usb_pipein(pipe))\n\t\tclear->devinfo |= 1 << 15;\n\n\t \n\tclear->hcd = bus_to_hcd(udev->bus);\n\tclear->ep = urb->ep;\n\n\t \n\tspin_lock_irqsave(&tt->lock, flags);\n\tlist_add_tail(&clear->clear_list, &tt->clear_list);\n\tschedule_work(&tt->clear_work);\n\tspin_unlock_irqrestore(&tt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);\n\nstatic void hub_power_on(struct usb_hub *hub, bool do_delay)\n{\n\tint port1;\n\n\t \n\tif (hub_is_port_power_switchable(hub))\n\t\tdev_dbg(hub->intfdev, \"enabling power on all ports\\n\");\n\telse\n\t\tdev_dbg(hub->intfdev, \"trying to enable port power on \"\n\t\t\t\t\"non-switchable hub\\n\");\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; port1++)\n\t\tif (test_bit(port1, hub->power_bits))\n\t\t\tset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\n\t\telse\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_POWER);\n\tif (do_delay)\n\t\tmsleep(hub_power_on_good_delay(hub));\n}\n\nstatic int hub_hub_status(struct usb_hub *hub,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_hub_status(hub->hdev, &hub->status->hub);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->hub.wHubStatus);\n\t\t*change = le16_to_cpu(hub->status->hub.wHubChange);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_set_port_link_state(struct usb_hub *hub, int port1,\n\t\t\tunsigned int link_status)\n{\n\treturn set_port_feature(hub->hdev,\n\t\t\tport1 | (link_status << 3),\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n}\n\n \nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\n{\n\tdev_dbg(&hub->ports[port1 - 1]->dev, \"logical disconnect\\n\");\n\thub_port_disable(hub, port1, 1);\n\n\t \n\n\tset_bit(port1, hub->change_bits);\n\tkick_hub_wq(hub);\n}\n\n \nint usb_remove_device(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_interface *intf;\n\tint ret;\n\n\tif (!udev->parent)\t \n\t\treturn -EINVAL;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tintf = to_usb_interface(hub->intfdev);\n\n\tret = usb_autopm_get_interface(intf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tset_bit(udev->portnum, hub->removed_bits);\n\thub_port_logical_disconnect(hub, udev->portnum);\n\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nenum hub_activation_type {\n\tHUB_INIT, HUB_INIT2, HUB_INIT3,\t\t \n\tHUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,\n};\n\nstatic void hub_init_func2(struct work_struct *ws);\nstatic void hub_init_func3(struct work_struct *ws);\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n\tunsigned delay;\n\n\t \n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\tdevice_lock(&hdev->dev);\n\n\t\t \n\t\tif (hub->disconnected)\n\t\t\tgoto disconnected;\n\t\tif (type == HUB_INIT2)\n\t\t\tgoto init2;\n\t\tgoto init3;\n\t}\n\tkref_get(&hub->kref);\n\n\t \n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t \n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t \n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t \n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t \n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"Host not accepting hub info update\\n\");\n\t\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"LS/FS devices and hubs may not work under this hub\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t \n\t} else if (hub_is_superspeed(hub->hdev))\n\t\tmsleep(20);\n\n init2:\n\n\t \n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = usb_hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (status)\n\t\t\tgoto abort;\n\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t \n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t \n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t \n\t\tif (type == HUB_RESUME &&\n\t\t    hub_port_warm_reset_required(hub, port1, portstatus))\n\t\t\tset_bit(port1, hub->event_bits);\n\n\t\t \n\t\tif (hub_is_superspeed(hdev) &&\n\t\t    ((portstatus & USB_PORT_STAT_LINK_STATE) ==\n\t\t\t\t\t\tUSB_SS_PORT_LS_POLLING))\n\t\t\tneed_debounce_delay = true;\n\n\t\t \n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t \n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t \n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portchange & USB_PORT_STAT_C_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT) ||\n\t\t\t    (portchange & USB_PORT_STAT_C_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t \n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->event_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t \n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t \n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t \n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t \n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\t\t\tdevice_unlock(&hdev->dev);\n\t\t\treturn;\t\t \n\t\t} else {\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t \n\tkick_hub_wq(hub);\n abort:\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\t \n disconnected:\n\t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n\t\tdevice_unlock(&hdev->dev);\n\t}\n\n\tkref_put(&hub->kref, hub_release);\n}\n\n \nstatic void hub_init_func2(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT2);\n}\n\nstatic void hub_init_func3(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT3);\n}\n\nenum hub_quiescing_type {\n\tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n};\n\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tunsigned long flags;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&hub->irq_urb_lock, flags);\n\thub->quiescing = 1;\n\tspin_unlock_irqrestore(&hub->irq_urb_lock, flags);\n\n\tif (type != HUB_SUSPEND) {\n\t\t \n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (hub->ports[i]->child)\n\t\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t\t}\n\t}\n\n\t \n\tdel_timer_sync(&hub->irq_urb_retry);\n\tusb_kill_urb(hub->urb);\n\tif (hub->has_indicators)\n\t\tcancel_delayed_work_sync(&hub->leds);\n\tif (hub->tt.hub)\n\t\tflush_work(&hub->tt.clear_work);\n}\n\nstatic void hub_pm_barrier_for_all_ports(struct usb_hub *hub)\n{\n\tint i;\n\n\tfor (i = 0; i < hub->hdev->maxchild; ++i)\n\t\tpm_runtime_barrier(&hub->ports[i]->dev);\n}\n\n \nstatic int hub_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub_quiesce(hub, HUB_PRE_RESET);\n\thub->in_reset = 1;\n\thub_pm_barrier_for_all_ports(hub);\n\treturn 0;\n}\n\n \nstatic int hub_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub->in_reset = 0;\n\thub_pm_barrier_for_all_ports(hub);\n\thub_activate(hub, HUB_POST_RESET);\n\treturn 0;\n}\n\nstatic int hub_configure(struct usb_hub *hub,\n\tstruct usb_endpoint_descriptor *endpoint)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct device *hub_dev = hub->intfdev;\n\tu16 hubstatus, hubchange;\n\tu16 wHubCharacteristics;\n\tunsigned int pipe;\n\tint maxp, ret, i;\n\tchar *message = \"out of memory\";\n\tunsigned unit_load;\n\tunsigned full_load;\n\tunsigned maxchild;\n\n\thub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\n\tif (!hub->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\n\tif (!hub->status) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmutex_init(&hub->status_mutex);\n\n\thub->descriptor = kzalloc(sizeof(*hub->descriptor), GFP_KERNEL);\n\tif (!hub->descriptor) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t \n\tret = get_hub_descriptor(hdev, hub->descriptor);\n\tif (ret < 0) {\n\t\tmessage = \"can't read hub descriptor\";\n\t\tgoto fail;\n\t}\n\n\tmaxchild = USB_MAXCHILDREN;\n\tif (hub_is_superspeed(hdev))\n\t\tmaxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);\n\n\tif (hub->descriptor->bNbrPorts > maxchild) {\n\t\tmessage = \"hub has too many ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts == 0) {\n\t\tmessage = \"hub doesn't have any ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (hub_is_superspeed(hdev) || hub_is_superspeedplus(hdev)) {\n\t\tu32 delay = __le16_to_cpu(hub->descriptor->u.ss.wHubDelay);\n\n\t\tif (hdev->parent)\n\t\t\tdelay += hdev->parent->hub_delay;\n\n\t\tdelay += USB_TP_TRANSMISSION_DELAY;\n\t\thdev->hub_delay = min_t(u32, delay, USB_TP_TRANSMISSION_DELAY_MAX);\n\t}\n\n\tmaxchild = hub->descriptor->bNbrPorts;\n\tdev_info(hub_dev, \"%d port%s detected\\n\", maxchild,\n\t\t\t(maxchild == 1) ? \"\" : \"s\");\n\n\thub->ports = kcalloc(maxchild, sizeof(struct usb_port *), GFP_KERNEL);\n\tif (!hub->ports) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\tif (hub_is_superspeed(hdev)) {\n\t\tunit_load = 150;\n\t\tfull_load = 900;\n\t} else {\n\t\tunit_load = 100;\n\t\tfull_load = 500;\n\t}\n\n\t \n\tif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\n\t\t\t!(hub_is_superspeed(hdev))) {\n\t\tchar\tportstr[USB_MAXCHILDREN + 1];\n\n\t\tfor (i = 0; i < maxchild; i++)\n\t\t\tportstr[i] = hub->descriptor->u.hs.DeviceRemovable\n\t\t\t\t    [((i + 1) / 8)] & (1 << ((i + 1) % 8))\n\t\t\t\t? 'F' : 'R';\n\t\tportstr[maxchild] = 0;\n\t\tdev_dbg(hub_dev, \"compound device; port removable status: %s\\n\", portstr);\n\t} else\n\t\tdev_dbg(hub_dev, \"standalone hub\\n\");\n\n\tswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\n\tcase HUB_CHAR_COMMON_LPSM:\n\t\tdev_dbg(hub_dev, \"ganged power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_LPSM:\n\t\tdev_dbg(hub_dev, \"individual port power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_LPSM:\n\tcase HUB_CHAR_LPSM:\n\t\tdev_dbg(hub_dev, \"no power switching (usb 1.0)\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\n\tcase HUB_CHAR_COMMON_OCPM:\n\t\tdev_dbg(hub_dev, \"global over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_OCPM:\n\t\tdev_dbg(hub_dev, \"individual port over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_OCPM:\n\tcase HUB_CHAR_OCPM:\n\t\tdev_dbg(hub_dev, \"no over-current protection\\n\");\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&hub->tt.lock);\n\tINIT_LIST_HEAD(&hub->tt.clear_list);\n\tINIT_WORK(&hub->tt.clear_work, hub_tt_work);\n\tswitch (hdev->descriptor.bDeviceProtocol) {\n\tcase USB_HUB_PR_FS:\n\t\tbreak;\n\tcase USB_HUB_PR_HS_SINGLE_TT:\n\t\tdev_dbg(hub_dev, \"Single TT\\n\");\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_HS_MULTI_TT:\n\t\tret = usb_set_interface(hdev, 0, 1);\n\t\tif (ret == 0) {\n\t\t\tdev_dbg(hub_dev, \"TT per port\\n\");\n\t\t\thub->tt.multi = 1;\n\t\t} else\n\t\t\tdev_err(hub_dev, \"Using single TT (err %d)\\n\",\n\t\t\t\tret);\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_SS:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(hub_dev, \"Unrecognized hub protocol %d\\n\",\n\t\t\thdev->descriptor.bDeviceProtocol);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\n\tcase HUB_TTTT_8_BITS:\n\t\tif (hdev->descriptor.bDeviceProtocol != 0) {\n\t\t\thub->tt.think_time = 666;\n\t\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t\t8, hub->tt.think_time);\n\t\t}\n\t\tbreak;\n\tcase HUB_TTTT_16_BITS:\n\t\thub->tt.think_time = 666 * 2;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t16, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_24_BITS:\n\t\thub->tt.think_time = 666 * 3;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t24, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_32_BITS:\n\t\thub->tt.think_time = 666 * 4;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t32, hub->tt.think_time);\n\t\tbreak;\n\t}\n\n\t \n\tif (wHubCharacteristics & HUB_CHAR_PORTIND) {\n\t\thub->has_indicators = 1;\n\t\tdev_dbg(hub_dev, \"Port indicators are supported\\n\");\n\t}\n\n\tdev_dbg(hub_dev, \"power on to power good time: %dms\\n\",\n\t\thub->descriptor->bPwrOn2PwrGood * 2);\n\n\t \n\tret = usb_get_std_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\n\tif (ret) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hdev == hdev->bus->root_hub) {\n\t\tif (hcd->power_budget > 0)\n\t\t\thdev->bus_mA = hcd->power_budget;\n\t\telse\n\t\t\thdev->bus_mA = full_load * maxchild;\n\t\tif (hdev->bus_mA >= full_load)\n\t\t\thub->mA_per_port = full_load;\n\t\telse {\n\t\t\thub->mA_per_port = hdev->bus_mA;\n\t\t\thub->limited_power = 1;\n\t\t}\n\t} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\tint remaining = hdev->bus_mA -\n\t\t\thub->descriptor->bHubContrCurrent;\n\n\t\tdev_dbg(hub_dev, \"hub controller current requirement: %dmA\\n\",\n\t\t\thub->descriptor->bHubContrCurrent);\n\t\thub->limited_power = 1;\n\n\t\tif (remaining < maxchild * unit_load)\n\t\t\tdev_warn(hub_dev,\n\t\t\t\t\t\"insufficient power available \"\n\t\t\t\t\t\"to use all downstream ports\\n\");\n\t\thub->mA_per_port = unit_load;\t \n\n\t} else {\t \n\t\t \n\t\thub->mA_per_port = full_load;\n\t}\n\tif (hub->mA_per_port < full_load)\n\t\tdev_dbg(hub_dev, \"%umA bus power budget for each child\\n\",\n\t\t\t\thub->mA_per_port);\n\n\tret = hub_hub_status(hub, &hubstatus, &hubchange);\n\tif (ret < 0) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\n\t \n\tif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\n\t\tdev_dbg(hub_dev, \"local power source is %s\\n\",\n\t\t\t(hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t? \"lost (inactive)\" : \"good\");\n\n\tif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\n\t\tdev_dbg(hub_dev, \"%sover-current condition exists\\n\",\n\t\t\t(hubstatus & HUB_STATUS_OVERCURRENT) ? \"\" : \"no \");\n\n\t \n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe);\n\n\tif (maxp > sizeof(*hub->buffer))\n\t\tmaxp = sizeof(*hub->buffer);\n\n\thub->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hub->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n\t\thub, endpoint->bInterval);\n\n\t \n\tif (hub->has_indicators && blinkenlights)\n\t\thub->indicator[0] = INDICATOR_CYCLE;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tfor (i = 0; i < maxchild; i++) {\n\t\tret = usb_hub_create_port_device(hub, i + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"couldn't create port%d device.\\n\", i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\thdev->maxchild = i;\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i];\n\n\t\tpm_runtime_put(&port_dev->dev);\n\t}\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t \n\tif (hcd->driver->update_hub_device) {\n\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t&hub->tt, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmessage = \"can't update HCD hub info\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tusb_hub_adjust_deviceremovable(hdev, hub->descriptor);\n\n\thub_activate(hub, HUB_INIT);\n\treturn 0;\n\nfail:\n\tdev_err(hub_dev, \"config failed, %s (err %d)\\n\",\n\t\t\tmessage, ret);\n\t \n\treturn ret;\n}\n\nstatic void hub_release(struct kref *kref)\n{\n\tstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\n\n\tusb_put_dev(hub->hdev);\n\tusb_put_intf(to_usb_interface(hub->intfdev));\n\tkfree(hub);\n}\n\nstatic unsigned highspeed_hubs;\n\nstatic void hub_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tint port1;\n\n\t \n\thub->disconnected = 1;\n\n\t \n\thub->error = 0;\n\thub_quiesce(hub, HUB_DISCONNECT);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\n\t \n\tspin_lock_irq(&device_state_lock);\n\tport1 = hdev->maxchild;\n\thdev->maxchild = 0;\n\tusb_set_intfdata(intf, NULL);\n\tspin_unlock_irq(&device_state_lock);\n\n\tfor (; port1 > 0; --port1)\n\t\tusb_hub_remove_port_device(hub, port1);\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\tif (hub->hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs--;\n\n\tusb_free_urb(hub->urb);\n\tkfree(hub->ports);\n\tkfree(hub->descriptor);\n\tkfree(hub->status);\n\tkfree(hub->buffer);\n\n\tpm_suspend_ignore_children(&intf->dev, false);\n\n\tif (hub->quirk_disable_autosuspend)\n\t\tusb_autopm_put_interface(intf);\n\n\tonboard_hub_destroy_pdevs(&hub->onboard_hub_devs);\n\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic bool hub_descriptor_is_sane(struct usb_host_interface *desc)\n{\n\t \n\t \n\tif (desc->desc.bInterfaceSubClass != 0 &&\n\t    desc->desc.bInterfaceSubClass != 1)\n\t\treturn false;\n\n\t \n\tif (desc->desc.bNumEndpoints != 1)\n\t\treturn false;\n\n\t \n\tif (!usb_endpoint_is_int_in(&desc->endpoint[0].desc))\n\t\treturn false;\n\n        return true;\n}\n\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *desc;\n\tstruct usb_device *hdev;\n\tstruct usb_hub *hub;\n\n\tdesc = intf->cur_altsetting;\n\thdev = interface_to_usbdev(intf);\n\n\t \n#ifdef CONFIG_PM\n\tif (hdev->dev.power.autosuspend_delay >= 0)\n\t\tpm_runtime_set_autosuspend_delay(&hdev->dev, 0);\n#endif\n\n\t \n\tif (hdev->parent) {\t\t \n\t\tusb_enable_autosuspend(hdev);\n\t} else {\t\t\t \n\t\tconst struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;\n\n\t\tif (drv->bus_suspend && drv->bus_resume)\n\t\t\tusb_enable_autosuspend(hdev);\n\t}\n\n\tif (hdev->level == MAX_TOPO_LEVEL) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unsupported bus topology: hub nested too deep\\n\");\n\t\treturn -E2BIG;\n\t}\n\n#ifdef\tCONFIG_USB_OTG_DISABLE_EXTERNAL_HUB\n\tif (hdev->parent) {\n\t\tdev_warn(&intf->dev, \"ignoring external hub\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\tif (!hub_descriptor_is_sane(desc)) {\n\t\tdev_err(&intf->dev, \"bad descriptor, ignoring hub\\n\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tdev_info(&intf->dev, \"USB hub found\\n\");\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\tkref_init(&hub->kref);\n\thub->intfdev = &intf->dev;\n\thub->hdev = hdev;\n\tINIT_DELAYED_WORK(&hub->leds, led_work);\n\tINIT_DELAYED_WORK(&hub->init_work, NULL);\n\tINIT_WORK(&hub->events, hub_event);\n\tINIT_LIST_HEAD(&hub->onboard_hub_devs);\n\tspin_lock_init(&hub->irq_urb_lock);\n\ttimer_setup(&hub->irq_urb_retry, hub_retry_irq_urb, 0);\n\tusb_get_intf(intf);\n\tusb_get_dev(hdev);\n\n\tusb_set_intfdata(intf, hub);\n\tintf->needs_remote_wakeup = 1;\n\tpm_suspend_ignore_children(&intf->dev, true);\n\n\tif (hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs++;\n\n\tif (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)\n\t\thub->quirk_check_port_auto_suspend = 1;\n\n\tif (id->driver_info & HUB_QUIRK_DISABLE_AUTOSUSPEND) {\n\t\thub->quirk_disable_autosuspend = 1;\n\t\tusb_autopm_get_interface_no_resume(intf);\n\t}\n\n\tif (hub_configure(hub, &desc->endpoint[0].desc) >= 0) {\n\t\tonboard_hub_create_pdevs(hdev, &hub->onboard_hub_devs);\n\n\t\treturn 0;\n\t}\n\n\thub_disconnect(intf);\n\treturn -ENODEV;\n}\n\nstatic int\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\n{\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\t \n\tswitch (code) {\n\tcase USBDEVFS_HUB_PORTINFO: {\n\t\tstruct usbdevfs_hub_portinfo *info = user_data;\n\t\tint i;\n\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->devnum <= 0)\n\t\t\tinfo->nports = 0;\n\t\telse {\n\t\t\tinfo->nports = hdev->maxchild;\n\t\t\tfor (i = 0; i < info->nports; i++) {\n\t\t\t\tif (hub->ports[i]->child == NULL)\n\t\t\t\t\tinfo->port[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tinfo->port[i] =\n\t\t\t\t\t\thub->ports[i]->child->devnum;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&device_state_lock);\n\n\t\treturn info->nports + 1;\n\t\t}\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n \nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state ***ppowner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (port1 == 0 || port1 > hdev->maxchild)\n\t\treturn -EINVAL;\n\n\t \n\t*ppowner = &(hub->ports[port1 - 1]->port_owner);\n\treturn 0;\n}\n\n \nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\t       struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner)\n\t\treturn -EBUSY;\n\t*powner = owner;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_claim_port);\n\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\t\t struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner != owner)\n\t\treturn -ENOENT;\n\t*powner = NULL;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_release_port);\n\nvoid usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tint n;\n\n\tfor (n = 0; n < hdev->maxchild; n++) {\n\t\tif (hub->ports[n]->port_owner == owner)\n\t\t\thub->ports[n]->port_owner = NULL;\n\t}\n\n}\n\n \nbool usb_device_is_owned(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\n\tif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\n\t\treturn false;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\treturn !!hub->ports[udev->portnum - 1]->port_owner;\n}\n\nstatic void update_port_device_state(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (udev->parent) {\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[udev->portnum - 1];\n\t\tWRITE_ONCE(port_dev->state, udev->state);\n\t\tsysfs_notify_dirent(port_dev->state_kn);\n\t}\n}\n\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\tfor (i = 0; i < udev->maxchild; ++i) {\n\t\tif (hub->ports[i]->child)\n\t\t\trecursively_mark_NOTATTACHED(hub->ports[i]->child);\n\t}\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\tudev->active_duration -= jiffies;\n\tudev->state = USB_STATE_NOTATTACHED;\n\tupdate_port_device_state(udev);\n}\n\n \nvoid usb_set_device_state(struct usb_device *udev,\n\t\tenum usb_device_state new_state)\n{\n\tunsigned long flags;\n\tint wakeup = -1;\n\n\tspin_lock_irqsave(&device_state_lock, flags);\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t;\t \n\telse if (new_state != USB_STATE_NOTATTACHED) {\n\n\t\t \n\t\tif (udev->parent) {\n\t\t\tif (udev->state == USB_STATE_SUSPENDED\n\t\t\t\t\t|| new_state == USB_STATE_SUSPENDED)\n\t\t\t\t;\t \n\t\t\telse if (new_state == USB_STATE_CONFIGURED)\n\t\t\t\twakeup = (udev->quirks &\n\t\t\t\t\tUSB_QUIRK_IGNORE_REMOTE_WAKEUP) ? 0 :\n\t\t\t\t\tudev->actconfig->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_WAKEUP;\n\t\t\telse\n\t\t\t\twakeup = 0;\n\t\t}\n\t\tif (udev->state == USB_STATE_SUSPENDED &&\n\t\t\tnew_state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration -= jiffies;\n\t\telse if (new_state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration += jiffies;\n\t\tudev->state = new_state;\n\t\tupdate_port_device_state(udev);\n\t} else\n\t\trecursively_mark_NOTATTACHED(udev);\n\tspin_unlock_irqrestore(&device_state_lock, flags);\n\tif (wakeup >= 0)\n\t\tdevice_set_wakeup_capable(&udev->dev, wakeup);\n}\nEXPORT_SYMBOL_GPL(usb_set_device_state);\n\n \nstatic void choose_devnum(struct usb_device *udev)\n{\n\tint\t\tdevnum;\n\tstruct usb_bus\t*bus = udev->bus;\n\n\t \n\tmutex_lock(&bus->devnum_next_mutex);\n\n\t \n\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\n\t\t\tbus->devnum_next);\n\tif (devnum >= 128)\n\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128, 1);\n\tbus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);\n\tif (devnum < 128) {\n\t\tset_bit(devnum, bus->devmap.devicemap);\n\t\tudev->devnum = devnum;\n\t}\n\tmutex_unlock(&bus->devnum_next_mutex);\n}\n\nstatic void release_devnum(struct usb_device *udev)\n{\n\tif (udev->devnum > 0) {\n\t\tclear_bit(udev->devnum, udev->bus->devmap.devicemap);\n\t\tudev->devnum = -1;\n\t}\n}\n\nstatic void update_devnum(struct usb_device *udev, int devnum)\n{\n\tudev->devnum = devnum;\n\tif (!udev->devaddr)\n\t\tudev->devaddr = (u8)devnum;\n}\n\nstatic void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t \n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n\nstatic void hub_disconnect_children(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\t \n\tfor (i = 0; i < udev->maxchild; i++) {\n\t\tif (hub->ports[i]->child)\n\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t}\n}\n\n \nvoid usb_disconnect(struct usb_device **pdev)\n{\n\tstruct usb_port *port_dev = NULL;\n\tstruct usb_device *udev = *pdev;\n\tstruct usb_hub *hub = NULL;\n\tint port1 = 1;\n\n\t \n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tdev_info(&udev->dev, \"USB disconnect, device number %d\\n\",\n\t\t\tudev->devnum);\n\n\t \n\tpm_runtime_barrier(&udev->dev);\n\n\tusb_lock_device(udev);\n\n\thub_disconnect_children(udev);\n\n\t \n\tdev_dbg(&udev->dev, \"unregistering device\\n\");\n\tusb_disable_device(udev, 0);\n\tusb_hcd_synchronize_unlinks(udev);\n\n\tif (udev->parent) {\n\t\tport1 = udev->portnum;\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[port1 - 1];\n\n\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\tsysfs_remove_link(&port_dev->dev.kobj, \"device\");\n\n\t\t \n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\tusb_remove_ep_devs(&udev->ep0);\n\tusb_unlock_device(udev);\n\n\t \n\tdevice_del(&udev->dev);\n\n\t \n\trelease_devnum(udev);\n\n\t \n\tspin_lock_irq(&device_state_lock);\n\t*pdev = NULL;\n\tspin_unlock_irq(&device_state_lock);\n\n\tif (port_dev && test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put(&port_dev->dev);\n\n\thub_free_dev(udev);\n\n\tput_device(&udev->dev);\n}\n\n#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES\nstatic void show_string(struct usb_device *udev, char *id, char *string)\n{\n\tif (!string)\n\t\treturn;\n\tdev_info(&udev->dev, \"%s: %s\\n\", id, string);\n}\n\nstatic void announce_device(struct usb_device *udev)\n{\n\tu16 bcdDevice = le16_to_cpu(udev->descriptor.bcdDevice);\n\n\tdev_info(&udev->dev,\n\t\t\"New USB device found, idVendor=%04x, idProduct=%04x, bcdDevice=%2x.%02x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\tbcdDevice >> 8, bcdDevice & 0xff);\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n#else\nstatic inline void announce_device(struct usb_device *udev) { }\n#endif\n\n\n \nstatic int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t \n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t \n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t \n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t \n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t \n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n\n\n \nstatic int usb_enumerate_device(struct usb_device *udev)\n{\n\tint err;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (udev->config == NULL) {\n\t\terr = usb_get_configuration(udev);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"can't read configurations, error %d\\n\",\n\t\t\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\n\tudev->manufacturer = usb_cache_string(udev,\n\t\t\t\t\t      udev->descriptor.iManufacturer);\n\tudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\n\n\terr = usb_enumerate_device_otg(udev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_USB_OTG_PRODUCTLIST) && hcd->tpl_support &&\n\t\t!is_targeted(udev)) {\n\t\t \n\t\tif (IS_ENABLED(CONFIG_USB_OTG) && (udev->bus->b_hnp_enable\n\t\t\t|| udev->bus->is_b_host)) {\n\t\t\terr = usb_port_suspend(udev, PMSG_AUTO_SUSPEND);\n\t\t\tif (err < 0)\n\t\t\t\tdev_dbg(&udev->dev, \"HNP fail, %d\\n\", err);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\tusb_detect_interface_quirks(udev);\n\n\treturn 0;\n}\n\nstatic void set_usb_port_removable(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hub *hub;\n\tu8 port = udev->portnum;\n\tu16 wHubCharacteristics;\n\tbool removable = true;\n\n\tdev_set_removable(&udev->dev, DEVICE_REMOVABLE_UNKNOWN);\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\n\t \n\tswitch (hub->ports[udev->portnum - 1]->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tdev_set_removable(&udev->dev, DEVICE_REMOVABLE);\n\t\treturn;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\tcase USB_PORT_NOT_USED:\n\t\tdev_set_removable(&udev->dev, DEVICE_FIXED);\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\n\tif (!(wHubCharacteristics & HUB_CHAR_COMPOUND))\n\t\treturn;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tif (le16_to_cpu(hub->descriptor->u.ss.DeviceRemovable)\n\t\t\t\t& (1 << port))\n\t\t\tremovable = false;\n\t} else {\n\t\tif (hub->descriptor->u.hs.DeviceRemovable[port / 8] & (1 << (port % 8)))\n\t\t\tremovable = false;\n\t}\n\n\tif (removable)\n\t\tdev_set_removable(&udev->dev, DEVICE_REMOVABLE);\n\telse\n\t\tdev_set_removable(&udev->dev, DEVICE_FIXED);\n\n}\n\n \nint usb_new_device(struct usb_device *udev)\n{\n\tint err;\n\n\tif (udev->parent) {\n\t\t \n\t\tdevice_init_wakeup(&udev->dev, 0);\n\t}\n\n\t \n\tpm_runtime_set_active(&udev->dev);\n\tpm_runtime_get_noresume(&udev->dev);\n\tpm_runtime_use_autosuspend(&udev->dev);\n\tpm_runtime_enable(&udev->dev);\n\n\t \n\tusb_disable_autosuspend(udev);\n\n\terr = usb_enumerate_device(udev);\t \n\tif (err < 0)\n\t\tgoto fail;\n\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",\n\t\t\tudev->devnum, udev->bus->busnum,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\t \n\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\n\t \n\tannounce_device(udev);\n\n\tif (udev->serial)\n\t\tadd_device_randomness(udev->serial, strlen(udev->serial));\n\tif (udev->product)\n\t\tadd_device_randomness(udev->product, strlen(udev->product));\n\tif (udev->manufacturer)\n\t\tadd_device_randomness(udev->manufacturer,\n\t\t\t\t      strlen(udev->manufacturer));\n\n\tdevice_enable_async_suspend(&udev->dev);\n\n\t \n\tset_usb_port_removable(udev);\n\n\t \n\terr = device_add(&udev->dev);\n\tif (err) {\n\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\t \n\tif (udev->parent) {\n\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\t\tint port1 = udev->portnum;\n\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];\n\n\t\terr = sysfs_create_link(&udev->dev.kobj,\n\t\t\t\t&port_dev->dev.kobj, \"port\");\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\terr = sysfs_create_link(&port_dev->dev.kobj,\n\t\t\t\t&udev->dev.kobj, \"device\");\n\t\tif (err) {\n\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_sync_autosuspend(&udev->dev);\n\treturn err;\n\nfail:\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tpm_runtime_disable(&udev->dev);\n\tpm_runtime_set_suspended(&udev->dev);\n\treturn err;\n}\n\n\n \nint usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}\n\n\nint usb_authorize_device(struct usb_device *usb_dev)\n{\n\tint result = 0, c;\n\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 1)\n\t\tgoto out_authorized;\n\n\tresult = usb_autoresume_device(usb_dev);\n\tif (result < 0) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"can't autoresume for authorization: %d\\n\", result);\n\t\tgoto error_autoresume;\n\t}\n\n\tusb_dev->authorized = 1;\n\t \n\tc = usb_choose_configuration(usb_dev);\n\tif (c >= 0) {\n\t\tresult = usb_set_configuration(usb_dev, c);\n\t\tif (result) {\n\t\t\tdev_err(&usb_dev->dev,\n\t\t\t\t\"can't set config #%d, error %d\\n\", c, result);\n\t\t\t \n\t\t}\n\t}\n\tdev_info(&usb_dev->dev, \"authorized to connect\\n\");\n\n\tusb_autosuspend_device(usb_dev);\nerror_autoresume:\nout_authorized:\n\tusb_unlock_device(usb_dev);\t \n\treturn result;\n}\n\n \nstatic enum usb_ssp_rate get_port_ssp_rate(struct usb_device *hdev,\n\t\t\t\t\t   u32 ext_portstatus)\n{\n\tstruct usb_ssp_cap_descriptor *ssp_cap;\n\tu32 attr;\n\tu8 speed_id;\n\tu8 ssac;\n\tu8 lanes;\n\tint i;\n\n\tif (!hdev->bos)\n\t\tgoto out;\n\n\tssp_cap = hdev->bos->ssp_cap;\n\tif (!ssp_cap)\n\t\tgoto out;\n\n\tspeed_id = ext_portstatus & USB_EXT_PORT_STAT_RX_SPEED_ID;\n\tlanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;\n\n\tssac = le32_to_cpu(ssp_cap->bmAttributes) &\n\t\tUSB_SSP_SUBLINK_SPEED_ATTRIBS;\n\n\tfor (i = 0; i <= ssac; i++) {\n\t\tu8 ssid;\n\n\t\tattr = le32_to_cpu(ssp_cap->bmSublinkSpeedAttr[i]);\n\t\tssid = FIELD_GET(USB_SSP_SUBLINK_SPEED_SSID, attr);\n\t\tif (speed_id == ssid) {\n\t\t\tu16 mantissa;\n\t\t\tu8 lse;\n\t\t\tu8 type;\n\n\t\t\t \n\t\t\ttype = FIELD_GET(USB_SSP_SUBLINK_SPEED_ST, attr);\n\t\t\tif (type == USB_SSP_SUBLINK_SPEED_ST_ASYM_RX ||\n\t\t\t    type == USB_SSP_SUBLINK_SPEED_ST_ASYM_TX)\n\t\t\t\tgoto out;\n\n\t\t\tif (FIELD_GET(USB_SSP_SUBLINK_SPEED_LP, attr) !=\n\t\t\t    USB_SSP_SUBLINK_SPEED_LP_SSP)\n\t\t\t\tgoto out;\n\n\t\t\tlse = FIELD_GET(USB_SSP_SUBLINK_SPEED_LSE, attr);\n\t\t\tmantissa = FIELD_GET(USB_SSP_SUBLINK_SPEED_LSM, attr);\n\n\t\t\t \n\t\t\tfor (; lse < USB_SSP_SUBLINK_SPEED_LSE_GBPS; lse++)\n\t\t\t\tmantissa /= 1000;\n\n\t\t\tif (mantissa >= 10 && lanes == 1)\n\t\t\t\treturn USB_SSP_GEN_2x1;\n\n\t\t\tif (mantissa >= 10 && lanes == 2)\n\t\t\t\treturn USB_SSP_GEN_2x2;\n\n\t\t\tif (mantissa >= 5 && lanes == 2)\n\t\t\t\treturn USB_SSP_GEN_1x2;\n\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\treturn USB_SSP_GEN_UNKNOWN;\n}\n\n#ifdef CONFIG_USB_FEW_INIT_RETRIES\n#define PORT_RESET_TRIES\t2\n#define SET_ADDRESS_TRIES\t1\n#define GET_DESCRIPTOR_TRIES\t1\n#define GET_MAXPACKET0_TRIES\t1\n#define PORT_INIT_TRIES\t\t4\n\n#else\n#define PORT_RESET_TRIES\t5\n#define SET_ADDRESS_TRIES\t2\n#define GET_DESCRIPTOR_TRIES\t2\n#define GET_MAXPACKET0_TRIES\t3\n#define PORT_INIT_TRIES\t\t4\n#endif\t \n\n#define DETECT_DISCONNECT_TRIES 5\n\n#define HUB_ROOT_RESET_TIME\t60\t \n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_BH_RESET_TIME\t50\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t800\n\nstatic bool use_new_scheme(struct usb_device *udev, int retry,\n\t\t\t   struct usb_port *port_dev)\n{\n\tint old_scheme_first_port =\n\t\t(port_dev->quirks & USB_PORT_QUIRK_OLD_SCHEME) ||\n\t\told_scheme_first;\n\n\t \n\tif (udev->speed >= USB_SPEED_SUPER)\n\t\treturn false;\n\n\t \n\tif (use_both_schemes && retry >= (PORT_INIT_TRIES + 1) / 2)\n\t\treturn old_scheme_first_port;\t \n\treturn !old_scheme_first_port;\t\t \n}\n\n \nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}\n\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint delay_time, ret;\n\tu16 portstatus;\n\tu16 portchange;\n\tu32 ext_portstatus = 0;\n\n\tfor (delay_time = 0;\n\t\t\tdelay_time < HUB_RESET_TIMEOUT;\n\t\t\tdelay_time += delay) {\n\t\t \n\t\tmsleep(delay);\n\n\t\t \n\t\tif (hub_is_superspeedplus(hub->hdev))\n\t\t\tret = hub_ext_port_status(hub, port1,\n\t\t\t\t\t\t  HUB_EXT_PORT_STATUS,\n\t\t\t\t\t\t  &portstatus, &portchange,\n\t\t\t\t\t\t  &ext_portstatus);\n\t\telse\n\t\t\tret = usb_hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t      &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (!(portstatus & USB_PORT_STAT_RESET) &&\n\t\t    (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tbreak;\n\n\t\t \n\t\tif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\n\t\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"not %sreset yet, waiting %dms\\n\",\n\t\t\t\twarm ? \"warm \" : \"\", delay);\n\t}\n\n\tif ((portstatus & USB_PORT_STAT_RESET))\n\t\treturn -EBUSY;\n\n\tif (hub_port_warm_reset_required(hub, port1, portstatus))\n\t\treturn -ENOTCONN;\n\n\t \n\tif (!(portstatus & USB_PORT_STAT_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\t \n\tif (!hub_is_superspeed(hub->hdev) &&\n\t    (portchange & USB_PORT_STAT_C_CONNECTION)) {\n\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t       USB_PORT_FEAT_C_CONNECTION);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (!(portstatus & USB_PORT_STAT_ENABLE))\n\t\treturn -EBUSY;\n\n\tif (!udev)\n\t\treturn 0;\n\n\tif (hub_is_superspeedplus(hub->hdev)) {\n\t\t \n\t\tudev->rx_lanes = USB_EXT_PORT_RX_LANES(ext_portstatus) + 1;\n\t\tudev->tx_lanes = USB_EXT_PORT_TX_LANES(ext_portstatus) + 1;\n\t\tudev->ssp_rate = get_port_ssp_rate(hub->hdev, ext_portstatus);\n\t} else {\n\t\tudev->rx_lanes = 1;\n\t\tudev->tx_lanes = 1;\n\t\tudev->ssp_rate = USB_SSP_GEN_UNKNOWN;\n\t}\n\tif (udev->ssp_rate != USB_SSP_GEN_UNKNOWN)\n\t\tudev->speed = USB_SPEED_SUPER_PLUS;\n\telse if (hub_is_superspeed(hub->hdev))\n\t\tudev->speed = USB_SPEED_SUPER;\n\telse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\tudev->speed = USB_SPEED_HIGH;\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\tudev->speed = USB_SPEED_LOW;\n\telse\n\t\tudev->speed = USB_SPEED_FULL;\n\treturn 0;\n}\n\n \nstatic int hub_port_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint i, status;\n\tu16 portchange, portstatus;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint reset_recovery_time;\n\n\tif (!hub_is_superspeed(hub->hdev)) {\n\t\tif (warm) {\n\t\t\tdev_err(hub->intfdev, \"only USB3 hub support \"\n\t\t\t\t\t\t\"warm reset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t \n\t\tdown_read(&ehci_cf_port_reset_rwsem);\n\t} else if (!warm) {\n\t\t \n\t\tif (usb_hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t&portchange) == 0)\n\t\t\tif (hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\t\t\tportstatus))\n\t\t\t\twarm = true;\n\t}\n\tclear_bit(port1, hub->warm_reset_bits);\n\n\t \n\tfor (i = 0; i < PORT_RESET_TRIES; i++) {\n\t\tstatus = set_port_feature(hub->hdev, port1, (warm ?\n\t\t\t\t\tUSB_PORT_FEAT_BH_PORT_RESET :\n\t\t\t\t\tUSB_PORT_FEAT_RESET));\n\t\tif (status == -ENODEV) {\n\t\t\t;\t \n\t\t} else if (status) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"cannot %sreset (err = %d)\\n\",\n\t\t\t\t\twarm ? \"warm \" : \"\", status);\n\t\t} else {\n\t\t\tstatus = hub_port_wait_reset(hub, port1, udev, delay,\n\t\t\t\t\t\t\t\twarm);\n\t\t\tif (status && status != -ENOTCONN && status != -ENODEV)\n\t\t\t\tdev_dbg(hub->intfdev,\n\t\t\t\t\t\t\"port_wait_reset: err = %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\n\t\t \n\t\tif (status == 0 || status == -ENOTCONN || status == -ENODEV ||\n\t\t    (status == -EBUSY && i == PORT_RESET_TRIES - 1)) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\n\t\t\tif (!hub_is_superspeed(hub->hdev))\n\t\t\t\tgoto done;\n\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\n\t\t\tif (udev)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\t \n\t\t\tif (usb_hub_port_status(hub, port1,\n\t\t\t\t\t&portstatus, &portchange) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (!hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\tportstatus))\n\t\t\t\tgoto done;\n\n\t\t\t \n\t\t\tif (!warm) {\n\t\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\t\t\"hot reset failed, warm reset\\n\");\n\t\t\t\twarm = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"not enabled, trying %sreset again...\\n\",\n\t\t\t\twarm ? \"warm \" : \"\");\n\t\tdelay = HUB_LONG_RESET_TIME;\n\t}\n\n\tdev_err(&port_dev->dev, \"Cannot enable. Maybe the USB cable is bad?\\n\");\n\ndone:\n\tif (status == 0) {\n\t\tif (port_dev->quirks & USB_PORT_QUIRK_FAST_ENUM)\n\t\t\tusleep_range(10000, 12000);\n\t\telse {\n\t\t\t \n\t\t\treset_recovery_time = 10 + 40;\n\n\t\t\t \n\t\t\tif (hub->hdev->quirks & USB_QUIRK_HUB_SLOW_RESET)\n\t\t\t\treset_recovery_time += 100;\n\n\t\t\tmsleep(reset_recovery_time);\n\t\t}\n\n\t\tif (udev) {\n\t\t\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t\t\tupdate_devnum(udev, 0);\n\t\t\t \n\t\t\tif (hcd->driver->reset_device)\n\t\t\t\thcd->driver->reset_device(hcd, udev);\n\n\t\t\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\t\t}\n\t} else {\n\t\tif (udev)\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t}\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\tup_read(&ehci_cf_port_reset_rwsem);\n\n\treturn status;\n}\n\n \nstatic bool hub_port_stop_enumerate(struct usb_hub *hub, int port1, int retries)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tif (port_dev->early_stop) {\n\t\tif (port_dev->ignore_event)\n\t\t\treturn true;\n\n\t\t \n\t\tif (retries < 2)\n\t\t\treturn false;\n\n\t\tport_dev->ignore_event = 1;\n\t} else\n\t\tport_dev->ignore_event = 0;\n\n\treturn port_dev->ignore_event;\n}\n\n \nint usb_port_is_power_on(struct usb_hub *hub, unsigned int portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb_lock_port(struct usb_port *port_dev)\n\t\t__acquires(&port_dev->status_lock)\n{\n\tmutex_lock(&port_dev->status_lock);\n\t__acquire(&port_dev->status_lock);\n}\n\nstatic void usb_unlock_port(struct usb_port *port_dev)\n\t\t__releases(&port_dev->status_lock)\n{\n\tmutex_unlock(&port_dev->status_lock);\n\t__release(&port_dev->status_lock);\n}\n\n#ifdef\tCONFIG_PM\n\n \nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE)\n\t\t\t\t== USB_SS_PORT_LS_U3)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_SUSPEND)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t \n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t ;\n\t}\n\t \n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!usb_port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = usb_hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t \n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t \n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\n\t\t \n\t\tclear_bit(port1, hub->change_bits);\n\t}\n\n\treturn status;\n}\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t \n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn 0;\n\n\t \n\tif (!udev->actconfig)\n\t\treturn 0;\n\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t \n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn;\n\n\t \n\tif (!udev->actconfig)\n\t\treturn;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\n \nstatic int usb_enable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND_RW |\n\t\t\t\t\tUSB_INTRF_FUNC_SUSPEND_LP,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n \nstatic int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n \nunsigned usb_wakeup_enabled_descendants(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\n\treturn udev->do_remote_wakeup +\n\t\t\t(hub ? hub->wakeup_enabled_descendants : 0);\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_enabled_descendants);\n\n \nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tbool\t\treally_suspend = true;\n\n\tusb_lock_port(port_dev);\n\n\t \n\tif (udev->do_remote_wakeup) {\n\t\tstatus = usb_enable_remote_wakeup(udev);\n\t\tif (status) {\n\t\t\tdev_dbg(&udev->dev, \"won't remote wakeup, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t \n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\tgoto err_wakeup;\n\t\t}\n\t}\n\n\t \n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tif (usb_disable_ltm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LTM before suspend\\n\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_ltm;\n\t}\n\n\t \n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);\n\n\t \n\telse if (PMSG_IS_AUTO(msg) || usb_wakeup_enabled_descendants(udev) > 0)\n\t\tstatus = set_port_feature(hub->hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_SUSPEND);\n\telse {\n\t\treally_suspend = false;\n\t\tstatus = 0;\n\t}\n\tif (status) {\n\t\t \n\t\tif (status == -ETIMEDOUT) {\n\t\t\tint ret;\n\t\t\tu16 portstatus, portchange;\n\n\t\t\tportstatus = portchange = 0;\n\t\t\tret = usb_hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t&portchange);\n\n\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"suspend timeout, status %04x\\n\", portstatus);\n\n\t\t\tif (ret == 0 && port_is_suspended(hub, portstatus)) {\n\t\t\t\tstatus = 0;\n\t\t\t\tgoto suspend_done;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev, \"can't suspend, status %d\\n\", status);\n\n\t\t \n\t\tusb_enable_ltm(udev);\n err_ltm:\n\t\t \n\t\tusb_enable_usb2_hardware_lpm(udev);\n\n\t\tif (udev->do_remote_wakeup)\n\t\t\t(void) usb_disable_remote_wakeup(udev);\n err_wakeup:\n\n\t\t \n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\t} else {\n suspend_done:\n\t\tdev_dbg(&udev->dev, \"usb %ssuspend, wakeup %d\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\t\tudev->do_remote_wakeup);\n\t\tif (really_suspend) {\n\t\t\tudev->port_is_suspended = 1;\n\n\t\t\t \n\t\t\tmsleep(10);\n\t\t}\n\t\tusb_set_device_state(udev, USB_STATE_SUSPENDED);\n\t}\n\n\tif (status == 0 && !udev->do_remote_wakeup && udev->persist_enabled\n\t\t\t&& test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put_sync(&port_dev->dev);\n\n\tusb_mark_last_busy(hub->hdev);\n\n\tusb_unlock_port(port_dev);\n\treturn status;\n}\n\n \nstatic int finish_port_resume(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t \n\tdev_dbg(&udev->dev, \"%s\\n\",\n\t\tudev->reset_resume ? \"finish reset-resume\" : \"finish resume\");\n\n\t \n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t \n\tif (udev->reset_resume) {\n\t\t \n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t \n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t \n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, \"retry with reset-resume\\n\");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, \"gone after usb resume? status %d\\n\",\n\t\t\t\tstatus);\n\t \n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t} else {\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_INTERFACE, 0,\n\t\t\t\t\t&devstatus);\n\t\t\tif (!status && devstatus & (USB_INTRF_STAT_FUNC_RW_CAP\n\t\t\t\t\t| USB_INTRF_STAT_FUNC_RW))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t}\n\n\t\tif (status)\n\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\"disable remote wakeup, status %d\\n\",\n\t\t\t\tstatus);\n\t\tstatus = 0;\n\t}\n\treturn status;\n}\n\n \nstatic int wait_for_connected(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tu16 *portchange, u16 *portstatus)\n{\n\tint status = 0, delay_ms = 0;\n\n\twhile (delay_ms < 2000) {\n\t\tif (status || *portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\tbreak;\n\t\tif (!usb_port_is_power_on(hub, *portstatus)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\tmsleep(20);\n\t\tdelay_ms += 20;\n\t\tstatus = usb_hub_port_status(hub, port1, portstatus, portchange);\n\t}\n\tdev_dbg(&udev->dev, \"Waited %dms for CONNECT\\n\", delay_ms);\n\treturn status;\n}\n\n \nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum  - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tu16\t\tportchange, portstatus;\n\n\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\tstatus = pm_runtime_resume_and_get(&port_dev->dev);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&udev->dev, \"can't resume usb port, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\n\t \n\tstatus = usb_hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (status == 0 && !port_is_suspended(hub, portstatus)) {\n\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\tgoto SuspendCleared;\n\t}\n\n\t \n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U0);\n\telse\n\t\tstatus = usb_clear_port_feature(hub->hdev,\n\t\t\t\tport1, USB_PORT_FEAT_SUSPEND);\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't resume, status %d\\n\", status);\n\t} else {\n\t\t \n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t \n\t\tstatus = usb_hub_port_status(hub, port1, &portstatus, &portchange);\n\t}\n\n SuspendCleared:\n\tif (status == 0) {\n\t\tudev->port_is_suspended = 0;\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t} else {\n\t\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_C_SUSPEND);\n\t\t}\n\n\t\t \n\t\tmsleep(10);\n\t}\n\n\tif (udev->persist_enabled)\n\t\tstatus = wait_for_connected(udev, hub, port1, &portchange,\n\t\t\t\t&portstatus);\n\n\tstatus = check_port_resume_type(udev,\n\t\t\thub, port1, status, portchange, portstatus);\n\tif (status == 0)\n\t\tstatus = finish_port_resume(udev);\n\tif (status < 0) {\n\t\tdev_dbg(&udev->dev, \"can't resume, status %d\\n\", status);\n\t\thub_port_logical_disconnect(hub, port1);\n\t} else  {\n\t\t \n\t\tusb_enable_usb2_hardware_lpm(udev);\n\n\t\t \n\t\tusb_enable_ltm(udev);\n\t}\n\n\tusb_unlock_port(port_dev);\n\n\treturn status;\n}\n\nint usb_remote_wakeup(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\", \"wakeup-\");\n\t\tstatus = usb_autoresume_device(udev);\n\t\tif (status == 0) {\n\t\t\t \n\t\t\tusb_autosuspend_device(udev);\n\t\t}\n\t}\n\tusb_unlock_device(udev);\n\treturn status;\n}\n\n \nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port - 1];\n\tstruct usb_device *hdev;\n\tstruct usb_device *udev;\n\tint connect_change = 0;\n\tu16 link_state;\n\tint ret;\n\n\thdev = hub->hdev;\n\tudev = port_dev->child;\n\tif (!hub_is_superspeed(hdev)) {\n\t\tif (!(portchange & USB_PORT_STAT_C_SUSPEND))\n\t\t\treturn 0;\n\t\tusb_clear_port_feature(hdev, port, USB_PORT_FEAT_C_SUSPEND);\n\t} else {\n\t\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\t\tif (!udev || udev->state != USB_STATE_SUSPENDED ||\n\t\t\t\t(link_state != USB_SS_PORT_LS_U0 &&\n\t\t\t\t link_state != USB_SS_PORT_LS_U1 &&\n\t\t\t\t link_state != USB_SS_PORT_LS_U2))\n\t\t\treturn 0;\n\t}\n\n\tif (udev) {\n\t\t \n\t\tmsleep(10);\n\n\t\tusb_unlock_port(port_dev);\n\t\tret = usb_remote_wakeup(udev);\n\t\tusb_lock_port(port_dev);\n\t\tif (ret < 0)\n\t\t\tconnect_change = 1;\n\t} else {\n\t\tret = -ENODEV;\n\t\thub_port_disable(hub, port, 1);\n\t}\n\tdev_dbg(&port_dev->dev, \"resume, status %d\\n\", ret);\n\treturn connect_change;\n}\n\nstatic int check_ports_changed(struct usb_hub *hub)\n{\n\tint port1;\n\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; ++port1) {\n\t\tu16 portstatus, portchange;\n\t\tint status;\n\n\t\tstatus = usb_hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (!status && portchange)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_hub\t\t*hub = usb_get_intfdata(intf);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\tport1;\n\n\t \n\thub->wakeup_enabled_descendants = 0;\n\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\n\t\tif (udev && udev->can_submit) {\n\t\t\tdev_warn(&port_dev->dev, \"device %s not suspended yet\\n\",\n\t\t\t\t\tdev_name(&udev->dev));\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (udev)\n\t\t\thub->wakeup_enabled_descendants +=\n\t\t\t\t\tusb_wakeup_enabled_descendants(udev);\n\t}\n\n\tif (hdev->do_remote_wakeup && hub->quirk_check_port_auto_suspend) {\n\t\t \n\t\tif (check_ports_changed(hub)) {\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t\tpm_wakeup_event(&hdev->dev, 2000);\n\t\t}\n\t}\n\n\tif (hub_is_superspeed(hdev) && hdev->do_remote_wakeup) {\n\t\t \n\t\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\t\tset_port_feature(hdev,\n\t\t\t\t\t port1 |\n\t\t\t\t\t USB_PORT_FEAT_REMOTE_WAKE_CONNECT |\n\t\t\t\t\t USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT |\n\t\t\t\t\t USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT,\n\t\t\t\t\t USB_PORT_FEAT_REMOTE_WAKE_MASK);\n\t\t}\n\t}\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t \n\thub_quiesce(hub, HUB_SUSPEND);\n\treturn 0;\n}\n\n \nstatic void report_wakeup_requests(struct usb_hub *hub)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_device\t*udev;\n\tstruct usb_hcd\t\t*hcd;\n\tunsigned long\t\tresuming_ports;\n\tint\t\t\ti;\n\n\tif (hdev->parent)\n\t\treturn;\t\t \n\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hcd->driver->get_resuming_ports) {\n\n\t\t \n\t\tresuming_ports = hcd->driver->get_resuming_ports(hcd);\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (test_bit(i, &resuming_ports)) {\n\t\t\t\tudev = hub->ports[i]->child;\n\t\t\t\tif (udev)\n\t\t\t\t\tpm_wakeup_event(&udev->dev, 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\n\t \n\treport_wakeup_requests(hub);\n\treturn 0;\n}\n\nstatic int hub_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESET_RESUME);\n\treturn 0;\n}\n\n \nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\n{\n\tdev_notice(&rhdev->dev, \"root hub lost power or was reset\\n\");\n\trhdev->reset_resume = 1;\n}\nEXPORT_SYMBOL_GPL(usb_root_hub_lost_power);\n\nstatic const char * const usb3_lpm_names[]  = {\n\t\"U0\",\n\t\"U1\",\n\t\"U2\",\n\t\"U3\",\n};\n\n \nstatic int usb_req_set_sel(struct usb_device *udev)\n{\n\tstruct usb_set_sel_req *sel_values;\n\tunsigned long long u1_sel;\n\tunsigned long long u1_pel;\n\tunsigned long long u2_sel;\n\tunsigned long long u2_pel;\n\tint ret;\n\n\tif (!udev->parent || udev->speed < USB_SPEED_SUPER || !udev->lpm_capable)\n\t\treturn 0;\n\n\t \n\tu1_sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\tu1_pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);\n\tu2_sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\tu2_pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);\n\n\t \n\tif (u1_sel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t    u1_pel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t    u2_sel > USB3_LPM_MAX_U2_SEL_PEL ||\n\t    u2_pel > USB3_LPM_MAX_U2_SEL_PEL) {\n\t\tdev_dbg(&udev->dev, \"Device-initiated U1/U2 disabled due to long SEL or PEL\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tsel_values = kmalloc(sizeof *(sel_values), GFP_NOIO);\n\tif (!sel_values)\n\t\treturn -ENOMEM;\n\n\tsel_values->u1_sel = u1_sel;\n\tsel_values->u1_pel = u1_pel;\n\tsel_values->u2_sel = cpu_to_le16(u2_sel);\n\tsel_values->u2_pel = cpu_to_le16(u2_pel);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_SEL,\n\t\t\tUSB_RECIP_DEVICE,\n\t\t\t0, 0,\n\t\t\tsel_values, sizeof *(sel_values),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(sel_values);\n\n\tif (ret > 0)\n\t\tudev->lpm_devinit_allow = 1;\n\n\treturn ret;\n}\n\n \nstatic int usb_set_device_initiated_lpm(struct usb_device *udev,\n\t\tenum usb3_link_state state, bool enable)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_DEVICE_U1_ENABLE;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_DEVICE_U2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't %s non-U1 or U2 state.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udev->state != USB_STATE_CONFIGURED) {\n\t\tdev_dbg(&udev->dev, \"%s: Can't %s %s state \"\n\t\t\t\t\"for unconfigured device.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\t \n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t} else {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"%s of device-initiated %s failed.\\n\",\n\t\t\t\tenable ? \"Enable\" : \"Disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}\n\n \nstatic bool usb_device_may_initiate_lpm(struct usb_device *udev,\n\t\t\t\t\tenum usb3_link_state state)\n{\n\tunsigned int sel;\t\t \n\tint i, j;\n\n\tif (!udev->lpm_devinit_allow)\n\t\treturn false;\n\n\tif (state == USB3_LPM_U1)\n\t\tsel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\telse if (state == USB3_LPM_U2)\n\t\tsel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\telse\n\t\treturn false;\n\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_endpoint_descriptor *desc;\n\t\tunsigned int interval;\n\n\t\tintf = udev->actconfig->interface[i];\n\t\tif (!intf)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++) {\n\t\t\tdesc = &intf->cur_altsetting->endpoint[j].desc;\n\n\t\t\tif (usb_endpoint_xfer_int(desc) ||\n\t\t\t    usb_endpoint_xfer_isoc(desc)) {\n\t\t\t\tinterval = (1 << (desc->bInterval - 1)) * 125;\n\t\t\t\tif (sel + 125 > interval)\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n \nstatic void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tint timeout;\n\t__u8 u1_mel;\n\t__le16 u2_mel;\n\n\t \n\tif (!udev->bos)\n\t\treturn;\n\n\tu1_mel = udev->bos->ss_cap->bU1devExitLat;\n\tu2_mel = udev->bos->ss_cap->bU2DevExitLat;\n\n\t \n\tif ((state == USB3_LPM_U1 && u1_mel == 0) ||\n\t\t\t(state == USB3_LPM_U2 && u2_mel == 0))\n\t\treturn;\n\n\t \n\ttimeout = hcd->driver->enable_usb3_lpm_timeout(hcd, udev, state);\n\n\t \n\tif (timeout == 0)\n\t\treturn;\n\n\tif (timeout < 0) {\n\t\tdev_warn(&udev->dev, \"Could not enable %s link state, \"\n\t\t\t\t\"xHCI error %i.\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout);\n\t\treturn;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, timeout)) {\n\t\t \n\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\t\treturn;\n\t}\n\n\t \n\tif (udev->actconfig &&\n\t    usb_device_may_initiate_lpm(udev, state)) {\n\t\tif (usb_set_device_initiated_lpm(udev, state, true)) {\n\t\t\t \n\t\t\tusb_set_lpm_timeout(udev, state, 0);\n\t\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (state == USB3_LPM_U1)\n\t\tudev->usb3_lpm_u1_enabled = 1;\n\telse if (state == USB3_LPM_U2)\n\t\tudev->usb3_lpm_u2_enabled = 1;\n}\n \nstatic int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\tcase USB3_LPM_U2:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't disable non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, 0))\n\t\treturn -EBUSY;\n\n\tusb_set_device_initiated_lpm(udev, state, false);\n\n\tif (hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state))\n\t\tdev_warn(&udev->dev, \"Could not disable xHCI %s timeout, \"\n\t\t\t\t\"bus schedule bandwidth may be impacted.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\n\t \n\tif (state == USB3_LPM_U1)\n\t\tudev->usb3_lpm_u1_enabled = 0;\n\telse if (state == USB3_LPM_U2)\n\t\tudev->usb3_lpm_u2_enabled = 0;\n\n\treturn 0;\n}\n\n \nint usb_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_CONFIGURED)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd || !hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn 0;\n\n\tudev->lpm_disable_count++;\n\tif ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0))\n\t\treturn 0;\n\n\t \n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U1))\n\t\tgoto enable_lpm;\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U2))\n\t\tgoto enable_lpm;\n\n\treturn 0;\n\nenable_lpm:\n\tusb_enable_lpm(udev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\n \nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret;\n\n\tif (!hcd)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_disable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\n \nvoid usb_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_hub *hub;\n\tstruct usb_port *port_dev;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed < USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_CONFIGURED)\n\t\treturn;\n\n\tudev->lpm_disable_count--;\n\thcd = bus_to_hcd(udev->bus);\n\t \n\tif (!hcd || !hcd->driver->enable_usb3_lpm_timeout ||\n\t\t\t!hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn;\n\n\tif (udev->lpm_disable_count > 0)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tif (!hub)\n\t\treturn;\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\tif (port_dev->usb3_lpm_u1_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U1);\n\n\tif (port_dev->usb3_lpm_u2_permit)\n\t\tusb_enable_link_state(hcd, udev, USB3_LPM_U2);\n}\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\n \nvoid usb_unlocked_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd)\n\t\treturn;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tusb_enable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\n \nstatic void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t  struct usb_port *port_dev)\n{\n\tstruct usb_device *udev = port_dev->child;\n\tint ret;\n\n\tif (udev && udev->port_is_suspended && udev->do_remote_wakeup) {\n\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t      USB_SS_PORT_LS_U0);\n\t\tif (!ret) {\n\t\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\t\tret = usb_disable_remote_wakeup(udev);\n\t\t}\n\t\tif (ret)\n\t\t\tdev_warn(&udev->dev,\n\t\t\t\t \"Port disable: can't disable remote wake\\n\");\n\t\tudev->do_remote_wakeup = 0;\n\t}\n}\n\n#else\t \n\n#define hub_suspend\t\tNULL\n#define hub_resume\t\tNULL\n#define hub_reset_resume\tNULL\n\nstatic inline void hub_usb3_port_prepare_disable(struct usb_hub *hub,\n\t\t\t\t\t\t struct usb_port *port_dev) { }\n\nint usb_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\nvoid usb_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\nvoid usb_unlocked_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n\nstatic int usb_req_set_sel(struct usb_device *udev)\n{\n\treturn 0;\n}\n\n#endif\t \n\n \nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *hdev = hub->hdev;\n\tint ret = 0;\n\n\tif (!hub->error) {\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\thub_usb3_port_prepare_disable(hub, port_dev);\n\t\t\tret = hub_set_port_link_state(hub, port_dev->portnum,\n\t\t\t\t\t\t      USB_SS_PORT_LS_U3);\n\t\t} else {\n\t\t\tret = usb_clear_port_feature(hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_ENABLE);\n\t\t}\n\t}\n\tif (port_dev->child && set_state)\n\t\tusb_set_device_state(port_dev->child, USB_STATE_NOTATTACHED);\n\tif (ret && ret != -ENODEV)\n\t\tdev_err(&port_dev->dev, \"cannot disable (err = %d)\\n\", ret);\n\treturn ret;\n}\n\n \nint usb_port_disable(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\treturn hub_port_disable(hub, udev->portnum, 0);\n}\n\n \nint hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)\n{\n\tint ret;\n\tu16 portchange, portstatus;\n\tunsigned connection = 0xffff;\n\tint total_time, stable_time = 0;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = usb_hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\n\t\t     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {\n\t\t\tif (!must_be_connected ||\n\t\t\t     (connection == USB_PORT_STAT_CONNECTION))\n\t\t\t\tstable_time += HUB_DEBOUNCE_STEP;\n\t\t\tif (stable_time >= HUB_DEBOUNCE_STABLE)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstable_time = 0;\n\t\t\tconnection = portstatus & USB_PORT_STAT_CONNECTION;\n\t\t}\n\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\n\tdev_dbg(&port_dev->dev, \"debounce total %dms stable %dms status 0x%x\\n\",\n\t\t\ttotal_time, stable_time, portstatus);\n\n\tif (stable_time < HUB_DEBOUNCE_STABLE)\n\t\treturn -ETIMEDOUT;\n\treturn portstatus;\n}\n\nvoid usb_ep0_reinit(struct usb_device *udev)\n{\n\tusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\n\tusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\n\tusb_enable_endpoint(udev, &udev->ep0, true);\n}\nEXPORT_SYMBOL_GPL(usb_ep0_reinit);\n\n#define usb_sndaddr0pipe()\t(PIPE_CONTROL << 30)\n#define usb_rcvaddr0pipe()\t((PIPE_CONTROL << 30) | USB_DIR_IN)\n\nstatic int hub_set_address(struct usb_device *udev, int devnum)\n{\n\tint retval;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t \n\tif (!hcd->driver->address_device && devnum <= 1)\n\t\treturn -EINVAL;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\tif (hcd->driver->address_device)\n\t\tretval = hcd->driver->address_device(hcd, udev);\n\telse\n\t\tretval = usb_control_msg(udev, usb_sndaddr0pipe(),\n\t\t\t\tUSB_REQ_SET_ADDRESS, 0, devnum, 0,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval == 0) {\n\t\tupdate_devnum(udev, devnum);\n\t\t \n\t\tusb_set_device_state(udev, USB_STATE_ADDRESS);\n\t\tusb_ep0_reinit(udev);\n\t}\n\treturn retval;\n}\n\n \nstatic void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\tint connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\n\tif (!udev->usb2_hw_lpm_capable || !udev->bos)\n\t\treturn;\n\n\tif (hub)\n\t\tconnect_type = hub->ports[udev->portnum - 1]->connect_type;\n\n\tif ((udev->bos->ext_cap->bmAttributes & cpu_to_le32(USB_BESL_SUPPORT)) ||\n\t\t\tconnect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\tudev->usb2_hw_lpm_allowed = 1;\n\t\tusb_enable_usb2_hardware_lpm(udev);\n\t}\n}\n\nstatic int hub_enable_device(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd->driver->enable_device)\n\t\treturn 0;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\treturn hcd->driver->enable_device(hcd, udev);\n}\n\n \nstatic int get_bMaxPacketSize0(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *buf, int size, bool first_time)\n{\n\tint i, rc;\n\n\t \n\tfor (i = 0; i < GET_MAXPACKET0_TRIES; ++i) {\n\t\t \n\t\tbuf->bDescriptorType = buf->bMaxPacketSize0 = 0;\n\t\trc = usb_control_msg(udev, usb_rcvaddr0pipe(),\n\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\tUSB_DT_DEVICE << 8, 0,\n\t\t\t\tbuf, size,\n\t\t\t\tinitial_descriptor_timeout);\n\t\tswitch (buf->bMaxPacketSize0) {\n\t\tcase 8: case 16: case 32: case 64: case 9:\n\t\t\tif (buf->bDescriptorType == USB_DT_DEVICE) {\n\t\t\t\trc = buf->bMaxPacketSize0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif (rc >= 0)\n\t\t\t\trc = -EPROTO;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (rc > 0 || (rc == -ETIMEDOUT && first_time &&\n\t\t\t\tudev->speed > USB_SPEED_FULL))\n\t\t\tbreak;\n\t}\n\treturn rc;\n}\n\n#define GET_DESCRIPTOR_BUFSIZE\t64\n\n \nstatic int\nhub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,\n\t\tint retry_counter, struct usb_device_descriptor *dev_descr)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port\t\t*port_dev = hub->ports[port1 - 1];\n\tint\t\t\tretries, operations, retval, i;\n\tunsigned\t\tdelay = HUB_SHORT_RESET_TIME;\n\tenum usb_device_speed\toldspeed = udev->speed;\n\tconst char\t\t*speed;\n\tint\t\t\tdevnum = udev->devnum;\n\tconst char\t\t*driver_name;\n\tbool\t\t\tdo_new_scheme;\n\tconst bool\t\tinitial = !dev_descr;\n\tint\t\t\tmaxp0;\n\tstruct usb_device_descriptor\t*buf, *descr;\n\n\tbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tif (!hdev->parent) {\n\t\tdelay = HUB_ROOT_RESET_TIME;\n\t\tif (port1 == hdev->bus->otg_port)\n\t\t\thdev->bus->b_hnp_enable = 0;\n\t}\n\n\t \n\t \n\tif (oldspeed == USB_SPEED_LOW)\n\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t \n\t \n\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\tif (retval < 0)\t\t \n\t\tgoto fail;\n\t \n\n\tretval = -ENODEV;\n\n\t \n\tif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed &&\n\t    !(oldspeed == USB_SPEED_SUPER && udev->speed > oldspeed)) {\n\t\tdev_dbg(&udev->dev, \"device reset changed speed!\\n\");\n\t\tgoto fail;\n\t}\n\toldspeed = udev->speed;\n\n\tif (initial) {\n\t\t \n\t\tswitch (udev->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\t\t\tbreak;\n\t\tcase USB_SPEED_HIGH:\t\t \n\t\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\t\tbreak;\n\t\tcase USB_SPEED_FULL:\t\t \n\t\t\t \n\t\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\t\tbreak;\n\t\tcase USB_SPEED_LOW:\t\t \n\t\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tspeed = usb_speed_string(udev->speed);\n\n\t \n\tif (udev->bus->controller->driver)\n\t\tdriver_name = udev->bus->controller->driver->name;\n\telse\n\t\tdriver_name = udev->bus->sysdev->driver->name;\n\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\tdev_info(&udev->dev,\n\t\t\t\t\"%s %s USB device number %d using %s\\n\",\n\t\t\t\t(initial ? \"new\" : \"reset\"), speed,\n\t\t\t\tdevnum, driver_name);\n\n\tif (initial) {\n\t\t \n\t\tif (hdev->tt) {\n\t\t\tudev->tt = hdev->tt;\n\t\t\tudev->ttport = hdev->ttport;\n\t\t} else if (udev->speed != USB_SPEED_HIGH\n\t\t\t\t&& hdev->speed == USB_SPEED_HIGH) {\n\t\t\tif (!hub->tt.hub) {\n\t\t\t\tdev_err(&udev->dev, \"parent hub has no TT\\n\");\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tudev->tt = &hub->tt;\n\t\t\tudev->ttport = port1;\n\t\t}\n\t}\n\n\t \n\tdo_new_scheme = use_new_scheme(udev, retry_counter, port_dev);\n\n\tfor (retries = 0; retries < GET_DESCRIPTOR_TRIES; (++retries, msleep(100))) {\n\t\tif (hub_port_stop_enumerate(hub, port1, retries)) {\n\t\t\tretval = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (do_new_scheme) {\n\t\t\tretval = hub_enable_device(udev);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"hub failed to enable device, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tmaxp0 = get_bMaxPacketSize0(udev, buf,\n\t\t\t\t\tGET_DESCRIPTOR_BUFSIZE, retries == 0);\n\t\t\tif (maxp0 > 0 && !initial &&\n\t\t\t\t\tmaxp0 != udev->descriptor.bMaxPacketSize0) {\n\t\t\t\tdev_err(&udev->dev, \"device reset changed ep0 maxpacket size!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\t\t\tif (retval < 0)\t\t \n\t\t\t\tgoto fail;\n\t\t\tif (oldspeed != udev->speed) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"device reset changed speed!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (maxp0 < 0) {\n\t\t\t\tif (maxp0 != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device descriptor read/64, error %d\\n\",\n\t\t\t\t\t\t\tmaxp0);\n\t\t\t\tretval = maxp0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfor (operations = 0; operations < SET_ADDRESS_TRIES; ++operations) {\n\t\t\tretval = hub_set_address(udev, devnum);\n\t\t\tif (retval >= 0)\n\t\t\t\tbreak;\n\t\t\tmsleep(200);\n\t\t}\n\t\tif (retval < 0) {\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"device not accepting address %d, error %d\\n\",\n\t\t\t\t\t\tdevnum, retval);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (udev->speed >= USB_SPEED_SUPER) {\n\t\t\tdevnum = udev->devnum;\n\t\t\tdev_info(&udev->dev,\n\t\t\t\t\t\"%s SuperSpeed%s%s USB device number %d using %s\\n\",\n\t\t\t\t\t(udev->config) ? \"reset\" : \"new\",\n\t\t\t\t (udev->speed == USB_SPEED_SUPER_PLUS) ?\n\t\t\t\t\t\t\" Plus\" : \"\",\n\t\t\t\t (udev->ssp_rate == USB_SSP_GEN_2x2) ?\n\t\t\t\t\t\t\" Gen 2x2\" :\n\t\t\t\t (udev->ssp_rate == USB_SSP_GEN_2x1) ?\n\t\t\t\t\t\t\" Gen 2x1\" :\n\t\t\t\t (udev->ssp_rate == USB_SSP_GEN_1x2) ?\n\t\t\t\t\t\t\" Gen 1x2\" : \"\",\n\t\t\t\t devnum, driver_name);\n\t\t}\n\n\t\t \n\t\tmsleep(10);\n\n\t\tif (do_new_scheme)\n\t\t\tbreak;\n\n\t\tmaxp0 = get_bMaxPacketSize0(udev, buf, 8, retries == 0);\n\t\tif (maxp0 < 0) {\n\t\t\tretval = maxp0;\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"device descriptor read/8, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t} else {\n\t\t\tu32 delay;\n\n\t\t\tif (!initial && maxp0 != udev->descriptor.bMaxPacketSize0) {\n\t\t\t\tdev_err(&udev->dev, \"device reset changed ep0 maxpacket size!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tdelay = udev->parent->hub_delay;\n\t\t\tudev->hub_delay = min_t(u32, delay,\n\t\t\t\t\t\tUSB_TP_TRANSMISSION_DELAY_MAX);\n\t\t\tretval = usb_set_isoch_delay(udev);\n\t\t\tif (retval) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"Failed set isoch delay, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tretval = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto fail;\n\n\t \n\ti = maxp0;\n\tif (udev->speed >= USB_SPEED_SUPER) {\n\t\tif (maxp0 <= 16)\n\t\t\ti = 1 << maxp0;\n\t\telse\n\t\t\ti = 0;\t\t \n\t}\n\tif (usb_endpoint_maxp(&udev->ep0.desc) == i) {\n\t\t;\t \n\t} else if ((udev->speed == USB_SPEED_FULL ||\n\t\t\t\tudev->speed == USB_SPEED_HIGH) &&\n\t\t\t(i == 8 || i == 16 || i == 32 || i == 64)) {\n\t\t \n\t\tif (udev->speed == USB_SPEED_FULL)\n\t\t\tdev_dbg(&udev->dev, \"ep0 maxpacket = %d\\n\", i);\n\t\telse\n\t\t\tdev_warn(&udev->dev, \"Using ep0 maxpacket: %d\\n\", i);\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\n\t\tusb_ep0_reinit(udev);\n\t} else {\n\t\t \n\t\tdev_err(&udev->dev, \"Invalid ep0 maxpacket: %d\\n\", maxp0);\n\t\tretval = -EMSGSIZE;\n\t\tgoto fail;\n\t}\n\n\tdescr = usb_get_device_descriptor(udev);\n\tif (IS_ERR(descr)) {\n\t\tretval = PTR_ERR(descr);\n\t\tif (retval != -ENODEV)\n\t\t\tdev_err(&udev->dev, \"device descriptor read/all, error %d\\n\",\n\t\t\t\t\tretval);\n\t\tgoto fail;\n\t}\n\tif (initial)\n\t\tudev->descriptor = *descr;\n\telse\n\t\t*dev_descr = *descr;\n\tkfree(descr);\n\n\t \n\tif ((udev->speed >= USB_SPEED_SUPER) &&\n\t\t\t(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {\n\t\tdev_err(&udev->dev, \"got a wrong device descriptor, warm reset device\\n\");\n\t\thub_port_reset(hub, port1, udev, HUB_BH_RESET_TIME, true);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tusb_detect_quirks(udev);\n\n\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(udev);\n\t\tif (!retval) {\n\t\t\tudev->lpm_capable = usb_device_supports_lpm(udev);\n\t\t\tudev->lpm_disable_count = 1;\n\t\t\tusb_set_lpm_parameters(udev);\n\t\t\tusb_req_set_sel(udev);\n\t\t}\n\t}\n\n\tretval = 0;\n\t \n\tif (hcd->driver->update_device)\n\t\thcd->driver->update_device(hcd, udev);\n\thub_set_initial_usb2_lpm_policy(udev);\nfail:\n\tif (retval) {\n\t\thub_port_disable(hub, port1, 0);\n\t\tupdate_devnum(udev, devnum);\t \n\t}\n\tkfree(buf);\n\treturn retval;\n}\n\nstatic void\ncheck_highspeed(struct usb_hub *hub, struct usb_device *udev, int port1)\n{\n\tstruct usb_qualifier_descriptor\t*qual;\n\tint\t\t\t\tstatus;\n\n\tif (udev->quirks & USB_QUIRK_DEVICE_QUALIFIER)\n\t\treturn;\n\n\tqual = kmalloc(sizeof *qual, GFP_KERNEL);\n\tif (qual == NULL)\n\t\treturn;\n\n\tstatus = usb_get_descriptor(udev, USB_DT_DEVICE_QUALIFIER, 0,\n\t\t\tqual, sizeof *qual);\n\tif (status == sizeof *qual) {\n\t\tdev_info(&udev->dev, \"not running at top speed; \"\n\t\t\t\"connect to a high speed hub\\n\");\n\t\t \n\t\tif (hub->has_indicators) {\n\t\t\thub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->leds, 0);\n\t\t}\n\t}\n\tkfree(qual);\n}\n\nstatic unsigned\nhub_power_remaining(struct usb_hub *hub)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint remaining;\n\tint port1;\n\n\tif (!hub->limited_power)\n\t\treturn 0;\n\n\tremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tunsigned unit_load;\n\t\tint delta;\n\n\t\tif (!udev)\n\t\t\tcontinue;\n\t\tif (hub_is_superspeed(udev))\n\t\t\tunit_load = 150;\n\t\telse\n\t\t\tunit_load = 100;\n\n\t\t \n\t\tif (udev->actconfig)\n\t\t\tdelta = usb_get_max_power(udev, udev->actconfig);\n\t\telse if (port1 != udev->bus->otg_port || hdev->parent)\n\t\t\tdelta = unit_load;\n\t\telse\n\t\t\tdelta = 8;\n\t\tif (delta > hub->mA_per_port)\n\t\t\tdev_warn(&port_dev->dev, \"%dmA is over %umA budget!\\n\",\n\t\t\t\t\tdelta, hub->mA_per_port);\n\t\tremaining -= delta;\n\t}\n\tif (remaining < 0) {\n\t\tdev_warn(hub->intfdev, \"%dmA over power budget!\\n\",\n\t\t\t-remaining);\n\t\tremaining = 0;\n\t}\n\treturn remaining;\n}\n\n\nstatic int descriptors_changed(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *new_device_descriptor,\n\t\tstruct usb_host_bos *old_bos)\n{\n\tint\t\tchanged = 0;\n\tunsigned\tindex;\n\tunsigned\tserial_len = 0;\n\tunsigned\tlen;\n\tunsigned\told_length;\n\tint\t\tlength;\n\tchar\t\t*buf;\n\n\tif (memcmp(&udev->descriptor, new_device_descriptor,\n\t\t\tsizeof(*new_device_descriptor)) != 0)\n\t\treturn 1;\n\n\tif ((old_bos && !udev->bos) || (!old_bos && udev->bos))\n\t\treturn 1;\n\tif (udev->bos) {\n\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\tif (len != le16_to_cpu(old_bos->desc->wTotalLength))\n\t\t\treturn 1;\n\t\tif (memcmp(udev->bos->desc, old_bos->desc, len))\n\t\t\treturn 1;\n\t}\n\n\t \n\tif (udev->serial)\n\t\tserial_len = strlen(udev->serial) + 1;\n\n\tlen = serial_len;\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlen = max(len, old_length);\n\t}\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (!buf)\n\t\t \n\t\treturn 1;\n\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\n\t\t\t\told_length);\n\t\tif (length != old_length) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d, error %d\\n\",\n\t\t\t\t\tindex, length);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(buf, udev->rawdescriptors[index], old_length)\n\t\t\t\t!= 0) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d changed (#%d)\\n\",\n\t\t\t\tindex,\n\t\t\t\t((struct usb_config_descriptor *) buf)->\n\t\t\t\t\tbConfigurationValue);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed && serial_len) {\n\t\tlength = usb_string(udev, udev->descriptor.iSerialNumber,\n\t\t\t\tbuf, serial_len);\n\t\tif (length + 1 != serial_len) {\n\t\t\tdev_dbg(&udev->dev, \"serial string error %d\\n\",\n\t\t\t\t\tlength);\n\t\t\tchanged = 1;\n\t\t} else if (memcmp(buf, udev->serial, length) != 0) {\n\t\t\tdev_dbg(&udev->dev, \"serial string changed\\n\");\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn changed;\n}\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status = -ENODEV;\n\tint i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\tbool retry_locked;\n\n\t \n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t \n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t \n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t \n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !usb_port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\n\tfor (i = 0; i < PORT_INIT_TRIES; i++) {\n\t\tif (hub_port_stop_enumerate(hub, port1, i)) {\n\t\t\tstatus = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\tusb_lock_port(port_dev);\n\t\tmutex_lock(hcd->address0_mutex);\n\t\tretry_locked = true;\n\t\t \n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\n\t\t \n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t \n\t\t\tgoto loop;\n\t\t}\n\n\t\t \n\t\tstatus = hub_port_init(hub, udev, port1, i, NULL);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tmutex_unlock(hcd->address0_mutex);\n\t\tusb_unlock_port(port_dev);\n\t\tretry_locked = false;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(2000);\n\n\t\t \n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t \n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t \n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t \n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t \n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tif (retry_locked) {\n\t\t\tmutex_unlock(hcd->address0_mutex);\n\t\t\tusb_unlock_port(port_dev);\n\t\t}\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\n\t\t \n\t\tif (i == (PORT_INIT_TRIES - 1) / 2) {\n\t\t\tdev_info(&port_dev->dev, \"attempt power cycle\\n\");\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, false);\n\t\t\tmsleep(2 * hub_power_on_good_delay(hub));\n\t\t\tusb_hub_set_port_power(hdev, hub, port1, true);\n\t\t\tmsleep(hub_power_on_good_delay(hub));\n\t\t}\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\thcd->driver->relinquish_port(hcd, port1);\n\t}\n}\n\n \nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\n\t\t\t\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device_descriptor *descr;\n\tint status = -ENODEV;\n\n\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,\n\t\t\tportchange, portspeed(hub, portstatus));\n\n\tif (hub->has_indicators) {\n\t\tset_port_led(hub, port1, HUB_LED_AUTO);\n\t\thub->indicator[port1-1] = INDICATOR_AUTO;\n\t}\n\n#ifdef\tCONFIG_USB_OTG\n\t \n\tif (hub->hdev->bus->is_b_host)\n\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE);\n#endif\n\n\t \n\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\n\t\t\tudev->state != USB_STATE_NOTATTACHED) {\n\t\tif (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\t \n\t\t\tdescr = usb_get_device_descriptor(udev);\n\t\t\tif (IS_ERR(descr)) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\t\"can't read device descriptor %ld\\n\",\n\t\t\t\t\t\tPTR_ERR(descr));\n\t\t\t} else {\n\t\t\t\tif (descriptors_changed(udev, descr,\n\t\t\t\t\t\tudev->bos)) {\n\t\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\t\t\"device descriptor has changed\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tstatus = 0;  \n\t\t\t\t}\n\t\t\t\tkfree(descr);\n\t\t\t}\n#ifdef CONFIG_PM\n\t\t} else if (udev->state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->persist_enabled) {\n\t\t\t \n\t\t\tusb_unlock_port(port_dev);\n\t\t\tstatus = usb_remote_wakeup(udev);\n\t\t\tusb_lock_port(port_dev);\n#endif\n\t\t} else {\n\t\t\t ;\n\t\t}\n\t}\n\tclear_bit(port1, hub->change_bits);\n\n\t \n\tif (status == 0)\n\t\treturn;\n\n\tusb_unlock_port(port_dev);\n\thub_port_connect(hub, port1, portstatus, portchange);\n\tusb_lock_port(port_dev);\n}\n\n \nstatic void port_over_current_notify(struct usb_port *port_dev)\n{\n\tchar *envp[3] = { NULL, NULL, NULL };\n\tstruct device *hub_dev;\n\tchar *port_dev_path;\n\n\tsysfs_notify(&port_dev->dev.kobj, NULL, \"over_current_count\");\n\n\thub_dev = port_dev->dev.parent;\n\n\tif (!hub_dev)\n\t\treturn;\n\n\tport_dev_path = kobject_get_path(&port_dev->dev.kobj, GFP_KERNEL);\n\tif (!port_dev_path)\n\t\treturn;\n\n\tenvp[0] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_PORT=%s\", port_dev_path);\n\tif (!envp[0])\n\t\tgoto exit;\n\n\tenvp[1] = kasprintf(GFP_KERNEL, \"OVER_CURRENT_COUNT=%u\",\n\t\t\tport_dev->over_current_count);\n\tif (!envp[1])\n\t\tgoto exit;\n\n\tkobject_uevent_env(&hub_dev->kobj, KOBJ_CHANGE, envp);\n\nexit:\n\tkfree(envp[1]);\n\tkfree(envp[0]);\n\tkfree(port_dev_path);\n}\n\nstatic void port_event(struct usb_hub *hub, int port1)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tint connect_change;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device *hdev = hub->hdev;\n\tu16 portstatus, portchange;\n\tint i = 0;\n\n\tconnect_change = test_bit(port1, hub->change_bits);\n\tclear_bit(port1, hub->event_bits);\n\tclear_bit(port1, hub->wakeup_bits);\n\n\tif (usb_hub_port_status(hub, port1, &portstatus, &portchange) < 0)\n\t\treturn;\n\n\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tconnect_change = 1;\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\tif (!connect_change)\n\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",\n\t\t\t\t\tportstatus);\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\n\t\t \n\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)\n\t\t    && !connect_change && udev) {\n\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");\n\t\t\tconnect_change = 1;\n\t\t}\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\n\t\tu16 status = 0, unused;\n\t\tport_dev->over_current_count++;\n\t\tport_over_current_notify(port_dev);\n\n\t\tdev_dbg(&port_dev->dev, \"over-current change #%u\\n\",\n\t\t\tport_dev->over_current_count);\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);\n\t\tmsleep(100);\t \n\t\thub_power_on(hub, true);\n\t\tusb_hub_port_status(hub, port1, &status, &unused);\n\t\tif (status & USB_PORT_STAT_OVERCURRENT)\n\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);\n\t}\n\tif ((portchange & USB_PORT_STAT_C_BH_RESET)\n\t    && hub_is_superspeed(hdev)) {\n\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t}\n\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {\n\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t}\n\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\n\t\tdev_warn(&port_dev->dev, \"config error\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\n\t}\n\n\t \n\tif (!pm_runtime_active(&port_dev->dev))\n\t\treturn;\n\n\t \n\tif (port_dev->ignore_event && port_dev->early_stop)\n\t\treturn;\n\n\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))\n\t\tconnect_change = 1;\n\n\t \n\twhile (hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\tif ((i++ < DETECT_DISCONNECT_TRIES) && udev) {\n\t\t\tu16 unused;\n\n\t\t\tmsleep(20);\n\t\t\tusb_hub_port_status(hub, port1, &portstatus, &unused);\n\t\t\tdev_dbg(&port_dev->dev, \"Wait for inactive link disconnect detect\\n\");\n\t\t\tcontinue;\n\t\t} else if (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {\n\t\t\tdev_dbg(&port_dev->dev, \"do warm reset, port only\\n\");\n\t\t\tif (hub_port_reset(hub, port1, NULL,\n\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)\n\t\t\t\thub_port_disable(hub, port1, 1);\n\t\t} else {\n\t\t\tdev_dbg(&port_dev->dev, \"do warm reset, full device\\n\");\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tusb_lock_device(udev);\n\t\t\tusb_reset_device(udev);\n\t\t\tusb_unlock_device(udev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tconnect_change = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (connect_change)\n\t\thub_port_connect_change(hub, port1, portstatus, portchange);\n}\n\nstatic void hub_event(struct work_struct *work)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tkcov_remote_start_usb((u64)hdev->bus->busnum);\n\n\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t \n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t \n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t \n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t \n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t \n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t \n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t \n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t \n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t \n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, \"power change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t \n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n\t\t\tu16 status = 0;\n\t\t\tu16 unused;\n\n\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\n\t\t\tmsleep(500);\t \n\t\t\thub_power_on(hub, true);\n\t\t\thub_hub_status(hub, &status, &unused);\n\t\t\tif (status & HUB_STATUS_OVERCURRENT)\n\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");\n\t\t}\n\t}\n\nout_autopm:\n\t \n\tusb_autopm_put_interface_no_suspend(intf);\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\n\t \n\tusb_autopm_put_interface(intf);\n\tkref_put(&hub->kref, hub_release);\n\n\tkcov_remote_stop();\n}\n\nstatic const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n                   | USB_DEVICE_ID_MATCH_PRODUCT\n                   | USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_SMSC,\n      .idProduct = USB_PRODUCT_USB5534B,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n                   | USB_DEVICE_ID_MATCH_PRODUCT,\n      .idVendor = USB_VENDOR_CYPRESS,\n      .idProduct = USB_PRODUCT_CY7C65632,\n      .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_GENESYS_LOGIC,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_PRODUCT,\n      .idVendor = USB_VENDOR_TEXAS_INSTRUMENTS,\n      .idProduct = USB_PRODUCT_TUSB8041_USB2,\n      .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_PRODUCT,\n      .idVendor = USB_VENDOR_TEXAS_INSTRUMENTS,\n      .idProduct = USB_PRODUCT_TUSB8041_USB3,\n      .driver_info = HUB_QUIRK_DISABLE_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n      .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n      .bInterfaceClass = USB_CLASS_HUB},\n    { }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n\t.name =\t\t\"hub\",\n\t.probe =\thub_probe,\n\t.disconnect =\thub_disconnect,\n\t.suspend =\thub_suspend,\n\t.resume =\thub_resume,\n\t.reset_resume =\thub_reset_resume,\n\t.pre_reset =\thub_pre_reset,\n\t.post_reset =\thub_post_reset,\n\t.unlocked_ioctl = hub_ioctl,\n\t.id_table =\thub_id_table,\n\t.supports_autosuspend =\t1,\n};\n\nint usb_hub_init(void)\n{\n\tif (usb_register(&hub_driver) < 0) {\n\t\tprintk(KERN_ERR \"%s: can't register hub driver\\n\",\n\t\t\tusbcore_name);\n\t\treturn -1;\n\t}\n\n\t \n\thub_wq = alloc_workqueue(\"usb_hub_wq\", WQ_FREEZABLE, 0);\n\tif (hub_wq)\n\t\treturn 0;\n\n\t \n\tusb_deregister(&hub_driver);\n\tpr_err(\"%s: can't allocate workqueue for usb hub\\n\", usbcore_name);\n\n\treturn -1;\n}\n\nvoid usb_hub_cleanup(void)\n{\n\tdestroy_workqueue(hub_wq);\n\n\t \n\tusb_deregister(&hub_driver);\n}  \n\n \nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t \n\tusb_disable_usb2_hardware_lpm(udev);\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tmutex_lock(hcd->address0_mutex);\n\n\tfor (i = 0; i < PORT_INIT_TRIES; ++i) {\n\t\tif (hub_port_stop_enumerate(parent_hub, port1, i)) {\n\t\t\tret = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i, &descriptor);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\tmutex_unlock(hcd->address0_mutex);\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t \n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tgoto re_enumerate;\n\t}\n\n\t \n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t \n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t \n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t \n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t \n\tusb_enable_usb2_hardware_lpm(udev);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n\n \nint usb_reset_device(struct usb_device *udev)\n{\n\tint ret;\n\tint i;\n\tunsigned int noio_flag;\n\tstruct usb_port *port_dev;\n\tstruct usb_host_config *config = udev->actconfig;\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\tif (udev->state == USB_STATE_NOTATTACHED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udev->parent) {\n\t\t \n\t\tdev_dbg(&udev->dev, \"%s for root hub!\\n\", __func__);\n\t\treturn -EISDIR;\n\t}\n\n\tif (udev->reset_in_progress)\n\t\treturn -EINPROGRESS;\n\tudev->reset_in_progress = 1;\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\t \n\tnoio_flag = memalloc_noio_save();\n\n\t \n\tusb_autoresume_device(udev);\n\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint unbind = 0;\n\n\t\t\tif (cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->pre_reset && drv->post_reset)\n\t\t\t\t\tunbind = (drv->pre_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\tunbind = 1;\n\t\t\t\tif (unbind)\n\t\t\t\t\tusb_forced_unbind_intf(cintf);\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\tret = usb_reset_and_verify_device(udev);\n\tusb_unlock_port(port_dev);\n\n\tif (config) {\n\t\tfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint rebind = cintf->needs_binding;\n\n\t\t\tif (!rebind && cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->post_reset)\n\t\t\t\t\trebind = (drv->post_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\trebind = 1;\n\t\t\t\tif (rebind)\n\t\t\t\t\tcintf->needs_binding = 1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (ret == 0)\n\t\t\tusb_unbind_and_rebind_marked_interfaces(udev);\n\t}\n\n\tusb_autosuspend_device(udev);\n\tmemalloc_noio_restore(noio_flag);\n\tudev->reset_in_progress = 0;\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_reset_device);\n\n\n \nvoid usb_queue_reset_device(struct usb_interface *iface)\n{\n\tif (schedule_work(&iface->reset_ws))\n\t\tusb_get_intf(iface);\n}\nEXPORT_SYMBOL_GPL(usb_queue_reset_device);\n\n \nstruct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\t\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (port1 < 1 || port1 > hdev->maxchild)\n\t\treturn NULL;\n\treturn hub->ports[port1 - 1]->child;\n}\nEXPORT_SYMBOL_GPL(usb_hub_find_child);\n\nvoid usb_hub_adjust_deviceremovable(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tenum usb_port_connect_type connect_type;\n\tint i;\n\n\tif (!hub)\n\t\treturn;\n\n\tif (!hub_is_superspeed(hdev)) {\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu8 mask = 1 << (i%8);\n\n\t\t\t\tif (!(desc->u.hs.DeviceRemovable[i/8] & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tdesc->u.hs.DeviceRemovable[i/8]\t|= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu16 port_removable = le16_to_cpu(desc->u.ss.DeviceRemovable);\n\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu16 mask = 1 << i;\n\n\t\t\t\tif (!(port_removable & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tport_removable |= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n\t}\n}\n\n#ifdef CONFIG_ACPI\n \nacpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,\n\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (!hub)\n\t\treturn NULL;\n\n\treturn ACPI_HANDLE(&hub->ports[port1 - 1]->dev);\n}\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}