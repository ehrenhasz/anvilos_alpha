{
  "module_name": "buffer.c",
  "hash_id": "c51e2c1a65d393eb1b639e1a30056f664b0628880d1f562aa607bf79ebab3bd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/buffer.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <linux/mm.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/genalloc.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n\n \n\n \nstatic size_t pool_max[HCD_BUFFER_POOLS] = {\n\t32, 128, 512, 2048,\n};\n\nvoid __init usb_init_pool_max(void)\n{\n\t \n\tif (ARCH_DMA_MINALIGN <= 32)\n\t\t;\t\t\t \n\telse if (ARCH_DMA_MINALIGN <= 64)\n\t\tpool_max[0] = 64;\n\telse if (ARCH_DMA_MINALIGN <= 128)\n\t\tpool_max[0] = 0;\t \n\telse\n\t\tBUILD_BUG();\t\t \n}\n\n \n\n \nint hcd_buffer_create(struct usb_hcd *hcd)\n{\n\tchar\t\tname[16];\n\tint\t\ti, size;\n\n\tif (hcd->localmem_pool || !hcd_uses_dma(hcd))\n\t\treturn 0;\n\n\tfor (i = 0; i < HCD_BUFFER_POOLS; i++) {\n\t\tsize = pool_max[i];\n\t\tif (!size)\n\t\t\tcontinue;\n\t\tsnprintf(name, sizeof(name), \"buffer-%d\", size);\n\t\thcd->pool[i] = dma_pool_create(name, hcd->self.sysdev,\n\t\t\t\tsize, size, 0);\n\t\tif (!hcd->pool[i]) {\n\t\t\thcd_buffer_destroy(hcd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n \nvoid hcd_buffer_destroy(struct usb_hcd *hcd)\n{\n\tint i;\n\n\tif (!IS_ENABLED(CONFIG_HAS_DMA))\n\t\treturn;\n\n\tfor (i = 0; i < HCD_BUFFER_POOLS; i++) {\n\t\tdma_pool_destroy(hcd->pool[i]);\n\t\thcd->pool[i] = NULL;\n\t}\n}\n\n\n \n\nvoid *hcd_buffer_alloc(\n\tstruct usb_bus\t\t*bus,\n\tsize_t\t\t\tsize,\n\tgfp_t\t\t\tmem_flags,\n\tdma_addr_t\t\t*dma\n)\n{\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(bus);\n\tint\t\t\ti;\n\n\tif (size == 0)\n\t\treturn NULL;\n\n\tif (hcd->localmem_pool)\n\t\treturn gen_pool_dma_alloc(hcd->localmem_pool, size, dma);\n\n\t \n\tif (!hcd_uses_dma(hcd)) {\n\t\t*dma = ~(dma_addr_t) 0;\n\t\treturn kmalloc(size, mem_flags);\n\t}\n\n\tfor (i = 0; i < HCD_BUFFER_POOLS; i++) {\n\t\tif (size <= pool_max[i])\n\t\t\treturn dma_pool_alloc(hcd->pool[i], mem_flags, dma);\n\t}\n\treturn dma_alloc_coherent(hcd->self.sysdev, size, dma, mem_flags);\n}\n\nvoid hcd_buffer_free(\n\tstruct usb_bus\t\t*bus,\n\tsize_t\t\t\tsize,\n\tvoid\t\t\t*addr,\n\tdma_addr_t\t\tdma\n)\n{\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(bus);\n\tint\t\t\ti;\n\n\tif (!addr)\n\t\treturn;\n\n\tif (hcd->localmem_pool) {\n\t\tgen_pool_free(hcd->localmem_pool, (unsigned long)addr, size);\n\t\treturn;\n\t}\n\n\tif (!hcd_uses_dma(hcd)) {\n\t\tkfree(addr);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < HCD_BUFFER_POOLS; i++) {\n\t\tif (size <= pool_max[i]) {\n\t\t\tdma_pool_free(hcd->pool[i], addr, dma);\n\t\t\treturn;\n\t\t}\n\t}\n\tdma_free_coherent(hcd->self.sysdev, size, addr, dma);\n}\n\nvoid *hcd_buffer_alloc_pages(struct usb_hcd *hcd,\n\t\tsize_t size, gfp_t mem_flags, dma_addr_t *dma)\n{\n\tif (size == 0)\n\t\treturn NULL;\n\n\tif (hcd->localmem_pool)\n\t\treturn gen_pool_dma_alloc_align(hcd->localmem_pool,\n\t\t\t\tsize, dma, PAGE_SIZE);\n\n\t \n\tif (!hcd_uses_dma(hcd)) {\n\t\t*dma = DMA_MAPPING_ERROR;\n\t\treturn (void *)__get_free_pages(mem_flags,\n\t\t\t\tget_order(size));\n\t}\n\n\treturn dma_alloc_coherent(hcd->self.sysdev,\n\t\t\tsize, dma, mem_flags);\n}\n\nvoid hcd_buffer_free_pages(struct usb_hcd *hcd,\n\t\tsize_t size, void *addr, dma_addr_t dma)\n{\n\tif (!addr)\n\t\treturn;\n\n\tif (hcd->localmem_pool) {\n\t\tgen_pool_free(hcd->localmem_pool,\n\t\t\t\t(unsigned long)addr, size);\n\t\treturn;\n\t}\n\n\tif (!hcd_uses_dma(hcd)) {\n\t\tfree_pages((unsigned long)addr, get_order(size));\n\t\treturn;\n\t}\n\n\tdma_free_coherent(hcd->self.sysdev, size, addr, dma);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}