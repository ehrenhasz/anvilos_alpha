{
  "module_name": "endpoint.c",
  "hash_id": "d91f128275f433b93e1b6e813d7fcb01855330d2e88b9d738dc0047e92ed64a4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/endpoint.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include \"usb.h\"\n\nstruct ep_device {\n\tstruct usb_endpoint_descriptor *desc;\n\tstruct usb_device *udev;\n\tstruct device dev;\n};\n#define to_ep_device(_dev) \\\n\tcontainer_of(_dev, struct ep_device, dev)\n\nstruct ep_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct usb_device *,\n\t\t\tstruct usb_endpoint_descriptor *, char *);\n};\n#define to_ep_attribute(_attr) \\\n\tcontainer_of(_attr, struct ep_attribute, attr)\n\n#define usb_ep_attr(field, format_string)\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\\\n\t\t\t       struct device_attribute *attr,\t\\\n\t\t\t       char *buf)\t\t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct ep_device *ep = to_ep_device(dev);\t\t\\\n\treturn sprintf(buf, format_string, ep->desc->field);\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nusb_ep_attr(bLength, \"%02x\\n\");\nusb_ep_attr(bEndpointAddress, \"%02x\\n\");\nusb_ep_attr(bmAttributes, \"%02x\\n\");\nusb_ep_attr(bInterval, \"%02x\\n\");\n\nstatic ssize_t wMaxPacketSize_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct ep_device *ep = to_ep_device(dev);\n\treturn sprintf(buf, \"%04x\\n\", usb_endpoint_maxp(ep->desc));\n}\nstatic DEVICE_ATTR_RO(wMaxPacketSize);\n\nstatic ssize_t type_show(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf)\n{\n\tstruct ep_device *ep = to_ep_device(dev);\n\tchar *type = \"unknown\";\n\n\tswitch (usb_endpoint_type(ep->desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\ttype = \"Control\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ttype = \"Isoc\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\ttype = \"Bulk\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttype = \"Interrupt\";\n\t\tbreak;\n\t}\n\treturn sprintf(buf, \"%s\\n\", type);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t interval_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct ep_device *ep = to_ep_device(dev);\n\tunsigned int interval;\n\tchar unit;\n\n\tinterval = usb_decode_interval(ep->desc, ep->udev->speed);\n\tif (interval % 1000) {\n\t\tunit = 'u';\n\t} else {\n\t\tunit = 'm';\n\t\tinterval /= 1000;\n\t}\n\n\treturn sprintf(buf, \"%d%cs\\n\", interval, unit);\n}\nstatic DEVICE_ATTR_RO(interval);\n\nstatic ssize_t direction_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ep_device *ep = to_ep_device(dev);\n\tchar *direction;\n\n\tif (usb_endpoint_xfer_control(ep->desc))\n\t\tdirection = \"both\";\n\telse if (usb_endpoint_dir_in(ep->desc))\n\t\tdirection = \"in\";\n\telse\n\t\tdirection = \"out\";\n\treturn sprintf(buf, \"%s\\n\", direction);\n}\nstatic DEVICE_ATTR_RO(direction);\n\nstatic struct attribute *ep_dev_attrs[] = {\n\t&dev_attr_bLength.attr,\n\t&dev_attr_bEndpointAddress.attr,\n\t&dev_attr_bmAttributes.attr,\n\t&dev_attr_bInterval.attr,\n\t&dev_attr_wMaxPacketSize.attr,\n\t&dev_attr_interval.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_direction.attr,\n\tNULL,\n};\nstatic const struct attribute_group ep_dev_attr_grp = {\n\t.attrs = ep_dev_attrs,\n};\nstatic const struct attribute_group *ep_dev_groups[] = {\n\t&ep_dev_attr_grp,\n\tNULL\n};\n\nstatic void ep_device_release(struct device *dev)\n{\n\tstruct ep_device *ep_dev = to_ep_device(dev);\n\n\tkfree(ep_dev);\n}\n\nstruct device_type usb_ep_device_type = {\n\t.name =\t\t\"usb_endpoint\",\n\t.release = ep_device_release,\n};\n\nint usb_create_ep_devs(struct device *parent,\n\t\t\tstruct usb_host_endpoint *endpoint,\n\t\t\tstruct usb_device *udev)\n{\n\tstruct ep_device *ep_dev;\n\tint retval;\n\n\tep_dev = kzalloc(sizeof(*ep_dev), GFP_KERNEL);\n\tif (!ep_dev) {\n\t\tretval = -ENOMEM;\n\t\tgoto exit;\n\t}\n\n\tep_dev->desc = &endpoint->desc;\n\tep_dev->udev = udev;\n\tep_dev->dev.groups = ep_dev_groups;\n\tep_dev->dev.type = &usb_ep_device_type;\n\tep_dev->dev.parent = parent;\n\tdev_set_name(&ep_dev->dev, \"ep_%02x\", endpoint->desc.bEndpointAddress);\n\n\tretval = device_register(&ep_dev->dev);\n\tif (retval)\n\t\tgoto error_register;\n\n\tdevice_enable_async_suspend(&ep_dev->dev);\n\tendpoint->ep_dev = ep_dev;\n\treturn retval;\n\nerror_register:\n\tput_device(&ep_dev->dev);\nexit:\n\treturn retval;\n}\n\nvoid usb_remove_ep_devs(struct usb_host_endpoint *endpoint)\n{\n\tstruct ep_device *ep_dev = endpoint->ep_dev;\n\n\tif (ep_dev) {\n\t\tdevice_unregister(&ep_dev->dev);\n\t\tendpoint->ep_dev = NULL;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}