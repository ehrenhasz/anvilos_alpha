{
  "module_name": "file.c",
  "hash_id": "dfde8ff50f8efa1e2ffe3c546134537c91c6e3a53c2a2de927922c50676816c8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/file.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/rwsem.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n\n#include \"usb.h\"\n\n#define MAX_USB_MINORS\t256\nstatic const struct file_operations *usb_minors[MAX_USB_MINORS];\nstatic DECLARE_RWSEM(minor_rwsem);\n\nstatic int usb_open(struct inode *inode, struct file *file)\n{\n\tint err = -ENODEV;\n\tconst struct file_operations *new_fops;\n\n\tdown_read(&minor_rwsem);\n\tnew_fops = fops_get(usb_minors[iminor(inode)]);\n\n\tif (!new_fops)\n\t\tgoto done;\n\n\treplace_fops(file, new_fops);\n\t \n\tif (file->f_op->open)\n\t\terr = file->f_op->open(inode, file);\n done:\n\tup_read(&minor_rwsem);\n\treturn err;\n}\n\nstatic const struct file_operations usb_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tusb_open,\n\t.llseek =\tnoop_llseek,\n};\n\nstatic char *usb_devnode(const struct device *dev, umode_t *mode)\n{\n\tstruct usb_class_driver *drv;\n\n\tdrv = dev_get_drvdata(dev);\n\tif (!drv || !drv->devnode)\n\t\treturn NULL;\n\treturn drv->devnode(dev, mode);\n}\n\nconst struct class usbmisc_class = {\n\t.name\t\t= \"usbmisc\",\n\t.devnode\t= usb_devnode,\n};\n\nint usb_major_init(void)\n{\n\tint error;\n\n\terror = register_chrdev(USB_MAJOR, \"usb\", &usb_fops);\n\tif (error)\n\t\tprintk(KERN_ERR \"Unable to get major %d for usb devices\\n\",\n\t\t       USB_MAJOR);\n\n\treturn error;\n}\n\nvoid usb_major_cleanup(void)\n{\n\tunregister_chrdev(USB_MAJOR, \"usb\");\n}\n\n \nint usb_register_dev(struct usb_interface *intf,\n\t\t     struct usb_class_driver *class_driver)\n{\n\tint retval = 0;\n\tint minor_base = class_driver->minor_base;\n\tint minor;\n\tchar name[20];\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n\t \n\tminor_base = 0;\n#endif\n\n\tif (class_driver->fops == NULL)\n\t\treturn -EINVAL;\n\tif (intf->minor >= 0)\n\t\treturn -EADDRINUSE;\n\n\tdev_dbg(&intf->dev, \"looking for a minor, starting at %d\\n\", minor_base);\n\n\tdown_write(&minor_rwsem);\n\tfor (minor = minor_base; minor < MAX_USB_MINORS; ++minor) {\n\t\tif (usb_minors[minor])\n\t\t\tcontinue;\n\n\t\tusb_minors[minor] = class_driver->fops;\n\t\tintf->minor = minor;\n\t\tbreak;\n\t}\n\tif (intf->minor < 0) {\n\t\tup_write(&minor_rwsem);\n\t\treturn -EXFULL;\n\t}\n\n\t \n\tsnprintf(name, sizeof(name), class_driver->name, minor - minor_base);\n\tintf->usb_dev = device_create(&usbmisc_class, &intf->dev,\n\t\t\t\t      MKDEV(USB_MAJOR, minor), class_driver,\n\t\t\t\t      \"%s\", kbasename(name));\n\tif (IS_ERR(intf->usb_dev)) {\n\t\tusb_minors[minor] = NULL;\n\t\tintf->minor = -1;\n\t\tretval = PTR_ERR(intf->usb_dev);\n\t}\n\tup_write(&minor_rwsem);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_register_dev);\n\n \nvoid usb_deregister_dev(struct usb_interface *intf,\n\t\t\tstruct usb_class_driver *class_driver)\n{\n\tif (intf->minor == -1)\n\t\treturn;\n\n\tdev_dbg(&intf->dev, \"removing %d minor\\n\", intf->minor);\n\tdevice_destroy(&usbmisc_class, MKDEV(USB_MAJOR, intf->minor));\n\n\tdown_write(&minor_rwsem);\n\tusb_minors[intf->minor] = NULL;\n\tup_write(&minor_rwsem);\n\n\tintf->usb_dev = NULL;\n\tintf->minor = -1;\n}\nEXPORT_SYMBOL_GPL(usb_deregister_dev);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}