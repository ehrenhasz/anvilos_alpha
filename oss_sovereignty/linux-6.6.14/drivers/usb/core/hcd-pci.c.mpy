{
  "module_name": "hcd-pci.c",
  "hash_id": "6de6c182a4303617d3cf164e3f97ebf2e154cf8336996139af02d2c12ff3b1ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/hcd-pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#ifdef CONFIG_PPC_PMAC\n#include <asm/machdep.h>\n#include <asm/pmac_feature.h>\n#endif\n\n#include \"usb.h\"\n\n\n \n\n \n\nstatic DECLARE_RWSEM(companions_rwsem);\n\n#define CL_UHCI\t\tPCI_CLASS_SERIAL_USB_UHCI\n#define CL_OHCI\t\tPCI_CLASS_SERIAL_USB_OHCI\n#define CL_EHCI\t\tPCI_CLASS_SERIAL_USB_EHCI\n\nstatic inline int is_ohci_or_uhci(struct pci_dev *pdev)\n{\n\treturn pdev->class == CL_OHCI || pdev->class == CL_UHCI;\n}\n\ntypedef void (*companion_fn)(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd);\n\n \nstatic void for_each_companion(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tcompanion_fn fn)\n{\n\tstruct pci_dev\t\t*companion;\n\tstruct usb_hcd\t\t*companion_hcd;\n\tunsigned int\t\tslot = PCI_SLOT(pdev->devfn);\n\n\t \n\tcompanion = NULL;\n\tfor_each_pci_dev(companion) {\n\t\tif (companion->bus != pdev->bus ||\n\t\t\t\tPCI_SLOT(companion->devfn) != slot)\n\t\t\tcontinue;\n\n\t\t \n\t\tif (companion->class != CL_UHCI && companion->class != CL_OHCI &&\n\t\t\t\tcompanion->class != CL_EHCI)\n\t\t\tcontinue;\n\n\t\tcompanion_hcd = pci_get_drvdata(companion);\n\t\tif (!companion_hcd || !companion_hcd->self.root_hub)\n\t\t\tcontinue;\n\t\tfn(pdev, hcd, companion, companion_hcd);\n\t}\n}\n\n \nstatic void ehci_pre_add(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd)\n{\n\tstruct usb_device *udev;\n\n\tif (is_ohci_or_uhci(companion)) {\n\t\tudev = companion_hcd->self.root_hub;\n\t\tusb_lock_device(udev);\n\t\tusb_set_configuration(udev, 0);\n\t}\n}\n\n \nstatic void ehci_post_add(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd)\n{\n\tstruct usb_device *udev;\n\n\tif (is_ohci_or_uhci(companion)) {\n\t\tif (dev_get_drvdata(&pdev->dev)) {\t \n\t\t\tdev_dbg(&pdev->dev, \"HS companion for %s\\n\",\n\t\t\t\t\tdev_name(&companion->dev));\n\t\t\tcompanion_hcd->self.hs_companion = &hcd->self;\n\t\t}\n\t\tudev = companion_hcd->self.root_hub;\n\t\tusb_set_configuration(udev, 1);\n\t\tusb_unlock_device(udev);\n\t}\n}\n\n \nstatic void non_ehci_add(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd)\n{\n\tif (is_ohci_or_uhci(pdev) && companion->class == CL_EHCI) {\n\t\tdev_dbg(&pdev->dev, \"FS/LS companion for %s\\n\",\n\t\t\t\tdev_name(&companion->dev));\n\t\thcd->self.hs_companion = &companion_hcd->self;\n\t}\n}\n\n \nstatic void ehci_remove(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd)\n{\n\tif (is_ohci_or_uhci(companion))\n\t\tcompanion_hcd->self.hs_companion = NULL;\n}\n\n#ifdef\tCONFIG_PM\n\n \nstatic void ehci_wait_for_companions(struct pci_dev *pdev, struct usb_hcd *hcd,\n\t\tstruct pci_dev *companion, struct usb_hcd *companion_hcd)\n{\n\tif (is_ohci_or_uhci(companion))\n\t\tdevice_pm_wait_for_dev(&pdev->dev, &companion->dev);\n}\n\n#endif\t \n\n \n\n \n \n\n \nint usb_hcd_pci_probe(struct pci_dev *dev, const struct hc_driver *driver)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tint\t\t\tretval;\n\tint\t\t\thcd_irq = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (!driver)\n\t\treturn -EINVAL;\n\n\tif (pci_enable_device(dev) < 0)\n\t\treturn -ENODEV;\n\n\t \n\tif ((driver->flags & HCD_MASK) < HCD_USB3) {\n\t\tretval = pci_alloc_irq_vectors(dev, 1, 1, PCI_IRQ_LEGACY | PCI_IRQ_MSI);\n\t\tif (retval < 0) {\n\t\t\tdev_err(&dev->dev,\n\t\t\t\"Found HC with no IRQ. Check BIOS/PCI %s setup!\\n\",\n\t\t\t\tpci_name(dev));\n\t\t\tretval = -ENODEV;\n\t\t\tgoto disable_pci;\n\t\t}\n\t\thcd_irq = pci_irq_vector(dev, 0);\n\t}\n\n\thcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto free_irq_vectors;\n\t}\n\n\thcd->amd_resume_bug = (usb_hcd_amd_remote_wakeup_quirk(dev) &&\n\t\t\tdriver->flags & (HCD_USB11 | HCD_USB3)) ? 1 : 0;\n\n\tif (driver->flags & HCD_MEMORY) {\n\t\t \n\t\thcd->rsrc_start = pci_resource_start(dev, 0);\n\t\thcd->rsrc_len = pci_resource_len(dev, 0);\n\t\tif (!devm_request_mem_region(&dev->dev, hcd->rsrc_start,\n\t\t\t\thcd->rsrc_len, driver->description)) {\n\t\t\tdev_dbg(&dev->dev, \"controller already in use\\n\");\n\t\t\tretval = -EBUSY;\n\t\t\tgoto put_hcd;\n\t\t}\n\t\thcd->regs = devm_ioremap(&dev->dev, hcd->rsrc_start,\n\t\t\t\thcd->rsrc_len);\n\t\tif (hcd->regs == NULL) {\n\t\t\tdev_dbg(&dev->dev, \"error mapping memory\\n\");\n\t\t\tretval = -EFAULT;\n\t\t\tgoto put_hcd;\n\t\t}\n\n\t} else {\n\t\t \n\t\tint\tregion;\n\n\t\tfor (region = 0; region < PCI_STD_NUM_BARS; region++) {\n\t\t\tif (!(pci_resource_flags(dev, region) &\n\t\t\t\t\tIORESOURCE_IO))\n\t\t\t\tcontinue;\n\n\t\t\thcd->rsrc_start = pci_resource_start(dev, region);\n\t\t\thcd->rsrc_len = pci_resource_len(dev, region);\n\t\t\tif (devm_request_region(&dev->dev, hcd->rsrc_start,\n\t\t\t\t\thcd->rsrc_len, driver->description))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (region == PCI_STD_NUM_BARS) {\n\t\t\tdev_dbg(&dev->dev, \"no i/o regions available\\n\");\n\t\t\tretval = -EBUSY;\n\t\t\tgoto put_hcd;\n\t\t}\n\t}\n\n\tpci_set_master(dev);\n\n\t \n\tif (dev->class == CL_EHCI) {\n\t\tdown_write(&companions_rwsem);\n\t\tdev_set_drvdata(&dev->dev, hcd);\n\t\tfor_each_companion(dev, hcd, ehci_pre_add);\n\t\tretval = usb_add_hcd(hcd, hcd_irq, IRQF_SHARED);\n\t\tif (retval != 0)\n\t\t\tdev_set_drvdata(&dev->dev, NULL);\n\t\tfor_each_companion(dev, hcd, ehci_post_add);\n\t\tup_write(&companions_rwsem);\n\t} else {\n\t\tdown_read(&companions_rwsem);\n\t\tdev_set_drvdata(&dev->dev, hcd);\n\t\tretval = usb_add_hcd(hcd, hcd_irq, IRQF_SHARED);\n\t\tif (retval != 0)\n\t\t\tdev_set_drvdata(&dev->dev, NULL);\n\t\telse\n\t\t\tfor_each_companion(dev, hcd, non_ehci_add);\n\t\tup_read(&companions_rwsem);\n\t}\n\n\tif (retval != 0)\n\t\tgoto put_hcd;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tif (pci_dev_run_wake(dev))\n\t\tpm_runtime_put_noidle(&dev->dev);\n\treturn retval;\n\nput_hcd:\n\tusb_put_hcd(hcd);\nfree_irq_vectors:\n\tif ((driver->flags & HCD_MASK) < HCD_USB3)\n\t\tpci_free_irq_vectors(dev);\ndisable_pci:\n\tpci_disable_device(dev);\n\tdev_err(&dev->dev, \"init %s fail, %d\\n\", pci_name(dev), retval);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_pci_probe);\n\n\n \n \n\n \nvoid usb_hcd_pci_remove(struct pci_dev *dev)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tint\t\t\thcd_driver_flags;\n\n\thcd = pci_get_drvdata(dev);\n\tif (!hcd)\n\t\treturn;\n\n\thcd_driver_flags = hcd->driver->flags;\n\n\tif (pci_dev_run_wake(dev))\n\t\tpm_runtime_get_noresume(&dev->dev);\n\n\t \n\tlocal_irq_disable();\n\tusb_hcd_irq(0, hcd);\n\tlocal_irq_enable();\n\n\t \n\tif (dev->class == CL_EHCI) {\n\t\tdown_write(&companions_rwsem);\n\t\tfor_each_companion(dev, hcd, ehci_remove);\n\t\tusb_remove_hcd(hcd);\n\t\tdev_set_drvdata(&dev->dev, NULL);\n\t\tup_write(&companions_rwsem);\n\t} else {\n\t\t \n\t\tdown_read(&companions_rwsem);\n\t\thcd->self.hs_companion = NULL;\n\t\tusb_remove_hcd(hcd);\n\t\tdev_set_drvdata(&dev->dev, NULL);\n\t\tup_read(&companions_rwsem);\n\t}\n\tusb_put_hcd(hcd);\n\tif ((hcd_driver_flags & HCD_MASK) < HCD_USB3)\n\t\tpci_free_irq_vectors(dev);\n\tpci_disable_device(dev);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_pci_remove);\n\n \nvoid usb_hcd_pci_shutdown(struct pci_dev *dev)\n{\n\tstruct usb_hcd\t\t*hcd;\n\n\thcd = pci_get_drvdata(dev);\n\tif (!hcd)\n\t\treturn;\n\n\tif (test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags) &&\n\t\t\thcd->driver->shutdown) {\n\t\thcd->driver->shutdown(hcd);\n\t\tif (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)\n\t\t\tfree_irq(hcd->irq, hcd);\n\t\tpci_disable_device(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_hcd_pci_shutdown);\n\n#ifdef\tCONFIG_PM\n\n#ifdef\tCONFIG_PPC_PMAC\nstatic void powermac_set_asic(struct pci_dev *pci_dev, int enable)\n{\n\t \n\tif (machine_is(powermac)) {\n\t\tstruct device_node\t*of_node;\n\n\t\tof_node = pci_device_to_OF_node(pci_dev);\n\t\tif (of_node)\n\t\t\tpmac_call_feature(PMAC_FTR_USB_ENABLE,\n\t\t\t\t\tof_node, 0, enable);\n\t}\n}\n\n#else\n\nstatic inline void powermac_set_asic(struct pci_dev *pci_dev, int enable)\n{}\n\n#endif\t \n\nstatic int check_root_hub_suspended(struct device *dev)\n{\n\tstruct usb_hcd\t\t*hcd = dev_get_drvdata(dev);\n\n\tif (HCD_RH_RUNNING(hcd)) {\n\t\tdev_warn(dev, \"Root hub is not suspended\\n\");\n\t\treturn -EBUSY;\n\t}\n\tif (hcd->shared_hcd) {\n\t\thcd = hcd->shared_hcd;\n\t\tif (HCD_RH_RUNNING(hcd)) {\n\t\t\tdev_warn(dev, \"Secondary root hub is not suspended\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int suspend_common(struct device *dev, pm_message_t msg)\n{\n\tstruct pci_dev\t\t*pci_dev = to_pci_dev(dev);\n\tstruct usb_hcd\t\t*hcd = pci_get_drvdata(pci_dev);\n\tbool\t\t\tdo_wakeup;\n\tint\t\t\tretval;\n\n\tdo_wakeup = PMSG_IS_AUTO(msg) ? true : device_may_wakeup(dev);\n\n\t \n\tretval = check_root_hub_suspended(dev);\n\tif (retval)\n\t\treturn retval;\n\n\tif (hcd->driver->pci_suspend && !HCD_DEAD(hcd)) {\n\t\t \n\t\tif (do_wakeup && HCD_WAKEUP_PENDING(hcd))\n\t\t\treturn -EBUSY;\n\t\tif (do_wakeup && hcd->shared_hcd &&\n\t\t\t\tHCD_WAKEUP_PENDING(hcd->shared_hcd))\n\t\t\treturn -EBUSY;\n\t\tretval = hcd->driver->pci_suspend(hcd, do_wakeup);\n\t\tsuspend_report_result(dev, hcd->driver->pci_suspend, retval);\n\n\t\t \n\t\tif ((retval == 0 && do_wakeup && HCD_WAKEUP_PENDING(hcd)) ||\n\t\t\t\t(retval == 0 && do_wakeup && hcd->shared_hcd &&\n\t\t\t\t HCD_WAKEUP_PENDING(hcd->shared_hcd))) {\n\t\t\tif (hcd->driver->pci_resume)\n\t\t\t\thcd->driver->pci_resume(hcd, msg);\n\t\t\tretval = -EBUSY;\n\t\t}\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\t \n\tif (!hcd->msix_enabled)\n\t\tsynchronize_irq(pci_irq_vector(pci_dev, 0));\n\n\t \n\tpci_disable_device(pci_dev);\n\treturn retval;\n}\n\nstatic int resume_common(struct device *dev, pm_message_t msg)\n{\n\tstruct pci_dev\t\t*pci_dev = to_pci_dev(dev);\n\tstruct usb_hcd\t\t*hcd = pci_get_drvdata(pci_dev);\n\tint\t\t\tretval;\n\n\tif (HCD_RH_RUNNING(hcd) ||\n\t\t\t(hcd->shared_hcd &&\n\t\t\t HCD_RH_RUNNING(hcd->shared_hcd))) {\n\t\tdev_dbg(dev, \"can't resume, not suspended!\\n\");\n\t\treturn 0;\n\t}\n\n\tretval = pci_enable_device(pci_dev);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"can't re-enable after resume, %d!\\n\", retval);\n\t\treturn retval;\n\t}\n\n\tpci_set_master(pci_dev);\n\n\tif (hcd->driver->pci_resume && !HCD_DEAD(hcd)) {\n\n\t\t \n\t\tif (pci_dev->class == CL_EHCI && msg.event != PM_EVENT_AUTO_RESUME)\n\t\t\tfor_each_companion(pci_dev, hcd,\n\t\t\t\t\tehci_wait_for_companions);\n\n\t\tretval = hcd->driver->pci_resume(hcd, msg);\n\t\tif (retval) {\n\t\t\tdev_err(dev, \"PCI post-resume error %d!\\n\", retval);\n\t\t\tusb_hc_died(hcd);\n\t\t}\n\t}\n\treturn retval;\n}\n\n#ifdef\tCONFIG_PM_SLEEP\n\nstatic int hcd_pci_suspend(struct device *dev)\n{\n\treturn suspend_common(dev, PMSG_SUSPEND);\n}\n\nstatic int hcd_pci_suspend_noirq(struct device *dev)\n{\n\tstruct pci_dev\t\t*pci_dev = to_pci_dev(dev);\n\tstruct usb_hcd\t\t*hcd = pci_get_drvdata(pci_dev);\n\tint\t\t\tretval;\n\n\tretval = check_root_hub_suspended(dev);\n\tif (retval)\n\t\treturn retval;\n\n\tpci_save_state(pci_dev);\n\n\t \n\tif (HCD_DEAD(hcd))\n\t\tdevice_set_wakeup_enable(dev, 0);\n\tdev_dbg(dev, \"wakeup: %d\\n\", device_may_wakeup(dev));\n\n\t \n\tretval = pci_prepare_to_sleep(pci_dev);\n\tif (retval == -EIO) {\t\t \n\t\tdev_dbg(dev, \"--> PCI D0 legacy\\n\");\n\t\tretval = 0;\n\t} else if (retval == 0) {\n\t\tdev_dbg(dev, \"--> PCI %s\\n\",\n\t\t\t\tpci_power_name(pci_dev->current_state));\n\t} else {\n\t\tsuspend_report_result(dev, pci_prepare_to_sleep, retval);\n\t\treturn retval;\n\t}\n\n\tpowermac_set_asic(pci_dev, 0);\n\treturn retval;\n}\n\nstatic int hcd_pci_poweroff_late(struct device *dev)\n{\n\tstruct pci_dev\t\t*pci_dev = to_pci_dev(dev);\n\tstruct usb_hcd\t\t*hcd = pci_get_drvdata(pci_dev);\n\n\tif (hcd->driver->pci_poweroff_late && !HCD_DEAD(hcd))\n\t\treturn hcd->driver->pci_poweroff_late(hcd, device_may_wakeup(dev));\n\n\treturn 0;\n}\n\nstatic int hcd_pci_resume_noirq(struct device *dev)\n{\n\tpowermac_set_asic(to_pci_dev(dev), 1);\n\treturn 0;\n}\n\nstatic int hcd_pci_resume(struct device *dev)\n{\n\treturn resume_common(dev, PMSG_RESUME);\n}\n\nstatic int hcd_pci_restore(struct device *dev)\n{\n\treturn resume_common(dev, PMSG_RESTORE);\n}\n\n#else\n\n#define hcd_pci_suspend\t\tNULL\n#define hcd_pci_suspend_noirq\tNULL\n#define hcd_pci_poweroff_late\tNULL\n#define hcd_pci_resume_noirq\tNULL\n#define hcd_pci_resume\t\tNULL\n#define hcd_pci_restore\t\tNULL\n\n#endif\t \n\nstatic int hcd_pci_runtime_suspend(struct device *dev)\n{\n\tint\tretval;\n\n\tretval = suspend_common(dev, PMSG_AUTO_SUSPEND);\n\tif (retval == 0)\n\t\tpowermac_set_asic(to_pci_dev(dev), 0);\n\tdev_dbg(dev, \"hcd_pci_runtime_suspend: %d\\n\", retval);\n\treturn retval;\n}\n\nstatic int hcd_pci_runtime_resume(struct device *dev)\n{\n\tint\tretval;\n\n\tpowermac_set_asic(to_pci_dev(dev), 1);\n\tretval = resume_common(dev, PMSG_AUTO_RESUME);\n\tdev_dbg(dev, \"hcd_pci_runtime_resume: %d\\n\", retval);\n\treturn retval;\n}\n\nconst struct dev_pm_ops usb_hcd_pci_pm_ops = {\n\t.suspend\t= hcd_pci_suspend,\n\t.suspend_noirq\t= hcd_pci_suspend_noirq,\n\t.resume_noirq\t= hcd_pci_resume_noirq,\n\t.resume\t\t= hcd_pci_resume,\n\t.freeze\t\t= hcd_pci_suspend,\n\t.freeze_noirq\t= check_root_hub_suspended,\n\t.thaw_noirq\t= NULL,\n\t.thaw\t\t= hcd_pci_resume,\n\t.poweroff\t= hcd_pci_suspend,\n\t.poweroff_late\t= hcd_pci_poweroff_late,\n\t.poweroff_noirq\t= hcd_pci_suspend_noirq,\n\t.restore_noirq\t= hcd_pci_resume_noirq,\n\t.restore\t= hcd_pci_restore,\n\t.runtime_suspend = hcd_pci_runtime_suspend,\n\t.runtime_resume\t= hcd_pci_runtime_resume,\n};\nEXPORT_SYMBOL_GPL(usb_hcd_pci_pm_ops);\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}