{
  "module_name": "devices.c",
  "hash_id": "71852762d3823b12fd88d178d5150cf4da333e347f8ae017af17665163b00dd3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/devices.c",
  "human_readable_source": "\n \n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\n#include \"usb.h\"\n\n \n#define ALLOW_SERIAL_NUMBER\n\nstatic const char format_topo[] =\n \n\"\\nT:  Bus=%2.2d Lev=%2.2d Prnt=%2.2d Port=%2.2d Cnt=%2.2d Dev#=%3d Spd=%-4s MxCh=%2d\\n\";\n\nstatic const char format_string_manufacturer[] =\n \n  \"S:  Manufacturer=%.100s\\n\";\n\nstatic const char format_string_product[] =\n \n  \"S:  Product=%.100s\\n\";\n\n#ifdef ALLOW_SERIAL_NUMBER\nstatic const char format_string_serialnumber[] =\n \n  \"S:  SerialNumber=%.100s\\n\";\n#endif\n\nstatic const char format_bandwidth[] =\n \n  \"B:  Alloc=%3d/%3d us (%2d%%), #Int=%3d, #Iso=%3d\\n\";\n\nstatic const char format_device1[] =\n \n  \"D:  Ver=%2x.%02x Cls=%02x(%-5s) Sub=%02x Prot=%02x MxPS=%2d #Cfgs=%3d\\n\";\n\nstatic const char format_device2[] =\n \n  \"P:  Vendor=%04x ProdID=%04x Rev=%2x.%02x\\n\";\n\nstatic const char format_config[] =\n \n  \"C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\\n\";\n\nstatic const char format_iad[] =\n \n  \"A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\\n\";\n\nstatic const char format_iface[] =\n \n  \"I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\\n\";\n\nstatic const char format_endpt[] =\n \n  \"E:  Ad=%02x(%c) Atr=%02x(%-4s) MxPS=%4d Ivl=%d%cs\\n\";\n\nstruct class_info {\n\tint class;\n\tchar *class_name;\n};\n\nstatic const struct class_info clas_info[] = {\n\t \n\t{USB_CLASS_PER_INTERFACE,\t\">ifc\"},\n\t{USB_CLASS_AUDIO,\t\t\"audio\"},\n\t{USB_CLASS_COMM,\t\t\"comm.\"},\n\t{USB_CLASS_HID,\t\t\t\"HID\"},\n\t{USB_CLASS_PHYSICAL,\t\t\"PID\"},\n\t{USB_CLASS_STILL_IMAGE,\t\t\"still\"},\n\t{USB_CLASS_PRINTER,\t\t\"print\"},\n\t{USB_CLASS_MASS_STORAGE,\t\"stor.\"},\n\t{USB_CLASS_HUB,\t\t\t\"hub\"},\n\t{USB_CLASS_CDC_DATA,\t\t\"data\"},\n\t{USB_CLASS_CSCID,\t\t\"scard\"},\n\t{USB_CLASS_CONTENT_SEC,\t\t\"c-sec\"},\n\t{USB_CLASS_VIDEO,\t\t\"video\"},\n\t{USB_CLASS_PERSONAL_HEALTHCARE,\t\"perhc\"},\n\t{USB_CLASS_AUDIO_VIDEO,\t\t\"av\"},\n\t{USB_CLASS_BILLBOARD,\t\t\"blbrd\"},\n\t{USB_CLASS_USB_TYPE_C_BRIDGE,\t\"bridg\"},\n\t{USB_CLASS_WIRELESS_CONTROLLER,\t\"wlcon\"},\n\t{USB_CLASS_MISC,\t\t\"misc\"},\n\t{USB_CLASS_APP_SPEC,\t\t\"app.\"},\n\t{USB_CLASS_VENDOR_SPEC,\t\t\"vend.\"},\n\t{-1,\t\t\t\t\"unk.\"}\t\t \n};\n\n \n\nstatic const char *class_decode(const int class)\n{\n\tint ix;\n\n\tfor (ix = 0; clas_info[ix].class != -1; ix++)\n\t\tif (clas_info[ix].class == class)\n\t\t\tbreak;\n\treturn clas_info[ix].class_name;\n}\n\nstatic char *usb_dump_endpoint_descriptor(int speed, char *start, char *end,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tchar dir, unit, *type;\n\tunsigned interval, bandwidth = 1;\n\n\tif (start > end)\n\t\treturn start;\n\n\tdir = usb_endpoint_dir_in(desc) ? 'I' : 'O';\n\n\tif (speed == USB_SPEED_HIGH)\n\t\tbandwidth = usb_endpoint_maxp_mult(desc);\n\n\t \n\tswitch (usb_endpoint_type(desc)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\ttype = \"Ctrl\";\n\t\tdir = 'B';\t\t\t \n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ttype = \"Isoc\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\ttype = \"Bulk\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttype = \"Int.\";\n\t\tbreak;\n\tdefault:\t \n\t\treturn start;\n\t}\n\n\tinterval = usb_decode_interval(desc, speed);\n\tif (interval % 1000) {\n\t\tunit = 'u';\n\t} else {\n\t\tunit = 'm';\n\t\tinterval /= 1000;\n\t}\n\n\tstart += sprintf(start, format_endpt, desc->bEndpointAddress, dir,\n\t\t\t desc->bmAttributes, type,\n\t\t\t usb_endpoint_maxp(desc) *\n\t\t\t bandwidth,\n\t\t\t interval, unit);\n\treturn start;\n}\n\nstatic char *usb_dump_interface_descriptor(char *start, char *end,\n\t\t\t\t\tconst struct usb_interface_cache *intfc,\n\t\t\t\t\tconst struct usb_interface *iface,\n\t\t\t\t\tint setno)\n{\n\tconst struct usb_interface_descriptor *desc;\n\tconst char *driver_name = \"\";\n\tint active = 0;\n\n\tif (start > end)\n\t\treturn start;\n\tdesc = &intfc->altsetting[setno].desc;\n\tif (iface) {\n\t\tdriver_name = (iface->dev.driver\n\t\t\t\t? iface->dev.driver->name\n\t\t\t\t: \"(none)\");\n\t\tactive = (desc == &iface->cur_altsetting->desc);\n\t}\n\tstart += sprintf(start, format_iface,\n\t\t\t active ? '*' : ' ',\t \n\t\t\t desc->bInterfaceNumber,\n\t\t\t desc->bAlternateSetting,\n\t\t\t desc->bNumEndpoints,\n\t\t\t desc->bInterfaceClass,\n\t\t\t class_decode(desc->bInterfaceClass),\n\t\t\t desc->bInterfaceSubClass,\n\t\t\t desc->bInterfaceProtocol,\n\t\t\t driver_name);\n\treturn start;\n}\n\nstatic char *usb_dump_interface(int speed, char *start, char *end,\n\t\t\t\tconst struct usb_interface_cache *intfc,\n\t\t\t\tconst struct usb_interface *iface, int setno)\n{\n\tconst struct usb_host_interface *desc = &intfc->altsetting[setno];\n\tint i;\n\n\tstart = usb_dump_interface_descriptor(start, end, intfc, iface, setno);\n\tfor (i = 0; i < desc->desc.bNumEndpoints; i++) {\n\t\tstart = usb_dump_endpoint_descriptor(speed,\n\t\t\t\tstart, end, &desc->endpoint[i].desc);\n\t}\n\treturn start;\n}\n\nstatic char *usb_dump_iad_descriptor(char *start, char *end,\n\t\t\tconst struct usb_interface_assoc_descriptor *iad)\n{\n\tif (start > end)\n\t\treturn start;\n\tstart += sprintf(start, format_iad,\n\t\t\t iad->bFirstInterface,\n\t\t\t iad->bInterfaceCount,\n\t\t\t iad->bFunctionClass,\n\t\t\t class_decode(iad->bFunctionClass),\n\t\t\t iad->bFunctionSubClass,\n\t\t\t iad->bFunctionProtocol);\n\treturn start;\n}\n\n \nstatic char *usb_dump_config_descriptor(char *start, char *end,\n\t\t\t\tconst struct usb_config_descriptor *desc,\n\t\t\t\tint active, int speed)\n{\n\tint mul;\n\n\tif (start > end)\n\t\treturn start;\n\tif (speed >= USB_SPEED_SUPER)\n\t\tmul = 8;\n\telse\n\t\tmul = 2;\n\tstart += sprintf(start, format_config,\n\t\t\t  \n\t\t\t active ? '*' : ' ',\n\t\t\t desc->bNumInterfaces,\n\t\t\t desc->bConfigurationValue,\n\t\t\t desc->bmAttributes,\n\t\t\t desc->bMaxPower * mul);\n\treturn start;\n}\n\nstatic char *usb_dump_config(int speed, char *start, char *end,\n\t\t\t     const struct usb_host_config *config, int active)\n{\n\tint i, j;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_interface *interface;\n\n\tif (start > end)\n\t\treturn start;\n\tif (!config)\n\t\t \n\t\treturn start + sprintf(start, \"(null Cfg. desc.)\\n\");\n\tstart = usb_dump_config_descriptor(start, end, &config->desc, active,\n\t\t\tspeed);\n\tfor (i = 0; i < USB_MAXIADS; i++) {\n\t\tif (config->intf_assoc[i] == NULL)\n\t\t\tbreak;\n\t\tstart = usb_dump_iad_descriptor(start, end,\n\t\t\t\t\tconfig->intf_assoc[i]);\n\t}\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tintfc = config->intf_cache[i];\n\t\tinterface = config->interface[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\t\tstart = usb_dump_interface(speed,\n\t\t\t\tstart, end, intfc, interface, j);\n\t\t}\n\t}\n\treturn start;\n}\n\n \nstatic char *usb_dump_device_descriptor(char *start, char *end,\n\t\t\t\tconst struct usb_device_descriptor *desc)\n{\n\tu16 bcdUSB = le16_to_cpu(desc->bcdUSB);\n\tu16 bcdDevice = le16_to_cpu(desc->bcdDevice);\n\n\tif (start > end)\n\t\treturn start;\n\tstart += sprintf(start, format_device1,\n\t\t\t  bcdUSB >> 8, bcdUSB & 0xff,\n\t\t\t  desc->bDeviceClass,\n\t\t\t  class_decode(desc->bDeviceClass),\n\t\t\t  desc->bDeviceSubClass,\n\t\t\t  desc->bDeviceProtocol,\n\t\t\t  desc->bMaxPacketSize0,\n\t\t\t  desc->bNumConfigurations);\n\tif (start > end)\n\t\treturn start;\n\tstart += sprintf(start, format_device2,\n\t\t\t le16_to_cpu(desc->idVendor),\n\t\t\t le16_to_cpu(desc->idProduct),\n\t\t\t bcdDevice >> 8, bcdDevice & 0xff);\n\treturn start;\n}\n\n \nstatic char *usb_dump_device_strings(char *start, char *end,\n\t\t\t\t     struct usb_device *dev)\n{\n\tif (start > end)\n\t\treturn start;\n\tif (dev->manufacturer)\n\t\tstart += sprintf(start, format_string_manufacturer,\n\t\t\t\t dev->manufacturer);\n\tif (start > end)\n\t\tgoto out;\n\tif (dev->product)\n\t\tstart += sprintf(start, format_string_product, dev->product);\n\tif (start > end)\n\t\tgoto out;\n#ifdef ALLOW_SERIAL_NUMBER\n\tif (dev->serial)\n\t\tstart += sprintf(start, format_string_serialnumber,\n\t\t\t\t dev->serial);\n#endif\n out:\n\treturn start;\n}\n\nstatic char *usb_dump_desc(char *start, char *end, struct usb_device *dev)\n{\n\tint i;\n\n\tstart = usb_dump_device_descriptor(start, end, &dev->descriptor);\n\n\tstart = usb_dump_device_strings(start, end, dev);\n\n\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++) {\n\t\tstart = usb_dump_config(dev->speed,\n\t\t\t\tstart, end, dev->config + i,\n\t\t\t\t \n\t\t\t\t(dev->config + i) == dev->actconfig);\n\t}\n\treturn start;\n}\n\n \n\n \nstatic ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,\n\t\t\t       loff_t *skip_bytes, loff_t *file_offset,\n\t\t\t       struct usb_device *usbdev, struct usb_bus *bus,\n\t\t\t       int level, int index, int count)\n{\n\tint chix;\n\tint ret, cnt = 0;\n\tint parent_devnum = 0;\n\tchar *pages_start, *data_end, *speed;\n\tunsigned int length;\n\tssize_t total_written = 0;\n\tstruct usb_device *childdev = NULL;\n\n\t \n\tif (*nbytes <= 0)\n\t\treturn 0;\n\n\tif (level > MAX_TOPO_LEVEL)\n\t\treturn 0;\n\t \n\tpages_start = (char *)__get_free_pages(GFP_NOIO, 1);\n\tif (!pages_start)\n\t\treturn -ENOMEM;\n\n\tif (usbdev->parent && usbdev->parent->devnum != -1)\n\t\tparent_devnum = usbdev->parent->devnum;\n\t \n\tswitch (usbdev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\"; break;\n\tcase USB_SPEED_UNKNOWN:\t\t \n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\"; break;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\"; break;\n\tcase USB_SPEED_SUPER:\n\t\tspeed = \"5000\"; break;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tspeed = \"10000\"; break;\n\tdefault:\n\t\tspeed = \"??\";\n\t}\n\tdata_end = pages_start + sprintf(pages_start, format_topo,\n\t\t\tbus->busnum, level, parent_devnum,\n\t\t\tindex, count, usbdev->devnum,\n\t\t\tspeed, usbdev->maxchild);\n\t \n\t \n\tif (level == 0) {\n\t\tint\tmax;\n\n\t\t \n\t\tif (usbdev->speed == USB_SPEED_HIGH ||\n\t\t    usbdev->speed >= USB_SPEED_SUPER)\n\t\t\tmax = 800;\n\t\telse\n\t\t\tmax = FRAME_TIME_MAX_USECS_ALLOC;\n\n\t\t \n\t\tdata_end += sprintf(data_end, format_bandwidth,\n\t\t\t\tbus->bandwidth_allocated, max,\n\t\t\t\t(100 * bus->bandwidth_allocated + max / 2)\n\t\t\t\t\t/ max,\n\t\t\t\tbus->bandwidth_int_reqs,\n\t\t\t\tbus->bandwidth_isoc_reqs);\n\n\t}\n\tdata_end = usb_dump_desc(data_end, pages_start + (2 * PAGE_SIZE) - 256,\n\t\t\t\t usbdev);\n\n\tif (data_end > (pages_start + (2 * PAGE_SIZE) - 256))\n\t\tdata_end += sprintf(data_end, \"(truncated)\\n\");\n\n\tlength = data_end - pages_start;\n\t \n\tif (length > *skip_bytes) {\n\t\tlength -= *skip_bytes;\n\t\tif (length > *nbytes)\n\t\t\tlength = *nbytes;\n\t\tif (copy_to_user(*buffer, pages_start + *skip_bytes, length)) {\n\t\t\tfree_pages((unsigned long)pages_start, 1);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\t*nbytes -= length;\n\t\t*file_offset += length;\n\t\ttotal_written += length;\n\t\t*buffer += length;\n\t\t*skip_bytes = 0;\n\t} else\n\t\t*skip_bytes -= length;\n\n\tfree_pages((unsigned long)pages_start, 1);\n\n\t \n\tusb_hub_for_each_child(usbdev, chix, childdev) {\n\t\tusb_lock_device(childdev);\n\t\tret = usb_device_dump(buffer, nbytes, skip_bytes,\n\t\t\t\t      file_offset, childdev, bus,\n\t\t\t\t      level + 1, chix - 1, ++cnt);\n\t\tusb_unlock_device(childdev);\n\t\tif (ret == -EFAULT)\n\t\t\treturn total_written;\n\t\ttotal_written += ret;\n\t}\n\treturn total_written;\n}\n\nstatic ssize_t usb_device_read(struct file *file, char __user *buf,\n\t\t\t       size_t nbytes, loff_t *ppos)\n{\n\tstruct usb_bus *bus;\n\tssize_t ret, total_written = 0;\n\tloff_t skip_bytes = *ppos;\n\tint id;\n\n\tif (*ppos < 0)\n\t\treturn -EINVAL;\n\tif (nbytes <= 0)\n\t\treturn 0;\n\n\tmutex_lock(&usb_bus_idr_lock);\n\t \n\tidr_for_each_entry(&usb_bus_idr, bus, id) {\n\t\t \n\t\tif (!bus_to_hcd(bus)->rh_registered)\n\t\t\tcontinue;\n\t\tusb_lock_device(bus->root_hub);\n\t\tret = usb_device_dump(&buf, &nbytes, &skip_bytes, ppos,\n\t\t\t\t      bus->root_hub, bus, 0, 0, 0);\n\t\tusb_unlock_device(bus->root_hub);\n\t\tif (ret < 0) {\n\t\t\tmutex_unlock(&usb_bus_idr_lock);\n\t\t\treturn ret;\n\t\t}\n\t\ttotal_written += ret;\n\t}\n\tmutex_unlock(&usb_bus_idr_lock);\n\treturn total_written;\n}\n\nconst struct file_operations usbfs_devices_fops = {\n\t.llseek =\tno_seek_end_llseek,\n\t.read =\t\tusb_device_read,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}