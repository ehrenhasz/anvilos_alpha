{
  "module_name": "hcd.c",
  "hash_id": "d4acb8c03fcfb3d980ee84fe71d08acd3065b7fdb2a7a7566e836e0f1d7568bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/hcd.c",
  "human_readable_source": "\n \n\n#include <linux/bcd.h>\n#include <linux/module.h>\n#include <linux/version.h>\n#include <linux/kernel.h>\n#include <linux/sched/task_stack.h>\n#include <linux/slab.h>\n#include <linux/completion.h>\n#include <linux/utsname.h>\n#include <linux/mm.h>\n#include <asm/io.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mutex.h>\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n#include <linux/platform_device.h>\n#include <linux/workqueue.h>\n#include <linux/pm_runtime.h>\n#include <linux/types.h>\n#include <linux/genalloc.h>\n#include <linux/io.h>\n#include <linux/kcov.h>\n\n#include <linux/phy/phy.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n\n#include \"usb.h\"\n#include \"phy.h\"\n\n\n \n\n \n\n \n\n \nunsigned long usb_hcds_loaded;\nEXPORT_SYMBOL_GPL(usb_hcds_loaded);\n\n \nDEFINE_IDR (usb_bus_idr);\nEXPORT_SYMBOL_GPL (usb_bus_idr);\n\n \n#define USB_MAXBUS\t\t64\n\n \nDEFINE_MUTEX(usb_bus_idr_lock);\t \nEXPORT_SYMBOL_GPL (usb_bus_idr_lock);\n\n \nstatic DEFINE_SPINLOCK(hcd_root_hub_lock);\n\n \nstatic DEFINE_SPINLOCK(hcd_urb_list_lock);\n\n \nstatic DEFINE_SPINLOCK(hcd_urb_unlink_lock);\n\n \nDECLARE_WAIT_QUEUE_HEAD(usb_kill_urb_queue);\n\n \n\n \n\n \n#define KERNEL_REL\tbin2bcd(LINUX_VERSION_MAJOR)\n#define KERNEL_VER\tbin2bcd(LINUX_VERSION_PATCHLEVEL)\n\n \nstatic const u8 usb31_rh_dev_descriptor[18] = {\n\t0x12,        \n\tUSB_DT_DEVICE,  \n\t0x10, 0x03,  \n\n\t0x09,\t     \n\t0x00,\t     \n\t0x03,        \n\t0x09,        \n\n\t0x6b, 0x1d,  \n\t0x03, 0x00,  \n\tKERNEL_VER, KERNEL_REL,  \n\n\t0x03,        \n\t0x02,        \n\t0x01,        \n\t0x01         \n};\n\n \nstatic const u8 usb3_rh_dev_descriptor[18] = {\n\t0x12,        \n\tUSB_DT_DEVICE,  \n\t0x00, 0x03,  \n\n\t0x09,\t     \n\t0x00,\t     \n\t0x03,        \n\t0x09,        \n\n\t0x6b, 0x1d,  \n\t0x03, 0x00,  \n\tKERNEL_VER, KERNEL_REL,  \n\n\t0x03,        \n\t0x02,        \n\t0x01,        \n\t0x01         \n};\n\n \nstatic const u8 usb2_rh_dev_descriptor[18] = {\n\t0x12,        \n\tUSB_DT_DEVICE,  \n\t0x00, 0x02,  \n\n\t0x09,\t     \n\t0x00,\t     \n\t0x00,        \n\t0x40,        \n\n\t0x6b, 0x1d,  \n\t0x02, 0x00,  \n\tKERNEL_VER, KERNEL_REL,  \n\n\t0x03,        \n\t0x02,        \n\t0x01,        \n\t0x01         \n};\n\n \n\n \nstatic const u8 usb11_rh_dev_descriptor[18] = {\n\t0x12,        \n\tUSB_DT_DEVICE,  \n\t0x10, 0x01,  \n\n\t0x09,\t     \n\t0x00,\t     \n\t0x00,        \n\t0x40,        \n\n\t0x6b, 0x1d,  \n\t0x01, 0x00,  \n\tKERNEL_VER, KERNEL_REL,  \n\n\t0x03,        \n\t0x02,        \n\t0x01,        \n\t0x01         \n};\n\n\n \n\n \n\nstatic const u8 fs_rh_config_descriptor[] = {\n\n\t \n\t0x09,        \n\tUSB_DT_CONFIG,  \n\t0x19, 0x00,  \n\t0x01,        \n\t0x01,        \n\t0x00,        \n\t0xc0,        \n\t0x00,        \n\n\t \n\n\t \n\t0x09,        \n\tUSB_DT_INTERFACE,   \n\t0x00,        \n\t0x00,        \n\t0x01,        \n\t0x09,        \n\t0x00,        \n\t0x00,        \n\t0x00,        \n\n\t \n\t0x07,        \n\tUSB_DT_ENDPOINT,  \n\t0x81,        \n\t0x03,        \n\t0x02, 0x00,  \n\t0xff         \n};\n\nstatic const u8 hs_rh_config_descriptor[] = {\n\n\t \n\t0x09,        \n\tUSB_DT_CONFIG,  \n\t0x19, 0x00,  \n\t0x01,        \n\t0x01,        \n\t0x00,        \n\t0xc0,        \n\t0x00,        \n\n\t \n\n\t \n\t0x09,        \n\tUSB_DT_INTERFACE,  \n\t0x00,        \n\t0x00,        \n\t0x01,        \n\t0x09,        \n\t0x00,        \n\t0x00,        \n\t0x00,        \n\n\t \n\t0x07,        \n\tUSB_DT_ENDPOINT,  \n\t0x81,        \n\t0x03,        \n\t\t     \n\t(USB_MAXCHILDREN + 1 + 7) / 8, 0x00,\n\t0x0c         \n};\n\nstatic const u8 ss_rh_config_descriptor[] = {\n\t \n\t0x09,        \n\tUSB_DT_CONFIG,  \n\t0x1f, 0x00,  \n\t0x01,        \n\t0x01,        \n\t0x00,        \n\t0xc0,        \n\t0x00,        \n\n\t \n\t0x09,        \n\tUSB_DT_INTERFACE,  \n\t0x00,        \n\t0x00,        \n\t0x01,        \n\t0x09,        \n\t0x00,        \n\t0x00,        \n\t0x00,        \n\n\t \n\t0x07,        \n\tUSB_DT_ENDPOINT,  \n\t0x81,        \n\t0x03,        \n\t\t     \n\t(USB_MAXCHILDREN + 1 + 7) / 8, 0x00,\n\t0x0c,        \n\n\t \n\t0x06,         \n\tUSB_DT_SS_ENDPOINT_COMP,  \n\t\t      \n\t0x00,         \n\t0x00,         \n\t0x02, 0x00    \n};\n\n \n#define USB_AUTHORIZE_WIRED\t-1\n#define USB_AUTHORIZE_NONE\t0\n#define USB_AUTHORIZE_ALL\t1\n#define USB_AUTHORIZE_INTERNAL\t2\n\nstatic int authorized_default = USB_AUTHORIZE_WIRED;\nmodule_param(authorized_default, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(authorized_default,\n\t\t\"Default USB device authorization: 0 is not authorized, 1 is \"\n\t\t\"authorized, 2 is authorized for internal devices, -1 is \"\n\t\t\"authorized (default, same as 1)\");\n \n\n \nstatic unsigned\nascii2desc(char const *s, u8 *buf, unsigned len)\n{\n\tunsigned n, t = 2 + 2*strlen(s);\n\n\tif (t > 254)\n\t\tt = 254;\t \n\tif (len > t)\n\t\tlen = t;\n\n\tt += USB_DT_STRING << 8;\t \n\n\tn = len;\n\twhile (n--) {\n\t\t*buf++ = t;\n\t\tif (!n--)\n\t\t\tbreak;\n\t\t*buf++ = t >> 8;\n\t\tt = (unsigned char)*s++;\n\t}\n\treturn len;\n}\n\n \nstatic unsigned\nrh_string(int id, struct usb_hcd const *hcd, u8 *data, unsigned len)\n{\n\tchar buf[100];\n\tchar const *s;\n\tstatic char const langids[4] = {4, USB_DT_STRING, 0x09, 0x04};\n\n\t \n\tswitch (id) {\n\tcase 0:\n\t\t \n\t\t \n\t\ts = hcd->self.bus_name;\n\t\tbreak;\n\tcase 2:\n\t\t \n\t\ts = hcd->product_desc;\n\t\tbreak;\n\tcase 3:\n\t\t \n\t\tsnprintf (buf, sizeof buf, \"%s %s %s\", init_utsname()->sysname,\n\t\t\tinit_utsname()->release, hcd->driver->description);\n\t\ts = buf;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn 0;\n\t}\n\n\treturn ascii2desc(s, data, len);\n}\n\n\n \nstatic int rh_call_control (struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct usb_ctrlrequest *cmd;\n\tu16\t\ttypeReq, wValue, wIndex, wLength;\n\tu8\t\t*ubuf = urb->transfer_buffer;\n\tunsigned\tlen = 0;\n\tint\t\tstatus;\n\tu8\t\tpatch_wakeup = 0;\n\tu8\t\tpatch_protocol = 0;\n\tu16\t\ttbuf_size;\n\tu8\t\t*tbuf = NULL;\n\tconst u8\t*bufp;\n\n\tmight_sleep();\n\n\tspin_lock_irq(&hcd_root_hub_lock);\n\tstatus = usb_hcd_link_urb_to_ep(hcd, urb);\n\tspin_unlock_irq(&hcd_root_hub_lock);\n\tif (status)\n\t\treturn status;\n\turb->hcpriv = hcd;\t \n\n\tcmd = (struct usb_ctrlrequest *) urb->setup_packet;\n\ttypeReq  = (cmd->bRequestType << 8) | cmd->bRequest;\n\twValue   = le16_to_cpu (cmd->wValue);\n\twIndex   = le16_to_cpu (cmd->wIndex);\n\twLength  = le16_to_cpu (cmd->wLength);\n\n\tif (wLength > urb->transfer_buffer_length)\n\t\tgoto error;\n\n\t \n\ttbuf_size =  max_t(u16, sizeof(struct usb_hub_descriptor), wLength);\n\ttbuf = kzalloc(tbuf_size, GFP_KERNEL);\n\tif (!tbuf) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_alloc;\n\t}\n\n\tbufp = tbuf;\n\n\n\turb->actual_length = 0;\n\tswitch (typeReq) {\n\n\t \n\n\t \n\n\tcase DeviceRequest | USB_REQ_GET_STATUS:\n\t\ttbuf[0] = (device_may_wakeup(&hcd->self.root_hub->dev)\n\t\t\t\t\t<< USB_DEVICE_REMOTE_WAKEUP)\n\t\t\t\t| (1 << USB_DEVICE_SELF_POWERED);\n\t\ttbuf[1] = 0;\n\t\tlen = 2;\n\t\tbreak;\n\tcase DeviceOutRequest | USB_REQ_CLEAR_FEATURE:\n\t\tif (wValue == USB_DEVICE_REMOTE_WAKEUP)\n\t\t\tdevice_set_wakeup_enable(&hcd->self.root_hub->dev, 0);\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\tcase DeviceOutRequest | USB_REQ_SET_FEATURE:\n\t\tif (device_can_wakeup(&hcd->self.root_hub->dev)\n\t\t\t\t&& wValue == USB_DEVICE_REMOTE_WAKEUP)\n\t\t\tdevice_set_wakeup_enable(&hcd->self.root_hub->dev, 1);\n\t\telse\n\t\t\tgoto error;\n\t\tbreak;\n\tcase DeviceRequest | USB_REQ_GET_CONFIGURATION:\n\t\ttbuf[0] = 1;\n\t\tlen = 1;\n\t\tfallthrough;\n\tcase DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\t\tbreak;\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\tswitch (wValue & 0xff00) {\n\t\tcase USB_DT_DEVICE << 8:\n\t\t\tswitch (hcd->speed) {\n\t\t\tcase HCD_USB32:\n\t\t\tcase HCD_USB31:\n\t\t\t\tbufp = usb31_rh_dev_descriptor;\n\t\t\t\tbreak;\n\t\t\tcase HCD_USB3:\n\t\t\t\tbufp = usb3_rh_dev_descriptor;\n\t\t\t\tbreak;\n\t\t\tcase HCD_USB2:\n\t\t\t\tbufp = usb2_rh_dev_descriptor;\n\t\t\t\tbreak;\n\t\t\tcase HCD_USB11:\n\t\t\t\tbufp = usb11_rh_dev_descriptor;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tlen = 18;\n\t\t\tif (hcd->has_tt)\n\t\t\t\tpatch_protocol = 1;\n\t\t\tbreak;\n\t\tcase USB_DT_CONFIG << 8:\n\t\t\tswitch (hcd->speed) {\n\t\t\tcase HCD_USB32:\n\t\t\tcase HCD_USB31:\n\t\t\tcase HCD_USB3:\n\t\t\t\tbufp = ss_rh_config_descriptor;\n\t\t\t\tlen = sizeof ss_rh_config_descriptor;\n\t\t\t\tbreak;\n\t\t\tcase HCD_USB2:\n\t\t\t\tbufp = hs_rh_config_descriptor;\n\t\t\t\tlen = sizeof hs_rh_config_descriptor;\n\t\t\t\tbreak;\n\t\t\tcase HCD_USB11:\n\t\t\t\tbufp = fs_rh_config_descriptor;\n\t\t\t\tlen = sizeof fs_rh_config_descriptor;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (device_can_wakeup(&hcd->self.root_hub->dev))\n\t\t\t\tpatch_wakeup = 1;\n\t\t\tbreak;\n\t\tcase USB_DT_STRING << 8:\n\t\t\tif ((wValue & 0xff) < 4)\n\t\t\t\turb->actual_length = rh_string(wValue & 0xff,\n\t\t\t\t\t\thcd, ubuf, wLength);\n\t\t\telse  \n\t\t\t\tgoto error;\n\t\t\tbreak;\n\t\tcase USB_DT_BOS << 8:\n\t\t\tgoto nongeneric;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase DeviceRequest | USB_REQ_GET_INTERFACE:\n\t\ttbuf[0] = 0;\n\t\tlen = 1;\n\t\tfallthrough;\n\tcase DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\t\tbreak;\n\tcase DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\t\t \n\t\tdev_dbg (hcd->self.controller, \"root hub device address %d\\n\",\n\t\t\twValue);\n\t\tbreak;\n\n\t \n\n\t \n\n\tcase EndpointRequest | USB_REQ_GET_STATUS:\n\t\t \n\t\ttbuf[0] = 0;\n\t\ttbuf[1] = 0;\n\t\tlen = 2;\n\t\tfallthrough;\n\tcase EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\tcase EndpointOutRequest | USB_REQ_SET_FEATURE:\n\t\tdev_dbg (hcd->self.controller, \"no endpoint features yet\\n\");\n\t\tbreak;\n\n\t \n\n\tdefault:\nnongeneric:\n\t\t \n\t\tswitch (typeReq) {\n\t\tcase GetHubStatus:\n\t\t\tlen = 4;\n\t\t\tbreak;\n\t\tcase GetPortStatus:\n\t\t\tif (wValue == HUB_PORT_STATUS)\n\t\t\t\tlen = 4;\n\t\t\telse\n\t\t\t\t \n\t\t\t\tlen = 8;\n\t\t\tbreak;\n\t\tcase GetHubDescriptor:\n\t\t\tlen = sizeof (struct usb_hub_descriptor);\n\t\t\tbreak;\n\t\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t\tstatus = hcd->driver->hub_control (hcd,\n\t\t\ttypeReq, wValue, wIndex,\n\t\t\ttbuf, wLength);\n\n\t\tif (typeReq == GetHubDescriptor)\n\t\t\tusb_hub_adjust_deviceremovable(hcd->self.root_hub,\n\t\t\t\t(struct usb_hub_descriptor *)tbuf);\n\t\tbreak;\nerror:\n\t\t \n\t\tstatus = -EPIPE;\n\t}\n\n\tif (status < 0) {\n\t\tlen = 0;\n\t\tif (status != -EPIPE) {\n\t\t\tdev_dbg (hcd->self.controller,\n\t\t\t\t\"CTRL: TypeReq=0x%x val=0x%x \"\n\t\t\t\t\"idx=0x%x len=%d ==> %d\\n\",\n\t\t\t\ttypeReq, wValue, wIndex,\n\t\t\t\twLength, status);\n\t\t}\n\t} else if (status > 0) {\n\t\t \n\t\tlen = status;\n\t\tstatus = 0;\n\t}\n\tif (len) {\n\t\tif (urb->transfer_buffer_length < len)\n\t\t\tlen = urb->transfer_buffer_length;\n\t\turb->actual_length = len;\n\t\t \n\t\tmemcpy (ubuf, bufp, len);\n\n\t\t \n\t\tif (patch_wakeup &&\n\t\t\t\tlen > offsetof (struct usb_config_descriptor,\n\t\t\t\t\t\tbmAttributes))\n\t\t\t((struct usb_config_descriptor *)ubuf)->bmAttributes\n\t\t\t\t|= USB_CONFIG_ATT_WAKEUP;\n\n\t\t \n\t\tif (patch_protocol &&\n\t\t\t\tlen > offsetof(struct usb_device_descriptor,\n\t\t\t\t\t\tbDeviceProtocol))\n\t\t\t((struct usb_device_descriptor *) ubuf)->\n\t\t\t\tbDeviceProtocol = USB_HUB_PR_HS_SINGLE_TT;\n\t}\n\n\tkfree(tbuf);\n err_alloc:\n\n\t \n\tspin_lock_irq(&hcd_root_hub_lock);\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\tusb_hcd_giveback_urb(hcd, urb, status);\n\tspin_unlock_irq(&hcd_root_hub_lock);\n\treturn 0;\n}\n\n \n\n \nvoid usb_hcd_poll_rh_status(struct usb_hcd *hcd)\n{\n\tstruct urb\t*urb;\n\tint\t\tlength;\n\tint\t\tstatus;\n\tunsigned long\tflags;\n\tchar\t\tbuffer[6];\t \n\n\tif (unlikely(!hcd->rh_pollable))\n\t\treturn;\n\tif (!hcd->uses_new_polling && !hcd->status_urb)\n\t\treturn;\n\n\tlength = hcd->driver->hub_status_data(hcd, buffer);\n\tif (length > 0) {\n\n\t\t \n\t\tspin_lock_irqsave(&hcd_root_hub_lock, flags);\n\t\turb = hcd->status_urb;\n\t\tif (urb) {\n\t\t\tclear_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\n\t\t\thcd->status_urb = NULL;\n\t\t\tif (urb->transfer_buffer_length >= length) {\n\t\t\t\tstatus = 0;\n\t\t\t} else {\n\t\t\t\tstatus = -EOVERFLOW;\n\t\t\t\tlength = urb->transfer_buffer_length;\n\t\t\t}\n\t\t\turb->actual_length = length;\n\t\t\tmemcpy(urb->transfer_buffer, buffer, length);\n\n\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t\t} else {\n\t\t\tlength = 0;\n\t\t\tset_bit(HCD_FLAG_POLL_PENDING, &hcd->flags);\n\t\t}\n\t\tspin_unlock_irqrestore(&hcd_root_hub_lock, flags);\n\t}\n\n\t \n\tif (hcd->uses_new_polling ? HCD_POLL_RH(hcd) :\n\t\t\t(length == 0 && hcd->status_urb != NULL))\n\t\tmod_timer (&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));\n}\nEXPORT_SYMBOL_GPL(usb_hcd_poll_rh_status);\n\n \nstatic void rh_timer_func (struct timer_list *t)\n{\n\tstruct usb_hcd *_hcd = from_timer(_hcd, t, rh_timer);\n\n\tusb_hcd_poll_rh_status(_hcd);\n}\n\n \n\nstatic int rh_queue_status (struct usb_hcd *hcd, struct urb *urb)\n{\n\tint\t\tretval;\n\tunsigned long\tflags;\n\tunsigned\tlen = 1 + (urb->dev->maxchild / 8);\n\n\tspin_lock_irqsave (&hcd_root_hub_lock, flags);\n\tif (hcd->status_urb || urb->transfer_buffer_length < len) {\n\t\tdev_dbg (hcd->self.controller, \"not queuing rh status urb\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto done;\n\n\thcd->status_urb = urb;\n\turb->hcpriv = hcd;\t \n\tif (!hcd->uses_new_polling)\n\t\tmod_timer(&hcd->rh_timer, (jiffies/(HZ/4) + 1) * (HZ/4));\n\n\t \n\telse if (HCD_POLL_PENDING(hcd))\n\t\tmod_timer(&hcd->rh_timer, jiffies);\n\tretval = 0;\n done:\n\tspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\n\treturn retval;\n}\n\nstatic int rh_urb_enqueue (struct usb_hcd *hcd, struct urb *urb)\n{\n\tif (usb_endpoint_xfer_int(&urb->ep->desc))\n\t\treturn rh_queue_status (hcd, urb);\n\tif (usb_endpoint_xfer_control(&urb->ep->desc))\n\t\treturn rh_call_control (hcd, urb);\n\treturn -EINVAL;\n}\n\n \n\n \nstatic int usb_rh_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tunsigned long\tflags;\n\tint\t\trc;\n\n\tspin_lock_irqsave(&hcd_root_hub_lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tif (usb_endpoint_num(&urb->ep->desc) == 0) {\t \n\t\t;\t \n\n\t} else {\t\t\t\t \n\t\tif (!hcd->uses_new_polling)\n\t\t\tdel_timer (&hcd->rh_timer);\n\t\tif (urb == hcd->status_urb) {\n\t\t\thcd->status_urb = NULL;\n\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t\t}\n\t}\n done:\n\tspin_unlock_irqrestore(&hcd_root_hub_lock, flags);\n\treturn rc;\n}\n\n\n \n\n \nstatic void usb_bus_init (struct usb_bus *bus)\n{\n\tmemset (&bus->devmap, 0, sizeof(struct usb_devmap));\n\n\tbus->devnum_next = 1;\n\n\tbus->root_hub = NULL;\n\tbus->busnum = -1;\n\tbus->bandwidth_allocated = 0;\n\tbus->bandwidth_int_reqs  = 0;\n\tbus->bandwidth_isoc_reqs = 0;\n\tmutex_init(&bus->devnum_next_mutex);\n}\n\n \n\n \nstatic int usb_register_bus(struct usb_bus *bus)\n{\n\tint result = -E2BIG;\n\tint busnum;\n\n\tmutex_lock(&usb_bus_idr_lock);\n\tbusnum = idr_alloc(&usb_bus_idr, bus, 1, USB_MAXBUS, GFP_KERNEL);\n\tif (busnum < 0) {\n\t\tpr_err(\"%s: failed to get bus number\\n\", usbcore_name);\n\t\tgoto error_find_busnum;\n\t}\n\tbus->busnum = busnum;\n\tmutex_unlock(&usb_bus_idr_lock);\n\n\tusb_notify_add_bus(bus);\n\n\tdev_info (bus->controller, \"new USB bus registered, assigned bus \"\n\t\t  \"number %d\\n\", bus->busnum);\n\treturn 0;\n\nerror_find_busnum:\n\tmutex_unlock(&usb_bus_idr_lock);\n\treturn result;\n}\n\n \nstatic void usb_deregister_bus (struct usb_bus *bus)\n{\n\tdev_info (bus->controller, \"USB bus %d deregistered\\n\", bus->busnum);\n\n\t \n\tmutex_lock(&usb_bus_idr_lock);\n\tidr_remove(&usb_bus_idr, bus->busnum);\n\tmutex_unlock(&usb_bus_idr_lock);\n\n\tusb_notify_remove_bus(bus);\n}\n\n \nstatic int register_root_hub(struct usb_hcd *hcd)\n{\n\tstruct device *parent_dev = hcd->self.controller;\n\tstruct usb_device *usb_dev = hcd->self.root_hub;\n\tstruct usb_device_descriptor *descr;\n\tconst int devnum = 1;\n\tint retval;\n\n\tusb_dev->devnum = devnum;\n\tusb_dev->bus->devnum_next = devnum + 1;\n\tset_bit (devnum, usb_dev->bus->devmap.devicemap);\n\tusb_set_device_state(usb_dev, USB_STATE_ADDRESS);\n\n\tmutex_lock(&usb_bus_idr_lock);\n\n\tusb_dev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\tdescr = usb_get_device_descriptor(usb_dev);\n\tif (IS_ERR(descr)) {\n\t\tretval = PTR_ERR(descr);\n\t\tmutex_unlock(&usb_bus_idr_lock);\n\t\tdev_dbg (parent_dev, \"can't read %s device descriptor %d\\n\",\n\t\t\t\tdev_name(&usb_dev->dev), retval);\n\t\treturn retval;\n\t}\n\tusb_dev->descriptor = *descr;\n\tkfree(descr);\n\n\tif (le16_to_cpu(usb_dev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(usb_dev);\n\t\tif (!retval) {\n\t\t\tusb_dev->lpm_capable = usb_device_supports_lpm(usb_dev);\n\t\t} else if (usb_dev->speed >= USB_SPEED_SUPER) {\n\t\t\tmutex_unlock(&usb_bus_idr_lock);\n\t\t\tdev_dbg(parent_dev, \"can't read %s bos descriptor %d\\n\",\n\t\t\t\t\tdev_name(&usb_dev->dev), retval);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\tretval = usb_new_device (usb_dev);\n\tif (retval) {\n\t\tdev_err (parent_dev, \"can't register root hub for %s, %d\\n\",\n\t\t\t\tdev_name(&usb_dev->dev), retval);\n\t} else {\n\t\tspin_lock_irq (&hcd_root_hub_lock);\n\t\thcd->rh_registered = 1;\n\t\tspin_unlock_irq (&hcd_root_hub_lock);\n\n\t\t \n\t\tif (HCD_DEAD(hcd))\n\t\t\tusb_hc_died (hcd);\t \n\t}\n\tmutex_unlock(&usb_bus_idr_lock);\n\n\treturn retval;\n}\n\n \nvoid usb_hcd_start_port_resume(struct usb_bus *bus, int portnum)\n{\n\tunsigned bit = 1 << portnum;\n\n\tif (!(bus->resuming_ports & bit)) {\n\t\tbus->resuming_ports |= bit;\n\t\tpm_runtime_get_noresume(&bus->root_hub->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_hcd_start_port_resume);\n\n \nvoid usb_hcd_end_port_resume(struct usb_bus *bus, int portnum)\n{\n\tunsigned bit = 1 << portnum;\n\n\tif (bus->resuming_ports & bit) {\n\t\tbus->resuming_ports &= ~bit;\n\t\tpm_runtime_put_noidle(&bus->root_hub->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_hcd_end_port_resume);\n\n \n\n \nlong usb_calc_bus_time (int speed, int is_input, int isoc, int bytecount)\n{\n\tunsigned long\ttmp;\n\n\tswitch (speed) {\n\tcase USB_SPEED_LOW: \t \n\t\tif (is_input) {\n\t\t\ttmp = (67667L * (31L + 10L * BitTime (bytecount))) / 1000L;\n\t\t\treturn 64060L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp;\n\t\t} else {\n\t\t\ttmp = (66700L * (31L + 10L * BitTime (bytecount))) / 1000L;\n\t\t\treturn 64107L + (2 * BW_HUB_LS_SETUP) + BW_HOST_DELAY + tmp;\n\t\t}\n\tcase USB_SPEED_FULL:\t \n\t\tif (isoc) {\n\t\t\ttmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;\n\t\t\treturn ((is_input) ? 7268L : 6265L) + BW_HOST_DELAY + tmp;\n\t\t} else {\n\t\t\ttmp = (8354L * (31L + 10L * BitTime (bytecount))) / 1000L;\n\t\t\treturn 9107L + BW_HOST_DELAY + tmp;\n\t\t}\n\tcase USB_SPEED_HIGH:\t \n\t\t \n\t\tif (isoc)\n\t\t\ttmp = HS_NSECS_ISO (bytecount);\n\t\telse\n\t\t\ttmp = HS_NSECS (bytecount);\n\t\treturn tmp;\n\tdefault:\n\t\tpr_debug (\"%s: bogus device speed!\\n\", usbcore_name);\n\t\treturn -1;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_calc_bus_time);\n\n\n \n\n \n\n \n\n \nint usb_hcd_link_urb_to_ep(struct usb_hcd *hcd, struct urb *urb)\n{\n\tint\t\trc = 0;\n\n\tspin_lock(&hcd_urb_list_lock);\n\n\t \n\tif (unlikely(atomic_read(&urb->reject))) {\n\t\trc = -EPERM;\n\t\tgoto done;\n\t}\n\n\tif (unlikely(!urb->ep->enabled)) {\n\t\trc = -ENOENT;\n\t\tgoto done;\n\t}\n\n\tif (unlikely(!urb->dev->can_submit)) {\n\t\trc = -EHOSTUNREACH;\n\t\tgoto done;\n\t}\n\n\t \n\tif (HCD_RH_RUNNING(hcd)) {\n\t\turb->unlinked = 0;\n\t\tlist_add_tail(&urb->urb_list, &urb->ep->urb_list);\n\t} else {\n\t\trc = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n done:\n\tspin_unlock(&hcd_urb_list_lock);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_link_urb_to_ep);\n\n \nint usb_hcd_check_unlink_urb(struct usb_hcd *hcd, struct urb *urb,\n\t\tint status)\n{\n\tstruct list_head\t*tmp;\n\n\t \n\tlist_for_each(tmp, &urb->ep->urb_list) {\n\t\tif (tmp == &urb->urb_list)\n\t\t\tbreak;\n\t}\n\tif (tmp != &urb->urb_list)\n\t\treturn -EIDRM;\n\n\t \n\tif (urb->unlinked)\n\t\treturn -EBUSY;\n\turb->unlinked = status;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_check_unlink_urb);\n\n \nvoid usb_hcd_unlink_urb_from_ep(struct usb_hcd *hcd, struct urb *urb)\n{\n\t \n\tspin_lock(&hcd_urb_list_lock);\n\tlist_del_init(&urb->urb_list);\n\tspin_unlock(&hcd_urb_list_lock);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_unlink_urb_from_ep);\n\n \n\nstatic int hcd_alloc_coherent(struct usb_bus *bus,\n\t\t\t      gfp_t mem_flags, dma_addr_t *dma_handle,\n\t\t\t      void **vaddr_handle, size_t size,\n\t\t\t      enum dma_data_direction dir)\n{\n\tunsigned char *vaddr;\n\n\tif (*vaddr_handle == NULL) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EFAULT;\n\t}\n\n\tvaddr = hcd_buffer_alloc(bus, size + sizeof(unsigned long),\n\t\t\t\t mem_flags, dma_handle);\n\tif (!vaddr)\n\t\treturn -ENOMEM;\n\n\t \n\tput_unaligned((unsigned long)*vaddr_handle,\n\t\t      (unsigned long *)(vaddr + size));\n\n\tif (dir == DMA_TO_DEVICE)\n\t\tmemcpy(vaddr, *vaddr_handle, size);\n\n\t*vaddr_handle = vaddr;\n\treturn 0;\n}\n\nstatic void hcd_free_coherent(struct usb_bus *bus, dma_addr_t *dma_handle,\n\t\t\t      void **vaddr_handle, size_t size,\n\t\t\t      enum dma_data_direction dir)\n{\n\tunsigned char *vaddr = *vaddr_handle;\n\n\tvaddr = (void *)get_unaligned((unsigned long *)(vaddr + size));\n\n\tif (dir == DMA_FROM_DEVICE)\n\t\tmemcpy(vaddr, *vaddr_handle, size);\n\n\thcd_buffer_free(bus, size + sizeof(vaddr), *vaddr_handle, *dma_handle);\n\n\t*vaddr_handle = vaddr;\n\t*dma_handle = 0;\n}\n\nvoid usb_hcd_unmap_urb_setup_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tif (IS_ENABLED(CONFIG_HAS_DMA) &&\n\t    (urb->transfer_flags & URB_SETUP_MAP_SINGLE))\n\t\tdma_unmap_single(hcd->self.sysdev,\n\t\t\t\turb->setup_dma,\n\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\tDMA_TO_DEVICE);\n\telse if (urb->transfer_flags & URB_SETUP_MAP_LOCAL)\n\t\thcd_free_coherent(urb->dev->bus,\n\t\t\t\t&urb->setup_dma,\n\t\t\t\t(void **) &urb->setup_packet,\n\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\tDMA_TO_DEVICE);\n\n\t \n\turb->transfer_flags &= ~(URB_SETUP_MAP_SINGLE | URB_SETUP_MAP_LOCAL);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_unmap_urb_setup_for_dma);\n\nstatic void unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tif (hcd->driver->unmap_urb_for_dma)\n\t\thcd->driver->unmap_urb_for_dma(hcd, urb);\n\telse\n\t\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n}\n\nvoid usb_hcd_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tenum dma_data_direction dir;\n\n\tusb_hcd_unmap_urb_setup_for_dma(hcd, urb);\n\n\tdir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tif (IS_ENABLED(CONFIG_HAS_DMA) &&\n\t    (urb->transfer_flags & URB_DMA_MAP_SG))\n\t\tdma_unmap_sg(hcd->self.sysdev,\n\t\t\t\turb->sg,\n\t\t\t\turb->num_sgs,\n\t\t\t\tdir);\n\telse if (IS_ENABLED(CONFIG_HAS_DMA) &&\n\t\t (urb->transfer_flags & URB_DMA_MAP_PAGE))\n\t\tdma_unmap_page(hcd->self.sysdev,\n\t\t\t\turb->transfer_dma,\n\t\t\t\turb->transfer_buffer_length,\n\t\t\t\tdir);\n\telse if (IS_ENABLED(CONFIG_HAS_DMA) &&\n\t\t (urb->transfer_flags & URB_DMA_MAP_SINGLE))\n\t\tdma_unmap_single(hcd->self.sysdev,\n\t\t\t\turb->transfer_dma,\n\t\t\t\turb->transfer_buffer_length,\n\t\t\t\tdir);\n\telse if (urb->transfer_flags & URB_MAP_LOCAL)\n\t\thcd_free_coherent(urb->dev->bus,\n\t\t\t\t&urb->transfer_dma,\n\t\t\t\t&urb->transfer_buffer,\n\t\t\t\turb->transfer_buffer_length,\n\t\t\t\tdir);\n\n\t \n\turb->transfer_flags &= ~(URB_DMA_MAP_SG | URB_DMA_MAP_PAGE |\n\t\t\tURB_DMA_MAP_SINGLE | URB_MAP_LOCAL);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_unmap_urb_for_dma);\n\nstatic int map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t   gfp_t mem_flags)\n{\n\tif (hcd->driver->map_urb_for_dma)\n\t\treturn hcd->driver->map_urb_for_dma(hcd, urb, mem_flags);\n\telse\n\t\treturn usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n}\n\nint usb_hcd_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t    gfp_t mem_flags)\n{\n\tenum dma_data_direction dir;\n\tint ret = 0;\n\n\t \n\n\tif (usb_endpoint_xfer_control(&urb->ep->desc)) {\n\t\tif (hcd->self.uses_pio_for_control)\n\t\t\treturn ret;\n\t\tif (hcd->localmem_pool) {\n\t\t\tret = hcd_alloc_coherent(\n\t\t\t\t\turb->dev->bus, mem_flags,\n\t\t\t\t\t&urb->setup_dma,\n\t\t\t\t\t(void **)&urb->setup_packet,\n\t\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\turb->transfer_flags |= URB_SETUP_MAP_LOCAL;\n\t\t} else if (hcd_uses_dma(hcd)) {\n\t\t\tif (object_is_on_stack(urb->setup_packet)) {\n\t\t\t\tWARN_ONCE(1, \"setup packet is on stack\\n\");\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\n\t\t\turb->setup_dma = dma_map_single(\n\t\t\t\t\thcd->self.sysdev,\n\t\t\t\t\turb->setup_packet,\n\t\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\tif (dma_mapping_error(hcd->self.sysdev,\n\t\t\t\t\t\turb->setup_dma))\n\t\t\t\treturn -EAGAIN;\n\t\t\turb->transfer_flags |= URB_SETUP_MAP_SINGLE;\n\t\t}\n\t}\n\n\tdir = usb_urb_dir_in(urb) ? DMA_FROM_DEVICE : DMA_TO_DEVICE;\n\tif (urb->transfer_buffer_length != 0\n\t    && !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)) {\n\t\tif (hcd->localmem_pool) {\n\t\t\tret = hcd_alloc_coherent(\n\t\t\t\t\turb->dev->bus, mem_flags,\n\t\t\t\t\t&urb->transfer_dma,\n\t\t\t\t\t&urb->transfer_buffer,\n\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\tdir);\n\t\t\tif (ret == 0)\n\t\t\t\turb->transfer_flags |= URB_MAP_LOCAL;\n\t\t} else if (hcd_uses_dma(hcd)) {\n\t\t\tif (urb->num_sgs) {\n\t\t\t\tint n;\n\n\t\t\t\t \n\t\t\t\tif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\n\t\t\t\tn = dma_map_sg(\n\t\t\t\t\t\thcd->self.sysdev,\n\t\t\t\t\t\turb->sg,\n\t\t\t\t\t\turb->num_sgs,\n\t\t\t\t\t\tdir);\n\t\t\t\tif (!n)\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\telse\n\t\t\t\t\turb->transfer_flags |= URB_DMA_MAP_SG;\n\t\t\t\turb->num_mapped_sgs = n;\n\t\t\t\tif (n != urb->num_sgs)\n\t\t\t\t\turb->transfer_flags |=\n\t\t\t\t\t\t\tURB_DMA_SG_COMBINED;\n\t\t\t} else if (urb->sg) {\n\t\t\t\tstruct scatterlist *sg = urb->sg;\n\t\t\t\turb->transfer_dma = dma_map_page(\n\t\t\t\t\t\thcd->self.sysdev,\n\t\t\t\t\t\tsg_page(sg),\n\t\t\t\t\t\tsg->offset,\n\t\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\t\tdir);\n\t\t\t\tif (dma_mapping_error(hcd->self.sysdev,\n\t\t\t\t\t\turb->transfer_dma))\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\telse\n\t\t\t\t\turb->transfer_flags |= URB_DMA_MAP_PAGE;\n\t\t\t} else if (object_is_on_stack(urb->transfer_buffer)) {\n\t\t\t\tWARN_ONCE(1, \"transfer buffer is on stack\\n\");\n\t\t\t\tret = -EAGAIN;\n\t\t\t} else {\n\t\t\t\turb->transfer_dma = dma_map_single(\n\t\t\t\t\t\thcd->self.sysdev,\n\t\t\t\t\t\turb->transfer_buffer,\n\t\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\t\tdir);\n\t\t\t\tif (dma_mapping_error(hcd->self.sysdev,\n\t\t\t\t\t\turb->transfer_dma))\n\t\t\t\t\tret = -EAGAIN;\n\t\t\t\telse\n\t\t\t\t\turb->transfer_flags |= URB_DMA_MAP_SINGLE;\n\t\t\t}\n\t\t}\n\t\tif (ret && (urb->transfer_flags & (URB_SETUP_MAP_SINGLE |\n\t\t\t\tURB_SETUP_MAP_LOCAL)))\n\t\t\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_map_urb_for_dma);\n\n \n\n \nint usb_hcd_submit_urb (struct urb *urb, gfp_t mem_flags)\n{\n\tint\t\t\tstatus;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(urb->dev->bus);\n\n\t \n\tusb_get_urb(urb);\n\tatomic_inc(&urb->use_count);\n\tatomic_inc(&urb->dev->urbnum);\n\tusbmon_urb_submit(&hcd->self, urb);\n\n\t \n\n\tif (is_root_hub(urb->dev)) {\n\t\tstatus = rh_urb_enqueue(hcd, urb);\n\t} else {\n\t\tstatus = map_urb_for_dma(hcd, urb, mem_flags);\n\t\tif (likely(status == 0)) {\n\t\t\tstatus = hcd->driver->urb_enqueue(hcd, urb, mem_flags);\n\t\t\tif (unlikely(status))\n\t\t\t\tunmap_urb_for_dma(hcd, urb);\n\t\t}\n\t}\n\n\tif (unlikely(status)) {\n\t\tusbmon_urb_submit_error(&hcd->self, urb, status);\n\t\turb->hcpriv = NULL;\n\t\tINIT_LIST_HEAD(&urb->urb_list);\n\t\tatomic_dec(&urb->use_count);\n\t\t \n\t\tsmp_mb__after_atomic();\n\n\t\tatomic_dec(&urb->dev->urbnum);\n\t\tif (atomic_read(&urb->reject))\n\t\t\twake_up(&usb_kill_urb_queue);\n\t\tusb_put_urb(urb);\n\t}\n\treturn status;\n}\n\n \n\n \nstatic int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tint\t\tvalue;\n\n\tif (is_root_hub(urb->dev))\n\t\tvalue = usb_rh_urb_dequeue(hcd, urb, status);\n\telse {\n\n\t\t \n\t\tvalue = hcd->driver->urb_dequeue(hcd, urb, status);\n\t}\n\treturn value;\n}\n\n \nint usb_hcd_unlink_urb (struct urb *urb, int status)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tretval = -EIDRM;\n\tunsigned long\t\tflags;\n\n\t \n\tspin_lock_irqsave(&hcd_urb_unlink_lock, flags);\n\tif (atomic_read(&urb->use_count) > 0) {\n\t\tretval = 0;\n\t\tusb_get_dev(udev);\n\t}\n\tspin_unlock_irqrestore(&hcd_urb_unlink_lock, flags);\n\tif (retval == 0) {\n\t\thcd = bus_to_hcd(urb->dev->bus);\n\t\tretval = unlink1(hcd, urb, status);\n\t\tif (retval == 0)\n\t\t\tretval = -EINPROGRESS;\n\t\telse if (retval != -EIDRM && retval != -EBUSY)\n\t\t\tdev_dbg(&udev->dev, \"hcd_unlink_urb %pK fail %d\\n\",\n\t\t\t\t\turb, retval);\n\t\tusb_put_dev(udev);\n\t}\n\treturn retval;\n}\n\n \n\nstatic void __usb_hcd_giveback_urb(struct urb *urb)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(urb->dev->bus);\n\tstruct usb_anchor *anchor = urb->anchor;\n\tint status = urb->unlinked;\n\n\turb->hcpriv = NULL;\n\tif (unlikely((urb->transfer_flags & URB_SHORT_NOT_OK) &&\n\t    urb->actual_length < urb->transfer_buffer_length &&\n\t    !status))\n\t\tstatus = -EREMOTEIO;\n\n\tunmap_urb_for_dma(hcd, urb);\n\tusbmon_urb_complete(&hcd->self, urb, status);\n\tusb_anchor_suspend_wakeups(anchor);\n\tusb_unanchor_urb(urb);\n\tif (likely(status == 0))\n\t\tusb_led_activity(USB_LED_EVENT_HOST);\n\n\t \n\turb->status = status;\n\t \n\tkcov_remote_start_usb_softirq((u64)urb->dev->bus->busnum);\n\turb->complete(urb);\n\tkcov_remote_stop_softirq();\n\n\tusb_anchor_resume_wakeups(anchor);\n\tatomic_dec(&urb->use_count);\n\t \n\tsmp_mb__after_atomic();\n\n\tif (unlikely(atomic_read(&urb->reject)))\n\t\twake_up(&usb_kill_urb_queue);\n\tusb_put_urb(urb);\n}\n\nstatic void usb_giveback_urb_bh(struct tasklet_struct *t)\n{\n\tstruct giveback_urb_bh *bh = from_tasklet(bh, t, bh);\n\tstruct list_head local_list;\n\n\tspin_lock_irq(&bh->lock);\n\tbh->running = true;\n\tlist_replace_init(&bh->head, &local_list);\n\tspin_unlock_irq(&bh->lock);\n\n\twhile (!list_empty(&local_list)) {\n\t\tstruct urb *urb;\n\n\t\turb = list_entry(local_list.next, struct urb, urb_list);\n\t\tlist_del_init(&urb->urb_list);\n\t\tbh->completing_ep = urb->ep;\n\t\t__usb_hcd_giveback_urb(urb);\n\t\tbh->completing_ep = NULL;\n\t}\n\n\t \n\tspin_lock_irq(&bh->lock);\n\tif (!list_empty(&bh->head)) {\n\t\tif (bh->high_prio)\n\t\t\ttasklet_hi_schedule(&bh->bh);\n\t\telse\n\t\t\ttasklet_schedule(&bh->bh);\n\t}\n\tbh->running = false;\n\tspin_unlock_irq(&bh->lock);\n}\n\n \nvoid usb_hcd_giveback_urb(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct giveback_urb_bh *bh;\n\tbool running;\n\n\t \n\tif (likely(!urb->unlinked))\n\t\turb->unlinked = status;\n\n\tif (!hcd_giveback_urb_in_bh(hcd) && !is_root_hub(urb->dev)) {\n\t\t__usb_hcd_giveback_urb(urb);\n\t\treturn;\n\t}\n\n\tif (usb_pipeisoc(urb->pipe) || usb_pipeint(urb->pipe))\n\t\tbh = &hcd->high_prio_bh;\n\telse\n\t\tbh = &hcd->low_prio_bh;\n\n\tspin_lock(&bh->lock);\n\tlist_add_tail(&urb->urb_list, &bh->head);\n\trunning = bh->running;\n\tspin_unlock(&bh->lock);\n\n\tif (running)\n\t\t;\n\telse if (bh->high_prio)\n\t\ttasklet_hi_schedule(&bh->bh);\n\telse\n\t\ttasklet_schedule(&bh->bh);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_giveback_urb);\n\n \n\n \nvoid usb_hcd_flush_endpoint(struct usb_device *udev,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct urb\t\t*urb;\n\n\tif (!ep)\n\t\treturn;\n\tmight_sleep();\n\thcd = bus_to_hcd(udev->bus);\n\n\t \n\tspin_lock_irq(&hcd_urb_list_lock);\nrescan:\n\tlist_for_each_entry_reverse(urb, &ep->urb_list, urb_list) {\n\t\tint\tis_in;\n\n\t\tif (urb->unlinked)\n\t\t\tcontinue;\n\t\tusb_get_urb (urb);\n\t\tis_in = usb_urb_dir_in(urb);\n\t\tspin_unlock(&hcd_urb_list_lock);\n\n\t\t \n\t\tunlink1(hcd, urb, -ESHUTDOWN);\n\t\tdev_dbg (hcd->self.controller,\n\t\t\t\"shutdown urb %pK ep%d%s-%s\\n\",\n\t\t\turb, usb_endpoint_num(&ep->desc),\n\t\t\tis_in ? \"in\" : \"out\",\n\t\t\tusb_ep_type_string(usb_endpoint_type(&ep->desc)));\n\t\tusb_put_urb (urb);\n\n\t\t \n\t\tspin_lock(&hcd_urb_list_lock);\n\t\tgoto rescan;\n\t}\n\tspin_unlock_irq(&hcd_urb_list_lock);\n\n\t \n\twhile (!list_empty (&ep->urb_list)) {\n\t\tspin_lock_irq(&hcd_urb_list_lock);\n\n\t\t \n\t\turb = NULL;\n\t\tif (!list_empty (&ep->urb_list)) {\n\t\t\turb = list_entry (ep->urb_list.prev, struct urb,\n\t\t\t\t\turb_list);\n\t\t\tusb_get_urb (urb);\n\t\t}\n\t\tspin_unlock_irq(&hcd_urb_list_lock);\n\n\t\tif (urb) {\n\t\t\tusb_kill_urb (urb);\n\t\t\tusb_put_urb (urb);\n\t\t}\n\t}\n}\n\n \nint usb_hcd_alloc_bandwidth(struct usb_device *udev,\n\t\tstruct usb_host_config *new_config,\n\t\tstruct usb_host_interface *cur_alt,\n\t\tstruct usb_host_interface *new_alt)\n{\n\tint num_intfs, i, j;\n\tstruct usb_host_interface *alt = NULL;\n\tint ret = 0;\n\tstruct usb_hcd *hcd;\n\tstruct usb_host_endpoint *ep;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd->driver->check_bandwidth)\n\t\treturn 0;\n\n\t \n\tif (!new_config && !cur_alt) {\n\t\tfor (i = 1; i < 16; ++i) {\n\t\t\tep = udev->ep_out[i];\n\t\t\tif (ep)\n\t\t\t\thcd->driver->drop_endpoint(hcd, udev, ep);\n\t\t\tep = udev->ep_in[i];\n\t\t\tif (ep)\n\t\t\t\thcd->driver->drop_endpoint(hcd, udev, ep);\n\t\t}\n\t\thcd->driver->check_bandwidth(hcd, udev);\n\t\treturn 0;\n\t}\n\t \n\tif (new_config) {\n\t\tnum_intfs = new_config->desc.bNumInterfaces;\n\t\t \n\t\tfor (i = 1; i < 16; ++i) {\n\t\t\tep = udev->ep_out[i];\n\t\t\tif (ep) {\n\t\t\t\tret = hcd->driver->drop_endpoint(hcd, udev, ep);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto reset;\n\t\t\t}\n\t\t\tep = udev->ep_in[i];\n\t\t\tif (ep) {\n\t\t\t\tret = hcd->driver->drop_endpoint(hcd, udev, ep);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto reset;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < num_intfs; ++i) {\n\t\t\tstruct usb_host_interface *first_alt;\n\t\t\tint iface_num;\n\n\t\t\tfirst_alt = &new_config->intf_cache[i]->altsetting[0];\n\t\t\tiface_num = first_alt->desc.bInterfaceNumber;\n\t\t\t \n\t\t\talt = usb_find_alt_setting(new_config, iface_num, 0);\n\t\t\tif (!alt)\n\t\t\t\t \n\t\t\t\talt = first_alt;\n\n\t\t\tfor (j = 0; j < alt->desc.bNumEndpoints; j++) {\n\t\t\t\tret = hcd->driver->add_endpoint(hcd, udev, &alt->endpoint[j]);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto reset;\n\t\t\t}\n\t\t}\n\t}\n\tif (cur_alt && new_alt) {\n\t\tstruct usb_interface *iface = usb_ifnum_to_if(udev,\n\t\t\t\tcur_alt->desc.bInterfaceNumber);\n\n\t\tif (!iface)\n\t\t\treturn -EINVAL;\n\t\tif (iface->resetting_device) {\n\t\t\t \n\t\t\tcur_alt = usb_altnum_to_altsetting(iface, 0);\n\t\t\tif (!cur_alt)\n\t\t\t\tcur_alt = &iface->altsetting[0];\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < cur_alt->desc.bNumEndpoints; i++) {\n\t\t\tret = hcd->driver->drop_endpoint(hcd, udev,\n\t\t\t\t\t&cur_alt->endpoint[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto reset;\n\t\t}\n\t\t \n\t\tfor (i = 0; i < new_alt->desc.bNumEndpoints; i++) {\n\t\t\tret = hcd->driver->add_endpoint(hcd, udev,\n\t\t\t\t\t&new_alt->endpoint[i]);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto reset;\n\t\t}\n\t}\n\tret = hcd->driver->check_bandwidth(hcd, udev);\nreset:\n\tif (ret < 0)\n\t\thcd->driver->reset_bandwidth(hcd, udev);\n\treturn ret;\n}\n\n \nvoid usb_hcd_disable_endpoint(struct usb_device *udev,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct usb_hcd\t\t*hcd;\n\n\tmight_sleep();\n\thcd = bus_to_hcd(udev->bus);\n\tif (hcd->driver->endpoint_disable)\n\t\thcd->driver->endpoint_disable(hcd, ep);\n}\n\n \nvoid usb_hcd_reset_endpoint(struct usb_device *udev,\n\t\t\t    struct usb_host_endpoint *ep)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (hcd->driver->endpoint_reset)\n\t\thcd->driver->endpoint_reset(hcd, ep);\n\telse {\n\t\tint epnum = usb_endpoint_num(&ep->desc);\n\t\tint is_out = usb_endpoint_dir_out(&ep->desc);\n\t\tint is_control = usb_endpoint_xfer_control(&ep->desc);\n\n\t\tusb_settoggle(udev, epnum, is_out, 0);\n\t\tif (is_control)\n\t\t\tusb_settoggle(udev, epnum, !is_out, 0);\n\t}\n}\n\n \nint usb_alloc_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tunsigned int num_streams, gfp_t mem_flags)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *dev;\n\tint i, ret;\n\n\tdev = interface_to_usbdev(interface);\n\thcd = bus_to_hcd(dev->bus);\n\tif (!hcd->driver->alloc_streams || !hcd->driver->free_streams)\n\t\treturn -EINVAL;\n\tif (dev->speed < USB_SPEED_SUPER)\n\t\treturn -EINVAL;\n\tif (dev->state < USB_STATE_CONFIGURED)\n\t\treturn -ENODEV;\n\n\tfor (i = 0; i < num_eps; i++) {\n\t\t \n\t\tif (!usb_endpoint_xfer_bulk(&eps[i]->desc))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (eps[i]->streams)\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = hcd->driver->alloc_streams(hcd, dev, eps, num_eps,\n\t\t\tnum_streams, mem_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_eps; i++)\n\t\teps[i]->streams = ret;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_alloc_streams);\n\n \nint usb_free_streams(struct usb_interface *interface,\n\t\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\t\tgfp_t mem_flags)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *dev;\n\tint i, ret;\n\n\tdev = interface_to_usbdev(interface);\n\thcd = bus_to_hcd(dev->bus);\n\tif (dev->speed < USB_SPEED_SUPER)\n\t\treturn -EINVAL;\n\n\t \n\tfor (i = 0; i < num_eps; i++)\n\t\tif (!eps[i] || !eps[i]->streams)\n\t\t\treturn -EINVAL;\n\n\tret = hcd->driver->free_streams(hcd, dev, eps, num_eps, mem_flags);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < num_eps; i++)\n\t\teps[i]->streams = 0;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_free_streams);\n\n \nvoid usb_hcd_synchronize_unlinks(struct usb_device *udev)\n{\n\tspin_lock_irq(&hcd_urb_unlink_lock);\n\tspin_unlock_irq(&hcd_urb_unlink_lock);\n}\n\n \n\n \nint usb_hcd_get_frame_number (struct usb_device *udev)\n{\n\tstruct usb_hcd\t*hcd = bus_to_hcd(udev->bus);\n\n\tif (!HCD_RH_RUNNING(hcd))\n\t\treturn -ESHUTDOWN;\n\treturn hcd->driver->get_frame_number (hcd);\n}\n\n \n#ifdef CONFIG_USB_HCD_TEST_MODE\n\nstatic void usb_ehset_completion(struct urb *urb)\n{\n\tstruct completion  *done = urb->context;\n\n\tcomplete(done);\n}\n \nstatic struct urb *request_single_step_set_feature_urb(\n\tstruct usb_device\t*udev,\n\tvoid\t\t\t*dr,\n\tvoid\t\t\t*buf,\n\tstruct completion\t*done)\n{\n\tstruct urb *urb;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn NULL;\n\n\turb->pipe = usb_rcvctrlpipe(udev, 0);\n\n\turb->ep = &udev->ep0;\n\turb->dev = udev;\n\turb->setup_packet = (void *)dr;\n\turb->transfer_buffer = buf;\n\turb->transfer_buffer_length = USB_DT_DEVICE_SIZE;\n\turb->complete = usb_ehset_completion;\n\turb->status = -EINPROGRESS;\n\turb->actual_length = 0;\n\turb->transfer_flags = URB_DIR_IN;\n\tusb_get_urb(urb);\n\tatomic_inc(&urb->use_count);\n\tatomic_inc(&urb->dev->urbnum);\n\tif (map_urb_for_dma(hcd, urb, GFP_KERNEL)) {\n\t\tusb_put_urb(urb);\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\turb->context = done;\n\treturn urb;\n}\n\nint ehset_single_step_set_feature(struct usb_hcd *hcd, int port)\n{\n\tint retval = -ENOMEM;\n\tstruct usb_ctrlrequest *dr;\n\tstruct urb *urb;\n\tstruct usb_device *udev;\n\tstruct usb_device_descriptor *buf;\n\tDECLARE_COMPLETION_ONSTACK(done);\n\n\t \n\tudev = usb_hub_find_child(hcd->self.root_hub, port);\n\tif (!udev) {\n\t\tdev_err(hcd->self.controller, \"No device attached to the RootHub\\n\");\n\t\treturn -ENODEV;\n\t}\n\tbuf = kmalloc(USB_DT_DEVICE_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!dr) {\n\t\tkfree(buf);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdr->bRequestType = USB_DIR_IN;\n\tdr->bRequest = USB_REQ_GET_DESCRIPTOR;\n\tdr->wValue = cpu_to_le16(USB_DT_DEVICE << 8);\n\tdr->wIndex = 0;\n\tdr->wLength = cpu_to_le16(USB_DT_DEVICE_SIZE);\n\turb = request_single_step_set_feature_urb(udev, dr, buf, &done);\n\tif (!urb)\n\t\tgoto cleanup;\n\n\t \n\tretval = hcd->driver->submit_single_step_set_feature(hcd, urb, 1);\n\tif (retval)\n\t\tgoto out1;\n\tif (!wait_for_completion_timeout(&done, msecs_to_jiffies(2000))) {\n\t\tusb_kill_urb(urb);\n\t\tretval = -ETIMEDOUT;\n\t\tdev_err(hcd->self.controller,\n\t\t\t\"%s SETUP stage timed out on ep0\\n\", __func__);\n\t\tgoto out1;\n\t}\n\tmsleep(15 * 1000);\n\n\t \n\turb->status = -EINPROGRESS;\n\tusb_get_urb(urb);\n\tatomic_inc(&urb->use_count);\n\tatomic_inc(&urb->dev->urbnum);\n\tretval = hcd->driver->submit_single_step_set_feature(hcd, urb, 0);\n\tif (!retval && !wait_for_completion_timeout(&done,\n\t\t\t\t\t\tmsecs_to_jiffies(2000))) {\n\t\tusb_kill_urb(urb);\n\t\tretval = -ETIMEDOUT;\n\t\tdev_err(hcd->self.controller,\n\t\t\t\"%s IN stage timed out on ep0\\n\", __func__);\n\t}\nout1:\n\tusb_free_urb(urb);\ncleanup:\n\tkfree(dr);\n\tkfree(buf);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(ehset_single_step_set_feature);\n#endif  \n\n \n\n#ifdef\tCONFIG_PM\n\nint hcd_bus_suspend(struct usb_device *rhdev, pm_message_t msg)\n{\n\tstruct usb_hcd\t*hcd = bus_to_hcd(rhdev->bus);\n\tint\t\tstatus;\n\tint\t\told_state = hcd->state;\n\n\tdev_dbg(&rhdev->dev, \"bus %ssuspend, wakeup %d\\n\",\n\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\trhdev->do_remote_wakeup);\n\tif (HCD_DEAD(hcd)) {\n\t\tdev_dbg(&rhdev->dev, \"skipped %s of dead bus\\n\", \"suspend\");\n\t\treturn 0;\n\t}\n\n\tif (!hcd->driver->bus_suspend) {\n\t\tstatus = -ENOENT;\n\t} else {\n\t\tclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\t\thcd->state = HC_STATE_QUIESCING;\n\t\tstatus = hcd->driver->bus_suspend(hcd);\n\t}\n\tif (status == 0) {\n\t\tusb_set_device_state(rhdev, USB_STATE_SUSPENDED);\n\t\thcd->state = HC_STATE_SUSPENDED;\n\n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tusb_phy_roothub_suspend(hcd->self.sysdev,\n\t\t\t\t\t\thcd->phy_roothub);\n\n\t\t \n\t\tif (rhdev->do_remote_wakeup) {\n\t\t\tchar\tbuffer[6];\n\n\t\t\tstatus = hcd->driver->hub_status_data(hcd, buffer);\n\t\t\tif (status != 0) {\n\t\t\t\tdev_dbg(&rhdev->dev, \"suspend raced with wakeup event\\n\");\n\t\t\t\thcd_bus_resume(rhdev, PMSG_AUTO_RESUME);\n\t\t\t\tstatus = -EBUSY;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tspin_lock_irq(&hcd_root_hub_lock);\n\t\tif (!HCD_DEAD(hcd)) {\n\t\t\tset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\t\t\thcd->state = old_state;\n\t\t}\n\t\tspin_unlock_irq(&hcd_root_hub_lock);\n\t\tdev_dbg(&rhdev->dev, \"bus %s fail, err %d\\n\",\n\t\t\t\t\"suspend\", status);\n\t}\n\treturn status;\n}\n\nint hcd_bus_resume(struct usb_device *rhdev, pm_message_t msg)\n{\n\tstruct usb_hcd\t*hcd = bus_to_hcd(rhdev->bus);\n\tint\t\tstatus;\n\tint\t\told_state = hcd->state;\n\n\tdev_dbg(&rhdev->dev, \"usb %sresume\\n\",\n\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\tif (HCD_DEAD(hcd)) {\n\t\tdev_dbg(&rhdev->dev, \"skipped %s of dead bus\\n\", \"resume\");\n\t\treturn 0;\n\t}\n\n\tif (!PMSG_IS_AUTO(msg)) {\n\t\tstatus = usb_phy_roothub_resume(hcd->self.sysdev,\n\t\t\t\t\t\thcd->phy_roothub);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tif (!hcd->driver->bus_resume)\n\t\treturn -ENOENT;\n\tif (HCD_RH_RUNNING(hcd))\n\t\treturn 0;\n\n\thcd->state = HC_STATE_RESUMING;\n\tstatus = hcd->driver->bus_resume(hcd);\n\tclear_bit(HCD_FLAG_WAKEUP_PENDING, &hcd->flags);\n\tif (status == 0)\n\t\tstatus = usb_phy_roothub_calibrate(hcd->phy_roothub);\n\n\tif (status == 0) {\n\t\tstruct usb_device *udev;\n\t\tint port1;\n\n\t\tspin_lock_irq(&hcd_root_hub_lock);\n\t\tif (!HCD_DEAD(hcd)) {\n\t\t\tusb_set_device_state(rhdev, rhdev->actconfig\n\t\t\t\t\t? USB_STATE_CONFIGURED\n\t\t\t\t\t: USB_STATE_ADDRESS);\n\t\t\tset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\t\t\thcd->state = HC_STATE_RUNNING;\n\t\t}\n\t\tspin_unlock_irq(&hcd_root_hub_lock);\n\n\t\t \n\t\tusb_hub_for_each_child(rhdev, port1, udev) {\n\t\t\tif (udev->state != USB_STATE_NOTATTACHED &&\n\t\t\t\t\t!udev->port_is_suspended) {\n\t\t\t\tusleep_range(10000, 11000);\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\thcd->state = old_state;\n\t\tusb_phy_roothub_suspend(hcd->self.sysdev, hcd->phy_roothub);\n\t\tdev_dbg(&rhdev->dev, \"bus %s fail, err %d\\n\",\n\t\t\t\t\"resume\", status);\n\t\tif (status != -ESHUTDOWN)\n\t\t\tusb_hc_died(hcd);\n\t}\n\treturn status;\n}\n\n \nstatic void hcd_resume_work(struct work_struct *work)\n{\n\tstruct usb_hcd *hcd = container_of(work, struct usb_hcd, wakeup_work);\n\tstruct usb_device *udev = hcd->self.root_hub;\n\n\tusb_remote_wakeup(udev);\n}\n\n \nvoid usb_hcd_resume_root_hub (struct usb_hcd *hcd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave (&hcd_root_hub_lock, flags);\n\tif (hcd->rh_registered) {\n\t\tpm_wakeup_event(&hcd->self.root_hub->dev, 0);\n\t\tset_bit(HCD_FLAG_WAKEUP_PENDING, &hcd->flags);\n\t\tqueue_work(pm_wq, &hcd->wakeup_work);\n\t}\n\tspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_resume_root_hub);\n\n#endif\t \n\n \n\n#ifdef\tCONFIG_USB_OTG\n\n \nint usb_bus_start_enum(struct usb_bus *bus, unsigned port_num)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tint\t\t\tstatus = -EOPNOTSUPP;\n\n\t \n\thcd = bus_to_hcd(bus);\n\tif (port_num && hcd->driver->start_port_reset)\n\t\tstatus = hcd->driver->start_port_reset(hcd, port_num);\n\n\t \n\tif (status == 0)\n\t\tmod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(10));\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_bus_start_enum);\n\n#endif\n\n \n\n \nirqreturn_t usb_hcd_irq (int irq, void *__hcd)\n{\n\tstruct usb_hcd\t\t*hcd = __hcd;\n\tirqreturn_t\t\trc;\n\n\tif (unlikely(HCD_DEAD(hcd) || !HCD_HW_ACCESSIBLE(hcd)))\n\t\trc = IRQ_NONE;\n\telse if (hcd->driver->irq(hcd) == IRQ_NONE)\n\t\trc = IRQ_NONE;\n\telse\n\t\trc = IRQ_HANDLED;\n\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_irq);\n\n \n\n \nstatic void hcd_died_work(struct work_struct *work)\n{\n\tstruct usb_hcd *hcd = container_of(work, struct usb_hcd, died_work);\n\tstatic char *env[] = {\n\t\t\"ERROR=DEAD\",\n\t\tNULL\n\t};\n\n\t \n\tkobject_uevent_env(&hcd->self.root_hub->dev.kobj, KOBJ_OFFLINE, env);\n}\n\n \nvoid usb_hc_died (struct usb_hcd *hcd)\n{\n\tunsigned long flags;\n\n\tdev_err (hcd->self.controller, \"HC died; cleaning up\\n\");\n\n\tspin_lock_irqsave (&hcd_root_hub_lock, flags);\n\tclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\tset_bit(HCD_FLAG_DEAD, &hcd->flags);\n\tif (hcd->rh_registered) {\n\t\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\t\t \n\t\tusb_set_device_state (hcd->self.root_hub,\n\t\t\t\tUSB_STATE_NOTATTACHED);\n\t\tusb_kick_hub_wq(hcd->self.root_hub);\n\t}\n\tif (usb_hcd_is_primary_hcd(hcd) && hcd->shared_hcd) {\n\t\thcd = hcd->shared_hcd;\n\t\tclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\t\tset_bit(HCD_FLAG_DEAD, &hcd->flags);\n\t\tif (hcd->rh_registered) {\n\t\t\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\t\t\t \n\t\t\tusb_set_device_state(hcd->self.root_hub,\n\t\t\t\t\tUSB_STATE_NOTATTACHED);\n\t\t\tusb_kick_hub_wq(hcd->self.root_hub);\n\t\t}\n\t}\n\n\t \n\tif (usb_hcd_is_primary_hcd(hcd))\n\t\tschedule_work(&hcd->died_work);\n\telse\n\t\tschedule_work(&hcd->primary_hcd->died_work);\n\n\tspin_unlock_irqrestore (&hcd_root_hub_lock, flags);\n\t \n}\nEXPORT_SYMBOL_GPL (usb_hc_died);\n\n \n\nstatic void init_giveback_urb_bh(struct giveback_urb_bh *bh)\n{\n\n\tspin_lock_init(&bh->lock);\n\tINIT_LIST_HEAD(&bh->head);\n\ttasklet_setup(&bh->bh, usb_giveback_urb_bh);\n}\n\nstruct usb_hcd *__usb_create_hcd(const struct hc_driver *driver,\n\t\tstruct device *sysdev, struct device *dev, const char *bus_name,\n\t\tstruct usb_hcd *primary_hcd)\n{\n\tstruct usb_hcd *hcd;\n\n\thcd = kzalloc(sizeof(*hcd) + driver->hcd_priv_size, GFP_KERNEL);\n\tif (!hcd)\n\t\treturn NULL;\n\tif (primary_hcd == NULL) {\n\t\thcd->address0_mutex = kmalloc(sizeof(*hcd->address0_mutex),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!hcd->address0_mutex) {\n\t\t\tkfree(hcd);\n\t\t\tdev_dbg(dev, \"hcd address0 mutex alloc failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tmutex_init(hcd->address0_mutex);\n\t\thcd->bandwidth_mutex = kmalloc(sizeof(*hcd->bandwidth_mutex),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!hcd->bandwidth_mutex) {\n\t\t\tkfree(hcd->address0_mutex);\n\t\t\tkfree(hcd);\n\t\t\tdev_dbg(dev, \"hcd bandwidth mutex alloc failed\\n\");\n\t\t\treturn NULL;\n\t\t}\n\t\tmutex_init(hcd->bandwidth_mutex);\n\t\tdev_set_drvdata(dev, hcd);\n\t} else {\n\t\tmutex_lock(&usb_port_peer_mutex);\n\t\thcd->address0_mutex = primary_hcd->address0_mutex;\n\t\thcd->bandwidth_mutex = primary_hcd->bandwidth_mutex;\n\t\thcd->primary_hcd = primary_hcd;\n\t\tprimary_hcd->primary_hcd = primary_hcd;\n\t\thcd->shared_hcd = primary_hcd;\n\t\tprimary_hcd->shared_hcd = hcd;\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\t}\n\n\tkref_init(&hcd->kref);\n\n\tusb_bus_init(&hcd->self);\n\thcd->self.controller = dev;\n\thcd->self.sysdev = sysdev;\n\thcd->self.bus_name = bus_name;\n\n\ttimer_setup(&hcd->rh_timer, rh_timer_func, 0);\n#ifdef CONFIG_PM\n\tINIT_WORK(&hcd->wakeup_work, hcd_resume_work);\n#endif\n\n\tINIT_WORK(&hcd->died_work, hcd_died_work);\n\n\thcd->driver = driver;\n\thcd->speed = driver->flags & HCD_MASK;\n\thcd->product_desc = (driver->product_desc) ? driver->product_desc :\n\t\t\t\"USB Host Controller\";\n\treturn hcd;\n}\nEXPORT_SYMBOL_GPL(__usb_create_hcd);\n\n \nstruct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,\n\t\tstruct device *dev, const char *bus_name,\n\t\tstruct usb_hcd *primary_hcd)\n{\n\treturn __usb_create_hcd(driver, dev, dev, bus_name, primary_hcd);\n}\nEXPORT_SYMBOL_GPL(usb_create_shared_hcd);\n\n \nstruct usb_hcd *usb_create_hcd(const struct hc_driver *driver,\n\t\tstruct device *dev, const char *bus_name)\n{\n\treturn __usb_create_hcd(driver, dev, dev, bus_name, NULL);\n}\nEXPORT_SYMBOL_GPL(usb_create_hcd);\n\n \nstatic void hcd_release(struct kref *kref)\n{\n\tstruct usb_hcd *hcd = container_of (kref, struct usb_hcd, kref);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tif (hcd->shared_hcd) {\n\t\tstruct usb_hcd *peer = hcd->shared_hcd;\n\n\t\tpeer->shared_hcd = NULL;\n\t\tpeer->primary_hcd = NULL;\n\t} else {\n\t\tkfree(hcd->address0_mutex);\n\t\tkfree(hcd->bandwidth_mutex);\n\t}\n\tmutex_unlock(&usb_port_peer_mutex);\n\tkfree(hcd);\n}\n\nstruct usb_hcd *usb_get_hcd (struct usb_hcd *hcd)\n{\n\tif (hcd)\n\t\tkref_get (&hcd->kref);\n\treturn hcd;\n}\nEXPORT_SYMBOL_GPL(usb_get_hcd);\n\nvoid usb_put_hcd (struct usb_hcd *hcd)\n{\n\tif (hcd)\n\t\tkref_put (&hcd->kref, hcd_release);\n}\nEXPORT_SYMBOL_GPL(usb_put_hcd);\n\nint usb_hcd_is_primary_hcd(struct usb_hcd *hcd)\n{\n\tif (!hcd->primary_hcd)\n\t\treturn 1;\n\treturn hcd == hcd->primary_hcd;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_is_primary_hcd);\n\nint usb_hcd_find_raw_port_number(struct usb_hcd *hcd, int port1)\n{\n\tif (!hcd->driver->find_raw_port_number)\n\t\treturn port1;\n\n\treturn hcd->driver->find_raw_port_number(hcd, port1);\n}\n\nstatic int usb_hcd_request_irqs(struct usb_hcd *hcd,\n\t\tunsigned int irqnum, unsigned long irqflags)\n{\n\tint retval;\n\n\tif (hcd->driver->irq) {\n\n\t\tsnprintf(hcd->irq_descr, sizeof(hcd->irq_descr), \"%s:usb%d\",\n\t\t\t\thcd->driver->description, hcd->self.busnum);\n\t\tretval = request_irq(irqnum, &usb_hcd_irq, irqflags,\n\t\t\t\thcd->irq_descr, hcd);\n\t\tif (retval != 0) {\n\t\t\tdev_err(hcd->self.controller,\n\t\t\t\t\t\"request interrupt %d failed\\n\",\n\t\t\t\t\tirqnum);\n\t\t\treturn retval;\n\t\t}\n\t\thcd->irq = irqnum;\n\t\tdev_info(hcd->self.controller, \"irq %d, %s 0x%08llx\\n\", irqnum,\n\t\t\t\t(hcd->driver->flags & HCD_MEMORY) ?\n\t\t\t\t\t\"io mem\" : \"io port\",\n\t\t\t\t(unsigned long long)hcd->rsrc_start);\n\t} else {\n\t\thcd->irq = 0;\n\t\tif (hcd->rsrc_start)\n\t\t\tdev_info(hcd->self.controller, \"%s 0x%08llx\\n\",\n\t\t\t\t\t(hcd->driver->flags & HCD_MEMORY) ?\n\t\t\t\t\t\t\"io mem\" : \"io port\",\n\t\t\t\t\t(unsigned long long)hcd->rsrc_start);\n\t}\n\treturn 0;\n}\n\n \nstatic void usb_put_invalidate_rhdev(struct usb_hcd *hcd)\n{\n\tstruct usb_device *rhdev;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\trhdev = hcd->self.root_hub;\n\thcd->self.root_hub = NULL;\n\tmutex_unlock(&usb_port_peer_mutex);\n\tusb_put_dev(rhdev);\n}\n\n \nstatic void usb_stop_hcd(struct usb_hcd *hcd)\n{\n\thcd->rh_pollable = 0;\n\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tdel_timer_sync(&hcd->rh_timer);\n\n\thcd->driver->stop(hcd);\n\thcd->state = HC_STATE_HALT;\n\n\t \n\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tdel_timer_sync(&hcd->rh_timer);\n}\n\n \nint usb_add_hcd(struct usb_hcd *hcd,\n\t\tunsigned int irqnum, unsigned long irqflags)\n{\n\tint retval;\n\tstruct usb_device *rhdev;\n\tstruct usb_hcd *shared_hcd;\n\n\tif (!hcd->skip_phy_initialization && usb_hcd_is_primary_hcd(hcd)) {\n\t\thcd->phy_roothub = usb_phy_roothub_alloc(hcd->self.sysdev);\n\t\tif (IS_ERR(hcd->phy_roothub))\n\t\t\treturn PTR_ERR(hcd->phy_roothub);\n\n\t\tretval = usb_phy_roothub_init(hcd->phy_roothub);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tretval = usb_phy_roothub_set_mode(hcd->phy_roothub,\n\t\t\t\t\t\t  PHY_MODE_USB_HOST_SS);\n\t\tif (retval)\n\t\t\tretval = usb_phy_roothub_set_mode(hcd->phy_roothub,\n\t\t\t\t\t\t\t  PHY_MODE_USB_HOST);\n\t\tif (retval)\n\t\t\tgoto err_usb_phy_roothub_power_on;\n\n\t\tretval = usb_phy_roothub_power_on(hcd->phy_roothub);\n\t\tif (retval)\n\t\t\tgoto err_usb_phy_roothub_power_on;\n\t}\n\n\tdev_info(hcd->self.controller, \"%s\\n\", hcd->product_desc);\n\n\tswitch (authorized_default) {\n\tcase USB_AUTHORIZE_NONE:\n\t\thcd->dev_policy = USB_DEVICE_AUTHORIZE_NONE;\n\t\tbreak;\n\n\tcase USB_AUTHORIZE_INTERNAL:\n\t\thcd->dev_policy = USB_DEVICE_AUTHORIZE_INTERNAL;\n\t\tbreak;\n\n\tcase USB_AUTHORIZE_ALL:\n\tcase USB_AUTHORIZE_WIRED:\n\tdefault:\n\t\thcd->dev_policy = USB_DEVICE_AUTHORIZE_ALL;\n\t\tbreak;\n\t}\n\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\t \n\tset_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\n\n\t \n\tretval = hcd_buffer_create(hcd);\n\tif (retval != 0) {\n\t\tdev_dbg(hcd->self.sysdev, \"pool alloc failed\\n\");\n\t\tgoto err_create_buf;\n\t}\n\n\tretval = usb_register_bus(&hcd->self);\n\tif (retval < 0)\n\t\tgoto err_register_bus;\n\n\trhdev = usb_alloc_dev(NULL, &hcd->self, 0);\n\tif (rhdev == NULL) {\n\t\tdev_err(hcd->self.sysdev, \"unable to allocate root hub\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err_allocate_root_hub;\n\t}\n\tmutex_lock(&usb_port_peer_mutex);\n\thcd->self.root_hub = rhdev;\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\trhdev->rx_lanes = 1;\n\trhdev->tx_lanes = 1;\n\trhdev->ssp_rate = USB_SSP_GEN_UNKNOWN;\n\n\tswitch (hcd->speed) {\n\tcase HCD_USB11:\n\t\trhdev->speed = USB_SPEED_FULL;\n\t\tbreak;\n\tcase HCD_USB2:\n\t\trhdev->speed = USB_SPEED_HIGH;\n\t\tbreak;\n\tcase HCD_USB3:\n\t\trhdev->speed = USB_SPEED_SUPER;\n\t\tbreak;\n\tcase HCD_USB32:\n\t\trhdev->rx_lanes = 2;\n\t\trhdev->tx_lanes = 2;\n\t\trhdev->ssp_rate = USB_SSP_GEN_2x2;\n\t\trhdev->speed = USB_SPEED_SUPER_PLUS;\n\t\tbreak;\n\tcase HCD_USB31:\n\t\trhdev->ssp_rate = USB_SSP_GEN_2x1;\n\t\trhdev->speed = USB_SPEED_SUPER_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tretval = -EINVAL;\n\t\tgoto err_set_rh_speed;\n\t}\n\n\t \n\tdevice_set_wakeup_capable(&rhdev->dev, 1);\n\n\t \n\tset_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\n\t \n\tif (hcd->driver->reset) {\n\t\tretval = hcd->driver->reset(hcd);\n\t\tif (retval < 0) {\n\t\t\tdev_err(hcd->self.controller, \"can't setup: %d\\n\",\n\t\t\t\t\tretval);\n\t\t\tgoto err_hcd_driver_setup;\n\t\t}\n\t}\n\thcd->rh_pollable = 1;\n\n\tretval = usb_phy_roothub_calibrate(hcd->phy_roothub);\n\tif (retval)\n\t\tgoto err_hcd_driver_setup;\n\n\t \n\tif (device_can_wakeup(hcd->self.controller)\n\t\t\t&& device_can_wakeup(&hcd->self.root_hub->dev))\n\t\tdev_dbg(hcd->self.controller, \"supports USB remote wakeup\\n\");\n\n\t \n\tinit_giveback_urb_bh(&hcd->high_prio_bh);\n\thcd->high_prio_bh.high_prio = true;\n\tinit_giveback_urb_bh(&hcd->low_prio_bh);\n\n\t \n\tif (usb_hcd_is_primary_hcd(hcd) && irqnum) {\n\t\tretval = usb_hcd_request_irqs(hcd, irqnum, irqflags);\n\t\tif (retval)\n\t\t\tgoto err_request_irq;\n\t}\n\n\thcd->state = HC_STATE_RUNNING;\n\tretval = hcd->driver->start(hcd);\n\tif (retval < 0) {\n\t\tdev_err(hcd->self.controller, \"startup error %d\\n\", retval);\n\t\tgoto err_hcd_driver_start;\n\t}\n\n\t \n\tshared_hcd = hcd->shared_hcd;\n\tif (!usb_hcd_is_primary_hcd(hcd) && shared_hcd && HCD_DEFER_RH_REGISTER(shared_hcd)) {\n\t\tretval = register_root_hub(shared_hcd);\n\t\tif (retval != 0)\n\t\t\tgoto err_register_root_hub;\n\n\t\tif (shared_hcd->uses_new_polling && HCD_POLL_RH(shared_hcd))\n\t\t\tusb_hcd_poll_rh_status(shared_hcd);\n\t}\n\n\t \n\tif (!HCD_DEFER_RH_REGISTER(hcd)) {\n\t\tretval = register_root_hub(hcd);\n\t\tif (retval != 0)\n\t\t\tgoto err_register_root_hub;\n\n\t\tif (hcd->uses_new_polling && HCD_POLL_RH(hcd))\n\t\t\tusb_hcd_poll_rh_status(hcd);\n\t}\n\n\treturn retval;\n\nerr_register_root_hub:\n\tusb_stop_hcd(hcd);\nerr_hcd_driver_start:\n\tif (usb_hcd_is_primary_hcd(hcd) && hcd->irq > 0)\n\t\tfree_irq(irqnum, hcd);\nerr_request_irq:\nerr_hcd_driver_setup:\nerr_set_rh_speed:\n\tusb_put_invalidate_rhdev(hcd);\nerr_allocate_root_hub:\n\tusb_deregister_bus(&hcd->self);\nerr_register_bus:\n\thcd_buffer_destroy(hcd);\nerr_create_buf:\n\tusb_phy_roothub_power_off(hcd->phy_roothub);\nerr_usb_phy_roothub_power_on:\n\tusb_phy_roothub_exit(hcd->phy_roothub);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_add_hcd);\n\n \nvoid usb_remove_hcd(struct usb_hcd *hcd)\n{\n\tstruct usb_device *rhdev;\n\tbool rh_registered;\n\n\tif (!hcd) {\n\t\tpr_debug(\"%s: hcd is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\trhdev = hcd->self.root_hub;\n\n\tdev_info(hcd->self.controller, \"remove, state %x\\n\", hcd->state);\n\n\tusb_get_dev(rhdev);\n\tclear_bit(HCD_FLAG_RH_RUNNING, &hcd->flags);\n\tif (HC_IS_RUNNING (hcd->state))\n\t\thcd->state = HC_STATE_QUIESCING;\n\n\tdev_dbg(hcd->self.controller, \"roothub graceful disconnect\\n\");\n\tspin_lock_irq (&hcd_root_hub_lock);\n\trh_registered = hcd->rh_registered;\n\thcd->rh_registered = 0;\n\tspin_unlock_irq (&hcd_root_hub_lock);\n\n#ifdef CONFIG_PM\n\tcancel_work_sync(&hcd->wakeup_work);\n#endif\n\tcancel_work_sync(&hcd->died_work);\n\n\tmutex_lock(&usb_bus_idr_lock);\n\tif (rh_registered)\n\t\tusb_disconnect(&rhdev);\t\t \n\tmutex_unlock(&usb_bus_idr_lock);\n\n\t \n\n\t \n\tusb_stop_hcd(hcd);\n\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tif (hcd->irq > 0)\n\t\t\tfree_irq(hcd->irq, hcd);\n\t}\n\n\tusb_deregister_bus(&hcd->self);\n\thcd_buffer_destroy(hcd);\n\n\tusb_phy_roothub_power_off(hcd->phy_roothub);\n\tusb_phy_roothub_exit(hcd->phy_roothub);\n\n\tusb_put_invalidate_rhdev(hcd);\n\thcd->flags = 0;\n}\nEXPORT_SYMBOL_GPL(usb_remove_hcd);\n\nvoid\nusb_hcd_platform_shutdown(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\n\t \n\tpm_runtime_get_sync(&dev->dev);\n\n\tif (hcd->driver->shutdown)\n\t\thcd->driver->shutdown(hcd);\n}\nEXPORT_SYMBOL_GPL(usb_hcd_platform_shutdown);\n\nint usb_hcd_setup_local_mem(struct usb_hcd *hcd, phys_addr_t phys_addr,\n\t\t\t    dma_addr_t dma, size_t size)\n{\n\tint err;\n\tvoid *local_mem;\n\n\thcd->localmem_pool = devm_gen_pool_create(hcd->self.sysdev, 4,\n\t\t\t\t\t\t  dev_to_node(hcd->self.sysdev),\n\t\t\t\t\t\t  dev_name(hcd->self.sysdev));\n\tif (IS_ERR(hcd->localmem_pool))\n\t\treturn PTR_ERR(hcd->localmem_pool);\n\n\t \n\tif (phys_addr)\n\t\tlocal_mem = devm_memremap(hcd->self.sysdev, phys_addr,\n\t\t\t\t\t  size, MEMREMAP_WC);\n\telse\n\t\tlocal_mem = dmam_alloc_attrs(hcd->self.sysdev, size, &dma,\n\t\t\t\t\t     GFP_KERNEL,\n\t\t\t\t\t     DMA_ATTR_WRITE_COMBINE);\n\n\tif (IS_ERR_OR_NULL(local_mem)) {\n\t\tif (!local_mem)\n\t\t\treturn -ENOMEM;\n\n\t\treturn PTR_ERR(local_mem);\n\t}\n\n\t \n\terr = gen_pool_add_virt(hcd->localmem_pool, (unsigned long)local_mem,\n\t\t\t\tdma, size, dev_to_node(hcd->self.sysdev));\n\tif (err < 0) {\n\t\tdev_err(hcd->self.sysdev, \"gen_pool_add_virt failed with %d\\n\",\n\t\t\terr);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_setup_local_mem);\n\n \n\n#if IS_ENABLED(CONFIG_USB_MON)\n\nconst struct usb_mon_operations *mon_ops;\n\n \n\nint usb_mon_register(const struct usb_mon_operations *ops)\n{\n\n\tif (mon_ops)\n\t\treturn -EBUSY;\n\n\tmon_ops = ops;\n\tmb();\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL (usb_mon_register);\n\nvoid usb_mon_deregister (void)\n{\n\n\tif (mon_ops == NULL) {\n\t\tprintk(KERN_ERR \"USB: monitor was not registered\\n\");\n\t\treturn;\n\t}\n\tmon_ops = NULL;\n\tmb();\n}\nEXPORT_SYMBOL_GPL (usb_mon_deregister);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}