{
  "module_name": "ledtrig-usbport.c",
  "hash_id": "62d4f29b67b6ee0a64b9eb14ce85c8fcd135ae599c6d7fc63506e4c9e9510f43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/ledtrig-usbport.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/leds.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/of.h>\n\nstruct usbport_trig_data {\n\tstruct led_classdev *led_cdev;\n\tstruct list_head ports;\n\tstruct notifier_block nb;\n\tint count;  \n};\n\nstruct usbport_trig_port {\n\tstruct usbport_trig_data *data;\n\tstruct usb_device *hub;\n\tint portnum;\n\tchar *port_name;\n\tbool observed;\n\tstruct device_attribute attr;\n\tstruct list_head list;\n};\n\n \n\n \nstatic bool usbport_trig_usb_dev_observed(struct usbport_trig_data *usbport_data,\n\t\t\t\t\t  struct usb_device *usb_dev)\n{\n\tstruct usbport_trig_port *port;\n\n\tif (!usb_dev->parent)\n\t\treturn false;\n\n\tlist_for_each_entry(port, &usbport_data->ports, list) {\n\t\tif (usb_dev->parent == port->hub &&\n\t\t    usb_dev->portnum == port->portnum)\n\t\t\treturn port->observed;\n\t}\n\n\treturn false;\n}\n\nstatic int usbport_trig_usb_dev_check(struct usb_device *usb_dev, void *data)\n{\n\tstruct usbport_trig_data *usbport_data = data;\n\n\tif (usbport_trig_usb_dev_observed(usbport_data, usb_dev))\n\t\tusbport_data->count++;\n\n\treturn 0;\n}\n\n \nstatic void usbport_trig_update_count(struct usbport_trig_data *usbport_data)\n{\n\tstruct led_classdev *led_cdev = usbport_data->led_cdev;\n\n\tusbport_data->count = 0;\n\tusb_for_each_dev(usbport_data, usbport_trig_usb_dev_check);\n\tled_set_brightness(led_cdev, usbport_data->count ? LED_FULL : LED_OFF);\n}\n\n \n\nstatic ssize_t usbport_trig_port_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usbport_trig_port *port = container_of(attr,\n\t\t\t\t\t\t      struct usbport_trig_port,\n\t\t\t\t\t\t      attr);\n\n\treturn sprintf(buf, \"%d\\n\", port->observed) + 1;\n}\n\nstatic ssize_t usbport_trig_port_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t size)\n{\n\tstruct usbport_trig_port *port = container_of(attr,\n\t\t\t\t\t\t      struct usbport_trig_port,\n\t\t\t\t\t\t      attr);\n\n\tif (!strcmp(buf, \"0\") || !strcmp(buf, \"0\\n\"))\n\t\tport->observed = 0;\n\telse if (!strcmp(buf, \"1\") || !strcmp(buf, \"1\\n\"))\n\t\tport->observed = 1;\n\telse\n\t\treturn -EINVAL;\n\n\tusbport_trig_update_count(port->data);\n\n\treturn size;\n}\n\nstatic struct attribute *ports_attrs[] = {\n\tNULL,\n};\n\nstatic const struct attribute_group ports_group = {\n\t.name = \"ports\",\n\t.attrs = ports_attrs,\n};\n\n \n\n \nstatic bool usbport_trig_port_observed(struct usbport_trig_data *usbport_data,\n\t\t\t\t       struct usb_device *usb_dev, int port1)\n{\n\tstruct device *dev = usbport_data->led_cdev->dev;\n\tstruct device_node *led_np = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct device_node *port_np;\n\tint count, i;\n\n\tif (!led_np)\n\t\treturn false;\n\n\t \n\tport_np = usb_of_get_device_node(usb_dev, port1);\n\tif (!port_np)\n\t\treturn false;\n\n\tof_node_put(port_np);\n\n\t \n\tcount = of_count_phandle_with_args(led_np, \"trigger-sources\",\n\t\t\t\t\t   \"#trigger-source-cells\");\n\tif (count < 0) {\n\t\tdev_warn(dev, \"Failed to get trigger sources for %pOF\\n\",\n\t\t\t led_np);\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\tint err;\n\n\t\terr = of_parse_phandle_with_args(led_np, \"trigger-sources\",\n\t\t\t\t\t\t \"#trigger-source-cells\", i,\n\t\t\t\t\t\t &args);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"Failed to get trigger source phandle at index %d: %d\\n\",\n\t\t\t\ti, err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tof_node_put(args.np);\n\n\t\tif (args.np == port_np)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic int usbport_trig_add_port(struct usbport_trig_data *usbport_data,\n\t\t\t\t struct usb_device *usb_dev,\n\t\t\t\t const char *hub_name, int portnum)\n{\n\tstruct led_classdev *led_cdev = usbport_data->led_cdev;\n\tstruct usbport_trig_port *port;\n\tsize_t len;\n\tint err;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port) {\n\t\terr = -ENOMEM;\n\t\tgoto err_out;\n\t}\n\n\tport->data = usbport_data;\n\tport->hub = usb_dev;\n\tport->portnum = portnum;\n\tport->observed = usbport_trig_port_observed(usbport_data, usb_dev,\n\t\t\t\t\t\t    portnum);\n\n\tlen = strlen(hub_name) + 8;\n\tport->port_name = kzalloc(len, GFP_KERNEL);\n\tif (!port->port_name) {\n\t\terr = -ENOMEM;\n\t\tgoto err_free_port;\n\t}\n\tsnprintf(port->port_name, len, \"%s-port%d\", hub_name, portnum);\n\n\tsysfs_attr_init(&port->attr.attr);\n\tport->attr.attr.name = port->port_name;\n\tport->attr.attr.mode = S_IRUSR | S_IWUSR;\n\tport->attr.show = usbport_trig_port_show;\n\tport->attr.store = usbport_trig_port_store;\n\n\terr = sysfs_add_file_to_group(&led_cdev->dev->kobj, &port->attr.attr,\n\t\t\t\t      ports_group.name);\n\tif (err)\n\t\tgoto err_free_port_name;\n\n\tlist_add_tail(&port->list, &usbport_data->ports);\n\n\treturn 0;\n\nerr_free_port_name:\n\tkfree(port->port_name);\nerr_free_port:\n\tkfree(port);\nerr_out:\n\treturn err;\n}\n\nstatic int usbport_trig_add_usb_dev_ports(struct usb_device *usb_dev,\n\t\t\t\t\t  void *data)\n{\n\tstruct usbport_trig_data *usbport_data = data;\n\tint i;\n\n\tfor (i = 1; i <= usb_dev->maxchild; i++)\n\t\tusbport_trig_add_port(usbport_data, usb_dev,\n\t\t\t\t      dev_name(&usb_dev->dev), i);\n\n\treturn 0;\n}\n\nstatic void usbport_trig_remove_port(struct usbport_trig_data *usbport_data,\n\t\t\t\t     struct usbport_trig_port *port)\n{\n\tstruct led_classdev *led_cdev = usbport_data->led_cdev;\n\n\tlist_del(&port->list);\n\tsysfs_remove_file_from_group(&led_cdev->dev->kobj, &port->attr.attr,\n\t\t\t\t     ports_group.name);\n\tkfree(port->port_name);\n\tkfree(port);\n}\n\nstatic void usbport_trig_remove_usb_dev_ports(struct usbport_trig_data *usbport_data,\n\t\t\t\t\t      struct usb_device *usb_dev)\n{\n\tstruct usbport_trig_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {\n\t\tif (port->hub == usb_dev)\n\t\t\tusbport_trig_remove_port(usbport_data, port);\n\t}\n}\n\n \n\nstatic int usbport_trig_notify(struct notifier_block *nb, unsigned long action,\n\t\t\t       void *data)\n{\n\tstruct usbport_trig_data *usbport_data =\n\t\tcontainer_of(nb, struct usbport_trig_data, nb);\n\tstruct led_classdev *led_cdev = usbport_data->led_cdev;\n\tstruct usb_device *usb_dev = data;\n\tbool observed;\n\n\tobserved = usbport_trig_usb_dev_observed(usbport_data, usb_dev);\n\n\tswitch (action) {\n\tcase USB_DEVICE_ADD:\n\t\tusbport_trig_add_usb_dev_ports(usb_dev, usbport_data);\n\t\tif (observed && usbport_data->count++ == 0)\n\t\t\tled_set_brightness(led_cdev, LED_FULL);\n\t\treturn NOTIFY_OK;\n\tcase USB_DEVICE_REMOVE:\n\t\tusbport_trig_remove_usb_dev_ports(usbport_data, usb_dev);\n\t\tif (observed && --usbport_data->count == 0)\n\t\t\tled_set_brightness(led_cdev, LED_OFF);\n\t\treturn NOTIFY_OK;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int usbport_trig_activate(struct led_classdev *led_cdev)\n{\n\tstruct usbport_trig_data *usbport_data;\n\tint err;\n\n\tusbport_data = kzalloc(sizeof(*usbport_data), GFP_KERNEL);\n\tif (!usbport_data)\n\t\treturn -ENOMEM;\n\tusbport_data->led_cdev = led_cdev;\n\n\t \n\tINIT_LIST_HEAD(&usbport_data->ports);\n\terr = sysfs_create_group(&led_cdev->dev->kobj, &ports_group);\n\tif (err)\n\t\tgoto err_free;\n\tusb_for_each_dev(usbport_data, usbport_trig_add_usb_dev_ports);\n\tusbport_trig_update_count(usbport_data);\n\n\t \n\tusbport_data->nb.notifier_call = usbport_trig_notify;\n\tled_set_trigger_data(led_cdev, usbport_data);\n\tusb_register_notify(&usbport_data->nb);\n\treturn 0;\n\nerr_free:\n\tkfree(usbport_data);\n\treturn err;\n}\n\nstatic void usbport_trig_deactivate(struct led_classdev *led_cdev)\n{\n\tstruct usbport_trig_data *usbport_data = led_get_trigger_data(led_cdev);\n\tstruct usbport_trig_port *port, *tmp;\n\n\tlist_for_each_entry_safe(port, tmp, &usbport_data->ports, list) {\n\t\tusbport_trig_remove_port(usbport_data, port);\n\t}\n\n\tsysfs_remove_group(&led_cdev->dev->kobj, &ports_group);\n\n\tusb_unregister_notify(&usbport_data->nb);\n\n\tkfree(usbport_data);\n}\n\nstatic struct led_trigger usbport_led_trigger = {\n\t.name     = \"usbport\",\n\t.activate = usbport_trig_activate,\n\t.deactivate = usbport_trig_deactivate,\n};\n\nmodule_led_trigger(usbport_led_trigger);\n\nMODULE_AUTHOR(\"Rafa\u0142 Mi\u0142ecki <rafal@milecki.pl>\");\nMODULE_DESCRIPTION(\"USB port trigger\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}