{
  "module_name": "devio.c",
  "hash_id": "fe252be86187af564c891821695f3de409c3873650950a70265718dc96f652de",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/devio.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/fs.h>\n#include <linux/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/signal.h>\n#include <linux/poll.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\t \n#include <linux/usb/quirks.h>\n#include <linux/cdev.h>\n#include <linux/notifier.h>\n#include <linux/security.h>\n#include <linux/user_namespace.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/dma-mapping.h>\n#include <asm/byteorder.h>\n#include <linux/moduleparam.h>\n\n#include \"usb.h\"\n\n#ifdef CONFIG_PM\n#define MAYBE_CAP_SUSPEND\tUSBDEVFS_CAP_SUSPEND\n#else\n#define MAYBE_CAP_SUSPEND\t0\n#endif\n\n#define USB_MAXBUS\t\t\t64\n#define USB_DEVICE_MAX\t\t\t(USB_MAXBUS * 128)\n#define USB_SG_SIZE\t\t\t16384  \n\n \nstatic DEFINE_MUTEX(usbfs_mutex);\n\nstruct usb_dev_state {\n\tstruct list_head list;       \n\tstruct usb_device *dev;\n\tstruct file *file;\n\tspinlock_t lock;             \n\tstruct list_head async_pending;\n\tstruct list_head async_completed;\n\tstruct list_head memory_list;\n\twait_queue_head_t wait;      \n\twait_queue_head_t wait_for_resume;    \n\tunsigned int discsignr;\n\tstruct pid *disc_pid;\n\tconst struct cred *cred;\n\tsigval_t disccontext;\n\tunsigned long ifclaimed;\n\tu32 disabled_bulk_eps;\n\tunsigned long interface_allowed_mask;\n\tint not_yet_resumed;\n\tbool suspend_allowed;\n\tbool privileges_dropped;\n};\n\nstruct usb_memory {\n\tstruct list_head memlist;\n\tint vma_use_count;\n\tint urb_use_count;\n\tu32 size;\n\tvoid *mem;\n\tdma_addr_t dma_handle;\n\tunsigned long vm_start;\n\tstruct usb_dev_state *ps;\n};\n\nstruct async {\n\tstruct list_head asynclist;\n\tstruct usb_dev_state *ps;\n\tstruct pid *pid;\n\tconst struct cred *cred;\n\tunsigned int signr;\n\tunsigned int ifnum;\n\tvoid __user *userbuffer;\n\tvoid __user *userurb;\n\tsigval_t userurb_sigval;\n\tstruct urb *urb;\n\tstruct usb_memory *usbm;\n\tunsigned int mem_usage;\n\tint status;\n\tu8 bulk_addr;\n\tu8 bulk_status;\n};\n\nstatic bool usbfs_snoop;\nmodule_param(usbfs_snoop, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(usbfs_snoop, \"true to log all usbfs traffic\");\n\nstatic unsigned usbfs_snoop_max = 65536;\nmodule_param(usbfs_snoop_max, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(usbfs_snoop_max,\n\t\t\"maximum number of bytes to print while snooping\");\n\n#define snoop(dev, format, arg...)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tif (usbfs_snoop)\t\t\t\t\\\n\t\t\tdev_info(dev, format, ## arg);\t\t\\\n\t} while (0)\n\nenum snoop_when {\n\tSUBMIT, COMPLETE\n};\n\n#define USB_DEVICE_DEV\t\tMKDEV(USB_DEVICE_MAJOR, 0)\n\n \nstatic u32 usbfs_memory_mb = 16;\nmodule_param(usbfs_memory_mb, uint, 0644);\nMODULE_PARM_DESC(usbfs_memory_mb,\n\t\t\"maximum MB allowed for usbfs buffers (0 = no limit)\");\n\n \n#define USBFS_XFER_MAX         (UINT_MAX / 2 - 1000000)\n\nstatic DEFINE_SPINLOCK(usbfs_memory_usage_lock);\nstatic u64 usbfs_memory_usage;\t \n\n \nstatic int usbfs_increase_memory_usage(u64 amount)\n{\n\tu64 lim, total_mem;\n\tunsigned long flags;\n\tint ret;\n\n\tlim = READ_ONCE(usbfs_memory_mb);\n\tlim <<= 20;\n\n\tret = 0;\n\tspin_lock_irqsave(&usbfs_memory_usage_lock, flags);\n\ttotal_mem = usbfs_memory_usage + amount;\n\tif (lim > 0 && total_mem > lim)\n\t\tret = -ENOMEM;\n\telse\n\t\tusbfs_memory_usage = total_mem;\n\tspin_unlock_irqrestore(&usbfs_memory_usage_lock, flags);\n\n\treturn ret;\n}\n\n \nstatic void usbfs_decrease_memory_usage(u64 amount)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usbfs_memory_usage_lock, flags);\n\tif (amount > usbfs_memory_usage)\n\t\tusbfs_memory_usage = 0;\n\telse\n\t\tusbfs_memory_usage -= amount;\n\tspin_unlock_irqrestore(&usbfs_memory_usage_lock, flags);\n}\n\nstatic int connected(struct usb_dev_state *ps)\n{\n\treturn (!list_empty(&ps->list) &&\n\t\t\tps->dev->state != USB_STATE_NOTATTACHED);\n}\n\nstatic void dec_usb_memory_use_count(struct usb_memory *usbm, int *count)\n{\n\tstruct usb_dev_state *ps = usbm->ps;\n\tstruct usb_hcd *hcd = bus_to_hcd(ps->dev->bus);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\t--*count;\n\tif (usbm->urb_use_count == 0 && usbm->vma_use_count == 0) {\n\t\tlist_del(&usbm->memlist);\n\t\tspin_unlock_irqrestore(&ps->lock, flags);\n\n\t\thcd_buffer_free_pages(hcd, usbm->size,\n\t\t\t\tusbm->mem, usbm->dma_handle);\n\t\tusbfs_decrease_memory_usage(\n\t\t\tusbm->size + sizeof(struct usb_memory));\n\t\tkfree(usbm);\n\t} else {\n\t\tspin_unlock_irqrestore(&ps->lock, flags);\n\t}\n}\n\nstatic void usbdev_vm_open(struct vm_area_struct *vma)\n{\n\tstruct usb_memory *usbm = vma->vm_private_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usbm->ps->lock, flags);\n\t++usbm->vma_use_count;\n\tspin_unlock_irqrestore(&usbm->ps->lock, flags);\n}\n\nstatic void usbdev_vm_close(struct vm_area_struct *vma)\n{\n\tstruct usb_memory *usbm = vma->vm_private_data;\n\n\tdec_usb_memory_use_count(usbm, &usbm->vma_use_count);\n}\n\nstatic const struct vm_operations_struct usbdev_vm_ops = {\n\t.open = usbdev_vm_open,\n\t.close = usbdev_vm_close\n};\n\nstatic int usbdev_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct usb_memory *usbm = NULL;\n\tstruct usb_dev_state *ps = file->private_data;\n\tstruct usb_hcd *hcd = bus_to_hcd(ps->dev->bus);\n\tsize_t size = vma->vm_end - vma->vm_start;\n\tvoid *mem;\n\tunsigned long flags;\n\tdma_addr_t dma_handle = DMA_MAPPING_ERROR;\n\tint ret;\n\n\tret = usbfs_increase_memory_usage(size + sizeof(struct usb_memory));\n\tif (ret)\n\t\tgoto error;\n\n\tusbm = kzalloc(sizeof(struct usb_memory), GFP_KERNEL);\n\tif (!usbm) {\n\t\tret = -ENOMEM;\n\t\tgoto error_decrease_mem;\n\t}\n\n\tmem = hcd_buffer_alloc_pages(hcd,\n\t\t\tsize, GFP_USER | __GFP_NOWARN, &dma_handle);\n\tif (!mem) {\n\t\tret = -ENOMEM;\n\t\tgoto error_free_usbm;\n\t}\n\n\tmemset(mem, 0, size);\n\n\tusbm->mem = mem;\n\tusbm->dma_handle = dma_handle;\n\tusbm->size = size;\n\tusbm->ps = ps;\n\tusbm->vm_start = vma->vm_start;\n\tusbm->vma_use_count = 1;\n\tINIT_LIST_HEAD(&usbm->memlist);\n\n\t \n\tif (dma_handle == DMA_MAPPING_ERROR) {\n\t\tif (remap_pfn_range(vma, vma->vm_start,\n\t\t\t\t    virt_to_phys(usbm->mem) >> PAGE_SHIFT,\n\t\t\t\t    size, vma->vm_page_prot) < 0) {\n\t\t\tdec_usb_memory_use_count(usbm, &usbm->vma_use_count);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t} else {\n\t\tif (dma_mmap_coherent(hcd->self.sysdev, vma, mem, dma_handle,\n\t\t\t\t      size)) {\n\t\t\tdec_usb_memory_use_count(usbm, &usbm->vma_use_count);\n\t\t\treturn -EAGAIN;\n\t\t}\n\t}\n\n\tvm_flags_set(vma, VM_IO | VM_DONTEXPAND | VM_DONTDUMP);\n\tvma->vm_ops = &usbdev_vm_ops;\n\tvma->vm_private_data = usbm;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_add_tail(&usbm->memlist, &ps->memory_list);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\n\treturn 0;\n\nerror_free_usbm:\n\tkfree(usbm);\nerror_decrease_mem:\n\tusbfs_decrease_memory_usage(size + sizeof(struct usb_memory));\nerror:\n\treturn ret;\n}\n\nstatic ssize_t usbdev_read(struct file *file, char __user *buf, size_t nbytes,\n\t\t\t   loff_t *ppos)\n{\n\tstruct usb_dev_state *ps = file->private_data;\n\tstruct usb_device *dev = ps->dev;\n\tssize_t ret = 0;\n\tunsigned len;\n\tloff_t pos;\n\tint i;\n\n\tpos = *ppos;\n\tusb_lock_device(dev);\n\tif (!connected(ps)) {\n\t\tret = -ENODEV;\n\t\tgoto err;\n\t} else if (pos < 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (pos < sizeof(struct usb_device_descriptor)) {\n\t\t \n\t\tstruct usb_device_descriptor temp_desc;\n\n\t\tmemcpy(&temp_desc, &dev->descriptor, sizeof(dev->descriptor));\n\t\tle16_to_cpus(&temp_desc.bcdUSB);\n\t\tle16_to_cpus(&temp_desc.idVendor);\n\t\tle16_to_cpus(&temp_desc.idProduct);\n\t\tle16_to_cpus(&temp_desc.bcdDevice);\n\n\t\tlen = sizeof(struct usb_device_descriptor) - pos;\n\t\tif (len > nbytes)\n\t\t\tlen = nbytes;\n\t\tif (copy_to_user(buf, ((char *)&temp_desc) + pos, len)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto err;\n\t\t}\n\n\t\t*ppos += len;\n\t\tbuf += len;\n\t\tnbytes -= len;\n\t\tret += len;\n\t}\n\n\tpos = sizeof(struct usb_device_descriptor);\n\tfor (i = 0; nbytes && i < dev->descriptor.bNumConfigurations; i++) {\n\t\tstruct usb_config_descriptor *config =\n\t\t\t(struct usb_config_descriptor *)dev->rawdescriptors[i];\n\t\tunsigned int length = le16_to_cpu(config->wTotalLength);\n\n\t\tif (*ppos < pos + length) {\n\n\t\t\t \n\t\t\tunsigned alloclen =\n\t\t\t\tle16_to_cpu(dev->config[i].desc.wTotalLength);\n\n\t\t\tlen = length - (*ppos - pos);\n\t\t\tif (len > nbytes)\n\t\t\t\tlen = nbytes;\n\n\t\t\t \n\t\t\tif (alloclen > (*ppos - pos)) {\n\t\t\t\talloclen -= (*ppos - pos);\n\t\t\t\tif (copy_to_user(buf,\n\t\t\t\t    dev->rawdescriptors[i] + (*ppos - pos),\n\t\t\t\t    min(len, alloclen))) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t*ppos += len;\n\t\t\tbuf += len;\n\t\t\tnbytes -= len;\n\t\t\tret += len;\n\t\t}\n\n\t\tpos += length;\n\t}\n\nerr:\n\tusb_unlock_device(dev);\n\treturn ret;\n}\n\n \n\nstatic struct async *alloc_async(unsigned int numisoframes)\n{\n\tstruct async *as;\n\n\tas = kzalloc(sizeof(struct async), GFP_KERNEL);\n\tif (!as)\n\t\treturn NULL;\n\tas->urb = usb_alloc_urb(numisoframes, GFP_KERNEL);\n\tif (!as->urb) {\n\t\tkfree(as);\n\t\treturn NULL;\n\t}\n\treturn as;\n}\n\nstatic void free_async(struct async *as)\n{\n\tint i;\n\n\tput_pid(as->pid);\n\tif (as->cred)\n\t\tput_cred(as->cred);\n\tfor (i = 0; i < as->urb->num_sgs; i++) {\n\t\tif (sg_page(&as->urb->sg[i]))\n\t\t\tkfree(sg_virt(&as->urb->sg[i]));\n\t}\n\n\tkfree(as->urb->sg);\n\tif (as->usbm == NULL)\n\t\tkfree(as->urb->transfer_buffer);\n\telse\n\t\tdec_usb_memory_use_count(as->usbm, &as->usbm->urb_use_count);\n\n\tkfree(as->urb->setup_packet);\n\tusb_free_urb(as->urb);\n\tusbfs_decrease_memory_usage(as->mem_usage);\n\tkfree(as);\n}\n\nstatic void async_newpending(struct async *as)\n{\n\tstruct usb_dev_state *ps = as->ps;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_add_tail(&as->asynclist, &ps->async_pending);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n}\n\nstatic void async_removepending(struct async *as)\n{\n\tstruct usb_dev_state *ps = as->ps;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_del_init(&as->asynclist);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n}\n\nstatic struct async *async_getcompleted(struct usb_dev_state *ps)\n{\n\tunsigned long flags;\n\tstruct async *as = NULL;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tif (!list_empty(&ps->async_completed)) {\n\t\tas = list_entry(ps->async_completed.next, struct async,\n\t\t\t\tasynclist);\n\t\tlist_del_init(&as->asynclist);\n\t}\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\treturn as;\n}\n\nstatic struct async *async_getpending(struct usb_dev_state *ps,\n\t\t\t\t\t     void __user *userurb)\n{\n\tstruct async *as;\n\n\tlist_for_each_entry(as, &ps->async_pending, asynclist)\n\t\tif (as->userurb == userurb) {\n\t\t\tlist_del_init(&as->asynclist);\n\t\t\treturn as;\n\t\t}\n\n\treturn NULL;\n}\n\nstatic void snoop_urb(struct usb_device *udev,\n\t\tvoid __user *userurb, int pipe, unsigned length,\n\t\tint timeout_or_status, enum snoop_when when,\n\t\tunsigned char *data, unsigned data_len)\n{\n\tstatic const char *types[] = {\"isoc\", \"int\", \"ctrl\", \"bulk\"};\n\tstatic const char *dirs[] = {\"out\", \"in\"};\n\tint ep;\n\tconst char *t, *d;\n\n\tif (!usbfs_snoop)\n\t\treturn;\n\n\tep = usb_pipeendpoint(pipe);\n\tt = types[usb_pipetype(pipe)];\n\td = dirs[!!usb_pipein(pipe)];\n\n\tif (userurb) {\t\t \n\t\tif (when == SUBMIT)\n\t\t\tdev_info(&udev->dev, \"userurb %px, ep%d %s-%s, \"\n\t\t\t\t\t\"length %u\\n\",\n\t\t\t\t\tuserurb, ep, t, d, length);\n\t\telse\n\t\t\tdev_info(&udev->dev, \"userurb %px, ep%d %s-%s, \"\n\t\t\t\t\t\"actual_length %u status %d\\n\",\n\t\t\t\t\tuserurb, ep, t, d, length,\n\t\t\t\t\ttimeout_or_status);\n\t} else {\n\t\tif (when == SUBMIT)\n\t\t\tdev_info(&udev->dev, \"ep%d %s-%s, length %u, \"\n\t\t\t\t\t\"timeout %d\\n\",\n\t\t\t\t\tep, t, d, length, timeout_or_status);\n\t\telse\n\t\t\tdev_info(&udev->dev, \"ep%d %s-%s, actual_length %u, \"\n\t\t\t\t\t\"status %d\\n\",\n\t\t\t\t\tep, t, d, length, timeout_or_status);\n\t}\n\n\tdata_len = min(data_len, usbfs_snoop_max);\n\tif (data && data_len > 0) {\n\t\tprint_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1,\n\t\t\tdata, data_len, 1);\n\t}\n}\n\nstatic void snoop_urb_data(struct urb *urb, unsigned len)\n{\n\tint i, size;\n\n\tlen = min(len, usbfs_snoop_max);\n\tif (!usbfs_snoop || len == 0)\n\t\treturn;\n\n\tif (urb->num_sgs == 0) {\n\t\tprint_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1,\n\t\t\turb->transfer_buffer, len, 1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < urb->num_sgs && len; i++) {\n\t\tsize = (len > USB_SG_SIZE) ? USB_SG_SIZE : len;\n\t\tprint_hex_dump(KERN_DEBUG, \"data: \", DUMP_PREFIX_NONE, 32, 1,\n\t\t\tsg_virt(&urb->sg[i]), size, 1);\n\t\tlen -= size;\n\t}\n}\n\nstatic int copy_urb_data_to_user(u8 __user *userbuffer, struct urb *urb)\n{\n\tunsigned i, len, size;\n\n\tif (urb->number_of_packets > 0)\t\t \n\t\tlen = urb->transfer_buffer_length;\n\telse\t\t\t\t\t \n\t\tlen = urb->actual_length;\n\n\tif (urb->num_sgs == 0) {\n\t\tif (copy_to_user(userbuffer, urb->transfer_buffer, len))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\tfor (i = 0; i < urb->num_sgs && len; i++) {\n\t\tsize = (len > USB_SG_SIZE) ? USB_SG_SIZE : len;\n\t\tif (copy_to_user(userbuffer, sg_virt(&urb->sg[i]), size))\n\t\t\treturn -EFAULT;\n\t\tuserbuffer += size;\n\t\tlen -= size;\n\t}\n\n\treturn 0;\n}\n\n#define AS_CONTINUATION\t1\n#define AS_UNLINK\t2\n\nstatic void cancel_bulk_urbs(struct usb_dev_state *ps, unsigned bulk_addr)\n__releases(ps->lock)\n__acquires(ps->lock)\n{\n\tstruct urb *urb;\n\tstruct async *as;\n\n\t \n\tlist_for_each_entry(as, &ps->async_pending, asynclist) {\n\t\tif (as->bulk_addr == bulk_addr) {\n\t\t\tif (as->bulk_status != AS_CONTINUATION)\n\t\t\t\tgoto rescan;\n\t\t\tas->bulk_status = AS_UNLINK;\n\t\t\tas->bulk_addr = 0;\n\t\t}\n\t}\n\tps->disabled_bulk_eps |= (1 << bulk_addr);\n\n\t \n rescan:\n\tlist_for_each_entry_reverse(as, &ps->async_pending, asynclist) {\n\t\tif (as->bulk_status == AS_UNLINK) {\n\t\t\tas->bulk_status = 0;\t\t \n\t\t\turb = as->urb;\n\t\t\tusb_get_urb(urb);\n\t\t\tspin_unlock(&ps->lock);\t\t \n\t\t\tusb_unlink_urb(urb);\n\t\t\tusb_put_urb(urb);\n\t\t\tspin_lock(&ps->lock);\n\t\t\tgoto rescan;\n\t\t}\n\t}\n}\n\nstatic void async_completed(struct urb *urb)\n{\n\tstruct async *as = urb->context;\n\tstruct usb_dev_state *ps = as->ps;\n\tstruct pid *pid = NULL;\n\tconst struct cred *cred = NULL;\n\tunsigned long flags;\n\tsigval_t addr;\n\tint signr, errno;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_move_tail(&as->asynclist, &ps->async_completed);\n\tas->status = urb->status;\n\tsignr = as->signr;\n\tif (signr) {\n\t\terrno = as->status;\n\t\taddr = as->userurb_sigval;\n\t\tpid = get_pid(as->pid);\n\t\tcred = get_cred(as->cred);\n\t}\n\tsnoop(&urb->dev->dev, \"urb complete\\n\");\n\tsnoop_urb(urb->dev, as->userurb, urb->pipe, urb->actual_length,\n\t\t\tas->status, COMPLETE, NULL, 0);\n\tif (usb_urb_dir_in(urb))\n\t\tsnoop_urb_data(urb, urb->actual_length);\n\n\tif (as->status < 0 && as->bulk_addr && as->status != -ECONNRESET &&\n\t\t\tas->status != -ENOENT)\n\t\tcancel_bulk_urbs(ps, as->bulk_addr);\n\n\twake_up(&ps->wait);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\n\tif (signr) {\n\t\tkill_pid_usb_asyncio(signr, errno, addr, pid, cred);\n\t\tput_pid(pid);\n\t\tput_cred(cred);\n\t}\n}\n\nstatic void destroy_async(struct usb_dev_state *ps, struct list_head *list)\n{\n\tstruct urb *urb;\n\tstruct async *as;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\twhile (!list_empty(list)) {\n\t\tas = list_last_entry(list, struct async, asynclist);\n\t\tlist_del_init(&as->asynclist);\n\t\turb = as->urb;\n\t\tusb_get_urb(urb);\n\n\t\t \n\t\tspin_unlock_irqrestore(&ps->lock, flags);\n\t\tusb_kill_urb(urb);\n\t\tusb_put_urb(urb);\n\t\tspin_lock_irqsave(&ps->lock, flags);\n\t}\n\tspin_unlock_irqrestore(&ps->lock, flags);\n}\n\nstatic void destroy_async_on_interface(struct usb_dev_state *ps,\n\t\t\t\t       unsigned int ifnum)\n{\n\tstruct list_head *p, *q, hitlist;\n\tunsigned long flags;\n\n\tINIT_LIST_HEAD(&hitlist);\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_for_each_safe(p, q, &ps->async_pending)\n\t\tif (ifnum == list_entry(p, struct async, asynclist)->ifnum)\n\t\t\tlist_move_tail(p, &hitlist);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\tdestroy_async(ps, &hitlist);\n}\n\nstatic void destroy_all_async(struct usb_dev_state *ps)\n{\n\tdestroy_async(ps, &ps->async_pending);\n}\n\n \n\nstatic int driver_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\treturn -ENODEV;\n}\n\nstatic void driver_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_dev_state *ps = usb_get_intfdata(intf);\n\tunsigned int ifnum = intf->altsetting->desc.bInterfaceNumber;\n\n\tif (!ps)\n\t\treturn;\n\n\t \n\n\tif (likely(ifnum < 8*sizeof(ps->ifclaimed)))\n\t\tclear_bit(ifnum, &ps->ifclaimed);\n\telse\n\t\tdev_warn(&intf->dev, \"interface number %u out of range\\n\",\n\t\t\t ifnum);\n\n\tusb_set_intfdata(intf, NULL);\n\n\t \n\tdestroy_async_on_interface(ps, ifnum);\n}\n\n \nstatic int driver_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\treturn 0;\n}\n\nstatic int driver_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n \nvoid usbfs_notify_suspend(struct usb_device *udev)\n{\n\t \n}\n\nvoid usbfs_notify_resume(struct usb_device *udev)\n{\n\tstruct usb_dev_state *ps;\n\n\t \n\tmutex_lock(&usbfs_mutex);\n\tlist_for_each_entry(ps, &udev->filelist, list) {\n\t\tWRITE_ONCE(ps->not_yet_resumed, 0);\n\t\twake_up_all(&ps->wait_for_resume);\n\t}\n\tmutex_unlock(&usbfs_mutex);\n}\n#endif\n\nstruct usb_driver usbfs_driver = {\n\t.name =\t\t\"usbfs\",\n\t.probe =\tdriver_probe,\n\t.disconnect =\tdriver_disconnect,\n\t.suspend =\tdriver_suspend,\n\t.resume =\tdriver_resume,\n\t.supports_autosuspend = 1,\n};\n\nstatic int claimintf(struct usb_dev_state *ps, unsigned int ifnum)\n{\n\tstruct usb_device *dev = ps->dev;\n\tstruct usb_interface *intf;\n\tint err;\n\n\tif (ifnum >= 8*sizeof(ps->ifclaimed))\n\t\treturn -EINVAL;\n\t \n\tif (test_bit(ifnum, &ps->ifclaimed))\n\t\treturn 0;\n\n\tif (ps->privileges_dropped &&\n\t\t\t!test_bit(ifnum, &ps->interface_allowed_mask))\n\t\treturn -EACCES;\n\n\tintf = usb_ifnum_to_if(dev, ifnum);\n\tif (!intf)\n\t\terr = -ENOENT;\n\telse {\n\t\tunsigned int old_suppress;\n\n\t\t \n\t\told_suppress = dev_get_uevent_suppress(&intf->dev);\n\t\tdev_set_uevent_suppress(&intf->dev, 1);\n\t\terr = usb_driver_claim_interface(&usbfs_driver, intf, ps);\n\t\tdev_set_uevent_suppress(&intf->dev, old_suppress);\n\t}\n\tif (err == 0)\n\t\tset_bit(ifnum, &ps->ifclaimed);\n\treturn err;\n}\n\nstatic int releaseintf(struct usb_dev_state *ps, unsigned int ifnum)\n{\n\tstruct usb_device *dev;\n\tstruct usb_interface *intf;\n\tint err;\n\n\terr = -EINVAL;\n\tif (ifnum >= 8*sizeof(ps->ifclaimed))\n\t\treturn err;\n\tdev = ps->dev;\n\tintf = usb_ifnum_to_if(dev, ifnum);\n\tif (!intf)\n\t\terr = -ENOENT;\n\telse if (test_and_clear_bit(ifnum, &ps->ifclaimed)) {\n\t\tunsigned int old_suppress;\n\n\t\t \n\t\told_suppress = dev_get_uevent_suppress(&intf->dev);\n\t\tdev_set_uevent_suppress(&intf->dev, 1);\n\t\tusb_driver_release_interface(&usbfs_driver, intf);\n\t\tdev_set_uevent_suppress(&intf->dev, old_suppress);\n\t\terr = 0;\n\t}\n\treturn err;\n}\n\nstatic int checkintf(struct usb_dev_state *ps, unsigned int ifnum)\n{\n\tif (ps->dev->state != USB_STATE_CONFIGURED)\n\t\treturn -EHOSTUNREACH;\n\tif (ifnum >= 8*sizeof(ps->ifclaimed))\n\t\treturn -EINVAL;\n\tif (test_bit(ifnum, &ps->ifclaimed))\n\t\treturn 0;\n\t \n\tdev_warn(&ps->dev->dev, \"usbfs: process %d (%s) did not claim \"\n\t\t \"interface %u before use\\n\", task_pid_nr(current),\n\t\t current->comm, ifnum);\n\treturn claimintf(ps, ifnum);\n}\n\nstatic int findintfep(struct usb_device *dev, unsigned int ep)\n{\n\tunsigned int i, j, e;\n\tstruct usb_interface *intf;\n\tstruct usb_host_interface *alts;\n\tstruct usb_endpoint_descriptor *endpt;\n\n\tif (ep & ~(USB_DIR_IN|0xf))\n\t\treturn -EINVAL;\n\tif (!dev->actconfig)\n\t\treturn -ESRCH;\n\tfor (i = 0; i < dev->actconfig->desc.bNumInterfaces; i++) {\n\t\tintf = dev->actconfig->interface[i];\n\t\tfor (j = 0; j < intf->num_altsetting; j++) {\n\t\t\talts = &intf->altsetting[j];\n\t\t\tfor (e = 0; e < alts->desc.bNumEndpoints; e++) {\n\t\t\t\tendpt = &alts->endpoint[e].desc;\n\t\t\t\tif (endpt->bEndpointAddress == ep)\n\t\t\t\t\treturn alts->desc.bInterfaceNumber;\n\t\t\t}\n\t\t}\n\t}\n\treturn -ENOENT;\n}\n\nstatic int check_ctrlrecip(struct usb_dev_state *ps, unsigned int requesttype,\n\t\t\t   unsigned int request, unsigned int index)\n{\n\tint ret = 0;\n\tstruct usb_host_interface *alt_setting;\n\n\tif (ps->dev->state != USB_STATE_UNAUTHENTICATED\n\t && ps->dev->state != USB_STATE_ADDRESS\n\t && ps->dev->state != USB_STATE_CONFIGURED)\n\t\treturn -EHOSTUNREACH;\n\tif (USB_TYPE_VENDOR == (USB_TYPE_MASK & requesttype))\n\t\treturn 0;\n\n\t \n\tif (requesttype == 0xa1 && request == 0) {\n\t\talt_setting = usb_find_alt_setting(ps->dev->actconfig,\n\t\t\t\t\t\t   index >> 8, index & 0xff);\n\t\tif (alt_setting\n\t\t && alt_setting->desc.bInterfaceClass == USB_CLASS_PRINTER)\n\t\t\treturn 0;\n\t}\n\n\tindex &= 0xff;\n\tswitch (requesttype & USB_RECIP_MASK) {\n\tcase USB_RECIP_ENDPOINT:\n\t\tif ((index & ~USB_DIR_IN) == 0)\n\t\t\treturn 0;\n\t\tret = findintfep(ps->dev, index);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\tret = findintfep(ps->dev, index ^ 0x80);\n\t\t\tif (ret >= 0)\n\t\t\t\tdev_info(&ps->dev->dev,\n\t\t\t\t\t\"%s: process %i (%s) requesting ep %02x but needs %02x\\n\",\n\t\t\t\t\t__func__, task_pid_nr(current),\n\t\t\t\t\tcurrent->comm, index, index ^ 0x80);\n\t\t}\n\t\tif (ret >= 0)\n\t\t\tret = checkintf(ps, ret);\n\t\tbreak;\n\n\tcase USB_RECIP_INTERFACE:\n\t\tret = checkintf(ps, index);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct usb_host_endpoint *ep_to_host_endpoint(struct usb_device *dev,\n\t\t\t\t\t\t     unsigned char ep)\n{\n\tif (ep & USB_ENDPOINT_DIR_MASK)\n\t\treturn dev->ep_in[ep & USB_ENDPOINT_NUMBER_MASK];\n\telse\n\t\treturn dev->ep_out[ep & USB_ENDPOINT_NUMBER_MASK];\n}\n\nstatic int parse_usbdevfs_streams(struct usb_dev_state *ps,\n\t\t\t\t  struct usbdevfs_streams __user *streams,\n\t\t\t\t  unsigned int *num_streams_ret,\n\t\t\t\t  unsigned int *num_eps_ret,\n\t\t\t\t  struct usb_host_endpoint ***eps_ret,\n\t\t\t\t  struct usb_interface **intf_ret)\n{\n\tunsigned int i, num_streams, num_eps;\n\tstruct usb_host_endpoint **eps;\n\tstruct usb_interface *intf = NULL;\n\tunsigned char ep;\n\tint ifnum, ret;\n\n\tif (get_user(num_streams, &streams->num_streams) ||\n\t    get_user(num_eps, &streams->num_eps))\n\t\treturn -EFAULT;\n\n\tif (num_eps < 1 || num_eps > USB_MAXENDPOINTS)\n\t\treturn -EINVAL;\n\n\t \n\tif (num_streams_ret && (num_streams < 2 || num_streams > 65536))\n\t\treturn -EINVAL;\n\n\teps = kmalloc_array(num_eps, sizeof(*eps), GFP_KERNEL);\n\tif (!eps)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < num_eps; i++) {\n\t\tif (get_user(ep, &streams->eps[i])) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\teps[i] = ep_to_host_endpoint(ps->dev, ep);\n\t\tif (!eps[i]) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tifnum = findintfep(ps->dev, ep);\n\t\tif (ifnum < 0) {\n\t\t\tret = ifnum;\n\t\t\tgoto error;\n\t\t}\n\n\t\tif (i == 0) {\n\t\t\tret = checkintf(ps, ifnum);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tintf = usb_ifnum_to_if(ps->dev, ifnum);\n\t\t} else {\n\t\t\t \n\t\t\tif (ifnum != intf->altsetting->desc.bInterfaceNumber) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (num_streams_ret)\n\t\t*num_streams_ret = num_streams;\n\t*num_eps_ret = num_eps;\n\t*eps_ret = eps;\n\t*intf_ret = intf;\n\n\treturn 0;\n\nerror:\n\tkfree(eps);\n\treturn ret;\n}\n\nstatic struct usb_device *usbdev_lookup_by_devt(dev_t devt)\n{\n\tstruct device *dev;\n\n\tdev = bus_find_device_by_devt(&usb_bus_type, devt);\n\tif (!dev)\n\t\treturn NULL;\n\treturn to_usb_device(dev);\n}\n\n \nstatic int usbdev_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_device *dev = NULL;\n\tstruct usb_dev_state *ps;\n\tint ret;\n\n\tret = -ENOMEM;\n\tps = kzalloc(sizeof(struct usb_dev_state), GFP_KERNEL);\n\tif (!ps)\n\t\tgoto out_free_ps;\n\n\tret = -ENODEV;\n\n\t \n\tif (imajor(inode) == USB_DEVICE_MAJOR)\n\t\tdev = usbdev_lookup_by_devt(inode->i_rdev);\n\tif (!dev)\n\t\tgoto out_free_ps;\n\n\tusb_lock_device(dev);\n\tif (dev->state == USB_STATE_NOTATTACHED)\n\t\tgoto out_unlock_device;\n\n\tret = usb_autoresume_device(dev);\n\tif (ret)\n\t\tgoto out_unlock_device;\n\n\tps->dev = dev;\n\tps->file = file;\n\tps->interface_allowed_mask = 0xFFFFFFFF;  \n\tspin_lock_init(&ps->lock);\n\tINIT_LIST_HEAD(&ps->list);\n\tINIT_LIST_HEAD(&ps->async_pending);\n\tINIT_LIST_HEAD(&ps->async_completed);\n\tINIT_LIST_HEAD(&ps->memory_list);\n\tinit_waitqueue_head(&ps->wait);\n\tinit_waitqueue_head(&ps->wait_for_resume);\n\tps->disc_pid = get_pid(task_pid(current));\n\tps->cred = get_current_cred();\n\tsmp_wmb();\n\n\t \n\tlist_add_tail(&ps->list, &dev->filelist);\n\tfile->private_data = ps;\n\tusb_unlock_device(dev);\n\tsnoop(&dev->dev, \"opened by process %d: %s\\n\", task_pid_nr(current),\n\t\t\tcurrent->comm);\n\treturn ret;\n\n out_unlock_device:\n\tusb_unlock_device(dev);\n\tusb_put_dev(dev);\n out_free_ps:\n\tkfree(ps);\n\treturn ret;\n}\n\nstatic int usbdev_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_dev_state *ps = file->private_data;\n\tstruct usb_device *dev = ps->dev;\n\tunsigned int ifnum;\n\tstruct async *as;\n\n\tusb_lock_device(dev);\n\tusb_hub_release_all_ports(dev, ps);\n\n\t \n\tmutex_lock(&usbfs_mutex);\n\tlist_del_init(&ps->list);\n\tmutex_unlock(&usbfs_mutex);\n\n\tfor (ifnum = 0; ps->ifclaimed && ifnum < 8*sizeof(ps->ifclaimed);\n\t\t\tifnum++) {\n\t\tif (test_bit(ifnum, &ps->ifclaimed))\n\t\t\treleaseintf(ps, ifnum);\n\t}\n\tdestroy_all_async(ps);\n\tif (!ps->suspend_allowed)\n\t\tusb_autosuspend_device(dev);\n\tusb_unlock_device(dev);\n\tusb_put_dev(dev);\n\tput_pid(ps->disc_pid);\n\tput_cred(ps->cred);\n\n\tas = async_getcompleted(ps);\n\twhile (as) {\n\t\tfree_async(as);\n\t\tas = async_getcompleted(ps);\n\t}\n\n\tkfree(ps);\n\treturn 0;\n}\n\nstatic void usbfs_blocking_completion(struct urb *urb)\n{\n\tcomplete((struct completion *) urb->context);\n}\n\n \nstatic int usbfs_start_wait_urb(struct urb *urb, int timeout,\n\t\tunsigned int *actlen)\n{\n\tDECLARE_COMPLETION_ONSTACK(ctx);\n\tunsigned long expire;\n\tint rc;\n\n\turb->context = &ctx;\n\turb->complete = usbfs_blocking_completion;\n\t*actlen = 0;\n\trc = usb_submit_urb(urb, GFP_KERNEL);\n\tif (unlikely(rc))\n\t\treturn rc;\n\n\texpire = (timeout ? msecs_to_jiffies(timeout) : MAX_SCHEDULE_TIMEOUT);\n\trc = wait_for_completion_killable_timeout(&ctx, expire);\n\tif (rc <= 0) {\n\t\tusb_kill_urb(urb);\n\t\t*actlen = urb->actual_length;\n\t\tif (urb->status != -ENOENT)\n\t\t\t;\t \n\t\telse if (rc < 0)\n\t\t\treturn -EINTR;\n\t\telse\n\t\t\treturn -ETIMEDOUT;\n\t}\n\t*actlen = urb->actual_length;\n\treturn urb->status;\n}\n\nstatic int do_proc_control(struct usb_dev_state *ps,\n\t\tstruct usbdevfs_ctrltransfer *ctrl)\n{\n\tstruct usb_device *dev = ps->dev;\n\tunsigned int tmo;\n\tunsigned char *tbuf;\n\tunsigned int wLength, actlen;\n\tint i, pipe, ret;\n\tstruct urb *urb = NULL;\n\tstruct usb_ctrlrequest *dr = NULL;\n\n\tret = check_ctrlrecip(ps, ctrl->bRequestType, ctrl->bRequest,\n\t\t\t      ctrl->wIndex);\n\tif (ret)\n\t\treturn ret;\n\twLength = ctrl->wLength;\t \n\tif (wLength > PAGE_SIZE)\n\t\treturn -EINVAL;\n\tret = usbfs_increase_memory_usage(PAGE_SIZE + sizeof(struct urb) +\n\t\t\tsizeof(struct usb_ctrlrequest));\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENOMEM;\n\ttbuf = (unsigned char *)__get_free_page(GFP_KERNEL);\n\tif (!tbuf)\n\t\tgoto done;\n\turb = usb_alloc_urb(0, GFP_NOIO);\n\tif (!urb)\n\t\tgoto done;\n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_NOIO);\n\tif (!dr)\n\t\tgoto done;\n\n\tdr->bRequestType = ctrl->bRequestType;\n\tdr->bRequest = ctrl->bRequest;\n\tdr->wValue = cpu_to_le16(ctrl->wValue);\n\tdr->wIndex = cpu_to_le16(ctrl->wIndex);\n\tdr->wLength = cpu_to_le16(ctrl->wLength);\n\n\ttmo = ctrl->timeout;\n\tsnoop(&dev->dev, \"control urb: bRequestType=%02x \"\n\t\t\"bRequest=%02x wValue=%04x \"\n\t\t\"wIndex=%04x wLength=%04x\\n\",\n\t\tctrl->bRequestType, ctrl->bRequest, ctrl->wValue,\n\t\tctrl->wIndex, ctrl->wLength);\n\n\tif ((ctrl->bRequestType & USB_DIR_IN) && wLength) {\n\t\tpipe = usb_rcvctrlpipe(dev, 0);\n\t\tusb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,\n\t\t\t\twLength, NULL, NULL);\n\t\tsnoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, NULL, 0);\n\n\t\tusb_unlock_device(dev);\n\t\ti = usbfs_start_wait_urb(urb, tmo, &actlen);\n\n\t\t \n\t\tif (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)\n\t\t\tmsleep(200);\n\t\tusb_lock_device(dev);\n\t\tsnoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, tbuf, actlen);\n\t\tif (!i && actlen) {\n\t\t\tif (copy_to_user(ctrl->data, tbuf, actlen)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (wLength) {\n\t\t\tif (copy_from_user(tbuf, ctrl->data, wLength)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tpipe = usb_sndctrlpipe(dev, 0);\n\t\tusb_fill_control_urb(urb, dev, pipe, (unsigned char *) dr, tbuf,\n\t\t\t\twLength, NULL, NULL);\n\t\tsnoop_urb(dev, NULL, pipe, wLength, tmo, SUBMIT, tbuf, wLength);\n\n\t\tusb_unlock_device(dev);\n\t\ti = usbfs_start_wait_urb(urb, tmo, &actlen);\n\n\t\t \n\t\tif (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)\n\t\t\tmsleep(200);\n\t\tusb_lock_device(dev);\n\t\tsnoop_urb(dev, NULL, pipe, actlen, i, COMPLETE, NULL, 0);\n\t}\n\tif (i < 0 && i != -EPIPE) {\n\t\tdev_printk(KERN_DEBUG, &dev->dev, \"usbfs: USBDEVFS_CONTROL \"\n\t\t\t   \"failed cmd %s rqt %u rq %u len %u ret %d\\n\",\n\t\t\t   current->comm, ctrl->bRequestType, ctrl->bRequest,\n\t\t\t   ctrl->wLength, i);\n\t}\n\tret = (i < 0 ? i : actlen);\n\n done:\n\tkfree(dr);\n\tusb_free_urb(urb);\n\tfree_page((unsigned long) tbuf);\n\tusbfs_decrease_memory_usage(PAGE_SIZE + sizeof(struct urb) +\n\t\t\tsizeof(struct usb_ctrlrequest));\n\treturn ret;\n}\n\nstatic int proc_control(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_ctrltransfer ctrl;\n\n\tif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\n\t\treturn -EFAULT;\n\treturn do_proc_control(ps, &ctrl);\n}\n\nstatic int do_proc_bulk(struct usb_dev_state *ps,\n\t\tstruct usbdevfs_bulktransfer *bulk)\n{\n\tstruct usb_device *dev = ps->dev;\n\tunsigned int tmo, len1, len2, pipe;\n\tunsigned char *tbuf;\n\tint i, ret;\n\tstruct urb *urb = NULL;\n\tstruct usb_host_endpoint *ep;\n\n\tret = findintfep(ps->dev, bulk->ep);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = checkintf(ps, ret);\n\tif (ret)\n\t\treturn ret;\n\n\tlen1 = bulk->len;\n\tif (len1 < 0 || len1 >= (INT_MAX - sizeof(struct urb)))\n\t\treturn -EINVAL;\n\n\tif (bulk->ep & USB_DIR_IN)\n\t\tpipe = usb_rcvbulkpipe(dev, bulk->ep & 0x7f);\n\telse\n\t\tpipe = usb_sndbulkpipe(dev, bulk->ep & 0x7f);\n\tep = usb_pipe_endpoint(dev, pipe);\n\tif (!ep || !usb_endpoint_maxp(&ep->desc))\n\t\treturn -EINVAL;\n\tret = usbfs_increase_memory_usage(len1 + sizeof(struct urb));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = -ENOMEM;\n\ttbuf = kmalloc(len1, GFP_KERNEL | __GFP_NOWARN);\n\tif (!tbuf)\n\t\tgoto done;\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\tgoto done;\n\n\tif ((ep->desc.bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_INT) {\n\t\tpipe = (pipe & ~(3 << 30)) | (PIPE_INTERRUPT << 30);\n\t\tusb_fill_int_urb(urb, dev, pipe, tbuf, len1,\n\t\t\t\tNULL, NULL, ep->desc.bInterval);\n\t} else {\n\t\tusb_fill_bulk_urb(urb, dev, pipe, tbuf, len1, NULL, NULL);\n\t}\n\n\ttmo = bulk->timeout;\n\tif (bulk->ep & 0x80) {\n\t\tsnoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, NULL, 0);\n\n\t\tusb_unlock_device(dev);\n\t\ti = usbfs_start_wait_urb(urb, tmo, &len2);\n\t\tusb_lock_device(dev);\n\t\tsnoop_urb(dev, NULL, pipe, len2, i, COMPLETE, tbuf, len2);\n\n\t\tif (!i && len2) {\n\t\t\tif (copy_to_user(bulk->data, tbuf, len2)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (len1) {\n\t\t\tif (copy_from_user(tbuf, bulk->data, len1)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t\tsnoop_urb(dev, NULL, pipe, len1, tmo, SUBMIT, tbuf, len1);\n\n\t\tusb_unlock_device(dev);\n\t\ti = usbfs_start_wait_urb(urb, tmo, &len2);\n\t\tusb_lock_device(dev);\n\t\tsnoop_urb(dev, NULL, pipe, len2, i, COMPLETE, NULL, 0);\n\t}\n\tret = (i < 0 ? i : len2);\n done:\n\tusb_free_urb(urb);\n\tkfree(tbuf);\n\tusbfs_decrease_memory_usage(len1 + sizeof(struct urb));\n\treturn ret;\n}\n\nstatic int proc_bulk(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_bulktransfer bulk;\n\n\tif (copy_from_user(&bulk, arg, sizeof(bulk)))\n\t\treturn -EFAULT;\n\treturn do_proc_bulk(ps, &bulk);\n}\n\nstatic void check_reset_of_active_ep(struct usb_device *udev,\n\t\tunsigned int epnum, char *ioctl_name)\n{\n\tstruct usb_host_endpoint **eps;\n\tstruct usb_host_endpoint *ep;\n\n\teps = (epnum & USB_DIR_IN) ? udev->ep_in : udev->ep_out;\n\tep = eps[epnum & 0x0f];\n\tif (ep && !list_empty(&ep->urb_list))\n\t\tdev_warn(&udev->dev, \"Process %d (%s) called USBDEVFS_%s for active endpoint 0x%02x\\n\",\n\t\t\t\ttask_pid_nr(current), current->comm,\n\t\t\t\tioctl_name, epnum);\n}\n\nstatic int proc_resetep(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned int ep;\n\tint ret;\n\n\tif (get_user(ep, (unsigned int __user *)arg))\n\t\treturn -EFAULT;\n\tret = findintfep(ps->dev, ep);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = checkintf(ps, ret);\n\tif (ret)\n\t\treturn ret;\n\tcheck_reset_of_active_ep(ps->dev, ep, \"RESETEP\");\n\tusb_reset_endpoint(ps->dev, ep);\n\treturn 0;\n}\n\nstatic int proc_clearhalt(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned int ep;\n\tint pipe;\n\tint ret;\n\n\tif (get_user(ep, (unsigned int __user *)arg))\n\t\treturn -EFAULT;\n\tret = findintfep(ps->dev, ep);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = checkintf(ps, ret);\n\tif (ret)\n\t\treturn ret;\n\tcheck_reset_of_active_ep(ps->dev, ep, \"CLEAR_HALT\");\n\tif (ep & USB_DIR_IN)\n\t\tpipe = usb_rcvbulkpipe(ps->dev, ep & 0x7f);\n\telse\n\t\tpipe = usb_sndbulkpipe(ps->dev, ep & 0x7f);\n\n\treturn usb_clear_halt(ps->dev, pipe);\n}\n\nstatic int proc_getdriver(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_getdriver gd;\n\tstruct usb_interface *intf;\n\tint ret;\n\n\tif (copy_from_user(&gd, arg, sizeof(gd)))\n\t\treturn -EFAULT;\n\tintf = usb_ifnum_to_if(ps->dev, gd.interface);\n\tif (!intf || !intf->dev.driver)\n\t\tret = -ENODATA;\n\telse {\n\t\tstrscpy(gd.driver, intf->dev.driver->name,\n\t\t\t\tsizeof(gd.driver));\n\t\tret = (copy_to_user(arg, &gd, sizeof(gd)) ? -EFAULT : 0);\n\t}\n\treturn ret;\n}\n\nstatic int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_connectinfo ci;\n\n\tmemset(&ci, 0, sizeof(ci));\n\tci.devnum = ps->dev->devnum;\n\tci.slow = ps->dev->speed == USB_SPEED_LOW;\n\n\tif (copy_to_user(arg, &ci, sizeof(ci)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int proc_conninfo_ex(struct usb_dev_state *ps,\n\t\t\t    void __user *arg, size_t size)\n{\n\tstruct usbdevfs_conninfo_ex ci;\n\tstruct usb_device *udev = ps->dev;\n\n\tif (size < sizeof(ci.size))\n\t\treturn -EINVAL;\n\n\tmemset(&ci, 0, sizeof(ci));\n\tci.size = sizeof(ci);\n\tci.busnum = udev->bus->busnum;\n\tci.devnum = udev->devnum;\n\tci.speed = udev->speed;\n\n\twhile (udev && udev->portnum != 0) {\n\t\tif (++ci.num_ports <= ARRAY_SIZE(ci.ports))\n\t\t\tci.ports[ARRAY_SIZE(ci.ports) - ci.num_ports] =\n\t\t\t\t\tudev->portnum;\n\t\tudev = udev->parent;\n\t}\n\n\tif (ci.num_ports < ARRAY_SIZE(ci.ports))\n\t\tmemmove(&ci.ports[0],\n\t\t\t&ci.ports[ARRAY_SIZE(ci.ports) - ci.num_ports],\n\t\t\tci.num_ports);\n\n\tif (copy_to_user(arg, &ci, min(sizeof(ci), size)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int proc_resetdevice(struct usb_dev_state *ps)\n{\n\tstruct usb_host_config *actconfig = ps->dev->actconfig;\n\tstruct usb_interface *interface;\n\tint i, number;\n\n\t \n\tif (ps->privileges_dropped && actconfig) {\n\t\tfor (i = 0; i < actconfig->desc.bNumInterfaces; ++i) {\n\t\t\tinterface = actconfig->interface[i];\n\t\t\tnumber = interface->cur_altsetting->desc.bInterfaceNumber;\n\t\t\tif (usb_interface_claimed(interface) &&\n\t\t\t\t\t!test_bit(number, &ps->ifclaimed)) {\n\t\t\t\tdev_warn(&ps->dev->dev,\n\t\t\t\t\t\"usbfs: interface %d claimed by %s while '%s' resets device\\n\",\n\t\t\t\t\tnumber,\tinterface->dev.driver->name, current->comm);\n\t\t\t\treturn -EACCES;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn usb_reset_device(ps->dev);\n}\n\nstatic int proc_setintf(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_setinterface setintf;\n\tint ret;\n\n\tif (copy_from_user(&setintf, arg, sizeof(setintf)))\n\t\treturn -EFAULT;\n\tret = checkintf(ps, setintf.interface);\n\tif (ret)\n\t\treturn ret;\n\n\tdestroy_async_on_interface(ps, setintf.interface);\n\n\treturn usb_set_interface(ps->dev, setintf.interface,\n\t\t\tsetintf.altsetting);\n}\n\nstatic int proc_setconfig(struct usb_dev_state *ps, void __user *arg)\n{\n\tint u;\n\tint status = 0;\n\tstruct usb_host_config *actconfig;\n\n\tif (get_user(u, (int __user *)arg))\n\t\treturn -EFAULT;\n\n\tactconfig = ps->dev->actconfig;\n\n\t \n\tif (actconfig) {\n\t\tint i;\n\n\t\tfor (i = 0; i < actconfig->desc.bNumInterfaces; ++i) {\n\t\t\tif (usb_interface_claimed(actconfig->interface[i])) {\n\t\t\t\tdev_warn(&ps->dev->dev,\n\t\t\t\t\t\"usbfs: interface %d claimed by %s \"\n\t\t\t\t\t\"while '%s' sets config #%d\\n\",\n\t\t\t\t\tactconfig->interface[i]\n\t\t\t\t\t\t->cur_altsetting\n\t\t\t\t\t\t->desc.bInterfaceNumber,\n\t\t\t\t\tactconfig->interface[i]\n\t\t\t\t\t\t->dev.driver->name,\n\t\t\t\t\tcurrent->comm, u);\n\t\t\t\tstatus = -EBUSY;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (status == 0) {\n\t\tif (actconfig && actconfig->desc.bConfigurationValue == u)\n\t\t\tstatus = usb_reset_configuration(ps->dev);\n\t\telse\n\t\t\tstatus = usb_set_configuration(ps->dev, u);\n\t}\n\n\treturn status;\n}\n\nstatic struct usb_memory *\nfind_memory_area(struct usb_dev_state *ps, const struct usbdevfs_urb *uurb)\n{\n\tstruct usb_memory *usbm = NULL, *iter;\n\tunsigned long flags;\n\tunsigned long uurb_start = (unsigned long)uurb->buffer;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tlist_for_each_entry(iter, &ps->memory_list, memlist) {\n\t\tif (uurb_start >= iter->vm_start &&\n\t\t\t\tuurb_start < iter->vm_start + iter->size) {\n\t\t\tif (uurb->buffer_length > iter->vm_start + iter->size -\n\t\t\t\t\tuurb_start) {\n\t\t\t\tusbm = ERR_PTR(-EINVAL);\n\t\t\t} else {\n\t\t\t\tusbm = iter;\n\t\t\t\tusbm->urb_use_count++;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\treturn usbm;\n}\n\nstatic int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb,\n\t\t\tstruct usbdevfs_iso_packet_desc __user *iso_frame_desc,\n\t\t\tvoid __user *arg, sigval_t userurb_sigval)\n{\n\tstruct usbdevfs_iso_packet_desc *isopkt = NULL;\n\tstruct usb_host_endpoint *ep;\n\tstruct async *as = NULL;\n\tstruct usb_ctrlrequest *dr = NULL;\n\tunsigned int u, totlen, isofrmlen;\n\tint i, ret, num_sgs = 0, ifnum = -1;\n\tint number_of_packets = 0;\n\tunsigned int stream_id = 0;\n\tvoid *buf;\n\tbool is_in;\n\tbool allow_short = false;\n\tbool allow_zero = false;\n\tunsigned long mask =\tUSBDEVFS_URB_SHORT_NOT_OK |\n\t\t\t\tUSBDEVFS_URB_BULK_CONTINUATION |\n\t\t\t\tUSBDEVFS_URB_NO_FSBR |\n\t\t\t\tUSBDEVFS_URB_ZERO_PACKET |\n\t\t\t\tUSBDEVFS_URB_NO_INTERRUPT;\n\t \n\tif (uurb->type == USBDEVFS_URB_TYPE_ISO)\n\t\tmask |= USBDEVFS_URB_ISO_ASAP;\n\n\tif (uurb->flags & ~mask)\n\t\t\treturn -EINVAL;\n\n\tif ((unsigned int)uurb->buffer_length >= USBFS_XFER_MAX)\n\t\treturn -EINVAL;\n\tif (uurb->buffer_length > 0 && !uurb->buffer)\n\t\treturn -EINVAL;\n\tif (!(uurb->type == USBDEVFS_URB_TYPE_CONTROL &&\n\t    (uurb->endpoint & ~USB_ENDPOINT_DIR_MASK) == 0)) {\n\t\tifnum = findintfep(ps->dev, uurb->endpoint);\n\t\tif (ifnum < 0)\n\t\t\treturn ifnum;\n\t\tret = checkintf(ps, ifnum);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tep = ep_to_host_endpoint(ps->dev, uurb->endpoint);\n\tif (!ep)\n\t\treturn -ENOENT;\n\tis_in = (uurb->endpoint & USB_ENDPOINT_DIR_MASK) != 0;\n\n\tu = 0;\n\tswitch (uurb->type) {\n\tcase USBDEVFS_URB_TYPE_CONTROL:\n\t\tif (!usb_endpoint_xfer_control(&ep->desc))\n\t\t\treturn -EINVAL;\n\t\t \n\t\tif (uurb->buffer_length < 8)\n\t\t\treturn -EINVAL;\n\t\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\t\tif (!dr)\n\t\t\treturn -ENOMEM;\n\t\tif (copy_from_user(dr, uurb->buffer, 8)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\tif (uurb->buffer_length < (le16_to_cpu(dr->wLength) + 8)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\t\tret = check_ctrlrecip(ps, dr->bRequestType, dr->bRequest,\n\t\t\t\t      le16_to_cpu(dr->wIndex));\n\t\tif (ret)\n\t\t\tgoto error;\n\t\tuurb->buffer_length = le16_to_cpu(dr->wLength);\n\t\tuurb->buffer += 8;\n\t\tif ((dr->bRequestType & USB_DIR_IN) && uurb->buffer_length) {\n\t\t\tis_in = true;\n\t\t\tuurb->endpoint |= USB_DIR_IN;\n\t\t} else {\n\t\t\tis_in = false;\n\t\t\tuurb->endpoint &= ~USB_DIR_IN;\n\t\t}\n\t\tif (is_in)\n\t\t\tallow_short = true;\n\t\tsnoop(&ps->dev->dev, \"control urb: bRequestType=%02x \"\n\t\t\t\"bRequest=%02x wValue=%04x \"\n\t\t\t\"wIndex=%04x wLength=%04x\\n\",\n\t\t\tdr->bRequestType, dr->bRequest,\n\t\t\t__le16_to_cpu(dr->wValue),\n\t\t\t__le16_to_cpu(dr->wIndex),\n\t\t\t__le16_to_cpu(dr->wLength));\n\t\tu = sizeof(struct usb_ctrlrequest);\n\t\tbreak;\n\n\tcase USBDEVFS_URB_TYPE_BULK:\n\t\tif (!is_in)\n\t\t\tallow_zero = true;\n\t\telse\n\t\t\tallow_short = true;\n\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\treturn -EINVAL;\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t \n\t\t\tuurb->type = USBDEVFS_URB_TYPE_INTERRUPT;\n\t\t\tgoto interrupt_urb;\n\t\t}\n\t\tnum_sgs = DIV_ROUND_UP(uurb->buffer_length, USB_SG_SIZE);\n\t\tif (num_sgs == 1 || num_sgs > ps->dev->bus->sg_tablesize)\n\t\t\tnum_sgs = 0;\n\t\tif (ep->streams)\n\t\t\tstream_id = uurb->stream_id;\n\t\tbreak;\n\n\tcase USBDEVFS_URB_TYPE_INTERRUPT:\n\t\tif (!usb_endpoint_xfer_int(&ep->desc))\n\t\t\treturn -EINVAL;\n interrupt_urb:\n\t\tif (!is_in)\n\t\t\tallow_zero = true;\n\t\telse\n\t\t\tallow_short = true;\n\t\tbreak;\n\n\tcase USBDEVFS_URB_TYPE_ISO:\n\t\t \n\t\tif (uurb->number_of_packets < 1 ||\n\t\t    uurb->number_of_packets > 128)\n\t\t\treturn -EINVAL;\n\t\tif (!usb_endpoint_xfer_isoc(&ep->desc))\n\t\t\treturn -EINVAL;\n\t\tnumber_of_packets = uurb->number_of_packets;\n\t\tisofrmlen = sizeof(struct usbdevfs_iso_packet_desc) *\n\t\t\t\t   number_of_packets;\n\t\tisopkt = memdup_user(iso_frame_desc, isofrmlen);\n\t\tif (IS_ERR(isopkt)) {\n\t\t\tret = PTR_ERR(isopkt);\n\t\t\tisopkt = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tfor (totlen = u = 0; u < number_of_packets; u++) {\n\t\t\t \n\t\t\tif (isopkt[u].length > 98304) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttotlen += isopkt[u].length;\n\t\t}\n\t\tu *= sizeof(struct usb_iso_packet_descriptor);\n\t\tuurb->buffer_length = totlen;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (uurb->buffer_length > 0 &&\n\t\t\t!access_ok(uurb->buffer, uurb->buffer_length)) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\tas = alloc_async(number_of_packets);\n\tif (!as) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tas->usbm = find_memory_area(ps, uurb);\n\tif (IS_ERR(as->usbm)) {\n\t\tret = PTR_ERR(as->usbm);\n\t\tas->usbm = NULL;\n\t\tgoto error;\n\t}\n\n\t \n\tif (as->usbm)\n\t\tnum_sgs = 0;\n\n\tu += sizeof(struct async) + sizeof(struct urb) +\n\t     (as->usbm ? 0 : uurb->buffer_length) +\n\t     num_sgs * sizeof(struct scatterlist);\n\tret = usbfs_increase_memory_usage(u);\n\tif (ret)\n\t\tgoto error;\n\tas->mem_usage = u;\n\n\tif (num_sgs) {\n\t\tas->urb->sg = kmalloc_array(num_sgs,\n\t\t\t\t\t    sizeof(struct scatterlist),\n\t\t\t\t\t    GFP_KERNEL | __GFP_NOWARN);\n\t\tif (!as->urb->sg) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tas->urb->num_sgs = num_sgs;\n\t\tsg_init_table(as->urb->sg, as->urb->num_sgs);\n\n\t\ttotlen = uurb->buffer_length;\n\t\tfor (i = 0; i < as->urb->num_sgs; i++) {\n\t\t\tu = (totlen > USB_SG_SIZE) ? USB_SG_SIZE : totlen;\n\t\t\tbuf = kmalloc(u, GFP_KERNEL);\n\t\t\tif (!buf) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tsg_set_buf(&as->urb->sg[i], buf, u);\n\n\t\t\tif (!is_in) {\n\t\t\t\tif (copy_from_user(buf, uurb->buffer, u)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\tuurb->buffer += u;\n\t\t\t}\n\t\t\ttotlen -= u;\n\t\t}\n\t} else if (uurb->buffer_length > 0) {\n\t\tif (as->usbm) {\n\t\t\tunsigned long uurb_start = (unsigned long)uurb->buffer;\n\n\t\t\tas->urb->transfer_buffer = as->usbm->mem +\n\t\t\t\t\t(uurb_start - as->usbm->vm_start);\n\t\t} else {\n\t\t\tas->urb->transfer_buffer = kmalloc(uurb->buffer_length,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN);\n\t\t\tif (!as->urb->transfer_buffer) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (!is_in) {\n\t\t\t\tif (copy_from_user(as->urb->transfer_buffer,\n\t\t\t\t\t\t   uurb->buffer,\n\t\t\t\t\t\t   uurb->buffer_length)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t} else if (uurb->type == USBDEVFS_URB_TYPE_ISO) {\n\t\t\t\t \n\t\t\t\tmemset(as->urb->transfer_buffer, 0,\n\t\t\t\t\t\tuurb->buffer_length);\n\t\t\t}\n\t\t}\n\t}\n\tas->urb->dev = ps->dev;\n\tas->urb->pipe = (uurb->type << 30) |\n\t\t\t__create_pipe(ps->dev, uurb->endpoint & 0xf) |\n\t\t\t(uurb->endpoint & USB_DIR_IN);\n\n\t \n\tu = (is_in ? URB_DIR_IN : URB_DIR_OUT);\n\tif (uurb->flags & USBDEVFS_URB_ISO_ASAP)\n\t\tu |= URB_ISO_ASAP;\n\tif (allow_short && uurb->flags & USBDEVFS_URB_SHORT_NOT_OK)\n\t\tu |= URB_SHORT_NOT_OK;\n\tif (allow_zero && uurb->flags & USBDEVFS_URB_ZERO_PACKET)\n\t\tu |= URB_ZERO_PACKET;\n\tif (uurb->flags & USBDEVFS_URB_NO_INTERRUPT)\n\t\tu |= URB_NO_INTERRUPT;\n\tas->urb->transfer_flags = u;\n\n\tif (!allow_short && uurb->flags & USBDEVFS_URB_SHORT_NOT_OK)\n\t\tdev_warn(&ps->dev->dev, \"Requested nonsensical USBDEVFS_URB_SHORT_NOT_OK.\\n\");\n\tif (!allow_zero && uurb->flags & USBDEVFS_URB_ZERO_PACKET)\n\t\tdev_warn(&ps->dev->dev, \"Requested nonsensical USBDEVFS_URB_ZERO_PACKET.\\n\");\n\n\tas->urb->transfer_buffer_length = uurb->buffer_length;\n\tas->urb->setup_packet = (unsigned char *)dr;\n\tdr = NULL;\n\tas->urb->start_frame = uurb->start_frame;\n\tas->urb->number_of_packets = number_of_packets;\n\tas->urb->stream_id = stream_id;\n\n\tif (ep->desc.bInterval) {\n\t\tif (uurb->type == USBDEVFS_URB_TYPE_ISO ||\n\t\t\t\tps->dev->speed == USB_SPEED_HIGH ||\n\t\t\t\tps->dev->speed >= USB_SPEED_SUPER)\n\t\t\tas->urb->interval = 1 <<\n\t\t\t\t\tmin(15, ep->desc.bInterval - 1);\n\t\telse\n\t\t\tas->urb->interval = ep->desc.bInterval;\n\t}\n\n\tas->urb->context = as;\n\tas->urb->complete = async_completed;\n\tfor (totlen = u = 0; u < number_of_packets; u++) {\n\t\tas->urb->iso_frame_desc[u].offset = totlen;\n\t\tas->urb->iso_frame_desc[u].length = isopkt[u].length;\n\t\ttotlen += isopkt[u].length;\n\t}\n\tkfree(isopkt);\n\tisopkt = NULL;\n\tas->ps = ps;\n\tas->userurb = arg;\n\tas->userurb_sigval = userurb_sigval;\n\tif (as->usbm) {\n\t\tunsigned long uurb_start = (unsigned long)uurb->buffer;\n\n\t\tas->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tas->urb->transfer_dma = as->usbm->dma_handle +\n\t\t\t\t(uurb_start - as->usbm->vm_start);\n\t} else if (is_in && uurb->buffer_length > 0)\n\t\tas->userbuffer = uurb->buffer;\n\tas->signr = uurb->signr;\n\tas->ifnum = ifnum;\n\tas->pid = get_pid(task_pid(current));\n\tas->cred = get_current_cred();\n\tsnoop_urb(ps->dev, as->userurb, as->urb->pipe,\n\t\t\tas->urb->transfer_buffer_length, 0, SUBMIT,\n\t\t\tNULL, 0);\n\tif (!is_in)\n\t\tsnoop_urb_data(as->urb, as->urb->transfer_buffer_length);\n\n\tasync_newpending(as);\n\n\tif (usb_endpoint_xfer_bulk(&ep->desc)) {\n\t\tspin_lock_irq(&ps->lock);\n\n\t\t \n\t\tas->bulk_addr = usb_endpoint_num(&ep->desc) |\n\t\t\t((ep->desc.bEndpointAddress & USB_ENDPOINT_DIR_MASK)\n\t\t\t\t>> 3);\n\n\t\t \n\t\tif (uurb->flags & USBDEVFS_URB_BULK_CONTINUATION)\n\t\t\tas->bulk_status = AS_CONTINUATION;\n\t\telse\n\t\t\tps->disabled_bulk_eps &= ~(1 << as->bulk_addr);\n\n\t\t \n\t\tif (ps->disabled_bulk_eps & (1 << as->bulk_addr))\n\t\t\tret = -EREMOTEIO;\n\t\telse\n\t\t\tret = usb_submit_urb(as->urb, GFP_ATOMIC);\n\t\tspin_unlock_irq(&ps->lock);\n\t} else {\n\t\tret = usb_submit_urb(as->urb, GFP_KERNEL);\n\t}\n\n\tif (ret) {\n\t\tdev_printk(KERN_DEBUG, &ps->dev->dev,\n\t\t\t   \"usbfs: usb_submit_urb returned %d\\n\", ret);\n\t\tsnoop_urb(ps->dev, as->userurb, as->urb->pipe,\n\t\t\t\t0, ret, COMPLETE, NULL, 0);\n\t\tasync_removepending(as);\n\t\tgoto error;\n\t}\n\treturn 0;\n\n error:\n\tkfree(isopkt);\n\tkfree(dr);\n\tif (as)\n\t\tfree_async(as);\n\treturn ret;\n}\n\nstatic int proc_submiturb(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_urb uurb;\n\tsigval_t userurb_sigval;\n\n\tif (copy_from_user(&uurb, arg, sizeof(uurb)))\n\t\treturn -EFAULT;\n\n\tmemset(&userurb_sigval, 0, sizeof(userurb_sigval));\n\tuserurb_sigval.sival_ptr = arg;\n\n\treturn proc_do_submiturb(ps, &uurb,\n\t\t\t(((struct usbdevfs_urb __user *)arg)->iso_frame_desc),\n\t\t\targ, userurb_sigval);\n}\n\nstatic int proc_unlinkurb(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct urb *urb;\n\tstruct async *as;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ps->lock, flags);\n\tas = async_getpending(ps, arg);\n\tif (!as) {\n\t\tspin_unlock_irqrestore(&ps->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\turb = as->urb;\n\tusb_get_urb(urb);\n\tspin_unlock_irqrestore(&ps->lock, flags);\n\n\tusb_kill_urb(urb);\n\tusb_put_urb(urb);\n\n\treturn 0;\n}\n\nstatic void compute_isochronous_actual_length(struct urb *urb)\n{\n\tunsigned int i;\n\n\tif (urb->number_of_packets > 0) {\n\t\turb->actual_length = 0;\n\t\tfor (i = 0; i < urb->number_of_packets; i++)\n\t\t\turb->actual_length +=\n\t\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t}\n}\n\nstatic int processcompl(struct async *as, void __user * __user *arg)\n{\n\tstruct urb *urb = as->urb;\n\tstruct usbdevfs_urb __user *userurb = as->userurb;\n\tvoid __user *addr = as->userurb;\n\tunsigned int i;\n\n\tcompute_isochronous_actual_length(urb);\n\tif (as->userbuffer && urb->actual_length) {\n\t\tif (copy_urb_data_to_user(as->userbuffer, urb))\n\t\t\tgoto err_out;\n\t}\n\tif (put_user(as->status, &userurb->status))\n\t\tgoto err_out;\n\tif (put_user(urb->actual_length, &userurb->actual_length))\n\t\tgoto err_out;\n\tif (put_user(urb->error_count, &userurb->error_count))\n\t\tgoto err_out;\n\n\tif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tif (put_user(urb->iso_frame_desc[i].actual_length,\n\t\t\t\t     &userurb->iso_frame_desc[i].actual_length))\n\t\t\t\tgoto err_out;\n\t\t\tif (put_user(urb->iso_frame_desc[i].status,\n\t\t\t\t     &userurb->iso_frame_desc[i].status))\n\t\t\t\tgoto err_out;\n\t\t}\n\t}\n\n\tif (put_user(addr, (void __user * __user *)arg))\n\t\treturn -EFAULT;\n\treturn 0;\n\nerr_out:\n\treturn -EFAULT;\n}\n\nstatic struct async *reap_as(struct usb_dev_state *ps)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct async *as = NULL;\n\tstruct usb_device *dev = ps->dev;\n\n\tadd_wait_queue(&ps->wait, &wait);\n\tfor (;;) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tas = async_getcompleted(ps);\n\t\tif (as || !connected(ps))\n\t\t\tbreak;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tusb_unlock_device(dev);\n\t\tschedule();\n\t\tusb_lock_device(dev);\n\t}\n\tremove_wait_queue(&ps->wait, &wait);\n\tset_current_state(TASK_RUNNING);\n\treturn as;\n}\n\nstatic int proc_reapurb(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct async *as = reap_as(ps);\n\n\tif (as) {\n\t\tint retval;\n\n\t\tsnoop(&ps->dev->dev, \"reap %px\\n\", as->userurb);\n\t\tretval = processcompl(as, (void __user * __user *)arg);\n\t\tfree_async(as);\n\t\treturn retval;\n\t}\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\treturn -ENODEV;\n}\n\nstatic int proc_reapurbnonblock(struct usb_dev_state *ps, void __user *arg)\n{\n\tint retval;\n\tstruct async *as;\n\n\tas = async_getcompleted(ps);\n\tif (as) {\n\t\tsnoop(&ps->dev->dev, \"reap %px\\n\", as->userurb);\n\t\tretval = processcompl(as, (void __user * __user *)arg);\n\t\tfree_async(as);\n\t} else {\n\t\tretval = (connected(ps) ? -EAGAIN : -ENODEV);\n\t}\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int proc_control_compat(struct usb_dev_state *ps,\n\t\t\t\tstruct usbdevfs_ctrltransfer32 __user *p32)\n{\n\tstruct usbdevfs_ctrltransfer ctrl;\n\tu32 udata;\n\n\tif (copy_from_user(&ctrl, p32, sizeof(*p32) - sizeof(compat_caddr_t)) ||\n\t    get_user(udata, &p32->data))\n\t\treturn -EFAULT;\n\tctrl.data = compat_ptr(udata);\n\treturn do_proc_control(ps, &ctrl);\n}\n\nstatic int proc_bulk_compat(struct usb_dev_state *ps,\n\t\t\tstruct usbdevfs_bulktransfer32 __user *p32)\n{\n\tstruct usbdevfs_bulktransfer bulk;\n\tcompat_caddr_t addr;\n\n\tif (get_user(bulk.ep, &p32->ep) ||\n\t    get_user(bulk.len, &p32->len) ||\n\t    get_user(bulk.timeout, &p32->timeout) ||\n\t    get_user(addr, &p32->data))\n\t\treturn -EFAULT;\n\tbulk.data = compat_ptr(addr);\n\treturn do_proc_bulk(ps, &bulk);\n}\n\nstatic int proc_disconnectsignal_compat(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_disconnectsignal32 ds;\n\n\tif (copy_from_user(&ds, arg, sizeof(ds)))\n\t\treturn -EFAULT;\n\tps->discsignr = ds.signr;\n\tps->disccontext.sival_int = ds.context;\n\treturn 0;\n}\n\nstatic int get_urb32(struct usbdevfs_urb *kurb,\n\t\t     struct usbdevfs_urb32 __user *uurb)\n{\n\tstruct usbdevfs_urb32 urb32;\n\tif (copy_from_user(&urb32, uurb, sizeof(*uurb)))\n\t\treturn -EFAULT;\n\tkurb->type = urb32.type;\n\tkurb->endpoint = urb32.endpoint;\n\tkurb->status = urb32.status;\n\tkurb->flags = urb32.flags;\n\tkurb->buffer = compat_ptr(urb32.buffer);\n\tkurb->buffer_length = urb32.buffer_length;\n\tkurb->actual_length = urb32.actual_length;\n\tkurb->start_frame = urb32.start_frame;\n\tkurb->number_of_packets = urb32.number_of_packets;\n\tkurb->error_count = urb32.error_count;\n\tkurb->signr = urb32.signr;\n\tkurb->usercontext = compat_ptr(urb32.usercontext);\n\treturn 0;\n}\n\nstatic int proc_submiturb_compat(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_urb uurb;\n\tsigval_t userurb_sigval;\n\n\tif (get_urb32(&uurb, (struct usbdevfs_urb32 __user *)arg))\n\t\treturn -EFAULT;\n\n\tmemset(&userurb_sigval, 0, sizeof(userurb_sigval));\n\tuserurb_sigval.sival_int = ptr_to_compat(arg);\n\n\treturn proc_do_submiturb(ps, &uurb,\n\t\t\t((struct usbdevfs_urb32 __user *)arg)->iso_frame_desc,\n\t\t\targ, userurb_sigval);\n}\n\nstatic int processcompl_compat(struct async *as, void __user * __user *arg)\n{\n\tstruct urb *urb = as->urb;\n\tstruct usbdevfs_urb32 __user *userurb = as->userurb;\n\tvoid __user *addr = as->userurb;\n\tunsigned int i;\n\n\tcompute_isochronous_actual_length(urb);\n\tif (as->userbuffer && urb->actual_length) {\n\t\tif (copy_urb_data_to_user(as->userbuffer, urb))\n\t\t\treturn -EFAULT;\n\t}\n\tif (put_user(as->status, &userurb->status))\n\t\treturn -EFAULT;\n\tif (put_user(urb->actual_length, &userurb->actual_length))\n\t\treturn -EFAULT;\n\tif (put_user(urb->error_count, &userurb->error_count))\n\t\treturn -EFAULT;\n\n\tif (usb_endpoint_xfer_isoc(&urb->ep->desc)) {\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tif (put_user(urb->iso_frame_desc[i].actual_length,\n\t\t\t\t     &userurb->iso_frame_desc[i].actual_length))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(urb->iso_frame_desc[i].status,\n\t\t\t\t     &userurb->iso_frame_desc[i].status))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(ptr_to_compat(addr), (u32 __user *)arg))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int proc_reapurb_compat(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct async *as = reap_as(ps);\n\n\tif (as) {\n\t\tint retval;\n\n\t\tsnoop(&ps->dev->dev, \"reap %px\\n\", as->userurb);\n\t\tretval = processcompl_compat(as, (void __user * __user *)arg);\n\t\tfree_async(as);\n\t\treturn retval;\n\t}\n\tif (signal_pending(current))\n\t\treturn -EINTR;\n\treturn -ENODEV;\n}\n\nstatic int proc_reapurbnonblock_compat(struct usb_dev_state *ps, void __user *arg)\n{\n\tint retval;\n\tstruct async *as;\n\n\tas = async_getcompleted(ps);\n\tif (as) {\n\t\tsnoop(&ps->dev->dev, \"reap %px\\n\", as->userurb);\n\t\tretval = processcompl_compat(as, (void __user * __user *)arg);\n\t\tfree_async(as);\n\t} else {\n\t\tretval = (connected(ps) ? -EAGAIN : -ENODEV);\n\t}\n\treturn retval;\n}\n\n\n#endif\n\nstatic int proc_disconnectsignal(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_disconnectsignal ds;\n\n\tif (copy_from_user(&ds, arg, sizeof(ds)))\n\t\treturn -EFAULT;\n\tps->discsignr = ds.signr;\n\tps->disccontext.sival_ptr = ds.context;\n\treturn 0;\n}\n\nstatic int proc_claiminterface(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned int ifnum;\n\n\tif (get_user(ifnum, (unsigned int __user *)arg))\n\t\treturn -EFAULT;\n\treturn claimintf(ps, ifnum);\n}\n\nstatic int proc_releaseinterface(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned int ifnum;\n\tint ret;\n\n\tif (get_user(ifnum, (unsigned int __user *)arg))\n\t\treturn -EFAULT;\n\tret = releaseintf(ps, ifnum);\n\tif (ret < 0)\n\t\treturn ret;\n\tdestroy_async_on_interface(ps, ifnum);\n\treturn 0;\n}\n\nstatic int proc_ioctl(struct usb_dev_state *ps, struct usbdevfs_ioctl *ctl)\n{\n\tint\t\t\tsize;\n\tvoid\t\t\t*buf = NULL;\n\tint\t\t\tretval = 0;\n\tstruct usb_interface    *intf = NULL;\n\tstruct usb_driver       *driver = NULL;\n\n\tif (ps->privileges_dropped)\n\t\treturn -EACCES;\n\n\tif (!connected(ps))\n\t\treturn -ENODEV;\n\n\t \n\tsize = _IOC_SIZE(ctl->ioctl_code);\n\tif (size > 0) {\n\t\tbuf = kmalloc(size, GFP_KERNEL);\n\t\tif (buf == NULL)\n\t\t\treturn -ENOMEM;\n\t\tif ((_IOC_DIR(ctl->ioctl_code) & _IOC_WRITE)) {\n\t\t\tif (copy_from_user(buf, ctl->data, size)) {\n\t\t\t\tkfree(buf);\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tmemset(buf, 0, size);\n\t\t}\n\t}\n\n\tif (ps->dev->state != USB_STATE_CONFIGURED)\n\t\tretval = -EHOSTUNREACH;\n\telse if (!(intf = usb_ifnum_to_if(ps->dev, ctl->ifno)))\n\t\tretval = -EINVAL;\n\telse switch (ctl->ioctl_code) {\n\n\t \n\tcase USBDEVFS_DISCONNECT:\n\t\tif (intf->dev.driver) {\n\t\t\tdriver = to_usb_driver(intf->dev.driver);\n\t\t\tdev_dbg(&intf->dev, \"disconnect by usbfs\\n\");\n\t\t\tusb_driver_release_interface(driver, intf);\n\t\t} else\n\t\t\tretval = -ENODATA;\n\t\tbreak;\n\n\t \n\tcase USBDEVFS_CONNECT:\n\t\tif (!intf->dev.driver)\n\t\t\tretval = device_attach(&intf->dev);\n\t\telse\n\t\t\tretval = -EBUSY;\n\t\tbreak;\n\n\t \n\tdefault:\n\t\tif (intf->dev.driver)\n\t\t\tdriver = to_usb_driver(intf->dev.driver);\n\t\tif (driver == NULL || driver->unlocked_ioctl == NULL) {\n\t\t\tretval = -ENOTTY;\n\t\t} else {\n\t\t\tretval = driver->unlocked_ioctl(intf, ctl->ioctl_code, buf);\n\t\t\tif (retval == -ENOIOCTLCMD)\n\t\t\t\tretval = -ENOTTY;\n\t\t}\n\t}\n\n\t \n\tif (retval >= 0\n\t\t\t&& (_IOC_DIR(ctl->ioctl_code) & _IOC_READ) != 0\n\t\t\t&& size > 0\n\t\t\t&& copy_to_user(ctl->data, buf, size) != 0)\n\t\tretval = -EFAULT;\n\n\tkfree(buf);\n\treturn retval;\n}\n\nstatic int proc_ioctl_default(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_ioctl\tctrl;\n\n\tif (copy_from_user(&ctrl, arg, sizeof(ctrl)))\n\t\treturn -EFAULT;\n\treturn proc_ioctl(ps, &ctrl);\n}\n\n#ifdef CONFIG_COMPAT\nstatic int proc_ioctl_compat(struct usb_dev_state *ps, compat_uptr_t arg)\n{\n\tstruct usbdevfs_ioctl32 ioc32;\n\tstruct usbdevfs_ioctl ctrl;\n\n\tif (copy_from_user(&ioc32, compat_ptr(arg), sizeof(ioc32)))\n\t\treturn -EFAULT;\n\tctrl.ifno = ioc32.ifno;\n\tctrl.ioctl_code = ioc32.ioctl_code;\n\tctrl.data = compat_ptr(ioc32.data);\n\treturn proc_ioctl(ps, &ctrl);\n}\n#endif\n\nstatic int proc_claim_port(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned portnum;\n\tint rc;\n\n\tif (get_user(portnum, (unsigned __user *) arg))\n\t\treturn -EFAULT;\n\trc = usb_hub_claim_port(ps->dev, portnum, ps);\n\tif (rc == 0)\n\t\tsnoop(&ps->dev->dev, \"port %d claimed by process %d: %s\\n\",\n\t\t\tportnum, task_pid_nr(current), current->comm);\n\treturn rc;\n}\n\nstatic int proc_release_port(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned portnum;\n\n\tif (get_user(portnum, (unsigned __user *) arg))\n\t\treturn -EFAULT;\n\treturn usb_hub_release_port(ps->dev, portnum, ps);\n}\n\nstatic int proc_get_capabilities(struct usb_dev_state *ps, void __user *arg)\n{\n\t__u32 caps;\n\n\tcaps = USBDEVFS_CAP_ZERO_PACKET | USBDEVFS_CAP_NO_PACKET_SIZE_LIM |\n\t\t\tUSBDEVFS_CAP_REAP_AFTER_DISCONNECT | USBDEVFS_CAP_MMAP |\n\t\t\tUSBDEVFS_CAP_DROP_PRIVILEGES |\n\t\t\tUSBDEVFS_CAP_CONNINFO_EX | MAYBE_CAP_SUSPEND;\n\tif (!ps->dev->bus->no_stop_on_short)\n\t\tcaps |= USBDEVFS_CAP_BULK_CONTINUATION;\n\tif (ps->dev->bus->sg_tablesize)\n\t\tcaps |= USBDEVFS_CAP_BULK_SCATTER_GATHER;\n\n\tif (put_user(caps, (__u32 __user *)arg))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int proc_disconnect_claim(struct usb_dev_state *ps, void __user *arg)\n{\n\tstruct usbdevfs_disconnect_claim dc;\n\tstruct usb_interface *intf;\n\n\tif (copy_from_user(&dc, arg, sizeof(dc)))\n\t\treturn -EFAULT;\n\n\tintf = usb_ifnum_to_if(ps->dev, dc.interface);\n\tif (!intf)\n\t\treturn -EINVAL;\n\n\tif (intf->dev.driver) {\n\t\tstruct usb_driver *driver = to_usb_driver(intf->dev.driver);\n\n\t\tif (ps->privileges_dropped)\n\t\t\treturn -EACCES;\n\n\t\tif ((dc.flags & USBDEVFS_DISCONNECT_CLAIM_IF_DRIVER) &&\n\t\t\t\tstrncmp(dc.driver, intf->dev.driver->name,\n\t\t\t\t\tsizeof(dc.driver)) != 0)\n\t\t\treturn -EBUSY;\n\n\t\tif ((dc.flags & USBDEVFS_DISCONNECT_CLAIM_EXCEPT_DRIVER) &&\n\t\t\t\tstrncmp(dc.driver, intf->dev.driver->name,\n\t\t\t\t\tsizeof(dc.driver)) == 0)\n\t\t\treturn -EBUSY;\n\n\t\tdev_dbg(&intf->dev, \"disconnect by usbfs\\n\");\n\t\tusb_driver_release_interface(driver, intf);\n\t}\n\n\treturn claimintf(ps, dc.interface);\n}\n\nstatic int proc_alloc_streams(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned num_streams, num_eps;\n\tstruct usb_host_endpoint **eps;\n\tstruct usb_interface *intf;\n\tint r;\n\n\tr = parse_usbdevfs_streams(ps, arg, &num_streams, &num_eps,\n\t\t\t\t   &eps, &intf);\n\tif (r)\n\t\treturn r;\n\n\tdestroy_async_on_interface(ps,\n\t\t\t\t   intf->altsetting[0].desc.bInterfaceNumber);\n\n\tr = usb_alloc_streams(intf, eps, num_eps, num_streams, GFP_KERNEL);\n\tkfree(eps);\n\treturn r;\n}\n\nstatic int proc_free_streams(struct usb_dev_state *ps, void __user *arg)\n{\n\tunsigned num_eps;\n\tstruct usb_host_endpoint **eps;\n\tstruct usb_interface *intf;\n\tint r;\n\n\tr = parse_usbdevfs_streams(ps, arg, NULL, &num_eps, &eps, &intf);\n\tif (r)\n\t\treturn r;\n\n\tdestroy_async_on_interface(ps,\n\t\t\t\t   intf->altsetting[0].desc.bInterfaceNumber);\n\n\tr = usb_free_streams(intf, eps, num_eps, GFP_KERNEL);\n\tkfree(eps);\n\treturn r;\n}\n\nstatic int proc_drop_privileges(struct usb_dev_state *ps, void __user *arg)\n{\n\tu32 data;\n\n\tif (copy_from_user(&data, arg, sizeof(data)))\n\t\treturn -EFAULT;\n\n\t \n\tps->interface_allowed_mask &= data;\n\tps->privileges_dropped = true;\n\n\treturn 0;\n}\n\nstatic int proc_forbid_suspend(struct usb_dev_state *ps)\n{\n\tint ret = 0;\n\n\tif (ps->suspend_allowed) {\n\t\tret = usb_autoresume_device(ps->dev);\n\t\tif (ret == 0)\n\t\t\tps->suspend_allowed = false;\n\t\telse if (ret != -ENODEV)\n\t\t\tret = -EIO;\n\t}\n\treturn ret;\n}\n\nstatic int proc_allow_suspend(struct usb_dev_state *ps)\n{\n\tif (!connected(ps))\n\t\treturn -ENODEV;\n\n\tWRITE_ONCE(ps->not_yet_resumed, 1);\n\tif (!ps->suspend_allowed) {\n\t\tusb_autosuspend_device(ps->dev);\n\t\tps->suspend_allowed = true;\n\t}\n\treturn 0;\n}\n\nstatic int proc_wait_for_resume(struct usb_dev_state *ps)\n{\n\tint ret;\n\n\tusb_unlock_device(ps->dev);\n\tret = wait_event_interruptible(ps->wait_for_resume,\n\t\t\tREAD_ONCE(ps->not_yet_resumed) == 0);\n\tusb_lock_device(ps->dev);\n\n\tif (ret != 0)\n\t\treturn -EINTR;\n\treturn proc_forbid_suspend(ps);\n}\n\n \nstatic long usbdev_do_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\tvoid __user *p)\n{\n\tstruct usb_dev_state *ps = file->private_data;\n\tstruct inode *inode = file_inode(file);\n\tstruct usb_device *dev = ps->dev;\n\tint ret = -ENOTTY;\n\n\tif (!(file->f_mode & FMODE_WRITE))\n\t\treturn -EPERM;\n\n\tusb_lock_device(dev);\n\n\t \n\tswitch (cmd) {\n\tcase USBDEVFS_REAPURB:\n\t\tsnoop(&dev->dev, \"%s: REAPURB\\n\", __func__);\n\t\tret = proc_reapurb(ps, p);\n\t\tgoto done;\n\n\tcase USBDEVFS_REAPURBNDELAY:\n\t\tsnoop(&dev->dev, \"%s: REAPURBNDELAY\\n\", __func__);\n\t\tret = proc_reapurbnonblock(ps, p);\n\t\tgoto done;\n\n#ifdef CONFIG_COMPAT\n\tcase USBDEVFS_REAPURB32:\n\t\tsnoop(&dev->dev, \"%s: REAPURB32\\n\", __func__);\n\t\tret = proc_reapurb_compat(ps, p);\n\t\tgoto done;\n\n\tcase USBDEVFS_REAPURBNDELAY32:\n\t\tsnoop(&dev->dev, \"%s: REAPURBNDELAY32\\n\", __func__);\n\t\tret = proc_reapurbnonblock_compat(ps, p);\n\t\tgoto done;\n#endif\n\t}\n\n\tif (!connected(ps)) {\n\t\tusb_unlock_device(dev);\n\t\treturn -ENODEV;\n\t}\n\n\tswitch (cmd) {\n\tcase USBDEVFS_CONTROL:\n\t\tsnoop(&dev->dev, \"%s: CONTROL\\n\", __func__);\n\t\tret = proc_control(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_BULK:\n\t\tsnoop(&dev->dev, \"%s: BULK\\n\", __func__);\n\t\tret = proc_bulk(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_RESETEP:\n\t\tsnoop(&dev->dev, \"%s: RESETEP\\n\", __func__);\n\t\tret = proc_resetep(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_RESET:\n\t\tsnoop(&dev->dev, \"%s: RESET\\n\", __func__);\n\t\tret = proc_resetdevice(ps);\n\t\tbreak;\n\n\tcase USBDEVFS_CLEAR_HALT:\n\t\tsnoop(&dev->dev, \"%s: CLEAR_HALT\\n\", __func__);\n\t\tret = proc_clearhalt(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_GETDRIVER:\n\t\tsnoop(&dev->dev, \"%s: GETDRIVER\\n\", __func__);\n\t\tret = proc_getdriver(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_CONNECTINFO:\n\t\tsnoop(&dev->dev, \"%s: CONNECTINFO\\n\", __func__);\n\t\tret = proc_connectinfo(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_SETINTERFACE:\n\t\tsnoop(&dev->dev, \"%s: SETINTERFACE\\n\", __func__);\n\t\tret = proc_setintf(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_SETCONFIGURATION:\n\t\tsnoop(&dev->dev, \"%s: SETCONFIGURATION\\n\", __func__);\n\t\tret = proc_setconfig(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_SUBMITURB:\n\t\tsnoop(&dev->dev, \"%s: SUBMITURB\\n\", __func__);\n\t\tret = proc_submiturb(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n#ifdef CONFIG_COMPAT\n\tcase USBDEVFS_CONTROL32:\n\t\tsnoop(&dev->dev, \"%s: CONTROL32\\n\", __func__);\n\t\tret = proc_control_compat(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_BULK32:\n\t\tsnoop(&dev->dev, \"%s: BULK32\\n\", __func__);\n\t\tret = proc_bulk_compat(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_DISCSIGNAL32:\n\t\tsnoop(&dev->dev, \"%s: DISCSIGNAL32\\n\", __func__);\n\t\tret = proc_disconnectsignal_compat(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_SUBMITURB32:\n\t\tsnoop(&dev->dev, \"%s: SUBMITURB32\\n\", __func__);\n\t\tret = proc_submiturb_compat(ps, p);\n\t\tif (ret >= 0)\n\t\t\tinode->i_mtime = inode_set_ctime_current(inode);\n\t\tbreak;\n\n\tcase USBDEVFS_IOCTL32:\n\t\tsnoop(&dev->dev, \"%s: IOCTL32\\n\", __func__);\n\t\tret = proc_ioctl_compat(ps, ptr_to_compat(p));\n\t\tbreak;\n#endif\n\n\tcase USBDEVFS_DISCARDURB:\n\t\tsnoop(&dev->dev, \"%s: DISCARDURB %px\\n\", __func__, p);\n\t\tret = proc_unlinkurb(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_DISCSIGNAL:\n\t\tsnoop(&dev->dev, \"%s: DISCSIGNAL\\n\", __func__);\n\t\tret = proc_disconnectsignal(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_CLAIMINTERFACE:\n\t\tsnoop(&dev->dev, \"%s: CLAIMINTERFACE\\n\", __func__);\n\t\tret = proc_claiminterface(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_RELEASEINTERFACE:\n\t\tsnoop(&dev->dev, \"%s: RELEASEINTERFACE\\n\", __func__);\n\t\tret = proc_releaseinterface(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_IOCTL:\n\t\tsnoop(&dev->dev, \"%s: IOCTL\\n\", __func__);\n\t\tret = proc_ioctl_default(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_CLAIM_PORT:\n\t\tsnoop(&dev->dev, \"%s: CLAIM_PORT\\n\", __func__);\n\t\tret = proc_claim_port(ps, p);\n\t\tbreak;\n\n\tcase USBDEVFS_RELEASE_PORT:\n\t\tsnoop(&dev->dev, \"%s: RELEASE_PORT\\n\", __func__);\n\t\tret = proc_release_port(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_GET_CAPABILITIES:\n\t\tret = proc_get_capabilities(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_DISCONNECT_CLAIM:\n\t\tret = proc_disconnect_claim(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_ALLOC_STREAMS:\n\t\tret = proc_alloc_streams(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_FREE_STREAMS:\n\t\tret = proc_free_streams(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_DROP_PRIVILEGES:\n\t\tret = proc_drop_privileges(ps, p);\n\t\tbreak;\n\tcase USBDEVFS_GET_SPEED:\n\t\tret = ps->dev->speed;\n\t\tbreak;\n\tcase USBDEVFS_FORBID_SUSPEND:\n\t\tret = proc_forbid_suspend(ps);\n\t\tbreak;\n\tcase USBDEVFS_ALLOW_SUSPEND:\n\t\tret = proc_allow_suspend(ps);\n\t\tbreak;\n\tcase USBDEVFS_WAIT_FOR_RESUME:\n\t\tret = proc_wait_for_resume(ps);\n\t\tbreak;\n\t}\n\n\t \n\tswitch (cmd & ~IOCSIZE_MASK) {\n\tcase USBDEVFS_CONNINFO_EX(0):\n\t\tret = proc_conninfo_ex(ps, p, _IOC_SIZE(cmd));\n\t\tbreak;\n\t}\n\n done:\n\tusb_unlock_device(dev);\n\tif (ret >= 0)\n\t\tinode->i_atime = current_time(inode);\n\treturn ret;\n}\n\nstatic long usbdev_ioctl(struct file *file, unsigned int cmd,\n\t\t\tunsigned long arg)\n{\n\tint ret;\n\n\tret = usbdev_do_ioctl(file, cmd, (void __user *)arg);\n\n\treturn ret;\n}\n\n \nstatic __poll_t usbdev_poll(struct file *file,\n\t\t\t\tstruct poll_table_struct *wait)\n{\n\tstruct usb_dev_state *ps = file->private_data;\n\t__poll_t mask = 0;\n\n\tpoll_wait(file, &ps->wait, wait);\n\tif (file->f_mode & FMODE_WRITE && !list_empty(&ps->async_completed))\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\tif (!connected(ps))\n\t\tmask |= EPOLLHUP;\n\tif (list_empty(&ps->list))\n\t\tmask |= EPOLLERR;\n\treturn mask;\n}\n\nconst struct file_operations usbdev_file_operations = {\n\t.owner =\t  THIS_MODULE,\n\t.llseek =\t  no_seek_end_llseek,\n\t.read =\t\t  usbdev_read,\n\t.poll =\t\t  usbdev_poll,\n\t.unlocked_ioctl = usbdev_ioctl,\n\t.compat_ioctl =   compat_ptr_ioctl,\n\t.mmap =           usbdev_mmap,\n\t.open =\t\t  usbdev_open,\n\t.release =\t  usbdev_release,\n};\n\nstatic void usbdev_remove(struct usb_device *udev)\n{\n\tstruct usb_dev_state *ps;\n\n\t \n\tmutex_lock(&usbfs_mutex);\n\twhile (!list_empty(&udev->filelist)) {\n\t\tps = list_entry(udev->filelist.next, struct usb_dev_state, list);\n\t\tdestroy_all_async(ps);\n\t\twake_up_all(&ps->wait);\n\t\tWRITE_ONCE(ps->not_yet_resumed, 0);\n\t\twake_up_all(&ps->wait_for_resume);\n\t\tlist_del_init(&ps->list);\n\t\tif (ps->discsignr)\n\t\t\tkill_pid_usb_asyncio(ps->discsignr, EPIPE, ps->disccontext,\n\t\t\t\t\t     ps->disc_pid, ps->cred);\n\t}\n\tmutex_unlock(&usbfs_mutex);\n}\n\nstatic int usbdev_notify(struct notifier_block *self,\n\t\t\t       unsigned long action, void *dev)\n{\n\tswitch (action) {\n\tcase USB_DEVICE_ADD:\n\t\tbreak;\n\tcase USB_DEVICE_REMOVE:\n\t\tusbdev_remove(dev);\n\t\tbreak;\n\t}\n\treturn NOTIFY_OK;\n}\n\nstatic struct notifier_block usbdev_nb = {\n\t.notifier_call =\tusbdev_notify,\n};\n\nstatic struct cdev usb_device_cdev;\n\nint __init usb_devio_init(void)\n{\n\tint retval;\n\n\tretval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,\n\t\t\t\t\t\"usb_device\");\n\tif (retval) {\n\t\tprintk(KERN_ERR \"Unable to register minors for usb_device\\n\");\n\t\tgoto out;\n\t}\n\tcdev_init(&usb_device_cdev, &usbdev_file_operations);\n\tretval = cdev_add(&usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);\n\tif (retval) {\n\t\tprintk(KERN_ERR \"Unable to get usb_device major %d\\n\",\n\t\t       USB_DEVICE_MAJOR);\n\t\tgoto error_cdev;\n\t}\n\tusb_register_notify(&usbdev_nb);\nout:\n\treturn retval;\n\nerror_cdev:\n\tunregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);\n\tgoto out;\n}\n\nvoid usb_devio_cleanup(void)\n{\n\tusb_unregister_notify(&usbdev_nb);\n\tcdev_del(&usb_device_cdev);\n\tunregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}