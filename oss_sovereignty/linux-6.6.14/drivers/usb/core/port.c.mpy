{
  "module_name": "port.c",
  "hash_id": "444018eec77d1b45e01bf86edf4cc33393b4e18fe940af07a9fc01c5c603902f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/port.c",
  "human_readable_source": "\n \n\n#include <linux/kstrtox.h>\n#include <linux/slab.h>\n#include <linux/pm_qos.h>\n#include <linux/component.h>\n\n#include \"hub.h\"\n\nstatic int usb_port_block_power_off;\n\nstatic const struct attribute_group *port_dev_group[];\n\nstatic ssize_t early_stop_show(struct device *dev,\n\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", port_dev->early_stop ? \"yes\" : \"no\");\n}\n\nstatic ssize_t early_stop_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tbool value;\n\n\tif (kstrtobool(buf, &value))\n\t\treturn -EINVAL;\n\n\tif (value)\n\t\tport_dev->early_stop = 1;\n\telse\n\t\tport_dev->early_stop = 0;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(early_stop);\n\nstatic ssize_t disable_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *hdev = to_usb_device(dev->parent->parent);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_interface *intf = to_usb_interface(hub->intfdev);\n\tint port1 = port_dev->portnum;\n\tu16 portstatus, unused;\n\tbool disabled;\n\tint rc;\n\n\trc = usb_autopm_get_interface(intf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tusb_lock_device(hdev);\n\tif (hub->disconnected) {\n\t\trc = -ENODEV;\n\t\tgoto out_hdev_lock;\n\t}\n\n\tusb_hub_port_status(hub, port1, &portstatus, &unused);\n\tdisabled = !usb_port_is_power_on(hub, portstatus);\n\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\tusb_autopm_put_interface(intf);\n\n\tif (rc)\n\t\treturn rc;\n\n\treturn sysfs_emit(buf, \"%s\\n\", disabled ? \"1\" : \"0\");\n}\n\nstatic ssize_t disable_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *hdev = to_usb_device(dev->parent->parent);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_interface *intf = to_usb_interface(hub->intfdev);\n\tint port1 = port_dev->portnum;\n\tbool disabled;\n\tint rc;\n\n\trc = kstrtobool(buf, &disabled);\n\tif (rc)\n\t\treturn rc;\n\n\trc = usb_autopm_get_interface(intf);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tusb_lock_device(hdev);\n\tif (hub->disconnected) {\n\t\trc = -ENODEV;\n\t\tgoto out_hdev_lock;\n\t}\n\n\tif (disabled && port_dev->child)\n\t\tusb_disconnect(&port_dev->child);\n\n\trc = usb_hub_set_port_power(hdev, hub, port1, !disabled);\n\n\tif (disabled) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tif (!port_dev->is_superspeed)\n\t\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\t}\n\n\tif (!rc)\n\t\trc = count;\n\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\tusb_autopm_put_interface(intf);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(disable);\n\nstatic ssize_t location_show(struct device *dev,\n\t\t\t     struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", port_dev->location);\n}\nstatic DEVICE_ATTR_RO(location);\n\nstatic ssize_t connect_type_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tchar *result;\n\n\tswitch (port_dev->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tresult = \"hotplug\";\n\t\tbreak;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\t\tresult = \"hardwired\";\n\t\tbreak;\n\tcase USB_PORT_NOT_USED:\n\t\tresult = \"not used\";\n\t\tbreak;\n\tdefault:\n\t\tresult = \"unknown\";\n\t\tbreak;\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", result);\n}\nstatic DEVICE_ATTR_RO(connect_type);\n\nstatic ssize_t state_show(struct device *dev,\n\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tenum usb_device_state state = READ_ONCE(port_dev->state);\n\n\treturn sysfs_emit(buf, \"%s\\n\", usb_state_string(state));\n}\nstatic DEVICE_ATTR_RO(state);\n\nstatic ssize_t over_current_count_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\treturn sprintf(buf, \"%u\\n\", port_dev->over_current_count);\n}\nstatic DEVICE_ATTR_RO(over_current_count);\n\nstatic ssize_t quirks_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\treturn sprintf(buf, \"%08x\\n\", port_dev->quirks);\n}\n\nstatic ssize_t quirks_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tu32 value;\n\n\tif (kstrtou32(buf, 16, &value))\n\t\treturn -EINVAL;\n\n\tport_dev->quirks = value;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(quirks);\n\nstatic ssize_t usb3_lpm_permit_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tconst char *p;\n\n\tif (port_dev->usb3_lpm_u1_permit) {\n\t\tif (port_dev->usb3_lpm_u2_permit)\n\t\t\tp = \"u1_u2\";\n\t\telse\n\t\t\tp = \"u1\";\n\t} else {\n\t\tif (port_dev->usb3_lpm_u2_permit)\n\t\t\tp = \"u2\";\n\t\telse\n\t\t\tp = \"0\";\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", p);\n}\n\nstatic ssize_t usb3_lpm_permit_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_hcd *hcd;\n\n\tif (!strncmp(buf, \"u1_u2\", 5)) {\n\t\tport_dev->usb3_lpm_u1_permit = 1;\n\t\tport_dev->usb3_lpm_u2_permit = 1;\n\n\t} else if (!strncmp(buf, \"u1\", 2)) {\n\t\tport_dev->usb3_lpm_u1_permit = 1;\n\t\tport_dev->usb3_lpm_u2_permit = 0;\n\n\t} else if (!strncmp(buf, \"u2\", 2)) {\n\t\tport_dev->usb3_lpm_u1_permit = 0;\n\t\tport_dev->usb3_lpm_u2_permit = 1;\n\n\t} else if (!strncmp(buf, \"0\", 1)) {\n\t\tport_dev->usb3_lpm_u1_permit = 0;\n\t\tport_dev->usb3_lpm_u2_permit = 0;\n\t} else\n\t\treturn -EINVAL;\n\n\t \n\tif (udev) {\n\t\thcd = bus_to_hcd(udev->bus);\n\t\tif (!hcd)\n\t\t\treturn -EINVAL;\n\t\tusb_lock_device(udev);\n\t\tmutex_lock(hcd->bandwidth_mutex);\n\t\tif (!usb_disable_lpm(udev))\n\t\t\tusb_enable_lpm(udev);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tusb_unlock_device(udev);\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb3_lpm_permit);\n\nstatic struct attribute *port_dev_attrs[] = {\n\t&dev_attr_connect_type.attr,\n\t&dev_attr_state.attr,\n\t&dev_attr_location.attr,\n\t&dev_attr_quirks.attr,\n\t&dev_attr_over_current_count.attr,\n\t&dev_attr_disable.attr,\n\t&dev_attr_early_stop.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group port_dev_attr_grp = {\n\t.attrs = port_dev_attrs,\n};\n\nstatic const struct attribute_group *port_dev_group[] = {\n\t&port_dev_attr_grp,\n\tNULL,\n};\n\nstatic struct attribute *port_dev_usb3_attrs[] = {\n\t&dev_attr_usb3_lpm_permit.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group port_dev_usb3_attr_grp = {\n\t.attrs = port_dev_usb3_attrs,\n};\n\nstatic const struct attribute_group *port_dev_usb3_group[] = {\n\t&port_dev_attr_grp,\n\t&port_dev_usb3_attr_grp,\n\tNULL,\n};\n\nstatic void usb_port_device_release(struct device *dev)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\tkfree(port_dev->req);\n\tkfree(port_dev);\n}\n\n#ifdef CONFIG_PM\nstatic int usb_port_runtime_resume(struct device *dev)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *hdev = to_usb_device(dev->parent->parent);\n\tstruct usb_interface *intf = to_usb_interface(dev->parent);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_port *peer = port_dev->peer;\n\tint port1 = port_dev->portnum;\n\tint retval;\n\n\tif (!hub)\n\t\treturn -EINVAL;\n\tif (hub->in_reset) {\n\t\tset_bit(port1, hub->power_bits);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!port_dev->is_superspeed && peer)\n\t\tpm_runtime_get_sync(&peer->dev);\n\n\tretval = usb_autopm_get_interface(intf);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = usb_hub_set_port_power(hdev, hub, port1, true);\n\tmsleep(hub_power_on_good_delay(hub));\n\tif (udev && !retval) {\n\t\t \n\t\tif (hub_port_debounce_be_connected(hub, port1) < 0) {\n\t\t\tdev_dbg(&port_dev->dev, \"reconnect timeout\\n\");\n\t\t\tif (hub_is_superspeed(hdev))\n\t\t\t\tset_bit(port1, hub->warm_reset_bits);\n\t\t}\n\n\t\t \n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_request_resume(&udev->dev);\n\t\t}\n\t}\n\n\tusb_autopm_put_interface(intf);\n\n\treturn retval;\n}\n\nstatic int usb_port_runtime_suspend(struct device *dev)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\tstruct usb_device *hdev = to_usb_device(dev->parent->parent);\n\tstruct usb_interface *intf = to_usb_interface(dev->parent);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tstruct usb_port *peer = port_dev->peer;\n\tint port1 = port_dev->portnum;\n\tint retval;\n\n\tif (!hub)\n\t\treturn -EINVAL;\n\tif (hub->in_reset)\n\t\treturn -EBUSY;\n\n\tif (dev_pm_qos_flags(&port_dev->dev, PM_QOS_FLAG_NO_POWER_OFF)\n\t\t\t== PM_QOS_FLAGS_ALL)\n\t\treturn -EAGAIN;\n\n\tif (usb_port_block_power_off)\n\t\treturn -EBUSY;\n\n\tretval = usb_autopm_get_interface(intf);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = usb_hub_set_port_power(hdev, hub, port1, false);\n\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\tif (!port_dev->is_superspeed)\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\tusb_autopm_put_interface(intf);\n\n\t \n\tif (!port_dev->is_superspeed && peer)\n\t\tpm_runtime_put(&peer->dev);\n\n\treturn retval;\n}\n#endif\n\nstatic void usb_port_shutdown(struct device *dev)\n{\n\tstruct usb_port *port_dev = to_usb_port(dev);\n\n\tif (port_dev->child)\n\t\tusb_disable_usb2_hardware_lpm(port_dev->child);\n}\n\nstatic const struct dev_pm_ops usb_port_pm_ops = {\n#ifdef CONFIG_PM\n\t.runtime_suspend =\tusb_port_runtime_suspend,\n\t.runtime_resume =\tusb_port_runtime_resume,\n#endif\n};\n\nstruct device_type usb_port_device_type = {\n\t.name =\t\t\"usb_port\",\n\t.release =\tusb_port_device_release,\n\t.pm =\t\t&usb_port_pm_ops,\n};\n\nstatic struct device_driver usb_port_driver = {\n\t.name = \"usb\",\n\t.owner = THIS_MODULE,\n\t.shutdown = usb_port_shutdown,\n};\n\nstatic int link_peers(struct usb_port *left, struct usb_port *right)\n{\n\tstruct usb_port *ss_port, *hs_port;\n\tint rc;\n\n\tif (left->peer == right && right->peer == left)\n\t\treturn 0;\n\n\tif (left->peer || right->peer) {\n\t\tstruct usb_port *lpeer = left->peer;\n\t\tstruct usb_port *rpeer = right->peer;\n\t\tchar *method;\n\n\t\tif (left->location && left->location == right->location)\n\t\t\tmethod = \"location\";\n\t\telse\n\t\t\tmethod = \"default\";\n\n\t\tpr_debug(\"usb: failed to peer %s and %s by %s (%s:%s) (%s:%s)\\n\",\n\t\t\tdev_name(&left->dev), dev_name(&right->dev), method,\n\t\t\tdev_name(&left->dev),\n\t\t\tlpeer ? dev_name(&lpeer->dev) : \"none\",\n\t\t\tdev_name(&right->dev),\n\t\t\trpeer ? dev_name(&rpeer->dev) : \"none\");\n\t\treturn -EBUSY;\n\t}\n\n\trc = sysfs_create_link(&left->dev.kobj, &right->dev.kobj, \"peer\");\n\tif (rc)\n\t\treturn rc;\n\trc = sysfs_create_link(&right->dev.kobj, &left->dev.kobj, \"peer\");\n\tif (rc) {\n\t\tsysfs_remove_link(&left->dev.kobj, \"peer\");\n\t\treturn rc;\n\t}\n\n\t \n\tif (left->is_superspeed) {\n\t\tss_port = left;\n\t\tWARN_ON(right->is_superspeed);\n\t\ths_port = right;\n\t} else {\n\t\tss_port = right;\n\t\tWARN_ON(!right->is_superspeed);\n\t\ths_port = left;\n\t}\n\tpm_runtime_get_sync(&hs_port->dev);\n\n\tleft->peer = right;\n\tright->peer = left;\n\n\t \n\tpm_runtime_get_sync(&ss_port->dev);\n\tpm_runtime_put(&hs_port->dev);\n\n\treturn 0;\n}\n\nstatic void link_peers_report(struct usb_port *left, struct usb_port *right)\n{\n\tint rc;\n\n\trc = link_peers(left, right);\n\tif (rc == 0) {\n\t\tdev_dbg(&left->dev, \"peered to %s\\n\", dev_name(&right->dev));\n\t} else {\n\t\tdev_dbg(&left->dev, \"failed to peer to %s (%d)\\n\",\n\t\t\t\tdev_name(&right->dev), rc);\n\t\tpr_warn_once(\"usb: port power management may be unreliable\\n\");\n\t\tusb_port_block_power_off = 1;\n\t}\n}\n\nstatic void unlink_peers(struct usb_port *left, struct usb_port *right)\n{\n\tstruct usb_port *ss_port, *hs_port;\n\n\tWARN(right->peer != left || left->peer != right,\n\t\t\t\"%s and %s are not peers?\\n\",\n\t\t\tdev_name(&left->dev), dev_name(&right->dev));\n\n\t \n\tif (left->is_superspeed) {\n\t\tss_port = left;\n\t\ths_port = right;\n\t} else {\n\t\tss_port = right;\n\t\ths_port = left;\n\t}\n\n\tpm_runtime_get_sync(&hs_port->dev);\n\n\tsysfs_remove_link(&left->dev.kobj, \"peer\");\n\tright->peer = NULL;\n\tsysfs_remove_link(&right->dev.kobj, \"peer\");\n\tleft->peer = NULL;\n\n\t \n\tpm_runtime_put(&ss_port->dev);\n\n\t \n\tpm_runtime_put(&hs_port->dev);\n}\n\n \nstatic int match_location(struct usb_device *peer_hdev, void *p)\n{\n\tint port1;\n\tstruct usb_hcd *hcd, *peer_hcd;\n\tstruct usb_port *port_dev = p, *peer;\n\tstruct usb_hub *peer_hub = usb_hub_to_struct_hub(peer_hdev);\n\tstruct usb_device *hdev = to_usb_device(port_dev->dev.parent->parent);\n\n\tif (!peer_hub)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(hdev->bus);\n\tpeer_hcd = bus_to_hcd(peer_hdev->bus);\n\t \n\tif (peer_hcd != hcd->shared_hcd)\n\t\treturn 0;\n\n\tfor (port1 = 1; port1 <= peer_hdev->maxchild; port1++) {\n\t\tpeer = peer_hub->ports[port1 - 1];\n\t\tif (peer && peer->location == port_dev->location) {\n\t\t\tlink_peers_report(port_dev, peer);\n\t\t\treturn 1;  \n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nstatic void find_and_link_peer(struct usb_hub *hub, int port1)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1], *peer;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_device *peer_hdev;\n\tstruct usb_hub *peer_hub;\n\n\t \n\tif (port_dev->location) {\n\t\t \n\t\tusb_for_each_dev(port_dev, match_location);\n\t\treturn;\n\t} else if (!hdev->parent) {\n\t\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\t\tstruct usb_hcd *peer_hcd = hcd->shared_hcd;\n\n\t\tif (!peer_hcd)\n\t\t\treturn;\n\n\t\tpeer_hdev = peer_hcd->self.root_hub;\n\t} else {\n\t\tstruct usb_port *upstream;\n\t\tstruct usb_device *parent = hdev->parent;\n\t\tstruct usb_hub *parent_hub = usb_hub_to_struct_hub(parent);\n\n\t\tif (!parent_hub)\n\t\t\treturn;\n\n\t\tupstream = parent_hub->ports[hdev->portnum - 1];\n\t\tif (!upstream || !upstream->peer)\n\t\t\treturn;\n\n\t\tpeer_hdev = upstream->peer->child;\n\t}\n\n\tpeer_hub = usb_hub_to_struct_hub(peer_hdev);\n\tif (!peer_hub || port1 > peer_hdev->maxchild)\n\t\treturn;\n\n\t \n\tpeer = peer_hub->ports[port1 - 1];\n\tif (peer && peer->location == 0)\n\t\tlink_peers_report(port_dev, peer);\n}\n\nstatic int connector_bind(struct device *dev, struct device *connector, void *data)\n{\n\tint ret;\n\n\tret = sysfs_create_link(&dev->kobj, &connector->kobj, \"connector\");\n\tif (ret)\n\t\treturn ret;\n\n\tret = sysfs_create_link(&connector->kobj, &dev->kobj, dev_name(dev));\n\tif (ret)\n\t\tsysfs_remove_link(&dev->kobj, \"connector\");\n\n\treturn ret;\n}\n\nstatic void connector_unbind(struct device *dev, struct device *connector, void *data)\n{\n\tsysfs_remove_link(&connector->kobj, dev_name(dev));\n\tsysfs_remove_link(&dev->kobj, \"connector\");\n}\n\nstatic const struct component_ops connector_ops = {\n\t.bind = connector_bind,\n\t.unbind = connector_unbind,\n};\n\nint usb_hub_create_port_device(struct usb_hub *hub, int port1)\n{\n\tstruct usb_port *port_dev;\n\tstruct usb_device *hdev = hub->hdev;\n\tint retval;\n\n\tport_dev = kzalloc(sizeof(*port_dev), GFP_KERNEL);\n\tif (!port_dev)\n\t\treturn -ENOMEM;\n\n\tport_dev->req = kzalloc(sizeof(*(port_dev->req)), GFP_KERNEL);\n\tif (!port_dev->req) {\n\t\tkfree(port_dev);\n\t\treturn -ENOMEM;\n\t}\n\n\thub->ports[port1 - 1] = port_dev;\n\tport_dev->portnum = port1;\n\tset_bit(port1, hub->power_bits);\n\tport_dev->dev.parent = hub->intfdev;\n\tif (hub_is_superspeed(hdev)) {\n\t\tport_dev->usb3_lpm_u1_permit = 1;\n\t\tport_dev->usb3_lpm_u2_permit = 1;\n\t\tport_dev->dev.groups = port_dev_usb3_group;\n\t} else\n\t\tport_dev->dev.groups = port_dev_group;\n\tport_dev->dev.type = &usb_port_device_type;\n\tport_dev->dev.driver = &usb_port_driver;\n\tif (hub_is_superspeed(hub->hdev))\n\t\tport_dev->is_superspeed = 1;\n\tdev_set_name(&port_dev->dev, \"%s-port%d\", dev_name(&hub->hdev->dev),\n\t\t\tport1);\n\tmutex_init(&port_dev->status_lock);\n\tretval = device_register(&port_dev->dev);\n\tif (retval) {\n\t\tput_device(&port_dev->dev);\n\t\treturn retval;\n\t}\n\n\tport_dev->state_kn = sysfs_get_dirent(port_dev->dev.kobj.sd, \"state\");\n\tif (!port_dev->state_kn) {\n\t\tdev_err(&port_dev->dev, \"failed to sysfs_get_dirent 'state'\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_unregister;\n\t}\n\n\t \n\tretval = dev_pm_qos_add_request(&port_dev->dev, port_dev->req,\n\t\t\tDEV_PM_QOS_FLAGS, PM_QOS_FLAG_NO_POWER_OFF);\n\tif (retval < 0) {\n\t\tgoto err_put_kn;\n\t}\n\n\tretval = component_add(&port_dev->dev, &connector_ops);\n\tif (retval) {\n\t\tdev_warn(&port_dev->dev, \"failed to add component\\n\");\n\t\tgoto err_put_kn;\n\t}\n\n\tfind_and_link_peer(hub, port1);\n\n\t \n\tpm_runtime_set_active(&port_dev->dev);\n\tpm_runtime_get_noresume(&port_dev->dev);\n\tpm_runtime_enable(&port_dev->dev);\n\tdevice_enable_async_suspend(&port_dev->dev);\n\n\t \n\tif (!hub_is_port_power_switchable(hub))\n\t\treturn 0;\n\n\t \n\tretval = dev_pm_qos_expose_flags(&port_dev->dev,\n\t\t\tPM_QOS_FLAG_NO_POWER_OFF);\n\tif (retval < 0) {\n\t\tdev_warn(&port_dev->dev, \"failed to expose pm_qos_no_poweroff\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tretval = dev_pm_qos_remove_request(port_dev->req);\n\tif (retval >= 0) {\n\t\tkfree(port_dev->req);\n\t\tport_dev->req = NULL;\n\t}\n\treturn 0;\n\nerr_put_kn:\n\tsysfs_put(port_dev->state_kn);\nerr_unregister:\n\tdevice_unregister(&port_dev->dev);\n\n\treturn retval;\n}\n\nvoid usb_hub_remove_port_device(struct usb_hub *hub, int port1)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_port *peer;\n\n\tpeer = port_dev->peer;\n\tif (peer)\n\t\tunlink_peers(port_dev, peer);\n\tcomponent_del(&port_dev->dev, &connector_ops);\n\tsysfs_put(port_dev->state_kn);\n\tdevice_unregister(&port_dev->dev);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}