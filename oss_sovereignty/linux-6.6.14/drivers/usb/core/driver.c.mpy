{
  "module_name": "driver.c",
  "hash_id": "5d080c0273d86da29106e4f76ea364ab109a46c42cb657d14aba0fca496d83b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/driver.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/usb.h>\n#include <linux/usb/quirks.h>\n#include <linux/usb/hcd.h>\n\n#include \"usb.h\"\n\n\n \nssize_t usb_store_new_id(struct usb_dynids *dynids,\n\t\t\t const struct usb_device_id *id_table,\n\t\t\t struct device_driver *driver,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct usb_dynid *dynid;\n\tu32 idVendor = 0;\n\tu32 idProduct = 0;\n\tunsigned int bInterfaceClass = 0;\n\tu32 refVendor, refProduct;\n\tint fields = 0;\n\tint retval = 0;\n\n\tfields = sscanf(buf, \"%x %x %x %x %x\", &idVendor, &idProduct,\n\t\t\t&bInterfaceClass, &refVendor, &refProduct);\n\tif (fields < 2)\n\t\treturn -EINVAL;\n\n\tdynid = kzalloc(sizeof(*dynid), GFP_KERNEL);\n\tif (!dynid)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&dynid->node);\n\tdynid->id.idVendor = idVendor;\n\tdynid->id.idProduct = idProduct;\n\tdynid->id.match_flags = USB_DEVICE_ID_MATCH_DEVICE;\n\tif (fields > 2 && bInterfaceClass) {\n\t\tif (bInterfaceClass > 255) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tdynid->id.bInterfaceClass = (u8)bInterfaceClass;\n\t\tdynid->id.match_flags |= USB_DEVICE_ID_MATCH_INT_CLASS;\n\t}\n\n\tif (fields > 4) {\n\t\tconst struct usb_device_id *id = id_table;\n\n\t\tif (!id) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\n\t\tfor (; id->match_flags; id++)\n\t\t\tif (id->idVendor == refVendor && id->idProduct == refProduct)\n\t\t\t\tbreak;\n\n\t\tif (id->match_flags) {\n\t\t\tdynid->id.driver_info = id->driver_info;\n\t\t} else {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tspin_lock(&dynids->lock);\n\tlist_add_tail(&dynid->node, &dynids->list);\n\tspin_unlock(&dynids->lock);\n\n\tretval = driver_attach(driver);\n\n\tif (retval)\n\t\treturn retval;\n\treturn count;\n\nfail:\n\tkfree(dynid);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_store_new_id);\n\nssize_t usb_show_dynids(struct usb_dynids *dynids, char *buf)\n{\n\tstruct usb_dynid *dynid;\n\tsize_t count = 0;\n\n\tlist_for_each_entry(dynid, &dynids->list, node)\n\t\tif (dynid->id.bInterfaceClass != 0)\n\t\t\tcount += scnprintf(&buf[count], PAGE_SIZE - count, \"%04x %04x %02x\\n\",\n\t\t\t\t\t   dynid->id.idVendor, dynid->id.idProduct,\n\t\t\t\t\t   dynid->id.bInterfaceClass);\n\t\telse\n\t\t\tcount += scnprintf(&buf[count], PAGE_SIZE - count, \"%04x %04x\\n\",\n\t\t\t\t\t   dynid->id.idVendor, dynid->id.idProduct);\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(usb_show_dynids);\n\nstatic ssize_t new_id_show(struct device_driver *driver, char *buf)\n{\n\tstruct usb_driver *usb_drv = to_usb_driver(driver);\n\n\treturn usb_show_dynids(&usb_drv->dynids, buf);\n}\n\nstatic ssize_t new_id_store(struct device_driver *driver,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct usb_driver *usb_drv = to_usb_driver(driver);\n\n\treturn usb_store_new_id(&usb_drv->dynids, usb_drv->id_table, driver, buf, count);\n}\nstatic DRIVER_ATTR_RW(new_id);\n\n \nstatic ssize_t remove_id_store(struct device_driver *driver, const char *buf,\n\t\t\t       size_t count)\n{\n\tstruct usb_dynid *dynid, *n;\n\tstruct usb_driver *usb_driver = to_usb_driver(driver);\n\tu32 idVendor;\n\tu32 idProduct;\n\tint fields;\n\n\tfields = sscanf(buf, \"%x %x\", &idVendor, &idProduct);\n\tif (fields < 2)\n\t\treturn -EINVAL;\n\n\tspin_lock(&usb_driver->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &usb_driver->dynids.list, node) {\n\t\tstruct usb_device_id *id = &dynid->id;\n\n\t\tif ((id->idVendor == idVendor) &&\n\t\t    (id->idProduct == idProduct)) {\n\t\t\tlist_del(&dynid->node);\n\t\t\tkfree(dynid);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&usb_driver->dynids.lock);\n\treturn count;\n}\n\nstatic ssize_t remove_id_show(struct device_driver *driver, char *buf)\n{\n\treturn new_id_show(driver, buf);\n}\nstatic DRIVER_ATTR_RW(remove_id);\n\nstatic int usb_create_newid_files(struct usb_driver *usb_drv)\n{\n\tint error = 0;\n\n\tif (usb_drv->no_dynamic_id)\n\t\tgoto exit;\n\n\tif (usb_drv->probe != NULL) {\n\t\terror = driver_create_file(&usb_drv->drvwrap.driver,\n\t\t\t\t\t   &driver_attr_new_id);\n\t\tif (error == 0) {\n\t\t\terror = driver_create_file(&usb_drv->drvwrap.driver,\n\t\t\t\t\t&driver_attr_remove_id);\n\t\t\tif (error)\n\t\t\t\tdriver_remove_file(&usb_drv->drvwrap.driver,\n\t\t\t\t\t\t&driver_attr_new_id);\n\t\t}\n\t}\nexit:\n\treturn error;\n}\n\nstatic void usb_remove_newid_files(struct usb_driver *usb_drv)\n{\n\tif (usb_drv->no_dynamic_id)\n\t\treturn;\n\n\tif (usb_drv->probe != NULL) {\n\t\tdriver_remove_file(&usb_drv->drvwrap.driver,\n\t\t\t\t&driver_attr_remove_id);\n\t\tdriver_remove_file(&usb_drv->drvwrap.driver,\n\t\t\t\t   &driver_attr_new_id);\n\t}\n}\n\nstatic void usb_free_dynids(struct usb_driver *usb_drv)\n{\n\tstruct usb_dynid *dynid, *n;\n\n\tspin_lock(&usb_drv->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &usb_drv->dynids.list, node) {\n\t\tlist_del(&dynid->node);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&usb_drv->dynids.lock);\n}\n\nstatic const struct usb_device_id *usb_match_dynamic_id(struct usb_interface *intf,\n\t\t\t\t\t\t\tstruct usb_driver *drv)\n{\n\tstruct usb_dynid *dynid;\n\n\tspin_lock(&drv->dynids.lock);\n\tlist_for_each_entry(dynid, &drv->dynids.list, node) {\n\t\tif (usb_match_one_id(intf, &dynid->id)) {\n\t\t\tspin_unlock(&drv->dynids.lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&drv->dynids.lock);\n\treturn NULL;\n}\n\n\n \nstatic int usb_probe_device(struct device *dev)\n{\n\tstruct usb_device_driver *udriver = to_usb_device_driver(dev->driver);\n\tstruct usb_device *udev = to_usb_device(dev);\n\tint error = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\t \n\n\t \n\tif (!udriver->supports_autosuspend)\n\t\terror = usb_autoresume_device(udev);\n\tif (error)\n\t\treturn error;\n\n\tif (udriver->generic_subclass)\n\t\terror = usb_generic_driver_probe(udev);\n\tif (error)\n\t\treturn error;\n\n\t \n\terror = udriver->probe(udev);\n\tif (error == -ENODEV && udriver != &usb_generic_driver &&\n\t    (udriver->id_table || udriver->match)) {\n\t\tudev->use_generic_driver = 1;\n\t\treturn -EPROBE_DEFER;\n\t}\n\treturn error;\n}\n\n \nstatic int usb_unbind_device(struct device *dev)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tstruct usb_device_driver *udriver = to_usb_device_driver(dev->driver);\n\n\tif (udriver->disconnect)\n\t\tudriver->disconnect(udev);\n\tif (udriver->generic_subclass)\n\t\tusb_generic_driver_disconnect(udev);\n\tif (!udriver->supports_autosuspend)\n\t\tusb_autosuspend_device(udev);\n\treturn 0;\n}\n\n \nstatic int usb_probe_interface(struct device *dev)\n{\n\tstruct usb_driver *driver = to_usb_driver(dev->driver);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tconst struct usb_device_id *id;\n\tint error = -ENODEV;\n\tint lpm_disable_error = -ENODEV;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tintf->needs_binding = 0;\n\n\tif (usb_device_is_owned(udev))\n\t\treturn error;\n\n\tif (udev->authorized == 0) {\n\t\tdev_err(&intf->dev, \"Device is not authorized for usage\\n\");\n\t\treturn error;\n\t} else if (intf->authorized == 0) {\n\t\tdev_err(&intf->dev, \"Interface %d is not authorized for usage\\n\",\n\t\t\t\tintf->altsetting->desc.bInterfaceNumber);\n\t\treturn error;\n\t}\n\n\tid = usb_match_dynamic_id(intf, driver);\n\tif (!id)\n\t\tid = usb_match_id(intf, driver->id_table);\n\tif (!id)\n\t\treturn error;\n\n\tdev_dbg(dev, \"%s - got id\\n\", __func__);\n\n\terror = usb_autoresume_device(udev);\n\tif (error)\n\t\treturn error;\n\n\tintf->condition = USB_INTERFACE_BINDING;\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_suspend_ignore_children(dev, false);\n\tif (driver->supports_autosuspend)\n\t\tpm_runtime_enable(dev);\n\n\t \n\tif (driver->disable_hub_initiated_lpm) {\n\t\tlpm_disable_error = usb_unlocked_disable_lpm(udev);\n\t\tif (lpm_disable_error) {\n\t\t\tdev_err(&intf->dev, \"%s Failed to disable LPM for driver %s\\n\",\n\t\t\t\t__func__, driver->name);\n\t\t\terror = lpm_disable_error;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\t \n\tif (intf->needs_altsetting0) {\n\t\terror = usb_set_interface(udev, intf->altsetting[0].\n\t\t\t\tdesc.bInterfaceNumber, 0);\n\t\tif (error < 0)\n\t\t\tgoto err;\n\t\tintf->needs_altsetting0 = 0;\n\t}\n\n\terror = driver->probe(intf, id);\n\tif (error)\n\t\tgoto err;\n\n\tintf->condition = USB_INTERFACE_BOUND;\n\n\t \n\tif (!lpm_disable_error)\n\t\tusb_unlocked_enable_lpm(udev);\n\n\tusb_autosuspend_device(udev);\n\treturn error;\n\n err:\n\tusb_set_intfdata(intf, NULL);\n\tintf->needs_remote_wakeup = 0;\n\tintf->condition = USB_INTERFACE_UNBOUND;\n\n\t \n\tif (!lpm_disable_error)\n\t\tusb_unlocked_enable_lpm(udev);\n\n\t \n\tif (driver->supports_autosuspend)\n\t\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tusb_autosuspend_device(udev);\n\treturn error;\n}\n\n \nstatic int usb_unbind_interface(struct device *dev)\n{\n\tstruct usb_driver *driver = to_usb_driver(dev->driver);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_host_endpoint *ep, **eps = NULL;\n\tstruct usb_device *udev;\n\tint i, j, error, r;\n\tint lpm_disable_error = -ENODEV;\n\n\tintf->condition = USB_INTERFACE_UNBINDING;\n\n\t \n\tudev = interface_to_usbdev(intf);\n\terror = usb_autoresume_device(udev);\n\n\t \n\tif (driver->disable_hub_initiated_lpm)\n\t\tlpm_disable_error = usb_unlocked_disable_lpm(udev);\n\n\t \n\tif (!driver->soft_unbind || udev->state == USB_STATE_NOTATTACHED)\n\t\tusb_disable_interface(udev, intf, false);\n\n\tdriver->disconnect(intf);\n\n\t \n\tfor (i = 0, j = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) {\n\t\tep = &intf->cur_altsetting->endpoint[i];\n\t\tif (ep->streams == 0)\n\t\t\tcontinue;\n\t\tif (j == 0) {\n\t\t\teps = kmalloc_array(USB_MAXENDPOINTS, sizeof(void *),\n\t\t\t\t      GFP_KERNEL);\n\t\t\tif (!eps)\n\t\t\t\tbreak;\n\t\t}\n\t\teps[j++] = ep;\n\t}\n\tif (j) {\n\t\tusb_free_streams(intf, eps, j, GFP_KERNEL);\n\t\tkfree(eps);\n\t}\n\n\t \n\tif (intf->cur_altsetting->desc.bAlternateSetting == 0) {\n\t\t \n\t\tusb_enable_interface(udev, intf, false);\n\t} else if (!error && !intf->dev.power.is_prepared) {\n\t\tr = usb_set_interface(udev, intf->altsetting[0].\n\t\t\t\tdesc.bInterfaceNumber, 0);\n\t\tif (r < 0)\n\t\t\tintf->needs_altsetting0 = 1;\n\t} else {\n\t\tintf->needs_altsetting0 = 1;\n\t}\n\tusb_set_intfdata(intf, NULL);\n\n\tintf->condition = USB_INTERFACE_UNBOUND;\n\tintf->needs_remote_wakeup = 0;\n\n\t \n\tif (!lpm_disable_error)\n\t\tusb_unlocked_enable_lpm(udev);\n\n\t \n\tif (driver->supports_autosuspend)\n\t\tpm_runtime_disable(dev);\n\tpm_runtime_set_suspended(dev);\n\n\tif (!error)\n\t\tusb_autosuspend_device(udev);\n\n\treturn 0;\n}\n\n \nint usb_driver_claim_interface(struct usb_driver *driver,\n\t\t\t\tstruct usb_interface *iface, void *data)\n{\n\tstruct device *dev;\n\tint retval = 0;\n\n\tif (!iface)\n\t\treturn -ENODEV;\n\n\tdev = &iface->dev;\n\tif (dev->driver)\n\t\treturn -EBUSY;\n\n\t \n\tif (!iface->authorized)\n\t\treturn -ENODEV;\n\n\tdev->driver = &driver->drvwrap.driver;\n\tusb_set_intfdata(iface, data);\n\tiface->needs_binding = 0;\n\n\tiface->condition = USB_INTERFACE_BOUND;\n\n\t \n\tpm_suspend_ignore_children(dev, false);\n\tif (driver->supports_autosuspend)\n\t\tpm_runtime_enable(dev);\n\telse\n\t\tpm_runtime_set_active(dev);\n\n\t \n\tif (device_is_registered(dev))\n\t\tretval = device_bind_driver(dev);\n\n\tif (retval) {\n\t\tdev->driver = NULL;\n\t\tusb_set_intfdata(iface, NULL);\n\t\tiface->needs_remote_wakeup = 0;\n\t\tiface->condition = USB_INTERFACE_UNBOUND;\n\n\t\t \n\t\tif (driver->supports_autosuspend)\n\t\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_suspended(dev);\n\t}\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_driver_claim_interface);\n\n \nvoid usb_driver_release_interface(struct usb_driver *driver,\n\t\t\t\t\tstruct usb_interface *iface)\n{\n\tstruct device *dev = &iface->dev;\n\n\t \n\tif (!dev->driver || dev->driver != &driver->drvwrap.driver)\n\t\treturn;\n\n\t \n\tif (iface->condition != USB_INTERFACE_BOUND)\n\t\treturn;\n\tiface->condition = USB_INTERFACE_UNBINDING;\n\n\t \n\tif (device_is_registered(dev)) {\n\t\tdevice_release_driver(dev);\n\t} else {\n\t\tdevice_lock(dev);\n\t\tusb_unbind_interface(dev);\n\t\tdev->driver = NULL;\n\t\tdevice_unlock(dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_driver_release_interface);\n\n \nint usb_match_device(struct usb_device *dev, const struct usb_device_id *id)\n{\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&\n\t    id->idVendor != le16_to_cpu(dev->descriptor.idVendor))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_PRODUCT) &&\n\t    id->idProduct != le16_to_cpu(dev->descriptor.idProduct))\n\t\treturn 0;\n\n\t \n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_LO) &&\n\t    (id->bcdDevice_lo > le16_to_cpu(dev->descriptor.bcdDevice)))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_HI) &&\n\t    (id->bcdDevice_hi < le16_to_cpu(dev->descriptor.bcdDevice)))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_CLASS) &&\n\t    (id->bDeviceClass != dev->descriptor.bDeviceClass))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_SUBCLASS) &&\n\t    (id->bDeviceSubClass != dev->descriptor.bDeviceSubClass))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_DEV_PROTOCOL) &&\n\t    (id->bDeviceProtocol != dev->descriptor.bDeviceProtocol))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nint usb_match_one_id_intf(struct usb_device *dev,\n\t\t\t  struct usb_host_interface *intf,\n\t\t\t  const struct usb_device_id *id)\n{\n\t \n\tif (dev->descriptor.bDeviceClass == USB_CLASS_VENDOR_SPEC &&\n\t\t\t!(id->match_flags & USB_DEVICE_ID_MATCH_VENDOR) &&\n\t\t\t(id->match_flags & (USB_DEVICE_ID_MATCH_INT_CLASS |\n\t\t\t\tUSB_DEVICE_ID_MATCH_INT_SUBCLASS |\n\t\t\t\tUSB_DEVICE_ID_MATCH_INT_PROTOCOL |\n\t\t\t\tUSB_DEVICE_ID_MATCH_INT_NUMBER)))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_INT_CLASS) &&\n\t    (id->bInterfaceClass != intf->desc.bInterfaceClass))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_INT_SUBCLASS) &&\n\t    (id->bInterfaceSubClass != intf->desc.bInterfaceSubClass))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_INT_PROTOCOL) &&\n\t    (id->bInterfaceProtocol != intf->desc.bInterfaceProtocol))\n\t\treturn 0;\n\n\tif ((id->match_flags & USB_DEVICE_ID_MATCH_INT_NUMBER) &&\n\t    (id->bInterfaceNumber != intf->desc.bInterfaceNumber))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n \nint usb_match_one_id(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *intf;\n\tstruct usb_device *dev;\n\n\t \n\tif (id == NULL)\n\t\treturn 0;\n\n\tintf = interface->cur_altsetting;\n\tdev = interface_to_usbdev(interface);\n\n\tif (!usb_match_device(dev, id))\n\t\treturn 0;\n\n\treturn usb_match_one_id_intf(dev, intf, id);\n}\nEXPORT_SYMBOL_GPL(usb_match_one_id);\n\n \nconst struct usb_device_id *usb_match_id(struct usb_interface *interface,\n\t\t\t\t\t const struct usb_device_id *id)\n{\n\t \n\tif (id == NULL)\n\t\treturn NULL;\n\n\t \n\tfor (; id->idVendor || id->idProduct || id->bDeviceClass ||\n\t       id->bInterfaceClass || id->driver_info; id++) {\n\t\tif (usb_match_one_id(interface, id))\n\t\t\treturn id;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_match_id);\n\nconst struct usb_device_id *usb_device_match_id(struct usb_device *udev,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tif (!id)\n\t\treturn NULL;\n\n\tfor (; id->idVendor || id->idProduct ; id++) {\n\t\tif (usb_match_device(udev, id))\n\t\t\treturn id;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_device_match_id);\n\nbool usb_driver_applicable(struct usb_device *udev,\n\t\t\t   struct usb_device_driver *udrv)\n{\n\tif (udrv->id_table && udrv->match)\n\t\treturn usb_device_match_id(udev, udrv->id_table) != NULL &&\n\t\t       udrv->match(udev);\n\n\tif (udrv->id_table)\n\t\treturn usb_device_match_id(udev, udrv->id_table) != NULL;\n\n\tif (udrv->match)\n\t\treturn udrv->match(udev);\n\n\treturn false;\n}\n\nstatic int usb_device_match(struct device *dev, struct device_driver *drv)\n{\n\t \n\tif (is_usb_device(dev)) {\n\t\tstruct usb_device *udev;\n\t\tstruct usb_device_driver *udrv;\n\n\t\t \n\t\tif (!is_usb_device_driver(drv))\n\t\t\treturn 0;\n\n\t\tudev = to_usb_device(dev);\n\t\tudrv = to_usb_device_driver(drv);\n\n\t\t \n\t\tif (!udrv->id_table && !udrv->match)\n\t\t\treturn 1;\n\n\t\treturn usb_driver_applicable(udev, udrv);\n\n\t} else if (is_usb_interface(dev)) {\n\t\tstruct usb_interface *intf;\n\t\tstruct usb_driver *usb_drv;\n\t\tconst struct usb_device_id *id;\n\n\t\t \n\t\tif (is_usb_device_driver(drv))\n\t\t\treturn 0;\n\n\t\tintf = to_usb_interface(dev);\n\t\tusb_drv = to_usb_driver(drv);\n\n\t\tid = usb_match_id(intf, usb_drv->id_table);\n\t\tif (id)\n\t\t\treturn 1;\n\n\t\tid = usb_match_dynamic_id(intf, usb_drv);\n\t\tif (id)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct usb_device *usb_dev;\n\n\tif (is_usb_device(dev)) {\n\t\tusb_dev = to_usb_device(dev);\n\t} else if (is_usb_interface(dev)) {\n\t\tconst struct usb_interface *intf = to_usb_interface(dev);\n\n\t\tusb_dev = interface_to_usbdev(intf);\n\t} else {\n\t\treturn 0;\n\t}\n\n\tif (usb_dev->devnum < 0) {\n\t\t \n\t\tpr_debug(\"usb %s: already deleted?\\n\", dev_name(dev));\n\t\treturn -ENODEV;\n\t}\n\tif (!usb_dev->bus) {\n\t\tpr_debug(\"usb %s: bus removed?\\n\", dev_name(dev));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (add_uevent_var(env, \"PRODUCT=%x/%x/%x\",\n\t\t\t   le16_to_cpu(usb_dev->descriptor.idVendor),\n\t\t\t   le16_to_cpu(usb_dev->descriptor.idProduct),\n\t\t\t   le16_to_cpu(usb_dev->descriptor.bcdDevice)))\n\t\treturn -ENOMEM;\n\n\t \n\tif (add_uevent_var(env, \"TYPE=%d/%d/%d\",\n\t\t\t   usb_dev->descriptor.bDeviceClass,\n\t\t\t   usb_dev->descriptor.bDeviceSubClass,\n\t\t\t   usb_dev->descriptor.bDeviceProtocol))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int __usb_bus_reprobe_drivers(struct device *dev, void *data)\n{\n\tstruct usb_device_driver *new_udriver = data;\n\tstruct usb_device *udev;\n\tint ret;\n\n\t \n\tif (dev->driver != &usb_generic_driver.drvwrap.driver)\n\t\treturn 0;\n\n\tudev = to_usb_device(dev);\n\tif (!usb_driver_applicable(udev, new_udriver))\n\t\treturn 0;\n\n\tret = device_reprobe(dev);\n\tif (ret && ret != -EPROBE_DEFER)\n\t\tdev_err(dev, \"Failed to reprobe device (error %d)\\n\", ret);\n\n\treturn 0;\n}\n\n \nint usb_register_device_driver(struct usb_device_driver *new_udriver,\n\t\tstruct module *owner)\n{\n\tint retval = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tnew_udriver->drvwrap.for_devices = 1;\n\tnew_udriver->drvwrap.driver.name = new_udriver->name;\n\tnew_udriver->drvwrap.driver.bus = &usb_bus_type;\n\tnew_udriver->drvwrap.driver.probe = usb_probe_device;\n\tnew_udriver->drvwrap.driver.remove = usb_unbind_device;\n\tnew_udriver->drvwrap.driver.owner = owner;\n\tnew_udriver->drvwrap.driver.dev_groups = new_udriver->dev_groups;\n\n\tretval = driver_register(&new_udriver->drvwrap.driver);\n\n\tif (!retval) {\n\t\tpr_info(\"%s: registered new device driver %s\\n\",\n\t\t\tusbcore_name, new_udriver->name);\n\t\t \n\t\tbus_for_each_dev(&usb_bus_type, NULL, new_udriver,\n\t\t\t\t __usb_bus_reprobe_drivers);\n\t} else {\n\t\tpr_err(\"%s: error %d registering device driver %s\\n\",\n\t\t\tusbcore_name, retval, new_udriver->name);\n\t}\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(usb_register_device_driver);\n\n \nvoid usb_deregister_device_driver(struct usb_device_driver *udriver)\n{\n\tpr_info(\"%s: deregistering device driver %s\\n\",\n\t\t\tusbcore_name, udriver->name);\n\n\tdriver_unregister(&udriver->drvwrap.driver);\n}\nEXPORT_SYMBOL_GPL(usb_deregister_device_driver);\n\n \nint usb_register_driver(struct usb_driver *new_driver, struct module *owner,\n\t\t\tconst char *mod_name)\n{\n\tint retval = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tnew_driver->drvwrap.for_devices = 0;\n\tnew_driver->drvwrap.driver.name = new_driver->name;\n\tnew_driver->drvwrap.driver.bus = &usb_bus_type;\n\tnew_driver->drvwrap.driver.probe = usb_probe_interface;\n\tnew_driver->drvwrap.driver.remove = usb_unbind_interface;\n\tnew_driver->drvwrap.driver.owner = owner;\n\tnew_driver->drvwrap.driver.mod_name = mod_name;\n\tnew_driver->drvwrap.driver.dev_groups = new_driver->dev_groups;\n\tspin_lock_init(&new_driver->dynids.lock);\n\tINIT_LIST_HEAD(&new_driver->dynids.list);\n\n\tretval = driver_register(&new_driver->drvwrap.driver);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = usb_create_newid_files(new_driver);\n\tif (retval)\n\t\tgoto out_newid;\n\n\tpr_info(\"%s: registered new interface driver %s\\n\",\n\t\t\tusbcore_name, new_driver->name);\n\nout:\n\treturn retval;\n\nout_newid:\n\tdriver_unregister(&new_driver->drvwrap.driver);\n\n\tpr_err(\"%s: error %d registering interface driver %s\\n\",\n\t\tusbcore_name, retval, new_driver->name);\n\tgoto out;\n}\nEXPORT_SYMBOL_GPL(usb_register_driver);\n\n \nvoid usb_deregister(struct usb_driver *driver)\n{\n\tpr_info(\"%s: deregistering interface driver %s\\n\",\n\t\t\tusbcore_name, driver->name);\n\n\tusb_remove_newid_files(driver);\n\tdriver_unregister(&driver->drvwrap.driver);\n\tusb_free_dynids(driver);\n}\nEXPORT_SYMBOL_GPL(usb_deregister);\n\n \nvoid usb_forced_unbind_intf(struct usb_interface *intf)\n{\n\tstruct usb_driver *driver = to_usb_driver(intf->dev.driver);\n\n\tdev_dbg(&intf->dev, \"forced unbind\\n\");\n\tusb_driver_release_interface(driver, intf);\n\n\t \n\tintf->needs_binding = 1;\n}\n\n \nstatic void unbind_marked_interfaces(struct usb_device *udev)\n{\n\tstruct usb_host_config\t*config;\n\tint\t\t\ti;\n\tstruct usb_interface\t*intf;\n\n\tconfig = udev->actconfig;\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tintf = config->interface[i];\n\t\t\tif (intf->dev.driver && intf->needs_binding)\n\t\t\t\tusb_forced_unbind_intf(intf);\n\t\t}\n\t}\n}\n\n \nstatic void usb_rebind_intf(struct usb_interface *intf)\n{\n\tint rc;\n\n\t \n\tif (intf->dev.driver)\n\t\tusb_forced_unbind_intf(intf);\n\n\t \n\tif (!intf->dev.power.is_prepared) {\n\t\tintf->needs_binding = 0;\n\t\trc = device_attach(&intf->dev);\n\t\tif (rc < 0 && rc != -EPROBE_DEFER)\n\t\t\tdev_warn(&intf->dev, \"rebind failed: %d\\n\", rc);\n\t}\n}\n\n \nstatic void rebind_marked_interfaces(struct usb_device *udev)\n{\n\tstruct usb_host_config\t*config;\n\tint\t\t\ti;\n\tstruct usb_interface\t*intf;\n\n\tconfig = udev->actconfig;\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tintf = config->interface[i];\n\t\t\tif (intf->needs_binding)\n\t\t\t\tusb_rebind_intf(intf);\n\t\t}\n\t}\n}\n\n \nvoid usb_unbind_and_rebind_marked_interfaces(struct usb_device *udev)\n{\n\tunbind_marked_interfaces(udev);\n\trebind_marked_interfaces(udev);\n}\n\n#ifdef CONFIG_PM\n\n \nstatic void unbind_no_pm_drivers_interfaces(struct usb_device *udev)\n{\n\tstruct usb_host_config\t*config;\n\tint\t\t\ti;\n\tstruct usb_interface\t*intf;\n\tstruct usb_driver\t*drv;\n\n\tconfig = udev->actconfig;\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tintf = config->interface[i];\n\n\t\t\tif (intf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(intf->dev.driver);\n\t\t\t\tif (!drv->suspend || !drv->resume)\n\t\t\t\t\tusb_forced_unbind_intf(intf);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int usb_suspend_device(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_device_driver\t*udriver;\n\tint\t\t\t\tstatus = 0;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED)\n\t\tgoto done;\n\n\t \n\tif (udev->dev.driver)\n\t\tudriver = to_usb_device_driver(udev->dev.driver);\n\telse {\n\t\tudev->do_remote_wakeup = 0;\n\t\tudriver = &usb_generic_driver;\n\t}\n\tif (udriver->suspend)\n\t\tstatus = udriver->suspend(udev, msg);\n\tif (status == 0 && udriver->generic_subclass)\n\t\tstatus = usb_generic_driver_suspend(udev, msg);\n\n done:\n\tdev_vdbg(&udev->dev, \"%s: status %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int usb_resume_device(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_device_driver\t*udriver;\n\tint\t\t\t\tstatus = 0;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\tgoto done;\n\n\t \n\tif (udev->dev.driver == NULL) {\n\t\tstatus = -ENOTCONN;\n\t\tgoto done;\n\t}\n\n\t \n\tif (!PMSG_IS_AUTO(msg) && udev->parent && udev->bus->hs_companion)\n\t\tdevice_pm_wait_for_dev(&udev->dev,\n\t\t\t\t&udev->bus->hs_companion->root_hub->dev);\n\n\tif (udev->quirks & USB_QUIRK_RESET_RESUME)\n\t\tudev->reset_resume = 1;\n\n\tudriver = to_usb_device_driver(udev->dev.driver);\n\tif (udriver->generic_subclass)\n\t\tstatus = usb_generic_driver_resume(udev, msg);\n\tif (status == 0 && udriver->resume)\n\t\tstatus = udriver->resume(udev, msg);\n\n done:\n\tdev_vdbg(&udev->dev, \"%s: status %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int usb_suspend_interface(struct usb_device *udev,\n\t\tstruct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_driver\t*driver;\n\tint\t\t\tstatus = 0;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tintf->condition == USB_INTERFACE_UNBOUND)\n\t\tgoto done;\n\tdriver = to_usb_driver(intf->dev.driver);\n\n\t \n\tstatus = driver->suspend(intf, msg);\n\tif (status && !PMSG_IS_AUTO(msg))\n\t\tdev_err(&intf->dev, \"suspend error %d\\n\", status);\n\n done:\n\tdev_vdbg(&intf->dev, \"%s: status %d\\n\", __func__, status);\n\treturn status;\n}\n\nstatic int usb_resume_interface(struct usb_device *udev,\n\t\tstruct usb_interface *intf, pm_message_t msg, int reset_resume)\n{\n\tstruct usb_driver\t*driver;\n\tint\t\t\tstatus = 0;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\tgoto done;\n\n\t \n\tif (intf->condition == USB_INTERFACE_UNBINDING)\n\t\tgoto done;\n\n\t \n\tif (intf->condition == USB_INTERFACE_UNBOUND) {\n\n\t\t \n\t\tif (intf->needs_altsetting0 && !intf->dev.power.is_prepared) {\n\t\t\tusb_set_interface(udev, intf->altsetting[0].\n\t\t\t\t\tdesc.bInterfaceNumber, 0);\n\t\t\tintf->needs_altsetting0 = 0;\n\t\t}\n\t\tgoto done;\n\t}\n\n\t \n\tif (intf->needs_binding)\n\t\tgoto done;\n\tdriver = to_usb_driver(intf->dev.driver);\n\n\tif (reset_resume) {\n\t\tif (driver->reset_resume) {\n\t\t\tstatus = driver->reset_resume(intf);\n\t\t\tif (status)\n\t\t\t\tdev_err(&intf->dev, \"%s error %d\\n\",\n\t\t\t\t\t\t\"reset_resume\", status);\n\t\t} else {\n\t\t\tintf->needs_binding = 1;\n\t\t\tdev_dbg(&intf->dev, \"no reset_resume for driver %s?\\n\",\n\t\t\t\t\tdriver->name);\n\t\t}\n\t} else {\n\t\tstatus = driver->resume(intf);\n\t\tif (status)\n\t\t\tdev_err(&intf->dev, \"resume error %d\\n\", status);\n\t}\n\ndone:\n\tdev_vdbg(&intf->dev, \"%s: status %d\\n\", __func__, status);\n\n\t \n\treturn status;\n}\n\n \nstatic int usb_suspend_both(struct usb_device *udev, pm_message_t msg)\n{\n\tint\t\t\tstatus = 0;\n\tint\t\t\ti = 0, n = 0;\n\tstruct usb_interface\t*intf;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED)\n\t\tgoto done;\n\n\t \n\tif (udev->actconfig) {\n\t\tn = udev->actconfig->desc.bNumInterfaces;\n\t\tfor (i = n - 1; i >= 0; --i) {\n\t\t\tintf = udev->actconfig->interface[i];\n\t\t\tstatus = usb_suspend_interface(udev, intf, msg);\n\n\t\t\t \n\t\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\t\tstatus = 0;\n\t\t\tif (status != 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tif (status == 0) {\n\t\tstatus = usb_suspend_device(udev, msg);\n\n\t\t \n\t\tif (udev->parent && !PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\n\t\t \n\t\tif (status && status != -EBUSY) {\n\t\t\tint err;\n\t\t\tu16 devstat;\n\n\t\t\terr = usb_get_std_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t\t &devstat);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"Failed to suspend device, error %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (status != 0) {\n\t\tif (udev->actconfig) {\n\t\t\tmsg.event ^= (PM_EVENT_SUSPEND | PM_EVENT_RESUME);\n\t\t\twhile (++i < n) {\n\t\t\t\tintf = udev->actconfig->interface[i];\n\t\t\t\tusb_resume_interface(udev, intf, msg, 0);\n\t\t\t}\n\t\t}\n\n\t \n\t} else {\n\t\tudev->can_submit = 0;\n\t\tfor (i = 0; i < 16; ++i) {\n\t\t\tusb_hcd_flush_endpoint(udev, udev->ep_out[i]);\n\t\t\tusb_hcd_flush_endpoint(udev, udev->ep_in[i]);\n\t\t}\n\t}\n\n done:\n\tdev_vdbg(&udev->dev, \"%s: status %d\\n\", __func__, status);\n\treturn status;\n}\n\n \nstatic int usb_resume_both(struct usb_device *udev, pm_message_t msg)\n{\n\tint\t\t\tstatus = 0;\n\tint\t\t\ti;\n\tstruct usb_interface\t*intf;\n\n\tif (udev->state == USB_STATE_NOTATTACHED) {\n\t\tstatus = -ENODEV;\n\t\tgoto done;\n\t}\n\tudev->can_submit = 1;\n\n\t \n\tif (udev->state == USB_STATE_SUSPENDED || udev->reset_resume)\n\t\tstatus = usb_resume_device(udev, msg);\n\n\t \n\tif (status == 0 && udev->actconfig) {\n\t\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tintf = udev->actconfig->interface[i];\n\t\t\tusb_resume_interface(udev, intf, msg,\n\t\t\t\t\tudev->reset_resume);\n\t\t}\n\t}\n\tusb_mark_last_busy(udev);\n\n done:\n\tdev_vdbg(&udev->dev, \"%s: status %d\\n\", __func__, status);\n\tif (!status)\n\t\tudev->reset_resume = 0;\n\treturn status;\n}\n\nstatic void choose_wakeup(struct usb_device *udev, pm_message_t msg)\n{\n\tint\tw;\n\n\t \n\tif (msg.event == PM_EVENT_FREEZE || msg.event == PM_EVENT_QUIESCE) {\n\t\tw = 0;\n\n\t} else {\n\t\t \n\t\tw = device_may_wakeup(&udev->dev);\n\t}\n\n\t \n\tif (udev->state == USB_STATE_SUSPENDED && w != udev->do_remote_wakeup)\n\t\tpm_runtime_resume(&udev->dev);\n\tudev->do_remote_wakeup = w;\n}\n\n \nint usb_suspend(struct device *dev, pm_message_t msg)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint r;\n\n\tunbind_no_pm_drivers_interfaces(udev);\n\n\t \n\tchoose_wakeup(udev, msg);\n\tr = usb_suspend_both(udev, msg);\n\tif (r)\n\t\treturn r;\n\n\tif (udev->quirks & USB_QUIRK_DISCONNECT_SUSPEND)\n\t\tusb_port_disable(udev);\n\n\treturn 0;\n}\n\n \nint usb_resume_complete(struct device *dev)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\n\t \n\tif (udev->state != USB_STATE_NOTATTACHED)\n\t\trebind_marked_interfaces(udev);\n\treturn 0;\n}\n\n \nint usb_resume(struct device *dev, pm_message_t msg)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint\t\t\tstatus;\n\n\t \n\tstatus = usb_resume_both(udev, msg);\n\tif (status == 0) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t\tunbind_marked_interfaces(udev);\n\t}\n\n\t \n\tif (status == -ENODEV || status == -ESHUTDOWN)\n\t\tstatus = 0;\n\treturn status;\n}\n\n \nvoid usb_enable_autosuspend(struct usb_device *udev)\n{\n\tpm_runtime_allow(&udev->dev);\n}\nEXPORT_SYMBOL_GPL(usb_enable_autosuspend);\n\n \nvoid usb_disable_autosuspend(struct usb_device *udev)\n{\n\tpm_runtime_forbid(&udev->dev);\n}\nEXPORT_SYMBOL_GPL(usb_disable_autosuspend);\n\n \nvoid usb_autosuspend_device(struct usb_device *udev)\n{\n\tint\tstatus;\n\n\tusb_mark_last_busy(udev);\n\tstatus = pm_runtime_put_sync_autosuspend(&udev->dev);\n\tdev_vdbg(&udev->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&udev->dev.power.usage_count),\n\t\t\tstatus);\n}\n\n \nint usb_autoresume_device(struct usb_device *udev)\n{\n\tint\tstatus;\n\n\tstatus = pm_runtime_get_sync(&udev->dev);\n\tif (status < 0)\n\t\tpm_runtime_put_sync(&udev->dev);\n\tdev_vdbg(&udev->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&udev->dev.power.usage_count),\n\t\t\tstatus);\n\tif (status > 0)\n\t\tstatus = 0;\n\treturn status;\n}\n\n \nvoid usb_autopm_put_interface(struct usb_interface *intf)\n{\n\tstruct usb_device\t*udev = interface_to_usbdev(intf);\n\tint\t\t\tstatus;\n\n\tusb_mark_last_busy(udev);\n\tstatus = pm_runtime_put_sync(&intf->dev);\n\tdev_vdbg(&intf->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&intf->dev.power.usage_count),\n\t\t\tstatus);\n}\nEXPORT_SYMBOL_GPL(usb_autopm_put_interface);\n\n \nvoid usb_autopm_put_interface_async(struct usb_interface *intf)\n{\n\tstruct usb_device\t*udev = interface_to_usbdev(intf);\n\tint\t\t\tstatus;\n\n\tusb_mark_last_busy(udev);\n\tstatus = pm_runtime_put(&intf->dev);\n\tdev_vdbg(&intf->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&intf->dev.power.usage_count),\n\t\t\tstatus);\n}\nEXPORT_SYMBOL_GPL(usb_autopm_put_interface_async);\n\n \nvoid usb_autopm_put_interface_no_suspend(struct usb_interface *intf)\n{\n\tstruct usb_device\t*udev = interface_to_usbdev(intf);\n\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_noidle(&intf->dev);\n}\nEXPORT_SYMBOL_GPL(usb_autopm_put_interface_no_suspend);\n\n \nint usb_autopm_get_interface(struct usb_interface *intf)\n{\n\tint\tstatus;\n\n\tstatus = pm_runtime_get_sync(&intf->dev);\n\tif (status < 0)\n\t\tpm_runtime_put_sync(&intf->dev);\n\tdev_vdbg(&intf->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&intf->dev.power.usage_count),\n\t\t\tstatus);\n\tif (status > 0)\n\t\tstatus = 0;\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_autopm_get_interface);\n\n \nint usb_autopm_get_interface_async(struct usb_interface *intf)\n{\n\tint\tstatus;\n\n\tstatus = pm_runtime_get(&intf->dev);\n\tif (status < 0 && status != -EINPROGRESS)\n\t\tpm_runtime_put_noidle(&intf->dev);\n\tdev_vdbg(&intf->dev, \"%s: cnt %d -> %d\\n\",\n\t\t\t__func__, atomic_read(&intf->dev.power.usage_count),\n\t\t\tstatus);\n\tif (status > 0 || status == -EINPROGRESS)\n\t\tstatus = 0;\n\treturn status;\n}\nEXPORT_SYMBOL_GPL(usb_autopm_get_interface_async);\n\n \nvoid usb_autopm_get_interface_no_resume(struct usb_interface *intf)\n{\n\tstruct usb_device\t*udev = interface_to_usbdev(intf);\n\n\tusb_mark_last_busy(udev);\n\tpm_runtime_get_noresume(&intf->dev);\n}\nEXPORT_SYMBOL_GPL(usb_autopm_get_interface_no_resume);\n\n \nstatic int autosuspend_check(struct usb_device *udev)\n{\n\tint\t\t\tw, i;\n\tstruct usb_interface\t*intf;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\n\t \n\tw = 0;\n\tif (udev->actconfig) {\n\t\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\t\tintf = udev->actconfig->interface[i];\n\n\t\t\t \n\t\t\tif (intf->dev.power.disable_depth)\n\t\t\t\tcontinue;\n\t\t\tif (atomic_read(&intf->dev.power.usage_count) > 0)\n\t\t\t\treturn -EBUSY;\n\t\t\tw |= intf->needs_remote_wakeup;\n\n\t\t\t \n\t\t\tif (udev->quirks & USB_QUIRK_RESET_RESUME) {\n\t\t\t\tstruct usb_driver *driver;\n\n\t\t\t\tdriver = to_usb_driver(intf->dev.driver);\n\t\t\t\tif (!driver->reset_resume ||\n\t\t\t\t\t\tintf->needs_remote_wakeup)\n\t\t\t\t\treturn -EOPNOTSUPP;\n\t\t\t}\n\t\t}\n\t}\n\tif (w && !device_can_wakeup(&udev->dev)) {\n\t\tdev_dbg(&udev->dev, \"remote wakeup needed for autosuspend\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (w && udev->parent == udev->bus->root_hub &&\n\t\t\tbus_to_hcd(udev->bus)->cant_recv_wakeups) {\n\t\tdev_dbg(&udev->dev, \"HCD doesn't handle wakeup requests\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tudev->do_remote_wakeup = w;\n\treturn 0;\n}\n\nint usb_runtime_suspend(struct device *dev)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint\t\t\tstatus;\n\n\t \n\tif (autosuspend_check(udev) != 0)\n\t\treturn -EAGAIN;\n\n\tstatus = usb_suspend_both(udev, PMSG_AUTO_SUSPEND);\n\n\t \n\tif (status == -EAGAIN || status == -EBUSY)\n\t\tusb_mark_last_busy(udev);\n\n\t \n\tif (status != 0 && udev->parent)\n\t\treturn -EBUSY;\n\treturn status;\n}\n\nint usb_runtime_resume(struct device *dev)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint\t\t\tstatus;\n\n\t \n\tstatus = usb_resume_both(udev, PMSG_AUTO_RESUME);\n\treturn status;\n}\n\nint usb_runtime_idle(struct device *dev)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\n\t \n\tif (autosuspend_check(udev) == 0)\n\t\tpm_runtime_autosuspend(dev);\n\t \n\treturn -EBUSY;\n}\n\nstatic int usb_set_usb2_hardware_lpm(struct usb_device *udev, int enable)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret = -EPERM;\n\n\tif (hcd->driver->set_usb2_hw_lpm) {\n\t\tret = hcd->driver->set_usb2_hw_lpm(hcd, udev, enable);\n\t\tif (!ret)\n\t\t\tudev->usb2_hw_lpm_enabled = enable;\n\t}\n\n\treturn ret;\n}\n\nint usb_enable_usb2_hardware_lpm(struct usb_device *udev)\n{\n\tif (!udev->usb2_hw_lpm_capable ||\n\t    !udev->usb2_hw_lpm_allowed ||\n\t    udev->usb2_hw_lpm_enabled)\n\t\treturn 0;\n\n\treturn usb_set_usb2_hardware_lpm(udev, 1);\n}\n\nint usb_disable_usb2_hardware_lpm(struct usb_device *udev)\n{\n\tif (!udev->usb2_hw_lpm_enabled)\n\t\treturn 0;\n\n\treturn usb_set_usb2_hardware_lpm(udev, 0);\n}\n\n#endif  \n\nconst struct bus_type usb_bus_type = {\n\t.name =\t\t\"usb\",\n\t.match =\tusb_device_match,\n\t.uevent =\tusb_uevent,\n\t.need_parent_lock =\ttrue,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}