{
  "module_name": "sysfs.c",
  "hash_id": "4c5e0c0cd918b329df1c1f4f68210fe09440aa6b6e6ed86b9722bbfb651ff148",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/sysfs.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/kstrtox.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/of.h>\n#include \"usb.h\"\n\n \n#define usb_actconfig_show(field, format_string)\t\t\t\\\nstatic ssize_t field##_show(struct device *dev,\t\t\t\t\\\n\t\t\t    struct device_attribute *attr, char *buf)\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_device *udev;\t\t\t\t\t\\\n\tstruct usb_host_config *actconfig;\t\t\t\t\\\n\tssize_t rc;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tudev = to_usb_device(dev);\t\t\t\t\t\\\n\trc = usb_lock_device_interruptible(udev);\t\t\t\\\n\tif (rc < 0)\t\t\t\t\t\t\t\\\n\t\treturn -EINTR;\t\t\t\t\t\t\\\n\tactconfig = udev->actconfig;\t\t\t\t\t\\\n\tif (actconfig)\t\t\t\t\t\t\t\\\n\t\trc = sysfs_emit(buf, format_string,\t\t\t\\\n\t\t\t\tactconfig->desc.field);\t\t\t\\\n\tusb_unlock_device(udev);\t\t\t\t\t\\\n\treturn rc;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\n\n#define usb_actconfig_attr(field, format_string)\t\t\\\n\tusb_actconfig_show(field, format_string)\t\t\\\n\tstatic DEVICE_ATTR_RO(field)\n\nusb_actconfig_attr(bNumInterfaces, \"%2d\\n\");\nusb_actconfig_attr(bmAttributes, \"%2x\\n\");\n\nstatic ssize_t bMaxPower_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev;\n\tstruct usb_host_config *actconfig;\n\tssize_t rc;\n\n\tudev = to_usb_device(dev);\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\tactconfig = udev->actconfig;\n\tif (actconfig)\n\t\trc = sysfs_emit(buf, \"%dmA\\n\", usb_get_max_power(udev, actconfig));\n\tusb_unlock_device(udev);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(bMaxPower);\n\nstatic ssize_t configuration_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev;\n\tstruct usb_host_config *actconfig;\n\tssize_t rc;\n\n\tudev = to_usb_device(dev);\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\tactconfig = udev->actconfig;\n\tif (actconfig && actconfig->string)\n\t\trc = sysfs_emit(buf, \"%s\\n\", actconfig->string);\n\tusb_unlock_device(udev);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RO(configuration);\n\n \nusb_actconfig_show(bConfigurationValue, \"%u\\n\");\n\nstatic ssize_t bConfigurationValue_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint\t\t\tconfig, value, rc;\n\n\tif (sscanf(buf, \"%d\", &config) != 1 || config < -1 || config > 255)\n\t\treturn -EINVAL;\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\tvalue = usb_set_configuration(udev, config);\n\tusb_unlock_device(udev);\n\treturn (value < 0) ? value : count;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(bConfigurationValue, S_IRUGO | S_IWUSR,\n\t\tbConfigurationValue_show, bConfigurationValue_store);\n\n#ifdef CONFIG_OF\nstatic ssize_t devspec_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct device_node *of_node = dev->of_node;\n\n\treturn sysfs_emit(buf, \"%pOF\\n\", of_node);\n}\nstatic DEVICE_ATTR_RO(devspec);\n#endif\n\n \n#define usb_string_attr(name)\t\t\t\t\t\t\\\nstatic ssize_t  name##_show(struct device *dev,\t\t\t\t\\\n\t\tstruct device_attribute *attr, char *buf)\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_device *udev;\t\t\t\t\t\\\n\tint retval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tudev = to_usb_device(dev);\t\t\t\t\t\\\n\tretval = usb_lock_device_interruptible(udev);\t\t\t\\\n\tif (retval < 0)\t\t\t\t\t\t\t\\\n\t\treturn -EINTR;\t\t\t\t\t\t\\\n\tretval = sysfs_emit(buf, \"%s\\n\", udev->name);\t\t\t\\\n\tusb_unlock_device(udev);\t\t\t\t\t\\\n\treturn retval;\t\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(name)\n\nusb_string_attr(product);\nusb_string_attr(manufacturer);\nusb_string_attr(serial);\n\nstatic ssize_t speed_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct usb_device *udev;\n\tchar *speed;\n\n\tudev = to_usb_device(dev);\n\n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"1.5\";\n\t\tbreak;\n\tcase USB_SPEED_UNKNOWN:\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"12\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"480\";\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tspeed = \"5000\";\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (udev->ssp_rate == USB_SSP_GEN_2x2)\n\t\t\tspeed = \"20000\";\n\t\telse\n\t\t\tspeed = \"10000\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"unknown\";\n\t}\n\treturn sysfs_emit(buf, \"%s\\n\", speed);\n}\nstatic DEVICE_ATTR_RO(speed);\n\nstatic ssize_t rx_lanes_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->rx_lanes);\n}\nstatic DEVICE_ATTR_RO(rx_lanes);\n\nstatic ssize_t tx_lanes_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->tx_lanes);\n}\nstatic DEVICE_ATTR_RO(tx_lanes);\n\nstatic ssize_t busnum_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->bus->busnum);\n}\nstatic DEVICE_ATTR_RO(busnum);\n\nstatic ssize_t devnum_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->devnum);\n}\nstatic DEVICE_ATTR_RO(devnum);\n\nstatic ssize_t devpath_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%s\\n\", udev->devpath);\n}\nstatic DEVICE_ATTR_RO(devpath);\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct usb_device *udev;\n\tu16 bcdUSB;\n\n\tudev = to_usb_device(dev);\n\tbcdUSB = le16_to_cpu(udev->descriptor.bcdUSB);\n\treturn sysfs_emit(buf, \"%2x.%02x\\n\", bcdUSB >> 8, bcdUSB & 0xff);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic ssize_t maxchild_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->maxchild);\n}\nstatic DEVICE_ATTR_RO(maxchild);\n\nstatic ssize_t quirks_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"0x%x\\n\", udev->quirks);\n}\nstatic DEVICE_ATTR_RO(quirks);\n\nstatic ssize_t avoid_reset_quirk_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", !!(udev->quirks & USB_QUIRK_RESET));\n}\n\nstatic ssize_t avoid_reset_quirk_store(struct device *dev,\n\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t      const char *buf, size_t count)\n{\n\tstruct usb_device\t*udev = to_usb_device(dev);\n\tint\t\t\tval, rc;\n\n\tif (sscanf(buf, \"%d\", &val) != 1 || val < 0 || val > 1)\n\t\treturn -EINVAL;\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\tif (val)\n\t\tudev->quirks |= USB_QUIRK_RESET;\n\telse\n\t\tudev->quirks &= ~USB_QUIRK_RESET;\n\tusb_unlock_device(udev);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(avoid_reset_quirk);\n\nstatic ssize_t urbnum_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tstruct usb_device *udev;\n\n\tudev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", atomic_read(&udev->urbnum));\n}\nstatic DEVICE_ATTR_RO(urbnum);\n\nstatic ssize_t ltm_capable_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tif (usb_device_supports_ltm(to_usb_device(dev)))\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"yes\");\n\treturn sysfs_emit(buf, \"%s\\n\", \"no\");\n}\nstatic DEVICE_ATTR_RO(ltm_capable);\n\n#ifdef\tCONFIG_PM\n\nstatic ssize_t persist_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", udev->persist_enabled);\n}\n\nstatic ssize_t persist_store(struct device *dev, struct device_attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tint value, rc;\n\n\t \n\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB)\n\t\treturn -EPERM;\n\n\tif (sscanf(buf, \"%d\", &value) != 1)\n\t\treturn -EINVAL;\n\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\tudev->persist_enabled = !!value;\n\tusb_unlock_device(udev);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(persist);\n\nstatic int add_persist_attributes(struct device *dev)\n{\n\tint rc = 0;\n\n\tif (is_usb_device(dev)) {\n\t\tstruct usb_device *udev = to_usb_device(dev);\n\n\t\t \n\t\tif (udev->descriptor.bDeviceClass != USB_CLASS_HUB)\n\t\t\trc = sysfs_add_file_to_group(&dev->kobj,\n\t\t\t\t\t&dev_attr_persist.attr,\n\t\t\t\t\tpower_group_name);\n\t}\n\treturn rc;\n}\n\nstatic void remove_persist_attributes(struct device *dev)\n{\n\tsysfs_remove_file_from_group(&dev->kobj,\n\t\t\t&dev_attr_persist.attr,\n\t\t\tpower_group_name);\n}\n\nstatic ssize_t connected_duration_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\",\n\t\t\tjiffies_to_msecs(jiffies - udev->connect_time));\n}\nstatic DEVICE_ATTR_RO(connected_duration);\n\n \nstatic ssize_t active_duration_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tint duration;\n\n\tif (udev->state != USB_STATE_SUSPENDED)\n\t\tduration = jiffies_to_msecs(jiffies + udev->active_duration);\n\telse\n\t\tduration = jiffies_to_msecs(udev->active_duration);\n\treturn sysfs_emit(buf, \"%u\\n\", duration);\n}\nstatic DEVICE_ATTR_RO(active_duration);\n\nstatic ssize_t autosuspend_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%d\\n\", dev->power.autosuspend_delay / 1000);\n}\n\nstatic ssize_t autosuspend_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint value;\n\n\tif (sscanf(buf, \"%d\", &value) != 1 || value >= INT_MAX/1000 ||\n\t\t\tvalue <= -INT_MAX/1000)\n\t\treturn -EINVAL;\n\n\tpm_runtime_set_autosuspend_delay(dev, value * 1000);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(autosuspend);\n\nstatic const char on_string[] = \"on\";\nstatic const char auto_string[] = \"auto\";\n\nstatic void warn_level(void)\n{\n\tstatic int level_warned;\n\n\tif (!level_warned) {\n\t\tlevel_warned = 1;\n\t\tprintk(KERN_WARNING \"WARNING! power/level is deprecated; \"\n\t\t\t\t\"use power/control instead\\n\");\n\t}\n}\n\nstatic ssize_t level_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tconst char *p = auto_string;\n\n\twarn_level();\n\tif (udev->state != USB_STATE_SUSPENDED && !udev->dev.power.runtime_auto)\n\t\tp = on_string;\n\treturn sysfs_emit(buf, \"%s\\n\", p);\n}\n\nstatic ssize_t level_store(struct device *dev, struct device_attribute *attr,\n\t\t\t   const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tint len = count;\n\tchar *cp;\n\tint rc = count;\n\tint rv;\n\n\twarn_level();\n\tcp = memchr(buf, '\\n', count);\n\tif (cp)\n\t\tlen = cp - buf;\n\n\trv = usb_lock_device_interruptible(udev);\n\tif (rv < 0)\n\t\treturn -EINTR;\n\n\tif (len == sizeof on_string - 1 &&\n\t\t\tstrncmp(buf, on_string, len) == 0)\n\t\tusb_disable_autosuspend(udev);\n\n\telse if (len == sizeof auto_string - 1 &&\n\t\t\tstrncmp(buf, auto_string, len) == 0)\n\t\tusb_enable_autosuspend(udev);\n\n\telse\n\t\trc = -EINVAL;\n\n\tusb_unlock_device(udev);\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(level);\n\nstatic ssize_t usb2_hardware_lpm_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tconst char *p;\n\n\tif (udev->usb2_hw_lpm_allowed == 1)\n\t\tp = \"enabled\";\n\telse\n\t\tp = \"disabled\";\n\n\treturn sysfs_emit(buf, \"%s\\n\", p);\n}\n\nstatic ssize_t usb2_hardware_lpm_store(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tbool value;\n\tint ret;\n\n\tret = usb_lock_device_interruptible(udev);\n\tif (ret < 0)\n\t\treturn -EINTR;\n\n\tret = kstrtobool(buf, &value);\n\n\tif (!ret) {\n\t\tudev->usb2_hw_lpm_allowed = value;\n\t\tif (value)\n\t\t\tret = usb_enable_usb2_hardware_lpm(udev);\n\t\telse\n\t\t\tret = usb_disable_usb2_hardware_lpm(udev);\n\t}\n\n\tusb_unlock_device(udev);\n\n\tif (!ret)\n\t\treturn count;\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(usb2_hardware_lpm);\n\nstatic ssize_t usb2_lpm_l1_timeout_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->l1_params.timeout);\n}\n\nstatic ssize_t usb2_lpm_l1_timeout_store(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu16 timeout;\n\n\tif (kstrtou16(buf, 0, &timeout))\n\t\treturn -EINVAL;\n\n\tudev->l1_params.timeout = timeout;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb2_lpm_l1_timeout);\n\nstatic ssize_t usb2_lpm_besl_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%d\\n\", udev->l1_params.besl);\n}\n\nstatic ssize_t usb2_lpm_besl_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tu8 besl;\n\n\tif (kstrtou8(buf, 0, &besl) || besl > 15)\n\t\treturn -EINVAL;\n\n\tudev->l1_params.besl = besl;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(usb2_lpm_besl);\n\nstatic ssize_t usb3_hardware_lpm_u1_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tconst char *p;\n\tint rc;\n\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\n\tif (udev->usb3_lpm_u1_enabled)\n\t\tp = \"enabled\";\n\telse\n\t\tp = \"disabled\";\n\n\tusb_unlock_device(udev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", p);\n}\nstatic DEVICE_ATTR_RO(usb3_hardware_lpm_u1);\n\nstatic ssize_t usb3_hardware_lpm_u2_show(struct device *dev,\n\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tconst char *p;\n\tint rc;\n\n\trc = usb_lock_device_interruptible(udev);\n\tif (rc < 0)\n\t\treturn -EINTR;\n\n\tif (udev->usb3_lpm_u2_enabled)\n\t\tp = \"enabled\";\n\telse\n\t\tp = \"disabled\";\n\n\tusb_unlock_device(udev);\n\n\treturn sysfs_emit(buf, \"%s\\n\", p);\n}\nstatic DEVICE_ATTR_RO(usb3_hardware_lpm_u2);\n\nstatic struct attribute *usb2_hardware_lpm_attr[] = {\n\t&dev_attr_usb2_hardware_lpm.attr,\n\t&dev_attr_usb2_lpm_l1_timeout.attr,\n\t&dev_attr_usb2_lpm_besl.attr,\n\tNULL,\n};\nstatic const struct attribute_group usb2_hardware_lpm_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= usb2_hardware_lpm_attr,\n};\n\nstatic struct attribute *usb3_hardware_lpm_attr[] = {\n\t&dev_attr_usb3_hardware_lpm_u1.attr,\n\t&dev_attr_usb3_hardware_lpm_u2.attr,\n\tNULL,\n};\nstatic const struct attribute_group usb3_hardware_lpm_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= usb3_hardware_lpm_attr,\n};\n\nstatic struct attribute *power_attrs[] = {\n\t&dev_attr_autosuspend.attr,\n\t&dev_attr_level.attr,\n\t&dev_attr_connected_duration.attr,\n\t&dev_attr_active_duration.attr,\n\tNULL,\n};\nstatic const struct attribute_group power_attr_group = {\n\t.name\t= power_group_name,\n\t.attrs\t= power_attrs,\n};\n\nstatic int add_power_attributes(struct device *dev)\n{\n\tint rc = 0;\n\n\tif (is_usb_device(dev)) {\n\t\tstruct usb_device *udev = to_usb_device(dev);\n\t\trc = sysfs_merge_group(&dev->kobj, &power_attr_group);\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\trc = sysfs_merge_group(&dev->kobj,\n\t\t\t\t\t&usb2_hardware_lpm_attr_group);\n\t\tif ((udev->speed == USB_SPEED_SUPER ||\n\t\t     udev->speed == USB_SPEED_SUPER_PLUS) &&\n\t\t\t\tudev->lpm_capable == 1)\n\t\t\trc = sysfs_merge_group(&dev->kobj,\n\t\t\t\t\t&usb3_hardware_lpm_attr_group);\n\t}\n\n\treturn rc;\n}\n\nstatic void remove_power_attributes(struct device *dev)\n{\n\tsysfs_unmerge_group(&dev->kobj, &usb2_hardware_lpm_attr_group);\n\tsysfs_unmerge_group(&dev->kobj, &power_attr_group);\n}\n\n#else\n\n#define add_persist_attributes(dev)\t0\n#define remove_persist_attributes(dev)\tdo {} while (0)\n\n#define add_power_attributes(dev)\t0\n#define remove_power_attributes(dev)\tdo {} while (0)\n\n#endif\t \n\n\n \n#define usb_descriptor_attr_le16(field, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\tchar *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_device *udev;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tudev = to_usb_device(dev);\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string,\t\t\t\t\\\n\t\t\tle16_to_cpu(udev->descriptor.field));\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nusb_descriptor_attr_le16(idVendor, \"%04x\\n\");\nusb_descriptor_attr_le16(idProduct, \"%04x\\n\");\nusb_descriptor_attr_le16(bcdDevice, \"%04x\\n\");\n\n#define usb_descriptor_attr(field, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\tchar *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_device *udev;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tudev = to_usb_device(dev);\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string, udev->descriptor.field);\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nusb_descriptor_attr(bDeviceClass, \"%02x\\n\");\nusb_descriptor_attr(bDeviceSubClass, \"%02x\\n\");\nusb_descriptor_attr(bDeviceProtocol, \"%02x\\n\");\nusb_descriptor_attr(bNumConfigurations, \"%d\\n\");\nusb_descriptor_attr(bMaxPacketSize0, \"%d\\n\");\n\n\n \nstatic ssize_t authorized_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *usb_dev = to_usb_device(dev);\n\treturn sysfs_emit(buf, \"%u\\n\", usb_dev->authorized);\n}\n\n \nstatic ssize_t authorized_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, const char *buf,\n\t\t\t\tsize_t size)\n{\n\tssize_t result;\n\tstruct usb_device *usb_dev = to_usb_device(dev);\n\tunsigned val;\n\tresult = sscanf(buf, \"%u\\n\", &val);\n\tif (result != 1)\n\t\tresult = -EINVAL;\n\telse if (val == 0)\n\t\tresult = usb_deauthorize_device(usb_dev);\n\telse\n\t\tresult = usb_authorize_device(usb_dev);\n\treturn result < 0 ? result : size;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(authorized, S_IRUGO | S_IWUSR,\n\t\t\t\t  authorized_show, authorized_store);\n\n \nstatic ssize_t remove_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct usb_device *udev = to_usb_device(dev);\n\tint rc = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state != USB_STATE_NOTATTACHED) {\n\n\t\t \n\t\tusb_set_configuration(udev, -1);\n\t\trc = usb_remove_device(udev);\n\t}\n\tif (rc == 0)\n\t\trc = count;\n\tusb_unlock_device(udev);\n\treturn rc;\n}\nstatic DEVICE_ATTR_IGNORE_LOCKDEP(remove, S_IWUSR, NULL, remove_store);\n\n\nstatic struct attribute *dev_attrs[] = {\n\t \n\t&dev_attr_configuration.attr,\n\t&dev_attr_bNumInterfaces.attr,\n\t&dev_attr_bConfigurationValue.attr,\n\t&dev_attr_bmAttributes.attr,\n\t&dev_attr_bMaxPower.attr,\n\t \n\t&dev_attr_urbnum.attr,\n\t&dev_attr_idVendor.attr,\n\t&dev_attr_idProduct.attr,\n\t&dev_attr_bcdDevice.attr,\n\t&dev_attr_bDeviceClass.attr,\n\t&dev_attr_bDeviceSubClass.attr,\n\t&dev_attr_bDeviceProtocol.attr,\n\t&dev_attr_bNumConfigurations.attr,\n\t&dev_attr_bMaxPacketSize0.attr,\n\t&dev_attr_speed.attr,\n\t&dev_attr_rx_lanes.attr,\n\t&dev_attr_tx_lanes.attr,\n\t&dev_attr_busnum.attr,\n\t&dev_attr_devnum.attr,\n\t&dev_attr_devpath.attr,\n\t&dev_attr_version.attr,\n\t&dev_attr_maxchild.attr,\n\t&dev_attr_quirks.attr,\n\t&dev_attr_avoid_reset_quirk.attr,\n\t&dev_attr_authorized.attr,\n\t&dev_attr_remove.attr,\n\t&dev_attr_ltm_capable.attr,\n#ifdef CONFIG_OF\n\t&dev_attr_devspec.attr,\n#endif\n\tNULL,\n};\nstatic const struct attribute_group dev_attr_grp = {\n\t.attrs = dev_attrs,\n};\n\n \nstatic struct attribute *dev_string_attrs[] = {\n\t&dev_attr_manufacturer.attr,\n\t&dev_attr_product.attr,\n\t&dev_attr_serial.attr,\n\tNULL\n};\n\nstatic umode_t dev_string_attrs_are_visible(struct kobject *kobj,\n\t\tstruct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_device *udev = to_usb_device(dev);\n\n\tif (a == &dev_attr_manufacturer.attr) {\n\t\tif (udev->manufacturer == NULL)\n\t\t\treturn 0;\n\t} else if (a == &dev_attr_product.attr) {\n\t\tif (udev->product == NULL)\n\t\t\treturn 0;\n\t} else if (a == &dev_attr_serial.attr) {\n\t\tif (udev->serial == NULL)\n\t\t\treturn 0;\n\t}\n\treturn a->mode;\n}\n\nstatic const struct attribute_group dev_string_attr_grp = {\n\t.attrs =\tdev_string_attrs,\n\t.is_visible =\tdev_string_attrs_are_visible,\n};\n\nconst struct attribute_group *usb_device_groups[] = {\n\t&dev_attr_grp,\n\t&dev_string_attr_grp,\n\tNULL\n};\n\n \n\nstatic ssize_t\nread_descriptors(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_device *udev = to_usb_device(dev);\n\tsize_t nleft = count;\n\tsize_t srclen, n;\n\tint cfgno;\n\tvoid *src;\n\n\t \n\tfor (cfgno = -1; cfgno < udev->descriptor.bNumConfigurations &&\n\t\t\tnleft > 0; ++cfgno) {\n\t\tif (cfgno < 0) {\n\t\t\tsrc = &udev->descriptor;\n\t\t\tsrclen = sizeof(struct usb_device_descriptor);\n\t\t} else {\n\t\t\tsrc = udev->rawdescriptors[cfgno];\n\t\t\tsrclen = __le16_to_cpu(udev->config[cfgno].desc.\n\t\t\t\t\twTotalLength);\n\t\t}\n\t\tif (off < srclen) {\n\t\t\tn = min(nleft, srclen - (size_t) off);\n\t\t\tmemcpy(buf, src + off, n);\n\t\t\tnleft -= n;\n\t\t\tbuf += n;\n\t\t\toff = 0;\n\t\t} else {\n\t\t\toff -= srclen;\n\t\t}\n\t}\n\treturn count - nleft;\n}\n\nstatic struct bin_attribute dev_bin_attr_descriptors = {\n\t.attr = {.name = \"descriptors\", .mode = 0444},\n\t.read = read_descriptors,\n\t.size = 18 + 65535,\t \n};\n\n \nstatic ssize_t authorized_default_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *rh_usb_dev = to_usb_device(dev);\n\tstruct usb_bus *usb_bus = rh_usb_dev->bus;\n\tstruct usb_hcd *hcd;\n\n\thcd = bus_to_hcd(usb_bus);\n\treturn sysfs_emit(buf, \"%u\\n\", hcd->dev_policy);\n}\n\nstatic ssize_t authorized_default_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t size)\n{\n\tssize_t result;\n\tunsigned int val;\n\tstruct usb_device *rh_usb_dev = to_usb_device(dev);\n\tstruct usb_bus *usb_bus = rh_usb_dev->bus;\n\tstruct usb_hcd *hcd;\n\n\thcd = bus_to_hcd(usb_bus);\n\tresult = sscanf(buf, \"%u\\n\", &val);\n\tif (result == 1) {\n\t\thcd->dev_policy = val <= USB_DEVICE_AUTHORIZE_INTERNAL ?\n\t\t\tval : USB_DEVICE_AUTHORIZE_ALL;\n\t\tresult = size;\n\t} else {\n\t\tresult = -EINVAL;\n\t}\n\treturn result;\n}\nstatic DEVICE_ATTR_RW(authorized_default);\n\n \nstatic ssize_t interface_authorized_default_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_device *usb_dev = to_usb_device(dev);\n\tstruct usb_hcd *hcd = bus_to_hcd(usb_dev->bus);\n\n\treturn sysfs_emit(buf, \"%u\\n\", !!HCD_INTF_AUTHORIZED(hcd));\n}\n\n \nstatic ssize_t interface_authorized_default_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_device *usb_dev = to_usb_device(dev);\n\tstruct usb_hcd *hcd = bus_to_hcd(usb_dev->bus);\n\tint rc = count;\n\tbool val;\n\n\tif (kstrtobool(buf, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tset_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\n\telse\n\t\tclear_bit(HCD_FLAG_INTF_AUTHORIZED, &hcd->flags);\n\n\treturn rc;\n}\nstatic DEVICE_ATTR_RW(interface_authorized_default);\n\n \nstatic struct attribute *usb_bus_attrs[] = {\n\t\t&dev_attr_authorized_default.attr,\n\t\t&dev_attr_interface_authorized_default.attr,\n\t\tNULL,\n};\n\nstatic const struct attribute_group usb_bus_attr_group = {\n\t.name = NULL,\t \n\t.attrs = usb_bus_attrs,\n};\n\n\nstatic int add_default_authorized_attributes(struct device *dev)\n{\n\tint rc = 0;\n\n\tif (is_usb_device(dev))\n\t\trc = sysfs_create_group(&dev->kobj, &usb_bus_attr_group);\n\n\treturn rc;\n}\n\nstatic void remove_default_authorized_attributes(struct device *dev)\n{\n\tif (is_usb_device(dev)) {\n\t\tsysfs_remove_group(&dev->kobj, &usb_bus_attr_group);\n\t}\n}\n\nint usb_create_sysfs_dev_files(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\tint retval;\n\n\tretval = device_create_bin_file(dev, &dev_bin_attr_descriptors);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = add_persist_attributes(dev);\n\tif (retval)\n\t\tgoto error;\n\n\tretval = add_power_attributes(dev);\n\tif (retval)\n\t\tgoto error;\n\n\tif (is_root_hub(udev)) {\n\t\tretval = add_default_authorized_attributes(dev);\n\t\tif (retval)\n\t\t\tgoto error;\n\t}\n\treturn retval;\n\nerror:\n\tusb_remove_sysfs_dev_files(udev);\n\treturn retval;\n}\n\nvoid usb_remove_sysfs_dev_files(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\n\tif (is_root_hub(udev))\n\t\tremove_default_authorized_attributes(dev);\n\n\tremove_power_attributes(dev);\n\tremove_persist_attributes(dev);\n\tdevice_remove_bin_file(dev, &dev_bin_attr_descriptors);\n}\n\n \n#define usb_intf_assoc_attr(field, format_string)\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\niad_##field##_show(struct device *dev, struct device_attribute *attr,\t\\\n\t\tchar *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_interface *intf = to_usb_interface(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string,\t\t\t\t\\\n\t\t\tintf->intf_assoc->field); \t\t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(iad_##field)\n\nusb_intf_assoc_attr(bFirstInterface, \"%02x\\n\");\nusb_intf_assoc_attr(bInterfaceCount, \"%02d\\n\");\nusb_intf_assoc_attr(bFunctionClass, \"%02x\\n\");\nusb_intf_assoc_attr(bFunctionSubClass, \"%02x\\n\");\nusb_intf_assoc_attr(bFunctionProtocol, \"%02x\\n\");\n\n \n#define usb_intf_attr(field, format_string)\t\t\t\t\\\nstatic ssize_t\t\t\t\t\t\t\t\t\\\nfield##_show(struct device *dev, struct device_attribute *attr,\t\t\\\n\t\tchar *buf)\t\t\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct usb_interface *intf = to_usb_interface(dev);\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn sysfs_emit(buf, format_string,\t\t\t\t\\\n\t\t\tintf->cur_altsetting->desc.field); \t\t\\\n}\t\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RO(field)\n\nusb_intf_attr(bInterfaceNumber, \"%02x\\n\");\nusb_intf_attr(bAlternateSetting, \"%2d\\n\");\nusb_intf_attr(bNumEndpoints, \"%02x\\n\");\nusb_intf_attr(bInterfaceClass, \"%02x\\n\");\nusb_intf_attr(bInterfaceSubClass, \"%02x\\n\");\nusb_intf_attr(bInterfaceProtocol, \"%02x\\n\");\n\nstatic ssize_t interface_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_interface *intf;\n\tchar *string;\n\n\tintf = to_usb_interface(dev);\n\tstring = READ_ONCE(intf->cur_altsetting->string);\n\tif (!string)\n\t\treturn 0;\n\treturn sysfs_emit(buf, \"%s\\n\", string);\n}\nstatic DEVICE_ATTR_RO(interface);\n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tstruct usb_interface *intf;\n\tstruct usb_device *udev;\n\tstruct usb_host_interface *alt;\n\n\tintf = to_usb_interface(dev);\n\tudev = interface_to_usbdev(intf);\n\talt = READ_ONCE(intf->cur_altsetting);\n\n\treturn sysfs_emit(buf,\n\t\t\t\"usb:v%04Xp%04Xd%04Xdc%02Xdsc%02Xdp%02X\"\n\t\t\t\"ic%02Xisc%02Xip%02Xin%02X\\n\",\n\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\tle16_to_cpu(udev->descriptor.idProduct),\n\t\t\tle16_to_cpu(udev->descriptor.bcdDevice),\n\t\t\tudev->descriptor.bDeviceClass,\n\t\t\tudev->descriptor.bDeviceSubClass,\n\t\t\tudev->descriptor.bDeviceProtocol,\n\t\t\talt->desc.bInterfaceClass,\n\t\t\talt->desc.bInterfaceSubClass,\n\t\t\talt->desc.bInterfaceProtocol,\n\t\t\talt->desc.bInterfaceNumber);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic ssize_t supports_autosuspend_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tint s;\n\n\ts = device_lock_interruptible(dev);\n\tif (s < 0)\n\t\treturn -EINTR;\n\t \n\ts = (!dev->driver || to_usb_driver(dev->driver)->supports_autosuspend);\n\tdevice_unlock(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", s);\n}\nstatic DEVICE_ATTR_RO(supports_autosuspend);\n\n \nstatic ssize_t interface_authorized_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\treturn sysfs_emit(buf, \"%u\\n\", intf->authorized);\n}\n\n \nstatic ssize_t interface_authorized_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tbool val;\n\n\tif (kstrtobool(buf, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif (val)\n\t\tusb_authorize_interface(intf);\n\telse\n\t\tusb_deauthorize_interface(intf);\n\n\treturn count;\n}\nstatic struct device_attribute dev_attr_interface_authorized =\n\t\t__ATTR(authorized, S_IRUGO | S_IWUSR,\n\t\tinterface_authorized_show, interface_authorized_store);\n\nstatic struct attribute *intf_attrs[] = {\n\t&dev_attr_bInterfaceNumber.attr,\n\t&dev_attr_bAlternateSetting.attr,\n\t&dev_attr_bNumEndpoints.attr,\n\t&dev_attr_bInterfaceClass.attr,\n\t&dev_attr_bInterfaceSubClass.attr,\n\t&dev_attr_bInterfaceProtocol.attr,\n\t&dev_attr_modalias.attr,\n\t&dev_attr_supports_autosuspend.attr,\n\t&dev_attr_interface_authorized.attr,\n\tNULL,\n};\nstatic const struct attribute_group intf_attr_grp = {\n\t.attrs = intf_attrs,\n};\n\nstatic struct attribute *intf_assoc_attrs[] = {\n\t&dev_attr_iad_bFirstInterface.attr,\n\t&dev_attr_iad_bInterfaceCount.attr,\n\t&dev_attr_iad_bFunctionClass.attr,\n\t&dev_attr_iad_bFunctionSubClass.attr,\n\t&dev_attr_iad_bFunctionProtocol.attr,\n\tNULL,\n};\n\nstatic umode_t intf_assoc_attrs_are_visible(struct kobject *kobj,\n\t\tstruct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\tif (intf->intf_assoc == NULL)\n\t\treturn 0;\n\treturn a->mode;\n}\n\nstatic const struct attribute_group intf_assoc_attr_grp = {\n\t.attrs =\tintf_assoc_attrs,\n\t.is_visible =\tintf_assoc_attrs_are_visible,\n};\n\nstatic ssize_t wireless_status_show(struct device *dev,\n\t\t\t\t    struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf;\n\n\tintf = to_usb_interface(dev);\n\tif (intf->wireless_status == USB_WIRELESS_STATUS_DISCONNECTED)\n\t\treturn sysfs_emit(buf, \"%s\\n\", \"disconnected\");\n\treturn sysfs_emit(buf, \"%s\\n\", \"connected\");\n}\nstatic DEVICE_ATTR_RO(wireless_status);\n\nstatic struct attribute *intf_wireless_status_attrs[] = {\n\t&dev_attr_wireless_status.attr,\n\tNULL\n};\n\nstatic umode_t intf_wireless_status_attr_is_visible(struct kobject *kobj,\n\t\tstruct attribute *a, int n)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\n\tif (a != &dev_attr_wireless_status.attr ||\n\t    intf->wireless_status != USB_WIRELESS_STATUS_NA)\n\t\treturn a->mode;\n\treturn 0;\n}\n\nstatic const struct attribute_group intf_wireless_status_attr_grp = {\n\t.attrs =\tintf_wireless_status_attrs,\n\t.is_visible =\tintf_wireless_status_attr_is_visible,\n};\n\nint usb_update_wireless_status_attr(struct usb_interface *intf)\n{\n\tstruct device *dev = &intf->dev;\n\tint ret;\n\n\tret = sysfs_update_group(&dev->kobj, &intf_wireless_status_attr_grp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsysfs_notify(&dev->kobj, NULL, \"wireless_status\");\n\tkobject_uevent(&dev->kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\n\nconst struct attribute_group *usb_interface_groups[] = {\n\t&intf_attr_grp,\n\t&intf_assoc_attr_grp,\n\t&intf_wireless_status_attr_grp,\n\tNULL\n};\n\nvoid usb_create_sysfs_intf_files(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct usb_host_interface *alt = intf->cur_altsetting;\n\n\tif (intf->sysfs_files_created || intf->unregistering)\n\t\treturn;\n\n\tif (!alt->string && !(udev->quirks & USB_QUIRK_CONFIG_INTF_STRINGS))\n\t\talt->string = usb_cache_string(udev, alt->desc.iInterface);\n\tif (alt->string && device_create_file(&intf->dev, &dev_attr_interface)) {\n\t\t \n\t\tdev_dbg(&intf->dev, \"interface string descriptor file not created\\n\");\n\t}\n\tintf->sysfs_files_created = 1;\n}\n\nvoid usb_remove_sysfs_intf_files(struct usb_interface *intf)\n{\n\tif (!intf->sysfs_files_created)\n\t\treturn;\n\n\tdevice_remove_file(&intf->dev, &dev_attr_interface);\n\tintf->sysfs_files_created = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}