{
  "module_name": "config.c",
  "hash_id": "1d27ba8388b1ebcedab17086d2cc879763ab9da718cb61ce6eee3f0b2e4ed3d2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/config.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/quirks.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/device.h>\n#include <asm/byteorder.h>\n#include \"usb.h\"\n\n\n#define USB_MAXALTSETTING\t\t128\t \n\n#define USB_MAXCONFIG\t\t\t8\t \n\n\nstatic inline const char *plural(int n)\n{\n\treturn (n == 1 ? \"\" : \"s\");\n}\n\nstatic int find_next_descriptor(unsigned char *buffer, int size,\n    int dt1, int dt2, int *num_skipped)\n{\n\tstruct usb_descriptor_header *h;\n\tint n = 0;\n\tunsigned char *buffer0 = buffer;\n\n\t \n\twhile (size > 0) {\n\t\th = (struct usb_descriptor_header *) buffer;\n\t\tif (h->bDescriptorType == dt1 || h->bDescriptorType == dt2)\n\t\t\tbreak;\n\t\tbuffer += h->bLength;\n\t\tsize -= h->bLength;\n\t\t++n;\n\t}\n\n\t \n\tif (num_skipped)\n\t\t*num_skipped = n;\n\treturn buffer - buffer0;\n}\n\nstatic void usb_parse_ssp_isoc_endpoint_companion(struct device *ddev,\n\t\tint cfgno, int inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ssp_isoc_ep_comp_descriptor *desc;\n\n\t \n\tdesc = (struct usb_ssp_isoc_ep_comp_descriptor *) buffer;\n\tif (desc->bDescriptorType != USB_DT_SSP_ISOC_ENDPOINT_COMP ||\n\t    size < USB_DT_SSP_ISOC_EP_COMP_SIZE) {\n\t\tdev_notice(ddev, \"Invalid SuperSpeedPlus isoc endpoint companion\"\n\t\t\t \"for config %d interface %d altsetting %d ep %d.\\n\",\n\t\t\t cfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\treturn;\n\t}\n\tmemcpy(&ep->ssp_isoc_ep_comp, desc, USB_DT_SSP_ISOC_EP_COMP_SIZE);\n}\n\nstatic void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,\n\t\tint inum, int asnum, struct usb_host_endpoint *ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_ss_ep_comp_descriptor *desc;\n\tint max_tx;\n\n\t \n\tdesc = (struct usb_ss_ep_comp_descriptor *) buffer;\n\n\tif (desc->bDescriptorType != USB_DT_SS_ENDPOINT_COMP ||\n\t\t\tsize < USB_DT_SS_EP_COMP_SIZE) {\n\t\tdev_notice(ddev, \"No SuperSpeed endpoint companion for config %d \"\n\t\t\t\t\" interface %d altsetting %d ep %d: \"\n\t\t\t\t\"using minimum values\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\n\t\t \n\t\tep->ss_ep_comp.bLength = USB_DT_SS_EP_COMP_SIZE;\n\t\tep->ss_ep_comp.bDescriptorType = USB_DT_SS_ENDPOINT_COMP;\n\t\tif (usb_endpoint_xfer_isoc(&ep->desc) ||\n\t\t\t\tusb_endpoint_xfer_int(&ep->desc))\n\t\t\tep->ss_ep_comp.wBytesPerInterval =\n\t\t\t\t\tep->desc.wMaxPacketSize;\n\t\treturn;\n\t}\n\tbuffer += desc->bLength;\n\tsize -= desc->bLength;\n\tmemcpy(&ep->ss_ep_comp, desc, USB_DT_SS_EP_COMP_SIZE);\n\n\t \n\tif (usb_endpoint_xfer_control(&ep->desc) && desc->bMaxBurst != 0) {\n\t\tdev_notice(ddev, \"Control endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 0;\n\t} else if (desc->bMaxBurst > 15) {\n\t\tdev_notice(ddev, \"Endpoint with bMaxBurst = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 15\\n\", desc->bMaxBurst,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bMaxBurst = 15;\n\t}\n\n\tif ((usb_endpoint_xfer_control(&ep->desc) ||\n\t\t\tusb_endpoint_xfer_int(&ep->desc)) &&\n\t\t\t\tdesc->bmAttributes != 0) {\n\t\tdev_notice(ddev, \"%s endpoint with bmAttributes = %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to zero\\n\",\n\t\t\t\tusb_endpoint_xfer_control(&ep->desc) ? \"Control\" : \"Bulk\",\n\t\t\t\tdesc->bmAttributes,\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 0;\n\t} else if (usb_endpoint_xfer_bulk(&ep->desc) &&\n\t\t\tdesc->bmAttributes > 16) {\n\t\tdev_notice(ddev, \"Bulk endpoint with more than 65536 streams in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to max\\n\",\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 16;\n\t} else if (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t\t   !USB_SS_SSP_ISOC_COMP(desc->bmAttributes) &&\n\t\t   USB_SS_MULT(desc->bmAttributes) > 3) {\n\t\tdev_notice(ddev, \"Isoc endpoint has Mult of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to 3\\n\",\n\t\t\t\tUSB_SS_MULT(desc->bmAttributes),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress);\n\t\tep->ss_ep_comp.bmAttributes = 2;\n\t}\n\n\tif (usb_endpoint_xfer_isoc(&ep->desc))\n\t\tmax_tx = (desc->bMaxBurst + 1) *\n\t\t\t(USB_SS_MULT(desc->bmAttributes)) *\n\t\t\tusb_endpoint_maxp(&ep->desc);\n\telse if (usb_endpoint_xfer_int(&ep->desc))\n\t\tmax_tx = usb_endpoint_maxp(&ep->desc) *\n\t\t\t(desc->bMaxBurst + 1);\n\telse\n\t\tmax_tx = 999999;\n\tif (le16_to_cpu(desc->wBytesPerInterval) > max_tx) {\n\t\tdev_notice(ddev, \"%s endpoint with wBytesPerInterval of %d in \"\n\t\t\t\t\"config %d interface %d altsetting %d ep %d: \"\n\t\t\t\t\"setting to %d\\n\",\n\t\t\t\tusb_endpoint_xfer_isoc(&ep->desc) ? \"Isoc\" : \"Int\",\n\t\t\t\tle16_to_cpu(desc->wBytesPerInterval),\n\t\t\t\tcfgno, inum, asnum, ep->desc.bEndpointAddress,\n\t\t\t\tmax_tx);\n\t\tep->ss_ep_comp.wBytesPerInterval = cpu_to_le16(max_tx);\n\t}\n\t \n\tif (usb_endpoint_xfer_isoc(&ep->desc) &&\n\t    USB_SS_SSP_ISOC_COMP(desc->bmAttributes))\n\t\tusb_parse_ssp_isoc_endpoint_companion(ddev, cfgno, inum, asnum,\n\t\t\t\t\t\t\tep, buffer, size);\n}\n\nstatic const unsigned short low_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 8,\n\t[USB_ENDPOINT_XFER_ISOC] = 0,\n\t[USB_ENDPOINT_XFER_BULK] = 0,\n\t[USB_ENDPOINT_XFER_INT] = 8,\n};\nstatic const unsigned short full_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1023,\n\t[USB_ENDPOINT_XFER_BULK] = 64,\n\t[USB_ENDPOINT_XFER_INT] = 64,\n};\nstatic const unsigned short high_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 64,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\n\t \n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\nstatic const unsigned short super_speed_maxpacket_maxes[4] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = 512,\n\t[USB_ENDPOINT_XFER_ISOC] = 1024,\n\t[USB_ENDPOINT_XFER_BULK] = 1024,\n\t[USB_ENDPOINT_XFER_INT] = 1024,\n};\n\nstatic bool endpoint_is_duplicate(struct usb_endpoint_descriptor *e1,\n\t\tstruct usb_endpoint_descriptor *e2)\n{\n\tif (e1->bEndpointAddress == e2->bEndpointAddress)\n\t\treturn true;\n\n\tif (usb_endpoint_xfer_control(e1) || usb_endpoint_xfer_control(e2)) {\n\t\tif (usb_endpoint_num(e1) == usb_endpoint_num(e2))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic bool config_endpoint_is_duplicate(struct usb_host_config *config,\n\t\tint inum, int asnum, struct usb_endpoint_descriptor *d)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, j, k;\n\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tintfc = config->intf_cache[i];\n\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\talt = &intfc->altsetting[j];\n\n\t\t\tif (alt->desc.bInterfaceNumber == inum &&\n\t\t\t\t\talt->desc.bAlternateSetting != asnum)\n\t\t\t\tcontinue;\n\n\t\t\tfor (k = 0; k < alt->desc.bNumEndpoints; ++k) {\n\t\t\t\tepd = &alt->endpoint[k].desc;\n\n\t\t\t\tif (endpoint_is_duplicate(epd, d))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic int usb_parse_endpoint(struct device *ddev, int cfgno,\n\t\tstruct usb_host_config *config, int inum, int asnum,\n\t\tstruct usb_host_interface *ifp, int num_ep,\n\t\tunsigned char *buffer, int size)\n{\n\tstruct usb_device *udev = to_usb_device(ddev);\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_endpoint_descriptor *d;\n\tstruct usb_host_endpoint *endpoint;\n\tint n, i, j, retval;\n\tunsigned int maxp;\n\tconst unsigned short *maxpacket_maxes;\n\n\td = (struct usb_endpoint_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength >= USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\tn = USB_DT_ENDPOINT_AUDIO_SIZE;\n\telse if (d->bLength >= USB_DT_ENDPOINT_SIZE)\n\t\tn = USB_DT_ENDPOINT_SIZE;\n\telse {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint descriptor of length %d, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bLength);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\ti = d->bEndpointAddress & ~USB_ENDPOINT_DIR_MASK;\n\tif (i >= 16 || i == 0) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d has an \"\n\t\t    \"invalid endpoint with address 0x%X, skipping\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t \n\tif (ifp->desc.bNumEndpoints >= num_ep)\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\n\t \n\tif (config_endpoint_is_duplicate(config, inum, asnum, d)) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d has a duplicate endpoint with address 0x%X, skipping\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress);\n\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t}\n\n\t \n\tif (udev->quirks & USB_QUIRK_ENDPOINT_IGNORE) {\n\t\tif (usb_endpoint_is_ignored(udev, ifp, d)) {\n\t\t\tdev_notice(ddev, \"config %d interface %d altsetting %d has an ignored endpoint with address 0x%X, skipping\\n\",\n\t\t\t\t\tcfgno, inum, asnum,\n\t\t\t\t\td->bEndpointAddress);\n\t\t\tgoto skip_to_next_endpoint_or_interface_descriptor;\n\t\t}\n\t}\n\n\tendpoint = &ifp->endpoint[ifp->desc.bNumEndpoints];\n\t++ifp->desc.bNumEndpoints;\n\n\tmemcpy(&endpoint->desc, d, n);\n\tINIT_LIST_HEAD(&endpoint->urb_list);\n\n\t \n\ti = 0;\t\t \n\tj = 255;\n\tif (usb_endpoint_xfer_int(d)) {\n\t\ti = 1;\n\t\tswitch (udev->speed) {\n\t\tcase USB_SPEED_SUPER_PLUS:\n\t\tcase USB_SPEED_SUPER:\n\t\tcase USB_SPEED_HIGH:\n\t\t\t \n\t\t\tn = fls(d->bInterval*8);\n\t\t\tif (n == 0)\n\t\t\t\tn = 7;\t \n\t\t\tj = 16;\n\n\t\t\t \n\t\t\t \n\t\t\tif (udev->quirks & USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval) + 3, i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\t \n\t\t\tif (udev->quirks & USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL) {\n\t\t\t\tn = clamp(fls(d->bInterval), i, j);\n\t\t\t\ti = j = n;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\t\t \n\t\t\t \n\t\t\tn = 10;\n\t\t\tbreak;\n\t\t}\n\t} else if (usb_endpoint_xfer_isoc(d)) {\n\t\ti = 1;\n\t\tj = 16;\n\t\tswitch (udev->speed) {\n\t\tcase USB_SPEED_HIGH:\n\t\t\tn = 7;\t\t \n\t\t\tbreak;\n\t\tdefault:\t\t \n\t\t\tn = 4;\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\tif (d->bInterval < i || d->bInterval > j) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X has an invalid bInterval %d, \"\n\t\t    \"changing to %d\\n\",\n\t\t    cfgno, inum, asnum,\n\t\t    d->bEndpointAddress, d->bInterval, n);\n\t\tendpoint->desc.bInterval = n;\n\t}\n\n\t \n\tif (udev->speed == USB_SPEED_LOW && usb_endpoint_xfer_bulk(d)) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d \"\n\t\t    \"endpoint 0x%X is Bulk; changing to Interrupt\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t\tendpoint->desc.bmAttributes = USB_ENDPOINT_XFER_INT;\n\t\tendpoint->desc.bInterval = 1;\n\t\tif (usb_endpoint_maxp(&endpoint->desc) > 8)\n\t\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(8);\n\t}\n\n\t \n\tmaxp = le16_to_cpu(endpoint->desc.wMaxPacketSize);\n\tif (maxp == 0 && !(usb_endpoint_xfer_isoc(d) && asnum == 0)) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid wMaxPacketSize 0\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress);\n\t}\n\n\t \n\ti = 0;\t\t \n\tswitch (udev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tmaxpacket_maxes = low_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tmaxpacket_maxes = full_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\t \n\t\tif (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {\n\t\t\ti = maxp & USB_EP_MAXP_MULT_MASK;\n\t\t\tmaxp &= ~i;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\tmaxpacket_maxes = high_speed_maxpacket_maxes;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmaxpacket_maxes = super_speed_maxpacket_maxes;\n\t\tbreak;\n\t}\n\tj = maxpacket_maxes[usb_endpoint_type(&endpoint->desc)];\n\n\tif (maxp > j) {\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\\n\",\n\t\t    cfgno, inum, asnum, d->bEndpointAddress, maxp, j);\n\t\tmaxp = j;\n\t\tendpoint->desc.wMaxPacketSize = cpu_to_le16(i | maxp);\n\t}\n\n\t \n\tif (udev->speed == USB_SPEED_HIGH && usb_endpoint_xfer_bulk(d)) {\n\t\tif (maxp != 512)\n\t\t\tdev_notice(ddev, \"config %d interface %d altsetting %d \"\n\t\t\t\t\"bulk endpoint 0x%X has invalid maxpacket %d\\n\",\n\t\t\t\tcfgno, inum, asnum, d->bEndpointAddress,\n\t\t\t\tmaxp);\n\t}\n\n\t \n\tif (udev->speed >= USB_SPEED_SUPER)\n\t\tusb_parse_ss_endpoint_companion(ddev, cfgno,\n\t\t\t\tinum, asnum, endpoint, buffer, size);\n\n\t \n\tendpoint->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t\t\tUSB_DT_INTERFACE, &n);\n\tendpoint->extralen = i;\n\tretval = buffer - buffer0 + i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"endpoint\");\n\treturn retval;\n\nskip_to_next_endpoint_or_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nvoid usb_release_interface_cache(struct kref *ref)\n{\n\tstruct usb_interface_cache *intfc = ref_to_usb_interface_cache(ref);\n\tint j;\n\n\tfor (j = 0; j < intfc->num_altsetting; j++) {\n\t\tstruct usb_host_interface *alt = &intfc->altsetting[j];\n\n\t\tkfree(alt->endpoint);\n\t\tkfree(alt->string);\n\t}\n\tkfree(intfc);\n}\n\nstatic int usb_parse_interface(struct device *ddev, int cfgno,\n    struct usb_host_config *config, unsigned char *buffer, int size,\n    u8 inums[], u8 nalts[])\n{\n\tunsigned char *buffer0 = buffer;\n\tstruct usb_interface_descriptor\t*d;\n\tint inum, asnum;\n\tstruct usb_interface_cache *intfc;\n\tstruct usb_host_interface *alt;\n\tint i, n;\n\tint len, retval;\n\tint num_ep, num_ep_orig;\n\n\td = (struct usb_interface_descriptor *) buffer;\n\tbuffer += d->bLength;\n\tsize -= d->bLength;\n\n\tif (d->bLength < USB_DT_INTERFACE_SIZE)\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t \n\tintfc = NULL;\n\tinum = d->bInterfaceNumber;\n\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\tif (inums[i] == inum) {\n\t\t\tintfc = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intfc || intfc->num_altsetting >= nalts[i])\n\t\tgoto skip_to_next_interface_descriptor;\n\n\t \n\tasnum = d->bAlternateSetting;\n\tfor ((i = 0, alt = &intfc->altsetting[0]);\n\t      i < intfc->num_altsetting;\n\t     (++i, ++alt)) {\n\t\tif (alt->desc.bAlternateSetting == asnum) {\n\t\t\tdev_notice(ddev, \"Duplicate descriptor for config %d \"\n\t\t\t    \"interface %d altsetting %d, skipping\\n\",\n\t\t\t    cfgno, inum, asnum);\n\t\t\tgoto skip_to_next_interface_descriptor;\n\t\t}\n\t}\n\n\t++intfc->num_altsetting;\n\tmemcpy(&alt->desc, d, USB_DT_INTERFACE_SIZE);\n\n\t \n\talt->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_ENDPOINT,\n\t    USB_DT_INTERFACE, &n);\n\talt->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"interface\");\n\tbuffer += i;\n\tsize -= i;\n\n\t \n\tnum_ep = num_ep_orig = alt->desc.bNumEndpoints;\n\talt->desc.bNumEndpoints = 0;\t\t \n\tif (num_ep > USB_MAXENDPOINTS) {\n\t\tdev_notice(ddev, \"too many endpoints for config %d interface %d \"\n\t\t    \"altsetting %d: %d, using maximum allowed: %d\\n\",\n\t\t    cfgno, inum, asnum, num_ep, USB_MAXENDPOINTS);\n\t\tnum_ep = USB_MAXENDPOINTS;\n\t}\n\n\tif (num_ep > 0) {\n\t\t \n\t\tlen = sizeof(struct usb_host_endpoint) * num_ep;\n\t\talt->endpoint = kzalloc(len, GFP_KERNEL);\n\t\tif (!alt->endpoint)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t \n\tn = 0;\n\twhile (size > 0) {\n\t\tif (((struct usb_descriptor_header *) buffer)->bDescriptorType\n\t\t     == USB_DT_INTERFACE)\n\t\t\tbreak;\n\t\tretval = usb_parse_endpoint(ddev, cfgno, config, inum, asnum,\n\t\t\t\talt, num_ep, buffer, size);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t\t++n;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\tif (n != num_ep_orig)\n\t\tdev_notice(ddev, \"config %d interface %d altsetting %d has %d \"\n\t\t    \"endpoint descriptor%s, different from the interface \"\n\t\t    \"descriptor's value: %d\\n\",\n\t\t    cfgno, inum, asnum, n, plural(n), num_ep_orig);\n\treturn buffer - buffer0;\n\nskip_to_next_interface_descriptor:\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, NULL);\n\treturn buffer - buffer0 + i;\n}\n\nstatic int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tconfig->desc.bNumInterfaces = 0;\t \n\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_notice(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_notice(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t \n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_notice(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_notice(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_notice(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_notice(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_notice(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t \n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_notice(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_notice(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_notice(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t \n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_notice(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_notice(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t \n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_notice(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t \n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_notice(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tintfc = kzalloc(struct_size(intfc, altsetting, j), GFP_KERNEL);\n\t\tconfig->intf_cache[i] = intfc;\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t \n\n\t \n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t \n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t \n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_notice(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n \nvoid usb_destroy_configuration(struct usb_device *dev)\n{\n\tint c, i;\n\n\tif (!dev->config)\n\t\treturn;\n\n\tif (dev->rawdescriptors) {\n\t\tfor (i = 0; i < dev->descriptor.bNumConfigurations; i++)\n\t\t\tkfree(dev->rawdescriptors[i]);\n\n\t\tkfree(dev->rawdescriptors);\n\t\tdev->rawdescriptors = NULL;\n\t}\n\n\tfor (c = 0; c < dev->descriptor.bNumConfigurations; c++) {\n\t\tstruct usb_host_config *cf = &dev->config[c];\n\n\t\tkfree(cf->string);\n\t\tfor (i = 0; i < cf->desc.bNumInterfaces; i++) {\n\t\t\tif (cf->intf_cache[i])\n\t\t\t\tkref_put(&cf->intf_cache[i]->ref,\n\t\t\t\t\t  usb_release_interface_cache);\n\t\t}\n\t}\n\tkfree(dev->config);\n\tdev->config = NULL;\n}\n\n\n \nint usb_get_configuration(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tint ncfg = dev->descriptor.bNumConfigurations;\n\tunsigned int cfgno, length;\n\tunsigned char *bigbuffer;\n\tstruct usb_config_descriptor *desc;\n\tint result;\n\n\tif (ncfg > USB_MAXCONFIG) {\n\t\tdev_notice(ddev, \"too many configurations: %d, \"\n\t\t    \"using maximum allowed: %d\\n\", ncfg, USB_MAXCONFIG);\n\t\tdev->descriptor.bNumConfigurations = ncfg = USB_MAXCONFIG;\n\t}\n\n\tif (ncfg < 1) {\n\t\tdev_err(ddev, \"no configurations\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlength = ncfg * sizeof(struct usb_host_config);\n\tdev->config = kzalloc(length, GFP_KERNEL);\n\tif (!dev->config)\n\t\treturn -ENOMEM;\n\n\tlength = ncfg * sizeof(char *);\n\tdev->rawdescriptors = kzalloc(length, GFP_KERNEL);\n\tif (!dev->rawdescriptors)\n\t\treturn -ENOMEM;\n\n\tdesc = kmalloc(USB_DT_CONFIG_SIZE, GFP_KERNEL);\n\tif (!desc)\n\t\treturn -ENOMEM;\n\n\tfor (cfgno = 0; cfgno < ncfg; cfgno++) {\n\t\t \n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    desc, USB_DT_CONFIG_SIZE);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s: %d\\n\", cfgno, \"start\", result);\n\t\t\tif (result != -EPIPE)\n\t\t\t\tgoto err;\n\t\t\tdev_notice(ddev, \"chopping to %d config(s)\\n\", cfgno);\n\t\t\tdev->descriptor.bNumConfigurations = cfgno;\n\t\t\tbreak;\n\t\t} else if (result < 4) {\n\t\t\tdev_err(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno,\n\t\t\t    USB_DT_CONFIG_SIZE, result);\n\t\t\tresult = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t\tlength = max((int) le16_to_cpu(desc->wTotalLength),\n\t\t    USB_DT_CONFIG_SIZE);\n\n\t\t \n\t\tbigbuffer = kmalloc(length, GFP_KERNEL);\n\t\tif (!bigbuffer) {\n\t\t\tresult = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (dev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(200);\n\n\t\tresult = usb_get_descriptor(dev, USB_DT_CONFIG, cfgno,\n\t\t    bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\tdev_err(ddev, \"unable to read config index %d \"\n\t\t\t    \"descriptor/%s\\n\", cfgno, \"all\");\n\t\t\tkfree(bigbuffer);\n\t\t\tgoto err;\n\t\t}\n\t\tif (result < length) {\n\t\t\tdev_notice(ddev, \"config index %d descriptor too short \"\n\t\t\t    \"(expected %i, got %i)\\n\", cfgno, length, result);\n\t\t\tlength = result;\n\t\t}\n\n\t\tdev->rawdescriptors[cfgno] = bigbuffer;\n\n\t\tresult = usb_parse_configuration(dev, cfgno,\n\t\t    &dev->config[cfgno], bigbuffer, length);\n\t\tif (result < 0) {\n\t\t\t++cfgno;\n\t\t\tgoto err;\n\t\t}\n\t}\n\nerr:\n\tkfree(desc);\n\tdev->descriptor.bNumConfigurations = cfgno;\n\n\treturn result;\n}\n\nvoid usb_release_bos_descriptor(struct usb_device *dev)\n{\n\tif (dev->bos) {\n\t\tkfree(dev->bos->desc);\n\t\tkfree(dev->bos);\n\t\tdev->bos = NULL;\n\t}\n}\n\nstatic const __u8 bos_desc_len[256] = {\n\t[USB_CAP_TYPE_WIRELESS_USB] = USB_DT_USB_WIRELESS_CAP_SIZE,\n\t[USB_CAP_TYPE_EXT]          = USB_DT_USB_EXT_CAP_SIZE,\n\t[USB_SS_CAP_TYPE]           = USB_DT_USB_SS_CAP_SIZE,\n\t[USB_SSP_CAP_TYPE]          = USB_DT_USB_SSP_CAP_SIZE(1),\n\t[CONTAINER_ID_TYPE]         = USB_DT_USB_SS_CONTN_ID_SIZE,\n\t[USB_PTM_CAP_TYPE]          = USB_DT_USB_PTM_ID_SIZE,\n};\n\n \nint usb_get_bos_descriptor(struct usb_device *dev)\n{\n\tstruct device *ddev = &dev->dev;\n\tstruct usb_bos_descriptor *bos;\n\tstruct usb_dev_cap_header *cap;\n\tstruct usb_ssp_cap_descriptor *ssp_cap;\n\tunsigned char *buffer, *buffer0;\n\tint length, total_len, num, i, ssac;\n\t__u8 cap_type;\n\tint ret;\n\n\tbos = kzalloc(sizeof(*bos), GFP_KERNEL);\n\tif (!bos)\n\t\treturn -ENOMEM;\n\n\t \n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, bos, USB_DT_BOS_SIZE);\n\tif (ret < USB_DT_BOS_SIZE || bos->bLength < USB_DT_BOS_SIZE) {\n\t\tdev_notice(ddev, \"unable to get BOS descriptor or descriptor too short\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tkfree(bos);\n\t\treturn ret;\n\t}\n\n\tlength = bos->bLength;\n\ttotal_len = le16_to_cpu(bos->wTotalLength);\n\tnum = bos->bNumDeviceCaps;\n\tkfree(bos);\n\tif (total_len < length)\n\t\treturn -EINVAL;\n\n\tdev->bos = kzalloc(sizeof(*dev->bos), GFP_KERNEL);\n\tif (!dev->bos)\n\t\treturn -ENOMEM;\n\n\t \n\tbuffer = kzalloc(total_len, GFP_KERNEL);\n\tif (!buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\tdev->bos->desc = (struct usb_bos_descriptor *)buffer;\n\n\tret = usb_get_descriptor(dev, USB_DT_BOS, 0, buffer, total_len);\n\tif (ret < total_len) {\n\t\tdev_notice(ddev, \"unable to get BOS descriptor set\\n\");\n\t\tif (ret >= 0)\n\t\t\tret = -ENOMSG;\n\t\tgoto err;\n\t}\n\n\tbuffer0 = buffer;\n\ttotal_len -= length;\n\tbuffer += length;\n\n\tfor (i = 0; i < num; i++) {\n\t\tcap = (struct usb_dev_cap_header *)buffer;\n\n\t\tif (total_len < sizeof(*cap) || total_len < cap->bLength) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\t\tcap_type = cap->bDevCapabilityType;\n\t\tlength = cap->bLength;\n\t\tif (bos_desc_len[cap_type] && length < bos_desc_len[cap_type]) {\n\t\t\tdev->bos->desc->bNumDeviceCaps = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cap->bDescriptorType != USB_DT_DEVICE_CAPABILITY) {\n\t\t\tdev_notice(ddev, \"descriptor type invalid, skip\\n\");\n\t\t\tgoto skip_to_next_descriptor;\n\t\t}\n\n\t\tswitch (cap_type) {\n\t\tcase USB_CAP_TYPE_EXT:\n\t\t\tdev->bos->ext_cap =\n\t\t\t\t(struct usb_ext_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SS_CAP_TYPE:\n\t\t\tdev->bos->ss_cap =\n\t\t\t\t(struct usb_ss_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_SSP_CAP_TYPE:\n\t\t\tssp_cap = (struct usb_ssp_cap_descriptor *)buffer;\n\t\t\tssac = (le32_to_cpu(ssp_cap->bmAttributes) &\n\t\t\t\tUSB_SSP_SUBLINK_SPEED_ATTRIBS);\n\t\t\tif (length >= USB_DT_USB_SSP_CAP_SIZE(ssac))\n\t\t\t\tdev->bos->ssp_cap = ssp_cap;\n\t\t\tbreak;\n\t\tcase CONTAINER_ID_TYPE:\n\t\t\tdev->bos->ss_id =\n\t\t\t\t(struct usb_ss_container_id_descriptor *)buffer;\n\t\t\tbreak;\n\t\tcase USB_PTM_CAP_TYPE:\n\t\t\tdev->bos->ptm_cap =\n\t\t\t\t(struct usb_ptm_cap_descriptor *)buffer;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\nskip_to_next_descriptor:\n\t\ttotal_len -= length;\n\t\tbuffer += length;\n\t}\n\tdev->bos->desc->wTotalLength = cpu_to_le16(buffer - buffer0);\n\n\treturn 0;\n\nerr:\n\tusb_release_bos_descriptor(dev);\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}