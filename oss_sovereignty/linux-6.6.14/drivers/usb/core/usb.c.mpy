{
  "module_name": "usb.c",
  "hash_id": "c966bc07cfaec354d4d271243d44f11b3d9e317117e64ac2558b10532dbcc65f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/usb.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/of.h>\n#include <linux/string.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/init.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/mutex.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/usb/of.h>\n\n#include <asm/io.h>\n#include <linux/scatterlist.h>\n#include <linux/mm.h>\n#include <linux/dma-mapping.h>\n\n#include \"hub.h\"\n\nconst char *usbcore_name = \"usbcore\";\n\nstatic bool nousb;\t \n\nmodule_param(nousb, bool, 0444);\n\n \nint usb_disabled(void)\n{\n\treturn nousb;\n}\nEXPORT_SYMBOL_GPL(usb_disabled);\n\n#ifdef\tCONFIG_PM\n \nstatic int usb_autosuspend_delay = CONFIG_USB_AUTOSUSPEND_DELAY;\nmodule_param_named(autosuspend, usb_autosuspend_delay, int, 0644);\nMODULE_PARM_DESC(autosuspend, \"default autosuspend delay\");\n\n#else\n#define usb_autosuspend_delay\t\t0\n#endif\n\nstatic bool match_endpoint(struct usb_endpoint_descriptor *epd,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tswitch (usb_endpoint_type(epd)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (bulk_in && !*bulk_in) {\n\t\t\t\t*bulk_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bulk_out && !*bulk_out) {\n\t\t\t\t*bulk_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (usb_endpoint_dir_in(epd)) {\n\t\t\tif (int_in && !*int_in) {\n\t\t\t\t*int_in = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (int_out && !*int_out) {\n\t\t\t\t*int_out = epd;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn (!bulk_in || *bulk_in) && (!bulk_out || *bulk_out) &&\n\t\t\t(!int_in || *int_in) && (!int_out || *int_out);\n}\n\n \nint usb_find_common_endpoints(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints);\n\n \nint usb_find_common_endpoints_reverse(struct usb_host_interface *alt,\n\t\tstruct usb_endpoint_descriptor **bulk_in,\n\t\tstruct usb_endpoint_descriptor **bulk_out,\n\t\tstruct usb_endpoint_descriptor **int_in,\n\t\tstruct usb_endpoint_descriptor **int_out)\n{\n\tstruct usb_endpoint_descriptor *epd;\n\tint i;\n\n\tif (bulk_in)\n\t\t*bulk_in = NULL;\n\tif (bulk_out)\n\t\t*bulk_out = NULL;\n\tif (int_in)\n\t\t*int_in = NULL;\n\tif (int_out)\n\t\t*int_out = NULL;\n\n\tfor (i = alt->desc.bNumEndpoints - 1; i >= 0; --i) {\n\t\tepd = &alt->endpoint[i].desc;\n\n\t\tif (match_endpoint(epd, bulk_in, bulk_out, int_in, int_out))\n\t\t\treturn 0;\n\t}\n\n\treturn -ENXIO;\n}\nEXPORT_SYMBOL_GPL(usb_find_common_endpoints_reverse);\n\n \nstatic const struct usb_host_endpoint *usb_find_endpoint(\n\t\tconst struct usb_interface *intf, unsigned int ep_addr)\n{\n\tint n;\n\tconst struct usb_host_endpoint *ep;\n\n\tn = intf->cur_altsetting->desc.bNumEndpoints;\n\tep = intf->cur_altsetting->endpoint;\n\tfor (; n > 0; (--n, ++ep)) {\n\t\tif (ep->desc.bEndpointAddress == ep_addr)\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n \nbool usb_check_bulk_endpoints(\n\t\tconst struct usb_interface *intf, const u8 *ep_addrs)\n{\n\tconst struct usb_host_endpoint *ep;\n\n\tfor (; *ep_addrs; ++ep_addrs) {\n\t\tep = usb_find_endpoint(intf, *ep_addrs);\n\t\tif (!ep || !usb_endpoint_xfer_bulk(&ep->desc))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(usb_check_bulk_endpoints);\n\n \nbool usb_check_int_endpoints(\n\t\tconst struct usb_interface *intf, const u8 *ep_addrs)\n{\n\tconst struct usb_host_endpoint *ep;\n\n\tfor (; *ep_addrs; ++ep_addrs) {\n\t\tep = usb_find_endpoint(intf, *ep_addrs);\n\t\tif (!ep || !usb_endpoint_xfer_int(&ep->desc))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nEXPORT_SYMBOL_GPL(usb_check_int_endpoints);\n\n \nstruct usb_host_interface *usb_find_alt_setting(\n\t\tstruct usb_host_config *config,\n\t\tunsigned int iface_num,\n\t\tunsigned int alt_num)\n{\n\tstruct usb_interface_cache *intf_cache = NULL;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++) {\n\t\tif (config->intf_cache[i]->altsetting[0].desc.bInterfaceNumber\n\t\t\t\t== iface_num) {\n\t\t\tintf_cache = config->intf_cache[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!intf_cache)\n\t\treturn NULL;\n\tfor (i = 0; i < intf_cache->num_altsetting; i++)\n\t\tif (intf_cache->altsetting[i].desc.bAlternateSetting == alt_num)\n\t\t\treturn &intf_cache->altsetting[i];\n\n\tprintk(KERN_DEBUG \"Did not find alt setting %u for intf %u, \"\n\t\t\t\"config %u\\n\", alt_num, iface_num,\n\t\t\tconfig->desc.bConfigurationValue);\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_alt_setting);\n\n \nstruct usb_interface *usb_ifnum_to_if(const struct usb_device *dev,\n\t\t\t\t      unsigned ifnum)\n{\n\tstruct usb_host_config *config = dev->actconfig;\n\tint i;\n\n\tif (!config)\n\t\treturn NULL;\n\tfor (i = 0; i < config->desc.bNumInterfaces; i++)\n\t\tif (config->interface[i]->altsetting[0]\n\t\t\t\t.desc.bInterfaceNumber == ifnum)\n\t\t\treturn config->interface[i];\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_ifnum_to_if);\n\n \nstruct usb_host_interface *usb_altnum_to_altsetting(\n\t\t\t\t\tconst struct usb_interface *intf,\n\t\t\t\t\tunsigned int altnum)\n{\n\tint i;\n\n\tfor (i = 0; i < intf->num_altsetting; i++) {\n\t\tif (intf->altsetting[i].desc.bAlternateSetting == altnum)\n\t\t\treturn &intf->altsetting[i];\n\t}\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(usb_altnum_to_altsetting);\n\nstruct find_interface_arg {\n\tint minor;\n\tstruct device_driver *drv;\n};\n\nstatic int __find_interface(struct device *dev, const void *data)\n{\n\tconst struct find_interface_arg *arg = data;\n\tstruct usb_interface *intf;\n\n\tif (!is_usb_interface(dev))\n\t\treturn 0;\n\n\tif (dev->driver != arg->drv)\n\t\treturn 0;\n\tintf = to_usb_interface(dev);\n\treturn intf->minor == arg->minor;\n}\n\n \nstruct usb_interface *usb_find_interface(struct usb_driver *drv, int minor)\n{\n\tstruct find_interface_arg argb;\n\tstruct device *dev;\n\n\targb.minor = minor;\n\targb.drv = &drv->drvwrap.driver;\n\n\tdev = bus_find_device(&usb_bus_type, NULL, &argb, __find_interface);\n\n\t \n\tput_device(dev);\n\n\treturn dev ? to_usb_interface(dev) : NULL;\n}\nEXPORT_SYMBOL_GPL(usb_find_interface);\n\nstruct each_dev_arg {\n\tvoid *data;\n\tint (*fn)(struct usb_device *, void *);\n};\n\nstatic int __each_dev(struct device *dev, void *data)\n{\n\tstruct each_dev_arg *arg = (struct each_dev_arg *)data;\n\n\t \n\tif (!is_usb_device(dev))\n\t\treturn 0;\n\n\treturn arg->fn(to_usb_device(dev), arg->data);\n}\n\n \nint usb_for_each_dev(void *data, int (*fn)(struct usb_device *, void *))\n{\n\tstruct each_dev_arg arg = {data, fn};\n\n\treturn bus_for_each_dev(&usb_bus_type, NULL, &arg, __each_dev);\n}\nEXPORT_SYMBOL_GPL(usb_for_each_dev);\n\n \nstatic void usb_release_dev(struct device *dev)\n{\n\tstruct usb_device *udev;\n\tstruct usb_hcd *hcd;\n\n\tudev = to_usb_device(dev);\n\thcd = bus_to_hcd(udev->bus);\n\n\tusb_destroy_configuration(udev);\n\tusb_release_bos_descriptor(udev);\n\tof_node_put(dev->of_node);\n\tusb_put_hcd(hcd);\n\tkfree(udev->product);\n\tkfree(udev->manufacturer);\n\tkfree(udev->serial);\n\tkfree(udev);\n}\n\nstatic int usb_dev_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\n\tif (add_uevent_var(env, \"BUSNUM=%03d\", usb_dev->bus->busnum))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"DEVNUM=%03d\", usb_dev->devnum))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n#ifdef\tCONFIG_PM\n\n \n\nstatic int usb_dev_prepare(struct device *dev)\n{\n\treturn 0;\t\t \n}\n\nstatic void usb_dev_complete(struct device *dev)\n{\n\t \n\tusb_resume_complete(dev);\n}\n\nstatic int usb_dev_suspend(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_SUSPEND);\n}\n\nstatic int usb_dev_resume(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESUME);\n}\n\nstatic int usb_dev_freeze(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_FREEZE);\n}\n\nstatic int usb_dev_thaw(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_THAW);\n}\n\nstatic int usb_dev_poweroff(struct device *dev)\n{\n\treturn usb_suspend(dev, PMSG_HIBERNATE);\n}\n\nstatic int usb_dev_restore(struct device *dev)\n{\n\treturn usb_resume(dev, PMSG_RESTORE);\n}\n\nstatic const struct dev_pm_ops usb_device_pm_ops = {\n\t.prepare =\tusb_dev_prepare,\n\t.complete =\tusb_dev_complete,\n\t.suspend =\tusb_dev_suspend,\n\t.resume =\tusb_dev_resume,\n\t.freeze =\tusb_dev_freeze,\n\t.thaw =\t\tusb_dev_thaw,\n\t.poweroff =\tusb_dev_poweroff,\n\t.restore =\tusb_dev_restore,\n\t.runtime_suspend =\tusb_runtime_suspend,\n\t.runtime_resume =\tusb_runtime_resume,\n\t.runtime_idle =\t\tusb_runtime_idle,\n};\n\n#endif\t \n\n\nstatic char *usb_devnode(const struct device *dev,\n\t\t\t umode_t *mode, kuid_t *uid, kgid_t *gid)\n{\n\tconst struct usb_device *usb_dev;\n\n\tusb_dev = to_usb_device(dev);\n\treturn kasprintf(GFP_KERNEL, \"bus/usb/%03d/%03d\",\n\t\t\t usb_dev->bus->busnum, usb_dev->devnum);\n}\n\nstruct device_type usb_device_type = {\n\t.name =\t\t\"usb_device\",\n\t.release =\tusb_release_dev,\n\t.uevent =\tusb_dev_uevent,\n\t.devnode = \tusb_devnode,\n#ifdef CONFIG_PM\n\t.pm =\t\t&usb_device_pm_ops,\n#endif\n};\n\nstatic bool usb_dev_authorized(struct usb_device *dev, struct usb_hcd *hcd)\n{\n\tstruct usb_hub *hub;\n\n\tif (!dev->parent)\n\t\treturn true;  \n\n\tswitch (hcd->dev_policy) {\n\tcase USB_DEVICE_AUTHORIZE_NONE:\n\tdefault:\n\t\treturn false;\n\n\tcase USB_DEVICE_AUTHORIZE_ALL:\n\t\treturn true;\n\n\tcase USB_DEVICE_AUTHORIZE_INTERNAL:\n\t\thub = usb_hub_to_struct_hub(dev->parent);\n\t\treturn hub->ports[dev->portnum - 1]->connect_type ==\n\t\t\t\tUSB_PORT_CONNECT_TYPE_HARD_WIRED;\n\t}\n}\n\n \nstruct usb_device *usb_alloc_dev(struct usb_device *parent,\n\t\t\t\t struct usb_bus *bus, unsigned port1)\n{\n\tstruct usb_device *dev;\n\tstruct usb_hcd *usb_hcd = bus_to_hcd(bus);\n\tunsigned raw_port = port1;\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn NULL;\n\n\tif (!usb_get_hcd(usb_hcd)) {\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\t \n\tif (usb_hcd->driver->alloc_dev && parent &&\n\t\t!usb_hcd->driver->alloc_dev(usb_hcd, dev)) {\n\t\tusb_put_hcd(bus_to_hcd(bus));\n\t\tkfree(dev);\n\t\treturn NULL;\n\t}\n\n\tdevice_initialize(&dev->dev);\n\tdev->dev.bus = &usb_bus_type;\n\tdev->dev.type = &usb_device_type;\n\tdev->dev.groups = usb_device_groups;\n\tset_dev_node(&dev->dev, dev_to_node(bus->sysdev));\n\tdev->state = USB_STATE_ATTACHED;\n\tdev->lpm_disable_count = 1;\n\tatomic_set(&dev->urbnum, 0);\n\n\tINIT_LIST_HEAD(&dev->ep0.urb_list);\n\tdev->ep0.desc.bLength = USB_DT_ENDPOINT_SIZE;\n\tdev->ep0.desc.bDescriptorType = USB_DT_ENDPOINT;\n\t \n\tusb_enable_endpoint(dev, &dev->ep0, false);\n\tdev->can_submit = 1;\n\n\t \n\tif (unlikely(!parent)) {\n\t\tdev->devpath[0] = '0';\n\t\tdev->route = 0;\n\n\t\tdev->dev.parent = bus->controller;\n\t\tdevice_set_of_node_from_dev(&dev->dev, bus->sysdev);\n\t\tdev_set_name(&dev->dev, \"usb%d\", bus->busnum);\n\t} else {\n\t\t \n\t\tif (parent->devpath[0] == '0') {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%d\", port1);\n\t\t\t \n\t\t\tdev->route = 0;\n\t\t} else {\n\t\t\tsnprintf(dev->devpath, sizeof dev->devpath,\n\t\t\t\t\"%s.%d\", parent->devpath, port1);\n\t\t\t \n\t\t\tif (port1 < 15)\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(port1 << ((parent->level - 1)*4));\n\t\t\telse\n\t\t\t\tdev->route = parent->route +\n\t\t\t\t\t(15 << ((parent->level - 1)*4));\n\t\t}\n\n\t\tdev->dev.parent = &parent->dev;\n\t\tdev_set_name(&dev->dev, \"%d-%s\", bus->busnum, dev->devpath);\n\n\t\tif (!parent->parent) {\n\t\t\t \n\t\t\traw_port = usb_hcd_find_raw_port_number(usb_hcd,\n\t\t\t\tport1);\n\t\t}\n\t\tdev->dev.of_node = usb_of_get_device_node(parent, raw_port);\n\n\t\t \n\t}\n\n\tdev->portnum = port1;\n\tdev->bus = bus;\n\tdev->parent = parent;\n\tINIT_LIST_HEAD(&dev->filelist);\n\n#ifdef\tCONFIG_PM\n\tpm_runtime_set_autosuspend_delay(&dev->dev,\n\t\t\tusb_autosuspend_delay * 1000);\n\tdev->connect_time = jiffies;\n\tdev->active_duration = -jiffies;\n#endif\n\n\tdev->authorized = usb_dev_authorized(dev, usb_hcd);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_alloc_dev);\n\n \nstruct usb_device *usb_get_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tget_device(&dev->dev);\n\treturn dev;\n}\nEXPORT_SYMBOL_GPL(usb_get_dev);\n\n \nvoid usb_put_dev(struct usb_device *dev)\n{\n\tif (dev)\n\t\tput_device(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_dev);\n\n \nstruct usb_interface *usb_get_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tget_device(&intf->dev);\n\treturn intf;\n}\nEXPORT_SYMBOL_GPL(usb_get_intf);\n\n \nvoid usb_put_intf(struct usb_interface *intf)\n{\n\tif (intf)\n\t\tput_device(&intf->dev);\n}\nEXPORT_SYMBOL_GPL(usb_put_intf);\n\n \nstruct device *usb_intf_get_dma_device(struct usb_interface *intf)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct device *dmadev;\n\n\tif (!udev->bus)\n\t\treturn NULL;\n\n\tdmadev = get_device(udev->bus->sysdev);\n\tif (!dmadev || !dmadev->dma_mask) {\n\t\tput_device(dmadev);\n\t\treturn NULL;\n\t}\n\n\treturn dmadev;\n}\nEXPORT_SYMBOL_GPL(usb_intf_get_dma_device);\n\n \n\n \nint usb_lock_device_for_reset(struct usb_device *udev,\n\t\t\t      const struct usb_interface *iface)\n{\n\tunsigned long jiffies_expire = jiffies + HZ;\n\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\treturn -EHOSTUNREACH;\n\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\treturn -EINTR;\n\n\twhile (!usb_trylock_device(udev)) {\n\n\t\t \n\t\tif (time_after(jiffies, jiffies_expire))\n\t\t\treturn -EBUSY;\n\n\t\tmsleep(15);\n\t\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t\treturn -ENODEV;\n\t\tif (udev->state == USB_STATE_SUSPENDED)\n\t\t\treturn -EHOSTUNREACH;\n\t\tif (iface && (iface->condition == USB_INTERFACE_UNBINDING ||\n\t\t\t\tiface->condition == USB_INTERFACE_UNBOUND))\n\t\t\treturn -EINTR;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_lock_device_for_reset);\n\n \nint usb_get_current_frame_number(struct usb_device *dev)\n{\n\treturn usb_hcd_get_frame_number(dev);\n}\nEXPORT_SYMBOL_GPL(usb_get_current_frame_number);\n\n \n \n\nint __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr, size_t minsize)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2 || header->bLength > size) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t\"%s: bogus descriptor, type %d length %d\\n\",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(__usb_get_extra_descriptor);\n\n \nvoid *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\n\t\t\t dma_addr_t *dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn NULL;\n\treturn hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\n}\nEXPORT_SYMBOL_GPL(usb_alloc_coherent);\n\n \nvoid usb_free_coherent(struct usb_device *dev, size_t size, void *addr,\n\t\t       dma_addr_t dma)\n{\n\tif (!dev || !dev->bus)\n\t\treturn;\n\tif (!addr)\n\t\treturn;\n\thcd_buffer_free(dev->bus, size, addr, dma);\n}\nEXPORT_SYMBOL_GPL(usb_free_coherent);\n\n \nstatic int usb_bus_notify(struct notifier_block *nb, unsigned long action,\n\t\tvoid *data)\n{\n\tstruct device *dev = data;\n\n\tswitch (action) {\n\tcase BUS_NOTIFY_ADD_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\t(void) usb_create_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_create_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\n\tcase BUS_NOTIFY_DEL_DEVICE:\n\t\tif (dev->type == &usb_device_type)\n\t\t\tusb_remove_sysfs_dev_files(to_usb_device(dev));\n\t\telse if (dev->type == &usb_if_device_type)\n\t\t\tusb_remove_sysfs_intf_files(to_usb_interface(dev));\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic struct notifier_block usb_bus_nb = {\n\t.notifier_call = usb_bus_notify,\n};\n\nstatic void usb_debugfs_init(void)\n{\n\tdebugfs_create_file(\"devices\", 0444, usb_debug_root, NULL,\n\t\t\t    &usbfs_devices_fops);\n}\n\nstatic void usb_debugfs_cleanup(void)\n{\n\tdebugfs_lookup_and_remove(\"devices\", usb_debug_root);\n}\n\n \nstatic int __init usb_init(void)\n{\n\tint retval;\n\tif (usb_disabled()) {\n\t\tpr_info(\"%s: USB support disabled\\n\", usbcore_name);\n\t\treturn 0;\n\t}\n\tusb_init_pool_max();\n\n\tusb_debugfs_init();\n\n\tusb_acpi_register();\n\tretval = bus_register(&usb_bus_type);\n\tif (retval)\n\t\tgoto bus_register_failed;\n\tretval = bus_register_notifier(&usb_bus_type, &usb_bus_nb);\n\tif (retval)\n\t\tgoto bus_notifier_failed;\n\tretval = usb_major_init();\n\tif (retval)\n\t\tgoto major_init_failed;\n\tretval = class_register(&usbmisc_class);\n\tif (retval)\n\t\tgoto class_register_failed;\n\tretval = usb_register(&usbfs_driver);\n\tif (retval)\n\t\tgoto driver_register_failed;\n\tretval = usb_devio_init();\n\tif (retval)\n\t\tgoto usb_devio_init_failed;\n\tretval = usb_hub_init();\n\tif (retval)\n\t\tgoto hub_init_failed;\n\tretval = usb_register_device_driver(&usb_generic_driver, THIS_MODULE);\n\tif (!retval)\n\t\tgoto out;\n\n\tusb_hub_cleanup();\nhub_init_failed:\n\tusb_devio_cleanup();\nusb_devio_init_failed:\n\tusb_deregister(&usbfs_driver);\ndriver_register_failed:\n\tclass_unregister(&usbmisc_class);\nclass_register_failed:\n\tusb_major_cleanup();\nmajor_init_failed:\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\nbus_notifier_failed:\n\tbus_unregister(&usb_bus_type);\nbus_register_failed:\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\nout:\n\treturn retval;\n}\n\n \nstatic void __exit usb_exit(void)\n{\n\t \n\tif (usb_disabled())\n\t\treturn;\n\n\tusb_release_quirk_list();\n\tusb_deregister_device_driver(&usb_generic_driver);\n\tusb_major_cleanup();\n\tusb_deregister(&usbfs_driver);\n\tusb_devio_cleanup();\n\tusb_hub_cleanup();\n\tclass_unregister(&usbmisc_class);\n\tbus_unregister_notifier(&usb_bus_type, &usb_bus_nb);\n\tbus_unregister(&usb_bus_type);\n\tusb_acpi_unregister();\n\tusb_debugfs_cleanup();\n\tidr_destroy(&usb_bus_idr);\n}\n\nsubsys_initcall(usb_init);\nmodule_exit(usb_exit);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}