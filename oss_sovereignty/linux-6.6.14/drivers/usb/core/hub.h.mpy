{
  "module_name": "hub.h",
  "hash_id": "c7fe8c81caf22ecb00e82f8212c6cb31047db83dfaeb4d2a3cd5c7369f4bcca2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/core/hub.h",
  "human_readable_source": " \n \n\n#include <linux/usb.h>\n#include <linux/usb/ch11.h>\n#include <linux/usb/hcd.h>\n#include \"usb.h\"\n\nstruct usb_hub {\n\tstruct device\t\t*intfdev;\t \n\tstruct usb_device\t*hdev;\n\tstruct kref\t\tkref;\n\tstruct urb\t\t*urb;\t\t \n\n\t \n\tu8\t\t\t(*buffer)[8];\n\tunion {\n\t\tstruct usb_hub_status\thub;\n\t\tstruct usb_port_status\tport;\n\t}\t\t\t*status;\t \n\tstruct mutex\t\tstatus_mutex;\t \n\n\tint\t\t\terror;\t\t \n\tint\t\t\tnerrors;\t \n\n\tunsigned long\t\tevent_bits[1];\t \n\tunsigned long\t\tchange_bits[1];\t \n\tunsigned long\t\tremoved_bits[1];  \n\tunsigned long\t\twakeup_bits[1];\t \n\tunsigned long\t\tpower_bits[1];  \n\tunsigned long\t\tchild_usage_bits[1];  \n\tunsigned long\t\twarm_reset_bits[1];  \n#if USB_MAXCHILDREN > 31  \n#error event_bits[] is too short!\n#endif\n\n\tstruct usb_hub_descriptor *descriptor;\t \n\tstruct usb_tt\t\ttt;\t\t \n\n\tunsigned\t\tmA_per_port;\t \n#ifdef\tCONFIG_PM\n\tunsigned\t\twakeup_enabled_descendants;\n#endif\n\n\tunsigned\t\tlimited_power:1;\n\tunsigned\t\tquiescing:1;\n\tunsigned\t\tdisconnected:1;\n\tunsigned\t\tin_reset:1;\n\tunsigned\t\tquirk_disable_autosuspend:1;\n\n\tunsigned\t\tquirk_check_port_auto_suspend:1;\n\n\tunsigned\t\thas_indicators:1;\n\tu8\t\t\tindicator[USB_MAXCHILDREN];\n\tstruct delayed_work\tleds;\n\tstruct delayed_work\tinit_work;\n\tstruct work_struct      events;\n\tspinlock_t\t\tirq_urb_lock;\n\tstruct timer_list\tirq_urb_retry;\n\tstruct usb_port\t\t**ports;\n\tstruct list_head        onboard_hub_devs;\n};\n\n \nstruct usb_port {\n\tstruct usb_device *child;\n\tstruct device dev;\n\tstruct usb_dev_state *port_owner;\n\tstruct usb_port *peer;\n\tstruct dev_pm_qos_request *req;\n\tenum usb_port_connect_type connect_type;\n\tenum usb_device_state state;\n\tstruct kernfs_node *state_kn;\n\tusb_port_location_t location;\n\tstruct mutex status_lock;\n\tu32 over_current_count;\n\tu8 portnum;\n\tu32 quirks;\n\tunsigned int early_stop:1;\n\tunsigned int ignore_event:1;\n\tunsigned int is_superspeed:1;\n\tunsigned int usb3_lpm_u1_permit:1;\n\tunsigned int usb3_lpm_u2_permit:1;\n};\n\n#define to_usb_port(_dev) \\\n\tcontainer_of(_dev, struct usb_port, dev)\n\nextern int usb_hub_create_port_device(struct usb_hub *hub,\n\t\tint port1);\nextern void usb_hub_remove_port_device(struct usb_hub *hub,\n\t\tint port1);\nextern int usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\tint port1, bool set);\nextern struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev);\nextern int hub_port_debounce(struct usb_hub *hub, int port1,\n\t\tbool must_be_connected);\nextern int usb_clear_port_feature(struct usb_device *hdev,\n\t\tint port1, int feature);\nextern int usb_hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change);\nextern int usb_port_is_power_on(struct usb_hub *hub, unsigned int portstatus);\n\nstatic inline bool hub_is_port_power_switchable(struct usb_hub *hub)\n{\n\t__le16 hcs;\n\n\tif (!hub)\n\t\treturn false;\n\thcs = hub->descriptor->wHubCharacteristics;\n\treturn (le16_to_cpu(hcs) & HUB_CHAR_LPSM) < HUB_CHAR_NO_LPSM;\n}\n\nstatic inline int hub_is_superspeed(struct usb_device *hdev)\n{\n\treturn hdev->descriptor.bDeviceProtocol == USB_HUB_PR_SS;\n}\n\nstatic inline int hub_is_superspeedplus(struct usb_device *hdev)\n{\n\treturn (hdev->descriptor.bDeviceProtocol == USB_HUB_PR_SS &&\n\t\tle16_to_cpu(hdev->descriptor.bcdUSB) >= 0x0310 &&\n\t\thdev->bos && hdev->bos->ssp_cap);\n}\n\nstatic inline unsigned hub_power_on_good_delay(struct usb_hub *hub)\n{\n\tunsigned delay = hub->descriptor->bPwrOn2PwrGood * 2;\n\n\tif (!hub->hdev->parent)\t \n\t\treturn delay;\n\telse  \n\t\treturn max(delay, 100U);\n}\n\nstatic inline int hub_port_debounce_be_connected(struct usb_hub *hub,\n\t\tint port1)\n{\n\treturn hub_port_debounce(hub, port1, true);\n}\n\nstatic inline int hub_port_debounce_be_stable(struct usb_hub *hub,\n\t\tint port1)\n{\n\treturn hub_port_debounce(hub, port1, false);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}