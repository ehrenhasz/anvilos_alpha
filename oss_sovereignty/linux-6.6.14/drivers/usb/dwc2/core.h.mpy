{
  "module_name": "core.h",
  "hash_id": "85c56404424b18efb60301b44128e3daa6b39a7253d8e81d8bcf9aa79ad6f8c5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/core.h",
  "human_readable_source": " \n \n\n#ifndef __DWC2_CORE_H__\n#define __DWC2_CORE_H__\n\n#include <linux/acpi.h>\n#include <linux/phy/phy.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/phy.h>\n#include \"hw.h\"\n\n \n\n#define DWC2_TRACE_SCHEDULER\t\tno_printk\n#define DWC2_TRACE_SCHEDULER_VB\t\tno_printk\n\n \n#define dwc2_sch_dbg(hsotg, fmt, ...)\t\t\t\t\t\\\n\tDWC2_TRACE_SCHEDULER(pr_fmt(\"%s: SCH: \" fmt),\t\t\t\\\n\t\t\t     dev_name(hsotg->dev), ##__VA_ARGS__)\n\n \n#define dwc2_sch_vdbg(hsotg, fmt, ...)\t\t\t\t\t\\\n\tDWC2_TRACE_SCHEDULER_VB(pr_fmt(\"%s: SCH: \" fmt),\t\t\\\n\t\t\t\tdev_name(hsotg->dev), ##__VA_ARGS__)\n\n \n#define MAX_EPS_CHANNELS\t16\n\n \nstatic const char * const dwc2_hsotg_supply_names[] = {\n\t\"vusb_d\",                \n\t\"vusb_a\",                \n};\n\n#define DWC2_NUM_SUPPLIES ARRAY_SIZE(dwc2_hsotg_supply_names)\n\n \n#define EP0_MPS_LIMIT   64\n\nstruct dwc2_hsotg;\nstruct dwc2_hsotg_req;\n\n \nstruct dwc2_hsotg_ep {\n\tstruct usb_ep           ep;\n\tstruct list_head        queue;\n\tstruct dwc2_hsotg       *parent;\n\tstruct dwc2_hsotg_req    *req;\n\tstruct dentry           *debugfs;\n\n\tunsigned long           total_data;\n\tunsigned int            size_loaded;\n\tunsigned int            last_load;\n\tunsigned int            fifo_load;\n\tunsigned short          fifo_size;\n\tunsigned short\t\tfifo_index;\n\n\tunsigned char           dir_in;\n\tunsigned char           map_dir;\n\tunsigned char           index;\n\tunsigned char           mc;\n\tu16                     interval;\n\n\tunsigned int            halted:1;\n\tunsigned int            periodic:1;\n\tunsigned int            isochronous:1;\n\tunsigned int            send_zlp:1;\n\tunsigned int            wedged:1;\n\tunsigned int            target_frame;\n#define TARGET_FRAME_INITIAL   0xFFFFFFFF\n\tbool\t\t\tframe_overrun;\n\n\tdma_addr_t\t\tdesc_list_dma;\n\tstruct dwc2_dma_desc\t*desc_list;\n\tu8\t\t\tdesc_count;\n\n\tunsigned int\t\tnext_desc;\n\tunsigned int\t\tcompl_desc;\n\n\tchar                    name[10];\n};\n\n \nstruct dwc2_hsotg_req {\n\tstruct usb_request      req;\n\tstruct list_head        queue;\n\tvoid *saved_req_buf;\n};\n\n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\n#define call_gadget(_hs, _entry) \\\ndo { \\\n\tif ((_hs)->gadget.speed != USB_SPEED_UNKNOWN && \\\n\t\t(_hs)->driver && (_hs)->driver->_entry) { \\\n\t\tspin_unlock(&_hs->lock); \\\n\t\t(_hs)->driver->_entry(&(_hs)->gadget); \\\n\t\tspin_lock(&_hs->lock); \\\n\t} \\\n} while (0)\n#else\n#define call_gadget(_hs, _entry)\tdo {} while (0)\n#endif\n\nstruct dwc2_hsotg;\nstruct dwc2_host_chan;\n\n \nenum dwc2_lx_state {\n\tDWC2_L0,\t \n\tDWC2_L1,\t \n\tDWC2_L2,\t \n\tDWC2_L3,\t \n};\n\n \nenum dwc2_ep0_state {\n\tDWC2_EP0_SETUP,\n\tDWC2_EP0_DATA_IN,\n\tDWC2_EP0_DATA_OUT,\n\tDWC2_EP0_STATUS_IN,\n\tDWC2_EP0_STATUS_OUT,\n};\n\n \nstruct dwc2_core_params {\n\tstruct usb_otg_caps otg_caps;\n\tu8 phy_type;\n#define DWC2_PHY_TYPE_PARAM_FS\t\t0\n#define DWC2_PHY_TYPE_PARAM_UTMI\t1\n#define DWC2_PHY_TYPE_PARAM_ULPI\t2\n\n\tu8 speed;\n#define DWC2_SPEED_PARAM_HIGH\t0\n#define DWC2_SPEED_PARAM_FULL\t1\n#define DWC2_SPEED_PARAM_LOW\t2\n\n\tu8 phy_utmi_width;\n\tbool phy_ulpi_ddr;\n\tbool phy_ulpi_ext_vbus;\n\tbool enable_dynamic_fifo;\n\tbool en_multiple_tx_fifo;\n\tbool i2c_enable;\n\tbool acg_enable;\n\tbool ulpi_fs_ls;\n\tbool ts_dline;\n\tbool reload_ctl;\n\tbool uframe_sched;\n\tbool external_id_pin_ctl;\n\n\tint power_down;\n#define DWC2_POWER_DOWN_PARAM_NONE\t\t0\n#define DWC2_POWER_DOWN_PARAM_PARTIAL\t\t1\n#define DWC2_POWER_DOWN_PARAM_HIBERNATION\t2\n\tbool no_clock_gating;\n\n\tbool lpm;\n\tbool lpm_clock_gating;\n\tbool besl;\n\tbool hird_threshold_en;\n\tbool service_interval;\n\tu8 hird_threshold;\n\tbool activate_stm_fs_transceiver;\n\tbool activate_stm_id_vb_detection;\n\tbool activate_ingenic_overcurrent_detection;\n\tbool ipg_isoc_en;\n\tu16 max_packet_count;\n\tu32 max_transfer_size;\n\tu32 ahbcfg;\n\n\t \n\tu32 ref_clk_per;\n\tu16 sof_cnt_wkup_alert;\n\n\t \n\tbool host_dma;\n\tbool dma_desc_enable;\n\tbool dma_desc_fs_enable;\n\tbool host_support_fs_ls_low_power;\n\tbool host_ls_low_power_phy_clk;\n\tbool oc_disable;\n\n\tu8 host_channels;\n\tu16 host_rx_fifo_size;\n\tu16 host_nperio_tx_fifo_size;\n\tu16 host_perio_tx_fifo_size;\n\n\t \n\tbool g_dma;\n\tbool g_dma_desc;\n\tu32 g_rx_fifo_size;\n\tu32 g_np_tx_fifo_size;\n\tu32 g_tx_fifo_size[MAX_EPS_CHANNELS];\n\n\tbool change_speed_quirk;\n};\n\n \nstruct dwc2_hw_params {\n\tunsigned op_mode:3;\n\tunsigned arch:2;\n\tunsigned dma_desc_enable:1;\n\tunsigned enable_dynamic_fifo:1;\n\tunsigned en_multiple_tx_fifo:1;\n\tunsigned rx_fifo_size:16;\n\tunsigned host_nperio_tx_fifo_size:16;\n\tunsigned dev_nperio_tx_fifo_size:16;\n\tunsigned host_perio_tx_fifo_size:16;\n\tunsigned nperio_tx_q_depth:3;\n\tunsigned host_perio_tx_q_depth:3;\n\tunsigned dev_token_q_depth:5;\n\tunsigned max_transfer_size:26;\n\tunsigned max_packet_count:11;\n\tunsigned host_channels:5;\n\tunsigned hs_phy_type:2;\n\tunsigned fs_phy_type:2;\n\tunsigned i2c_enable:1;\n\tunsigned acg_enable:1;\n\tunsigned num_dev_ep:4;\n\tunsigned num_dev_in_eps : 4;\n\tunsigned num_dev_perio_in_ep:4;\n\tunsigned total_fifo_size:16;\n\tunsigned power_optimized:1;\n\tunsigned hibernation:1;\n\tunsigned utmi_phy_data_width:2;\n\tunsigned lpm_mode:1;\n\tunsigned ipg_isoc_en:1;\n\tunsigned service_interval_mode:1;\n\tu32 snpsid;\n\tu32 dev_ep_dirs;\n\tu32 g_tx_fifo_size[MAX_EPS_CHANNELS];\n};\n\n \n#define DWC2_CTRL_BUFF_SIZE 8\n\n \nstruct dwc2_gregs_backup {\n\tu32 gotgctl;\n\tu32 gintmsk;\n\tu32 gahbcfg;\n\tu32 gusbcfg;\n\tu32 grxfsiz;\n\tu32 gnptxfsiz;\n\tu32 gi2cctl;\n\tu32 glpmcfg;\n\tu32 pcgcctl;\n\tu32 pcgcctl1;\n\tu32 gdfifocfg;\n\tu32 gpwrdn;\n\tbool valid;\n};\n\n \nstruct dwc2_dregs_backup {\n\tu32 dcfg;\n\tu32 dctl;\n\tu32 daintmsk;\n\tu32 diepmsk;\n\tu32 doepmsk;\n\tu32 diepctl[MAX_EPS_CHANNELS];\n\tu32 dieptsiz[MAX_EPS_CHANNELS];\n\tu32 diepdma[MAX_EPS_CHANNELS];\n\tu32 doepctl[MAX_EPS_CHANNELS];\n\tu32 doeptsiz[MAX_EPS_CHANNELS];\n\tu32 doepdma[MAX_EPS_CHANNELS];\n\tu32 dtxfsiz[MAX_EPS_CHANNELS];\n\tbool valid;\n};\n\n \nstruct dwc2_hregs_backup {\n\tu32 hcfg;\n\tu32 haintmsk;\n\tu32 hcintmsk[MAX_EPS_CHANNELS];\n\tu32 hprt0;\n\tu32 hfir;\n\tu32 hptxfsiz;\n\tbool valid;\n};\n\n \n#define DWC2_US_PER_UFRAME\t\t125\n#define DWC2_HS_PERIODIC_US_PER_UFRAME\t100\n\n#define DWC2_HS_SCHEDULE_UFRAMES\t8\n#define DWC2_HS_SCHEDULE_US\t\t(DWC2_HS_SCHEDULE_UFRAMES * \\\n\t\t\t\t\t DWC2_HS_PERIODIC_US_PER_UFRAME)\n\n \n#define DWC2_US_PER_SLICE\t25\n#define DWC2_SLICES_PER_UFRAME\t(DWC2_US_PER_UFRAME / DWC2_US_PER_SLICE)\n\n#define DWC2_ROUND_US_TO_SLICE(us) \\\n\t\t\t\t(DIV_ROUND_UP((us), DWC2_US_PER_SLICE) * \\\n\t\t\t\t DWC2_US_PER_SLICE)\n\n#define DWC2_LS_PERIODIC_US_PER_FRAME \\\n\t\t\t\t900\n#define DWC2_LS_PERIODIC_SLICES_PER_FRAME \\\n\t\t\t\t(DWC2_LS_PERIODIC_US_PER_FRAME / \\\n\t\t\t\t DWC2_US_PER_SLICE)\n\n#define DWC2_LS_SCHEDULE_FRAMES\t1\n#define DWC2_LS_SCHEDULE_SLICES\t(DWC2_LS_SCHEDULE_FRAMES * \\\n\t\t\t\t DWC2_LS_PERIODIC_SLICES_PER_FRAME)\n\n \nstruct dwc2_hsotg {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\t \n\tstruct dwc2_hw_params hw_params;\n\t \n\tstruct dwc2_core_params params;\n\tenum usb_otg_state op_state;\n\tenum usb_dr_mode dr_mode;\n\tstruct usb_role_switch *role_sw;\n\tenum usb_dr_mode role_sw_default_mode;\n\tunsigned int hcd_enabled:1;\n\tunsigned int gadget_enabled:1;\n\tunsigned int ll_hw_enabled:1;\n\tunsigned int hibernated:1;\n\tunsigned int in_ppd:1;\n\tbool bus_suspended;\n\tunsigned int reset_phy_on_wake:1;\n\tunsigned int need_phy_for_wake:1;\n\tunsigned int phy_off_for_suspend:1;\n\tu16 frame_number;\n\n\tstruct phy *phy;\n\tstruct usb_phy *uphy;\n\tstruct dwc2_hsotg_plat *plat;\n\tstruct regulator_bulk_data supplies[DWC2_NUM_SUPPLIES];\n\tstruct regulator *vbus_supply;\n\tstruct regulator *usb33d;\n\n\tspinlock_t lock;\n\tvoid *priv;\n\tint     irq;\n\tstruct clk *clk;\n\tstruct clk *utmi_clk;\n\tstruct reset_control *reset;\n\tstruct reset_control *reset_ecc;\n\n\tunsigned int queuing_high_bandwidth:1;\n\tunsigned int srp_success:1;\n\n\tstruct workqueue_struct *wq_otg;\n\tstruct work_struct wf_otg;\n\tstruct timer_list wkp_timer;\n\tenum dwc2_lx_state lx_state;\n\tstruct dwc2_gregs_backup gr_backup;\n\tstruct dwc2_dregs_backup dr_backup;\n\tstruct dwc2_hregs_backup hr_backup;\n\n\tstruct dentry *debug_root;\n\tstruct debugfs_regset32 *regset;\n\tbool needs_byte_swap;\n\n\t \n#define DWC2_CORE_REV_2_71a\t0x4f54271a\n#define DWC2_CORE_REV_2_72a     0x4f54272a\n#define DWC2_CORE_REV_2_80a\t0x4f54280a\n#define DWC2_CORE_REV_2_90a\t0x4f54290a\n#define DWC2_CORE_REV_2_91a\t0x4f54291a\n#define DWC2_CORE_REV_2_92a\t0x4f54292a\n#define DWC2_CORE_REV_2_94a\t0x4f54294a\n#define DWC2_CORE_REV_3_00a\t0x4f54300a\n#define DWC2_CORE_REV_3_10a\t0x4f54310a\n#define DWC2_CORE_REV_4_00a\t0x4f54400a\n#define DWC2_CORE_REV_4_20a\t0x4f54420a\n#define DWC2_FS_IOT_REV_1_00a\t0x5531100a\n#define DWC2_HS_IOT_REV_1_00a\t0x5532100a\n#define DWC2_CORE_REV_MASK\t0x0000ffff\n\n\t \n#define DWC2_OTG_ID\t\t0x4f540000\n#define DWC2_FS_IOT_ID\t\t0x55310000\n#define DWC2_HS_IOT_ID\t\t0x55320000\n\n#if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\n\tunion dwc2_hcd_internal_flags {\n\t\tu32 d32;\n\t\tstruct {\n\t\t\tunsigned port_connect_status_change:1;\n\t\t\tunsigned port_connect_status:1;\n\t\t\tunsigned port_reset_change:1;\n\t\t\tunsigned port_enable_change:1;\n\t\t\tunsigned port_suspend_change:1;\n\t\t\tunsigned port_over_current_change:1;\n\t\t\tunsigned port_l1_change:1;\n\t\t\tunsigned reserved:25;\n\t\t} b;\n\t} flags;\n\n\tstruct list_head non_periodic_sched_inactive;\n\tstruct list_head non_periodic_sched_waiting;\n\tstruct list_head non_periodic_sched_active;\n\tstruct list_head *non_periodic_qh_ptr;\n\tstruct list_head periodic_sched_inactive;\n\tstruct list_head periodic_sched_ready;\n\tstruct list_head periodic_sched_assigned;\n\tstruct list_head periodic_sched_queued;\n\tstruct list_head split_order;\n\tu16 periodic_usecs;\n\tDECLARE_BITMAP(hs_periodic_bitmap, DWC2_HS_SCHEDULE_US);\n\tu16 periodic_qh_count;\n\tbool new_connection;\n\n\tu16 last_frame_num;\n\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\n#define FRAME_NUM_ARRAY_SIZE 1000\n\tu16 *frame_num_array;\n\tu16 *last_frame_num_array;\n\tint frame_num_idx;\n\tint dumped_frame_num_array;\n#endif\n\n\tstruct list_head free_hc_list;\n\tint periodic_channels;\n\tint non_periodic_channels;\n\tint available_host_channels;\n\tstruct dwc2_host_chan *hc_ptr_array[MAX_EPS_CHANNELS];\n\tu8 *status_buf;\n\tdma_addr_t status_buf_dma;\n#define DWC2_HCD_STATUS_BUF_SIZE 64\n\n\tstruct delayed_work start_work;\n\tstruct delayed_work reset_work;\n\tstruct work_struct phy_reset_work;\n\tu8 otg_port;\n\tu32 *frame_list;\n\tdma_addr_t frame_list_dma;\n\tu32 frame_list_sz;\n\tstruct kmem_cache *desc_gen_cache;\n\tstruct kmem_cache *desc_hsisoc_cache;\n\tstruct kmem_cache *unaligned_cache;\n#define DWC2_KMEM_UNALIGNED_BUF_SIZE 1024\n\n#endif  \n\n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\n\t \n\tstruct usb_gadget_driver *driver;\n\tint fifo_mem;\n\tunsigned int dedicated_fifos:1;\n\tunsigned char num_of_eps;\n\tu32 fifo_map;\n\n\tstruct usb_request *ep0_reply;\n\tstruct usb_request *ctrl_req;\n\tvoid *ep0_buff;\n\tvoid *ctrl_buff;\n\tenum dwc2_ep0_state ep0_state;\n\tunsigned delayed_status : 1;\n\tu8 test_mode;\n\n\tdma_addr_t setup_desc_dma[2];\n\tstruct dwc2_dma_desc *setup_desc[2];\n\tdma_addr_t ctrl_in_desc_dma;\n\tstruct dwc2_dma_desc *ctrl_in_desc;\n\tdma_addr_t ctrl_out_desc_dma;\n\tstruct dwc2_dma_desc *ctrl_out_desc;\n\n\tstruct usb_gadget gadget;\n\tunsigned int enabled:1;\n\tunsigned int connected:1;\n\tunsigned int remote_wakeup_allowed:1;\n\tstruct dwc2_hsotg_ep *eps_in[MAX_EPS_CHANNELS];\n\tstruct dwc2_hsotg_ep *eps_out[MAX_EPS_CHANNELS];\n#endif  \n};\n\n \nstatic inline u32 dwc2_readl(struct dwc2_hsotg *hsotg, u32 offset)\n{\n\tu32 val;\n\n\tval = readl(hsotg->regs + offset);\n\tif (hsotg->needs_byte_swap)\n\t\treturn swab32(val);\n\telse\n\t\treturn val;\n}\n\nstatic inline void dwc2_writel(struct dwc2_hsotg *hsotg, u32 value, u32 offset)\n{\n\tif (hsotg->needs_byte_swap)\n\t\twritel(swab32(value), hsotg->regs + offset);\n\telse\n\t\twritel(value, hsotg->regs + offset);\n\n#ifdef DWC2_LOG_WRITES\n\tpr_info(\"info:: wrote %08x to %p\\n\", value, hsotg->regs + offset);\n#endif\n}\n\nstatic inline void dwc2_readl_rep(struct dwc2_hsotg *hsotg, u32 offset,\n\t\t\t\t  void *buffer, unsigned int count)\n{\n\tif (count) {\n\t\tu32 *buf = buffer;\n\n\t\tdo {\n\t\t\tu32 x = dwc2_readl(hsotg, offset);\n\t\t\t*buf++ = x;\n\t\t} while (--count);\n\t}\n}\n\nstatic inline void dwc2_writel_rep(struct dwc2_hsotg *hsotg, u32 offset,\n\t\t\t\t   const void *buffer, unsigned int count)\n{\n\tif (count) {\n\t\tconst u32 *buf = buffer;\n\n\t\tdo {\n\t\t\tdwc2_writel(hsotg, *buf++, offset);\n\t\t} while (--count);\n\t}\n}\n\n \nenum dwc2_halt_status {\n\tDWC2_HC_XFER_NO_HALT_STATUS,\n\tDWC2_HC_XFER_COMPLETE,\n\tDWC2_HC_XFER_URB_COMPLETE,\n\tDWC2_HC_XFER_ACK,\n\tDWC2_HC_XFER_NAK,\n\tDWC2_HC_XFER_NYET,\n\tDWC2_HC_XFER_STALL,\n\tDWC2_HC_XFER_XACT_ERR,\n\tDWC2_HC_XFER_FRAME_OVERRUN,\n\tDWC2_HC_XFER_BABBLE_ERR,\n\tDWC2_HC_XFER_DATA_TOGGLE_ERR,\n\tDWC2_HC_XFER_AHB_ERR,\n\tDWC2_HC_XFER_PERIODIC_INCOMPLETE,\n\tDWC2_HC_XFER_URB_DEQUEUE,\n};\n\n \nstatic inline bool dwc2_is_iot(struct dwc2_hsotg *hsotg)\n{\n\treturn (hsotg->hw_params.snpsid & 0xfff00000) == 0x55300000;\n}\n\nstatic inline bool dwc2_is_fs_iot(struct dwc2_hsotg *hsotg)\n{\n\treturn (hsotg->hw_params.snpsid & 0xffff0000) == 0x55310000;\n}\n\nstatic inline bool dwc2_is_hs_iot(struct dwc2_hsotg *hsotg)\n{\n\treturn (hsotg->hw_params.snpsid & 0xffff0000) == 0x55320000;\n}\n\n \nint dwc2_core_reset(struct dwc2_hsotg *hsotg, bool skip_wait);\nint dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg);\nint dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t\t bool restore);\nint dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host);\nint dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\tint reset, int is_host);\nvoid dwc2_init_fs_ls_pclk_sel(struct dwc2_hsotg *hsotg);\nint dwc2_phy_init(struct dwc2_hsotg *hsotg, bool select_phy);\n\nvoid dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host);\nvoid dwc2_force_dr_mode(struct dwc2_hsotg *hsotg);\n\nbool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg);\n\nint dwc2_check_core_version(struct dwc2_hsotg *hsotg);\n\n \nvoid dwc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes);\nvoid dwc2_flush_tx_fifo(struct dwc2_hsotg *hsotg, const int num);\nvoid dwc2_flush_rx_fifo(struct dwc2_hsotg *hsotg);\n\nvoid dwc2_enable_global_interrupts(struct dwc2_hsotg *hcd);\nvoid dwc2_disable_global_interrupts(struct dwc2_hsotg *hcd);\n\nvoid dwc2_hib_restore_common(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t     int is_host);\nint dwc2_backup_global_registers(struct dwc2_hsotg *hsotg);\nint dwc2_restore_global_registers(struct dwc2_hsotg *hsotg);\n\nvoid dwc2_enable_acg(struct dwc2_hsotg *hsotg);\n\n \nirqreturn_t dwc2_handle_common_intr(int irq, void *dev);\n\n \nextern const struct of_device_id dwc2_of_match_table[];\nextern const struct acpi_device_id dwc2_acpi_match[];\nextern const struct pci_device_id dwc2_pci_ids[];\n\nint dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg);\nint dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg);\n\n \nint dwc2_hsotg_wait_bit_set(struct dwc2_hsotg *hs_otg, u32 reg, u32 bit,\n\t\t\t    u32 timeout);\nint dwc2_hsotg_wait_bit_clear(struct dwc2_hsotg *hs_otg, u32 reg, u32 bit,\n\t\t\t      u32 timeout);\n \nint dwc2_get_hwparams(struct dwc2_hsotg *hsotg);\nint dwc2_init_params(struct dwc2_hsotg *hsotg);\n\n \nunsigned int dwc2_op_mode(struct dwc2_hsotg *hsotg);\nbool dwc2_hw_is_otg(struct dwc2_hsotg *hsotg);\nbool dwc2_hw_is_host(struct dwc2_hsotg *hsotg);\nbool dwc2_hw_is_device(struct dwc2_hsotg *hsotg);\n\n \nstatic inline int dwc2_is_host_mode(struct dwc2_hsotg *hsotg)\n{\n\treturn (dwc2_readl(hsotg, GINTSTS) & GINTSTS_CURMODE_HOST) != 0;\n}\n\nstatic inline int dwc2_is_device_mode(struct dwc2_hsotg *hsotg)\n{\n\treturn (dwc2_readl(hsotg, GINTSTS) & GINTSTS_CURMODE_HOST) == 0;\n}\n\nint dwc2_drd_init(struct dwc2_hsotg *hsotg);\nvoid dwc2_drd_suspend(struct dwc2_hsotg *hsotg);\nvoid dwc2_drd_resume(struct dwc2_hsotg *hsotg);\nvoid dwc2_drd_exit(struct dwc2_hsotg *hsotg);\n\n \nvoid dwc2_dump_dev_registers(struct dwc2_hsotg *hsotg);\nvoid dwc2_dump_host_registers(struct dwc2_hsotg *hsotg);\nvoid dwc2_dump_global_registers(struct dwc2_hsotg *hsotg);\n\n \n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\nint dwc2_hsotg_remove(struct dwc2_hsotg *hsotg);\nint dwc2_hsotg_suspend(struct dwc2_hsotg *dwc2);\nint dwc2_hsotg_resume(struct dwc2_hsotg *dwc2);\nint dwc2_gadget_init(struct dwc2_hsotg *hsotg);\nvoid dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *dwc2,\n\t\t\t\t       bool reset);\nvoid dwc2_hsotg_core_disconnect(struct dwc2_hsotg *hsotg);\nvoid dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg);\nvoid dwc2_hsotg_disconnect(struct dwc2_hsotg *dwc2);\nint dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode);\n#define dwc2_is_device_connected(hsotg) (hsotg->connected)\n#define dwc2_is_device_enabled(hsotg) (hsotg->enabled)\nint dwc2_backup_device_registers(struct dwc2_hsotg *hsotg);\nint dwc2_restore_device_registers(struct dwc2_hsotg *hsotg, int remote_wakeup);\nint dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg);\nint dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,\n\t\t\t\t int rem_wakeup, int reset);\nint dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg);\nint dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tbool restore);\nvoid dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg);\nvoid dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,\n\t\t\t\t   int rem_wakeup);\nint dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg);\nint dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg);\nint dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg);\nvoid dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg);\nvoid dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg);\nstatic inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg)\n{ hsotg->fifo_map = 0; }\n#else\nstatic inline int dwc2_hsotg_remove(struct dwc2_hsotg *dwc2)\n{ return 0; }\nstatic inline int dwc2_hsotg_suspend(struct dwc2_hsotg *dwc2)\n{ return 0; }\nstatic inline int dwc2_hsotg_resume(struct dwc2_hsotg *dwc2)\n{ return 0; }\nstatic inline int dwc2_gadget_init(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *dwc2,\n\t\t\t\t\t\t     bool reset) {}\nstatic inline void dwc2_hsotg_core_disconnect(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_hsotg_disconnect(struct dwc2_hsotg *dwc2) {}\nstatic inline int dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t   int testmode)\n{ return 0; }\n#define dwc2_is_device_connected(hsotg) (0)\n#define dwc2_is_device_enabled(hsotg) (0)\nstatic inline int dwc2_backup_device_registers(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_restore_device_registers(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\tint remote_wakeup)\n{ return 0; }\nstatic inline int dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t       int rem_wakeup, int reset)\n{ return 0; }\nstatic inline int dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t      bool restore)\n{ return 0; }\nstatic inline void dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t int rem_wakeup) {}\nstatic inline int dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline void dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_clear_fifo_map(struct dwc2_hsotg *hsotg) {}\n#endif\n\n#if IS_ENABLED(CONFIG_USB_DWC2_HOST) || IS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\nint dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg);\nint dwc2_hcd_get_future_frame_number(struct dwc2_hsotg *hsotg, int us);\nvoid dwc2_hcd_connect(struct dwc2_hsotg *hsotg);\nvoid dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg, bool force);\nvoid dwc2_hcd_start(struct dwc2_hsotg *hsotg);\nint dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup);\nint dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex);\nint dwc2_port_resume(struct dwc2_hsotg *hsotg);\nint dwc2_backup_host_registers(struct dwc2_hsotg *hsotg);\nint dwc2_restore_host_registers(struct dwc2_hsotg *hsotg);\nint dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg);\nint dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,\n\t\t\t       int rem_wakeup, int reset);\nint dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg);\nint dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t      int rem_wakeup, bool restore);\nvoid dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg);\nvoid dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup);\nbool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2);\nstatic inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg)\n{ schedule_work(&hsotg->phy_reset_work); }\n#else\nstatic inline int dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_hcd_get_future_frame_number(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t   int us)\n{ return 0; }\nstatic inline void dwc2_hcd_connect(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg, bool force) {}\nstatic inline void dwc2_hcd_start(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_hcd_remove(struct dwc2_hsotg *hsotg) {}\nstatic inline int dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup)\n{ return 0; }\nstatic inline int dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)\n{ return 0; }\nstatic inline int dwc2_port_resume(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_hcd_init(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_restore_host_registers(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t     int rem_wakeup, int reset)\n{ return 0; }\nstatic inline int dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)\n{ return 0; }\nstatic inline int dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t    int rem_wakeup, bool restore)\n{ return 0; }\nstatic inline void dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg) {}\nstatic inline void dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t       int rem_wakeup) {}\nstatic inline bool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2)\n{ return false; }\nstatic inline void dwc2_host_schedule_phy_reset(struct dwc2_hsotg *hsotg) {}\n\n#endif\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}