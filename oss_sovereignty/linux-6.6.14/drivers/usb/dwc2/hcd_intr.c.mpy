{
  "module_name": "hcd_intr.c",
  "hash_id": "71f69e814ede4382be5f0d885c8e94be8e814cb6a7e87c2e1e514ea7f5ff153c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/hcd_intr.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\n \n#define DWC2_NAKS_BEFORE_DELAY\t\t3\n\n \nstatic void dwc2_track_missed_sofs(struct dwc2_hsotg *hsotg)\n{\n\tu16 curr_frame_number = hsotg->frame_number;\n\tu16 expected = dwc2_frame_num_inc(hsotg->last_frame_num, 1);\n\n\tif (expected != curr_frame_number)\n\t\tdwc2_sch_vdbg(hsotg, \"MISSED SOF %04x != %04x\\n\",\n\t\t\t      expected, curr_frame_number);\n\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\n\tif (hsotg->frame_num_idx < FRAME_NUM_ARRAY_SIZE) {\n\t\tif (expected != curr_frame_number) {\n\t\t\thsotg->frame_num_array[hsotg->frame_num_idx] =\n\t\t\t\t\tcurr_frame_number;\n\t\t\thsotg->last_frame_num_array[hsotg->frame_num_idx] =\n\t\t\t\t\thsotg->last_frame_num;\n\t\t\thsotg->frame_num_idx++;\n\t\t}\n\t} else if (!hsotg->dumped_frame_num_array) {\n\t\tint i;\n\n\t\tdev_info(hsotg->dev, \"Frame     Last Frame\\n\");\n\t\tdev_info(hsotg->dev, \"-----     ----------\\n\");\n\t\tfor (i = 0; i < FRAME_NUM_ARRAY_SIZE; i++) {\n\t\t\tdev_info(hsotg->dev, \"0x%04x    0x%04x\\n\",\n\t\t\t\t hsotg->frame_num_array[i],\n\t\t\t\t hsotg->last_frame_num_array[i]);\n\t\t}\n\t\thsotg->dumped_frame_num_array = 1;\n\t}\n#endif\n\thsotg->last_frame_num = curr_frame_number;\n}\n\nstatic void dwc2_hc_handle_tt_clear(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_host_chan *chan,\n\t\t\t\t    struct dwc2_qtd *qtd)\n{\n\tstruct usb_device *root_hub = dwc2_hsotg_to_hcd(hsotg)->self.root_hub;\n\tstruct urb *usb_urb;\n\n\tif (!chan->qh)\n\t\treturn;\n\n\tif (chan->qh->dev_speed == USB_SPEED_HIGH)\n\t\treturn;\n\n\tif (!qtd->urb)\n\t\treturn;\n\n\tusb_urb = qtd->urb->priv;\n\tif (!usb_urb || !usb_urb->dev || !usb_urb->dev->tt)\n\t\treturn;\n\n\t \n\tif (usb_urb->dev->tt->hub == root_hub)\n\t\treturn;\n\n\tif (qtd->urb->status != -EPIPE && qtd->urb->status != -EREMOTEIO) {\n\t\tchan->qh->tt_buffer_dirty = 1;\n\t\tif (usb_hub_clear_tt_buffer(usb_urb))\n\t\t\t \n\t\t\tchan->qh->tt_buffer_dirty = 0;\n\t}\n}\n\n \nstatic void dwc2_sof_intr(struct dwc2_hsotg *hsotg)\n{\n\tstruct list_head *qh_entry;\n\tstruct dwc2_qh *qh;\n\tenum dwc2_transaction_type tr_type;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_SOF, GINTSTS);\n\n#ifdef DEBUG_SOF\n\tdev_vdbg(hsotg->dev, \"--Start of Frame Interrupt--\\n\");\n#endif\n\n\thsotg->frame_number = dwc2_hcd_get_frame_number(hsotg);\n\n\tdwc2_track_missed_sofs(hsotg);\n\n\t \n\tqh_entry = hsotg->periodic_sched_inactive.next;\n\twhile (qh_entry != &hsotg->periodic_sched_inactive) {\n\t\tqh = list_entry(qh_entry, struct dwc2_qh, qh_list_entry);\n\t\tqh_entry = qh_entry->next;\n\t\tif (dwc2_frame_num_le(qh->next_active_frame,\n\t\t\t\t      hsotg->frame_number)) {\n\t\t\tdwc2_sch_vdbg(hsotg, \"QH=%p ready fn=%04x, nxt=%04x\\n\",\n\t\t\t\t      qh, hsotg->frame_number,\n\t\t\t\t      qh->next_active_frame);\n\n\t\t\t \n\t\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t\t       &hsotg->periodic_sched_ready);\n\t\t}\n\t}\n\ttr_type = dwc2_hcd_select_transactions(hsotg);\n\tif (tr_type != DWC2_TRANSACTION_NONE)\n\t\tdwc2_hcd_queue_transactions(hsotg, tr_type);\n}\n\n \nstatic void dwc2_rx_fifo_level_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 grxsts, chnum, bcnt, dpid, pktsts;\n\tstruct dwc2_host_chan *chan;\n\n\tif (dbg_perio())\n\t\tdev_vdbg(hsotg->dev, \"--RxFIFO Level Interrupt--\\n\");\n\n\tgrxsts = dwc2_readl(hsotg, GRXSTSP);\n\tchnum = (grxsts & GRXSTS_HCHNUM_MASK) >> GRXSTS_HCHNUM_SHIFT;\n\tchan = hsotg->hc_ptr_array[chnum];\n\tif (!chan) {\n\t\tdev_err(hsotg->dev, \"Unable to get corresponding channel\\n\");\n\t\treturn;\n\t}\n\n\tbcnt = (grxsts & GRXSTS_BYTECNT_MASK) >> GRXSTS_BYTECNT_SHIFT;\n\tdpid = (grxsts & GRXSTS_DPID_MASK) >> GRXSTS_DPID_SHIFT;\n\tpktsts = (grxsts & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT;\n\n\t \n\tif (dbg_perio()) {\n\t\tdev_vdbg(hsotg->dev, \"    Ch num = %d\\n\", chnum);\n\t\tdev_vdbg(hsotg->dev, \"    Count = %d\\n\", bcnt);\n\t\tdev_vdbg(hsotg->dev, \"    DPID = %d, chan.dpid = %d\\n\", dpid,\n\t\t\t chan->data_pid_start);\n\t\tdev_vdbg(hsotg->dev, \"    PStatus = %d\\n\", pktsts);\n\t}\n\n\tswitch (pktsts) {\n\tcase GRXSTS_PKTSTS_HCHIN:\n\t\t \n\t\tif (bcnt > 0) {\n\t\t\tdwc2_read_packet(hsotg, chan->xfer_buf, bcnt);\n\n\t\t\t \n\t\t\tchan->xfer_count += bcnt;\n\t\t\tchan->xfer_buf += bcnt;\n\t\t}\n\t\tbreak;\n\tcase GRXSTS_PKTSTS_HCHIN_XFER_COMP:\n\tcase GRXSTS_PKTSTS_DATATOGGLEERR:\n\tcase GRXSTS_PKTSTS_HCHHALTED:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev,\n\t\t\t\"RxFIFO Level Interrupt: Unknown status %d\\n\", pktsts);\n\t\tbreak;\n\t}\n}\n\n \nstatic void dwc2_np_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg)\n{\n\tdev_vdbg(hsotg->dev, \"--Non-Periodic TxFIFO Empty Interrupt--\\n\");\n\tdwc2_hcd_queue_transactions(hsotg, DWC2_TRANSACTION_NON_PERIODIC);\n}\n\n \nstatic void dwc2_perio_tx_fifo_empty_intr(struct dwc2_hsotg *hsotg)\n{\n\tif (dbg_perio())\n\t\tdev_vdbg(hsotg->dev, \"--Periodic TxFIFO Empty Interrupt--\\n\");\n\tdwc2_hcd_queue_transactions(hsotg, DWC2_TRANSACTION_PERIODIC);\n}\n\nstatic void dwc2_hprt0_enable(struct dwc2_hsotg *hsotg, u32 hprt0,\n\t\t\t      u32 *hprt0_modify)\n{\n\tstruct dwc2_core_params *params = &hsotg->params;\n\tint do_reset = 0;\n\tu32 usbcfg;\n\tu32 prtspd;\n\tu32 hcfg;\n\tu32 fslspclksel;\n\tu32 hfir;\n\n\tdev_vdbg(hsotg->dev, \"%s(%p)\\n\", __func__, hsotg);\n\n\t \n\thfir = dwc2_readl(hsotg, HFIR);\n\thfir &= ~HFIR_FRINT_MASK;\n\thfir |= dwc2_calc_frame_interval(hsotg) << HFIR_FRINT_SHIFT &\n\t\tHFIR_FRINT_MASK;\n\tdwc2_writel(hsotg, hfir, HFIR);\n\n\t \n\tif (!params->host_support_fs_ls_low_power) {\n\t\t \n\t\thsotg->flags.b.port_reset_change = 1;\n\t\treturn;\n\t}\n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tprtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\n\n\tif (prtspd == HPRT0_SPD_LOW_SPEED || prtspd == HPRT0_SPD_FULL_SPEED) {\n\t\t \n\t\tif (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL)) {\n\t\t\t \n\t\t\tusbcfg |= GUSBCFG_PHY_LP_CLK_SEL;\n\t\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\t\t\tdo_reset = 1;\n\t\t}\n\n\t\thcfg = dwc2_readl(hsotg, HCFG);\n\t\tfslspclksel = (hcfg & HCFG_FSLSPCLKSEL_MASK) >>\n\t\t\t      HCFG_FSLSPCLKSEL_SHIFT;\n\n\t\tif (prtspd == HPRT0_SPD_LOW_SPEED &&\n\t\t    params->host_ls_low_power_phy_clk) {\n\t\t\t \n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"FS_PHY programming HCFG to 6 MHz\\n\");\n\t\t\tif (fslspclksel != HCFG_FSLSPCLKSEL_6_MHZ) {\n\t\t\t\tfslspclksel = HCFG_FSLSPCLKSEL_6_MHZ;\n\t\t\t\thcfg &= ~HCFG_FSLSPCLKSEL_MASK;\n\t\t\t\thcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;\n\t\t\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t\t\t\tdo_reset = 1;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"FS_PHY programming HCFG to 48 MHz\\n\");\n\t\t\tif (fslspclksel != HCFG_FSLSPCLKSEL_48_MHZ) {\n\t\t\t\tfslspclksel = HCFG_FSLSPCLKSEL_48_MHZ;\n\t\t\t\thcfg &= ~HCFG_FSLSPCLKSEL_MASK;\n\t\t\t\thcfg |= fslspclksel << HCFG_FSLSPCLKSEL_SHIFT;\n\t\t\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t\t\t\tdo_reset = 1;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (usbcfg & GUSBCFG_PHY_LP_CLK_SEL) {\n\t\t\tusbcfg &= ~GUSBCFG_PHY_LP_CLK_SEL;\n\t\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\t\t\tdo_reset = 1;\n\t\t}\n\t}\n\n\tif (do_reset) {\n\t\t*hprt0_modify |= HPRT0_RST;\n\t\tdwc2_writel(hsotg, *hprt0_modify, HPRT0);\n\t\tqueue_delayed_work(hsotg->wq_otg, &hsotg->reset_work,\n\t\t\t\t   msecs_to_jiffies(60));\n\t} else {\n\t\t \n\t\thsotg->flags.b.port_reset_change = 1;\n\t}\n}\n\n \nstatic void dwc2_port_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 hprt0;\n\tu32 hprt0_modify;\n\n\tdev_vdbg(hsotg->dev, \"--Port Interrupt--\\n\");\n\n\thprt0 = dwc2_readl(hsotg, HPRT0);\n\thprt0_modify = hprt0;\n\n\t \n\thprt0_modify &= ~(HPRT0_ENA | HPRT0_CONNDET | HPRT0_ENACHG |\n\t\t\t  HPRT0_OVRCURRCHG);\n\n\t \n\tif (hprt0 & HPRT0_CONNDET) {\n\t\tdwc2_writel(hsotg, hprt0_modify | HPRT0_CONNDET, HPRT0);\n\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"--Port Interrupt HPRT0=0x%08x Port Connect Detected--\\n\",\n\t\t\t hprt0);\n\t\tdwc2_hcd_connect(hsotg);\n\n\t\t \n\t}\n\n\t \n\tif (hprt0 & HPRT0_ENACHG) {\n\t\tdwc2_writel(hsotg, hprt0_modify | HPRT0_ENACHG, HPRT0);\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"  --Port Interrupt HPRT0=0x%08x Port Enable Changed (now %d)--\\n\",\n\t\t\t hprt0, !!(hprt0 & HPRT0_ENA));\n\t\tif (hprt0 & HPRT0_ENA) {\n\t\t\thsotg->new_connection = true;\n\t\t\tdwc2_hprt0_enable(hsotg, hprt0, &hprt0_modify);\n\t\t} else {\n\t\t\thsotg->flags.b.port_enable_change = 1;\n\t\t\tif (hsotg->params.dma_desc_fs_enable) {\n\t\t\t\tu32 hcfg;\n\n\t\t\t\thsotg->params.dma_desc_enable = false;\n\t\t\t\thsotg->new_connection = false;\n\t\t\t\thcfg = dwc2_readl(hsotg, HCFG);\n\t\t\t\thcfg &= ~HCFG_DESCDMA;\n\t\t\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (hprt0 & HPRT0_OVRCURRCHG) {\n\t\tdwc2_writel(hsotg, hprt0_modify | HPRT0_OVRCURRCHG,\n\t\t\t    HPRT0);\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"  --Port Interrupt HPRT0=0x%08x Port Overcurrent Changed--\\n\",\n\t\t\t hprt0);\n\t\thsotg->flags.b.port_over_current_change = 1;\n\t}\n}\n\n \nstatic u32 dwc2_get_actual_xfer_length(struct dwc2_hsotg *hsotg,\n\t\t\t\t       struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t       struct dwc2_qtd *qtd,\n\t\t\t\t       enum dwc2_halt_status halt_status,\n\t\t\t\t       int *short_read)\n{\n\tu32 hctsiz, count, length;\n\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\n\tif (halt_status == DWC2_HC_XFER_COMPLETE) {\n\t\tif (chan->ep_is_in) {\n\t\t\tcount = (hctsiz & TSIZ_XFERSIZE_MASK) >>\n\t\t\t\tTSIZ_XFERSIZE_SHIFT;\n\t\t\tlength = chan->xfer_len - count;\n\t\t\tif (short_read)\n\t\t\t\t*short_read = (count != 0);\n\t\t} else if (chan->qh->do_split) {\n\t\t\tlength = qtd->ssplit_out_xfer_count;\n\t\t} else {\n\t\t\tlength = chan->xfer_len;\n\t\t}\n\t} else {\n\t\t \n\t\tcount = (hctsiz & TSIZ_PKTCNT_MASK) >> TSIZ_PKTCNT_SHIFT;\n\t\tlength = (chan->start_pkt_count - count) * chan->max_packet;\n\t}\n\n\treturn length;\n}\n\n \nstatic int dwc2_update_urb_state(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t struct dwc2_hcd_urb *urb,\n\t\t\t\t struct dwc2_qtd *qtd)\n{\n\tu32 hctsiz;\n\tint xfer_done = 0;\n\tint short_read = 0;\n\tint xfer_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,\n\t\t\t\t\t\t      DWC2_HC_XFER_COMPLETE,\n\t\t\t\t\t\t      &short_read);\n\n\tif (urb->actual_length + xfer_length > urb->length) {\n\t\tdev_dbg(hsotg->dev, \"%s(): trimming xfer length\\n\", __func__);\n\t\txfer_length = urb->length - urb->actual_length;\n\t}\n\n\tdev_vdbg(hsotg->dev, \"urb->actual_length=%d xfer_length=%d\\n\",\n\t\t urb->actual_length, xfer_length);\n\turb->actual_length += xfer_length;\n\n\tif (xfer_length && chan->ep_type == USB_ENDPOINT_XFER_BULK &&\n\t    (urb->flags & URB_SEND_ZERO_PACKET) &&\n\t    urb->actual_length >= urb->length &&\n\t    !(urb->length % chan->max_packet)) {\n\t\txfer_done = 0;\n\t} else if (short_read || urb->actual_length >= urb->length) {\n\t\txfer_done = 1;\n\t\turb->status = 0;\n\t}\n\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\tdev_vdbg(hsotg->dev, \"DWC_otg: %s: %s, channel %d\\n\",\n\t\t __func__, (chan->ep_is_in ? \"IN\" : \"OUT\"), chnum);\n\tdev_vdbg(hsotg->dev, \"  chan->xfer_len %d\\n\", chan->xfer_len);\n\tdev_vdbg(hsotg->dev, \"  hctsiz.xfersize %d\\n\",\n\t\t (hctsiz & TSIZ_XFERSIZE_MASK) >> TSIZ_XFERSIZE_SHIFT);\n\tdev_vdbg(hsotg->dev, \"  urb->transfer_buffer_length %d\\n\", urb->length);\n\tdev_vdbg(hsotg->dev, \"  urb->actual_length %d\\n\", urb->actual_length);\n\tdev_vdbg(hsotg->dev, \"  short_read %d, xfer_done %d\\n\", short_read,\n\t\t xfer_done);\n\n\treturn xfer_done;\n}\n\n \nvoid dwc2_hcd_save_data_toggle(struct dwc2_hsotg *hsotg,\n\t\t\t       struct dwc2_host_chan *chan, int chnum,\n\t\t\t       struct dwc2_qtd *qtd)\n{\n\tu32 hctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\tu32 pid = (hctsiz & TSIZ_SC_MC_PID_MASK) >> TSIZ_SC_MC_PID_SHIFT;\n\n\tif (chan->ep_type != USB_ENDPOINT_XFER_CONTROL) {\n\t\tif (WARN(!chan || !chan->qh,\n\t\t\t \"chan->qh must be specified for non-control eps\\n\"))\n\t\t\treturn;\n\n\t\tif (pid == TSIZ_SC_MC_PID_DATA0)\n\t\t\tchan->qh->data_toggle = DWC2_HC_PID_DATA0;\n\t\telse\n\t\t\tchan->qh->data_toggle = DWC2_HC_PID_DATA1;\n\t} else {\n\t\tif (WARN(!qtd,\n\t\t\t \"qtd must be specified for control eps\\n\"))\n\t\t\treturn;\n\n\t\tif (pid == TSIZ_SC_MC_PID_DATA0)\n\t\t\tqtd->data_toggle = DWC2_HC_PID_DATA0;\n\t\telse\n\t\t\tqtd->data_toggle = DWC2_HC_PID_DATA1;\n\t}\n}\n\n \nstatic enum dwc2_halt_status dwc2_update_isoc_urb_state(\n\t\tstruct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan,\n\t\tint chnum, struct dwc2_qtd *qtd,\n\t\tenum dwc2_halt_status halt_status)\n{\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\n\tif (!urb)\n\t\treturn DWC2_HC_XFER_NO_HALT_STATUS;\n\n\tframe_desc = &urb->iso_descs[qtd->isoc_frame_index];\n\n\tswitch (halt_status) {\n\tcase DWC2_HC_XFER_COMPLETE:\n\t\tframe_desc->status = 0;\n\t\tframe_desc->actual_length = dwc2_get_actual_xfer_length(hsotg,\n\t\t\t\t\tchan, chnum, qtd, halt_status, NULL);\n\t\tbreak;\n\tcase DWC2_HC_XFER_FRAME_OVERRUN:\n\t\turb->error_count++;\n\t\tif (chan->ep_is_in)\n\t\t\tframe_desc->status = -ENOSR;\n\t\telse\n\t\t\tframe_desc->status = -ECOMM;\n\t\tframe_desc->actual_length = 0;\n\t\tbreak;\n\tcase DWC2_HC_XFER_BABBLE_ERR:\n\t\turb->error_count++;\n\t\tframe_desc->status = -EOVERFLOW;\n\t\t \n\t\tbreak;\n\tcase DWC2_HC_XFER_XACT_ERR:\n\t\turb->error_count++;\n\t\tframe_desc->status = -EPROTO;\n\t\tframe_desc->actual_length = dwc2_get_actual_xfer_length(hsotg,\n\t\t\t\t\tchan, chnum, qtd, halt_status, NULL);\n\n\t\t \n\t\tif (chan->qh->do_split &&\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC && chan->ep_is_in &&\n\t\t    hsotg->params.host_dma) {\n\t\t\tqtd->complete_split = 0;\n\t\t\tqtd->isoc_split_offset = 0;\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev, \"Unhandled halt_status (%d)\\n\",\n\t\t\thalt_status);\n\t\tbreak;\n\t}\n\n\tif (++qtd->isoc_frame_index == urb->packet_count) {\n\t\t \n\t\tdwc2_host_complete(hsotg, qtd, 0);\n\t\thalt_status = DWC2_HC_XFER_URB_COMPLETE;\n\t} else {\n\t\thalt_status = DWC2_HC_XFER_COMPLETE;\n\t}\n\n\treturn halt_status;\n}\n\n \nstatic void dwc2_deactivate_qh(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t       int free_qtd)\n{\n\tint continue_split = 0;\n\tstruct dwc2_qtd *qtd;\n\n\tif (dbg_qh(qh))\n\t\tdev_vdbg(hsotg->dev, \"  %s(%p,%p,%d)\\n\", __func__,\n\t\t\t hsotg, qh, free_qtd);\n\n\tif (list_empty(&qh->qtd_list)) {\n\t\tdev_dbg(hsotg->dev, \"## QTD list empty ##\\n\");\n\t\tgoto no_qtd;\n\t}\n\n\tqtd = list_first_entry(&qh->qtd_list, struct dwc2_qtd, qtd_list_entry);\n\n\tif (qtd->complete_split)\n\t\tcontinue_split = 1;\n\telse if (qtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_MID ||\n\t\t qtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_END)\n\t\tcontinue_split = 1;\n\n\tif (free_qtd) {\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\t\tcontinue_split = 0;\n\t}\n\nno_qtd:\n\tqh->channel = NULL;\n\tdwc2_hcd_qh_deactivate(hsotg, qh, continue_split);\n}\n\n \nstatic void dwc2_release_channel(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan,\n\t\t\t\t struct dwc2_qtd *qtd,\n\t\t\t\t enum dwc2_halt_status halt_status)\n{\n\tenum dwc2_transaction_type tr_type;\n\tu32 haintmsk;\n\tint free_qtd = 0;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"  %s: channel %d, halt_status %d\\n\",\n\t\t\t __func__, chan->hc_num, halt_status);\n\n\tswitch (halt_status) {\n\tcase DWC2_HC_XFER_URB_COMPLETE:\n\t\tfree_qtd = 1;\n\t\tbreak;\n\tcase DWC2_HC_XFER_AHB_ERR:\n\tcase DWC2_HC_XFER_STALL:\n\tcase DWC2_HC_XFER_BABBLE_ERR:\n\t\tfree_qtd = 1;\n\t\tbreak;\n\tcase DWC2_HC_XFER_XACT_ERR:\n\t\tif (qtd && qtd->error_count >= 3) {\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"  Complete URB with transaction error\\n\");\n\t\t\tfree_qtd = 1;\n\t\t\tdwc2_host_complete(hsotg, qtd, -EPROTO);\n\t\t}\n\t\tbreak;\n\tcase DWC2_HC_XFER_URB_DEQUEUE:\n\t\t \n\t\tgoto cleanup;\n\tcase DWC2_HC_XFER_PERIODIC_INCOMPLETE:\n\t\tdev_vdbg(hsotg->dev, \"  Complete URB with I/O error\\n\");\n\t\tfree_qtd = 1;\n\t\tdwc2_host_complete(hsotg, qtd, -EIO);\n\t\tbreak;\n\tcase DWC2_HC_XFER_NO_HALT_STATUS:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdwc2_deactivate_qh(hsotg, chan->qh, free_qtd);\n\ncleanup:\n\t \n\tif (!list_empty(&chan->hc_list_entry))\n\t\tlist_del(&chan->hc_list_entry);\n\tdwc2_hc_cleanup(hsotg, chan);\n\tlist_add_tail(&chan->hc_list_entry, &hsotg->free_hc_list);\n\n\tif (hsotg->params.uframe_sched) {\n\t\thsotg->available_host_channels++;\n\t} else {\n\t\tswitch (chan->ep_type) {\n\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\thsotg->non_periodic_channels--;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\thaintmsk = dwc2_readl(hsotg, HAINTMSK);\n\thaintmsk &= ~(1 << chan->hc_num);\n\tdwc2_writel(hsotg, haintmsk, HAINTMSK);\n\n\t \n\ttr_type = dwc2_hcd_select_transactions(hsotg);\n\tif (tr_type != DWC2_TRANSACTION_NONE)\n\t\tdwc2_hcd_queue_transactions(hsotg, tr_type);\n}\n\n \nstatic void dwc2_halt_channel(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_host_chan *chan, struct dwc2_qtd *qtd,\n\t\t\t      enum dwc2_halt_status halt_status)\n{\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tif (hsotg->params.host_dma) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"DMA enabled\\n\");\n\t\tdwc2_release_channel(hsotg, chan, qtd, halt_status);\n\t\treturn;\n\t}\n\n\t \n\tdwc2_hc_halt(hsotg, chan, halt_status);\n\n\tif (chan->halt_on_queue) {\n\t\tu32 gintmsk;\n\n\t\tdev_vdbg(hsotg->dev, \"Halt on queue\\n\");\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_BULK) {\n\t\t\tdev_vdbg(hsotg->dev, \"control/bulk\\n\");\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk |= GINTSTS_NPTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t} else {\n\t\t\tdev_vdbg(hsotg->dev, \"isoc/intr\\n\");\n\t\t\t \n\t\t\tlist_move_tail(&chan->qh->qh_list_entry,\n\t\t\t\t       &hsotg->periodic_sched_assigned);\n\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk |= GINTSTS_PTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t}\n\t}\n}\n\n \nstatic void dwc2_complete_non_periodic_xfer(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t    struct dwc2_host_chan *chan,\n\t\t\t\t\t    int chnum, struct dwc2_qtd *qtd,\n\t\t\t\t\t    enum dwc2_halt_status halt_status)\n{\n\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tqtd->error_count = 0;\n\n\tif (chan->hcint & HCINTMSK_NYET) {\n\t\t \n\t\tdev_vdbg(hsotg->dev, \"got NYET\\n\");\n\t\tchan->qh->ping_state = 1;\n\t}\n\n\t \n\tif (chan->ep_is_in) {\n\t\t \n\t\tdwc2_halt_channel(hsotg, chan, qtd, halt_status);\n\t} else {\n\t\t \n\t\tdwc2_release_channel(hsotg, chan, qtd, halt_status);\n\t}\n}\n\n \nstatic void dwc2_complete_periodic_xfer(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_host_chan *chan, int chnum,\n\t\t\t\t\tstruct dwc2_qtd *qtd,\n\t\t\t\t\tenum dwc2_halt_status halt_status)\n{\n\tu32 hctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\n\tqtd->error_count = 0;\n\n\tif (!chan->ep_is_in || (hctsiz & TSIZ_PKTCNT_MASK) == 0)\n\t\t \n\t\tdwc2_release_channel(hsotg, chan, qtd, halt_status);\n\telse\n\t\t \n\t\tdwc2_halt_channel(hsotg, chan, qtd, halt_status);\n}\n\nstatic int dwc2_xfercomp_isoc_split_in(struct dwc2_hsotg *hsotg,\n\t\t\t\t       struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t       struct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\tu32 len;\n\tu32 hctsiz;\n\tu32 pid;\n\n\tif (!qtd->urb)\n\t\treturn 0;\n\n\tframe_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index];\n\tlen = dwc2_get_actual_xfer_length(hsotg, chan, chnum, qtd,\n\t\t\t\t\t  DWC2_HC_XFER_COMPLETE, NULL);\n\tif (!len && !qtd->isoc_split_offset) {\n\t\tqtd->complete_split = 0;\n\t\treturn 0;\n\t}\n\n\tframe_desc->actual_length += len;\n\n\tif (chan->align_buf) {\n\t\tdev_vdbg(hsotg->dev, \"non-aligned buffer\\n\");\n\t\tdma_unmap_single(hsotg->dev, chan->qh->dw_align_buf_dma,\n\t\t\t\t DWC2_KMEM_UNALIGNED_BUF_SIZE, DMA_FROM_DEVICE);\n\t\tmemcpy(qtd->urb->buf + (chan->xfer_dma - qtd->urb->dma),\n\t\t       chan->qh->dw_align_buf, len);\n\t}\n\n\tqtd->isoc_split_offset += len;\n\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\tpid = (hctsiz & TSIZ_SC_MC_PID_MASK) >> TSIZ_SC_MC_PID_SHIFT;\n\n\tif (frame_desc->actual_length >= frame_desc->length || pid == 0) {\n\t\tframe_desc->status = 0;\n\t\tqtd->isoc_frame_index++;\n\t\tqtd->complete_split = 0;\n\t\tqtd->isoc_split_offset = 0;\n\t}\n\n\tif (qtd->isoc_frame_index == qtd->urb->packet_count) {\n\t\tdwc2_host_complete(hsotg, qtd, 0);\n\t\tdwc2_release_channel(hsotg, chan, qtd,\n\t\t\t\t     DWC2_HC_XFER_URB_COMPLETE);\n\t} else {\n\t\tdwc2_release_channel(hsotg, chan, qtd,\n\t\t\t\t     DWC2_HC_XFER_NO_HALT_STATUS);\n\t}\n\n\treturn 1;\t \n}\n\n \nstatic void dwc2_hc_xfercomp_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\t  struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t  struct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tenum dwc2_halt_status halt_status = DWC2_HC_XFER_COMPLETE;\n\tint pipe_type;\n\tint urb_xfer_done;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"--Host Channel %d Interrupt: Transfer Complete--\\n\",\n\t\t\t chnum);\n\n\tif (!urb)\n\t\tgoto handle_xfercomp_done;\n\n\tpipe_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum, halt_status);\n\t\tif (pipe_type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t \n\t\t\treturn;\n\t\tgoto handle_xfercomp_done;\n\t}\n\n\t \n\tif (chan->qh->do_split) {\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC && chan->ep_is_in &&\n\t\t    hsotg->params.host_dma) {\n\t\t\tif (qtd->complete_split &&\n\t\t\t    dwc2_xfercomp_isoc_split_in(hsotg, chan, chnum,\n\t\t\t\t\t\t\tqtd))\n\t\t\t\tgoto handle_xfercomp_done;\n\t\t} else {\n\t\t\tqtd->complete_split = 0;\n\t\t}\n\t}\n\n\t \n\tswitch (pipe_type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tswitch (qtd->control_phase) {\n\t\tcase DWC2_CONTROL_SETUP:\n\t\t\tif (urb->length > 0)\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_DATA;\n\t\t\telse\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_STATUS;\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"  Control setup transaction done\\n\");\n\t\t\thalt_status = DWC2_HC_XFER_COMPLETE;\n\t\t\tbreak;\n\t\tcase DWC2_CONTROL_DATA:\n\t\t\turb_xfer_done = dwc2_update_urb_state(hsotg, chan,\n\t\t\t\t\t\t\t      chnum, urb, qtd);\n\t\t\tif (urb_xfer_done) {\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_STATUS;\n\t\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t\t \"  Control data transfer done\\n\");\n\t\t\t} else {\n\t\t\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum,\n\t\t\t\t\t\t\t  qtd);\n\t\t\t}\n\t\t\thalt_status = DWC2_HC_XFER_COMPLETE;\n\t\t\tbreak;\n\t\tcase DWC2_CONTROL_STATUS:\n\t\t\tdev_vdbg(hsotg->dev, \"  Control transfer complete\\n\");\n\t\t\tif (urb->status == -EINPROGRESS)\n\t\t\t\turb->status = 0;\n\t\t\tdwc2_host_complete(hsotg, qtd, urb->status);\n\t\t\thalt_status = DWC2_HC_XFER_URB_COMPLETE;\n\t\t\tbreak;\n\t\t}\n\n\t\tdwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd,\n\t\t\t\t\t\thalt_status);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tdev_vdbg(hsotg->dev, \"  Bulk transfer complete\\n\");\n\t\turb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb,\n\t\t\t\t\t\t      qtd);\n\t\tif (urb_xfer_done) {\n\t\t\tdwc2_host_complete(hsotg, qtd, urb->status);\n\t\t\thalt_status = DWC2_HC_XFER_URB_COMPLETE;\n\t\t} else {\n\t\t\thalt_status = DWC2_HC_XFER_COMPLETE;\n\t\t}\n\n\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\t\tdwc2_complete_non_periodic_xfer(hsotg, chan, chnum, qtd,\n\t\t\t\t\t\thalt_status);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tdev_vdbg(hsotg->dev, \"  Interrupt transfer complete\\n\");\n\t\turb_xfer_done = dwc2_update_urb_state(hsotg, chan, chnum, urb,\n\t\t\t\t\t\t      qtd);\n\n\t\t \n\t\tif (urb_xfer_done) {\n\t\t\tdwc2_host_complete(hsotg, qtd, urb->status);\n\t\t\thalt_status = DWC2_HC_XFER_URB_COMPLETE;\n\t\t} else {\n\t\t\thalt_status = DWC2_HC_XFER_COMPLETE;\n\t\t}\n\n\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\t\tdwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd,\n\t\t\t\t\t    halt_status);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (dbg_perio())\n\t\t\tdev_vdbg(hsotg->dev, \"  Isochronous transfer complete\\n\");\n\t\tif (qtd->isoc_split_pos == DWC2_HCSPLT_XACTPOS_ALL)\n\t\t\thalt_status = dwc2_update_isoc_urb_state(hsotg, chan,\n\t\t\t\t\t\t\tchnum, qtd,\n\t\t\t\t\t\t\tDWC2_HC_XFER_COMPLETE);\n\t\tdwc2_complete_periodic_xfer(hsotg, chan, chnum, qtd,\n\t\t\t\t\t    halt_status);\n\t\tbreak;\n\t}\n\nhandle_xfercomp_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_XFERCOMPL);\n}\n\n \nstatic void dwc2_hc_stall_intr(struct dwc2_hsotg *hsotg,\n\t\t\t       struct dwc2_host_chan *chan, int chnum,\n\t\t\t       struct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tint pipe_type;\n\n\tdev_dbg(hsotg->dev, \"--Host Channel %d Interrupt: STALL Received--\\n\",\n\t\tchnum);\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t    DWC2_HC_XFER_STALL);\n\t\tgoto handle_stall_done;\n\t}\n\n\tif (!urb)\n\t\tgoto handle_stall_halt;\n\n\tpipe_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\n\n\tif (pipe_type == USB_ENDPOINT_XFER_CONTROL)\n\t\tdwc2_host_complete(hsotg, qtd, -EPIPE);\n\n\tif (pipe_type == USB_ENDPOINT_XFER_BULK ||\n\t    pipe_type == USB_ENDPOINT_XFER_INT) {\n\t\tdwc2_host_complete(hsotg, qtd, -EPIPE);\n\t\t \n\t\tchan->qh->data_toggle = 0;\n\t}\n\nhandle_stall_halt:\n\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_STALL);\n\nhandle_stall_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_STALL);\n}\n\n \nstatic void dwc2_update_urb_state_abn(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t      struct dwc2_hcd_urb *urb,\n\t\t\t\t      struct dwc2_qtd *qtd,\n\t\t\t\t      enum dwc2_halt_status halt_status)\n{\n\tu32 xfer_length = dwc2_get_actual_xfer_length(hsotg, chan, chnum,\n\t\t\t\t\t\t      qtd, halt_status, NULL);\n\tu32 hctsiz;\n\n\tif (urb->actual_length + xfer_length > urb->length) {\n\t\tdev_warn(hsotg->dev, \"%s(): trimming xfer length\\n\", __func__);\n\t\txfer_length = urb->length - urb->actual_length;\n\t}\n\n\turb->actual_length += xfer_length;\n\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\tdev_vdbg(hsotg->dev, \"DWC_otg: %s: %s, channel %d\\n\",\n\t\t __func__, (chan->ep_is_in ? \"IN\" : \"OUT\"), chnum);\n\tdev_vdbg(hsotg->dev, \"  chan->start_pkt_count %d\\n\",\n\t\t chan->start_pkt_count);\n\tdev_vdbg(hsotg->dev, \"  hctsiz.pktcnt %d\\n\",\n\t\t (hctsiz & TSIZ_PKTCNT_MASK) >> TSIZ_PKTCNT_SHIFT);\n\tdev_vdbg(hsotg->dev, \"  chan->max_packet %d\\n\", chan->max_packet);\n\tdev_vdbg(hsotg->dev, \"  bytes_transferred %d\\n\",\n\t\t xfer_length);\n\tdev_vdbg(hsotg->dev, \"  urb->actual_length %d\\n\",\n\t\t urb->actual_length);\n\tdev_vdbg(hsotg->dev, \"  urb->transfer_buffer_length %d\\n\",\n\t\t urb->length);\n}\n\n \nstatic void dwc2_hc_nak_intr(struct dwc2_hsotg *hsotg,\n\t\t\t     struct dwc2_host_chan *chan, int chnum,\n\t\t\t     struct dwc2_qtd *qtd)\n{\n\tif (!qtd) {\n\t\tdev_dbg(hsotg->dev, \"%s: qtd is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!qtd->urb) {\n\t\tdev_dbg(hsotg->dev, \"%s: qtd->urb is NULL\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"--Host Channel %d Interrupt: NAK Received--\\n\",\n\t\t\t chnum);\n\n\t \n\tif (chan->do_split) {\n\t\tif (chan->complete_split)\n\t\t\tqtd->error_count = 0;\n\t\tqtd->complete_split = 0;\n\t\tqtd->num_naks++;\n\t\tqtd->qh->want_wait = qtd->num_naks >= DWC2_NAKS_BEFORE_DELAY &&\n\t\t\t\t!(chan->ep_type == USB_ENDPOINT_XFER_CONTROL &&\n\t\t\t\t  chan->ep_is_in);\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\n\t\tgoto handle_nak_done;\n\t}\n\n\tswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (hsotg->params.host_dma && chan->ep_is_in) {\n\t\t\t \n\t\t\tqtd->error_count = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tqtd->error_count = 0;\n\n\t\tif (!chan->qh->ping_state) {\n\t\t\tdwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\n\t\t\t\t\t\t  qtd, DWC2_HC_XFER_NAK);\n\t\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\n\t\t\tif (chan->speed == USB_SPEED_HIGH)\n\t\t\t\tchan->qh->ping_state = 1;\n\t\t}\n\n\t\t \n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tqtd->error_count = 0;\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NAK);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t \n\t\tdev_err(hsotg->dev, \"NACK interrupt for ISOC transfer\\n\");\n\t\tbreak;\n\t}\n\nhandle_nak_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_NAK);\n}\n\n \nstatic void dwc2_hc_ack_intr(struct dwc2_hsotg *hsotg,\n\t\t\t     struct dwc2_host_chan *chan, int chnum,\n\t\t\t     struct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"--Host Channel %d Interrupt: ACK Received--\\n\",\n\t\t\t chnum);\n\n\tif (chan->do_split) {\n\t\t \n\t\tif (!chan->ep_is_in &&\n\t\t    chan->data_pid_start != DWC2_HC_PID_SETUP)\n\t\t\tqtd->ssplit_out_xfer_count = chan->xfer_len;\n\n\t\tif (chan->ep_type != USB_ENDPOINT_XFER_ISOC || chan->ep_is_in) {\n\t\t\tqtd->complete_split = 1;\n\t\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_ACK);\n\t\t} else {\n\t\t\t \n\t\t\tswitch (chan->xact_pos) {\n\t\t\tcase DWC2_HCSPLT_XACTPOS_ALL:\n\t\t\t\tbreak;\n\t\t\tcase DWC2_HCSPLT_XACTPOS_END:\n\t\t\t\tqtd->isoc_split_pos = DWC2_HCSPLT_XACTPOS_ALL;\n\t\t\t\tqtd->isoc_split_offset = 0;\n\t\t\t\tbreak;\n\t\t\tcase DWC2_HCSPLT_XACTPOS_BEGIN:\n\t\t\tcase DWC2_HCSPLT_XACTPOS_MID:\n\t\t\t\t \n\t\t\t\tframe_desc = &qtd->urb->iso_descs[\n\t\t\t\t\t\tqtd->isoc_frame_index];\n\t\t\t\tqtd->isoc_split_offset += 188;\n\n\t\t\t\tif (frame_desc->length - qtd->isoc_split_offset\n\t\t\t\t\t\t\t<= 188)\n\t\t\t\t\tqtd->isoc_split_pos =\n\t\t\t\t\t\t\tDWC2_HCSPLT_XACTPOS_END;\n\t\t\t\telse\n\t\t\t\t\tqtd->isoc_split_pos =\n\t\t\t\t\t\t\tDWC2_HCSPLT_XACTPOS_MID;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tqtd->error_count = 0;\n\n\t\tif (chan->qh->ping_state) {\n\t\t\tchan->qh->ping_state = 0;\n\t\t\t \n\t\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_ACK);\n\t\t}\n\t}\n\n\t \n\tdisable_hc_int(hsotg, chnum, HCINTMSK_ACK);\n}\n\n \nstatic void dwc2_hc_nyet_intr(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_host_chan *chan, int chnum,\n\t\t\t      struct dwc2_qtd *qtd)\n{\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"--Host Channel %d Interrupt: NYET Received--\\n\",\n\t\t\t chnum);\n\n\t \n\tif (chan->do_split && chan->complete_split) {\n\t\tif (chan->ep_is_in && chan->ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t\t    hsotg->params.host_dma) {\n\t\t\tqtd->complete_split = 0;\n\t\t\tqtd->isoc_split_offset = 0;\n\t\t\tqtd->isoc_frame_index++;\n\t\t\tif (qtd->urb &&\n\t\t\t    qtd->isoc_frame_index == qtd->urb->packet_count) {\n\t\t\t\tdwc2_host_complete(hsotg, qtd, 0);\n\t\t\t\tdwc2_release_channel(hsotg, chan, qtd,\n\t\t\t\t\t\t     DWC2_HC_XFER_URB_COMPLETE);\n\t\t\t} else {\n\t\t\t\tdwc2_release_channel(hsotg, chan, qtd,\n\t\t\t\t\t\tDWC2_HC_XFER_NO_HALT_STATUS);\n\t\t\t}\n\t\t\tgoto handle_nyet_done;\n\t\t}\n\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tstruct dwc2_qh *qh = chan->qh;\n\t\t\tbool past_end;\n\n\t\t\tif (!hsotg->params.uframe_sched) {\n\t\t\t\tint frnum = dwc2_hcd_get_frame_number(hsotg);\n\n\t\t\t\t \n\t\t\t\tpast_end = dwc2_full_frame_num(frnum) !=\n\t\t\t\t     dwc2_full_frame_num(qh->next_active_frame);\n\t\t\t} else {\n\t\t\t\tint end_frnum;\n\n\t\t\t\t \n\t\t\t\tend_frnum = dwc2_frame_num_inc(\n\t\t\t\t\tqh->start_active_frame,\n\t\t\t\t\tqh->num_hs_transfers);\n\n\t\t\t\tif (qh->ep_type != USB_ENDPOINT_XFER_ISOC ||\n\t\t\t\t    qh->ep_is_in)\n\t\t\t\t\tend_frnum =\n\t\t\t\t\t       dwc2_frame_num_inc(end_frnum, 1);\n\n\t\t\t\tpast_end = dwc2_frame_num_le(\n\t\t\t\t\tend_frnum, qh->next_active_frame);\n\t\t\t}\n\n\t\t\tif (past_end) {\n\t\t\t\t \n#if 0\n\t\t\t\t \n\t\t\t\tqtd->error_count++;\n#endif\n\t\t\t\tqtd->complete_split = 0;\n\t\t\t\tdwc2_halt_channel(hsotg, chan, qtd,\n\t\t\t\t\t\t  DWC2_HC_XFER_XACT_ERR);\n\t\t\t\t \n\t\t\t\tgoto handle_nyet_done;\n\t\t\t}\n\t\t}\n\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NYET);\n\t\tgoto handle_nyet_done;\n\t}\n\n\tchan->qh->ping_state = 1;\n\tqtd->error_count = 0;\n\n\tdwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb, qtd,\n\t\t\t\t  DWC2_HC_XFER_NYET);\n\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\n\t \n\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_NYET);\n\nhandle_nyet_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_NYET);\n}\n\n \nstatic void dwc2_hc_babble_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_host_chan *chan, int chnum,\n\t\t\t\tstruct dwc2_qtd *qtd)\n{\n\tdev_dbg(hsotg->dev, \"--Host Channel %d Interrupt: Babble Error--\\n\",\n\t\tchnum);\n\n\tdwc2_hc_handle_tt_clear(hsotg, chan, qtd);\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t    DWC2_HC_XFER_BABBLE_ERR);\n\t\tgoto disable_int;\n\t}\n\n\tif (chan->ep_type != USB_ENDPOINT_XFER_ISOC) {\n\t\tdwc2_host_complete(hsotg, qtd, -EOVERFLOW);\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_BABBLE_ERR);\n\t} else {\n\t\tenum dwc2_halt_status halt_status;\n\n\t\thalt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum,\n\t\t\t\t\t\tqtd, DWC2_HC_XFER_BABBLE_ERR);\n\t\tdwc2_halt_channel(hsotg, chan, qtd, halt_status);\n\t}\n\ndisable_int:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_BBLERR);\n}\n\n \nstatic void dwc2_hc_ahberr_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_host_chan *chan, int chnum,\n\t\t\t\tstruct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tchar *pipetype, *speed;\n\tu32 hcchar;\n\tu32 hcsplt;\n\tu32 hctsiz;\n\tu32 hc_dma;\n\n\tdev_dbg(hsotg->dev, \"--Host Channel %d Interrupt: AHB Error--\\n\",\n\t\tchnum);\n\n\tif (!urb)\n\t\tgoto handle_ahberr_halt;\n\n\tdwc2_hc_handle_tt_clear(hsotg, chan, qtd);\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chnum));\n\thcsplt = dwc2_readl(hsotg, HCSPLT(chnum));\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\thc_dma = dwc2_readl(hsotg, HCDMA(chnum));\n\n\tdev_err(hsotg->dev, \"AHB ERROR, Channel %d\\n\", chnum);\n\tdev_err(hsotg->dev, \"  hcchar 0x%08x, hcsplt 0x%08x\\n\", hcchar, hcsplt);\n\tdev_err(hsotg->dev, \"  hctsiz 0x%08x, hc_dma 0x%08x\\n\", hctsiz, hc_dma);\n\tdev_err(hsotg->dev, \"  Device address: %d\\n\",\n\t\tdwc2_hcd_get_dev_addr(&urb->pipe_info));\n\tdev_err(hsotg->dev, \"  Endpoint: %d, %s\\n\",\n\t\tdwc2_hcd_get_ep_num(&urb->pipe_info),\n\t\tdwc2_hcd_is_pipe_in(&urb->pipe_info) ? \"IN\" : \"OUT\");\n\n\tswitch (dwc2_hcd_get_pipe_type(&urb->pipe_info)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tpipetype = \"CONTROL\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tpipetype = \"BULK\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tpipetype = \"INTERRUPT\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tpipetype = \"ISOCHRONOUS\";\n\t\tbreak;\n\tdefault:\n\t\tpipetype = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\n\tdev_err(hsotg->dev, \"  Endpoint type: %s\\n\", pipetype);\n\n\tswitch (chan->speed) {\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"HIGH\";\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"FULL\";\n\t\tbreak;\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"LOW\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\n\tdev_err(hsotg->dev, \"  Speed: %s\\n\", speed);\n\n\tdev_err(hsotg->dev, \"  Max packet size: %d (mult %d)\\n\",\n\t\tdwc2_hcd_get_maxp(&urb->pipe_info),\n\t\tdwc2_hcd_get_maxp_mult(&urb->pipe_info));\n\tdev_err(hsotg->dev, \"  Data buffer length: %d\\n\", urb->length);\n\tdev_err(hsotg->dev, \"  Transfer buffer: %p, Transfer DMA: %08lx\\n\",\n\t\turb->buf, (unsigned long)urb->dma);\n\tdev_err(hsotg->dev, \"  Setup buffer: %p, Setup DMA: %08lx\\n\",\n\t\turb->setup_packet, (unsigned long)urb->setup_dma);\n\tdev_err(hsotg->dev, \"  Interval: %d\\n\", urb->interval);\n\n\t \n\tif (hsotg->params.dma_desc_enable) {\n\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t    DWC2_HC_XFER_AHB_ERR);\n\t\tgoto handle_ahberr_done;\n\t}\n\n\tdwc2_host_complete(hsotg, qtd, -EIO);\n\nhandle_ahberr_halt:\n\t \n\tdwc2_hc_halt(hsotg, chan, DWC2_HC_XFER_AHB_ERR);\n\nhandle_ahberr_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_AHBERR);\n}\n\n \nstatic void dwc2_hc_xacterr_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t struct dwc2_qtd *qtd)\n{\n\tdev_dbg(hsotg->dev,\n\t\t\"--Host Channel %d Interrupt: Transaction Error--\\n\", chnum);\n\n\tdwc2_hc_handle_tt_clear(hsotg, chan, qtd);\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t    DWC2_HC_XFER_XACT_ERR);\n\t\tgoto handle_xacterr_done;\n\t}\n\n\tswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tqtd->error_count++;\n\t\tif (!chan->qh->ping_state) {\n\t\t\tdwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\n\t\t\t\t\t\t  qtd, DWC2_HC_XFER_XACT_ERR);\n\t\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\t\t\tif (!chan->ep_is_in && chan->speed == USB_SPEED_HIGH)\n\t\t\t\tchan->qh->ping_state = 1;\n\t\t}\n\n\t\t \n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tqtd->error_count++;\n\t\tif (chan->do_split && chan->complete_split)\n\t\t\tqtd->complete_split = 0;\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t{\n\t\t\tenum dwc2_halt_status halt_status;\n\n\t\t\thalt_status = dwc2_update_isoc_urb_state(hsotg, chan,\n\t\t\t\t\t chnum, qtd, DWC2_HC_XFER_XACT_ERR);\n\t\t\tdwc2_halt_channel(hsotg, chan, qtd, halt_status);\n\t\t}\n\t\tbreak;\n\t}\n\nhandle_xacterr_done:\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_XACTERR);\n}\n\n \nstatic void dwc2_hc_frmovrun_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\t  struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t  struct dwc2_qtd *qtd)\n{\n\tenum dwc2_halt_status halt_status;\n\n\tif (dbg_hc(chan))\n\t\tdev_dbg(hsotg->dev, \"--Host Channel %d Interrupt: Frame Overrun--\\n\",\n\t\t\tchnum);\n\n\tdwc2_hc_handle_tt_clear(hsotg, chan, qtd);\n\n\tswitch (dwc2_hcd_get_pipe_type(&qtd->urb->pipe_info)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_FRAME_OVERRUN);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\thalt_status = dwc2_update_isoc_urb_state(hsotg, chan, chnum,\n\t\t\t\t\tqtd, DWC2_HC_XFER_FRAME_OVERRUN);\n\t\tdwc2_halt_channel(hsotg, chan, qtd, halt_status);\n\t\tbreak;\n\t}\n\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_FRMOVRUN);\n}\n\n \nstatic void dwc2_hc_datatglerr_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t    struct dwc2_qtd *qtd)\n{\n\tdev_dbg(hsotg->dev,\n\t\t\"--Host Channel %d Interrupt: Data Toggle Error--\\n\", chnum);\n\n\tif (chan->ep_is_in)\n\t\tqtd->error_count = 0;\n\telse\n\t\tdev_err(hsotg->dev,\n\t\t\t\"Data Toggle Error on OUT transfer, channel %d\\n\",\n\t\t\tchnum);\n\n\tdwc2_hc_handle_tt_clear(hsotg, chan, qtd);\n\tdisable_hc_int(hsotg, chnum, HCINTMSK_DATATGLERR);\n}\n\n \nstatic bool dwc2_halt_status_ok(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_host_chan *chan, int chnum,\n\t\t\t\tstruct dwc2_qtd *qtd)\n{\n#ifdef DEBUG\n\tu32 hcchar;\n\tu32 hctsiz;\n\tu32 hcintmsk;\n\tu32 hcsplt;\n\n\tif (chan->halt_status == DWC2_HC_XFER_NO_HALT_STATUS) {\n\t\t \n\t\thcchar = dwc2_readl(hsotg, HCCHAR(chnum));\n\t\thctsiz = dwc2_readl(hsotg, HCTSIZ(chnum));\n\t\thcintmsk = dwc2_readl(hsotg, HCINTMSK(chnum));\n\t\thcsplt = dwc2_readl(hsotg, HCSPLT(chnum));\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: chan->halt_status DWC2_HC_XFER_NO_HALT_STATUS,\\n\",\n\t\t\t __func__);\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"channel %d, hcchar 0x%08x, hctsiz 0x%08x,\\n\",\n\t\t\tchnum, hcchar, hctsiz);\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"hcint 0x%08x, hcintmsk 0x%08x, hcsplt 0x%08x,\\n\",\n\t\t\tchan->hcint, hcintmsk, hcsplt);\n\t\tif (qtd)\n\t\t\tdev_dbg(hsotg->dev, \"qtd->complete_split %d\\n\",\n\t\t\t\tqtd->complete_split);\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"%s: no halt status, channel %d, ignoring interrupt\\n\",\n\t\t\t __func__, chnum);\n\t\treturn false;\n\t}\n\n\t \n\thcchar = dwc2_readl(hsotg, HCCHAR(chnum));\n\tif (hcchar & HCCHAR_CHDIS) {\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"%s: hcchar.chdis set unexpectedly, hcchar 0x%08x, trying to halt again\\n\",\n\t\t\t __func__, hcchar);\n\t\tchan->halt_pending = 0;\n\t\tdwc2_halt_channel(hsotg, chan, qtd, chan->halt_status);\n\t\treturn false;\n\t}\n#endif\n\n\treturn true;\n}\n\n \nstatic void dwc2_hc_chhltd_intr_dma(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t    struct dwc2_qtd *qtd)\n{\n\tu32 hcintmsk;\n\tint out_nak_enh = 0;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"--Host Channel %d Interrupt: DMA Channel Halted--\\n\",\n\t\t\t chnum);\n\n\t \n\tif (hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_71a) {\n\t\tif (chan->speed == USB_SPEED_HIGH && !chan->ep_is_in &&\n\t\t    (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||\n\t\t     chan->ep_type == USB_ENDPOINT_XFER_BULK)) {\n\t\t\tout_nak_enh = 1;\n\t\t}\n\t}\n\n\tif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE ||\n\t    (chan->halt_status == DWC2_HC_XFER_AHB_ERR &&\n\t     !hsotg->params.dma_desc_enable)) {\n\t\tif (hsotg->params.dma_desc_enable)\n\t\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t\t    chan->halt_status);\n\t\telse\n\t\t\t \n\t\t\tdwc2_release_channel(hsotg, chan, qtd,\n\t\t\t\t\t     chan->halt_status);\n\t\treturn;\n\t}\n\n\thcintmsk = dwc2_readl(hsotg, HCINTMSK(chnum));\n\n\tif (chan->hcint & HCINTMSK_XFERCOMPL) {\n\t\t \n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC && !chan->ep_is_in)\n\t\t\tdwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\n\t\tdwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);\n\t} else if (chan->hcint & HCINTMSK_STALL) {\n\t\tdwc2_hc_stall_intr(hsotg, chan, chnum, qtd);\n\t} else if ((chan->hcint & HCINTMSK_XACTERR) &&\n\t\t   !hsotg->params.dma_desc_enable) {\n\t\tif (out_nak_enh) {\n\t\t\tif (chan->hcint &\n\t\t\t    (HCINTMSK_NYET | HCINTMSK_NAK | HCINTMSK_ACK)) {\n\t\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t\t \"XactErr with NYET/NAK/ACK\\n\");\n\t\t\t\tqtd->error_count = 0;\n\t\t\t} else {\n\t\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t\t \"XactErr without NYET/NAK/ACK\\n\");\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tdwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\n\t} else if ((chan->hcint & HCINTMSK_XCS_XACT) &&\n\t\t   hsotg->params.dma_desc_enable) {\n\t\tdwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\n\t} else if ((chan->hcint & HCINTMSK_AHBERR) &&\n\t\t   hsotg->params.dma_desc_enable) {\n\t\tdwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);\n\t} else if (chan->hcint & HCINTMSK_BBLERR) {\n\t\tdwc2_hc_babble_intr(hsotg, chan, chnum, qtd);\n\t} else if (chan->hcint & HCINTMSK_FRMOVRUN) {\n\t\tdwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);\n\t} else if (!out_nak_enh) {\n\t\tif (chan->hcint & HCINTMSK_NYET) {\n\t\t\t \n\t\t\tdwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);\n\t\t} else if ((chan->hcint & HCINTMSK_NAK) &&\n\t\t\t   !(hcintmsk & HCINTMSK_NAK)) {\n\t\t\t \n\t\t\tdwc2_hc_nak_intr(hsotg, chan, chnum, qtd);\n\t\t} else if ((chan->hcint & HCINTMSK_ACK) &&\n\t\t\t   !(hcintmsk & HCINTMSK_ACK)) {\n\t\t\t \n\t\t\tdwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\n\t\t} else {\n\t\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\t\t \n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"%s: Halt channel %d (assume incomplete periodic transfer)\\n\",\n\t\t\t\t\t__func__, chnum);\n\t\t\t\tdwc2_halt_channel(hsotg, chan, qtd,\n\t\t\t\t\tDWC2_HC_XFER_PERIODIC_INCOMPLETE);\n\t\t\t} else {\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"%s: Channel %d - ChHltd set, but reason is unknown\\n\",\n\t\t\t\t\t__func__, chnum);\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"hcint 0x%08x, intsts 0x%08x\\n\",\n\t\t\t\t\tchan->hcint,\n\t\t\t\t\tdwc2_readl(hsotg, GINTSTS));\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_info(hsotg->dev,\n\t\t\t \"NYET/NAK/ACK/other in non-error case, 0x%08x\\n\",\n\t\t\t chan->hcint);\nerror:\n\t\t \n\t\tqtd->error_count++;\n\t\tdwc2_update_urb_state_abn(hsotg, chan, chnum, qtd->urb,\n\t\t\t\t\t  qtd, DWC2_HC_XFER_XACT_ERR);\n\t\t \n\t\tif (qtd->urb->actual_length >= qtd->urb->length)\n\t\t\tqtd->error_count = 3;\n\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, qtd);\n\t\tdwc2_halt_channel(hsotg, chan, qtd, DWC2_HC_XFER_XACT_ERR);\n\t}\n}\n\n \nstatic void dwc2_hc_chhltd_intr(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_host_chan *chan, int chnum,\n\t\t\t\tstruct dwc2_qtd *qtd)\n{\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"--Host Channel %d Interrupt: Channel Halted--\\n\",\n\t\t\t chnum);\n\n\tif (hsotg->params.host_dma) {\n\t\tdwc2_hc_chhltd_intr_dma(hsotg, chan, chnum, qtd);\n\t} else {\n\t\tif (!dwc2_halt_status_ok(hsotg, chan, chnum, qtd))\n\t\t\treturn;\n\t\tdwc2_release_channel(hsotg, chan, qtd, chan->halt_status);\n\t}\n}\n\n \nstatic bool dwc2_check_qtd_still_ok(struct dwc2_qtd *qtd, struct dwc2_qh *qh)\n{\n\tstruct dwc2_qtd *cur_head;\n\n\tif (!qh)\n\t\treturn false;\n\n\tcur_head = list_first_entry(&qh->qtd_list, struct dwc2_qtd,\n\t\t\t\t    qtd_list_entry);\n\treturn (cur_head == qtd);\n}\n\n \nstatic void dwc2_hc_n_intr(struct dwc2_hsotg *hsotg, int chnum)\n{\n\tstruct dwc2_qtd *qtd;\n\tstruct dwc2_host_chan *chan;\n\tu32 hcint, hcintraw, hcintmsk;\n\n\tchan = hsotg->hc_ptr_array[chnum];\n\n\thcintraw = dwc2_readl(hsotg, HCINT(chnum));\n\thcintmsk = dwc2_readl(hsotg, HCINTMSK(chnum));\n\thcint = hcintraw & hcintmsk;\n\tdwc2_writel(hsotg, hcint, HCINT(chnum));\n\n\tif (!chan) {\n\t\tdev_err(hsotg->dev, \"## hc_ptr_array for channel is NULL ##\\n\");\n\t\treturn;\n\t}\n\n\tif (dbg_hc(chan)) {\n\t\tdev_vdbg(hsotg->dev, \"--Host Channel Interrupt--, Channel %d\\n\",\n\t\t\t chnum);\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\\n\",\n\t\t\t hcintraw, hcintmsk, hcint);\n\t}\n\n\t \n\tif (!chan->qh) {\n\t\tdev_warn(hsotg->dev, \"Interrupt on disabled channel\\n\");\n\t\treturn;\n\t}\n\n\tchan->hcint = hcintraw;\n\n\t \n\tif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE) {\n\t\t \n\t\tWARN_ON(hcint != HCINTMSK_CHHLTD);\n\t\tif (hsotg->params.dma_desc_enable)\n\t\t\tdwc2_hcd_complete_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t\t    chan->halt_status);\n\t\telse\n\t\t\tdwc2_release_channel(hsotg, chan, NULL,\n\t\t\t\t\t     chan->halt_status);\n\t\treturn;\n\t}\n\n\tif (list_empty(&chan->qh->qtd_list)) {\n\t\t \n\t\tdev_dbg(hsotg->dev, \"## no QTD queued for channel %d ##\\n\",\n\t\t\tchnum);\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"  hcint 0x%08x, hcintmsk 0x%08x, hcint&hcintmsk 0x%08x\\n\",\n\t\t\tchan->hcint, hcintmsk, hcint);\n\t\tchan->halt_status = DWC2_HC_XFER_NO_HALT_STATUS;\n\t\tdisable_hc_int(hsotg, chnum, HCINTMSK_CHHLTD);\n\t\tchan->hcint = 0;\n\t\treturn;\n\t}\n\n\tqtd = list_first_entry(&chan->qh->qtd_list, struct dwc2_qtd,\n\t\t\t       qtd_list_entry);\n\n\tif (!hsotg->params.host_dma) {\n\t\tif ((hcint & HCINTMSK_CHHLTD) && hcint != HCINTMSK_CHHLTD)\n\t\t\thcint &= ~HCINTMSK_CHHLTD;\n\t}\n\n\tif (hcint & HCINTMSK_XFERCOMPL) {\n\t\tdwc2_hc_xfercomp_intr(hsotg, chan, chnum, qtd);\n\t\t \n\t\thcint &= ~HCINTMSK_NYET;\n\t}\n\n\tif (hcint & HCINTMSK_CHHLTD) {\n\t\tdwc2_hc_chhltd_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_AHBERR) {\n\t\tdwc2_hc_ahberr_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_STALL) {\n\t\tdwc2_hc_stall_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_NAK) {\n\t\tdwc2_hc_nak_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_ACK) {\n\t\tdwc2_hc_ack_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_NYET) {\n\t\tdwc2_hc_nyet_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_XACTERR) {\n\t\tdwc2_hc_xacterr_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_BBLERR) {\n\t\tdwc2_hc_babble_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_FRMOVRUN) {\n\t\tdwc2_hc_frmovrun_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\tif (hcint & HCINTMSK_DATATGLERR) {\n\t\tdwc2_hc_datatglerr_intr(hsotg, chan, chnum, qtd);\n\t\tif (!dwc2_check_qtd_still_ok(qtd, chan->qh))\n\t\t\tgoto exit;\n\t}\n\nexit:\n\tchan->hcint = 0;\n}\n\n \nstatic void dwc2_hc_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 haint;\n\tint i;\n\tstruct dwc2_host_chan *chan, *chan_tmp;\n\n\thaint = dwc2_readl(hsotg, HAINT);\n\tif (dbg_perio()) {\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t\tdev_vdbg(hsotg->dev, \"HAINT=%08x\\n\", haint);\n\t}\n\n\t \n\tlist_for_each_entry_safe(chan, chan_tmp, &hsotg->split_order,\n\t\t\t\t split_order_list_entry) {\n\t\tint hc_num = chan->hc_num;\n\n\t\tif (haint & (1 << hc_num)) {\n\t\t\tdwc2_hc_n_intr(hsotg, hc_num);\n\t\t\thaint &= ~(1 << hc_num);\n\t\t}\n\t}\n\n\tfor (i = 0; i < hsotg->params.host_channels; i++) {\n\t\tif (haint & (1 << i))\n\t\t\tdwc2_hc_n_intr(hsotg, i);\n\t}\n}\n\n \nirqreturn_t dwc2_handle_hcd_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts, dbg_gintsts;\n\tirqreturn_t retval = IRQ_HANDLED;\n\n\tif (!dwc2_is_controller_alive(hsotg)) {\n\t\tdev_warn(hsotg->dev, \"Controller is dead\\n\");\n\t\treturn retval;\n\t} else {\n\t\tretval = IRQ_NONE;\n\t}\n\n\tspin_lock(&hsotg->lock);\n\n\t \n\tif (dwc2_is_host_mode(hsotg)) {\n\t\tgintsts = dwc2_read_core_intr(hsotg);\n\t\tif (!gintsts) {\n\t\t\tspin_unlock(&hsotg->lock);\n\t\t\treturn retval;\n\t\t}\n\n\t\tretval = IRQ_HANDLED;\n\n\t\tdbg_gintsts = gintsts;\n#ifndef DEBUG_SOF\n\t\tdbg_gintsts &= ~GINTSTS_SOF;\n#endif\n\t\tif (!dbg_perio())\n\t\t\tdbg_gintsts &= ~(GINTSTS_HCHINT | GINTSTS_RXFLVL |\n\t\t\t\t\t GINTSTS_PTXFEMP);\n\n\t\t \n\t\tif (dbg_gintsts)\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"DWC OTG HCD Interrupt Detected gintsts&gintmsk=0x%08x\\n\",\n\t\t\t\t gintsts);\n\n\t\tif (gintsts & GINTSTS_SOF)\n\t\t\tdwc2_sof_intr(hsotg);\n\t\tif (gintsts & GINTSTS_RXFLVL)\n\t\t\tdwc2_rx_fifo_level_intr(hsotg);\n\t\tif (gintsts & GINTSTS_NPTXFEMP)\n\t\t\tdwc2_np_tx_fifo_empty_intr(hsotg);\n\t\tif (gintsts & GINTSTS_PRTINT)\n\t\t\tdwc2_port_intr(hsotg);\n\t\tif (gintsts & GINTSTS_HCHINT)\n\t\t\tdwc2_hc_intr(hsotg);\n\t\tif (gintsts & GINTSTS_PTXFEMP)\n\t\t\tdwc2_perio_tx_fifo_empty_intr(hsotg);\n\n\t\tif (dbg_gintsts) {\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"DWC OTG HCD Finished Servicing Interrupts\\n\");\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"DWC OTG HCD gintsts=0x%08x gintmsk=0x%08x\\n\",\n\t\t\t\t dwc2_readl(hsotg, GINTSTS),\n\t\t\t\t dwc2_readl(hsotg, GINTMSK));\n\t\t}\n\t}\n\n\tspin_unlock(&hsotg->lock);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}