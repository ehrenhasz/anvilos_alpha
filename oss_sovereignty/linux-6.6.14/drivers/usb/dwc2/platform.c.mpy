{
  "module_name": "platform.c",
  "hash_id": "c47984dae76d1877881aff14f9537bc4c9c63402462a3a07b49a6cca384a5c80",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/platform.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_data/s3c-hsotg.h>\n#include <linux/reset.h>\n\n#include <linux/usb/of.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n#include \"debug.h\"\n\nstatic const char dwc2_driver_name[] = \"dwc2\";\n\n \nstatic int dwc2_get_dr_mode(struct dwc2_hsotg *hsotg)\n{\n\tenum usb_dr_mode mode;\n\n\thsotg->dr_mode = usb_get_dr_mode(hsotg->dev);\n\tif (hsotg->dr_mode == USB_DR_MODE_UNKNOWN)\n\t\thsotg->dr_mode = USB_DR_MODE_OTG;\n\n\tmode = hsotg->dr_mode;\n\n\tif (dwc2_hw_is_device(hsotg)) {\n\t\tif (IS_ENABLED(CONFIG_USB_DWC2_HOST)) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Controller does not support host mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode = USB_DR_MODE_PERIPHERAL;\n\t} else if (dwc2_hw_is_host(hsotg)) {\n\t\tif (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL)) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Controller does not support device mode.\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmode = USB_DR_MODE_HOST;\n\t} else {\n\t\tif (IS_ENABLED(CONFIG_USB_DWC2_HOST))\n\t\t\tmode = USB_DR_MODE_HOST;\n\t\telse if (IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL))\n\t\t\tmode = USB_DR_MODE_PERIPHERAL;\n\t}\n\n\tif (mode != hsotg->dr_mode) {\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"Configuration mismatch. dr_mode forced to %s\\n\",\n\t\t\tmode == USB_DR_MODE_HOST ? \"host\" : \"device\");\n\n\t\thsotg->dr_mode = mode;\n\t}\n\n\treturn 0;\n}\n\nstatic int __dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)\n{\n\tstruct platform_device *pdev = to_platform_device(hsotg->dev);\n\tint ret;\n\n\tret = regulator_bulk_enable(ARRAY_SIZE(hsotg->supplies),\n\t\t\t\t    hsotg->supplies);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hsotg->utmi_clk) {\n\t\tret = clk_prepare_enable(hsotg->utmi_clk);\n\t\tif (ret)\n\t\t\tgoto err_dis_reg;\n\t}\n\n\tif (hsotg->clk) {\n\t\tret = clk_prepare_enable(hsotg->clk);\n\t\tif (ret)\n\t\t\tgoto err_dis_utmi_clk;\n\t}\n\n\tif (hsotg->uphy) {\n\t\tret = usb_phy_init(hsotg->uphy);\n\t} else if (hsotg->plat && hsotg->plat->phy_init) {\n\t\tret = hsotg->plat->phy_init(pdev, hsotg->plat->phy_type);\n\t} else {\n\t\tret = phy_init(hsotg->phy);\n\t\tif (ret == 0) {\n\t\t\tret = phy_power_on(hsotg->phy);\n\t\t\tif (ret)\n\t\t\t\tphy_exit(hsotg->phy);\n\t\t}\n\t}\n\n\tif (ret)\n\t\tgoto err_dis_clk;\n\n\treturn 0;\n\nerr_dis_clk:\n\tif (hsotg->clk)\n\t\tclk_disable_unprepare(hsotg->clk);\n\nerr_dis_utmi_clk:\n\tif (hsotg->utmi_clk)\n\t\tclk_disable_unprepare(hsotg->utmi_clk);\n\nerr_dis_reg:\n\tregulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);\n\n\treturn ret;\n}\n\n \nint dwc2_lowlevel_hw_enable(struct dwc2_hsotg *hsotg)\n{\n\tint ret = __dwc2_lowlevel_hw_enable(hsotg);\n\n\tif (ret == 0)\n\t\thsotg->ll_hw_enabled = true;\n\treturn ret;\n}\n\nstatic int __dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)\n{\n\tstruct platform_device *pdev = to_platform_device(hsotg->dev);\n\tint ret = 0;\n\n\tif (hsotg->uphy) {\n\t\tusb_phy_shutdown(hsotg->uphy);\n\t} else if (hsotg->plat && hsotg->plat->phy_exit) {\n\t\tret = hsotg->plat->phy_exit(pdev, hsotg->plat->phy_type);\n\t} else {\n\t\tret = phy_power_off(hsotg->phy);\n\t\tif (ret == 0)\n\t\t\tret = phy_exit(hsotg->phy);\n\t}\n\tif (ret)\n\t\treturn ret;\n\n\tif (hsotg->clk)\n\t\tclk_disable_unprepare(hsotg->clk);\n\n\tif (hsotg->utmi_clk)\n\t\tclk_disable_unprepare(hsotg->utmi_clk);\n\n\treturn regulator_bulk_disable(ARRAY_SIZE(hsotg->supplies), hsotg->supplies);\n}\n\n \nint dwc2_lowlevel_hw_disable(struct dwc2_hsotg *hsotg)\n{\n\tint ret = __dwc2_lowlevel_hw_disable(hsotg);\n\n\tif (ret == 0)\n\t\thsotg->ll_hw_enabled = false;\n\treturn ret;\n}\n\nstatic void dwc2_reset_control_assert(void *data)\n{\n\treset_control_assert(data);\n}\n\nstatic int dwc2_lowlevel_hw_init(struct dwc2_hsotg *hsotg)\n{\n\tint i, ret;\n\n\thsotg->reset = devm_reset_control_get_optional(hsotg->dev, \"dwc2\");\n\tif (IS_ERR(hsotg->reset))\n\t\treturn dev_err_probe(hsotg->dev, PTR_ERR(hsotg->reset),\n\t\t\t\t     \"error getting reset control\\n\");\n\n\treset_control_deassert(hsotg->reset);\n\tret = devm_add_action_or_reset(hsotg->dev, dwc2_reset_control_assert,\n\t\t\t\t       hsotg->reset);\n\tif (ret)\n\t\treturn ret;\n\n\thsotg->reset_ecc = devm_reset_control_get_optional(hsotg->dev, \"dwc2-ecc\");\n\tif (IS_ERR(hsotg->reset_ecc))\n\t\treturn dev_err_probe(hsotg->dev, PTR_ERR(hsotg->reset_ecc),\n\t\t\t\t     \"error getting reset control for ecc\\n\");\n\n\treset_control_deassert(hsotg->reset_ecc);\n\tret = devm_add_action_or_reset(hsotg->dev, dwc2_reset_control_assert,\n\t\t\t\t       hsotg->reset_ecc);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\thsotg->phy = devm_phy_get(hsotg->dev, \"usb2-phy\");\n\tif (IS_ERR(hsotg->phy)) {\n\t\tret = PTR_ERR(hsotg->phy);\n\t\tswitch (ret) {\n\t\tcase -ENODEV:\n\t\tcase -ENOSYS:\n\t\t\thsotg->phy = NULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn dev_err_probe(hsotg->dev, ret, \"error getting phy\\n\");\n\t\t}\n\t}\n\n\tif (!hsotg->phy) {\n\t\thsotg->uphy = devm_usb_get_phy(hsotg->dev, USB_PHY_TYPE_USB2);\n\t\tif (IS_ERR(hsotg->uphy)) {\n\t\t\tret = PTR_ERR(hsotg->uphy);\n\t\t\tswitch (ret) {\n\t\t\tcase -ENODEV:\n\t\t\tcase -ENXIO:\n\t\t\t\thsotg->uphy = NULL;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn dev_err_probe(hsotg->dev, ret, \"error getting usb phy\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\thsotg->plat = dev_get_platdata(hsotg->dev);\n\n\t \n\thsotg->clk = devm_clk_get_optional(hsotg->dev, \"otg\");\n\tif (IS_ERR(hsotg->clk))\n\t\treturn dev_err_probe(hsotg->dev, PTR_ERR(hsotg->clk), \"cannot get otg clock\\n\");\n\n\thsotg->utmi_clk = devm_clk_get_optional(hsotg->dev, \"utmi\");\n\tif (IS_ERR(hsotg->utmi_clk))\n\t\treturn dev_err_probe(hsotg->dev, PTR_ERR(hsotg->utmi_clk),\n\t\t\t\t     \"cannot get utmi clock\\n\");\n\n\t \n\tfor (i = 0; i < ARRAY_SIZE(hsotg->supplies); i++)\n\t\thsotg->supplies[i].supply = dwc2_hsotg_supply_names[i];\n\n\tret = devm_regulator_bulk_get(hsotg->dev, ARRAY_SIZE(hsotg->supplies),\n\t\t\t\t      hsotg->supplies);\n\tif (ret)\n\t\treturn dev_err_probe(hsotg->dev, ret, \"failed to request supplies\\n\");\n\n\treturn 0;\n}\n\n \nstatic void dwc2_driver_remove(struct platform_device *dev)\n{\n\tstruct dwc2_hsotg *hsotg = platform_get_drvdata(dev);\n\tstruct dwc2_gregs_backup *gr;\n\tint ret = 0;\n\n\tgr = &hsotg->gr_backup;\n\n\t \n\tif (hsotg->hibernated) {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tret = dwc2_exit_hibernation(hsotg, 0, 0, 1);\n\t\telse\n\t\t\tret = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\n\");\n\t}\n\n\t \n\tif (hsotg->in_ppd) {\n\t\tret = dwc2_exit_partial_power_down(hsotg, 0, true);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down failed\\n\");\n\t}\n\n\t \n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\tdwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg, 0);\n\t}\n\n\tdwc2_debugfs_exit(hsotg);\n\tif (hsotg->hcd_enabled)\n\t\tdwc2_hcd_remove(hsotg);\n\tif (hsotg->gadget_enabled)\n\t\tdwc2_hsotg_remove(hsotg);\n\n\tdwc2_drd_exit(hsotg);\n\n\tif (hsotg->params.activate_stm_id_vb_detection)\n\t\tregulator_disable(hsotg->usb33d);\n\n\tif (hsotg->ll_hw_enabled)\n\t\tdwc2_lowlevel_hw_disable(hsotg);\n}\n\n \nstatic void dwc2_driver_shutdown(struct platform_device *dev)\n{\n\tstruct dwc2_hsotg *hsotg = platform_get_drvdata(dev);\n\n\tdwc2_disable_global_interrupts(hsotg);\n\tsynchronize_irq(hsotg->irq);\n}\n\n \nstatic bool dwc2_check_core_endianness(struct dwc2_hsotg *hsotg)\n{\n\tu32 snpsid;\n\n\tsnpsid = ioread32(hsotg->regs + GSNPSID);\n\tif ((snpsid & GSNPSID_ID_MASK) == DWC2_OTG_ID ||\n\t    (snpsid & GSNPSID_ID_MASK) == DWC2_FS_IOT_ID ||\n\t    (snpsid & GSNPSID_ID_MASK) == DWC2_HS_IOT_ID)\n\t\treturn false;\n\treturn true;\n}\n\n \nint dwc2_check_core_version(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\n\t \n\n\thw->snpsid = dwc2_readl(hsotg, GSNPSID);\n\tif ((hw->snpsid & GSNPSID_ID_MASK) != DWC2_OTG_ID &&\n\t    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_FS_IOT_ID &&\n\t    (hw->snpsid & GSNPSID_ID_MASK) != DWC2_HS_IOT_ID) {\n\t\tdev_err(hsotg->dev, \"Bad value for GSNPSID: 0x%08x\\n\",\n\t\t\thw->snpsid);\n\t\treturn -ENODEV;\n\t}\n\n\tdev_dbg(hsotg->dev, \"Core Release: %1x.%1x%1x%1x (snpsid=%x)\\n\",\n\t\thw->snpsid >> 12 & 0xf, hw->snpsid >> 8 & 0xf,\n\t\thw->snpsid >> 4 & 0xf, hw->snpsid & 0xf, hw->snpsid);\n\treturn 0;\n}\n\n \nstatic int dwc2_driver_probe(struct platform_device *dev)\n{\n\tstruct dwc2_hsotg *hsotg;\n\tstruct resource *res;\n\tint retval;\n\n\thsotg = devm_kzalloc(&dev->dev, sizeof(*hsotg), GFP_KERNEL);\n\tif (!hsotg)\n\t\treturn -ENOMEM;\n\n\thsotg->dev = &dev->dev;\n\n\t \n\tif (!dev->dev.dma_mask)\n\t\tdev->dev.dma_mask = &dev->dev.coherent_dma_mask;\n\tretval = dma_set_coherent_mask(&dev->dev, DMA_BIT_MASK(32));\n\tif (retval) {\n\t\tdev_err(&dev->dev, \"can't set coherent DMA mask: %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\thsotg->regs = devm_platform_get_and_ioremap_resource(dev, 0, &res);\n\tif (IS_ERR(hsotg->regs))\n\t\treturn PTR_ERR(hsotg->regs);\n\n\tdev_dbg(&dev->dev, \"mapped PA %08lx to VA %p\\n\",\n\t\t(unsigned long)res->start, hsotg->regs);\n\n\tretval = dwc2_lowlevel_hw_init(hsotg);\n\tif (retval)\n\t\treturn retval;\n\n\tspin_lock_init(&hsotg->lock);\n\n\thsotg->irq = platform_get_irq(dev, 0);\n\tif (hsotg->irq < 0)\n\t\treturn hsotg->irq;\n\n\tdev_dbg(hsotg->dev, \"registering common handler for irq%d\\n\",\n\t\thsotg->irq);\n\tretval = devm_request_irq(hsotg->dev, hsotg->irq,\n\t\t\t\t  dwc2_handle_common_intr, IRQF_SHARED,\n\t\t\t\t  dev_name(hsotg->dev), hsotg);\n\tif (retval)\n\t\treturn retval;\n\n\thsotg->vbus_supply = devm_regulator_get_optional(hsotg->dev, \"vbus\");\n\tif (IS_ERR(hsotg->vbus_supply)) {\n\t\tretval = PTR_ERR(hsotg->vbus_supply);\n\t\thsotg->vbus_supply = NULL;\n\t\tif (retval != -ENODEV)\n\t\t\treturn retval;\n\t}\n\n\tretval = dwc2_lowlevel_hw_enable(hsotg);\n\tif (retval)\n\t\treturn retval;\n\n\thsotg->needs_byte_swap = dwc2_check_core_endianness(hsotg);\n\n\tretval = dwc2_get_dr_mode(hsotg);\n\tif (retval)\n\t\tgoto error;\n\n\thsotg->need_phy_for_wake =\n\t\tof_property_read_bool(dev->dev.of_node,\n\t\t\t\t      \"snps,need-phy-for-wake\");\n\n\t \n\tretval = dwc2_check_core_version(hsotg);\n\tif (retval)\n\t\tgoto error;\n\n\t \n\tretval = dwc2_core_reset(hsotg, false);\n\tif (retval)\n\t\tgoto error;\n\n\t \n\tretval = dwc2_get_hwparams(hsotg);\n\tif (retval)\n\t\tgoto error;\n\n\t \n\tdwc2_force_dr_mode(hsotg);\n\n\tretval = dwc2_init_params(hsotg);\n\tif (retval)\n\t\tgoto error;\n\n\tif (hsotg->params.activate_stm_id_vb_detection) {\n\t\tu32 ggpio;\n\n\t\thsotg->usb33d = devm_regulator_get(hsotg->dev, \"usb33d\");\n\t\tif (IS_ERR(hsotg->usb33d)) {\n\t\t\tretval = PTR_ERR(hsotg->usb33d);\n\t\t\tdev_err_probe(hsotg->dev, retval, \"failed to request usb33d supply\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tretval = regulator_enable(hsotg->usb33d);\n\t\tif (retval) {\n\t\t\tdev_err_probe(hsotg->dev, retval, \"failed to enable usb33d supply\\n\");\n\t\t\tgoto error;\n\t\t}\n\n\t\tggpio = dwc2_readl(hsotg, GGPIO);\n\t\tggpio |= GGPIO_STM32_OTG_GCCFG_IDEN;\n\t\tggpio |= GGPIO_STM32_OTG_GCCFG_VBDEN;\n\t\tdwc2_writel(hsotg, ggpio, GGPIO);\n\n\t\t \n\t\tusleep_range(5000, 7000);\n\t}\n\n\tretval = dwc2_drd_init(hsotg);\n\tif (retval) {\n\t\tdev_err_probe(hsotg->dev, retval, \"failed to initialize dual-role\\n\");\n\t\tgoto error_init;\n\t}\n\n\tif (hsotg->dr_mode != USB_DR_MODE_HOST) {\n\t\tretval = dwc2_gadget_init(hsotg);\n\t\tif (retval)\n\t\t\tgoto error_drd;\n\t\thsotg->gadget_enabled = 1;\n\t}\n\n\t \n\tif (hsotg->need_phy_for_wake)\n\t\tdevice_set_wakeup_capable(&dev->dev, true);\n\n\thsotg->reset_phy_on_wake =\n\t\tof_property_read_bool(dev->dev.of_node,\n\t\t\t\t      \"snps,reset-phy-on-wake\");\n\tif (hsotg->reset_phy_on_wake && !hsotg->phy) {\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"Quirk reset-phy-on-wake only supports generic PHYs\\n\");\n\t\thsotg->reset_phy_on_wake = false;\n\t}\n\n\tif (hsotg->dr_mode != USB_DR_MODE_PERIPHERAL) {\n\t\tretval = dwc2_hcd_init(hsotg);\n\t\tif (retval) {\n\t\t\tif (hsotg->gadget_enabled)\n\t\t\t\tdwc2_hsotg_remove(hsotg);\n\t\t\tgoto error_drd;\n\t\t}\n\t\thsotg->hcd_enabled = 1;\n\t}\n\n\tplatform_set_drvdata(dev, hsotg);\n\thsotg->hibernated = 0;\n\n\tdwc2_debugfs_init(hsotg);\n\n\t \n\tif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc2_lowlevel_hw_disable(hsotg);\n\n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\n\t \n\tif (hsotg->gadget_enabled) {\n\t\tretval = usb_add_gadget_udc(hsotg->dev, &hsotg->gadget);\n\t\tif (retval) {\n\t\t\thsotg->gadget.udc = NULL;\n\t\t\tdwc2_hsotg_remove(hsotg);\n\t\t\tgoto error_debugfs;\n\t\t}\n\t}\n#endif  \n\treturn 0;\n\n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\nerror_debugfs:\n\tdwc2_debugfs_exit(hsotg);\n\tif (hsotg->hcd_enabled)\n\t\tdwc2_hcd_remove(hsotg);\n#endif\nerror_drd:\n\tdwc2_drd_exit(hsotg);\n\nerror_init:\n\tif (hsotg->params.activate_stm_id_vb_detection)\n\t\tregulator_disable(hsotg->usb33d);\nerror:\n\tif (hsotg->ll_hw_enabled)\n\t\tdwc2_lowlevel_hw_disable(hsotg);\n\treturn retval;\n}\n\nstatic int __maybe_unused dwc2_suspend(struct device *dev)\n{\n\tstruct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);\n\tbool is_device_mode = dwc2_is_device_mode(dwc2);\n\tint ret = 0;\n\n\tif (is_device_mode)\n\t\tdwc2_hsotg_suspend(dwc2);\n\n\tdwc2_drd_suspend(dwc2);\n\n\tif (dwc2->params.activate_stm_id_vb_detection) {\n\t\tunsigned long flags;\n\t\tu32 ggpio, gotgctl;\n\n\t\t \n\t\tdwc2_force_mode(dwc2, !is_device_mode);\n\n\t\tspin_lock_irqsave(&dwc2->lock, flags);\n\t\tgotgctl = dwc2_readl(dwc2, GOTGCTL);\n\t\t \n\t\tgotgctl |= GOTGCTL_DBNCE_FLTR_BYPASS;\n\t\tgotgctl |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN;\n\t\t \n\t\tif (gotgctl & GOTGCTL_ASESVLD)\n\t\t\tgotgctl |= GOTGCTL_AVALOVAL;\n\t\tif (gotgctl & GOTGCTL_BSESVLD)\n\t\t\tgotgctl |= GOTGCTL_BVALOVAL;\n\t\tdwc2_writel(dwc2, gotgctl, GOTGCTL);\n\t\tspin_unlock_irqrestore(&dwc2->lock, flags);\n\n\t\tggpio = dwc2_readl(dwc2, GGPIO);\n\t\tggpio &= ~GGPIO_STM32_OTG_GCCFG_IDEN;\n\t\tggpio &= ~GGPIO_STM32_OTG_GCCFG_VBDEN;\n\t\tdwc2_writel(dwc2, ggpio, GGPIO);\n\n\t\tregulator_disable(dwc2->usb33d);\n\t}\n\n\tif (dwc2->ll_hw_enabled &&\n\t    (is_device_mode || dwc2_host_can_poweroff_phy(dwc2))) {\n\t\tret = __dwc2_lowlevel_hw_disable(dwc2);\n\t\tdwc2->phy_off_for_suspend = true;\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused dwc2_resume(struct device *dev)\n{\n\tstruct dwc2_hsotg *dwc2 = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (dwc2->phy_off_for_suspend && dwc2->ll_hw_enabled) {\n\t\tret = __dwc2_lowlevel_hw_enable(dwc2);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tdwc2->phy_off_for_suspend = false;\n\n\tif (dwc2->params.activate_stm_id_vb_detection) {\n\t\tunsigned long flags;\n\t\tu32 ggpio, gotgctl;\n\n\t\tret = regulator_enable(dwc2->usb33d);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tggpio = dwc2_readl(dwc2, GGPIO);\n\t\tggpio |= GGPIO_STM32_OTG_GCCFG_IDEN;\n\t\tggpio |= GGPIO_STM32_OTG_GCCFG_VBDEN;\n\t\tdwc2_writel(dwc2, ggpio, GGPIO);\n\n\t\t \n\t\tusleep_range(5000, 7000);\n\n\t\tspin_lock_irqsave(&dwc2->lock, flags);\n\t\tgotgctl = dwc2_readl(dwc2, GOTGCTL);\n\t\tgotgctl &= ~GOTGCTL_DBNCE_FLTR_BYPASS;\n\t\tgotgctl &= ~(GOTGCTL_BVALOEN | GOTGCTL_AVALOEN |\n\t\t\t     GOTGCTL_BVALOVAL | GOTGCTL_AVALOVAL);\n\t\tdwc2_writel(dwc2, gotgctl, GOTGCTL);\n\t\tspin_unlock_irqrestore(&dwc2->lock, flags);\n\t}\n\n\tif (!dwc2->role_sw) {\n\t\t \n\t\tdwc2_force_dr_mode(dwc2);\n\t} else {\n\t\tdwc2_drd_resume(dwc2);\n\t}\n\n\tif (dwc2_is_device_mode(dwc2))\n\t\tret = dwc2_hsotg_resume(dwc2);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops dwc2_dev_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(dwc2_suspend, dwc2_resume)\n};\n\nstatic struct platform_driver dwc2_platform_driver = {\n\t.driver = {\n\t\t.name = dwc2_driver_name,\n\t\t.of_match_table = dwc2_of_match_table,\n\t\t.acpi_match_table = ACPI_PTR(dwc2_acpi_match),\n\t\t.pm = &dwc2_dev_pm_ops,\n\t},\n\t.probe = dwc2_driver_probe,\n\t.remove_new = dwc2_driver_remove,\n\t.shutdown = dwc2_driver_shutdown,\n};\n\nmodule_platform_driver(dwc2_platform_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}