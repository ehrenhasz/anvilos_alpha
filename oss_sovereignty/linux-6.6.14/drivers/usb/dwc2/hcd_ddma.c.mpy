{
  "module_name": "hcd_ddma.c",
  "hash_id": "1b9e688f07e2c51cce7f2b6d912901bfa3fb65d66f7006c7a1e8b4fed53aea40",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/hcd_ddma.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\nstatic u16 dwc2_frame_list_idx(u16 frame)\n{\n\treturn frame & (FRLISTEN_64_SIZE - 1);\n}\n\nstatic u16 dwc2_desclist_idx_inc(u16 idx, u16 inc, u8 speed)\n{\n\treturn (idx + inc) &\n\t\t((speed == USB_SPEED_HIGH ? MAX_DMA_DESC_NUM_HS_ISOC :\n\t\t  MAX_DMA_DESC_NUM_GENERIC) - 1);\n}\n\nstatic u16 dwc2_desclist_idx_dec(u16 idx, u16 inc, u8 speed)\n{\n\treturn (idx - inc) &\n\t\t((speed == USB_SPEED_HIGH ? MAX_DMA_DESC_NUM_HS_ISOC :\n\t\t  MAX_DMA_DESC_NUM_GENERIC) - 1);\n}\n\nstatic u16 dwc2_max_desc_num(struct dwc2_qh *qh)\n{\n\treturn (qh->ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t\tqh->dev_speed == USB_SPEED_HIGH) ?\n\t\tMAX_DMA_DESC_NUM_HS_ISOC : MAX_DMA_DESC_NUM_GENERIC;\n}\n\nstatic u16 dwc2_frame_incr_val(struct dwc2_qh *qh)\n{\n\treturn qh->dev_speed == USB_SPEED_HIGH ?\n\t       (qh->host_interval + 8 - 1) / 8 : qh->host_interval;\n}\n\nstatic int dwc2_desc_list_alloc(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t\tgfp_t flags)\n{\n\tstruct kmem_cache *desc_cache;\n\n\tif (qh->ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t    qh->dev_speed == USB_SPEED_HIGH)\n\t\tdesc_cache = hsotg->desc_hsisoc_cache;\n\telse\n\t\tdesc_cache = hsotg->desc_gen_cache;\n\n\tqh->desc_list_sz = sizeof(struct dwc2_dma_desc) *\n\t\t\t\t\t\tdwc2_max_desc_num(qh);\n\n\tqh->desc_list = kmem_cache_zalloc(desc_cache, flags | GFP_DMA);\n\tif (!qh->desc_list)\n\t\treturn -ENOMEM;\n\n\tqh->desc_list_dma = dma_map_single(hsotg->dev, qh->desc_list,\n\t\t\t\t\t   qh->desc_list_sz,\n\t\t\t\t\t   DMA_TO_DEVICE);\n\n\tqh->n_bytes = kcalloc(dwc2_max_desc_num(qh), sizeof(u32), flags);\n\tif (!qh->n_bytes) {\n\t\tdma_unmap_single(hsotg->dev, qh->desc_list_dma,\n\t\t\t\t qh->desc_list_sz,\n\t\t\t\t DMA_FROM_DEVICE);\n\t\tkmem_cache_free(desc_cache, qh->desc_list);\n\t\tqh->desc_list = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc2_desc_list_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tstruct kmem_cache *desc_cache;\n\n\tif (qh->ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t    qh->dev_speed == USB_SPEED_HIGH)\n\t\tdesc_cache = hsotg->desc_hsisoc_cache;\n\telse\n\t\tdesc_cache = hsotg->desc_gen_cache;\n\n\tif (qh->desc_list) {\n\t\tdma_unmap_single(hsotg->dev, qh->desc_list_dma,\n\t\t\t\t qh->desc_list_sz, DMA_FROM_DEVICE);\n\t\tkmem_cache_free(desc_cache, qh->desc_list);\n\t\tqh->desc_list = NULL;\n\t}\n\n\tkfree(qh->n_bytes);\n\tqh->n_bytes = NULL;\n}\n\nstatic int dwc2_frame_list_alloc(struct dwc2_hsotg *hsotg, gfp_t mem_flags)\n{\n\tif (hsotg->frame_list)\n\t\treturn 0;\n\n\thsotg->frame_list_sz = 4 * FRLISTEN_64_SIZE;\n\thsotg->frame_list = kzalloc(hsotg->frame_list_sz, GFP_ATOMIC | GFP_DMA);\n\tif (!hsotg->frame_list)\n\t\treturn -ENOMEM;\n\n\thsotg->frame_list_dma = dma_map_single(hsotg->dev, hsotg->frame_list,\n\t\t\t\t\t       hsotg->frame_list_sz,\n\t\t\t\t\t       DMA_TO_DEVICE);\n\n\treturn 0;\n}\n\nstatic void dwc2_frame_list_free(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tif (!hsotg->frame_list) {\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\treturn;\n\t}\n\n\tdma_unmap_single(hsotg->dev, hsotg->frame_list_dma,\n\t\t\t hsotg->frame_list_sz, DMA_FROM_DEVICE);\n\n\tkfree(hsotg->frame_list);\n\thsotg->frame_list = NULL;\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\nstatic void dwc2_per_sched_enable(struct dwc2_hsotg *hsotg, u32 fr_list_en)\n{\n\tu32 hcfg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\thcfg = dwc2_readl(hsotg, HCFG);\n\tif (hcfg & HCFG_PERSCHEDENA) {\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\treturn;\n\t}\n\n\tdwc2_writel(hsotg, hsotg->frame_list_dma, HFLBADDR);\n\n\thcfg &= ~HCFG_FRLISTEN_MASK;\n\thcfg |= fr_list_en | HCFG_PERSCHEDENA;\n\tdev_vdbg(hsotg->dev, \"Enabling Periodic schedule\\n\");\n\tdwc2_writel(hsotg, hcfg, HCFG);\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\nstatic void dwc2_per_sched_disable(struct dwc2_hsotg *hsotg)\n{\n\tu32 hcfg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\thcfg = dwc2_readl(hsotg, HCFG);\n\tif (!(hcfg & HCFG_PERSCHEDENA)) {\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\treturn;\n\t}\n\n\thcfg &= ~HCFG_PERSCHEDENA;\n\tdev_vdbg(hsotg->dev, \"Disabling Periodic schedule\\n\");\n\tdwc2_writel(hsotg, hcfg, HCFG);\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\n \nstatic void dwc2_update_frame_list(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t\t   int enable)\n{\n\tstruct dwc2_host_chan *chan;\n\tu16 i, j, inc;\n\n\tif (!hsotg) {\n\t\tpr_err(\"hsotg = %p\\n\", hsotg);\n\t\treturn;\n\t}\n\n\tif (!qh->channel) {\n\t\tdev_err(hsotg->dev, \"qh->channel = %p\\n\", qh->channel);\n\t\treturn;\n\t}\n\n\tif (!hsotg->frame_list) {\n\t\tdev_err(hsotg->dev, \"hsotg->frame_list = %p\\n\",\n\t\t\thsotg->frame_list);\n\t\treturn;\n\t}\n\n\tchan = qh->channel;\n\tinc = dwc2_frame_incr_val(qh);\n\tif (qh->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\ti = dwc2_frame_list_idx(qh->next_active_frame);\n\telse\n\t\ti = 0;\n\n\tj = i;\n\tdo {\n\t\tif (enable)\n\t\t\thsotg->frame_list[j] |= 1 << chan->hc_num;\n\t\telse\n\t\t\thsotg->frame_list[j] &= ~(1 << chan->hc_num);\n\t\tj = (j + inc) & (FRLISTEN_64_SIZE - 1);\n\t} while (j != i);\n\n\t \n\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t   hsotg->frame_list_dma,\n\t\t\t\t   hsotg->frame_list_sz,\n\t\t\t\t   DMA_TO_DEVICE);\n\n\tif (!enable)\n\t\treturn;\n\n\tchan->schinfo = 0;\n\tif (chan->speed == USB_SPEED_HIGH && qh->host_interval) {\n\t\tj = 1;\n\t\t \n\t\tinc = (8 + qh->host_interval - 1) / qh->host_interval;\n\t\tfor (i = 0; i < inc; i++) {\n\t\t\tchan->schinfo |= j;\n\t\t\tj = j << qh->host_interval;\n\t\t}\n\t} else {\n\t\tchan->schinfo = 0xff;\n\t}\n}\n\nstatic void dwc2_release_channel_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_qh *qh)\n{\n\tstruct dwc2_host_chan *chan = qh->channel;\n\n\tif (dwc2_qh_is_non_per(qh)) {\n\t\tif (hsotg->params.uframe_sched)\n\t\t\thsotg->available_host_channels++;\n\t\telse\n\t\t\thsotg->non_periodic_channels--;\n\t} else {\n\t\tdwc2_update_frame_list(hsotg, qh, 0);\n\t\thsotg->available_host_channels++;\n\t}\n\n\t \n\tif (chan->qh) {\n\t\tif (!list_empty(&chan->hc_list_entry))\n\t\t\tlist_del(&chan->hc_list_entry);\n\t\tdwc2_hc_cleanup(hsotg, chan);\n\t\tlist_add_tail(&chan->hc_list_entry, &hsotg->free_hc_list);\n\t\tchan->qh = NULL;\n\t}\n\n\tqh->channel = NULL;\n\tqh->ntd = 0;\n\n\tif (qh->desc_list)\n\t\tmemset(qh->desc_list, 0, sizeof(struct dwc2_dma_desc) *\n\t\t       dwc2_max_desc_num(qh));\n}\n\n \nint dwc2_hcd_qh_init_ddma(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t  gfp_t mem_flags)\n{\n\tint retval;\n\n\tif (qh->do_split) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"SPLIT Transfers are not supported in Descriptor DMA mode.\\n\");\n\t\tretval = -EINVAL;\n\t\tgoto err0;\n\t}\n\n\tretval = dwc2_desc_list_alloc(hsotg, qh, mem_flags);\n\tif (retval)\n\t\tgoto err0;\n\n\tif (qh->ep_type == USB_ENDPOINT_XFER_ISOC ||\n\t    qh->ep_type == USB_ENDPOINT_XFER_INT) {\n\t\tif (!hsotg->frame_list) {\n\t\t\tretval = dwc2_frame_list_alloc(hsotg, mem_flags);\n\t\t\tif (retval)\n\t\t\t\tgoto err1;\n\t\t\t \n\t\t\tdwc2_per_sched_enable(hsotg, HCFG_FRLISTEN_64);\n\t\t}\n\t}\n\n\tqh->ntd = 0;\n\treturn 0;\n\nerr1:\n\tdwc2_desc_list_free(hsotg, qh);\nerr0:\n\treturn retval;\n}\n\n \nvoid dwc2_hcd_qh_free_ddma(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tunsigned long flags;\n\n\tdwc2_desc_list_free(hsotg, qh);\n\n\t \n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tif (qh->channel)\n\t\tdwc2_release_channel_ddma(hsotg, qh);\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tif ((qh->ep_type == USB_ENDPOINT_XFER_ISOC ||\n\t     qh->ep_type == USB_ENDPOINT_XFER_INT) &&\n\t    (hsotg->params.uframe_sched ||\n\t     !hsotg->periodic_channels) && hsotg->frame_list) {\n\t\tdwc2_per_sched_disable(hsotg);\n\t\tdwc2_frame_list_free(hsotg);\n\t}\n}\n\nstatic u8 dwc2_frame_to_desc_idx(struct dwc2_qh *qh, u16 frame_idx)\n{\n\tif (qh->dev_speed == USB_SPEED_HIGH)\n\t\t \n\t\treturn (frame_idx & ((MAX_DMA_DESC_NUM_HS_ISOC / 8) - 1)) * 8;\n\telse\n\t\treturn frame_idx & (MAX_DMA_DESC_NUM_GENERIC - 1);\n}\n\n \nstatic u16 dwc2_calc_starting_frame(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh, u16 *skip_frames)\n{\n\tu16 frame;\n\n\thsotg->frame_number = dwc2_hcd_get_frame_number(hsotg);\n\n\t \n\n\t \n\tif (qh->dev_speed == USB_SPEED_HIGH) {\n\t\t \n\t\tif (dwc2_micro_frame_num(hsotg->frame_number) >= 5) {\n\t\t\t*skip_frames = 2 * 8;\n\t\t\tframe = dwc2_frame_num_inc(hsotg->frame_number,\n\t\t\t\t\t\t   *skip_frames);\n\t\t} else {\n\t\t\t*skip_frames = 1 * 8;\n\t\t\tframe = dwc2_frame_num_inc(hsotg->frame_number,\n\t\t\t\t\t\t   *skip_frames);\n\t\t}\n\n\t\tframe = dwc2_full_frame_num(frame);\n\t} else {\n\t\t \n\t\t*skip_frames = 1;\n\t\tframe = dwc2_frame_num_inc(hsotg->frame_number, 2);\n\t}\n\n\treturn frame;\n}\n\n \nstatic u16 dwc2_recalc_initial_desc_idx(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_qh *qh)\n{\n\tu16 frame, fr_idx, fr_idx_tmp, skip_frames;\n\n\t \n\n\t \n\tif (qh->channel) {\n\t\tframe = dwc2_calc_starting_frame(hsotg, qh, &skip_frames);\n\t\t \n\t\tfr_idx_tmp = dwc2_frame_list_idx(frame);\n\t\tfr_idx = (FRLISTEN_64_SIZE +\n\t\t\t  dwc2_frame_list_idx(qh->next_active_frame) -\n\t\t\t  fr_idx_tmp) % dwc2_frame_incr_val(qh);\n\t\tfr_idx = (fr_idx + fr_idx_tmp) % FRLISTEN_64_SIZE;\n\t} else {\n\t\tqh->next_active_frame = dwc2_calc_starting_frame(hsotg, qh,\n\t\t\t\t\t\t\t   &skip_frames);\n\t\tfr_idx = dwc2_frame_list_idx(qh->next_active_frame);\n\t}\n\n\tqh->td_first = qh->td_last = dwc2_frame_to_desc_idx(qh, fr_idx);\n\n\treturn skip_frames;\n}\n\n#define ISOC_URB_GIVEBACK_ASAP\n\n#define MAX_ISOC_XFER_SIZE_FS\t1023\n#define MAX_ISOC_XFER_SIZE_HS\t3072\n#define DESCNUM_THRESHOLD\t4\n\nstatic void dwc2_fill_host_isoc_dma_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t struct dwc2_qtd *qtd,\n\t\t\t\t\t struct dwc2_qh *qh, u32 max_xfer_size,\n\t\t\t\t\t u16 idx)\n{\n\tstruct dwc2_dma_desc *dma_desc = &qh->desc_list[idx];\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\n\tmemset(dma_desc, 0, sizeof(*dma_desc));\n\tframe_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index_last];\n\n\tif (frame_desc->length > max_xfer_size)\n\t\tqh->n_bytes[idx] = max_xfer_size;\n\telse\n\t\tqh->n_bytes[idx] = frame_desc->length;\n\n\tdma_desc->buf = (u32)(qtd->urb->dma + frame_desc->offset);\n\tdma_desc->status = qh->n_bytes[idx] << HOST_DMA_ISOC_NBYTES_SHIFT &\n\t\t\t   HOST_DMA_ISOC_NBYTES_MASK;\n\n\t \n\tdma_desc->status |= HOST_DMA_A;\n\n\tqh->ntd++;\n\tqtd->isoc_frame_index_last++;\n\n#ifdef ISOC_URB_GIVEBACK_ASAP\n\t \n\tif (qtd->isoc_frame_index_last == qtd->urb->packet_count)\n\t\tdma_desc->status |= HOST_DMA_IOC;\n#endif\n\n\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t   qh->desc_list_dma +\n\t\t\t(idx * sizeof(struct dwc2_dma_desc)),\n\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\tDMA_TO_DEVICE);\n}\n\nstatic void dwc2_init_isoc_dma_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh, u16 skip_frames)\n{\n\tstruct dwc2_qtd *qtd;\n\tu32 max_xfer_size;\n\tu16 idx, inc, n_desc = 0, ntd_max = 0;\n\tu16 cur_idx;\n\tu16 next_idx;\n\n\tidx = qh->td_last;\n\tinc = qh->host_interval;\n\thsotg->frame_number = dwc2_hcd_get_frame_number(hsotg);\n\tcur_idx = dwc2_frame_list_idx(hsotg->frame_number);\n\tnext_idx = dwc2_desclist_idx_inc(qh->td_last, inc, qh->dev_speed);\n\n\t \n\tif (dwc2_frame_idx_num_gt(cur_idx, next_idx) || (cur_idx == next_idx)) {\n\t\tif (inc < 32) {\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"current frame number overstep last descriptor\\n\");\n\t\t\tqh->td_last = dwc2_desclist_idx_inc(cur_idx, inc,\n\t\t\t\t\t\t\t    qh->dev_speed);\n\t\t\tidx = qh->td_last;\n\t\t}\n\t}\n\n\tif (qh->host_interval) {\n\t\tntd_max = (dwc2_max_desc_num(qh) + qh->host_interval - 1) /\n\t\t\t\tqh->host_interval;\n\t\tif (skip_frames && !qh->channel)\n\t\t\tntd_max -= skip_frames / qh->host_interval;\n\t}\n\n\tmax_xfer_size = qh->dev_speed == USB_SPEED_HIGH ?\n\t\t\tMAX_ISOC_XFER_SIZE_HS : MAX_ISOC_XFER_SIZE_FS;\n\n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list_entry) {\n\t\tif (qtd->in_process &&\n\t\t    qtd->isoc_frame_index_last ==\n\t\t    qtd->urb->packet_count)\n\t\t\tcontinue;\n\n\t\tqtd->isoc_td_first = idx;\n\t\twhile (qh->ntd < ntd_max && qtd->isoc_frame_index_last <\n\t\t\t\t\t\tqtd->urb->packet_count) {\n\t\t\tdwc2_fill_host_isoc_dma_desc(hsotg, qtd, qh,\n\t\t\t\t\t\t     max_xfer_size, idx);\n\t\t\tidx = dwc2_desclist_idx_inc(idx, inc, qh->dev_speed);\n\t\t\tn_desc++;\n\t\t}\n\t\tqtd->isoc_td_last = idx;\n\t\tqtd->in_process = 1;\n\t}\n\n\tqh->td_last = idx;\n\n#ifdef ISOC_URB_GIVEBACK_ASAP\n\t \n\tif (qh->ntd == ntd_max) {\n\t\tidx = dwc2_desclist_idx_dec(qh->td_last, inc, qh->dev_speed);\n\t\tqh->desc_list[idx].status |= HOST_DMA_IOC;\n\t\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t\t   qh->desc_list_dma + (idx *\n\t\t\t\t\t   sizeof(struct dwc2_dma_desc)),\n\t\t\t\t\t   sizeof(struct dwc2_dma_desc),\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t}\n#else\n\t \n\n\tif (n_desc > DESCNUM_THRESHOLD)\n\t\t \n\t\tidx = dwc2_desclist_idx_dec(idx, inc * ((qh->ntd + 1) / 2),\n\t\t\t\t\t    qh->dev_speed);\n\telse\n\t\t \n\t\tidx = dwc2_desclist_idx_dec(qh->td_last, inc, qh->dev_speed);\n\n\tqh->desc_list[idx].status |= HOST_DMA_IOC;\n\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t   qh->desc_list_dma +\n\t\t\t\t   (idx * sizeof(struct dwc2_dma_desc)),\n\t\t\t\t   sizeof(struct dwc2_dma_desc),\n\t\t\t\t   DMA_TO_DEVICE);\n#endif\n}\n\nstatic void dwc2_fill_host_dma_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_host_chan *chan,\n\t\t\t\t    struct dwc2_qtd *qtd, struct dwc2_qh *qh,\n\t\t\t\t    int n_desc)\n{\n\tstruct dwc2_dma_desc *dma_desc = &qh->desc_list[n_desc];\n\tint len = chan->xfer_len;\n\n\tif (len > HOST_DMA_NBYTES_LIMIT - (chan->max_packet - 1))\n\t\tlen = HOST_DMA_NBYTES_LIMIT - (chan->max_packet - 1);\n\n\tif (chan->ep_is_in) {\n\t\tint num_packets;\n\n\t\tif (len > 0 && chan->max_packet)\n\t\t\tnum_packets = (len + chan->max_packet - 1)\n\t\t\t\t\t/ chan->max_packet;\n\t\telse\n\t\t\t \n\t\t\tnum_packets = 1;\n\n\t\t \n\t\tlen = num_packets * chan->max_packet;\n\t}\n\n\tdma_desc->status = len << HOST_DMA_NBYTES_SHIFT & HOST_DMA_NBYTES_MASK;\n\tqh->n_bytes[n_desc] = len;\n\n\tif (qh->ep_type == USB_ENDPOINT_XFER_CONTROL &&\n\t    qtd->control_phase == DWC2_CONTROL_SETUP)\n\t\tdma_desc->status |= HOST_DMA_SUP;\n\n\tdma_desc->buf = (u32)chan->xfer_dma;\n\n\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t   qh->desc_list_dma +\n\t\t\t\t   (n_desc * sizeof(struct dwc2_dma_desc)),\n\t\t\t\t   sizeof(struct dwc2_dma_desc),\n\t\t\t\t   DMA_TO_DEVICE);\n\n\t \n\tif (len > chan->xfer_len) {\n\t\tchan->xfer_len = 0;\n\t} else {\n\t\tchan->xfer_dma += len;\n\t\tchan->xfer_len -= len;\n\t}\n}\n\nstatic void dwc2_init_non_isoc_dma_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_qh *qh)\n{\n\tstruct dwc2_qtd *qtd;\n\tstruct dwc2_host_chan *chan = qh->channel;\n\tint n_desc = 0;\n\n\tdev_vdbg(hsotg->dev, \"%s(): qh=%p dma=%08lx len=%d\\n\", __func__, qh,\n\t\t (unsigned long)chan->xfer_dma, chan->xfer_len);\n\n\t \n\n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list_entry) {\n\t\tdev_vdbg(hsotg->dev, \"qtd=%p\\n\", qtd);\n\n\t\tif (n_desc) {\n\t\t\t \n\t\t\tchan->xfer_dma = qtd->urb->dma +\n\t\t\t\t\tqtd->urb->actual_length;\n\t\t\tchan->xfer_len = qtd->urb->length -\n\t\t\t\t\tqtd->urb->actual_length;\n\t\t\tdev_vdbg(hsotg->dev, \"buf=%08lx len=%d\\n\",\n\t\t\t\t (unsigned long)chan->xfer_dma, chan->xfer_len);\n\t\t}\n\n\t\tqtd->n_desc = 0;\n\t\tdo {\n\t\t\tif (n_desc > 1) {\n\t\t\t\tqh->desc_list[n_desc - 1].status |= HOST_DMA_A;\n\t\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t\t \"set A bit in desc %d (%p)\\n\",\n\t\t\t\t\t n_desc - 1,\n\t\t\t\t\t &qh->desc_list[n_desc - 1]);\n\t\t\t\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t\t\t\t   qh->desc_list_dma +\n\t\t\t\t\t((n_desc - 1) *\n\t\t\t\t\tsizeof(struct dwc2_dma_desc)),\n\t\t\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t\t}\n\t\t\tdwc2_fill_host_dma_desc(hsotg, chan, qtd, qh, n_desc);\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"desc %d (%p) buf=%08x status=%08x\\n\",\n\t\t\t\t n_desc, &qh->desc_list[n_desc],\n\t\t\t\t qh->desc_list[n_desc].buf,\n\t\t\t\t qh->desc_list[n_desc].status);\n\t\t\tqtd->n_desc++;\n\t\t\tn_desc++;\n\t\t} while (chan->xfer_len > 0 &&\n\t\t\t n_desc != MAX_DMA_DESC_NUM_GENERIC);\n\n\t\tdev_vdbg(hsotg->dev, \"n_desc=%d\\n\", n_desc);\n\t\tqtd->in_process = 1;\n\t\tif (qh->ep_type == USB_ENDPOINT_XFER_CONTROL)\n\t\t\tbreak;\n\t\tif (n_desc == MAX_DMA_DESC_NUM_GENERIC)\n\t\t\tbreak;\n\t}\n\n\tif (n_desc) {\n\t\tqh->desc_list[n_desc - 1].status |=\n\t\t\t\tHOST_DMA_IOC | HOST_DMA_EOL | HOST_DMA_A;\n\t\tdev_vdbg(hsotg->dev, \"set IOC/EOL/A bits in desc %d (%p)\\n\",\n\t\t\t n_desc - 1, &qh->desc_list[n_desc - 1]);\n\t\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t\t   qh->desc_list_dma + (n_desc - 1) *\n\t\t\t\t\t   sizeof(struct dwc2_dma_desc),\n\t\t\t\t\t   sizeof(struct dwc2_dma_desc),\n\t\t\t\t\t   DMA_TO_DEVICE);\n\t\tif (n_desc > 1) {\n\t\t\tqh->desc_list[0].status |= HOST_DMA_A;\n\t\t\tdev_vdbg(hsotg->dev, \"set A bit in desc 0 (%p)\\n\",\n\t\t\t\t &qh->desc_list[0]);\n\t\t\tdma_sync_single_for_device(hsotg->dev,\n\t\t\t\t\t\t   qh->desc_list_dma,\n\t\t\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\t\t\tDMA_TO_DEVICE);\n\t\t}\n\t\tchan->ntd = n_desc;\n\t}\n}\n\n \nvoid dwc2_hcd_start_xfer_ddma(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\t \n\tstruct dwc2_host_chan *chan = qh->channel;\n\tu16 skip_frames = 0;\n\n\tswitch (chan->ep_type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tdwc2_init_non_isoc_dma_desc(hsotg, qh);\n\t\tdwc2_hc_start_transfer_ddma(hsotg, chan);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tdwc2_init_non_isoc_dma_desc(hsotg, qh);\n\t\tdwc2_update_frame_list(hsotg, qh, 1);\n\t\tdwc2_hc_start_transfer_ddma(hsotg, chan);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (!qh->ntd)\n\t\t\tskip_frames = dwc2_recalc_initial_desc_idx(hsotg, qh);\n\t\tdwc2_init_isoc_dma_desc(hsotg, qh, skip_frames);\n\n\t\tif (!chan->xfer_started) {\n\t\t\tdwc2_update_frame_list(hsotg, qh, 1);\n\n\t\t\t \n\t\t\tchan->ntd = dwc2_max_desc_num(qh);\n\n\t\t\t \n\t\t\tdwc2_hc_start_transfer_ddma(hsotg, chan);\n\t\t}\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n#define DWC2_CMPL_DONE\t\t1\n#define DWC2_CMPL_STOP\t\t2\n\nstatic int dwc2_cmpl_host_isoc_dma_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_host_chan *chan,\n\t\t\t\t\tstruct dwc2_qtd *qtd,\n\t\t\t\t\tstruct dwc2_qh *qh, u16 idx)\n{\n\tstruct dwc2_dma_desc *dma_desc;\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\tu16 remain = 0;\n\tint rc = 0;\n\n\tif (!qtd->urb)\n\t\treturn -EINVAL;\n\n\tdma_sync_single_for_cpu(hsotg->dev, qh->desc_list_dma + (idx *\n\t\t\t\tsizeof(struct dwc2_dma_desc)),\n\t\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tdma_desc = &qh->desc_list[idx];\n\n\tframe_desc = &qtd->urb->iso_descs[qtd->isoc_frame_index_last];\n\tdma_desc->buf = (u32)(qtd->urb->dma + frame_desc->offset);\n\tif (chan->ep_is_in)\n\t\tremain = (dma_desc->status & HOST_DMA_ISOC_NBYTES_MASK) >>\n\t\t\t HOST_DMA_ISOC_NBYTES_SHIFT;\n\n\tif ((dma_desc->status & HOST_DMA_STS_MASK) == HOST_DMA_STS_PKTERR) {\n\t\t \n\t\tqtd->urb->error_count++;\n\t\tframe_desc->actual_length = qh->n_bytes[idx] - remain;\n\t\tframe_desc->status = -EPROTO;\n\t} else {\n\t\t \n\t\tframe_desc->actual_length = qh->n_bytes[idx] - remain;\n\t\tframe_desc->status = 0;\n\t}\n\n\tif (++qtd->isoc_frame_index == qtd->urb->packet_count) {\n\t\t \n\t\tdwc2_host_complete(hsotg, qtd, 0);\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\n\t\t \n\t\tif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE)\n\t\t\treturn -1;\n\t\trc = DWC2_CMPL_DONE;\n\t}\n\n\tqh->ntd--;\n\n\t \n\tif (dma_desc->status & HOST_DMA_IOC)\n\t\trc = DWC2_CMPL_STOP;\n\n\treturn rc;\n}\n\nstatic void dwc2_complete_isoc_xfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t struct dwc2_host_chan *chan,\n\t\t\t\t\t enum dwc2_halt_status halt_status)\n{\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\tstruct dwc2_qtd *qtd, *qtd_tmp;\n\tstruct dwc2_qh *qh;\n\tu16 idx;\n\tint rc;\n\n\tqh = chan->qh;\n\tidx = qh->td_first;\n\n\tif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE) {\n\t\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list_entry)\n\t\t\tqtd->in_process = 0;\n\t\treturn;\n\t}\n\n\tif (halt_status == DWC2_HC_XFER_AHB_ERR ||\n\t    halt_status == DWC2_HC_XFER_BABBLE_ERR) {\n\t\t \n\t\tint err = halt_status == DWC2_HC_XFER_AHB_ERR ?\n\t\t\t  -EIO : -EOVERFLOW;\n\n\t\tlist_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry) {\n\t\t\tif (qtd->urb) {\n\t\t\t\tfor (idx = 0; idx < qtd->urb->packet_count;\n\t\t\t\t     idx++) {\n\t\t\t\t\tframe_desc = &qtd->urb->iso_descs[idx];\n\t\t\t\t\tframe_desc->status = err;\n\t\t\t\t}\n\n\t\t\t\tdwc2_host_complete(hsotg, qtd, err);\n\t\t\t}\n\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list, qtd_list_entry) {\n\t\tif (!qtd->in_process)\n\t\t\tbreak;\n\n\t\t \n\t\tif (idx != qtd->isoc_td_first) {\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"try to complete %d instead of %d\\n\",\n\t\t\t\t idx, qtd->isoc_td_first);\n\t\t\tidx = qtd->isoc_td_first;\n\t\t}\n\n\t\tdo {\n\t\t\tstruct dwc2_qtd *qtd_next;\n\t\t\tu16 cur_idx;\n\n\t\t\trc = dwc2_cmpl_host_isoc_dma_desc(hsotg, chan, qtd, qh,\n\t\t\t\t\t\t\t  idx);\n\t\t\tif (rc < 0)\n\t\t\t\treturn;\n\t\t\tidx = dwc2_desclist_idx_inc(idx, qh->host_interval,\n\t\t\t\t\t\t    chan->speed);\n\t\t\tif (!rc)\n\t\t\t\tcontinue;\n\n\t\t\tif (rc == DWC2_CMPL_DONE)\n\t\t\t\tbreak;\n\n\t\t\t \n\n\t\t\tif (qh->host_interval >= 32)\n\t\t\t\tgoto stop_scan;\n\n\t\t\tqh->td_first = idx;\n\t\t\tcur_idx = dwc2_frame_list_idx(hsotg->frame_number);\n\t\t\tqtd_next = list_first_entry(&qh->qtd_list,\n\t\t\t\t\t\t    struct dwc2_qtd,\n\t\t\t\t\t\t    qtd_list_entry);\n\t\t\tif (dwc2_frame_idx_num_gt(cur_idx,\n\t\t\t\t\t\t  qtd_next->isoc_td_last))\n\t\t\t\tbreak;\n\n\t\t\tgoto stop_scan;\n\n\t\t} while (idx != qh->td_first);\n\t}\n\nstop_scan:\n\tqh->td_first = idx;\n}\n\nstatic int dwc2_update_non_isoc_urb_state_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t       struct dwc2_host_chan *chan,\n\t\t\t\t\tstruct dwc2_qtd *qtd,\n\t\t\t\t\tstruct dwc2_dma_desc *dma_desc,\n\t\t\t\t\tenum dwc2_halt_status halt_status,\n\t\t\t\t\tu32 n_bytes, int *xfer_done)\n{\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tu16 remain = 0;\n\n\tif (chan->ep_is_in)\n\t\tremain = (dma_desc->status & HOST_DMA_NBYTES_MASK) >>\n\t\t\t HOST_DMA_NBYTES_SHIFT;\n\n\tdev_vdbg(hsotg->dev, \"remain=%d dwc2_urb=%p\\n\", remain, urb);\n\n\tif (halt_status == DWC2_HC_XFER_AHB_ERR) {\n\t\tdev_err(hsotg->dev, \"EIO\\n\");\n\t\turb->status = -EIO;\n\t\treturn 1;\n\t}\n\n\tif ((dma_desc->status & HOST_DMA_STS_MASK) == HOST_DMA_STS_PKTERR) {\n\t\tswitch (halt_status) {\n\t\tcase DWC2_HC_XFER_STALL:\n\t\t\tdev_vdbg(hsotg->dev, \"Stall\\n\");\n\t\t\turb->status = -EPIPE;\n\t\t\tbreak;\n\t\tcase DWC2_HC_XFER_BABBLE_ERR:\n\t\t\tdev_err(hsotg->dev, \"Babble\\n\");\n\t\t\turb->status = -EOVERFLOW;\n\t\t\tbreak;\n\t\tcase DWC2_HC_XFER_XACT_ERR:\n\t\t\tdev_err(hsotg->dev, \"XactErr\\n\");\n\t\t\turb->status = -EPROTO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: Unhandled descriptor error status (%d)\\n\",\n\t\t\t\t__func__, halt_status);\n\t\t\tbreak;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif (dma_desc->status & HOST_DMA_A) {\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"Active descriptor encountered on channel %d\\n\",\n\t\t\t chan->hc_num);\n\t\treturn 0;\n\t}\n\n\tif (chan->ep_type == USB_ENDPOINT_XFER_CONTROL) {\n\t\tif (qtd->control_phase == DWC2_CONTROL_DATA) {\n\t\t\turb->actual_length += n_bytes - remain;\n\t\t\tif (remain || urb->actual_length >= urb->length) {\n\t\t\t\t \n\t\t\t\t*xfer_done = 1;\n\t\t\t}\n\t\t} else if (qtd->control_phase == DWC2_CONTROL_STATUS) {\n\t\t\turb->status = 0;\n\t\t\t*xfer_done = 1;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\turb->actual_length += n_bytes - remain;\n\t\tdev_vdbg(hsotg->dev, \"length=%d actual=%d\\n\", urb->length,\n\t\t\t urb->actual_length);\n\t\tif (remain || urb->actual_length >= urb->length) {\n\t\t\turb->status = 0;\n\t\t\t*xfer_done = 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc2_process_non_isoc_desc(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_host_chan *chan,\n\t\t\t\t      int chnum, struct dwc2_qtd *qtd,\n\t\t\t\t      int desc_num,\n\t\t\t\t      enum dwc2_halt_status halt_status,\n\t\t\t\t      int *xfer_done)\n{\n\tstruct dwc2_qh *qh = chan->qh;\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tstruct dwc2_dma_desc *dma_desc;\n\tu32 n_bytes;\n\tint failed;\n\n\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tif (!urb)\n\t\treturn -EINVAL;\n\n\tdma_sync_single_for_cpu(hsotg->dev,\n\t\t\t\tqh->desc_list_dma + (desc_num *\n\t\t\t\tsizeof(struct dwc2_dma_desc)),\n\t\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\t\tDMA_FROM_DEVICE);\n\n\tdma_desc = &qh->desc_list[desc_num];\n\tn_bytes = qh->n_bytes[desc_num];\n\tdev_vdbg(hsotg->dev,\n\t\t \"qtd=%p dwc2_urb=%p desc_num=%d desc=%p n_bytes=%d\\n\",\n\t\t qtd, urb, desc_num, dma_desc, n_bytes);\n\tfailed = dwc2_update_non_isoc_urb_state_ddma(hsotg, chan, qtd, dma_desc,\n\t\t\t\t\t\t     halt_status, n_bytes,\n\t\t\t\t\t\t     xfer_done);\n\tif (failed || (*xfer_done && urb->status != -EINPROGRESS)) {\n\t\tdwc2_host_complete(hsotg, qtd, urb->status);\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\t\tdev_vdbg(hsotg->dev, \"failed=%1x xfer_done=%1x\\n\",\n\t\t\t failed, *xfer_done);\n\t\treturn failed;\n\t}\n\n\tif (qh->ep_type == USB_ENDPOINT_XFER_CONTROL) {\n\t\tswitch (qtd->control_phase) {\n\t\tcase DWC2_CONTROL_SETUP:\n\t\t\tif (urb->length > 0)\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_DATA;\n\t\t\telse\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_STATUS;\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"  Control setup transaction done\\n\");\n\t\t\tbreak;\n\t\tcase DWC2_CONTROL_DATA:\n\t\t\tif (*xfer_done) {\n\t\t\t\tqtd->control_phase = DWC2_CONTROL_STATUS;\n\t\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t\t \"  Control data transfer done\\n\");\n\t\t\t} else if (desc_num + 1 == qtd->n_desc) {\n\t\t\t\t \n\t\t\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum,\n\t\t\t\t\t\t\t  qtd);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void dwc2_complete_non_isoc_xfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t     struct dwc2_host_chan *chan,\n\t\t\t\t\t     int chnum,\n\t\t\t\t\t     enum dwc2_halt_status halt_status)\n{\n\tstruct list_head *qtd_item, *qtd_tmp;\n\tstruct dwc2_qh *qh = chan->qh;\n\tstruct dwc2_qtd *qtd = NULL;\n\tint xfer_done;\n\tint desc_num = 0;\n\n\tif (chan->halt_status == DWC2_HC_XFER_URB_DEQUEUE) {\n\t\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list_entry)\n\t\t\tqtd->in_process = 0;\n\t\treturn;\n\t}\n\n\tlist_for_each_safe(qtd_item, qtd_tmp, &qh->qtd_list) {\n\t\tint i;\n\t\tint qtd_desc_count;\n\n\t\tqtd = list_entry(qtd_item, struct dwc2_qtd, qtd_list_entry);\n\t\txfer_done = 0;\n\t\tqtd_desc_count = qtd->n_desc;\n\n\t\tfor (i = 0; i < qtd_desc_count; i++) {\n\t\t\tif (dwc2_process_non_isoc_desc(hsotg, chan, chnum, qtd,\n\t\t\t\t\t\t       desc_num, halt_status,\n\t\t\t\t\t\t       &xfer_done)) {\n\t\t\t\tqtd = NULL;\n\t\t\t\tgoto stop_scan;\n\t\t\t}\n\n\t\t\tdesc_num++;\n\t\t}\n\t}\n\nstop_scan:\n\tif (qh->ep_type != USB_ENDPOINT_XFER_CONTROL) {\n\t\t \n\t\tif (halt_status == DWC2_HC_XFER_STALL)\n\t\t\tqh->data_toggle = DWC2_HC_PID_DATA0;\n\t\telse\n\t\t\tdwc2_hcd_save_data_toggle(hsotg, chan, chnum, NULL);\n\t}\n\n\tif (halt_status == DWC2_HC_XFER_COMPLETE) {\n\t\tif (chan->hcint & HCINTMSK_NYET) {\n\t\t\t \n\t\t\tqh->ping_state = 1;\n\t\t}\n\t}\n}\n\n \nvoid dwc2_hcd_complete_xfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t enum dwc2_halt_status halt_status)\n{\n\tstruct dwc2_qh *qh = chan->qh;\n\tint continue_isoc_xfer = 0;\n\tenum dwc2_transaction_type tr_type;\n\n\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\tdwc2_complete_isoc_xfer_ddma(hsotg, chan, halt_status);\n\n\t\t \n\t\tif (halt_status != DWC2_HC_XFER_COMPLETE ||\n\t\t    list_empty(&qh->qtd_list)) {\n\t\t\tstruct dwc2_qtd *qtd, *qtd_tmp;\n\n\t\t\t \n\t\t\tlist_for_each_entry_safe(qtd, qtd_tmp,\n\t\t\t\t\t\t &qh->qtd_list,\n\t\t\t\t\t\t qtd_list_entry) {\n\t\t\t\tdwc2_host_complete(hsotg, qtd,\n\t\t\t\t\t\t   -ECONNRESET);\n\t\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg,\n\t\t\t\t\t\t\t     qtd, qh);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (halt_status == DWC2_HC_XFER_COMPLETE)\n\t\t\t\tdwc2_hc_halt(hsotg, chan, halt_status);\n\t\t\tdwc2_release_channel_ddma(hsotg, qh);\n\t\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t} else {\n\t\t\t \n\t\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t\t       &hsotg->periodic_sched_assigned);\n\t\t\t \n\t\t\tif (!chan->halt_status)\n\t\t\t\tcontinue_isoc_xfer = 1;\n\t\t}\n\t\t \n\t} else {\n\t\t \n\t\tdwc2_complete_non_isoc_xfer_ddma(hsotg, chan, chnum,\n\t\t\t\t\t\t halt_status);\n\t\tdwc2_release_channel_ddma(hsotg, qh);\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\t \n\t\t\tdwc2_hcd_qh_add(hsotg, qh);\n\t\t}\n\t}\n\n\ttr_type = dwc2_hcd_select_transactions(hsotg);\n\tif (tr_type != DWC2_TRANSACTION_NONE || continue_isoc_xfer) {\n\t\tif (continue_isoc_xfer) {\n\t\t\tif (tr_type == DWC2_TRANSACTION_NONE)\n\t\t\t\ttr_type = DWC2_TRANSACTION_PERIODIC;\n\t\t\telse if (tr_type == DWC2_TRANSACTION_NON_PERIODIC)\n\t\t\t\ttr_type = DWC2_TRANSACTION_ALL;\n\t\t}\n\t\tdwc2_hcd_queue_transactions(hsotg, tr_type);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}