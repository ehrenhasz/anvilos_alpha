{
  "module_name": "params.c",
  "hash_id": "b13e27ab0e73df683835ae1074d2deab4389c8ed3dd49aedb4ccad2834230d30",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/params.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_device.h>\n#include <linux/usb/of.h>\n#include <linux/pci_ids.h>\n#include <linux/pci.h>\n\n#include \"core.h\"\n\n#define PCI_PRODUCT_ID_HAPS_HSOTG\t0xabc0\n#define PCI_DEVICE_ID_LOONGSON_DWC2\t0x7a04\n\nstatic void dwc2_set_bcm_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->host_rx_fifo_size = 774;\n\tp->max_transfer_size = 65535;\n\tp->max_packet_count = 511;\n\tp->ahbcfg = 0x10;\n}\n\nstatic void dwc2_set_his_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->host_rx_fifo_size = 512;\n\tp->host_nperio_tx_fifo_size = 512;\n\tp->host_perio_tx_fifo_size = 512;\n\tp->max_transfer_size = 65535;\n\tp->max_packet_count = 511;\n\tp->host_channels = 16;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->phy_utmi_width = 8;\n\tp->i2c_enable = false;\n\tp->reload_ctl = false;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<\n\t\tGAHBCFG_HBSTLEN_SHIFT;\n\tp->change_speed_quirk = true;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n}\n\nstatic void dwc2_set_jz4775_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->phy_utmi_width = 16;\n\tp->activate_ingenic_overcurrent_detection =\n\t\t!device_property_read_bool(hsotg->dev, \"disable-over-current\");\n}\n\nstatic void dwc2_set_loongson_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->phy_utmi_width = 8;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_PARTIAL;\n}\n\nstatic void dwc2_set_x1600_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->host_channels = 16;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->phy_utmi_width = 16;\n\tp->activate_ingenic_overcurrent_detection =\n\t\t!device_property_read_bool(hsotg->dev, \"disable-over-current\");\n}\n\nstatic void dwc2_set_x2000_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->host_rx_fifo_size = 1024;\n\tp->host_nperio_tx_fifo_size = 1024;\n\tp->host_perio_tx_fifo_size = 1024;\n\tp->host_channels = 16;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->phy_utmi_width = 16;\n\tp->activate_ingenic_overcurrent_detection =\n\t\t!device_property_read_bool(hsotg->dev, \"disable-over-current\");\n}\n\nstatic void dwc2_set_s3c6400_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n\tp->no_clock_gating = true;\n\tp->phy_utmi_width = 8;\n}\n\nstatic void dwc2_set_socfpga_agilex_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n\tp->no_clock_gating = true;\n}\n\nstatic void dwc2_set_rk_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->host_rx_fifo_size = 525;\n\tp->host_nperio_tx_fifo_size = 128;\n\tp->host_perio_tx_fifo_size = 256;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<\n\t\tGAHBCFG_HBSTLEN_SHIFT;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n\tp->lpm = false;\n\tp->lpm_clock_gating = false;\n\tp->besl = false;\n\tp->hird_threshold_en = false;\n}\n\nstatic void dwc2_set_ltq_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->host_rx_fifo_size = 288;\n\tp->host_nperio_tx_fifo_size = 128;\n\tp->host_perio_tx_fifo_size = 96;\n\tp->max_transfer_size = 65535;\n\tp->max_packet_count = 511;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 <<\n\t\tGAHBCFG_HBSTLEN_SHIFT;\n}\n\nstatic void dwc2_set_amlogic_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->host_rx_fifo_size = 512;\n\tp->host_nperio_tx_fifo_size = 500;\n\tp->host_perio_tx_fifo_size = 500;\n\tp->host_channels = 16;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR8 <<\n\t\tGAHBCFG_HBSTLEN_SHIFT;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n}\n\nstatic void dwc2_set_amlogic_g12a_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->lpm = false;\n\tp->lpm_clock_gating = false;\n\tp->besl = false;\n\tp->hird_threshold_en = false;\n}\n\nstatic void dwc2_set_amlogic_a1_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_HIGH;\n\tp->host_rx_fifo_size = 192;\n\tp->host_nperio_tx_fifo_size = 128;\n\tp->host_perio_tx_fifo_size = 128;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_UTMI;\n\tp->phy_utmi_width = 8;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR8 << GAHBCFG_HBSTLEN_SHIFT;\n\tp->lpm = false;\n\tp->lpm_clock_gating = false;\n\tp->besl = false;\n\tp->hird_threshold_en = false;\n}\n\nstatic void dwc2_set_amcc_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;\n}\n\nstatic void dwc2_set_stm32f4x9_fsotg_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->speed = DWC2_SPEED_PARAM_FULL;\n\tp->host_rx_fifo_size = 128;\n\tp->host_nperio_tx_fifo_size = 96;\n\tp->host_perio_tx_fifo_size = 96;\n\tp->max_packet_count = 256;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_FS;\n\tp->i2c_enable = false;\n\tp->activate_stm_fs_transceiver = true;\n}\n\nstatic void dwc2_set_stm32f7_hsotg_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->host_rx_fifo_size = 622;\n\tp->host_nperio_tx_fifo_size = 128;\n\tp->host_perio_tx_fifo_size = 256;\n}\n\nstatic void dwc2_set_stm32mp15_fsotg_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->otg_caps.otg_rev = 0x200;\n\tp->speed = DWC2_SPEED_PARAM_FULL;\n\tp->host_rx_fifo_size = 128;\n\tp->host_nperio_tx_fifo_size = 96;\n\tp->host_perio_tx_fifo_size = 96;\n\tp->max_packet_count = 256;\n\tp->phy_type = DWC2_PHY_TYPE_PARAM_FS;\n\tp->i2c_enable = false;\n\tp->activate_stm_fs_transceiver = true;\n\tp->activate_stm_id_vb_detection = true;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n\tp->host_support_fs_ls_low_power = true;\n\tp->host_ls_low_power_phy_clk = true;\n}\n\nstatic void dwc2_set_stm32mp15_hsotg_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->otg_caps.hnp_support = false;\n\tp->otg_caps.srp_support = false;\n\tp->otg_caps.otg_rev = 0x200;\n\tp->activate_stm_id_vb_detection = !device_property_read_bool(hsotg->dev, \"usb-role-switch\");\n\tp->host_rx_fifo_size = 440;\n\tp->host_nperio_tx_fifo_size = 256;\n\tp->host_perio_tx_fifo_size = 256;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR16 << GAHBCFG_HBSTLEN_SHIFT;\n\tp->power_down = DWC2_POWER_DOWN_PARAM_NONE;\n\tp->lpm = false;\n\tp->lpm_clock_gating = false;\n\tp->besl = false;\n\tp->hird_threshold_en = false;\n}\n\nconst struct of_device_id dwc2_of_match_table[] = {\n\t{ .compatible = \"brcm,bcm2835-usb\", .data = dwc2_set_bcm_params },\n\t{ .compatible = \"hisilicon,hi6220-usb\", .data = dwc2_set_his_params },\n\t{ .compatible = \"ingenic,jz4775-otg\", .data = dwc2_set_jz4775_params },\n\t{ .compatible = \"ingenic,jz4780-otg\", .data = dwc2_set_jz4775_params },\n\t{ .compatible = \"ingenic,x1000-otg\", .data = dwc2_set_jz4775_params },\n\t{ .compatible = \"ingenic,x1600-otg\", .data = dwc2_set_x1600_params },\n\t{ .compatible = \"ingenic,x1700-otg\", .data = dwc2_set_x1600_params },\n\t{ .compatible = \"ingenic,x1830-otg\", .data = dwc2_set_x1600_params },\n\t{ .compatible = \"ingenic,x2000-otg\", .data = dwc2_set_x2000_params },\n\t{ .compatible = \"rockchip,rk3066-usb\", .data = dwc2_set_rk_params },\n\t{ .compatible = \"lantiq,arx100-usb\", .data = dwc2_set_ltq_params },\n\t{ .compatible = \"lantiq,xrx200-usb\", .data = dwc2_set_ltq_params },\n\t{ .compatible = \"snps,dwc2\" },\n\t{ .compatible = \"samsung,s3c6400-hsotg\",\n\t  .data = dwc2_set_s3c6400_params },\n\t{ .compatible = \"amlogic,meson8-usb\",\n\t  .data = dwc2_set_amlogic_params },\n\t{ .compatible = \"amlogic,meson8b-usb\",\n\t  .data = dwc2_set_amlogic_params },\n\t{ .compatible = \"amlogic,meson-gxbb-usb\",\n\t  .data = dwc2_set_amlogic_params },\n\t{ .compatible = \"amlogic,meson-g12a-usb\",\n\t  .data = dwc2_set_amlogic_g12a_params },\n\t{ .compatible = \"amlogic,meson-a1-usb\",\n\t  .data = dwc2_set_amlogic_a1_params },\n\t{ .compatible = \"amcc,dwc-otg\", .data = dwc2_set_amcc_params },\n\t{ .compatible = \"apm,apm82181-dwc-otg\", .data = dwc2_set_amcc_params },\n\t{ .compatible = \"st,stm32f4x9-fsotg\",\n\t  .data = dwc2_set_stm32f4x9_fsotg_params },\n\t{ .compatible = \"st,stm32f4x9-hsotg\" },\n\t{ .compatible = \"st,stm32f7-hsotg\",\n\t  .data = dwc2_set_stm32f7_hsotg_params },\n\t{ .compatible = \"st,stm32mp15-fsotg\",\n\t  .data = dwc2_set_stm32mp15_fsotg_params },\n\t{ .compatible = \"st,stm32mp15-hsotg\",\n\t  .data = dwc2_set_stm32mp15_hsotg_params },\n\t{ .compatible = \"intel,socfpga-agilex-hsotg\",\n\t  .data = dwc2_set_socfpga_agilex_params },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, dwc2_of_match_table);\n\nconst struct acpi_device_id dwc2_acpi_match[] = {\n\t{ \"BCM2848\", (kernel_ulong_t)dwc2_set_bcm_params },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, dwc2_acpi_match);\n\nconst struct pci_device_id dwc2_pci_ids[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_SYNOPSYS, PCI_PRODUCT_ID_HAPS_HSOTG),\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_STMICRO,\n\t\t\t   PCI_DEVICE_ID_STMICRO_USB_OTG),\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_LOONGSON, PCI_DEVICE_ID_LOONGSON_DWC2),\n\t\t.driver_data = (unsigned long)dwc2_set_loongson_params,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(pci, dwc2_pci_ids);\nEXPORT_SYMBOL_GPL(dwc2_pci_ids);\n\nstatic void dwc2_set_param_otg_cap(struct dwc2_hsotg *hsotg)\n{\n\tswitch (hsotg->hw_params.op_mode) {\n\tcase GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:\n\t\thsotg->params.otg_caps.hnp_support = true;\n\t\thsotg->params.otg_caps.srp_support = true;\n\t\tbreak;\n\tcase GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:\n\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:\n\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:\n\t\thsotg->params.otg_caps.hnp_support = false;\n\t\thsotg->params.otg_caps.srp_support = true;\n\t\tbreak;\n\tdefault:\n\t\thsotg->params.otg_caps.hnp_support = false;\n\t\thsotg->params.otg_caps.srp_support = false;\n\t\tbreak;\n\t}\n}\n\nstatic void dwc2_set_param_phy_type(struct dwc2_hsotg *hsotg)\n{\n\tint val;\n\tu32 hs_phy_type = hsotg->hw_params.hs_phy_type;\n\n\tval = DWC2_PHY_TYPE_PARAM_FS;\n\tif (hs_phy_type != GHWCFG2_HS_PHY_TYPE_NOT_SUPPORTED) {\n\t\tif (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI ||\n\t\t    hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI)\n\t\t\tval = DWC2_PHY_TYPE_PARAM_UTMI;\n\t\telse\n\t\t\tval = DWC2_PHY_TYPE_PARAM_ULPI;\n\t}\n\n\tif (dwc2_is_fs_iot(hsotg))\n\t\thsotg->params.phy_type = DWC2_PHY_TYPE_PARAM_FS;\n\n\thsotg->params.phy_type = val;\n}\n\nstatic void dwc2_set_param_speed(struct dwc2_hsotg *hsotg)\n{\n\tint val;\n\n\tval = hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS ?\n\t\tDWC2_SPEED_PARAM_FULL : DWC2_SPEED_PARAM_HIGH;\n\n\tif (dwc2_is_fs_iot(hsotg))\n\t\tval = DWC2_SPEED_PARAM_FULL;\n\n\tif (dwc2_is_hs_iot(hsotg))\n\t\tval = DWC2_SPEED_PARAM_HIGH;\n\n\thsotg->params.speed = val;\n}\n\nstatic void dwc2_set_param_phy_utmi_width(struct dwc2_hsotg *hsotg)\n{\n\tint val;\n\n\tval = (hsotg->hw_params.utmi_phy_data_width ==\n\t       GHWCFG4_UTMI_PHY_DATA_WIDTH_8) ? 8 : 16;\n\n\tif (hsotg->phy) {\n\t\t \n\t\tif (phy_get_bus_width(hsotg->phy) == 8)\n\t\t\tval = 8;\n\t}\n\n\thsotg->params.phy_utmi_width = val;\n}\n\nstatic void dwc2_set_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\tint depth_average;\n\tint fifo_count;\n\tint i;\n\n\tfifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\n\n\tmemset(p->g_tx_fifo_size, 0, sizeof(p->g_tx_fifo_size));\n\tdepth_average = dwc2_hsotg_tx_fifo_average_depth(hsotg);\n\tfor (i = 1; i <= fifo_count; i++)\n\t\tp->g_tx_fifo_size[i] = depth_average;\n}\n\nstatic void dwc2_set_param_power_down(struct dwc2_hsotg *hsotg)\n{\n\tint val;\n\n\tif (hsotg->hw_params.hibernation)\n\t\tval = DWC2_POWER_DOWN_PARAM_HIBERNATION;\n\telse if (hsotg->hw_params.power_optimized)\n\t\tval = DWC2_POWER_DOWN_PARAM_PARTIAL;\n\telse\n\t\tval = DWC2_POWER_DOWN_PARAM_NONE;\n\n\thsotg->params.power_down = val;\n}\n\nstatic void dwc2_set_param_lpm(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\n\tp->lpm = hsotg->hw_params.lpm_mode;\n\tif (p->lpm) {\n\t\tp->lpm_clock_gating = true;\n\t\tp->besl = true;\n\t\tp->hird_threshold_en = true;\n\t\tp->hird_threshold = 4;\n\t} else {\n\t\tp->lpm_clock_gating = false;\n\t\tp->besl = false;\n\t\tp->hird_threshold_en = false;\n\t}\n}\n\n \nstatic void dwc2_set_default_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tstruct dwc2_core_params *p = &hsotg->params;\n\tbool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);\n\n\tdwc2_set_param_otg_cap(hsotg);\n\tdwc2_set_param_phy_type(hsotg);\n\tdwc2_set_param_speed(hsotg);\n\tdwc2_set_param_phy_utmi_width(hsotg);\n\tdwc2_set_param_power_down(hsotg);\n\tdwc2_set_param_lpm(hsotg);\n\tp->phy_ulpi_ddr = false;\n\tp->phy_ulpi_ext_vbus = false;\n\n\tp->enable_dynamic_fifo = hw->enable_dynamic_fifo;\n\tp->en_multiple_tx_fifo = hw->en_multiple_tx_fifo;\n\tp->i2c_enable = hw->i2c_enable;\n\tp->acg_enable = hw->acg_enable;\n\tp->ulpi_fs_ls = false;\n\tp->ts_dline = false;\n\tp->reload_ctl = (hw->snpsid >= DWC2_CORE_REV_2_92a);\n\tp->uframe_sched = true;\n\tp->external_id_pin_ctl = false;\n\tp->ipg_isoc_en = false;\n\tp->service_interval = false;\n\tp->max_packet_count = hw->max_packet_count;\n\tp->max_transfer_size = hw->max_transfer_size;\n\tp->ahbcfg = GAHBCFG_HBSTLEN_INCR << GAHBCFG_HBSTLEN_SHIFT;\n\tp->ref_clk_per = 33333;\n\tp->sof_cnt_wkup_alert = 100;\n\n\tif ((hsotg->dr_mode == USB_DR_MODE_HOST) ||\n\t    (hsotg->dr_mode == USB_DR_MODE_OTG)) {\n\t\tp->host_dma = dma_capable;\n\t\tp->dma_desc_enable = false;\n\t\tp->dma_desc_fs_enable = false;\n\t\tp->host_support_fs_ls_low_power = false;\n\t\tp->host_ls_low_power_phy_clk = false;\n\t\tp->host_channels = hw->host_channels;\n\t\tp->host_rx_fifo_size = hw->rx_fifo_size;\n\t\tp->host_nperio_tx_fifo_size = hw->host_nperio_tx_fifo_size;\n\t\tp->host_perio_tx_fifo_size = hw->host_perio_tx_fifo_size;\n\t}\n\n\tif ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||\n\t    (hsotg->dr_mode == USB_DR_MODE_OTG)) {\n\t\tp->g_dma = dma_capable;\n\t\tp->g_dma_desc = hw->dma_desc_enable;\n\n\t\t \n\t\tp->g_rx_fifo_size = 2048;\n\t\tp->g_np_tx_fifo_size = 1024;\n\t\tdwc2_set_param_tx_fifo_sizes(hsotg);\n\t}\n}\n\n \nstatic void dwc2_get_device_properties(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *p = &hsotg->params;\n\tint num;\n\n\tif ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||\n\t    (hsotg->dr_mode == USB_DR_MODE_OTG)) {\n\t\tdevice_property_read_u32(hsotg->dev, \"g-rx-fifo-size\",\n\t\t\t\t\t &p->g_rx_fifo_size);\n\n\t\tdevice_property_read_u32(hsotg->dev, \"g-np-tx-fifo-size\",\n\t\t\t\t\t &p->g_np_tx_fifo_size);\n\n\t\tnum = device_property_count_u32(hsotg->dev, \"g-tx-fifo-size\");\n\t\tif (num > 0) {\n\t\t\tnum = min(num, 15);\n\t\t\tmemset(p->g_tx_fifo_size, 0,\n\t\t\t       sizeof(p->g_tx_fifo_size));\n\t\t\tdevice_property_read_u32_array(hsotg->dev,\n\t\t\t\t\t\t       \"g-tx-fifo-size\",\n\t\t\t\t\t\t       &p->g_tx_fifo_size[1],\n\t\t\t\t\t\t       num);\n\t\t}\n\n\t\tof_usb_update_otg_caps(hsotg->dev->of_node, &p->otg_caps);\n\t}\n\n\tp->oc_disable = of_property_read_bool(hsotg->dev->of_node, \"disable-over-current\");\n}\n\nstatic void dwc2_check_param_otg_cap(struct dwc2_hsotg *hsotg)\n{\n\tint valid = 1;\n\n\tif (hsotg->params.otg_caps.hnp_support && hsotg->params.otg_caps.srp_support) {\n\t\t \n\t\tif (hsotg->hw_params.op_mode != GHWCFG2_OP_MODE_HNP_SRP_CAPABLE)\n\t\t\tvalid = 0;\n\t} else if (!hsotg->params.otg_caps.hnp_support) {\n\t\t \n\t\tif (hsotg->params.otg_caps.srp_support) {\n\t\t\tswitch (hsotg->hw_params.op_mode) {\n\t\t\tcase GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:\n\t\t\tcase GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:\n\t\t\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:\n\t\t\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tvalid = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t} else {\n\t\tvalid = 0;\n\t}\n\n\tif (!valid)\n\t\tdwc2_set_param_otg_cap(hsotg);\n}\n\nstatic void dwc2_check_param_phy_type(struct dwc2_hsotg *hsotg)\n{\n\tint valid = 0;\n\tu32 hs_phy_type;\n\tu32 fs_phy_type;\n\n\ths_phy_type = hsotg->hw_params.hs_phy_type;\n\tfs_phy_type = hsotg->hw_params.fs_phy_type;\n\n\tswitch (hsotg->params.phy_type) {\n\tcase DWC2_PHY_TYPE_PARAM_FS:\n\t\tif (fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED)\n\t\t\tvalid = 1;\n\t\tbreak;\n\tcase DWC2_PHY_TYPE_PARAM_UTMI:\n\t\tif ((hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI) ||\n\t\t    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))\n\t\t\tvalid = 1;\n\t\tbreak;\n\tcase DWC2_PHY_TYPE_PARAM_ULPI:\n\t\tif ((hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI) ||\n\t\t    (hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI_ULPI))\n\t\t\tvalid = 1;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (!valid)\n\t\tdwc2_set_param_phy_type(hsotg);\n}\n\nstatic void dwc2_check_param_speed(struct dwc2_hsotg *hsotg)\n{\n\tint valid = 1;\n\tint phy_type = hsotg->params.phy_type;\n\tint speed = hsotg->params.speed;\n\n\tswitch (speed) {\n\tcase DWC2_SPEED_PARAM_HIGH:\n\t\tif ((hsotg->params.speed == DWC2_SPEED_PARAM_HIGH) &&\n\t\t    (phy_type == DWC2_PHY_TYPE_PARAM_FS))\n\t\t\tvalid = 0;\n\t\tbreak;\n\tcase DWC2_SPEED_PARAM_FULL:\n\tcase DWC2_SPEED_PARAM_LOW:\n\t\tbreak;\n\tdefault:\n\t\tvalid = 0;\n\t\tbreak;\n\t}\n\n\tif (!valid)\n\t\tdwc2_set_param_speed(hsotg);\n}\n\nstatic void dwc2_check_param_phy_utmi_width(struct dwc2_hsotg *hsotg)\n{\n\tint valid = 0;\n\tint param = hsotg->params.phy_utmi_width;\n\tint width = hsotg->hw_params.utmi_phy_data_width;\n\n\tswitch (width) {\n\tcase GHWCFG4_UTMI_PHY_DATA_WIDTH_8:\n\t\tvalid = (param == 8);\n\t\tbreak;\n\tcase GHWCFG4_UTMI_PHY_DATA_WIDTH_16:\n\t\tvalid = (param == 16);\n\t\tbreak;\n\tcase GHWCFG4_UTMI_PHY_DATA_WIDTH_8_OR_16:\n\t\tvalid = (param == 8 || param == 16);\n\t\tbreak;\n\t}\n\n\tif (!valid)\n\t\tdwc2_set_param_phy_utmi_width(hsotg);\n}\n\nstatic void dwc2_check_param_power_down(struct dwc2_hsotg *hsotg)\n{\n\tint param = hsotg->params.power_down;\n\n\tswitch (param) {\n\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\tif (hsotg->hw_params.power_optimized)\n\t\t\tbreak;\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"Partial power down isn't supported by HW\\n\");\n\t\tparam = DWC2_POWER_DOWN_PARAM_NONE;\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\tif (hsotg->hw_params.hibernation)\n\t\t\tbreak;\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"Hibernation isn't supported by HW\\n\");\n\t\tparam = DWC2_POWER_DOWN_PARAM_NONE;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: Invalid parameter power_down=%d\\n\",\n\t\t\t__func__, param);\n\t\tparam = DWC2_POWER_DOWN_PARAM_NONE;\n\t\tbreak;\n\t}\n\n\thsotg->params.power_down = param;\n}\n\nstatic void dwc2_check_param_tx_fifo_sizes(struct dwc2_hsotg *hsotg)\n{\n\tint fifo_count;\n\tint fifo;\n\tint min;\n\tu32 total = 0;\n\tu32 dptxfszn;\n\n\tfifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\n\tmin = hsotg->hw_params.en_multiple_tx_fifo ? 16 : 4;\n\n\tfor (fifo = 1; fifo <= fifo_count; fifo++)\n\t\ttotal += hsotg->params.g_tx_fifo_size[fifo];\n\n\tif (total > dwc2_hsotg_tx_fifo_total_depth(hsotg) || !total) {\n\t\tdev_warn(hsotg->dev, \"%s: Invalid parameter g-tx-fifo-size, setting to default average\\n\",\n\t\t\t __func__);\n\t\tdwc2_set_param_tx_fifo_sizes(hsotg);\n\t}\n\n\tfor (fifo = 1; fifo <= fifo_count; fifo++) {\n\t\tdptxfszn = hsotg->hw_params.g_tx_fifo_size[fifo];\n\n\t\tif (hsotg->params.g_tx_fifo_size[fifo] < min ||\n\t\t    hsotg->params.g_tx_fifo_size[fifo] >  dptxfszn) {\n\t\t\tdev_warn(hsotg->dev, \"%s: Invalid parameter g_tx_fifo_size[%d]=%d\\n\",\n\t\t\t\t __func__, fifo,\n\t\t\t\t hsotg->params.g_tx_fifo_size[fifo]);\n\t\t\thsotg->params.g_tx_fifo_size[fifo] = dptxfszn;\n\t\t}\n\t}\n}\n\n#define CHECK_RANGE(_param, _min, _max, _def) do {\t\t\t\\\n\t\tif ((int)(hsotg->params._param) < (_min) ||\t\t\\\n\t\t    (hsotg->params._param) > (_max)) {\t\t\t\\\n\t\t\tdev_warn(hsotg->dev, \"%s: Invalid parameter %s=%d\\n\", \\\n\t\t\t\t __func__, #_param, hsotg->params._param); \\\n\t\t\thsotg->params._param = (_def);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n#define CHECK_BOOL(_param, _check) do {\t\t\t\t\t\\\n\t\tif (hsotg->params._param && !(_check)) {\t\t\\\n\t\t\tdev_warn(hsotg->dev, \"%s: Invalid parameter %s=%d\\n\", \\\n\t\t\t\t __func__, #_param, hsotg->params._param); \\\n\t\t\thsotg->params._param = false;\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void dwc2_check_params(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tstruct dwc2_core_params *p = &hsotg->params;\n\tbool dma_capable = !(hw->arch == GHWCFG2_SLAVE_ONLY_ARCH);\n\n\tdwc2_check_param_otg_cap(hsotg);\n\tdwc2_check_param_phy_type(hsotg);\n\tdwc2_check_param_speed(hsotg);\n\tdwc2_check_param_phy_utmi_width(hsotg);\n\tdwc2_check_param_power_down(hsotg);\n\tCHECK_BOOL(enable_dynamic_fifo, hw->enable_dynamic_fifo);\n\tCHECK_BOOL(en_multiple_tx_fifo, hw->en_multiple_tx_fifo);\n\tCHECK_BOOL(i2c_enable, hw->i2c_enable);\n\tCHECK_BOOL(ipg_isoc_en, hw->ipg_isoc_en);\n\tCHECK_BOOL(acg_enable, hw->acg_enable);\n\tCHECK_BOOL(reload_ctl, (hsotg->hw_params.snpsid > DWC2_CORE_REV_2_92a));\n\tCHECK_BOOL(lpm, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_80a));\n\tCHECK_BOOL(lpm, hw->lpm_mode);\n\tCHECK_BOOL(lpm_clock_gating, hsotg->params.lpm);\n\tCHECK_BOOL(besl, hsotg->params.lpm);\n\tCHECK_BOOL(besl, (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a));\n\tCHECK_BOOL(hird_threshold_en, hsotg->params.lpm);\n\tCHECK_RANGE(hird_threshold, 0, hsotg->params.besl ? 12 : 7, 0);\n\tCHECK_BOOL(service_interval, hw->service_interval_mode);\n\tCHECK_RANGE(max_packet_count,\n\t\t    15, hw->max_packet_count,\n\t\t    hw->max_packet_count);\n\tCHECK_RANGE(max_transfer_size,\n\t\t    2047, hw->max_transfer_size,\n\t\t    hw->max_transfer_size);\n\n\tif ((hsotg->dr_mode == USB_DR_MODE_HOST) ||\n\t    (hsotg->dr_mode == USB_DR_MODE_OTG)) {\n\t\tCHECK_BOOL(host_dma, dma_capable);\n\t\tCHECK_BOOL(dma_desc_enable, p->host_dma);\n\t\tCHECK_BOOL(dma_desc_fs_enable, p->dma_desc_enable);\n\t\tCHECK_BOOL(host_ls_low_power_phy_clk,\n\t\t\t   p->phy_type == DWC2_PHY_TYPE_PARAM_FS);\n\t\tCHECK_RANGE(host_channels,\n\t\t\t    1, hw->host_channels,\n\t\t\t    hw->host_channels);\n\t\tCHECK_RANGE(host_rx_fifo_size,\n\t\t\t    16, hw->rx_fifo_size,\n\t\t\t    hw->rx_fifo_size);\n\t\tCHECK_RANGE(host_nperio_tx_fifo_size,\n\t\t\t    16, hw->host_nperio_tx_fifo_size,\n\t\t\t    hw->host_nperio_tx_fifo_size);\n\t\tCHECK_RANGE(host_perio_tx_fifo_size,\n\t\t\t    16, hw->host_perio_tx_fifo_size,\n\t\t\t    hw->host_perio_tx_fifo_size);\n\t}\n\n\tif ((hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) ||\n\t    (hsotg->dr_mode == USB_DR_MODE_OTG)) {\n\t\tCHECK_BOOL(g_dma, dma_capable);\n\t\tCHECK_BOOL(g_dma_desc, (p->g_dma && hw->dma_desc_enable));\n\t\tCHECK_RANGE(g_rx_fifo_size,\n\t\t\t    16, hw->rx_fifo_size,\n\t\t\t    hw->rx_fifo_size);\n\t\tCHECK_RANGE(g_np_tx_fifo_size,\n\t\t\t    16, hw->dev_nperio_tx_fifo_size,\n\t\t\t    hw->dev_nperio_tx_fifo_size);\n\t\tdwc2_check_param_tx_fifo_sizes(hsotg);\n\t}\n}\n\n \nstatic void dwc2_get_host_hwparams(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tu32 gnptxfsiz;\n\tu32 hptxfsiz;\n\n\tif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\treturn;\n\n\tdwc2_force_mode(hsotg, true);\n\n\tgnptxfsiz = dwc2_readl(hsotg, GNPTXFSIZ);\n\thptxfsiz = dwc2_readl(hsotg, HPTXFSIZ);\n\n\thw->host_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>\n\t\t\t\t       FIFOSIZE_DEPTH_SHIFT;\n\thw->host_perio_tx_fifo_size = (hptxfsiz & FIFOSIZE_DEPTH_MASK) >>\n\t\t\t\t      FIFOSIZE_DEPTH_SHIFT;\n}\n\n \nstatic void dwc2_get_dev_hwparams(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tu32 gnptxfsiz;\n\tint fifo, fifo_count;\n\n\tif (hsotg->dr_mode == USB_DR_MODE_HOST)\n\t\treturn;\n\n\tdwc2_force_mode(hsotg, false);\n\n\tgnptxfsiz = dwc2_readl(hsotg, GNPTXFSIZ);\n\n\tfifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\n\n\tfor (fifo = 1; fifo <= fifo_count; fifo++) {\n\t\thw->g_tx_fifo_size[fifo] =\n\t\t\t(dwc2_readl(hsotg, DPTXFSIZN(fifo)) &\n\t\t\t FIFOSIZE_DEPTH_MASK) >> FIFOSIZE_DEPTH_SHIFT;\n\t}\n\n\thw->dev_nperio_tx_fifo_size = (gnptxfsiz & FIFOSIZE_DEPTH_MASK) >>\n\t\t\t\t       FIFOSIZE_DEPTH_SHIFT;\n}\n\n \nint dwc2_get_hwparams(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tunsigned int width;\n\tu32 hwcfg1, hwcfg2, hwcfg3, hwcfg4;\n\tu32 grxfsiz;\n\n\thwcfg1 = dwc2_readl(hsotg, GHWCFG1);\n\thwcfg2 = dwc2_readl(hsotg, GHWCFG2);\n\thwcfg3 = dwc2_readl(hsotg, GHWCFG3);\n\thwcfg4 = dwc2_readl(hsotg, GHWCFG4);\n\tgrxfsiz = dwc2_readl(hsotg, GRXFSIZ);\n\n\t \n\thw->dev_ep_dirs = hwcfg1;\n\n\t \n\thw->op_mode = (hwcfg2 & GHWCFG2_OP_MODE_MASK) >>\n\t\t      GHWCFG2_OP_MODE_SHIFT;\n\thw->arch = (hwcfg2 & GHWCFG2_ARCHITECTURE_MASK) >>\n\t\t   GHWCFG2_ARCHITECTURE_SHIFT;\n\thw->enable_dynamic_fifo = !!(hwcfg2 & GHWCFG2_DYNAMIC_FIFO);\n\thw->host_channels = 1 + ((hwcfg2 & GHWCFG2_NUM_HOST_CHAN_MASK) >>\n\t\t\t\tGHWCFG2_NUM_HOST_CHAN_SHIFT);\n\thw->hs_phy_type = (hwcfg2 & GHWCFG2_HS_PHY_TYPE_MASK) >>\n\t\t\t  GHWCFG2_HS_PHY_TYPE_SHIFT;\n\thw->fs_phy_type = (hwcfg2 & GHWCFG2_FS_PHY_TYPE_MASK) >>\n\t\t\t  GHWCFG2_FS_PHY_TYPE_SHIFT;\n\thw->num_dev_ep = (hwcfg2 & GHWCFG2_NUM_DEV_EP_MASK) >>\n\t\t\t GHWCFG2_NUM_DEV_EP_SHIFT;\n\thw->nperio_tx_q_depth =\n\t\t(hwcfg2 & GHWCFG2_NONPERIO_TX_Q_DEPTH_MASK) >>\n\t\tGHWCFG2_NONPERIO_TX_Q_DEPTH_SHIFT << 1;\n\thw->host_perio_tx_q_depth =\n\t\t(hwcfg2 & GHWCFG2_HOST_PERIO_TX_Q_DEPTH_MASK) >>\n\t\tGHWCFG2_HOST_PERIO_TX_Q_DEPTH_SHIFT << 1;\n\thw->dev_token_q_depth =\n\t\t(hwcfg2 & GHWCFG2_DEV_TOKEN_Q_DEPTH_MASK) >>\n\t\tGHWCFG2_DEV_TOKEN_Q_DEPTH_SHIFT;\n\n\t \n\twidth = (hwcfg3 & GHWCFG3_XFER_SIZE_CNTR_WIDTH_MASK) >>\n\t\tGHWCFG3_XFER_SIZE_CNTR_WIDTH_SHIFT;\n\thw->max_transfer_size = (1 << (width + 11)) - 1;\n\twidth = (hwcfg3 & GHWCFG3_PACKET_SIZE_CNTR_WIDTH_MASK) >>\n\t\tGHWCFG3_PACKET_SIZE_CNTR_WIDTH_SHIFT;\n\thw->max_packet_count = (1 << (width + 4)) - 1;\n\thw->i2c_enable = !!(hwcfg3 & GHWCFG3_I2C);\n\thw->total_fifo_size = (hwcfg3 & GHWCFG3_DFIFO_DEPTH_MASK) >>\n\t\t\t      GHWCFG3_DFIFO_DEPTH_SHIFT;\n\thw->lpm_mode = !!(hwcfg3 & GHWCFG3_OTG_LPM_EN);\n\n\t \n\thw->en_multiple_tx_fifo = !!(hwcfg4 & GHWCFG4_DED_FIFO_EN);\n\thw->num_dev_perio_in_ep = (hwcfg4 & GHWCFG4_NUM_DEV_PERIO_IN_EP_MASK) >>\n\t\t\t\t  GHWCFG4_NUM_DEV_PERIO_IN_EP_SHIFT;\n\thw->num_dev_in_eps = (hwcfg4 & GHWCFG4_NUM_IN_EPS_MASK) >>\n\t\t\t     GHWCFG4_NUM_IN_EPS_SHIFT;\n\thw->dma_desc_enable = !!(hwcfg4 & GHWCFG4_DESC_DMA);\n\thw->power_optimized = !!(hwcfg4 & GHWCFG4_POWER_OPTIMIZ);\n\thw->hibernation = !!(hwcfg4 & GHWCFG4_HIBER);\n\thw->utmi_phy_data_width = (hwcfg4 & GHWCFG4_UTMI_PHY_DATA_WIDTH_MASK) >>\n\t\t\t\t  GHWCFG4_UTMI_PHY_DATA_WIDTH_SHIFT;\n\thw->acg_enable = !!(hwcfg4 & GHWCFG4_ACG_SUPPORTED);\n\thw->ipg_isoc_en = !!(hwcfg4 & GHWCFG4_IPG_ISOC_SUPPORTED);\n\thw->service_interval_mode = !!(hwcfg4 &\n\t\t\t\t       GHWCFG4_SERVICE_INTERVAL_SUPPORTED);\n\n\t \n\thw->rx_fifo_size = (grxfsiz & GRXFSIZ_DEPTH_MASK) >>\n\t\t\t\tGRXFSIZ_DEPTH_SHIFT;\n\t \n\tdwc2_get_host_hwparams(hsotg);\n\tdwc2_get_dev_hwparams(hsotg);\n\n\treturn 0;\n}\n\ntypedef void (*set_params_cb)(struct dwc2_hsotg *data);\n\nint dwc2_init_params(struct dwc2_hsotg *hsotg)\n{\n\tconst struct of_device_id *match;\n\tset_params_cb set_params;\n\n\tdwc2_set_default_params(hsotg);\n\tdwc2_get_device_properties(hsotg);\n\n\tmatch = of_match_device(dwc2_of_match_table, hsotg->dev);\n\tif (match && match->data) {\n\t\tset_params = match->data;\n\t\tset_params(hsotg);\n\t} else if (!match) {\n\t\tconst struct acpi_device_id *amatch;\n\t\tconst struct pci_device_id *pmatch = NULL;\n\n\t\tamatch = acpi_match_device(dwc2_acpi_match, hsotg->dev);\n\t\tif (amatch && amatch->driver_data) {\n\t\t\tset_params = (set_params_cb)amatch->driver_data;\n\t\t\tset_params(hsotg);\n\t\t} else if (!amatch)\n\t\t\tpmatch = pci_match_id(dwc2_pci_ids, to_pci_dev(hsotg->dev->parent));\n\n\t\tif (pmatch && pmatch->driver_data) {\n\t\t\tset_params = (set_params_cb)pmatch->driver_data;\n\t\t\tset_params(hsotg);\n\t\t}\n\t}\n\n\tdwc2_check_params(hsotg);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}