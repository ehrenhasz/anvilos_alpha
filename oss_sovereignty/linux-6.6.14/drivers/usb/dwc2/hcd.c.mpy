{
  "module_name": "hcd.c",
  "hash_id": "dd2e41d3083c1764f9d1a13db91c974e70b248accb462ed462a77f2096c34784",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/hcd.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n#include <linux/usb/of.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\n \n\n \nstatic void dwc2_enable_common_interrupts(struct dwc2_hsotg *hsotg)\n{\n\tu32 intmsk;\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GOTGINT);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tintmsk = GINTSTS_MODEMIS | GINTSTS_OTGINT;\n\n\tif (!hsotg->params.host_dma)\n\t\tintmsk |= GINTSTS_RXFLVL;\n\tif (!hsotg->params.external_id_pin_ctl)\n\t\tintmsk |= GINTSTS_CONIDSTSCHNG;\n\n\tintmsk |= GINTSTS_WKUPINT | GINTSTS_USBSUSP |\n\t\t  GINTSTS_SESSREQINT;\n\n\tif (dwc2_is_device_mode(hsotg) && hsotg->params.lpm)\n\t\tintmsk |= GINTSTS_LPMTRANRCVD;\n\n\tdwc2_writel(hsotg, intmsk, GINTMSK);\n}\n\nstatic int dwc2_gahbcfg_init(struct dwc2_hsotg *hsotg)\n{\n\tu32 ahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\n\tswitch (hsotg->hw_params.arch) {\n\tcase GHWCFG2_EXT_DMA_ARCH:\n\t\tdev_err(hsotg->dev, \"External DMA Mode not supported\\n\");\n\t\treturn -EINVAL;\n\n\tcase GHWCFG2_INT_DMA_ARCH:\n\t\tdev_dbg(hsotg->dev, \"Internal DMA Mode\\n\");\n\t\tif (hsotg->params.ahbcfg != -1) {\n\t\t\tahbcfg &= GAHBCFG_CTRL_MASK;\n\t\t\tahbcfg |= hsotg->params.ahbcfg &\n\t\t\t\t  ~GAHBCFG_CTRL_MASK;\n\t\t}\n\t\tbreak;\n\n\tcase GHWCFG2_SLAVE_ONLY_ARCH:\n\tdefault:\n\t\tdev_dbg(hsotg->dev, \"Slave Only Mode\\n\");\n\t\tbreak;\n\t}\n\n\tif (hsotg->params.host_dma)\n\t\tahbcfg |= GAHBCFG_DMA_EN;\n\telse\n\t\thsotg->params.dma_desc_enable = false;\n\n\tdwc2_writel(hsotg, ahbcfg, GAHBCFG);\n\n\treturn 0;\n}\n\nstatic void dwc2_gusbcfg_init(struct dwc2_hsotg *hsotg)\n{\n\tu32 usbcfg;\n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tusbcfg &= ~(GUSBCFG_HNPCAP | GUSBCFG_SRPCAP);\n\n\tswitch (hsotg->hw_params.op_mode) {\n\tcase GHWCFG2_OP_MODE_HNP_SRP_CAPABLE:\n\t\tif (hsotg->params.otg_caps.hnp_support &&\n\t\t    hsotg->params.otg_caps.srp_support)\n\t\t\tusbcfg |= GUSBCFG_HNPCAP;\n\t\tfallthrough;\n\n\tcase GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE:\n\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE:\n\tcase GHWCFG2_OP_MODE_SRP_CAPABLE_HOST:\n\t\tif (hsotg->params.otg_caps.srp_support)\n\t\t\tusbcfg |= GUSBCFG_SRPCAP;\n\t\tbreak;\n\n\tcase GHWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE:\n\tcase GHWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE:\n\tcase GHWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST:\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n}\n\nstatic int dwc2_vbus_supply_init(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->vbus_supply)\n\t\treturn regulator_enable(hsotg->vbus_supply);\n\n\treturn 0;\n}\n\nstatic int dwc2_vbus_supply_exit(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->vbus_supply)\n\t\treturn regulator_disable(hsotg->vbus_supply);\n\n\treturn 0;\n}\n\n \nstatic void dwc2_enable_host_interrupts(struct dwc2_hsotg *hsotg)\n{\n\tu32 intmsk;\n\n\tdev_dbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\tdwc2_writel(hsotg, 0, GINTMSK);\n\tdwc2_writel(hsotg, 0, HAINTMSK);\n\n\t \n\tdwc2_enable_common_interrupts(hsotg);\n\n\t \n\tintmsk = dwc2_readl(hsotg, GINTMSK);\n\tintmsk |= GINTSTS_DISCONNINT | GINTSTS_PRTINT | GINTSTS_HCHINT;\n\tdwc2_writel(hsotg, intmsk, GINTMSK);\n}\n\n \nstatic void dwc2_disable_host_interrupts(struct dwc2_hsotg *hsotg)\n{\n\tu32 intmsk = dwc2_readl(hsotg, GINTMSK);\n\n\t \n\tintmsk &= ~(GINTSTS_SOF | GINTSTS_PRTINT | GINTSTS_HCHINT |\n\t\t    GINTSTS_PTXFEMP | GINTSTS_NPTXFEMP | GINTSTS_DISCONNINT);\n\tdwc2_writel(hsotg, intmsk, GINTMSK);\n}\n\n \nstatic void dwc2_calculate_dynamic_fifo(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *params = &hsotg->params;\n\tstruct dwc2_hw_params *hw = &hsotg->hw_params;\n\tu32 rxfsiz, nptxfsiz, ptxfsiz, total_fifo_size;\n\n\ttotal_fifo_size = hw->total_fifo_size;\n\trxfsiz = params->host_rx_fifo_size;\n\tnptxfsiz = params->host_nperio_tx_fifo_size;\n\tptxfsiz = params->host_perio_tx_fifo_size;\n\n\t \n\tif (total_fifo_size < (rxfsiz + nptxfsiz + ptxfsiz)) {\n\t\t \n\t\trxfsiz = 516 + hw->host_channels;\n\n\t\t \n\t\tnptxfsiz = 256;\n\n\t\t \n\t\tptxfsiz = 768;\n\n\t\tparams->host_rx_fifo_size = rxfsiz;\n\t\tparams->host_nperio_tx_fifo_size = nptxfsiz;\n\t\tparams->host_perio_tx_fifo_size = ptxfsiz;\n\t}\n\n\t \n\tif (unlikely(total_fifo_size < (rxfsiz + nptxfsiz + ptxfsiz)))\n\t\tdev_err(hsotg->dev, \"invalid fifo sizes\\n\");\n}\n\nstatic void dwc2_config_fifos(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_core_params *params = &hsotg->params;\n\tu32 nptxfsiz, hptxfsiz, dfifocfg, grxfsiz;\n\n\tif (!params->enable_dynamic_fifo)\n\t\treturn;\n\n\tdwc2_calculate_dynamic_fifo(hsotg);\n\n\t \n\tgrxfsiz = dwc2_readl(hsotg, GRXFSIZ);\n\tdev_dbg(hsotg->dev, \"initial grxfsiz=%08x\\n\", grxfsiz);\n\tgrxfsiz &= ~GRXFSIZ_DEPTH_MASK;\n\tgrxfsiz |= params->host_rx_fifo_size <<\n\t\t   GRXFSIZ_DEPTH_SHIFT & GRXFSIZ_DEPTH_MASK;\n\tdwc2_writel(hsotg, grxfsiz, GRXFSIZ);\n\tdev_dbg(hsotg->dev, \"new grxfsiz=%08x\\n\",\n\t\tdwc2_readl(hsotg, GRXFSIZ));\n\n\t \n\tdev_dbg(hsotg->dev, \"initial gnptxfsiz=%08x\\n\",\n\t\tdwc2_readl(hsotg, GNPTXFSIZ));\n\tnptxfsiz = params->host_nperio_tx_fifo_size <<\n\t\t   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;\n\tnptxfsiz |= params->host_rx_fifo_size <<\n\t\t    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;\n\tdwc2_writel(hsotg, nptxfsiz, GNPTXFSIZ);\n\tdev_dbg(hsotg->dev, \"new gnptxfsiz=%08x\\n\",\n\t\tdwc2_readl(hsotg, GNPTXFSIZ));\n\n\t \n\tdev_dbg(hsotg->dev, \"initial hptxfsiz=%08x\\n\",\n\t\tdwc2_readl(hsotg, HPTXFSIZ));\n\thptxfsiz = params->host_perio_tx_fifo_size <<\n\t\t   FIFOSIZE_DEPTH_SHIFT & FIFOSIZE_DEPTH_MASK;\n\thptxfsiz |= (params->host_rx_fifo_size +\n\t\t     params->host_nperio_tx_fifo_size) <<\n\t\t    FIFOSIZE_STARTADDR_SHIFT & FIFOSIZE_STARTADDR_MASK;\n\tdwc2_writel(hsotg, hptxfsiz, HPTXFSIZ);\n\tdev_dbg(hsotg->dev, \"new hptxfsiz=%08x\\n\",\n\t\tdwc2_readl(hsotg, HPTXFSIZ));\n\n\tif (hsotg->params.en_multiple_tx_fifo &&\n\t    hsotg->hw_params.snpsid >= DWC2_CORE_REV_2_91a) {\n\t\t \n\t\tdfifocfg = dwc2_readl(hsotg, GDFIFOCFG);\n\t\tdfifocfg &= ~GDFIFOCFG_EPINFOBASE_MASK;\n\t\tdfifocfg |= (params->host_rx_fifo_size +\n\t\t\t     params->host_nperio_tx_fifo_size +\n\t\t\t     params->host_perio_tx_fifo_size) <<\n\t\t\t    GDFIFOCFG_EPINFOBASE_SHIFT &\n\t\t\t    GDFIFOCFG_EPINFOBASE_MASK;\n\t\tdwc2_writel(hsotg, dfifocfg, GDFIFOCFG);\n\t}\n}\n\n \nu32 dwc2_calc_frame_interval(struct dwc2_hsotg *hsotg)\n{\n\tu32 usbcfg;\n\tu32 hprt0;\n\tint clock = 60;\t \n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\thprt0 = dwc2_readl(hsotg, HPRT0);\n\n\tif (!(usbcfg & GUSBCFG_PHYSEL) && (usbcfg & GUSBCFG_ULPI_UTMI_SEL) &&\n\t    !(usbcfg & GUSBCFG_PHYIF16))\n\t\tclock = 60;\n\tif ((usbcfg & GUSBCFG_PHYSEL) && hsotg->hw_params.fs_phy_type ==\n\t    GHWCFG2_FS_PHY_TYPE_SHARED_ULPI)\n\t\tclock = 48;\n\tif (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL) && !(usbcfg & GUSBCFG_PHYSEL) &&\n\t    !(usbcfg & GUSBCFG_ULPI_UTMI_SEL) && (usbcfg & GUSBCFG_PHYIF16))\n\t\tclock = 30;\n\tif (!(usbcfg & GUSBCFG_PHY_LP_CLK_SEL) && !(usbcfg & GUSBCFG_PHYSEL) &&\n\t    !(usbcfg & GUSBCFG_ULPI_UTMI_SEL) && !(usbcfg & GUSBCFG_PHYIF16))\n\t\tclock = 60;\n\tif ((usbcfg & GUSBCFG_PHY_LP_CLK_SEL) && !(usbcfg & GUSBCFG_PHYSEL) &&\n\t    !(usbcfg & GUSBCFG_ULPI_UTMI_SEL) && (usbcfg & GUSBCFG_PHYIF16))\n\t\tclock = 48;\n\tif ((usbcfg & GUSBCFG_PHYSEL) && !(usbcfg & GUSBCFG_PHYIF16) &&\n\t    hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_SHARED_UTMI)\n\t\tclock = 48;\n\tif ((usbcfg & GUSBCFG_PHYSEL) &&\n\t    hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED)\n\t\tclock = 48;\n\n\tif ((hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT == HPRT0_SPD_HIGH_SPEED)\n\t\t \n\t\treturn 125 * clock - 1;\n\n\t \n\treturn 1000 * clock - 1;\n}\n\n \nvoid dwc2_read_packet(struct dwc2_hsotg *hsotg, u8 *dest, u16 bytes)\n{\n\tu32 *data_buf = (u32 *)dest;\n\tint word_count = (bytes + 3) / 4;\n\tint i;\n\n\t \n\n\tdev_vdbg(hsotg->dev, \"%s(%p,%p,%d)\\n\", __func__, hsotg, dest, bytes);\n\n\tfor (i = 0; i < word_count; i++, data_buf++)\n\t\t*data_buf = dwc2_readl(hsotg, HCFIFO(0));\n}\n\n \nstatic void dwc2_dump_channel_info(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_host_chan *chan)\n{\n#ifdef VERBOSE_DEBUG\n\tint num_channels = hsotg->params.host_channels;\n\tstruct dwc2_qh *qh;\n\tu32 hcchar;\n\tu32 hcsplt;\n\tu32 hctsiz;\n\tu32 hc_dma;\n\tint i;\n\n\tif (!chan)\n\t\treturn;\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\thcsplt = dwc2_readl(hsotg, HCSPLT(chan->hc_num));\n\thctsiz = dwc2_readl(hsotg, HCTSIZ(chan->hc_num));\n\thc_dma = dwc2_readl(hsotg, HCDMA(chan->hc_num));\n\n\tdev_dbg(hsotg->dev, \"  Assigned to channel %p:\\n\", chan);\n\tdev_dbg(hsotg->dev, \"    hcchar 0x%08x, hcsplt 0x%08x\\n\",\n\t\thcchar, hcsplt);\n\tdev_dbg(hsotg->dev, \"    hctsiz 0x%08x, hc_dma 0x%08x\\n\",\n\t\thctsiz, hc_dma);\n\tdev_dbg(hsotg->dev, \"    dev_addr: %d, ep_num: %d, ep_is_in: %d\\n\",\n\t\tchan->dev_addr, chan->ep_num, chan->ep_is_in);\n\tdev_dbg(hsotg->dev, \"    ep_type: %d\\n\", chan->ep_type);\n\tdev_dbg(hsotg->dev, \"    max_packet: %d\\n\", chan->max_packet);\n\tdev_dbg(hsotg->dev, \"    data_pid_start: %d\\n\", chan->data_pid_start);\n\tdev_dbg(hsotg->dev, \"    xfer_started: %d\\n\", chan->xfer_started);\n\tdev_dbg(hsotg->dev, \"    halt_status: %d\\n\", chan->halt_status);\n\tdev_dbg(hsotg->dev, \"    xfer_buf: %p\\n\", chan->xfer_buf);\n\tdev_dbg(hsotg->dev, \"    xfer_dma: %08lx\\n\",\n\t\t(unsigned long)chan->xfer_dma);\n\tdev_dbg(hsotg->dev, \"    xfer_len: %d\\n\", chan->xfer_len);\n\tdev_dbg(hsotg->dev, \"    qh: %p\\n\", chan->qh);\n\tdev_dbg(hsotg->dev, \"  NP inactive sched:\\n\");\n\tlist_for_each_entry(qh, &hsotg->non_periodic_sched_inactive,\n\t\t\t    qh_list_entry)\n\t\tdev_dbg(hsotg->dev, \"    %p\\n\", qh);\n\tdev_dbg(hsotg->dev, \"  NP waiting sched:\\n\");\n\tlist_for_each_entry(qh, &hsotg->non_periodic_sched_waiting,\n\t\t\t    qh_list_entry)\n\t\tdev_dbg(hsotg->dev, \"    %p\\n\", qh);\n\tdev_dbg(hsotg->dev, \"  NP active sched:\\n\");\n\tlist_for_each_entry(qh, &hsotg->non_periodic_sched_active,\n\t\t\t    qh_list_entry)\n\t\tdev_dbg(hsotg->dev, \"    %p\\n\", qh);\n\tdev_dbg(hsotg->dev, \"  Channels:\\n\");\n\tfor (i = 0; i < num_channels; i++) {\n\t\tstruct dwc2_host_chan *chan = hsotg->hc_ptr_array[i];\n\n\t\tdev_dbg(hsotg->dev, \"    %2d: %p\\n\", i, chan);\n\t}\n#endif  \n}\n\nstatic int _dwc2_hcd_start(struct usb_hcd *hcd);\n\nstatic void dwc2_host_start(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_hcd *hcd = dwc2_hsotg_to_hcd(hsotg);\n\n\thcd->self.is_b_host = dwc2_hcd_is_b_host(hsotg);\n\t_dwc2_hcd_start(hcd);\n}\n\nstatic void dwc2_host_disconnect(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_hcd *hcd = dwc2_hsotg_to_hcd(hsotg);\n\n\thcd->self.is_b_host = 0;\n}\n\nstatic void dwc2_host_hub_info(struct dwc2_hsotg *hsotg, void *context,\n\t\t\t       int *hub_addr, int *hub_port)\n{\n\tstruct urb *urb = context;\n\n\tif (urb->dev->tt)\n\t\t*hub_addr = urb->dev->tt->hub->devnum;\n\telse\n\t\t*hub_addr = 0;\n\t*hub_port = urb->dev->ttport;\n}\n\n \n\nstatic void dwc2_hc_enable_slave_ints(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_host_chan *chan)\n{\n\tu32 hcintmsk = HCINTMSK_CHHLTD;\n\n\tswitch (chan->ep_type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tdev_vdbg(hsotg->dev, \"control/bulk\\n\");\n\t\thcintmsk |= HCINTMSK_XFERCOMPL;\n\t\thcintmsk |= HCINTMSK_STALL;\n\t\thcintmsk |= HCINTMSK_XACTERR;\n\t\thcintmsk |= HCINTMSK_DATATGLERR;\n\t\tif (chan->ep_is_in) {\n\t\t\thcintmsk |= HCINTMSK_BBLERR;\n\t\t} else {\n\t\t\thcintmsk |= HCINTMSK_NAK;\n\t\t\thcintmsk |= HCINTMSK_NYET;\n\t\t\tif (chan->do_ping)\n\t\t\t\thcintmsk |= HCINTMSK_ACK;\n\t\t}\n\n\t\tif (chan->do_split) {\n\t\t\thcintmsk |= HCINTMSK_NAK;\n\t\t\tif (chan->complete_split)\n\t\t\t\thcintmsk |= HCINTMSK_NYET;\n\t\t\telse\n\t\t\t\thcintmsk |= HCINTMSK_ACK;\n\t\t}\n\n\t\tif (chan->error_state)\n\t\t\thcintmsk |= HCINTMSK_ACK;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (dbg_perio())\n\t\t\tdev_vdbg(hsotg->dev, \"intr\\n\");\n\t\thcintmsk |= HCINTMSK_XFERCOMPL;\n\t\thcintmsk |= HCINTMSK_NAK;\n\t\thcintmsk |= HCINTMSK_STALL;\n\t\thcintmsk |= HCINTMSK_XACTERR;\n\t\thcintmsk |= HCINTMSK_DATATGLERR;\n\t\thcintmsk |= HCINTMSK_FRMOVRUN;\n\n\t\tif (chan->ep_is_in)\n\t\t\thcintmsk |= HCINTMSK_BBLERR;\n\t\tif (chan->error_state)\n\t\t\thcintmsk |= HCINTMSK_ACK;\n\t\tif (chan->do_split) {\n\t\t\tif (chan->complete_split)\n\t\t\t\thcintmsk |= HCINTMSK_NYET;\n\t\t\telse\n\t\t\t\thcintmsk |= HCINTMSK_ACK;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (dbg_perio())\n\t\t\tdev_vdbg(hsotg->dev, \"isoc\\n\");\n\t\thcintmsk |= HCINTMSK_XFERCOMPL;\n\t\thcintmsk |= HCINTMSK_FRMOVRUN;\n\t\thcintmsk |= HCINTMSK_ACK;\n\n\t\tif (chan->ep_is_in) {\n\t\t\thcintmsk |= HCINTMSK_XACTERR;\n\t\t\thcintmsk |= HCINTMSK_BBLERR;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev, \"## Unknown EP type ##\\n\");\n\t\tbreak;\n\t}\n\n\tdwc2_writel(hsotg, hcintmsk, HCINTMSK(chan->hc_num));\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"set HCINTMSK to %08x\\n\", hcintmsk);\n}\n\nstatic void dwc2_hc_enable_dma_ints(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_host_chan *chan)\n{\n\tu32 hcintmsk = HCINTMSK_CHHLTD;\n\n\t \n\tif (!hsotg->params.dma_desc_enable) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"desc DMA disabled\\n\");\n\t\thcintmsk |= HCINTMSK_AHBERR;\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"desc DMA enabled\\n\");\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\t\thcintmsk |= HCINTMSK_XFERCOMPL;\n\t}\n\n\tif (chan->error_state && !chan->do_split &&\n\t    chan->ep_type != USB_ENDPOINT_XFER_ISOC) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"setting ACK\\n\");\n\t\thcintmsk |= HCINTMSK_ACK;\n\t\tif (chan->ep_is_in) {\n\t\t\thcintmsk |= HCINTMSK_DATATGLERR;\n\t\t\tif (chan->ep_type != USB_ENDPOINT_XFER_INT)\n\t\t\t\thcintmsk |= HCINTMSK_NAK;\n\t\t}\n\t}\n\n\tdwc2_writel(hsotg, hcintmsk, HCINTMSK(chan->hc_num));\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"set HCINTMSK to %08x\\n\", hcintmsk);\n}\n\nstatic void dwc2_hc_enable_ints(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_host_chan *chan)\n{\n\tu32 intmsk;\n\n\tif (hsotg->params.host_dma) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"DMA enabled\\n\");\n\t\tdwc2_hc_enable_dma_ints(hsotg, chan);\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"DMA disabled\\n\");\n\t\tdwc2_hc_enable_slave_ints(hsotg, chan);\n\t}\n\n\t \n\tintmsk = dwc2_readl(hsotg, HAINTMSK);\n\tintmsk |= 1 << chan->hc_num;\n\tdwc2_writel(hsotg, intmsk, HAINTMSK);\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"set HAINTMSK to %08x\\n\", intmsk);\n\n\t \n\tintmsk = dwc2_readl(hsotg, GINTMSK);\n\tintmsk |= GINTSTS_HCHINT;\n\tdwc2_writel(hsotg, intmsk, GINTMSK);\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"set GINTMSK to %08x\\n\", intmsk);\n}\n\n \nstatic void dwc2_hc_init(struct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan)\n{\n\tu8 hc_num = chan->hc_num;\n\tu32 hcintmsk;\n\tu32 hcchar;\n\tu32 hcsplt = 0;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\thcintmsk = 0xffffffff;\n\thcintmsk &= ~HCINTMSK_RESERVED14_31;\n\tdwc2_writel(hsotg, hcintmsk, HCINT(hc_num));\n\n\t \n\tdwc2_hc_enable_ints(hsotg, chan);\n\n\t \n\thcchar = chan->dev_addr << HCCHAR_DEVADDR_SHIFT & HCCHAR_DEVADDR_MASK;\n\thcchar |= chan->ep_num << HCCHAR_EPNUM_SHIFT & HCCHAR_EPNUM_MASK;\n\tif (chan->ep_is_in)\n\t\thcchar |= HCCHAR_EPDIR;\n\tif (chan->speed == USB_SPEED_LOW)\n\t\thcchar |= HCCHAR_LSPDDEV;\n\thcchar |= chan->ep_type << HCCHAR_EPTYPE_SHIFT & HCCHAR_EPTYPE_MASK;\n\thcchar |= chan->max_packet << HCCHAR_MPS_SHIFT & HCCHAR_MPS_MASK;\n\tdwc2_writel(hsotg, hcchar, HCCHAR(hc_num));\n\tif (dbg_hc(chan)) {\n\t\tdev_vdbg(hsotg->dev, \"set HCCHAR(%d) to %08x\\n\",\n\t\t\t hc_num, hcchar);\n\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\",\n\t\t\t __func__, hc_num);\n\t\tdev_vdbg(hsotg->dev, \"\t Dev Addr: %d\\n\",\n\t\t\t chan->dev_addr);\n\t\tdev_vdbg(hsotg->dev, \"\t Ep Num: %d\\n\",\n\t\t\t chan->ep_num);\n\t\tdev_vdbg(hsotg->dev, \"\t Is In: %d\\n\",\n\t\t\t chan->ep_is_in);\n\t\tdev_vdbg(hsotg->dev, \"\t Is Low Speed: %d\\n\",\n\t\t\t chan->speed == USB_SPEED_LOW);\n\t\tdev_vdbg(hsotg->dev, \"\t Ep Type: %d\\n\",\n\t\t\t chan->ep_type);\n\t\tdev_vdbg(hsotg->dev, \"\t Max Pkt: %d\\n\",\n\t\t\t chan->max_packet);\n\t}\n\n\t \n\tif (chan->do_split) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev,\n\t\t\t\t \"Programming HC %d with split --> %s\\n\",\n\t\t\t\t hc_num,\n\t\t\t\t chan->complete_split ? \"CSPLIT\" : \"SSPLIT\");\n\t\tif (chan->complete_split)\n\t\t\thcsplt |= HCSPLT_COMPSPLT;\n\t\thcsplt |= chan->xact_pos << HCSPLT_XACTPOS_SHIFT &\n\t\t\t  HCSPLT_XACTPOS_MASK;\n\t\thcsplt |= chan->hub_addr << HCSPLT_HUBADDR_SHIFT &\n\t\t\t  HCSPLT_HUBADDR_MASK;\n\t\thcsplt |= chan->hub_port << HCSPLT_PRTADDR_SHIFT &\n\t\t\t  HCSPLT_PRTADDR_MASK;\n\t\tif (dbg_hc(chan)) {\n\t\t\tdev_vdbg(hsotg->dev, \"\t  comp split %d\\n\",\n\t\t\t\t chan->complete_split);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  xact pos %d\\n\",\n\t\t\t\t chan->xact_pos);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  hub addr %d\\n\",\n\t\t\t\t chan->hub_addr);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  hub port %d\\n\",\n\t\t\t\t chan->hub_port);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  is_in %d\\n\",\n\t\t\t\t chan->ep_is_in);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  Max Pkt %d\\n\",\n\t\t\t\t chan->max_packet);\n\t\t\tdev_vdbg(hsotg->dev, \"\t  xferlen %d\\n\",\n\t\t\t\t chan->xfer_len);\n\t\t}\n\t}\n\n\tdwc2_writel(hsotg, hcsplt, HCSPLT(hc_num));\n}\n\n \nvoid dwc2_hc_halt(struct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan,\n\t\t  enum dwc2_halt_status halt_status)\n{\n\tu32 nptxsts, hptxsts, hcchar;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\tif ((hsotg->params.g_dma && !hsotg->params.g_dma_desc) ||\n\t    hsotg->hw_params.arch == GHWCFG2_EXT_DMA_ARCH) {\n\t\tif (!chan->do_split &&\n\t\t    (chan->ep_type == USB_ENDPOINT_XFER_ISOC ||\n\t\t     chan->ep_type == USB_ENDPOINT_XFER_INT)) {\n\t\t\tdev_err(hsotg->dev, \"%s() Channel can't be halted\\n\",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (halt_status == DWC2_HC_XFER_NO_HALT_STATUS)\n\t\tdev_err(hsotg->dev, \"!!! halt_status = %d !!!\\n\", halt_status);\n\n\tif (halt_status == DWC2_HC_XFER_URB_DEQUEUE ||\n\t    halt_status == DWC2_HC_XFER_AHB_ERR) {\n\t\t \n\t\tu32 hcintmsk = HCINTMSK_CHHLTD;\n\n\t\tdev_vdbg(hsotg->dev, \"dequeue/error\\n\");\n\t\tdwc2_writel(hsotg, hcintmsk, HCINTMSK(chan->hc_num));\n\n\t\t \n\t\tdwc2_writel(hsotg, ~hcintmsk, HCINT(chan->hc_num));\n\n\t\t \n\t\tchan->halt_status = halt_status;\n\n\t\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\t\tif (!(hcchar & HCCHAR_CHENA)) {\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\tif (chan->halt_pending) {\n\t\t \n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"*** %s: Channel %d, chan->halt_pending already set ***\\n\",\n\t\t\t __func__, chan->hc_num);\n\t\treturn;\n\t}\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\n\t \n\t \n\tif (!hsotg->params.dma_desc_enable) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"desc DMA disabled\\n\");\n\t\thcchar |= HCCHAR_CHENA;\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_dbg(hsotg->dev, \"desc DMA enabled\\n\");\n\t}\n\thcchar |= HCCHAR_CHDIS;\n\n\tif (!hsotg->params.host_dma) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"DMA not enabled\\n\");\n\t\thcchar |= HCCHAR_CHENA;\n\n\t\t \n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_CONTROL ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_BULK) {\n\t\t\tdev_vdbg(hsotg->dev, \"control/bulk\\n\");\n\t\t\tnptxsts = dwc2_readl(hsotg, GNPTXSTS);\n\t\t\tif ((nptxsts & TXSTS_QSPCAVAIL_MASK) == 0) {\n\t\t\t\tdev_vdbg(hsotg->dev, \"Disabling channel\\n\");\n\t\t\t\thcchar &= ~HCCHAR_CHENA;\n\t\t\t}\n\t\t} else {\n\t\t\tif (dbg_perio())\n\t\t\t\tdev_vdbg(hsotg->dev, \"isoc/intr\\n\");\n\t\t\thptxsts = dwc2_readl(hsotg, HPTXSTS);\n\t\t\tif ((hptxsts & TXSTS_QSPCAVAIL_MASK) == 0 ||\n\t\t\t    hsotg->queuing_high_bandwidth) {\n\t\t\t\tif (dbg_perio())\n\t\t\t\t\tdev_vdbg(hsotg->dev, \"Disabling channel\\n\");\n\t\t\t\thcchar &= ~HCCHAR_CHENA;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"DMA enabled\\n\");\n\t}\n\n\tdwc2_writel(hsotg, hcchar, HCCHAR(chan->hc_num));\n\tchan->halt_status = halt_status;\n\n\tif (hcchar & HCCHAR_CHENA) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"Channel enabled\\n\");\n\t\tchan->halt_pending = 1;\n\t\tchan->halt_on_queue = 0;\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"Channel disabled\\n\");\n\t\tchan->halt_on_queue = 1;\n\t}\n\n\tif (dbg_hc(chan)) {\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\", __func__,\n\t\t\t chan->hc_num);\n\t\tdev_vdbg(hsotg->dev, \"\t hcchar: 0x%08x\\n\",\n\t\t\t hcchar);\n\t\tdev_vdbg(hsotg->dev, \"\t halt_pending: %d\\n\",\n\t\t\t chan->halt_pending);\n\t\tdev_vdbg(hsotg->dev, \"\t halt_on_queue: %d\\n\",\n\t\t\t chan->halt_on_queue);\n\t\tdev_vdbg(hsotg->dev, \"\t halt_status: %d\\n\",\n\t\t\t chan->halt_status);\n\t}\n}\n\n \nvoid dwc2_hc_cleanup(struct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan)\n{\n\tu32 hcintmsk;\n\n\tchan->xfer_started = 0;\n\n\tlist_del_init(&chan->split_order_list_entry);\n\n\t \n\tdwc2_writel(hsotg, 0, HCINTMSK(chan->hc_num));\n\thcintmsk = 0xffffffff;\n\thcintmsk &= ~HCINTMSK_RESERVED14_31;\n\tdwc2_writel(hsotg, hcintmsk, HCINT(chan->hc_num));\n}\n\n \nstatic void dwc2_hc_set_even_odd_frame(struct dwc2_hsotg *hsotg,\n\t\t\t\t       struct dwc2_host_chan *chan, u32 *hcchar)\n{\n\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\tint host_speed;\n\t\tint xfer_ns;\n\t\tint xfer_us;\n\t\tint bytes_in_fifo;\n\t\tu16 fifo_space;\n\t\tu16 frame_number;\n\t\tu16 wire_frame;\n\n\t\t \n\n\t\t \n\t\thost_speed = (chan->speed != USB_SPEED_HIGH &&\n\t\t\t      !chan->do_split) ? chan->speed : USB_SPEED_HIGH;\n\n\t\t \n\t\tfifo_space = (dwc2_readl(hsotg, HPTXSTS) &\n\t\t\t      TXSTS_FSPCAVAIL_MASK) >> TXSTS_FSPCAVAIL_SHIFT;\n\t\tbytes_in_fifo = sizeof(u32) *\n\t\t\t\t(hsotg->params.host_perio_tx_fifo_size -\n\t\t\t\t fifo_space);\n\n\t\t \n\t\txfer_ns = usb_calc_bus_time(host_speed, false, false,\n\t\t\t\t\t    chan->xfer_len + bytes_in_fifo);\n\t\txfer_us = NS_TO_US(xfer_ns);\n\n\t\t \n\t\tframe_number = dwc2_hcd_get_future_frame_number(hsotg, xfer_us);\n\n\t\t \n\t\twire_frame = dwc2_frame_num_inc(chan->qh->next_active_frame, 1);\n\n\t\t \n\t\tif (dwc2_frame_num_gt(frame_number, wire_frame)) {\n\t\t\tdwc2_sch_vdbg(hsotg,\n\t\t\t\t      \"QH=%p EO MISS fr=%04x=>%04x (%+d)\\n\",\n\t\t\t\t      chan->qh, wire_frame, frame_number,\n\t\t\t\t      dwc2_frame_num_dec(frame_number,\n\t\t\t\t\t\t\t wire_frame));\n\t\t\twire_frame = frame_number;\n\n\t\t\t \n\t\t\tchan->qh->next_active_frame =\n\t\t\t\tdwc2_frame_num_dec(frame_number, 1);\n\t\t}\n\n\t\tif (wire_frame & 1)\n\t\t\t*hcchar |= HCCHAR_ODDFRM;\n\t\telse\n\t\t\t*hcchar &= ~HCCHAR_ODDFRM;\n\t}\n}\n\nstatic void dwc2_set_pid_isoc(struct dwc2_host_chan *chan)\n{\n\t \n\tif (chan->speed == USB_SPEED_HIGH) {\n\t\tif (chan->ep_is_in) {\n\t\t\tif (chan->multi_count == 1)\n\t\t\t\tchan->data_pid_start = DWC2_HC_PID_DATA0;\n\t\t\telse if (chan->multi_count == 2)\n\t\t\t\tchan->data_pid_start = DWC2_HC_PID_DATA1;\n\t\t\telse\n\t\t\t\tchan->data_pid_start = DWC2_HC_PID_DATA2;\n\t\t} else {\n\t\t\tif (chan->multi_count == 1)\n\t\t\t\tchan->data_pid_start = DWC2_HC_PID_DATA0;\n\t\t\telse\n\t\t\t\tchan->data_pid_start = DWC2_HC_PID_MDATA;\n\t\t}\n\t} else {\n\t\tchan->data_pid_start = DWC2_HC_PID_DATA0;\n\t}\n}\n\n \nstatic void dwc2_hc_write_packet(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan)\n{\n\tu32 i;\n\tu32 remaining_count;\n\tu32 byte_count;\n\tu32 dword_count;\n\tu32 *data_buf = (u32 *)chan->xfer_buf;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tremaining_count = chan->xfer_len - chan->xfer_count;\n\tif (remaining_count > chan->max_packet)\n\t\tbyte_count = chan->max_packet;\n\telse\n\t\tbyte_count = remaining_count;\n\n\tdword_count = (byte_count + 3) / 4;\n\n\tif (((unsigned long)data_buf & 0x3) == 0) {\n\t\t \n\t\tfor (i = 0; i < dword_count; i++, data_buf++)\n\t\t\tdwc2_writel(hsotg, *data_buf, HCFIFO(chan->hc_num));\n\t} else {\n\t\t \n\t\tfor (i = 0; i < dword_count; i++, data_buf++) {\n\t\t\tu32 data = data_buf[0] | data_buf[1] << 8 |\n\t\t\t\t   data_buf[2] << 16 | data_buf[3] << 24;\n\t\t\tdwc2_writel(hsotg, data, HCFIFO(chan->hc_num));\n\t\t}\n\t}\n\n\tchan->xfer_count += byte_count;\n\tchan->xfer_buf += byte_count;\n}\n\n \nstatic void dwc2_hc_do_ping(struct dwc2_hsotg *hsotg,\n\t\t\t    struct dwc2_host_chan *chan)\n{\n\tu32 hcchar;\n\tu32 hctsiz;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\", __func__,\n\t\t\t chan->hc_num);\n\n\thctsiz = TSIZ_DOPNG;\n\thctsiz |= 1 << TSIZ_PKTCNT_SHIFT;\n\tdwc2_writel(hsotg, hctsiz, HCTSIZ(chan->hc_num));\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\thcchar |= HCCHAR_CHENA;\n\thcchar &= ~HCCHAR_CHDIS;\n\tdwc2_writel(hsotg, hcchar, HCCHAR(chan->hc_num));\n}\n\n \nstatic void dwc2_hc_start_transfer(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_host_chan *chan)\n{\n\tu32 max_hc_xfer_size = hsotg->params.max_transfer_size;\n\tu16 max_hc_pkt_count = hsotg->params.max_packet_count;\n\tu32 hcchar;\n\tu32 hctsiz = 0;\n\tu16 num_packets;\n\tu32 ec_mc;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tif (chan->do_ping) {\n\t\tif (!hsotg->params.host_dma) {\n\t\t\tif (dbg_hc(chan))\n\t\t\t\tdev_vdbg(hsotg->dev, \"ping, no DMA\\n\");\n\t\t\tdwc2_hc_do_ping(hsotg, chan);\n\t\t\tchan->xfer_started = 1;\n\t\t\treturn;\n\t\t}\n\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"ping, DMA\\n\");\n\n\t\thctsiz |= TSIZ_DOPNG;\n\t}\n\n\tif (chan->do_split) {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"split\\n\");\n\t\tnum_packets = 1;\n\n\t\tif (chan->complete_split && !chan->ep_is_in)\n\t\t\t \n\t\t\tchan->xfer_len = 0;\n\t\telse if (chan->ep_is_in || chan->xfer_len > chan->max_packet)\n\t\t\tchan->xfer_len = chan->max_packet;\n\t\telse if (!chan->ep_is_in && chan->xfer_len > 188)\n\t\t\tchan->xfer_len = 188;\n\n\t\thctsiz |= chan->xfer_len << TSIZ_XFERSIZE_SHIFT &\n\t\t\t  TSIZ_XFERSIZE_MASK;\n\n\t\t \n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tec_mc = 3;\n\t\telse\n\t\t\tec_mc = 1;\n\t} else {\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"no split\\n\");\n\t\t \n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\t \n\t\t\tu32 max_periodic_len =\n\t\t\t\tchan->multi_count * chan->max_packet;\n\n\t\t\tif (chan->xfer_len > max_periodic_len)\n\t\t\t\tchan->xfer_len = max_periodic_len;\n\t\t} else if (chan->xfer_len > max_hc_xfer_size) {\n\t\t\t \n\t\t\tchan->xfer_len =\n\t\t\t\tmax_hc_xfer_size - chan->max_packet + 1;\n\t\t}\n\n\t\tif (chan->xfer_len > 0) {\n\t\t\tnum_packets = (chan->xfer_len + chan->max_packet - 1) /\n\t\t\t\t\tchan->max_packet;\n\t\t\tif (num_packets > max_hc_pkt_count) {\n\t\t\t\tnum_packets = max_hc_pkt_count;\n\t\t\t\tchan->xfer_len = num_packets * chan->max_packet;\n\t\t\t} else if (chan->ep_is_in) {\n\t\t\t\t \n\t\t\t\tchan->xfer_len = num_packets * chan->max_packet;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tnum_packets = 1;\n\t\t}\n\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\t\t \n\t\t\tchan->multi_count = num_packets;\n\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tdwc2_set_pid_isoc(chan);\n\n\t\thctsiz |= chan->xfer_len << TSIZ_XFERSIZE_SHIFT &\n\t\t\t  TSIZ_XFERSIZE_MASK;\n\n\t\t \n\t\tec_mc = chan->multi_count;\n\t}\n\n\tchan->start_pkt_count = num_packets;\n\thctsiz |= num_packets << TSIZ_PKTCNT_SHIFT & TSIZ_PKTCNT_MASK;\n\thctsiz |= chan->data_pid_start << TSIZ_SC_MC_PID_SHIFT &\n\t\t  TSIZ_SC_MC_PID_MASK;\n\tdwc2_writel(hsotg, hctsiz, HCTSIZ(chan->hc_num));\n\tif (dbg_hc(chan)) {\n\t\tdev_vdbg(hsotg->dev, \"Wrote %08x to HCTSIZ(%d)\\n\",\n\t\t\t hctsiz, chan->hc_num);\n\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\", __func__,\n\t\t\t chan->hc_num);\n\t\tdev_vdbg(hsotg->dev, \"\t Xfer Size: %d\\n\",\n\t\t\t (hctsiz & TSIZ_XFERSIZE_MASK) >>\n\t\t\t TSIZ_XFERSIZE_SHIFT);\n\t\tdev_vdbg(hsotg->dev, \"\t Num Pkts: %d\\n\",\n\t\t\t (hctsiz & TSIZ_PKTCNT_MASK) >>\n\t\t\t TSIZ_PKTCNT_SHIFT);\n\t\tdev_vdbg(hsotg->dev, \"\t Start PID: %d\\n\",\n\t\t\t (hctsiz & TSIZ_SC_MC_PID_MASK) >>\n\t\t\t TSIZ_SC_MC_PID_SHIFT);\n\t}\n\n\tif (hsotg->params.host_dma) {\n\t\tdma_addr_t dma_addr;\n\n\t\tif (chan->align_buf) {\n\t\t\tif (dbg_hc(chan))\n\t\t\t\tdev_vdbg(hsotg->dev, \"align_buf\\n\");\n\t\t\tdma_addr = chan->align_buf;\n\t\t} else {\n\t\t\tdma_addr = chan->xfer_dma;\n\t\t}\n\t\tdwc2_writel(hsotg, (u32)dma_addr, HCDMA(chan->hc_num));\n\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"Wrote %08lx to HCDMA(%d)\\n\",\n\t\t\t\t (unsigned long)dma_addr, chan->hc_num);\n\t}\n\n\t \n\tif (chan->do_split) {\n\t\tu32 hcsplt = dwc2_readl(hsotg, HCSPLT(chan->hc_num));\n\n\t\thcsplt |= HCSPLT_SPLTENA;\n\t\tdwc2_writel(hsotg, hcsplt, HCSPLT(chan->hc_num));\n\t}\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\thcchar &= ~HCCHAR_MULTICNT_MASK;\n\thcchar |= (ec_mc << HCCHAR_MULTICNT_SHIFT) & HCCHAR_MULTICNT_MASK;\n\tdwc2_hc_set_even_odd_frame(hsotg, chan, &hcchar);\n\n\tif (hcchar & HCCHAR_CHDIS)\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"%s: chdis set, channel %d, hcchar 0x%08x\\n\",\n\t\t\t __func__, chan->hc_num, hcchar);\n\n\t \n\thcchar |= HCCHAR_CHENA;\n\thcchar &= ~HCCHAR_CHDIS;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"\t Multi Cnt: %d\\n\",\n\t\t\t (hcchar & HCCHAR_MULTICNT_MASK) >>\n\t\t\t HCCHAR_MULTICNT_SHIFT);\n\n\tdwc2_writel(hsotg, hcchar, HCCHAR(chan->hc_num));\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"Wrote %08x to HCCHAR(%d)\\n\", hcchar,\n\t\t\t chan->hc_num);\n\n\tchan->xfer_started = 1;\n\tchan->requests++;\n\n\tif (!hsotg->params.host_dma &&\n\t    !chan->ep_is_in && chan->xfer_len > 0)\n\t\t \n\t\tdwc2_hc_write_packet(hsotg, chan);\n}\n\n \nvoid dwc2_hc_start_transfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan)\n{\n\tu32 hcchar;\n\tu32 hctsiz = 0;\n\n\tif (chan->do_ping)\n\t\thctsiz |= TSIZ_DOPNG;\n\n\tif (chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\tdwc2_set_pid_isoc(chan);\n\n\t \n\thctsiz |= chan->data_pid_start << TSIZ_SC_MC_PID_SHIFT &\n\t\t  TSIZ_SC_MC_PID_MASK;\n\n\t \n\thctsiz |= (chan->ntd - 1) << TSIZ_NTD_SHIFT & TSIZ_NTD_MASK;\n\n\t \n\thctsiz |= chan->schinfo << TSIZ_SCHINFO_SHIFT & TSIZ_SCHINFO_MASK;\n\n\tif (dbg_hc(chan)) {\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\", __func__,\n\t\t\t chan->hc_num);\n\t\tdev_vdbg(hsotg->dev, \"\t Start PID: %d\\n\",\n\t\t\t chan->data_pid_start);\n\t\tdev_vdbg(hsotg->dev, \"\t NTD: %d\\n\", chan->ntd - 1);\n\t}\n\n\tdwc2_writel(hsotg, hctsiz, HCTSIZ(chan->hc_num));\n\n\tdma_sync_single_for_device(hsotg->dev, chan->desc_list_addr,\n\t\t\t\t   chan->desc_list_sz, DMA_TO_DEVICE);\n\n\tdwc2_writel(hsotg, chan->desc_list_addr, HCDMA(chan->hc_num));\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"Wrote %pad to HCDMA(%d)\\n\",\n\t\t\t &chan->desc_list_addr, chan->hc_num);\n\n\thcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\thcchar &= ~HCCHAR_MULTICNT_MASK;\n\thcchar |= chan->multi_count << HCCHAR_MULTICNT_SHIFT &\n\t\t  HCCHAR_MULTICNT_MASK;\n\n\tif (hcchar & HCCHAR_CHDIS)\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"%s: chdis set, channel %d, hcchar 0x%08x\\n\",\n\t\t\t __func__, chan->hc_num, hcchar);\n\n\t \n\thcchar |= HCCHAR_CHENA;\n\thcchar &= ~HCCHAR_CHDIS;\n\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"\t Multi Cnt: %d\\n\",\n\t\t\t (hcchar & HCCHAR_MULTICNT_MASK) >>\n\t\t\t HCCHAR_MULTICNT_SHIFT);\n\n\tdwc2_writel(hsotg, hcchar, HCCHAR(chan->hc_num));\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"Wrote %08x to HCCHAR(%d)\\n\", hcchar,\n\t\t\t chan->hc_num);\n\n\tchan->xfer_started = 1;\n\tchan->requests++;\n}\n\n \nstatic int dwc2_hc_continue_transfer(struct dwc2_hsotg *hsotg,\n\t\t\t\t     struct dwc2_host_chan *chan)\n{\n\tif (dbg_hc(chan))\n\t\tdev_vdbg(hsotg->dev, \"%s: Channel %d\\n\", __func__,\n\t\t\t chan->hc_num);\n\n\tif (chan->do_split)\n\t\t \n\t\treturn 0;\n\n\tif (chan->data_pid_start == DWC2_HC_PID_SETUP)\n\t\t \n\t\treturn 0;\n\n\tif (chan->ep_is_in) {\n\t\t \n\t\tu32 hcchar = dwc2_readl(hsotg, HCCHAR(chan->hc_num));\n\n\t\tdwc2_hc_set_even_odd_frame(hsotg, chan, &hcchar);\n\t\thcchar |= HCCHAR_CHENA;\n\t\thcchar &= ~HCCHAR_CHDIS;\n\t\tif (dbg_hc(chan))\n\t\t\tdev_vdbg(hsotg->dev, \"\t IN xfer: hcchar = 0x%08x\\n\",\n\t\t\t\t hcchar);\n\t\tdwc2_writel(hsotg, hcchar, HCCHAR(chan->hc_num));\n\t\tchan->requests++;\n\t\treturn 1;\n\t}\n\n\t \n\n\tif (chan->xfer_count < chan->xfer_len) {\n\t\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tu32 hcchar = dwc2_readl(hsotg,\n\t\t\t\t\t\tHCCHAR(chan->hc_num));\n\n\t\t\tdwc2_hc_set_even_odd_frame(hsotg, chan,\n\t\t\t\t\t\t   &hcchar);\n\t\t}\n\n\t\t \n\t\tdwc2_hc_write_packet(hsotg, chan);\n\t\tchan->requests++;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n \n\n \nstatic void dwc2_kill_urbs_in_qh_list(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct list_head *qh_list)\n{\n\tstruct dwc2_qh *qh, *qh_tmp;\n\tstruct dwc2_qtd *qtd, *qtd_tmp;\n\n\tlist_for_each_entry_safe(qh, qh_tmp, qh_list, qh_list_entry) {\n\t\tlist_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry) {\n\t\t\tdwc2_host_complete(hsotg, qtd, -ECONNRESET);\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\t\t}\n\t}\n}\n\nstatic void dwc2_qh_list_free(struct dwc2_hsotg *hsotg,\n\t\t\t      struct list_head *qh_list)\n{\n\tstruct dwc2_qtd *qtd, *qtd_tmp;\n\tstruct dwc2_qh *qh, *qh_tmp;\n\tunsigned long flags;\n\n\tif (!qh_list->next)\n\t\t \n\t\treturn;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t \n\tdwc2_kill_urbs_in_qh_list(hsotg, qh_list);\n\n\tlist_for_each_entry_safe(qh, qh_tmp, qh_list, qh_list_entry) {\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\n\t\t \n\t\tlist_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\n\t\tif (qh->channel && qh->channel->qh == qh)\n\t\t\tqh->channel->qh = NULL;\n\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\n \nstatic void dwc2_kill_all_urbs(struct dwc2_hsotg *hsotg)\n{\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_waiting);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->non_periodic_sched_active);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_inactive);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_ready);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_assigned);\n\tdwc2_kill_urbs_in_qh_list(hsotg, &hsotg->periodic_sched_queued);\n}\n\n \nvoid dwc2_hcd_start(struct dwc2_hsotg *hsotg)\n{\n\tu32 hprt0;\n\n\tif (hsotg->op_state == OTG_STATE_B_HOST) {\n\t\t \n\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\thprt0 |= HPRT0_RST;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t}\n\n\tqueue_delayed_work(hsotg->wq_otg, &hsotg->start_work,\n\t\t\t   msecs_to_jiffies(50));\n}\n\n \nstatic void dwc2_hcd_cleanup_channels(struct dwc2_hsotg *hsotg)\n{\n\tint num_channels = hsotg->params.host_channels;\n\tstruct dwc2_host_chan *channel;\n\tu32 hcchar;\n\tint i;\n\n\tif (!hsotg->params.host_dma) {\n\t\t \n\t\tfor (i = 0; i < num_channels; i++) {\n\t\t\tchannel = hsotg->hc_ptr_array[i];\n\t\t\tif (!list_empty(&channel->hc_list_entry))\n\t\t\t\tcontinue;\n\t\t\thcchar = dwc2_readl(hsotg, HCCHAR(i));\n\t\t\tif (hcchar & HCCHAR_CHENA) {\n\t\t\t\thcchar &= ~(HCCHAR_CHENA | HCCHAR_EPDIR);\n\t\t\t\thcchar |= HCCHAR_CHDIS;\n\t\t\t\tdwc2_writel(hsotg, hcchar, HCCHAR(i));\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tchannel = hsotg->hc_ptr_array[i];\n\t\tif (!list_empty(&channel->hc_list_entry))\n\t\t\tcontinue;\n\t\thcchar = dwc2_readl(hsotg, HCCHAR(i));\n\t\tif (hcchar & HCCHAR_CHENA) {\n\t\t\t \n\t\t\thcchar |= HCCHAR_CHDIS;\n\t\t\tdwc2_writel(hsotg, hcchar, HCCHAR(i));\n\t\t}\n\n\t\tdwc2_hc_cleanup(hsotg, channel);\n\t\tlist_add_tail(&channel->hc_list_entry, &hsotg->free_hc_list);\n\t\t \n\t\tchannel->qh = NULL;\n\t}\n\t \n\tif (hsotg->params.uframe_sched) {\n\t\thsotg->available_host_channels =\n\t\t\thsotg->params.host_channels;\n\t} else {\n\t\thsotg->non_periodic_channels = 0;\n\t\thsotg->periodic_channels = 0;\n\t}\n}\n\n \nvoid dwc2_hcd_connect(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->lx_state != DWC2_L0)\n\t\tusb_hcd_resume_root_hub(hsotg->priv);\n\n\thsotg->flags.b.port_connect_status_change = 1;\n\thsotg->flags.b.port_connect_status = 1;\n}\n\n \nvoid dwc2_hcd_disconnect(struct dwc2_hsotg *hsotg, bool force)\n{\n\tu32 intr;\n\tu32 hprt0;\n\n\t \n\thsotg->flags.b.port_connect_status_change = 1;\n\thsotg->flags.b.port_connect_status = 0;\n\n\t \n\tintr = dwc2_readl(hsotg, GINTMSK);\n\tintr &= ~(GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT);\n\tdwc2_writel(hsotg, intr, GINTMSK);\n\tintr = GINTSTS_NPTXFEMP | GINTSTS_PTXFEMP | GINTSTS_HCHINT;\n\tdwc2_writel(hsotg, intr, GINTSTS);\n\n\t \n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tif (hsotg->op_state != OTG_STATE_A_SUSPEND) {\n\t\t\tdev_dbg(hsotg->dev, \"Disconnect: PortPower off\\n\");\n\t\t\tdwc2_writel(hsotg, 0, HPRT0);\n\t\t}\n\n\t\tdwc2_disable_host_interrupts(hsotg);\n\t}\n\n\t \n\tdwc2_kill_all_urbs(hsotg);\n\n\tif (dwc2_is_host_mode(hsotg))\n\t\t \n\t\tdwc2_hcd_cleanup_channels(hsotg);\n\n\tdwc2_host_disconnect(hsotg);\n\n\t \n\tif (!force) {\n\t\thprt0 = dwc2_readl(hsotg, HPRT0);\n\t\tif (!(hprt0 & HPRT0_CONNDET) && (hprt0 & HPRT0_CONNSTS))\n\t\t\tdwc2_hcd_connect(hsotg);\n\t}\n}\n\n \nstatic void dwc2_hcd_rem_wakeup(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->bus_suspended) {\n\t\thsotg->flags.b.port_suspend_change = 1;\n\t\tusb_hcd_resume_root_hub(hsotg->priv);\n\t}\n\n\tif (hsotg->lx_state == DWC2_L1)\n\t\thsotg->flags.b.port_l1_change = 1;\n}\n\n \nvoid dwc2_hcd_stop(struct dwc2_hsotg *hsotg)\n{\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD STOP\\n\");\n\n\t \n\n\t \n\tdwc2_disable_host_interrupts(hsotg);\n\n\t \n\tdev_dbg(hsotg->dev, \"PortPower off\\n\");\n\tdwc2_writel(hsotg, 0, HPRT0);\n}\n\n \nstatic int dwc2_hcd_urb_enqueue(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_hcd_urb *urb, struct dwc2_qh *qh,\n\t\t\t\tstruct dwc2_qtd *qtd)\n{\n\tu32 intr_mask;\n\tint retval;\n\tint dev_speed;\n\n\tif (!hsotg->flags.b.port_connect_status) {\n\t\t \n\t\tdev_err(hsotg->dev, \"Not connected\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tdev_speed = dwc2_host_get_speed(hsotg, urb->priv);\n\n\t \n\tif ((dev_speed == USB_SPEED_LOW) &&\n\t    (hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED) &&\n\t    (hsotg->hw_params.hs_phy_type == GHWCFG2_HS_PHY_TYPE_UTMI)) {\n\t\tu32 hprt0 = dwc2_readl(hsotg, HPRT0);\n\t\tu32 prtspd = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\n\n\t\tif (prtspd == HPRT0_SPD_FULL_SPEED)\n\t\t\treturn -ENODEV;\n\t}\n\n\tif (!qtd)\n\t\treturn -EINVAL;\n\n\tdwc2_hcd_qtd_init(qtd, urb);\n\tretval = dwc2_hcd_qtd_add(hsotg, qtd, qh);\n\tif (retval) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"DWC OTG HCD URB Enqueue failed adding QTD. Error status %d\\n\",\n\t\t\tretval);\n\t\treturn retval;\n\t}\n\n\tintr_mask = dwc2_readl(hsotg, GINTMSK);\n\tif (!(intr_mask & GINTSTS_SOF)) {\n\t\tenum dwc2_transaction_type tr_type;\n\n\t\tif (qtd->qh->ep_type == USB_ENDPOINT_XFER_BULK &&\n\t\t    !(qtd->urb->flags & URB_GIVEBACK_ASAP))\n\t\t\t \n\t\t\treturn 0;\n\n\t\ttr_type = dwc2_hcd_select_transactions(hsotg);\n\t\tif (tr_type != DWC2_TRANSACTION_NONE)\n\t\t\tdwc2_hcd_queue_transactions(hsotg, tr_type);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dwc2_hcd_urb_dequeue(struct dwc2_hsotg *hsotg,\n\t\t\t\tstruct dwc2_hcd_urb *urb)\n{\n\tstruct dwc2_qh *qh;\n\tstruct dwc2_qtd *urb_qtd;\n\n\turb_qtd = urb->qtd;\n\tif (!urb_qtd) {\n\t\tdev_dbg(hsotg->dev, \"## Urb QTD is NULL ##\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tqh = urb_qtd->qh;\n\tif (!qh) {\n\t\tdev_dbg(hsotg->dev, \"## Urb QTD QH is NULL ##\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\turb->priv = NULL;\n\n\tif (urb_qtd->in_process && qh->channel) {\n\t\tdwc2_dump_channel_info(hsotg, qh->channel);\n\n\t\t \n\t\tif (hsotg->flags.b.port_connect_status)\n\t\t\t \n\t\t\tdwc2_hc_halt(hsotg, qh->channel,\n\t\t\t\t     DWC2_HC_XFER_URB_DEQUEUE);\n\t}\n\n\t \n\tif (!hsotg->params.dma_desc_enable) {\n\t\tu8 in_process = urb_qtd->in_process;\n\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, urb_qtd, qh);\n\t\tif (in_process) {\n\t\t\tdwc2_hcd_qh_deactivate(hsotg, qh, 0);\n\t\t\tqh->channel = NULL;\n\t\t} else if (list_empty(&qh->qtd_list)) {\n\t\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t}\n\t} else {\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, urb_qtd, qh);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dwc2_hcd_endpoint_disable(struct dwc2_hsotg *hsotg,\n\t\t\t\t     struct usb_host_endpoint *ep, int retry)\n{\n\tstruct dwc2_qtd *qtd, *qtd_tmp;\n\tstruct dwc2_qh *qh;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tqh = ep->hcpriv;\n\tif (!qh) {\n\t\trc = -EINVAL;\n\t\tgoto err;\n\t}\n\n\twhile (!list_empty(&qh->qtd_list) && retry--) {\n\t\tif (retry == 0) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"## timeout in dwc2_hcd_endpoint_disable() ##\\n\");\n\t\t\trc = -EBUSY;\n\t\t\tgoto err;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tmsleep(20);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tqh = ep->hcpriv;\n\t\tif (!qh) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tdwc2_hcd_qh_unlink(hsotg, qh);\n\n\t \n\tlist_for_each_entry_safe(qtd, qtd_tmp, &qh->qtd_list, qtd_list_entry)\n\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd, qh);\n\n\tep->hcpriv = NULL;\n\n\tif (qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh = NULL;\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tdwc2_hcd_qh_free(hsotg, qh);\n\n\treturn 0;\n\nerr:\n\tep->hcpriv = NULL;\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn rc;\n}\n\n \nstatic int dwc2_hcd_endpoint_reset(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_qh *qh = ep->hcpriv;\n\n\tif (!qh)\n\t\treturn -EINVAL;\n\n\tqh->data_toggle = DWC2_HC_PID_DATA0;\n\n\treturn 0;\n}\n\n \nint dwc2_core_init(struct dwc2_hsotg *hsotg, bool initial_setup)\n{\n\tu32 usbcfg, otgctl;\n\tint retval;\n\n\tdev_dbg(hsotg->dev, \"%s(%p)\\n\", __func__, hsotg);\n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\n\t \n\tusbcfg &= ~GUSBCFG_ULPI_EXT_VBUS_DRV;\n\tif (hsotg->params.phy_ulpi_ext_vbus)\n\t\tusbcfg |= GUSBCFG_ULPI_EXT_VBUS_DRV;\n\n\t \n\tusbcfg &= ~GUSBCFG_TERMSELDLPULSE;\n\tif (hsotg->params.ts_dline)\n\t\tusbcfg |= GUSBCFG_TERMSELDLPULSE;\n\n\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\t \n\tif (!initial_setup) {\n\t\tretval = dwc2_core_reset(hsotg, false);\n\t\tif (retval) {\n\t\t\tdev_err(hsotg->dev, \"%s(): Reset failed, aborting\\n\",\n\t\t\t\t__func__);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\t \n\tretval = dwc2_phy_init(hsotg, initial_setup);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tretval = dwc2_gahbcfg_init(hsotg);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tdwc2_gusbcfg_init(hsotg);\n\n\t \n\totgctl = dwc2_readl(hsotg, GOTGCTL);\n\totgctl &= ~GOTGCTL_OTGVER;\n\tdwc2_writel(hsotg, otgctl, GOTGCTL);\n\n\t \n\thsotg->srp_success = 0;\n\n\t \n\tdwc2_enable_common_interrupts(hsotg);\n\n\t \n\tif (dwc2_is_host_mode(hsotg)) {\n\t\tdev_dbg(hsotg->dev, \"Host Mode\\n\");\n\t\thsotg->op_state = OTG_STATE_A_HOST;\n\t} else {\n\t\tdev_dbg(hsotg->dev, \"Device Mode\\n\");\n\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dwc2_core_host_init(struct dwc2_hsotg *hsotg)\n{\n\tu32 hcfg, hfir, otgctl, usbcfg;\n\n\tdev_dbg(hsotg->dev, \"%s(%p)\\n\", __func__, hsotg);\n\n\t \n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tusbcfg |= GUSBCFG_TOUTCAL(7);\n\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\t \n\tdwc2_writel(hsotg, 0, PCGCTL);\n\n\t \n\tdwc2_init_fs_ls_pclk_sel(hsotg);\n\tif (hsotg->params.speed == DWC2_SPEED_PARAM_FULL ||\n\t    hsotg->params.speed == DWC2_SPEED_PARAM_LOW) {\n\t\thcfg = dwc2_readl(hsotg, HCFG);\n\t\thcfg |= HCFG_FSLSSUPP;\n\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t}\n\n\t \n\tif (hsotg->params.reload_ctl) {\n\t\thfir = dwc2_readl(hsotg, HFIR);\n\t\thfir |= HFIR_RLDCTRL;\n\t\tdwc2_writel(hsotg, hfir, HFIR);\n\t}\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tu32 op_mode = hsotg->hw_params.op_mode;\n\n\t\tif (hsotg->hw_params.snpsid < DWC2_CORE_REV_2_90a ||\n\t\t    !hsotg->hw_params.dma_desc_enable ||\n\t\t    op_mode == GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE ||\n\t\t    op_mode == GHWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE ||\n\t\t    op_mode == GHWCFG2_OP_MODE_UNDEFINED) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Hardware does not support descriptor DMA mode -\\n\");\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"falling back to buffer DMA mode.\\n\");\n\t\t\thsotg->params.dma_desc_enable = false;\n\t\t} else {\n\t\t\thcfg = dwc2_readl(hsotg, HCFG);\n\t\t\thcfg |= HCFG_DESCDMA;\n\t\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t\t}\n\t}\n\n\t \n\tdwc2_config_fifos(hsotg);\n\n\t \n\t \n\totgctl = dwc2_readl(hsotg, GOTGCTL);\n\totgctl &= ~GOTGCTL_HSTSETHNPEN;\n\tdwc2_writel(hsotg, otgctl, GOTGCTL);\n\n\t \n\tdwc2_flush_tx_fifo(hsotg, 0x10  );\n\tdwc2_flush_rx_fifo(hsotg);\n\n\t \n\totgctl = dwc2_readl(hsotg, GOTGCTL);\n\totgctl &= ~GOTGCTL_HSTSETHNPEN;\n\tdwc2_writel(hsotg, otgctl, GOTGCTL);\n\n\tif (!hsotg->params.dma_desc_enable) {\n\t\tint num_channels, i;\n\t\tu32 hcchar;\n\n\t\t \n\t\tnum_channels = hsotg->params.host_channels;\n\t\tfor (i = 0; i < num_channels; i++) {\n\t\t\thcchar = dwc2_readl(hsotg, HCCHAR(i));\n\t\t\tif (hcchar & HCCHAR_CHENA) {\n\t\t\t\thcchar &= ~HCCHAR_CHENA;\n\t\t\t\thcchar |= HCCHAR_CHDIS;\n\t\t\t\thcchar &= ~HCCHAR_EPDIR;\n\t\t\t\tdwc2_writel(hsotg, hcchar, HCCHAR(i));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tfor (i = 0; i < num_channels; i++) {\n\t\t\thcchar = dwc2_readl(hsotg, HCCHAR(i));\n\t\t\tif (hcchar & HCCHAR_CHENA) {\n\t\t\t\thcchar |= HCCHAR_CHENA | HCCHAR_CHDIS;\n\t\t\t\thcchar &= ~HCCHAR_EPDIR;\n\t\t\t\tdwc2_writel(hsotg, hcchar, HCCHAR(i));\n\t\t\t\tdev_dbg(hsotg->dev, \"%s: Halt channel %d\\n\",\n\t\t\t\t\t__func__, i);\n\n\t\t\t\tif (dwc2_hsotg_wait_bit_clear(hsotg, HCCHAR(i),\n\t\t\t\t\t\t\t      HCCHAR_CHENA,\n\t\t\t\t\t\t\t      1000)) {\n\t\t\t\t\tdev_warn(hsotg->dev,\n\t\t\t\t\t\t \"Unable to clear enable on channel %d\\n\",\n\t\t\t\t\t\t i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdwc2_enable_acg(hsotg);\n\n\t \n\tdev_dbg(hsotg->dev, \"Init: Port Power? op_state=%d\\n\", hsotg->op_state);\n\tif (hsotg->op_state == OTG_STATE_A_HOST) {\n\t\tu32 hprt0 = dwc2_read_hprt0(hsotg);\n\n\t\tdev_dbg(hsotg->dev, \"Init: Power Port (%d)\\n\",\n\t\t\t!!(hprt0 & HPRT0_PWR));\n\t\tif (!(hprt0 & HPRT0_PWR)) {\n\t\t\thprt0 |= HPRT0_PWR;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t}\n\t}\n\n\tdwc2_enable_host_interrupts(hsotg);\n}\n\n \nstatic void dwc2_hcd_reinit(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_host_chan *chan, *chan_tmp;\n\tint num_channels;\n\tint i;\n\n\thsotg->flags.d32 = 0;\n\thsotg->non_periodic_qh_ptr = &hsotg->non_periodic_sched_active;\n\n\tif (hsotg->params.uframe_sched) {\n\t\thsotg->available_host_channels =\n\t\t\thsotg->params.host_channels;\n\t} else {\n\t\thsotg->non_periodic_channels = 0;\n\t\thsotg->periodic_channels = 0;\n\t}\n\n\t \n\tlist_for_each_entry_safe(chan, chan_tmp, &hsotg->free_hc_list,\n\t\t\t\t hc_list_entry)\n\t\tlist_del_init(&chan->hc_list_entry);\n\n\tnum_channels = hsotg->params.host_channels;\n\tfor (i = 0; i < num_channels; i++) {\n\t\tchan = hsotg->hc_ptr_array[i];\n\t\tlist_add_tail(&chan->hc_list_entry, &hsotg->free_hc_list);\n\t\tdwc2_hc_cleanup(hsotg, chan);\n\t}\n\n\t \n\tdwc2_core_host_init(hsotg);\n}\n\nstatic void dwc2_hc_init_split(struct dwc2_hsotg *hsotg,\n\t\t\t       struct dwc2_host_chan *chan,\n\t\t\t       struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb)\n{\n\tint hub_addr, hub_port;\n\n\tchan->do_split = 1;\n\tchan->xact_pos = qtd->isoc_split_pos;\n\tchan->complete_split = qtd->complete_split;\n\tdwc2_host_hub_info(hsotg, urb->priv, &hub_addr, &hub_port);\n\tchan->hub_addr = (u8)hub_addr;\n\tchan->hub_port = (u8)hub_port;\n}\n\nstatic void dwc2_hc_init_xfer(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_host_chan *chan,\n\t\t\t      struct dwc2_qtd *qtd)\n{\n\tstruct dwc2_hcd_urb *urb = qtd->urb;\n\tstruct dwc2_hcd_iso_packet_desc *frame_desc;\n\n\tswitch (dwc2_hcd_get_pipe_type(&urb->pipe_info)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tchan->ep_type = USB_ENDPOINT_XFER_CONTROL;\n\n\t\tswitch (qtd->control_phase) {\n\t\tcase DWC2_CONTROL_SETUP:\n\t\t\tdev_vdbg(hsotg->dev, \"  Control setup transaction\\n\");\n\t\t\tchan->do_ping = 0;\n\t\t\tchan->ep_is_in = 0;\n\t\t\tchan->data_pid_start = DWC2_HC_PID_SETUP;\n\t\t\tif (hsotg->params.host_dma)\n\t\t\t\tchan->xfer_dma = urb->setup_dma;\n\t\t\telse\n\t\t\t\tchan->xfer_buf = urb->setup_packet;\n\t\t\tchan->xfer_len = 8;\n\t\t\tbreak;\n\n\t\tcase DWC2_CONTROL_DATA:\n\t\t\tdev_vdbg(hsotg->dev, \"  Control data transaction\\n\");\n\t\t\tchan->data_pid_start = qtd->data_toggle;\n\t\t\tbreak;\n\n\t\tcase DWC2_CONTROL_STATUS:\n\t\t\t \n\t\t\tdev_vdbg(hsotg->dev, \"  Control status transaction\\n\");\n\t\t\tif (urb->length == 0)\n\t\t\t\tchan->ep_is_in = 1;\n\t\t\telse\n\t\t\t\tchan->ep_is_in =\n\t\t\t\t\tdwc2_hcd_is_pipe_out(&urb->pipe_info);\n\t\t\tif (chan->ep_is_in)\n\t\t\t\tchan->do_ping = 0;\n\t\t\tchan->data_pid_start = DWC2_HC_PID_DATA1;\n\t\t\tchan->xfer_len = 0;\n\t\t\tif (hsotg->params.host_dma)\n\t\t\t\tchan->xfer_dma = hsotg->status_buf_dma;\n\t\t\telse\n\t\t\t\tchan->xfer_buf = hsotg->status_buf;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tchan->ep_type = USB_ENDPOINT_XFER_BULK;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tchan->ep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tchan->ep_type = USB_ENDPOINT_XFER_ISOC;\n\t\tif (hsotg->params.dma_desc_enable)\n\t\t\tbreak;\n\n\t\tframe_desc = &urb->iso_descs[qtd->isoc_frame_index];\n\t\tframe_desc->status = 0;\n\n\t\tif (hsotg->params.host_dma) {\n\t\t\tchan->xfer_dma = urb->dma;\n\t\t\tchan->xfer_dma += frame_desc->offset +\n\t\t\t\t\tqtd->isoc_split_offset;\n\t\t} else {\n\t\t\tchan->xfer_buf = urb->buf;\n\t\t\tchan->xfer_buf += frame_desc->offset +\n\t\t\t\t\tqtd->isoc_split_offset;\n\t\t}\n\n\t\tchan->xfer_len = frame_desc->length - qtd->isoc_split_offset;\n\n\t\tif (chan->xact_pos == DWC2_HCSPLT_XACTPOS_ALL) {\n\t\t\tif (chan->xfer_len <= 188)\n\t\t\t\tchan->xact_pos = DWC2_HCSPLT_XACTPOS_ALL;\n\t\t\telse\n\t\t\t\tchan->xact_pos = DWC2_HCSPLT_XACTPOS_BEGIN;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int dwc2_alloc_split_dma_aligned_buf(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t    struct dwc2_qh *qh,\n\t\t\t\t\t    struct dwc2_host_chan *chan)\n{\n\tif (!hsotg->unaligned_cache ||\n\t    chan->max_packet > DWC2_KMEM_UNALIGNED_BUF_SIZE)\n\t\treturn -ENOMEM;\n\n\tif (!qh->dw_align_buf) {\n\t\tqh->dw_align_buf = kmem_cache_alloc(hsotg->unaligned_cache,\n\t\t\t\t\t\t    GFP_ATOMIC | GFP_DMA);\n\t\tif (!qh->dw_align_buf)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tqh->dw_align_buf_dma = dma_map_single(hsotg->dev, qh->dw_align_buf,\n\t\t\t\t\t      DWC2_KMEM_UNALIGNED_BUF_SIZE,\n\t\t\t\t\t      DMA_FROM_DEVICE);\n\n\tif (dma_mapping_error(hsotg->dev, qh->dw_align_buf_dma)) {\n\t\tdev_err(hsotg->dev, \"can't map align_buf\\n\");\n\t\tchan->align_buf = 0;\n\t\treturn -EINVAL;\n\t}\n\n\tchan->align_buf = qh->dw_align_buf_dma;\n\treturn 0;\n}\n\n#define DWC2_USB_DMA_ALIGN 4\n\nstatic void dwc2_free_dma_aligned_buffer(struct urb *urb)\n{\n\tvoid *stored_xfer_buffer;\n\tsize_t length;\n\n\tif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\n\t\treturn;\n\n\t \n\tmemcpy(&stored_xfer_buffer,\n\t       PTR_ALIGN(urb->transfer_buffer + urb->transfer_buffer_length,\n\t\t\t dma_get_cache_alignment()),\n\t       sizeof(urb->transfer_buffer));\n\n\tif (usb_urb_dir_in(urb)) {\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tlength = urb->transfer_buffer_length;\n\t\telse\n\t\t\tlength = urb->actual_length;\n\n\t\tmemcpy(stored_xfer_buffer, urb->transfer_buffer, length);\n\t}\n\tkfree(urb->transfer_buffer);\n\turb->transfer_buffer = stored_xfer_buffer;\n\n\turb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\n}\n\nstatic int dwc2_alloc_dma_aligned_buffer(struct urb *urb, gfp_t mem_flags)\n{\n\tvoid *kmalloc_ptr;\n\tsize_t kmalloc_size;\n\n\tif (urb->num_sgs || urb->sg ||\n\t    urb->transfer_buffer_length == 0 ||\n\t    !((uintptr_t)urb->transfer_buffer & (DWC2_USB_DMA_ALIGN - 1)))\n\t\treturn 0;\n\n\t \n\tkmalloc_size = urb->transfer_buffer_length +\n\t\t(dma_get_cache_alignment() - 1) +\n\t\tsizeof(urb->transfer_buffer);\n\n\tkmalloc_ptr = kmalloc(kmalloc_size, mem_flags);\n\tif (!kmalloc_ptr)\n\t\treturn -ENOMEM;\n\n\t \n\tmemcpy(PTR_ALIGN(kmalloc_ptr + urb->transfer_buffer_length,\n\t\t\t dma_get_cache_alignment()),\n\t       &urb->transfer_buffer, sizeof(urb->transfer_buffer));\n\n\tif (usb_urb_dir_out(urb))\n\t\tmemcpy(kmalloc_ptr, urb->transfer_buffer,\n\t\t       urb->transfer_buffer_length);\n\turb->transfer_buffer = kmalloc_ptr;\n\n\turb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\n\n\treturn 0;\n}\n\nstatic int dwc2_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\tgfp_t mem_flags)\n{\n\tint ret;\n\n\t \n\tWARN_ON_ONCE(urb->setup_dma &&\n\t\t     (urb->setup_dma & (DWC2_USB_DMA_ALIGN - 1)));\n\n\tret = dwc2_alloc_dma_aligned_buffer(urb, mem_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n\tif (ret)\n\t\tdwc2_free_dma_aligned_buffer(urb);\n\n\treturn ret;\n}\n\nstatic void dwc2_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n\tdwc2_free_dma_aligned_buffer(urb);\n}\n\n \nstatic int dwc2_assign_and_init_hc(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tstruct dwc2_host_chan *chan;\n\tstruct dwc2_hcd_urb *urb;\n\tstruct dwc2_qtd *qtd;\n\n\tif (dbg_qh(qh))\n\t\tdev_vdbg(hsotg->dev, \"%s(%p,%p)\\n\", __func__, hsotg, qh);\n\n\tif (list_empty(&qh->qtd_list)) {\n\t\tdev_dbg(hsotg->dev, \"No QTDs in QH list\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (list_empty(&hsotg->free_hc_list)) {\n\t\tdev_dbg(hsotg->dev, \"No free channel to assign\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tchan = list_first_entry(&hsotg->free_hc_list, struct dwc2_host_chan,\n\t\t\t\thc_list_entry);\n\n\t \n\tlist_del_init(&chan->hc_list_entry);\n\n\tqtd = list_first_entry(&qh->qtd_list, struct dwc2_qtd, qtd_list_entry);\n\turb = qtd->urb;\n\tqh->channel = chan;\n\tqtd->in_process = 1;\n\n\t \n\tchan->dev_addr = dwc2_hcd_get_dev_addr(&urb->pipe_info);\n\tchan->ep_num = dwc2_hcd_get_ep_num(&urb->pipe_info);\n\tchan->speed = qh->dev_speed;\n\tchan->max_packet = qh->maxp;\n\n\tchan->xfer_started = 0;\n\tchan->halt_status = DWC2_HC_XFER_NO_HALT_STATUS;\n\tchan->error_state = (qtd->error_count > 0);\n\tchan->halt_on_queue = 0;\n\tchan->halt_pending = 0;\n\tchan->requests = 0;\n\n\t \n\n\tchan->ep_is_in = (dwc2_hcd_is_pipe_in(&urb->pipe_info) != 0);\n\tif (chan->ep_is_in)\n\t\tchan->do_ping = 0;\n\telse\n\t\tchan->do_ping = qh->ping_state;\n\n\tchan->data_pid_start = qh->data_toggle;\n\tchan->multi_count = 1;\n\n\tif (urb->actual_length > urb->length &&\n\t    !dwc2_hcd_is_pipe_in(&urb->pipe_info))\n\t\turb->actual_length = urb->length;\n\n\tif (hsotg->params.host_dma)\n\t\tchan->xfer_dma = urb->dma + urb->actual_length;\n\telse\n\t\tchan->xfer_buf = (u8 *)urb->buf + urb->actual_length;\n\n\tchan->xfer_len = urb->length - urb->actual_length;\n\tchan->xfer_count = 0;\n\n\t \n\tif (qh->do_split)\n\t\tdwc2_hc_init_split(hsotg, chan, qtd, urb);\n\telse\n\t\tchan->do_split = 0;\n\n\t \n\tdwc2_hc_init_xfer(hsotg, chan, qtd);\n\n\t \n\tif (hsotg->params.host_dma && qh->do_split &&\n\t    chan->ep_is_in && (chan->xfer_dma & 0x3)) {\n\t\tdev_vdbg(hsotg->dev, \"Non-aligned buffer\\n\");\n\t\tif (dwc2_alloc_split_dma_aligned_buf(hsotg, qh, chan)) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Failed to allocate memory to handle non-aligned buffer\\n\");\n\t\t\t \n\t\t\tchan->align_buf = 0;\n\t\t\tchan->multi_count = 0;\n\t\t\tlist_add_tail(&chan->hc_list_entry,\n\t\t\t\t      &hsotg->free_hc_list);\n\t\t\tqtd->in_process = 0;\n\t\t\tqh->channel = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\t \n\t\tWARN_ON_ONCE(hsotg->params.host_dma &&\n\t\t\t     (chan->xfer_dma & 0x3));\n\t\tchan->align_buf = 0;\n\t}\n\n\tif (chan->ep_type == USB_ENDPOINT_XFER_INT ||\n\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\t \n\t\tchan->multi_count = qh->maxp_mult;\n\n\tif (hsotg->params.dma_desc_enable) {\n\t\tchan->desc_list_addr = qh->desc_list_dma;\n\t\tchan->desc_list_sz = qh->desc_list_sz;\n\t}\n\n\tdwc2_hc_init(hsotg, chan);\n\tchan->qh = qh;\n\n\treturn 0;\n}\n\n \nenum dwc2_transaction_type dwc2_hcd_select_transactions(\n\t\tstruct dwc2_hsotg *hsotg)\n{\n\tenum dwc2_transaction_type ret_val = DWC2_TRANSACTION_NONE;\n\tstruct list_head *qh_ptr;\n\tstruct dwc2_qh *qh;\n\tint num_channels;\n\n#ifdef DWC2_DEBUG_SOF\n\tdev_vdbg(hsotg->dev, \"  Select Transactions\\n\");\n#endif\n\n\t \n\tqh_ptr = hsotg->periodic_sched_ready.next;\n\twhile (qh_ptr != &hsotg->periodic_sched_ready) {\n\t\tif (list_empty(&hsotg->free_hc_list))\n\t\t\tbreak;\n\t\tif (hsotg->params.uframe_sched) {\n\t\t\tif (hsotg->available_host_channels <= 1)\n\t\t\t\tbreak;\n\t\t\thsotg->available_host_channels--;\n\t\t}\n\t\tqh = list_entry(qh_ptr, struct dwc2_qh, qh_list_entry);\n\t\tif (dwc2_assign_and_init_hc(hsotg, qh))\n\t\t\tbreak;\n\n\t\t \n\t\tqh_ptr = qh_ptr->next;\n\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t       &hsotg->periodic_sched_assigned);\n\t\tret_val = DWC2_TRANSACTION_PERIODIC;\n\t}\n\n\t \n\tnum_channels = hsotg->params.host_channels;\n\tqh_ptr = hsotg->non_periodic_sched_inactive.next;\n\twhile (qh_ptr != &hsotg->non_periodic_sched_inactive) {\n\t\tif (!hsotg->params.uframe_sched &&\n\t\t    hsotg->non_periodic_channels >= num_channels -\n\t\t\t\t\t\thsotg->periodic_channels)\n\t\t\tbreak;\n\t\tif (list_empty(&hsotg->free_hc_list))\n\t\t\tbreak;\n\t\tqh = list_entry(qh_ptr, struct dwc2_qh, qh_list_entry);\n\t\tif (hsotg->params.uframe_sched) {\n\t\t\tif (hsotg->available_host_channels < 1)\n\t\t\t\tbreak;\n\t\t\thsotg->available_host_channels--;\n\t\t}\n\n\t\tif (dwc2_assign_and_init_hc(hsotg, qh))\n\t\t\tbreak;\n\n\t\t \n\t\tqh_ptr = qh_ptr->next;\n\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t       &hsotg->non_periodic_sched_active);\n\n\t\tif (ret_val == DWC2_TRANSACTION_NONE)\n\t\t\tret_val = DWC2_TRANSACTION_NON_PERIODIC;\n\t\telse\n\t\t\tret_val = DWC2_TRANSACTION_ALL;\n\n\t\tif (!hsotg->params.uframe_sched)\n\t\t\thsotg->non_periodic_channels++;\n\t}\n\n\treturn ret_val;\n}\n\n \nstatic int dwc2_queue_transaction(struct dwc2_hsotg *hsotg,\n\t\t\t\t  struct dwc2_host_chan *chan,\n\t\t\t\t  u16 fifo_dwords_avail)\n{\n\tint retval = 0;\n\n\tif (chan->do_split)\n\t\t \n\t\tlist_move_tail(&chan->split_order_list_entry,\n\t\t\t       &hsotg->split_order);\n\n\tif (hsotg->params.host_dma && chan->qh) {\n\t\tif (hsotg->params.dma_desc_enable) {\n\t\t\tif (!chan->xfer_started ||\n\t\t\t    chan->ep_type == USB_ENDPOINT_XFER_ISOC) {\n\t\t\t\tdwc2_hcd_start_xfer_ddma(hsotg, chan->qh);\n\t\t\t\tchan->qh->ping_state = 0;\n\t\t\t}\n\t\t} else if (!chan->xfer_started) {\n\t\t\tdwc2_hc_start_transfer(hsotg, chan);\n\t\t\tchan->qh->ping_state = 0;\n\t\t}\n\t} else if (chan->halt_pending) {\n\t\t \n\t} else if (chan->halt_on_queue) {\n\t\tdwc2_hc_halt(hsotg, chan, chan->halt_status);\n\t} else if (chan->do_ping) {\n\t\tif (!chan->xfer_started)\n\t\t\tdwc2_hc_start_transfer(hsotg, chan);\n\t} else if (!chan->ep_is_in ||\n\t\t   chan->data_pid_start == DWC2_HC_PID_SETUP) {\n\t\tif ((fifo_dwords_avail * 4) >= chan->max_packet) {\n\t\t\tif (!chan->xfer_started) {\n\t\t\t\tdwc2_hc_start_transfer(hsotg, chan);\n\t\t\t\tretval = 1;\n\t\t\t} else {\n\t\t\t\tretval = dwc2_hc_continue_transfer(hsotg, chan);\n\t\t\t}\n\t\t} else {\n\t\t\tretval = -1;\n\t\t}\n\t} else {\n\t\tif (!chan->xfer_started) {\n\t\t\tdwc2_hc_start_transfer(hsotg, chan);\n\t\t\tretval = 1;\n\t\t} else {\n\t\t\tretval = dwc2_hc_continue_transfer(hsotg, chan);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\n \nstatic void dwc2_process_periodic_channels(struct dwc2_hsotg *hsotg)\n{\n\tstruct list_head *qh_ptr;\n\tstruct dwc2_qh *qh;\n\tu32 tx_status;\n\tu32 fspcavail;\n\tu32 gintmsk;\n\tint status;\n\tbool no_queue_space = false;\n\tbool no_fifo_space = false;\n\tu32 qspcavail;\n\n\t \n\tif (list_empty(&hsotg->periodic_sched_assigned))\n\t\tgoto exit;\n\n\tif (dbg_perio())\n\t\tdev_vdbg(hsotg->dev, \"Queue periodic transactions\\n\");\n\n\ttx_status = dwc2_readl(hsotg, HPTXSTS);\n\tqspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>\n\t\t    TXSTS_QSPCAVAIL_SHIFT;\n\tfspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>\n\t\t    TXSTS_FSPCAVAIL_SHIFT;\n\n\tif (dbg_perio()) {\n\t\tdev_vdbg(hsotg->dev, \"  P Tx Req Queue Space Avail (before queue): %d\\n\",\n\t\t\t qspcavail);\n\t\tdev_vdbg(hsotg->dev, \"  P Tx FIFO Space Avail (before queue): %d\\n\",\n\t\t\t fspcavail);\n\t}\n\n\tqh_ptr = hsotg->periodic_sched_assigned.next;\n\twhile (qh_ptr != &hsotg->periodic_sched_assigned) {\n\t\ttx_status = dwc2_readl(hsotg, HPTXSTS);\n\t\tqspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_QSPCAVAIL_SHIFT;\n\t\tif (qspcavail == 0) {\n\t\t\tno_queue_space = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tqh = list_entry(qh_ptr, struct dwc2_qh, qh_list_entry);\n\t\tif (!qh->channel) {\n\t\t\tqh_ptr = qh_ptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (qh->tt_buffer_dirty) {\n\t\t\tqh_ptr = qh_ptr->next;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif (!hsotg->params.host_dma &&\n\t\t    qh->channel->multi_count > 1)\n\t\t\thsotg->queuing_high_bandwidth = 1;\n\n\t\tfspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_FSPCAVAIL_SHIFT;\n\t\tstatus = dwc2_queue_transaction(hsotg, qh->channel, fspcavail);\n\t\tif (status < 0) {\n\t\t\tno_fifo_space = true;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (hsotg->params.host_dma || status == 0 ||\n\t\t    qh->channel->requests == qh->channel->multi_count) {\n\t\t\tqh_ptr = qh_ptr->next;\n\t\t\t \n\t\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t\t       &hsotg->periodic_sched_queued);\n\n\t\t\t \n\t\t\thsotg->queuing_high_bandwidth = 0;\n\t\t}\n\t}\n\nexit:\n\tif (no_queue_space || no_fifo_space ||\n\t    (!hsotg->params.host_dma &&\n\t     !list_empty(&hsotg->periodic_sched_assigned))) {\n\t\t \n\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\tif (!(gintmsk & GINTSTS_PTXFEMP)) {\n\t\t\tgintmsk |= GINTSTS_PTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t}\n\t} else {\n\t\t \n\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\tif (gintmsk & GINTSTS_PTXFEMP) {\n\t\t\tgintmsk &= ~GINTSTS_PTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t}\n\t}\n}\n\n \nstatic void dwc2_process_non_periodic_channels(struct dwc2_hsotg *hsotg)\n{\n\tstruct list_head *orig_qh_ptr;\n\tstruct dwc2_qh *qh;\n\tu32 tx_status;\n\tu32 qspcavail;\n\tu32 fspcavail;\n\tu32 gintmsk;\n\tint status;\n\tint no_queue_space = 0;\n\tint no_fifo_space = 0;\n\tint more_to_do = 0;\n\n\tdev_vdbg(hsotg->dev, \"Queue non-periodic transactions\\n\");\n\n\ttx_status = dwc2_readl(hsotg, GNPTXSTS);\n\tqspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>\n\t\t    TXSTS_QSPCAVAIL_SHIFT;\n\tfspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>\n\t\t    TXSTS_FSPCAVAIL_SHIFT;\n\tdev_vdbg(hsotg->dev, \"  NP Tx Req Queue Space Avail (before queue): %d\\n\",\n\t\t qspcavail);\n\tdev_vdbg(hsotg->dev, \"  NP Tx FIFO Space Avail (before queue): %d\\n\",\n\t\t fspcavail);\n\n\t \n\tif (hsotg->non_periodic_qh_ptr == &hsotg->non_periodic_sched_active)\n\t\thsotg->non_periodic_qh_ptr = hsotg->non_periodic_qh_ptr->next;\n\torig_qh_ptr = hsotg->non_periodic_qh_ptr;\n\n\t \n\tdo {\n\t\ttx_status = dwc2_readl(hsotg, GNPTXSTS);\n\t\tqspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_QSPCAVAIL_SHIFT;\n\t\tif (!hsotg->params.host_dma && qspcavail == 0) {\n\t\t\tno_queue_space = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tqh = list_entry(hsotg->non_periodic_qh_ptr, struct dwc2_qh,\n\t\t\t\tqh_list_entry);\n\t\tif (!qh->channel)\n\t\t\tgoto next;\n\n\t\t \n\t\tif (qh->tt_buffer_dirty)\n\t\t\tgoto next;\n\n\t\tfspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_FSPCAVAIL_SHIFT;\n\t\tstatus = dwc2_queue_transaction(hsotg, qh->channel, fspcavail);\n\n\t\tif (status > 0) {\n\t\t\tmore_to_do = 1;\n\t\t} else if (status < 0) {\n\t\t\tno_fifo_space = 1;\n\t\t\tbreak;\n\t\t}\nnext:\n\t\t \n\t\thsotg->non_periodic_qh_ptr = hsotg->non_periodic_qh_ptr->next;\n\t\tif (hsotg->non_periodic_qh_ptr ==\n\t\t\t\t&hsotg->non_periodic_sched_active)\n\t\t\thsotg->non_periodic_qh_ptr =\n\t\t\t\t\thsotg->non_periodic_qh_ptr->next;\n\t} while (hsotg->non_periodic_qh_ptr != orig_qh_ptr);\n\n\tif (!hsotg->params.host_dma) {\n\t\ttx_status = dwc2_readl(hsotg, GNPTXSTS);\n\t\tqspcavail = (tx_status & TXSTS_QSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_QSPCAVAIL_SHIFT;\n\t\tfspcavail = (tx_status & TXSTS_FSPCAVAIL_MASK) >>\n\t\t\t    TXSTS_FSPCAVAIL_SHIFT;\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"  NP Tx Req Queue Space Avail (after queue): %d\\n\",\n\t\t\t qspcavail);\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"  NP Tx FIFO Space Avail (after queue): %d\\n\",\n\t\t\t fspcavail);\n\n\t\tif (more_to_do || no_queue_space || no_fifo_space) {\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk |= GINTSTS_NPTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t} else {\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk &= ~GINTSTS_NPTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t}\n\t}\n}\n\n \nvoid dwc2_hcd_queue_transactions(struct dwc2_hsotg *hsotg,\n\t\t\t\t enum dwc2_transaction_type tr_type)\n{\n#ifdef DWC2_DEBUG_SOF\n\tdev_vdbg(hsotg->dev, \"Queue Transactions\\n\");\n#endif\n\t \n\tif (tr_type == DWC2_TRANSACTION_PERIODIC ||\n\t    tr_type == DWC2_TRANSACTION_ALL)\n\t\tdwc2_process_periodic_channels(hsotg);\n\n\t \n\tif (tr_type == DWC2_TRANSACTION_NON_PERIODIC ||\n\t    tr_type == DWC2_TRANSACTION_ALL) {\n\t\tif (!list_empty(&hsotg->non_periodic_sched_active)) {\n\t\t\tdwc2_process_non_periodic_channels(hsotg);\n\t\t} else {\n\t\t\t \n\t\t\tu32 gintmsk = dwc2_readl(hsotg, GINTMSK);\n\n\t\t\tgintmsk &= ~GINTSTS_NPTXFEMP;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t}\n\t}\n}\n\nstatic void dwc2_conn_id_status_change(struct work_struct *work)\n{\n\tstruct dwc2_hsotg *hsotg = container_of(work, struct dwc2_hsotg,\n\t\t\t\t\t\twf_otg);\n\tu32 count = 0;\n\tu32 gotgctl;\n\tunsigned long flags;\n\n\tdev_dbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\tdev_dbg(hsotg->dev, \"gotgctl=%0x\\n\", gotgctl);\n\tdev_dbg(hsotg->dev, \"gotgctl.b.conidsts=%d\\n\",\n\t\t!!(gotgctl & GOTGCTL_CONID_B));\n\n\t \n\tif (gotgctl & GOTGCTL_CONID_B) {\n\t\tdwc2_vbus_supply_exit(hsotg);\n\t\t \n\t\tdev_dbg(hsotg->dev, \"connId B\\n\");\n\t\tif (hsotg->bus_suspended) {\n\t\t\tdev_info(hsotg->dev,\n\t\t\t\t \"Do port resume before switching to device mode\\n\");\n\t\t\tdwc2_port_resume(hsotg);\n\t\t}\n\t\twhile (!dwc2_is_device_mode(hsotg)) {\n\t\t\tdev_info(hsotg->dev,\n\t\t\t\t \"Waiting for Peripheral Mode, Mode=%s\\n\",\n\t\t\t\t dwc2_is_host_mode(hsotg) ? \"Host\" :\n\t\t\t\t \"Peripheral\");\n\t\t\tmsleep(20);\n\t\t\t \n\t\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\t\tif (!(gotgctl & GOTGCTL_CONID_B))\n\t\t\t\tgoto host;\n\t\t\tif (++count > 250)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 250)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Connection id status change timed out\\n\");\n\n\t\t \n\t\tif (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)\n\t\t\tdwc2_exit_partial_power_down(hsotg, 0, false);\n\n\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\t\tdwc2_core_init(hsotg, false);\n\t\tdwc2_enable_global_interrupts(hsotg);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\t \n\t\tdwc2_enable_acg(hsotg);\n\t\tdwc2_hsotg_core_connect(hsotg);\n\t} else {\nhost:\n\t\t \n\t\tdev_dbg(hsotg->dev, \"connId A\\n\");\n\t\twhile (!dwc2_is_host_mode(hsotg)) {\n\t\t\tdev_info(hsotg->dev, \"Waiting for Host Mode, Mode=%s\\n\",\n\t\t\t\t dwc2_is_host_mode(hsotg) ?\n\t\t\t\t \"Host\" : \"Peripheral\");\n\t\t\tmsleep(20);\n\t\t\tif (++count > 250)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (count > 250)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Connection id status change timed out\\n\");\n\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tdwc2_hsotg_disconnect(hsotg);\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\t\thsotg->op_state = OTG_STATE_A_HOST;\n\t\t \n\t\tdwc2_core_init(hsotg, false);\n\t\tdwc2_enable_global_interrupts(hsotg);\n\t\tdwc2_hcd_start(hsotg);\n\t}\n}\n\nstatic void dwc2_wakeup_detected(struct timer_list *t)\n{\n\tstruct dwc2_hsotg *hsotg = from_timer(hsotg, t, wkp_timer);\n\tu32 hprt0;\n\n\tdev_dbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\thprt0 = dwc2_read_hprt0(hsotg);\n\tdev_dbg(hsotg->dev, \"Resume: HPRT0=%0x\\n\", hprt0);\n\thprt0 &= ~HPRT0_RES;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\tdev_dbg(hsotg->dev, \"Clear Resume: HPRT0=%0x\\n\",\n\t\tdwc2_readl(hsotg, HPRT0));\n\n\tdwc2_hcd_rem_wakeup(hsotg);\n\thsotg->bus_suspended = false;\n\n\t \n\thsotg->lx_state = DWC2_L0;\n}\n\nstatic int dwc2_host_is_b_hnp_enabled(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_hcd *hcd = dwc2_hsotg_to_hcd(hsotg);\n\n\treturn hcd->self.b_hnp_enable;\n}\n\n \nint dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)\n{\n\tunsigned long flags;\n\tu32 pcgctl;\n\tu32 gotgctl;\n\tint ret = 0;\n\n\tdev_dbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tif (windex == hsotg->otg_port && dwc2_host_is_b_hnp_enabled(hsotg)) {\n\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\tgotgctl |= GOTGCTL_HSTSETHNPEN;\n\t\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\t\thsotg->op_state = OTG_STATE_A_SUSPEND;\n\t}\n\n\tswitch (hsotg->params.power_down) {\n\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\tret = dwc2_enter_partial_power_down(hsotg);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"enter partial_power_down failed.\\n\");\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tret = dwc2_enter_hibernation(hsotg, 1);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev, \"enter hibernation failed.\\n\");\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\t \n\t\tif (!hsotg->params.no_clock_gating)\n\t\t\tdwc2_host_enter_clock_gating(hsotg);\n\t\tbreak;\n\t}\n\n\t \n\tif (dwc2_host_is_b_hnp_enabled(hsotg)) {\n\t\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\t\tpcgctl &= ~PCGCTL_STOPPCLK;\n\t\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\t\tmsleep(200);\n\t} else {\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t}\n\n\treturn ret;\n}\n\n \nint dwc2_port_resume(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tswitch (hsotg->params.power_down) {\n\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\tret = dwc2_exit_partial_power_down(hsotg, 0, true);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down failed.\\n\");\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\t \n\t\tret = dwc2_exit_hibernation(hsotg, 0, 0, 1);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev, \"exit hibernation failed.\\n\");\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tdwc2_host_exit_clock_gating(hsotg, 0);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,\n\t\t\t\tu16 wvalue, u16 windex, char *buf, u16 wlength)\n{\n\tstruct usb_hub_descriptor *hub_desc;\n\tint retval = 0;\n\tu32 hprt0;\n\tu32 port_status;\n\tu32 speed;\n\tu32 pcgctl;\n\tu32 pwr;\n\n\tswitch (typereq) {\n\tcase ClearHubFeature:\n\t\tdev_dbg(hsotg->dev, \"ClearHubFeature %1xh\\n\", wvalue);\n\n\t\tswitch (wvalue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tretval = -EINVAL;\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"ClearHubFeature request %1xh unknown\\n\",\n\t\t\t\twvalue);\n\t\t}\n\t\tbreak;\n\n\tcase ClearPortFeature:\n\t\tif (wvalue != USB_PORT_FEAT_L1)\n\t\t\tif (!windex || windex > 1)\n\t\t\t\tgoto error;\n\t\tswitch (wvalue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_ENABLE\\n\");\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\t\thprt0 |= HPRT0_ENA;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_SUSPEND\\n\");\n\n\t\t\tif (hsotg->bus_suspended)\n\t\t\t\tretval = dwc2_port_resume(hsotg);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_POWER\\n\");\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\t\tpwr = hprt0 & HPRT0_PWR;\n\t\t\thprt0 &= ~HPRT0_PWR;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\tif (pwr)\n\t\t\t\tdwc2_vbus_supply_exit(hsotg);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_INDICATOR:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_INDICATOR\\n\");\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\t \n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_CONNECTION\\n\");\n\t\t\thsotg->flags.b.port_connect_status_change = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_RESET\\n\");\n\t\t\thsotg->flags.b.port_reset_change = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\t \n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_ENABLE\\n\");\n\t\t\thsotg->flags.b.port_enable_change = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\t \n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_SUSPEND\\n\");\n\t\t\thsotg->flags.b.port_suspend_change = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_PORT_L1:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_PORT_L1\\n\");\n\t\t\thsotg->flags.b.port_l1_change = 0;\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ClearPortFeature USB_PORT_FEAT_C_OVER_CURRENT\\n\");\n\t\t\thsotg->flags.b.port_over_current_change = 0;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tretval = -EINVAL;\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"ClearPortFeature request %1xh unknown or unsupported\\n\",\n\t\t\t\twvalue);\n\t\t}\n\t\tbreak;\n\n\tcase GetHubDescriptor:\n\t\tdev_dbg(hsotg->dev, \"GetHubDescriptor\\n\");\n\t\thub_desc = (struct usb_hub_descriptor *)buf;\n\t\thub_desc->bDescLength = 9;\n\t\thub_desc->bDescriptorType = USB_DT_HUB;\n\t\thub_desc->bNbrPorts = 1;\n\t\thub_desc->wHubCharacteristics =\n\t\t\tcpu_to_le16(HUB_CHAR_COMMON_LPSM |\n\t\t\t\t    HUB_CHAR_INDV_PORT_OCPM);\n\t\thub_desc->bPwrOn2PwrGood = 1;\n\t\thub_desc->bHubContrCurrent = 0;\n\t\thub_desc->u.hs.DeviceRemovable[0] = 0;\n\t\thub_desc->u.hs.DeviceRemovable[1] = 0xff;\n\t\tbreak;\n\n\tcase GetHubStatus:\n\t\tdev_dbg(hsotg->dev, \"GetHubStatus\\n\");\n\t\tmemset(buf, 0, 4);\n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"GetPortStatus wIndex=0x%04x flags=0x%08x\\n\", windex,\n\t\t\t hsotg->flags.d32);\n\t\tif (!windex || windex > 1)\n\t\t\tgoto error;\n\n\t\tport_status = 0;\n\t\tif (hsotg->flags.b.port_connect_status_change)\n\t\t\tport_status |= USB_PORT_STAT_C_CONNECTION << 16;\n\t\tif (hsotg->flags.b.port_enable_change)\n\t\t\tport_status |= USB_PORT_STAT_C_ENABLE << 16;\n\t\tif (hsotg->flags.b.port_suspend_change)\n\t\t\tport_status |= USB_PORT_STAT_C_SUSPEND << 16;\n\t\tif (hsotg->flags.b.port_l1_change)\n\t\t\tport_status |= USB_PORT_STAT_C_L1 << 16;\n\t\tif (hsotg->flags.b.port_reset_change)\n\t\t\tport_status |= USB_PORT_STAT_C_RESET << 16;\n\t\tif (hsotg->flags.b.port_over_current_change) {\n\t\t\tdev_warn(hsotg->dev, \"Overcurrent change detected\\n\");\n\t\t\tport_status |= USB_PORT_STAT_C_OVERCURRENT << 16;\n\t\t}\n\n\t\tif (!hsotg->flags.b.port_connect_status) {\n\t\t\t \n\t\t\t*(__le32 *)buf = cpu_to_le32(port_status);\n\t\t\tbreak;\n\t\t}\n\n\t\thprt0 = dwc2_readl(hsotg, HPRT0);\n\t\tdev_vdbg(hsotg->dev, \"  HPRT0: 0x%08x\\n\", hprt0);\n\n\t\tif (hprt0 & HPRT0_CONNSTS)\n\t\t\tport_status |= USB_PORT_STAT_CONNECTION;\n\t\tif (hprt0 & HPRT0_ENA)\n\t\t\tport_status |= USB_PORT_STAT_ENABLE;\n\t\tif (hprt0 & HPRT0_SUSP)\n\t\t\tport_status |= USB_PORT_STAT_SUSPEND;\n\t\tif (hprt0 & HPRT0_OVRCURRACT)\n\t\t\tport_status |= USB_PORT_STAT_OVERCURRENT;\n\t\tif (hprt0 & HPRT0_RST)\n\t\t\tport_status |= USB_PORT_STAT_RESET;\n\t\tif (hprt0 & HPRT0_PWR)\n\t\t\tport_status |= USB_PORT_STAT_POWER;\n\n\t\tspeed = (hprt0 & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\n\t\tif (speed == HPRT0_SPD_HIGH_SPEED)\n\t\t\tport_status |= USB_PORT_STAT_HIGH_SPEED;\n\t\telse if (speed == HPRT0_SPD_LOW_SPEED)\n\t\t\tport_status |= USB_PORT_STAT_LOW_SPEED;\n\n\t\tif (hprt0 & HPRT0_TSTCTL_MASK)\n\t\t\tport_status |= USB_PORT_STAT_TEST;\n\t\t \n\n\t\tif (hsotg->params.dma_desc_fs_enable) {\n\t\t\t \n\t\t\tif (hsotg->new_connection &&\n\t\t\t    ((port_status &\n\t\t\t      (USB_PORT_STAT_CONNECTION |\n\t\t\t       USB_PORT_STAT_HIGH_SPEED |\n\t\t\t       USB_PORT_STAT_LOW_SPEED)) ==\n\t\t\t       USB_PORT_STAT_CONNECTION)) {\n\t\t\t\tu32 hcfg;\n\n\t\t\t\tdev_info(hsotg->dev, \"Enabling descriptor DMA mode\\n\");\n\t\t\t\thsotg->params.dma_desc_enable = true;\n\t\t\t\thcfg = dwc2_readl(hsotg, HCFG);\n\t\t\t\thcfg |= HCFG_DESCDMA;\n\t\t\t\tdwc2_writel(hsotg, hcfg, HCFG);\n\t\t\t\thsotg->new_connection = false;\n\t\t\t}\n\t\t}\n\n\t\tdev_vdbg(hsotg->dev, \"port_status=%08x\\n\", port_status);\n\t\t*(__le32 *)buf = cpu_to_le32(port_status);\n\t\tbreak;\n\n\tcase SetHubFeature:\n\t\tdev_dbg(hsotg->dev, \"SetHubFeature\\n\");\n\t\t \n\t\tbreak;\n\n\tcase SetPortFeature:\n\t\tdev_dbg(hsotg->dev, \"SetPortFeature\\n\");\n\t\tif (wvalue != USB_PORT_FEAT_TEST && (!windex || windex > 1))\n\t\t\tgoto error;\n\n\t\tif (!hsotg->flags.b.port_connect_status) {\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (wvalue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"SetPortFeature - USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\tif (windex != hsotg->otg_port)\n\t\t\t\tgoto error;\n\t\t\tif (!hsotg->bus_suspended)\n\t\t\t\tretval = dwc2_port_suspend(hsotg, windex);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"SetPortFeature - USB_PORT_FEAT_POWER\\n\");\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\t\tpwr = hprt0 & HPRT0_PWR;\n\t\t\thprt0 |= HPRT0_PWR;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\tif (!pwr)\n\t\t\t\tdwc2_vbus_supply_init(hsotg);\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"SetPortFeature - USB_PORT_FEAT_RESET\\n\");\n\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\n\t\t\tif (hsotg->hibernated) {\n\t\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 1, 1);\n\t\t\t\tif (retval)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit hibernation failed\\n\");\n\t\t\t}\n\n\t\t\tif (hsotg->in_ppd) {\n\t\t\t\tretval = dwc2_exit_partial_power_down(hsotg, 1,\n\t\t\t\t\t\t\t\t      true);\n\t\t\t\tif (retval)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit partial_power_down failed\\n\");\n\t\t\t}\n\n\t\t\tif (hsotg->params.power_down ==\n\t\t\t    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)\n\t\t\t\tdwc2_host_exit_clock_gating(hsotg, 0);\n\n\t\t\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\t\t\tpcgctl &= ~(PCGCTL_ENBL_SLEEP_GATING | PCGCTL_STOPPCLK);\n\t\t\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\t\t\t \n\t\t\tdwc2_writel(hsotg, 0, PCGCTL);\n\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\t\tpwr = hprt0 & HPRT0_PWR;\n\t\t\t \n\t\t\thprt0 &= ~HPRT0_SUSP;\n\n\t\t\t \n\t\t\tif (!dwc2_hcd_is_b_host(hsotg)) {\n\t\t\t\thprt0 |= HPRT0_PWR | HPRT0_RST;\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"In host mode, hprt0=%08x\\n\", hprt0);\n\t\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\t\tif (!pwr)\n\t\t\t\t\tdwc2_vbus_supply_init(hsotg);\n\t\t\t}\n\n\t\t\t \n\t\t\tmsleep(50);\n\t\t\thprt0 &= ~HPRT0_RST;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\thsotg->lx_state = DWC2_L0;  \n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_INDICATOR:\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"SetPortFeature - USB_PORT_FEAT_INDICATOR\\n\");\n\t\t\t \n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"SetPortFeature - USB_PORT_FEAT_TEST\\n\");\n\t\t\thprt0 &= ~HPRT0_TSTCTL_MASK;\n\t\t\thprt0 |= (windex >> 8) << HPRT0_TSTCTL_SHIFT;\n\t\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tretval = -EINVAL;\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"SetPortFeature %1xh unknown or unsupported\\n\",\n\t\t\t\twvalue);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\tretval = -EINVAL;\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"Unknown hub control request: %1xh wIndex: %1xh wValue: %1xh\\n\",\n\t\t\ttypereq, windex, wvalue);\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic int dwc2_hcd_is_status_changed(struct dwc2_hsotg *hsotg, int port)\n{\n\tint retval;\n\n\tif (port != 1)\n\t\treturn -EINVAL;\n\n\tretval = (hsotg->flags.b.port_connect_status_change ||\n\t\t  hsotg->flags.b.port_reset_change ||\n\t\t  hsotg->flags.b.port_enable_change ||\n\t\t  hsotg->flags.b.port_suspend_change ||\n\t\t  hsotg->flags.b.port_over_current_change);\n\n\tif (retval) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"DWC OTG HCD HUB STATUS DATA: Root port status changed\\n\");\n\t\tdev_dbg(hsotg->dev, \"  port_connect_status_change: %d\\n\",\n\t\t\thsotg->flags.b.port_connect_status_change);\n\t\tdev_dbg(hsotg->dev, \"  port_reset_change: %d\\n\",\n\t\t\thsotg->flags.b.port_reset_change);\n\t\tdev_dbg(hsotg->dev, \"  port_enable_change: %d\\n\",\n\t\t\thsotg->flags.b.port_enable_change);\n\t\tdev_dbg(hsotg->dev, \"  port_suspend_change: %d\\n\",\n\t\t\thsotg->flags.b.port_suspend_change);\n\t\tdev_dbg(hsotg->dev, \"  port_over_current_change: %d\\n\",\n\t\t\thsotg->flags.b.port_over_current_change);\n\t}\n\n\treturn retval;\n}\n\nint dwc2_hcd_get_frame_number(struct dwc2_hsotg *hsotg)\n{\n\tu32 hfnum = dwc2_readl(hsotg, HFNUM);\n\n#ifdef DWC2_DEBUG_SOF\n\tdev_vdbg(hsotg->dev, \"DWC OTG HCD GET FRAME NUMBER %d\\n\",\n\t\t (hfnum & HFNUM_FRNUM_MASK) >> HFNUM_FRNUM_SHIFT);\n#endif\n\treturn (hfnum & HFNUM_FRNUM_MASK) >> HFNUM_FRNUM_SHIFT;\n}\n\nint dwc2_hcd_get_future_frame_number(struct dwc2_hsotg *hsotg, int us)\n{\n\tu32 hprt = dwc2_readl(hsotg, HPRT0);\n\tu32 hfir = dwc2_readl(hsotg, HFIR);\n\tu32 hfnum = dwc2_readl(hsotg, HFNUM);\n\tunsigned int us_per_frame;\n\tunsigned int frame_number;\n\tunsigned int remaining;\n\tunsigned int interval;\n\tunsigned int phy_clks;\n\n\t \n\tus_per_frame = (hprt & HPRT0_SPD_MASK) ? 1000 : 125;\n\n\t \n\tframe_number = (hfnum & HFNUM_FRNUM_MASK) >> HFNUM_FRNUM_SHIFT;\n\tremaining = (hfnum & HFNUM_FRREM_MASK) >> HFNUM_FRREM_SHIFT;\n\tinterval = (hfir & HFIR_FRINT_MASK) >> HFIR_FRINT_SHIFT;\n\n\t \n\tphy_clks = (interval - remaining) +\n\t\t   DIV_ROUND_UP(interval * us, us_per_frame);\n\n\treturn dwc2_frame_num_inc(frame_number, phy_clks / interval);\n}\n\nint dwc2_hcd_is_b_host(struct dwc2_hsotg *hsotg)\n{\n\treturn hsotg->op_state == OTG_STATE_B_HOST;\n}\n\nstatic struct dwc2_hcd_urb *dwc2_hcd_urb_alloc(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t       int iso_desc_count,\n\t\t\t\t\t       gfp_t mem_flags)\n{\n\tstruct dwc2_hcd_urb *urb;\n\n\turb = kzalloc(struct_size(urb, iso_descs, iso_desc_count), mem_flags);\n\tif (urb)\n\t\turb->packet_count = iso_desc_count;\n\treturn urb;\n}\n\nstatic void dwc2_hcd_urb_set_pipeinfo(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_hcd_urb *urb, u8 dev_addr,\n\t\t\t\t      u8 ep_num, u8 ep_type, u8 ep_dir,\n\t\t\t\t      u16 maxp, u16 maxp_mult)\n{\n\tif (dbg_perio() ||\n\t    ep_type == USB_ENDPOINT_XFER_BULK ||\n\t    ep_type == USB_ENDPOINT_XFER_CONTROL)\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"addr=%d, ep_num=%d, ep_dir=%1x, ep_type=%1x, maxp=%d (%d mult)\\n\",\n\t\t\t dev_addr, ep_num, ep_dir, ep_type, maxp, maxp_mult);\n\turb->pipe_info.dev_addr = dev_addr;\n\turb->pipe_info.ep_num = ep_num;\n\turb->pipe_info.pipe_type = ep_type;\n\turb->pipe_info.pipe_dir = ep_dir;\n\turb->pipe_info.maxp = maxp;\n\turb->pipe_info.maxp_mult = maxp_mult;\n}\n\n \nvoid dwc2_hcd_dump_state(struct dwc2_hsotg *hsotg)\n{\n#ifdef DEBUG\n\tstruct dwc2_host_chan *chan;\n\tstruct dwc2_hcd_urb *urb;\n\tstruct dwc2_qtd *qtd;\n\tint num_channels;\n\tu32 np_tx_status;\n\tu32 p_tx_status;\n\tint i;\n\n\tnum_channels = hsotg->params.host_channels;\n\tdev_dbg(hsotg->dev, \"\\n\");\n\tdev_dbg(hsotg->dev,\n\t\t\"************************************************************\\n\");\n\tdev_dbg(hsotg->dev, \"HCD State:\\n\");\n\tdev_dbg(hsotg->dev, \"  Num channels: %d\\n\", num_channels);\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tchan = hsotg->hc_ptr_array[i];\n\t\tdev_dbg(hsotg->dev, \"  Channel %d:\\n\", i);\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"    dev_addr: %d, ep_num: %d, ep_is_in: %d\\n\",\n\t\t\tchan->dev_addr, chan->ep_num, chan->ep_is_in);\n\t\tdev_dbg(hsotg->dev, \"    speed: %d\\n\", chan->speed);\n\t\tdev_dbg(hsotg->dev, \"    ep_type: %d\\n\", chan->ep_type);\n\t\tdev_dbg(hsotg->dev, \"    max_packet: %d\\n\", chan->max_packet);\n\t\tdev_dbg(hsotg->dev, \"    data_pid_start: %d\\n\",\n\t\t\tchan->data_pid_start);\n\t\tdev_dbg(hsotg->dev, \"    multi_count: %d\\n\", chan->multi_count);\n\t\tdev_dbg(hsotg->dev, \"    xfer_started: %d\\n\",\n\t\t\tchan->xfer_started);\n\t\tdev_dbg(hsotg->dev, \"    xfer_buf: %p\\n\", chan->xfer_buf);\n\t\tdev_dbg(hsotg->dev, \"    xfer_dma: %08lx\\n\",\n\t\t\t(unsigned long)chan->xfer_dma);\n\t\tdev_dbg(hsotg->dev, \"    xfer_len: %d\\n\", chan->xfer_len);\n\t\tdev_dbg(hsotg->dev, \"    xfer_count: %d\\n\", chan->xfer_count);\n\t\tdev_dbg(hsotg->dev, \"    halt_on_queue: %d\\n\",\n\t\t\tchan->halt_on_queue);\n\t\tdev_dbg(hsotg->dev, \"    halt_pending: %d\\n\",\n\t\t\tchan->halt_pending);\n\t\tdev_dbg(hsotg->dev, \"    halt_status: %d\\n\", chan->halt_status);\n\t\tdev_dbg(hsotg->dev, \"    do_split: %d\\n\", chan->do_split);\n\t\tdev_dbg(hsotg->dev, \"    complete_split: %d\\n\",\n\t\t\tchan->complete_split);\n\t\tdev_dbg(hsotg->dev, \"    hub_addr: %d\\n\", chan->hub_addr);\n\t\tdev_dbg(hsotg->dev, \"    hub_port: %d\\n\", chan->hub_port);\n\t\tdev_dbg(hsotg->dev, \"    xact_pos: %d\\n\", chan->xact_pos);\n\t\tdev_dbg(hsotg->dev, \"    requests: %d\\n\", chan->requests);\n\t\tdev_dbg(hsotg->dev, \"    qh: %p\\n\", chan->qh);\n\n\t\tif (chan->xfer_started) {\n\t\t\tu32 hfnum, hcchar, hctsiz, hcint, hcintmsk;\n\n\t\t\thfnum = dwc2_readl(hsotg, HFNUM);\n\t\t\thcchar = dwc2_readl(hsotg, HCCHAR(i));\n\t\t\thctsiz = dwc2_readl(hsotg, HCTSIZ(i));\n\t\t\thcint = dwc2_readl(hsotg, HCINT(i));\n\t\t\thcintmsk = dwc2_readl(hsotg, HCINTMSK(i));\n\t\t\tdev_dbg(hsotg->dev, \"    hfnum: 0x%08x\\n\", hfnum);\n\t\t\tdev_dbg(hsotg->dev, \"    hcchar: 0x%08x\\n\", hcchar);\n\t\t\tdev_dbg(hsotg->dev, \"    hctsiz: 0x%08x\\n\", hctsiz);\n\t\t\tdev_dbg(hsotg->dev, \"    hcint: 0x%08x\\n\", hcint);\n\t\t\tdev_dbg(hsotg->dev, \"    hcintmsk: 0x%08x\\n\", hcintmsk);\n\t\t}\n\n\t\tif (!(chan->xfer_started && chan->qh))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(qtd, &chan->qh->qtd_list, qtd_list_entry) {\n\t\t\tif (!qtd->in_process)\n\t\t\t\tbreak;\n\t\t\turb = qtd->urb;\n\t\t\tdev_dbg(hsotg->dev, \"    URB Info:\\n\");\n\t\t\tdev_dbg(hsotg->dev, \"      qtd: %p, urb: %p\\n\",\n\t\t\t\tqtd, urb);\n\t\t\tif (urb) {\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"      Dev: %d, EP: %d %s\\n\",\n\t\t\t\t\tdwc2_hcd_get_dev_addr(&urb->pipe_info),\n\t\t\t\t\tdwc2_hcd_get_ep_num(&urb->pipe_info),\n\t\t\t\t\tdwc2_hcd_is_pipe_in(&urb->pipe_info) ?\n\t\t\t\t\t\"IN\" : \"OUT\");\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"      Max packet size: %d (%d mult)\\n\",\n\t\t\t\t\tdwc2_hcd_get_maxp(&urb->pipe_info),\n\t\t\t\t\tdwc2_hcd_get_maxp_mult(&urb->pipe_info));\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"      transfer_buffer: %p\\n\",\n\t\t\t\t\turb->buf);\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"      transfer_dma: %08lx\\n\",\n\t\t\t\t\t(unsigned long)urb->dma);\n\t\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\t\"      transfer_buffer_length: %d\\n\",\n\t\t\t\t\turb->length);\n\t\t\t\tdev_dbg(hsotg->dev, \"      actual_length: %d\\n\",\n\t\t\t\t\turb->actual_length);\n\t\t\t}\n\t\t}\n\t}\n\n\tdev_dbg(hsotg->dev, \"  non_periodic_channels: %d\\n\",\n\t\thsotg->non_periodic_channels);\n\tdev_dbg(hsotg->dev, \"  periodic_channels: %d\\n\",\n\t\thsotg->periodic_channels);\n\tdev_dbg(hsotg->dev, \"  periodic_usecs: %d\\n\", hsotg->periodic_usecs);\n\tnp_tx_status = dwc2_readl(hsotg, GNPTXSTS);\n\tdev_dbg(hsotg->dev, \"  NP Tx Req Queue Space Avail: %d\\n\",\n\t\t(np_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);\n\tdev_dbg(hsotg->dev, \"  NP Tx FIFO Space Avail: %d\\n\",\n\t\t(np_tx_status & TXSTS_FSPCAVAIL_MASK) >> TXSTS_FSPCAVAIL_SHIFT);\n\tp_tx_status = dwc2_readl(hsotg, HPTXSTS);\n\tdev_dbg(hsotg->dev, \"  P Tx Req Queue Space Avail: %d\\n\",\n\t\t(p_tx_status & TXSTS_QSPCAVAIL_MASK) >> TXSTS_QSPCAVAIL_SHIFT);\n\tdev_dbg(hsotg->dev, \"  P Tx FIFO Space Avail: %d\\n\",\n\t\t(p_tx_status & TXSTS_FSPCAVAIL_MASK) >> TXSTS_FSPCAVAIL_SHIFT);\n\tdwc2_dump_global_registers(hsotg);\n\tdwc2_dump_host_registers(hsotg);\n\tdev_dbg(hsotg->dev,\n\t\t\"************************************************************\\n\");\n\tdev_dbg(hsotg->dev, \"\\n\");\n#endif\n}\n\nstruct wrapper_priv_data {\n\tstruct dwc2_hsotg *hsotg;\n};\n\n \nstatic struct dwc2_hsotg *dwc2_hcd_to_hsotg(struct usb_hcd *hcd)\n{\n\tstruct wrapper_priv_data *p;\n\n\tp = (struct wrapper_priv_data *)&hcd->hcd_priv;\n\treturn p->hsotg;\n}\n\n \n\nstruct dwc2_tt *dwc2_host_get_tt_info(struct dwc2_hsotg *hsotg, void *context,\n\t\t\t\t      gfp_t mem_flags, int *ttport)\n{\n\tstruct urb *urb = context;\n\tstruct dwc2_tt *dwc_tt = NULL;\n\n\tif (urb->dev->tt) {\n\t\t*ttport = urb->dev->ttport;\n\n\t\tdwc_tt = urb->dev->tt->hcpriv;\n\t\tif (!dwc_tt) {\n\t\t\tsize_t bitmap_size;\n\n\t\t\t \n\t\t\tbitmap_size = DWC2_ELEMENTS_PER_LS_BITMAP *\n\t\t\t\t      sizeof(dwc_tt->periodic_bitmaps[0]);\n\t\t\tif (urb->dev->tt->multi)\n\t\t\t\tbitmap_size *= urb->dev->tt->hub->maxchild;\n\n\t\t\tdwc_tt = kzalloc(sizeof(*dwc_tt) + bitmap_size,\n\t\t\t\t\t mem_flags);\n\t\t\tif (!dwc_tt)\n\t\t\t\treturn NULL;\n\n\t\t\tdwc_tt->usb_tt = urb->dev->tt;\n\t\t\tdwc_tt->usb_tt->hcpriv = dwc_tt;\n\t\t}\n\n\t\tdwc_tt->refcount++;\n\t}\n\n\treturn dwc_tt;\n}\n\n \nvoid dwc2_host_put_tt_info(struct dwc2_hsotg *hsotg, struct dwc2_tt *dwc_tt)\n{\n\t \n\tif (!dwc_tt)\n\t\treturn;\n\n\tWARN_ON(dwc_tt->refcount < 1);\n\n\tdwc_tt->refcount--;\n\tif (!dwc_tt->refcount) {\n\t\tdwc_tt->usb_tt->hcpriv = NULL;\n\t\tkfree(dwc_tt);\n\t}\n}\n\nint dwc2_host_get_speed(struct dwc2_hsotg *hsotg, void *context)\n{\n\tstruct urb *urb = context;\n\n\treturn urb->dev->speed;\n}\n\nstatic void dwc2_allocate_bus_bandwidth(struct usb_hcd *hcd, u16 bw,\n\t\t\t\t\tstruct urb *urb)\n{\n\tstruct usb_bus *bus = hcd_to_bus(hcd);\n\n\tif (urb->interval)\n\t\tbus->bandwidth_allocated += bw / urb->interval;\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n\t\tbus->bandwidth_isoc_reqs++;\n\telse\n\t\tbus->bandwidth_int_reqs++;\n}\n\nstatic void dwc2_free_bus_bandwidth(struct usb_hcd *hcd, u16 bw,\n\t\t\t\t    struct urb *urb)\n{\n\tstruct usb_bus *bus = hcd_to_bus(hcd);\n\n\tif (urb->interval)\n\t\tbus->bandwidth_allocated -= bw / urb->interval;\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n\t\tbus->bandwidth_isoc_reqs--;\n\telse\n\t\tbus->bandwidth_int_reqs--;\n}\n\n \nvoid dwc2_host_complete(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\n\t\t\tint status)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tif (!qtd) {\n\t\tdev_dbg(hsotg->dev, \"## %s: qtd is NULL ##\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (!qtd->urb) {\n\t\tdev_dbg(hsotg->dev, \"## %s: qtd->urb is NULL ##\\n\", __func__);\n\t\treturn;\n\t}\n\n\turb = qtd->urb->priv;\n\tif (!urb) {\n\t\tdev_dbg(hsotg->dev, \"## %s: urb->priv is NULL ##\\n\", __func__);\n\t\treturn;\n\t}\n\n\turb->actual_length = dwc2_hcd_urb_get_actual_length(qtd->urb);\n\n\tif (dbg_urb(urb))\n\t\tdev_vdbg(hsotg->dev,\n\t\t\t \"%s: urb %p device %d ep %d-%s status %d actual %d\\n\",\n\t\t\t __func__, urb, usb_pipedevice(urb->pipe),\n\t\t\t usb_pipeendpoint(urb->pipe),\n\t\t\t usb_pipein(urb->pipe) ? \"IN\" : \"OUT\", status,\n\t\t\t urb->actual_length);\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\turb->error_count = dwc2_hcd_urb_get_error_count(qtd->urb);\n\t\tfor (i = 0; i < urb->number_of_packets; ++i) {\n\t\t\turb->iso_frame_desc[i].actual_length =\n\t\t\t\tdwc2_hcd_urb_get_iso_desc_actual_length(\n\t\t\t\t\t\tqtd->urb, i);\n\t\t\turb->iso_frame_desc[i].status =\n\t\t\t\tdwc2_hcd_urb_get_iso_desc_status(qtd->urb, i);\n\t\t}\n\t}\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS && dbg_perio()) {\n\t\tfor (i = 0; i < urb->number_of_packets; i++)\n\t\t\tdev_vdbg(hsotg->dev, \" ISO Desc %d status %d\\n\",\n\t\t\t\t i, urb->iso_frame_desc[i].status);\n\t}\n\n\turb->status = status;\n\tif (!status) {\n\t\tif ((urb->transfer_flags & URB_SHORT_NOT_OK) &&\n\t\t    urb->actual_length < urb->transfer_buffer_length)\n\t\t\turb->status = -EREMOTEIO;\n\t}\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\tstruct usb_host_endpoint *ep = urb->ep;\n\n\t\tif (ep)\n\t\t\tdwc2_free_bus_bandwidth(dwc2_hsotg_to_hcd(hsotg),\n\t\t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\t\turb);\n\t}\n\n\tusb_hcd_unlink_urb_from_ep(dwc2_hsotg_to_hcd(hsotg), urb);\n\turb->hcpriv = NULL;\n\tkfree(qtd->urb);\n\tqtd->urb = NULL;\n\n\tusb_hcd_giveback_urb(dwc2_hsotg_to_hcd(hsotg), urb, status);\n}\n\n \nstatic void dwc2_hcd_start_func(struct work_struct *work)\n{\n\tstruct dwc2_hsotg *hsotg = container_of(work, struct dwc2_hsotg,\n\t\t\t\t\t\tstart_work.work);\n\n\tdev_dbg(hsotg->dev, \"%s() %p\\n\", __func__, hsotg);\n\tdwc2_host_start(hsotg);\n}\n\n \nstatic void dwc2_hcd_reset_func(struct work_struct *work)\n{\n\tstruct dwc2_hsotg *hsotg = container_of(work, struct dwc2_hsotg,\n\t\t\t\t\t\treset_work.work);\n\tunsigned long flags;\n\tu32 hprt0;\n\n\tdev_dbg(hsotg->dev, \"USB RESET function called\\n\");\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\thprt0 = dwc2_read_hprt0(hsotg);\n\thprt0 &= ~HPRT0_RST;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\thsotg->flags.b.port_reset_change = 1;\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\nstatic void dwc2_hcd_phy_reset_func(struct work_struct *work)\n{\n\tstruct dwc2_hsotg *hsotg = container_of(work, struct dwc2_hsotg,\n\t\t\t\t\t\tphy_reset_work);\n\tint ret;\n\n\tret = phy_reset(hsotg->phy);\n\tif (ret)\n\t\tdev_warn(hsotg->dev, \"PHY reset failed\\n\");\n}\n\n \n\n \nstatic int _dwc2_hcd_start(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_bus *bus = hcd_to_bus(hcd);\n\tunsigned long flags;\n\tu32 hprt0;\n\tint ret;\n\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD START\\n\");\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\thsotg->lx_state = DWC2_L0;\n\thcd->state = HC_STATE_RUNNING;\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\treturn 0;\t \n\t}\n\n\tdwc2_hcd_reinit(hsotg);\n\n\thprt0 = dwc2_read_hprt0(hsotg);\n\t \n\tif (hprt0 & HPRT0_PWR) {\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tret = dwc2_vbus_supply_init(hsotg);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t}\n\n\t \n\tif (bus->root_hub) {\n\t\tdev_dbg(hsotg->dev, \"DWC OTG HCD Has Root Hub\\n\");\n\t\t \n\t\tusb_hcd_resume_root_hub(hcd);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic void _dwc2_hcd_stop(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tunsigned long flags;\n\tu32 hprt0;\n\n\t \n\tdwc2_disable_host_interrupts(hsotg);\n\n\t \n\tsynchronize_irq(hcd->irq);\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\thprt0 = dwc2_read_hprt0(hsotg);\n\t \n\tdwc2_hcd_disconnect(hsotg, true);\n\tdwc2_hcd_stop(hsotg);\n\thsotg->lx_state = DWC2_L3;\n\thcd->state = HC_STATE_HALT;\n\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\t \n\tif (hprt0 & HPRT0_PWR)\n\t\tdwc2_vbus_supply_exit(hsotg);\n\n\tusleep_range(1000, 3000);\n}\n\nstatic int _dwc2_hcd_suspend(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tif (dwc2_is_device_mode(hsotg))\n\t\tgoto unlock;\n\n\tif (hsotg->lx_state != DWC2_L0)\n\t\tgoto unlock;\n\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto unlock;\n\n\tif (hsotg->op_state == OTG_STATE_B_PERIPHERAL)\n\t\tgoto unlock;\n\n\tif (hsotg->bus_suspended)\n\t\tgoto skip_power_saving;\n\n\tif (hsotg->flags.b.port_connect_status == 0)\n\t\tgoto skip_power_saving;\n\n\tswitch (hsotg->params.power_down) {\n\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\t \n\t\tret = dwc2_enter_partial_power_down(hsotg);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"enter partial_power_down failed\\n\");\n\t\t \n\t\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tret = dwc2_enter_hibernation(hsotg, 1);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev, \"enter hibernation failed\\n\");\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t\t \n\t\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\t \n\t\tif (!hsotg->params.no_clock_gating) {\n\t\t\tdwc2_host_enter_clock_gating(hsotg);\n\n\t\t\t \n\t\t\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tgoto skip_power_saving;\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\tdwc2_vbus_supply_exit(hsotg);\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t \n\tif (!IS_ERR_OR_NULL(hsotg->uphy)) {\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tusb_phy_set_suspend(hsotg->uphy, true);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t}\n\nskip_power_saving:\n\thsotg->lx_state = DWC2_L2;\nunlock:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn ret;\n}\n\nstatic int _dwc2_hcd_resume(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tunsigned long flags;\n\tu32 hprt0;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tif (dwc2_is_device_mode(hsotg))\n\t\tgoto unlock;\n\n\tif (hsotg->lx_state != DWC2_L2)\n\t\tgoto unlock;\n\n\thprt0 = dwc2_read_hprt0(hsotg);\n\n\t \n\tif (hprt0 & HPRT0_CONNSTS) {\n\t\thsotg->lx_state = DWC2_L0;\n\t\tgoto unlock;\n\t}\n\n\tswitch (hsotg->params.power_down) {\n\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\tret = dwc2_exit_partial_power_down(hsotg, 0, true);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down failed\\n\");\n\t\t \n\t\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\tret = dwc2_exit_hibernation(hsotg, 0, 0, 1);\n\t\tif (ret)\n\t\t\tdev_err(hsotg->dev, \"exit hibernation failed.\\n\");\n\n\t\t \n\t\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\tbreak;\n\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\t \n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tdwc2_host_exit_clock_gating(hsotg, 0);\n\n\t\t \n\t\tdwc2_core_init(hsotg, false);\n\t\tdwc2_enable_global_interrupts(hsotg);\n\t\tdwc2_hcd_reinit(hsotg);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t\t \n\t\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t\tbreak;\n\tdefault:\n\t\thsotg->lx_state = DWC2_L0;\n\t\tgoto unlock;\n\t}\n\n\t \n\thsotg->flags.b.port_suspend_change = 1;\n\n\t \n\tif (!IS_ERR_OR_NULL(hsotg->uphy)) {\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t\tusb_phy_set_suspend(hsotg->uphy, false);\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t}\n\n\t \n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\tdwc2_vbus_supply_init(hsotg);\n\n\t \n\tusleep_range(3000, 5000);\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t \n\tdwc2_writel(hsotg, HPRT0_PWR | HPRT0_CONNDET |\n\t\t\tHPRT0_ENACHG, HPRT0);\n\n\t \n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\tusleep_range(5000, 7000);\n\tspin_lock_irqsave(&hsotg->lock, flags);\nunlock:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int _dwc2_hcd_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\treturn dwc2_hcd_get_frame_number(hsotg);\n}\n\nstatic void dwc2_dump_urb_info(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t       char *fn_name)\n{\n#ifdef VERBOSE_DEBUG\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tchar *pipetype = NULL;\n\tchar *speed = NULL;\n\n\tdev_vdbg(hsotg->dev, \"%s, urb %p\\n\", fn_name, urb);\n\tdev_vdbg(hsotg->dev, \"  Device address: %d\\n\",\n\t\t usb_pipedevice(urb->pipe));\n\tdev_vdbg(hsotg->dev, \"  Endpoint: %d, %s\\n\",\n\t\t usb_pipeendpoint(urb->pipe),\n\t\t usb_pipein(urb->pipe) ? \"IN\" : \"OUT\");\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tpipetype = \"CONTROL\";\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tpipetype = \"BULK\";\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tpipetype = \"INTERRUPT\";\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tpipetype = \"ISOCHRONOUS\";\n\t\tbreak;\n\t}\n\n\tdev_vdbg(hsotg->dev, \"  Endpoint type: %s %s (%s)\\n\", pipetype,\n\t\t usb_urb_dir_in(urb) ? \"IN\" : \"OUT\", usb_pipein(urb->pipe) ?\n\t\t \"IN\" : \"OUT\");\n\n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"HIGH\";\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"FULL\";\n\t\tbreak;\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"LOW\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"UNKNOWN\";\n\t\tbreak;\n\t}\n\n\tdev_vdbg(hsotg->dev, \"  Speed: %s\\n\", speed);\n\tdev_vdbg(hsotg->dev, \"  Max packet size: %d (%d mult)\\n\",\n\t\t usb_endpoint_maxp(&urb->ep->desc),\n\t\t usb_endpoint_maxp_mult(&urb->ep->desc));\n\n\tdev_vdbg(hsotg->dev, \"  Data buffer length: %d\\n\",\n\t\t urb->transfer_buffer_length);\n\tdev_vdbg(hsotg->dev, \"  Transfer buffer: %p, Transfer DMA: %08lx\\n\",\n\t\t urb->transfer_buffer, (unsigned long)urb->transfer_dma);\n\tdev_vdbg(hsotg->dev, \"  Setup buffer: %p, Setup DMA: %08lx\\n\",\n\t\t urb->setup_packet, (unsigned long)urb->setup_dma);\n\tdev_vdbg(hsotg->dev, \"  Interval: %d\\n\", urb->interval);\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\tint i;\n\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tdev_vdbg(hsotg->dev, \"  ISO Desc %d:\\n\", i);\n\t\t\tdev_vdbg(hsotg->dev, \"    offset: %d, length %d\\n\",\n\t\t\t\t urb->iso_frame_desc[i].offset,\n\t\t\t\t urb->iso_frame_desc[i].length);\n\t\t}\n\t}\n#endif\n}\n\n \nstatic int _dwc2_hcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t gfp_t mem_flags)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct usb_host_endpoint *ep = urb->ep;\n\tstruct dwc2_hcd_urb *dwc2_urb;\n\tint i;\n\tint retval;\n\tint alloc_bandwidth = 0;\n\tu8 ep_type = 0;\n\tu32 tflags = 0;\n\tvoid *buf;\n\tunsigned long flags;\n\tstruct dwc2_qh *qh;\n\tbool qh_allocated = false;\n\tstruct dwc2_qtd *qtd;\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\n\tif (dbg_urb(urb)) {\n\t\tdev_vdbg(hsotg->dev, \"DWC OTG HCD URB Enqueue\\n\");\n\t\tdwc2_dump_urb_info(hcd, urb, \"urb_enqueue\");\n\t}\n\n\tif (hsotg->hibernated) {\n\t\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 1);\n\t\telse\n\t\t\tretval = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit hibernation failed.\\n\");\n\t}\n\n\tif (hsotg->in_ppd) {\n\t\tretval = dwc2_exit_partial_power_down(hsotg, 0, true);\n\t\tif (retval)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"exit partial_power_down failed\\n\");\n\t}\n\n\tif (hsotg->params.power_down == DWC2_POWER_DOWN_PARAM_NONE &&\n\t    hsotg->bus_suspended) {\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\tdwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\telse\n\t\t\tdwc2_host_exit_clock_gating(hsotg, 0);\n\t}\n\n\tif (!ep)\n\t\treturn -EINVAL;\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS ||\n\t    usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (!dwc2_hcd_is_bandwidth_allocated(hsotg, ep))\n\t\t\talloc_bandwidth = 1;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\tep_type = USB_ENDPOINT_XFER_CONTROL;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tep_type = USB_ENDPOINT_XFER_ISOC;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tep_type = USB_ENDPOINT_XFER_BULK;\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tep_type = USB_ENDPOINT_XFER_INT;\n\t\tbreak;\n\t}\n\n\tdwc2_urb = dwc2_hcd_urb_alloc(hsotg, urb->number_of_packets,\n\t\t\t\t      mem_flags);\n\tif (!dwc2_urb)\n\t\treturn -ENOMEM;\n\n\tdwc2_hcd_urb_set_pipeinfo(hsotg, dwc2_urb, usb_pipedevice(urb->pipe),\n\t\t\t\t  usb_pipeendpoint(urb->pipe), ep_type,\n\t\t\t\t  usb_pipein(urb->pipe),\n\t\t\t\t  usb_endpoint_maxp(&ep->desc),\n\t\t\t\t  usb_endpoint_maxp_mult(&ep->desc));\n\n\tbuf = urb->transfer_buffer;\n\n\tif (hcd_uses_dma(hcd)) {\n\t\tif (!buf && (urb->transfer_dma & 3)) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: unaligned transfer with no transfer_buffer\",\n\t\t\t\t__func__);\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail0;\n\t\t}\n\t}\n\n\tif (!(urb->transfer_flags & URB_NO_INTERRUPT))\n\t\ttflags |= URB_GIVEBACK_ASAP;\n\tif (urb->transfer_flags & URB_ZERO_PACKET)\n\t\ttflags |= URB_SEND_ZERO_PACKET;\n\n\tdwc2_urb->priv = urb;\n\tdwc2_urb->buf = buf;\n\tdwc2_urb->dma = urb->transfer_dma;\n\tdwc2_urb->length = urb->transfer_buffer_length;\n\tdwc2_urb->setup_packet = urb->setup_packet;\n\tdwc2_urb->setup_dma = urb->setup_dma;\n\tdwc2_urb->flags = tflags;\n\tdwc2_urb->interval = urb->interval;\n\tdwc2_urb->status = -EINPROGRESS;\n\n\tfor (i = 0; i < urb->number_of_packets; ++i)\n\t\tdwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i,\n\t\t\t\t\t\t urb->iso_frame_desc[i].offset,\n\t\t\t\t\t\t urb->iso_frame_desc[i].length);\n\n\turb->hcpriv = dwc2_urb;\n\tqh = (struct dwc2_qh *)ep->hcpriv;\n\t \n\tif (!qh) {\n\t\tqh = dwc2_hcd_qh_create(hsotg, dwc2_urb, mem_flags);\n\t\tif (!qh) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail0;\n\t\t}\n\t\tep->hcpriv = qh;\n\t\tqh_allocated = true;\n\t}\n\n\tqtd = kzalloc(sizeof(*qtd), mem_flags);\n\tif (!qtd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail1;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto fail2;\n\n\tretval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, qh, qtd);\n\tif (retval)\n\t\tgoto fail3;\n\n\tif (alloc_bandwidth) {\n\t\tdwc2_allocate_bus_bandwidth(hcd,\n\t\t\t\tdwc2_hcd_get_ep_bandwidth(hsotg, ep),\n\t\t\t\turb);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn 0;\n\nfail3:\n\tdwc2_urb->priv = NULL;\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\tif (qh_allocated && qh->channel && qh->channel->qh == qh)\n\t\tqh->channel->qh = NULL;\nfail2:\n\turb->hcpriv = NULL;\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\tkfree(qtd);\nfail1:\n\tif (qh_allocated) {\n\t\tstruct dwc2_qtd *qtd2, *qtd2_tmp;\n\n\t\tep->hcpriv = NULL;\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\t \n\t\tlist_for_each_entry_safe(qtd2, qtd2_tmp, &qh->qtd_list,\n\t\t\t\t\t qtd_list_entry)\n\t\t\tdwc2_hcd_qtd_unlink_and_free(hsotg, qtd2, qh);\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t}\nfail0:\n\tkfree(dwc2_urb);\n\n\treturn retval;\n}\n\n \nstatic int _dwc2_hcd_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t int status)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tint rc;\n\tunsigned long flags;\n\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD URB Dequeue\\n\");\n\tdwc2_dump_urb_info(hcd, urb, \"urb_dequeue\");\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto out;\n\n\tif (!urb->hcpriv) {\n\t\tdev_dbg(hsotg->dev, \"## urb->hcpriv is NULL ##\\n\");\n\t\tgoto out;\n\t}\n\n\trc = dwc2_hcd_urb_dequeue(hsotg, urb->hcpriv);\n\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\n\tkfree(urb->hcpriv);\n\turb->hcpriv = NULL;\n\n\t \n\tspin_unlock(&hsotg->lock);\n\tusb_hcd_giveback_urb(hcd, urb, status);\n\tspin_lock(&hsotg->lock);\n\n\tdev_dbg(hsotg->dev, \"Called usb_hcd_giveback_urb()\\n\");\n\tdev_dbg(hsotg->dev, \"  urb->status = %d\\n\", urb->status);\nout:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn rc;\n}\n\n \nstatic void _dwc2_hcd_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t       struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\tdev_dbg(hsotg->dev,\n\t\t\"DWC OTG HCD EP DISABLE: bEndpointAddress=0x%02x, ep->hcpriv=%p\\n\",\n\t\tep->desc.bEndpointAddress, ep->hcpriv);\n\tdwc2_hcd_endpoint_disable(hsotg, ep, 250);\n}\n\n \nstatic void _dwc2_hcd_endpoint_reset(struct usb_hcd *hcd,\n\t\t\t\t     struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tunsigned long flags;\n\n\tdev_dbg(hsotg->dev,\n\t\t\"DWC OTG HCD EP RESET: bEndpointAddress=0x%02x\\n\",\n\t\tep->desc.bEndpointAddress);\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tdwc2_hcd_endpoint_reset(hsotg, ep);\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\n \nstatic irqreturn_t _dwc2_hcd_irq(struct usb_hcd *hcd)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\treturn dwc2_handle_hcd_intr(hsotg);\n}\n\n \nstatic int _dwc2_hcd_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\tbuf[0] = dwc2_hcd_is_status_changed(hsotg, 1) << 1;\n\treturn buf[0] != 0;\n}\n\n \nstatic int _dwc2_hcd_hub_control(struct usb_hcd *hcd, u16 typereq, u16 wvalue,\n\t\t\t\t u16 windex, char *buf, u16 wlength)\n{\n\tint retval = dwc2_hcd_hub_control(dwc2_hcd_to_hsotg(hcd), typereq,\n\t\t\t\t\t  wvalue, windex, buf, wlength);\n\treturn retval;\n}\n\n \nstatic void _dwc2_hcd_clear_tt_buffer_complete(struct usb_hcd *hcd,\n\t\t\t\t\t       struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\tstruct dwc2_qh *qh;\n\tunsigned long flags;\n\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\treturn;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tqh->tt_buffer_dirty = 0;\n\n\tif (hsotg->flags.b.port_connect_status)\n\t\tdwc2_hcd_queue_transactions(hsotg, DWC2_TRANSACTION_ALL);\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\n \nstatic void dwc2_change_bus_speed(struct usb_hcd *hcd, int speed)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\tif (hsotg->params.speed == speed)\n\t\treturn;\n\n\thsotg->params.speed = speed;\n\tqueue_work(hsotg->wq_otg, &hsotg->wf_otg);\n}\n\nstatic void dwc2_free_dev(struct usb_hcd *hcd, struct usb_device *udev)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\tif (!hsotg->params.change_speed_quirk)\n\t\treturn;\n\n\t \n\tif (udev->parent && udev->parent->speed > USB_SPEED_UNKNOWN &&\n\t    udev->parent->speed < USB_SPEED_HIGH) {\n\t\tdev_info(hsotg->dev, \"Set speed to default high-speed\\n\");\n\t\tdwc2_change_bus_speed(hcd, HPRT0_SPD_HIGH_SPEED);\n\t}\n}\n\nstatic int dwc2_reset_device(struct usb_hcd *hcd, struct usb_device *udev)\n{\n\tstruct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);\n\n\tif (!hsotg->params.change_speed_quirk)\n\t\treturn 0;\n\n\tif (udev->speed == USB_SPEED_HIGH) {\n\t\tdev_info(hsotg->dev, \"Set speed to high-speed\\n\");\n\t\tdwc2_change_bus_speed(hcd, HPRT0_SPD_HIGH_SPEED);\n\t} else if ((udev->speed == USB_SPEED_FULL ||\n\t\t\t\tudev->speed == USB_SPEED_LOW)) {\n\t\t \n\t\tdev_info(hsotg->dev, \"Set speed to full-speed\\n\");\n\t\tdwc2_change_bus_speed(hcd, HPRT0_SPD_FULL_SPEED);\n\t}\n\n\treturn 0;\n}\n\nstatic struct hc_driver dwc2_hc_driver = {\n\t.description = \"dwc2_hsotg\",\n\t.product_desc = \"DWC OTG Controller\",\n\t.hcd_priv_size = sizeof(struct wrapper_priv_data),\n\n\t.irq = _dwc2_hcd_irq,\n\t.flags = HCD_MEMORY | HCD_USB2 | HCD_BH,\n\n\t.start = _dwc2_hcd_start,\n\t.stop = _dwc2_hcd_stop,\n\t.urb_enqueue = _dwc2_hcd_urb_enqueue,\n\t.urb_dequeue = _dwc2_hcd_urb_dequeue,\n\t.endpoint_disable = _dwc2_hcd_endpoint_disable,\n\t.endpoint_reset = _dwc2_hcd_endpoint_reset,\n\t.get_frame_number = _dwc2_hcd_get_frame_number,\n\n\t.hub_status_data = _dwc2_hcd_hub_status_data,\n\t.hub_control = _dwc2_hcd_hub_control,\n\t.clear_tt_buffer_complete = _dwc2_hcd_clear_tt_buffer_complete,\n\n\t.bus_suspend = _dwc2_hcd_suspend,\n\t.bus_resume = _dwc2_hcd_resume,\n\n\t.map_urb_for_dma\t= dwc2_map_urb_for_dma,\n\t.unmap_urb_for_dma\t= dwc2_unmap_urb_for_dma,\n};\n\n \nstatic void dwc2_hcd_free(struct dwc2_hsotg *hsotg)\n{\n\tu32 ahbcfg;\n\tu32 dctl;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD FREE\\n\");\n\n\t \n\tdwc2_qh_list_free(hsotg, &hsotg->non_periodic_sched_inactive);\n\tdwc2_qh_list_free(hsotg, &hsotg->non_periodic_sched_waiting);\n\tdwc2_qh_list_free(hsotg, &hsotg->non_periodic_sched_active);\n\tdwc2_qh_list_free(hsotg, &hsotg->periodic_sched_inactive);\n\tdwc2_qh_list_free(hsotg, &hsotg->periodic_sched_ready);\n\tdwc2_qh_list_free(hsotg, &hsotg->periodic_sched_assigned);\n\tdwc2_qh_list_free(hsotg, &hsotg->periodic_sched_queued);\n\n\t \n\tfor (i = 0; i < MAX_EPS_CHANNELS; i++) {\n\t\tstruct dwc2_host_chan *chan = hsotg->hc_ptr_array[i];\n\n\t\tif (chan) {\n\t\t\tdev_dbg(hsotg->dev, \"HCD Free channel #%i, chan=%p\\n\",\n\t\t\t\ti, chan);\n\t\t\thsotg->hc_ptr_array[i] = NULL;\n\t\t\tkfree(chan);\n\t\t}\n\t}\n\n\tif (hsotg->params.host_dma) {\n\t\tif (hsotg->status_buf) {\n\t\t\tdma_free_coherent(hsotg->dev, DWC2_HCD_STATUS_BUF_SIZE,\n\t\t\t\t\t  hsotg->status_buf,\n\t\t\t\t\t  hsotg->status_buf_dma);\n\t\t\thsotg->status_buf = NULL;\n\t\t}\n\t} else {\n\t\tkfree(hsotg->status_buf);\n\t\thsotg->status_buf = NULL;\n\t}\n\n\tahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\n\t \n\tahbcfg &= ~GAHBCFG_GLBL_INTR_EN;\n\tdwc2_writel(hsotg, ahbcfg, GAHBCFG);\n\tdwc2_writel(hsotg, 0, GINTMSK);\n\n\tif (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a) {\n\t\tdctl = dwc2_readl(hsotg, DCTL);\n\t\tdctl |= DCTL_SFTDISCON;\n\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t}\n\n\tif (hsotg->wq_otg) {\n\t\tif (!cancel_work_sync(&hsotg->wf_otg))\n\t\t\tflush_workqueue(hsotg->wq_otg);\n\t\tdestroy_workqueue(hsotg->wq_otg);\n\t}\n\n\tcancel_work_sync(&hsotg->phy_reset_work);\n\n\tdel_timer(&hsotg->wkp_timer);\n}\n\nstatic void dwc2_hcd_release(struct dwc2_hsotg *hsotg)\n{\n\t \n\tdwc2_disable_host_interrupts(hsotg);\n\n\tdwc2_hcd_free(hsotg);\n}\n\n \nint dwc2_hcd_init(struct dwc2_hsotg *hsotg)\n{\n\tstruct platform_device *pdev = to_platform_device(hsotg->dev);\n\tstruct resource *res;\n\tstruct usb_hcd *hcd;\n\tstruct dwc2_host_chan *channel;\n\tu32 hcfg;\n\tint i, num_channels;\n\tint retval;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD INIT\\n\");\n\n\tretval = -ENOMEM;\n\n\thcfg = dwc2_readl(hsotg, HCFG);\n\tdev_dbg(hsotg->dev, \"hcfg=%08x\\n\", hcfg);\n\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\n\thsotg->frame_num_array = kcalloc(FRAME_NUM_ARRAY_SIZE,\n\t\t\t\t\t sizeof(*hsotg->frame_num_array),\n\t\t\t\t\t GFP_KERNEL);\n\tif (!hsotg->frame_num_array)\n\t\tgoto error1;\n\thsotg->last_frame_num_array =\n\t\tkcalloc(FRAME_NUM_ARRAY_SIZE,\n\t\t\tsizeof(*hsotg->last_frame_num_array), GFP_KERNEL);\n\tif (!hsotg->last_frame_num_array)\n\t\tgoto error1;\n#endif\n\thsotg->last_frame_num = HFNUM_MAX_FRNUM;\n\n\t \n\tif (hsotg->params.host_dma &&\n\t    !hsotg->dev->dma_mask) {\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"dma_mask not set, disabling DMA\\n\");\n\t\thsotg->params.host_dma = false;\n\t\thsotg->params.dma_desc_enable = false;\n\t}\n\n\t \n\tif (hsotg->params.host_dma) {\n\t\tif (dma_set_mask(hsotg->dev, DMA_BIT_MASK(32)) < 0)\n\t\t\tdev_warn(hsotg->dev, \"can't set DMA mask\\n\");\n\t\tif (dma_set_coherent_mask(hsotg->dev, DMA_BIT_MASK(32)) < 0)\n\t\t\tdev_warn(hsotg->dev, \"can't set coherent DMA mask\\n\");\n\t}\n\n\tif (hsotg->params.change_speed_quirk) {\n\t\tdwc2_hc_driver.free_dev = dwc2_free_dev;\n\t\tdwc2_hc_driver.reset_device = dwc2_reset_device;\n\t}\n\n\tif (hsotg->params.host_dma)\n\t\tdwc2_hc_driver.flags |= HCD_DMA;\n\n\thcd = usb_create_hcd(&dwc2_hc_driver, hsotg->dev, dev_name(hsotg->dev));\n\tif (!hcd)\n\t\tgoto error1;\n\n\thcd->has_tt = 1;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tretval = -EINVAL;\n\t\tgoto error2;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\t((struct wrapper_priv_data *)&hcd->hcd_priv)->hsotg = hsotg;\n\thsotg->priv = hcd;\n\n\t \n\tdwc2_disable_global_interrupts(hsotg);\n\n\t \n\tretval = dwc2_core_init(hsotg, true);\n\tif (retval)\n\t\tgoto error2;\n\n\t \n\tretval = -ENOMEM;\n\thsotg->wq_otg = alloc_ordered_workqueue(\"dwc2\", 0);\n\tif (!hsotg->wq_otg) {\n\t\tdev_err(hsotg->dev, \"Failed to create workqueue\\n\");\n\t\tgoto error2;\n\t}\n\tINIT_WORK(&hsotg->wf_otg, dwc2_conn_id_status_change);\n\n\ttimer_setup(&hsotg->wkp_timer, dwc2_wakeup_detected, 0);\n\n\t \n\tINIT_LIST_HEAD(&hsotg->non_periodic_sched_inactive);\n\tINIT_LIST_HEAD(&hsotg->non_periodic_sched_waiting);\n\tINIT_LIST_HEAD(&hsotg->non_periodic_sched_active);\n\n\t \n\tINIT_LIST_HEAD(&hsotg->periodic_sched_inactive);\n\tINIT_LIST_HEAD(&hsotg->periodic_sched_ready);\n\tINIT_LIST_HEAD(&hsotg->periodic_sched_assigned);\n\tINIT_LIST_HEAD(&hsotg->periodic_sched_queued);\n\n\tINIT_LIST_HEAD(&hsotg->split_order);\n\n\t \n\tINIT_LIST_HEAD(&hsotg->free_hc_list);\n\tnum_channels = hsotg->params.host_channels;\n\tmemset(&hsotg->hc_ptr_array[0], 0, sizeof(hsotg->hc_ptr_array));\n\n\tfor (i = 0; i < num_channels; i++) {\n\t\tchannel = kzalloc(sizeof(*channel), GFP_KERNEL);\n\t\tif (!channel)\n\t\t\tgoto error3;\n\t\tchannel->hc_num = i;\n\t\tINIT_LIST_HEAD(&channel->split_order_list_entry);\n\t\thsotg->hc_ptr_array[i] = channel;\n\t}\n\n\t \n\tINIT_DELAYED_WORK(&hsotg->start_work, dwc2_hcd_start_func);\n\tINIT_DELAYED_WORK(&hsotg->reset_work, dwc2_hcd_reset_func);\n\tINIT_WORK(&hsotg->phy_reset_work, dwc2_hcd_phy_reset_func);\n\n\t \n\tif (hsotg->params.host_dma)\n\t\thsotg->status_buf = dma_alloc_coherent(hsotg->dev,\n\t\t\t\t\tDWC2_HCD_STATUS_BUF_SIZE,\n\t\t\t\t\t&hsotg->status_buf_dma, GFP_KERNEL);\n\telse\n\t\thsotg->status_buf = kzalloc(DWC2_HCD_STATUS_BUF_SIZE,\n\t\t\t\t\t  GFP_KERNEL);\n\n\tif (!hsotg->status_buf)\n\t\tgoto error3;\n\n\t \n\tif (hsotg->params.dma_desc_enable ||\n\t    hsotg->params.dma_desc_fs_enable) {\n\t\thsotg->desc_gen_cache = kmem_cache_create(\"dwc2-gen-desc\",\n\t\t\t\tsizeof(struct dwc2_dma_desc) *\n\t\t\t\tMAX_DMA_DESC_NUM_GENERIC, 512, SLAB_CACHE_DMA,\n\t\t\t\tNULL);\n\t\tif (!hsotg->desc_gen_cache) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"unable to create dwc2 generic desc cache\\n\");\n\n\t\t\t \n\t\t\thsotg->params.dma_desc_enable = false;\n\t\t\thsotg->params.dma_desc_fs_enable = false;\n\t\t}\n\n\t\thsotg->desc_hsisoc_cache = kmem_cache_create(\"dwc2-hsisoc-desc\",\n\t\t\t\tsizeof(struct dwc2_dma_desc) *\n\t\t\t\tMAX_DMA_DESC_NUM_HS_ISOC, 512, 0, NULL);\n\t\tif (!hsotg->desc_hsisoc_cache) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"unable to create dwc2 hs isoc desc cache\\n\");\n\n\t\t\tkmem_cache_destroy(hsotg->desc_gen_cache);\n\n\t\t\t \n\t\t\thsotg->params.dma_desc_enable = false;\n\t\t\thsotg->params.dma_desc_fs_enable = false;\n\t\t}\n\t}\n\n\tif (hsotg->params.host_dma) {\n\t\t \n\t\thsotg->unaligned_cache = kmem_cache_create(\"dwc2-unaligned-dma\",\n\t\t\t\t\t\tDWC2_KMEM_UNALIGNED_BUF_SIZE, 4,\n\t\t\t\t\t\tSLAB_CACHE_DMA, NULL);\n\t\tif (!hsotg->unaligned_cache)\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"unable to create dwc2 unaligned cache\\n\");\n\t}\n\n\thsotg->otg_port = 1;\n\thsotg->frame_list = NULL;\n\thsotg->frame_list_dma = 0;\n\thsotg->periodic_qh_count = 0;\n\n\t \n\thsotg->lx_state = DWC2_L3;\n\n\thcd->self.otg_port = hsotg->otg_port;\n\n\t \n\thcd->self.sg_tablesize = 0;\n\n\thcd->tpl_support = of_usb_host_tpl_support(hsotg->dev->of_node);\n\n\tif (!IS_ERR_OR_NULL(hsotg->uphy))\n\t\totg_set_host(hsotg->uphy->otg, &hcd->self);\n\n\t \n\tretval = usb_add_hcd(hcd, hsotg->irq, IRQF_SHARED);\n\tif (retval < 0)\n\t\tgoto error4;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tdwc2_hcd_dump_state(hsotg);\n\n\tdwc2_enable_global_interrupts(hsotg);\n\n\treturn 0;\n\nerror4:\n\tkmem_cache_destroy(hsotg->unaligned_cache);\n\tkmem_cache_destroy(hsotg->desc_hsisoc_cache);\n\tkmem_cache_destroy(hsotg->desc_gen_cache);\nerror3:\n\tdwc2_hcd_release(hsotg);\nerror2:\n\tusb_put_hcd(hcd);\nerror1:\n\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\n\tkfree(hsotg->last_frame_num_array);\n\tkfree(hsotg->frame_num_array);\n#endif\n\n\tdev_err(hsotg->dev, \"%s() FAILED, returning %d\\n\", __func__, retval);\n\treturn retval;\n}\n\n \nvoid dwc2_hcd_remove(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_hcd *hcd;\n\n\tdev_dbg(hsotg->dev, \"DWC OTG HCD REMOVE\\n\");\n\n\thcd = dwc2_hsotg_to_hcd(hsotg);\n\tdev_dbg(hsotg->dev, \"hsotg->hcd = %p\\n\", hcd);\n\n\tif (!hcd) {\n\t\tdev_dbg(hsotg->dev, \"%s: dwc2_hsotg_to_hcd(hsotg) NULL!\\n\",\n\t\t\t__func__);\n\t\treturn;\n\t}\n\n\tif (!IS_ERR_OR_NULL(hsotg->uphy))\n\t\totg_set_host(hsotg->uphy->otg, NULL);\n\n\tusb_remove_hcd(hcd);\n\thsotg->priv = NULL;\n\n\tkmem_cache_destroy(hsotg->unaligned_cache);\n\tkmem_cache_destroy(hsotg->desc_hsisoc_cache);\n\tkmem_cache_destroy(hsotg->desc_gen_cache);\n\n\tdwc2_hcd_release(hsotg);\n\tusb_put_hcd(hcd);\n\n#ifdef CONFIG_USB_DWC2_TRACK_MISSED_SOFS\n\tkfree(hsotg->last_frame_num_array);\n\tkfree(hsotg->frame_num_array);\n#endif\n}\n\n \nint dwc2_backup_host_registers(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hregs_backup *hr;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\thr = &hsotg->hr_backup;\n\thr->hcfg = dwc2_readl(hsotg, HCFG);\n\thr->haintmsk = dwc2_readl(hsotg, HAINTMSK);\n\tfor (i = 0; i < hsotg->params.host_channels; ++i)\n\t\thr->hcintmsk[i] = dwc2_readl(hsotg, HCINTMSK(i));\n\n\thr->hprt0 = dwc2_read_hprt0(hsotg);\n\thr->hfir = dwc2_readl(hsotg, HFIR);\n\thr->hptxfsiz = dwc2_readl(hsotg, HPTXFSIZ);\n\thr->valid = true;\n\n\treturn 0;\n}\n\n \nint dwc2_restore_host_registers(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hregs_backup *hr;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\thr = &hsotg->hr_backup;\n\tif (!hr->valid) {\n\t\tdev_err(hsotg->dev, \"%s: no host registers to restore\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\thr->valid = false;\n\n\tdwc2_writel(hsotg, hr->hcfg, HCFG);\n\tdwc2_writel(hsotg, hr->haintmsk, HAINTMSK);\n\n\tfor (i = 0; i < hsotg->params.host_channels; ++i)\n\t\tdwc2_writel(hsotg, hr->hcintmsk[i], HCINTMSK(i));\n\n\tdwc2_writel(hsotg, hr->hprt0, HPRT0);\n\tdwc2_writel(hsotg, hr->hfir, HFIR);\n\tdwc2_writel(hsotg, hr->hptxfsiz, HPTXFSIZ);\n\thsotg->frame_number = 0;\n\n\treturn 0;\n}\n\n \nint dwc2_host_enter_hibernation(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\tint ret = 0;\n\tu32 hprt0;\n\tu32 pcgcctl;\n\tu32 gusbcfg;\n\tu32 gpwrdn;\n\n\tdev_dbg(hsotg->dev, \"Preparing host for hibernation\\n\");\n\tret = dwc2_backup_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup global registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\tret = dwc2_backup_host_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup host registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\thprt0 = dwc2_readl(hsotg, HPRT0);\n\thprt0 |= HPRT0_SUSP;\n\thprt0 &= ~HPRT0_ENA;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 5000))\n\t\tdev_warn(hsotg->dev, \"Suspend wasn't generated\\n\");\n\n\t \n\tspin_lock_irqsave(&hsotg->lock, flags);\n\thsotg->lx_state = DWC2_L2;\n\n\tgusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tif (gusbcfg & GUSBCFG_ULPI_UTMI_SEL) {\n\t\t \n\t\t \n\t\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\t\tpcgcctl |= PCGCTL_STOPPCLK;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\n\t\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\t\tgpwrdn |= GPWRDN_PMUACTV;\n\t\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\t\tudelay(10);\n\t} else {\n\t\t \n\t\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\t\tgpwrdn |= GPWRDN_PMUACTV;\n\t\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\t\tudelay(10);\n\n\t\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\t\tpcgcctl |= PCGCTL_STOPPCLK;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\t}\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PMUINTSEL;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_DISCONN_DET_MSK;\n\tgpwrdn |= GPWRDN_LNSTSCHG_MSK;\n\tgpwrdn |= GPWRDN_STS_CHGINT_MSK;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PWRDNCLMP;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PWRDNSWTCH;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\n\thsotg->hibernated = 1;\n\thsotg->bus_suspended = 1;\n\tdev_dbg(hsotg->dev, \"Host hibernation completed\\n\");\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\treturn ret;\n}\n\n \nint dwc2_host_exit_hibernation(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t       int reset)\n{\n\tu32 gpwrdn;\n\tu32 hprt0;\n\tint ret = 0;\n\tstruct dwc2_gregs_backup *gr;\n\tstruct dwc2_hregs_backup *hr;\n\n\tgr = &hsotg->gr_backup;\n\thr = &hsotg->hr_backup;\n\n\tdev_dbg(hsotg->dev,\n\t\t\"%s: called with rem_wakeup = %d reset = %d\\n\",\n\t\t__func__, rem_wakeup, reset);\n\n\tdwc2_hib_restore_common(hsotg, rem_wakeup, 1);\n\thsotg->hibernated = 0;\n\n\t \n\tmdelay(100);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_RESTORE;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tdwc2_writel(hsotg, gr->gusbcfg, GUSBCFG);\n\tdwc2_writel(hsotg, hr->hcfg, HCFG);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PMUACTV;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\thprt0 = hr->hprt0;\n\thprt0 |= HPRT0_PWR;\n\thprt0 &= ~HPRT0_ENA;\n\thprt0 &= ~HPRT0_SUSP;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\thprt0 = hr->hprt0;\n\thprt0 |= HPRT0_PWR;\n\thprt0 &= ~HPRT0_ENA;\n\thprt0 &= ~HPRT0_SUSP;\n\n\tif (reset) {\n\t\thprt0 |= HPRT0_RST;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t\t \n\t\tmdelay(60);\n\t\thprt0 &= ~HPRT0_RST;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t} else {\n\t\thprt0 |= HPRT0_RES;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t\t \n\t\tmdelay(100);\n\t\thprt0 &= ~HPRT0_RES;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t}\n\t \n\thprt0 = dwc2_readl(hsotg, HPRT0);\n\thprt0 |= HPRT0_CONNDET;\n\thprt0 |= HPRT0_ENACHG;\n\thprt0 &= ~HPRT0_ENA;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\thprt0 = dwc2_readl(hsotg, HPRT0);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tret = dwc2_restore_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to restore registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tret = dwc2_restore_host_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to restore host registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (rem_wakeup) {\n\t\tdwc2_hcd_rem_wakeup(hsotg);\n\t\t \n\t\thsotg->flags.b.port_connect_status_change = 1;\n\t}\n\n\thsotg->hibernated = 0;\n\thsotg->bus_suspended = 0;\n\thsotg->lx_state = DWC2_L0;\n\tdev_dbg(hsotg->dev, \"Host hibernation restore complete\\n\");\n\treturn ret;\n}\n\nbool dwc2_host_can_poweroff_phy(struct dwc2_hsotg *dwc2)\n{\n\tstruct usb_device *root_hub = dwc2_hsotg_to_hcd(dwc2)->self.root_hub;\n\n\t \n\tif (!device_may_wakeup(dwc2->dev))\n\t\treturn true;\n\n\t \n\tif (usb_wakeup_enabled_descendants(root_hub))\n\t\treturn false;\n\n\t \n\treturn true;\n}\n\n \nint dwc2_host_enter_partial_power_down(struct dwc2_hsotg *hsotg)\n{\n\tu32 pcgcctl;\n\tu32 hprt0;\n\tint ret = 0;\n\n\tdev_dbg(hsotg->dev, \"Entering host partial power down started.\\n\");\n\n\t \n\thprt0 = dwc2_read_hprt0(hsotg);\n\thprt0 |= HPRT0_SUSP;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\tudelay(5);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, HPRT0, HPRT0_SUSP, 3000))\n\t\tdev_warn(hsotg->dev, \"Suspend wasn't generated\\n\");\n\n\t \n\tret = dwc2_backup_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup global registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tret = dwc2_backup_host_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup host registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\n\tpcgcctl |= PCGCTL_PWRCLMP;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl |= PCGCTL_RSTPDWNMODULE;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl |= PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\t \n\thsotg->in_ppd = 1;\n\thsotg->lx_state = DWC2_L2;\n\thsotg->bus_suspended = true;\n\n\tdev_dbg(hsotg->dev, \"Entering host partial power down completed.\\n\");\n\n\treturn ret;\n}\n\n \nint dwc2_host_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t      int rem_wakeup, bool restore)\n{\n\tu32 pcgcctl;\n\tint ret = 0;\n\tu32 hprt0;\n\n\tdev_dbg(hsotg->dev, \"Exiting host partial power down started.\\n\");\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_PWRCLMP;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_RSTPDWNMODULE;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\tudelay(100);\n\tif (restore) {\n\t\tret = dwc2_restore_global_registers(hsotg);\n\t\tif (ret) {\n\t\t\tdev_err(hsotg->dev, \"%s: failed to restore registers\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = dwc2_restore_host_registers(hsotg);\n\t\tif (ret) {\n\t\t\tdev_err(hsotg->dev, \"%s: failed to restore host registers\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\thprt0 = dwc2_read_hprt0(hsotg);\n\thprt0 |= HPRT0_RES;\n\thprt0 &= ~HPRT0_SUSP;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\tudelay(5);\n\n\tif (!rem_wakeup) {\n\t\t \n\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\thprt0 &= ~HPRT0_RES;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t\thsotg->bus_suspended = false;\n\t} else {\n\t\t \n\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\thprt0 |= HPRT0_PWR;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t\t \n\t\tdwc2_hcd_connect(hsotg);\n\n\t\tmod_timer(&hsotg->wkp_timer,\n\t\t\t  jiffies + msecs_to_jiffies(71));\n\t}\n\n\t \n\thsotg->in_ppd = 0;\n\thsotg->lx_state = DWC2_L0;\n\n\tdev_dbg(hsotg->dev, \"Exiting host partial power down completed.\\n\");\n\treturn ret;\n}\n\n \nvoid dwc2_host_enter_clock_gating(struct dwc2_hsotg *hsotg)\n{\n\tu32 hprt0;\n\tu32 pcgctl;\n\n\tdev_dbg(hsotg->dev, \"Entering host clock gating.\\n\");\n\n\t \n\thprt0 = dwc2_read_hprt0(hsotg);\n\thprt0 |= HPRT0_SUSP;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl |= PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl |= PCGCTL_GATEHCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\thsotg->bus_suspended = true;\n\thsotg->lx_state = DWC2_L2;\n}\n\n \nvoid dwc2_host_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)\n{\n\tu32 hprt0;\n\tu32 pcgctl;\n\n\tdev_dbg(hsotg->dev, \"Exiting host clock gating.\\n\");\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl &= ~PCGCTL_GATEHCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl &= ~PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\t \n\thprt0 = dwc2_read_hprt0(hsotg);\n\thprt0 |= HPRT0_RES;\n\thprt0 &= ~HPRT0_SUSP;\n\tdwc2_writel(hsotg, hprt0, HPRT0);\n\tudelay(5);\n\n\tif (!rem_wakeup) {\n\t\t \n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t \n\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\thprt0 &= ~HPRT0_RES;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\n\t\thsotg->bus_suspended = false;\n\t\thsotg->lx_state = DWC2_L0;\n\t} else {\n\t\tmod_timer(&hsotg->wkp_timer,\n\t\t\t  jiffies + msecs_to_jiffies(71));\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}