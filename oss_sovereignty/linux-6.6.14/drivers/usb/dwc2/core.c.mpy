{
  "module_name": "core.c",
  "hash_id": "b81bb2bf2462554bc1e1ab505b771823f3eea0d0e0f6bb753690c2e86f906556",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/core.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\n \nint dwc2_backup_global_registers(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_gregs_backup *gr;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\tgr = &hsotg->gr_backup;\n\n\tgr->gotgctl = dwc2_readl(hsotg, GOTGCTL);\n\tgr->gintmsk = dwc2_readl(hsotg, GINTMSK);\n\tgr->gahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\tgr->gusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tgr->grxfsiz = dwc2_readl(hsotg, GRXFSIZ);\n\tgr->gnptxfsiz = dwc2_readl(hsotg, GNPTXFSIZ);\n\tgr->gdfifocfg = dwc2_readl(hsotg, GDFIFOCFG);\n\tgr->pcgcctl1 = dwc2_readl(hsotg, PCGCCTL1);\n\tgr->glpmcfg = dwc2_readl(hsotg, GLPMCFG);\n\tgr->gi2cctl = dwc2_readl(hsotg, GI2CCTL);\n\tgr->pcgcctl = dwc2_readl(hsotg, PCGCTL);\n\n\tgr->valid = true;\n\treturn 0;\n}\n\n \nint dwc2_restore_global_registers(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_gregs_backup *gr;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\tgr = &hsotg->gr_backup;\n\tif (!gr->valid) {\n\t\tdev_err(hsotg->dev, \"%s: no global registers to restore\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tgr->valid = false;\n\n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\tdwc2_writel(hsotg, gr->gotgctl, GOTGCTL);\n\tdwc2_writel(hsotg, gr->gintmsk, GINTMSK);\n\tdwc2_writel(hsotg, gr->gusbcfg, GUSBCFG);\n\tdwc2_writel(hsotg, gr->gahbcfg, GAHBCFG);\n\tdwc2_writel(hsotg, gr->grxfsiz, GRXFSIZ);\n\tdwc2_writel(hsotg, gr->gnptxfsiz, GNPTXFSIZ);\n\tdwc2_writel(hsotg, gr->gdfifocfg, GDFIFOCFG);\n\tdwc2_writel(hsotg, gr->pcgcctl1, PCGCCTL1);\n\tdwc2_writel(hsotg, gr->glpmcfg, GLPMCFG);\n\tdwc2_writel(hsotg, gr->pcgcctl, PCGCTL);\n\tdwc2_writel(hsotg, gr->gi2cctl, GI2CCTL);\n\n\treturn 0;\n}\n\n \nint dwc2_exit_partial_power_down(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t\t bool restore)\n{\n\tstruct dwc2_gregs_backup *gr;\n\n\tgr = &hsotg->gr_backup;\n\n\t \n\tif (gr->gotgctl & GOTGCTL_CURMODE_HOST)\n\t\treturn dwc2_host_exit_partial_power_down(hsotg, rem_wakeup,\n\t\t\t\t\t\t\t restore);\n\telse\n\t\treturn dwc2_gadget_exit_partial_power_down(hsotg, restore);\n}\n\n \nint dwc2_enter_partial_power_down(struct dwc2_hsotg *hsotg)\n{\n\tif (dwc2_is_host_mode(hsotg))\n\t\treturn dwc2_host_enter_partial_power_down(hsotg);\n\telse\n\t\treturn dwc2_gadget_enter_partial_power_down(hsotg);\n}\n\n \nstatic void dwc2_restore_essential_regs(struct dwc2_hsotg *hsotg, int rmode,\n\t\t\t\t\tint is_host)\n{\n\tu32 pcgcctl;\n\tstruct dwc2_gregs_backup *gr;\n\tstruct dwc2_dregs_backup *dr;\n\tstruct dwc2_hregs_backup *hr;\n\n\tgr = &hsotg->gr_backup;\n\tdr = &hsotg->dr_backup;\n\thr = &hsotg->hr_backup;\n\n\tdev_dbg(hsotg->dev, \"%s: restoring essential regs\\n\", __func__);\n\n\t \n\tpcgcctl = (gr->pcgcctl & 0xffffc000);\n\t \n\tif (is_host) {\n\t\tif (!(pcgcctl & PCGCTL_P2HD_PRT_SPD_MASK))\n\t\t\tpcgcctl |= BIT(17);\n\t} else {\n\t\tif (!(pcgcctl & PCGCTL_P2HD_DEV_ENUM_SPD_MASK))\n\t\t\tpcgcctl |= BIT(17);\n\t}\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\t \n\tdwc2_writel(hsotg, gr->gahbcfg | GAHBCFG_GLBL_INTR_EN, GAHBCFG);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_RESTOREDONE, GINTMSK);\n\n\t \n\tdwc2_writel(hsotg, gr->gusbcfg, GUSBCFG);\n\n\tif (is_host) {\n\t\tdwc2_writel(hsotg, hr->hcfg, HCFG);\n\t\tif (rmode)\n\t\t\tpcgcctl |= PCGCTL_RESTOREMODE;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\n\t\tpcgcctl |= PCGCTL_ESS_REG_RESTORED;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\t} else {\n\t\tdwc2_writel(hsotg, dr->dcfg, DCFG);\n\t\tif (!rmode)\n\t\t\tpcgcctl |= PCGCTL_RESTOREMODE | PCGCTL_RSTPDWNMODULE;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\n\t\tpcgcctl |= PCGCTL_ESS_REG_RESTORED;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\tudelay(10);\n\t}\n}\n\n \nvoid dwc2_hib_restore_common(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t     int is_host)\n{\n\tu32 gpwrdn;\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PWRDNSWTCH;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PWRDNRSTN;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_RESTORE;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PWRDNCLMP;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(50);\n\n\tif (!is_host && rem_wakeup)\n\t\tudelay(70);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PWRDNRSTN;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PMUINTSEL;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tdwc2_restore_essential_regs(hsotg, rem_wakeup, is_host);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS, GINTSTS_RESTOREDONE,\n\t\t\t\t    20000)) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: Restore Done wasn't generated here\\n\",\n\t\t\t__func__);\n\t} else {\n\t\tdev_dbg(hsotg->dev, \"restore done  generated here\\n\");\n\n\t\t \n\t\tdwc2_writel(hsotg, GINTSTS_RESTOREDONE, GINTSTS);\n\t}\n}\n\n \nstatic void dwc2_wait_for_mode(struct dwc2_hsotg *hsotg,\n\t\t\t       bool host_mode)\n{\n\tktime_t start;\n\tktime_t end;\n\tunsigned int timeout = 110;\n\n\tdev_vdbg(hsotg->dev, \"Waiting for %s mode\\n\",\n\t\t host_mode ? \"host\" : \"device\");\n\n\tstart = ktime_get();\n\n\twhile (1) {\n\t\ts64 ms;\n\n\t\tif (dwc2_is_host_mode(hsotg) == host_mode) {\n\t\t\tdev_vdbg(hsotg->dev, \"%s mode set\\n\",\n\t\t\t\t host_mode ? \"Host\" : \"Device\");\n\t\t\tbreak;\n\t\t}\n\n\t\tend = ktime_get();\n\t\tms = ktime_to_ms(ktime_sub(end, start));\n\n\t\tif (ms >= (s64)timeout) {\n\t\t\tdev_warn(hsotg->dev, \"%s: Couldn't set %s mode\\n\",\n\t\t\t\t __func__, host_mode ? \"host\" : \"device\");\n\t\t\tbreak;\n\t\t}\n\n\t\tusleep_range(1000, 2000);\n\t}\n}\n\n \nstatic bool dwc2_iddig_filter_enabled(struct dwc2_hsotg *hsotg)\n{\n\tu32 gsnpsid;\n\tu32 ghwcfg4;\n\n\tif (!dwc2_hw_is_otg(hsotg))\n\t\treturn false;\n\n\t \n\tghwcfg4 = dwc2_readl(hsotg, GHWCFG4);\n\tif (!(ghwcfg4 & GHWCFG4_IDDIG_FILT_EN))\n\t\treturn false;\n\n\t \n\tgsnpsid = dwc2_readl(hsotg, GSNPSID);\n\tif (gsnpsid >= DWC2_CORE_REV_3_10a) {\n\t\tu32 gotgctl = dwc2_readl(hsotg, GOTGCTL);\n\n\t\tif (gotgctl & GOTGCTL_DBNCE_FLTR_BYPASS)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nint dwc2_enter_hibernation(struct dwc2_hsotg *hsotg, int is_host)\n{\n\tif (is_host)\n\t\treturn dwc2_host_enter_hibernation(hsotg);\n\telse\n\t\treturn dwc2_gadget_enter_hibernation(hsotg);\n}\n\n \nint dwc2_exit_hibernation(struct dwc2_hsotg *hsotg, int rem_wakeup,\n\t\t\t  int reset, int is_host)\n{\n\tif (is_host)\n\t\treturn dwc2_host_exit_hibernation(hsotg, rem_wakeup, reset);\n\telse\n\t\treturn dwc2_gadget_exit_hibernation(hsotg, rem_wakeup, reset);\n}\n\n \nint dwc2_core_reset(struct dwc2_hsotg *hsotg, bool skip_wait)\n{\n\tu32 greset;\n\tbool wait_for_host_mode = false;\n\n\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\tif (dwc2_iddig_filter_enabled(hsotg)) {\n\t\tu32 gotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\tu32 gusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\n\t\tif (!(gotgctl & GOTGCTL_CONID_B) ||\n\t\t    (gusbcfg & GUSBCFG_FORCEHOSTMODE)) {\n\t\t\twait_for_host_mode = true;\n\t\t}\n\t}\n\n\t \n\tgreset = dwc2_readl(hsotg, GRSTCTL);\n\tgreset |= GRSTCTL_CSFTRST;\n\tdwc2_writel(hsotg, greset, GRSTCTL);\n\n\tif ((hsotg->hw_params.snpsid & DWC2_CORE_REV_MASK) <\n\t\t(DWC2_CORE_REV_4_20a & DWC2_CORE_REV_MASK)) {\n\t\tif (dwc2_hsotg_wait_bit_clear(hsotg, GRSTCTL,\n\t\t\t\t\t      GRSTCTL_CSFTRST, 10000)) {\n\t\t\tdev_warn(hsotg->dev, \"%s: HANG! Soft Reset timeout GRSTCTL_CSFTRST\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -EBUSY;\n\t\t}\n\t} else {\n\t\tif (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL,\n\t\t\t\t\t    GRSTCTL_CSFTRST_DONE, 10000)) {\n\t\t\tdev_warn(hsotg->dev, \"%s: HANG! Soft Reset timeout GRSTCTL_CSFTRST_DONE\\n\",\n\t\t\t\t __func__);\n\t\t\treturn -EBUSY;\n\t\t}\n\t\tgreset = dwc2_readl(hsotg, GRSTCTL);\n\t\tgreset &= ~GRSTCTL_CSFTRST;\n\t\tgreset |= GRSTCTL_CSFTRST_DONE;\n\t\tdwc2_writel(hsotg, greset, GRSTCTL);\n\t}\n\n\t \n\tdwc2_clear_fifo_map(hsotg);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL, GRSTCTL_AHBIDLE, 10000)) {\n\t\tdev_warn(hsotg->dev, \"%s: HANG! AHB Idle timeout GRSTCTL GRSTCTL_AHBIDLE\\n\",\n\t\t\t __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tif (wait_for_host_mode && !skip_wait)\n\t\tdwc2_wait_for_mode(hsotg, true);\n\n\treturn 0;\n}\n\n \nvoid dwc2_force_mode(struct dwc2_hsotg *hsotg, bool host)\n{\n\tu32 gusbcfg;\n\tu32 set;\n\tu32 clear;\n\n\tdev_dbg(hsotg->dev, \"Forcing mode to %s\\n\", host ? \"host\" : \"device\");\n\n\t \n\tif (!dwc2_hw_is_otg(hsotg))\n\t\treturn;\n\n\t \n\tif (WARN_ON(host && hsotg->dr_mode == USB_DR_MODE_PERIPHERAL))\n\t\treturn;\n\n\tif (WARN_ON(!host && hsotg->dr_mode == USB_DR_MODE_HOST))\n\t\treturn;\n\n\tgusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\n\tset = host ? GUSBCFG_FORCEHOSTMODE : GUSBCFG_FORCEDEVMODE;\n\tclear = host ? GUSBCFG_FORCEDEVMODE : GUSBCFG_FORCEHOSTMODE;\n\n\tgusbcfg &= ~clear;\n\tgusbcfg |= set;\n\tdwc2_writel(hsotg, gusbcfg, GUSBCFG);\n\n\tdwc2_wait_for_mode(hsotg, host);\n\treturn;\n}\n\n \nstatic void dwc2_clear_force_mode(struct dwc2_hsotg *hsotg)\n{\n\tu32 gusbcfg;\n\n\tif (!dwc2_hw_is_otg(hsotg))\n\t\treturn;\n\n\tdev_dbg(hsotg->dev, \"Clearing force mode bits\\n\");\n\n\tgusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tgusbcfg &= ~GUSBCFG_FORCEHOSTMODE;\n\tgusbcfg &= ~GUSBCFG_FORCEDEVMODE;\n\tdwc2_writel(hsotg, gusbcfg, GUSBCFG);\n\n\tif (dwc2_iddig_filter_enabled(hsotg))\n\t\tmsleep(100);\n}\n\n \nvoid dwc2_force_dr_mode(struct dwc2_hsotg *hsotg)\n{\n\tswitch (hsotg->dr_mode) {\n\tcase USB_DR_MODE_HOST:\n\t\t \n\t\tif (!dwc2_hw_is_otg(hsotg))\n\t\t\tmsleep(50);\n\n\t\tbreak;\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tdwc2_force_mode(hsotg, false);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tdwc2_clear_force_mode(hsotg);\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(hsotg->dev, \"%s() Invalid dr_mode=%d\\n\",\n\t\t\t __func__, hsotg->dr_mode);\n\t\tbreak;\n\t}\n}\n\n \nvoid dwc2_enable_acg(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->params.acg_enable) {\n\t\tu32 pcgcctl1 = dwc2_readl(hsotg, PCGCCTL1);\n\n\t\tdev_dbg(hsotg->dev, \"Enabling Active Clock Gating\\n\");\n\t\tpcgcctl1 |= PCGCCTL1_GATEEN;\n\t\tdwc2_writel(hsotg, pcgcctl1, PCGCCTL1);\n\t}\n}\n\n \nvoid dwc2_dump_host_registers(struct dwc2_hsotg *hsotg)\n{\n#ifdef DEBUG\n\tu32 __iomem *addr;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"Host Global Registers\\n\");\n\taddr = hsotg->regs + HCFG;\n\tdev_dbg(hsotg->dev, \"HCFG\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HCFG));\n\taddr = hsotg->regs + HFIR;\n\tdev_dbg(hsotg->dev, \"HFIR\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HFIR));\n\taddr = hsotg->regs + HFNUM;\n\tdev_dbg(hsotg->dev, \"HFNUM\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HFNUM));\n\taddr = hsotg->regs + HPTXSTS;\n\tdev_dbg(hsotg->dev, \"HPTXSTS\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HPTXSTS));\n\taddr = hsotg->regs + HAINT;\n\tdev_dbg(hsotg->dev, \"HAINT\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HAINT));\n\taddr = hsotg->regs + HAINTMSK;\n\tdev_dbg(hsotg->dev, \"HAINTMSK\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HAINTMSK));\n\tif (hsotg->params.dma_desc_enable) {\n\t\taddr = hsotg->regs + HFLBADDR;\n\t\tdev_dbg(hsotg->dev, \"HFLBADDR @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HFLBADDR));\n\t}\n\n\taddr = hsotg->regs + HPRT0;\n\tdev_dbg(hsotg->dev, \"HPRT0\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HPRT0));\n\n\tfor (i = 0; i < hsotg->params.host_channels; i++) {\n\t\tdev_dbg(hsotg->dev, \"Host Channel %d Specific Registers\\n\", i);\n\t\taddr = hsotg->regs + HCCHAR(i);\n\t\tdev_dbg(hsotg->dev, \"HCCHAR\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCCHAR(i)));\n\t\taddr = hsotg->regs + HCSPLT(i);\n\t\tdev_dbg(hsotg->dev, \"HCSPLT\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCSPLT(i)));\n\t\taddr = hsotg->regs + HCINT(i);\n\t\tdev_dbg(hsotg->dev, \"HCINT\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCINT(i)));\n\t\taddr = hsotg->regs + HCINTMSK(i);\n\t\tdev_dbg(hsotg->dev, \"HCINTMSK\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCINTMSK(i)));\n\t\taddr = hsotg->regs + HCTSIZ(i);\n\t\tdev_dbg(hsotg->dev, \"HCTSIZ\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCTSIZ(i)));\n\t\taddr = hsotg->regs + HCDMA(i);\n\t\tdev_dbg(hsotg->dev, \"HCDMA\t @0x%08lX : 0x%08X\\n\",\n\t\t\t(unsigned long)addr, dwc2_readl(hsotg, HCDMA(i)));\n\t\tif (hsotg->params.dma_desc_enable) {\n\t\t\taddr = hsotg->regs + HCDMAB(i);\n\t\t\tdev_dbg(hsotg->dev, \"HCDMAB\t @0x%08lX : 0x%08X\\n\",\n\t\t\t\t(unsigned long)addr, dwc2_readl(hsotg,\n\t\t\t\t\t\t\t\tHCDMAB(i)));\n\t\t}\n\t}\n#endif\n}\n\n \nvoid dwc2_dump_global_registers(struct dwc2_hsotg *hsotg)\n{\n#ifdef DEBUG\n\tu32 __iomem *addr;\n\n\tdev_dbg(hsotg->dev, \"Core Global Registers\\n\");\n\taddr = hsotg->regs + GOTGCTL;\n\tdev_dbg(hsotg->dev, \"GOTGCTL\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GOTGCTL));\n\taddr = hsotg->regs + GOTGINT;\n\tdev_dbg(hsotg->dev, \"GOTGINT\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GOTGINT));\n\taddr = hsotg->regs + GAHBCFG;\n\tdev_dbg(hsotg->dev, \"GAHBCFG\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GAHBCFG));\n\taddr = hsotg->regs + GUSBCFG;\n\tdev_dbg(hsotg->dev, \"GUSBCFG\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GUSBCFG));\n\taddr = hsotg->regs + GRSTCTL;\n\tdev_dbg(hsotg->dev, \"GRSTCTL\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GRSTCTL));\n\taddr = hsotg->regs + GINTSTS;\n\tdev_dbg(hsotg->dev, \"GINTSTS\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GINTSTS));\n\taddr = hsotg->regs + GINTMSK;\n\tdev_dbg(hsotg->dev, \"GINTMSK\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GINTMSK));\n\taddr = hsotg->regs + GRXSTSR;\n\tdev_dbg(hsotg->dev, \"GRXSTSR\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GRXSTSR));\n\taddr = hsotg->regs + GRXFSIZ;\n\tdev_dbg(hsotg->dev, \"GRXFSIZ\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GRXFSIZ));\n\taddr = hsotg->regs + GNPTXFSIZ;\n\tdev_dbg(hsotg->dev, \"GNPTXFSIZ\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GNPTXFSIZ));\n\taddr = hsotg->regs + GNPTXSTS;\n\tdev_dbg(hsotg->dev, \"GNPTXSTS\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GNPTXSTS));\n\taddr = hsotg->regs + GI2CCTL;\n\tdev_dbg(hsotg->dev, \"GI2CCTL\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GI2CCTL));\n\taddr = hsotg->regs + GPVNDCTL;\n\tdev_dbg(hsotg->dev, \"GPVNDCTL\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GPVNDCTL));\n\taddr = hsotg->regs + GGPIO;\n\tdev_dbg(hsotg->dev, \"GGPIO\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GGPIO));\n\taddr = hsotg->regs + GUID;\n\tdev_dbg(hsotg->dev, \"GUID\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GUID));\n\taddr = hsotg->regs + GSNPSID;\n\tdev_dbg(hsotg->dev, \"GSNPSID\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GSNPSID));\n\taddr = hsotg->regs + GHWCFG1;\n\tdev_dbg(hsotg->dev, \"GHWCFG1\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GHWCFG1));\n\taddr = hsotg->regs + GHWCFG2;\n\tdev_dbg(hsotg->dev, \"GHWCFG2\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GHWCFG2));\n\taddr = hsotg->regs + GHWCFG3;\n\tdev_dbg(hsotg->dev, \"GHWCFG3\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GHWCFG3));\n\taddr = hsotg->regs + GHWCFG4;\n\tdev_dbg(hsotg->dev, \"GHWCFG4\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GHWCFG4));\n\taddr = hsotg->regs + GLPMCFG;\n\tdev_dbg(hsotg->dev, \"GLPMCFG\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GLPMCFG));\n\taddr = hsotg->regs + GPWRDN;\n\tdev_dbg(hsotg->dev, \"GPWRDN\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GPWRDN));\n\taddr = hsotg->regs + GDFIFOCFG;\n\tdev_dbg(hsotg->dev, \"GDFIFOCFG\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, GDFIFOCFG));\n\taddr = hsotg->regs + HPTXFSIZ;\n\tdev_dbg(hsotg->dev, \"HPTXFSIZ\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, HPTXFSIZ));\n\n\taddr = hsotg->regs + PCGCTL;\n\tdev_dbg(hsotg->dev, \"PCGCTL\t @0x%08lX : 0x%08X\\n\",\n\t\t(unsigned long)addr, dwc2_readl(hsotg, PCGCTL));\n#endif\n}\n\n \nvoid dwc2_flush_tx_fifo(struct dwc2_hsotg *hsotg, const int num)\n{\n\tu32 greset;\n\n\tdev_vdbg(hsotg->dev, \"Flush Tx FIFO %d\\n\", num);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL, GRSTCTL_AHBIDLE, 10000))\n\t\tdev_warn(hsotg->dev, \"%s:  HANG! AHB Idle GRSCTL\\n\",\n\t\t\t __func__);\n\n\tgreset = GRSTCTL_TXFFLSH;\n\tgreset |= num << GRSTCTL_TXFNUM_SHIFT & GRSTCTL_TXFNUM_MASK;\n\tdwc2_writel(hsotg, greset, GRSTCTL);\n\n\tif (dwc2_hsotg_wait_bit_clear(hsotg, GRSTCTL, GRSTCTL_TXFFLSH, 10000))\n\t\tdev_warn(hsotg->dev, \"%s:  HANG! timeout GRSTCTL GRSTCTL_TXFFLSH\\n\",\n\t\t\t __func__);\n\n\t \n\tudelay(1);\n}\n\n \nvoid dwc2_flush_rx_fifo(struct dwc2_hsotg *hsotg)\n{\n\tu32 greset;\n\n\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, GRSTCTL, GRSTCTL_AHBIDLE, 10000))\n\t\tdev_warn(hsotg->dev, \"%s:  HANG! AHB Idle GRSCTL\\n\",\n\t\t\t __func__);\n\n\tgreset = GRSTCTL_RXFFLSH;\n\tdwc2_writel(hsotg, greset, GRSTCTL);\n\n\t \n\tif (dwc2_hsotg_wait_bit_clear(hsotg, GRSTCTL, GRSTCTL_RXFFLSH, 10000))\n\t\tdev_warn(hsotg->dev, \"%s: HANG! timeout GRSTCTL GRSTCTL_RXFFLSH\\n\",\n\t\t\t __func__);\n\n\t \n\tudelay(1);\n}\n\nbool dwc2_is_controller_alive(struct dwc2_hsotg *hsotg)\n{\n\tif (dwc2_readl(hsotg, GSNPSID) == 0xffffffff)\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\n \nvoid dwc2_enable_global_interrupts(struct dwc2_hsotg *hsotg)\n{\n\tu32 ahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\n\tahbcfg |= GAHBCFG_GLBL_INTR_EN;\n\tdwc2_writel(hsotg, ahbcfg, GAHBCFG);\n}\n\n \nvoid dwc2_disable_global_interrupts(struct dwc2_hsotg *hsotg)\n{\n\tu32 ahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\n\tahbcfg &= ~GAHBCFG_GLBL_INTR_EN;\n\tdwc2_writel(hsotg, ahbcfg, GAHBCFG);\n}\n\n \nunsigned int dwc2_op_mode(struct dwc2_hsotg *hsotg)\n{\n\tu32 ghwcfg2 = dwc2_readl(hsotg, GHWCFG2);\n\n\treturn (ghwcfg2 & GHWCFG2_OP_MODE_MASK) >>\n\t\tGHWCFG2_OP_MODE_SHIFT;\n}\n\n \nbool dwc2_hw_is_otg(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int op_mode = dwc2_op_mode(hsotg);\n\n\treturn (op_mode == GHWCFG2_OP_MODE_HNP_SRP_CAPABLE) ||\n\t\t(op_mode == GHWCFG2_OP_MODE_SRP_ONLY_CAPABLE) ||\n\t\t(op_mode == GHWCFG2_OP_MODE_NO_HNP_SRP_CAPABLE);\n}\n\n \nbool dwc2_hw_is_host(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int op_mode = dwc2_op_mode(hsotg);\n\n\treturn (op_mode == GHWCFG2_OP_MODE_SRP_CAPABLE_HOST) ||\n\t\t(op_mode == GHWCFG2_OP_MODE_NO_SRP_CAPABLE_HOST);\n}\n\n \nbool dwc2_hw_is_device(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int op_mode = dwc2_op_mode(hsotg);\n\n\treturn (op_mode == GHWCFG2_OP_MODE_SRP_CAPABLE_DEVICE) ||\n\t\t(op_mode == GHWCFG2_OP_MODE_NO_SRP_CAPABLE_DEVICE);\n}\n\n \nint dwc2_hsotg_wait_bit_set(struct dwc2_hsotg *hsotg, u32 offset, u32 mask,\n\t\t\t    u32 timeout)\n{\n\tu32 i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tif (dwc2_readl(hsotg, offset) & mask)\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nint dwc2_hsotg_wait_bit_clear(struct dwc2_hsotg *hsotg, u32 offset, u32 mask,\n\t\t\t      u32 timeout)\n{\n\tu32 i;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tif (!(dwc2_readl(hsotg, offset) & mask))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\n \nvoid dwc2_init_fs_ls_pclk_sel(struct dwc2_hsotg *hsotg)\n{\n\tu32 hcfg, val;\n\n\tif ((hsotg->hw_params.hs_phy_type == GHWCFG2_HS_PHY_TYPE_ULPI &&\n\t     hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED &&\n\t     hsotg->params.ulpi_fs_ls) ||\n\t    hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS) {\n\t\t \n\t\tval = HCFG_FSLSPCLKSEL_48_MHZ;\n\t} else {\n\t\t \n\t\tval = HCFG_FSLSPCLKSEL_30_60_MHZ;\n\t}\n\n\tdev_dbg(hsotg->dev, \"Initializing HCFG.FSLSPClkSel to %08x\\n\", val);\n\thcfg = dwc2_readl(hsotg, HCFG);\n\thcfg &= ~HCFG_FSLSPCLKSEL_MASK;\n\thcfg |= val << HCFG_FSLSPCLKSEL_SHIFT;\n\tdwc2_writel(hsotg, hcfg, HCFG);\n}\n\nstatic int dwc2_fs_phy_init(struct dwc2_hsotg *hsotg, bool select_phy)\n{\n\tu32 usbcfg, ggpio, i2cctl;\n\tint retval = 0;\n\n\t \n\tif (select_phy) {\n\t\tdev_dbg(hsotg->dev, \"FS PHY selected\\n\");\n\n\t\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\t\tif (!(usbcfg & GUSBCFG_PHYSEL)) {\n\t\t\tusbcfg |= GUSBCFG_PHYSEL;\n\t\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\t\t\t \n\t\t\tretval = dwc2_core_reset(hsotg, false);\n\n\t\t\tif (retval) {\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"%s: Reset failed, aborting\", __func__);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t}\n\n\t\tif (hsotg->params.activate_stm_fs_transceiver) {\n\t\t\tggpio = dwc2_readl(hsotg, GGPIO);\n\t\t\tif (!(ggpio & GGPIO_STM32_OTG_GCCFG_PWRDWN)) {\n\t\t\t\tdev_dbg(hsotg->dev, \"Activating transceiver\\n\");\n\t\t\t\t \n\t\t\t\tggpio |= GGPIO_STM32_OTG_GCCFG_PWRDWN;\n\t\t\t\tdwc2_writel(hsotg, ggpio, GGPIO);\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (dwc2_is_host_mode(hsotg))\n\t\tdwc2_init_fs_ls_pclk_sel(hsotg);\n\n\tif (hsotg->params.i2c_enable) {\n\t\tdev_dbg(hsotg->dev, \"FS PHY enabling I2C\\n\");\n\n\t\t \n\t\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\t\tusbcfg |= GUSBCFG_OTG_UTMI_FS_SEL;\n\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\t\t \n\t\ti2cctl = dwc2_readl(hsotg, GI2CCTL);\n\t\ti2cctl &= ~GI2CCTL_I2CDEVADDR_MASK;\n\t\ti2cctl |= 1 << GI2CCTL_I2CDEVADDR_SHIFT;\n\t\ti2cctl &= ~GI2CCTL_I2CEN;\n\t\tdwc2_writel(hsotg, i2cctl, GI2CCTL);\n\t\ti2cctl |= GI2CCTL_I2CEN;\n\t\tdwc2_writel(hsotg, i2cctl, GI2CCTL);\n\t}\n\n\treturn retval;\n}\n\nstatic int dwc2_hs_phy_init(struct dwc2_hsotg *hsotg, bool select_phy)\n{\n\tu32 usbcfg, usbcfg_old;\n\tint retval = 0;\n\n\tif (!select_phy)\n\t\treturn 0;\n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tusbcfg_old = usbcfg;\n\n\t \n\tswitch (hsotg->params.phy_type) {\n\tcase DWC2_PHY_TYPE_PARAM_ULPI:\n\t\t \n\t\tdev_dbg(hsotg->dev, \"HS ULPI PHY selected\\n\");\n\t\tusbcfg |= GUSBCFG_ULPI_UTMI_SEL;\n\t\tusbcfg &= ~(GUSBCFG_PHYIF16 | GUSBCFG_DDRSEL);\n\t\tif (hsotg->params.phy_ulpi_ddr)\n\t\t\tusbcfg |= GUSBCFG_DDRSEL;\n\n\t\t \n\t\tif (hsotg->params.oc_disable)\n\t\t\tusbcfg |= (GUSBCFG_ULPI_INT_VBUS_IND |\n\t\t\t\t   GUSBCFG_INDICATORPASSTHROUGH);\n\t\tbreak;\n\tcase DWC2_PHY_TYPE_PARAM_UTMI:\n\t\t \n\t\tdev_dbg(hsotg->dev, \"HS UTMI+ PHY selected\\n\");\n\t\tusbcfg &= ~(GUSBCFG_ULPI_UTMI_SEL | GUSBCFG_PHYIF16);\n\t\tif (hsotg->params.phy_utmi_width == 16)\n\t\t\tusbcfg |= GUSBCFG_PHYIF16;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev, \"FS PHY selected at HS!\\n\");\n\t\tbreak;\n\t}\n\n\tif (usbcfg != usbcfg_old) {\n\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\t\t \n\t\tretval = dwc2_core_reset(hsotg, false);\n\t\tif (retval) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: Reset failed, aborting\", __func__);\n\t\t\treturn retval;\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nstatic void dwc2_set_turnaround_time(struct dwc2_hsotg *hsotg)\n{\n\tu32 usbcfg;\n\n\tif (hsotg->params.phy_type != DWC2_PHY_TYPE_PARAM_UTMI)\n\t\treturn;\n\n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\n\tusbcfg &= ~GUSBCFG_USBTRDTIM_MASK;\n\tif (hsotg->params.phy_utmi_width == 16)\n\t\tusbcfg |= 5 << GUSBCFG_USBTRDTIM_SHIFT;\n\telse\n\t\tusbcfg |= 9 << GUSBCFG_USBTRDTIM_SHIFT;\n\n\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n}\n\nint dwc2_phy_init(struct dwc2_hsotg *hsotg, bool select_phy)\n{\n\tu32 usbcfg;\n\tu32 otgctl;\n\tint retval = 0;\n\n\tif ((hsotg->params.speed == DWC2_SPEED_PARAM_FULL ||\n\t     hsotg->params.speed == DWC2_SPEED_PARAM_LOW) &&\n\t    hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS) {\n\t\t \n\t\tretval = dwc2_fs_phy_init(hsotg, select_phy);\n\t\tif (retval)\n\t\t\treturn retval;\n\t} else {\n\t\t \n\t\tretval = dwc2_hs_phy_init(hsotg, select_phy);\n\t\tif (retval)\n\t\t\treturn retval;\n\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\tdwc2_set_turnaround_time(hsotg);\n\t}\n\n\tif (hsotg->hw_params.hs_phy_type == GHWCFG2_HS_PHY_TYPE_ULPI &&\n\t    hsotg->hw_params.fs_phy_type == GHWCFG2_FS_PHY_TYPE_DEDICATED &&\n\t    hsotg->params.ulpi_fs_ls) {\n\t\tdev_dbg(hsotg->dev, \"Setting ULPI FSLS\\n\");\n\t\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\t\tusbcfg |= GUSBCFG_ULPI_FS_LS;\n\t\tusbcfg |= GUSBCFG_ULPI_CLK_SUSP_M;\n\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\t} else {\n\t\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\t\tusbcfg &= ~GUSBCFG_ULPI_FS_LS;\n\t\tusbcfg &= ~GUSBCFG_ULPI_CLK_SUSP_M;\n\t\tdwc2_writel(hsotg, usbcfg, GUSBCFG);\n\t}\n\n\tif (!hsotg->params.activate_ingenic_overcurrent_detection) {\n\t\tif (dwc2_is_host_mode(hsotg)) {\n\t\t\totgctl = readl(hsotg->regs + GOTGCTL);\n\t\t\totgctl |= GOTGCTL_VBVALOEN | GOTGCTL_VBVALOVAL;\n\t\t\twritel(otgctl, hsotg->regs + GOTGCTL);\n\t\t}\n\t}\n\n\treturn retval;\n}\n\nMODULE_DESCRIPTION(\"DESIGNWARE HS OTG Core\");\nMODULE_AUTHOR(\"Synopsys, Inc.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}