{
  "module_name": "hcd_queue.c",
  "hash_id": "c4bb7e8ab6aa3b4b9d8e5624448c0969061639127ff4c0bd3aa41de71561b118",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/hcd_queue.c",
  "human_readable_source": "\n \n\n \n#include <linux/gcd.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\n \n#define DWC2_UNRESERVE_DELAY (msecs_to_jiffies(5))\n\n \n#define DWC2_RETRY_WAIT_DELAY (1 * NSEC_PER_MSEC)\n\n \nstatic int dwc2_periodic_channel_available(struct dwc2_hsotg *hsotg)\n{\n\t \n\tint status;\n\tint num_channels;\n\n\tnum_channels = hsotg->params.host_channels;\n\tif ((hsotg->periodic_channels + hsotg->non_periodic_channels <\n\t     num_channels) && (hsotg->periodic_channels < num_channels - 1)) {\n\t\tstatus = 0;\n\t} else {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: Total channels: %d, Periodic: %d, Non-periodic: %d\\n\",\n\t\t\t__func__, num_channels,\n\t\t\thsotg->periodic_channels, hsotg->non_periodic_channels);\n\t\tstatus = -ENOSPC;\n\t}\n\n\treturn status;\n}\n\n \nstatic int dwc2_check_periodic_bandwidth(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t struct dwc2_qh *qh)\n{\n\tint status;\n\ts16 max_claimed_usecs;\n\n\tstatus = 0;\n\n\tif (qh->dev_speed == USB_SPEED_HIGH || qh->do_split) {\n\t\t \n\t\tmax_claimed_usecs = 100 - qh->host_us;\n\t} else {\n\t\t \n\t\tmax_claimed_usecs = 900 - qh->host_us;\n\t}\n\n\tif (hsotg->periodic_usecs > max_claimed_usecs) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: already claimed usecs %d, required usecs %d\\n\",\n\t\t\t__func__, hsotg->periodic_usecs, qh->host_us);\n\t\tstatus = -ENOSPC;\n\t}\n\n\treturn status;\n}\n\n \nstatic int pmap_schedule(unsigned long *map, int bits_per_period,\n\t\t\t int periods_in_map, int num_bits,\n\t\t\t int interval, int start, bool only_one_period)\n{\n\tint interval_bits;\n\tint to_reserve;\n\tint first_end;\n\tint i;\n\n\tif (num_bits > bits_per_period)\n\t\treturn -ENOSPC;\n\n\t \n\tinterval = gcd(interval, periods_in_map);\n\n\tinterval_bits = bits_per_period * interval;\n\tto_reserve = periods_in_map / interval;\n\n\t \n\tif (start >= interval_bits)\n\t\treturn -ENOSPC;\n\n\tif (only_one_period)\n\t\t \n\t\tfirst_end = (start / bits_per_period + 1) * bits_per_period;\n\telse\n\t\t \n\t\tfirst_end = interval_bits;\n\n\t \n\twhile (start + num_bits <= first_end) {\n\t\tint end;\n\n\t\t \n\t\tend = (start / bits_per_period + 1) * bits_per_period;\n\n\t\t \n\t\tstart = bitmap_find_next_zero_area(map, end, start, num_bits,\n\t\t\t\t\t\t   0);\n\n\t\t \n\t\tif (start >= end) {\n\t\t\tstart = end;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tfor (i = 1; i < to_reserve; i++) {\n\t\t\tint ith_start = start + interval_bits * i;\n\t\t\tint ith_end = end + interval_bits * i;\n\t\t\tint ret;\n\n\t\t\t \n\t\t\tret = bitmap_find_next_zero_area(\n\t\t\t\tmap, ith_start + num_bits, ith_start, num_bits,\n\t\t\t\t0);\n\n\t\t\t \n\t\t\tif (ret == ith_start)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tith_start = bitmap_find_next_zero_area(\n\t\t\t\tmap, ith_end, ith_start, num_bits, 0);\n\t\t\tif (ith_start >= ith_end)\n\t\t\t\t \n\t\t\t\tstart = end;\n\t\t\telse\n\t\t\t\tstart = ith_start - interval_bits * i;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == to_reserve)\n\t\t\tbreak;\n\t}\n\n\tif (start + num_bits > first_end)\n\t\treturn -ENOSPC;\n\n\tfor (i = 0; i < to_reserve; i++) {\n\t\tint ith_start = start + interval_bits * i;\n\n\t\tbitmap_set(map, ith_start, num_bits);\n\t}\n\n\treturn start;\n}\n\n \nstatic void pmap_unschedule(unsigned long *map, int bits_per_period,\n\t\t\t    int periods_in_map, int num_bits,\n\t\t\t    int interval, int start)\n{\n\tint interval_bits;\n\tint to_release;\n\tint i;\n\n\t \n\tinterval = gcd(interval, periods_in_map);\n\n\tinterval_bits = bits_per_period * interval;\n\tto_release = periods_in_map / interval;\n\n\tfor (i = 0; i < to_release; i++) {\n\t\tint ith_start = start + interval_bits * i;\n\n\t\tbitmap_clear(map, ith_start, num_bits);\n\t}\n}\n\n \nstatic unsigned long *dwc2_get_ls_map(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_qh *qh)\n{\n\tunsigned long *map;\n\n\t \n\tif (WARN_ON(!qh->dwc_tt))\n\t\treturn NULL;\n\n\t \n\tmap = qh->dwc_tt->periodic_bitmaps;\n\tif (qh->dwc_tt->usb_tt->multi)\n\t\tmap += DWC2_ELEMENTS_PER_LS_BITMAP * (qh->ttport - 1);\n\n\treturn map;\n}\n\n#ifdef DWC2_PRINT_SCHEDULE\n \nstatic __printf(3, 4)\nvoid cat_printf(char **buf, size_t *size, const char *fmt, ...)\n{\n\tva_list args;\n\tint i;\n\n\tif (*size == 0)\n\t\treturn;\n\n\tva_start(args, fmt);\n\ti = vsnprintf(*buf, *size, fmt, args);\n\tva_end(args);\n\n\tif (i >= *size) {\n\t\t(*buf)[*size - 1] = '\\0';\n\t\t*buf += *size;\n\t\t*size = 0;\n\t} else {\n\t\t*buf += i;\n\t\t*size -= i;\n\t}\n}\n\n \nstatic void pmap_print(unsigned long *map, int bits_per_period,\n\t\t       int periods_in_map, const char *period_name,\n\t\t       const char *units,\n\t\t       void (*print_fn)(const char *str, void *data),\n\t\t       void *print_data)\n{\n\tint period;\n\n\tfor (period = 0; period < periods_in_map; period++) {\n\t\tchar tmp[64];\n\t\tchar *buf = tmp;\n\t\tsize_t buf_size = sizeof(tmp);\n\t\tint period_start = period * bits_per_period;\n\t\tint period_end = period_start + bits_per_period;\n\t\tint start = 0;\n\t\tint count = 0;\n\t\tbool printed = false;\n\t\tint i;\n\n\t\tfor (i = period_start; i < period_end + 1; i++) {\n\t\t\t \n\t\t\tif (i < period_end &&\n\t\t\t    bitmap_find_next_zero_area(map, i + 1,\n\t\t\t\t\t\t       i, 1, 0) != i) {\n\t\t\t\tif (count == 0)\n\t\t\t\t\tstart = i - period_start;\n\t\t\t\tcount++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (count == 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (!printed)\n\t\t\t\tcat_printf(&buf, &buf_size, \"%s %d: \",\n\t\t\t\t\t   period_name, period);\n\t\t\telse\n\t\t\t\tcat_printf(&buf, &buf_size, \", \");\n\t\t\tprinted = true;\n\n\t\t\tcat_printf(&buf, &buf_size, \"%d %s -%3d %s\", start,\n\t\t\t\t   units, start + count - 1, units);\n\t\t\tcount = 0;\n\t\t}\n\n\t\tif (printed)\n\t\t\tprint_fn(tmp, print_data);\n\t}\n}\n\nstruct dwc2_qh_print_data {\n\tstruct dwc2_hsotg *hsotg;\n\tstruct dwc2_qh *qh;\n};\n\n \nstatic void dwc2_qh_print(const char *str, void *data)\n{\n\tstruct dwc2_qh_print_data *print_data = data;\n\n\tdwc2_sch_dbg(print_data->hsotg, \"QH=%p ...%s\\n\", print_data->qh, str);\n}\n\n \nstatic void dwc2_qh_schedule_print(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_qh *qh)\n{\n\tstruct dwc2_qh_print_data print_data = { hsotg, qh };\n\tint i;\n\n\t \n\n\tif (qh->schedule_low_speed) {\n\t\tunsigned long *map = dwc2_get_ls_map(hsotg, qh);\n\n\t\tdwc2_sch_dbg(hsotg, \"QH=%p LS/FS trans: %d=>%d us @ %d us\",\n\t\t\t     qh, qh->device_us,\n\t\t\t     DWC2_ROUND_US_TO_SLICE(qh->device_us),\n\t\t\t     DWC2_US_PER_SLICE * qh->ls_start_schedule_slice);\n\n\t\tif (map) {\n\t\t\tdwc2_sch_dbg(hsotg,\n\t\t\t\t     \"QH=%p Whole low/full speed map %p now:\\n\",\n\t\t\t\t     qh, map);\n\t\t\tpmap_print(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\n\t\t\t\t   DWC2_LS_SCHEDULE_FRAMES, \"Frame \", \"slices\",\n\t\t\t\t   dwc2_qh_print, &print_data);\n\t\t}\n\t}\n\n\tfor (i = 0; i < qh->num_hs_transfers; i++) {\n\t\tstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + i;\n\t\tint uframe = trans_time->start_schedule_us /\n\t\t\t     DWC2_HS_PERIODIC_US_PER_UFRAME;\n\t\tint rel_us = trans_time->start_schedule_us %\n\t\t\t     DWC2_HS_PERIODIC_US_PER_UFRAME;\n\n\t\tdwc2_sch_dbg(hsotg,\n\t\t\t     \"QH=%p HS trans #%d: %d us @ uFrame %d + %d us\\n\",\n\t\t\t     qh, i, trans_time->duration_us, uframe, rel_us);\n\t}\n\tif (qh->num_hs_transfers) {\n\t\tdwc2_sch_dbg(hsotg, \"QH=%p Whole high speed map now:\\n\", qh);\n\t\tpmap_print(hsotg->hs_periodic_bitmap,\n\t\t\t   DWC2_HS_PERIODIC_US_PER_UFRAME,\n\t\t\t   DWC2_HS_SCHEDULE_UFRAMES, \"uFrame\", \"us\",\n\t\t\t   dwc2_qh_print, &print_data);\n\t}\n}\n#else\nstatic inline void dwc2_qh_schedule_print(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t  struct dwc2_qh *qh) {};\n#endif\n\n \nstatic int dwc2_ls_pmap_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t\t int search_slice)\n{\n\tint slices = DIV_ROUND_UP(qh->device_us, DWC2_US_PER_SLICE);\n\tunsigned long *map = dwc2_get_ls_map(hsotg, qh);\n\tint slice;\n\n\tif (!map)\n\t\treturn -EINVAL;\n\n\t \n\tslice = pmap_schedule(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\n\t\t\t      DWC2_LS_SCHEDULE_FRAMES, slices,\n\t\t\t      qh->device_interval, search_slice, false);\n\n\tif (slice < 0)\n\t\treturn slice;\n\n\tqh->ls_start_schedule_slice = slice;\n\treturn 0;\n}\n\n \nstatic void dwc2_ls_pmap_unschedule(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh)\n{\n\tint slices = DIV_ROUND_UP(qh->device_us, DWC2_US_PER_SLICE);\n\tunsigned long *map = dwc2_get_ls_map(hsotg, qh);\n\n\t \n\tif (!map)\n\t\treturn;\n\n\tpmap_unschedule(map, DWC2_LS_PERIODIC_SLICES_PER_FRAME,\n\t\t\tDWC2_LS_SCHEDULE_FRAMES, slices, qh->device_interval,\n\t\t\tqh->ls_start_schedule_slice);\n}\n\n \nstatic int dwc2_hs_pmap_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t\t bool only_one_period, int index)\n{\n\tstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + index;\n\tint us;\n\n\tus = pmap_schedule(hsotg->hs_periodic_bitmap,\n\t\t\t   DWC2_HS_PERIODIC_US_PER_UFRAME,\n\t\t\t   DWC2_HS_SCHEDULE_UFRAMES, trans_time->duration_us,\n\t\t\t   qh->host_interval, trans_time->start_schedule_us,\n\t\t\t   only_one_period);\n\n\tif (us < 0)\n\t\treturn us;\n\n\ttrans_time->start_schedule_us = us;\n\treturn 0;\n}\n\n \nstatic void dwc2_hs_pmap_unschedule(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh, int index)\n{\n\tstruct dwc2_hs_transfer_time *trans_time = qh->hs_transfers + index;\n\n\tpmap_unschedule(hsotg->hs_periodic_bitmap,\n\t\t\tDWC2_HS_PERIODIC_US_PER_UFRAME,\n\t\t\tDWC2_HS_SCHEDULE_UFRAMES, trans_time->duration_us,\n\t\t\tqh->host_interval, trans_time->start_schedule_us);\n}\n\n \nstatic int dwc2_uframe_schedule_split(struct dwc2_hsotg *hsotg,\n\t\t\t\t      struct dwc2_qh *qh)\n{\n\tint bytecount = qh->maxp_mult * qh->maxp;\n\tint ls_search_slice;\n\tint err = 0;\n\tint host_interval_in_sched;\n\n\t \n\thost_interval_in_sched = gcd(qh->host_interval,\n\t\t\t\t     DWC2_HS_SCHEDULE_UFRAMES);\n\n\t \n\tls_search_slice = 0;\n\n\twhile (ls_search_slice < DWC2_LS_SCHEDULE_SLICES) {\n\t\tint start_s_uframe;\n\t\tint ssplit_s_uframe;\n\t\tint second_s_uframe;\n\t\tint rel_uframe;\n\t\tint first_count;\n\t\tint middle_count;\n\t\tint end_count;\n\t\tint first_data_bytes;\n\t\tint other_data_bytes;\n\t\tint i;\n\n\t\tif (qh->schedule_low_speed) {\n\t\t\terr = dwc2_ls_pmap_schedule(hsotg, qh, ls_search_slice);\n\n\t\t\t \n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t} else {\n\t\t\t \n\t\t\tWARN_ON_ONCE(1);\n\t\t}\n\n\t\t \n\t\tstart_s_uframe = qh->ls_start_schedule_slice /\n\t\t\t\t DWC2_SLICES_PER_UFRAME;\n\n\t\t \n\t\trel_uframe = (start_s_uframe % 8);\n\n\t\t \n\t\tif (rel_uframe == 7) {\n\t\t\tif (qh->schedule_low_speed)\n\t\t\t\tdwc2_ls_pmap_unschedule(hsotg, qh);\n\t\t\tls_search_slice =\n\t\t\t\t(qh->ls_start_schedule_slice /\n\t\t\t\t DWC2_LS_PERIODIC_SLICES_PER_FRAME + 1) *\n\t\t\t\tDWC2_LS_PERIODIC_SLICES_PER_FRAME;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tssplit_s_uframe = (start_s_uframe +\n\t\t\t\t   host_interval_in_sched - 1) %\n\t\t\t\t  host_interval_in_sched;\n\t\tif (qh->ep_type == USB_ENDPOINT_XFER_ISOC && !qh->ep_is_in)\n\t\t\tsecond_s_uframe = start_s_uframe;\n\t\telse\n\t\t\tsecond_s_uframe = start_s_uframe + 1;\n\n\t\t \n\t\tfirst_data_bytes = 188 -\n\t\t\tDIV_ROUND_UP(188 * (qh->ls_start_schedule_slice %\n\t\t\t\t\t    DWC2_SLICES_PER_UFRAME),\n\t\t\t\t     DWC2_SLICES_PER_UFRAME);\n\t\tif (first_data_bytes > bytecount)\n\t\t\tfirst_data_bytes = bytecount;\n\t\tother_data_bytes = bytecount - first_data_bytes;\n\n\t\t \n\t\tif (!qh->ep_is_in &&\n\t\t    (first_data_bytes != min_t(int, 188, bytecount))) {\n\t\t\tdwc2_sch_dbg(hsotg,\n\t\t\t\t     \"QH=%p avoiding broken 1st xfer (%d, %d)\\n\",\n\t\t\t\t     qh, first_data_bytes, bytecount);\n\t\t\tif (qh->schedule_low_speed)\n\t\t\t\tdwc2_ls_pmap_unschedule(hsotg, qh);\n\t\t\tls_search_slice = (start_s_uframe + 1) *\n\t\t\t\tDWC2_SLICES_PER_UFRAME;\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tqh->num_hs_transfers = 1 + DIV_ROUND_UP(other_data_bytes, 188);\n\n\t\t \n\t\tif (qh->ep_type == USB_ENDPOINT_XFER_INT) {\n\t\t\tif (rel_uframe == 6)\n\t\t\t\tqh->num_hs_transfers += 2;\n\t\t\telse\n\t\t\t\tqh->num_hs_transfers += 3;\n\n\t\t\tif (qh->ep_is_in) {\n\t\t\t\t \n\t\t\t\tfirst_count = 4;\n\t\t\t\tmiddle_count = bytecount;\n\t\t\t\tend_count = bytecount;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfirst_count = first_data_bytes;\n\t\t\t\tmiddle_count = max_t(int, 4, other_data_bytes);\n\t\t\t\tend_count = 4;\n\t\t\t}\n\t\t} else {\n\t\t\tif (qh->ep_is_in) {\n\t\t\t\tint last;\n\n\t\t\t\t \n\t\t\t\tqh->num_hs_transfers++;\n\n\t\t\t\t \n\t\t\t\tlast = rel_uframe + qh->num_hs_transfers + 1;\n\n\t\t\t\t \n\t\t\t\tif (last <= 6)\n\t\t\t\t\tqh->num_hs_transfers += 2;\n\t\t\t\telse\n\t\t\t\t\tqh->num_hs_transfers += 1;\n\n\t\t\t\t \n\t\t\t\tif (last >= 6 && rel_uframe == 0)\n\t\t\t\t\tqh->num_hs_transfers--;\n\n\t\t\t\t \n\t\t\t\tfirst_count = 4;\n\t\t\t\tmiddle_count = min_t(int, 188, bytecount);\n\t\t\t\tend_count = middle_count;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tfirst_count = first_data_bytes;\n\t\t\t\tmiddle_count = min_t(int, 188,\n\t\t\t\t\t\t     other_data_bytes);\n\t\t\t\tend_count = other_data_bytes % 188;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tqh->hs_transfers[0].duration_us = HS_USECS_ISO(first_count);\n\t\tfor (i = 1; i < qh->num_hs_transfers - 1; i++)\n\t\t\tqh->hs_transfers[i].duration_us =\n\t\t\t\tHS_USECS_ISO(middle_count);\n\t\tif (qh->num_hs_transfers > 1)\n\t\t\tqh->hs_transfers[qh->num_hs_transfers - 1].duration_us =\n\t\t\t\tHS_USECS_ISO(end_count);\n\n\t\t \n\t\tqh->hs_transfers[0].start_schedule_us =\n\t\t\tssplit_s_uframe * DWC2_HS_PERIODIC_US_PER_UFRAME;\n\t\tfor (i = 1; i < qh->num_hs_transfers; i++)\n\t\t\tqh->hs_transfers[i].start_schedule_us =\n\t\t\t\t((second_s_uframe + i - 1) %\n\t\t\t\t DWC2_HS_SCHEDULE_UFRAMES) *\n\t\t\t\tDWC2_HS_PERIODIC_US_PER_UFRAME;\n\n\t\t \n\t\tfor (i = 0; i < qh->num_hs_transfers; i++) {\n\t\t\terr = dwc2_hs_pmap_schedule(hsotg, qh, true, i);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (i == qh->num_hs_transfers)\n\t\t\tbreak;\n\n\t\tfor (; i >= 0; i--)\n\t\t\tdwc2_hs_pmap_unschedule(hsotg, qh, i);\n\n\t\tif (qh->schedule_low_speed)\n\t\t\tdwc2_ls_pmap_unschedule(hsotg, qh);\n\n\t\t \n\t\tls_search_slice = (start_s_uframe + 1) * DWC2_SLICES_PER_UFRAME;\n\t}\n\n\tif (ls_search_slice >= DWC2_LS_SCHEDULE_SLICES)\n\t\treturn -ENOSPC;\n\n\treturn 0;\n}\n\n \nstatic int dwc2_uframe_schedule_hs(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\t \n\tWARN_ON(qh->host_us != qh->device_us);\n\tWARN_ON(qh->host_interval != qh->device_interval);\n\tWARN_ON(qh->num_hs_transfers != 1);\n\n\t \n\tqh->hs_transfers[0].start_schedule_us = 0;\n\tqh->hs_transfers[0].duration_us = qh->host_us;\n\n\treturn dwc2_hs_pmap_schedule(hsotg, qh, false, 0);\n}\n\n \nstatic int dwc2_uframe_schedule_ls(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\t \n\tWARN_ON(qh->host_us != qh->device_us);\n\tWARN_ON(qh->host_interval != qh->device_interval);\n\tWARN_ON(!qh->schedule_low_speed);\n\n\t \n\treturn dwc2_ls_pmap_schedule(hsotg, qh, 0);\n}\n\n \nstatic int dwc2_uframe_schedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tint ret;\n\n\tif (qh->dev_speed == USB_SPEED_HIGH)\n\t\tret = dwc2_uframe_schedule_hs(hsotg, qh);\n\telse if (!qh->do_split)\n\t\tret = dwc2_uframe_schedule_ls(hsotg, qh);\n\telse\n\t\tret = dwc2_uframe_schedule_split(hsotg, qh);\n\n\tif (ret)\n\t\tdwc2_sch_dbg(hsotg, \"QH=%p Failed to schedule %d\\n\", qh, ret);\n\telse\n\t\tdwc2_qh_schedule_print(hsotg, qh);\n\n\treturn ret;\n}\n\n \nstatic void dwc2_uframe_unschedule(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tint i;\n\n\tfor (i = 0; i < qh->num_hs_transfers; i++)\n\t\tdwc2_hs_pmap_unschedule(hsotg, qh, i);\n\n\tif (qh->schedule_low_speed)\n\t\tdwc2_ls_pmap_unschedule(hsotg, qh);\n\n\tdwc2_sch_dbg(hsotg, \"QH=%p Unscheduled\\n\", qh);\n}\n\n \nstatic void dwc2_pick_first_frame(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tu16 frame_number;\n\tu16 earliest_frame;\n\tu16 next_active_frame;\n\tu16 relative_frame;\n\tu16 interval;\n\n\t \n\tframe_number = dwc2_hcd_get_frame_number(hsotg);\n\n\t \n\tearliest_frame = dwc2_frame_num_inc(frame_number, 1);\n\tnext_active_frame = earliest_frame;\n\n\t \n\tif (!hsotg->params.uframe_sched) {\n\t\tif (qh->do_split)\n\t\t\t \n\t\t\tnext_active_frame |= 0x7;\n\t\tgoto exit;\n\t}\n\n\tif (qh->dev_speed == USB_SPEED_HIGH || qh->do_split) {\n\t\t \n\t\tWARN_ON(qh->num_hs_transfers < 1);\n\n\t\trelative_frame = qh->hs_transfers[0].start_schedule_us /\n\t\t\t\t DWC2_HS_PERIODIC_US_PER_UFRAME;\n\n\t\t \n\t\tinterval = gcd(qh->host_interval, DWC2_HS_SCHEDULE_UFRAMES);\n\n\t} else {\n\t\t \n\t\trelative_frame = qh->ls_start_schedule_slice /\n\t\t\t\t DWC2_LS_PERIODIC_SLICES_PER_FRAME;\n\t\tinterval = gcd(qh->host_interval, DWC2_LS_SCHEDULE_FRAMES);\n\t}\n\n\t \n\tWARN_ON(relative_frame >= interval);\n\n\t \n\tnext_active_frame = (next_active_frame / interval) * interval;\n\n\t \n\tnext_active_frame = dwc2_frame_num_inc(next_active_frame,\n\t\t\t\t\t       relative_frame);\n\n\t \n\tnext_active_frame = dwc2_frame_num_dec(next_active_frame, 1);\n\n\t \n\twhile (dwc2_frame_num_gt(earliest_frame, next_active_frame))\n\t\tnext_active_frame = dwc2_frame_num_inc(next_active_frame,\n\t\t\t\t\t\t       interval);\n\nexit:\n\tqh->next_active_frame = next_active_frame;\n\tqh->start_active_frame = next_active_frame;\n\n\tdwc2_sch_vdbg(hsotg, \"QH=%p First fn=%04x nxt=%04x\\n\",\n\t\t      qh, frame_number, qh->next_active_frame);\n}\n\n \nstatic int dwc2_do_reserve(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tint status;\n\n\tif (hsotg->params.uframe_sched) {\n\t\tstatus = dwc2_uframe_schedule(hsotg, qh);\n\t} else {\n\t\tstatus = dwc2_periodic_channel_available(hsotg);\n\t\tif (status) {\n\t\t\tdev_info(hsotg->dev,\n\t\t\t\t \"%s: No host channel available for periodic transfer\\n\",\n\t\t\t\t __func__);\n\t\t\treturn status;\n\t\t}\n\n\t\tstatus = dwc2_check_periodic_bandwidth(hsotg, qh);\n\t}\n\n\tif (status) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: Insufficient periodic bandwidth for periodic transfer\\n\",\n\t\t\t__func__);\n\t\treturn status;\n\t}\n\n\tif (!hsotg->params.uframe_sched)\n\t\t \n\t\thsotg->periodic_channels++;\n\n\t \n\thsotg->periodic_usecs += qh->host_us;\n\n\tdwc2_pick_first_frame(hsotg, qh);\n\n\treturn 0;\n}\n\n \nstatic void dwc2_do_unreserve(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tassert_spin_locked(&hsotg->lock);\n\n\tWARN_ON(!qh->unreserve_pending);\n\n\t \n\tqh->unreserve_pending = false;\n\n\tif (WARN_ON(!list_empty(&qh->qh_list_entry)))\n\t\tlist_del_init(&qh->qh_list_entry);\n\n\t \n\thsotg->periodic_usecs -= qh->host_us;\n\n\tif (hsotg->params.uframe_sched) {\n\t\tdwc2_uframe_unschedule(hsotg, qh);\n\t} else {\n\t\t \n\t\thsotg->periodic_channels--;\n\t}\n}\n\n \nstatic void dwc2_unreserve_timer_fn(struct timer_list *t)\n{\n\tstruct dwc2_qh *qh = from_timer(qh, t, unreserve_timer);\n\tstruct dwc2_hsotg *hsotg = qh->hsotg;\n\tunsigned long flags;\n\n\t \n\twhile (!spin_trylock_irqsave(&hsotg->lock, flags)) {\n\t\tif (timer_pending(&qh->unreserve_timer))\n\t\t\treturn;\n\t}\n\n\t \n\tif (qh->unreserve_pending)\n\t\tdwc2_do_unreserve(hsotg, qh);\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\n \nstatic int dwc2_check_max_xfer_size(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh)\n{\n\tu32 max_xfer_size;\n\tu32 max_channel_xfer_size;\n\tint status = 0;\n\n\tmax_xfer_size = qh->maxp * qh->maxp_mult;\n\tmax_channel_xfer_size = hsotg->params.max_transfer_size;\n\n\tif (max_xfer_size > max_channel_xfer_size) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: Periodic xfer length %d > max xfer length for channel %d\\n\",\n\t\t\t__func__, max_xfer_size, max_channel_xfer_size);\n\t\tstatus = -ENOSPC;\n\t}\n\n\treturn status;\n}\n\n \nstatic int dwc2_schedule_periodic(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tint status;\n\n\tstatus = dwc2_check_max_xfer_size(hsotg, qh);\n\tif (status) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: Channel max transfer size too small for periodic transfer\\n\",\n\t\t\t__func__);\n\t\treturn status;\n\t}\n\n\t \n\tif (del_timer(&qh->unreserve_timer))\n\t\tWARN_ON(!qh->unreserve_pending);\n\n\t \n\tif (!qh->unreserve_pending) {\n\t\tstatus = dwc2_do_reserve(hsotg, qh);\n\t\tif (status)\n\t\t\treturn status;\n\t} else {\n\t\t \n\t\tif (dwc2_frame_num_le(qh->next_active_frame,\n\t\t\t\t      hsotg->frame_number))\n\t\t\tdwc2_pick_first_frame(hsotg, qh);\n\t}\n\n\tqh->unreserve_pending = 0;\n\n\tif (hsotg->params.dma_desc_enable)\n\t\t \n\t\tlist_add_tail(&qh->qh_list_entry, &hsotg->periodic_sched_ready);\n\telse\n\t\t \n\t\tlist_add_tail(&qh->qh_list_entry,\n\t\t\t      &hsotg->periodic_sched_inactive);\n\n\treturn 0;\n}\n\n \nstatic void dwc2_deschedule_periodic(struct dwc2_hsotg *hsotg,\n\t\t\t\t     struct dwc2_qh *qh)\n{\n\tbool did_modify;\n\n\tassert_spin_locked(&hsotg->lock);\n\n\t \n\tdid_modify = mod_timer(&qh->unreserve_timer,\n\t\t\t       jiffies + DWC2_UNRESERVE_DELAY + 1);\n\tWARN_ON(did_modify);\n\tqh->unreserve_pending = 1;\n\n\tlist_del_init(&qh->qh_list_entry);\n}\n\n \nstatic enum hrtimer_restart dwc2_wait_timer_fn(struct hrtimer *t)\n{\n\tstruct dwc2_qh *qh = container_of(t, struct dwc2_qh, wait_timer);\n\tstruct dwc2_hsotg *hsotg = qh->hsotg;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t \n\tif (!qh->wait_timer_cancel) {\n\t\tenum dwc2_transaction_type tr_type;\n\n\t\tqh->want_wait = false;\n\n\t\tlist_move(&qh->qh_list_entry,\n\t\t\t  &hsotg->non_periodic_sched_inactive);\n\n\t\ttr_type = dwc2_hcd_select_transactions(hsotg);\n\t\tif (tr_type != DWC2_TRANSACTION_NONE)\n\t\t\tdwc2_hcd_queue_transactions(hsotg, tr_type);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic void dwc2_qh_init(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t struct dwc2_hcd_urb *urb, gfp_t mem_flags)\n{\n\tint dev_speed = dwc2_host_get_speed(hsotg, urb->priv);\n\tu8 ep_type = dwc2_hcd_get_pipe_type(&urb->pipe_info);\n\tbool ep_is_in = !!dwc2_hcd_is_pipe_in(&urb->pipe_info);\n\tbool ep_is_isoc = (ep_type == USB_ENDPOINT_XFER_ISOC);\n\tbool ep_is_int = (ep_type == USB_ENDPOINT_XFER_INT);\n\tu32 hprt = dwc2_readl(hsotg, HPRT0);\n\tu32 prtspd = (hprt & HPRT0_SPD_MASK) >> HPRT0_SPD_SHIFT;\n\tbool do_split = (prtspd == HPRT0_SPD_HIGH_SPEED &&\n\t\t\t dev_speed != USB_SPEED_HIGH);\n\tint maxp = dwc2_hcd_get_maxp(&urb->pipe_info);\n\tint maxp_mult = dwc2_hcd_get_maxp_mult(&urb->pipe_info);\n\tint bytecount = maxp_mult * maxp;\n\tchar *speed, *type;\n\n\t \n\tqh->hsotg = hsotg;\n\ttimer_setup(&qh->unreserve_timer, dwc2_unreserve_timer_fn, 0);\n\thrtimer_init(&qh->wait_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tqh->wait_timer.function = &dwc2_wait_timer_fn;\n\tqh->ep_type = ep_type;\n\tqh->ep_is_in = ep_is_in;\n\n\tqh->data_toggle = DWC2_HC_PID_DATA0;\n\tqh->maxp = maxp;\n\tqh->maxp_mult = maxp_mult;\n\tINIT_LIST_HEAD(&qh->qtd_list);\n\tINIT_LIST_HEAD(&qh->qh_list_entry);\n\n\tqh->do_split = do_split;\n\tqh->dev_speed = dev_speed;\n\n\tif (ep_is_int || ep_is_isoc) {\n\t\t \n\t\tint host_speed = do_split ? USB_SPEED_HIGH : dev_speed;\n\t\tstruct dwc2_tt *dwc_tt = dwc2_host_get_tt_info(hsotg, urb->priv,\n\t\t\t\t\t\t\t       mem_flags,\n\t\t\t\t\t\t\t       &qh->ttport);\n\t\tint device_ns;\n\n\t\tqh->dwc_tt = dwc_tt;\n\n\t\tqh->host_us = NS_TO_US(usb_calc_bus_time(host_speed, ep_is_in,\n\t\t\t\t       ep_is_isoc, bytecount));\n\t\tdevice_ns = usb_calc_bus_time(dev_speed, ep_is_in,\n\t\t\t\t\t      ep_is_isoc, bytecount);\n\n\t\tif (do_split && dwc_tt)\n\t\t\tdevice_ns += dwc_tt->usb_tt->think_time;\n\t\tqh->device_us = NS_TO_US(device_ns);\n\n\t\tqh->device_interval = urb->interval;\n\t\tqh->host_interval = urb->interval * (do_split ? 8 : 1);\n\n\t\t \n\t\tqh->schedule_low_speed = prtspd != HPRT0_SPD_HIGH_SPEED ||\n\t\t\t\t\t dwc_tt;\n\n\t\tif (do_split) {\n\t\t\t \n\t\t\tqh->num_hs_transfers = -1;\n\t\t} else if (dev_speed == USB_SPEED_HIGH) {\n\t\t\tqh->num_hs_transfers = 1;\n\t\t} else {\n\t\t\tqh->num_hs_transfers = 0;\n\t\t}\n\n\t\t \n\t}\n\n\tswitch (dev_speed) {\n\tcase USB_SPEED_LOW:\n\t\tspeed = \"low\";\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tspeed = \"full\";\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tspeed = \"high\";\n\t\tbreak;\n\tdefault:\n\t\tspeed = \"?\";\n\t\tbreak;\n\t}\n\n\tswitch (qh->ep_type) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\ttype = \"isochronous\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\ttype = \"interrupt\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\ttype = \"control\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\ttype = \"bulk\";\n\t\tbreak;\n\tdefault:\n\t\ttype = \"?\";\n\t\tbreak;\n\t}\n\n\tdwc2_sch_dbg(hsotg, \"QH=%p Init %s, %s speed, %d bytes:\\n\", qh, type,\n\t\t     speed, bytecount);\n\tdwc2_sch_dbg(hsotg, \"QH=%p ...addr=%d, ep=%d, %s\\n\", qh,\n\t\t     dwc2_hcd_get_dev_addr(&urb->pipe_info),\n\t\t     dwc2_hcd_get_ep_num(&urb->pipe_info),\n\t\t     ep_is_in ? \"IN\" : \"OUT\");\n\tif (ep_is_int || ep_is_isoc) {\n\t\tdwc2_sch_dbg(hsotg,\n\t\t\t     \"QH=%p ...duration: host=%d us, device=%d us\\n\",\n\t\t\t     qh, qh->host_us, qh->device_us);\n\t\tdwc2_sch_dbg(hsotg, \"QH=%p ...interval: host=%d, device=%d\\n\",\n\t\t\t     qh, qh->host_interval, qh->device_interval);\n\t\tif (qh->schedule_low_speed)\n\t\t\tdwc2_sch_dbg(hsotg, \"QH=%p ...low speed schedule=%p\\n\",\n\t\t\t\t     qh, dwc2_get_ls_map(hsotg, qh));\n\t}\n}\n\n \nstruct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hcd_urb *urb,\n\t\t\t\t\t  gfp_t mem_flags)\n{\n\tstruct dwc2_qh *qh;\n\n\tif (!urb->priv)\n\t\treturn NULL;\n\n\t \n\tqh = kzalloc(sizeof(*qh), mem_flags);\n\tif (!qh)\n\t\treturn NULL;\n\n\tdwc2_qh_init(hsotg, qh, urb, mem_flags);\n\n\tif (hsotg->params.dma_desc_enable &&\n\t    dwc2_hcd_qh_init_ddma(hsotg, qh, mem_flags) < 0) {\n\t\tdwc2_hcd_qh_free(hsotg, qh);\n\t\treturn NULL;\n\t}\n\n\treturn qh;\n}\n\n \nvoid dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\t \n\tif (del_timer_sync(&qh->unreserve_timer)) {\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tdwc2_do_unreserve(hsotg, qh);\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t}\n\n\t \n\thrtimer_cancel(&qh->wait_timer);\n\n\tdwc2_host_put_tt_info(hsotg, qh->dwc_tt);\n\n\tif (qh->desc_list)\n\t\tdwc2_hcd_qh_free_ddma(hsotg, qh);\n\telse if (hsotg->unaligned_cache && qh->dw_align_buf)\n\t\tkmem_cache_free(hsotg->unaligned_cache, qh->dw_align_buf);\n\n\tkfree(qh);\n}\n\n \nint dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tint status;\n\tu32 intr_mask;\n\tktime_t delay;\n\n\tif (dbg_qh(qh))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tif (!list_empty(&qh->qh_list_entry))\n\t\t \n\t\treturn 0;\n\n\t \n\tif (dwc2_qh_is_non_per(qh)) {\n\t\t \n\t\tqh->start_active_frame = hsotg->frame_number;\n\t\tqh->next_active_frame = qh->start_active_frame;\n\n\t\tif (qh->want_wait) {\n\t\t\tlist_add_tail(&qh->qh_list_entry,\n\t\t\t\t      &hsotg->non_periodic_sched_waiting);\n\t\t\tqh->wait_timer_cancel = false;\n\t\t\tdelay = ktime_set(0, DWC2_RETRY_WAIT_DELAY);\n\t\t\thrtimer_start(&qh->wait_timer, delay, HRTIMER_MODE_REL);\n\t\t} else {\n\t\t\tlist_add_tail(&qh->qh_list_entry,\n\t\t\t\t      &hsotg->non_periodic_sched_inactive);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatus = dwc2_schedule_periodic(hsotg, qh);\n\tif (status)\n\t\treturn status;\n\tif (!hsotg->periodic_qh_count) {\n\t\tintr_mask = dwc2_readl(hsotg, GINTMSK);\n\t\tintr_mask |= GINTSTS_SOF;\n\t\tdwc2_writel(hsotg, intr_mask, GINTMSK);\n\t}\n\thsotg->periodic_qh_count++;\n\n\treturn 0;\n}\n\n \nvoid dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh)\n{\n\tu32 intr_mask;\n\n\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\t \n\tqh->wait_timer_cancel = true;\n\n\tif (list_empty(&qh->qh_list_entry))\n\t\t \n\t\treturn;\n\n\tif (dwc2_qh_is_non_per(qh)) {\n\t\tif (hsotg->non_periodic_qh_ptr == &qh->qh_list_entry)\n\t\t\thsotg->non_periodic_qh_ptr =\n\t\t\t\t\thsotg->non_periodic_qh_ptr->next;\n\t\tlist_del_init(&qh->qh_list_entry);\n\t\treturn;\n\t}\n\n\tdwc2_deschedule_periodic(hsotg, qh);\n\thsotg->periodic_qh_count--;\n\tif (!hsotg->periodic_qh_count &&\n\t    !hsotg->params.dma_desc_enable) {\n\t\tintr_mask = dwc2_readl(hsotg, GINTMSK);\n\t\tintr_mask &= ~GINTSTS_SOF;\n\t\tdwc2_writel(hsotg, intr_mask, GINTMSK);\n\t}\n}\n\n \nstatic int dwc2_next_for_periodic_split(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_qh *qh, u16 frame_number)\n{\n\tu16 old_frame = qh->next_active_frame;\n\tu16 prev_frame_number = dwc2_frame_num_dec(frame_number, 1);\n\tint missed = 0;\n\tu16 incr;\n\n\t \n\tif (old_frame == qh->start_active_frame &&\n\t    !(qh->ep_type == USB_ENDPOINT_XFER_ISOC && !qh->ep_is_in))\n\t\tincr = 2;\n\telse\n\t\tincr = 1;\n\n\tqh->next_active_frame = dwc2_frame_num_inc(old_frame, incr);\n\n\t \n\tif (dwc2_frame_num_gt(prev_frame_number, qh->next_active_frame)) {\n\t\t \n\t\tmissed = dwc2_frame_num_dec(prev_frame_number,\n\t\t\t\t\t    qh->next_active_frame);\n\t\tqh->next_active_frame = frame_number;\n\t}\n\n\treturn missed;\n}\n\n \nstatic int dwc2_next_periodic_start(struct dwc2_hsotg *hsotg,\n\t\t\t\t    struct dwc2_qh *qh, u16 frame_number)\n{\n\tint missed = 0;\n\tu16 interval = qh->host_interval;\n\tu16 prev_frame_number = dwc2_frame_num_dec(frame_number, 1);\n\n\tqh->start_active_frame = dwc2_frame_num_inc(qh->start_active_frame,\n\t\t\t\t\t\t    interval);\n\n\t \n\tif (interval >= 0x1000)\n\t\tgoto exit;\n\n\t \n\tif (qh->start_active_frame == qh->next_active_frame ||\n\t    dwc2_frame_num_gt(prev_frame_number, qh->start_active_frame)) {\n\t\tu16 ideal_start = qh->start_active_frame;\n\t\tint periods_in_map;\n\n\t\t \n\t\tif (qh->do_split || qh->dev_speed == USB_SPEED_HIGH)\n\t\t\tperiods_in_map = DWC2_HS_SCHEDULE_UFRAMES;\n\t\telse\n\t\t\tperiods_in_map = DWC2_LS_SCHEDULE_FRAMES;\n\t\tinterval = gcd(interval, periods_in_map);\n\n\t\tdo {\n\t\t\tqh->start_active_frame = dwc2_frame_num_inc(\n\t\t\t\tqh->start_active_frame, interval);\n\t\t} while (dwc2_frame_num_gt(prev_frame_number,\n\t\t\t\t\t   qh->start_active_frame));\n\n\t\tmissed = dwc2_frame_num_dec(qh->start_active_frame,\n\t\t\t\t\t    ideal_start);\n\t}\n\nexit:\n\tqh->next_active_frame = qh->start_active_frame;\n\n\treturn missed;\n}\n\n \nvoid dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t    int sched_next_periodic_split)\n{\n\tu16 old_frame = qh->next_active_frame;\n\tu16 frame_number;\n\tint missed;\n\n\tif (dbg_qh(qh))\n\t\tdev_vdbg(hsotg->dev, \"%s()\\n\", __func__);\n\n\tif (dwc2_qh_is_non_per(qh)) {\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\tif (!list_empty(&qh->qtd_list))\n\t\t\t \n\t\t\tdwc2_hcd_qh_add(hsotg, qh);\n\t\treturn;\n\t}\n\n\t \n\tframe_number = dwc2_hcd_get_frame_number(hsotg);\n\n\tif (sched_next_periodic_split)\n\t\tmissed = dwc2_next_for_periodic_split(hsotg, qh, frame_number);\n\telse\n\t\tmissed = dwc2_next_periodic_start(hsotg, qh, frame_number);\n\n\tdwc2_sch_vdbg(hsotg,\n\t\t      \"QH=%p next(%d) fn=%04x, sch=%04x=>%04x (%+d) miss=%d %s\\n\",\n\t\t     qh, sched_next_periodic_split, frame_number, old_frame,\n\t\t     qh->next_active_frame,\n\t\t     dwc2_frame_num_dec(qh->next_active_frame, old_frame),\n\t\tmissed, missed ? \"MISS\" : \"\");\n\n\tif (list_empty(&qh->qtd_list)) {\n\t\tdwc2_hcd_qh_unlink(hsotg, qh);\n\t\treturn;\n\t}\n\n\t \n\tif (dwc2_frame_num_le(qh->next_active_frame, hsotg->frame_number))\n\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t       &hsotg->periodic_sched_ready);\n\telse\n\t\tlist_move_tail(&qh->qh_list_entry,\n\t\t\t       &hsotg->periodic_sched_inactive);\n}\n\n \nvoid dwc2_hcd_qtd_init(struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb)\n{\n\tqtd->urb = urb;\n\tif (dwc2_hcd_get_pipe_type(&urb->pipe_info) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\t \n\t\tqtd->data_toggle = DWC2_HC_PID_DATA1;\n\t\tqtd->control_phase = DWC2_CONTROL_SETUP;\n\t}\n\n\t \n\tqtd->complete_split = 0;\n\tqtd->isoc_split_pos = DWC2_HCSPLT_XACTPOS_ALL;\n\tqtd->isoc_split_offset = 0;\n\tqtd->in_process = 0;\n\n\t \n\turb->qtd = qtd;\n}\n\n \nint dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\n\t\t     struct dwc2_qh *qh)\n{\n\tint retval;\n\n\tif (unlikely(!qh)) {\n\t\tdev_err(hsotg->dev, \"%s: Invalid QH\\n\", __func__);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tretval = dwc2_hcd_qh_add(hsotg, qh);\n\tif (retval)\n\t\tgoto fail;\n\n\tqtd->qh = qh;\n\tlist_add_tail(&qtd->qtd_list_entry, &qh->qtd_list);\n\n\treturn 0;\nfail:\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}