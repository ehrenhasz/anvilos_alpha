{
  "module_name": "hcd.h",
  "hash_id": "0816e928f209e23d9820faa282c36a770444fd25195173f36a87df9d37913f85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/hcd.h",
  "human_readable_source": " \n \n\n#ifndef __DWC2_HCD_H__\n#define __DWC2_HCD_H__\n\n \n\nstruct dwc2_qh;\n\n \nstruct dwc2_host_chan {\n\tu8 hc_num;\n\n\tunsigned dev_addr:7;\n\tunsigned ep_num:4;\n\tunsigned ep_is_in:1;\n\tunsigned speed:4;\n\tunsigned ep_type:2;\n\tunsigned max_packet:11;\n\tunsigned data_pid_start:2;\n#define DWC2_HC_PID_DATA0\tTSIZ_SC_MC_PID_DATA0\n#define DWC2_HC_PID_DATA2\tTSIZ_SC_MC_PID_DATA2\n#define DWC2_HC_PID_DATA1\tTSIZ_SC_MC_PID_DATA1\n#define DWC2_HC_PID_MDATA\tTSIZ_SC_MC_PID_MDATA\n#define DWC2_HC_PID_SETUP\tTSIZ_SC_MC_PID_SETUP\n\n\tunsigned multi_count:2;\n\n\tu8 *xfer_buf;\n\tdma_addr_t xfer_dma;\n\tdma_addr_t align_buf;\n\tu32 xfer_len;\n\tu32 xfer_count;\n\tu16 start_pkt_count;\n\tu8 xfer_started;\n\tu8 do_ping;\n\tu8 error_state;\n\tu8 halt_on_queue;\n\tu8 halt_pending;\n\tu8 do_split;\n\tu8 complete_split;\n\tu8 hub_addr;\n\tu8 hub_port;\n\tu8 xact_pos;\n#define DWC2_HCSPLT_XACTPOS_MID\tHCSPLT_XACTPOS_MID\n#define DWC2_HCSPLT_XACTPOS_END\tHCSPLT_XACTPOS_END\n#define DWC2_HCSPLT_XACTPOS_BEGIN HCSPLT_XACTPOS_BEGIN\n#define DWC2_HCSPLT_XACTPOS_ALL\tHCSPLT_XACTPOS_ALL\n\n\tu8 requests;\n\tu8 schinfo;\n\tu16 ntd;\n\tenum dwc2_halt_status halt_status;\n\tu32 hcint;\n\tstruct dwc2_qh *qh;\n\tstruct list_head hc_list_entry;\n\tdma_addr_t desc_list_addr;\n\tu32 desc_list_sz;\n\tstruct list_head split_order_list_entry;\n};\n\nstruct dwc2_hcd_pipe_info {\n\tu8 dev_addr;\n\tu8 ep_num;\n\tu8 pipe_type;\n\tu8 pipe_dir;\n\tu16 maxp;\n\tu16 maxp_mult;\n};\n\nstruct dwc2_hcd_iso_packet_desc {\n\tu32 offset;\n\tu32 length;\n\tu32 actual_length;\n\tu32 status;\n};\n\nstruct dwc2_qtd;\n\nstruct dwc2_hcd_urb {\n\tvoid *priv;\n\tstruct dwc2_qtd *qtd;\n\tvoid *buf;\n\tdma_addr_t dma;\n\tvoid *setup_packet;\n\tdma_addr_t setup_dma;\n\tu32 length;\n\tu32 actual_length;\n\tu32 status;\n\tu32 error_count;\n\tu32 packet_count;\n\tu32 flags;\n\tu16 interval;\n\tstruct dwc2_hcd_pipe_info pipe_info;\n\tstruct dwc2_hcd_iso_packet_desc iso_descs[];\n};\n\n \nenum dwc2_control_phase {\n\tDWC2_CONTROL_SETUP,\n\tDWC2_CONTROL_DATA,\n\tDWC2_CONTROL_STATUS,\n};\n\n \nenum dwc2_transaction_type {\n\tDWC2_TRANSACTION_NONE,\n\tDWC2_TRANSACTION_PERIODIC,\n\tDWC2_TRANSACTION_NON_PERIODIC,\n\tDWC2_TRANSACTION_ALL,\n};\n\n \n#define DWC2_ELEMENTS_PER_LS_BITMAP\tDIV_ROUND_UP(DWC2_LS_SCHEDULE_SLICES, \\\n\t\t\t\t\t\t     BITS_PER_LONG)\n\n \nstruct dwc2_tt {\n\tint refcount;\n\tstruct usb_tt *usb_tt;\n\tunsigned long periodic_bitmaps[];\n};\n\n \n\nstruct dwc2_hs_transfer_time {\n\tu32 start_schedule_us;\n\tu16 duration_us;\n};\n\n \nstruct dwc2_qh {\n\tstruct dwc2_hsotg *hsotg;\n\tu8 ep_type;\n\tu8 ep_is_in;\n\tu16 maxp;\n\tu16 maxp_mult;\n\tu8 dev_speed;\n\tu8 data_toggle;\n\tu8 ping_state;\n\tu8 do_split;\n\tu8 td_first;\n\tu8 td_last;\n\tu16 host_us;\n\tu16 device_us;\n\tu16 host_interval;\n\tu16 device_interval;\n\tu16 next_active_frame;\n\tu16 start_active_frame;\n\ts16 num_hs_transfers;\n\tstruct dwc2_hs_transfer_time hs_transfers[DWC2_HS_SCHEDULE_UFRAMES];\n\tu32 ls_start_schedule_slice;\n\tu16 ntd;\n\tu8 *dw_align_buf;\n\tdma_addr_t dw_align_buf_dma;\n\tstruct list_head qtd_list;\n\tstruct dwc2_host_chan *channel;\n\tstruct list_head qh_list_entry;\n\tstruct dwc2_dma_desc *desc_list;\n\tdma_addr_t desc_list_dma;\n\tu32 desc_list_sz;\n\tu32 *n_bytes;\n\tstruct timer_list unreserve_timer;\n\tstruct hrtimer wait_timer;\n\tstruct dwc2_tt *dwc_tt;\n\tint ttport;\n\tunsigned tt_buffer_dirty:1;\n\tunsigned unreserve_pending:1;\n\tunsigned schedule_low_speed:1;\n\tunsigned want_wait:1;\n\tunsigned wait_timer_cancel:1;\n};\n\n \nstruct dwc2_qtd {\n\tenum dwc2_control_phase control_phase;\n\tu8 in_process;\n\tu8 data_toggle;\n\tu8 complete_split;\n\tu8 isoc_split_pos;\n\tu16 isoc_frame_index;\n\tu16 isoc_split_offset;\n\tu16 isoc_td_last;\n\tu16 isoc_td_first;\n\tu32 ssplit_out_xfer_count;\n\tu8 error_count;\n\tu8 n_desc;\n\tu16 isoc_frame_index_last;\n\tu16 num_naks;\n\tstruct dwc2_hcd_urb *urb;\n\tstruct dwc2_qh *qh;\n\tstruct list_head qtd_list_entry;\n};\n\n#ifdef DEBUG\nstruct hc_xfer_info {\n\tstruct dwc2_hsotg *hsotg;\n\tstruct dwc2_host_chan *chan;\n};\n#endif\n\nu32 dwc2_calc_frame_interval(struct dwc2_hsotg *hsotg);\n\n \nstatic inline struct usb_hcd *dwc2_hsotg_to_hcd(struct dwc2_hsotg *hsotg)\n{\n\treturn (struct usb_hcd *)hsotg->priv;\n}\n\n \nstatic inline void disable_hc_int(struct dwc2_hsotg *hsotg, int chnum, u32 intr)\n{\n\tu32 mask = dwc2_readl(hsotg, HCINTMSK(chnum));\n\n\tmask &= ~intr;\n\tdwc2_writel(hsotg, mask, HCINTMSK(chnum));\n}\n\nvoid dwc2_hc_cleanup(struct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan);\nvoid dwc2_hc_halt(struct dwc2_hsotg *hsotg, struct dwc2_host_chan *chan,\n\t\t  enum dwc2_halt_status halt_status);\nvoid dwc2_hc_start_transfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan);\n\n \nstatic inline u32 dwc2_read_hprt0(struct dwc2_hsotg *hsotg)\n{\n\tu32 hprt0 = dwc2_readl(hsotg, HPRT0);\n\n\thprt0 &= ~(HPRT0_ENA | HPRT0_CONNDET | HPRT0_ENACHG | HPRT0_OVRCURRCHG);\n\treturn hprt0;\n}\n\nstatic inline u8 dwc2_hcd_get_ep_num(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->ep_num;\n}\n\nstatic inline u8 dwc2_hcd_get_pipe_type(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_type;\n}\n\nstatic inline u16 dwc2_hcd_get_maxp(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->maxp;\n}\n\nstatic inline u16 dwc2_hcd_get_maxp_mult(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->maxp_mult;\n}\n\nstatic inline u8 dwc2_hcd_get_dev_addr(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->dev_addr;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_isoc(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_type == USB_ENDPOINT_XFER_ISOC;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_int(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_type == USB_ENDPOINT_XFER_INT;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_bulk(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_type == USB_ENDPOINT_XFER_BULK;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_control(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_type == USB_ENDPOINT_XFER_CONTROL;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_in(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn pipe->pipe_dir == USB_DIR_IN;\n}\n\nstatic inline u8 dwc2_hcd_is_pipe_out(struct dwc2_hcd_pipe_info *pipe)\n{\n\treturn !dwc2_hcd_is_pipe_in(pipe);\n}\n\nint dwc2_hcd_init(struct dwc2_hsotg *hsotg);\nvoid dwc2_hcd_remove(struct dwc2_hsotg *hsotg);\n\n \nenum dwc2_transaction_type dwc2_hcd_select_transactions(\n\t\t\t\t\t\tstruct dwc2_hsotg *hsotg);\nvoid dwc2_hcd_queue_transactions(struct dwc2_hsotg *hsotg,\n\t\t\t\t enum dwc2_transaction_type tr_type);\n\n \n \nstruct dwc2_qh *dwc2_hcd_qh_create(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hcd_urb *urb,\n\t\t\t\t\t  gfp_t mem_flags);\nvoid dwc2_hcd_qh_free(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);\nint dwc2_hcd_qh_add(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);\nvoid dwc2_hcd_qh_unlink(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);\nvoid dwc2_hcd_qh_deactivate(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t    int sched_csplit);\n\nvoid dwc2_hcd_qtd_init(struct dwc2_qtd *qtd, struct dwc2_hcd_urb *urb);\nint dwc2_hcd_qtd_add(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\n\t\t     struct dwc2_qh *qh);\n\n \nstatic inline void dwc2_hcd_qtd_unlink_and_free(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\tstruct dwc2_qtd *qtd,\n\t\t\t\t\t\tstruct dwc2_qh *qh)\n{\n\tlist_del(&qtd->qtd_list_entry);\n\tkfree(qtd);\n}\n\n \nvoid dwc2_hcd_start_xfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_qh *qh);\nvoid dwc2_hcd_complete_xfer_ddma(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t\tenum dwc2_halt_status halt_status);\n\nint dwc2_hcd_qh_init_ddma(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh,\n\t\t\t  gfp_t mem_flags);\nvoid dwc2_hcd_qh_free_ddma(struct dwc2_hsotg *hsotg, struct dwc2_qh *qh);\n\n \n#define dwc2_qh_is_non_per(_qh_ptr_) \\\n\t((_qh_ptr_)->ep_type == USB_ENDPOINT_XFER_BULK || \\\n\t (_qh_ptr_)->ep_type == USB_ENDPOINT_XFER_CONTROL)\n\n#ifdef CONFIG_USB_DWC2_DEBUG_PERIODIC\nstatic inline bool dbg_hc(struct dwc2_host_chan *hc) { return true; }\nstatic inline bool dbg_qh(struct dwc2_qh *qh) { return true; }\nstatic inline bool dbg_urb(struct urb *urb) { return true; }\nstatic inline bool dbg_perio(void) { return true; }\n#else  \nstatic inline bool dbg_hc(struct dwc2_host_chan *hc)\n{\n\treturn hc->ep_type == USB_ENDPOINT_XFER_BULK ||\n\t       hc->ep_type == USB_ENDPOINT_XFER_CONTROL;\n}\n\nstatic inline bool dbg_qh(struct dwc2_qh *qh)\n{\n\treturn qh->ep_type == USB_ENDPOINT_XFER_BULK ||\n\t       qh->ep_type == USB_ENDPOINT_XFER_CONTROL;\n}\n\nstatic inline bool dbg_urb(struct urb *urb)\n{\n\treturn usb_pipetype(urb->pipe) == PIPE_BULK ||\n\t       usb_pipetype(urb->pipe) == PIPE_CONTROL;\n}\n\nstatic inline bool dbg_perio(void) { return false; }\n#endif\n\n \nstatic inline bool dwc2_frame_idx_num_gt(u16 fr_idx1, u16 fr_idx2)\n{\n\tu16 diff = fr_idx1 - fr_idx2;\n\tu16 sign = diff & (FRLISTEN_64_SIZE >> 1);\n\n\treturn diff && !sign;\n}\n\n \nstatic inline int dwc2_frame_num_le(u16 frame1, u16 frame2)\n{\n\treturn ((frame2 - frame1) & HFNUM_MAX_FRNUM) <= (HFNUM_MAX_FRNUM >> 1);\n}\n\n \nstatic inline int dwc2_frame_num_gt(u16 frame1, u16 frame2)\n{\n\treturn (frame1 != frame2) &&\n\t       ((frame1 - frame2) & HFNUM_MAX_FRNUM) < (HFNUM_MAX_FRNUM >> 1);\n}\n\n \nstatic inline u16 dwc2_frame_num_inc(u16 frame, u16 inc)\n{\n\treturn (frame + inc) & HFNUM_MAX_FRNUM;\n}\n\nstatic inline u16 dwc2_frame_num_dec(u16 frame, u16 dec)\n{\n\treturn (frame + HFNUM_MAX_FRNUM + 1 - dec) & HFNUM_MAX_FRNUM;\n}\n\nstatic inline u16 dwc2_full_frame_num(u16 frame)\n{\n\treturn (frame & HFNUM_MAX_FRNUM) >> 3;\n}\n\nstatic inline u16 dwc2_micro_frame_num(u16 frame)\n{\n\treturn frame & 0x7;\n}\n\n \nstatic inline u32 dwc2_read_core_intr(struct dwc2_hsotg *hsotg)\n{\n\treturn dwc2_readl(hsotg, GINTSTS) &\n\t       dwc2_readl(hsotg, GINTMSK);\n}\n\nstatic inline u32 dwc2_hcd_urb_get_status(struct dwc2_hcd_urb *dwc2_urb)\n{\n\treturn dwc2_urb->status;\n}\n\nstatic inline u32 dwc2_hcd_urb_get_actual_length(\n\t\tstruct dwc2_hcd_urb *dwc2_urb)\n{\n\treturn dwc2_urb->actual_length;\n}\n\nstatic inline u32 dwc2_hcd_urb_get_error_count(struct dwc2_hcd_urb *dwc2_urb)\n{\n\treturn dwc2_urb->error_count;\n}\n\nstatic inline void dwc2_hcd_urb_set_iso_desc_params(\n\t\tstruct dwc2_hcd_urb *dwc2_urb, int desc_num, u32 offset,\n\t\tu32 length)\n{\n\tdwc2_urb->iso_descs[desc_num].offset = offset;\n\tdwc2_urb->iso_descs[desc_num].length = length;\n}\n\nstatic inline u32 dwc2_hcd_urb_get_iso_desc_status(\n\t\tstruct dwc2_hcd_urb *dwc2_urb, int desc_num)\n{\n\treturn dwc2_urb->iso_descs[desc_num].status;\n}\n\nstatic inline u32 dwc2_hcd_urb_get_iso_desc_actual_length(\n\t\tstruct dwc2_hcd_urb *dwc2_urb, int desc_num)\n{\n\treturn dwc2_urb->iso_descs[desc_num].actual_length;\n}\n\nstatic inline int dwc2_hcd_is_bandwidth_allocated(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t  struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_qh *qh = ep->hcpriv;\n\n\tif (qh && !list_empty(&qh->qh_list_entry))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic inline u16 dwc2_hcd_get_ep_bandwidth(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t    struct usb_host_endpoint *ep)\n{\n\tstruct dwc2_qh *qh = ep->hcpriv;\n\n\tif (!qh) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn qh->host_us;\n}\n\nvoid dwc2_hcd_save_data_toggle(struct dwc2_hsotg *hsotg,\n\t\t\t       struct dwc2_host_chan *chan, int chnum,\n\t\t\t\t      struct dwc2_qtd *qtd);\n\n \n\n \nirqreturn_t dwc2_handle_hcd_intr(struct dwc2_hsotg *hsotg);\n\n \nvoid dwc2_hcd_stop(struct dwc2_hsotg *hsotg);\n\n \nint dwc2_hcd_is_b_host(struct dwc2_hsotg *hsotg);\n\n \nvoid dwc2_hcd_dump_state(struct dwc2_hsotg *hsotg);\n\n \n\n \n#define URB_GIVEBACK_ASAP\t0x1\n#define URB_SEND_ZERO_PACKET\t0x2\n\n \nstruct dwc2_tt *dwc2_host_get_tt_info(struct dwc2_hsotg *hsotg,\n\t\t\t\t      void *context, gfp_t mem_flags,\n\t\t\t\t      int *ttport);\n\nvoid dwc2_host_put_tt_info(struct dwc2_hsotg *hsotg,\n\t\t\t   struct dwc2_tt *dwc_tt);\nint dwc2_host_get_speed(struct dwc2_hsotg *hsotg, void *context);\nvoid dwc2_host_complete(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,\n\t\t\tint status);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}