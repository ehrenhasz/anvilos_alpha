{
  "module_name": "drd.c",
  "hash_id": "28d21667d4d94c831b07e06b466028d934e4be50a3dc3c30f30df6cf34ecd018",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/drd.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/iopoll.h>\n#include <linux/platform_device.h>\n#include <linux/usb/role.h>\n#include \"core.h\"\n\n#define dwc2_ovr_gotgctl(gotgctl) \\\n\t((gotgctl) |= GOTGCTL_BVALOEN | GOTGCTL_AVALOEN | GOTGCTL_VBVALOEN | \\\n\t GOTGCTL_DBNCE_FLTR_BYPASS)\n\nstatic void dwc2_ovr_init(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\tu32 gotgctl;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\tdwc2_ovr_gotgctl(gotgctl);\n\tgotgctl &= ~(GOTGCTL_BVALOVAL | GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL);\n\tif (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)\n\t\tgotgctl |= GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL;\n\telse if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)\n\t\tgotgctl |= GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL;\n\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tdwc2_force_mode(hsotg, (hsotg->dr_mode == USB_DR_MODE_HOST) ||\n\t\t\t\t(hsotg->role_sw_default_mode == USB_DR_MODE_HOST));\n}\n\nstatic int dwc2_ovr_avalid(struct dwc2_hsotg *hsotg, bool valid)\n{\n\tu32 gotgctl = dwc2_readl(hsotg, GOTGCTL);\n\n\t \n\tif ((valid && (gotgctl & GOTGCTL_ASESVLD)) ||\n\t    (!valid && !(gotgctl & GOTGCTL_ASESVLD)))\n\t\treturn -EALREADY;\n\n\t \n\tdwc2_ovr_gotgctl(gotgctl);\n\n\tgotgctl &= ~GOTGCTL_BVALOVAL;\n\tif (valid)\n\t\tgotgctl |= GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL;\n\telse\n\t\tgotgctl &= ~(GOTGCTL_AVALOVAL | GOTGCTL_VBVALOVAL);\n\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\n\treturn 0;\n}\n\nstatic int dwc2_ovr_bvalid(struct dwc2_hsotg *hsotg, bool valid)\n{\n\tu32 gotgctl = dwc2_readl(hsotg, GOTGCTL);\n\n\t \n\tif ((valid && (gotgctl & GOTGCTL_BSESVLD)) ||\n\t    (!valid && !(gotgctl & GOTGCTL_BSESVLD)))\n\t\treturn -EALREADY;\n\n\t \n\tdwc2_ovr_gotgctl(gotgctl);\n\n\tgotgctl &= ~GOTGCTL_AVALOVAL;\n\tif (valid)\n\t\tgotgctl |= GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL;\n\telse\n\t\tgotgctl &= ~(GOTGCTL_BVALOVAL | GOTGCTL_VBVALOVAL);\n\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\n\treturn 0;\n}\n\nstatic int dwc2_drd_role_sw_set(struct usb_role_switch *sw, enum usb_role role)\n{\n\tstruct dwc2_hsotg *hsotg = usb_role_switch_get_drvdata(sw);\n\tunsigned long flags;\n\tint already = 0;\n\n\t \n\tif ((role == USB_ROLE_DEVICE && hsotg->dr_mode == USB_DR_MODE_HOST) ||\n\t    (role == USB_ROLE_HOST && hsotg->dr_mode == USB_DR_MODE_PERIPHERAL))\n\t\treturn -EINVAL;\n\n#if IS_ENABLED(CONFIG_USB_DWC2_PERIPHERAL) || \\\n\tIS_ENABLED(CONFIG_USB_DWC2_DUAL_ROLE)\n\t \n\tif (role == USB_ROLE_NONE && hsotg->test_mode) {\n\t\tdev_dbg(hsotg->dev, \"Core is in test mode\\n\");\n\t\treturn -EBUSY;\n\t}\n#endif\n\n\t \n\tif (!hsotg->ll_hw_enabled && hsotg->clk) {\n\t\tint ret = clk_prepare_enable(hsotg->clk);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tif (role == USB_ROLE_NONE) {\n\t\t \n\t\tif (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)\n\t\t\trole = USB_ROLE_HOST;\n\t\telse if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)\n\t\t\trole = USB_ROLE_DEVICE;\n\t}\n\n\tif (role == USB_ROLE_HOST) {\n\t\talready = dwc2_ovr_avalid(hsotg, true);\n\t} else if (role == USB_ROLE_DEVICE) {\n\t\talready = dwc2_ovr_bvalid(hsotg, true);\n\t\tif (dwc2_is_device_enabled(hsotg)) {\n\t\t\t \n\t\t\tdwc2_hsotg_core_connect(hsotg);\n\t\t}\n\t} else {\n\t\tif (dwc2_is_device_mode(hsotg)) {\n\t\t\tif (!dwc2_ovr_bvalid(hsotg, false))\n\t\t\t\t \n\t\t\t\tdwc2_hsotg_core_disconnect(hsotg);\n\t\t} else {\n\t\t\tdwc2_ovr_avalid(hsotg, false);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tif (!already && hsotg->dr_mode == USB_DR_MODE_OTG)\n\t\t \n\t\tdwc2_force_mode(hsotg, role == USB_ROLE_HOST);\n\n\tif (!hsotg->ll_hw_enabled && hsotg->clk)\n\t\tclk_disable_unprepare(hsotg->clk);\n\n\tdev_dbg(hsotg->dev, \"%s-session valid\\n\",\n\t\trole == USB_ROLE_NONE ? \"No\" :\n\t\trole == USB_ROLE_HOST ? \"A\" : \"B\");\n\n\treturn 0;\n}\n\nint dwc2_drd_init(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_role_switch_desc role_sw_desc = {0};\n\tstruct usb_role_switch *role_sw;\n\tint ret;\n\n\tif (!device_property_read_bool(hsotg->dev, \"usb-role-switch\"))\n\t\treturn 0;\n\n\thsotg->role_sw_default_mode = usb_get_role_switch_default_mode(hsotg->dev);\n\trole_sw_desc.driver_data = hsotg;\n\trole_sw_desc.fwnode = dev_fwnode(hsotg->dev);\n\trole_sw_desc.set = dwc2_drd_role_sw_set;\n\trole_sw_desc.allow_userspace_control = true;\n\n\trole_sw = usb_role_switch_register(hsotg->dev, &role_sw_desc);\n\tif (IS_ERR(role_sw)) {\n\t\tret = PTR_ERR(role_sw);\n\t\tdev_err(hsotg->dev,\n\t\t\t\"failed to register role switch: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thsotg->role_sw = role_sw;\n\n\t \n\tdwc2_ovr_init(hsotg);\n\n\treturn 0;\n}\n\nvoid dwc2_drd_suspend(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts, gintmsk;\n\n\tif (hsotg->role_sw && !hsotg->params.external_id_pin_ctl) {\n\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\tgintmsk &= ~GINTSTS_CONIDSTSCHNG;\n\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\tgintsts = dwc2_readl(hsotg, GINTSTS);\n\t\tdwc2_writel(hsotg, gintsts | GINTSTS_CONIDSTSCHNG, GINTSTS);\n\t}\n}\n\nvoid dwc2_drd_resume(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts, gintmsk;\n\tenum usb_role role;\n\n\tif (hsotg->role_sw) {\n\t\t \n\t\trole = usb_role_switch_get_role(hsotg->role_sw);\n\n\t\tif (role == USB_ROLE_NONE) {\n\t\t\tif (hsotg->role_sw_default_mode == USB_DR_MODE_HOST)\n\t\t\t\trole = USB_ROLE_HOST;\n\t\t\telse if (hsotg->role_sw_default_mode == USB_DR_MODE_PERIPHERAL)\n\t\t\t\trole = USB_ROLE_DEVICE;\n\t\t}\n\n\t\t \n\t\tif (role == USB_ROLE_HOST)\n\t\t\tdwc2_ovr_avalid(hsotg, true);\n\t\telse if (role == USB_ROLE_DEVICE)\n\t\t\tdwc2_ovr_bvalid(hsotg, true);\n\n\t\tdwc2_force_mode(hsotg, role == USB_ROLE_HOST);\n\n\t\tdev_dbg(hsotg->dev, \"resuming %s-session valid\\n\",\n\t\t\trole == USB_ROLE_NONE ? \"No\" :\n\t\t\trole == USB_ROLE_HOST ? \"A\" : \"B\");\n\t}\n\n\tif (hsotg->role_sw && !hsotg->params.external_id_pin_ctl) {\n\t\tgintsts = dwc2_readl(hsotg, GINTSTS);\n\t\tdwc2_writel(hsotg, gintsts | GINTSTS_CONIDSTSCHNG, GINTSTS);\n\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\tgintmsk |= GINTSTS_CONIDSTSCHNG;\n\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t}\n}\n\nvoid dwc2_drd_exit(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->role_sw)\n\t\tusb_role_switch_unregister(hsotg->role_sw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}