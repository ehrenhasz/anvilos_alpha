{
  "module_name": "gadget.c",
  "hash_id": "72f363b72a84bbcd65bff90268f002a0c3bcb649c5c01f115a1722c4cfebb554",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/gadget.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/mutex.h>\n#include <linux/seq_file.h>\n#include <linux/delay.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/phy.h>\n#include <linux/usb/composite.h>\n\n\n#include \"core.h\"\n#include \"hw.h\"\n\n \nstatic inline struct dwc2_hsotg_req *our_req(struct usb_request *req)\n{\n\treturn container_of(req, struct dwc2_hsotg_req, req);\n}\n\nstatic inline struct dwc2_hsotg_ep *our_ep(struct usb_ep *ep)\n{\n\treturn container_of(ep, struct dwc2_hsotg_ep, ep);\n}\n\nstatic inline struct dwc2_hsotg *to_hsotg(struct usb_gadget *gadget)\n{\n\treturn container_of(gadget, struct dwc2_hsotg, gadget);\n}\n\nstatic inline void dwc2_set_bit(struct dwc2_hsotg *hsotg, u32 offset, u32 val)\n{\n\tdwc2_writel(hsotg, dwc2_readl(hsotg, offset) | val, offset);\n}\n\nstatic inline void dwc2_clear_bit(struct dwc2_hsotg *hsotg, u32 offset, u32 val)\n{\n\tdwc2_writel(hsotg, dwc2_readl(hsotg, offset) & ~val, offset);\n}\n\nstatic inline struct dwc2_hsotg_ep *index_to_ep(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\tu32 ep_index, u32 dir_in)\n{\n\tif (dir_in)\n\t\treturn hsotg->eps_in[ep_index];\n\telse\n\t\treturn hsotg->eps_out[ep_index];\n}\n\n \nstatic void dwc2_hsotg_dump(struct dwc2_hsotg *hsotg);\n\n \nstatic inline bool using_dma(struct dwc2_hsotg *hsotg)\n{\n\treturn hsotg->params.g_dma;\n}\n\n \nstatic inline bool using_desc_dma(struct dwc2_hsotg *hsotg)\n{\n\treturn hsotg->params.g_dma_desc;\n}\n\n \nstatic inline void dwc2_gadget_incr_frame_num(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tu16 limit = DSTS_SOFFN_LIMIT;\n\n\tif (hsotg->gadget.speed != USB_SPEED_HIGH)\n\t\tlimit >>= 3;\n\n\ths_ep->target_frame += hs_ep->interval;\n\tif (hs_ep->target_frame > limit) {\n\t\ths_ep->frame_overrun = true;\n\t\ths_ep->target_frame &= limit;\n\t} else {\n\t\ths_ep->frame_overrun = false;\n\t}\n}\n\n \nstatic inline void dwc2_gadget_dec_frame_num_by_one(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tu16 limit = DSTS_SOFFN_LIMIT;\n\n\tif (hsotg->gadget.speed != USB_SPEED_HIGH)\n\t\tlimit >>= 3;\n\n\tif (hs_ep->target_frame)\n\t\ths_ep->target_frame -= 1;\n\telse\n\t\ths_ep->target_frame = limit;\n}\n\n \nstatic void dwc2_hsotg_en_gsint(struct dwc2_hsotg *hsotg, u32 ints)\n{\n\tu32 gsintmsk = dwc2_readl(hsotg, GINTMSK);\n\tu32 new_gsintmsk;\n\n\tnew_gsintmsk = gsintmsk | ints;\n\n\tif (new_gsintmsk != gsintmsk) {\n\t\tdev_dbg(hsotg->dev, \"gsintmsk now 0x%08x\\n\", new_gsintmsk);\n\t\tdwc2_writel(hsotg, new_gsintmsk, GINTMSK);\n\t}\n}\n\n \nstatic void dwc2_hsotg_disable_gsint(struct dwc2_hsotg *hsotg, u32 ints)\n{\n\tu32 gsintmsk = dwc2_readl(hsotg, GINTMSK);\n\tu32 new_gsintmsk;\n\n\tnew_gsintmsk = gsintmsk & ~ints;\n\n\tif (new_gsintmsk != gsintmsk)\n\t\tdwc2_writel(hsotg, new_gsintmsk, GINTMSK);\n}\n\n \nstatic void dwc2_hsotg_ctrl_epint(struct dwc2_hsotg *hsotg,\n\t\t\t\t  unsigned int ep, unsigned int dir_in,\n\t\t\t\t unsigned int en)\n{\n\tunsigned long flags;\n\tu32 bit = 1 << ep;\n\tu32 daint;\n\n\tif (!dir_in)\n\t\tbit <<= 16;\n\n\tlocal_irq_save(flags);\n\tdaint = dwc2_readl(hsotg, DAINTMSK);\n\tif (en)\n\t\tdaint |= bit;\n\telse\n\t\tdaint &= ~bit;\n\tdwc2_writel(hsotg, daint, DAINTMSK);\n\tlocal_irq_restore(flags);\n}\n\n \nint dwc2_hsotg_tx_fifo_count(struct dwc2_hsotg *hsotg)\n{\n\tif (hsotg->hw_params.en_multiple_tx_fifo)\n\t\t \n\t\treturn hsotg->hw_params.num_dev_in_eps;\n\telse\n\t\t \n\t\treturn hsotg->hw_params.num_dev_perio_in_ep;\n}\n\n \nint dwc2_hsotg_tx_fifo_total_depth(struct dwc2_hsotg *hsotg)\n{\n\tint addr;\n\tint tx_addr_max;\n\tu32 np_tx_fifo_size;\n\n\tnp_tx_fifo_size = min_t(u32, hsotg->hw_params.dev_nperio_tx_fifo_size,\n\t\t\t\thsotg->params.g_np_tx_fifo_size);\n\n\t \n\ttx_addr_max = hsotg->hw_params.total_fifo_size;\n\n\taddr = hsotg->params.g_rx_fifo_size + np_tx_fifo_size;\n\tif (tx_addr_max <= addr)\n\t\treturn 0;\n\n\treturn tx_addr_max - addr;\n}\n\n \nstatic void dwc2_gadget_wkup_alert_handler(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts2;\n\tu32 gintmsk2;\n\n\tgintsts2 = dwc2_readl(hsotg, GINTSTS2);\n\tgintmsk2 = dwc2_readl(hsotg, GINTMSK2);\n\tgintsts2 &= gintmsk2;\n\n\tif (gintsts2 & GINTSTS2_WKUP_ALERT_INT) {\n\t\tdev_dbg(hsotg->dev, \"%s: Wkup_Alert_Int\\n\", __func__);\n\t\tdwc2_set_bit(hsotg, GINTSTS2, GINTSTS2_WKUP_ALERT_INT);\n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_RMTWKUPSIG);\n\t}\n}\n\n \nint dwc2_hsotg_tx_fifo_average_depth(struct dwc2_hsotg *hsotg)\n{\n\tint tx_fifo_count;\n\tint tx_fifo_depth;\n\n\ttx_fifo_depth = dwc2_hsotg_tx_fifo_total_depth(hsotg);\n\n\ttx_fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\n\n\tif (!tx_fifo_count)\n\t\treturn tx_fifo_depth;\n\telse\n\t\treturn tx_fifo_depth / tx_fifo_count;\n}\n\n \nstatic void dwc2_hsotg_init_fifo(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int ep;\n\tunsigned int addr;\n\tint timeout;\n\n\tu32 val;\n\tu32 *txfsz = hsotg->params.g_tx_fifo_size;\n\n\t \n\tWARN_ON(hsotg->fifo_map);\n\thsotg->fifo_map = 0;\n\n\t \n\tdwc2_writel(hsotg, hsotg->params.g_rx_fifo_size, GRXFSIZ);\n\tdwc2_writel(hsotg, (hsotg->params.g_rx_fifo_size <<\n\t\t    FIFOSIZE_STARTADDR_SHIFT) |\n\t\t    (hsotg->params.g_np_tx_fifo_size << FIFOSIZE_DEPTH_SHIFT),\n\t\t    GNPTXFSIZ);\n\n\t \n\n\t \n\taddr = hsotg->params.g_rx_fifo_size + hsotg->params.g_np_tx_fifo_size;\n\n\t \n\tfor (ep = 1; ep < MAX_EPS_CHANNELS; ep++) {\n\t\tif (!txfsz[ep])\n\t\t\tcontinue;\n\t\tval = addr;\n\t\tval |= txfsz[ep] << FIFOSIZE_DEPTH_SHIFT;\n\t\tWARN_ONCE(addr + txfsz[ep] > hsotg->fifo_mem,\n\t\t\t  \"insufficient fifo memory\");\n\t\taddr += txfsz[ep];\n\n\t\tdwc2_writel(hsotg, val, DPTXFSIZN(ep));\n\t\tval = dwc2_readl(hsotg, DPTXFSIZN(ep));\n\t}\n\n\tdwc2_writel(hsotg, hsotg->hw_params.total_fifo_size |\n\t\t    addr << GDFIFOCFG_EPINFOBASE_SHIFT,\n\t\t    GDFIFOCFG);\n\t \n\n\tdwc2_writel(hsotg, GRSTCTL_TXFNUM(0x10) | GRSTCTL_TXFFLSH |\n\t       GRSTCTL_RXFFLSH, GRSTCTL);\n\n\t \n\ttimeout = 100;\n\twhile (1) {\n\t\tval = dwc2_readl(hsotg, GRSTCTL);\n\n\t\tif ((val & (GRSTCTL_TXFFLSH | GRSTCTL_RXFFLSH)) == 0)\n\t\t\tbreak;\n\n\t\tif (--timeout == 0) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: timeout flushing fifos (GRSTCTL=%08x)\\n\",\n\t\t\t\t__func__, val);\n\t\t\tbreak;\n\t\t}\n\n\t\tudelay(1);\n\t}\n\n\tdev_dbg(hsotg->dev, \"FIFOs reset, timeout at %d\\n\", timeout);\n}\n\n \nstatic struct usb_request *dwc2_hsotg_ep_alloc_request(struct usb_ep *ep,\n\t\t\t\t\t\t       gfp_t flags)\n{\n\tstruct dwc2_hsotg_req *req;\n\n\treq = kzalloc(sizeof(*req), flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->queue);\n\n\treturn &req->req;\n}\n\n \nstatic inline int is_ep_periodic(struct dwc2_hsotg_ep *hs_ep)\n{\n\treturn hs_ep->periodic;\n}\n\n \nstatic void dwc2_hsotg_unmap_dma(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\tstruct dwc2_hsotg_req *hs_req)\n{\n\tstruct usb_request *req = &hs_req->req;\n\n\tusb_gadget_unmap_request(&hsotg->gadget, req, hs_ep->map_dir);\n}\n\n \nstatic int dwc2_gadget_alloc_ctrl_desc_chains(struct dwc2_hsotg *hsotg)\n{\n\thsotg->setup_desc[0] =\n\t\tdmam_alloc_coherent(hsotg->dev,\n\t\t\t\t    sizeof(struct dwc2_dma_desc),\n\t\t\t\t    &hsotg->setup_desc_dma[0],\n\t\t\t\t    GFP_KERNEL);\n\tif (!hsotg->setup_desc[0])\n\t\tgoto fail;\n\n\thsotg->setup_desc[1] =\n\t\tdmam_alloc_coherent(hsotg->dev,\n\t\t\t\t    sizeof(struct dwc2_dma_desc),\n\t\t\t\t    &hsotg->setup_desc_dma[1],\n\t\t\t\t    GFP_KERNEL);\n\tif (!hsotg->setup_desc[1])\n\t\tgoto fail;\n\n\thsotg->ctrl_in_desc =\n\t\tdmam_alloc_coherent(hsotg->dev,\n\t\t\t\t    sizeof(struct dwc2_dma_desc),\n\t\t\t\t    &hsotg->ctrl_in_desc_dma,\n\t\t\t\t    GFP_KERNEL);\n\tif (!hsotg->ctrl_in_desc)\n\t\tgoto fail;\n\n\thsotg->ctrl_out_desc =\n\t\tdmam_alloc_coherent(hsotg->dev,\n\t\t\t\t    sizeof(struct dwc2_dma_desc),\n\t\t\t\t    &hsotg->ctrl_out_desc_dma,\n\t\t\t\t    GFP_KERNEL);\n\tif (!hsotg->ctrl_out_desc)\n\t\tgoto fail;\n\n\treturn 0;\n\nfail:\n\treturn -ENOMEM;\n}\n\n \nstatic int dwc2_hsotg_write_fifo(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\tstruct dwc2_hsotg_req *hs_req)\n{\n\tbool periodic = is_ep_periodic(hs_ep);\n\tu32 gnptxsts = dwc2_readl(hsotg, GNPTXSTS);\n\tint buf_pos = hs_req->req.actual;\n\tint to_write = hs_ep->size_loaded;\n\tvoid *data;\n\tint can_write;\n\tint pkt_round;\n\tint max_transfer;\n\n\tto_write -= (buf_pos - hs_ep->last_load);\n\n\t \n\tif (to_write == 0)\n\t\treturn 0;\n\n\tif (periodic && !hsotg->dedicated_fifos) {\n\t\tu32 epsize = dwc2_readl(hsotg, DIEPTSIZ(hs_ep->index));\n\t\tint size_left;\n\t\tint size_done;\n\n\t\t \n\n\t\tsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\n\n\t\t \n\t\tif (hs_ep->fifo_load != 0) {\n\t\t\tdwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tdev_dbg(hsotg->dev, \"%s: left=%d, load=%d, fifo=%d, size %d\\n\",\n\t\t\t__func__, size_left,\n\t\t\ths_ep->size_loaded, hs_ep->fifo_load, hs_ep->fifo_size);\n\n\t\t \n\t\tsize_done = hs_ep->size_loaded - size_left;\n\n\t\t \n\t\tcan_write = hs_ep->fifo_load - size_done;\n\t\tdev_dbg(hsotg->dev, \"%s: => can_write1=%d\\n\",\n\t\t\t__func__, can_write);\n\n\t\tcan_write = hs_ep->fifo_size - can_write;\n\t\tdev_dbg(hsotg->dev, \"%s: => can_write2=%d\\n\",\n\t\t\t__func__, can_write);\n\n\t\tif (can_write <= 0) {\n\t\t\tdwc2_hsotg_en_gsint(hsotg, GINTSTS_PTXFEMP);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t} else if (hsotg->dedicated_fifos && hs_ep->index != 0) {\n\t\tcan_write = dwc2_readl(hsotg,\n\t\t\t\t       DTXFSTS(hs_ep->fifo_index));\n\n\t\tcan_write &= 0xffff;\n\t\tcan_write *= 4;\n\t} else {\n\t\tif (GNPTXSTS_NP_TXQ_SPC_AVAIL_GET(gnptxsts) == 0) {\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"%s: no queue slots available (0x%08x)\\n\",\n\t\t\t\t__func__, gnptxsts);\n\n\t\t\tdwc2_hsotg_en_gsint(hsotg, GINTSTS_NPTXFEMP);\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tcan_write = GNPTXSTS_NP_TXF_SPC_AVAIL_GET(gnptxsts);\n\t\tcan_write *= 4;\t \n\t}\n\n\tmax_transfer = hs_ep->ep.maxpacket * hs_ep->mc;\n\n\tdev_dbg(hsotg->dev, \"%s: GNPTXSTS=%08x, can=%d, to=%d, max_transfer %d\\n\",\n\t\t__func__, gnptxsts, can_write, to_write, max_transfer);\n\n\t \n\tif (can_write > 512 && !periodic)\n\t\tcan_write = 512;\n\n\t \n\tif (to_write > max_transfer) {\n\t\tto_write = max_transfer;\n\n\t\t \n\t\tif (!hsotg->dedicated_fifos)\n\t\t\tdwc2_hsotg_en_gsint(hsotg,\n\t\t\t\t\t    periodic ? GINTSTS_PTXFEMP :\n\t\t\t\t\t   GINTSTS_NPTXFEMP);\n\t}\n\n\t \n\n\tif (to_write > can_write) {\n\t\tto_write = can_write;\n\t\tpkt_round = to_write % max_transfer;\n\n\t\t \n\n\t\tif (pkt_round)\n\t\t\tto_write -= pkt_round;\n\n\t\t \n\n\t\t \n\t\tif (!hsotg->dedicated_fifos)\n\t\t\tdwc2_hsotg_en_gsint(hsotg,\n\t\t\t\t\t    periodic ? GINTSTS_PTXFEMP :\n\t\t\t\t\t   GINTSTS_NPTXFEMP);\n\t}\n\n\tdev_dbg(hsotg->dev, \"write %d/%d, can_write %d, done %d\\n\",\n\t\tto_write, hs_req->req.length, can_write, buf_pos);\n\n\tif (to_write <= 0)\n\t\treturn -ENOSPC;\n\n\ths_req->req.actual = buf_pos + to_write;\n\ths_ep->total_data += to_write;\n\n\tif (periodic)\n\t\ths_ep->fifo_load += to_write;\n\n\tto_write = DIV_ROUND_UP(to_write, 4);\n\tdata = hs_req->req.buf + buf_pos;\n\n\tdwc2_writel_rep(hsotg, EPFIFO(hs_ep->index), data, to_write);\n\n\treturn (to_write >= can_write) ? -ENOSPC : 0;\n}\n\n \nstatic unsigned int get_ep_limit(struct dwc2_hsotg_ep *hs_ep)\n{\n\tint index = hs_ep->index;\n\tunsigned int maxsize;\n\tunsigned int maxpkt;\n\n\tif (index != 0) {\n\t\tmaxsize = DXEPTSIZ_XFERSIZE_LIMIT + 1;\n\t\tmaxpkt = DXEPTSIZ_PKTCNT_LIMIT + 1;\n\t} else {\n\t\tmaxsize = 64 + 64;\n\t\tif (hs_ep->dir_in)\n\t\t\tmaxpkt = DIEPTSIZ0_PKTCNT_LIMIT + 1;\n\t\telse\n\t\t\tmaxpkt = 2;\n\t}\n\n\t \n\tmaxpkt--;\n\tmaxsize--;\n\n\t \n\n\tif ((maxpkt * hs_ep->ep.maxpacket) < maxsize)\n\t\tmaxsize = maxpkt * hs_ep->ep.maxpacket;\n\n\treturn maxsize;\n}\n\n \nstatic u32 dwc2_hsotg_read_frameno(struct dwc2_hsotg *hsotg)\n{\n\tu32 dsts;\n\n\tdsts = dwc2_readl(hsotg, DSTS);\n\tdsts &= DSTS_SOFFN_MASK;\n\tdsts >>= DSTS_SOFFN_SHIFT;\n\n\treturn dsts;\n}\n\n \nstatic unsigned int dwc2_gadget_get_chain_limit(struct dwc2_hsotg_ep *hs_ep)\n{\n\tconst struct usb_endpoint_descriptor *ep_desc = hs_ep->ep.desc;\n\tint is_isoc = hs_ep->isochronous;\n\tunsigned int maxsize;\n\tu32 mps = hs_ep->ep.maxpacket;\n\tint dir_in = hs_ep->dir_in;\n\n\tif (is_isoc)\n\t\tmaxsize = (hs_ep->dir_in ? DEV_DMA_ISOC_TX_NBYTES_LIMIT :\n\t\t\t\t\t   DEV_DMA_ISOC_RX_NBYTES_LIMIT) *\n\t\t\t\t\t   MAX_DMA_DESC_NUM_HS_ISOC;\n\telse\n\t\tmaxsize = DEV_DMA_NBYTES_LIMIT * MAX_DMA_DESC_NUM_GENERIC;\n\n\t \n\tif (hs_ep->index)\n\t\tif (usb_endpoint_xfer_int(ep_desc) && !dir_in && (mps % 4))\n\t\t\tmaxsize = mps * MAX_DMA_DESC_NUM_GENERIC;\n\n\treturn maxsize;\n}\n\n \nstatic u32 dwc2_gadget_get_desc_params(struct dwc2_hsotg_ep *hs_ep, u32 *mask)\n{\n\tconst struct usb_endpoint_descriptor *ep_desc = hs_ep->ep.desc;\n\tu32 mps = hs_ep->ep.maxpacket;\n\tint dir_in = hs_ep->dir_in;\n\tu32 desc_size = 0;\n\n\tif (!hs_ep->index && !dir_in) {\n\t\tdesc_size = mps;\n\t\t*mask = DEV_DMA_NBYTES_MASK;\n\t} else if (hs_ep->isochronous) {\n\t\tif (dir_in) {\n\t\t\tdesc_size = DEV_DMA_ISOC_TX_NBYTES_LIMIT;\n\t\t\t*mask = DEV_DMA_ISOC_TX_NBYTES_MASK;\n\t\t} else {\n\t\t\tdesc_size = DEV_DMA_ISOC_RX_NBYTES_LIMIT;\n\t\t\t*mask = DEV_DMA_ISOC_RX_NBYTES_MASK;\n\t\t}\n\t} else {\n\t\tdesc_size = DEV_DMA_NBYTES_LIMIT;\n\t\t*mask = DEV_DMA_NBYTES_MASK;\n\n\t\t \n\t\tdesc_size -= desc_size % mps;\n\t}\n\n\t \n\tif (hs_ep->index)\n\t\tif (usb_endpoint_xfer_int(ep_desc) && !dir_in && (mps % 4)) {\n\t\t\tdesc_size = mps;\n\t\t\t*mask = DEV_DMA_NBYTES_MASK;\n\t\t}\n\n\treturn desc_size;\n}\n\nstatic void dwc2_gadget_fill_nonisoc_xfer_ddma_one(struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t\t\t struct dwc2_dma_desc **desc,\n\t\t\t\t\t\t dma_addr_t dma_buff,\n\t\t\t\t\t\t unsigned int len,\n\t\t\t\t\t\t bool true_last)\n{\n\tint dir_in = hs_ep->dir_in;\n\tu32 mps = hs_ep->ep.maxpacket;\n\tu32 maxsize = 0;\n\tu32 offset = 0;\n\tu32 mask = 0;\n\tint i;\n\n\tmaxsize = dwc2_gadget_get_desc_params(hs_ep, &mask);\n\n\ths_ep->desc_count = (len / maxsize) +\n\t\t\t\t((len % maxsize) ? 1 : 0);\n\tif (len == 0)\n\t\ths_ep->desc_count = 1;\n\n\tfor (i = 0; i < hs_ep->desc_count; ++i) {\n\t\t(*desc)->status = 0;\n\t\t(*desc)->status |= (DEV_DMA_BUFF_STS_HBUSY\n\t\t\t\t << DEV_DMA_BUFF_STS_SHIFT);\n\n\t\tif (len > maxsize) {\n\t\t\tif (!hs_ep->index && !dir_in)\n\t\t\t\t(*desc)->status |= (DEV_DMA_L | DEV_DMA_IOC);\n\n\t\t\t(*desc)->status |=\n\t\t\t\tmaxsize << DEV_DMA_NBYTES_SHIFT & mask;\n\t\t\t(*desc)->buf = dma_buff + offset;\n\n\t\t\tlen -= maxsize;\n\t\t\toffset += maxsize;\n\t\t} else {\n\t\t\tif (true_last)\n\t\t\t\t(*desc)->status |= (DEV_DMA_L | DEV_DMA_IOC);\n\n\t\t\tif (dir_in)\n\t\t\t\t(*desc)->status |= (len % mps) ? DEV_DMA_SHORT :\n\t\t\t\t\t((hs_ep->send_zlp && true_last) ?\n\t\t\t\t\tDEV_DMA_SHORT : 0);\n\n\t\t\t(*desc)->status |=\n\t\t\t\tlen << DEV_DMA_NBYTES_SHIFT & mask;\n\t\t\t(*desc)->buf = dma_buff + offset;\n\t\t}\n\n\t\t(*desc)->status &= ~DEV_DMA_BUFF_STS_MASK;\n\t\t(*desc)->status |= (DEV_DMA_BUFF_STS_HREADY\n\t\t\t\t << DEV_DMA_BUFF_STS_SHIFT);\n\t\t(*desc)++;\n\t}\n}\n\n \nstatic void dwc2_gadget_config_nonisoc_xfer_ddma(struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t\t\t dma_addr_t dma_buff,\n\t\t\t\t\t\t unsigned int len)\n{\n\tstruct usb_request *ureq = NULL;\n\tstruct dwc2_dma_desc *desc = hs_ep->desc_list;\n\tstruct scatterlist *sg;\n\tint i;\n\tu8 desc_count = 0;\n\n\tif (hs_ep->req)\n\t\tureq = &hs_ep->req->req;\n\n\t \n\tif (!ureq || !ureq->num_sgs) {\n\t\tdwc2_gadget_fill_nonisoc_xfer_ddma_one(hs_ep, &desc,\n\t\t\tdma_buff, len, true);\n\t\treturn;\n\t}\n\n\t \n\tfor_each_sg(ureq->sg, sg, ureq->num_sgs, i) {\n\t\tdwc2_gadget_fill_nonisoc_xfer_ddma_one(hs_ep, &desc,\n\t\t\tsg_dma_address(sg) + sg->offset, sg_dma_len(sg),\n\t\t\tsg_is_last(sg));\n\t\tdesc_count += hs_ep->desc_count;\n\t}\n\n\ths_ep->desc_count = desc_count;\n}\n\n \nstatic int dwc2_gadget_fill_isoc_desc(struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t      dma_addr_t dma_buff, unsigned int len)\n{\n\tstruct dwc2_dma_desc *desc;\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tu32 index;\n\tu32 mask = 0;\n\tu8 pid = 0;\n\n\tdwc2_gadget_get_desc_params(hs_ep, &mask);\n\n\tindex = hs_ep->next_desc;\n\tdesc = &hs_ep->desc_list[index];\n\n\t \n\tif ((desc->status >> DEV_DMA_BUFF_STS_SHIFT) ==\n\t    DEV_DMA_BUFF_STS_HREADY) {\n\t\tdev_dbg(hsotg->dev, \"%s: desc chain full\\n\", __func__);\n\t\treturn 1;\n\t}\n\n\t \n\tif (hs_ep->next_desc)\n\t\ths_ep->desc_list[index - 1].status &= ~DEV_DMA_L;\n\n\tdev_dbg(hsotg->dev, \"%s: Filling ep %d, dir %s isoc desc # %d\\n\",\n\t\t__func__, hs_ep->index, hs_ep->dir_in ? \"in\" : \"out\", index);\n\n\tdesc->status = 0;\n\tdesc->status |= (DEV_DMA_BUFF_STS_HBUSY\t<< DEV_DMA_BUFF_STS_SHIFT);\n\n\tdesc->buf = dma_buff;\n\tdesc->status |= (DEV_DMA_L | DEV_DMA_IOC |\n\t\t\t ((len << DEV_DMA_NBYTES_SHIFT) & mask));\n\n\tif (hs_ep->dir_in) {\n\t\tif (len)\n\t\t\tpid = DIV_ROUND_UP(len, hs_ep->ep.maxpacket);\n\t\telse\n\t\t\tpid = 1;\n\t\tdesc->status |= ((pid << DEV_DMA_ISOC_PID_SHIFT) &\n\t\t\t\t DEV_DMA_ISOC_PID_MASK) |\n\t\t\t\t((len % hs_ep->ep.maxpacket) ?\n\t\t\t\t DEV_DMA_SHORT : 0) |\n\t\t\t\t((hs_ep->target_frame <<\n\t\t\t\t  DEV_DMA_ISOC_FRNUM_SHIFT) &\n\t\t\t\t DEV_DMA_ISOC_FRNUM_MASK);\n\t}\n\n\tdesc->status &= ~DEV_DMA_BUFF_STS_MASK;\n\tdesc->status |= (DEV_DMA_BUFF_STS_HREADY << DEV_DMA_BUFF_STS_SHIFT);\n\n\t \n\tif (hs_ep->dir_in)\n\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\n\t \n\ths_ep->next_desc++;\n\tif (hs_ep->next_desc >= MAX_DMA_DESC_NUM_HS_ISOC)\n\t\ths_ep->next_desc = 0;\n\n\treturn 0;\n}\n\n \nstatic void dwc2_gadget_start_isoc_ddma(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tstruct dwc2_hsotg_req *hs_req, *treq;\n\tint index = hs_ep->index;\n\tint ret;\n\tint i;\n\tu32 dma_reg;\n\tu32 depctl;\n\tu32 ctrl;\n\tstruct dwc2_dma_desc *desc;\n\n\tif (list_empty(&hs_ep->queue)) {\n\t\ths_ep->target_frame = TARGET_FRAME_INITIAL;\n\t\tdev_dbg(hsotg->dev, \"%s: No requests in queue\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tfor (i = 0; i < MAX_DMA_DESC_NUM_HS_ISOC; i++) {\n\t\tdesc = &hs_ep->desc_list[i];\n\t\tdesc->status = 0;\n\t\tdesc->status |= (DEV_DMA_BUFF_STS_HBUSY\n\t\t\t\t    << DEV_DMA_BUFF_STS_SHIFT);\n\t}\n\n\ths_ep->next_desc = 0;\n\tlist_for_each_entry_safe(hs_req, treq, &hs_ep->queue, queue) {\n\t\tdma_addr_t dma_addr = hs_req->req.dma;\n\n\t\tif (hs_req->req.num_sgs) {\n\t\t\tWARN_ON(hs_req->req.num_sgs > 1);\n\t\t\tdma_addr = sg_dma_address(hs_req->req.sg);\n\t\t}\n\t\tret = dwc2_gadget_fill_isoc_desc(hs_ep, dma_addr,\n\t\t\t\t\t\t hs_req->req.length);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\ths_ep->compl_desc = 0;\n\tdepctl = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\n\tdma_reg = hs_ep->dir_in ? DIEPDMA(index) : DOEPDMA(index);\n\n\t \n\tdwc2_writel(hsotg, hs_ep->desc_list_dma, dma_reg);\n\n\tctrl = dwc2_readl(hsotg, depctl);\n\tctrl |= DXEPCTL_EPENA | DXEPCTL_CNAK;\n\tdwc2_writel(hsotg, ctrl, depctl);\n}\n\nstatic bool dwc2_gadget_target_frame_elapsed(struct dwc2_hsotg_ep *hs_ep);\nstatic void dwc2_hsotg_complete_request(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t       struct dwc2_hsotg_req *hs_req,\n\t\t\t\t       int result);\n\n \nstatic void dwc2_hsotg_start_req(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\tstruct dwc2_hsotg_req *hs_req,\n\t\t\t\tbool continuing)\n{\n\tstruct usb_request *ureq = &hs_req->req;\n\tint index = hs_ep->index;\n\tint dir_in = hs_ep->dir_in;\n\tu32 epctrl_reg;\n\tu32 epsize_reg;\n\tu32 epsize;\n\tu32 ctrl;\n\tunsigned int length;\n\tunsigned int packets;\n\tunsigned int maxreq;\n\tunsigned int dma_reg;\n\n\tif (index != 0) {\n\t\tif (hs_ep->req && !continuing) {\n\t\t\tdev_err(hsotg->dev, \"%s: active request\\n\", __func__);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t} else if (hs_ep->req != hs_req && continuing) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: continue different req\\n\", __func__);\n\t\t\tWARN_ON(1);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tdma_reg = dir_in ? DIEPDMA(index) : DOEPDMA(index);\n\tepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\n\tepsize_reg = dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\n\n\tdev_dbg(hsotg->dev, \"%s: DxEPCTL=0x%08x, ep %d, dir %s\\n\",\n\t\t__func__, dwc2_readl(hsotg, epctrl_reg), index,\n\t\ths_ep->dir_in ? \"in\" : \"out\");\n\n\t \n\tctrl = dwc2_readl(hsotg, epctrl_reg);\n\n\tif (index && ctrl & DXEPCTL_STALL) {\n\t\tdev_warn(hsotg->dev, \"%s: ep%d is stalled\\n\", __func__, index);\n\t\treturn;\n\t}\n\n\tlength = ureq->length - ureq->actual;\n\tdev_dbg(hsotg->dev, \"ureq->length:%d ureq->actual:%d\\n\",\n\t\tureq->length, ureq->actual);\n\n\tif (!using_desc_dma(hsotg))\n\t\tmaxreq = get_ep_limit(hs_ep);\n\telse\n\t\tmaxreq = dwc2_gadget_get_chain_limit(hs_ep);\n\n\tif (length > maxreq) {\n\t\tint round = maxreq % hs_ep->ep.maxpacket;\n\n\t\tdev_dbg(hsotg->dev, \"%s: length %d, max-req %d, r %d\\n\",\n\t\t\t__func__, length, maxreq, round);\n\n\t\t \n\t\tif (round)\n\t\t\tmaxreq -= round;\n\n\t\tlength = maxreq;\n\t}\n\n\tif (length)\n\t\tpackets = DIV_ROUND_UP(length, hs_ep->ep.maxpacket);\n\telse\n\t\tpackets = 1;\t \n\n\tif (dir_in && index != 0)\n\t\tif (hs_ep->isochronous)\n\t\t\tepsize = DXEPTSIZ_MC(packets);\n\t\telse\n\t\t\tepsize = DXEPTSIZ_MC(1);\n\telse\n\t\tepsize = 0;\n\n\t \n\tif (dir_in && ureq->zero && !continuing) {\n\t\t \n\t\tif ((ureq->length >= hs_ep->ep.maxpacket) &&\n\t\t    !(ureq->length % hs_ep->ep.maxpacket))\n\t\t\ths_ep->send_zlp = 1;\n\t}\n\n\tepsize |= DXEPTSIZ_PKTCNT(packets);\n\tepsize |= DXEPTSIZ_XFERSIZE(length);\n\n\tdev_dbg(hsotg->dev, \"%s: %d@%d/%d, 0x%08x => 0x%08x\\n\",\n\t\t__func__, packets, length, ureq->length, epsize, epsize_reg);\n\n\t \n\ths_ep->req = hs_req;\n\n\tif (using_desc_dma(hsotg)) {\n\t\tu32 offset = 0;\n\t\tu32 mps = hs_ep->ep.maxpacket;\n\n\t\t \n\t\tif (!dir_in) {\n\t\t\tif (!index)\n\t\t\t\tlength = mps;\n\t\t\telse if (length % mps)\n\t\t\t\tlength += (mps - (length % mps));\n\t\t}\n\n\t\tif (continuing)\n\t\t\toffset = ureq->actual;\n\n\t\t \n\t\tdwc2_gadget_config_nonisoc_xfer_ddma(hs_ep, ureq->dma + offset,\n\t\t\t\t\t\t     length);\n\n\t\t \n\t\tdwc2_writel(hsotg, hs_ep->desc_list_dma, dma_reg);\n\n\t\tdev_dbg(hsotg->dev, \"%s: %08x pad => 0x%08x\\n\",\n\t\t\t__func__, (u32)hs_ep->desc_list_dma, dma_reg);\n\t} else {\n\t\t \n\t\tdwc2_writel(hsotg, epsize, epsize_reg);\n\n\t\tif (using_dma(hsotg) && !continuing && (length != 0)) {\n\t\t\t \n\n\t\t\tdwc2_writel(hsotg, ureq->dma, dma_reg);\n\n\t\t\tdev_dbg(hsotg->dev, \"%s: %pad => 0x%08x\\n\",\n\t\t\t\t__func__, &ureq->dma, dma_reg);\n\t\t}\n\t}\n\n\tif (hs_ep->isochronous) {\n\t\tif (!dwc2_gadget_target_frame_elapsed(hs_ep)) {\n\t\t\tif (hs_ep->interval == 1) {\n\t\t\t\tif (hs_ep->target_frame & 0x1)\n\t\t\t\t\tctrl |= DXEPCTL_SETODDFR;\n\t\t\t\telse\n\t\t\t\t\tctrl |= DXEPCTL_SETEVENFR;\n\t\t\t}\n\t\t\tctrl |= DXEPCTL_CNAK;\n\t\t} else {\n\t\t\ths_req->req.frame_number = hs_ep->target_frame;\n\t\t\ths_req->req.actual = 0;\n\t\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, -ENODATA);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tctrl |= DXEPCTL_EPENA;\t \n\n\tdev_dbg(hsotg->dev, \"ep0 state:%d\\n\", hsotg->ep0_state);\n\n\t \n\tif (!(index == 0 && hsotg->ep0_state == DWC2_EP0_SETUP))\n\t\tctrl |= DXEPCTL_CNAK;\t \n\n\tdev_dbg(hsotg->dev, \"%s: DxEPCTL=0x%08x\\n\", __func__, ctrl);\n\tdwc2_writel(hsotg, ctrl, epctrl_reg);\n\n\t \n\ths_ep->size_loaded = length;\n\ths_ep->last_load = ureq->actual;\n\n\tif (dir_in && !using_dma(hsotg)) {\n\t\t \n\t\ths_ep->fifo_load = 0;\n\n\t\tdwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);\n\t}\n\n\t \n\n\t \n\tif (!(dwc2_readl(hsotg, epctrl_reg) & DXEPCTL_EPENA))\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"ep%d: failed to become enabled (DXEPCTL=0x%08x)?\\n\",\n\t\t\t index, dwc2_readl(hsotg, epctrl_reg));\n\n\tdev_dbg(hsotg->dev, \"%s: DXEPCTL=0x%08x\\n\",\n\t\t__func__, dwc2_readl(hsotg, epctrl_reg));\n\n\t \n\tdwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 1);\n}\n\n \nstatic int dwc2_hsotg_map_dma(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_hsotg_ep *hs_ep,\n\t\t\t     struct usb_request *req)\n{\n\tint ret;\n\n\ths_ep->map_dir = hs_ep->dir_in;\n\tret = usb_gadget_map_request(&hsotg->gadget, req, hs_ep->dir_in);\n\tif (ret)\n\t\tgoto dma_error;\n\n\treturn 0;\n\ndma_error:\n\tdev_err(hsotg->dev, \"%s: failed to map buffer %p, %d bytes\\n\",\n\t\t__func__, req->buf, req->length);\n\n\treturn -EIO;\n}\n\nstatic int dwc2_hsotg_handle_unaligned_buf_start(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t\t struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t\t\t struct dwc2_hsotg_req *hs_req)\n{\n\tvoid *req_buf = hs_req->req.buf;\n\n\t \n\tif (!using_dma(hsotg) || !((long)req_buf & 3))\n\t\treturn 0;\n\n\tWARN_ON(hs_req->saved_req_buf);\n\n\tdev_dbg(hsotg->dev, \"%s: %s: buf=%p length=%d\\n\", __func__,\n\t\ths_ep->ep.name, req_buf, hs_req->req.length);\n\n\ths_req->req.buf = kmalloc(hs_req->req.length, GFP_ATOMIC);\n\tif (!hs_req->req.buf) {\n\t\ths_req->req.buf = req_buf;\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: unable to allocate memory for bounce buffer\\n\",\n\t\t\t__func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\ths_req->saved_req_buf = req_buf;\n\n\tif (hs_ep->dir_in)\n\t\tmemcpy(hs_req->req.buf, req_buf, hs_req->req.length);\n\treturn 0;\n}\n\nstatic void\ndwc2_hsotg_handle_unaligned_buf_complete(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t\t struct dwc2_hsotg_req *hs_req)\n{\n\t \n\tif (!using_dma(hsotg) || !hs_req->saved_req_buf)\n\t\treturn;\n\n\tdev_dbg(hsotg->dev, \"%s: %s: status=%d actual-length=%d\\n\", __func__,\n\t\ths_ep->ep.name, hs_req->req.status, hs_req->req.actual);\n\n\t \n\tif (!hs_ep->dir_in && !hs_req->req.status)\n\t\tmemcpy(hs_req->saved_req_buf, hs_req->req.buf,\n\t\t       hs_req->req.actual);\n\n\t \n\tkfree(hs_req->req.buf);\n\n\ths_req->req.buf = hs_req->saved_req_buf;\n\ths_req->saved_req_buf = NULL;\n}\n\n \nstatic bool dwc2_gadget_target_frame_elapsed(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tu32 target_frame = hs_ep->target_frame;\n\tu32 current_frame = hsotg->frame_number;\n\tbool frame_overrun = hs_ep->frame_overrun;\n\tu16 limit = DSTS_SOFFN_LIMIT;\n\n\tif (hsotg->gadget.speed != USB_SPEED_HIGH)\n\t\tlimit >>= 3;\n\n\tif (!frame_overrun && current_frame >= target_frame)\n\t\treturn true;\n\n\tif (frame_overrun && current_frame >= target_frame &&\n\t    ((current_frame - target_frame) < limit / 2))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int dwc2_gadget_set_ep0_desc_chain(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t  struct dwc2_hsotg_ep *hs_ep)\n{\n\tswitch (hsotg->ep0_state) {\n\tcase DWC2_EP0_SETUP:\n\tcase DWC2_EP0_STATUS_OUT:\n\t\ths_ep->desc_list = hsotg->setup_desc[0];\n\t\ths_ep->desc_list_dma = hsotg->setup_desc_dma[0];\n\t\tbreak;\n\tcase DWC2_EP0_DATA_IN:\n\tcase DWC2_EP0_STATUS_IN:\n\t\ths_ep->desc_list = hsotg->ctrl_in_desc;\n\t\ths_ep->desc_list_dma = hsotg->ctrl_in_desc_dma;\n\t\tbreak;\n\tcase DWC2_EP0_DATA_OUT:\n\t\ths_ep->desc_list = hsotg->ctrl_out_desc;\n\t\ths_ep->desc_list_dma = hsotg->ctrl_out_desc_dma;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev, \"invalid EP 0 state in queue %d\\n\",\n\t\t\thsotg->ep0_state);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int dwc2_hsotg_ep_queue(struct usb_ep *ep, struct usb_request *req,\n\t\t\t       gfp_t gfp_flags)\n{\n\tstruct dwc2_hsotg_req *hs_req = our_req(req);\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\tbool first;\n\tint ret;\n\tu32 maxsize = 0;\n\tu32 mask = 0;\n\n\n\tdev_dbg(hs->dev, \"%s: req %p: %d@%p, noi=%d, zero=%d, snok=%d\\n\",\n\t\tep->name, req, req->length, req->buf, req->no_interrupt,\n\t\treq->zero, req->short_not_ok);\n\n\t \n\tif (hs->lx_state != DWC2_L0) {\n\t\tdev_dbg(hs->dev, \"%s: submit request only in active state\\n\",\n\t\t\t__func__);\n\t\treturn -EAGAIN;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&hs_req->queue);\n\treq->actual = 0;\n\treq->status = -EINPROGRESS;\n\n\t \n\tif (hs_ep->isochronous &&\n\t    req->length > (hs_ep->mc * hs_ep->ep.maxpacket)) {\n\t\tdev_err(hs->dev, \"req length > maxpacket*mc\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (using_desc_dma(hs) && hs_ep->isochronous) {\n\t\tmaxsize = dwc2_gadget_get_desc_params(hs_ep, &mask);\n\t\tif (hs_ep->dir_in && req->length > maxsize) {\n\t\t\tdev_err(hs->dev, \"wrong length %d (maxsize=%d)\\n\",\n\t\t\t\treq->length, maxsize);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (!hs_ep->dir_in && req->length > hs_ep->ep.maxpacket) {\n\t\t\tdev_err(hs->dev, \"ISOC OUT: wrong length %d (mps=%d)\\n\",\n\t\t\t\treq->length, hs_ep->ep.maxpacket);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tret = dwc2_hsotg_handle_unaligned_buf_start(hs, hs_ep, hs_req);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (using_dma(hs)) {\n\t\tret = dwc2_hsotg_map_dma(hs, hs_ep, req);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\t \n\tif (using_desc_dma(hs) && !hs_ep->index) {\n\t\tret = dwc2_gadget_set_ep0_desc_chain(hs, hs_ep);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tfirst = list_empty(&hs_ep->queue);\n\tlist_add_tail(&hs_req->queue, &hs_ep->queue);\n\n\t \n\tif (using_desc_dma(hs) && hs_ep->isochronous) {\n\t\tif (hs_ep->target_frame != TARGET_FRAME_INITIAL) {\n\t\t\tdma_addr_t dma_addr = hs_req->req.dma;\n\n\t\t\tif (hs_req->req.num_sgs) {\n\t\t\t\tWARN_ON(hs_req->req.num_sgs > 1);\n\t\t\t\tdma_addr = sg_dma_address(hs_req->req.sg);\n\t\t\t}\n\t\t\tdwc2_gadget_fill_isoc_desc(hs_ep, dma_addr,\n\t\t\t\t\t\t   hs_req->req.length);\n\t\t}\n\t\treturn 0;\n\t}\n\n\t \n\tif (!hs_ep->index && !req->length && !hs_ep->dir_in &&\n\t    hs->ep0_state == DWC2_EP0_DATA_OUT)\n\t\ths_ep->dir_in = 1;\n\n\tif (first) {\n\t\tif (!hs_ep->isochronous) {\n\t\t\tdwc2_hsotg_start_req(hs, hs_ep, hs_req, false);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\ths->frame_number = dwc2_hsotg_read_frameno(hs);\n\t\twhile (dwc2_gadget_target_frame_elapsed(hs_ep)) {\n\t\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t\t\t \n\t\t\ths->frame_number = dwc2_hsotg_read_frameno(hs);\n\t\t}\n\n\t\tif (hs_ep->target_frame != TARGET_FRAME_INITIAL)\n\t\t\tdwc2_hsotg_start_req(hs, hs_ep, hs_req, false);\n\t}\n\treturn 0;\n}\n\nstatic int dwc2_hsotg_ep_queue_lock(struct usb_ep *ep, struct usb_request *req,\n\t\t\t\t    gfp_t gfp_flags)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&hs->lock, flags);\n\tret = dwc2_hsotg_ep_queue(ep, req, gfp_flags);\n\tspin_unlock_irqrestore(&hs->lock, flags);\n\n\treturn ret;\n}\n\nstatic void dwc2_hsotg_ep_free_request(struct usb_ep *ep,\n\t\t\t\t       struct usb_request *req)\n{\n\tstruct dwc2_hsotg_req *hs_req = our_req(req);\n\n\tkfree(hs_req);\n}\n\n \nstatic void dwc2_hsotg_complete_oursetup(struct usb_ep *ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\n\tdev_dbg(hsotg->dev, \"%s: ep %p, req %p\\n\", __func__, ep, req);\n\n\tdwc2_hsotg_ep_free_request(ep, req);\n}\n\n \nstatic struct dwc2_hsotg_ep *ep_from_windex(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t    u32 windex)\n{\n\tint dir = (windex & USB_DIR_IN) ? 1 : 0;\n\tint idx = windex & 0x7F;\n\n\tif (windex >= 0x100)\n\t\treturn NULL;\n\n\tif (idx > hsotg->num_of_eps)\n\t\treturn NULL;\n\n\treturn index_to_ep(hsotg, idx, dir);\n}\n\n \nint dwc2_hsotg_set_test_mode(struct dwc2_hsotg *hsotg, int testmode)\n{\n\tint dctl = dwc2_readl(hsotg, DCTL);\n\n\tdctl &= ~DCTL_TSTCTL_MASK;\n\tswitch (testmode) {\n\tcase USB_TEST_J:\n\tcase USB_TEST_K:\n\tcase USB_TEST_SE0_NAK:\n\tcase USB_TEST_PACKET:\n\tcase USB_TEST_FORCE_ENABLE:\n\t\tdctl |= testmode << DCTL_TSTCTL_SHIFT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\tdwc2_writel(hsotg, dctl, DCTL);\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_send_reply(struct dwc2_hsotg *hsotg,\n\t\t\t\t struct dwc2_hsotg_ep *ep,\n\t\t\t\tvoid *buff,\n\t\t\t\tint length)\n{\n\tstruct usb_request *req;\n\tint ret;\n\n\tdev_dbg(hsotg->dev, \"%s: buff %p, len %d\\n\", __func__, buff, length);\n\n\treq = dwc2_hsotg_ep_alloc_request(&ep->ep, GFP_ATOMIC);\n\thsotg->ep0_reply = req;\n\tif (!req) {\n\t\tdev_warn(hsotg->dev, \"%s: cannot alloc req\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\treq->buf = hsotg->ep0_buff;\n\treq->length = length;\n\t \n\treq->zero = 0;\n\treq->complete = dwc2_hsotg_complete_oursetup;\n\n\tif (length)\n\t\tmemcpy(req->buf, buff, length);\n\n\tret = dwc2_hsotg_ep_queue(&ep->ep, req, GFP_ATOMIC);\n\tif (ret) {\n\t\tdev_warn(hsotg->dev, \"%s: cannot queue req\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_process_req_status(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t struct usb_ctrlrequest *ctrl)\n{\n\tstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\n\tstruct dwc2_hsotg_ep *ep;\n\t__le16 reply;\n\tu16 status;\n\tint ret;\n\n\tdev_dbg(hsotg->dev, \"%s: USB_REQ_GET_STATUS\\n\", __func__);\n\n\tif (!ep0->dir_in) {\n\t\tdev_warn(hsotg->dev, \"%s: direction out?\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ctrl->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tstatus = hsotg->gadget.is_selfpowered <<\n\t\t\t USB_DEVICE_SELF_POWERED;\n\t\tstatus |= hsotg->remote_wakeup_allowed <<\n\t\t\t  USB_DEVICE_REMOTE_WAKEUP;\n\t\treply = cpu_to_le16(status);\n\t\tbreak;\n\n\tcase USB_RECIP_INTERFACE:\n\t\t \n\t\treply = cpu_to_le16(0);\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = ep_from_windex(hsotg, le16_to_cpu(ctrl->wIndex));\n\t\tif (!ep)\n\t\t\treturn -ENOENT;\n\n\t\treply = cpu_to_le16(ep->halted ? 1 : 0);\n\t\tbreak;\n\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(ctrl->wLength) != 2)\n\t\treturn -EINVAL;\n\n\tret = dwc2_hsotg_send_reply(hsotg, ep0, &reply, 2);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to send reply\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\nstatic int dwc2_hsotg_ep_sethalt(struct usb_ep *ep, int value, bool now);\n\n \nstatic struct dwc2_hsotg_req *get_ep_head(struct dwc2_hsotg_ep *hs_ep)\n{\n\treturn list_first_entry_or_null(&hs_ep->queue, struct dwc2_hsotg_req,\n\t\t\t\t\tqueue);\n}\n\n \nstatic void dwc2_gadget_start_next_request(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tint dir_in = hs_ep->dir_in;\n\tstruct dwc2_hsotg_req *hs_req;\n\n\tif (!list_empty(&hs_ep->queue)) {\n\t\ths_req = get_ep_head(hs_ep);\n\t\tdwc2_hsotg_start_req(hsotg, hs_ep, hs_req, false);\n\t\treturn;\n\t}\n\tif (!hs_ep->isochronous)\n\t\treturn;\n\n\tif (dir_in) {\n\t\tdev_dbg(hsotg->dev, \"%s: No more ISOC-IN requests\\n\",\n\t\t\t__func__);\n\t} else {\n\t\tdev_dbg(hsotg->dev, \"%s: No more ISOC-OUT requests\\n\",\n\t\t\t__func__);\n\t}\n}\n\n \nstatic int dwc2_hsotg_process_req_feature(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t  struct usb_ctrlrequest *ctrl)\n{\n\tstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\n\tstruct dwc2_hsotg_req *hs_req;\n\tbool set = (ctrl->bRequest == USB_REQ_SET_FEATURE);\n\tstruct dwc2_hsotg_ep *ep;\n\tint ret;\n\tbool halted;\n\tu32 recip;\n\tu32 wValue;\n\tu32 wIndex;\n\n\tdev_dbg(hsotg->dev, \"%s: %s_FEATURE\\n\",\n\t\t__func__, set ? \"SET\" : \"CLEAR\");\n\n\twValue = le16_to_cpu(ctrl->wValue);\n\twIndex = le16_to_cpu(ctrl->wIndex);\n\trecip = ctrl->bRequestType & USB_RECIP_MASK;\n\n\tswitch (recip) {\n\tcase USB_RECIP_DEVICE:\n\t\tswitch (wValue) {\n\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\tif (set)\n\t\t\t\thsotg->remote_wakeup_allowed = 1;\n\t\t\telse\n\t\t\t\thsotg->remote_wakeup_allowed = 0;\n\t\t\tbreak;\n\n\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\tif ((wIndex & 0xff) != 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!set)\n\t\t\t\treturn -EINVAL;\n\n\t\t\thsotg->test_mode = wIndex >> 8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\n\t\tif (ret) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: failed to send reply\\n\", __func__);\n\t\t\treturn ret;\n\t\t}\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tep = ep_from_windex(hsotg, wIndex);\n\t\tif (!ep) {\n\t\t\tdev_dbg(hsotg->dev, \"%s: no endpoint for 0x%04x\\n\",\n\t\t\t\t__func__, wIndex);\n\t\t\treturn -ENOENT;\n\t\t}\n\n\t\tswitch (wValue) {\n\t\tcase USB_ENDPOINT_HALT:\n\t\t\thalted = ep->halted;\n\n\t\t\tif (!ep->wedged)\n\t\t\t\tdwc2_hsotg_ep_sethalt(&ep->ep, set, true);\n\n\t\t\tret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"%s: failed to send reply\\n\", __func__);\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t \n\n\t\t\tif (!set && halted) {\n\t\t\t\t \n\t\t\t\tif (ep->req) {\n\t\t\t\t\ths_req = ep->req;\n\t\t\t\t\tep->req = NULL;\n\t\t\t\t\tlist_del_init(&hs_req->queue);\n\t\t\t\t\tif (hs_req->req.complete) {\n\t\t\t\t\t\tspin_unlock(&hsotg->lock);\n\t\t\t\t\t\tusb_gadget_giveback_request(\n\t\t\t\t\t\t\t&ep->ep, &hs_req->req);\n\t\t\t\t\t\tspin_lock(&hsotg->lock);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tif (!ep->req)\n\t\t\t\t\tdwc2_gadget_start_next_request(ep);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -ENOENT;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOENT;\n\t}\n\treturn 1;\n}\n\nstatic void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg);\n\n \nstatic void dwc2_hsotg_stall_ep0(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\n\tu32 reg;\n\tu32 ctrl;\n\n\tdev_dbg(hsotg->dev, \"ep0 stall (dir=%d)\\n\", ep0->dir_in);\n\treg = (ep0->dir_in) ? DIEPCTL0 : DOEPCTL0;\n\n\t \n\n\tctrl = dwc2_readl(hsotg, reg);\n\tctrl |= DXEPCTL_STALL;\n\tctrl |= DXEPCTL_CNAK;\n\tdwc2_writel(hsotg, ctrl, reg);\n\n\tdev_dbg(hsotg->dev,\n\t\t\"written DXEPCTL=0x%08x to %08x (DXEPCTL=0x%08x)\\n\",\n\t\tctrl, reg, dwc2_readl(hsotg, reg));\n\n\t  \n\t dwc2_hsotg_enqueue_setup(hsotg);\n}\n\n \nstatic void dwc2_hsotg_process_control(struct dwc2_hsotg *hsotg,\n\t\t\t\t       struct usb_ctrlrequest *ctrl)\n{\n\tstruct dwc2_hsotg_ep *ep0 = hsotg->eps_out[0];\n\tint ret = 0;\n\tu32 dcfg;\n\n\tdev_dbg(hsotg->dev,\n\t\t\"ctrl Type=%02x, Req=%02x, V=%04x, I=%04x, L=%04x\\n\",\n\t\tctrl->bRequestType, ctrl->bRequest, ctrl->wValue,\n\t\tctrl->wIndex, ctrl->wLength);\n\n\tif (ctrl->wLength == 0) {\n\t\tep0->dir_in = 1;\n\t\thsotg->ep0_state = DWC2_EP0_STATUS_IN;\n\t} else if (ctrl->bRequestType & USB_DIR_IN) {\n\t\tep0->dir_in = 1;\n\t\thsotg->ep0_state = DWC2_EP0_DATA_IN;\n\t} else {\n\t\tep0->dir_in = 0;\n\t\thsotg->ep0_state = DWC2_EP0_DATA_OUT;\n\t}\n\n\tif ((ctrl->bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD) {\n\t\tswitch (ctrl->bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\thsotg->connected = 1;\n\t\t\tdcfg = dwc2_readl(hsotg, DCFG);\n\t\t\tdcfg &= ~DCFG_DEVADDR_MASK;\n\t\t\tdcfg |= (le16_to_cpu(ctrl->wValue) <<\n\t\t\t\t DCFG_DEVADDR_SHIFT) & DCFG_DEVADDR_MASK;\n\t\t\tdwc2_writel(hsotg, dcfg, DCFG);\n\n\t\t\tdev_info(hsotg->dev, \"new address %d\\n\", ctrl->wValue);\n\n\t\t\tret = dwc2_hsotg_send_reply(hsotg, ep0, NULL, 0);\n\t\t\treturn;\n\n\t\tcase USB_REQ_GET_STATUS:\n\t\t\tret = dwc2_hsotg_process_req_status(hsotg, ctrl);\n\t\t\tbreak;\n\n\t\tcase USB_REQ_CLEAR_FEATURE:\n\t\tcase USB_REQ_SET_FEATURE:\n\t\t\tret = dwc2_hsotg_process_req_feature(hsotg, ctrl);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\n\tif (ret == 0 && hsotg->driver) {\n\t\tspin_unlock(&hsotg->lock);\n\t\tret = hsotg->driver->setup(&hsotg->gadget, ctrl);\n\t\tspin_lock(&hsotg->lock);\n\t\tif (ret < 0)\n\t\t\tdev_dbg(hsotg->dev, \"driver->setup() ret %d\\n\", ret);\n\t}\n\n\thsotg->delayed_status = false;\n\tif (ret == USB_GADGET_DELAYED_STATUS)\n\t\thsotg->delayed_status = true;\n\n\t \n\n\tif (ret < 0)\n\t\tdwc2_hsotg_stall_ep0(hsotg);\n}\n\n \nstatic void dwc2_hsotg_complete_setup(struct usb_ep *ep,\n\t\t\t\t      struct usb_request *req)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\n\tif (req->status < 0) {\n\t\tdev_dbg(hsotg->dev, \"%s: failed %d\\n\", __func__, req->status);\n\t\treturn;\n\t}\n\n\tspin_lock(&hsotg->lock);\n\tif (req->actual == 0)\n\t\tdwc2_hsotg_enqueue_setup(hsotg);\n\telse\n\t\tdwc2_hsotg_process_control(hsotg, req->buf);\n\tspin_unlock(&hsotg->lock);\n}\n\n \nstatic void dwc2_hsotg_enqueue_setup(struct dwc2_hsotg *hsotg)\n{\n\tstruct usb_request *req = hsotg->ctrl_req;\n\tstruct dwc2_hsotg_req *hs_req = our_req(req);\n\tint ret;\n\n\tdev_dbg(hsotg->dev, \"%s: queueing setup request\\n\", __func__);\n\n\treq->zero = 0;\n\treq->length = 8;\n\treq->buf = hsotg->ctrl_buff;\n\treq->complete = dwc2_hsotg_complete_setup;\n\n\tif (!list_empty(&hs_req->queue)) {\n\t\tdev_dbg(hsotg->dev, \"%s already queued???\\n\", __func__);\n\t\treturn;\n\t}\n\n\thsotg->eps_out[0]->dir_in = 0;\n\thsotg->eps_out[0]->send_zlp = 0;\n\thsotg->ep0_state = DWC2_EP0_SETUP;\n\n\tret = dwc2_hsotg_ep_queue(&hsotg->eps_out[0]->ep, req, GFP_ATOMIC);\n\tif (ret < 0) {\n\t\tdev_err(hsotg->dev, \"%s: failed queue (%d)\\n\", __func__, ret);\n\t\t \n\t}\n}\n\nstatic void dwc2_hsotg_program_zlp(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hsotg_ep *hs_ep)\n{\n\tu32 ctrl;\n\tu8 index = hs_ep->index;\n\tu32 epctl_reg = hs_ep->dir_in ? DIEPCTL(index) : DOEPCTL(index);\n\tu32 epsiz_reg = hs_ep->dir_in ? DIEPTSIZ(index) : DOEPTSIZ(index);\n\n\tif (hs_ep->dir_in)\n\t\tdev_dbg(hsotg->dev, \"Sending zero-length packet on ep%d\\n\",\n\t\t\tindex);\n\telse\n\t\tdev_dbg(hsotg->dev, \"Receiving zero-length packet on ep%d\\n\",\n\t\t\tindex);\n\tif (using_desc_dma(hsotg)) {\n\t\t \n\t\tdma_addr_t dma = hs_ep->desc_list_dma;\n\n\t\tif (!index)\n\t\t\tdwc2_gadget_set_ep0_desc_chain(hsotg, hs_ep);\n\n\t\tdwc2_gadget_config_nonisoc_xfer_ddma(hs_ep, dma, 0);\n\t} else {\n\t\tdwc2_writel(hsotg, DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\n\t\t\t    DXEPTSIZ_XFERSIZE(0),\n\t\t\t    epsiz_reg);\n\t}\n\n\tctrl = dwc2_readl(hsotg, epctl_reg);\n\tctrl |= DXEPCTL_CNAK;   \n\tctrl |= DXEPCTL_EPENA;  \n\tctrl |= DXEPCTL_USBACTEP;\n\tdwc2_writel(hsotg, ctrl, epctl_reg);\n}\n\n \nstatic void dwc2_hsotg_complete_request(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tstruct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t       struct dwc2_hsotg_req *hs_req,\n\t\t\t\t       int result)\n{\n\tif (!hs_req) {\n\t\tdev_dbg(hsotg->dev, \"%s: nothing to complete?\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdev_dbg(hsotg->dev, \"complete: ep %p %s, req %p, %d => %p\\n\",\n\t\ths_ep, hs_ep->ep.name, hs_req, result, hs_req->req.complete);\n\n\t \n\n\tif (hs_req->req.status == -EINPROGRESS)\n\t\ths_req->req.status = result;\n\n\tif (using_dma(hsotg))\n\t\tdwc2_hsotg_unmap_dma(hsotg, hs_ep, hs_req);\n\n\tdwc2_hsotg_handle_unaligned_buf_complete(hsotg, hs_ep, hs_req);\n\n\ths_ep->req = NULL;\n\tlist_del_init(&hs_req->queue);\n\n\t \n\n\tif (hs_req->req.complete) {\n\t\tspin_unlock(&hsotg->lock);\n\t\tusb_gadget_giveback_request(&hs_ep->ep, &hs_req->req);\n\t\tspin_lock(&hsotg->lock);\n\t}\n\n\t \n\tif (using_desc_dma(hsotg) && hs_ep->isochronous)\n\t\treturn;\n\n\t \n\n\tif (!hs_ep->req && result >= 0)\n\t\tdwc2_gadget_start_next_request(hs_ep);\n}\n\n \nstatic void dwc2_gadget_complete_isoc_request_ddma(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tstruct dwc2_hsotg_req *hs_req;\n\tstruct usb_request *ureq;\n\tu32 desc_sts;\n\tu32 mask;\n\n\tdesc_sts = hs_ep->desc_list[hs_ep->compl_desc].status;\n\n\t \n\twhile ((desc_sts & DEV_DMA_BUFF_STS_MASK) >>\n\t\tDEV_DMA_BUFF_STS_SHIFT == DEV_DMA_BUFF_STS_DMADONE) {\n\n\t\ths_req = get_ep_head(hs_ep);\n\t\tif (!hs_req) {\n\t\t\tdev_warn(hsotg->dev, \"%s: ISOC EP queue empty\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\t\tureq = &hs_req->req;\n\n\t\t \n\t\tif ((desc_sts & DEV_DMA_STS_MASK) >> DEV_DMA_STS_SHIFT ==\n\t\t\tDEV_DMA_STS_SUCC) {\n\t\t\tmask = hs_ep->dir_in ? DEV_DMA_ISOC_TX_NBYTES_MASK :\n\t\t\t\tDEV_DMA_ISOC_RX_NBYTES_MASK;\n\t\t\tureq->actual = ureq->length - ((desc_sts & mask) >>\n\t\t\t\tDEV_DMA_ISOC_NBYTES_SHIFT);\n\n\t\t\t \n\t\t\tif (!hs_ep->dir_in && ureq->length & 0x3)\n\t\t\t\tureq->actual += 4 - (ureq->length & 0x3);\n\n\t\t\t \n\t\t\tureq->frame_number =\n\t\t\t\t(desc_sts & DEV_DMA_ISOC_FRNUM_MASK) >>\n\t\t\t\tDEV_DMA_ISOC_FRNUM_SHIFT;\n\t\t}\n\n\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\n\n\t\ths_ep->compl_desc++;\n\t\tif (hs_ep->compl_desc > (MAX_DMA_DESC_NUM_HS_ISOC - 1))\n\t\t\ths_ep->compl_desc = 0;\n\t\tdesc_sts = hs_ep->desc_list[hs_ep->compl_desc].status;\n\t}\n}\n\n \nstatic void dwc2_gadget_handle_isoc_bna(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\n\tif (!hs_ep->dir_in)\n\t\tdwc2_flush_rx_fifo(hsotg);\n\tdwc2_hsotg_complete_request(hsotg, hs_ep, get_ep_head(hs_ep), 0);\n\n\ths_ep->target_frame = TARGET_FRAME_INITIAL;\n\ths_ep->next_desc = 0;\n\ths_ep->compl_desc = 0;\n}\n\n \nstatic void dwc2_hsotg_rx_data(struct dwc2_hsotg *hsotg, int ep_idx, int size)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[ep_idx];\n\tstruct dwc2_hsotg_req *hs_req = hs_ep->req;\n\tint to_read;\n\tint max_req;\n\tint read_ptr;\n\n\tif (!hs_req) {\n\t\tu32 epctl = dwc2_readl(hsotg, DOEPCTL(ep_idx));\n\t\tint ptr;\n\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: FIFO %d bytes on ep%d but no req (DXEPCTl=0x%08x)\\n\",\n\t\t\t __func__, size, ep_idx, epctl);\n\n\t\t \n\t\tfor (ptr = 0; ptr < size; ptr += 4)\n\t\t\t(void)dwc2_readl(hsotg, EPFIFO(ep_idx));\n\n\t\treturn;\n\t}\n\n\tto_read = size;\n\tread_ptr = hs_req->req.actual;\n\tmax_req = hs_req->req.length - read_ptr;\n\n\tdev_dbg(hsotg->dev, \"%s: read %d/%d, done %d/%d\\n\",\n\t\t__func__, to_read, max_req, read_ptr, hs_req->req.length);\n\n\tif (to_read > max_req) {\n\t\t \n\n\t\t \n\t\tWARN_ON_ONCE(1);\n\t}\n\n\ths_ep->total_data += to_read;\n\ths_req->req.actual += to_read;\n\tto_read = DIV_ROUND_UP(to_read, 4);\n\n\t \n\tdwc2_readl_rep(hsotg, EPFIFO(ep_idx),\n\t\t       hs_req->req.buf + read_ptr, to_read);\n}\n\n \nstatic void dwc2_hsotg_ep0_zlp(struct dwc2_hsotg *hsotg, bool dir_in)\n{\n\t \n\thsotg->eps_out[0]->dir_in = dir_in;\n\thsotg->ep0_state = dir_in ? DWC2_EP0_STATUS_IN : DWC2_EP0_STATUS_OUT;\n\n\tdwc2_hsotg_program_zlp(hsotg, hsotg->eps_out[0]);\n}\n\n \nstatic unsigned int dwc2_gadget_get_xfersize_ddma(struct dwc2_hsotg_ep *hs_ep)\n{\n\tconst struct usb_endpoint_descriptor *ep_desc = hs_ep->ep.desc;\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tunsigned int bytes_rem = 0;\n\tunsigned int bytes_rem_correction = 0;\n\tstruct dwc2_dma_desc *desc = hs_ep->desc_list;\n\tint i;\n\tu32 status;\n\tu32 mps = hs_ep->ep.maxpacket;\n\tint dir_in = hs_ep->dir_in;\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t \n\tif (hs_ep->index)\n\t\tif (usb_endpoint_xfer_int(ep_desc) && !dir_in && (mps % 4))\n\t\t\tbytes_rem_correction = 4 - (mps % 4);\n\n\tfor (i = 0; i < hs_ep->desc_count; ++i) {\n\t\tstatus = desc->status;\n\t\tbytes_rem += status & DEV_DMA_NBYTES_MASK;\n\t\tbytes_rem -= bytes_rem_correction;\n\n\t\tif (status & DEV_DMA_STS_MASK)\n\t\t\tdev_err(hsotg->dev, \"descriptor %d closed with %x\\n\",\n\t\t\t\ti, status & DEV_DMA_STS_MASK);\n\n\t\tif (status & DEV_DMA_L)\n\t\t\tbreak;\n\n\t\tdesc++;\n\t}\n\n\treturn bytes_rem;\n}\n\n \nstatic void dwc2_hsotg_handle_outdone(struct dwc2_hsotg *hsotg, int epnum)\n{\n\tu32 epsize = dwc2_readl(hsotg, DOEPTSIZ(epnum));\n\tstruct dwc2_hsotg_ep *hs_ep = hsotg->eps_out[epnum];\n\tstruct dwc2_hsotg_req *hs_req = hs_ep->req;\n\tstruct usb_request *req = &hs_req->req;\n\tunsigned int size_left = DXEPTSIZ_XFERSIZE_GET(epsize);\n\tint result = 0;\n\n\tif (!hs_req) {\n\t\tdev_dbg(hsotg->dev, \"%s: no request active\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (epnum == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_OUT) {\n\t\tdev_dbg(hsotg->dev, \"zlp packet received\\n\");\n\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\n\t\tdwc2_hsotg_enqueue_setup(hsotg);\n\t\treturn;\n\t}\n\n\tif (using_desc_dma(hsotg))\n\t\tsize_left = dwc2_gadget_get_xfersize_ddma(hs_ep);\n\n\tif (using_dma(hsotg)) {\n\t\tunsigned int size_done;\n\n\t\t \n\n\t\tsize_done = hs_ep->size_loaded - size_left;\n\t\tsize_done += hs_ep->last_load;\n\n\t\treq->actual = size_done;\n\t}\n\n\t \n\tif (req->actual < req->length && size_left == 0) {\n\t\tdwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);\n\t\treturn;\n\t}\n\n\tif (req->actual < req->length && req->short_not_ok) {\n\t\tdev_dbg(hsotg->dev, \"%s: got %d/%d (short not ok) => error\\n\",\n\t\t\t__func__, req->actual, req->length);\n\n\t\t \n\t}\n\n\t \n\tif (!using_desc_dma(hsotg) && epnum == 0 &&\n\t    hsotg->ep0_state == DWC2_EP0_DATA_OUT) {\n\t\t \n\t\tif (!hsotg->delayed_status)\n\t\t\tdwc2_hsotg_ep0_zlp(hsotg, true);\n\t}\n\n\t \n\tif (!using_desc_dma(hsotg) && hs_ep->isochronous) {\n\t\treq->frame_number = hs_ep->target_frame;\n\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t}\n\n\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, result);\n}\n\n \nstatic void dwc2_hsotg_handle_rx(struct dwc2_hsotg *hsotg)\n{\n\tu32 grxstsr = dwc2_readl(hsotg, GRXSTSP);\n\tu32 epnum, status, size;\n\n\tWARN_ON(using_dma(hsotg));\n\n\tepnum = grxstsr & GRXSTS_EPNUM_MASK;\n\tstatus = grxstsr & GRXSTS_PKTSTS_MASK;\n\n\tsize = grxstsr & GRXSTS_BYTECNT_MASK;\n\tsize >>= GRXSTS_BYTECNT_SHIFT;\n\n\tdev_dbg(hsotg->dev, \"%s: GRXSTSP=0x%08x (%d@%d)\\n\",\n\t\t__func__, grxstsr, size, epnum);\n\n\tswitch ((status & GRXSTS_PKTSTS_MASK) >> GRXSTS_PKTSTS_SHIFT) {\n\tcase GRXSTS_PKTSTS_GLOBALOUTNAK:\n\t\tdev_dbg(hsotg->dev, \"GLOBALOUTNAK\\n\");\n\t\tbreak;\n\n\tcase GRXSTS_PKTSTS_OUTDONE:\n\t\tdev_dbg(hsotg->dev, \"OutDone (Frame=0x%08x)\\n\",\n\t\t\tdwc2_hsotg_read_frameno(hsotg));\n\n\t\tif (!using_dma(hsotg))\n\t\t\tdwc2_hsotg_handle_outdone(hsotg, epnum);\n\t\tbreak;\n\n\tcase GRXSTS_PKTSTS_SETUPDONE:\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"SetupDone (Frame=0x%08x, DOPEPCTL=0x%08x)\\n\",\n\t\t\tdwc2_hsotg_read_frameno(hsotg),\n\t\t\tdwc2_readl(hsotg, DOEPCTL(0)));\n\t\t \n\t\tif (hsotg->ep0_state == DWC2_EP0_SETUP)\n\t\t\tdwc2_hsotg_handle_outdone(hsotg, epnum);\n\t\tbreak;\n\n\tcase GRXSTS_PKTSTS_OUTRX:\n\t\tdwc2_hsotg_rx_data(hsotg, epnum, size);\n\t\tbreak;\n\n\tcase GRXSTS_PKTSTS_SETUPRX:\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"SetupRX (Frame=0x%08x, DOPEPCTL=0x%08x)\\n\",\n\t\t\tdwc2_hsotg_read_frameno(hsotg),\n\t\t\tdwc2_readl(hsotg, DOEPCTL(0)));\n\n\t\tWARN_ON(hsotg->ep0_state != DWC2_EP0_SETUP);\n\n\t\tdwc2_hsotg_rx_data(hsotg, epnum, size);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(hsotg->dev, \"%s: unknown status %08x\\n\",\n\t\t\t __func__, grxstsr);\n\n\t\tdwc2_hsotg_dump(hsotg);\n\t\tbreak;\n\t}\n}\n\n \nstatic u32 dwc2_hsotg_ep0_mps(unsigned int mps)\n{\n\tswitch (mps) {\n\tcase 64:\n\t\treturn D0EPCTL_MPS_64;\n\tcase 32:\n\t\treturn D0EPCTL_MPS_32;\n\tcase 16:\n\t\treturn D0EPCTL_MPS_16;\n\tcase 8:\n\t\treturn D0EPCTL_MPS_8;\n\t}\n\n\t \n\tWARN_ON(1);\n\treturn (u32)-1;\n}\n\n \nstatic void dwc2_hsotg_set_ep_maxpacket(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tunsigned int ep, unsigned int mps,\n\t\t\t\t\tunsigned int mc, unsigned int dir_in)\n{\n\tstruct dwc2_hsotg_ep *hs_ep;\n\tu32 reg;\n\n\ths_ep = index_to_ep(hsotg, ep, dir_in);\n\tif (!hs_ep)\n\t\treturn;\n\n\tif (ep == 0) {\n\t\tu32 mps_bytes = mps;\n\n\t\t \n\t\tmps = dwc2_hsotg_ep0_mps(mps_bytes);\n\t\tif (mps > 3)\n\t\t\tgoto bad_mps;\n\t\ths_ep->ep.maxpacket = mps_bytes;\n\t\ths_ep->mc = 1;\n\t} else {\n\t\tif (mps > 1024)\n\t\t\tgoto bad_mps;\n\t\ths_ep->mc = mc;\n\t\tif (mc > 3)\n\t\t\tgoto bad_mps;\n\t\ths_ep->ep.maxpacket = mps;\n\t}\n\n\tif (dir_in) {\n\t\treg = dwc2_readl(hsotg, DIEPCTL(ep));\n\t\treg &= ~DXEPCTL_MPS_MASK;\n\t\treg |= mps;\n\t\tdwc2_writel(hsotg, reg, DIEPCTL(ep));\n\t} else {\n\t\treg = dwc2_readl(hsotg, DOEPCTL(ep));\n\t\treg &= ~DXEPCTL_MPS_MASK;\n\t\treg |= mps;\n\t\tdwc2_writel(hsotg, reg, DOEPCTL(ep));\n\t}\n\n\treturn;\n\nbad_mps:\n\tdev_err(hsotg->dev, \"ep%d: bad mps of %d\\n\", ep, mps);\n}\n\n \nstatic void dwc2_hsotg_txfifo_flush(struct dwc2_hsotg *hsotg, unsigned int idx)\n{\n\tdwc2_writel(hsotg, GRSTCTL_TXFNUM(idx) | GRSTCTL_TXFFLSH,\n\t\t    GRSTCTL);\n\n\t \n\tif (dwc2_hsotg_wait_bit_clear(hsotg, GRSTCTL, GRSTCTL_TXFFLSH, 100))\n\t\tdev_warn(hsotg->dev, \"%s: timeout flushing fifo GRSTCTL_TXFFLSH\\n\",\n\t\t\t __func__);\n}\n\n \nstatic int dwc2_hsotg_trytx(struct dwc2_hsotg *hsotg,\n\t\t\t    struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg_req *hs_req = hs_ep->req;\n\n\tif (!hs_ep->dir_in || !hs_req) {\n\t\t \n\t\tif (hs_ep->index != 0)\n\t\t\tdwc2_hsotg_ctrl_epint(hsotg, hs_ep->index,\n\t\t\t\t\t      hs_ep->dir_in, 0);\n\t\treturn 0;\n\t}\n\n\tif (hs_req->req.actual < hs_req->req.length) {\n\t\tdev_dbg(hsotg->dev, \"trying to write more for ep%d\\n\",\n\t\t\ths_ep->index);\n\t\treturn dwc2_hsotg_write_fifo(hsotg, hs_ep, hs_req);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void dwc2_hsotg_complete_in(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg_req *hs_req = hs_ep->req;\n\tu32 epsize = dwc2_readl(hsotg, DIEPTSIZ(hs_ep->index));\n\tint size_left, size_done;\n\n\tif (!hs_req) {\n\t\tdev_dbg(hsotg->dev, \"XferCompl but no req\\n\");\n\t\treturn;\n\t}\n\n\t \n\tif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_STATUS_IN) {\n\t\tdev_dbg(hsotg->dev, \"zlp packet sent\\n\");\n\n\t\t \n\t\ths_ep->dir_in = 0;\n\n\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\n\t\tif (hsotg->test_mode) {\n\t\t\tint ret;\n\n\t\t\tret = dwc2_hsotg_set_test_mode(hsotg, hsotg->test_mode);\n\t\t\tif (ret < 0) {\n\t\t\t\tdev_dbg(hsotg->dev, \"Invalid Test #%d\\n\",\n\t\t\t\t\thsotg->test_mode);\n\t\t\t\tdwc2_hsotg_stall_ep0(hsotg);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tdwc2_hsotg_enqueue_setup(hsotg);\n\t\treturn;\n\t}\n\n\t \n\tif (using_desc_dma(hsotg)) {\n\t\tsize_left = dwc2_gadget_get_xfersize_ddma(hs_ep);\n\t\tif (size_left < 0)\n\t\t\tdev_err(hsotg->dev, \"error parsing DDMA results %d\\n\",\n\t\t\t\tsize_left);\n\t} else {\n\t\tsize_left = DXEPTSIZ_XFERSIZE_GET(epsize);\n\t}\n\n\tsize_done = hs_ep->size_loaded - size_left;\n\tsize_done += hs_ep->last_load;\n\n\tif (hs_req->req.actual != size_done)\n\t\tdev_dbg(hsotg->dev, \"%s: adjusting size done %d => %d\\n\",\n\t\t\t__func__, hs_req->req.actual, size_done);\n\n\ths_req->req.actual = size_done;\n\tdev_dbg(hsotg->dev, \"req->length:%d req->actual:%d req->zero:%d\\n\",\n\t\ths_req->req.length, hs_req->req.actual, hs_req->req.zero);\n\n\tif (!size_left && hs_req->req.actual < hs_req->req.length) {\n\t\tdev_dbg(hsotg->dev, \"%s trying more for req...\\n\", __func__);\n\t\tdwc2_hsotg_start_req(hsotg, hs_ep, hs_req, true);\n\t\treturn;\n\t}\n\n\t \n\tif (hs_ep->send_zlp) {\n\t\ths_ep->send_zlp = 0;\n\t\tif (!using_desc_dma(hsotg)) {\n\t\t\tdwc2_hsotg_program_zlp(hsotg, hs_ep);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (hs_ep->index == 0 && hsotg->ep0_state == DWC2_EP0_DATA_IN) {\n\t\t \n\t\tdwc2_hsotg_ep0_zlp(hsotg, false);\n\t\treturn;\n\t}\n\n\t \n\tif (!using_desc_dma(hsotg) && hs_ep->isochronous) {\n\t\ths_req->req.frame_number = hs_ep->target_frame;\n\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t}\n\n\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, 0);\n}\n\n \nstatic u32 dwc2_gadget_read_ep_interrupts(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t  unsigned int idx, int dir_in)\n{\n\tu32 epmsk_reg = dir_in ? DIEPMSK : DOEPMSK;\n\tu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\n\tu32 ints;\n\tu32 mask;\n\tu32 diepempmsk;\n\n\tmask = dwc2_readl(hsotg, epmsk_reg);\n\tdiepempmsk = dwc2_readl(hsotg, DIEPEMPMSK);\n\tmask |= ((diepempmsk >> idx) & 0x1) ? DIEPMSK_TXFIFOEMPTY : 0;\n\tmask |= DXEPINT_SETUP_RCVD;\n\n\tints = dwc2_readl(hsotg, epint_reg);\n\tints &= mask;\n\treturn ints;\n}\n\n \nstatic void dwc2_gadget_handle_ep_disabled(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tstruct dwc2_hsotg_req *hs_req;\n\tunsigned char idx = hs_ep->index;\n\tint dir_in = hs_ep->dir_in;\n\tu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\n\tint dctl = dwc2_readl(hsotg, DCTL);\n\n\tdev_dbg(hsotg->dev, \"%s: EPDisbld\\n\", __func__);\n\n\tif (dir_in) {\n\t\tint epctl = dwc2_readl(hsotg, epctl_reg);\n\n\t\tdwc2_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);\n\n\t\tif ((epctl & DXEPCTL_STALL) && (epctl & DXEPCTL_EPTYPE_BULK)) {\n\t\t\tint dctl = dwc2_readl(hsotg, DCTL);\n\n\t\t\tdctl |= DCTL_CGNPINNAK;\n\t\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t\t}\n\t} else {\n\n\t\tif (dctl & DCTL_GOUTNAKSTS) {\n\t\t\tdctl |= DCTL_CGOUTNAK;\n\t\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t\t}\n\t}\n\n\tif (!hs_ep->isochronous)\n\t\treturn;\n\n\tif (list_empty(&hs_ep->queue)) {\n\t\tdev_dbg(hsotg->dev, \"%s: complete_ep 0x%p, ep->queue empty!\\n\",\n\t\t\t__func__, hs_ep);\n\t\treturn;\n\t}\n\n\tdo {\n\t\ths_req = get_ep_head(hs_ep);\n\t\tif (hs_req) {\n\t\t\ths_req->req.frame_number = hs_ep->target_frame;\n\t\t\ths_req->req.actual = 0;\n\t\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req,\n\t\t\t\t\t\t    -ENODATA);\n\t\t}\n\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t\t \n\t\thsotg->frame_number = dwc2_hsotg_read_frameno(hsotg);\n\t} while (dwc2_gadget_target_frame_elapsed(hs_ep));\n}\n\n \nstatic void dwc2_gadget_handle_out_token_ep_disabled(struct dwc2_hsotg_ep *ep)\n{\n\tstruct dwc2_hsotg *hsotg = ep->parent;\n\tstruct dwc2_hsotg_req *hs_req;\n\tint dir_in = ep->dir_in;\n\n\tif (dir_in || !ep->isochronous)\n\t\treturn;\n\n\tif (using_desc_dma(hsotg)) {\n\t\tif (ep->target_frame == TARGET_FRAME_INITIAL) {\n\t\t\t \n\t\t\tep->target_frame = hsotg->frame_number;\n\t\t\tdwc2_gadget_start_isoc_ddma(ep);\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ep->target_frame == TARGET_FRAME_INITIAL) {\n\t\tu32 ctrl;\n\n\t\tep->target_frame = hsotg->frame_number;\n\t\tif (ep->interval > 1) {\n\t\t\tctrl = dwc2_readl(hsotg, DOEPCTL(ep->index));\n\t\t\tif (ep->target_frame & 0x1)\n\t\t\t\tctrl |= DXEPCTL_SETODDFR;\n\t\t\telse\n\t\t\t\tctrl |= DXEPCTL_SETEVENFR;\n\n\t\t\tdwc2_writel(hsotg, ctrl, DOEPCTL(ep->index));\n\t\t}\n\t}\n\n\twhile (dwc2_gadget_target_frame_elapsed(ep)) {\n\t\ths_req = get_ep_head(ep);\n\t\tif (hs_req) {\n\t\t\ths_req->req.frame_number = ep->target_frame;\n\t\t\ths_req->req.actual = 0;\n\t\t\tdwc2_hsotg_complete_request(hsotg, ep, hs_req, -ENODATA);\n\t\t}\n\n\t\tdwc2_gadget_incr_frame_num(ep);\n\t\t \n\t\thsotg->frame_number = dwc2_hsotg_read_frameno(hsotg);\n\t}\n\n\tif (!ep->req)\n\t\tdwc2_gadget_start_next_request(ep);\n\n}\n\nstatic void dwc2_hsotg_ep_stop_xfr(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hsotg_ep *hs_ep);\n\n \nstatic void dwc2_gadget_handle_nak(struct dwc2_hsotg_ep *hs_ep)\n{\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tstruct dwc2_hsotg_req *hs_req;\n\tint dir_in = hs_ep->dir_in;\n\tu32 ctrl;\n\n\tif (!dir_in || !hs_ep->isochronous)\n\t\treturn;\n\n\tif (hs_ep->target_frame == TARGET_FRAME_INITIAL) {\n\n\t\tif (using_desc_dma(hsotg)) {\n\t\t\ths_ep->target_frame = hsotg->frame_number;\n\t\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\n\t\t\t \n\t\t\tif (hsotg->params.service_interval) {\n\t\t\t\t \n\t\t\t\ths_ep->target_frame &= ~hs_ep->interval + 1;\n\n\t\t\t\t \n\t\t\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t\t\t\tdwc2_gadget_dec_frame_num_by_one(hs_ep);\n\t\t\t}\n\n\t\t\tdwc2_gadget_start_isoc_ddma(hs_ep);\n\t\t\treturn;\n\t\t}\n\n\t\ths_ep->target_frame = hsotg->frame_number;\n\t\tif (hs_ep->interval > 1) {\n\t\t\tu32 ctrl = dwc2_readl(hsotg,\n\t\t\t\t\t      DIEPCTL(hs_ep->index));\n\t\t\tif (hs_ep->target_frame & 0x1)\n\t\t\t\tctrl |= DXEPCTL_SETODDFR;\n\t\t\telse\n\t\t\t\tctrl |= DXEPCTL_SETEVENFR;\n\n\t\t\tdwc2_writel(hsotg, ctrl, DIEPCTL(hs_ep->index));\n\t\t}\n\t}\n\n\tif (using_desc_dma(hsotg))\n\t\treturn;\n\n\tctrl = dwc2_readl(hsotg, DIEPCTL(hs_ep->index));\n\tif (ctrl & DXEPCTL_EPENA)\n\t\tdwc2_hsotg_ep_stop_xfr(hsotg, hs_ep);\n\telse\n\t\tdwc2_hsotg_txfifo_flush(hsotg, hs_ep->fifo_index);\n\n\twhile (dwc2_gadget_target_frame_elapsed(hs_ep)) {\n\t\ths_req = get_ep_head(hs_ep);\n\t\tif (hs_req) {\n\t\t\ths_req->req.frame_number = hs_ep->target_frame;\n\t\t\ths_req->req.actual = 0;\n\t\t\tdwc2_hsotg_complete_request(hsotg, hs_ep, hs_req, -ENODATA);\n\t\t}\n\n\t\tdwc2_gadget_incr_frame_num(hs_ep);\n\t\t \n\t\thsotg->frame_number = dwc2_hsotg_read_frameno(hsotg);\n\t}\n\n\tif (!hs_ep->req)\n\t\tdwc2_gadget_start_next_request(hs_ep);\n}\n\n \nstatic void dwc2_hsotg_epint(struct dwc2_hsotg *hsotg, unsigned int idx,\n\t\t\t     int dir_in)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = index_to_ep(hsotg, idx, dir_in);\n\tu32 epint_reg = dir_in ? DIEPINT(idx) : DOEPINT(idx);\n\tu32 epctl_reg = dir_in ? DIEPCTL(idx) : DOEPCTL(idx);\n\tu32 epsiz_reg = dir_in ? DIEPTSIZ(idx) : DOEPTSIZ(idx);\n\tu32 ints;\n\n\tints = dwc2_gadget_read_ep_interrupts(hsotg, idx, dir_in);\n\n\t \n\tdwc2_writel(hsotg, ints, epint_reg);\n\n\tif (!hs_ep) {\n\t\tdev_err(hsotg->dev, \"%s:Interrupt for unconfigured ep%d(%s)\\n\",\n\t\t\t__func__, idx, dir_in ? \"in\" : \"out\");\n\t\treturn;\n\t}\n\n\tdev_dbg(hsotg->dev, \"%s: ep%d(%s) DxEPINT=0x%08x\\n\",\n\t\t__func__, idx, dir_in ? \"in\" : \"out\", ints);\n\n\t \n\tif (idx == 0 && (ints & (DXEPINT_SETUP | DXEPINT_SETUP_RCVD)))\n\t\tints &= ~DXEPINT_XFERCOMPL;\n\n\t \n\tif (using_desc_dma(hsotg) && idx == 0 && !hs_ep->dir_in &&\n\t    hsotg->ep0_state == DWC2_EP0_SETUP && !(ints & DXEPINT_SETUP))\n\t\tints &= ~DXEPINT_XFERCOMPL;\n\n\tif (ints & DXEPINT_XFERCOMPL) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"%s: XferCompl: DxEPCTL=0x%08x, DXEPTSIZ=%08x\\n\",\n\t\t\t__func__, dwc2_readl(hsotg, epctl_reg),\n\t\t\tdwc2_readl(hsotg, epsiz_reg));\n\n\t\t \n\t\tif (using_desc_dma(hsotg) && hs_ep->isochronous) {\n\t\t\tdwc2_gadget_complete_isoc_request_ddma(hs_ep);\n\t\t} else if (dir_in) {\n\t\t\t \n\t\t\tif (!hs_ep->isochronous || !(ints & DXEPINT_NAKINTRPT))\n\t\t\t\tdwc2_hsotg_complete_in(hsotg, hs_ep);\n\n\t\t\tif (idx == 0 && !hs_ep->req)\n\t\t\t\tdwc2_hsotg_enqueue_setup(hsotg);\n\t\t} else if (using_dma(hsotg)) {\n\t\t\t \n\t\t\tif (!hs_ep->isochronous || !(ints & DXEPINT_OUTTKNEPDIS))\n\t\t\t\tdwc2_hsotg_handle_outdone(hsotg, idx);\n\t\t}\n\t}\n\n\tif (ints & DXEPINT_EPDISBLD)\n\t\tdwc2_gadget_handle_ep_disabled(hs_ep);\n\n\tif (ints & DXEPINT_OUTTKNEPDIS)\n\t\tdwc2_gadget_handle_out_token_ep_disabled(hs_ep);\n\n\tif (ints & DXEPINT_NAKINTRPT)\n\t\tdwc2_gadget_handle_nak(hs_ep);\n\n\tif (ints & DXEPINT_AHBERR)\n\t\tdev_dbg(hsotg->dev, \"%s: AHBErr\\n\", __func__);\n\n\tif (ints & DXEPINT_SETUP) {   \n\t\tdev_dbg(hsotg->dev, \"%s: Setup/Timeout\\n\",  __func__);\n\n\t\tif (using_dma(hsotg) && idx == 0) {\n\t\t\t \n\n\t\t\tif (dir_in)\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\telse\n\t\t\t\tdwc2_hsotg_handle_outdone(hsotg, 0);\n\t\t}\n\t}\n\n\tif (ints & DXEPINT_STSPHSERCVD) {\n\t\tdev_dbg(hsotg->dev, \"%s: StsPhseRcvd\\n\", __func__);\n\n\t\t \n\t\tif (hsotg->ep0_state == DWC2_EP0_DATA_OUT) {\n\t\t\t \n\t\t\tif (using_desc_dma(hsotg)) {\n\t\t\t\tif (!hsotg->delayed_status)\n\t\t\t\t\tdwc2_hsotg_ep0_zlp(hsotg, true);\n\t\t\t\telse\n\t\t\t\t \n\t\t\t\t\tdwc2_set_bit(hsotg, DIEPCTL(0),\n\t\t\t\t\t\t     DXEPCTL_CNAK);\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (ints & DXEPINT_BACK2BACKSETUP)\n\t\tdev_dbg(hsotg->dev, \"%s: B2BSetup/INEPNakEff\\n\", __func__);\n\n\tif (ints & DXEPINT_BNAINTR) {\n\t\tdev_dbg(hsotg->dev, \"%s: BNA interrupt\\n\", __func__);\n\t\tif (hs_ep->isochronous)\n\t\t\tdwc2_gadget_handle_isoc_bna(hs_ep);\n\t}\n\n\tif (dir_in && !hs_ep->isochronous) {\n\t\t \n\t\tif (ints & DXEPINT_INTKNTXFEMP) {\n\t\t\tdev_dbg(hsotg->dev, \"%s: ep%d: INTknTXFEmpMsk\\n\",\n\t\t\t\t__func__, idx);\n\t\t}\n\n\t\t \n\t\tif (ints & DXEPINT_INTKNEPMIS) {\n\t\t\tdev_warn(hsotg->dev, \"%s: ep%d: INTknEP\\n\",\n\t\t\t\t __func__, idx);\n\t\t}\n\n\t\t \n\t\tif (hsotg->dedicated_fifos &&\n\t\t    ints & DXEPINT_TXFEMP) {\n\t\t\tdev_dbg(hsotg->dev, \"%s: ep%d: TxFIFOEmpty\\n\",\n\t\t\t\t__func__, idx);\n\t\t\tif (!using_dma(hsotg))\n\t\t\t\tdwc2_hsotg_trytx(hsotg, hs_ep);\n\t\t}\n\t}\n}\n\n \nstatic void dwc2_hsotg_irq_enumdone(struct dwc2_hsotg *hsotg)\n{\n\tu32 dsts = dwc2_readl(hsotg, DSTS);\n\tint ep0_mps = 0, ep_mps = 8;\n\n\t \n\n\tdev_dbg(hsotg->dev, \"EnumDone (DSTS=0x%08x)\\n\", dsts);\n\n\t \n\n\t \n\tswitch ((dsts & DSTS_ENUMSPD_MASK) >> DSTS_ENUMSPD_SHIFT) {\n\tcase DSTS_ENUMSPD_FS:\n\tcase DSTS_ENUMSPD_FS48:\n\t\thsotg->gadget.speed = USB_SPEED_FULL;\n\t\tep0_mps = EP0_MPS_LIMIT;\n\t\tep_mps = 1023;\n\t\tbreak;\n\n\tcase DSTS_ENUMSPD_HS:\n\t\thsotg->gadget.speed = USB_SPEED_HIGH;\n\t\tep0_mps = EP0_MPS_LIMIT;\n\t\tep_mps = 1024;\n\t\tbreak;\n\n\tcase DSTS_ENUMSPD_LS:\n\t\thsotg->gadget.speed = USB_SPEED_LOW;\n\t\tep0_mps = 8;\n\t\tep_mps = 8;\n\t\t \n\t\tbreak;\n\t}\n\tdev_info(hsotg->dev, \"new device is %s\\n\",\n\t\t usb_speed_string(hsotg->gadget.speed));\n\n\t \n\n\tif (ep0_mps) {\n\t\tint i;\n\t\t \n\t\tdwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0, 1);\n\t\tdwc2_hsotg_set_ep_maxpacket(hsotg, 0, ep0_mps, 0, 0);\n\t\tfor (i = 1; i < hsotg->num_of_eps; i++) {\n\t\t\tif (hsotg->eps_in[i])\n\t\t\t\tdwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps,\n\t\t\t\t\t\t\t    0, 1);\n\t\t\tif (hsotg->eps_out[i])\n\t\t\t\tdwc2_hsotg_set_ep_maxpacket(hsotg, i, ep_mps,\n\t\t\t\t\t\t\t    0, 0);\n\t\t}\n\t}\n\n\t \n\n\tdwc2_hsotg_enqueue_setup(hsotg);\n\n\tdev_dbg(hsotg->dev, \"EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\\n\",\n\t\tdwc2_readl(hsotg, DIEPCTL0),\n\t\tdwc2_readl(hsotg, DOEPCTL0));\n}\n\n \nstatic void kill_all_requests(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_hsotg_ep *ep,\n\t\t\t      int result)\n{\n\tunsigned int size;\n\n\tep->req = NULL;\n\n\twhile (!list_empty(&ep->queue)) {\n\t\tstruct dwc2_hsotg_req *req = get_ep_head(ep);\n\n\t\tdwc2_hsotg_complete_request(hsotg, ep, req, result);\n\t}\n\n\tif (!hsotg->dedicated_fifos)\n\t\treturn;\n\tsize = (dwc2_readl(hsotg, DTXFSTS(ep->fifo_index)) & 0xffff) * 4;\n\tif (size < ep->fifo_size)\n\t\tdwc2_hsotg_txfifo_flush(hsotg, ep->fifo_index);\n}\n\n \nvoid dwc2_hsotg_disconnect(struct dwc2_hsotg *hsotg)\n{\n\tunsigned int ep;\n\n\tif (!hsotg->connected)\n\t\treturn;\n\n\thsotg->connected = 0;\n\thsotg->test_mode = 0;\n\n\t \n\tfor (ep = 0; ep < hsotg->num_of_eps; ep++) {\n\t\tif (hsotg->eps_in[ep])\n\t\t\tkill_all_requests(hsotg, hsotg->eps_in[ep],\n\t\t\t\t\t  -ESHUTDOWN);\n\t\tif (hsotg->eps_out[ep])\n\t\t\tkill_all_requests(hsotg, hsotg->eps_out[ep],\n\t\t\t\t\t  -ESHUTDOWN);\n\t}\n\n\tcall_gadget(hsotg, disconnect);\n\thsotg->lx_state = DWC2_L3;\n\n\tusb_gadget_set_state(&hsotg->gadget, USB_STATE_NOTATTACHED);\n}\n\n \nstatic void dwc2_hsotg_irq_fifoempty(struct dwc2_hsotg *hsotg, bool periodic)\n{\n\tstruct dwc2_hsotg_ep *ep;\n\tint epno, ret;\n\n\t \n\tfor (epno = 0; epno < hsotg->num_of_eps; epno++) {\n\t\tep = index_to_ep(hsotg, epno, 1);\n\n\t\tif (!ep)\n\t\t\tcontinue;\n\n\t\tif (!ep->dir_in)\n\t\t\tcontinue;\n\n\t\tif ((periodic && !ep->periodic) ||\n\t\t    (!periodic && ep->periodic))\n\t\t\tcontinue;\n\n\t\tret = dwc2_hsotg_trytx(hsotg, ep);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n}\n\n \n#define IRQ_RETRY_MASK (GINTSTS_NPTXFEMP | \\\n\t\t\tGINTSTS_PTXFEMP |  \\\n\t\t\tGINTSTS_RXFLVL)\n\nstatic int dwc2_hsotg_ep_disable(struct usb_ep *ep);\n \nvoid dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,\n\t\t\t\t       bool is_usb_reset)\n{\n\tu32 intmsk;\n\tu32 val;\n\tu32 usbcfg;\n\tu32 dcfg = 0;\n\tint ep;\n\n\t \n\tkill_all_requests(hsotg, hsotg->eps_out[0], -ECONNRESET);\n\n\tif (!is_usb_reset) {\n\t\tif (dwc2_core_reset(hsotg, true))\n\t\t\treturn;\n\t} else {\n\t\t \n\t\tfor (ep = 1; ep < hsotg->num_of_eps; ep++) {\n\t\t\tif (hsotg->eps_in[ep])\n\t\t\t\tdwc2_hsotg_ep_disable(&hsotg->eps_in[ep]->ep);\n\t\t\tif (hsotg->eps_out[ep])\n\t\t\t\tdwc2_hsotg_ep_disable(&hsotg->eps_out[ep]->ep);\n\t\t}\n\t}\n\n\t \n\n\t \n\tusbcfg = dwc2_readl(hsotg, GUSBCFG);\n\tusbcfg &= ~GUSBCFG_TOUTCAL_MASK;\n\tusbcfg |= GUSBCFG_TOUTCAL(7);\n\n\t \n\tusbcfg &= ~(GUSBCFG_SRPCAP | GUSBCFG_HNPCAP);\n        dwc2_writel(hsotg, usbcfg, GUSBCFG);\n\n\tdwc2_phy_init(hsotg, true);\n\n\tdwc2_hsotg_init_fifo(hsotg);\n\n\tif (!is_usb_reset)\n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_SFTDISCON);\n\n\tdcfg |= DCFG_EPMISCNT(1);\n\n\tswitch (hsotg->params.speed) {\n\tcase DWC2_SPEED_PARAM_LOW:\n\t\tdcfg |= DCFG_DEVSPD_LS;\n\t\tbreak;\n\tcase DWC2_SPEED_PARAM_FULL:\n\t\tif (hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS)\n\t\t\tdcfg |= DCFG_DEVSPD_FS48;\n\t\telse\n\t\t\tdcfg |= DCFG_DEVSPD_FS;\n\t\tbreak;\n\tdefault:\n\t\tdcfg |= DCFG_DEVSPD_HS;\n\t}\n\n\tif (hsotg->params.ipg_isoc_en)\n\t\tdcfg |= DCFG_IPG_ISOC_SUPPORDED;\n\n\tdwc2_writel(hsotg, dcfg,  DCFG);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GOTGINT);\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\tintmsk = GINTSTS_ERLYSUSP | GINTSTS_SESSREQINT |\n\t\tGINTSTS_GOUTNAKEFF | GINTSTS_GINNAKEFF |\n\t\tGINTSTS_USBRST | GINTSTS_RESETDET |\n\t\tGINTSTS_ENUMDONE | GINTSTS_OTGINT |\n\t\tGINTSTS_USBSUSP | GINTSTS_WKUPINT |\n\t\tGINTSTS_LPMTRANRCVD;\n\n\tif (!using_desc_dma(hsotg))\n\t\tintmsk |= GINTSTS_INCOMPL_SOIN | GINTSTS_INCOMPL_SOOUT;\n\n\tif (!hsotg->params.external_id_pin_ctl)\n\t\tintmsk |= GINTSTS_CONIDSTSCHNG;\n\n\tdwc2_writel(hsotg, intmsk, GINTMSK);\n\n\tif (using_dma(hsotg)) {\n\t\tdwc2_writel(hsotg, GAHBCFG_GLBL_INTR_EN | GAHBCFG_DMA_EN |\n\t\t\t    hsotg->params.ahbcfg,\n\t\t\t    GAHBCFG);\n\n\t\t \n\t\tif (using_desc_dma(hsotg))\n\t\t\tdwc2_set_bit(hsotg, DCFG, DCFG_DESCDMA_EN);\n\n\t} else {\n\t\tdwc2_writel(hsotg, ((hsotg->dedicated_fifos) ?\n\t\t\t\t\t\t(GAHBCFG_NP_TXF_EMP_LVL |\n\t\t\t\t\t\t GAHBCFG_P_TXF_EMP_LVL) : 0) |\n\t\t\t    GAHBCFG_GLBL_INTR_EN, GAHBCFG);\n\t}\n\n\t \n\n\tdwc2_writel(hsotg, ((hsotg->dedicated_fifos && !using_dma(hsotg)) ?\n\t\tDIEPMSK_TXFIFOEMPTY | DIEPMSK_INTKNTXFEMPMSK : 0) |\n\t\tDIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK |\n\t\tDIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK,\n\t\tDIEPMSK);\n\n\t \n\tdwc2_writel(hsotg, (using_dma(hsotg) ? (DIEPMSK_XFERCOMPLMSK |\n\t\tDOEPMSK_STSPHSERCVDMSK) : 0) |\n\t\tDOEPMSK_EPDISBLDMSK | DOEPMSK_AHBERRMSK |\n\t\tDOEPMSK_SETUPMSK,\n\t\tDOEPMSK);\n\n\t \n\tif (using_desc_dma(hsotg)) {\n\t\tdwc2_set_bit(hsotg, DOEPMSK, DOEPMSK_BNAMSK);\n\t\tdwc2_set_bit(hsotg, DIEPMSK, DIEPMSK_BNAININTRMSK);\n\t}\n\n\t \n\tif (using_desc_dma(hsotg) && hsotg->params.service_interval)\n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_SERVICE_INTERVAL_SUPPORTED);\n\n\tdwc2_writel(hsotg, 0, DAINTMSK);\n\n\tdev_dbg(hsotg->dev, \"EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\\n\",\n\t\tdwc2_readl(hsotg, DIEPCTL0),\n\t\tdwc2_readl(hsotg, DOEPCTL0));\n\n\t \n\tdwc2_hsotg_en_gsint(hsotg, GINTSTS_OEPINT | GINTSTS_IEPINT);\n\n\t \n\tif (!using_dma(hsotg))\n\t\tdwc2_hsotg_en_gsint(hsotg, GINTSTS_RXFLVL);\n\n\t \n\tdwc2_hsotg_ctrl_epint(hsotg, 0, 0, 1);\n\tdwc2_hsotg_ctrl_epint(hsotg, 0, 1, 1);\n\n\tif (!is_usb_reset) {\n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_PWRONPRGDONE);\n\t\tudelay(10);   \n\t\tdwc2_clear_bit(hsotg, DCTL, DCTL_PWRONPRGDONE);\n\t}\n\n\tdev_dbg(hsotg->dev, \"DCTL=0x%08x\\n\", dwc2_readl(hsotg, DCTL));\n\n\t \n\n\t \n\tdwc2_writel(hsotg, DXEPTSIZ_MC(1) | DXEPTSIZ_PKTCNT(1) |\n\t       DXEPTSIZ_XFERSIZE(8), DOEPTSIZ0);\n\n\tdwc2_writel(hsotg, dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\n\t       DXEPCTL_CNAK | DXEPCTL_EPENA |\n\t       DXEPCTL_USBACTEP,\n\t       DOEPCTL0);\n\n\t \n\tdwc2_writel(hsotg, dwc2_hsotg_ep0_mps(hsotg->eps_out[0]->ep.maxpacket) |\n\t       DXEPCTL_USBACTEP, DIEPCTL0);\n\n\t \n\tval = DCTL_CGOUTNAK | DCTL_CGNPINNAK;\n\tif (!is_usb_reset)\n\t\tval |= DCTL_SFTDISCON;\n\tdwc2_set_bit(hsotg, DCTL, val);\n\n\t \n\tdwc2_gadget_init_lpm(hsotg);\n\n\t \n\tif (using_desc_dma(hsotg) && hsotg->params.service_interval)\n\t\tdwc2_gadget_program_ref_clk(hsotg);\n\n\t \n\tmdelay(3);\n\n\thsotg->lx_state = DWC2_L0;\n\n\tdwc2_hsotg_enqueue_setup(hsotg);\n\n\tdev_dbg(hsotg->dev, \"EP0: DIEPCTL0=0x%08x, DOEPCTL0=0x%08x\\n\",\n\t\tdwc2_readl(hsotg, DIEPCTL0),\n\t\tdwc2_readl(hsotg, DOEPCTL0));\n}\n\nvoid dwc2_hsotg_core_disconnect(struct dwc2_hsotg *hsotg)\n{\n\t \n\tdwc2_set_bit(hsotg, DCTL, DCTL_SFTDISCON);\n}\n\nvoid dwc2_hsotg_core_connect(struct dwc2_hsotg *hsotg)\n{\n\t \n\tif (!hsotg->role_sw || (dwc2_readl(hsotg, GOTGCTL) & GOTGCTL_BSESVLD))\n\t\tdwc2_clear_bit(hsotg, DCTL, DCTL_SFTDISCON);\n}\n\n \nstatic void dwc2_gadget_handle_incomplete_isoc_in(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_hsotg_ep *hs_ep;\n\tu32 epctrl;\n\tu32 daintmsk;\n\tu32 idx;\n\n\tdev_dbg(hsotg->dev, \"Incomplete isoc in interrupt received:\\n\");\n\n\tdaintmsk = dwc2_readl(hsotg, DAINTMSK);\n\n\tfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\n\t\ths_ep = hsotg->eps_in[idx];\n\t\t \n\t\tif ((BIT(idx) & ~daintmsk) || !hs_ep->isochronous)\n\t\t\tcontinue;\n\n\t\tepctrl = dwc2_readl(hsotg, DIEPCTL(idx));\n\t\tif ((epctrl & DXEPCTL_EPENA) &&\n\t\t    dwc2_gadget_target_frame_elapsed(hs_ep)) {\n\t\t\tepctrl |= DXEPCTL_SNAK;\n\t\t\tepctrl |= DXEPCTL_EPDIS;\n\t\t\tdwc2_writel(hsotg, epctrl, DIEPCTL(idx));\n\t\t}\n\t}\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_INCOMPL_SOIN, GINTSTS);\n}\n\n \nstatic void dwc2_gadget_handle_incomplete_isoc_out(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts;\n\tu32 gintmsk;\n\tu32 daintmsk;\n\tu32 epctrl;\n\tstruct dwc2_hsotg_ep *hs_ep;\n\tint idx;\n\n\tdev_dbg(hsotg->dev, \"%s: GINTSTS_INCOMPL_SOOUT\\n\", __func__);\n\n\tdaintmsk = dwc2_readl(hsotg, DAINTMSK);\n\tdaintmsk >>= DAINT_OUTEP_SHIFT;\n\n\tfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\n\t\ths_ep = hsotg->eps_out[idx];\n\t\t \n\t\tif ((BIT(idx) & ~daintmsk) || !hs_ep->isochronous)\n\t\t\tcontinue;\n\n\t\tepctrl = dwc2_readl(hsotg, DOEPCTL(idx));\n\t\tif ((epctrl & DXEPCTL_EPENA) &&\n\t\t    dwc2_gadget_target_frame_elapsed(hs_ep)) {\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk |= GINTSTS_GOUTNAKEFF;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\n\t\t\tgintsts = dwc2_readl(hsotg, GINTSTS);\n\t\t\tif (!(gintsts & GINTSTS_GOUTNAKEFF)) {\n\t\t\t\tdwc2_set_bit(hsotg, DCTL, DCTL_SGOUTNAK);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_INCOMPL_SOOUT, GINTSTS);\n}\n\n \nstatic irqreturn_t dwc2_hsotg_irq(int irq, void *pw)\n{\n\tstruct dwc2_hsotg *hsotg = pw;\n\tint retry_count = 8;\n\tu32 gintsts;\n\tu32 gintmsk;\n\n\tif (!dwc2_is_device_mode(hsotg))\n\t\treturn IRQ_NONE;\n\n\tspin_lock(&hsotg->lock);\nirq_retry:\n\tgintsts = dwc2_readl(hsotg, GINTSTS);\n\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\n\tdev_dbg(hsotg->dev, \"%s: %08x %08x (%08x) retry %d\\n\",\n\t\t__func__, gintsts, gintsts & gintmsk, gintmsk, retry_count);\n\n\tgintsts &= gintmsk;\n\n\tif (gintsts & GINTSTS_RESETDET) {\n\t\tdev_dbg(hsotg->dev, \"%s: USBRstDet\\n\", __func__);\n\n\t\tdwc2_writel(hsotg, GINTSTS_RESETDET, GINTSTS);\n\n\t\t \n\t\tif (hsotg->in_ppd && hsotg->lx_state == DWC2_L2)\n\t\t\tdwc2_exit_partial_power_down(hsotg, 0, true);\n\n\t\thsotg->lx_state = DWC2_L0;\n\t}\n\n\tif (gintsts & (GINTSTS_USBRST | GINTSTS_RESETDET)) {\n\t\tu32 usb_status = dwc2_readl(hsotg, GOTGCTL);\n\t\tu32 connected = hsotg->connected;\n\n\t\tdev_dbg(hsotg->dev, \"%s: USBRst\\n\", __func__);\n\t\tdev_dbg(hsotg->dev, \"GNPTXSTS=%08x\\n\",\n\t\t\tdwc2_readl(hsotg, GNPTXSTS));\n\n\t\tdwc2_writel(hsotg, GINTSTS_USBRST, GINTSTS);\n\n\t\t \n\t\tdwc2_hsotg_disconnect(hsotg);\n\n\t\t \n\t\tdwc2_clear_bit(hsotg, DCFG, DCFG_DEVADDR_MASK);\n\n\t\tif (usb_status & GOTGCTL_BSESVLD && connected)\n\t\t\tdwc2_hsotg_core_init_disconnected(hsotg, true);\n\t}\n\n\tif (gintsts & GINTSTS_ENUMDONE) {\n\t\tdwc2_writel(hsotg, GINTSTS_ENUMDONE, GINTSTS);\n\n\t\tdwc2_hsotg_irq_enumdone(hsotg);\n\t}\n\n\tif (gintsts & (GINTSTS_OEPINT | GINTSTS_IEPINT)) {\n\t\tu32 daint = dwc2_readl(hsotg, DAINT);\n\t\tu32 daintmsk = dwc2_readl(hsotg, DAINTMSK);\n\t\tu32 daint_out, daint_in;\n\t\tint ep;\n\n\t\tdaint &= daintmsk;\n\t\tdaint_out = daint >> DAINT_OUTEP_SHIFT;\n\t\tdaint_in = daint & ~(daint_out << DAINT_OUTEP_SHIFT);\n\n\t\tdev_dbg(hsotg->dev, \"%s: daint=%08x\\n\", __func__, daint);\n\n\t\tfor (ep = 0; ep < hsotg->num_of_eps && daint_out;\n\t\t\t\t\t\tep++, daint_out >>= 1) {\n\t\t\tif (daint_out & 1)\n\t\t\t\tdwc2_hsotg_epint(hsotg, ep, 0);\n\t\t}\n\n\t\tfor (ep = 0; ep < hsotg->num_of_eps  && daint_in;\n\t\t\t\t\t\tep++, daint_in >>= 1) {\n\t\t\tif (daint_in & 1)\n\t\t\t\tdwc2_hsotg_epint(hsotg, ep, 1);\n\t\t}\n\t}\n\n\t \n\n\tif (gintsts & GINTSTS_NPTXFEMP) {\n\t\tdev_dbg(hsotg->dev, \"NPTxFEmp\\n\");\n\n\t\t \n\n\t\tdwc2_hsotg_disable_gsint(hsotg, GINTSTS_NPTXFEMP);\n\t\tdwc2_hsotg_irq_fifoempty(hsotg, false);\n\t}\n\n\tif (gintsts & GINTSTS_PTXFEMP) {\n\t\tdev_dbg(hsotg->dev, \"PTxFEmp\\n\");\n\n\t\t \n\n\t\tdwc2_hsotg_disable_gsint(hsotg, GINTSTS_PTXFEMP);\n\t\tdwc2_hsotg_irq_fifoempty(hsotg, true);\n\t}\n\n\tif (gintsts & GINTSTS_RXFLVL) {\n\t\t \n\n\t\tdwc2_hsotg_handle_rx(hsotg);\n\t}\n\n\tif (gintsts & GINTSTS_ERLYSUSP) {\n\t\tdev_dbg(hsotg->dev, \"GINTSTS_ErlySusp\\n\");\n\t\tdwc2_writel(hsotg, GINTSTS_ERLYSUSP, GINTSTS);\n\t}\n\n\t \n\n\tif (gintsts & GINTSTS_GOUTNAKEFF) {\n\t\tu8 idx;\n\t\tu32 epctrl;\n\t\tu32 gintmsk;\n\t\tu32 daintmsk;\n\t\tstruct dwc2_hsotg_ep *hs_ep;\n\n\t\tdaintmsk = dwc2_readl(hsotg, DAINTMSK);\n\t\tdaintmsk >>= DAINT_OUTEP_SHIFT;\n\t\t \n\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\tgintmsk &= ~GINTSTS_GOUTNAKEFF;\n\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\n\t\tdev_dbg(hsotg->dev, \"GOUTNakEff triggered\\n\");\n\t\tfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\n\t\t\ths_ep = hsotg->eps_out[idx];\n\t\t\t \n\t\t\tif (BIT(idx) & ~daintmsk)\n\t\t\t\tcontinue;\n\n\t\t\tepctrl = dwc2_readl(hsotg, DOEPCTL(idx));\n\n\t\t\t\n\t\t\tif ((epctrl & DXEPCTL_EPENA) && hs_ep->isochronous) {\n\t\t\t\tepctrl |= DXEPCTL_SNAK;\n\t\t\t\tepctrl |= DXEPCTL_EPDIS;\n\t\t\t\tdwc2_writel(hsotg, epctrl, DOEPCTL(idx));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (hs_ep->halted) {\n\t\t\t\tif (!(epctrl & DXEPCTL_EPENA))\n\t\t\t\t\tepctrl |= DXEPCTL_EPENA;\n\t\t\t\tepctrl |= DXEPCTL_EPDIS;\n\t\t\t\tepctrl |= DXEPCTL_STALL;\n\t\t\t\tdwc2_writel(hsotg, epctrl, DOEPCTL(idx));\n\t\t\t}\n\t\t}\n\n\t\t \n\t}\n\n\tif (gintsts & GINTSTS_GINNAKEFF) {\n\t\tdev_info(hsotg->dev, \"GINNakEff triggered\\n\");\n\n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_CGNPINNAK);\n\n\t\tdwc2_hsotg_dump(hsotg);\n\t}\n\n\tif (gintsts & GINTSTS_INCOMPL_SOIN)\n\t\tdwc2_gadget_handle_incomplete_isoc_in(hsotg);\n\n\tif (gintsts & GINTSTS_INCOMPL_SOOUT)\n\t\tdwc2_gadget_handle_incomplete_isoc_out(hsotg);\n\n\t \n\n\tif (gintsts & IRQ_RETRY_MASK && --retry_count > 0)\n\t\tgoto irq_retry;\n\n\t \n\tif (hsotg->params.service_interval)\n\t\tdwc2_gadget_wkup_alert_handler(hsotg);\n\n\tspin_unlock(&hsotg->lock);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void dwc2_hsotg_ep_stop_xfr(struct dwc2_hsotg *hsotg,\n\t\t\t\t   struct dwc2_hsotg_ep *hs_ep)\n{\n\tu32 epctrl_reg;\n\tu32 epint_reg;\n\n\tepctrl_reg = hs_ep->dir_in ? DIEPCTL(hs_ep->index) :\n\t\tDOEPCTL(hs_ep->index);\n\tepint_reg = hs_ep->dir_in ? DIEPINT(hs_ep->index) :\n\t\tDOEPINT(hs_ep->index);\n\n\tdev_dbg(hsotg->dev, \"%s: stopping transfer on %s\\n\", __func__,\n\t\ths_ep->name);\n\n\tif (hs_ep->dir_in) {\n\t\tif (hsotg->dedicated_fifos || hs_ep->periodic) {\n\t\t\tdwc2_set_bit(hsotg, epctrl_reg, DXEPCTL_SNAK);\n\t\t\t \n\t\t\tif (dwc2_hsotg_wait_bit_set(hsotg, epint_reg,\n\t\t\t\t\t\t    DXEPINT_INEPNAKEFF, 100))\n\t\t\t\tdev_warn(hsotg->dev,\n\t\t\t\t\t \"%s: timeout DIEPINT.NAKEFF\\n\",\n\t\t\t\t\t __func__);\n\t\t} else {\n\t\t\tdwc2_set_bit(hsotg, DCTL, DCTL_SGNPINNAK);\n\t\t\t \n\t\t\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,\n\t\t\t\t\t\t    GINTSTS_GINNAKEFF, 100))\n\t\t\t\tdev_warn(hsotg->dev,\n\t\t\t\t\t \"%s: timeout GINTSTS.GINNAKEFF\\n\",\n\t\t\t\t\t __func__);\n\t\t}\n\t} else {\n\t\t \n\t\tdwc2_hsotg_disable_gsint(hsotg, GINTSTS_GOUTNAKEFF);\n\n\t\tif (!(dwc2_readl(hsotg, GINTSTS) & GINTSTS_GOUTNAKEFF))\n\t\t\tdwc2_set_bit(hsotg, DCTL, DCTL_SGOUTNAK);\n\n\t\tif (!using_dma(hsotg)) {\n\t\t\t \n\t\t\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,\n\t\t\t\t\t\t    GINTSTS_RXFLVL, 100)) {\n\t\t\t\tdev_warn(hsotg->dev, \"%s: timeout GINTSTS.RXFLVL\\n\",\n\t\t\t\t\t __func__);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tdwc2_readl(hsotg, GRXSTSP);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (dwc2_hsotg_wait_bit_set(hsotg, GINTSTS,\n\t\t\t\t\t    GINTSTS_GOUTNAKEFF, 100))\n\t\t\tdev_warn(hsotg->dev, \"%s: timeout GINTSTS.GOUTNAKEFF\\n\",\n\t\t\t\t __func__);\n\t}\n\n\t \n\tdwc2_set_bit(hsotg, epctrl_reg, DXEPCTL_EPDIS | DXEPCTL_SNAK);\n\n\t \n\tif (dwc2_hsotg_wait_bit_set(hsotg, epint_reg, DXEPINT_EPDISBLD, 100))\n\t\tdev_warn(hsotg->dev,\n\t\t\t \"%s: timeout DOEPCTL.EPDisable\\n\", __func__);\n\n\t \n\tdwc2_set_bit(hsotg, epint_reg, DXEPINT_EPDISBLD);\n\n\tif (hs_ep->dir_in) {\n\t\tunsigned short fifo_index;\n\n\t\tif (hsotg->dedicated_fifos || hs_ep->periodic)\n\t\t\tfifo_index = hs_ep->fifo_index;\n\t\telse\n\t\t\tfifo_index = 0;\n\n\t\t \n\t\tdwc2_flush_tx_fifo(hsotg, fifo_index);\n\n\t\t \n\t\tif (!hsotg->dedicated_fifos && !hs_ep->periodic)\n\t\t\tdwc2_set_bit(hsotg, DCTL, DCTL_CGNPINNAK);\n\n\t} else {\n\t\t \n\t\tdwc2_set_bit(hsotg, DCTL, DCTL_CGOUTNAK);\n\t}\n}\n\n \nstatic int dwc2_hsotg_ep_enable(struct usb_ep *ep,\n\t\t\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tunsigned long flags;\n\tunsigned int index = hs_ep->index;\n\tu32 epctrl_reg;\n\tu32 epctrl;\n\tu32 mps;\n\tu32 mc;\n\tu32 mask;\n\tunsigned int dir_in;\n\tunsigned int i, val, size;\n\tint ret = 0;\n\tunsigned char ep_type;\n\tint desc_num;\n\n\tdev_dbg(hsotg->dev,\n\t\t\"%s: ep %s: a 0x%02x, attr 0x%02x, mps 0x%04x, intr %d\\n\",\n\t\t__func__, ep->name, desc->bEndpointAddress, desc->bmAttributes,\n\t\tdesc->wMaxPacketSize, desc->bInterval);\n\n\t \n\tif (index == 0) {\n\t\tdev_err(hsotg->dev, \"%s: called for EP 0\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tdir_in = (desc->bEndpointAddress & USB_ENDPOINT_DIR_MASK) ? 1 : 0;\n\tif (dir_in != hs_ep->dir_in) {\n\t\tdev_err(hsotg->dev, \"%s: direction mismatch!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tep_type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;\n\tmps = usb_endpoint_maxp(desc);\n\tmc = usb_endpoint_maxp_mult(desc);\n\n\t \n\tif (using_desc_dma(hsotg) && ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t    dir_in && desc->bInterval > 10) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: ISOC IN, DDMA: bInterval>10 not supported!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (using_desc_dma(hsotg) && ep_type == USB_ENDPOINT_XFER_ISOC &&\n\t    !dir_in && mc > 1) {\n\t\tdev_err(hsotg->dev,\n\t\t\t\"%s: ISOC OUT, DDMA: HB not supported!\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\n\tepctrl = dwc2_readl(hsotg, epctrl_reg);\n\n\tdev_dbg(hsotg->dev, \"%s: read DxEPCTL=0x%08x from 0x%08x\\n\",\n\t\t__func__, epctrl, epctrl_reg);\n\n\tif (using_desc_dma(hsotg) && ep_type == USB_ENDPOINT_XFER_ISOC)\n\t\tdesc_num = MAX_DMA_DESC_NUM_HS_ISOC;\n\telse\n\t\tdesc_num = MAX_DMA_DESC_NUM_GENERIC;\n\n\t \n\tif (using_desc_dma(hsotg) && !hs_ep->desc_list) {\n\t\ths_ep->desc_list = dmam_alloc_coherent(hsotg->dev,\n\t\t\tdesc_num * sizeof(struct dwc2_dma_desc),\n\t\t\t&hs_ep->desc_list_dma, GFP_ATOMIC);\n\t\tif (!hs_ep->desc_list) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error2;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\tepctrl &= ~(DXEPCTL_EPTYPE_MASK | DXEPCTL_MPS_MASK);\n\tepctrl |= DXEPCTL_MPS(mps);\n\n\t \n\tepctrl |= DXEPCTL_USBACTEP;\n\n\t \n\tdwc2_hsotg_set_ep_maxpacket(hsotg, hs_ep->index, mps, mc, dir_in);\n\n\t \n\ths_ep->isochronous = 0;\n\ths_ep->periodic = 0;\n\ths_ep->halted = 0;\n\ths_ep->wedged = 0;\n\ths_ep->interval = desc->bInterval;\n\n\tswitch (ep_type) {\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tepctrl |= DXEPCTL_EPTYPE_ISO;\n\t\tepctrl |= DXEPCTL_SETEVENFR;\n\t\ths_ep->isochronous = 1;\n\t\ths_ep->interval = 1 << (desc->bInterval - 1);\n\t\ths_ep->target_frame = TARGET_FRAME_INITIAL;\n\t\ths_ep->next_desc = 0;\n\t\ths_ep->compl_desc = 0;\n\t\tif (dir_in) {\n\t\t\ths_ep->periodic = 1;\n\t\t\tmask = dwc2_readl(hsotg, DIEPMSK);\n\t\t\tmask |= DIEPMSK_NAKMSK;\n\t\t\tdwc2_writel(hsotg, mask, DIEPMSK);\n\t\t} else {\n\t\t\tepctrl |= DXEPCTL_SNAK;\n\t\t\tmask = dwc2_readl(hsotg, DOEPMSK);\n\t\t\tmask |= DOEPMSK_OUTTKNEPDISMSK;\n\t\t\tdwc2_writel(hsotg, mask, DOEPMSK);\n\t\t}\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tepctrl |= DXEPCTL_EPTYPE_BULK;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (dir_in)\n\t\t\ths_ep->periodic = 1;\n\n\t\tif (hsotg->gadget.speed == USB_SPEED_HIGH)\n\t\t\ths_ep->interval = 1 << (desc->bInterval - 1);\n\n\t\tepctrl |= DXEPCTL_EPTYPE_INTERRUPT;\n\t\tbreak;\n\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tepctrl |= DXEPCTL_EPTYPE_CONTROL;\n\t\tbreak;\n\t}\n\n\t \n\tif (dir_in && hsotg->dedicated_fifos) {\n\t\tunsigned fifo_count = dwc2_hsotg_tx_fifo_count(hsotg);\n\t\tu32 fifo_index = 0;\n\t\tu32 fifo_size = UINT_MAX;\n\n\t\tsize = hs_ep->ep.maxpacket * hs_ep->mc;\n\t\tfor (i = 1; i <= fifo_count; ++i) {\n\t\t\tif (hsotg->fifo_map & (1 << i))\n\t\t\t\tcontinue;\n\t\t\tval = dwc2_readl(hsotg, DPTXFSIZN(i));\n\t\t\tval = (val >> FIFOSIZE_DEPTH_SHIFT) * 4;\n\t\t\tif (val < size)\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tif (val < fifo_size) {\n\t\t\t\tfifo_size = val;\n\t\t\t\tfifo_index = i;\n\t\t\t}\n\t\t}\n\t\tif (!fifo_index) {\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"%s: No suitable fifo found\\n\", __func__);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error1;\n\t\t}\n\t\tepctrl &= ~(DXEPCTL_TXFNUM_LIMIT << DXEPCTL_TXFNUM_SHIFT);\n\t\thsotg->fifo_map |= 1 << fifo_index;\n\t\tepctrl |= DXEPCTL_TXFNUM(fifo_index);\n\t\ths_ep->fifo_index = fifo_index;\n\t\ths_ep->fifo_size = fifo_size;\n\t}\n\n\t \n\tif (index && !hs_ep->isochronous)\n\t\tepctrl |= DXEPCTL_SETD0PID;\n\n\t \n\n\tif (hsotg->gadget.speed == USB_SPEED_FULL &&\n\t    hs_ep->isochronous && dir_in) {\n\t\t \n\t\tu32 gsnpsid = dwc2_readl(hsotg, GSNPSID);\n\n\t\tif ((gsnpsid >= DWC2_CORE_REV_2_72a &&\n\t\t     gsnpsid <= DWC2_CORE_REV_4_00a) ||\n\t\t     gsnpsid == DWC2_FS_IOT_REV_1_00a ||\n\t\t     gsnpsid == DWC2_HS_IOT_REV_1_00a)\n\t\t\tepctrl |= DXEPCTL_CNAK;\n\t}\n\n\tdev_dbg(hsotg->dev, \"%s: write DxEPCTL=0x%08x\\n\",\n\t\t__func__, epctrl);\n\n\tdwc2_writel(hsotg, epctrl, epctrl_reg);\n\tdev_dbg(hsotg->dev, \"%s: read DxEPCTL=0x%08x\\n\",\n\t\t__func__, dwc2_readl(hsotg, epctrl_reg));\n\n\t \n\tdwc2_hsotg_ctrl_epint(hsotg, index, dir_in, 1);\n\nerror1:\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\nerror2:\n\tif (ret && using_desc_dma(hsotg) && hs_ep->desc_list) {\n\t\tdmam_free_coherent(hsotg->dev, desc_num *\n\t\t\tsizeof(struct dwc2_dma_desc),\n\t\t\ths_ep->desc_list, hs_ep->desc_list_dma);\n\t\ths_ep->desc_list = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int dwc2_hsotg_ep_disable(struct usb_ep *ep)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tint dir_in = hs_ep->dir_in;\n\tint index = hs_ep->index;\n\tu32 epctrl_reg;\n\tu32 ctrl;\n\n\tdev_dbg(hsotg->dev, \"%s(ep %p)\\n\", __func__, ep);\n\n\tif (ep == &hsotg->eps_out[0]->ep) {\n\t\tdev_err(hsotg->dev, \"%s: called for ep0\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (hsotg->op_state != OTG_STATE_B_PERIPHERAL) {\n\t\tdev_err(hsotg->dev, \"%s: called in host mode?\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tepctrl_reg = dir_in ? DIEPCTL(index) : DOEPCTL(index);\n\n\tctrl = dwc2_readl(hsotg, epctrl_reg);\n\n\tif (ctrl & DXEPCTL_EPENA)\n\t\tdwc2_hsotg_ep_stop_xfr(hsotg, hs_ep);\n\n\tctrl &= ~DXEPCTL_EPENA;\n\tctrl &= ~DXEPCTL_USBACTEP;\n\tctrl |= DXEPCTL_SNAK;\n\n\tdev_dbg(hsotg->dev, \"%s: DxEPCTL=0x%08x\\n\", __func__, ctrl);\n\tdwc2_writel(hsotg, ctrl, epctrl_reg);\n\n\t \n\tdwc2_hsotg_ctrl_epint(hsotg, hs_ep->index, hs_ep->dir_in, 0);\n\n\t \n\tkill_all_requests(hsotg, hs_ep, -ESHUTDOWN);\n\n\thsotg->fifo_map &= ~(1 << hs_ep->fifo_index);\n\ths_ep->fifo_index = 0;\n\ths_ep->fifo_size = 0;\n\n\treturn 0;\n}\n\nstatic int dwc2_hsotg_ep_disable_lock(struct usb_ep *ep)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hsotg = hs_ep->parent;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tret = dwc2_hsotg_ep_disable(ep);\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\treturn ret;\n}\n\n \nstatic bool on_list(struct dwc2_hsotg_ep *ep, struct dwc2_hsotg_req *test)\n{\n\tstruct dwc2_hsotg_req *req, *treq;\n\n\tlist_for_each_entry_safe(req, treq, &ep->queue, queue) {\n\t\tif (req == test)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n \nstatic int dwc2_hsotg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct dwc2_hsotg_req *hs_req = our_req(req);\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\tunsigned long flags;\n\n\tdev_dbg(hs->dev, \"ep_dequeue(%p,%p)\\n\", ep, req);\n\n\tspin_lock_irqsave(&hs->lock, flags);\n\n\tif (!on_list(hs_ep, hs_req)) {\n\t\tspin_unlock_irqrestore(&hs->lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (req == &hs_ep->req->req)\n\t\tdwc2_hsotg_ep_stop_xfr(hs, hs_ep);\n\n\tdwc2_hsotg_complete_request(hs, hs_ep, hs_req, -ECONNRESET);\n\tspin_unlock_irqrestore(&hs->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int dwc2_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\n\tunsigned long\tflags;\n\tint\t\tret;\n\n\tspin_lock_irqsave(&hs->lock, flags);\n\ths_ep->wedged = 1;\n\tret = dwc2_hsotg_ep_sethalt(ep, 1, false);\n\tspin_unlock_irqrestore(&hs->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int dwc2_hsotg_ep_sethalt(struct usb_ep *ep, int value, bool now)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\tint index = hs_ep->index;\n\tu32 epreg;\n\tu32 epctl;\n\tu32 xfertype;\n\n\tdev_info(hs->dev, \"%s(ep %p %s, %d)\\n\", __func__, ep, ep->name, value);\n\n\tif (index == 0) {\n\t\tif (value)\n\t\t\tdwc2_hsotg_stall_ep0(hs);\n\t\telse\n\t\t\tdev_warn(hs->dev,\n\t\t\t\t \"%s: can't clear halt on ep0\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (hs_ep->isochronous) {\n\t\tdev_err(hs->dev, \"%s is Isochronous Endpoint\\n\", ep->name);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!now && value && !list_empty(&hs_ep->queue)) {\n\t\tdev_dbg(hs->dev, \"%s request is pending, cannot halt\\n\",\n\t\t\tep->name);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (hs_ep->dir_in) {\n\t\tepreg = DIEPCTL(index);\n\t\tepctl = dwc2_readl(hs, epreg);\n\n\t\tif (value) {\n\t\t\tepctl |= DXEPCTL_STALL | DXEPCTL_SNAK;\n\t\t\tif (epctl & DXEPCTL_EPENA)\n\t\t\t\tepctl |= DXEPCTL_EPDIS;\n\t\t} else {\n\t\t\tepctl &= ~DXEPCTL_STALL;\n\t\t\ths_ep->wedged = 0;\n\t\t\txfertype = epctl & DXEPCTL_EPTYPE_MASK;\n\t\t\tif (xfertype == DXEPCTL_EPTYPE_BULK ||\n\t\t\t    xfertype == DXEPCTL_EPTYPE_INTERRUPT)\n\t\t\t\tepctl |= DXEPCTL_SETD0PID;\n\t\t}\n\t\tdwc2_writel(hs, epctl, epreg);\n\t} else {\n\t\tepreg = DOEPCTL(index);\n\t\tepctl = dwc2_readl(hs, epreg);\n\n\t\tif (value) {\n\t\t\t \n\t\t\tdwc2_hsotg_en_gsint(hs, GINTSTS_GOUTNAKEFF);\n\n\t\t\tif (!(dwc2_readl(hs, GINTSTS) & GINTSTS_GOUTNAKEFF))\n\t\t\t\tdwc2_set_bit(hs, DCTL, DCTL_SGOUTNAK);\n\t\t\t \n\t\t} else {\n\t\t\tepctl &= ~DXEPCTL_STALL;\n\t\t\ths_ep->wedged = 0;\n\t\t\txfertype = epctl & DXEPCTL_EPTYPE_MASK;\n\t\t\tif (xfertype == DXEPCTL_EPTYPE_BULK ||\n\t\t\t    xfertype == DXEPCTL_EPTYPE_INTERRUPT)\n\t\t\t\tepctl |= DXEPCTL_SETD0PID;\n\t\t\tdwc2_writel(hs, epctl, epreg);\n\t\t}\n\t}\n\n\ths_ep->halted = value;\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_ep_sethalt_lock(struct usb_ep *ep, int value)\n{\n\tstruct dwc2_hsotg_ep *hs_ep = our_ep(ep);\n\tstruct dwc2_hsotg *hs = hs_ep->parent;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&hs->lock, flags);\n\tret = dwc2_hsotg_ep_sethalt(ep, value, false);\n\tspin_unlock_irqrestore(&hs->lock, flags);\n\n\treturn ret;\n}\n\nstatic const struct usb_ep_ops dwc2_hsotg_ep_ops = {\n\t.enable\t\t= dwc2_hsotg_ep_enable,\n\t.disable\t= dwc2_hsotg_ep_disable_lock,\n\t.alloc_request\t= dwc2_hsotg_ep_alloc_request,\n\t.free_request\t= dwc2_hsotg_ep_free_request,\n\t.queue\t\t= dwc2_hsotg_ep_queue_lock,\n\t.dequeue\t= dwc2_hsotg_ep_dequeue,\n\t.set_halt\t= dwc2_hsotg_ep_sethalt_lock,\n\t.set_wedge\t= dwc2_gadget_ep_set_wedge,\n\t \n};\n\n \nstatic void dwc2_hsotg_init(struct dwc2_hsotg *hsotg)\n{\n\t \n\n\tdwc2_writel(hsotg, DIEPMSK_TIMEOUTMSK | DIEPMSK_AHBERRMSK |\n\t\t    DIEPMSK_EPDISBLDMSK | DIEPMSK_XFERCOMPLMSK,\n\t\t    DIEPMSK);\n\n\tdwc2_writel(hsotg, DOEPMSK_SETUPMSK | DOEPMSK_AHBERRMSK |\n\t\t    DOEPMSK_EPDISBLDMSK | DOEPMSK_XFERCOMPLMSK,\n\t\t    DOEPMSK);\n\n\tdwc2_writel(hsotg, 0, DAINTMSK);\n\n\t \n\tdwc2_set_bit(hsotg, DCTL, DCTL_SFTDISCON);\n\n\t \n\n\tdev_dbg(hsotg->dev, \"GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\\n\",\n\t\tdwc2_readl(hsotg, GRXFSIZ),\n\t\tdwc2_readl(hsotg, GNPTXFSIZ));\n\n\tdwc2_hsotg_init_fifo(hsotg);\n\n\tif (using_dma(hsotg))\n\t\tdwc2_set_bit(hsotg, GAHBCFG, GAHBCFG_DMA_EN);\n}\n\n \nstatic int dwc2_hsotg_udc_start(struct usb_gadget *gadget,\n\t\t\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\tunsigned long flags;\n\tint ret;\n\n\tif (!hsotg) {\n\t\tpr_err(\"%s: called with no device\\n\", __func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (!driver) {\n\t\tdev_err(hsotg->dev, \"%s: no driver\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (driver->max_speed < USB_SPEED_FULL)\n\t\tdev_err(hsotg->dev, \"%s: bad speed\\n\", __func__);\n\n\tif (!driver->setup) {\n\t\tdev_err(hsotg->dev, \"%s: missing entry points\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tWARN_ON(hsotg->driver);\n\n\thsotg->driver = driver;\n\thsotg->gadget.dev.of_node = hsotg->dev->of_node;\n\thsotg->gadget.speed = USB_SPEED_UNKNOWN;\n\n\tif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\tret = dwc2_lowlevel_hw_enable(hsotg);\n\t\tif (ret)\n\t\t\tgoto err;\n\t}\n\n\tif (!IS_ERR_OR_NULL(hsotg->uphy))\n\t\totg_set_peripheral(hsotg->uphy->otg, &hsotg->gadget);\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tif (dwc2_hw_is_device(hsotg)) {\n\t\tdwc2_hsotg_init(hsotg);\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t}\n\n\thsotg->enabled = 0;\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tgadget->sg_supported = using_desc_dma(hsotg);\n\tdev_info(hsotg->dev, \"bound driver %s\\n\", driver->driver.name);\n\n\treturn 0;\n\nerr:\n\thsotg->driver = NULL;\n\treturn ret;\n}\n\n \nstatic int dwc2_hsotg_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\tunsigned long flags;\n\tint ep;\n\n\tif (!hsotg)\n\t\treturn -ENODEV;\n\n\t \n\tfor (ep = 1; ep < hsotg->num_of_eps; ep++) {\n\t\tif (hsotg->eps_in[ep])\n\t\t\tdwc2_hsotg_ep_disable_lock(&hsotg->eps_in[ep]->ep);\n\t\tif (hsotg->eps_out[ep])\n\t\t\tdwc2_hsotg_ep_disable_lock(&hsotg->eps_out[ep]->ep);\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\thsotg->driver = NULL;\n\thsotg->gadget.speed = USB_SPEED_UNKNOWN;\n\thsotg->enabled = 0;\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\tif (!IS_ERR_OR_NULL(hsotg->uphy))\n\t\totg_set_peripheral(hsotg->uphy->otg, NULL);\n\n\tif (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\tdwc2_lowlevel_hw_disable(hsotg);\n\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_gadget_getframe(struct usb_gadget *gadget)\n{\n\treturn dwc2_hsotg_read_frameno(to_hsotg(gadget));\n}\n\n \nstatic int dwc2_hsotg_set_selfpowered(struct usb_gadget *gadget,\n\t\t\t\t      int is_selfpowered)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tgadget->is_selfpowered = !!is_selfpowered;\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\tunsigned long flags;\n\n\tdev_dbg(hsotg->dev, \"%s: is_on: %d op_state: %d\\n\", __func__, is_on,\n\t\thsotg->op_state);\n\n\t \n\tif (hsotg->op_state != OTG_STATE_B_PERIPHERAL) {\n\t\thsotg->enabled = is_on;\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tif (is_on) {\n\t\thsotg->enabled = 1;\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t\t \n\t\tdwc2_enable_acg(hsotg);\n\t\tdwc2_hsotg_core_connect(hsotg);\n\t} else {\n\t\tdwc2_hsotg_core_disconnect(hsotg);\n\t\tdwc2_hsotg_disconnect(hsotg);\n\t\thsotg->enabled = 0;\n\t}\n\n\thsotg->gadget.speed = USB_SPEED_UNKNOWN;\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\treturn 0;\n}\n\nstatic int dwc2_hsotg_vbus_session(struct usb_gadget *gadget, int is_active)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\tunsigned long flags;\n\n\tdev_dbg(hsotg->dev, \"%s: is_active: %d\\n\", __func__, is_active);\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\n\t \n\tif (hsotg->lx_state == DWC2_L2 && hsotg->in_ppd)\n\t\t \n\t\tdwc2_exit_partial_power_down(hsotg, 0, false);\n\n\tif (is_active) {\n\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t\tif (hsotg->enabled) {\n\t\t\t \n\t\t\tdwc2_enable_acg(hsotg);\n\t\t\tdwc2_hsotg_core_connect(hsotg);\n\t\t}\n\t} else {\n\t\tdwc2_hsotg_core_disconnect(hsotg);\n\t\tdwc2_hsotg_disconnect(hsotg);\n\t}\n\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\treturn 0;\n}\n\n \nstatic int dwc2_hsotg_vbus_draw(struct usb_gadget *gadget, unsigned int mA)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(gadget);\n\n\tif (IS_ERR_OR_NULL(hsotg->uphy))\n\t\treturn -ENOTSUPP;\n\treturn usb_phy_set_power(hsotg->uphy, mA);\n}\n\nstatic void dwc2_gadget_set_speed(struct usb_gadget *g, enum usb_device_speed speed)\n{\n\tstruct dwc2_hsotg *hsotg = to_hsotg(g);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hsotg->lock, flags);\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\t\thsotg->params.speed = DWC2_SPEED_PARAM_HIGH;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\thsotg->params.speed = DWC2_SPEED_PARAM_FULL;\n\t\tbreak;\n\tcase USB_SPEED_LOW:\n\t\thsotg->params.speed = DWC2_SPEED_PARAM_LOW;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(hsotg->dev, \"invalid speed (%d)\\n\", speed);\n\t}\n\tspin_unlock_irqrestore(&hsotg->lock, flags);\n}\n\nstatic const struct usb_gadget_ops dwc2_hsotg_gadget_ops = {\n\t.get_frame\t= dwc2_hsotg_gadget_getframe,\n\t.set_selfpowered\t= dwc2_hsotg_set_selfpowered,\n\t.udc_start\t\t= dwc2_hsotg_udc_start,\n\t.udc_stop\t\t= dwc2_hsotg_udc_stop,\n\t.pullup                 = dwc2_hsotg_pullup,\n\t.udc_set_speed\t\t= dwc2_gadget_set_speed,\n\t.vbus_session\t\t= dwc2_hsotg_vbus_session,\n\t.vbus_draw\t\t= dwc2_hsotg_vbus_draw,\n};\n\n \nstatic void dwc2_hsotg_initep(struct dwc2_hsotg *hsotg,\n\t\t\t      struct dwc2_hsotg_ep *hs_ep,\n\t\t\t\t       int epnum,\n\t\t\t\t       bool dir_in)\n{\n\tchar *dir;\n\n\tif (epnum == 0)\n\t\tdir = \"\";\n\telse if (dir_in)\n\t\tdir = \"in\";\n\telse\n\t\tdir = \"out\";\n\n\ths_ep->dir_in = dir_in;\n\ths_ep->index = epnum;\n\n\tsnprintf(hs_ep->name, sizeof(hs_ep->name), \"ep%d%s\", epnum, dir);\n\n\tINIT_LIST_HEAD(&hs_ep->queue);\n\tINIT_LIST_HEAD(&hs_ep->ep.ep_list);\n\n\t \n\tif (epnum)\n\t\tlist_add_tail(&hs_ep->ep.ep_list, &hsotg->gadget.ep_list);\n\n\ths_ep->parent = hsotg;\n\ths_ep->ep.name = hs_ep->name;\n\n\tif (hsotg->params.speed == DWC2_SPEED_PARAM_LOW)\n\t\tusb_ep_set_maxpacket_limit(&hs_ep->ep, 8);\n\telse\n\t\tusb_ep_set_maxpacket_limit(&hs_ep->ep,\n\t\t\t\t\t   epnum ? 1024 : EP0_MPS_LIMIT);\n\ths_ep->ep.ops = &dwc2_hsotg_ep_ops;\n\n\tif (epnum == 0) {\n\t\ths_ep->ep.caps.type_control = true;\n\t} else {\n\t\tif (hsotg->params.speed != DWC2_SPEED_PARAM_LOW) {\n\t\t\ths_ep->ep.caps.type_iso = true;\n\t\t\ths_ep->ep.caps.type_bulk = true;\n\t\t}\n\t\ths_ep->ep.caps.type_int = true;\n\t}\n\n\tif (dir_in)\n\t\ths_ep->ep.caps.dir_in = true;\n\telse\n\t\ths_ep->ep.caps.dir_out = true;\n\n\t \n\n\tif (using_dma(hsotg)) {\n\t\tu32 next = DXEPCTL_NEXTEP((epnum + 1) % 15);\n\n\t\tif (dir_in)\n\t\t\tdwc2_writel(hsotg, next, DIEPCTL(epnum));\n\t\telse\n\t\t\tdwc2_writel(hsotg, next, DOEPCTL(epnum));\n\t}\n}\n\n \nstatic int dwc2_hsotg_hw_cfg(struct dwc2_hsotg *hsotg)\n{\n\tu32 cfg;\n\tu32 ep_type;\n\tu32 i;\n\n\t \n\n\thsotg->num_of_eps = hsotg->hw_params.num_dev_ep;\n\n\t \n\thsotg->num_of_eps++;\n\n\thsotg->eps_in[0] = devm_kzalloc(hsotg->dev,\n\t\t\t\t\tsizeof(struct dwc2_hsotg_ep),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!hsotg->eps_in[0])\n\t\treturn -ENOMEM;\n\t \n\thsotg->eps_out[0] = hsotg->eps_in[0];\n\n\tcfg = hsotg->hw_params.dev_ep_dirs;\n\tfor (i = 1, cfg >>= 2; i < hsotg->num_of_eps; i++, cfg >>= 2) {\n\t\tep_type = cfg & 3;\n\t\t \n\t\tif (!(ep_type & 2)) {\n\t\t\thsotg->eps_in[i] = devm_kzalloc(hsotg->dev,\n\t\t\t\tsizeof(struct dwc2_hsotg_ep), GFP_KERNEL);\n\t\t\tif (!hsotg->eps_in[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t\t \n\t\tif (!(ep_type & 1)) {\n\t\t\thsotg->eps_out[i] = devm_kzalloc(hsotg->dev,\n\t\t\t\tsizeof(struct dwc2_hsotg_ep), GFP_KERNEL);\n\t\t\tif (!hsotg->eps_out[i])\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\thsotg->fifo_mem = hsotg->hw_params.total_fifo_size;\n\thsotg->dedicated_fifos = hsotg->hw_params.en_multiple_tx_fifo;\n\n\tdev_info(hsotg->dev, \"EPs: %d, %s fifos, %d entries in SPRAM\\n\",\n\t\t hsotg->num_of_eps,\n\t\t hsotg->dedicated_fifos ? \"dedicated\" : \"shared\",\n\t\t hsotg->fifo_mem);\n\treturn 0;\n}\n\n \nstatic void dwc2_hsotg_dump(struct dwc2_hsotg *hsotg)\n{\n#ifdef DEBUG\n\tstruct device *dev = hsotg->dev;\n\tu32 val;\n\tint idx;\n\n\tdev_info(dev, \"DCFG=0x%08x, DCTL=0x%08x, DIEPMSK=%08x\\n\",\n\t\t dwc2_readl(hsotg, DCFG), dwc2_readl(hsotg, DCTL),\n\t\t dwc2_readl(hsotg, DIEPMSK));\n\n\tdev_info(dev, \"GAHBCFG=0x%08x, GHWCFG1=0x%08x\\n\",\n\t\t dwc2_readl(hsotg, GAHBCFG), dwc2_readl(hsotg, GHWCFG1));\n\n\tdev_info(dev, \"GRXFSIZ=0x%08x, GNPTXFSIZ=0x%08x\\n\",\n\t\t dwc2_readl(hsotg, GRXFSIZ), dwc2_readl(hsotg, GNPTXFSIZ));\n\n\t \n\n\tfor (idx = 1; idx < hsotg->num_of_eps; idx++) {\n\t\tval = dwc2_readl(hsotg, DPTXFSIZN(idx));\n\t\tdev_info(dev, \"DPTx[%d] FSize=%d, StAddr=0x%08x\\n\", idx,\n\t\t\t val >> FIFOSIZE_DEPTH_SHIFT,\n\t\t\t val & FIFOSIZE_STARTADDR_MASK);\n\t}\n\n\tfor (idx = 0; idx < hsotg->num_of_eps; idx++) {\n\t\tdev_info(dev,\n\t\t\t \"ep%d-in: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\\n\", idx,\n\t\t\t dwc2_readl(hsotg, DIEPCTL(idx)),\n\t\t\t dwc2_readl(hsotg, DIEPTSIZ(idx)),\n\t\t\t dwc2_readl(hsotg, DIEPDMA(idx)));\n\n\t\tval = dwc2_readl(hsotg, DOEPCTL(idx));\n\t\tdev_info(dev,\n\t\t\t \"ep%d-out: EPCTL=0x%08x, SIZ=0x%08x, DMA=0x%08x\\n\",\n\t\t\t idx, dwc2_readl(hsotg, DOEPCTL(idx)),\n\t\t\t dwc2_readl(hsotg, DOEPTSIZ(idx)),\n\t\t\t dwc2_readl(hsotg, DOEPDMA(idx)));\n\t}\n\n\tdev_info(dev, \"DVBUSDIS=0x%08x, DVBUSPULSE=%08x\\n\",\n\t\t dwc2_readl(hsotg, DVBUSDIS), dwc2_readl(hsotg, DVBUSPULSE));\n#endif\n}\n\n \nint dwc2_gadget_init(struct dwc2_hsotg *hsotg)\n{\n\tstruct device *dev = hsotg->dev;\n\tint epnum;\n\tint ret;\n\n\t \n\tdev_dbg(dev, \"NonPeriodic TXFIFO size: %d\\n\",\n\t\thsotg->params.g_np_tx_fifo_size);\n\tdev_dbg(dev, \"RXFIFO size: %d\\n\", hsotg->params.g_rx_fifo_size);\n\n\tswitch (hsotg->params.speed) {\n\tcase DWC2_SPEED_PARAM_LOW:\n\t\thsotg->gadget.max_speed = USB_SPEED_LOW;\n\t\tbreak;\n\tcase DWC2_SPEED_PARAM_FULL:\n\t\thsotg->gadget.max_speed = USB_SPEED_FULL;\n\t\tbreak;\n\tdefault:\n\t\thsotg->gadget.max_speed = USB_SPEED_HIGH;\n\t\tbreak;\n\t}\n\n\thsotg->gadget.ops = &dwc2_hsotg_gadget_ops;\n\thsotg->gadget.name = dev_name(dev);\n\thsotg->gadget.otg_caps = &hsotg->params.otg_caps;\n\thsotg->remote_wakeup_allowed = 0;\n\n\tif (hsotg->params.lpm)\n\t\thsotg->gadget.lpm_capable = true;\n\n\tif (hsotg->dr_mode == USB_DR_MODE_OTG)\n\t\thsotg->gadget.is_otg = 1;\n\telse if (hsotg->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\n\tret = dwc2_hsotg_hw_cfg(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"Hardware configuration failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\thsotg->ctrl_buff = devm_kzalloc(hsotg->dev,\n\t\t\tDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\n\tif (!hsotg->ctrl_buff)\n\t\treturn -ENOMEM;\n\n\thsotg->ep0_buff = devm_kzalloc(hsotg->dev,\n\t\t\tDWC2_CTRL_BUFF_SIZE, GFP_KERNEL);\n\tif (!hsotg->ep0_buff)\n\t\treturn -ENOMEM;\n\n\tif (using_desc_dma(hsotg)) {\n\t\tret = dwc2_gadget_alloc_ctrl_desc_chains(hsotg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tret = devm_request_irq(hsotg->dev, hsotg->irq, dwc2_hsotg_irq,\n\t\t\t       IRQF_SHARED, dev_name(hsotg->dev), hsotg);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot claim IRQ for gadget\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\n\tif (hsotg->num_of_eps == 0) {\n\t\tdev_err(dev, \"wrong number of EPs (zero)\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\n\tINIT_LIST_HEAD(&hsotg->gadget.ep_list);\n\thsotg->gadget.ep0 = &hsotg->eps_out[0]->ep;\n\n\t \n\n\thsotg->ctrl_req = dwc2_hsotg_ep_alloc_request(&hsotg->eps_out[0]->ep,\n\t\t\t\t\t\t     GFP_KERNEL);\n\tif (!hsotg->ctrl_req) {\n\t\tdev_err(dev, \"failed to allocate ctrl req\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tfor (epnum = 0; epnum < hsotg->num_of_eps; epnum++) {\n\t\tif (hsotg->eps_in[epnum])\n\t\t\tdwc2_hsotg_initep(hsotg, hsotg->eps_in[epnum],\n\t\t\t\t\t  epnum, 1);\n\t\tif (hsotg->eps_out[epnum])\n\t\t\tdwc2_hsotg_initep(hsotg, hsotg->eps_out[epnum],\n\t\t\t\t\t  epnum, 0);\n\t}\n\n\tdwc2_hsotg_dump(hsotg);\n\n\treturn 0;\n}\n\n \nint dwc2_hsotg_remove(struct dwc2_hsotg *hsotg)\n{\n\tusb_del_gadget_udc(&hsotg->gadget);\n\tdwc2_hsotg_ep_free_request(&hsotg->eps_out[0]->ep, hsotg->ctrl_req);\n\n\treturn 0;\n}\n\nint dwc2_hsotg_suspend(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\n\tif (hsotg->lx_state != DWC2_L0)\n\t\treturn 0;\n\n\tif (hsotg->driver) {\n\t\tint ep;\n\n\t\tdev_info(hsotg->dev, \"suspending usb gadget %s\\n\",\n\t\t\t hsotg->driver->driver.name);\n\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tif (hsotg->enabled)\n\t\t\tdwc2_hsotg_core_disconnect(hsotg);\n\t\tdwc2_hsotg_disconnect(hsotg);\n\t\thsotg->gadget.speed = USB_SPEED_UNKNOWN;\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\n\t\tfor (ep = 1; ep < hsotg->num_of_eps; ep++) {\n\t\t\tif (hsotg->eps_in[ep])\n\t\t\t\tdwc2_hsotg_ep_disable_lock(&hsotg->eps_in[ep]->ep);\n\t\t\tif (hsotg->eps_out[ep])\n\t\t\t\tdwc2_hsotg_ep_disable_lock(&hsotg->eps_out[ep]->ep);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint dwc2_hsotg_resume(struct dwc2_hsotg *hsotg)\n{\n\tunsigned long flags;\n\n\tif (hsotg->lx_state == DWC2_L2)\n\t\treturn 0;\n\n\tif (hsotg->driver) {\n\t\tdev_info(hsotg->dev, \"resuming usb gadget %s\\n\",\n\t\t\t hsotg->driver->driver.name);\n\n\t\tspin_lock_irqsave(&hsotg->lock, flags);\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t\tif (hsotg->enabled) {\n\t\t\t \n\t\t\tdwc2_enable_acg(hsotg);\n\t\t\tdwc2_hsotg_core_connect(hsotg);\n\t\t}\n\t\tspin_unlock_irqrestore(&hsotg->lock, flags);\n\t}\n\n\treturn 0;\n}\n\n \nint dwc2_backup_device_registers(struct dwc2_hsotg *hsotg)\n{\n\tstruct dwc2_dregs_backup *dr;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\tdr = &hsotg->dr_backup;\n\n\tdr->dcfg = dwc2_readl(hsotg, DCFG);\n\tdr->dctl = dwc2_readl(hsotg, DCTL);\n\tdr->daintmsk = dwc2_readl(hsotg, DAINTMSK);\n\tdr->diepmsk = dwc2_readl(hsotg, DIEPMSK);\n\tdr->doepmsk = dwc2_readl(hsotg, DOEPMSK);\n\n\tfor (i = 0; i < hsotg->num_of_eps; i++) {\n\t\t \n\t\tdr->diepctl[i] = dwc2_readl(hsotg, DIEPCTL(i));\n\n\t\t \n\t\tif (dr->diepctl[i] & DXEPCTL_DPID)\n\t\t\tdr->diepctl[i] |= DXEPCTL_SETD1PID;\n\t\telse\n\t\t\tdr->diepctl[i] |= DXEPCTL_SETD0PID;\n\n\t\tdr->dieptsiz[i] = dwc2_readl(hsotg, DIEPTSIZ(i));\n\t\tdr->diepdma[i] = dwc2_readl(hsotg, DIEPDMA(i));\n\n\t\t \n\t\tdr->doepctl[i] = dwc2_readl(hsotg, DOEPCTL(i));\n\n\t\t \n\t\tif (dr->doepctl[i] & DXEPCTL_DPID)\n\t\t\tdr->doepctl[i] |= DXEPCTL_SETD1PID;\n\t\telse\n\t\t\tdr->doepctl[i] |= DXEPCTL_SETD0PID;\n\n\t\tdr->doeptsiz[i] = dwc2_readl(hsotg, DOEPTSIZ(i));\n\t\tdr->doepdma[i] = dwc2_readl(hsotg, DOEPDMA(i));\n\t\tdr->dtxfsiz[i] = dwc2_readl(hsotg, DPTXFSIZN(i));\n\t}\n\tdr->valid = true;\n\treturn 0;\n}\n\n \nint dwc2_restore_device_registers(struct dwc2_hsotg *hsotg, int remote_wakeup)\n{\n\tstruct dwc2_dregs_backup *dr;\n\tint i;\n\n\tdev_dbg(hsotg->dev, \"%s\\n\", __func__);\n\n\t \n\tdr = &hsotg->dr_backup;\n\tif (!dr->valid) {\n\t\tdev_err(hsotg->dev, \"%s: no device registers to restore\\n\",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\tdr->valid = false;\n\n\tif (!remote_wakeup)\n\t\tdwc2_writel(hsotg, dr->dctl, DCTL);\n\n\tdwc2_writel(hsotg, dr->daintmsk, DAINTMSK);\n\tdwc2_writel(hsotg, dr->diepmsk, DIEPMSK);\n\tdwc2_writel(hsotg, dr->doepmsk, DOEPMSK);\n\n\tfor (i = 0; i < hsotg->num_of_eps; i++) {\n\t\t \n\t\tdwc2_writel(hsotg, dr->dieptsiz[i], DIEPTSIZ(i));\n\t\tdwc2_writel(hsotg, dr->diepdma[i], DIEPDMA(i));\n\t\tdwc2_writel(hsotg, dr->doeptsiz[i], DOEPTSIZ(i));\n\t\t \n\t\tif (using_desc_dma(hsotg) &&\n\t\t    (dr->diepctl[i] & DXEPCTL_EPENA))\n\t\t\tdr->diepdma[i] = hsotg->eps_in[i]->desc_list_dma;\n\t\tdwc2_writel(hsotg, dr->dtxfsiz[i], DPTXFSIZN(i));\n\t\tdwc2_writel(hsotg, dr->diepctl[i], DIEPCTL(i));\n\t\t \n\t\tdwc2_writel(hsotg, dr->doeptsiz[i], DOEPTSIZ(i));\n\t\t \n\t\tif (using_desc_dma(hsotg) &&\n\t\t    (dr->doepctl[i] & DXEPCTL_EPENA))\n\t\t\tdr->doepdma[i] = hsotg->eps_out[i]->desc_list_dma;\n\t\tdwc2_writel(hsotg, dr->doepdma[i], DOEPDMA(i));\n\t\tdwc2_writel(hsotg, dr->doepctl[i], DOEPCTL(i));\n\t}\n\n\treturn 0;\n}\n\n \nvoid dwc2_gadget_init_lpm(struct dwc2_hsotg *hsotg)\n{\n\tu32 val;\n\n\tif (!hsotg->params.lpm)\n\t\treturn;\n\n\tval = GLPMCFG_LPMCAP | GLPMCFG_APPL1RES;\n\tval |= hsotg->params.hird_threshold_en ? GLPMCFG_HIRD_THRES_EN : 0;\n\tval |= hsotg->params.lpm_clock_gating ? GLPMCFG_ENBLSLPM : 0;\n\tval |= hsotg->params.hird_threshold << GLPMCFG_HIRD_THRES_SHIFT;\n\tval |= hsotg->params.besl ? GLPMCFG_ENBESL : 0;\n\tval |= GLPMCFG_LPM_REJECT_CTRL_CONTROL;\n\tval |= GLPMCFG_LPM_ACCEPT_CTRL_ISOC;\n\tdwc2_writel(hsotg, val, GLPMCFG);\n\tdev_dbg(hsotg->dev, \"GLPMCFG=0x%08x\\n\", dwc2_readl(hsotg, GLPMCFG));\n\n\t \n\tif (hsotg->params.service_interval)\n\t\tdwc2_set_bit(hsotg, GINTMSK2, GINTMSK2_WKUP_ALERT_INT_MSK);\n}\n\n \nvoid dwc2_gadget_program_ref_clk(struct dwc2_hsotg *hsotg)\n{\n\tu32 val = 0;\n\n\tval |= GREFCLK_REF_CLK_MODE;\n\tval |= hsotg->params.ref_clk_per << GREFCLK_REFCLKPER_SHIFT;\n\tval |= hsotg->params.sof_cnt_wkup_alert <<\n\t       GREFCLK_SOF_CNT_WKUP_ALERT_SHIFT;\n\n\tdwc2_writel(hsotg, val, GREFCLK);\n\tdev_dbg(hsotg->dev, \"GREFCLK=0x%08x\\n\", dwc2_readl(hsotg, GREFCLK));\n}\n\n \nint dwc2_gadget_enter_hibernation(struct dwc2_hsotg *hsotg)\n{\n\tu32 gpwrdn;\n\tint ret = 0;\n\n\t \n\thsotg->lx_state = DWC2_L2;\n\tdev_dbg(hsotg->dev, \"Start of hibernation completed\\n\");\n\tret = dwc2_backup_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup global registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\tret = dwc2_backup_device_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup device registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tgpwrdn = GPWRDN_PWRDNRSTN;\n\tgpwrdn |= GPWRDN_PMUACTV;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\thsotg->hibernated = 1;\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PMUINTSEL;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_RST_DET_MSK;\n\tgpwrdn |= GPWRDN_LNSTSCHG_MSK;\n\tgpwrdn |= GPWRDN_STS_CHGINT_MSK;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PWRDNCLMP;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn |= GPWRDN_PWRDNSWTCH;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\t \n\thsotg->gr_backup.gpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tdev_dbg(hsotg->dev, \"Hibernation completed\\n\");\n\n\treturn ret;\n}\n\n \nint dwc2_gadget_exit_hibernation(struct dwc2_hsotg *hsotg,\n\t\t\t\t int rem_wakeup, int reset)\n{\n\tu32 pcgcctl;\n\tu32 gpwrdn;\n\tu32 dctl;\n\tint ret = 0;\n\tstruct dwc2_gregs_backup *gr;\n\tstruct dwc2_dregs_backup *dr;\n\n\tgr = &hsotg->gr_backup;\n\tdr = &hsotg->dr_backup;\n\n\tif (!hsotg->hibernated) {\n\t\tdev_dbg(hsotg->dev, \"Already exited from Hibernation\\n\");\n\t\treturn 1;\n\t}\n\tdev_dbg(hsotg->dev,\n\t\t\"%s: called with rem_wakeup = %d reset = %d\\n\",\n\t\t__func__, rem_wakeup, reset);\n\n\tdwc2_hib_restore_common(hsotg, rem_wakeup, 0);\n\n\tif (!reset) {\n\t\t \n\t\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\t}\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_RESTORE;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tudelay(10);\n\n\tif (!rem_wakeup) {\n\t\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\t\tpcgcctl &= ~PCGCTL_RSTPDWNMODULE;\n\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t}\n\n\t \n\tdwc2_writel(hsotg, gr->gusbcfg, GUSBCFG);\n\tdwc2_writel(hsotg, dr->dcfg, DCFG);\n\tdwc2_writel(hsotg, dr->dctl, DCTL);\n\n\t \n\tif (reset)\n\t\tdwc2_clear_bit(hsotg, DCFG, DCFG_DEVADDR_MASK);\n\n\t \n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn &= ~GPWRDN_PMUACTV;\n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\n\tif (rem_wakeup) {\n\t\tudelay(10);\n\t\t \n\t\tdwc2_writel(hsotg, dr->dctl | DCTL_RMTWKUPSIG, DCTL);\n\t} else {\n\t\tudelay(50);\n\t\t \n\t\tdctl = dwc2_readl(hsotg, DCTL);\n\t\tdctl |= DCTL_PWRONPRGDONE;\n\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t}\n\t \n\tmdelay(2);\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tret = dwc2_restore_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to restore registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tret = dwc2_restore_device_registers(hsotg, rem_wakeup);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to restore device registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tif (rem_wakeup) {\n\t\tmdelay(10);\n\t\tdctl = dwc2_readl(hsotg, DCTL);\n\t\tdctl &= ~DCTL_RMTWKUPSIG;\n\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t}\n\n\thsotg->hibernated = 0;\n\thsotg->lx_state = DWC2_L0;\n\tdev_dbg(hsotg->dev, \"Hibernation recovery completes here\\n\");\n\n\treturn ret;\n}\n\n \nint dwc2_gadget_enter_partial_power_down(struct dwc2_hsotg *hsotg)\n{\n\tu32 pcgcctl;\n\tint ret = 0;\n\n\tdev_dbg(hsotg->dev, \"Entering device partial power down started.\\n\");\n\n\t \n\tret = dwc2_backup_global_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup global registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\tret = dwc2_backup_device_registers(hsotg);\n\tif (ret) {\n\t\tdev_err(hsotg->dev, \"%s: failed to backup device registers\\n\",\n\t\t\t__func__);\n\t\treturn ret;\n\t}\n\n\t \n\tdwc2_writel(hsotg, 0xffffffff, GINTSTS);\n\n\t \n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\n\tpcgcctl |= PCGCTL_PWRCLMP;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl |= PCGCTL_RSTPDWNMODULE;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\tudelay(5);\n\n\tpcgcctl |= PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\t \n\thsotg->in_ppd = 1;\n\thsotg->lx_state = DWC2_L2;\n\n\tdev_dbg(hsotg->dev, \"Entering device partial power down completed.\\n\");\n\n\treturn ret;\n}\n\n \nint dwc2_gadget_exit_partial_power_down(struct dwc2_hsotg *hsotg,\n\t\t\t\t\tbool restore)\n{\n\tu32 pcgcctl;\n\tu32 dctl;\n\tstruct dwc2_dregs_backup *dr;\n\tint ret = 0;\n\n\tdr = &hsotg->dr_backup;\n\n\tdev_dbg(hsotg->dev, \"Exiting device partial Power Down started.\\n\");\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_PWRCLMP;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgcctl &= ~PCGCTL_RSTPDWNMODULE;\n\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\n\tudelay(100);\n\tif (restore) {\n\t\tret = dwc2_restore_global_registers(hsotg);\n\t\tif (ret) {\n\t\t\tdev_err(hsotg->dev, \"%s: failed to restore registers\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t\t \n\t\tdwc2_writel(hsotg, dr->dcfg, DCFG);\n\n\t\tret = dwc2_restore_device_registers(hsotg, 0);\n\t\tif (ret) {\n\t\t\tdev_err(hsotg->dev, \"%s: failed to restore device registers\\n\",\n\t\t\t\t__func__);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tdctl = dwc2_readl(hsotg, DCTL);\n\tdctl |= DCTL_PWRONPRGDONE;\n\tdwc2_writel(hsotg, dctl, DCTL);\n\n\t \n\thsotg->in_ppd = 0;\n\thsotg->lx_state = DWC2_L0;\n\n\tdev_dbg(hsotg->dev, \"Exiting device partial Power Down completed.\\n\");\n\treturn ret;\n}\n\n \nvoid dwc2_gadget_enter_clock_gating(struct dwc2_hsotg *hsotg)\n{\n\tu32 pcgctl;\n\n\tdev_dbg(hsotg->dev, \"Entering device clock gating.\\n\");\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl |= PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl |= PCGCTL_GATEHCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\thsotg->lx_state = DWC2_L2;\n\thsotg->bus_suspended = true;\n}\n\n \nvoid dwc2_gadget_exit_clock_gating(struct dwc2_hsotg *hsotg, int rem_wakeup)\n{\n\tu32 pcgctl;\n\tu32 dctl;\n\n\tdev_dbg(hsotg->dev, \"Exiting device clock gating.\\n\");\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl &= ~PCGCTL_GATEHCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\t \n\tpcgctl = dwc2_readl(hsotg, PCGCTL);\n\tpcgctl &= ~PCGCTL_STOPPCLK;\n\tdwc2_writel(hsotg, pcgctl, PCGCTL);\n\tudelay(5);\n\n\tif (rem_wakeup) {\n\t\t \n\t\tdctl = dwc2_readl(hsotg, DCTL);\n\t\tdctl |= DCTL_RMTWKUPSIG;\n\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t}\n\n\t \n\tcall_gadget(hsotg, resume);\n\thsotg->lx_state = DWC2_L0;\n\thsotg->bus_suspended = false;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}