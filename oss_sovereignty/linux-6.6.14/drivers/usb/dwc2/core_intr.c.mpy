{
  "module_name": "core_intr.c",
  "hash_id": "7cce365e8db0cd38f9c8df436c6b866a3504b7d878b862415dee61b4954ae22c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/dwc2/core_intr.c",
  "human_readable_source": "\n \n\n \n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#include <linux/usb/hcd.h>\n#include <linux/usb/ch11.h>\n\n#include \"core.h\"\n#include \"hcd.h\"\n\nstatic const char *dwc2_op_state_str(struct dwc2_hsotg *hsotg)\n{\n\tswitch (hsotg->op_state) {\n\tcase OTG_STATE_A_HOST:\n\t\treturn \"a_host\";\n\tcase OTG_STATE_A_SUSPEND:\n\t\treturn \"a_suspend\";\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\treturn \"a_peripheral\";\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\treturn \"b_peripheral\";\n\tcase OTG_STATE_B_HOST:\n\t\treturn \"b_host\";\n\tdefault:\n\t\treturn \"unknown\";\n\t}\n}\n\n \nstatic void dwc2_handle_usb_port_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 hprt0 = dwc2_readl(hsotg, HPRT0);\n\n\tif (hprt0 & HPRT0_ENACHG) {\n\t\thprt0 &= ~HPRT0_ENA;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t}\n}\n\n \nstatic void dwc2_handle_mode_mismatch_intr(struct dwc2_hsotg *hsotg)\n{\n\t \n\tdwc2_writel(hsotg, GINTSTS_MODEMIS, GINTSTS);\n\n\tdev_warn(hsotg->dev, \"Mode Mismatch Interrupt: currently in %s mode\\n\",\n\t\t dwc2_is_host_mode(hsotg) ? \"Host\" : \"Device\");\n}\n\n \nstatic void dwc2_handle_otg_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 gotgint;\n\tu32 gotgctl;\n\tu32 gintmsk;\n\n\tgotgint = dwc2_readl(hsotg, GOTGINT);\n\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\tdev_dbg(hsotg->dev, \"++OTG Interrupt gotgint=%0x [%s]\\n\", gotgint,\n\t\tdwc2_op_state_str(hsotg));\n\n\tif (gotgint & GOTGINT_SES_END_DET) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\" ++OTG Interrupt: Session End Detected++ (%s)\\n\",\n\t\t\tdwc2_op_state_str(hsotg));\n\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\n\t\tif (dwc2_is_device_mode(hsotg))\n\t\t\tdwc2_hsotg_disconnect(hsotg);\n\n\t\tif (hsotg->op_state == OTG_STATE_B_HOST) {\n\t\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\t\t} else {\n\t\t\t \n\t\t\tif (gotgctl & GOTGCTL_DEVHNPEN) {\n\t\t\t\tdev_dbg(hsotg->dev, \"Session End Detected\\n\");\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"Device Not Connected/Responding!\\n\");\n\t\t\t}\n\n\t\t\t \n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L0;\n\t\t}\n\n\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\tgotgctl &= ~GOTGCTL_DEVHNPEN;\n\t\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\t}\n\n\tif (gotgint & GOTGINT_SES_REQ_SUC_STS_CHNG) {\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\" ++OTG Interrupt: Session Request Success Status Change++\\n\");\n\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\tif (gotgctl & GOTGCTL_SESREQSCS) {\n\t\t\tif (hsotg->params.phy_type == DWC2_PHY_TYPE_PARAM_FS &&\n\t\t\t    hsotg->params.i2c_enable) {\n\t\t\t\thsotg->srp_success = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\t\t\tgotgctl &= ~GOTGCTL_SESREQ;\n\t\t\t\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (gotgint & GOTGINT_HST_NEG_SUC_STS_CHNG) {\n\t\t \n\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\t \n\t\tif (hsotg->hw_params.snpsid >= DWC2_CORE_REV_3_00a)\n\t\t\tudelay(100);\n\t\tif (gotgctl & GOTGCTL_HSTNEGSCS) {\n\t\t\tif (dwc2_is_host_mode(hsotg)) {\n\t\t\t\thsotg->op_state = OTG_STATE_B_HOST;\n\t\t\t\t \n\t\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\t\tgintmsk &= ~GINTSTS_SOF;\n\t\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\n\t\t\t\t \n\t\t\t\tspin_unlock(&hsotg->lock);\n\n\t\t\t\t \n\t\t\t\tdwc2_hcd_start(hsotg);\n\t\t\t\tspin_lock(&hsotg->lock);\n\t\t\t\thsotg->op_state = OTG_STATE_B_HOST;\n\t\t\t}\n\t\t} else {\n\t\t\tgotgctl = dwc2_readl(hsotg, GOTGCTL);\n\t\t\tgotgctl &= ~(GOTGCTL_HNPREQ | GOTGCTL_DEVHNPEN);\n\t\t\tdwc2_writel(hsotg, gotgctl, GOTGCTL);\n\t\t\tdev_dbg(hsotg->dev, \"HNP Failed\\n\");\n\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\"Device Not Connected/Responding\\n\");\n\t\t}\n\t}\n\n\tif (gotgint & GOTGINT_HST_NEG_DET) {\n\t\t \n\t\tdev_dbg(hsotg->dev,\n\t\t\t\" ++OTG Interrupt: Host Negotiation Detected++ (%s)\\n\",\n\t\t\t(dwc2_is_host_mode(hsotg) ? \"Host\" : \"Device\"));\n\t\tif (dwc2_is_device_mode(hsotg)) {\n\t\t\tdev_dbg(hsotg->dev, \"a_suspend->a_peripheral (%d)\\n\",\n\t\t\t\thsotg->op_state);\n\t\t\tspin_unlock(&hsotg->lock);\n\t\t\tdwc2_hcd_disconnect(hsotg, false);\n\t\t\tspin_lock(&hsotg->lock);\n\t\t\thsotg->op_state = OTG_STATE_A_PERIPHERAL;\n\t\t} else {\n\t\t\t \n\t\t\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\t\t\tgintmsk &= ~GINTSTS_SOF;\n\t\t\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\t\t\tspin_unlock(&hsotg->lock);\n\t\t\tdwc2_hcd_start(hsotg);\n\t\t\tspin_lock(&hsotg->lock);\n\t\t\thsotg->op_state = OTG_STATE_A_HOST;\n\t\t}\n\t}\n\n\tif (gotgint & GOTGINT_A_DEV_TOUT_CHG)\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\" ++OTG Interrupt: A-Device Timeout Change++\\n\");\n\tif (gotgint & GOTGINT_DBNCE_DONE)\n\t\tdev_dbg(hsotg->dev, \" ++OTG Interrupt: Debounce Done++\\n\");\n\n\t \n\tdwc2_writel(hsotg, gotgint, GOTGINT);\n}\n\n \nstatic void dwc2_handle_conn_id_status_change_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintmsk;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_CONIDSTSCHNG, GINTSTS);\n\n\t \n\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\tgintmsk &= ~GINTSTS_SOF;\n\tdwc2_writel(hsotg, gintmsk, GINTMSK);\n\n\tdev_dbg(hsotg->dev, \" ++Connector ID Status Change Interrupt++  (%s)\\n\",\n\t\tdwc2_is_host_mode(hsotg) ? \"Host\" : \"Device\");\n\n\t \n\tif (hsotg->wq_otg)\n\t\tqueue_work(hsotg->wq_otg, &hsotg->wf_otg);\n}\n\n \nstatic void dwc2_handle_session_req_intr(struct dwc2_hsotg *hsotg)\n{\n\tint ret;\n\tu32 hprt0;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_SESSREQINT, GINTSTS);\n\n\tdev_dbg(hsotg->dev, \"Session request interrupt - lx_state=%d\\n\",\n\t\thsotg->lx_state);\n\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tif (hsotg->lx_state == DWC2_L2) {\n\t\t\tif (hsotg->in_ppd) {\n\t\t\t\tret = dwc2_exit_partial_power_down(hsotg, 0,\n\t\t\t\t\t\t\t\t   true);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit power_down failed\\n\");\n\t\t\t}\n\n\t\t\t \n\t\t\tif (hsotg->params.power_down ==\n\t\t\t    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)\n\t\t\t\tdwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\t}\n\n\t\t \n\t\tdwc2_hsotg_disconnect(hsotg);\n\t} else {\n\t\t \n\t\thprt0 = dwc2_read_hprt0(hsotg);\n\t\thprt0 |= HPRT0_PWR;\n\t\tdwc2_writel(hsotg, hprt0, HPRT0);\n\t\t \n\t\tdwc2_hcd_connect(hsotg);\n\t}\n}\n\n \nstatic void dwc2_wakeup_from_lpm_l1(struct dwc2_hsotg *hsotg)\n{\n\tu32 glpmcfg;\n\tu32 i = 0;\n\n\tif (hsotg->lx_state != DWC2_L1) {\n\t\tdev_err(hsotg->dev, \"Core isn't in DWC2_L1 state\\n\");\n\t\treturn;\n\t}\n\n\tglpmcfg = dwc2_readl(hsotg, GLPMCFG);\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tdev_dbg(hsotg->dev, \"Exit from L1 state\\n\");\n\t\tglpmcfg &= ~GLPMCFG_ENBLSLPM;\n\t\tglpmcfg &= ~GLPMCFG_HIRD_THRES_EN;\n\t\tdwc2_writel(hsotg, glpmcfg, GLPMCFG);\n\n\t\tdo {\n\t\t\tglpmcfg = dwc2_readl(hsotg, GLPMCFG);\n\n\t\t\tif (!(glpmcfg & (GLPMCFG_COREL1RES_MASK |\n\t\t\t\t\t GLPMCFG_L1RESUMEOK | GLPMCFG_SLPSTS)))\n\t\t\t\tbreak;\n\n\t\t\tudelay(1);\n\t\t} while (++i < 200);\n\n\t\tif (i == 200) {\n\t\t\tdev_err(hsotg->dev, \"Failed to exit L1 sleep state in 200us.\\n\");\n\t\t\treturn;\n\t\t}\n\t\tdwc2_gadget_init_lpm(hsotg);\n\t} else {\n\t\t \n\t\tdev_err(hsotg->dev, \"Host side LPM is not supported.\\n\");\n\t\treturn;\n\t}\n\n\t \n\thsotg->lx_state = DWC2_L0;\n\n\t \n\tcall_gadget(hsotg, resume);\n}\n\n \nstatic void dwc2_handle_wakeup_detected_intr(struct dwc2_hsotg *hsotg)\n{\n\tint ret;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_WKUPINT, GINTSTS);\n\n\tdev_dbg(hsotg->dev, \"++Resume or Remote Wakeup Detected Interrupt++\\n\");\n\tdev_dbg(hsotg->dev, \"%s lxstate = %d\\n\", __func__, hsotg->lx_state);\n\n\tif (hsotg->lx_state == DWC2_L1) {\n\t\tdwc2_wakeup_from_lpm_l1(hsotg);\n\t\treturn;\n\t}\n\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tdev_dbg(hsotg->dev, \"DSTS=0x%0x\\n\",\n\t\t\tdwc2_readl(hsotg, DSTS));\n\t\tif (hsotg->lx_state == DWC2_L2) {\n\t\t\tif (hsotg->in_ppd) {\n\t\t\t\tu32 dctl = dwc2_readl(hsotg, DCTL);\n\t\t\t\t \n\t\t\t\tdctl &= ~DCTL_RMTWKUPSIG;\n\t\t\t\tdwc2_writel(hsotg, dctl, DCTL);\n\t\t\t\tret = dwc2_exit_partial_power_down(hsotg, 1,\n\t\t\t\t\t\t\t\t   true);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit partial_power_down failed\\n\");\n\t\t\t\tcall_gadget(hsotg, resume);\n\t\t\t}\n\n\t\t\t \n\t\t\tif (hsotg->params.power_down ==\n\t\t\t    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)\n\t\t\t\tdwc2_gadget_exit_clock_gating(hsotg, 0);\n\t\t} else {\n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L0;\n\t\t}\n\t} else {\n\t\tif (hsotg->lx_state == DWC2_L2) {\n\t\t\tif (hsotg->in_ppd) {\n\t\t\t\tret = dwc2_exit_partial_power_down(hsotg, 1,\n\t\t\t\t\t\t\t\t   true);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit partial_power_down failed\\n\");\n\t\t\t}\n\n\t\t\tif (hsotg->params.power_down ==\n\t\t\t    DWC2_POWER_DOWN_PARAM_NONE && hsotg->bus_suspended)\n\t\t\t\tdwc2_host_exit_clock_gating(hsotg, 1);\n\n\t\t\t \n\t\t\tif (hsotg->reset_phy_on_wake)\n\t\t\t\tdwc2_host_schedule_phy_reset(hsotg);\n\n\t\t\tmod_timer(&hsotg->wkp_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(71));\n\t\t} else {\n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L0;\n\t\t}\n\t}\n}\n\n \nstatic void dwc2_handle_disconnect_intr(struct dwc2_hsotg *hsotg)\n{\n\tdwc2_writel(hsotg, GINTSTS_DISCONNINT, GINTSTS);\n\n\tdev_dbg(hsotg->dev, \"++Disconnect Detected Interrupt++ (%s) %s\\n\",\n\t\tdwc2_is_host_mode(hsotg) ? \"Host\" : \"Device\",\n\t\tdwc2_op_state_str(hsotg));\n\n\tif (hsotg->op_state == OTG_STATE_A_HOST)\n\t\tdwc2_hcd_disconnect(hsotg, false);\n}\n\n \nstatic void dwc2_handle_usb_suspend_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 dsts;\n\tint ret;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_USBSUSP, GINTSTS);\n\n\tdev_dbg(hsotg->dev, \"USB SUSPEND\\n\");\n\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\t \n\t\tdsts = dwc2_readl(hsotg, DSTS);\n\t\tdev_dbg(hsotg->dev, \"%s: DSTS=0x%0x\\n\", __func__, dsts);\n\t\tdev_dbg(hsotg->dev,\n\t\t\t\"DSTS.Suspend Status=%d HWCFG4.Power Optimize=%d HWCFG4.Hibernation=%d\\n\",\n\t\t\t!!(dsts & DSTS_SUSPSTS),\n\t\t\thsotg->hw_params.power_optimized,\n\t\t\thsotg->hw_params.hibernation);\n\n\t\t \n\t\tif (!dwc2_is_device_connected(hsotg)) {\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"ignore suspend request before enumeration\\n\");\n\t\t\treturn;\n\t\t}\n\t\tif (dsts & DSTS_SUSPSTS) {\n\t\t\tswitch (hsotg->params.power_down) {\n\t\t\tcase DWC2_POWER_DOWN_PARAM_PARTIAL:\n\t\t\t\tret = dwc2_enter_partial_power_down(hsotg);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"enter partial_power_down failed\\n\");\n\n\t\t\t\tudelay(100);\n\n\t\t\t\t \n\t\t\t\tif (!IS_ERR_OR_NULL(hsotg->uphy))\n\t\t\t\t\tusb_phy_set_suspend(hsotg->uphy, true);\n\t\t\t\tbreak;\n\t\t\tcase DWC2_POWER_DOWN_PARAM_HIBERNATION:\n\t\t\t\tret = dwc2_enter_hibernation(hsotg, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"enter hibernation failed\\n\");\n\t\t\t\tbreak;\n\t\t\tcase DWC2_POWER_DOWN_PARAM_NONE:\n\t\t\t\t \n\t\t\t\tif (!hsotg->params.no_clock_gating)\n\t\t\t\t\tdwc2_gadget_enter_clock_gating(hsotg);\n\t\t\t}\n\n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L2;\n\n\t\t\t \n\t\t\tcall_gadget(hsotg, suspend);\n\t\t}\n\t} else {\n\t\tif (hsotg->op_state == OTG_STATE_A_PERIPHERAL) {\n\t\t\tdev_dbg(hsotg->dev, \"a_peripheral->a_host\\n\");\n\n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L2;\n\t\t\t \n\t\t\tspin_unlock(&hsotg->lock);\n\t\t\tdwc2_hcd_start(hsotg);\n\t\t\tspin_lock(&hsotg->lock);\n\t\t\thsotg->op_state = OTG_STATE_A_HOST;\n\t\t}\n\t}\n}\n\n \nstatic void dwc2_handle_lpm_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 glpmcfg;\n\tu32 pcgcctl;\n\tu32 hird;\n\tu32 hird_thres;\n\tu32 hird_thres_en;\n\tu32 enslpm;\n\n\t \n\tdwc2_writel(hsotg, GINTSTS_LPMTRANRCVD, GINTSTS);\n\n\tglpmcfg = dwc2_readl(hsotg, GLPMCFG);\n\n\tif (!(glpmcfg & GLPMCFG_LPMCAP)) {\n\t\tdev_err(hsotg->dev, \"Unexpected LPM interrupt\\n\");\n\t\treturn;\n\t}\n\n\third = (glpmcfg & GLPMCFG_HIRD_MASK) >> GLPMCFG_HIRD_SHIFT;\n\third_thres = (glpmcfg & GLPMCFG_HIRD_THRES_MASK &\n\t\t\t~GLPMCFG_HIRD_THRES_EN) >> GLPMCFG_HIRD_THRES_SHIFT;\n\third_thres_en = glpmcfg & GLPMCFG_HIRD_THRES_EN;\n\tenslpm = glpmcfg & GLPMCFG_ENBLSLPM;\n\n\tif (dwc2_is_device_mode(hsotg)) {\n\t\tdev_dbg(hsotg->dev, \"HIRD_THRES_EN = %d\\n\", hird_thres_en);\n\n\t\tif (hird_thres_en && hird >= hird_thres) {\n\t\t\tdev_dbg(hsotg->dev, \"L1 with utmi_l1_suspend_n\\n\");\n\t\t} else if (enslpm) {\n\t\t\tdev_dbg(hsotg->dev, \"L1 with utmi_sleep_n\\n\");\n\t\t} else {\n\t\t\tdev_dbg(hsotg->dev, \"Entering Sleep with L1 Gating\\n\");\n\n\t\t\tpcgcctl = dwc2_readl(hsotg, PCGCTL);\n\t\t\tpcgcctl |= PCGCTL_ENBL_SLEEP_GATING;\n\t\t\tdwc2_writel(hsotg, pcgcctl, PCGCTL);\n\t\t}\n\t\t \n\t\tudelay(10);\n\n\t\tglpmcfg = dwc2_readl(hsotg, GLPMCFG);\n\n\t\tif (glpmcfg & GLPMCFG_SLPSTS) {\n\t\t\t \n\t\t\thsotg->lx_state = DWC2_L1;\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\"Core is in L1 sleep glpmcfg=%08x\\n\", glpmcfg);\n\n\t\t\t \n\t\t\tcall_gadget(hsotg, suspend);\n\t\t}\n\t}\n}\n\n#define GINTMSK_COMMON\t(GINTSTS_WKUPINT | GINTSTS_SESSREQINT |\t\t\\\n\t\t\t GINTSTS_CONIDSTSCHNG | GINTSTS_OTGINT |\t\\\n\t\t\t GINTSTS_MODEMIS | GINTSTS_DISCONNINT |\t\t\\\n\t\t\t GINTSTS_USBSUSP | GINTSTS_PRTINT |\t\t\\\n\t\t\t GINTSTS_LPMTRANRCVD)\n\n \nstatic u32 dwc2_read_common_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 gintsts;\n\tu32 gintmsk;\n\tu32 gahbcfg;\n\tu32 gintmsk_common = GINTMSK_COMMON;\n\n\tgintsts = dwc2_readl(hsotg, GINTSTS);\n\tgintmsk = dwc2_readl(hsotg, GINTMSK);\n\tgahbcfg = dwc2_readl(hsotg, GAHBCFG);\n\n\t \n\tif (gintsts & gintmsk_common)\n\t\tdev_dbg(hsotg->dev, \"gintsts=%08x  gintmsk=%08x\\n\",\n\t\t\tgintsts, gintmsk);\n\n\tif (gahbcfg & GAHBCFG_GLBL_INTR_EN)\n\t\treturn gintsts & gintmsk & gintmsk_common;\n\telse\n\t\treturn 0;\n}\n\n \nstatic inline void dwc_handle_gpwrdn_disc_det(struct dwc2_hsotg *hsotg,\n\t\t\t\t\t      u32 gpwrdn)\n{\n\tu32 gpwrdn_tmp;\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp &= ~GPWRDN_PWRDNSWTCH;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\tudelay(5);\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp &= ~GPWRDN_PWRDNRSTN;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\tudelay(5);\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp &= ~GPWRDN_PWRDNCLMP;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\tudelay(5);\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp |= GPWRDN_PWRDNRSTN;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\tudelay(5);\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp &= ~GPWRDN_PMUINTSEL;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\n\t \n\tgpwrdn_tmp = dwc2_readl(hsotg, GPWRDN);\n\tgpwrdn_tmp &= ~GPWRDN_PMUACTV;\n\tdwc2_writel(hsotg, gpwrdn_tmp, GPWRDN);\n\n\thsotg->hibernated = 0;\n\thsotg->bus_suspended = 0;\n\n\tif (gpwrdn & GPWRDN_IDSTS) {\n\t\thsotg->op_state = OTG_STATE_B_PERIPHERAL;\n\t\tdwc2_core_init(hsotg, false);\n\t\tdwc2_enable_global_interrupts(hsotg);\n\t\tdwc2_hsotg_core_init_disconnected(hsotg, false);\n\t\tdwc2_hsotg_core_connect(hsotg);\n\t} else {\n\t\thsotg->op_state = OTG_STATE_A_HOST;\n\n\t\t \n\t\tdwc2_core_init(hsotg, false);\n\t\tdwc2_enable_global_interrupts(hsotg);\n\t\tdwc2_hcd_start(hsotg);\n\t}\n}\n\n \nstatic int dwc2_handle_gpwrdn_intr(struct dwc2_hsotg *hsotg)\n{\n\tu32 gpwrdn;\n\tint linestate;\n\tint ret = 0;\n\n\tgpwrdn = dwc2_readl(hsotg, GPWRDN);\n\t \n\tdwc2_writel(hsotg, gpwrdn, GPWRDN);\n\tlinestate = (gpwrdn & GPWRDN_LINESTATE_MASK) >> GPWRDN_LINESTATE_SHIFT;\n\tdev_dbg(hsotg->dev,\n\t\t\"%s: dwc2_handle_gpwrdwn_intr called gpwrdn= %08x\\n\", __func__,\n\t\tgpwrdn);\n\n\tif ((gpwrdn & GPWRDN_DISCONN_DET) &&\n\t    (gpwrdn & GPWRDN_DISCONN_DET_MSK) && !linestate) {\n\t\tdev_dbg(hsotg->dev, \"%s: GPWRDN_DISCONN_DET\\n\", __func__);\n\t\t \n\t\tdwc_handle_gpwrdn_disc_det(hsotg, gpwrdn);\n\t} else if ((gpwrdn & GPWRDN_LNSTSCHG) &&\n\t\t   (gpwrdn & GPWRDN_LNSTSCHG_MSK) && linestate) {\n\t\tdev_dbg(hsotg->dev, \"%s: GPWRDN_LNSTSCHG\\n\", __func__);\n\t\tif (hsotg->hw_params.hibernation &&\n\t\t    hsotg->hibernated) {\n\t\t\tif (gpwrdn & GPWRDN_IDSTS) {\n\t\t\t\tret = dwc2_exit_hibernation(hsotg, 0, 0, 0);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit hibernation failed.\\n\");\n\t\t\t\tcall_gadget(hsotg, resume);\n\t\t\t} else {\n\t\t\t\tret = dwc2_exit_hibernation(hsotg, 1, 0, 1);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\t\"exit hibernation failed.\\n\");\n\t\t\t}\n\t\t}\n\t} else if ((gpwrdn & GPWRDN_RST_DET) &&\n\t\t   (gpwrdn & GPWRDN_RST_DET_MSK)) {\n\t\tdev_dbg(hsotg->dev, \"%s: GPWRDN_RST_DET\\n\", __func__);\n\t\tif (!linestate) {\n\t\t\tret = dwc2_exit_hibernation(hsotg, 0, 1, 0);\n\t\t\tif (ret)\n\t\t\t\tdev_err(hsotg->dev,\n\t\t\t\t\t\"exit hibernation failed.\\n\");\n\t\t}\n\t} else if ((gpwrdn & GPWRDN_STS_CHGINT) &&\n\t\t   (gpwrdn & GPWRDN_STS_CHGINT_MSK)) {\n\t\tdev_dbg(hsotg->dev, \"%s: GPWRDN_STS_CHGINT\\n\", __func__);\n\t\t \n\t\tdwc_handle_gpwrdn_disc_det(hsotg, gpwrdn);\n\t}\n\n\treturn ret;\n}\n\n \nirqreturn_t dwc2_handle_common_intr(int irq, void *dev)\n{\n\tstruct dwc2_hsotg *hsotg = dev;\n\tu32 gintsts;\n\tirqreturn_t retval = IRQ_NONE;\n\n\tspin_lock(&hsotg->lock);\n\n\tif (!dwc2_is_controller_alive(hsotg)) {\n\t\tdev_warn(hsotg->dev, \"Controller is dead\\n\");\n\t\tgoto out;\n\t}\n\n\t \n\tif (dwc2_is_device_mode(hsotg))\n\t\thsotg->frame_number = (dwc2_readl(hsotg, DSTS)\n\t\t\t\t       & DSTS_SOFFN_MASK) >> DSTS_SOFFN_SHIFT;\n\telse\n\t\thsotg->frame_number = (dwc2_readl(hsotg, HFNUM)\n\t\t\t\t       & HFNUM_FRNUM_MASK) >> HFNUM_FRNUM_SHIFT;\n\n\tgintsts = dwc2_read_common_intr(hsotg);\n\tif (gintsts & ~GINTSTS_PRTINT)\n\t\tretval = IRQ_HANDLED;\n\n\t \n\tif (hsotg->hibernated) {\n\t\tdwc2_handle_gpwrdn_intr(hsotg);\n\t\tretval = IRQ_HANDLED;\n\t\tgoto out;\n\t}\n\n\tif (gintsts & GINTSTS_MODEMIS)\n\t\tdwc2_handle_mode_mismatch_intr(hsotg);\n\tif (gintsts & GINTSTS_OTGINT)\n\t\tdwc2_handle_otg_intr(hsotg);\n\tif (gintsts & GINTSTS_CONIDSTSCHNG)\n\t\tdwc2_handle_conn_id_status_change_intr(hsotg);\n\tif (gintsts & GINTSTS_DISCONNINT)\n\t\tdwc2_handle_disconnect_intr(hsotg);\n\tif (gintsts & GINTSTS_SESSREQINT)\n\t\tdwc2_handle_session_req_intr(hsotg);\n\tif (gintsts & GINTSTS_WKUPINT)\n\t\tdwc2_handle_wakeup_detected_intr(hsotg);\n\tif (gintsts & GINTSTS_USBSUSP)\n\t\tdwc2_handle_usb_suspend_intr(hsotg);\n\tif (gintsts & GINTSTS_LPMTRANRCVD)\n\t\tdwc2_handle_lpm_intr(hsotg);\n\n\tif (gintsts & GINTSTS_PRTINT) {\n\t\t \n\t\tif (dwc2_is_device_mode(hsotg)) {\n\t\t\tdev_dbg(hsotg->dev,\n\t\t\t\t\" --Port interrupt received in Device mode--\\n\");\n\t\t\tdwc2_handle_usb_port_intr(hsotg);\n\t\t\tretval = IRQ_HANDLED;\n\t\t}\n\t}\n\nout:\n\tspin_unlock(&hsotg->lock);\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}