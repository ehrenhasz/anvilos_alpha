{
  "module_name": "otg.c",
  "hash_id": "40d19417537973dfc7debb37ead742d7e4f79a1f3cc7f74c2be256ccc186cce3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/otg.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/usb/otg.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/chipidea.h>\n\n#include \"ci.h\"\n#include \"bits.h\"\n#include \"otg.h\"\n#include \"otg_fsm.h\"\n\n \nu32 hw_read_otgsc(struct ci_hdrc *ci, u32 mask)\n{\n\tstruct ci_hdrc_cable *cable;\n\tu32 val = hw_read(ci, OP_OTGSC, mask);\n\n\t \n\tcable = &ci->platdata->vbus_extcon;\n\tif (!IS_ERR(cable->edev) || ci->role_switch) {\n\t\tif (cable->changed)\n\t\t\tval |= OTGSC_BSVIS;\n\t\telse\n\t\t\tval &= ~OTGSC_BSVIS;\n\n\t\tif (cable->connected)\n\t\t\tval |= OTGSC_BSV;\n\t\telse\n\t\t\tval &= ~OTGSC_BSV;\n\n\t\tif (cable->enabled)\n\t\t\tval |= OTGSC_BSVIE;\n\t\telse\n\t\t\tval &= ~OTGSC_BSVIE;\n\t}\n\n\tcable = &ci->platdata->id_extcon;\n\tif (!IS_ERR(cable->edev) || ci->role_switch) {\n\t\tif (cable->changed)\n\t\t\tval |= OTGSC_IDIS;\n\t\telse\n\t\t\tval &= ~OTGSC_IDIS;\n\n\t\tif (cable->connected)\n\t\t\tval &= ~OTGSC_ID;  \n\t\telse\n\t\t\tval |= OTGSC_ID;  \n\n\t\tif (cable->enabled)\n\t\t\tval |= OTGSC_IDIE;\n\t\telse\n\t\t\tval &= ~OTGSC_IDIE;\n\t}\n\n\treturn val & mask;\n}\n\n \nvoid hw_write_otgsc(struct ci_hdrc *ci, u32 mask, u32 data)\n{\n\tstruct ci_hdrc_cable *cable;\n\n\tcable = &ci->platdata->vbus_extcon;\n\tif (!IS_ERR(cable->edev) || ci->role_switch) {\n\t\tif (data & mask & OTGSC_BSVIS)\n\t\t\tcable->changed = false;\n\n\t\t \n\t\tif (data & mask & OTGSC_BSVIE) {\n\t\t\tcable->enabled = true;\n\t\t\tdata &= ~OTGSC_BSVIE;\n\t\t} else if (mask & OTGSC_BSVIE) {\n\t\t\tcable->enabled = false;\n\t\t}\n\t}\n\n\tcable = &ci->platdata->id_extcon;\n\tif (!IS_ERR(cable->edev) || ci->role_switch) {\n\t\tif (data & mask & OTGSC_IDIS)\n\t\t\tcable->changed = false;\n\n\t\t \n\t\tif (data & mask & OTGSC_IDIE) {\n\t\t\tcable->enabled = true;\n\t\t\tdata &= ~OTGSC_IDIE;\n\t\t} else if (mask & OTGSC_IDIE) {\n\t\t\tcable->enabled = false;\n\t\t}\n\t}\n\n\thw_write(ci, OP_OTGSC, mask | OTGSC_INT_STATUS_BITS, data);\n}\n\n \nenum ci_role ci_otg_role(struct ci_hdrc *ci)\n{\n\tenum ci_role role = hw_read_otgsc(ci, OTGSC_ID)\n\t\t? CI_ROLE_GADGET\n\t\t: CI_ROLE_HOST;\n\n\treturn role;\n}\n\nvoid ci_handle_vbus_change(struct ci_hdrc *ci)\n{\n\tif (!ci->is_otg)\n\t\treturn;\n\n\tif (hw_read_otgsc(ci, OTGSC_BSV) && !ci->vbus_active)\n\t\tusb_gadget_vbus_connect(&ci->gadget);\n\telse if (!hw_read_otgsc(ci, OTGSC_BSV) && ci->vbus_active)\n\t\tusb_gadget_vbus_disconnect(&ci->gadget);\n}\n\n \nstatic int hw_wait_vbus_lower_bsv(struct ci_hdrc *ci)\n{\n\tunsigned long elapse = jiffies + msecs_to_jiffies(5000);\n\tu32 mask = OTGSC_BSV;\n\n\twhile (hw_read_otgsc(ci, mask)) {\n\t\tif (time_after(jiffies, elapse)) {\n\t\t\tdev_err(ci->dev, \"timeout waiting for %08x in OTGSC\\n\",\n\t\t\t\t\tmask);\n\t\t\treturn -ETIMEDOUT;\n\t\t}\n\t\tmsleep(20);\n\t}\n\n\treturn 0;\n}\n\nvoid ci_handle_id_switch(struct ci_hdrc *ci)\n{\n\tenum ci_role role;\n\n\tmutex_lock(&ci->mutex);\n\trole = ci_otg_role(ci);\n\tif (role != ci->role) {\n\t\tdev_dbg(ci->dev, \"switching from %s to %s\\n\",\n\t\t\tci_role(ci)->name, ci->roles[role]->name);\n\n\t\tif (ci->vbus_active && ci->role == CI_ROLE_GADGET)\n\t\t\t \n\t\t\tusb_gadget_vbus_disconnect(&ci->gadget);\n\n\t\tci_role_stop(ci);\n\n\t\tif (role == CI_ROLE_GADGET &&\n\t\t\t\tIS_ERR(ci->platdata->vbus_extcon.edev))\n\t\t\t \n\t\t\thw_wait_vbus_lower_bsv(ci);\n\n\t\tci_role_start(ci, role);\n\t\t \n\t\tif (role == CI_ROLE_GADGET)\n\t\t\tci_handle_vbus_change(ci);\n\t}\n\tmutex_unlock(&ci->mutex);\n}\n \nstatic void ci_otg_work(struct work_struct *work)\n{\n\tstruct ci_hdrc *ci = container_of(work, struct ci_hdrc, work);\n\n\tif (ci_otg_is_fsm_mode(ci) && !ci_otg_fsm_work(ci)) {\n\t\tenable_irq(ci->irq);\n\t\treturn;\n\t}\n\n\tpm_runtime_get_sync(ci->dev);\n\n\tif (ci->id_event) {\n\t\tci->id_event = false;\n\t\tci_handle_id_switch(ci);\n\t}\n\n\tif (ci->b_sess_valid_event) {\n\t\tci->b_sess_valid_event = false;\n\t\tci_handle_vbus_change(ci);\n\t}\n\n\tpm_runtime_put_sync(ci->dev);\n\n\tenable_irq(ci->irq);\n}\n\n\n \nint ci_hdrc_otg_init(struct ci_hdrc *ci)\n{\n\tINIT_WORK(&ci->work, ci_otg_work);\n\tci->wq = create_freezable_workqueue(\"ci_otg\");\n\tif (!ci->wq) {\n\t\tdev_err(ci->dev, \"can't create workqueue\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (ci_otg_is_fsm_mode(ci))\n\t\treturn ci_hdrc_otg_fsm_init(ci);\n\n\treturn 0;\n}\n\n \nvoid ci_hdrc_otg_destroy(struct ci_hdrc *ci)\n{\n\tif (ci->wq)\n\t\tdestroy_workqueue(ci->wq);\n\n\t \n\thw_write_otgsc(ci, OTGSC_INT_EN_BITS | OTGSC_INT_STATUS_BITS,\n\t\t\t\t\t\tOTGSC_INT_STATUS_BITS);\n\tif (ci_otg_is_fsm_mode(ci))\n\t\tci_hdrc_otg_fsm_remove(ci);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}