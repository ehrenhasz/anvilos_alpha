{
  "module_name": "ci_hdrc_pci.c",
  "hash_id": "21f38066a8234fecb116e2ea3df5a6b5a52c0cc5ad407e17a36f44c5eb2acf9d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci_hdrc_pci.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/interrupt.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/chipidea.h>\n#include <linux/usb/usb_phy_generic.h>\n\n \n#define UDC_DRIVER_NAME   \"ci_hdrc_pci\"\n\nstruct ci_hdrc_pci {\n\tstruct platform_device\t*ci;\n\tstruct platform_device\t*phy;\n};\n\n \nstatic struct ci_hdrc_platform_data pci_platdata = {\n\t.name\t\t= UDC_DRIVER_NAME,\n\t.capoffset\t= DEF_CAPOFFSET,\n};\n\nstatic struct ci_hdrc_platform_data langwell_pci_platdata = {\n\t.name\t\t= UDC_DRIVER_NAME,\n\t.capoffset\t= 0,\n};\n\nstatic struct ci_hdrc_platform_data penwell_pci_platdata = {\n\t.name\t\t= UDC_DRIVER_NAME,\n\t.capoffset\t= 0,\n\t.power_budget\t= 200,\n};\n\n \nstatic int ci_hdrc_pci_probe(struct pci_dev *pdev,\n\t\t\t\t       const struct pci_device_id *id)\n{\n\tstruct ci_hdrc_platform_data *platdata = (void *)id->driver_data;\n\tstruct ci_hdrc_pci *ci;\n\tstruct resource res[3];\n\tint retval = 0, nres = 2;\n\n\tif (!platdata) {\n\t\tdev_err(&pdev->dev, \"device doesn't provide driver data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tci = devm_kzalloc(&pdev->dev, sizeof(*ci), GFP_KERNEL);\n\tif (!ci)\n\t\treturn -ENOMEM;\n\n\tretval = pcim_enable_device(pdev);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!pdev->irq) {\n\t\tdev_err(&pdev->dev, \"No IRQ, check BIOS/PCI setup!\");\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_master(pdev);\n\tpci_try_set_mwi(pdev);\n\n\t \n\tci->phy = usb_phy_generic_register();\n\tif (IS_ERR(ci->phy))\n\t\treturn PTR_ERR(ci->phy);\n\n\tmemset(res, 0, sizeof(res));\n\tres[0].start\t= pci_resource_start(pdev, 0);\n\tres[0].end\t= pci_resource_end(pdev, 0);\n\tres[0].flags\t= IORESOURCE_MEM;\n\tres[1].start\t= pdev->irq;\n\tres[1].flags\t= IORESOURCE_IRQ;\n\n\tci->ci = ci_hdrc_add_device(&pdev->dev, res, nres, platdata);\n\tif (IS_ERR(ci->ci)) {\n\t\tdev_err(&pdev->dev, \"ci_hdrc_add_device failed!\\n\");\n\t\tusb_phy_generic_unregister(ci->phy);\n\t\treturn PTR_ERR(ci->ci);\n\t}\n\n\tpci_set_drvdata(pdev, ci);\n\n\treturn 0;\n}\n\n \nstatic void ci_hdrc_pci_remove(struct pci_dev *pdev)\n{\n\tstruct ci_hdrc_pci *ci = pci_get_drvdata(pdev);\n\n\tci_hdrc_remove_device(ci->ci);\n\tusb_phy_generic_unregister(ci->phy);\n}\n\n \nstatic const struct pci_device_id ci_hdrc_pci_id_table[] = {\n\t{\n\t\tPCI_DEVICE(0x153F, 0x1004),\n\t\t.driver_data = (kernel_ulong_t)&pci_platdata,\n\t},\n\t{\n\t\tPCI_DEVICE(0x153F, 0x1006),\n\t\t.driver_data = (kernel_ulong_t)&pci_platdata,\n\t},\n\t{\n\t\tPCI_VDEVICE(INTEL, 0x0811),\n\t\t.driver_data = (kernel_ulong_t)&langwell_pci_platdata,\n\t},\n\t{\n\t\tPCI_VDEVICE(INTEL, 0x0829),\n\t\t.driver_data = (kernel_ulong_t)&penwell_pci_platdata,\n\t},\n\t{\n\t\t \n\t\tPCI_VDEVICE(INTEL, 0xe006),\n\t\t.driver_data = (kernel_ulong_t)&penwell_pci_platdata,\n\t},\n\t{ 0 }  \n};\nMODULE_DEVICE_TABLE(pci, ci_hdrc_pci_id_table);\n\nstatic struct pci_driver ci_hdrc_pci_driver = {\n\t.name         =\tUDC_DRIVER_NAME,\n\t.id_table     =\tci_hdrc_pci_id_table,\n\t.probe        =\tci_hdrc_pci_probe,\n\t.remove       =\tci_hdrc_pci_remove,\n};\n\nmodule_pci_driver(ci_hdrc_pci_driver);\n\nMODULE_AUTHOR(\"MIPS - David Lopo <dlopo@chipidea.mips.com>\");\nMODULE_DESCRIPTION(\"MIPS CI13XXX USB Peripheral Controller\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:ci13xxx_pci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}