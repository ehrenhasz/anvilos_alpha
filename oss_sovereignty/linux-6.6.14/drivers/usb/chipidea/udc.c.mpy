{
  "module_name": "udc.c",
  "hash_id": "b2e163ecb42afb59826a558255f8905ca93828cd9d6648b9723519b9abb31a5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/udc.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/err.h>\n#include <linux/irqreturn.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg-fsm.h>\n#include <linux/usb/chipidea.h>\n\n#include \"ci.h\"\n#include \"udc.h\"\n#include \"bits.h\"\n#include \"otg.h\"\n#include \"otg_fsm.h\"\n#include \"trace.h\"\n\n \nstatic const struct usb_endpoint_descriptor\nctrl_endpt_out_desc = {\n\t.bLength         = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_OUT,\n\t.bmAttributes    = USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize  = cpu_to_le16(CTRL_PAYLOAD_MAX),\n};\n\nstatic const struct usb_endpoint_descriptor\nctrl_endpt_in_desc = {\n\t.bLength         = USB_DT_ENDPOINT_SIZE,\n\t.bDescriptorType = USB_DT_ENDPOINT,\n\n\t.bEndpointAddress = USB_DIR_IN,\n\t.bmAttributes    = USB_ENDPOINT_XFER_CONTROL,\n\t.wMaxPacketSize  = cpu_to_le16(CTRL_PAYLOAD_MAX),\n};\n\nstatic int reprime_dtd(struct ci_hdrc *ci, struct ci_hw_ep *hwep,\n\t\t       struct td_node *node);\n \nstatic inline int hw_ep_bit(int num, int dir)\n{\n\treturn num + ((dir == TX) ? 16 : 0);\n}\n\nstatic inline int ep_to_bit(struct ci_hdrc *ci, int n)\n{\n\tint fill = 16 - ci->hw_ep_max / 2;\n\n\tif (n >= ci->hw_ep_max / 2)\n\t\tn += fill;\n\n\treturn n;\n}\n\n \nstatic int hw_device_state(struct ci_hdrc *ci, u32 dma)\n{\n\tif (dma) {\n\t\thw_write(ci, OP_ENDPTLISTADDR, ~0, dma);\n\t\t \n\t\thw_write(ci, OP_USBINTR, ~0,\n\t\t\t     USBi_UI|USBi_UEI|USBi_PCI|USBi_URI|USBi_SLI);\n\t} else {\n\t\thw_write(ci, OP_USBINTR, ~0, 0);\n\t}\n\treturn 0;\n}\n\n \nstatic int hw_ep_flush(struct ci_hdrc *ci, int num, int dir)\n{\n\tint n = hw_ep_bit(num, dir);\n\n\tdo {\n\t\t \n\t\thw_write(ci, OP_ENDPTFLUSH, ~0, BIT(n));\n\t\twhile (hw_read(ci, OP_ENDPTFLUSH, BIT(n)))\n\t\t\tcpu_relax();\n\t} while (hw_read(ci, OP_ENDPTSTAT, BIT(n)));\n\n\treturn 0;\n}\n\n \nstatic int hw_ep_disable(struct ci_hdrc *ci, int num, int dir)\n{\n\thw_write(ci, OP_ENDPTCTRL + num,\n\t\t (dir == TX) ? ENDPTCTRL_TXE : ENDPTCTRL_RXE, 0);\n\treturn 0;\n}\n\n \nstatic int hw_ep_enable(struct ci_hdrc *ci, int num, int dir, int type)\n{\n\tu32 mask, data;\n\n\tif (dir == TX) {\n\t\tmask  = ENDPTCTRL_TXT;   \n\t\tdata  = type << __ffs(mask);\n\n\t\tmask |= ENDPTCTRL_TXS;   \n\t\tmask |= ENDPTCTRL_TXR;   \n\t\tdata |= ENDPTCTRL_TXR;\n\t\tmask |= ENDPTCTRL_TXE;   \n\t\tdata |= ENDPTCTRL_TXE;\n\t} else {\n\t\tmask  = ENDPTCTRL_RXT;   \n\t\tdata  = type << __ffs(mask);\n\n\t\tmask |= ENDPTCTRL_RXS;   \n\t\tmask |= ENDPTCTRL_RXR;   \n\t\tdata |= ENDPTCTRL_RXR;\n\t\tmask |= ENDPTCTRL_RXE;   \n\t\tdata |= ENDPTCTRL_RXE;\n\t}\n\thw_write(ci, OP_ENDPTCTRL + num, mask, data);\n\treturn 0;\n}\n\n \nstatic int hw_ep_get_halt(struct ci_hdrc *ci, int num, int dir)\n{\n\tu32 mask = (dir == TX) ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\n\n\treturn hw_read(ci, OP_ENDPTCTRL + num, mask) ? 1 : 0;\n}\n\n \nstatic int hw_ep_prime(struct ci_hdrc *ci, int num, int dir, int is_ctrl)\n{\n\tint n = hw_ep_bit(num, dir);\n\n\t \n\twmb();\n\n\tif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\n\t\treturn -EAGAIN;\n\n\thw_write(ci, OP_ENDPTPRIME, ~0, BIT(n));\n\n\twhile (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\n\t\tcpu_relax();\n\tif (is_ctrl && dir == RX && hw_read(ci, OP_ENDPTSETUPSTAT, BIT(num)))\n\t\treturn -EAGAIN;\n\n\t \n\treturn 0;\n}\n\n \nstatic int hw_ep_set_halt(struct ci_hdrc *ci, int num, int dir, int value)\n{\n\tif (value != 0 && value != 1)\n\t\treturn -EINVAL;\n\n\tdo {\n\t\tenum ci_hw_regs reg = OP_ENDPTCTRL + num;\n\t\tu32 mask_xs = (dir == TX) ? ENDPTCTRL_TXS : ENDPTCTRL_RXS;\n\t\tu32 mask_xr = (dir == TX) ? ENDPTCTRL_TXR : ENDPTCTRL_RXR;\n\n\t\t \n\t\thw_write(ci, reg, mask_xs|mask_xr,\n\t\t\t  value ? mask_xs : mask_xr);\n\t} while (value != hw_ep_get_halt(ci, num, dir));\n\n\treturn 0;\n}\n\n \nstatic int hw_port_is_high_speed(struct ci_hdrc *ci)\n{\n\treturn ci->hw_bank.lpm ? hw_read(ci, OP_DEVLC, DEVLC_PSPD) :\n\t\thw_read(ci, OP_PORTSC, PORTSC_HSP);\n}\n\n \nstatic int hw_test_and_clear_complete(struct ci_hdrc *ci, int n)\n{\n\tn = ep_to_bit(ci, n);\n\treturn hw_test_and_clear(ci, OP_ENDPTCOMPLETE, BIT(n));\n}\n\n \nstatic u32 hw_test_and_clear_intr_active(struct ci_hdrc *ci)\n{\n\tu32 reg = hw_read_intr_status(ci) & hw_read_intr_enable(ci);\n\n\thw_write(ci, OP_USBSTS, ~0, reg);\n\treturn reg;\n}\n\n \nstatic int hw_test_and_clear_setup_guard(struct ci_hdrc *ci)\n{\n\treturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, 0);\n}\n\n \nstatic int hw_test_and_set_setup_guard(struct ci_hdrc *ci)\n{\n\treturn hw_test_and_write(ci, OP_USBCMD, USBCMD_SUTW, USBCMD_SUTW);\n}\n\n \nstatic void hw_usb_set_address(struct ci_hdrc *ci, u8 value)\n{\n\thw_write(ci, OP_DEVICEADDR, DEVICEADDR_USBADR,\n\t\t value << __ffs(DEVICEADDR_USBADR));\n}\n\n \nstatic int hw_usb_reset(struct ci_hdrc *ci)\n{\n\thw_usb_set_address(ci, 0);\n\n\t \n\thw_write(ci, OP_ENDPTFLUSH,    ~0, ~0);\n\n\t \n\thw_write(ci, OP_ENDPTSETUPSTAT, 0,  0);\n\n\t \n\thw_write(ci, OP_ENDPTCOMPLETE,  0,  0);\n\n\t \n\twhile (hw_read(ci, OP_ENDPTPRIME, ~0))\n\t\tudelay(10);              \n\n\t \n\n\t \n\n\treturn 0;\n}\n\n \n\nstatic int add_td_to_list(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq,\n\t\t\tunsigned int length, struct scatterlist *s)\n{\n\tint i;\n\tu32 temp;\n\tstruct td_node *lastnode, *node = kzalloc(sizeof(struct td_node),\n\t\t\t\t\t\t  GFP_ATOMIC);\n\n\tif (node == NULL)\n\t\treturn -ENOMEM;\n\n\tnode->ptr = dma_pool_zalloc(hwep->td_pool, GFP_ATOMIC, &node->dma);\n\tif (node->ptr == NULL) {\n\t\tkfree(node);\n\t\treturn -ENOMEM;\n\t}\n\n\tnode->ptr->token = cpu_to_le32(length << __ffs(TD_TOTAL_BYTES));\n\tnode->ptr->token &= cpu_to_le32(TD_TOTAL_BYTES);\n\tnode->ptr->token |= cpu_to_le32(TD_STATUS_ACTIVE);\n\tif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == TX) {\n\t\tu32 mul = hwreq->req.length / hwep->ep.maxpacket;\n\n\t\tif (hwreq->req.length == 0\n\t\t\t\t|| hwreq->req.length % hwep->ep.maxpacket)\n\t\t\tmul++;\n\t\tnode->ptr->token |= cpu_to_le32(mul << __ffs(TD_MULTO));\n\t}\n\n\tif (s) {\n\t\ttemp = (u32) (sg_dma_address(s) + hwreq->req.actual);\n\t\tnode->td_remaining_size = CI_MAX_BUF_SIZE - length;\n\t} else {\n\t\ttemp = (u32) (hwreq->req.dma + hwreq->req.actual);\n\t}\n\n\tif (length) {\n\t\tnode->ptr->page[0] = cpu_to_le32(temp);\n\t\tfor (i = 1; i < TD_PAGE_COUNT; i++) {\n\t\t\tu32 page = temp + i * CI_HDRC_PAGE_SIZE;\n\t\t\tpage &= ~TD_RESERVED_MASK;\n\t\t\tnode->ptr->page[i] = cpu_to_le32(page);\n\t\t}\n\t}\n\n\thwreq->req.actual += length;\n\n\tif (!list_empty(&hwreq->tds)) {\n\t\t \n\t\tlastnode = list_entry(hwreq->tds.prev,\n\t\t\t\tstruct td_node, td);\n\t\tlastnode->ptr->next = cpu_to_le32(node->dma);\n\t}\n\n\tINIT_LIST_HEAD(&node->td);\n\tlist_add_tail(&node->td, &hwreq->tds);\n\n\treturn 0;\n}\n\n \nstatic inline u8 _usb_addr(struct ci_hw_ep *ep)\n{\n\treturn ((ep->dir == TX) ? USB_ENDPOINT_DIR_MASK : 0) | ep->num;\n}\n\nstatic int prepare_td_for_non_sg(struct ci_hw_ep *hwep,\n\t\tstruct ci_hw_req *hwreq)\n{\n\tunsigned int rest = hwreq->req.length;\n\tint pages = TD_PAGE_COUNT;\n\tint ret = 0;\n\n\tif (rest == 0) {\n\t\tret = add_td_to_list(hwep, hwreq, 0, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (hwreq->req.dma % PAGE_SIZE)\n\t\tpages--;\n\n\twhile (rest > 0) {\n\t\tunsigned int count = min(hwreq->req.length - hwreq->req.actual,\n\t\t\t(unsigned int)(pages * CI_HDRC_PAGE_SIZE));\n\n\t\tret = add_td_to_list(hwep, hwreq, count, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trest -= count;\n\t}\n\n\tif (hwreq->req.zero && hwreq->req.length && hwep->dir == TX\n\t    && (hwreq->req.length % hwep->ep.maxpacket == 0)) {\n\t\tret = add_td_to_list(hwep, hwreq, 0, NULL);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn ret;\n}\n\nstatic int prepare_td_per_sg(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq,\n\t\tstruct scatterlist *s)\n{\n\tunsigned int rest = sg_dma_len(s);\n\tint ret = 0;\n\n\thwreq->req.actual = 0;\n\twhile (rest > 0) {\n\t\tunsigned int count = min_t(unsigned int, rest,\n\t\t\t\tCI_MAX_BUF_SIZE);\n\n\t\tret = add_td_to_list(hwep, hwreq, count, s);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\trest -= count;\n\t}\n\n\treturn ret;\n}\n\nstatic void ci_add_buffer_entry(struct td_node *node, struct scatterlist *s)\n{\n\tint empty_td_slot_index = (CI_MAX_BUF_SIZE - node->td_remaining_size)\n\t\t\t/ CI_HDRC_PAGE_SIZE;\n\tint i;\n\tu32 token;\n\n\ttoken = le32_to_cpu(node->ptr->token) + (sg_dma_len(s) << __ffs(TD_TOTAL_BYTES));\n\tnode->ptr->token = cpu_to_le32(token);\n\n\tfor (i = empty_td_slot_index; i < TD_PAGE_COUNT; i++) {\n\t\tu32 page = (u32) sg_dma_address(s) +\n\t\t\t(i - empty_td_slot_index) * CI_HDRC_PAGE_SIZE;\n\n\t\tpage &= ~TD_RESERVED_MASK;\n\t\tnode->ptr->page[i] = cpu_to_le32(page);\n\t}\n}\n\nstatic int prepare_td_for_sg(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq)\n{\n\tstruct usb_request *req = &hwreq->req;\n\tstruct scatterlist *s = req->sg;\n\tint ret = 0, i = 0;\n\tstruct td_node *node = NULL;\n\n\tif (!s || req->zero || req->length == 0) {\n\t\tdev_err(hwep->ci->dev, \"not supported operation for sg\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\twhile (i++ < req->num_mapped_sgs) {\n\t\tif (sg_dma_address(s) % PAGE_SIZE) {\n\t\t\tdev_err(hwep->ci->dev, \"not page aligned sg buffer\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (node && (node->td_remaining_size >= sg_dma_len(s))) {\n\t\t\tci_add_buffer_entry(node, s);\n\t\t\tnode->td_remaining_size -= sg_dma_len(s);\n\t\t} else {\n\t\t\tret = prepare_td_per_sg(hwep, hwreq, s);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tnode = list_entry(hwreq->tds.prev,\n\t\t\t\tstruct td_node, td);\n\t\t}\n\n\t\ts = sg_next(s);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int _hardware_enqueue(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq)\n{\n\tstruct ci_hdrc *ci = hwep->ci;\n\tint ret = 0;\n\tstruct td_node *firstnode, *lastnode;\n\n\t \n\tif (hwreq->req.status == -EALREADY)\n\t\treturn -EALREADY;\n\n\thwreq->req.status = -EALREADY;\n\n\tret = usb_gadget_map_request_by_dev(ci->dev->parent,\n\t\t\t\t\t    &hwreq->req, hwep->dir);\n\tif (ret)\n\t\treturn ret;\n\n\tif (hwreq->req.num_mapped_sgs)\n\t\tret = prepare_td_for_sg(hwep, hwreq);\n\telse\n\t\tret = prepare_td_for_non_sg(hwep, hwreq);\n\n\tif (ret)\n\t\treturn ret;\n\n\tlastnode = list_entry(hwreq->tds.prev,\n\t\tstruct td_node, td);\n\n\tlastnode->ptr->next = cpu_to_le32(TD_TERMINATE);\n\tif (!hwreq->req.no_interrupt)\n\t\tlastnode->ptr->token |= cpu_to_le32(TD_IOC);\n\n\tlist_for_each_entry_safe(firstnode, lastnode, &hwreq->tds, td)\n\t\ttrace_ci_prepare_td(hwep, hwreq, firstnode);\n\n\tfirstnode = list_first_entry(&hwreq->tds, struct td_node, td);\n\n\twmb();\n\n\thwreq->req.actual = 0;\n\tif (!list_empty(&hwep->qh.queue)) {\n\t\tstruct ci_hw_req *hwreqprev;\n\t\tint n = hw_ep_bit(hwep->num, hwep->dir);\n\t\tint tmp_stat;\n\t\tstruct td_node *prevlastnode;\n\t\tu32 next = firstnode->dma & TD_ADDR_MASK;\n\n\t\thwreqprev = list_entry(hwep->qh.queue.prev,\n\t\t\t\tstruct ci_hw_req, queue);\n\t\tprevlastnode = list_entry(hwreqprev->tds.prev,\n\t\t\t\tstruct td_node, td);\n\n\t\tprevlastnode->ptr->next = cpu_to_le32(next);\n\t\twmb();\n\n\t\tif (ci->rev == CI_REVISION_22) {\n\t\t\tif (!hw_read(ci, OP_ENDPTSTAT, BIT(n)))\n\t\t\t\treprime_dtd(ci, hwep, prevlastnode);\n\t\t}\n\n\t\tif (hw_read(ci, OP_ENDPTPRIME, BIT(n)))\n\t\t\tgoto done;\n\t\tdo {\n\t\t\thw_write(ci, OP_USBCMD, USBCMD_ATDTW, USBCMD_ATDTW);\n\t\t\ttmp_stat = hw_read(ci, OP_ENDPTSTAT, BIT(n));\n\t\t} while (!hw_read(ci, OP_USBCMD, USBCMD_ATDTW));\n\t\thw_write(ci, OP_USBCMD, USBCMD_ATDTW, 0);\n\t\tif (tmp_stat)\n\t\t\tgoto done;\n\t}\n\n\t \n\thwep->qh.ptr->td.next = cpu_to_le32(firstnode->dma);\n\thwep->qh.ptr->td.token &=\n\t\tcpu_to_le32(~(TD_STATUS_HALTED|TD_STATUS_ACTIVE));\n\n\tif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == RX) {\n\t\tu32 mul = hwreq->req.length / hwep->ep.maxpacket;\n\n\t\tif (hwreq->req.length == 0\n\t\t\t\t|| hwreq->req.length % hwep->ep.maxpacket)\n\t\t\tmul++;\n\t\thwep->qh.ptr->cap |= cpu_to_le32(mul << __ffs(QH_MULT));\n\t}\n\n\tret = hw_ep_prime(ci, hwep->num, hwep->dir,\n\t\t\t   hwep->type == USB_ENDPOINT_XFER_CONTROL);\ndone:\n\treturn ret;\n}\n\n \nstatic void free_pending_td(struct ci_hw_ep *hwep)\n{\n\tstruct td_node *pending = hwep->pending_td;\n\n\tdma_pool_free(hwep->td_pool, pending->ptr, pending->dma);\n\thwep->pending_td = NULL;\n\tkfree(pending);\n}\n\nstatic int reprime_dtd(struct ci_hdrc *ci, struct ci_hw_ep *hwep,\n\t\t\t\t\t   struct td_node *node)\n{\n\thwep->qh.ptr->td.next = cpu_to_le32(node->dma);\n\thwep->qh.ptr->td.token &=\n\t\tcpu_to_le32(~(TD_STATUS_HALTED | TD_STATUS_ACTIVE));\n\n\treturn hw_ep_prime(ci, hwep->num, hwep->dir,\n\t\t\t\thwep->type == USB_ENDPOINT_XFER_CONTROL);\n}\n\n \nstatic int _hardware_dequeue(struct ci_hw_ep *hwep, struct ci_hw_req *hwreq)\n{\n\tu32 tmptoken;\n\tstruct td_node *node, *tmpnode;\n\tunsigned remaining_length;\n\tunsigned actual = hwreq->req.length;\n\tstruct ci_hdrc *ci = hwep->ci;\n\n\tif (hwreq->req.status != -EALREADY)\n\t\treturn -EINVAL;\n\n\thwreq->req.status = 0;\n\n\tlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\n\t\ttmptoken = le32_to_cpu(node->ptr->token);\n\t\ttrace_ci_complete_td(hwep, hwreq, node);\n\t\tif ((TD_STATUS_ACTIVE & tmptoken) != 0) {\n\t\t\tint n = hw_ep_bit(hwep->num, hwep->dir);\n\n\t\t\tif (ci->rev == CI_REVISION_24)\n\t\t\t\tif (!hw_read(ci, OP_ENDPTSTAT, BIT(n)))\n\t\t\t\t\treprime_dtd(ci, hwep, node);\n\t\t\thwreq->req.status = -EALREADY;\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tremaining_length = (tmptoken & TD_TOTAL_BYTES);\n\t\tremaining_length >>= __ffs(TD_TOTAL_BYTES);\n\t\tactual -= remaining_length;\n\n\t\thwreq->req.status = tmptoken & TD_STATUS;\n\t\tif ((TD_STATUS_HALTED & hwreq->req.status)) {\n\t\t\thwreq->req.status = -EPIPE;\n\t\t\tbreak;\n\t\t} else if ((TD_STATUS_DT_ERR & hwreq->req.status)) {\n\t\t\thwreq->req.status = -EPROTO;\n\t\t\tbreak;\n\t\t} else if ((TD_STATUS_TR_ERR & hwreq->req.status)) {\n\t\t\thwreq->req.status = -EILSEQ;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (remaining_length) {\n\t\t\tif (hwep->dir == TX) {\n\t\t\t\thwreq->req.status = -EPROTO;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tif (hwep->pending_td)\n\t\t\tfree_pending_td(hwep);\n\n\t\thwep->pending_td = node;\n\t\tlist_del_init(&node->td);\n\t}\n\n\tusb_gadget_unmap_request_by_dev(hwep->ci->dev->parent,\n\t\t\t\t\t&hwreq->req, hwep->dir);\n\n\thwreq->req.actual += actual;\n\n\tif (hwreq->req.status)\n\t\treturn hwreq->req.status;\n\n\treturn hwreq->req.actual;\n}\n\n \nstatic int _ep_nuke(struct ci_hw_ep *hwep)\n__releases(hwep->lock)\n__acquires(hwep->lock)\n{\n\tstruct td_node *node, *tmpnode;\n\tif (hwep == NULL)\n\t\treturn -EINVAL;\n\n\thw_ep_flush(hwep->ci, hwep->num, hwep->dir);\n\n\twhile (!list_empty(&hwep->qh.queue)) {\n\n\t\t \n\t\tstruct ci_hw_req *hwreq = list_entry(hwep->qh.queue.next,\n\t\t\t\t\t\t     struct ci_hw_req, queue);\n\n\t\tlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\n\t\t\tdma_pool_free(hwep->td_pool, node->ptr, node->dma);\n\t\t\tlist_del_init(&node->td);\n\t\t\tnode->ptr = NULL;\n\t\t\tkfree(node);\n\t\t}\n\n\t\tlist_del_init(&hwreq->queue);\n\t\thwreq->req.status = -ESHUTDOWN;\n\n\t\tif (hwreq->req.complete != NULL) {\n\t\t\tspin_unlock(hwep->lock);\n\t\t\tusb_gadget_giveback_request(&hwep->ep, &hwreq->req);\n\t\t\tspin_lock(hwep->lock);\n\t\t}\n\t}\n\n\tif (hwep->pending_td)\n\t\tfree_pending_td(hwep);\n\n\treturn 0;\n}\n\nstatic int _ep_set_halt(struct usb_ep *ep, int value, bool check_transfer)\n{\n\tstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\n\tint direction, retval = 0;\n\tunsigned long flags;\n\n\tif (ep == NULL || hwep->ep.desc == NULL)\n\t\treturn -EINVAL;\n\n\tif (usb_endpoint_xfer_isoc(hwep->ep.desc))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\n\tif (value && hwep->dir == TX && check_transfer &&\n\t\t!list_empty(&hwep->qh.queue) &&\n\t\t\t!usb_endpoint_xfer_control(hwep->ep.desc)) {\n\t\tspin_unlock_irqrestore(hwep->lock, flags);\n\t\treturn -EAGAIN;\n\t}\n\n\tdirection = hwep->dir;\n\tdo {\n\t\tretval |= hw_ep_set_halt(hwep->ci, hwep->num, hwep->dir, value);\n\n\t\tif (!value)\n\t\t\thwep->wedge = 0;\n\n\t\tif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\n\t\t\thwep->dir = (hwep->dir == TX) ? RX : TX;\n\n\t} while (hwep->dir != direction);\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\treturn retval;\n}\n\n\n \nstatic int _gadget_stop_activity(struct usb_gadget *gadget)\n{\n\tstruct usb_ep *ep;\n\tstruct ci_hdrc    *ci = container_of(gadget, struct ci_hdrc, gadget);\n\tunsigned long flags;\n\n\t \n\tgadget_for_each_ep(ep, gadget) {\n\t\tusb_ep_fifo_flush(ep);\n\t}\n\tusb_ep_fifo_flush(&ci->ep0out->ep);\n\tusb_ep_fifo_flush(&ci->ep0in->ep);\n\n\t \n\tgadget_for_each_ep(ep, gadget) {\n\t\tusb_ep_disable(ep);\n\t}\n\n\tif (ci->status != NULL) {\n\t\tusb_ep_free_request(&ci->ep0in->ep, ci->status);\n\t\tci->status = NULL;\n\t}\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tci->gadget.speed = USB_SPEED_UNKNOWN;\n\tci->remote_wakeup = 0;\n\tci->suspended = 0;\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\treturn 0;\n}\n\n \n \nstatic void isr_reset_handler(struct ci_hdrc *ci)\n__releases(ci->lock)\n__acquires(ci->lock)\n{\n\tint retval;\n\n\tspin_unlock(&ci->lock);\n\tif (ci->gadget.speed != USB_SPEED_UNKNOWN)\n\t\tusb_gadget_udc_reset(&ci->gadget, ci->driver);\n\n\tretval = _gadget_stop_activity(&ci->gadget);\n\tif (retval)\n\t\tgoto done;\n\n\tretval = hw_usb_reset(ci);\n\tif (retval)\n\t\tgoto done;\n\n\tci->status = usb_ep_alloc_request(&ci->ep0in->ep, GFP_ATOMIC);\n\tif (ci->status == NULL)\n\t\tretval = -ENOMEM;\n\ndone:\n\tspin_lock(&ci->lock);\n\n\tif (retval)\n\t\tdev_err(ci->dev, \"error: %i\\n\", retval);\n}\n\n \nstatic void isr_get_status_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tif (ep == NULL || req == NULL)\n\t\treturn;\n\n\tkfree(req->buf);\n\tusb_ep_free_request(ep, req);\n}\n\n \nstatic int _ep_queue(struct usb_ep *ep, struct usb_request *req,\n\t\t    gfp_t __maybe_unused gfp_flags)\n{\n\tstruct ci_hw_ep  *hwep  = container_of(ep,  struct ci_hw_ep, ep);\n\tstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\n\tstruct ci_hdrc *ci = hwep->ci;\n\tint retval = 0;\n\n\tif (ep == NULL || req == NULL || hwep->ep.desc == NULL)\n\t\treturn -EINVAL;\n\n\tif (hwep->type == USB_ENDPOINT_XFER_CONTROL) {\n\t\tif (req->length)\n\t\t\thwep = (ci->ep0_dir == RX) ?\n\t\t\t       ci->ep0out : ci->ep0in;\n\t\tif (!list_empty(&hwep->qh.queue)) {\n\t\t\t_ep_nuke(hwep);\n\t\t\tdev_warn(hwep->ci->dev, \"endpoint ctrl %X nuked\\n\",\n\t\t\t\t _usb_addr(hwep));\n\t\t}\n\t}\n\n\tif (usb_endpoint_xfer_isoc(hwep->ep.desc) &&\n\t    hwreq->req.length > hwep->ep.mult * hwep->ep.maxpacket) {\n\t\tdev_err(hwep->ci->dev, \"request length too big for isochronous\\n\");\n\t\treturn -EMSGSIZE;\n\t}\n\n\t \n\tif (!list_empty(&hwreq->queue)) {\n\t\tdev_err(hwep->ci->dev, \"request already in queue\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t \n\thwreq->req.status = -EINPROGRESS;\n\thwreq->req.actual = 0;\n\n\tretval = _hardware_enqueue(hwep, hwreq);\n\n\tif (retval == -EALREADY)\n\t\tretval = 0;\n\tif (!retval)\n\t\tlist_add_tail(&hwreq->queue, &hwep->qh.queue);\n\n\treturn retval;\n}\n\n \nstatic int isr_get_status_response(struct ci_hdrc *ci,\n\t\t\t\t   struct usb_ctrlrequest *setup)\n__releases(hwep->lock)\n__acquires(hwep->lock)\n{\n\tstruct ci_hw_ep *hwep = ci->ep0in;\n\tstruct usb_request *req = NULL;\n\tgfp_t gfp_flags = GFP_ATOMIC;\n\tint dir, num, retval;\n\n\tif (hwep == NULL || setup == NULL)\n\t\treturn -EINVAL;\n\n\tspin_unlock(hwep->lock);\n\treq = usb_ep_alloc_request(&hwep->ep, gfp_flags);\n\tspin_lock(hwep->lock);\n\tif (req == NULL)\n\t\treturn -ENOMEM;\n\n\treq->complete = isr_get_status_complete;\n\treq->length   = 2;\n\treq->buf      = kzalloc(req->length, gfp_flags);\n\tif (req->buf == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_free_req;\n\t}\n\n\tif ((setup->bRequestType & USB_RECIP_MASK) == USB_RECIP_DEVICE) {\n\t\t*(u16 *)req->buf = (ci->remote_wakeup << 1) |\n\t\t\tci->gadget.is_selfpowered;\n\t} else if ((setup->bRequestType & USB_RECIP_MASK) \\\n\t\t   == USB_RECIP_ENDPOINT) {\n\t\tdir = (le16_to_cpu(setup->wIndex) & USB_ENDPOINT_DIR_MASK) ?\n\t\t\tTX : RX;\n\t\tnum =  le16_to_cpu(setup->wIndex) & USB_ENDPOINT_NUMBER_MASK;\n\t\t*(u16 *)req->buf = hw_ep_get_halt(ci, num, dir);\n\t}\n\t \n\n\tretval = _ep_queue(&hwep->ep, req, gfp_flags);\n\tif (retval)\n\t\tgoto err_free_buf;\n\n\treturn 0;\n\n err_free_buf:\n\tkfree(req->buf);\n err_free_req:\n\tspin_unlock(hwep->lock);\n\tusb_ep_free_request(&hwep->ep, req);\n\tspin_lock(hwep->lock);\n\treturn retval;\n}\n\n \nstatic void\nisr_setup_status_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ci_hdrc *ci = req->context;\n\tunsigned long flags;\n\n\tif (req->status < 0)\n\t\treturn;\n\n\tif (ci->setaddr) {\n\t\thw_usb_set_address(ci, ci->address);\n\t\tci->setaddr = false;\n\t\tif (ci->address)\n\t\t\tusb_gadget_set_state(&ci->gadget, USB_STATE_ADDRESS);\n\t}\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tif (ci->test_mode)\n\t\thw_port_test_set(ci, ci->test_mode);\n\tspin_unlock_irqrestore(&ci->lock, flags);\n}\n\n \nstatic int isr_setup_status_phase(struct ci_hdrc *ci)\n{\n\tstruct ci_hw_ep *hwep;\n\n\t \n\tif (WARN_ON_ONCE(!ci->status))\n\t\treturn -EPIPE;\n\n\thwep = (ci->ep0_dir == TX) ? ci->ep0out : ci->ep0in;\n\tci->status->context = ci;\n\tci->status->complete = isr_setup_status_complete;\n\n\treturn _ep_queue(&hwep->ep, ci->status, GFP_ATOMIC);\n}\n\n \nstatic int isr_tr_complete_low(struct ci_hw_ep *hwep)\n__releases(hwep->lock)\n__acquires(hwep->lock)\n{\n\tstruct ci_hw_req *hwreq, *hwreqtemp;\n\tstruct ci_hw_ep *hweptemp = hwep;\n\tint retval = 0;\n\n\tlist_for_each_entry_safe(hwreq, hwreqtemp, &hwep->qh.queue,\n\t\t\tqueue) {\n\t\tretval = _hardware_dequeue(hwep, hwreq);\n\t\tif (retval < 0)\n\t\t\tbreak;\n\t\tlist_del_init(&hwreq->queue);\n\t\tif (hwreq->req.complete != NULL) {\n\t\t\tspin_unlock(hwep->lock);\n\t\t\tif ((hwep->type == USB_ENDPOINT_XFER_CONTROL) &&\n\t\t\t\t\thwreq->req.length)\n\t\t\t\thweptemp = hwep->ci->ep0in;\n\t\t\tusb_gadget_giveback_request(&hweptemp->ep, &hwreq->req);\n\t\t\tspin_lock(hwep->lock);\n\t\t}\n\t}\n\n\tif (retval == -EBUSY)\n\t\tretval = 0;\n\n\treturn retval;\n}\n\nstatic int otg_a_alt_hnp_support(struct ci_hdrc *ci)\n{\n\tdev_warn(&ci->gadget.dev,\n\t\t\"connect the device to an alternate port if you want HNP\\n\");\n\treturn isr_setup_status_phase(ci);\n}\n\n \nstatic void isr_setup_packet_handler(struct ci_hdrc *ci)\n__releases(ci->lock)\n__acquires(ci->lock)\n{\n\tstruct ci_hw_ep *hwep = &ci->ci_hw_ep[0];\n\tstruct usb_ctrlrequest req;\n\tint type, num, dir, err = -EINVAL;\n\tu8 tmode = 0;\n\n\t \n\t_ep_nuke(ci->ep0out);\n\t_ep_nuke(ci->ep0in);\n\n\t \n\tdo {\n\t\thw_test_and_set_setup_guard(ci);\n\t\tmemcpy(&req, &hwep->qh.ptr->setup, sizeof(req));\n\t} while (!hw_test_and_clear_setup_guard(ci));\n\n\ttype = req.bRequestType;\n\n\tci->ep0_dir = (type & USB_DIR_IN) ? TX : RX;\n\n\tswitch (req.bRequest) {\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\n\t\t\t\tle16_to_cpu(req.wValue) ==\n\t\t\t\tUSB_ENDPOINT_HALT) {\n\t\t\tif (req.wLength != 0)\n\t\t\t\tbreak;\n\t\t\tnum  = le16_to_cpu(req.wIndex);\n\t\t\tdir = (num & USB_ENDPOINT_DIR_MASK) ? TX : RX;\n\t\t\tnum &= USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (dir == TX)\n\t\t\t\tnum += ci->hw_ep_max / 2;\n\t\t\tif (!ci->ci_hw_ep[num].wedge) {\n\t\t\t\tspin_unlock(&ci->lock);\n\t\t\t\terr = usb_ep_clear_halt(\n\t\t\t\t\t&ci->ci_hw_ep[num].ep);\n\t\t\t\tspin_lock(&ci->lock);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\terr = isr_setup_status_phase(ci);\n\t\t} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE) &&\n\t\t\t\tle16_to_cpu(req.wValue) ==\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP) {\n\t\t\tif (req.wLength != 0)\n\t\t\t\tbreak;\n\t\t\tci->remote_wakeup = 0;\n\t\t\terr = isr_setup_status_phase(ci);\n\t\t} else {\n\t\t\tgoto delegate;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif ((type != (USB_DIR_IN|USB_RECIP_DEVICE) ||\n\t\t\tle16_to_cpu(req.wIndex) == OTG_STS_SELECTOR) &&\n\t\t    type != (USB_DIR_IN|USB_RECIP_ENDPOINT) &&\n\t\t    type != (USB_DIR_IN|USB_RECIP_INTERFACE))\n\t\t\tgoto delegate;\n\t\tif (le16_to_cpu(req.wLength) != 2 ||\n\t\t    le16_to_cpu(req.wValue)  != 0)\n\t\t\tbreak;\n\t\terr = isr_get_status_response(ci, &req);\n\t\tbreak;\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (type != (USB_DIR_OUT|USB_RECIP_DEVICE))\n\t\t\tgoto delegate;\n\t\tif (le16_to_cpu(req.wLength) != 0 ||\n\t\t    le16_to_cpu(req.wIndex)  != 0)\n\t\t\tbreak;\n\t\tci->address = (u8)le16_to_cpu(req.wValue);\n\t\tci->setaddr = true;\n\t\terr = isr_setup_status_phase(ci);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (type == (USB_DIR_OUT|USB_RECIP_ENDPOINT) &&\n\t\t\t\tle16_to_cpu(req.wValue) ==\n\t\t\t\tUSB_ENDPOINT_HALT) {\n\t\t\tif (req.wLength != 0)\n\t\t\t\tbreak;\n\t\t\tnum  = le16_to_cpu(req.wIndex);\n\t\t\tdir = (num & USB_ENDPOINT_DIR_MASK) ? TX : RX;\n\t\t\tnum &= USB_ENDPOINT_NUMBER_MASK;\n\t\t\tif (dir == TX)\n\t\t\t\tnum += ci->hw_ep_max / 2;\n\n\t\t\tspin_unlock(&ci->lock);\n\t\t\terr = _ep_set_halt(&ci->ci_hw_ep[num].ep, 1, false);\n\t\t\tspin_lock(&ci->lock);\n\t\t\tif (!err)\n\t\t\t\tisr_setup_status_phase(ci);\n\t\t} else if (type == (USB_DIR_OUT|USB_RECIP_DEVICE)) {\n\t\t\tif (req.wLength != 0)\n\t\t\t\tbreak;\n\t\t\tswitch (le16_to_cpu(req.wValue)) {\n\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\tci->remote_wakeup = 1;\n\t\t\t\terr = isr_setup_status_phase(ci);\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_TEST_MODE:\n\t\t\t\ttmode = le16_to_cpu(req.wIndex) >> 8;\n\t\t\t\tswitch (tmode) {\n\t\t\t\tcase USB_TEST_J:\n\t\t\t\tcase USB_TEST_K:\n\t\t\t\tcase USB_TEST_SE0_NAK:\n\t\t\t\tcase USB_TEST_PACKET:\n\t\t\t\tcase USB_TEST_FORCE_ENABLE:\n\t\t\t\t\tci->test_mode = tmode;\n\t\t\t\t\terr = isr_setup_status_phase(\n\t\t\t\t\t\t\tci);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_B_HNP_ENABLE:\n\t\t\t\tif (ci_otg_is_fsm_mode(ci)) {\n\t\t\t\t\tci->gadget.b_hnp_enable = 1;\n\t\t\t\t\terr = isr_setup_status_phase(\n\t\t\t\t\t\t\tci);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_ALT_HNP_SUPPORT:\n\t\t\t\tif (ci_otg_is_fsm_mode(ci))\n\t\t\t\t\terr = otg_a_alt_hnp_support(ci);\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_HNP_SUPPORT:\n\t\t\t\tif (ci_otg_is_fsm_mode(ci)) {\n\t\t\t\t\tci->gadget.a_hnp_support = 1;\n\t\t\t\t\terr = isr_setup_status_phase(\n\t\t\t\t\t\t\tci);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgoto delegate;\n\t\t\t}\n\t\t} else {\n\t\t\tgoto delegate;\n\t\t}\n\t\tbreak;\n\tdefault:\ndelegate:\n\t\tif (req.wLength == 0)    \n\t\t\tci->ep0_dir = TX;\n\n\t\tspin_unlock(&ci->lock);\n\t\terr = ci->driver->setup(&ci->gadget, &req);\n\t\tspin_lock(&ci->lock);\n\t\tbreak;\n\t}\n\n\tif (err < 0) {\n\t\tspin_unlock(&ci->lock);\n\t\tif (_ep_set_halt(&hwep->ep, 1, false))\n\t\t\tdev_err(ci->dev, \"error: _ep_set_halt\\n\");\n\t\tspin_lock(&ci->lock);\n\t}\n}\n\n \nstatic void isr_tr_complete_handler(struct ci_hdrc *ci)\n__releases(ci->lock)\n__acquires(ci->lock)\n{\n\tunsigned i;\n\tint err;\n\n\tfor (i = 0; i < ci->hw_ep_max; i++) {\n\t\tstruct ci_hw_ep *hwep  = &ci->ci_hw_ep[i];\n\n\t\tif (hwep->ep.desc == NULL)\n\t\t\tcontinue;    \n\n\t\tif (hw_test_and_clear_complete(ci, i)) {\n\t\t\terr = isr_tr_complete_low(hwep);\n\t\t\tif (hwep->type == USB_ENDPOINT_XFER_CONTROL) {\n\t\t\t\tif (err > 0)    \n\t\t\t\t\terr = isr_setup_status_phase(ci);\n\t\t\t\tif (err < 0) {\n\t\t\t\t\tspin_unlock(&ci->lock);\n\t\t\t\t\tif (_ep_set_halt(&hwep->ep, 1, false))\n\t\t\t\t\t\tdev_err(ci->dev,\n\t\t\t\t\t\t\"error: _ep_set_halt\\n\");\n\t\t\t\t\tspin_lock(&ci->lock);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (i == 0 &&\n\t\t\thw_test_and_clear(ci, OP_ENDPTSETUPSTAT, BIT(0)))\n\t\t\tisr_setup_packet_handler(ci);\n\t}\n}\n\n \n \nstatic int ep_enable(struct usb_ep *ep,\n\t\t     const struct usb_endpoint_descriptor *desc)\n{\n\tstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\n\tint retval = 0;\n\tunsigned long flags;\n\tu32 cap = 0;\n\n\tif (ep == NULL || desc == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\n\t \n\n\tif (!list_empty(&hwep->qh.queue)) {\n\t\tdev_warn(hwep->ci->dev, \"enabling a non-empty endpoint!\\n\");\n\t\tspin_unlock_irqrestore(hwep->lock, flags);\n\t\treturn -EBUSY;\n\t}\n\n\thwep->ep.desc = desc;\n\n\thwep->dir  = usb_endpoint_dir_in(desc) ? TX : RX;\n\thwep->num  = usb_endpoint_num(desc);\n\thwep->type = usb_endpoint_type(desc);\n\n\thwep->ep.maxpacket = usb_endpoint_maxp(desc);\n\thwep->ep.mult = usb_endpoint_maxp_mult(desc);\n\n\tif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\n\t\tcap |= QH_IOS;\n\n\tcap |= QH_ZLT;\n\tcap |= (hwep->ep.maxpacket << __ffs(QH_MAX_PKT)) & QH_MAX_PKT;\n\t \n\tif (hwep->type == USB_ENDPOINT_XFER_ISOC && hwep->dir == TX)\n\t\tcap |= 3 << __ffs(QH_MULT);\n\n\thwep->qh.ptr->cap = cpu_to_le32(cap);\n\n\thwep->qh.ptr->td.next |= cpu_to_le32(TD_TERMINATE);    \n\n\tif (hwep->num != 0 && hwep->type == USB_ENDPOINT_XFER_CONTROL) {\n\t\tdev_err(hwep->ci->dev, \"Set control xfer at non-ep0\\n\");\n\t\tretval = -EINVAL;\n\t}\n\n\t \n\tif (hwep->num)\n\t\tretval |= hw_ep_enable(hwep->ci, hwep->num, hwep->dir,\n\t\t\t\t       hwep->type);\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\treturn retval;\n}\n\n \nstatic int ep_disable(struct usb_ep *ep)\n{\n\tstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\n\tint direction, retval = 0;\n\tunsigned long flags;\n\n\tif (ep == NULL)\n\t\treturn -EINVAL;\n\telse if (hwep->ep.desc == NULL)\n\t\treturn -EBUSY;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\tif (hwep->ci->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tspin_unlock_irqrestore(hwep->lock, flags);\n\t\treturn 0;\n\t}\n\n\t \n\n\tdirection = hwep->dir;\n\tdo {\n\t\tretval |= _ep_nuke(hwep);\n\t\tretval |= hw_ep_disable(hwep->ci, hwep->num, hwep->dir);\n\n\t\tif (hwep->type == USB_ENDPOINT_XFER_CONTROL)\n\t\t\thwep->dir = (hwep->dir == TX) ? RX : TX;\n\n\t} while (hwep->dir != direction);\n\n\thwep->ep.desc = NULL;\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\treturn retval;\n}\n\n \nstatic struct usb_request *ep_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\n{\n\tstruct ci_hw_req *hwreq;\n\n\tif (ep == NULL)\n\t\treturn NULL;\n\n\thwreq = kzalloc(sizeof(struct ci_hw_req), gfp_flags);\n\tif (hwreq != NULL) {\n\t\tINIT_LIST_HEAD(&hwreq->queue);\n\t\tINIT_LIST_HEAD(&hwreq->tds);\n\t}\n\n\treturn (hwreq == NULL) ? NULL : &hwreq->req;\n}\n\n \nstatic void ep_free_request(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ci_hw_ep  *hwep  = container_of(ep,  struct ci_hw_ep, ep);\n\tstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\n\tstruct td_node *node, *tmpnode;\n\tunsigned long flags;\n\n\tif (ep == NULL || req == NULL) {\n\t\treturn;\n\t} else if (!list_empty(&hwreq->queue)) {\n\t\tdev_err(hwep->ci->dev, \"freeing queued request\\n\");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\n\tlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\n\t\tdma_pool_free(hwep->td_pool, node->ptr, node->dma);\n\t\tlist_del_init(&node->td);\n\t\tnode->ptr = NULL;\n\t\tkfree(node);\n\t}\n\n\tkfree(hwreq);\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n}\n\n \nstatic int ep_queue(struct usb_ep *ep, struct usb_request *req,\n\t\t    gfp_t __maybe_unused gfp_flags)\n{\n\tstruct ci_hw_ep  *hwep  = container_of(ep,  struct ci_hw_ep, ep);\n\tint retval = 0;\n\tunsigned long flags;\n\n\tif (ep == NULL || req == NULL || hwep->ep.desc == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\tif (hwep->ci->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tspin_unlock_irqrestore(hwep->lock, flags);\n\t\treturn 0;\n\t}\n\tretval = _ep_queue(ep, req, gfp_flags);\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\treturn retval;\n}\n\n \nstatic int ep_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ci_hw_ep  *hwep  = container_of(ep,  struct ci_hw_ep, ep);\n\tstruct ci_hw_req *hwreq = container_of(req, struct ci_hw_req, req);\n\tunsigned long flags;\n\tstruct td_node *node, *tmpnode;\n\n\tif (ep == NULL || req == NULL || hwreq->req.status != -EALREADY ||\n\t\thwep->ep.desc == NULL || list_empty(&hwreq->queue) ||\n\t\tlist_empty(&hwep->qh.queue))\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\tif (hwep->ci->gadget.speed != USB_SPEED_UNKNOWN)\n\t\thw_ep_flush(hwep->ci, hwep->num, hwep->dir);\n\n\tlist_for_each_entry_safe(node, tmpnode, &hwreq->tds, td) {\n\t\tdma_pool_free(hwep->td_pool, node->ptr, node->dma);\n\t\tlist_del(&node->td);\n\t\tkfree(node);\n\t}\n\n\t \n\tlist_del_init(&hwreq->queue);\n\n\tusb_gadget_unmap_request(&hwep->ci->gadget, req, hwep->dir);\n\n\treq->status = -ECONNRESET;\n\n\tif (hwreq->req.complete != NULL) {\n\t\tspin_unlock(hwep->lock);\n\t\tusb_gadget_giveback_request(&hwep->ep, &hwreq->req);\n\t\tspin_lock(hwep->lock);\n\t}\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\treturn 0;\n}\n\n \nstatic int ep_set_halt(struct usb_ep *ep, int value)\n{\n\treturn _ep_set_halt(ep, value, true);\n}\n\n \nstatic int ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\n\tunsigned long flags;\n\n\tif (ep == NULL || hwep->ep.desc == NULL)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\thwep->wedge = 1;\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\n\treturn usb_ep_set_halt(ep);\n}\n\n \nstatic void ep_fifo_flush(struct usb_ep *ep)\n{\n\tstruct ci_hw_ep *hwep = container_of(ep, struct ci_hw_ep, ep);\n\tunsigned long flags;\n\n\tif (ep == NULL) {\n\t\tdev_err(hwep->ci->dev, \"%02X: -EINVAL\\n\", _usb_addr(hwep));\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\tif (hwep->ci->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tspin_unlock_irqrestore(hwep->lock, flags);\n\t\treturn;\n\t}\n\n\thw_ep_flush(hwep->ci, hwep->num, hwep->dir);\n\n\tspin_unlock_irqrestore(hwep->lock, flags);\n}\n\n \nstatic const struct usb_ep_ops usb_ep_ops = {\n\t.enable\t       = ep_enable,\n\t.disable       = ep_disable,\n\t.alloc_request = ep_alloc_request,\n\t.free_request  = ep_free_request,\n\t.queue\t       = ep_queue,\n\t.dequeue       = ep_dequeue,\n\t.set_halt      = ep_set_halt,\n\t.set_wedge     = ep_set_wedge,\n\t.fifo_flush    = ep_fifo_flush,\n};\n\n \n\nstatic int ci_udc_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tret = hw_read(ci, OP_FRINDEX, 0x3fff);\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\treturn ret >> 3;\n}\n\n \nstatic void ci_hdrc_gadget_connect(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\n\tif (is_active) {\n\t\tpm_runtime_get_sync(ci->dev);\n\t\thw_device_reset(ci);\n\t\tspin_lock_irq(&ci->lock);\n\t\tif (ci->driver) {\n\t\t\thw_device_state(ci, ci->ep0out->qh.dma);\n\t\t\tusb_gadget_set_state(_gadget, USB_STATE_POWERED);\n\t\t\tspin_unlock_irq(&ci->lock);\n\t\t\tusb_udc_vbus_handler(_gadget, true);\n\t\t} else {\n\t\t\tspin_unlock_irq(&ci->lock);\n\t\t}\n\t} else {\n\t\tusb_udc_vbus_handler(_gadget, false);\n\t\tif (ci->driver)\n\t\t\tci->driver->disconnect(&ci->gadget);\n\t\thw_device_state(ci, 0);\n\t\tif (ci->platdata->notify_event)\n\t\t\tci->platdata->notify_event(ci,\n\t\t\tCI_HDRC_CONTROLLER_STOPPED_EVENT);\n\t\t_gadget_stop_activity(&ci->gadget);\n\t\tpm_runtime_put_sync(ci->dev);\n\t\tusb_gadget_set_state(_gadget, USB_STATE_NOTATTACHED);\n\t}\n}\n\nstatic int ci_udc_vbus_session(struct usb_gadget *_gadget, int is_active)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tci->vbus_active = is_active;\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\tif (ci->usb_phy)\n\t\tusb_phy_set_charger_state(ci->usb_phy, is_active ?\n\t\t\tUSB_CHARGER_PRESENT : USB_CHARGER_ABSENT);\n\n\tif (ci->platdata->notify_event)\n\t\tret = ci->platdata->notify_event(ci,\n\t\t\t\tCI_HDRC_CONTROLLER_VBUS_EVENT);\n\n\tif (ci->usb_phy) {\n\t\tif (is_active)\n\t\t\tusb_phy_set_event(ci->usb_phy, USB_EVENT_VBUS);\n\t\telse\n\t\t\tusb_phy_set_event(ci->usb_phy, USB_EVENT_NONE);\n\t}\n\n\tif (ci->driver)\n\t\tci_hdrc_gadget_connect(_gadget, is_active);\n\n\treturn ret;\n}\n\nstatic int ci_udc_wakeup(struct usb_gadget *_gadget)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tif (ci->gadget.speed == USB_SPEED_UNKNOWN) {\n\t\tspin_unlock_irqrestore(&ci->lock, flags);\n\t\treturn 0;\n\t}\n\tif (!ci->remote_wakeup) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tif (!hw_read(ci, OP_PORTSC, PORTSC_SUSP)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\thw_write(ci, OP_PORTSC, PORTSC_FPR, PORTSC_FPR);\nout:\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\treturn ret;\n}\n\nstatic int ci_udc_vbus_draw(struct usb_gadget *_gadget, unsigned ma)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\n\tif (ci->usb_phy)\n\t\treturn usb_phy_set_power(ci->usb_phy, ma);\n\treturn -ENOTSUPP;\n}\n\nstatic int ci_udc_selfpowered(struct usb_gadget *_gadget, int is_on)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\tstruct ci_hw_ep *hwep = ci->ep0in;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(hwep->lock, flags);\n\t_gadget->is_selfpowered = (is_on != 0);\n\tspin_unlock_irqrestore(hwep->lock, flags);\n\n\treturn 0;\n}\n\n \nstatic int ci_udc_pullup(struct usb_gadget *_gadget, int is_on)\n{\n\tstruct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);\n\n\t \n\tif (ci_otg_is_fsm_mode(ci) || ci->role == CI_ROLE_HOST)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(ci->dev);\n\tif (is_on)\n\t\thw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\n\telse\n\t\thw_write(ci, OP_USBCMD, USBCMD_RS, 0);\n\tpm_runtime_put_sync(ci->dev);\n\n\treturn 0;\n}\n\nstatic int ci_udc_start(struct usb_gadget *gadget,\n\t\t\t struct usb_gadget_driver *driver);\nstatic int ci_udc_stop(struct usb_gadget *gadget);\n\n \nstatic struct usb_ep *ci_udc_match_ep(struct usb_gadget *gadget,\n\t\t\t      struct usb_endpoint_descriptor *desc,\n\t\t\t      struct usb_ss_ep_comp_descriptor *comp_desc)\n{\n\tstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\n\tstruct usb_ep *ep;\n\n\tif (usb_endpoint_xfer_isoc(desc) && usb_endpoint_dir_in(desc)) {\n\t\tlist_for_each_entry_reverse(ep, &ci->gadget.ep_list, ep_list) {\n\t\t\tif (ep->caps.dir_in && !ep->claimed)\n\t\t\t\treturn ep;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n \nstatic const struct usb_gadget_ops usb_gadget_ops = {\n\t.get_frame\t= ci_udc_get_frame,\n\t.vbus_session\t= ci_udc_vbus_session,\n\t.wakeup\t\t= ci_udc_wakeup,\n\t.set_selfpowered\t= ci_udc_selfpowered,\n\t.pullup\t\t= ci_udc_pullup,\n\t.vbus_draw\t= ci_udc_vbus_draw,\n\t.udc_start\t= ci_udc_start,\n\t.udc_stop\t= ci_udc_stop,\n\t.match_ep \t= ci_udc_match_ep,\n};\n\nstatic int init_eps(struct ci_hdrc *ci)\n{\n\tint retval = 0, i, j;\n\n\tfor (i = 0; i < ci->hw_ep_max/2; i++)\n\t\tfor (j = RX; j <= TX; j++) {\n\t\t\tint k = i + j * ci->hw_ep_max/2;\n\t\t\tstruct ci_hw_ep *hwep = &ci->ci_hw_ep[k];\n\n\t\t\tscnprintf(hwep->name, sizeof(hwep->name), \"ep%i%s\", i,\n\t\t\t\t\t(j == TX)  ? \"in\" : \"out\");\n\n\t\t\thwep->ci          = ci;\n\t\t\thwep->lock         = &ci->lock;\n\t\t\thwep->td_pool      = ci->td_pool;\n\n\t\t\thwep->ep.name      = hwep->name;\n\t\t\thwep->ep.ops       = &usb_ep_ops;\n\n\t\t\tif (i == 0) {\n\t\t\t\thwep->ep.caps.type_control = true;\n\t\t\t} else {\n\t\t\t\thwep->ep.caps.type_iso = true;\n\t\t\t\thwep->ep.caps.type_bulk = true;\n\t\t\t\thwep->ep.caps.type_int = true;\n\t\t\t}\n\n\t\t\tif (j == TX)\n\t\t\t\thwep->ep.caps.dir_in = true;\n\t\t\telse\n\t\t\t\thwep->ep.caps.dir_out = true;\n\n\t\t\t \n\t\t\tusb_ep_set_maxpacket_limit(&hwep->ep, (unsigned short)~0);\n\n\t\t\tINIT_LIST_HEAD(&hwep->qh.queue);\n\t\t\thwep->qh.ptr = dma_pool_zalloc(ci->qh_pool, GFP_KERNEL,\n\t\t\t\t\t\t       &hwep->qh.dma);\n\t\t\tif (hwep->qh.ptr == NULL)\n\t\t\t\tretval = -ENOMEM;\n\n\t\t\t \n\t\t\tif (i == 0) {\n\t\t\t\tif (j == RX)\n\t\t\t\t\tci->ep0out = hwep;\n\t\t\t\telse\n\t\t\t\t\tci->ep0in = hwep;\n\n\t\t\t\tusb_ep_set_maxpacket_limit(&hwep->ep, CTRL_PAYLOAD_MAX);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlist_add_tail(&hwep->ep.ep_list, &ci->gadget.ep_list);\n\t\t}\n\n\treturn retval;\n}\n\nstatic void destroy_eps(struct ci_hdrc *ci)\n{\n\tint i;\n\n\tfor (i = 0; i < ci->hw_ep_max; i++) {\n\t\tstruct ci_hw_ep *hwep = &ci->ci_hw_ep[i];\n\n\t\tif (hwep->pending_td)\n\t\t\tfree_pending_td(hwep);\n\t\tdma_pool_free(ci->qh_pool, hwep->qh.ptr, hwep->qh.dma);\n\t}\n}\n\n \nstatic int ci_udc_start(struct usb_gadget *gadget,\n\t\t\t struct usb_gadget_driver *driver)\n{\n\tstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\n\tint retval;\n\n\tif (driver->disconnect == NULL)\n\t\treturn -EINVAL;\n\n\tci->ep0out->ep.desc = &ctrl_endpt_out_desc;\n\tretval = usb_ep_enable(&ci->ep0out->ep);\n\tif (retval)\n\t\treturn retval;\n\n\tci->ep0in->ep.desc = &ctrl_endpt_in_desc;\n\tretval = usb_ep_enable(&ci->ep0in->ep);\n\tif (retval)\n\t\treturn retval;\n\n\tci->driver = driver;\n\n\t \n\tif (ci_otg_is_fsm_mode(ci) && ci->fsm.id) {\n\t\tci_hdrc_otg_fsm_start(ci);\n\t\treturn retval;\n\t}\n\n\tif (ci->vbus_active)\n\t\tci_hdrc_gadget_connect(gadget, 1);\n\telse\n\t\tusb_udc_vbus_handler(&ci->gadget, false);\n\n\treturn retval;\n}\n\nstatic void ci_udc_stop_for_otg_fsm(struct ci_hdrc *ci)\n{\n\tif (!ci_otg_is_fsm_mode(ci))\n\t\treturn;\n\n\tmutex_lock(&ci->fsm.lock);\n\tif (ci->fsm.otg->state == OTG_STATE_A_PERIPHERAL) {\n\t\tci->fsm.a_bidl_adis_tmout = 1;\n\t\tci_hdrc_otg_fsm_start(ci);\n\t} else if (ci->fsm.otg->state == OTG_STATE_B_PERIPHERAL) {\n\t\tci->fsm.protocol = PROTO_UNDEF;\n\t\tci->fsm.otg->state = OTG_STATE_UNDEFINED;\n\t}\n\tmutex_unlock(&ci->fsm.lock);\n}\n\n \nstatic int ci_udc_stop(struct usb_gadget *gadget)\n{\n\tstruct ci_hdrc *ci = container_of(gadget, struct ci_hdrc, gadget);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tci->driver = NULL;\n\n\tif (ci->vbus_active) {\n\t\thw_device_state(ci, 0);\n\t\tspin_unlock_irqrestore(&ci->lock, flags);\n\t\tif (ci->platdata->notify_event)\n\t\t\tci->platdata->notify_event(ci,\n\t\t\tCI_HDRC_CONTROLLER_STOPPED_EVENT);\n\t\t_gadget_stop_activity(&ci->gadget);\n\t\tspin_lock_irqsave(&ci->lock, flags);\n\t\tpm_runtime_put(ci->dev);\n\t}\n\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\tci_udc_stop_for_otg_fsm(ci);\n\treturn 0;\n}\n\n \n \nstatic irqreturn_t udc_irq(struct ci_hdrc *ci)\n{\n\tirqreturn_t retval;\n\tu32 intr;\n\n\tif (ci == NULL)\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock(&ci->lock);\n\n\tif (ci->platdata->flags & CI_HDRC_REGS_SHARED) {\n\t\tif (hw_read(ci, OP_USBMODE, USBMODE_CM) !=\n\t\t\t\tUSBMODE_CM_DC) {\n\t\t\tspin_unlock(&ci->lock);\n\t\t\treturn IRQ_NONE;\n\t\t}\n\t}\n\tintr = hw_test_and_clear_intr_active(ci);\n\n\tif (intr) {\n\t\t \n\t\tif (USBi_URI & intr)\n\t\t\tisr_reset_handler(ci);\n\n\t\tif (USBi_PCI & intr) {\n\t\t\tci->gadget.speed = hw_port_is_high_speed(ci) ?\n\t\t\t\tUSB_SPEED_HIGH : USB_SPEED_FULL;\n\t\t\tif (ci->usb_phy)\n\t\t\t\tusb_phy_set_event(ci->usb_phy,\n\t\t\t\t\tUSB_EVENT_ENUMERATED);\n\t\t\tif (ci->suspended) {\n\t\t\t\tif (ci->driver->resume) {\n\t\t\t\t\tspin_unlock(&ci->lock);\n\t\t\t\t\tci->driver->resume(&ci->gadget);\n\t\t\t\t\tspin_lock(&ci->lock);\n\t\t\t\t}\n\t\t\t\tci->suspended = 0;\n\t\t\t\tusb_gadget_set_state(&ci->gadget,\n\t\t\t\t\t\tci->resume_state);\n\t\t\t}\n\t\t}\n\n\t\tif (USBi_UI  & intr)\n\t\t\tisr_tr_complete_handler(ci);\n\n\t\tif ((USBi_SLI & intr) && !(ci->suspended)) {\n\t\t\tci->suspended = 1;\n\t\t\tci->resume_state = ci->gadget.state;\n\t\t\tif (ci->gadget.speed != USB_SPEED_UNKNOWN &&\n\t\t\t    ci->driver->suspend) {\n\t\t\t\tspin_unlock(&ci->lock);\n\t\t\t\tci->driver->suspend(&ci->gadget);\n\t\t\t\tspin_lock(&ci->lock);\n\t\t\t}\n\t\t\tusb_gadget_set_state(&ci->gadget,\n\t\t\t\t\tUSB_STATE_SUSPENDED);\n\t\t}\n\t\tretval = IRQ_HANDLED;\n\t} else {\n\t\tretval = IRQ_NONE;\n\t}\n\tspin_unlock(&ci->lock);\n\n\treturn retval;\n}\n\n \nstatic int udc_start(struct ci_hdrc *ci)\n{\n\tstruct device *dev = ci->dev;\n\tstruct usb_otg_caps *otg_caps = &ci->platdata->ci_otg_caps;\n\tint retval = 0;\n\n\tci->gadget.ops          = &usb_gadget_ops;\n\tci->gadget.speed        = USB_SPEED_UNKNOWN;\n\tci->gadget.max_speed    = USB_SPEED_HIGH;\n\tci->gadget.name         = ci->platdata->name;\n\tci->gadget.otg_caps\t= otg_caps;\n\tci->gadget.sg_supported = 1;\n\tci->gadget.irq\t\t= ci->irq;\n\n\tif (ci->platdata->flags & CI_HDRC_REQUIRES_ALIGNED_DMA)\n\t\tci->gadget.quirk_avoids_skb_reserve = 1;\n\n\tif (ci->is_otg && (otg_caps->hnp_support || otg_caps->srp_support ||\n\t\t\t\t\t\totg_caps->adp_support))\n\t\tci->gadget.is_otg = 1;\n\n\tINIT_LIST_HEAD(&ci->gadget.ep_list);\n\n\t \n\tci->qh_pool = dma_pool_create(\"ci_hw_qh\", dev->parent,\n\t\t\t\t       sizeof(struct ci_hw_qh),\n\t\t\t\t       64, CI_HDRC_PAGE_SIZE);\n\tif (ci->qh_pool == NULL)\n\t\treturn -ENOMEM;\n\n\tci->td_pool = dma_pool_create(\"ci_hw_td\", dev->parent,\n\t\t\t\t       sizeof(struct ci_hw_td),\n\t\t\t\t       64, CI_HDRC_PAGE_SIZE);\n\tif (ci->td_pool == NULL) {\n\t\tretval = -ENOMEM;\n\t\tgoto free_qh_pool;\n\t}\n\n\tretval = init_eps(ci);\n\tif (retval)\n\t\tgoto free_pools;\n\n\tci->gadget.ep0 = &ci->ep0in->ep;\n\n\tretval = usb_add_gadget_udc(dev, &ci->gadget);\n\tif (retval)\n\t\tgoto destroy_eps;\n\n\treturn retval;\n\ndestroy_eps:\n\tdestroy_eps(ci);\nfree_pools:\n\tdma_pool_destroy(ci->td_pool);\nfree_qh_pool:\n\tdma_pool_destroy(ci->qh_pool);\n\treturn retval;\n}\n\n \nvoid ci_hdrc_gadget_destroy(struct ci_hdrc *ci)\n{\n\tif (!ci->roles[CI_ROLE_GADGET])\n\t\treturn;\n\n\tusb_del_gadget_udc(&ci->gadget);\n\n\tdestroy_eps(ci);\n\n\tdma_pool_destroy(ci->td_pool);\n\tdma_pool_destroy(ci->qh_pool);\n}\n\nstatic int udc_id_switch_for_device(struct ci_hdrc *ci)\n{\n\tif (ci->platdata->pins_device)\n\t\tpinctrl_select_state(ci->platdata->pctl,\n\t\t\t\t     ci->platdata->pins_device);\n\n\tif (ci->is_otg)\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_BSVIS | OTGSC_BSVIE,\n\t\t\t\t\tOTGSC_BSVIS | OTGSC_BSVIE);\n\n\treturn 0;\n}\n\nstatic void udc_id_switch_for_host(struct ci_hdrc *ci)\n{\n\t \n\tif (ci->is_otg)\n\t\thw_write_otgsc(ci, OTGSC_BSVIE | OTGSC_BSVIS, OTGSC_BSVIS);\n\n\tci->vbus_active = 0;\n\n\tif (ci->platdata->pins_device && ci->platdata->pins_default)\n\t\tpinctrl_select_state(ci->platdata->pctl,\n\t\t\t\t     ci->platdata->pins_default);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void udc_suspend(struct ci_hdrc *ci)\n{\n\t \n\tif (hw_read(ci, OP_ENDPTLISTADDR, ~0) == 0)\n\t\thw_write(ci, OP_ENDPTLISTADDR, ~0, ~0);\n}\n\nstatic void udc_resume(struct ci_hdrc *ci, bool power_lost)\n{\n\tif (power_lost) {\n\t\tif (ci->is_otg)\n\t\t\thw_write_otgsc(ci, OTGSC_BSVIS | OTGSC_BSVIE,\n\t\t\t\t\tOTGSC_BSVIS | OTGSC_BSVIE);\n\t\tif (ci->vbus_active)\n\t\t\tusb_gadget_vbus_disconnect(&ci->gadget);\n\t}\n\n\t \n\tif (hw_read(ci, OP_ENDPTLISTADDR, ~0) == 0xFFFFFFFF)\n\t\thw_write(ci, OP_ENDPTLISTADDR, ~0, 0);\n}\n#endif\n\n \nint ci_hdrc_gadget_init(struct ci_hdrc *ci)\n{\n\tstruct ci_role_driver *rdrv;\n\tint ret;\n\n\tif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_DC))\n\t\treturn -ENXIO;\n\n\trdrv = devm_kzalloc(ci->dev, sizeof(*rdrv), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start\t= udc_id_switch_for_device;\n\trdrv->stop\t= udc_id_switch_for_host;\n#ifdef CONFIG_PM_SLEEP\n\trdrv->suspend\t= udc_suspend;\n\trdrv->resume\t= udc_resume;\n#endif\n\trdrv->irq\t= udc_irq;\n\trdrv->name\t= \"gadget\";\n\n\tret = udc_start(ci);\n\tif (!ret)\n\t\tci->roles[CI_ROLE_GADGET] = rdrv;\n\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}