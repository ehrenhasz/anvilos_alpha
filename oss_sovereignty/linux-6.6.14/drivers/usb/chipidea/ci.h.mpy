{
  "module_name": "ci.h",
  "hash_id": "91826ebc6038eb37657223c646b5437f58d1416a95081f2fb2b2b38f4182e7c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci.h",
  "human_readable_source": " \n \n\n#ifndef __DRIVERS_USB_CHIPIDEA_CI_H\n#define __DRIVERS_USB_CHIPIDEA_CI_H\n\n#include <linux/list.h>\n#include <linux/irqreturn.h>\n#include <linux/usb.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg-fsm.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/role.h>\n#include <linux/ulpi/interface.h>\n\n \n#define TD_PAGE_COUNT      5\n#define CI_HDRC_PAGE_SIZE  4096ul  \n#define ENDPT_MAX          32\n#define CI_MAX_BUF_SIZE\t(TD_PAGE_COUNT * CI_HDRC_PAGE_SIZE)\n\n \n \n#define ID_ID\t\t\t\t0x0\n#define ID_HWGENERAL\t\t\t0x4\n#define ID_HWHOST\t\t\t0x8\n#define ID_HWDEVICE\t\t\t0xc\n#define ID_HWTXBUF\t\t\t0x10\n#define ID_HWRXBUF\t\t\t0x14\n#define ID_SBUSCFG\t\t\t0x90\n\n \nenum ci_hw_regs {\n\tCAP_CAPLENGTH,\n\tCAP_HCCPARAMS,\n\tCAP_DCCPARAMS,\n\tCAP_TESTMODE,\n\tCAP_LAST = CAP_TESTMODE,\n\tOP_USBCMD,\n\tOP_USBSTS,\n\tOP_USBINTR,\n\tOP_FRINDEX,\n\tOP_DEVICEADDR,\n\tOP_ENDPTLISTADDR,\n\tOP_TTCTRL,\n\tOP_BURSTSIZE,\n\tOP_ULPI_VIEWPORT,\n\tOP_PORTSC,\n\tOP_DEVLC,\n\tOP_OTGSC,\n\tOP_USBMODE,\n\tOP_ENDPTSETUPSTAT,\n\tOP_ENDPTPRIME,\n\tOP_ENDPTFLUSH,\n\tOP_ENDPTSTAT,\n\tOP_ENDPTCOMPLETE,\n\tOP_ENDPTCTRL,\n\t \n\tOP_LAST = OP_ENDPTCTRL + ENDPT_MAX / 2,\n};\n\n \n \nstruct ci_hw_ep {\n\tstruct usb_ep\t\t\t\tep;\n\tu8\t\t\t\t\tdir;\n\tu8\t\t\t\t\tnum;\n\tu8\t\t\t\t\ttype;\n\tchar\t\t\t\t\tname[16];\n\tstruct {\n\t\tstruct list_head\tqueue;\n\t\tstruct ci_hw_qh\t\t*ptr;\n\t\tdma_addr_t\t\tdma;\n\t}\t\t\t\t\tqh;\n\tint\t\t\t\t\twedge;\n\n\t \n\tstruct ci_hdrc\t\t\t\t*ci;\n\tspinlock_t\t\t\t\t*lock;\n\tstruct dma_pool\t\t\t\t*td_pool;\n\tstruct td_node\t\t\t\t*pending_td;\n};\n\nenum ci_role {\n\tCI_ROLE_HOST = 0,\n\tCI_ROLE_GADGET,\n\tCI_ROLE_END,\n};\n\nenum ci_revision {\n\tCI_REVISION_1X = 10,\t \n\tCI_REVISION_20 = 20,  \n\tCI_REVISION_21,  \n\tCI_REVISION_22,  \n\tCI_REVISION_23,  \n\tCI_REVISION_24,  \n\tCI_REVISION_25,  \n\tCI_REVISION_25_PLUS,  \n\tCI_REVISION_UNKNOWN = 99,  \n};\n\n \nstruct ci_role_driver {\n\tint\t\t(*start)(struct ci_hdrc *);\n\tvoid\t\t(*stop)(struct ci_hdrc *);\n\tvoid\t\t(*suspend)(struct ci_hdrc *ci);\n\tvoid\t\t(*resume)(struct ci_hdrc *ci, bool power_lost);\n\tirqreturn_t\t(*irq)(struct ci_hdrc *);\n\tconst char\t*name;\n};\n\n \nstruct hw_bank {\n\tunsigned\tlpm;\n\tresource_size_t\tphys;\n\tvoid __iomem\t*abs;\n\tvoid __iomem\t*cap;\n\tvoid __iomem\t*op;\n\tsize_t\t\tsize;\n\tvoid __iomem\t*regmap[OP_LAST + 1];\n};\n\n \nstruct ci_hdrc {\n\tstruct device\t\t\t*dev;\n\tspinlock_t\t\t\tlock;\n\tstruct hw_bank\t\t\thw_bank;\n\tint\t\t\t\tirq;\n\tstruct ci_role_driver\t\t*roles[CI_ROLE_END];\n\tenum ci_role\t\t\trole;\n\tbool\t\t\t\tis_otg;\n\tstruct usb_otg\t\t\totg;\n\tstruct otg_fsm\t\t\tfsm;\n\tstruct hrtimer\t\t\totg_fsm_hrtimer;\n\tktime_t\t\t\t\thr_timeouts[NUM_OTG_FSM_TIMERS];\n\tunsigned\t\t\tenabled_otg_timer_bits;\n\tenum otg_fsm_timer\t\tnext_otg_timer;\n\tstruct usb_role_switch\t\t*role_switch;\n\tstruct work_struct\t\twork;\n\tstruct workqueue_struct\t\t*wq;\n\n\tstruct dma_pool\t\t\t*qh_pool;\n\tstruct dma_pool\t\t\t*td_pool;\n\n\tstruct usb_gadget\t\tgadget;\n\tstruct usb_gadget_driver\t*driver;\n\tenum usb_device_state\t\tresume_state;\n\tunsigned\t\t\thw_ep_max;\n\tstruct ci_hw_ep\t\t\tci_hw_ep[ENDPT_MAX];\n\tu32\t\t\t\tep0_dir;\n\tstruct ci_hw_ep\t\t\t*ep0out, *ep0in;\n\n\tstruct usb_request\t\t*status;\n\tbool\t\t\t\tsetaddr;\n\tu8\t\t\t\taddress;\n\tu8\t\t\t\tremote_wakeup;\n\tu8\t\t\t\tsuspended;\n\tu8\t\t\t\ttest_mode;\n\n\tstruct ci_hdrc_platform_data\t*platdata;\n\tint\t\t\t\tvbus_active;\n\tstruct ulpi\t\t\t*ulpi;\n\tstruct ulpi_ops \t\tulpi_ops;\n\tstruct phy\t\t\t*phy;\n\t \n\tstruct usb_phy\t\t\t*usb_phy;\n\tstruct usb_hcd\t\t\t*hcd;\n\tbool\t\t\t\tid_event;\n\tbool\t\t\t\tb_sess_valid_event;\n\tbool\t\t\t\timx28_write_fix;\n\tbool\t\t\t\thas_portsc_pec_bug;\n\tbool\t\t\t\tsupports_runtime_pm;\n\tbool\t\t\t\tin_lpm;\n\tbool\t\t\t\twakeup_int;\n\tenum ci_revision\t\trev;\n\tstruct mutex                    mutex;\n};\n\nstatic inline struct ci_role_driver *ci_role(struct ci_hdrc *ci)\n{\n\tBUG_ON(ci->role >= CI_ROLE_END || !ci->roles[ci->role]);\n\treturn ci->roles[ci->role];\n}\n\nstatic inline int ci_role_start(struct ci_hdrc *ci, enum ci_role role)\n{\n\tint ret;\n\n\tif (role >= CI_ROLE_END)\n\t\treturn -EINVAL;\n\n\tif (!ci->roles[role])\n\t\treturn -ENXIO;\n\n\tret = ci->roles[role]->start(ci);\n\tif (ret)\n\t\treturn ret;\n\n\tci->role = role;\n\n\tif (ci->usb_phy) {\n\t\tif (role == CI_ROLE_HOST)\n\t\t\tusb_phy_set_event(ci->usb_phy, USB_EVENT_ID);\n\t\telse\n\t\t\t \n\t\t\tusb_phy_set_event(ci->usb_phy, USB_EVENT_NONE);\n\t}\n\n\treturn ret;\n}\n\nstatic inline void ci_role_stop(struct ci_hdrc *ci)\n{\n\tenum ci_role role = ci->role;\n\n\tif (role == CI_ROLE_END)\n\t\treturn;\n\n\tci->role = CI_ROLE_END;\n\n\tci->roles[role]->stop(ci);\n\n\tif (ci->usb_phy)\n\t\tusb_phy_set_event(ci->usb_phy, USB_EVENT_NONE);\n}\n\nstatic inline enum usb_role ci_role_to_usb_role(struct ci_hdrc *ci)\n{\n\tif (ci->role == CI_ROLE_HOST)\n\t\treturn USB_ROLE_HOST;\n\telse if (ci->role == CI_ROLE_GADGET && ci->vbus_active)\n\t\treturn USB_ROLE_DEVICE;\n\telse\n\t\treturn USB_ROLE_NONE;\n}\n\nstatic inline enum ci_role usb_role_to_ci_role(enum usb_role role)\n{\n\tif (role == USB_ROLE_HOST)\n\t\treturn CI_ROLE_HOST;\n\telse if (role == USB_ROLE_DEVICE)\n\t\treturn CI_ROLE_GADGET;\n\telse\n\t\treturn CI_ROLE_END;\n}\n\n \nstatic inline u32 hw_read_id_reg(struct ci_hdrc *ci, u32 offset, u32 mask)\n{\n\treturn ioread32(ci->hw_bank.abs + offset) & mask;\n}\n\n \nstatic inline void hw_write_id_reg(struct ci_hdrc *ci, u32 offset,\n\t\t\t    u32 mask, u32 data)\n{\n\tif (~mask)\n\t\tdata = (ioread32(ci->hw_bank.abs + offset) & ~mask)\n\t\t\t| (data & mask);\n\n\tiowrite32(data, ci->hw_bank.abs + offset);\n}\n\n \nstatic inline u32 hw_read(struct ci_hdrc *ci, enum ci_hw_regs reg, u32 mask)\n{\n\treturn ioread32(ci->hw_bank.regmap[reg]) & mask;\n}\n\n#ifdef CONFIG_SOC_IMX28\nstatic inline void imx28_ci_writel(u32 val, volatile void __iomem *addr)\n{\n\t__asm__ (\"swp %0, %0, [%1]\" : : \"r\"(val), \"r\"(addr));\n}\n#else\nstatic inline void imx28_ci_writel(u32 val, volatile void __iomem *addr)\n{\n}\n#endif\n\nstatic inline void __hw_write(struct ci_hdrc *ci, u32 val,\n\t\tvoid __iomem *addr)\n{\n\tif (ci->imx28_write_fix)\n\t\timx28_ci_writel(val, addr);\n\telse\n\t\tiowrite32(val, addr);\n}\n\n \nstatic inline void hw_write(struct ci_hdrc *ci, enum ci_hw_regs reg,\n\t\t\t    u32 mask, u32 data)\n{\n\tif (~mask)\n\t\tdata = (ioread32(ci->hw_bank.regmap[reg]) & ~mask)\n\t\t\t| (data & mask);\n\n\t__hw_write(ci, data, ci->hw_bank.regmap[reg]);\n}\n\n \nstatic inline u32 hw_test_and_clear(struct ci_hdrc *ci, enum ci_hw_regs reg,\n\t\t\t\t    u32 mask)\n{\n\tu32 val = ioread32(ci->hw_bank.regmap[reg]) & mask;\n\n\t__hw_write(ci, val, ci->hw_bank.regmap[reg]);\n\treturn val;\n}\n\n \nstatic inline u32 hw_test_and_write(struct ci_hdrc *ci, enum ci_hw_regs reg,\n\t\t\t\t    u32 mask, u32 data)\n{\n\tu32 val = hw_read(ci, reg, ~0);\n\n\thw_write(ci, reg, mask, data);\n\treturn (val & mask) >> __ffs(mask);\n}\n\n \nstatic inline bool ci_otg_is_fsm_mode(struct ci_hdrc *ci)\n{\n#ifdef CONFIG_USB_OTG_FSM\n\tstruct usb_otg_caps *otg_caps = &ci->platdata->ci_otg_caps;\n\n\treturn ci->is_otg && ci->roles[CI_ROLE_HOST] &&\n\t\tci->roles[CI_ROLE_GADGET] && (otg_caps->srp_support ||\n\t\totg_caps->hnp_support || otg_caps->adp_support);\n#else\n\treturn false;\n#endif\n}\n\nint ci_ulpi_init(struct ci_hdrc *ci);\nvoid ci_ulpi_exit(struct ci_hdrc *ci);\nint ci_ulpi_resume(struct ci_hdrc *ci);\n\nu32 hw_read_intr_enable(struct ci_hdrc *ci);\n\nu32 hw_read_intr_status(struct ci_hdrc *ci);\n\nint hw_device_reset(struct ci_hdrc *ci);\n\nint hw_port_test_set(struct ci_hdrc *ci, u8 mode);\n\nu8 hw_port_test_get(struct ci_hdrc *ci);\n\nvoid hw_phymode_configure(struct ci_hdrc *ci);\n\nvoid ci_platform_configure(struct ci_hdrc *ci);\n\nvoid dbg_create_files(struct ci_hdrc *ci);\n\nvoid dbg_remove_files(struct ci_hdrc *ci);\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}