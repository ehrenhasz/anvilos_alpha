{
  "module_name": "ulpi.c",
  "hash_id": "aa434cf2eabaa934fed1b89b6609772f26320777d4ce15cfe7fc5ec28eb0fcca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ulpi.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/usb/chipidea.h>\n#include <linux/ulpi/interface.h>\n\n#include \"ci.h\"\n\n#define ULPI_WAKEUP\t\tBIT(31)\n#define ULPI_RUN\t\tBIT(30)\n#define ULPI_WRITE\t\tBIT(29)\n#define ULPI_SYNC_STATE\t\tBIT(27)\n#define ULPI_ADDR(n)\t\t((n) << 16)\n#define ULPI_DATA(n)\t\t(n)\n\nstatic int ci_ulpi_wait(struct ci_hdrc *ci, u32 mask)\n{\n\tunsigned long usec = 10000;\n\n\twhile (usec--) {\n\t\tif (!hw_read(ci, OP_ULPI_VIEWPORT, mask))\n\t\t\treturn 0;\n\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic int ci_ulpi_read(struct device *dev, u8 addr)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tint ret;\n\n\thw_write(ci, OP_ULPI_VIEWPORT, 0xffffffff, ULPI_WRITE | ULPI_WAKEUP);\n\tret = ci_ulpi_wait(ci, ULPI_WAKEUP);\n\tif (ret)\n\t\treturn ret;\n\n\thw_write(ci, OP_ULPI_VIEWPORT, 0xffffffff, ULPI_RUN | ULPI_ADDR(addr));\n\tret = ci_ulpi_wait(ci, ULPI_RUN);\n\tif (ret)\n\t\treturn ret;\n\n\treturn hw_read(ci, OP_ULPI_VIEWPORT, GENMASK(15, 8)) >> 8;\n}\n\nstatic int ci_ulpi_write(struct device *dev, u8 addr, u8 val)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tint ret;\n\n\thw_write(ci, OP_ULPI_VIEWPORT, 0xffffffff, ULPI_WRITE | ULPI_WAKEUP);\n\tret = ci_ulpi_wait(ci, ULPI_WAKEUP);\n\tif (ret)\n\t\treturn ret;\n\n\thw_write(ci, OP_ULPI_VIEWPORT, 0xffffffff,\n\t\t ULPI_RUN | ULPI_WRITE | ULPI_ADDR(addr) | val);\n\treturn ci_ulpi_wait(ci, ULPI_RUN);\n}\n\nint ci_ulpi_init(struct ci_hdrc *ci)\n{\n\tif (ci->platdata->phy_mode != USBPHY_INTERFACE_MODE_ULPI)\n\t\treturn 0;\n\n\t \n\thw_phymode_configure(ci);\n\n\tci->ulpi_ops.read = ci_ulpi_read;\n\tci->ulpi_ops.write = ci_ulpi_write;\n\tci->ulpi = ulpi_register_interface(ci->dev, &ci->ulpi_ops);\n\tif (IS_ERR(ci->ulpi))\n\t\tdev_err(ci->dev, \"failed to register ULPI interface\");\n\n\treturn PTR_ERR_OR_ZERO(ci->ulpi);\n}\n\nvoid ci_ulpi_exit(struct ci_hdrc *ci)\n{\n\tif (ci->ulpi) {\n\t\tulpi_unregister_interface(ci->ulpi);\n\t\tci->ulpi = NULL;\n\t}\n}\n\nint ci_ulpi_resume(struct ci_hdrc *ci)\n{\n\tint cnt = 100000;\n\n\tif (ci->platdata->phy_mode != USBPHY_INTERFACE_MODE_ULPI)\n\t\treturn 0;\n\n\twhile (cnt-- > 0) {\n\t\tif (hw_read(ci, OP_ULPI_VIEWPORT, ULPI_SYNC_STATE))\n\t\t\treturn 0;\n\t\tudelay(1);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}