{
  "module_name": "otg_fsm.c",
  "hash_id": "5f1bcf649629b3e0ac0bc27432f63c62cd1f4fa42e9e74aefa5a5e0b10db9218",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/otg_fsm.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/usb/otg.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/chipidea.h>\n#include <linux/regulator/consumer.h>\n\n#include \"ci.h\"\n#include \"bits.h\"\n#include \"otg.h\"\n#include \"otg_fsm.h\"\n\n \nstatic ssize_t\na_bus_req_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar\t\t*next;\n\tunsigned\tsize, t;\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tt = scnprintf(next, size, \"%d\\n\", ci->fsm.a_bus_req);\n\tsize -= t;\n\tnext += t;\n\n\treturn PAGE_SIZE - size;\n}\n\nstatic ssize_t\na_bus_req_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tmutex_lock(&ci->fsm.lock);\n\tif (buf[0] == '0') {\n\t\tci->fsm.a_bus_req = 0;\n\t} else if (buf[0] == '1') {\n\t\t \n\t\tif (ci->fsm.a_bus_drop) {\n\t\t\tmutex_unlock(&ci->fsm.lock);\n\t\t\treturn count;\n\t\t}\n\t\tci->fsm.a_bus_req = 1;\n\t\tif (ci->fsm.otg->state == OTG_STATE_A_PERIPHERAL) {\n\t\t\tci->gadget.host_request_flag = 1;\n\t\t\tmutex_unlock(&ci->fsm.lock);\n\t\t\treturn count;\n\t\t}\n\t}\n\n\tci_otg_queue_work(ci);\n\tmutex_unlock(&ci->fsm.lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(a_bus_req);\n\nstatic ssize_t\na_bus_drop_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar\t\t*next;\n\tunsigned\tsize, t;\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tt = scnprintf(next, size, \"%d\\n\", ci->fsm.a_bus_drop);\n\tsize -= t;\n\tnext += t;\n\n\treturn PAGE_SIZE - size;\n}\n\nstatic ssize_t\na_bus_drop_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tmutex_lock(&ci->fsm.lock);\n\tif (buf[0] == '0') {\n\t\tci->fsm.a_bus_drop = 0;\n\t} else if (buf[0] == '1') {\n\t\tci->fsm.a_bus_drop = 1;\n\t\tci->fsm.a_bus_req = 0;\n\t}\n\n\tci_otg_queue_work(ci);\n\tmutex_unlock(&ci->fsm.lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(a_bus_drop);\n\nstatic ssize_t\nb_bus_req_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tchar\t\t*next;\n\tunsigned\tsize, t;\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tnext = buf;\n\tsize = PAGE_SIZE;\n\tt = scnprintf(next, size, \"%d\\n\", ci->fsm.b_bus_req);\n\tsize -= t;\n\tnext += t;\n\n\treturn PAGE_SIZE - size;\n}\n\nstatic ssize_t\nb_bus_req_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tmutex_lock(&ci->fsm.lock);\n\tif (buf[0] == '0')\n\t\tci->fsm.b_bus_req = 0;\n\telse if (buf[0] == '1') {\n\t\tci->fsm.b_bus_req = 1;\n\t\tif (ci->fsm.otg->state == OTG_STATE_B_PERIPHERAL) {\n\t\t\tci->gadget.host_request_flag = 1;\n\t\t\tmutex_unlock(&ci->fsm.lock);\n\t\t\treturn count;\n\t\t}\n\t}\n\n\tci_otg_queue_work(ci);\n\tmutex_unlock(&ci->fsm.lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(b_bus_req);\n\nstatic ssize_t\na_clr_err_store(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ci_hdrc\t*ci = dev_get_drvdata(dev);\n\n\tif (count > 2)\n\t\treturn -1;\n\n\tmutex_lock(&ci->fsm.lock);\n\tif (buf[0] == '1')\n\t\tci->fsm.a_clr_err = 1;\n\n\tci_otg_queue_work(ci);\n\tmutex_unlock(&ci->fsm.lock);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(a_clr_err);\n\nstatic struct attribute *inputs_attrs[] = {\n\t&dev_attr_a_bus_req.attr,\n\t&dev_attr_a_bus_drop.attr,\n\t&dev_attr_b_bus_req.attr,\n\t&dev_attr_a_clr_err.attr,\n\tNULL,\n};\n\nstatic const struct attribute_group inputs_attr_group = {\n\t.name = \"inputs\",\n\t.attrs = inputs_attrs,\n};\n\n \nstatic unsigned otg_timer_ms[] = {\n\tTA_WAIT_VRISE,\n\tTA_WAIT_VFALL,\n\tTA_WAIT_BCON,\n\tTA_AIDL_BDIS,\n\tTB_ASE0_BRST,\n\tTA_BIDL_ADIS,\n\tTB_AIDL_BDIS,\n\tTB_SE0_SRP,\n\tTB_SRP_FAIL,\n\t0,\n\tTB_DATA_PLS,\n\tTB_SSEND_SRP,\n};\n\n \nstatic void ci_otg_add_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)\n{\n\tunsigned long flags, timer_sec, timer_nsec;\n\n\tif (t >= NUM_OTG_FSM_TIMERS)\n\t\treturn;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\ttimer_sec = otg_timer_ms[t] / MSEC_PER_SEC;\n\ttimer_nsec = (otg_timer_ms[t] % MSEC_PER_SEC) * NSEC_PER_MSEC;\n\tci->hr_timeouts[t] = ktime_add(ktime_get(),\n\t\t\t\tktime_set(timer_sec, timer_nsec));\n\tci->enabled_otg_timer_bits |= (1 << t);\n\tif ((ci->next_otg_timer == NUM_OTG_FSM_TIMERS) ||\n\t\t\tktime_after(ci->hr_timeouts[ci->next_otg_timer],\n\t\t\t\t\t\tci->hr_timeouts[t])) {\n\t\t\tci->next_otg_timer = t;\n\t\t\thrtimer_start_range_ns(&ci->otg_fsm_hrtimer,\n\t\t\t\t\tci->hr_timeouts[t], NSEC_PER_MSEC,\n\t\t\t\t\t\t\tHRTIMER_MODE_ABS);\n\t}\n\tspin_unlock_irqrestore(&ci->lock, flags);\n}\n\n \nstatic void ci_otg_del_timer(struct ci_hdrc *ci, enum otg_fsm_timer t)\n{\n\tunsigned long flags, enabled_timer_bits;\n\tenum otg_fsm_timer cur_timer, next_timer = NUM_OTG_FSM_TIMERS;\n\n\tif ((t >= NUM_OTG_FSM_TIMERS) ||\n\t\t\t!(ci->enabled_otg_timer_bits & (1 << t)))\n\t\treturn;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tci->enabled_otg_timer_bits &= ~(1 << t);\n\tif (ci->next_otg_timer == t) {\n\t\tif (ci->enabled_otg_timer_bits == 0) {\n\t\t\tspin_unlock_irqrestore(&ci->lock, flags);\n\t\t\t \n\t\t\thrtimer_cancel(&ci->otg_fsm_hrtimer);\n\t\t\tspin_lock_irqsave(&ci->lock, flags);\n\t\t\tci->next_otg_timer = NUM_OTG_FSM_TIMERS;\n\t\t} else {\n\t\t\t \n\t\t\tenabled_timer_bits = ci->enabled_otg_timer_bits;\n\t\t\tfor_each_set_bit(cur_timer, &enabled_timer_bits,\n\t\t\t\t\t\t\tNUM_OTG_FSM_TIMERS) {\n\t\t\t\tif ((next_timer == NUM_OTG_FSM_TIMERS) ||\n\t\t\t\t\tktime_before(ci->hr_timeouts[next_timer],\n\t\t\t\t\t ci->hr_timeouts[cur_timer]))\n\t\t\t\t\tnext_timer = cur_timer;\n\t\t\t}\n\t\t}\n\t}\n\tif (next_timer != NUM_OTG_FSM_TIMERS) {\n\t\tci->next_otg_timer = next_timer;\n\t\thrtimer_start_range_ns(&ci->otg_fsm_hrtimer,\n\t\t\tci->hr_timeouts[next_timer], NSEC_PER_MSEC,\n\t\t\t\t\t\t\tHRTIMER_MODE_ABS);\n\t}\n\tspin_unlock_irqrestore(&ci->lock, flags);\n}\n\n \nstatic int a_wait_vrise_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_wait_vrise_tmout = 1;\n\treturn 0;\n}\n\nstatic int a_wait_vfall_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_wait_vfall_tmout = 1;\n\treturn 0;\n}\n\nstatic int a_wait_bcon_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_wait_bcon_tmout = 1;\n\treturn 0;\n}\n\nstatic int a_aidl_bdis_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_aidl_bdis_tmout = 1;\n\treturn 0;\n}\n\nstatic int b_ase0_brst_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.b_ase0_brst_tmout = 1;\n\treturn 0;\n}\n\nstatic int a_bidl_adis_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_bidl_adis_tmout = 1;\n\treturn 0;\n}\n\nstatic int b_aidl_bdis_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.a_bus_suspend = 1;\n\treturn 0;\n}\n\nstatic int b_se0_srp_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.b_se0_srp = 1;\n\treturn 0;\n}\n\nstatic int b_srp_fail_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.b_srp_done = 1;\n\treturn 1;\n}\n\nstatic int b_data_pls_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.b_srp_done = 1;\n\tci->fsm.b_bus_req = 0;\n\tif (ci->fsm.power_up)\n\t\tci->fsm.power_up = 0;\n\thw_write_otgsc(ci, OTGSC_HABA, 0);\n\tpm_runtime_put(ci->dev);\n\treturn 0;\n}\n\nstatic int b_ssend_srp_tmout(struct ci_hdrc *ci)\n{\n\tci->fsm.b_ssend_srp = 1;\n\t \n\tif (ci->fsm.otg->state == OTG_STATE_B_IDLE)\n\t\treturn 0;\n\telse\n\t\treturn 1;\n}\n\n \nstatic int (*otg_timer_handlers[])(struct ci_hdrc *) = {\n\ta_wait_vrise_tmout,\t \n\ta_wait_vfall_tmout,\t \n\ta_wait_bcon_tmout,\t \n\ta_aidl_bdis_tmout,\t \n\tb_ase0_brst_tmout,\t \n\ta_bidl_adis_tmout,\t \n\tb_aidl_bdis_tmout,\t \n\tb_se0_srp_tmout,\t \n\tb_srp_fail_tmout,\t \n\tNULL,\t\t\t \n\tb_data_pls_tmout,\t \n\tb_ssend_srp_tmout,\t \n};\n\n \nstatic enum hrtimer_restart ci_otg_hrtimer_func(struct hrtimer *t)\n{\n\tstruct ci_hdrc *ci = container_of(t, struct ci_hdrc, otg_fsm_hrtimer);\n\tktime_t\tnow, *timeout;\n\tunsigned long   enabled_timer_bits;\n\tunsigned long   flags;\n\tenum otg_fsm_timer cur_timer, next_timer = NUM_OTG_FSM_TIMERS;\n\tint ret = -EINVAL;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tenabled_timer_bits = ci->enabled_otg_timer_bits;\n\tci->next_otg_timer = NUM_OTG_FSM_TIMERS;\n\n\tnow = ktime_get();\n\tfor_each_set_bit(cur_timer, &enabled_timer_bits, NUM_OTG_FSM_TIMERS) {\n\t\tif (ktime_compare(now, ci->hr_timeouts[cur_timer]) >= 0) {\n\t\t\tci->enabled_otg_timer_bits &= ~(1 << cur_timer);\n\t\t\tif (otg_timer_handlers[cur_timer])\n\t\t\t\tret = otg_timer_handlers[cur_timer](ci);\n\t\t} else {\n\t\t\tif ((next_timer == NUM_OTG_FSM_TIMERS) ||\n\t\t\t\tktime_before(ci->hr_timeouts[cur_timer],\n\t\t\t\t\tci->hr_timeouts[next_timer]))\n\t\t\t\tnext_timer = cur_timer;\n\t\t}\n\t}\n\t \n\tif (next_timer < NUM_OTG_FSM_TIMERS) {\n\t\ttimeout = &ci->hr_timeouts[next_timer];\n\t\thrtimer_start_range_ns(&ci->otg_fsm_hrtimer, *timeout,\n\t\t\t\t\tNSEC_PER_MSEC, HRTIMER_MODE_ABS);\n\t\tci->next_otg_timer = next_timer;\n\t}\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\tif (!ret)\n\t\tci_otg_queue_work(ci);\n\n\treturn HRTIMER_NORESTART;\n}\n\n \nstatic int ci_otg_init_timers(struct ci_hdrc *ci)\n{\n\thrtimer_init(&ci->otg_fsm_hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tci->otg_fsm_hrtimer.function = ci_otg_hrtimer_func;\n\n\treturn 0;\n}\n\n \n \n \nstatic void ci_otg_fsm_add_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (t < NUM_OTG_FSM_TIMERS)\n\t\tci_otg_add_timer(ci, t);\n\treturn;\n}\n\nstatic void ci_otg_fsm_del_timer(struct otg_fsm *fsm, enum otg_fsm_timer t)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (t < NUM_OTG_FSM_TIMERS)\n\t\tci_otg_del_timer(ci, t);\n\treturn;\n}\n\n \nstatic void ci_otg_drv_vbus(struct otg_fsm *fsm, int on)\n{\n\tint ret;\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (on) {\n\t\t \n\t\thw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_PP,\n\t\t\t\t\t\t\tPORTSC_PP);\n\t\tif (ci->platdata->reg_vbus) {\n\t\t\tret = regulator_enable(ci->platdata->reg_vbus);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(ci->dev,\n\t\t\t\t\"Failed to enable vbus regulator, ret=%d\\n\",\n\t\t\t\tret);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL)\n\t\t\tusb_phy_vbus_on(ci->usb_phy);\n\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_DPIE, 0);\n\n\t\tfsm->a_srp_det = 0;\n\t\tfsm->power_up = 0;\n\t} else {\n\t\tif (ci->platdata->reg_vbus)\n\t\t\tregulator_disable(ci->platdata->reg_vbus);\n\n\t\tif (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL)\n\t\t\tusb_phy_vbus_off(ci->usb_phy);\n\n\t\tfsm->a_bus_drop = 1;\n\t\tfsm->a_bus_req = 0;\n\t}\n}\n\n \nstatic void ci_otg_loc_conn(struct otg_fsm *fsm, int on)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (on)\n\t\thw_write(ci, OP_USBCMD, USBCMD_RS, USBCMD_RS);\n\telse\n\t\thw_write(ci, OP_USBCMD, USBCMD_RS, 0);\n}\n\n \nstatic void ci_otg_loc_sof(struct otg_fsm *fsm, int on)\n{\n\tstruct usb_device *udev;\n\n\tif (!fsm->otg->host)\n\t\treturn;\n\n\tudev = usb_hub_find_child(fsm->otg->host->root_hub, 1);\n\tif (!udev)\n\t\treturn;\n\n\tif (on) {\n\t\tusb_disable_autosuspend(udev);\n\t} else {\n\t\tpm_runtime_set_autosuspend_delay(&udev->dev, 0);\n\t\tusb_enable_autosuspend(udev);\n\t}\n}\n\n \nstatic void ci_otg_start_pulse(struct otg_fsm *fsm)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\t \n\thw_write_otgsc(ci, OTGSC_HADP, OTGSC_HADP);\n\n\tpm_runtime_get(ci->dev);\n\tci_otg_add_timer(ci, B_DATA_PLS);\n}\n\nstatic int ci_otg_start_host(struct otg_fsm *fsm, int on)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (on) {\n\t\tci_role_stop(ci);\n\t\tci_role_start(ci, CI_ROLE_HOST);\n\t} else {\n\t\tci_role_stop(ci);\n\t\tci_role_start(ci, CI_ROLE_GADGET);\n\t}\n\treturn 0;\n}\n\nstatic int ci_otg_start_gadget(struct otg_fsm *fsm, int on)\n{\n\tstruct ci_hdrc\t*ci = container_of(fsm, struct ci_hdrc, fsm);\n\n\tif (on)\n\t\tusb_gadget_vbus_connect(&ci->gadget);\n\telse\n\t\tusb_gadget_vbus_disconnect(&ci->gadget);\n\n\treturn 0;\n}\n\nstatic struct otg_fsm_ops ci_otg_ops = {\n\t.drv_vbus = ci_otg_drv_vbus,\n\t.loc_conn = ci_otg_loc_conn,\n\t.loc_sof = ci_otg_loc_sof,\n\t.start_pulse = ci_otg_start_pulse,\n\t.add_timer = ci_otg_fsm_add_timer,\n\t.del_timer = ci_otg_fsm_del_timer,\n\t.start_host = ci_otg_start_host,\n\t.start_gadget = ci_otg_start_gadget,\n};\n\nint ci_otg_fsm_work(struct ci_hdrc *ci)\n{\n\t \n\tif (ci->fsm.id && !(ci->driver) &&\n\t\tci->fsm.otg->state < OTG_STATE_A_IDLE)\n\t\treturn 0;\n\n\tpm_runtime_get_sync(ci->dev);\n\tif (otg_statemachine(&ci->fsm)) {\n\t\tif (ci->fsm.otg->state == OTG_STATE_A_IDLE) {\n\t\t\t \n\t\t\tif ((ci->fsm.id) || (ci->id_event) ||\n\t\t\t\t\t\t(ci->fsm.power_up)) {\n\t\t\t\tci_otg_queue_work(ci);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\thw_write(ci, OP_PORTSC, PORTSC_W1C_BITS |\n\t\t\t\t\t\t\t\tPORTSC_PP, 0);\n\t\t\t\thw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\n\t\t\t\thw_write_otgsc(ci, OTGSC_DPIE, OTGSC_DPIE);\n\t\t\t}\n\t\t\tif (ci->id_event)\n\t\t\t\tci->id_event = false;\n\t\t} else if (ci->fsm.otg->state == OTG_STATE_B_IDLE) {\n\t\t\tif (ci->fsm.b_sess_vld) {\n\t\t\t\tci->fsm.power_up = 0;\n\t\t\t\t \n\t\t\t\tci_otg_queue_work(ci);\n\t\t\t}\n\t\t} else if (ci->fsm.otg->state == OTG_STATE_A_HOST) {\n\t\t\tpm_runtime_mark_last_busy(ci->dev);\n\t\t\tpm_runtime_put_autosuspend(ci->dev);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tpm_runtime_put_sync(ci->dev);\n\treturn 0;\n}\n\n \nstatic void ci_otg_fsm_event(struct ci_hdrc *ci)\n{\n\tu32 intr_sts, otg_bsess_vld, port_conn;\n\tstruct otg_fsm *fsm = &ci->fsm;\n\n\tintr_sts = hw_read_intr_status(ci);\n\totg_bsess_vld = hw_read_otgsc(ci, OTGSC_BSV);\n\tport_conn = hw_read(ci, OP_PORTSC, PORTSC_CCS);\n\n\tswitch (ci->fsm.otg->state) {\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tif (port_conn) {\n\t\t\tfsm->b_conn = 1;\n\t\t\tfsm->a_bus_req = 1;\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_IDLE:\n\t\tif (otg_bsess_vld && (intr_sts & USBi_PCI) && port_conn) {\n\t\t\tfsm->b_sess_vld = 1;\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif ((intr_sts & USBi_SLI) && port_conn && otg_bsess_vld) {\n\t\t\tci_otg_add_timer(ci, B_AIDL_BDIS);\n\t\t} else if (intr_sts & USBi_PCI) {\n\t\t\tci_otg_del_timer(ci, B_AIDL_BDIS);\n\t\t\tif (fsm->a_bus_suspend == 1)\n\t\t\t\tfsm->a_bus_suspend = 0;\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\tif ((intr_sts & USBi_PCI) && !port_conn) {\n\t\t\tfsm->a_conn = 0;\n\t\t\tfsm->b_bus_req = 0;\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\tif (intr_sts & USBi_SLI) {\n\t\t\t fsm->b_bus_suspend = 1;\n\t\t\t \n\t\t\t ci_otg_add_timer(ci, A_BIDL_ADIS);\n\t\t}\n\n\t\tif (intr_sts & USBi_URI)\n\t\t\tci_otg_del_timer(ci, A_BIDL_ADIS);\n\n\t\tif (intr_sts & USBi_PCI) {\n\t\t\tif (fsm->b_bus_suspend == 1) {\n\t\t\t\tci_otg_del_timer(ci, A_BIDL_ADIS);\n\t\t\t\tfsm->b_bus_suspend = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_SUSPEND:\n\t\tif ((intr_sts & USBi_PCI) && !port_conn) {\n\t\t\tfsm->b_conn = 0;\n\n\t\t\t \n\t\t\tif (ci->driver) {\n\t\t\t\t \n\t\t\t\tci->gadget.is_a_peripheral = 1;\n\t\t\t}\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\tif ((intr_sts & USBi_PCI) && !port_conn) {\n\t\t\tfsm->b_conn = 0;\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\tif ((intr_sts & USBi_PCI) && port_conn) {\n\t\t\tfsm->a_conn = 1;\n\t\t\tci_otg_queue_work(ci);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n \nirqreturn_t ci_otg_fsm_irq(struct ci_hdrc *ci)\n{\n\tirqreturn_t retval =  IRQ_NONE;\n\tu32 otgsc, otg_int_src = 0;\n\tstruct otg_fsm *fsm = &ci->fsm;\n\n\totgsc = hw_read_otgsc(ci, ~0);\n\totg_int_src = otgsc & OTGSC_INT_STATUS_BITS & (otgsc >> 8);\n\tfsm->id = (otgsc & OTGSC_ID) ? 1 : 0;\n\n\tif (otg_int_src) {\n\t\tif (otg_int_src & OTGSC_DPIS) {\n\t\t\thw_write_otgsc(ci, OTGSC_DPIS, OTGSC_DPIS);\n\t\t\tfsm->a_srp_det = 1;\n\t\t\tfsm->a_bus_drop = 0;\n\t\t} else if (otg_int_src & OTGSC_IDIS) {\n\t\t\thw_write_otgsc(ci, OTGSC_IDIS, OTGSC_IDIS);\n\t\t\tif (fsm->id == 0) {\n\t\t\t\tfsm->a_bus_drop = 0;\n\t\t\t\tfsm->a_bus_req = 1;\n\t\t\t\tci->id_event = true;\n\t\t\t}\n\t\t} else if (otg_int_src & OTGSC_BSVIS) {\n\t\t\thw_write_otgsc(ci, OTGSC_BSVIS, OTGSC_BSVIS);\n\t\t\tif (otgsc & OTGSC_BSV) {\n\t\t\t\tfsm->b_sess_vld = 1;\n\t\t\t\tci_otg_del_timer(ci, B_SSEND_SRP);\n\t\t\t\tci_otg_del_timer(ci, B_SRP_FAIL);\n\t\t\t\tfsm->b_ssend_srp = 0;\n\t\t\t} else {\n\t\t\t\tfsm->b_sess_vld = 0;\n\t\t\t\tif (fsm->id)\n\t\t\t\t\tci_otg_add_timer(ci, B_SSEND_SRP);\n\t\t\t}\n\t\t} else if (otg_int_src & OTGSC_AVVIS) {\n\t\t\thw_write_otgsc(ci, OTGSC_AVVIS, OTGSC_AVVIS);\n\t\t\tif (otgsc & OTGSC_AVV) {\n\t\t\t\tfsm->a_vbus_vld = 1;\n\t\t\t} else {\n\t\t\t\tfsm->a_vbus_vld = 0;\n\t\t\t\tfsm->b_conn = 0;\n\t\t\t}\n\t\t}\n\t\tci_otg_queue_work(ci);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tci_otg_fsm_event(ci);\n\n\treturn retval;\n}\n\nvoid ci_hdrc_otg_fsm_start(struct ci_hdrc *ci)\n{\n\tci_otg_queue_work(ci);\n}\n\nint ci_hdrc_otg_fsm_init(struct ci_hdrc *ci)\n{\n\tint retval = 0;\n\n\tif (ci->phy)\n\t\tci->otg.phy = ci->phy;\n\telse\n\t\tci->otg.usb_phy = ci->usb_phy;\n\n\tci->otg.gadget = &ci->gadget;\n\tci->fsm.otg = &ci->otg;\n\tci->fsm.power_up = 1;\n\tci->fsm.id = hw_read_otgsc(ci, OTGSC_ID) ? 1 : 0;\n\tci->fsm.otg->state = OTG_STATE_UNDEFINED;\n\tci->fsm.ops = &ci_otg_ops;\n\tci->gadget.hnp_polling_support = 1;\n\tci->fsm.host_req_flag = devm_kzalloc(ci->dev, 1, GFP_KERNEL);\n\tif (!ci->fsm.host_req_flag)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&ci->fsm.lock);\n\n\tretval = ci_otg_init_timers(ci);\n\tif (retval) {\n\t\tdev_err(ci->dev, \"Couldn't init OTG timers\\n\");\n\t\treturn retval;\n\t}\n\tci->enabled_otg_timer_bits = 0;\n\tci->next_otg_timer = NUM_OTG_FSM_TIMERS;\n\n\tretval = sysfs_create_group(&ci->dev->kobj, &inputs_attr_group);\n\tif (retval < 0) {\n\t\tdev_dbg(ci->dev,\n\t\t\t\"Can't register sysfs attr group: %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t \n\thw_write_otgsc(ci, OTGSC_AVVIE, OTGSC_AVVIE);\n\n\tif (ci->fsm.id) {\n\t\tci->fsm.b_ssend_srp =\n\t\t\thw_read_otgsc(ci, OTGSC_BSV) ? 0 : 1;\n\t\tci->fsm.b_sess_vld =\n\t\t\thw_read_otgsc(ci, OTGSC_BSV) ? 1 : 0;\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_BSVIE, OTGSC_BSVIE);\n\t}\n\n\treturn 0;\n}\n\nvoid ci_hdrc_otg_fsm_remove(struct ci_hdrc *ci)\n{\n\tsysfs_remove_group(&ci->dev->kobj, &inputs_attr_group);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}