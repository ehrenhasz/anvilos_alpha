{
  "module_name": "ci_hdrc_imx.c",
  "hash_id": "2d18691c8a0ace0d7fb9fa260afb0ab5c8c6fd4c736d6c14c8cf96a93c6df77a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci_hdrc_imx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/usb/chipidea.h>\n#include <linux/usb/of.h>\n#include <linux/clk.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/pm_qos.h>\n\n#include \"ci.h\"\n#include \"ci_hdrc_imx.h\"\n\nstruct ci_hdrc_imx_platform_flag {\n\tunsigned int flags;\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx23_usb_data = {\n\t.flags = CI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx27_usb_data = {\n\t.flags = CI_HDRC_DISABLE_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx28_usb_data = {\n\t.flags = CI_HDRC_IMX28_WRITE_FIX |\n\t\tCI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx6q_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx6sl_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_HOST_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx6sx_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_HOST_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx6ul_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_TURN_VBUS_EARLY_ON |\n\t\tCI_HDRC_DISABLE_DEVICE_STREAMING,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx7d_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx7ulp_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_HAS_PORTSC_PEC_MISSED |\n\t\tCI_HDRC_PMQOS,\n};\n\nstatic const struct ci_hdrc_imx_platform_flag imx8ulp_usb_data = {\n\t.flags = CI_HDRC_SUPPORTS_RUNTIME_PM |\n\t\tCI_HDRC_HAS_PORTSC_PEC_MISSED,\n};\n\nstatic const struct of_device_id ci_hdrc_imx_dt_ids[] = {\n\t{ .compatible = \"fsl,imx23-usb\", .data = &imx23_usb_data},\n\t{ .compatible = \"fsl,imx28-usb\", .data = &imx28_usb_data},\n\t{ .compatible = \"fsl,imx27-usb\", .data = &imx27_usb_data},\n\t{ .compatible = \"fsl,imx6q-usb\", .data = &imx6q_usb_data},\n\t{ .compatible = \"fsl,imx6sl-usb\", .data = &imx6sl_usb_data},\n\t{ .compatible = \"fsl,imx6sx-usb\", .data = &imx6sx_usb_data},\n\t{ .compatible = \"fsl,imx6ul-usb\", .data = &imx6ul_usb_data},\n\t{ .compatible = \"fsl,imx7d-usb\", .data = &imx7d_usb_data},\n\t{ .compatible = \"fsl,imx7ulp-usb\", .data = &imx7ulp_usb_data},\n\t{ .compatible = \"fsl,imx8ulp-usb\", .data = &imx8ulp_usb_data},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, ci_hdrc_imx_dt_ids);\n\nstruct ci_hdrc_imx_data {\n\tstruct usb_phy *phy;\n\tstruct platform_device *ci_pdev;\n\tstruct clk *clk;\n\tstruct imx_usbmisc_data *usbmisc_data;\n\tbool supports_runtime_pm;\n\tbool override_phy_control;\n\tbool in_lpm;\n\tstruct pinctrl *pinctrl;\n\tstruct pinctrl_state *pinctrl_hsic_active;\n\tstruct regulator *hsic_pad_regulator;\n\t \n\tbool need_three_clks;\n\tstruct clk *clk_ipg;\n\tstruct clk *clk_ahb;\n\tstruct clk *clk_per;\n\t \n\tstruct pm_qos_request pm_qos_req;\n\tconst struct ci_hdrc_imx_platform_flag *plat_data;\n};\n\n \n\nstatic struct imx_usbmisc_data *usbmisc_get_init_data(struct device *dev)\n{\n\tstruct platform_device *misc_pdev;\n\tstruct device_node *np = dev->of_node;\n\tstruct of_phandle_args args;\n\tstruct imx_usbmisc_data *data;\n\tint ret;\n\n\t \n\tif (!of_get_property(np, \"fsl,usbmisc\", NULL))\n\t\treturn NULL;\n\n\tdata = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = of_parse_phandle_with_args(np, \"fsl,usbmisc\", \"#index-cells\",\n\t\t\t\t\t0, &args);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to parse property fsl,usbmisc, errno %d\\n\",\n\t\t\tret);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdata->index = args.args[0];\n\n\tmisc_pdev = of_find_device_by_node(args.np);\n\tof_node_put(args.np);\n\n\tif (!misc_pdev)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\tif (!platform_get_drvdata(misc_pdev)) {\n\t\tput_device(&misc_pdev->dev);\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\t}\n\tdata->dev = &misc_pdev->dev;\n\n\t \n\tif (of_property_read_bool(np, \"disable-over-current\")) {\n\t\tdata->disable_oc = 1;\n\t} else if (of_property_read_bool(np, \"over-current-active-high\")) {\n\t\tdata->oc_pol_active_low = 0;\n\t\tdata->oc_pol_configured = 1;\n\t} else if (of_property_read_bool(np, \"over-current-active-low\")) {\n\t\tdata->oc_pol_active_low = 1;\n\t\tdata->oc_pol_configured = 1;\n\t} else {\n\t\tdev_warn(dev, \"No over current polarity defined\\n\");\n\t}\n\n\tdata->pwr_pol = of_property_read_bool(np, \"power-active-high\");\n\tdata->evdo = of_property_read_bool(np, \"external-vbus-divider\");\n\n\tif (of_usb_get_phy_mode(np) == USBPHY_INTERFACE_MODE_ULPI)\n\t\tdata->ulpi = 1;\n\n\tif (of_property_read_u32(np, \"samsung,picophy-pre-emp-curr-control\",\n\t\t\t&data->emp_curr_control))\n\t\tdata->emp_curr_control = -1;\n\tif (of_property_read_u32(np, \"samsung,picophy-dc-vol-level-adjust\",\n\t\t\t&data->dc_vol_level_adjust))\n\t\tdata->dc_vol_level_adjust = -1;\n\tif (of_property_read_u32(np, \"fsl,picophy-rise-fall-time-adjust\",\n\t\t\t&data->rise_fall_time_adjust))\n\t\tdata->rise_fall_time_adjust = -1;\n\n\treturn data;\n}\n\n \nstatic int imx_get_clks(struct device *dev)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdata->clk_ipg = devm_clk_get(dev, \"ipg\");\n\tif (IS_ERR(data->clk_ipg)) {\n\t\t \n\t\tdata->clk = devm_clk_get(dev, NULL);\n\t\tif (IS_ERR(data->clk)) {\n\t\t\tret = PTR_ERR(data->clk);\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to get clks, err=%ld,%ld\\n\",\n\t\t\t\tPTR_ERR(data->clk), PTR_ERR(data->clk_ipg));\n\t\t\treturn ret;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tdata->clk_ahb = devm_clk_get(dev, \"ahb\");\n\tif (IS_ERR(data->clk_ahb)) {\n\t\tret = PTR_ERR(data->clk_ahb);\n\t\tdev_err(dev,\n\t\t\t\"Failed to get ahb clock, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->clk_per = devm_clk_get(dev, \"per\");\n\tif (IS_ERR(data->clk_per)) {\n\t\tret = PTR_ERR(data->clk_per);\n\t\tdev_err(dev,\n\t\t\t\"Failed to get per clock, err=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tdata->need_three_clks = true;\n\treturn ret;\n}\n\nstatic int imx_prepare_enable_clks(struct device *dev)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tif (data->need_three_clks) {\n\t\tret = clk_prepare_enable(data->clk_ipg);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to prepare/enable ipg clk, err=%d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(data->clk_ahb);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to prepare/enable ahb clk, err=%d\\n\",\n\t\t\t\tret);\n\t\t\tclk_disable_unprepare(data->clk_ipg);\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = clk_prepare_enable(data->clk_per);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to prepare/enable per clk, err=%d\\n\",\n\t\t\t\tret);\n\t\t\tclk_disable_unprepare(data->clk_ahb);\n\t\t\tclk_disable_unprepare(data->clk_ipg);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = clk_prepare_enable(data->clk);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to prepare/enable clk, err=%d\\n\",\n\t\t\t\tret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void imx_disable_unprepare_clks(struct device *dev)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\n\tif (data->need_three_clks) {\n\t\tclk_disable_unprepare(data->clk_per);\n\t\tclk_disable_unprepare(data->clk_ahb);\n\t\tclk_disable_unprepare(data->clk_ipg);\n\t} else {\n\t\tclk_disable_unprepare(data->clk);\n\t}\n}\n\nstatic int ci_hdrc_imx_notify_event(struct ci_hdrc *ci, unsigned int event)\n{\n\tstruct device *dev = ci->dev->parent;\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\tstruct imx_usbmisc_data *mdata = data->usbmisc_data;\n\n\tswitch (event) {\n\tcase CI_HDRC_IMX_HSIC_ACTIVE_EVENT:\n\t\tif (data->pinctrl) {\n\t\t\tret = pinctrl_select_state(data->pinctrl,\n\t\t\t\t\tdata->pinctrl_hsic_active);\n\t\t\tif (ret)\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"hsic_active select failed, err=%d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t\tbreak;\n\tcase CI_HDRC_IMX_HSIC_SUSPEND_EVENT:\n\t\tret = imx_usbmisc_hsic_set_connect(mdata);\n\t\tif (ret)\n\t\t\tdev_err(dev,\n\t\t\t\t\"hsic_set_connect failed, err=%d\\n\", ret);\n\t\tbreak;\n\tcase CI_HDRC_CONTROLLER_VBUS_EVENT:\n\t\tif (ci->vbus_active)\n\t\t\tret = imx_usbmisc_charger_detection(mdata, true);\n\t\telse\n\t\t\tret = imx_usbmisc_charger_detection(mdata, false);\n\t\tif (ci->usb_phy)\n\t\t\tschedule_work(&ci->usb_phy->chg_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int ci_hdrc_imx_probe(struct platform_device *pdev)\n{\n\tstruct ci_hdrc_imx_data *data;\n\tstruct ci_hdrc_platform_data pdata = {\n\t\t.name\t\t= dev_name(&pdev->dev),\n\t\t.capoffset\t= DEF_CAPOFFSET,\n\t\t.notify_event\t= ci_hdrc_imx_notify_event,\n\t};\n\tint ret;\n\tconst struct ci_hdrc_imx_platform_flag *imx_platform_flag;\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\n\timx_platform_flag = of_device_get_match_data(&pdev->dev);\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->plat_data = imx_platform_flag;\n\tpdata.flags |= imx_platform_flag->flags;\n\tplatform_set_drvdata(pdev, data);\n\tdata->usbmisc_data = usbmisc_get_init_data(dev);\n\tif (IS_ERR(data->usbmisc_data))\n\t\treturn PTR_ERR(data->usbmisc_data);\n\n\tif ((of_usb_get_phy_mode(dev->of_node) == USBPHY_INTERFACE_MODE_HSIC)\n\t\t&& data->usbmisc_data) {\n\t\tpdata.flags |= CI_HDRC_IMX_IS_HSIC;\n\t\tdata->usbmisc_data->hsic = 1;\n\t\tdata->pinctrl = devm_pinctrl_get(dev);\n\t\tif (PTR_ERR(data->pinctrl) == -ENODEV)\n\t\t\tdata->pinctrl = NULL;\n\t\telse if (IS_ERR(data->pinctrl))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(data->pinctrl),\n\t\t\t\t\t     \"pinctrl get failed\\n\");\n\n\t\tdata->hsic_pad_regulator =\n\t\t\t\tdevm_regulator_get_optional(dev, \"hsic\");\n\t\tif (PTR_ERR(data->hsic_pad_regulator) == -ENODEV) {\n\t\t\t \n\t\t\tdata->hsic_pad_regulator = NULL;\n\t\t} else if (IS_ERR(data->hsic_pad_regulator))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(data->hsic_pad_regulator),\n\t\t\t\t\t     \"Get HSIC pad regulator error\\n\");\n\n\t\tif (data->hsic_pad_regulator) {\n\t\t\tret = regulator_enable(data->hsic_pad_regulator);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"Failed to enable HSIC pad regulator\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (data->pinctrl) {\n\t\tstruct pinctrl_state *pinctrl_hsic_idle;\n\n\t\tpinctrl_hsic_idle = pinctrl_lookup_state(data->pinctrl, \"idle\");\n\t\tif (IS_ERR(pinctrl_hsic_idle)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"pinctrl_hsic_idle lookup failed, err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(pinctrl_hsic_idle));\n\t\t\treturn PTR_ERR(pinctrl_hsic_idle);\n\t\t}\n\n\t\tret = pinctrl_select_state(data->pinctrl, pinctrl_hsic_idle);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"hsic_idle select failed, err=%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tdata->pinctrl_hsic_active = pinctrl_lookup_state(data->pinctrl,\n\t\t\t\t\t\t\t\t\"active\");\n\t\tif (IS_ERR(data->pinctrl_hsic_active)) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"pinctrl_hsic_active lookup failed, err=%ld\\n\",\n\t\t\t\t\tPTR_ERR(data->pinctrl_hsic_active));\n\t\t\treturn PTR_ERR(data->pinctrl_hsic_active);\n\t\t}\n\t}\n\n\tif (pdata.flags & CI_HDRC_PMQOS)\n\t\tcpu_latency_qos_add_request(&data->pm_qos_req, 0);\n\n\tret = imx_get_clks(dev);\n\tif (ret)\n\t\tgoto disable_hsic_regulator;\n\n\tret = imx_prepare_enable_clks(dev);\n\tif (ret)\n\t\tgoto disable_hsic_regulator;\n\n\tdata->phy = devm_usb_get_phy_by_phandle(dev, \"fsl,usbphy\", 0);\n\tif (IS_ERR(data->phy)) {\n\t\tret = PTR_ERR(data->phy);\n\t\tif (ret != -ENODEV) {\n\t\t\tdev_err_probe(dev, ret, \"Failed to parse fsl,usbphy\\n\");\n\t\t\tgoto err_clk;\n\t\t}\n\t\tdata->phy = devm_usb_get_phy_by_phandle(dev, \"phys\", 0);\n\t\tif (IS_ERR(data->phy)) {\n\t\t\tret = PTR_ERR(data->phy);\n\t\t\tif (ret == -ENODEV) {\n\t\t\t\tdata->phy = NULL;\n\t\t\t} else {\n\t\t\t\tdev_err_probe(dev, ret, \"Failed to parse phys\\n\");\n\t\t\t\tgoto err_clk;\n\t\t\t}\n\t\t}\n\t}\n\n\tpdata.usb_phy = data->phy;\n\tif (data->usbmisc_data)\n\t\tdata->usbmisc_data->usb_phy = data->phy;\n\n\tif ((of_device_is_compatible(np, \"fsl,imx53-usb\") ||\n\t     of_device_is_compatible(np, \"fsl,imx51-usb\")) && pdata.usb_phy &&\n\t    of_usb_get_phy_mode(np) == USBPHY_INTERFACE_MODE_ULPI) {\n\t\tpdata.flags |= CI_HDRC_OVERRIDE_PHY_CONTROL;\n\t\tdata->override_phy_control = true;\n\t\tusb_phy_init(pdata.usb_phy);\n\t}\n\n\tif (pdata.flags & CI_HDRC_SUPPORTS_RUNTIME_PM)\n\t\tdata->supports_runtime_pm = true;\n\n\tret = imx_usbmisc_init(data->usbmisc_data);\n\tif (ret) {\n\t\tdev_err(dev, \"usbmisc init failed, ret=%d\\n\", ret);\n\t\tgoto err_clk;\n\t}\n\n\tdata->ci_pdev = ci_hdrc_add_device(dev,\n\t\t\t\tpdev->resource, pdev->num_resources,\n\t\t\t\t&pdata);\n\tif (IS_ERR(data->ci_pdev)) {\n\t\tret = PTR_ERR(data->ci_pdev);\n\t\tdev_err_probe(dev, ret, \"ci_hdrc_add_device failed\\n\");\n\t\tgoto err_clk;\n\t}\n\n\tif (data->usbmisc_data) {\n\t\tif (!IS_ERR(pdata.id_extcon.edev) ||\n\t\t    of_property_read_bool(np, \"usb-role-switch\"))\n\t\t\tdata->usbmisc_data->ext_id = 1;\n\n\t\tif (!IS_ERR(pdata.vbus_extcon.edev) ||\n\t\t    of_property_read_bool(np, \"usb-role-switch\"))\n\t\t\tdata->usbmisc_data->ext_vbus = 1;\n\n\t\t \n\t\tdata->usbmisc_data->available_role =\n\t\t\tci_hdrc_query_available_role(data->ci_pdev);\n\t}\n\n\tret = imx_usbmisc_init_post(data->usbmisc_data);\n\tif (ret) {\n\t\tdev_err(dev, \"usbmisc post failed, ret=%d\\n\", ret);\n\t\tgoto disable_device;\n\t}\n\n\tif (data->supports_runtime_pm) {\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\tdevice_set_wakeup_capable(dev, true);\n\n\treturn 0;\n\ndisable_device:\n\tci_hdrc_remove_device(data->ci_pdev);\nerr_clk:\n\timx_disable_unprepare_clks(dev);\ndisable_hsic_regulator:\n\tif (data->hsic_pad_regulator)\n\t\t \n\t\tregulator_disable(data->hsic_pad_regulator);\n\tif (pdata.flags & CI_HDRC_PMQOS)\n\t\tcpu_latency_qos_remove_request(&data->pm_qos_req);\n\tdata->ci_pdev = NULL;\n\treturn ret;\n}\n\nstatic void ci_hdrc_imx_remove(struct platform_device *pdev)\n{\n\tstruct ci_hdrc_imx_data *data = platform_get_drvdata(pdev);\n\n\tif (data->supports_runtime_pm) {\n\t\tpm_runtime_get_sync(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t}\n\tif (data->ci_pdev)\n\t\tci_hdrc_remove_device(data->ci_pdev);\n\tif (data->override_phy_control)\n\t\tusb_phy_shutdown(data->phy);\n\tif (data->ci_pdev) {\n\t\timx_disable_unprepare_clks(&pdev->dev);\n\t\tif (data->plat_data->flags & CI_HDRC_PMQOS)\n\t\t\tcpu_latency_qos_remove_request(&data->pm_qos_req);\n\t\tif (data->hsic_pad_regulator)\n\t\t\tregulator_disable(data->hsic_pad_regulator);\n\t}\n}\n\nstatic void ci_hdrc_imx_shutdown(struct platform_device *pdev)\n{\n\tci_hdrc_imx_remove(pdev);\n}\n\nstatic int __maybe_unused imx_controller_suspend(struct device *dev,\n\t\t\t\t\t\t pm_message_t msg)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdev_dbg(dev, \"at %s\\n\", __func__);\n\n\tret = imx_usbmisc_suspend(data->usbmisc_data,\n\t\t\t\t  PMSG_IS_AUTO(msg) || device_may_wakeup(dev));\n\tif (ret) {\n\t\tdev_err(dev,\n\t\t\t\"usbmisc suspend failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\timx_disable_unprepare_clks(dev);\n\tif (data->plat_data->flags & CI_HDRC_PMQOS)\n\t\tcpu_latency_qos_remove_request(&data->pm_qos_req);\n\n\tdata->in_lpm = true;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused imx_controller_resume(struct device *dev,\n\t\t\t\t\t\tpm_message_t msg)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdev_dbg(dev, \"at %s\\n\", __func__);\n\n\tif (!data->in_lpm) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (data->plat_data->flags & CI_HDRC_PMQOS)\n\t\tcpu_latency_qos_add_request(&data->pm_qos_req, 0);\n\n\tret = imx_prepare_enable_clks(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->in_lpm = false;\n\n\tret = imx_usbmisc_resume(data->usbmisc_data,\n\t\t\t\t PMSG_IS_AUTO(msg) || device_may_wakeup(dev));\n\tif (ret) {\n\t\tdev_err(dev, \"usbmisc resume failed, ret=%d\\n\", ret);\n\t\tgoto clk_disable;\n\t}\n\n\treturn 0;\n\nclk_disable:\n\timx_disable_unprepare_clks(dev);\n\treturn ret;\n}\n\nstatic int __maybe_unused ci_hdrc_imx_suspend(struct device *dev)\n{\n\tint ret;\n\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\n\tif (data->in_lpm)\n\t\t \n\t\treturn 0;\n\n\tret = imx_controller_suspend(dev, PMSG_SUSPEND);\n\tif (ret)\n\t\treturn ret;\n\n\tpinctrl_pm_select_sleep_state(dev);\n\treturn ret;\n}\n\nstatic int __maybe_unused ci_hdrc_imx_resume(struct device *dev)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\tint ret;\n\n\tpinctrl_pm_select_default_state(dev);\n\tret = imx_controller_resume(dev, PMSG_RESUME);\n\tif (!ret && data->supports_runtime_pm) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused ci_hdrc_imx_runtime_suspend(struct device *dev)\n{\n\tstruct ci_hdrc_imx_data *data = dev_get_drvdata(dev);\n\n\tif (data->in_lpm) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\treturn imx_controller_suspend(dev, PMSG_AUTO_SUSPEND);\n}\n\nstatic int __maybe_unused ci_hdrc_imx_runtime_resume(struct device *dev)\n{\n\treturn imx_controller_resume(dev, PMSG_AUTO_RESUME);\n}\n\nstatic const struct dev_pm_ops ci_hdrc_imx_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ci_hdrc_imx_suspend, ci_hdrc_imx_resume)\n\tSET_RUNTIME_PM_OPS(ci_hdrc_imx_runtime_suspend,\n\t\t\tci_hdrc_imx_runtime_resume, NULL)\n};\nstatic struct platform_driver ci_hdrc_imx_driver = {\n\t.probe = ci_hdrc_imx_probe,\n\t.remove_new = ci_hdrc_imx_remove,\n\t.shutdown = ci_hdrc_imx_shutdown,\n\t.driver = {\n\t\t.name = \"imx_usb\",\n\t\t.of_match_table = ci_hdrc_imx_dt_ids,\n\t\t.pm = &ci_hdrc_imx_pm_ops,\n\t },\n};\n\nmodule_platform_driver(ci_hdrc_imx_driver);\n\nMODULE_ALIAS(\"platform:imx-usb\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"CI HDRC i.MX USB binding\");\nMODULE_AUTHOR(\"Marek Vasut <marex@denx.de>\");\nMODULE_AUTHOR(\"Richard Zhao <richard.zhao@freescale.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}