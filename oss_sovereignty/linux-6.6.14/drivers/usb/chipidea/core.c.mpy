{
  "module_name": "core.c",
  "hash_id": "bc5538643ea2648c2f1944a60f43bc511798748713ffc49a183b3b196d37c245",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/core.c",
  "human_readable_source": "\n \n#include <linux/delay.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/extcon.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/idr.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/pm_runtime.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/chipidea.h>\n#include <linux/usb/of.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/ehci_def.h>\n\n#include \"ci.h\"\n#include \"udc.h\"\n#include \"bits.h\"\n#include \"host.h\"\n#include \"otg.h\"\n#include \"otg_fsm.h\"\n\n \nstatic const u8 ci_regs_nolpm[] = {\n\t[CAP_CAPLENGTH]\t\t= 0x00U,\n\t[CAP_HCCPARAMS]\t\t= 0x08U,\n\t[CAP_DCCPARAMS]\t\t= 0x24U,\n\t[CAP_TESTMODE]\t\t= 0x38U,\n\t[OP_USBCMD]\t\t= 0x00U,\n\t[OP_USBSTS]\t\t= 0x04U,\n\t[OP_USBINTR]\t\t= 0x08U,\n\t[OP_FRINDEX]\t\t= 0x0CU,\n\t[OP_DEVICEADDR]\t\t= 0x14U,\n\t[OP_ENDPTLISTADDR]\t= 0x18U,\n\t[OP_TTCTRL]\t\t= 0x1CU,\n\t[OP_BURSTSIZE]\t\t= 0x20U,\n\t[OP_ULPI_VIEWPORT]\t= 0x30U,\n\t[OP_PORTSC]\t\t= 0x44U,\n\t[OP_DEVLC]\t\t= 0x84U,\n\t[OP_OTGSC]\t\t= 0x64U,\n\t[OP_USBMODE]\t\t= 0x68U,\n\t[OP_ENDPTSETUPSTAT]\t= 0x6CU,\n\t[OP_ENDPTPRIME]\t\t= 0x70U,\n\t[OP_ENDPTFLUSH]\t\t= 0x74U,\n\t[OP_ENDPTSTAT]\t\t= 0x78U,\n\t[OP_ENDPTCOMPLETE]\t= 0x7CU,\n\t[OP_ENDPTCTRL]\t\t= 0x80U,\n};\n\nstatic const u8 ci_regs_lpm[] = {\n\t[CAP_CAPLENGTH]\t\t= 0x00U,\n\t[CAP_HCCPARAMS]\t\t= 0x08U,\n\t[CAP_DCCPARAMS]\t\t= 0x24U,\n\t[CAP_TESTMODE]\t\t= 0xFCU,\n\t[OP_USBCMD]\t\t= 0x00U,\n\t[OP_USBSTS]\t\t= 0x04U,\n\t[OP_USBINTR]\t\t= 0x08U,\n\t[OP_FRINDEX]\t\t= 0x0CU,\n\t[OP_DEVICEADDR]\t\t= 0x14U,\n\t[OP_ENDPTLISTADDR]\t= 0x18U,\n\t[OP_TTCTRL]\t\t= 0x1CU,\n\t[OP_BURSTSIZE]\t\t= 0x20U,\n\t[OP_ULPI_VIEWPORT]\t= 0x30U,\n\t[OP_PORTSC]\t\t= 0x44U,\n\t[OP_DEVLC]\t\t= 0x84U,\n\t[OP_OTGSC]\t\t= 0xC4U,\n\t[OP_USBMODE]\t\t= 0xC8U,\n\t[OP_ENDPTSETUPSTAT]\t= 0xD8U,\n\t[OP_ENDPTPRIME]\t\t= 0xDCU,\n\t[OP_ENDPTFLUSH]\t\t= 0xE0U,\n\t[OP_ENDPTSTAT]\t\t= 0xE4U,\n\t[OP_ENDPTCOMPLETE]\t= 0xE8U,\n\t[OP_ENDPTCTRL]\t\t= 0xECU,\n};\n\nstatic void hw_alloc_regmap(struct ci_hdrc *ci, bool is_lpm)\n{\n\tint i;\n\n\tfor (i = 0; i < OP_ENDPTCTRL; i++)\n\t\tci->hw_bank.regmap[i] =\n\t\t\t(i <= CAP_LAST ? ci->hw_bank.cap : ci->hw_bank.op) +\n\t\t\t(is_lpm ? ci_regs_lpm[i] : ci_regs_nolpm[i]);\n\n\tfor (; i <= OP_LAST; i++)\n\t\tci->hw_bank.regmap[i] = ci->hw_bank.op +\n\t\t\t4 * (i - OP_ENDPTCTRL) +\n\t\t\t(is_lpm\n\t\t\t ? ci_regs_lpm[OP_ENDPTCTRL]\n\t\t\t : ci_regs_nolpm[OP_ENDPTCTRL]);\n\n}\n\nstatic enum ci_revision ci_get_revision(struct ci_hdrc *ci)\n{\n\tint ver = hw_read_id_reg(ci, ID_ID, VERSION) >> __ffs(VERSION);\n\tenum ci_revision rev = CI_REVISION_UNKNOWN;\n\n\tif (ver == 0x2) {\n\t\trev = hw_read_id_reg(ci, ID_ID, REVISION)\n\t\t\t>> __ffs(REVISION);\n\t\trev += CI_REVISION_20;\n\t} else if (ver == 0x0) {\n\t\trev = CI_REVISION_1X;\n\t}\n\n\treturn rev;\n}\n\n \nu32 hw_read_intr_enable(struct ci_hdrc *ci)\n{\n\treturn hw_read(ci, OP_USBINTR, ~0);\n}\n\n \nu32 hw_read_intr_status(struct ci_hdrc *ci)\n{\n\treturn hw_read(ci, OP_USBSTS, ~0);\n}\n\n \nint hw_port_test_set(struct ci_hdrc *ci, u8 mode)\n{\n\tconst u8 TEST_MODE_MAX = 7;\n\n\tif (mode > TEST_MODE_MAX)\n\t\treturn -EINVAL;\n\n\thw_write(ci, OP_PORTSC, PORTSC_PTC, mode << __ffs(PORTSC_PTC));\n\treturn 0;\n}\n\n \nu8 hw_port_test_get(struct ci_hdrc *ci)\n{\n\treturn hw_read(ci, OP_PORTSC, PORTSC_PTC) >> __ffs(PORTSC_PTC);\n}\n\nstatic void hw_wait_phy_stable(void)\n{\n\t \n\tusleep_range(2000, 2500);\n}\n\n \nstatic void ci_hdrc_enter_lpm_common(struct ci_hdrc *ci, bool enable)\n{\n\tenum ci_hw_regs reg = ci->hw_bank.lpm ? OP_DEVLC : OP_PORTSC;\n\tbool lpm = !!(hw_read(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm)));\n\n\tif (enable && !lpm)\n\t\thw_write(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm),\n\t\t\t\tPORTSC_PHCD(ci->hw_bank.lpm));\n\telse if (!enable && lpm)\n\t\thw_write(ci, reg, PORTSC_PHCD(ci->hw_bank.lpm),\n\t\t\t\t0);\n}\n\nstatic void ci_hdrc_enter_lpm(struct ci_hdrc *ci, bool enable)\n{\n\treturn ci->platdata->enter_lpm(ci, enable);\n}\n\nstatic int hw_device_init(struct ci_hdrc *ci, void __iomem *base)\n{\n\tu32 reg;\n\n\t \n\tci->hw_bank.abs = base;\n\n\tci->hw_bank.cap = ci->hw_bank.abs;\n\tci->hw_bank.cap += ci->platdata->capoffset;\n\tci->hw_bank.op = ci->hw_bank.cap + (ioread32(ci->hw_bank.cap) & 0xff);\n\n\thw_alloc_regmap(ci, false);\n\treg = hw_read(ci, CAP_HCCPARAMS, HCCPARAMS_LEN) >>\n\t\t__ffs(HCCPARAMS_LEN);\n\tci->hw_bank.lpm  = reg;\n\tif (reg)\n\t\thw_alloc_regmap(ci, !!reg);\n\tci->hw_bank.size = ci->hw_bank.op - ci->hw_bank.abs;\n\tci->hw_bank.size += OP_LAST;\n\tci->hw_bank.size /= sizeof(u32);\n\n\treg = hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_DEN) >>\n\t\t__ffs(DCCPARAMS_DEN);\n\tci->hw_ep_max = reg * 2;    \n\n\tif (ci->hw_ep_max > ENDPT_MAX)\n\t\treturn -ENODEV;\n\n\tci_hdrc_enter_lpm(ci, false);\n\n\t \n\thw_write(ci, OP_USBINTR, 0xffffffff, 0);\n\n\t \n\thw_write(ci, OP_USBSTS, 0xffffffff, 0xffffffff);\n\n\tci->rev = ci_get_revision(ci);\n\n\tdev_dbg(ci->dev,\n\t\t\"revision: %d, lpm: %d; cap: %px op: %px\\n\",\n\t\tci->rev, ci->hw_bank.lpm, ci->hw_bank.cap, ci->hw_bank.op);\n\n\t \n\n\t \n\n\t \n\n\treturn 0;\n}\n\nvoid hw_phymode_configure(struct ci_hdrc *ci)\n{\n\tu32 portsc, lpm, sts = 0;\n\n\tswitch (ci->platdata->phy_mode) {\n\tcase USBPHY_INTERFACE_MODE_UTMI:\n\t\tportsc = PORTSC_PTS(PTS_UTMI);\n\t\tlpm = DEVLC_PTS(PTS_UTMI);\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_UTMIW:\n\t\tportsc = PORTSC_PTS(PTS_UTMI) | PORTSC_PTW;\n\t\tlpm = DEVLC_PTS(PTS_UTMI) | DEVLC_PTW;\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_ULPI:\n\t\tportsc = PORTSC_PTS(PTS_ULPI);\n\t\tlpm = DEVLC_PTS(PTS_ULPI);\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_SERIAL:\n\t\tportsc = PORTSC_PTS(PTS_SERIAL);\n\t\tlpm = DEVLC_PTS(PTS_SERIAL);\n\t\tsts = 1;\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_HSIC:\n\t\tportsc = PORTSC_PTS(PTS_HSIC);\n\t\tlpm = DEVLC_PTS(PTS_HSIC);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tif (ci->hw_bank.lpm) {\n\t\thw_write(ci, OP_DEVLC, DEVLC_PTS(7) | DEVLC_PTW, lpm);\n\t\tif (sts)\n\t\t\thw_write(ci, OP_DEVLC, DEVLC_STS, DEVLC_STS);\n\t} else {\n\t\thw_write(ci, OP_PORTSC, PORTSC_PTS(7) | PORTSC_PTW, portsc);\n\t\tif (sts)\n\t\t\thw_write(ci, OP_PORTSC, PORTSC_STS, PORTSC_STS);\n\t}\n}\nEXPORT_SYMBOL_GPL(hw_phymode_configure);\n\n \nstatic int _ci_usb_phy_init(struct ci_hdrc *ci)\n{\n\tint ret;\n\n\tif (ci->phy) {\n\t\tret = phy_init(ci->phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_power_on(ci->phy);\n\t\tif (ret) {\n\t\t\tphy_exit(ci->phy);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = usb_phy_init(ci->usb_phy);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void ci_usb_phy_exit(struct ci_hdrc *ci)\n{\n\tif (ci->platdata->flags & CI_HDRC_OVERRIDE_PHY_CONTROL)\n\t\treturn;\n\n\tif (ci->phy) {\n\t\tphy_power_off(ci->phy);\n\t\tphy_exit(ci->phy);\n\t} else {\n\t\tusb_phy_shutdown(ci->usb_phy);\n\t}\n}\n\n \nstatic int ci_usb_phy_init(struct ci_hdrc *ci)\n{\n\tint ret;\n\n\tif (ci->platdata->flags & CI_HDRC_OVERRIDE_PHY_CONTROL)\n\t\treturn 0;\n\n\tswitch (ci->platdata->phy_mode) {\n\tcase USBPHY_INTERFACE_MODE_UTMI:\n\tcase USBPHY_INTERFACE_MODE_UTMIW:\n\tcase USBPHY_INTERFACE_MODE_HSIC:\n\t\tret = _ci_usb_phy_init(ci);\n\t\tif (!ret)\n\t\t\thw_wait_phy_stable();\n\t\telse\n\t\t\treturn ret;\n\t\thw_phymode_configure(ci);\n\t\tbreak;\n\tcase USBPHY_INTERFACE_MODE_ULPI:\n\tcase USBPHY_INTERFACE_MODE_SERIAL:\n\t\thw_phymode_configure(ci);\n\t\tret = _ci_usb_phy_init(ci);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tret = _ci_usb_phy_init(ci);\n\t\tif (!ret)\n\t\t\thw_wait_phy_stable();\n\t}\n\n\treturn ret;\n}\n\n\n \nvoid ci_platform_configure(struct ci_hdrc *ci)\n{\n\tbool is_device_mode, is_host_mode;\n\n\tis_device_mode = hw_read(ci, OP_USBMODE, USBMODE_CM) == USBMODE_CM_DC;\n\tis_host_mode = hw_read(ci, OP_USBMODE, USBMODE_CM) == USBMODE_CM_HC;\n\n\tif (is_device_mode) {\n\t\tphy_set_mode(ci->phy, PHY_MODE_USB_DEVICE);\n\n\t\tif (ci->platdata->flags & CI_HDRC_DISABLE_DEVICE_STREAMING)\n\t\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS,\n\t\t\t\t USBMODE_CI_SDIS);\n\t}\n\n\tif (is_host_mode) {\n\t\tphy_set_mode(ci->phy, PHY_MODE_USB_HOST);\n\n\t\tif (ci->platdata->flags & CI_HDRC_DISABLE_HOST_STREAMING)\n\t\t\thw_write(ci, OP_USBMODE, USBMODE_CI_SDIS,\n\t\t\t\t USBMODE_CI_SDIS);\n\t}\n\n\tif (ci->platdata->flags & CI_HDRC_FORCE_FULLSPEED) {\n\t\tif (ci->hw_bank.lpm)\n\t\t\thw_write(ci, OP_DEVLC, DEVLC_PFSC, DEVLC_PFSC);\n\t\telse\n\t\t\thw_write(ci, OP_PORTSC, PORTSC_PFSC, PORTSC_PFSC);\n\t}\n\n\tif (ci->platdata->flags & CI_HDRC_SET_NON_ZERO_TTHA)\n\t\thw_write(ci, OP_TTCTRL, TTCTRL_TTHA_MASK, TTCTRL_TTHA);\n\n\thw_write(ci, OP_USBCMD, 0xff0000, ci->platdata->itc_setting << 16);\n\n\tif (ci->platdata->flags & CI_HDRC_OVERRIDE_AHB_BURST)\n\t\thw_write_id_reg(ci, ID_SBUSCFG, AHBBRST_MASK,\n\t\t\tci->platdata->ahb_burst_config);\n\n\t \n\tif (!hw_read_id_reg(ci, ID_SBUSCFG, AHBBRST_MASK)) {\n\t\tif (ci->platdata->flags & CI_HDRC_OVERRIDE_TX_BURST)\n\t\t\thw_write(ci, OP_BURSTSIZE, TX_BURST_MASK,\n\t\t\tci->platdata->tx_burst_size << __ffs(TX_BURST_MASK));\n\n\t\tif (ci->platdata->flags & CI_HDRC_OVERRIDE_RX_BURST)\n\t\t\thw_write(ci, OP_BURSTSIZE, RX_BURST_MASK,\n\t\t\t\tci->platdata->rx_burst_size);\n\t}\n}\n\n \nstatic int hw_controller_reset(struct ci_hdrc *ci)\n{\n\tint count = 0;\n\n\thw_write(ci, OP_USBCMD, USBCMD_RST, USBCMD_RST);\n\twhile (hw_read(ci, OP_USBCMD, USBCMD_RST)) {\n\t\tudelay(10);\n\t\tif (count++ > 1000)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\n \nint hw_device_reset(struct ci_hdrc *ci)\n{\n\tint ret;\n\n\t \n\thw_write(ci, OP_ENDPTFLUSH, ~0, ~0);\n\thw_write(ci, OP_USBCMD, USBCMD_RS, 0);\n\n\tret = hw_controller_reset(ci);\n\tif (ret) {\n\t\tdev_err(ci->dev, \"error resetting controller, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (ci->platdata->notify_event) {\n\t\tret = ci->platdata->notify_event(ci,\n\t\t\tCI_HDRC_CONTROLLER_RESET_EVENT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t \n\thw_write(ci, OP_USBMODE, USBMODE_CM, USBMODE_CM_IDLE);\n\thw_write(ci, OP_USBMODE, USBMODE_CM, USBMODE_CM_DC);\n\t \n\thw_write(ci, OP_USBMODE, USBMODE_SLOM, USBMODE_SLOM);\n\n\tif (hw_read(ci, OP_USBMODE, USBMODE_CM) != USBMODE_CM_DC) {\n\t\tdev_err(ci->dev, \"cannot enter in %s device mode\\n\",\n\t\t\tci_role(ci)->name);\n\t\tdev_err(ci->dev, \"lpm = %i\\n\", ci->hw_bank.lpm);\n\t\treturn -ENODEV;\n\t}\n\n\tci_platform_configure(ci);\n\n\treturn 0;\n}\n\nstatic irqreturn_t ci_irq_handler(int irq, void *data)\n{\n\tstruct ci_hdrc *ci = data;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 otgsc = 0;\n\n\tif (ci->in_lpm) {\n\t\t \n\t\tif (ci->wakeup_int)\n\t\t\treturn IRQ_HANDLED;\n\n\t\tdisable_irq_nosync(irq);\n\t\tci->wakeup_int = true;\n\t\tpm_runtime_get(ci->dev);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tif (ci->is_otg) {\n\t\totgsc = hw_read_otgsc(ci, ~0);\n\t\tif (ci_otg_is_fsm_mode(ci)) {\n\t\t\tret = ci_otg_fsm_irq(ci);\n\t\t\tif (ret == IRQ_HANDLED)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tif (ci->is_otg && (otgsc & OTGSC_IDIE) && (otgsc & OTGSC_IDIS)) {\n\t\tci->id_event = true;\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_IDIS, OTGSC_IDIS);\n\t\tci_otg_queue_work(ci);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (ci->is_otg && (otgsc & OTGSC_BSVIE) && (otgsc & OTGSC_BSVIS)) {\n\t\tci->b_sess_valid_event = true;\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_BSVIS, OTGSC_BSVIS);\n\t\tci_otg_queue_work(ci);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tif (ci->role != CI_ROLE_END)\n\t\tret = ci_role(ci)->irq(ci);\n\n\treturn ret;\n}\n\nstatic void ci_irq(struct ci_hdrc *ci)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tci_irq_handler(ci->irq, ci);\n\tlocal_irq_restore(flags);\n}\n\nstatic int ci_cable_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t     void *ptr)\n{\n\tstruct ci_hdrc_cable *cbl = container_of(nb, struct ci_hdrc_cable, nb);\n\tstruct ci_hdrc *ci = cbl->ci;\n\n\tcbl->connected = event;\n\tcbl->changed = true;\n\n\tci_irq(ci);\n\treturn NOTIFY_DONE;\n}\n\nstatic enum usb_role ci_usb_role_switch_get(struct usb_role_switch *sw)\n{\n\tstruct ci_hdrc *ci = usb_role_switch_get_drvdata(sw);\n\tenum usb_role role;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\trole = ci_role_to_usb_role(ci);\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\treturn role;\n}\n\nstatic int ci_usb_role_switch_set(struct usb_role_switch *sw,\n\t\t\t\t  enum usb_role role)\n{\n\tstruct ci_hdrc *ci = usb_role_switch_get_drvdata(sw);\n\tstruct ci_hdrc_cable *cable;\n\n\tif (role == USB_ROLE_HOST) {\n\t\tcable = &ci->platdata->id_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = true;\n\t\tcable = &ci->platdata->vbus_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = false;\n\t} else if (role == USB_ROLE_DEVICE) {\n\t\tcable = &ci->platdata->id_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = false;\n\t\tcable = &ci->platdata->vbus_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = true;\n\t} else {\n\t\tcable = &ci->platdata->id_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = false;\n\t\tcable = &ci->platdata->vbus_extcon;\n\t\tcable->changed = true;\n\t\tcable->connected = false;\n\t}\n\n\tci_irq(ci);\n\treturn 0;\n}\n\nstatic enum ci_role ci_get_role(struct ci_hdrc *ci)\n{\n\tenum ci_role role;\n\n\tif (ci->roles[CI_ROLE_HOST] && ci->roles[CI_ROLE_GADGET]) {\n\t\tif (ci->is_otg) {\n\t\t\trole = ci_otg_role(ci);\n\t\t\thw_write_otgsc(ci, OTGSC_IDIE, OTGSC_IDIE);\n\t\t} else {\n\t\t\t \n\t\t\trole = CI_ROLE_GADGET;\n\t\t}\n\t} else {\n\t\trole = ci->roles[CI_ROLE_HOST] ? CI_ROLE_HOST\n\t\t\t\t\t: CI_ROLE_GADGET;\n\t}\n\n\treturn role;\n}\n\nstatic struct usb_role_switch_desc ci_role_switch = {\n\t.set = ci_usb_role_switch_set,\n\t.get = ci_usb_role_switch_get,\n\t.allow_userspace_control = true,\n};\n\nstatic int ci_get_platdata(struct device *dev,\n\t\tstruct ci_hdrc_platform_data *platdata)\n{\n\tstruct extcon_dev *ext_vbus, *ext_id;\n\tstruct ci_hdrc_cable *cable;\n\tint ret;\n\n\tif (!platdata->phy_mode)\n\t\tplatdata->phy_mode = of_usb_get_phy_mode(dev->of_node);\n\n\tif (!platdata->dr_mode)\n\t\tplatdata->dr_mode = usb_get_dr_mode(dev);\n\n\tif (platdata->dr_mode == USB_DR_MODE_UNKNOWN)\n\t\tplatdata->dr_mode = USB_DR_MODE_OTG;\n\n\tif (platdata->dr_mode != USB_DR_MODE_PERIPHERAL) {\n\t\t \n\t\tplatdata->reg_vbus = devm_regulator_get_optional(dev, \"vbus\");\n\t\tif (PTR_ERR(platdata->reg_vbus) == -EPROBE_DEFER) {\n\t\t\treturn -EPROBE_DEFER;\n\t\t} else if (PTR_ERR(platdata->reg_vbus) == -ENODEV) {\n\t\t\t \n\t\t\tplatdata->reg_vbus = NULL;\n\t\t} else if (IS_ERR(platdata->reg_vbus)) {\n\t\t\tdev_err(dev, \"Getting regulator error: %ld\\n\",\n\t\t\t\tPTR_ERR(platdata->reg_vbus));\n\t\t\treturn PTR_ERR(platdata->reg_vbus);\n\t\t}\n\t\t \n\t\tif (!platdata->tpl_support)\n\t\t\tplatdata->tpl_support =\n\t\t\t\tof_usb_host_tpl_support(dev->of_node);\n\t}\n\n\tif (platdata->dr_mode == USB_DR_MODE_OTG) {\n\t\t \n\t\tplatdata->ci_otg_caps.otg_rev = 0x0200;\n\t\tplatdata->ci_otg_caps.hnp_support = true;\n\t\tplatdata->ci_otg_caps.srp_support = true;\n\n\t\t \n\t\tret = of_usb_update_otg_caps(dev->of_node,\n\t\t\t\t\t&platdata->ci_otg_caps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (usb_get_maximum_speed(dev) == USB_SPEED_FULL)\n\t\tplatdata->flags |= CI_HDRC_FORCE_FULLSPEED;\n\n\tof_property_read_u32(dev->of_node, \"phy-clkgate-delay-us\",\n\t\t\t\t     &platdata->phy_clkgate_delay_us);\n\n\tplatdata->itc_setting = 1;\n\n\tof_property_read_u32(dev->of_node, \"itc-setting\",\n\t\t\t\t\t&platdata->itc_setting);\n\n\tret = of_property_read_u32(dev->of_node, \"ahb-burst-config\",\n\t\t\t\t&platdata->ahb_burst_config);\n\tif (!ret) {\n\t\tplatdata->flags |= CI_HDRC_OVERRIDE_AHB_BURST;\n\t} else if (ret != -EINVAL) {\n\t\tdev_err(dev, \"failed to get ahb-burst-config\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"tx-burst-size-dword\",\n\t\t\t\t&platdata->tx_burst_size);\n\tif (!ret) {\n\t\tplatdata->flags |= CI_HDRC_OVERRIDE_TX_BURST;\n\t} else if (ret != -EINVAL) {\n\t\tdev_err(dev, \"failed to get tx-burst-size-dword\\n\");\n\t\treturn ret;\n\t}\n\n\tret = of_property_read_u32(dev->of_node, \"rx-burst-size-dword\",\n\t\t\t\t&platdata->rx_burst_size);\n\tif (!ret) {\n\t\tplatdata->flags |= CI_HDRC_OVERRIDE_RX_BURST;\n\t} else if (ret != -EINVAL) {\n\t\tdev_err(dev, \"failed to get rx-burst-size-dword\\n\");\n\t\treturn ret;\n\t}\n\n\tif (of_property_read_bool(dev->of_node, \"non-zero-ttctrl-ttha\"))\n\t\tplatdata->flags |= CI_HDRC_SET_NON_ZERO_TTHA;\n\n\text_id = ERR_PTR(-ENODEV);\n\text_vbus = ERR_PTR(-ENODEV);\n\tif (of_property_read_bool(dev->of_node, \"extcon\")) {\n\t\t \n\t\text_vbus = extcon_get_edev_by_phandle(dev, 0);\n\t\tif (IS_ERR(ext_vbus) && PTR_ERR(ext_vbus) != -ENODEV)\n\t\t\treturn PTR_ERR(ext_vbus);\n\n\t\text_id = extcon_get_edev_by_phandle(dev, 1);\n\t\tif (IS_ERR(ext_id) && PTR_ERR(ext_id) != -ENODEV)\n\t\t\treturn PTR_ERR(ext_id);\n\t}\n\n\tcable = &platdata->vbus_extcon;\n\tcable->nb.notifier_call = ci_cable_notifier;\n\tcable->edev = ext_vbus;\n\n\tif (!IS_ERR(ext_vbus)) {\n\t\tret = extcon_get_state(cable->edev, EXTCON_USB);\n\t\tif (ret)\n\t\t\tcable->connected = true;\n\t\telse\n\t\t\tcable->connected = false;\n\t}\n\n\tcable = &platdata->id_extcon;\n\tcable->nb.notifier_call = ci_cable_notifier;\n\tcable->edev = ext_id;\n\n\tif (!IS_ERR(ext_id)) {\n\t\tret = extcon_get_state(cable->edev, EXTCON_USB_HOST);\n\t\tif (ret)\n\t\t\tcable->connected = true;\n\t\telse\n\t\t\tcable->connected = false;\n\t}\n\n\tif (device_property_read_bool(dev, \"usb-role-switch\"))\n\t\tci_role_switch.fwnode = dev->fwnode;\n\n\tplatdata->pctl = devm_pinctrl_get(dev);\n\tif (!IS_ERR(platdata->pctl)) {\n\t\tstruct pinctrl_state *p;\n\n\t\tp = pinctrl_lookup_state(platdata->pctl, \"default\");\n\t\tif (!IS_ERR(p))\n\t\t\tplatdata->pins_default = p;\n\n\t\tp = pinctrl_lookup_state(platdata->pctl, \"host\");\n\t\tif (!IS_ERR(p))\n\t\t\tplatdata->pins_host = p;\n\n\t\tp = pinctrl_lookup_state(platdata->pctl, \"device\");\n\t\tif (!IS_ERR(p))\n\t\t\tplatdata->pins_device = p;\n\t}\n\n\tif (!platdata->enter_lpm)\n\t\tplatdata->enter_lpm = ci_hdrc_enter_lpm_common;\n\n\treturn 0;\n}\n\nstatic int ci_extcon_register(struct ci_hdrc *ci)\n{\n\tstruct ci_hdrc_cable *id, *vbus;\n\tint ret;\n\n\tid = &ci->platdata->id_extcon;\n\tid->ci = ci;\n\tif (!IS_ERR_OR_NULL(id->edev)) {\n\t\tret = devm_extcon_register_notifier(ci->dev, id->edev,\n\t\t\t\t\t\tEXTCON_USB_HOST, &id->nb);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ci->dev, \"register ID failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tvbus = &ci->platdata->vbus_extcon;\n\tvbus->ci = ci;\n\tif (!IS_ERR_OR_NULL(vbus->edev)) {\n\t\tret = devm_extcon_register_notifier(ci->dev, vbus->edev,\n\t\t\t\t\t\tEXTCON_USB, &vbus->nb);\n\t\tif (ret < 0) {\n\t\t\tdev_err(ci->dev, \"register VBUS failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic DEFINE_IDA(ci_ida);\n\nstruct platform_device *ci_hdrc_add_device(struct device *dev,\n\t\t\tstruct resource *res, int nres,\n\t\t\tstruct ci_hdrc_platform_data *platdata)\n{\n\tstruct platform_device *pdev;\n\tint id, ret;\n\n\tret = ci_get_platdata(dev, platdata);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tid = ida_simple_get(&ci_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0)\n\t\treturn ERR_PTR(id);\n\n\tpdev = platform_device_alloc(\"ci_hdrc\", id);\n\tif (!pdev) {\n\t\tret = -ENOMEM;\n\t\tgoto put_id;\n\t}\n\n\tpdev->dev.parent = dev;\n\tdevice_set_of_node_from_dev(&pdev->dev, dev);\n\n\tret = platform_device_add_resources(pdev, res, nres);\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add_data(pdev, platdata, sizeof(*platdata));\n\tif (ret)\n\t\tgoto err;\n\n\tret = platform_device_add(pdev);\n\tif (ret)\n\t\tgoto err;\n\n\treturn pdev;\n\nerr:\n\tplatform_device_put(pdev);\nput_id:\n\tida_simple_remove(&ci_ida, id);\n\treturn ERR_PTR(ret);\n}\nEXPORT_SYMBOL_GPL(ci_hdrc_add_device);\n\nvoid ci_hdrc_remove_device(struct platform_device *pdev)\n{\n\tint id = pdev->id;\n\tplatform_device_unregister(pdev);\n\tida_simple_remove(&ci_ida, id);\n}\nEXPORT_SYMBOL_GPL(ci_hdrc_remove_device);\n\n \nenum usb_dr_mode ci_hdrc_query_available_role(struct platform_device *pdev)\n{\n\tstruct ci_hdrc *ci = platform_get_drvdata(pdev);\n\n\tif (!ci)\n\t\treturn USB_DR_MODE_UNKNOWN;\n\tif (ci->roles[CI_ROLE_HOST] && ci->roles[CI_ROLE_GADGET])\n\t\treturn USB_DR_MODE_OTG;\n\telse if (ci->roles[CI_ROLE_HOST])\n\t\treturn USB_DR_MODE_HOST;\n\telse if (ci->roles[CI_ROLE_GADGET])\n\t\treturn USB_DR_MODE_PERIPHERAL;\n\telse\n\t\treturn USB_DR_MODE_UNKNOWN;\n}\nEXPORT_SYMBOL_GPL(ci_hdrc_query_available_role);\n\nstatic inline void ci_role_destroy(struct ci_hdrc *ci)\n{\n\tci_hdrc_gadget_destroy(ci);\n\tci_hdrc_host_destroy(ci);\n\tif (ci->is_otg && ci->roles[CI_ROLE_GADGET])\n\t\tci_hdrc_otg_destroy(ci);\n}\n\nstatic void ci_get_otg_capable(struct ci_hdrc *ci)\n{\n\tif (ci->platdata->flags & CI_HDRC_DUAL_ROLE_NOT_OTG)\n\t\tci->is_otg = false;\n\telse\n\t\tci->is_otg = (hw_read(ci, CAP_DCCPARAMS,\n\t\t\t\tDCCPARAMS_DC | DCCPARAMS_HC)\n\t\t\t\t\t== (DCCPARAMS_DC | DCCPARAMS_HC));\n\tif (ci->is_otg) {\n\t\tdev_dbg(ci->dev, \"It is OTG capable controller\\n\");\n\t\t \n\t\thw_write_otgsc(ci, OTGSC_INT_EN_BITS | OTGSC_INT_STATUS_BITS,\n\t\t\t\t\t\t\tOTGSC_INT_STATUS_BITS);\n\t}\n}\n\nstatic ssize_t role_show(struct device *dev, struct device_attribute *attr,\n\t\t\t  char *buf)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\n\tif (ci->role != CI_ROLE_END)\n\t\treturn sprintf(buf, \"%s\\n\", ci_role(ci)->name);\n\n\treturn 0;\n}\n\nstatic ssize_t role_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t n)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tenum ci_role role;\n\tint ret;\n\n\tif (!(ci->roles[CI_ROLE_HOST] && ci->roles[CI_ROLE_GADGET])) {\n\t\tdev_warn(dev, \"Current configuration is not dual-role, quit\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tfor (role = CI_ROLE_HOST; role < CI_ROLE_END; role++)\n\t\tif (!strncmp(buf, ci->roles[role]->name,\n\t\t\t     strlen(ci->roles[role]->name)))\n\t\t\tbreak;\n\n\tif (role == CI_ROLE_END)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&ci->mutex);\n\n\tif (role == ci->role) {\n\t\tmutex_unlock(&ci->mutex);\n\t\treturn n;\n\t}\n\n\tpm_runtime_get_sync(dev);\n\tdisable_irq(ci->irq);\n\tci_role_stop(ci);\n\tret = ci_role_start(ci, role);\n\tif (!ret && ci->role == CI_ROLE_GADGET)\n\t\tci_handle_vbus_change(ci);\n\tenable_irq(ci->irq);\n\tpm_runtime_put_sync(dev);\n\tmutex_unlock(&ci->mutex);\n\n\treturn (ret == 0) ? n : ret;\n}\nstatic DEVICE_ATTR_RW(role);\n\nstatic struct attribute *ci_attrs[] = {\n\t&dev_attr_role.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ci);\n\nstatic int ci_hdrc_probe(struct platform_device *pdev)\n{\n\tstruct device\t*dev = &pdev->dev;\n\tstruct ci_hdrc\t*ci;\n\tstruct resource\t*res;\n\tvoid __iomem\t*base;\n\tint\t\tret;\n\tenum usb_dr_mode dr_mode;\n\n\tif (!dev_get_platdata(dev)) {\n\t\tdev_err(dev, \"platform data missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base))\n\t\treturn PTR_ERR(base);\n\n\tci = devm_kzalloc(dev, sizeof(*ci), GFP_KERNEL);\n\tif (!ci)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&ci->lock);\n\tmutex_init(&ci->mutex);\n\tci->dev = dev;\n\tci->platdata = dev_get_platdata(dev);\n\tci->imx28_write_fix = !!(ci->platdata->flags &\n\t\tCI_HDRC_IMX28_WRITE_FIX);\n\tci->supports_runtime_pm = !!(ci->platdata->flags &\n\t\tCI_HDRC_SUPPORTS_RUNTIME_PM);\n\tci->has_portsc_pec_bug = !!(ci->platdata->flags &\n\t\tCI_HDRC_HAS_PORTSC_PEC_MISSED);\n\tplatform_set_drvdata(pdev, ci);\n\n\tret = hw_device_init(ci, base);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't initialize hardware\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = ci_ulpi_init(ci);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ci->platdata->phy) {\n\t\tci->phy = ci->platdata->phy;\n\t} else if (ci->platdata->usb_phy) {\n\t\tci->usb_phy = ci->platdata->usb_phy;\n\t} else {\n\t\t \n\t\tci->phy = devm_phy_get(dev->parent, \"usb-phy\");\n\n\t\tif (PTR_ERR(ci->phy) == -EPROBE_DEFER) {\n\t\t\tret = -EPROBE_DEFER;\n\t\t\tgoto ulpi_exit;\n\t\t} else if (IS_ERR(ci->phy)) {\n\t\t\tci->phy = NULL;\n\t\t}\n\n\t\t \n\t\tif (!ci->phy) {\n\t\t\tci->usb_phy = devm_usb_get_phy_by_phandle(dev->parent,\n\t\t\t\t\t\t\t\t  \"phys\", 0);\n\n\t\t\tif (PTR_ERR(ci->usb_phy) == -EPROBE_DEFER) {\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\t\tgoto ulpi_exit;\n\t\t\t} else if (IS_ERR(ci->usb_phy)) {\n\t\t\t\tci->usb_phy = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ci->phy && !ci->usb_phy) {\n\t\t\tci->usb_phy = devm_usb_get_phy(dev->parent,\n\t\t\t\t\t\t       USB_PHY_TYPE_USB2);\n\n\t\t\tif (PTR_ERR(ci->usb_phy) == -EPROBE_DEFER) {\n\t\t\t\tret = -EPROBE_DEFER;\n\t\t\t\tgoto ulpi_exit;\n\t\t\t} else if (IS_ERR(ci->usb_phy)) {\n\t\t\t\tci->usb_phy = NULL;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ci->phy && !ci->usb_phy) {\n\t\t\tret = -ENXIO;\n\t\t\tgoto ulpi_exit;\n\t\t}\n\t}\n\n\tret = ci_usb_phy_init(ci);\n\tif (ret) {\n\t\tdev_err(dev, \"unable to init phy: %d\\n\", ret);\n\t\tgoto ulpi_exit;\n\t}\n\n\tci->hw_bank.phys = res->start;\n\n\tci->irq = platform_get_irq(pdev, 0);\n\tif (ci->irq < 0) {\n\t\tret = ci->irq;\n\t\tgoto deinit_phy;\n\t}\n\n\tci_get_otg_capable(ci);\n\n\tdr_mode = ci->platdata->dr_mode;\n\t \n\tif (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_HOST) {\n\t\tret = ci_hdrc_host_init(ci);\n\t\tif (ret) {\n\t\t\tif (ret == -ENXIO)\n\t\t\t\tdev_info(dev, \"doesn't support host\\n\");\n\t\t\telse\n\t\t\t\tgoto deinit_phy;\n\t\t}\n\t}\n\n\tif (dr_mode == USB_DR_MODE_OTG || dr_mode == USB_DR_MODE_PERIPHERAL) {\n\t\tret = ci_hdrc_gadget_init(ci);\n\t\tif (ret) {\n\t\t\tif (ret == -ENXIO)\n\t\t\t\tdev_info(dev, \"doesn't support gadget\\n\");\n\t\t\telse\n\t\t\t\tgoto deinit_host;\n\t\t}\n\t}\n\n\tif (!ci->roles[CI_ROLE_HOST] && !ci->roles[CI_ROLE_GADGET]) {\n\t\tdev_err(dev, \"no supported roles\\n\");\n\t\tret = -ENODEV;\n\t\tgoto deinit_gadget;\n\t}\n\n\tif (ci->is_otg && ci->roles[CI_ROLE_GADGET]) {\n\t\tret = ci_hdrc_otg_init(ci);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"init otg fails, ret = %d\\n\", ret);\n\t\t\tgoto deinit_gadget;\n\t\t}\n\t}\n\n\tif (ci_role_switch.fwnode) {\n\t\tci_role_switch.driver_data = ci;\n\t\tci->role_switch = usb_role_switch_register(dev,\n\t\t\t\t\t&ci_role_switch);\n\t\tif (IS_ERR(ci->role_switch)) {\n\t\t\tret = PTR_ERR(ci->role_switch);\n\t\t\tgoto deinit_otg;\n\t\t}\n\t}\n\n\tci->role = ci_get_role(ci);\n\tif (!ci_otg_is_fsm_mode(ci)) {\n\t\t \n\t\tif (ci->role == CI_ROLE_GADGET) {\n\t\t\t \n\t\t\thw_write(ci, OP_USBCMD, USBCMD_RS, 0);\n\t\t\tci_handle_vbus_change(ci);\n\t\t}\n\n\t\tret = ci_role_start(ci, ci->role);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"can't start %s role\\n\",\n\t\t\t\t\t\tci_role(ci)->name);\n\t\t\tgoto stop;\n\t\t}\n\t}\n\n\tret = devm_request_irq(dev, ci->irq, ci_irq_handler, IRQF_SHARED,\n\t\t\tci->platdata->name, ci);\n\tif (ret)\n\t\tgoto stop;\n\n\tret = ci_extcon_register(ci);\n\tif (ret)\n\t\tgoto stop;\n\n\tif (ci->supports_runtime_pm) {\n\t\tpm_runtime_set_active(&pdev->dev);\n\t\tpm_runtime_enable(&pdev->dev);\n\t\tpm_runtime_set_autosuspend_delay(&pdev->dev, 2000);\n\t\tpm_runtime_mark_last_busy(ci->dev);\n\t\tpm_runtime_use_autosuspend(&pdev->dev);\n\t}\n\n\tif (ci_otg_is_fsm_mode(ci))\n\t\tci_hdrc_otg_fsm_start(ci);\n\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\tdbg_create_files(ci);\n\n\treturn 0;\n\nstop:\n\tif (ci->role_switch)\n\t\tusb_role_switch_unregister(ci->role_switch);\ndeinit_otg:\n\tif (ci->is_otg && ci->roles[CI_ROLE_GADGET])\n\t\tci_hdrc_otg_destroy(ci);\ndeinit_gadget:\n\tci_hdrc_gadget_destroy(ci);\ndeinit_host:\n\tci_hdrc_host_destroy(ci);\ndeinit_phy:\n\tci_usb_phy_exit(ci);\nulpi_exit:\n\tci_ulpi_exit(ci);\n\n\treturn ret;\n}\n\nstatic void ci_hdrc_remove(struct platform_device *pdev)\n{\n\tstruct ci_hdrc *ci = platform_get_drvdata(pdev);\n\n\tif (ci->role_switch)\n\t\tusb_role_switch_unregister(ci->role_switch);\n\n\tif (ci->supports_runtime_pm) {\n\t\tpm_runtime_get_sync(&pdev->dev);\n\t\tpm_runtime_disable(&pdev->dev);\n\t\tpm_runtime_put_noidle(&pdev->dev);\n\t}\n\n\tdbg_remove_files(ci);\n\tci_role_destroy(ci);\n\tci_hdrc_enter_lpm(ci, true);\n\tci_usb_phy_exit(ci);\n\tci_ulpi_exit(ci);\n}\n\n#ifdef CONFIG_PM\n \nstatic void ci_otg_fsm_suspend_for_srp(struct ci_hdrc *ci)\n{\n\tif ((ci->fsm.otg->state == OTG_STATE_A_IDLE) &&\n\t\t\t\t!hw_read_otgsc(ci, OTGSC_ID)) {\n\t\thw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_PP,\n\t\t\t\t\t\t\t\tPORTSC_PP);\n\t\thw_write(ci, OP_PORTSC, PORTSC_W1C_BITS | PORTSC_WKCN,\n\t\t\t\t\t\t\t\tPORTSC_WKCN);\n\t}\n}\n\n \nstatic void ci_otg_fsm_wakeup_by_srp(struct ci_hdrc *ci)\n{\n\tif ((ci->fsm.otg->state == OTG_STATE_A_IDLE) &&\n\t\t(ci->fsm.a_bus_drop == 1) && (ci->fsm.a_bus_req == 0)) {\n\t\tif (!hw_read_otgsc(ci, OTGSC_ID)) {\n\t\t\tci->fsm.a_srp_det = 1;\n\t\t\tci->fsm.a_bus_drop = 0;\n\t\t} else {\n\t\t\tci->fsm.id = 1;\n\t\t}\n\t\tci_otg_queue_work(ci);\n\t}\n}\n\nstatic void ci_controller_suspend(struct ci_hdrc *ci)\n{\n\tdisable_irq(ci->irq);\n\tci_hdrc_enter_lpm(ci, true);\n\tif (ci->platdata->phy_clkgate_delay_us)\n\t\tusleep_range(ci->platdata->phy_clkgate_delay_us,\n\t\t\t     ci->platdata->phy_clkgate_delay_us + 50);\n\tusb_phy_set_suspend(ci->usb_phy, 1);\n\tci->in_lpm = true;\n\tenable_irq(ci->irq);\n}\n\n \nstatic void ci_extcon_wakeup_int(struct ci_hdrc *ci)\n{\n\tstruct ci_hdrc_cable *cable_id, *cable_vbus;\n\tu32 otgsc = hw_read_otgsc(ci, ~0);\n\n\tcable_id = &ci->platdata->id_extcon;\n\tcable_vbus = &ci->platdata->vbus_extcon;\n\n\tif ((!IS_ERR(cable_id->edev) || ci->role_switch)\n\t\t&& ci->is_otg &&\n\t\t(otgsc & OTGSC_IDIE) && (otgsc & OTGSC_IDIS))\n\t\tci_irq(ci);\n\n\tif ((!IS_ERR(cable_vbus->edev) || ci->role_switch)\n\t\t&& ci->is_otg &&\n\t\t(otgsc & OTGSC_BSVIE) && (otgsc & OTGSC_BSVIS))\n\t\tci_irq(ci);\n}\n\nstatic int ci_controller_resume(struct device *dev)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"at %s\\n\", __func__);\n\n\tif (!ci->in_lpm) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tci_hdrc_enter_lpm(ci, false);\n\n\tret = ci_ulpi_resume(ci);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ci->usb_phy) {\n\t\tusb_phy_set_suspend(ci->usb_phy, 0);\n\t\tusb_phy_set_wakeup(ci->usb_phy, false);\n\t\thw_wait_phy_stable();\n\t}\n\n\tci->in_lpm = false;\n\tif (ci->wakeup_int) {\n\t\tci->wakeup_int = false;\n\t\tpm_runtime_mark_last_busy(ci->dev);\n\t\tpm_runtime_put_autosuspend(ci->dev);\n\t\tenable_irq(ci->irq);\n\t\tif (ci_otg_is_fsm_mode(ci))\n\t\t\tci_otg_fsm_wakeup_by_srp(ci);\n\t\tci_extcon_wakeup_int(ci);\n\t}\n\n\treturn 0;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ci_suspend(struct device *dev)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\n\tif (ci->wq)\n\t\tflush_workqueue(ci->wq);\n\t \n\tif (ci->in_lpm)\n\t\tpm_runtime_resume(dev);\n\n\tif (ci->in_lpm) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t \n\tif (ci->role != CI_ROLE_END && ci_role(ci)->suspend)\n\t\tci_role(ci)->suspend(ci);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (ci_otg_is_fsm_mode(ci))\n\t\t\tci_otg_fsm_suspend_for_srp(ci);\n\n\t\tusb_phy_set_wakeup(ci->usb_phy, true);\n\t\tenable_irq_wake(ci->irq);\n\t}\n\n\tci_controller_suspend(ci);\n\n\treturn 0;\n}\n\nstatic void ci_handle_power_lost(struct ci_hdrc *ci)\n{\n\tenum ci_role role;\n\n\tdisable_irq_nosync(ci->irq);\n\tif (!ci_otg_is_fsm_mode(ci)) {\n\t\trole = ci_get_role(ci);\n\n\t\tif (ci->role != role) {\n\t\t\tci_handle_id_switch(ci);\n\t\t} else if (role == CI_ROLE_GADGET) {\n\t\t\tif (ci->is_otg && hw_read_otgsc(ci, OTGSC_BSV))\n\t\t\t\tusb_gadget_vbus_connect(&ci->gadget);\n\t\t}\n\t}\n\n\tenable_irq(ci->irq);\n}\n\nstatic int ci_resume(struct device *dev)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tbool power_lost;\n\tint ret;\n\n\t \n\tpower_lost = !hw_read(ci, OP_ENDPTLISTADDR, ~0);\n\n\tif (device_may_wakeup(dev))\n\t\tdisable_irq_wake(ci->irq);\n\n\tret = ci_controller_resume(dev);\n\tif (ret)\n\t\treturn ret;\n\n\tif (power_lost) {\n\t\t \n\t\tci_usb_phy_exit(ci);\n\t\tci_usb_phy_init(ci);\n\t}\n\n\t \n\tif (ci->role != CI_ROLE_END && ci_role(ci)->resume)\n\t\tci_role(ci)->resume(ci, power_lost);\n\n\tif (power_lost)\n\t\tci_handle_power_lost(ci);\n\n\tif (ci->supports_runtime_pm) {\n\t\tpm_runtime_disable(dev);\n\t\tpm_runtime_set_active(dev);\n\t\tpm_runtime_enable(dev);\n\t}\n\n\treturn ret;\n}\n#endif  \n\nstatic int ci_runtime_suspend(struct device *dev)\n{\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\n\tdev_dbg(dev, \"at %s\\n\", __func__);\n\n\tif (ci->in_lpm) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\tif (ci_otg_is_fsm_mode(ci))\n\t\tci_otg_fsm_suspend_for_srp(ci);\n\n\tusb_phy_set_wakeup(ci->usb_phy, true);\n\tci_controller_suspend(ci);\n\n\treturn 0;\n}\n\nstatic int ci_runtime_resume(struct device *dev)\n{\n\treturn ci_controller_resume(dev);\n}\n\n#endif  \nstatic const struct dev_pm_ops ci_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(ci_suspend, ci_resume)\n\tSET_RUNTIME_PM_OPS(ci_runtime_suspend, ci_runtime_resume, NULL)\n};\n\nstatic struct platform_driver ci_hdrc_driver = {\n\t.probe\t= ci_hdrc_probe,\n\t.remove_new = ci_hdrc_remove,\n\t.driver\t= {\n\t\t.name\t= \"ci_hdrc\",\n\t\t.pm\t= &ci_pm_ops,\n\t\t.dev_groups = ci_groups,\n\t},\n};\n\nstatic int __init ci_hdrc_platform_register(void)\n{\n\tci_hdrc_host_driver_init();\n\treturn platform_driver_register(&ci_hdrc_driver);\n}\nmodule_init(ci_hdrc_platform_register);\n\nstatic void __exit ci_hdrc_platform_unregister(void)\n{\n\tplatform_driver_unregister(&ci_hdrc_driver);\n}\nmodule_exit(ci_hdrc_platform_unregister);\n\nMODULE_ALIAS(\"platform:ci_hdrc\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"David Lopo <dlopo@chipidea.mips.com>\");\nMODULE_DESCRIPTION(\"ChipIdea HDRC Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}