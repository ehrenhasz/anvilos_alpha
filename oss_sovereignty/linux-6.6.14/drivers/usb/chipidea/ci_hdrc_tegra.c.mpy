{
  "module_name": "ci_hdrc_tegra.c",
  "hash_id": "66817988aa02a5ddeb788feb686e48d80a04ddb11f8dd4b16c56b2c57c76b706",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci_hdrc_tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include <linux/usb.h>\n#include <linux/usb/chipidea.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/of.h>\n#include <linux/usb/phy.h>\n\n#include <soc/tegra/common.h>\n\n#include \"../host/ehci.h\"\n\n#include \"ci.h\"\n\nstruct tegra_usb {\n\tstruct ci_hdrc_platform_data data;\n\tstruct platform_device *dev;\n\n\tconst struct tegra_usb_soc_info *soc;\n\tstruct usb_phy *phy;\n\tstruct clk *clk;\n\n\tbool needs_double_reset;\n};\n\nstruct tegra_usb_soc_info {\n\tunsigned long flags;\n\tunsigned int txfifothresh;\n\tenum usb_dr_mode dr_mode;\n};\n\nstatic const struct tegra_usb_soc_info tegra20_ehci_soc_info = {\n\t.flags = CI_HDRC_REQUIRES_ALIGNED_DMA |\n\t\t CI_HDRC_OVERRIDE_PHY_CONTROL |\n\t\t CI_HDRC_SUPPORTS_RUNTIME_PM,\n\t.dr_mode = USB_DR_MODE_HOST,\n\t.txfifothresh = 10,\n};\n\nstatic const struct tegra_usb_soc_info tegra30_ehci_soc_info = {\n\t.flags = CI_HDRC_REQUIRES_ALIGNED_DMA |\n\t\t CI_HDRC_OVERRIDE_PHY_CONTROL |\n\t\t CI_HDRC_SUPPORTS_RUNTIME_PM,\n\t.dr_mode = USB_DR_MODE_HOST,\n\t.txfifothresh = 16,\n};\n\nstatic const struct tegra_usb_soc_info tegra20_udc_soc_info = {\n\t.flags = CI_HDRC_REQUIRES_ALIGNED_DMA |\n\t\t CI_HDRC_OVERRIDE_PHY_CONTROL |\n\t\t CI_HDRC_SUPPORTS_RUNTIME_PM,\n\t.dr_mode = USB_DR_MODE_UNKNOWN,\n\t.txfifothresh = 10,\n};\n\nstatic const struct tegra_usb_soc_info tegra30_udc_soc_info = {\n\t.flags = CI_HDRC_REQUIRES_ALIGNED_DMA |\n\t\t CI_HDRC_OVERRIDE_PHY_CONTROL |\n\t\t CI_HDRC_SUPPORTS_RUNTIME_PM,\n\t.dr_mode = USB_DR_MODE_UNKNOWN,\n\t.txfifothresh = 16,\n};\n\nstatic const struct of_device_id tegra_usb_of_match[] = {\n\t{\n\t\t.compatible = \"nvidia,tegra20-ehci\",\n\t\t.data = &tegra20_ehci_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra30-ehci\",\n\t\t.data = &tegra30_ehci_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra20-udc\",\n\t\t.data = &tegra20_udc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra30-udc\",\n\t\t.data = &tegra30_udc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra114-udc\",\n\t\t.data = &tegra30_udc_soc_info,\n\t}, {\n\t\t.compatible = \"nvidia,tegra124-udc\",\n\t\t.data = &tegra30_udc_soc_info,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, tegra_usb_of_match);\n\nstatic int tegra_usb_reset_controller(struct device *dev)\n{\n\tstruct reset_control *rst, *rst_utmi;\n\tstruct device_node *phy_np;\n\tint err;\n\n\trst = devm_reset_control_get_shared(dev, \"usb\");\n\tif (IS_ERR(rst)) {\n\t\tdev_err(dev, \"can't get ehci reset: %pe\\n\", rst);\n\t\treturn PTR_ERR(rst);\n\t}\n\n\tphy_np = of_parse_phandle(dev->of_node, \"nvidia,phy\", 0);\n\tif (!phy_np)\n\t\treturn -ENOENT;\n\n\t \n\trst_utmi = of_reset_control_get_shared(phy_np, \"utmi-pads\");\n\tif (IS_ERR(rst_utmi)) {\n\t\tdev_warn(dev, \"can't get utmi-pads reset from the PHY\\n\");\n\t\tdev_warn(dev, \"continuing, but please update your DT\\n\");\n\t} else {\n\t\t \n\t\treset_control_put(rst_utmi);\n\t}\n\n\tof_node_put(phy_np);\n\n\t \n\terr = reset_control_deassert(rst);\n\tif (err)\n\t\treturn err;\n\n\terr = reset_control_assert(rst);\n\tif (err)\n\t\treturn err;\n\n\tudelay(1);\n\n\terr = reset_control_deassert(rst);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic int tegra_usb_notify_event(struct ci_hdrc *ci, unsigned int event)\n{\n\tstruct tegra_usb *usb = dev_get_drvdata(ci->dev->parent);\n\tstruct ehci_hcd *ehci;\n\n\tswitch (event) {\n\tcase CI_HDRC_CONTROLLER_RESET_EVENT:\n\t\tif (ci->hcd) {\n\t\t\tehci = hcd_to_ehci(ci->hcd);\n\t\t\tehci->has_tdi_phy_lpm = false;\n\t\t\tehci_writel(ehci, usb->soc->txfifothresh << 16,\n\t\t\t\t    &ehci->regs->txfill_tuning);\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_usb_internal_port_reset(struct ehci_hcd *ehci,\n\t\t\t\t\t u32 __iomem *portsc_reg,\n\t\t\t\t\t unsigned long *flags)\n{\n\tu32 saved_usbintr, temp;\n\tunsigned int i, tries;\n\tint retval = 0;\n\n\tsaved_usbintr = ehci_readl(ehci, &ehci->regs->intr_enable);\n\t \n\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\tspin_unlock_irqrestore(&ehci->lock, *flags);\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\ttemp = ehci_readl(ehci, portsc_reg);\n\t\ttemp |= PORT_RESET;\n\t\tehci_writel(ehci, temp, portsc_reg);\n\t\tfsleep(10000);\n\t\ttemp &= ~PORT_RESET;\n\t\tehci_writel(ehci, temp, portsc_reg);\n\t\tfsleep(1000);\n\t\ttries = 100;\n\t\tdo {\n\t\t\tfsleep(1000);\n\t\t\t \n\t\t\ttemp = ehci_readl(ehci, portsc_reg);\n\t\t} while (!(temp & PORT_PE) && tries--);\n\t\tif (temp & PORT_PE)\n\t\t\tbreak;\n\t}\n\tif (i == 2)\n\t\tretval = -ETIMEDOUT;\n\n\t \n\tif (temp & PORT_CSC)\n\t\tehci_writel(ehci, PORT_CSC, portsc_reg);\n\n\t \n\ttemp = ehci_readl(ehci, &ehci->regs->status);\n\tehci_writel(ehci, temp, &ehci->regs->status);\n\n\t \n\tspin_lock_irqsave(&ehci->lock, *flags);\n\tehci_writel(ehci, saved_usbintr, &ehci->regs->intr_enable);\n\n\treturn retval;\n}\n\nstatic int tegra_ehci_hub_control(struct ci_hdrc *ci, u16 typeReq, u16 wValue,\n\t\t\t\t  u16 wIndex, char *buf, u16 wLength,\n\t\t\t\t  bool *done, unsigned long *flags)\n{\n\tstruct tegra_usb *usb = dev_get_drvdata(ci->dev->parent);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(ci->hcd);\n\tu32 __iomem *status_reg;\n\tint retval = 0;\n\n\tstatus_reg = &ehci->regs->port_status[(wIndex & 0xff) - 1];\n\n\tswitch (typeReq) {\n\tcase SetPortFeature:\n\t\tif (wValue != USB_PORT_FEAT_RESET || !usb->needs_double_reset)\n\t\t\tbreak;\n\n\t\t \n\t\tretval = tegra_usb_internal_port_reset(ehci, status_reg, flags);\n\t\t*done  = true;\n\t\tbreak;\n\t}\n\n\treturn retval;\n}\n\nstatic void tegra_usb_enter_lpm(struct ci_hdrc *ci, bool enable)\n{\n\t \n\tusb_phy_set_suspend(ci->usb_phy, enable);\n}\n\nstatic int tegra_usb_probe(struct platform_device *pdev)\n{\n\tconst struct tegra_usb_soc_info *soc;\n\tstruct tegra_usb *usb;\n\tint err;\n\n\tusb = devm_kzalloc(&pdev->dev, sizeof(*usb), GFP_KERNEL);\n\tif (!usb)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, usb);\n\n\tsoc = of_device_get_match_data(&pdev->dev);\n\tif (!soc) {\n\t\tdev_err(&pdev->dev, \"failed to match OF data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tusb->phy = devm_usb_get_phy_by_phandle(&pdev->dev, \"nvidia,phy\", 0);\n\tif (IS_ERR(usb->phy))\n\t\treturn dev_err_probe(&pdev->dev, PTR_ERR(usb->phy),\n\t\t\t\t     \"failed to get PHY\\n\");\n\n\tusb->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(usb->clk)) {\n\t\terr = PTR_ERR(usb->clk);\n\t\tdev_err(&pdev->dev, \"failed to get clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = devm_tegra_core_dev_init_opp_table_common(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tpm_runtime_enable(&pdev->dev);\n\terr = pm_runtime_resume_and_get(&pdev->dev);\n\tif (err)\n\t\treturn err;\n\n\tif (device_property_present(&pdev->dev, \"nvidia,needs-double-reset\"))\n\t\tusb->needs_double_reset = true;\n\n\terr = tegra_usb_reset_controller(&pdev->dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to reset controller: %d\\n\", err);\n\t\tgoto fail_power_off;\n\t}\n\n\t \n\terr = usb_phy_init(usb->phy);\n\tif (err)\n\t\tgoto fail_power_off;\n\n\t \n\tusb->soc = soc;\n\tusb->data.name = \"tegra-usb\";\n\tusb->data.flags = soc->flags;\n\tusb->data.usb_phy = usb->phy;\n\tusb->data.dr_mode = soc->dr_mode;\n\tusb->data.capoffset = DEF_CAPOFFSET;\n\tusb->data.enter_lpm = tegra_usb_enter_lpm;\n\tusb->data.hub_control = tegra_ehci_hub_control;\n\tusb->data.notify_event = tegra_usb_notify_event;\n\n\t \n\tif (of_usb_get_phy_mode(pdev->dev.of_node) == USBPHY_INTERFACE_MODE_ULPI)\n\t\tusb->data.flags &= ~CI_HDRC_SUPPORTS_RUNTIME_PM;\n\n\tusb->dev = ci_hdrc_add_device(&pdev->dev, pdev->resource,\n\t\t\t\t      pdev->num_resources, &usb->data);\n\tif (IS_ERR(usb->dev)) {\n\t\terr = PTR_ERR(usb->dev);\n\t\tdev_err(&pdev->dev, \"failed to add HDRC device: %d\\n\", err);\n\t\tgoto phy_shutdown;\n\t}\n\n\treturn 0;\n\nphy_shutdown:\n\tusb_phy_shutdown(usb->phy);\nfail_power_off:\n\tpm_runtime_put_sync_suspend(&pdev->dev);\n\tpm_runtime_force_suspend(&pdev->dev);\n\n\treturn err;\n}\n\nstatic void tegra_usb_remove(struct platform_device *pdev)\n{\n\tstruct tegra_usb *usb = platform_get_drvdata(pdev);\n\n\tci_hdrc_remove_device(usb->dev);\n\tusb_phy_shutdown(usb->phy);\n\n\tpm_runtime_put_sync_suspend(&pdev->dev);\n\tpm_runtime_force_suspend(&pdev->dev);\n}\n\nstatic int __maybe_unused tegra_usb_runtime_resume(struct device *dev)\n{\n\tstruct tegra_usb *usb = dev_get_drvdata(dev);\n\tint err;\n\n\terr = clk_prepare_enable(usb->clk);\n\tif (err < 0) {\n\t\tdev_err(dev, \"failed to enable clock: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tegra_usb_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_usb *usb = dev_get_drvdata(dev);\n\n\tclk_disable_unprepare(usb->clk);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tegra_usb_pm = {\n\tSET_RUNTIME_PM_OPS(tegra_usb_runtime_suspend, tegra_usb_runtime_resume,\n\t\t\t   NULL)\n};\n\nstatic struct platform_driver tegra_usb_driver = {\n\t.driver = {\n\t\t.name = \"tegra-usb\",\n\t\t.of_match_table = tegra_usb_of_match,\n\t\t.pm = &tegra_usb_pm,\n\t},\n\t.probe = tegra_usb_probe,\n\t.remove_new = tegra_usb_remove,\n};\nmodule_platform_driver(tegra_usb_driver);\n\nMODULE_DESCRIPTION(\"NVIDIA Tegra USB driver\");\nMODULE_AUTHOR(\"Thierry Reding <treding@nvidia.com>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}