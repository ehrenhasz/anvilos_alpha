{
  "module_name": "ci_hdrc_usb2.c",
  "hash_id": "683d03b4c8942f4351619424e49b5b13a492425de1dc54107fa9ac7afe196ab4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci_hdrc_usb2.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/usb/chipidea.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/ulpi.h>\n\n#include \"ci.h\"\n\nstruct ci_hdrc_usb2_priv {\n\tstruct platform_device\t*ci_pdev;\n\tstruct clk\t\t*clk;\n};\n\nstatic const struct ci_hdrc_platform_data ci_default_pdata = {\n\t.capoffset\t= DEF_CAPOFFSET,\n\t.flags\t\t= CI_HDRC_DISABLE_STREAMING,\n};\n\nstatic const struct ci_hdrc_platform_data ci_zynq_pdata = {\n\t.capoffset\t= DEF_CAPOFFSET,\n\t.flags          = CI_HDRC_PHY_VBUS_CONTROL,\n};\n\nstatic const struct ci_hdrc_platform_data ci_zevio_pdata = {\n\t.capoffset\t= DEF_CAPOFFSET,\n\t.flags\t\t= CI_HDRC_REGS_SHARED | CI_HDRC_FORCE_FULLSPEED,\n};\n\nstatic const struct of_device_id ci_hdrc_usb2_of_match[] = {\n\t{ .compatible = \"chipidea,usb2\" },\n\t{ .compatible = \"xlnx,zynq-usb-2.20a\", .data = &ci_zynq_pdata },\n\t{ .compatible = \"lsi,zevio-usb\", .data = &ci_zevio_pdata },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ci_hdrc_usb2_of_match);\n\nstatic int ci_hdrc_usb2_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct ci_hdrc_usb2_priv *priv;\n\tstruct ci_hdrc_platform_data *ci_pdata = dev_get_platdata(dev);\n\tint ret;\n\tconst struct of_device_id *match;\n\n\tif (!ci_pdata) {\n\t\tci_pdata = devm_kmalloc(dev, sizeof(*ci_pdata), GFP_KERNEL);\n\t\tif (!ci_pdata)\n\t\t\treturn -ENOMEM;\n\t\t*ci_pdata = ci_default_pdata;\t \n\t}\n\n\tmatch = of_match_device(ci_hdrc_usb2_of_match, &pdev->dev);\n\tif (match && match->data) {\n\t\t \n\t\t*ci_pdata = *(struct ci_hdrc_platform_data *)match->data;\n\t}\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(priv->clk))\n\t\treturn PTR_ERR(priv->clk);\n\n\tret = clk_prepare_enable(priv->clk);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to enable the clock: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tci_pdata->name = dev_name(dev);\n\n\tpriv->ci_pdev = ci_hdrc_add_device(dev, pdev->resource,\n\t\t\t\t\t   pdev->num_resources, ci_pdata);\n\tif (IS_ERR(priv->ci_pdev)) {\n\t\tret = PTR_ERR(priv->ci_pdev);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to register ci_hdrc platform device: %d\\n\",\n\t\t\t\tret);\n\t\tgoto clk_err;\n\t}\n\n\tplatform_set_drvdata(pdev, priv);\n\n\tpm_runtime_no_callbacks(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nclk_err:\n\tclk_disable_unprepare(priv->clk);\n\treturn ret;\n}\n\nstatic void ci_hdrc_usb2_remove(struct platform_device *pdev)\n{\n\tstruct ci_hdrc_usb2_priv *priv = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tci_hdrc_remove_device(priv->ci_pdev);\n\tclk_disable_unprepare(priv->clk);\n}\n\nstatic struct platform_driver ci_hdrc_usb2_driver = {\n\t.probe\t= ci_hdrc_usb2_probe,\n\t.remove_new = ci_hdrc_usb2_remove,\n\t.driver\t= {\n\t\t.name\t\t= \"chipidea-usb2\",\n\t\t.of_match_table\t= of_match_ptr(ci_hdrc_usb2_of_match),\n\t},\n};\nmodule_platform_driver(ci_hdrc_usb2_driver);\n\nMODULE_DESCRIPTION(\"ChipIdea HDRC USB2 binding for ci13xxx\");\nMODULE_AUTHOR(\"Antoine Tenart <antoine.tenart@free-electrons.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}