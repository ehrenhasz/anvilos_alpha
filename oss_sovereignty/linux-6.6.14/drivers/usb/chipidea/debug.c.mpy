{
  "module_name": "debug.c",
  "hash_id": "dca227d72f668adfe79a48dbc90a99c64d1269f3efce24cd82f3aee8c3511f98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/debug.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/device.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/phy.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/otg-fsm.h>\n#include <linux/usb/chipidea.h>\n\n#include \"ci.h\"\n#include \"udc.h\"\n#include \"bits.h\"\n#include \"otg.h\"\n\n \nstatic int ci_device_show(struct seq_file *s, void *data)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tstruct usb_gadget *gadget = &ci->gadget;\n\n\tseq_printf(s, \"speed             = %d\\n\", gadget->speed);\n\tseq_printf(s, \"max_speed         = %d\\n\", gadget->max_speed);\n\tseq_printf(s, \"is_otg            = %d\\n\", gadget->is_otg);\n\tseq_printf(s, \"is_a_peripheral   = %d\\n\", gadget->is_a_peripheral);\n\tseq_printf(s, \"b_hnp_enable      = %d\\n\", gadget->b_hnp_enable);\n\tseq_printf(s, \"a_hnp_support     = %d\\n\", gadget->a_hnp_support);\n\tseq_printf(s, \"a_alt_hnp_support = %d\\n\", gadget->a_alt_hnp_support);\n\tseq_printf(s, \"name              = %s\\n\",\n\t\t   (gadget->name ? gadget->name : \"\"));\n\n\tif (!ci->driver)\n\t\treturn 0;\n\n\tseq_printf(s, \"gadget function   = %s\\n\",\n\t\t       (ci->driver->function ? ci->driver->function : \"\"));\n\tseq_printf(s, \"gadget max speed  = %d\\n\", ci->driver->max_speed);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ci_device);\n\n \nstatic int ci_port_test_show(struct seq_file *s, void *data)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tunsigned long flags;\n\tunsigned mode;\n\n\tpm_runtime_get_sync(ci->dev);\n\tspin_lock_irqsave(&ci->lock, flags);\n\tmode = hw_port_test_get(ci);\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\tpm_runtime_put_sync(ci->dev);\n\n\tseq_printf(s, \"mode = %u\\n\", mode);\n\n\treturn 0;\n}\n\n \nstatic ssize_t ci_port_test_write(struct file *file, const char __user *ubuf,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\tstruct seq_file *s = file->private_data;\n\tstruct ci_hdrc *ci = s->private;\n\tunsigned long flags;\n\tunsigned mode;\n\tchar buf[32];\n\tint ret;\n\n\tcount = min_t(size_t, sizeof(buf) - 1, count);\n\tif (copy_from_user(buf, ubuf, count))\n\t\treturn -EFAULT;\n\n\t \n\tbuf[count] = '\\0';\n\n\tif (sscanf(buf, \"%u\", &mode) != 1)\n\t\treturn -EINVAL;\n\n\tif (mode > 255)\n\t\treturn -EBADRQC;\n\n\tpm_runtime_get_sync(ci->dev);\n\tspin_lock_irqsave(&ci->lock, flags);\n\tret = hw_port_test_set(ci, mode);\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\tpm_runtime_put_sync(ci->dev);\n\n\treturn ret ? ret : count;\n}\n\nstatic int ci_port_test_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ci_port_test_show, inode->i_private);\n}\n\nstatic const struct file_operations ci_port_test_fops = {\n\t.open\t\t= ci_port_test_open,\n\t.write\t\t= ci_port_test_write,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\n \nstatic int ci_qheads_show(struct seq_file *s, void *data)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tunsigned long flags;\n\tunsigned i, j;\n\n\tif (ci->role != CI_ROLE_GADGET) {\n\t\tseq_printf(s, \"not in gadget mode\\n\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tfor (i = 0; i < ci->hw_ep_max/2; i++) {\n\t\tstruct ci_hw_ep *hweprx = &ci->ci_hw_ep[i];\n\t\tstruct ci_hw_ep *hweptx =\n\t\t\t&ci->ci_hw_ep[i + ci->hw_ep_max/2];\n\t\tseq_printf(s, \"EP=%02i: RX=%08X TX=%08X\\n\",\n\t\t\t   i, (u32)hweprx->qh.dma, (u32)hweptx->qh.dma);\n\t\tfor (j = 0; j < (sizeof(struct ci_hw_qh)/sizeof(u32)); j++)\n\t\t\tseq_printf(s, \" %04X:    %08X    %08X\\n\", j,\n\t\t\t\t   *((u32 *)hweprx->qh.ptr + j),\n\t\t\t\t   *((u32 *)hweptx->qh.ptr + j));\n\t}\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ci_qheads);\n\n \nstatic int ci_requests_show(struct seq_file *s, void *data)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tunsigned long flags;\n\tstruct ci_hw_req *req = NULL;\n\tstruct td_node *node, *tmpnode;\n\tunsigned i, j, qsize = sizeof(struct ci_hw_td)/sizeof(u32);\n\n\tif (ci->role != CI_ROLE_GADGET) {\n\t\tseq_printf(s, \"not in gadget mode\\n\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&ci->lock, flags);\n\tfor (i = 0; i < ci->hw_ep_max; i++)\n\t\tlist_for_each_entry(req, &ci->ci_hw_ep[i].qh.queue, queue) {\n\t\t\tlist_for_each_entry_safe(node, tmpnode, &req->tds, td) {\n\t\t\t\tseq_printf(s, \"EP=%02i: TD=%08X %s\\n\",\n\t\t\t\t\t   i % (ci->hw_ep_max / 2),\n\t\t\t\t\t   (u32)node->dma,\n\t\t\t\t\t   ((i < ci->hw_ep_max/2) ?\n\t\t\t\t\t   \"RX\" : \"TX\"));\n\n\t\t\t\tfor (j = 0; j < qsize; j++)\n\t\t\t\t\tseq_printf(s, \" %04X:    %08X\\n\", j,\n\t\t\t\t\t\t   *((u32 *)node->ptr + j));\n\t\t\t}\n\t\t}\n\tspin_unlock_irqrestore(&ci->lock, flags);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ci_requests);\n\nstatic int ci_otg_show(struct seq_file *s, void *unused)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tstruct otg_fsm *fsm;\n\n\tif (!ci || !ci_otg_is_fsm_mode(ci))\n\t\treturn 0;\n\n\tfsm = &ci->fsm;\n\n\t \n\tseq_printf(s, \"OTG state: %s\\n\\n\",\n\t\t\tusb_otg_state_string(ci->otg.state));\n\n\t \n\tseq_printf(s, \"a_bus_drop: %d\\n\", fsm->a_bus_drop);\n\n\tseq_printf(s, \"a_bus_req: %d\\n\", fsm->a_bus_req);\n\n\tseq_printf(s, \"a_srp_det: %d\\n\", fsm->a_srp_det);\n\n\tseq_printf(s, \"a_vbus_vld: %d\\n\", fsm->a_vbus_vld);\n\n\tseq_printf(s, \"b_conn: %d\\n\", fsm->b_conn);\n\n\tseq_printf(s, \"adp_change: %d\\n\", fsm->adp_change);\n\n\tseq_printf(s, \"power_up: %d\\n\", fsm->power_up);\n\n\tseq_printf(s, \"a_bus_resume: %d\\n\", fsm->a_bus_resume);\n\n\tseq_printf(s, \"a_bus_suspend: %d\\n\", fsm->a_bus_suspend);\n\n\tseq_printf(s, \"a_conn: %d\\n\", fsm->a_conn);\n\n\tseq_printf(s, \"b_bus_req: %d\\n\", fsm->b_bus_req);\n\n\tseq_printf(s, \"b_bus_suspend: %d\\n\", fsm->b_bus_suspend);\n\n\tseq_printf(s, \"b_se0_srp: %d\\n\", fsm->b_se0_srp);\n\n\tseq_printf(s, \"b_ssend_srp: %d\\n\", fsm->b_ssend_srp);\n\n\tseq_printf(s, \"b_sess_vld: %d\\n\", fsm->b_sess_vld);\n\n\tseq_printf(s, \"b_srp_done: %d\\n\", fsm->b_srp_done);\n\n\tseq_printf(s, \"drv_vbus: %d\\n\", fsm->drv_vbus);\n\n\tseq_printf(s, \"loc_conn: %d\\n\", fsm->loc_conn);\n\n\tseq_printf(s, \"loc_sof: %d\\n\", fsm->loc_sof);\n\n\tseq_printf(s, \"adp_prb: %d\\n\", fsm->adp_prb);\n\n\tseq_printf(s, \"id: %d\\n\", fsm->id);\n\n\tseq_printf(s, \"protocol: %d\\n\", fsm->protocol);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ci_otg);\n\nstatic int ci_registers_show(struct seq_file *s, void *unused)\n{\n\tstruct ci_hdrc *ci = s->private;\n\tu32 tmp_reg;\n\n\tif (!ci || ci->in_lpm)\n\t\treturn -EPERM;\n\n\t \n\ttmp_reg = hw_read_intr_enable(ci);\n\tseq_printf(s, \"USBINTR reg: %08x\\n\", tmp_reg);\n\n\ttmp_reg = hw_read_intr_status(ci);\n\tseq_printf(s, \"USBSTS reg: %08x\\n\", tmp_reg);\n\n\ttmp_reg = hw_read(ci, OP_USBMODE, ~0);\n\tseq_printf(s, \"USBMODE reg: %08x\\n\", tmp_reg);\n\n\ttmp_reg = hw_read(ci, OP_USBCMD, ~0);\n\tseq_printf(s, \"USBCMD reg: %08x\\n\", tmp_reg);\n\n\ttmp_reg = hw_read(ci, OP_PORTSC, ~0);\n\tseq_printf(s, \"PORTSC reg: %08x\\n\", tmp_reg);\n\n\tif (ci->is_otg) {\n\t\ttmp_reg = hw_read_otgsc(ci, ~0);\n\t\tseq_printf(s, \"OTGSC reg: %08x\\n\", tmp_reg);\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ci_registers);\n\n \nvoid dbg_create_files(struct ci_hdrc *ci)\n{\n\tstruct dentry *dir;\n\n\tdir = debugfs_create_dir(dev_name(ci->dev), usb_debug_root);\n\n\tdebugfs_create_file(\"device\", S_IRUGO, dir, ci, &ci_device_fops);\n\tdebugfs_create_file(\"port_test\", S_IRUGO | S_IWUSR, dir, ci, &ci_port_test_fops);\n\tdebugfs_create_file(\"qheads\", S_IRUGO, dir, ci, &ci_qheads_fops);\n\tdebugfs_create_file(\"requests\", S_IRUGO, dir, ci, &ci_requests_fops);\n\n\tif (ci_otg_is_fsm_mode(ci))\n\t\tdebugfs_create_file(\"otg\", S_IRUGO, dir, ci, &ci_otg_fops);\n\n\tdebugfs_create_file(\"registers\", S_IRUGO, dir, ci, &ci_registers_fops);\n}\n\n \nvoid dbg_remove_files(struct ci_hdrc *ci)\n{\n\tdebugfs_lookup_and_remove(dev_name(ci->dev), usb_debug_root);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}