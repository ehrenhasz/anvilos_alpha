{
  "module_name": "usbmisc_imx.c",
  "hash_id": "fe550e02096cf77e99109c8941a728238845c5ed3a5e067107f9e01b51541b42",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/usbmisc_imx.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/usb/otg.h>\n\n#include \"ci_hdrc_imx.h\"\n\n#define MX25_USB_PHY_CTRL_OFFSET\t0x08\n#define MX25_BM_EXTERNAL_VBUS_DIVIDER\tBIT(23)\n\n#define MX25_EHCI_INTERFACE_SINGLE_UNI\t(2 << 0)\n#define MX25_EHCI_INTERFACE_DIFF_UNI\t(0 << 0)\n#define MX25_EHCI_INTERFACE_MASK\t(0xf)\n\n#define MX25_OTG_SIC_SHIFT\t\t29\n#define MX25_OTG_SIC_MASK\t\t(0x3 << MX25_OTG_SIC_SHIFT)\n#define MX25_OTG_PM_BIT\t\t\tBIT(24)\n#define MX25_OTG_PP_BIT\t\t\tBIT(11)\n#define MX25_OTG_OCPOL_BIT\t\tBIT(3)\n\n#define MX25_H1_SIC_SHIFT\t\t21\n#define MX25_H1_SIC_MASK\t\t(0x3 << MX25_H1_SIC_SHIFT)\n#define MX25_H1_PP_BIT\t\t\tBIT(18)\n#define MX25_H1_PM_BIT\t\t\tBIT(16)\n#define MX25_H1_IPPUE_UP_BIT\t\tBIT(7)\n#define MX25_H1_IPPUE_DOWN_BIT\t\tBIT(6)\n#define MX25_H1_TLL_BIT\t\t\tBIT(5)\n#define MX25_H1_USBTE_BIT\t\tBIT(4)\n#define MX25_H1_OCPOL_BIT\t\tBIT(2)\n\n#define MX27_H1_PM_BIT\t\t\tBIT(8)\n#define MX27_H2_PM_BIT\t\t\tBIT(16)\n#define MX27_OTG_PM_BIT\t\t\tBIT(24)\n\n#define MX53_USB_OTG_PHY_CTRL_0_OFFSET\t0x08\n#define MX53_USB_OTG_PHY_CTRL_1_OFFSET\t0x0c\n#define MX53_USB_CTRL_1_OFFSET\t        0x10\n#define MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_MASK (0x11 << 2)\n#define MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_ULPI BIT(2)\n#define MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_MASK (0x11 << 6)\n#define MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_ULPI BIT(6)\n#define MX53_USB_UH2_CTRL_OFFSET\t0x14\n#define MX53_USB_UH3_CTRL_OFFSET\t0x18\n#define MX53_USB_CLKONOFF_CTRL_OFFSET\t0x24\n#define MX53_USB_CLKONOFF_CTRL_H2_INT60CKOFF BIT(21)\n#define MX53_USB_CLKONOFF_CTRL_H3_INT60CKOFF BIT(22)\n#define MX53_BM_OVER_CUR_DIS_H1\t\tBIT(5)\n#define MX53_BM_OVER_CUR_DIS_OTG\tBIT(8)\n#define MX53_BM_OVER_CUR_DIS_UHx\tBIT(30)\n#define MX53_USB_CTRL_1_UH2_ULPI_EN\tBIT(26)\n#define MX53_USB_CTRL_1_UH3_ULPI_EN\tBIT(27)\n#define MX53_USB_UHx_CTRL_WAKE_UP_EN\tBIT(7)\n#define MX53_USB_UHx_CTRL_ULPI_INT_EN\tBIT(8)\n#define MX53_USB_PHYCTRL1_PLLDIV_MASK\t0x3\n#define MX53_USB_PLL_DIV_24_MHZ\t\t0x01\n\n#define MX6_BM_NON_BURST_SETTING\tBIT(1)\n#define MX6_BM_OVER_CUR_DIS\t\tBIT(7)\n#define MX6_BM_OVER_CUR_POLARITY\tBIT(8)\n#define MX6_BM_PWR_POLARITY\t\tBIT(9)\n#define MX6_BM_WAKEUP_ENABLE\t\tBIT(10)\n#define MX6_BM_UTMI_ON_CLOCK\t\tBIT(13)\n#define MX6_BM_ID_WAKEUP\t\tBIT(16)\n#define MX6_BM_VBUS_WAKEUP\t\tBIT(17)\n#define MX6SX_BM_DPDM_WAKEUP_EN\t\tBIT(29)\n#define MX6_BM_WAKEUP_INTR\t\tBIT(31)\n\n#define MX6_USB_HSIC_CTRL_OFFSET\t0x10\n \n#define MX6SX_BM_HSIC_AUTO_RESUME\tBIT(23)\n \n#define MX6_BM_HSIC_DEV_CONN\t\tBIT(21)\n \n#define MX6_BM_HSIC_EN\t\t\tBIT(12)\n \n#define MX6_BM_HSIC_CLK_ON\t\tBIT(11)\n\n#define MX6_USB_OTG1_PHY_CTRL\t\t0x18\n \n#define MX6_USB_OTG2_PHY_CTRL\t\t0x1c\n#define MX6SX_USB_VBUS_WAKEUP_SOURCE(v)\t(v << 8)\n#define MX6SX_USB_VBUS_WAKEUP_SOURCE_VBUS\tMX6SX_USB_VBUS_WAKEUP_SOURCE(0)\n#define MX6SX_USB_VBUS_WAKEUP_SOURCE_AVALID\tMX6SX_USB_VBUS_WAKEUP_SOURCE(1)\n#define MX6SX_USB_VBUS_WAKEUP_SOURCE_BVALID\tMX6SX_USB_VBUS_WAKEUP_SOURCE(2)\n#define MX6SX_USB_VBUS_WAKEUP_SOURCE_SESS_END\tMX6SX_USB_VBUS_WAKEUP_SOURCE(3)\n\n#define VF610_OVER_CUR_DIS\t\tBIT(7)\n\n#define MX7D_USBNC_USB_CTRL2\t\t0x4\n#define MX7D_USB_VBUS_WAKEUP_SOURCE_MASK\t0x3\n#define MX7D_USB_VBUS_WAKEUP_SOURCE(v)\t\t(v << 0)\n#define MX7D_USB_VBUS_WAKEUP_SOURCE_VBUS\tMX7D_USB_VBUS_WAKEUP_SOURCE(0)\n#define MX7D_USB_VBUS_WAKEUP_SOURCE_AVALID\tMX7D_USB_VBUS_WAKEUP_SOURCE(1)\n#define MX7D_USB_VBUS_WAKEUP_SOURCE_BVALID\tMX7D_USB_VBUS_WAKEUP_SOURCE(2)\n#define MX7D_USB_VBUS_WAKEUP_SOURCE_SESS_END\tMX7D_USB_VBUS_WAKEUP_SOURCE(3)\n#define MX7D_USBNC_AUTO_RESUME\t\t\t\tBIT(2)\n \n#define MX7D_USBNC_USB_CTRL2_OPMODE(v)\t\t\t(v << 6)\n#define MX7D_USBNC_USB_CTRL2_OPMODE_NON_DRIVING\tMX7D_USBNC_USB_CTRL2_OPMODE(1)\n#define MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_MASK\t(BIT(7) | BIT(6))\n#define MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_EN\t\tBIT(8)\n#define MX7D_USBNC_USB_CTRL2_DP_OVERRIDE_VAL\t\tBIT(12)\n#define MX7D_USBNC_USB_CTRL2_DP_OVERRIDE_EN\t\tBIT(13)\n#define MX7D_USBNC_USB_CTRL2_DM_OVERRIDE_VAL\t\tBIT(14)\n#define MX7D_USBNC_USB_CTRL2_DM_OVERRIDE_EN\t\tBIT(15)\n#define MX7D_USBNC_USB_CTRL2_DP_DM_MASK\t\t\t(BIT(12) | BIT(13) | \\\n\t\t\t\t\t\t\tBIT(14) | BIT(15))\n\n#define MX7D_USB_OTG_PHY_CFG2_CHRG_CHRGSEL\tBIT(0)\n#define MX7D_USB_OTG_PHY_CFG2_CHRG_VDATDETENB0\tBIT(1)\n#define MX7D_USB_OTG_PHY_CFG2_CHRG_VDATSRCENB0\tBIT(2)\n#define MX7D_USB_OTG_PHY_CFG2_CHRG_DCDENB\tBIT(3)\n#define MX7D_USB_OTG_PHY_CFG2_DRVVBUS0\t\tBIT(16)\n\n#define MX7D_USB_OTG_PHY_CFG2\t\t0x34\n\n#define MX7D_USB_OTG_PHY_STATUS\t\t0x3c\n#define MX7D_USB_OTG_PHY_STATUS_LINE_STATE0\tBIT(0)\n#define MX7D_USB_OTG_PHY_STATUS_LINE_STATE1\tBIT(1)\n#define MX7D_USB_OTG_PHY_STATUS_VBUS_VLD\tBIT(3)\n#define MX7D_USB_OTG_PHY_STATUS_CHRGDET\t\tBIT(29)\n\n#define MX7D_USB_OTG_PHY_CFG1\t\t0x30\n#define TXPREEMPAMPTUNE0_BIT\t\t28\n#define TXPREEMPAMPTUNE0_MASK\t\t(3 << 28)\n#define TXRISETUNE0_BIT\t\t\t24\n#define TXRISETUNE0_MASK\t\t(3 << 24)\n#define TXVREFTUNE0_BIT\t\t\t20\n#define TXVREFTUNE0_MASK\t\t(0xf << 20)\n\n#define MX6_USB_OTG_WAKEUP_BITS (MX6_BM_WAKEUP_ENABLE | MX6_BM_VBUS_WAKEUP | \\\n\t\t\t\t MX6_BM_ID_WAKEUP | MX6SX_BM_DPDM_WAKEUP_EN)\n\nstruct usbmisc_ops {\n\t \n\tint (*init)(struct imx_usbmisc_data *data);\n\t \n\tint (*post)(struct imx_usbmisc_data *data);\n\t \n\tint (*set_wakeup)(struct imx_usbmisc_data *data, bool enabled);\n\t \n\tint (*hsic_set_connect)(struct imx_usbmisc_data *data);\n\t \n\tint (*hsic_set_clk)(struct imx_usbmisc_data *data, bool enabled);\n\t \n\tint (*charger_detection)(struct imx_usbmisc_data *data);\n\t \n\tint (*power_lost_check)(struct imx_usbmisc_data *data);\n\tvoid (*vbus_comparator_on)(struct imx_usbmisc_data *data, bool on);\n};\n\nstruct imx_usbmisc {\n\tvoid __iomem *base;\n\tspinlock_t lock;\n\tconst struct usbmisc_ops *ops;\n};\n\nstatic inline bool is_imx53_usbmisc(struct imx_usbmisc_data *data);\n\nstatic int usbmisc_imx25_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val = 0;\n\n\tif (data->index > 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tswitch (data->index) {\n\tcase 0:\n\t\tval = readl(usbmisc->base);\n\t\tval &= ~(MX25_OTG_SIC_MASK | MX25_OTG_PP_BIT);\n\t\tval |= (MX25_EHCI_INTERFACE_DIFF_UNI & MX25_EHCI_INTERFACE_MASK) << MX25_OTG_SIC_SHIFT;\n\t\tval |= (MX25_OTG_PM_BIT | MX25_OTG_OCPOL_BIT);\n\n\t\t \n\t\tif (data->oc_pol_configured && data->oc_pol_active_low)\n\t\t\tval &= ~MX25_OTG_OCPOL_BIT;\n\n\t\twritel(val, usbmisc->base);\n\t\tbreak;\n\tcase 1:\n\t\tval = readl(usbmisc->base);\n\t\tval &= ~(MX25_H1_SIC_MASK | MX25_H1_PP_BIT |  MX25_H1_IPPUE_UP_BIT);\n\t\tval |= (MX25_EHCI_INTERFACE_SINGLE_UNI & MX25_EHCI_INTERFACE_MASK) << MX25_H1_SIC_SHIFT;\n\t\tval |= (MX25_H1_PM_BIT | MX25_H1_OCPOL_BIT | MX25_H1_TLL_BIT |\n\t\t\tMX25_H1_USBTE_BIT | MX25_H1_IPPUE_DOWN_BIT);\n\n\t\t \n\t\tif (data->oc_pol_configured && data->oc_pol_active_low)\n\t\t\tval &= ~MX25_H1_OCPOL_BIT;\n\n\t\twritel(val, usbmisc->base);\n\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx25_post(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tvoid __iomem *reg;\n\tunsigned long flags;\n\tu32 val;\n\n\tif (data->index > 2)\n\t\treturn -EINVAL;\n\n\tif (data->index)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\treg = usbmisc->base + MX25_USB_PHY_CTRL_OFFSET;\n\tval = readl(reg);\n\n\tif (data->evdo)\n\t\tval |= MX25_BM_EXTERNAL_VBUS_DIVIDER;\n\telse\n\t\tval &= ~MX25_BM_EXTERNAL_VBUS_DIVIDER;\n\n\twritel(val, reg);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\tusleep_range(5000, 10000);  \n\n\treturn 0;\n}\n\nstatic int usbmisc_imx27_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tswitch (data->index) {\n\tcase 0:\n\t\tval = MX27_OTG_PM_BIT;\n\t\tbreak;\n\tcase 1:\n\t\tval = MX27_H1_PM_BIT;\n\t\tbreak;\n\tcase 2:\n\t\tval = MX27_H2_PM_BIT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tif (data->disable_oc)\n\t\tval = readl(usbmisc->base) | val;\n\telse\n\t\tval = readl(usbmisc->base) & ~val;\n\twritel(val, usbmisc->base);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx53_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tvoid __iomem *reg = NULL;\n\tunsigned long flags;\n\tu32 val = 0;\n\n\tif (data->index > 3)\n\t\treturn -EINVAL;\n\n\t \n\tval = readl(usbmisc->base + MX53_USB_OTG_PHY_CTRL_1_OFFSET);\n\tval &= ~MX53_USB_PHYCTRL1_PLLDIV_MASK;\n\tval |= MX53_USB_PLL_DIV_24_MHZ;\n\twritel(val, usbmisc->base + MX53_USB_OTG_PHY_CTRL_1_OFFSET);\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\n\tswitch (data->index) {\n\tcase 0:\n\t\tif (data->disable_oc) {\n\t\t\treg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\n\t\t\tval = readl(reg) | MX53_BM_OVER_CUR_DIS_OTG;\n\t\t\twritel(val, reg);\n\t\t}\n\t\tbreak;\n\tcase 1:\n\t\tif (data->disable_oc) {\n\t\t\treg = usbmisc->base + MX53_USB_OTG_PHY_CTRL_0_OFFSET;\n\t\t\tval = readl(reg) | MX53_BM_OVER_CUR_DIS_H1;\n\t\t\twritel(val, reg);\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tif (data->ulpi) {\n\t\t\t \n\t\t\treg = usbmisc->base + MX53_USB_CTRL_1_OFFSET;\n\t\t\tval = readl(reg) | MX53_USB_CTRL_1_UH2_ULPI_EN;\n\t\t\t \n\t\t\tval &= ~MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_MASK;\n\t\t\tval |= MX53_USB_CTRL_1_H2_XCVR_CLK_SEL_ULPI;\n\t\t\twritel(val, reg);\n\t\t\t \n\t\t\treg = usbmisc->base + MX53_USB_UH2_CTRL_OFFSET;\n\t\t\tval = readl(reg) | MX53_USB_UHx_CTRL_WAKE_UP_EN\n\t\t\t\t| MX53_USB_UHx_CTRL_ULPI_INT_EN;\n\t\t\twritel(val, reg);\n\t\t\tif (is_imx53_usbmisc(data)) {\n\t\t\t\t \n\t\t\t\treg = usbmisc->base +\n\t\t\t\t\tMX53_USB_CLKONOFF_CTRL_OFFSET;\n\t\t\t\tval = readl(reg) |\n\t\t\t\t\tMX53_USB_CLKONOFF_CTRL_H2_INT60CKOFF;\n\t\t\t\twritel(val, reg);\n\t\t\t}\n\n\t\t}\n\t\tif (data->disable_oc) {\n\t\t\treg = usbmisc->base + MX53_USB_UH2_CTRL_OFFSET;\n\t\t\tval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\n\t\t\twritel(val, reg);\n\t\t}\n\t\tbreak;\n\tcase 3:\n\t\tif (data->ulpi) {\n\t\t\t \n\t\t\treg = usbmisc->base + MX53_USB_CTRL_1_OFFSET;\n\t\t\tval = readl(reg) | MX53_USB_CTRL_1_UH3_ULPI_EN;\n\t\t\t \n\t\t\tval &= ~MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_MASK;\n\t\t\tval |= MX53_USB_CTRL_1_H3_XCVR_CLK_SEL_ULPI;\n\t\t\twritel(val, reg);\n\t\t\t \n\t\t\treg = usbmisc->base + MX53_USB_UH3_CTRL_OFFSET;\n\t\t\tval = readl(reg) | MX53_USB_UHx_CTRL_WAKE_UP_EN\n\t\t\t\t| MX53_USB_UHx_CTRL_ULPI_INT_EN;\n\t\t\twritel(val, reg);\n\n\t\t\tif (is_imx53_usbmisc(data)) {\n\t\t\t\t \n\t\t\t\treg = usbmisc->base +\n\t\t\t\t\tMX53_USB_CLKONOFF_CTRL_OFFSET;\n\t\t\t\tval = readl(reg) |\n\t\t\t\t\tMX53_USB_CLKONOFF_CTRL_H3_INT60CKOFF;\n\t\t\t\twritel(val, reg);\n\t\t\t}\n\t\t}\n\t\tif (data->disable_oc) {\n\t\t\treg = usbmisc->base + MX53_USB_UH3_CTRL_OFFSET;\n\t\t\tval = readl(reg) | MX53_BM_OVER_CUR_DIS_UHx;\n\t\t\twritel(val, reg);\n\t\t}\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\nstatic u32 usbmisc_wakeup_setting(struct imx_usbmisc_data *data)\n{\n\tu32 wakeup_setting = MX6_USB_OTG_WAKEUP_BITS;\n\n\tif (data->ext_id || data->available_role != USB_DR_MODE_OTG)\n\t\twakeup_setting &= ~MX6_BM_ID_WAKEUP;\n\n\tif (data->ext_vbus || data->available_role == USB_DR_MODE_HOST)\n\t\twakeup_setting &= ~MX6_BM_VBUS_WAKEUP;\n\n\treturn wakeup_setting;\n}\n\nstatic int usbmisc_imx6q_set_wakeup\n\t(struct imx_usbmisc_data *data, bool enabled)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\tint ret = 0;\n\n\tif (data->index > 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + data->index * 4);\n\tif (enabled) {\n\t\tval &= ~MX6_USB_OTG_WAKEUP_BITS;\n\t\tval |= usbmisc_wakeup_setting(data);\n\t} else {\n\t\tif (val & MX6_BM_WAKEUP_INTR)\n\t\t\tpr_debug(\"wakeup int at ci_hdrc.%d\\n\", data->index);\n\t\tval &= ~MX6_USB_OTG_WAKEUP_BITS;\n\t}\n\twritel(val, usbmisc->base + data->index * 4);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn ret;\n}\n\nstatic int usbmisc_imx6q_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (data->index > 3)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\n\treg = readl(usbmisc->base + data->index * 4);\n\tif (data->disable_oc) {\n\t\treg |= MX6_BM_OVER_CUR_DIS;\n\t} else {\n\t\treg &= ~MX6_BM_OVER_CUR_DIS;\n\n\t\t \n\t\tif (data->oc_pol_configured && data->oc_pol_active_low)\n\t\t\treg |= MX6_BM_OVER_CUR_POLARITY;\n\t\telse if (data->oc_pol_configured)\n\t\t\treg &= ~MX6_BM_OVER_CUR_POLARITY;\n\t}\n\t \n\tif (data->pwr_pol == 1)\n\t\treg |= MX6_BM_PWR_POLARITY;\n\twritel(reg, usbmisc->base + data->index * 4);\n\n\t \n\treg = readl(usbmisc->base + data->index * 4);\n\twritel(reg | MX6_BM_NON_BURST_SETTING,\n\t\t\tusbmisc->base + data->index * 4);\n\n\t \n\tif (data->hsic) {\n\t\treg = readl(usbmisc->base + data->index * 4);\n\t\twritel(reg | MX6_BM_UTMI_ON_CLOCK,\n\t\t\tusbmisc->base + data->index * 4);\n\t\treg = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET\n\t\t\t+ (data->index - 2) * 4);\n\t\treg |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;\n\t\twritel(reg, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET\n\t\t\t+ (data->index - 2) * 4);\n\t}\n\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tusbmisc_imx6q_set_wakeup(data, false);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx6_hsic_get_reg_offset(struct imx_usbmisc_data *data)\n{\n\tint offset, ret = 0;\n\n\tif (data->index == 2 || data->index == 3) {\n\t\toffset = (data->index - 2) * 4;\n\t} else if (data->index == 0) {\n\t\t \n\t\toffset = 0;\n\t} else {\n\t\tdev_err(data->dev, \"index is error for usbmisc\\n\");\n\t\tret = -EINVAL;\n\t}\n\n\treturn ret ? ret : offset;\n}\n\nstatic int usbmisc_imx6_hsic_set_connect(struct imx_usbmisc_data *data)\n{\n\tunsigned long flags;\n\tu32 val;\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tint offset;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\toffset = usbmisc_imx6_hsic_get_reg_offset(data);\n\tif (offset < 0) {\n\t\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\t\treturn offset;\n\t}\n\n\tval = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET + offset);\n\tif (!(val & MX6_BM_HSIC_DEV_CONN))\n\t\twritel(val | MX6_BM_HSIC_DEV_CONN,\n\t\t\tusbmisc->base + MX6_USB_HSIC_CTRL_OFFSET + offset);\n\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx6_hsic_set_clk(struct imx_usbmisc_data *data, bool on)\n{\n\tunsigned long flags;\n\tu32 val;\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tint offset;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\toffset = usbmisc_imx6_hsic_get_reg_offset(data);\n\tif (offset < 0) {\n\t\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\t\treturn offset;\n\t}\n\n\tval = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET + offset);\n\tval |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;\n\tif (on)\n\t\tval |= MX6_BM_HSIC_CLK_ON;\n\telse\n\t\tval &= ~MX6_BM_HSIC_CLK_ON;\n\n\twritel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET + offset);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\n\nstatic int usbmisc_imx6sx_init(struct imx_usbmisc_data *data)\n{\n\tvoid __iomem *reg = NULL;\n\tunsigned long flags;\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tu32 val;\n\n\tusbmisc_imx6q_init(data);\n\n\tif (data->index == 0 || data->index == 1) {\n\t\treg = usbmisc->base + MX6_USB_OTG1_PHY_CTRL + data->index * 4;\n\t\tspin_lock_irqsave(&usbmisc->lock, flags);\n\t\t \n\t\tval = readl(reg);\n\t\twritel(val | MX6SX_USB_VBUS_WAKEUP_SOURCE_BVALID, reg);\n\t\t \n\t\tval = readl(usbmisc->base + data->index * 4);\n\t\twritel(val & ~MX6SX_BM_DPDM_WAKEUP_EN,\n\t\t\tusbmisc->base + data->index * 4);\n\t\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\t}\n\n\t \n\tif (data->hsic) {\n\t\tval = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET);\n\t\tval |= MX6SX_BM_HSIC_AUTO_RESUME;\n\t\twritel(val, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbmisc_vf610_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tu32 reg;\n\n\t \n\tif (data->index >= 1)\n\t\treturn -EINVAL;\n\n\tif (data->disable_oc) {\n\t\treg = readl(usbmisc->base);\n\t\twritel(reg | VF610_OVER_CUR_DIS, usbmisc->base);\n\t}\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx7d_set_wakeup\n\t(struct imx_usbmisc_data *data, bool enabled)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base);\n\tif (enabled) {\n\t\tval &= ~MX6_USB_OTG_WAKEUP_BITS;\n\t\tval |= usbmisc_wakeup_setting(data);\n\t\twritel(val, usbmisc->base);\n\t} else {\n\t\tif (val & MX6_BM_WAKEUP_INTR)\n\t\t\tdev_dbg(data->dev, \"wakeup int\\n\");\n\t\twritel(val & ~MX6_USB_OTG_WAKEUP_BITS, usbmisc->base);\n\t}\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx7d_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (data->index >= 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\treg = readl(usbmisc->base);\n\tif (data->disable_oc) {\n\t\treg |= MX6_BM_OVER_CUR_DIS;\n\t} else {\n\t\treg &= ~MX6_BM_OVER_CUR_DIS;\n\n\t\t \n\t\tif (data->oc_pol_configured && data->oc_pol_active_low)\n\t\t\treg |= MX6_BM_OVER_CUR_POLARITY;\n\t\telse if (data->oc_pol_configured)\n\t\t\treg &= ~MX6_BM_OVER_CUR_POLARITY;\n\t}\n\t \n\tif (data->pwr_pol == 1)\n\t\treg |= MX6_BM_PWR_POLARITY;\n\twritel(reg, usbmisc->base);\n\n\t \n\treg = readl(usbmisc->base);\n\twritel(reg | MX6_BM_NON_BURST_SETTING, usbmisc->base);\n\n\tif (!data->hsic) {\n\t\treg = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t\treg &= ~MX7D_USB_VBUS_WAKEUP_SOURCE_MASK;\n\t\twritel(reg | MX7D_USB_VBUS_WAKEUP_SOURCE_BVALID\n\t\t\t| MX7D_USBNC_AUTO_RESUME,\n\t\t\tusbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t\t \n\t\treg = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG1);\n\t\tif (data->emp_curr_control >= 0 &&\n\t\t\tdata->emp_curr_control <=\n\t\t\t(TXPREEMPAMPTUNE0_MASK >> TXPREEMPAMPTUNE0_BIT)) {\n\t\t\treg &= ~TXPREEMPAMPTUNE0_MASK;\n\t\t\treg |= (data->emp_curr_control << TXPREEMPAMPTUNE0_BIT);\n\t\t}\n\n\t\tif (data->dc_vol_level_adjust >= 0 &&\n\t\t\tdata->dc_vol_level_adjust <=\n\t\t\t(TXVREFTUNE0_MASK >> TXVREFTUNE0_BIT)) {\n\t\t\treg &= ~TXVREFTUNE0_MASK;\n\t\t\treg |= (data->dc_vol_level_adjust << TXVREFTUNE0_BIT);\n\t\t}\n\n\t\tif (data->rise_fall_time_adjust >= 0 &&\n\t\t\tdata->rise_fall_time_adjust <=\n\t\t\t(TXRISETUNE0_MASK >> TXRISETUNE0_BIT)) {\n\t\t\treg &= ~TXRISETUNE0_MASK;\n\t\t\treg |= (data->rise_fall_time_adjust << TXRISETUNE0_BIT);\n\t\t}\n\n\t\twritel(reg, usbmisc->base + MX7D_USB_OTG_PHY_CFG1);\n\t}\n\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tusbmisc_imx7d_set_wakeup(data, false);\n\n\treturn 0;\n}\n\nstatic int imx7d_charger_secondary_detection(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tstruct usb_phy *usb_phy = data->usb_phy;\n\tint val;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tval &= ~MX7D_USB_OTG_PHY_CFG2_CHRG_VDATSRCENB0;\n\twritel(val, usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\t \n\tmsleep(20);\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\twritel(val | MX7D_USB_OTG_PHY_CFG2_CHRG_VDATSRCENB0 |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_VDATDETENB0 |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_CHRGSEL,\n\t\t\t\tusbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\t \n\tmsleep(40);\n\n\t \n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_STATUS);\n\tif (val & MX7D_USB_OTG_PHY_STATUS_CHRGDET) {\n\t\tdev_dbg(data->dev, \"It is a dedicate charging port\\n\");\n\t\tusb_phy->chg_type = DCP_TYPE;\n\t} else {\n\t\tdev_dbg(data->dev, \"It is a charging downstream port\\n\");\n\t\tusb_phy->chg_type = CDP_TYPE;\n\t}\n\n\treturn 0;\n}\n\nstatic void imx7_disable_charger_detector(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tval &= ~(MX7D_USB_OTG_PHY_CFG2_CHRG_DCDENB |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_VDATSRCENB0 |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_VDATDETENB0 |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_CHRGSEL);\n\twritel(val, usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\n\t \n\tval = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\tval &= ~MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_MASK;\n\twritel(val, usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\n\tval = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\twritel(val & ~MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_EN,\n\t\t\tusbmisc->base + MX7D_USBNC_USB_CTRL2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n}\n\nstatic int imx7d_charger_data_contact_detect(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\tint i, data_pin_contact_count = 0;\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\twritel(val | MX7D_USB_OTG_PHY_CFG2_CHRG_DCDENB,\n\t\t\tusbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tfor (i = 0; i < 100; i = i + 1) {\n\t\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_STATUS);\n\t\tif (!(val & MX7D_USB_OTG_PHY_STATUS_LINE_STATE0)) {\n\t\t\tif (data_pin_contact_count++ > 5)\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tusleep_range(5000, 10000);\n\t\t} else {\n\t\t\tdata_pin_contact_count = 0;\n\t\t\tusleep_range(5000, 6000);\n\t\t}\n\t}\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\twritel(val & ~MX7D_USB_OTG_PHY_CFG2_CHRG_DCDENB,\n\t\t\tusbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tif (i == 100) {\n\t\tdev_err(data->dev,\n\t\t\t\"VBUS is coming from a dedicated power supply.\\n\");\n\t\treturn -ENXIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int imx7d_charger_primary_detection(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tstruct usb_phy *usb_phy = data->usb_phy;\n\tunsigned long flags;\n\tu32 val;\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tval &= ~MX7D_USB_OTG_PHY_CFG2_CHRG_CHRGSEL;\n\twritel(val | MX7D_USB_OTG_PHY_CFG2_CHRG_VDATSRCENB0 |\n\t\t\tMX7D_USB_OTG_PHY_CFG2_CHRG_VDATDETENB0,\n\t\t\t\tusbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\t \n\tmsleep(40);\n\n\t \n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_STATUS);\n\tif (!(val & MX7D_USB_OTG_PHY_STATUS_CHRGDET)) {\n\t\tdev_dbg(data->dev, \"It is a standard downstream port\\n\");\n\t\tusb_phy->chg_type = SDP_TYPE;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int imx7d_charger_detection(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tstruct usb_phy *usb_phy = data->usb_phy;\n\tunsigned long flags;\n\tu32 val;\n\tint ret;\n\n\t \n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_STATUS);\n\tif (!(val & MX7D_USB_OTG_PHY_STATUS_VBUS_VLD)) {\n\t\tdev_err(data->dev, \"vbus is error\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\tval &= ~MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_MASK;\n\tval |= MX7D_USBNC_USB_CTRL2_OPMODE_NON_DRIVING;\n\twritel(val, usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\n\tval = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\twritel(val | MX7D_USBNC_USB_CTRL2_OPMODE_OVERRIDE_EN,\n\t\t\tusbmisc->base + MX7D_USBNC_USB_CTRL2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tret = imx7d_charger_data_contact_detect(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = imx7d_charger_primary_detection(data);\n\tif (!ret && usb_phy->chg_type != SDP_TYPE)\n\t\tret = imx7d_charger_secondary_detection(data);\n\n\timx7_disable_charger_detector(data);\n\n\treturn ret;\n}\n\nstatic void usbmisc_imx7d_vbus_comparator_on(struct imx_usbmisc_data *data,\n\t\t\t\t\t     bool on)\n{\n\tunsigned long flags;\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tu32 val;\n\n\tif (data->hsic)\n\t\treturn;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\t \n\tval = readl(usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tif (on)\n\t\tval |= MX7D_USB_OTG_PHY_CFG2_DRVVBUS0;\n\telse\n\t\tval &= ~MX7D_USB_OTG_PHY_CFG2_DRVVBUS0;\n\n\twritel(val, usbmisc->base + MX7D_USB_OTG_PHY_CFG2);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n}\n\nstatic int usbmisc_imx7ulp_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 reg;\n\n\tif (data->index >= 1)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\treg = readl(usbmisc->base);\n\tif (data->disable_oc) {\n\t\treg |= MX6_BM_OVER_CUR_DIS;\n\t} else {\n\t\treg &= ~MX6_BM_OVER_CUR_DIS;\n\n\t\t \n\t\tif (data->oc_pol_configured && data->oc_pol_active_low)\n\t\t\treg |= MX6_BM_OVER_CUR_POLARITY;\n\t\telse if (data->oc_pol_configured)\n\t\t\treg &= ~MX6_BM_OVER_CUR_POLARITY;\n\t}\n\t \n\tif (data->pwr_pol == 1)\n\t\treg |= MX6_BM_PWR_POLARITY;\n\n\twritel(reg, usbmisc->base);\n\n\t \n\treg = readl(usbmisc->base);\n\twritel(reg | MX6_BM_NON_BURST_SETTING, usbmisc->base);\n\n\tif (data->hsic) {\n\t\treg = readl(usbmisc->base);\n\t\twritel(reg | MX6_BM_UTMI_ON_CLOCK, usbmisc->base);\n\n\t\treg = readl(usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET);\n\t\treg |= MX6_BM_HSIC_EN | MX6_BM_HSIC_CLK_ON;\n\t\twritel(reg, usbmisc->base + MX6_USB_HSIC_CTRL_OFFSET);\n\n\t\t \n\t\treg = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t\twritel(reg | MX7D_USBNC_AUTO_RESUME,\n\t\t\tusbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t} else {\n\t\treg = readl(usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t\treg &= ~MX7D_USB_VBUS_WAKEUP_SOURCE_MASK;\n\t\twritel(reg | MX7D_USB_VBUS_WAKEUP_SOURCE_BVALID,\n\t\t\t usbmisc->base + MX7D_USBNC_USB_CTRL2);\n\t}\n\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\n\tusbmisc_imx7d_set_wakeup(data, false);\n\n\treturn 0;\n}\n\nstatic int usbmisc_imx7d_power_lost_check(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\t \n\tif (val == 0x30001000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int usbmisc_imx6sx_power_lost_check(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&usbmisc->lock, flags);\n\tval = readl(usbmisc->base + data->index * 4);\n\tspin_unlock_irqrestore(&usbmisc->lock, flags);\n\t \n\tif (val == 0x30001000)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic const struct usbmisc_ops imx25_usbmisc_ops = {\n\t.init = usbmisc_imx25_init,\n\t.post = usbmisc_imx25_post,\n};\n\nstatic const struct usbmisc_ops imx27_usbmisc_ops = {\n\t.init = usbmisc_imx27_init,\n};\n\nstatic const struct usbmisc_ops imx51_usbmisc_ops = {\n\t.init = usbmisc_imx53_init,\n};\n\nstatic const struct usbmisc_ops imx53_usbmisc_ops = {\n\t.init = usbmisc_imx53_init,\n};\n\nstatic const struct usbmisc_ops imx6q_usbmisc_ops = {\n\t.set_wakeup = usbmisc_imx6q_set_wakeup,\n\t.init = usbmisc_imx6q_init,\n\t.hsic_set_connect = usbmisc_imx6_hsic_set_connect,\n\t.hsic_set_clk   = usbmisc_imx6_hsic_set_clk,\n};\n\nstatic const struct usbmisc_ops vf610_usbmisc_ops = {\n\t.init = usbmisc_vf610_init,\n};\n\nstatic const struct usbmisc_ops imx6sx_usbmisc_ops = {\n\t.set_wakeup = usbmisc_imx6q_set_wakeup,\n\t.init = usbmisc_imx6sx_init,\n\t.hsic_set_connect = usbmisc_imx6_hsic_set_connect,\n\t.hsic_set_clk = usbmisc_imx6_hsic_set_clk,\n\t.power_lost_check = usbmisc_imx6sx_power_lost_check,\n};\n\nstatic const struct usbmisc_ops imx7d_usbmisc_ops = {\n\t.init = usbmisc_imx7d_init,\n\t.set_wakeup = usbmisc_imx7d_set_wakeup,\n\t.charger_detection = imx7d_charger_detection,\n\t.power_lost_check = usbmisc_imx7d_power_lost_check,\n\t.vbus_comparator_on = usbmisc_imx7d_vbus_comparator_on,\n};\n\nstatic const struct usbmisc_ops imx7ulp_usbmisc_ops = {\n\t.init = usbmisc_imx7ulp_init,\n\t.set_wakeup = usbmisc_imx7d_set_wakeup,\n\t.hsic_set_connect = usbmisc_imx6_hsic_set_connect,\n\t.hsic_set_clk = usbmisc_imx6_hsic_set_clk,\n\t.power_lost_check = usbmisc_imx7d_power_lost_check,\n};\n\nstatic inline bool is_imx53_usbmisc(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc = dev_get_drvdata(data->dev);\n\n\treturn usbmisc->ops == &imx53_usbmisc_ops;\n}\n\nint imx_usbmisc_init(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc;\n\n\tif (!data)\n\t\treturn 0;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\tif (!usbmisc->ops->init)\n\t\treturn 0;\n\treturn usbmisc->ops->init(data);\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_init);\n\nint imx_usbmisc_init_post(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\tif (usbmisc->ops->post)\n\t\tret = usbmisc->ops->post(data);\n\tif (ret) {\n\t\tdev_err(data->dev, \"post init failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (usbmisc->ops->set_wakeup)\n\t\tret = usbmisc->ops->set_wakeup(data, false);\n\tif (ret) {\n\t\tdev_err(data->dev, \"set_wakeup failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_init_post);\n\nint imx_usbmisc_hsic_set_connect(struct imx_usbmisc_data *data)\n{\n\tstruct imx_usbmisc *usbmisc;\n\n\tif (!data)\n\t\treturn 0;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\tif (!usbmisc->ops->hsic_set_connect || !data->hsic)\n\t\treturn 0;\n\treturn usbmisc->ops->hsic_set_connect(data);\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_hsic_set_connect);\n\nint imx_usbmisc_charger_detection(struct imx_usbmisc_data *data, bool connect)\n{\n\tstruct imx_usbmisc *usbmisc;\n\tstruct usb_phy *usb_phy;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\tusb_phy = data->usb_phy;\n\tif (!usbmisc->ops->charger_detection)\n\t\treturn -ENOTSUPP;\n\n\tif (connect) {\n\t\tret = usbmisc->ops->charger_detection(data);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev,\n\t\t\t\t\t\"Error occurs during detection: %d\\n\",\n\t\t\t\t\tret);\n\t\t\tusb_phy->chg_state = USB_CHARGER_ABSENT;\n\t\t} else {\n\t\t\tusb_phy->chg_state = USB_CHARGER_PRESENT;\n\t\t}\n\t} else {\n\t\tusb_phy->chg_state = USB_CHARGER_ABSENT;\n\t\tusb_phy->chg_type = UNKNOWN_TYPE;\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_charger_detection);\n\nint imx_usbmisc_suspend(struct imx_usbmisc_data *data, bool wakeup)\n{\n\tstruct imx_usbmisc *usbmisc;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\n\tif (usbmisc->ops->vbus_comparator_on)\n\t\tusbmisc->ops->vbus_comparator_on(data, false);\n\n\tif (wakeup && usbmisc->ops->set_wakeup)\n\t\tret = usbmisc->ops->set_wakeup(data, true);\n\tif (ret) {\n\t\tdev_err(data->dev, \"set_wakeup failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (usbmisc->ops->hsic_set_clk && data->hsic)\n\t\tret = usbmisc->ops->hsic_set_clk(data, false);\n\tif (ret) {\n\t\tdev_err(data->dev, \"set_wakeup failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_suspend);\n\nint imx_usbmisc_resume(struct imx_usbmisc_data *data, bool wakeup)\n{\n\tstruct imx_usbmisc *usbmisc;\n\tint ret = 0;\n\n\tif (!data)\n\t\treturn 0;\n\n\tusbmisc = dev_get_drvdata(data->dev);\n\n\tif (usbmisc->ops->power_lost_check)\n\t\tret = usbmisc->ops->power_lost_check(data);\n\tif (ret > 0) {\n\t\t \n\t\tret = imx_usbmisc_init(data);\n\t\tif (ret) {\n\t\t\tdev_err(data->dev, \"re-init failed, ret=%d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (wakeup && usbmisc->ops->set_wakeup)\n\t\tret = usbmisc->ops->set_wakeup(data, false);\n\tif (ret) {\n\t\tdev_err(data->dev, \"set_wakeup failed, ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (usbmisc->ops->hsic_set_clk && data->hsic)\n\t\tret = usbmisc->ops->hsic_set_clk(data, true);\n\tif (ret) {\n\t\tdev_err(data->dev, \"set_wakeup failed, ret=%d\\n\", ret);\n\t\tgoto hsic_set_clk_fail;\n\t}\n\n\tif (usbmisc->ops->vbus_comparator_on)\n\t\tusbmisc->ops->vbus_comparator_on(data, true);\n\n\treturn 0;\n\nhsic_set_clk_fail:\n\tif (wakeup && usbmisc->ops->set_wakeup)\n\t\tusbmisc->ops->set_wakeup(data, true);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(imx_usbmisc_resume);\n\nstatic const struct of_device_id usbmisc_imx_dt_ids[] = {\n\t{\n\t\t.compatible = \"fsl,imx25-usbmisc\",\n\t\t.data = &imx25_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx35-usbmisc\",\n\t\t.data = &imx25_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx27-usbmisc\",\n\t\t.data = &imx27_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx51-usbmisc\",\n\t\t.data = &imx51_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx53-usbmisc\",\n\t\t.data = &imx53_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx6q-usbmisc\",\n\t\t.data = &imx6q_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,vf610-usbmisc\",\n\t\t.data = &vf610_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx6sx-usbmisc\",\n\t\t.data = &imx6sx_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx6ul-usbmisc\",\n\t\t.data = &imx6sx_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx7d-usbmisc\",\n\t\t.data = &imx7d_usbmisc_ops,\n\t},\n\t{\n\t\t.compatible = \"fsl,imx7ulp-usbmisc\",\n\t\t.data = &imx7ulp_usbmisc_ops,\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, usbmisc_imx_dt_ids);\n\nstatic int usbmisc_imx_probe(struct platform_device *pdev)\n{\n\tstruct imx_usbmisc *data;\n\n\tdata = devm_kzalloc(&pdev->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&data->lock);\n\n\tdata->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(data->base))\n\t\treturn PTR_ERR(data->base);\n\n\tdata->ops = of_device_get_match_data(&pdev->dev);\n\tplatform_set_drvdata(pdev, data);\n\n\treturn 0;\n}\n\nstatic struct platform_driver usbmisc_imx_driver = {\n\t.probe = usbmisc_imx_probe,\n\t.driver = {\n\t\t.name = \"usbmisc_imx\",\n\t\t.of_match_table = usbmisc_imx_dt_ids,\n\t },\n};\n\nmodule_platform_driver(usbmisc_imx_driver);\n\nMODULE_ALIAS(\"platform:usbmisc-imx\");\nMODULE_LICENSE(\"GPL\");\nMODULE_DESCRIPTION(\"driver for imx usb non-core registers\");\nMODULE_AUTHOR(\"Richard Zhao <richard.zhao@freescale.com>\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}