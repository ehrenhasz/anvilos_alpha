{
  "module_name": "host.c",
  "hash_id": "e7e8222a4fed6b682cb34b4ea32f10e3bdd2054510cc2aa32563d456e506b7b9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/host.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/chipidea.h>\n#include <linux/regulator/consumer.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"../host/ehci.h\"\n\n#include \"ci.h\"\n#include \"bits.h\"\n#include \"host.h\"\n\nstatic struct hc_driver __read_mostly ci_ehci_hc_driver;\nstatic int (*orig_bus_suspend)(struct usb_hcd *hcd);\n\nstruct ehci_ci_priv {\n\tstruct regulator *reg_vbus;\n\tbool enabled;\n};\n\nstruct ci_hdrc_dma_aligned_buffer {\n\tvoid *original_buffer;\n\tu8 data[];\n};\n\nstatic int ehci_ci_portpower(struct usb_hcd *hcd, int portnum, bool enable)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tstruct ehci_ci_priv *priv = (struct ehci_ci_priv *)ehci->priv;\n\tstruct device *dev = hcd->self.controller;\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tint ret = 0;\n\tint port = HCS_N_PORTS(ehci->hcs_params);\n\n\tif (priv->reg_vbus && enable != priv->enabled) {\n\t\tif (port > 1) {\n\t\t\tdev_warn(dev,\n\t\t\t\t\"Not support multi-port regulator control\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (enable)\n\t\t\tret = regulator_enable(priv->reg_vbus);\n\t\telse\n\t\t\tret = regulator_disable(priv->reg_vbus);\n\t\tif (ret) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"Failed to %s vbus regulator, ret=%d\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tpriv->enabled = enable;\n\t}\n\n\tif (ci->platdata->flags & CI_HDRC_PHY_VBUS_CONTROL) {\n\t\tif (enable)\n\t\t\tusb_phy_vbus_on(ci->usb_phy);\n\t\telse\n\t\t\tusb_phy_vbus_off(ci->usb_phy);\n\t}\n\n\tif (enable && (ci->platdata->phy_mode == USBPHY_INTERFACE_MODE_HSIC)) {\n\t\t \n\t\thw_port_test_set(ci, 5);\n\t\thw_port_test_set(ci, 0);\n\t}\n\treturn 0;\n};\n\nstatic int ehci_ci_reset(struct usb_hcd *hcd)\n{\n\tstruct device *dev = hcd->self.controller;\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tint ret;\n\n\tret = ehci_setup(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\tehci->need_io_watchdog = 0;\n\n\tif (ci->platdata->notify_event) {\n\t\tret = ci->platdata->notify_event(ci,\n\t\t\t\tCI_HDRC_CONTROLLER_RESET_EVENT);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tci_platform_configure(ci);\n\n\treturn ret;\n}\n\nstatic const struct ehci_driver_overrides ehci_ci_overrides = {\n\t.extra_priv_size = sizeof(struct ehci_ci_priv),\n\t.port_power\t = ehci_ci_portpower,\n\t.reset\t\t = ehci_ci_reset,\n};\n\nstatic irqreturn_t host_irq(struct ci_hdrc *ci)\n{\n\treturn usb_hcd_irq(ci->irq, ci->hcd);\n}\n\nstatic int host_start(struct ci_hdrc *ci)\n{\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tstruct ehci_ci_priv *priv;\n\tint ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = __usb_create_hcd(&ci_ehci_hc_driver, ci->dev->parent,\n\t\t\t       ci->dev, dev_name(ci->dev), NULL);\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(ci->dev, ci);\n\thcd->rsrc_start = ci->hw_bank.phys;\n\thcd->rsrc_len = ci->hw_bank.size;\n\thcd->regs = ci->hw_bank.abs;\n\thcd->has_tt = 1;\n\n\thcd->power_budget = ci->platdata->power_budget;\n\thcd->tpl_support = ci->platdata->tpl_support;\n\tif (ci->phy || ci->usb_phy) {\n\t\thcd->skip_phy_initialization = 1;\n\t\tif (ci->usb_phy)\n\t\t\thcd->usb_phy = ci->usb_phy;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = ci->hw_bank.cap;\n\tehci->has_hostpc = ci->hw_bank.lpm;\n\tehci->has_tdi_phy_lpm = ci->hw_bank.lpm;\n\tehci->imx28_write_fix = ci->imx28_write_fix;\n\tehci->has_ci_pec_bug = ci->has_portsc_pec_bug;\n\n\tpriv = (struct ehci_ci_priv *)ehci->priv;\n\tpriv->reg_vbus = NULL;\n\n\tif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci)) {\n\t\tif (ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON) {\n\t\t\tret = regulator_enable(ci->platdata->reg_vbus);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(ci->dev,\n\t\t\t\t\"Failed to enable vbus regulator, ret=%d\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t\t\t\tgoto put_hcd;\n\t\t\t}\n\t\t} else {\n\t\t\tpriv->reg_vbus = ci->platdata->reg_vbus;\n\t\t}\n\t}\n\n\tif (ci->platdata->pins_host)\n\t\tpinctrl_select_state(ci->platdata->pctl,\n\t\t\t\t     ci->platdata->pins_host);\n\n\tci->hcd = hcd;\n\n\tret = usb_add_hcd(hcd, 0, 0);\n\tif (ret) {\n\t\tci->hcd = NULL;\n\t\tgoto disable_reg;\n\t} else {\n\t\tstruct usb_otg *otg = &ci->otg;\n\n\t\tif (ci_otg_is_fsm_mode(ci)) {\n\t\t\totg->host = &hcd->self;\n\t\t\thcd->self.otg_port = 1;\n\t\t}\n\n\t\tif (ci->platdata->notify_event &&\n\t\t\t(ci->platdata->flags & CI_HDRC_IMX_IS_HSIC))\n\t\t\tci->platdata->notify_event\n\t\t\t\t(ci, CI_HDRC_IMX_HSIC_ACTIVE_EVENT);\n\t}\n\n\treturn ret;\n\ndisable_reg:\n\tif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&\n\t\t\t(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))\n\t\tregulator_disable(ci->platdata->reg_vbus);\nput_hcd:\n\tusb_put_hcd(hcd);\n\n\treturn ret;\n}\n\nstatic void host_stop(struct ci_hdrc *ci)\n{\n\tstruct usb_hcd *hcd = ci->hcd;\n\n\tif (hcd) {\n\t\tif (ci->platdata->notify_event)\n\t\t\tci->platdata->notify_event(ci,\n\t\t\t\tCI_HDRC_CONTROLLER_STOPPED_EVENT);\n\t\tusb_remove_hcd(hcd);\n\t\tci->role = CI_ROLE_END;\n\t\tsynchronize_irq(ci->irq);\n\t\tusb_put_hcd(hcd);\n\t\tif (ci->platdata->reg_vbus && !ci_otg_is_fsm_mode(ci) &&\n\t\t\t(ci->platdata->flags & CI_HDRC_TURN_VBUS_EARLY_ON))\n\t\t\t\tregulator_disable(ci->platdata->reg_vbus);\n\t}\n\tci->hcd = NULL;\n\tci->otg.host = NULL;\n\n\tif (ci->platdata->pins_host && ci->platdata->pins_default)\n\t\tpinctrl_select_state(ci->platdata->pctl,\n\t\t\t\t     ci->platdata->pins_default);\n}\n\n\nvoid ci_hdrc_host_destroy(struct ci_hdrc *ci)\n{\n\tif (ci->role == CI_ROLE_HOST && ci->hcd)\n\t\thost_stop(ci);\n}\n\n \nstatic int ci_ehci_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength\n)\n{\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci(hcd);\n\tunsigned int\tports = HCS_N_PORTS(ehci->hcs_params);\n\tu32 __iomem\t*status_reg;\n\tu32\t\ttemp, port_index;\n\tunsigned long\tflags;\n\tint\t\tretval = 0;\n\tbool\t\tdone = false;\n\tstruct device *dev = hcd->self.controller;\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\n\tport_index = wIndex & 0xff;\n\tport_index -= (port_index > 0);\n\tstatus_reg = &ehci->regs->port_status[port_index];\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\n\tif (ci->platdata->hub_control) {\n\t\tretval = ci->platdata->hub_control(ci, typeReq, wValue, wIndex,\n\t\t\t\t\t\t   buf, wLength, &done, &flags);\n\t\tif (done)\n\t\t\tgoto done;\n\t}\n\n\tif (typeReq == SetPortFeature && wValue == USB_PORT_FEAT_SUSPEND) {\n\t\tif (!wIndex || wIndex > ports) {\n\t\t\tretval = -EPIPE;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttemp = ehci_readl(ehci, status_reg);\n\t\tif ((temp & PORT_PE) == 0 || (temp & PORT_RESET) != 0) {\n\t\t\tretval = -EPIPE;\n\t\t\tgoto done;\n\t\t}\n\n\t\ttemp &= ~(PORT_RWC_BITS | PORT_WKCONN_E);\n\t\ttemp |= PORT_WKDISC_E | PORT_WKOC_E;\n\t\tehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\n\n\t\t \n\t\tif (ehci_handshake(ehci, status_reg, PORT_SUSPEND,\n\t\t\tPORT_SUSPEND, 5000))\n\t\t\tehci_err(ehci, \"timeout waiting for SUSPEND\\n\");\n\n\t\tif (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC) {\n\t\t\tif (ci->platdata->notify_event)\n\t\t\t\tci->platdata->notify_event(ci,\n\t\t\t\t\tCI_HDRC_IMX_HSIC_SUSPEND_EVENT);\n\n\t\t\ttemp = ehci_readl(ehci, status_reg);\n\t\t\ttemp &= ~(PORT_WKDISC_E | PORT_WKCONN_E);\n\t\t\tehci_writel(ehci, temp, status_reg);\n\t\t}\n\n\t\tset_bit(port_index, &ehci->suspended_ports);\n\t\tgoto done;\n\t}\n\n\t \n\telse if (typeReq == ClearPortFeature &&\n\t\twValue == USB_PORT_FEAT_C_SUSPEND) {\n\t\t \n\t\tif (ehci_handshake(ehci, status_reg, PORT_RESUME, 0, 25000))\n\t\t\tehci_err(ehci, \"timeout waiting for resume\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\n\t \n\treturn ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\ndone:\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\treturn retval;\n}\nstatic int ci_ehci_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tstruct device *dev = hcd->self.controller;\n\tstruct ci_hdrc *ci = dev_get_drvdata(dev);\n\tint port;\n\tu32 tmp;\n\n\tint ret = orig_bus_suspend(hcd);\n\n\tif (ret)\n\t\treturn ret;\n\n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tu32 __iomem *reg = &ehci->regs->port_status[port];\n\t\tu32 portsc = ehci_readl(ehci, reg);\n\n\t\tif (portsc & PORT_CONNECT) {\n\t\t\t \n\n\t\t\ttmp = ehci_readl(ehci, &ehci->regs->command);\n\t\t\ttmp |= CMD_RUN;\n\t\t\tehci_writel(ehci, tmp, &ehci->regs->command);\n\t\t\t \n\t\t\tusleep_range(150, 200);\n\t\t\t \n\t\t\tif (ci->platdata->flags & CI_HDRC_IMX_IS_HSIC) {\n\t\t\t\ttmp = ehci_readl(ehci, reg);\n\t\t\t\ttmp &= ~(PORT_WKDISC_E | PORT_WKCONN_E);\n\t\t\t\tehci_writel(ehci, tmp, reg);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ci_hdrc_free_dma_aligned_buffer(struct urb *urb, bool copy_back)\n{\n\tstruct ci_hdrc_dma_aligned_buffer *temp;\n\n\tif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\n\t\treturn;\n\turb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\n\n\ttemp = container_of(urb->transfer_buffer,\n\t\t\t    struct ci_hdrc_dma_aligned_buffer, data);\n\turb->transfer_buffer = temp->original_buffer;\n\n\tif (copy_back && usb_urb_dir_in(urb)) {\n\t\tsize_t length;\n\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tlength = urb->transfer_buffer_length;\n\t\telse\n\t\t\tlength = urb->actual_length;\n\n\t\tmemcpy(temp->original_buffer, temp->data, length);\n\t}\n\n\tkfree(temp);\n}\n\nstatic int ci_hdrc_alloc_dma_aligned_buffer(struct urb *urb, gfp_t mem_flags)\n{\n\tstruct ci_hdrc_dma_aligned_buffer *temp;\n\n\tif (urb->num_sgs || urb->sg || urb->transfer_buffer_length == 0)\n\t\treturn 0;\n\tif (IS_ALIGNED((uintptr_t)urb->transfer_buffer, 4)\n\t    && IS_ALIGNED(urb->transfer_buffer_length, 4))\n\t\treturn 0;\n\n\ttemp = kmalloc(sizeof(*temp) + ALIGN(urb->transfer_buffer_length, 4), mem_flags);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\tif (usb_urb_dir_out(urb))\n\t\tmemcpy(temp->data, urb->transfer_buffer,\n\t\t       urb->transfer_buffer_length);\n\n\ttemp->original_buffer = urb->transfer_buffer;\n\turb->transfer_buffer = temp->data;\n\turb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\n\n\treturn 0;\n}\n\nstatic int ci_hdrc_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t   gfp_t mem_flags)\n{\n\tint ret;\n\n\tret = ci_hdrc_alloc_dma_aligned_buffer(urb, mem_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n\tif (ret)\n\t\tci_hdrc_free_dma_aligned_buffer(urb, false);\n\n\treturn ret;\n}\n\nstatic void ci_hdrc_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n\tci_hdrc_free_dma_aligned_buffer(urb, true);\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic void ci_hdrc_host_suspend(struct ci_hdrc *ci)\n{\n\tehci_suspend(ci->hcd, device_may_wakeup(ci->dev));\n}\n\nstatic void ci_hdrc_host_resume(struct ci_hdrc *ci, bool power_lost)\n{\n\tehci_resume(ci->hcd, power_lost);\n}\n#endif\n\nint ci_hdrc_host_init(struct ci_hdrc *ci)\n{\n\tstruct ci_role_driver *rdrv;\n\n\tif (!hw_read(ci, CAP_DCCPARAMS, DCCPARAMS_HC))\n\t\treturn -ENXIO;\n\n\trdrv = devm_kzalloc(ci->dev, sizeof(struct ci_role_driver), GFP_KERNEL);\n\tif (!rdrv)\n\t\treturn -ENOMEM;\n\n\trdrv->start\t= host_start;\n\trdrv->stop\t= host_stop;\n#ifdef CONFIG_PM_SLEEP\n\trdrv->suspend\t= ci_hdrc_host_suspend;\n\trdrv->resume\t= ci_hdrc_host_resume;\n#endif\n\trdrv->irq\t= host_irq;\n\trdrv->name\t= \"host\";\n\tci->roles[CI_ROLE_HOST] = rdrv;\n\n\tif (ci->platdata->flags & CI_HDRC_REQUIRES_ALIGNED_DMA) {\n\t\tci_ehci_hc_driver.map_urb_for_dma = ci_hdrc_map_urb_for_dma;\n\t\tci_ehci_hc_driver.unmap_urb_for_dma = ci_hdrc_unmap_urb_for_dma;\n\t}\n\n\treturn 0;\n}\n\nvoid ci_hdrc_host_driver_init(void)\n{\n\tehci_init_driver(&ci_ehci_hc_driver, &ehci_ci_overrides);\n\torig_bus_suspend = ci_ehci_hc_driver.bus_suspend;\n\tci_ehci_hc_driver.bus_suspend = ci_ehci_bus_suspend;\n\tci_ehci_hc_driver.hub_control = ci_ehci_hub_control;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}