{
  "module_name": "ci_hdrc_msm.c",
  "hash_id": "ba15ca62737fd702b0dc1a18467c6b91386e10d773b2b917c70813c9e1bd65e4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/chipidea/ci_hdrc_msm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/usb/chipidea.h>\n#include <linux/clk.h>\n#include <linux/reset.h>\n#include <linux/mfd/syscon.h>\n#include <linux/regmap.h>\n#include <linux/io.h>\n#include <linux/reset-controller.h>\n#include <linux/extcon.h>\n#include <linux/of.h>\n\n#include \"ci.h\"\n\n#define HS_PHY_AHB_MODE\t\t\t0x0098\n\n#define HS_PHY_GENCONFIG\t\t0x009c\n#define HS_PHY_TXFIFO_IDLE_FORCE_DIS\tBIT(4)\n\n#define HS_PHY_GENCONFIG_2\t\t0x00a0\n#define HS_PHY_SESS_VLD_CTRL_EN\t\tBIT(7)\n#define HS_PHY_ULPI_TX_PKT_EN_CLR_FIX\tBIT(19)\n\n#define HSPHY_SESS_VLD_CTRL\t\tBIT(25)\n\n \n#define HS_PHY_CTRL\t\t\t0x0040\n#define HS_PHY_SEC_CTRL\t\t\t0x0078\n#define HS_PHY_DIG_CLAMP_N\t\tBIT(16)\n#define HS_PHY_POR_ASSERT\t\tBIT(0)\n\nstruct ci_hdrc_msm {\n\tstruct platform_device *ci;\n\tstruct clk *core_clk;\n\tstruct clk *iface_clk;\n\tstruct clk *fs_clk;\n\tstruct ci_hdrc_platform_data pdata;\n\tstruct reset_controller_dev rcdev;\n\tbool secondary_phy;\n\tbool hsic;\n\tvoid __iomem *base;\n};\n\nstatic int\nci_hdrc_msm_por_reset(struct reset_controller_dev *r, unsigned long id)\n{\n\tstruct ci_hdrc_msm *ci_msm = container_of(r, struct ci_hdrc_msm, rcdev);\n\tvoid __iomem *addr = ci_msm->base;\n\tu32 val;\n\n\tif (id)\n\t\taddr += HS_PHY_SEC_CTRL;\n\telse\n\t\taddr += HS_PHY_CTRL;\n\n\tval = readl_relaxed(addr);\n\tval |= HS_PHY_POR_ASSERT;\n\twritel(val, addr);\n\t \n\tudelay(12);\n\tval &= ~HS_PHY_POR_ASSERT;\n\twritel(val, addr);\n\n\treturn 0;\n}\n\nstatic const struct reset_control_ops ci_hdrc_msm_reset_ops = {\n\t.reset = ci_hdrc_msm_por_reset,\n};\n\nstatic int ci_hdrc_msm_notify_event(struct ci_hdrc *ci, unsigned event)\n{\n\tstruct device *dev = ci->dev->parent;\n\tstruct ci_hdrc_msm *msm_ci = dev_get_drvdata(dev);\n\tint ret;\n\n\tswitch (event) {\n\tcase CI_HDRC_CONTROLLER_RESET_EVENT:\n\t\tdev_dbg(dev, \"CI_HDRC_CONTROLLER_RESET_EVENT received\\n\");\n\n\t\thw_phymode_configure(ci);\n\t\tif (msm_ci->secondary_phy) {\n\t\t\tu32 val = readl_relaxed(msm_ci->base + HS_PHY_SEC_CTRL);\n\t\t\tval |= HS_PHY_DIG_CLAMP_N;\n\t\t\twritel_relaxed(val, msm_ci->base + HS_PHY_SEC_CTRL);\n\t\t}\n\n\t\tret = phy_init(ci->phy);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = phy_power_on(ci->phy);\n\t\tif (ret) {\n\t\t\tphy_exit(ci->phy);\n\t\t\treturn ret;\n\t\t}\n\n\t\t \n\t\thw_write_id_reg(ci, HS_PHY_AHB_MODE, 0xffffffff, 0x8);\n\n\t\t \n\t\thw_write_id_reg(ci, HS_PHY_GENCONFIG,\n\t\t\t\tHS_PHY_TXFIFO_IDLE_FORCE_DIS, 0);\n\n\t\tif (!msm_ci->hsic)\n\t\t\thw_write_id_reg(ci, HS_PHY_GENCONFIG_2,\n\t\t\t\t\tHS_PHY_ULPI_TX_PKT_EN_CLR_FIX, 0);\n\n\t\tif (!IS_ERR(ci->platdata->vbus_extcon.edev) || ci->role_switch) {\n\t\t\thw_write_id_reg(ci, HS_PHY_GENCONFIG_2,\n\t\t\t\t\tHS_PHY_SESS_VLD_CTRL_EN,\n\t\t\t\t\tHS_PHY_SESS_VLD_CTRL_EN);\n\t\t\thw_write(ci, OP_USBCMD, HSPHY_SESS_VLD_CTRL,\n\t\t\t\t HSPHY_SESS_VLD_CTRL);\n\n\t\t}\n\t\tbreak;\n\tcase CI_HDRC_CONTROLLER_STOPPED_EVENT:\n\t\tdev_dbg(dev, \"CI_HDRC_CONTROLLER_STOPPED_EVENT received\\n\");\n\t\tphy_power_off(ci->phy);\n\t\tphy_exit(ci->phy);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"unknown ci_hdrc event\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_hdrc_msm_mux_phy(struct ci_hdrc_msm *ci,\n\t\t\t       struct platform_device *pdev)\n{\n\tstruct regmap *regmap;\n\tstruct device *dev = &pdev->dev;\n\tstruct of_phandle_args args;\n\tu32 val;\n\tint ret;\n\n\tret = of_parse_phandle_with_fixed_args(dev->of_node, \"phy-select\", 2, 0,\n\t\t\t\t\t       &args);\n\tif (ret)\n\t\treturn 0;\n\n\tregmap = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tif (IS_ERR(regmap))\n\t\treturn PTR_ERR(regmap);\n\n\tret = regmap_write(regmap, args.args[0], args.args[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tci->secondary_phy = !!args.args[1];\n\tif (ci->secondary_phy) {\n\t\tval = readl_relaxed(ci->base + HS_PHY_SEC_CTRL);\n\t\tval |= HS_PHY_DIG_CLAMP_N;\n\t\twritel_relaxed(val, ci->base + HS_PHY_SEC_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int ci_hdrc_msm_probe(struct platform_device *pdev)\n{\n\tstruct ci_hdrc_msm *ci;\n\tstruct platform_device *plat_ci;\n\tstruct clk *clk;\n\tstruct reset_control *reset;\n\tint ret;\n\tstruct device_node *ulpi_node, *phy_node;\n\n\tdev_dbg(&pdev->dev, \"ci_hdrc_msm_probe\\n\");\n\n\tci = devm_kzalloc(&pdev->dev, sizeof(*ci), GFP_KERNEL);\n\tif (!ci)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, ci);\n\n\tci->pdata.name = \"ci_hdrc_msm\";\n\tci->pdata.capoffset = DEF_CAPOFFSET;\n\tci->pdata.flags\t= CI_HDRC_REGS_SHARED | CI_HDRC_DISABLE_STREAMING |\n\t\t\t  CI_HDRC_OVERRIDE_AHB_BURST |\n\t\t\t  CI_HDRC_OVERRIDE_PHY_CONTROL;\n\tci->pdata.notify_event = ci_hdrc_msm_notify_event;\n\n\treset = devm_reset_control_get(&pdev->dev, \"core\");\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\n\tci->core_clk = clk = devm_clk_get(&pdev->dev, \"core\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tci->iface_clk = clk = devm_clk_get(&pdev->dev, \"iface\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tci->fs_clk = clk = devm_clk_get_optional(&pdev->dev, \"fs\");\n\tif (IS_ERR(clk))\n\t\treturn PTR_ERR(clk);\n\n\tci->base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(ci->base))\n\t\treturn PTR_ERR(ci->base);\n\n\tci->rcdev.owner = THIS_MODULE;\n\tci->rcdev.ops = &ci_hdrc_msm_reset_ops;\n\tci->rcdev.of_node = pdev->dev.of_node;\n\tci->rcdev.nr_resets = 2;\n\tret = devm_reset_controller_register(&pdev->dev, &ci->rcdev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ci->fs_clk);\n\tif (ret)\n\t\treturn ret;\n\n\treset_control_assert(reset);\n\tusleep_range(10000, 12000);\n\treset_control_deassert(reset);\n\n\tclk_disable_unprepare(ci->fs_clk);\n\n\tret = clk_prepare_enable(ci->core_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = clk_prepare_enable(ci->iface_clk);\n\tif (ret)\n\t\tgoto err_iface;\n\n\tret = ci_hdrc_msm_mux_phy(ci, pdev);\n\tif (ret)\n\t\tgoto err_mux;\n\n\tulpi_node = of_get_child_by_name(pdev->dev.of_node, \"ulpi\");\n\tif (ulpi_node) {\n\t\tphy_node = of_get_next_available_child(ulpi_node, NULL);\n\t\tci->hsic = of_device_is_compatible(phy_node, \"qcom,usb-hsic-phy\");\n\t\tof_node_put(phy_node);\n\t}\n\tof_node_put(ulpi_node);\n\n\tplat_ci = ci_hdrc_add_device(&pdev->dev, pdev->resource,\n\t\t\t\t     pdev->num_resources, &ci->pdata);\n\tif (IS_ERR(plat_ci)) {\n\t\tret = PTR_ERR(plat_ci);\n\t\tif (ret != -EPROBE_DEFER)\n\t\t\tdev_err(&pdev->dev, \"ci_hdrc_add_device failed!\\n\");\n\t\tgoto err_mux;\n\t}\n\n\tci->ci = plat_ci;\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_no_callbacks(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\n\treturn 0;\n\nerr_mux:\n\tclk_disable_unprepare(ci->iface_clk);\nerr_iface:\n\tclk_disable_unprepare(ci->core_clk);\n\treturn ret;\n}\n\nstatic void ci_hdrc_msm_remove(struct platform_device *pdev)\n{\n\tstruct ci_hdrc_msm *ci = platform_get_drvdata(pdev);\n\n\tpm_runtime_disable(&pdev->dev);\n\tci_hdrc_remove_device(ci->ci);\n\tclk_disable_unprepare(ci->iface_clk);\n\tclk_disable_unprepare(ci->core_clk);\n}\n\nstatic const struct of_device_id msm_ci_dt_match[] = {\n\t{ .compatible = \"qcom,ci-hdrc\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, msm_ci_dt_match);\n\nstatic struct platform_driver ci_hdrc_msm_driver = {\n\t.probe = ci_hdrc_msm_probe,\n\t.remove_new = ci_hdrc_msm_remove,\n\t.driver = {\n\t\t.name = \"msm_hsusb\",\n\t\t.of_match_table = msm_ci_dt_match,\n\t},\n};\n\nmodule_platform_driver(ci_hdrc_msm_driver);\n\nMODULE_ALIAS(\"platform:msm_hsusb\");\nMODULE_ALIAS(\"platform:ci13xxx_msm\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}