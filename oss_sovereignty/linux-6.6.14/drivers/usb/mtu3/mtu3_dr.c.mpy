{
  "module_name": "mtu3_dr.c",
  "hash_id": "a90490991e53f56b299b60a256c38c15756d510357743a4ab0921dc2abccad10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_dr.c",
  "human_readable_source": "\n \n\n#include \"mtu3.h\"\n#include \"mtu3_dr.h\"\n#include \"mtu3_debug.h\"\n\n#define USB2_PORT 2\n#define USB3_PORT 3\n\nstatic inline struct ssusb_mtk *otg_sx_to_ssusb(struct otg_switch_mtk *otg_sx)\n{\n\treturn container_of(otg_sx, struct ssusb_mtk, otg_switch);\n}\n\nstatic void toggle_opstate(struct ssusb_mtk *ssusb)\n{\n\tmtu3_setbits(ssusb->mac_base, U3D_DEVICE_CONTROL, DC_SESSION);\n\tmtu3_setbits(ssusb->mac_base, U3D_POWER_MANAGEMENT, SOFT_CONN);\n}\n\n \nstatic int ssusb_port0_switch(struct ssusb_mtk *ssusb,\n\tint version, bool tohost)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tu32 value;\n\n\tdev_dbg(ssusb->dev, \"%s (switch u%d port0 to %s)\\n\", __func__,\n\t\tversion, tohost ? \"host\" : \"device\");\n\n\tif (version == USB2_PORT) {\n\t\t \n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(0));\n\t\tvalue |= SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS;\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(0), value);\n\n\t\t \n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(0));\n\t\tvalue &= ~(SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS);\n\t\tvalue = tohost ? (value | SSUSB_U2_PORT_HOST_SEL) :\n\t\t\t(value & (~SSUSB_U2_PORT_HOST_SEL));\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(0), value);\n\t} else {\n\t\t \n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(0));\n\t\tvalue |= SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS;\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(0), value);\n\n\t\t \n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(0));\n\t\tvalue &= ~(SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS);\n\t\tvalue = tohost ? (value | SSUSB_U3_PORT_HOST_SEL) :\n\t\t\t(value & (~SSUSB_U3_PORT_HOST_SEL));\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(0), value);\n\t}\n\n\treturn 0;\n}\n\nstatic void switch_port_to_host(struct ssusb_mtk *ssusb)\n{\n\tu32 check_clk = 0;\n\n\tdev_dbg(ssusb->dev, \"%s\\n\", __func__);\n\n\tssusb_port0_switch(ssusb, USB2_PORT, true);\n\n\tif (ssusb->otg_switch.is_u3_drd) {\n\t\tssusb_port0_switch(ssusb, USB3_PORT, true);\n\t\tcheck_clk = SSUSB_U3_MAC_RST_B_STS;\n\t}\n\n\tssusb_check_clocks(ssusb, check_clk);\n\n\t \n\ttoggle_opstate(ssusb);\n}\n\nstatic void switch_port_to_device(struct ssusb_mtk *ssusb)\n{\n\tu32 check_clk = 0;\n\n\tdev_dbg(ssusb->dev, \"%s\\n\", __func__);\n\n\tssusb_port0_switch(ssusb, USB2_PORT, false);\n\n\tif (ssusb->otg_switch.is_u3_drd) {\n\t\tssusb_port0_switch(ssusb, USB3_PORT, false);\n\t\tcheck_clk = SSUSB_U3_MAC_RST_B_STS;\n\t}\n\n\tssusb_check_clocks(ssusb, check_clk);\n}\n\nint ssusb_set_vbus(struct otg_switch_mtk *otg_sx, int is_on)\n{\n\tstruct ssusb_mtk *ssusb = otg_sx_to_ssusb(otg_sx);\n\tstruct regulator *vbus = otg_sx->vbus;\n\tint ret;\n\n\t \n\tif (!vbus)\n\t\treturn 0;\n\n\tdev_dbg(ssusb->dev, \"%s: turn %s\\n\", __func__, is_on ? \"on\" : \"off\");\n\n\tif (is_on) {\n\t\tret = regulator_enable(vbus);\n\t\tif (ret) {\n\t\t\tdev_err(ssusb->dev, \"vbus regulator enable failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tregulator_disable(vbus);\n\t}\n\n\treturn 0;\n}\n\nstatic void ssusb_mode_sw_work(struct work_struct *work)\n{\n\tstruct otg_switch_mtk *otg_sx =\n\t\tcontainer_of(work, struct otg_switch_mtk, dr_work);\n\tstruct ssusb_mtk *ssusb = otg_sx_to_ssusb(otg_sx);\n\tstruct mtu3 *mtu = ssusb->u3d;\n\tenum usb_role desired_role = otg_sx->desired_role;\n\tenum usb_role current_role;\n\n\tcurrent_role = ssusb->is_host ? USB_ROLE_HOST : USB_ROLE_DEVICE;\n\n\tif (desired_role == USB_ROLE_NONE) {\n\t\t \n\t\tdesired_role = USB_ROLE_HOST;\n\t\tif (otg_sx->default_role == USB_ROLE_DEVICE)\n\t\t\tdesired_role = USB_ROLE_DEVICE;\n\t}\n\n\tif (current_role == desired_role)\n\t\treturn;\n\n\tdev_dbg(ssusb->dev, \"set role : %s\\n\", usb_role_string(desired_role));\n\tmtu3_dbg_trace(ssusb->dev, \"set role : %s\", usb_role_string(desired_role));\n\tpm_runtime_get_sync(ssusb->dev);\n\n\tswitch (desired_role) {\n\tcase USB_ROLE_HOST:\n\t\tssusb_set_force_mode(ssusb, MTU3_DR_FORCE_HOST);\n\t\tmtu3_stop(mtu);\n\t\tswitch_port_to_host(ssusb);\n\t\tssusb_set_vbus(otg_sx, 1);\n\t\tssusb->is_host = true;\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\tssusb_set_force_mode(ssusb, MTU3_DR_FORCE_DEVICE);\n\t\tssusb->is_host = false;\n\t\tssusb_set_vbus(otg_sx, 0);\n\t\tswitch_port_to_device(ssusb);\n\t\tmtu3_start(mtu);\n\t\tbreak;\n\tcase USB_ROLE_NONE:\n\tdefault:\n\t\tdev_err(ssusb->dev, \"invalid role\\n\");\n\t}\n\tpm_runtime_put(ssusb->dev);\n}\n\nstatic void ssusb_set_mode(struct otg_switch_mtk *otg_sx, enum usb_role role)\n{\n\tstruct ssusb_mtk *ssusb = otg_sx_to_ssusb(otg_sx);\n\n\tif (ssusb->dr_mode != USB_DR_MODE_OTG)\n\t\treturn;\n\n\totg_sx->desired_role = role;\n\tqueue_work(system_freezable_wq, &otg_sx->dr_work);\n}\n\nstatic int ssusb_id_notifier(struct notifier_block *nb,\n\tunsigned long event, void *ptr)\n{\n\tstruct otg_switch_mtk *otg_sx =\n\t\tcontainer_of(nb, struct otg_switch_mtk, id_nb);\n\n\tssusb_set_mode(otg_sx, event ? USB_ROLE_HOST : USB_ROLE_DEVICE);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int ssusb_extcon_register(struct otg_switch_mtk *otg_sx)\n{\n\tstruct ssusb_mtk *ssusb = otg_sx_to_ssusb(otg_sx);\n\tstruct extcon_dev *edev = otg_sx->edev;\n\tint ret;\n\n\t \n\tif (!edev)\n\t\treturn 0;\n\n\totg_sx->id_nb.notifier_call = ssusb_id_notifier;\n\tret = devm_extcon_register_notifier(ssusb->dev, edev, EXTCON_USB_HOST,\n\t\t\t\t\t&otg_sx->id_nb);\n\tif (ret < 0) {\n\t\tdev_err(ssusb->dev, \"failed to register notifier for USB-HOST\\n\");\n\t\treturn ret;\n\t}\n\n\tret = extcon_get_state(edev, EXTCON_USB_HOST);\n\tdev_dbg(ssusb->dev, \"EXTCON_USB_HOST: %d\\n\", ret);\n\n\t \n\tif (!ret)\n\t\tssusb_set_mode(otg_sx, USB_ROLE_DEVICE);\n\n\treturn 0;\n}\n\n \nvoid ssusb_mode_switch(struct ssusb_mtk *ssusb, int to_host)\n{\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\n\tssusb_set_mode(otg_sx, to_host ? USB_ROLE_HOST : USB_ROLE_DEVICE);\n}\n\nvoid ssusb_set_force_mode(struct ssusb_mtk *ssusb,\n\t\t\t  enum mtu3_dr_force_mode mode)\n{\n\tu32 value;\n\n\tvalue = mtu3_readl(ssusb->ippc_base, SSUSB_U2_CTRL(0));\n\tswitch (mode) {\n\tcase MTU3_DR_FORCE_DEVICE:\n\t\tvalue |= SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG;\n\t\tbreak;\n\tcase MTU3_DR_FORCE_HOST:\n\t\tvalue |= SSUSB_U2_PORT_FORCE_IDDIG;\n\t\tvalue &= ~SSUSB_U2_PORT_RG_IDDIG;\n\t\tbreak;\n\tcase MTU3_DR_FORCE_NONE:\n\t\tvalue &= ~(SSUSB_U2_PORT_FORCE_IDDIG | SSUSB_U2_PORT_RG_IDDIG);\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tmtu3_writel(ssusb->ippc_base, SSUSB_U2_CTRL(0), value);\n}\n\nstatic int ssusb_role_sw_set(struct usb_role_switch *sw, enum usb_role role)\n{\n\tstruct ssusb_mtk *ssusb = usb_role_switch_get_drvdata(sw);\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\n\tssusb_set_mode(otg_sx, role);\n\n\treturn 0;\n}\n\nstatic enum usb_role ssusb_role_sw_get(struct usb_role_switch *sw)\n{\n\tstruct ssusb_mtk *ssusb = usb_role_switch_get_drvdata(sw);\n\n\treturn ssusb->is_host ? USB_ROLE_HOST : USB_ROLE_DEVICE;\n}\n\nstatic int ssusb_role_sw_register(struct otg_switch_mtk *otg_sx)\n{\n\tstruct usb_role_switch_desc role_sx_desc = { 0 };\n\tstruct ssusb_mtk *ssusb = otg_sx_to_ssusb(otg_sx);\n\tstruct device *dev = ssusb->dev;\n\tenum usb_dr_mode mode;\n\n\tif (!otg_sx->role_sw_used)\n\t\treturn 0;\n\n\tmode = usb_get_role_switch_default_mode(dev);\n\tif (mode == USB_DR_MODE_PERIPHERAL)\n\t\totg_sx->default_role = USB_ROLE_DEVICE;\n\telse\n\t\totg_sx->default_role = USB_ROLE_HOST;\n\n\trole_sx_desc.set = ssusb_role_sw_set;\n\trole_sx_desc.get = ssusb_role_sw_get;\n\trole_sx_desc.fwnode = dev_fwnode(dev);\n\trole_sx_desc.driver_data = ssusb;\n\trole_sx_desc.allow_userspace_control = true;\n\totg_sx->role_sw = usb_role_switch_register(dev, &role_sx_desc);\n\tif (IS_ERR(otg_sx->role_sw))\n\t\treturn PTR_ERR(otg_sx->role_sw);\n\n\tssusb_set_mode(otg_sx, otg_sx->default_role);\n\n\treturn 0;\n}\n\nint ssusb_otg_switch_init(struct ssusb_mtk *ssusb)\n{\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\tint ret = 0;\n\n\tINIT_WORK(&otg_sx->dr_work, ssusb_mode_sw_work);\n\n\tif (otg_sx->manual_drd_enabled)\n\t\tssusb_dr_debugfs_init(ssusb);\n\telse if (otg_sx->role_sw_used)\n\t\tret = ssusb_role_sw_register(otg_sx);\n\telse\n\t\tret = ssusb_extcon_register(otg_sx);\n\n\treturn ret;\n}\n\nvoid ssusb_otg_switch_exit(struct ssusb_mtk *ssusb)\n{\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\n\tcancel_work_sync(&otg_sx->dr_work);\n\tusb_role_switch_unregister(otg_sx->role_sw);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}