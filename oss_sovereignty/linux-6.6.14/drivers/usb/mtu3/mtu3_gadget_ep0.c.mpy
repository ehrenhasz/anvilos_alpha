{
  "module_name": "mtu3_gadget_ep0.c",
  "hash_id": "1ecb0d6a28a8c57590c1aa17f49bdfd17378c3f1204c06e13b20acfe70a563cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_gadget_ep0.c",
  "human_readable_source": "\n \n\n#include <linux/iopoll.h>\n#include <linux/usb/composite.h>\n\n#include \"mtu3.h\"\n#include \"mtu3_debug.h\"\n#include \"mtu3_trace.h\"\n\n \n#define\tnext_ep0_request(mtu)\tnext_request((mtu)->ep0)\n\n \nstatic const u8 mtu3_test_packet[53] = {\n\t \n\n\t \n\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t \n\t0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,\n\t \n\t0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,\n\t \n\t0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t \n\t0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd,\n\t \n\t0xfc, 0x7e, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0x7e,\n\t \n};\n\nstatic char *decode_ep0_state(struct mtu3 *mtu)\n{\n\tswitch (mtu->ep0_state) {\n\tcase MU3D_EP0_STATE_SETUP:\n\t\treturn \"SETUP\";\n\tcase MU3D_EP0_STATE_TX:\n\t\treturn \"IN\";\n\tcase MU3D_EP0_STATE_RX:\n\t\treturn \"OUT\";\n\tcase MU3D_EP0_STATE_TX_END:\n\t\treturn \"TX-END\";\n\tcase MU3D_EP0_STATE_STALL:\n\t\treturn \"STALL\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\nstatic void ep0_req_giveback(struct mtu3 *mtu, struct usb_request *req)\n{\n\tmtu3_req_complete(mtu->ep0, req, 0);\n}\n\nstatic int\nforward_to_driver(struct mtu3 *mtu, const struct usb_ctrlrequest *setup)\n__releases(mtu->lock)\n__acquires(mtu->lock)\n{\n\tint ret;\n\n\tif (!mtu->gadget_driver || !mtu->async_callbacks)\n\t\treturn -EOPNOTSUPP;\n\n\tspin_unlock(&mtu->lock);\n\tret = mtu->gadget_driver->setup(&mtu->g, setup);\n\tspin_lock(&mtu->lock);\n\n\tdev_dbg(mtu->dev, \"%s ret %d\\n\", __func__, ret);\n\treturn ret;\n}\n\nstatic void ep0_write_fifo(struct mtu3_ep *mep, const u8 *src, u16 len)\n{\n\tvoid __iomem *fifo = mep->mtu->mac_base + U3D_FIFO0;\n\tu16 index = 0;\n\n\tdev_dbg(mep->mtu->dev, \"%s: ep%din, len=%d, buf=%p\\n\",\n\t\t__func__, mep->epnum, len, src);\n\n\tif (len >= 4) {\n\t\tiowrite32_rep(fifo, src, len >> 2);\n\t\tindex = len & ~0x03;\n\t}\n\tif (len & 0x02) {\n\t\twritew(*(u16 *)&src[index], fifo);\n\t\tindex += 2;\n\t}\n\tif (len & 0x01)\n\t\twriteb(src[index], fifo);\n}\n\nstatic void ep0_read_fifo(struct mtu3_ep *mep, u8 *dst, u16 len)\n{\n\tvoid __iomem *fifo = mep->mtu->mac_base + U3D_FIFO0;\n\tu32 value;\n\tu16 index = 0;\n\n\tdev_dbg(mep->mtu->dev, \"%s: ep%dout len=%d buf=%p\\n\",\n\t\t __func__, mep->epnum, len, dst);\n\n\tif (len >= 4) {\n\t\tioread32_rep(fifo, dst, len >> 2);\n\t\tindex = len & ~0x03;\n\t}\n\tif (len & 0x3) {\n\t\tvalue = readl(fifo);\n\t\tmemcpy(&dst[index], &value, len & 0x3);\n\t}\n\n}\n\nstatic void ep0_load_test_packet(struct mtu3 *mtu)\n{\n\t \n\tep0_write_fifo(mtu->ep0, mtu3_test_packet, sizeof(mtu3_test_packet));\n}\n\n \nstatic void ep0_stall_set(struct mtu3_ep *mep0, bool set, u32 pktrdy)\n{\n\tstruct mtu3 *mtu = mep0->mtu;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 csr;\n\n\t \n\tcsr = mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS;\n\tif (set)\n\t\tcsr |= EP0_SENDSTALL | pktrdy;\n\telse\n\t\tcsr = (csr & ~EP0_SENDSTALL) | EP0_SENTSTALL;\n\tmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr);\n\n\tmtu->delayed_status = false;\n\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\n\tdev_dbg(mtu->dev, \"ep0: %s STALL, ep0_state: %s\\n\",\n\t\tset ? \"SEND\" : \"CLEAR\", decode_ep0_state(mtu));\n}\n\nstatic void ep0_do_status_stage(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 value;\n\n\tvalue = mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS;\n\tmtu3_writel(mbase, U3D_EP0CSR, value | EP0_SETUPPKTRDY | EP0_DATAEND);\n}\n\nstatic int ep0_queue(struct mtu3_ep *mep0, struct mtu3_request *mreq);\n\nstatic void ep0_dummy_complete(struct usb_ep *ep, struct usb_request *req)\n{}\n\nstatic void ep0_set_sel_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct mtu3_request *mreq;\n\tstruct mtu3 *mtu;\n\tstruct usb_set_sel_req sel;\n\n\tmemcpy(&sel, req->buf, sizeof(sel));\n\n\tmreq = to_mtu3_request(req);\n\tmtu = mreq->mtu;\n\tdev_dbg(mtu->dev, \"u1sel:%d, u1pel:%d, u2sel:%d, u2pel:%d\\n\",\n\t\tsel.u1_sel, sel.u1_pel, sel.u2_sel, sel.u2_pel);\n}\n\n \nstatic int ep0_set_sel(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\n{\n\tint ret;\n\tu16 length = le16_to_cpu(setup->wLength);\n\n\tif (unlikely(length != 6)) {\n\t\tdev_err(mtu->dev, \"%s wrong wLength:%d\\n\",\n\t\t\t__func__, length);\n\t\treturn -EINVAL;\n\t}\n\n\tmtu->ep0_req.mep = mtu->ep0;\n\tmtu->ep0_req.request.length = 6;\n\tmtu->ep0_req.request.buf = mtu->setup_buf;\n\tmtu->ep0_req.request.complete = ep0_set_sel_complete;\n\tret = ep0_queue(mtu->ep0, &mtu->ep0_req);\n\n\treturn ret < 0 ? ret : 1;\n}\n\nstatic int\nep0_get_status(struct mtu3 *mtu, const struct usb_ctrlrequest *setup)\n{\n\tstruct mtu3_ep *mep = NULL;\n\tint handled = 1;\n\tu8 result[2] = {0, 0};\n\tu8 epnum = 0;\n\tint is_in;\n\n\tswitch (setup->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\tresult[0] = mtu->is_self_powered << USB_DEVICE_SELF_POWERED;\n\t\tresult[0] |= mtu->may_wakeup << USB_DEVICE_REMOTE_WAKEUP;\n\n\t\tif (mtu->g.speed >= USB_SPEED_SUPER) {\n\t\t\tresult[0] |= mtu->u1_enable << USB_DEV_STAT_U1_ENABLED;\n\t\t\tresult[0] |= mtu->u2_enable << USB_DEV_STAT_U2_ENABLED;\n\t\t}\n\n\t\tdev_dbg(mtu->dev, \"%s result=%x, U1=%x, U2=%x\\n\", __func__,\n\t\t\tresult[0], mtu->u1_enable, mtu->u2_enable);\n\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\t \n\t\thandled = 0;\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = (u8) le16_to_cpu(setup->wIndex);\n\t\tis_in = epnum & USB_DIR_IN;\n\t\tepnum &= USB_ENDPOINT_NUMBER_MASK;\n\n\t\tif (epnum >= mtu->num_eps) {\n\t\t\thandled = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (!epnum)\n\t\t\tbreak;\n\n\t\tmep = (is_in ? mtu->in_eps : mtu->out_eps) + epnum;\n\t\tif (!mep->desc) {\n\t\t\thandled = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tif (mep->flags & MTU3_EP_STALL)\n\t\t\tresult[0] |= 1 << USB_ENDPOINT_HALT;\n\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thandled = 0;\n\t\tbreak;\n\t}\n\n\tif (handled > 0) {\n\t\tint ret;\n\n\t\t \n\t\tdev_dbg(mtu->dev, \"get_status=%x\\n\", *(u16 *)result);\n\t\tmemcpy(mtu->setup_buf, result, sizeof(result));\n\t\tmtu->ep0_req.mep = mtu->ep0;\n\t\tmtu->ep0_req.request.length = 2;\n\t\tmtu->ep0_req.request.buf = &mtu->setup_buf;\n\t\tmtu->ep0_req.request.complete = ep0_dummy_complete;\n\t\tret = ep0_queue(mtu->ep0, &mtu->ep0_req);\n\t\tif (ret < 0)\n\t\t\thandled = ret;\n\t}\n\treturn handled;\n}\n\nstatic int handle_test_mode(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint handled = 1;\n\tu32 value;\n\n\tswitch (le16_to_cpu(setup->wIndex) >> 8) {\n\tcase USB_TEST_J:\n\t\tdev_dbg(mtu->dev, \"USB_TEST_J\\n\");\n\t\tmtu->test_mode_nr = TEST_J_MODE;\n\t\tbreak;\n\tcase USB_TEST_K:\n\t\tdev_dbg(mtu->dev, \"USB_TEST_K\\n\");\n\t\tmtu->test_mode_nr = TEST_K_MODE;\n\t\tbreak;\n\tcase USB_TEST_SE0_NAK:\n\t\tdev_dbg(mtu->dev, \"USB_TEST_SE0_NAK\\n\");\n\t\tmtu->test_mode_nr = TEST_SE0_NAK_MODE;\n\t\tbreak;\n\tcase USB_TEST_PACKET:\n\t\tdev_dbg(mtu->dev, \"USB_TEST_PACKET\\n\");\n\t\tmtu->test_mode_nr = TEST_PACKET_MODE;\n\t\tbreak;\n\tdefault:\n\t\thandled = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmtu->test_mode = true;\n\n\t \n\tif (mtu->test_mode_nr == TEST_PACKET_MODE)\n\t\tep0_load_test_packet(mtu);\n\n\t \n\tep0_do_status_stage(mtu);\n\n\t \n\treadl_poll_timeout_atomic(mbase + U3D_EP0CSR, value,\n\t\t\t!(value & EP0_DATAEND), 100, 5000);\n\n\tmtu3_writel(mbase, U3D_USB2_TEST_MODE, mtu->test_mode_nr);\n\n\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\nout:\n\treturn handled;\n}\n\nstatic int ep0_handle_feature_dev(struct mtu3 *mtu,\n\t\tstruct usb_ctrlrequest *setup, bool set)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint handled = -EINVAL;\n\tu32 lpc;\n\n\tswitch (le16_to_cpu(setup->wValue)) {\n\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\tmtu->may_wakeup = !!set;\n\t\thandled = 1;\n\t\tbreak;\n\tcase USB_DEVICE_TEST_MODE:\n\t\tif (!set || (mtu->g.speed != USB_SPEED_HIGH) ||\n\t\t\t(le16_to_cpu(setup->wIndex) & 0xff))\n\t\t\tbreak;\n\n\t\thandled = handle_test_mode(mtu, setup);\n\t\tbreak;\n\tcase USB_DEVICE_U1_ENABLE:\n\t\tif (mtu->g.speed < USB_SPEED_SUPER ||\n\t\t    mtu->g.state != USB_STATE_CONFIGURED)\n\t\t\tbreak;\n\n\t\tlpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);\n\t\tif (set)\n\t\t\tlpc |= SW_U1_REQUEST_ENABLE;\n\t\telse\n\t\t\tlpc &= ~SW_U1_REQUEST_ENABLE;\n\t\tmtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);\n\n\t\tmtu->u1_enable = !!set;\n\t\thandled = 1;\n\t\tbreak;\n\tcase USB_DEVICE_U2_ENABLE:\n\t\tif (mtu->g.speed < USB_SPEED_SUPER ||\n\t\t    mtu->g.state != USB_STATE_CONFIGURED)\n\t\t\tbreak;\n\n\t\tlpc = mtu3_readl(mbase, U3D_LINK_POWER_CONTROL);\n\t\tif (set)\n\t\t\tlpc |= SW_U2_REQUEST_ENABLE;\n\t\telse\n\t\t\tlpc &= ~SW_U2_REQUEST_ENABLE;\n\t\tmtu3_writel(mbase, U3D_LINK_POWER_CONTROL, lpc);\n\n\t\tmtu->u2_enable = !!set;\n\t\thandled = 1;\n\t\tbreak;\n\tdefault:\n\t\thandled = -EINVAL;\n\t\tbreak;\n\t}\n\treturn handled;\n}\n\nstatic int ep0_handle_feature(struct mtu3 *mtu,\n\t\tstruct usb_ctrlrequest *setup, bool set)\n{\n\tstruct mtu3_ep *mep;\n\tint handled = -EINVAL;\n\tint is_in;\n\tu16 value;\n\tu16 index;\n\tu8 epnum;\n\n\tvalue = le16_to_cpu(setup->wValue);\n\tindex = le16_to_cpu(setup->wIndex);\n\n\tswitch (setup->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_DEVICE:\n\t\thandled = ep0_handle_feature_dev(mtu, setup, set);\n\t\tbreak;\n\tcase USB_RECIP_INTERFACE:\n\t\t \n\t\tif (value == USB_INTRF_FUNC_SUSPEND &&\n\t\t    mtu->g.speed >= USB_SPEED_SUPER) {\n\t\t\t \n\t\t\tmtu->may_wakeup = !!(index & USB_INTRF_FUNC_SUSPEND_RW);\n\t\t\thandled = 0;\n\t\t}\n\t\tbreak;\n\tcase USB_RECIP_ENDPOINT:\n\t\tepnum = index & USB_ENDPOINT_NUMBER_MASK;\n\t\tif (epnum == 0 || epnum >= mtu->num_eps ||\n\t\t\tvalue != USB_ENDPOINT_HALT)\n\t\t\tbreak;\n\n\t\tis_in = index & USB_DIR_IN;\n\t\tmep = (is_in ? mtu->in_eps : mtu->out_eps) + epnum;\n\t\tif (!mep->desc)\n\t\t\tbreak;\n\n\t\thandled = 1;\n\t\t \n\t\tif (mep->flags & MTU3_EP_WEDGE)\n\t\t\tbreak;\n\n\t\tmtu3_ep_stall_set(mep, set);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thandled = 0;\n\t\tbreak;\n\t}\n\treturn handled;\n}\n\n \nstatic int handle_standard_request(struct mtu3 *mtu,\n\t\t\t  struct usb_ctrlrequest *setup)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tenum usb_device_state state = mtu->g.state;\n\tint handled = -EINVAL;\n\tu32 dev_conf;\n\tu16 value;\n\n\tvalue = le16_to_cpu(setup->wValue);\n\n\t \n\tswitch (setup->bRequest) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\t \n\t\tmtu->address = (u8) (value & 0x7f);\n\t\tdev_dbg(mtu->dev, \"set address to 0x%x\\n\", mtu->address);\n\n\t\tdev_conf = mtu3_readl(mbase, U3D_DEVICE_CONF);\n\t\tdev_conf &= ~DEV_ADDR_MSK;\n\t\tdev_conf |= DEV_ADDR(mtu->address);\n\t\tmtu3_writel(mbase, U3D_DEVICE_CONF, dev_conf);\n\n\t\tif (mtu->address)\n\t\t\tusb_gadget_set_state(&mtu->g, USB_STATE_ADDRESS);\n\t\telse\n\t\t\tusb_gadget_set_state(&mtu->g, USB_STATE_DEFAULT);\n\n\t\thandled = 1;\n\t\tbreak;\n\tcase USB_REQ_SET_CONFIGURATION:\n\t\tif (state == USB_STATE_ADDRESS) {\n\t\t\tusb_gadget_set_state(&mtu->g,\n\t\t\t\t\tUSB_STATE_CONFIGURED);\n\t\t} else if (state == USB_STATE_CONFIGURED) {\n\t\t\t \n\t\t\tif (!value)\n\t\t\t\tusb_gadget_set_state(&mtu->g,\n\t\t\t\t\t\tUSB_STATE_ADDRESS);\n\t\t}\n\t\thandled = 0;\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\thandled = ep0_handle_feature(mtu, setup, 0);\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\thandled = ep0_handle_feature(mtu, setup, 1);\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\thandled = ep0_get_status(mtu, setup);\n\t\tbreak;\n\tcase USB_REQ_SET_SEL:\n\t\thandled = ep0_set_sel(mtu, setup);\n\t\tbreak;\n\tcase USB_REQ_SET_ISOCH_DELAY:\n\t\thandled = 1;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\thandled = 0;\n\t}\n\n\treturn handled;\n}\n\n \nstatic void ep0_rx_state(struct mtu3 *mtu)\n{\n\tstruct mtu3_request *mreq;\n\tstruct usb_request *req;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 maxp;\n\tu32 csr;\n\tu16 count = 0;\n\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\tcsr = mtu3_readl(mbase, U3D_EP0CSR) & EP0_W1C_BITS;\n\tmreq = next_ep0_request(mtu);\n\treq = &mreq->request;\n\n\t \n\tif (req) {\n\t\tvoid *buf = req->buf + req->actual;\n\t\tunsigned int len = req->length - req->actual;\n\n\t\t \n\t\tcount = mtu3_readl(mbase, U3D_RXCOUNT0);\n\t\tif (count > len) {\n\t\t\treq->status = -EOVERFLOW;\n\t\t\tcount = len;\n\t\t}\n\t\tep0_read_fifo(mtu->ep0, buf, count);\n\t\treq->actual += count;\n\t\tcsr |= EP0_RXPKTRDY;\n\n\t\tmaxp = mtu->g.ep0->maxpacket;\n\t\tif (count < maxp || req->actual == req->length) {\n\t\t\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\t\t\tdev_dbg(mtu->dev, \"ep0 state: %s\\n\",\n\t\t\t\tdecode_ep0_state(mtu));\n\n\t\t\tcsr |= EP0_DATAEND;\n\t\t} else {\n\t\t\treq = NULL;\n\t\t}\n\t} else {\n\t\tcsr |= EP0_RXPKTRDY | EP0_SENDSTALL;\n\t\tdev_dbg(mtu->dev, \"%s: SENDSTALL\\n\", __func__);\n\t}\n\n\tmtu3_writel(mbase, U3D_EP0CSR, csr);\n\n\t \n\tif (req)\n\t\tep0_req_giveback(mtu, req);\n\n}\n\n \nstatic void ep0_tx_state(struct mtu3 *mtu)\n{\n\tstruct mtu3_request *mreq = next_ep0_request(mtu);\n\tstruct usb_request *req;\n\tu32 csr;\n\tu8 *src;\n\tu32 count;\n\tu32 maxp;\n\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\tif (!mreq)\n\t\treturn;\n\n\tmaxp = mtu->g.ep0->maxpacket;\n\treq = &mreq->request;\n\n\t \n\tsrc = (u8 *)req->buf + req->actual;\n\tcount = min(maxp, req->length - req->actual);\n\tif (count)\n\t\tep0_write_fifo(mtu->ep0, src, count);\n\n\tdev_dbg(mtu->dev, \"%s act=%d, len=%d, cnt=%d, maxp=%d zero=%d\\n\",\n\t\t __func__, req->actual, req->length, count, maxp, req->zero);\n\n\treq->actual += count;\n\n\tif ((count < maxp)\n\t\t|| ((req->actual == req->length) && !req->zero))\n\t\tmtu->ep0_state = MU3D_EP0_STATE_TX_END;\n\n\t \n\tcsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR) & EP0_W1C_BITS;\n\tmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr | EP0_TXPKTRDY);\n\n\tdev_dbg(mtu->dev, \"%s ep0csr=0x%x\\n\", __func__,\n\t\tmtu3_readl(mtu->mac_base, U3D_EP0CSR));\n}\n\nstatic void ep0_read_setup(struct mtu3 *mtu, struct usb_ctrlrequest *setup)\n{\n\tstruct mtu3_request *mreq;\n\tu32 count;\n\tu32 csr;\n\n\tcsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR) & EP0_W1C_BITS;\n\tcount = mtu3_readl(mtu->mac_base, U3D_RXCOUNT0);\n\n\tep0_read_fifo(mtu->ep0, (u8 *)setup, count);\n\n\tdev_dbg(mtu->dev, \"SETUP req%02x.%02x v%04x i%04x l%04x\\n\",\n\t\t setup->bRequestType, setup->bRequest,\n\t\t le16_to_cpu(setup->wValue), le16_to_cpu(setup->wIndex),\n\t\t le16_to_cpu(setup->wLength));\n\n\t \n\tmreq = next_ep0_request(mtu);\n\tif (mreq)\n\t\tep0_req_giveback(mtu, &mreq->request);\n\n\tif (le16_to_cpu(setup->wLength) == 0) {\n\t\t;\t \n\t} else if (setup->bRequestType & USB_DIR_IN) {\n\t\tmtu3_writel(mtu->mac_base, U3D_EP0CSR,\n\t\t\tcsr | EP0_SETUPPKTRDY | EP0_DPHTX);\n\t\tmtu->ep0_state = MU3D_EP0_STATE_TX;\n\t} else {\n\t\tmtu3_writel(mtu->mac_base, U3D_EP0CSR,\n\t\t\t(csr | EP0_SETUPPKTRDY) & (~EP0_DPHTX));\n\t\tmtu->ep0_state = MU3D_EP0_STATE_RX;\n\t}\n}\n\nstatic int ep0_handle_setup(struct mtu3 *mtu)\n__releases(mtu->lock)\n__acquires(mtu->lock)\n{\n\tstruct usb_ctrlrequest setup;\n\tstruct mtu3_request *mreq;\n\tint handled = 0;\n\n\tep0_read_setup(mtu, &setup);\n\ttrace_mtu3_handle_setup(&setup);\n\n\tif ((setup.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD)\n\t\thandled = handle_standard_request(mtu, &setup);\n\n\tdev_dbg(mtu->dev, \"handled %d, ep0_state: %s\\n\",\n\t\t handled, decode_ep0_state(mtu));\n\n\tif (handled < 0)\n\t\tgoto stall;\n\telse if (handled > 0)\n\t\tgoto finish;\n\n\thandled = forward_to_driver(mtu, &setup);\n\tif (handled < 0) {\nstall:\n\t\tdev_dbg(mtu->dev, \"%s stall (%d)\\n\", __func__, handled);\n\n\t\tep0_stall_set(mtu->ep0, true,\n\t\t\tle16_to_cpu(setup.wLength) ? 0 : EP0_SETUPPKTRDY);\n\n\t\treturn 0;\n\t}\n\nfinish:\n\tif (mtu->test_mode) {\n\t\t;\t \n\t} else if (handled == USB_GADGET_DELAYED_STATUS) {\n\n\t\tmreq = next_ep0_request(mtu);\n\t\tif (mreq) {\n\t\t\t \n\t\t\tep0_do_status_stage(mtu);\n\t\t\tep0_req_giveback(mtu, &mreq->request);\n\t\t} else {\n\t\t\t \n\t\t\tmtu->delayed_status = true;\n\t\t}\n\t} else if (le16_to_cpu(setup.wLength) == 0) {  \n\n\t\tep0_do_status_stage(mtu);\n\t\t \n\t\tmreq = next_ep0_request(mtu);\n\t\tif (mreq && !mreq->request.length)\n\t\t\tep0_req_giveback(mtu, &mreq->request);\n\t}\n\n\treturn 0;\n}\n\nirqreturn_t mtu3_ep0_isr(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tstruct mtu3_request *mreq;\n\tu32 int_status;\n\tirqreturn_t ret = IRQ_NONE;\n\tu32 csr;\n\tu32 len;\n\n\tint_status = mtu3_readl(mbase, U3D_EPISR);\n\tint_status &= mtu3_readl(mbase, U3D_EPIER);\n\tmtu3_writel(mbase, U3D_EPISR, int_status);  \n\n\t \n\tif (!(int_status & (EP0ISR | SETUPENDISR)))\n\t\treturn IRQ_NONE;\n\n\t \n\tif (int_status & SETUPENDISR)\n\t\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\n\tcsr = mtu3_readl(mbase, U3D_EP0CSR);\n\n\tdev_dbg(mtu->dev, \"%s csr=0x%x\\n\", __func__, csr);\n\n\t \n\tif (csr & EP0_SENTSTALL) {\n\t\tep0_stall_set(mtu->ep0, false, 0);\n\t\tcsr = mtu3_readl(mbase, U3D_EP0CSR);\n\t\tret = IRQ_HANDLED;\n\t}\n\tdev_dbg(mtu->dev, \"ep0_state: %s\\n\", decode_ep0_state(mtu));\n\tmtu3_dbg_trace(mtu->dev, \"ep0_state %s\", decode_ep0_state(mtu));\n\n\tswitch (mtu->ep0_state) {\n\tcase MU3D_EP0_STATE_TX:\n\t\t \n\t\tif ((csr & EP0_FIFOFULL) == 0) {\n\t\t\tep0_tx_state(mtu);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t\tbreak;\n\tcase MU3D_EP0_STATE_RX:\n\t\t \n\t\tif (csr & EP0_RXPKTRDY) {\n\t\t\tep0_rx_state(mtu);\n\t\t\tret = IRQ_HANDLED;\n\t\t}\n\t\tbreak;\n\tcase MU3D_EP0_STATE_TX_END:\n\t\tmtu3_writel(mbase, U3D_EP0CSR,\n\t\t\t(csr & EP0_W1C_BITS) | EP0_DATAEND);\n\n\t\tmreq = next_ep0_request(mtu);\n\t\tif (mreq)\n\t\t\tep0_req_giveback(mtu, &mreq->request);\n\n\t\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\t\tret = IRQ_HANDLED;\n\t\tdev_dbg(mtu->dev, \"ep0_state: %s\\n\", decode_ep0_state(mtu));\n\t\tbreak;\n\tcase MU3D_EP0_STATE_SETUP:\n\t\tif (!(csr & EP0_SETUPPKTRDY))\n\t\t\tbreak;\n\n\t\tlen = mtu3_readl(mbase, U3D_RXCOUNT0);\n\t\tif (len != 8) {\n\t\t\tdev_err(mtu->dev, \"SETUP packet len %d != 8 ?\\n\", len);\n\t\t\tbreak;\n\t\t}\n\n\t\tep0_handle_setup(mtu);\n\t\tret = IRQ_HANDLED;\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tep0_stall_set(mtu->ep0, true, 0);\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n\nstatic int mtu3_ep0_enable(struct usb_ep *ep,\n\tconst struct usb_endpoint_descriptor *desc)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int mtu3_ep0_disable(struct usb_ep *ep)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int ep0_queue(struct mtu3_ep *mep, struct mtu3_request *mreq)\n{\n\tstruct mtu3 *mtu = mep->mtu;\n\n\tmreq->mtu = mtu;\n\tmreq->request.actual = 0;\n\tmreq->request.status = -EINPROGRESS;\n\n\tdev_dbg(mtu->dev, \"%s %s (ep0_state: %s), len#%d\\n\", __func__,\n\t\tmep->name, decode_ep0_state(mtu), mreq->request.length);\n\n\tswitch (mtu->ep0_state) {\n\tcase MU3D_EP0_STATE_SETUP:\n\tcase MU3D_EP0_STATE_RX:\t \n\tcase MU3D_EP0_STATE_TX:\t \n\t\tbreak;\n\tdefault:\n\t\tdev_err(mtu->dev, \"%s, error in ep0 state %s\\n\", __func__,\n\t\t\tdecode_ep0_state(mtu));\n\t\treturn -EINVAL;\n\t}\n\n\tif (mtu->delayed_status) {\n\n\t\tmtu->delayed_status = false;\n\t\tep0_do_status_stage(mtu);\n\t\t \n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&mep->req_list))\n\t\treturn -EBUSY;\n\n\tlist_add_tail(&mreq->list, &mep->req_list);\n\n\t \n\tif (mtu->ep0_state == MU3D_EP0_STATE_TX)\n\t\tep0_tx_state(mtu);\n\n\treturn 0;\n}\n\nstatic int mtu3_ep0_queue(struct usb_ep *ep,\n\tstruct usb_request *req, gfp_t gfp)\n{\n\tstruct mtu3_ep *mep;\n\tstruct mtu3_request *mreq;\n\tstruct mtu3 *mtu;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!ep || !req)\n\t\treturn -EINVAL;\n\n\tmep = to_mtu3_ep(ep);\n\tmtu = mep->mtu;\n\tmreq = to_mtu3_request(req);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tret = ep0_queue(mep, mreq);\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\treturn ret;\n}\n\nstatic int mtu3_ep0_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\t \n\treturn -EINVAL;\n}\n\nstatic int mtu3_ep0_halt(struct usb_ep *ep, int value)\n{\n\tstruct mtu3_ep *mep;\n\tstruct mtu3 *mtu;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!ep || !value)\n\t\treturn -EINVAL;\n\n\tmep = to_mtu3_ep(ep);\n\tmtu = mep->mtu;\n\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tif (!list_empty(&mep->req_list)) {\n\t\tret = -EBUSY;\n\t\tgoto cleanup;\n\t}\n\n\tswitch (mtu->ep0_state) {\n\t \n\tcase MU3D_EP0_STATE_TX:\n\tcase MU3D_EP0_STATE_TX_END:\n\tcase MU3D_EP0_STATE_RX:\n\tcase MU3D_EP0_STATE_SETUP:\n\t\tep0_stall_set(mtu->ep0, true, 0);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(mtu->dev, \"ep0 can't halt in state %s\\n\",\n\t\t\tdecode_ep0_state(mtu));\n\t\tret = -EINVAL;\n\t}\n\ncleanup:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\treturn ret;\n}\n\nconst struct usb_ep_ops mtu3_ep0_ops = {\n\t.enable = mtu3_ep0_enable,\n\t.disable = mtu3_ep0_disable,\n\t.alloc_request = mtu3_alloc_request,\n\t.free_request = mtu3_free_request,\n\t.queue = mtu3_ep0_queue,\n\t.dequeue = mtu3_ep0_dequeue,\n\t.set_halt = mtu3_ep0_halt,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}