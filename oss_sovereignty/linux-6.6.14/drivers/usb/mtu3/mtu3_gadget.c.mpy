{
  "module_name": "mtu3_gadget.c",
  "hash_id": "2c1eefcdaab98521204b2da525a46906433d2333301ab0cff1e3d398bb4b45f0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_gadget.c",
  "human_readable_source": "\n \n\n#include \"mtu3.h\"\n#include \"mtu3_trace.h\"\n\nvoid mtu3_req_complete(struct mtu3_ep *mep,\n\t\t     struct usb_request *req, int status)\n__releases(mep->mtu->lock)\n__acquires(mep->mtu->lock)\n{\n\tstruct mtu3_request *mreq = to_mtu3_request(req);\n\tstruct mtu3 *mtu = mreq->mtu;\n\n\tlist_del(&mreq->list);\n\tif (req->status == -EINPROGRESS)\n\t\treq->status = status;\n\n\ttrace_mtu3_req_complete(mreq);\n\n\t \n\tif (mep->epnum)\n\t\tusb_gadget_unmap_request(&mtu->g, req, mep->is_in);\n\n\tdev_dbg(mtu->dev, \"%s complete req: %p, sts %d, %d/%d\\n\",\n\t\tmep->name, req, req->status, req->actual, req->length);\n\n\tspin_unlock(&mtu->lock);\n\tusb_gadget_giveback_request(&mep->ep, req);\n\tspin_lock(&mtu->lock);\n}\n\nstatic void nuke(struct mtu3_ep *mep, const int status)\n{\n\tstruct mtu3_request *mreq = NULL;\n\n\tif (list_empty(&mep->req_list))\n\t\treturn;\n\n\tdev_dbg(mep->mtu->dev, \"abort %s's req: sts %d\\n\", mep->name, status);\n\n\t \n\tif (mep->epnum)\n\t\tmtu3_qmu_flush(mep);\n\n\twhile (!list_empty(&mep->req_list)) {\n\t\tmreq = list_first_entry(&mep->req_list,\n\t\t\t\t\tstruct mtu3_request, list);\n\t\tmtu3_req_complete(mep, &mreq->request, status);\n\t}\n}\n\nstatic int mtu3_ep_enable(struct mtu3_ep *mep)\n{\n\tconst struct usb_endpoint_descriptor *desc;\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n\tstruct mtu3 *mtu = mep->mtu;\n\tu32 interval = 0;\n\tu32 mult = 0;\n\tu32 burst = 0;\n\tint ret;\n\n\tdesc = mep->desc;\n\tcomp_desc = mep->comp_desc;\n\tmep->type = usb_endpoint_type(desc);\n\tmep->maxp = usb_endpoint_maxp(desc);\n\n\tswitch (mtu->g.speed) {\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tif (usb_endpoint_xfer_int(desc) ||\n\t\t\t\tusb_endpoint_xfer_isoc(desc)) {\n\t\t\tinterval = desc->bInterval;\n\t\t\tinterval = clamp_val(interval, 1, 16);\n\t\t\tif (usb_endpoint_xfer_isoc(desc) && comp_desc)\n\t\t\t\tmult = comp_desc->bmAttributes;\n\t\t}\n\t\tif (comp_desc)\n\t\t\tburst = comp_desc->bMaxBurst;\n\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tif (usb_endpoint_xfer_isoc(desc) ||\n\t\t\t\tusb_endpoint_xfer_int(desc)) {\n\t\t\tinterval = desc->bInterval;\n\t\t\tinterval = clamp_val(interval, 1, 16);\n\t\t\tmult = usb_endpoint_maxp_mult(desc) - 1;\n\t\t}\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tif (usb_endpoint_xfer_isoc(desc))\n\t\t\tinterval = clamp_val(desc->bInterval, 1, 16);\n\t\telse if (usb_endpoint_xfer_int(desc))\n\t\t\tinterval = clamp_val(desc->bInterval, 1, 255);\n\n\t\tbreak;\n\tdefault:\n\t\tbreak;  \n\t}\n\n\tdev_dbg(mtu->dev, \"%s maxp:%d, interval:%d, burst:%d, mult:%d\\n\",\n\t\t__func__, mep->maxp, interval, burst, mult);\n\n\tmep->ep.maxpacket = mep->maxp;\n\tmep->ep.desc = desc;\n\tmep->ep.comp_desc = comp_desc;\n\n\t \n\tmep->slot = usb_endpoint_xfer_int(desc) ? 0 : mtu->slot;\n\n\tret = mtu3_config_ep(mtu, mep, interval, burst, mult);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = mtu3_gpd_ring_alloc(mep);\n\tif (ret < 0) {\n\t\tmtu3_deconfig_ep(mtu, mep);\n\t\treturn ret;\n\t}\n\n\tmtu3_qmu_start(mep);\n\n\treturn 0;\n}\n\nstatic int mtu3_ep_disable(struct mtu3_ep *mep)\n{\n\tstruct mtu3 *mtu = mep->mtu;\n\n\t \n\tnuke(mep, -ESHUTDOWN);\n\tmtu3_qmu_stop(mep);\n\tmtu3_deconfig_ep(mtu, mep);\n\tmtu3_gpd_ring_free(mep);\n\n\tmep->desc = NULL;\n\tmep->ep.desc = NULL;\n\tmep->comp_desc = NULL;\n\tmep->type = 0;\n\tmep->flags = 0;\n\n\treturn 0;\n}\n\nstatic int mtu3_gadget_ep_enable(struct usb_ep *ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct mtu3_ep *mep;\n\tstruct mtu3 *mtu;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (!ep || !desc || desc->bDescriptorType != USB_DT_ENDPOINT) {\n\t\tpr_debug(\"%s invalid parameters\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!desc->wMaxPacketSize) {\n\t\tpr_debug(\"%s missing wMaxPacketSize\\n\", __func__);\n\t\treturn -EINVAL;\n\t}\n\tmep = to_mtu3_ep(ep);\n\tmtu = mep->mtu;\n\n\t \n\tif (usb_endpoint_num(desc) != mep->epnum)\n\t\treturn -EINVAL;\n\n\tif (!!usb_endpoint_dir_in(desc) ^ !!mep->is_in)\n\t\treturn -EINVAL;\n\n\tdev_dbg(mtu->dev, \"%s %s\\n\", __func__, ep->name);\n\n\tif (mep->flags & MTU3_EP_ENABLED) {\n\t\tdev_WARN_ONCE(mtu->dev, true, \"%s is already enabled\\n\",\n\t\t\t\tmep->name);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tmep->desc = desc;\n\tmep->comp_desc = ep->comp_desc;\n\n\tret = mtu3_ep_enable(mep);\n\tif (ret)\n\t\tgoto error;\n\n\tmep->flags = MTU3_EP_ENABLED;\n\tmtu->active_ep++;\n\nerror:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\tdev_dbg(mtu->dev, \"%s active_ep=%d\\n\", __func__, mtu->active_ep);\n\ttrace_mtu3_gadget_ep_enable(mep);\n\n\treturn ret;\n}\n\nstatic int mtu3_gadget_ep_disable(struct usb_ep *ep)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\tstruct mtu3 *mtu = mep->mtu;\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s %s\\n\", __func__, mep->name);\n\ttrace_mtu3_gadget_ep_disable(mep);\n\n\tif (!(mep->flags & MTU3_EP_ENABLED)) {\n\t\tdev_warn(mtu->dev, \"%s is already disabled\\n\", mep->name);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tmtu3_ep_disable(mep);\n\tmep->flags = 0;\n\tmtu->active_ep--;\n\tspin_unlock_irqrestore(&(mtu->lock), flags);\n\n\tdev_dbg(mtu->dev, \"%s active_ep=%d, mtu3 is_active=%d\\n\",\n\t\t__func__, mtu->active_ep, mtu->is_active);\n\n\treturn 0;\n}\n\nstruct usb_request *mtu3_alloc_request(struct usb_ep *ep, gfp_t gfp_flags)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\tstruct mtu3_request *mreq;\n\n\tmreq = kzalloc(sizeof(*mreq), gfp_flags);\n\tif (!mreq)\n\t\treturn NULL;\n\n\tmreq->request.dma = DMA_ADDR_INVALID;\n\tmreq->epnum = mep->epnum;\n\tmreq->mep = mep;\n\tINIT_LIST_HEAD(&mreq->list);\n\ttrace_mtu3_alloc_request(mreq);\n\n\treturn &mreq->request;\n}\n\nvoid mtu3_free_request(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct mtu3_request *mreq = to_mtu3_request(req);\n\n\ttrace_mtu3_free_request(mreq);\n\tkfree(mreq);\n}\n\nstatic int mtu3_gadget_queue(struct usb_ep *ep,\n\t\tstruct usb_request *req, gfp_t gfp_flags)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\tstruct mtu3_request *mreq = to_mtu3_request(req);\n\tstruct mtu3 *mtu = mep->mtu;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (!req->buf)\n\t\treturn -ENODATA;\n\n\tif (mreq->mep != mep)\n\t\treturn -EINVAL;\n\n\tdev_dbg(mtu->dev, \"%s %s EP%d(%s), req=%p, maxp=%d, len#%d\\n\",\n\t\t__func__, mep->is_in ? \"TX\" : \"RX\", mreq->epnum, ep->name,\n\t\tmreq, ep->maxpacket, mreq->request.length);\n\n\tif (req->length > GPD_BUF_SIZE ||\n\t    (mtu->gen2cp && req->length > GPD_BUF_SIZE_EL)) {\n\t\tdev_warn(mtu->dev,\n\t\t\t\"req length > supported MAX:%d requested:%d\\n\",\n\t\t\tmtu->gen2cp ? GPD_BUF_SIZE_EL : GPD_BUF_SIZE,\n\t\t\treq->length);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t \n\tif (!mep->desc) {\n\t\tdev_dbg(mtu->dev, \"req=%p queued to %s while it's disabled\\n\",\n\t\t\treq, ep->name);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\tmreq->mtu = mtu;\n\tmreq->request.actual = 0;\n\tmreq->request.status = -EINPROGRESS;\n\n\tret = usb_gadget_map_request(&mtu->g, req, mep->is_in);\n\tif (ret) {\n\t\tdev_err(mtu->dev, \"dma mapping failed\\n\");\n\t\treturn ret;\n\t}\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tif (mtu3_prepare_transfer(mep)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\n\tlist_add_tail(&mreq->list, &mep->req_list);\n\tmtu3_insert_gpd(mep, mreq);\n\tmtu3_qmu_resume(mep);\n\nerror:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\ttrace_mtu3_gadget_queue(mreq);\n\n\treturn ret;\n}\n\nstatic int mtu3_gadget_dequeue(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\tstruct mtu3_request *mreq = to_mtu3_request(req);\n\tstruct mtu3_request *r;\n\tstruct mtu3 *mtu = mep->mtu;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (mreq->mep != mep)\n\t\treturn -EINVAL;\n\n\tdev_dbg(mtu->dev, \"%s : req=%p\\n\", __func__, req);\n\ttrace_mtu3_gadget_dequeue(mreq);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tlist_for_each_entry(r, &mep->req_list, list) {\n\t\tif (r == mreq)\n\t\t\tbreak;\n\t}\n\tif (r != mreq) {\n\t\tdev_dbg(mtu->dev, \"req=%p not queued to %s\\n\", req, ep->name);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmtu3_qmu_flush(mep);   \n\tmtu3_req_complete(mep, req, -ECONNRESET);\n\tmtu3_qmu_start(mep);\n\ndone:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int mtu3_gadget_ep_set_halt(struct usb_ep *ep, int value)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\tstruct mtu3 *mtu = mep->mtu;\n\tstruct mtu3_request *mreq;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdev_dbg(mtu->dev, \"%s : %s...\", __func__, ep->name);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tif (mep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tmreq = next_request(mep);\n\tif (value) {\n\t\t \n\t\tif (mreq) {\n\t\t\tdev_dbg(mtu->dev, \"req in progress, cannot halt %s\\n\",\n\t\t\t\tep->name);\n\t\t\tret = -EAGAIN;\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tmep->flags &= ~MTU3_EP_WEDGE;\n\t}\n\n\tdev_dbg(mtu->dev, \"%s %s stall\\n\", ep->name, value ? \"set\" : \"clear\");\n\n\tmtu3_ep_stall_set(mep, value);\n\ndone:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\ttrace_mtu3_gadget_ep_set_halt(mep);\n\n\treturn ret;\n}\n\n \nstatic int mtu3_gadget_ep_set_wedge(struct usb_ep *ep)\n{\n\tstruct mtu3_ep *mep = to_mtu3_ep(ep);\n\n\tmep->flags |= MTU3_EP_WEDGE;\n\n\treturn usb_ep_set_halt(ep);\n}\n\nstatic const struct usb_ep_ops mtu3_ep_ops = {\n\t.enable = mtu3_gadget_ep_enable,\n\t.disable = mtu3_gadget_ep_disable,\n\t.alloc_request = mtu3_alloc_request,\n\t.free_request = mtu3_free_request,\n\t.queue = mtu3_gadget_queue,\n\t.dequeue = mtu3_gadget_dequeue,\n\t.set_halt = mtu3_gadget_ep_set_halt,\n\t.set_wedge = mtu3_gadget_ep_set_wedge,\n};\n\nstatic int mtu3_gadget_get_frame(struct usb_gadget *gadget)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(gadget);\n\n\treturn (int)mtu3_readl(mtu->mac_base, U3D_USB20_FRAME_NUM);\n}\n\nstatic void function_wake_notif(struct mtu3 *mtu, u8 intf)\n{\n\tmtu3_writel(mtu->mac_base, U3D_DEV_NOTIF_0,\n\t\t    TYPE_FUNCTION_WAKE | DEV_NOTIF_VAL_FW(intf));\n\tmtu3_setbits(mtu->mac_base, U3D_DEV_NOTIF_0, SEND_DEV_NOTIF);\n}\n\nstatic int mtu3_gadget_wakeup(struct usb_gadget *gadget)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(gadget);\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\t \n\tif (!mtu->may_wakeup)\n\t\treturn  -EOPNOTSUPP;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tif (mtu->g.speed >= USB_SPEED_SUPER) {\n\t\t \n\t\tmtu3_setbits(mtu->mac_base, U3D_LINK_POWER_CONTROL, UX_EXIT);\n\t\t \n\t\tfunction_wake_notif(mtu, 0);\n\t} else {\n\t\tmtu3_setbits(mtu->mac_base, U3D_POWER_MANAGEMENT, RESUME);\n\t\tspin_unlock_irqrestore(&mtu->lock, flags);\n\t\tusleep_range(10000, 11000);\n\t\tspin_lock_irqsave(&mtu->lock, flags);\n\t\tmtu3_clrbits(mtu->mac_base, U3D_POWER_MANAGEMENT, RESUME);\n\t}\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\treturn 0;\n}\n\nstatic int mtu3_gadget_set_self_powered(struct usb_gadget *gadget,\n\t\tint is_selfpowered)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(gadget);\n\n\tmtu->is_self_powered = !!is_selfpowered;\n\treturn 0;\n}\n\nstatic int mtu3_gadget_pullup(struct usb_gadget *gadget, int is_on)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(gadget);\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s (%s) for %sactive device\\n\", __func__,\n\t\tis_on ? \"on\" : \"off\", mtu->is_active ? \"\" : \"in\");\n\n\tpm_runtime_get_sync(mtu->dev);\n\n\t \n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tis_on = !!is_on;\n\tif (!mtu->is_active) {\n\t\t \n\t\tmtu->softconnect = is_on;\n\t} else if (is_on != mtu->softconnect) {\n\t\tmtu->softconnect = is_on;\n\t\tmtu3_dev_on_off(mtu, is_on);\n\t}\n\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\tpm_runtime_put(mtu->dev);\n\n\treturn 0;\n}\n\nstatic int mtu3_gadget_start(struct usb_gadget *gadget,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(gadget);\n\tunsigned long flags;\n\n\tif (mtu->gadget_driver) {\n\t\tdev_err(mtu->dev, \"%s is already bound to %s\\n\",\n\t\t\tmtu->g.name, mtu->gadget_driver->driver.name);\n\t\treturn -EBUSY;\n\t}\n\n\tdev_dbg(mtu->dev, \"bind driver %s\\n\", driver->function);\n\tpm_runtime_get_sync(mtu->dev);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tmtu->softconnect = 0;\n\tmtu->gadget_driver = driver;\n\n\tif (mtu->ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\tmtu3_start(mtu);\n\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\tpm_runtime_put(mtu->dev);\n\n\treturn 0;\n}\n\nstatic void stop_activity(struct mtu3 *mtu)\n{\n\tstruct usb_gadget_driver *driver = mtu->gadget_driver;\n\tint i;\n\n\t \n\tif (mtu->g.speed == USB_SPEED_UNKNOWN)\n\t\tdriver = NULL;\n\telse\n\t\tmtu->g.speed = USB_SPEED_UNKNOWN;\n\n\t \n\tif (mtu->softconnect) {\n\t\tmtu->softconnect = 0;\n\t\tmtu3_dev_on_off(mtu, 0);\n\t}\n\n\t \n\tnuke(mtu->ep0, -ESHUTDOWN);\n\tfor (i = 1; i < mtu->num_eps; i++) {\n\t\tnuke(mtu->in_eps + i, -ESHUTDOWN);\n\t\tnuke(mtu->out_eps + i, -ESHUTDOWN);\n\t}\n\n\tif (driver) {\n\t\tspin_unlock(&mtu->lock);\n\t\tdriver->disconnect(&mtu->g);\n\t\tspin_lock(&mtu->lock);\n\t}\n}\n\nstatic int mtu3_gadget_stop(struct usb_gadget *g)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(g);\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tstop_activity(mtu);\n\tmtu->gadget_driver = NULL;\n\n\tif (mtu->ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\tmtu3_stop(mtu);\n\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\tsynchronize_irq(mtu->irq);\n\treturn 0;\n}\n\nstatic void\nmtu3_gadget_set_speed(struct usb_gadget *g, enum usb_device_speed speed)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(g);\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s %s\\n\", __func__, usb_speed_string(speed));\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tmtu->speed = speed;\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n}\n\nstatic void mtu3_gadget_async_callbacks(struct usb_gadget *g, bool enable)\n{\n\tstruct mtu3 *mtu = gadget_to_mtu3(g);\n\tunsigned long flags;\n\n\tdev_dbg(mtu->dev, \"%s %s\\n\", __func__, enable ? \"en\" : \"dis\");\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tmtu->async_callbacks = enable;\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n}\n\nstatic const struct usb_gadget_ops mtu3_gadget_ops = {\n\t.get_frame = mtu3_gadget_get_frame,\n\t.wakeup = mtu3_gadget_wakeup,\n\t.set_selfpowered = mtu3_gadget_set_self_powered,\n\t.pullup = mtu3_gadget_pullup,\n\t.udc_start = mtu3_gadget_start,\n\t.udc_stop = mtu3_gadget_stop,\n\t.udc_set_speed = mtu3_gadget_set_speed,\n\t.udc_async_callbacks = mtu3_gadget_async_callbacks,\n};\n\nstatic void mtu3_state_reset(struct mtu3 *mtu)\n{\n\tmtu->address = 0;\n\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\tmtu->may_wakeup = 0;\n\tmtu->u1_enable = 0;\n\tmtu->u2_enable = 0;\n\tmtu->delayed_status = false;\n\tmtu->test_mode = false;\n}\n\nstatic void init_hw_ep(struct mtu3 *mtu, struct mtu3_ep *mep,\n\t\tu32 epnum, u32 is_in)\n{\n\tmep->epnum = epnum;\n\tmep->mtu = mtu;\n\tmep->is_in = is_in;\n\n\tINIT_LIST_HEAD(&mep->req_list);\n\n\tsprintf(mep->name, \"ep%d%s\", epnum,\n\t\t!epnum ? \"\" : (is_in ? \"in\" : \"out\"));\n\n\tmep->ep.name = mep->name;\n\tINIT_LIST_HEAD(&mep->ep.ep_list);\n\n\t \n\tif (!epnum) {\n\t\tusb_ep_set_maxpacket_limit(&mep->ep, 512);\n\t\tmep->ep.caps.type_control = true;\n\t\tmep->ep.ops = &mtu3_ep0_ops;\n\t\tmtu->g.ep0 = &mep->ep;\n\t} else {\n\t\tusb_ep_set_maxpacket_limit(&mep->ep, 1024);\n\t\tmep->ep.caps.type_iso = true;\n\t\tmep->ep.caps.type_bulk = true;\n\t\tmep->ep.caps.type_int = true;\n\t\tmep->ep.ops = &mtu3_ep_ops;\n\t\tlist_add_tail(&mep->ep.ep_list, &mtu->g.ep_list);\n\t}\n\n\tdev_dbg(mtu->dev, \"%s, name=%s, maxp=%d\\n\", __func__, mep->ep.name,\n\t\t mep->ep.maxpacket);\n\n\tif (!epnum) {\n\t\tmep->ep.caps.dir_in = true;\n\t\tmep->ep.caps.dir_out = true;\n\t} else if (is_in) {\n\t\tmep->ep.caps.dir_in = true;\n\t} else {\n\t\tmep->ep.caps.dir_out = true;\n\t}\n}\n\nstatic void mtu3_gadget_init_eps(struct mtu3 *mtu)\n{\n\tu8 epnum;\n\n\t \n\tINIT_LIST_HEAD(&(mtu->g.ep_list));\n\n\tdev_dbg(mtu->dev, \"%s num_eps(1 for a pair of tx&rx ep)=%d\\n\",\n\t\t__func__, mtu->num_eps);\n\n\tinit_hw_ep(mtu, mtu->ep0, 0, 0);\n\tfor (epnum = 1; epnum < mtu->num_eps; epnum++) {\n\t\tinit_hw_ep(mtu, mtu->in_eps + epnum, epnum, 1);\n\t\tinit_hw_ep(mtu, mtu->out_eps + epnum, epnum, 0);\n\t}\n}\n\nint mtu3_gadget_setup(struct mtu3 *mtu)\n{\n\tmtu->g.ops = &mtu3_gadget_ops;\n\tmtu->g.max_speed = mtu->max_speed;\n\tmtu->g.speed = USB_SPEED_UNKNOWN;\n\tmtu->g.sg_supported = 0;\n\tmtu->g.name = MTU3_DRIVER_NAME;\n\tmtu->g.irq = mtu->irq;\n\tmtu->is_active = 0;\n\tmtu->delayed_status = false;\n\n\tmtu3_gadget_init_eps(mtu);\n\n\treturn usb_add_gadget_udc(mtu->dev, &mtu->g);\n}\n\nvoid mtu3_gadget_cleanup(struct mtu3 *mtu)\n{\n\tusb_del_gadget_udc(&mtu->g);\n}\n\nvoid mtu3_gadget_resume(struct mtu3 *mtu)\n{\n\tdev_dbg(mtu->dev, \"gadget RESUME\\n\");\n\tif (mtu->async_callbacks && mtu->gadget_driver && mtu->gadget_driver->resume) {\n\t\tspin_unlock(&mtu->lock);\n\t\tmtu->gadget_driver->resume(&mtu->g);\n\t\tspin_lock(&mtu->lock);\n\t}\n}\n\n \nvoid mtu3_gadget_suspend(struct mtu3 *mtu)\n{\n\tdev_dbg(mtu->dev, \"gadget SUSPEND\\n\");\n\tif (mtu->async_callbacks && mtu->gadget_driver && mtu->gadget_driver->suspend) {\n\t\tspin_unlock(&mtu->lock);\n\t\tmtu->gadget_driver->suspend(&mtu->g);\n\t\tspin_lock(&mtu->lock);\n\t}\n}\n\n \nvoid mtu3_gadget_disconnect(struct mtu3 *mtu)\n{\n\tdev_dbg(mtu->dev, \"gadget DISCONNECT\\n\");\n\tif (mtu->async_callbacks && mtu->gadget_driver && mtu->gadget_driver->disconnect) {\n\t\tspin_unlock(&mtu->lock);\n\t\tmtu->gadget_driver->disconnect(&mtu->g);\n\t\tspin_lock(&mtu->lock);\n\t}\n\n\tmtu3_state_reset(mtu);\n\tusb_gadget_set_state(&mtu->g, USB_STATE_NOTATTACHED);\n}\n\nvoid mtu3_gadget_reset(struct mtu3 *mtu)\n{\n\tdev_dbg(mtu->dev, \"gadget RESET\\n\");\n\n\t \n\tif (mtu->g.speed != USB_SPEED_UNKNOWN)\n\t\tmtu3_gadget_disconnect(mtu);\n\telse\n\t\tmtu3_state_reset(mtu);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}