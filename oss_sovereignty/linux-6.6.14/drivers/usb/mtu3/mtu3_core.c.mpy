{
  "module_name": "mtu3_core.c",
  "hash_id": "32314c52dad9ea14348385545cce4f77c41e67add52205fd8c28e39dbbb5e070",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_core.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\n#include \"mtu3.h\"\n#include \"mtu3_dr.h\"\n#include \"mtu3_debug.h\"\n#include \"mtu3_trace.h\"\n\nstatic int ep_fifo_alloc(struct mtu3_ep *mep, u32 seg_size)\n{\n\tstruct mtu3_fifo_info *fifo = mep->fifo;\n\tu32 num_bits = DIV_ROUND_UP(seg_size, MTU3_EP_FIFO_UNIT);\n\tu32 start_bit;\n\n\t \n\tnum_bits = roundup_pow_of_two(num_bits);\n\tif (num_bits > fifo->limit)\n\t\treturn -EINVAL;\n\n\tmep->fifo_seg_size = num_bits * MTU3_EP_FIFO_UNIT;\n\tnum_bits = num_bits * (mep->slot + 1);\n\tstart_bit = bitmap_find_next_zero_area(fifo->bitmap,\n\t\t\tfifo->limit, 0, num_bits, 0);\n\tif (start_bit >= fifo->limit)\n\t\treturn -EOVERFLOW;\n\n\tbitmap_set(fifo->bitmap, start_bit, num_bits);\n\tmep->fifo_size = num_bits * MTU3_EP_FIFO_UNIT;\n\tmep->fifo_addr = fifo->base + MTU3_EP_FIFO_UNIT * start_bit;\n\n\tdev_dbg(mep->mtu->dev, \"%s fifo:%#x/%#x, start_bit: %d\\n\",\n\t\t__func__, mep->fifo_seg_size, mep->fifo_size, start_bit);\n\n\treturn mep->fifo_addr;\n}\n\nstatic void ep_fifo_free(struct mtu3_ep *mep)\n{\n\tstruct mtu3_fifo_info *fifo = mep->fifo;\n\tu32 addr = mep->fifo_addr;\n\tu32 bits = mep->fifo_size / MTU3_EP_FIFO_UNIT;\n\tu32 start_bit;\n\n\tif (unlikely(addr < fifo->base || bits > fifo->limit))\n\t\treturn;\n\n\tstart_bit = (addr - fifo->base) / MTU3_EP_FIFO_UNIT;\n\tbitmap_clear(fifo->bitmap, start_bit, bits);\n\tmep->fifo_size = 0;\n\tmep->fifo_seg_size = 0;\n\n\tdev_dbg(mep->mtu->dev, \"%s size:%#x/%#x, start_bit: %d\\n\",\n\t\t__func__, mep->fifo_seg_size, mep->fifo_size, start_bit);\n}\n\n \nstatic inline void mtu3_ss_func_set(struct mtu3 *mtu, bool enable)\n{\n\t \n\tif (enable)\n\t\tmtu3_setbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);\n\telse\n\t\tmtu3_clrbits(mtu->mac_base, U3D_USB3_CONFIG, USB3_EN);\n\n\tdev_dbg(mtu->dev, \"USB3_EN = %d\\n\", !!enable);\n}\n\n \nstatic inline void mtu3_hs_softconn_set(struct mtu3 *mtu, bool enable)\n{\n\tif (enable) {\n\t\tmtu3_setbits(mtu->mac_base, U3D_POWER_MANAGEMENT,\n\t\t\tSOFT_CONN | SUSPENDM_ENABLE);\n\t} else {\n\t\tmtu3_clrbits(mtu->mac_base, U3D_POWER_MANAGEMENT,\n\t\t\tSOFT_CONN | SUSPENDM_ENABLE);\n\t}\n\tdev_dbg(mtu->dev, \"SOFTCONN = %d\\n\", !!enable);\n}\n\n \nstatic int mtu3_device_enable(struct mtu3 *mtu)\n{\n\tvoid __iomem *ibase = mtu->ippc_base;\n\tu32 check_clk = 0;\n\n\tmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\n\n\tif (mtu->u3_capable) {\n\t\tcheck_clk = SSUSB_U3_MAC_RST_B_STS;\n\t\tmtu3_clrbits(ibase, SSUSB_U3_CTRL(0),\n\t\t\t(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN |\n\t\t\tSSUSB_U3_PORT_HOST_SEL));\n\t}\n\tmtu3_clrbits(ibase, SSUSB_U2_CTRL(0),\n\t\t(SSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN |\n\t\tSSUSB_U2_PORT_HOST_SEL));\n\n\tif (mtu->ssusb->dr_mode == USB_DR_MODE_OTG) {\n\t\tmtu3_setbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);\n\t\tif (mtu->u3_capable)\n\t\t\tmtu3_setbits(ibase, SSUSB_U3_CTRL(0),\n\t\t\t\t     SSUSB_U3_PORT_DUAL_MODE);\n\t}\n\n\treturn ssusb_check_clocks(mtu->ssusb, check_clk);\n}\n\nstatic void mtu3_device_disable(struct mtu3 *mtu)\n{\n\tvoid __iomem *ibase = mtu->ippc_base;\n\n\tif (mtu->u3_capable)\n\t\tmtu3_setbits(ibase, SSUSB_U3_CTRL(0),\n\t\t\t(SSUSB_U3_PORT_DIS | SSUSB_U3_PORT_PDN));\n\n\tmtu3_setbits(ibase, SSUSB_U2_CTRL(0),\n\t\tSSUSB_U2_PORT_DIS | SSUSB_U2_PORT_PDN);\n\n\tif (mtu->ssusb->dr_mode == USB_DR_MODE_OTG) {\n\t\tmtu3_clrbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_OTG_SEL);\n\t\tif (mtu->u3_capable)\n\t\t\tmtu3_clrbits(ibase, SSUSB_U3_CTRL(0),\n\t\t\t\t     SSUSB_U3_PORT_DUAL_MODE);\n\t}\n\n\tmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\n}\n\nstatic void mtu3_dev_power_on(struct mtu3 *mtu)\n{\n\tvoid __iomem *ibase = mtu->ippc_base;\n\n\tmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\n\tif (mtu->u3_capable)\n\t\tmtu3_clrbits(ibase, SSUSB_U3_CTRL(0), SSUSB_U3_PORT_PDN);\n\n\tmtu3_clrbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_PDN);\n}\n\nstatic void mtu3_dev_power_down(struct mtu3 *mtu)\n{\n\tvoid __iomem *ibase = mtu->ippc_base;\n\n\tif (mtu->u3_capable)\n\t\tmtu3_setbits(ibase, SSUSB_U3_CTRL(0), SSUSB_U3_PORT_PDN);\n\n\tmtu3_setbits(ibase, SSUSB_U2_CTRL(0), SSUSB_U2_PORT_PDN);\n\tmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\n}\n\n \nstatic void mtu3_device_reset(struct mtu3 *mtu)\n{\n\tvoid __iomem *ibase = mtu->ippc_base;\n\n\tmtu3_setbits(ibase, U3D_SSUSB_DEV_RST_CTRL, SSUSB_DEV_SW_RST);\n\tudelay(1);\n\tmtu3_clrbits(ibase, U3D_SSUSB_DEV_RST_CTRL, SSUSB_DEV_SW_RST);\n}\n\nstatic void mtu3_intr_status_clear(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\t \n\tmtu3_writel(mbase, U3D_EPISR, ~0x0);\n\t \n\tmtu3_writel(mbase, U3D_COMMON_USB_INTR, ~0x0);\n\t \n\tmtu3_writel(mbase, U3D_LTSSM_INTR, ~0x0);\n\t \n\tmtu3_writel(mbase, U3D_DEV_LINK_INTR, ~0x0);\n\t \n\tmtu3_writel(mbase, U3D_QISAR0, ~0x0);\n}\n\n \nstatic void mtu3_intr_disable(struct mtu3 *mtu)\n{\n\t \n\tmtu3_writel(mtu->mac_base, U3D_LV1IECR, ~0x0);\n\t \n\tmtu3_writel(mtu->mac_base, U3D_EPIECR, ~0x0);\n\tmtu3_intr_status_clear(mtu);\n}\n\n \nstatic void mtu3_intr_enable(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 value;\n\n\t \n\tvalue = BMU_INTR | QMU_INTR | MAC3_INTR | MAC2_INTR | EP_CTRL_INTR;\n\tmtu3_writel(mbase, U3D_LV1IESR, value);\n\n\t \n\tvalue = SUSPEND_INTR | RESUME_INTR | RESET_INTR;\n\tmtu3_writel(mbase, U3D_COMMON_USB_INTR_ENABLE, value);\n\n\tif (mtu->u3_capable) {\n\t\t \n\t\tvalue = HOT_RST_INTR | WARM_RST_INTR |\n\t\t\tENTER_U3_INTR | EXIT_U3_INTR;\n\t\tmtu3_writel(mbase, U3D_LTSSM_INTR_ENABLE, value);\n\t}\n\n\t \n\tvalue = TXQ_CSERR_INT | TXQ_LENERR_INT | RXQ_CSERR_INT |\n\t\t\tRXQ_LENERR_INT | RXQ_ZLPERR_INT;\n\tmtu3_writel(mbase, U3D_QIESR1, value);\n\n\t \n\tmtu3_writel(mbase, U3D_DEV_LINK_INTR_ENABLE, SSUSB_DEV_SPEED_CHG_INTR);\n}\n\nstatic void mtu3_set_speed(struct mtu3 *mtu, enum usb_device_speed speed)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\tif (speed > mtu->max_speed)\n\t\tspeed = mtu->max_speed;\n\n\tswitch (speed) {\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tmtu3_clrbits(mbase, U3D_USB3_CONFIG, USB3_EN);\n\t\t \n\t\tmtu3_clrbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tmtu3_clrbits(mbase, U3D_USB3_CONFIG, USB3_EN);\n\t\t \n\t\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\n\t\tmtu3_clrbits(mtu->ippc_base, SSUSB_U3_CTRL(0),\n\t\t\t     SSUSB_U3_PORT_SSP_SPEED);\n\t\tbreak;\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT, HS_ENABLE);\n\t\tmtu3_setbits(mtu->ippc_base, SSUSB_U3_CTRL(0),\n\t\t\t     SSUSB_U3_PORT_SSP_SPEED);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mtu->dev, \"invalid speed: %s\\n\",\n\t\t\tusb_speed_string(speed));\n\t\treturn;\n\t}\n\n\tmtu->speed = speed;\n\tdev_dbg(mtu->dev, \"set speed: %s\\n\", usb_speed_string(speed));\n}\n\n \nstatic void mtu3_csr_init(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\tif (mtu->u3_capable) {\n\t\t \n\t\tmtu3_clrbits(mbase, U3D_LINK_POWER_CONTROL,\n\t\t\t\tSW_U1_REQUEST_ENABLE | SW_U2_REQUEST_ENABLE);\n\t\t \n\t\tmtu3_setbits(mbase, U3D_LINK_POWER_CONTROL,\n\t\t\t\tSW_U1_ACCEPT_ENABLE | SW_U2_ACCEPT_ENABLE);\n\t\t \n\t\tmtu3_clrbits(mbase, U3D_LTSSM_CTRL, SOFT_U3_EXIT_EN);\n\t\t \n\t\tmtu3_setbits(mbase, U3D_USB2_TEST_MODE, U2U3_AUTO_SWITCH);\n\t\t \n\t\tmtu3_setbits(mbase, U3D_U3U2_SWITCH_CTRL, SOFTCON_CLR_AUTO_EN);\n\t}\n\n\t \n\tmtu3_clrbits(mbase, U3D_LINK_RESET_INFO, WTCHRP_MSK);\n\t \n\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT, LPM_HRWE);\n}\n\n \nstatic void mtu3_ep_reset(struct mtu3_ep *mep)\n{\n\tstruct mtu3 *mtu = mep->mtu;\n\tu32 rst_bit = EP_RST(mep->is_in, mep->epnum);\n\n\tmtu3_setbits(mtu->mac_base, U3D_EP_RST, rst_bit);\n\tmtu3_clrbits(mtu->mac_base, U3D_EP_RST, rst_bit);\n}\n\n \nvoid mtu3_ep_stall_set(struct mtu3_ep *mep, bool set)\n{\n\tstruct mtu3 *mtu = mep->mtu;\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu8 epnum = mep->epnum;\n\tu32 csr;\n\n\tif (mep->is_in) {\t \n\t\tcsr = mtu3_readl(mbase, MU3D_EP_TXCR0(epnum)) & TX_W1C_BITS;\n\t\tif (set)\n\t\t\tcsr |= TX_SENDSTALL;\n\t\telse\n\t\t\tcsr = (csr & (~TX_SENDSTALL)) | TX_SENTSTALL;\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), csr);\n\t} else {\t \n\t\tcsr = mtu3_readl(mbase, MU3D_EP_RXCR0(epnum)) & RX_W1C_BITS;\n\t\tif (set)\n\t\t\tcsr |= RX_SENDSTALL;\n\t\telse\n\t\t\tcsr = (csr & (~RX_SENDSTALL)) | RX_SENTSTALL;\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), csr);\n\t}\n\n\tif (!set) {\n\t\tmtu3_ep_reset(mep);\n\t\tmep->flags &= ~MTU3_EP_STALL;\n\t} else {\n\t\tmep->flags |= MTU3_EP_STALL;\n\t}\n\n\tdev_dbg(mtu->dev, \"%s: %s\\n\", mep->name,\n\t\tset ? \"SEND STALL\" : \"CLEAR STALL, with EP RESET\");\n}\n\nvoid mtu3_dev_on_off(struct mtu3 *mtu, int is_on)\n{\n\tif (mtu->u3_capable && mtu->speed >= USB_SPEED_SUPER)\n\t\tmtu3_ss_func_set(mtu, is_on);\n\telse\n\t\tmtu3_hs_softconn_set(mtu, is_on);\n\n\tdev_info(mtu->dev, \"gadget (%s) pullup D%s\\n\",\n\t\tusb_speed_string(mtu->speed), is_on ? \"+\" : \"-\");\n}\n\nvoid mtu3_start(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\tdev_dbg(mtu->dev, \"%s devctl 0x%x\\n\", __func__,\n\t\tmtu3_readl(mbase, U3D_DEVICE_CONTROL));\n\n\tmtu3_dev_power_on(mtu);\n\tmtu3_csr_init(mtu);\n\tmtu3_set_speed(mtu, mtu->speed);\n\n\t \n\tmtu3_intr_enable(mtu);\n\tmtu->is_active = 1;\n\n\tif (mtu->softconnect)\n\t\tmtu3_dev_on_off(mtu, 1);\n}\n\nvoid mtu3_stop(struct mtu3 *mtu)\n{\n\tdev_dbg(mtu->dev, \"%s\\n\", __func__);\n\n\tmtu3_intr_disable(mtu);\n\n\tif (mtu->softconnect)\n\t\tmtu3_dev_on_off(mtu, 0);\n\n\tmtu->is_active = 0;\n\tmtu3_dev_power_down(mtu);\n}\n\nstatic void mtu3_dev_suspend(struct mtu3 *mtu)\n{\n\tif (!mtu->is_active)\n\t\treturn;\n\n\tmtu3_intr_disable(mtu);\n\tmtu3_dev_power_down(mtu);\n}\n\nstatic void mtu3_dev_resume(struct mtu3 *mtu)\n{\n\tif (!mtu->is_active)\n\t\treturn;\n\n\tmtu3_dev_power_on(mtu);\n\tmtu3_intr_enable(mtu);\n}\n\n \nint mtu3_config_ep(struct mtu3 *mtu, struct mtu3_ep *mep,\n\t\t\tint interval, int burst, int mult)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tbool gen2cp = mtu->gen2cp;\n\tint epnum = mep->epnum;\n\tu32 csr0, csr1, csr2;\n\tint fifo_sgsz, fifo_addr;\n\tint num_pkts;\n\n\tfifo_addr = ep_fifo_alloc(mep, mep->maxp);\n\tif (fifo_addr < 0) {\n\t\tdev_err(mtu->dev, \"alloc ep fifo failed(%d)\\n\", mep->maxp);\n\t\treturn -ENOMEM;\n\t}\n\tfifo_sgsz = ilog2(mep->fifo_seg_size);\n\tdev_dbg(mtu->dev, \"%s fifosz: %x(%x/%x)\\n\", __func__, fifo_sgsz,\n\t\tmep->fifo_seg_size, mep->fifo_size);\n\n\tif (mep->is_in) {\n\t\tcsr0 = TX_TXMAXPKTSZ(mep->maxp);\n\t\tcsr0 |= TX_DMAREQEN;\n\n\t\tnum_pkts = (burst + 1) * (mult + 1) - 1;\n\t\tcsr1 = TX_SS_BURST(burst) | TX_SLOT(mep->slot);\n\t\tcsr1 |= TX_MAX_PKT(gen2cp, num_pkts) | TX_MULT(gen2cp, mult);\n\n\t\tcsr2 = TX_FIFOADDR(fifo_addr >> 4);\n\t\tcsr2 |= TX_FIFOSEGSIZE(fifo_sgsz);\n\n\t\tswitch (mep->type) {\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tcsr1 |= TX_TYPE(TYPE_BULK);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcsr1 |= TX_TYPE(TYPE_ISO);\n\t\t\tcsr2 |= TX_BINTERVAL(interval);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tcsr1 |= TX_TYPE(TYPE_INT);\n\t\t\tcsr2 |= TX_BINTERVAL(interval);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmtu3_setbits(mbase, U3D_QIESR0, QMU_TX_DONE_INT(epnum));\n\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), csr0);\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR1(epnum), csr1);\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR2(epnum), csr2);\n\n\t\tdev_dbg(mtu->dev, \"U3D_TX%d CSR0:%#x, CSR1:%#x, CSR2:%#x\\n\",\n\t\t\tepnum, mtu3_readl(mbase, MU3D_EP_TXCR0(epnum)),\n\t\t\tmtu3_readl(mbase, MU3D_EP_TXCR1(epnum)),\n\t\t\tmtu3_readl(mbase, MU3D_EP_TXCR2(epnum)));\n\t} else {\n\t\tcsr0 = RX_RXMAXPKTSZ(mep->maxp);\n\t\tcsr0 |= RX_DMAREQEN;\n\n\t\tnum_pkts = (burst + 1) * (mult + 1) - 1;\n\t\tcsr1 = RX_SS_BURST(burst) | RX_SLOT(mep->slot);\n\t\tcsr1 |= RX_MAX_PKT(gen2cp, num_pkts) | RX_MULT(gen2cp, mult);\n\n\t\tcsr2 = RX_FIFOADDR(fifo_addr >> 4);\n\t\tcsr2 |= RX_FIFOSEGSIZE(fifo_sgsz);\n\n\t\tswitch (mep->type) {\n\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\tcsr1 |= RX_TYPE(TYPE_BULK);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcsr1 |= RX_TYPE(TYPE_ISO);\n\t\t\tcsr2 |= RX_BINTERVAL(interval);\n\t\t\tbreak;\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\tcsr1 |= RX_TYPE(TYPE_INT);\n\t\t\tcsr2 |= RX_BINTERVAL(interval);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmtu3_setbits(mbase, U3D_QIESR0, QMU_RX_DONE_INT(epnum));\n\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), csr0);\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR1(epnum), csr1);\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR2(epnum), csr2);\n\n\t\tdev_dbg(mtu->dev, \"U3D_RX%d CSR0:%#x, CSR1:%#x, CSR2:%#x\\n\",\n\t\t\tepnum, mtu3_readl(mbase, MU3D_EP_RXCR0(epnum)),\n\t\t\tmtu3_readl(mbase, MU3D_EP_RXCR1(epnum)),\n\t\t\tmtu3_readl(mbase, MU3D_EP_RXCR2(epnum)));\n\t}\n\n\tdev_dbg(mtu->dev, \"csr0:%#x, csr1:%#x, csr2:%#x\\n\", csr0, csr1, csr2);\n\tdev_dbg(mtu->dev, \"%s: %s, fifo-addr:%#x, fifo-size:%#x(%#x/%#x)\\n\",\n\t\t__func__, mep->name, mep->fifo_addr, mep->fifo_size,\n\t\tfifo_sgsz, mep->fifo_seg_size);\n\n\treturn 0;\n}\n\n \nvoid mtu3_deconfig_ep(struct mtu3 *mtu, struct mtu3_ep *mep)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tint epnum = mep->epnum;\n\n\tif (mep->is_in) {\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR0(epnum), 0);\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR1(epnum), 0);\n\t\tmtu3_writel(mbase, MU3D_EP_TXCR2(epnum), 0);\n\t\tmtu3_setbits(mbase, U3D_QIECR0, QMU_TX_DONE_INT(epnum));\n\t} else {\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR0(epnum), 0);\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR1(epnum), 0);\n\t\tmtu3_writel(mbase, MU3D_EP_RXCR2(epnum), 0);\n\t\tmtu3_setbits(mbase, U3D_QIECR0, QMU_RX_DONE_INT(epnum));\n\t}\n\n\tmtu3_ep_reset(mep);\n\tep_fifo_free(mep);\n\n\tdev_dbg(mtu->dev, \"%s: %s\\n\", __func__, mep->name);\n}\n\n \nstatic void get_ep_fifo_config(struct mtu3 *mtu)\n{\n\tstruct mtu3_fifo_info *tx_fifo;\n\tstruct mtu3_fifo_info *rx_fifo;\n\tu32 fifosize;\n\n\tif (mtu->separate_fifo) {\n\t\tfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNTXFFSZ);\n\t\ttx_fifo = &mtu->tx_fifo;\n\t\ttx_fifo->base = 0;\n\t\ttx_fifo->limit = fifosize / MTU3_EP_FIFO_UNIT;\n\t\tbitmap_zero(tx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\n\n\t\tfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNRXFFSZ);\n\t\trx_fifo = &mtu->rx_fifo;\n\t\trx_fifo->base = 0;\n\t\trx_fifo->limit = fifosize / MTU3_EP_FIFO_UNIT;\n\t\tbitmap_zero(rx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\n\t\tmtu->slot = MTU3_U3_IP_SLOT_DEFAULT;\n\t} else {\n\t\tfifosize = mtu3_readl(mtu->mac_base, U3D_CAP_EPNTXFFSZ);\n\t\ttx_fifo = &mtu->tx_fifo;\n\t\ttx_fifo->base = MTU3_U2_IP_EP0_FIFO_SIZE;\n\t\ttx_fifo->limit = (fifosize / MTU3_EP_FIFO_UNIT) >> 1;\n\t\tbitmap_zero(tx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\n\n\t\trx_fifo = &mtu->rx_fifo;\n\t\trx_fifo->base =\n\t\t\ttx_fifo->base + tx_fifo->limit * MTU3_EP_FIFO_UNIT;\n\t\trx_fifo->limit = tx_fifo->limit;\n\t\tbitmap_zero(rx_fifo->bitmap, MTU3_FIFO_BIT_SIZE);\n\t\tmtu->slot = MTU3_U2_IP_SLOT_DEFAULT;\n\t}\n\n\tdev_dbg(mtu->dev, \"%s, TX: base-%d, limit-%d; RX: base-%d, limit-%d\\n\",\n\t\t__func__, tx_fifo->base, tx_fifo->limit,\n\t\trx_fifo->base, rx_fifo->limit);\n}\n\nstatic void mtu3_ep0_setup(struct mtu3 *mtu)\n{\n\tu32 maxpacket = mtu->g.ep0->maxpacket;\n\tu32 csr;\n\n\tdev_dbg(mtu->dev, \"%s maxpacket: %d\\n\", __func__, maxpacket);\n\n\tcsr = mtu3_readl(mtu->mac_base, U3D_EP0CSR);\n\tcsr &= ~EP0_MAXPKTSZ_MSK;\n\tcsr |= EP0_MAXPKTSZ(maxpacket);\n\tcsr &= EP0_W1C_BITS;\n\tmtu3_writel(mtu->mac_base, U3D_EP0CSR, csr);\n\n\t \n\tmtu3_writel(mtu->mac_base, U3D_EPIESR, EP0ISR | SETUPENDISR);\n}\n\nstatic int mtu3_mem_alloc(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tstruct mtu3_ep *ep_array;\n\tint in_ep_num, out_ep_num;\n\tu32 cap_epinfo;\n\tint ret;\n\tint i;\n\n\tcap_epinfo = mtu3_readl(mbase, U3D_CAP_EPINFO);\n\tin_ep_num = CAP_TX_EP_NUM(cap_epinfo);\n\tout_ep_num = CAP_RX_EP_NUM(cap_epinfo);\n\n\tdev_info(mtu->dev, \"fifosz/epnum: Tx=%#x/%d, Rx=%#x/%d\\n\",\n\t\t mtu3_readl(mbase, U3D_CAP_EPNTXFFSZ), in_ep_num,\n\t\t mtu3_readl(mbase, U3D_CAP_EPNRXFFSZ), out_ep_num);\n\n\t \n\tmtu->num_eps = min(in_ep_num, out_ep_num) + 1;\n\tep_array = kcalloc(mtu->num_eps * 2, sizeof(*ep_array), GFP_KERNEL);\n\tif (ep_array == NULL)\n\t\treturn -ENOMEM;\n\n\tmtu->ep_array = ep_array;\n\tmtu->in_eps = ep_array;\n\tmtu->out_eps = &ep_array[mtu->num_eps];\n\t \n\tmtu->ep0 = mtu->in_eps;\n\tmtu->ep0->mtu = mtu;\n\tmtu->ep0->epnum = 0;\n\n\tfor (i = 1; i < mtu->num_eps; i++) {\n\t\tstruct mtu3_ep *mep = mtu->in_eps + i;\n\n\t\tmep->fifo = &mtu->tx_fifo;\n\t\tmep = mtu->out_eps + i;\n\t\tmep->fifo = &mtu->rx_fifo;\n\t}\n\n\tget_ep_fifo_config(mtu);\n\n\tret = mtu3_qmu_init(mtu);\n\tif (ret)\n\t\tkfree(mtu->ep_array);\n\n\treturn ret;\n}\n\nstatic void mtu3_mem_free(struct mtu3 *mtu)\n{\n\tmtu3_qmu_exit(mtu);\n\tkfree(mtu->ep_array);\n}\n\nstatic void mtu3_regs_init(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\t \n\tmtu3_intr_disable(mtu);\n\n\tmtu3_csr_init(mtu);\n\n\t \n\tmtu3_writel(mbase, U3D_DEVICE_CONF, 0);\n\t \n\tmtu3_clrbits(mbase, U3D_MISC_CTRL, VBUS_FRC_EN | VBUS_ON);\n\t \n\tif (mtu->gen2cp)\n\t\tmtu3_writel(mbase, U3D_QFCR, ~0x0);\n}\n\nstatic irqreturn_t mtu3_link_isr(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tenum usb_device_speed udev_speed;\n\tu32 maxpkt = 64;\n\tu32 link;\n\tu32 speed;\n\n\tlink = mtu3_readl(mbase, U3D_DEV_LINK_INTR);\n\tlink &= mtu3_readl(mbase, U3D_DEV_LINK_INTR_ENABLE);\n\tmtu3_writel(mbase, U3D_DEV_LINK_INTR, link);  \n\tdev_dbg(mtu->dev, \"=== LINK[%x] ===\\n\", link);\n\n\tif (!(link & SSUSB_DEV_SPEED_CHG_INTR))\n\t\treturn IRQ_NONE;\n\n\tspeed = SSUSB_DEV_SPEED(mtu3_readl(mbase, U3D_DEVICE_CONF));\n\n\tswitch (speed) {\n\tcase MTU3_SPEED_FULL:\n\t\tudev_speed = USB_SPEED_FULL;\n\t\t \n\t\tmtu3_writel(mbase, U3D_USB20_LPM_PARAMETER, LPM_BESLDCK(0xf)\n\t\t\t\t| LPM_BESLCK(4) | LPM_BESLCK_U3(0xa));\n\t\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT,\n\t\t\t\tLPM_BESL_STALL | LPM_BESLD_STALL);\n\t\tbreak;\n\tcase MTU3_SPEED_HIGH:\n\t\tudev_speed = USB_SPEED_HIGH;\n\t\t \n\t\tmtu3_writel(mbase, U3D_USB20_LPM_PARAMETER, LPM_BESLDCK(0xf)\n\t\t\t\t| LPM_BESLCK(4) | LPM_BESLCK_U3(0xa));\n\t\tmtu3_setbits(mbase, U3D_POWER_MANAGEMENT,\n\t\t\t\tLPM_BESL_STALL | LPM_BESLD_STALL);\n\t\tbreak;\n\tcase MTU3_SPEED_SUPER:\n\t\tudev_speed = USB_SPEED_SUPER;\n\t\tmaxpkt = 512;\n\t\tbreak;\n\tcase MTU3_SPEED_SUPER_PLUS:\n\t\tudev_speed = USB_SPEED_SUPER_PLUS;\n\t\tmaxpkt = 512;\n\t\tbreak;\n\tdefault:\n\t\tudev_speed = USB_SPEED_UNKNOWN;\n\t\tbreak;\n\t}\n\tdev_dbg(mtu->dev, \"%s: %s\\n\", __func__, usb_speed_string(udev_speed));\n\tmtu3_dbg_trace(mtu->dev, \"link speed %s\",\n\t\t       usb_speed_string(udev_speed));\n\n\tmtu->g.speed = udev_speed;\n\tmtu->g.ep0->maxpacket = maxpkt;\n\tmtu->ep0_state = MU3D_EP0_STATE_SETUP;\n\tmtu->connected = !!(udev_speed != USB_SPEED_UNKNOWN);\n\n\tif (udev_speed == USB_SPEED_UNKNOWN) {\n\t\tmtu3_gadget_disconnect(mtu);\n\t\tpm_runtime_put(mtu->dev);\n\t} else {\n\t\tpm_runtime_get(mtu->dev);\n\t\tmtu3_ep0_setup(mtu);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtu3_u3_ltssm_isr(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 ltssm;\n\n\tltssm = mtu3_readl(mbase, U3D_LTSSM_INTR);\n\tltssm &= mtu3_readl(mbase, U3D_LTSSM_INTR_ENABLE);\n\tmtu3_writel(mbase, U3D_LTSSM_INTR, ltssm);  \n\tdev_dbg(mtu->dev, \"=== LTSSM[%x] ===\\n\", ltssm);\n\ttrace_mtu3_u3_ltssm_isr(ltssm);\n\n\tif (ltssm & (HOT_RST_INTR | WARM_RST_INTR))\n\t\tmtu3_gadget_reset(mtu);\n\n\tif (ltssm & VBUS_FALL_INTR) {\n\t\tmtu3_ss_func_set(mtu, false);\n\t\tmtu3_gadget_reset(mtu);\n\t}\n\n\tif (ltssm & VBUS_RISE_INTR)\n\t\tmtu3_ss_func_set(mtu, true);\n\n\tif (ltssm & EXIT_U3_INTR)\n\t\tmtu3_gadget_resume(mtu);\n\n\tif (ltssm & ENTER_U3_INTR)\n\t\tmtu3_gadget_suspend(mtu);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtu3_u2_common_isr(struct mtu3 *mtu)\n{\n\tvoid __iomem *mbase = mtu->mac_base;\n\tu32 u2comm;\n\n\tu2comm = mtu3_readl(mbase, U3D_COMMON_USB_INTR);\n\tu2comm &= mtu3_readl(mbase, U3D_COMMON_USB_INTR_ENABLE);\n\tmtu3_writel(mbase, U3D_COMMON_USB_INTR, u2comm);  \n\tdev_dbg(mtu->dev, \"=== U2COMM[%x] ===\\n\", u2comm);\n\ttrace_mtu3_u2_common_isr(u2comm);\n\n\tif (u2comm & SUSPEND_INTR)\n\t\tmtu3_gadget_suspend(mtu);\n\n\tif (u2comm & RESUME_INTR)\n\t\tmtu3_gadget_resume(mtu);\n\n\tif (u2comm & RESET_INTR)\n\t\tmtu3_gadget_reset(mtu);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t mtu3_irq(int irq, void *data)\n{\n\tstruct mtu3 *mtu = (struct mtu3 *)data;\n\tunsigned long flags;\n\tu32 level1;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\t \n\tlevel1 = mtu3_readl(mtu->mac_base, U3D_LV1ISR);\n\tlevel1 &= mtu3_readl(mtu->mac_base, U3D_LV1IER);\n\n\tif (level1 & EP_CTRL_INTR)\n\t\tmtu3_link_isr(mtu);\n\n\tif (level1 & MAC2_INTR)\n\t\tmtu3_u2_common_isr(mtu);\n\n\tif (level1 & MAC3_INTR)\n\t\tmtu3_u3_ltssm_isr(mtu);\n\n\tif (level1 & BMU_INTR)\n\t\tmtu3_ep0_isr(mtu);\n\n\tif (level1 & QMU_INTR)\n\t\tmtu3_qmu_isr(mtu);\n\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void mtu3_check_params(struct mtu3 *mtu)\n{\n\t \n\tif (mtu->u3_capable && (mtu->ssusb->u3p_dis_msk & BIT(0)))\n\t\tmtu->u3_capable = 0;\n\n\t \n\tswitch (mtu->max_speed) {\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tbreak;\n\tdefault:\n\t\tdev_err(mtu->dev, \"invalid max_speed: %s\\n\",\n\t\t\tusb_speed_string(mtu->max_speed));\n\t\tfallthrough;\n\tcase USB_SPEED_UNKNOWN:\n\t\t \n\t\tmtu->max_speed = USB_SPEED_SUPER_PLUS;\n\t\tbreak;\n\t}\n\n\tif (!mtu->u3_capable && (mtu->max_speed > USB_SPEED_HIGH))\n\t\tmtu->max_speed = USB_SPEED_HIGH;\n\n\tmtu->speed = mtu->max_speed;\n\n\tdev_info(mtu->dev, \"max_speed: %s\\n\",\n\t\t usb_speed_string(mtu->max_speed));\n}\n\nstatic int mtu3_hw_init(struct mtu3 *mtu)\n{\n\tu32 value;\n\tint ret;\n\n\tvalue = mtu3_readl(mtu->ippc_base, U3D_SSUSB_IP_TRUNK_VERS);\n\tmtu->hw_version = IP_TRUNK_VERS(value);\n\tmtu->gen2cp = !!(mtu->hw_version >= MTU3_TRUNK_VERS_1003);\n\n\tvalue = mtu3_readl(mtu->ippc_base, U3D_SSUSB_IP_DEV_CAP);\n\tmtu->u3_capable = !!SSUSB_IP_DEV_U3_PORT_NUM(value);\n\t \n\tmtu->separate_fifo = mtu->u3_capable;\n\n\tdev_info(mtu->dev, \"IP version 0x%x(%s IP)\\n\", mtu->hw_version,\n\t\tmtu->u3_capable ? \"U3\" : \"U2\");\n\n\tmtu3_check_params(mtu);\n\n\tmtu3_device_reset(mtu);\n\n\tret = mtu3_device_enable(mtu);\n\tif (ret) {\n\t\tdev_err(mtu->dev, \"device enable failed %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtu3_mem_alloc(mtu);\n\tif (ret)\n\t\treturn -ENOMEM;\n\n\tmtu3_regs_init(mtu);\n\n\treturn 0;\n}\n\nstatic void mtu3_hw_exit(struct mtu3 *mtu)\n{\n\tmtu3_device_disable(mtu);\n\tmtu3_mem_free(mtu);\n}\n\n \nstatic int mtu3_set_dma_mask(struct mtu3 *mtu)\n{\n\tstruct device *dev = mtu->dev;\n\tbool is_36bit = false;\n\tint ret = 0;\n\tu32 value;\n\n\tvalue = mtu3_readl(mtu->mac_base, U3D_MISC_CTRL);\n\tif (value & DMA_ADDR_36BIT) {\n\t\tis_36bit = true;\n\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(36));\n\t\t \n\t\tif (ret) {\n\t\t\tis_36bit = false;\n\t\t\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\t\t}\n\t}\n\tdev_info(dev, \"dma mask: %s bits\\n\", is_36bit ? \"36\" : \"32\");\n\n\treturn ret;\n}\n\nint ssusb_gadget_init(struct ssusb_mtk *ssusb)\n{\n\tstruct device *dev = ssusb->dev;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct mtu3 *mtu = NULL;\n\tint ret = -ENOMEM;\n\n\tmtu = devm_kzalloc(dev, sizeof(struct mtu3), GFP_KERNEL);\n\tif (mtu == NULL)\n\t\treturn -ENOMEM;\n\n\tmtu->irq = platform_get_irq_byname_optional(pdev, \"device\");\n\tif (mtu->irq < 0) {\n\t\tif (mtu->irq == -EPROBE_DEFER)\n\t\t\treturn mtu->irq;\n\n\t\t \n\t\tmtu->irq = platform_get_irq(pdev, 0);\n\t\tif (mtu->irq < 0)\n\t\t\treturn mtu->irq;\n\t}\n\tdev_info(dev, \"irq %d\\n\", mtu->irq);\n\n\tmtu->mac_base = devm_platform_ioremap_resource_byname(pdev, \"mac\");\n\tif (IS_ERR(mtu->mac_base)) {\n\t\tdev_err(dev, \"error mapping memory for dev mac\\n\");\n\t\treturn PTR_ERR(mtu->mac_base);\n\t}\n\n\tspin_lock_init(&mtu->lock);\n\tmtu->dev = dev;\n\tmtu->ippc_base = ssusb->ippc_base;\n\tssusb->mac_base\t= mtu->mac_base;\n\tssusb->u3d = mtu;\n\tmtu->ssusb = ssusb;\n\tmtu->max_speed = usb_get_maximum_speed(dev);\n\n\tdev_dbg(dev, \"mac_base=0x%p, ippc_base=0x%p\\n\",\n\t\tmtu->mac_base, mtu->ippc_base);\n\n\tret = mtu3_hw_init(mtu);\n\tif (ret) {\n\t\tdev_err(dev, \"mtu3 hw init failed:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = mtu3_set_dma_mask(mtu);\n\tif (ret) {\n\t\tdev_err(dev, \"mtu3 set dma_mask failed:%d\\n\", ret);\n\t\tgoto dma_mask_err;\n\t}\n\n\tret = devm_request_threaded_irq(dev, mtu->irq, NULL, mtu3_irq,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), mtu);\n\tif (ret) {\n\t\tdev_err(dev, \"request irq %d failed!\\n\", mtu->irq);\n\t\tgoto irq_err;\n\t}\n\n\t \n\tmtu3_stop(mtu);\n\n\tret = mtu3_gadget_setup(mtu);\n\tif (ret) {\n\t\tdev_err(dev, \"mtu3 gadget init failed:%d\\n\", ret);\n\t\tgoto gadget_err;\n\t}\n\n\tssusb_dev_debugfs_init(ssusb);\n\n\tdev_dbg(dev, \" %s() done...\\n\", __func__);\n\n\treturn 0;\n\ngadget_err:\n\tdevice_init_wakeup(dev, false);\n\ndma_mask_err:\nirq_err:\n\tmtu3_hw_exit(mtu);\n\tssusb->u3d = NULL;\n\tdev_err(dev, \" %s() fail...\\n\", __func__);\n\n\treturn ret;\n}\n\nvoid ssusb_gadget_exit(struct ssusb_mtk *ssusb)\n{\n\tstruct mtu3 *mtu = ssusb->u3d;\n\n\tmtu3_gadget_cleanup(mtu);\n\tdevice_init_wakeup(ssusb->dev, false);\n\tmtu3_hw_exit(mtu);\n}\n\nbool ssusb_gadget_ip_sleep_check(struct ssusb_mtk *ssusb)\n{\n\tstruct mtu3 *mtu = ssusb->u3d;\n\n\t \n\tif (!mtu)\n\t\treturn true;\n\n\t \n\tif (mtu->is_active && mtu->softconnect)\n\t\treturn true;\n\n\t \n\treturn false;\n}\n\nint ssusb_gadget_suspend(struct ssusb_mtk *ssusb, pm_message_t msg)\n{\n\tstruct mtu3 *mtu = ssusb->u3d;\n\n\tif (!mtu->gadget_driver)\n\t\treturn 0;\n\n\tif (mtu->connected)\n\t\treturn -EBUSY;\n\n\tmtu3_dev_suspend(mtu);\n\tsynchronize_irq(mtu->irq);\n\n\treturn 0;\n}\n\nint ssusb_gadget_resume(struct ssusb_mtk *ssusb, pm_message_t msg)\n{\n\tstruct mtu3 *mtu = ssusb->u3d;\n\n\tif (!mtu->gadget_driver)\n\t\treturn 0;\n\n\tmtu3_dev_resume(mtu);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}