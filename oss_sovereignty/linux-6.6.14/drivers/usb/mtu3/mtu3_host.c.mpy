{
  "module_name": "mtu3_host.c",
  "hash_id": "5d1881488742538bf7e0f33746fab81a1f02073838aa4f27d0fa569bf4c251e0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_host.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/irq.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/regmap.h>\n\n#include \"mtu3.h\"\n#include \"mtu3_dr.h\"\n\n \n#define PERI_WK_CTRL1\t0x4\n#define WC1_IS_C(x)\t(((x) & 0xf) << 26)   \n#define WC1_IS_EN\tBIT(25)\n#define WC1_IS_P\tBIT(6)   \n\n \n#define PERI_WK_CTRL0\t0x0\n#define WC0_IS_C(x)\t((u32)(((x) & 0xf) << 28))   \n#define WC0_IS_P\tBIT(12)\t \n#define WC0_IS_EN\tBIT(6)\n\n \n#define WC0_SSUSB0_CDEN\t\tBIT(6)\n#define WC0_IS_SPM_EN\t\tBIT(1)\n\n \n#define PERI_SSUSB_SPM_CTRL\t0x0\n#define SSC_IP_SLEEP_EN\tBIT(4)\n#define SSC_SPM_INT_EN\t\tBIT(1)\n\nenum ssusb_uwk_vers {\n\tSSUSB_UWK_V1 = 1,\n\tSSUSB_UWK_V2,\n\tSSUSB_UWK_V1_1 = 101,\t \n\tSSUSB_UWK_V1_2,\t\t \n};\n\n \nstatic void ssusb_wakeup_ip_sleep_set(struct ssusb_mtk *ssusb, bool enable)\n{\n\tu32 reg, msk, val;\n\n\tswitch (ssusb->uwk_vers) {\n\tcase SSUSB_UWK_V1:\n\t\treg = ssusb->uwk_reg_base + PERI_WK_CTRL1;\n\t\tmsk = WC1_IS_EN | WC1_IS_C(0xf) | WC1_IS_P;\n\t\tval = enable ? (WC1_IS_EN | WC1_IS_C(0x8)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_1:\n\t\treg = ssusb->uwk_reg_base + PERI_WK_CTRL0;\n\t\tmsk = WC0_IS_EN | WC0_IS_C(0xf) | WC0_IS_P;\n\t\tval = enable ? (WC0_IS_EN | WC0_IS_C(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_2:\n\t\treg = ssusb->uwk_reg_base + PERI_WK_CTRL0;\n\t\tmsk = WC0_SSUSB0_CDEN | WC0_IS_SPM_EN;\n\t\tval = enable ? msk : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V2:\n\t\treg = ssusb->uwk_reg_base + PERI_SSUSB_SPM_CTRL;\n\t\tmsk = SSC_IP_SLEEP_EN | SSC_SPM_INT_EN;\n\t\tval = enable ? msk : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tregmap_update_bits(ssusb->uwk, reg, msk, val);\n}\n\nint ssusb_wakeup_of_property_parse(struct ssusb_mtk *ssusb,\n\t\t\t\tstruct device_node *dn)\n{\n\tstruct of_phandle_args args;\n\tint ret;\n\n\t \n\tssusb->uwk_en = of_property_read_bool(dn, \"wakeup-source\");\n\tif (!ssusb->uwk_en)\n\t\treturn 0;\n\n\tret = of_parse_phandle_with_fixed_args(dn,\n\t\t\t\t\"mediatek,syscon-wakeup\", 2, 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tssusb->uwk_reg_base = args.args[0];\n\tssusb->uwk_vers = args.args[1];\n\tssusb->uwk = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tdev_info(ssusb->dev, \"uwk - reg:0x%x, version:%d\\n\",\n\t\t\tssusb->uwk_reg_base, ssusb->uwk_vers);\n\n\treturn PTR_ERR_OR_ZERO(ssusb->uwk);\n}\n\nvoid ssusb_wakeup_set(struct ssusb_mtk *ssusb, bool enable)\n{\n\tif (ssusb->uwk_en)\n\t\tssusb_wakeup_ip_sleep_set(ssusb, enable);\n}\n\nstatic void host_ports_num_get(struct ssusb_mtk *ssusb)\n{\n\tu32 xhci_cap;\n\n\txhci_cap = mtu3_readl(ssusb->ippc_base, U3D_SSUSB_IP_XHCI_CAP);\n\tssusb->u2_ports = SSUSB_IP_XHCI_U2_PORT_NUM(xhci_cap);\n\tssusb->u3_ports = SSUSB_IP_XHCI_U3_PORT_NUM(xhci_cap);\n\n\tdev_dbg(ssusb->dev, \"host - u2_ports:%d, u3_ports:%d\\n\",\n\t\t ssusb->u2_ports, ssusb->u3_ports);\n}\n\n \nstatic int ssusb_host_enable(struct ssusb_mtk *ssusb)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tint num_u3p = ssusb->u3_ports;\n\tint num_u2p = ssusb->u2_ports;\n\tint u3_ports_disabled;\n\tu32 check_clk;\n\tu32 value;\n\tint i;\n\n\t \n\tmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\n\n\t \n\tu3_ports_disabled = 0;\n\tfor (i = 0; i < num_u3p; i++) {\n\t\tif ((0x1 << i) & ssusb->u3p_dis_msk) {\n\t\t\tu3_ports_disabled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\n\t\tvalue &= ~(SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS);\n\t\tvalue |= SSUSB_U3_PORT_HOST_SEL;\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\n\t}\n\n\t \n\tfor (i = 0; i < num_u2p; i++) {\n\t\tif ((0x1 << i) & ssusb->u2p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\n\t\tvalue &= ~(SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS);\n\t\tvalue |= SSUSB_U2_PORT_HOST_SEL;\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\n\t}\n\n\tcheck_clk = SSUSB_XHCI_RST_B_STS;\n\tif (num_u3p > u3_ports_disabled)\n\t\tcheck_clk = SSUSB_U3_MAC_RST_B_STS;\n\n\treturn ssusb_check_clocks(ssusb, check_clk);\n}\n\nstatic int ssusb_host_disable(struct ssusb_mtk *ssusb)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tint num_u3p = ssusb->u3_ports;\n\tint num_u2p = ssusb->u2_ports;\n\tu32 value;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_u3p; i++) {\n\t\tif ((0x1 << i) & ssusb->u3p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\n\t\tvalue |= SSUSB_U3_PORT_PDN | SSUSB_U3_PORT_DIS;\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\n\t}\n\n\t \n\tfor (i = 0; i < num_u2p; i++) {\n\t\tif ((0x1 << i) & ssusb->u2p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\n\t\tvalue |= SSUSB_U2_PORT_PDN | SSUSB_U2_PORT_DIS;\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\n\t}\n\n\t \n\tmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\n\n\treturn 0;\n}\n\nint ssusb_host_resume(struct ssusb_mtk *ssusb, bool p0_skipped)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tint u3p_skip_msk = ssusb->u3p_dis_msk;\n\tint u2p_skip_msk = ssusb->u2p_dis_msk;\n\tint num_u3p = ssusb->u3_ports;\n\tint num_u2p = ssusb->u2_ports;\n\tu32 value;\n\tint i;\n\n\tif (p0_skipped) {\n\t\tu2p_skip_msk |= 0x1;\n\t\tif (ssusb->otg_switch.is_u3_drd)\n\t\t\tu3p_skip_msk |= 0x1;\n\t}\n\n\t \n\tmtu3_clrbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\n\n\t \n\tfor (i = 0; i < num_u3p; i++) {\n\t\tif ((0x1 << i) & u3p_skip_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\n\t\tvalue &= ~SSUSB_U3_PORT_PDN;\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\n\t}\n\n\t \n\tfor (i = 0; i < num_u2p; i++) {\n\t\tif ((0x1 << i) & u2p_skip_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\n\t\tvalue &= ~SSUSB_U2_PORT_PDN;\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\n\t}\n\n\treturn 0;\n}\n\n \nint ssusb_host_suspend(struct ssusb_mtk *ssusb)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tint num_u3p = ssusb->u3_ports;\n\tint num_u2p = ssusb->u2_ports;\n\tu32 value;\n\tint i;\n\n\t \n\tfor (i = 0; i < num_u3p; i++) {\n\t\tif ((0x1 << i) & ssusb->u3p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U3_CTRL(i));\n\t\tvalue |= SSUSB_U3_PORT_PDN;\n\t\tmtu3_writel(ibase, SSUSB_U3_CTRL(i), value);\n\t}\n\n\t \n\tfor (i = 0; i < num_u2p; i++) {\n\t\tif ((0x1 << i) & ssusb->u2p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = mtu3_readl(ibase, SSUSB_U2_CTRL(i));\n\t\tvalue |= SSUSB_U2_PORT_PDN;\n\t\tmtu3_writel(ibase, SSUSB_U2_CTRL(i), value);\n\t}\n\n\t \n\tmtu3_setbits(ibase, U3D_SSUSB_IP_PW_CTRL1, SSUSB_IP_HOST_PDN);\n\n\treturn 0;\n}\n\nstatic void ssusb_host_setup(struct ssusb_mtk *ssusb)\n{\n\thost_ports_num_get(ssusb);\n\n\t \n\tssusb_host_enable(ssusb);\n\tssusb_set_force_mode(ssusb, MTU3_DR_FORCE_HOST);\n\n\t \n\tssusb_set_vbus(&ssusb->otg_switch, 1);\n}\n\nstatic void ssusb_host_cleanup(struct ssusb_mtk *ssusb)\n{\n\tif (ssusb->is_host)\n\t\tssusb_set_vbus(&ssusb->otg_switch, 0);\n\n\tssusb_host_disable(ssusb);\n}\n\n \nint ssusb_host_init(struct ssusb_mtk *ssusb, struct device_node *parent_dn)\n{\n\tstruct device *parent_dev = ssusb->dev;\n\tint ret;\n\n\tssusb_host_setup(ssusb);\n\n\tret = of_platform_populate(parent_dn, NULL, NULL, parent_dev);\n\tif (ret) {\n\t\tdev_dbg(parent_dev, \"failed to create child devices at %pOF\\n\",\n\t\t\t\tparent_dn);\n\t\treturn ret;\n\t}\n\n\tdev_info(parent_dev, \"xHCI platform device register success...\\n\");\n\n\treturn 0;\n}\n\nvoid ssusb_host_exit(struct ssusb_mtk *ssusb)\n{\n\tof_platform_depopulate(ssusb->dev);\n\tssusb_host_cleanup(ssusb);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}