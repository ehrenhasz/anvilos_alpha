{
  "module_name": "mtu3_plat.c",
  "hash_id": "72079454a07bfd0fd89072aef7a3e01c3e4f204ebdb27fcffbf3c1387dc43e90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_plat.c",
  "human_readable_source": "\n \n\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/reset.h>\n\n#include \"mtu3.h\"\n#include \"mtu3_dr.h\"\n#include \"mtu3_debug.h\"\n\n \nint ssusb_check_clocks(struct ssusb_mtk *ssusb, u32 ex_clks)\n{\n\tvoid __iomem *ibase = ssusb->ippc_base;\n\tu32 value, check_val;\n\tint ret;\n\n\tcheck_val = ex_clks | SSUSB_SYS125_RST_B_STS | SSUSB_SYSPLL_STABLE |\n\t\t\tSSUSB_REF_RST_B_STS;\n\n\tret = readl_poll_timeout(ibase + U3D_SSUSB_IP_PW_STS1, value,\n\t\t\t(check_val == (value & check_val)), 100, 20000);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"clks of sts1 are not stable!\\n\");\n\t\treturn ret;\n\t}\n\n\tret = readl_poll_timeout(ibase + U3D_SSUSB_IP_PW_STS2, value,\n\t\t\t(value & SSUSB_U2_MAC_SYS_RST_B_STS), 100, 10000);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"mac2 clock is not stable\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int wait_for_ip_sleep(struct ssusb_mtk *ssusb)\n{\n\tbool sleep_check = true;\n\tu32 value;\n\tint ret;\n\n\tif (!ssusb->is_host)\n\t\tsleep_check = ssusb_gadget_ip_sleep_check(ssusb);\n\n\tif (!sleep_check)\n\t\treturn 0;\n\n\t \n\tret = readl_poll_timeout(ssusb->ippc_base + U3D_SSUSB_IP_PW_STS1, value,\n\t\t\t\t (value & SSUSB_IP_SLEEP_STS), 100, 100000);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"ip sleep failed!!!\\n\");\n\t\tret = -EBUSY;\n\t} else {\n\t\t \n\t\tusleep_range(100, 200);\n\t}\n\n\treturn ret;\n}\n\nstatic int ssusb_phy_init(struct ssusb_mtk *ssusb)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ssusb->num_phys; i++) {\n\t\tret = phy_init(ssusb->phys[i]);\n\t\tif (ret)\n\t\t\tgoto exit_phy;\n\t}\n\treturn 0;\n\nexit_phy:\n\tfor (; i > 0; i--)\n\t\tphy_exit(ssusb->phys[i - 1]);\n\n\treturn ret;\n}\n\nstatic int ssusb_phy_exit(struct ssusb_mtk *ssusb)\n{\n\tint i;\n\n\tfor (i = 0; i < ssusb->num_phys; i++)\n\t\tphy_exit(ssusb->phys[i]);\n\n\treturn 0;\n}\n\nstatic int ssusb_phy_power_on(struct ssusb_mtk *ssusb)\n{\n\tint i;\n\tint ret;\n\n\tfor (i = 0; i < ssusb->num_phys; i++) {\n\t\tret = phy_power_on(ssusb->phys[i]);\n\t\tif (ret)\n\t\t\tgoto power_off_phy;\n\t}\n\treturn 0;\n\npower_off_phy:\n\tfor (; i > 0; i--)\n\t\tphy_power_off(ssusb->phys[i - 1]);\n\n\treturn ret;\n}\n\nstatic void ssusb_phy_power_off(struct ssusb_mtk *ssusb)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < ssusb->num_phys; i++)\n\t\tphy_power_off(ssusb->phys[i]);\n}\n\nstatic int ssusb_rscs_init(struct ssusb_mtk *ssusb)\n{\n\tint ret = 0;\n\n\tret = regulator_enable(ssusb->vusb33);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"failed to enable vusb33\\n\");\n\t\tgoto vusb33_err;\n\t}\n\n\tret = clk_bulk_prepare_enable(BULK_CLKS_CNT, ssusb->clks);\n\tif (ret)\n\t\tgoto clks_err;\n\n\tret = ssusb_phy_init(ssusb);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"failed to init phy\\n\");\n\t\tgoto phy_init_err;\n\t}\n\n\tret = ssusb_phy_power_on(ssusb);\n\tif (ret) {\n\t\tdev_err(ssusb->dev, \"failed to power on phy\\n\");\n\t\tgoto phy_err;\n\t}\n\n\treturn 0;\n\nphy_err:\n\tssusb_phy_exit(ssusb);\nphy_init_err:\n\tclk_bulk_disable_unprepare(BULK_CLKS_CNT, ssusb->clks);\nclks_err:\n\tregulator_disable(ssusb->vusb33);\nvusb33_err:\n\treturn ret;\n}\n\nstatic void ssusb_rscs_exit(struct ssusb_mtk *ssusb)\n{\n\tclk_bulk_disable_unprepare(BULK_CLKS_CNT, ssusb->clks);\n\tregulator_disable(ssusb->vusb33);\n\tssusb_phy_power_off(ssusb);\n\tssusb_phy_exit(ssusb);\n}\n\nstatic void ssusb_ip_sw_reset(struct ssusb_mtk *ssusb)\n{\n\t \n\tmtu3_setbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);\n\tudelay(1);\n\tmtu3_clrbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL0, SSUSB_IP_SW_RST);\n\n\t \n\tmtu3_setbits(ssusb->ippc_base, U3D_SSUSB_IP_PW_CTRL2, SSUSB_IP_DEV_PDN);\n}\n\nstatic void ssusb_u3_drd_check(struct ssusb_mtk *ssusb)\n{\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\tu32 dev_u3p_num;\n\tu32 host_u3p_num;\n\tu32 value;\n\n\t \n\tif (ssusb->u3p_dis_msk & BIT(0)) {\n\t\totg_sx->is_u3_drd = false;\n\t\tgoto out;\n\t}\n\n\tvalue = mtu3_readl(ssusb->ippc_base, U3D_SSUSB_IP_DEV_CAP);\n\tdev_u3p_num = SSUSB_IP_DEV_U3_PORT_NUM(value);\n\n\tvalue = mtu3_readl(ssusb->ippc_base, U3D_SSUSB_IP_XHCI_CAP);\n\thost_u3p_num = SSUSB_IP_XHCI_U3_PORT_NUM(value);\n\n\totg_sx->is_u3_drd = !!(dev_u3p_num && host_u3p_num);\n\nout:\n\tdev_info(ssusb->dev, \"usb3-drd: %d\\n\", otg_sx->is_u3_drd);\n}\n\nstatic int get_ssusb_rscs(struct platform_device *pdev, struct ssusb_mtk *ssusb)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\tstruct clk_bulk_data *clks = ssusb->clks;\n\tstruct device *dev = &pdev->dev;\n\tint i;\n\tint ret;\n\n\tssusb->vusb33 = devm_regulator_get(dev, \"vusb33\");\n\tif (IS_ERR(ssusb->vusb33)) {\n\t\tdev_err(dev, \"failed to get vusb33\\n\");\n\t\treturn PTR_ERR(ssusb->vusb33);\n\t}\n\n\tclks[0].id = \"sys_ck\";\n\tclks[1].id = \"ref_ck\";\n\tclks[2].id = \"mcu_ck\";\n\tclks[3].id = \"dma_ck\";\n\tclks[4].id = \"xhci_ck\";\n\tclks[5].id = \"frmcnt_ck\";\n\tret = devm_clk_bulk_get_optional(dev, BULK_CLKS_CNT, clks);\n\tif (ret)\n\t\treturn ret;\n\n\tssusb->num_phys = of_count_phandle_with_args(node,\n\t\t\t\"phys\", \"#phy-cells\");\n\tif (ssusb->num_phys > 0) {\n\t\tssusb->phys = devm_kcalloc(dev, ssusb->num_phys,\n\t\t\t\t\tsizeof(*ssusb->phys), GFP_KERNEL);\n\t\tif (!ssusb->phys)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tssusb->num_phys = 0;\n\t}\n\n\tfor (i = 0; i < ssusb->num_phys; i++) {\n\t\tssusb->phys[i] = devm_of_phy_get_by_index(dev, node, i);\n\t\tif (IS_ERR(ssusb->phys[i])) {\n\t\t\tdev_err(dev, \"failed to get phy-%d\\n\", i);\n\t\t\treturn PTR_ERR(ssusb->phys[i]);\n\t\t}\n\t}\n\n\tssusb->ippc_base = devm_platform_ioremap_resource_byname(pdev, \"ippc\");\n\tif (IS_ERR(ssusb->ippc_base))\n\t\treturn PTR_ERR(ssusb->ippc_base);\n\n\tssusb->wakeup_irq = platform_get_irq_byname_optional(pdev, \"wakeup\");\n\tif (ssusb->wakeup_irq == -EPROBE_DEFER)\n\t\treturn ssusb->wakeup_irq;\n\n\tssusb->dr_mode = usb_get_dr_mode(dev);\n\tif (ssusb->dr_mode == USB_DR_MODE_UNKNOWN)\n\t\tssusb->dr_mode = USB_DR_MODE_OTG;\n\n\tof_property_read_u32(node, \"mediatek,u3p-dis-msk\", &ssusb->u3p_dis_msk);\n\n\tif (ssusb->dr_mode == USB_DR_MODE_PERIPHERAL)\n\t\tgoto out;\n\n\t \n\tret = ssusb_wakeup_of_property_parse(ssusb, node);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse uwk property\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tof_property_read_u32(node, \"mediatek,u2p-dis-msk\",\n\t\t\t     &ssusb->u2p_dis_msk);\n\n\totg_sx->vbus = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(otg_sx->vbus)) {\n\t\tdev_err(dev, \"failed to get vbus\\n\");\n\t\treturn PTR_ERR(otg_sx->vbus);\n\t}\n\n\tif (ssusb->dr_mode == USB_DR_MODE_HOST)\n\t\tgoto out;\n\n\t \n\totg_sx->manual_drd_enabled =\n\t\tof_property_read_bool(node, \"enable-manual-drd\");\n\totg_sx->role_sw_used = of_property_read_bool(node, \"usb-role-switch\");\n\n\t \n\tssusb->u2p_dis_msk &= ~0x1;\n\n\tif (otg_sx->role_sw_used || otg_sx->manual_drd_enabled)\n\t\tgoto out;\n\n\tif (of_property_read_bool(node, \"extcon\")) {\n\t\totg_sx->edev = extcon_get_edev_by_phandle(ssusb->dev, 0);\n\t\tif (IS_ERR(otg_sx->edev)) {\n\t\t\treturn dev_err_probe(dev, PTR_ERR(otg_sx->edev),\n\t\t\t\t\t     \"couldn't get extcon device\\n\");\n\t\t}\n\t}\n\nout:\n\tdev_info(dev, \"dr_mode: %d, drd: %s\\n\", ssusb->dr_mode,\n\t\t otg_sx->manual_drd_enabled ? \"manual\" : \"auto\");\n\tdev_info(dev, \"u2p_dis_msk: %x, u3p_dis_msk: %x\\n\",\n\t\t ssusb->u2p_dis_msk, ssusb->u3p_dis_msk);\n\n\treturn 0;\n}\n\nstatic int mtu3_probe(struct platform_device *pdev)\n{\n\tstruct device_node *node = pdev->dev.of_node;\n\tstruct device *dev = &pdev->dev;\n\tstruct ssusb_mtk *ssusb;\n\tint ret = -ENOMEM;\n\n\t \n\tssusb = devm_kzalloc(dev, sizeof(*ssusb), GFP_KERNEL);\n\tif (!ssusb)\n\t\treturn -ENOMEM;\n\n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret) {\n\t\tdev_err(dev, \"No suitable DMA config available\\n\");\n\t\treturn -ENOTSUPP;\n\t}\n\n\tplatform_set_drvdata(pdev, ssusb);\n\tssusb->dev = dev;\n\n\tret = get_ssusb_rscs(pdev, ssusb);\n\tif (ret)\n\t\treturn ret;\n\n\tssusb_debugfs_create_root(ssusb);\n\n\t \n\tpm_runtime_set_active(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 4000);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tdevice_init_wakeup(dev, true);\n\n\tret = ssusb_rscs_init(ssusb);\n\tif (ret)\n\t\tgoto comm_init_err;\n\n\tif (ssusb->wakeup_irq > 0) {\n\t\tret = dev_pm_set_dedicated_wake_irq_reverse(dev, ssusb->wakeup_irq);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to set wakeup irq %d\\n\", ssusb->wakeup_irq);\n\t\t\tgoto comm_exit;\n\t\t}\n\t\tdev_info(dev, \"wakeup irq %d\\n\", ssusb->wakeup_irq);\n\t}\n\n\tret = device_reset_optional(dev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to reset controller\\n\");\n\t\tgoto comm_exit;\n\t}\n\n\tssusb_ip_sw_reset(ssusb);\n\tssusb_u3_drd_check(ssusb);\n\n\tif (IS_ENABLED(CONFIG_USB_MTU3_HOST))\n\t\tssusb->dr_mode = USB_DR_MODE_HOST;\n\telse if (IS_ENABLED(CONFIG_USB_MTU3_GADGET))\n\t\tssusb->dr_mode = USB_DR_MODE_PERIPHERAL;\n\n\t \n\tssusb->is_host = !(ssusb->dr_mode == USB_DR_MODE_PERIPHERAL);\n\n\tswitch (ssusb->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tret = ssusb_gadget_init(ssusb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize gadget\\n\");\n\t\t\tgoto comm_exit;\n\t\t}\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tret = ssusb_host_init(ssusb, node);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\t\tgoto comm_exit;\n\t\t}\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tret = ssusb_gadget_init(ssusb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize gadget\\n\");\n\t\t\tgoto comm_exit;\n\t\t}\n\n\t\tret = ssusb_host_init(ssusb, node);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize host\\n\");\n\t\t\tgoto gadget_exit;\n\t\t}\n\n\t\tret = ssusb_otg_switch_init(ssusb);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to initialize switch\\n\");\n\t\t\tgoto host_exit;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unsupported mode: %d\\n\", ssusb->dr_mode);\n\t\tret = -EINVAL;\n\t\tgoto comm_exit;\n\t}\n\n\tdevice_enable_async_suspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\nhost_exit:\n\tssusb_host_exit(ssusb);\ngadget_exit:\n\tssusb_gadget_exit(ssusb);\ncomm_exit:\n\tssusb_rscs_exit(ssusb);\ncomm_init_err:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\tssusb_debugfs_remove_root(ssusb);\n\n\treturn ret;\n}\n\nstatic int mtu3_remove(struct platform_device *pdev)\n{\n\tstruct ssusb_mtk *ssusb = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\n\tswitch (ssusb->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tssusb_gadget_exit(ssusb);\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tssusb_host_exit(ssusb);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tssusb_otg_switch_exit(ssusb);\n\t\tssusb_gadget_exit(ssusb);\n\t\tssusb_host_exit(ssusb);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tssusb_rscs_exit(ssusb);\n\tssusb_debugfs_remove_root(ssusb);\n\tpm_runtime_disable(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_set_suspended(&pdev->dev);\n\n\treturn 0;\n}\n\nstatic int resume_ip_and_ports(struct ssusb_mtk *ssusb, pm_message_t msg)\n{\n\tswitch (ssusb->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tssusb_gadget_resume(ssusb, msg);\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tssusb_host_resume(ssusb, false);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tssusb_host_resume(ssusb, !ssusb->is_host);\n\t\tif (!ssusb->is_host)\n\t\t\tssusb_gadget_resume(ssusb, msg);\n\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int mtu3_suspend_common(struct device *dev, pm_message_t msg)\n{\n\tstruct ssusb_mtk *ssusb = dev_get_drvdata(dev);\n\tint ret = 0;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tswitch (ssusb->dr_mode) {\n\tcase USB_DR_MODE_PERIPHERAL:\n\t\tret = ssusb_gadget_suspend(ssusb, msg);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tbreak;\n\tcase USB_DR_MODE_HOST:\n\t\tssusb_host_suspend(ssusb);\n\t\tbreak;\n\tcase USB_DR_MODE_OTG:\n\t\tif (!ssusb->is_host) {\n\t\t\tret = ssusb_gadget_suspend(ssusb, msg);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t\tssusb_host_suspend(ssusb);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = wait_for_ip_sleep(ssusb);\n\tif (ret)\n\t\tgoto sleep_err;\n\n\tssusb_phy_power_off(ssusb);\n\tclk_bulk_disable_unprepare(BULK_CLKS_CNT, ssusb->clks);\n\tssusb_wakeup_set(ssusb, true);\n\treturn 0;\n\nsleep_err:\n\tresume_ip_and_ports(ssusb, msg);\nerr:\n\treturn ret;\n}\n\nstatic int mtu3_resume_common(struct device *dev, pm_message_t msg)\n{\n\tstruct ssusb_mtk *ssusb = dev_get_drvdata(dev);\n\tint ret;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tssusb_wakeup_set(ssusb, false);\n\tret = clk_bulk_prepare_enable(BULK_CLKS_CNT, ssusb->clks);\n\tif (ret)\n\t\tgoto clks_err;\n\n\tret = ssusb_phy_power_on(ssusb);\n\tif (ret)\n\t\tgoto phy_err;\n\n\treturn resume_ip_and_ports(ssusb, msg);\n\nphy_err:\n\tclk_bulk_disable_unprepare(BULK_CLKS_CNT, ssusb->clks);\nclks_err:\n\treturn ret;\n}\n\nstatic int __maybe_unused mtu3_suspend(struct device *dev)\n{\n\treturn mtu3_suspend_common(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused mtu3_resume(struct device *dev)\n{\n\treturn mtu3_resume_common(dev, PMSG_SUSPEND);\n}\n\nstatic int __maybe_unused mtu3_runtime_suspend(struct device *dev)\n{\n\tif (!device_may_wakeup(dev))\n\t\treturn 0;\n\n\treturn mtu3_suspend_common(dev, PMSG_AUTO_SUSPEND);\n}\n\nstatic int __maybe_unused mtu3_runtime_resume(struct device *dev)\n{\n\tif (!device_may_wakeup(dev))\n\t\treturn 0;\n\n\treturn mtu3_resume_common(dev, PMSG_AUTO_SUSPEND);\n}\n\nstatic const struct dev_pm_ops mtu3_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(mtu3_suspend, mtu3_resume)\n\tSET_RUNTIME_PM_OPS(mtu3_runtime_suspend,\n\t\t\t   mtu3_runtime_resume, NULL)\n};\n\n#define DEV_PM_OPS (IS_ENABLED(CONFIG_PM) ? &mtu3_pm_ops : NULL)\n\nstatic const struct of_device_id mtu3_of_match[] = {\n\t{.compatible = \"mediatek,mt8173-mtu3\",},\n\t{.compatible = \"mediatek,mtu3\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, mtu3_of_match);\n\nstatic struct platform_driver mtu3_driver = {\n\t.probe = mtu3_probe,\n\t.remove = mtu3_remove,\n\t.driver = {\n\t\t.name = MTU3_DRIVER_NAME,\n\t\t.pm = DEV_PM_OPS,\n\t\t.of_match_table = mtu3_of_match,\n\t},\n};\nmodule_platform_driver(mtu3_driver);\n\nMODULE_AUTHOR(\"Chunfeng Yun <chunfeng.yun@mediatek.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"MediaTek USB3 DRD Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}