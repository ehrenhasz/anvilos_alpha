{
  "module_name": "mtu3.h",
  "hash_id": "2a8d36c22ee05e33c2b0c545d070ee2a75fab4336d0939e0ab6dda65afd3208c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3.h",
  "human_readable_source": " \n \n\n#ifndef __MTU3_H__\n#define __MTU3_H__\n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dmapool.h>\n#include <linux/extcon.h>\n#include <linux/interrupt.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/role.h>\n\nstruct mtu3;\nstruct mtu3_ep;\nstruct mtu3_request;\n\n#include \"mtu3_hw_regs.h\"\n#include \"mtu3_qmu.h\"\n\n#define\tMU3D_EP_TXCR0(epnum)\t(U3D_TX1CSR0 + (((epnum) - 1) * 0x10))\n#define\tMU3D_EP_TXCR1(epnum)\t(U3D_TX1CSR1 + (((epnum) - 1) * 0x10))\n#define\tMU3D_EP_TXCR2(epnum)\t(U3D_TX1CSR2 + (((epnum) - 1) * 0x10))\n\n#define\tMU3D_EP_RXCR0(epnum)\t(U3D_RX1CSR0 + (((epnum) - 1) * 0x10))\n#define\tMU3D_EP_RXCR1(epnum)\t(U3D_RX1CSR1 + (((epnum) - 1) * 0x10))\n#define\tMU3D_EP_RXCR2(epnum)\t(U3D_RX1CSR2 + (((epnum) - 1) * 0x10))\n\n#define USB_QMU_TQHIAR(epnum)\t(U3D_TXQHIAR1 + (((epnum) - 1) * 0x4))\n#define USB_QMU_RQHIAR(epnum)\t(U3D_RXQHIAR1 + (((epnum) - 1) * 0x4))\n\n#define USB_QMU_RQCSR(epnum)\t(U3D_RXQCSR1 + (((epnum) - 1) * 0x10))\n#define USB_QMU_RQSAR(epnum)\t(U3D_RXQSAR1 + (((epnum) - 1) * 0x10))\n#define USB_QMU_RQCPR(epnum)\t(U3D_RXQCPR1 + (((epnum) - 1) * 0x10))\n\n#define USB_QMU_TQCSR(epnum)\t(U3D_TXQCSR1 + (((epnum) - 1) * 0x10))\n#define USB_QMU_TQSAR(epnum)\t(U3D_TXQSAR1 + (((epnum) - 1) * 0x10))\n#define USB_QMU_TQCPR(epnum)\t(U3D_TXQCPR1 + (((epnum) - 1) * 0x10))\n\n#define SSUSB_U3_CTRL(p)\t(U3D_SSUSB_U3_CTRL_0P + ((p) * 0x08))\n#define SSUSB_U2_CTRL(p)\t(U3D_SSUSB_U2_CTRL_0P + ((p) * 0x08))\n\n#define MTU3_DRIVER_NAME\t\"mtu3\"\n#define\tDMA_ADDR_INVALID\t(~(dma_addr_t)0)\n\n#define MTU3_EP_ENABLED\t\tBIT(0)\n#define MTU3_EP_STALL\t\tBIT(1)\n#define MTU3_EP_WEDGE\t\tBIT(2)\n#define MTU3_EP_BUSY\t\tBIT(3)\n\n#define MTU3_U3_IP_SLOT_DEFAULT 2\n#define MTU3_U2_IP_SLOT_DEFAULT 1\n\n \n#define MTU3_TRUNK_VERS_1003\t0x1003\n\n \n#define MTU3_EP_FIFO_UNIT\t\t(1 << 9)\n#define MTU3_FIFO_BIT_SIZE\t\t128\n#define MTU3_U2_IP_EP0_FIFO_SIZE\t64\n\n \n#define EP0_RESPONSE_BUF  6\n\n#define BULK_CLKS_CNT\t6\n\n \nenum mtu3_speed {\n\tMTU3_SPEED_INACTIVE = 0,\n\tMTU3_SPEED_FULL = 1,\n\tMTU3_SPEED_HIGH = 3,\n\tMTU3_SPEED_SUPER = 4,\n\tMTU3_SPEED_SUPER_PLUS = 5,\n};\n\n \nenum mtu3_g_ep0_state {\n\tMU3D_EP0_STATE_SETUP = 1,\n\tMU3D_EP0_STATE_TX,\n\tMU3D_EP0_STATE_RX,\n\tMU3D_EP0_STATE_TX_END,\n\tMU3D_EP0_STATE_STALL,\n};\n\n \nenum mtu3_dr_force_mode {\n\tMTU3_DR_FORCE_NONE = 0,\n\tMTU3_DR_FORCE_HOST,\n\tMTU3_DR_FORCE_DEVICE,\n};\n\n \nstruct mtu3_fifo_info {\n\tu32 base;\n\tu32 limit;\n\tDECLARE_BITMAP(bitmap, MTU3_FIFO_BIT_SIZE);\n};\n\n \nstruct qmu_gpd {\n\t__le32 dw0_info;\n\t__le32 next_gpd;\n\t__le32 buffer;\n\t__le32 dw3_info;\n} __packed;\n\n \nstruct mtu3_gpd_ring {\n\tdma_addr_t dma;\n\tstruct qmu_gpd *start;\n\tstruct qmu_gpd *end;\n\tstruct qmu_gpd *enqueue;\n\tstruct qmu_gpd *dequeue;\n};\n\n \nstruct otg_switch_mtk {\n\tstruct regulator *vbus;\n\tstruct extcon_dev *edev;\n\tstruct notifier_block id_nb;\n\tstruct work_struct dr_work;\n\tenum usb_role desired_role;\n\tenum usb_role default_role;\n\tstruct usb_role_switch *role_sw;\n\tbool role_sw_used;\n\tbool is_u3_drd;\n\tbool manual_drd_enabled;\n};\n\n \nstruct ssusb_mtk {\n\tstruct device *dev;\n\tstruct mtu3 *u3d;\n\tvoid __iomem *mac_base;\n\tvoid __iomem *ippc_base;\n\tstruct phy **phys;\n\tint num_phys;\n\tint wakeup_irq;\n\t \n\tstruct regulator *vusb33;\n\tstruct clk_bulk_data clks[BULK_CLKS_CNT];\n\t \n\tstruct otg_switch_mtk otg_switch;\n\tenum usb_dr_mode dr_mode;\n\tbool is_host;\n\tint u2_ports;\n\tint u3_ports;\n\tint u2p_dis_msk;\n\tint u3p_dis_msk;\n\tstruct dentry *dbgfs_root;\n\t \n\tbool uwk_en;\n\tstruct regmap *uwk;\n\tu32 uwk_reg_base;\n\tu32 uwk_vers;\n};\n\n \nstruct mtu3_ep {\n\tstruct usb_ep ep;\n\tchar name[12];\n\tstruct mtu3 *mtu;\n\tu8 epnum;\n\tu8 type;\n\tu8 is_in;\n\tu16 maxp;\n\tint slot;\n\tu32 fifo_size;\n\tu32 fifo_addr;\n\tu32 fifo_seg_size;\n\tstruct mtu3_fifo_info *fifo;\n\n\tstruct list_head req_list;\n\tstruct mtu3_gpd_ring gpd_ring;\n\tconst struct usb_ss_ep_comp_descriptor *comp_desc;\n\tconst struct usb_endpoint_descriptor *desc;\n\n\tint flags;\n};\n\nstruct mtu3_request {\n\tstruct usb_request request;\n\tstruct list_head list;\n\tstruct mtu3_ep *mep;\n\tstruct mtu3 *mtu;\n\tstruct qmu_gpd *gpd;\n\tint epnum;\n};\n\nstatic inline struct ssusb_mtk *dev_to_ssusb(struct device *dev)\n{\n\treturn dev_get_drvdata(dev);\n}\n\n \nstruct mtu3 {\n\tspinlock_t lock;\n\tstruct ssusb_mtk *ssusb;\n\tstruct device *dev;\n\tvoid __iomem *mac_base;\n\tvoid __iomem *ippc_base;\n\tint irq;\n\n\tstruct mtu3_fifo_info tx_fifo;\n\tstruct mtu3_fifo_info rx_fifo;\n\n\tstruct mtu3_ep *ep_array;\n\tstruct mtu3_ep *in_eps;\n\tstruct mtu3_ep *out_eps;\n\tstruct mtu3_ep *ep0;\n\tint num_eps;\n\tint slot;\n\tint active_ep;\n\n\tstruct dma_pool\t*qmu_gpd_pool;\n\tenum mtu3_g_ep0_state ep0_state;\n\tstruct usb_gadget g;\t \n\tstruct usb_gadget_driver *gadget_driver;\n\tstruct mtu3_request ep0_req;\n\tu8 setup_buf[EP0_RESPONSE_BUF];\n\tenum usb_device_speed max_speed;\n\tenum usb_device_speed speed;\n\n\tunsigned is_active:1;\n\tunsigned may_wakeup:1;\n\tunsigned is_self_powered:1;\n\tunsigned test_mode:1;\n\tunsigned softconnect:1;\n\tunsigned u1_enable:1;\n\tunsigned u2_enable:1;\n\tunsigned u3_capable:1;\n\tunsigned delayed_status:1;\n\tunsigned gen2cp:1;\n\tunsigned connected:1;\n\tunsigned async_callbacks:1;\n\tunsigned separate_fifo:1;\n\n\tu8 address;\n\tu8 test_mode_nr;\n\tu32 hw_version;\n};\n\nstatic inline struct mtu3 *gadget_to_mtu3(struct usb_gadget *g)\n{\n\treturn container_of(g, struct mtu3, g);\n}\n\nstatic inline struct mtu3_request *to_mtu3_request(struct usb_request *req)\n{\n\treturn req ? container_of(req, struct mtu3_request, request) : NULL;\n}\n\nstatic inline struct mtu3_ep *to_mtu3_ep(struct usb_ep *ep)\n{\n\treturn ep ? container_of(ep, struct mtu3_ep, ep) : NULL;\n}\n\nstatic inline struct mtu3_request *next_request(struct mtu3_ep *mep)\n{\n\treturn list_first_entry_or_null(&mep->req_list, struct mtu3_request,\n\t\t\t\t\tlist);\n}\n\nstatic inline void mtu3_writel(void __iomem *base, u32 offset, u32 data)\n{\n\twritel(data, base + offset);\n}\n\nstatic inline u32 mtu3_readl(void __iomem *base, u32 offset)\n{\n\treturn readl(base + offset);\n}\n\nstatic inline void mtu3_setbits(void __iomem *base, u32 offset, u32 bits)\n{\n\tvoid __iomem *addr = base + offset;\n\tu32 tmp = readl(addr);\n\n\twritel((tmp | (bits)), addr);\n}\n\nstatic inline void mtu3_clrbits(void __iomem *base, u32 offset, u32 bits)\n{\n\tvoid __iomem *addr = base + offset;\n\tu32 tmp = readl(addr);\n\n\twritel((tmp & ~(bits)), addr);\n}\n\nint ssusb_check_clocks(struct ssusb_mtk *ssusb, u32 ex_clks);\nstruct usb_request *mtu3_alloc_request(struct usb_ep *ep, gfp_t gfp_flags);\nvoid mtu3_free_request(struct usb_ep *ep, struct usb_request *req);\nvoid mtu3_req_complete(struct mtu3_ep *mep,\n\t\tstruct usb_request *req, int status);\n\nint mtu3_config_ep(struct mtu3 *mtu, struct mtu3_ep *mep,\n\t\tint interval, int burst, int mult);\nvoid mtu3_deconfig_ep(struct mtu3 *mtu, struct mtu3_ep *mep);\nvoid mtu3_ep_stall_set(struct mtu3_ep *mep, bool set);\nvoid mtu3_start(struct mtu3 *mtu);\nvoid mtu3_stop(struct mtu3 *mtu);\nvoid mtu3_dev_on_off(struct mtu3 *mtu, int is_on);\n\nint mtu3_gadget_setup(struct mtu3 *mtu);\nvoid mtu3_gadget_cleanup(struct mtu3 *mtu);\nvoid mtu3_gadget_reset(struct mtu3 *mtu);\nvoid mtu3_gadget_suspend(struct mtu3 *mtu);\nvoid mtu3_gadget_resume(struct mtu3 *mtu);\nvoid mtu3_gadget_disconnect(struct mtu3 *mtu);\n\nirqreturn_t mtu3_ep0_isr(struct mtu3 *mtu);\nextern const struct usb_ep_ops mtu3_ep0_ops;\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}