{
  "module_name": "mtu3_debugfs.c",
  "hash_id": "bcc207051b0aeb0db9db17da434db591b2b8b695d543f888a68538263542925f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/mtu3/mtu3_debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/uaccess.h>\n\n#include \"mtu3.h\"\n#include \"mtu3_dr.h\"\n#include \"mtu3_debug.h\"\n\n#define dump_register(nm)\t\t\\\n{\t\t\t\t\t\\\n\t.name = __stringify(nm),\t\\\n\t.offset = U3D_ ##nm,\t\t\\\n}\n\n#define dump_prb_reg(nm, os)\t\\\n{\t\t\t\t\\\n\t.name = nm,\t\t\\\n\t.offset = os,\t\t\\\n}\n\nstatic const struct debugfs_reg32 mtu3_ippc_regs[] = {\n\tdump_register(SSUSB_IP_PW_CTRL0),\n\tdump_register(SSUSB_IP_PW_CTRL1),\n\tdump_register(SSUSB_IP_PW_CTRL2),\n\tdump_register(SSUSB_IP_PW_CTRL3),\n\tdump_register(SSUSB_IP_PW_STS1),\n\tdump_register(SSUSB_OTG_STS),\n\tdump_register(SSUSB_IP_XHCI_CAP),\n\tdump_register(SSUSB_IP_DEV_CAP),\n\tdump_register(SSUSB_U3_CTRL_0P),\n\tdump_register(SSUSB_U2_CTRL_0P),\n\tdump_register(SSUSB_HW_ID),\n\tdump_register(SSUSB_HW_SUB_ID),\n\tdump_register(SSUSB_IP_SPARE0),\n};\n\nstatic const struct debugfs_reg32 mtu3_dev_regs[] = {\n\tdump_register(LV1ISR),\n\tdump_register(LV1IER),\n\tdump_register(EPISR),\n\tdump_register(EPIER),\n\tdump_register(EP0CSR),\n\tdump_register(RXCOUNT0),\n\tdump_register(QISAR0),\n\tdump_register(QIER0),\n\tdump_register(QISAR1),\n\tdump_register(QIER1),\n\tdump_register(CAP_EPNTXFFSZ),\n\tdump_register(CAP_EPNRXFFSZ),\n\tdump_register(CAP_EPINFO),\n\tdump_register(MISC_CTRL),\n};\n\nstatic const struct debugfs_reg32 mtu3_csr_regs[] = {\n\tdump_register(DEVICE_CONF),\n\tdump_register(DEV_LINK_INTR_ENABLE),\n\tdump_register(DEV_LINK_INTR),\n\tdump_register(LTSSM_CTRL),\n\tdump_register(USB3_CONFIG),\n\tdump_register(LINK_STATE_MACHINE),\n\tdump_register(LTSSM_INTR_ENABLE),\n\tdump_register(LTSSM_INTR),\n\tdump_register(U3U2_SWITCH_CTRL),\n\tdump_register(POWER_MANAGEMENT),\n\tdump_register(DEVICE_CONTROL),\n\tdump_register(COMMON_USB_INTR_ENABLE),\n\tdump_register(COMMON_USB_INTR),\n\tdump_register(USB20_MISC_CONTROL),\n\tdump_register(USB20_OPSTATE),\n};\n\nstatic int mtu3_link_state_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3 *mtu = sf->private;\n\tvoid __iomem *mbase = mtu->mac_base;\n\n\tseq_printf(sf, \"opstate: %#x, ltssm: %#x\\n\",\n\t\t   mtu3_readl(mbase, U3D_USB20_OPSTATE),\n\t\t   LTSSM_STATE(mtu3_readl(mbase, U3D_LINK_STATE_MACHINE)));\n\n\treturn 0;\n}\n\nstatic int mtu3_ep_used_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3 *mtu = sf->private;\n\tstruct mtu3_ep *mep;\n\tunsigned long flags;\n\tint used = 0;\n\tint i;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\n\tfor (i = 0; i < mtu->num_eps; i++) {\n\t\tmep = mtu->in_eps + i;\n\t\tif (mep->flags & MTU3_EP_ENABLED) {\n\t\t\tseq_printf(sf, \"%s - type: %s\\n\", mep->name, usb_ep_type_string(mep->type));\n\t\t\tused++;\n\t\t}\n\n\t\tmep = mtu->out_eps + i;\n\t\tif (mep->flags & MTU3_EP_ENABLED) {\n\t\t\tseq_printf(sf, \"%s - type: %s\\n\", mep->name, usb_ep_type_string(mep->type));\n\t\t\tused++;\n\t\t}\n\t}\n\tseq_printf(sf, \"total used: %d eps\\n\", used);\n\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn 0;\n}\n\nDEFINE_SHOW_ATTRIBUTE(mtu3_link_state);\nDEFINE_SHOW_ATTRIBUTE(mtu3_ep_used);\n\nstatic void mtu3_debugfs_regset(struct mtu3 *mtu, void __iomem *base,\n\t\t\t\tconst struct debugfs_reg32 *regs, size_t nregs,\n\t\t\t\tconst char *name, struct dentry *parent)\n{\n\tstruct debugfs_regset32 *regset;\n\tstruct mtu3_regset *mregs;\n\n\tmregs = devm_kzalloc(mtu->dev, sizeof(*mregs), GFP_KERNEL);\n\tif (!mregs)\n\t\treturn;\n\n\tsprintf(mregs->name, \"%s\", name);\n\tregset = &mregs->regset;\n\tregset->regs = regs;\n\tregset->nregs = nregs;\n\tregset->base = base;\n\n\tdebugfs_create_regset32(mregs->name, 0444, parent, regset);\n}\n\nstatic void mtu3_debugfs_ep_regset(struct mtu3 *mtu, struct mtu3_ep *mep,\n\t\t\t\t   struct dentry *parent)\n{\n\tstruct debugfs_reg32 *regs;\n\tint epnum = mep->epnum;\n\tint in = mep->is_in;\n\n\tregs = devm_kcalloc(mtu->dev, 7, sizeof(*regs), GFP_KERNEL);\n\tif (!regs)\n\t\treturn;\n\n\tregs[0].name = in ? \"TCR0\" : \"RCR0\";\n\tregs[0].offset = in ? MU3D_EP_TXCR0(epnum) : MU3D_EP_RXCR0(epnum);\n\tregs[1].name = in ? \"TCR1\" : \"RCR1\";\n\tregs[1].offset = in ? MU3D_EP_TXCR1(epnum) : MU3D_EP_RXCR1(epnum);\n\tregs[2].name = in ? \"TCR2\" : \"RCR2\";\n\tregs[2].offset = in ? MU3D_EP_TXCR2(epnum) : MU3D_EP_RXCR2(epnum);\n\tregs[3].name = in ? \"TQHIAR\" : \"RQHIAR\";\n\tregs[3].offset = in ? USB_QMU_TQHIAR(epnum) : USB_QMU_RQHIAR(epnum);\n\tregs[4].name = in ? \"TQCSR\" : \"RQCSR\";\n\tregs[4].offset = in ? USB_QMU_TQCSR(epnum) : USB_QMU_RQCSR(epnum);\n\tregs[5].name = in ? \"TQSAR\" : \"RQSAR\";\n\tregs[5].offset = in ? USB_QMU_TQSAR(epnum) : USB_QMU_RQSAR(epnum);\n\tregs[6].name = in ? \"TQCPR\" : \"RQCPR\";\n\tregs[6].offset = in ? USB_QMU_TQCPR(epnum) : USB_QMU_RQCPR(epnum);\n\n\tmtu3_debugfs_regset(mtu, mtu->mac_base, regs, 7, \"ep-regs\", parent);\n}\n\nstatic int mtu3_ep_info_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3_ep *mep = sf->private;\n\tstruct mtu3 *mtu = mep->mtu;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tseq_printf(sf, \"ep - type:%s, maxp:%d, slot:%d, flags:%x\\n\",\n\t\t   usb_ep_type_string(mep->type), mep->maxp, mep->slot, mep->flags);\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtu3_fifo_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3_ep *mep = sf->private;\n\tstruct mtu3 *mtu = mep->mtu;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tseq_printf(sf, \"fifo - seg_size:%d, addr:%d, size:%d\\n\",\n\t\t   mep->fifo_seg_size, mep->fifo_addr, mep->fifo_size);\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtu3_qmu_ring_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3_ep *mep = sf->private;\n\tstruct mtu3 *mtu = mep->mtu;\n\tstruct mtu3_gpd_ring *ring;\n\tunsigned long flags;\n\n\tring = &mep->gpd_ring;\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tseq_printf(sf,\n\t\t   \"qmu-ring - dma:%pad, start:%p, end:%p, enq:%p, dep:%p\\n\",\n\t\t   &ring->dma, ring->start, ring->end,\n\t\t   ring->enqueue, ring->dequeue);\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn 0;\n}\n\nstatic int mtu3_qmu_gpd_show(struct seq_file *sf, void *unused)\n{\n\tstruct mtu3_ep *mep = sf->private;\n\tstruct mtu3 *mtu = mep->mtu;\n\tstruct mtu3_gpd_ring *ring;\n\tstruct qmu_gpd *gpd;\n\tdma_addr_t dma;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mtu->lock, flags);\n\tring = &mep->gpd_ring;\n\tgpd = ring->start;\n\tif (!gpd || !(mep->flags & MTU3_EP_ENABLED)) {\n\t\tseq_puts(sf, \"empty!\\n\");\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAX_GPD_NUM; i++, gpd++) {\n\t\tdma = ring->dma + i * sizeof(*gpd);\n\t\tseq_printf(sf, \"gpd.%03d -> %pad, %p: %08x %08x %08x %08x\\n\",\n\t\t\t   i, &dma, gpd, gpd->dw0_info, gpd->next_gpd,\n\t\t\t   gpd->buffer, gpd->dw3_info);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&mtu->lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct mtu3_file_map mtu3_ep_files[] = {\n\t{\"ep-info\", mtu3_ep_info_show, },\n\t{\"fifo\", mtu3_fifo_show, },\n\t{\"qmu-ring\", mtu3_qmu_ring_show, },\n\t{\"qmu-gpd\", mtu3_qmu_gpd_show, },\n};\n\nstatic int mtu3_ep_open(struct inode *inode, struct file *file)\n{\n\tconst char *file_name = file_dentry(file)->d_iname;\n\tconst struct mtu3_file_map *f_map;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtu3_ep_files); i++) {\n\t\tf_map = &mtu3_ep_files[i];\n\n\t\tif (strcmp(f_map->name, file_name) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn single_open(file, f_map->show, inode->i_private);\n}\n\nstatic const struct file_operations mtu3_ep_fops = {\n\t.open = mtu3_ep_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic const struct debugfs_reg32 mtu3_prb_regs[] = {\n\tdump_prb_reg(\"enable\", U3D_SSUSB_PRB_CTRL0),\n\tdump_prb_reg(\"byte-sell\", U3D_SSUSB_PRB_CTRL1),\n\tdump_prb_reg(\"byte-selh\", U3D_SSUSB_PRB_CTRL2),\n\tdump_prb_reg(\"module-sel\", U3D_SSUSB_PRB_CTRL3),\n\tdump_prb_reg(\"sw-out\", U3D_SSUSB_PRB_CTRL4),\n\tdump_prb_reg(\"data\", U3D_SSUSB_PRB_CTRL5),\n};\n\nstatic int mtu3_probe_show(struct seq_file *sf, void *unused)\n{\n\tconst char *file_name = file_dentry(sf->file)->d_iname;\n\tstruct mtu3 *mtu = sf->private;\n\tconst struct debugfs_reg32 *regs;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtu3_prb_regs); i++) {\n\t\tregs = &mtu3_prb_regs[i];\n\n\t\tif (strcmp(regs->name, file_name) == 0)\n\t\t\tbreak;\n\t}\n\n\tseq_printf(sf, \"0x%04x - 0x%08x\\n\", (u32)regs->offset,\n\t\t   mtu3_readl(mtu->ippc_base, (u32)regs->offset));\n\n\treturn 0;\n}\n\nstatic int mtu3_probe_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, mtu3_probe_show, inode->i_private);\n}\n\nstatic ssize_t mtu3_probe_write(struct file *file, const char __user *ubuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tconst char *file_name = file_dentry(file)->d_iname;\n\tstruct seq_file *sf = file->private_data;\n\tstruct mtu3 *mtu = sf->private;\n\tconst struct debugfs_reg32 *regs;\n\tchar buf[32];\n\tu32 val;\n\tint i;\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (kstrtou32(buf, 0, &val))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < ARRAY_SIZE(mtu3_prb_regs); i++) {\n\t\tregs = &mtu3_prb_regs[i];\n\n\t\tif (strcmp(regs->name, file_name) == 0)\n\t\t\tbreak;\n\t}\n\tmtu3_writel(mtu->ippc_base, (u32)regs->offset, val);\n\n\treturn count;\n}\n\nstatic const struct file_operations mtu3_probe_fops = {\n\t.open = mtu3_probe_open,\n\t.write = mtu3_probe_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic void mtu3_debugfs_create_prb_files(struct mtu3 *mtu)\n{\n\tstruct ssusb_mtk *ssusb = mtu->ssusb;\n\tconst struct debugfs_reg32 *regs;\n\tstruct dentry *dir_prb;\n\tint i;\n\n\tdir_prb = debugfs_create_dir(\"probe\", ssusb->dbgfs_root);\n\n\tfor (i = 0; i < ARRAY_SIZE(mtu3_prb_regs); i++) {\n\t\tregs = &mtu3_prb_regs[i];\n\t\tdebugfs_create_file(regs->name, 0644, dir_prb,\n\t\t\t\t    mtu, &mtu3_probe_fops);\n\t}\n\n\tmtu3_debugfs_regset(mtu, mtu->ippc_base, mtu3_prb_regs,\n\t\t\t    ARRAY_SIZE(mtu3_prb_regs), \"regs\", dir_prb);\n}\n\nstatic void mtu3_debugfs_create_ep_dir(struct mtu3_ep *mep,\n\t\t\t\t       struct dentry *parent)\n{\n\tconst struct mtu3_file_map *files;\n\tstruct dentry *dir_ep;\n\tint i;\n\n\tdir_ep = debugfs_create_dir(mep->name, parent);\n\tmtu3_debugfs_ep_regset(mep->mtu, mep, dir_ep);\n\n\tfor (i = 0; i < ARRAY_SIZE(mtu3_ep_files); i++) {\n\t\tfiles = &mtu3_ep_files[i];\n\n\t\tdebugfs_create_file(files->name, 0444, dir_ep,\n\t\t\t\t    mep, &mtu3_ep_fops);\n\t}\n}\n\nstatic void mtu3_debugfs_create_ep_dirs(struct mtu3 *mtu)\n{\n\tstruct ssusb_mtk *ssusb = mtu->ssusb;\n\tstruct dentry *dir_eps;\n\tint i;\n\n\tdir_eps = debugfs_create_dir(\"eps\", ssusb->dbgfs_root);\n\n\tfor (i = 1; i < mtu->num_eps; i++) {\n\t\tmtu3_debugfs_create_ep_dir(mtu->in_eps + i, dir_eps);\n\t\tmtu3_debugfs_create_ep_dir(mtu->out_eps + i, dir_eps);\n\t}\n}\n\nvoid ssusb_dev_debugfs_init(struct ssusb_mtk *ssusb)\n{\n\tstruct mtu3 *mtu = ssusb->u3d;\n\tstruct dentry *dir_regs;\n\n\tdir_regs = debugfs_create_dir(\"regs\", ssusb->dbgfs_root);\n\n\tmtu3_debugfs_regset(mtu, mtu->ippc_base,\n\t\t\t    mtu3_ippc_regs, ARRAY_SIZE(mtu3_ippc_regs),\n\t\t\t    \"reg-ippc\", dir_regs);\n\n\tmtu3_debugfs_regset(mtu, mtu->mac_base,\n\t\t\t    mtu3_dev_regs, ARRAY_SIZE(mtu3_dev_regs),\n\t\t\t    \"reg-dev\", dir_regs);\n\n\tmtu3_debugfs_regset(mtu, mtu->mac_base,\n\t\t\t    mtu3_csr_regs, ARRAY_SIZE(mtu3_csr_regs),\n\t\t\t    \"reg-csr\", dir_regs);\n\n\tmtu3_debugfs_create_ep_dirs(mtu);\n\n\tmtu3_debugfs_create_prb_files(mtu);\n\n\tdebugfs_create_file(\"link-state\", 0444, ssusb->dbgfs_root,\n\t\t\t    mtu, &mtu3_link_state_fops);\n\tdebugfs_create_file(\"ep-used\", 0444, ssusb->dbgfs_root,\n\t\t\t    mtu, &mtu3_ep_used_fops);\n}\n\nstatic int ssusb_mode_show(struct seq_file *sf, void *unused)\n{\n\tstruct ssusb_mtk *ssusb = sf->private;\n\n\tseq_printf(sf, \"current mode: %s(%s drd)\\n(echo device/host)\\n\",\n\t\t   ssusb->is_host ? \"host\" : \"device\",\n\t\t   ssusb->otg_switch.manual_drd_enabled ? \"manual\" : \"auto\");\n\n\treturn 0;\n}\n\nstatic int ssusb_mode_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ssusb_mode_show, inode->i_private);\n}\n\nstatic ssize_t ssusb_mode_write(struct file *file, const char __user *ubuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct ssusb_mtk *ssusb = sf->private;\n\tchar buf[16];\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"host\", 4) && !ssusb->is_host) {\n\t\tssusb_mode_switch(ssusb, 1);\n\t} else if (!strncmp(buf, \"device\", 6) && ssusb->is_host) {\n\t\tssusb_mode_switch(ssusb, 0);\n\t} else {\n\t\tdev_err(ssusb->dev, \"wrong or duplicated setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations ssusb_mode_fops = {\n\t.open = ssusb_mode_open,\n\t.write = ssusb_mode_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int ssusb_vbus_show(struct seq_file *sf, void *unused)\n{\n\tstruct ssusb_mtk *ssusb = sf->private;\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\n\tseq_printf(sf, \"vbus state: %s\\n(echo on/off)\\n\",\n\t\t   regulator_is_enabled(otg_sx->vbus) ? \"on\" : \"off\");\n\n\treturn 0;\n}\n\nstatic int ssusb_vbus_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, ssusb_vbus_show, inode->i_private);\n}\n\nstatic ssize_t ssusb_vbus_write(struct file *file, const char __user *ubuf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct seq_file *sf = file->private_data;\n\tstruct ssusb_mtk *ssusb = sf->private;\n\tstruct otg_switch_mtk *otg_sx = &ssusb->otg_switch;\n\tchar buf[16];\n\tbool enable;\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (kstrtobool(buf, &enable)) {\n\t\tdev_err(ssusb->dev, \"wrong setting\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tssusb_set_vbus(otg_sx, enable);\n\n\treturn count;\n}\n\nstatic const struct file_operations ssusb_vbus_fops = {\n\t.open = ssusb_vbus_open,\n\t.write = ssusb_vbus_write,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nvoid ssusb_dr_debugfs_init(struct ssusb_mtk *ssusb)\n{\n\tstruct dentry *root = ssusb->dbgfs_root;\n\n\tdebugfs_create_file(\"mode\", 0644, root, ssusb, &ssusb_mode_fops);\n\tdebugfs_create_file(\"vbus\", 0644, root, ssusb, &ssusb_vbus_fops);\n}\n\nvoid ssusb_debugfs_create_root(struct ssusb_mtk *ssusb)\n{\n\tssusb->dbgfs_root =\n\t\tdebugfs_create_dir(dev_name(ssusb->dev), usb_debug_root);\n}\n\nvoid ssusb_debugfs_remove_root(struct ssusb_mtk *ssusb)\n{\n\tdebugfs_remove_recursive(ssusb->dbgfs_root);\n\tssusb->dbgfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}