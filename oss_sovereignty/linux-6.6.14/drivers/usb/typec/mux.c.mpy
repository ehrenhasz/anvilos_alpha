{
  "module_name": "mux.c",
  "hash_id": "cfbf755c7a3f3a9e43628855af6ecc3f73745b0d4f366a32164ebc7ff130c2f5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/mux.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"class.h\"\n#include \"mux.h\"\n\n#define TYPEC_MUX_MAX_DEVS\t3\n\nstruct typec_switch {\n\tstruct typec_switch_dev *sw_devs[TYPEC_MUX_MAX_DEVS];\n\tunsigned int num_sw_devs;\n};\n\nstatic int switch_fwnode_match(struct device *dev, const void *fwnode)\n{\n\tif (!is_typec_switch_dev(dev))\n\t\treturn 0;\n\n\treturn device_match_fwnode(dev, fwnode);\n}\n\nstatic void *typec_switch_match(const struct fwnode_handle *fwnode,\n\t\t\t\tconst char *id, void *data)\n{\n\tstruct device *dev;\n\n\t \n\tif (id && !fwnode_property_present(fwnode, id))\n\t\treturn NULL;\n\n\t \n\tdev = class_find_device(&typec_mux_class, NULL, fwnode,\n\t\t\t\tswitch_fwnode_match);\n\n\treturn dev ? to_typec_switch_dev(dev) : ERR_PTR(-EPROBE_DEFER);\n}\n\n \nstruct typec_switch *fwnode_typec_switch_get(struct fwnode_handle *fwnode)\n{\n\tstruct typec_switch_dev *sw_devs[TYPEC_MUX_MAX_DEVS];\n\tstruct typec_switch *sw;\n\tint count;\n\tint err;\n\tint i;\n\n\tsw = kzalloc(sizeof(*sw), GFP_KERNEL);\n\tif (!sw)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcount = fwnode_connection_find_matches(fwnode, \"orientation-switch\", NULL,\n\t\t\t\t\t       typec_switch_match,\n\t\t\t\t\t       (void **)sw_devs,\n\t\t\t\t\t       ARRAY_SIZE(sw_devs));\n\tif (count <= 0) {\n\t\tkfree(sw);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (IS_ERR(sw_devs[i])) {\n\t\t\terr = PTR_ERR(sw_devs[i]);\n\t\t\tgoto put_sw_devs;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tWARN_ON(!try_module_get(sw_devs[i]->dev.parent->driver->owner));\n\t\tsw->sw_devs[i] = sw_devs[i];\n\t}\n\n\tsw->num_sw_devs = count;\n\n\treturn sw;\n\nput_sw_devs:\n\tfor (i = 0; i < count; i++) {\n\t\tif (!IS_ERR(sw_devs[i]))\n\t\t\tput_device(&sw_devs[i]->dev);\n\t}\n\n\tkfree(sw);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(fwnode_typec_switch_get);\n\n \nvoid typec_switch_put(struct typec_switch *sw)\n{\n\tstruct typec_switch_dev *sw_dev;\n\tunsigned int i;\n\n\tif (IS_ERR_OR_NULL(sw))\n\t\treturn;\n\n\tfor (i = 0; i < sw->num_sw_devs; i++) {\n\t\tsw_dev = sw->sw_devs[i];\n\n\t\tmodule_put(sw_dev->dev.parent->driver->owner);\n\t\tput_device(&sw_dev->dev);\n\t}\n\tkfree(sw);\n}\nEXPORT_SYMBOL_GPL(typec_switch_put);\n\nstatic void typec_switch_release(struct device *dev)\n{\n\tkfree(to_typec_switch_dev(dev));\n}\n\nconst struct device_type typec_switch_dev_type = {\n\t.name = \"orientation_switch\",\n\t.release = typec_switch_release,\n};\n\n \nstruct typec_switch_dev *\ntypec_switch_register(struct device *parent,\n\t\t      const struct typec_switch_desc *desc)\n{\n\tstruct typec_switch_dev *sw_dev;\n\tint ret;\n\n\tif (!desc || !desc->set)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsw_dev = kzalloc(sizeof(*sw_dev), GFP_KERNEL);\n\tif (!sw_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsw_dev->set = desc->set;\n\n\tdevice_initialize(&sw_dev->dev);\n\tsw_dev->dev.parent = parent;\n\tsw_dev->dev.fwnode = desc->fwnode;\n\tsw_dev->dev.class = &typec_mux_class;\n\tsw_dev->dev.type = &typec_switch_dev_type;\n\tsw_dev->dev.driver_data = desc->drvdata;\n\tret = dev_set_name(&sw_dev->dev, \"%s-switch\", desc->name ? desc->name : dev_name(parent));\n\tif (ret) {\n\t\tput_device(&sw_dev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = device_add(&sw_dev->dev);\n\tif (ret) {\n\t\tdev_err(parent, \"failed to register switch (%d)\\n\", ret);\n\t\tput_device(&sw_dev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn sw_dev;\n}\nEXPORT_SYMBOL_GPL(typec_switch_register);\n\nint typec_switch_set(struct typec_switch *sw,\n\t\t     enum typec_orientation orientation)\n{\n\tstruct typec_switch_dev *sw_dev;\n\tunsigned int i;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(sw))\n\t\treturn 0;\n\n\tfor (i = 0; i < sw->num_sw_devs; i++) {\n\t\tsw_dev = sw->sw_devs[i];\n\n\t\tret = sw_dev->set(sw_dev, orientation);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_switch_set);\n\n \nvoid typec_switch_unregister(struct typec_switch_dev *sw_dev)\n{\n\tif (!IS_ERR_OR_NULL(sw_dev))\n\t\tdevice_unregister(&sw_dev->dev);\n}\nEXPORT_SYMBOL_GPL(typec_switch_unregister);\n\nvoid typec_switch_set_drvdata(struct typec_switch_dev *sw_dev, void *data)\n{\n\tdev_set_drvdata(&sw_dev->dev, data);\n}\nEXPORT_SYMBOL_GPL(typec_switch_set_drvdata);\n\nvoid *typec_switch_get_drvdata(struct typec_switch_dev *sw_dev)\n{\n\treturn dev_get_drvdata(&sw_dev->dev);\n}\nEXPORT_SYMBOL_GPL(typec_switch_get_drvdata);\n\n \n\nstruct typec_mux {\n\tstruct typec_mux_dev *mux_devs[TYPEC_MUX_MAX_DEVS];\n\tunsigned int num_mux_devs;\n};\n\nstatic int mux_fwnode_match(struct device *dev, const void *fwnode)\n{\n\tif (!is_typec_mux_dev(dev))\n\t\treturn 0;\n\n\treturn device_match_fwnode(dev, fwnode);\n}\n\nstatic void *typec_mux_match(const struct fwnode_handle *fwnode,\n\t\t\t     const char *id, void *data)\n{\n\tstruct device *dev;\n\n\t \n\tif (id && !fwnode_property_present(fwnode, id))\n\t\treturn NULL;\n\n\tdev = class_find_device(&typec_mux_class, NULL, fwnode,\n\t\t\t\tmux_fwnode_match);\n\n\treturn dev ? to_typec_mux_dev(dev) : ERR_PTR(-EPROBE_DEFER);\n}\n\n \nstruct typec_mux *fwnode_typec_mux_get(struct fwnode_handle *fwnode)\n{\n\tstruct typec_mux_dev *mux_devs[TYPEC_MUX_MAX_DEVS];\n\tstruct typec_mux *mux;\n\tint count;\n\tint err;\n\tint i;\n\n\tmux = kzalloc(sizeof(*mux), GFP_KERNEL);\n\tif (!mux)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcount = fwnode_connection_find_matches(fwnode, \"mode-switch\",\n\t\t\t\t\t       NULL, typec_mux_match,\n\t\t\t\t\t       (void **)mux_devs,\n\t\t\t\t\t       ARRAY_SIZE(mux_devs));\n\tif (count <= 0) {\n\t\tkfree(mux);\n\t\treturn NULL;\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tif (IS_ERR(mux_devs[i])) {\n\t\t\terr = PTR_ERR(mux_devs[i]);\n\t\t\tgoto put_mux_devs;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\t\tWARN_ON(!try_module_get(mux_devs[i]->dev.parent->driver->owner));\n\t\tmux->mux_devs[i] = mux_devs[i];\n\t}\n\n\tmux->num_mux_devs = count;\n\n\treturn mux;\n\nput_mux_devs:\n\tfor (i = 0; i < count; i++) {\n\t\tif (!IS_ERR(mux_devs[i]))\n\t\t\tput_device(&mux_devs[i]->dev);\n\t}\n\n\tkfree(mux);\n\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(fwnode_typec_mux_get);\n\n \nvoid typec_mux_put(struct typec_mux *mux)\n{\n\tstruct typec_mux_dev *mux_dev;\n\tunsigned int i;\n\n\tif (IS_ERR_OR_NULL(mux))\n\t\treturn;\n\n\tfor (i = 0; i < mux->num_mux_devs; i++) {\n\t\tmux_dev = mux->mux_devs[i];\n\t\tmodule_put(mux_dev->dev.parent->driver->owner);\n\t\tput_device(&mux_dev->dev);\n\t}\n\tkfree(mux);\n}\nEXPORT_SYMBOL_GPL(typec_mux_put);\n\nint typec_mux_set(struct typec_mux *mux, struct typec_mux_state *state)\n{\n\tstruct typec_mux_dev *mux_dev;\n\tunsigned int i;\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(mux))\n\t\treturn 0;\n\n\tfor (i = 0; i < mux->num_mux_devs; i++) {\n\t\tmux_dev = mux->mux_devs[i];\n\n\t\tret = mux_dev->set(mux_dev, state);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_mux_set);\n\nstatic void typec_mux_release(struct device *dev)\n{\n\tkfree(to_typec_mux_dev(dev));\n}\n\nconst struct device_type typec_mux_dev_type = {\n\t.name = \"mode_switch\",\n\t.release = typec_mux_release,\n};\n\n \nstruct typec_mux_dev *\ntypec_mux_register(struct device *parent, const struct typec_mux_desc *desc)\n{\n\tstruct typec_mux_dev *mux_dev;\n\tint ret;\n\n\tif (!desc || !desc->set)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmux_dev = kzalloc(sizeof(*mux_dev), GFP_KERNEL);\n\tif (!mux_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmux_dev->set = desc->set;\n\n\tdevice_initialize(&mux_dev->dev);\n\tmux_dev->dev.parent = parent;\n\tmux_dev->dev.fwnode = desc->fwnode;\n\tmux_dev->dev.class = &typec_mux_class;\n\tmux_dev->dev.type = &typec_mux_dev_type;\n\tmux_dev->dev.driver_data = desc->drvdata;\n\tret = dev_set_name(&mux_dev->dev, \"%s-mux\", desc->name ? desc->name : dev_name(parent));\n\tif (ret) {\n\t\tput_device(&mux_dev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = device_add(&mux_dev->dev);\n\tif (ret) {\n\t\tdev_err(parent, \"failed to register mux (%d)\\n\", ret);\n\t\tput_device(&mux_dev->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn mux_dev;\n}\nEXPORT_SYMBOL_GPL(typec_mux_register);\n\n \nvoid typec_mux_unregister(struct typec_mux_dev *mux_dev)\n{\n\tif (!IS_ERR_OR_NULL(mux_dev))\n\t\tdevice_unregister(&mux_dev->dev);\n}\nEXPORT_SYMBOL_GPL(typec_mux_unregister);\n\nvoid typec_mux_set_drvdata(struct typec_mux_dev *mux_dev, void *data)\n{\n\tdev_set_drvdata(&mux_dev->dev, data);\n}\nEXPORT_SYMBOL_GPL(typec_mux_set_drvdata);\n\nvoid *typec_mux_get_drvdata(struct typec_mux_dev *mux_dev)\n{\n\treturn dev_get_drvdata(&mux_dev->dev);\n}\nEXPORT_SYMBOL_GPL(typec_mux_get_drvdata);\n\nstruct class typec_mux_class = {\n\t.name = \"typec_mux\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}