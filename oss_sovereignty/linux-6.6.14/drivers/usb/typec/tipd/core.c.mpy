{
  "module_name": "core.c",
  "hash_id": "50116b33fe2d33681ec474de9b466cc7256747bb06e529f92b87bfb01f9167f4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tipd/core.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/interrupt.h>\n#include <linux/usb/typec.h>\n#include <linux/usb/typec_altmode.h>\n#include <linux/usb/role.h>\n#include <linux/workqueue.h>\n\n#include \"tps6598x.h\"\n#include \"trace.h\"\n\n \n#define TPS_REG_VID\t\t\t0x00\n#define TPS_REG_MODE\t\t\t0x03\n#define TPS_REG_CMD1\t\t\t0x08\n#define TPS_REG_DATA1\t\t\t0x09\n#define TPS_REG_INT_EVENT1\t\t0x14\n#define TPS_REG_INT_EVENT2\t\t0x15\n#define TPS_REG_INT_MASK1\t\t0x16\n#define TPS_REG_INT_MASK2\t\t0x17\n#define TPS_REG_INT_CLEAR1\t\t0x18\n#define TPS_REG_INT_CLEAR2\t\t0x19\n#define TPS_REG_SYSTEM_POWER_STATE\t0x20\n#define TPS_REG_STATUS\t\t\t0x1a\n#define TPS_REG_SYSTEM_CONF\t\t0x28\n#define TPS_REG_CTRL_CONF\t\t0x29\n#define TPS_REG_POWER_STATUS\t\t0x3f\n#define TPS_REG_RX_IDENTITY_SOP\t\t0x48\n#define TPS_REG_DATA_STATUS\t\t0x5f\n\n \n#define TPS_SYSCONF_PORTINFO(c)\t\t((c) & 7)\n\nenum {\n\tTPS_PORTINFO_SINK,\n\tTPS_PORTINFO_SINK_ACCESSORY,\n\tTPS_PORTINFO_DRP_UFP,\n\tTPS_PORTINFO_DRP_UFP_DRD,\n\tTPS_PORTINFO_DRP_DFP,\n\tTPS_PORTINFO_DRP_DFP_DRD,\n\tTPS_PORTINFO_SOURCE,\n};\n\n \nstruct tps6598x_rx_identity_reg {\n\tu8 status;\n\tstruct usb_pd_identity identity;\n} __packed;\n\n \n#define TPS_TASK_TIMEOUT\t\t1\n#define TPS_TASK_REJECTED\t\t3\n\nenum {\n\tTPS_MODE_APP,\n\tTPS_MODE_BOOT,\n\tTPS_MODE_BIST,\n\tTPS_MODE_DISC,\n};\n\nstatic const char *const modes[] = {\n\t[TPS_MODE_APP]\t= \"APP \",\n\t[TPS_MODE_BOOT]\t= \"BOOT\",\n\t[TPS_MODE_BIST]\t= \"BIST\",\n\t[TPS_MODE_DISC]\t= \"DISC\",\n};\n\n \n#define INVALID_CMD(_cmd_)\t\t(_cmd_ == 0x444d4321)\n\nstruct tps6598x {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct mutex lock;  \n\tu8 i2c_protocol:1;\n\n\tstruct typec_port *port;\n\tstruct typec_partner *partner;\n\tstruct usb_pd_identity partner_identity;\n\tstruct usb_role_switch *role_sw;\n\tstruct typec_capability typec_cap;\n\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tenum power_supply_usb_type usb_type;\n\n\tint wakeup;\n\tu16 pwr_status;\n\tstruct delayed_work\twq_poll;\n\tirq_handler_t irq_handler;\n};\n\nstatic enum power_supply_property tps6598x_psy_props[] = {\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic enum power_supply_usb_type tps6598x_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n};\n\nstatic const char *tps6598x_psy_name_prefix = \"tps6598x-source-psy-\";\n\n \n#define TPS_MAX_LEN\t64\n\nstatic int\ntps6598x_block_read(struct tps6598x *tps, u8 reg, void *val, size_t len)\n{\n\tu8 data[TPS_MAX_LEN + 1];\n\tint ret;\n\n\tif (len + 1 > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (!tps->i2c_protocol)\n\t\treturn regmap_raw_read(tps->regmap, reg, val, len);\n\n\tret = regmap_raw_read(tps->regmap, reg, data, len + 1);\n\tif (ret)\n\t\treturn ret;\n\n\tif (data[0] < len)\n\t\treturn -EIO;\n\n\tmemcpy(val, &data[1], len);\n\treturn 0;\n}\n\nstatic int tps6598x_block_write(struct tps6598x *tps, u8 reg,\n\t\t\t\tconst void *val, size_t len)\n{\n\tu8 data[TPS_MAX_LEN + 1];\n\n\tif (len + 1 > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (!tps->i2c_protocol)\n\t\treturn regmap_raw_write(tps->regmap, reg, val, len);\n\n\tdata[0] = len;\n\tmemcpy(&data[1], val, len);\n\n\treturn regmap_raw_write(tps->regmap, reg, data, len + 1);\n}\n\nstatic inline int tps6598x_read8(struct tps6598x *tps, u8 reg, u8 *val)\n{\n\treturn tps6598x_block_read(tps, reg, val, sizeof(u8));\n}\n\nstatic inline int tps6598x_read16(struct tps6598x *tps, u8 reg, u16 *val)\n{\n\treturn tps6598x_block_read(tps, reg, val, sizeof(u16));\n}\n\nstatic inline int tps6598x_read32(struct tps6598x *tps, u8 reg, u32 *val)\n{\n\treturn tps6598x_block_read(tps, reg, val, sizeof(u32));\n}\n\nstatic inline int tps6598x_read64(struct tps6598x *tps, u8 reg, u64 *val)\n{\n\treturn tps6598x_block_read(tps, reg, val, sizeof(u64));\n}\n\nstatic inline int tps6598x_write64(struct tps6598x *tps, u8 reg, u64 val)\n{\n\treturn tps6598x_block_write(tps, reg, &val, sizeof(u64));\n}\n\nstatic inline int\ntps6598x_write_4cc(struct tps6598x *tps, u8 reg, const char *val)\n{\n\treturn tps6598x_block_write(tps, reg, val, 4);\n}\n\nstatic int tps6598x_read_partner_identity(struct tps6598x *tps)\n{\n\tstruct tps6598x_rx_identity_reg id;\n\tint ret;\n\n\tret = tps6598x_block_read(tps, TPS_REG_RX_IDENTITY_SOP,\n\t\t\t\t  &id, sizeof(id));\n\tif (ret)\n\t\treturn ret;\n\n\ttps->partner_identity = id.identity;\n\n\treturn 0;\n}\n\nstatic void tps6598x_set_data_role(struct tps6598x *tps,\n\t\t\t\t   enum typec_data_role role, bool connected)\n{\n\tenum usb_role role_val;\n\n\tif (role == TYPEC_HOST)\n\t\trole_val = USB_ROLE_HOST;\n\telse\n\t\trole_val = USB_ROLE_DEVICE;\n\n\tif (!connected)\n\t\trole_val = USB_ROLE_NONE;\n\n\tusb_role_switch_set_role(tps->role_sw, role_val);\n\ttypec_set_data_role(tps->port, role);\n}\n\nstatic int tps6598x_connect(struct tps6598x *tps, u32 status)\n{\n\tstruct typec_partner_desc desc;\n\tenum typec_pwr_opmode mode;\n\tint ret;\n\n\tif (tps->partner)\n\t\treturn 0;\n\n\tmode = TPS_POWER_STATUS_PWROPMODE(tps->pwr_status);\n\n\tdesc.usb_pd = mode == TYPEC_PWR_MODE_PD;\n\tdesc.accessory = TYPEC_ACCESSORY_NONE;  \n\tdesc.identity = NULL;\n\n\tif (desc.usb_pd) {\n\t\tret = tps6598x_read_partner_identity(tps);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tdesc.identity = &tps->partner_identity;\n\t}\n\n\ttypec_set_pwr_opmode(tps->port, mode);\n\ttypec_set_pwr_role(tps->port, TPS_STATUS_TO_TYPEC_PORTROLE(status));\n\ttypec_set_vconn_role(tps->port, TPS_STATUS_TO_TYPEC_VCONN(status));\n\tif (TPS_STATUS_TO_UPSIDE_DOWN(status))\n\t\ttypec_set_orientation(tps->port, TYPEC_ORIENTATION_REVERSE);\n\telse\n\t\ttypec_set_orientation(tps->port, TYPEC_ORIENTATION_NORMAL);\n\ttypec_set_mode(tps->port, TYPEC_STATE_USB);\n\ttps6598x_set_data_role(tps, TPS_STATUS_TO_TYPEC_DATAROLE(status), true);\n\n\ttps->partner = typec_register_partner(tps->port, &desc);\n\tif (IS_ERR(tps->partner))\n\t\treturn PTR_ERR(tps->partner);\n\n\tif (desc.identity)\n\t\ttypec_partner_set_identity(tps->partner);\n\n\tpower_supply_changed(tps->psy);\n\n\treturn 0;\n}\n\nstatic void tps6598x_disconnect(struct tps6598x *tps, u32 status)\n{\n\tif (!IS_ERR(tps->partner))\n\t\ttypec_unregister_partner(tps->partner);\n\ttps->partner = NULL;\n\ttypec_set_pwr_opmode(tps->port, TYPEC_PWR_MODE_USB);\n\ttypec_set_pwr_role(tps->port, TPS_STATUS_TO_TYPEC_PORTROLE(status));\n\ttypec_set_vconn_role(tps->port, TPS_STATUS_TO_TYPEC_VCONN(status));\n\ttypec_set_orientation(tps->port, TYPEC_ORIENTATION_NONE);\n\ttypec_set_mode(tps->port, TYPEC_STATE_SAFE);\n\ttps6598x_set_data_role(tps, TPS_STATUS_TO_TYPEC_DATAROLE(status), false);\n\n\tpower_supply_changed(tps->psy);\n}\n\nstatic int tps6598x_exec_cmd(struct tps6598x *tps, const char *cmd,\n\t\t\t     size_t in_len, u8 *in_data,\n\t\t\t     size_t out_len, u8 *out_data)\n{\n\tunsigned long timeout;\n\tu32 val;\n\tint ret;\n\n\tret = tps6598x_read32(tps, TPS_REG_CMD1, &val);\n\tif (ret)\n\t\treturn ret;\n\tif (val && !INVALID_CMD(val))\n\t\treturn -EBUSY;\n\n\tif (in_len) {\n\t\tret = tps6598x_block_write(tps, TPS_REG_DATA1,\n\t\t\t\t\t   in_data, in_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tret = tps6598x_write_4cc(tps, TPS_REG_CMD1, cmd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(1000);\n\n\tdo {\n\t\tret = tps6598x_read32(tps, TPS_REG_CMD1, &val);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (INVALID_CMD(val))\n\t\t\treturn -EINVAL;\n\n\t\tif (time_is_before_jiffies(timeout))\n\t\t\treturn -ETIMEDOUT;\n\t} while (val);\n\n\tif (out_len) {\n\t\tret = tps6598x_block_read(tps, TPS_REG_DATA1,\n\t\t\t\t\t  out_data, out_len);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tval = out_data[0];\n\t} else {\n\t\tret = tps6598x_block_read(tps, TPS_REG_DATA1, &val, sizeof(u8));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tswitch (val) {\n\tcase TPS_TASK_TIMEOUT:\n\t\treturn -ETIMEDOUT;\n\tcase TPS_TASK_REJECTED:\n\t\treturn -EPERM;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int tps6598x_dr_set(struct typec_port *port, enum typec_data_role role)\n{\n\tconst char *cmd = (role == TYPEC_DEVICE) ? \"SWUF\" : \"SWDF\";\n\tstruct tps6598x *tps = typec_get_drvdata(port);\n\tu32 status;\n\tint ret;\n\n\tmutex_lock(&tps->lock);\n\n\tret = tps6598x_exec_cmd(tps, cmd, 0, NULL, 0, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = tps6598x_read32(tps, TPS_REG_STATUS, &status);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (role != TPS_STATUS_TO_TYPEC_DATAROLE(status)) {\n\t\tret = -EPROTO;\n\t\tgoto out_unlock;\n\t}\n\n\ttps6598x_set_data_role(tps, role, true);\n\nout_unlock:\n\tmutex_unlock(&tps->lock);\n\n\treturn ret;\n}\n\nstatic int tps6598x_pr_set(struct typec_port *port, enum typec_role role)\n{\n\tconst char *cmd = (role == TYPEC_SINK) ? \"SWSk\" : \"SWSr\";\n\tstruct tps6598x *tps = typec_get_drvdata(port);\n\tu32 status;\n\tint ret;\n\n\tmutex_lock(&tps->lock);\n\n\tret = tps6598x_exec_cmd(tps, cmd, 0, NULL, 0, NULL);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tret = tps6598x_read32(tps, TPS_REG_STATUS, &status);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (role != TPS_STATUS_TO_TYPEC_PORTROLE(status)) {\n\t\tret = -EPROTO;\n\t\tgoto out_unlock;\n\t}\n\n\ttypec_set_pwr_role(tps->port, role);\n\nout_unlock:\n\tmutex_unlock(&tps->lock);\n\n\treturn ret;\n}\n\nstatic const struct typec_operations tps6598x_ops = {\n\t.dr_set = tps6598x_dr_set,\n\t.pr_set = tps6598x_pr_set,\n};\n\nstatic bool tps6598x_read_status(struct tps6598x *tps, u32 *status)\n{\n\tint ret;\n\n\tret = tps6598x_read32(tps, TPS_REG_STATUS, status);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"%s: failed to read status\\n\", __func__);\n\t\treturn false;\n\t}\n\ttrace_tps6598x_status(*status);\n\n\treturn true;\n}\n\nstatic bool tps6598x_read_data_status(struct tps6598x *tps)\n{\n\tu32 data_status;\n\tint ret;\n\n\tret = tps6598x_read32(tps, TPS_REG_DATA_STATUS, &data_status);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"failed to read data status: %d\\n\", ret);\n\t\treturn false;\n\t}\n\ttrace_tps6598x_data_status(data_status);\n\n\treturn true;\n}\n\nstatic bool tps6598x_read_power_status(struct tps6598x *tps)\n{\n\tu16 pwr_status;\n\tint ret;\n\n\tret = tps6598x_read16(tps, TPS_REG_POWER_STATUS, &pwr_status);\n\tif (ret < 0) {\n\t\tdev_err(tps->dev, \"failed to read power status: %d\\n\", ret);\n\t\treturn false;\n\t}\n\ttps->pwr_status = pwr_status;\n\ttrace_tps6598x_power_status(pwr_status);\n\n\treturn true;\n}\n\nstatic void tps6598x_handle_plug_event(struct tps6598x *tps, u32 status)\n{\n\tint ret;\n\n\tif (status & TPS_STATUS_PLUG_PRESENT) {\n\t\tret = tps6598x_connect(tps, status);\n\t\tif (ret)\n\t\t\tdev_err(tps->dev, \"failed to register partner\\n\");\n\t} else {\n\t\ttps6598x_disconnect(tps, status);\n\t}\n}\n\nstatic irqreturn_t cd321x_interrupt(int irq, void *data)\n{\n\tstruct tps6598x *tps = data;\n\tu64 event = 0;\n\tu32 status;\n\tint ret;\n\n\tmutex_lock(&tps->lock);\n\n\tret = tps6598x_read64(tps, TPS_REG_INT_EVENT1, &event);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"%s: failed to read events\\n\", __func__);\n\t\tgoto err_unlock;\n\t}\n\ttrace_cd321x_irq(event);\n\n\tif (!event)\n\t\tgoto err_unlock;\n\n\tif (!tps6598x_read_status(tps, &status))\n\t\tgoto err_clear_ints;\n\n\tif (event & APPLE_CD_REG_INT_POWER_STATUS_UPDATE)\n\t\tif (!tps6598x_read_power_status(tps))\n\t\t\tgoto err_clear_ints;\n\n\tif (event & APPLE_CD_REG_INT_DATA_STATUS_UPDATE)\n\t\tif (!tps6598x_read_data_status(tps))\n\t\t\tgoto err_clear_ints;\n\n\t \n\tif (event & APPLE_CD_REG_INT_PLUG_EVENT)\n\t\ttps6598x_handle_plug_event(tps, status);\n\nerr_clear_ints:\n\ttps6598x_write64(tps, TPS_REG_INT_CLEAR1, event);\n\nerr_unlock:\n\tmutex_unlock(&tps->lock);\n\n\tif (event)\n\t\treturn IRQ_HANDLED;\n\treturn IRQ_NONE;\n}\n\nstatic irqreturn_t tps6598x_interrupt(int irq, void *data)\n{\n\tstruct tps6598x *tps = data;\n\tu64 event1 = 0;\n\tu64 event2 = 0;\n\tu32 status;\n\tint ret;\n\n\tmutex_lock(&tps->lock);\n\n\tret = tps6598x_read64(tps, TPS_REG_INT_EVENT1, &event1);\n\tret |= tps6598x_read64(tps, TPS_REG_INT_EVENT2, &event2);\n\tif (ret) {\n\t\tdev_err(tps->dev, \"%s: failed to read events\\n\", __func__);\n\t\tgoto err_unlock;\n\t}\n\ttrace_tps6598x_irq(event1, event2);\n\n\tif (!(event1 | event2))\n\t\tgoto err_unlock;\n\n\tif (!tps6598x_read_status(tps, &status))\n\t\tgoto err_clear_ints;\n\n\tif ((event1 | event2) & TPS_REG_INT_POWER_STATUS_UPDATE)\n\t\tif (!tps6598x_read_power_status(tps))\n\t\t\tgoto err_clear_ints;\n\n\tif ((event1 | event2) & TPS_REG_INT_DATA_STATUS_UPDATE)\n\t\tif (!tps6598x_read_data_status(tps))\n\t\t\tgoto err_clear_ints;\n\n\t \n\tif ((event1 | event2) & TPS_REG_INT_PLUG_EVENT)\n\t\ttps6598x_handle_plug_event(tps, status);\n\nerr_clear_ints:\n\ttps6598x_write64(tps, TPS_REG_INT_CLEAR1, event1);\n\ttps6598x_write64(tps, TPS_REG_INT_CLEAR2, event2);\n\nerr_unlock:\n\tmutex_unlock(&tps->lock);\n\n\tif (event1 | event2)\n\t\treturn IRQ_HANDLED;\n\treturn IRQ_NONE;\n}\n\n \n#define POLL_INTERVAL\t500  \nstatic void tps6598x_poll_work(struct work_struct *work)\n{\n\tstruct tps6598x *tps = container_of(to_delayed_work(work),\n\t\t\t\t\t    struct tps6598x, wq_poll);\n\n\ttps->irq_handler(0, tps);\n\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t   &tps->wq_poll, msecs_to_jiffies(POLL_INTERVAL));\n}\n\nstatic int tps6598x_check_mode(struct tps6598x *tps)\n{\n\tchar mode[5] = { };\n\tint ret;\n\n\tret = tps6598x_read32(tps, TPS_REG_MODE, (void *)mode);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (match_string(modes, ARRAY_SIZE(modes), mode)) {\n\tcase TPS_MODE_APP:\n\t\treturn 0;\n\tcase TPS_MODE_BOOT:\n\t\tdev_warn(tps->dev, \"dead-battery condition\\n\");\n\t\treturn 0;\n\tcase TPS_MODE_BIST:\n\tcase TPS_MODE_DISC:\n\tdefault:\n\t\tdev_err(tps->dev, \"controller in unsupported mode \\\"%s\\\"\\n\",\n\t\t\tmode);\n\t\tbreak;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic const struct regmap_config tps6598x_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x7F,\n};\n\nstatic int tps6598x_psy_get_online(struct tps6598x *tps,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tif (TPS_POWER_STATUS_CONNECTION(tps->pwr_status) &&\n\t    TPS_POWER_STATUS_SOURCESINK(tps->pwr_status)) {\n\t\tval->intval = 1;\n\t} else {\n\t\tval->intval = 0;\n\t}\n\treturn 0;\n}\n\nstatic int tps6598x_psy_get_prop(struct power_supply *psy,\n\t\t\t\t enum power_supply_property psp,\n\t\t\t\t union power_supply_propval *val)\n{\n\tstruct tps6598x *tps = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tif (TPS_POWER_STATUS_PWROPMODE(tps->pwr_status) == TYPEC_PWR_MODE_PD)\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_PD;\n\t\telse\n\t\t\tval->intval = POWER_SUPPLY_USB_TYPE_C;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = tps6598x_psy_get_online(tps, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int cd321x_switch_power_state(struct tps6598x *tps, u8 target_state)\n{\n\tu8 state;\n\tint ret;\n\n\tret = tps6598x_read8(tps, TPS_REG_SYSTEM_POWER_STATE, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state == target_state)\n\t\treturn 0;\n\n\tret = tps6598x_exec_cmd(tps, \"SSPS\", sizeof(u8), &target_state, 0, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6598x_read8(tps, TPS_REG_SYSTEM_POWER_STATE, &state);\n\tif (ret)\n\t\treturn ret;\n\n\tif (state != target_state)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int devm_tps6598_psy_register(struct tps6598x *tps)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tconst char *port_dev_name = dev_name(tps->dev);\n\tchar *psy_name;\n\n\tpsy_cfg.drv_data = tps;\n\tpsy_cfg.fwnode = dev_fwnode(tps->dev);\n\n\tpsy_name = devm_kasprintf(tps->dev, GFP_KERNEL, \"%s%s\", tps6598x_psy_name_prefix,\n\t\t\t\t  port_dev_name);\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\ttps->psy_desc.name = psy_name;\n\ttps->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\ttps->psy_desc.usb_types = tps6598x_psy_usb_types;\n\ttps->psy_desc.num_usb_types = ARRAY_SIZE(tps6598x_psy_usb_types);\n\ttps->psy_desc.properties = tps6598x_psy_props;\n\ttps->psy_desc.num_properties = ARRAY_SIZE(tps6598x_psy_props);\n\ttps->psy_desc.get_property = tps6598x_psy_get_prop;\n\n\ttps->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\n\ttps->psy = devm_power_supply_register(tps->dev, &tps->psy_desc,\n\t\t\t\t\t       &psy_cfg);\n\treturn PTR_ERR_OR_ZERO(tps->psy);\n}\n\nstatic int tps6598x_probe(struct i2c_client *client)\n{\n\tirq_handler_t irq_handler = tps6598x_interrupt;\n\tstruct device_node *np = client->dev.of_node;\n\tstruct typec_capability typec_cap = { };\n\tstruct tps6598x *tps;\n\tstruct fwnode_handle *fwnode;\n\tu32 status;\n\tu32 conf;\n\tu32 vid;\n\tint ret;\n\tu64 mask1;\n\n\ttps = devm_kzalloc(&client->dev, sizeof(*tps), GFP_KERNEL);\n\tif (!tps)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tps->lock);\n\ttps->dev = &client->dev;\n\n\ttps->regmap = devm_regmap_init_i2c(client, &tps6598x_regmap_config);\n\tif (IS_ERR(tps->regmap))\n\t\treturn PTR_ERR(tps->regmap);\n\n\tret = tps6598x_read32(tps, TPS_REG_VID, &vid);\n\tif (ret < 0 || !vid)\n\t\treturn -ENODEV;\n\n\t \n\tif (i2c_check_functionality(client->adapter, I2C_FUNC_I2C))\n\t\ttps->i2c_protocol = true;\n\n\tif (np && of_device_is_compatible(np, \"apple,cd321x\")) {\n\t\t \n\t\tret = cd321x_switch_power_state(tps, TPS_SYSTEM_POWER_STATE_S0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tmask1 = APPLE_CD_REG_INT_POWER_STATUS_UPDATE |\n\t\t\tAPPLE_CD_REG_INT_DATA_STATUS_UPDATE |\n\t\t\tAPPLE_CD_REG_INT_PLUG_EVENT;\n\n\t\tirq_handler = cd321x_interrupt;\n\t} else {\n\t\t \n\t\tmask1 = TPS_REG_INT_POWER_STATUS_UPDATE |\n\t\t\tTPS_REG_INT_DATA_STATUS_UPDATE |\n\t\t\tTPS_REG_INT_PLUG_EVENT;\n\t}\n\n\ttps->irq_handler = irq_handler;\n\t \n\tret = tps6598x_check_mode(tps);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6598x_write64(tps, TPS_REG_INT_MASK1, mask1);\n\tif (ret)\n\t\treturn ret;\n\n\tret = tps6598x_read32(tps, TPS_REG_STATUS, &status);\n\tif (ret < 0)\n\t\tgoto err_clear_mask;\n\ttrace_tps6598x_status(status);\n\n\tret = tps6598x_read32(tps, TPS_REG_SYSTEM_CONF, &conf);\n\tif (ret < 0)\n\t\tgoto err_clear_mask;\n\n\t \n\tfwnode = device_get_named_child_node(&client->dev, \"connector\");\n\tif (fwnode)\n\t\tfw_devlink_purge_absent_suppliers(fwnode);\n\n\ttps->role_sw = fwnode_usb_role_switch_get(fwnode);\n\tif (IS_ERR(tps->role_sw)) {\n\t\tret = PTR_ERR(tps->role_sw);\n\t\tgoto err_fwnode_put;\n\t}\n\n\ttypec_cap.revision = USB_TYPEC_REV_1_2;\n\ttypec_cap.pd_revision = 0x200;\n\ttypec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;\n\ttypec_cap.driver_data = tps;\n\ttypec_cap.ops = &tps6598x_ops;\n\ttypec_cap.fwnode = fwnode;\n\n\tswitch (TPS_SYSCONF_PORTINFO(conf)) {\n\tcase TPS_PORTINFO_SINK_ACCESSORY:\n\tcase TPS_PORTINFO_SINK:\n\t\ttypec_cap.type = TYPEC_PORT_SNK;\n\t\ttypec_cap.data = TYPEC_PORT_UFP;\n\t\tbreak;\n\tcase TPS_PORTINFO_DRP_UFP_DRD:\n\tcase TPS_PORTINFO_DRP_DFP_DRD:\n\t\ttypec_cap.type = TYPEC_PORT_DRP;\n\t\ttypec_cap.data = TYPEC_PORT_DRD;\n\t\tbreak;\n\tcase TPS_PORTINFO_DRP_UFP:\n\t\ttypec_cap.type = TYPEC_PORT_DRP;\n\t\ttypec_cap.data = TYPEC_PORT_UFP;\n\t\tbreak;\n\tcase TPS_PORTINFO_DRP_DFP:\n\t\ttypec_cap.type = TYPEC_PORT_DRP;\n\t\ttypec_cap.data = TYPEC_PORT_DFP;\n\t\tbreak;\n\tcase TPS_PORTINFO_SOURCE:\n\t\ttypec_cap.type = TYPEC_PORT_SRC;\n\t\ttypec_cap.data = TYPEC_PORT_DFP;\n\t\tbreak;\n\tdefault:\n\t\tret = -ENODEV;\n\t\tgoto err_role_put;\n\t}\n\n\tret = devm_tps6598_psy_register(tps);\n\tif (ret)\n\t\tgoto err_role_put;\n\n\ttps->port = typec_register_port(&client->dev, &typec_cap);\n\tif (IS_ERR(tps->port)) {\n\t\tret = PTR_ERR(tps->port);\n\t\tgoto err_role_put;\n\t}\n\n\tif (status & TPS_STATUS_PLUG_PRESENT) {\n\t\tret = tps6598x_read16(tps, TPS_REG_POWER_STATUS, &tps->pwr_status);\n\t\tif (ret < 0) {\n\t\t\tdev_err(tps->dev, \"failed to read power status: %d\\n\", ret);\n\t\t\tgoto err_unregister_port;\n\t\t}\n\t\tret = tps6598x_connect(tps, status);\n\t\tif (ret)\n\t\t\tdev_err(&client->dev, \"failed to register partner\\n\");\n\t}\n\n\tif (client->irq) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t\tirq_handler,\n\t\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT,\n\t\t\t\t\t\tdev_name(&client->dev), tps);\n\t} else {\n\t\tdev_warn(tps->dev, \"Unable to find the interrupt, switching to polling\\n\");\n\t\tINIT_DELAYED_WORK(&tps->wq_poll, tps6598x_poll_work);\n\t\tqueue_delayed_work(system_power_efficient_wq, &tps->wq_poll,\n\t\t\t\t   msecs_to_jiffies(POLL_INTERVAL));\n\t}\n\n\tif (ret)\n\t\tgoto err_disconnect;\n\n\ti2c_set_clientdata(client, tps);\n\tfwnode_handle_put(fwnode);\n\n\ttps->wakeup = device_property_read_bool(tps->dev, \"wakeup-source\");\n\tif (tps->wakeup && client->irq) {\n\t\tdevice_init_wakeup(&client->dev, true);\n\t\tenable_irq_wake(client->irq);\n\t}\n\n\treturn 0;\n\nerr_disconnect:\n\ttps6598x_disconnect(tps, 0);\nerr_unregister_port:\n\ttypec_unregister_port(tps->port);\nerr_role_put:\n\tusb_role_switch_put(tps->role_sw);\nerr_fwnode_put:\n\tfwnode_handle_put(fwnode);\nerr_clear_mask:\n\ttps6598x_write64(tps, TPS_REG_INT_MASK1, 0);\n\treturn ret;\n}\n\nstatic void tps6598x_remove(struct i2c_client *client)\n{\n\tstruct tps6598x *tps = i2c_get_clientdata(client);\n\n\tif (!client->irq)\n\t\tcancel_delayed_work_sync(&tps->wq_poll);\n\n\ttps6598x_disconnect(tps, 0);\n\ttypec_unregister_port(tps->port);\n\tusb_role_switch_put(tps->role_sw);\n}\n\nstatic int __maybe_unused tps6598x_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tps6598x *tps = i2c_get_clientdata(client);\n\n\tif (tps->wakeup) {\n\t\tdisable_irq(client->irq);\n\t\tenable_irq_wake(client->irq);\n\t}\n\n\tif (!client->irq)\n\t\tcancel_delayed_work_sync(&tps->wq_poll);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused tps6598x_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct tps6598x *tps = i2c_get_clientdata(client);\n\n\tif (tps->wakeup) {\n\t\tdisable_irq_wake(client->irq);\n\t\tenable_irq(client->irq);\n\t}\n\n\tif (!client->irq)\n\t\tqueue_delayed_work(system_power_efficient_wq, &tps->wq_poll,\n\t\t\t\t   msecs_to_jiffies(POLL_INTERVAL));\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops tps6598x_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(tps6598x_suspend, tps6598x_resume)\n};\n\nstatic const struct of_device_id tps6598x_of_match[] = {\n\t{ .compatible = \"ti,tps6598x\", },\n\t{ .compatible = \"apple,cd321x\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, tps6598x_of_match);\n\nstatic const struct i2c_device_id tps6598x_id[] = {\n\t{ \"tps6598x\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tps6598x_id);\n\nstatic struct i2c_driver tps6598x_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tps6598x\",\n\t\t.pm = &tps6598x_pm_ops,\n\t\t.of_match_table = tps6598x_of_match,\n\t},\n\t.probe = tps6598x_probe,\n\t.remove = tps6598x_remove,\n\t.id_table = tps6598x_id,\n};\nmodule_i2c_driver(tps6598x_i2c_driver);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"TI TPS6598x USB Power Delivery Controller Driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}