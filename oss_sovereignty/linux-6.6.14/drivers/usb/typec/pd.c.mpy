{
  "module_name": "pd.c",
  "hash_id": "cf8e95af4b8955feb805e40c3ebc98f88a133cf07538ebdd07abf26115980ada",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/pd.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/usb/pd.h>\n\n#include \"pd.h\"\n\nstatic DEFINE_IDA(pd_ida);\n\nstatic struct class pd_class = {\n\t.name = \"usb_power_delivery\",\n};\n\n#define to_pdo(o) container_of(o, struct pdo, dev)\n\nstruct pdo {\n\tstruct device dev;\n\tint object_position;\n\tu32 pdo;\n};\n\nstatic void pdo_release(struct device *dev)\n{\n\tkfree(to_pdo(dev));\n}\n\n \n \n\nstatic ssize_t\ndual_role_power_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_DUAL_ROLE));\n}\nstatic DEVICE_ATTR_RO(dual_role_power);\n\nstatic ssize_t\nusb_suspend_supported_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_SUSPEND));\n}\nstatic DEVICE_ATTR_RO(usb_suspend_supported);\n\nstatic ssize_t\nhigher_capability_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_HIGHER_CAP));\n}\nstatic DEVICE_ATTR_RO(higher_capability);\n\nstatic ssize_t\nunconstrained_power_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_EXTPOWER));\n}\nstatic DEVICE_ATTR_RO(unconstrained_power);\n\nstatic ssize_t\nusb_communication_capable_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_USB_COMM));\n}\nstatic DEVICE_ATTR_RO(usb_communication_capable);\n\nstatic ssize_t\ndual_role_data_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_DATA_SWAP));\n}\nstatic DEVICE_ATTR_RO(dual_role_data);\n\nstatic ssize_t\nunchunked_extended_messages_supported_show(struct device *dev,\n\t\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & PDO_FIXED_UNCHUNK_EXT));\n}\nstatic DEVICE_ATTR_RO(unchunked_extended_messages_supported);\n\n \n\nstatic ssize_t\nfast_role_swap_current_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", (to_pdo(dev)->pdo >> PDO_FIXED_FRS_CURR_SHIFT) & 3);\n}\nstatic DEVICE_ATTR_RO(fast_role_swap_current);\n\nstatic ssize_t voltage_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umV\\n\", pdo_fixed_voltage(to_pdo(dev)->pdo));\n}\nstatic DEVICE_ATTR_RO(voltage);\n\n \nstatic ssize_t current_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umA\\n\", pdo_max_current(to_pdo(dev)->pdo));\n}\n\n \nstatic struct device_attribute maximum_current_attr = {\n\t.attr = {\n\t\t.name = \"maximum_current\",\n\t\t.mode = 0444,\n\t},\n\t.show = current_show,\n};\n\nstatic struct device_attribute operational_current_attr = {\n\t.attr = {\n\t\t.name = \"operational_current\",\n\t\t.mode = 0444,\n\t},\n\t.show = current_show,\n};\n\nstatic struct attribute *source_fixed_supply_attrs[] = {\n\t&dev_attr_dual_role_power.attr,\n\t&dev_attr_usb_suspend_supported.attr,\n\t&dev_attr_unconstrained_power.attr,\n\t&dev_attr_usb_communication_capable.attr,\n\t&dev_attr_dual_role_data.attr,\n\t&dev_attr_unchunked_extended_messages_supported.attr,\n\t \n\t&dev_attr_voltage.attr,\n\t&maximum_current_attr.attr,\n\tNULL\n};\n\nstatic umode_t fixed_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tif (to_pdo(kobj_to_dev(kobj))->object_position &&\n\t     \n\t    attr != &dev_attr_voltage.attr &&\n\t    attr != &maximum_current_attr.attr &&\n\t    attr != &operational_current_attr.attr)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group source_fixed_supply_group = {\n\t.is_visible = fixed_attr_is_visible,\n\t.attrs = source_fixed_supply_attrs,\n};\n__ATTRIBUTE_GROUPS(source_fixed_supply);\n\nstatic struct device_type source_fixed_supply_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = source_fixed_supply_groups,\n};\n\nstatic struct attribute *sink_fixed_supply_attrs[] = {\n\t&dev_attr_dual_role_power.attr,\n\t&dev_attr_higher_capability.attr,\n\t&dev_attr_unconstrained_power.attr,\n\t&dev_attr_usb_communication_capable.attr,\n\t&dev_attr_dual_role_data.attr,\n\t&dev_attr_unchunked_extended_messages_supported.attr,\n\t&dev_attr_fast_role_swap_current.attr,\n\t&dev_attr_voltage.attr,\n\t&operational_current_attr.attr,\n\tNULL\n};\n\nstatic const struct attribute_group sink_fixed_supply_group = {\n\t.is_visible = fixed_attr_is_visible,\n\t.attrs = sink_fixed_supply_attrs,\n};\n__ATTRIBUTE_GROUPS(sink_fixed_supply);\n\nstatic struct device_type sink_fixed_supply_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = sink_fixed_supply_groups,\n};\n\n \n \n\nstatic ssize_t\nmaximum_voltage_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umV\\n\", pdo_max_voltage(to_pdo(dev)->pdo));\n}\nstatic DEVICE_ATTR_RO(maximum_voltage);\n\nstatic ssize_t\nminimum_voltage_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umV\\n\", pdo_min_voltage(to_pdo(dev)->pdo));\n}\nstatic DEVICE_ATTR_RO(minimum_voltage);\n\nstatic struct attribute *source_variable_supply_attrs[] = {\n\t&dev_attr_maximum_voltage.attr,\n\t&dev_attr_minimum_voltage.attr,\n\t&maximum_current_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(source_variable_supply);\n\nstatic struct device_type source_variable_supply_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = source_variable_supply_groups,\n};\n\nstatic struct attribute *sink_variable_supply_attrs[] = {\n\t&dev_attr_maximum_voltage.attr,\n\t&dev_attr_minimum_voltage.attr,\n\t&operational_current_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(sink_variable_supply);\n\nstatic struct device_type sink_variable_supply_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = sink_variable_supply_groups,\n};\n\n \n \n\nstatic ssize_t\nmaximum_power_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umW\\n\", pdo_max_power(to_pdo(dev)->pdo));\n}\nstatic DEVICE_ATTR_RO(maximum_power);\n\nstatic ssize_t\noperational_power_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umW\\n\", pdo_max_power(to_pdo(dev)->pdo));\n}\nstatic DEVICE_ATTR_RO(operational_power);\n\nstatic struct attribute *source_battery_attrs[] = {\n\t&dev_attr_maximum_voltage.attr,\n\t&dev_attr_minimum_voltage.attr,\n\t&dev_attr_maximum_power.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(source_battery);\n\nstatic struct device_type source_battery_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = source_battery_groups,\n};\n\nstatic struct attribute *sink_battery_attrs[] = {\n\t&dev_attr_maximum_voltage.attr,\n\t&dev_attr_minimum_voltage.attr,\n\t&dev_attr_operational_power.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(sink_battery);\n\nstatic struct device_type sink_battery_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = sink_battery_groups,\n};\n\n \n \n\nstatic ssize_t\npps_power_limited_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%u\\n\", !!(to_pdo(dev)->pdo & BIT(27)));\n}\nstatic DEVICE_ATTR_RO(pps_power_limited);\n\nstatic ssize_t\npps_max_voltage_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umV\\n\", pdo_pps_apdo_max_voltage(to_pdo(dev)->pdo));\n}\n\nstatic ssize_t\npps_min_voltage_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umV\\n\", pdo_pps_apdo_min_voltage(to_pdo(dev)->pdo));\n}\n\nstatic ssize_t\npps_max_current_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, \"%umA\\n\", pdo_pps_apdo_max_current(to_pdo(dev)->pdo));\n}\n\nstatic struct device_attribute pps_max_voltage_attr = {\n\t.attr = {\n\t\t.name = \"maximum_voltage\",\n\t\t.mode = 0444,\n\t},\n\t.show = pps_max_voltage_show,\n};\n\nstatic struct device_attribute pps_min_voltage_attr = {\n\t.attr = {\n\t\t.name = \"minimum_voltage\",\n\t\t.mode = 0444,\n\t},\n\t.show = pps_min_voltage_show,\n};\n\nstatic struct device_attribute pps_max_current_attr = {\n\t.attr = {\n\t\t.name = \"maximum_current\",\n\t\t.mode = 0444,\n\t},\n\t.show = pps_max_current_show,\n};\n\nstatic struct attribute *source_pps_attrs[] = {\n\t&dev_attr_pps_power_limited.attr,\n\t&pps_max_voltage_attr.attr,\n\t&pps_min_voltage_attr.attr,\n\t&pps_max_current_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(source_pps);\n\nstatic struct device_type source_pps_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = source_pps_groups,\n};\n\nstatic struct attribute *sink_pps_attrs[] = {\n\t&pps_max_voltage_attr.attr,\n\t&pps_min_voltage_attr.attr,\n\t&pps_max_current_attr.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(sink_pps);\n\nstatic struct device_type sink_pps_type = {\n\t.name = \"pdo\",\n\t.release = pdo_release,\n\t.groups = sink_pps_groups,\n};\n\n \n\nstatic const char * const supply_name[] = {\n\t[PDO_TYPE_FIXED] = \"fixed_supply\",\n\t[PDO_TYPE_BATT]  = \"battery\",\n\t[PDO_TYPE_VAR]\t = \"variable_supply\",\n};\n\nstatic const char * const apdo_supply_name[] = {\n\t[APDO_TYPE_PPS]  = \"programmable_supply\",\n};\n\nstatic struct device_type *source_type[] = {\n\t[PDO_TYPE_FIXED] = &source_fixed_supply_type,\n\t[PDO_TYPE_BATT]  = &source_battery_type,\n\t[PDO_TYPE_VAR]   = &source_variable_supply_type,\n};\n\nstatic struct device_type *source_apdo_type[] = {\n\t[APDO_TYPE_PPS]  = &source_pps_type,\n};\n\nstatic struct device_type *sink_type[] = {\n\t[PDO_TYPE_FIXED] = &sink_fixed_supply_type,\n\t[PDO_TYPE_BATT]  = &sink_battery_type,\n\t[PDO_TYPE_VAR]   = &sink_variable_supply_type,\n};\n\nstatic struct device_type *sink_apdo_type[] = {\n\t[APDO_TYPE_PPS]  = &sink_pps_type,\n};\n\n \nstatic int add_pdo(struct usb_power_delivery_capabilities *cap, u32 pdo, int position)\n{\n\tstruct device_type *type;\n\tconst char *name;\n\tstruct pdo *p;\n\tint ret;\n\n\tp = kzalloc(sizeof(*p), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tp->pdo = pdo;\n\tp->object_position = position;\n\n\tif (pdo_type(pdo) == PDO_TYPE_APDO) {\n\t\t \n\t\tif (pdo_apdo_type(pdo) > APDO_TYPE_PPS) {\n\t\t\tdev_warn(&cap->dev, \"Unknown APDO type. PDO 0x%08x\\n\", pdo);\n\t\t\tkfree(p);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (is_source(cap->role))\n\t\t\ttype = source_apdo_type[pdo_apdo_type(pdo)];\n\t\telse\n\t\t\ttype = sink_apdo_type[pdo_apdo_type(pdo)];\n\n\t\tname = apdo_supply_name[pdo_apdo_type(pdo)];\n\t} else {\n\t\tif (is_source(cap->role))\n\t\t\ttype = source_type[pdo_type(pdo)];\n\t\telse\n\t\t\ttype = sink_type[pdo_type(pdo)];\n\n\t\tname = supply_name[pdo_type(pdo)];\n\t}\n\n\tp->dev.parent = &cap->dev;\n\tp->dev.type = type;\n\tdev_set_name(&p->dev, \"%u:%s\", position + 1, name);\n\n\tret = device_register(&p->dev);\n\tif (ret) {\n\t\tput_device(&p->dev);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int remove_pdo(struct device *dev, void *data)\n{\n\tdevice_unregister(dev);\n\treturn 0;\n}\n\n \n\nstatic const char * const cap_name[] = {\n\t[TYPEC_SINK]    = \"sink-capabilities\",\n\t[TYPEC_SOURCE]  = \"source-capabilities\",\n};\n\nstatic void pd_capabilities_release(struct device *dev)\n{\n\tkfree(to_usb_power_delivery_capabilities(dev));\n}\n\nstatic struct device_type pd_capabilities_type = {\n\t.name = \"capabilities\",\n\t.release = pd_capabilities_release,\n};\n\n \nstruct usb_power_delivery_capabilities *\nusb_power_delivery_register_capabilities(struct usb_power_delivery *pd,\n\t\t\t\t\t struct usb_power_delivery_capabilities_desc *desc)\n{\n\tstruct usb_power_delivery_capabilities *cap;\n\tint ret;\n\tint i;\n\n\tcap = kzalloc(sizeof(*cap), GFP_KERNEL);\n\tif (!cap)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcap->pd = pd;\n\tcap->role = desc->role;\n\n\tcap->dev.parent = &pd->dev;\n\tcap->dev.type = &pd_capabilities_type;\n\tdev_set_name(&cap->dev, \"%s\", cap_name[cap->role]);\n\n\tret = device_register(&cap->dev);\n\tif (ret) {\n\t\tput_device(&cap->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tfor (i = 0; i < PDO_MAX_OBJECTS && desc->pdo[i]; i++) {\n\t\tret = add_pdo(cap, desc->pdo[i], i);\n\t\tif (ret) {\n\t\t\tusb_power_delivery_unregister_capabilities(cap);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn cap;\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_register_capabilities);\n\n \nvoid usb_power_delivery_unregister_capabilities(struct usb_power_delivery_capabilities *cap)\n{\n\tif (!cap)\n\t\treturn;\n\n\tdevice_for_each_child(&cap->dev, NULL, remove_pdo);\n\tdevice_unregister(&cap->dev);\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_unregister_capabilities);\n\n \n\nstatic ssize_t revision_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_power_delivery *pd = to_usb_power_delivery(dev);\n\n\treturn sysfs_emit(buf, \"%u.%u\\n\", (pd->revision >> 8) & 0xff, (pd->revision >> 4) & 0xf);\n}\nstatic DEVICE_ATTR_RO(revision);\n\nstatic ssize_t version_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_power_delivery *pd = to_usb_power_delivery(dev);\n\n\treturn sysfs_emit(buf, \"%u.%u\\n\", (pd->version >> 8) & 0xff, (pd->version >> 4) & 0xf);\n}\nstatic DEVICE_ATTR_RO(version);\n\nstatic struct attribute *pd_attrs[] = {\n\t&dev_attr_revision.attr,\n\t&dev_attr_version.attr,\n\tNULL\n};\n\nstatic umode_t pd_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct usb_power_delivery *pd = to_usb_power_delivery(kobj_to_dev(kobj));\n\n\tif (attr == &dev_attr_version.attr && !pd->version)\n\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group pd_group = {\n\t.is_visible = pd_attr_is_visible,\n\t.attrs = pd_attrs,\n};\n__ATTRIBUTE_GROUPS(pd);\n\nstatic void pd_release(struct device *dev)\n{\n\tstruct usb_power_delivery *pd = to_usb_power_delivery(dev);\n\n\tida_simple_remove(&pd_ida, pd->id);\n\tkfree(pd);\n}\n\nstatic struct device_type pd_type = {\n\t.name = \"usb_power_delivery\",\n\t.release = pd_release,\n\t.groups = pd_groups,\n};\n\nstruct usb_power_delivery *usb_power_delivery_find(const char *name)\n{\n\tstruct device *dev;\n\n\tdev = class_find_device_by_name(&pd_class, name);\n\n\treturn dev ? to_usb_power_delivery(dev) : NULL;\n}\n\n \nstruct usb_power_delivery *\nusb_power_delivery_register(struct device *parent, struct usb_power_delivery_desc *desc)\n{\n\tstruct usb_power_delivery *pd;\n\tint ret;\n\n\tpd = kzalloc(sizeof(*pd), GFP_KERNEL);\n\tif (!pd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = ida_simple_get(&pd_ida, 0, 0, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tkfree(pd);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tpd->id = ret;\n\tpd->revision = desc->revision;\n\tpd->version = desc->version;\n\n\tpd->dev.parent = parent;\n\tpd->dev.type = &pd_type;\n\tpd->dev.class = &pd_class;\n\tdev_set_name(&pd->dev, \"pd%d\", pd->id);\n\n\tret = device_register(&pd->dev);\n\tif (ret) {\n\t\tput_device(&pd->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn pd;\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_register);\n\n \nvoid usb_power_delivery_unregister(struct usb_power_delivery *pd)\n{\n\tif (IS_ERR_OR_NULL(pd))\n\t\treturn;\n\n\tdevice_unregister(&pd->dev);\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_unregister);\n\n \nint usb_power_delivery_link_device(struct usb_power_delivery *pd, struct device *dev)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(pd) || !dev)\n\t\treturn 0;\n\n\tret = sysfs_create_link(&dev->kobj, &pd->dev.kobj, \"usb_power_delivery\");\n\tif (ret)\n\t\treturn ret;\n\n\tget_device(&pd->dev);\n\tget_device(dev);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_link_device);\n\n \nvoid usb_power_delivery_unlink_device(struct usb_power_delivery *pd, struct device *dev)\n{\n\tif (IS_ERR_OR_NULL(pd) || !dev)\n\t\treturn;\n\n\tsysfs_remove_link(&dev->kobj, \"usb_power_delivery\");\n\tput_device(&pd->dev);\n\tput_device(dev);\n}\nEXPORT_SYMBOL_GPL(usb_power_delivery_unlink_device);\n\n \n\nint __init usb_power_delivery_init(void)\n{\n\treturn class_register(&pd_class);\n}\n\nvoid __exit usb_power_delivery_exit(void)\n{\n\tida_destroy(&pd_ida);\n\tclass_unregister(&pd_class);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}