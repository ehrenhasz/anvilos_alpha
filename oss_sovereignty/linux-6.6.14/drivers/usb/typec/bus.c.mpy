{
  "module_name": "bus.c",
  "hash_id": "74ca9bc33f71c5c7177fc109c9c46194c5870c2c7f8deb86b91c659208dfe560",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/bus.c",
  "human_readable_source": "\n \n\n#include <linux/usb/pd_vdo.h>\n\n#include \"bus.h\"\n#include \"class.h\"\n#include \"mux.h\"\n#include \"retimer.h\"\n\nstatic inline int\ntypec_altmode_set_retimer(struct altmode *alt, unsigned long conf, void *data)\n{\n\tstruct typec_retimer_state state;\n\n\tif (!alt->retimer)\n\t\treturn 0;\n\n\tstate.alt = &alt->adev;\n\tstate.mode = conf;\n\tstate.data = data;\n\n\treturn typec_retimer_set(alt->retimer, &state);\n}\n\nstatic inline int\ntypec_altmode_set_mux(struct altmode *alt, unsigned long conf, void *data)\n{\n\tstruct typec_mux_state state;\n\n\tif (!alt->mux)\n\t\treturn 0;\n\n\tstate.alt = &alt->adev;\n\tstate.mode = conf;\n\tstate.data = data;\n\n\treturn typec_mux_set(alt->mux, &state);\n}\n\n \nstatic inline int\ntypec_altmode_set_switches(struct altmode *alt, unsigned long conf, void *data)\n{\n\tint ret;\n\n\tret = typec_altmode_set_retimer(alt, conf, data);\n\tif (ret)\n\t\treturn ret;\n\n\treturn typec_altmode_set_mux(alt, conf, data);\n}\n\nstatic int typec_altmode_set_state(struct typec_altmode *adev,\n\t\t\t\t   unsigned long conf, void *data)\n{\n\tbool is_port = is_typec_port(adev->dev.parent);\n\tstruct altmode *port_altmode;\n\n\tport_altmode = is_port ? to_altmode(adev) : to_altmode(adev)->partner;\n\n\treturn typec_altmode_set_switches(port_altmode, conf, data);\n}\n\n \n \n\n \nint typec_altmode_notify(struct typec_altmode *adev,\n\t\t\t unsigned long conf, void *data)\n{\n\tbool is_port;\n\tstruct altmode *altmode;\n\tstruct altmode *partner;\n\tint ret;\n\n\tif (!adev)\n\t\treturn 0;\n\n\taltmode = to_altmode(adev);\n\n\tif (!altmode->partner)\n\t\treturn -ENODEV;\n\n\tis_port = is_typec_port(adev->dev.parent);\n\tpartner = altmode->partner;\n\n\tret = typec_altmode_set_switches(is_port ? altmode : partner, conf, data);\n\tif (ret)\n\t\treturn ret;\n\n\tif (partner->adev.ops && partner->adev.ops->notify)\n\t\treturn partner->adev.ops->notify(&partner->adev, conf, data);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_altmode_notify);\n\n \nint typec_altmode_enter(struct typec_altmode *adev, u32 *vdo)\n{\n\tstruct altmode *partner = to_altmode(adev)->partner;\n\tstruct typec_altmode *pdev = &partner->adev;\n\tint ret;\n\n\tif (!adev || adev->active)\n\t\treturn 0;\n\n\tif (!pdev->ops || !pdev->ops->enter)\n\t\treturn -EOPNOTSUPP;\n\n\tif (is_typec_port(pdev->dev.parent) && !pdev->active)\n\t\treturn -EPERM;\n\n\t \n\tret = typec_altmode_set_state(adev, TYPEC_STATE_SAFE, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn pdev->ops->enter(pdev, vdo);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_enter);\n\n \nint typec_altmode_exit(struct typec_altmode *adev)\n{\n\tstruct altmode *partner = to_altmode(adev)->partner;\n\tstruct typec_altmode *pdev = &partner->adev;\n\tint ret;\n\n\tif (!adev || !adev->active)\n\t\treturn 0;\n\n\tif (!pdev->ops || !pdev->ops->exit)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tret = typec_altmode_set_state(adev, TYPEC_STATE_SAFE, NULL);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\treturn pdev->ops->exit(pdev);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_exit);\n\n \nint typec_altmode_attention(struct typec_altmode *adev, u32 vdo)\n{\n\tstruct altmode *partner = to_altmode(adev)->partner;\n\tstruct typec_altmode *pdev;\n\n\tif (!partner)\n\t\treturn -ENODEV;\n\n\tpdev = &partner->adev;\n\n\tif (pdev->ops && pdev->ops->attention)\n\t\tpdev->ops->attention(pdev, vdo);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_altmode_attention);\n\n \nint typec_altmode_vdm(struct typec_altmode *adev,\n\t\t      const u32 header, const u32 *vdo, int count)\n{\n\tstruct typec_altmode *pdev;\n\tstruct altmode *altmode;\n\n\tif (!adev)\n\t\treturn 0;\n\n\taltmode = to_altmode(adev);\n\n\tif (!altmode->partner)\n\t\treturn -ENODEV;\n\n\tpdev = &altmode->partner->adev;\n\n\tif (!pdev->ops || !pdev->ops->vdm)\n\t\treturn -EOPNOTSUPP;\n\n\treturn pdev->ops->vdm(pdev, header, vdo, count);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_vdm);\n\nconst struct typec_altmode *\ntypec_altmode_get_partner(struct typec_altmode *adev)\n{\n\tif (!adev || !to_altmode(adev)->partner)\n\t\treturn NULL;\n\n\treturn &to_altmode(adev)->partner->adev;\n}\nEXPORT_SYMBOL_GPL(typec_altmode_get_partner);\n\n \n \n\n \nstruct typec_altmode *typec_altmode_get_plug(struct typec_altmode *adev,\n\t\t\t\t\t     enum typec_plug_index index)\n{\n\tstruct altmode *port = to_altmode(adev)->partner;\n\n\tif (port->plug[index]) {\n\t\tget_device(&port->plug[index]->adev.dev);\n\t\treturn &port->plug[index]->adev;\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(typec_altmode_get_plug);\n\n \nvoid typec_altmode_put_plug(struct typec_altmode *plug)\n{\n\tif (plug)\n\t\tput_device(&plug->dev);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_put_plug);\n\nint __typec_altmode_register_driver(struct typec_altmode_driver *drv,\n\t\t\t\t    struct module *module)\n{\n\tif (!drv->probe)\n\t\treturn -EINVAL;\n\n\tdrv->driver.owner = module;\n\tdrv->driver.bus = &typec_bus;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__typec_altmode_register_driver);\n\nvoid typec_altmode_unregister_driver(struct typec_altmode_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_unregister_driver);\n\n \n \n\n \nstruct typec_altmode *typec_match_altmode(struct typec_altmode **altmodes,\n\t\t\t\t\t  size_t n, u16 svid, u8 mode)\n{\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (!altmodes[i])\n\t\t\tbreak;\n\t\tif (altmodes[i]->svid == svid && altmodes[i]->mode == mode)\n\t\t\treturn altmodes[i];\n\t}\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(typec_match_altmode);\n\n \n\nstatic ssize_t\ndescription_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *alt = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"%s\\n\", alt->desc ? alt->desc : \"\");\n}\nstatic DEVICE_ATTR_RO(description);\n\nstatic struct attribute *typec_attrs[] = {\n\t&dev_attr_description.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(typec);\n\nstatic int typec_match(struct device *dev, struct device_driver *driver)\n{\n\tstruct typec_altmode_driver *drv = to_altmode_driver(driver);\n\tstruct typec_altmode *altmode = to_typec_altmode(dev);\n\tconst struct typec_device_id *id;\n\n\tfor (id = drv->id_table; id->svid; id++)\n\t\tif (id->svid == altmode->svid &&\n\t\t    (id->mode == TYPEC_ANY_MODE || id->mode == altmode->mode))\n\t\t\treturn 1;\n\treturn 0;\n}\n\nstatic int typec_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct typec_altmode *altmode = to_typec_altmode(dev);\n\n\tif (add_uevent_var(env, \"SVID=%04X\", altmode->svid))\n\t\treturn -ENOMEM;\n\n\tif (add_uevent_var(env, \"MODE=%u\", altmode->mode))\n\t\treturn -ENOMEM;\n\n\treturn add_uevent_var(env, \"MODALIAS=typec:id%04Xm%02X\",\n\t\t\t      altmode->svid, altmode->mode);\n}\n\nstatic int typec_altmode_create_links(struct altmode *alt)\n{\n\tstruct device *port_dev = &alt->partner->adev.dev;\n\tstruct device *dev = &alt->adev.dev;\n\tint err;\n\n\terr = sysfs_create_link(&dev->kobj, &port_dev->kobj, \"port\");\n\tif (err)\n\t\treturn err;\n\n\terr = sysfs_create_link(&port_dev->kobj, &dev->kobj, \"partner\");\n\tif (err)\n\t\tsysfs_remove_link(&dev->kobj, \"port\");\n\n\treturn err;\n}\n\nstatic void typec_altmode_remove_links(struct altmode *alt)\n{\n\tsysfs_remove_link(&alt->partner->adev.dev.kobj, \"partner\");\n\tsysfs_remove_link(&alt->adev.dev.kobj, \"port\");\n}\n\nstatic int typec_probe(struct device *dev)\n{\n\tstruct typec_altmode_driver *drv = to_altmode_driver(dev->driver);\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\tstruct altmode *altmode = to_altmode(adev);\n\tint ret;\n\n\t \n\tif (!altmode->partner)\n\t\treturn -ENODEV;\n\n\tret = typec_altmode_create_links(altmode);\n\tif (ret) {\n\t\tdev_warn(dev, \"failed to create symlinks\\n\");\n\t\treturn ret;\n\t}\n\n\tret = drv->probe(adev);\n\tif (ret)\n\t\ttypec_altmode_remove_links(altmode);\n\n\treturn ret;\n}\n\nstatic void typec_remove(struct device *dev)\n{\n\tstruct typec_altmode_driver *drv = to_altmode_driver(dev->driver);\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\tstruct altmode *altmode = to_altmode(adev);\n\n\ttypec_altmode_remove_links(altmode);\n\n\tif (drv->remove)\n\t\tdrv->remove(to_typec_altmode(dev));\n\n\tif (adev->active) {\n\t\tWARN_ON(typec_altmode_set_state(adev, TYPEC_STATE_SAFE, NULL));\n\t\ttypec_altmode_update_active(adev, false);\n\t}\n\n\tadev->desc = NULL;\n\tadev->ops = NULL;\n}\n\nconst struct bus_type typec_bus = {\n\t.name = \"typec\",\n\t.dev_groups = typec_groups,\n\t.match = typec_match,\n\t.uevent = typec_uevent,\n\t.probe = typec_probe,\n\t.remove = typec_remove,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}