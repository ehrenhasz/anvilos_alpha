{
  "module_name": "wusb3801.c",
  "hash_id": "94f2dc3b4b912e9807850f7832217529a3aa740de1ae7e4782bc9d133f5d2c75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/wusb3801.c",
  "human_readable_source": "\n \n\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/typec.h>\n\n#define WUSB3801_REG_DEVICE_ID\t\t0x01\n#define WUSB3801_REG_CTRL0\t\t0x02\n#define WUSB3801_REG_INT\t\t0x03\n#define WUSB3801_REG_STAT\t\t0x04\n#define WUSB3801_REG_CTRL1\t\t0x05\n#define WUSB3801_REG_TEST00\t\t0x06\n#define WUSB3801_REG_TEST01\t\t0x07\n#define WUSB3801_REG_TEST02\t\t0x08\n#define WUSB3801_REG_TEST03\t\t0x09\n#define WUSB3801_REG_TEST04\t\t0x0a\n#define WUSB3801_REG_TEST05\t\t0x0b\n#define WUSB3801_REG_TEST06\t\t0x0c\n#define WUSB3801_REG_TEST07\t\t0x0d\n#define WUSB3801_REG_TEST08\t\t0x0e\n#define WUSB3801_REG_TEST09\t\t0x0f\n#define WUSB3801_REG_TEST0A\t\t0x10\n#define WUSB3801_REG_TEST0B\t\t0x11\n#define WUSB3801_REG_TEST0C\t\t0x12\n#define WUSB3801_REG_TEST0D\t\t0x13\n#define WUSB3801_REG_TEST0E\t\t0x14\n#define WUSB3801_REG_TEST0F\t\t0x15\n#define WUSB3801_REG_TEST10\t\t0x16\n#define WUSB3801_REG_TEST11\t\t0x17\n#define WUSB3801_REG_TEST12\t\t0x18\n\n#define WUSB3801_DEVICE_ID_VERSION_ID\tGENMASK(7, 3)\n#define WUSB3801_DEVICE_ID_VENDOR_ID\tGENMASK(2, 0)\n\n#define WUSB3801_CTRL0_DIS_ACC_SUPPORT\tBIT(7)\n#define WUSB3801_CTRL0_TRY\t\tGENMASK(6, 5)\n#define WUSB3801_CTRL0_TRY_NONE\t\t(0x0 << 5)\n#define WUSB3801_CTRL0_TRY_SNK\t\t(0x1 << 5)\n#define WUSB3801_CTRL0_TRY_SRC\t\t(0x2 << 5)\n#define WUSB3801_CTRL0_CURRENT\t\tGENMASK(4, 3)  \n#define WUSB3801_CTRL0_CURRENT_DEFAULT\t(0x0 << 3)\n#define WUSB3801_CTRL0_CURRENT_1_5A\t(0x1 << 3)\n#define WUSB3801_CTRL0_CURRENT_3_0A\t(0x2 << 3)\n#define WUSB3801_CTRL0_ROLE\t\tGENMASK(2, 1)\n#define WUSB3801_CTRL0_ROLE_SNK\t\t(0x0 << 1)\n#define WUSB3801_CTRL0_ROLE_SRC\t\t(0x1 << 1)\n#define WUSB3801_CTRL0_ROLE_DRP\t\t(0x2 << 1)\n#define WUSB3801_CTRL0_INT_MASK\t\tBIT(0)\n\n#define WUSB3801_INT_ATTACHED\t\tBIT(0)\n#define WUSB3801_INT_DETACHED\t\tBIT(1)\n\n#define WUSB3801_STAT_VBUS_DETECTED\tBIT(7)\n#define WUSB3801_STAT_CURRENT\t\tGENMASK(6, 5)  \n#define WUSB3801_STAT_CURRENT_STANDBY\t(0x0 << 5)\n#define WUSB3801_STAT_CURRENT_DEFAULT\t(0x1 << 5)\n#define WUSB3801_STAT_CURRENT_1_5A\t(0x2 << 5)\n#define WUSB3801_STAT_CURRENT_3_0A\t(0x3 << 5)\n#define WUSB3801_STAT_PARTNER\t\tGENMASK(4, 2)\n#define WUSB3801_STAT_PARTNER_STANDBY\t(0x0 << 2)\n#define WUSB3801_STAT_PARTNER_SNK\t(0x1 << 2)\n#define WUSB3801_STAT_PARTNER_SRC\t(0x2 << 2)\n#define WUSB3801_STAT_PARTNER_AUDIO\t(0x3 << 2)\n#define WUSB3801_STAT_PARTNER_DEBUG\t(0x4 << 2)\n#define WUSB3801_STAT_ORIENTATION\tGENMASK(1, 0)\n#define WUSB3801_STAT_ORIENTATION_NONE\t(0x0 << 0)\n#define WUSB3801_STAT_ORIENTATION_CC1\t(0x1 << 0)\n#define WUSB3801_STAT_ORIENTATION_CC2\t(0x2 << 0)\n#define WUSB3801_STAT_ORIENTATION_BOTH\t(0x3 << 0)\n\n#define WUSB3801_CTRL1_SM_RESET\t\tBIT(0)\n\n#define WUSB3801_TEST01_VENDOR_SUB_ID\t(BIT(8) | BIT(6))\n\n#define WUSB3801_TEST02_FORCE_ERR_RCY\tBIT(8)\n\n#define WUSB3801_TEST0A_WAIT_VBUS\tBIT(5)\n\nstruct wusb3801 {\n\tstruct typec_capability\tcap;\n\tstruct device\t\t*dev;\n\tstruct typec_partner\t*partner;\n\tstruct typec_port\t*port;\n\tstruct regmap\t\t*regmap;\n\tstruct regulator\t*vbus_supply;\n\tunsigned int\t\tpartner_type;\n\tenum typec_port_type\tport_type;\n\tenum typec_pwr_opmode\tpwr_opmode;\n\tbool\t\t\tvbus_on;\n};\n\nstatic enum typec_role wusb3801_get_default_role(struct wusb3801 *wusb3801)\n{\n\tswitch (wusb3801->port_type) {\n\tcase TYPEC_PORT_SRC:\n\t\treturn TYPEC_SOURCE;\n\tcase TYPEC_PORT_SNK:\n\t\treturn TYPEC_SINK;\n\tcase TYPEC_PORT_DRP:\n\tdefault:\n\t\tif (wusb3801->cap.prefer_role == TYPEC_SOURCE)\n\t\t\treturn TYPEC_SOURCE;\n\t\treturn TYPEC_SINK;\n\t}\n}\n\nstatic int wusb3801_map_port_type(enum typec_port_type type)\n{\n\tswitch (type) {\n\tcase TYPEC_PORT_SRC:\n\t\treturn WUSB3801_CTRL0_ROLE_SRC;\n\tcase TYPEC_PORT_SNK:\n\t\treturn WUSB3801_CTRL0_ROLE_SNK;\n\tcase TYPEC_PORT_DRP:\n\tdefault:\n\t\treturn WUSB3801_CTRL0_ROLE_DRP;\n\t}\n}\n\nstatic int wusb3801_map_pwr_opmode(enum typec_pwr_opmode mode)\n{\n\tswitch (mode) {\n\tcase TYPEC_PWR_MODE_USB:\n\tdefault:\n\t\treturn WUSB3801_CTRL0_CURRENT_DEFAULT;\n\tcase TYPEC_PWR_MODE_1_5A:\n\t\treturn WUSB3801_CTRL0_CURRENT_1_5A;\n\tcase TYPEC_PWR_MODE_3_0A:\n\t\treturn WUSB3801_CTRL0_CURRENT_3_0A;\n\t}\n}\n\nstatic unsigned int wusb3801_map_try_role(int role)\n{\n\tswitch (role) {\n\tcase TYPEC_NO_PREFERRED_ROLE:\n\tdefault:\n\t\treturn WUSB3801_CTRL0_TRY_NONE;\n\tcase TYPEC_SINK:\n\t\treturn WUSB3801_CTRL0_TRY_SNK;\n\tcase TYPEC_SOURCE:\n\t\treturn WUSB3801_CTRL0_TRY_SRC;\n\t}\n}\n\nstatic enum typec_orientation wusb3801_unmap_orientation(unsigned int status)\n{\n\tswitch (status & WUSB3801_STAT_ORIENTATION) {\n\tcase WUSB3801_STAT_ORIENTATION_NONE:\n\tcase WUSB3801_STAT_ORIENTATION_BOTH:\n\tdefault:\n\t\treturn TYPEC_ORIENTATION_NONE;\n\tcase WUSB3801_STAT_ORIENTATION_CC1:\n\t\treturn TYPEC_ORIENTATION_NORMAL;\n\tcase WUSB3801_STAT_ORIENTATION_CC2:\n\t\treturn TYPEC_ORIENTATION_REVERSE;\n\t}\n}\n\nstatic enum typec_pwr_opmode wusb3801_unmap_pwr_opmode(unsigned int status)\n{\n\tswitch (status & WUSB3801_STAT_CURRENT) {\n\tcase WUSB3801_STAT_CURRENT_STANDBY:\n\tcase WUSB3801_STAT_CURRENT_DEFAULT:\n\tdefault:\n\t\treturn TYPEC_PWR_MODE_USB;\n\tcase WUSB3801_STAT_CURRENT_1_5A:\n\t\treturn TYPEC_PWR_MODE_1_5A;\n\tcase WUSB3801_STAT_CURRENT_3_0A:\n\t\treturn TYPEC_PWR_MODE_3_0A;\n\t}\n}\n\nstatic int wusb3801_try_role(struct typec_port *port, int role)\n{\n\tstruct wusb3801 *wusb3801 = typec_get_drvdata(port);\n\n\treturn regmap_update_bits(wusb3801->regmap, WUSB3801_REG_CTRL0,\n\t\t\t\t  WUSB3801_CTRL0_TRY,\n\t\t\t\t  wusb3801_map_try_role(role));\n}\n\nstatic int wusb3801_port_type_set(struct typec_port *port,\n\t\t\t\t  enum typec_port_type type)\n{\n\tstruct wusb3801 *wusb3801 = typec_get_drvdata(port);\n\tint ret;\n\n\tret = regmap_update_bits(wusb3801->regmap, WUSB3801_REG_CTRL0,\n\t\t\t\t WUSB3801_CTRL0_ROLE,\n\t\t\t\t wusb3801_map_port_type(type));\n\tif (ret)\n\t\treturn ret;\n\n\twusb3801->port_type = type;\n\n\treturn 0;\n}\n\nstatic const struct typec_operations wusb3801_typec_ops = {\n\t.try_role\t= wusb3801_try_role,\n\t.port_type_set\t= wusb3801_port_type_set,\n};\n\nstatic int wusb3801_hw_init(struct wusb3801 *wusb3801)\n{\n\treturn regmap_write(wusb3801->regmap, WUSB3801_REG_CTRL0,\n\t\t\t    wusb3801_map_try_role(wusb3801->cap.prefer_role) |\n\t\t\t    wusb3801_map_pwr_opmode(wusb3801->pwr_opmode) |\n\t\t\t    wusb3801_map_port_type(wusb3801->port_type));\n}\n\nstatic void wusb3801_hw_update(struct wusb3801 *wusb3801)\n{\n\tstruct typec_port *port = wusb3801->port;\n\tstruct device *dev = wusb3801->dev;\n\tunsigned int partner_type, status;\n\tint ret;\n\n\tret = regmap_read(wusb3801->regmap, WUSB3801_REG_STAT, &status);\n\tif (ret) {\n\t\tdev_warn(dev, \"Failed to read port status: %d\\n\", ret);\n\t\tstatus = 0;\n\t}\n\tdev_dbg(dev, \"status = 0x%02x\\n\", status);\n\n\tpartner_type = status & WUSB3801_STAT_PARTNER;\n\n\tif (partner_type == WUSB3801_STAT_PARTNER_SNK) {\n\t\tif (!wusb3801->vbus_on) {\n\t\t\tret = regulator_enable(wusb3801->vbus_supply);\n\t\t\tif (ret)\n\t\t\t\tdev_warn(dev, \"Failed to enable VBUS: %d\\n\", ret);\n\t\t\twusb3801->vbus_on = true;\n\t\t}\n\t} else {\n\t\tif (wusb3801->vbus_on) {\n\t\t\tregulator_disable(wusb3801->vbus_supply);\n\t\t\twusb3801->vbus_on = false;\n\t\t}\n\t}\n\n\tif (partner_type != wusb3801->partner_type) {\n\t\tstruct typec_partner_desc desc = {};\n\t\tenum typec_data_role data_role;\n\t\tenum typec_role pwr_role = wusb3801_get_default_role(wusb3801);\n\n\t\tswitch (partner_type) {\n\t\tcase WUSB3801_STAT_PARTNER_STANDBY:\n\t\t\tbreak;\n\t\tcase WUSB3801_STAT_PARTNER_SNK:\n\t\t\tpwr_role = TYPEC_SOURCE;\n\t\t\tbreak;\n\t\tcase WUSB3801_STAT_PARTNER_SRC:\n\t\t\tpwr_role = TYPEC_SINK;\n\t\t\tbreak;\n\t\tcase WUSB3801_STAT_PARTNER_AUDIO:\n\t\t\tdesc.accessory = TYPEC_ACCESSORY_AUDIO;\n\t\t\tbreak;\n\t\tcase WUSB3801_STAT_PARTNER_DEBUG:\n\t\t\tdesc.accessory = TYPEC_ACCESSORY_DEBUG;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wusb3801->partner) {\n\t\t\ttypec_unregister_partner(wusb3801->partner);\n\t\t\twusb3801->partner = NULL;\n\t\t}\n\n\t\tif (partner_type != WUSB3801_STAT_PARTNER_STANDBY) {\n\t\t\twusb3801->partner = typec_register_partner(port, &desc);\n\t\t\tif (IS_ERR(wusb3801->partner))\n\t\t\t\tdev_err(dev, \"Failed to register partner: %ld\\n\",\n\t\t\t\t\tPTR_ERR(wusb3801->partner));\n\t\t}\n\n\t\tdata_role = pwr_role == TYPEC_SOURCE ? TYPEC_HOST : TYPEC_DEVICE;\n\t\ttypec_set_data_role(port, data_role);\n\t\ttypec_set_pwr_role(port, pwr_role);\n\t\ttypec_set_vconn_role(port, pwr_role);\n\t}\n\n\ttypec_set_pwr_opmode(wusb3801->port,\n\t\t\t     partner_type == WUSB3801_STAT_PARTNER_SRC\n\t\t\t\t? wusb3801_unmap_pwr_opmode(status)\n\t\t\t\t: wusb3801->pwr_opmode);\n\ttypec_set_orientation(wusb3801->port,\n\t\t\t      wusb3801_unmap_orientation(status));\n\n\twusb3801->partner_type = partner_type;\n}\n\nstatic irqreturn_t wusb3801_irq(int irq, void *data)\n{\n\tstruct wusb3801 *wusb3801 = data;\n\tunsigned int dummy;\n\n\t \n\tregmap_read(wusb3801->regmap, WUSB3801_REG_INT, &dummy);\n\n\twusb3801_hw_update(wusb3801);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct regmap_config config = {\n\t.reg_bits\t= 8,\n\t.val_bits\t= 8,\n\t.max_register\t= WUSB3801_REG_TEST12,\n};\n\nstatic int wusb3801_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct fwnode_handle *connector;\n\tstruct wusb3801 *wusb3801;\n\tconst char *cap_str;\n\tint ret;\n\n\twusb3801 = devm_kzalloc(dev, sizeof(*wusb3801), GFP_KERNEL);\n\tif (!wusb3801)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, wusb3801);\n\n\twusb3801->dev = dev;\n\n\twusb3801->regmap = devm_regmap_init_i2c(client, &config);\n\tif (IS_ERR(wusb3801->regmap))\n\t\treturn PTR_ERR(wusb3801->regmap);\n\n\twusb3801->vbus_supply = devm_regulator_get(dev, \"vbus\");\n\tif (IS_ERR(wusb3801->vbus_supply))\n\t\treturn PTR_ERR(wusb3801->vbus_supply);\n\n\tconnector = device_get_named_child_node(dev, \"connector\");\n\tif (!connector)\n\t\treturn -ENODEV;\n\n\tret = typec_get_fw_cap(&wusb3801->cap, connector);\n\tif (ret)\n\t\tgoto err_put_connector;\n\twusb3801->port_type = wusb3801->cap.type;\n\n\tret = fwnode_property_read_string(connector, \"typec-power-opmode\", &cap_str);\n\tif (ret)\n\t\tgoto err_put_connector;\n\n\tret = typec_find_pwr_opmode(cap_str);\n\tif (ret < 0 || ret == TYPEC_PWR_MODE_PD)\n\t\tgoto err_put_connector;\n\twusb3801->pwr_opmode = ret;\n\n\t \n\tret = wusb3801_hw_init(wusb3801);\n\tif (ret)\n\t\tgoto err_put_connector;\n\n\twusb3801->cap.revision\t\t= USB_TYPEC_REV_1_2;\n\twusb3801->cap.accessory[0]\t= TYPEC_ACCESSORY_AUDIO;\n\twusb3801->cap.accessory[1]\t= TYPEC_ACCESSORY_DEBUG;\n\twusb3801->cap.orientation_aware\t= true;\n\twusb3801->cap.driver_data\t= wusb3801;\n\twusb3801->cap.ops\t\t= &wusb3801_typec_ops;\n\n\twusb3801->port = typec_register_port(dev, &wusb3801->cap);\n\tif (IS_ERR(wusb3801->port)) {\n\t\tret = PTR_ERR(wusb3801->port);\n\t\tgoto err_put_connector;\n\t}\n\n\t \n\twusb3801_hw_update(wusb3801);\n\n\tret = request_threaded_irq(client->irq, NULL, wusb3801_irq,\n\t\t\t\t   IRQF_ONESHOT, dev_name(dev), wusb3801);\n\tif (ret)\n\t\tgoto err_unregister_port;\n\n\tfwnode_handle_put(connector);\n\n\treturn 0;\n\nerr_unregister_port:\n\ttypec_unregister_port(wusb3801->port);\nerr_put_connector:\n\tfwnode_handle_put(connector);\n\n\treturn ret;\n}\n\nstatic void wusb3801_remove(struct i2c_client *client)\n{\n\tstruct wusb3801 *wusb3801 = i2c_get_clientdata(client);\n\n\tfree_irq(client->irq, wusb3801);\n\n\tif (wusb3801->partner)\n\t\ttypec_unregister_partner(wusb3801->partner);\n\ttypec_unregister_port(wusb3801->port);\n\n\tif (wusb3801->vbus_on)\n\t\tregulator_disable(wusb3801->vbus_supply);\n}\n\nstatic const struct of_device_id wusb3801_of_match[] = {\n\t{ .compatible = \"willsemi,wusb3801\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, wusb3801_of_match);\n\nstatic struct i2c_driver wusb3801_driver = {\n\t.probe\t\t= wusb3801_probe,\n\t.remove\t\t= wusb3801_remove,\n\t.driver\t\t= {\n\t\t.name\t\t= \"wusb3801\",\n\t\t.of_match_table\t= wusb3801_of_match,\n\t},\n};\n\nmodule_i2c_driver(wusb3801_driver);\n\nMODULE_AUTHOR(\"Samuel Holland <samuel@sholland.org>\");\nMODULE_DESCRIPTION(\"Willsemi WUSB3801 Type-C port controller driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}