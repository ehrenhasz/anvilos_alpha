{
  "module_name": "stusb160x.c",
  "hash_id": "3107360a0068618b53385eb2b419db6f5a8305922b76a58105420a4a7f16728e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/stusb160x.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/role.h>\n#include <linux/usb/typec.h>\n\n#define STUSB160X_ALERT_STATUS\t\t\t0x0B  \n#define STUSB160X_ALERT_STATUS_MASK_CTRL\t0x0C  \n#define STUSB160X_CC_CONNECTION_STATUS_TRANS\t0x0D  \n#define STUSB160X_CC_CONNECTION_STATUS\t\t0x0E  \n#define STUSB160X_MONITORING_STATUS_TRANS\t0x0F  \n#define STUSB160X_MONITORING_STATUS\t\t0x10  \n#define STUSB160X_CC_OPERATION_STATUS\t\t0x11  \n#define STUSB160X_HW_FAULT_STATUS_TRANS\t\t0x12  \n#define STUSB160X_HW_FAULT_STATUS\t\t0x13  \n#define STUSB160X_CC_CAPABILITY_CTRL\t\t0x18  \n#define STUSB160X_CC_VCONN_SWITCH_CTRL\t\t0x1E  \n#define STUSB160X_VCONN_MONITORING_CTRL\t\t0x20  \n#define STUSB160X_VBUS_MONITORING_RANGE_CTRL\t0x22  \n#define STUSB160X_RESET_CTRL\t\t\t0x23  \n#define STUSB160X_VBUS_DISCHARGE_TIME_CTRL\t0x25  \n#define STUSB160X_VBUS_DISCHARGE_STATUS\t\t0x26  \n#define STUSB160X_VBUS_ENABLE_STATUS\t\t0x27  \n#define STUSB160X_CC_POWER_MODE_CTRL\t\t0x28  \n#define STUSB160X_VBUS_MONITORING_CTRL\t\t0x2E  \n#define STUSB1600_REG_MAX\t\t\t0x2F  \n\n \n#define STUSB160X_HW_FAULT\t\t\tBIT(4)\n#define STUSB160X_MONITORING\t\t\tBIT(5)\n#define STUSB160X_CC_CONNECTION\t\t\tBIT(6)\n#define STUSB160X_ALL_ALERTS\t\t\tGENMASK(6, 4)\n\n \n#define STUSB160X_CC_ATTACH_TRANS\t\tBIT(0)\n\n \n#define STUSB160X_CC_ATTACH\t\t\tBIT(0)\n#define STUSB160X_CC_VCONN_SUPPLY\t\tBIT(1)\n#define STUSB160X_CC_DATA_ROLE(s)\t\t(!!((s) & BIT(2)))\n#define STUSB160X_CC_POWER_ROLE(s)\t\t(!!((s) & BIT(3)))\n#define STUSB160X_CC_ATTACHED_MODE\t\tGENMASK(7, 5)\n\n \n#define STUSB160X_VCONN_PRESENCE_TRANS\t\tBIT(0)\n#define STUSB160X_VBUS_PRESENCE_TRANS\t\tBIT(1)\n#define STUSB160X_VBUS_VSAFE0V_TRANS\t\tBIT(2)\n#define STUSB160X_VBUS_VALID_TRANS\t\tBIT(3)\n\n \n#define STUSB160X_VCONN_PRESENCE\t\tBIT(0)\n#define STUSB160X_VBUS_PRESENCE\t\t\tBIT(1)\n#define STUSB160X_VBUS_VSAFE0V\t\t\tBIT(2)\n#define STUSB160X_VBUS_VALID\t\t\tBIT(3)\n\n \n#define STUSB160X_TYPEC_FSM_STATE\t\tGENMASK(4, 0)\n#define STUSB160X_SINK_POWER_STATE\t\tGENMASK(6, 5)\n#define STUSB160X_CC_ATTACHED\t\t\tBIT(7)\n\n \n#define STUSB160X_VCONN_SW_OVP_FAULT_TRANS\tBIT(0)\n#define STUSB160X_VCONN_SW_OCP_FAULT_TRANS\tBIT(1)\n#define STUSB160X_VCONN_SW_RVP_FAULT_TRANS\tBIT(2)\n#define STUSB160X_VPU_VALID_TRANS\t\tBIT(4)\n#define STUSB160X_VPU_OVP_FAULT_TRANS\t\tBIT(5)\n#define STUSB160X_THERMAL_FAULT\t\t\tBIT(7)\n\n \n#define STUSB160X_VCONN_SW_OVP_FAULT_CC2\tBIT(0)\n#define STUSB160X_VCONN_SW_OVP_FAULT_CC1\tBIT(1)\n#define STUSB160X_VCONN_SW_OCP_FAULT_CC2\tBIT(2)\n#define STUSB160X_VCONN_SW_OCP_FAULT_CC1\tBIT(3)\n#define STUSB160X_VCONN_SW_RVP_FAULT_CC2\tBIT(4)\n#define STUSB160X_VCONN_SW_RVP_FAULT_CC1\tBIT(5)\n#define STUSB160X_VPU_VALID\t\t\tBIT(6)\n#define STUSB160X_VPU_OVP_FAULT\t\t\tBIT(7)\n\n \n#define STUSB160X_CC_VCONN_SUPPLY_EN\t\tBIT(0)\n#define STUSB160X_CC_VCONN_DISCHARGE_EN\t\tBIT(4)\n#define STUSB160X_CC_CURRENT_ADVERTISED\t\tGENMASK(7, 6)\n\n \n#define STUSB160X_CC_VCONN_SWITCH_ILIM\t\tGENMASK(3, 0)\n\n \n#define STUSB160X_VCONN_UVLO_THRESHOLD\t\tBIT(6)\n#define STUSB160X_VCONN_MONITORING_EN\t\tBIT(7)\n\n \n#define STUSB160X_SHIFT_LOW_VBUS_LIMIT\t\tGENMASK(3, 0)\n#define STUSB160X_SHIFT_HIGH_VBUS_LIMIT\t\tGENMASK(7, 4)\n\n \n#define STUSB160X_SW_RESET_EN\t\t\tBIT(0)\n\n \n#define STUSBXX02_VBUS_DISCHARGE_TIME_TO_PDO\tGENMASK(3, 0)\n#define STUSB160X_VBUS_DISCHARGE_TIME_TO_0V\tGENMASK(7, 4)\n\n \n#define STUSB160X_VBUS_DISCHARGE_EN\t\tBIT(7)\n\n \n#define STUSB160X_VBUS_SOURCE_EN\t\tBIT(0)\n#define STUSB160X_VBUS_SINK_EN\t\t\tBIT(1)\n\n \n#define STUSB160X_CC_POWER_MODE\t\t\tGENMASK(2, 0)\n\n \n#define STUSB160X_VDD_UVLO_DISABLE\t\tBIT(0)\n#define STUSB160X_VBUS_VSAFE0V_THRESHOLD\tGENMASK(2, 1)\n#define STUSB160X_VBUS_RANGE_DISABLE\t\tBIT(4)\n#define STUSB160X_VDD_OVLO_DISABLE\t\tBIT(6)\n\nenum stusb160x_pwr_mode {\n\tSOURCE_WITH_ACCESSORY,\n\tSINK_WITH_ACCESSORY,\n\tSINK_WITHOUT_ACCESSORY,\n\tDUAL_WITH_ACCESSORY,\n\tDUAL_WITH_ACCESSORY_AND_TRY_SRC,\n\tDUAL_WITH_ACCESSORY_AND_TRY_SNK,\n};\n\nenum stusb160x_attached_mode {\n\tNO_DEVICE_ATTACHED,\n\tSINK_ATTACHED,\n\tSOURCE_ATTACHED,\n\tDEBUG_ACCESSORY_ATTACHED,\n\tAUDIO_ACCESSORY_ATTACHED,\n};\n\nstruct stusb160x {\n\tstruct device\t\t*dev;\n\tstruct regmap\t\t*regmap;\n\tstruct regulator\t*vdd_supply;\n\tstruct regulator\t*vsys_supply;\n\tstruct regulator\t*vconn_supply;\n\tstruct regulator\t*main_supply;\n\n\tstruct typec_port\t*port;\n\tstruct typec_capability capability;\n\tstruct typec_partner\t*partner;\n\n\tenum typec_port_type\tport_type;\n\tenum typec_pwr_opmode\tpwr_opmode;\n\tbool\t\t\tvbus_on;\n\n\tstruct usb_role_switch\t*role_sw;\n};\n\nstatic bool stusb160x_reg_writeable(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STUSB160X_ALERT_STATUS_MASK_CTRL:\n\tcase STUSB160X_CC_CAPABILITY_CTRL:\n\tcase STUSB160X_CC_VCONN_SWITCH_CTRL:\n\tcase STUSB160X_VCONN_MONITORING_CTRL:\n\tcase STUSB160X_VBUS_MONITORING_RANGE_CTRL:\n\tcase STUSB160X_RESET_CTRL:\n\tcase STUSB160X_VBUS_DISCHARGE_TIME_CTRL:\n\tcase STUSB160X_CC_POWER_MODE_CTRL:\n\tcase STUSB160X_VBUS_MONITORING_CTRL:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stusb160x_reg_readable(struct device *dev, unsigned int reg)\n{\n\tif (reg <= 0x0A ||\n\t    (reg >= 0x14 && reg <= 0x17) ||\n\t    (reg >= 0x19 && reg <= 0x1D) ||\n\t    (reg >= 0x29 && reg <= 0x2D) ||\n\t    (reg == 0x1F || reg == 0x21 || reg == 0x24 || reg == 0x2F))\n\t\treturn false;\n\telse\n\t\treturn true;\n}\n\nstatic bool stusb160x_reg_volatile(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STUSB160X_ALERT_STATUS:\n\tcase STUSB160X_CC_CONNECTION_STATUS_TRANS:\n\tcase STUSB160X_CC_CONNECTION_STATUS:\n\tcase STUSB160X_MONITORING_STATUS_TRANS:\n\tcase STUSB160X_MONITORING_STATUS:\n\tcase STUSB160X_CC_OPERATION_STATUS:\n\tcase STUSB160X_HW_FAULT_STATUS_TRANS:\n\tcase STUSB160X_HW_FAULT_STATUS:\n\tcase STUSB160X_VBUS_DISCHARGE_STATUS:\n\tcase STUSB160X_VBUS_ENABLE_STATUS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic bool stusb160x_reg_precious(struct device *dev, unsigned int reg)\n{\n\tswitch (reg) {\n\tcase STUSB160X_ALERT_STATUS:\n\tcase STUSB160X_CC_CONNECTION_STATUS_TRANS:\n\tcase STUSB160X_MONITORING_STATUS_TRANS:\n\tcase STUSB160X_HW_FAULT_STATUS_TRANS:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nstatic const struct regmap_config stusb1600_regmap_config = {\n\t.reg_bits\t= 8,\n\t.reg_stride\t= 1,\n\t.val_bits\t= 8,\n\t.max_register\t= STUSB1600_REG_MAX,\n\t.writeable_reg\t= stusb160x_reg_writeable,\n\t.readable_reg\t= stusb160x_reg_readable,\n\t.volatile_reg\t= stusb160x_reg_volatile,\n\t.precious_reg\t= stusb160x_reg_precious,\n\t.cache_type\t= REGCACHE_RBTREE,\n};\n\nstatic bool stusb160x_get_vconn(struct stusb160x *chip)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, STUSB160X_CC_CAPABILITY_CTRL, &val);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Unable to get Vconn status: %d\\n\", ret);\n\t\treturn false;\n\t}\n\n\treturn !!FIELD_GET(STUSB160X_CC_VCONN_SUPPLY_EN, val);\n}\n\nstatic int stusb160x_set_vconn(struct stusb160x *chip, bool on)\n{\n\tint ret;\n\n\t \n\tif (chip->vconn_supply) {\n\t\tif (on) {\n\t\t\tret = regulator_enable(chip->vconn_supply);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"failed to enable vconn supply: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} else {\n\t\t\tregulator_disable(chip->vconn_supply);\n\t\t}\n\t}\n\n\t \n\tret = regmap_update_bits(chip->regmap, STUSB160X_VCONN_MONITORING_CTRL,\n\t\t\t\t STUSB160X_VCONN_MONITORING_EN,\n\t\t\t\t on ? STUSB160X_VCONN_MONITORING_EN : 0);\n\tif (ret)\n\t\tgoto vconn_reg_disable;\n\n\treturn 0;\n\nvconn_reg_disable:\n\tif (chip->vconn_supply && on)\n\t\tregulator_disable(chip->vconn_supply);\n\n\treturn ret;\n}\n\nstatic enum typec_pwr_opmode stusb160x_get_pwr_opmode(struct stusb160x *chip)\n{\n\tu32 val;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, STUSB160X_CC_CAPABILITY_CTRL, &val);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Unable to get pwr opmode: %d\\n\", ret);\n\t\treturn TYPEC_PWR_MODE_USB;\n\t}\n\n\treturn FIELD_GET(STUSB160X_CC_CURRENT_ADVERTISED, val);\n}\n\nstatic enum typec_accessory stusb160x_get_accessory(u32 status)\n{\n\tenum stusb160x_attached_mode mode;\n\n\tmode = FIELD_GET(STUSB160X_CC_ATTACHED_MODE, status);\n\n\tswitch (mode) {\n\tcase DEBUG_ACCESSORY_ATTACHED:\n\t\treturn TYPEC_ACCESSORY_DEBUG;\n\tcase AUDIO_ACCESSORY_ATTACHED:\n\t\treturn TYPEC_ACCESSORY_AUDIO;\n\tdefault:\n\t\treturn TYPEC_ACCESSORY_NONE;\n\t}\n}\n\nstatic enum typec_role stusb160x_get_vconn_role(u32 status)\n{\n\tif (FIELD_GET(STUSB160X_CC_VCONN_SUPPLY, status))\n\t\treturn TYPEC_SOURCE;\n\n\treturn TYPEC_SINK;\n}\n\nstatic void stusb160x_set_data_role(struct stusb160x *chip,\n\t\t\t\t    enum typec_data_role data_role,\n\t\t\t\t    bool attached)\n{\n\tenum usb_role usb_role = USB_ROLE_NONE;\n\n\tif (attached) {\n\t\tif (data_role == TYPEC_HOST)\n\t\t\tusb_role = USB_ROLE_HOST;\n\t\telse\n\t\t\tusb_role = USB_ROLE_DEVICE;\n\t}\n\n\tusb_role_switch_set_role(chip->role_sw, usb_role);\n\ttypec_set_data_role(chip->port, data_role);\n}\n\nstatic int stusb160x_attach(struct stusb160x *chip, u32 status)\n{\n\tstruct typec_partner_desc desc;\n\tint ret;\n\n\tif ((STUSB160X_CC_POWER_ROLE(status) == TYPEC_SOURCE) &&\n\t    chip->vdd_supply) {\n\t\tret = regulator_enable(chip->vdd_supply);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to enable Vbus supply: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t\tchip->vbus_on = true;\n\t}\n\n\tdesc.usb_pd = false;\n\tdesc.accessory = stusb160x_get_accessory(status);\n\tdesc.identity = NULL;\n\n\tchip->partner = typec_register_partner(chip->port, &desc);\n\tif (IS_ERR(chip->partner)) {\n\t\tret = PTR_ERR(chip->partner);\n\t\tgoto vbus_disable;\n\t}\n\n\ttypec_set_pwr_role(chip->port, STUSB160X_CC_POWER_ROLE(status));\n\ttypec_set_pwr_opmode(chip->port, stusb160x_get_pwr_opmode(chip));\n\ttypec_set_vconn_role(chip->port, stusb160x_get_vconn_role(status));\n\tstusb160x_set_data_role(chip, STUSB160X_CC_DATA_ROLE(status), true);\n\n\treturn 0;\n\nvbus_disable:\n\tif (chip->vbus_on) {\n\t\tregulator_disable(chip->vdd_supply);\n\t\tchip->vbus_on = false;\n\t}\n\n\treturn ret;\n}\n\nstatic void stusb160x_detach(struct stusb160x *chip, u32 status)\n{\n\ttypec_unregister_partner(chip->partner);\n\tchip->partner = NULL;\n\n\ttypec_set_pwr_role(chip->port, STUSB160X_CC_POWER_ROLE(status));\n\ttypec_set_pwr_opmode(chip->port, TYPEC_PWR_MODE_USB);\n\ttypec_set_vconn_role(chip->port, stusb160x_get_vconn_role(status));\n\tstusb160x_set_data_role(chip, STUSB160X_CC_DATA_ROLE(status), false);\n\n\tif (chip->vbus_on) {\n\t\tregulator_disable(chip->vdd_supply);\n\t\tchip->vbus_on = false;\n\t}\n}\n\nstatic irqreturn_t stusb160x_irq_handler(int irq, void *data)\n{\n\tstruct stusb160x *chip = data;\n\tu32 pending, trans, status;\n\tint ret;\n\n\tret = regmap_read(chip->regmap, STUSB160X_ALERT_STATUS, &pending);\n\tif (ret)\n\t\tgoto err;\n\n\tif (pending & STUSB160X_CC_CONNECTION) {\n\t\tret = regmap_read(chip->regmap,\n\t\t\t\t  STUSB160X_CC_CONNECTION_STATUS_TRANS, &trans);\n\t\tif (ret)\n\t\t\tgoto err;\n\t\tret = regmap_read(chip->regmap,\n\t\t\t\t  STUSB160X_CC_CONNECTION_STATUS, &status);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tif (trans & STUSB160X_CC_ATTACH_TRANS) {\n\t\t\tif (status & STUSB160X_CC_ATTACH) {\n\t\t\t\tret = stusb160x_attach(chip, status);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tstusb160x_detach(chip, status);\n\t\t\t}\n\t\t}\n\t}\nerr:\n\treturn IRQ_HANDLED;\n}\n\nstatic int stusb160x_irq_init(struct stusb160x *chip, int irq)\n{\n\tu32 status;\n\tint ret;\n\n\tret = regmap_read(chip->regmap,\n\t\t\t  STUSB160X_CC_CONNECTION_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (status & STUSB160X_CC_ATTACH) {\n\t\tret = stusb160x_attach(chip, status);\n\t\tif (ret)\n\t\t\tdev_err(chip->dev, \"attach failed: %d\\n\", ret);\n\t}\n\n\tret = devm_request_threaded_irq(chip->dev, irq, NULL,\n\t\t\t\t\tstusb160x_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\tdev_name(chip->dev), chip);\n\tif (ret)\n\t\tgoto partner_unregister;\n\n\t \n\tret = regmap_write_bits(chip->regmap, STUSB160X_ALERT_STATUS_MASK_CTRL,\n\t\t\t\tSTUSB160X_CC_CONNECTION, 0);\n\tif (ret)\n\t\tgoto partner_unregister;\n\n\treturn 0;\n\npartner_unregister:\n\tif (chip->partner) {\n\t\ttypec_unregister_partner(chip->partner);\n\t\tchip->partner = NULL;\n\t}\n\n\treturn ret;\n}\n\nstatic int stusb160x_chip_init(struct stusb160x *chip)\n{\n\tu32 val;\n\tint ret;\n\n\t \n\tif (chip->port_type == TYPEC_PORT_SRC)\n\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE_CTRL,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE,\n\t\t\t\t\t SOURCE_WITH_ACCESSORY);\n\telse if (chip->port_type == TYPEC_PORT_SNK)\n\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE_CTRL,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE,\n\t\t\t\t\t SINK_WITH_ACCESSORY);\n\telse  \n\t\tret = regmap_update_bits(chip->regmap,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE_CTRL,\n\t\t\t\t\t STUSB160X_CC_POWER_MODE,\n\t\t\t\t\t DUAL_WITH_ACCESSORY);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->port_type == TYPEC_PORT_SNK)\n\t\tgoto skip_src;\n\n\t \n\tret = regmap_update_bits(chip->regmap, STUSB160X_CC_CAPABILITY_CTRL,\n\t\t\t\t STUSB160X_CC_CURRENT_ADVERTISED,\n\t\t\t\t FIELD_PREP(STUSB160X_CC_CURRENT_ADVERTISED,\n\t\t\t\t\t    chip->pwr_opmode));\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (stusb160x_get_vconn(chip)) {\n\t\tret = stusb160x_set_vconn(chip, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\nskip_src:\n\t \n\tret = regmap_update_bits(chip->regmap, STUSB160X_ALERT_STATUS_MASK_CTRL,\n\t\t\t\t STUSB160X_ALL_ALERTS, STUSB160X_ALL_ALERTS);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tregmap_read(chip->regmap, STUSB160X_ALERT_STATUS, &val);\n\tregmap_read(chip->regmap, STUSB160X_CC_CONNECTION_STATUS_TRANS, &val);\n\tregmap_read(chip->regmap, STUSB160X_MONITORING_STATUS_TRANS, &val);\n\tregmap_read(chip->regmap, STUSB160X_HW_FAULT_STATUS_TRANS, &val);\n\n\treturn 0;\n}\n\nstatic int stusb160x_get_fw_caps(struct stusb160x *chip,\n\t\t\t\t struct fwnode_handle *fwnode)\n{\n\tconst char *cap_str;\n\tint ret;\n\n\tchip->capability.fwnode = fwnode;\n\n\t \n\tret = fwnode_property_read_string(fwnode, \"power-role\", &cap_str);\n\tif (!ret) {\n\t\tret = typec_find_port_power_role(cap_str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tchip->port_type = ret;\n\t}\n\tchip->capability.type = chip->port_type;\n\n\t \n\tif (chip->port_type == TYPEC_PORT_SNK)\n\t\treturn 0;\n\n\tif (chip->port_type == TYPEC_PORT_DRP)\n\t\tchip->capability.prefer_role = TYPEC_SINK;\n\n\t \n\tret = fwnode_property_read_string(fwnode, \"typec-power-opmode\", &cap_str);\n\tif (!ret) {\n\t\tret = typec_find_pwr_opmode(cap_str);\n\t\t \n\t\tif (ret < 0 || ret == TYPEC_PWR_MODE_PD) {\n\t\t\tdev_err(chip->dev, \"bad power operation mode: %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tchip->pwr_opmode = ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int stusb160x_get_caps(struct stusb160x *chip)\n{\n\tenum typec_port_type *type = &chip->capability.type;\n\tenum typec_port_data *data = &chip->capability.data;\n\tenum typec_accessory *accessory = chip->capability.accessory;\n\tu32 val;\n\tint ret;\n\n\tchip->capability.revision = USB_TYPEC_REV_1_2;\n\n\tret = regmap_read(chip->regmap, STUSB160X_CC_POWER_MODE_CTRL, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (FIELD_GET(STUSB160X_CC_POWER_MODE, val)) {\n\tcase SOURCE_WITH_ACCESSORY:\n\t\t*type = TYPEC_PORT_SRC;\n\t\t*data = TYPEC_PORT_DFP;\n\t\t*accessory++ = TYPEC_ACCESSORY_AUDIO;\n\t\t*accessory++ = TYPEC_ACCESSORY_DEBUG;\n\t\tbreak;\n\tcase SINK_WITH_ACCESSORY:\n\t\t*type = TYPEC_PORT_SNK;\n\t\t*data = TYPEC_PORT_UFP;\n\t\t*accessory++ = TYPEC_ACCESSORY_AUDIO;\n\t\t*accessory++ = TYPEC_ACCESSORY_DEBUG;\n\t\tbreak;\n\tcase SINK_WITHOUT_ACCESSORY:\n\t\t*type = TYPEC_PORT_SNK;\n\t\t*data = TYPEC_PORT_UFP;\n\t\tbreak;\n\tcase DUAL_WITH_ACCESSORY:\n\tcase DUAL_WITH_ACCESSORY_AND_TRY_SRC:\n\tcase DUAL_WITH_ACCESSORY_AND_TRY_SNK:\n\t\t*type = TYPEC_PORT_DRP;\n\t\t*data = TYPEC_PORT_DRD;\n\t\t*accessory++ = TYPEC_ACCESSORY_AUDIO;\n\t\t*accessory++ = TYPEC_ACCESSORY_DEBUG;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tchip->port_type = *type;\n\tchip->pwr_opmode = stusb160x_get_pwr_opmode(chip);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id stusb160x_of_match[] = {\n\t{ .compatible = \"st,stusb1600\", .data = &stusb1600_regmap_config},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, stusb160x_of_match);\n\nstatic int stusb160x_probe(struct i2c_client *client)\n{\n\tstruct stusb160x *chip;\n\tconst struct of_device_id *match;\n\tstruct regmap_config *regmap_config;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(struct stusb160x), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, chip);\n\n\tmatch = i2c_of_match_device(stusb160x_of_match, client);\n\tregmap_config = (struct regmap_config *)match->data;\n\tchip->regmap = devm_regmap_init_i2c(client, regmap_config);\n\tif (IS_ERR(chip->regmap)) {\n\t\tret = PTR_ERR(chip->regmap);\n\t\tdev_err(&client->dev,\n\t\t\t\"Failed to allocate register map:%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tchip->dev = &client->dev;\n\n\tchip->vsys_supply = devm_regulator_get_optional(chip->dev, \"vsys\");\n\tif (IS_ERR(chip->vsys_supply)) {\n\t\tret = PTR_ERR(chip->vsys_supply);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t\tchip->vsys_supply = NULL;\n\t}\n\n\tchip->vdd_supply = devm_regulator_get_optional(chip->dev, \"vdd\");\n\tif (IS_ERR(chip->vdd_supply)) {\n\t\tret = PTR_ERR(chip->vdd_supply);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t\tchip->vdd_supply = NULL;\n\t}\n\n\tchip->vconn_supply = devm_regulator_get_optional(chip->dev, \"vconn\");\n\tif (IS_ERR(chip->vconn_supply)) {\n\t\tret = PTR_ERR(chip->vconn_supply);\n\t\tif (ret != -ENODEV)\n\t\t\treturn ret;\n\t\tchip->vconn_supply = NULL;\n\t}\n\n\tfwnode = device_get_named_child_node(chip->dev, \"connector\");\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\t \n\tfw_devlink_purge_absent_suppliers(fwnode);\n\n\t \n\tif (chip->vdd_supply &&\n\t    (!chip->vsys_supply ||\n\t     (regulator_get_voltage(chip->vsys_supply) <= 3100000)))\n\t\tchip->main_supply = chip->vdd_supply;\n\telse\n\t\tchip->main_supply = chip->vsys_supply;\n\n\tif (chip->main_supply) {\n\t\tret = regulator_enable(chip->main_supply);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev,\n\t\t\t\t\"Failed to enable main supply: %d\\n\", ret);\n\t\t\tgoto fwnode_put;\n\t\t}\n\t}\n\n\t \n\tret = stusb160x_get_caps(chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to get port caps: %d\\n\", ret);\n\t\tgoto main_reg_disable;\n\t}\n\n\t \n\tret = stusb160x_get_fw_caps(chip, fwnode);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to get connector caps: %d\\n\", ret);\n\t\tgoto main_reg_disable;\n\t}\n\n\tret = stusb160x_chip_init(chip);\n\tif (ret) {\n\t\tdev_err(chip->dev, \"Failed to init port: %d\\n\", ret);\n\t\tgoto main_reg_disable;\n\t}\n\n\tchip->port = typec_register_port(chip->dev, &chip->capability);\n\tif (IS_ERR(chip->port)) {\n\t\tret = PTR_ERR(chip->port);\n\t\tgoto all_reg_disable;\n\t}\n\n\t \n\ttypec_set_pwr_opmode(chip->port, chip->pwr_opmode);\n\n\tif (client->irq) {\n\t\tchip->role_sw = fwnode_usb_role_switch_get(fwnode);\n\t\tif (IS_ERR(chip->role_sw)) {\n\t\t\tret = dev_err_probe(chip->dev, PTR_ERR(chip->role_sw),\n\t\t\t\t\t    \"Failed to get usb role switch\\n\");\n\t\t\tgoto port_unregister;\n\t\t}\n\n\t\tret = stusb160x_irq_init(chip, client->irq);\n\t\tif (ret)\n\t\t\tgoto role_sw_put;\n\t} else {\n\t\t \n\t\tif (chip->port_type != TYPEC_PORT_SNK && chip->vdd_supply) {\n\t\t\tret = regulator_enable(chip->vdd_supply);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(chip->dev,\n\t\t\t\t\t\"Failed to enable VDD supply: %d\\n\",\n\t\t\t\t\tret);\n\t\t\t\tgoto port_unregister;\n\t\t\t}\n\t\t\tchip->vbus_on = true;\n\t\t}\n\t}\n\n\tfwnode_handle_put(fwnode);\n\n\treturn 0;\n\nrole_sw_put:\n\tif (chip->role_sw)\n\t\tusb_role_switch_put(chip->role_sw);\nport_unregister:\n\ttypec_unregister_port(chip->port);\nall_reg_disable:\n\tif (stusb160x_get_vconn(chip))\n\t\tstusb160x_set_vconn(chip, false);\nmain_reg_disable:\n\tif (chip->main_supply)\n\t\tregulator_disable(chip->main_supply);\nfwnode_put:\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic void stusb160x_remove(struct i2c_client *client)\n{\n\tstruct stusb160x *chip = i2c_get_clientdata(client);\n\n\tif (chip->partner) {\n\t\ttypec_unregister_partner(chip->partner);\n\t\tchip->partner = NULL;\n\t}\n\n\tif (chip->vbus_on)\n\t\tregulator_disable(chip->vdd_supply);\n\n\tif (chip->role_sw)\n\t\tusb_role_switch_put(chip->role_sw);\n\n\ttypec_unregister_port(chip->port);\n\n\tif (stusb160x_get_vconn(chip))\n\t\tstusb160x_set_vconn(chip, false);\n\n\tif (chip->main_supply)\n\t\tregulator_disable(chip->main_supply);\n}\n\nstatic int __maybe_unused stusb160x_suspend(struct device *dev)\n{\n\tstruct stusb160x *chip = dev_get_drvdata(dev);\n\n\t \n\treturn regmap_update_bits(chip->regmap,\n\t\t\t\t  STUSB160X_ALERT_STATUS_MASK_CTRL,\n\t\t\t\t  STUSB160X_ALL_ALERTS, STUSB160X_ALL_ALERTS);\n}\n\nstatic int __maybe_unused stusb160x_resume(struct device *dev)\n{\n\tstruct stusb160x *chip = dev_get_drvdata(dev);\n\tu32 status;\n\tint ret;\n\n\tret = regcache_sync(chip->regmap);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_read(chip->regmap,\n\t\t\t  STUSB160X_CC_CONNECTION_STATUS, &status);\n\tif (ret)\n\t\treturn ret;\n\n\tif (chip->partner && !(status & STUSB160X_CC_ATTACH))\n\t\tstusb160x_detach(chip, status);\n\n\tif (!chip->partner && (status & STUSB160X_CC_ATTACH)) {\n\t\tret = stusb160x_attach(chip, status);\n\t\tif (ret)\n\t\t\tdev_err(chip->dev, \"attach failed: %d\\n\", ret);\n\t}\n\n\t \n\treturn regmap_write_bits(chip->regmap, STUSB160X_ALERT_STATUS_MASK_CTRL,\n\t\t\t\t STUSB160X_CC_CONNECTION, 0);\n}\n\nstatic SIMPLE_DEV_PM_OPS(stusb160x_pm_ops, stusb160x_suspend, stusb160x_resume);\n\nstatic struct i2c_driver stusb160x_driver = {\n\t.driver = {\n\t\t.name = \"stusb160x\",\n\t\t.pm = &stusb160x_pm_ops,\n\t\t.of_match_table = stusb160x_of_match,\n\t},\n\t.probe = stusb160x_probe,\n\t.remove = stusb160x_remove,\n};\nmodule_i2c_driver(stusb160x_driver);\n\nMODULE_AUTHOR(\"Amelie Delaunay <amelie.delaunay@st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STUSB160x Type-C controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}