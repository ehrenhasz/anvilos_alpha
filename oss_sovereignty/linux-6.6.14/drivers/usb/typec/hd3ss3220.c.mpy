{
  "module_name": "hd3ss3220.c",
  "hash_id": "2172fbb964398cab24f674c4007585af3743c46cc123a07f83e77a004f42f7ff",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/hd3ss3220.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/usb/role.h>\n#include <linux/irqreturn.h>\n#include <linux/interrupt.h>\n#include <linux/regmap.h>\n#include <linux/slab.h>\n#include <linux/usb/typec.h>\n#include <linux/delay.h>\n#include <linux/workqueue.h>\n\n#define HD3SS3220_REG_CN_STAT_CTRL\t0x09\n#define HD3SS3220_REG_GEN_CTRL\t\t0x0A\n#define HD3SS3220_REG_DEV_REV\t\t0xA0\n\n \n#define HD3SS3220_REG_CN_STAT_CTRL_ATTACHED_STATE_MASK\t(BIT(7) | BIT(6))\n#define HD3SS3220_REG_CN_STAT_CTRL_AS_DFP\t\tBIT(6)\n#define HD3SS3220_REG_CN_STAT_CTRL_AS_UFP\t\tBIT(7)\n#define HD3SS3220_REG_CN_STAT_CTRL_TO_ACCESSORY\t\t(BIT(7) | BIT(6))\n#define HD3SS3220_REG_CN_STAT_CTRL_INT_STATUS\t\tBIT(4)\n\n \n#define HD3SS3220_REG_GEN_CTRL_SRC_PREF_MASK\t\t(BIT(2) | BIT(1))\n#define HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_DEFAULT\t0x00\n#define HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_TRY_SNK\tBIT(1)\n#define HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_TRY_SRC\t(BIT(2) | BIT(1))\n\nstruct hd3ss3220 {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct usb_role_switch\t*role_sw;\n\tstruct typec_port *port;\n\tstruct delayed_work output_poll_work;\n\tenum usb_role role_state;\n\tbool poll;\n};\n\nstatic int hd3ss3220_set_source_pref(struct hd3ss3220 *hd3ss3220, int src_pref)\n{\n\treturn regmap_update_bits(hd3ss3220->regmap, HD3SS3220_REG_GEN_CTRL,\n\t\t\t\t  HD3SS3220_REG_GEN_CTRL_SRC_PREF_MASK,\n\t\t\t\t  src_pref);\n}\n\nstatic enum usb_role hd3ss3220_get_attached_state(struct hd3ss3220 *hd3ss3220)\n{\n\tunsigned int reg_val;\n\tenum usb_role attached_state;\n\tint ret;\n\n\tret = regmap_read(hd3ss3220->regmap, HD3SS3220_REG_CN_STAT_CTRL,\n\t\t\t  &reg_val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tswitch (reg_val & HD3SS3220_REG_CN_STAT_CTRL_ATTACHED_STATE_MASK) {\n\tcase HD3SS3220_REG_CN_STAT_CTRL_AS_DFP:\n\t\tattached_state = USB_ROLE_HOST;\n\t\tbreak;\n\tcase HD3SS3220_REG_CN_STAT_CTRL_AS_UFP:\n\t\tattached_state = USB_ROLE_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tattached_state = USB_ROLE_NONE;\n\t\tbreak;\n\t}\n\n\treturn attached_state;\n}\n\nstatic int hd3ss3220_dr_set(struct typec_port *port, enum typec_data_role role)\n{\n\tstruct hd3ss3220 *hd3ss3220 = typec_get_drvdata(port);\n\tenum usb_role role_val;\n\tint pref, ret = 0;\n\n\tif (role == TYPEC_HOST) {\n\t\trole_val = USB_ROLE_HOST;\n\t\tpref = HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_TRY_SRC;\n\t} else {\n\t\trole_val = USB_ROLE_DEVICE;\n\t\tpref = HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_TRY_SNK;\n\t}\n\n\tret = hd3ss3220_set_source_pref(hd3ss3220, pref);\n\tusleep_range(10, 100);\n\n\tusb_role_switch_set_role(hd3ss3220->role_sw, role_val);\n\ttypec_set_data_role(hd3ss3220->port, role);\n\n\treturn ret;\n}\n\nstatic const struct typec_operations hd3ss3220_ops = {\n\t.dr_set = hd3ss3220_dr_set\n};\n\nstatic void hd3ss3220_set_role(struct hd3ss3220 *hd3ss3220)\n{\n\tenum usb_role role_state = hd3ss3220_get_attached_state(hd3ss3220);\n\n\tusb_role_switch_set_role(hd3ss3220->role_sw, role_state);\n\tif (role_state == USB_ROLE_NONE)\n\t\thd3ss3220_set_source_pref(hd3ss3220,\n\t\t\t\tHD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_DEFAULT);\n\n\tswitch (role_state) {\n\tcase USB_ROLE_HOST:\n\t\ttypec_set_data_role(hd3ss3220->port, TYPEC_HOST);\n\t\tbreak;\n\tcase USB_ROLE_DEVICE:\n\t\ttypec_set_data_role(hd3ss3220->port, TYPEC_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\thd3ss3220->role_state = role_state;\n}\n\nstatic void output_poll_execute(struct work_struct *work)\n{\n\tstruct delayed_work *delayed_work = to_delayed_work(work);\n\tstruct hd3ss3220 *hd3ss3220 = container_of(delayed_work,\n\t\t\t\t\t\t   struct hd3ss3220,\n\t\t\t\t\t\t   output_poll_work);\n\tenum usb_role role_state = hd3ss3220_get_attached_state(hd3ss3220);\n\n\tif (hd3ss3220->role_state != role_state)\n\t\thd3ss3220_set_role(hd3ss3220);\n\n\tschedule_delayed_work(&hd3ss3220->output_poll_work, HZ);\n}\n\nstatic irqreturn_t hd3ss3220_irq(struct hd3ss3220 *hd3ss3220)\n{\n\tint err;\n\n\thd3ss3220_set_role(hd3ss3220);\n\terr = regmap_write_bits(hd3ss3220->regmap, HD3SS3220_REG_CN_STAT_CTRL,\n\t\t\t\tHD3SS3220_REG_CN_STAT_CTRL_INT_STATUS,\n\t\t\t\tHD3SS3220_REG_CN_STAT_CTRL_INT_STATUS);\n\tif (err < 0)\n\t\treturn IRQ_NONE;\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t hd3ss3220_irq_handler(int irq, void *data)\n{\n\tstruct i2c_client *client = to_i2c_client(data);\n\tstruct hd3ss3220 *hd3ss3220 = i2c_get_clientdata(client);\n\n\treturn hd3ss3220_irq(hd3ss3220);\n}\n\nstatic const struct regmap_config config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x0A,\n};\n\nstatic int hd3ss3220_probe(struct i2c_client *client)\n{\n\tstruct typec_capability typec_cap = { };\n\tstruct hd3ss3220 *hd3ss3220;\n\tstruct fwnode_handle *connector, *ep;\n\tint ret;\n\tunsigned int data;\n\n\thd3ss3220 = devm_kzalloc(&client->dev, sizeof(struct hd3ss3220),\n\t\t\t\t GFP_KERNEL);\n\tif (!hd3ss3220)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(client, hd3ss3220);\n\n\thd3ss3220->dev = &client->dev;\n\thd3ss3220->regmap = devm_regmap_init_i2c(client, &config);\n\tif (IS_ERR(hd3ss3220->regmap))\n\t\treturn PTR_ERR(hd3ss3220->regmap);\n\n\thd3ss3220_set_source_pref(hd3ss3220,\n\t\t\t\t  HD3SS3220_REG_GEN_CTRL_SRC_PREF_DRP_DEFAULT);\n\t \n\tconnector = device_get_named_child_node(hd3ss3220->dev, \"connector\");\n\tif (connector) {\n\t\thd3ss3220->role_sw = fwnode_usb_role_switch_get(connector);\n\t} else {\n\t\tep = fwnode_graph_get_next_endpoint(dev_fwnode(hd3ss3220->dev), NULL);\n\t\tif (!ep)\n\t\t\treturn -ENODEV;\n\t\tconnector = fwnode_graph_get_remote_port_parent(ep);\n\t\tfwnode_handle_put(ep);\n\t\tif (!connector)\n\t\t\treturn -ENODEV;\n\t\thd3ss3220->role_sw = usb_role_switch_get(hd3ss3220->dev);\n\t}\n\n\tif (IS_ERR(hd3ss3220->role_sw)) {\n\t\tret = PTR_ERR(hd3ss3220->role_sw);\n\t\tgoto err_put_fwnode;\n\t}\n\n\ttypec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;\n\ttypec_cap.driver_data = hd3ss3220;\n\ttypec_cap.type = TYPEC_PORT_DRP;\n\ttypec_cap.data = TYPEC_PORT_DRD;\n\ttypec_cap.ops = &hd3ss3220_ops;\n\ttypec_cap.fwnode = connector;\n\n\thd3ss3220->port = typec_register_port(&client->dev, &typec_cap);\n\tif (IS_ERR(hd3ss3220->port)) {\n\t\tret = PTR_ERR(hd3ss3220->port);\n\t\tgoto err_put_role;\n\t}\n\n\thd3ss3220_set_role(hd3ss3220);\n\tret = regmap_read(hd3ss3220->regmap, HD3SS3220_REG_CN_STAT_CTRL, &data);\n\tif (ret < 0)\n\t\tgoto err_unreg_port;\n\n\tif (data & HD3SS3220_REG_CN_STAT_CTRL_INT_STATUS) {\n\t\tret = regmap_write(hd3ss3220->regmap,\n\t\t\t\tHD3SS3220_REG_CN_STAT_CTRL,\n\t\t\t\tdata | HD3SS3220_REG_CN_STAT_CTRL_INT_STATUS);\n\t\tif (ret < 0)\n\t\t\tgoto err_unreg_port;\n\t}\n\n\tif (client->irq > 0) {\n\t\tret = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\thd3ss3220_irq_handler,\n\t\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\t\"hd3ss3220\", &client->dev);\n\t\tif (ret)\n\t\t\tgoto err_unreg_port;\n\t} else {\n\t\tINIT_DELAYED_WORK(&hd3ss3220->output_poll_work, output_poll_execute);\n\t\thd3ss3220->poll = true;\n\t}\n\n\tret = i2c_smbus_read_byte_data(client, HD3SS3220_REG_DEV_REV);\n\tif (ret < 0)\n\t\tgoto err_unreg_port;\n\n\tfwnode_handle_put(connector);\n\n\tif (hd3ss3220->poll)\n\t\tschedule_delayed_work(&hd3ss3220->output_poll_work, HZ);\n\n\tdev_info(&client->dev, \"probed revision=0x%x\\n\", ret);\n\n\treturn 0;\nerr_unreg_port:\n\ttypec_unregister_port(hd3ss3220->port);\nerr_put_role:\n\tusb_role_switch_put(hd3ss3220->role_sw);\nerr_put_fwnode:\n\tfwnode_handle_put(connector);\n\n\treturn ret;\n}\n\nstatic void hd3ss3220_remove(struct i2c_client *client)\n{\n\tstruct hd3ss3220 *hd3ss3220 = i2c_get_clientdata(client);\n\n\tif (hd3ss3220->poll)\n\t\tcancel_delayed_work_sync(&hd3ss3220->output_poll_work);\n\n\ttypec_unregister_port(hd3ss3220->port);\n\tusb_role_switch_put(hd3ss3220->role_sw);\n}\n\nstatic const struct of_device_id dev_ids[] = {\n\t{ .compatible = \"ti,hd3ss3220\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(of, dev_ids);\n\nstatic struct i2c_driver hd3ss3220_driver = {\n\t.driver = {\n\t\t.name = \"hd3ss3220\",\n\t\t.of_match_table = dev_ids,\n\t},\n\t.probe = hd3ss3220_probe,\n\t.remove = hd3ss3220_remove,\n};\n\nmodule_i2c_driver(hd3ss3220_driver);\n\nMODULE_AUTHOR(\"Biju Das <biju.das@bp.renesas.com>\");\nMODULE_DESCRIPTION(\"TI HD3SS3220 DRP Port Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}