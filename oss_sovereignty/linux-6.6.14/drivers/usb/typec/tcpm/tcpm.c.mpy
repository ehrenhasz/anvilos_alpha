{
  "module_name": "tcpm.c",
  "hash_id": "e64b03fdc8ffef9c690d0fd22a781c621ffb6470c839fe2493aba54bd486d646",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/tcpm.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/debugfs.h>\n#include <linux/device.h>\n#include <linux/hrtimer.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/power_supply.h>\n#include <linux/proc_fs.h>\n#include <linux/property.h>\n#include <linux/sched/clock.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/pd_ado.h>\n#include <linux/usb/pd_bdo.h>\n#include <linux/usb/pd_ext_sdb.h>\n#include <linux/usb/pd_vdo.h>\n#include <linux/usb/role.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec_altmode.h>\n\n#include <uapi/linux/sched/types.h>\n\n#define FOREACH_STATE(S)\t\t\t\\\n\tS(INVALID_STATE),\t\t\t\\\n\tS(TOGGLING),\t\t\t\\\n\tS(CHECK_CONTAMINANT),\t\t\t\\\n\tS(SRC_UNATTACHED),\t\t\t\\\n\tS(SRC_ATTACH_WAIT),\t\t\t\\\n\tS(SRC_ATTACHED),\t\t\t\\\n\tS(SRC_STARTUP),\t\t\t\t\\\n\tS(SRC_SEND_CAPABILITIES),\t\t\\\n\tS(SRC_SEND_CAPABILITIES_TIMEOUT),\t\\\n\tS(SRC_NEGOTIATE_CAPABILITIES),\t\t\\\n\tS(SRC_TRANSITION_SUPPLY),\t\t\\\n\tS(SRC_READY),\t\t\t\t\\\n\tS(SRC_WAIT_NEW_CAPABILITIES),\t\t\\\n\t\t\t\t\t\t\\\n\tS(SNK_UNATTACHED),\t\t\t\\\n\tS(SNK_ATTACH_WAIT),\t\t\t\\\n\tS(SNK_DEBOUNCED),\t\t\t\\\n\tS(SNK_ATTACHED),\t\t\t\\\n\tS(SNK_STARTUP),\t\t\t\t\\\n\tS(SNK_DISCOVERY),\t\t\t\\\n\tS(SNK_DISCOVERY_DEBOUNCE),\t\t\\\n\tS(SNK_DISCOVERY_DEBOUNCE_DONE),\t\t\\\n\tS(SNK_WAIT_CAPABILITIES),\t\t\\\n\tS(SNK_NEGOTIATE_CAPABILITIES),\t\t\\\n\tS(SNK_NEGOTIATE_PPS_CAPABILITIES),\t\\\n\tS(SNK_TRANSITION_SINK),\t\t\t\\\n\tS(SNK_TRANSITION_SINK_VBUS),\t\t\\\n\tS(SNK_READY),\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(ACC_UNATTACHED),\t\t\t\\\n\tS(DEBUG_ACC_ATTACHED),\t\t\t\\\n\tS(AUDIO_ACC_ATTACHED),\t\t\t\\\n\tS(AUDIO_ACC_DEBOUNCE),\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(HARD_RESET_SEND),\t\t\t\\\n\tS(HARD_RESET_START),\t\t\t\\\n\tS(SRC_HARD_RESET_VBUS_OFF),\t\t\\\n\tS(SRC_HARD_RESET_VBUS_ON),\t\t\\\n\tS(SNK_HARD_RESET_SINK_OFF),\t\t\\\n\tS(SNK_HARD_RESET_WAIT_VBUS),\t\t\\\n\tS(SNK_HARD_RESET_SINK_ON),\t\t\\\n\t\t\t\t\t\t\\\n\tS(SOFT_RESET),\t\t\t\t\\\n\tS(SRC_SOFT_RESET_WAIT_SNK_TX),\t\t\\\n\tS(SNK_SOFT_RESET),\t\t\t\\\n\tS(SOFT_RESET_SEND),\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(DR_SWAP_ACCEPT),\t\t\t\\\n\tS(DR_SWAP_SEND),\t\t\t\\\n\tS(DR_SWAP_SEND_TIMEOUT),\t\t\\\n\tS(DR_SWAP_CANCEL),\t\t\t\\\n\tS(DR_SWAP_CHANGE_DR),\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(PR_SWAP_ACCEPT),\t\t\t\\\n\tS(PR_SWAP_SEND),\t\t\t\\\n\tS(PR_SWAP_SEND_TIMEOUT),\t\t\\\n\tS(PR_SWAP_CANCEL),\t\t\t\\\n\tS(PR_SWAP_START),\t\t\t\\\n\tS(PR_SWAP_SRC_SNK_TRANSITION_OFF),\t\\\n\tS(PR_SWAP_SRC_SNK_SOURCE_OFF),\t\t\\\n\tS(PR_SWAP_SRC_SNK_SOURCE_OFF_CC_DEBOUNCED), \\\n\tS(PR_SWAP_SRC_SNK_SINK_ON),\t\t\\\n\tS(PR_SWAP_SNK_SRC_SINK_OFF),\t\t\\\n\tS(PR_SWAP_SNK_SRC_SOURCE_ON),\t\t\\\n\tS(PR_SWAP_SNK_SRC_SOURCE_ON_VBUS_RAMPED_UP),    \\\n\t\t\t\t\t\t\\\n\tS(VCONN_SWAP_ACCEPT),\t\t\t\\\n\tS(VCONN_SWAP_SEND),\t\t\t\\\n\tS(VCONN_SWAP_SEND_TIMEOUT),\t\t\\\n\tS(VCONN_SWAP_CANCEL),\t\t\t\\\n\tS(VCONN_SWAP_START),\t\t\t\\\n\tS(VCONN_SWAP_WAIT_FOR_VCONN),\t\t\\\n\tS(VCONN_SWAP_TURN_ON_VCONN),\t\t\\\n\tS(VCONN_SWAP_TURN_OFF_VCONN),\t\t\\\n\t\t\t\t\t\t\\\n\tS(FR_SWAP_SEND),\t\t\t\\\n\tS(FR_SWAP_SEND_TIMEOUT),\t\t\\\n\tS(FR_SWAP_SNK_SRC_TRANSITION_TO_OFF),\t\t\t\\\n\tS(FR_SWAP_SNK_SRC_NEW_SINK_READY),\t\t\\\n\tS(FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED),\t\\\n\tS(FR_SWAP_CANCEL),\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(SNK_TRY),\t\t\t\t\\\n\tS(SNK_TRY_WAIT),\t\t\t\\\n\tS(SNK_TRY_WAIT_DEBOUNCE),               \\\n\tS(SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS),    \\\n\tS(SRC_TRYWAIT),\t\t\t\t\\\n\tS(SRC_TRYWAIT_DEBOUNCE),\t\t\\\n\tS(SRC_TRYWAIT_UNATTACHED),\t\t\\\n\t\t\t\t\t\t\\\n\tS(SRC_TRY),\t\t\t\t\\\n\tS(SRC_TRY_WAIT),                        \\\n\tS(SRC_TRY_DEBOUNCE),\t\t\t\\\n\tS(SNK_TRYWAIT),\t\t\t\t\\\n\tS(SNK_TRYWAIT_DEBOUNCE),\t\t\\\n\tS(SNK_TRYWAIT_VBUS),\t\t\t\\\n\tS(BIST_RX),\t\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(GET_STATUS_SEND),\t\t\t\\\n\tS(GET_STATUS_SEND_TIMEOUT),\t\t\\\n\tS(GET_PPS_STATUS_SEND),\t\t\t\\\n\tS(GET_PPS_STATUS_SEND_TIMEOUT),\t\t\\\n\t\t\t\t\t\t\\\n\tS(GET_SINK_CAP),\t\t\t\\\n\tS(GET_SINK_CAP_TIMEOUT),\t\t\\\n\t\t\t\t\t\t\\\n\tS(ERROR_RECOVERY),\t\t\t\\\n\tS(PORT_RESET),\t\t\t\t\\\n\tS(PORT_RESET_WAIT_OFF),\t\t\t\\\n\t\t\t\t\t\t\\\n\tS(AMS_START),\t\t\t\t\\\n\tS(CHUNK_NOT_SUPP)\n\n#define FOREACH_AMS(S)\t\t\t\t\\\n\tS(NONE_AMS),\t\t\t\t\\\n\tS(POWER_NEGOTIATION),\t\t\t\\\n\tS(GOTOMIN),\t\t\t\t\\\n\tS(SOFT_RESET_AMS),\t\t\t\\\n\tS(HARD_RESET),\t\t\t\t\\\n\tS(CABLE_RESET),\t\t\t\t\\\n\tS(GET_SOURCE_CAPABILITIES),\t\t\\\n\tS(GET_SINK_CAPABILITIES),\t\t\\\n\tS(POWER_ROLE_SWAP),\t\t\t\\\n\tS(FAST_ROLE_SWAP),\t\t\t\\\n\tS(DATA_ROLE_SWAP),\t\t\t\\\n\tS(VCONN_SWAP),\t\t\t\t\\\n\tS(SOURCE_ALERT),\t\t\t\\\n\tS(GETTING_SOURCE_EXTENDED_CAPABILITIES),\\\n\tS(GETTING_SOURCE_SINK_STATUS),\t\t\\\n\tS(GETTING_BATTERY_CAPABILITIES),\t\\\n\tS(GETTING_BATTERY_STATUS),\t\t\\\n\tS(GETTING_MANUFACTURER_INFORMATION),\t\\\n\tS(SECURITY),\t\t\t\t\\\n\tS(FIRMWARE_UPDATE),\t\t\t\\\n\tS(DISCOVER_IDENTITY),\t\t\t\\\n\tS(SOURCE_STARTUP_CABLE_PLUG_DISCOVER_IDENTITY),\t\\\n\tS(DISCOVER_SVIDS),\t\t\t\\\n\tS(DISCOVER_MODES),\t\t\t\\\n\tS(DFP_TO_UFP_ENTER_MODE),\t\t\\\n\tS(DFP_TO_UFP_EXIT_MODE),\t\t\\\n\tS(DFP_TO_CABLE_PLUG_ENTER_MODE),\t\\\n\tS(DFP_TO_CABLE_PLUG_EXIT_MODE),\t\t\\\n\tS(ATTENTION),\t\t\t\t\\\n\tS(BIST),\t\t\t\t\\\n\tS(UNSTRUCTURED_VDMS),\t\t\t\\\n\tS(STRUCTURED_VDMS),\t\t\t\\\n\tS(COUNTRY_INFO),\t\t\t\\\n\tS(COUNTRY_CODES)\n\n#define GENERATE_ENUM(e)\te\n#define GENERATE_STRING(s)\t#s\n\nenum tcpm_state {\n\tFOREACH_STATE(GENERATE_ENUM)\n};\n\nstatic const char * const tcpm_states[] = {\n\tFOREACH_STATE(GENERATE_STRING)\n};\n\nenum tcpm_ams {\n\tFOREACH_AMS(GENERATE_ENUM)\n};\n\nstatic const char * const tcpm_ams_str[] = {\n\tFOREACH_AMS(GENERATE_STRING)\n};\n\nenum vdm_states {\n\tVDM_STATE_ERR_BUSY = -3,\n\tVDM_STATE_ERR_SEND = -2,\n\tVDM_STATE_ERR_TMOUT = -1,\n\tVDM_STATE_DONE = 0,\n\t \n\tVDM_STATE_READY = 1,\n\tVDM_STATE_BUSY = 2,\n\tVDM_STATE_WAIT_RSP_BUSY = 3,\n\tVDM_STATE_SEND_MESSAGE = 4,\n};\n\nenum pd_msg_request {\n\tPD_MSG_NONE = 0,\n\tPD_MSG_CTRL_REJECT,\n\tPD_MSG_CTRL_WAIT,\n\tPD_MSG_CTRL_NOT_SUPP,\n\tPD_MSG_DATA_SINK_CAP,\n\tPD_MSG_DATA_SOURCE_CAP,\n};\n\nenum adev_actions {\n\tADEV_NONE = 0,\n\tADEV_NOTIFY_USB_AND_QUEUE_VDM,\n\tADEV_QUEUE_VDM,\n\tADEV_QUEUE_VDM_SEND_EXIT_MODE_ON_FAIL,\n\tADEV_ATTENTION,\n};\n\n \nenum frs_typec_current {\n\tFRS_NOT_SUPPORTED,\n\tFRS_DEFAULT_POWER,\n\tFRS_5V_1P5A,\n\tFRS_5V_3A,\n};\n\n \n\n#define TCPM_CC_EVENT\t\tBIT(0)\n#define TCPM_VBUS_EVENT\t\tBIT(1)\n#define TCPM_RESET_EVENT\tBIT(2)\n#define TCPM_FRS_EVENT\t\tBIT(3)\n#define TCPM_SOURCING_VBUS\tBIT(4)\n#define TCPM_PORT_CLEAN\t\tBIT(5)\n\n#define LOG_BUFFER_ENTRIES\t1024\n#define LOG_BUFFER_ENTRY_SIZE\t128\n\n \n\n#define SVID_DISCOVERY_MAX\t16\n#define ALTMODE_DISCOVERY_MAX\t(SVID_DISCOVERY_MAX * MODE_DISCOVERY_MAX)\n\n#define GET_SINK_CAP_RETRY_MS\t100\n#define SEND_DISCOVER_RETRY_MS\t100\n\nstruct pd_mode_data {\n\tint svid_index;\t\t \n\tint nsvids;\n\tu16 svids[SVID_DISCOVERY_MAX];\n\tint altmodes;\t\t \n\tstruct typec_altmode_desc altmode_desc[ALTMODE_DISCOVERY_MAX];\n};\n\n \nstruct pd_pps_data {\n\tu32 min_volt;\n\tu32 req_min_volt;\n\tu32 max_volt;\n\tu32 req_max_volt;\n\tu32 max_curr;\n\tu32 req_max_curr;\n\tu32 req_out_volt;\n\tu32 req_op_curr;\n\tbool supported;\n\tbool active;\n};\n\nstruct tcpm_port {\n\tstruct device *dev;\n\n\tstruct mutex lock;\t\t \n\tstruct kthread_worker *wq;\n\n\tstruct typec_capability typec_caps;\n\tstruct typec_port *typec_port;\n\n\tstruct tcpc_dev\t*tcpc;\n\tstruct usb_role_switch *role_sw;\n\n\tenum typec_role vconn_role;\n\tenum typec_role pwr_role;\n\tenum typec_data_role data_role;\n\tenum typec_pwr_opmode pwr_opmode;\n\n\tstruct usb_pd_identity partner_ident;\n\tstruct typec_partner_desc partner_desc;\n\tstruct typec_partner *partner;\n\n\tenum typec_cc_status cc_req;\n\tenum typec_cc_status src_rp;\t \n\n\tenum typec_cc_status cc1;\n\tenum typec_cc_status cc2;\n\tenum typec_cc_polarity polarity;\n\n\tbool attached;\n\tbool connected;\n\tbool registered;\n\tbool pd_supported;\n\tenum typec_port_type port_type;\n\n\t \n\tbool vbus_present;\n\n\t \n\tbool vbus_vsafe0v;\n\n\tbool vbus_never_low;\n\tbool vbus_source;\n\tbool vbus_charge;\n\n\t \n\tbool send_discover;\n\tbool op_vsafe5v;\n\n\tint try_role;\n\tint try_snk_count;\n\tint try_src_count;\n\n\tenum pd_msg_request queued_message;\n\n\tenum tcpm_state enter_state;\n\tenum tcpm_state prev_state;\n\tenum tcpm_state state;\n\tenum tcpm_state delayed_state;\n\tktime_t delayed_runtime;\n\tunsigned long delay_ms;\n\n\tspinlock_t pd_event_lock;\n\tu32 pd_events;\n\n\tstruct kthread_work event_work;\n\tstruct hrtimer state_machine_timer;\n\tstruct kthread_work state_machine;\n\tstruct hrtimer vdm_state_machine_timer;\n\tstruct kthread_work vdm_state_machine;\n\tstruct hrtimer enable_frs_timer;\n\tstruct kthread_work enable_frs;\n\tstruct hrtimer send_discover_timer;\n\tstruct kthread_work send_discover_work;\n\tbool state_machine_running;\n\t \n\tbool vdm_sm_running;\n\n\tstruct completion tx_complete;\n\tenum tcpm_transmit_status tx_status;\n\n\tstruct mutex swap_lock;\t\t \n\tbool swap_pending;\n\tbool non_pd_role_swap;\n\tstruct completion swap_complete;\n\tint swap_status;\n\n\tunsigned int negotiated_rev;\n\tunsigned int message_id;\n\tunsigned int caps_count;\n\tunsigned int hard_reset_count;\n\tbool pd_capable;\n\tbool explicit_contract;\n\tunsigned int rx_msgid;\n\n\t \n\tstruct usb_power_delivery *pd;\n\tstruct usb_power_delivery_capabilities *port_source_caps;\n\tstruct usb_power_delivery_capabilities *port_sink_caps;\n\tstruct usb_power_delivery *partner_pd;\n\tstruct usb_power_delivery_capabilities *partner_source_caps;\n\tstruct usb_power_delivery_capabilities *partner_sink_caps;\n\n\t \n\tu32 sink_request;\n\tu32 source_caps[PDO_MAX_OBJECTS];\n\tunsigned int nr_source_caps;\n\tu32 sink_caps[PDO_MAX_OBJECTS];\n\tunsigned int nr_sink_caps;\n\n\t \n\tu32 src_pdo[PDO_MAX_OBJECTS];\n\tunsigned int nr_src_pdo;\n\tu32 snk_pdo[PDO_MAX_OBJECTS];\n\tunsigned int nr_snk_pdo;\n\tu32 snk_vdo_v1[VDO_MAX_OBJECTS];\n\tunsigned int nr_snk_vdo_v1;\n\tu32 snk_vdo[VDO_MAX_OBJECTS];\n\tunsigned int nr_snk_vdo;\n\n\tunsigned int operating_snk_mw;\n\tbool update_sink_caps;\n\n\t \n\tu32 req_current_limit;\n\tu32 req_supply_voltage;\n\t \n\tu32 current_limit;\n\tu32 supply_voltage;\n\n\t \n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tenum power_supply_usb_type usb_type;\n\n\tu32 bist_request;\n\n\t \n\tenum vdm_states vdm_state;\n\tu32 vdm_retries;\n\t \n\tu32 vdo_data[VDO_MAX_SIZE];\n\tu8 vdo_count;\n\t \n\tu32 vdo_retry;\n\n\t \n\tstruct pd_pps_data pps_data;\n\tstruct completion pps_complete;\n\tbool pps_pending;\n\tint pps_status;\n\n\t \n\tstruct pd_mode_data mode_data;\n\tstruct typec_altmode *partner_altmode[ALTMODE_DISCOVERY_MAX];\n\tstruct typec_altmode *port_altmode[ALTMODE_DISCOVERY_MAX];\n\n\t \n\tunsigned long max_wait;\n\n\t \n\tbool self_powered;\n\n\t \n\tenum frs_typec_current new_source_frs_current;\n\n\t \n\tbool sink_cap_done;\n\n\t \n\tenum tcpm_state upcoming_state;\n\tenum tcpm_ams ams;\n\tenum tcpm_ams next_ams;\n\tbool in_ams;\n\n\t \n\tbool auto_vbus_discharge_enabled;\n\n\t \n\tbool slow_charger_loop;\n\n\t \n\tbool potential_contaminant;\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dentry;\n\tstruct mutex logbuffer_lock;\t \n\tint logbuffer_head;\n\tint logbuffer_tail;\n\tu8 *logbuffer[LOG_BUFFER_ENTRIES];\n#endif\n};\n\nstruct pd_rx_event {\n\tstruct kthread_work work;\n\tstruct tcpm_port *port;\n\tstruct pd_message msg;\n};\n\nstatic const char * const pd_rev[] = {\n\t[PD_REV10]\t\t= \"rev1\",\n\t[PD_REV20]\t\t= \"rev2\",\n\t[PD_REV30]\t\t= \"rev3\",\n};\n\n#define tcpm_cc_is_sink(cc) \\\n\t((cc) == TYPEC_CC_RP_DEF || (cc) == TYPEC_CC_RP_1_5 || \\\n\t (cc) == TYPEC_CC_RP_3_0)\n\n#define tcpm_port_is_sink(port) \\\n\t((tcpm_cc_is_sink((port)->cc1) && !tcpm_cc_is_sink((port)->cc2)) || \\\n\t (tcpm_cc_is_sink((port)->cc2) && !tcpm_cc_is_sink((port)->cc1)))\n\n#define tcpm_cc_is_source(cc) ((cc) == TYPEC_CC_RD)\n#define tcpm_cc_is_audio(cc) ((cc) == TYPEC_CC_RA)\n#define tcpm_cc_is_open(cc) ((cc) == TYPEC_CC_OPEN)\n\n#define tcpm_port_is_source(port) \\\n\t((tcpm_cc_is_source((port)->cc1) && \\\n\t !tcpm_cc_is_source((port)->cc2)) || \\\n\t (tcpm_cc_is_source((port)->cc2) && \\\n\t  !tcpm_cc_is_source((port)->cc1)))\n\n#define tcpm_port_is_debug(port) \\\n\t(tcpm_cc_is_source((port)->cc1) && tcpm_cc_is_source((port)->cc2))\n\n#define tcpm_port_is_audio(port) \\\n\t(tcpm_cc_is_audio((port)->cc1) && tcpm_cc_is_audio((port)->cc2))\n\n#define tcpm_port_is_audio_detached(port) \\\n\t((tcpm_cc_is_audio((port)->cc1) && tcpm_cc_is_open((port)->cc2)) || \\\n\t (tcpm_cc_is_audio((port)->cc2) && tcpm_cc_is_open((port)->cc1)))\n\n#define tcpm_try_snk(port) \\\n\t((port)->try_snk_count == 0 && (port)->try_role == TYPEC_SINK && \\\n\t(port)->port_type == TYPEC_PORT_DRP)\n\n#define tcpm_try_src(port) \\\n\t((port)->try_src_count == 0 && (port)->try_role == TYPEC_SOURCE && \\\n\t(port)->port_type == TYPEC_PORT_DRP)\n\n#define tcpm_data_role_for_source(port) \\\n\t((port)->typec_caps.data == TYPEC_PORT_UFP ? \\\n\tTYPEC_DEVICE : TYPEC_HOST)\n\n#define tcpm_data_role_for_sink(port) \\\n\t((port)->typec_caps.data == TYPEC_PORT_DFP ? \\\n\tTYPEC_HOST : TYPEC_DEVICE)\n\n#define tcpm_sink_tx_ok(port) \\\n\t(tcpm_port_is_sink(port) && \\\n\t((port)->cc1 == TYPEC_CC_RP_3_0 || (port)->cc2 == TYPEC_CC_RP_3_0))\n\n#define tcpm_wait_for_discharge(port) \\\n\t(((port)->auto_vbus_discharge_enabled && !(port)->vbus_vsafe0v) ? PD_T_SAFE_0V : 0)\n\nstatic enum tcpm_state tcpm_default_state(struct tcpm_port *port)\n{\n\tif (port->port_type == TYPEC_PORT_DRP) {\n\t\tif (port->try_role == TYPEC_SINK)\n\t\t\treturn SNK_UNATTACHED;\n\t\telse if (port->try_role == TYPEC_SOURCE)\n\t\t\treturn SRC_UNATTACHED;\n\t\t \n\t} else if (port->port_type == TYPEC_PORT_SNK) {\n\t\treturn SNK_UNATTACHED;\n\t}\n\treturn SRC_UNATTACHED;\n}\n\nstatic bool tcpm_port_is_disconnected(struct tcpm_port *port)\n{\n\treturn (!port->attached && port->cc1 == TYPEC_CC_OPEN &&\n\t\tport->cc2 == TYPEC_CC_OPEN) ||\n\t       (port->attached && ((port->polarity == TYPEC_POLARITY_CC1 &&\n\t\t\t\t    port->cc1 == TYPEC_CC_OPEN) ||\n\t\t\t\t   (port->polarity == TYPEC_POLARITY_CC2 &&\n\t\t\t\t    port->cc2 == TYPEC_CC_OPEN)));\n}\n\n \n\n#ifdef CONFIG_DEBUG_FS\n\nstatic bool tcpm_log_full(struct tcpm_port *port)\n{\n\treturn port->logbuffer_tail ==\n\t\t(port->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;\n}\n\n__printf(2, 0)\nstatic void _tcpm_log(struct tcpm_port *port, const char *fmt, va_list args)\n{\n\tchar tmpbuffer[LOG_BUFFER_ENTRY_SIZE];\n\tu64 ts_nsec = local_clock();\n\tunsigned long rem_nsec;\n\n\tmutex_lock(&port->logbuffer_lock);\n\tif (!port->logbuffer[port->logbuffer_head]) {\n\t\tport->logbuffer[port->logbuffer_head] =\n\t\t\t\tkzalloc(LOG_BUFFER_ENTRY_SIZE, GFP_KERNEL);\n\t\tif (!port->logbuffer[port->logbuffer_head]) {\n\t\t\tmutex_unlock(&port->logbuffer_lock);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tvsnprintf(tmpbuffer, sizeof(tmpbuffer), fmt, args);\n\n\tif (tcpm_log_full(port)) {\n\t\tport->logbuffer_head = max(port->logbuffer_head - 1, 0);\n\t\tstrcpy(tmpbuffer, \"overflow\");\n\t}\n\n\tif (port->logbuffer_head < 0 ||\n\t    port->logbuffer_head >= LOG_BUFFER_ENTRIES) {\n\t\tdev_warn(port->dev,\n\t\t\t \"Bad log buffer index %d\\n\", port->logbuffer_head);\n\t\tgoto abort;\n\t}\n\n\tif (!port->logbuffer[port->logbuffer_head]) {\n\t\tdev_warn(port->dev,\n\t\t\t \"Log buffer index %d is NULL\\n\", port->logbuffer_head);\n\t\tgoto abort;\n\t}\n\n\trem_nsec = do_div(ts_nsec, 1000000000);\n\tscnprintf(port->logbuffer[port->logbuffer_head],\n\t\t  LOG_BUFFER_ENTRY_SIZE, \"[%5lu.%06lu] %s\",\n\t\t  (unsigned long)ts_nsec, rem_nsec / 1000,\n\t\t  tmpbuffer);\n\tport->logbuffer_head = (port->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;\n\nabort:\n\tmutex_unlock(&port->logbuffer_lock);\n}\n\n__printf(2, 3)\nstatic void tcpm_log(struct tcpm_port *port, const char *fmt, ...)\n{\n\tva_list args;\n\n\t \n\tif (tcpm_port_is_disconnected(port) &&\n\t    (port->state == SRC_UNATTACHED || port->state == SNK_UNATTACHED ||\n\t     port->state == TOGGLING || port->state == CHECK_CONTAMINANT))\n\t\treturn;\n\n\tva_start(args, fmt);\n\t_tcpm_log(port, fmt, args);\n\tva_end(args);\n}\n\n__printf(2, 3)\nstatic void tcpm_log_force(struct tcpm_port *port, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\t_tcpm_log(port, fmt, args);\n\tva_end(args);\n}\n\nstatic void tcpm_log_source_caps(struct tcpm_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < port->nr_source_caps; i++) {\n\t\tu32 pdo = port->source_caps[i];\n\t\tenum pd_pdo_type type = pdo_type(pdo);\n\t\tchar msg[64];\n\n\t\tswitch (type) {\n\t\tcase PDO_TYPE_FIXED:\n\t\t\tscnprintf(msg, sizeof(msg),\n\t\t\t\t  \"%u mV, %u mA [%s%s%s%s%s%s]\",\n\t\t\t\t  pdo_fixed_voltage(pdo),\n\t\t\t\t  pdo_max_current(pdo),\n\t\t\t\t  (pdo & PDO_FIXED_DUAL_ROLE) ?\n\t\t\t\t\t\t\t\"R\" : \"\",\n\t\t\t\t  (pdo & PDO_FIXED_SUSPEND) ?\n\t\t\t\t\t\t\t\"S\" : \"\",\n\t\t\t\t  (pdo & PDO_FIXED_HIGHER_CAP) ?\n\t\t\t\t\t\t\t\"H\" : \"\",\n\t\t\t\t  (pdo & PDO_FIXED_USB_COMM) ?\n\t\t\t\t\t\t\t\"U\" : \"\",\n\t\t\t\t  (pdo & PDO_FIXED_DATA_SWAP) ?\n\t\t\t\t\t\t\t\"D\" : \"\",\n\t\t\t\t  (pdo & PDO_FIXED_EXTPOWER) ?\n\t\t\t\t\t\t\t\"E\" : \"\");\n\t\t\tbreak;\n\t\tcase PDO_TYPE_VAR:\n\t\t\tscnprintf(msg, sizeof(msg),\n\t\t\t\t  \"%u-%u mV, %u mA\",\n\t\t\t\t  pdo_min_voltage(pdo),\n\t\t\t\t  pdo_max_voltage(pdo),\n\t\t\t\t  pdo_max_current(pdo));\n\t\t\tbreak;\n\t\tcase PDO_TYPE_BATT:\n\t\t\tscnprintf(msg, sizeof(msg),\n\t\t\t\t  \"%u-%u mV, %u mW\",\n\t\t\t\t  pdo_min_voltage(pdo),\n\t\t\t\t  pdo_max_voltage(pdo),\n\t\t\t\t  pdo_max_power(pdo));\n\t\t\tbreak;\n\t\tcase PDO_TYPE_APDO:\n\t\t\tif (pdo_apdo_type(pdo) == APDO_TYPE_PPS)\n\t\t\t\tscnprintf(msg, sizeof(msg),\n\t\t\t\t\t  \"%u-%u mV, %u mA\",\n\t\t\t\t\t  pdo_pps_apdo_min_voltage(pdo),\n\t\t\t\t\t  pdo_pps_apdo_max_voltage(pdo),\n\t\t\t\t\t  pdo_pps_apdo_max_current(pdo));\n\t\t\telse\n\t\t\t\tstrcpy(msg, \"undefined APDO\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(msg, \"undefined\");\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_log(port, \" PDO %d: type %d, %s\",\n\t\t\t i, type, msg);\n\t}\n}\n\nstatic int tcpm_debug_show(struct seq_file *s, void *v)\n{\n\tstruct tcpm_port *port = s->private;\n\tint tail;\n\n\tmutex_lock(&port->logbuffer_lock);\n\ttail = port->logbuffer_tail;\n\twhile (tail != port->logbuffer_head) {\n\t\tseq_printf(s, \"%s\\n\", port->logbuffer[tail]);\n\t\ttail = (tail + 1) % LOG_BUFFER_ENTRIES;\n\t}\n\tif (!seq_has_overflowed(s))\n\t\tport->logbuffer_tail = tail;\n\tmutex_unlock(&port->logbuffer_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(tcpm_debug);\n\nstatic void tcpm_debugfs_init(struct tcpm_port *port)\n{\n\tchar name[NAME_MAX];\n\n\tmutex_init(&port->logbuffer_lock);\n\tsnprintf(name, NAME_MAX, \"tcpm-%s\", dev_name(port->dev));\n\tport->dentry = debugfs_create_dir(name, usb_debug_root);\n\tdebugfs_create_file(\"log\", S_IFREG | 0444, port->dentry, port,\n\t\t\t    &tcpm_debug_fops);\n}\n\nstatic void tcpm_debugfs_exit(struct tcpm_port *port)\n{\n\tint i;\n\n\tmutex_lock(&port->logbuffer_lock);\n\tfor (i = 0; i < LOG_BUFFER_ENTRIES; i++) {\n\t\tkfree(port->logbuffer[i]);\n\t\tport->logbuffer[i] = NULL;\n\t}\n\tmutex_unlock(&port->logbuffer_lock);\n\n\tdebugfs_remove(port->dentry);\n}\n\n#else\n\n__printf(2, 3)\nstatic void tcpm_log(const struct tcpm_port *port, const char *fmt, ...) { }\n__printf(2, 3)\nstatic void tcpm_log_force(struct tcpm_port *port, const char *fmt, ...) { }\nstatic void tcpm_log_source_caps(struct tcpm_port *port) { }\nstatic void tcpm_debugfs_init(const struct tcpm_port *port) { }\nstatic void tcpm_debugfs_exit(const struct tcpm_port *port) { }\n\n#endif\n\nstatic void tcpm_set_cc(struct tcpm_port *port, enum typec_cc_status cc)\n{\n\ttcpm_log(port, \"cc:=%d\", cc);\n\tport->cc_req = cc;\n\tport->tcpc->set_cc(port->tcpc, cc);\n}\n\nstatic int tcpm_enable_auto_vbus_discharge(struct tcpm_port *port, bool enable)\n{\n\tint ret = 0;\n\n\tif (port->tcpc->enable_auto_vbus_discharge) {\n\t\tret = port->tcpc->enable_auto_vbus_discharge(port->tcpc, enable);\n\t\ttcpm_log_force(port, \"%s vbus discharge ret:%d\", enable ? \"enable\" : \"disable\",\n\t\t\t       ret);\n\t\tif (!ret)\n\t\t\tport->auto_vbus_discharge_enabled = enable;\n\t}\n\n\treturn ret;\n}\n\nstatic void tcpm_apply_rc(struct tcpm_port *port)\n{\n\t \n\tif (port->tcpc->enable_auto_vbus_discharge && port->tcpc->apply_rc) {\n\t\ttcpm_log(port, \"Apply_RC\");\n\t\tport->tcpc->apply_rc(port->tcpc, port->cc_req, port->polarity);\n\t\ttcpm_enable_auto_vbus_discharge(port, false);\n\t}\n}\n\n \nstatic enum typec_cc_status tcpm_rp_cc(struct tcpm_port *port)\n{\n\tconst u32 *src_pdo = port->src_pdo;\n\tint nr_pdo = port->nr_src_pdo;\n\tint i;\n\n\tif (!port->pd_supported)\n\t\treturn port->src_rp;\n\n\t \n\tfor (i = 0; i < nr_pdo; i++) {\n\t\tconst u32 pdo = src_pdo[i];\n\n\t\tif (pdo_type(pdo) == PDO_TYPE_FIXED &&\n\t\t    pdo_fixed_voltage(pdo) == 5000) {\n\t\t\tunsigned int curr = pdo_max_current(pdo);\n\n\t\t\tif (curr >= 3000)\n\t\t\t\treturn TYPEC_CC_RP_3_0;\n\t\t\telse if (curr >= 1500)\n\t\t\t\treturn TYPEC_CC_RP_1_5;\n\t\t\treturn TYPEC_CC_RP_DEF;\n\t\t}\n\t}\n\n\treturn TYPEC_CC_RP_DEF;\n}\n\nstatic void tcpm_ams_finish(struct tcpm_port *port)\n{\n\ttcpm_log(port, \"AMS %s finished\", tcpm_ams_str[port->ams]);\n\n\tif (port->pd_capable && port->pwr_role == TYPEC_SOURCE) {\n\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\ttcpm_set_cc(port, SINK_TX_OK);\n\t\telse\n\t\t\ttcpm_set_cc(port, SINK_TX_NG);\n\t} else if (port->pwr_role == TYPEC_SOURCE) {\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t}\n\n\tport->in_ams = false;\n\tport->ams = NONE_AMS;\n}\n\nstatic int tcpm_pd_transmit(struct tcpm_port *port,\n\t\t\t    enum tcpm_transmit_type type,\n\t\t\t    const struct pd_message *msg)\n{\n\tunsigned long timeout;\n\tint ret;\n\n\tif (msg)\n\t\ttcpm_log(port, \"PD TX, header: %#x\", le16_to_cpu(msg->header));\n\telse\n\t\ttcpm_log(port, \"PD TX, type: %#x\", type);\n\n\treinit_completion(&port->tx_complete);\n\tret = port->tcpc->pd_transmit(port->tcpc, type, msg, port->negotiated_rev);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_unlock(&port->lock);\n\ttimeout = wait_for_completion_timeout(&port->tx_complete,\n\t\t\t\tmsecs_to_jiffies(PD_T_TCPC_TX_TIMEOUT));\n\tmutex_lock(&port->lock);\n\tif (!timeout)\n\t\treturn -ETIMEDOUT;\n\n\tswitch (port->tx_status) {\n\tcase TCPC_TX_SUCCESS:\n\t\tport->message_id = (port->message_id + 1) & PD_HEADER_ID_MASK;\n\t\t \n\t\tif (port->ams != NONE_AMS)\n\t\t\tport->in_ams = true;\n\t\tbreak;\n\tcase TCPC_TX_DISCARDED:\n\t\tret = -EAGAIN;\n\t\tbreak;\n\tcase TCPC_TX_FAILED:\n\tdefault:\n\t\tret = -EIO;\n\t\tbreak;\n\t}\n\n\t \n\tif (port->ams == ATTENTION || port->ams == SOURCE_ALERT)\n\t\ttcpm_ams_finish(port);\n\n\treturn ret;\n}\n\nvoid tcpm_pd_transmit_complete(struct tcpm_port *port,\n\t\t\t       enum tcpm_transmit_status status)\n{\n\ttcpm_log(port, \"PD TX complete, status: %u\", status);\n\tport->tx_status = status;\n\tcomplete(&port->tx_complete);\n}\nEXPORT_SYMBOL_GPL(tcpm_pd_transmit_complete);\n\nstatic int tcpm_mux_set(struct tcpm_port *port, int state,\n\t\t\tenum usb_role usb_role,\n\t\t\tenum typec_orientation orientation)\n{\n\tint ret;\n\n\ttcpm_log(port, \"Requesting mux state %d, usb-role %d, orientation %d\",\n\t\t state, usb_role, orientation);\n\n\tret = typec_set_orientation(port->typec_port, orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tif (port->role_sw) {\n\t\tret = usb_role_switch_set_role(port->role_sw, usb_role);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn typec_set_mode(port->typec_port, state);\n}\n\nstatic int tcpm_set_polarity(struct tcpm_port *port,\n\t\t\t     enum typec_cc_polarity polarity)\n{\n\tint ret;\n\n\ttcpm_log(port, \"polarity %d\", polarity);\n\n\tret = port->tcpc->set_polarity(port->tcpc, polarity);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->polarity = polarity;\n\n\treturn 0;\n}\n\nstatic int tcpm_set_vconn(struct tcpm_port *port, bool enable)\n{\n\tint ret;\n\n\ttcpm_log(port, \"vconn:=%d\", enable);\n\n\tret = port->tcpc->set_vconn(port->tcpc, enable);\n\tif (!ret) {\n\t\tport->vconn_role = enable ? TYPEC_SOURCE : TYPEC_SINK;\n\t\ttypec_set_vconn_role(port->typec_port, port->vconn_role);\n\t}\n\n\treturn ret;\n}\n\nstatic u32 tcpm_get_current_limit(struct tcpm_port *port)\n{\n\tenum typec_cc_status cc;\n\tu32 limit;\n\n\tcc = port->polarity ? port->cc2 : port->cc1;\n\tswitch (cc) {\n\tcase TYPEC_CC_RP_1_5:\n\t\tlimit = 1500;\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\tlimit = 3000;\n\t\tbreak;\n\tcase TYPEC_CC_RP_DEF:\n\tdefault:\n\t\tif (port->tcpc->get_current_limit)\n\t\t\tlimit = port->tcpc->get_current_limit(port->tcpc);\n\t\telse\n\t\t\tlimit = 0;\n\t\tbreak;\n\t}\n\n\treturn limit;\n}\n\nstatic int tcpm_set_current_limit(struct tcpm_port *port, u32 max_ma, u32 mv)\n{\n\tint ret = -EOPNOTSUPP;\n\n\ttcpm_log(port, \"Setting voltage/current limit %u mV %u mA\", mv, max_ma);\n\n\tport->supply_voltage = mv;\n\tport->current_limit = max_ma;\n\tpower_supply_changed(port->psy);\n\n\tif (port->tcpc->set_current_limit)\n\t\tret = port->tcpc->set_current_limit(port->tcpc, max_ma, mv);\n\n\treturn ret;\n}\n\nstatic int tcpm_set_attached_state(struct tcpm_port *port, bool attached)\n{\n\treturn port->tcpc->set_roles(port->tcpc, attached, port->pwr_role,\n\t\t\t\t     port->data_role);\n}\n\nstatic int tcpm_set_roles(struct tcpm_port *port, bool attached,\n\t\t\t  enum typec_role role, enum typec_data_role data)\n{\n\tenum typec_orientation orientation;\n\tenum usb_role usb_role;\n\tint ret;\n\n\tif (port->polarity == TYPEC_POLARITY_CC1)\n\t\torientation = TYPEC_ORIENTATION_NORMAL;\n\telse\n\t\torientation = TYPEC_ORIENTATION_REVERSE;\n\n\tif (port->typec_caps.data == TYPEC_PORT_DRD) {\n\t\tif (data == TYPEC_HOST)\n\t\t\tusb_role = USB_ROLE_HOST;\n\t\telse\n\t\t\tusb_role = USB_ROLE_DEVICE;\n\t} else if (port->typec_caps.data == TYPEC_PORT_DFP) {\n\t\tif (data == TYPEC_HOST) {\n\t\t\tif (role == TYPEC_SOURCE)\n\t\t\t\tusb_role = USB_ROLE_HOST;\n\t\t\telse\n\t\t\t\tusb_role = USB_ROLE_NONE;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t} else {\n\t\tif (data == TYPEC_DEVICE) {\n\t\t\tif (role == TYPEC_SINK)\n\t\t\t\tusb_role = USB_ROLE_DEVICE;\n\t\t\telse\n\t\t\t\tusb_role = USB_ROLE_NONE;\n\t\t} else {\n\t\t\treturn -ENOTSUPP;\n\t\t}\n\t}\n\n\tret = tcpm_mux_set(port, TYPEC_STATE_USB, usb_role, orientation);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = port->tcpc->set_roles(port->tcpc, attached, role, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->pwr_role = role;\n\tport->data_role = data;\n\ttypec_set_data_role(port->typec_port, data);\n\ttypec_set_pwr_role(port->typec_port, role);\n\n\treturn 0;\n}\n\nstatic int tcpm_set_pwr_role(struct tcpm_port *port, enum typec_role role)\n{\n\tint ret;\n\n\tret = port->tcpc->set_roles(port->tcpc, true, role,\n\t\t\t\t    port->data_role);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->pwr_role = role;\n\ttypec_set_pwr_role(port->typec_port, role);\n\n\treturn 0;\n}\n\n \nstatic u32 tcpm_forge_legacy_pdo(struct tcpm_port *port, u32 pdo, enum typec_role role)\n{\n\tswitch (pdo_type(pdo)) {\n\tcase PDO_TYPE_FIXED:\n\t\tif (role == TYPEC_SINK)\n\t\t\treturn pdo & ~PDO_FIXED_FRS_CURR_MASK;\n\t\telse\n\t\t\treturn pdo & ~PDO_FIXED_UNCHUNK_EXT;\n\tcase PDO_TYPE_VAR:\n\tcase PDO_TYPE_BATT:\n\t\treturn pdo;\n\tcase PDO_TYPE_APDO:\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic int tcpm_pd_send_source_caps(struct tcpm_port *port)\n{\n\tstruct pd_message msg;\n\tu32 pdo;\n\tunsigned int i, nr_pdo = 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tfor (i = 0; i < port->nr_src_pdo; i++) {\n\t\tif (port->negotiated_rev >= PD_REV30) {\n\t\t\tmsg.payload[nr_pdo++] =\tcpu_to_le32(port->src_pdo[i]);\n\t\t} else {\n\t\t\tpdo = tcpm_forge_legacy_pdo(port, port->src_pdo[i], TYPEC_SOURCE);\n\t\t\tif (pdo)\n\t\t\t\tmsg.payload[nr_pdo++] = cpu_to_le32(pdo);\n\t\t}\n\t}\n\n\tif (!nr_pdo) {\n\t\t \n\t\tmsg.header = PD_HEADER_LE(PD_CTRL_REJECT,\n\t\t\t\t\t  port->pwr_role,\n\t\t\t\t\t  port->data_role,\n\t\t\t\t\t  port->negotiated_rev,\n\t\t\t\t\t  port->message_id, 0);\n\t} else {\n\t\tmsg.header = PD_HEADER_LE(PD_DATA_SOURCE_CAP,\n\t\t\t\t\t  port->pwr_role,\n\t\t\t\t\t  port->data_role,\n\t\t\t\t\t  port->negotiated_rev,\n\t\t\t\t\t  port->message_id,\n\t\t\t\t\t  nr_pdo);\n\t}\n\n\treturn tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n}\n\nstatic int tcpm_pd_send_sink_caps(struct tcpm_port *port)\n{\n\tstruct pd_message msg;\n\tu32 pdo;\n\tunsigned int i, nr_pdo = 0;\n\n\tmemset(&msg, 0, sizeof(msg));\n\n\tfor (i = 0; i < port->nr_snk_pdo; i++) {\n\t\tif (port->negotiated_rev >= PD_REV30) {\n\t\t\tmsg.payload[nr_pdo++] =\tcpu_to_le32(port->snk_pdo[i]);\n\t\t} else {\n\t\t\tpdo = tcpm_forge_legacy_pdo(port, port->snk_pdo[i], TYPEC_SINK);\n\t\t\tif (pdo)\n\t\t\t\tmsg.payload[nr_pdo++] = cpu_to_le32(pdo);\n\t\t}\n\t}\n\n\tif (!nr_pdo) {\n\t\t \n\t\tmsg.header = PD_HEADER_LE(PD_CTRL_REJECT,\n\t\t\t\t\t  port->pwr_role,\n\t\t\t\t\t  port->data_role,\n\t\t\t\t\t  port->negotiated_rev,\n\t\t\t\t\t  port->message_id, 0);\n\t} else {\n\t\tmsg.header = PD_HEADER_LE(PD_DATA_SINK_CAP,\n\t\t\t\t\t  port->pwr_role,\n\t\t\t\t\t  port->data_role,\n\t\t\t\t\t  port->negotiated_rev,\n\t\t\t\t\t  port->message_id,\n\t\t\t\t\t  nr_pdo);\n\t}\n\n\treturn tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n}\n\nstatic void mod_tcpm_delayed_work(struct tcpm_port *port, unsigned int delay_ms)\n{\n\tif (delay_ms) {\n\t\thrtimer_start(&port->state_machine_timer, ms_to_ktime(delay_ms), HRTIMER_MODE_REL);\n\t} else {\n\t\thrtimer_cancel(&port->state_machine_timer);\n\t\tkthread_queue_work(port->wq, &port->state_machine);\n\t}\n}\n\nstatic void mod_vdm_delayed_work(struct tcpm_port *port, unsigned int delay_ms)\n{\n\tif (delay_ms) {\n\t\thrtimer_start(&port->vdm_state_machine_timer, ms_to_ktime(delay_ms),\n\t\t\t      HRTIMER_MODE_REL);\n\t} else {\n\t\thrtimer_cancel(&port->vdm_state_machine_timer);\n\t\tkthread_queue_work(port->wq, &port->vdm_state_machine);\n\t}\n}\n\nstatic void mod_enable_frs_delayed_work(struct tcpm_port *port, unsigned int delay_ms)\n{\n\tif (delay_ms) {\n\t\thrtimer_start(&port->enable_frs_timer, ms_to_ktime(delay_ms), HRTIMER_MODE_REL);\n\t} else {\n\t\thrtimer_cancel(&port->enable_frs_timer);\n\t\tkthread_queue_work(port->wq, &port->enable_frs);\n\t}\n}\n\nstatic void mod_send_discover_delayed_work(struct tcpm_port *port, unsigned int delay_ms)\n{\n\tif (delay_ms) {\n\t\thrtimer_start(&port->send_discover_timer, ms_to_ktime(delay_ms), HRTIMER_MODE_REL);\n\t} else {\n\t\thrtimer_cancel(&port->send_discover_timer);\n\t\tkthread_queue_work(port->wq, &port->send_discover_work);\n\t}\n}\n\nstatic void tcpm_set_state(struct tcpm_port *port, enum tcpm_state state,\n\t\t\t   unsigned int delay_ms)\n{\n\tif (delay_ms) {\n\t\ttcpm_log(port, \"pending state change %s -> %s @ %u ms [%s %s]\",\n\t\t\t tcpm_states[port->state], tcpm_states[state], delay_ms,\n\t\t\t pd_rev[port->negotiated_rev], tcpm_ams_str[port->ams]);\n\t\tport->delayed_state = state;\n\t\tmod_tcpm_delayed_work(port, delay_ms);\n\t\tport->delayed_runtime = ktime_add(ktime_get(), ms_to_ktime(delay_ms));\n\t\tport->delay_ms = delay_ms;\n\t} else {\n\t\ttcpm_log(port, \"state change %s -> %s [%s %s]\",\n\t\t\t tcpm_states[port->state], tcpm_states[state],\n\t\t\t pd_rev[port->negotiated_rev], tcpm_ams_str[port->ams]);\n\t\tport->delayed_state = INVALID_STATE;\n\t\tport->prev_state = port->state;\n\t\tport->state = state;\n\t\t \n\t\tif (!port->state_machine_running)\n\t\t\tmod_tcpm_delayed_work(port, 0);\n\t}\n}\n\nstatic void tcpm_set_state_cond(struct tcpm_port *port, enum tcpm_state state,\n\t\t\t\tunsigned int delay_ms)\n{\n\tif (port->enter_state == port->state)\n\t\ttcpm_set_state(port, state, delay_ms);\n\telse\n\t\ttcpm_log(port,\n\t\t\t \"skipped %sstate change %s -> %s [%u ms], context state %s [%s %s]\",\n\t\t\t delay_ms ? \"delayed \" : \"\",\n\t\t\t tcpm_states[port->state], tcpm_states[state],\n\t\t\t delay_ms, tcpm_states[port->enter_state],\n\t\t\t pd_rev[port->negotiated_rev], tcpm_ams_str[port->ams]);\n}\n\nstatic void tcpm_queue_message(struct tcpm_port *port,\n\t\t\t       enum pd_msg_request message)\n{\n\tport->queued_message = message;\n\tmod_tcpm_delayed_work(port, 0);\n}\n\nstatic bool tcpm_vdm_ams(struct tcpm_port *port)\n{\n\tswitch (port->ams) {\n\tcase DISCOVER_IDENTITY:\n\tcase SOURCE_STARTUP_CABLE_PLUG_DISCOVER_IDENTITY:\n\tcase DISCOVER_SVIDS:\n\tcase DISCOVER_MODES:\n\tcase DFP_TO_UFP_ENTER_MODE:\n\tcase DFP_TO_UFP_EXIT_MODE:\n\tcase DFP_TO_CABLE_PLUG_ENTER_MODE:\n\tcase DFP_TO_CABLE_PLUG_EXIT_MODE:\n\tcase ATTENTION:\n\tcase UNSTRUCTURED_VDMS:\n\tcase STRUCTURED_VDMS:\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool tcpm_ams_interruptible(struct tcpm_port *port)\n{\n\tswitch (port->ams) {\n\t \n\tcase NONE_AMS:\n\tcase SECURITY:\n\tcase FIRMWARE_UPDATE:\n\tcase DISCOVER_IDENTITY:\n\tcase SOURCE_STARTUP_CABLE_PLUG_DISCOVER_IDENTITY:\n\tcase DISCOVER_SVIDS:\n\tcase DISCOVER_MODES:\n\tcase DFP_TO_UFP_ENTER_MODE:\n\tcase DFP_TO_UFP_EXIT_MODE:\n\tcase DFP_TO_CABLE_PLUG_ENTER_MODE:\n\tcase DFP_TO_CABLE_PLUG_EXIT_MODE:\n\tcase UNSTRUCTURED_VDMS:\n\tcase STRUCTURED_VDMS:\n\tcase COUNTRY_INFO:\n\tcase COUNTRY_CODES:\n\t\tbreak;\n\t \n\tdefault:\n\t\tif (port->in_ams)\n\t\t\treturn false;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic int tcpm_ams_start(struct tcpm_port *port, enum tcpm_ams ams)\n{\n\tint ret = 0;\n\n\ttcpm_log(port, \"AMS %s start\", tcpm_ams_str[ams]);\n\n\tif (!tcpm_ams_interruptible(port) &&\n\t    !(ams == HARD_RESET || ams == SOFT_RESET_AMS)) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\ttcpm_log(port, \"AMS %s not interruptible, aborting\",\n\t\t\t tcpm_ams_str[port->ams]);\n\t\treturn -EAGAIN;\n\t}\n\n\tif (port->pwr_role == TYPEC_SOURCE) {\n\t\tenum typec_cc_status cc_req = port->cc_req;\n\n\t\tport->ams = ams;\n\n\t\tif (ams == HARD_RESET) {\n\t\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\t\ttcpm_pd_transmit(port, TCPC_TX_HARD_RESET, NULL);\n\t\t\ttcpm_set_state(port, HARD_RESET_START, 0);\n\t\t\treturn ret;\n\t\t} else if (ams == SOFT_RESET_AMS) {\n\t\t\tif (!port->explicit_contract)\n\t\t\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\t\ttcpm_set_state(port, SOFT_RESET_SEND, 0);\n\t\t\treturn ret;\n\t\t} else if (tcpm_vdm_ams(port)) {\n\t\t\t \n\t\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\t\ttcpm_set_cc(port, SINK_TX_NG);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\ttcpm_set_cc(port, SINK_TX_NG);\n\n\t\tswitch (port->state) {\n\t\tcase SRC_READY:\n\t\tcase SRC_STARTUP:\n\t\tcase SRC_SOFT_RESET_WAIT_SNK_TX:\n\t\tcase SOFT_RESET:\n\t\tcase SOFT_RESET_SEND:\n\t\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\t\ttcpm_set_state(port, AMS_START,\n\t\t\t\t\t       cc_req == SINK_TX_OK ?\n\t\t\t\t\t       PD_T_SINK_TX : 0);\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, AMS_START, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\t\ttcpm_set_state(port, SRC_READY,\n\t\t\t\t\t       cc_req == SINK_TX_OK ?\n\t\t\t\t\t       PD_T_SINK_TX : 0);\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tif (port->negotiated_rev >= PD_REV30 &&\n\t\t    !tcpm_sink_tx_ok(port) &&\n\t\t    ams != SOFT_RESET_AMS &&\n\t\t    ams != HARD_RESET) {\n\t\t\tport->upcoming_state = INVALID_STATE;\n\t\t\ttcpm_log(port, \"Sink TX No Go\");\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\tport->ams = ams;\n\n\t\tif (ams == HARD_RESET) {\n\t\t\ttcpm_pd_transmit(port, TCPC_TX_HARD_RESET, NULL);\n\t\t\ttcpm_set_state(port, HARD_RESET_START, 0);\n\t\t\treturn ret;\n\t\t} else if (tcpm_vdm_ams(port)) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port->state == SNK_READY ||\n\t\t    port->state == SNK_SOFT_RESET)\n\t\t\ttcpm_set_state(port, AMS_START, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t}\n\n\treturn ret;\n}\n\n \nstatic void tcpm_queue_vdm(struct tcpm_port *port, const u32 header,\n\t\t\t   const u32 *data, int cnt)\n{\n\tu32 vdo_hdr = port->vdo_data[0];\n\n\tWARN_ON(!mutex_is_locked(&port->lock));\n\n\t \n\tif (PD_VDO_SVDM(vdo_hdr) && PD_VDO_CMD(vdo_hdr) == CMD_DISCOVER_IDENT) {\n\t\tport->send_discover = true;\n\t\tmod_send_discover_delayed_work(port, SEND_DISCOVER_RETRY_MS);\n\t} else {\n\t\t \n\t\tWARN_ON(port->vdm_state > VDM_STATE_DONE);\n\t}\n\n\tport->vdo_count = cnt + 1;\n\tport->vdo_data[0] = header;\n\tmemcpy(&port->vdo_data[1], data, sizeof(u32) * cnt);\n\t \n\tport->vdm_retries = 0;\n\tport->vdm_state = VDM_STATE_READY;\n\tport->vdm_sm_running = true;\n\n\tmod_vdm_delayed_work(port, 0);\n}\n\nstatic void tcpm_queue_vdm_unlocked(struct tcpm_port *port, const u32 header,\n\t\t\t\t    const u32 *data, int cnt)\n{\n\tmutex_lock(&port->lock);\n\ttcpm_queue_vdm(port, header, data, cnt);\n\tmutex_unlock(&port->lock);\n}\n\nstatic void svdm_consume_identity(struct tcpm_port *port, const u32 *p, int cnt)\n{\n\tu32 vdo = p[VDO_INDEX_IDH];\n\tu32 product = p[VDO_INDEX_PRODUCT];\n\n\tmemset(&port->mode_data, 0, sizeof(port->mode_data));\n\n\tport->partner_ident.id_header = vdo;\n\tport->partner_ident.cert_stat = p[VDO_INDEX_CSTAT];\n\tport->partner_ident.product = product;\n\n\ttypec_partner_set_identity(port->partner);\n\n\ttcpm_log(port, \"Identity: %04x:%04x.%04x\",\n\t\t PD_IDH_VID(vdo),\n\t\t PD_PRODUCT_PID(product), product & 0xffff);\n}\n\nstatic bool svdm_consume_svids(struct tcpm_port *port, const u32 *p, int cnt)\n{\n\tstruct pd_mode_data *pmdata = &port->mode_data;\n\tint i;\n\n\tfor (i = 1; i < cnt; i++) {\n\t\tu16 svid;\n\n\t\tsvid = (p[i] >> 16) & 0xffff;\n\t\tif (!svid)\n\t\t\treturn false;\n\n\t\tif (pmdata->nsvids >= SVID_DISCOVERY_MAX)\n\t\t\tgoto abort;\n\n\t\tpmdata->svids[pmdata->nsvids++] = svid;\n\t\ttcpm_log(port, \"SVID %d: 0x%x\", pmdata->nsvids, svid);\n\n\t\tsvid = p[i] & 0xffff;\n\t\tif (!svid)\n\t\t\treturn false;\n\n\t\tif (pmdata->nsvids >= SVID_DISCOVERY_MAX)\n\t\t\tgoto abort;\n\n\t\tpmdata->svids[pmdata->nsvids++] = svid;\n\t\ttcpm_log(port, \"SVID %d: 0x%x\", pmdata->nsvids, svid);\n\t}\n\n\t \n\treturn cnt == 7;\nabort:\n\ttcpm_log(port, \"SVID_DISCOVERY_MAX(%d) too low!\", SVID_DISCOVERY_MAX);\n\treturn false;\n}\n\nstatic void svdm_consume_modes(struct tcpm_port *port, const u32 *p, int cnt)\n{\n\tstruct pd_mode_data *pmdata = &port->mode_data;\n\tstruct typec_altmode_desc *paltmode;\n\tint i;\n\n\tif (pmdata->altmodes >= ARRAY_SIZE(port->partner_altmode)) {\n\t\t \n\t\treturn;\n\t}\n\n\tfor (i = 1; i < cnt; i++) {\n\t\tpaltmode = &pmdata->altmode_desc[pmdata->altmodes];\n\t\tmemset(paltmode, 0, sizeof(*paltmode));\n\n\t\tpaltmode->svid = pmdata->svids[pmdata->svid_index];\n\t\tpaltmode->mode = i;\n\t\tpaltmode->vdo = p[i];\n\n\t\ttcpm_log(port, \" Alternate mode %d: SVID 0x%04x, VDO %d: 0x%08x\",\n\t\t\t pmdata->altmodes, paltmode->svid,\n\t\t\t paltmode->mode, paltmode->vdo);\n\n\t\tpmdata->altmodes++;\n\t}\n}\n\nstatic void tcpm_register_partner_altmodes(struct tcpm_port *port)\n{\n\tstruct pd_mode_data *modep = &port->mode_data;\n\tstruct typec_altmode *altmode;\n\tint i;\n\n\tfor (i = 0; i < modep->altmodes; i++) {\n\t\taltmode = typec_partner_register_altmode(port->partner,\n\t\t\t\t\t\t&modep->altmode_desc[i]);\n\t\tif (IS_ERR(altmode)) {\n\t\t\ttcpm_log(port, \"Failed to register partner SVID 0x%04x\",\n\t\t\t\t modep->altmode_desc[i].svid);\n\t\t\taltmode = NULL;\n\t\t}\n\t\tport->partner_altmode[i] = altmode;\n\t}\n}\n\n#define supports_modal(port)\tPD_IDH_MODAL_SUPP((port)->partner_ident.id_header)\n\nstatic int tcpm_pd_svdm(struct tcpm_port *port, struct typec_altmode *adev,\n\t\t\tconst u32 *p, int cnt, u32 *response,\n\t\t\tenum adev_actions *adev_action)\n{\n\tstruct typec_port *typec = port->typec_port;\n\tstruct typec_altmode *pdev;\n\tstruct pd_mode_data *modep;\n\tint svdm_version;\n\tint rlen = 0;\n\tint cmd_type;\n\tint cmd;\n\tint i;\n\n\tcmd_type = PD_VDO_CMDT(p[0]);\n\tcmd = PD_VDO_CMD(p[0]);\n\n\ttcpm_log(port, \"Rx VDM cmd 0x%x type %d cmd %d len %d\",\n\t\t p[0], cmd_type, cmd, cnt);\n\n\tmodep = &port->mode_data;\n\n\tpdev = typec_match_altmode(port->partner_altmode, ALTMODE_DISCOVERY_MAX,\n\t\t\t\t   PD_VDO_VID(p[0]), PD_VDO_OPOS(p[0]));\n\n\tsvdm_version = typec_get_negotiated_svdm_version(typec);\n\tif (svdm_version < 0)\n\t\treturn 0;\n\n\tswitch (cmd_type) {\n\tcase CMDT_INIT:\n\t\tswitch (cmd) {\n\t\tcase CMD_DISCOVER_IDENT:\n\t\t\tif (PD_VDO_VID(p[0]) != USB_SID_PD)\n\t\t\t\tbreak;\n\n\t\t\tif (IS_ERR_OR_NULL(port->partner))\n\t\t\t\tbreak;\n\n\t\t\tif (PD_VDO_SVDM_VER(p[0]) < svdm_version) {\n\t\t\t\ttypec_partner_set_svdm_version(port->partner,\n\t\t\t\t\t\t\t       PD_VDO_SVDM_VER(p[0]));\n\t\t\t\tsvdm_version = PD_VDO_SVDM_VER(p[0]);\n\t\t\t}\n\n\t\t\tport->ams = DISCOVER_IDENTITY;\n\t\t\t \n\t\t\tif ((port->data_role == TYPEC_DEVICE || svdm_version >= SVDM_VER_2_0) &&\n\t\t\t    port->nr_snk_vdo) {\n\t\t\t\tif (svdm_version < SVDM_VER_2_0) {\n\t\t\t\t\tfor (i = 0; i < port->nr_snk_vdo_v1; i++)\n\t\t\t\t\t\tresponse[i + 1] = port->snk_vdo_v1[i];\n\t\t\t\t\trlen = port->nr_snk_vdo_v1 + 1;\n\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < port->nr_snk_vdo; i++)\n\t\t\t\t\t\tresponse[i + 1] = port->snk_vdo[i];\n\t\t\t\t\trlen = port->nr_snk_vdo + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_DISCOVER_SVID:\n\t\t\tport->ams = DISCOVER_SVIDS;\n\t\t\tbreak;\n\t\tcase CMD_DISCOVER_MODES:\n\t\t\tport->ams = DISCOVER_MODES;\n\t\t\tbreak;\n\t\tcase CMD_ENTER_MODE:\n\t\t\tport->ams = DFP_TO_UFP_ENTER_MODE;\n\t\t\tbreak;\n\t\tcase CMD_EXIT_MODE:\n\t\t\tport->ams = DFP_TO_UFP_EXIT_MODE;\n\t\t\tbreak;\n\t\tcase CMD_ATTENTION:\n\t\t\t \n\t\t\t*adev_action = ADEV_ATTENTION;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (rlen >= 1) {\n\t\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_ACK);\n\t\t} else if (rlen == 0) {\n\t\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_NAK);\n\t\t\trlen = 1;\n\t\t} else {\n\t\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_BUSY);\n\t\t\trlen = 1;\n\t\t}\n\t\tresponse[0] = (response[0] & ~VDO_SVDM_VERS_MASK) |\n\t\t\t      (VDO_SVDM_VERS(typec_get_negotiated_svdm_version(typec)));\n\t\tbreak;\n\tcase CMDT_RSP_ACK:\n\t\t \n\t\tif (IS_ERR_OR_NULL(port->partner))\n\t\t\tbreak;\n\n\t\ttcpm_ams_finish(port);\n\n\t\tswitch (cmd) {\n\t\tcase CMD_DISCOVER_IDENT:\n\t\t\tif (PD_VDO_SVDM_VER(p[0]) < svdm_version)\n\t\t\t\ttypec_partner_set_svdm_version(port->partner,\n\t\t\t\t\t\t\t       PD_VDO_SVDM_VER(p[0]));\n\t\t\t \n\t\t\tsvdm_consume_identity(port, p, cnt);\n\t\t\tresponse[0] = VDO(USB_SID_PD, 1, typec_get_negotiated_svdm_version(typec),\n\t\t\t\t\t  CMD_DISCOVER_SVID);\n\t\t\trlen = 1;\n\t\t\tbreak;\n\t\tcase CMD_DISCOVER_SVID:\n\t\t\t \n\t\t\tif (svdm_consume_svids(port, p, cnt)) {\n\t\t\t\tresponse[0] = VDO(USB_SID_PD, 1, svdm_version, CMD_DISCOVER_SVID);\n\t\t\t\trlen = 1;\n\t\t\t} else if (modep->nsvids && supports_modal(port)) {\n\t\t\t\tresponse[0] = VDO(modep->svids[0], 1, svdm_version,\n\t\t\t\t\t\t  CMD_DISCOVER_MODES);\n\t\t\t\trlen = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_DISCOVER_MODES:\n\t\t\t \n\t\t\tsvdm_consume_modes(port, p, cnt);\n\t\t\tmodep->svid_index++;\n\t\t\tif (modep->svid_index < modep->nsvids) {\n\t\t\t\tu16 svid = modep->svids[modep->svid_index];\n\t\t\t\tresponse[0] = VDO(svid, 1, svdm_version, CMD_DISCOVER_MODES);\n\t\t\t\trlen = 1;\n\t\t\t} else {\n\t\t\t\ttcpm_register_partner_altmodes(port);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMD_ENTER_MODE:\n\t\t\tif (adev && pdev)\n\t\t\t\t*adev_action = ADEV_QUEUE_VDM_SEND_EXIT_MODE_ON_FAIL;\n\t\t\treturn 0;\n\t\tcase CMD_EXIT_MODE:\n\t\t\tif (adev && pdev) {\n\t\t\t\t \n\t\t\t\t*adev_action = ADEV_NOTIFY_USB_AND_QUEUE_VDM;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase VDO_CMD_VENDOR(0) ... VDO_CMD_VENDOR(15):\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t \n\t\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_NAK);\n\t\t\trlen = 1;\n\t\t\tresponse[0] = (response[0] & ~VDO_SVDM_VERS_MASK) |\n\t\t\t\t      (VDO_SVDM_VERS(svdm_version));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CMDT_RSP_NAK:\n\t\ttcpm_ams_finish(port);\n\t\tswitch (cmd) {\n\t\tcase CMD_DISCOVER_IDENT:\n\t\tcase CMD_DISCOVER_SVID:\n\t\tcase CMD_DISCOVER_MODES:\n\t\tcase VDO_CMD_VENDOR(0) ... VDO_CMD_VENDOR(15):\n\t\t\tbreak;\n\t\tcase CMD_ENTER_MODE:\n\t\t\t \n\t\t\t*adev_action = ADEV_NOTIFY_USB_AND_QUEUE_VDM;\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\t \n\t\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_NAK);\n\t\t\trlen = 1;\n\t\t\tresponse[0] = (response[0] & ~VDO_SVDM_VERS_MASK) |\n\t\t\t\t      (VDO_SVDM_VERS(svdm_version));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tresponse[0] = p[0] | VDO_CMDT(CMDT_RSP_NAK);\n\t\trlen = 1;\n\t\tresponse[0] = (response[0] & ~VDO_SVDM_VERS_MASK) |\n\t\t\t      (VDO_SVDM_VERS(svdm_version));\n\t\tbreak;\n\t}\n\n\t \n\t*adev_action = ADEV_QUEUE_VDM;\n\treturn rlen;\n}\n\nstatic void tcpm_pd_handle_msg(struct tcpm_port *port,\n\t\t\t       enum pd_msg_request message,\n\t\t\t       enum tcpm_ams ams);\n\nstatic void tcpm_handle_vdm_request(struct tcpm_port *port,\n\t\t\t\t    const __le32 *payload, int cnt)\n{\n\tenum adev_actions adev_action = ADEV_NONE;\n\tstruct typec_altmode *adev;\n\tu32 p[PD_MAX_PAYLOAD];\n\tu32 response[8] = { };\n\tint i, rlen = 0;\n\n\tfor (i = 0; i < cnt; i++)\n\t\tp[i] = le32_to_cpu(payload[i]);\n\n\tadev = typec_match_altmode(port->port_altmode, ALTMODE_DISCOVERY_MAX,\n\t\t\t\t   PD_VDO_VID(p[0]), PD_VDO_OPOS(p[0]));\n\n\tif (port->vdm_state == VDM_STATE_BUSY) {\n\t\t \n\t\tif (PD_VDO_CMDT(p[0]) == CMDT_RSP_BUSY) {\n\t\t\tport->vdm_state = VDM_STATE_WAIT_RSP_BUSY;\n\t\t\tport->vdo_retry = (p[0] & ~VDO_CMDT_MASK) |\n\t\t\t\tCMDT_INIT;\n\t\t\tmod_vdm_delayed_work(port, PD_T_VDM_BUSY);\n\t\t\treturn;\n\t\t}\n\t\tport->vdm_state = VDM_STATE_DONE;\n\t}\n\n\tif (PD_VDO_SVDM(p[0]) && (adev || tcpm_vdm_ams(port) || port->nr_snk_vdo)) {\n\t\t \n\t\tport->vdm_sm_running = true;\n\t\trlen = tcpm_pd_svdm(port, adev, p, cnt, response, &adev_action);\n\t} else {\n\t\tif (port->negotiated_rev >= PD_REV30)\n\t\t\ttcpm_pd_handle_msg(port, PD_MSG_CTRL_NOT_SUPP, NONE_AMS);\n\t}\n\n\t \n\tmutex_unlock(&port->lock);\n\n\tif (adev) {\n\t\tswitch (adev_action) {\n\t\tcase ADEV_NONE:\n\t\t\tbreak;\n\t\tcase ADEV_NOTIFY_USB_AND_QUEUE_VDM:\n\t\t\tWARN_ON(typec_altmode_notify(adev, TYPEC_STATE_USB, NULL));\n\t\t\ttypec_altmode_vdm(adev, p[0], &p[1], cnt);\n\t\t\tbreak;\n\t\tcase ADEV_QUEUE_VDM:\n\t\t\ttypec_altmode_vdm(adev, p[0], &p[1], cnt);\n\t\t\tbreak;\n\t\tcase ADEV_QUEUE_VDM_SEND_EXIT_MODE_ON_FAIL:\n\t\t\tif (typec_altmode_vdm(adev, p[0], &p[1], cnt)) {\n\t\t\t\tint svdm_version = typec_get_negotiated_svdm_version(\n\t\t\t\t\t\t\t\t\tport->typec_port);\n\t\t\t\tif (svdm_version < 0)\n\t\t\t\t\tbreak;\n\n\t\t\t\tresponse[0] = VDO(adev->svid, 1, svdm_version,\n\t\t\t\t\t\t  CMD_EXIT_MODE);\n\t\t\t\tresponse[0] |= VDO_OPOS(adev->mode);\n\t\t\t\trlen = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ADEV_ATTENTION:\n\t\t\tif (typec_altmode_attention(adev, p[1]))\n\t\t\t\ttcpm_log(port, \"typec_altmode_attention no port partner altmode\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tmutex_lock(&port->lock);\n\n\tif (rlen > 0)\n\t\ttcpm_queue_vdm(port, response[0], &response[1], rlen - 1);\n\telse\n\t\tport->vdm_sm_running = false;\n}\n\nstatic void tcpm_send_vdm(struct tcpm_port *port, u32 vid, int cmd,\n\t\t\t  const u32 *data, int count)\n{\n\tint svdm_version = typec_get_negotiated_svdm_version(port->typec_port);\n\tu32 header;\n\n\tif (svdm_version < 0)\n\t\treturn;\n\n\tif (WARN_ON(count > VDO_MAX_SIZE - 1))\n\t\tcount = VDO_MAX_SIZE - 1;\n\n\t \n\theader = VDO(vid, ((vid & USB_SID_PD) == USB_SID_PD) ?\n\t\t\t1 : (PD_VDO_CMD(cmd) <= CMD_ATTENTION),\n\t\t\tsvdm_version, cmd);\n\ttcpm_queue_vdm(port, header, data, count);\n}\n\nstatic unsigned int vdm_ready_timeout(u32 vdm_hdr)\n{\n\tunsigned int timeout;\n\tint cmd = PD_VDO_CMD(vdm_hdr);\n\n\t \n\tif (!PD_VDO_SVDM(vdm_hdr))\n\t\treturn PD_T_VDM_UNSTRUCTURED;\n\n\tswitch (PD_VDO_CMDT(vdm_hdr)) {\n\tcase CMDT_INIT:\n\t\tif (cmd == CMD_ENTER_MODE || cmd == CMD_EXIT_MODE)\n\t\t\ttimeout = PD_T_VDM_WAIT_MODE_E;\n\t\telse\n\t\t\ttimeout = PD_T_VDM_SNDR_RSP;\n\t\tbreak;\n\tdefault:\n\t\tif (cmd == CMD_ENTER_MODE || cmd == CMD_EXIT_MODE)\n\t\t\ttimeout = PD_T_VDM_E_MODE;\n\t\telse\n\t\t\ttimeout = PD_T_VDM_RCVR_RSP;\n\t\tbreak;\n\t}\n\treturn timeout;\n}\n\nstatic void vdm_run_state_machine(struct tcpm_port *port)\n{\n\tstruct pd_message msg;\n\tint i, res = 0;\n\tu32 vdo_hdr = port->vdo_data[0];\n\n\tswitch (port->vdm_state) {\n\tcase VDM_STATE_READY:\n\t\t \n\t\tif (!port->attached) {\n\t\t\tport->vdm_state = VDM_STATE_ERR_BUSY;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (port->state != SRC_READY && port->state != SNK_READY) {\n\t\t\tport->vdm_sm_running = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (PD_VDO_SVDM(vdo_hdr) && PD_VDO_CMDT(vdo_hdr) == CMDT_INIT) {\n\t\t\tswitch (PD_VDO_CMD(vdo_hdr)) {\n\t\t\tcase CMD_DISCOVER_IDENT:\n\t\t\t\tres = tcpm_ams_start(port, DISCOVER_IDENTITY);\n\t\t\t\tif (res == 0) {\n\t\t\t\t\tport->send_discover = false;\n\t\t\t\t} else if (res == -EAGAIN) {\n\t\t\t\t\tport->vdo_data[0] = 0;\n\t\t\t\t\tmod_send_discover_delayed_work(port,\n\t\t\t\t\t\t\t\t       SEND_DISCOVER_RETRY_MS);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CMD_DISCOVER_SVID:\n\t\t\t\tres = tcpm_ams_start(port, DISCOVER_SVIDS);\n\t\t\t\tbreak;\n\t\t\tcase CMD_DISCOVER_MODES:\n\t\t\t\tres = tcpm_ams_start(port, DISCOVER_MODES);\n\t\t\t\tbreak;\n\t\t\tcase CMD_ENTER_MODE:\n\t\t\t\tres = tcpm_ams_start(port, DFP_TO_UFP_ENTER_MODE);\n\t\t\t\tbreak;\n\t\t\tcase CMD_EXIT_MODE:\n\t\t\t\tres = tcpm_ams_start(port, DFP_TO_UFP_EXIT_MODE);\n\t\t\t\tbreak;\n\t\t\tcase CMD_ATTENTION:\n\t\t\t\tres = tcpm_ams_start(port, ATTENTION);\n\t\t\t\tbreak;\n\t\t\tcase VDO_CMD_VENDOR(0) ... VDO_CMD_VENDOR(15):\n\t\t\t\tres = tcpm_ams_start(port, STRUCTURED_VDMS);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tres = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (res < 0) {\n\t\t\t\tport->vdm_state = VDM_STATE_ERR_BUSY;\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tport->vdm_state = VDM_STATE_SEND_MESSAGE;\n\t\tmod_vdm_delayed_work(port, (port->negotiated_rev >= PD_REV30 &&\n\t\t\t\t\t    port->pwr_role == TYPEC_SOURCE &&\n\t\t\t\t\t    PD_VDO_SVDM(vdo_hdr) &&\n\t\t\t\t\t    PD_VDO_CMDT(vdo_hdr) == CMDT_INIT) ?\n\t\t\t\t\t   PD_T_SINK_TX : 0);\n\t\tbreak;\n\tcase VDM_STATE_WAIT_RSP_BUSY:\n\t\tport->vdo_data[0] = port->vdo_retry;\n\t\tport->vdo_count = 1;\n\t\tport->vdm_state = VDM_STATE_READY;\n\t\ttcpm_ams_finish(port);\n\t\tbreak;\n\tcase VDM_STATE_BUSY:\n\t\tport->vdm_state = VDM_STATE_ERR_TMOUT;\n\t\tif (port->ams != NONE_AMS)\n\t\t\ttcpm_ams_finish(port);\n\t\tbreak;\n\tcase VDM_STATE_ERR_SEND:\n\t\t \n\t\tif (port->vdm_retries < 3) {\n\t\t\ttcpm_log(port, \"VDM Tx error, retry\");\n\t\t\tport->vdm_retries++;\n\t\t\tport->vdm_state = VDM_STATE_READY;\n\t\t\tif (PD_VDO_SVDM(vdo_hdr) && PD_VDO_CMDT(vdo_hdr) == CMDT_INIT)\n\t\t\t\ttcpm_ams_finish(port);\n\t\t} else {\n\t\t\ttcpm_ams_finish(port);\n\t\t}\n\t\tbreak;\n\tcase VDM_STATE_SEND_MESSAGE:\n\t\t \n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmsg.header = PD_HEADER_LE(PD_DATA_VENDOR_DEF,\n\t\t\t\t\t  port->pwr_role,\n\t\t\t\t\t  port->data_role,\n\t\t\t\t\t  port->negotiated_rev,\n\t\t\t\t\t  port->message_id, port->vdo_count);\n\t\tfor (i = 0; i < port->vdo_count; i++)\n\t\t\tmsg.payload[i] = cpu_to_le32(port->vdo_data[i]);\n\t\tres = tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n\t\tif (res < 0) {\n\t\t\tport->vdm_state = VDM_STATE_ERR_SEND;\n\t\t} else {\n\t\t\tunsigned long timeout;\n\n\t\t\tport->vdm_retries = 0;\n\t\t\tport->vdo_data[0] = 0;\n\t\t\tport->vdm_state = VDM_STATE_BUSY;\n\t\t\ttimeout = vdm_ready_timeout(vdo_hdr);\n\t\t\tmod_vdm_delayed_work(port, timeout);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void vdm_state_machine_work(struct kthread_work *work)\n{\n\tstruct tcpm_port *port = container_of(work, struct tcpm_port, vdm_state_machine);\n\tenum vdm_states prev_state;\n\n\tmutex_lock(&port->lock);\n\n\t \n\tdo {\n\t\tprev_state = port->vdm_state;\n\t\tvdm_run_state_machine(port);\n\t} while (port->vdm_state != prev_state &&\n\t\t port->vdm_state != VDM_STATE_BUSY &&\n\t\t port->vdm_state != VDM_STATE_SEND_MESSAGE);\n\n\tif (port->vdm_state < VDM_STATE_READY)\n\t\tport->vdm_sm_running = false;\n\n\tmutex_unlock(&port->lock);\n}\n\nenum pdo_err {\n\tPDO_NO_ERR,\n\tPDO_ERR_NO_VSAFE5V,\n\tPDO_ERR_VSAFE5V_NOT_FIRST,\n\tPDO_ERR_PDO_TYPE_NOT_IN_ORDER,\n\tPDO_ERR_FIXED_NOT_SORTED,\n\tPDO_ERR_VARIABLE_BATT_NOT_SORTED,\n\tPDO_ERR_DUPE_PDO,\n\tPDO_ERR_PPS_APDO_NOT_SORTED,\n\tPDO_ERR_DUPE_PPS_APDO,\n};\n\nstatic const char * const pdo_err_msg[] = {\n\t[PDO_ERR_NO_VSAFE5V] =\n\t\" err: source/sink caps should at least have vSafe5V\",\n\t[PDO_ERR_VSAFE5V_NOT_FIRST] =\n\t\" err: vSafe5V Fixed Supply Object Shall always be the first object\",\n\t[PDO_ERR_PDO_TYPE_NOT_IN_ORDER] =\n\t\" err: PDOs should be in the following order: Fixed; Battery; Variable\",\n\t[PDO_ERR_FIXED_NOT_SORTED] =\n\t\" err: Fixed supply pdos should be in increasing order of their fixed voltage\",\n\t[PDO_ERR_VARIABLE_BATT_NOT_SORTED] =\n\t\" err: Variable/Battery supply pdos should be in increasing order of their minimum voltage\",\n\t[PDO_ERR_DUPE_PDO] =\n\t\" err: Variable/Batt supply pdos cannot have same min/max voltage\",\n\t[PDO_ERR_PPS_APDO_NOT_SORTED] =\n\t\" err: Programmable power supply apdos should be in increasing order of their maximum voltage\",\n\t[PDO_ERR_DUPE_PPS_APDO] =\n\t\" err: Programmable power supply apdos cannot have same min/max voltage and max current\",\n};\n\nstatic enum pdo_err tcpm_caps_err(struct tcpm_port *port, const u32 *pdo,\n\t\t\t\t  unsigned int nr_pdo)\n{\n\tunsigned int i;\n\n\t \n\tif (nr_pdo < 1)\n\t\treturn PDO_ERR_NO_VSAFE5V;\n\n\t \n\tif (pdo_type(pdo[0]) != PDO_TYPE_FIXED ||\n\t    pdo_fixed_voltage(pdo[0]) != VSAFE5V)\n\t\treturn PDO_ERR_VSAFE5V_NOT_FIRST;\n\n\tfor (i = 1; i < nr_pdo; i++) {\n\t\tif (pdo_type(pdo[i]) < pdo_type(pdo[i - 1])) {\n\t\t\treturn PDO_ERR_PDO_TYPE_NOT_IN_ORDER;\n\t\t} else if (pdo_type(pdo[i]) == pdo_type(pdo[i - 1])) {\n\t\t\tenum pd_pdo_type type = pdo_type(pdo[i]);\n\n\t\t\tswitch (type) {\n\t\t\t \n\t\t\tcase PDO_TYPE_FIXED:\n\t\t\t\tif (pdo_fixed_voltage(pdo[i]) <=\n\t\t\t\t    pdo_fixed_voltage(pdo[i - 1]))\n\t\t\t\t\treturn PDO_ERR_FIXED_NOT_SORTED;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase PDO_TYPE_VAR:\n\t\t\tcase PDO_TYPE_BATT:\n\t\t\t\tif (pdo_min_voltage(pdo[i]) <\n\t\t\t\t    pdo_min_voltage(pdo[i - 1]))\n\t\t\t\t\treturn PDO_ERR_VARIABLE_BATT_NOT_SORTED;\n\t\t\t\telse if ((pdo_min_voltage(pdo[i]) ==\n\t\t\t\t\t  pdo_min_voltage(pdo[i - 1])) &&\n\t\t\t\t\t (pdo_max_voltage(pdo[i]) ==\n\t\t\t\t\t  pdo_max_voltage(pdo[i - 1])))\n\t\t\t\t\treturn PDO_ERR_DUPE_PDO;\n\t\t\t\tbreak;\n\t\t\t \n\t\t\tcase PDO_TYPE_APDO:\n\t\t\t\tif (pdo_apdo_type(pdo[i]) != APDO_TYPE_PPS)\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (pdo_pps_apdo_max_voltage(pdo[i]) <\n\t\t\t\t    pdo_pps_apdo_max_voltage(pdo[i - 1]))\n\t\t\t\t\treturn PDO_ERR_PPS_APDO_NOT_SORTED;\n\t\t\t\telse if (pdo_pps_apdo_min_voltage(pdo[i]) ==\n\t\t\t\t\t  pdo_pps_apdo_min_voltage(pdo[i - 1]) &&\n\t\t\t\t\t pdo_pps_apdo_max_voltage(pdo[i]) ==\n\t\t\t\t\t  pdo_pps_apdo_max_voltage(pdo[i - 1]) &&\n\t\t\t\t\t pdo_pps_apdo_max_current(pdo[i]) ==\n\t\t\t\t\t  pdo_pps_apdo_max_current(pdo[i - 1]))\n\t\t\t\t\treturn PDO_ERR_DUPE_PPS_APDO;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttcpm_log_force(port, \" Unknown pdo type\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn PDO_NO_ERR;\n}\n\nstatic int tcpm_validate_caps(struct tcpm_port *port, const u32 *pdo,\n\t\t\t      unsigned int nr_pdo)\n{\n\tenum pdo_err err_index = tcpm_caps_err(port, pdo, nr_pdo);\n\n\tif (err_index != PDO_NO_ERR) {\n\t\ttcpm_log_force(port, \" %s\", pdo_err_msg[err_index]);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcpm_altmode_enter(struct typec_altmode *altmode, u32 *vdo)\n{\n\tstruct tcpm_port *port = typec_altmode_get_drvdata(altmode);\n\tint svdm_version;\n\tu32 header;\n\n\tsvdm_version = typec_get_negotiated_svdm_version(port->typec_port);\n\tif (svdm_version < 0)\n\t\treturn svdm_version;\n\n\theader = VDO(altmode->svid, vdo ? 2 : 1, svdm_version, CMD_ENTER_MODE);\n\theader |= VDO_OPOS(altmode->mode);\n\n\ttcpm_queue_vdm_unlocked(port, header, vdo, vdo ? 1 : 0);\n\treturn 0;\n}\n\nstatic int tcpm_altmode_exit(struct typec_altmode *altmode)\n{\n\tstruct tcpm_port *port = typec_altmode_get_drvdata(altmode);\n\tint svdm_version;\n\tu32 header;\n\n\tsvdm_version = typec_get_negotiated_svdm_version(port->typec_port);\n\tif (svdm_version < 0)\n\t\treturn svdm_version;\n\n\theader = VDO(altmode->svid, 1, svdm_version, CMD_EXIT_MODE);\n\theader |= VDO_OPOS(altmode->mode);\n\n\ttcpm_queue_vdm_unlocked(port, header, NULL, 0);\n\treturn 0;\n}\n\nstatic int tcpm_altmode_vdm(struct typec_altmode *altmode,\n\t\t\t    u32 header, const u32 *data, int count)\n{\n\tstruct tcpm_port *port = typec_altmode_get_drvdata(altmode);\n\n\ttcpm_queue_vdm_unlocked(port, header, data, count - 1);\n\n\treturn 0;\n}\n\nstatic const struct typec_altmode_ops tcpm_altmode_ops = {\n\t.enter = tcpm_altmode_enter,\n\t.exit = tcpm_altmode_exit,\n\t.vdm = tcpm_altmode_vdm,\n};\n\n \nstatic inline enum tcpm_state ready_state(struct tcpm_port *port)\n{\n\tif (port->pwr_role == TYPEC_SOURCE)\n\t\treturn SRC_READY;\n\telse\n\t\treturn SNK_READY;\n}\n\nstatic int tcpm_pd_send_control(struct tcpm_port *port,\n\t\t\t\tenum pd_ctrl_msg_type type);\n\nstatic void tcpm_handle_alert(struct tcpm_port *port, const __le32 *payload,\n\t\t\t      int cnt)\n{\n\tu32 p0 = le32_to_cpu(payload[0]);\n\tunsigned int type = usb_pd_ado_type(p0);\n\n\tif (!type) {\n\t\ttcpm_log(port, \"Alert message received with no type\");\n\t\ttcpm_queue_message(port, PD_MSG_CTRL_NOT_SUPP);\n\t\treturn;\n\t}\n\n\t \n\tif (!(type & USB_PD_ADO_TYPE_BATT_STATUS_CHANGE)) {\n\t\tif (port->pwr_role == TYPEC_SOURCE) {\n\t\t\tport->upcoming_state = GET_STATUS_SEND;\n\t\t\ttcpm_ams_start(port, GETTING_SOURCE_SINK_STATUS);\n\t\t} else {\n\t\t\t \n\t\t\tport->ams = GETTING_SOURCE_SINK_STATUS;\n\t\t\ttcpm_set_state(port, GET_STATUS_SEND, 0);\n\t\t}\n\t} else {\n\t\ttcpm_queue_message(port, PD_MSG_CTRL_NOT_SUPP);\n\t}\n}\n\nstatic int tcpm_set_auto_vbus_discharge_threshold(struct tcpm_port *port,\n\t\t\t\t\t\t  enum typec_pwr_opmode mode, bool pps_active,\n\t\t\t\t\t\t  u32 requested_vbus_voltage)\n{\n\tint ret;\n\n\tif (!port->tcpc->set_auto_vbus_discharge_threshold)\n\t\treturn 0;\n\n\tret = port->tcpc->set_auto_vbus_discharge_threshold(port->tcpc, mode, pps_active,\n\t\t\t\t\t\t\t    requested_vbus_voltage);\n\ttcpm_log_force(port,\n\t\t       \"set_auto_vbus_discharge_threshold mode:%d pps_active:%c vbus:%u ret:%d\",\n\t\t       mode, pps_active ? 'y' : 'n', requested_vbus_voltage, ret);\n\n\treturn ret;\n}\n\nstatic void tcpm_pd_handle_state(struct tcpm_port *port,\n\t\t\t\t enum tcpm_state state,\n\t\t\t\t enum tcpm_ams ams,\n\t\t\t\t unsigned int delay_ms)\n{\n\tswitch (port->state) {\n\tcase SRC_READY:\n\tcase SNK_READY:\n\t\tport->ams = ams;\n\t\ttcpm_set_state(port, state, delay_ms);\n\t\tbreak;\n\t \n\tcase SNK_TRANSITION_SINK:\n\tcase SNK_TRANSITION_SINK_VBUS:\n\tcase SRC_TRANSITION_SUPPLY:\n\t\ttcpm_set_state(port, HARD_RESET_SEND, 0);\n\t\tbreak;\n\tdefault:\n\t\tif (!tcpm_ams_interruptible(port)) {\n\t\t\ttcpm_set_state(port, port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t       SRC_SOFT_RESET_WAIT_SNK_TX :\n\t\t\t\t       SNK_SOFT_RESET,\n\t\t\t\t       0);\n\t\t} else {\n\t\t\t \n\t\t\tport->upcoming_state = state;\n\t\t\tport->next_ams = ams;\n\t\t\ttcpm_set_state(port, ready_state(port), delay_ms);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic void tcpm_pd_handle_msg(struct tcpm_port *port,\n\t\t\t       enum pd_msg_request message,\n\t\t\t       enum tcpm_ams ams)\n{\n\tswitch (port->state) {\n\tcase SRC_READY:\n\tcase SNK_READY:\n\t\tport->ams = ams;\n\t\ttcpm_queue_message(port, message);\n\t\tbreak;\n\t \n\tcase SNK_TRANSITION_SINK:\n\tcase SNK_TRANSITION_SINK_VBUS:\n\tcase SRC_TRANSITION_SUPPLY:\n\t\ttcpm_set_state(port, HARD_RESET_SEND, 0);\n\t\tbreak;\n\tdefault:\n\t\tif (!tcpm_ams_interruptible(port)) {\n\t\t\ttcpm_set_state(port, port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t       SRC_SOFT_RESET_WAIT_SNK_TX :\n\t\t\t\t       SNK_SOFT_RESET,\n\t\t\t\t       0);\n\t\t} else {\n\t\t\tport->next_ams = ams;\n\t\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\t\t \n\t\t\ttcpm_queue_message(port, message);\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic int tcpm_register_source_caps(struct tcpm_port *port)\n{\n\tstruct usb_power_delivery_desc desc = { port->negotiated_rev };\n\tstruct usb_power_delivery_capabilities_desc caps = { };\n\tstruct usb_power_delivery_capabilities *cap;\n\n\tif (!port->partner_pd)\n\t\tport->partner_pd = usb_power_delivery_register(NULL, &desc);\n\tif (IS_ERR(port->partner_pd))\n\t\treturn PTR_ERR(port->partner_pd);\n\n\tmemcpy(caps.pdo, port->source_caps, sizeof(u32) * port->nr_source_caps);\n\tcaps.role = TYPEC_SOURCE;\n\n\tcap = usb_power_delivery_register_capabilities(port->partner_pd, &caps);\n\tif (IS_ERR(cap))\n\t\treturn PTR_ERR(cap);\n\n\tport->partner_source_caps = cap;\n\n\treturn 0;\n}\n\nstatic int tcpm_register_sink_caps(struct tcpm_port *port)\n{\n\tstruct usb_power_delivery_desc desc = { port->negotiated_rev };\n\tstruct usb_power_delivery_capabilities_desc caps = { };\n\tstruct usb_power_delivery_capabilities *cap;\n\n\tif (!port->partner_pd)\n\t\tport->partner_pd = usb_power_delivery_register(NULL, &desc);\n\tif (IS_ERR(port->partner_pd))\n\t\treturn PTR_ERR(port->partner_pd);\n\n\tmemcpy(caps.pdo, port->sink_caps, sizeof(u32) * port->nr_sink_caps);\n\tcaps.role = TYPEC_SINK;\n\n\tcap = usb_power_delivery_register_capabilities(port->partner_pd, &caps);\n\tif (IS_ERR(cap))\n\t\treturn PTR_ERR(cap);\n\n\tport->partner_sink_caps = cap;\n\n\treturn 0;\n}\n\nstatic void tcpm_pd_data_request(struct tcpm_port *port,\n\t\t\t\t const struct pd_message *msg)\n{\n\tenum pd_data_msg_type type = pd_header_type_le(msg->header);\n\tunsigned int cnt = pd_header_cnt_le(msg->header);\n\tunsigned int rev = pd_header_rev_le(msg->header);\n\tunsigned int i;\n\tenum frs_typec_current partner_frs_current;\n\tbool frs_enable;\n\tint ret;\n\n\tif (tcpm_vdm_ams(port) && type != PD_DATA_VENDOR_DEF) {\n\t\tport->vdm_state = VDM_STATE_ERR_BUSY;\n\t\ttcpm_ams_finish(port);\n\t\tmod_vdm_delayed_work(port, 0);\n\t}\n\n\tswitch (type) {\n\tcase PD_DATA_SOURCE_CAP:\n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tport->source_caps[i] = le32_to_cpu(msg->payload[i]);\n\n\t\tport->nr_source_caps = cnt;\n\n\t\ttcpm_log_source_caps(port);\n\n\t\ttcpm_validate_caps(port, port->source_caps,\n\t\t\t\t   port->nr_source_caps);\n\n\t\ttcpm_register_source_caps(port);\n\n\t\t \n\t\tif (rev == PD_REV10) {\n\t\t\tif (port->ams == GET_SOURCE_CAPABILITIES)\n\t\t\t\ttcpm_ams_finish(port);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rev < PD_MAX_REV)\n\t\t\tport->negotiated_rev = rev;\n\n\t\tif (port->pwr_role == TYPEC_SOURCE) {\n\t\t\tif (port->ams == GET_SOURCE_CAPABILITIES)\n\t\t\t\ttcpm_pd_handle_state(port, SRC_READY, NONE_AMS, 0);\n\t\t\t \n\t\t\telse\n\t\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t\t   NONE_AMS);\n\t\t} else if (port->state == SNK_WAIT_CAPABILITIES) {\n\t\t \n\t\t\tport->ams = POWER_NEGOTIATION;\n\t\t\tport->in_ams = true;\n\t\t\ttcpm_set_state(port, SNK_NEGOTIATE_CAPABILITIES, 0);\n\t\t} else {\n\t\t\tif (port->ams == GET_SOURCE_CAPABILITIES)\n\t\t\t\ttcpm_ams_finish(port);\n\t\t\ttcpm_pd_handle_state(port, SNK_NEGOTIATE_CAPABILITIES,\n\t\t\t\t\t     POWER_NEGOTIATION, 0);\n\t\t}\n\t\tbreak;\n\tcase PD_DATA_REQUEST:\n\t\t \n\t\tif (rev == PD_REV10) {\n\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t   NONE_AMS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rev < PD_MAX_REV)\n\t\t\tport->negotiated_rev = rev;\n\n\t\tif (port->pwr_role != TYPEC_SOURCE || cnt != 1) {\n\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t   NONE_AMS);\n\t\t\tbreak;\n\t\t}\n\n\t\tport->sink_request = le32_to_cpu(msg->payload[0]);\n\n\t\tif (port->vdm_sm_running && port->explicit_contract) {\n\t\t\ttcpm_pd_handle_msg(port, PD_MSG_CTRL_WAIT, port->ams);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (port->state == SRC_SEND_CAPABILITIES)\n\t\t\ttcpm_set_state(port, SRC_NEGOTIATE_CAPABILITIES, 0);\n\t\telse\n\t\t\ttcpm_pd_handle_state(port, SRC_NEGOTIATE_CAPABILITIES,\n\t\t\t\t\t     POWER_NEGOTIATION, 0);\n\t\tbreak;\n\tcase PD_DATA_SINK_CAP:\n\t\t \n\t\tfor (i = 0; i < cnt; i++)\n\t\t\tport->sink_caps[i] = le32_to_cpu(msg->payload[i]);\n\n\t\tpartner_frs_current = (port->sink_caps[0] & PDO_FIXED_FRS_CURR_MASK) >>\n\t\t\tPDO_FIXED_FRS_CURR_SHIFT;\n\t\tfrs_enable = partner_frs_current && (partner_frs_current <=\n\t\t\t\t\t\t     port->new_source_frs_current);\n\t\ttcpm_log(port,\n\t\t\t \"Port partner FRS capable partner_frs_current:%u port_frs_current:%u enable:%c\",\n\t\t\t partner_frs_current, port->new_source_frs_current, frs_enable ? 'y' : 'n');\n\t\tif (frs_enable) {\n\t\t\tret  = port->tcpc->enable_frs(port->tcpc, true);\n\t\t\ttcpm_log(port, \"Enable FRS %s, ret:%d\\n\", ret ? \"fail\" : \"success\", ret);\n\t\t}\n\n\t\tport->nr_sink_caps = cnt;\n\t\tport->sink_cap_done = true;\n\t\ttcpm_register_sink_caps(port);\n\n\t\tif (port->ams == GET_SINK_CAPABILITIES)\n\t\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\t \n\t\telse\n\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t   NONE_AMS);\n\t\tbreak;\n\tcase PD_DATA_VENDOR_DEF:\n\t\ttcpm_handle_vdm_request(port, msg->payload, cnt);\n\t\tbreak;\n\tcase PD_DATA_BIST:\n\t\tport->bist_request = le32_to_cpu(msg->payload[0]);\n\t\ttcpm_pd_handle_state(port, BIST_RX, BIST, 0);\n\t\tbreak;\n\tcase PD_DATA_ALERT:\n\t\tif (port->state != SRC_READY && port->state != SNK_READY)\n\t\t\ttcpm_pd_handle_state(port, port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t\t     SRC_SOFT_RESET_WAIT_SNK_TX : SNK_SOFT_RESET,\n\t\t\t\t\t     NONE_AMS, 0);\n\t\telse\n\t\t\ttcpm_handle_alert(port, msg->payload, cnt);\n\t\tbreak;\n\tcase PD_DATA_BATT_STATUS:\n\tcase PD_DATA_GET_COUNTRY_INFO:\n\t\t \n\t\ttcpm_pd_handle_msg(port, port->negotiated_rev < PD_REV30 ?\n\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t   NONE_AMS);\n\t\tbreak;\n\tdefault:\n\t\ttcpm_pd_handle_msg(port, port->negotiated_rev < PD_REV30 ?\n\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t   NONE_AMS);\n\t\ttcpm_log(port, \"Unrecognized data message type %#x\", type);\n\t\tbreak;\n\t}\n}\n\nstatic void tcpm_pps_complete(struct tcpm_port *port, int result)\n{\n\tif (port->pps_pending) {\n\t\tport->pps_status = result;\n\t\tport->pps_pending = false;\n\t\tcomplete(&port->pps_complete);\n\t}\n}\n\nstatic void tcpm_pd_ctrl_request(struct tcpm_port *port,\n\t\t\t\t const struct pd_message *msg)\n{\n\tenum pd_ctrl_msg_type type = pd_header_type_le(msg->header);\n\tenum tcpm_state next_state;\n\n\t \n\tif (tcpm_vdm_ams(port) && type != PD_CTRL_NOT_SUPP && type != PD_CTRL_GOOD_CRC) {\n\t\tport->vdm_state = VDM_STATE_ERR_BUSY;\n\t\ttcpm_ams_finish(port);\n\t\tmod_vdm_delayed_work(port, 0);\n\t}\n\n\tswitch (type) {\n\tcase PD_CTRL_GOOD_CRC:\n\tcase PD_CTRL_PING:\n\t\tbreak;\n\tcase PD_CTRL_GET_SOURCE_CAP:\n\t\ttcpm_pd_handle_msg(port, PD_MSG_DATA_SOURCE_CAP, GET_SOURCE_CAPABILITIES);\n\t\tbreak;\n\tcase PD_CTRL_GET_SINK_CAP:\n\t\ttcpm_pd_handle_msg(port, PD_MSG_DATA_SINK_CAP, GET_SINK_CAPABILITIES);\n\t\tbreak;\n\tcase PD_CTRL_GOTO_MIN:\n\t\tbreak;\n\tcase PD_CTRL_PS_RDY:\n\t\tswitch (port->state) {\n\t\tcase SNK_TRANSITION_SINK:\n\t\t\tif (port->vbus_present) {\n\t\t\t\ttcpm_set_current_limit(port,\n\t\t\t\t\t\t       port->req_current_limit,\n\t\t\t\t\t\t       port->req_supply_voltage);\n\t\t\t\tport->explicit_contract = true;\n\t\t\t\ttcpm_set_auto_vbus_discharge_threshold(port,\n\t\t\t\t\t\t\t\t       TYPEC_PWR_MODE_PD,\n\t\t\t\t\t\t\t\t       port->pps_data.active,\n\t\t\t\t\t\t\t\t       port->supply_voltage);\n\t\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttcpm_set_state(port,\n\t\t\t\t\t       SNK_TRANSITION_SINK_VBUS, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PR_SWAP_SRC_SNK_SOURCE_OFF_CC_DEBOUNCED:\n\t\t\ttcpm_set_state(port, PR_SWAP_SRC_SNK_SINK_ON, 0);\n\t\t\tbreak;\n\t\tcase PR_SWAP_SNK_SRC_SINK_OFF:\n\t\t\ttcpm_set_state(port, PR_SWAP_SNK_SRC_SOURCE_ON, 0);\n\t\t\tbreak;\n\t\tcase VCONN_SWAP_WAIT_FOR_VCONN:\n\t\t\ttcpm_set_state(port, VCONN_SWAP_TURN_OFF_VCONN, 0);\n\t\t\tbreak;\n\t\tcase FR_SWAP_SNK_SRC_TRANSITION_TO_OFF:\n\t\t\ttcpm_set_state(port, FR_SWAP_SNK_SRC_NEW_SINK_READY, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttcpm_pd_handle_state(port,\n\t\t\t\t\t     port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t\t     SRC_SOFT_RESET_WAIT_SNK_TX :\n\t\t\t\t\t     SNK_SOFT_RESET,\n\t\t\t\t\t     NONE_AMS, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PD_CTRL_REJECT:\n\tcase PD_CTRL_WAIT:\n\tcase PD_CTRL_NOT_SUPP:\n\t\tswitch (port->state) {\n\t\tcase SNK_NEGOTIATE_CAPABILITIES:\n\t\t\t \n\t\t\tif (port->explicit_contract)\n\t\t\t\tnext_state = SNK_READY;\n\t\t\telse\n\t\t\t\tnext_state = SNK_WAIT_CAPABILITIES;\n\n\t\t\t \n\t\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_PD,\n\t\t\t\t\t\t\t       port->pps_data.active,\n\t\t\t\t\t\t\t       port->supply_voltage);\n\t\t\ttcpm_set_state(port, next_state, 0);\n\t\t\tbreak;\n\t\tcase SNK_NEGOTIATE_PPS_CAPABILITIES:\n\t\t\t \n\t\t\tport->pps_data.req_out_volt = port->supply_voltage;\n\t\t\tport->pps_data.req_op_curr = port->current_limit;\n\t\t\tport->pps_status = (type == PD_CTRL_WAIT ?\n\t\t\t\t\t    -EAGAIN : -EOPNOTSUPP);\n\n\t\t\t \n\t\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_PD,\n\t\t\t\t\t\t\t       port->pps_data.active,\n\t\t\t\t\t\t\t       port->supply_voltage);\n\n\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\t\tbreak;\n\t\tcase DR_SWAP_SEND:\n\t\t\tport->swap_status = (type == PD_CTRL_WAIT ?\n\t\t\t\t\t     -EAGAIN : -EOPNOTSUPP);\n\t\t\ttcpm_set_state(port, DR_SWAP_CANCEL, 0);\n\t\t\tbreak;\n\t\tcase PR_SWAP_SEND:\n\t\t\tport->swap_status = (type == PD_CTRL_WAIT ?\n\t\t\t\t\t     -EAGAIN : -EOPNOTSUPP);\n\t\t\ttcpm_set_state(port, PR_SWAP_CANCEL, 0);\n\t\t\tbreak;\n\t\tcase VCONN_SWAP_SEND:\n\t\t\tport->swap_status = (type == PD_CTRL_WAIT ?\n\t\t\t\t\t     -EAGAIN : -EOPNOTSUPP);\n\t\t\ttcpm_set_state(port, VCONN_SWAP_CANCEL, 0);\n\t\t\tbreak;\n\t\tcase FR_SWAP_SEND:\n\t\t\ttcpm_set_state(port, FR_SWAP_CANCEL, 0);\n\t\t\tbreak;\n\t\tcase GET_SINK_CAP:\n\t\t\tport->sink_cap_done = true;\n\t\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\t\tbreak;\n\t\t \n\t\tcase GET_STATUS_SEND:\n\t\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\t\tbreak;\n\t\tcase SRC_READY:\n\t\tcase SNK_READY:\n\t\t\tif (port->vdm_state > VDM_STATE_READY) {\n\t\t\t\tport->vdm_state = VDM_STATE_DONE;\n\t\t\t\tif (tcpm_vdm_ams(port))\n\t\t\t\t\ttcpm_ams_finish(port);\n\t\t\t\tmod_vdm_delayed_work(port, 0);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\ttcpm_pd_handle_state(port,\n\t\t\t\t\t     port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t\t     SRC_SOFT_RESET_WAIT_SNK_TX :\n\t\t\t\t\t     SNK_SOFT_RESET,\n\t\t\t\t\t     NONE_AMS, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PD_CTRL_ACCEPT:\n\t\tswitch (port->state) {\n\t\tcase SNK_NEGOTIATE_CAPABILITIES:\n\t\t\tport->pps_data.active = false;\n\t\t\ttcpm_set_state(port, SNK_TRANSITION_SINK, 0);\n\t\t\tbreak;\n\t\tcase SNK_NEGOTIATE_PPS_CAPABILITIES:\n\t\t\tport->pps_data.active = true;\n\t\t\tport->pps_data.min_volt = port->pps_data.req_min_volt;\n\t\t\tport->pps_data.max_volt = port->pps_data.req_max_volt;\n\t\t\tport->pps_data.max_curr = port->pps_data.req_max_curr;\n\t\t\tport->req_supply_voltage = port->pps_data.req_out_volt;\n\t\t\tport->req_current_limit = port->pps_data.req_op_curr;\n\t\t\tpower_supply_changed(port->psy);\n\t\t\ttcpm_set_state(port, SNK_TRANSITION_SINK, 0);\n\t\t\tbreak;\n\t\tcase SOFT_RESET_SEND:\n\t\t\tif (port->ams == SOFT_RESET_AMS)\n\t\t\t\ttcpm_ams_finish(port);\n\t\t\tif (port->pwr_role == TYPEC_SOURCE) {\n\t\t\t\tport->upcoming_state = SRC_SEND_CAPABILITIES;\n\t\t\t\ttcpm_ams_start(port, POWER_NEGOTIATION);\n\t\t\t} else {\n\t\t\t\ttcpm_set_state(port, SNK_WAIT_CAPABILITIES, 0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DR_SWAP_SEND:\n\t\t\ttcpm_set_state(port, DR_SWAP_CHANGE_DR, 0);\n\t\t\tbreak;\n\t\tcase PR_SWAP_SEND:\n\t\t\ttcpm_set_state(port, PR_SWAP_START, 0);\n\t\t\tbreak;\n\t\tcase VCONN_SWAP_SEND:\n\t\t\ttcpm_set_state(port, VCONN_SWAP_START, 0);\n\t\t\tbreak;\n\t\tcase FR_SWAP_SEND:\n\t\t\ttcpm_set_state(port, FR_SWAP_SNK_SRC_TRANSITION_TO_OFF, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttcpm_pd_handle_state(port,\n\t\t\t\t\t     port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t\t     SRC_SOFT_RESET_WAIT_SNK_TX :\n\t\t\t\t\t     SNK_SOFT_RESET,\n\t\t\t\t\t     NONE_AMS, 0);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PD_CTRL_SOFT_RESET:\n\t\tport->ams = SOFT_RESET_AMS;\n\t\ttcpm_set_state(port, SOFT_RESET, 0);\n\t\tbreak;\n\tcase PD_CTRL_DR_SWAP:\n\t\t \n\t\tif (port->typec_caps.data != TYPEC_PORT_DRD) {\n\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t   NONE_AMS);\n\t\t} else {\n\t\t\tif (port->send_discover) {\n\t\t\t\ttcpm_queue_message(port, PD_MSG_CTRL_WAIT);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttcpm_pd_handle_state(port, DR_SWAP_ACCEPT, DATA_ROLE_SWAP, 0);\n\t\t}\n\t\tbreak;\n\tcase PD_CTRL_PR_SWAP:\n\t\tif (port->port_type != TYPEC_PORT_DRP) {\n\t\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t\t   NONE_AMS);\n\t\t} else {\n\t\t\tif (port->send_discover) {\n\t\t\t\ttcpm_queue_message(port, PD_MSG_CTRL_WAIT);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ttcpm_pd_handle_state(port, PR_SWAP_ACCEPT, POWER_ROLE_SWAP, 0);\n\t\t}\n\t\tbreak;\n\tcase PD_CTRL_VCONN_SWAP:\n\t\tif (port->send_discover) {\n\t\t\ttcpm_queue_message(port, PD_MSG_CTRL_WAIT);\n\t\t\tbreak;\n\t\t}\n\n\t\ttcpm_pd_handle_state(port, VCONN_SWAP_ACCEPT, VCONN_SWAP, 0);\n\t\tbreak;\n\tcase PD_CTRL_GET_SOURCE_CAP_EXT:\n\tcase PD_CTRL_GET_STATUS:\n\tcase PD_CTRL_FR_SWAP:\n\tcase PD_CTRL_GET_PPS_STATUS:\n\tcase PD_CTRL_GET_COUNTRY_CODES:\n\t\t \n\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t   NONE_AMS);\n\t\tbreak;\n\tdefault:\n\t\ttcpm_pd_handle_msg(port,\n\t\t\t\t   port->negotiated_rev < PD_REV30 ?\n\t\t\t\t   PD_MSG_CTRL_REJECT :\n\t\t\t\t   PD_MSG_CTRL_NOT_SUPP,\n\t\t\t\t   NONE_AMS);\n\t\ttcpm_log(port, \"Unrecognized ctrl message type %#x\", type);\n\t\tbreak;\n\t}\n}\n\nstatic void tcpm_pd_ext_msg_request(struct tcpm_port *port,\n\t\t\t\t    const struct pd_message *msg)\n{\n\tenum pd_ext_msg_type type = pd_header_type_le(msg->header);\n\tunsigned int data_size = pd_ext_header_data_size_le(msg->ext_msg.header);\n\n\t \n\tif (tcpm_vdm_ams(port)) {\n\t\tport->vdm_state = VDM_STATE_ERR_BUSY;\n\t\ttcpm_ams_finish(port);\n\t\tmod_vdm_delayed_work(port, 0);\n\t}\n\n\tif (!(le16_to_cpu(msg->ext_msg.header) & PD_EXT_HDR_CHUNKED)) {\n\t\ttcpm_pd_handle_msg(port, PD_MSG_CTRL_NOT_SUPP, NONE_AMS);\n\t\ttcpm_log(port, \"Unchunked extended messages unsupported\");\n\t\treturn;\n\t}\n\n\tif (data_size > PD_EXT_MAX_CHUNK_DATA) {\n\t\ttcpm_pd_handle_state(port, CHUNK_NOT_SUPP, NONE_AMS, PD_T_CHUNK_NOT_SUPP);\n\t\ttcpm_log(port, \"Chunk handling not yet supported\");\n\t\treturn;\n\t}\n\n\tswitch (type) {\n\tcase PD_EXT_STATUS:\n\tcase PD_EXT_PPS_STATUS:\n\t\tif (port->ams == GETTING_SOURCE_SINK_STATUS) {\n\t\t\ttcpm_ams_finish(port);\n\t\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\t} else {\n\t\t\t \n\t\t\ttcpm_pd_handle_state(port, port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t\t     SRC_SOFT_RESET_WAIT_SNK_TX : SNK_SOFT_RESET,\n\t\t\t\t\t     NONE_AMS, 0);\n\t\t}\n\t\tbreak;\n\tcase PD_EXT_SOURCE_CAP_EXT:\n\tcase PD_EXT_GET_BATT_CAP:\n\tcase PD_EXT_GET_BATT_STATUS:\n\tcase PD_EXT_BATT_CAP:\n\tcase PD_EXT_GET_MANUFACTURER_INFO:\n\tcase PD_EXT_MANUFACTURER_INFO:\n\tcase PD_EXT_SECURITY_REQUEST:\n\tcase PD_EXT_SECURITY_RESPONSE:\n\tcase PD_EXT_FW_UPDATE_REQUEST:\n\tcase PD_EXT_FW_UPDATE_RESPONSE:\n\tcase PD_EXT_COUNTRY_INFO:\n\tcase PD_EXT_COUNTRY_CODES:\n\t\ttcpm_pd_handle_msg(port, PD_MSG_CTRL_NOT_SUPP, NONE_AMS);\n\t\tbreak;\n\tdefault:\n\t\ttcpm_pd_handle_msg(port, PD_MSG_CTRL_NOT_SUPP, NONE_AMS);\n\t\ttcpm_log(port, \"Unrecognized extended message type %#x\", type);\n\t\tbreak;\n\t}\n}\n\nstatic void tcpm_pd_rx_handler(struct kthread_work *work)\n{\n\tstruct pd_rx_event *event = container_of(work,\n\t\t\t\t\t\t struct pd_rx_event, work);\n\tconst struct pd_message *msg = &event->msg;\n\tunsigned int cnt = pd_header_cnt_le(msg->header);\n\tstruct tcpm_port *port = event->port;\n\n\tmutex_lock(&port->lock);\n\n\ttcpm_log(port, \"PD RX, header: %#x [%d]\", le16_to_cpu(msg->header),\n\t\t port->attached);\n\n\tif (port->attached) {\n\t\tenum pd_ctrl_msg_type type = pd_header_type_le(msg->header);\n\t\tunsigned int msgid = pd_header_msgid_le(msg->header);\n\n\t\t \n\t\tif (msgid == port->rx_msgid && type != PD_CTRL_SOFT_RESET)\n\t\t\tgoto done;\n\t\tport->rx_msgid = msgid;\n\n\t\t \n\t\tif (!!(le16_to_cpu(msg->header) & PD_HEADER_DATA_ROLE) ==\n\t\t    (port->data_role == TYPEC_HOST)) {\n\t\t\ttcpm_log(port,\n\t\t\t\t \"Data role mismatch, initiating error recovery\");\n\t\t\ttcpm_set_state(port, ERROR_RECOVERY, 0);\n\t\t} else {\n\t\t\tif (le16_to_cpu(msg->header) & PD_HEADER_EXT_HDR)\n\t\t\t\ttcpm_pd_ext_msg_request(port, msg);\n\t\t\telse if (cnt)\n\t\t\t\ttcpm_pd_data_request(port, msg);\n\t\t\telse\n\t\t\t\ttcpm_pd_ctrl_request(port, msg);\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&port->lock);\n\tkfree(event);\n}\n\nvoid tcpm_pd_receive(struct tcpm_port *port, const struct pd_message *msg)\n{\n\tstruct pd_rx_event *event;\n\n\tevent = kzalloc(sizeof(*event), GFP_ATOMIC);\n\tif (!event)\n\t\treturn;\n\n\tkthread_init_work(&event->work, tcpm_pd_rx_handler);\n\tevent->port = port;\n\tmemcpy(&event->msg, msg, sizeof(*msg));\n\tkthread_queue_work(port->wq, &event->work);\n}\nEXPORT_SYMBOL_GPL(tcpm_pd_receive);\n\nstatic int tcpm_pd_send_control(struct tcpm_port *port,\n\t\t\t\tenum pd_ctrl_msg_type type)\n{\n\tstruct pd_message msg;\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.header = PD_HEADER_LE(type, port->pwr_role,\n\t\t\t\t  port->data_role,\n\t\t\t\t  port->negotiated_rev,\n\t\t\t\t  port->message_id, 0);\n\n\treturn tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n}\n\n \nstatic bool tcpm_send_queued_message(struct tcpm_port *port)\n{\n\tenum pd_msg_request queued_message;\n\tint ret;\n\n\tdo {\n\t\tqueued_message = port->queued_message;\n\t\tport->queued_message = PD_MSG_NONE;\n\n\t\tswitch (queued_message) {\n\t\tcase PD_MSG_CTRL_WAIT:\n\t\t\ttcpm_pd_send_control(port, PD_CTRL_WAIT);\n\t\t\tbreak;\n\t\tcase PD_MSG_CTRL_REJECT:\n\t\t\ttcpm_pd_send_control(port, PD_CTRL_REJECT);\n\t\t\tbreak;\n\t\tcase PD_MSG_CTRL_NOT_SUPP:\n\t\t\ttcpm_pd_send_control(port, PD_CTRL_NOT_SUPP);\n\t\t\tbreak;\n\t\tcase PD_MSG_DATA_SINK_CAP:\n\t\t\tret = tcpm_pd_send_sink_caps(port);\n\t\t\tif (ret < 0) {\n\t\t\t\ttcpm_log(port, \"Unable to send snk caps, ret=%d\", ret);\n\t\t\t\ttcpm_set_state(port, SNK_SOFT_RESET, 0);\n\t\t\t}\n\t\t\ttcpm_ams_finish(port);\n\t\t\tbreak;\n\t\tcase PD_MSG_DATA_SOURCE_CAP:\n\t\t\tret = tcpm_pd_send_source_caps(port);\n\t\t\tif (ret < 0) {\n\t\t\t\ttcpm_log(port,\n\t\t\t\t\t \"Unable to send src caps, ret=%d\",\n\t\t\t\t\t ret);\n\t\t\t\ttcpm_set_state(port, SOFT_RESET_SEND, 0);\n\t\t\t} else if (port->pwr_role == TYPEC_SOURCE) {\n\t\t\t\ttcpm_ams_finish(port);\n\t\t\t\ttcpm_set_state(port, HARD_RESET_SEND,\n\t\t\t\t\t       PD_T_SENDER_RESPONSE);\n\t\t\t} else {\n\t\t\t\ttcpm_ams_finish(port);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} while (port->queued_message != PD_MSG_NONE);\n\n\tif (port->delayed_state != INVALID_STATE) {\n\t\tif (ktime_after(port->delayed_runtime, ktime_get())) {\n\t\t\tmod_tcpm_delayed_work(port, ktime_to_ms(ktime_sub(port->delayed_runtime,\n\t\t\t\t\t\t\t\t\t  ktime_get())));\n\t\t\treturn true;\n\t\t}\n\t\tport->delayed_state = INVALID_STATE;\n\t}\n\treturn false;\n}\n\nstatic int tcpm_pd_check_request(struct tcpm_port *port)\n{\n\tu32 pdo, rdo = port->sink_request;\n\tunsigned int max, op, pdo_max, index;\n\tenum pd_pdo_type type;\n\n\tindex = rdo_index(rdo);\n\tif (!index || index > port->nr_src_pdo)\n\t\treturn -EINVAL;\n\n\tpdo = port->src_pdo[index - 1];\n\ttype = pdo_type(pdo);\n\tswitch (type) {\n\tcase PDO_TYPE_FIXED:\n\tcase PDO_TYPE_VAR:\n\t\tmax = rdo_max_current(rdo);\n\t\top = rdo_op_current(rdo);\n\t\tpdo_max = pdo_max_current(pdo);\n\n\t\tif (op > pdo_max)\n\t\t\treturn -EINVAL;\n\t\tif (max > pdo_max && !(rdo & RDO_CAP_MISMATCH))\n\t\t\treturn -EINVAL;\n\n\t\tif (type == PDO_TYPE_FIXED)\n\t\t\ttcpm_log(port,\n\t\t\t\t \"Requested %u mV, %u mA for %u / %u mA\",\n\t\t\t\t pdo_fixed_voltage(pdo), pdo_max, op, max);\n\t\telse\n\t\t\ttcpm_log(port,\n\t\t\t\t \"Requested %u -> %u mV, %u mA for %u / %u mA\",\n\t\t\t\t pdo_min_voltage(pdo), pdo_max_voltage(pdo),\n\t\t\t\t pdo_max, op, max);\n\t\tbreak;\n\tcase PDO_TYPE_BATT:\n\t\tmax = rdo_max_power(rdo);\n\t\top = rdo_op_power(rdo);\n\t\tpdo_max = pdo_max_power(pdo);\n\n\t\tif (op > pdo_max)\n\t\t\treturn -EINVAL;\n\t\tif (max > pdo_max && !(rdo & RDO_CAP_MISMATCH))\n\t\t\treturn -EINVAL;\n\t\ttcpm_log(port,\n\t\t\t \"Requested %u -> %u mV, %u mW for %u / %u mW\",\n\t\t\t pdo_min_voltage(pdo), pdo_max_voltage(pdo),\n\t\t\t pdo_max, op, max);\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tport->op_vsafe5v = index == 1;\n\n\treturn 0;\n}\n\n#define min_power(x, y) min(pdo_max_power(x), pdo_max_power(y))\n#define min_current(x, y) min(pdo_max_current(x), pdo_max_current(y))\n\nstatic int tcpm_pd_select_pdo(struct tcpm_port *port, int *sink_pdo,\n\t\t\t      int *src_pdo)\n{\n\tunsigned int i, j, max_src_mv = 0, min_src_mv = 0, max_mw = 0,\n\t\t     max_mv = 0, src_mw = 0, src_ma = 0, max_snk_mv = 0,\n\t\t     min_snk_mv = 0;\n\tint ret = -EINVAL;\n\n\tport->pps_data.supported = false;\n\tport->usb_type = POWER_SUPPLY_USB_TYPE_PD;\n\tpower_supply_changed(port->psy);\n\n\t \n\tfor (i = 0; i < port->nr_source_caps; i++) {\n\t\tu32 pdo = port->source_caps[i];\n\t\tenum pd_pdo_type type = pdo_type(pdo);\n\n\t\tswitch (type) {\n\t\tcase PDO_TYPE_FIXED:\n\t\t\tmax_src_mv = pdo_fixed_voltage(pdo);\n\t\t\tmin_src_mv = max_src_mv;\n\t\t\tbreak;\n\t\tcase PDO_TYPE_BATT:\n\t\tcase PDO_TYPE_VAR:\n\t\t\tmax_src_mv = pdo_max_voltage(pdo);\n\t\t\tmin_src_mv = pdo_min_voltage(pdo);\n\t\t\tbreak;\n\t\tcase PDO_TYPE_APDO:\n\t\t\tif (pdo_apdo_type(pdo) == APDO_TYPE_PPS) {\n\t\t\t\tport->pps_data.supported = true;\n\t\t\t\tport->usb_type =\n\t\t\t\t\tPOWER_SUPPLY_USB_TYPE_PD_PPS;\n\t\t\t\tpower_supply_changed(port->psy);\n\t\t\t}\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\ttcpm_log(port, \"Invalid source PDO type, ignoring\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (type) {\n\t\tcase PDO_TYPE_FIXED:\n\t\tcase PDO_TYPE_VAR:\n\t\t\tsrc_ma = pdo_max_current(pdo);\n\t\t\tsrc_mw = src_ma * min_src_mv / 1000;\n\t\t\tbreak;\n\t\tcase PDO_TYPE_BATT:\n\t\t\tsrc_mw = pdo_max_power(pdo);\n\t\t\tbreak;\n\t\tcase PDO_TYPE_APDO:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\ttcpm_log(port, \"Invalid source PDO type, ignoring\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 0; j < port->nr_snk_pdo; j++) {\n\t\t\tpdo = port->snk_pdo[j];\n\n\t\t\tswitch (pdo_type(pdo)) {\n\t\t\tcase PDO_TYPE_FIXED:\n\t\t\t\tmax_snk_mv = pdo_fixed_voltage(pdo);\n\t\t\t\tmin_snk_mv = max_snk_mv;\n\t\t\t\tbreak;\n\t\t\tcase PDO_TYPE_BATT:\n\t\t\tcase PDO_TYPE_VAR:\n\t\t\t\tmax_snk_mv = pdo_max_voltage(pdo);\n\t\t\t\tmin_snk_mv = pdo_min_voltage(pdo);\n\t\t\t\tbreak;\n\t\t\tcase PDO_TYPE_APDO:\n\t\t\t\tcontinue;\n\t\t\tdefault:\n\t\t\t\ttcpm_log(port, \"Invalid sink PDO type, ignoring\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (max_src_mv <= max_snk_mv &&\n\t\t\t\tmin_src_mv >= min_snk_mv) {\n\t\t\t\t \n\t\t\t\tif ((src_mw == max_mw && min_src_mv > max_mv) ||\n\t\t\t\t\t\t\tsrc_mw > max_mw) {\n\t\t\t\t\t*src_pdo = i;\n\t\t\t\t\t*sink_pdo = j;\n\t\t\t\t\tmax_mw = src_mw;\n\t\t\t\t\tmax_mv = min_src_mv;\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int tcpm_pd_select_pps_apdo(struct tcpm_port *port)\n{\n\tunsigned int i, src_ma, max_temp_mw = 0, max_op_ma, op_mw;\n\tunsigned int src_pdo = 0;\n\tu32 pdo, src;\n\n\tfor (i = 1; i < port->nr_source_caps; ++i) {\n\t\tpdo = port->source_caps[i];\n\n\t\tswitch (pdo_type(pdo)) {\n\t\tcase PDO_TYPE_APDO:\n\t\t\tif (pdo_apdo_type(pdo) != APDO_TYPE_PPS) {\n\t\t\t\ttcpm_log(port, \"Not PPS APDO (source), ignoring\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (port->pps_data.req_out_volt > pdo_pps_apdo_max_voltage(pdo) ||\n\t\t\t    port->pps_data.req_out_volt < pdo_pps_apdo_min_voltage(pdo))\n\t\t\t\tcontinue;\n\n\t\t\tsrc_ma = pdo_pps_apdo_max_current(pdo);\n\t\t\tmax_op_ma = min(src_ma, port->pps_data.req_op_curr);\n\t\t\top_mw = max_op_ma * port->pps_data.req_out_volt / 1000;\n\t\t\tif (op_mw > max_temp_mw) {\n\t\t\t\tsrc_pdo = i;\n\t\t\t\tmax_temp_mw = op_mw;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttcpm_log(port, \"Not APDO type (source), ignoring\");\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tif (src_pdo) {\n\t\tsrc = port->source_caps[src_pdo];\n\n\t\tport->pps_data.req_min_volt = pdo_pps_apdo_min_voltage(src);\n\t\tport->pps_data.req_max_volt = pdo_pps_apdo_max_voltage(src);\n\t\tport->pps_data.req_max_curr = pdo_pps_apdo_max_current(src);\n\t\tport->pps_data.req_op_curr = min(port->pps_data.req_max_curr,\n\t\t\t\t\t\t port->pps_data.req_op_curr);\n\t}\n\n\treturn src_pdo;\n}\n\nstatic int tcpm_pd_build_request(struct tcpm_port *port, u32 *rdo)\n{\n\tunsigned int mv, ma, mw, flags;\n\tunsigned int max_ma, max_mw;\n\tenum pd_pdo_type type;\n\tu32 pdo, matching_snk_pdo;\n\tint src_pdo_index = 0;\n\tint snk_pdo_index = 0;\n\tint ret;\n\n\tret = tcpm_pd_select_pdo(port, &snk_pdo_index, &src_pdo_index);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpdo = port->source_caps[src_pdo_index];\n\tmatching_snk_pdo = port->snk_pdo[snk_pdo_index];\n\ttype = pdo_type(pdo);\n\n\tswitch (type) {\n\tcase PDO_TYPE_FIXED:\n\t\tmv = pdo_fixed_voltage(pdo);\n\t\tbreak;\n\tcase PDO_TYPE_BATT:\n\tcase PDO_TYPE_VAR:\n\t\tmv = pdo_min_voltage(pdo);\n\t\tbreak;\n\tdefault:\n\t\ttcpm_log(port, \"Invalid PDO selected!\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (type == PDO_TYPE_BATT) {\n\t\tmw = min_power(pdo, matching_snk_pdo);\n\t\tma = 1000 * mw / mv;\n\t} else {\n\t\tma = min_current(pdo, matching_snk_pdo);\n\t\tmw = ma * mv / 1000;\n\t}\n\n\tflags = RDO_USB_COMM | RDO_NO_SUSPEND;\n\n\t \n\tmax_ma = ma;\n\tmax_mw = mw;\n\tif (mw < port->operating_snk_mw) {\n\t\tflags |= RDO_CAP_MISMATCH;\n\t\tif (type == PDO_TYPE_BATT &&\n\t\t    (pdo_max_power(matching_snk_pdo) > pdo_max_power(pdo)))\n\t\t\tmax_mw = pdo_max_power(matching_snk_pdo);\n\t\telse if (pdo_max_current(matching_snk_pdo) >\n\t\t\t pdo_max_current(pdo))\n\t\t\tmax_ma = pdo_max_current(matching_snk_pdo);\n\t}\n\n\ttcpm_log(port, \"cc=%d cc1=%d cc2=%d vbus=%d vconn=%s polarity=%d\",\n\t\t port->cc_req, port->cc1, port->cc2, port->vbus_source,\n\t\t port->vconn_role == TYPEC_SOURCE ? \"source\" : \"sink\",\n\t\t port->polarity);\n\n\tif (type == PDO_TYPE_BATT) {\n\t\t*rdo = RDO_BATT(src_pdo_index + 1, mw, max_mw, flags);\n\n\t\ttcpm_log(port, \"Requesting PDO %d: %u mV, %u mW%s\",\n\t\t\t src_pdo_index, mv, mw,\n\t\t\t flags & RDO_CAP_MISMATCH ? \" [mismatch]\" : \"\");\n\t} else {\n\t\t*rdo = RDO_FIXED(src_pdo_index + 1, ma, max_ma, flags);\n\n\t\ttcpm_log(port, \"Requesting PDO %d: %u mV, %u mA%s\",\n\t\t\t src_pdo_index, mv, ma,\n\t\t\t flags & RDO_CAP_MISMATCH ? \" [mismatch]\" : \"\");\n\t}\n\n\tport->req_current_limit = ma;\n\tport->req_supply_voltage = mv;\n\n\treturn 0;\n}\n\nstatic int tcpm_pd_send_request(struct tcpm_port *port)\n{\n\tstruct pd_message msg;\n\tint ret;\n\tu32 rdo;\n\n\tret = tcpm_pd_build_request(port, &rdo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB, false, 0);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.header = PD_HEADER_LE(PD_DATA_REQUEST,\n\t\t\t\t  port->pwr_role,\n\t\t\t\t  port->data_role,\n\t\t\t\t  port->negotiated_rev,\n\t\t\t\t  port->message_id, 1);\n\tmsg.payload[0] = cpu_to_le32(rdo);\n\n\treturn tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n}\n\nstatic int tcpm_pd_build_pps_request(struct tcpm_port *port, u32 *rdo)\n{\n\tunsigned int out_mv, op_ma, op_mw, max_mv, max_ma, flags;\n\tunsigned int src_pdo_index;\n\n\tsrc_pdo_index = tcpm_pd_select_pps_apdo(port);\n\tif (!src_pdo_index)\n\t\treturn -EOPNOTSUPP;\n\n\tmax_mv = port->pps_data.req_max_volt;\n\tmax_ma = port->pps_data.req_max_curr;\n\tout_mv = port->pps_data.req_out_volt;\n\top_ma = port->pps_data.req_op_curr;\n\n\tflags = RDO_USB_COMM | RDO_NO_SUSPEND;\n\n\top_mw = (op_ma * out_mv) / 1000;\n\tif (op_mw < port->operating_snk_mw) {\n\t\t \n\t\top_ma = (port->operating_snk_mw * 1000) / out_mv;\n\t\tif ((port->operating_snk_mw * 1000) % out_mv)\n\t\t\t++op_ma;\n\t\top_ma += RDO_PROG_CURR_MA_STEP - (op_ma % RDO_PROG_CURR_MA_STEP);\n\n\t\tif (op_ma > max_ma) {\n\t\t\top_ma = max_ma;\n\t\t\tout_mv = (port->operating_snk_mw * 1000) / op_ma;\n\t\t\tif ((port->operating_snk_mw * 1000) % op_ma)\n\t\t\t\t++out_mv;\n\t\t\tout_mv += RDO_PROG_VOLT_MV_STEP -\n\t\t\t\t  (out_mv % RDO_PROG_VOLT_MV_STEP);\n\n\t\t\tif (out_mv > max_mv) {\n\t\t\t\ttcpm_log(port, \"Invalid PPS APDO selected!\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\ttcpm_log(port, \"cc=%d cc1=%d cc2=%d vbus=%d vconn=%s polarity=%d\",\n\t\t port->cc_req, port->cc1, port->cc2, port->vbus_source,\n\t\t port->vconn_role == TYPEC_SOURCE ? \"source\" : \"sink\",\n\t\t port->polarity);\n\n\t*rdo = RDO_PROG(src_pdo_index + 1, out_mv, op_ma, flags);\n\n\ttcpm_log(port, \"Requesting APDO %d: %u mV, %u mA\",\n\t\t src_pdo_index, out_mv, op_ma);\n\n\tport->pps_data.req_op_curr = op_ma;\n\tport->pps_data.req_out_volt = out_mv;\n\n\treturn 0;\n}\n\nstatic int tcpm_pd_send_pps_request(struct tcpm_port *port)\n{\n\tstruct pd_message msg;\n\tint ret;\n\tu32 rdo;\n\n\tret = tcpm_pd_build_pps_request(port, &rdo);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB, false, 0);\n\n\tmemset(&msg, 0, sizeof(msg));\n\tmsg.header = PD_HEADER_LE(PD_DATA_REQUEST,\n\t\t\t\t  port->pwr_role,\n\t\t\t\t  port->data_role,\n\t\t\t\t  port->negotiated_rev,\n\t\t\t\t  port->message_id, 1);\n\tmsg.payload[0] = cpu_to_le32(rdo);\n\n\treturn tcpm_pd_transmit(port, TCPC_TX_SOP, &msg);\n}\n\nstatic int tcpm_set_vbus(struct tcpm_port *port, bool enable)\n{\n\tint ret;\n\n\tif (enable && port->vbus_charge)\n\t\treturn -EINVAL;\n\n\ttcpm_log(port, \"vbus:=%d charge=%d\", enable, port->vbus_charge);\n\n\tret = port->tcpc->set_vbus(port->tcpc, enable, port->vbus_charge);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->vbus_source = enable;\n\treturn 0;\n}\n\nstatic int tcpm_set_charge(struct tcpm_port *port, bool charge)\n{\n\tint ret;\n\n\tif (charge && port->vbus_source)\n\t\treturn -EINVAL;\n\n\tif (charge != port->vbus_charge) {\n\t\ttcpm_log(port, \"vbus=%d charge:=%d\", port->vbus_source, charge);\n\t\tret = port->tcpc->set_vbus(port->tcpc, port->vbus_source,\n\t\t\t\t\t   charge);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\tport->vbus_charge = charge;\n\tpower_supply_changed(port->psy);\n\treturn 0;\n}\n\nstatic bool tcpm_start_toggling(struct tcpm_port *port, enum typec_cc_status cc)\n{\n\tint ret;\n\n\tif (!port->tcpc->start_toggling)\n\t\treturn false;\n\n\ttcpm_log_force(port, \"Start toggling\");\n\tret = port->tcpc->start_toggling(port->tcpc, port->port_type, cc);\n\treturn ret == 0;\n}\n\nstatic int tcpm_init_vbus(struct tcpm_port *port)\n{\n\tint ret;\n\n\tret = port->tcpc->set_vbus(port->tcpc, false, false);\n\tport->vbus_source = false;\n\tport->vbus_charge = false;\n\treturn ret;\n}\n\nstatic int tcpm_init_vconn(struct tcpm_port *port)\n{\n\tint ret;\n\n\tret = port->tcpc->set_vconn(port->tcpc, false);\n\tport->vconn_role = TYPEC_SINK;\n\treturn ret;\n}\n\nstatic void tcpm_typec_connect(struct tcpm_port *port)\n{\n\tif (!port->connected) {\n\t\t \n\t\tmemset(&port->partner_ident, 0, sizeof(port->partner_ident));\n\t\tport->partner_desc.usb_pd = port->pd_capable;\n\t\tif (tcpm_port_is_debug(port))\n\t\t\tport->partner_desc.accessory = TYPEC_ACCESSORY_DEBUG;\n\t\telse if (tcpm_port_is_audio(port))\n\t\t\tport->partner_desc.accessory = TYPEC_ACCESSORY_AUDIO;\n\t\telse\n\t\t\tport->partner_desc.accessory = TYPEC_ACCESSORY_NONE;\n\t\tport->partner = typec_register_partner(port->typec_port,\n\t\t\t\t\t\t       &port->partner_desc);\n\t\tport->connected = true;\n\t\ttypec_partner_set_usb_power_delivery(port->partner, port->partner_pd);\n\t}\n}\n\nstatic int tcpm_src_attach(struct tcpm_port *port)\n{\n\tenum typec_cc_polarity polarity =\n\t\t\t\tport->cc2 == TYPEC_CC_RD ? TYPEC_POLARITY_CC2\n\t\t\t\t\t\t\t : TYPEC_POLARITY_CC1;\n\tint ret;\n\n\tif (port->attached)\n\t\treturn 0;\n\n\tret = tcpm_set_polarity(port, polarity);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttcpm_enable_auto_vbus_discharge(port, true);\n\n\tret = tcpm_set_roles(port, true, TYPEC_SOURCE, tcpm_data_role_for_source(port));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (port->pd_supported) {\n\t\tret = port->tcpc->set_pd_rx(port->tcpc, true);\n\t\tif (ret < 0)\n\t\t\tgoto out_disable_mux;\n\t}\n\n\t \n\tif ((polarity == TYPEC_POLARITY_CC1 && port->cc2 == TYPEC_CC_RA) ||\n\t    (polarity == TYPEC_POLARITY_CC2 && port->cc1 == TYPEC_CC_RA)) {\n\t\tret = tcpm_set_vconn(port, true);\n\t\tif (ret < 0)\n\t\t\tgoto out_disable_pd;\n\t}\n\n\tret = tcpm_set_vbus(port, true);\n\tif (ret < 0)\n\t\tgoto out_disable_vconn;\n\n\tport->pd_capable = false;\n\n\tport->partner = NULL;\n\n\tport->attached = true;\n\tport->send_discover = true;\n\n\treturn 0;\n\nout_disable_vconn:\n\ttcpm_set_vconn(port, false);\nout_disable_pd:\n\tif (port->pd_supported)\n\t\tport->tcpc->set_pd_rx(port->tcpc, false);\nout_disable_mux:\n\ttcpm_mux_set(port, TYPEC_STATE_SAFE, USB_ROLE_NONE,\n\t\t     TYPEC_ORIENTATION_NONE);\n\treturn ret;\n}\n\nstatic void tcpm_typec_disconnect(struct tcpm_port *port)\n{\n\tif (port->connected) {\n\t\ttypec_partner_set_usb_power_delivery(port->partner, NULL);\n\t\ttypec_unregister_partner(port->partner);\n\t\tport->partner = NULL;\n\t\tport->connected = false;\n\t}\n}\n\nstatic void tcpm_unregister_altmodes(struct tcpm_port *port)\n{\n\tstruct pd_mode_data *modep = &port->mode_data;\n\tint i;\n\n\tfor (i = 0; i < modep->altmodes; i++) {\n\t\ttypec_unregister_altmode(port->partner_altmode[i]);\n\t\tport->partner_altmode[i] = NULL;\n\t}\n\n\tmemset(modep, 0, sizeof(*modep));\n}\n\nstatic void tcpm_set_partner_usb_comm_capable(struct tcpm_port *port, bool capable)\n{\n\ttcpm_log(port, \"Setting usb_comm capable %s\", capable ? \"true\" : \"false\");\n\n\tif (port->tcpc->set_partner_usb_comm_capable)\n\t\tport->tcpc->set_partner_usb_comm_capable(port->tcpc, capable);\n}\n\nstatic void tcpm_reset_port(struct tcpm_port *port)\n{\n\ttcpm_enable_auto_vbus_discharge(port, false);\n\tport->in_ams = false;\n\tport->ams = NONE_AMS;\n\tport->vdm_sm_running = false;\n\ttcpm_unregister_altmodes(port);\n\ttcpm_typec_disconnect(port);\n\tport->attached = false;\n\tport->pd_capable = false;\n\tport->pps_data.supported = false;\n\ttcpm_set_partner_usb_comm_capable(port, false);\n\n\t \n\tport->rx_msgid = -1;\n\n\tport->tcpc->set_pd_rx(port->tcpc, false);\n\ttcpm_init_vbus(port);\t \n\ttcpm_init_vconn(port);\n\ttcpm_set_current_limit(port, 0, 0);\n\ttcpm_set_polarity(port, TYPEC_POLARITY_CC1);\n\ttcpm_mux_set(port, TYPEC_STATE_SAFE, USB_ROLE_NONE,\n\t\t     TYPEC_ORIENTATION_NONE);\n\ttcpm_set_attached_state(port, false);\n\tport->try_src_count = 0;\n\tport->try_snk_count = 0;\n\tport->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\tpower_supply_changed(port->psy);\n\tport->nr_sink_caps = 0;\n\tport->sink_cap_done = false;\n\tif (port->tcpc->enable_frs)\n\t\tport->tcpc->enable_frs(port->tcpc, false);\n\n\tusb_power_delivery_unregister_capabilities(port->partner_sink_caps);\n\tport->partner_sink_caps = NULL;\n\tusb_power_delivery_unregister_capabilities(port->partner_source_caps);\n\tport->partner_source_caps = NULL;\n\tusb_power_delivery_unregister(port->partner_pd);\n\tport->partner_pd = NULL;\n}\n\nstatic void tcpm_detach(struct tcpm_port *port)\n{\n\tif (tcpm_port_is_disconnected(port))\n\t\tport->hard_reset_count = 0;\n\n\tport->try_src_count = 0;\n\tport->try_snk_count = 0;\n\n\tif (!port->attached)\n\t\treturn;\n\n\tif (port->tcpc->set_bist_data) {\n\t\ttcpm_log(port, \"disable BIST MODE TESTDATA\");\n\t\tport->tcpc->set_bist_data(port->tcpc, false);\n\t}\n\n\ttcpm_reset_port(port);\n}\n\nstatic void tcpm_src_detach(struct tcpm_port *port)\n{\n\ttcpm_detach(port);\n}\n\nstatic int tcpm_snk_attach(struct tcpm_port *port)\n{\n\tint ret;\n\n\tif (port->attached)\n\t\treturn 0;\n\n\tret = tcpm_set_polarity(port, port->cc2 != TYPEC_CC_OPEN ?\n\t\t\t\tTYPEC_POLARITY_CC2 : TYPEC_POLARITY_CC1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttcpm_enable_auto_vbus_discharge(port, true);\n\n\tret = tcpm_set_roles(port, true, TYPEC_SINK, tcpm_data_role_for_sink(port));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->pd_capable = false;\n\n\tport->partner = NULL;\n\n\tport->attached = true;\n\tport->send_discover = true;\n\n\treturn 0;\n}\n\nstatic void tcpm_snk_detach(struct tcpm_port *port)\n{\n\ttcpm_detach(port);\n}\n\nstatic int tcpm_acc_attach(struct tcpm_port *port)\n{\n\tint ret;\n\n\tif (port->attached)\n\t\treturn 0;\n\n\tret = tcpm_set_roles(port, true, TYPEC_SOURCE,\n\t\t\t     tcpm_data_role_for_source(port));\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->partner = NULL;\n\n\ttcpm_typec_connect(port);\n\n\tport->attached = true;\n\n\treturn 0;\n}\n\nstatic void tcpm_acc_detach(struct tcpm_port *port)\n{\n\ttcpm_detach(port);\n}\n\nstatic inline enum tcpm_state hard_reset_state(struct tcpm_port *port)\n{\n\tif (port->hard_reset_count < PD_N_HARD_RESET_COUNT)\n\t\treturn HARD_RESET_SEND;\n\tif (port->pd_capable)\n\t\treturn ERROR_RECOVERY;\n\tif (port->pwr_role == TYPEC_SOURCE)\n\t\treturn SRC_UNATTACHED;\n\tif (port->state == SNK_WAIT_CAPABILITIES)\n\t\treturn SNK_READY;\n\treturn SNK_UNATTACHED;\n}\n\nstatic inline enum tcpm_state unattached_state(struct tcpm_port *port)\n{\n\tif (port->port_type == TYPEC_PORT_DRP) {\n\t\tif (port->pwr_role == TYPEC_SOURCE)\n\t\t\treturn SRC_UNATTACHED;\n\t\telse\n\t\t\treturn SNK_UNATTACHED;\n\t} else if (port->port_type == TYPEC_PORT_SRC) {\n\t\treturn SRC_UNATTACHED;\n\t}\n\n\treturn SNK_UNATTACHED;\n}\n\nstatic void tcpm_swap_complete(struct tcpm_port *port, int result)\n{\n\tif (port->swap_pending) {\n\t\tport->swap_status = result;\n\t\tport->swap_pending = false;\n\t\tport->non_pd_role_swap = false;\n\t\tcomplete(&port->swap_complete);\n\t}\n}\n\nstatic enum typec_pwr_opmode tcpm_get_pwr_opmode(enum typec_cc_status cc)\n{\n\tswitch (cc) {\n\tcase TYPEC_CC_RP_1_5:\n\t\treturn TYPEC_PWR_MODE_1_5A;\n\tcase TYPEC_CC_RP_3_0:\n\t\treturn TYPEC_PWR_MODE_3_0A;\n\tcase TYPEC_CC_RP_DEF:\n\tdefault:\n\t\treturn TYPEC_PWR_MODE_USB;\n\t}\n}\n\nstatic enum typec_cc_status tcpm_pwr_opmode_to_rp(enum typec_pwr_opmode opmode)\n{\n\tswitch (opmode) {\n\tcase TYPEC_PWR_MODE_USB:\n\t\treturn TYPEC_CC_RP_DEF;\n\tcase TYPEC_PWR_MODE_1_5A:\n\t\treturn TYPEC_CC_RP_1_5;\n\tcase TYPEC_PWR_MODE_3_0A:\n\tcase TYPEC_PWR_MODE_PD:\n\tdefault:\n\t\treturn TYPEC_CC_RP_3_0;\n\t}\n}\n\nstatic void tcpm_set_initial_svdm_version(struct tcpm_port *port)\n{\n\tswitch (port->negotiated_rev) {\n\tcase PD_REV30:\n\t\tbreak;\n\t \n\tcase PD_REV20:\n\t\ttypec_partner_set_svdm_version(port->partner, SVDM_VER_1_0);\n\t\tbreak;\n\tdefault:\n\t\ttypec_partner_set_svdm_version(port->partner, SVDM_VER_1_0);\n\t\tbreak;\n\t}\n}\n\nstatic void run_state_machine(struct tcpm_port *port)\n{\n\tint ret;\n\tenum typec_pwr_opmode opmode;\n\tunsigned int msecs;\n\tenum tcpm_state upcoming_state;\n\n\tif (port->tcpc->check_contaminant && port->state != CHECK_CONTAMINANT)\n\t\tport->potential_contaminant = ((port->enter_state == SRC_ATTACH_WAIT &&\n\t\t\t\t\t\tport->state == SRC_UNATTACHED) ||\n\t\t\t\t\t       (port->enter_state == SNK_ATTACH_WAIT &&\n\t\t\t\t\t\tport->state == SNK_UNATTACHED) ||\n\t\t\t\t\t       (port->enter_state == SNK_DEBOUNCED &&\n\t\t\t\t\t\tport->state == SNK_UNATTACHED));\n\n\tport->enter_state = port->state;\n\tswitch (port->state) {\n\tcase TOGGLING:\n\t\tbreak;\n\tcase CHECK_CONTAMINANT:\n\t\tport->tcpc->check_contaminant(port->tcpc);\n\t\tbreak;\n\t \n\tcase SRC_UNATTACHED:\n\t\tif (!port->non_pd_role_swap)\n\t\t\ttcpm_swap_complete(port, -ENOTCONN);\n\t\ttcpm_src_detach(port);\n\t\tif (port->potential_contaminant) {\n\t\t\ttcpm_set_state(port, CHECK_CONTAMINANT, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (tcpm_start_toggling(port, tcpm_rp_cc(port))) {\n\t\t\ttcpm_set_state(port, TOGGLING, 0);\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\tif (port->port_type == TYPEC_PORT_DRP)\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED, PD_T_DRP_SNK);\n\t\tbreak;\n\tcase SRC_ATTACH_WAIT:\n\t\tif (tcpm_port_is_debug(port))\n\t\t\ttcpm_set_state(port, DEBUG_ACC_ATTACHED,\n\t\t\t\t       PD_T_CC_DEBOUNCE);\n\t\telse if (tcpm_port_is_audio(port))\n\t\t\ttcpm_set_state(port, AUDIO_ACC_ATTACHED,\n\t\t\t\t       PD_T_CC_DEBOUNCE);\n\t\telse if (tcpm_port_is_source(port) && port->vbus_vsafe0v)\n\t\t\ttcpm_set_state(port,\n\t\t\t\t       tcpm_try_snk(port) ? SNK_TRY\n\t\t\t\t\t\t\t  : SRC_ATTACHED,\n\t\t\t\t       PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\n\tcase SNK_TRY:\n\t\tport->try_snk_count++;\n\t\t \n\t\ttcpm_set_cc(port, TYPEC_CC_RD);\n\t\ttcpm_set_state(port, SNK_TRY_WAIT, PD_T_DRP_TRY);\n\t\tbreak;\n\tcase SNK_TRY_WAIT:\n\t\tif (tcpm_port_is_sink(port)) {\n\t\t\ttcpm_set_state(port, SNK_TRY_WAIT_DEBOUNCE, 0);\n\t\t} else {\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT, 0);\n\t\t\tport->max_wait = 0;\n\t\t}\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE:\n\t\ttcpm_set_state(port, SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS,\n\t\t\t       PD_T_TRY_CC_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS:\n\t\tif (port->vbus_present && tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_ATTACHED, 0);\n\t\telse\n\t\t\tport->max_wait = 0;\n\t\tbreak;\n\tcase SRC_TRYWAIT:\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\tif (port->max_wait == 0) {\n\t\t\tport->max_wait = jiffies +\n\t\t\t\t\t msecs_to_jiffies(PD_T_DRP_TRY);\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT_UNATTACHED,\n\t\t\t\t       PD_T_DRP_TRY);\n\t\t} else {\n\t\t\tif (time_is_after_jiffies(port->max_wait))\n\t\t\t\ttcpm_set_state(port, SRC_TRYWAIT_UNATTACHED,\n\t\t\t\t\t       jiffies_to_msecs(port->max_wait -\n\t\t\t\t\t\t\t\tjiffies));\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SNK_UNATTACHED, 0);\n\t\t}\n\t\tbreak;\n\tcase SRC_TRYWAIT_DEBOUNCE:\n\t\ttcpm_set_state(port, SRC_ATTACHED, PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\tcase SRC_TRYWAIT_UNATTACHED:\n\t\ttcpm_set_state(port, SNK_UNATTACHED, 0);\n\t\tbreak;\n\n\tcase SRC_ATTACHED:\n\t\tret = tcpm_src_attach(port);\n\t\ttcpm_set_state(port, SRC_UNATTACHED,\n\t\t\t       ret < 0 ? 0 : PD_T_PS_SOURCE_ON);\n\t\tbreak;\n\tcase SRC_STARTUP:\n\t\topmode =  tcpm_get_pwr_opmode(tcpm_rp_cc(port));\n\t\ttypec_set_pwr_opmode(port->typec_port, opmode);\n\t\tport->pwr_opmode = TYPEC_PWR_MODE_USB;\n\t\tport->caps_count = 0;\n\t\tport->negotiated_rev = PD_MAX_REV;\n\t\tport->message_id = 0;\n\t\tport->rx_msgid = -1;\n\t\tport->explicit_contract = false;\n\t\t \n\t\tif (port->ams == POWER_ROLE_SWAP ||\n\t\t    port->ams == FAST_ROLE_SWAP)\n\t\t\ttcpm_ams_finish(port);\n\t\tif (!port->pd_supported) {\n\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\t\tbreak;\n\t\t}\n\t\tport->upcoming_state = SRC_SEND_CAPABILITIES;\n\t\ttcpm_ams_start(port, POWER_NEGOTIATION);\n\t\tbreak;\n\tcase SRC_SEND_CAPABILITIES:\n\t\tport->caps_count++;\n\t\tif (port->caps_count > PD_N_CAPS_COUNT) {\n\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\t\tbreak;\n\t\t}\n\t\tret = tcpm_pd_send_source_caps(port);\n\t\tif (ret < 0) {\n\t\t\ttcpm_set_state(port, SRC_SEND_CAPABILITIES,\n\t\t\t\t       PD_T_SEND_SOURCE_CAP);\n\t\t} else {\n\t\t\t \n\t\t\t \n\t\t\tport->caps_count = 0;\n\t\t\tport->pd_capable = true;\n\t\t\ttcpm_set_state_cond(port, SRC_SEND_CAPABILITIES_TIMEOUT,\n\t\t\t\t\t    PD_T_SEND_SOURCE_CAP);\n\t\t}\n\t\tbreak;\n\tcase SRC_SEND_CAPABILITIES_TIMEOUT:\n\t\t \n\t\tif (port->hard_reset_count < PD_N_HARD_RESET_COUNT) {\n\t\t\ttcpm_set_state(port, HARD_RESET_SEND, 0);\n\t\t} else if (port->negotiated_rev > PD_REV20) {\n\t\t\tport->negotiated_rev--;\n\t\t\tport->hard_reset_count = 0;\n\t\t\ttcpm_set_state(port, SRC_SEND_CAPABILITIES, 0);\n\t\t} else {\n\t\t\ttcpm_set_state(port, hard_reset_state(port), 0);\n\t\t}\n\t\tbreak;\n\tcase SRC_NEGOTIATE_CAPABILITIES:\n\t\tret = tcpm_pd_check_request(port);\n\t\tif (ret < 0) {\n\t\t\ttcpm_pd_send_control(port, PD_CTRL_REJECT);\n\t\t\tif (!port->explicit_contract) {\n\t\t\t\ttcpm_set_state(port,\n\t\t\t\t\t       SRC_WAIT_NEW_CAPABILITIES, 0);\n\t\t\t} else {\n\t\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\t\t}\n\t\t} else {\n\t\t\ttcpm_pd_send_control(port, PD_CTRL_ACCEPT);\n\t\t\ttcpm_set_partner_usb_comm_capable(port,\n\t\t\t\t\t\t\t  !!(port->sink_request & RDO_USB_COMM));\n\t\t\ttcpm_set_state(port, SRC_TRANSITION_SUPPLY,\n\t\t\t\t       PD_T_SRC_TRANSITION);\n\t\t}\n\t\tbreak;\n\tcase SRC_TRANSITION_SUPPLY:\n\t\t \n\t\ttcpm_pd_send_control(port, PD_CTRL_PS_RDY);\n\t\tport->explicit_contract = true;\n\t\ttypec_set_pwr_opmode(port->typec_port, TYPEC_PWR_MODE_PD);\n\t\tport->pwr_opmode = TYPEC_PWR_MODE_PD;\n\t\ttcpm_set_state_cond(port, SRC_READY, 0);\n\t\tbreak;\n\tcase SRC_READY:\n#if 1\n\t\tport->hard_reset_count = 0;\n#endif\n\t\tport->try_src_count = 0;\n\n\t\ttcpm_swap_complete(port, 0);\n\t\ttcpm_typec_connect(port);\n\n\t\tif (port->ams != NONE_AMS)\n\t\t\ttcpm_ams_finish(port);\n\t\tif (port->next_ams != NONE_AMS) {\n\t\t\tport->ams = port->next_ams;\n\t\t\tport->next_ams = NONE_AMS;\n\t\t}\n\n\t\t \n\t\tif (port->upcoming_state != INVALID_STATE) {\n\t\t\tupcoming_state = port->upcoming_state;\n\t\t\tport->upcoming_state = INVALID_STATE;\n\t\t\ttcpm_set_state(port, upcoming_state, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (port->explicit_contract) {\n\t\t\ttcpm_set_initial_svdm_version(port);\n\t\t\tmod_send_discover_delayed_work(port, 0);\n\t\t} else {\n\t\t\tport->send_discover = false;\n\t\t}\n\n\t\t \n\t\tbreak;\n\tcase SRC_WAIT_NEW_CAPABILITIES:\n\t\t \n\t\tbreak;\n\n\t \n\tcase SNK_UNATTACHED:\n\t\tif (!port->non_pd_role_swap)\n\t\t\ttcpm_swap_complete(port, -ENOTCONN);\n\t\ttcpm_pps_complete(port, -ENOTCONN);\n\t\ttcpm_snk_detach(port);\n\t\tif (port->potential_contaminant) {\n\t\t\ttcpm_set_state(port, CHECK_CONTAMINANT, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (tcpm_start_toggling(port, TYPEC_CC_RD)) {\n\t\t\ttcpm_set_state(port, TOGGLING, 0);\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_cc(port, TYPEC_CC_RD);\n\t\tif (port->port_type == TYPEC_PORT_DRP)\n\t\t\ttcpm_set_state(port, SRC_UNATTACHED, PD_T_DRP_SRC);\n\t\tbreak;\n\tcase SNK_ATTACH_WAIT:\n\t\tif ((port->cc1 == TYPEC_CC_OPEN &&\n\t\t     port->cc2 != TYPEC_CC_OPEN) ||\n\t\t    (port->cc1 != TYPEC_CC_OPEN &&\n\t\t     port->cc2 == TYPEC_CC_OPEN))\n\t\t\ttcpm_set_state(port, SNK_DEBOUNCED,\n\t\t\t\t       PD_T_CC_DEBOUNCE);\n\t\telse if (tcpm_port_is_disconnected(port))\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED,\n\t\t\t\t       PD_T_PD_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_DEBOUNCED:\n\t\tif (tcpm_port_is_disconnected(port))\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED,\n\t\t\t\t       PD_T_PD_DEBOUNCE);\n\t\telse if (port->vbus_present)\n\t\t\ttcpm_set_state(port,\n\t\t\t\t       tcpm_try_src(port) ? SRC_TRY\n\t\t\t\t\t\t\t  : SNK_ATTACHED,\n\t\t\t\t       0);\n\t\tbreak;\n\tcase SRC_TRY:\n\t\tport->try_src_count++;\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\tport->max_wait = 0;\n\t\ttcpm_set_state(port, SRC_TRY_WAIT, 0);\n\t\tbreak;\n\tcase SRC_TRY_WAIT:\n\t\tif (port->max_wait == 0) {\n\t\t\tport->max_wait = jiffies +\n\t\t\t\t\t msecs_to_jiffies(PD_T_DRP_TRY);\n\t\t\tmsecs = PD_T_DRP_TRY;\n\t\t} else {\n\t\t\tif (time_is_after_jiffies(port->max_wait))\n\t\t\t\tmsecs = jiffies_to_msecs(port->max_wait -\n\t\t\t\t\t\t\t jiffies);\n\t\t\telse\n\t\t\t\tmsecs = 0;\n\t\t}\n\t\ttcpm_set_state(port, SNK_TRYWAIT, msecs);\n\t\tbreak;\n\tcase SRC_TRY_DEBOUNCE:\n\t\ttcpm_set_state(port, SRC_ATTACHED, PD_T_PD_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_TRYWAIT:\n\t\ttcpm_set_cc(port, TYPEC_CC_RD);\n\t\ttcpm_set_state(port, SNK_TRYWAIT_VBUS, PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_TRYWAIT_VBUS:\n\t\t \n\t\tif (port->vbus_present && tcpm_port_is_sink(port)) {\n\t\t\ttcpm_set_state(port, SNK_ATTACHED, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (!tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_TRYWAIT_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SNK_TRYWAIT_DEBOUNCE:\n\t\ttcpm_set_state(port, SNK_UNATTACHED, PD_T_PD_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_ATTACHED:\n\t\tret = tcpm_snk_attach(port);\n\t\tif (ret < 0)\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_STARTUP, 0);\n\t\tbreak;\n\tcase SNK_STARTUP:\n\t\topmode =  tcpm_get_pwr_opmode(port->polarity ?\n\t\t\t\t\t      port->cc2 : port->cc1);\n\t\ttypec_set_pwr_opmode(port->typec_port, opmode);\n\t\tport->pwr_opmode = TYPEC_PWR_MODE_USB;\n\t\tport->negotiated_rev = PD_MAX_REV;\n\t\tport->message_id = 0;\n\t\tport->rx_msgid = -1;\n\t\tport->explicit_contract = false;\n\n\t\tif (port->ams == POWER_ROLE_SWAP ||\n\t\t    port->ams == FAST_ROLE_SWAP)\n\t\t\t \n\t\t\ttcpm_ams_finish(port);\n\n\t\ttcpm_set_state(port, SNK_DISCOVERY, 0);\n\t\tbreak;\n\tcase SNK_DISCOVERY:\n\t\tif (port->vbus_present) {\n\t\t\tu32 current_lim = tcpm_get_current_limit(port);\n\n\t\t\tif (port->slow_charger_loop && (current_lim > PD_P_SNK_STDBY_MW / 5))\n\t\t\t\tcurrent_lim = PD_P_SNK_STDBY_MW / 5;\n\t\t\ttcpm_set_current_limit(port, current_lim, 5000);\n\t\t\t \n\t\t\ttcpm_set_charge(port, !port->pd_supported ||\n\t\t\t\t\tpdo_max_current(port->snk_pdo[0]));\n\n\t\t\tif (!port->pd_supported)\n\t\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SNK_WAIT_CAPABILITIES, 0);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\ttcpm_set_state(port, hard_reset_state(port),\n\t\t\t       port->port_type == TYPEC_PORT_DRP ?\n\t\t\t\t\tPD_T_DB_DETECT : PD_T_NO_RESPONSE);\n\t\tbreak;\n\tcase SNK_DISCOVERY_DEBOUNCE:\n\t\ttcpm_set_state(port, SNK_DISCOVERY_DEBOUNCE_DONE,\n\t\t\t       PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\tcase SNK_DISCOVERY_DEBOUNCE_DONE:\n\t\tif (!tcpm_port_is_disconnected(port) &&\n\t\t    tcpm_port_is_sink(port) &&\n\t\t    ktime_after(port->delayed_runtime, ktime_get())) {\n\t\t\ttcpm_set_state(port, SNK_DISCOVERY,\n\t\t\t\t       ktime_to_ms(ktime_sub(port->delayed_runtime, ktime_get())));\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_state(port, unattached_state(port), 0);\n\t\tbreak;\n\tcase SNK_WAIT_CAPABILITIES:\n\t\tret = port->tcpc->set_pd_rx(port->tcpc, true);\n\t\tif (ret < 0) {\n\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (port->vbus_never_low) {\n\t\t\tport->vbus_never_low = false;\n\t\t\ttcpm_set_state(port, SNK_SOFT_RESET,\n\t\t\t\t       PD_T_SINK_WAIT_CAP);\n\t\t} else {\n\t\t\ttcpm_set_state(port, hard_reset_state(port),\n\t\t\t\t       PD_T_SINK_WAIT_CAP);\n\t\t}\n\t\tbreak;\n\tcase SNK_NEGOTIATE_CAPABILITIES:\n\t\tport->pd_capable = true;\n\t\ttcpm_set_partner_usb_comm_capable(port,\n\t\t\t\t\t\t  !!(port->source_caps[0] & PDO_FIXED_USB_COMM));\n\t\tport->hard_reset_count = 0;\n\t\tret = tcpm_pd_send_request(port);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_PD,\n\t\t\t\t\t\t\t       port->pps_data.active,\n\t\t\t\t\t\t\t       port->supply_voltage);\n\t\t\t \n\t\t\ttcpm_set_state(port, SNK_WAIT_CAPABILITIES, 0);\n\t\t} else {\n\t\t\ttcpm_set_state_cond(port, hard_reset_state(port),\n\t\t\t\t\t    PD_T_SENDER_RESPONSE);\n\t\t}\n\t\tbreak;\n\tcase SNK_NEGOTIATE_PPS_CAPABILITIES:\n\t\tret = tcpm_pd_send_pps_request(port);\n\t\tif (ret < 0) {\n\t\t\t \n\t\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_PD,\n\t\t\t\t\t\t\t       port->pps_data.active,\n\t\t\t\t\t\t\t       port->supply_voltage);\n\t\t\tport->pps_status = ret;\n\t\t\t \n\t\t\tif (port->update_sink_caps)\n\t\t\t\ttcpm_set_state(port, SNK_NEGOTIATE_CAPABILITIES, 0);\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\t} else {\n\t\t\ttcpm_set_state_cond(port, hard_reset_state(port),\n\t\t\t\t\t    PD_T_SENDER_RESPONSE);\n\t\t}\n\t\tbreak;\n\tcase SNK_TRANSITION_SINK:\n\t\t \n\t\tif (port->supply_voltage != port->req_supply_voltage && !port->pps_data.active &&\n\t\t    port->current_limit * port->supply_voltage / 1000 > PD_P_SNK_STDBY_MW) {\n\t\t\tu32 stdby_ma = PD_P_SNK_STDBY_MW * 1000 / port->supply_voltage;\n\n\t\t\ttcpm_log(port, \"Setting standby current %u mV @ %u mA\",\n\t\t\t\t port->supply_voltage, stdby_ma);\n\t\t\ttcpm_set_current_limit(port, stdby_ma, port->supply_voltage);\n\t\t}\n\t\tfallthrough;\n\tcase SNK_TRANSITION_SINK_VBUS:\n\t\ttcpm_set_state(port, hard_reset_state(port),\n\t\t\t       PD_T_PS_TRANSITION);\n\t\tbreak;\n\tcase SNK_READY:\n\t\tport->try_snk_count = 0;\n\t\tport->update_sink_caps = false;\n\t\tif (port->explicit_contract) {\n\t\t\ttypec_set_pwr_opmode(port->typec_port,\n\t\t\t\t\t     TYPEC_PWR_MODE_PD);\n\t\t\tport->pwr_opmode = TYPEC_PWR_MODE_PD;\n\t\t}\n\n\t\tif (!port->pd_capable && port->slow_charger_loop)\n\t\t\ttcpm_set_current_limit(port, tcpm_get_current_limit(port), 5000);\n\t\ttcpm_swap_complete(port, 0);\n\t\ttcpm_typec_connect(port);\n\t\tmod_enable_frs_delayed_work(port, 0);\n\t\ttcpm_pps_complete(port, port->pps_status);\n\n\t\tif (port->ams != NONE_AMS)\n\t\t\ttcpm_ams_finish(port);\n\t\tif (port->next_ams != NONE_AMS) {\n\t\t\tport->ams = port->next_ams;\n\t\t\tport->next_ams = NONE_AMS;\n\t\t}\n\n\t\t \n\t\tif (port->upcoming_state != INVALID_STATE) {\n\t\t\tupcoming_state = port->upcoming_state;\n\t\t\tport->upcoming_state = INVALID_STATE;\n\t\t\ttcpm_set_state(port, upcoming_state, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (port->explicit_contract) {\n\t\t\ttcpm_set_initial_svdm_version(port);\n\t\t\tmod_send_discover_delayed_work(port, 0);\n\t\t} else {\n\t\t\tport->send_discover = false;\n\t\t}\n\n\t\tpower_supply_changed(port->psy);\n\t\tbreak;\n\n\t \n\tcase ACC_UNATTACHED:\n\t\ttcpm_acc_detach(port);\n\t\ttcpm_set_state(port, SRC_UNATTACHED, 0);\n\t\tbreak;\n\tcase DEBUG_ACC_ATTACHED:\n\tcase AUDIO_ACC_ATTACHED:\n\t\tret = tcpm_acc_attach(port);\n\t\tif (ret < 0)\n\t\t\ttcpm_set_state(port, ACC_UNATTACHED, 0);\n\t\tbreak;\n\tcase AUDIO_ACC_DEBOUNCE:\n\t\ttcpm_set_state(port, ACC_UNATTACHED, PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\n\t \n\tcase HARD_RESET_SEND:\n\t\tif (port->ams != NONE_AMS)\n\t\t\ttcpm_ams_finish(port);\n\t\t \n\t\tport->upcoming_state = INVALID_STATE;\n\t\ttcpm_ams_start(port, HARD_RESET);\n\t\tbreak;\n\tcase HARD_RESET_START:\n\t\tport->sink_cap_done = false;\n\t\tif (port->tcpc->enable_frs)\n\t\t\tport->tcpc->enable_frs(port->tcpc, false);\n\t\tport->hard_reset_count++;\n\t\tport->tcpc->set_pd_rx(port->tcpc, false);\n\t\ttcpm_unregister_altmodes(port);\n\t\tport->nr_sink_caps = 0;\n\t\tport->send_discover = true;\n\t\tif (port->pwr_role == TYPEC_SOURCE)\n\t\t\ttcpm_set_state(port, SRC_HARD_RESET_VBUS_OFF,\n\t\t\t\t       PD_T_PS_HARD_RESET);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_HARD_RESET_SINK_OFF, 0);\n\t\tbreak;\n\tcase SRC_HARD_RESET_VBUS_OFF:\n\t\t \n\t\ttcpm_set_vconn(port, false);\n\t\ttcpm_set_vbus(port, false);\n\t\ttcpm_set_roles(port, port->self_powered, TYPEC_SOURCE,\n\t\t\t       tcpm_data_role_for_source(port));\n\t\t \n\t\ttcpm_set_state(port, SRC_HARD_RESET_VBUS_ON, PD_T_SAFE_0V + PD_T_SRC_RECOVER);\n\t\tbreak;\n\tcase SRC_HARD_RESET_VBUS_ON:\n\t\ttcpm_set_vconn(port, true);\n\t\ttcpm_set_vbus(port, true);\n\t\tif (port->ams == HARD_RESET)\n\t\t\ttcpm_ams_finish(port);\n\t\tif (port->pd_supported)\n\t\t\tport->tcpc->set_pd_rx(port->tcpc, true);\n\t\ttcpm_set_attached_state(port, true);\n\t\ttcpm_set_state(port, SRC_UNATTACHED, PD_T_PS_SOURCE_ON);\n\t\tbreak;\n\tcase SNK_HARD_RESET_SINK_OFF:\n\t\t \n\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB, false, 0);\n\t\tmemset(&port->pps_data, 0, sizeof(port->pps_data));\n\t\ttcpm_set_vconn(port, false);\n\t\tif (port->pd_capable)\n\t\t\ttcpm_set_charge(port, false);\n\t\ttcpm_set_roles(port, port->self_powered, TYPEC_SINK,\n\t\t\t       tcpm_data_role_for_sink(port));\n\t\t \n\t\ttcpm_set_state(port, SNK_HARD_RESET_SINK_ON, PD_T_SAFE_0V);\n\t\tbreak;\n\tcase SNK_HARD_RESET_WAIT_VBUS:\n\t\tif (port->ams == HARD_RESET)\n\t\t\ttcpm_ams_finish(port);\n\t\t \n\t\ttcpm_set_state(port, SNK_UNATTACHED,\n\t\t\t       PD_T_SRC_RECOVER_MAX + PD_T_SRC_TURN_ON);\n\t\tbreak;\n\tcase SNK_HARD_RESET_SINK_ON:\n\t\t \n\t\t \n\t\tif (port->pd_capable) {\n\t\t\ttcpm_set_current_limit(port,\n\t\t\t\t\t       tcpm_get_current_limit(port),\n\t\t\t\t\t       5000);\n\t\t\t \n\t\t\ttcpm_set_charge(port, !!pdo_max_current(port->snk_pdo[0]));\n\t\t}\n\t\tif (port->ams == HARD_RESET)\n\t\t\ttcpm_ams_finish(port);\n\t\ttcpm_set_attached_state(port, true);\n\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB, false, VSAFE5V);\n\t\ttcpm_set_state(port, SNK_STARTUP, 0);\n\t\tbreak;\n\n\t \n\tcase SOFT_RESET:\n\t\tport->message_id = 0;\n\t\tport->rx_msgid = -1;\n\t\t \n\t\tusb_power_delivery_unregister_capabilities(port->partner_source_caps);\n\t\tport->partner_source_caps = NULL;\n\t\ttcpm_pd_send_control(port, PD_CTRL_ACCEPT);\n\t\ttcpm_ams_finish(port);\n\t\tif (port->pwr_role == TYPEC_SOURCE) {\n\t\t\tport->upcoming_state = SRC_SEND_CAPABILITIES;\n\t\t\ttcpm_ams_start(port, POWER_NEGOTIATION);\n\t\t} else {\n\t\t\ttcpm_set_state(port, SNK_WAIT_CAPABILITIES, 0);\n\t\t}\n\t\tbreak;\n\tcase SRC_SOFT_RESET_WAIT_SNK_TX:\n\tcase SNK_SOFT_RESET:\n\t\tif (port->ams != NONE_AMS)\n\t\t\ttcpm_ams_finish(port);\n\t\tport->upcoming_state = SOFT_RESET_SEND;\n\t\ttcpm_ams_start(port, SOFT_RESET_AMS);\n\t\tbreak;\n\tcase SOFT_RESET_SEND:\n\t\tport->message_id = 0;\n\t\tport->rx_msgid = -1;\n\t\t \n\t\tusb_power_delivery_unregister_capabilities(port->partner_source_caps);\n\t\tport->partner_source_caps = NULL;\n\t\tif (tcpm_pd_send_control(port, PD_CTRL_SOFT_RESET))\n\t\t\ttcpm_set_state_cond(port, hard_reset_state(port), 0);\n\t\telse\n\t\t\ttcpm_set_state_cond(port, hard_reset_state(port),\n\t\t\t\t\t    PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\n\t \n\tcase DR_SWAP_SEND:\n\t\ttcpm_pd_send_control(port, PD_CTRL_DR_SWAP);\n\t\tif (port->data_role == TYPEC_DEVICE || port->negotiated_rev > PD_REV20)\n\t\t\tport->send_discover = true;\n\t\ttcpm_set_state_cond(port, DR_SWAP_SEND_TIMEOUT,\n\t\t\t\t    PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase DR_SWAP_ACCEPT:\n\t\ttcpm_pd_send_control(port, PD_CTRL_ACCEPT);\n\t\tif (port->data_role == TYPEC_DEVICE || port->negotiated_rev > PD_REV20)\n\t\t\tport->send_discover = true;\n\t\ttcpm_set_state_cond(port, DR_SWAP_CHANGE_DR, 0);\n\t\tbreak;\n\tcase DR_SWAP_SEND_TIMEOUT:\n\t\ttcpm_swap_complete(port, -ETIMEDOUT);\n\t\tport->send_discover = false;\n\t\ttcpm_ams_finish(port);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase DR_SWAP_CHANGE_DR:\n\t\ttcpm_unregister_altmodes(port);\n\t\tif (port->data_role == TYPEC_HOST)\n\t\t\ttcpm_set_roles(port, true, port->pwr_role,\n\t\t\t\t       TYPEC_DEVICE);\n\t\telse\n\t\t\ttcpm_set_roles(port, true, port->pwr_role,\n\t\t\t\t       TYPEC_HOST);\n\t\ttcpm_ams_finish(port);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\n\tcase FR_SWAP_SEND:\n\t\tif (tcpm_pd_send_control(port, PD_CTRL_FR_SWAP)) {\n\t\t\ttcpm_set_state(port, ERROR_RECOVERY, 0);\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_state_cond(port, FR_SWAP_SEND_TIMEOUT, PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase FR_SWAP_SEND_TIMEOUT:\n\t\ttcpm_set_state(port, ERROR_RECOVERY, 0);\n\t\tbreak;\n\tcase FR_SWAP_SNK_SRC_TRANSITION_TO_OFF:\n\t\ttcpm_set_state(port, ERROR_RECOVERY, PD_T_PS_SOURCE_OFF);\n\t\tbreak;\n\tcase FR_SWAP_SNK_SRC_NEW_SINK_READY:\n\t\tif (port->vbus_source)\n\t\t\ttcpm_set_state(port, FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, ERROR_RECOVERY, PD_T_RECEIVER_RESPONSE);\n\t\tbreak;\n\tcase FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED:\n\t\ttcpm_set_pwr_role(port, TYPEC_SOURCE);\n\t\tif (tcpm_pd_send_control(port, PD_CTRL_PS_RDY)) {\n\t\t\ttcpm_set_state(port, ERROR_RECOVERY, 0);\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\ttcpm_set_state(port, SRC_STARTUP, PD_T_SWAP_SRC_START);\n\t\tbreak;\n\n\t \n\tcase PR_SWAP_ACCEPT:\n\t\ttcpm_pd_send_control(port, PD_CTRL_ACCEPT);\n\t\ttcpm_set_state(port, PR_SWAP_START, 0);\n\t\tbreak;\n\tcase PR_SWAP_SEND:\n\t\ttcpm_pd_send_control(port, PD_CTRL_PR_SWAP);\n\t\ttcpm_set_state_cond(port, PR_SWAP_SEND_TIMEOUT,\n\t\t\t\t    PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase PR_SWAP_SEND_TIMEOUT:\n\t\ttcpm_swap_complete(port, -ETIMEDOUT);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase PR_SWAP_START:\n\t\ttcpm_apply_rc(port);\n\t\tif (port->pwr_role == TYPEC_SOURCE)\n\t\t\ttcpm_set_state(port, PR_SWAP_SRC_SNK_TRANSITION_OFF,\n\t\t\t\t       PD_T_SRC_TRANSITION);\n\t\telse\n\t\t\ttcpm_set_state(port, PR_SWAP_SNK_SRC_SINK_OFF, 0);\n\t\tbreak;\n\tcase PR_SWAP_SRC_SNK_TRANSITION_OFF:\n\t\t \n\t\ttcpm_set_vbus(port, false);\n\t\tport->explicit_contract = false;\n\t\t \n\t\ttcpm_set_state(port, PR_SWAP_SRC_SNK_SOURCE_OFF,\n\t\t\t       PD_T_SRCSWAPSTDBY);\n\t\tbreak;\n\tcase PR_SWAP_SRC_SNK_SOURCE_OFF:\n\t\ttcpm_set_cc(port, TYPEC_CC_RD);\n\t\t \n\t\ttcpm_set_state(port, PR_SWAP_SRC_SNK_SOURCE_OFF_CC_DEBOUNCED,\n\t\t\t       PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\tcase PR_SWAP_SRC_SNK_SOURCE_OFF_CC_DEBOUNCED:\n\t\t \n\t\ttcpm_set_pwr_role(port, TYPEC_SINK);\n\t\tif (tcpm_pd_send_control(port, PD_CTRL_PS_RDY)) {\n\t\t\ttcpm_set_state(port, ERROR_RECOVERY, 0);\n\t\t\tbreak;\n\t\t}\n\t\ttcpm_set_state(port, ERROR_RECOVERY, PD_T_PS_SOURCE_ON_PRS);\n\t\tbreak;\n\tcase PR_SWAP_SRC_SNK_SINK_ON:\n\t\ttcpm_enable_auto_vbus_discharge(port, true);\n\t\t \n\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB, false, VSAFE5V);\n\t\ttcpm_set_state(port, SNK_STARTUP, 0);\n\t\tbreak;\n\tcase PR_SWAP_SNK_SRC_SINK_OFF:\n\t\t \n\t\tusb_power_delivery_unregister_capabilities(port->partner_source_caps);\n\t\tport->partner_source_caps = NULL;\n\t\t \n\t\ttcpm_set_auto_vbus_discharge_threshold(port, TYPEC_PWR_MODE_USB,\n\t\t\t\t\t\t       port->pps_data.active, 0);\n\t\ttcpm_set_charge(port, false);\n\t\ttcpm_set_state(port, hard_reset_state(port),\n\t\t\t       PD_T_PS_SOURCE_OFF);\n\t\tbreak;\n\tcase PR_SWAP_SNK_SRC_SOURCE_ON:\n\t\ttcpm_enable_auto_vbus_discharge(port, true);\n\t\ttcpm_set_cc(port, tcpm_rp_cc(port));\n\t\ttcpm_set_vbus(port, true);\n\t\t \n\t\ttcpm_set_state(port, PR_SWAP_SNK_SRC_SOURCE_ON_VBUS_RAMPED_UP,\n\t\t\t       PD_T_NEWSRC);\n\t\tbreak;\n\tcase PR_SWAP_SNK_SRC_SOURCE_ON_VBUS_RAMPED_UP:\n\t\t \n\t\ttcpm_set_pwr_role(port, TYPEC_SOURCE);\n\t\ttcpm_pd_send_control(port, PD_CTRL_PS_RDY);\n\t\ttcpm_set_state(port, SRC_STARTUP, PD_T_SWAP_SRC_START);\n\t\tbreak;\n\n\tcase VCONN_SWAP_ACCEPT:\n\t\ttcpm_pd_send_control(port, PD_CTRL_ACCEPT);\n\t\ttcpm_ams_finish(port);\n\t\ttcpm_set_state(port, VCONN_SWAP_START, 0);\n\t\tbreak;\n\tcase VCONN_SWAP_SEND:\n\t\ttcpm_pd_send_control(port, PD_CTRL_VCONN_SWAP);\n\t\ttcpm_set_state(port, VCONN_SWAP_SEND_TIMEOUT,\n\t\t\t       PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase VCONN_SWAP_SEND_TIMEOUT:\n\t\ttcpm_swap_complete(port, -ETIMEDOUT);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase VCONN_SWAP_START:\n\t\tif (port->vconn_role == TYPEC_SOURCE)\n\t\t\ttcpm_set_state(port, VCONN_SWAP_WAIT_FOR_VCONN, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, VCONN_SWAP_TURN_ON_VCONN, 0);\n\t\tbreak;\n\tcase VCONN_SWAP_WAIT_FOR_VCONN:\n\t\ttcpm_set_state(port, hard_reset_state(port),\n\t\t\t       PD_T_VCONN_SOURCE_ON);\n\t\tbreak;\n\tcase VCONN_SWAP_TURN_ON_VCONN:\n\t\ttcpm_set_vconn(port, true);\n\t\ttcpm_pd_send_control(port, PD_CTRL_PS_RDY);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase VCONN_SWAP_TURN_OFF_VCONN:\n\t\ttcpm_set_vconn(port, false);\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\n\tcase DR_SWAP_CANCEL:\n\tcase PR_SWAP_CANCEL:\n\tcase VCONN_SWAP_CANCEL:\n\t\ttcpm_swap_complete(port, port->swap_status);\n\t\tif (port->pwr_role == TYPEC_SOURCE)\n\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\tbreak;\n\tcase FR_SWAP_CANCEL:\n\t\tif (port->pwr_role == TYPEC_SOURCE)\n\t\t\ttcpm_set_state(port, SRC_READY, 0);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\tbreak;\n\n\tcase BIST_RX:\n\t\tswitch (BDO_MODE_MASK(port->bist_request)) {\n\t\tcase BDO_MODE_CARRIER2:\n\t\t\ttcpm_pd_transmit(port, TCPC_TX_BIST_MODE_2, NULL);\n\t\t\ttcpm_set_state(port, unattached_state(port),\n\t\t\t\t       PD_T_BIST_CONT_MODE);\n\t\t\tbreak;\n\t\tcase BDO_MODE_TESTDATA:\n\t\t\tif (port->tcpc->set_bist_data) {\n\t\t\t\ttcpm_log(port, \"Enable BIST MODE TESTDATA\");\n\t\t\t\tport->tcpc->set_bist_data(port->tcpc, true);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GET_STATUS_SEND:\n\t\ttcpm_pd_send_control(port, PD_CTRL_GET_STATUS);\n\t\ttcpm_set_state(port, GET_STATUS_SEND_TIMEOUT,\n\t\t\t       PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase GET_STATUS_SEND_TIMEOUT:\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase GET_PPS_STATUS_SEND:\n\t\ttcpm_pd_send_control(port, PD_CTRL_GET_PPS_STATUS);\n\t\ttcpm_set_state(port, GET_PPS_STATUS_SEND_TIMEOUT,\n\t\t\t       PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase GET_PPS_STATUS_SEND_TIMEOUT:\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase GET_SINK_CAP:\n\t\ttcpm_pd_send_control(port, PD_CTRL_GET_SINK_CAP);\n\t\ttcpm_set_state(port, GET_SINK_CAP_TIMEOUT, PD_T_SENDER_RESPONSE);\n\t\tbreak;\n\tcase GET_SINK_CAP_TIMEOUT:\n\t\tport->sink_cap_done = true;\n\t\ttcpm_set_state(port, ready_state(port), 0);\n\t\tbreak;\n\tcase ERROR_RECOVERY:\n\t\ttcpm_swap_complete(port, -EPROTO);\n\t\ttcpm_pps_complete(port, -EPROTO);\n\t\ttcpm_set_state(port, PORT_RESET, 0);\n\t\tbreak;\n\tcase PORT_RESET:\n\t\ttcpm_reset_port(port);\n\t\ttcpm_set_cc(port, tcpm_default_state(port) == SNK_UNATTACHED ?\n\t\t\t    TYPEC_CC_RD : tcpm_rp_cc(port));\n\t\ttcpm_set_state(port, PORT_RESET_WAIT_OFF,\n\t\t\t       PD_T_ERROR_RECOVERY);\n\t\tbreak;\n\tcase PORT_RESET_WAIT_OFF:\n\t\ttcpm_set_state(port,\n\t\t\t       tcpm_default_state(port),\n\t\t\t       port->vbus_present ? PD_T_PS_SOURCE_OFF : 0);\n\t\tbreak;\n\n\t \n\tcase AMS_START:\n\t\tif (port->upcoming_state == INVALID_STATE) {\n\t\t\ttcpm_set_state(port, port->pwr_role == TYPEC_SOURCE ?\n\t\t\t\t       SRC_READY : SNK_READY, 0);\n\t\t\tbreak;\n\t\t}\n\n\t\tupcoming_state = port->upcoming_state;\n\t\tport->upcoming_state = INVALID_STATE;\n\t\ttcpm_set_state(port, upcoming_state, 0);\n\t\tbreak;\n\n\t \n\tcase CHUNK_NOT_SUPP:\n\t\ttcpm_pd_send_control(port, PD_CTRL_NOT_SUPP);\n\t\ttcpm_set_state(port, port->pwr_role == TYPEC_SOURCE ? SRC_READY : SNK_READY, 0);\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"Unexpected port state %d\\n\", port->state);\n\t\tbreak;\n\t}\n}\n\nstatic void tcpm_state_machine_work(struct kthread_work *work)\n{\n\tstruct tcpm_port *port = container_of(work, struct tcpm_port, state_machine);\n\tenum tcpm_state prev_state;\n\n\tmutex_lock(&port->lock);\n\tport->state_machine_running = true;\n\n\tif (port->queued_message && tcpm_send_queued_message(port))\n\t\tgoto done;\n\n\t \n\tif (port->delayed_state) {\n\t\ttcpm_log(port, \"state change %s -> %s [delayed %ld ms]\",\n\t\t\t tcpm_states[port->state],\n\t\t\t tcpm_states[port->delayed_state], port->delay_ms);\n\t\tport->prev_state = port->state;\n\t\tport->state = port->delayed_state;\n\t\tport->delayed_state = INVALID_STATE;\n\t}\n\n\t \n\tdo {\n\t\tprev_state = port->state;\n\t\trun_state_machine(port);\n\t\tif (port->queued_message)\n\t\t\ttcpm_send_queued_message(port);\n\t} while (port->state != prev_state && !port->delayed_state);\n\ndone:\n\tport->state_machine_running = false;\n\tmutex_unlock(&port->lock);\n}\n\nstatic void _tcpm_cc_change(struct tcpm_port *port, enum typec_cc_status cc1,\n\t\t\t    enum typec_cc_status cc2)\n{\n\tenum typec_cc_status old_cc1, old_cc2;\n\tenum tcpm_state new_state;\n\n\told_cc1 = port->cc1;\n\told_cc2 = port->cc2;\n\tport->cc1 = cc1;\n\tport->cc2 = cc2;\n\n\ttcpm_log_force(port,\n\t\t       \"CC1: %u -> %u, CC2: %u -> %u [state %s, polarity %d, %s]\",\n\t\t       old_cc1, cc1, old_cc2, cc2, tcpm_states[port->state],\n\t\t       port->polarity,\n\t\t       tcpm_port_is_disconnected(port) ? \"disconnected\"\n\t\t\t\t\t\t       : \"connected\");\n\n\tswitch (port->state) {\n\tcase TOGGLING:\n\t\tif (tcpm_port_is_debug(port) || tcpm_port_is_audio(port) ||\n\t\t    tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_ATTACH_WAIT, 0);\n\t\telse if (tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_ATTACH_WAIT, 0);\n\t\tbreak;\n\tcase CHECK_CONTAMINANT:\n\t\t \n\t\tbreak;\n\tcase SRC_UNATTACHED:\n\tcase ACC_UNATTACHED:\n\t\tif (tcpm_port_is_debug(port) || tcpm_port_is_audio(port) ||\n\t\t    tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_ATTACH_WAIT, 0);\n\t\tbreak;\n\tcase SRC_ATTACH_WAIT:\n\t\tif (tcpm_port_is_disconnected(port) ||\n\t\t    tcpm_port_is_audio_detached(port))\n\t\t\ttcpm_set_state(port, SRC_UNATTACHED, 0);\n\t\telse if (cc1 != old_cc1 || cc2 != old_cc2)\n\t\t\ttcpm_set_state(port, SRC_ATTACH_WAIT, 0);\n\t\tbreak;\n\tcase SRC_ATTACHED:\n\tcase SRC_STARTUP:\n\tcase SRC_SEND_CAPABILITIES:\n\tcase SRC_READY:\n\t\tif (tcpm_port_is_disconnected(port) ||\n\t\t    !tcpm_port_is_source(port)) {\n\t\t\tif (port->port_type == TYPEC_PORT_SRC)\n\t\t\t\ttcpm_set_state(port, SRC_UNATTACHED, tcpm_wait_for_discharge(port));\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SNK_UNATTACHED, tcpm_wait_for_discharge(port));\n\t\t}\n\t\tbreak;\n\tcase SNK_UNATTACHED:\n\t\tif (tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_ATTACH_WAIT, 0);\n\t\tbreak;\n\tcase SNK_ATTACH_WAIT:\n\t\tif ((port->cc1 == TYPEC_CC_OPEN &&\n\t\t     port->cc2 != TYPEC_CC_OPEN) ||\n\t\t    (port->cc1 != TYPEC_CC_OPEN &&\n\t\t     port->cc2 == TYPEC_CC_OPEN))\n\t\t\tnew_state = SNK_DEBOUNCED;\n\t\telse if (tcpm_port_is_disconnected(port))\n\t\t\tnew_state = SNK_UNATTACHED;\n\t\telse\n\t\t\tbreak;\n\t\tif (new_state != port->delayed_state)\n\t\t\ttcpm_set_state(port, SNK_ATTACH_WAIT, 0);\n\t\tbreak;\n\tcase SNK_DEBOUNCED:\n\t\tif (tcpm_port_is_disconnected(port))\n\t\t\tnew_state = SNK_UNATTACHED;\n\t\telse if (port->vbus_present)\n\t\t\tnew_state = tcpm_try_src(port) ? SRC_TRY : SNK_ATTACHED;\n\t\telse\n\t\t\tnew_state = SNK_UNATTACHED;\n\t\tif (new_state != port->delayed_state)\n\t\t\ttcpm_set_state(port, SNK_DEBOUNCED, 0);\n\t\tbreak;\n\tcase SNK_READY:\n\t\t \n\t\tif (!port->auto_vbus_discharge_enabled && tcpm_port_is_disconnected(port))\n\t\t\ttcpm_set_state(port, unattached_state(port), 0);\n\t\telse if (!port->pd_capable &&\n\t\t\t (cc1 != old_cc1 || cc2 != old_cc2))\n\t\t\ttcpm_set_current_limit(port,\n\t\t\t\t\t       tcpm_get_current_limit(port),\n\t\t\t\t\t       5000);\n\t\tbreak;\n\n\tcase AUDIO_ACC_ATTACHED:\n\t\tif (cc1 == TYPEC_CC_OPEN || cc2 == TYPEC_CC_OPEN)\n\t\t\ttcpm_set_state(port, AUDIO_ACC_DEBOUNCE, 0);\n\t\tbreak;\n\tcase AUDIO_ACC_DEBOUNCE:\n\t\tif (tcpm_port_is_audio(port))\n\t\t\ttcpm_set_state(port, AUDIO_ACC_ATTACHED, 0);\n\t\tbreak;\n\n\tcase DEBUG_ACC_ATTACHED:\n\t\tif (cc1 == TYPEC_CC_OPEN || cc2 == TYPEC_CC_OPEN)\n\t\t\ttcpm_set_state(port, ACC_UNATTACHED, 0);\n\t\tbreak;\n\n\tcase SNK_TRY:\n\t\t \n\t\tbreak;\n\n\tcase SNK_DISCOVERY:\n\t\t \n\t\tif (tcpm_port_is_disconnected(port))\n\t\t\ttcpm_set_state(port, SNK_DISCOVERY_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SNK_DISCOVERY_DEBOUNCE:\n\t\tbreak;\n\n\tcase SRC_TRYWAIT:\n\t\t \n\t\tif (!port->vbus_present && tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SRC_TRYWAIT_DEBOUNCE:\n\t\tif (port->vbus_present || !tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT, 0);\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE:\n\t\tif (!tcpm_port_is_sink(port)) {\n\t\t\tport->max_wait = 0;\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT, 0);\n\t\t}\n\t\tbreak;\n\tcase SRC_TRY_WAIT:\n\t\tif (tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_TRY_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SRC_TRY_DEBOUNCE:\n\t\ttcpm_set_state(port, SRC_TRY_WAIT, 0);\n\t\tbreak;\n\tcase SNK_TRYWAIT_DEBOUNCE:\n\t\tif (tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_TRYWAIT_VBUS, 0);\n\t\tbreak;\n\tcase SNK_TRYWAIT_VBUS:\n\t\tif (!tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_TRYWAIT_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS:\n\t\tif (!tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT, PD_T_TRY_CC_DEBOUNCE);\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS, 0);\n\t\tbreak;\n\tcase SNK_TRYWAIT:\n\t\t \n\t\tbreak;\n\tcase PR_SWAP_SNK_SRC_SINK_OFF:\n\tcase PR_SWAP_SRC_SNK_TRANSITION_OFF:\n\tcase PR_SWAP_SRC_SNK_SOURCE_OFF:\n\tcase PR_SWAP_SRC_SNK_SOURCE_OFF_CC_DEBOUNCED:\n\tcase PR_SWAP_SNK_SRC_SOURCE_ON:\n\t\t \n\t\tbreak;\n\tcase FR_SWAP_SEND:\n\tcase FR_SWAP_SEND_TIMEOUT:\n\tcase FR_SWAP_SNK_SRC_TRANSITION_TO_OFF:\n\tcase FR_SWAP_SNK_SRC_NEW_SINK_READY:\n\tcase FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED:\n\t\t \n\t\tbreak;\n\n\tcase PORT_RESET:\n\tcase PORT_RESET_WAIT_OFF:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\tif (tcpm_port_is_disconnected(port) && !(port->pwr_role == TYPEC_SINK &&\n\t\t\t\t\t\t\t port->auto_vbus_discharge_enabled))\n\t\t\ttcpm_set_state(port, unattached_state(port), 0);\n\t\tbreak;\n\t}\n}\n\nstatic void _tcpm_pd_vbus_on(struct tcpm_port *port)\n{\n\ttcpm_log_force(port, \"VBUS on\");\n\tport->vbus_present = true;\n\t \n\tport->vbus_vsafe0v = false;\n\n\tswitch (port->state) {\n\tcase SNK_TRANSITION_SINK_VBUS:\n\t\tport->explicit_contract = true;\n\t\ttcpm_set_state(port, SNK_READY, 0);\n\t\tbreak;\n\tcase SNK_DISCOVERY:\n\t\ttcpm_set_state(port, SNK_DISCOVERY, 0);\n\t\tbreak;\n\n\tcase SNK_DEBOUNCED:\n\t\ttcpm_set_state(port, tcpm_try_src(port) ? SRC_TRY\n\t\t\t\t\t\t\t: SNK_ATTACHED,\n\t\t\t\t       0);\n\t\tbreak;\n\tcase SNK_HARD_RESET_WAIT_VBUS:\n\t\ttcpm_set_state(port, SNK_HARD_RESET_SINK_ON, 0);\n\t\tbreak;\n\tcase SRC_ATTACHED:\n\t\ttcpm_set_state(port, SRC_STARTUP, 0);\n\t\tbreak;\n\tcase SRC_HARD_RESET_VBUS_ON:\n\t\ttcpm_set_state(port, SRC_STARTUP, 0);\n\t\tbreak;\n\n\tcase SNK_TRY:\n\t\t \n\t\tbreak;\n\tcase SRC_TRYWAIT:\n\t\t \n\t\tbreak;\n\tcase SRC_TRYWAIT_DEBOUNCE:\n\t\ttcpm_set_state(port, SRC_TRYWAIT, 0);\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE:\n\t\t \n\t\tbreak;\n\tcase SNK_TRYWAIT:\n\t\t \n\t\tbreak;\n\tcase SNK_TRYWAIT_VBUS:\n\t\tif (tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_ATTACHED, 0);\n\t\tbreak;\n\tcase SNK_TRYWAIT_DEBOUNCE:\n\t\t \n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE_CHECK_VBUS:\n\t\tif (port->vbus_present && tcpm_port_is_sink(port))\n\t\t\ttcpm_set_state(port, SNK_ATTACHED, 0);\n\t\tbreak;\n\tcase SRC_TRY_WAIT:\n\tcase SRC_TRY_DEBOUNCE:\n\t\t \n\t\tbreak;\n\tcase FR_SWAP_SEND:\n\tcase FR_SWAP_SEND_TIMEOUT:\n\tcase FR_SWAP_SNK_SRC_TRANSITION_TO_OFF:\n\tcase FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED:\n\t\tif (port->tcpc->frs_sourcing_vbus)\n\t\t\tport->tcpc->frs_sourcing_vbus(port->tcpc);\n\t\tbreak;\n\tcase FR_SWAP_SNK_SRC_NEW_SINK_READY:\n\t\tif (port->tcpc->frs_sourcing_vbus)\n\t\t\tport->tcpc->frs_sourcing_vbus(port->tcpc);\n\t\ttcpm_set_state(port, FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED, 0);\n\t\tbreak;\n\n\tcase PORT_RESET:\n\tcase PORT_RESET_WAIT_OFF:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void _tcpm_pd_vbus_off(struct tcpm_port *port)\n{\n\ttcpm_log_force(port, \"VBUS off\");\n\tport->vbus_present = false;\n\tport->vbus_never_low = false;\n\tswitch (port->state) {\n\tcase SNK_HARD_RESET_SINK_OFF:\n\t\ttcpm_set_state(port, SNK_HARD_RESET_WAIT_VBUS, 0);\n\t\tbreak;\n\tcase HARD_RESET_SEND:\n\t\tbreak;\n\tcase SNK_TRY:\n\t\t \n\t\tbreak;\n\tcase SRC_TRYWAIT:\n\t\t \n\t\tif (tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, SRC_TRYWAIT_DEBOUNCE, 0);\n\t\tbreak;\n\tcase SNK_TRY_WAIT_DEBOUNCE:\n\t\t \n\t\tbreak;\n\tcase SNK_TRYWAIT:\n\tcase SNK_TRYWAIT_VBUS:\n\tcase SNK_TRYWAIT_DEBOUNCE:\n\t\tbreak;\n\tcase SNK_ATTACH_WAIT:\n\tcase SNK_DEBOUNCED:\n\t\t \n\t\tbreak;\n\n\tcase SNK_NEGOTIATE_CAPABILITIES:\n\t\tbreak;\n\n\tcase PR_SWAP_SRC_SNK_TRANSITION_OFF:\n\t\ttcpm_set_state(port, PR_SWAP_SRC_SNK_SOURCE_OFF, 0);\n\t\tbreak;\n\n\tcase PR_SWAP_SNK_SRC_SINK_OFF:\n\t\t \n\t\tbreak;\n\n\tcase PR_SWAP_SNK_SRC_SOURCE_ON:\n\t\t \n\t\tbreak;\n\n\tcase PORT_RESET_WAIT_OFF:\n\t\ttcpm_set_state(port, tcpm_default_state(port), 0);\n\t\tbreak;\n\n\tcase SRC_TRY_WAIT:\n\tcase SRC_TRY_DEBOUNCE:\n\t\t \n\t\tbreak;\n\n\tcase SRC_STARTUP:\n\tcase SRC_SEND_CAPABILITIES:\n\tcase SRC_SEND_CAPABILITIES_TIMEOUT:\n\tcase SRC_NEGOTIATE_CAPABILITIES:\n\tcase SRC_TRANSITION_SUPPLY:\n\tcase SRC_READY:\n\tcase SRC_WAIT_NEW_CAPABILITIES:\n\t\t \n\t\tif (port->port_type == TYPEC_PORT_SRC)\n\t\t\ttcpm_set_state(port, SRC_UNATTACHED, tcpm_wait_for_discharge(port));\n\t\telse\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED, tcpm_wait_for_discharge(port));\n\t\tbreak;\n\n\tcase PORT_RESET:\n\t\t \n\t\tbreak;\n\n\tcase FR_SWAP_SEND:\n\tcase FR_SWAP_SEND_TIMEOUT:\n\tcase FR_SWAP_SNK_SRC_TRANSITION_TO_OFF:\n\tcase FR_SWAP_SNK_SRC_NEW_SINK_READY:\n\tcase FR_SWAP_SNK_SRC_SOURCE_VBUS_APPLIED:\n\t\t \n\t\tbreak;\n\n\tcase SNK_HARD_RESET_WAIT_VBUS:\n\t\t \n\t\tbreak;\n\n\tdefault:\n\t\tif (port->pwr_role == TYPEC_SINK && port->attached)\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED, tcpm_wait_for_discharge(port));\n\t\tbreak;\n\t}\n}\n\nstatic void _tcpm_pd_vbus_vsafe0v(struct tcpm_port *port)\n{\n\ttcpm_log_force(port, \"VBUS VSAFE0V\");\n\tport->vbus_vsafe0v = true;\n\tswitch (port->state) {\n\tcase SRC_HARD_RESET_VBUS_OFF:\n\t\t \n\t\ttcpm_set_state(port, SRC_HARD_RESET_VBUS_ON, PD_T_SRC_RECOVER);\n\t\tbreak;\n\tcase SRC_ATTACH_WAIT:\n\t\tif (tcpm_port_is_source(port))\n\t\t\ttcpm_set_state(port, tcpm_try_snk(port) ? SNK_TRY : SRC_ATTACHED,\n\t\t\t\t       PD_T_CC_DEBOUNCE);\n\t\tbreak;\n\tcase SRC_STARTUP:\n\tcase SRC_SEND_CAPABILITIES:\n\tcase SRC_SEND_CAPABILITIES_TIMEOUT:\n\tcase SRC_NEGOTIATE_CAPABILITIES:\n\tcase SRC_TRANSITION_SUPPLY:\n\tcase SRC_READY:\n\tcase SRC_WAIT_NEW_CAPABILITIES:\n\t\tif (port->auto_vbus_discharge_enabled) {\n\t\t\tif (port->port_type == TYPEC_PORT_SRC)\n\t\t\t\ttcpm_set_state(port, SRC_UNATTACHED, 0);\n\t\t\telse\n\t\t\t\ttcpm_set_state(port, SNK_UNATTACHED, 0);\n\t\t}\n\t\tbreak;\n\tcase PR_SWAP_SNK_SRC_SINK_OFF:\n\tcase PR_SWAP_SNK_SRC_SOURCE_ON:\n\t\t \n\t\tbreak;\n\tcase SNK_ATTACH_WAIT:\n\tcase SNK_DEBOUNCED:\n\t\t \n\t\tbreak;\n\tcase SNK_HARD_RESET_WAIT_VBUS:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tif (port->pwr_role == TYPEC_SINK && port->auto_vbus_discharge_enabled)\n\t\t\ttcpm_set_state(port, SNK_UNATTACHED, 0);\n\t\tbreak;\n\t}\n}\n\nstatic void _tcpm_pd_hard_reset(struct tcpm_port *port)\n{\n\ttcpm_log_force(port, \"Received hard reset\");\n\tif (port->bist_request == BDO_MODE_TESTDATA && port->tcpc->set_bist_data)\n\t\tport->tcpc->set_bist_data(port->tcpc, false);\n\n\tswitch (port->state) {\n\tcase ERROR_RECOVERY:\n\tcase PORT_RESET:\n\tcase PORT_RESET_WAIT_OFF:\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (port->ams != NONE_AMS)\n\t\tport->ams = NONE_AMS;\n\tif (port->hard_reset_count < PD_N_HARD_RESET_COUNT)\n\t\tport->ams = HARD_RESET;\n\t \n\ttcpm_set_state(port,\n\t\t       port->hard_reset_count < PD_N_HARD_RESET_COUNT ?\n\t\t\t\tHARD_RESET_START : ERROR_RECOVERY,\n\t\t       0);\n}\n\nstatic void tcpm_pd_event_handler(struct kthread_work *work)\n{\n\tstruct tcpm_port *port = container_of(work, struct tcpm_port,\n\t\t\t\t\t      event_work);\n\tu32 events;\n\n\tmutex_lock(&port->lock);\n\n\tspin_lock(&port->pd_event_lock);\n\twhile (port->pd_events) {\n\t\tevents = port->pd_events;\n\t\tport->pd_events = 0;\n\t\tspin_unlock(&port->pd_event_lock);\n\t\tif (events & TCPM_RESET_EVENT)\n\t\t\t_tcpm_pd_hard_reset(port);\n\t\tif (events & TCPM_VBUS_EVENT) {\n\t\t\tbool vbus;\n\n\t\t\tvbus = port->tcpc->get_vbus(port->tcpc);\n\t\t\tif (vbus) {\n\t\t\t\t_tcpm_pd_vbus_on(port);\n\t\t\t} else {\n\t\t\t\t_tcpm_pd_vbus_off(port);\n\t\t\t\t \n\t\t\t\tif (!port->tcpc->is_vbus_vsafe0v ||\n\t\t\t\t    port->tcpc->is_vbus_vsafe0v(port->tcpc))\n\t\t\t\t\t_tcpm_pd_vbus_vsafe0v(port);\n\t\t\t}\n\t\t}\n\t\tif (events & TCPM_CC_EVENT) {\n\t\t\tenum typec_cc_status cc1, cc2;\n\n\t\t\tif (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0)\n\t\t\t\t_tcpm_cc_change(port, cc1, cc2);\n\t\t}\n\t\tif (events & TCPM_FRS_EVENT) {\n\t\t\tif (port->state == SNK_READY) {\n\t\t\t\tint ret;\n\n\t\t\t\tport->upcoming_state = FR_SWAP_SEND;\n\t\t\t\tret = tcpm_ams_start(port, FAST_ROLE_SWAP);\n\t\t\t\tif (ret == -EAGAIN)\n\t\t\t\t\tport->upcoming_state = INVALID_STATE;\n\t\t\t} else {\n\t\t\t\ttcpm_log(port, \"Discarding FRS_SIGNAL! Not in sink ready\");\n\t\t\t}\n\t\t}\n\t\tif (events & TCPM_SOURCING_VBUS) {\n\t\t\ttcpm_log(port, \"sourcing vbus\");\n\t\t\t \n\t\t\tport->vbus_source = true;\n\t\t\t_tcpm_pd_vbus_on(port);\n\t\t}\n\t\tif (events & TCPM_PORT_CLEAN) {\n\t\t\ttcpm_log(port, \"port clean\");\n\t\t\tif (port->state == CHECK_CONTAMINANT) {\n\t\t\t\tif (tcpm_start_toggling(port, tcpm_rp_cc(port)))\n\t\t\t\t\ttcpm_set_state(port, TOGGLING, 0);\n\t\t\t\telse\n\t\t\t\t\ttcpm_set_state(port, tcpm_default_state(port), 0);\n\t\t\t}\n\t\t}\n\n\t\tspin_lock(&port->pd_event_lock);\n\t}\n\tspin_unlock(&port->pd_event_lock);\n\tmutex_unlock(&port->lock);\n}\n\nvoid tcpm_cc_change(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events |= TCPM_CC_EVENT;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_cc_change);\n\nvoid tcpm_vbus_change(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events |= TCPM_VBUS_EVENT;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_vbus_change);\n\nvoid tcpm_pd_hard_reset(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events = TCPM_RESET_EVENT;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_pd_hard_reset);\n\nvoid tcpm_sink_frs(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events |= TCPM_FRS_EVENT;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_sink_frs);\n\nvoid tcpm_sourcing_vbus(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events |= TCPM_SOURCING_VBUS;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_sourcing_vbus);\n\nvoid tcpm_port_clean(struct tcpm_port *port)\n{\n\tspin_lock(&port->pd_event_lock);\n\tport->pd_events |= TCPM_PORT_CLEAN;\n\tspin_unlock(&port->pd_event_lock);\n\tkthread_queue_work(port->wq, &port->event_work);\n}\nEXPORT_SYMBOL_GPL(tcpm_port_clean);\n\nbool tcpm_port_is_toggling(struct tcpm_port *port)\n{\n\treturn port->port_type == TYPEC_PORT_DRP && port->state == TOGGLING;\n}\nEXPORT_SYMBOL_GPL(tcpm_port_is_toggling);\n\nstatic void tcpm_enable_frs_work(struct kthread_work *work)\n{\n\tstruct tcpm_port *port = container_of(work, struct tcpm_port, enable_frs);\n\tint ret;\n\n\tmutex_lock(&port->lock);\n\t \n\tif (!port->connected || port->port_type != TYPEC_PORT_DRP ||\n\t    port->pwr_opmode != TYPEC_PWR_MODE_PD ||\n\t    !port->tcpc->enable_frs ||\n\t     \n\t    port->sink_cap_done || port->negotiated_rev < PD_REV30)\n\t\tgoto unlock;\n\n\t \n\tif (port->state != SNK_READY || port->vdm_sm_running || port->send_discover)\n\t\tgoto resched;\n\n\tport->upcoming_state = GET_SINK_CAP;\n\tret = tcpm_ams_start(port, GET_SINK_CAPABILITIES);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t} else {\n\t\tport->sink_cap_done = true;\n\t\tgoto unlock;\n\t}\nresched:\n\tmod_enable_frs_delayed_work(port, GET_SINK_CAP_RETRY_MS);\nunlock:\n\tmutex_unlock(&port->lock);\n}\n\nstatic void tcpm_send_discover_work(struct kthread_work *work)\n{\n\tstruct tcpm_port *port = container_of(work, struct tcpm_port, send_discover_work);\n\n\tmutex_lock(&port->lock);\n\t \n\tif (!port->send_discover)\n\t\tgoto unlock;\n\n\tif (port->data_role == TYPEC_DEVICE && port->negotiated_rev < PD_REV30) {\n\t\tport->send_discover = false;\n\t\tgoto unlock;\n\t}\n\n\t \n\tif ((port->state != SRC_READY && port->state != SNK_READY) || port->vdm_sm_running) {\n\t\tmod_send_discover_delayed_work(port, SEND_DISCOVER_RETRY_MS);\n\t\tgoto unlock;\n\t}\n\n\ttcpm_send_vdm(port, USB_SID_PD, CMD_DISCOVER_IDENT, NULL, 0);\n\nunlock:\n\tmutex_unlock(&port->lock);\n}\n\nstatic int tcpm_dr_set(struct typec_port *p, enum typec_data_role data)\n{\n\tstruct tcpm_port *port = typec_get_drvdata(p);\n\tint ret;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (port->typec_caps.data != TYPEC_PORT_DRD) {\n\t\tret = -EINVAL;\n\t\tgoto port_unlock;\n\t}\n\tif (port->state != SRC_READY && port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\tif (port->data_role == data) {\n\t\tret = 0;\n\t\tgoto port_unlock;\n\t}\n\n\t \n\n\tif (!port->pd_capable) {\n\t\t \n\t\tif (port->try_role == TYPEC_NO_PREFERRED_ROLE ||\n\t\t    port->try_role == port->pwr_role) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto port_unlock;\n\t\t}\n\t\tport->non_pd_role_swap = true;\n\t\ttcpm_set_state(port, PORT_RESET, 0);\n\t} else {\n\t\tport->upcoming_state = DR_SWAP_SEND;\n\t\tret = tcpm_ams_start(port, DATA_ROLE_SWAP);\n\t\tif (ret == -EAGAIN) {\n\t\t\tport->upcoming_state = INVALID_STATE;\n\t\t\tgoto port_unlock;\n\t\t}\n\t}\n\n\tport->swap_status = 0;\n\tport->swap_pending = true;\n\treinit_completion(&port->swap_complete);\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->swap_complete,\n\t\t\t\tmsecs_to_jiffies(PD_ROLE_SWAP_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->swap_status;\n\n\tport->non_pd_role_swap = false;\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\treturn ret;\n}\n\nstatic int tcpm_pr_set(struct typec_port *p, enum typec_role role)\n{\n\tstruct tcpm_port *port = typec_get_drvdata(p);\n\tint ret;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (port->port_type != TYPEC_PORT_DRP) {\n\t\tret = -EINVAL;\n\t\tgoto port_unlock;\n\t}\n\tif (port->state != SRC_READY && port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\tif (role == port->pwr_role) {\n\t\tret = 0;\n\t\tgoto port_unlock;\n\t}\n\n\tport->upcoming_state = PR_SWAP_SEND;\n\tret = tcpm_ams_start(port, POWER_ROLE_SWAP);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\tgoto port_unlock;\n\t}\n\n\tport->swap_status = 0;\n\tport->swap_pending = true;\n\treinit_completion(&port->swap_complete);\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->swap_complete,\n\t\t\t\tmsecs_to_jiffies(PD_ROLE_SWAP_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->swap_status;\n\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\treturn ret;\n}\n\nstatic int tcpm_vconn_set(struct typec_port *p, enum typec_role role)\n{\n\tstruct tcpm_port *port = typec_get_drvdata(p);\n\tint ret;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (port->state != SRC_READY && port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\tif (role == port->vconn_role) {\n\t\tret = 0;\n\t\tgoto port_unlock;\n\t}\n\n\tport->upcoming_state = VCONN_SWAP_SEND;\n\tret = tcpm_ams_start(port, VCONN_SWAP);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\tgoto port_unlock;\n\t}\n\n\tport->swap_status = 0;\n\tport->swap_pending = true;\n\treinit_completion(&port->swap_complete);\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->swap_complete,\n\t\t\t\tmsecs_to_jiffies(PD_ROLE_SWAP_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->swap_status;\n\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\treturn ret;\n}\n\nstatic int tcpm_try_role(struct typec_port *p, int role)\n{\n\tstruct tcpm_port *port = typec_get_drvdata(p);\n\tstruct tcpc_dev\t*tcpc = port->tcpc;\n\tint ret = 0;\n\n\tmutex_lock(&port->lock);\n\tif (tcpc->try_role)\n\t\tret = tcpc->try_role(tcpc, role);\n\tif (!ret)\n\t\tport->try_role = role;\n\tport->try_src_count = 0;\n\tport->try_snk_count = 0;\n\tmutex_unlock(&port->lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_pps_set_op_curr(struct tcpm_port *port, u16 req_op_curr)\n{\n\tunsigned int target_mw;\n\tint ret;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (!port->pps_data.active) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto port_unlock;\n\t}\n\n\tif (port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\tif (req_op_curr > port->pps_data.max_curr) {\n\t\tret = -EINVAL;\n\t\tgoto port_unlock;\n\t}\n\n\ttarget_mw = (req_op_curr * port->supply_voltage) / 1000;\n\tif (target_mw < port->operating_snk_mw) {\n\t\tret = -EINVAL;\n\t\tgoto port_unlock;\n\t}\n\n\tport->upcoming_state = SNK_NEGOTIATE_PPS_CAPABILITIES;\n\tret = tcpm_ams_start(port, POWER_NEGOTIATION);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\tgoto port_unlock;\n\t}\n\n\t \n\treq_op_curr = req_op_curr - (req_op_curr % RDO_PROG_CURR_MA_STEP);\n\n\treinit_completion(&port->pps_complete);\n\tport->pps_data.req_op_curr = req_op_curr;\n\tport->pps_status = 0;\n\tport->pps_pending = true;\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->pps_complete,\n\t\t\t\tmsecs_to_jiffies(PD_PPS_CTRL_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->pps_status;\n\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_pps_set_out_volt(struct tcpm_port *port, u16 req_out_volt)\n{\n\tunsigned int target_mw;\n\tint ret;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (!port->pps_data.active) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto port_unlock;\n\t}\n\n\tif (port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\ttarget_mw = (port->current_limit * req_out_volt) / 1000;\n\tif (target_mw < port->operating_snk_mw) {\n\t\tret = -EINVAL;\n\t\tgoto port_unlock;\n\t}\n\n\tport->upcoming_state = SNK_NEGOTIATE_PPS_CAPABILITIES;\n\tret = tcpm_ams_start(port, POWER_NEGOTIATION);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\tgoto port_unlock;\n\t}\n\n\t \n\treq_out_volt = req_out_volt - (req_out_volt % RDO_PROG_VOLT_MV_STEP);\n\n\treinit_completion(&port->pps_complete);\n\tport->pps_data.req_out_volt = req_out_volt;\n\tport->pps_status = 0;\n\tport->pps_pending = true;\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->pps_complete,\n\t\t\t\tmsecs_to_jiffies(PD_PPS_CTRL_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->pps_status;\n\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_pps_activate(struct tcpm_port *port, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&port->swap_lock);\n\tmutex_lock(&port->lock);\n\n\tif (!port->pps_data.supported) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto port_unlock;\n\t}\n\n\t \n\tif (!port->pps_data.active && !activate)\n\t\tgoto port_unlock;\n\n\tif (port->state != SNK_READY) {\n\t\tret = -EAGAIN;\n\t\tgoto port_unlock;\n\t}\n\n\tif (activate)\n\t\tport->upcoming_state = SNK_NEGOTIATE_PPS_CAPABILITIES;\n\telse\n\t\tport->upcoming_state = SNK_NEGOTIATE_CAPABILITIES;\n\tret = tcpm_ams_start(port, POWER_NEGOTIATION);\n\tif (ret == -EAGAIN) {\n\t\tport->upcoming_state = INVALID_STATE;\n\t\tgoto port_unlock;\n\t}\n\n\treinit_completion(&port->pps_complete);\n\tport->pps_status = 0;\n\tport->pps_pending = true;\n\n\t \n\tif (activate) {\n\t\tport->pps_data.req_out_volt = port->supply_voltage;\n\t\tport->pps_data.req_op_curr = port->current_limit;\n\t}\n\tmutex_unlock(&port->lock);\n\n\tif (!wait_for_completion_timeout(&port->pps_complete,\n\t\t\t\tmsecs_to_jiffies(PD_PPS_CTRL_TIMEOUT)))\n\t\tret = -ETIMEDOUT;\n\telse\n\t\tret = port->pps_status;\n\n\tgoto swap_unlock;\n\nport_unlock:\n\tmutex_unlock(&port->lock);\nswap_unlock:\n\tmutex_unlock(&port->swap_lock);\n\n\treturn ret;\n}\n\nstatic void tcpm_init(struct tcpm_port *port)\n{\n\tenum typec_cc_status cc1, cc2;\n\n\tport->tcpc->init(port->tcpc);\n\n\ttcpm_reset_port(port);\n\n\t \n\tport->vbus_present = port->tcpc->get_vbus(port->tcpc);\n\tif (port->vbus_present)\n\t\tport->vbus_never_low = true;\n\n\t \n\tif (port->vbus_present)\n\t\tport->vbus_vsafe0v = false;\n\telse if (!port->tcpc->is_vbus_vsafe0v)\n\t\tport->vbus_vsafe0v = true;\n\telse\n\t\tport->vbus_vsafe0v = port->tcpc->is_vbus_vsafe0v(port->tcpc);\n\n\ttcpm_set_state(port, tcpm_default_state(port), 0);\n\n\tif (port->tcpc->get_cc(port->tcpc, &cc1, &cc2) == 0)\n\t\t_tcpm_cc_change(port, cc1, cc2);\n\n\t \n\ttcpm_set_state(port, PORT_RESET, 0);\n}\n\nstatic int tcpm_port_type_set(struct typec_port *p, enum typec_port_type type)\n{\n\tstruct tcpm_port *port = typec_get_drvdata(p);\n\n\tmutex_lock(&port->lock);\n\tif (type == port->port_type)\n\t\tgoto port_unlock;\n\n\tport->port_type = type;\n\n\tif (!port->connected) {\n\t\ttcpm_set_state(port, PORT_RESET, 0);\n\t} else if (type == TYPEC_PORT_SNK) {\n\t\tif (!(port->pwr_role == TYPEC_SINK &&\n\t\t      port->data_role == TYPEC_DEVICE))\n\t\t\ttcpm_set_state(port, PORT_RESET, 0);\n\t} else if (type == TYPEC_PORT_SRC) {\n\t\tif (!(port->pwr_role == TYPEC_SOURCE &&\n\t\t      port->data_role == TYPEC_HOST))\n\t\t\ttcpm_set_state(port, PORT_RESET, 0);\n\t}\n\nport_unlock:\n\tmutex_unlock(&port->lock);\n\treturn 0;\n}\n\nstatic const struct typec_operations tcpm_ops = {\n\t.try_role = tcpm_try_role,\n\t.dr_set = tcpm_dr_set,\n\t.pr_set = tcpm_pr_set,\n\t.vconn_set = tcpm_vconn_set,\n\t.port_type_set = tcpm_port_type_set\n};\n\nvoid tcpm_tcpc_reset(struct tcpm_port *port)\n{\n\tmutex_lock(&port->lock);\n\t \n\ttcpm_init(port);\n\tmutex_unlock(&port->lock);\n}\nEXPORT_SYMBOL_GPL(tcpm_tcpc_reset);\n\nstatic void tcpm_port_unregister_pd(struct tcpm_port *port)\n{\n\tusb_power_delivery_unregister_capabilities(port->port_sink_caps);\n\tport->port_sink_caps = NULL;\n\tusb_power_delivery_unregister_capabilities(port->port_source_caps);\n\tport->port_source_caps = NULL;\n\tusb_power_delivery_unregister(port->pd);\n\tport->pd = NULL;\n}\n\nstatic int tcpm_port_register_pd(struct tcpm_port *port)\n{\n\tstruct usb_power_delivery_desc desc = { port->typec_caps.pd_revision };\n\tstruct usb_power_delivery_capabilities_desc caps = { };\n\tstruct usb_power_delivery_capabilities *cap;\n\tint ret;\n\n\tif (!port->nr_src_pdo && !port->nr_snk_pdo)\n\t\treturn 0;\n\n\tport->pd = usb_power_delivery_register(port->dev, &desc);\n\tif (IS_ERR(port->pd)) {\n\t\tret = PTR_ERR(port->pd);\n\t\tgoto err_unregister;\n\t}\n\n\tif (port->nr_src_pdo) {\n\t\tmemcpy_and_pad(caps.pdo, sizeof(caps.pdo), port->src_pdo,\n\t\t\t       port->nr_src_pdo * sizeof(u32), 0);\n\t\tcaps.role = TYPEC_SOURCE;\n\n\t\tcap = usb_power_delivery_register_capabilities(port->pd, &caps);\n\t\tif (IS_ERR(cap)) {\n\t\t\tret = PTR_ERR(cap);\n\t\t\tgoto err_unregister;\n\t\t}\n\n\t\tport->port_source_caps = cap;\n\t}\n\n\tif (port->nr_snk_pdo) {\n\t\tmemcpy_and_pad(caps.pdo, sizeof(caps.pdo), port->snk_pdo,\n\t\t\t       port->nr_snk_pdo * sizeof(u32), 0);\n\t\tcaps.role = TYPEC_SINK;\n\n\t\tcap = usb_power_delivery_register_capabilities(port->pd, &caps);\n\t\tif (IS_ERR(cap)) {\n\t\t\tret = PTR_ERR(cap);\n\t\t\tgoto err_unregister;\n\t\t}\n\n\t\tport->port_sink_caps = cap;\n\t}\n\n\treturn 0;\n\nerr_unregister:\n\ttcpm_port_unregister_pd(port);\n\n\treturn ret;\n}\n\nstatic int tcpm_fw_get_caps(struct tcpm_port *port,\n\t\t\t    struct fwnode_handle *fwnode)\n{\n\tconst char *opmode_str;\n\tint ret;\n\tu32 mw, frs_current;\n\n\tif (!fwnode)\n\t\treturn -EINVAL;\n\n\t \n\tfw_devlink_purge_absent_suppliers(fwnode);\n\n\tret = typec_get_fw_cap(&port->typec_caps, fwnode);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport->port_type = port->typec_caps.type;\n\tport->pd_supported = !fwnode_property_read_bool(fwnode, \"pd-disable\");\n\n\tport->slow_charger_loop = fwnode_property_read_bool(fwnode, \"slow-charger-loop\");\n\tif (port->port_type == TYPEC_PORT_SNK)\n\t\tgoto sink;\n\n\t \n\tif (port->pd_supported) {\n\t\tret = fwnode_property_count_u32(fwnode, \"source-pdos\");\n\t\tif (ret == 0)\n\t\t\treturn -EINVAL;\n\t\telse if (ret < 0)\n\t\t\treturn ret;\n\n\t\tport->nr_src_pdo = min(ret, PDO_MAX_OBJECTS);\n\t\tret = fwnode_property_read_u32_array(fwnode, \"source-pdos\",\n\t\t\t\t\t\t     port->src_pdo, port->nr_src_pdo);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = tcpm_validate_caps(port, port->src_pdo, port->nr_src_pdo);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tret = fwnode_property_read_string(fwnode, \"typec-power-opmode\", &opmode_str);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = typec_find_pwr_opmode(opmode_str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tport->src_rp = tcpm_pwr_opmode_to_rp(ret);\n\t}\n\n\tif (port->port_type == TYPEC_PORT_SRC)\n\t\treturn 0;\n\nsink:\n\tport->self_powered = fwnode_property_read_bool(fwnode, \"self-powered\");\n\n\tif (!port->pd_supported)\n\t\treturn 0;\n\n\t \n\tret = fwnode_property_count_u32(fwnode, \"sink-pdos\");\n\tif (ret <= 0)\n\t\treturn -EINVAL;\n\n\tport->nr_snk_pdo = min(ret, PDO_MAX_OBJECTS);\n\tret = fwnode_property_read_u32_array(fwnode, \"sink-pdos\",\n\t\t\t\t\t     port->snk_pdo, port->nr_snk_pdo);\n\tif ((ret < 0) || tcpm_validate_caps(port, port->snk_pdo,\n\t\t\t\t\t    port->nr_snk_pdo))\n\t\treturn -EINVAL;\n\n\tif (fwnode_property_read_u32(fwnode, \"op-sink-microwatt\", &mw) < 0)\n\t\treturn -EINVAL;\n\tport->operating_snk_mw = mw / 1000;\n\n\t \n\tif (port->port_type == TYPEC_PORT_DRP) {\n\t\tret = fwnode_property_read_u32(fwnode, \"new-source-frs-typec-current\",\n\t\t\t\t\t       &frs_current);\n\t\tif (ret >= 0 && frs_current <= FRS_5V_3A)\n\t\t\tport->new_source_frs_current = frs_current;\n\t}\n\n\t \n\tret = fwnode_property_count_u32(fwnode, \"sink-vdos\");\n\tif (ret < 0)\n\t\tret = 0;\n\n\tport->nr_snk_vdo = min(ret, VDO_MAX_OBJECTS);\n\tif (port->nr_snk_vdo) {\n\t\tret = fwnode_property_read_u32_array(fwnode, \"sink-vdos\",\n\t\t\t\t\t\t     port->snk_vdo,\n\t\t\t\t\t\t     port->nr_snk_vdo);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tif (port->nr_snk_vdo) {\n\t\tret = fwnode_property_count_u32(fwnode, \"sink-vdos-v1\");\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\telse if (ret == 0)\n\t\t\treturn -ENODATA;\n\n\t\tport->nr_snk_vdo_v1 = min(ret, VDO_MAX_OBJECTS);\n\t\tret = fwnode_property_read_u32_array(fwnode, \"sink-vdos-v1\",\n\t\t\t\t\t\t     port->snk_vdo_v1,\n\t\t\t\t\t\t     port->nr_snk_vdo_v1);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\n \nenum tcpm_psy_online_states {\n\tTCPM_PSY_OFFLINE = 0,\n\tTCPM_PSY_FIXED_ONLINE,\n\tTCPM_PSY_PROG_ONLINE,\n};\n\nstatic enum power_supply_property tcpm_psy_props[] = {\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic int tcpm_psy_get_online(struct tcpm_port *port,\n\t\t\t       union power_supply_propval *val)\n{\n\tif (port->vbus_charge) {\n\t\tif (port->pps_data.active)\n\t\t\tval->intval = TCPM_PSY_PROG_ONLINE;\n\t\telse\n\t\t\tval->intval = TCPM_PSY_FIXED_ONLINE;\n\t} else {\n\t\tval->intval = TCPM_PSY_OFFLINE;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_voltage_min(struct tcpm_port *port,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tif (port->pps_data.active)\n\t\tval->intval = port->pps_data.min_volt * 1000;\n\telse\n\t\tval->intval = port->supply_voltage * 1000;\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_voltage_max(struct tcpm_port *port,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tif (port->pps_data.active)\n\t\tval->intval = port->pps_data.max_volt * 1000;\n\telse\n\t\tval->intval = port->supply_voltage * 1000;\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_voltage_now(struct tcpm_port *port,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tval->intval = port->supply_voltage * 1000;\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_current_max(struct tcpm_port *port,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tif (port->pps_data.active)\n\t\tval->intval = port->pps_data.max_curr * 1000;\n\telse\n\t\tval->intval = port->current_limit * 1000;\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_current_now(struct tcpm_port *port,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tval->intval = port->current_limit * 1000;\n\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_input_power_limit(struct tcpm_port *port,\n\t\t\t\t\t  union power_supply_propval *val)\n{\n\tunsigned int src_mv, src_ma, max_src_uw = 0;\n\tunsigned int i, tmp;\n\n\tfor (i = 0; i < port->nr_source_caps; i++) {\n\t\tu32 pdo = port->source_caps[i];\n\n\t\tif (pdo_type(pdo) == PDO_TYPE_FIXED) {\n\t\t\tsrc_mv = pdo_fixed_voltage(pdo);\n\t\t\tsrc_ma = pdo_max_current(pdo);\n\t\t\ttmp = src_mv * src_ma;\n\t\t\tmax_src_uw = tmp > max_src_uw ? tmp : max_src_uw;\n\t\t}\n\t}\n\n\tval->intval = max_src_uw;\n\treturn 0;\n}\n\nstatic int tcpm_psy_get_prop(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     union power_supply_propval *val)\n{\n\tstruct tcpm_port *port = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = port->usb_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = tcpm_psy_get_online(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\tret = tcpm_psy_get_voltage_min(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tret = tcpm_psy_get_voltage_max(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = tcpm_psy_get_voltage_now(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tret = tcpm_psy_get_current_max(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tret = tcpm_psy_get_current_now(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_INPUT_POWER_LIMIT:\n\t\ttcpm_psy_get_input_power_limit(port, val);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int tcpm_psy_set_online(struct tcpm_port *port,\n\t\t\t       const union power_supply_propval *val)\n{\n\tint ret;\n\n\tswitch (val->intval) {\n\tcase TCPM_PSY_FIXED_ONLINE:\n\t\tret = tcpm_pps_activate(port, false);\n\t\tbreak;\n\tcase TCPM_PSY_PROG_ONLINE:\n\t\tret = tcpm_pps_activate(port, true);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int tcpm_psy_set_prop(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     const union power_supply_propval *val)\n{\n\tstruct tcpm_port *port = power_supply_get_drvdata(psy);\n\tint ret;\n\n\t \n\tif (!port->pd_supported)\n\t\treturn -EOPNOTSUPP;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tret = tcpm_psy_set_online(port, val);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tret = tcpm_pps_set_out_volt(port, val->intval / 1000);\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tif (val->intval > port->pps_data.max_curr * 1000)\n\t\t\tret = -EINVAL;\n\t\telse\n\t\t\tret = tcpm_pps_set_op_curr(port, val->intval / 1000);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\tpower_supply_changed(port->psy);\n\treturn ret;\n}\n\nstatic int tcpm_psy_prop_writeable(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp)\n{\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic enum power_supply_usb_type tcpm_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_PPS,\n};\n\nstatic const char *tcpm_psy_name_prefix = \"tcpm-source-psy-\";\n\nstatic int devm_tcpm_psy_register(struct tcpm_port *port)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tconst char *port_dev_name = dev_name(port->dev);\n\tsize_t psy_name_len = strlen(tcpm_psy_name_prefix) +\n\t\t\t\t     strlen(port_dev_name) + 1;\n\tchar *psy_name;\n\n\tpsy_cfg.drv_data = port;\n\tpsy_cfg.fwnode = dev_fwnode(port->dev);\n\tpsy_name = devm_kzalloc(port->dev, psy_name_len, GFP_KERNEL);\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\tsnprintf(psy_name, psy_name_len, \"%s%s\", tcpm_psy_name_prefix,\n\t\t port_dev_name);\n\tport->psy_desc.name = psy_name;\n\tport->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\tport->psy_desc.usb_types = tcpm_psy_usb_types;\n\tport->psy_desc.num_usb_types = ARRAY_SIZE(tcpm_psy_usb_types);\n\tport->psy_desc.properties = tcpm_psy_props;\n\tport->psy_desc.num_properties = ARRAY_SIZE(tcpm_psy_props);\n\tport->psy_desc.get_property = tcpm_psy_get_prop;\n\tport->psy_desc.set_property = tcpm_psy_set_prop;\n\tport->psy_desc.property_is_writeable = tcpm_psy_prop_writeable;\n\n\tport->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\n\tport->psy = devm_power_supply_register(port->dev, &port->psy_desc,\n\t\t\t\t\t       &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(port->psy);\n}\n\nstatic enum hrtimer_restart state_machine_timer_handler(struct hrtimer *timer)\n{\n\tstruct tcpm_port *port = container_of(timer, struct tcpm_port, state_machine_timer);\n\n\tif (port->registered)\n\t\tkthread_queue_work(port->wq, &port->state_machine);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum hrtimer_restart vdm_state_machine_timer_handler(struct hrtimer *timer)\n{\n\tstruct tcpm_port *port = container_of(timer, struct tcpm_port, vdm_state_machine_timer);\n\n\tif (port->registered)\n\t\tkthread_queue_work(port->wq, &port->vdm_state_machine);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum hrtimer_restart enable_frs_timer_handler(struct hrtimer *timer)\n{\n\tstruct tcpm_port *port = container_of(timer, struct tcpm_port, enable_frs_timer);\n\n\tif (port->registered)\n\t\tkthread_queue_work(port->wq, &port->enable_frs);\n\treturn HRTIMER_NORESTART;\n}\n\nstatic enum hrtimer_restart send_discover_timer_handler(struct hrtimer *timer)\n{\n\tstruct tcpm_port *port = container_of(timer, struct tcpm_port, send_discover_timer);\n\n\tif (port->registered)\n\t\tkthread_queue_work(port->wq, &port->send_discover_work);\n\treturn HRTIMER_NORESTART;\n}\n\nstruct tcpm_port *tcpm_register_port(struct device *dev, struct tcpc_dev *tcpc)\n{\n\tstruct tcpm_port *port;\n\tint err;\n\n\tif (!dev || !tcpc ||\n\t    !tcpc->get_vbus || !tcpc->set_cc || !tcpc->get_cc ||\n\t    !tcpc->set_polarity || !tcpc->set_vconn || !tcpc->set_vbus ||\n\t    !tcpc->set_pd_rx || !tcpc->set_roles || !tcpc->pd_transmit)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tport = devm_kzalloc(dev, sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tport->dev = dev;\n\tport->tcpc = tcpc;\n\n\tmutex_init(&port->lock);\n\tmutex_init(&port->swap_lock);\n\n\tport->wq = kthread_create_worker(0, dev_name(dev));\n\tif (IS_ERR(port->wq))\n\t\treturn ERR_CAST(port->wq);\n\tsched_set_fifo(port->wq->task);\n\n\tkthread_init_work(&port->state_machine, tcpm_state_machine_work);\n\tkthread_init_work(&port->vdm_state_machine, vdm_state_machine_work);\n\tkthread_init_work(&port->event_work, tcpm_pd_event_handler);\n\tkthread_init_work(&port->enable_frs, tcpm_enable_frs_work);\n\tkthread_init_work(&port->send_discover_work, tcpm_send_discover_work);\n\thrtimer_init(&port->state_machine_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tport->state_machine_timer.function = state_machine_timer_handler;\n\thrtimer_init(&port->vdm_state_machine_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tport->vdm_state_machine_timer.function = vdm_state_machine_timer_handler;\n\thrtimer_init(&port->enable_frs_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tport->enable_frs_timer.function = enable_frs_timer_handler;\n\thrtimer_init(&port->send_discover_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tport->send_discover_timer.function = send_discover_timer_handler;\n\n\tspin_lock_init(&port->pd_event_lock);\n\n\tinit_completion(&port->tx_complete);\n\tinit_completion(&port->swap_complete);\n\tinit_completion(&port->pps_complete);\n\ttcpm_debugfs_init(port);\n\n\terr = tcpm_fw_get_caps(port, tcpc->fwnode);\n\tif (err < 0)\n\t\tgoto out_destroy_wq;\n\n\tport->try_role = port->typec_caps.prefer_role;\n\n\tport->typec_caps.fwnode = tcpc->fwnode;\n\tport->typec_caps.revision = 0x0120;\t \n\tport->typec_caps.pd_revision = 0x0300;\t \n\tport->typec_caps.svdm_version = SVDM_VER_2_0;\n\tport->typec_caps.driver_data = port;\n\tport->typec_caps.ops = &tcpm_ops;\n\tport->typec_caps.orientation_aware = 1;\n\n\tport->partner_desc.identity = &port->partner_ident;\n\tport->port_type = port->typec_caps.type;\n\n\tport->role_sw = usb_role_switch_get(port->dev);\n\tif (!port->role_sw)\n\t\tport->role_sw = fwnode_usb_role_switch_get(tcpc->fwnode);\n\tif (IS_ERR(port->role_sw)) {\n\t\terr = PTR_ERR(port->role_sw);\n\t\tgoto out_destroy_wq;\n\t}\n\n\terr = devm_tcpm_psy_register(port);\n\tif (err)\n\t\tgoto out_role_sw_put;\n\tpower_supply_changed(port->psy);\n\n\terr = tcpm_port_register_pd(port);\n\tif (err)\n\t\tgoto out_role_sw_put;\n\n\tport->typec_caps.pd = port->pd;\n\n\tport->typec_port = typec_register_port(port->dev, &port->typec_caps);\n\tif (IS_ERR(port->typec_port)) {\n\t\terr = PTR_ERR(port->typec_port);\n\t\tgoto out_unregister_pd;\n\t}\n\n\ttypec_port_register_altmodes(port->typec_port,\n\t\t\t\t     &tcpm_altmode_ops, port,\n\t\t\t\t     port->port_altmode, ALTMODE_DISCOVERY_MAX);\n\tport->registered = true;\n\n\tmutex_lock(&port->lock);\n\ttcpm_init(port);\n\tmutex_unlock(&port->lock);\n\n\ttcpm_log(port, \"%s: registered\", dev_name(dev));\n\treturn port;\n\nout_unregister_pd:\n\ttcpm_port_unregister_pd(port);\nout_role_sw_put:\n\tusb_role_switch_put(port->role_sw);\nout_destroy_wq:\n\ttcpm_debugfs_exit(port);\n\tkthread_destroy_worker(port->wq);\n\treturn ERR_PTR(err);\n}\nEXPORT_SYMBOL_GPL(tcpm_register_port);\n\nvoid tcpm_unregister_port(struct tcpm_port *port)\n{\n\tint i;\n\n\tport->registered = false;\n\tkthread_destroy_worker(port->wq);\n\n\thrtimer_cancel(&port->send_discover_timer);\n\thrtimer_cancel(&port->enable_frs_timer);\n\thrtimer_cancel(&port->vdm_state_machine_timer);\n\thrtimer_cancel(&port->state_machine_timer);\n\n\ttcpm_reset_port(port);\n\n\ttcpm_port_unregister_pd(port);\n\n\tfor (i = 0; i < ARRAY_SIZE(port->port_altmode); i++)\n\t\ttypec_unregister_altmode(port->port_altmode[i]);\n\ttypec_unregister_port(port->typec_port);\n\tusb_role_switch_put(port->role_sw);\n\ttcpm_debugfs_exit(port);\n}\nEXPORT_SYMBOL_GPL(tcpm_unregister_port);\n\nMODULE_AUTHOR(\"Guenter Roeck <groeck@chromium.org>\");\nMODULE_DESCRIPTION(\"USB Type-C Port Manager\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}