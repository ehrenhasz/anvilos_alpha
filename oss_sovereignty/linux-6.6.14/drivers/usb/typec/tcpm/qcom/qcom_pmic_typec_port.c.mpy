{
  "module_name": "qcom_pmic_typec_port.c",
  "hash_id": "b39c42ef1bc1c719d01cc4fe386f4467fd7ed630d6247939483352d68d16bc6c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/qcom/qcom_pmic_typec_port.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/workqueue.h>\n#include \"qcom_pmic_typec_port.h\"\n\nstruct pmic_typec_port_irq_data {\n\tint\t\t\t\tvirq;\n\tint\t\t\t\tirq;\n\tstruct pmic_typec_port\t\t*pmic_typec_port;\n};\n\nstruct pmic_typec_port {\n\tstruct device\t\t\t*dev;\n\tstruct tcpm_port\t\t*tcpm_port;\n\tstruct regmap\t\t\t*regmap;\n\tu32\t\t\t\tbase;\n\tunsigned int\t\t\tnr_irqs;\n\tstruct pmic_typec_port_irq_data\t*irq_data;\n\n\tstruct regulator\t\t*vdd_vbus;\n\n\tint\t\t\t\tcc;\n\tbool\t\t\t\tdebouncing_cc;\n\tstruct delayed_work\t\tcc_debounce_dwork;\n\n\tspinlock_t\t\t\tlock;\t \n};\n\nstatic const char * const typec_cc_status_name[] = {\n\t[TYPEC_CC_OPEN]\t\t= \"Open\",\n\t[TYPEC_CC_RA]\t\t= \"Ra\",\n\t[TYPEC_CC_RD]\t\t= \"Rd\",\n\t[TYPEC_CC_RP_DEF]\t= \"Rp-def\",\n\t[TYPEC_CC_RP_1_5]\t= \"Rp-1.5\",\n\t[TYPEC_CC_RP_3_0]\t= \"Rp-3.0\",\n};\n\nstatic const char *rp_unknown = \"unknown\";\n\nstatic const char *cc_to_name(enum typec_cc_status cc)\n{\n\tif (cc > TYPEC_CC_RP_3_0)\n\t\treturn rp_unknown;\n\n\treturn typec_cc_status_name[cc];\n}\n\nstatic const char * const rp_sel_name[] = {\n\t[TYPEC_SRC_RP_SEL_80UA]\t\t= \"Rp-def-80uA\",\n\t[TYPEC_SRC_RP_SEL_180UA]\t= \"Rp-1.5-180uA\",\n\t[TYPEC_SRC_RP_SEL_330UA]\t= \"Rp-3.0-330uA\",\n};\n\nstatic const char *rp_sel_to_name(int rp_sel)\n{\n\tif (rp_sel > TYPEC_SRC_RP_SEL_330UA)\n\t\treturn rp_unknown;\n\n\treturn rp_sel_name[rp_sel];\n}\n\n#define misc_to_cc(msic) !!(misc & CC_ORIENTATION) ? \"cc1\" : \"cc2\"\n#define misc_to_vconn(msic) !!(misc & CC_ORIENTATION) ? \"cc2\" : \"cc1\"\n\nstatic void qcom_pmic_typec_port_cc_debounce(struct work_struct *work)\n{\n\tstruct pmic_typec_port *pmic_typec_port =\n\t\tcontainer_of(work, struct pmic_typec_port, cc_debounce_dwork.work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmic_typec_port->lock, flags);\n\tpmic_typec_port->debouncing_cc = false;\n\tspin_unlock_irqrestore(&pmic_typec_port->lock, flags);\n\n\tdev_dbg(pmic_typec_port->dev, \"Debounce cc complete\\n\");\n}\n\nstatic irqreturn_t pmic_typec_port_isr(int irq, void *dev_id)\n{\n\tstruct pmic_typec_port_irq_data *irq_data = dev_id;\n\tstruct pmic_typec_port *pmic_typec_port = irq_data->pmic_typec_port;\n\tu32 misc_stat;\n\tbool vbus_change = false;\n\tbool cc_change = false;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_port->lock, flags);\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG,\n\t\t\t  &misc_stat);\n\tif (ret)\n\t\tgoto done;\n\n\tswitch (irq_data->virq) {\n\tcase PMIC_TYPEC_VBUS_IRQ:\n\t\tvbus_change = true;\n\t\tbreak;\n\tcase PMIC_TYPEC_CC_STATE_IRQ:\n\tcase PMIC_TYPEC_ATTACH_DETACH_IRQ:\n\t\tif (!pmic_typec_port->debouncing_cc)\n\t\t\tcc_change = true;\n\t\tbreak;\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_port->lock, flags);\n\n\tif (vbus_change)\n\t\ttcpm_vbus_change(pmic_typec_port->tcpm_port);\n\n\tif (cc_change)\n\t\ttcpm_cc_change(pmic_typec_port->tcpm_port);\n\n\treturn IRQ_HANDLED;\n}\n\nint qcom_pmic_typec_port_get_vbus(struct pmic_typec_port *pmic_typec_port)\n{\n\tstruct device *dev = pmic_typec_port->dev;\n\tunsigned int misc;\n\tint ret;\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG,\n\t\t\t  &misc);\n\tif (ret)\n\t\tmisc = 0;\n\n\tdev_dbg(dev, \"get_vbus: 0x%08x detect %d\\n\", misc, !!(misc & TYPEC_VBUS_DETECT));\n\n\treturn !!(misc & TYPEC_VBUS_DETECT);\n}\n\nint qcom_pmic_typec_port_set_vbus(struct pmic_typec_port *pmic_typec_port, bool on)\n{\n\tu32 sm_stat;\n\tu32 val;\n\tint ret;\n\n\tif (on) {\n\t\tret = regulator_enable(pmic_typec_port->vdd_vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = TYPEC_SM_VBUS_VSAFE5V;\n\t} else {\n\t\tret = regulator_disable(pmic_typec_port->vdd_vbus);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tval = TYPEC_SM_VBUS_VSAFE0V;\n\t}\n\n\t \n\tret = regmap_read_poll_timeout(pmic_typec_port->regmap,\n\t\t\t\t       pmic_typec_port->base + TYPEC_SM_STATUS_REG,\n\t\t\t\t       sm_stat, sm_stat & val,\n\t\t\t\t       100, 250000);\n\tif (ret)\n\t\tdev_warn(pmic_typec_port->dev, \"vbus vsafe%dv fail\\n\", on ? 5 : 0);\n\n\treturn 0;\n}\n\nint qcom_pmic_typec_port_get_cc(struct pmic_typec_port *pmic_typec_port,\n\t\t\t\tenum typec_cc_status *cc1,\n\t\t\t\tenum typec_cc_status *cc2)\n{\n\tstruct device *dev = pmic_typec_port->dev;\n\tunsigned int misc, val;\n\tbool attached;\n\tint ret = 0;\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG, &misc);\n\tif (ret)\n\t\tgoto done;\n\n\tattached = !!(misc & CC_ATTACHED);\n\n\tif (pmic_typec_port->debouncing_cc) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t*cc1 = TYPEC_CC_OPEN;\n\t*cc2 = TYPEC_CC_OPEN;\n\n\tif (!attached)\n\t\tgoto done;\n\n\tif (misc & SNK_SRC_MODE) {\n\t\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t\t  pmic_typec_port->base + TYPEC_SRC_STATUS_REG,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tswitch (val & DETECTED_SRC_TYPE_MASK) {\n\t\tcase AUDIO_ACCESS_RA_RA:\n\t\t\tval = TYPEC_CC_RA;\n\t\t\t*cc1 = TYPEC_CC_RA;\n\t\t\t*cc2 = TYPEC_CC_RA;\n\t\t\tbreak;\n\t\tcase SRC_RD_OPEN:\n\t\t\tval = TYPEC_CC_RD;\n\t\t\tbreak;\n\t\tcase SRC_RD_RA_VCONN:\n\t\t\tval = TYPEC_CC_RD;\n\t\t\t*cc1 = TYPEC_CC_RA;\n\t\t\t*cc2 = TYPEC_CC_RA;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"unexpected src status %.2x\\n\", val);\n\t\t\tval = TYPEC_CC_RD;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t\t  pmic_typec_port->base + TYPEC_SNK_STATUS_REG,\n\t\t\t\t  &val);\n\t\tif (ret)\n\t\t\tgoto done;\n\t\tswitch (val & DETECTED_SNK_TYPE_MASK) {\n\t\tcase SNK_RP_STD:\n\t\t\tval = TYPEC_CC_RP_DEF;\n\t\t\tbreak;\n\t\tcase SNK_RP_1P5:\n\t\t\tval = TYPEC_CC_RP_1_5;\n\t\t\tbreak;\n\t\tcase SNK_RP_3P0:\n\t\t\tval = TYPEC_CC_RP_3_0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_warn(dev, \"unexpected snk status %.2x\\n\", val);\n\t\t\tval = TYPEC_CC_RP_DEF;\n\t\t\tbreak;\n\t\t}\n\t\tval = TYPEC_CC_RP_DEF;\n\t}\n\n\tif (misc & CC_ORIENTATION)\n\t\t*cc2 = val;\n\telse\n\t\t*cc1 = val;\n\ndone:\n\tdev_dbg(dev, \"get_cc: misc 0x%08x cc1 0x%08x %s cc2 0x%08x %s attached %d cc=%s\\n\",\n\t\tmisc, *cc1, cc_to_name(*cc1), *cc2, cc_to_name(*cc2), attached,\n\t\tmisc_to_cc(misc));\n\n\treturn ret;\n}\n\nstatic void qcom_pmic_set_cc_debounce(struct pmic_typec_port *pmic_typec_port)\n{\n\tpmic_typec_port->debouncing_cc = true;\n\tschedule_delayed_work(&pmic_typec_port->cc_debounce_dwork,\n\t\t\t      msecs_to_jiffies(2));\n}\n\nint qcom_pmic_typec_port_set_cc(struct pmic_typec_port *pmic_typec_port,\n\t\t\t\tenum typec_cc_status cc)\n{\n\tstruct device *dev = pmic_typec_port->dev;\n\tunsigned int mode, currsrc;\n\tunsigned int misc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_port->lock, flags);\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG,\n\t\t\t  &misc);\n\tif (ret)\n\t\tgoto done;\n\n\tmode = EN_SRC_ONLY;\n\n\tswitch (cc) {\n\tcase TYPEC_CC_OPEN:\n\t\tcurrsrc = TYPEC_SRC_RP_SEL_80UA;\n\t\tbreak;\n\tcase TYPEC_CC_RP_DEF:\n\t\tcurrsrc = TYPEC_SRC_RP_SEL_80UA;\n\t\tbreak;\n\tcase TYPEC_CC_RP_1_5:\n\t\tcurrsrc = TYPEC_SRC_RP_SEL_180UA;\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\tcurrsrc = TYPEC_SRC_RP_SEL_330UA;\n\t\tbreak;\n\tcase TYPEC_CC_RD:\n\t\tcurrsrc = TYPEC_SRC_RP_SEL_80UA;\n\t\tmode = EN_SNK_ONLY;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"unexpected set_cc %d\\n\", cc);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (mode == EN_SRC_ONLY) {\n\t\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t\t   pmic_typec_port->base + TYPEC_CURRSRC_CFG_REG,\n\t\t\t\t   currsrc);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tpmic_typec_port->cc = cc;\n\tqcom_pmic_set_cc_debounce(pmic_typec_port);\n\tret = 0;\n\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_port->lock, flags);\n\n\tdev_dbg(dev, \"set_cc: currsrc=%x %s mode %s debounce %d attached %d cc=%s\\n\",\n\t\tcurrsrc, rp_sel_to_name(currsrc),\n\t\tmode == EN_SRC_ONLY ? \"EN_SRC_ONLY\" : \"EN_SNK_ONLY\",\n\t\tpmic_typec_port->debouncing_cc, !!(misc & CC_ATTACHED),\n\t\tmisc_to_cc(misc));\n\n\treturn ret;\n}\n\nint qcom_pmic_typec_port_set_vconn(struct pmic_typec_port *pmic_typec_port, bool on)\n{\n\tstruct device *dev = pmic_typec_port->dev;\n\tunsigned int orientation, misc, mask, value;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_port->lock, flags);\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG, &misc);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\torientation = (misc & CC_ORIENTATION) ? 0 : VCONN_EN_ORIENTATION;\n\tif (on) {\n\t\tmask = VCONN_EN_ORIENTATION | VCONN_EN_VALUE;\n\t\tvalue = orientation | VCONN_EN_VALUE | VCONN_EN_SRC;\n\t} else {\n\t\tmask = VCONN_EN_VALUE;\n\t\tvalue = 0;\n\t}\n\n\tret = regmap_update_bits(pmic_typec_port->regmap,\n\t\t\t\t pmic_typec_port->base + TYPEC_VCONN_CONTROL_REG,\n\t\t\t\t mask, value);\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_port->lock, flags);\n\n\tdev_dbg(dev, \"set_vconn: orientation %d control 0x%08x state %s cc %s vconn %s\\n\",\n\t\torientation, value, on ? \"on\" : \"off\", misc_to_vconn(misc), misc_to_cc(misc));\n\n\treturn ret;\n}\n\nint qcom_pmic_typec_port_start_toggling(struct pmic_typec_port *pmic_typec_port,\n\t\t\t\t\tenum typec_port_type port_type,\n\t\t\t\t\tenum typec_cc_status cc)\n{\n\tstruct device *dev = pmic_typec_port->dev;\n\tunsigned int misc;\n\tu8 mode = 0;\n\tunsigned long flags;\n\tint ret;\n\n\tswitch (port_type) {\n\tcase TYPEC_PORT_SRC:\n\t\tmode = EN_SRC_ONLY;\n\t\tbreak;\n\tcase TYPEC_PORT_SNK:\n\t\tmode = EN_SNK_ONLY;\n\t\tbreak;\n\tcase TYPEC_PORT_DRP:\n\t\tmode = EN_TRY_SNK;\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&pmic_typec_port->lock, flags);\n\n\tret = regmap_read(pmic_typec_port->regmap,\n\t\t\t  pmic_typec_port->base + TYPEC_MISC_STATUS_REG, &misc);\n\tif (ret)\n\t\tgoto done;\n\n\tdev_dbg(dev, \"start_toggling: misc 0x%08x attached %d port_type %d current cc %d new %d\\n\",\n\t\tmisc, !!(misc & CC_ATTACHED), port_type, pmic_typec_port->cc, cc);\n\n\tqcom_pmic_set_cc_debounce(pmic_typec_port);\n\n\t \n\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t   pmic_typec_port->base + TYPEC_MODE_CFG_REG,\n\t\t\t   TYPEC_DISABLE_CMD);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t   pmic_typec_port->base + TYPEC_MODE_CFG_REG,\n\t\t\t   mode);\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_port->lock, flags);\n\n\treturn ret;\n}\n\n#define TYPEC_INTR_EN_CFG_1_MASK\t\t  \\\n\t(TYPEC_LEGACY_CABLE_INT_EN\t\t| \\\n\t TYPEC_NONCOMPLIANT_LEGACY_CABLE_INT_EN\t| \\\n\t TYPEC_TRYSOURCE_DETECT_INT_EN\t\t| \\\n\t TYPEC_TRYSINK_DETECT_INT_EN\t\t| \\\n\t TYPEC_CCOUT_DETACH_INT_EN\t\t| \\\n\t TYPEC_CCOUT_ATTACH_INT_EN\t\t| \\\n\t TYPEC_VBUS_DEASSERT_INT_EN\t\t| \\\n\t TYPEC_VBUS_ASSERT_INT_EN)\n\n#define TYPEC_INTR_EN_CFG_2_MASK \\\n\t(TYPEC_STATE_MACHINE_CHANGE_INT_EN | TYPEC_VBUS_ERROR_INT_EN | \\\n\t TYPEC_DEBOUNCE_DONE_INT_EN)\n\nint qcom_pmic_typec_port_start(struct pmic_typec_port *pmic_typec_port,\n\t\t\t       struct tcpm_port *tcpm_port)\n{\n\tint i;\n\tint mask;\n\tint ret;\n\n\t \n\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t   pmic_typec_port->base + TYPEC_INTERRUPT_EN_CFG_1_REG,\n\t\t\t   TYPEC_INTR_EN_CFG_1_MASK);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t   pmic_typec_port->base + TYPEC_INTERRUPT_EN_CFG_2_REG,\n\t\t\t   TYPEC_INTR_EN_CFG_2_MASK);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = regmap_write(pmic_typec_port->regmap,\n\t\t\t   pmic_typec_port->base + TYPEC_MODE_CFG_REG, EN_TRY_SNK);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = regmap_update_bits(pmic_typec_port->regmap,\n\t\t\t\t pmic_typec_port->base + TYPEC_VCONN_CONTROL_REG,\n\t\t\t\t VCONN_EN_SRC | VCONN_EN_VALUE, VCONN_EN_SRC);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tmask = SEL_SRC_UPPER_REF | USE_TPD_FOR_EXITING_ATTACHSRC;\n\tret = regmap_update_bits(pmic_typec_port->regmap,\n\t\t\t\t pmic_typec_port->base + TYPEC_EXIT_STATE_CFG_REG,\n\t\t\t\t mask, mask);\n\tif (ret)\n\t\tgoto done;\n\n\tpmic_typec_port->tcpm_port = tcpm_port;\n\n\tfor (i = 0; i < pmic_typec_port->nr_irqs; i++)\n\t\tenable_irq(pmic_typec_port->irq_data[i].irq);\n\ndone:\n\treturn ret;\n}\n\nvoid qcom_pmic_typec_port_stop(struct pmic_typec_port *pmic_typec_port)\n{\n\tint i;\n\n\tfor (i = 0; i < pmic_typec_port->nr_irqs; i++)\n\t\tdisable_irq(pmic_typec_port->irq_data[i].irq);\n}\n\nstruct pmic_typec_port *qcom_pmic_typec_port_alloc(struct device *dev)\n{\n\treturn devm_kzalloc(dev, sizeof(struct pmic_typec_port), GFP_KERNEL);\n}\n\nint qcom_pmic_typec_port_probe(struct platform_device *pdev,\n\t\t\t       struct pmic_typec_port *pmic_typec_port,\n\t\t\t       struct pmic_typec_port_resources *res,\n\t\t\t       struct regmap *regmap,\n\t\t\t       u32 base)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pmic_typec_port_irq_data *irq_data;\n\tint i, ret, irq;\n\n\tif (!res->nr_irqs || res->nr_irqs > PMIC_TYPEC_MAX_IRQS)\n\t\treturn -EINVAL;\n\n\tirq_data = devm_kzalloc(dev, sizeof(*irq_data) * res->nr_irqs,\n\t\t\t\tGFP_KERNEL);\n\tif (!irq_data)\n\t\treturn -ENOMEM;\n\n\tpmic_typec_port->vdd_vbus = devm_regulator_get(dev, \"vdd-vbus\");\n\tif (IS_ERR(pmic_typec_port->vdd_vbus))\n\t\treturn PTR_ERR(pmic_typec_port->vdd_vbus);\n\n\tpmic_typec_port->dev = dev;\n\tpmic_typec_port->base = base;\n\tpmic_typec_port->regmap = regmap;\n\tpmic_typec_port->nr_irqs = res->nr_irqs;\n\tpmic_typec_port->irq_data = irq_data;\n\tspin_lock_init(&pmic_typec_port->lock);\n\tINIT_DELAYED_WORK(&pmic_typec_port->cc_debounce_dwork,\n\t\t\t  qcom_pmic_typec_port_cc_debounce);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tfor (i = 0; i < res->nr_irqs; i++, irq_data++) {\n\t\tirq = platform_get_irq_byname(pdev,\n\t\t\t\t\t      res->irq_params[i].irq_name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tirq_data->pmic_typec_port = pmic_typec_port;\n\t\tirq_data->irq = irq;\n\t\tirq_data->virq = res->irq_params[i].virq;\n\t\tret = devm_request_threaded_irq(dev, irq, NULL, pmic_typec_port_isr,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t\tres->irq_params[i].irq_name,\n\t\t\t\t\t\tirq_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}