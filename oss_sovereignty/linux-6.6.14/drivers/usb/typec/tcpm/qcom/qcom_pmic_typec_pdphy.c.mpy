{
  "module_name": "qcom_pmic_typec_pdphy.c",
  "hash_id": "4532358e3cc13587d81ad5da3c0869b909f05e3acf037a400f8ed9a98f828d1e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/qcom/qcom_pmic_typec_pdphy.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/tcpm.h>\n#include \"qcom_pmic_typec_pdphy.h\"\n\nstruct pmic_typec_pdphy_irq_data {\n\tint\t\t\t\tvirq;\n\tint\t\t\t\tirq;\n\tstruct pmic_typec_pdphy\t\t*pmic_typec_pdphy;\n};\n\nstruct pmic_typec_pdphy {\n\tstruct device\t\t\t*dev;\n\tstruct tcpm_port\t\t*tcpm_port;\n\tstruct regmap\t\t\t*regmap;\n\tu32\t\t\t\tbase;\n\n\tunsigned int\t\t\tnr_irqs;\n\tstruct pmic_typec_pdphy_irq_data\t*irq_data;\n\n\tstruct work_struct\t\treset_work;\n\tstruct work_struct\t\treceive_work;\n\tstruct regulator\t\t*vdd_pdphy;\n\tspinlock_t\t\t\tlock;\t\t \n};\n\nstatic void qcom_pmic_typec_pdphy_reset_on(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tint ret;\n\n\t \n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_TX_CONTROL_REG, 0);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_FRAME_FILTER_REG, 0);\n\tif (ret)\n\t\tgoto err;\n\n\treturn;\nerr:\n\tdev_err(dev, \"pd_reset_on error\\n\");\n}\n\nstatic void qcom_pmic_typec_pdphy_reset_off(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tint ret;\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_FRAME_FILTER_REG,\n\t\t\t   FRAME_FILTER_EN_SOP | FRAME_FILTER_EN_HARD_RESET);\n\tif (ret)\n\t\tdev_err(dev, \"pd_reset_off error\\n\");\n}\n\nstatic void qcom_pmic_typec_pdphy_sig_reset_work(struct work_struct *work)\n{\n\tstruct pmic_typec_pdphy *pmic_typec_pdphy = container_of(work, struct pmic_typec_pdphy,\n\t\t\t\t\t\t     reset_work);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\tqcom_pmic_typec_pdphy_reset_on(pmic_typec_pdphy);\n\tqcom_pmic_typec_pdphy_reset_off(pmic_typec_pdphy);\n\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\ttcpm_pd_hard_reset(pmic_typec_pdphy->tcpm_port);\n}\n\nstatic int\nqcom_pmic_typec_pdphy_clear_tx_control_reg(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tunsigned int val;\n\tint ret;\n\n\t \n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_TX_CONTROL_REG, 0);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = regmap_read(pmic_typec_pdphy->regmap,\n\t\t\t  pmic_typec_pdphy->base + USB_PDPHY_TX_CONTROL_REG, &val);\n\ndone:\n\tif (ret)\n\t\tdev_err(dev, \"pd_clear_tx_control_reg: clear tx flag\\n\");\n\n\treturn ret;\n}\n\nstatic int\nqcom_pmic_typec_pdphy_pd_transmit_signal(struct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\t\t enum tcpm_transmit_type type,\n\t\t\t\t\t unsigned int negotiated_rev)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tunsigned int val;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\t \n\tret = qcom_pmic_typec_pdphy_clear_tx_control_reg(pmic_typec_pdphy);\n\tif (ret)\n\t\tgoto done;\n\n\tval = TX_CONTROL_SEND_SIGNAL;\n\tif (negotiated_rev == PD_REV30)\n\t\tval |= TX_CONTROL_RETRY_COUNT(2);\n\telse\n\t\tval |= TX_CONTROL_RETRY_COUNT(3);\n\n\tif (type == TCPC_TX_CABLE_RESET || type == TCPC_TX_HARD_RESET)\n\t\tval |= TX_CONTROL_FRAME_TYPE(1);\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_TX_CONTROL_REG, val);\n\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\tdev_vdbg(dev, \"pd_transmit_signal: type %d negotiate_rev %d send %d\\n\",\n\t\t type, negotiated_rev, ret);\n\n\treturn ret;\n}\n\nstatic int\nqcom_pmic_typec_pdphy_pd_transmit_payload(struct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\t\t  enum tcpm_transmit_type type,\n\t\t\t\t\t  const struct pd_message *msg,\n\t\t\t\t\t  unsigned int negotiated_rev)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tunsigned int val, hdr_len, txbuf_len, txsize_len;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\tret = regmap_read(pmic_typec_pdphy->regmap,\n\t\t\t  pmic_typec_pdphy->base + USB_PDPHY_RX_ACKNOWLEDGE_REG,\n\t\t\t  &val);\n\tif (ret)\n\t\tgoto done;\n\n\tif (val) {\n\t\tdev_err(dev, \"pd_transmit_payload: RX message pending\\n\");\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\t \n\tret = qcom_pmic_typec_pdphy_clear_tx_control_reg(pmic_typec_pdphy);\n\tif (ret)\n\t\tgoto done;\n\n\thdr_len = sizeof(msg->header);\n\ttxbuf_len = pd_header_cnt_le(msg->header) * 4;\n\ttxsize_len = hdr_len + txbuf_len - 1;\n\n\t \n\tret = regmap_bulk_write(pmic_typec_pdphy->regmap,\n\t\t\t\tpmic_typec_pdphy->base + USB_PDPHY_TX_BUFFER_HDR_REG,\n\t\t\t\t&msg->header, hdr_len);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tif (txbuf_len) {\n\t\tret = regmap_bulk_write(pmic_typec_pdphy->regmap,\n\t\t\t\t\tpmic_typec_pdphy->base + USB_PDPHY_TX_BUFFER_DATA_REG,\n\t\t\t\t\t&msg->payload, txbuf_len);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\t \n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_TX_SIZE_REG,\n\t\t\t   txsize_len);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = qcom_pmic_typec_pdphy_clear_tx_control_reg(pmic_typec_pdphy);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tval = TX_CONTROL_FRAME_TYPE(type) | TX_CONTROL_SEND_MSG;\n\tif (pd_header_rev(msg->header) == PD_REV30)\n\t\tval |= TX_CONTROL_RETRY_COUNT(2);\n\telse\n\t\tval |= TX_CONTROL_RETRY_COUNT(3);\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_TX_CONTROL_REG, val);\n\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\tif (ret) {\n\t\tdev_err(dev, \"pd_transmit_payload: hdr %*ph data %*ph ret %d\\n\",\n\t\t\thdr_len, &msg->header, txbuf_len, &msg->payload, ret);\n\t}\n\n\treturn ret;\n}\n\nint qcom_pmic_typec_pdphy_pd_transmit(struct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\t      enum tcpm_transmit_type type,\n\t\t\t\t      const struct pd_message *msg,\n\t\t\t\t      unsigned int negotiated_rev)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tint ret;\n\n\tif (msg) {\n\t\tret = qcom_pmic_typec_pdphy_pd_transmit_payload(pmic_typec_pdphy,\n\t\t\t\t\t\t\t\ttype, msg,\n\t\t\t\t\t\t\t\tnegotiated_rev);\n\t} else {\n\t\tret = qcom_pmic_typec_pdphy_pd_transmit_signal(pmic_typec_pdphy,\n\t\t\t\t\t\t\t       type,\n\t\t\t\t\t\t\t       negotiated_rev);\n\t}\n\n\tif (ret)\n\t\tdev_dbg(dev, \"pd_transmit: type %x result %d\\n\", type, ret);\n\n\treturn ret;\n}\n\nstatic void qcom_pmic_typec_pdphy_pd_receive(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tstruct pd_message msg;\n\tunsigned int size, rx_status;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\tret = regmap_read(pmic_typec_pdphy->regmap,\n\t\t\t  pmic_typec_pdphy->base + USB_PDPHY_RX_SIZE_REG, &size);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tif (size < 1 || size > sizeof(msg.payload) + 1) {\n\t\tdev_dbg(dev, \"pd_receive: invalid size %d\\n\", size);\n\t\tgoto done;\n\t}\n\n\tsize += 1;\n\tret = regmap_read(pmic_typec_pdphy->regmap,\n\t\t\t  pmic_typec_pdphy->base + USB_PDPHY_RX_STATUS_REG,\n\t\t\t  &rx_status);\n\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_bulk_read(pmic_typec_pdphy->regmap,\n\t\t\t       pmic_typec_pdphy->base + USB_PDPHY_RX_BUFFER_REG,\n\t\t\t       (u8 *)&msg, size);\n\tif (ret)\n\t\tgoto done;\n\n\t \n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_RX_ACKNOWLEDGE_REG, 0);\n\ndone:\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\tif (!ret) {\n\t\tdev_vdbg(dev, \"pd_receive: handing %d bytes to tcpm\\n\", size);\n\t\ttcpm_pd_receive(pmic_typec_pdphy->tcpm_port, &msg);\n\t}\n}\n\nstatic irqreturn_t qcom_pmic_typec_pdphy_isr(int irq, void *dev_id)\n{\n\tstruct pmic_typec_pdphy_irq_data *irq_data = dev_id;\n\tstruct pmic_typec_pdphy *pmic_typec_pdphy = irq_data->pmic_typec_pdphy;\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\n\tswitch (irq_data->virq) {\n\tcase PMIC_PDPHY_SIG_TX_IRQ:\n\t\tdev_err(dev, \"isr: tx_sig\\n\");\n\t\tbreak;\n\tcase PMIC_PDPHY_SIG_RX_IRQ:\n\t\tschedule_work(&pmic_typec_pdphy->reset_work);\n\t\tbreak;\n\tcase PMIC_PDPHY_MSG_TX_IRQ:\n\t\ttcpm_pd_transmit_complete(pmic_typec_pdphy->tcpm_port,\n\t\t\t\t\t  TCPC_TX_SUCCESS);\n\t\tbreak;\n\tcase PMIC_PDPHY_MSG_RX_IRQ:\n\t\tqcom_pmic_typec_pdphy_pd_receive(pmic_typec_pdphy);\n\t\tbreak;\n\tcase PMIC_PDPHY_MSG_TX_FAIL_IRQ:\n\t\ttcpm_pd_transmit_complete(pmic_typec_pdphy->tcpm_port,\n\t\t\t\t\t  TCPC_TX_FAILED);\n\t\tbreak;\n\tcase PMIC_PDPHY_MSG_TX_DISCARD_IRQ:\n\t\ttcpm_pd_transmit_complete(pmic_typec_pdphy->tcpm_port,\n\t\t\t\t\t  TCPC_TX_DISCARDED);\n\t\tbreak;\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nint qcom_pmic_typec_pdphy_set_pd_rx(struct pmic_typec_pdphy *pmic_typec_pdphy, bool on)\n{\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_RX_ACKNOWLEDGE_REG, !on);\n\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\tdev_dbg(pmic_typec_pdphy->dev, \"set_pd_rx: %s\\n\", on ? \"on\" : \"off\");\n\n\treturn ret;\n}\n\nint qcom_pmic_typec_pdphy_set_roles(struct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\t    bool data_role_host, bool power_role_src)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&pmic_typec_pdphy->lock, flags);\n\n\tret = regmap_update_bits(pmic_typec_pdphy->regmap,\n\t\t\t\t pmic_typec_pdphy->base + USB_PDPHY_MSG_CONFIG_REG,\n\t\t\t\t MSG_CONFIG_PORT_DATA_ROLE |\n\t\t\t\t MSG_CONFIG_PORT_POWER_ROLE,\n\t\t\t\t data_role_host << 3 | power_role_src << 2);\n\n\tspin_unlock_irqrestore(&pmic_typec_pdphy->lock, flags);\n\n\tdev_dbg(dev, \"pdphy_set_roles: data_role_host=%d power_role_src=%d\\n\",\n\t\tdata_role_host, power_role_src);\n\n\treturn ret;\n}\n\nstatic int qcom_pmic_typec_pdphy_enable(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tstruct device *dev = pmic_typec_pdphy->dev;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(pmic_typec_pdphy->regmap,\n\t\t\t\t pmic_typec_pdphy->base + USB_PDPHY_MSG_CONFIG_REG,\n\t\t\t\t MSG_CONFIG_SPEC_REV_MASK, PD_REV20);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_EN_CONTROL_REG, 0);\n\tif (ret)\n\t\tgoto done;\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_EN_CONTROL_REG,\n\t\t\t   CONTROL_ENABLE);\n\tif (ret)\n\t\tgoto done;\n\n\tqcom_pmic_typec_pdphy_reset_off(pmic_typec_pdphy);\ndone:\n\tif (ret) {\n\t\tregulator_disable(pmic_typec_pdphy->vdd_pdphy);\n\t\tdev_err(dev, \"pdphy_enable fail %d\\n\", ret);\n\t}\n\n\treturn ret;\n}\n\nstatic int qcom_pmic_typec_pdphy_disable(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tint ret;\n\n\tqcom_pmic_typec_pdphy_reset_on(pmic_typec_pdphy);\n\n\tret = regmap_write(pmic_typec_pdphy->regmap,\n\t\t\t   pmic_typec_pdphy->base + USB_PDPHY_EN_CONTROL_REG, 0);\n\n\treturn ret;\n}\n\nstatic int pmic_typec_pdphy_reset(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tint ret;\n\n\tret = qcom_pmic_typec_pdphy_disable(pmic_typec_pdphy);\n\tif (ret)\n\t\tgoto done;\n\n\tusleep_range(400, 500);\n\tret = qcom_pmic_typec_pdphy_enable(pmic_typec_pdphy);\ndone:\n\treturn ret;\n}\n\nint qcom_pmic_typec_pdphy_start(struct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\tstruct tcpm_port *tcpm_port)\n{\n\tint i;\n\tint ret;\n\n\tret = regulator_enable(pmic_typec_pdphy->vdd_pdphy);\n\tif (ret)\n\t\treturn ret;\n\n\tpmic_typec_pdphy->tcpm_port = tcpm_port;\n\n\tret = pmic_typec_pdphy_reset(pmic_typec_pdphy);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < pmic_typec_pdphy->nr_irqs; i++)\n\t\tenable_irq(pmic_typec_pdphy->irq_data[i].irq);\n\n\treturn 0;\n}\n\nvoid qcom_pmic_typec_pdphy_stop(struct pmic_typec_pdphy *pmic_typec_pdphy)\n{\n\tint i;\n\n\tfor (i = 0; i < pmic_typec_pdphy->nr_irqs; i++)\n\t\tdisable_irq(pmic_typec_pdphy->irq_data[i].irq);\n\n\tqcom_pmic_typec_pdphy_reset_on(pmic_typec_pdphy);\n\n\tregulator_disable(pmic_typec_pdphy->vdd_pdphy);\n}\n\nstruct pmic_typec_pdphy *qcom_pmic_typec_pdphy_alloc(struct device *dev)\n{\n\treturn devm_kzalloc(dev, sizeof(struct pmic_typec_pdphy), GFP_KERNEL);\n}\n\nint qcom_pmic_typec_pdphy_probe(struct platform_device *pdev,\n\t\t\t\tstruct pmic_typec_pdphy *pmic_typec_pdphy,\n\t\t\t\tstruct pmic_typec_pdphy_resources *res,\n\t\t\t\tstruct regmap *regmap,\n\t\t\t\tu32 base)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct pmic_typec_pdphy_irq_data *irq_data;\n\tint i, ret, irq;\n\n\tif (!res->nr_irqs || res->nr_irqs > PMIC_PDPHY_MAX_IRQS)\n\t\treturn -EINVAL;\n\n\tirq_data = devm_kzalloc(dev, sizeof(*irq_data) * res->nr_irqs,\n\t\t\t\tGFP_KERNEL);\n\tif (!irq_data)\n\t\treturn -ENOMEM;\n\n\tpmic_typec_pdphy->vdd_pdphy = devm_regulator_get(dev, \"vdd-pdphy\");\n\tif (IS_ERR(pmic_typec_pdphy->vdd_pdphy))\n\t\treturn PTR_ERR(pmic_typec_pdphy->vdd_pdphy);\n\n\tpmic_typec_pdphy->dev = dev;\n\tpmic_typec_pdphy->base = base;\n\tpmic_typec_pdphy->regmap = regmap;\n\tpmic_typec_pdphy->nr_irqs = res->nr_irqs;\n\tpmic_typec_pdphy->irq_data = irq_data;\n\tspin_lock_init(&pmic_typec_pdphy->lock);\n\tINIT_WORK(&pmic_typec_pdphy->reset_work, qcom_pmic_typec_pdphy_sig_reset_work);\n\n\tfor (i = 0; i < res->nr_irqs; i++, irq_data++) {\n\t\tirq = platform_get_irq_byname(pdev, res->irq_params[i].irq_name);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\n\t\tirq_data->pmic_typec_pdphy = pmic_typec_pdphy;\n\t\tirq_data->irq = irq;\n\t\tirq_data->virq = res->irq_params[i].virq;\n\n\t\tret = devm_request_threaded_irq(dev, irq, NULL,\n\t\t\t\t\t\tqcom_pmic_typec_pdphy_isr,\n\t\t\t\t\t\tIRQF_ONESHOT | IRQF_NO_AUTOEN,\n\t\t\t\t\t\tres->irq_params[i].irq_name,\n\t\t\t\t\t\tirq_data);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}