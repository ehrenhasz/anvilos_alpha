{
  "module_name": "qcom_pmic_typec.c",
  "hash_id": "2add72ee6d0281fbd84eb7b3ac04086538e0e571e44f9199e061c3427e4fff52",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/qcom/qcom_pmic_typec.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_graph.h>\n#include <linux/platform_device.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/usb/role.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec_mux.h>\n\n#include <drm/drm_bridge.h>\n\n#include \"qcom_pmic_typec_pdphy.h\"\n#include \"qcom_pmic_typec_port.h\"\n\nstruct pmic_typec_resources {\n\tstruct pmic_typec_pdphy_resources\t*pdphy_res;\n\tstruct pmic_typec_port_resources\t*port_res;\n};\n\nstruct pmic_typec {\n\tstruct device\t\t*dev;\n\tstruct tcpm_port\t*tcpm_port;\n\tstruct tcpc_dev\t\ttcpc;\n\tstruct pmic_typec_pdphy\t*pmic_typec_pdphy;\n\tstruct pmic_typec_port\t*pmic_typec_port;\n\tbool\t\t\tvbus_enabled;\n\tstruct mutex\t\tlock;\t\t \n\tstruct drm_bridge\tbridge;\n};\n\n#define tcpc_to_tcpm(_tcpc_) container_of(_tcpc_, struct pmic_typec, tcpc)\n\nstatic int qcom_pmic_typec_get_vbus(struct tcpc_dev *tcpc)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\tint ret;\n\n\tmutex_lock(&tcpm->lock);\n\tret = tcpm->vbus_enabled || qcom_pmic_typec_port_get_vbus(tcpm->pmic_typec_port);\n\tmutex_unlock(&tcpm->lock);\n\n\treturn ret;\n}\n\nstatic int qcom_pmic_typec_set_vbus(struct tcpc_dev *tcpc, bool on, bool sink)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\tint ret = 0;\n\n\tmutex_lock(&tcpm->lock);\n\tif (tcpm->vbus_enabled == on)\n\t\tgoto done;\n\n\tret = qcom_pmic_typec_port_set_vbus(tcpm->pmic_typec_port, on);\n\tif (ret)\n\t\tgoto done;\n\n\ttcpm->vbus_enabled = on;\n\ttcpm_vbus_change(tcpm->tcpm_port);\n\ndone:\n\tdev_dbg(tcpm->dev, \"set_vbus set: %d result %d\\n\", on, ret);\n\tmutex_unlock(&tcpm->lock);\n\n\treturn ret;\n}\n\nstatic int qcom_pmic_typec_set_vconn(struct tcpc_dev *tcpc, bool on)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_port_set_vconn(tcpm->pmic_typec_port, on);\n}\n\nstatic int qcom_pmic_typec_get_cc(struct tcpc_dev *tcpc,\n\t\t\t\t  enum typec_cc_status *cc1,\n\t\t\t\t  enum typec_cc_status *cc2)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_port_get_cc(tcpm->pmic_typec_port, cc1, cc2);\n}\n\nstatic int qcom_pmic_typec_set_cc(struct tcpc_dev *tcpc,\n\t\t\t\t  enum typec_cc_status cc)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_port_set_cc(tcpm->pmic_typec_port, cc);\n}\n\nstatic int qcom_pmic_typec_set_polarity(struct tcpc_dev *tcpc,\n\t\t\t\t\tenum typec_cc_polarity pol)\n{\n\t \n\treturn 0;\n}\n\nstatic int qcom_pmic_typec_start_toggling(struct tcpc_dev *tcpc,\n\t\t\t\t\t  enum typec_port_type port_type,\n\t\t\t\t\t  enum typec_cc_status cc)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_port_start_toggling(tcpm->pmic_typec_port,\n\t\t\t\t\t\t   port_type, cc);\n}\n\nstatic int qcom_pmic_typec_set_roles(struct tcpc_dev *tcpc, bool attached,\n\t\t\t\t     enum typec_role power_role,\n\t\t\t\t     enum typec_data_role data_role)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_pdphy_set_roles(tcpm->pmic_typec_pdphy,\n\t\t\t\t\t       data_role, power_role);\n}\n\nstatic int qcom_pmic_typec_set_pd_rx(struct tcpc_dev *tcpc, bool on)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_pdphy_set_pd_rx(tcpm->pmic_typec_pdphy, on);\n}\n\nstatic int qcom_pmic_typec_pd_transmit(struct tcpc_dev *tcpc,\n\t\t\t\t       enum tcpm_transmit_type type,\n\t\t\t\t       const struct pd_message *msg,\n\t\t\t\t       unsigned int negotiated_rev)\n{\n\tstruct pmic_typec *tcpm = tcpc_to_tcpm(tcpc);\n\n\treturn qcom_pmic_typec_pdphy_pd_transmit(tcpm->pmic_typec_pdphy, type,\n\t\t\t\t\t\t msg, negotiated_rev);\n}\n\nstatic int qcom_pmic_typec_init(struct tcpc_dev *tcpc)\n{\n\treturn 0;\n}\n\n#if IS_ENABLED(CONFIG_DRM)\nstatic int qcom_pmic_typec_attach(struct drm_bridge *bridge,\n\t\t\t\t     enum drm_bridge_attach_flags flags)\n{\n\treturn flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR ? 0 : -EINVAL;\n}\n\nstatic const struct drm_bridge_funcs qcom_pmic_typec_bridge_funcs = {\n\t.attach = qcom_pmic_typec_attach,\n};\n\nstatic int qcom_pmic_typec_init_drm(struct pmic_typec *tcpm)\n{\n\ttcpm->bridge.funcs = &qcom_pmic_typec_bridge_funcs;\n#ifdef CONFIG_OF\n\ttcpm->bridge.of_node = of_get_child_by_name(tcpm->dev->of_node, \"connector\");\n#endif\n\ttcpm->bridge.ops = DRM_BRIDGE_OP_HPD;\n\ttcpm->bridge.type = DRM_MODE_CONNECTOR_DisplayPort;\n\n\treturn devm_drm_bridge_add(tcpm->dev, &tcpm->bridge);\n}\n#else\nstatic int qcom_pmic_typec_init_drm(struct pmic_typec *tcpm)\n{\n\treturn 0;\n}\n#endif\n\nstatic int qcom_pmic_typec_probe(struct platform_device *pdev)\n{\n\tstruct pmic_typec *tcpm;\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct pmic_typec_resources *res;\n\tstruct regmap *regmap;\n\tu32 base[2];\n\tint ret;\n\n\tres = of_device_get_match_data(dev);\n\tif (!res)\n\t\treturn -ENODEV;\n\n\ttcpm = devm_kzalloc(dev, sizeof(*tcpm), GFP_KERNEL);\n\tif (!tcpm)\n\t\treturn -ENOMEM;\n\n\ttcpm->dev = dev;\n\ttcpm->tcpc.init = qcom_pmic_typec_init;\n\ttcpm->tcpc.get_vbus = qcom_pmic_typec_get_vbus;\n\ttcpm->tcpc.set_vbus = qcom_pmic_typec_set_vbus;\n\ttcpm->tcpc.set_cc = qcom_pmic_typec_set_cc;\n\ttcpm->tcpc.get_cc = qcom_pmic_typec_get_cc;\n\ttcpm->tcpc.set_polarity = qcom_pmic_typec_set_polarity;\n\ttcpm->tcpc.set_vconn = qcom_pmic_typec_set_vconn;\n\ttcpm->tcpc.start_toggling = qcom_pmic_typec_start_toggling;\n\ttcpm->tcpc.set_pd_rx = qcom_pmic_typec_set_pd_rx;\n\ttcpm->tcpc.set_roles = qcom_pmic_typec_set_roles;\n\ttcpm->tcpc.pd_transmit = qcom_pmic_typec_pd_transmit;\n\n\tregmap = dev_get_regmap(dev->parent, NULL);\n\tif (!regmap) {\n\t\tdev_err(dev, \"Failed to get regmap\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tret = of_property_read_u32_array(np, \"reg\", base, 2);\n\tif (ret)\n\t\treturn ret;\n\n\ttcpm->pmic_typec_port = qcom_pmic_typec_port_alloc(dev);\n\tif (IS_ERR(tcpm->pmic_typec_port))\n\t\treturn PTR_ERR(tcpm->pmic_typec_port);\n\n\ttcpm->pmic_typec_pdphy = qcom_pmic_typec_pdphy_alloc(dev);\n\tif (IS_ERR(tcpm->pmic_typec_pdphy))\n\t\treturn PTR_ERR(tcpm->pmic_typec_pdphy);\n\n\tret = qcom_pmic_typec_port_probe(pdev, tcpm->pmic_typec_port,\n\t\t\t\t\t res->port_res, regmap, base[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = qcom_pmic_typec_pdphy_probe(pdev, tcpm->pmic_typec_pdphy,\n\t\t\t\t\t  res->pdphy_res, regmap, base[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_init(&tcpm->lock);\n\tplatform_set_drvdata(pdev, tcpm);\n\n\tret = qcom_pmic_typec_init_drm(tcpm);\n\tif (ret)\n\t\treturn ret;\n\n\ttcpm->tcpc.fwnode = device_get_named_child_node(tcpm->dev, \"connector\");\n\tif (!tcpm->tcpc.fwnode)\n\t\treturn -EINVAL;\n\n\ttcpm->tcpm_port = tcpm_register_port(tcpm->dev, &tcpm->tcpc);\n\tif (IS_ERR(tcpm->tcpm_port)) {\n\t\tret = PTR_ERR(tcpm->tcpm_port);\n\t\tgoto fwnode_remove;\n\t}\n\n\tret = qcom_pmic_typec_port_start(tcpm->pmic_typec_port,\n\t\t\t\t\t tcpm->tcpm_port);\n\tif (ret)\n\t\tgoto fwnode_remove;\n\n\tret = qcom_pmic_typec_pdphy_start(tcpm->pmic_typec_pdphy,\n\t\t\t\t\t  tcpm->tcpm_port);\n\tif (ret)\n\t\tgoto fwnode_remove;\n\n\treturn 0;\n\nfwnode_remove:\n\tfwnode_remove_software_node(tcpm->tcpc.fwnode);\n\n\treturn ret;\n}\n\nstatic void qcom_pmic_typec_remove(struct platform_device *pdev)\n{\n\tstruct pmic_typec *tcpm = platform_get_drvdata(pdev);\n\n\tqcom_pmic_typec_pdphy_stop(tcpm->pmic_typec_pdphy);\n\tqcom_pmic_typec_port_stop(tcpm->pmic_typec_port);\n\ttcpm_unregister_port(tcpm->tcpm_port);\n\tfwnode_remove_software_node(tcpm->tcpc.fwnode);\n}\n\nstatic struct pmic_typec_pdphy_resources pm8150b_pdphy_res = {\n\t.irq_params = {\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_SIG_TX_IRQ,\n\t\t\t.irq_name = \"sig-tx\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_SIG_RX_IRQ,\n\t\t\t.irq_name = \"sig-rx\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_MSG_TX_IRQ,\n\t\t\t.irq_name = \"msg-tx\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_MSG_RX_IRQ,\n\t\t\t.irq_name = \"msg-rx\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_MSG_TX_FAIL_IRQ,\n\t\t\t.irq_name = \"msg-tx-failed\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_MSG_TX_DISCARD_IRQ,\n\t\t\t.irq_name = \"msg-tx-discarded\",\n\t\t},\n\t\t{\n\t\t\t.virq = PMIC_PDPHY_MSG_RX_DISCARD_IRQ,\n\t\t\t.irq_name = \"msg-rx-discarded\",\n\t\t},\n\t},\n\t.nr_irqs = 7,\n};\n\nstatic struct pmic_typec_port_resources pm8150b_port_res = {\n\t.irq_params = {\n\t\t{\n\t\t\t.irq_name = \"vpd-detect\",\n\t\t\t.virq = PMIC_TYPEC_VPD_IRQ,\n\t\t},\n\n\t\t{\n\t\t\t.irq_name = \"cc-state-change\",\n\t\t\t.virq = PMIC_TYPEC_CC_STATE_IRQ,\n\t\t},\n\t\t{\n\t\t\t.irq_name = \"vconn-oc\",\n\t\t\t.virq = PMIC_TYPEC_VCONN_OC_IRQ,\n\t\t},\n\n\t\t{\n\t\t\t.irq_name = \"vbus-change\",\n\t\t\t.virq = PMIC_TYPEC_VBUS_IRQ,\n\t\t},\n\n\t\t{\n\t\t\t.irq_name = \"attach-detach\",\n\t\t\t.virq = PMIC_TYPEC_ATTACH_DETACH_IRQ,\n\t\t},\n\t\t{\n\t\t\t.irq_name = \"legacy-cable-detect\",\n\t\t\t.virq = PMIC_TYPEC_LEGACY_CABLE_IRQ,\n\t\t},\n\n\t\t{\n\t\t\t.irq_name = \"try-snk-src-detect\",\n\t\t\t.virq = PMIC_TYPEC_TRY_SNK_SRC_IRQ,\n\t\t},\n\t},\n\t.nr_irqs = 7,\n};\n\nstatic struct pmic_typec_resources pm8150b_typec_res = {\n\t.pdphy_res = &pm8150b_pdphy_res,\n\t.port_res = &pm8150b_port_res,\n};\n\nstatic const struct of_device_id qcom_pmic_typec_table[] = {\n\t{ .compatible = \"qcom,pm8150b-typec\", .data = &pm8150b_typec_res },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, qcom_pmic_typec_table);\n\nstatic struct platform_driver qcom_pmic_typec_driver = {\n\t.driver = {\n\t\t.name = \"qcom,pmic-typec\",\n\t\t.of_match_table = qcom_pmic_typec_table,\n\t},\n\t.probe = qcom_pmic_typec_probe,\n\t.remove_new = qcom_pmic_typec_remove,\n};\n\nmodule_platform_driver(qcom_pmic_typec_driver);\n\nMODULE_DESCRIPTION(\"QCOM PMIC USB Type-C Port Manager Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}