{
  "module_name": "tcpci_rt1711h.c",
  "hash_id": "e0ba0ba53f0a0321bd5f13336ec128d1afeade11367b321806b57e7bbd033eb0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/tcpci_rt1711h.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/gpio/consumer.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/tcpm.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n\n#define RT1711H_VID\t\t0x29CF\n#define RT1711H_PID\t\t0x1711\n#define RT1711H_DID\t\t0x2171\n#define RT1715_DID\t\t0x2173\n\n#define RT1711H_PHYCTRL1\t0x80\n#define RT1711H_PHYCTRL2\t0x81\n\n#define RT1711H_RTCTRL4\t\t0x93\n \n#define RT1711H_BMCIO_RXDZSEL\tBIT(0)\n\n#define RT1711H_RTCTRL8\t\t0x9B\n \n#define RT1711H_RTCTRL8_SET(ck300, ship_off, auto_idle, tout) \\\n\t\t\t    (((ck300) << 7) | ((ship_off) << 5) | \\\n\t\t\t    ((auto_idle) << 3) | ((tout) & 0x07))\n#define RT1711H_AUTOIDLEEN\tBIT(3)\n#define RT1711H_ENEXTMSG\tBIT(4)\n\n#define RT1711H_RTCTRL11\t0x9E\n\n \n#define RT1711H_RTCTRL11_SET(en, tout) \\\n\t\t\t     (((en) << 7) | ((tout) & 0x0F))\n\n#define RT1711H_RTCTRL13\t0xA0\n#define RT1711H_RTCTRL14\t0xA1\n#define RT1711H_RTCTRL15\t0xA2\n#define RT1711H_RTCTRL16\t0xA3\n\n#define RT1711H_RTCTRL18\t0xAF\n \n#define BMCIO_RXDZEN\tBIT(0)\n\nstruct rt1711h_chip {\n\tstruct tcpci_data data;\n\tstruct tcpci *tcpci;\n\tstruct device *dev;\n\tstruct regulator *vbus;\n\tbool src_en;\n\tu16 did;\n};\n\nstatic int rt1711h_read16(struct rt1711h_chip *chip, unsigned int reg, u16 *val)\n{\n\treturn regmap_raw_read(chip->data.regmap, reg, val, sizeof(u16));\n}\n\nstatic int rt1711h_write16(struct rt1711h_chip *chip, unsigned int reg, u16 val)\n{\n\treturn regmap_raw_write(chip->data.regmap, reg, &val, sizeof(u16));\n}\n\nstatic int rt1711h_read8(struct rt1711h_chip *chip, unsigned int reg, u8 *val)\n{\n\treturn regmap_raw_read(chip->data.regmap, reg, val, sizeof(u8));\n}\n\nstatic int rt1711h_write8(struct rt1711h_chip *chip, unsigned int reg, u8 val)\n{\n\treturn regmap_raw_write(chip->data.regmap, reg, &val, sizeof(u8));\n}\n\nstatic const struct regmap_config rt1711h_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0xFF,  \n};\n\nstatic struct rt1711h_chip *tdata_to_rt1711h(struct tcpci_data *tdata)\n{\n\treturn container_of(tdata, struct rt1711h_chip, data);\n}\n\nstatic int rt1711h_init(struct tcpci *tcpci, struct tcpci_data *tdata)\n{\n\tstruct rt1711h_chip *chip = tdata_to_rt1711h(tdata);\n\tstruct regmap *regmap = chip->data.regmap;\n\tint ret;\n\n\t \n\tret = rt1711h_write8(chip, RT1711H_RTCTRL8,\n\t\t\t     RT1711H_RTCTRL8_SET(0, 1, 1, 2));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (chip->did == RT1715_DID) {\n\t\tret = regmap_update_bits(regmap, RT1711H_RTCTRL8,\n\t\t\t\t\t RT1711H_ENEXTMSG, RT1711H_ENEXTMSG);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = rt1711h_write8(chip, RT1711H_RTCTRL11,\n\t\t\t     RT1711H_RTCTRL11_SET(1, 0x0F));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rt1711h_write8(chip, RT1711H_RTCTRL14, 0x0F);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rt1711h_write8(chip, RT1711H_RTCTRL15, 0x04);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rt1711h_write16(chip, RT1711H_RTCTRL16, 330);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rt1711h_write8(chip, RT1711H_PHYCTRL1, 0xF1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\treturn rt1711h_write8(chip, RT1711H_PHYCTRL2, 62);\n}\n\nstatic int rt1711h_set_vbus(struct tcpci *tcpci, struct tcpci_data *tdata,\n\t\t\t    bool src, bool snk)\n{\n\tstruct rt1711h_chip *chip = tdata_to_rt1711h(tdata);\n\tint ret;\n\n\tif (chip->src_en == src)\n\t\treturn 0;\n\n\tif (src)\n\t\tret = regulator_enable(chip->vbus);\n\telse\n\t\tret = regulator_disable(chip->vbus);\n\n\tif (!ret)\n\t\tchip->src_en = src;\n\treturn ret;\n}\n\nstatic int rt1711h_set_vconn(struct tcpci *tcpci, struct tcpci_data *tdata,\n\t\t\t     bool enable)\n{\n\tstruct rt1711h_chip *chip = tdata_to_rt1711h(tdata);\n\n\treturn regmap_update_bits(chip->data.regmap, RT1711H_RTCTRL8,\n\t\t\t\t  RT1711H_AUTOIDLEEN, enable ? 0 : RT1711H_AUTOIDLEEN);\n}\n\n \nstatic inline int rt1711h_init_cc_params(struct rt1711h_chip *chip, u8 status)\n{\n\tint ret, cc1, cc2;\n\tu8 role = 0;\n\tu32 rxdz_en, rxdz_sel;\n\n\tret = rt1711h_read8(chip, TCPC_ROLE_CTRL, &role);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcc1 = tcpci_to_typec_cc((status >> TCPC_CC_STATUS_CC1_SHIFT) &\n\t\t\t\tTCPC_CC_STATUS_CC1_MASK,\n\t\t\t\tstatus & TCPC_CC_STATUS_TERM ||\n\t\t\t\ttcpc_presenting_rd(role, CC1));\n\tcc2 = tcpci_to_typec_cc((status >> TCPC_CC_STATUS_CC2_SHIFT) &\n\t\t\t\tTCPC_CC_STATUS_CC2_MASK,\n\t\t\t\tstatus & TCPC_CC_STATUS_TERM ||\n\t\t\t\ttcpc_presenting_rd(role, CC2));\n\n\tif ((cc1 >= TYPEC_CC_RP_1_5 && cc2 < TYPEC_CC_RP_DEF) ||\n\t    (cc2 >= TYPEC_CC_RP_1_5 && cc1 < TYPEC_CC_RP_DEF)) {\n\t\trxdz_en = BMCIO_RXDZEN;\n\t\tif (chip->did == RT1715_DID)\n\t\t\trxdz_sel = RT1711H_BMCIO_RXDZSEL;\n\t\telse\n\t\t\trxdz_sel = 0;\n\t} else {\n\t\trxdz_en = 0;\n\t\trxdz_sel = RT1711H_BMCIO_RXDZSEL;\n\t}\n\n\tret = regmap_update_bits(chip->data.regmap, RT1711H_RTCTRL18,\n\t\t\t\t BMCIO_RXDZEN, rxdz_en);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_update_bits(chip->data.regmap, RT1711H_RTCTRL4,\n\t\t\t\t  RT1711H_BMCIO_RXDZSEL, rxdz_sel);\n}\n\nstatic int rt1711h_start_drp_toggling(struct tcpci *tcpci,\n\t\t\t\t      struct tcpci_data *tdata,\n\t\t\t\t      enum typec_cc_status cc)\n{\n\tstruct rt1711h_chip *chip = tdata_to_rt1711h(tdata);\n\tint ret;\n\tunsigned int reg = 0;\n\n\tswitch (cc) {\n\tdefault:\n\tcase TYPEC_CC_RP_DEF:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_1_5:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\t}\n\n\tif (cc == TYPEC_CC_RD)\n\t\treg |= (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t   (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT);\n\telse\n\t\treg |= (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t   (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT);\n\n\tret = rt1711h_write8(chip, TCPC_ROLE_CTRL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\tusleep_range(500, 1000);\n\n\treturn 0;\n}\n\nstatic irqreturn_t rt1711h_irq(int irq, void *dev_id)\n{\n\tint ret;\n\tu16 alert;\n\tu8 status;\n\tstruct rt1711h_chip *chip = dev_id;\n\n\tif (!chip->tcpci)\n\t\treturn IRQ_HANDLED;\n\n\tret = rt1711h_read16(chip, TCPC_ALERT, &alert);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (alert & TCPC_ALERT_CC_STATUS) {\n\t\tret = rt1711h_read8(chip, TCPC_CC_STATUS, &status);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\t \n\t\tif (status & TCPC_CC_STATUS_TOGGLING)\n\t\t\trt1711h_write8(chip, TCPC_ALERT, TCPC_ALERT_CC_STATUS);\n\t\telse\n\t\t\trt1711h_init_cc_params(chip, status);\n\t}\n\nout:\n\treturn tcpci_irq(chip->tcpci);\n}\n\nstatic int rt1711h_sw_reset(struct rt1711h_chip *chip)\n{\n\tint ret;\n\n\tret = rt1711h_write8(chip, RT1711H_RTCTRL13, 0x01);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(1000, 2000);\n\treturn 0;\n}\n\nstatic int rt1711h_check_revision(struct i2c_client *i2c, struct rt1711h_chip *chip)\n{\n\tint ret;\n\n\tret = i2c_smbus_read_word_data(i2c, TCPC_VENDOR_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != RT1711H_VID) {\n\t\tdev_err(&i2c->dev, \"vid is not correct, 0x%04x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\tret = i2c_smbus_read_word_data(i2c, TCPC_PRODUCT_ID);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != RT1711H_PID) {\n\t\tdev_err(&i2c->dev, \"pid is not correct, 0x%04x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\tret = i2c_smbus_read_word_data(i2c, TCPC_BCD_DEV);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret != chip->did) {\n\t\tdev_err(&i2c->dev, \"did is not correct, 0x%04x\\n\", ret);\n\t\treturn -ENODEV;\n\t}\n\tdev_dbg(&i2c->dev, \"did is 0x%04x\\n\", ret);\n\treturn ret;\n}\n\nstatic int rt1711h_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct rt1711h_chip *chip;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->did = (size_t)device_get_match_data(&client->dev);\n\n\tret = rt1711h_check_revision(client, chip);\n\tif (ret < 0) {\n\t\tdev_err(&client->dev, \"check vid/pid fail\\n\");\n\t\treturn ret;\n\t}\n\n\tchip->data.regmap = devm_regmap_init_i2c(client,\n\t\t\t\t\t\t &rt1711h_regmap_config);\n\tif (IS_ERR(chip->data.regmap))\n\t\treturn PTR_ERR(chip->data.regmap);\n\n\tchip->dev = &client->dev;\n\ti2c_set_clientdata(client, chip);\n\n\tret = rt1711h_sw_reset(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = rt1711h_write16(chip, TCPC_ALERT_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tchip->vbus = devm_regulator_get(&client->dev, \"vbus\");\n\tif (IS_ERR(chip->vbus))\n\t\treturn PTR_ERR(chip->vbus);\n\n\tchip->data.init = rt1711h_init;\n\tchip->data.set_vbus = rt1711h_set_vbus;\n\tchip->data.set_vconn = rt1711h_set_vconn;\n\tchip->data.start_drp_toggling = rt1711h_start_drp_toggling;\n\tchip->tcpci = tcpci_register_port(chip->dev, &chip->data);\n\tif (IS_ERR_OR_NULL(chip->tcpci))\n\t\treturn PTR_ERR(chip->tcpci);\n\n\tret = devm_request_threaded_irq(chip->dev, client->irq, NULL,\n\t\t\t\t\trt1711h_irq,\n\t\t\t\t\tIRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\t\tdev_name(chip->dev), chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic void rt1711h_remove(struct i2c_client *client)\n{\n\tstruct rt1711h_chip *chip = i2c_get_clientdata(client);\n\n\ttcpci_unregister_port(chip->tcpci);\n}\n\nstatic const struct i2c_device_id rt1711h_id[] = {\n\t{ \"rt1711h\", 0 },\n\t{ \"rt1715\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, rt1711h_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id rt1711h_of_match[] = {\n\t{ .compatible = \"richtek,rt1711h\", .data = (void *)RT1711H_DID },\n\t{ .compatible = \"richtek,rt1715\", .data = (void *)RT1715_DID },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, rt1711h_of_match);\n#endif\n\nstatic struct i2c_driver rt1711h_i2c_driver = {\n\t.driver = {\n\t\t.name = \"rt1711h\",\n\t\t.of_match_table = of_match_ptr(rt1711h_of_match),\n\t},\n\t.probe = rt1711h_probe,\n\t.remove = rt1711h_remove,\n\t.id_table = rt1711h_id,\n};\nmodule_i2c_driver(rt1711h_i2c_driver);\n\nMODULE_AUTHOR(\"ShuFan Lee <shufan_lee@richtek.com>\");\nMODULE_DESCRIPTION(\"RT1711H USB Type-C Port Controller Interface Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}