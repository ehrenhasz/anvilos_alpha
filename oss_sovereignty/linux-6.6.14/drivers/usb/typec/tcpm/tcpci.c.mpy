{
  "module_name": "tcpci.c",
  "hash_id": "983d1de8b7d07a70679dad98628d69f5c8c07b17c6f0f4f3a3c865ba0c0833bc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/tcpci.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/property.h>\n#include <linux/regmap.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec.h>\n\n#define\tPD_RETRY_COUNT_DEFAULT\t\t\t3\n#define\tPD_RETRY_COUNT_3_0_OR_HIGHER\t\t2\n#define\tAUTO_DISCHARGE_DEFAULT_THRESHOLD_MV\t3500\n#define\tVSINKPD_MIN_IR_DROP_MV\t\t\t750\n#define\tVSRC_NEW_MIN_PERCENT\t\t\t95\n#define\tVSRC_VALID_MIN_MV\t\t\t500\n#define\tVPPS_NEW_MIN_PERCENT\t\t\t95\n#define\tVPPS_VALID_MIN_MV\t\t\t100\n#define\tVSINKDISCONNECT_PD_MIN_PERCENT\t\t90\n\nstruct tcpci {\n\tstruct device *dev;\n\n\tstruct tcpm_port *port;\n\n\tstruct regmap *regmap;\n\tunsigned int alert_mask;\n\n\tbool controls_vbus;\n\n\tstruct tcpc_dev tcpc;\n\tstruct tcpci_data *data;\n};\n\nstruct tcpci_chip {\n\tstruct tcpci *tcpci;\n\tstruct tcpci_data data;\n};\n\nstruct tcpm_port *tcpci_get_tcpm_port(struct tcpci *tcpci)\n{\n\treturn tcpci->port;\n}\nEXPORT_SYMBOL_GPL(tcpci_get_tcpm_port);\n\nstatic inline struct tcpci *tcpc_to_tcpci(struct tcpc_dev *tcpc)\n{\n\treturn container_of(tcpc, struct tcpci, tcpc);\n}\n\nstatic int tcpci_read16(struct tcpci *tcpci, unsigned int reg, u16 *val)\n{\n\treturn regmap_raw_read(tcpci->regmap, reg, val, sizeof(u16));\n}\n\nstatic int tcpci_write16(struct tcpci *tcpci, unsigned int reg, u16 val)\n{\n\treturn regmap_raw_write(tcpci->regmap, reg, &val, sizeof(u16));\n}\n\nstatic int tcpci_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tbool vconn_pres;\n\tenum typec_cc_polarity polarity = TYPEC_POLARITY_CC1;\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tvconn_pres = !!(reg & TCPC_POWER_STATUS_VCONN_PRES);\n\tif (vconn_pres) {\n\t\tret = regmap_read(tcpci->regmap, TCPC_TCPC_CTRL, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (reg & TCPC_TCPC_CTRL_ORIENTATION)\n\t\t\tpolarity = TYPEC_POLARITY_CC2;\n\t}\n\n\tswitch (cc) {\n\tcase TYPEC_CC_RA:\n\t\treg = (TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_RA << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RD:\n\t\treg = (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_DEF:\n\t\treg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_RP_VAL_DEF <<\n\t\t\t TCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_1_5:\n\t\treg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_RP_VAL_1_5 <<\n\t\t\t TCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\treg = (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_RP_VAL_3_0 <<\n\t\t\t TCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_OPEN:\n\tdefault:\n\t\treg = (TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t(TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\tbreak;\n\t}\n\n\tif (vconn_pres) {\n\t\tif (polarity == TYPEC_POLARITY_CC2) {\n\t\t\treg &= ~(TCPC_ROLE_CTRL_CC1_MASK << TCPC_ROLE_CTRL_CC1_SHIFT);\n\t\t\treg |= (TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT);\n\t\t} else {\n\t\t\treg &= ~(TCPC_ROLE_CTRL_CC2_MASK << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\t\treg |= (TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\t}\n\t}\n\n\tret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tcpci_apply_rc(struct tcpc_dev *tcpc, enum typec_cc_status cc,\n\t\t\t  enum typec_cc_polarity polarity)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_ROLE_CTRL, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (((reg & (TCPC_ROLE_CTRL_CC2_MASK << TCPC_ROLE_CTRL_CC2_SHIFT)) >>\n\t     TCPC_ROLE_CTRL_CC2_SHIFT) !=\n\t    ((reg & (TCPC_ROLE_CTRL_CC1_MASK << TCPC_ROLE_CTRL_CC1_SHIFT)) >>\n\t     TCPC_ROLE_CTRL_CC1_SHIFT))\n\t\treturn 0;\n\n\treturn regmap_update_bits(tcpci->regmap, TCPC_ROLE_CTRL, polarity == TYPEC_POLARITY_CC1 ?\n\t\t\t\t  TCPC_ROLE_CTRL_CC2_MASK << TCPC_ROLE_CTRL_CC2_SHIFT :\n\t\t\t\t  TCPC_ROLE_CTRL_CC1_MASK << TCPC_ROLE_CTRL_CC1_SHIFT,\n\t\t\t\t  TCPC_ROLE_CTRL_CC_OPEN);\n}\n\nstatic int tcpci_start_toggling(struct tcpc_dev *tcpc,\n\t\t\t\tenum typec_port_type port_type,\n\t\t\t\tenum typec_cc_status cc)\n{\n\tint ret;\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg = TCPC_ROLE_CTRL_DRP;\n\n\tif (port_type != TYPEC_PORT_DRP)\n\t\treturn -EOPNOTSUPP;\n\n\t \n\tif (tcpci->data->start_drp_toggling) {\n\t\tret = tcpci->data->start_drp_toggling(tcpci, tcpci->data, cc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tswitch (cc) {\n\tdefault:\n\tcase TYPEC_CC_RP_DEF:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_DEF <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_1_5:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_1_5 <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\treg |= (TCPC_ROLE_CTRL_RP_VAL_3_0 <<\n\t\t\tTCPC_ROLE_CTRL_RP_VAL_SHIFT);\n\t\tbreak;\n\t}\n\n\tif (cc == TYPEC_CC_RD)\n\t\treg |= (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t   (TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT);\n\telse\n\t\treg |= (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT) |\n\t\t\t   (TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT);\n\tret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t    TCPC_CMD_LOOK4CONNECTION);\n}\n\nstatic int tcpci_get_cc(struct tcpc_dev *tcpc,\n\t\t\tenum typec_cc_status *cc1, enum typec_cc_status *cc2)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg, role_control;\n\tint ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_ROLE_CTRL, &role_control);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_CC_STATUS, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*cc1 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC1_SHIFT) &\n\t\t\t\t TCPC_CC_STATUS_CC1_MASK,\n\t\t\t\t reg & TCPC_CC_STATUS_TERM ||\n\t\t\t\t tcpc_presenting_rd(role_control, CC1));\n\t*cc2 = tcpci_to_typec_cc((reg >> TCPC_CC_STATUS_CC2_SHIFT) &\n\t\t\t\t TCPC_CC_STATUS_CC2_MASK,\n\t\t\t\t reg & TCPC_CC_STATUS_TERM ||\n\t\t\t\t tcpc_presenting_rd(role_control, CC2));\n\n\treturn 0;\n}\n\nstatic int tcpci_set_polarity(struct tcpc_dev *tcpc,\n\t\t\t      enum typec_cc_polarity polarity)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg;\n\tint ret;\n\tenum typec_cc_status cc1, cc2;\n\n\t \n\tret = regmap_read(tcpci->regmap, TCPC_ROLE_CTRL, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = tcpci_get_cc(tcpc, &cc1, &cc2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (reg & TCPC_ROLE_CTRL_DRP) {\n\t\t \n\t\treg = reg & ~TCPC_ROLE_CTRL_DRP;\n\n\t\tif (polarity == TYPEC_POLARITY_CC2) {\n\t\t\treg &= ~(TCPC_ROLE_CTRL_CC2_MASK << TCPC_ROLE_CTRL_CC2_SHIFT);\n\t\t\t \n\t\t\tif (cc2 == TYPEC_CC_RD)\n\t\t\t\t \n\t\t\t\treg |= TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC2_SHIFT;\n\t\t\telse\n\t\t\t\treg |= TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT;\n\t\t} else {\n\t\t\treg &= ~(TCPC_ROLE_CTRL_CC1_MASK << TCPC_ROLE_CTRL_CC1_SHIFT);\n\t\t\t \n\t\t\tif (cc1 == TYPEC_CC_RD)\n\t\t\t\t \n\t\t\t\treg |= TCPC_ROLE_CTRL_CC_RP << TCPC_ROLE_CTRL_CC1_SHIFT;\n\t\t\telse\n\t\t\t\treg |= TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT;\n\t\t}\n\t}\n\n\tif (polarity == TYPEC_POLARITY_CC2)\n\t\treg |= TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC1_SHIFT;\n\telse\n\t\treg |= TCPC_ROLE_CTRL_CC_OPEN << TCPC_ROLE_CTRL_CC2_SHIFT;\n\tret = regmap_write(tcpci->regmap, TCPC_ROLE_CTRL, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn regmap_write(tcpci->regmap, TCPC_TCPC_CTRL,\n\t\t\t   (polarity == TYPEC_POLARITY_CC2) ?\n\t\t\t   TCPC_TCPC_CTRL_ORIENTATION : 0);\n}\n\nstatic void tcpci_set_partner_usb_comm_capable(struct tcpc_dev *tcpc, bool capable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\n\tif (tcpci->data->set_partner_usb_comm_capable)\n\t\ttcpci->data->set_partner_usb_comm_capable(tcpci, tcpci->data, capable);\n}\n\nstatic int tcpci_set_vconn(struct tcpc_dev *tcpc, bool enable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tint ret;\n\n\t \n\tif (tcpci->data->set_vconn) {\n\t\tret = tcpci->data->set_vconn(tcpci, tcpci->data, enable);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn regmap_update_bits(tcpci->regmap, TCPC_POWER_CTRL,\n\t\t\t\tTCPC_POWER_CTRL_VCONN_ENABLE,\n\t\t\t\tenable ? TCPC_POWER_CTRL_VCONN_ENABLE : 0);\n}\n\nstatic int tcpci_enable_auto_vbus_discharge(struct tcpc_dev *dev, bool enable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(dev);\n\tint ret;\n\n\tret = regmap_update_bits(tcpci->regmap, TCPC_POWER_CTRL, TCPC_POWER_CTRL_AUTO_DISCHARGE,\n\t\t\t\t enable ? TCPC_POWER_CTRL_AUTO_DISCHARGE : 0);\n\treturn ret;\n}\n\nstatic int tcpci_set_auto_vbus_discharge_threshold(struct tcpc_dev *dev, enum typec_pwr_opmode mode,\n\t\t\t\t\t\t   bool pps_active, u32 requested_vbus_voltage_mv)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(dev);\n\tunsigned int pwr_ctrl, threshold = 0;\n\tint ret;\n\n\t \n\tif (requested_vbus_voltage_mv == 0)\n\t\tgoto write_thresh;\n\n\tret = regmap_read(tcpci->regmap, TCPC_POWER_CTRL, &pwr_ctrl);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (pwr_ctrl & TCPC_FAST_ROLE_SWAP_EN) {\n\t\t \n\t\tthreshold = AUTO_DISCHARGE_DEFAULT_THRESHOLD_MV;\n\t} else if (mode == TYPEC_PWR_MODE_PD) {\n\t\tif (pps_active)\n\t\t\tthreshold = ((VPPS_NEW_MIN_PERCENT * requested_vbus_voltage_mv / 100) -\n\t\t\t\t     VSINKPD_MIN_IR_DROP_MV - VPPS_VALID_MIN_MV) *\n\t\t\t\t     VSINKDISCONNECT_PD_MIN_PERCENT / 100;\n\t\telse\n\t\t\tthreshold = ((VSRC_NEW_MIN_PERCENT * requested_vbus_voltage_mv / 100) -\n\t\t\t\t     VSINKPD_MIN_IR_DROP_MV - VSRC_VALID_MIN_MV) *\n\t\t\t\t     VSINKDISCONNECT_PD_MIN_PERCENT / 100;\n\t} else {\n\t\t \n\t\tthreshold = AUTO_DISCHARGE_DEFAULT_THRESHOLD_MV;\n\t}\n\n\tthreshold = threshold / TCPC_VBUS_SINK_DISCONNECT_THRESH_LSB_MV;\n\n\tif (threshold > TCPC_VBUS_SINK_DISCONNECT_THRESH_MAX)\n\t\treturn -EINVAL;\n\nwrite_thresh:\n\treturn tcpci_write16(tcpci, TCPC_VBUS_SINK_DISCONNECT_THRESH, threshold);\n}\n\nstatic int tcpci_enable_frs(struct tcpc_dev *dev, bool enable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(dev);\n\tint ret;\n\n\t \n\tret = tcpci_write16(tcpci, TCPC_VBUS_SINK_DISCONNECT_THRESH, enable ? 0 : 0x8c);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(tcpci->regmap, TCPC_POWER_CTRL, TCPC_FAST_ROLE_SWAP_EN, enable ?\n\t\t\t\t TCPC_FAST_ROLE_SWAP_EN : 0);\n\n\treturn ret;\n}\n\nstatic void tcpci_frs_sourcing_vbus(struct tcpc_dev *dev)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(dev);\n\n\tif (tcpci->data->frs_sourcing_vbus)\n\t\ttcpci->data->frs_sourcing_vbus(tcpci, tcpci->data);\n}\n\nstatic void tcpci_check_contaminant(struct tcpc_dev *dev)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(dev);\n\n\tif (tcpci->data->check_contaminant)\n\t\ttcpci->data->check_contaminant(tcpci, tcpci->data);\n}\n\nstatic int tcpci_set_bist_data(struct tcpc_dev *tcpc, bool enable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\n\treturn regmap_update_bits(tcpci->regmap, TCPC_TCPC_CTRL, TCPC_TCPC_CTRL_BIST_TM,\n\t\t\t\t enable ? TCPC_TCPC_CTRL_BIST_TM : 0);\n}\n\nstatic int tcpci_set_roles(struct tcpc_dev *tcpc, bool attached,\n\t\t\t   enum typec_role role, enum typec_data_role data)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg;\n\tint ret;\n\n\treg = PD_REV20 << TCPC_MSG_HDR_INFO_REV_SHIFT;\n\tif (role == TYPEC_SOURCE)\n\t\treg |= TCPC_MSG_HDR_INFO_PWR_ROLE;\n\tif (data == TYPEC_HOST)\n\t\treg |= TCPC_MSG_HDR_INFO_DATA_ROLE;\n\tret = regmap_write(tcpci->regmap, TCPC_MSG_HDR_INFO, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tcpci_set_pd_rx(struct tcpc_dev *tcpc, bool enable)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg = 0;\n\tint ret;\n\n\tif (enable)\n\t\treg = TCPC_RX_DETECT_SOP | TCPC_RX_DETECT_HARD_RESET;\n\tret = regmap_write(tcpci->regmap, TCPC_RX_DETECT, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tcpci_get_vbus(struct tcpc_dev *tcpc)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn !!(reg & TCPC_POWER_STATUS_VBUS_PRES);\n}\n\nstatic bool tcpci_is_vbus_vsafe0v(struct tcpc_dev *tcpc)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned int reg;\n\tint ret;\n\n\tret = regmap_read(tcpci->regmap, TCPC_EXTENDED_STATUS, &reg);\n\tif (ret < 0)\n\t\treturn false;\n\n\treturn !!(reg & TCPC_EXTENDED_STATUS_VSAFE0V);\n}\n\nstatic int tcpci_set_vbus(struct tcpc_dev *tcpc, bool source, bool sink)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tint ret;\n\n\tif (tcpci->data->set_vbus) {\n\t\tret = tcpci->data->set_vbus(tcpci, tcpci->data, source, sink);\n\t\t \n\t\tif (ret != 0)\n\t\t\treturn ret < 0 ? ret : 0;\n\t}\n\n\t \n\n\tif (!source) {\n\t\tret = regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t\t   TCPC_CMD_DISABLE_SRC_VBUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (!sink) {\n\t\tret = regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t\t   TCPC_CMD_DISABLE_SINK_VBUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (source) {\n\t\tret = regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t\t   TCPC_CMD_SRC_VBUS_DEFAULT);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tif (sink) {\n\t\tret = regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t\t   TCPC_CMD_SINK_VBUS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int tcpci_pd_transmit(struct tcpc_dev *tcpc, enum tcpm_transmit_type type,\n\t\t\t     const struct pd_message *msg, unsigned int negotiated_rev)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tu16 header = msg ? le16_to_cpu(msg->header) : 0;\n\tunsigned int reg, cnt;\n\tint ret;\n\n\tcnt = msg ? pd_header_cnt(header) * 4 : 0;\n\t \n\tif (tcpci->data->TX_BUF_BYTE_x_hidden) {\n\t\tu8 buf[TCPC_TRANSMIT_BUFFER_MAX_LEN] = {0,};\n\t\tu8 pos = 0;\n\n\t\t \n\t\tbuf[pos++] = cnt + 2;\n\n\t\tif (msg)\n\t\t\tmemcpy(&buf[pos], &msg->header, sizeof(msg->header));\n\n\t\tpos += sizeof(header);\n\n\t\tif (cnt > 0)\n\t\t\tmemcpy(&buf[pos], msg->payload, cnt);\n\n\t\tpos += cnt;\n\t\tret = regmap_raw_write(tcpci->regmap, TCPC_TX_BYTE_CNT, buf, pos);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t} else {\n\t\tret = regmap_write(tcpci->regmap, TCPC_TX_BYTE_CNT, cnt + 2);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = tcpci_write16(tcpci, TCPC_TX_HDR, header);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (cnt > 0) {\n\t\t\tret = regmap_raw_write(tcpci->regmap, TCPC_TX_DATA, &msg->payload, cnt);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\treg = ((negotiated_rev > PD_REV20 ? PD_RETRY_COUNT_3_0_OR_HIGHER : PD_RETRY_COUNT_DEFAULT)\n\t       << TCPC_TRANSMIT_RETRY_SHIFT) | (type << TCPC_TRANSMIT_TYPE_SHIFT);\n\tret = regmap_write(tcpci->regmap, TCPC_TRANSMIT, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int tcpci_init(struct tcpc_dev *tcpc)\n{\n\tstruct tcpci *tcpci = tcpc_to_tcpci(tcpc);\n\tunsigned long timeout = jiffies + msecs_to_jiffies(2000);  \n\tunsigned int reg;\n\tint ret;\n\n\twhile (time_before_eq(jiffies, timeout)) {\n\t\tret = regmap_read(tcpci->regmap, TCPC_POWER_STATUS, &reg);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (!(reg & TCPC_POWER_STATUS_UNINIT))\n\t\t\tbreak;\n\t\tusleep_range(10000, 20000);\n\t}\n\tif (time_after(jiffies, timeout))\n\t\treturn -ETIMEDOUT;\n\n\tret = tcpci_write16(tcpci, TCPC_FAULT_STATUS, TCPC_FAULT_STATUS_ALL_REG_RST_TO_DEFAULT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (tcpci->data->init) {\n\t\tret = tcpci->data->init(tcpci, tcpci->data);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\t \n\tret = tcpci_write16(tcpci, TCPC_ALERT, 0xffff);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (tcpci->controls_vbus)\n\t\treg = TCPC_POWER_STATUS_VBUS_PRES;\n\telse\n\t\treg = 0;\n\tret = regmap_write(tcpci->regmap, TCPC_POWER_STATUS_MASK, reg);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(tcpci->regmap, TCPC_COMMAND,\n\t\t\t   TCPC_CMD_ENABLE_VBUS_DETECT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treg = TCPC_ALERT_TX_SUCCESS | TCPC_ALERT_TX_FAILED |\n\t\tTCPC_ALERT_TX_DISCARDED | TCPC_ALERT_RX_STATUS |\n\t\tTCPC_ALERT_RX_HARD_RST | TCPC_ALERT_CC_STATUS;\n\tif (tcpci->controls_vbus)\n\t\treg |= TCPC_ALERT_POWER_STATUS;\n\t \n\tif (tcpci->data->vbus_vsafe0v) {\n\t\treg |= TCPC_ALERT_EXTENDED_STATUS;\n\t\tret = regmap_write(tcpci->regmap, TCPC_EXTENDED_STATUS_MASK,\n\t\t\t\t   TCPC_EXTENDED_STATUS_VSAFE0V);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttcpci->alert_mask = reg;\n\n\treturn tcpci_write16(tcpci, TCPC_ALERT_MASK, reg);\n}\n\nirqreturn_t tcpci_irq(struct tcpci *tcpci)\n{\n\tu16 status;\n\tint ret;\n\tunsigned int raw;\n\n\ttcpci_read16(tcpci, TCPC_ALERT, &status);\n\n\t \n\tif (status & ~TCPC_ALERT_RX_STATUS)\n\t\ttcpci_write16(tcpci, TCPC_ALERT,\n\t\t\t      status & ~TCPC_ALERT_RX_STATUS);\n\n\tif (status & TCPC_ALERT_CC_STATUS)\n\t\ttcpm_cc_change(tcpci->port);\n\n\tif (status & TCPC_ALERT_POWER_STATUS) {\n\t\tregmap_read(tcpci->regmap, TCPC_POWER_STATUS_MASK, &raw);\n\t\t \n\t\tif (raw == 0xff)\n\t\t\ttcpm_tcpc_reset(tcpci->port);\n\t\telse\n\t\t\ttcpm_vbus_change(tcpci->port);\n\t}\n\n\tif (status & TCPC_ALERT_RX_STATUS) {\n\t\tstruct pd_message msg;\n\t\tunsigned int cnt, payload_cnt;\n\t\tu16 header;\n\n\t\tregmap_read(tcpci->regmap, TCPC_RX_BYTE_CNT, &cnt);\n\t\t \n\t\tif (cnt > 3)\n\t\t\tpayload_cnt = cnt - (1 + sizeof(msg.header));\n\t\telse\n\t\t\tpayload_cnt = 0;\n\n\t\ttcpci_read16(tcpci, TCPC_RX_HDR, &header);\n\t\tmsg.header = cpu_to_le16(header);\n\n\t\tif (WARN_ON(payload_cnt > sizeof(msg.payload)))\n\t\t\tpayload_cnt = sizeof(msg.payload);\n\n\t\tif (payload_cnt > 0)\n\t\t\tregmap_raw_read(tcpci->regmap, TCPC_RX_DATA,\n\t\t\t\t\t&msg.payload, payload_cnt);\n\n\t\t \n\t\ttcpci_write16(tcpci, TCPC_ALERT, TCPC_ALERT_RX_STATUS);\n\n\t\ttcpm_pd_receive(tcpci->port, &msg);\n\t}\n\n\tif (tcpci->data->vbus_vsafe0v && (status & TCPC_ALERT_EXTENDED_STATUS)) {\n\t\tret = regmap_read(tcpci->regmap, TCPC_EXTENDED_STATUS, &raw);\n\t\tif (!ret && (raw & TCPC_EXTENDED_STATUS_VSAFE0V))\n\t\t\ttcpm_vbus_change(tcpci->port);\n\t}\n\n\tif (status & TCPC_ALERT_RX_HARD_RST)\n\t\ttcpm_pd_hard_reset(tcpci->port);\n\n\tif (status & TCPC_ALERT_TX_SUCCESS)\n\t\ttcpm_pd_transmit_complete(tcpci->port, TCPC_TX_SUCCESS);\n\telse if (status & TCPC_ALERT_TX_DISCARDED)\n\t\ttcpm_pd_transmit_complete(tcpci->port, TCPC_TX_DISCARDED);\n\telse if (status & TCPC_ALERT_TX_FAILED)\n\t\ttcpm_pd_transmit_complete(tcpci->port, TCPC_TX_FAILED);\n\n\treturn IRQ_RETVAL(status & tcpci->alert_mask);\n}\nEXPORT_SYMBOL_GPL(tcpci_irq);\n\nstatic irqreturn_t _tcpci_irq(int irq, void *dev_id)\n{\n\tstruct tcpci_chip *chip = dev_id;\n\n\treturn tcpci_irq(chip->tcpci);\n}\n\nstatic const struct regmap_config tcpci_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = 0x7F,  \n};\n\nstatic int tcpci_parse_config(struct tcpci *tcpci)\n{\n\ttcpci->controls_vbus = true;  \n\n\ttcpci->tcpc.fwnode = device_get_named_child_node(tcpci->dev,\n\t\t\t\t\t\t\t \"connector\");\n\tif (!tcpci->tcpc.fwnode) {\n\t\tdev_err(tcpci->dev, \"Can't find connector node.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstruct tcpci *tcpci_register_port(struct device *dev, struct tcpci_data *data)\n{\n\tstruct tcpci *tcpci;\n\tint err;\n\n\ttcpci = devm_kzalloc(dev, sizeof(*tcpci), GFP_KERNEL);\n\tif (!tcpci)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttcpci->dev = dev;\n\ttcpci->data = data;\n\ttcpci->regmap = data->regmap;\n\n\ttcpci->tcpc.init = tcpci_init;\n\ttcpci->tcpc.get_vbus = tcpci_get_vbus;\n\ttcpci->tcpc.set_vbus = tcpci_set_vbus;\n\ttcpci->tcpc.set_cc = tcpci_set_cc;\n\ttcpci->tcpc.apply_rc = tcpci_apply_rc;\n\ttcpci->tcpc.get_cc = tcpci_get_cc;\n\ttcpci->tcpc.set_polarity = tcpci_set_polarity;\n\ttcpci->tcpc.set_vconn = tcpci_set_vconn;\n\ttcpci->tcpc.start_toggling = tcpci_start_toggling;\n\n\ttcpci->tcpc.set_pd_rx = tcpci_set_pd_rx;\n\ttcpci->tcpc.set_roles = tcpci_set_roles;\n\ttcpci->tcpc.pd_transmit = tcpci_pd_transmit;\n\ttcpci->tcpc.set_bist_data = tcpci_set_bist_data;\n\ttcpci->tcpc.enable_frs = tcpci_enable_frs;\n\ttcpci->tcpc.frs_sourcing_vbus = tcpci_frs_sourcing_vbus;\n\ttcpci->tcpc.set_partner_usb_comm_capable = tcpci_set_partner_usb_comm_capable;\n\n\tif (tcpci->data->check_contaminant)\n\t\ttcpci->tcpc.check_contaminant = tcpci_check_contaminant;\n\n\tif (tcpci->data->auto_discharge_disconnect) {\n\t\ttcpci->tcpc.enable_auto_vbus_discharge = tcpci_enable_auto_vbus_discharge;\n\t\ttcpci->tcpc.set_auto_vbus_discharge_threshold =\n\t\t\ttcpci_set_auto_vbus_discharge_threshold;\n\t\tregmap_update_bits(tcpci->regmap, TCPC_POWER_CTRL, TCPC_POWER_CTRL_BLEED_DISCHARGE,\n\t\t\t\t   TCPC_POWER_CTRL_BLEED_DISCHARGE);\n\t}\n\n\tif (tcpci->data->vbus_vsafe0v)\n\t\ttcpci->tcpc.is_vbus_vsafe0v = tcpci_is_vbus_vsafe0v;\n\n\terr = tcpci_parse_config(tcpci);\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\ttcpci->port = tcpm_register_port(tcpci->dev, &tcpci->tcpc);\n\tif (IS_ERR(tcpci->port)) {\n\t\tfwnode_handle_put(tcpci->tcpc.fwnode);\n\t\treturn ERR_CAST(tcpci->port);\n\t}\n\n\treturn tcpci;\n}\nEXPORT_SYMBOL_GPL(tcpci_register_port);\n\nvoid tcpci_unregister_port(struct tcpci *tcpci)\n{\n\ttcpm_unregister_port(tcpci->port);\n\tfwnode_handle_put(tcpci->tcpc.fwnode);\n}\nEXPORT_SYMBOL_GPL(tcpci_unregister_port);\n\nstatic int tcpci_probe(struct i2c_client *client)\n{\n\tstruct tcpci_chip *chip;\n\tint err;\n\tu16 val = 0;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->data.regmap = devm_regmap_init_i2c(client, &tcpci_regmap_config);\n\tif (IS_ERR(chip->data.regmap))\n\t\treturn PTR_ERR(chip->data.regmap);\n\n\ti2c_set_clientdata(client, chip);\n\n\t \n\terr = regmap_raw_write(chip->data.regmap, TCPC_ALERT_MASK, &val,\n\t\t\t       sizeof(u16));\n\tif (err < 0)\n\t\treturn err;\n\n\tchip->tcpci = tcpci_register_port(&client->dev, &chip->data);\n\tif (IS_ERR(chip->tcpci))\n\t\treturn PTR_ERR(chip->tcpci);\n\n\terr = devm_request_threaded_irq(&client->dev, client->irq, NULL,\n\t\t\t\t\t_tcpci_irq,\n\t\t\t\t\tIRQF_SHARED | IRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t\t\tdev_name(&client->dev), chip);\n\tif (err < 0) {\n\t\ttcpci_unregister_port(chip->tcpci);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void tcpci_remove(struct i2c_client *client)\n{\n\tstruct tcpci_chip *chip = i2c_get_clientdata(client);\n\tint err;\n\n\t \n\terr = tcpci_write16(chip->tcpci, TCPC_ALERT_MASK, 0);\n\tif (err < 0)\n\t\tdev_warn(&client->dev, \"Failed to disable irqs (%pe)\\n\", ERR_PTR(err));\n\n\ttcpci_unregister_port(chip->tcpci);\n}\n\nstatic const struct i2c_device_id tcpci_id[] = {\n\t{ \"tcpci\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, tcpci_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id tcpci_of_match[] = {\n\t{ .compatible = \"nxp,ptn5110\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, tcpci_of_match);\n#endif\n\nstatic struct i2c_driver tcpci_i2c_driver = {\n\t.driver = {\n\t\t.name = \"tcpci\",\n\t\t.of_match_table = of_match_ptr(tcpci_of_match),\n\t},\n\t.probe = tcpci_probe,\n\t.remove = tcpci_remove,\n\t.id_table = tcpci_id,\n};\nmodule_i2c_driver(tcpci_i2c_driver);\n\nMODULE_DESCRIPTION(\"USB Type-C Port Controller Interface driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}