{
  "module_name": "fusb302.c",
  "hash_id": "b631ff07ed4ad28699c5915fe8253266892f3c79a726006aac42e561f2fd1feb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/fusb302.c",
  "human_readable_source": "\n \n\n#include <linux/debugfs.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/extcon.h>\n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/proc_fs.h>\n#include <linux/regulator/consumer.h>\n#include <linux/sched/clock.h>\n#include <linux/seq_file.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/usb.h>\n#include <linux/usb/typec.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/pd.h>\n#include <linux/workqueue.h>\n\n#include \"fusb302_reg.h\"\n\n \n#define T_BC_LVL_DEBOUNCE_DELAY_MS 30\n\nenum toggling_mode {\n\tTOGGLING_MODE_OFF,\n\tTOGGLING_MODE_DRP,\n\tTOGGLING_MODE_SNK,\n\tTOGGLING_MODE_SRC,\n};\n\nenum src_current_status {\n\tSRC_CURRENT_DEFAULT,\n\tSRC_CURRENT_MEDIUM,\n\tSRC_CURRENT_HIGH,\n};\n\nstatic const u8 ra_mda_value[] = {\n\t[SRC_CURRENT_DEFAULT] = 4,\t \n\t[SRC_CURRENT_MEDIUM] = 9,\t \n\t[SRC_CURRENT_HIGH] = 18,\t \n};\n\nstatic const u8 rd_mda_value[] = {\n\t[SRC_CURRENT_DEFAULT] = 38,\t \n\t[SRC_CURRENT_MEDIUM] = 38,\t \n\t[SRC_CURRENT_HIGH] = 61,\t \n};\n\n#define LOG_BUFFER_ENTRIES\t1024\n#define LOG_BUFFER_ENTRY_SIZE\t128\n\nstruct fusb302_chip {\n\tstruct device *dev;\n\tstruct i2c_client *i2c_client;\n\tstruct tcpm_port *tcpm_port;\n\tstruct tcpc_dev tcpc_dev;\n\n\tstruct regulator *vbus;\n\n\tspinlock_t irq_lock;\n\tstruct work_struct irq_work;\n\tbool irq_suspended;\n\tbool irq_while_suspended;\n\tstruct gpio_desc *gpio_int_n;\n\tint gpio_int_n_irq;\n\tstruct extcon_dev *extcon;\n\n\tstruct workqueue_struct *wq;\n\tstruct delayed_work bc_lvl_handler;\n\n\t \n\tstruct mutex lock;\n\n\t \n\tenum toggling_mode toggling_mode;\n\tenum src_current_status src_current_status;\n\tbool intr_togdone;\n\tbool intr_bc_lvl;\n\tbool intr_comp_chng;\n\n\t \n\tbool vconn_on;\n\tbool vbus_on;\n\tbool charge_on;\n\tbool vbus_present;\n\tenum typec_cc_polarity cc_polarity;\n\tenum typec_cc_status cc1;\n\tenum typec_cc_status cc2;\n\tu32 snk_pdo[PDO_MAX_OBJECTS];\n\n#ifdef CONFIG_DEBUG_FS\n\tstruct dentry *dentry;\n\t \n\tstruct mutex logbuffer_lock;\n\tint logbuffer_head;\n\tint logbuffer_tail;\n\tu8 *logbuffer[LOG_BUFFER_ENTRIES];\n#endif\n};\n\n \n\n#ifdef CONFIG_DEBUG_FS\nstatic bool fusb302_log_full(struct fusb302_chip *chip)\n{\n\treturn chip->logbuffer_tail ==\n\t\t(chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;\n}\n\n__printf(2, 0)\nstatic void _fusb302_log(struct fusb302_chip *chip, const char *fmt,\n\t\t\t va_list args)\n{\n\tchar tmpbuffer[LOG_BUFFER_ENTRY_SIZE];\n\tu64 ts_nsec = local_clock();\n\tunsigned long rem_nsec;\n\n\tif (!chip->logbuffer[chip->logbuffer_head]) {\n\t\tchip->logbuffer[chip->logbuffer_head] =\n\t\t\t\tkzalloc(LOG_BUFFER_ENTRY_SIZE, GFP_KERNEL);\n\t\tif (!chip->logbuffer[chip->logbuffer_head])\n\t\t\treturn;\n\t}\n\n\tvsnprintf(tmpbuffer, sizeof(tmpbuffer), fmt, args);\n\n\tmutex_lock(&chip->logbuffer_lock);\n\n\tif (fusb302_log_full(chip)) {\n\t\tchip->logbuffer_head = max(chip->logbuffer_head - 1, 0);\n\t\tstrscpy(tmpbuffer, \"overflow\", sizeof(tmpbuffer));\n\t}\n\n\tif (chip->logbuffer_head < 0 ||\n\t    chip->logbuffer_head >= LOG_BUFFER_ENTRIES) {\n\t\tdev_warn(chip->dev,\n\t\t\t \"Bad log buffer index %d\\n\", chip->logbuffer_head);\n\t\tgoto abort;\n\t}\n\n\tif (!chip->logbuffer[chip->logbuffer_head]) {\n\t\tdev_warn(chip->dev,\n\t\t\t \"Log buffer index %d is NULL\\n\", chip->logbuffer_head);\n\t\tgoto abort;\n\t}\n\n\trem_nsec = do_div(ts_nsec, 1000000000);\n\tscnprintf(chip->logbuffer[chip->logbuffer_head],\n\t\t  LOG_BUFFER_ENTRY_SIZE, \"[%5lu.%06lu] %s\",\n\t\t  (unsigned long)ts_nsec, rem_nsec / 1000,\n\t\t  tmpbuffer);\n\tchip->logbuffer_head = (chip->logbuffer_head + 1) % LOG_BUFFER_ENTRIES;\n\nabort:\n\tmutex_unlock(&chip->logbuffer_lock);\n}\n\n__printf(2, 3)\nstatic void fusb302_log(struct fusb302_chip *chip, const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\t_fusb302_log(chip, fmt, args);\n\tva_end(args);\n}\n\nstatic int fusb302_debug_show(struct seq_file *s, void *v)\n{\n\tstruct fusb302_chip *chip = s->private;\n\tint tail;\n\n\tmutex_lock(&chip->logbuffer_lock);\n\ttail = chip->logbuffer_tail;\n\twhile (tail != chip->logbuffer_head) {\n\t\tseq_printf(s, \"%s\\n\", chip->logbuffer[tail]);\n\t\ttail = (tail + 1) % LOG_BUFFER_ENTRIES;\n\t}\n\tif (!seq_has_overflowed(s))\n\t\tchip->logbuffer_tail = tail;\n\tmutex_unlock(&chip->logbuffer_lock);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(fusb302_debug);\n\nstatic void fusb302_debugfs_init(struct fusb302_chip *chip)\n{\n\tchar name[NAME_MAX];\n\n\tmutex_init(&chip->logbuffer_lock);\n\tsnprintf(name, NAME_MAX, \"fusb302-%s\", dev_name(chip->dev));\n\tchip->dentry = debugfs_create_dir(name, usb_debug_root);\n\tdebugfs_create_file(\"log\", S_IFREG | 0444, chip->dentry, chip,\n\t\t\t    &fusb302_debug_fops);\n}\n\nstatic void fusb302_debugfs_exit(struct fusb302_chip *chip)\n{\n\tdebugfs_remove(chip->dentry);\n}\n\n#else\n\nstatic void fusb302_log(const struct fusb302_chip *chip,\n\t\t\tconst char *fmt, ...) { }\nstatic void fusb302_debugfs_init(const struct fusb302_chip *chip) { }\nstatic void fusb302_debugfs_exit(const struct fusb302_chip *chip) { }\n\n#endif\n\nstatic int fusb302_i2c_write(struct fusb302_chip *chip,\n\t\t\t     u8 address, u8 data)\n{\n\tint ret = 0;\n\n\tret = i2c_smbus_write_byte_data(chip->i2c_client, address, data);\n\tif (ret < 0)\n\t\tfusb302_log(chip, \"cannot write 0x%02x to 0x%02x, ret=%d\",\n\t\t\t    data, address, ret);\n\n\treturn ret;\n}\n\nstatic int fusb302_i2c_block_write(struct fusb302_chip *chip, u8 address,\n\t\t\t\t   u8 length, const u8 *data)\n{\n\tint ret = 0;\n\n\tif (length <= 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_write_i2c_block_data(chip->i2c_client, address,\n\t\t\t\t\t     length, data);\n\tif (ret < 0)\n\t\tfusb302_log(chip, \"cannot block write 0x%02x, len=%d, ret=%d\",\n\t\t\t    address, length, ret);\n\n\treturn ret;\n}\n\nstatic int fusb302_i2c_read(struct fusb302_chip *chip,\n\t\t\t    u8 address, u8 *data)\n{\n\tint ret = 0;\n\n\tret = i2c_smbus_read_byte_data(chip->i2c_client, address);\n\t*data = (u8)ret;\n\tif (ret < 0)\n\t\tfusb302_log(chip, \"cannot read %02x, ret=%d\", address, ret);\n\n\treturn ret;\n}\n\nstatic int fusb302_i2c_block_read(struct fusb302_chip *chip, u8 address,\n\t\t\t\t  u8 length, u8 *data)\n{\n\tint ret = 0;\n\n\tif (length <= 0)\n\t\treturn ret;\n\n\tret = i2c_smbus_read_i2c_block_data(chip->i2c_client, address,\n\t\t\t\t\t    length, data);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot block read 0x%02x, len=%d, ret=%d\",\n\t\t\t    address, length, ret);\n\t\tgoto done;\n\t}\n\tif (ret != length) {\n\t\tfusb302_log(chip, \"only read %d/%d bytes from 0x%02x\",\n\t\t\t    ret, length, address);\n\t\tret = -EIO;\n\t}\n\ndone:\n\treturn ret;\n}\n\nstatic int fusb302_i2c_mask_write(struct fusb302_chip *chip, u8 address,\n\t\t\t\t  u8 mask, u8 value)\n{\n\tint ret = 0;\n\tu8 data;\n\n\tret = fusb302_i2c_read(chip, address, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tdata &= ~mask;\n\tdata |= value;\n\tret = fusb302_i2c_write(chip, address, data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int fusb302_i2c_set_bits(struct fusb302_chip *chip, u8 address,\n\t\t\t\tu8 set_bits)\n{\n\treturn fusb302_i2c_mask_write(chip, address, 0x00, set_bits);\n}\n\nstatic int fusb302_i2c_clear_bits(struct fusb302_chip *chip, u8 address,\n\t\t\t\t  u8 clear_bits)\n{\n\treturn fusb302_i2c_mask_write(chip, address, clear_bits, 0x00);\n}\n\nstatic int fusb302_sw_reset(struct fusb302_chip *chip)\n{\n\tint ret = 0;\n\n\tret = fusb302_i2c_write(chip, FUSB_REG_RESET,\n\t\t\t\tFUSB_REG_RESET_SW_RESET);\n\tif (ret < 0)\n\t\tfusb302_log(chip, \"cannot sw reset the chip, ret=%d\", ret);\n\telse\n\t\tfusb302_log(chip, \"sw reset\");\n\n\treturn ret;\n}\n\nstatic int fusb302_enable_tx_auto_retries(struct fusb302_chip *chip, u8 retry_count)\n{\n\tint ret = 0;\n\n\tret = fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL3, retry_count |\n\t\t\t\t   FUSB_REG_CONTROL3_AUTO_RETRY);\n\n\treturn ret;\n}\n\n \nstatic int fusb302_init_interrupt(struct fusb302_chip *chip)\n{\n\tint ret = 0;\n\n\tret = fusb302_i2c_write(chip, FUSB_REG_MASK,\n\t\t\t\t0xFF & ~FUSB_REG_MASK_VBUSOK);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_write(chip, FUSB_REG_MASKA, 0xFF);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_write(chip, FUSB_REG_MASKB, 0xFF);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_clear_bits(chip, FUSB_REG_CONTROL0,\n\t\t\t\t     FUSB_REG_CONTROL0_INT_MASK);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret;\n}\n\nstatic int fusb302_set_power_mode(struct fusb302_chip *chip, u8 power_mode)\n{\n\tint ret = 0;\n\n\tret = fusb302_i2c_write(chip, FUSB_REG_POWER, power_mode);\n\n\treturn ret;\n}\n\nstatic int tcpm_init(struct tcpc_dev *dev)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\tu8 data;\n\n\tret = fusb302_sw_reset(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_enable_tx_auto_retries(chip, FUSB_REG_CONTROL3_N_RETRIES_3);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_init_interrupt(chip);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_set_power_mode(chip, FUSB_REG_POWER_PWR_ALL);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tchip->vbus_present = !!(data & FUSB_REG_STATUS0_VBUSOK);\n\tret = fusb302_i2c_read(chip, FUSB_REG_DEVICE_ID, &data);\n\tif (ret < 0)\n\t\treturn ret;\n\tfusb302_log(chip, \"fusb302 device ID: 0x%02x\", data);\n\n\treturn ret;\n}\n\nstatic int tcpm_get_vbus(struct tcpc_dev *dev)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tret = chip->vbus_present ? 1 : 0;\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_get_current_limit(struct tcpc_dev *dev)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint current_limit = 0;\n\tunsigned long timeout;\n\n\tif (!chip->extcon)\n\t\treturn 0;\n\n\t \n\ttimeout = jiffies + msecs_to_jiffies(800);\n\tdo {\n\t\tif (extcon_get_state(chip->extcon, EXTCON_CHG_USB_SDP) == 1)\n\t\t\tcurrent_limit = 500;\n\n\t\tif (extcon_get_state(chip->extcon, EXTCON_CHG_USB_CDP) == 1 ||\n\t\t    extcon_get_state(chip->extcon, EXTCON_CHG_USB_ACA) == 1)\n\t\t\tcurrent_limit = 1500;\n\n\t\tif (extcon_get_state(chip->extcon, EXTCON_CHG_USB_DCP) == 1)\n\t\t\tcurrent_limit = 2000;\n\n\t\tmsleep(50);\n\t} while (current_limit == 0 && time_before(jiffies, timeout));\n\n\treturn current_limit;\n}\n\nstatic int fusb302_set_src_current(struct fusb302_chip *chip,\n\t\t\t\t   enum src_current_status status)\n{\n\tint ret = 0;\n\n\tchip->src_current_status = status;\n\tswitch (status) {\n\tcase SRC_CURRENT_DEFAULT:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_DEF);\n\t\tbreak;\n\tcase SRC_CURRENT_MEDIUM:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_MED);\n\t\tbreak;\n\tcase SRC_CURRENT_HIGH:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL0,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL0_HOST_CUR_HIGH);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int fusb302_set_toggling(struct fusb302_chip *chip,\n\t\t\t\tenum toggling_mode mode)\n{\n\tint ret = 0;\n\n\t \n\tret = fusb302_i2c_clear_bits(chip, FUSB_REG_CONTROL2,\n\t\t\t\t     FUSB_REG_CONTROL2_TOGGLE);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = fusb302_i2c_set_bits(chip, FUSB_REG_MASK,\n\t\t\t\t   FUSB_REG_MASK_BC_LVL |\n\t\t\t\t   FUSB_REG_MASK_COMP_CHNG);\n\tif (ret < 0)\n\t\treturn ret;\n\tchip->intr_bc_lvl = false;\n\tchip->intr_comp_chng = false;\n\t \n\tswitch (mode) {\n\tcase TOGGLING_MODE_OFF:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_NONE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TOGGLING_MODE_SNK:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_UFP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TOGGLING_MODE_SRC:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_DFP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase TOGGLING_MODE_DRP:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_CONTROL2,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_MASK,\n\t\t\t\t\t     FUSB_REG_CONTROL2_MODE_DRP);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (mode == TOGGLING_MODE_OFF) {\n\t\t \n\t\tret = fusb302_i2c_set_bits(chip, FUSB_REG_MASKA,\n\t\t\t\t\t   FUSB_REG_MASKA_TOGDONE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tchip->intr_togdone = false;\n\t} else {\n\t\t \n\t\tWARN(chip->vconn_on, \"Vconn is on during toggle start\");\n\t\t \n\t\tret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASKA,\n\t\t\t\t\t     FUSB_REG_MASKA_TOGDONE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tchip->intr_togdone = true;\n\t\t \n\t\tret = fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL2,\n\t\t\t\t\t   FUSB_REG_CONTROL2_TOGGLE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\tchip->cc1 = TYPEC_CC_OPEN;\n\t\tchip->cc2 = TYPEC_CC_OPEN;\n\t}\n\tchip->toggling_mode = mode;\n\n\treturn ret;\n}\n\nstatic const char * const typec_cc_status_name[] = {\n\t[TYPEC_CC_OPEN]\t\t= \"Open\",\n\t[TYPEC_CC_RA]\t\t= \"Ra\",\n\t[TYPEC_CC_RD]\t\t= \"Rd\",\n\t[TYPEC_CC_RP_DEF]\t= \"Rp-def\",\n\t[TYPEC_CC_RP_1_5]\t= \"Rp-1.5\",\n\t[TYPEC_CC_RP_3_0]\t= \"Rp-3.0\",\n};\n\nstatic const enum src_current_status cc_src_current[] = {\n\t[TYPEC_CC_OPEN]\t\t= SRC_CURRENT_DEFAULT,\n\t[TYPEC_CC_RA]\t\t= SRC_CURRENT_DEFAULT,\n\t[TYPEC_CC_RD]\t\t= SRC_CURRENT_DEFAULT,\n\t[TYPEC_CC_RP_DEF]\t= SRC_CURRENT_DEFAULT,\n\t[TYPEC_CC_RP_1_5]\t= SRC_CURRENT_MEDIUM,\n\t[TYPEC_CC_RP_3_0]\t= SRC_CURRENT_HIGH,\n};\n\nstatic int tcpm_set_cc(struct tcpc_dev *dev, enum typec_cc_status cc)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tu8 switches0_mask = FUSB_REG_SWITCHES0_CC1_PU_EN |\n\t\t\t    FUSB_REG_SWITCHES0_CC2_PU_EN |\n\t\t\t    FUSB_REG_SWITCHES0_CC1_PD_EN |\n\t\t\t    FUSB_REG_SWITCHES0_CC2_PD_EN;\n\tu8 rd_mda, switches0_data = 0x00;\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tswitch (cc) {\n\tcase TYPEC_CC_OPEN:\n\t\tbreak;\n\tcase TYPEC_CC_RD:\n\t\tswitches0_data |= FUSB_REG_SWITCHES0_CC1_PD_EN |\n\t\t\t\t  FUSB_REG_SWITCHES0_CC2_PD_EN;\n\t\tbreak;\n\tcase TYPEC_CC_RP_DEF:\n\tcase TYPEC_CC_RP_1_5:\n\tcase TYPEC_CC_RP_3_0:\n\t\tswitches0_data |= (chip->cc_polarity == TYPEC_POLARITY_CC1) ?\n\t\t\t\t  FUSB_REG_SWITCHES0_CC1_PU_EN :\n\t\t\t\t  FUSB_REG_SWITCHES0_CC2_PU_EN;\n\t\tbreak;\n\tdefault:\n\t\tfusb302_log(chip, \"unsupported cc value %s\",\n\t\t\t    typec_cc_status_name[cc]);\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tfusb302_log(chip, \"cc := %s\", typec_cc_status_name[cc]);\n\n\tret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set toggling mode, ret=%d\", ret);\n\t\tgoto done;\n\t}\n\n\tret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES0,\n\t\t\t\t     switches0_mask, switches0_data);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set pull-up/-down, ret = %d\", ret);\n\t\tgoto done;\n\t}\n\t \n\tchip->cc1 = TYPEC_CC_OPEN;\n\tchip->cc2 = TYPEC_CC_OPEN;\n\n\t \n\tret = fusb302_set_src_current(chip, cc_src_current[cc]);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set src current %s, ret=%d\",\n\t\t\t    typec_cc_status_name[cc], ret);\n\t\tgoto done;\n\t}\n\n\t \n\tswitch (cc) {\n\tcase TYPEC_CC_RP_DEF:\n\tcase TYPEC_CC_RP_1_5:\n\tcase TYPEC_CC_RP_3_0:\n\t\trd_mda = rd_mda_value[cc_src_current[cc]];\n\t\tret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"cannot set SRC measure value, ret=%d\",\n\t\t\t\t    ret);\n\t\t\tgoto done;\n\t\t}\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_MASK,\n\t\t\t\t\t     FUSB_REG_MASK_BC_LVL |\n\t\t\t\t\t     FUSB_REG_MASK_COMP_CHNG,\n\t\t\t\t\t     FUSB_REG_MASK_BC_LVL);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip, \"cannot set SRC interrupt, ret=%d\",\n\t\t\t\t    ret);\n\t\t\tgoto done;\n\t\t}\n\t\tchip->intr_comp_chng = true;\n\t\tchip->intr_bc_lvl = false;\n\t\tbreak;\n\tcase TYPEC_CC_RD:\n\t\tret = fusb302_i2c_mask_write(chip, FUSB_REG_MASK,\n\t\t\t\t\t     FUSB_REG_MASK_BC_LVL |\n\t\t\t\t\t     FUSB_REG_MASK_COMP_CHNG,\n\t\t\t\t\t     FUSB_REG_MASK_COMP_CHNG);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip, \"cannot set SRC interrupt, ret=%d\",\n\t\t\t\t    ret);\n\t\t\tgoto done;\n\t\t}\n\t\tchip->intr_bc_lvl = true;\n\t\tchip->intr_comp_chng = false;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_get_cc(struct tcpc_dev *dev, enum typec_cc_status *cc1,\n\t\t       enum typec_cc_status *cc2)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\n\tmutex_lock(&chip->lock);\n\t*cc1 = chip->cc1;\n\t*cc2 = chip->cc2;\n\tfusb302_log(chip, \"cc1=%s, cc2=%s\", typec_cc_status_name[*cc1],\n\t\t    typec_cc_status_name[*cc2]);\n\tmutex_unlock(&chip->lock);\n\n\treturn 0;\n}\n\nstatic int tcpm_set_polarity(struct tcpc_dev *dev,\n\t\t\t     enum typec_cc_polarity polarity)\n{\n\treturn 0;\n}\n\nstatic int tcpm_set_vconn(struct tcpc_dev *dev, bool on)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\tu8 switches0_data = 0x00;\n\tu8 switches0_mask = FUSB_REG_SWITCHES0_VCONN_CC1 |\n\t\t\t    FUSB_REG_SWITCHES0_VCONN_CC2;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->vconn_on == on) {\n\t\tfusb302_log(chip, \"vconn is already %s\", on ? \"On\" : \"Off\");\n\t\tgoto done;\n\t}\n\tif (on) {\n\t\tswitches0_data = (chip->cc_polarity == TYPEC_POLARITY_CC1) ?\n\t\t\t\t FUSB_REG_SWITCHES0_VCONN_CC2 :\n\t\t\t\t FUSB_REG_SWITCHES0_VCONN_CC1;\n\t}\n\tret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES0,\n\t\t\t\t     switches0_mask, switches0_data);\n\tif (ret < 0)\n\t\tgoto done;\n\tchip->vconn_on = on;\n\tfusb302_log(chip, \"vconn := %s\", on ? \"On\" : \"Off\");\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_set_vbus(struct tcpc_dev *dev, bool on, bool charge)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tif (chip->vbus_on == on) {\n\t\tfusb302_log(chip, \"vbus is already %s\", on ? \"On\" : \"Off\");\n\t} else {\n\t\tif (on)\n\t\t\tret = regulator_enable(chip->vbus);\n\t\telse\n\t\t\tret = regulator_disable(chip->vbus);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip, \"cannot %s vbus regulator, ret=%d\",\n\t\t\t\t    on ? \"enable\" : \"disable\", ret);\n\t\t\tgoto done;\n\t\t}\n\t\tchip->vbus_on = on;\n\t\tfusb302_log(chip, \"vbus := %s\", on ? \"On\" : \"Off\");\n\t}\n\tif (chip->charge_on == charge)\n\t\tfusb302_log(chip, \"charge is already %s\",\n\t\t\t    charge ? \"On\" : \"Off\");\n\telse\n\t\tchip->charge_on = charge;\n\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int fusb302_pd_tx_flush(struct fusb302_chip *chip)\n{\n\treturn fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL0,\n\t\t\t\t    FUSB_REG_CONTROL0_TX_FLUSH);\n}\n\nstatic int fusb302_pd_rx_flush(struct fusb302_chip *chip)\n{\n\treturn fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL1,\n\t\t\t\t    FUSB_REG_CONTROL1_RX_FLUSH);\n}\n\nstatic int fusb302_pd_set_auto_goodcrc(struct fusb302_chip *chip, bool on)\n{\n\tif (on)\n\t\treturn fusb302_i2c_set_bits(chip, FUSB_REG_SWITCHES1,\n\t\t\t\t\t    FUSB_REG_SWITCHES1_AUTO_GCRC);\n\treturn fusb302_i2c_clear_bits(chip, FUSB_REG_SWITCHES1,\n\t\t\t\t\t    FUSB_REG_SWITCHES1_AUTO_GCRC);\n}\n\nstatic int fusb302_pd_set_interrupts(struct fusb302_chip *chip, bool on)\n{\n\tint ret = 0;\n\tu8 mask_interrupts = FUSB_REG_MASK_COLLISION;\n\tu8 maska_interrupts = FUSB_REG_MASKA_RETRYFAIL |\n\t\t\t      FUSB_REG_MASKA_HARDSENT |\n\t\t\t      FUSB_REG_MASKA_TX_SUCCESS |\n\t\t\t      FUSB_REG_MASKA_HARDRESET;\n\tu8 maskb_interrupts = FUSB_REG_MASKB_GCRCSENT;\n\n\tret = on ?\n\t\tfusb302_i2c_clear_bits(chip, FUSB_REG_MASK, mask_interrupts) :\n\t\tfusb302_i2c_set_bits(chip, FUSB_REG_MASK, mask_interrupts);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = on ?\n\t\tfusb302_i2c_clear_bits(chip, FUSB_REG_MASKA, maska_interrupts) :\n\t\tfusb302_i2c_set_bits(chip, FUSB_REG_MASKA, maska_interrupts);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = on ?\n\t\tfusb302_i2c_clear_bits(chip, FUSB_REG_MASKB, maskb_interrupts) :\n\t\tfusb302_i2c_set_bits(chip, FUSB_REG_MASKB, maskb_interrupts);\n\treturn ret;\n}\n\nstatic int tcpm_set_pd_rx(struct tcpc_dev *dev, bool on)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tret = fusb302_pd_rx_flush(chip);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot flush pd rx buffer, ret=%d\", ret);\n\t\tgoto done;\n\t}\n\tret = fusb302_pd_tx_flush(chip);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot flush pd tx buffer, ret=%d\", ret);\n\t\tgoto done;\n\t}\n\tret = fusb302_pd_set_auto_goodcrc(chip, on);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot turn %s auto GCRC, ret=%d\",\n\t\t\t    on ? \"on\" : \"off\", ret);\n\t\tgoto done;\n\t}\n\tret = fusb302_pd_set_interrupts(chip, on);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot turn %s pd interrupts, ret=%d\",\n\t\t\t    on ? \"on\" : \"off\", ret);\n\t\tgoto done;\n\t}\n\tfusb302_log(chip, \"pd := %s\", on ? \"on\" : \"off\");\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic const char * const typec_role_name[] = {\n\t[TYPEC_SINK]\t\t= \"Sink\",\n\t[TYPEC_SOURCE]\t\t= \"Source\",\n};\n\nstatic const char * const typec_data_role_name[] = {\n\t[TYPEC_DEVICE]\t\t= \"Device\",\n\t[TYPEC_HOST]\t\t= \"Host\",\n};\n\nstatic int tcpm_set_roles(struct tcpc_dev *dev, bool attached,\n\t\t\t  enum typec_role pwr, enum typec_data_role data)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\tu8 switches1_mask = FUSB_REG_SWITCHES1_POWERROLE |\n\t\t\t    FUSB_REG_SWITCHES1_DATAROLE;\n\tu8 switches1_data = 0x00;\n\n\tmutex_lock(&chip->lock);\n\tif (pwr == TYPEC_SOURCE)\n\t\tswitches1_data |= FUSB_REG_SWITCHES1_POWERROLE;\n\tif (data == TYPEC_HOST)\n\t\tswitches1_data |= FUSB_REG_SWITCHES1_DATAROLE;\n\tret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES1,\n\t\t\t\t     switches1_mask, switches1_data);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"unable to set pd header %s, %s, ret=%d\",\n\t\t\t    typec_role_name[pwr], typec_data_role_name[data],\n\t\t\t    ret);\n\t\tgoto done;\n\t}\n\tfusb302_log(chip, \"pd header := %s, %s\", typec_role_name[pwr],\n\t\t    typec_data_role_name[data]);\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int tcpm_start_toggling(struct tcpc_dev *dev,\n\t\t\t       enum typec_port_type port_type,\n\t\t\t       enum typec_cc_status cc)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tenum toggling_mode mode = TOGGLING_MODE_OFF;\n\tint ret = 0;\n\n\tswitch (port_type) {\n\tcase TYPEC_PORT_SRC:\n\t\tmode = TOGGLING_MODE_SRC;\n\t\tbreak;\n\tcase TYPEC_PORT_SNK:\n\t\tmode = TOGGLING_MODE_SNK;\n\t\tbreak;\n\tcase TYPEC_PORT_DRP:\n\t\tmode = TOGGLING_MODE_DRP;\n\t\tbreak;\n\t}\n\n\tmutex_lock(&chip->lock);\n\tret = fusb302_set_src_current(chip, cc_src_current[cc]);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"unable to set src current %s, ret=%d\",\n\t\t\t    typec_cc_status_name[cc], ret);\n\t\tgoto done;\n\t}\n\tret = fusb302_set_toggling(chip, mode);\n\tif (ret < 0) {\n\t\tfusb302_log(chip,\n\t\t\t    \"unable to start drp toggling, ret=%d\", ret);\n\t\tgoto done;\n\t}\n\tfusb302_log(chip, \"start drp toggling\");\ndone:\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic int fusb302_pd_send_message(struct fusb302_chip *chip,\n\t\t\t\t   const struct pd_message *msg)\n{\n\tint ret = 0;\n\tu8 buf[40];\n\tu8 pos = 0;\n\tint len;\n\n\t \n\tbuf[pos++] = FUSB302_TKN_SYNC1;\n\tbuf[pos++] = FUSB302_TKN_SYNC1;\n\tbuf[pos++] = FUSB302_TKN_SYNC1;\n\tbuf[pos++] = FUSB302_TKN_SYNC2;\n\n\tlen = pd_header_cnt_le(msg->header) * 4;\n\t \n\tlen += 2;\n\tif (len > 0x1F) {\n\t\tfusb302_log(chip,\n\t\t\t    \"PD message too long %d (incl. header)\", len);\n\t\treturn -EINVAL;\n\t}\n\t \n\tbuf[pos++] = FUSB302_TKN_PACKSYM | (len & 0x1F);\n\tmemcpy(&buf[pos], &msg->header, sizeof(msg->header));\n\tpos += sizeof(msg->header);\n\n\tlen -= 2;\n\tmemcpy(&buf[pos], msg->payload, len);\n\tpos += len;\n\n\t \n\tbuf[pos++] = FUSB302_TKN_JAMCRC;\n\t \n\tbuf[pos++] = FUSB302_TKN_EOP;\n\t \n\tbuf[pos++] = FUSB302_TKN_TXOFF;\n\t \n\tbuf[pos++] = FUSB302_TKN_TXON;\n\n\tret = fusb302_i2c_block_write(chip, FUSB_REG_FIFOS, pos, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tfusb302_log(chip, \"sending PD message header: %x\", msg->header);\n\tfusb302_log(chip, \"sending PD message len: %d\", len);\n\n\treturn ret;\n}\n\nstatic int fusb302_pd_send_hardreset(struct fusb302_chip *chip)\n{\n\treturn fusb302_i2c_set_bits(chip, FUSB_REG_CONTROL3,\n\t\t\t\t    FUSB_REG_CONTROL3_SEND_HARDRESET);\n}\n\nstatic const char * const transmit_type_name[] = {\n\t[TCPC_TX_SOP]\t\t\t= \"SOP\",\n\t[TCPC_TX_SOP_PRIME]\t\t= \"SOP'\",\n\t[TCPC_TX_SOP_PRIME_PRIME]\t= \"SOP''\",\n\t[TCPC_TX_SOP_DEBUG_PRIME]\t= \"DEBUG'\",\n\t[TCPC_TX_SOP_DEBUG_PRIME_PRIME]\t= \"DEBUG''\",\n\t[TCPC_TX_HARD_RESET]\t\t= \"HARD_RESET\",\n\t[TCPC_TX_CABLE_RESET]\t\t= \"CABLE_RESET\",\n\t[TCPC_TX_BIST_MODE_2]\t\t= \"BIST_MODE_2\",\n};\n\nstatic int tcpm_pd_transmit(struct tcpc_dev *dev, enum tcpm_transmit_type type,\n\t\t\t    const struct pd_message *msg, unsigned int negotiated_rev)\n{\n\tstruct fusb302_chip *chip = container_of(dev, struct fusb302_chip,\n\t\t\t\t\t\t tcpc_dev);\n\tint ret = 0;\n\n\tmutex_lock(&chip->lock);\n\tswitch (type) {\n\tcase TCPC_TX_SOP:\n\t\t \n\t\tret = fusb302_enable_tx_auto_retries(chip, negotiated_rev > PD_REV20 ?\n\t\t\t\t\t\t     FUSB_REG_CONTROL3_N_RETRIES_2 :\n\t\t\t\t\t\t     FUSB_REG_CONTROL3_N_RETRIES_3);\n\t\tif (ret < 0)\n\t\t\tfusb302_log(chip, \"Cannot update retry count ret=%d\", ret);\n\n\t\tret = fusb302_pd_send_message(chip, msg);\n\t\tif (ret < 0)\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"cannot send PD message, ret=%d\", ret);\n\t\tbreak;\n\tcase TCPC_TX_HARD_RESET:\n\t\tret = fusb302_pd_send_hardreset(chip);\n\t\tif (ret < 0)\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"cannot send hardreset, ret=%d\", ret);\n\t\tbreak;\n\tdefault:\n\t\tfusb302_log(chip, \"type %s not supported\",\n\t\t\t    transmit_type_name[type]);\n\t\tret = -EINVAL;\n\t}\n\tmutex_unlock(&chip->lock);\n\n\treturn ret;\n}\n\nstatic enum typec_cc_status fusb302_bc_lvl_to_cc(u8 bc_lvl)\n{\n\tif (bc_lvl == FUSB_REG_STATUS0_BC_LVL_1230_MAX)\n\t\treturn TYPEC_CC_RP_3_0;\n\tif (bc_lvl == FUSB_REG_STATUS0_BC_LVL_600_1230)\n\t\treturn TYPEC_CC_RP_1_5;\n\tif (bc_lvl == FUSB_REG_STATUS0_BC_LVL_200_600)\n\t\treturn TYPEC_CC_RP_DEF;\n\treturn TYPEC_CC_OPEN;\n}\n\nstatic void fusb302_bc_lvl_handler_work(struct work_struct *work)\n{\n\tstruct fusb302_chip *chip = container_of(work, struct fusb302_chip,\n\t\t\t\t\t\t bc_lvl_handler.work);\n\tint ret = 0;\n\tu8 status0;\n\tu8 bc_lvl;\n\tenum typec_cc_status cc_status;\n\n\tmutex_lock(&chip->lock);\n\tif (!chip->intr_bc_lvl) {\n\t\tfusb302_log(chip, \"BC_LVL interrupt is turned off, abort\");\n\t\tgoto done;\n\t}\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\tgoto done;\n\tfusb302_log(chip, \"BC_LVL handler, status0=0x%02x\", status0);\n\tif (status0 & FUSB_REG_STATUS0_ACTIVITY) {\n\t\tfusb302_log(chip, \"CC activities detected, delay handling\");\n\t\tmod_delayed_work(chip->wq, &chip->bc_lvl_handler,\n\t\t\t\t msecs_to_jiffies(T_BC_LVL_DEBOUNCE_DELAY_MS));\n\t\tgoto done;\n\t}\n\tbc_lvl = status0 & FUSB_REG_STATUS0_BC_LVL_MASK;\n\tcc_status = fusb302_bc_lvl_to_cc(bc_lvl);\n\tif (chip->cc_polarity == TYPEC_POLARITY_CC1) {\n\t\tif (chip->cc1 != cc_status) {\n\t\t\tfusb302_log(chip, \"cc1: %s -> %s\",\n\t\t\t\t    typec_cc_status_name[chip->cc1],\n\t\t\t\t    typec_cc_status_name[cc_status]);\n\t\t\tchip->cc1 = cc_status;\n\t\t\ttcpm_cc_change(chip->tcpm_port);\n\t\t}\n\t} else {\n\t\tif (chip->cc2 != cc_status) {\n\t\t\tfusb302_log(chip, \"cc2: %s -> %s\",\n\t\t\t\t    typec_cc_status_name[chip->cc2],\n\t\t\t\t    typec_cc_status_name[cc_status]);\n\t\t\tchip->cc2 = cc_status;\n\t\t\ttcpm_cc_change(chip->tcpm_port);\n\t\t}\n\t}\n\ndone:\n\tmutex_unlock(&chip->lock);\n}\n\nstatic void init_tcpc_dev(struct tcpc_dev *fusb302_tcpc_dev)\n{\n\tfusb302_tcpc_dev->init = tcpm_init;\n\tfusb302_tcpc_dev->get_vbus = tcpm_get_vbus;\n\tfusb302_tcpc_dev->get_current_limit = tcpm_get_current_limit;\n\tfusb302_tcpc_dev->set_cc = tcpm_set_cc;\n\tfusb302_tcpc_dev->get_cc = tcpm_get_cc;\n\tfusb302_tcpc_dev->set_polarity = tcpm_set_polarity;\n\tfusb302_tcpc_dev->set_vconn = tcpm_set_vconn;\n\tfusb302_tcpc_dev->set_vbus = tcpm_set_vbus;\n\tfusb302_tcpc_dev->set_pd_rx = tcpm_set_pd_rx;\n\tfusb302_tcpc_dev->set_roles = tcpm_set_roles;\n\tfusb302_tcpc_dev->start_toggling = tcpm_start_toggling;\n\tfusb302_tcpc_dev->pd_transmit = tcpm_pd_transmit;\n}\n\nstatic const char * const cc_polarity_name[] = {\n\t[TYPEC_POLARITY_CC1]\t= \"Polarity_CC1\",\n\t[TYPEC_POLARITY_CC2]\t= \"Polarity_CC2\",\n};\n\nstatic int fusb302_set_cc_polarity_and_pull(struct fusb302_chip *chip,\n\t\t\t\t\t    enum typec_cc_polarity cc_polarity,\n\t\t\t\t\t    bool pull_up, bool pull_down)\n{\n\tint ret = 0;\n\tu8 switches0_data = 0x00;\n\tu8 switches1_mask = FUSB_REG_SWITCHES1_TXCC1_EN |\n\t\t\t    FUSB_REG_SWITCHES1_TXCC2_EN;\n\tu8 switches1_data = 0x00;\n\n\tif (pull_down)\n\t\tswitches0_data |= FUSB_REG_SWITCHES0_CC1_PD_EN |\n\t\t\t\t  FUSB_REG_SWITCHES0_CC2_PD_EN;\n\n\tif (cc_polarity == TYPEC_POLARITY_CC1) {\n\t\tswitches0_data |= FUSB_REG_SWITCHES0_MEAS_CC1;\n\t\tif (chip->vconn_on)\n\t\t\tswitches0_data |= FUSB_REG_SWITCHES0_VCONN_CC2;\n\t\tif (pull_up)\n\t\t\tswitches0_data |= FUSB_REG_SWITCHES0_CC1_PU_EN;\n\t\tswitches1_data = FUSB_REG_SWITCHES1_TXCC1_EN;\n\t} else {\n\t\tswitches0_data |= FUSB_REG_SWITCHES0_MEAS_CC2;\n\t\tif (chip->vconn_on)\n\t\t\tswitches0_data |= FUSB_REG_SWITCHES0_VCONN_CC1;\n\t\tif (pull_up)\n\t\t\tswitches0_data |= FUSB_REG_SWITCHES0_CC2_PU_EN;\n\t\tswitches1_data = FUSB_REG_SWITCHES1_TXCC2_EN;\n\t}\n\tret = fusb302_i2c_write(chip, FUSB_REG_SWITCHES0, switches0_data);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_mask_write(chip, FUSB_REG_SWITCHES1,\n\t\t\t\t     switches1_mask, switches1_data);\n\tif (ret < 0)\n\t\treturn ret;\n\tchip->cc_polarity = cc_polarity;\n\n\treturn ret;\n}\n\nstatic int fusb302_handle_togdone_snk(struct fusb302_chip *chip,\n\t\t\t\t      u8 togdone_result)\n{\n\tint ret = 0;\n\tu8 status0;\n\tu8 bc_lvl;\n\tenum typec_cc_polarity cc_polarity;\n\tenum typec_cc_status cc_status_active, cc1, cc2;\n\n\t \n\tcc_polarity = (togdone_result == FUSB_REG_STATUS1A_TOGSS_SNK1) ?\n\t\t      TYPEC_POLARITY_CC1 : TYPEC_POLARITY_CC2;\n\tret = fusb302_set_cc_polarity_and_pull(chip, cc_polarity, false, true);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set cc polarity %s, ret=%d\",\n\t\t\t    cc_polarity_name[cc_polarity], ret);\n\t\treturn ret;\n\t}\n\t \n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\treturn ret;\n\tbc_lvl = status0 & FUSB_REG_STATUS0_BC_LVL_MASK;\n\tcc_status_active = fusb302_bc_lvl_to_cc(bc_lvl);\n\t \n\tif (cc_status_active == TYPEC_CC_OPEN) {\n\t\tfusb302_log(chip, \"restart toggling as CC_OPEN detected\");\n\t\tret = fusb302_set_toggling(chip, chip->toggling_mode);\n\t\treturn ret;\n\t}\n\t \n\tcc1 = (cc_polarity == TYPEC_POLARITY_CC1) ?\n\t      cc_status_active : TYPEC_CC_OPEN;\n\tcc2 = (cc_polarity == TYPEC_POLARITY_CC2) ?\n\t      cc_status_active : TYPEC_CC_OPEN;\n\tif ((chip->cc1 != cc1) || (chip->cc2 != cc2)) {\n\t\tchip->cc1 = cc1;\n\t\tchip->cc2 = cc2;\n\t\ttcpm_cc_change(chip->tcpm_port);\n\t}\n\t \n\tret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);\n\tif (ret < 0) {\n\t\tfusb302_log(chip,\n\t\t\t    \"cannot set toggling mode off, ret=%d\", ret);\n\t\treturn ret;\n\t}\n\t \n\tret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASK, FUSB_REG_MASK_BC_LVL);\n\tif (ret < 0) {\n\t\tfusb302_log(chip,\n\t\t\t    \"cannot unmask bc_lcl interrupt, ret=%d\", ret);\n\t\treturn ret;\n\t}\n\tchip->intr_bc_lvl = true;\n\tfusb302_log(chip, \"detected cc1=%s, cc2=%s\",\n\t\t    typec_cc_status_name[cc1],\n\t\t    typec_cc_status_name[cc2]);\n\n\treturn ret;\n}\n\n \nstatic int fusb302_get_src_cc_status(struct fusb302_chip *chip,\n\t\t\t\t     enum typec_cc_polarity cc_polarity,\n\t\t\t\t     enum typec_cc_status *cc)\n{\n\tu8 ra_mda = ra_mda_value[chip->src_current_status];\n\tu8 rd_mda = rd_mda_value[chip->src_current_status];\n\tu8 switches0_data, status0;\n\tint ret;\n\n\t \n\tswitches0_data = (cc_polarity == TYPEC_POLARITY_CC1) ?\n\t\tFUSB_REG_SWITCHES0_CC1_PU_EN | FUSB_REG_SWITCHES0_MEAS_CC1 :\n\t\tFUSB_REG_SWITCHES0_CC2_PU_EN | FUSB_REG_SWITCHES0_MEAS_CC2;\n\tret = fusb302_i2c_write(chip, FUSB_REG_SWITCHES0, switches0_data);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfusb302_i2c_read(chip, FUSB_REG_SWITCHES0, &status0);\n\tfusb302_log(chip, \"get_src_cc_status switches: 0x%0x\", status0);\n\n\t \n\tret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(50, 100);\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfusb302_log(chip, \"get_src_cc_status rd_mda status0: 0x%0x\", status0);\n\tif (status0 & FUSB_REG_STATUS0_COMP) {\n\t\t*cc = TYPEC_CC_OPEN;\n\t\treturn 0;\n\t}\n\n\t \n\tret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, ra_mda);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(50, 100);\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tfusb302_log(chip, \"get_src_cc_status ra_mda status0: 0x%0x\", status0);\n\tif (status0 & FUSB_REG_STATUS0_COMP)\n\t\t*cc = TYPEC_CC_RD;\n\telse\n\t\t*cc = TYPEC_CC_RA;\n\n\treturn 0;\n}\n\nstatic int fusb302_handle_togdone_src(struct fusb302_chip *chip,\n\t\t\t\t      u8 togdone_result)\n{\n\t \n\tint ret = 0;\n\tu8 rd_mda = rd_mda_value[chip->src_current_status];\n\tenum toggling_mode toggling_mode = chip->toggling_mode;\n\tenum typec_cc_polarity cc_polarity;\n\tenum typec_cc_status cc1, cc2;\n\n\t \n\tif (togdone_result == FUSB_REG_STATUS1A_TOGSS_SRC1)\n\t\tret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC1, &cc1);\n\telse\n\t\tret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC2, &cc2);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = fusb302_set_toggling(chip, TOGGLING_MODE_OFF);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set toggling mode off, ret=%d\", ret);\n\t\treturn ret;\n\t}\n\t \n\tif (togdone_result == FUSB_REG_STATUS1A_TOGSS_SRC1)\n\t\tret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC2, &cc2);\n\telse\n\t\tret = fusb302_get_src_cc_status(chip, TYPEC_POLARITY_CC1, &cc1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tif (cc1 == TYPEC_CC_RD &&\n\t\t\t(cc2 == TYPEC_CC_OPEN || cc2 == TYPEC_CC_RA)) {\n\t\tcc_polarity = TYPEC_POLARITY_CC1;\n\t} else if (cc2 == TYPEC_CC_RD &&\n\t\t    (cc1 == TYPEC_CC_OPEN || cc1 == TYPEC_CC_RA)) {\n\t\tcc_polarity = TYPEC_POLARITY_CC2;\n\t} else {\n\t\tfusb302_log(chip, \"unexpected CC status cc1=%s, cc2=%s, restarting toggling\",\n\t\t\t    typec_cc_status_name[cc1],\n\t\t\t    typec_cc_status_name[cc2]);\n\t\treturn fusb302_set_toggling(chip, toggling_mode);\n\t}\n\t \n\tret = fusb302_set_cc_polarity_and_pull(chip, cc_polarity, true, false);\n\tif (ret < 0) {\n\t\tfusb302_log(chip, \"cannot set cc polarity %s, ret=%d\",\n\t\t\t    cc_polarity_name[cc_polarity], ret);\n\t\treturn ret;\n\t}\n\t \n\tif ((chip->cc1 != cc1) || (chip->cc2 != cc2)) {\n\t\tchip->cc1 = cc1;\n\t\tchip->cc2 = cc2;\n\t\ttcpm_cc_change(chip->tcpm_port);\n\t}\n\t \n\tret = fusb302_i2c_write(chip, FUSB_REG_MEASURE, rd_mda);\n\tif (ret < 0)\n\t\treturn ret;\n\t \n\tret = fusb302_i2c_clear_bits(chip, FUSB_REG_MASK,\n\t\t\t\t     FUSB_REG_MASK_COMP_CHNG);\n\tif (ret < 0) {\n\t\tfusb302_log(chip,\n\t\t\t    \"cannot unmask comp_chng interrupt, ret=%d\", ret);\n\t\treturn ret;\n\t}\n\tchip->intr_comp_chng = true;\n\tfusb302_log(chip, \"detected cc1=%s, cc2=%s\",\n\t\t    typec_cc_status_name[cc1],\n\t\t    typec_cc_status_name[cc2]);\n\n\treturn ret;\n}\n\nstatic int fusb302_handle_togdone(struct fusb302_chip *chip)\n{\n\tint ret = 0;\n\tu8 status1a;\n\tu8 togdone_result;\n\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS1A, &status1a);\n\tif (ret < 0)\n\t\treturn ret;\n\ttogdone_result = (status1a >> FUSB_REG_STATUS1A_TOGSS_POS) &\n\t\t\t FUSB_REG_STATUS1A_TOGSS_MASK;\n\tswitch (togdone_result) {\n\tcase FUSB_REG_STATUS1A_TOGSS_SNK1:\n\tcase FUSB_REG_STATUS1A_TOGSS_SNK2:\n\t\treturn fusb302_handle_togdone_snk(chip, togdone_result);\n\tcase FUSB_REG_STATUS1A_TOGSS_SRC1:\n\tcase FUSB_REG_STATUS1A_TOGSS_SRC2:\n\t\treturn fusb302_handle_togdone_src(chip, togdone_result);\n\tcase FUSB_REG_STATUS1A_TOGSS_AA:\n\t\t \n\t\tfusb302_log(chip, \"AudioAccessory not supported\");\n\t\tfusb302_set_toggling(chip, chip->toggling_mode);\n\t\tbreak;\n\tdefault:\n\t\tfusb302_log(chip, \"TOGDONE with an invalid state: %d\",\n\t\t\t    togdone_result);\n\t\tfusb302_set_toggling(chip, chip->toggling_mode);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int fusb302_pd_reset(struct fusb302_chip *chip)\n{\n\treturn fusb302_i2c_set_bits(chip, FUSB_REG_RESET,\n\t\t\t\t    FUSB_REG_RESET_PD_RESET);\n}\n\nstatic int fusb302_pd_read_message(struct fusb302_chip *chip,\n\t\t\t\t   struct pd_message *msg)\n{\n\tint ret = 0;\n\tu8 token;\n\tu8 crc[4];\n\tint len;\n\n\t \n\tret = fusb302_i2c_read(chip, FUSB_REG_FIFOS, &token);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, 2,\n\t\t\t\t     (u8 *)&msg->header);\n\tif (ret < 0)\n\t\treturn ret;\n\tlen = pd_header_cnt_le(msg->header) * 4;\n\t \n\tif (len > PD_MAX_PAYLOAD * 4) {\n\t\tfusb302_log(chip, \"PD message too long %d\", len);\n\t\treturn -EINVAL;\n\t}\n\tif (len > 0) {\n\t\tret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, len,\n\t\t\t\t\t     (u8 *)msg->payload);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\t \n\tret = fusb302_i2c_block_read(chip, FUSB_REG_FIFOS, 4, crc);\n\tif (ret < 0)\n\t\treturn ret;\n\tfusb302_log(chip, \"PD message header: %x\", msg->header);\n\tfusb302_log(chip, \"PD message len: %d\", len);\n\n\t \n\tif ((!len) && (pd_header_type_le(msg->header) == PD_CTRL_GOOD_CRC))\n\t\ttcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_SUCCESS);\n\telse\n\t\ttcpm_pd_receive(chip->tcpm_port, msg);\n\n\treturn ret;\n}\n\nstatic irqreturn_t fusb302_irq_intn(int irq, void *dev_id)\n{\n\tstruct fusb302_chip *chip = dev_id;\n\tunsigned long flags;\n\n\t \n\tdisable_irq_nosync(chip->gpio_int_n_irq);\n\n\tspin_lock_irqsave(&chip->irq_lock, flags);\n\tif (chip->irq_suspended)\n\t\tchip->irq_while_suspended = true;\n\telse\n\t\tschedule_work(&chip->irq_work);\n\tspin_unlock_irqrestore(&chip->irq_lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void fusb302_irq_work(struct work_struct *work)\n{\n\tstruct fusb302_chip *chip = container_of(work, struct fusb302_chip,\n\t\t\t\t\t\t irq_work);\n\tint ret = 0;\n\tu8 interrupt;\n\tu8 interrupta;\n\tu8 interruptb;\n\tu8 status0;\n\tbool vbus_present;\n\tbool comp_result;\n\tbool intr_togdone;\n\tbool intr_bc_lvl;\n\tbool intr_comp_chng;\n\tstruct pd_message pd_msg;\n\n\tmutex_lock(&chip->lock);\n\t \n\tintr_togdone = chip->intr_togdone;\n\tintr_bc_lvl = chip->intr_bc_lvl;\n\tintr_comp_chng = chip->intr_comp_chng;\n\n\tret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPT, &interrupt);\n\tif (ret < 0)\n\t\tgoto done;\n\tret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPTA, &interrupta);\n\tif (ret < 0)\n\t\tgoto done;\n\tret = fusb302_i2c_read(chip, FUSB_REG_INTERRUPTB, &interruptb);\n\tif (ret < 0)\n\t\tgoto done;\n\tret = fusb302_i2c_read(chip, FUSB_REG_STATUS0, &status0);\n\tif (ret < 0)\n\t\tgoto done;\n\tfusb302_log(chip,\n\t\t    \"IRQ: 0x%02x, a: 0x%02x, b: 0x%02x, status0: 0x%02x\",\n\t\t    interrupt, interrupta, interruptb, status0);\n\n\tif (interrupt & FUSB_REG_INTERRUPT_VBUSOK) {\n\t\tvbus_present = !!(status0 & FUSB_REG_STATUS0_VBUSOK);\n\t\tfusb302_log(chip, \"IRQ: VBUS_OK, vbus=%s\",\n\t\t\t    vbus_present ? \"On\" : \"Off\");\n\t\tif (vbus_present != chip->vbus_present) {\n\t\t\tchip->vbus_present = vbus_present;\n\t\t\ttcpm_vbus_change(chip->tcpm_port);\n\t\t}\n\t}\n\n\tif ((interrupta & FUSB_REG_INTERRUPTA_TOGDONE) && intr_togdone) {\n\t\tfusb302_log(chip, \"IRQ: TOGDONE\");\n\t\tret = fusb302_handle_togdone(chip);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"handle togdone error, ret=%d\", ret);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif ((interrupt & FUSB_REG_INTERRUPT_BC_LVL) && intr_bc_lvl) {\n\t\tfusb302_log(chip, \"IRQ: BC_LVL, handler pending\");\n\t\t \n\t\tmod_delayed_work(chip->wq, &chip->bc_lvl_handler,\n\t\t\t\t msecs_to_jiffies(T_BC_LVL_DEBOUNCE_DELAY_MS));\n\t}\n\n\tif ((interrupt & FUSB_REG_INTERRUPT_COMP_CHNG) && intr_comp_chng) {\n\t\tcomp_result = !!(status0 & FUSB_REG_STATUS0_COMP);\n\t\tfusb302_log(chip, \"IRQ: COMP_CHNG, comp=%s\",\n\t\t\t    comp_result ? \"true\" : \"false\");\n\t\tif (comp_result) {\n\t\t\t \n\t\t\tchip->cc1 = TYPEC_CC_OPEN;\n\t\t\tchip->cc2 = TYPEC_CC_OPEN;\n\t\t\ttcpm_cc_change(chip->tcpm_port);\n\t\t}\n\t}\n\n\tif (interrupt & FUSB_REG_INTERRUPT_COLLISION) {\n\t\tfusb302_log(chip, \"IRQ: PD collision\");\n\t\ttcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_FAILED);\n\t}\n\n\tif (interrupta & FUSB_REG_INTERRUPTA_RETRYFAIL) {\n\t\tfusb302_log(chip, \"IRQ: PD retry failed\");\n\t\ttcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_FAILED);\n\t}\n\n\tif (interrupta & FUSB_REG_INTERRUPTA_HARDSENT) {\n\t\tfusb302_log(chip, \"IRQ: PD hardreset sent\");\n\t\tret = fusb302_pd_reset(chip);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip, \"cannot PD reset, ret=%d\", ret);\n\t\t\tgoto done;\n\t\t}\n\t\ttcpm_pd_transmit_complete(chip->tcpm_port, TCPC_TX_SUCCESS);\n\t}\n\n\tif (interrupta & FUSB_REG_INTERRUPTA_TX_SUCCESS) {\n\t\tfusb302_log(chip, \"IRQ: PD tx success\");\n\t\tret = fusb302_pd_read_message(chip, &pd_msg);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"cannot read in PD message, ret=%d\", ret);\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\tif (interrupta & FUSB_REG_INTERRUPTA_HARDRESET) {\n\t\tfusb302_log(chip, \"IRQ: PD received hardreset\");\n\t\tret = fusb302_pd_reset(chip);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip, \"cannot PD reset, ret=%d\", ret);\n\t\t\tgoto done;\n\t\t}\n\t\ttcpm_pd_hard_reset(chip->tcpm_port);\n\t}\n\n\tif (interruptb & FUSB_REG_INTERRUPTB_GCRCSENT) {\n\t\tfusb302_log(chip, \"IRQ: PD sent good CRC\");\n\t\tret = fusb302_pd_read_message(chip, &pd_msg);\n\t\tif (ret < 0) {\n\t\t\tfusb302_log(chip,\n\t\t\t\t    \"cannot read in PD message, ret=%d\", ret);\n\t\t\tgoto done;\n\t\t}\n\t}\ndone:\n\tmutex_unlock(&chip->lock);\n\tenable_irq(chip->gpio_int_n_irq);\n}\n\nstatic int init_gpio(struct fusb302_chip *chip)\n{\n\tstruct device *dev = chip->dev;\n\tint ret = 0;\n\n\tchip->gpio_int_n = devm_gpiod_get(dev, \"fcs,int_n\", GPIOD_IN);\n\tif (IS_ERR(chip->gpio_int_n)) {\n\t\tdev_err(dev, \"failed to request gpio_int_n\\n\");\n\t\treturn PTR_ERR(chip->gpio_int_n);\n\t}\n\tret = gpiod_to_irq(chip->gpio_int_n);\n\tif (ret < 0) {\n\t\tdev_err(dev,\n\t\t\t\"cannot request IRQ for GPIO Int_N, ret=%d\", ret);\n\t\treturn ret;\n\t}\n\tchip->gpio_int_n_irq = ret;\n\treturn 0;\n}\n\n#define PDO_FIXED_FLAGS \\\n\t(PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP | PDO_FIXED_USB_COMM)\n\nstatic const u32 src_pdo[] = {\n\tPDO_FIXED(5000, 400, PDO_FIXED_FLAGS)\n};\n\nstatic const u32 snk_pdo[] = {\n\tPDO_FIXED(5000, 400, PDO_FIXED_FLAGS)\n};\n\nstatic const struct property_entry port_props[] = {\n\tPROPERTY_ENTRY_STRING(\"data-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"power-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"try-power-role\", \"sink\"),\n\tPROPERTY_ENTRY_U32_ARRAY(\"source-pdos\", src_pdo),\n\tPROPERTY_ENTRY_U32_ARRAY(\"sink-pdos\", snk_pdo),\n\tPROPERTY_ENTRY_U32(\"op-sink-microwatt\", 2500000),\n\t{ }\n};\n\nstatic struct fwnode_handle *fusb302_fwnode_get(struct device *dev)\n{\n\tstruct fwnode_handle *fwnode;\n\n\tfwnode = device_get_named_child_node(dev, \"connector\");\n\tif (!fwnode)\n\t\tfwnode = fwnode_create_software_node(port_props, NULL);\n\n\treturn fwnode;\n}\n\nstatic int fusb302_probe(struct i2c_client *client)\n{\n\tstruct fusb302_chip *chip;\n\tstruct i2c_adapter *adapter = client->adapter;\n\tstruct device *dev = &client->dev;\n\tconst char *name;\n\tint ret = 0;\n\n\tif (!i2c_check_functionality(adapter, I2C_FUNC_SMBUS_I2C_BLOCK)) {\n\t\tdev_err(&client->dev,\n\t\t\t\"I2C/SMBus block functionality not supported!\\n\");\n\t\treturn -ENODEV;\n\t}\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->i2c_client = client;\n\tchip->dev = &client->dev;\n\tmutex_init(&chip->lock);\n\n\t \n\tif (device_property_read_string(dev, \"linux,extcon-name\", &name) == 0) {\n\t\tchip->extcon = extcon_get_extcon_dev(name);\n\t\tif (IS_ERR(chip->extcon))\n\t\t\treturn PTR_ERR(chip->extcon);\n\t}\n\n\tchip->vbus = devm_regulator_get(chip->dev, \"vbus\");\n\tif (IS_ERR(chip->vbus))\n\t\treturn PTR_ERR(chip->vbus);\n\n\tchip->wq = create_singlethread_workqueue(dev_name(chip->dev));\n\tif (!chip->wq)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&chip->irq_lock);\n\tINIT_WORK(&chip->irq_work, fusb302_irq_work);\n\tINIT_DELAYED_WORK(&chip->bc_lvl_handler, fusb302_bc_lvl_handler_work);\n\tinit_tcpc_dev(&chip->tcpc_dev);\n\tfusb302_debugfs_init(chip);\n\n\tif (client->irq) {\n\t\tchip->gpio_int_n_irq = client->irq;\n\t} else {\n\t\tret = init_gpio(chip);\n\t\tif (ret < 0)\n\t\t\tgoto destroy_workqueue;\n\t}\n\n\tchip->tcpc_dev.fwnode = fusb302_fwnode_get(dev);\n\tif (IS_ERR(chip->tcpc_dev.fwnode)) {\n\t\tret = PTR_ERR(chip->tcpc_dev.fwnode);\n\t\tgoto destroy_workqueue;\n\t}\n\n\tchip->tcpm_port = tcpm_register_port(&client->dev, &chip->tcpc_dev);\n\tif (IS_ERR(chip->tcpm_port)) {\n\t\tfwnode_handle_put(chip->tcpc_dev.fwnode);\n\t\tret = dev_err_probe(dev, PTR_ERR(chip->tcpm_port),\n\t\t\t\t    \"cannot register tcpm port\\n\");\n\t\tgoto destroy_workqueue;\n\t}\n\n\tret = request_irq(chip->gpio_int_n_irq, fusb302_irq_intn,\n\t\t\t  IRQF_ONESHOT | IRQF_TRIGGER_LOW,\n\t\t\t  \"fsc_interrupt_int_n\", chip);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"cannot request IRQ for GPIO Int_N, ret=%d\", ret);\n\t\tgoto tcpm_unregister_port;\n\t}\n\tenable_irq_wake(chip->gpio_int_n_irq);\n\ti2c_set_clientdata(client, chip);\n\n\treturn ret;\n\ntcpm_unregister_port:\n\ttcpm_unregister_port(chip->tcpm_port);\n\tfwnode_handle_put(chip->tcpc_dev.fwnode);\ndestroy_workqueue:\n\tfusb302_debugfs_exit(chip);\n\tdestroy_workqueue(chip->wq);\n\n\treturn ret;\n}\n\nstatic void fusb302_remove(struct i2c_client *client)\n{\n\tstruct fusb302_chip *chip = i2c_get_clientdata(client);\n\n\tdisable_irq_wake(chip->gpio_int_n_irq);\n\tfree_irq(chip->gpio_int_n_irq, chip);\n\tcancel_work_sync(&chip->irq_work);\n\tcancel_delayed_work_sync(&chip->bc_lvl_handler);\n\ttcpm_unregister_port(chip->tcpm_port);\n\tfwnode_handle_put(chip->tcpc_dev.fwnode);\n\tdestroy_workqueue(chip->wq);\n\tfusb302_debugfs_exit(chip);\n}\n\nstatic int fusb302_pm_suspend(struct device *dev)\n{\n\tstruct fusb302_chip *chip = dev->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->irq_lock, flags);\n\tchip->irq_suspended = true;\n\tspin_unlock_irqrestore(&chip->irq_lock, flags);\n\n\t \n\tflush_work(&chip->irq_work);\n\treturn 0;\n}\n\nstatic int fusb302_pm_resume(struct device *dev)\n{\n\tstruct fusb302_chip *chip = dev->driver_data;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&chip->irq_lock, flags);\n\tif (chip->irq_while_suspended) {\n\t\tschedule_work(&chip->irq_work);\n\t\tchip->irq_while_suspended = false;\n\t}\n\tchip->irq_suspended = false;\n\tspin_unlock_irqrestore(&chip->irq_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id fusb302_dt_match[] __maybe_unused = {\n\t{.compatible = \"fcs,fusb302\"},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fusb302_dt_match);\n\nstatic const struct i2c_device_id fusb302_i2c_device_id[] = {\n\t{\"typec_fusb302\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, fusb302_i2c_device_id);\n\nstatic const struct dev_pm_ops fusb302_pm_ops = {\n\t.suspend = fusb302_pm_suspend,\n\t.resume = fusb302_pm_resume,\n};\n\nstatic struct i2c_driver fusb302_driver = {\n\t.driver = {\n\t\t   .name = \"typec_fusb302\",\n\t\t   .pm = &fusb302_pm_ops,\n\t\t   .of_match_table = of_match_ptr(fusb302_dt_match),\n\t\t   },\n\t.probe = fusb302_probe,\n\t.remove = fusb302_remove,\n\t.id_table = fusb302_i2c_device_id,\n};\nmodule_i2c_driver(fusb302_driver);\n\nMODULE_AUTHOR(\"Yueyao Zhu <yueyao.zhu@gmail.com>\");\nMODULE_DESCRIPTION(\"Fairchild FUSB302 Type-C Chip Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}