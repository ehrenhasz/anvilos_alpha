{
  "module_name": "maxim_contaminant.c",
  "hash_id": "ecce33d292f38f4fdb1ef62aeb091494ffcdce8a2a9cd2467ea8f8fbc077c1fe",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/maxim_contaminant.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/irqreturn.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec.h>\n\n#include \"tcpci_maxim.h\"\n\nenum fladc_select {\n\tCC1_SCALE1 = 1,\n\tCC1_SCALE2,\n\tCC2_SCALE1,\n\tCC2_SCALE2,\n\tSBU1,\n\tSBU2,\n};\n\n#define FLADC_1uA_LSB_MV\t\t25\n \n#define FLADC_CC_HIGH_RANGE_LSB_MV\t208\n \n#define FLADC_CC_LOW_RANGE_LSB_MV      126\n\n \n#define FLADC_CC_SCALE1\t\t\t1\n \n#define FLADC_CC_SCALE2\t\t\t5\n\n#define FLADC_1uA_CC_OFFSET_MV\t\t300\n#define FLADC_CC_HIGH_RANGE_OFFSET_MV\t624\n#define FLADC_CC_LOW_RANGE_OFFSET_MV\t378\n\n#define CONTAMINANT_THRESHOLD_SBU_K\t1000\n#define\tCONTAMINANT_THRESHOLD_CC_K\t1000\n\n#define READ1_SLEEP_MS\t\t\t10\n#define READ2_SLEEP_MS\t\t\t5\n\n#define STATUS_CHECK(reg, mask, val)\t(((reg) & (mask)) == (val))\n\n#define IS_CC_OPEN(cc_status) \\\n\t(STATUS_CHECK((cc_status), TCPC_CC_STATUS_CC1_MASK << TCPC_CC_STATUS_CC1_SHIFT,  \\\n\t\t      TCPC_CC_STATE_SRC_OPEN) && STATUS_CHECK((cc_status),               \\\n\t\t\t\t\t\t\t      TCPC_CC_STATUS_CC2_MASK << \\\n\t\t\t\t\t\t\t      TCPC_CC_STATUS_CC2_SHIFT,  \\\n\t\t\t\t\t\t\t      TCPC_CC_STATE_SRC_OPEN))\n\nstatic int max_contaminant_adc_to_mv(struct max_tcpci_chip *chip, enum fladc_select channel,\n\t\t\t\t     bool ua_src, u8 fladc)\n{\n\t \n\tif ((ua_src && (channel == CC1_SCALE2 || channel == CC2_SCALE2 || channel == SBU1 ||\n\t\t\tchannel == SBU2)))\n\t\t \n\t\treturn FLADC_1uA_CC_OFFSET_MV + (fladc * FLADC_1uA_LSB_MV);\n\telse if (!ua_src && (channel == CC1_SCALE1 || channel == CC2_SCALE1))\n\t\treturn FLADC_CC_HIGH_RANGE_OFFSET_MV + (fladc * FLADC_CC_HIGH_RANGE_LSB_MV);\n\telse if (!ua_src && (channel == CC1_SCALE2 || channel == CC2_SCALE2))\n\t\treturn FLADC_CC_LOW_RANGE_OFFSET_MV + (fladc * FLADC_CC_LOW_RANGE_LSB_MV);\n\n\tdev_err_once(chip->dev, \"ADC ERROR: SCALE UNKNOWN\");\n\n\treturn -EINVAL;\n}\n\nstatic int max_contaminant_read_adc_mv(struct max_tcpci_chip *chip, enum fladc_select channel,\n\t\t\t\t       int sleep_msec, bool raw, bool ua_src)\n{\n\tstruct regmap *regmap = chip->data.regmap;\n\tu8 fladc;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_ADC_CTRL1, ADCINSEL_MASK,\n\t\t\t\t channel << ADC_CHANNEL_OFFSET);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_ADC_CTRL1, ADCEN, ADCEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(sleep_msec * 1000, (sleep_msec + 1) * 1000);\n\tret = max_tcpci_read8(chip, TCPC_VENDOR_FLADC_STATUS, &fladc);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_ADC_CTRL1, ADCEN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_ADC_CTRL1, ADCINSEL_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (!raw)\n\t\treturn max_contaminant_adc_to_mv(chip, channel, ua_src, fladc);\n\telse\n\t\treturn fladc;\n}\n\nstatic int max_contaminant_read_resistance_kohm(struct max_tcpci_chip *chip,\n\t\t\t\t\t\tenum fladc_select channel, int sleep_msec, bool raw)\n{\n\tstruct regmap *regmap = chip->data.regmap;\n\tint mv;\n\tint ret;\n\n\tif (channel == CC1_SCALE1 || channel == CC2_SCALE1 || channel == CC1_SCALE2 ||\n\t    channel == CC2_SCALE2) {\n\t\t \n\t\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCLPMODESEL_MASK,\n\t\t\t\t\t ULTRA_LOW_POWER_MODE);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCRPCTRL_MASK, UA_1_SRC);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCOVPDIS, CCOVPDIS);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tmv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);\n\t\tif (mv < 0)\n\t\t\treturn ret;\n\n\t\t \n\t\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCOVPDIS, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t \n\t\treturn mv;\n\t}\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBUOVPDIS, SBUOVPDIS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBURPCTRL, SBURPCTRL);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmv = max_contaminant_read_adc_mv(chip, channel, sleep_msec, raw, true);\n\tif (mv < 0)\n\t\treturn ret;\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBURPCTRL, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, SBUOVPDIS, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn mv;\n}\n\nstatic int max_contaminant_read_comparators(struct max_tcpci_chip *chip, u8 *vendor_cc_status2_cc1,\n\t\t\t\t\t    u8 *vendor_cc_status2_cc2)\n{\n\tstruct regmap *regmap = chip->data.regmap;\n\tint ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCRPCTRL_MASK, UA_80_SRC);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL1, CCCOMPEN, CCCOMPEN);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tusleep_range(5000, 6000);\n\tret = regmap_update_bits(regmap, TCPC_TCPC_CTRL, TCPC_TCPC_CTRL_ORIENTATION, PLUG_ORNT_CC1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(5000, 6000);\n\tret = max_tcpci_read8(chip, VENDOR_CC_STATUS2, vendor_cc_status2_cc1);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_TCPC_CTRL, TCPC_TCPC_CTRL_ORIENTATION, PLUG_ORNT_CC2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tusleep_range(5000, 6000);\n\tret = max_tcpci_read8(chip, VENDOR_CC_STATUS2, vendor_cc_status2_cc2);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL1, CCCOMPEN, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCRPCTRL_MASK, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int max_contaminant_detect_contaminant(struct max_tcpci_chip *chip)\n{\n\tint cc1_k, cc2_k, sbu1_k, sbu2_k, ret;\n\tu8 vendor_cc_status2_cc1 = 0xff, vendor_cc_status2_cc2 = 0xff;\n\tu8 role_ctrl = 0, role_ctrl_backup = 0;\n\tint inferred_state = NOT_DETECTED;\n\n\tret = max_tcpci_read8(chip, TCPC_ROLE_CTRL, &role_ctrl);\n\tif (ret < 0)\n\t\treturn NOT_DETECTED;\n\n\trole_ctrl_backup = role_ctrl;\n\trole_ctrl = 0x0F;\n\tret = max_tcpci_write8(chip, TCPC_ROLE_CTRL, role_ctrl);\n\tif (ret < 0)\n\t\treturn NOT_DETECTED;\n\n\tcc1_k = max_contaminant_read_resistance_kohm(chip, CC1_SCALE2, READ1_SLEEP_MS, false);\n\tif (cc1_k < 0)\n\t\tgoto exit;\n\n\tcc2_k = max_contaminant_read_resistance_kohm(chip, CC2_SCALE2, READ2_SLEEP_MS, false);\n\tif (cc2_k < 0)\n\t\tgoto exit;\n\n\tsbu1_k = max_contaminant_read_resistance_kohm(chip, SBU1, READ1_SLEEP_MS, false);\n\tif (sbu1_k < 0)\n\t\tgoto exit;\n\n\tsbu2_k = max_contaminant_read_resistance_kohm(chip, SBU2, READ2_SLEEP_MS, false);\n\tif (sbu2_k < 0)\n\t\tgoto exit;\n\n\tret = max_contaminant_read_comparators(chip, &vendor_cc_status2_cc1,\n\t\t\t\t\t       &vendor_cc_status2_cc2);\n\n\tif (ret < 0)\n\t\tgoto exit;\n\n\tif ((!(CC1_VUFP_RD0P5 & vendor_cc_status2_cc1) ||\n\t     !(CC2_VUFP_RD0P5 & vendor_cc_status2_cc2)) &&\n\t    !(CC1_VUFP_RD0P5 & vendor_cc_status2_cc1 && CC2_VUFP_RD0P5 & vendor_cc_status2_cc2))\n\t\tinferred_state = SINK;\n\telse if ((cc1_k < CONTAMINANT_THRESHOLD_CC_K || cc2_k < CONTAMINANT_THRESHOLD_CC_K) &&\n\t\t (sbu1_k < CONTAMINANT_THRESHOLD_SBU_K || sbu2_k < CONTAMINANT_THRESHOLD_SBU_K))\n\t\tinferred_state = DETECTED;\n\n\tif (inferred_state == NOT_DETECTED)\n\t\tmax_tcpci_write8(chip, TCPC_ROLE_CTRL, role_ctrl_backup);\n\telse\n\t\tmax_tcpci_write8(chip, TCPC_ROLE_CTRL, (TCPC_ROLE_CTRL_DRP | 0xA));\n\n\treturn inferred_state;\nexit:\n\tmax_tcpci_write8(chip, TCPC_ROLE_CTRL, role_ctrl_backup);\n\treturn NOT_DETECTED;\n}\n\nstatic int max_contaminant_enable_dry_detection(struct max_tcpci_chip *chip)\n{\n\tstruct regmap *regmap = chip->data.regmap;\n\tu8 temp;\n\tint ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL3, CCWTRDEB_MASK | CCWTRSEL_MASK\n\t\t\t\t    | WTRCYCLE_MASK, CCWTRDEB_1MS << CCWTRDEB_SHIFT |\n\t\t\t\t    CCWTRSEL_1V << CCWTRSEL_SHIFT | WTRCYCLE_4_8_S <<\n\t\t\t\t    WTRCYCLE_SHIFT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_ROLE_CTRL, TCPC_ROLE_CTRL_DRP, TCPC_ROLE_CTRL_DRP);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL1, CCCONNDRY, CCCONNDRY);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = max_tcpci_read8(chip, TCPC_VENDOR_CC_CTRL1, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = regmap_update_bits(regmap, TCPC_VENDOR_CC_CTRL2, CCLPMODESEL_MASK,\n\t\t\t\t ULTRA_LOW_POWER_MODE);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = max_tcpci_read8(chip, TCPC_VENDOR_CC_CTRL2, &temp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tret = regmap_update_bits(regmap, TCPC_TCPC_CTRL, TCPC_TCPC_CTRL_EN_LK4CONN_ALRT,\n\t\t\t\t TCPC_TCPC_CTRL_EN_LK4CONN_ALRT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = max_tcpci_write8(chip, TCPC_COMMAND, TCPC_CMD_LOOK4CONNECTION);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn 0;\n}\n\nbool max_contaminant_is_contaminant(struct max_tcpci_chip *chip, bool disconnect_while_debounce)\n{\n\tu8 cc_status, pwr_cntl;\n\tint ret;\n\n\tret = max_tcpci_read8(chip, TCPC_CC_STATUS, &cc_status);\n\tif (ret < 0)\n\t\treturn false;\n\n\tret = max_tcpci_read8(chip, TCPC_POWER_CTRL, &pwr_cntl);\n\tif (ret < 0)\n\t\treturn false;\n\n\tif (chip->contaminant_state == NOT_DETECTED || chip->contaminant_state == SINK) {\n\t\tif (!disconnect_while_debounce)\n\t\t\tmsleep(100);\n\n\t\tret = max_tcpci_read8(chip, TCPC_CC_STATUS, &cc_status);\n\t\tif (ret < 0)\n\t\t\treturn false;\n\n\t\tif (IS_CC_OPEN(cc_status)) {\n\t\t\tu8 role_ctrl, role_ctrl_backup;\n\n\t\t\tret = max_tcpci_read8(chip, TCPC_ROLE_CTRL, &role_ctrl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\trole_ctrl_backup = role_ctrl;\n\t\t\trole_ctrl |= 0x0F;\n\t\t\trole_ctrl &= ~(TCPC_ROLE_CTRL_DRP);\n\t\t\tret = max_tcpci_write8(chip, TCPC_ROLE_CTRL, role_ctrl);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tchip->contaminant_state = max_contaminant_detect_contaminant(chip);\n\n\t\t\tret = max_tcpci_write8(chip, TCPC_ROLE_CTRL, role_ctrl_backup);\n\t\t\tif (ret < 0)\n\t\t\t\treturn false;\n\n\t\t\tif (chip->contaminant_state == DETECTED) {\n\t\t\t\tmax_contaminant_enable_dry_detection(chip);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} else if (chip->contaminant_state == DETECTED) {\n\t\tif (STATUS_CHECK(cc_status, TCPC_CC_STATUS_TOGGLING, 0)) {\n\t\t\tchip->contaminant_state = max_contaminant_detect_contaminant(chip);\n\t\t\tif (chip->contaminant_state == DETECTED) {\n\t\t\t\tmax_contaminant_enable_dry_detection(chip);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false;\n}\n\nMODULE_DESCRIPTION(\"MAXIM TCPC CONTAMINANT Module\");\nMODULE_AUTHOR(\"Badhri Jagan Sridharan <badhri@google.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}