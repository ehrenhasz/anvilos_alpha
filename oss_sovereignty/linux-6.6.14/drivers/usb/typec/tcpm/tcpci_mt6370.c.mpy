{
  "module_name": "tcpci_mt6370.c",
  "hash_id": "59f5f7d39e0d9574a45e61d11a0c4cae1ed92ac8919e1153b3a467601d60379f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/tcpci_mt6370.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/pm_wakeup.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/tcpm.h>\n\n#define MT6370_REG_SYSCTRL8\t0x9B\n\n#define MT6370_AUTOIDLE_MASK\tBIT(3)\n\n#define MT6370_VENDOR_ID\t0x29CF\n#define MT6370_TCPC_DID_A\t0x2170\n\nstruct mt6370_priv {\n\tstruct device *dev;\n\tstruct regulator *vbus;\n\tstruct tcpci *tcpci;\n\tstruct tcpci_data tcpci_data;\n};\n\nstatic const struct reg_sequence mt6370_reg_init[] = {\n\tREG_SEQ(0xA0, 0x1, 1000),\n\tREG_SEQ(0x81, 0x38, 0),\n\tREG_SEQ(0x82, 0x82, 0),\n\tREG_SEQ(0xBA, 0xFC, 0),\n\tREG_SEQ(0xBB, 0x50, 0),\n\tREG_SEQ(0x9E, 0x8F, 0),\n\tREG_SEQ(0xA1, 0x5, 0),\n\tREG_SEQ(0xA2, 0x4, 0),\n\tREG_SEQ(0xA3, 0x4A, 0),\n\tREG_SEQ(0xA4, 0x01, 0),\n\tREG_SEQ(0x95, 0x01, 0),\n\tREG_SEQ(0x80, 0x71, 0),\n\tREG_SEQ(0x9B, 0x3A, 1000),\n};\n\nstatic int mt6370_tcpc_init(struct tcpci *tcpci, struct tcpci_data *data)\n{\n\tu16 did;\n\tint ret;\n\n\tret = regmap_register_patch(data->regmap, mt6370_reg_init,\n\t\t\t\t    ARRAY_SIZE(mt6370_reg_init));\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_raw_read(data->regmap, TCPC_BCD_DEV, &did, sizeof(u16));\n\tif (ret)\n\t\treturn ret;\n\n\tif (did == MT6370_TCPC_DID_A)\n\t\treturn regmap_write(data->regmap, TCPC_FAULT_CTRL, 0x80);\n\n\treturn 0;\n}\n\nstatic int mt6370_tcpc_set_vconn(struct tcpci *tcpci, struct tcpci_data *data,\n\t\t\t\t bool enable)\n{\n\treturn regmap_update_bits(data->regmap, MT6370_REG_SYSCTRL8,\n\t\t\t\t  MT6370_AUTOIDLE_MASK,\n\t\t\t\t  enable ? 0 : MT6370_AUTOIDLE_MASK);\n}\n\nstatic int mt6370_tcpc_set_vbus(struct tcpci *tcpci, struct tcpci_data *data,\n\t\t\t\tbool source, bool sink)\n{\n\tstruct mt6370_priv *priv = container_of(data, struct mt6370_priv,\n\t\t\t\t\t\ttcpci_data);\n\tint ret;\n\n\tret = regulator_is_enabled(priv->vbus);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret && !source)\n\t\treturn regulator_disable(priv->vbus);\n\n\tif (!ret && source)\n\t\treturn regulator_enable(priv->vbus);\n\n\treturn 0;\n}\n\nstatic irqreturn_t mt6370_irq_handler(int irq, void *dev_id)\n{\n\tstruct mt6370_priv *priv = dev_id;\n\n\treturn tcpci_irq(priv->tcpci);\n}\n\nstatic int mt6370_check_vendor_info(struct mt6370_priv *priv)\n{\n\tstruct regmap *regmap = priv->tcpci_data.regmap;\n\tu16 vid;\n\tint ret;\n\n\tret = regmap_raw_read(regmap, TCPC_VENDOR_ID, &vid, sizeof(u16));\n\tif (ret)\n\t\treturn ret;\n\n\tif (vid != MT6370_VENDOR_ID)\n\t\treturn dev_err_probe(priv->dev, -ENODEV,\n\t\t\t\t     \"Vendor ID not correct 0x%02x\\n\", vid);\n\n\treturn 0;\n}\n\nstatic void mt6370_unregister_tcpci_port(void *tcpci)\n{\n\ttcpci_unregister_port(tcpci);\n}\n\nstatic int mt6370_tcpc_probe(struct platform_device *pdev)\n{\n\tstruct mt6370_priv *priv;\n\tstruct device *dev = &pdev->dev;\n\tint irq, ret;\n\n\tpriv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->dev = dev;\n\n\tpriv->tcpci_data.regmap = dev_get_regmap(dev->parent, NULL);\n\tif (!priv->tcpci_data.regmap)\n\t\treturn dev_err_probe(dev, -ENODEV, \"Failed to init regmap\\n\");\n\n\tret = mt6370_check_vendor_info(priv);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tpriv->tcpci_data.auto_discharge_disconnect = 1;\n\tpriv->tcpci_data.init = mt6370_tcpc_init;\n\tpriv->tcpci_data.set_vconn = mt6370_tcpc_set_vconn;\n\n\tpriv->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (!IS_ERR(priv->vbus))\n\t\tpriv->tcpci_data.set_vbus = mt6370_tcpc_set_vbus;\n\n\tpriv->tcpci = tcpci_register_port(dev, &priv->tcpci_data);\n\tif (IS_ERR(priv->tcpci))\n\t\treturn dev_err_probe(dev, PTR_ERR(priv->tcpci),\n\t\t\t\t     \"Failed to register tcpci port\\n\");\n\n\tret = devm_add_action_or_reset(dev, mt6370_unregister_tcpci_port, priv->tcpci);\n\tif (ret)\n\t\treturn ret;\n\n\tret = devm_request_threaded_irq(dev, irq, NULL, mt6370_irq_handler,\n\t\t\t\t\tIRQF_ONESHOT, dev_name(dev), priv);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to allocate irq\\n\");\n\n\tdevice_init_wakeup(dev, true);\n\tdev_pm_set_wake_irq(dev, irq);\n\n\treturn 0;\n}\n\nstatic void mt6370_tcpc_remove(struct platform_device *pdev)\n{\n\tdev_pm_clear_wake_irq(&pdev->dev);\n\tdevice_init_wakeup(&pdev->dev, false);\n}\n\nstatic const struct of_device_id mt6370_tcpc_devid_table[] = {\n\t{ .compatible = \"mediatek,mt6370-tcpc\" },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, mt6370_tcpc_devid_table);\n\nstatic struct platform_driver mt6370_tcpc_driver = {\n\t.driver = {\n\t\t.name = \"mt6370-tcpc\",\n\t\t.of_match_table = mt6370_tcpc_devid_table,\n\t},\n\t.probe = mt6370_tcpc_probe,\n\t.remove_new = mt6370_tcpc_remove,\n};\nmodule_platform_driver(mt6370_tcpc_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"MT6370 USB Type-C Port Controller Interface Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}