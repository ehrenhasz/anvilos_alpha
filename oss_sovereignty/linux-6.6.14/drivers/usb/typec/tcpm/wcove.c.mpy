{
  "module_name": "wcove.c",
  "hash_id": "ecbcdf7085c94821814efc21e7c852d95ed184bb4d993105a45ea2273015da66",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/wcove.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/usb/tcpm.h>\n#include <linux/interrupt.h>\n#include <linux/platform_device.h>\n#include <linux/mfd/intel_soc_pmic.h>\n\n \n#define WCOVE_CHGRIRQ0\t\t0x4e09\n\n#define USBC_CONTROL1\t\t0x7001\n#define USBC_CONTROL2\t\t0x7002\n#define USBC_CONTROL3\t\t0x7003\n#define USBC_CC1_CTRL\t\t0x7004\n#define USBC_CC2_CTRL\t\t0x7005\n#define USBC_STATUS1\t\t0x7007\n#define USBC_STATUS2\t\t0x7008\n#define USBC_STATUS3\t\t0x7009\n#define USBC_CC1\t\t0x700a\n#define USBC_CC2\t\t0x700b\n#define USBC_CC1_STATUS\t\t0x700c\n#define USBC_CC2_STATUS\t\t0x700d\n#define USBC_IRQ1\t\t0x7015\n#define USBC_IRQ2\t\t0x7016\n#define USBC_IRQMASK1\t\t0x7017\n#define USBC_IRQMASK2\t\t0x7018\n#define USBC_PDCFG2\t\t0x701a\n#define USBC_PDCFG3\t\t0x701b\n#define USBC_PDSTATUS\t\t0x701c\n#define USBC_RXSTATUS\t\t0x701d\n#define USBC_RXINFO\t\t0x701e\n#define USBC_TXCMD\t\t0x701f\n#define USBC_TXINFO\t\t0x7020\n#define USBC_RX_DATA\t\t0x7028\n#define USBC_TX_DATA\t\t0x7047\n\n \n\n#define USBC_CONTROL1_MODE_MASK\t\t0x3\n#define   USBC_CONTROL1_MODE_SNK\t0\n#define   USBC_CONTROL1_MODE_SNKACC\t1\n#define   USBC_CONTROL1_MODE_SRC\t2\n#define   USBC_CONTROL1_MODE_SRCACC\t3\n#define   USBC_CONTROL1_MODE_DRP\t4\n#define   USBC_CONTROL1_MODE_DRPACC\t5\n#define   USBC_CONTROL1_MODE_TEST\t7\n#define USBC_CONTROL1_CURSRC_MASK\t0xc\n#define   USBC_CONTROL1_CURSRC_UA_0\t(0 << 3)\n#define   USBC_CONTROL1_CURSRC_UA_80\t(1 << 3)\n#define   USBC_CONTROL1_CURSRC_UA_180\t(2 << 3)\n#define   USBC_CONTROL1_CURSRC_UA_330\t(3 << 3)\n#define USBC_CONTROL1_DRPTOGGLE_RANDOM\t0xe0\n\n#define USBC_CONTROL2_UNATT_SNK\t\tBIT(0)\n#define USBC_CONTROL2_UNATT_SRC\t\tBIT(1)\n#define USBC_CONTROL2_DIS_ST\t\tBIT(2)\n\n#define USBC_CONTROL3_DET_DIS\t\tBIT(0)\n#define USBC_CONTROL3_PD_DIS\t\tBIT(1)\n#define USBC_CONTROL3_RESETPHY\t\tBIT(2)\n\n#define USBC_CC_CTRL_PU_EN\t\tBIT(0)\n#define USBC_CC_CTRL_VCONN_EN\t\tBIT(1)\n#define USBC_CC_CTRL_TX_EN\t\tBIT(2)\n#define USBC_CC_CTRL_PD_EN\t\tBIT(3)\n#define USBC_CC_CTRL_CDET_EN\t\tBIT(4)\n#define USBC_CC_CTRL_RDET_EN\t\tBIT(5)\n#define USBC_CC_CTRL_ADC_EN\t\tBIT(6)\n#define USBC_CC_CTRL_VBUSOK\t\tBIT(7)\n\n#define USBC_STATUS1_DET_ONGOING\tBIT(6)\n#define USBC_STATUS1_RSLT(r)\t\t((r) & 0xf)\n#define USBC_RSLT_NOTHING\t\t0\n#define USBC_RSLT_SRC_DEFAULT\t\t1\n#define USBC_RSLT_SRC_1_5A\t\t2\n#define USBC_RSLT_SRC_3_0A\t\t3\n#define USBC_RSLT_SNK\t\t\t4\n#define USBC_RSLT_DEBUG_ACC\t\t5\n#define USBC_RSLT_AUDIO_ACC\t\t6\n#define USBC_RSLT_UNDEF\t\t\t15\n#define USBC_STATUS1_ORIENT(r)\t\t(((r) >> 4) & 0x3)\n#define USBC_ORIENT_NORMAL\t\t1\n#define USBC_ORIENT_REVERSE\t\t2\n\n#define USBC_STATUS2_VBUS_REQ\t\tBIT(5)\n\n#define UCSC_CC_STATUS_SNK_RP\t\tBIT(0)\n#define UCSC_CC_STATUS_PWRDEFSNK\tBIT(1)\n#define UCSC_CC_STATUS_PWR_1P5A_SNK\tBIT(2)\n#define UCSC_CC_STATUS_PWR_3A_SNK\tBIT(3)\n#define UCSC_CC_STATUS_SRC_RP\t\tBIT(4)\n#define UCSC_CC_STATUS_RX(r)\t\t(((r) >> 5) & 0x3)\n#define   USBC_CC_STATUS_RD\t\t1\n#define   USBC_CC_STATUS_RA\t\t2\n\n#define USBC_IRQ1_ADCDONE1\t\tBIT(2)\n#define USBC_IRQ1_OVERTEMP\t\tBIT(1)\n#define USBC_IRQ1_SHORT\t\t\tBIT(0)\n\n#define USBC_IRQ2_CC_CHANGE\t\tBIT(7)\n#define USBC_IRQ2_RX_PD\t\t\tBIT(6)\n#define USBC_IRQ2_RX_HR\t\t\tBIT(5)\n#define USBC_IRQ2_RX_CR\t\t\tBIT(4)\n#define USBC_IRQ2_TX_SUCCESS\t\tBIT(3)\n#define USBC_IRQ2_TX_FAIL\t\tBIT(2)\n\n#define USBC_IRQMASK1_ALL\t(USBC_IRQ1_ADCDONE1 | USBC_IRQ1_OVERTEMP | \\\n\t\t\t\t USBC_IRQ1_SHORT)\n\n#define USBC_IRQMASK2_ALL\t(USBC_IRQ2_CC_CHANGE | USBC_IRQ2_RX_PD | \\\n\t\t\t\t USBC_IRQ2_RX_HR | USBC_IRQ2_RX_CR | \\\n\t\t\t\t USBC_IRQ2_TX_SUCCESS | USBC_IRQ2_TX_FAIL)\n\n#define USBC_PDCFG2_SOP\t\t\tBIT(0)\n#define USBC_PDCFG2_SOP_P\t\tBIT(1)\n#define USBC_PDCFG2_SOP_PP\t\tBIT(2)\n#define USBC_PDCFG2_SOP_P_DEBUG\t\tBIT(3)\n#define USBC_PDCFG2_SOP_PP_DEBUG\tBIT(4)\n\n#define USBC_PDCFG3_DATAROLE_SHIFT\t1\n#define USBC_PDCFG3_SOP_SHIFT\t\t2\n\n#define USBC_RXSTATUS_RXCLEAR\t\tBIT(0)\n#define USBC_RXSTATUS_RXDATA\t\tBIT(7)\n\n#define USBC_RXINFO_RXBYTES(i)\t\t(((i) >> 3) & 0x1f)\n\n#define USBC_TXCMD_BUF_RDY\t\tBIT(0)\n#define USBC_TXCMD_START\t\tBIT(1)\n#define USBC_TXCMD_NOP\t\t\t(0 << 5)\n#define USBC_TXCMD_MSG\t\t\t(1 << 5)\n#define USBC_TXCMD_CR\t\t\t(2 << 5)\n#define USBC_TXCMD_HR\t\t\t(3 << 5)\n#define USBC_TXCMD_BIST\t\t\t(4 << 5)\n\n#define USBC_TXINFO_RETRIES(d)\t\t(d << 3)\n\nstruct wcove_typec {\n\tstruct mutex lock;  \n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tguid_t guid;\n\n\tbool vbus;\n\n\tstruct tcpc_dev tcpc;\n\tstruct tcpm_port *tcpm;\n};\n\n#define tcpc_to_wcove(_tcpc_) container_of(_tcpc_, struct wcove_typec, tcpc)\n\nenum wcove_typec_func {\n\tWCOVE_FUNC_DRIVE_VBUS = 1,\n\tWCOVE_FUNC_ORIENTATION,\n\tWCOVE_FUNC_ROLE,\n\tWCOVE_FUNC_DRIVE_VCONN,\n};\n\nenum wcove_typec_orientation {\n\tWCOVE_ORIENTATION_NORMAL,\n\tWCOVE_ORIENTATION_REVERSE,\n};\n\nenum wcove_typec_role {\n\tWCOVE_ROLE_HOST,\n\tWCOVE_ROLE_DEVICE,\n};\n\n#define WCOVE_DSM_UUID\t\t\"482383f0-2876-4e49-8685-db66211af037\"\n\nstatic int wcove_typec_func(struct wcove_typec *wcove,\n\t\t\t    enum wcove_typec_func func, int param)\n{\n\tunion acpi_object *obj;\n\tunion acpi_object tmp;\n\tunion acpi_object argv4 = ACPI_INIT_DSM_ARGV4(1, &tmp);\n\n\ttmp.type = ACPI_TYPE_INTEGER;\n\ttmp.integer.value = param;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(wcove->dev), &wcove->guid, 1, func,\n\t\t\t\t&argv4);\n\tif (!obj) {\n\t\tdev_err(wcove->dev, \"%s: failed to evaluate _DSM\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tACPI_FREE(obj);\n\treturn 0;\n}\n\nstatic int wcove_init(struct tcpc_dev *tcpc)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tint ret;\n\n\tret = regmap_write(wcove->regmap, USBC_CONTROL1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = regmap_write(wcove->regmap, USBC_IRQMASK1, 0);\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(wcove->regmap, USBC_IRQMASK2, 0);\n}\n\nstatic int wcove_get_vbus(struct tcpc_dev *tcpc)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int cc1ctrl;\n\tint ret;\n\n\tret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1ctrl);\n\tif (ret)\n\t\treturn ret;\n\n\twcove->vbus = !!(cc1ctrl & USBC_CC_CTRL_VBUSOK);\n\n\treturn wcove->vbus;\n}\n\nstatic int wcove_set_vbus(struct tcpc_dev *tcpc, bool on, bool sink)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\n\treturn wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VBUS, on);\n}\n\nstatic int wcove_set_vconn(struct tcpc_dev *tcpc, bool on)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\n\treturn wcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, on);\n}\n\nstatic enum typec_cc_status wcove_to_typec_cc(unsigned int cc)\n{\n\tif (cc & UCSC_CC_STATUS_SNK_RP) {\n\t\tif (cc & UCSC_CC_STATUS_PWRDEFSNK)\n\t\t\treturn TYPEC_CC_RP_DEF;\n\t\telse if (cc & UCSC_CC_STATUS_PWR_1P5A_SNK)\n\t\t\treturn TYPEC_CC_RP_1_5;\n\t\telse if (cc & UCSC_CC_STATUS_PWR_3A_SNK)\n\t\t\treturn TYPEC_CC_RP_3_0;\n\t} else {\n\t\tswitch (UCSC_CC_STATUS_RX(cc)) {\n\t\tcase USBC_CC_STATUS_RD:\n\t\t\treturn TYPEC_CC_RD;\n\t\tcase USBC_CC_STATUS_RA:\n\t\t\treturn TYPEC_CC_RA;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn TYPEC_CC_OPEN;\n}\n\nstatic int wcove_get_cc(struct tcpc_dev *tcpc, enum typec_cc_status *cc1,\n\t\t\tenum typec_cc_status *cc2)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int cc1_status;\n\tunsigned int cc2_status;\n\tint ret;\n\n\tret = regmap_read(wcove->regmap, USBC_CC1_STATUS, &cc1_status);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regmap_read(wcove->regmap, USBC_CC2_STATUS, &cc2_status);\n\tif (ret)\n\t\treturn ret;\n\n\t*cc1 = wcove_to_typec_cc(cc1_status);\n\t*cc2 = wcove_to_typec_cc(cc2_status);\n\n\treturn 0;\n}\n\nstatic int wcove_set_cc(struct tcpc_dev *tcpc, enum typec_cc_status cc)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int ctrl;\n\n\tswitch (cc) {\n\tcase TYPEC_CC_RD:\n\t\tctrl = USBC_CONTROL1_MODE_SNK;\n\t\tbreak;\n\tcase TYPEC_CC_RP_DEF:\n\t\tctrl = USBC_CONTROL1_CURSRC_UA_80 | USBC_CONTROL1_MODE_SRC;\n\t\tbreak;\n\tcase TYPEC_CC_RP_1_5:\n\t\tctrl = USBC_CONTROL1_CURSRC_UA_180 | USBC_CONTROL1_MODE_SRC;\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\tctrl = USBC_CONTROL1_CURSRC_UA_330 | USBC_CONTROL1_MODE_SRC;\n\t\tbreak;\n\tcase TYPEC_CC_OPEN:\n\t\tctrl = 0;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn regmap_write(wcove->regmap, USBC_CONTROL1, ctrl);\n}\n\nstatic int wcove_set_polarity(struct tcpc_dev *tcpc, enum typec_cc_polarity pol)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\n\treturn wcove_typec_func(wcove, WCOVE_FUNC_ORIENTATION, pol);\n}\n\nstatic int wcove_set_current_limit(struct tcpc_dev *tcpc, u32 max_ma, u32 mv)\n{\n\treturn 0;\n}\n\nstatic int wcove_set_roles(struct tcpc_dev *tcpc, bool attached,\n\t\t\t   enum typec_role role, enum typec_data_role data)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int val;\n\tint ret;\n\n\tret = wcove_typec_func(wcove, WCOVE_FUNC_ROLE, data == TYPEC_HOST ?\n\t\t\t       WCOVE_ROLE_HOST : WCOVE_ROLE_DEVICE);\n\tif (ret)\n\t\treturn ret;\n\n\tval = role;\n\tval |= data << USBC_PDCFG3_DATAROLE_SHIFT;\n\tval |= PD_REV20 << USBC_PDCFG3_SOP_SHIFT;\n\n\treturn regmap_write(wcove->regmap, USBC_PDCFG3, val);\n}\n\nstatic int wcove_set_pd_rx(struct tcpc_dev *tcpc, bool on)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\n\treturn regmap_write(wcove->regmap, USBC_PDCFG2,\n\t\t\t    on ? USBC_PDCFG2_SOP : 0);\n}\n\nstatic int wcove_pd_transmit(struct tcpc_dev *tcpc,\n\t\t\t     enum tcpm_transmit_type type,\n\t\t\t     const struct pd_message *msg,\n\t\t\t     unsigned int negotiated_rev)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int info = 0;\n\tunsigned int cmd;\n\tint ret;\n\n\tret = regmap_read(wcove->regmap, USBC_TXCMD, &cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!(cmd & USBC_TXCMD_BUF_RDY)) {\n\t\tdev_warn(wcove->dev, \"%s: Last transmission still ongoing!\",\n\t\t\t __func__);\n\t\treturn -EBUSY;\n\t}\n\n\tif (msg) {\n\t\tconst u8 *data = (void *)msg;\n\t\tint i;\n\n\t\tfor (i = 0; i < pd_header_cnt_le(msg->header) * 4 + 2; i++) {\n\t\t\tret = regmap_write(wcove->regmap, USBC_TX_DATA + i,\n\t\t\t\t\t   data[i]);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TCPC_TX_SOP:\n\tcase TCPC_TX_SOP_PRIME:\n\tcase TCPC_TX_SOP_PRIME_PRIME:\n\tcase TCPC_TX_SOP_DEBUG_PRIME:\n\tcase TCPC_TX_SOP_DEBUG_PRIME_PRIME:\n\t\tinfo = type + 1;\n\t\tcmd = USBC_TXCMD_MSG;\n\t\tbreak;\n\tcase TCPC_TX_HARD_RESET:\n\t\tcmd = USBC_TXCMD_HR;\n\t\tbreak;\n\tcase TCPC_TX_CABLE_RESET:\n\t\tcmd = USBC_TXCMD_CR;\n\t\tbreak;\n\tcase TCPC_TX_BIST_MODE_2:\n\t\tcmd = USBC_TXCMD_BIST;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tret = regmap_write(wcove->regmap, USBC_TXINFO,\n\t\t\t   info | USBC_TXINFO_RETRIES(7));\n\tif (ret)\n\t\treturn ret;\n\n\treturn regmap_write(wcove->regmap, USBC_TXCMD, cmd | USBC_TXCMD_START);\n}\n\nstatic int wcove_start_toggling(struct tcpc_dev *tcpc,\n\t\t\t\tenum typec_port_type port_type,\n\t\t\t\tenum typec_cc_status cc)\n{\n\tstruct wcove_typec *wcove = tcpc_to_wcove(tcpc);\n\tunsigned int usbc_ctrl;\n\n\tif (port_type != TYPEC_PORT_DRP)\n\t\treturn -EOPNOTSUPP;\n\n\tusbc_ctrl = USBC_CONTROL1_MODE_DRP | USBC_CONTROL1_DRPTOGGLE_RANDOM;\n\n\tswitch (cc) {\n\tcase TYPEC_CC_RP_1_5:\n\t\tusbc_ctrl |= USBC_CONTROL1_CURSRC_UA_180;\n\t\tbreak;\n\tcase TYPEC_CC_RP_3_0:\n\t\tusbc_ctrl |= USBC_CONTROL1_CURSRC_UA_330;\n\t\tbreak;\n\tdefault:\n\t\tusbc_ctrl |= USBC_CONTROL1_CURSRC_UA_80;\n\t\tbreak;\n\t}\n\n\treturn regmap_write(wcove->regmap, USBC_CONTROL1, usbc_ctrl);\n}\n\nstatic int wcove_read_rx_buffer(struct wcove_typec *wcove, void *msg)\n{\n\tunsigned int info;\n\tint ret;\n\tint i;\n\n\tret = regmap_read(wcove->regmap, USBC_RXINFO, &info);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\n\tfor (i = 0; i < USBC_RXINFO_RXBYTES(info); i++) {\n\t\tret = regmap_read(wcove->regmap, USBC_RX_DATA + i, msg + i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn regmap_write(wcove->regmap, USBC_RXSTATUS,\n\t\t\t    USBC_RXSTATUS_RXCLEAR);\n}\n\nstatic irqreturn_t wcove_typec_irq(int irq, void *data)\n{\n\tstruct wcove_typec *wcove = data;\n\tunsigned int usbc_irq1 = 0;\n\tunsigned int usbc_irq2 = 0;\n\tunsigned int cc1ctrl;\n\tint ret;\n\n\tmutex_lock(&wcove->lock);\n\n\t \n\tret = regmap_read(wcove->regmap, USBC_IRQ1, &usbc_irq1);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_read(wcove->regmap, USBC_IRQ2, &usbc_irq2);\n\tif (ret)\n\t\tgoto err;\n\n\tret = regmap_read(wcove->regmap, USBC_CC1_CTRL, &cc1ctrl);\n\tif (ret)\n\t\tgoto err;\n\n\tif (!wcove->tcpm)\n\t\tgoto err;\n\n\t \n\tif (usbc_irq1 & USBC_IRQ1_OVERTEMP) {\n\t\tdev_err(wcove->dev, \"VCONN Switch Over Temperature!\\n\");\n\t\twcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, false);\n\t\t \n\t}\n\n\tif (usbc_irq1 & USBC_IRQ1_SHORT) {\n\t\tdev_err(wcove->dev, \"VCONN Switch Short Circuit!\\n\");\n\t\twcove_typec_func(wcove, WCOVE_FUNC_DRIVE_VCONN, false);\n\t\t \n\t}\n\n\tif (wcove->vbus != !!(cc1ctrl & USBC_CC_CTRL_VBUSOK))\n\t\ttcpm_vbus_change(wcove->tcpm);\n\n\t \n\tif (usbc_irq2 & USBC_IRQ2_CC_CHANGE)\n\t\ttcpm_cc_change(wcove->tcpm);\n\n\tif (usbc_irq2 & USBC_IRQ2_RX_PD) {\n\t\tunsigned int status;\n\n\t\t \n\n\t\tret = regmap_read(wcove->regmap, USBC_RXSTATUS, &status);\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\t \n\t\twhile (status & USBC_RXSTATUS_RXDATA) {\n\t\t\tstruct pd_message msg;\n\n\t\t\tret = wcove_read_rx_buffer(wcove, &msg);\n\t\t\tif (ret) {\n\t\t\t\tdev_err(wcove->dev, \"%s: RX read failed\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\ttcpm_pd_receive(wcove->tcpm, &msg);\n\n\t\t\tret = regmap_read(wcove->regmap, USBC_RXSTATUS,\n\t\t\t\t\t  &status);\n\t\t\tif (ret)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (usbc_irq2 & USBC_IRQ2_RX_HR)\n\t\ttcpm_pd_hard_reset(wcove->tcpm);\n\n\t \n\n\tif (usbc_irq2 & USBC_IRQ2_TX_SUCCESS)\n\t\ttcpm_pd_transmit_complete(wcove->tcpm, TCPC_TX_SUCCESS);\n\n\tif (usbc_irq2 & USBC_IRQ2_TX_FAIL)\n\t\ttcpm_pd_transmit_complete(wcove->tcpm, TCPC_TX_FAILED);\n\nerr:\n\t \n\tif (usbc_irq1) {\n\t\tret = regmap_write(wcove->regmap, USBC_IRQ1, usbc_irq1);\n\t\tif (ret)\n\t\t\tdev_WARN(wcove->dev, \"%s failed to clear IRQ1\\n\",\n\t\t\t\t __func__);\n\t}\n\n\tif (usbc_irq2) {\n\t\tret = regmap_write(wcove->regmap, USBC_IRQ2, usbc_irq2);\n\t\tif (ret)\n\t\t\tdev_WARN(wcove->dev, \"%s failed to clear IRQ2\\n\",\n\t\t\t\t __func__);\n\t}\n\n\t \n\tregmap_write(wcove->regmap, WCOVE_CHGRIRQ0, BIT(5));\n\n\tmutex_unlock(&wcove->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic const u32 src_pdo[] = {\n\tPDO_FIXED(5000, 1500, PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP |\n\t\t  PDO_FIXED_USB_COMM),\n};\n\nstatic const u32 snk_pdo[] = {\n\tPDO_FIXED(5000, 500, PDO_FIXED_DUAL_ROLE | PDO_FIXED_DATA_SWAP |\n\t\t  PDO_FIXED_USB_COMM),\n\tPDO_VAR(5000, 12000, 3000),\n};\n\nstatic const struct property_entry wcove_props[] = {\n\tPROPERTY_ENTRY_STRING(\"data-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"power-role\", \"dual\"),\n\tPROPERTY_ENTRY_STRING(\"try-power-role\", \"sink\"),\n\tPROPERTY_ENTRY_U32_ARRAY(\"source-pdos\", src_pdo),\n\tPROPERTY_ENTRY_U32_ARRAY(\"sink-pdos\", snk_pdo),\n\tPROPERTY_ENTRY_U32(\"op-sink-microwatt\", 15000000),\n\t{ }\n};\n\nstatic int wcove_typec_probe(struct platform_device *pdev)\n{\n\tstruct intel_soc_pmic *pmic = dev_get_drvdata(pdev->dev.parent);\n\tstruct wcove_typec *wcove;\n\tint irq;\n\tint ret;\n\n\twcove = devm_kzalloc(&pdev->dev, sizeof(*wcove), GFP_KERNEL);\n\tif (!wcove)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&wcove->lock);\n\twcove->dev = &pdev->dev;\n\twcove->regmap = pmic->regmap;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tirq = regmap_irq_get_virq(pmic->irq_chip_data_chgr, irq);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tret = guid_parse(WCOVE_DSM_UUID, &wcove->guid);\n\tif (ret)\n\t\treturn ret;\n\n\tif (!acpi_check_dsm(ACPI_HANDLE(&pdev->dev), &wcove->guid, 0, 0x1f)) {\n\t\tdev_err(&pdev->dev, \"Missing _DSM functions\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\twcove->tcpc.init = wcove_init;\n\twcove->tcpc.get_vbus = wcove_get_vbus;\n\twcove->tcpc.set_vbus = wcove_set_vbus;\n\twcove->tcpc.set_cc = wcove_set_cc;\n\twcove->tcpc.get_cc = wcove_get_cc;\n\twcove->tcpc.set_polarity = wcove_set_polarity;\n\twcove->tcpc.set_vconn = wcove_set_vconn;\n\twcove->tcpc.set_current_limit = wcove_set_current_limit;\n\twcove->tcpc.start_toggling = wcove_start_toggling;\n\n\twcove->tcpc.set_pd_rx = wcove_set_pd_rx;\n\twcove->tcpc.set_roles = wcove_set_roles;\n\twcove->tcpc.pd_transmit = wcove_pd_transmit;\n\n\twcove->tcpc.fwnode = fwnode_create_software_node(wcove_props, NULL);\n\tif (IS_ERR(wcove->tcpc.fwnode))\n\t\treturn PTR_ERR(wcove->tcpc.fwnode);\n\n\twcove->tcpm = tcpm_register_port(wcove->dev, &wcove->tcpc);\n\tif (IS_ERR(wcove->tcpm)) {\n\t\tfwnode_remove_software_node(wcove->tcpc.fwnode);\n\t\treturn PTR_ERR(wcove->tcpm);\n\t}\n\n\tret = devm_request_threaded_irq(&pdev->dev, irq, NULL,\n\t\t\t\t\twcove_typec_irq, IRQF_ONESHOT,\n\t\t\t\t\t\"wcove_typec\", wcove);\n\tif (ret) {\n\t\ttcpm_unregister_port(wcove->tcpm);\n\t\tfwnode_remove_software_node(wcove->tcpc.fwnode);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, wcove);\n\treturn 0;\n}\n\nstatic void wcove_typec_remove(struct platform_device *pdev)\n{\n\tstruct wcove_typec *wcove = platform_get_drvdata(pdev);\n\tunsigned int val;\n\n\t \n\tregmap_read(wcove->regmap, USBC_IRQMASK1, &val);\n\tregmap_write(wcove->regmap, USBC_IRQMASK1, val | USBC_IRQMASK1_ALL);\n\tregmap_read(wcove->regmap, USBC_IRQMASK2, &val);\n\tregmap_write(wcove->regmap, USBC_IRQMASK2, val | USBC_IRQMASK2_ALL);\n\n\ttcpm_unregister_port(wcove->tcpm);\n\tfwnode_remove_software_node(wcove->tcpc.fwnode);\n}\n\nstatic struct platform_driver wcove_typec_driver = {\n\t.driver = {\n\t\t.name\t\t= \"bxt_wcove_usbc\",\n\t},\n\t.probe\t\t\t= wcove_typec_probe,\n\t.remove_new\t\t= wcove_typec_remove,\n};\n\nmodule_platform_driver(wcove_typec_driver);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"WhiskeyCove PMIC USB Type-C PHY driver\");\nMODULE_ALIAS(\"platform:bxt_wcove_usbc\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}