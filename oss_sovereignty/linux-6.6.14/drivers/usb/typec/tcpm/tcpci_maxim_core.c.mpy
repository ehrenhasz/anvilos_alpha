{
  "module_name": "tcpci_maxim_core.c",
  "hash_id": "941c253c2e5cfa62bde29ec2a0583304a9924ed1090fcdc9af3a64ce4436fca5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/tcpm/tcpci_maxim_core.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/tcpm.h>\n#include <linux/usb/typec.h>\n\n#include \"tcpci_maxim.h\"\n\n#define PD_ACTIVITY_TIMEOUT_MS\t\t\t\t10000\n\n#define TCPC_VENDOR_ALERT\t\t\t\t0x80\n#define TCPC_VENDOR_USBSW_CTRL\t\t\t\t0x93\n#define TCPC_VENDOR_USBSW_CTRL_ENABLE_USB_DATA\t\t0x9\n#define TCPC_VENDOR_USBSW_CTRL_DISABLE_USB_DATA\t\t0\n\n#define TCPC_RECEIVE_BUFFER_COUNT_OFFSET\t\t0\n#define TCPC_RECEIVE_BUFFER_FRAME_TYPE_OFFSET\t\t1\n#define TCPC_RECEIVE_BUFFER_RX_BYTE_BUF_OFFSET\t\t2\n\n \n#define TCPC_RECEIVE_BUFFER_LEN\t\t\t\t32\n\n#define MAX_BUCK_BOOST_SID\t\t\t\t0x69\n#define MAX_BUCK_BOOST_OP\t\t\t\t0xb9\n#define MAX_BUCK_BOOST_OFF\t\t\t\t0\n#define MAX_BUCK_BOOST_SOURCE\t\t\t\t0xa\n#define MAX_BUCK_BOOST_SINK\t\t\t\t0x5\n\nstatic const struct regmap_range max_tcpci_tcpci_range[] = {\n\tregmap_reg_range(0x00, 0x95)\n};\n\nstatic const struct regmap_access_table max_tcpci_tcpci_write_table = {\n\t.yes_ranges = max_tcpci_tcpci_range,\n\t.n_yes_ranges = ARRAY_SIZE(max_tcpci_tcpci_range),\n};\n\nstatic const struct regmap_config max_tcpci_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0x95,\n\t.wr_table = &max_tcpci_tcpci_write_table,\n};\n\nstatic struct max_tcpci_chip *tdata_to_max_tcpci(struct tcpci_data *tdata)\n{\n\treturn container_of(tdata, struct max_tcpci_chip, data);\n}\n\nstatic void max_tcpci_init_regs(struct max_tcpci_chip *chip)\n{\n\tu16 alert_mask = 0;\n\tint ret;\n\n\tret = max_tcpci_write16(chip, TCPC_ALERT, 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Error writing to TCPC_ALERT ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = max_tcpci_write16(chip, TCPC_VENDOR_ALERT, 0xffff);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Error writing to TCPC_VENDOR_ALERT ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = max_tcpci_write8(chip, TCPC_ALERT_EXTENDED, 0xff);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Unable to clear TCPC_ALERT_EXTENDED ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tret = max_tcpci_write8(chip, TCPC_EXTENDED_STATUS_MASK, TCPC_EXTENDED_STATUS_VSAFE0V);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Unable to unmask TCPC_EXTENDED_STATUS_VSAFE0V ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\talert_mask = TCPC_ALERT_TX_SUCCESS | TCPC_ALERT_TX_DISCARDED | TCPC_ALERT_TX_FAILED |\n\t\tTCPC_ALERT_RX_HARD_RST | TCPC_ALERT_RX_STATUS | TCPC_ALERT_CC_STATUS |\n\t\tTCPC_ALERT_VBUS_DISCNCT | TCPC_ALERT_RX_BUF_OVF | TCPC_ALERT_POWER_STATUS |\n\t\t \n\t\tTCPC_ALERT_EXTND | TCPC_ALERT_EXTENDED_STATUS;\n\n\tret = max_tcpci_write16(chip, TCPC_ALERT_MASK, alert_mask);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev,\n\t\t\t\"Error enabling TCPC_ALERT: TCPC_ALERT_MASK write failed ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\t \n\tret = max_tcpci_write8(chip, TCPC_POWER_CTRL, 0);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Error writing to TCPC_POWER_CTRL ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tret = max_tcpci_write8(chip, TCPC_ALERT_EXTENDED_MASK, TCPC_SINK_FAST_ROLE_SWAP);\n\tif (ret < 0)\n\t\treturn;\n}\n\nstatic void process_rx(struct max_tcpci_chip *chip, u16 status)\n{\n\tstruct pd_message msg;\n\tu8 count, frame_type, rx_buf[TCPC_RECEIVE_BUFFER_LEN];\n\tint ret, payload_index;\n\tu8 *rx_buf_ptr;\n\n\t \n\tret = regmap_raw_read(chip->data.regmap, TCPC_RX_BYTE_CNT, rx_buf, 2);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"TCPC_RX_BYTE_CNT read failed ret:%d\\n\", ret);\n\t\treturn;\n\t}\n\n\tcount = rx_buf[TCPC_RECEIVE_BUFFER_COUNT_OFFSET];\n\tframe_type = rx_buf[TCPC_RECEIVE_BUFFER_FRAME_TYPE_OFFSET];\n\n\tif (count == 0 || frame_type != TCPC_RX_BUF_FRAME_TYPE_SOP) {\n\t\tmax_tcpci_write16(chip, TCPC_ALERT, TCPC_ALERT_RX_STATUS);\n\t\tdev_err(chip->dev, \"%s\\n\", count ==  0 ? \"error: count is 0\" :\n\t\t\t\"error frame_type is not SOP\");\n\t\treturn;\n\t}\n\n\tif (count > sizeof(struct pd_message) || count + 1 > TCPC_RECEIVE_BUFFER_LEN) {\n\t\tdev_err(chip->dev, \"Invalid TCPC_RX_BYTE_CNT %d\\n\", count);\n\t\treturn;\n\t}\n\n\t \n\tcount += 1;\n\tret = regmap_raw_read(chip->data.regmap, TCPC_RX_BYTE_CNT, rx_buf, count);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"Error: TCPC_RX_BYTE_CNT read failed: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\trx_buf_ptr = rx_buf + TCPC_RECEIVE_BUFFER_RX_BYTE_BUF_OFFSET;\n\tmsg.header = cpu_to_le16(*(u16 *)rx_buf_ptr);\n\trx_buf_ptr = rx_buf_ptr + sizeof(msg.header);\n\tfor (payload_index = 0; payload_index < pd_header_cnt_le(msg.header); payload_index++,\n\t     rx_buf_ptr += sizeof(msg.payload[0]))\n\t\tmsg.payload[payload_index] = cpu_to_le32(*(u32 *)rx_buf_ptr);\n\n\t \n\tret = max_tcpci_write16(chip, TCPC_ALERT, status & TCPC_ALERT_RX_BUF_OVF ?\n\t\t\t\tTCPC_ALERT_RX_STATUS | TCPC_ALERT_RX_BUF_OVF :\n\t\t\t\tTCPC_ALERT_RX_STATUS);\n\tif (ret < 0)\n\t\treturn;\n\n\ttcpm_pd_receive(chip->port, &msg);\n}\n\nstatic int max_tcpci_set_vbus(struct tcpci *tcpci, struct tcpci_data *tdata, bool source, bool sink)\n{\n\tstruct max_tcpci_chip *chip = tdata_to_max_tcpci(tdata);\n\tu8 buffer_source[2] = {MAX_BUCK_BOOST_OP, MAX_BUCK_BOOST_SOURCE};\n\tu8 buffer_sink[2] = {MAX_BUCK_BOOST_OP, MAX_BUCK_BOOST_SINK};\n\tu8 buffer_none[2] = {MAX_BUCK_BOOST_OP, MAX_BUCK_BOOST_OFF};\n\tstruct i2c_client *i2c = chip->client;\n\tint ret;\n\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr = MAX_BUCK_BOOST_SID,\n\t\t\t.flags = i2c->flags & I2C_M_TEN,\n\t\t\t.len = 2,\n\t\t\t.buf = source ? buffer_source : sink ? buffer_sink : buffer_none,\n\t\t},\n\t};\n\n\tif (source && sink) {\n\t\tdev_err(chip->dev, \"Both source and sink set\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tret = i2c_transfer(i2c->adapter, msgs, 1);\n\n\treturn  ret < 0 ? ret : 1;\n}\n\nstatic void process_power_status(struct max_tcpci_chip *chip)\n{\n\tu8 pwr_status;\n\tint ret;\n\n\tret = max_tcpci_read8(chip, TCPC_POWER_STATUS, &pwr_status);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (pwr_status == 0xff)\n\t\tmax_tcpci_init_regs(chip);\n\telse if (pwr_status & TCPC_POWER_STATUS_SOURCING_VBUS)\n\t\ttcpm_sourcing_vbus(chip->port);\n\telse\n\t\ttcpm_vbus_change(chip->port);\n}\n\nstatic void max_tcpci_frs_sourcing_vbus(struct tcpci *tcpci, struct tcpci_data *tdata)\n{\n\t \n\tmax_tcpci_set_vbus(tcpci, tdata, true, false);\n}\n\nstatic void process_tx(struct max_tcpci_chip *chip, u16 status)\n{\n\tif (status & TCPC_ALERT_TX_SUCCESS)\n\t\ttcpm_pd_transmit_complete(chip->port, TCPC_TX_SUCCESS);\n\telse if (status & TCPC_ALERT_TX_DISCARDED)\n\t\ttcpm_pd_transmit_complete(chip->port, TCPC_TX_DISCARDED);\n\telse if (status & TCPC_ALERT_TX_FAILED)\n\t\ttcpm_pd_transmit_complete(chip->port, TCPC_TX_FAILED);\n\n\t \n\tif ((status & TCPC_ALERT_TX_SUCCESS) && (status & TCPC_ALERT_TX_FAILED))\n\t\tmax_tcpci_init_regs(chip);\n}\n\n \nstatic void max_tcpci_set_partner_usb_comm_capable(struct tcpci *tcpci, struct tcpci_data *data,\n\t\t\t\t\t\t   bool capable)\n{\n\tstruct max_tcpci_chip *chip = tdata_to_max_tcpci(data);\n\tint ret;\n\n\tret = max_tcpci_write8(chip, TCPC_VENDOR_USBSW_CTRL, capable ?\n\t\t\t       TCPC_VENDOR_USBSW_CTRL_ENABLE_USB_DATA :\n\t\t\t       TCPC_VENDOR_USBSW_CTRL_DISABLE_USB_DATA);\n\n\tif (ret < 0)\n\t\tdev_err(chip->dev, \"Failed to enable USB switches\");\n}\n\nstatic irqreturn_t _max_tcpci_irq(struct max_tcpci_chip *chip, u16 status)\n{\n\tu16 mask;\n\tint ret;\n\tu8 reg_status;\n\n\t \n\tif (status & ~TCPC_ALERT_RX_STATUS) {\n\t\tmask = status & TCPC_ALERT_RX_BUF_OVF ?\n\t\t\tstatus & ~(TCPC_ALERT_RX_STATUS | TCPC_ALERT_RX_BUF_OVF) :\n\t\t\tstatus & ~TCPC_ALERT_RX_STATUS;\n\t\tret = max_tcpci_write16(chip, TCPC_ALERT, mask);\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"ALERT clear failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (status & TCPC_ALERT_RX_BUF_OVF && !(status & TCPC_ALERT_RX_STATUS)) {\n\t\tret = max_tcpci_write16(chip, TCPC_ALERT, (TCPC_ALERT_RX_STATUS |\n\t\t\t\t\t\t\t  TCPC_ALERT_RX_BUF_OVF));\n\t\tif (ret < 0) {\n\t\t\tdev_err(chip->dev, \"ALERT clear failed\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tif (status & TCPC_ALERT_EXTND) {\n\t\tret = max_tcpci_read8(chip, TCPC_ALERT_EXTENDED, &reg_status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tret = max_tcpci_write8(chip, TCPC_ALERT_EXTENDED, reg_status);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (reg_status & TCPC_SINK_FAST_ROLE_SWAP) {\n\t\t\tdev_info(chip->dev, \"FRS Signal\\n\");\n\t\t\ttcpm_sink_frs(chip->port);\n\t\t}\n\t}\n\n\tif (status & TCPC_ALERT_EXTENDED_STATUS) {\n\t\tret = max_tcpci_read8(chip, TCPC_EXTENDED_STATUS, (u8 *)&reg_status);\n\t\tif (ret >= 0 && (reg_status & TCPC_EXTENDED_STATUS_VSAFE0V))\n\t\t\ttcpm_vbus_change(chip->port);\n\t}\n\n\tif (status & TCPC_ALERT_RX_STATUS)\n\t\tprocess_rx(chip, status);\n\n\tif (status & TCPC_ALERT_VBUS_DISCNCT)\n\t\ttcpm_vbus_change(chip->port);\n\n\tif (status & TCPC_ALERT_CC_STATUS) {\n\t\tif (chip->contaminant_state == DETECTED || tcpm_port_is_toggling(chip->port)) {\n\t\t\tif (!max_contaminant_is_contaminant(chip, false))\n\t\t\t\ttcpm_port_clean(chip->port);\n\t\t} else {\n\t\t\ttcpm_cc_change(chip->port);\n\t\t}\n\t}\n\n\tif (status & TCPC_ALERT_POWER_STATUS)\n\t\tprocess_power_status(chip);\n\n\tif (status & TCPC_ALERT_RX_HARD_RST) {\n\t\ttcpm_pd_hard_reset(chip->port);\n\t\tmax_tcpci_init_regs(chip);\n\t}\n\n\tif (status & TCPC_ALERT_TX_SUCCESS || status & TCPC_ALERT_TX_DISCARDED || status &\n\t    TCPC_ALERT_TX_FAILED)\n\t\tprocess_tx(chip, status);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t max_tcpci_irq(int irq, void *dev_id)\n{\n\tstruct max_tcpci_chip *chip = dev_id;\n\tu16 status;\n\tirqreturn_t irq_return = IRQ_HANDLED;\n\tint ret;\n\n\tif (!chip->port)\n\t\treturn IRQ_HANDLED;\n\n\tret = max_tcpci_read16(chip, TCPC_ALERT, &status);\n\tif (ret < 0) {\n\t\tdev_err(chip->dev, \"ALERT read failed\\n\");\n\t\treturn ret;\n\t}\n\twhile (status) {\n\t\tirq_return = _max_tcpci_irq(chip, status);\n\t\t \n\t\tret = max_tcpci_read16(chip, TCPC_ALERT, &status);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn irq_return;\n}\n\nstatic irqreturn_t max_tcpci_isr(int irq, void *dev_id)\n{\n\tstruct max_tcpci_chip *chip = dev_id;\n\n\tpm_wakeup_event(chip->dev, PD_ACTIVITY_TIMEOUT_MS);\n\n\tif (!chip->port)\n\t\treturn IRQ_HANDLED;\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic int max_tcpci_init_alert(struct max_tcpci_chip *chip, struct i2c_client *client)\n{\n\tint ret;\n\n\tret = devm_request_threaded_irq(chip->dev, client->irq, max_tcpci_isr, max_tcpci_irq,\n\t\t\t\t\t(IRQF_TRIGGER_LOW | IRQF_ONESHOT), dev_name(chip->dev),\n\t\t\t\t\tchip);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tenable_irq_wake(client->irq);\n\treturn 0;\n}\n\nstatic int max_tcpci_start_toggling(struct tcpci *tcpci, struct tcpci_data *tdata,\n\t\t\t\t    enum typec_cc_status cc)\n{\n\tstruct max_tcpci_chip *chip = tdata_to_max_tcpci(tdata);\n\n\tmax_tcpci_init_regs(chip);\n\n\treturn 0;\n}\n\nstatic int tcpci_init(struct tcpci *tcpci, struct tcpci_data *data)\n{\n\t \n\treturn -1;\n}\n\nstatic void max_tcpci_check_contaminant(struct tcpci *tcpci, struct tcpci_data *tdata)\n{\n\tstruct max_tcpci_chip *chip = tdata_to_max_tcpci(tdata);\n\n\tif (!max_contaminant_is_contaminant(chip, true))\n\t\ttcpm_port_clean(chip->port);\n}\n\nstatic int max_tcpci_probe(struct i2c_client *client)\n{\n\tint ret;\n\tstruct max_tcpci_chip *chip;\n\tu8 power_status;\n\n\tchip = devm_kzalloc(&client->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->client = client;\n\tchip->data.regmap = devm_regmap_init_i2c(client, &max_tcpci_regmap_config);\n\tif (IS_ERR(chip->data.regmap)) {\n\t\tdev_err(&client->dev, \"Regmap init failed\\n\");\n\t\treturn PTR_ERR(chip->data.regmap);\n\t}\n\n\tchip->dev = &client->dev;\n\ti2c_set_clientdata(client, chip);\n\n\tret = max_tcpci_read8(chip, TCPC_POWER_STATUS, &power_status);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tchip->data.set_vbus = max_tcpci_set_vbus;\n\tchip->data.start_drp_toggling = max_tcpci_start_toggling;\n\tchip->data.TX_BUF_BYTE_x_hidden = true;\n\tchip->data.init = tcpci_init;\n\tchip->data.frs_sourcing_vbus = max_tcpci_frs_sourcing_vbus;\n\tchip->data.auto_discharge_disconnect = true;\n\tchip->data.vbus_vsafe0v = true;\n\tchip->data.set_partner_usb_comm_capable = max_tcpci_set_partner_usb_comm_capable;\n\tchip->data.check_contaminant = max_tcpci_check_contaminant;\n\n\tmax_tcpci_init_regs(chip);\n\tchip->tcpci = tcpci_register_port(chip->dev, &chip->data);\n\tif (IS_ERR(chip->tcpci)) {\n\t\tdev_err(&client->dev, \"TCPCI port registration failed\\n\");\n\t\treturn PTR_ERR(chip->tcpci);\n\t}\n\tchip->port = tcpci_get_tcpm_port(chip->tcpci);\n\tret = max_tcpci_init_alert(chip, client);\n\tif (ret < 0)\n\t\tgoto unreg_port;\n\n\tdevice_init_wakeup(chip->dev, true);\n\treturn 0;\n\nunreg_port:\n\ttcpci_unregister_port(chip->tcpci);\n\n\treturn ret;\n}\n\nstatic void max_tcpci_remove(struct i2c_client *client)\n{\n\tstruct max_tcpci_chip *chip = i2c_get_clientdata(client);\n\n\tif (!IS_ERR_OR_NULL(chip->tcpci))\n\t\ttcpci_unregister_port(chip->tcpci);\n}\n\nstatic const struct i2c_device_id max_tcpci_id[] = {\n\t{ \"maxtcpc\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, max_tcpci_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id max_tcpci_of_match[] = {\n\t{ .compatible = \"maxim,max33359\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max_tcpci_of_match);\n#endif\n\nstatic struct i2c_driver max_tcpci_i2c_driver = {\n\t.driver = {\n\t\t.name = \"maxtcpc\",\n\t\t.of_match_table = of_match_ptr(max_tcpci_of_match),\n\t},\n\t.probe = max_tcpci_probe,\n\t.remove = max_tcpci_remove,\n\t.id_table = max_tcpci_id,\n};\nmodule_i2c_driver(max_tcpci_i2c_driver);\n\nMODULE_AUTHOR(\"Badhri Jagan Sridharan <badhri@google.com>\");\nMODULE_DESCRIPTION(\"Maxim TCPCI based USB Type-C Port Controller Interface Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}