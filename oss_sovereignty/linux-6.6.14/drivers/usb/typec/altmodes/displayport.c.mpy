{
  "module_name": "displayport.c",
  "hash_id": "7fedd6f6508d3bd7afe5f3544a55adbc19a1598528f18f703a5c184c65f29734",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/altmodes/displayport.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/property.h>\n#include <linux/usb/pd_vdo.h>\n#include <linux/usb/typec_dp.h>\n#include <drm/drm_connector.h>\n#include \"displayport.h\"\n\n#define DP_HEADER(_dp, ver, cmd)\t(VDO((_dp)->alt->svid, 1, ver, cmd)\t\\\n\t\t\t\t\t | VDO_OPOS(USB_TYPEC_DP_MODE))\n\nenum {\n\tDP_CONF_USB,\n\tDP_CONF_DFP_D,\n\tDP_CONF_UFP_D,\n\tDP_CONF_DUAL_D,\n};\n\n \n#define DP_PIN_ASSIGN_GEN2_BR_MASK\t(BIT(DP_PIN_ASSIGN_A) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_B))\n\n \n#define DP_PIN_ASSIGN_DP_BR_MASK\t(BIT(DP_PIN_ASSIGN_C) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_D) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_E) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_F))\n\n \n#define DP_PIN_ASSIGN_DP_ONLY_MASK\t(BIT(DP_PIN_ASSIGN_A) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_C) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_E))\n\n \n#define DP_PIN_ASSIGN_MULTI_FUNC_MASK\t(BIT(DP_PIN_ASSIGN_B) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_D) | \\\n\t\t\t\t\t BIT(DP_PIN_ASSIGN_F))\n\nenum dp_state {\n\tDP_STATE_IDLE,\n\tDP_STATE_ENTER,\n\tDP_STATE_UPDATE,\n\tDP_STATE_CONFIGURE,\n\tDP_STATE_EXIT,\n};\n\nstruct dp_altmode {\n\tstruct typec_displayport_data data;\n\n\tenum dp_state state;\n\tbool hpd;\n\tbool pending_hpd;\n\n\tstruct mutex lock;  \n\tstruct work_struct work;\n\tstruct typec_altmode *alt;\n\tconst struct typec_altmode *port;\n\tstruct fwnode_handle *connector_fwnode;\n};\n\nstatic int dp_altmode_notify(struct dp_altmode *dp)\n{\n\tunsigned long conf;\n\tu8 state;\n\n\tif (dp->data.conf) {\n\t\tstate = get_count_order(DP_CONF_GET_PIN_ASSIGN(dp->data.conf));\n\t\tconf = TYPEC_MODAL_STATE(state);\n\t} else {\n\t\tconf = TYPEC_STATE_USB;\n\t}\n\n\treturn typec_altmode_notify(dp->alt, conf, &dp->data);\n}\n\nstatic int dp_altmode_configure(struct dp_altmode *dp, u8 con)\n{\n\tu32 conf = DP_CONF_SIGNALING_DP;  \n\tu8 pin_assign = 0;\n\n\tswitch (con) {\n\tcase DP_STATUS_CON_DISABLED:\n\t\treturn 0;\n\tcase DP_STATUS_CON_DFP_D:\n\t\tconf |= DP_CONF_UFP_U_AS_DFP_D;\n\t\tpin_assign = DP_CAP_UFP_D_PIN_ASSIGN(dp->alt->vdo) &\n\t\t\t     DP_CAP_DFP_D_PIN_ASSIGN(dp->port->vdo);\n\t\tbreak;\n\tcase DP_STATUS_CON_UFP_D:\n\tcase DP_STATUS_CON_BOTH:  \n\t\tconf |= DP_CONF_UFP_U_AS_UFP_D;\n\t\tpin_assign = DP_CAP_PIN_ASSIGN_UFP_D(dp->alt->vdo) &\n\t\t\t\t DP_CAP_PIN_ASSIGN_DFP_D(dp->port->vdo);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (!DP_CONF_GET_PIN_ASSIGN(dp->data.conf)) {\n\t\t \n\t\tif (dp->data.status & DP_STATUS_PREFER_MULTI_FUNC &&\n\t\t    pin_assign & DP_PIN_ASSIGN_MULTI_FUNC_MASK)\n\t\t\tpin_assign &= DP_PIN_ASSIGN_MULTI_FUNC_MASK;\n\t\telse if (pin_assign & DP_PIN_ASSIGN_DP_ONLY_MASK) {\n\t\t\tpin_assign &= DP_PIN_ASSIGN_DP_ONLY_MASK;\n\t\t\t \n\t\t\tif (pin_assign & BIT(DP_PIN_ASSIGN_C))\n\t\t\t\tpin_assign = BIT(DP_PIN_ASSIGN_C);\n\t\t}\n\n\t\tif (!pin_assign)\n\t\t\treturn -EINVAL;\n\n\t\tconf |= DP_CONF_SET_PIN_ASSIGN(pin_assign);\n\t}\n\n\tdp->data.conf = conf;\n\n\treturn 0;\n}\n\nstatic int dp_altmode_status_update(struct dp_altmode *dp)\n{\n\tbool configured = !!DP_CONF_GET_PIN_ASSIGN(dp->data.conf);\n\tbool hpd = !!(dp->data.status & DP_STATUS_HPD_STATE);\n\tu8 con = DP_STATUS_CONNECTION(dp->data.status);\n\tint ret = 0;\n\n\tif (configured && (dp->data.status & DP_STATUS_SWITCH_TO_USB)) {\n\t\tdp->data.conf = 0;\n\t\tdp->state = DP_STATE_CONFIGURE;\n\t} else if (dp->data.status & DP_STATUS_EXIT_DP_MODE) {\n\t\tdp->state = DP_STATE_EXIT;\n\t} else if (!(con & DP_CONF_CURRENTLY(dp->data.conf))) {\n\t\tret = dp_altmode_configure(dp, con);\n\t\tif (!ret) {\n\t\t\tdp->state = DP_STATE_CONFIGURE;\n\t\t\tif (dp->hpd != hpd) {\n\t\t\t\tdp->hpd = hpd;\n\t\t\t\tdp->pending_hpd = true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (dp->hpd != hpd) {\n\t\t\tdrm_connector_oob_hotplug_event(dp->connector_fwnode);\n\t\t\tdp->hpd = hpd;\n\t\t\tsysfs_notify(&dp->alt->dev.kobj, \"displayport\", \"hpd\");\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int dp_altmode_configured(struct dp_altmode *dp)\n{\n\tsysfs_notify(&dp->alt->dev.kobj, \"displayport\", \"configuration\");\n\tsysfs_notify(&dp->alt->dev.kobj, \"displayport\", \"pin_assignment\");\n\t \n\tif (dp->pending_hpd) {\n\t\tdrm_connector_oob_hotplug_event(dp->connector_fwnode);\n\t\tsysfs_notify(&dp->alt->dev.kobj, \"displayport\", \"hpd\");\n\t\tdp->pending_hpd = false;\n\t}\n\n\treturn dp_altmode_notify(dp);\n}\n\nstatic int dp_altmode_configure_vdm(struct dp_altmode *dp, u32 conf)\n{\n\tint svdm_version = typec_altmode_get_svdm_version(dp->alt);\n\tu32 header;\n\tint ret;\n\n\tif (svdm_version < 0)\n\t\treturn svdm_version;\n\n\theader = DP_HEADER(dp, svdm_version, DP_CMD_CONFIGURE);\n\tret = typec_altmode_notify(dp->alt, TYPEC_STATE_SAFE, &dp->data);\n\tif (ret) {\n\t\tdev_err(&dp->alt->dev,\n\t\t\t\"unable to put to connector to safe mode\\n\");\n\t\treturn ret;\n\t}\n\n\tret = typec_altmode_vdm(dp->alt, header, &conf, 2);\n\tif (ret)\n\t\tdp_altmode_notify(dp);\n\n\treturn ret;\n}\n\nstatic void dp_altmode_work(struct work_struct *work)\n{\n\tstruct dp_altmode *dp = container_of(work, struct dp_altmode, work);\n\tint svdm_version;\n\tu32 header;\n\tu32 vdo;\n\tint ret;\n\n\tmutex_lock(&dp->lock);\n\n\tswitch (dp->state) {\n\tcase DP_STATE_ENTER:\n\t\tret = typec_altmode_enter(dp->alt, NULL);\n\t\tif (ret && ret != -EBUSY)\n\t\t\tdev_err(&dp->alt->dev, \"failed to enter mode\\n\");\n\t\tbreak;\n\tcase DP_STATE_UPDATE:\n\t\tsvdm_version = typec_altmode_get_svdm_version(dp->alt);\n\t\tif (svdm_version < 0)\n\t\t\tbreak;\n\t\theader = DP_HEADER(dp, svdm_version, DP_CMD_STATUS_UPDATE);\n\t\tvdo = 1;\n\t\tret = typec_altmode_vdm(dp->alt, header, &vdo, 2);\n\t\tif (ret)\n\t\t\tdev_err(&dp->alt->dev,\n\t\t\t\t\"unable to send Status Update command (%d)\\n\",\n\t\t\t\tret);\n\t\tbreak;\n\tcase DP_STATE_CONFIGURE:\n\t\tret = dp_altmode_configure_vdm(dp, dp->data.conf);\n\t\tif (ret)\n\t\t\tdev_err(&dp->alt->dev,\n\t\t\t\t\"unable to send Configure command (%d)\\n\", ret);\n\t\tbreak;\n\tcase DP_STATE_EXIT:\n\t\tif (typec_altmode_exit(dp->alt))\n\t\t\tdev_err(&dp->alt->dev, \"Exit Mode Failed!\\n\");\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdp->state = DP_STATE_IDLE;\n\n\tmutex_unlock(&dp->lock);\n}\n\nstatic void dp_altmode_attention(struct typec_altmode *alt, const u32 vdo)\n{\n\tstruct dp_altmode *dp = typec_altmode_get_drvdata(alt);\n\tu8 old_state;\n\n\tmutex_lock(&dp->lock);\n\n\told_state = dp->state;\n\tdp->data.status = vdo;\n\n\tif (old_state != DP_STATE_IDLE)\n\t\tdev_warn(&alt->dev, \"ATTENTION while processing state %d\\n\",\n\t\t\t old_state);\n\n\tif (dp_altmode_status_update(dp))\n\t\tdev_warn(&alt->dev, \"%s: status update failed\\n\", __func__);\n\n\tif (dp_altmode_notify(dp))\n\t\tdev_err(&alt->dev, \"%s: notification failed\\n\", __func__);\n\n\tif (old_state == DP_STATE_IDLE && dp->state != DP_STATE_IDLE)\n\t\tschedule_work(&dp->work);\n\n\tmutex_unlock(&dp->lock);\n}\n\nstatic int dp_altmode_vdm(struct typec_altmode *alt,\n\t\t\t  const u32 hdr, const u32 *vdo, int count)\n{\n\tstruct dp_altmode *dp = typec_altmode_get_drvdata(alt);\n\tint cmd_type = PD_VDO_CMDT(hdr);\n\tint cmd = PD_VDO_CMD(hdr);\n\tint ret = 0;\n\n\tmutex_lock(&dp->lock);\n\n\tif (dp->state != DP_STATE_IDLE) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tswitch (cmd_type) {\n\tcase CMDT_RSP_ACK:\n\t\tswitch (cmd) {\n\t\tcase CMD_ENTER_MODE:\n\t\t\ttypec_altmode_update_active(alt, true);\n\t\t\tdp->state = DP_STATE_UPDATE;\n\t\t\tbreak;\n\t\tcase CMD_EXIT_MODE:\n\t\t\ttypec_altmode_update_active(alt, false);\n\t\t\tdp->data.status = 0;\n\t\t\tdp->data.conf = 0;\n\t\t\tif (dp->hpd) {\n\t\t\t\tdrm_connector_oob_hotplug_event(dp->connector_fwnode);\n\t\t\t\tdp->hpd = false;\n\t\t\t\tsysfs_notify(&dp->alt->dev.kobj, \"displayport\", \"hpd\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase DP_CMD_STATUS_UPDATE:\n\t\t\tdp->data.status = *vdo;\n\t\t\tret = dp_altmode_status_update(dp);\n\t\t\tbreak;\n\t\tcase DP_CMD_CONFIGURE:\n\t\t\tret = dp_altmode_configured(dp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase CMDT_RSP_NAK:\n\t\tswitch (cmd) {\n\t\tcase DP_CMD_CONFIGURE:\n\t\t\tdp->data.conf = 0;\n\t\t\tret = dp_altmode_configured(dp);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (dp->state != DP_STATE_IDLE)\n\t\tschedule_work(&dp->work);\n\nerr_unlock:\n\tmutex_unlock(&dp->lock);\n\treturn ret;\n}\n\nstatic int dp_altmode_activate(struct typec_altmode *alt, int activate)\n{\n\treturn activate ? typec_altmode_enter(alt, NULL) :\n\t\t\t  typec_altmode_exit(alt);\n}\n\nstatic const struct typec_altmode_ops dp_altmode_ops = {\n\t.attention = dp_altmode_attention,\n\t.vdm = dp_altmode_vdm,\n\t.activate = dp_altmode_activate,\n};\n\nstatic const char * const configurations[] = {\n\t[DP_CONF_USB]\t= \"USB\",\n\t[DP_CONF_DFP_D]\t= \"source\",\n\t[DP_CONF_UFP_D]\t= \"sink\",\n};\n\nstatic ssize_t\nconfiguration_store(struct device *dev, struct device_attribute *attr,\n\t\t    const char *buf, size_t size)\n{\n\tstruct dp_altmode *dp = dev_get_drvdata(dev);\n\tu32 conf;\n\tu32 cap;\n\tint con;\n\tint ret = 0;\n\n\tcon = sysfs_match_string(configurations, buf);\n\tif (con < 0)\n\t\treturn con;\n\n\tmutex_lock(&dp->lock);\n\n\tif (dp->state != DP_STATE_IDLE) {\n\t\tret = -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\tcap = DP_CAP_CAPABILITY(dp->alt->vdo);\n\n\tif ((con == DP_CONF_DFP_D && !(cap & DP_CAP_DFP_D)) ||\n\t    (con == DP_CONF_UFP_D && !(cap & DP_CAP_UFP_D))) {\n\t\tret = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\n\tconf = dp->data.conf & ~DP_CONF_DUAL_D;\n\tconf |= con;\n\n\tif (dp->alt->active) {\n\t\tret = dp_altmode_configure_vdm(dp, conf);\n\t\tif (ret)\n\t\t\tgoto err_unlock;\n\t}\n\n\tdp->data.conf = conf;\n\nerr_unlock:\n\tmutex_unlock(&dp->lock);\n\n\treturn ret ? ret : size;\n}\n\nstatic ssize_t configuration_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct dp_altmode *dp = dev_get_drvdata(dev);\n\tint len;\n\tu8 cap;\n\tu8 cur;\n\tint i;\n\n\tmutex_lock(&dp->lock);\n\n\tcap = DP_CAP_CAPABILITY(dp->alt->vdo);\n\tcur = DP_CONF_CURRENTLY(dp->data.conf);\n\n\tlen = sprintf(buf, \"%s \", cur ? \"USB\" : \"[USB]\");\n\n\tfor (i = 1; i < ARRAY_SIZE(configurations); i++) {\n\t\tif (i == cur)\n\t\t\tlen += sprintf(buf + len, \"[%s] \", configurations[i]);\n\t\telse if ((i == DP_CONF_DFP_D && cap & DP_CAP_DFP_D) ||\n\t\t\t (i == DP_CONF_UFP_D && cap & DP_CAP_UFP_D))\n\t\t\tlen += sprintf(buf + len, \"%s \", configurations[i]);\n\t}\n\n\tmutex_unlock(&dp->lock);\n\n\tbuf[len - 1] = '\\n';\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(configuration);\n\nstatic const char * const pin_assignments[] = {\n\t[DP_PIN_ASSIGN_A] = \"A\",\n\t[DP_PIN_ASSIGN_B] = \"B\",\n\t[DP_PIN_ASSIGN_C] = \"C\",\n\t[DP_PIN_ASSIGN_D] = \"D\",\n\t[DP_PIN_ASSIGN_E] = \"E\",\n\t[DP_PIN_ASSIGN_F] = \"F\",\n};\n\n \nstatic u8 get_current_pin_assignments(struct dp_altmode *dp)\n{\n\tif (DP_CONF_CURRENTLY(dp->data.conf) == DP_CONF_UFP_U_AS_DFP_D)\n\t\treturn DP_CAP_PIN_ASSIGN_DFP_D(dp->alt->vdo);\n\telse\n\t\treturn DP_CAP_PIN_ASSIGN_UFP_D(dp->alt->vdo);\n}\n\nstatic ssize_t\npin_assignment_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t size)\n{\n\tstruct dp_altmode *dp = dev_get_drvdata(dev);\n\tu8 assignments;\n\tu32 conf;\n\tint ret;\n\n\tret = sysfs_match_string(pin_assignments, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tconf = DP_CONF_SET_PIN_ASSIGN(BIT(ret));\n\tret = 0;\n\n\tmutex_lock(&dp->lock);\n\n\tif (conf & dp->data.conf)\n\t\tgoto out_unlock;\n\n\tif (dp->state != DP_STATE_IDLE) {\n\t\tret = -EBUSY;\n\t\tgoto out_unlock;\n\t}\n\n\tassignments = get_current_pin_assignments(dp);\n\n\tif (!(DP_CONF_GET_PIN_ASSIGN(conf) & assignments)) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tconf |= dp->data.conf & ~DP_CONF_PIN_ASSIGNEMENT_MASK;\n\n\t \n\tif (dp->alt->active && DP_CONF_CURRENTLY(dp->data.conf)) {\n\t\tret = dp_altmode_configure_vdm(dp, conf);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\tdp->data.conf = conf;\n\nout_unlock:\n\tmutex_unlock(&dp->lock);\n\n\treturn ret ? ret : size;\n}\n\nstatic ssize_t pin_assignment_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tstruct dp_altmode *dp = dev_get_drvdata(dev);\n\tu8 assignments;\n\tint len = 0;\n\tu8 cur;\n\tint i;\n\n\tmutex_lock(&dp->lock);\n\n\tcur = get_count_order(DP_CONF_GET_PIN_ASSIGN(dp->data.conf));\n\n\tassignments = get_current_pin_assignments(dp);\n\n\tfor (i = 0; assignments; assignments >>= 1, i++) {\n\t\tif (assignments & 1) {\n\t\t\tif (i == cur)\n\t\t\t\tlen += sprintf(buf + len, \"[%s] \",\n\t\t\t\t\t       pin_assignments[i]);\n\t\t\telse\n\t\t\t\tlen += sprintf(buf + len, \"%s \",\n\t\t\t\t\t       pin_assignments[i]);\n\t\t}\n\t}\n\n\tmutex_unlock(&dp->lock);\n\n\t \n\tif (len == 0)\n\t\tlen++;\n\n\tbuf[len - 1] = '\\n';\n\treturn len;\n}\nstatic DEVICE_ATTR_RW(pin_assignment);\n\nstatic ssize_t hpd_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct dp_altmode *dp = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", dp->hpd);\n}\nstatic DEVICE_ATTR_RO(hpd);\n\nstatic struct attribute *dp_altmode_attrs[] = {\n\t&dev_attr_configuration.attr,\n\t&dev_attr_pin_assignment.attr,\n\t&dev_attr_hpd.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dp_altmode_group = {\n\t.name = \"displayport\",\n\t.attrs = dp_altmode_attrs,\n};\n\nint dp_altmode_probe(struct typec_altmode *alt)\n{\n\tconst struct typec_altmode *port = typec_altmode_get_partner(alt);\n\tstruct fwnode_handle *fwnode;\n\tstruct dp_altmode *dp;\n\tint ret;\n\n\t \n\n\t \n\tif (!(DP_CAP_PIN_ASSIGN_DFP_D(port->vdo) &\n\t      DP_CAP_PIN_ASSIGN_UFP_D(alt->vdo)) &&\n\t    !(DP_CAP_PIN_ASSIGN_UFP_D(port->vdo) &\n\t      DP_CAP_PIN_ASSIGN_DFP_D(alt->vdo)))\n\t\treturn -ENODEV;\n\n\tret = sysfs_create_group(&alt->dev.kobj, &dp_altmode_group);\n\tif (ret)\n\t\treturn ret;\n\n\tdp = devm_kzalloc(&alt->dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&dp->work, dp_altmode_work);\n\tmutex_init(&dp->lock);\n\tdp->port = port;\n\tdp->alt = alt;\n\n\talt->desc = \"DisplayPort\";\n\talt->ops = &dp_altmode_ops;\n\n\tfwnode = dev_fwnode(alt->dev.parent->parent);  \n\tif (fwnode_property_present(fwnode, \"displayport\"))\n\t\tdp->connector_fwnode = fwnode_find_reference(fwnode, \"displayport\", 0);\n\telse\n\t\tdp->connector_fwnode = fwnode_handle_get(fwnode);  \n\tif (IS_ERR(dp->connector_fwnode))\n\t\tdp->connector_fwnode = NULL;\n\n\ttypec_altmode_set_drvdata(alt, dp);\n\n\tdp->state = DP_STATE_ENTER;\n\tschedule_work(&dp->work);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(dp_altmode_probe);\n\nvoid dp_altmode_remove(struct typec_altmode *alt)\n{\n\tstruct dp_altmode *dp = typec_altmode_get_drvdata(alt);\n\n\tsysfs_remove_group(&alt->dev.kobj, &dp_altmode_group);\n\tcancel_work_sync(&dp->work);\n\n\tif (dp->connector_fwnode) {\n\t\tif (dp->hpd)\n\t\t\tdrm_connector_oob_hotplug_event(dp->connector_fwnode);\n\n\t\tfwnode_handle_put(dp->connector_fwnode);\n\t}\n}\nEXPORT_SYMBOL_GPL(dp_altmode_remove);\n\nstatic const struct typec_device_id dp_typec_id[] = {\n\t{ USB_TYPEC_DP_SID, USB_TYPEC_DP_MODE },\n\t{ },\n};\nMODULE_DEVICE_TABLE(typec, dp_typec_id);\n\nstatic struct typec_altmode_driver dp_altmode_driver = {\n\t.id_table = dp_typec_id,\n\t.probe = dp_altmode_probe,\n\t.remove = dp_altmode_remove,\n\t.driver = {\n\t\t.name = \"typec_displayport\",\n\t\t.owner = THIS_MODULE,\n\t},\n};\nmodule_typec_altmode_driver(dp_altmode_driver);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"DisplayPort Alternate Mode\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}