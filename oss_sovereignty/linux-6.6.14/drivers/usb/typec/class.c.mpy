{
  "module_name": "class.c",
  "hash_id": "28e8622b0dd7c9f798b999e8066c0a863d3da19a799dcf72617132a1d58ffb1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/class.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n#include <linux/usb/pd_vdo.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/usb/typec_retimer.h>\n\n#include \"bus.h\"\n#include \"class.h\"\n#include \"pd.h\"\n\nstatic DEFINE_IDA(typec_index_ida);\n\nstruct class typec_class = {\n\t.name = \"typec\",\n};\n\n \n \n\nstatic const char * const typec_accessory_modes[] = {\n\t[TYPEC_ACCESSORY_NONE]\t\t= \"none\",\n\t[TYPEC_ACCESSORY_AUDIO]\t\t= \"analog_audio\",\n\t[TYPEC_ACCESSORY_DEBUG]\t\t= \"debug\",\n};\n\n \nstatic const char * const product_type_ufp[8] = {\n\t[IDH_PTYPE_NOT_UFP]\t\t= \"not_ufp\",\n\t[IDH_PTYPE_HUB]\t\t\t= \"hub\",\n\t[IDH_PTYPE_PERIPH]\t\t= \"peripheral\",\n\t[IDH_PTYPE_PSD]\t\t\t= \"psd\",\n\t[IDH_PTYPE_AMA]\t\t\t= \"ama\",\n};\n\nstatic const char * const product_type_dfp[8] = {\n\t[IDH_PTYPE_NOT_DFP]\t\t= \"not_dfp\",\n\t[IDH_PTYPE_DFP_HUB]\t\t= \"hub\",\n\t[IDH_PTYPE_DFP_HOST]\t\t= \"host\",\n\t[IDH_PTYPE_DFP_PB]\t\t= \"power_brick\",\n};\n\nstatic const char * const product_type_cable[8] = {\n\t[IDH_PTYPE_NOT_CABLE]\t\t= \"not_cable\",\n\t[IDH_PTYPE_PCABLE]\t\t= \"passive\",\n\t[IDH_PTYPE_ACABLE]\t\t= \"active\",\n\t[IDH_PTYPE_VPD]\t\t\t= \"vpd\",\n};\n\nstatic struct usb_pd_identity *get_pd_identity(struct device *dev)\n{\n\tif (is_typec_partner(dev)) {\n\t\tstruct typec_partner *partner = to_typec_partner(dev);\n\n\t\treturn partner->identity;\n\t} else if (is_typec_cable(dev)) {\n\t\tstruct typec_cable *cable = to_typec_cable(dev);\n\n\t\treturn cable->identity;\n\t}\n\treturn NULL;\n}\n\nstatic const char *get_pd_product_type(struct device *dev)\n{\n\tstruct typec_port *port = to_typec_port(dev->parent);\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\tconst char *ptype = NULL;\n\n\tif (is_typec_partner(dev)) {\n\t\tif (!id)\n\t\t\treturn NULL;\n\n\t\tif (port->data_role == TYPEC_HOST)\n\t\t\tptype = product_type_ufp[PD_IDH_PTYPE(id->id_header)];\n\t\telse\n\t\t\tptype = product_type_dfp[PD_IDH_DFP_PTYPE(id->id_header)];\n\t} else if (is_typec_cable(dev)) {\n\t\tif (id)\n\t\t\tptype = product_type_cable[PD_IDH_PTYPE(id->id_header)];\n\t\telse\n\t\t\tptype = to_typec_cable(dev)->active ?\n\t\t\t\tproduct_type_cable[IDH_PTYPE_ACABLE] :\n\t\t\t\tproduct_type_cable[IDH_PTYPE_PCABLE];\n\t}\n\n\treturn ptype;\n}\n\nstatic ssize_t id_header_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", id->id_header);\n}\nstatic DEVICE_ATTR_RO(id_header);\n\nstatic ssize_t cert_stat_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", id->cert_stat);\n}\nstatic DEVICE_ATTR_RO(cert_stat);\n\nstatic ssize_t product_show(struct device *dev, struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", id->product);\n}\nstatic DEVICE_ATTR_RO(product);\n\nstatic ssize_t product_type_vdo1_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", id->vdo[0]);\n}\nstatic DEVICE_ATTR_RO(product_type_vdo1);\n\nstatic ssize_t product_type_vdo2_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", id->vdo[1]);\n}\nstatic DEVICE_ATTR_RO(product_type_vdo2);\n\nstatic ssize_t product_type_vdo3_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t      char *buf)\n{\n\tstruct usb_pd_identity *id = get_pd_identity(dev);\n\n\treturn sysfs_emit(buf, \"0x%08x\\n\", id->vdo[2]);\n}\nstatic DEVICE_ATTR_RO(product_type_vdo3);\n\nstatic struct attribute *usb_pd_id_attrs[] = {\n\t&dev_attr_id_header.attr,\n\t&dev_attr_cert_stat.attr,\n\t&dev_attr_product.attr,\n\t&dev_attr_product_type_vdo1.attr,\n\t&dev_attr_product_type_vdo2.attr,\n\t&dev_attr_product_type_vdo3.attr,\n\tNULL\n};\n\nstatic const struct attribute_group usb_pd_id_group = {\n\t.name = \"identity\",\n\t.attrs = usb_pd_id_attrs,\n};\n\nstatic const struct attribute_group *usb_pd_id_groups[] = {\n\t&usb_pd_id_group,\n\tNULL,\n};\n\nstatic void typec_product_type_notify(struct device *dev)\n{\n\tchar *envp[2] = { };\n\tconst char *ptype;\n\n\tptype = get_pd_product_type(dev);\n\tif (!ptype)\n\t\treturn;\n\n\tsysfs_notify(&dev->kobj, NULL, \"type\");\n\n\tenvp[0] = kasprintf(GFP_KERNEL, \"PRODUCT_TYPE=%s\", ptype);\n\tif (!envp[0])\n\t\treturn;\n\n\tkobject_uevent_env(&dev->kobj, KOBJ_CHANGE, envp);\n\tkfree(envp[0]);\n}\n\nstatic void typec_report_identity(struct device *dev)\n{\n\tsysfs_notify(&dev->kobj, \"identity\", \"id_header\");\n\tsysfs_notify(&dev->kobj, \"identity\", \"cert_stat\");\n\tsysfs_notify(&dev->kobj, \"identity\", \"product\");\n\tsysfs_notify(&dev->kobj, \"identity\", \"product_type_vdo1\");\n\tsysfs_notify(&dev->kobj, \"identity\", \"product_type_vdo2\");\n\tsysfs_notify(&dev->kobj, \"identity\", \"product_type_vdo3\");\n\ttypec_product_type_notify(dev);\n}\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tconst char *ptype;\n\n\tptype = get_pd_product_type(dev);\n\tif (!ptype)\n\t\treturn 0;\n\n\treturn sysfs_emit(buf, \"%s\\n\", ptype);\n}\nstatic DEVICE_ATTR_RO(type);\n\nstatic ssize_t usb_power_delivery_revision_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf);\nstatic DEVICE_ATTR_RO(usb_power_delivery_revision);\n\n \n \n\nstatic int altmode_match(struct device *dev, void *data)\n{\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\tstruct typec_device_id *id = data;\n\n\tif (!is_typec_altmode(dev))\n\t\treturn 0;\n\n\treturn ((adev->svid == id->svid) && (adev->mode == id->mode));\n}\n\nstatic void typec_altmode_set_partner(struct altmode *altmode)\n{\n\tstruct typec_altmode *adev = &altmode->adev;\n\tstruct typec_device_id id = { adev->svid, adev->mode, };\n\tstruct typec_port *port = typec_altmode2port(adev);\n\tstruct altmode *partner;\n\tstruct device *dev;\n\n\tdev = device_find_child(&port->dev, &id, altmode_match);\n\tif (!dev)\n\t\treturn;\n\n\t \n\tpartner = to_altmode(to_typec_altmode(dev));\n\taltmode->partner = partner;\n\n\t \n\tif (is_typec_plug(adev->dev.parent)) {\n\t\tstruct typec_plug *plug = to_typec_plug(adev->dev.parent);\n\n\t\tpartner->plug[plug->index] = altmode;\n\t} else {\n\t\tpartner->partner = altmode;\n\t}\n}\n\nstatic void typec_altmode_put_partner(struct altmode *altmode)\n{\n\tstruct altmode *partner = altmode->partner;\n\tstruct typec_altmode *adev;\n\tstruct typec_altmode *partner_adev;\n\n\tif (!partner)\n\t\treturn;\n\n\tadev = &altmode->adev;\n\tpartner_adev = &partner->adev;\n\n\tif (is_typec_plug(adev->dev.parent)) {\n\t\tstruct typec_plug *plug = to_typec_plug(adev->dev.parent);\n\n\t\tpartner->plug[plug->index] = NULL;\n\t} else {\n\t\tpartner->partner = NULL;\n\t}\n\tput_device(&partner_adev->dev);\n}\n\n \nvoid typec_altmode_update_active(struct typec_altmode *adev, bool active)\n{\n\tchar dir[6];\n\n\tif (adev->active == active)\n\t\treturn;\n\n\tif (!is_typec_port(adev->dev.parent) && adev->dev.driver) {\n\t\tif (!active)\n\t\t\tmodule_put(adev->dev.driver->owner);\n\t\telse\n\t\t\tWARN_ON(!try_module_get(adev->dev.driver->owner));\n\t}\n\n\tadev->active = active;\n\tsnprintf(dir, sizeof(dir), \"mode%d\", adev->mode);\n\tsysfs_notify(&adev->dev.kobj, dir, \"active\");\n\tsysfs_notify(&adev->dev.kobj, NULL, \"active\");\n\tkobject_uevent(&adev->dev.kobj, KOBJ_CHANGE);\n}\nEXPORT_SYMBOL_GPL(typec_altmode_update_active);\n\n \nstruct typec_port *typec_altmode2port(struct typec_altmode *alt)\n{\n\tif (is_typec_plug(alt->dev.parent))\n\t\treturn to_typec_port(alt->dev.parent->parent->parent);\n\tif (is_typec_partner(alt->dev.parent))\n\t\treturn to_typec_port(alt->dev.parent->parent);\n\tif (is_typec_port(alt->dev.parent))\n\t\treturn to_typec_port(alt->dev.parent);\n\n\treturn NULL;\n}\nEXPORT_SYMBOL_GPL(typec_altmode2port);\n\nstatic ssize_t\nvdo_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *alt = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"0x%08x\\n\", alt->vdo);\n}\nstatic DEVICE_ATTR_RO(vdo);\n\nstatic ssize_t\ndescription_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *alt = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"%s\\n\", alt->desc ? alt->desc : \"\");\n}\nstatic DEVICE_ATTR_RO(description);\n\nstatic ssize_t\nactive_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *alt = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"%s\\n\", alt->active ? \"yes\" : \"no\");\n}\n\nstatic ssize_t active_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t size)\n{\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\tstruct altmode *altmode = to_altmode(adev);\n\tbool enter;\n\tint ret;\n\n\tret = kstrtobool(buf, &enter);\n\tif (ret)\n\t\treturn ret;\n\n\tif (adev->active == enter)\n\t\treturn size;\n\n\tif (is_typec_port(adev->dev.parent)) {\n\t\ttypec_altmode_update_active(adev, enter);\n\n\t\t \n\t\tif (altmode->partner && !enter && altmode->partner->adev.active)\n\t\t\ttypec_altmode_exit(&altmode->partner->adev);\n\t} else if (altmode->partner) {\n\t\tif (enter && !altmode->partner->adev.active) {\n\t\t\tdev_warn(dev, \"port has the mode disabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\t \n\tif (adev->ops && adev->ops->activate) {\n\t\tret = adev->ops->activate(adev, enter);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn size;\n}\nstatic DEVICE_ATTR_RW(active);\n\nstatic ssize_t\nsupported_roles_show(struct device *dev, struct device_attribute *attr,\n\t\t     char *buf)\n{\n\tstruct altmode *alt = to_altmode(to_typec_altmode(dev));\n\tssize_t ret;\n\n\tswitch (alt->roles) {\n\tcase TYPEC_PORT_SRC:\n\t\tret = sprintf(buf, \"source\\n\");\n\t\tbreak;\n\tcase TYPEC_PORT_SNK:\n\t\tret = sprintf(buf, \"sink\\n\");\n\t\tbreak;\n\tcase TYPEC_PORT_DRP:\n\tdefault:\n\t\tret = sprintf(buf, \"source sink\\n\");\n\t\tbreak;\n\t}\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(supported_roles);\n\nstatic ssize_t\nmode_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"%u\\n\", adev->mode);\n}\nstatic DEVICE_ATTR_RO(mode);\n\nstatic ssize_t\nsvid_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct typec_altmode *adev = to_typec_altmode(dev);\n\n\treturn sprintf(buf, \"%04x\\n\", adev->svid);\n}\nstatic DEVICE_ATTR_RO(svid);\n\nstatic struct attribute *typec_altmode_attrs[] = {\n\t&dev_attr_active.attr,\n\t&dev_attr_mode.attr,\n\t&dev_attr_svid.attr,\n\t&dev_attr_vdo.attr,\n\tNULL\n};\n\nstatic umode_t typec_altmode_attr_is_visible(struct kobject *kobj,\n\t\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct typec_altmode *adev = to_typec_altmode(kobj_to_dev(kobj));\n\n\tif (attr == &dev_attr_active.attr)\n\t\tif (!adev->ops || !adev->ops->activate)\n\t\t\treturn 0444;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group typec_altmode_group = {\n\t.is_visible = typec_altmode_attr_is_visible,\n\t.attrs = typec_altmode_attrs,\n};\n\nstatic const struct attribute_group *typec_altmode_groups[] = {\n\t&typec_altmode_group,\n\tNULL\n};\n\nstatic int altmode_id_get(struct device *dev)\n{\n\tstruct ida *ids;\n\n\tif (is_typec_partner(dev))\n\t\tids = &to_typec_partner(dev)->mode_ids;\n\telse if (is_typec_plug(dev))\n\t\tids = &to_typec_plug(dev)->mode_ids;\n\telse\n\t\tids = &to_typec_port(dev)->mode_ids;\n\n\treturn ida_simple_get(ids, 0, 0, GFP_KERNEL);\n}\n\nstatic void altmode_id_remove(struct device *dev, int id)\n{\n\tstruct ida *ids;\n\n\tif (is_typec_partner(dev))\n\t\tids = &to_typec_partner(dev)->mode_ids;\n\telse if (is_typec_plug(dev))\n\t\tids = &to_typec_plug(dev)->mode_ids;\n\telse\n\t\tids = &to_typec_port(dev)->mode_ids;\n\n\tida_simple_remove(ids, id);\n}\n\nstatic void typec_altmode_release(struct device *dev)\n{\n\tstruct altmode *alt = to_altmode(to_typec_altmode(dev));\n\n\tif (!is_typec_port(dev->parent))\n\t\ttypec_altmode_put_partner(alt);\n\n\taltmode_id_remove(alt->adev.dev.parent, alt->id);\n\tkfree(alt);\n}\n\nconst struct device_type typec_altmode_dev_type = {\n\t.name = \"typec_alternate_mode\",\n\t.groups = typec_altmode_groups,\n\t.release = typec_altmode_release,\n};\n\nstatic struct typec_altmode *\ntypec_register_altmode(struct device *parent,\n\t\t       const struct typec_altmode_desc *desc)\n{\n\tunsigned int id = altmode_id_get(parent);\n\tbool is_port = is_typec_port(parent);\n\tstruct altmode *alt;\n\tint ret;\n\n\talt = kzalloc(sizeof(*alt), GFP_KERNEL);\n\tif (!alt) {\n\t\taltmode_id_remove(parent, id);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\talt->adev.svid = desc->svid;\n\talt->adev.mode = desc->mode;\n\talt->adev.vdo = desc->vdo;\n\talt->roles = desc->roles;\n\talt->id = id;\n\n\talt->attrs[0] = &dev_attr_vdo.attr;\n\talt->attrs[1] = &dev_attr_description.attr;\n\talt->attrs[2] = &dev_attr_active.attr;\n\n\tif (is_port) {\n\t\talt->attrs[3] = &dev_attr_supported_roles.attr;\n\t\talt->adev.active = true;  \n\t}\n\n\tsprintf(alt->group_name, \"mode%d\", desc->mode);\n\talt->group.name = alt->group_name;\n\talt->group.attrs = alt->attrs;\n\talt->groups[0] = &alt->group;\n\n\talt->adev.dev.parent = parent;\n\talt->adev.dev.groups = alt->groups;\n\talt->adev.dev.type = &typec_altmode_dev_type;\n\tdev_set_name(&alt->adev.dev, \"%s.%u\", dev_name(parent), id);\n\n\t \n\tif (!is_port)\n\t\ttypec_altmode_set_partner(alt);\n\n\t \n\tif (is_typec_partner(parent))\n\t\talt->adev.dev.bus = &typec_bus;\n\n\t \n\tif (is_typec_plug(parent))\n\t\talt->adev.dev.class = &typec_class;\n\n\tret = device_register(&alt->adev.dev);\n\tif (ret) {\n\t\tdev_err(parent, \"failed to register alternate mode (%d)\\n\",\n\t\t\tret);\n\t\tput_device(&alt->adev.dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn &alt->adev;\n}\n\n \nvoid typec_unregister_altmode(struct typec_altmode *adev)\n{\n\tif (IS_ERR_OR_NULL(adev))\n\t\treturn;\n\ttypec_retimer_put(to_altmode(adev)->retimer);\n\ttypec_mux_put(to_altmode(adev)->mux);\n\tdevice_unregister(&adev->dev);\n}\nEXPORT_SYMBOL_GPL(typec_unregister_altmode);\n\n \n \n\nstatic ssize_t accessory_mode_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct typec_partner *p = to_typec_partner(dev);\n\n\treturn sprintf(buf, \"%s\\n\", typec_accessory_modes[p->accessory]);\n}\nstatic DEVICE_ATTR_RO(accessory_mode);\n\nstatic ssize_t supports_usb_power_delivery_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tstruct typec_partner *p = to_typec_partner(dev);\n\n\treturn sprintf(buf, \"%s\\n\", p->usb_pd ? \"yes\" : \"no\");\n}\nstatic DEVICE_ATTR_RO(supports_usb_power_delivery);\n\nstatic ssize_t number_of_alternate_modes_show(struct device *dev, struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct typec_partner *partner;\n\tstruct typec_plug *plug;\n\tint num_altmodes;\n\n\tif (is_typec_partner(dev)) {\n\t\tpartner = to_typec_partner(dev);\n\t\tnum_altmodes = partner->num_altmodes;\n\t} else if (is_typec_plug(dev)) {\n\t\tplug = to_typec_plug(dev);\n\t\tnum_altmodes = plug->num_altmodes;\n\t} else {\n\t\treturn 0;\n\t}\n\n\treturn sysfs_emit(buf, \"%d\\n\", num_altmodes);\n}\nstatic DEVICE_ATTR_RO(number_of_alternate_modes);\n\nstatic struct attribute *typec_partner_attrs[] = {\n\t&dev_attr_accessory_mode.attr,\n\t&dev_attr_supports_usb_power_delivery.attr,\n\t&dev_attr_number_of_alternate_modes.attr,\n\t&dev_attr_type.attr,\n\t&dev_attr_usb_power_delivery_revision.attr,\n\tNULL\n};\n\nstatic umode_t typec_partner_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct typec_partner *partner = to_typec_partner(kobj_to_dev(kobj));\n\n\tif (attr == &dev_attr_number_of_alternate_modes.attr) {\n\t\tif (partner->num_altmodes < 0)\n\t\t\treturn 0;\n\t}\n\n\tif (attr == &dev_attr_type.attr)\n\t\tif (!get_pd_product_type(kobj_to_dev(kobj)))\n\t\t\treturn 0;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group typec_partner_group = {\n\t.is_visible = typec_partner_attr_is_visible,\n\t.attrs = typec_partner_attrs\n};\n\nstatic const struct attribute_group *typec_partner_groups[] = {\n\t&typec_partner_group,\n\tNULL\n};\n\nstatic void typec_partner_release(struct device *dev)\n{\n\tstruct typec_partner *partner = to_typec_partner(dev);\n\n\tida_destroy(&partner->mode_ids);\n\tkfree(partner);\n}\n\nconst struct device_type typec_partner_dev_type = {\n\t.name = \"typec_partner\",\n\t.groups = typec_partner_groups,\n\t.release = typec_partner_release,\n};\n\n \nint typec_partner_set_identity(struct typec_partner *partner)\n{\n\tif (!partner->identity)\n\t\treturn -EINVAL;\n\n\ttypec_report_identity(&partner->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_partner_set_identity);\n\n \nvoid typec_partner_set_pd_revision(struct typec_partner *partner, u16 pd_revision)\n{\n\tif (partner->pd_revision == pd_revision)\n\t\treturn;\n\n\tpartner->pd_revision = pd_revision;\n\tsysfs_notify(&partner->dev.kobj, NULL, \"usb_power_delivery_revision\");\n\tif (pd_revision != 0 && !partner->usb_pd) {\n\t\tpartner->usb_pd = 1;\n\t\tsysfs_notify(&partner->dev.kobj, NULL,\n\t\t\t     \"supports_usb_power_delivery\");\n\t}\n\tkobject_uevent(&partner->dev.kobj, KOBJ_CHANGE);\n}\nEXPORT_SYMBOL_GPL(typec_partner_set_pd_revision);\n\n \nint typec_partner_set_usb_power_delivery(struct typec_partner *partner,\n\t\t\t\t\t struct usb_power_delivery *pd)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(partner) || partner->pd == pd)\n\t\treturn 0;\n\n\tif (pd) {\n\t\tret = usb_power_delivery_link_device(pd, &partner->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tusb_power_delivery_unlink_device(partner->pd, &partner->dev);\n\t}\n\n\tpartner->pd = pd;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_partner_set_usb_power_delivery);\n\n \nint typec_partner_set_num_altmodes(struct typec_partner *partner, int num_altmodes)\n{\n\tint ret;\n\n\tif (num_altmodes < 0)\n\t\treturn -EINVAL;\n\n\tpartner->num_altmodes = num_altmodes;\n\tret = sysfs_update_group(&partner->dev.kobj, &typec_partner_group);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsysfs_notify(&partner->dev.kobj, NULL, \"number_of_alternate_modes\");\n\tkobject_uevent(&partner->dev.kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_partner_set_num_altmodes);\n\n \nstruct typec_altmode *\ntypec_partner_register_altmode(struct typec_partner *partner,\n\t\t\t       const struct typec_altmode_desc *desc)\n{\n\treturn typec_register_altmode(&partner->dev, desc);\n}\nEXPORT_SYMBOL_GPL(typec_partner_register_altmode);\n\n \nvoid typec_partner_set_svdm_version(struct typec_partner *partner,\n\t\t\t\t   enum usb_pd_svdm_ver svdm_version)\n{\n\tpartner->svdm_version = svdm_version;\n}\nEXPORT_SYMBOL_GPL(typec_partner_set_svdm_version);\n\n \nstruct usb_power_delivery *\ntypec_partner_usb_power_delivery_register(struct typec_partner *partner,\n\t\t\t\t\t  struct usb_power_delivery_desc *desc)\n{\n\treturn usb_power_delivery_register(&partner->dev, desc);\n}\nEXPORT_SYMBOL_GPL(typec_partner_usb_power_delivery_register);\n\n \nstruct typec_partner *typec_register_partner(struct typec_port *port,\n\t\t\t\t\t     struct typec_partner_desc *desc)\n{\n\tstruct typec_partner *partner;\n\tint ret;\n\n\tpartner = kzalloc(sizeof(*partner), GFP_KERNEL);\n\tif (!partner)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tida_init(&partner->mode_ids);\n\tpartner->usb_pd = desc->usb_pd;\n\tpartner->accessory = desc->accessory;\n\tpartner->num_altmodes = -1;\n\tpartner->pd_revision = desc->pd_revision;\n\tpartner->svdm_version = port->cap->svdm_version;\n\n\tif (desc->identity) {\n\t\t \n\t\tpartner->dev.groups = usb_pd_id_groups;\n\t\tpartner->identity = desc->identity;\n\t}\n\n\tpartner->dev.class = &typec_class;\n\tpartner->dev.parent = &port->dev;\n\tpartner->dev.type = &typec_partner_dev_type;\n\tdev_set_name(&partner->dev, \"%s-partner\", dev_name(&port->dev));\n\n\tret = device_register(&partner->dev);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to register partner (%d)\\n\", ret);\n\t\tput_device(&partner->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn partner;\n}\nEXPORT_SYMBOL_GPL(typec_register_partner);\n\n \nvoid typec_unregister_partner(struct typec_partner *partner)\n{\n\tif (!IS_ERR_OR_NULL(partner))\n\t\tdevice_unregister(&partner->dev);\n}\nEXPORT_SYMBOL_GPL(typec_unregister_partner);\n\n \n \n\nstatic void typec_plug_release(struct device *dev)\n{\n\tstruct typec_plug *plug = to_typec_plug(dev);\n\n\tida_destroy(&plug->mode_ids);\n\tkfree(plug);\n}\n\nstatic struct attribute *typec_plug_attrs[] = {\n\t&dev_attr_number_of_alternate_modes.attr,\n\tNULL\n};\n\nstatic umode_t typec_plug_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct typec_plug *plug = to_typec_plug(kobj_to_dev(kobj));\n\n\tif (attr == &dev_attr_number_of_alternate_modes.attr) {\n\t\tif (plug->num_altmodes < 0)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group typec_plug_group = {\n\t.is_visible = typec_plug_attr_is_visible,\n\t.attrs = typec_plug_attrs\n};\n\nstatic const struct attribute_group *typec_plug_groups[] = {\n\t&typec_plug_group,\n\tNULL\n};\n\nconst struct device_type typec_plug_dev_type = {\n\t.name = \"typec_plug\",\n\t.groups = typec_plug_groups,\n\t.release = typec_plug_release,\n};\n\n \nint typec_plug_set_num_altmodes(struct typec_plug *plug, int num_altmodes)\n{\n\tint ret;\n\n\tif (num_altmodes < 0)\n\t\treturn -EINVAL;\n\n\tplug->num_altmodes = num_altmodes;\n\tret = sysfs_update_group(&plug->dev.kobj, &typec_plug_group);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tsysfs_notify(&plug->dev.kobj, NULL, \"number_of_alternate_modes\");\n\tkobject_uevent(&plug->dev.kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_plug_set_num_altmodes);\n\n \nstruct typec_altmode *\ntypec_plug_register_altmode(struct typec_plug *plug,\n\t\t\t    const struct typec_altmode_desc *desc)\n{\n\treturn typec_register_altmode(&plug->dev, desc);\n}\nEXPORT_SYMBOL_GPL(typec_plug_register_altmode);\n\n \nstruct typec_plug *typec_register_plug(struct typec_cable *cable,\n\t\t\t\t       struct typec_plug_desc *desc)\n{\n\tstruct typec_plug *plug;\n\tchar name[8];\n\tint ret;\n\n\tplug = kzalloc(sizeof(*plug), GFP_KERNEL);\n\tif (!plug)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tsprintf(name, \"plug%d\", desc->index);\n\n\tida_init(&plug->mode_ids);\n\tplug->num_altmodes = -1;\n\tplug->index = desc->index;\n\tplug->dev.class = &typec_class;\n\tplug->dev.parent = &cable->dev;\n\tplug->dev.type = &typec_plug_dev_type;\n\tdev_set_name(&plug->dev, \"%s-%s\", dev_name(cable->dev.parent), name);\n\n\tret = device_register(&plug->dev);\n\tif (ret) {\n\t\tdev_err(&cable->dev, \"failed to register plug (%d)\\n\", ret);\n\t\tput_device(&plug->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn plug;\n}\nEXPORT_SYMBOL_GPL(typec_register_plug);\n\n \nvoid typec_unregister_plug(struct typec_plug *plug)\n{\n\tif (!IS_ERR_OR_NULL(plug))\n\t\tdevice_unregister(&plug->dev);\n}\nEXPORT_SYMBOL_GPL(typec_unregister_plug);\n\n \n\nstatic const char * const typec_plug_types[] = {\n\t[USB_PLUG_NONE]\t\t= \"unknown\",\n\t[USB_PLUG_TYPE_A]\t= \"type-a\",\n\t[USB_PLUG_TYPE_B]\t= \"type-b\",\n\t[USB_PLUG_TYPE_C]\t= \"type-c\",\n\t[USB_PLUG_CAPTIVE]\t= \"captive\",\n};\n\nstatic ssize_t plug_type_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct typec_cable *cable = to_typec_cable(dev);\n\n\treturn sprintf(buf, \"%s\\n\", typec_plug_types[cable->type]);\n}\nstatic DEVICE_ATTR_RO(plug_type);\n\nstatic struct attribute *typec_cable_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_plug_type.attr,\n\t&dev_attr_usb_power_delivery_revision.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(typec_cable);\n\nstatic void typec_cable_release(struct device *dev)\n{\n\tstruct typec_cable *cable = to_typec_cable(dev);\n\n\tkfree(cable);\n}\n\nconst struct device_type typec_cable_dev_type = {\n\t.name = \"typec_cable\",\n\t.groups = typec_cable_groups,\n\t.release = typec_cable_release,\n};\n\nstatic int cable_match(struct device *dev, void *data)\n{\n\treturn is_typec_cable(dev);\n}\n\n \nstruct typec_cable *typec_cable_get(struct typec_port *port)\n{\n\tstruct device *dev;\n\n\tdev = device_find_child(&port->dev, NULL, cable_match);\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn to_typec_cable(dev);\n}\nEXPORT_SYMBOL_GPL(typec_cable_get);\n\n \nvoid typec_cable_put(struct typec_cable *cable)\n{\n\tput_device(&cable->dev);\n}\nEXPORT_SYMBOL_GPL(typec_cable_put);\n\n \nint typec_cable_is_active(struct typec_cable *cable)\n{\n\treturn cable->active;\n}\nEXPORT_SYMBOL_GPL(typec_cable_is_active);\n\n \nint typec_cable_set_identity(struct typec_cable *cable)\n{\n\tif (!cable->identity)\n\t\treturn -EINVAL;\n\n\ttypec_report_identity(&cable->dev);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_cable_set_identity);\n\n \nstruct typec_cable *typec_register_cable(struct typec_port *port,\n\t\t\t\t\t struct typec_cable_desc *desc)\n{\n\tstruct typec_cable *cable;\n\tint ret;\n\n\tcable = kzalloc(sizeof(*cable), GFP_KERNEL);\n\tif (!cable)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcable->type = desc->type;\n\tcable->active = desc->active;\n\tcable->pd_revision = desc->pd_revision;\n\n\tif (desc->identity) {\n\t\t \n\t\tcable->dev.groups = usb_pd_id_groups;\n\t\tcable->identity = desc->identity;\n\t}\n\n\tcable->dev.class = &typec_class;\n\tcable->dev.parent = &port->dev;\n\tcable->dev.type = &typec_cable_dev_type;\n\tdev_set_name(&cable->dev, \"%s-cable\", dev_name(&port->dev));\n\n\tret = device_register(&cable->dev);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to register cable (%d)\\n\", ret);\n\t\tput_device(&cable->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn cable;\n}\nEXPORT_SYMBOL_GPL(typec_register_cable);\n\n \nvoid typec_unregister_cable(struct typec_cable *cable)\n{\n\tif (!IS_ERR_OR_NULL(cable))\n\t\tdevice_unregister(&cable->dev);\n}\nEXPORT_SYMBOL_GPL(typec_unregister_cable);\n\n \n \n\n \nint typec_port_set_usb_power_delivery(struct typec_port *port, struct usb_power_delivery *pd)\n{\n\tint ret;\n\n\tif (IS_ERR_OR_NULL(port) || port->pd == pd)\n\t\treturn 0;\n\n\tif (pd) {\n\t\tret = usb_power_delivery_link_device(pd, &port->dev);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\tusb_power_delivery_unlink_device(port->pd, &port->dev);\n\t}\n\n\tport->pd = pd;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_port_set_usb_power_delivery);\n\nstatic ssize_t select_usb_power_delivery_store(struct device *dev,\n\t\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t\t       const char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tstruct usb_power_delivery *pd;\n\n\tif (!port->ops || !port->ops->pd_set)\n\t\treturn -EOPNOTSUPP;\n\n\tpd = usb_power_delivery_find(buf);\n\tif (!pd)\n\t\treturn -EINVAL;\n\n\treturn port->ops->pd_set(port, pd);\n}\n\nstatic ssize_t select_usb_power_delivery_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tstruct usb_power_delivery **pds;\n\tint i, ret = 0;\n\n\tif (!port->ops || !port->ops->pd_get)\n\t\treturn -EOPNOTSUPP;\n\n\tpds = port->ops->pd_get(port);\n\tif (!pds)\n\t\treturn 0;\n\n\tfor (i = 0; pds[i]; i++) {\n\t\tif (pds[i] == port->pd)\n\t\t\tret += sysfs_emit_at(buf, ret, \"[%s] \", dev_name(&pds[i]->dev));\n\t\telse\n\t\t\tret += sysfs_emit_at(buf, ret, \"%s \", dev_name(&pds[i]->dev));\n\t}\n\n\tbuf[ret - 1] = '\\n';\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(select_usb_power_delivery);\n\nstatic struct attribute *port_attrs[] = {\n\t&dev_attr_select_usb_power_delivery.attr,\n\tNULL\n};\n\nstatic umode_t port_attr_is_visible(struct kobject *kobj, struct attribute *attr, int n)\n{\n\tstruct typec_port *port = to_typec_port(kobj_to_dev(kobj));\n\n\tif (!port->pd || !port->ops || !port->ops->pd_get)\n\t\treturn 0;\n\tif (!port->ops->pd_set)\n\t\treturn 0444;\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group pd_group = {\n\t.is_visible = port_attr_is_visible,\n\t.attrs = port_attrs,\n};\n\nstatic const char * const typec_orientations[] = {\n\t[TYPEC_ORIENTATION_NONE]\t= \"unknown\",\n\t[TYPEC_ORIENTATION_NORMAL]\t= \"normal\",\n\t[TYPEC_ORIENTATION_REVERSE]\t= \"reverse\",\n};\n\nstatic const char * const typec_roles[] = {\n\t[TYPEC_SINK]\t= \"sink\",\n\t[TYPEC_SOURCE]\t= \"source\",\n};\n\nstatic const char * const typec_data_roles[] = {\n\t[TYPEC_DEVICE]\t= \"device\",\n\t[TYPEC_HOST]\t= \"host\",\n};\n\nstatic const char * const typec_port_power_roles[] = {\n\t[TYPEC_PORT_SRC] = \"source\",\n\t[TYPEC_PORT_SNK] = \"sink\",\n\t[TYPEC_PORT_DRP] = \"dual\",\n};\n\nstatic const char * const typec_port_data_roles[] = {\n\t[TYPEC_PORT_DFP] = \"host\",\n\t[TYPEC_PORT_UFP] = \"device\",\n\t[TYPEC_PORT_DRD] = \"dual\",\n};\n\nstatic const char * const typec_port_types_drp[] = {\n\t[TYPEC_PORT_SRC] = \"dual [source] sink\",\n\t[TYPEC_PORT_SNK] = \"dual source [sink]\",\n\t[TYPEC_PORT_DRP] = \"[dual] source sink\",\n};\n\nstatic ssize_t\npreferred_role_store(struct device *dev, struct device_attribute *attr,\n\t\t     const char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tint role;\n\tint ret;\n\n\tif (port->cap->type != TYPEC_PORT_DRP) {\n\t\tdev_dbg(dev, \"Preferred role only supported with DRP ports\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!port->ops || !port->ops->try_role) {\n\t\tdev_dbg(dev, \"Setting preferred role not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\trole = sysfs_match_string(typec_roles, buf);\n\tif (role < 0) {\n\t\tif (sysfs_streq(buf, \"none\"))\n\t\t\trole = TYPEC_NO_PREFERRED_ROLE;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tret = port->ops->try_role(port, role);\n\tif (ret)\n\t\treturn ret;\n\n\tport->prefer_role = role;\n\treturn size;\n}\n\nstatic ssize_t\npreferred_role_show(struct device *dev, struct device_attribute *attr,\n\t\t    char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\tif (port->cap->type != TYPEC_PORT_DRP)\n\t\treturn 0;\n\n\tif (port->prefer_role < 0)\n\t\treturn 0;\n\n\treturn sprintf(buf, \"%s\\n\", typec_roles[port->prefer_role]);\n}\nstatic DEVICE_ATTR_RW(preferred_role);\n\nstatic ssize_t data_role_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tint ret;\n\n\tif (!port->ops || !port->ops->dr_set) {\n\t\tdev_dbg(dev, \"data role swapping not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = sysfs_match_string(typec_data_roles, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&port->port_type_lock);\n\tif (port->cap->data != TYPEC_PORT_DRD) {\n\t\tret = -EOPNOTSUPP;\n\t\tgoto unlock_and_ret;\n\t}\n\n\tret = port->ops->dr_set(port, ret);\n\tif (ret)\n\t\tgoto unlock_and_ret;\n\n\tret = size;\nunlock_and_ret:\n\tmutex_unlock(&port->port_type_lock);\n\treturn ret;\n}\n\nstatic ssize_t data_role_show(struct device *dev,\n\t\t\t      struct device_attribute *attr, char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\tif (port->cap->data == TYPEC_PORT_DRD)\n\t\treturn sprintf(buf, \"%s\\n\", port->data_role == TYPEC_HOST ?\n\t\t\t       \"[host] device\" : \"host [device]\");\n\n\treturn sprintf(buf, \"[%s]\\n\", typec_data_roles[port->data_role]);\n}\nstatic DEVICE_ATTR_RW(data_role);\n\nstatic ssize_t power_role_store(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tconst char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tint ret;\n\n\tif (!port->ops || !port->ops->pr_set) {\n\t\tdev_dbg(dev, \"power role swapping not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (port->pwr_opmode != TYPEC_PWR_MODE_PD) {\n\t\tdev_dbg(dev, \"partner unable to swap power role\\n\");\n\t\treturn -EIO;\n\t}\n\n\tret = sysfs_match_string(typec_roles, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmutex_lock(&port->port_type_lock);\n\tif (port->port_type != TYPEC_PORT_DRP) {\n\t\tdev_dbg(dev, \"port type fixed at \\\"%s\\\"\",\n\t\t\t     typec_port_power_roles[port->port_type]);\n\t\tret = -EOPNOTSUPP;\n\t\tgoto unlock_and_ret;\n\t}\n\n\tret = port->ops->pr_set(port, ret);\n\tif (ret)\n\t\tgoto unlock_and_ret;\n\n\tret = size;\nunlock_and_ret:\n\tmutex_unlock(&port->port_type_lock);\n\treturn ret;\n}\n\nstatic ssize_t power_role_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\tif (port->cap->type == TYPEC_PORT_DRP)\n\t\treturn sprintf(buf, \"%s\\n\", port->pwr_role == TYPEC_SOURCE ?\n\t\t\t       \"[source] sink\" : \"source [sink]\");\n\n\treturn sprintf(buf, \"[%s]\\n\", typec_roles[port->pwr_role]);\n}\nstatic DEVICE_ATTR_RW(power_role);\n\nstatic ssize_t\nport_type_store(struct device *dev, struct device_attribute *attr,\n\t\t\tconst char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tint ret;\n\tenum typec_port_type type;\n\n\tif (port->cap->type != TYPEC_PORT_DRP ||\n\t    !port->ops || !port->ops->port_type_set) {\n\t\tdev_dbg(dev, \"changing port type not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = sysfs_match_string(typec_port_power_roles, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttype = ret;\n\tmutex_lock(&port->port_type_lock);\n\n\tif (port->port_type == type) {\n\t\tret = size;\n\t\tgoto unlock_and_ret;\n\t}\n\n\tret = port->ops->port_type_set(port, type);\n\tif (ret)\n\t\tgoto unlock_and_ret;\n\n\tport->port_type = type;\n\tret = size;\n\nunlock_and_ret:\n\tmutex_unlock(&port->port_type_lock);\n\treturn ret;\n}\n\nstatic ssize_t\nport_type_show(struct device *dev, struct device_attribute *attr,\n\t\tchar *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\tif (port->cap->type == TYPEC_PORT_DRP)\n\t\treturn sprintf(buf, \"%s\\n\",\n\t\t\t       typec_port_types_drp[port->port_type]);\n\n\treturn sprintf(buf, \"[%s]\\n\", typec_port_power_roles[port->cap->type]);\n}\nstatic DEVICE_ATTR_RW(port_type);\n\nstatic const char * const typec_pwr_opmodes[] = {\n\t[TYPEC_PWR_MODE_USB]\t= \"default\",\n\t[TYPEC_PWR_MODE_1_5A]\t= \"1.5A\",\n\t[TYPEC_PWR_MODE_3_0A]\t= \"3.0A\",\n\t[TYPEC_PWR_MODE_PD]\t= \"usb_power_delivery\",\n};\n\nstatic ssize_t power_operation_mode_show(struct device *dev,\n\t\t\t\t\t struct device_attribute *attr,\n\t\t\t\t\t char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\", typec_pwr_opmodes[port->pwr_opmode]);\n}\nstatic DEVICE_ATTR_RO(power_operation_mode);\n\nstatic ssize_t vconn_source_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tbool source;\n\tint ret;\n\n\tif (!port->cap->pd_revision) {\n\t\tdev_dbg(dev, \"VCONN swap depends on USB Power Delivery\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tif (!port->ops || !port->ops->vconn_set) {\n\t\tdev_dbg(dev, \"VCONN swapping not supported\\n\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tret = kstrtobool(buf, &source);\n\tif (ret)\n\t\treturn ret;\n\n\tret = port->ops->vconn_set(port, (enum typec_role)source);\n\tif (ret)\n\t\treturn ret;\n\n\treturn size;\n}\n\nstatic ssize_t vconn_source_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\",\n\t\t       port->vconn_role == TYPEC_SOURCE ? \"yes\" : \"no\");\n}\nstatic DEVICE_ATTR_RW(vconn_source);\n\nstatic ssize_t supported_accessory_modes_show(struct device *dev,\n\t\t\t\t\t      struct device_attribute *attr,\n\t\t\t\t\t      char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tssize_t ret = 0;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->cap->accessory); i++) {\n\t\tif (port->cap->accessory[i])\n\t\t\tret += sprintf(buf + ret, \"%s \",\n\t\t\t       typec_accessory_modes[port->cap->accessory[i]]);\n\t}\n\n\tif (!ret)\n\t\treturn sprintf(buf, \"none\\n\");\n\n\tbuf[ret - 1] = '\\n';\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_RO(supported_accessory_modes);\n\nstatic ssize_t usb_typec_revision_show(struct device *dev,\n\t\t\t\t       struct device_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\tu16 rev = port->cap->revision;\n\n\treturn sprintf(buf, \"%d.%d\\n\", (rev >> 8) & 0xff, (rev >> 4) & 0xf);\n}\nstatic DEVICE_ATTR_RO(usb_typec_revision);\n\nstatic ssize_t usb_power_delivery_revision_show(struct device *dev,\n\t\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\t\tchar *buf)\n{\n\tu16 rev = 0;\n\n\tif (is_typec_partner(dev)) {\n\t\tstruct typec_partner *partner = to_typec_partner(dev);\n\n\t\trev = partner->pd_revision;\n\t} else if (is_typec_cable(dev)) {\n\t\tstruct typec_cable *cable = to_typec_cable(dev);\n\n\t\trev = cable->pd_revision;\n\t} else if (is_typec_port(dev)) {\n\t\tstruct typec_port *p = to_typec_port(dev);\n\n\t\trev = p->cap->pd_revision;\n\t}\n\treturn sysfs_emit(buf, \"%d.%d\\n\", (rev >> 8) & 0xff, (rev >> 4) & 0xf);\n}\n\nstatic ssize_t orientation_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\treturn sprintf(buf, \"%s\\n\", typec_orientations[port->orientation]);\n}\nstatic DEVICE_ATTR_RO(orientation);\n\nstatic struct attribute *typec_attrs[] = {\n\t&dev_attr_data_role.attr,\n\t&dev_attr_power_operation_mode.attr,\n\t&dev_attr_power_role.attr,\n\t&dev_attr_preferred_role.attr,\n\t&dev_attr_supported_accessory_modes.attr,\n\t&dev_attr_usb_power_delivery_revision.attr,\n\t&dev_attr_usb_typec_revision.attr,\n\t&dev_attr_vconn_source.attr,\n\t&dev_attr_port_type.attr,\n\t&dev_attr_orientation.attr,\n\tNULL,\n};\n\nstatic umode_t typec_attr_is_visible(struct kobject *kobj,\n\t\t\t\t     struct attribute *attr, int n)\n{\n\tstruct typec_port *port = to_typec_port(kobj_to_dev(kobj));\n\n\tif (attr == &dev_attr_data_role.attr) {\n\t\tif (port->cap->data != TYPEC_PORT_DRD ||\n\t\t    !port->ops || !port->ops->dr_set)\n\t\t\treturn 0444;\n\t} else if (attr == &dev_attr_power_role.attr) {\n\t\tif (port->cap->type != TYPEC_PORT_DRP ||\n\t\t    !port->ops || !port->ops->pr_set)\n\t\t\treturn 0444;\n\t} else if (attr == &dev_attr_vconn_source.attr) {\n\t\tif (!port->cap->pd_revision ||\n\t\t    !port->ops || !port->ops->vconn_set)\n\t\t\treturn 0444;\n\t} else if (attr == &dev_attr_preferred_role.attr) {\n\t\tif (port->cap->type != TYPEC_PORT_DRP ||\n\t\t    !port->ops || !port->ops->try_role)\n\t\t\treturn 0444;\n\t} else if (attr == &dev_attr_port_type.attr) {\n\t\tif (!port->ops || !port->ops->port_type_set)\n\t\t\treturn 0;\n\t\tif (port->cap->type != TYPEC_PORT_DRP)\n\t\t\treturn 0444;\n\t} else if (attr == &dev_attr_orientation.attr) {\n\t\tif (port->cap->orientation_aware)\n\t\t\treturn 0444;\n\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group typec_group = {\n\t.is_visible = typec_attr_is_visible,\n\t.attrs = typec_attrs,\n};\n\nstatic const struct attribute_group *typec_groups[] = {\n\t&typec_group,\n\t&pd_group,\n\tNULL\n};\n\nstatic int typec_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tint ret;\n\n\tret = add_uevent_var(env, \"TYPEC_PORT=%s\", dev_name(dev));\n\tif (ret)\n\t\tdev_err(dev, \"failed to add uevent TYPEC_PORT\\n\");\n\n\treturn ret;\n}\n\nstatic void typec_release(struct device *dev)\n{\n\tstruct typec_port *port = to_typec_port(dev);\n\n\tida_simple_remove(&typec_index_ida, port->id);\n\tida_destroy(&port->mode_ids);\n\ttypec_switch_put(port->sw);\n\ttypec_mux_put(port->mux);\n\ttypec_retimer_put(port->retimer);\n\tkfree(port->cap);\n\tkfree(port);\n}\n\nconst struct device_type typec_port_dev_type = {\n\t.name = \"typec_port\",\n\t.groups = typec_groups,\n\t.uevent = typec_uevent,\n\t.release = typec_release,\n};\n\n \n \n\nstatic int partner_match(struct device *dev, void *data)\n{\n\treturn is_typec_partner(dev);\n}\n\n \nvoid typec_set_data_role(struct typec_port *port, enum typec_data_role role)\n{\n\tstruct device *partner_dev;\n\n\tif (port->data_role == role)\n\t\treturn;\n\n\tport->data_role = role;\n\tsysfs_notify(&port->dev.kobj, NULL, \"data_role\");\n\tkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\n\n\tpartner_dev = device_find_child(&port->dev, NULL, partner_match);\n\tif (!partner_dev)\n\t\treturn;\n\n\tif (to_typec_partner(partner_dev)->identity)\n\t\ttypec_product_type_notify(partner_dev);\n\n\tput_device(partner_dev);\n}\nEXPORT_SYMBOL_GPL(typec_set_data_role);\n\n \nvoid typec_set_pwr_role(struct typec_port *port, enum typec_role role)\n{\n\tif (port->pwr_role == role)\n\t\treturn;\n\n\tport->pwr_role = role;\n\tsysfs_notify(&port->dev.kobj, NULL, \"power_role\");\n\tkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\n}\nEXPORT_SYMBOL_GPL(typec_set_pwr_role);\n\n \nvoid typec_set_vconn_role(struct typec_port *port, enum typec_role role)\n{\n\tif (port->vconn_role == role)\n\t\treturn;\n\n\tport->vconn_role = role;\n\tsysfs_notify(&port->dev.kobj, NULL, \"vconn_source\");\n\tkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\n}\nEXPORT_SYMBOL_GPL(typec_set_vconn_role);\n\n \nvoid typec_set_pwr_opmode(struct typec_port *port,\n\t\t\t  enum typec_pwr_opmode opmode)\n{\n\tstruct device *partner_dev;\n\n\tif (port->pwr_opmode == opmode)\n\t\treturn;\n\n\tport->pwr_opmode = opmode;\n\tsysfs_notify(&port->dev.kobj, NULL, \"power_operation_mode\");\n\tkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\n\n\tpartner_dev = device_find_child(&port->dev, NULL, partner_match);\n\tif (partner_dev) {\n\t\tstruct typec_partner *partner = to_typec_partner(partner_dev);\n\n\t\tif (opmode == TYPEC_PWR_MODE_PD && !partner->usb_pd) {\n\t\t\tpartner->usb_pd = 1;\n\t\t\tsysfs_notify(&partner_dev->kobj, NULL,\n\t\t\t\t     \"supports_usb_power_delivery\");\n\t\t\tkobject_uevent(&partner_dev->kobj, KOBJ_CHANGE);\n\t\t}\n\t\tput_device(partner_dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(typec_set_pwr_opmode);\n\n \nint typec_find_pwr_opmode(const char *name)\n{\n\treturn match_string(typec_pwr_opmodes,\n\t\t\t    ARRAY_SIZE(typec_pwr_opmodes), name);\n}\nEXPORT_SYMBOL_GPL(typec_find_pwr_opmode);\n\n \nint typec_find_orientation(const char *name)\n{\n\treturn match_string(typec_orientations, ARRAY_SIZE(typec_orientations),\n\t\t\t    name);\n}\nEXPORT_SYMBOL_GPL(typec_find_orientation);\n\n \nint typec_find_port_power_role(const char *name)\n{\n\treturn match_string(typec_port_power_roles,\n\t\t\t    ARRAY_SIZE(typec_port_power_roles), name);\n}\nEXPORT_SYMBOL_GPL(typec_find_port_power_role);\n\n \nint typec_find_power_role(const char *name)\n{\n\treturn match_string(typec_roles, ARRAY_SIZE(typec_roles), name);\n}\nEXPORT_SYMBOL_GPL(typec_find_power_role);\n\n \nint typec_find_port_data_role(const char *name)\n{\n\treturn match_string(typec_port_data_roles,\n\t\t\t    ARRAY_SIZE(typec_port_data_roles), name);\n}\nEXPORT_SYMBOL_GPL(typec_find_port_data_role);\n\n \n \n\n \nint typec_set_orientation(struct typec_port *port,\n\t\t\t  enum typec_orientation orientation)\n{\n\tint ret;\n\n\tret = typec_switch_set(port->sw, orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tport->orientation = orientation;\n\tsysfs_notify(&port->dev.kobj, NULL, \"orientation\");\n\tkobject_uevent(&port->dev.kobj, KOBJ_CHANGE);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_set_orientation);\n\n \nenum typec_orientation typec_get_orientation(struct typec_port *port)\n{\n\treturn port->orientation;\n}\nEXPORT_SYMBOL_GPL(typec_get_orientation);\n\n \nint typec_set_mode(struct typec_port *port, int mode)\n{\n\tstruct typec_mux_state state = { };\n\n\tstate.mode = mode;\n\n\treturn typec_mux_set(port->mux, &state);\n}\nEXPORT_SYMBOL_GPL(typec_set_mode);\n\n \n\n \nint typec_get_negotiated_svdm_version(struct typec_port *port)\n{\n\tenum usb_pd_svdm_ver svdm_version;\n\tstruct device *partner_dev;\n\n\tpartner_dev = device_find_child(&port->dev, NULL, partner_match);\n\tif (!partner_dev)\n\t\treturn -ENODEV;\n\n\tsvdm_version = to_typec_partner(partner_dev)->svdm_version;\n\tput_device(partner_dev);\n\n\treturn svdm_version;\n}\nEXPORT_SYMBOL_GPL(typec_get_negotiated_svdm_version);\n\n \nvoid *typec_get_drvdata(struct typec_port *port)\n{\n\treturn dev_get_drvdata(&port->dev);\n}\nEXPORT_SYMBOL_GPL(typec_get_drvdata);\n\nint typec_get_fw_cap(struct typec_capability *cap,\n\t\t     struct fwnode_handle *fwnode)\n{\n\tconst char *cap_str;\n\tint ret;\n\n\tcap->fwnode = fwnode;\n\n\tret = fwnode_property_read_string(fwnode, \"power-role\", &cap_str);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = typec_find_port_power_role(cap_str);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->type = ret;\n\n\t \n\tret = fwnode_property_read_string(fwnode, \"data-role\", &cap_str);\n\tif (ret == 0) {\n\t\tret = typec_find_port_data_role(cap_str);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tcap->data = ret;\n\t}\n\n\t \n\tif (cap->type == TYPEC_PORT_DRP) {\n\t\tcap->prefer_role = TYPEC_NO_PREFERRED_ROLE;\n\n\t\tret = fwnode_property_read_string(fwnode, \"try-power-role\", &cap_str);\n\t\tif (ret == 0) {\n\t\t\tret = typec_find_power_role(cap_str);\n\t\t\tif (ret < 0)\n\t\t\t\treturn ret;\n\t\t\tcap->prefer_role = ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(typec_get_fw_cap);\n\n \nstruct typec_altmode *\ntypec_port_register_altmode(struct typec_port *port,\n\t\t\t    const struct typec_altmode_desc *desc)\n{\n\tstruct typec_altmode *adev;\n\tstruct typec_mux *mux;\n\tstruct typec_retimer *retimer;\n\n\tmux = typec_mux_get(&port->dev);\n\tif (IS_ERR(mux))\n\t\treturn ERR_CAST(mux);\n\n\tretimer = typec_retimer_get(&port->dev);\n\tif (IS_ERR(retimer)) {\n\t\ttypec_mux_put(mux);\n\t\treturn ERR_CAST(retimer);\n\t}\n\n\tadev = typec_register_altmode(&port->dev, desc);\n\tif (IS_ERR(adev)) {\n\t\ttypec_retimer_put(retimer);\n\t\ttypec_mux_put(mux);\n\t} else {\n\t\tto_altmode(adev)->mux = mux;\n\t\tto_altmode(adev)->retimer = retimer;\n\t}\n\n\treturn adev;\n}\nEXPORT_SYMBOL_GPL(typec_port_register_altmode);\n\nvoid typec_port_register_altmodes(struct typec_port *port,\n\tconst struct typec_altmode_ops *ops, void *drvdata,\n\tstruct typec_altmode **altmodes, size_t n)\n{\n\tstruct fwnode_handle *altmodes_node, *child;\n\tstruct typec_altmode_desc desc;\n\tstruct typec_altmode *alt;\n\tsize_t index = 0;\n\tu32 svid, vdo;\n\tint ret;\n\n\taltmodes_node = device_get_named_child_node(&port->dev, \"altmodes\");\n\tif (!altmodes_node)\n\t\treturn;  \n\n\tfwnode_for_each_child_node(altmodes_node, child) {\n\t\tret = fwnode_property_read_u32(child, \"svid\", &svid);\n\t\tif (ret) {\n\t\t\tdev_err(&port->dev, \"Error reading svid for altmode %s\\n\",\n\t\t\t\tfwnode_get_name(child));\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = fwnode_property_read_u32(child, \"vdo\", &vdo);\n\t\tif (ret) {\n\t\t\tdev_err(&port->dev, \"Error reading vdo for altmode %s\\n\",\n\t\t\t\tfwnode_get_name(child));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (index >= n) {\n\t\t\tdev_err(&port->dev, \"Error not enough space for altmode %s\\n\",\n\t\t\t\tfwnode_get_name(child));\n\t\t\tcontinue;\n\t\t}\n\n\t\tdesc.svid = svid;\n\t\tdesc.vdo = vdo;\n\t\tdesc.mode = index + 1;\n\t\talt = typec_port_register_altmode(port, &desc);\n\t\tif (IS_ERR(alt)) {\n\t\t\tdev_err(&port->dev, \"Error registering altmode %s\\n\",\n\t\t\t\tfwnode_get_name(child));\n\t\t\tcontinue;\n\t\t}\n\n\t\talt->ops = ops;\n\t\ttypec_altmode_set_drvdata(alt, drvdata);\n\t\taltmodes[index] = alt;\n\t\tindex++;\n\t}\n}\nEXPORT_SYMBOL_GPL(typec_port_register_altmodes);\n\n \nstruct typec_port *typec_register_port(struct device *parent,\n\t\t\t\t       const struct typec_capability *cap)\n{\n\tstruct typec_port *port;\n\tint ret;\n\tint id;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tid = ida_simple_get(&typec_index_ida, 0, 0, GFP_KERNEL);\n\tif (id < 0) {\n\t\tkfree(port);\n\t\treturn ERR_PTR(id);\n\t}\n\n\tswitch (cap->type) {\n\tcase TYPEC_PORT_SRC:\n\t\tport->pwr_role = TYPEC_SOURCE;\n\t\tport->vconn_role = TYPEC_SOURCE;\n\t\tbreak;\n\tcase TYPEC_PORT_SNK:\n\t\tport->pwr_role = TYPEC_SINK;\n\t\tport->vconn_role = TYPEC_SINK;\n\t\tbreak;\n\tcase TYPEC_PORT_DRP:\n\t\tif (cap->prefer_role != TYPEC_NO_PREFERRED_ROLE)\n\t\t\tport->pwr_role = cap->prefer_role;\n\t\telse\n\t\t\tport->pwr_role = TYPEC_SINK;\n\t\tbreak;\n\t}\n\n\tswitch (cap->data) {\n\tcase TYPEC_PORT_DFP:\n\t\tport->data_role = TYPEC_HOST;\n\t\tbreak;\n\tcase TYPEC_PORT_UFP:\n\t\tport->data_role = TYPEC_DEVICE;\n\t\tbreak;\n\tcase TYPEC_PORT_DRD:\n\t\tif (cap->prefer_role == TYPEC_SOURCE)\n\t\t\tport->data_role = TYPEC_HOST;\n\t\telse\n\t\t\tport->data_role = TYPEC_DEVICE;\n\t\tbreak;\n\t}\n\n\tida_init(&port->mode_ids);\n\tmutex_init(&port->port_type_lock);\n\n\tport->id = id;\n\tport->ops = cap->ops;\n\tport->port_type = cap->type;\n\tport->prefer_role = cap->prefer_role;\n\n\tdevice_initialize(&port->dev);\n\tport->dev.class = &typec_class;\n\tport->dev.parent = parent;\n\tport->dev.fwnode = cap->fwnode;\n\tport->dev.type = &typec_port_dev_type;\n\tdev_set_name(&port->dev, \"port%d\", id);\n\tdev_set_drvdata(&port->dev, cap->driver_data);\n\n\tport->cap = kmemdup(cap, sizeof(*cap), GFP_KERNEL);\n\tif (!port->cap) {\n\t\tput_device(&port->dev);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tport->sw = typec_switch_get(&port->dev);\n\tif (IS_ERR(port->sw)) {\n\t\tret = PTR_ERR(port->sw);\n\t\tput_device(&port->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tport->mux = typec_mux_get(&port->dev);\n\tif (IS_ERR(port->mux)) {\n\t\tret = PTR_ERR(port->mux);\n\t\tput_device(&port->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tport->retimer = typec_retimer_get(&port->dev);\n\tif (IS_ERR(port->retimer)) {\n\t\tret = PTR_ERR(port->retimer);\n\t\tput_device(&port->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tport->pd = cap->pd;\n\n\tret = device_add(&port->dev);\n\tif (ret) {\n\t\tdev_err(parent, \"failed to register port (%d)\\n\", ret);\n\t\tput_device(&port->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = usb_power_delivery_link_device(port->pd, &port->dev);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to link pd\\n\");\n\t\tdevice_unregister(&port->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tret = typec_link_ports(port);\n\tif (ret)\n\t\tdev_warn(&port->dev, \"failed to create symlinks (%d)\\n\", ret);\n\n\treturn port;\n}\nEXPORT_SYMBOL_GPL(typec_register_port);\n\n \nvoid typec_unregister_port(struct typec_port *port)\n{\n\tif (!IS_ERR_OR_NULL(port)) {\n\t\ttypec_unlink_ports(port);\n\t\ttypec_port_set_usb_power_delivery(port, NULL);\n\t\tdevice_unregister(&port->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(typec_unregister_port);\n\nstatic int __init typec_init(void)\n{\n\tint ret;\n\n\tret = bus_register(&typec_bus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = class_register(&typec_mux_class);\n\tif (ret)\n\t\tgoto err_unregister_bus;\n\n\tret = class_register(&retimer_class);\n\tif (ret)\n\t\tgoto err_unregister_mux_class;\n\n\tret = class_register(&typec_class);\n\tif (ret)\n\t\tgoto err_unregister_retimer_class;\n\n\tret = usb_power_delivery_init();\n\tif (ret)\n\t\tgoto err_unregister_class;\n\n\treturn 0;\n\nerr_unregister_class:\n\tclass_unregister(&typec_class);\n\nerr_unregister_retimer_class:\n\tclass_unregister(&retimer_class);\n\nerr_unregister_mux_class:\n\tclass_unregister(&typec_mux_class);\n\nerr_unregister_bus:\n\tbus_unregister(&typec_bus);\n\n\treturn ret;\n}\nsubsys_initcall(typec_init);\n\nstatic void __exit typec_exit(void)\n{\n\tusb_power_delivery_exit();\n\tclass_unregister(&typec_class);\n\tida_destroy(&typec_index_ida);\n\tbus_unregister(&typec_bus);\n\tclass_unregister(&typec_mux_class);\n\tclass_unregister(&retimer_class);\n}\nmodule_exit(typec_exit);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"USB Type-C Connector Class\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}