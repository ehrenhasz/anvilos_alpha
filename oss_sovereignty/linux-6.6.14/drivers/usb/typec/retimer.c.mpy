{
  "module_name": "retimer.c",
  "hash_id": "0c129f1e01af34063e0d44ff48b9b3161f70fa79505aefe9efb3395509aa8d24",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/retimer.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/slab.h>\n\n#include \"class.h\"\n#include \"retimer.h\"\n\nstatic int retimer_fwnode_match(struct device *dev, const void *fwnode)\n{\n\treturn is_typec_retimer(dev) && device_match_fwnode(dev, fwnode);\n}\n\nstatic void *typec_retimer_match(const struct fwnode_handle *fwnode, const char *id, void *data)\n{\n\tstruct device *dev;\n\n\tif (id && !fwnode_property_present(fwnode, id))\n\t\treturn NULL;\n\n\tdev = class_find_device(&retimer_class, NULL, fwnode,\n\t\t\t\tretimer_fwnode_match);\n\n\treturn dev ? to_typec_retimer(dev) : ERR_PTR(-EPROBE_DEFER);\n}\n\n \nstruct typec_retimer *fwnode_typec_retimer_get(struct fwnode_handle *fwnode)\n{\n\tstruct typec_retimer *retimer;\n\n\tretimer = fwnode_connection_find_match(fwnode, \"retimer-switch\", NULL, typec_retimer_match);\n\tif (!IS_ERR_OR_NULL(retimer))\n\t\tWARN_ON(!try_module_get(retimer->dev.parent->driver->owner));\n\n\treturn retimer;\n}\nEXPORT_SYMBOL_GPL(fwnode_typec_retimer_get);\n\n \nvoid typec_retimer_put(struct typec_retimer *retimer)\n{\n\tif (!IS_ERR_OR_NULL(retimer)) {\n\t\tmodule_put(retimer->dev.parent->driver->owner);\n\t\tput_device(&retimer->dev);\n\t}\n}\nEXPORT_SYMBOL_GPL(typec_retimer_put);\n\nint typec_retimer_set(struct typec_retimer *retimer, struct typec_retimer_state *state)\n{\n\tif (IS_ERR_OR_NULL(retimer))\n\t\treturn 0;\n\n\treturn retimer->set(retimer, state);\n}\nEXPORT_SYMBOL_GPL(typec_retimer_set);\n\nstatic void typec_retimer_release(struct device *dev)\n{\n\tkfree(to_typec_retimer(dev));\n}\n\nconst struct device_type typec_retimer_dev_type = {\n\t.name = \"typec_retimer\",\n\t.release = typec_retimer_release,\n};\n\n \nstruct typec_retimer *\ntypec_retimer_register(struct device *parent, const struct typec_retimer_desc *desc)\n{\n\tstruct typec_retimer *retimer;\n\tint ret;\n\n\tif (!desc || !desc->set)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tretimer = kzalloc(sizeof(*retimer), GFP_KERNEL);\n\tif (!retimer)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tretimer->set = desc->set;\n\n\tdevice_initialize(&retimer->dev);\n\tretimer->dev.parent = parent;\n\tretimer->dev.fwnode = desc->fwnode;\n\tretimer->dev.class = &retimer_class;\n\tretimer->dev.type = &typec_retimer_dev_type;\n\tretimer->dev.driver_data = desc->drvdata;\n\tdev_set_name(&retimer->dev, \"%s-retimer\",\n\t\t     desc->name ? desc->name : dev_name(parent));\n\n\tret = device_add(&retimer->dev);\n\tif (ret) {\n\t\tdev_err(parent, \"failed to register retimer (%d)\\n\", ret);\n\t\tput_device(&retimer->dev);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn retimer;\n}\nEXPORT_SYMBOL_GPL(typec_retimer_register);\n\n \nvoid typec_retimer_unregister(struct typec_retimer *retimer)\n{\n\tif (!IS_ERR_OR_NULL(retimer))\n\t\tdevice_unregister(&retimer->dev);\n}\nEXPORT_SYMBOL_GPL(typec_retimer_unregister);\n\nvoid *typec_retimer_get_drvdata(struct typec_retimer *retimer)\n{\n\treturn dev_get_drvdata(&retimer->dev);\n}\nEXPORT_SYMBOL_GPL(typec_retimer_get_drvdata);\n\nstruct class retimer_class = {\n\t.name = \"retimer\",\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}