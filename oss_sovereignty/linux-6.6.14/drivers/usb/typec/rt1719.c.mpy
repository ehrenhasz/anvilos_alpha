{
  "module_name": "rt1719.c",
  "hash_id": "1c5cd9da416aee84713458a425d5f0190f76432f5f8195c21f04d76b94372ff6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/rt1719.c",
  "human_readable_source": "\n\n#include <linux/bitfield.h>\n#include <linux/completion.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/power_supply.h>\n#include <linux/regmap.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/role.h>\n#include <linux/usb/typec.h>\n\n#define RT1719_REG_TXCTRL1\t0x03\n#define RT1719_REG_TXCTRL2\t0x04\n#define RT1719_REG_POLICYINFO\t0x0E\n#define RT1719_REG_SRCPDO1\t0x11\n#define RT1719_REG_MASKS\t0x2D\n#define RT1719_REG_EVENTS\t0x33\n#define RT1719_REG_STATS\t0x37\n#define RT1719_REG_PSELINFO\t0x3C\n#define RT1719_REG_USBSETINFO\t0x3E\n#define RT1719_REG_VENID\t0x82\n\n#define RT1719_UNIQUE_PID\t0x1719\n#define RT1719_REQDRSWAP_MASK\tBIT(7)\n#define RT1719_EVALMODE_MASK\tBIT(4)\n#define RT1719_REQSRCPDO_MASK\tGENMASK(2, 0)\n#define RT1719_TXSPDOREQ_MASK\tBIT(7)\n#define RT1719_INT_DRSW_ACCEPT\tBIT(23)\n#define RT1719_INT_RX_SRCCAP\tBIT(21)\n#define RT1719_INT_VBUS_DCT\tBIT(6)\n#define RT1719_INT_VBUS_PRESENT\tBIT(5)\n#define RT1719_INT_PE_SNK_RDY\tBIT(2)\n#define RT1719_CC1_STAT\t\tGENMASK(9, 8)\n#define RT1719_CC2_STAT\t\tGENMASK(11, 10)\n#define RT1719_POLARITY_MASK\tBIT(23)\n#define RT1719_DATAROLE_MASK\tBIT(22)\n#define RT1719_PDSPECREV_MASK\tGENMASK(21, 20)\n#define RT1719_SPDOSEL_MASK\tGENMASK(18, 16)\n#define RT1719_SPDONUM_MASK\tGENMASK(15, 13)\n#define RT1719_ATTACH_VBUS\tBIT(12)\n#define RT1719_ATTACH_DBG\tBIT(10)\n#define RT1719_ATTACH_SNK\tBIT(9)\n#define RT1719_ATTACHDEV_MASK\t(RT1719_ATTACH_VBUS | RT1719_ATTACH_DBG | \\\n\t\t\t\t RT1719_ATTACH_SNK)\n#define RT1719_PE_EXP_CONTRACT\tBIT(2)\n#define RT1719_PSEL_SUPPORT\tBIT(15)\n#define RT1719_TBLSEL_MASK\tBIT(6)\n#define RT1719_LATPSEL_MASK\tGENMASK(5, 0)\n#define RT1719_USBINFO_MASK\tGENMASK(1, 0)\n#define RT1719_USB_DFPUFP\t3\n#define RT1719_MAX_SRCPDO\t7\n\nenum {\n\tSNK_PWR_OPEN = 0,\n\tSNK_PWR_DEF,\n\tSNK_PWR_1P5A,\n\tSNK_PWR_3A\n};\n\nenum {\n\tUSBPD_SPECREV_1_0 = 0,\n\tUSBPD_SPECREV_2_0,\n\tUSBPD_SPECREV_3_0\n};\n\nenum rt1719_snkcap {\n\tRT1719_SNKCAP_5V = 0,\n\tRT1719_SNKCAP_9V,\n\tRT1719_SNKCAP_12V,\n\tRT1719_SNKCAP_15V,\n\tRT1719_SNKCAP_20V,\n\tRT1719_MAX_SNKCAP\n};\n\nstruct rt1719_psel_cap {\n\tu8 lomask;\n\tu8 himask;\n\tu32 milliwatt;\n\tu32 milliamp;\n};\n\nstruct rt1719_data {\n\tstruct device *dev;\n\tstruct regmap *regmap;\n\tstruct typec_port *port;\n\tstruct usb_role_switch *role_sw;\n\tstruct power_supply *psy;\n\tstruct typec_partner *partner;\n\tstruct power_supply_desc psy_desc;\n\tstruct usb_pd_identity partner_ident;\n\tstruct typec_partner_desc partner_desc;\n\tstruct completion req_completion;\n\tenum power_supply_usb_type usb_type;\n\tbool attached;\n\tbool pd_capable;\n\tbool drswap_support;\n\tu32 voltage;\n\tu32 req_voltage;\n\tu32 max_current;\n\tu32 op_current;\n\tu32 spdos[RT1719_MAX_SRCPDO];\n\tu16 snkcaps[RT1719_MAX_SNKCAP];\n\tint spdo_num;\n\tint spdo_sel;\n\tu32 conn_info;\n\tu16 conn_stat;\n};\n\nstatic const enum power_supply_usb_type rt1719_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_PPS\n};\n\nstatic const enum power_supply_property rt1719_psy_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW\n};\n\nstatic int rt1719_read16(struct rt1719_data *data, unsigned int reg, u16 *val)\n{\n\t__le16 regval;\n\tint ret;\n\n\tret = regmap_raw_read(data->regmap, reg, &regval, sizeof(regval));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le16_to_cpu(regval);\n\treturn 0;\n}\n\nstatic int rt1719_read32(struct rt1719_data *data, unsigned int reg, u32 *val)\n{\n\t__le32 regval;\n\tint ret;\n\n\tret = regmap_raw_read(data->regmap, reg, &regval, sizeof(regval));\n\tif (ret)\n\t\treturn ret;\n\n\t*val = le32_to_cpu(regval);\n\treturn 0;\n}\n\nstatic int rt1719_write32(struct rt1719_data *data, unsigned int reg, u32 val)\n{\n\t__le32 regval = cpu_to_le32(val);\n\n\treturn regmap_raw_write(data->regmap, reg, &regval, sizeof(regval));\n}\n\nstatic enum typec_pwr_opmode rt1719_get_pwr_opmode(u32 conn, u16 stat)\n{\n\tu16 cc1, cc2, cc_stat;\n\n\tcc1 = FIELD_GET(RT1719_CC1_STAT, stat);\n\tcc2 = FIELD_GET(RT1719_CC2_STAT, stat);\n\n\tif (conn & RT1719_ATTACH_SNK) {\n\t\tif (conn & RT1719_POLARITY_MASK)\n\t\t\tcc_stat = cc2;\n\t\telse\n\t\t\tcc_stat = cc1;\n\n\t\tswitch (cc_stat) {\n\t\tcase SNK_PWR_3A:\n\t\t\treturn TYPEC_PWR_MODE_3_0A;\n\t\tcase SNK_PWR_1P5A:\n\t\t\treturn TYPEC_PWR_MODE_1_5A;\n\t\t}\n\t} else if (conn & RT1719_ATTACH_DBG) {\n\t\tif ((cc1 == SNK_PWR_1P5A && cc2 == SNK_PWR_DEF) ||\n\t\t    (cc1 == SNK_PWR_DEF && cc2 == SNK_PWR_1P5A))\n\t\t\treturn TYPEC_PWR_MODE_1_5A;\n\t\telse if ((cc1 == SNK_PWR_3A && cc2 == SNK_PWR_DEF) ||\n\t\t\t (cc1 == SNK_PWR_DEF && cc2 == SNK_PWR_3A))\n\t\t\treturn TYPEC_PWR_MODE_3_0A;\n\t}\n\n\treturn TYPEC_PWR_MODE_USB;\n}\n\nstatic enum typec_data_role rt1719_get_data_role(u32 conn)\n{\n\tif (conn & RT1719_DATAROLE_MASK)\n\t\treturn TYPEC_HOST;\n\treturn TYPEC_DEVICE;\n}\n\nstatic void rt1719_set_data_role(struct rt1719_data *data,\n\t\t\t\t enum typec_data_role data_role,\n\t\t\t\t bool attached)\n{\n\tenum usb_role usb_role = USB_ROLE_NONE;\n\n\tif (attached) {\n\t\tif (data_role == TYPEC_HOST)\n\t\t\tusb_role = USB_ROLE_HOST;\n\t\telse\n\t\t\tusb_role = USB_ROLE_DEVICE;\n\t}\n\n\tusb_role_switch_set_role(data->role_sw, usb_role);\n\ttypec_set_data_role(data->port, data_role);\n}\n\nstatic void rt1719_update_data_role(struct rt1719_data *data)\n{\n\tif (!data->attached)\n\t\treturn;\n\n\trt1719_set_data_role(data, rt1719_get_data_role(data->conn_info), true);\n}\n\nstatic void rt1719_register_partner(struct rt1719_data *data)\n{\n\tu16 spec_rev = 0;\n\n\tif (data->pd_capable) {\n\t\tu32 rev;\n\n\t\trev = FIELD_GET(RT1719_PDSPECREV_MASK, data->conn_info);\n\t\tswitch (rev) {\n\t\tcase USBPD_SPECREV_3_0:\n\t\t\tspec_rev = 0x0300;\n\t\t\tbreak;\n\t\tcase USBPD_SPECREV_2_0:\n\t\t\tspec_rev = 0x0200;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspec_rev = 0x0100;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (data->partner)\n\t\ttypec_unregister_partner(data->partner);\n\n\tmemset(&data->partner_ident, 0, sizeof(data->partner_ident));\n\tdata->partner_desc.usb_pd = data->pd_capable;\n\tdata->partner_desc.pd_revision = spec_rev;\n\n\tif (data->conn_info & RT1719_ATTACH_DBG)\n\t\tdata->partner_desc.accessory = TYPEC_ACCESSORY_DEBUG;\n\telse\n\t\tdata->partner_desc.accessory = TYPEC_ACCESSORY_NONE;\n\n\tdata->partner = typec_register_partner(data->port, &data->partner_desc);\n}\n\nstatic void rt1719_attach(struct rt1719_data *data)\n{\n\tenum typec_pwr_opmode pwr_opmode;\n\tenum typec_data_role data_role;\n\tu32 volt = 5000, curr = 500;\n\n\tif (!(data->conn_info & RT1719_ATTACHDEV_MASK))\n\t\treturn;\n\n\tpwr_opmode = rt1719_get_pwr_opmode(data->conn_info, data->conn_stat);\n\tdata_role = rt1719_get_data_role(data->conn_info);\n\n\ttypec_set_pwr_opmode(data->port, pwr_opmode);\n\trt1719_set_data_role(data, data_role, true);\n\n\tif (data->conn_info & RT1719_ATTACH_SNK)\n\t\trt1719_register_partner(data);\n\n\tif (pwr_opmode == TYPEC_PWR_MODE_3_0A)\n\t\tcurr = 3000;\n\telse if (pwr_opmode == TYPEC_PWR_MODE_1_5A)\n\t\tcurr = 1500;\n\n\tdata->voltage = volt * 1000;\n\tdata->max_current = data->op_current = curr * 1000;\n\tdata->attached = true;\n\n\tpower_supply_changed(data->psy);\n}\n\nstatic void rt1719_detach(struct rt1719_data *data)\n{\n\tif (!data->attached || (data->conn_info & RT1719_ATTACHDEV_MASK))\n\t\treturn;\n\n\ttypec_unregister_partner(data->partner);\n\tdata->partner = NULL;\n\n\ttypec_set_pwr_opmode(data->port, TYPEC_PWR_MODE_USB);\n\trt1719_set_data_role(data, TYPEC_DEVICE, false);\n\n\tmemset32(data->spdos, 0, RT1719_MAX_SRCPDO);\n\tdata->spdo_num = 0;\n\tdata->voltage = data->max_current = data->op_current = 0;\n\tdata->attached = data->pd_capable = false;\n\n\tdata->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\n\tpower_supply_changed(data->psy);\n}\n\nstatic void rt1719_update_operating_status(struct rt1719_data *data)\n{\n\tenum power_supply_usb_type usb_type = POWER_SUPPLY_USB_TYPE_PD;\n\tu32 voltage, max_current, op_current;\n\tint i, snk_sel;\n\n\tfor (i = 0; i < data->spdo_num; i++) {\n\t\tu32 pdo = data->spdos[i];\n\t\tenum pd_pdo_type type = pdo_type(pdo);\n\n\t\tif (type == PDO_TYPE_APDO) {\n\t\t\tusb_type = POWER_SUPPLY_USB_TYPE_PD_PPS;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdata->spdo_sel = FIELD_GET(RT1719_SPDOSEL_MASK, data->conn_info);\n\tif (data->spdo_sel <= 0)\n\t\treturn;\n\n\tdata->usb_type = usb_type;\n\n\tvoltage = pdo_fixed_voltage(data->spdos[data->spdo_sel - 1]);\n\tmax_current = pdo_max_current(data->spdos[data->spdo_sel - 1]);\n\n\tswitch (voltage) {\n\tcase 5000:\n\t\tsnk_sel = RT1719_SNKCAP_5V;\n\t\tbreak;\n\tcase 9000:\n\t\tsnk_sel = RT1719_SNKCAP_9V;\n\t\tbreak;\n\tcase 12000:\n\t\tsnk_sel = RT1719_SNKCAP_12V;\n\t\tbreak;\n\tcase 15000:\n\t\tsnk_sel = RT1719_SNKCAP_15V;\n\t\tbreak;\n\tcase 20000:\n\t\tsnk_sel = RT1719_SNKCAP_20V;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\top_current = min(max_current, pdo_max_current(data->snkcaps[snk_sel]));\n\n\t \n\tdata->voltage = voltage * 1000;\n\tdata->max_current = max_current * 1000;\n\tdata->op_current = op_current * 1000;\n\n\tpower_supply_changed(data->psy);\n}\n\nstatic void rt1719_update_pwr_opmode(struct rt1719_data *data)\n{\n\tif (!data->attached)\n\t\treturn;\n\n\tif (!data->pd_capable) {\n\t\tdata->pd_capable = true;\n\n\t\ttypec_set_pwr_opmode(data->port, TYPEC_PWR_MODE_PD);\n\t\trt1719_register_partner(data);\n\t}\n\n\trt1719_update_operating_status(data);\n}\n\nstatic void rt1719_update_source_pdos(struct rt1719_data *data)\n{\n\tint spdo_num = FIELD_GET(RT1719_SPDONUM_MASK, data->conn_info);\n\t__le32 src_pdos[RT1719_MAX_SRCPDO] = { };\n\tint i, ret;\n\n\tif (!data->attached)\n\t\treturn;\n\n\tret = regmap_raw_read(data->regmap, RT1719_REG_SRCPDO1, src_pdos,\n\t\t\t      sizeof(__le32) * spdo_num);\n\tif (ret)\n\t\treturn;\n\n\tdata->spdo_num = spdo_num;\n\tfor (i = 0; i < spdo_num; i++)\n\t\tdata->spdos[i] = le32_to_cpu(src_pdos[i]);\n}\n\nstatic int rt1719_dr_set(struct typec_port *port, enum typec_data_role role)\n{\n\tstruct rt1719_data *data = typec_get_drvdata(port);\n\tenum typec_data_role cur_role;\n\tint ret;\n\n\tif (!data->attached || !data->pd_capable || !data->drswap_support)\n\t\treturn -EOPNOTSUPP;\n\n\tif (data->spdo_num > 0 && !(data->spdos[0] & PDO_FIXED_DATA_SWAP))\n\t\treturn -EINVAL;\n\n\tcur_role = rt1719_get_data_role(data->conn_info);\n\tif (cur_role == role)\n\t\treturn 0;\n\n\tret = regmap_update_bits(data->regmap, RT1719_REG_TXCTRL1,\n\t\t\t\t RT1719_REQDRSWAP_MASK, RT1719_REQDRSWAP_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&data->req_completion);\n\tret = wait_for_completion_timeout(&data->req_completion,\n\t\t\t\t\t  msecs_to_jiffies(400));\n\tif (ret == 0)\n\t\treturn -ETIMEDOUT;\n\n\tcur_role = rt1719_get_data_role(data->conn_info);\n\tif (cur_role != role)\n\t\treturn -EAGAIN;\n\n\trt1719_set_data_role(data, role, true);\n\treturn 0;\n}\n\nstatic const struct typec_operations rt1719_port_ops = {\n\t.dr_set = rt1719_dr_set,\n};\n\nstatic int rt1719_usbpd_request_voltage(struct rt1719_data *data)\n{\n\tu32 src_voltage;\n\tint snk_sel, src_sel = -1;\n\tint i, ret;\n\n\tif (!data->attached || !data->pd_capable || data->spdo_sel <= 0)\n\t\treturn -EINVAL;\n\n\tsrc_voltage = pdo_fixed_voltage(data->spdos[data->spdo_sel - 1]);\n\tif (src_voltage == data->req_voltage)\n\t\treturn 0;\n\n\tswitch (data->req_voltage) {\n\tcase 5000:\n\t\tsnk_sel = RT1719_SNKCAP_5V;\n\t\tbreak;\n\tcase 9000:\n\t\tsnk_sel = RT1719_SNKCAP_9V;\n\t\tbreak;\n\tcase 12000:\n\t\tsnk_sel = RT1719_SNKCAP_12V;\n\t\tbreak;\n\tcase 15000:\n\t\tsnk_sel = RT1719_SNKCAP_15V;\n\t\tbreak;\n\tcase 20000:\n\t\tsnk_sel = RT1719_SNKCAP_20V;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (!(data->snkcaps[snk_sel] & RT1719_PSEL_SUPPORT))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < data->spdo_num; i++) {\n\t\tenum pd_pdo_type type = pdo_type(data->spdos[i]);\n\n\t\tif (type != PDO_TYPE_FIXED)\n\t\t\tcontinue;\n\n\t\tsrc_voltage = pdo_fixed_voltage(data->spdos[i]);\n\t\tif (src_voltage == data->req_voltage) {\n\t\t\tsrc_sel = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (src_sel == -1)\n\t\treturn -EOPNOTSUPP;\n\n\tret = regmap_update_bits(data->regmap, RT1719_REG_TXCTRL1,\n\t\t\t\t RT1719_EVALMODE_MASK | RT1719_REQSRCPDO_MASK,\n\t\t\t\t RT1719_EVALMODE_MASK | (src_sel + 1));\n\tret |= regmap_update_bits(data->regmap, RT1719_REG_TXCTRL2,\n\t\t\t\t  RT1719_TXSPDOREQ_MASK, RT1719_TXSPDOREQ_MASK);\n\tif (ret)\n\t\treturn ret;\n\n\treinit_completion(&data->req_completion);\n\tret = wait_for_completion_timeout(&data->req_completion,\n\t\t\t\t\t  msecs_to_jiffies(400));\n\tif (!ret)\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n}\n\nstatic int rt1719_psy_set_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   const union power_supply_propval *val)\n{\n\tstruct rt1719_data *data = power_supply_get_drvdata(psy);\n\n\tif (psp == POWER_SUPPLY_PROP_VOLTAGE_NOW) {\n\t\tdata->req_voltage = val->intval / 1000;\n\t\treturn rt1719_usbpd_request_voltage(data);\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int rt1719_psy_get_property(struct power_supply *psy,\n\t\t\t\t   enum power_supply_property psp,\n\t\t\t\t   union power_supply_propval *val)\n{\n\tstruct rt1719_data *data = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = data->attached ? 1 : 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = data->usb_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\tval->intval = data->voltage;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = data->max_current;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\tval->intval = data->op_current;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int rt1719_psy_property_is_writeable(struct power_supply *psy,\n\t\t\t\t\t    enum power_supply_property psp)\n{\n\tif (psp == POWER_SUPPLY_PROP_VOLTAGE_NOW)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int devm_rt1719_psy_register(struct rt1719_data *data)\n{\n\tstruct power_supply_config psy_cfg = { };\n\tchar *psy_name;\n\n\tpsy_cfg.fwnode = dev_fwnode(data->dev);\n\tpsy_cfg.drv_data = data;\n\n\tpsy_name = devm_kasprintf(data->dev, GFP_KERNEL, \"rt1719-source-psy-%s\",\n\t\t\t\t  dev_name(data->dev));\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\tdata->psy_desc.name = psy_name;\n\tdata->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\tdata->psy_desc.usb_types = rt1719_psy_usb_types;\n\tdata->psy_desc.num_usb_types = ARRAY_SIZE(rt1719_psy_usb_types);\n\tdata->psy_desc.properties = rt1719_psy_properties;\n\tdata->psy_desc.num_properties = ARRAY_SIZE(rt1719_psy_properties);\n\tdata->psy_desc.get_property = rt1719_psy_get_property;\n\tdata->psy_desc.set_property = rt1719_psy_set_property;\n\tdata->psy_desc.property_is_writeable = rt1719_psy_property_is_writeable;\n\n\tdata->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\n\tdata->psy = devm_power_supply_register(data->dev, &data->psy_desc,\n\t\t\t\t\t       &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(data->psy);\n}\n\nstatic irqreturn_t rt1719_irq_handler(int irq, void *priv)\n{\n\tstruct rt1719_data *data = priv;\n\tu32 events, conn_info;\n\tu16 conn_stat;\n\tint ret;\n\n\tret = rt1719_read32(data, RT1719_REG_EVENTS, &events);\n\tret |= rt1719_read32(data, RT1719_REG_POLICYINFO, &conn_info);\n\tret |= rt1719_read16(data, RT1719_REG_STATS, &conn_stat);\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tdata->conn_info = conn_info;\n\tdata->conn_stat = conn_stat;\n\n\tevents &= (RT1719_INT_DRSW_ACCEPT | RT1719_INT_RX_SRCCAP |\n\t\t   RT1719_INT_VBUS_PRESENT | RT1719_INT_VBUS_DCT |\n\t\t   RT1719_INT_PE_SNK_RDY);\n\n\tif (events & RT1719_INT_DRSW_ACCEPT)\n\t\trt1719_update_data_role(data);\n\n\tif (events & RT1719_INT_VBUS_PRESENT)\n\t\trt1719_attach(data);\n\n\tif (events & RT1719_INT_VBUS_DCT)\n\t\trt1719_detach(data);\n\n\tif (events & RT1719_INT_RX_SRCCAP)\n\t\trt1719_update_source_pdos(data);\n\n\tif (events & RT1719_INT_PE_SNK_RDY) {\n\t\tcomplete(&data->req_completion);\n\t\trt1719_update_pwr_opmode(data);\n\t}\n\n\t \n\trt1719_write32(data, RT1719_REG_EVENTS, events);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int rt1719_irq_init(struct rt1719_data *data)\n{\n\tstruct i2c_client *i2c = to_i2c_client(data->dev);\n\tu32 irq_enable;\n\tint ret;\n\n\tirq_enable = RT1719_INT_DRSW_ACCEPT | RT1719_INT_RX_SRCCAP |\n\t\t     RT1719_INT_VBUS_DCT | RT1719_INT_VBUS_PRESENT |\n\t\t     RT1719_INT_PE_SNK_RDY;\n\n\tret = rt1719_write32(data, RT1719_REG_MASKS, irq_enable);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to config irq enable\\n\");\n\t\treturn ret;\n\t}\n\n\treturn devm_request_threaded_irq(&i2c->dev, i2c->irq, NULL,\n\t\t\t\t\t rt1719_irq_handler, IRQF_ONESHOT,\n\t\t\t\t\t dev_name(&i2c->dev), data);\n}\n\nstatic int rt1719_init_attach_state(struct rt1719_data *data)\n{\n\tu32 conn_info, irq_clear;\n\tu16 conn_stat;\n\tint ret;\n\n\tirq_clear = RT1719_INT_DRSW_ACCEPT | RT1719_INT_RX_SRCCAP |\n\t\t    RT1719_INT_VBUS_DCT | RT1719_INT_VBUS_PRESENT |\n\t\t    RT1719_INT_PE_SNK_RDY;\n\n\tret = rt1719_read32(data, RT1719_REG_POLICYINFO, &conn_info);\n\tret |= rt1719_read16(data, RT1719_REG_STATS, &conn_stat);\n\tret |= rt1719_write32(data, RT1719_REG_EVENTS, irq_clear);\n\tif (ret)\n\t\treturn ret;\n\n\tdata->conn_info = conn_info;\n\tdata->conn_stat = conn_stat;\n\n\tif (conn_info & RT1719_ATTACHDEV_MASK)\n\t\trt1719_attach(data);\n\n\tif (conn_info & RT1719_PE_EXP_CONTRACT) {\n\t\trt1719_update_source_pdos(data);\n\t\trt1719_update_pwr_opmode(data);\n\t}\n\n\treturn 0;\n}\n\n#define RT1719_PSEL_CAPINFO(_lomask, _milliwatt, _himask, _milliamp) { \\\n\t.lomask\t\t= _lomask, \\\n\t.milliwatt\t= _milliwatt, \\\n\t.himask\t\t= _himask, \\\n\t.milliamp\t= _milliamp, \\\n}\n\nstatic const struct rt1719_psel_cap rt1719_psel_caps[] = {\n\tRT1719_PSEL_CAPINFO(0x18, 75000, 0x10, 5000),\n\tRT1719_PSEL_CAPINFO(0x18, 60000, 0x10, 4500),\n\tRT1719_PSEL_CAPINFO(0x18, 45000, 0x10, 4000),\n\tRT1719_PSEL_CAPINFO(0x18, 30000, 0x10, 3500),\n\tRT1719_PSEL_CAPINFO(0x18, 25000, 0x10, 3000),\n\tRT1719_PSEL_CAPINFO(0x18, 20000, 0x10, 2500),\n\tRT1719_PSEL_CAPINFO(0x18, 15000, 0x10, 2000),\n\tRT1719_PSEL_CAPINFO(0x18, 10000, 0x10, 1000),\n\tRT1719_PSEL_CAPINFO(0x1C, 60000, 0x1F, 5000),\n\tRT1719_PSEL_CAPINFO(0x1C, 45000, 0x1F, 4500),\n\tRT1719_PSEL_CAPINFO(0x1C, 30000, 0x1F, 4000),\n\tRT1719_PSEL_CAPINFO(0x1C, 24000, 0x1F, 3500),\n\tRT1719_PSEL_CAPINFO(0x1C, 15000, 0x1F, 3000),\n\tRT1719_PSEL_CAPINFO(0x1C, 10000, 0x1F, 2500),\n\tRT1719_PSEL_CAPINFO(0x0C, 60000, 0x1F, 2000),\n\tRT1719_PSEL_CAPINFO(0x0C, 45000, 0x1F, 1000),\n\tRT1719_PSEL_CAPINFO(0x0C, 36000, 0x08, 5000),\n\tRT1719_PSEL_CAPINFO(0x0C, 30000, 0x08, 4500),\n\tRT1719_PSEL_CAPINFO(0x0C, 24000, 0x08, 4000),\n\tRT1719_PSEL_CAPINFO(0x0C, 15000, 0x08, 3500),\n\tRT1719_PSEL_CAPINFO(0x0C, 10000, 0x08, 3000),\n\tRT1719_PSEL_CAPINFO(0x1E, 45000, 0x08, 2500),\n\tRT1719_PSEL_CAPINFO(0x1E, 36000, 0x08, 2000),\n\tRT1719_PSEL_CAPINFO(0x1E, 27000, 0x08, 1500),\n\tRT1719_PSEL_CAPINFO(0x1E, 20000, 0x08, 1000),\n\tRT1719_PSEL_CAPINFO(0x1E, 15000, 0x0F, 5000),\n\tRT1719_PSEL_CAPINFO(0x1E, 9000, 0x0F, 4500),\n\tRT1719_PSEL_CAPINFO(0x0E, 45000, 0x0F, 4000),\n\tRT1719_PSEL_CAPINFO(0x0E, 36000, 0x0F, 3500),\n\tRT1719_PSEL_CAPINFO(0x0E, 27000, 0x0F, 3000),\n\tRT1719_PSEL_CAPINFO(0x0E, 20000, 0x0F, 2500),\n\tRT1719_PSEL_CAPINFO(0x0E, 15000, 0x0F, 2000),\n\tRT1719_PSEL_CAPINFO(0x0E, 9000, 0x0F, 1500),\n\tRT1719_PSEL_CAPINFO(0x06, 45000, 0x0F, 1000),\n\tRT1719_PSEL_CAPINFO(0x06, 36000, 0x0F, 500),\n\tRT1719_PSEL_CAPINFO(0x06, 27000, 0x04, 5000),\n\tRT1719_PSEL_CAPINFO(0x06, 24000, 0x04, 4500),\n\tRT1719_PSEL_CAPINFO(0x06, 18000, 0x04, 4000),\n\tRT1719_PSEL_CAPINFO(0x06, 12000, 0x04, 3500),\n\tRT1719_PSEL_CAPINFO(0x06, 9000, 0x04, 3000),\n\tRT1719_PSEL_CAPINFO(0x1F, 25000, 0x04, 2500),\n\tRT1719_PSEL_CAPINFO(0x1F, 20000, 0x04, 2000),\n\tRT1719_PSEL_CAPINFO(0x1F, 15000, 0x04, 1500),\n\tRT1719_PSEL_CAPINFO(0x1F, 10000, 0x04, 1000),\n\tRT1719_PSEL_CAPINFO(0x1F, 7500, 0x07, 5000),\n\tRT1719_PSEL_CAPINFO(0x0F, 25000, 0x07, 4500),\n\tRT1719_PSEL_CAPINFO(0x0F, 20000, 0x07, 4000),\n\tRT1719_PSEL_CAPINFO(0x0F, 15000, 0x07, 3500),\n\tRT1719_PSEL_CAPINFO(0x0F, 10000, 0x07, 3000),\n\tRT1719_PSEL_CAPINFO(0x0F, 7500, 0x07, 2500),\n\tRT1719_PSEL_CAPINFO(0x07, 25000, 0x07, 2000),\n\tRT1719_PSEL_CAPINFO(0x07, 20000, 0x07, 1500),\n\tRT1719_PSEL_CAPINFO(0x07, 15000, 0x07, 1000),\n\tRT1719_PSEL_CAPINFO(0x07, 10000, 0x07, 500),\n\tRT1719_PSEL_CAPINFO(0x07, 7500, 0x03, 5000),\n\tRT1719_PSEL_CAPINFO(0x03, 25000, 0x03, 4500),\n\tRT1719_PSEL_CAPINFO(0x03, 20000, 0x03, 4000),\n\tRT1719_PSEL_CAPINFO(0x03, 15000, 0x03, 3500),\n\tRT1719_PSEL_CAPINFO(0x03, 10000, 0x03, 3000),\n\tRT1719_PSEL_CAPINFO(0x03, 7500, 0x03, 2500),\n\tRT1719_PSEL_CAPINFO(0x01, 15000, 0x03, 2000),\n\tRT1719_PSEL_CAPINFO(0x01, 10000, 0x03, 1500),\n\tRT1719_PSEL_CAPINFO(0x01, 7500, 0x03, 1000),\n\tRT1719_PSEL_CAPINFO(0x01, 2500, 0x03, 500)\n};\n\nstatic u16 rt1719_gen_snkcap_by_current(const struct rt1719_psel_cap *psel_cap,\n\t\t\t\t\tenum rt1719_snkcap capsel)\n{\n\tu16 cap = RT1719_PSEL_SUPPORT;\n\n\tif (!(psel_cap->himask & BIT(capsel)))\n\t\treturn 0;\n\n\tcap |= psel_cap->milliamp / 10;\n\treturn cap;\n}\n\nstatic u16 rt1719_gen_snkcap_by_watt(const struct rt1719_psel_cap *psel_cap,\n\t\t\t\t     enum rt1719_snkcap capsel)\n{\n\tu32 volt_div[RT1719_MAX_SNKCAP] = { 5, 9, 12, 15, 20 };\n\tu16 cap = RT1719_PSEL_SUPPORT;\n\n\tif (!(psel_cap->lomask & BIT(capsel)))\n\t\treturn 0;\n\n\tcap |= min(psel_cap->milliwatt / volt_div[capsel], (u32)5000) / 10;\n\treturn cap;\n}\n\nstatic u16 rt1719_gen_snkcap(unsigned int pselinfo, enum rt1719_snkcap capsel)\n{\n\tint psel = FIELD_GET(RT1719_LATPSEL_MASK, pselinfo);\n\tconst struct rt1719_psel_cap *psel_cap;\n\tbool by_current = false;\n\n\tif (pselinfo & RT1719_TBLSEL_MASK)\n\t\tby_current = true;\n\n\tpsel_cap = rt1719_psel_caps + psel;\n\tif (by_current)\n\t\treturn rt1719_gen_snkcap_by_current(psel_cap, capsel);\n\n\treturn rt1719_gen_snkcap_by_watt(psel_cap, capsel);\n}\n\nstatic int rt1719_get_caps(struct rt1719_data *data)\n{\n\tunsigned int pselinfo, usbinfo;\n\tint i, ret;\n\n\tret = regmap_read(data->regmap, RT1719_REG_PSELINFO, &pselinfo);\n\tret |= regmap_read(data->regmap, RT1719_REG_USBSETINFO, &usbinfo);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < RT1719_MAX_SNKCAP; i++)\n\t\tdata->snkcaps[i] = rt1719_gen_snkcap(pselinfo, i);\n\n\tusbinfo = FIELD_GET(RT1719_USBINFO_MASK, usbinfo);\n\tif (usbinfo == RT1719_USB_DFPUFP)\n\t\tdata->drswap_support = true;\n\n\treturn 0;\n}\n\nstatic int rt1719_check_exist(struct rt1719_data *data)\n{\n\tu16 pid;\n\tint ret;\n\n\tret = rt1719_read16(data, RT1719_REG_VENID, &pid);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pid != RT1719_UNIQUE_PID) {\n\t\tdev_err(data->dev, \"Incorrect PID 0x%04x\\n\", pid);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config rt1719_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = 0xff,\n};\n\nstatic int rt1719_probe(struct i2c_client *i2c)\n{\n\tstruct rt1719_data *data;\n\tstruct fwnode_handle *fwnode;\n\tstruct typec_capability typec_cap = { };\n\tint ret;\n\n\tdata = devm_kzalloc(&i2c->dev, sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->dev = &i2c->dev;\n\tinit_completion(&data->req_completion);\n\n\tdata->regmap = devm_regmap_init_i2c(i2c, &rt1719_regmap_config);\n\tif (IS_ERR(data->regmap)) {\n\t\tret = PTR_ERR(data->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to init regmap (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = rt1719_check_exist(data);\n\tif (ret)\n\t\treturn ret;\n\n\tret = rt1719_get_caps(data);\n\tif (ret)\n\t\treturn ret;\n\n\tfwnode = device_get_named_child_node(&i2c->dev, \"connector\");\n\tif (!fwnode)\n\t\treturn -ENODEV;\n\n\tdata->role_sw = fwnode_usb_role_switch_get(fwnode);\n\tif (IS_ERR(data->role_sw)) {\n\t\tret = PTR_ERR(data->role_sw);\n\t\tdev_err(&i2c->dev, \"Failed to get usb role switch (%d)\\n\", ret);\n\t\tgoto err_fwnode_put;\n\t}\n\n\tret = devm_rt1719_psy_register(data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to register psy (%d)\\n\", ret);\n\t\tgoto err_role_put;\n\t}\n\n\ttypec_cap.revision = USB_TYPEC_REV_1_2;\n\ttypec_cap.pd_revision = 0x300;\t \n\ttypec_cap.type = TYPEC_PORT_SNK;\n\ttypec_cap.data = TYPEC_PORT_DRD;\n\ttypec_cap.ops = &rt1719_port_ops;\n\ttypec_cap.fwnode = fwnode;\n\ttypec_cap.driver_data = data;\n\ttypec_cap.accessory[0] = TYPEC_ACCESSORY_DEBUG;\n\n\tdata->partner_desc.identity = &data->partner_ident;\n\n\tdata->port = typec_register_port(&i2c->dev, &typec_cap);\n\tif (IS_ERR(data->port)) {\n\t\tret = PTR_ERR(data->port);\n\t\tdev_err(&i2c->dev, \"Failed to register typec port (%d)\\n\", ret);\n\t\tgoto err_role_put;\n\t}\n\n\tret = rt1719_init_attach_state(data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to init attach state (%d)\\n\", ret);\n\t\tgoto err_role_put;\n\t}\n\n\tret = rt1719_irq_init(data);\n\tif (ret) {\n\t\tdev_err(&i2c->dev, \"Failed to init irq\\n\");\n\t\tgoto err_role_put;\n\t}\n\n\tfwnode_handle_put(fwnode);\n\n\ti2c_set_clientdata(i2c, data);\n\n\treturn 0;\n\nerr_role_put:\n\tusb_role_switch_put(data->role_sw);\nerr_fwnode_put:\n\tfwnode_handle_put(fwnode);\n\n\treturn ret;\n}\n\nstatic void rt1719_remove(struct i2c_client *i2c)\n{\n\tstruct rt1719_data *data = i2c_get_clientdata(i2c);\n\n\ttypec_unregister_port(data->port);\n\tusb_role_switch_put(data->role_sw);\n}\n\nstatic const struct of_device_id __maybe_unused rt1719_device_table[] = {\n\t{ .compatible = \"richtek,rt1719\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, rt1719_device_table);\n\nstatic struct i2c_driver rt1719_driver = {\n\t.driver = {\n\t\t.name = \"rt1719\",\n\t\t.of_match_table = rt1719_device_table,\n\t},\n\t.probe = rt1719_probe,\n\t.remove = rt1719_remove,\n};\nmodule_i2c_driver(rt1719_driver);\n\nMODULE_AUTHOR(\"ChiYuan Huang <cy_huang@richtek.com>\");\nMODULE_DESCRIPTION(\"Richtek RT1719 Sink Only USBPD Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}