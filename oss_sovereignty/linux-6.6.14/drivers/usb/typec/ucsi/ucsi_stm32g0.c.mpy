{
  "module_name": "ucsi_stm32g0.c",
  "hash_id": "e07802dd2193a11393e7307af921c2f27a1df19ed51aeea7349f654d885e69a5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/ucsi_stm32g0.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <asm/unaligned.h>\n\n#include \"ucsi.h\"\n\n \n#define STM32G0_I2C_BL_ADDR\t(0xa2 >> 1)\n\n \n#define STM32G0_I2C_BL_SZ\t256\n\n \n#define STM32_CMD_GVR\t\t0x01\t \n#define STM32_CMD_GVR_LEN\t1\n#define STM32_CMD_RM\t\t0x11\t \n#define STM32_CMD_WM\t\t0x31\t \n#define STM32_CMD_ADDR_LEN\t5\t \n#define STM32_CMD_ERASE\t\t0x44\t \n#define STM32_CMD_ERASE_SPECIAL_LEN\t3\n#define STM32_CMD_GLOBAL_MASS_ERASE\t0xffff  \n\n \n#define STM32G0_I2C_BL_ACK\t0x79\n#define STM32G0_I2C_BL_NACK\t0x1f\n#define STM32G0_I2C_BL_BUSY\t0x76\n\n \n#define STM32G0_USER_OPTION_BYTES\t0x1fff7800\n#define STM32G0_USER_OB_NBOOT0\t\tBIT(26)\n#define STM32G0_USER_OB_NBOOT_SEL\tBIT(24)\n#define STM32G0_USER_OB_BOOT_MAIN\t(STM32G0_USER_OB_NBOOT0 | STM32G0_USER_OB_NBOOT_SEL)\n#define STM32G0_MAIN_MEM_ADDR\t\t0x08000000\n\n \n#define STM32G0_FW_GETVER\t0x00\t \n#define STM32G0_FW_GETVER_LEN\t4\n#define STM32G0_FW_RSTGOBL\t0x21\t \n#define STM32G0_FW_KEYWORD\t0xa56959a6\n\n \nstruct ucsi_stm32g0_fw_info {\n\tu32 version;\n\tu32 keyword;\n};\n\nstruct ucsi_stm32g0 {\n\tstruct i2c_client *client;\n\tstruct i2c_client *i2c_bl;\n\tbool in_bootloader;\n\tu8 bl_version;\n\tstruct completion complete;\n\tstruct device *dev;\n\tunsigned long flags;\n\tconst char *fw_name;\n\tstruct ucsi *ucsi;\n\tbool suspended;\n\tbool wakeup_event;\n};\n\n \nstatic int ucsi_stm32g0_bl_check_ack(struct ucsi *ucsi)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->i2c_bl;\n\tunsigned char ack;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = I2C_M_RD,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &ack,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(g0->dev, \"i2c bl ack (%02x), error: %d\\n\", client->addr, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\t \n\tswitch (ack) {\n\tcase STM32G0_I2C_BL_ACK:\n\t\treturn 0;\n\tcase STM32G0_I2C_BL_NACK:\n\t\treturn -ENOENT;\n\tcase STM32G0_I2C_BL_BUSY:\n\t\treturn -EBUSY;\n\tdefault:\n\t\tdev_err(g0->dev, \"i2c bl ack (%02x), invalid byte: %02x\\n\",\n\t\t\tclient->addr, ack);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int ucsi_stm32g0_bl_cmd_check_ack(struct ucsi *ucsi, unsigned int cmd, bool check_ack)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->i2c_bl;\n\tunsigned char buf[2];\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0,\n\t\t\t.len\t= sizeof(buf),\n\t\t\t.buf\t= buf,\n\t\t},\n\t};\n\tint ret;\n\n\t \n\tbuf[0] = cmd;\n\tbuf[1] = cmd ^ 0xff;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_dbg(g0->dev, \"i2c bl cmd %d (%02x), error: %d\\n\", cmd, client->addr, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tif (check_ack)\n\t\treturn ucsi_stm32g0_bl_check_ack(ucsi);\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_bl_cmd(struct ucsi *ucsi, unsigned int cmd)\n{\n\treturn ucsi_stm32g0_bl_cmd_check_ack(ucsi, cmd, true);\n}\n\nstatic int ucsi_stm32g0_bl_rcv_check_ack(struct ucsi *ucsi, void *data, size_t len, bool check_ack)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->i2c_bl;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = I2C_M_RD,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= data,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(g0->dev, \"i2c bl rcv %02x, error: %d\\n\", client->addr, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\tif (check_ack)\n\t\treturn ucsi_stm32g0_bl_check_ack(ucsi);\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_bl_rcv(struct ucsi *ucsi, void *data, size_t len)\n{\n\treturn ucsi_stm32g0_bl_rcv_check_ack(ucsi, data, len, true);\n}\n\nstatic int ucsi_stm32g0_bl_rcv_woack(struct ucsi *ucsi, void *data, size_t len)\n{\n\treturn ucsi_stm32g0_bl_rcv_check_ack(ucsi, data, len, false);\n}\n\nstatic int ucsi_stm32g0_bl_send(struct ucsi *ucsi, void *data, size_t len)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->i2c_bl;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= data,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(g0->dev, \"i2c bl send %02x, error: %d\\n\", client->addr, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn ucsi_stm32g0_bl_check_ack(ucsi);\n}\n\n \nstatic int ucsi_stm32g0_bl_get_version(struct ucsi *ucsi, u8 *bl_version)\n{\n\tint ret;\n\n\tret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_GVR);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ucsi_stm32g0_bl_rcv(ucsi, bl_version, STM32_CMD_GVR_LEN);\n}\n\nstatic int ucsi_stm32g0_bl_send_addr(struct ucsi *ucsi, u32 addr)\n{\n\tu8 data8[STM32_CMD_ADDR_LEN];\n\n\t \n\tput_unaligned_be32(addr, data8);\n\tdata8[4] = data8[0] ^ data8[1] ^ data8[2] ^ data8[3];\n\n\treturn ucsi_stm32g0_bl_send(ucsi, data8, STM32_CMD_ADDR_LEN);\n}\n\nstatic int ucsi_stm32g0_bl_global_mass_erase(struct ucsi *ucsi)\n{\n\tu8 data8[4];\n\tu16 *data16 = (u16 *)&data8[0];\n\tint ret;\n\n\tdata16[0] = STM32_CMD_GLOBAL_MASS_ERASE;\n\tdata8[2] = data8[0] ^ data8[1];\n\n\tret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_ERASE);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ucsi_stm32g0_bl_send(ucsi, data8, STM32_CMD_ERASE_SPECIAL_LEN);\n}\n\nstatic int ucsi_stm32g0_bl_write(struct ucsi *ucsi, u32 addr, const void *data, size_t len)\n{\n\tu8 *data8;\n\tint i, ret;\n\n\tif (!len || len > STM32G0_I2C_BL_SZ)\n\t\treturn -EINVAL;\n\n\t \n\tdata8 = kmalloc(STM32G0_I2C_BL_SZ + 2, GFP_KERNEL);\n\tif (!data8)\n\t\treturn -ENOMEM;\n\n\tret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_WM);\n\tif (ret)\n\t\tgoto free;\n\n\tret = ucsi_stm32g0_bl_send_addr(ucsi, addr);\n\tif (ret)\n\t\tgoto free;\n\n\tdata8[0] = len - 1;\n\tmemcpy(data8 + 1, data, len);\n\tdata8[len + 1] = data8[0];\n\tfor (i = 1; i <= len; i++)\n\t\tdata8[len + 1] ^= data8[i];\n\n\tret = ucsi_stm32g0_bl_send(ucsi, data8, len + 2);\nfree:\n\tkfree(data8);\n\n\treturn ret;\n}\n\nstatic int ucsi_stm32g0_bl_read(struct ucsi *ucsi, u32 addr, void *data, size_t len)\n{\n\tint ret;\n\n\tif (!len || len > STM32G0_I2C_BL_SZ)\n\t\treturn -EINVAL;\n\n\tret = ucsi_stm32g0_bl_cmd(ucsi, STM32_CMD_RM);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucsi_stm32g0_bl_send_addr(ucsi, addr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucsi_stm32g0_bl_cmd(ucsi, len - 1);\n\tif (ret)\n\t\treturn ret;\n\n\treturn ucsi_stm32g0_bl_rcv_woack(ucsi, data, len);\n}\n\n \nstatic int ucsi_stm32g0_fw_cmd(struct ucsi *ucsi, unsigned int cmd)\n{\n\treturn ucsi_stm32g0_bl_cmd_check_ack(ucsi, cmd, false);\n}\n\nstatic int ucsi_stm32g0_fw_rcv(struct ucsi *ucsi, void *data, size_t len)\n{\n\treturn ucsi_stm32g0_bl_rcv_woack(ucsi, data, len);\n}\n\n \nstatic int ucsi_stm32g0_read(struct ucsi *ucsi, unsigned int offset, void *val, size_t len)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->client;\n\tu8 reg = offset;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0,\n\t\t\t.len\t= 1,\n\t\t\t.buf\t= &reg,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = I2C_M_RD,\n\t\t\t.len\t= len,\n\t\t\t.buf\t= val,\n\t\t},\n\t};\n\tint ret;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(g0->dev, \"i2c read %02x, %02x error: %d\\n\", client->addr, reg, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_async_write(struct ucsi *ucsi, unsigned int offset, const void *val,\n\t\t\t\t    size_t len)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->client;\n\tstruct i2c_msg msg[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0,\n\t\t}\n\t};\n\tunsigned char *buf;\n\tint ret;\n\n\tbuf = kmalloc(len + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = offset;\n\tmemcpy(&buf[1], val, len);\n\tmsg[0].len = len + 1;\n\tmsg[0].buf = buf;\n\n\tret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));\n\tkfree(buf);\n\tif (ret != ARRAY_SIZE(msg)) {\n\t\tdev_err(g0->dev, \"i2c write %02x, %02x error: %d\\n\", client->addr, offset, ret);\n\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_sync_write(struct ucsi *ucsi, unsigned int offset, const void *val,\n\t\t\t\t   size_t len)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tint ret;\n\n\tset_bit(COMMAND_PENDING, &g0->flags);\n\n\tret = ucsi_stm32g0_async_write(ucsi, offset, val, len);\n\tif (ret)\n\t\tgoto out_clear_bit;\n\n\tif (!wait_for_completion_timeout(&g0->complete, msecs_to_jiffies(5000)))\n\t\tret = -ETIMEDOUT;\n\nout_clear_bit:\n\tclear_bit(COMMAND_PENDING, &g0->flags);\n\n\treturn ret;\n}\n\nstatic irqreturn_t ucsi_stm32g0_irq_handler(int irq, void *data)\n{\n\tstruct ucsi_stm32g0 *g0 = data;\n\tu32 cci;\n\tint ret;\n\n\tif (g0->suspended)\n\t\tg0->wakeup_event = true;\n\n\tret = ucsi_stm32g0_read(g0->ucsi, UCSI_CCI, &cci, sizeof(cci));\n\tif (ret)\n\t\treturn IRQ_NONE;\n\n\tif (UCSI_CCI_CONNECTOR(cci))\n\t\tucsi_connector_change(g0->ucsi, UCSI_CCI_CONNECTOR(cci));\n\n\tif (test_bit(COMMAND_PENDING, &g0->flags) &&\n\t    cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))\n\t\tcomplete(&g0->complete);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct ucsi_operations ucsi_stm32g0_ops = {\n\t.read = ucsi_stm32g0_read,\n\t.sync_write = ucsi_stm32g0_sync_write,\n\t.async_write = ucsi_stm32g0_async_write,\n};\n\nstatic int ucsi_stm32g0_register(struct ucsi *ucsi)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->client;\n\tint ret;\n\n\t \n\tret = request_threaded_irq(client->irq, NULL, ucsi_stm32g0_irq_handler, IRQF_ONESHOT,\n\t\t\t\t   dev_name(g0->dev), g0);\n\tif (ret) {\n\t\tdev_err(g0->dev, \"request IRQ failed: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = ucsi_register(ucsi);\n\tif (ret) {\n\t\tdev_err_probe(g0->dev, ret, \"ucsi_register failed\\n\");\n\t\tfree_irq(client->irq, g0);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void ucsi_stm32g0_unregister(struct ucsi *ucsi)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tstruct i2c_client *client = g0->client;\n\n\tucsi_unregister(ucsi);\n\tfree_irq(client->irq, g0);\n}\n\nstatic void ucsi_stm32g0_fw_cb(const struct firmware *fw, void *context)\n{\n\tstruct ucsi_stm32g0 *g0;\n\tconst u8 *data, *end;\n\tconst struct ucsi_stm32g0_fw_info *fw_info;\n\tu32 addr = STM32G0_MAIN_MEM_ADDR, ob, fw_version;\n\tint ret, size;\n\n\tif (!context)\n\t\treturn;\n\n\tg0 = ucsi_get_drvdata(context);\n\n\tif (!fw)\n\t\tgoto fw_release;\n\n\tfw_info = (struct ucsi_stm32g0_fw_info *)(fw->data + fw->size - sizeof(*fw_info));\n\n\tif (!g0->in_bootloader) {\n\t\t \n\t\tret = ucsi_stm32g0_fw_cmd(g0->ucsi, STM32G0_FW_GETVER);\n\t\tif (ret) {\n\t\t\tdev_err(g0->dev, \"Get version cmd failed %d\\n\", ret);\n\t\t\tgoto fw_release;\n\t\t}\n\t\tret = ucsi_stm32g0_fw_rcv(g0->ucsi, &fw_version,\n\t\t\t\t\t  STM32G0_FW_GETVER_LEN);\n\t\tif (ret) {\n\t\t\tdev_err(g0->dev, \"Get version failed %d\\n\", ret);\n\t\t\tgoto fw_release;\n\t\t}\n\n\t\t \n\t\tif (fw_info->keyword != STM32G0_FW_KEYWORD || fw_info->version == fw_version)\n\t\t\tgoto fw_release;\n\n\t\tdev_info(g0->dev, \"Flashing FW: %08x (%08x cur)\\n\", fw_info->version, fw_version);\n\n\t\t \n\t\tucsi_stm32g0_unregister(g0->ucsi);\n\t\tret = ucsi_stm32g0_fw_cmd(g0->ucsi, STM32G0_FW_RSTGOBL);\n\t\tif (ret) {\n\t\t\tdev_err(g0->dev, \"bootloader cmd failed %d\\n\", ret);\n\t\t\tgoto fw_release;\n\t\t}\n\t\tg0->in_bootloader = true;\n\n\t\t \n\t\tmsleep(100);\n\t}\n\n\tret = ucsi_stm32g0_bl_global_mass_erase(g0->ucsi);\n\tif (ret) {\n\t\tdev_err(g0->dev, \"Erase failed %d\\n\", ret);\n\t\tgoto fw_release;\n\t}\n\n\tdata = fw->data;\n\tend = fw->data + fw->size;\n\twhile (data < end) {\n\t\tif ((end - data) < STM32G0_I2C_BL_SZ)\n\t\t\tsize = end - data;\n\t\telse\n\t\t\tsize = STM32G0_I2C_BL_SZ;\n\n\t\tret = ucsi_stm32g0_bl_write(g0->ucsi, addr, data, size);\n\t\tif (ret) {\n\t\t\tdev_err(g0->dev, \"Write failed %d\\n\", ret);\n\t\t\tgoto fw_release;\n\t\t}\n\t\taddr += size;\n\t\tdata += size;\n\t}\n\n\tdev_dbg(g0->dev, \"Configure to boot from main flash\\n\");\n\n\tret = ucsi_stm32g0_bl_read(g0->ucsi, STM32G0_USER_OPTION_BYTES, &ob, sizeof(ob));\n\tif (ret) {\n\t\tdev_err(g0->dev, \"read user option bytes failed %d\\n\", ret);\n\t\tgoto fw_release;\n\t}\n\n\tdev_dbg(g0->dev, \"STM32G0_USER_OPTION_BYTES 0x%08x\\n\", ob);\n\n\t \n\tob |= STM32G0_USER_OB_BOOT_MAIN;\n\n\t \n\tret = ucsi_stm32g0_bl_write(g0->ucsi, STM32G0_USER_OPTION_BYTES, &ob, sizeof(ob));\n\tif (ret) {\n\t\tdev_err(g0->dev, \"write user option bytes failed %d\\n\", ret);\n\t\tgoto fw_release;\n\t}\n\n\tdev_info(g0->dev, \"Starting, option bytes:0x%08x\\n\", ob);\n\n\t \n\tmsleep(500);\n\n\t \n\tif (!ucsi_stm32g0_register(g0->ucsi))\n\t\tg0->in_bootloader = false;\n\nfw_release:\n\trelease_firmware(fw);\n}\n\nstatic int ucsi_stm32g0_probe_bootloader(struct ucsi *ucsi)\n{\n\tstruct ucsi_stm32g0 *g0 = ucsi_get_drvdata(ucsi);\n\tint ret;\n\tu16 ucsi_version;\n\n\t \n\tif (device_property_present(g0->dev, \"firmware-name\")) {\n\t\tret = device_property_read_string(g0->dev, \"firmware-name\", &g0->fw_name);\n\t\tif (ret < 0)\n\t\t\treturn dev_err_probe(g0->dev, ret, \"Error reading firmware-name\\n\");\n\t}\n\n\tif (g0->fw_name) {\n\t\t \n\t\tg0->i2c_bl = i2c_new_dummy_device(g0->client->adapter, STM32G0_I2C_BL_ADDR);\n\t\tif (IS_ERR(g0->i2c_bl)) {\n\t\t\tret = dev_err_probe(g0->dev, PTR_ERR(g0->i2c_bl),\n\t\t\t\t\t    \"Failed to register bootloader I2C address\\n\");\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t \n\tret = ucsi_stm32g0_read(ucsi, UCSI_VERSION, &ucsi_version, sizeof(ucsi_version));\n\tif (!ret || !g0->fw_name)\n\t\treturn ret;\n\n\t \n\tret = ucsi_stm32g0_bl_get_version(ucsi, &g0->bl_version);\n\tif (ret < 0) {\n\t\ti2c_unregister_device(g0->i2c_bl);\n\t\treturn ret;\n\t}\n\n\t \n\tg0->in_bootloader = true;\n\tdev_info(g0->dev, \"Bootloader Version 0x%02x\\n\", g0->bl_version);\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ucsi_stm32g0 *g0;\n\tint ret;\n\n\tg0 = devm_kzalloc(dev, sizeof(*g0), GFP_KERNEL);\n\tif (!g0)\n\t\treturn -ENOMEM;\n\n\tg0->dev = dev;\n\tg0->client = client;\n\tinit_completion(&g0->complete);\n\ti2c_set_clientdata(client, g0);\n\n\tg0->ucsi = ucsi_create(dev, &ucsi_stm32g0_ops);\n\tif (IS_ERR(g0->ucsi))\n\t\treturn PTR_ERR(g0->ucsi);\n\n\tucsi_set_drvdata(g0->ucsi, g0);\n\n\tret = ucsi_stm32g0_probe_bootloader(g0->ucsi);\n\tif (ret < 0)\n\t\tgoto destroy;\n\n\t \n\tif (!g0->in_bootloader) {\n\t\tret = ucsi_stm32g0_register(g0->ucsi);\n\t\tif (ret < 0)\n\t\t\tgoto freei2c;\n\t}\n\n\tif (g0->fw_name) {\n\t\t \n\t\tret = request_firmware_nowait(THIS_MODULE, FW_ACTION_UEVENT, g0->fw_name, g0->dev,\n\t\t\t\t\t      GFP_KERNEL, g0->ucsi, ucsi_stm32g0_fw_cb);\n\t\tif (ret < 0) {\n\t\t\tdev_err_probe(dev, ret, \"firmware request failed\\n\");\n\t\t\tgoto unregister;\n\t\t}\n\t}\n\n\treturn 0;\n\nunregister:\n\tif (!g0->in_bootloader)\n\t\tucsi_stm32g0_unregister(g0->ucsi);\nfreei2c:\n\tif (g0->fw_name)\n\t\ti2c_unregister_device(g0->i2c_bl);\ndestroy:\n\tucsi_destroy(g0->ucsi);\n\n\treturn ret;\n}\n\nstatic void ucsi_stm32g0_remove(struct i2c_client *client)\n{\n\tstruct ucsi_stm32g0 *g0 = i2c_get_clientdata(client);\n\n\tif (!g0->in_bootloader)\n\t\tucsi_stm32g0_unregister(g0->ucsi);\n\tif (g0->fw_name)\n\t\ti2c_unregister_device(g0->i2c_bl);\n\tucsi_destroy(g0->ucsi);\n}\n\nstatic int ucsi_stm32g0_suspend(struct device *dev)\n{\n\tstruct ucsi_stm32g0 *g0 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = g0->client;\n\n\tif (g0->in_bootloader)\n\t\treturn 0;\n\n\t \n\tdisable_irq(client->irq);\n\n\tg0->suspended = true;\n\tg0->wakeup_event = false;\n\n\tif (device_may_wakeup(dev) || device_wakeup_path(dev))\n\t\tenable_irq_wake(client->irq);\n\n\treturn 0;\n}\n\nstatic int ucsi_stm32g0_resume(struct device *dev)\n{\n\tstruct ucsi_stm32g0 *g0 = dev_get_drvdata(dev);\n\tstruct i2c_client *client = g0->client;\n\n\tif (g0->in_bootloader)\n\t\treturn 0;\n\n\tif (device_may_wakeup(dev) || device_wakeup_path(dev))\n\t\tdisable_irq_wake(client->irq);\n\n\tenable_irq(client->irq);\n\n\t \n\tsynchronize_irq(client->irq);\n\n\tif (g0->wakeup_event)\n\t\tpm_wakeup_event(g0->dev, 0);\n\n\tg0->suspended = false;\n\n\treturn 0;\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ucsi_stm32g0_pm_ops, ucsi_stm32g0_suspend, ucsi_stm32g0_resume);\n\nstatic const struct of_device_id __maybe_unused ucsi_stm32g0_typec_of_match[] = {\n\t{ .compatible = \"st,stm32g0-typec\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ucsi_stm32g0_typec_of_match);\n\nstatic const struct i2c_device_id ucsi_stm32g0_typec_i2c_devid[] = {\n\t{\"stm32g0-typec\", 0},\n\t{},\n};\nMODULE_DEVICE_TABLE(i2c, ucsi_stm32g0_typec_i2c_devid);\n\nstatic struct i2c_driver ucsi_stm32g0_i2c_driver = {\n\t.driver = {\n\t\t.name = \"ucsi-stm32g0-i2c\",\n\t\t.of_match_table = of_match_ptr(ucsi_stm32g0_typec_of_match),\n\t\t.pm = pm_sleep_ptr(&ucsi_stm32g0_pm_ops),\n\t},\n\t.probe = ucsi_stm32g0_probe,\n\t.remove = ucsi_stm32g0_remove,\n\t.id_table = ucsi_stm32g0_typec_i2c_devid\n};\nmodule_i2c_driver(ucsi_stm32g0_i2c_driver);\n\nMODULE_AUTHOR(\"Fabrice Gasnier <fabrice.gasnier@foss.st.com>\");\nMODULE_DESCRIPTION(\"STMicroelectronics STM32G0 Type-C controller\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_ALIAS(\"platform:ucsi-stm32g0\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}