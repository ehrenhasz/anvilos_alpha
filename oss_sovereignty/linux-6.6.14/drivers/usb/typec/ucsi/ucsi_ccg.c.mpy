{
  "module_name": "ucsi_ccg.c",
  "hash_id": "8da5d7bb07ae5aa2fb698eb7f634389bb737fdc0ff9603a35f65cb16376d3a64",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/ucsi_ccg.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/pm_runtime.h>\n#include <linux/usb/typec_dp.h>\n\n#include <asm/unaligned.h>\n#include \"ucsi.h\"\n\nenum enum_fw_mode {\n\tBOOT,    \n\tFW1,     \n\tFW2,     \n\tFW_INVALID,\n};\n\n#define CCGX_RAB_DEVICE_MODE\t\t\t0x0000\n#define CCGX_RAB_INTR_REG\t\t\t0x0006\n#define  DEV_INT\t\t\t\tBIT(0)\n#define  PORT0_INT\t\t\t\tBIT(1)\n#define  PORT1_INT\t\t\t\tBIT(2)\n#define  UCSI_READ_INT\t\t\t\tBIT(7)\n#define CCGX_RAB_JUMP_TO_BOOT\t\t\t0x0007\n#define  TO_BOOT\t\t\t\t'J'\n#define  TO_ALT_FW\t\t\t\t'A'\n#define CCGX_RAB_RESET_REQ\t\t\t0x0008\n#define  RESET_SIG\t\t\t\t'R'\n#define  CMD_RESET_I2C\t\t\t\t0x0\n#define  CMD_RESET_DEV\t\t\t\t0x1\n#define CCGX_RAB_ENTER_FLASHING\t\t\t0x000A\n#define  FLASH_ENTER_SIG\t\t\t'P'\n#define CCGX_RAB_VALIDATE_FW\t\t\t0x000B\n#define CCGX_RAB_FLASH_ROW_RW\t\t\t0x000C\n#define  FLASH_SIG\t\t\t\t'F'\n#define  FLASH_RD_CMD\t\t\t\t0x0\n#define  FLASH_WR_CMD\t\t\t\t0x1\n#define  FLASH_FWCT1_WR_CMD\t\t\t0x2\n#define  FLASH_FWCT2_WR_CMD\t\t\t0x3\n#define  FLASH_FWCT_SIG_WR_CMD\t\t\t0x4\n#define CCGX_RAB_READ_ALL_VER\t\t\t0x0010\n#define CCGX_RAB_READ_FW2_VER\t\t\t0x0020\n#define CCGX_RAB_UCSI_CONTROL\t\t\t0x0039\n#define CCGX_RAB_UCSI_CONTROL_START\t\tBIT(0)\n#define CCGX_RAB_UCSI_CONTROL_STOP\t\tBIT(1)\n#define CCGX_RAB_UCSI_DATA_BLOCK(offset)\t(0xf000 | ((offset) & 0xff))\n#define REG_FLASH_RW_MEM        0x0200\n#define DEV_REG_IDX\t\t\t\tCCGX_RAB_DEVICE_MODE\n#define CCGX_RAB_PDPORT_ENABLE\t\t\t0x002C\n#define  PDPORT_1\t\tBIT(0)\n#define  PDPORT_2\t\tBIT(1)\n#define CCGX_RAB_RESPONSE\t\t\t0x007E\n#define  ASYNC_EVENT\t\t\t\tBIT(7)\n\n \n#define RESET_COMPLETE\t\t0x80\n#define EVENT_INDEX\t\tRESET_COMPLETE\n#define PORT_CONNECT_DET\t0x84\n#define PORT_DISCONNECT_DET\t0x85\n#define ROLE_SWAP_COMPELETE\t0x87\n\n \n#define CYACD_LINE_SIZE         527\n#define CCG4_ROW_SIZE           256\n#define FW1_METADATA_ROW        0x1FF\n#define FW2_METADATA_ROW        0x1FE\n#define FW_CFG_TABLE_SIG_SIZE\t256\n\nstatic int secondary_fw_min_ver = 41;\n\nenum enum_flash_mode {\n\tSECONDARY_BL,\t \n\tPRIMARY,\t \n\tSECONDARY,\t \n\tFLASH_NOT_NEEDED,\t \n\tFLASH_INVALID,\n};\n\nstatic const char * const ccg_fw_names[] = {\n\t\"ccg_boot.cyacd\",\n\t\"ccg_primary.cyacd\",\n\t\"ccg_secondary.cyacd\"\n};\n\nstruct ccg_dev_info {\n#define CCG_DEVINFO_FWMODE_SHIFT (0)\n#define CCG_DEVINFO_FWMODE_MASK (0x3 << CCG_DEVINFO_FWMODE_SHIFT)\n#define CCG_DEVINFO_PDPORTS_SHIFT (2)\n#define CCG_DEVINFO_PDPORTS_MASK (0x3 << CCG_DEVINFO_PDPORTS_SHIFT)\n\tu8 mode;\n\tu8 bl_mode;\n\t__le16 silicon_id;\n\t__le16 bl_last_row;\n} __packed;\n\nstruct version_format {\n\t__le16 build;\n\tu8 patch;\n\tu8 ver;\n#define CCG_VERSION_PATCH(x) ((x) << 16)\n#define CCG_VERSION(x)\t((x) << 24)\n#define CCG_VERSION_MIN_SHIFT (0)\n#define CCG_VERSION_MIN_MASK (0xf << CCG_VERSION_MIN_SHIFT)\n#define CCG_VERSION_MAJ_SHIFT (4)\n#define CCG_VERSION_MAJ_MASK (0xf << CCG_VERSION_MAJ_SHIFT)\n} __packed;\n\n \n#define CCG_FW_BUILD_NVIDIA\t(('n' << 8) | 'v')\n#define CCG_OLD_FW_VERSION\t(CCG_VERSION(0x31) | CCG_VERSION_PATCH(10))\n\n \n#define CCG_FW_BUILD_NVIDIA_TEGRA\t(('g' << 8) | 'n')\n\n \n#define NVIDIA_FTB_DP_OFFSET\t(2)\n#define NVIDIA_FTB_DBG_OFFSET\t(3)\n\nstruct version_info {\n\tstruct version_format base;\n\tstruct version_format app;\n};\n\nstruct fw_config_table {\n\tu32 identity;\n\tu16 table_size;\n\tu8 fwct_version;\n\tu8 is_key_change;\n\tu8 guid[16];\n\tstruct version_format base;\n\tstruct version_format app;\n\tu8 primary_fw_digest[32];\n\tu32 key_exp_length;\n\tu8 key_modulus[256];\n\tu8 key_exp[4];\n};\n\n \nenum ccg_resp_code {\n\tCMD_NO_RESP             = 0x00,\n\tCMD_SUCCESS             = 0x02,\n\tFLASH_DATA_AVAILABLE    = 0x03,\n\tCMD_INVALID             = 0x05,\n\tFLASH_UPDATE_FAIL       = 0x07,\n\tINVALID_FW              = 0x08,\n\tINVALID_ARG             = 0x09,\n\tCMD_NOT_SUPPORT         = 0x0A,\n\tTRANSACTION_FAIL        = 0x0C,\n\tPD_CMD_FAIL             = 0x0D,\n\tUNDEF_ERROR             = 0x0F,\n\tINVALID_RESP\t\t= 0x10,\n};\n\n#define CCG_EVENT_MAX\t(EVENT_INDEX + 43)\n\nstruct ccg_cmd {\n\tu16 reg;\n\tu32 data;\n\tint len;\n\tu32 delay;  \n};\n\nstruct ccg_resp {\n\tu8 code;\n\tu8 length;\n};\n\nstruct ucsi_ccg_altmode {\n\tu16 svid;\n\tu32 mid;\n\tu8 linked_idx;\n\tu8 active_idx;\n#define UCSI_MULTI_DP_INDEX\t(0xff)\n\tbool checked;\n} __packed;\n\nstruct ucsi_ccg {\n\tstruct device *dev;\n\tstruct ucsi *ucsi;\n\tstruct i2c_client *client;\n\n\tstruct ccg_dev_info info;\n\t \n\tstruct version_info version[FW2 + 1];\n\tu32 fw_version;\n\t \n\tunsigned long flags;\n#define RESET_PENDING\t0\n#define DEV_CMD_PENDING\t1\n\tstruct ccg_resp dev_resp;\n\tu8 cmd_resp;\n\tint port_num;\n\tint irq;\n\tstruct work_struct work;\n\tstruct mutex lock;  \n\n\t \n\tu16 fw_build;\n\tstruct work_struct pm_work;\n\n\tstruct completion complete;\n\n\tu64 last_cmd_sent;\n\tbool has_multiple_dp;\n\tstruct ucsi_ccg_altmode orig[UCSI_MAX_ALTMODES];\n\tstruct ucsi_ccg_altmode updated[UCSI_MAX_ALTMODES];\n};\n\nstatic int ccg_read(struct ucsi_ccg *uc, u16 rab, u8 *data, u32 len)\n{\n\tstruct i2c_client *client = uc->client;\n\tconst struct i2c_adapter_quirks *quirks = client->adapter->quirks;\n\tunsigned char buf[2];\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0x0,\n\t\t\t.len\t= sizeof(buf),\n\t\t\t.buf\t= buf,\n\t\t},\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = I2C_M_RD,\n\t\t\t.buf\t= data,\n\t\t},\n\t};\n\tu32 rlen, rem_len = len, max_read_len = len;\n\tint status;\n\n\t \n\tif (quirks && quirks->max_read_len)\n\t\tmax_read_len = quirks->max_read_len;\n\n\tpm_runtime_get_sync(uc->dev);\n\twhile (rem_len > 0) {\n\t\tmsgs[1].buf = &data[len - rem_len];\n\t\trlen = min_t(u16, rem_len, max_read_len);\n\t\tmsgs[1].len = rlen;\n\t\tput_unaligned_le16(rab, buf);\n\t\tstatus = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\t\tif (status < 0) {\n\t\t\tdev_err(uc->dev, \"i2c_transfer failed %d\\n\", status);\n\t\t\tpm_runtime_put_sync(uc->dev);\n\t\t\treturn status;\n\t\t}\n\t\trab += rlen;\n\t\trem_len -= rlen;\n\t}\n\n\tpm_runtime_put_sync(uc->dev);\n\treturn 0;\n}\n\nstatic int ccg_write(struct ucsi_ccg *uc, u16 rab, const u8 *data, u32 len)\n{\n\tstruct i2c_client *client = uc->client;\n\tunsigned char *buf;\n\tstruct i2c_msg msgs[] = {\n\t\t{\n\t\t\t.addr\t= client->addr,\n\t\t\t.flags  = 0x0,\n\t\t}\n\t};\n\tint status;\n\n\tbuf = kzalloc(len + sizeof(rab), GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tput_unaligned_le16(rab, buf);\n\tmemcpy(buf + sizeof(rab), data, len);\n\n\tmsgs[0].len = len + sizeof(rab);\n\tmsgs[0].buf = buf;\n\n\tpm_runtime_get_sync(uc->dev);\n\tstatus = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));\n\tif (status < 0) {\n\t\tdev_err(uc->dev, \"i2c_transfer failed %d\\n\", status);\n\t\tpm_runtime_put_sync(uc->dev);\n\t\tkfree(buf);\n\t\treturn status;\n\t}\n\n\tpm_runtime_put_sync(uc->dev);\n\tkfree(buf);\n\treturn 0;\n}\n\nstatic int ucsi_ccg_init(struct ucsi_ccg *uc)\n{\n\tunsigned int count = 10;\n\tu8 data;\n\tint status;\n\n\tdata = CCGX_RAB_UCSI_CONTROL_STOP;\n\tstatus = ccg_write(uc, CCGX_RAB_UCSI_CONTROL, &data, sizeof(data));\n\tif (status < 0)\n\t\treturn status;\n\n\tdata = CCGX_RAB_UCSI_CONTROL_START;\n\tstatus = ccg_write(uc, CCGX_RAB_UCSI_CONTROL, &data, sizeof(data));\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tdo {\n\t\tstatus = ccg_read(uc, CCGX_RAB_INTR_REG, &data, sizeof(data));\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (!(data & DEV_INT))\n\t\t\treturn 0;\n\n\t\tstatus = ccg_write(uc, CCGX_RAB_INTR_REG, &data, sizeof(data));\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tusleep_range(10000, 11000);\n\t} while (--count);\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void ucsi_ccg_update_get_current_cam_cmd(struct ucsi_ccg *uc, u8 *data)\n{\n\tu8 cam, new_cam;\n\n\tcam = data[0];\n\tnew_cam = uc->orig[cam].linked_idx;\n\tuc->updated[new_cam].active_idx = cam;\n\tdata[0] = new_cam;\n}\n\nstatic bool ucsi_ccg_update_altmodes(struct ucsi *ucsi,\n\t\t\t\t     struct ucsi_altmode *orig,\n\t\t\t\t     struct ucsi_altmode *updated)\n{\n\tstruct ucsi_ccg *uc = ucsi_get_drvdata(ucsi);\n\tstruct ucsi_ccg_altmode *alt, *new_alt;\n\tint i, j, k = 0;\n\tbool found = false;\n\n\talt = uc->orig;\n\tnew_alt = uc->updated;\n\tmemset(uc->updated, 0, sizeof(uc->updated));\n\n\t \n\tfor (i = 0; i < UCSI_MAX_ALTMODES; i++) {\n\t\talt[i].svid = orig[i].svid;\n\t\talt[i].mid = orig[i].mid;\n\t\tif (!alt[i].svid)\n\t\t\tbreak;\n\t}\n\n\tfor (i = 0; i < UCSI_MAX_ALTMODES; i++) {\n\t\tif (!alt[i].svid)\n\t\t\tbreak;\n\n\t\t \n\t\tif (alt[i].checked)\n\t\t\tcontinue;\n\n\t\tif (!DP_CONF_GET_PIN_ASSIGN(alt[i].mid)) {\n\t\t\t \n\t\t\tnew_alt[k].svid = alt[i].svid;\n\t\t\tnew_alt[k].mid |= alt[i].mid;\n\t\t\tnew_alt[k].linked_idx = i;\n\t\t\talt[i].linked_idx = k;\n\t\t\tupdated[k].svid = new_alt[k].svid;\n\t\t\tupdated[k].mid = new_alt[k].mid;\n\t\t\tk++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = i + 1; j < UCSI_MAX_ALTMODES; j++) {\n\t\t\tif (alt[i].svid != alt[j].svid ||\n\t\t\t    !DP_CONF_GET_PIN_ASSIGN(alt[j].mid)) {\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tnew_alt[k].svid = alt[i].svid;\n\t\t\t\tnew_alt[k].mid |= alt[i].mid | alt[j].mid;\n\t\t\t\tnew_alt[k].linked_idx = UCSI_MULTI_DP_INDEX;\n\t\t\t\talt[i].linked_idx = k;\n\t\t\t\talt[j].linked_idx = k;\n\t\t\t\talt[j].checked = true;\n\t\t\t\tfound = true;\n\t\t\t}\n\t\t}\n\t\tif (found) {\n\t\t\tuc->has_multiple_dp = true;\n\t\t} else {\n\t\t\t \n\t\t\tnew_alt[k].svid = alt[i].svid;\n\t\t\tnew_alt[k].mid |= alt[i].mid;\n\t\t\tnew_alt[k].linked_idx = i;\n\t\t\talt[i].linked_idx = k;\n\t\t}\n\t\tupdated[k].svid = new_alt[k].svid;\n\t\tupdated[k].mid = new_alt[k].mid;\n\t\tk++;\n\t}\n\treturn found;\n}\n\nstatic void ucsi_ccg_update_set_new_cam_cmd(struct ucsi_ccg *uc,\n\t\t\t\t\t    struct ucsi_connector *con,\n\t\t\t\t\t    u64 *cmd)\n{\n\tstruct ucsi_ccg_altmode *new_port, *port;\n\tstruct typec_altmode *alt = NULL;\n\tu8 new_cam, cam, pin;\n\tbool enter_new_mode;\n\tint i, j, k = 0xff;\n\n\tport = uc->orig;\n\tnew_cam = UCSI_SET_NEW_CAM_GET_AM(*cmd);\n\tnew_port = &uc->updated[new_cam];\n\tcam = new_port->linked_idx;\n\tenter_new_mode = UCSI_SET_NEW_CAM_ENTER(*cmd);\n\n\t \n\tif (cam == UCSI_MULTI_DP_INDEX) {\n\t\tif (enter_new_mode) {\n\t\t\tfor (i = 0; con->partner_altmode[i]; i++) {\n\t\t\t\talt = con->partner_altmode[i];\n\t\t\t\tif (alt->svid == new_port->svid)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tfor (j = 0; port[j].svid; j++) {\n\t\t\t\tpin = DP_CONF_GET_PIN_ASSIGN(port[j].mid);\n\t\t\t\tif (alt && port[j].svid == alt->svid &&\n\t\t\t\t    (pin & DP_CONF_GET_PIN_ASSIGN(alt->vdo))) {\n\t\t\t\t\t \n\t\t\t\t\tif (k == 0xff || (k != 0xff && pin >\n\t\t\t\t\t    DP_CONF_GET_PIN_ASSIGN(port[k].mid))\n\t\t\t\t\t    ) {\n\t\t\t\t\t\tk = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcam = k;\n\t\t\tnew_port->active_idx = cam;\n\t\t} else {\n\t\t\tcam = new_port->active_idx;\n\t\t}\n\t}\n\t*cmd &= ~UCSI_SET_NEW_CAM_AM_MASK;\n\t*cmd |= UCSI_SET_NEW_CAM_SET_AM(cam);\n}\n\n \nstatic void ucsi_ccg_nvidia_altmode(struct ucsi_ccg *uc,\n\t\t\t\t    struct ucsi_altmode *alt)\n{\n\tswitch (UCSI_ALTMODE_OFFSET(uc->last_cmd_sent)) {\n\tcase NVIDIA_FTB_DP_OFFSET:\n\t\tif (alt[0].mid == USB_TYPEC_NVIDIA_VLINK_DBG_VDO)\n\t\t\talt[0].mid = USB_TYPEC_NVIDIA_VLINK_DP_VDO |\n\t\t\t\tDP_CAP_DP_SIGNALING | DP_CAP_USB |\n\t\t\t\tDP_CONF_SET_PIN_ASSIGN(BIT(DP_PIN_ASSIGN_E));\n\t\tbreak;\n\tcase NVIDIA_FTB_DBG_OFFSET:\n\t\tif (alt[0].mid == USB_TYPEC_NVIDIA_VLINK_DP_VDO)\n\t\t\talt[0].mid = USB_TYPEC_NVIDIA_VLINK_DBG_VDO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int ucsi_ccg_read(struct ucsi *ucsi, unsigned int offset,\n\t\t\t void *val, size_t val_len)\n{\n\tstruct ucsi_ccg *uc = ucsi_get_drvdata(ucsi);\n\tu16 reg = CCGX_RAB_UCSI_DATA_BLOCK(offset);\n\tstruct ucsi_capability *cap;\n\tstruct ucsi_altmode *alt;\n\tint ret;\n\n\tret = ccg_read(uc, reg, val, val_len);\n\tif (ret)\n\t\treturn ret;\n\n\tif (offset != UCSI_MESSAGE_IN)\n\t\treturn ret;\n\n\tswitch (UCSI_COMMAND(uc->last_cmd_sent)) {\n\tcase UCSI_GET_CURRENT_CAM:\n\t\tif (uc->has_multiple_dp)\n\t\t\tucsi_ccg_update_get_current_cam_cmd(uc, (u8 *)val);\n\t\tbreak;\n\tcase UCSI_GET_ALTERNATE_MODES:\n\t\tif (UCSI_ALTMODE_RECIPIENT(uc->last_cmd_sent) ==\n\t\t    UCSI_RECIPIENT_SOP) {\n\t\t\talt = val;\n\t\t\tif (alt[0].svid == USB_TYPEC_NVIDIA_VLINK_SID)\n\t\t\t\tucsi_ccg_nvidia_altmode(uc, alt);\n\t\t}\n\t\tbreak;\n\tcase UCSI_GET_CAPABILITY:\n\t\tif (uc->fw_build == CCG_FW_BUILD_NVIDIA_TEGRA) {\n\t\t\tcap = val;\n\t\t\tcap->features &= ~UCSI_CAP_ALT_MODE_DETAILS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tuc->last_cmd_sent = 0;\n\n\treturn ret;\n}\n\nstatic int ucsi_ccg_async_write(struct ucsi *ucsi, unsigned int offset,\n\t\t\t\tconst void *val, size_t val_len)\n{\n\tu16 reg = CCGX_RAB_UCSI_DATA_BLOCK(offset);\n\n\treturn ccg_write(ucsi_get_drvdata(ucsi), reg, val, val_len);\n}\n\nstatic int ucsi_ccg_sync_write(struct ucsi *ucsi, unsigned int offset,\n\t\t\t       const void *val, size_t val_len)\n{\n\tstruct ucsi_ccg *uc = ucsi_get_drvdata(ucsi);\n\tstruct ucsi_connector *con;\n\tint con_index;\n\tint ret;\n\n\tmutex_lock(&uc->lock);\n\tpm_runtime_get_sync(uc->dev);\n\tset_bit(DEV_CMD_PENDING, &uc->flags);\n\n\tif (offset == UCSI_CONTROL && val_len == sizeof(uc->last_cmd_sent)) {\n\t\tuc->last_cmd_sent = *(u64 *)val;\n\n\t\tif (UCSI_COMMAND(uc->last_cmd_sent) == UCSI_SET_NEW_CAM &&\n\t\t    uc->has_multiple_dp) {\n\t\t\tcon_index = (uc->last_cmd_sent >> 16) &\n\t\t\t\t    UCSI_CMD_CONNECTOR_MASK;\n\t\t\tcon = &uc->ucsi->connector[con_index - 1];\n\t\t\tucsi_ccg_update_set_new_cam_cmd(uc, con, (u64 *)val);\n\t\t}\n\t}\n\n\tret = ucsi_ccg_async_write(ucsi, offset, val, val_len);\n\tif (ret)\n\t\tgoto err_clear_bit;\n\n\tif (!wait_for_completion_timeout(&uc->complete, msecs_to_jiffies(5000)))\n\t\tret = -ETIMEDOUT;\n\nerr_clear_bit:\n\tclear_bit(DEV_CMD_PENDING, &uc->flags);\n\tpm_runtime_put_sync(uc->dev);\n\tmutex_unlock(&uc->lock);\n\n\treturn ret;\n}\n\nstatic const struct ucsi_operations ucsi_ccg_ops = {\n\t.read = ucsi_ccg_read,\n\t.sync_write = ucsi_ccg_sync_write,\n\t.async_write = ucsi_ccg_async_write,\n\t.update_altmodes = ucsi_ccg_update_altmodes\n};\n\nstatic irqreturn_t ccg_irq_handler(int irq, void *data)\n{\n\tu16 reg = CCGX_RAB_UCSI_DATA_BLOCK(UCSI_CCI);\n\tstruct ucsi_ccg *uc = data;\n\tu8 intr_reg;\n\tu32 cci;\n\tint ret;\n\n\tret = ccg_read(uc, CCGX_RAB_INTR_REG, &intr_reg, sizeof(intr_reg));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ccg_read(uc, reg, (void *)&cci, sizeof(cci));\n\tif (ret)\n\t\tgoto err_clear_irq;\n\n\tif (UCSI_CCI_CONNECTOR(cci))\n\t\tucsi_connector_change(uc->ucsi, UCSI_CCI_CONNECTOR(cci));\n\n\tif (test_bit(DEV_CMD_PENDING, &uc->flags) &&\n\t    cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))\n\t\tcomplete(&uc->complete);\n\nerr_clear_irq:\n\tccg_write(uc, CCGX_RAB_INTR_REG, &intr_reg, sizeof(intr_reg));\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ccg_request_irq(struct ucsi_ccg *uc)\n{\n\tunsigned long flags = IRQF_ONESHOT;\n\n\tif (!dev_fwnode(uc->dev))\n\t\tflags |= IRQF_TRIGGER_HIGH;\n\n\treturn request_threaded_irq(uc->irq, NULL, ccg_irq_handler, flags, dev_name(uc->dev), uc);\n}\n\nstatic void ccg_pm_workaround_work(struct work_struct *pm_work)\n{\n\tccg_irq_handler(0, container_of(pm_work, struct ucsi_ccg, pm_work));\n}\n\nstatic int get_fw_info(struct ucsi_ccg *uc)\n{\n\tint err;\n\n\terr = ccg_read(uc, CCGX_RAB_READ_ALL_VER, (u8 *)(&uc->version),\n\t\t       sizeof(uc->version));\n\tif (err < 0)\n\t\treturn err;\n\n\tuc->fw_version = CCG_VERSION(uc->version[FW2].app.ver) |\n\t\t\tCCG_VERSION_PATCH(uc->version[FW2].app.patch);\n\n\terr = ccg_read(uc, CCGX_RAB_DEVICE_MODE, (u8 *)(&uc->info),\n\t\t       sizeof(uc->info));\n\tif (err < 0)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic inline bool invalid_async_evt(int code)\n{\n\treturn (code >= CCG_EVENT_MAX) || (code < EVENT_INDEX);\n}\n\nstatic void ccg_process_response(struct ucsi_ccg *uc)\n{\n\tstruct device *dev = uc->dev;\n\n\tif (uc->dev_resp.code & ASYNC_EVENT) {\n\t\tif (uc->dev_resp.code == RESET_COMPLETE) {\n\t\t\tif (test_bit(RESET_PENDING, &uc->flags))\n\t\t\t\tuc->cmd_resp = uc->dev_resp.code;\n\t\t\tget_fw_info(uc);\n\t\t}\n\t\tif (invalid_async_evt(uc->dev_resp.code))\n\t\t\tdev_err(dev, \"invalid async evt %d\\n\",\n\t\t\t\tuc->dev_resp.code);\n\t} else {\n\t\tif (test_bit(DEV_CMD_PENDING, &uc->flags)) {\n\t\t\tuc->cmd_resp = uc->dev_resp.code;\n\t\t\tclear_bit(DEV_CMD_PENDING, &uc->flags);\n\t\t} else {\n\t\t\tdev_err(dev, \"dev resp 0x%04x but no cmd pending\\n\",\n\t\t\t\tuc->dev_resp.code);\n\t\t}\n\t}\n}\n\nstatic int ccg_read_response(struct ucsi_ccg *uc)\n{\n\tunsigned long target = jiffies + msecs_to_jiffies(1000);\n\tstruct device *dev = uc->dev;\n\tu8 intval;\n\tint status;\n\n\t \n\tdo {\n\t\tstatus = ccg_read(uc, CCGX_RAB_INTR_REG, &intval,\n\t\t\t\t  sizeof(intval));\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tif (intval & DEV_INT)\n\t\t\tbreak;\n\t\tusleep_range(500, 600);\n\t} while (time_is_after_jiffies(target));\n\n\tif (time_is_before_jiffies(target)) {\n\t\tdev_err(dev, \"response timeout error\\n\");\n\t\treturn -ETIME;\n\t}\n\n\tstatus = ccg_read(uc, CCGX_RAB_RESPONSE, (u8 *)&uc->dev_resp,\n\t\t\t  sizeof(uc->dev_resp));\n\tif (status < 0)\n\t\treturn status;\n\n\tstatus = ccg_write(uc, CCGX_RAB_INTR_REG, &intval, sizeof(intval));\n\tif (status < 0)\n\t\treturn status;\n\n\treturn 0;\n}\n\n \nstatic int ccg_send_command(struct ucsi_ccg *uc, struct ccg_cmd *cmd)\n{\n\tstruct device *dev = uc->dev;\n\tint ret;\n\n\tswitch (cmd->reg & 0xF000) {\n\tcase DEV_REG_IDX:\n\t\tset_bit(DEV_CMD_PENDING, &uc->flags);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"invalid cmd register\\n\");\n\t\tbreak;\n\t}\n\n\tret = ccg_write(uc, cmd->reg, (u8 *)&cmd->data, cmd->len);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tmsleep(cmd->delay);\n\n\tret = ccg_read_response(uc);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"response read error\\n\");\n\t\tswitch (cmd->reg & 0xF000) {\n\t\tcase DEV_REG_IDX:\n\t\t\tclear_bit(DEV_CMD_PENDING, &uc->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"invalid cmd register\\n\");\n\t\t\tbreak;\n\t\t}\n\t\treturn -EIO;\n\t}\n\tccg_process_response(uc);\n\n\treturn uc->cmd_resp;\n}\n\nstatic int ccg_cmd_enter_flashing(struct ucsi_ccg *uc)\n{\n\tstruct ccg_cmd cmd;\n\tint ret;\n\n\tcmd.reg = CCGX_RAB_ENTER_FLASHING;\n\tcmd.data = FLASH_ENTER_SIG;\n\tcmd.len = 1;\n\tcmd.delay = 50;\n\n\tmutex_lock(&uc->lock);\n\n\tret = ccg_send_command(uc, &cmd);\n\n\tmutex_unlock(&uc->lock);\n\n\tif (ret != CMD_SUCCESS) {\n\t\tdev_err(uc->dev, \"enter flashing failed ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccg_cmd_reset(struct ucsi_ccg *uc)\n{\n\tstruct ccg_cmd cmd;\n\tu8 *p;\n\tint ret;\n\n\tp = (u8 *)&cmd.data;\n\tcmd.reg = CCGX_RAB_RESET_REQ;\n\tp[0] = RESET_SIG;\n\tp[1] = CMD_RESET_DEV;\n\tcmd.len = 2;\n\tcmd.delay = 5000;\n\n\tmutex_lock(&uc->lock);\n\n\tset_bit(RESET_PENDING, &uc->flags);\n\n\tret = ccg_send_command(uc, &cmd);\n\tif (ret != RESET_COMPLETE)\n\t\tgoto err_clear_flag;\n\n\tret = 0;\n\nerr_clear_flag:\n\tclear_bit(RESET_PENDING, &uc->flags);\n\n\tmutex_unlock(&uc->lock);\n\n\treturn ret;\n}\n\nstatic int ccg_cmd_port_control(struct ucsi_ccg *uc, bool enable)\n{\n\tstruct ccg_cmd cmd;\n\tint ret;\n\n\tcmd.reg = CCGX_RAB_PDPORT_ENABLE;\n\tif (enable)\n\t\tcmd.data = (uc->port_num == 1) ?\n\t\t\t    PDPORT_1 : (PDPORT_1 | PDPORT_2);\n\telse\n\t\tcmd.data = 0x0;\n\tcmd.len = 1;\n\tcmd.delay = 10;\n\n\tmutex_lock(&uc->lock);\n\n\tret = ccg_send_command(uc, &cmd);\n\n\tmutex_unlock(&uc->lock);\n\n\tif (ret != CMD_SUCCESS) {\n\t\tdev_err(uc->dev, \"port control failed ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\treturn 0;\n}\n\nstatic int ccg_cmd_jump_boot_mode(struct ucsi_ccg *uc, int bl_mode)\n{\n\tstruct ccg_cmd cmd;\n\tint ret;\n\n\tcmd.reg = CCGX_RAB_JUMP_TO_BOOT;\n\n\tif (bl_mode)\n\t\tcmd.data = TO_BOOT;\n\telse\n\t\tcmd.data = TO_ALT_FW;\n\n\tcmd.len = 1;\n\tcmd.delay = 100;\n\n\tmutex_lock(&uc->lock);\n\n\tset_bit(RESET_PENDING, &uc->flags);\n\n\tret = ccg_send_command(uc, &cmd);\n\tif (ret != RESET_COMPLETE)\n\t\tgoto err_clear_flag;\n\n\tret = 0;\n\nerr_clear_flag:\n\tclear_bit(RESET_PENDING, &uc->flags);\n\n\tmutex_unlock(&uc->lock);\n\n\treturn ret;\n}\n\nstatic int\nccg_cmd_write_flash_row(struct ucsi_ccg *uc, u16 row,\n\t\t\tconst void *data, u8 fcmd)\n{\n\tstruct i2c_client *client = uc->client;\n\tstruct ccg_cmd cmd;\n\tu8 buf[CCG4_ROW_SIZE + 2];\n\tu8 *p;\n\tint ret;\n\n\t \n\tput_unaligned_le16(REG_FLASH_RW_MEM, buf);\n\n\tmemcpy(buf + 2, data, CCG4_ROW_SIZE);\n\n\tmutex_lock(&uc->lock);\n\n\tret = i2c_master_send(client, buf, CCG4_ROW_SIZE + 2);\n\tif (ret != CCG4_ROW_SIZE + 2) {\n\t\tdev_err(uc->dev, \"REG_FLASH_RW_MEM write fail %d\\n\", ret);\n\t\tmutex_unlock(&uc->lock);\n\t\treturn ret < 0 ? ret : -EIO;\n\t}\n\n\t \n\t \n\tp = (u8 *)&cmd.data;\n\tcmd.reg = CCGX_RAB_FLASH_ROW_RW;\n\tp[0] = FLASH_SIG;\n\tp[1] = fcmd;\n\tput_unaligned_le16(row, &p[2]);\n\tcmd.len = 4;\n\tcmd.delay = 50;\n\tif (fcmd == FLASH_FWCT_SIG_WR_CMD)\n\t\tcmd.delay += 400;\n\tif (row == 510)\n\t\tcmd.delay += 220;\n\tret = ccg_send_command(uc, &cmd);\n\n\tmutex_unlock(&uc->lock);\n\n\tif (ret != CMD_SUCCESS) {\n\t\tdev_err(uc->dev, \"write flash row failed ret=%d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ccg_cmd_validate_fw(struct ucsi_ccg *uc, unsigned int fwid)\n{\n\tstruct ccg_cmd cmd;\n\tint ret;\n\n\tcmd.reg = CCGX_RAB_VALIDATE_FW;\n\tcmd.data = fwid;\n\tcmd.len = 1;\n\tcmd.delay = 500;\n\n\tmutex_lock(&uc->lock);\n\n\tret = ccg_send_command(uc, &cmd);\n\n\tmutex_unlock(&uc->lock);\n\n\tif (ret != CMD_SUCCESS)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic bool ccg_check_vendor_version(struct ucsi_ccg *uc,\n\t\t\t\t     struct version_format *app,\n\t\t\t\t     struct fw_config_table *fw_cfg)\n{\n\tstruct device *dev = uc->dev;\n\n\t \n\tif (le16_to_cpu(app->build) != uc->fw_build) {\n\t\tdev_info(dev, \"current fw is not from supported vendor\\n\");\n\t\treturn false;\n\t}\n\n\t \n\tif (le16_to_cpu(fw_cfg->app.build) != uc->fw_build) {\n\t\tdev_info(dev, \"new fw is not from supported vendor\\n\");\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool ccg_check_fw_version(struct ucsi_ccg *uc, const char *fw_name,\n\t\t\t\t struct version_format *app)\n{\n\tconst struct firmware *fw = NULL;\n\tstruct device *dev = uc->dev;\n\tstruct fw_config_table fw_cfg;\n\tu32 cur_version, new_version;\n\tbool is_later = false;\n\n\tif (request_firmware(&fw, fw_name, dev) != 0) {\n\t\tdev_err(dev, \"error: Failed to open cyacd file %s\\n\", fw_name);\n\t\treturn false;\n\t}\n\n\t \n\tif (fw->size < sizeof(fw_cfg) + FW_CFG_TABLE_SIG_SIZE)\n\t\tgoto out_release_firmware;\n\n\tmemcpy((uint8_t *)&fw_cfg, fw->data + fw->size -\n\t       sizeof(fw_cfg) - FW_CFG_TABLE_SIG_SIZE, sizeof(fw_cfg));\n\n\tif (fw_cfg.identity != ('F' | 'W' << 8 | 'C' << 16 | 'T' << 24)) {\n\t\tdev_info(dev, \"not a signed image\\n\");\n\t\tgoto out_release_firmware;\n\t}\n\n\t \n\tcur_version = le16_to_cpu(app->build) | CCG_VERSION_PATCH(app->patch) |\n\t\t\tCCG_VERSION(app->ver);\n\n\tnew_version = le16_to_cpu(fw_cfg.app.build) |\n\t\t\tCCG_VERSION_PATCH(fw_cfg.app.patch) |\n\t\t\tCCG_VERSION(fw_cfg.app.ver);\n\n\tif (!ccg_check_vendor_version(uc, app, &fw_cfg))\n\t\tgoto out_release_firmware;\n\n\tif (new_version > cur_version)\n\t\tis_later = true;\n\nout_release_firmware:\n\trelease_firmware(fw);\n\treturn is_later;\n}\n\nstatic int ccg_fw_update_needed(struct ucsi_ccg *uc,\n\t\t\t\tenum enum_flash_mode *mode)\n{\n\tstruct device *dev = uc->dev;\n\tint err;\n\tstruct version_info version[3];\n\n\terr = ccg_read(uc, CCGX_RAB_DEVICE_MODE, (u8 *)(&uc->info),\n\t\t       sizeof(uc->info));\n\tif (err) {\n\t\tdev_err(dev, \"read device mode failed\\n\");\n\t\treturn err;\n\t}\n\n\terr = ccg_read(uc, CCGX_RAB_READ_ALL_VER, (u8 *)version,\n\t\t       sizeof(version));\n\tif (err) {\n\t\tdev_err(dev, \"read device mode failed\\n\");\n\t\treturn err;\n\t}\n\n\tif (memcmp(&version[FW1], \"\\0\\0\\0\\0\\0\\0\\0\\0\",\n\t\t   sizeof(struct version_info)) == 0) {\n\t\tdev_info(dev, \"secondary fw is not flashed\\n\");\n\t\t*mode = SECONDARY_BL;\n\t} else if (le16_to_cpu(version[FW1].base.build) <\n\t\tsecondary_fw_min_ver) {\n\t\tdev_info(dev, \"secondary fw version is too low (< %d)\\n\",\n\t\t\t secondary_fw_min_ver);\n\t\t*mode = SECONDARY;\n\t} else if (memcmp(&version[FW2], \"\\0\\0\\0\\0\\0\\0\\0\\0\",\n\t\t   sizeof(struct version_info)) == 0) {\n\t\tdev_info(dev, \"primary fw is not flashed\\n\");\n\t\t*mode = PRIMARY;\n\t} else if (ccg_check_fw_version(uc, ccg_fw_names[PRIMARY],\n\t\t   &version[FW2].app)) {\n\t\tdev_info(dev, \"found primary fw with later version\\n\");\n\t\t*mode = PRIMARY;\n\t} else {\n\t\tdev_info(dev, \"secondary and primary fw are the latest\\n\");\n\t\t*mode = FLASH_NOT_NEEDED;\n\t}\n\treturn 0;\n}\n\nstatic int do_flash(struct ucsi_ccg *uc, enum enum_flash_mode mode)\n{\n\tstruct device *dev = uc->dev;\n\tconst struct firmware *fw = NULL;\n\tconst char *p, *s;\n\tconst char *eof;\n\tint err, row, len, line_sz, line_cnt = 0;\n\tunsigned long start_time = jiffies;\n\tstruct fw_config_table  fw_cfg;\n\tu8 fw_cfg_sig[FW_CFG_TABLE_SIG_SIZE];\n\tu8 *wr_buf;\n\n\terr = request_firmware(&fw, ccg_fw_names[mode], dev);\n\tif (err) {\n\t\tdev_err(dev, \"request %s failed err=%d\\n\",\n\t\t\tccg_fw_names[mode], err);\n\t\treturn err;\n\t}\n\n\tif (((uc->info.mode & CCG_DEVINFO_FWMODE_MASK) >>\n\t\t\tCCG_DEVINFO_FWMODE_SHIFT) == FW2) {\n\t\terr = ccg_cmd_port_control(uc, false);\n\t\tif (err < 0)\n\t\t\tgoto release_fw;\n\t\terr = ccg_cmd_jump_boot_mode(uc, 0);\n\t\tif (err < 0)\n\t\t\tgoto release_fw;\n\t}\n\n\teof = fw->data + fw->size;\n\n\t \n\tif (fw->size < sizeof(fw_cfg) + sizeof(fw_cfg_sig))\n\t\tgoto not_signed_fw;\n\n\tmemcpy((uint8_t *)&fw_cfg, fw->data + fw->size -\n\t       sizeof(fw_cfg) - sizeof(fw_cfg_sig), sizeof(fw_cfg));\n\n\tif (fw_cfg.identity != ('F' | ('W' << 8) | ('C' << 16) | ('T' << 24))) {\n\t\tdev_info(dev, \"not a signed image\\n\");\n\t\tgoto not_signed_fw;\n\t}\n\teof = fw->data + fw->size - sizeof(fw_cfg) - sizeof(fw_cfg_sig);\n\n\tmemcpy((uint8_t *)&fw_cfg_sig,\n\t       fw->data + fw->size - sizeof(fw_cfg_sig), sizeof(fw_cfg_sig));\n\n\t \n\terr = ccg_cmd_write_flash_row(uc, 0, (u8 *)&fw_cfg,\n\t\t\t\t      FLASH_FWCT1_WR_CMD);\n\tif (err)\n\t\tgoto release_fw;\n\n\terr = ccg_cmd_write_flash_row(uc, 0, (u8 *)&fw_cfg + CCG4_ROW_SIZE,\n\t\t\t\t      FLASH_FWCT2_WR_CMD);\n\tif (err)\n\t\tgoto release_fw;\n\n\terr = ccg_cmd_write_flash_row(uc, 0, &fw_cfg_sig,\n\t\t\t\t      FLASH_FWCT_SIG_WR_CMD);\n\tif (err)\n\t\tgoto release_fw;\n\nnot_signed_fw:\n\twr_buf = kzalloc(CCG4_ROW_SIZE + 4, GFP_KERNEL);\n\tif (!wr_buf) {\n\t\terr = -ENOMEM;\n\t\tgoto release_fw;\n\t}\n\n\terr = ccg_cmd_enter_flashing(uc);\n\tif (err)\n\t\tgoto release_mem;\n\n\t \n\n\tp = strnchr(fw->data, fw->size, ':');\n\twhile (p < eof) {\n\t\ts = strnchr(p + 1, eof - p - 1, ':');\n\n\t\tif (!s)\n\t\t\ts = eof;\n\n\t\tline_sz = s - p;\n\n\t\tif (line_sz != CYACD_LINE_SIZE) {\n\t\t\tdev_err(dev, \"Bad FW format line_sz=%d\\n\", line_sz);\n\t\t\terr =  -EINVAL;\n\t\t\tgoto release_mem;\n\t\t}\n\n\t\tif (hex2bin(wr_buf, p + 3, CCG4_ROW_SIZE + 4)) {\n\t\t\terr =  -EINVAL;\n\t\t\tgoto release_mem;\n\t\t}\n\n\t\trow = get_unaligned_be16(wr_buf);\n\t\tlen = get_unaligned_be16(&wr_buf[2]);\n\n\t\tif (len != CCG4_ROW_SIZE) {\n\t\t\terr =  -EINVAL;\n\t\t\tgoto release_mem;\n\t\t}\n\n\t\terr = ccg_cmd_write_flash_row(uc, row, wr_buf + 4,\n\t\t\t\t\t      FLASH_WR_CMD);\n\t\tif (err)\n\t\t\tgoto release_mem;\n\n\t\tline_cnt++;\n\t\tp = s;\n\t}\n\n\tdev_info(dev, \"total %d row flashed. time: %dms\\n\",\n\t\t line_cnt, jiffies_to_msecs(jiffies - start_time));\n\n\terr = ccg_cmd_validate_fw(uc, (mode == PRIMARY) ? FW2 :  FW1);\n\tif (err)\n\t\tdev_err(dev, \"%s validation failed err=%d\\n\",\n\t\t\t(mode == PRIMARY) ? \"FW2\" :  \"FW1\", err);\n\telse\n\t\tdev_info(dev, \"%s validated\\n\",\n\t\t\t (mode == PRIMARY) ? \"FW2\" :  \"FW1\");\n\n\terr = ccg_cmd_port_control(uc, false);\n\tif (err < 0)\n\t\tgoto release_mem;\n\n\terr = ccg_cmd_reset(uc);\n\tif (err < 0)\n\t\tgoto release_mem;\n\n\terr = ccg_cmd_port_control(uc, true);\n\tif (err < 0)\n\t\tgoto release_mem;\n\nrelease_mem:\n\tkfree(wr_buf);\n\nrelease_fw:\n\trelease_firmware(fw);\n\treturn err;\n}\n\n \nstatic int ccg_fw_update(struct ucsi_ccg *uc, enum enum_flash_mode flash_mode)\n{\n\tint err = 0;\n\n\twhile (flash_mode != FLASH_NOT_NEEDED) {\n\t\terr = do_flash(uc, flash_mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t\terr = ccg_fw_update_needed(uc, &flash_mode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tdev_info(uc->dev, \"CCG FW update successful\\n\");\n\n\treturn err;\n}\n\nstatic int ccg_restart(struct ucsi_ccg *uc)\n{\n\tstruct device *dev = uc->dev;\n\tint status;\n\n\tstatus = ucsi_ccg_init(uc);\n\tif (status < 0) {\n\t\tdev_err(dev, \"ucsi_ccg_start fail, err=%d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = ccg_request_irq(uc);\n\tif (status < 0) {\n\t\tdev_err(dev, \"request_threaded_irq failed - %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = ucsi_register(uc->ucsi);\n\tif (status) {\n\t\tdev_err(uc->dev, \"failed to register the interface\\n\");\n\t\treturn status;\n\t}\n\n\tpm_runtime_enable(uc->dev);\n\treturn 0;\n}\n\nstatic void ccg_update_firmware(struct work_struct *work)\n{\n\tstruct ucsi_ccg *uc = container_of(work, struct ucsi_ccg, work);\n\tenum enum_flash_mode flash_mode;\n\tint status;\n\n\tstatus = ccg_fw_update_needed(uc, &flash_mode);\n\tif (status < 0)\n\t\treturn;\n\n\tif (flash_mode != FLASH_NOT_NEEDED) {\n\t\tucsi_unregister(uc->ucsi);\n\t\tpm_runtime_disable(uc->dev);\n\t\tfree_irq(uc->irq, uc);\n\n\t\tccg_fw_update(uc, flash_mode);\n\t\tccg_restart(uc);\n\t}\n}\n\nstatic ssize_t do_flash_store(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tstruct ucsi_ccg *uc = i2c_get_clientdata(to_i2c_client(dev));\n\tbool flash;\n\n\tif (kstrtobool(buf, &flash))\n\t\treturn -EINVAL;\n\n\tif (!flash)\n\t\treturn n;\n\n\tif (uc->fw_build == 0x0) {\n\t\tdev_err(dev, \"fail to flash FW due to missing FW build info\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tschedule_work(&uc->work);\n\treturn n;\n}\n\nstatic DEVICE_ATTR_WO(do_flash);\n\nstatic struct attribute *ucsi_ccg_attrs[] = {\n\t&dev_attr_do_flash.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(ucsi_ccg);\n\nstatic int ucsi_ccg_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct ucsi_ccg *uc;\n\tconst char *fw_name;\n\tint status;\n\n\tuc = devm_kzalloc(dev, sizeof(*uc), GFP_KERNEL);\n\tif (!uc)\n\t\treturn -ENOMEM;\n\n\tuc->dev = dev;\n\tuc->client = client;\n\tuc->irq = client->irq;\n\tmutex_init(&uc->lock);\n\tinit_completion(&uc->complete);\n\tINIT_WORK(&uc->work, ccg_update_firmware);\n\tINIT_WORK(&uc->pm_work, ccg_pm_workaround_work);\n\n\t \n\tstatus = device_property_read_string(dev, \"firmware-name\", &fw_name);\n\tif (!status) {\n\t\tif (!strcmp(fw_name, \"nvidia,jetson-agx-xavier\"))\n\t\t\tuc->fw_build = CCG_FW_BUILD_NVIDIA_TEGRA;\n\t\telse if (!strcmp(fw_name, \"nvidia,gpu\"))\n\t\t\tuc->fw_build = CCG_FW_BUILD_NVIDIA;\n\t}\n\n\tif (!uc->fw_build)\n\t\tdev_err(uc->dev, \"failed to get FW build information\\n\");\n\n\t \n\tstatus = ucsi_ccg_init(uc);\n\tif (status < 0) {\n\t\tdev_err(uc->dev, \"ucsi_ccg_init failed - %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tstatus = get_fw_info(uc);\n\tif (status < 0) {\n\t\tdev_err(uc->dev, \"get_fw_info failed - %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tuc->port_num = 1;\n\n\tif (uc->info.mode & CCG_DEVINFO_PDPORTS_MASK)\n\t\tuc->port_num++;\n\n\tuc->ucsi = ucsi_create(dev, &ucsi_ccg_ops);\n\tif (IS_ERR(uc->ucsi))\n\t\treturn PTR_ERR(uc->ucsi);\n\n\tucsi_set_drvdata(uc->ucsi, uc);\n\n\tstatus = ccg_request_irq(uc);\n\tif (status < 0) {\n\t\tdev_err(uc->dev, \"request_threaded_irq failed - %d\\n\", status);\n\t\tgoto out_ucsi_destroy;\n\t}\n\n\tstatus = ucsi_register(uc->ucsi);\n\tif (status)\n\t\tgoto out_free_irq;\n\n\ti2c_set_clientdata(client, uc);\n\n\tpm_runtime_set_active(uc->dev);\n\tpm_runtime_enable(uc->dev);\n\tpm_runtime_use_autosuspend(uc->dev);\n\tpm_runtime_set_autosuspend_delay(uc->dev, 5000);\n\tpm_runtime_idle(uc->dev);\n\n\treturn 0;\n\nout_free_irq:\n\tfree_irq(uc->irq, uc);\nout_ucsi_destroy:\n\tucsi_destroy(uc->ucsi);\n\n\treturn status;\n}\n\nstatic void ucsi_ccg_remove(struct i2c_client *client)\n{\n\tstruct ucsi_ccg *uc = i2c_get_clientdata(client);\n\n\tcancel_work_sync(&uc->pm_work);\n\tcancel_work_sync(&uc->work);\n\tpm_runtime_disable(uc->dev);\n\tucsi_unregister(uc->ucsi);\n\tucsi_destroy(uc->ucsi);\n\tfree_irq(uc->irq, uc);\n}\n\nstatic const struct of_device_id ucsi_ccg_of_match_table[] = {\n\t\t{ .compatible = \"cypress,cypd4226\", },\n\t\t{   }\n};\nMODULE_DEVICE_TABLE(of, ucsi_ccg_of_match_table);\n\nstatic const struct i2c_device_id ucsi_ccg_device_id[] = {\n\t{\"ccgx-ucsi\", 0},\n\t{}\n};\nMODULE_DEVICE_TABLE(i2c, ucsi_ccg_device_id);\n\nstatic const struct acpi_device_id amd_i2c_ucsi_match[] = {\n\t{\"AMDI0042\"},\n\t{}\n};\nMODULE_DEVICE_TABLE(acpi, amd_i2c_ucsi_match);\n\nstatic int ucsi_ccg_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ucsi_ccg *uc = i2c_get_clientdata(client);\n\n\treturn ucsi_resume(uc->ucsi);\n}\n\nstatic int ucsi_ccg_runtime_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic int ucsi_ccg_runtime_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct ucsi_ccg *uc = i2c_get_clientdata(client);\n\n\t \n\tif (uc->fw_build == CCG_FW_BUILD_NVIDIA &&\n\t    uc->fw_version <= CCG_OLD_FW_VERSION)\n\t\tschedule_work(&uc->pm_work);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ucsi_ccg_pm = {\n\t.resume = ucsi_ccg_resume,\n\t.runtime_suspend = ucsi_ccg_runtime_suspend,\n\t.runtime_resume = ucsi_ccg_runtime_resume,\n};\n\nstatic struct i2c_driver ucsi_ccg_driver = {\n\t.driver = {\n\t\t.name = \"ucsi_ccg\",\n\t\t.pm = &ucsi_ccg_pm,\n\t\t.dev_groups = ucsi_ccg_groups,\n\t\t.acpi_match_table = amd_i2c_ucsi_match,\n\t\t.of_match_table = ucsi_ccg_of_match_table,\n\t},\n\t.probe = ucsi_ccg_probe,\n\t.remove = ucsi_ccg_remove,\n\t.id_table = ucsi_ccg_device_id,\n};\n\nmodule_i2c_driver(ucsi_ccg_driver);\n\nMODULE_AUTHOR(\"Ajay Gupta <ajayg@nvidia.com>\");\nMODULE_DESCRIPTION(\"UCSI driver for Cypress CCGx Type-C controller\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}