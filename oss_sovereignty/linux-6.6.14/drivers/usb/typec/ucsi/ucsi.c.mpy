{
  "module_name": "ucsi.c",
  "hash_id": "e06f15f3a8f36e769a3d0568be607fefa2dba727658ac99b965560bd0a053795",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/ucsi.c",
  "human_readable_source": "\n \n\n#include <linux/completion.h>\n#include <linux/property.h>\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/usb/typec_dp.h>\n\n#include \"ucsi.h\"\n#include \"trace.h\"\n\n \n#define UCSI_TIMEOUT_MS\t\t5000\n\n \n#define UCSI_SWAP_TIMEOUT_MS\t5000\n\nstatic int ucsi_acknowledge_command(struct ucsi *ucsi)\n{\n\tu64 ctrl;\n\n\tctrl = UCSI_ACK_CC_CI;\n\tctrl |= UCSI_ACK_COMMAND_COMPLETE;\n\n\treturn ucsi->ops->sync_write(ucsi, UCSI_CONTROL, &ctrl, sizeof(ctrl));\n}\n\nstatic int ucsi_acknowledge_connector_change(struct ucsi *ucsi)\n{\n\tu64 ctrl;\n\n\tctrl = UCSI_ACK_CC_CI;\n\tctrl |= UCSI_ACK_CONNECTOR_CHANGE;\n\n\treturn ucsi->ops->sync_write(ucsi, UCSI_CONTROL, &ctrl, sizeof(ctrl));\n}\n\nstatic int ucsi_exec_command(struct ucsi *ucsi, u64 command);\n\nstatic int ucsi_read_error(struct ucsi *ucsi)\n{\n\tu16 error;\n\tint ret;\n\n\t \n\tret = ucsi_acknowledge_command(ucsi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucsi_exec_command(ucsi, UCSI_GET_ERROR_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = ucsi->ops->read(ucsi, UCSI_MESSAGE_IN, &error, sizeof(error));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucsi_acknowledge_command(ucsi);\n\tif (ret)\n\t\treturn ret;\n\n\tswitch (error) {\n\tcase UCSI_ERROR_INCOMPATIBLE_PARTNER:\n\t\treturn -EOPNOTSUPP;\n\tcase UCSI_ERROR_CC_COMMUNICATION_ERR:\n\t\treturn -ECOMM;\n\tcase UCSI_ERROR_CONTRACT_NEGOTIATION_FAIL:\n\t\treturn -EPROTO;\n\tcase UCSI_ERROR_DEAD_BATTERY:\n\t\tdev_warn(ucsi->dev, \"Dead battery condition!\\n\");\n\t\treturn -EPERM;\n\tcase UCSI_ERROR_INVALID_CON_NUM:\n\tcase UCSI_ERROR_UNREGONIZED_CMD:\n\tcase UCSI_ERROR_INVALID_CMD_ARGUMENT:\n\t\tdev_err(ucsi->dev, \"possible UCSI driver bug %u\\n\", error);\n\t\treturn -EINVAL;\n\tcase UCSI_ERROR_OVERCURRENT:\n\t\tdev_warn(ucsi->dev, \"Overcurrent condition\\n\");\n\t\tbreak;\n\tcase UCSI_ERROR_PARTNER_REJECTED_SWAP:\n\t\tdev_warn(ucsi->dev, \"Partner rejected swap\\n\");\n\t\tbreak;\n\tcase UCSI_ERROR_HARD_RESET:\n\t\tdev_warn(ucsi->dev, \"Hard reset occurred\\n\");\n\t\tbreak;\n\tcase UCSI_ERROR_PPM_POLICY_CONFLICT:\n\t\tdev_warn(ucsi->dev, \"PPM Policy conflict\\n\");\n\t\tbreak;\n\tcase UCSI_ERROR_SWAP_REJECTED:\n\t\tdev_warn(ucsi->dev, \"Swap rejected\\n\");\n\t\tbreak;\n\tcase UCSI_ERROR_UNDEFINED:\n\tdefault:\n\t\tdev_err(ucsi->dev, \"unknown error %u\\n\", error);\n\t\tbreak;\n\t}\n\n\treturn -EIO;\n}\n\nstatic int ucsi_exec_command(struct ucsi *ucsi, u64 cmd)\n{\n\tu32 cci;\n\tint ret;\n\n\tret = ucsi->ops->sync_write(ucsi, UCSI_CONTROL, &cmd, sizeof(cmd));\n\tif (ret)\n\t\treturn ret;\n\n\tret = ucsi->ops->read(ucsi, UCSI_CCI, &cci, sizeof(cci));\n\tif (ret)\n\t\treturn ret;\n\n\tif (cmd != UCSI_CANCEL && cci & UCSI_CCI_BUSY)\n\t\treturn ucsi_exec_command(ucsi, UCSI_CANCEL);\n\n\tif (!(cci & UCSI_CCI_COMMAND_COMPLETE))\n\t\treturn -EIO;\n\n\tif (cci & UCSI_CCI_NOT_SUPPORTED)\n\t\treturn -EOPNOTSUPP;\n\n\tif (cci & UCSI_CCI_ERROR) {\n\t\tif (cmd == UCSI_GET_ERROR_STATUS)\n\t\t\treturn -EIO;\n\t\treturn ucsi_read_error(ucsi);\n\t}\n\n\tif (cmd == UCSI_CANCEL && cci & UCSI_CCI_CANCEL_COMPLETE) {\n\t\tret = ucsi_acknowledge_command(ucsi);\n\t\treturn ret ? ret : -EBUSY;\n\t}\n\n\treturn UCSI_CCI_LENGTH(cci);\n}\n\nint ucsi_send_command(struct ucsi *ucsi, u64 command,\n\t\t      void *data, size_t size)\n{\n\tu8 length;\n\tint ret;\n\n\tmutex_lock(&ucsi->ppm_lock);\n\n\tret = ucsi_exec_command(ucsi, command);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlength = ret;\n\n\tif (data) {\n\t\tret = ucsi->ops->read(ucsi, UCSI_MESSAGE_IN, data, size);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = ucsi_acknowledge_command(ucsi);\n\tif (ret)\n\t\tgoto out;\n\n\tret = length;\nout:\n\tmutex_unlock(&ucsi->ppm_lock);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ucsi_send_command);\n\n \n\nstruct ucsi_work {\n\tstruct delayed_work work;\n\tstruct list_head node;\n\tunsigned long delay;\n\tunsigned int count;\n\tstruct ucsi_connector *con;\n\tint (*cb)(struct ucsi_connector *);\n};\n\nstatic void ucsi_poll_worker(struct work_struct *work)\n{\n\tstruct ucsi_work *uwork = container_of(work, struct ucsi_work, work.work);\n\tstruct ucsi_connector *con = uwork->con;\n\tint ret;\n\n\tmutex_lock(&con->lock);\n\n\tif (!con->partner) {\n\t\tlist_del(&uwork->node);\n\t\tmutex_unlock(&con->lock);\n\t\tkfree(uwork);\n\t\treturn;\n\t}\n\n\tret = uwork->cb(con);\n\n\tif (uwork->count-- && (ret == -EBUSY || ret == -ETIMEDOUT)) {\n\t\tqueue_delayed_work(con->wq, &uwork->work, uwork->delay);\n\t} else {\n\t\tlist_del(&uwork->node);\n\t\tkfree(uwork);\n\t}\n\n\tmutex_unlock(&con->lock);\n}\n\nstatic int ucsi_partner_task(struct ucsi_connector *con,\n\t\t\t     int (*cb)(struct ucsi_connector *),\n\t\t\t     int retries, unsigned long delay)\n{\n\tstruct ucsi_work *uwork;\n\n\tif (!con->partner)\n\t\treturn 0;\n\n\tuwork = kzalloc(sizeof(*uwork), GFP_KERNEL);\n\tif (!uwork)\n\t\treturn -ENOMEM;\n\n\tINIT_DELAYED_WORK(&uwork->work, ucsi_poll_worker);\n\tuwork->count = retries;\n\tuwork->delay = delay;\n\tuwork->con = con;\n\tuwork->cb = cb;\n\n\tlist_add_tail(&uwork->node, &con->partner_tasks);\n\tqueue_delayed_work(con->wq, &uwork->work, delay);\n\n\treturn 0;\n}\n\n \n\nvoid ucsi_altmode_update_active(struct ucsi_connector *con)\n{\n\tconst struct typec_altmode *altmode = NULL;\n\tu64 command;\n\tint ret;\n\tu8 cur;\n\tint i;\n\n\tcommand = UCSI_GET_CURRENT_CAM | UCSI_CONNECTOR_NUMBER(con->num);\n\tret = ucsi_send_command(con->ucsi, command, &cur, sizeof(cur));\n\tif (ret < 0) {\n\t\tif (con->ucsi->version > 0x0100) {\n\t\t\tdev_err(con->ucsi->dev,\n\t\t\t\t\"GET_CURRENT_CAM command failed\\n\");\n\t\t\treturn;\n\t\t}\n\t\tcur = 0xff;\n\t}\n\n\tif (cur < UCSI_MAX_ALTMODES)\n\t\taltmode = typec_altmode_get_partner(con->port_altmode[cur]);\n\n\tfor (i = 0; con->partner_altmode[i]; i++)\n\t\ttypec_altmode_update_active(con->partner_altmode[i],\n\t\t\t\t\t    con->partner_altmode[i] == altmode);\n}\n\nstatic int ucsi_altmode_next_mode(struct typec_altmode **alt, u16 svid)\n{\n\tu8 mode = 1;\n\tint i;\n\n\tfor (i = 0; alt[i]; i++) {\n\t\tif (i > MODE_DISCOVERY_MAX)\n\t\t\treturn -ERANGE;\n\n\t\tif (alt[i]->svid == svid)\n\t\t\tmode++;\n\t}\n\n\treturn mode;\n}\n\nstatic int ucsi_next_altmode(struct typec_altmode **alt)\n{\n\tint i = 0;\n\n\tfor (i = 0; i < UCSI_MAX_ALTMODES; i++)\n\t\tif (!alt[i])\n\t\t\treturn i;\n\n\treturn -ENOENT;\n}\n\nstatic int ucsi_get_num_altmode(struct typec_altmode **alt)\n{\n\tint i;\n\n\tfor (i = 0; i < UCSI_MAX_ALTMODES; i++)\n\t\tif (!alt[i])\n\t\t\tbreak;\n\n\treturn i;\n}\n\nstatic int ucsi_register_altmode(struct ucsi_connector *con,\n\t\t\t\t struct typec_altmode_desc *desc,\n\t\t\t\t u8 recipient)\n{\n\tstruct typec_altmode *alt;\n\tbool override;\n\tint ret;\n\tint i;\n\n\toverride = !!(con->ucsi->cap.features & UCSI_CAP_ALT_MODE_OVERRIDE);\n\n\tswitch (recipient) {\n\tcase UCSI_RECIPIENT_CON:\n\t\ti = ucsi_next_altmode(con->port_altmode);\n\t\tif (i < 0) {\n\t\t\tret = i;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = ucsi_altmode_next_mode(con->port_altmode, desc->svid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdesc->mode = ret;\n\n\t\tswitch (desc->svid) {\n\t\tcase USB_TYPEC_DP_SID:\n\t\t\talt = ucsi_register_displayport(con, override, i, desc);\n\t\t\tbreak;\n\t\tcase USB_TYPEC_NVIDIA_VLINK_SID:\n\t\t\tif (desc->vdo == USB_TYPEC_NVIDIA_VLINK_DBG_VDO)\n\t\t\t\talt = typec_port_register_altmode(con->port,\n\t\t\t\t\t\t\t\t  desc);\n\t\t\telse\n\t\t\t\talt = ucsi_register_displayport(con, override,\n\t\t\t\t\t\t\t\ti, desc);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\talt = typec_port_register_altmode(con->port, desc);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (IS_ERR(alt)) {\n\t\t\tret = PTR_ERR(alt);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcon->port_altmode[i] = alt;\n\t\tbreak;\n\tcase UCSI_RECIPIENT_SOP:\n\t\ti = ucsi_next_altmode(con->partner_altmode);\n\t\tif (i < 0) {\n\t\t\tret = i;\n\t\t\tgoto err;\n\t\t}\n\n\t\tret = ucsi_altmode_next_mode(con->partner_altmode, desc->svid);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tdesc->mode = ret;\n\n\t\talt = typec_partner_register_altmode(con->partner, desc);\n\t\tif (IS_ERR(alt)) {\n\t\t\tret = PTR_ERR(alt);\n\t\t\tgoto err;\n\t\t}\n\n\t\tcon->partner_altmode[i] = alt;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_ucsi_register_altmode(recipient, alt);\n\n\treturn 0;\n\nerr:\n\tdev_err(con->ucsi->dev, \"failed to registers svid 0x%04x mode %d\\n\",\n\t\tdesc->svid, desc->mode);\n\n\treturn ret;\n}\n\nstatic int\nucsi_register_altmodes_nvidia(struct ucsi_connector *con, u8 recipient)\n{\n\tint max_altmodes = UCSI_MAX_ALTMODES;\n\tstruct typec_altmode_desc desc;\n\tstruct ucsi_altmode alt;\n\tstruct ucsi_altmode orig[UCSI_MAX_ALTMODES];\n\tstruct ucsi_altmode updated[UCSI_MAX_ALTMODES];\n\tstruct ucsi *ucsi = con->ucsi;\n\tbool multi_dp = false;\n\tu64 command;\n\tint ret;\n\tint len;\n\tint i;\n\tint k = 0;\n\n\tif (recipient == UCSI_RECIPIENT_CON)\n\t\tmax_altmodes = con->ucsi->cap.num_alt_modes;\n\n\tmemset(orig, 0, sizeof(orig));\n\tmemset(updated, 0, sizeof(updated));\n\n\t \n\tfor (i = 0; i < max_altmodes; i++) {\n\t\tmemset(&alt, 0, sizeof(alt));\n\t\tcommand = UCSI_GET_ALTERNATE_MODES;\n\t\tcommand |= UCSI_GET_ALTMODE_RECIPIENT(recipient);\n\t\tcommand |= UCSI_GET_ALTMODE_CONNECTOR_NUMBER(con->num);\n\t\tcommand |= UCSI_GET_ALTMODE_OFFSET(i);\n\t\tlen = ucsi_send_command(con->ucsi, command, &alt, sizeof(alt));\n\t\t \n\t\tif (len < 0)\n\t\t\treturn len;\n\n\t\t \n\t\tif (!len || !alt.svid)\n\t\t\tbreak;\n\n\t\torig[k].mid = alt.mid;\n\t\torig[k].svid = alt.svid;\n\t\tk++;\n\t}\n\t \n\tif (recipient == UCSI_RECIPIENT_CON)\n\t\tmulti_dp = ucsi->ops->update_altmodes(ucsi, orig, updated);\n\n\t \n\tfor (i = 0; i < max_altmodes; i++) {\n\t\tmemset(&desc, 0, sizeof(desc));\n\t\tif (multi_dp && recipient == UCSI_RECIPIENT_CON) {\n\t\t\tdesc.svid = updated[i].svid;\n\t\t\tdesc.vdo = updated[i].mid;\n\t\t} else {\n\t\t\tdesc.svid = orig[i].svid;\n\t\t\tdesc.vdo = orig[i].mid;\n\t\t}\n\t\tdesc.roles = TYPEC_PORT_DRD;\n\n\t\tif (!desc.svid)\n\t\t\treturn 0;\n\n\t\tret = ucsi_register_altmode(con, &desc, recipient);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ucsi_register_altmodes(struct ucsi_connector *con, u8 recipient)\n{\n\tint max_altmodes = UCSI_MAX_ALTMODES;\n\tstruct typec_altmode_desc desc;\n\tstruct ucsi_altmode alt[2];\n\tu64 command;\n\tint num;\n\tint ret;\n\tint len;\n\tint j;\n\tint i;\n\n\tif (!(con->ucsi->cap.features & UCSI_CAP_ALT_MODE_DETAILS))\n\t\treturn 0;\n\n\tif (recipient == UCSI_RECIPIENT_SOP && con->partner_altmode[0])\n\t\treturn 0;\n\n\tif (con->ucsi->ops->update_altmodes)\n\t\treturn ucsi_register_altmodes_nvidia(con, recipient);\n\n\tif (recipient == UCSI_RECIPIENT_CON)\n\t\tmax_altmodes = con->ucsi->cap.num_alt_modes;\n\n\tfor (i = 0; i < max_altmodes;) {\n\t\tmemset(alt, 0, sizeof(alt));\n\t\tcommand = UCSI_GET_ALTERNATE_MODES;\n\t\tcommand |= UCSI_GET_ALTMODE_RECIPIENT(recipient);\n\t\tcommand |= UCSI_GET_ALTMODE_CONNECTOR_NUMBER(con->num);\n\t\tcommand |= UCSI_GET_ALTMODE_OFFSET(i);\n\t\tlen = ucsi_send_command(con->ucsi, command, alt, sizeof(alt));\n\t\tif (len == -EBUSY)\n\t\t\tcontinue;\n\t\tif (len <= 0)\n\t\t\treturn len;\n\n\t\t \n\t\tnum = len / sizeof(alt[0]);\n\t\ti += num;\n\n\t\tfor (j = 0; j < num; j++) {\n\t\t\tif (!alt[j].svid)\n\t\t\t\treturn 0;\n\n\t\t\tmemset(&desc, 0, sizeof(desc));\n\t\t\tdesc.vdo = alt[j].mid;\n\t\t\tdesc.svid = alt[j].svid;\n\t\t\tdesc.roles = TYPEC_PORT_DRD;\n\n\t\t\tret = ucsi_register_altmode(con, &desc, recipient);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ucsi_unregister_altmodes(struct ucsi_connector *con, u8 recipient)\n{\n\tconst struct typec_altmode *pdev;\n\tstruct typec_altmode **adev;\n\tint i = 0;\n\n\tswitch (recipient) {\n\tcase UCSI_RECIPIENT_CON:\n\t\tadev = con->port_altmode;\n\t\tbreak;\n\tcase UCSI_RECIPIENT_SOP:\n\t\tadev = con->partner_altmode;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\twhile (adev[i]) {\n\t\tif (recipient == UCSI_RECIPIENT_SOP &&\n\t\t    (adev[i]->svid == USB_TYPEC_DP_SID ||\n\t\t\t(adev[i]->svid == USB_TYPEC_NVIDIA_VLINK_SID &&\n\t\t\tadev[i]->vdo != USB_TYPEC_NVIDIA_VLINK_DBG_VDO))) {\n\t\t\tpdev = typec_altmode_get_partner(adev[i]);\n\t\t\tucsi_displayport_remove_partner((void *)pdev);\n\t\t}\n\t\ttypec_unregister_altmode(adev[i]);\n\t\tadev[i++] = NULL;\n\t}\n}\n\nstatic int ucsi_read_pdos(struct ucsi_connector *con,\n\t\t\t  enum typec_role role, int is_partner,\n\t\t\t  u32 *pdos, int offset, int num_pdos)\n{\n\tstruct ucsi *ucsi = con->ucsi;\n\tu64 command;\n\tint ret;\n\n\tcommand = UCSI_COMMAND(UCSI_GET_PDOS) | UCSI_CONNECTOR_NUMBER(con->num);\n\tcommand |= UCSI_GET_PDOS_PARTNER_PDO(is_partner);\n\tcommand |= UCSI_GET_PDOS_PDO_OFFSET(offset);\n\tcommand |= UCSI_GET_PDOS_NUM_PDOS(num_pdos - 1);\n\tcommand |= is_source(role) ? UCSI_GET_PDOS_SRC_PDOS : 0;\n\tret = ucsi_send_command(ucsi, command, pdos + offset,\n\t\t\t\tnum_pdos * sizeof(u32));\n\tif (ret < 0 && ret != -ETIMEDOUT)\n\t\tdev_err(ucsi->dev, \"UCSI_GET_PDOS failed (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ucsi_get_pdos(struct ucsi_connector *con, enum typec_role role,\n\t\t\t int is_partner, u32 *pdos)\n{\n\tu8 num_pdos;\n\tint ret;\n\n\t \n\tret = ucsi_read_pdos(con, role, is_partner, pdos, 0, UCSI_MAX_PDOS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tnum_pdos = ret / sizeof(u32);  \n\tif (num_pdos < UCSI_MAX_PDOS)\n\t\treturn num_pdos;\n\n\t \n\tret = ucsi_read_pdos(con, role, is_partner, pdos, UCSI_MAX_PDOS,\n\t\t\t     PDO_MAX_OBJECTS - UCSI_MAX_PDOS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn ret / sizeof(u32) + num_pdos;\n}\n\nstatic int ucsi_get_src_pdos(struct ucsi_connector *con)\n{\n\tint ret;\n\n\tret = ucsi_get_pdos(con, TYPEC_SOURCE, 1, con->src_pdos);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tcon->num_pdos = ret;\n\n\tucsi_port_psy_changed(con);\n\n\treturn ret;\n}\n\nstatic int ucsi_check_altmodes(struct ucsi_connector *con)\n{\n\tint ret, num_partner_am;\n\n\tret = ucsi_register_altmodes(con, UCSI_RECIPIENT_SOP);\n\tif (ret && ret != -ETIMEDOUT)\n\t\tdev_err(con->ucsi->dev,\n\t\t\t\"con%d: failed to register partner alt modes (%d)\\n\",\n\t\t\tcon->num, ret);\n\n\t \n\tif (con->partner_altmode[0]) {\n\t\tnum_partner_am = ucsi_get_num_altmode(con->partner_altmode);\n\t\tif (num_partner_am > 0)\n\t\t\ttypec_partner_set_num_altmodes(con->partner, num_partner_am);\n\t\tucsi_altmode_update_active(con);\n\t\treturn 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int ucsi_register_partner_pdos(struct ucsi_connector *con)\n{\n\tstruct usb_power_delivery_desc desc = { con->ucsi->cap.pd_version };\n\tstruct usb_power_delivery_capabilities_desc caps;\n\tstruct usb_power_delivery_capabilities *cap;\n\tint ret;\n\n\tif (con->partner_pd)\n\t\treturn 0;\n\n\tcon->partner_pd = usb_power_delivery_register(NULL, &desc);\n\tif (IS_ERR(con->partner_pd))\n\t\treturn PTR_ERR(con->partner_pd);\n\n\tret = ucsi_get_pdos(con, TYPEC_SOURCE, 1, caps.pdo);\n\tif (ret > 0) {\n\t\tif (ret < PDO_MAX_OBJECTS)\n\t\t\tcaps.pdo[ret] = 0;\n\n\t\tcaps.role = TYPEC_SOURCE;\n\t\tcap = usb_power_delivery_register_capabilities(con->partner_pd, &caps);\n\t\tif (IS_ERR(cap))\n\t\t\treturn PTR_ERR(cap);\n\n\t\tcon->partner_source_caps = cap;\n\n\t\tret = typec_partner_set_usb_power_delivery(con->partner, con->partner_pd);\n\t\tif (ret) {\n\t\t\tusb_power_delivery_unregister_capabilities(con->partner_source_caps);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ucsi_get_pdos(con, TYPEC_SINK, 1, caps.pdo);\n\tif (ret > 0) {\n\t\tif (ret < PDO_MAX_OBJECTS)\n\t\t\tcaps.pdo[ret] = 0;\n\n\t\tcaps.role = TYPEC_SINK;\n\n\t\tcap = usb_power_delivery_register_capabilities(con->partner_pd, &caps);\n\t\tif (IS_ERR(cap))\n\t\t\treturn PTR_ERR(cap);\n\n\t\tcon->partner_sink_caps = cap;\n\n\t\tret = typec_partner_set_usb_power_delivery(con->partner, con->partner_pd);\n\t\tif (ret) {\n\t\t\tusb_power_delivery_unregister_capabilities(con->partner_sink_caps);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void ucsi_unregister_partner_pdos(struct ucsi_connector *con)\n{\n\tusb_power_delivery_unregister_capabilities(con->partner_sink_caps);\n\tcon->partner_sink_caps = NULL;\n\tusb_power_delivery_unregister_capabilities(con->partner_source_caps);\n\tcon->partner_source_caps = NULL;\n\tusb_power_delivery_unregister(con->partner_pd);\n\tcon->partner_pd = NULL;\n}\n\nstatic void ucsi_pwr_opmode_change(struct ucsi_connector *con)\n{\n\tswitch (UCSI_CONSTAT_PWR_OPMODE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PWR_OPMODE_PD:\n\t\tcon->rdo = con->status.request_data_obj;\n\t\ttypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_PD);\n\t\tucsi_partner_task(con, ucsi_get_src_pdos, 30, 0);\n\t\tucsi_partner_task(con, ucsi_check_altmodes, 30, 0);\n\t\tucsi_partner_task(con, ucsi_register_partner_pdos, 1, HZ);\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\n\t\tcon->rdo = 0;\n\t\ttypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_1_5A);\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\n\t\tcon->rdo = 0;\n\t\ttypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_3_0A);\n\t\tbreak;\n\tdefault:\n\t\tcon->rdo = 0;\n\t\ttypec_set_pwr_opmode(con->port, TYPEC_PWR_MODE_USB);\n\t\tbreak;\n\t}\n}\n\nstatic int ucsi_register_partner(struct ucsi_connector *con)\n{\n\tu8 pwr_opmode = UCSI_CONSTAT_PWR_OPMODE(con->status.flags);\n\tstruct typec_partner_desc desc;\n\tstruct typec_partner *partner;\n\n\tif (con->partner)\n\t\treturn 0;\n\n\tmemset(&desc, 0, sizeof(desc));\n\n\tswitch (UCSI_CONSTAT_PARTNER_TYPE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PARTNER_TYPE_DEBUG:\n\t\tdesc.accessory = TYPEC_ACCESSORY_DEBUG;\n\t\tbreak;\n\tcase UCSI_CONSTAT_PARTNER_TYPE_AUDIO:\n\t\tdesc.accessory = TYPEC_ACCESSORY_AUDIO;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdesc.usb_pd = pwr_opmode == UCSI_CONSTAT_PWR_OPMODE_PD;\n\n\tpartner = typec_register_partner(con->port, &desc);\n\tif (IS_ERR(partner)) {\n\t\tdev_err(con->ucsi->dev,\n\t\t\t\"con%d: failed to register partner (%ld)\\n\", con->num,\n\t\t\tPTR_ERR(partner));\n\t\treturn PTR_ERR(partner);\n\t}\n\n\tcon->partner = partner;\n\n\treturn 0;\n}\n\nstatic void ucsi_unregister_partner(struct ucsi_connector *con)\n{\n\tif (!con->partner)\n\t\treturn;\n\n\ttypec_set_mode(con->port, TYPEC_STATE_SAFE);\n\n\ttypec_partner_set_usb_power_delivery(con->partner, NULL);\n\tucsi_unregister_partner_pdos(con);\n\tucsi_unregister_altmodes(con, UCSI_RECIPIENT_SOP);\n\ttypec_unregister_partner(con->partner);\n\tcon->partner = NULL;\n}\n\nstatic void ucsi_partner_change(struct ucsi_connector *con)\n{\n\tenum usb_role u_role = USB_ROLE_NONE;\n\tint ret;\n\n\tswitch (UCSI_CONSTAT_PARTNER_TYPE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PARTNER_TYPE_UFP:\n\tcase UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP:\n\t\tu_role = USB_ROLE_HOST;\n\t\tfallthrough;\n\tcase UCSI_CONSTAT_PARTNER_TYPE_CABLE:\n\t\ttypec_set_data_role(con->port, TYPEC_HOST);\n\t\tbreak;\n\tcase UCSI_CONSTAT_PARTNER_TYPE_DFP:\n\t\tu_role = USB_ROLE_DEVICE;\n\t\ttypec_set_data_role(con->port, TYPEC_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (con->status.flags & UCSI_CONSTAT_CONNECTED) {\n\t\tswitch (UCSI_CONSTAT_PARTNER_TYPE(con->status.flags)) {\n\t\tcase UCSI_CONSTAT_PARTNER_TYPE_DEBUG:\n\t\t\ttypec_set_mode(con->port, TYPEC_MODE_DEBUG);\n\t\t\tbreak;\n\t\tcase UCSI_CONSTAT_PARTNER_TYPE_AUDIO:\n\t\t\ttypec_set_mode(con->port, TYPEC_MODE_AUDIO);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (UCSI_CONSTAT_PARTNER_FLAGS(con->status.flags) ==\n\t\t\t\t\tUCSI_CONSTAT_PARTNER_FLAG_USB)\n\t\t\t\ttypec_set_mode(con->port, TYPEC_STATE_USB);\n\t\t}\n\t}\n\n\t \n\tif (!(UCSI_CONSTAT_PARTNER_FLAGS(con->status.flags) & UCSI_CONSTAT_PARTNER_FLAG_USB))\n\t\tu_role = USB_ROLE_NONE;\n\n\tret = usb_role_switch_set_role(con->usb_role_sw, u_role);\n\tif (ret)\n\t\tdev_err(con->ucsi->dev, \"con:%d: failed to set usb role:%d\\n\",\n\t\t\tcon->num, u_role);\n}\n\nstatic int ucsi_check_connection(struct ucsi_connector *con)\n{\n\tu8 prev_flags = con->status.flags;\n\tu64 command;\n\tint ret;\n\n\tcommand = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con->num);\n\tret = ucsi_send_command(con->ucsi, command, &con->status, sizeof(con->status));\n\tif (ret < 0) {\n\t\tdev_err(con->ucsi->dev, \"GET_CONNECTOR_STATUS failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (con->status.flags == prev_flags)\n\t\treturn 0;\n\n\tif (con->status.flags & UCSI_CONSTAT_CONNECTED) {\n\t\tucsi_register_partner(con);\n\t\tucsi_pwr_opmode_change(con);\n\t\tucsi_partner_change(con);\n\t} else {\n\t\tucsi_partner_change(con);\n\t\tucsi_port_psy_changed(con);\n\t\tucsi_unregister_partner(con);\n\t}\n\n\treturn 0;\n}\n\nstatic void ucsi_handle_connector_change(struct work_struct *work)\n{\n\tstruct ucsi_connector *con = container_of(work, struct ucsi_connector,\n\t\t\t\t\t\t  work);\n\tstruct ucsi *ucsi = con->ucsi;\n\tenum typec_role role;\n\tu64 command;\n\tint ret;\n\n\tmutex_lock(&con->lock);\n\n\tcommand = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con->num);\n\tret = ucsi_send_command(ucsi, command, &con->status, sizeof(con->status));\n\tif (ret < 0) {\n\t\tdev_err(ucsi->dev, \"%s: GET_CONNECTOR_STATUS failed (%d)\\n\",\n\t\t\t__func__, ret);\n\t\tclear_bit(EVENT_PENDING, &con->ucsi->flags);\n\t\tgoto out_unlock;\n\t}\n\n\ttrace_ucsi_connector_change(con->num, &con->status);\n\n\trole = !!(con->status.flags & UCSI_CONSTAT_PWR_DIR);\n\n\tif (con->status.change & UCSI_CONSTAT_POWER_DIR_CHANGE) {\n\t\ttypec_set_pwr_role(con->port, role);\n\n\t\t \n\t\tif (!completion_done(&con->complete))\n\t\t\tcomplete(&con->complete);\n\t}\n\n\tif (con->status.change & UCSI_CONSTAT_CONNECT_CHANGE) {\n\t\ttypec_set_pwr_role(con->port, role);\n\t\tucsi_port_psy_changed(con);\n\t\tucsi_partner_change(con);\n\n\t\tif (con->status.flags & UCSI_CONSTAT_CONNECTED) {\n\t\t\tucsi_register_partner(con);\n\t\t\tucsi_partner_task(con, ucsi_check_connection, 1, HZ);\n\n\t\t\tif (UCSI_CONSTAT_PWR_OPMODE(con->status.flags) ==\n\t\t\t    UCSI_CONSTAT_PWR_OPMODE_PD)\n\t\t\t\tucsi_partner_task(con, ucsi_register_partner_pdos, 1, HZ);\n\t\t} else {\n\t\t\tucsi_unregister_partner(con);\n\t\t}\n\t}\n\n\tif (con->status.change & UCSI_CONSTAT_POWER_OPMODE_CHANGE ||\n\t    con->status.change & UCSI_CONSTAT_POWER_LEVEL_CHANGE)\n\t\tucsi_pwr_opmode_change(con);\n\n\tif (con->partner && con->status.change & UCSI_CONSTAT_PARTNER_CHANGE) {\n\t\tucsi_partner_change(con);\n\n\t\t \n\t\tif (!completion_done(&con->complete))\n\t\t\tcomplete(&con->complete);\n\t}\n\n\tif (con->status.change & UCSI_CONSTAT_CAM_CHANGE)\n\t\tucsi_partner_task(con, ucsi_check_altmodes, 1, 0);\n\n\tclear_bit(EVENT_PENDING, &con->ucsi->flags);\n\n\tret = ucsi_acknowledge_connector_change(ucsi);\n\tif (ret)\n\t\tdev_err(ucsi->dev, \"%s: ACK failed (%d)\", __func__, ret);\n\nout_unlock:\n\tmutex_unlock(&con->lock);\n}\n\n \nvoid ucsi_connector_change(struct ucsi *ucsi, u8 num)\n{\n\tstruct ucsi_connector *con = &ucsi->connector[num - 1];\n\n\tif (!(ucsi->ntfy & UCSI_ENABLE_NTFY_CONNECTOR_CHANGE)) {\n\t\tdev_dbg(ucsi->dev, \"Bogus connector change event\\n\");\n\t\treturn;\n\t}\n\n\tif (!test_and_set_bit(EVENT_PENDING, &ucsi->flags))\n\t\tschedule_work(&con->work);\n}\nEXPORT_SYMBOL_GPL(ucsi_connector_change);\n\n \n\nstatic int ucsi_reset_connector(struct ucsi_connector *con, bool hard)\n{\n\tu64 command;\n\n\tcommand = UCSI_CONNECTOR_RESET | UCSI_CONNECTOR_NUMBER(con->num);\n\tcommand |= hard ? UCSI_CONNECTOR_RESET_HARD : 0;\n\n\treturn ucsi_send_command(con->ucsi, command, NULL, 0);\n}\n\nstatic int ucsi_reset_ppm(struct ucsi *ucsi)\n{\n\tu64 command = UCSI_PPM_RESET;\n\tunsigned long tmo;\n\tu32 cci;\n\tint ret;\n\n\tmutex_lock(&ucsi->ppm_lock);\n\n\tret = ucsi->ops->async_write(ucsi, UCSI_CONTROL, &command,\n\t\t\t\t     sizeof(command));\n\tif (ret < 0)\n\t\tgoto out;\n\n\ttmo = jiffies + msecs_to_jiffies(UCSI_TIMEOUT_MS);\n\n\tdo {\n\t\tif (time_is_before_jiffies(tmo)) {\n\t\t\tret = -ETIMEDOUT;\n\t\t\tgoto out;\n\t\t}\n\n\t\tret = ucsi->ops->read(ucsi, UCSI_CCI, &cci, sizeof(cci));\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\t \n\t\tif (cci & ~UCSI_CCI_RESET_COMPLETE) {\n\t\t\tret = ucsi->ops->async_write(ucsi, UCSI_CONTROL,\n\t\t\t\t\t\t     &command,\n\t\t\t\t\t\t     sizeof(command));\n\t\t\tif (ret < 0)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tmsleep(20);\n\t} while (!(cci & UCSI_CCI_RESET_COMPLETE));\n\nout:\n\tmutex_unlock(&ucsi->ppm_lock);\n\treturn ret;\n}\n\nstatic int ucsi_role_cmd(struct ucsi_connector *con, u64 command)\n{\n\tint ret;\n\n\tret = ucsi_send_command(con->ucsi, command, NULL, 0);\n\tif (ret == -ETIMEDOUT) {\n\t\tu64 c;\n\n\t\t \n\t\tucsi_reset_ppm(con->ucsi);\n\n\t\tc = UCSI_SET_NOTIFICATION_ENABLE | con->ucsi->ntfy;\n\t\tucsi_send_command(con->ucsi, c, NULL, 0);\n\n\t\tucsi_reset_connector(con, true);\n\t}\n\n\treturn ret;\n}\n\nstatic int ucsi_dr_swap(struct typec_port *port, enum typec_data_role role)\n{\n\tstruct ucsi_connector *con = typec_get_drvdata(port);\n\tu8 partner_type;\n\tu64 command;\n\tint ret = 0;\n\n\tmutex_lock(&con->lock);\n\n\tif (!con->partner) {\n\t\tret = -ENOTCONN;\n\t\tgoto out_unlock;\n\t}\n\n\tpartner_type = UCSI_CONSTAT_PARTNER_TYPE(con->status.flags);\n\tif ((partner_type == UCSI_CONSTAT_PARTNER_TYPE_DFP &&\n\t     role == TYPEC_DEVICE) ||\n\t    (partner_type == UCSI_CONSTAT_PARTNER_TYPE_UFP &&\n\t     role == TYPEC_HOST))\n\t\tgoto out_unlock;\n\n\treinit_completion(&con->complete);\n\n\tcommand = UCSI_SET_UOR | UCSI_CONNECTOR_NUMBER(con->num);\n\tcommand |= UCSI_SET_UOR_ROLE(role);\n\tcommand |= UCSI_SET_UOR_ACCEPT_ROLE_SWAPS;\n\tret = ucsi_role_cmd(con, command);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&con->lock);\n\n\tif (!wait_for_completion_timeout(&con->complete,\n\t\t\t\t\t msecs_to_jiffies(UCSI_SWAP_TIMEOUT_MS)))\n\t\treturn -ETIMEDOUT;\n\n\treturn 0;\n\nout_unlock:\n\tmutex_unlock(&con->lock);\n\n\treturn ret;\n}\n\nstatic int ucsi_pr_swap(struct typec_port *port, enum typec_role role)\n{\n\tstruct ucsi_connector *con = typec_get_drvdata(port);\n\tenum typec_role cur_role;\n\tu64 command;\n\tint ret = 0;\n\n\tmutex_lock(&con->lock);\n\n\tif (!con->partner) {\n\t\tret = -ENOTCONN;\n\t\tgoto out_unlock;\n\t}\n\n\tcur_role = !!(con->status.flags & UCSI_CONSTAT_PWR_DIR);\n\n\tif (cur_role == role)\n\t\tgoto out_unlock;\n\n\treinit_completion(&con->complete);\n\n\tcommand = UCSI_SET_PDR | UCSI_CONNECTOR_NUMBER(con->num);\n\tcommand |= UCSI_SET_PDR_ROLE(role);\n\tcommand |= UCSI_SET_PDR_ACCEPT_ROLE_SWAPS;\n\tret = ucsi_role_cmd(con, command);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tmutex_unlock(&con->lock);\n\n\tif (!wait_for_completion_timeout(&con->complete,\n\t\t\t\t\t msecs_to_jiffies(UCSI_SWAP_TIMEOUT_MS)))\n\t\treturn -ETIMEDOUT;\n\n\tmutex_lock(&con->lock);\n\n\t \n\tif (UCSI_CONSTAT_PWR_OPMODE(con->status.flags) !=\n\t    UCSI_CONSTAT_PWR_OPMODE_PD) {\n\t\tucsi_reset_connector(con, true);\n\t\tret = -EPROTO;\n\t}\n\nout_unlock:\n\tmutex_unlock(&con->lock);\n\n\treturn ret;\n}\n\nstatic const struct typec_operations ucsi_ops = {\n\t.dr_set = ucsi_dr_swap,\n\t.pr_set = ucsi_pr_swap\n};\n\n \nstatic struct fwnode_handle *ucsi_find_fwnode(struct ucsi_connector *con)\n{\n\tstruct fwnode_handle *fwnode;\n\tint i = 1;\n\n\tdevice_for_each_child_node(con->ucsi->dev, fwnode)\n\t\tif (i++ == con->num)\n\t\t\treturn fwnode;\n\treturn NULL;\n}\n\nstatic int ucsi_register_port(struct ucsi *ucsi, struct ucsi_connector *con)\n{\n\tstruct usb_power_delivery_desc desc = { ucsi->cap.pd_version};\n\tstruct usb_power_delivery_capabilities_desc pd_caps;\n\tstruct usb_power_delivery_capabilities *pd_cap;\n\tstruct typec_capability *cap = &con->typec_cap;\n\tenum typec_accessory *accessory = cap->accessory;\n\tenum usb_role u_role = USB_ROLE_NONE;\n\tu64 command;\n\tchar *name;\n\tint ret;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-con%d\", dev_name(ucsi->dev), con->num);\n\tif (!name)\n\t\treturn -ENOMEM;\n\n\tcon->wq = create_singlethread_workqueue(name);\n\tkfree(name);\n\tif (!con->wq)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&con->work, ucsi_handle_connector_change);\n\tinit_completion(&con->complete);\n\tmutex_init(&con->lock);\n\tINIT_LIST_HEAD(&con->partner_tasks);\n\tcon->ucsi = ucsi;\n\n\tcap->fwnode = ucsi_find_fwnode(con);\n\tcon->usb_role_sw = fwnode_usb_role_switch_get(cap->fwnode);\n\tif (IS_ERR(con->usb_role_sw))\n\t\treturn dev_err_probe(ucsi->dev, PTR_ERR(con->usb_role_sw),\n\t\t\t\"con%d: failed to get usb role switch\\n\", con->num);\n\n\t \n\tmutex_lock(&con->lock);\n\n\t \n\tcommand = UCSI_GET_CONNECTOR_CAPABILITY;\n\tcommand |= UCSI_CONNECTOR_NUMBER(con->num);\n\tret = ucsi_send_command(ucsi, command, &con->cap, sizeof(con->cap));\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tif (con->cap.op_mode & UCSI_CONCAP_OPMODE_DRP)\n\t\tcap->data = TYPEC_PORT_DRD;\n\telse if (con->cap.op_mode & UCSI_CONCAP_OPMODE_DFP)\n\t\tcap->data = TYPEC_PORT_DFP;\n\telse if (con->cap.op_mode & UCSI_CONCAP_OPMODE_UFP)\n\t\tcap->data = TYPEC_PORT_UFP;\n\n\tif ((con->cap.flags & UCSI_CONCAP_FLAG_PROVIDER) &&\n\t    (con->cap.flags & UCSI_CONCAP_FLAG_CONSUMER))\n\t\tcap->type = TYPEC_PORT_DRP;\n\telse if (con->cap.flags & UCSI_CONCAP_FLAG_PROVIDER)\n\t\tcap->type = TYPEC_PORT_SRC;\n\telse if (con->cap.flags & UCSI_CONCAP_FLAG_CONSUMER)\n\t\tcap->type = TYPEC_PORT_SNK;\n\n\tcap->revision = ucsi->cap.typec_version;\n\tcap->pd_revision = ucsi->cap.pd_version;\n\tcap->svdm_version = SVDM_VER_2_0;\n\tcap->prefer_role = TYPEC_NO_PREFERRED_ROLE;\n\n\tif (con->cap.op_mode & UCSI_CONCAP_OPMODE_AUDIO_ACCESSORY)\n\t\t*accessory++ = TYPEC_ACCESSORY_AUDIO;\n\tif (con->cap.op_mode & UCSI_CONCAP_OPMODE_DEBUG_ACCESSORY)\n\t\t*accessory = TYPEC_ACCESSORY_DEBUG;\n\n\tcap->driver_data = con;\n\tcap->ops = &ucsi_ops;\n\n\tret = ucsi_register_port_psy(con);\n\tif (ret)\n\t\tgoto out;\n\n\t \n\tcon->port = typec_register_port(ucsi->dev, cap);\n\tif (IS_ERR(con->port)) {\n\t\tret = PTR_ERR(con->port);\n\t\tgoto out;\n\t}\n\n\tcon->pd = usb_power_delivery_register(ucsi->dev, &desc);\n\n\tret = ucsi_get_pdos(con, TYPEC_SOURCE, 0, pd_caps.pdo);\n\tif (ret > 0) {\n\t\tif (ret < PDO_MAX_OBJECTS)\n\t\t\tpd_caps.pdo[ret] = 0;\n\n\t\tpd_caps.role = TYPEC_SOURCE;\n\t\tpd_cap = usb_power_delivery_register_capabilities(con->pd, &pd_caps);\n\t\tif (IS_ERR(pd_cap)) {\n\t\t\tret = PTR_ERR(pd_cap);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcon->port_source_caps = pd_cap;\n\t\ttypec_port_set_usb_power_delivery(con->port, con->pd);\n\t}\n\n\tmemset(&pd_caps, 0, sizeof(pd_caps));\n\tret = ucsi_get_pdos(con, TYPEC_SINK, 0, pd_caps.pdo);\n\tif (ret > 0) {\n\t\tif (ret < PDO_MAX_OBJECTS)\n\t\t\tpd_caps.pdo[ret] = 0;\n\n\t\tpd_caps.role = TYPEC_SINK;\n\t\tpd_cap = usb_power_delivery_register_capabilities(con->pd, &pd_caps);\n\t\tif (IS_ERR(pd_cap)) {\n\t\t\tret = PTR_ERR(pd_cap);\n\t\t\tgoto out;\n\t\t}\n\n\t\tcon->port_sink_caps = pd_cap;\n\t\ttypec_port_set_usb_power_delivery(con->port, con->pd);\n\t}\n\n\t \n\tret = ucsi_register_altmodes(con, UCSI_RECIPIENT_CON);\n\tif (ret) {\n\t\tdev_err(ucsi->dev, \"con%d: failed to register alt modes\\n\",\n\t\t\tcon->num);\n\t\tgoto out;\n\t}\n\n\t \n\tcommand = UCSI_GET_CONNECTOR_STATUS | UCSI_CONNECTOR_NUMBER(con->num);\n\tret = ucsi_send_command(ucsi, command, &con->status, sizeof(con->status));\n\tif (ret < 0) {\n\t\tdev_err(ucsi->dev, \"con%d: failed to get status\\n\", con->num);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tret = 0;  \n\n\tswitch (UCSI_CONSTAT_PARTNER_TYPE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PARTNER_TYPE_UFP:\n\tcase UCSI_CONSTAT_PARTNER_TYPE_CABLE_AND_UFP:\n\t\tu_role = USB_ROLE_HOST;\n\t\tfallthrough;\n\tcase UCSI_CONSTAT_PARTNER_TYPE_CABLE:\n\t\ttypec_set_data_role(con->port, TYPEC_HOST);\n\t\tbreak;\n\tcase UCSI_CONSTAT_PARTNER_TYPE_DFP:\n\t\tu_role = USB_ROLE_DEVICE;\n\t\ttypec_set_data_role(con->port, TYPEC_DEVICE);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\tif (con->status.flags & UCSI_CONSTAT_CONNECTED) {\n\t\ttypec_set_pwr_role(con->port,\n\t\t\t\t  !!(con->status.flags & UCSI_CONSTAT_PWR_DIR));\n\t\tucsi_register_partner(con);\n\t\tucsi_pwr_opmode_change(con);\n\t\tucsi_port_psy_changed(con);\n\t}\n\n\t \n\tif (!(UCSI_CONSTAT_PARTNER_FLAGS(con->status.flags) & UCSI_CONSTAT_PARTNER_FLAG_USB))\n\t\tu_role = USB_ROLE_NONE;\n\n\tret = usb_role_switch_set_role(con->usb_role_sw, u_role);\n\tif (ret) {\n\t\tdev_err(ucsi->dev, \"con:%d: failed to set usb role:%d\\n\",\n\t\t\tcon->num, u_role);\n\t\tret = 0;\n\t}\n\n\tif (con->partner &&\n\t    UCSI_CONSTAT_PWR_OPMODE(con->status.flags) ==\n\t    UCSI_CONSTAT_PWR_OPMODE_PD) {\n\t\tucsi_get_src_pdos(con);\n\t\tucsi_check_altmodes(con);\n\t}\n\n\ttrace_ucsi_register_port(con->num, &con->status);\n\nout:\n\tfwnode_handle_put(cap->fwnode);\nout_unlock:\n\tmutex_unlock(&con->lock);\n\n\tif (ret && con->wq) {\n\t\tdestroy_workqueue(con->wq);\n\t\tcon->wq = NULL;\n\t}\n\n\treturn ret;\n}\n\n \nstatic int ucsi_init(struct ucsi *ucsi)\n{\n\tstruct ucsi_connector *con, *connector;\n\tu64 command, ntfy;\n\tint ret;\n\tint i;\n\n\t \n\tret = ucsi_reset_ppm(ucsi);\n\tif (ret) {\n\t\tdev_err(ucsi->dev, \"failed to reset PPM!\\n\");\n\t\tgoto err;\n\t}\n\n\t \n\tntfy = UCSI_ENABLE_NTFY_CMD_COMPLETE | UCSI_ENABLE_NTFY_ERROR;\n\tcommand = UCSI_SET_NOTIFICATION_ENABLE | ntfy;\n\tret = ucsi_send_command(ucsi, command, NULL, 0);\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\t \n\tcommand = UCSI_GET_CAPABILITY;\n\tret = ucsi_send_command(ucsi, command, &ucsi->cap, sizeof(ucsi->cap));\n\tif (ret < 0)\n\t\tgoto err_reset;\n\n\tif (!ucsi->cap.num_connectors) {\n\t\tret = -ENODEV;\n\t\tgoto err_reset;\n\t}\n\n\t \n\tconnector = kcalloc(ucsi->cap.num_connectors + 1, sizeof(*connector), GFP_KERNEL);\n\tif (!connector) {\n\t\tret = -ENOMEM;\n\t\tgoto err_reset;\n\t}\n\n\t \n\tfor (i = 0; i < ucsi->cap.num_connectors; i++) {\n\t\tconnector[i].num = i + 1;\n\t\tret = ucsi_register_port(ucsi, &connector[i]);\n\t\tif (ret)\n\t\t\tgoto err_unregister;\n\t}\n\n\t \n\tntfy = UCSI_ENABLE_NTFY_ALL;\n\tcommand = UCSI_SET_NOTIFICATION_ENABLE | ntfy;\n\tret = ucsi_send_command(ucsi, command, NULL, 0);\n\tif (ret < 0)\n\t\tgoto err_unregister;\n\n\tucsi->connector = connector;\n\tucsi->ntfy = ntfy;\n\treturn 0;\n\nerr_unregister:\n\tfor (con = connector; con->port; con++) {\n\t\tucsi_unregister_partner(con);\n\t\tucsi_unregister_altmodes(con, UCSI_RECIPIENT_CON);\n\t\tucsi_unregister_port_psy(con);\n\t\tif (con->wq)\n\t\t\tdestroy_workqueue(con->wq);\n\n\t\tusb_power_delivery_unregister_capabilities(con->port_sink_caps);\n\t\tcon->port_sink_caps = NULL;\n\t\tusb_power_delivery_unregister_capabilities(con->port_source_caps);\n\t\tcon->port_source_caps = NULL;\n\t\tusb_power_delivery_unregister(con->pd);\n\t\tcon->pd = NULL;\n\t\ttypec_unregister_port(con->port);\n\t\tcon->port = NULL;\n\t}\n\tkfree(connector);\nerr_reset:\n\tmemset(&ucsi->cap, 0, sizeof(ucsi->cap));\n\tucsi_reset_ppm(ucsi);\nerr:\n\treturn ret;\n}\n\nstatic void ucsi_resume_work(struct work_struct *work)\n{\n\tstruct ucsi *ucsi = container_of(work, struct ucsi, resume_work);\n\tstruct ucsi_connector *con;\n\tu64 command;\n\tint ret;\n\n\t \n\tcommand = UCSI_SET_NOTIFICATION_ENABLE | ucsi->ntfy;\n\tret = ucsi_send_command(ucsi, command, NULL, 0);\n\tif (ret < 0) {\n\t\tdev_err(ucsi->dev, \"failed to re-enable notifications (%d)\\n\", ret);\n\t\treturn;\n\t}\n\n\tfor (con = ucsi->connector; con->port; con++) {\n\t\tmutex_lock(&con->lock);\n\t\tucsi_partner_task(con, ucsi_check_connection, 1, 0);\n\t\tmutex_unlock(&con->lock);\n\t}\n}\n\nint ucsi_resume(struct ucsi *ucsi)\n{\n\tif (ucsi->connector)\n\t\tqueue_work(system_long_wq, &ucsi->resume_work);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ucsi_resume);\n\nstatic void ucsi_init_work(struct work_struct *work)\n{\n\tstruct ucsi *ucsi = container_of(work, struct ucsi, work.work);\n\tint ret;\n\n\tret = ucsi_init(ucsi);\n\tif (ret)\n\t\tdev_err_probe(ucsi->dev, ret, \"PPM init failed\\n\");\n\n\tif (ret == -EPROBE_DEFER) {\n\t\tif (ucsi->work_count++ > UCSI_ROLE_SWITCH_WAIT_COUNT) {\n\t\t\tdev_err(ucsi->dev, \"PPM init failed, stop trying\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tqueue_delayed_work(system_long_wq, &ucsi->work,\n\t\t\t\t   UCSI_ROLE_SWITCH_INTERVAL);\n\t}\n}\n\n \nvoid *ucsi_get_drvdata(struct ucsi *ucsi)\n{\n\treturn ucsi->driver_data;\n}\nEXPORT_SYMBOL_GPL(ucsi_get_drvdata);\n\n \nvoid ucsi_set_drvdata(struct ucsi *ucsi, void *data)\n{\n\tucsi->driver_data = data;\n}\nEXPORT_SYMBOL_GPL(ucsi_set_drvdata);\n\n \nstruct ucsi *ucsi_create(struct device *dev, const struct ucsi_operations *ops)\n{\n\tstruct ucsi *ucsi;\n\n\tif (!ops || !ops->read || !ops->sync_write || !ops->async_write)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tucsi = kzalloc(sizeof(*ucsi), GFP_KERNEL);\n\tif (!ucsi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tINIT_WORK(&ucsi->resume_work, ucsi_resume_work);\n\tINIT_DELAYED_WORK(&ucsi->work, ucsi_init_work);\n\tmutex_init(&ucsi->ppm_lock);\n\tucsi->dev = dev;\n\tucsi->ops = ops;\n\n\treturn ucsi;\n}\nEXPORT_SYMBOL_GPL(ucsi_create);\n\n \nvoid ucsi_destroy(struct ucsi *ucsi)\n{\n\tucsi_debugfs_unregister(ucsi);\n\tkfree(ucsi);\n}\nEXPORT_SYMBOL_GPL(ucsi_destroy);\n\n \nint ucsi_register(struct ucsi *ucsi)\n{\n\tint ret;\n\n\tret = ucsi->ops->read(ucsi, UCSI_VERSION, &ucsi->version,\n\t\t\t      sizeof(ucsi->version));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!ucsi->version)\n\t\treturn -ENODEV;\n\n\tqueue_delayed_work(system_long_wq, &ucsi->work, 0);\n\n\tucsi_debugfs_register(ucsi);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ucsi_register);\n\n \nvoid ucsi_unregister(struct ucsi *ucsi)\n{\n\tu64 cmd = UCSI_SET_NOTIFICATION_ENABLE;\n\tint i;\n\n\t \n\tcancel_delayed_work_sync(&ucsi->work);\n\tcancel_work_sync(&ucsi->resume_work);\n\n\t \n\tucsi->ops->async_write(ucsi, UCSI_CONTROL, &cmd, sizeof(cmd));\n\n\tif (!ucsi->connector)\n\t\treturn;\n\n\tfor (i = 0; i < ucsi->cap.num_connectors; i++) {\n\t\tcancel_work_sync(&ucsi->connector[i].work);\n\t\tucsi_unregister_partner(&ucsi->connector[i]);\n\t\tucsi_unregister_altmodes(&ucsi->connector[i],\n\t\t\t\t\t UCSI_RECIPIENT_CON);\n\t\tucsi_unregister_port_psy(&ucsi->connector[i]);\n\n\t\tif (ucsi->connector[i].wq) {\n\t\t\tstruct ucsi_work *uwork;\n\n\t\t\tmutex_lock(&ucsi->connector[i].lock);\n\t\t\t \n\t\t\tlist_for_each_entry(uwork, &ucsi->connector[i].partner_tasks, node)\n\t\t\t\tmod_delayed_work(ucsi->connector[i].wq, &uwork->work, 0);\n\t\t\tmutex_unlock(&ucsi->connector[i].lock);\n\t\t\tdestroy_workqueue(ucsi->connector[i].wq);\n\t\t}\n\n\t\tusb_power_delivery_unregister_capabilities(ucsi->connector[i].port_sink_caps);\n\t\tucsi->connector[i].port_sink_caps = NULL;\n\t\tusb_power_delivery_unregister_capabilities(ucsi->connector[i].port_source_caps);\n\t\tucsi->connector[i].port_source_caps = NULL;\n\t\tusb_power_delivery_unregister(ucsi->connector[i].pd);\n\t\tucsi->connector[i].pd = NULL;\n\t\ttypec_unregister_port(ucsi->connector[i].port);\n\t}\n\n\tkfree(ucsi->connector);\n}\nEXPORT_SYMBOL_GPL(ucsi_unregister);\n\nstatic int __init ucsi_module_init(void)\n{\n\tucsi_debugfs_init();\n\treturn 0;\n}\nmodule_init(ucsi_module_init);\n\nstatic void __exit ucsi_module_exit(void)\n{\n\tucsi_debugfs_exit();\n}\nmodule_exit(ucsi_module_exit);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"USB Type-C Connector System Software Interface driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}