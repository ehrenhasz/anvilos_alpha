{
  "module_name": "psy.c",
  "hash_id": "ea2329364b8b8fdb26b662e96fd999cfd3b7b2f34f38751c0bda4d39dcd6d7ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/psy.c",
  "human_readable_source": "\n \n\n#include <linux/property.h>\n#include <linux/usb/pd.h>\n\n#include \"ucsi.h\"\n\n \nenum ucsi_psy_online_states {\n\tUCSI_PSY_OFFLINE = 0,\n\tUCSI_PSY_FIXED_ONLINE,\n\tUCSI_PSY_PROG_ONLINE,\n};\n\nstatic enum power_supply_property ucsi_psy_props[] = {\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n\tPOWER_SUPPLY_PROP_SCOPE,\n};\n\nstatic int ucsi_psy_get_scope(struct ucsi_connector *con,\n\t\t\t      union power_supply_propval *val)\n{\n\tu8 scope = POWER_SUPPLY_SCOPE_UNKNOWN;\n\tstruct device *dev = con->ucsi->dev;\n\n\tdevice_property_read_u8(dev, \"scope\", &scope);\n\tif (scope == POWER_SUPPLY_SCOPE_UNKNOWN) {\n\t\tu32 mask = UCSI_CAP_ATTR_POWER_AC_SUPPLY |\n\t\t\t   UCSI_CAP_ATTR_BATTERY_CHARGING;\n\n\t\tif (con->ucsi->cap.attributes & mask)\n\t\t\tscope = POWER_SUPPLY_SCOPE_SYSTEM;\n\t\telse\n\t\t\tscope = POWER_SUPPLY_SCOPE_DEVICE;\n\t}\n\tval->intval = scope;\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_online(struct ucsi_connector *con,\n\t\t\t       union power_supply_propval *val)\n{\n\tval->intval = UCSI_PSY_OFFLINE;\n\tif (con->status.flags & UCSI_CONSTAT_CONNECTED &&\n\t    (con->status.flags & UCSI_CONSTAT_PWR_DIR) == TYPEC_SINK)\n\t\tval->intval = UCSI_PSY_FIXED_ONLINE;\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_voltage_min(struct ucsi_connector *con,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tu32 pdo;\n\n\tswitch (UCSI_CONSTAT_PWR_OPMODE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PWR_OPMODE_PD:\n\t\tpdo = con->src_pdos[0];\n\t\tval->intval = pdo_fixed_voltage(pdo) * 1000;\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\n\tcase UCSI_CONSTAT_PWR_OPMODE_BC:\n\tcase UCSI_CONSTAT_PWR_OPMODE_DEFAULT:\n\t\tval->intval = UCSI_TYPEC_VSAFE5V * 1000;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_voltage_max(struct ucsi_connector *con,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tu32 pdo;\n\n\tswitch (UCSI_CONSTAT_PWR_OPMODE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PWR_OPMODE_PD:\n\t\tif (con->num_pdos > 0) {\n\t\t\tpdo = con->src_pdos[con->num_pdos - 1];\n\t\t\tval->intval = pdo_fixed_voltage(pdo) * 1000;\n\t\t} else {\n\t\t\tval->intval = 0;\n\t\t}\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\n\tcase UCSI_CONSTAT_PWR_OPMODE_BC:\n\tcase UCSI_CONSTAT_PWR_OPMODE_DEFAULT:\n\t\tval->intval = UCSI_TYPEC_VSAFE5V * 1000;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_voltage_now(struct ucsi_connector *con,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tint index;\n\tu32 pdo;\n\n\tswitch (UCSI_CONSTAT_PWR_OPMODE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PWR_OPMODE_PD:\n\t\tindex = rdo_index(con->rdo);\n\t\tif (index > 0) {\n\t\t\tpdo = con->src_pdos[index - 1];\n\t\t\tval->intval = pdo_fixed_voltage(pdo) * 1000;\n\t\t} else {\n\t\t\tval->intval = 0;\n\t\t}\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\n\tcase UCSI_CONSTAT_PWR_OPMODE_BC:\n\tcase UCSI_CONSTAT_PWR_OPMODE_DEFAULT:\n\t\tval->intval = UCSI_TYPEC_VSAFE5V * 1000;\n\t\tbreak;\n\tdefault:\n\t\tval->intval = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_current_max(struct ucsi_connector *con,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tu32 pdo;\n\n\tswitch (UCSI_CONSTAT_PWR_OPMODE(con->status.flags)) {\n\tcase UCSI_CONSTAT_PWR_OPMODE_PD:\n\t\tif (con->num_pdos > 0) {\n\t\t\tpdo = con->src_pdos[con->num_pdos - 1];\n\t\t\tval->intval = pdo_max_current(pdo) * 1000;\n\t\t} else {\n\t\t\tval->intval = 0;\n\t\t}\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC1_5:\n\t\tval->intval = UCSI_TYPEC_1_5_CURRENT * 1000;\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_TYPEC3_0:\n\t\tval->intval = UCSI_TYPEC_3_0_CURRENT * 1000;\n\t\tbreak;\n\tcase UCSI_CONSTAT_PWR_OPMODE_BC:\n\tcase UCSI_CONSTAT_PWR_OPMODE_DEFAULT:\n\t \n\tdefault:\n\t\tval->intval = 0;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_current_now(struct ucsi_connector *con,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tu16 flags = con->status.flags;\n\n\tif (UCSI_CONSTAT_PWR_OPMODE(flags) == UCSI_CONSTAT_PWR_OPMODE_PD)\n\t\tval->intval = rdo_op_current(con->rdo) * 1000;\n\telse\n\t\tval->intval = 0;\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_usb_type(struct ucsi_connector *con,\n\t\t\t\t union power_supply_propval *val)\n{\n\tu16 flags = con->status.flags;\n\n\tval->intval = POWER_SUPPLY_USB_TYPE_C;\n\tif (flags & UCSI_CONSTAT_CONNECTED &&\n\t    UCSI_CONSTAT_PWR_OPMODE(flags) == UCSI_CONSTAT_PWR_OPMODE_PD)\n\t\tval->intval = POWER_SUPPLY_USB_TYPE_PD;\n\n\treturn 0;\n}\n\nstatic int ucsi_psy_get_prop(struct power_supply *psy,\n\t\t\t     enum power_supply_property psp,\n\t\t\t     union power_supply_propval *val)\n{\n\tstruct ucsi_connector *con = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\treturn ucsi_psy_get_usb_type(con, val);\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\treturn ucsi_psy_get_online(con, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\t\treturn ucsi_psy_get_voltage_min(con, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\treturn ucsi_psy_get_voltage_max(con, val);\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\t\treturn ucsi_psy_get_voltage_now(con, val);\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\treturn ucsi_psy_get_current_max(con, val);\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\t\treturn ucsi_psy_get_current_now(con, val);\n\tcase POWER_SUPPLY_PROP_SCOPE:\n\t\treturn ucsi_psy_get_scope(con, val);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic enum power_supply_usb_type ucsi_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_PPS,\n};\n\nint ucsi_register_port_psy(struct ucsi_connector *con)\n{\n\tstruct power_supply_config psy_cfg = {};\n\tstruct device *dev = con->ucsi->dev;\n\tchar *psy_name;\n\n\tpsy_cfg.drv_data = con;\n\tpsy_cfg.fwnode = dev_fwnode(dev);\n\n\tpsy_name = devm_kasprintf(dev, GFP_KERNEL, \"ucsi-source-psy-%s%d\",\n\t\t\t\t  dev_name(dev), con->num);\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\tcon->psy_desc.name = psy_name;\n\tcon->psy_desc.type = POWER_SUPPLY_TYPE_USB;\n\tcon->psy_desc.usb_types = ucsi_psy_usb_types;\n\tcon->psy_desc.num_usb_types = ARRAY_SIZE(ucsi_psy_usb_types);\n\tcon->psy_desc.properties = ucsi_psy_props;\n\tcon->psy_desc.num_properties = ARRAY_SIZE(ucsi_psy_props);\n\tcon->psy_desc.get_property = ucsi_psy_get_prop;\n\n\tcon->psy = power_supply_register(dev, &con->psy_desc, &psy_cfg);\n\n\treturn PTR_ERR_OR_ZERO(con->psy);\n}\n\nvoid ucsi_unregister_port_psy(struct ucsi_connector *con)\n{\n\tif (IS_ERR_OR_NULL(con->psy))\n\t\treturn;\n\n\tpower_supply_unregister(con->psy);\n\tcon->psy = NULL;\n}\n\nvoid ucsi_port_psy_changed(struct ucsi_connector *con)\n{\n\tif (IS_ERR_OR_NULL(con->psy))\n\t\treturn;\n\n\tpower_supply_changed(con->psy);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}