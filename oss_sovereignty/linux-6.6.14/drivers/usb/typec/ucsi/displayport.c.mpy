{
  "module_name": "displayport.c",
  "hash_id": "26230b99a7970815800a26f0fd32cb38fcd994d0eb6cd55cc2ab8eca07601d23",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/displayport.c",
  "human_readable_source": "\n \n\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/pd_vdo.h>\n\n#include \"ucsi.h\"\n\n#define UCSI_CMD_SET_NEW_CAM(_con_num_, _enter_, _cam_, _am_)\t\t\\\n\t (UCSI_SET_NEW_CAM | ((_con_num_) << 16) | ((_enter_) << 23) |\t\\\n\t  ((_cam_) << 24) | ((u64)(_am_) << 32))\n\nstruct ucsi_dp {\n\tstruct typec_displayport_data data;\n\tstruct ucsi_connector *con;\n\tstruct typec_altmode *alt;\n\tstruct work_struct work;\n\tint offset;\n\n\tbool override;\n\tbool initialized;\n\n\tu32 header;\n\tu32 *vdo_data;\n\tu8 vdo_size;\n};\n\n \n\nstatic int ucsi_displayport_enter(struct typec_altmode *alt, u32 *vdo)\n{\n\tstruct ucsi_dp *dp = typec_altmode_get_drvdata(alt);\n\tstruct ucsi *ucsi = dp->con->ucsi;\n\tint svdm_version;\n\tu64 command;\n\tu8 cur = 0;\n\tint ret;\n\n\tmutex_lock(&dp->con->lock);\n\n\tif (!dp->override && dp->initialized) {\n\t\tconst struct typec_altmode *p = typec_altmode_get_partner(alt);\n\n\t\tdev_warn(&p->dev,\n\t\t\t \"firmware doesn't support alternate mode overriding\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto err_unlock;\n\t}\n\n\tcommand = UCSI_GET_CURRENT_CAM | UCSI_CONNECTOR_NUMBER(dp->con->num);\n\tret = ucsi_send_command(ucsi, command, &cur, sizeof(cur));\n\tif (ret < 0) {\n\t\tif (ucsi->version > 0x0100)\n\t\t\tgoto err_unlock;\n\t\tcur = 0xff;\n\t}\n\n\tif (cur != 0xff) {\n\t\tret = dp->con->port_altmode[cur] == alt ? 0 : -EBUSY;\n\t\tgoto err_unlock;\n\t}\n\n\t \n\n\tsvdm_version = typec_altmode_get_svdm_version(alt);\n\tif (svdm_version < 0) {\n\t\tret = svdm_version;\n\t\tgoto err_unlock;\n\t}\n\n\tdp->header = VDO(USB_TYPEC_DP_SID, 1, svdm_version, CMD_ENTER_MODE);\n\tdp->header |= VDO_OPOS(USB_TYPEC_DP_MODE);\n\tdp->header |= VDO_CMDT(CMDT_RSP_ACK);\n\n\tdp->vdo_data = NULL;\n\tdp->vdo_size = 1;\n\n\tschedule_work(&dp->work);\n\tret = 0;\nerr_unlock:\n\tmutex_unlock(&dp->con->lock);\n\n\treturn ret;\n}\n\nstatic int ucsi_displayport_exit(struct typec_altmode *alt)\n{\n\tstruct ucsi_dp *dp = typec_altmode_get_drvdata(alt);\n\tint svdm_version;\n\tu64 command;\n\tint ret = 0;\n\n\tmutex_lock(&dp->con->lock);\n\n\tif (!dp->override) {\n\t\tconst struct typec_altmode *p = typec_altmode_get_partner(alt);\n\n\t\tdev_warn(&p->dev,\n\t\t\t \"firmware doesn't support alternate mode overriding\\n\");\n\t\tret = -EOPNOTSUPP;\n\t\tgoto out_unlock;\n\t}\n\n\tcommand = UCSI_CMD_SET_NEW_CAM(dp->con->num, 0, dp->offset, 0);\n\tret = ucsi_send_command(dp->con->ucsi, command, NULL, 0);\n\tif (ret < 0)\n\t\tgoto out_unlock;\n\n\tsvdm_version = typec_altmode_get_svdm_version(alt);\n\tif (svdm_version < 0) {\n\t\tret = svdm_version;\n\t\tgoto out_unlock;\n\t}\n\n\tdp->header = VDO(USB_TYPEC_DP_SID, 1, svdm_version, CMD_EXIT_MODE);\n\tdp->header |= VDO_OPOS(USB_TYPEC_DP_MODE);\n\tdp->header |= VDO_CMDT(CMDT_RSP_ACK);\n\n\tdp->vdo_data = NULL;\n\tdp->vdo_size = 1;\n\n\tschedule_work(&dp->work);\n\nout_unlock:\n\tmutex_unlock(&dp->con->lock);\n\n\treturn ret;\n}\n\n \nstatic int ucsi_displayport_status_update(struct ucsi_dp *dp)\n{\n\tu32 cap = dp->alt->vdo;\n\n\tdp->data.status = DP_STATUS_ENABLED;\n\n\t \n\tif (DP_CAP_CAPABILITY(cap) & DP_CAP_UFP_D) {\n\t\tdp->data.status |= DP_STATUS_CON_UFP_D;\n\n\t\tif (DP_CAP_UFP_D_PIN_ASSIGN(cap) & BIT(DP_PIN_ASSIGN_D))\n\t\t\tdp->data.status |= DP_STATUS_PREFER_MULTI_FUNC;\n\t} else {\n\t\tdp->data.status |= DP_STATUS_CON_DFP_D;\n\n\t\tif (DP_CAP_DFP_D_PIN_ASSIGN(cap) & BIT(DP_PIN_ASSIGN_D))\n\t\t\tdp->data.status |= DP_STATUS_PREFER_MULTI_FUNC;\n\t}\n\n\tdp->vdo_data = &dp->data.status;\n\tdp->vdo_size = 2;\n\n\treturn 0;\n}\n\nstatic int ucsi_displayport_configure(struct ucsi_dp *dp)\n{\n\tu32 pins = DP_CONF_GET_PIN_ASSIGN(dp->data.conf);\n\tu64 command;\n\n\tif (!dp->override)\n\t\treturn 0;\n\n\tcommand = UCSI_CMD_SET_NEW_CAM(dp->con->num, 1, dp->offset, pins);\n\n\treturn ucsi_send_command(dp->con->ucsi, command, NULL, 0);\n}\n\nstatic int ucsi_displayport_vdm(struct typec_altmode *alt,\n\t\t\t\tu32 header, const u32 *data, int count)\n{\n\tstruct ucsi_dp *dp = typec_altmode_get_drvdata(alt);\n\tint cmd_type = PD_VDO_CMDT(header);\n\tint cmd = PD_VDO_CMD(header);\n\tint svdm_version;\n\n\tmutex_lock(&dp->con->lock);\n\n\tif (!dp->override && dp->initialized) {\n\t\tconst struct typec_altmode *p = typec_altmode_get_partner(alt);\n\n\t\tdev_warn(&p->dev,\n\t\t\t \"firmware doesn't support alternate mode overriding\\n\");\n\t\tmutex_unlock(&dp->con->lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tsvdm_version = typec_altmode_get_svdm_version(alt);\n\tif (svdm_version < 0) {\n\t\tmutex_unlock(&dp->con->lock);\n\t\treturn svdm_version;\n\t}\n\n\tswitch (cmd_type) {\n\tcase CMDT_INIT:\n\t\tif (PD_VDO_SVDM_VER(header) < svdm_version) {\n\t\t\ttypec_partner_set_svdm_version(dp->con->partner, PD_VDO_SVDM_VER(header));\n\t\t\tsvdm_version = PD_VDO_SVDM_VER(header);\n\t\t}\n\n\t\tdp->header = VDO(USB_TYPEC_DP_SID, 1, svdm_version, cmd);\n\t\tdp->header |= VDO_OPOS(USB_TYPEC_DP_MODE);\n\n\t\tswitch (cmd) {\n\t\tcase DP_CMD_STATUS_UPDATE:\n\t\t\tif (ucsi_displayport_status_update(dp))\n\t\t\t\tdp->header |= VDO_CMDT(CMDT_RSP_NAK);\n\t\t\telse\n\t\t\t\tdp->header |= VDO_CMDT(CMDT_RSP_ACK);\n\t\t\tbreak;\n\t\tcase DP_CMD_CONFIGURE:\n\t\t\tdp->data.conf = *data;\n\t\t\tif (ucsi_displayport_configure(dp)) {\n\t\t\t\tdp->header |= VDO_CMDT(CMDT_RSP_NAK);\n\t\t\t} else {\n\t\t\t\tdp->header |= VDO_CMDT(CMDT_RSP_ACK);\n\t\t\t\tif (dp->initialized)\n\t\t\t\t\tucsi_altmode_update_active(dp->con);\n\t\t\t\telse\n\t\t\t\t\tdp->initialized = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdp->header |= VDO_CMDT(CMDT_RSP_ACK);\n\t\t\tbreak;\n\t\t}\n\n\t\tschedule_work(&dp->work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&dp->con->lock);\n\n\treturn 0;\n}\n\nstatic const struct typec_altmode_ops ucsi_displayport_ops = {\n\t.enter = ucsi_displayport_enter,\n\t.exit = ucsi_displayport_exit,\n\t.vdm = ucsi_displayport_vdm,\n};\n\nstatic void ucsi_displayport_work(struct work_struct *work)\n{\n\tstruct ucsi_dp *dp = container_of(work, struct ucsi_dp, work);\n\tint ret;\n\n\tmutex_lock(&dp->con->lock);\n\n\tret = typec_altmode_vdm(dp->alt, dp->header,\n\t\t\t\tdp->vdo_data, dp->vdo_size);\n\tif (ret)\n\t\tdev_err(&dp->alt->dev, \"VDM 0x%x failed\\n\", dp->header);\n\n\tdp->vdo_data = NULL;\n\tdp->vdo_size = 0;\n\tdp->header = 0;\n\n\tmutex_unlock(&dp->con->lock);\n}\n\nvoid ucsi_displayport_remove_partner(struct typec_altmode *alt)\n{\n\tstruct ucsi_dp *dp;\n\n\tif (!alt)\n\t\treturn;\n\n\tdp = typec_altmode_get_drvdata(alt);\n\tif (!dp)\n\t\treturn;\n\n\tdp->data.conf = 0;\n\tdp->data.status = 0;\n\tdp->initialized = false;\n}\n\nstruct typec_altmode *ucsi_register_displayport(struct ucsi_connector *con,\n\t\t\t\t\t\tbool override, int offset,\n\t\t\t\t\t\tstruct typec_altmode_desc *desc)\n{\n\tu8 all_assignments = BIT(DP_PIN_ASSIGN_C) | BIT(DP_PIN_ASSIGN_D) |\n\t\t\t     BIT(DP_PIN_ASSIGN_E);\n\tstruct typec_altmode *alt;\n\tstruct ucsi_dp *dp;\n\n\t \n\tdesc->vdo |= DP_CAP_DP_SIGNALING | DP_CAP_RECEPTACLE;\n\n\t \n\tdesc->vdo |= all_assignments << 8;\n\tdesc->vdo |= all_assignments << 16;\n\n\talt = typec_port_register_altmode(con->port, desc);\n\tif (IS_ERR(alt))\n\t\treturn alt;\n\n\tdp = devm_kzalloc(&alt->dev, sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\ttypec_unregister_altmode(alt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tINIT_WORK(&dp->work, ucsi_displayport_work);\n\tdp->override = override;\n\tdp->offset = offset;\n\tdp->con = con;\n\tdp->alt = alt;\n\n\talt->ops = &ucsi_displayport_ops;\n\ttypec_altmode_set_drvdata(alt, dp);\n\n\treturn alt;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}