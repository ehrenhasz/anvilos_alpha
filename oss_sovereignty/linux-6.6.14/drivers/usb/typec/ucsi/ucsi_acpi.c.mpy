{
  "module_name": "ucsi_acpi.c",
  "hash_id": "56d19c8f89a0edef47e05fef7fcbdd5a5d8066951f33824864c3de1e9e442eec",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/ucsi_acpi.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n\n#include \"ucsi.h\"\n\n#define UCSI_DSM_UUID\t\t\"6f8398c2-7ca4-11e4-ad36-631042b5008f\"\n#define UCSI_DSM_FUNC_WRITE\t1\n#define UCSI_DSM_FUNC_READ\t2\n\nstruct ucsi_acpi {\n\tstruct device *dev;\n\tstruct ucsi *ucsi;\n\tvoid *base;\n\tstruct completion complete;\n\tunsigned long flags;\n\tguid_t guid;\n\tu64 cmd;\n};\n\nstatic int ucsi_acpi_dsm(struct ucsi_acpi *ua, int func)\n{\n\tunion acpi_object *obj;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(ua->dev), &ua->guid, 1, func,\n\t\t\t\tNULL);\n\tif (!obj) {\n\t\tdev_err(ua->dev, \"%s: failed to evaluate _DSM %d\\n\",\n\t\t\t__func__, func);\n\t\treturn -EIO;\n\t}\n\n\tACPI_FREE(obj);\n\treturn 0;\n}\n\nstatic int ucsi_acpi_read(struct ucsi *ucsi, unsigned int offset,\n\t\t\t  void *val, size_t val_len)\n{\n\tstruct ucsi_acpi *ua = ucsi_get_drvdata(ucsi);\n\tint ret;\n\n\tret = ucsi_acpi_dsm(ua, UCSI_DSM_FUNC_READ);\n\tif (ret)\n\t\treturn ret;\n\n\tmemcpy(val, ua->base + offset, val_len);\n\n\treturn 0;\n}\n\nstatic int ucsi_acpi_async_write(struct ucsi *ucsi, unsigned int offset,\n\t\t\t\t const void *val, size_t val_len)\n{\n\tstruct ucsi_acpi *ua = ucsi_get_drvdata(ucsi);\n\n\tmemcpy(ua->base + offset, val, val_len);\n\tua->cmd = *(u64 *)val;\n\n\treturn ucsi_acpi_dsm(ua, UCSI_DSM_FUNC_WRITE);\n}\n\nstatic int ucsi_acpi_sync_write(struct ucsi *ucsi, unsigned int offset,\n\t\t\t\tconst void *val, size_t val_len)\n{\n\tstruct ucsi_acpi *ua = ucsi_get_drvdata(ucsi);\n\tint ret;\n\n\tset_bit(COMMAND_PENDING, &ua->flags);\n\n\tret = ucsi_acpi_async_write(ucsi, offset, val, val_len);\n\tif (ret)\n\t\tgoto out_clear_bit;\n\n\tif (!wait_for_completion_timeout(&ua->complete, 5 * HZ))\n\t\tret = -ETIMEDOUT;\n\nout_clear_bit:\n\tclear_bit(COMMAND_PENDING, &ua->flags);\n\n\treturn ret;\n}\n\nstatic const struct ucsi_operations ucsi_acpi_ops = {\n\t.read = ucsi_acpi_read,\n\t.sync_write = ucsi_acpi_sync_write,\n\t.async_write = ucsi_acpi_async_write\n};\n\nstatic int\nucsi_zenbook_read(struct ucsi *ucsi, unsigned int offset, void *val, size_t val_len)\n{\n\tstruct ucsi_acpi *ua = ucsi_get_drvdata(ucsi);\n\tint ret;\n\n\tif (offset == UCSI_VERSION || UCSI_COMMAND(ua->cmd) == UCSI_PPM_RESET) {\n\t\tret = ucsi_acpi_dsm(ua, UCSI_DSM_FUNC_READ);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmemcpy(val, ua->base + offset, val_len);\n\n\treturn 0;\n}\n\nstatic const struct ucsi_operations ucsi_zenbook_ops = {\n\t.read = ucsi_zenbook_read,\n\t.sync_write = ucsi_acpi_sync_write,\n\t.async_write = ucsi_acpi_async_write\n};\n\nstatic const struct dmi_system_id zenbook_dmi_id[] = {\n\t{\n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"ASUSTeK COMPUTER INC.\"),\n\t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"ZenBook UX325UA_UM325UA\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic void ucsi_acpi_notify(acpi_handle handle, u32 event, void *data)\n{\n\tstruct ucsi_acpi *ua = data;\n\tu32 cci;\n\tint ret;\n\n\tret = ua->ucsi->ops->read(ua->ucsi, UCSI_CCI, &cci, sizeof(cci));\n\tif (ret)\n\t\treturn;\n\n\tif (UCSI_CCI_CONNECTOR(cci))\n\t\tucsi_connector_change(ua->ucsi, UCSI_CCI_CONNECTOR(cci));\n\n\tif (test_bit(COMMAND_PENDING, &ua->flags) &&\n\t    cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))\n\t\tcomplete(&ua->complete);\n}\n\nstatic int ucsi_acpi_probe(struct platform_device *pdev)\n{\n\tstruct acpi_device *adev = ACPI_COMPANION(&pdev->dev);\n\tconst struct ucsi_operations *ops = &ucsi_acpi_ops;\n\tstruct ucsi_acpi *ua;\n\tstruct resource *res;\n\tacpi_status status;\n\tint ret;\n\n\tif (adev->dep_unmet)\n\t\treturn -EPROBE_DEFER;\n\n\tua = devm_kzalloc(&pdev->dev, sizeof(*ua), GFP_KERNEL);\n\tif (!ua)\n\t\treturn -ENOMEM;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"missing memory resource\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tua->base = devm_memremap(&pdev->dev, res->start, resource_size(res), MEMREMAP_WB);\n\tif (IS_ERR(ua->base))\n\t\treturn PTR_ERR(ua->base);\n\n\tret = guid_parse(UCSI_DSM_UUID, &ua->guid);\n\tif (ret)\n\t\treturn ret;\n\n\tinit_completion(&ua->complete);\n\tua->dev = &pdev->dev;\n\n\tif (dmi_check_system(zenbook_dmi_id))\n\t\tops = &ucsi_zenbook_ops;\n\n\tua->ucsi = ucsi_create(&pdev->dev, ops);\n\tif (IS_ERR(ua->ucsi))\n\t\treturn PTR_ERR(ua->ucsi);\n\n\tucsi_set_drvdata(ua->ucsi, ua);\n\n\tstatus = acpi_install_notify_handler(ACPI_HANDLE(&pdev->dev),\n\t\t\t\t\t     ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t     ucsi_acpi_notify, ua);\n\tif (ACPI_FAILURE(status)) {\n\t\tdev_err(&pdev->dev, \"failed to install notify handler\\n\");\n\t\tucsi_destroy(ua->ucsi);\n\t\treturn -ENODEV;\n\t}\n\n\tret = ucsi_register(ua->ucsi);\n\tif (ret) {\n\t\tacpi_remove_notify_handler(ACPI_HANDLE(&pdev->dev),\n\t\t\t\t\t   ACPI_DEVICE_NOTIFY,\n\t\t\t\t\t   ucsi_acpi_notify);\n\t\tucsi_destroy(ua->ucsi);\n\t\treturn ret;\n\t}\n\n\tplatform_set_drvdata(pdev, ua);\n\n\treturn 0;\n}\n\nstatic void ucsi_acpi_remove(struct platform_device *pdev)\n{\n\tstruct ucsi_acpi *ua = platform_get_drvdata(pdev);\n\n\tucsi_unregister(ua->ucsi);\n\tucsi_destroy(ua->ucsi);\n\n\tacpi_remove_notify_handler(ACPI_HANDLE(&pdev->dev), ACPI_DEVICE_NOTIFY,\n\t\t\t\t   ucsi_acpi_notify);\n}\n\nstatic int ucsi_acpi_resume(struct device *dev)\n{\n\tstruct ucsi_acpi *ua = dev_get_drvdata(dev);\n\n\treturn ucsi_resume(ua->ucsi);\n}\n\nstatic DEFINE_SIMPLE_DEV_PM_OPS(ucsi_acpi_pm_ops, NULL, ucsi_acpi_resume);\n\nstatic const struct acpi_device_id ucsi_acpi_match[] = {\n\t{ \"PNP0CA0\", 0 },\n\t{ },\n};\nMODULE_DEVICE_TABLE(acpi, ucsi_acpi_match);\n\nstatic struct platform_driver ucsi_acpi_platform_driver = {\n\t.driver = {\n\t\t.name = \"ucsi_acpi\",\n\t\t.pm = pm_ptr(&ucsi_acpi_pm_ops),\n\t\t.acpi_match_table = ACPI_PTR(ucsi_acpi_match),\n\t},\n\t.probe = ucsi_acpi_probe,\n\t.remove_new = ucsi_acpi_remove,\n};\n\nmodule_platform_driver(ucsi_acpi_platform_driver);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"UCSI ACPI driver\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}