{
  "module_name": "ucsi_glink.c",
  "hash_id": "8f79328eb1732ed3d1a15edb34f29c7d647df51ff7d4933fc57a3ddb10c195e7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/ucsi/ucsi_glink.c",
  "human_readable_source": "\n \n#include <linux/auxiliary_bus.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/property.h>\n#include <linux/soc/qcom/pdr.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/gpio/consumer.h>\n#include <linux/soc/qcom/pmic_glink.h>\n#include \"ucsi.h\"\n\n#define PMIC_GLINK_MAX_PORTS\t2\n\n#define UCSI_BUF_SIZE                   48\n\n#define MSG_TYPE_REQ_RESP               1\n#define UCSI_BUF_SIZE                   48\n\n#define UC_NOTIFY_RECEIVER_UCSI         0x0\n#define UC_UCSI_READ_BUF_REQ            0x11\n#define UC_UCSI_WRITE_BUF_REQ           0x12\n#define UC_UCSI_USBC_NOTIFY_IND         0x13\n\nstruct ucsi_read_buf_req_msg {\n\tstruct pmic_glink_hdr   hdr;\n};\n\nstruct ucsi_read_buf_resp_msg {\n\tstruct pmic_glink_hdr   hdr;\n\tu8                      buf[UCSI_BUF_SIZE];\n\tu32                     ret_code;\n};\n\nstruct ucsi_write_buf_req_msg {\n\tstruct pmic_glink_hdr   hdr;\n\tu8                      buf[UCSI_BUF_SIZE];\n\tu32                     reserved;\n};\n\nstruct ucsi_write_buf_resp_msg {\n\tstruct pmic_glink_hdr   hdr;\n\tu32                     ret_code;\n};\n\nstruct ucsi_notify_ind_msg {\n\tstruct pmic_glink_hdr   hdr;\n\tu32                     notification;\n\tu32                     receiver;\n\tu32                     reserved;\n};\n\nstruct pmic_glink_ucsi {\n\tstruct device *dev;\n\n\tstruct gpio_desc *port_orientation[PMIC_GLINK_MAX_PORTS];\n\tstruct typec_switch *port_switch[PMIC_GLINK_MAX_PORTS];\n\n\tstruct pmic_glink_client *client;\n\n\tstruct ucsi *ucsi;\n\tstruct completion read_ack;\n\tstruct completion write_ack;\n\tstruct completion sync_ack;\n\tbool sync_pending;\n\tstruct mutex lock;\t \n\n\tint sync_val;\n\n\tstruct work_struct notify_work;\n\tstruct work_struct register_work;\n\n\tu8 read_buf[UCSI_BUF_SIZE];\n};\n\nstatic int pmic_glink_ucsi_read(struct ucsi *__ucsi, unsigned int offset,\n\t\t\t\tvoid *val, size_t val_len)\n{\n\tstruct pmic_glink_ucsi *ucsi = ucsi_get_drvdata(__ucsi);\n\tstruct ucsi_read_buf_req_msg req = {};\n\tunsigned long left;\n\tint ret;\n\n\treq.hdr.owner = PMIC_GLINK_OWNER_USBC;\n\treq.hdr.type = MSG_TYPE_REQ_RESP;\n\treq.hdr.opcode = UC_UCSI_READ_BUF_REQ;\n\n\tmutex_lock(&ucsi->lock);\n\tmemset(ucsi->read_buf, 0, sizeof(ucsi->read_buf));\n\treinit_completion(&ucsi->read_ack);\n\n\tret = pmic_glink_send(ucsi->client, &req, sizeof(req));\n\tif (ret < 0) {\n\t\tdev_err(ucsi->dev, \"failed to send UCSI read request: %d\\n\", ret);\n\t\tgoto out_unlock;\n\t}\n\n\tleft = wait_for_completion_timeout(&ucsi->read_ack, 5 * HZ);\n\tif (!left) {\n\t\tdev_err(ucsi->dev, \"timeout waiting for UCSI read response\\n\");\n\t\tret = -ETIMEDOUT;\n\t\tgoto out_unlock;\n\t}\n\n\tmemcpy(val, &ucsi->read_buf[offset], val_len);\n\tret = 0;\n\nout_unlock:\n\tmutex_unlock(&ucsi->lock);\n\n\treturn ret;\n}\n\nstatic int pmic_glink_ucsi_locked_write(struct pmic_glink_ucsi *ucsi, unsigned int offset,\n\t\t\t\t\tconst void *val, size_t val_len)\n{\n\tstruct ucsi_write_buf_req_msg req = {};\n\tunsigned long left;\n\tint ret;\n\n\treq.hdr.owner = PMIC_GLINK_OWNER_USBC;\n\treq.hdr.type = MSG_TYPE_REQ_RESP;\n\treq.hdr.opcode = UC_UCSI_WRITE_BUF_REQ;\n\tmemcpy(&req.buf[offset], val, val_len);\n\n\treinit_completion(&ucsi->write_ack);\n\n\tret = pmic_glink_send(ucsi->client, &req, sizeof(req));\n\tif (ret < 0) {\n\t\tdev_err(ucsi->dev, \"failed to send UCSI write request: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tleft = wait_for_completion_timeout(&ucsi->write_ack, 5 * HZ);\n\tif (!left) {\n\t\tdev_err(ucsi->dev, \"timeout waiting for UCSI write response\\n\");\n\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic int pmic_glink_ucsi_async_write(struct ucsi *__ucsi, unsigned int offset,\n\t\t\t\t       const void *val, size_t val_len)\n{\n\tstruct pmic_glink_ucsi *ucsi = ucsi_get_drvdata(__ucsi);\n\tint ret;\n\n\tmutex_lock(&ucsi->lock);\n\tret = pmic_glink_ucsi_locked_write(ucsi, offset, val, val_len);\n\tmutex_unlock(&ucsi->lock);\n\n\treturn ret;\n}\n\nstatic int pmic_glink_ucsi_sync_write(struct ucsi *__ucsi, unsigned int offset,\n\t\t\t\t      const void *val, size_t val_len)\n{\n\tstruct pmic_glink_ucsi *ucsi = ucsi_get_drvdata(__ucsi);\n\tunsigned long left;\n\tint ret;\n\n\t \n\n\tmutex_lock(&ucsi->lock);\n\tucsi->sync_val = 0;\n\treinit_completion(&ucsi->sync_ack);\n\tucsi->sync_pending = true;\n\tret = pmic_glink_ucsi_locked_write(ucsi, offset, val, val_len);\n\tmutex_unlock(&ucsi->lock);\n\n\tleft = wait_for_completion_timeout(&ucsi->sync_ack, 5 * HZ);\n\tif (!left) {\n\t\tdev_err(ucsi->dev, \"timeout waiting for UCSI sync write response\\n\");\n\t\tret = -ETIMEDOUT;\n\t} else if (ucsi->sync_val) {\n\t\tdev_err(ucsi->dev, \"sync write returned: %d\\n\", ucsi->sync_val);\n\t}\n\n\tucsi->sync_pending = false;\n\n\treturn ret;\n}\n\nstatic const struct ucsi_operations pmic_glink_ucsi_ops = {\n\t.read = pmic_glink_ucsi_read,\n\t.sync_write = pmic_glink_ucsi_sync_write,\n\t.async_write = pmic_glink_ucsi_async_write\n};\n\nstatic void pmic_glink_ucsi_read_ack(struct pmic_glink_ucsi *ucsi, const void *data, int len)\n{\n\tconst struct ucsi_read_buf_resp_msg *resp = data;\n\n\tif (resp->ret_code)\n\t\treturn;\n\n\tmemcpy(ucsi->read_buf, resp->buf, UCSI_BUF_SIZE);\n\tcomplete(&ucsi->read_ack);\n}\n\nstatic void pmic_glink_ucsi_write_ack(struct pmic_glink_ucsi *ucsi, const void *data, int len)\n{\n\tconst struct ucsi_write_buf_resp_msg *resp = data;\n\n\tif (resp->ret_code)\n\t\treturn;\n\n\tucsi->sync_val = resp->ret_code;\n\tcomplete(&ucsi->write_ack);\n}\n\nstatic void pmic_glink_ucsi_notify(struct work_struct *work)\n{\n\tstruct pmic_glink_ucsi *ucsi = container_of(work, struct pmic_glink_ucsi, notify_work);\n\tunsigned int con_num;\n\tu32 cci;\n\tint ret;\n\n\tret = pmic_glink_ucsi_read(ucsi->ucsi, UCSI_CCI, &cci, sizeof(cci));\n\tif (ret) {\n\t\tdev_err(ucsi->dev, \"failed to read CCI on notification\\n\");\n\t\treturn;\n\t}\n\n\tcon_num = UCSI_CCI_CONNECTOR(cci);\n\tif (con_num) {\n\t\tif (con_num <= PMIC_GLINK_MAX_PORTS &&\n\t\t    ucsi->port_orientation[con_num - 1]) {\n\t\t\tint orientation = gpiod_get_value(ucsi->port_orientation[con_num - 1]);\n\n\t\t\tif (orientation >= 0) {\n\t\t\t\ttypec_switch_set(ucsi->port_switch[con_num - 1],\n\t\t\t\t\t\t orientation ? TYPEC_ORIENTATION_REVERSE\n\t\t\t\t\t\t\t     : TYPEC_ORIENTATION_NORMAL);\n\t\t\t}\n\t\t}\n\n\t\tucsi_connector_change(ucsi->ucsi, con_num);\n\t}\n\n\tif (ucsi->sync_pending && cci & UCSI_CCI_BUSY) {\n\t\tucsi->sync_val = -EBUSY;\n\t\tcomplete(&ucsi->sync_ack);\n\t} else if (ucsi->sync_pending &&\n\t\t   (cci & (UCSI_CCI_ACK_COMPLETE | UCSI_CCI_COMMAND_COMPLETE))) {\n\t\tcomplete(&ucsi->sync_ack);\n\t}\n}\n\nstatic void pmic_glink_ucsi_register(struct work_struct *work)\n{\n\tstruct pmic_glink_ucsi *ucsi = container_of(work, struct pmic_glink_ucsi, register_work);\n\n\tucsi_register(ucsi->ucsi);\n}\n\nstatic void pmic_glink_ucsi_callback(const void *data, size_t len, void *priv)\n{\n\tstruct pmic_glink_ucsi *ucsi = priv;\n\tconst struct pmic_glink_hdr *hdr = data;\n\n\tswitch (le32_to_cpu(hdr->opcode)) {\n\tcase UC_UCSI_READ_BUF_REQ:\n\t\tpmic_glink_ucsi_read_ack(ucsi, data, len);\n\t\tbreak;\n\tcase UC_UCSI_WRITE_BUF_REQ:\n\t\tpmic_glink_ucsi_write_ack(ucsi, data, len);\n\t\tbreak;\n\tcase UC_UCSI_USBC_NOTIFY_IND:\n\t\tschedule_work(&ucsi->notify_work);\n\t\tbreak;\n\t};\n}\n\nstatic void pmic_glink_ucsi_pdr_notify(void *priv, int state)\n{\n\tstruct pmic_glink_ucsi *ucsi = priv;\n\n\tif (state == SERVREG_SERVICE_STATE_UP)\n\t\tschedule_work(&ucsi->register_work);\n\telse if (state == SERVREG_SERVICE_STATE_DOWN)\n\t\tucsi_unregister(ucsi->ucsi);\n}\n\nstatic void pmic_glink_ucsi_destroy(void *data)\n{\n\tstruct pmic_glink_ucsi *ucsi = data;\n\n\t \n\tmutex_lock(&ucsi->lock);\n\tucsi_destroy(ucsi->ucsi);\n\tmutex_unlock(&ucsi->lock);\n}\n\nstatic int pmic_glink_ucsi_probe(struct auxiliary_device *adev,\n\t\t\t\t const struct auxiliary_device_id *id)\n{\n\tstruct pmic_glink_ucsi *ucsi;\n\tstruct device *dev = &adev->dev;\n\tstruct fwnode_handle *fwnode;\n\tint ret;\n\n\tucsi = devm_kzalloc(dev, sizeof(*ucsi), GFP_KERNEL);\n\tif (!ucsi)\n\t\treturn -ENOMEM;\n\n\tucsi->dev = dev;\n\tdev_set_drvdata(dev, ucsi);\n\n\tINIT_WORK(&ucsi->notify_work, pmic_glink_ucsi_notify);\n\tINIT_WORK(&ucsi->register_work, pmic_glink_ucsi_register);\n\tinit_completion(&ucsi->read_ack);\n\tinit_completion(&ucsi->write_ack);\n\tinit_completion(&ucsi->sync_ack);\n\tmutex_init(&ucsi->lock);\n\n\tucsi->ucsi = ucsi_create(dev, &pmic_glink_ucsi_ops);\n\tif (IS_ERR(ucsi->ucsi))\n\t\treturn PTR_ERR(ucsi->ucsi);\n\n\t \n\tret = devm_add_action_or_reset(dev, pmic_glink_ucsi_destroy, ucsi);\n\tif (ret)\n\t\treturn ret;\n\n\tucsi_set_drvdata(ucsi->ucsi, ucsi);\n\n\tdevice_for_each_child_node(dev, fwnode) {\n\t\tstruct gpio_desc *desc;\n\t\tu32 port;\n\n\t\tret = fwnode_property_read_u32(fwnode, \"reg\", &port);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"missing reg property of %pOFn\\n\", fwnode);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (port >= PMIC_GLINK_MAX_PORTS) {\n\t\t\tdev_warn(dev, \"invalid connector number, ignoring\\n\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tdesc = devm_gpiod_get_index_optional(&adev->dev, \"orientation\", port, GPIOD_IN);\n\n\t\t \n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\tif (IS_ERR(desc))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(desc),\n\t\t\t\t\t     \"unable to acquire orientation gpio\\n\");\n\t\tucsi->port_orientation[port] = desc;\n\n\t\tucsi->port_switch[port] = fwnode_typec_switch_get(fwnode);\n\t\tif (IS_ERR(ucsi->port_switch[port]))\n\t\t\treturn dev_err_probe(dev, PTR_ERR(ucsi->port_switch[port]),\n\t\t\t\t\t\"failed to acquire orientation-switch\\n\");\n\t}\n\n\tucsi->client = devm_pmic_glink_register_client(dev,\n\t\t\t\t\t\t       PMIC_GLINK_OWNER_USBC,\n\t\t\t\t\t\t       pmic_glink_ucsi_callback,\n\t\t\t\t\t\t       pmic_glink_ucsi_pdr_notify,\n\t\t\t\t\t\t       ucsi);\n\treturn PTR_ERR_OR_ZERO(ucsi->client);\n}\n\nstatic void pmic_glink_ucsi_remove(struct auxiliary_device *adev)\n{\n\tstruct pmic_glink_ucsi *ucsi = dev_get_drvdata(&adev->dev);\n\n\t \n\tucsi_unregister(ucsi->ucsi);\n}\n\nstatic const struct auxiliary_device_id pmic_glink_ucsi_id_table[] = {\n\t{ .name = \"pmic_glink.ucsi\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(auxiliary, pmic_glink_ucsi_id_table);\n\nstatic struct auxiliary_driver pmic_glink_ucsi_driver = {\n\t.name = \"pmic_glink_ucsi\",\n\t.probe = pmic_glink_ucsi_probe,\n\t.remove = pmic_glink_ucsi_remove,\n\t.id_table = pmic_glink_ucsi_id_table,\n};\n\nmodule_auxiliary_driver(pmic_glink_ucsi_driver);\n\nMODULE_DESCRIPTION(\"Qualcomm PMIC GLINK UCSI driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}