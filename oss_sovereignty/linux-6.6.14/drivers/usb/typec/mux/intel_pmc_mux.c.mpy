{
  "module_name": "intel_pmc_mux.c",
  "hash_id": "7cc07b02bcb118b4ee70f0f8450b7704fd75e8707f239dcbd62d6eb1c227a904",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/mux/intel_pmc_mux.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/role.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_tbt.h>\n#include <linux/debugfs.h>\n#include <linux/usb.h>\n\n#include <asm/intel_scu_ipc.h>\n\n#define PMC_USBC_CMD\t\t0xa7\n\n \n#define PMC_USB_RESP_STATUS_FAILURE\tBIT(0)\n#define PMC_USB_RESP_STATUS_FATAL\tBIT(1)\n\n \nenum {\n\tPMC_USB_CONNECT,\n\tPMC_USB_DISCONNECT,\n\tPMC_USB_SAFE_MODE,\n\tPMC_USB_ALT_MODE,\n\tPMC_USB_DP_HPD,\n};\n\n#define PMC_USB_MSG_USB2_PORT_SHIFT\t0\n#define PMC_USB_MSG_USB3_PORT_SHIFT\t4\n#define PMC_USB_MSG_UFP_SHIFT\t\t4\n#define PMC_USB_MSG_ORI_HSL_SHIFT\t5\n#define PMC_USB_MSG_ORI_AUX_SHIFT\t6\n\n \nstruct altmode_req {\n\tu8 usage;\n\tu8 mode_type;\n\tu8 mode_id;\n\tu8 reserved;\n\tu32 mode_data;\n} __packed;\n\n#define PMC_USB_MODE_TYPE_SHIFT\t\t4\n\nenum {\n\tPMC_USB_MODE_TYPE_USB,\n\tPMC_USB_MODE_TYPE_DP,\n\tPMC_USB_MODE_TYPE_TBT,\n};\n\n \n#define PMC_USB_ALTMODE_RETIMER_CABLE\tBIT(2)\n\n#define PMC_USB_ALTMODE_ORI_SHIFT\t1\n#define PMC_USB_ALTMODE_UFP_SHIFT\t3\n\n \n#define PMC_USB_ALTMODE_DP_MODE_SHIFT\t8\n\n \n#define PMC_USB_ALTMODE_TBT_TYPE\tBIT(17)\n#define PMC_USB_ALTMODE_CABLE_TYPE\tBIT(18)\n#define PMC_USB_ALTMODE_ACTIVE_LINK\tBIT(20)\n#define PMC_USB_ALTMODE_ACTIVE_CABLE\tBIT(22)\n#define PMC_USB_ALTMODE_FORCE_LSR\tBIT(23)\n#define PMC_USB_ALTMODE_CABLE_SPD(_s_)\t(((_s_) & GENMASK(2, 0)) << 25)\n#define   PMC_USB_ALTMODE_CABLE_USB31\t1\n#define   PMC_USB_ALTMODE_CABLE_10GPS\t2\n#define   PMC_USB_ALTMODE_CABLE_20GPS\t3\n#define PMC_USB_ALTMODE_TBT_GEN(_g_)\t(((_g_) & GENMASK(1, 0)) << 28)\n\n \n#define PMC_USB_DP_HPD_LVL\t\tBIT(4)\n#define PMC_USB_DP_HPD_IRQ\t\tBIT(5)\n\n \n#define IOM_PORT_STATUS_ACTIVITY_TYPE_MASK\t\tGENMASK(9, 6)\n#define IOM_PORT_STATUS_ACTIVITY_TYPE_SHIFT\t\t6\n#define IOM_PORT_STATUS_ACTIVITY_TYPE_USB\t\t0x03\n \n#define IOM_PORT_STATUS_ACTIVITY_TYPE_SAFE_MODE\t\t0x04\n \n#define IOM_PORT_STATUS_ACTIVITY_TYPE_DP\t\t0x05\n \n#define IOM_PORT_STATUS_ACTIVITY_TYPE_DP_MFD\t\t0x06\n \n#define IOM_PORT_STATUS_ACTIVITY_TYPE_TBT\t\t0x07\n#define IOM_PORT_STATUS_ACTIVITY_TYPE_ALT_MODE_USB\t0x0c\n#define IOM_PORT_STATUS_ACTIVITY_TYPE_ALT_MODE_TBT_USB\t0x0d\n \n#define IOM_PORT_STATUS_UFP\t\t\t\tBIT(10)\n \n#define IOM_PORT_STATUS_DHPD_HPD_STATUS_MASK\t\tGENMASK(13, 12)\n#define IOM_PORT_STATUS_DHPD_HPD_STATUS_SHIFT\t\t12\n#define IOM_PORT_STATUS_DHPD_HPD_STATUS_ASSERT\t\t0x01\n#define IOM_PORT_STATUS_DHPD_HPD_SOURCE_TBT\t\tBIT(14)\n#define IOM_PORT_STATUS_CONNECTED\t\t\tBIT(31)\n\n#define IOM_PORT_ACTIVITY_IS(_status_, _type_)\t\t\t\t\\\n\t((((_status_) & IOM_PORT_STATUS_ACTIVITY_TYPE_MASK) >>\t\t\\\n\t  IOM_PORT_STATUS_ACTIVITY_TYPE_SHIFT) ==\t\t\t\\\n\t (IOM_PORT_STATUS_ACTIVITY_TYPE_##_type_))\n\n#define IOM_PORT_HPD_ASSERTED(_status_)\t\t\t\t\t\\\n\t((((_status_) & IOM_PORT_STATUS_DHPD_HPD_STATUS_MASK) >>\t\\\n\t  IOM_PORT_STATUS_DHPD_HPD_STATUS_SHIFT) &\t\t\t\\\n\t IOM_PORT_STATUS_DHPD_HPD_STATUS_ASSERT)\n\n \n#define IOM_PORT_STATUS_REGS(_offset_, _size_)\t((_offset_) | (_size_))\n#define IOM_PORT_STATUS_REGS_SZ_MASK\t\tBIT(0)\n#define IOM_PORT_STATUS_REGS_SZ_4\t\t0\n#define IOM_PORT_STATUS_REGS_SZ_8\t\t1\n#define IOM_PORT_STATUS_REGS_OFFSET(_d_)\t\t\t\t\\\n\t((_d_) & ~IOM_PORT_STATUS_REGS_SZ_MASK)\n#define IOM_PORT_STATUS_REGS_SIZE(_d_)\t\t\t\t\t\\\n\t(4 << ((_d_) & IOM_PORT_STATUS_REGS_SZ_MASK))\n\nstruct pmc_usb;\n\nstruct pmc_usb_port {\n\tint num;\n\tu32 iom_status;\n\tstruct pmc_usb *pmc;\n\tstruct typec_mux_dev *typec_mux;\n\tstruct typec_switch_dev *typec_sw;\n\tstruct usb_role_switch *usb_sw;\n\n\tenum typec_orientation orientation;\n\tenum usb_role role;\n\n\tu8 usb2_port;\n\tu8 usb3_port;\n\n\tenum typec_orientation sbu_orientation;\n\tenum typec_orientation hsl_orientation;\n};\n\nstruct pmc_usb {\n\tu8 num_ports;\n\tstruct device *dev;\n\tstruct intel_scu_ipc_dev *ipc;\n\tstruct pmc_usb_port *port;\n\tstruct acpi_device *iom_adev;\n\tvoid __iomem *iom_base;\n\tu32 iom_port_status_offset;\n\tu8 iom_port_status_size;\n\n\tstruct dentry *dentry;\n};\n\nstatic struct dentry *pmc_mux_debugfs_root;\n\nstatic void update_port_status(struct pmc_usb_port *port)\n{\n\tu8 port_num;\n\n\t \n\tport_num = port->usb3_port - 1;\n\n\tport->iom_status = readl(port->pmc->iom_base +\n\t\t\t\t port->pmc->iom_port_status_offset +\n\t\t\t\t port_num * port->pmc->iom_port_status_size);\n}\n\nstatic int sbu_orientation(struct pmc_usb_port *port)\n{\n\tif (port->sbu_orientation)\n\t\treturn port->sbu_orientation - 1;\n\n\treturn port->orientation - 1;\n}\n\nstatic int hsl_orientation(struct pmc_usb_port *port)\n{\n\tif (port->hsl_orientation)\n\t\treturn port->hsl_orientation - 1;\n\n\treturn port->orientation - 1;\n}\n\nstatic int pmc_usb_send_command(struct intel_scu_ipc_dev *ipc, u8 *msg, u32 len)\n{\n\tu8 response[4];\n\tu8 status_res;\n\tint ret;\n\n\t \n\tret = intel_scu_ipc_dev_command(ipc, PMC_USBC_CMD, 0, msg,\n\t\t\t\t\tlen, response, sizeof(response));\n\n\tif (ret)\n\t\treturn ret;\n\n\tstatus_res = (msg[0] & 0xf) < PMC_USB_SAFE_MODE ?\n\t\t     response[2] : response[1];\n\n\tif (status_res & PMC_USB_RESP_STATUS_FAILURE) {\n\t\tif (status_res & PMC_USB_RESP_STATUS_FATAL)\n\t\t\treturn -EIO;\n\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\n\nstatic int pmc_usb_command(struct pmc_usb_port *port, u8 *msg, u32 len)\n{\n\tint retry_count = 3;\n\tint ret;\n\n\t \n\twhile (retry_count--) {\n\t\tret = pmc_usb_send_command(port->pmc->ipc, msg, len);\n\t\tif (ret != -EBUSY)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int\npmc_usb_mux_dp_hpd(struct pmc_usb_port *port, struct typec_displayport_data *dp)\n{\n\tu8 msg[2] = { };\n\tint ret;\n\n\tmsg[0] = PMC_USB_DP_HPD;\n\tmsg[0] |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\n\t \n\tif (!IOM_PORT_HPD_ASSERTED(port->iom_status) &&\n\t    dp->status & DP_STATUS_IRQ_HPD &&\n\t    dp->status & DP_STATUS_HPD_STATE) {\n\t\tmsg[1] = PMC_USB_DP_HPD_LVL;\n\t\tret = pmc_usb_command(port, msg, sizeof(msg));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (dp->status & DP_STATUS_IRQ_HPD)\n\t\tmsg[1] = PMC_USB_DP_HPD_IRQ;\n\n\tif (dp->status & DP_STATUS_HPD_STATE)\n\t\tmsg[1] |= PMC_USB_DP_HPD_LVL;\n\n\treturn pmc_usb_command(port, msg, sizeof(msg));\n}\n\nstatic int\npmc_usb_mux_dp(struct pmc_usb_port *port, struct typec_mux_state *state)\n{\n\tstruct typec_displayport_data *data = state->data;\n\tstruct altmode_req req = { };\n\tint ret;\n\n\tif (IOM_PORT_ACTIVITY_IS(port->iom_status, DP) ||\n\t    IOM_PORT_ACTIVITY_IS(port->iom_status, DP_MFD)) {\n\t\tif (IOM_PORT_HPD_ASSERTED(port->iom_status) &&\n\t\t    (!(data->status & DP_STATUS_IRQ_HPD) &&\n\t\t     data->status & DP_STATUS_HPD_STATE))\n\t\t\treturn 0;\n\n\t\treturn pmc_usb_mux_dp_hpd(port, state->data);\n\t}\n\n\treq.usage = PMC_USB_ALT_MODE;\n\treq.usage |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\treq.mode_type = PMC_USB_MODE_TYPE_DP << PMC_USB_MODE_TYPE_SHIFT;\n\n\treq.mode_data = (port->orientation - 1) << PMC_USB_ALTMODE_ORI_SHIFT;\n\treq.mode_data |= (port->role - 1) << PMC_USB_ALTMODE_UFP_SHIFT;\n\n\treq.mode_data |= (state->mode - TYPEC_STATE_MODAL) <<\n\t\t\t PMC_USB_ALTMODE_DP_MODE_SHIFT;\n\n\tret = pmc_usb_command(port, (void *)&req, sizeof(req));\n\tif (ret)\n\t\treturn ret;\n\n\tif (data->status & (DP_STATUS_IRQ_HPD | DP_STATUS_HPD_STATE))\n\t\treturn pmc_usb_mux_dp_hpd(port, state->data);\n\n\treturn 0;\n}\n\nstatic int\npmc_usb_mux_tbt(struct pmc_usb_port *port, struct typec_mux_state *state)\n{\n\tstruct typec_thunderbolt_data *data = state->data;\n\tu8 cable_rounded = TBT_CABLE_ROUNDED_SUPPORT(data->cable_mode);\n\tu8 cable_speed = TBT_CABLE_SPEED(data->cable_mode);\n\tstruct altmode_req req = { };\n\n\tif (IOM_PORT_ACTIVITY_IS(port->iom_status, TBT) ||\n\t    IOM_PORT_ACTIVITY_IS(port->iom_status, ALT_MODE_TBT_USB))\n\t\treturn 0;\n\n\treq.usage = PMC_USB_ALT_MODE;\n\treq.usage |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\treq.mode_type = PMC_USB_MODE_TYPE_TBT << PMC_USB_MODE_TYPE_SHIFT;\n\n\treq.mode_data = (port->orientation - 1) << PMC_USB_ALTMODE_ORI_SHIFT;\n\treq.mode_data |= (port->role - 1) << PMC_USB_ALTMODE_UFP_SHIFT;\n\n\tif (TBT_ADAPTER(data->device_mode) == TBT_ADAPTER_TBT3)\n\t\treq.mode_data |= PMC_USB_ALTMODE_TBT_TYPE;\n\n\tif (data->cable_mode & TBT_CABLE_OPTICAL)\n\t\treq.mode_data |= PMC_USB_ALTMODE_CABLE_TYPE;\n\n\tif (data->cable_mode & TBT_CABLE_LINK_TRAINING)\n\t\treq.mode_data |= PMC_USB_ALTMODE_ACTIVE_LINK;\n\n\tif (acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1072\", NULL) ||\n\t    acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1079\", NULL)) {\n\t\tif ((data->enter_vdo & TBT_ENTER_MODE_ACTIVE_CABLE) ||\n\t\t    (data->cable_mode & TBT_CABLE_RETIMER))\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_RETIMER_CABLE;\n\t} else {\n\t\tif (data->enter_vdo & TBT_ENTER_MODE_ACTIVE_CABLE)\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_ACTIVE_CABLE;\n\n\t\tif (data->cable_mode & TBT_CABLE_RETIMER)\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_RETIMER_CABLE;\n\t}\n\n\treq.mode_data |= PMC_USB_ALTMODE_CABLE_SPD(cable_speed);\n\n\treq.mode_data |= PMC_USB_ALTMODE_TBT_GEN(cable_rounded);\n\n\treturn pmc_usb_command(port, (void *)&req, sizeof(req));\n}\n\nstatic int\npmc_usb_mux_usb4(struct pmc_usb_port *port, struct typec_mux_state *state)\n{\n\tstruct enter_usb_data *data = state->data;\n\tstruct altmode_req req = { };\n\tu8 cable_speed;\n\n\tif (IOM_PORT_ACTIVITY_IS(port->iom_status, TBT) ||\n\t    IOM_PORT_ACTIVITY_IS(port->iom_status, ALT_MODE_TBT_USB))\n\t\treturn 0;\n\n\treq.usage = PMC_USB_ALT_MODE;\n\treq.usage |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\treq.mode_type = PMC_USB_MODE_TYPE_TBT << PMC_USB_MODE_TYPE_SHIFT;\n\n\t \n\treq.mode_data = PMC_USB_ALTMODE_FORCE_LSR;\n\n\tif (data->active_link_training)\n\t\treq.mode_data |= PMC_USB_ALTMODE_ACTIVE_LINK;\n\n\treq.mode_data |= (port->orientation - 1) << PMC_USB_ALTMODE_ORI_SHIFT;\n\treq.mode_data |= (port->role - 1) << PMC_USB_ALTMODE_UFP_SHIFT;\n\n\tswitch ((data->eudo & EUDO_CABLE_TYPE_MASK) >> EUDO_CABLE_TYPE_SHIFT) {\n\tcase EUDO_CABLE_TYPE_PASSIVE:\n\t\tbreak;\n\tcase EUDO_CABLE_TYPE_OPTICAL:\n\t\treq.mode_data |= PMC_USB_ALTMODE_CABLE_TYPE;\n\t\tfallthrough;\n\tcase EUDO_CABLE_TYPE_RE_TIMER:\n\t\tif (!acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1072\", NULL) ||\n\t\t    !acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1079\", NULL))\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_RETIMER_CABLE;\n\t\tfallthrough;\n\tdefault:\n\t\tif (acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1072\", NULL) ||\n\t\t    acpi_dev_hid_uid_match(port->pmc->iom_adev, \"INTC1079\", NULL))\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_RETIMER_CABLE;\n\t\telse\n\t\t\treq.mode_data |= PMC_USB_ALTMODE_ACTIVE_CABLE;\n\n\t\t \n\t\treq.mode_data |= PMC_USB_ALTMODE_TBT_GEN(1);\n\t\tbreak;\n\t}\n\n\tcable_speed = (data->eudo & EUDO_CABLE_SPEED_MASK) >> EUDO_CABLE_SPEED_SHIFT;\n\treq.mode_data |= PMC_USB_ALTMODE_CABLE_SPD(cable_speed);\n\n\treturn pmc_usb_command(port, (void *)&req, sizeof(req));\n}\n\nstatic int pmc_usb_mux_safe_state(struct pmc_usb_port *port,\n\t\t\t\t  struct typec_mux_state *state)\n{\n\tu8 msg;\n\n\tif (IOM_PORT_ACTIVITY_IS(port->iom_status, SAFE_MODE))\n\t\treturn 0;\n\n\tif ((IOM_PORT_ACTIVITY_IS(port->iom_status, DP) ||\n\t     IOM_PORT_ACTIVITY_IS(port->iom_status, DP_MFD)) &&\n\t     state->alt && state->alt->svid == USB_TYPEC_DP_SID)\n\t\treturn 0;\n\n\tif ((IOM_PORT_ACTIVITY_IS(port->iom_status, TBT) ||\n\t     IOM_PORT_ACTIVITY_IS(port->iom_status, ALT_MODE_TBT_USB)) &&\n\t     state->alt && state->alt->svid == USB_TYPEC_TBT_SID)\n\t\treturn 0;\n\n\tmsg = PMC_USB_SAFE_MODE;\n\tmsg |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\n\treturn pmc_usb_command(port, &msg, sizeof(msg));\n}\n\nstatic int pmc_usb_disconnect(struct pmc_usb_port *port)\n{\n\tstruct typec_displayport_data data = { };\n\tu8 msg[2];\n\n\tif (!(port->iom_status & IOM_PORT_STATUS_CONNECTED))\n\t\treturn 0;\n\n\t \n\tif (IOM_PORT_HPD_ASSERTED(port->iom_status))\n\t\tpmc_usb_mux_dp_hpd(port, &data);\n\n\tmsg[0] = PMC_USB_DISCONNECT;\n\tmsg[0] |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\n\tmsg[1] = port->usb2_port << PMC_USB_MSG_USB2_PORT_SHIFT;\n\n\treturn pmc_usb_command(port, msg, sizeof(msg));\n}\n\nstatic int pmc_usb_connect(struct pmc_usb_port *port, enum usb_role role)\n{\n\tu8 ufp = role == USB_ROLE_DEVICE ? 1 : 0;\n\tu8 msg[2];\n\tint ret;\n\n\tif (port->orientation == TYPEC_ORIENTATION_NONE)\n\t\treturn -EINVAL;\n\n\tif (port->iom_status & IOM_PORT_STATUS_CONNECTED) {\n\t\tif (port->role == role || port->role == USB_ROLE_NONE)\n\t\t\treturn 0;\n\n\t\t \n\t\tret = pmc_usb_disconnect(port);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tmsg[0] = PMC_USB_CONNECT;\n\tmsg[0] |= port->usb3_port << PMC_USB_MSG_USB3_PORT_SHIFT;\n\n\tmsg[1] = port->usb2_port << PMC_USB_MSG_USB2_PORT_SHIFT;\n\tmsg[1] |= ufp << PMC_USB_MSG_UFP_SHIFT;\n\tmsg[1] |= hsl_orientation(port) << PMC_USB_MSG_ORI_HSL_SHIFT;\n\tmsg[1] |= sbu_orientation(port) << PMC_USB_MSG_ORI_AUX_SHIFT;\n\n\treturn pmc_usb_command(port, msg, sizeof(msg));\n}\n\nstatic int\npmc_usb_mux_set(struct typec_mux_dev *mux, struct typec_mux_state *state)\n{\n\tstruct pmc_usb_port *port = typec_mux_get_drvdata(mux);\n\n\tupdate_port_status(port);\n\n\tif (port->orientation == TYPEC_ORIENTATION_NONE || port->role == USB_ROLE_NONE)\n\t\treturn 0;\n\n\tif (state->mode == TYPEC_STATE_SAFE)\n\t\treturn pmc_usb_mux_safe_state(port, state);\n\tif (state->mode == TYPEC_STATE_USB)\n\t\treturn pmc_usb_connect(port, port->role);\n\n\tif (state->alt) {\n\t\tswitch (state->alt->svid) {\n\t\tcase USB_TYPEC_TBT_SID:\n\t\t\treturn pmc_usb_mux_tbt(port, state);\n\t\tcase USB_TYPEC_DP_SID:\n\t\t\treturn pmc_usb_mux_dp(port, state);\n\t\t}\n\t} else {\n\t\tswitch (state->mode) {\n\t\tcase TYPEC_MODE_USB2:\n\t\t\t \n\t\t\tbreak;\n\t\tcase TYPEC_MODE_USB3:\n\t\t\treturn pmc_usb_connect(port, port->role);\n\t\tcase TYPEC_MODE_USB4:\n\t\t\treturn pmc_usb_mux_usb4(port, state);\n\t\t}\n\t}\n\n\treturn -EOPNOTSUPP;\n}\n\nstatic int pmc_usb_set_orientation(struct typec_switch_dev *sw,\n\t\t\t\t   enum typec_orientation orientation)\n{\n\tstruct pmc_usb_port *port = typec_switch_get_drvdata(sw);\n\n\tupdate_port_status(port);\n\n\tport->orientation = orientation;\n\n\treturn 0;\n}\n\nstatic int pmc_usb_set_role(struct usb_role_switch *sw, enum usb_role role)\n{\n\tstruct pmc_usb_port *port = usb_role_switch_get_drvdata(sw);\n\tint ret;\n\n\tupdate_port_status(port);\n\n\tif (role == USB_ROLE_NONE)\n\t\tret = pmc_usb_disconnect(port);\n\telse\n\t\tret = pmc_usb_connect(port, role);\n\n\tport->role = role;\n\n\treturn ret;\n}\n\nstatic int pmc_usb_register_port(struct pmc_usb *pmc, int index,\n\t\t\t\t struct fwnode_handle *fwnode)\n{\n\tstruct pmc_usb_port *port = &pmc->port[index];\n\tstruct usb_role_switch_desc desc = { };\n\tstruct typec_switch_desc sw_desc = { };\n\tstruct typec_mux_desc mux_desc = { };\n\tconst char *str;\n\tint ret;\n\n\tret = fwnode_property_read_u8(fwnode, \"usb2-port-number\", &port->usb2_port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fwnode_property_read_u8(fwnode, \"usb3-port-number\", &port->usb3_port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = fwnode_property_read_string(fwnode, \"sbu-orientation\", &str);\n\tif (!ret)\n\t\tport->sbu_orientation = typec_find_orientation(str);\n\n\tret = fwnode_property_read_string(fwnode, \"hsl-orientation\", &str);\n\tif (!ret)\n\t\tport->hsl_orientation = typec_find_orientation(str);\n\n\tport->num = index;\n\tport->pmc = pmc;\n\n\tsw_desc.fwnode = fwnode;\n\tsw_desc.drvdata = port;\n\tsw_desc.name = fwnode_get_name(fwnode);\n\tsw_desc.set = pmc_usb_set_orientation;\n\n\tport->typec_sw = typec_switch_register(pmc->dev, &sw_desc);\n\tif (IS_ERR(port->typec_sw))\n\t\treturn PTR_ERR(port->typec_sw);\n\n\tmux_desc.fwnode = fwnode;\n\tmux_desc.drvdata = port;\n\tmux_desc.name = fwnode_get_name(fwnode);\n\tmux_desc.set = pmc_usb_mux_set;\n\n\tport->typec_mux = typec_mux_register(pmc->dev, &mux_desc);\n\tif (IS_ERR(port->typec_mux)) {\n\t\tret = PTR_ERR(port->typec_mux);\n\t\tgoto err_unregister_switch;\n\t}\n\n\tdesc.fwnode = fwnode;\n\tdesc.driver_data = port;\n\tdesc.name = fwnode_get_name(fwnode);\n\tdesc.set = pmc_usb_set_role;\n\n\tport->usb_sw = usb_role_switch_register(pmc->dev, &desc);\n\tif (IS_ERR(port->usb_sw)) {\n\t\tret = PTR_ERR(port->usb_sw);\n\t\tgoto err_unregister_mux;\n\t}\n\n\treturn 0;\n\nerr_unregister_mux:\n\ttypec_mux_unregister(port->typec_mux);\n\nerr_unregister_switch:\n\ttypec_switch_unregister(port->typec_sw);\n\n\treturn ret;\n}\n\n \nstatic const struct acpi_device_id iom_acpi_ids[] = {\n\t \n\t{ \"INTC1072\", IOM_PORT_STATUS_REGS(0x560, IOM_PORT_STATUS_REGS_SZ_4) },\n\n\t \n\t{ \"INTC1079\", IOM_PORT_STATUS_REGS(0x160, IOM_PORT_STATUS_REGS_SZ_4) },\n\n\t \n\t{ \"INTC107A\", IOM_PORT_STATUS_REGS(0x160, IOM_PORT_STATUS_REGS_SZ_4) },\n\n\t \n\t{ \"INTC10EA\", IOM_PORT_STATUS_REGS(0x150, IOM_PORT_STATUS_REGS_SZ_8) },\n\t{}\n};\n\nstatic int pmc_usb_probe_iom(struct pmc_usb *pmc)\n{\n\tstruct list_head resource_list;\n\tstruct resource_entry *rentry;\n\tstatic const struct acpi_device_id *dev_id;\n\tstruct acpi_device *adev = NULL;\n\tint ret;\n\n\tfor (dev_id = &iom_acpi_ids[0]; dev_id->id[0]; dev_id++) {\n\t\tadev = acpi_dev_get_first_match_dev(dev_id->id, NULL, -1);\n\t\tif (adev)\n\t\t\tbreak;\n\t}\n\tif (!adev)\n\t\treturn -ENODEV;\n\n\tpmc->iom_port_status_offset = IOM_PORT_STATUS_REGS_OFFSET(dev_id->driver_data);\n\tpmc->iom_port_status_size = IOM_PORT_STATUS_REGS_SIZE(dev_id->driver_data);\n\n\tINIT_LIST_HEAD(&resource_list);\n\tret = acpi_dev_get_memory_resources(adev, &resource_list);\n\tif (ret < 0) {\n\t\tacpi_dev_put(adev);\n\t\treturn ret;\n\t}\n\n\trentry = list_first_entry_or_null(&resource_list, struct resource_entry, node);\n\tif (rentry)\n\t\tpmc->iom_base = devm_ioremap_resource(pmc->dev, rentry->res);\n\n\tacpi_dev_free_resource_list(&resource_list);\n\n\tif (!pmc->iom_base) {\n\t\tacpi_dev_put(adev);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (IS_ERR(pmc->iom_base)) {\n\t\tacpi_dev_put(adev);\n\t\treturn PTR_ERR(pmc->iom_base);\n\t}\n\n\tpmc->iom_adev = adev;\n\n\treturn 0;\n}\n\nstatic int port_iom_status_show(struct seq_file *s, void *unused)\n{\n\tstruct pmc_usb_port *port = s->private;\n\n\tupdate_port_status(port);\n\tseq_printf(s, \"0x%08x\\n\", port->iom_status);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(port_iom_status);\n\nstatic void pmc_mux_port_debugfs_init(struct pmc_usb_port *port)\n{\n\tstruct dentry *debugfs_dir;\n\tchar name[6];\n\n\tsnprintf(name, sizeof(name), \"port%d\", port->usb3_port - 1);\n\n\tdebugfs_dir = debugfs_create_dir(name, port->pmc->dentry);\n\tdebugfs_create_file(\"iom_status\", 0400, debugfs_dir, port,\n\t\t\t    &port_iom_status_fops);\n}\n\nstatic int pmc_usb_probe(struct platform_device *pdev)\n{\n\tstruct fwnode_handle *fwnode = NULL;\n\tstruct pmc_usb *pmc;\n\tint i = 0;\n\tint ret;\n\n\tpmc = devm_kzalloc(&pdev->dev, sizeof(*pmc), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn -ENOMEM;\n\n\tdevice_for_each_child_node(&pdev->dev, fwnode)\n\t\tpmc->num_ports++;\n\n\t \n\tif (pmc->num_ports > 4) {\n\t\tdev_err(&pdev->dev, \"driver limited to 4 ports\\n\");\n\t\treturn -ERANGE;\n\t}\n\n\tpmc->port = devm_kcalloc(&pdev->dev, pmc->num_ports,\n\t\t\t\t sizeof(struct pmc_usb_port), GFP_KERNEL);\n\tif (!pmc->port)\n\t\treturn -ENOMEM;\n\n\tpmc->ipc = devm_intel_scu_ipc_dev_get(&pdev->dev);\n\tif (!pmc->ipc)\n\t\treturn -ENODEV;\n\n\tpmc->dev = &pdev->dev;\n\n\tret = pmc_usb_probe_iom(pmc);\n\tif (ret)\n\t\treturn ret;\n\n\tpmc->dentry = debugfs_create_dir(dev_name(pmc->dev), pmc_mux_debugfs_root);\n\n\t \n\tfor (i = 0; i < pmc->num_ports; i++) {\n\t\tfwnode = device_get_next_child_node(pmc->dev, fwnode);\n\t\tif (!fwnode)\n\t\t\tbreak;\n\n\t\tret = pmc_usb_register_port(pmc, i, fwnode);\n\t\tif (ret) {\n\t\t\tfwnode_handle_put(fwnode);\n\t\t\tgoto err_remove_ports;\n\t\t}\n\n\t\tpmc_mux_port_debugfs_init(&pmc->port[i]);\n\t}\n\n\tplatform_set_drvdata(pdev, pmc);\n\n\treturn 0;\n\nerr_remove_ports:\n\tfor (i = 0; i < pmc->num_ports; i++) {\n\t\ttypec_switch_unregister(pmc->port[i].typec_sw);\n\t\ttypec_mux_unregister(pmc->port[i].typec_mux);\n\t\tusb_role_switch_unregister(pmc->port[i].usb_sw);\n\t}\n\n\tacpi_dev_put(pmc->iom_adev);\n\n\tdebugfs_remove(pmc->dentry);\n\n\treturn ret;\n}\n\nstatic void pmc_usb_remove(struct platform_device *pdev)\n{\n\tstruct pmc_usb *pmc = platform_get_drvdata(pdev);\n\tint i;\n\n\tfor (i = 0; i < pmc->num_ports; i++) {\n\t\ttypec_switch_unregister(pmc->port[i].typec_sw);\n\t\ttypec_mux_unregister(pmc->port[i].typec_mux);\n\t\tusb_role_switch_unregister(pmc->port[i].usb_sw);\n\t}\n\n\tacpi_dev_put(pmc->iom_adev);\n\n\tdebugfs_remove(pmc->dentry);\n}\n\nstatic const struct acpi_device_id pmc_usb_acpi_ids[] = {\n\t{ \"INTC105C\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, pmc_usb_acpi_ids);\n\nstatic struct platform_driver pmc_usb_driver = {\n\t.driver = {\n\t\t.name = \"intel_pmc_usb\",\n\t\t.acpi_match_table = ACPI_PTR(pmc_usb_acpi_ids),\n\t},\n\t.probe = pmc_usb_probe,\n\t.remove_new = pmc_usb_remove,\n};\n\nstatic int __init pmc_usb_init(void)\n{\n\tpmc_mux_debugfs_root = debugfs_create_dir(\"intel_pmc_mux\", usb_debug_root);\n\n\treturn platform_driver_register(&pmc_usb_driver);\n}\nmodule_init(pmc_usb_init);\n\nstatic void __exit pmc_usb_exit(void)\n{\n\tplatform_driver_unregister(&pmc_usb_driver);\n\tdebugfs_remove(pmc_mux_debugfs_root);\n}\nmodule_exit(pmc_usb_exit);\n\nMODULE_AUTHOR(\"Heikki Krogerus <heikki.krogerus@linux.intel.com>\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"Intel PMC USB mux control\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}