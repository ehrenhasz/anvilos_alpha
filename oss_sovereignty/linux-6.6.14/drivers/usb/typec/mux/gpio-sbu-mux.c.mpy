{
  "module_name": "gpio-sbu-mux.c",
  "hash_id": "b1229b29e7f292de76da769f1fe0fb73517ca282ec517410bab3efbbe6548527",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/mux/gpio-sbu-mux.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n\nstruct gpio_sbu_mux {\n\tstruct gpio_desc *enable_gpio;\n\tstruct gpio_desc *select_gpio;\n\n\tstruct typec_switch_dev *sw;\n\tstruct typec_mux_dev *mux;\n\n\tstruct mutex lock;  \n\tbool enabled;\n\tbool swapped;\n};\n\nstatic int gpio_sbu_switch_set(struct typec_switch_dev *sw,\n\t\t\t       enum typec_orientation orientation)\n{\n\tstruct gpio_sbu_mux *sbu_mux = typec_switch_get_drvdata(sw);\n\tbool enabled;\n\tbool swapped;\n\n\tmutex_lock(&sbu_mux->lock);\n\n\tenabled = sbu_mux->enabled;\n\tswapped = sbu_mux->swapped;\n\n\tswitch (orientation) {\n\tcase TYPEC_ORIENTATION_NONE:\n\t\tenabled = false;\n\t\tbreak;\n\tcase TYPEC_ORIENTATION_NORMAL:\n\t\tswapped = false;\n\t\tbreak;\n\tcase TYPEC_ORIENTATION_REVERSE:\n\t\tswapped = true;\n\t\tbreak;\n\t}\n\n\tif (enabled != sbu_mux->enabled)\n\t\tgpiod_set_value(sbu_mux->enable_gpio, enabled);\n\n\tif (swapped != sbu_mux->swapped)\n\t\tgpiod_set_value(sbu_mux->select_gpio, swapped);\n\n\tsbu_mux->enabled = enabled;\n\tsbu_mux->swapped = swapped;\n\n\tmutex_unlock(&sbu_mux->lock);\n\n\treturn 0;\n}\n\nstatic int gpio_sbu_mux_set(struct typec_mux_dev *mux,\n\t\t\t    struct typec_mux_state *state)\n{\n\tstruct gpio_sbu_mux *sbu_mux = typec_mux_get_drvdata(mux);\n\n\tmutex_lock(&sbu_mux->lock);\n\n\tswitch (state->mode) {\n\tcase TYPEC_STATE_SAFE:\n\tcase TYPEC_STATE_USB:\n\t\tsbu_mux->enabled = false;\n\t\tbreak;\n\tcase TYPEC_DP_STATE_C:\n\tcase TYPEC_DP_STATE_D:\n\tcase TYPEC_DP_STATE_E:\n\t\tsbu_mux->enabled = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tgpiod_set_value(sbu_mux->enable_gpio, sbu_mux->enabled);\n\n\tmutex_unlock(&sbu_mux->lock);\n\n\treturn 0;\n}\n\nstatic int gpio_sbu_mux_probe(struct platform_device *pdev)\n{\n\tstruct typec_switch_desc sw_desc = { };\n\tstruct typec_mux_desc mux_desc = { };\n\tstruct device *dev = &pdev->dev;\n\tstruct gpio_sbu_mux *sbu_mux;\n\n\tsbu_mux = devm_kzalloc(dev, sizeof(*sbu_mux), GFP_KERNEL);\n\tif (!sbu_mux)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&sbu_mux->lock);\n\n\tsbu_mux->enable_gpio = devm_gpiod_get(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(sbu_mux->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(sbu_mux->enable_gpio),\n\t\t\t\t     \"unable to acquire enable gpio\\n\");\n\n\tsbu_mux->select_gpio = devm_gpiod_get(dev, \"select\", GPIOD_OUT_LOW);\n\tif (IS_ERR(sbu_mux->select_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(sbu_mux->select_gpio),\n\t\t\t\t     \"unable to acquire select gpio\\n\");\n\n\tsw_desc.drvdata = sbu_mux;\n\tsw_desc.fwnode = dev_fwnode(dev);\n\tsw_desc.set = gpio_sbu_switch_set;\n\n\tsbu_mux->sw = typec_switch_register(dev, &sw_desc);\n\tif (IS_ERR(sbu_mux->sw))\n\t\treturn dev_err_probe(dev, PTR_ERR(sbu_mux->sw),\n\t\t\t\t     \"failed to register typec switch\\n\");\n\n\tmux_desc.drvdata = sbu_mux;\n\tmux_desc.fwnode = dev_fwnode(dev);\n\tmux_desc.set = gpio_sbu_mux_set;\n\n\tsbu_mux->mux = typec_mux_register(dev, &mux_desc);\n\tif (IS_ERR(sbu_mux->mux)) {\n\t\ttypec_switch_unregister(sbu_mux->sw);\n\t\treturn dev_err_probe(dev, PTR_ERR(sbu_mux->mux),\n\t\t\t\t     \"failed to register typec mux\\n\");\n\t}\n\n\tplatform_set_drvdata(pdev, sbu_mux);\n\n\treturn 0;\n}\n\nstatic void gpio_sbu_mux_remove(struct platform_device *pdev)\n{\n\tstruct gpio_sbu_mux *sbu_mux = platform_get_drvdata(pdev);\n\n\tgpiod_set_value(sbu_mux->enable_gpio, 0);\n\n\ttypec_mux_unregister(sbu_mux->mux);\n\ttypec_switch_unregister(sbu_mux->sw);\n}\n\nstatic const struct of_device_id gpio_sbu_mux_match[] = {\n\t{ .compatible = \"gpio-sbu-mux\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, gpio_sbu_mux_match);\n\nstatic struct platform_driver gpio_sbu_mux_driver = {\n\t.probe = gpio_sbu_mux_probe,\n\t.remove_new = gpio_sbu_mux_remove,\n\t.driver = {\n\t\t.name = \"gpio_sbu_mux\",\n\t\t.of_match_table = gpio_sbu_mux_match,\n\t},\n};\nmodule_platform_driver(gpio_sbu_mux_driver);\n\nMODULE_DESCRIPTION(\"GPIO based SBU mux driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}