{
  "module_name": "nb7vpq904m.c",
  "hash_id": "49c42c4d9e4ac87ba617c0b6d3fb8a4d3024643d60e20bafaa221b033be0d691",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/mux/nb7vpq904m.c",
  "human_readable_source": "\n \n#include <linux/i2c.h>\n#include <linux/mutex.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/regmap.h>\n#include <linux/bitfield.h>\n#include <linux/of_graph.h>\n#include <drm/drm_bridge.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/usb/typec_retimer.h>\n#include <linux/gpio/consumer.h>\n#include <linux/regulator/consumer.h>\n\n#define NB7_CHNA\t\t0\n#define NB7_CHNB\t\t1\n#define NB7_CHNC\t\t2\n#define NB7_CHND\t\t3\n#define NB7_IS_CHAN_AD(channel) (channel == NB7_CHNA || channel == NB7_CHND)\n\n#define GEN_DEV_SET_REG\t\t\t0x00\n\n#define GEN_DEV_SET_CHIP_EN\t\tBIT(0)\n#define GEN_DEV_SET_CHNA_EN\t\tBIT(4)\n#define GEN_DEV_SET_CHNB_EN\t\tBIT(5)\n#define GEN_DEV_SET_CHNC_EN\t\tBIT(6)\n#define GEN_DEV_SET_CHND_EN\t\tBIT(7)\n\n#define GEN_DEV_SET_OP_MODE_MASK\tGENMASK(3, 1)\n\n#define GEN_DEV_SET_OP_MODE_DP_CC2\t0\n#define GEN_DEV_SET_OP_MODE_DP_CC1\t1\n#define GEN_DEV_SET_OP_MODE_DP_4LANE\t2\n#define GEN_DEV_SET_OP_MODE_USB\t\t5\n\n#define EQ_SETTING_REG_BASE\t\t0x01\n#define EQ_SETTING_REG(n)\t\t(EQ_SETTING_REG_BASE + (n) * 2)\n#define EQ_SETTING_MASK\t\t\tGENMASK(3, 1)\n\n#define OUTPUT_COMPRESSION_AND_POL_REG_BASE\t0x02\n#define OUTPUT_COMPRESSION_AND_POL_REG(n)\t(OUTPUT_COMPRESSION_AND_POL_REG_BASE + (n) * 2)\n#define OUTPUT_COMPRESSION_MASK\t\tGENMASK(2, 1)\n\n#define FLAT_GAIN_REG_BASE\t\t0x18\n#define FLAT_GAIN_REG(n)\t\t(FLAT_GAIN_REG_BASE + (n) * 2)\n#define FLAT_GAIN_MASK\t\t\tGENMASK(1, 0)\n\n#define LOSS_MATCH_REG_BASE\t\t0x19\n#define LOSS_MATCH_REG(n)\t\t(LOSS_MATCH_REG_BASE + (n) * 2)\n#define LOSS_MATCH_MASK\t\t\tGENMASK(1, 0)\n\n#define AUX_CC_REG\t\t\t0x09\n\n#define CHIP_VERSION_REG\t\t0x17\n\nstruct nb7vpq904m {\n\tstruct i2c_client *client;\n\tstruct gpio_desc *enable_gpio;\n\tstruct regulator *vcc_supply;\n\tstruct regmap *regmap;\n\tstruct typec_switch_dev *sw;\n\tstruct typec_retimer *retimer;\n\n\tbool swap_data_lanes;\n\tstruct typec_switch *typec_switch;\n\n\tstruct drm_bridge bridge;\n\n\tstruct mutex lock;  \n\n\tenum typec_orientation orientation;\n\tunsigned long mode;\n\tunsigned int svid;\n};\n\nstatic void nb7vpq904m_set_channel(struct nb7vpq904m *nb7, unsigned int channel, bool dp)\n{\n\tu8 eq, out_comp, flat_gain, loss_match;\n\n\tif (dp) {\n\t\teq = NB7_IS_CHAN_AD(channel) ? 0x6 : 0x4;\n\t\tout_comp = 0x3;\n\t\tflat_gain = NB7_IS_CHAN_AD(channel) ? 0x2 : 0x1;\n\t\tloss_match = 0x3;\n\t} else {\n\t\teq = 0x4;\n\t\tout_comp = 0x3;\n\t\tflat_gain = NB7_IS_CHAN_AD(channel) ? 0x3 : 0x1;\n\t\tloss_match = NB7_IS_CHAN_AD(channel) ? 0x1 : 0x3;\n\t}\n\n\tregmap_update_bits(nb7->regmap, EQ_SETTING_REG(channel),\n\t\t\t   EQ_SETTING_MASK, FIELD_PREP(EQ_SETTING_MASK, eq));\n\tregmap_update_bits(nb7->regmap, OUTPUT_COMPRESSION_AND_POL_REG(channel),\n\t\t\t   OUTPUT_COMPRESSION_MASK, FIELD_PREP(OUTPUT_COMPRESSION_MASK, out_comp));\n\tregmap_update_bits(nb7->regmap, FLAT_GAIN_REG(channel),\n\t\t\t   FLAT_GAIN_MASK, FIELD_PREP(FLAT_GAIN_MASK, flat_gain));\n\tregmap_update_bits(nb7->regmap, LOSS_MATCH_REG(channel),\n\t\t\t   LOSS_MATCH_MASK, FIELD_PREP(LOSS_MATCH_MASK, loss_match));\n}\n\nstatic int nb7vpq904m_set(struct nb7vpq904m *nb7)\n{\n\tbool reverse = (nb7->orientation == TYPEC_ORIENTATION_REVERSE);\n\n\tswitch (nb7->mode) {\n\tcase TYPEC_STATE_SAFE:\n\t\tregmap_write(nb7->regmap, GEN_DEV_SET_REG,\n\t\t\t     GEN_DEV_SET_CHIP_EN |\n\t\t\t     GEN_DEV_SET_CHNA_EN |\n\t\t\t     GEN_DEV_SET_CHNB_EN |\n\t\t\t     GEN_DEV_SET_CHNC_EN |\n\t\t\t     GEN_DEV_SET_CHND_EN |\n\t\t\t     FIELD_PREP(GEN_DEV_SET_OP_MODE_MASK,\n\t\t\t\t\tGEN_DEV_SET_OP_MODE_USB));\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNA, false);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNB, false);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNC, false);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHND, false);\n\t\tregmap_write(nb7->regmap, AUX_CC_REG, 0x2);\n\n\t\treturn 0;\n\n\tcase TYPEC_STATE_USB:\n\t\t \n\t\tif (reverse ^ nb7->swap_data_lanes) {\n\t\t\tregmap_write(nb7->regmap, GEN_DEV_SET_REG,\n\t\t\t\t     GEN_DEV_SET_CHIP_EN |\n\t\t\t\t     GEN_DEV_SET_CHNA_EN |\n\t\t\t\t     GEN_DEV_SET_CHNB_EN |\n\t\t\t\t     FIELD_PREP(GEN_DEV_SET_OP_MODE_MASK,\n\t\t\t\t\t\tGEN_DEV_SET_OP_MODE_USB));\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNA, false);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNB, false);\n\t\t} else {\n\t\t\tregmap_write(nb7->regmap, GEN_DEV_SET_REG,\n\t\t\t\t     GEN_DEV_SET_CHIP_EN |\n\t\t\t\t     GEN_DEV_SET_CHNC_EN |\n\t\t\t\t     GEN_DEV_SET_CHND_EN |\n\t\t\t\t     FIELD_PREP(GEN_DEV_SET_OP_MODE_MASK,\n\t\t\t\t\t\tGEN_DEV_SET_OP_MODE_USB));\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNC, false);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHND, false);\n\t\t}\n\t\tregmap_write(nb7->regmap, AUX_CC_REG, 0x2);\n\n\t\treturn 0;\n\n\tdefault:\n\t\tif (nb7->svid != USB_TYPEC_DP_SID)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\t}\n\n\t \n\n\tregmap_write(nb7->regmap, AUX_CC_REG, reverse ? 0x1 : 0x0);\n\n\tswitch (nb7->mode) {\n\tcase TYPEC_DP_STATE_C:\n\tcase TYPEC_DP_STATE_E:\n\t\t \n\t\tregmap_write(nb7->regmap, GEN_DEV_SET_REG,\n\t\t\t     GEN_DEV_SET_CHIP_EN |\n\t\t\t     GEN_DEV_SET_CHNA_EN |\n\t\t\t     GEN_DEV_SET_CHNB_EN |\n\t\t\t     GEN_DEV_SET_CHNC_EN |\n\t\t\t     GEN_DEV_SET_CHND_EN |\n\t\t\t     FIELD_PREP(GEN_DEV_SET_OP_MODE_MASK,\n\t\t\t\t\tGEN_DEV_SET_OP_MODE_DP_4LANE));\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNA, true);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNB, true);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHNC, true);\n\t\tnb7vpq904m_set_channel(nb7, NB7_CHND, true);\n\t\tbreak;\n\n\tcase TYPEC_DP_STATE_D:\n\tcase TYPEC_DP_STATE_F:\n\t\tregmap_write(nb7->regmap, GEN_DEV_SET_REG,\n\t\t\t     GEN_DEV_SET_CHIP_EN |\n\t\t\t     GEN_DEV_SET_CHNA_EN |\n\t\t\t     GEN_DEV_SET_CHNB_EN |\n\t\t\t     GEN_DEV_SET_CHNC_EN |\n\t\t\t     GEN_DEV_SET_CHND_EN |\n\t\t\t     FIELD_PREP(GEN_DEV_SET_OP_MODE_MASK,\n\t\t\t\t\treverse ^ nb7->swap_data_lanes ?\n\t\t\t\t\t\tGEN_DEV_SET_OP_MODE_DP_CC2\n\t\t\t\t\t\t: GEN_DEV_SET_OP_MODE_DP_CC1));\n\n\t\t \n\t\tif (nb7->swap_data_lanes) {\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNA, !reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNB, !reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNC, reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHND, reverse);\n\t\t} else {\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNA, reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNB, reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHNC, !reverse);\n\t\t\tnb7vpq904m_set_channel(nb7, NB7_CHND, !reverse);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nstatic int nb7vpq904m_sw_set(struct typec_switch_dev *sw, enum typec_orientation orientation)\n{\n\tstruct nb7vpq904m *nb7 = typec_switch_get_drvdata(sw);\n\tint ret;\n\n\tret = typec_switch_set(nb7->typec_switch, orientation);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&nb7->lock);\n\n\tif (nb7->orientation != orientation) {\n\t\tnb7->orientation = orientation;\n\n\t\tret = nb7vpq904m_set(nb7);\n\t}\n\n\tmutex_unlock(&nb7->lock);\n\n\treturn ret;\n}\n\nstatic int nb7vpq904m_retimer_set(struct typec_retimer *retimer, struct typec_retimer_state *state)\n{\n\tstruct nb7vpq904m *nb7 = typec_retimer_get_drvdata(retimer);\n\tint ret = 0;\n\n\tmutex_lock(&nb7->lock);\n\n\tif (nb7->mode != state->mode) {\n\t\tnb7->mode = state->mode;\n\n\t\tif (state->alt)\n\t\t\tnb7->svid = state->alt->svid;\n\t\telse\n\t\t\tnb7->svid = 0; \n\n\t\tret = nb7vpq904m_set(nb7);\n\t}\n\n\tmutex_unlock(&nb7->lock);\n\n\treturn ret;\n}\n\n#if IS_ENABLED(CONFIG_OF) && IS_ENABLED(CONFIG_DRM_PANEL_BRIDGE)\nstatic int nb7vpq904m_bridge_attach(struct drm_bridge *bridge,\n\t\t\t\t    enum drm_bridge_attach_flags flags)\n{\n\tstruct nb7vpq904m *nb7 = container_of(bridge, struct nb7vpq904m, bridge);\n\tstruct drm_bridge *next_bridge;\n\n\tif (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR))\n\t\treturn -EINVAL;\n\n\tnext_bridge = devm_drm_of_get_bridge(&nb7->client->dev, nb7->client->dev.of_node, 0, 0);\n\tif (IS_ERR(next_bridge)) {\n\t\tdev_err(&nb7->client->dev, \"failed to acquire drm_bridge: %pe\\n\", next_bridge);\n\t\treturn PTR_ERR(next_bridge);\n\t}\n\n\treturn drm_bridge_attach(bridge->encoder, next_bridge, bridge,\n\t\t\t\t DRM_BRIDGE_ATTACH_NO_CONNECTOR);\n}\n\nstatic const struct drm_bridge_funcs nb7vpq904m_bridge_funcs = {\n\t.attach\t= nb7vpq904m_bridge_attach,\n};\n\nstatic int nb7vpq904m_register_bridge(struct nb7vpq904m *nb7)\n{\n\tnb7->bridge.funcs = &nb7vpq904m_bridge_funcs;\n\tnb7->bridge.of_node = nb7->client->dev.of_node;\n\n\treturn devm_drm_bridge_add(&nb7->client->dev, &nb7->bridge);\n}\n#else\nstatic int nb7vpq904m_register_bridge(struct nb7vpq904m *nb7)\n{\n\treturn 0;\n}\n#endif\n\nstatic const struct regmap_config nb7_regmap = {\n\t.max_register = 0x1f,\n\t.reg_bits = 8,\n\t.val_bits = 8,\n};\n\nenum {\n\tNORMAL_LANE_MAPPING,\n\tINVERT_LANE_MAPPING,\n};\n\n#define DATA_LANES_COUNT\t4\n\nstatic const int supported_data_lane_mapping[][DATA_LANES_COUNT] = {\n\t[NORMAL_LANE_MAPPING] = { 0, 1, 2, 3 },\n\t[INVERT_LANE_MAPPING] = { 3, 2, 1, 0 },\n};\n\nstatic int nb7vpq904m_parse_data_lanes_mapping(struct nb7vpq904m *nb7)\n{\n\tstruct device_node *ep;\n\tu32 data_lanes[4];\n\tint ret, i, j;\n\n\tep = of_graph_get_endpoint_by_regs(nb7->client->dev.of_node, 1, 0);\n\n\tif (ep) {\n\t\tret = of_property_count_u32_elems(ep, \"data-lanes\");\n\t\tif (ret == -EINVAL)\n\t\t\t \n\t\t\tgoto out_done;\n\t\tif (ret < 0)\n\t\t\tgoto out_error;\n\n\t\tif (ret != DATA_LANES_COUNT) {\n\t\t\tdev_err(&nb7->client->dev, \"expected 4 data lanes\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tret = of_property_read_u32_array(ep, \"data-lanes\", data_lanes, DATA_LANES_COUNT);\n\t\tif (ret)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(supported_data_lane_mapping); i++) {\n\t\t\tfor (j = 0; j < DATA_LANES_COUNT; j++) {\n\t\t\t\tif (data_lanes[j] != supported_data_lane_mapping[i][j])\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (j == DATA_LANES_COUNT)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (i) {\n\t\tcase NORMAL_LANE_MAPPING:\n\t\t\tbreak;\n\t\tcase INVERT_LANE_MAPPING:\n\t\t\tnb7->swap_data_lanes = true;\n\t\t\tdev_info(&nb7->client->dev, \"using inverted data lanes mapping\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&nb7->client->dev, \"invalid data lanes mapping\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto out_error;\n\t\t}\n\t}\n\nout_done:\n\tret = 0;\n\nout_error:\n\tof_node_put(ep);\n\n\treturn ret;\n}\n\nstatic int nb7vpq904m_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct typec_switch_desc sw_desc = { };\n\tstruct typec_retimer_desc retimer_desc = { };\n\tstruct nb7vpq904m *nb7;\n\tint ret;\n\n\tnb7 = devm_kzalloc(dev, sizeof(*nb7), GFP_KERNEL);\n\tif (!nb7)\n\t\treturn -ENOMEM;\n\n\tnb7->client = client;\n\n\tnb7->regmap = devm_regmap_init_i2c(client, &nb7_regmap);\n\tif (IS_ERR(nb7->regmap)) {\n\t\tdev_err(&client->dev, \"Failed to allocate register map\\n\");\n\t\treturn PTR_ERR(nb7->regmap);\n\t}\n\n\tnb7->mode = TYPEC_STATE_SAFE;\n\tnb7->orientation = TYPEC_ORIENTATION_NONE;\n\n\tmutex_init(&nb7->lock);\n\n\tnb7->enable_gpio = devm_gpiod_get_optional(dev, \"enable\", GPIOD_OUT_LOW);\n\tif (IS_ERR(nb7->enable_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(nb7->enable_gpio),\n\t\t\t\t     \"unable to acquire enable gpio\\n\");\n\n\tnb7->vcc_supply = devm_regulator_get_optional(dev, \"vcc\");\n\tif (IS_ERR(nb7->vcc_supply))\n\t\treturn PTR_ERR(nb7->vcc_supply);\n\n\tnb7->typec_switch = fwnode_typec_switch_get(dev->fwnode);\n\tif (IS_ERR(nb7->typec_switch))\n\t\treturn dev_err_probe(dev, PTR_ERR(nb7->typec_switch),\n\t\t\t\t     \"failed to acquire orientation-switch\\n\");\n\n\tret = nb7vpq904m_parse_data_lanes_mapping(nb7);\n\tif (ret)\n\t\treturn ret;\n\n\tret = regulator_enable(nb7->vcc_supply);\n\tif (ret)\n\t\tdev_warn(dev, \"Failed to enable vcc: %d\\n\", ret);\n\n\tgpiod_set_value(nb7->enable_gpio, 1);\n\n\tret = nb7vpq904m_register_bridge(nb7);\n\tif (ret)\n\t\tgoto err_disable_gpio;\n\n\tsw_desc.drvdata = nb7;\n\tsw_desc.fwnode = dev->fwnode;\n\tsw_desc.set = nb7vpq904m_sw_set;\n\n\tnb7->sw = typec_switch_register(dev, &sw_desc);\n\tif (IS_ERR(nb7->sw)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(nb7->sw),\n\t\t\t\t    \"Error registering typec switch\\n\");\n\t\tgoto err_disable_gpio;\n\t}\n\n\tretimer_desc.drvdata = nb7;\n\tretimer_desc.fwnode = dev->fwnode;\n\tretimer_desc.set = nb7vpq904m_retimer_set;\n\n\tnb7->retimer = typec_retimer_register(dev, &retimer_desc);\n\tif (IS_ERR(nb7->retimer)) {\n\t\tret = dev_err_probe(dev, PTR_ERR(nb7->retimer),\n\t\t\t\t    \"Error registering typec retimer\\n\");\n\t\tgoto err_switch_unregister;\n\t}\n\n\treturn 0;\n\nerr_switch_unregister:\n\ttypec_switch_unregister(nb7->sw);\n\nerr_disable_gpio:\n\tgpiod_set_value(nb7->enable_gpio, 0);\n\tregulator_disable(nb7->vcc_supply);\n\n\treturn ret;\n}\n\nstatic void nb7vpq904m_remove(struct i2c_client *client)\n{\n\tstruct nb7vpq904m *nb7 = i2c_get_clientdata(client);\n\n\ttypec_retimer_unregister(nb7->retimer);\n\ttypec_switch_unregister(nb7->sw);\n\n\tgpiod_set_value(nb7->enable_gpio, 0);\n\n\tregulator_disable(nb7->vcc_supply);\n}\n\nstatic const struct i2c_device_id nb7vpq904m_table[] = {\n\t{ \"nb7vpq904m\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, nb7vpq904m_table);\n\nstatic const struct of_device_id nb7vpq904m_of_table[] = {\n\t{ .compatible = \"onnn,nb7vpq904m\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, nb7vpq904m_of_table);\n\nstatic struct i2c_driver nb7vpq904m_driver = {\n\t.driver = {\n\t\t.name = \"nb7vpq904m\",\n\t\t.of_match_table = nb7vpq904m_of_table,\n\t},\n\t.probe\t\t= nb7vpq904m_probe,\n\t.remove\t\t= nb7vpq904m_remove,\n\t.id_table\t= nb7vpq904m_table,\n};\n\nmodule_i2c_driver(nb7vpq904m_driver);\n\nMODULE_AUTHOR(\"Dmitry Baryshkov <dmitry.baryshkov@linaro.org>\");\nMODULE_DESCRIPTION(\"OnSemi NB7VPQ904M Type-C driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}