{
  "module_name": "fsa4480.c",
  "hash_id": "d78fd1a888c407c1c546d5826ae4586fc795187f86f6c815a9da6896f408f100",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/mux/fsa4480.c",
  "human_readable_source": "\n \n\n#include <linux/bits.h>\n#include <linux/i2c.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/regmap.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n\n#define FSA4480_SWITCH_ENABLE\t0x04\n#define FSA4480_SWITCH_SELECT\t0x05\n#define FSA4480_SWITCH_STATUS1\t0x07\n#define FSA4480_SLOW_L\t\t0x08\n#define FSA4480_SLOW_R\t\t0x09\n#define FSA4480_SLOW_MIC\t0x0a\n#define FSA4480_SLOW_SENSE\t0x0b\n#define FSA4480_SLOW_GND\t0x0c\n#define FSA4480_DELAY_L_R\t0x0d\n#define FSA4480_DELAY_L_MIC\t0x0e\n#define FSA4480_DELAY_L_SENSE\t0x0f\n#define FSA4480_DELAY_L_AGND\t0x10\n#define FSA4480_FUNCTION_ENABLE\t0x12\n#define FSA4480_RESET\t\t0x1e\n#define FSA4480_MAX_REGISTER\t0x1f\n\n#define FSA4480_ENABLE_DEVICE\tBIT(7)\n#define FSA4480_ENABLE_SBU\tGENMASK(6, 5)\n#define FSA4480_ENABLE_USB\tGENMASK(4, 3)\n#define FSA4480_ENABLE_SENSE\tBIT(2)\n#define FSA4480_ENABLE_MIC\tBIT(1)\n#define FSA4480_ENABLE_AGND\tBIT(0)\n\n#define FSA4480_SEL_SBU_REVERSE\tGENMASK(6, 5)\n#define FSA4480_SEL_USB\t\tGENMASK(4, 3)\n#define FSA4480_SEL_SENSE\tBIT(2)\n#define FSA4480_SEL_MIC\t\tBIT(1)\n#define FSA4480_SEL_AGND\tBIT(0)\n\n#define FSA4480_ENABLE_AUTO_JACK_DETECT\tBIT(0)\n\nstruct fsa4480 {\n\tstruct i2c_client *client;\n\n\t \n\tstruct mutex lock;\n\n\tstruct typec_switch_dev *sw;\n\tstruct typec_mux_dev *mux;\n\n\tstruct regmap *regmap;\n\n\tenum typec_orientation orientation;\n\tunsigned long mode;\n\tunsigned int svid;\n\n\tu8 cur_enable;\n};\n\nstatic const struct regmap_config fsa4480_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\t.max_register = FSA4480_MAX_REGISTER,\n\t \n\t.disable_locking = true,\n};\n\nstatic int fsa4480_set(struct fsa4480 *fsa)\n{\n\tbool reverse = (fsa->orientation == TYPEC_ORIENTATION_REVERSE);\n\tu8 enable = FSA4480_ENABLE_DEVICE;\n\tu8 sel = 0;\n\n\t \n\tif (fsa->mode < TYPEC_STATE_MODAL ||\n\t    (!fsa->svid && (fsa->mode == TYPEC_MODE_USB2 ||\n\t\t\t    fsa->mode == TYPEC_MODE_USB3))) {\n\t\tenable |= FSA4480_ENABLE_USB;\n\t\tsel = FSA4480_SEL_USB;\n\t} else if (fsa->svid) {\n\t\tswitch (fsa->mode) {\n\t\t \n\t\tcase TYPEC_DP_STATE_C:\n\t\tcase TYPEC_DP_STATE_E:\n\t\t\tenable |= FSA4480_ENABLE_SBU;\n\t\t\tif (reverse)\n\t\t\t\tsel = FSA4480_SEL_SBU_REVERSE;\n\t\t\tbreak;\n\n\t\t \n\t\tcase TYPEC_DP_STATE_D:\n\t\tcase TYPEC_DP_STATE_F:\n\t\t\tenable |= FSA4480_ENABLE_USB | FSA4480_ENABLE_SBU;\n\t\t\tsel = FSA4480_SEL_USB;\n\t\t\tif (reverse)\n\t\t\t\tsel |= FSA4480_SEL_SBU_REVERSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\treturn -EOPNOTSUPP;\n\t\t}\n\t} else if (fsa->mode == TYPEC_MODE_AUDIO) {\n\t\t \n\t\tenable |= FSA4480_ENABLE_USB | FSA4480_ENABLE_AGND;\n\t} else\n\t\treturn -EOPNOTSUPP;\n\n\tif (fsa->cur_enable & FSA4480_ENABLE_SBU) {\n\t\t \n\t\tregmap_write(fsa->regmap, FSA4480_SWITCH_ENABLE,\n\t\t\t     fsa->cur_enable & ~FSA4480_ENABLE_SBU);\n\n\t\t \n\t\tusleep_range(35, 1000);\n\t}\n\n\tregmap_write(fsa->regmap, FSA4480_SWITCH_SELECT, sel);\n\tregmap_write(fsa->regmap, FSA4480_SWITCH_ENABLE, enable);\n\n\t \n\tif (enable & FSA4480_ENABLE_AGND)\n\t\tregmap_write(fsa->regmap, FSA4480_FUNCTION_ENABLE,\n\t\t\t     FSA4480_ENABLE_AUTO_JACK_DETECT);\n\n\tif (enable & FSA4480_ENABLE_SBU) {\n\t\t \n\t\tusleep_range(15, 1000);\n\t}\n\n\tfsa->cur_enable = enable;\n\n\treturn 0;\n}\n\nstatic int fsa4480_switch_set(struct typec_switch_dev *sw,\n\t\t\t      enum typec_orientation orientation)\n{\n\tstruct fsa4480 *fsa = typec_switch_get_drvdata(sw);\n\tint ret = 0;\n\n\tmutex_lock(&fsa->lock);\n\n\tif (fsa->orientation != orientation) {\n\t\tfsa->orientation = orientation;\n\n\t\tret = fsa4480_set(fsa);\n\t}\n\n\tmutex_unlock(&fsa->lock);\n\n\treturn ret;\n}\n\nstatic int fsa4480_mux_set(struct typec_mux_dev *mux, struct typec_mux_state *state)\n{\n\tstruct fsa4480 *fsa = typec_mux_get_drvdata(mux);\n\tint ret = 0;\n\n\tmutex_lock(&fsa->lock);\n\n\tif (fsa->mode != state->mode) {\n\t\tfsa->mode = state->mode;\n\n\t\tif (state->alt)\n\t\t\tfsa->svid = state->alt->svid;\n\t\telse\n\t\t\tfsa->svid = 0; \n\n\t\tret = fsa4480_set(fsa);\n\t}\n\n\tmutex_unlock(&fsa->lock);\n\n\treturn ret;\n}\n\nstatic int fsa4480_probe(struct i2c_client *client)\n{\n\tstruct device *dev = &client->dev;\n\tstruct typec_switch_desc sw_desc = { };\n\tstruct typec_mux_desc mux_desc = { };\n\tstruct fsa4480 *fsa;\n\n\tfsa = devm_kzalloc(dev, sizeof(*fsa), GFP_KERNEL);\n\tif (!fsa)\n\t\treturn -ENOMEM;\n\n\tfsa->client = client;\n\tmutex_init(&fsa->lock);\n\n\tfsa->regmap = devm_regmap_init_i2c(client, &fsa4480_regmap_config);\n\tif (IS_ERR(fsa->regmap))\n\t\treturn dev_err_probe(dev, PTR_ERR(fsa->regmap), \"failed to initialize regmap\\n\");\n\n\t \n\tfsa->cur_enable = FSA4480_ENABLE_DEVICE | FSA4480_ENABLE_USB;\n\tfsa->mode = TYPEC_STATE_SAFE;\n\tfsa->orientation = TYPEC_ORIENTATION_NONE;\n\n\t \n\tregmap_write(fsa->regmap, FSA4480_SLOW_L, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_SLOW_R, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_SLOW_MIC, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_SLOW_SENSE, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_SLOW_GND, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_DELAY_L_R, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_DELAY_L_MIC, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_DELAY_L_SENSE, 0x00);\n\tregmap_write(fsa->regmap, FSA4480_DELAY_L_AGND, 0x09);\n\tregmap_write(fsa->regmap, FSA4480_SWITCH_SELECT, FSA4480_SEL_USB);\n\tregmap_write(fsa->regmap, FSA4480_SWITCH_ENABLE, fsa->cur_enable);\n\n\tsw_desc.drvdata = fsa;\n\tsw_desc.fwnode = dev_fwnode(dev);\n\tsw_desc.set = fsa4480_switch_set;\n\n\tfsa->sw = typec_switch_register(dev, &sw_desc);\n\tif (IS_ERR(fsa->sw))\n\t\treturn dev_err_probe(dev, PTR_ERR(fsa->sw), \"failed to register typec switch\\n\");\n\n\tmux_desc.drvdata = fsa;\n\tmux_desc.fwnode = dev_fwnode(dev);\n\tmux_desc.set = fsa4480_mux_set;\n\n\tfsa->mux = typec_mux_register(dev, &mux_desc);\n\tif (IS_ERR(fsa->mux)) {\n\t\ttypec_switch_unregister(fsa->sw);\n\t\treturn dev_err_probe(dev, PTR_ERR(fsa->mux), \"failed to register typec mux\\n\");\n\t}\n\n\ti2c_set_clientdata(client, fsa);\n\treturn 0;\n}\n\nstatic void fsa4480_remove(struct i2c_client *client)\n{\n\tstruct fsa4480 *fsa = i2c_get_clientdata(client);\n\n\ttypec_mux_unregister(fsa->mux);\n\ttypec_switch_unregister(fsa->sw);\n}\n\nstatic const struct i2c_device_id fsa4480_table[] = {\n\t{ \"fsa4480\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, fsa4480_table);\n\nstatic const struct of_device_id fsa4480_of_table[] = {\n\t{ .compatible = \"fcs,fsa4480\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, fsa4480_of_table);\n\nstatic struct i2c_driver fsa4480_driver = {\n\t.driver = {\n\t\t.name = \"fsa4480\",\n\t\t.of_match_table = fsa4480_of_table,\n\t},\n\t.probe\t\t= fsa4480_probe,\n\t.remove\t\t= fsa4480_remove,\n\t.id_table\t= fsa4480_table,\n};\nmodule_i2c_driver(fsa4480_driver);\n\nMODULE_DESCRIPTION(\"ON Semiconductor FSA4480 driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}