{
  "module_name": "anx7411.c",
  "hash_id": "25f7a94c5027fa5ad03205ab92f270277bf4b207809827dbb02a8bcbe901bab3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/typec/anx7411.c",
  "human_readable_source": "\n\n \n#include <linux/gpio/consumer.h>\n#include <linux/i2c.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of_graph.h>\n#include <linux/of_platform.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/usb/pd.h>\n#include <linux/usb/role.h>\n#include <linux/usb/tcpci.h>\n#include <linux/usb/typec.h>\n#include <linux/usb/typec_dp.h>\n#include <linux/usb/typec_mux.h>\n#include <linux/workqueue.h>\n#include <linux/power_supply.h>\n\n#define TCPC_ADDRESS1\t\t0x58\n#define TCPC_ADDRESS2\t\t0x56\n#define TCPC_ADDRESS3\t\t0x54\n#define TCPC_ADDRESS4\t\t0x52\n#define SPI_ADDRESS1\t\t0x7e\n#define SPI_ADDRESS2\t\t0x6e\n#define SPI_ADDRESS3\t\t0x64\n#define SPI_ADDRESS4\t\t0x62\n\nstruct anx7411_i2c_select {\n\tu8 tcpc_address;\n\tu8 spi_address;\n};\n\n#define VID_ANALOGIX\t\t0x1F29\n#define PID_ANALOGIX\t\t0x7411\n\n \n\n#define ANALOG_CTRL_10\t\t0xAA\n\n#define STATUS_LEN\t\t2\n#define ALERT_0\t\t\t0xCB\n#define RECEIVED_MSG\t\tBIT(7)\n#define SOFTWARE_INT\t\tBIT(6)\n#define MSG_LEN\t\t\t32\n#define HEADER_LEN\t\t2\n#define MSG_HEADER\t\t0x00\n#define MSG_TYPE\t\t0x01\n#define MSG_RAWDATA\t\t0x02\n#define MSG_LEN_MASK\t\t0x1F\n\n#define ALERT_1\t\t\t0xCC\n#define INTP_POW_ON\t\tBIT(7)\n#define INTP_POW_OFF\t\tBIT(6)\n\n#define VBUS_THRESHOLD_H\t0xDD\n#define VBUS_THRESHOLD_L\t0xDE\n\n#define FW_CTRL_0\t\t0xF0\n#define UNSTRUCT_VDM_EN\t\tBIT(0)\n#define DELAY_200MS\t\tBIT(1)\n#define VSAFE0\t\t\t0\n#define VSAFE1\t\t\tBIT(2)\n#define VSAFE2\t\t\tBIT(3)\n#define VSAFE3\t\t\t(BIT(2) | BIT(3))\n#define FRS_EN\t\t\tBIT(7)\n\n#define FW_PARAM\t\t0xF1\n#define DONGLE_IOP\t\tBIT(0)\n\n#define FW_CTRL_2\t\t0xF7\n#define SINK_CTRL_DIS_FLAG\tBIT(5)\n\n \n#define OCM_CTRL_0\t\t0x6E\n#define OCM_RESET\t\tBIT(6)\n\n#define MAX_VOLTAGE\t\t0xAC\n#define MAX_POWER\t\t0xAD\n#define MIN_POWER\t\t0xAE\n\n#define REQUEST_VOLTAGE\t\t0xAF\n#define VOLTAGE_UNIT\t\t100  \n\n#define REQUEST_CURRENT\t\t0xB1\n#define CURRENT_UNIT\t\t50  \n\n#define CMD_SEND_BUF\t\t0xC0\n#define CMD_RECV_BUF\t\t0xE0\n\n#define REQ_VOL_20V_IN_100MV\t0xC8\n#define REQ_CUR_2_25A_IN_50MA\t0x2D\n#define REQ_CUR_3_25A_IN_50MA\t0x41\n\n#define DEF_5V\t\t\t5000\n#define DEF_1_5A\t\t1500\n\n#define LOBYTE(w)\t\t((u8)((w) & 0xFF))\n#define HIBYTE(w)\t\t((u8)(((u16)(w) >> 8) & 0xFF))\n\nenum anx7411_typec_message_type {\n\tTYPE_SRC_CAP = 0x00,\n\tTYPE_SNK_CAP = 0x01,\n\tTYPE_SNK_IDENTITY = 0x02,\n\tTYPE_SVID = 0x03,\n\tTYPE_SET_SNK_DP_CAP = 0x08,\n\tTYPE_PSWAP_REQ = 0x10,\n\tTYPE_DSWAP_REQ = 0x11,\n\tTYPE_VDM = 0x14,\n\tTYPE_OBJ_REQ = 0x16,\n\tTYPE_DP_ALT_ENTER = 0x19,\n\tTYPE_DP_DISCOVER_MODES_INFO = 0x27,\n\tTYPE_GET_DP_CONFIG = 0x29,\n\tTYPE_DP_CONFIGURE = 0x2A,\n\tTYPE_GET_DP_DISCOVER_MODES_INFO = 0x2E,\n\tTYPE_GET_DP_ALT_ENTER = 0x2F,\n};\n\n#define FW_CTRL_1\t\t0xB2\n#define AUTO_PD_EN\t\tBIT(1)\n#define TRYSRC_EN\t\tBIT(2)\n#define TRYSNK_EN\t\tBIT(3)\n#define FORCE_SEND_RDO\t\tBIT(6)\n\n#define FW_VER\t\t\t0xB4\n#define FW_SUBVER\t\t0xB5\n\n#define INT_MASK\t\t0xB6\n#define INT_STS\t\t\t0xB7\n#define OCM_BOOT_UP\t\tBIT(0)\n#define OC_OV_EVENT\t\tBIT(1)\n#define VCONN_CHANGE\t\tBIT(2)\n#define VBUS_CHANGE\t\tBIT(3)\n#define CC_STATUS_CHANGE\tBIT(4)\n#define DATA_ROLE_CHANGE\tBIT(5)\n#define PR_CONSUMER_GOT_POWER\tBIT(6)\n#define HPD_STATUS_CHANGE\tBIT(7)\n\n#define SYSTEM_STSTUS\t\t0xB8\n \n#define SINK_STATUS\t\tBIT(1)\n \n#define VCONN_STATUS\t\tBIT(2)\n \n#define VBUS_STATUS\t\tBIT(3)\n \n#define DATA_ROLE\t\tBIT(5)\n \n#define SUPPORT_UNCHUNKING\tBIT(6)\n \n#define HPD_STATUS\t\tBIT(7)\n\n#define DATA_DFP\t\t1\n#define DATA_UFP\t\t2\n#define POWER_SOURCE\t\t1\n#define POWER_SINK\t\t2\n\n#define CC_STATUS\t\t0xB9\n#define CC1_RD\t\t\tBIT(0)\n#define CC2_RD\t\t\tBIT(4)\n#define CC1_RA\t\t\tBIT(1)\n#define CC2_RA\t\t\tBIT(5)\n#define CC1_RD\t\t\tBIT(0)\n#define CC1_RP(cc)\t\t(((cc) >> 2) & 0x03)\n#define CC2_RP(cc)\t\t(((cc) >> 6) & 0x03)\n\n#define PD_REV_INIT\t\t0xBA\n\n#define PD_EXT_MSG_CTRL\t\t0xBB\n#define SRC_CAP_EXT_REPLY\tBIT(0)\n#define MANUFACTURER_INFO_REPLY\tBIT(1)\n#define BATTERY_STS_REPLY\tBIT(2)\n#define BATTERY_CAP_REPLY\tBIT(3)\n#define ALERT_REPLY\t\tBIT(4)\n#define STATUS_REPLY\t\tBIT(5)\n#define PPS_STATUS_REPLY\tBIT(6)\n#define SNK_CAP_EXT_REPLY\tBIT(7)\n\n#define NO_CONNECT\t\t0x00\n#define USB3_1_CONNECTED\t0x01\n#define DP_ALT_4LANES\t\t0x02\n#define USB3_1_DP_2LANES\t0x03\n#define CC1_CONNECTED\t\t0x01\n#define CC2_CONNECTED\t\t0x02\n#define SELECT_PIN_ASSIGMENT_C\t0x04\n#define SELECT_PIN_ASSIGMENT_D\t0x08\n#define SELECT_PIN_ASSIGMENT_E\t0x10\n#define SELECT_PIN_ASSIGMENT_U\t0x00\n#define REDRIVER_ADDRESS\t0x20\n#define REDRIVER_OFFSET\t\t0x00\n\n#define DP_SVID\t\t\t0xFF01\n#define VDM_ACK\t\t\t0x40\n#define VDM_CMD_RES\t\t0x00\n#define VDM_CMD_DIS_ID\t\t0x01\n#define VDM_CMD_DIS_SVID\t0x02\n#define VDM_CMD_DIS_MOD\t\t0x03\n#define VDM_CMD_ENTER_MODE\t0x04\n#define VDM_CMD_EXIT_MODE\t0x05\n#define VDM_CMD_ATTENTION\t0x06\n#define VDM_CMD_GET_STS\t\t0x10\n#define VDM_CMD_AND_ACK_MASK\t0x5F\n\n#define MAX_ALTMODE\t\t2\n\n#define HAS_SOURCE_CAP\t\tBIT(0)\n#define HAS_SINK_CAP\t\tBIT(1)\n#define HAS_SINK_WATT\t\tBIT(2)\n\nenum anx7411_psy_state {\n\t \n\tANX7411_PSY_OFFLINE = 0,\n\tANX7411_PSY_FIXED_ONLINE,\n\n\t \n\t \n\tANX7411_PSY_HANG = 0xff,\n};\n\nstruct typec_params {\n\tint request_current;  \n\tint request_voltage;  \n\tint cc_connect;\n\tint cc_orientation_valid;\n\tint cc_status;\n\tint data_role;\n\tint power_role;\n\tint vconn_role;\n\tint dp_altmode_enter;\n\tint cust_altmode_enter;\n\tstruct usb_role_switch *role_sw;\n\tstruct typec_port *port;\n\tstruct typec_partner *partner;\n\tstruct typec_mux_dev *typec_mux;\n\tstruct typec_switch_dev *typec_switch;\n\tstruct typec_altmode *amode[MAX_ALTMODE];\n\tstruct typec_altmode *port_amode[MAX_ALTMODE];\n\tstruct typec_displayport_data data;\n\tint pin_assignment;\n\tstruct typec_capability caps;\n\tu32 src_pdo[PDO_MAX_OBJECTS];\n\tu32 sink_pdo[PDO_MAX_OBJECTS];\n\tu8 caps_flags;\n\tu8 src_pdo_nr;\n\tu8 sink_pdo_nr;\n\tu8 sink_watt;\n\tu8 sink_voltage;\n};\n\n#define MAX_BUF_LEN\t30\nstruct fw_msg {\n\tu8 msg_len;\n\tu8 msg_type;\n\tu8 buf[MAX_BUF_LEN];\n} __packed;\n\nstruct anx7411_data {\n\tint fw_version;\n\tint fw_subversion;\n\tstruct i2c_client *tcpc_client;\n\tstruct i2c_client *spi_client;\n\tstruct fw_msg send_msg;\n\tstruct fw_msg recv_msg;\n\tstruct gpio_desc *intp_gpiod;\n\tstruct fwnode_handle *connector_fwnode;\n\tstruct typec_params typec;\n\tint intp_irq;\n\tstruct work_struct work;\n\tstruct workqueue_struct *workqueue;\n\t \n\tstruct mutex lock;\n\n\tenum anx7411_psy_state psy_online;\n\tenum power_supply_usb_type usb_type;\n\tstruct power_supply *psy;\n\tstruct power_supply_desc psy_desc;\n\tstruct device *dev;\n};\n\nstatic u8 snk_identity[] = {\n\tLOBYTE(VID_ANALOGIX), HIBYTE(VID_ANALOGIX), 0x00, 0x82,  \n\t0x00, 0x00, 0x00, 0x00,                                  \n\t0x00, 0x00, LOBYTE(PID_ANALOGIX), HIBYTE(PID_ANALOGIX),  \n};\n\nstatic u8 dp_caps[4] = {0xC6, 0x00, 0x00, 0x00};\n\nstatic int anx7411_reg_read(struct i2c_client *client,\n\t\t\t    u8 reg_addr)\n{\n\treturn i2c_smbus_read_byte_data(client, reg_addr);\n}\n\nstatic int anx7411_reg_block_read(struct i2c_client *client,\n\t\t\t\t  u8 reg_addr, u8 len, u8 *buf)\n{\n\treturn i2c_smbus_read_i2c_block_data(client, reg_addr, len, buf);\n}\n\nstatic int anx7411_reg_write(struct i2c_client *client,\n\t\t\t     u8 reg_addr, u8 reg_val)\n{\n\treturn i2c_smbus_write_byte_data(client, reg_addr, reg_val);\n}\n\nstatic int anx7411_reg_block_write(struct i2c_client *client,\n\t\t\t\t   u8 reg_addr, u8 len, u8 *buf)\n{\n\treturn i2c_smbus_write_i2c_block_data(client, reg_addr, len, buf);\n}\n\nstatic struct anx7411_i2c_select anx7411_i2c_addr[] = {\n\t{TCPC_ADDRESS1, SPI_ADDRESS1},\n\t{TCPC_ADDRESS2, SPI_ADDRESS2},\n\t{TCPC_ADDRESS3, SPI_ADDRESS3},\n\t{TCPC_ADDRESS4, SPI_ADDRESS4},\n};\n\nstatic int anx7411_detect_power_mode(struct anx7411_data *ctx)\n{\n\tint ret;\n\tint mode;\n\n\tret = anx7411_reg_read(ctx->spi_client, REQUEST_CURRENT);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->typec.request_current = ret * CURRENT_UNIT;  \n\n\tret = anx7411_reg_read(ctx->spi_client, REQUEST_VOLTAGE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->typec.request_voltage = ret * VOLTAGE_UNIT;  \n\n\tif (ctx->psy_online == ANX7411_PSY_OFFLINE) {\n\t\tctx->psy_online = ANX7411_PSY_FIXED_ONLINE;\n\t\tctx->usb_type = POWER_SUPPLY_USB_TYPE_PD;\n\t\tpower_supply_changed(ctx->psy);\n\t}\n\n\tif (!ctx->typec.cc_orientation_valid)\n\t\treturn 0;\n\n\tif (ctx->typec.cc_connect == CC1_CONNECTED)\n\t\tmode = CC1_RP(ctx->typec.cc_status);\n\telse\n\t\tmode = CC2_RP(ctx->typec.cc_status);\n\tif (mode) {\n\t\ttypec_set_pwr_opmode(ctx->typec.port, mode - 1);\n\t\treturn 0;\n\t}\n\n\ttypec_set_pwr_opmode(ctx->typec.port, TYPEC_PWR_MODE_PD);\n\n\treturn 0;\n}\n\nstatic int anx7411_register_partner(struct anx7411_data *ctx,\n\t\t\t\t    int pd, int accessory)\n{\n\tstruct typec_partner_desc desc;\n\tstruct typec_partner *partner;\n\n\tif (ctx->typec.partner)\n\t\treturn 0;\n\n\tdesc.usb_pd = pd;\n\tdesc.accessory = accessory;\n\tdesc.identity = NULL;\n\tpartner = typec_register_partner(ctx->typec.port, &desc);\n\tif (IS_ERR(partner))\n\t\treturn PTR_ERR(partner);\n\n\tctx->typec.partner = partner;\n\n\treturn 0;\n}\n\nstatic int anx7411_detect_cc_orientation(struct anx7411_data *ctx)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tint ret;\n\tint cc1_rd, cc2_rd;\n\tint cc1_ra, cc2_ra;\n\tint cc1_rp, cc2_rp;\n\n\tret = anx7411_reg_read(ctx->spi_client, CC_STATUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->typec.cc_status = ret;\n\n\tcc1_rd = ret & CC1_RD ? 1 : 0;\n\tcc2_rd = ret & CC2_RD ? 1 : 0;\n\tcc1_ra = ret & CC1_RA ? 1 : 0;\n\tcc2_ra = ret & CC2_RA ? 1 : 0;\n\tcc1_rp = CC1_RP(ret);\n\tcc2_rp = CC2_RP(ret);\n\n\t \n\tif (cc1_rd && cc2_rd) {\n\t\tctx->typec.cc_orientation_valid = 0;\n\t\treturn anx7411_register_partner(ctx, 0, TYPEC_ACCESSORY_DEBUG);\n\t}\n\n\tif (cc1_ra && cc2_ra) {\n\t\tctx->typec.cc_orientation_valid = 0;\n\t\treturn anx7411_register_partner(ctx, 0, TYPEC_ACCESSORY_AUDIO);\n\t}\n\n\tctx->typec.cc_orientation_valid = 1;\n\n\tret = anx7411_register_partner(ctx, 1, TYPEC_ACCESSORY_NONE);\n\tif (ret) {\n\t\tdev_err(dev, \"register partner\\n\");\n\t\treturn ret;\n\t}\n\n\tif (cc1_rd || cc1_rp) {\n\t\ttypec_set_orientation(ctx->typec.port, TYPEC_ORIENTATION_NORMAL);\n\t\tctx->typec.cc_connect = CC1_CONNECTED;\n\t}\n\n\tif (cc2_rd || cc2_rp) {\n\t\ttypec_set_orientation(ctx->typec.port, TYPEC_ORIENTATION_REVERSE);\n\t\tctx->typec.cc_connect = CC2_CONNECTED;\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7411_set_mux(struct anx7411_data *ctx, int pin_assignment)\n{\n\tint mode = TYPEC_STATE_SAFE;\n\n\tswitch (pin_assignment) {\n\tcase SELECT_PIN_ASSIGMENT_U:\n\t\t \n\t\tmode = TYPEC_STATE_MODAL;\n\t\tbreak;\n\tcase SELECT_PIN_ASSIGMENT_C:\n\tcase SELECT_PIN_ASSIGMENT_E:\n\t\t \n\t\tmode = TYPEC_STATE_SAFE;\n\t\tbreak;\n\tcase SELECT_PIN_ASSIGMENT_D:\n\t\t \n\t\tmode = TYPEC_MODE_USB3;\n\t\tbreak;\n\tdefault:\n\t\tmode = TYPEC_STATE_SAFE;\n\t\tbreak;\n\t}\n\n\tctx->typec.pin_assignment = pin_assignment;\n\n\treturn typec_set_mode(ctx->typec.port, mode);\n}\n\nstatic int anx7411_set_usb_role(struct anx7411_data *ctx, enum usb_role role)\n{\n\tif (!ctx->typec.role_sw)\n\t\treturn 0;\n\n\treturn usb_role_switch_set_role(ctx->typec.role_sw, role);\n}\n\nstatic int anx7411_data_role_detect(struct anx7411_data *ctx)\n{\n\tint ret;\n\n\tret = anx7411_reg_read(ctx->spi_client, SYSTEM_STSTUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->typec.data_role = (ret & DATA_ROLE) ? TYPEC_HOST : TYPEC_DEVICE;\n\tctx->typec.vconn_role = (ret & VCONN_STATUS) ? TYPEC_SOURCE : TYPEC_SINK;\n\n\ttypec_set_data_role(ctx->typec.port, ctx->typec.data_role);\n\n\ttypec_set_vconn_role(ctx->typec.port, ctx->typec.vconn_role);\n\n\tif (ctx->typec.data_role == TYPEC_HOST)\n\t\treturn anx7411_set_usb_role(ctx, USB_ROLE_HOST);\n\n\treturn anx7411_set_usb_role(ctx, USB_ROLE_DEVICE);\n}\n\nstatic int anx7411_power_role_detect(struct anx7411_data *ctx)\n{\n\tint ret;\n\n\tret = anx7411_reg_read(ctx->spi_client, SYSTEM_STSTUS);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tctx->typec.power_role = (ret & SINK_STATUS) ? TYPEC_SINK : TYPEC_SOURCE;\n\n\tif (ctx->typec.power_role == TYPEC_SOURCE) {\n\t\tctx->typec.request_current = DEF_1_5A;\n\t\tctx->typec.request_voltage = DEF_5V;\n\t}\n\n\ttypec_set_pwr_role(ctx->typec.port, ctx->typec.power_role);\n\n\treturn 0;\n}\n\nstatic int anx7411_cc_status_detect(struct anx7411_data *ctx)\n{\n\tanx7411_detect_cc_orientation(ctx);\n\tanx7411_detect_power_mode(ctx);\n\n\treturn 0;\n}\n\nstatic void anx7411_partner_unregister_altmode(struct anx7411_data *ctx)\n{\n\tint i;\n\n\tctx->typec.dp_altmode_enter = 0;\n\tctx->typec.cust_altmode_enter = 0;\n\n\tfor (i = 0; i < MAX_ALTMODE; i++)\n\t\tif (ctx->typec.amode[i]) {\n\t\t\ttypec_unregister_altmode(ctx->typec.amode[i]);\n\t\t\tctx->typec.amode[i] = NULL;\n\t\t}\n\n\tctx->typec.pin_assignment = 0;\n}\n\nstatic int anx7411_typec_register_altmode(struct anx7411_data *ctx,\n\t\t\t\t\t  int svid, int vdo)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tstruct typec_altmode_desc desc;\n\tint err;\n\tint i;\n\n\tdesc.svid = svid;\n\tdesc.vdo = vdo;\n\n\tfor (i = 0; i < MAX_ALTMODE; i++)\n\t\tif (!ctx->typec.amode[i])\n\t\t\tbreak;\n\n\tdesc.mode = i + 1;  \n\n\tif (i >= MAX_ALTMODE) {\n\t\tdev_err(dev, \"no altmode space for registering\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tctx->typec.amode[i] = typec_partner_register_altmode(ctx->typec.partner,\n\t\t\t\t\t\t\t     &desc);\n\tif (IS_ERR(ctx->typec.amode[i])) {\n\t\tdev_err(dev, \"failed to register altmode\\n\");\n\t\terr = PTR_ERR(ctx->typec.amode[i]);\n\t\tctx->typec.amode[i] = NULL;\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void anx7411_unregister_partner(struct anx7411_data *ctx)\n{\n\tif (ctx->typec.partner) {\n\t\ttypec_unregister_partner(ctx->typec.partner);\n\t\tctx->typec.partner = NULL;\n\t}\n}\n\nstatic int anx7411_update_altmode(struct anx7411_data *ctx, int svid)\n{\n\tint i;\n\n\tif (svid == DP_SVID)\n\t\tctx->typec.dp_altmode_enter = 1;\n\telse\n\t\tctx->typec.cust_altmode_enter = 1;\n\n\tfor (i = 0; i < MAX_ALTMODE; i++) {\n\t\tif (!ctx->typec.amode[i])\n\t\t\tcontinue;\n\n\t\tif (ctx->typec.amode[i]->svid == svid) {\n\t\t\ttypec_altmode_update_active(ctx->typec.amode[i], true);\n\t\t\ttypec_altmode_notify(ctx->typec.amode[i],\n\t\t\t\t\t     ctx->typec.pin_assignment,\n\t\t\t\t\t     &ctx->typec.data);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7411_register_altmode(struct anx7411_data *ctx,\n\t\t\t\t    bool dp_altmode, u8 *buf)\n{\n\tint ret;\n\tint svid;\n\tint mid;\n\n\tif (!ctx->typec.partner)\n\t\treturn 0;\n\n\tsvid = DP_SVID;\n\tif (dp_altmode) {\n\t\tmid = buf[0] | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n\n\t\treturn anx7411_typec_register_altmode(ctx, svid, mid);\n\t}\n\n\tsvid = (buf[3] << 8) | buf[2];\n\tif ((buf[0] & VDM_CMD_AND_ACK_MASK) != (VDM_ACK | VDM_CMD_ENTER_MODE))\n\t\treturn anx7411_update_altmode(ctx, svid);\n\n\tif ((buf[0] & VDM_CMD_AND_ACK_MASK) != (VDM_ACK | VDM_CMD_DIS_MOD))\n\t\treturn 0;\n\n\tmid = buf[4] | (buf[5] << 8) | (buf[6] << 16) | (buf[7] << 24);\n\n\tret = anx7411_typec_register_altmode(ctx, svid, mid);\n\tif (ctx->typec.cust_altmode_enter)\n\t\tret |= anx7411_update_altmode(ctx, svid);\n\n\treturn ret;\n}\n\nstatic int anx7411_parse_cmd(struct anx7411_data *ctx, u8 type, u8 *buf, u8 len)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tu8 cur_50ma, vol_100mv;\n\n\tswitch (type) {\n\tcase TYPE_SRC_CAP:\n\t\tcur_50ma = anx7411_reg_read(ctx->spi_client, REQUEST_CURRENT);\n\t\tvol_100mv = anx7411_reg_read(ctx->spi_client, REQUEST_VOLTAGE);\n\n\t\tctx->typec.request_voltage = vol_100mv * VOLTAGE_UNIT;\n\t\tctx->typec.request_current = cur_50ma * CURRENT_UNIT;\n\n\t\tctx->psy_online = ANX7411_PSY_FIXED_ONLINE;\n\t\tctx->usb_type = POWER_SUPPLY_USB_TYPE_PD;\n\t\tpower_supply_changed(ctx->psy);\n\t\tbreak;\n\tcase TYPE_SNK_CAP:\n\t\tbreak;\n\tcase TYPE_SVID:\n\t\tbreak;\n\tcase TYPE_SNK_IDENTITY:\n\t\tbreak;\n\tcase TYPE_GET_DP_ALT_ENTER:\n\t\t \n\t\tif (buf[0])\n\t\t\tanx7411_update_altmode(ctx, DP_SVID);\n\t\tbreak;\n\tcase TYPE_DP_ALT_ENTER:\n\t\t \n\t\tanx7411_update_altmode(ctx, DP_SVID);\n\t\tbreak;\n\tcase TYPE_OBJ_REQ:\n\t\tanx7411_detect_power_mode(ctx);\n\t\tbreak;\n\tcase TYPE_DP_CONFIGURE:\n\t\tanx7411_set_mux(ctx, buf[1]);\n\t\tbreak;\n\tcase TYPE_DP_DISCOVER_MODES_INFO:\n\t\t \n\t\tif (buf[0] | buf[1])\n\t\t\t \n\t\t\tanx7411_register_altmode(ctx, 1, buf);\n\t\tbreak;\n\tcase TYPE_VDM:\n\t\t \n\t\tanx7411_register_altmode(ctx, 0, buf);\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"ignore message(0x%.02x).\\n\", type);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic u8 checksum(struct device *dev, u8 *buf, u8 len)\n{\n\tu8 ret = 0;\n\tu8 i;\n\n\tfor (i = 0; i < len; i++)\n\t\tret += buf[i];\n\n\treturn ret;\n}\n\nstatic int anx7411_read_msg_ctrl_status(struct i2c_client *client)\n{\n\treturn anx7411_reg_read(client, CMD_SEND_BUF);\n}\n\nstatic int anx7411_wait_msg_empty(struct i2c_client *client)\n{\n\tint val;\n\n\treturn readx_poll_timeout(anx7411_read_msg_ctrl_status,\n\t\t\t\t  client, val, (val < 0) || (val == 0),\n\t\t\t\t  2000, 2000 * 150);\n}\n\nstatic int anx7411_send_msg(struct anx7411_data *ctx, u8 type, u8 *buf, u8 size)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tstruct fw_msg *msg = &ctx->send_msg;\n\tu8 crc;\n\tint ret;\n\n\tsize = min_t(u8, size, (u8)MAX_BUF_LEN);\n\tmemcpy(msg->buf, buf, size);\n\tmsg->msg_type = type;\n\t \n\tmsg->msg_len = size + 1;\n\n\t \n\tcrc = checksum(dev, (u8 *)msg, size + HEADER_LEN);\n\tmsg->buf[size] = 0 - crc;\n\n\tret = anx7411_wait_msg_empty(ctx->spi_client);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anx7411_reg_block_write(ctx->spi_client,\n\t\t\t\t      CMD_SEND_BUF + 1, size + HEADER_LEN,\n\t\t\t\t      &msg->msg_type);\n\tret |= anx7411_reg_write(ctx->spi_client, CMD_SEND_BUF,\n\t\t\t\t msg->msg_len);\n\treturn ret;\n}\n\nstatic int anx7411_process_cmd(struct anx7411_data *ctx)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tstruct fw_msg *msg = &ctx->recv_msg;\n\tu8 len;\n\tu8 crc;\n\tint ret;\n\n\t \n\tret = anx7411_reg_block_read(ctx->spi_client, CMD_RECV_BUF,\n\t\t\t\t     MSG_LEN, (u8 *)msg);\n\tif (ret < 0)\n\t\treturn 0;\n\n\tif (!msg->msg_len)\n\t\treturn 0;\n\n\tret = anx7411_reg_write(ctx->spi_client, CMD_RECV_BUF, 0);\n\tif (ret)\n\t\treturn ret;\n\n\tlen = msg->msg_len & MSG_LEN_MASK;\n\tcrc = checksum(dev, (u8 *)msg, len + HEADER_LEN);\n\tif (crc) {\n\t\tdev_err(dev, \"message error crc(0x%.02x)\\n\", crc);\n\t\treturn -ERANGE;\n\t}\n\n\treturn anx7411_parse_cmd(ctx, msg->msg_type, msg->buf, len - 1);\n}\n\nstatic void anx7411_translate_payload(struct device *dev, __le32 *payload,\n\t\t\t\t      u32 *pdo, int nr, const char *type)\n{\n\tint i;\n\n\tif (nr > PDO_MAX_OBJECTS) {\n\t\tdev_err(dev, \"nr(%d) exceed PDO_MAX_OBJECTS(%d)\\n\",\n\t\t\tnr, PDO_MAX_OBJECTS);\n\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr; i++)\n\t\tpayload[i] = cpu_to_le32(pdo[i]);\n}\n\nstatic int anx7411_config(struct anx7411_data *ctx)\n{\n\tstruct device *dev = &ctx->spi_client->dev;\n\tstruct typec_params *typecp = &ctx->typec;\n\t__le32 payload[PDO_MAX_OBJECTS];\n\tint ret;\n\n\t \n\tret = anx7411_reg_write(ctx->spi_client, PD_REV_INIT, PD_REV20);\n\tret |= anx7411_reg_write(ctx->tcpc_client, FW_CTRL_0,\n\t\t\t\t UNSTRUCT_VDM_EN | DELAY_200MS |\n\t\t\t\t VSAFE1 | FRS_EN);\n\tret |= anx7411_reg_write(ctx->spi_client, FW_CTRL_1,\n\t\t\t\t AUTO_PD_EN | FORCE_SEND_RDO);\n\n\t \n\tret |= anx7411_reg_write(ctx->tcpc_client, VBUS_THRESHOLD_H, 0xff);\n\tret |= anx7411_reg_write(ctx->tcpc_client, VBUS_THRESHOLD_L, 0x03);\n\n\t \n\tret |= anx7411_reg_write(ctx->tcpc_client, FW_PARAM,\n\t\t\t\t anx7411_reg_read(ctx->tcpc_client, FW_PARAM) |\n\t\t\t\t DONGLE_IOP);\n\tret |= anx7411_reg_write(ctx->spi_client, INT_MASK, 0);\n\n\tret |= anx7411_reg_write(ctx->spi_client, PD_EXT_MSG_CTRL, 0xFF);\n\tif (ret)\n\t\treturn ret;\n\n\tif (typecp->caps_flags & HAS_SOURCE_CAP) {\n\t\tanx7411_translate_payload(dev, payload, typecp->src_pdo,\n\t\t\t\t\t  typecp->src_pdo_nr, \"source\");\n\t\tanx7411_send_msg(ctx, TYPE_SRC_CAP, (u8 *)&payload,\n\t\t\t\t typecp->src_pdo_nr * 4);\n\t\tanx7411_send_msg(ctx, TYPE_SNK_IDENTITY, snk_identity,\n\t\t\t\t sizeof(snk_identity));\n\t\tanx7411_send_msg(ctx, TYPE_SET_SNK_DP_CAP, dp_caps,\n\t\t\t\t sizeof(dp_caps));\n\t}\n\n\tif (typecp->caps_flags & HAS_SINK_CAP) {\n\t\tanx7411_translate_payload(dev, payload, typecp->sink_pdo,\n\t\t\t\t\t  typecp->sink_pdo_nr, \"sink\");\n\t\tanx7411_send_msg(ctx, TYPE_SNK_CAP, (u8 *)&payload,\n\t\t\t\t typecp->sink_pdo_nr * 4);\n\t}\n\n\tif (typecp->caps_flags & HAS_SINK_WATT) {\n\t\tif (typecp->sink_watt) {\n\t\t\tret |= anx7411_reg_write(ctx->spi_client, MAX_POWER,\n\t\t\t\t\t\t typecp->sink_watt);\n\t\t\t \n\t\t\tret |= anx7411_reg_write(ctx->spi_client, MIN_POWER, 2);\n\t\t}\n\n\t\tif (typecp->sink_voltage)\n\t\t\tret |= anx7411_reg_write(ctx->spi_client, MAX_VOLTAGE,\n\t\t\t\t\t  typecp->sink_voltage);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (!typecp->caps_flags)\n\t\tusleep_range(5000, 6000);\n\n\tctx->fw_version = anx7411_reg_read(ctx->spi_client, FW_VER);\n\tctx->fw_subversion = anx7411_reg_read(ctx->spi_client, FW_SUBVER);\n\n\treturn 0;\n}\n\nstatic void anx7411_chip_standby(struct anx7411_data *ctx)\n{\n\tint ret;\n\tu8 cc1, cc2;\n\tstruct device *dev = &ctx->spi_client->dev;\n\n\tret = anx7411_reg_write(ctx->spi_client, OCM_CTRL_0,\n\t\t\t\tanx7411_reg_read(ctx->spi_client, OCM_CTRL_0) |\n\t\t\t\tOCM_RESET);\n\tret |= anx7411_reg_write(ctx->tcpc_client, ANALOG_CTRL_10, 0x80);\n\t \n\tcc1 = TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC1_SHIFT;\n\tcc2 = TCPC_ROLE_CTRL_CC_RD << TCPC_ROLE_CTRL_CC2_SHIFT;\n\tret |= anx7411_reg_write(ctx->tcpc_client, TCPC_ROLE_CTRL,\n\t\t\t\t TCPC_ROLE_CTRL_DRP | cc1 | cc2);\n\n\t \n\tret |= anx7411_reg_write(ctx->tcpc_client, TCPC_COMMAND,\n\t\t\t\t TCPC_CMD_LOOK4CONNECTION);\n\n\t \n\tret |= anx7411_reg_write(ctx->tcpc_client,\n\t\t\t\t TCPC_COMMAND, TCPC_CMD_I2C_IDLE);\n\tif (ret)\n\t\tdev_err(dev, \"Chip standby failed\\n\");\n}\n\nstatic void anx7411_work_func(struct work_struct *work)\n{\n\tint ret;\n\tu8 buf[STATUS_LEN];\n\tu8 int_change;  \n\tu8 int_status;  \n\tu8 alert0, alert1;  \n\tstruct anx7411_data *ctx = container_of(work, struct anx7411_data, work);\n\tstruct device *dev = &ctx->spi_client->dev;\n\n\tmutex_lock(&ctx->lock);\n\n\t \n\tret = anx7411_reg_block_read(ctx->spi_client, INT_STS, STATUS_LEN, buf);\n\tif (ret < 0) {\n\t\t \n\t\tgoto unlock;\n\t}\n\tint_change = buf[0];\n\tint_status = buf[1];\n\n\t \n\tret = anx7411_reg_block_read(ctx->tcpc_client, ALERT_0, STATUS_LEN, buf);\n\tif (ret < 0)\n\t\tgoto unlock;\n\n\talert0 = buf[0];\n\talert1 = buf[1];\n\n\t \n\tret = anx7411_reg_write(ctx->spi_client, INT_STS, 0);\n\tret |= anx7411_reg_write(ctx->tcpc_client, ALERT_0, alert0);\n\tret |= anx7411_reg_write(ctx->tcpc_client, ALERT_1, alert1);\n\tif (ret)\n\t\tgoto unlock;\n\n\tif (alert1 & INTP_POW_OFF) {\n\t\tanx7411_partner_unregister_altmode(ctx);\n\t\tif (anx7411_set_usb_role(ctx, USB_ROLE_NONE))\n\t\t\tdev_err(dev, \"Set usb role\\n\");\n\t\tanx7411_unregister_partner(ctx);\n\t\tctx->psy_online = ANX7411_PSY_OFFLINE;\n\t\tctx->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\t\tctx->typec.request_voltage = 0;\n\t\tctx->typec.request_current = 0;\n\t\tpower_supply_changed(ctx->psy);\n\t\tanx7411_chip_standby(ctx);\n\t\tgoto unlock;\n\t}\n\n\tif ((alert0 & SOFTWARE_INT) && (int_change & OCM_BOOT_UP)) {\n\t\tif (anx7411_config(ctx))\n\t\t\tdev_err(dev, \"Config failed\\n\");\n\t\tif (anx7411_data_role_detect(ctx))\n\t\t\tdev_err(dev, \"set PD data role\\n\");\n\t\tif (anx7411_power_role_detect(ctx))\n\t\t\tdev_err(dev, \"set PD power role\\n\");\n\t\tanx7411_set_mux(ctx, SELECT_PIN_ASSIGMENT_C);\n\t}\n\n\tif (alert0 & RECEIVED_MSG)\n\t\tanx7411_process_cmd(ctx);\n\n\tret = (int_status & DATA_ROLE) ? TYPEC_HOST : TYPEC_DEVICE;\n\tif (ctx->typec.data_role != ret)\n\t\tif (anx7411_data_role_detect(ctx))\n\t\t\tdev_err(dev, \"set PD data role\\n\");\n\n\tret = (int_status & SINK_STATUS) ? TYPEC_SINK : TYPEC_SOURCE;\n\tif (ctx->typec.power_role != ret)\n\t\tif (anx7411_power_role_detect(ctx))\n\t\t\tdev_err(dev, \"set PD power role\\n\");\n\n\tif ((alert0 & SOFTWARE_INT) && (int_change & CC_STATUS_CHANGE))\n\t\tanx7411_cc_status_detect(ctx);\n\nunlock:\n\tmutex_unlock(&ctx->lock);\n}\n\nstatic irqreturn_t anx7411_intr_isr(int irq, void *data)\n{\n\tstruct anx7411_data *ctx = (struct anx7411_data *)data;\n\n\tqueue_work(ctx->workqueue, &ctx->work);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int anx7411_register_i2c_dummy_clients(struct anx7411_data *ctx,\n\t\t\t\t\t      struct i2c_client *client)\n{\n\tint i;\n\tu8 spi_addr;\n\n\tfor (i = 0; i < ARRAY_SIZE(anx7411_i2c_addr); i++) {\n\t\tif (client->addr == (anx7411_i2c_addr[i].tcpc_address >> 1)) {\n\t\t\tspi_addr = anx7411_i2c_addr[i].spi_address >> 1;\n\t\t\tctx->spi_client = i2c_new_dummy_device(client->adapter,\n\t\t\t\t\t\t\t       spi_addr);\n\t\t\tif (!IS_ERR(ctx->spi_client))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdev_err(&client->dev, \"unable to get SPI slave\\n\");\n\treturn -ENOMEM;\n}\n\nstatic void anx7411_port_unregister_altmodes(struct typec_altmode **adev)\n{\n\tint i;\n\n\tfor (i = 0; i < MAX_ALTMODE; i++)\n\t\tif (adev[i]) {\n\t\t\ttypec_unregister_altmode(adev[i]);\n\t\t\tadev[i] = NULL;\n\t\t}\n}\n\nstatic int anx7411_usb_mux_set(struct typec_mux_dev *mux,\n\t\t\t       struct typec_mux_state *state)\n{\n\tstruct anx7411_data *ctx = typec_mux_get_drvdata(mux);\n\tstruct device *dev = &ctx->spi_client->dev;\n\tint has_dp;\n\n\thas_dp = (state->alt && state->alt->svid == USB_TYPEC_DP_SID &&\n\t\t  state->alt->mode == USB_TYPEC_DP_MODE);\n\tif (!has_dp)\n\t\tdev_err(dev, \"dp altmode not register\\n\");\n\n\treturn 0;\n}\n\nstatic int anx7411_usb_set_orientation(struct typec_switch_dev *sw,\n\t\t\t\t       enum typec_orientation orientation)\n{\n\t \n\n\treturn 0;\n}\n\nstatic int anx7411_register_switch(struct anx7411_data *ctx,\n\t\t\t\t   struct device *dev,\n\t\t\t\t   struct fwnode_handle *fwnode)\n{\n\tstruct typec_switch_desc sw_desc = { };\n\n\tsw_desc.fwnode = fwnode;\n\tsw_desc.drvdata = ctx;\n\tsw_desc.name = fwnode_get_name(fwnode);\n\tsw_desc.set = anx7411_usb_set_orientation;\n\n\tctx->typec.typec_switch = typec_switch_register(dev, &sw_desc);\n\tif (IS_ERR(ctx->typec.typec_switch)) {\n\t\tdev_err(dev, \"switch register failed\\n\");\n\t\treturn PTR_ERR(ctx->typec.typec_switch);\n\t}\n\n\treturn 0;\n}\n\nstatic int anx7411_register_mux(struct anx7411_data *ctx,\n\t\t\t\tstruct device *dev,\n\t\t\t\tstruct fwnode_handle *fwnode)\n{\n\tstruct typec_mux_desc mux_desc = { };\n\n\tmux_desc.fwnode = fwnode;\n\tmux_desc.drvdata = ctx;\n\tmux_desc.name = fwnode_get_name(fwnode);\n\tmux_desc.set = anx7411_usb_mux_set;\n\n\tctx->typec.typec_mux = typec_mux_register(dev, &mux_desc);\n\tif (IS_ERR(ctx->typec.typec_mux)) {\n\t\tdev_err(dev, \"mux register failed\\n\");\n\t\treturn PTR_ERR(ctx->typec.typec_mux);\n\t}\n\n\treturn 0;\n}\n\nstatic void anx7411_unregister_mux(struct anx7411_data *ctx)\n{\n\tif (ctx->typec.typec_mux) {\n\t\ttypec_mux_unregister(ctx->typec.typec_mux);\n\t\tctx->typec.typec_mux = NULL;\n\t}\n}\n\nstatic void anx7411_unregister_switch(struct anx7411_data *ctx)\n{\n\tif (ctx->typec.typec_switch) {\n\t\ttypec_switch_unregister(ctx->typec.typec_switch);\n\t\tctx->typec.typec_switch = NULL;\n\t}\n}\n\nstatic int anx7411_typec_switch_probe(struct anx7411_data *ctx,\n\t\t\t\t      struct device *dev)\n{\n\tint ret;\n\tstruct device_node *node;\n\n\tnode = of_get_child_by_name(dev->of_node, \"orientation_switch\");\n\tif (!node)\n\t\treturn 0;\n\n\tret = anx7411_register_switch(ctx, dev, &node->fwnode);\n\tif (ret) {\n\t\tdev_err(dev, \"failed register switch\");\n\t\treturn ret;\n\t}\n\n\tnode = of_get_child_by_name(dev->of_node, \"mode_switch\");\n\tif (!node) {\n\t\tdev_err(dev, \"no typec mux exist\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_switch;\n\t}\n\n\tret = anx7411_register_mux(ctx, dev, &node->fwnode);\n\tif (ret) {\n\t\tdev_err(dev, \"failed register mode switch\");\n\t\tret = -ENODEV;\n\t\tgoto unregister_switch;\n\t}\n\n\treturn 0;\n\nunregister_switch:\n\tanx7411_unregister_switch(ctx);\n\n\treturn ret;\n}\n\nstatic int anx7411_typec_port_probe(struct anx7411_data *ctx,\n\t\t\t\t    struct device *dev)\n{\n\tstruct typec_capability *cap = &ctx->typec.caps;\n\tstruct typec_params *typecp = &ctx->typec;\n\tstruct fwnode_handle *fwnode;\n\tconst char *buf;\n\tint ret, i;\n\n\tfwnode = device_get_named_child_node(dev, \"connector\");\n\tif (!fwnode)\n\t\treturn -EINVAL;\n\n\tret = fwnode_property_read_string(fwnode, \"power-role\", &buf);\n\tif (ret) {\n\t\tdev_err(dev, \"power-role not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = typec_find_port_power_role(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->type = ret;\n\n\tret = fwnode_property_read_string(fwnode, \"data-role\", &buf);\n\tif (ret) {\n\t\tdev_err(dev, \"data-role not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = typec_find_port_data_role(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->data = ret;\n\n\tret = fwnode_property_read_string(fwnode, \"try-power-role\", &buf);\n\tif (ret) {\n\t\tdev_err(dev, \"try-power-role not found: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = typec_find_power_role(buf);\n\tif (ret < 0)\n\t\treturn ret;\n\tcap->prefer_role = ret;\n\n\t \n\tret = fwnode_property_count_u32(fwnode, \"source-pdos\");\n\tif (ret > 0) {\n\t\ttypecp->src_pdo_nr = min_t(u8, ret, PDO_MAX_OBJECTS);\n\t\tret = fwnode_property_read_u32_array(fwnode, \"source-pdos\",\n\t\t\t\t\t\t     typecp->src_pdo,\n\t\t\t\t\t\t     typecp->src_pdo_nr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"source cap validate failed: %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\ttypecp->caps_flags |= HAS_SOURCE_CAP;\n\t}\n\n\tret = fwnode_property_count_u32(fwnode, \"sink-pdos\");\n\tif (ret > 0) {\n\t\ttypecp->sink_pdo_nr = min_t(u8, ret, PDO_MAX_OBJECTS);\n\t\tret = fwnode_property_read_u32_array(fwnode, \"sink-pdos\",\n\t\t\t\t\t\t     typecp->sink_pdo,\n\t\t\t\t\t\t     typecp->sink_pdo_nr);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"sink cap validate failed: %d\\n\", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < typecp->sink_pdo_nr; i++) {\n\t\t\tret = 0;\n\t\t\tswitch (pdo_type(typecp->sink_pdo[i])) {\n\t\t\tcase PDO_TYPE_FIXED:\n\t\t\t\tret = pdo_fixed_voltage(typecp->sink_pdo[i]);\n\t\t\t\tbreak;\n\t\t\tcase PDO_TYPE_BATT:\n\t\t\tcase PDO_TYPE_VAR:\n\t\t\t\tret = pdo_max_voltage(typecp->sink_pdo[i]);\n\t\t\t\tbreak;\n\t\t\tcase PDO_TYPE_APDO:\n\t\t\tdefault:\n\t\t\t\tret = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\ttypecp->sink_voltage = max(5000, ret) / 100;\n\t\t}\n\n\t\ttypecp->caps_flags |= HAS_SINK_CAP;\n\t}\n\n\tif (!fwnode_property_read_u32(fwnode, \"op-sink-microwatt\", &ret)) {\n\t\ttypecp->sink_watt = ret / 500000;  \n\t\ttypecp->caps_flags |= HAS_SINK_WATT;\n\t}\n\n\tcap->fwnode = fwnode;\n\n\tctx->typec.role_sw = usb_role_switch_get(dev);\n\tif (IS_ERR(ctx->typec.role_sw)) {\n\t\tdev_err(dev, \"USB role switch not found.\\n\");\n\t\tctx->typec.role_sw = NULL;\n\t}\n\n\tctx->typec.port = typec_register_port(dev, cap);\n\tif (IS_ERR(ctx->typec.port)) {\n\t\tret = PTR_ERR(ctx->typec.port);\n\t\tctx->typec.port = NULL;\n\t\tdev_err(dev, \"Failed to register type c port %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\ttypec_port_register_altmodes(ctx->typec.port, NULL, ctx,\n\t\t\t\t     ctx->typec.port_amode,\n\t\t\t\t     MAX_ALTMODE);\n\treturn 0;\n}\n\nstatic int anx7411_typec_check_connection(struct anx7411_data *ctx)\n{\n\tint ret;\n\n\tret = anx7411_reg_read(ctx->spi_client, FW_VER);\n\tif (ret < 0)\n\t\treturn 0;  \n\n\t \n\tret = anx7411_reg_write(ctx->spi_client, INT_STS, 0);\n\tret |= anx7411_reg_write(ctx->tcpc_client, ALERT_0, 0xFF);\n\tret |= anx7411_reg_write(ctx->tcpc_client, ALERT_1, 0xFF);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anx7411_cc_status_detect(ctx);\n\tret |= anx7411_power_role_detect(ctx);\n\tret |= anx7411_data_role_detect(ctx);\n\tret |= anx7411_set_mux(ctx, SELECT_PIN_ASSIGMENT_C);\n\tif (ret)\n\t\treturn ret;\n\n\tret = anx7411_send_msg(ctx, TYPE_GET_DP_ALT_ENTER, NULL, 0);\n\tret |= anx7411_send_msg(ctx, TYPE_GET_DP_DISCOVER_MODES_INFO, NULL, 0);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused anx7411_runtime_pm_suspend(struct device *dev)\n{\n\tstruct anx7411_data *ctx = dev_get_drvdata(dev);\n\n\tmutex_lock(&ctx->lock);\n\n\tanx7411_partner_unregister_altmode(ctx);\n\n\tif (ctx->typec.partner)\n\t\tanx7411_unregister_partner(ctx);\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused anx7411_runtime_pm_resume(struct device *dev)\n{\n\tstruct anx7411_data *ctx = dev_get_drvdata(dev);\n\n\tmutex_lock(&ctx->lock);\n\t \n\tif (anx7411_typec_check_connection(ctx))\n\t\tdev_err(dev, \"check connection\");\n\n\tmutex_unlock(&ctx->lock);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops anx7411_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,\n\t\t\t\tpm_runtime_force_resume)\n\tSET_RUNTIME_PM_OPS(anx7411_runtime_pm_suspend,\n\t\t\t   anx7411_runtime_pm_resume, NULL)\n};\n\nstatic void anx7411_get_gpio_irq(struct anx7411_data *ctx)\n{\n\tstruct device *dev = &ctx->tcpc_client->dev;\n\n\tctx->intp_gpiod = devm_gpiod_get_optional(dev, \"interrupt\", GPIOD_IN);\n\tif (IS_ERR_OR_NULL(ctx->intp_gpiod)) {\n\t\tdev_err(dev, \"no interrupt gpio property\\n\");\n\t\treturn;\n\t}\n\n\tctx->intp_irq = gpiod_to_irq(ctx->intp_gpiod);\n\tif (ctx->intp_irq < 0)\n\t\tdev_err(dev, \"failed to get GPIO IRQ\\n\");\n}\n\nstatic enum power_supply_usb_type anx7411_psy_usb_types[] = {\n\tPOWER_SUPPLY_USB_TYPE_C,\n\tPOWER_SUPPLY_USB_TYPE_PD,\n\tPOWER_SUPPLY_USB_TYPE_PD_PPS,\n};\n\nstatic enum power_supply_property anx7411_psy_props[] = {\n\tPOWER_SUPPLY_PROP_USB_TYPE,\n\tPOWER_SUPPLY_PROP_ONLINE,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MIN,\n\tPOWER_SUPPLY_PROP_VOLTAGE_MAX,\n\tPOWER_SUPPLY_PROP_VOLTAGE_NOW,\n\tPOWER_SUPPLY_PROP_CURRENT_MAX,\n\tPOWER_SUPPLY_PROP_CURRENT_NOW,\n};\n\nstatic int anx7411_psy_set_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tconst union power_supply_propval *val)\n{\n\tstruct anx7411_data *ctx = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tif (psp == POWER_SUPPLY_PROP_ONLINE)\n\t\tctx->psy_online = val->intval;\n\telse\n\t\tret = -EINVAL;\n\n\tpower_supply_changed(ctx->psy);\n\treturn ret;\n}\n\nstatic int anx7411_psy_prop_writeable(struct power_supply *psy,\n\t\t\t\t      enum power_supply_property psp)\n{\n\treturn psp == POWER_SUPPLY_PROP_ONLINE;\n}\n\nstatic int anx7411_psy_get_prop(struct power_supply *psy,\n\t\t\t\tenum power_supply_property psp,\n\t\t\t\tunion power_supply_propval *val)\n{\n\tstruct anx7411_data *ctx = power_supply_get_drvdata(psy);\n\tint ret = 0;\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_USB_TYPE:\n\t\tval->intval = ctx->usb_type;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = ctx->psy_online;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_VOLTAGE_NOW:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MIN:\n\tcase POWER_SUPPLY_PROP_VOLTAGE_MAX:\n\t\tval->intval = (ctx->psy_online) ?\n\t\t\tctx->typec.request_voltage * 1000 : 0;\n\t\tbreak;\n\tcase POWER_SUPPLY_PROP_CURRENT_NOW:\n\tcase POWER_SUPPLY_PROP_CURRENT_MAX:\n\t\tval->intval = (ctx->psy_online) ?\n\t\t\tctx->typec.request_current * 1000 : 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic int anx7411_psy_register(struct anx7411_data *ctx)\n{\n\tstruct power_supply_desc *psy_desc = &ctx->psy_desc;\n\tstruct power_supply_config psy_cfg = {};\n\tchar *psy_name;\n\n\tpsy_name = devm_kasprintf(ctx->dev, GFP_KERNEL, \"anx7411-source-psy-%s\",\n\t\t\t\t  dev_name(ctx->dev));\n\tif (!psy_name)\n\t\treturn -ENOMEM;\n\n\tpsy_desc->name = psy_name;\n\tpsy_desc->type = POWER_SUPPLY_TYPE_USB;\n\tpsy_desc->usb_types = anx7411_psy_usb_types;\n\tpsy_desc->num_usb_types = ARRAY_SIZE(anx7411_psy_usb_types);\n\tpsy_desc->properties = anx7411_psy_props;\n\tpsy_desc->num_properties = ARRAY_SIZE(anx7411_psy_props);\n\n\tpsy_desc->get_property = anx7411_psy_get_prop;\n\tpsy_desc->set_property = anx7411_psy_set_prop;\n\tpsy_desc->property_is_writeable = anx7411_psy_prop_writeable;\n\n\tctx->usb_type = POWER_SUPPLY_USB_TYPE_C;\n\tctx->psy = devm_power_supply_register(ctx->dev, psy_desc, &psy_cfg);\n\n\tif (IS_ERR(ctx->psy))\n\t\tdev_warn(ctx->dev, \"unable to register psy\\n\");\n\n\treturn PTR_ERR_OR_ZERO(ctx->psy);\n}\n\nstatic int anx7411_i2c_probe(struct i2c_client *client)\n{\n\tstruct anx7411_data *plat;\n\tstruct device *dev = &client->dev;\n\tint ret;\n\n\tif (!i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_I2C_BLOCK))\n\t\treturn -ENODEV;\n\n\tplat = devm_kzalloc(dev, sizeof(*plat), GFP_KERNEL);\n\tif (!plat)\n\t\treturn -ENOMEM;\n\n\tplat->tcpc_client = client;\n\ti2c_set_clientdata(client, plat);\n\n\tmutex_init(&plat->lock);\n\n\tret = anx7411_register_i2c_dummy_clients(plat, client);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to reserve I2C bus\\n\");\n\t\treturn ret;\n\t}\n\n\tret = anx7411_typec_switch_probe(plat, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to probe typec switch\\n\");\n\t\tgoto free_i2c_dummy;\n\t}\n\n\tret = anx7411_typec_port_probe(plat, dev);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to probe typec property.\\n\");\n\t\tret = -ENODEV;\n\t\tgoto free_typec_switch;\n\t}\n\n\tplat->intp_irq = client->irq;\n\tif (!client->irq)\n\t\tanx7411_get_gpio_irq(plat);\n\n\tif (!plat->intp_irq) {\n\t\tdev_err(dev, \"fail to get interrupt IRQ\\n\");\n\t\tret = -EINVAL;\n\t\tgoto free_typec_port;\n\t}\n\n\tplat->dev = dev;\n\tplat->psy_online = ANX7411_PSY_OFFLINE;\n\tret = anx7411_psy_register(plat);\n\tif (ret) {\n\t\tdev_err(dev, \"register psy\\n\");\n\t\tgoto free_typec_port;\n\t}\n\n\tINIT_WORK(&plat->work, anx7411_work_func);\n\tplat->workqueue = alloc_workqueue(\"anx7411_work\",\n\t\t\t\t\t  WQ_FREEZABLE |\n\t\t\t\t\t  WQ_MEM_RECLAIM,\n\t\t\t\t\t  1);\n\tif (!plat->workqueue) {\n\t\tdev_err(dev, \"fail to create work queue\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_typec_port;\n\t}\n\n\tret = devm_request_threaded_irq(dev, plat->intp_irq,\n\t\t\t\t\tNULL, anx7411_intr_isr,\n\t\t\t\t\tIRQF_TRIGGER_FALLING |\n\t\t\t\t\tIRQF_ONESHOT,\n\t\t\t\t\t\"anx7411-intp\", plat);\n\tif (ret) {\n\t\tdev_err(dev, \"fail to request irq\\n\");\n\t\tgoto free_wq;\n\t}\n\n\tif (anx7411_typec_check_connection(plat))\n\t\tdev_err(dev, \"check status\\n\");\n\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\nfree_wq:\n\tdestroy_workqueue(plat->workqueue);\n\nfree_typec_port:\n\ttypec_unregister_port(plat->typec.port);\n\tanx7411_port_unregister_altmodes(plat->typec.port_amode);\n\nfree_typec_switch:\n\tanx7411_unregister_switch(plat);\n\tanx7411_unregister_mux(plat);\n\nfree_i2c_dummy:\n\ti2c_unregister_device(plat->spi_client);\n\n\treturn ret;\n}\n\nstatic void anx7411_i2c_remove(struct i2c_client *client)\n{\n\tstruct anx7411_data *plat = i2c_get_clientdata(client);\n\n\tanx7411_partner_unregister_altmode(plat);\n\tanx7411_unregister_partner(plat);\n\n\tif (plat->workqueue)\n\t\tdestroy_workqueue(plat->workqueue);\n\n\tif (plat->spi_client)\n\t\ti2c_unregister_device(plat->spi_client);\n\n\tif (plat->typec.role_sw)\n\t\tusb_role_switch_put(plat->typec.role_sw);\n\n\tanx7411_unregister_mux(plat);\n\n\tanx7411_unregister_switch(plat);\n\n\tif (plat->typec.port)\n\t\ttypec_unregister_port(plat->typec.port);\n\n\tanx7411_port_unregister_altmodes(plat->typec.port_amode);\n}\n\nstatic const struct i2c_device_id anx7411_id[] = {\n\t{\"anx7411\", 0},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(i2c, anx7411_id);\n\nstatic const struct of_device_id anx_match_table[] = {\n\t{.compatible = \"analogix,anx7411\",},\n\t{},\n};\n\nstatic struct i2c_driver anx7411_driver = {\n\t.driver = {\n\t\t.name = \"anx7411\",\n\t\t.of_match_table = anx_match_table,\n\t\t.pm = &anx7411_pm_ops,\n\t},\n\t.probe = anx7411_i2c_probe,\n\t.remove = anx7411_i2c_remove,\n\n\t.id_table = anx7411_id,\n};\n\nmodule_i2c_driver(anx7411_driver);\n\nMODULE_DESCRIPTION(\"Anx7411 USB Type-C PD driver\");\nMODULE_AUTHOR(\"Xin Ji <xji@analogixsemi.com>\");\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(\"0.1.5\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}