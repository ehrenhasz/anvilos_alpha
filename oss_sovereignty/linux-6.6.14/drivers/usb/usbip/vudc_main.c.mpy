{
  "module_name": "vudc_main.c",
  "hash_id": "c5a62587de6b29036884468c473c63a5b00083f67dddfd512cfe93d834be3d61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_main.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#include \"vudc.h\"\n\nstatic unsigned int vudc_number = 1;\n\nmodule_param_named(num, vudc_number, uint, S_IRUGO);\nMODULE_PARM_DESC(num, \"number of emulated controllers\");\n\nstatic struct platform_driver vudc_driver = {\n\t.probe\t\t= vudc_probe,\n\t.remove\t\t= vudc_remove,\n\t.driver\t\t= {\n\t\t.name\t= GADGET_NAME,\n\t\t.dev_groups = vudc_groups,\n\t},\n};\n\nstatic LIST_HEAD(vudc_devices);\n\nstatic int __init vudc_init(void)\n{\n\tint retval = -ENOMEM;\n\tint i;\n\tstruct vudc_device *udc_dev = NULL, *udc_dev2 = NULL;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (vudc_number < 1) {\n\t\tpr_err(\"Number of emulated UDC must be no less than 1\");\n\t\treturn -EINVAL;\n\t}\n\n\tretval = platform_driver_register(&vudc_driver);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tfor (i = 0; i < vudc_number; i++) {\n\t\tudc_dev = alloc_vudc_device(i);\n\t\tif (!udc_dev) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tretval = platform_device_add(udc_dev->pdev);\n\t\tif (retval < 0) {\n\t\t\tput_vudc_device(udc_dev);\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tlist_add_tail(&udc_dev->dev_entry, &vudc_devices);\n\t\tif (!platform_get_drvdata(udc_dev->pdev)) {\n\t\t\t \n\t\t\tretval = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\tgoto out;\n\ncleanup:\n\tlist_for_each_entry_safe(udc_dev, udc_dev2, &vudc_devices, dev_entry) {\n\t\tlist_del(&udc_dev->dev_entry);\n\t\t \n\t\tplatform_device_del(udc_dev->pdev);\n\t\tput_vudc_device(udc_dev);\n\t}\n\n\tplatform_driver_unregister(&vudc_driver);\nout:\n\treturn retval;\n}\nmodule_init(vudc_init);\n\nstatic void __exit vudc_cleanup(void)\n{\n\tstruct vudc_device *udc_dev = NULL, *udc_dev2 = NULL;\n\n\tlist_for_each_entry_safe(udc_dev, udc_dev2, &vudc_devices, dev_entry) {\n\t\tlist_del(&udc_dev->dev_entry);\n\t\t \n\t\tplatform_device_del(udc_dev->pdev);\n\t\tput_vudc_device(udc_dev);\n\t}\n\tplatform_driver_unregister(&vudc_driver);\n}\nmodule_exit(vudc_cleanup);\n\nMODULE_DESCRIPTION(\"USB over IP Device Controller\");\nMODULE_AUTHOR(\"Krzysztof Opasiak, Karol Kosik, Igor Kotrasinski\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}