{
  "module_name": "usbip_event.c",
  "hash_id": "77f7ba801b63760ec29778fed057e12e71fd0a702a1e620360e09745c7928aab",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/usbip_event.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n\n#include \"usbip_common.h\"\n\nstruct usbip_event {\n\tstruct list_head node;\n\tstruct usbip_device *ud;\n};\n\nstatic DEFINE_SPINLOCK(event_lock);\nstatic LIST_HEAD(event_list);\n\nstatic void set_event(struct usbip_device *ud, unsigned long event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\tud->event |= event;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\nstatic void unset_event(struct usbip_device *ud, unsigned long event)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\tud->event &= ~event;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\nstatic struct usbip_device *get_event(void)\n{\n\tstruct usbip_event *ue = NULL;\n\tstruct usbip_device *ud = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&event_lock, flags);\n\tif (!list_empty(&event_list)) {\n\t\tue = list_first_entry(&event_list, struct usbip_event, node);\n\t\tlist_del(&ue->node);\n\t}\n\tspin_unlock_irqrestore(&event_lock, flags);\n\n\tif (ue) {\n\t\tud = ue->ud;\n\t\tkfree(ue);\n\t}\n\treturn ud;\n}\n\nstatic struct task_struct *worker_context;\n\nstatic void event_handler(struct work_struct *work)\n{\n\tstruct usbip_device *ud;\n\n\tif (worker_context == NULL) {\n\t\tworker_context = current;\n\t}\n\n\twhile ((ud = get_event()) != NULL) {\n\t\tusbip_dbg_eh(\"pending event %lx\\n\", ud->event);\n\n\t\tmutex_lock(&ud->sysfs_lock);\n\t\t \n\t\tif (ud->event & USBIP_EH_SHUTDOWN) {\n\t\t\tud->eh_ops.shutdown(ud);\n\t\t\tunset_event(ud, USBIP_EH_SHUTDOWN);\n\t\t}\n\n\t\t \n\t\tif (ud->event & USBIP_EH_RESET) {\n\t\t\tud->eh_ops.reset(ud);\n\t\t\tunset_event(ud, USBIP_EH_RESET);\n\t\t}\n\n\t\t \n\t\tif (ud->event & USBIP_EH_UNUSABLE) {\n\t\t\tud->eh_ops.unusable(ud);\n\t\t\tunset_event(ud, USBIP_EH_UNUSABLE);\n\t\t}\n\t\tmutex_unlock(&ud->sysfs_lock);\n\n\t\twake_up(&ud->eh_waitq);\n\t}\n}\n\nint usbip_start_eh(struct usbip_device *ud)\n{\n\tinit_waitqueue_head(&ud->eh_waitq);\n\tud->event = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbip_start_eh);\n\nvoid usbip_stop_eh(struct usbip_device *ud)\n{\n\tunsigned long pending = ud->event & ~USBIP_EH_BYE;\n\n\tif (!(ud->event & USBIP_EH_BYE))\n\t\tusbip_dbg_eh(\"usbip_eh stopping but not removed\\n\");\n\n\tif (pending)\n\t\tusbip_dbg_eh(\"usbip_eh waiting completion %lx\\n\", pending);\n\n\twait_event_interruptible(ud->eh_waitq, !(ud->event & ~USBIP_EH_BYE));\n\tusbip_dbg_eh(\"usbip_eh has stopped\\n\");\n}\nEXPORT_SYMBOL_GPL(usbip_stop_eh);\n\n#define WORK_QUEUE_NAME \"usbip_event\"\n\nstatic struct workqueue_struct *usbip_queue;\nstatic DECLARE_WORK(usbip_work, event_handler);\n\nint usbip_init_eh(void)\n{\n\tusbip_queue = create_singlethread_workqueue(WORK_QUEUE_NAME);\n\tif (usbip_queue == NULL) {\n\t\tpr_err(\"failed to create usbip_event\\n\");\n\t\treturn -ENOMEM;\n\t}\n\treturn 0;\n}\n\nvoid usbip_finish_eh(void)\n{\n\tdestroy_workqueue(usbip_queue);\n\tusbip_queue = NULL;\n}\n\nvoid usbip_event_add(struct usbip_device *ud, unsigned long event)\n{\n\tstruct usbip_event *ue;\n\tunsigned long flags;\n\n\tif (ud->event & USBIP_EH_BYE)\n\t\treturn;\n\n\tset_event(ud, event);\n\n\tspin_lock_irqsave(&event_lock, flags);\n\n\tlist_for_each_entry_reverse(ue, &event_list, node) {\n\t\tif (ue->ud == ud)\n\t\t\tgoto out;\n\t}\n\n\tue = kmalloc(sizeof(struct usbip_event), GFP_ATOMIC);\n\tif (ue == NULL)\n\t\tgoto out;\n\n\tue->ud = ud;\n\n\tlist_add_tail(&ue->node, &event_list);\n\tqueue_work(usbip_queue, &usbip_work);\n\nout:\n\tspin_unlock_irqrestore(&event_lock, flags);\n}\nEXPORT_SYMBOL_GPL(usbip_event_add);\n\nint usbip_event_happened(struct usbip_device *ud)\n{\n\tint happened = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\tif (ud->event != 0)\n\t\thappened = 1;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n\n\treturn happened;\n}\nEXPORT_SYMBOL_GPL(usbip_event_happened);\n\nint usbip_in_eh(struct task_struct *task)\n{\n\tif (task == worker_context)\n\t\treturn 1;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usbip_in_eh);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}