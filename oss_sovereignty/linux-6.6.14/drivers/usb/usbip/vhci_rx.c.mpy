{
  "module_name": "vhci_rx.c",
  "hash_id": "58ea5d308ed62730177c2b0d89ce7f80542e8cb9c2b935f2ae7e452c767069d1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vhci_rx.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/slab.h>\n\n#include \"usbip_common.h\"\n#include \"vhci.h\"\n\n \nstruct urb *pickup_urb_and_free_priv(struct vhci_device *vdev, __u32 seqnum)\n{\n\tstruct vhci_priv *priv, *tmp;\n\tstruct urb *urb = NULL;\n\tint status;\n\n\tlist_for_each_entry_safe(priv, tmp, &vdev->priv_rx, list) {\n\t\tif (priv->seqnum != seqnum)\n\t\t\tcontinue;\n\n\t\turb = priv->urb;\n\t\tstatus = urb->status;\n\n\t\tusbip_dbg_vhci_rx(\"find urb seqnum %u\\n\", seqnum);\n\n\t\tswitch (status) {\n\t\tcase -ENOENT:\n\t\t\tfallthrough;\n\t\tcase -ECONNRESET:\n\t\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\t \"urb seq# %u was unlinked %ssynchronously\\n\",\n\t\t\t\t seqnum, status == -ENOENT ? \"\" : \"a\");\n\t\t\tbreak;\n\t\tcase -EINPROGRESS:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\t \"urb seq# %u may be in a error, status %d\\n\",\n\t\t\t\t seqnum, status);\n\t\t}\n\n\t\tlist_del(&priv->list);\n\t\tkfree(priv);\n\t\turb->hcpriv = NULL;\n\n\t\tbreak;\n\t}\n\n\treturn urb;\n}\n\nstatic void vhci_recv_ret_submit(struct vhci_device *vdev,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tstruct vhci_hcd *vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tstruct usbip_device *ud = &vdev->ud;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\turb = pickup_urb_and_free_priv(vdev, pdu->base.seqnum);\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\tif (!urb) {\n\t\tpr_err(\"cannot find a urb of seqnum %u max seqnum %d\\n\",\n\t\t\tpdu->base.seqnum,\n\t\t\tatomic_read(&vhci_hcd->seqnum));\n\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\treturn;\n\t}\n\n\t \n\tusbip_pack_pdu(pdu, urb, USBIP_RET_SUBMIT, 0);\n\n\t \n\tif (usbip_recv_xbuff(ud, urb) < 0) {\n\t\turb->status = -EPROTO;\n\t\tgoto error;\n\t}\n\n\t \n\tif (usbip_recv_iso(ud, urb) < 0) {\n\t\turb->status = -EPROTO;\n\t\tgoto error;\n\t}\n\n\t \n\tusbip_pad_iso(ud, urb);\n\nerror:\n\tif (usbip_dbg_flag_vhci_rx)\n\t\tusbip_dump_urb(urb);\n\n\tif (urb->num_sgs)\n\t\turb->transfer_flags &= ~URB_DMA_MAP_SG;\n\n\tusbip_dbg_vhci_rx(\"now giveback urb %u\\n\", pdu->base.seqnum);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\tusb_hcd_unlink_urb_from_ep(vhci_hcd_to_hcd(vhci_hcd), urb);\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tusb_hcd_giveback_urb(vhci_hcd_to_hcd(vhci_hcd), urb, urb->status);\n\n\tusbip_dbg_vhci_rx(\"Leave\\n\");\n}\n\nstatic struct vhci_unlink *dequeue_pending_unlink(struct vhci_device *vdev,\n\t\t\t\t\t\t  struct usbip_header *pdu)\n{\n\tstruct vhci_unlink *unlink, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(unlink, tmp, &vdev->unlink_rx, list) {\n\t\tpr_info(\"unlink->seqnum %lu\\n\", unlink->seqnum);\n\t\tif (unlink->seqnum == pdu->base.seqnum) {\n\t\t\tusbip_dbg_vhci_rx(\"found pending unlink, %lu\\n\",\n\t\t\t\t\t  unlink->seqnum);\n\t\t\tlist_del(&unlink->list);\n\n\t\t\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\t\t\treturn unlink;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\treturn NULL;\n}\n\nstatic void vhci_recv_ret_unlink(struct vhci_device *vdev,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tstruct vhci_hcd *vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tstruct vhci_unlink *unlink;\n\tstruct urb *urb;\n\tunsigned long flags;\n\n\tusbip_dump_header(pdu);\n\n\tunlink = dequeue_pending_unlink(vdev, pdu);\n\tif (!unlink) {\n\t\tpr_info(\"cannot find the pending unlink %u\\n\",\n\t\t\tpdu->base.seqnum);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\turb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\tif (!urb) {\n\t\t \n\t\tpr_info(\"the urb (seqnum %d) was already given back\\n\",\n\t\t\tpdu->base.seqnum);\n\t} else {\n\t\tusbip_dbg_vhci_rx(\"now giveback urb %d\\n\", pdu->base.seqnum);\n\n\t\t \n\t\turb->status = pdu->u.ret_unlink.status;\n\t\tpr_info(\"urb->status %d\\n\", urb->status);\n\n\t\tspin_lock_irqsave(&vhci->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(vhci_hcd_to_hcd(vhci_hcd), urb);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\t\tusb_hcd_giveback_urb(vhci_hcd_to_hcd(vhci_hcd), urb, urb->status);\n\t}\n\n\tkfree(unlink);\n}\n\nstatic int vhci_priv_tx_empty(struct vhci_device *vdev)\n{\n\tint empty = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\tempty = list_empty(&vdev->priv_rx);\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\treturn empty;\n}\n\n \nstatic void vhci_rx_pdu(struct usbip_device *ud)\n{\n\tint ret;\n\tstruct usbip_header pdu;\n\tstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\n\n\tusbip_dbg_vhci_rx(\"Enter\\n\");\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\t \n\tret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\n\tif (ret < 0) {\n\t\tif (ret == -ECONNRESET)\n\t\t\tpr_info(\"connection reset by peer\\n\");\n\t\telse if (ret == -EAGAIN) {\n\t\t\t \n\t\t\tif (vhci_priv_tx_empty(vdev))\n\t\t\t\treturn;\n\t\t\tpr_info(\"connection timed out with pending urbs\\n\");\n\t\t} else if (ret != -ERESTARTSYS)\n\t\t\tpr_info(\"xmit failed %d\\n\", ret);\n\n\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\treturn;\n\t}\n\tif (ret == 0) {\n\t\tpr_info(\"connection closed\");\n\t\tusbip_event_add(ud, VDEV_EVENT_DOWN);\n\t\treturn;\n\t}\n\tif (ret != sizeof(pdu)) {\n\t\tpr_err(\"received pdu size is %d, should be %d\\n\", ret,\n\t\t       (unsigned int)sizeof(pdu));\n\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\treturn;\n\t}\n\n\tusbip_header_correct_endian(&pdu, 0);\n\n\tif (usbip_dbg_flag_vhci_rx)\n\t\tusbip_dump_header(&pdu);\n\n\tswitch (pdu.base.command) {\n\tcase USBIP_RET_SUBMIT:\n\t\tvhci_recv_ret_submit(vdev, &pdu);\n\t\tbreak;\n\tcase USBIP_RET_UNLINK:\n\t\tvhci_recv_ret_unlink(vdev, &pdu);\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tpr_err(\"unknown pdu %u\\n\", pdu.base.command);\n\t\tusbip_dump_header(&pdu);\n\t\tusbip_event_add(ud, VDEV_EVENT_ERROR_TCP);\n\t\tbreak;\n\t}\n}\n\nint vhci_rx_loop(void *data)\n{\n\tstruct usbip_device *ud = data;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (usbip_event_happened(ud))\n\t\t\tbreak;\n\n\t\tusbip_kcov_remote_start(ud);\n\t\tvhci_rx_pdu(ud);\n\t\tusbip_kcov_remote_stop();\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}