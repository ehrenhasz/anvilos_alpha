{
  "module_name": "vhci_sysfs.c",
  "hash_id": "66a494a1fe305cc62f4211546525831aa3c9538cc7e2d9f6f26d4d6508802bea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vhci_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n \n#include <linux/nospec.h>\n\n#include \"usbip_common.h\"\n#include \"vhci.h\"\n\n \n\n \nstatic void port_show_vhci(char **out, int hub, int port, struct vhci_device *vdev)\n{\n\tif (hub == HUB_SPEED_HIGH)\n\t\t*out += sprintf(*out, \"hs  %04u %03u \",\n\t\t\t\t      port, vdev->ud.status);\n\telse  \n\t\t*out += sprintf(*out, \"ss  %04u %03u \",\n\t\t\t\t      port, vdev->ud.status);\n\n\tif (vdev->ud.status == VDEV_ST_USED) {\n\t\t*out += sprintf(*out, \"%03u %08x \",\n\t\t\t\t      vdev->speed, vdev->devid);\n\t\t*out += sprintf(*out, \"%06u %s\",\n\t\t\t\t      vdev->ud.sockfd,\n\t\t\t\t      dev_name(&vdev->udev->dev));\n\n\t} else {\n\t\t*out += sprintf(*out, \"000 00000000 \");\n\t\t*out += sprintf(*out, \"000000 0-0\");\n\t}\n\n\t*out += sprintf(*out, \"\\n\");\n}\n\n \nstatic ssize_t status_show_vhci(int pdev_nr, char *out)\n{\n\tstruct platform_device *pdev = vhcis[pdev_nr].pdev;\n\tstruct vhci *vhci;\n\tstruct usb_hcd *hcd;\n\tstruct vhci_hcd *vhci_hcd;\n\tchar *s = out;\n\tint i;\n\tunsigned long flags;\n\n\tif (!pdev || !out) {\n\t\tusbip_dbg_vhci_sysfs(\"show status error\\n\");\n\t\treturn 0;\n\t}\n\n\thcd = platform_get_drvdata(pdev);\n\tvhci_hcd = hcd_to_vhci_hcd(hcd);\n\tvhci = vhci_hcd->vhci;\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tfor (i = 0; i < VHCI_HC_PORTS; i++) {\n\t\tstruct vhci_device *vdev = &vhci->vhci_hcd_hs->vdev[i];\n\n\t\tspin_lock(&vdev->ud.lock);\n\t\tport_show_vhci(&out, HUB_SPEED_HIGH,\n\t\t\t       pdev_nr * VHCI_PORTS + i, vdev);\n\t\tspin_unlock(&vdev->ud.lock);\n\t}\n\n\tfor (i = 0; i < VHCI_HC_PORTS; i++) {\n\t\tstruct vhci_device *vdev = &vhci->vhci_hcd_ss->vdev[i];\n\n\t\tspin_lock(&vdev->ud.lock);\n\t\tport_show_vhci(&out, HUB_SPEED_SUPER,\n\t\t\t       pdev_nr * VHCI_PORTS + VHCI_HC_PORTS + i, vdev);\n\t\tspin_unlock(&vdev->ud.lock);\n\t}\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\treturn out - s;\n}\n\nstatic ssize_t status_show_not_ready(int pdev_nr, char *out)\n{\n\tchar *s = out;\n\tint i = 0;\n\n\tfor (i = 0; i < VHCI_HC_PORTS; i++) {\n\t\tout += sprintf(out, \"hs  %04u %03u \",\n\t\t\t\t    (pdev_nr * VHCI_PORTS) + i,\n\t\t\t\t    VDEV_ST_NOTASSIGNED);\n\t\tout += sprintf(out, \"000 00000000 0000000000000000 0-0\");\n\t\tout += sprintf(out, \"\\n\");\n\t}\n\n\tfor (i = 0; i < VHCI_HC_PORTS; i++) {\n\t\tout += sprintf(out, \"ss  %04u %03u \",\n\t\t\t\t    (pdev_nr * VHCI_PORTS) + VHCI_HC_PORTS + i,\n\t\t\t\t    VDEV_ST_NOTASSIGNED);\n\t\tout += sprintf(out, \"000 00000000 0000000000000000 0-0\");\n\t\tout += sprintf(out, \"\\n\");\n\t}\n\treturn out - s;\n}\n\nstatic int status_name_to_id(const char *name)\n{\n\tchar *c;\n\tlong val;\n\tint ret;\n\n\tc = strchr(name, '.');\n\tif (c == NULL)\n\t\treturn 0;\n\n\tret = kstrtol(c+1, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic ssize_t status_show(struct device *dev,\n\t\t\t   struct device_attribute *attr, char *out)\n{\n\tchar *s = out;\n\tint pdev_nr;\n\n\tout += sprintf(out,\n\t\t       \"hub port sta spd dev      sockfd local_busid\\n\");\n\n\tpdev_nr = status_name_to_id(attr->attr.name);\n\tif (pdev_nr < 0)\n\t\tout += status_show_not_ready(pdev_nr, out);\n\telse\n\t\tout += status_show_vhci(pdev_nr, out);\n\n\treturn out - s;\n}\n\nstatic ssize_t nports_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *out)\n{\n\tchar *s = out;\n\n\t \n\tout += sprintf(out, \"%d\\n\", VHCI_PORTS * vhci_num_controllers);\n\treturn out - s;\n}\nstatic DEVICE_ATTR_RO(nports);\n\n \nstatic int vhci_port_disconnect(struct vhci_hcd *vhci_hcd, __u32 rhport)\n{\n\tstruct vhci_device *vdev = &vhci_hcd->vdev[rhport];\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tunsigned long flags;\n\n\tusbip_dbg_vhci_sysfs(\"enter\\n\");\n\n\tmutex_lock(&vdev->ud.sysfs_lock);\n\n\t \n\tspin_lock_irqsave(&vhci->lock, flags);\n\tspin_lock(&vdev->ud.lock);\n\n\tif (vdev->ud.status == VDEV_ST_NULL) {\n\t\tpr_err(\"not connected %d\\n\", vdev->ud.status);\n\n\t\t \n\t\tspin_unlock(&vdev->ud.lock);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\tmutex_unlock(&vdev->ud.sysfs_lock);\n\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tspin_unlock(&vdev->ud.lock);\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tusbip_event_add(&vdev->ud, VDEV_EVENT_DOWN);\n\n\tmutex_unlock(&vdev->ud.sysfs_lock);\n\n\treturn 0;\n}\n\nstatic int valid_port(__u32 *pdev_nr, __u32 *rhport)\n{\n\tif (*pdev_nr >= vhci_num_controllers) {\n\t\tpr_err(\"pdev %u\\n\", *pdev_nr);\n\t\treturn 0;\n\t}\n\t*pdev_nr = array_index_nospec(*pdev_nr, vhci_num_controllers);\n\n\tif (*rhport >= VHCI_HC_PORTS) {\n\t\tpr_err(\"rhport %u\\n\", *rhport);\n\t\treturn 0;\n\t}\n\t*rhport = array_index_nospec(*rhport, VHCI_HC_PORTS);\n\n\treturn 1;\n}\n\nstatic ssize_t detach_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\t__u32 port = 0, pdev_nr = 0, rhport = 0;\n\tstruct usb_hcd *hcd;\n\tstruct vhci_hcd *vhci_hcd;\n\tint ret;\n\n\tif (kstrtoint(buf, 10, &port) < 0)\n\t\treturn -EINVAL;\n\n\tpdev_nr = port_to_pdev_nr(port);\n\trhport = port_to_rhport(port);\n\n\tif (!valid_port(&pdev_nr, &rhport))\n\t\treturn -EINVAL;\n\n\thcd = platform_get_drvdata(vhcis[pdev_nr].pdev);\n\tif (hcd == NULL) {\n\t\tdev_err(dev, \"port is not ready %u\\n\", port);\n\t\treturn -EAGAIN;\n\t}\n\n\tusbip_dbg_vhci_sysfs(\"rhport %d\\n\", rhport);\n\n\tif ((port / VHCI_HC_PORTS) % 2)\n\t\tvhci_hcd = hcd_to_vhci_hcd(hcd)->vhci->vhci_hcd_ss;\n\telse\n\t\tvhci_hcd = hcd_to_vhci_hcd(hcd)->vhci->vhci_hcd_hs;\n\n\tret = vhci_port_disconnect(vhci_hcd, rhport);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tusbip_dbg_vhci_sysfs(\"Leave\\n\");\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(detach);\n\nstatic int valid_args(__u32 *pdev_nr, __u32 *rhport,\n\t\t      enum usb_device_speed speed)\n{\n\tif (!valid_port(pdev_nr, rhport)) {\n\t\treturn 0;\n\t}\n\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\tcase USB_SPEED_FULL:\n\tcase USB_SPEED_HIGH:\n\tcase USB_SPEED_WIRELESS:\n\tcase USB_SPEED_SUPER:\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Failed attach request for unsupported USB speed: %s\\n\",\n\t\t\tusb_speed_string(speed));\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \n \nstatic ssize_t attach_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct socket *socket;\n\tint sockfd = 0;\n\t__u32 port = 0, pdev_nr = 0, rhport = 0, devid = 0, speed = 0;\n\tstruct usb_hcd *hcd;\n\tstruct vhci_hcd *vhci_hcd;\n\tstruct vhci_device *vdev;\n\tstruct vhci *vhci;\n\tint err;\n\tunsigned long flags;\n\tstruct task_struct *tcp_rx = NULL;\n\tstruct task_struct *tcp_tx = NULL;\n\n\t \n\tif (sscanf(buf, \"%u %u %u %u\", &port, &sockfd, &devid, &speed) != 4)\n\t\treturn -EINVAL;\n\tpdev_nr = port_to_pdev_nr(port);\n\trhport = port_to_rhport(port);\n\n\tusbip_dbg_vhci_sysfs(\"port(%u) pdev(%d) rhport(%u)\\n\",\n\t\t\t     port, pdev_nr, rhport);\n\tusbip_dbg_vhci_sysfs(\"sockfd(%u) devid(%u) speed(%u)\\n\",\n\t\t\t     sockfd, devid, speed);\n\n\t \n\tif (!valid_args(&pdev_nr, &rhport, speed))\n\t\treturn -EINVAL;\n\n\thcd = platform_get_drvdata(vhcis[pdev_nr].pdev);\n\tif (hcd == NULL) {\n\t\tdev_err(dev, \"port %d is not ready\\n\", port);\n\t\treturn -EAGAIN;\n\t}\n\n\tvhci_hcd = hcd_to_vhci_hcd(hcd);\n\tvhci = vhci_hcd->vhci;\n\n\tif (speed == USB_SPEED_SUPER)\n\t\tvdev = &vhci->vhci_hcd_ss->vdev[rhport];\n\telse\n\t\tvdev = &vhci->vhci_hcd_hs->vdev[rhport];\n\n\tmutex_lock(&vdev->ud.sysfs_lock);\n\n\t \n\tsocket = sockfd_lookup(sockfd, &err);\n\tif (!socket) {\n\t\tdev_err(dev, \"failed to lookup sock\");\n\t\terr = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\tif (socket->type != SOCK_STREAM) {\n\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n\t\t\tsocket->type);\n\t\tsockfd_put(socket);\n\t\terr = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\t \n\ttcp_rx = kthread_create(vhci_rx_loop, &vdev->ud, \"vhci_rx\");\n\tif (IS_ERR(tcp_rx)) {\n\t\tsockfd_put(socket);\n\t\terr = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\ttcp_tx = kthread_create(vhci_tx_loop, &vdev->ud, \"vhci_tx\");\n\tif (IS_ERR(tcp_tx)) {\n\t\tkthread_stop(tcp_rx);\n\t\tsockfd_put(socket);\n\t\terr = -EINVAL;\n\t\tgoto unlock_mutex;\n\t}\n\n\t \n\tget_task_struct(tcp_rx);\n\tget_task_struct(tcp_tx);\n\n\t \n\tspin_lock_irqsave(&vhci->lock, flags);\n\tspin_lock(&vdev->ud.lock);\n\n\tif (vdev->ud.status != VDEV_ST_NULL) {\n\t\t \n\t\tspin_unlock(&vdev->ud.lock);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\t\tsockfd_put(socket);\n\t\tkthread_stop_put(tcp_rx);\n\t\tkthread_stop_put(tcp_tx);\n\n\t\tdev_err(dev, \"port %d already used\\n\", rhport);\n\t\t \n\t\terr = -EBUSY;\n\t\tgoto unlock_mutex;\n\t}\n\n\tdev_info(dev, \"pdev(%u) rhport(%u) sockfd(%d)\\n\",\n\t\t pdev_nr, rhport, sockfd);\n\tdev_info(dev, \"devid(%u) speed(%u) speed_str(%s)\\n\",\n\t\t devid, speed, usb_speed_string(speed));\n\n\tvdev->devid         = devid;\n\tvdev->speed         = speed;\n\tvdev->ud.sockfd     = sockfd;\n\tvdev->ud.tcp_socket = socket;\n\tvdev->ud.tcp_rx     = tcp_rx;\n\tvdev->ud.tcp_tx     = tcp_tx;\n\tvdev->ud.status     = VDEV_ST_NOTASSIGNED;\n\tusbip_kcov_handle_init(&vdev->ud);\n\n\tspin_unlock(&vdev->ud.lock);\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t \n\n\twake_up_process(vdev->ud.tcp_rx);\n\twake_up_process(vdev->ud.tcp_tx);\n\n\trh_port_connect(vdev, speed);\n\n\tdev_info(dev, \"Device attached\\n\");\n\n\tmutex_unlock(&vdev->ud.sysfs_lock);\n\n\treturn count;\n\nunlock_mutex:\n\tmutex_unlock(&vdev->ud.sysfs_lock);\n\treturn err;\n}\nstatic DEVICE_ATTR_WO(attach);\n\n#define MAX_STATUS_NAME 16\n\nstruct status_attr {\n\tstruct device_attribute attr;\n\tchar name[MAX_STATUS_NAME+1];\n};\n\nstatic struct status_attr *status_attrs;\n\nstatic void set_status_attr(int id)\n{\n\tstruct status_attr *status;\n\n\tstatus = status_attrs + id;\n\tif (id == 0)\n\t\tstrcpy(status->name, \"status\");\n\telse\n\t\tsnprintf(status->name, MAX_STATUS_NAME+1, \"status.%d\", id);\n\tstatus->attr.attr.name = status->name;\n\tstatus->attr.attr.mode = S_IRUGO;\n\tstatus->attr.show = status_show;\n\tsysfs_attr_init(&status->attr.attr);\n}\n\nstatic int init_status_attrs(void)\n{\n\tint id;\n\n\tstatus_attrs = kcalloc(vhci_num_controllers, sizeof(struct status_attr),\n\t\t\t       GFP_KERNEL);\n\tif (status_attrs == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (id = 0; id < vhci_num_controllers; id++)\n\t\tset_status_attr(id);\n\n\treturn 0;\n}\n\nstatic void finish_status_attrs(void)\n{\n\tkfree(status_attrs);\n}\n\nstruct attribute_group vhci_attr_group = {\n\t.attrs = NULL,\n};\n\nint vhci_init_attr_group(void)\n{\n\tstruct attribute **attrs;\n\tint ret, i;\n\n\tattrs = kcalloc((vhci_num_controllers + 5), sizeof(struct attribute *),\n\t\t\tGFP_KERNEL);\n\tif (attrs == NULL)\n\t\treturn -ENOMEM;\n\n\tret = init_status_attrs();\n\tif (ret) {\n\t\tkfree(attrs);\n\t\treturn ret;\n\t}\n\t*attrs = &dev_attr_nports.attr;\n\t*(attrs + 1) = &dev_attr_detach.attr;\n\t*(attrs + 2) = &dev_attr_attach.attr;\n\t*(attrs + 3) = &dev_attr_usbip_debug.attr;\n\tfor (i = 0; i < vhci_num_controllers; i++)\n\t\t*(attrs + i + 4) = &((status_attrs + i)->attr.attr);\n\tvhci_attr_group.attrs = attrs;\n\treturn 0;\n}\n\nvoid vhci_finish_attr_group(void)\n{\n\tfinish_status_attrs();\n\tkfree(vhci_attr_group.attrs);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}