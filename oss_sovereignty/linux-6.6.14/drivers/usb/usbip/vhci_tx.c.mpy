{
  "module_name": "vhci_tx.c",
  "hash_id": "8532d3c8682f267a2e9b99e10c0c6344b5e48e960d617c1a28f78cb74ee68cfb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vhci_tx.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/slab.h>\n#include <linux/scatterlist.h>\n\n#include \"usbip_common.h\"\n#include \"vhci.h\"\n\nstatic void setup_cmd_submit_pdu(struct usbip_header *pdup,  struct urb *urb)\n{\n\tstruct vhci_priv *priv = ((struct vhci_priv *)urb->hcpriv);\n\tstruct vhci_device *vdev = priv->vdev;\n\n\tusbip_dbg_vhci_tx(\"URB, local devnum %u, remote devid %u\\n\",\n\t\t\t  usb_pipedevice(urb->pipe), vdev->devid);\n\n\tpdup->base.command   = USBIP_CMD_SUBMIT;\n\tpdup->base.seqnum    = priv->seqnum;\n\tpdup->base.devid     = vdev->devid;\n\tpdup->base.direction = usb_pipein(urb->pipe) ?\n\t\tUSBIP_DIR_IN : USBIP_DIR_OUT;\n\tpdup->base.ep\t     = usb_pipeendpoint(urb->pipe);\n\n\tusbip_pack_pdu(pdup, urb, USBIP_CMD_SUBMIT, 1);\n\n\tif (urb->setup_packet)\n\t\tmemcpy(pdup->u.cmd_submit.setup, urb->setup_packet, 8);\n}\n\nstatic struct vhci_priv *dequeue_from_priv_tx(struct vhci_device *vdev)\n{\n\tstruct vhci_priv *priv, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(priv, tmp, &vdev->priv_tx, list) {\n\t\tlist_move_tail(&priv->list, &vdev->priv_rx);\n\t\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\t\treturn priv;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\treturn NULL;\n}\n\nstatic int vhci_send_cmd_submit(struct vhci_device *vdev)\n{\n\tstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\n\tstruct vhci_priv *priv = NULL;\n\tstruct scatterlist *sg;\n\n\tstruct msghdr msg;\n\tstruct kvec *iov;\n\tsize_t txsize;\n\n\tsize_t total_size = 0;\n\tint iovnum;\n\tint err = -ENOMEM;\n\tint i;\n\n\twhile ((priv = dequeue_from_priv_tx(vdev)) != NULL) {\n\t\tint ret;\n\t\tstruct urb *urb = priv->urb;\n\t\tstruct usbip_header pdu_header;\n\n\t\ttxsize = 0;\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmemset(&iov, 0, sizeof(iov));\n\n\t\tusbip_dbg_vhci_tx(\"setup txdata urb seqnum %lu\\n\",\n\t\t\t\t  priv->seqnum);\n\n\t\tif (urb->num_sgs && usb_pipeout(urb->pipe))\n\t\t\tiovnum = 2 + urb->num_sgs;\n\t\telse\n\t\t\tiovnum = 3;\n\n\t\tiov = kcalloc(iovnum, sizeof(*iov), GFP_KERNEL);\n\t\tif (!iov) {\n\t\t\tusbip_event_add(&vdev->ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (urb->num_sgs)\n\t\t\turb->transfer_flags |= URB_DMA_MAP_SG;\n\n\t\t \n\t\tsetup_cmd_submit_pdu(&pdu_header, urb);\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\t\tiovnum = 0;\n\n\t\tiov[iovnum].iov_base = &pdu_header;\n\t\tiov[iovnum].iov_len  = sizeof(pdu_header);\n\t\ttxsize += sizeof(pdu_header);\n\t\tiovnum++;\n\n\t\t \n\t\tif (!usb_pipein(urb->pipe) && urb->transfer_buffer_length > 0) {\n\t\t\tif (urb->num_sgs &&\n\t\t\t\t      !usb_endpoint_xfer_isoc(&urb->ep->desc)) {\n\t\t\t\tfor_each_sg(urb->sg, sg, urb->num_sgs, i) {\n\t\t\t\t\tiov[iovnum].iov_base = sg_virt(sg);\n\t\t\t\t\tiov[iovnum].iov_len = sg->length;\n\t\t\t\t\tiovnum++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tiov[iovnum].iov_base = urb->transfer_buffer;\n\t\t\t\tiov[iovnum].iov_len  =\n\t\t\t\t\t\turb->transfer_buffer_length;\n\t\t\t\tiovnum++;\n\t\t\t}\n\t\t\ttxsize += urb->transfer_buffer_length;\n\t\t}\n\n\t\t \n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\tssize_t len = 0;\n\n\t\t\tiso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\n\t\t\tif (!iso_buffer) {\n\t\t\t\tusbip_event_add(&vdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_MALLOC);\n\t\t\t\tgoto err_iso_buffer;\n\t\t\t}\n\n\t\t\tiov[iovnum].iov_base = iso_buffer;\n\t\t\tiov[iovnum].iov_len  = len;\n\t\t\tiovnum++;\n\t\t\ttxsize += len;\n\t\t}\n\n\t\tret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, iov, iovnum,\n\t\t\t\t     txsize);\n\t\tif (ret != txsize) {\n\t\t\tpr_err(\"sendmsg failed!, ret=%d for %zd\\n\", ret,\n\t\t\t       txsize);\n\t\t\tusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);\n\t\t\terr = -EPIPE;\n\t\t\tgoto err_tx;\n\t\t}\n\n\t\tkfree(iov);\n\t\t \n\t\tkfree(iso_buffer);\n\t\tiso_buffer = NULL;\n\n\t\tusbip_dbg_vhci_tx(\"send txdata\\n\");\n\n\t\ttotal_size += txsize;\n\t}\n\n\treturn total_size;\n\nerr_tx:\n\tkfree(iso_buffer);\nerr_iso_buffer:\n\tkfree(iov);\n\n\treturn err;\n}\n\nstatic struct vhci_unlink *dequeue_from_unlink_tx(struct vhci_device *vdev)\n{\n\tstruct vhci_unlink *unlink, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(unlink, tmp, &vdev->unlink_tx, list) {\n\t\tlist_move_tail(&unlink->list, &vdev->unlink_rx);\n\t\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\t\treturn unlink;\n\t}\n\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n\n\treturn NULL;\n}\n\nstatic int vhci_send_cmd_unlink(struct vhci_device *vdev)\n{\n\tstruct vhci_unlink *unlink = NULL;\n\n\tstruct msghdr msg;\n\tstruct kvec iov;\n\tsize_t txsize;\n\tsize_t total_size = 0;\n\n\twhile ((unlink = dequeue_from_unlink_tx(vdev)) != NULL) {\n\t\tint ret;\n\t\tstruct usbip_header pdu_header;\n\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmemset(&iov, 0, sizeof(iov));\n\n\t\tusbip_dbg_vhci_tx(\"setup cmd unlink, %lu\\n\", unlink->seqnum);\n\n\t\t \n\t\tpdu_header.base.command = USBIP_CMD_UNLINK;\n\t\tpdu_header.base.seqnum  = unlink->seqnum;\n\t\tpdu_header.base.devid\t= vdev->devid;\n\t\tpdu_header.base.ep\t= 0;\n\t\tpdu_header.u.cmd_unlink.seqnum = unlink->unlink_seqnum;\n\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\n\t\tiov.iov_base = &pdu_header;\n\t\tiov.iov_len  = sizeof(pdu_header);\n\t\ttxsize = sizeof(pdu_header);\n\n\t\tret = kernel_sendmsg(vdev->ud.tcp_socket, &msg, &iov, 1, txsize);\n\t\tif (ret != txsize) {\n\t\t\tpr_err(\"sendmsg failed!, ret=%d for %zd\\n\", ret,\n\t\t\t       txsize);\n\t\t\tusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_TCP);\n\t\t\treturn -1;\n\t\t}\n\n\t\tusbip_dbg_vhci_tx(\"send txdata\\n\");\n\n\t\ttotal_size += txsize;\n\t}\n\n\treturn total_size;\n}\n\nint vhci_tx_loop(void *data)\n{\n\tstruct usbip_device *ud = data;\n\tstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (vhci_send_cmd_submit(vdev) < 0)\n\t\t\tbreak;\n\n\t\tif (vhci_send_cmd_unlink(vdev) < 0)\n\t\t\tbreak;\n\n\t\twait_event_interruptible(vdev->waitq_tx,\n\t\t\t\t\t (!list_empty(&vdev->priv_tx) ||\n\t\t\t\t\t  !list_empty(&vdev->unlink_tx) ||\n\t\t\t\t\t  kthread_should_stop()));\n\n\t\tusbip_dbg_vhci_tx(\"pending urbs ?, now wake up\\n\");\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}