{
  "module_name": "vudc_tx.c",
  "hash_id": "44eb0b6fb3ad9fa5ea539e3b1759e55ca4c3f3e535e4b140e40b98a17245e9d7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_tx.c",
  "human_readable_source": "\n \n\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n\n#include \"usbip_common.h\"\n#include \"vudc.h\"\n\nstatic inline void setup_base_pdu(struct usbip_header_basic *base,\n\t\t\t\t  __u32 command, __u32 seqnum)\n{\n\tbase->command\t= command;\n\tbase->seqnum\t= seqnum;\n\tbase->devid\t= 0;\n\tbase->ep\t= 0;\n\tbase->direction = 0;\n}\n\nstatic void setup_ret_submit_pdu(struct usbip_header *rpdu, struct urbp *urb_p)\n{\n\tsetup_base_pdu(&rpdu->base, USBIP_RET_SUBMIT, urb_p->seqnum);\n\tusbip_pack_pdu(rpdu, urb_p->urb, USBIP_RET_SUBMIT, 1);\n}\n\nstatic void setup_ret_unlink_pdu(struct usbip_header *rpdu,\n\t\t\t\t struct v_unlink *unlink)\n{\n\tsetup_base_pdu(&rpdu->base, USBIP_RET_UNLINK, unlink->seqnum);\n\trpdu->u.ret_unlink.status = unlink->status;\n}\n\nstatic int v_send_ret_unlink(struct vudc *udc, struct v_unlink *unlink)\n{\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tsize_t txsize;\n\n\tint ret;\n\tstruct usbip_header pdu_header;\n\n\ttxsize = 0;\n\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\tmemset(&msg, 0, sizeof(msg));\n\tmemset(&iov, 0, sizeof(iov));\n\n\t \n\tsetup_ret_unlink_pdu(&pdu_header, unlink);\n\tusbip_header_correct_endian(&pdu_header, 1);\n\n\tiov[0].iov_base = &pdu_header;\n\tiov[0].iov_len  = sizeof(pdu_header);\n\ttxsize += sizeof(pdu_header);\n\n\tret = kernel_sendmsg(udc->ud.tcp_socket, &msg, iov,\n\t\t\t     1, txsize);\n\tif (ret != txsize) {\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_TCP);\n\t\tif (ret >= 0)\n\t\t\treturn -EPIPE;\n\t\treturn ret;\n\t}\n\tkfree(unlink);\n\n\treturn txsize;\n}\n\nstatic int v_send_ret_submit(struct vudc *udc, struct urbp *urb_p)\n{\n\tstruct urb *urb = urb_p->urb;\n\tstruct usbip_header pdu_header;\n\tstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\n\tstruct kvec *iov = NULL;\n\tint iovnum = 0;\n\tint ret = 0;\n\tsize_t txsize;\n\tstruct msghdr msg;\n\n\ttxsize = 0;\n\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\tmemset(&msg, 0, sizeof(msg));\n\n\tif (urb->actual_length > 0 && !urb->transfer_buffer) {\n\t\tdev_err(&udc->gadget.dev,\n\t\t\t\"urb: actual_length %d transfer_buffer null\\n\",\n\t\t\turb->actual_length);\n\t\treturn -1;\n\t}\n\n\tif (urb_p->type == USB_ENDPOINT_XFER_ISOC)\n\t\tiovnum = 2 + urb->number_of_packets;\n\telse\n\t\tiovnum = 2;\n\n\tiov = kcalloc(iovnum, sizeof(*iov), GFP_KERNEL);\n\tif (!iov) {\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_MALLOC);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tiovnum = 0;\n\n\t \n\tsetup_ret_submit_pdu(&pdu_header, urb_p);\n\tusbip_dbg_stub_tx(\"setup txdata seqnum: %d\\n\",\n\t\t\t  pdu_header.base.seqnum);\n\tusbip_header_correct_endian(&pdu_header, 1);\n\n\tiov[iovnum].iov_base = &pdu_header;\n\tiov[iovnum].iov_len  = sizeof(pdu_header);\n\tiovnum++;\n\ttxsize += sizeof(pdu_header);\n\n\t \n\tif (urb_p->type != USB_ENDPOINT_XFER_ISOC &&\n\t    usb_pipein(urb->pipe) && urb->actual_length > 0) {\n\t\tiov[iovnum].iov_base = urb->transfer_buffer;\n\t\tiov[iovnum].iov_len  = urb->actual_length;\n\t\tiovnum++;\n\t\ttxsize += urb->actual_length;\n\t} else if (urb_p->type == USB_ENDPOINT_XFER_ISOC &&\n\t\tusb_pipein(urb->pipe)) {\n\t\t \n\t\tint i;\n\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tiov[iovnum].iov_base = urb->transfer_buffer +\n\t\t\t\turb->iso_frame_desc[i].offset;\n\t\t\tiov[iovnum].iov_len =\n\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t\t\tiovnum++;\n\t\t\ttxsize += urb->iso_frame_desc[i].actual_length;\n\t\t}\n\n\t\tif (txsize != sizeof(pdu_header) + urb->actual_length) {\n\t\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_TCP);\n\t\t\tret = -EPIPE;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t \n\n\t \n\tif (urb_p->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tssize_t len = 0;\n\n\t\tiso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\n\t\tif (!iso_buffer) {\n\t\t\tusbip_event_add(&udc->ud,\n\t\t\t\t\tVUDC_EVENT_ERROR_MALLOC);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tiov[iovnum].iov_base = iso_buffer;\n\t\tiov[iovnum].iov_len  = len;\n\t\ttxsize += len;\n\t\tiovnum++;\n\t}\n\n\tret = kernel_sendmsg(udc->ud.tcp_socket, &msg,\n\t\t\t\t\t\tiov,  iovnum, txsize);\n\tif (ret != txsize) {\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_TCP);\n\t\tif (ret >= 0)\n\t\t\tret = -EPIPE;\n\t\tgoto out;\n\t}\n\nout:\n\tkfree(iov);\n\tkfree(iso_buffer);\n\tfree_urbp_and_urb(urb_p);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn txsize;\n}\n\nstatic int v_send_ret(struct vudc *udc)\n{\n\tunsigned long flags;\n\tstruct tx_item *txi;\n\tsize_t total_size = 0;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&udc->lock_tx, flags);\n\twhile (!list_empty(&udc->tx_queue)) {\n\t\ttxi = list_first_entry(&udc->tx_queue, struct tx_item,\n\t\t\t\t       tx_entry);\n\t\tlist_del(&txi->tx_entry);\n\t\tspin_unlock_irqrestore(&udc->lock_tx, flags);\n\n\t\tswitch (txi->type) {\n\t\tcase TX_SUBMIT:\n\t\t\tret = v_send_ret_submit(udc, txi->s);\n\t\t\tbreak;\n\t\tcase TX_UNLINK:\n\t\t\tret = v_send_ret_unlink(udc, txi->u);\n\t\t\tbreak;\n\t\t}\n\t\tkfree(txi);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\ttotal_size += ret;\n\n\t\tspin_lock_irqsave(&udc->lock_tx, flags);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock_tx, flags);\n\treturn total_size;\n}\n\n\nint v_tx_loop(void *data)\n{\n\tstruct usbip_device *ud = (struct usbip_device *) data;\n\tstruct vudc *udc = container_of(ud, struct vudc, ud);\n\tint ret;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (usbip_event_happened(&udc->ud))\n\t\t\tbreak;\n\t\tret = v_send_ret(udc);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"v_tx exit with error %d\", ret);\n\t\t\tbreak;\n\t\t}\n\t\twait_event_interruptible(udc->tx_waitq,\n\t\t\t\t\t (!list_empty(&udc->tx_queue) ||\n\t\t\t\t\t kthread_should_stop()));\n\t}\n\n\treturn 0;\n}\n\n \nvoid v_enqueue_ret_unlink(struct vudc *udc, __u32 seqnum, __u32 status)\n{\n\tstruct tx_item *txi;\n\tstruct v_unlink *unlink;\n\n\ttxi = kzalloc(sizeof(*txi), GFP_ATOMIC);\n\tif (!txi) {\n\t\tusbip_event_add(&udc->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\tunlink = kzalloc(sizeof(*unlink), GFP_ATOMIC);\n\tif (!unlink) {\n\t\tkfree(txi);\n\t\tusbip_event_add(&udc->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\tunlink->seqnum = seqnum;\n\tunlink->status = status;\n\ttxi->type = TX_UNLINK;\n\ttxi->u = unlink;\n\n\tlist_add_tail(&txi->tx_entry, &udc->tx_queue);\n}\n\n \nvoid v_enqueue_ret_submit(struct vudc *udc, struct urbp *urb_p)\n{\n\tstruct tx_item *txi;\n\n\ttxi = kzalloc(sizeof(*txi), GFP_ATOMIC);\n\tif (!txi) {\n\t\tusbip_event_add(&udc->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\ttxi->type = TX_SUBMIT;\n\ttxi->s = urb_p;\n\n\tlist_add_tail(&txi->tx_entry, &udc->tx_queue);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}