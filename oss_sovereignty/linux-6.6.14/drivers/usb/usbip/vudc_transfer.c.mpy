{
  "module_name": "vudc_transfer.c",
  "hash_id": "995332688ae3c9c9ed60642b701cc5c0776e2a689ff869ead4c97ea782489548",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_transfer.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/timer.h>\n#include <linux/usb/ch9.h>\n\n#include \"vudc.h\"\n\n#define DEV_REQUEST\t(USB_TYPE_STANDARD | USB_RECIP_DEVICE)\n#define DEV_INREQUEST\t(DEV_REQUEST | USB_DIR_IN)\n#define INTF_REQUEST\t(USB_TYPE_STANDARD | USB_RECIP_INTERFACE)\n#define INTF_INREQUEST\t(INTF_REQUEST | USB_DIR_IN)\n#define EP_REQUEST\t(USB_TYPE_STANDARD | USB_RECIP_ENDPOINT)\n#define EP_INREQUEST\t(EP_REQUEST | USB_DIR_IN)\n\nstatic int get_frame_limit(enum usb_device_speed speed)\n{\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\treturn 8   * 12  ;\n\tcase USB_SPEED_FULL:\n\t\treturn 64   * 19  ;\n\tcase USB_SPEED_HIGH:\n\t\treturn 512   * 13   * 8  ;\n\tcase USB_SPEED_SUPER:\n\t\t \n\t\treturn 490000;\n\tdefault:\n\t\t \n\t\treturn -1;\n\t}\n\n}\n\n \nstatic int handle_control_request(struct vudc *udc, struct urb *urb,\n\t\t\t\t  struct usb_ctrlrequest *setup,\n\t\t\t\t  int *status)\n{\n\tstruct vep\t*ep2;\n\tint\t\tret_val = 1;\n\tunsigned int\tw_index;\n\tunsigned int\tw_value;\n\n\tw_index = le16_to_cpu(setup->wIndex);\n\tw_value = le16_to_cpu(setup->wValue);\n\tswitch (setup->bRequest) {\n\tcase USB_REQ_SET_ADDRESS:\n\t\tif (setup->bRequestType != DEV_REQUEST)\n\t\t\tbreak;\n\t\tudc->address = w_value;\n\t\tret_val = 0;\n\t\t*status = 0;\n\t\tbreak;\n\tcase USB_REQ_SET_FEATURE:\n\t\tif (setup->bRequestType == DEV_REQUEST) {\n\t\t\tret_val = 0;\n\t\t\tswitch (w_value) {\n\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_B_HNP_ENABLE:\n\t\t\t\tudc->gadget.b_hnp_enable = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_HNP_SUPPORT:\n\t\t\t\tudc->gadget.a_hnp_support = 1;\n\t\t\t\tbreak;\n\t\t\tcase USB_DEVICE_A_ALT_HNP_SUPPORT:\n\t\t\t\tudc->gadget.a_alt_hnp_support = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t}\n\t\t\tif (ret_val == 0) {\n\t\t\t\tudc->devstatus |= (1 << w_value);\n\t\t\t\t*status = 0;\n\t\t\t}\n\t\t} else if (setup->bRequestType == EP_REQUEST) {\n\t\t\t \n\t\t\tep2 = vudc_find_endpoint(udc, w_index);\n\t\t\tif (!ep2 || ep2->ep.name == udc->ep[0].ep.name) {\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tep2->halted = 1;\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_CLEAR_FEATURE:\n\t\tif (setup->bRequestType == DEV_REQUEST) {\n\t\t\tret_val = 0;\n\t\t\tswitch (w_value) {\n\t\t\tcase USB_DEVICE_REMOTE_WAKEUP:\n\t\t\t\tw_value = USB_DEVICE_REMOTE_WAKEUP;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_DEVICE_U1_ENABLE:\n\t\t\tcase USB_DEVICE_U2_ENABLE:\n\t\t\tcase USB_DEVICE_LTM_ENABLE:\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ret_val == 0) {\n\t\t\t\tudc->devstatus &= ~(1 << w_value);\n\t\t\t\t*status = 0;\n\t\t\t}\n\t\t} else if (setup->bRequestType == EP_REQUEST) {\n\t\t\t \n\t\t\tep2 = vudc_find_endpoint(udc, w_index);\n\t\t\tif (!ep2) {\n\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!ep2->wedged)\n\t\t\t\tep2->halted = 0;\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\tcase USB_REQ_GET_STATUS:\n\t\tif (setup->bRequestType == DEV_INREQUEST\n\t\t\t\t|| setup->bRequestType == INTF_INREQUEST\n\t\t\t\t|| setup->bRequestType == EP_INREQUEST) {\n\t\t\tchar *buf;\n\t\t\t \n\t\t\tbuf = (char *)urb->transfer_buffer;\n\t\t\tif (urb->transfer_buffer_length > 0) {\n\t\t\t\tif (setup->bRequestType == EP_INREQUEST) {\n\t\t\t\t\tep2 = vudc_find_endpoint(udc, w_index);\n\t\t\t\t\tif (!ep2) {\n\t\t\t\t\t\tret_val = -EOPNOTSUPP;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbuf[0] = ep2->halted;\n\t\t\t\t} else if (setup->bRequestType ==\n\t\t\t\t\t   DEV_INREQUEST) {\n\t\t\t\t\tbuf[0] = (u8)udc->devstatus;\n\t\t\t\t} else\n\t\t\t\t\tbuf[0] = 0;\n\t\t\t}\n\t\t\tif (urb->transfer_buffer_length > 1)\n\t\t\t\tbuf[1] = 0;\n\t\t\turb->actual_length = min_t(u32, 2,\n\t\t\t\turb->transfer_buffer_length);\n\t\t\tret_val = 0;\n\t\t\t*status = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn ret_val;\n}\n\n \nstatic int transfer(struct vudc *udc,\n\t\tstruct urb *urb, struct vep *ep, int limit)\n{\n\tstruct vrequest\t*req;\n\tint sent = 0;\ntop:\n\t \n\tlist_for_each_entry(req, &ep->req_queue, req_entry) {\n\t\tunsigned int\thost_len, dev_len, len;\n\t\tvoid\t\t*ubuf_pos, *rbuf_pos;\n\t\tint\t\tis_short, to_host;\n\t\tint\t\trescan = 0;\n\n\t\t \n\t\thost_len = urb->transfer_buffer_length - urb->actual_length;\n\t\tdev_len = req->req.length - req->req.actual;\n\t\tlen = min(host_len, dev_len);\n\n\t\tto_host = usb_pipein(urb->pipe);\n\t\tif (unlikely(len == 0))\n\t\t\tis_short = 1;\n\t\telse {\n\t\t\t \n\t\t\tif (len >= ep->ep.maxpacket) {\n\t\t\t\tis_short = 0;\n\t\t\t\tif (len % ep->ep.maxpacket > 0)\n\t\t\t\t\trescan = 1;\n\t\t\t\tlen -= len % ep->ep.maxpacket;\n\t\t\t} else {\n\t\t\t\tis_short = 1;\n\t\t\t}\n\n\t\t\tubuf_pos = urb->transfer_buffer + urb->actual_length;\n\t\t\trbuf_pos = req->req.buf + req->req.actual;\n\n\t\t\tif (urb->pipe & USB_DIR_IN)\n\t\t\t\tmemcpy(ubuf_pos, rbuf_pos, len);\n\t\t\telse\n\t\t\t\tmemcpy(rbuf_pos, ubuf_pos, len);\n\n\t\t\turb->actual_length += len;\n\t\t\treq->req.actual += len;\n\t\t\tsent += len;\n\t\t}\n\n\t\t \n\t\tif (is_short) {\n\t\t\tif (host_len == dev_len) {\n\t\t\t\treq->req.status = 0;\n\t\t\t\turb->status = 0;\n\t\t\t} else if (to_host) {\n\t\t\t\treq->req.status = 0;\n\t\t\t\tif (dev_len > host_len)\n\t\t\t\t\turb->status = -EOVERFLOW;\n\t\t\t\telse\n\t\t\t\t\turb->status = 0;\n\t\t\t} else {\n\t\t\t\turb->status = 0;\n\t\t\t\tif (host_len > dev_len)\n\t\t\t\t\treq->req.status = -EOVERFLOW;\n\t\t\t\telse\n\t\t\t\t\treq->req.status = 0;\n\t\t\t}\n\n\t\t \n\t\t \n\t\t} else {\n\t\t\tif (req->req.length == req->req.actual) {\n\t\t\t\tif (req->req.zero && to_host)\n\t\t\t\t\trescan = 1;\n\t\t\t\telse\n\t\t\t\t\treq->req.status = 0;\n\t\t\t}\n\t\t\tif (urb->transfer_buffer_length == urb->actual_length) {\n\t\t\t\tif (urb->transfer_flags & URB_ZERO_PACKET &&\n\t\t\t\t    !to_host)\n\t\t\t\t\trescan = 1;\n\t\t\t\telse\n\t\t\t\t\turb->status = 0;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (req->req.status != -EINPROGRESS) {\n\n\t\t\tlist_del_init(&req->req_entry);\n\t\t\tspin_unlock(&udc->lock);\n\t\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\t\tspin_lock(&udc->lock);\n\n\t\t\t \n\t\t\trescan = 1;\n\t\t}\n\n\t\t \n\t\tif (urb->status != -EINPROGRESS)\n\t\t\tbreak;\n\n\t\t \n\t\tif (rescan)\n\t\t\tgoto top;\n\t}\n\treturn sent;\n}\n\nstatic void v_timer(struct timer_list *t)\n{\n\tstruct vudc *udc = from_timer(udc, t, tr_timer.timer);\n\tstruct transfer_timer *timer = &udc->tr_timer;\n\tstruct urbp *urb_p, *tmp;\n\tunsigned long flags;\n\tstruct usb_ep *_ep;\n\tstruct vep *ep;\n\tint ret = 0;\n\tint total, limit;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\ttotal = get_frame_limit(udc->gadget.speed);\n\tif (total < 0) {\t \n\t\ttimer->state = VUDC_TR_IDLE;\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn;\n\t}\n\t \n\tif (time_after(jiffies, timer->frame_start + msecs_to_jiffies(1))) {\n\t\ttimer->frame_limit = total;\n\t\t \n\t\ttimer->frame_start = jiffies;\n\t} else {\n\t\ttotal = timer->frame_limit;\n\t}\n\n\t \n\tudc->ep[0].already_seen = 0;\n\tlist_for_each_entry(_ep, &udc->gadget.ep_list, ep_list) {\n\t\tep = to_vep(_ep);\n\t\tep->already_seen = 0;\n\t}\n\nrestart:\n\tlist_for_each_entry_safe(urb_p, tmp, &udc->urb_queue, urb_entry) {\n\t\tstruct urb *urb = urb_p->urb;\n\n\t\tep = urb_p->ep;\n\t\tif (urb->unlinked)\n\t\t\tgoto return_urb;\n\t\tif (timer->state != VUDC_TR_RUNNING)\n\t\t\tcontinue;\n\n\t\tif (!ep) {\n\t\t\turb->status = -EPROTO;\n\t\t\tgoto return_urb;\n\t\t}\n\n\t\t \n\t\tif (total <= 0 && ep->type == USB_ENDPOINT_XFER_BULK)\n\t\t\tcontinue;\n\n\t\tif (ep->already_seen)\n\t\t\tcontinue;\n\t\tep->already_seen = 1;\n\t\tif (ep == &udc->ep[0] && urb_p->new) {\n\t\t\tep->setup_stage = 1;\n\t\t\turb_p->new = 0;\n\t\t}\n\t\tif (ep->halted && !ep->setup_stage) {\n\t\t\turb->status = -EPIPE;\n\t\t\tgoto return_urb;\n\t\t}\n\n\t\tif (ep == &udc->ep[0] && ep->setup_stage) {\n\t\t\t \n\t\t\tep->setup_stage = 0;\n\t\t\tep->halted = 0;\n\n\t\t\tret = handle_control_request(udc, urb,\n\t\t\t\t(struct usb_ctrlrequest *) urb->setup_packet,\n\t\t\t\t(&urb->status));\n\t\t\tif (ret > 0) {\n\t\t\t\tspin_unlock(&udc->lock);\n\t\t\t\tret = udc->driver->setup(&udc->gadget,\n\t\t\t\t\t(struct usb_ctrlrequest *)\n\t\t\t\t\turb->setup_packet);\n\t\t\t\tspin_lock(&udc->lock);\n\t\t\t}\n\t\t\tif (ret >= 0) {\n\t\t\t\t \n\t\t\t\tlimit = 64 * 1024;\n\t\t\t\tgoto treat_control_like_bulk;\n\t\t\t} else {\n\t\t\t\turb->status = -EPIPE;\n\t\t\t\turb->actual_length = 0;\n\t\t\t\tgoto return_urb;\n\t\t\t}\n\t\t}\n\n\t\tlimit = total;\n\t\tswitch (ep->type) {\n\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t \n\t\t\turb->status = -EXDEV;\n\t\t\tbreak;\n\n\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t \n\t\t\tlimit += urb->transfer_buffer_length;\n\t\t\tfallthrough;\n\t\tdefault:\ntreat_control_like_bulk:\n\t\t\ttotal -= transfer(udc, urb, ep, limit);\n\t\t}\n\t\tif (urb->status == -EINPROGRESS)\n\t\t\tcontinue;\n\nreturn_urb:\n\t\tif (ep)\n\t\t\tep->already_seen = ep->setup_stage = 0;\n\n\t\tspin_lock(&udc->lock_tx);\n\t\tlist_del(&urb_p->urb_entry);\n\t\tif (!urb->unlinked) {\n\t\t\tv_enqueue_ret_submit(udc, urb_p);\n\t\t} else {\n\t\t\tv_enqueue_ret_unlink(udc, urb_p->seqnum,\n\t\t\t\t\t     urb->unlinked);\n\t\t\tfree_urbp_and_urb(urb_p);\n\t\t}\n\t\twake_up(&udc->tx_waitq);\n\t\tspin_unlock(&udc->lock_tx);\n\n\t\tgoto restart;\n\t}\n\n\t \n\tif (list_empty(&udc->urb_queue))\n\t\ttimer->state = VUDC_TR_IDLE;\n\telse\n\t\tmod_timer(&timer->timer,\n\t\t\t  timer->frame_start + msecs_to_jiffies(1));\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n}\n\n \n\nvoid v_init_timer(struct vudc *udc)\n{\n\tstruct transfer_timer *t = &udc->tr_timer;\n\n\ttimer_setup(&t->timer, v_timer, 0);\n\tt->state = VUDC_TR_STOPPED;\n}\n\nvoid v_start_timer(struct vudc *udc)\n{\n\tstruct transfer_timer *t = &udc->tr_timer;\n\n\tdev_dbg(&udc->pdev->dev, \"timer start\");\n\tswitch (t->state) {\n\tcase VUDC_TR_RUNNING:\n\t\treturn;\n\tcase VUDC_TR_IDLE:\n\t\treturn v_kick_timer(udc, jiffies);\n\tcase VUDC_TR_STOPPED:\n\t\tt->state = VUDC_TR_IDLE;\n\t\tt->frame_start = jiffies;\n\t\tt->frame_limit = get_frame_limit(udc->gadget.speed);\n\t\treturn v_kick_timer(udc, jiffies);\n\t}\n}\n\nvoid v_kick_timer(struct vudc *udc, unsigned long time)\n{\n\tstruct transfer_timer *t = &udc->tr_timer;\n\n\tdev_dbg(&udc->pdev->dev, \"timer kick\");\n\tswitch (t->state) {\n\tcase VUDC_TR_RUNNING:\n\t\treturn;\n\tcase VUDC_TR_IDLE:\n\t\tt->state = VUDC_TR_RUNNING;\n\t\tfallthrough;\n\tcase VUDC_TR_STOPPED:\n\t\t \n\t\tmod_timer(&t->timer, time);\n\t}\n}\n\nvoid v_stop_timer(struct vudc *udc)\n{\n\tstruct transfer_timer *t = &udc->tr_timer;\n\n\t \n\tdev_dbg(&udc->pdev->dev, \"timer stop\");\n\tt->state = VUDC_TR_STOPPED;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}