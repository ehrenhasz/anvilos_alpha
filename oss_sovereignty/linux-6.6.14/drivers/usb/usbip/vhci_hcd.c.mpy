{
  "module_name": "vhci_hcd.c",
  "hash_id": "181f6eba15489af4fc630a6775bf68acdff12c4dbf1a7f68c8ec2a9cc5eac260",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vhci_hcd.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/file.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include \"usbip_common.h\"\n#include \"vhci.h\"\n\n#define DRIVER_AUTHOR \"Takahiro Hirofuchi\"\n#define DRIVER_DESC \"USB/IP 'Virtual' Host Controller (VHCI) Driver\"\n\n \n\n \n\nstatic int vhci_hub_status(struct usb_hcd *hcd, char *buff);\nstatic int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t    u16 wIndex, char *buff, u16 wLength);\nstatic int vhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t    gfp_t mem_flags);\nstatic int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status);\nstatic int vhci_start(struct usb_hcd *vhci_hcd);\nstatic void vhci_stop(struct usb_hcd *hcd);\nstatic int vhci_get_frame_number(struct usb_hcd *hcd);\n\nstatic const char driver_name[] = \"vhci_hcd\";\nstatic const char driver_desc[] = \"USB/IP Virtual Host Controller\";\n\nint vhci_num_controllers = VHCI_NR_HCS;\nstruct vhci *vhcis;\n\nstatic const char * const bit_desc[] = {\n\t\"CONNECTION\",\t\t \n\t\"ENABLE\",\t\t \n\t\"SUSPEND\",\t\t \n\t\"OVER_CURRENT\",\t\t \n\t\"RESET\",\t\t \n\t\"L1\",\t\t\t \n\t\"R6\",\t\t\t \n\t\"R7\",\t\t\t \n\t\"POWER\",\t\t \n\t\"LOWSPEED\",\t\t \n\t\"HIGHSPEED\",\t\t \n\t\"PORT_TEST\",\t\t \n\t\"INDICATOR\",\t\t \n\t\"R13\",\t\t\t \n\t\"R14\",\t\t\t \n\t\"R15\",\t\t\t \n\t\"C_CONNECTION\",\t\t \n\t\"C_ENABLE\",\t\t \n\t\"C_SUSPEND\",\t\t \n\t\"C_OVER_CURRENT\",\t \n\t\"C_RESET\",\t\t \n\t\"C_L1\",\t\t\t \n\t\"R22\",\t\t\t \n\t\"R23\",\t\t\t \n\t\"R24\",\t\t\t \n\t\"R25\",\t\t\t \n\t\"R26\",\t\t\t \n\t\"R27\",\t\t\t \n\t\"R28\",\t\t\t \n\t\"R29\",\t\t\t \n\t\"R30\",\t\t\t \n\t\"R31\",\t\t\t \n};\n\nstatic const char * const bit_desc_ss[] = {\n\t\"CONNECTION\",\t\t \n\t\"ENABLE\",\t\t \n\t\"SUSPEND\",\t\t \n\t\"OVER_CURRENT\",\t\t \n\t\"RESET\",\t\t \n\t\"L1\",\t\t\t \n\t\"R6\",\t\t\t \n\t\"R7\",\t\t\t \n\t\"R8\",\t\t\t \n\t\"POWER\",\t\t \n\t\"HIGHSPEED\",\t\t \n\t\"PORT_TEST\",\t\t \n\t\"INDICATOR\",\t\t \n\t\"R13\",\t\t\t \n\t\"R14\",\t\t\t \n\t\"R15\",\t\t\t \n\t\"C_CONNECTION\",\t\t \n\t\"C_ENABLE\",\t\t \n\t\"C_SUSPEND\",\t\t \n\t\"C_OVER_CURRENT\",\t \n\t\"C_RESET\",\t\t \n\t\"C_BH_RESET\",\t\t \n\t\"C_LINK_STATE\",\t\t \n\t\"C_CONFIG_ERROR\",\t \n\t\"R24\",\t\t\t \n\t\"R25\",\t\t\t \n\t\"R26\",\t\t\t \n\t\"R27\",\t\t\t \n\t\"R28\",\t\t\t \n\t\"R29\",\t\t\t \n\t\"R30\",\t\t\t \n\t\"R31\",\t\t\t \n};\n\nstatic void dump_port_status_diff(u32 prev_status, u32 new_status, bool usb3)\n{\n\tint i = 0;\n\tu32 bit = 1;\n\tconst char * const *desc = bit_desc;\n\n\tif (usb3)\n\t\tdesc = bit_desc_ss;\n\n\tpr_debug(\"status prev -> new: %08x -> %08x\\n\", prev_status, new_status);\n\twhile (bit) {\n\t\tu32 prev = prev_status & bit;\n\t\tu32 new = new_status & bit;\n\t\tchar change;\n\n\t\tif (!prev && new)\n\t\t\tchange = '+';\n\t\telse if (prev && !new)\n\t\t\tchange = '-';\n\t\telse\n\t\t\tchange = ' ';\n\n\t\tif (prev || new) {\n\t\t\tpr_debug(\" %c%s\\n\", change, desc[i]);\n\n\t\t\tif (bit == 1)  \n\t\t\t\tpr_debug(\" %c%s\\n\", change, \"USB_PORT_STAT_SPEED_5GBPS\");\n\t\t}\n\t\tbit <<= 1;\n\t\ti++;\n\t}\n\tpr_debug(\"\\n\");\n}\n\nvoid rh_port_connect(struct vhci_device *vdev, enum usb_device_speed speed)\n{\n\tstruct vhci_hcd\t*vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tint\t\trhport = vdev->rhport;\n\tu32\t\tstatus;\n\tunsigned long\tflags;\n\n\tusbip_dbg_vhci_rh(\"rh_port_connect %d\\n\", rhport);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tstatus = vhci_hcd->port_status[rhport];\n\n\tstatus |= USB_PORT_STAT_CONNECTION | (1 << USB_PORT_FEAT_C_CONNECTION);\n\n\tswitch (speed) {\n\tcase USB_SPEED_HIGH:\n\t\tstatus |= USB_PORT_STAT_HIGH_SPEED;\n\t\tbreak;\n\tcase USB_SPEED_LOW:\n\t\tstatus |= USB_PORT_STAT_LOW_SPEED;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tvhci_hcd->port_status[rhport] = status;\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tusb_hcd_poll_rh_status(vhci_hcd_to_hcd(vhci_hcd));\n}\n\nstatic void rh_port_disconnect(struct vhci_device *vdev)\n{\n\tstruct vhci_hcd\t*vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tint\t\trhport = vdev->rhport;\n\tu32\t\tstatus;\n\tunsigned long\tflags;\n\n\tusbip_dbg_vhci_rh(\"rh_port_disconnect %d\\n\", rhport);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tstatus = vhci_hcd->port_status[rhport];\n\n\tstatus &= ~USB_PORT_STAT_CONNECTION;\n\tstatus |= (1 << USB_PORT_FEAT_C_CONNECTION);\n\n\tvhci_hcd->port_status[rhport] = status;\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\tusb_hcd_poll_rh_status(vhci_hcd_to_hcd(vhci_hcd));\n}\n\n#define PORT_C_MASK\t\t\t\t\\\n\t((USB_PORT_STAT_C_CONNECTION\t\t\\\n\t  | USB_PORT_STAT_C_ENABLE\t\t\\\n\t  | USB_PORT_STAT_C_SUSPEND\t\t\\\n\t  | USB_PORT_STAT_C_OVERCURRENT\t\t\\\n\t  | USB_PORT_STAT_C_RESET) << 16)\n\n \nstatic int vhci_hub_status(struct usb_hcd *hcd, char *buf)\n{\n\tstruct vhci_hcd\t*vhci_hcd = hcd_to_vhci_hcd(hcd);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tint\t\tretval = DIV_ROUND_UP(VHCI_HC_PORTS + 1, 8);\n\tint\t\trhport;\n\tint\t\tchanged = 0;\n\tunsigned long\tflags;\n\n\tmemset(buf, 0, retval);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tusbip_dbg_vhci_rh(\"hw accessible flag not on?\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tfor (rhport = 0; rhport < VHCI_HC_PORTS; rhport++) {\n\t\tif ((vhci_hcd->port_status[rhport] & PORT_C_MASK)) {\n\t\t\t \n\t\t\tusbip_dbg_vhci_rh(\"port %d status changed\\n\", rhport);\n\n\t\t\tbuf[(rhport + 1) / 8] |= 1 << (rhport + 1) % 8;\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tif ((hcd->state == HC_STATE_SUSPENDED) && (changed == 1))\n\t\tusb_hcd_resume_root_hub(hcd);\n\ndone:\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\treturn changed ? retval : 0;\n}\n\n \nstatic struct {\n\tstruct usb_bos_descriptor bos;\n\tstruct usb_ss_cap_descriptor ss_cap;\n} __packed usb3_bos_desc = {\n\n\t.bos = {\n\t\t.bLength\t\t= USB_DT_BOS_SIZE,\n\t\t.bDescriptorType\t= USB_DT_BOS,\n\t\t.wTotalLength\t\t= cpu_to_le16(sizeof(usb3_bos_desc)),\n\t\t.bNumDeviceCaps\t\t= 1,\n\t},\n\t.ss_cap = {\n\t\t.bLength\t\t= USB_DT_USB_SS_CAP_SIZE,\n\t\t.bDescriptorType\t= USB_DT_DEVICE_CAPABILITY,\n\t\t.bDevCapabilityType\t= USB_SS_CAP_TYPE,\n\t\t.wSpeedSupported\t= cpu_to_le16(USB_5GBPS_OPERATION),\n\t\t.bFunctionalitySupport\t= ilog2(USB_5GBPS_OPERATION),\n\t},\n};\n\nstatic inline void\nss_hub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof *desc);\n\tdesc->bDescriptorType = USB_DT_SS_HUB;\n\tdesc->bDescLength = 12;\n\tdesc->wHubCharacteristics = cpu_to_le16(\n\t\tHUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = VHCI_HC_PORTS;\n\tdesc->u.ss.bHubHdrDecLat = 0x04;  \n\tdesc->u.ss.DeviceRemovable = 0xffff;\n}\n\nstatic inline void hub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tint width;\n\n\tmemset(desc, 0, sizeof(*desc));\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->wHubCharacteristics = cpu_to_le16(\n\t\tHUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_COMMON_OCPM);\n\n\tdesc->bNbrPorts = VHCI_HC_PORTS;\n\tBUILD_BUG_ON(VHCI_HC_PORTS > USB_MAXCHILDREN);\n\twidth = desc->bNbrPorts / 8 + 1;\n\tdesc->bDescLength = USB_DT_HUB_NONVAR_SIZE + 2 * width;\n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, width);\n\tmemset(&desc->u.hs.DeviceRemovable[width], 0xff, width);\n}\n\nstatic int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t    u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct vhci_hcd\t*vhci_hcd;\n\tstruct vhci\t*vhci;\n\tint             retval = 0;\n\tint\t\trhport = -1;\n\tunsigned long\tflags;\n\tbool invalid_rhport = false;\n\n\tu32 prev_port_status[VHCI_HC_PORTS];\n\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\treturn -ETIMEDOUT;\n\n\t \n\twIndex = ((__u8)(wIndex & 0x00ff));\n\tusbip_dbg_vhci_rh(\"typeReq %x wValue %x wIndex %x\\n\", typeReq, wValue,\n\t\t\t  wIndex);\n\n\t \n\tif (wIndex < 1 || wIndex > VHCI_HC_PORTS) {\n\t\tinvalid_rhport = true;\n\t\tif (wIndex > VHCI_HC_PORTS)\n\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t} else\n\t\trhport = wIndex - 1;\n\n\tvhci_hcd = hcd_to_vhci_hcd(hcd);\n\tvhci = vhci_hcd->vhci;\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\t \n\tif (usbip_dbg_flag_vhci_rh) {\n\t\tif (!invalid_rhport)\n\t\t\tmemcpy(prev_port_status, vhci_hcd->port_status,\n\t\t\t\tsizeof(prev_port_status));\n\t}\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tusbip_dbg_vhci_rh(\" ClearHubFeature\\n\");\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (invalid_rhport) {\n\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\tgoto error;\n\t\t}\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tpr_err(\" ClearPortFeature: USB_PORT_FEAT_SUSPEND req not \"\n\t\t\t\t       \"supported for USB 3.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" ClearPortFeature: USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\tif (vhci_hcd->port_status[rhport] & USB_PORT_STAT_SUSPEND) {\n\t\t\t\t \n\t\t\t\tvhci_hcd->resuming = 1;\n\t\t\t\tvhci_hcd->re_timeout = jiffies + msecs_to_jiffies(20);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" ClearPortFeature: USB_PORT_FEAT_POWER\\n\");\n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tvhci_hcd->port_status[rhport] &= ~USB_SS_PORT_STAT_POWER;\n\t\t\telse\n\t\t\t\tvhci_hcd->port_status[rhport] &= ~USB_PORT_STAT_POWER;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusbip_dbg_vhci_rh(\" ClearPortFeature: default %x\\n\",\n\t\t\t\t\t  wValue);\n\t\t\tif (wValue >= 32)\n\t\t\t\tgoto error;\n\t\t\tvhci_hcd->port_status[rhport] &= ~(1 << wValue);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tusbip_dbg_vhci_rh(\" GetHubDescriptor\\n\");\n\t\tif (hcd->speed == HCD_USB3 &&\n\t\t\t\t(wLength < USB_DT_SS_HUB_SIZE ||\n\t\t\t\t wValue != (USB_DT_SS_HUB << 8))) {\n\t\t\tpr_err(\"Wrong hub descriptor type for USB 3.0 roothub.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tif (hcd->speed == HCD_USB3)\n\t\t\tss_hub_descriptor((struct usb_hub_descriptor *) buf);\n\t\telse\n\t\t\thub_descriptor((struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\tif (hcd->speed != HCD_USB3)\n\t\t\tgoto error;\n\n\t\tif ((wValue >> 8) != USB_DT_BOS)\n\t\t\tgoto error;\n\n\t\tmemcpy(buf, &usb3_bos_desc, sizeof(usb3_bos_desc));\n\t\tretval = sizeof(usb3_bos_desc);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\tusbip_dbg_vhci_rh(\" GetHubStatus\\n\");\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tusbip_dbg_vhci_rh(\" GetPortStatus port %x\\n\", wIndex);\n\t\tif (invalid_rhport) {\n\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\tretval = -EPIPE;\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\n\t\t \n\t\tif (vhci_hcd->resuming && time_after(jiffies, vhci_hcd->re_timeout)) {\n\t\t\tvhci_hcd->port_status[rhport] |= (1 << USB_PORT_FEAT_C_SUSPEND);\n\t\t\tvhci_hcd->port_status[rhport] &= ~(1 << USB_PORT_FEAT_SUSPEND);\n\t\t\tvhci_hcd->resuming = 0;\n\t\t\tvhci_hcd->re_timeout = 0;\n\t\t}\n\n\t\tif ((vhci_hcd->port_status[rhport] & (1 << USB_PORT_FEAT_RESET)) !=\n\t\t    0 && time_after(jiffies, vhci_hcd->re_timeout)) {\n\t\t\tvhci_hcd->port_status[rhport] |= (1 << USB_PORT_FEAT_C_RESET);\n\t\t\tvhci_hcd->port_status[rhport] &= ~(1 << USB_PORT_FEAT_RESET);\n\t\t\tvhci_hcd->re_timeout = 0;\n\n\t\t\t \n\t\t\tif (vhci_hcd->vdev[rhport].ud.status ==\n\t\t\t\tVDEV_ST_NOTASSIGNED ||\n\t\t\t    vhci_hcd->vdev[rhport].ud.status ==\n\t\t\t\tVDEV_ST_USED) {\n\t\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\t\" enable rhport %d (status %u)\\n\",\n\t\t\t\t\trhport,\n\t\t\t\t\tvhci_hcd->vdev[rhport].ud.status);\n\t\t\t\tvhci_hcd->port_status[rhport] |=\n\t\t\t\t\tUSB_PORT_STAT_ENABLE;\n\t\t\t}\n\n\t\t\tif (hcd->speed < HCD_USB3) {\n\t\t\t\tswitch (vhci_hcd->vdev[rhport].speed) {\n\t\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\t\tvhci_hcd->port_status[rhport] |=\n\t\t\t\t\t      USB_PORT_STAT_HIGH_SPEED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase USB_SPEED_LOW:\n\t\t\t\t\tvhci_hcd->port_status[rhport] |=\n\t\t\t\t\t\tUSB_PORT_STAT_LOW_SPEED;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tpr_err(\"vhci_device speed not set\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t((__le16 *) buf)[0] = cpu_to_le16(vhci_hcd->port_status[rhport]);\n\t\t((__le16 *) buf)[1] =\n\t\t\tcpu_to_le16(vhci_hcd->port_status[rhport] >> 16);\n\n\t\tusbip_dbg_vhci_rh(\" GetPortStatus bye %x %x\\n\", ((u16 *)buf)[0],\n\t\t\t\t  ((u16 *)buf)[1]);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tusbip_dbg_vhci_rh(\" SetHubFeature\\n\");\n\t\tretval = -EPIPE;\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_LINK_STATE\\n\");\n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tpr_err(\"USB_PORT_FEAT_LINK_STATE req not \"\n\t\t\t\t       \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_U1_TIMEOUT\\n\");\n\t\t\tfallthrough;\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_U2_TIMEOUT\\n\");\n\t\t\t \n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tpr_err(\"USB_PORT_FEAT_U1/2_TIMEOUT req not \"\n\t\t\t\t       \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tpr_err(\"USB_PORT_FEAT_SUSPEND req not \"\n\t\t\t\t       \"supported for USB 3.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tif (invalid_rhport) {\n\t\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tvhci_hcd->port_status[rhport] |= USB_PORT_STAT_SUSPEND;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_POWER\\n\");\n\t\t\tif (invalid_rhport) {\n\t\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (hcd->speed == HCD_USB3)\n\t\t\t\tvhci_hcd->port_status[rhport] |= USB_SS_PORT_STAT_POWER;\n\t\t\telse\n\t\t\t\tvhci_hcd->port_status[rhport] |= USB_PORT_STAT_POWER;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_BH_PORT_RESET\\n\");\n\t\t\tif (invalid_rhport) {\n\t\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tif (hcd->speed != HCD_USB3) {\n\t\t\t\tpr_err(\"USB_PORT_FEAT_BH_PORT_RESET req not \"\n\t\t\t\t       \"supported for USB 2.0 roothub\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tusbip_dbg_vhci_rh(\n\t\t\t\t\" SetPortFeature: USB_PORT_FEAT_RESET\\n\");\n\t\t\tif (invalid_rhport) {\n\t\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tvhci_hcd->port_status[rhport] = 0;\n\t\t\t\tvhci_hcd->port_status[rhport] =\n\t\t\t\t\t(USB_SS_PORT_STAT_POWER |\n\t\t\t\t\t USB_PORT_STAT_CONNECTION |\n\t\t\t\t\t USB_PORT_STAT_RESET);\n\t\t\t} else if (vhci_hcd->port_status[rhport] & USB_PORT_STAT_ENABLE) {\n\t\t\t\tvhci_hcd->port_status[rhport] &= ~(USB_PORT_STAT_ENABLE\n\t\t\t\t\t| USB_PORT_STAT_LOW_SPEED\n\t\t\t\t\t| USB_PORT_STAT_HIGH_SPEED);\n\t\t\t}\n\n\t\t\t \n\t\t\tvhci_hcd->re_timeout = jiffies + msecs_to_jiffies(50);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tusbip_dbg_vhci_rh(\" SetPortFeature: default %d\\n\",\n\t\t\t\t\t  wValue);\n\t\t\tif (invalid_rhport) {\n\t\t\t\tpr_err(\"invalid port number %d\\n\", wIndex);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (wValue >= 32)\n\t\t\t\tgoto error;\n\t\t\tif (hcd->speed == HCD_USB3) {\n\t\t\t\tif ((vhci_hcd->port_status[rhport] &\n\t\t\t\t     USB_SS_PORT_STAT_POWER) != 0) {\n\t\t\t\t\tvhci_hcd->port_status[rhport] |= (1 << wValue);\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tif ((vhci_hcd->port_status[rhport] &\n\t\t\t\t     USB_PORT_STAT_POWER) != 0) {\n\t\t\t\t\tvhci_hcd->port_status[rhport] |= (1 << wValue);\n\t\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase GetPortErrorCount:\n\t\tusbip_dbg_vhci_rh(\" GetPortErrorCount\\n\");\n\t\tif (hcd->speed != HCD_USB3) {\n\t\t\tpr_err(\"GetPortErrorCount req not \"\n\t\t\t       \"supported for USB 2.0 roothub\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\tcase SetHubDepth:\n\t\tusbip_dbg_vhci_rh(\" SetHubDepth\\n\");\n\t\tif (hcd->speed != HCD_USB3) {\n\t\t\tpr_err(\"SetHubDepth req not supported for \"\n\t\t\t       \"USB 2.0 roothub\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"default hub control req: %04x v%04x i%04x l%d\\n\",\n\t\t\ttypeReq, wValue, wIndex, wLength);\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\n\tif (usbip_dbg_flag_vhci_rh) {\n\t\tpr_debug(\"port %d\\n\", rhport);\n\t\t \n\t\tif (!invalid_rhport) {\n\t\t\tdump_port_status_diff(prev_port_status[rhport],\n\t\t\t\t\t      vhci_hcd->port_status[rhport],\n\t\t\t\t\t      hcd->speed == HCD_USB3);\n\t\t}\n\t}\n\tusbip_dbg_vhci_rh(\" bye\\n\");\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tif (!invalid_rhport &&\n\t    (vhci_hcd->port_status[rhport] & PORT_C_MASK) != 0) {\n\t\tusb_hcd_poll_rh_status(hcd);\n\t}\n\n\treturn retval;\n}\n\nstatic void vhci_tx_urb(struct urb *urb, struct vhci_device *vdev)\n{\n\tstruct vhci_priv *priv;\n\tstruct vhci_hcd *vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tunsigned long flags;\n\n\tpriv = kzalloc(sizeof(struct vhci_priv), GFP_ATOMIC);\n\tif (!priv) {\n\t\tusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&vdev->priv_lock, flags);\n\n\tpriv->seqnum = atomic_inc_return(&vhci_hcd->seqnum);\n\tif (priv->seqnum == 0xffff)\n\t\tdev_info(&urb->dev->dev, \"seqnum max\\n\");\n\n\tpriv->vdev = vdev;\n\tpriv->urb = urb;\n\n\turb->hcpriv = (void *) priv;\n\n\tlist_add_tail(&priv->list, &vdev->priv_tx);\n\n\twake_up(&vdev->waitq_tx);\n\tspin_unlock_irqrestore(&vdev->priv_lock, flags);\n}\n\nstatic int vhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\n{\n\tstruct vhci_hcd *vhci_hcd = hcd_to_vhci_hcd(hcd);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tstruct device *dev = &urb->dev->dev;\n\tu8 portnum = urb->dev->portnum;\n\tint ret = 0;\n\tstruct vhci_device *vdev;\n\tunsigned long flags;\n\n\tif (portnum > VHCI_HC_PORTS) {\n\t\tpr_err(\"invalid port number %d\\n\", portnum);\n\t\treturn -ENODEV;\n\t}\n\tvdev = &vhci_hcd->vdev[portnum-1];\n\n\tif (!urb->transfer_buffer && !urb->num_sgs &&\n\t     urb->transfer_buffer_length) {\n\t\tdev_dbg(dev, \"Null URB transfer buffer\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tif (urb->status != -EINPROGRESS) {\n\t\tdev_err(dev, \"URB already unlinked!, status %d\\n\", urb->status);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\treturn urb->status;\n\t}\n\n\t \n\tspin_lock(&vdev->ud.lock);\n\tif (vdev->ud.status == VDEV_ST_NULL ||\n\t    vdev->ud.status == VDEV_ST_ERROR) {\n\t\tdev_err(dev, \"enqueue for inactive port %d\\n\", vdev->rhport);\n\t\tspin_unlock(&vdev->ud.lock);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\tspin_unlock(&vdev->ud.lock);\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret)\n\t\tgoto no_need_unlink;\n\n\t \n\tif (usb_pipedevice(urb->pipe) == 0) {\n\t\t__u8 type = usb_pipetype(urb->pipe);\n\t\tstruct usb_ctrlrequest *ctrlreq =\n\t\t\t(struct usb_ctrlrequest *) urb->setup_packet;\n\n\t\tif (type != PIPE_CONTROL || !ctrlreq) {\n\t\t\tdev_err(dev, \"invalid request to devnum 0\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto no_need_xmit;\n\t\t}\n\n\t\tswitch (ctrlreq->bRequest) {\n\t\tcase USB_REQ_SET_ADDRESS:\n\t\t\t \n\t\t\tdev_info(dev, \"SetAddress Request (%d) to port %d\\n\",\n\t\t\t\t ctrlreq->wValue, vdev->rhport);\n\n\t\t\tusb_put_dev(vdev->udev);\n\t\t\tvdev->udev = usb_get_dev(urb->dev);\n\n\t\t\tspin_lock(&vdev->ud.lock);\n\t\t\tvdev->ud.status = VDEV_ST_USED;\n\t\t\tspin_unlock(&vdev->ud.lock);\n\n\t\t\tif (urb->status == -EINPROGRESS) {\n\t\t\t\t \n\t\t\t\t \n\t\t\t\turb->status = 0;\n\t\t\t}\n\n\t\t\tgoto no_need_xmit;\n\n\t\tcase USB_REQ_GET_DESCRIPTOR:\n\t\t\tif (ctrlreq->wValue == cpu_to_le16(USB_DT_DEVICE << 8))\n\t\t\t\tusbip_dbg_vhci_hc(\n\t\t\t\t\t\"Not yet?:Get_Descriptor to device 0 (get max pipe size)\\n\");\n\n\t\t\tusb_put_dev(vdev->udev);\n\t\t\tvdev->udev = usb_get_dev(urb->dev);\n\t\t\tgoto out;\n\n\t\tdefault:\n\t\t\t \n\t\t\tdev_err(dev,\n\t\t\t\t\"invalid request to devnum 0 bRequest %u, wValue %u\\n\",\n\t\t\t\tctrlreq->bRequest,\n\t\t\t\tctrlreq->wValue);\n\t\t\tret =  -EINVAL;\n\t\t\tgoto no_need_xmit;\n\t\t}\n\n\t}\n\nout:\n\tvhci_tx_urb(urb, vdev);\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\treturn 0;\n\nno_need_xmit:\n\tusb_hcd_unlink_urb_from_ep(hcd, urb);\nno_need_unlink:\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\tif (!ret) {\n\t\t \n\t\tlocal_irq_disable();\n\t\tusb_hcd_giveback_urb(hcd, urb, urb->status);\n\t\tlocal_irq_enable();\n\t}\n\treturn ret;\n}\n\n \nstatic int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct vhci_hcd *vhci_hcd = hcd_to_vhci_hcd(hcd);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tstruct vhci_priv *priv;\n\tstruct vhci_device *vdev;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tpriv = urb->hcpriv;\n\tif (!priv) {\n\t\t \n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\treturn -EIDRM;\n\t}\n\n\t{\n\t\tint ret = 0;\n\n\t\tret = usb_hcd_check_unlink_urb(hcd, urb, status);\n\t\tif (ret) {\n\t\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t  \n\tvdev = priv->vdev;\n\n\tif (!vdev->ud.tcp_socket) {\n\t\t \n\t\tspin_lock(&vdev->priv_lock);\n\n\t\tlist_del(&priv->list);\n\t\tkfree(priv);\n\t\turb->hcpriv = NULL;\n\n\t\tspin_unlock(&vdev->priv_lock);\n\n\t\t \n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\tusb_hcd_giveback_urb(hcd, urb, urb->status);\n\t\tspin_lock_irqsave(&vhci->lock, flags);\n\n\t} else {\n\t\t \n\t\tstruct vhci_unlink *unlink;\n\n\t\tspin_lock(&vdev->priv_lock);\n\n\t\t \n\t\tunlink = kzalloc(sizeof(struct vhci_unlink), GFP_ATOMIC);\n\t\tif (!unlink) {\n\t\t\tspin_unlock(&vdev->priv_lock);\n\t\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\t\t\tusbip_event_add(&vdev->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tunlink->seqnum = atomic_inc_return(&vhci_hcd->seqnum);\n\t\tif (unlink->seqnum == 0xffff)\n\t\t\tpr_info(\"seqnum max\\n\");\n\n\t\tunlink->unlink_seqnum = priv->seqnum;\n\n\t\t \n\t\tlist_add_tail(&unlink->list, &vdev->unlink_tx);\n\t\twake_up(&vdev->waitq_tx);\n\n\t\tspin_unlock(&vdev->priv_lock);\n\t}\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tusbip_dbg_vhci_hc(\"leave\\n\");\n\treturn 0;\n}\n\nstatic void vhci_cleanup_unlink_list(struct vhci_device *vdev,\n\t\tstruct list_head *unlink_list)\n{\n\tstruct vhci_hcd *vhci_hcd = vdev_to_vhci_hcd(vdev);\n\tstruct usb_hcd *hcd = vhci_hcd_to_hcd(vhci_hcd);\n\tstruct vhci *vhci = vhci_hcd->vhci;\n\tstruct vhci_unlink *unlink, *tmp;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\tspin_lock(&vdev->priv_lock);\n\n\tlist_for_each_entry_safe(unlink, tmp, unlink_list, list) {\n\t\tstruct urb *urb;\n\n\t\turb = pickup_urb_and_free_priv(vdev, unlink->unlink_seqnum);\n\t\tif (!urb) {\n\t\t\tlist_del(&unlink->list);\n\t\t\tkfree(unlink);\n\t\t\tcontinue;\n\t\t}\n\n\t\turb->status = -ENODEV;\n\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\n\t\tlist_del(&unlink->list);\n\n\t\tspin_unlock(&vdev->priv_lock);\n\t\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\t\tusb_hcd_giveback_urb(hcd, urb, urb->status);\n\n\t\tspin_lock_irqsave(&vhci->lock, flags);\n\t\tspin_lock(&vdev->priv_lock);\n\n\t\tkfree(unlink);\n\t}\n\n\tspin_unlock(&vdev->priv_lock);\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n}\n\nstatic void vhci_device_unlink_cleanup(struct vhci_device *vdev)\n{\n\t \n\tvhci_cleanup_unlink_list(vdev, &vdev->unlink_tx);\n\n\t \n\tvhci_cleanup_unlink_list(vdev, &vdev->unlink_rx);\n}\n\n \nstatic void vhci_shutdown_connection(struct usbip_device *ud)\n{\n\tstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\n\n\t \n\tif (ud->tcp_socket) {\n\t\tpr_debug(\"shutdown tcp_socket %d\\n\", ud->sockfd);\n\t\tkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\n\t}\n\n\t \n\tif (vdev->ud.tcp_rx) {\n\t\tkthread_stop_put(vdev->ud.tcp_rx);\n\t\tvdev->ud.tcp_rx = NULL;\n\t}\n\tif (vdev->ud.tcp_tx) {\n\t\tkthread_stop_put(vdev->ud.tcp_tx);\n\t\tvdev->ud.tcp_tx = NULL;\n\t}\n\tpr_info(\"stop threads\\n\");\n\n\t \n\tif (vdev->ud.tcp_socket) {\n\t\tsockfd_put(vdev->ud.tcp_socket);\n\t\tvdev->ud.tcp_socket = NULL;\n\t\tvdev->ud.sockfd = -1;\n\t}\n\tpr_info(\"release socket\\n\");\n\n\tvhci_device_unlink_cleanup(vdev);\n\n\t \n\trh_port_disconnect(vdev);\n\n\tpr_info(\"disconnect device\\n\");\n}\n\nstatic void vhci_device_reset(struct usbip_device *ud)\n{\n\tstruct vhci_device *vdev = container_of(ud, struct vhci_device, ud);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\n\tvdev->speed  = 0;\n\tvdev->devid  = 0;\n\n\tusb_put_dev(vdev->udev);\n\tvdev->udev = NULL;\n\n\tif (ud->tcp_socket) {\n\t\tsockfd_put(ud->tcp_socket);\n\t\tud->tcp_socket = NULL;\n\t\tud->sockfd = -1;\n\t}\n\tud->status = VDEV_ST_NULL;\n\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\nstatic void vhci_device_unusable(struct usbip_device *ud)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\tud->status = VDEV_ST_ERROR;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\nstatic void vhci_device_init(struct vhci_device *vdev)\n{\n\tmemset(vdev, 0, sizeof(struct vhci_device));\n\n\tvdev->ud.side   = USBIP_VHCI;\n\tvdev->ud.status = VDEV_ST_NULL;\n\tspin_lock_init(&vdev->ud.lock);\n\tmutex_init(&vdev->ud.sysfs_lock);\n\n\tINIT_LIST_HEAD(&vdev->priv_rx);\n\tINIT_LIST_HEAD(&vdev->priv_tx);\n\tINIT_LIST_HEAD(&vdev->unlink_tx);\n\tINIT_LIST_HEAD(&vdev->unlink_rx);\n\tspin_lock_init(&vdev->priv_lock);\n\n\tinit_waitqueue_head(&vdev->waitq_tx);\n\n\tvdev->ud.eh_ops.shutdown = vhci_shutdown_connection;\n\tvdev->ud.eh_ops.reset = vhci_device_reset;\n\tvdev->ud.eh_ops.unusable = vhci_device_unusable;\n\n\tusbip_start_eh(&vdev->ud);\n}\n\nstatic int hcd_name_to_id(const char *name)\n{\n\tchar *c;\n\tlong val;\n\tint ret;\n\n\tc = strchr(name, '.');\n\tif (c == NULL)\n\t\treturn 0;\n\n\tret = kstrtol(c+1, 10, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn val;\n}\n\nstatic int vhci_setup(struct usb_hcd *hcd)\n{\n\tstruct vhci *vhci = *((void **)dev_get_platdata(hcd->self.controller));\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tvhci->vhci_hcd_hs = hcd_to_vhci_hcd(hcd);\n\t\tvhci->vhci_hcd_hs->vhci = vhci;\n\t\t \n\t\thcd->speed = HCD_USB2;\n\t\thcd->self.root_hub->speed = USB_SPEED_HIGH;\n\t} else {\n\t\tvhci->vhci_hcd_ss = hcd_to_vhci_hcd(hcd);\n\t\tvhci->vhci_hcd_ss->vhci = vhci;\n\t\thcd->speed = HCD_USB3;\n\t\thcd->self.root_hub->speed = USB_SPEED_SUPER;\n\t}\n\n\t \n\thcd->self.sg_tablesize = 32;\n\thcd->self.no_sg_constraint = 1;\n\n\treturn 0;\n}\n\nstatic int vhci_start(struct usb_hcd *hcd)\n{\n\tstruct vhci_hcd *vhci_hcd = hcd_to_vhci_hcd(hcd);\n\tint id, rhport;\n\tint err;\n\n\tusbip_dbg_vhci_hc(\"enter vhci_start\\n\");\n\n\tif (usb_hcd_is_primary_hcd(hcd))\n\t\tspin_lock_init(&vhci_hcd->vhci->lock);\n\n\t \n\n\tfor (rhport = 0; rhport < VHCI_HC_PORTS; rhport++) {\n\t\tstruct vhci_device *vdev = &vhci_hcd->vdev[rhport];\n\n\t\tvhci_device_init(vdev);\n\t\tvdev->rhport = rhport;\n\t}\n\n\tatomic_set(&vhci_hcd->seqnum, 0);\n\n\thcd->power_budget = 0;  \n\thcd->uses_new_polling = 1;\n\n#ifdef CONFIG_USB_OTG\n\thcd->self.otg_port = 1;\n#endif\n\n\tid = hcd_name_to_id(hcd_name(hcd));\n\tif (id < 0) {\n\t\tpr_err(\"invalid vhci name %s\\n\", hcd_name(hcd));\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (id == 0 && usb_hcd_is_primary_hcd(hcd)) {\n\t\terr = vhci_init_attr_group();\n\t\tif (err) {\n\t\t\tdev_err(hcd_dev(hcd), \"init attr group failed, err = %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\terr = sysfs_create_group(&hcd_dev(hcd)->kobj, &vhci_attr_group);\n\t\tif (err) {\n\t\t\tdev_err(hcd_dev(hcd), \"create sysfs files failed, err = %d\\n\", err);\n\t\t\tvhci_finish_attr_group();\n\t\t\treturn err;\n\t\t}\n\t\tpr_info(\"created sysfs %s\\n\", hcd_name(hcd));\n\t}\n\n\treturn 0;\n}\n\nstatic void vhci_stop(struct usb_hcd *hcd)\n{\n\tstruct vhci_hcd *vhci_hcd = hcd_to_vhci_hcd(hcd);\n\tint id, rhport;\n\n\tusbip_dbg_vhci_hc(\"stop VHCI controller\\n\");\n\n\t \n\tid = hcd_name_to_id(hcd_name(hcd));\n\tif (id == 0 && usb_hcd_is_primary_hcd(hcd)) {\n\t\tsysfs_remove_group(&hcd_dev(hcd)->kobj, &vhci_attr_group);\n\t\tvhci_finish_attr_group();\n\t}\n\n\t \n\tfor (rhport = 0; rhport < VHCI_HC_PORTS; rhport++) {\n\t\tstruct vhci_device *vdev = &vhci_hcd->vdev[rhport];\n\n\t\tusbip_event_add(&vdev->ud, VDEV_EVENT_REMOVED);\n\t\tusbip_stop_eh(&vdev->ud);\n\t}\n}\n\nstatic int vhci_get_frame_number(struct usb_hcd *hcd)\n{\n\tdev_err_ratelimited(&hcd->self.root_hub->dev, \"Not yet implemented\\n\");\n\treturn 0;\n}\n\n#ifdef CONFIG_PM\n\n \nstatic int vhci_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct vhci *vhci = *((void **)dev_get_platdata(hcd->self.controller));\n\tunsigned long flags;\n\n\tdev_dbg(&hcd->self.root_hub->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\thcd->state = HC_STATE_SUSPENDED;\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vhci_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct vhci *vhci = *((void **)dev_get_platdata(hcd->self.controller));\n\tint rc = 0;\n\tunsigned long flags;\n\n\tdev_dbg(&hcd->self.root_hub->dev, \"%s\\n\", __func__);\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\trc = -ESHUTDOWN;\n\telse\n\t\thcd->state = HC_STATE_RUNNING;\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\treturn rc;\n}\n\n#else\n\n#define vhci_bus_suspend      NULL\n#define vhci_bus_resume       NULL\n#endif\n\n \nstatic int vhci_alloc_streams(struct usb_hcd *hcd, struct usb_device *udev,\n\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\tunsigned int num_streams, gfp_t mem_flags)\n{\n\tdev_dbg(&hcd->self.root_hub->dev, \"vhci_alloc_streams not implemented\\n\");\n\treturn 0;\n}\n\n \nstatic int vhci_free_streams(struct usb_hcd *hcd, struct usb_device *udev,\n\tstruct usb_host_endpoint **eps, unsigned int num_eps,\n\tgfp_t mem_flags)\n{\n\tdev_dbg(&hcd->self.root_hub->dev, \"vhci_free_streams not implemented\\n\");\n\treturn 0;\n}\n\nstatic const struct hc_driver vhci_hc_driver = {\n\t.description\t= driver_name,\n\t.product_desc\t= driver_desc,\n\t.hcd_priv_size\t= sizeof(struct vhci_hcd),\n\n\t.flags\t\t= HCD_USB3 | HCD_SHARED,\n\n\t.reset\t\t= vhci_setup,\n\t.start\t\t= vhci_start,\n\t.stop\t\t= vhci_stop,\n\n\t.urb_enqueue\t= vhci_urb_enqueue,\n\t.urb_dequeue\t= vhci_urb_dequeue,\n\n\t.get_frame_number = vhci_get_frame_number,\n\n\t.hub_status_data = vhci_hub_status,\n\t.hub_control    = vhci_hub_control,\n\t.bus_suspend\t= vhci_bus_suspend,\n\t.bus_resume\t= vhci_bus_resume,\n\n\t.alloc_streams\t= vhci_alloc_streams,\n\t.free_streams\t= vhci_free_streams,\n};\n\nstatic int vhci_hcd_probe(struct platform_device *pdev)\n{\n\tstruct vhci             *vhci = *((void **)dev_get_platdata(&pdev->dev));\n\tstruct usb_hcd\t\t*hcd_hs;\n\tstruct usb_hcd\t\t*hcd_ss;\n\tint\t\t\tret;\n\n\tusbip_dbg_vhci_hc(\"name %s id %d\\n\", pdev->name, pdev->id);\n\n\t \n\thcd_hs = usb_create_hcd(&vhci_hc_driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd_hs) {\n\t\tpr_err(\"create primary hcd failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thcd_hs->has_tt = 1;\n\n\t \n\tret = usb_add_hcd(hcd_hs, 0, 0);\n\tif (ret != 0) {\n\t\tpr_err(\"usb_add_hcd hs failed %d\\n\", ret);\n\t\tgoto put_usb2_hcd;\n\t}\n\n\thcd_ss = usb_create_shared_hcd(&vhci_hc_driver, &pdev->dev,\n\t\t\t\t       dev_name(&pdev->dev), hcd_hs);\n\tif (!hcd_ss) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"create shared hcd failed\\n\");\n\t\tgoto remove_usb2_hcd;\n\t}\n\n\tret = usb_add_hcd(hcd_ss, 0, 0);\n\tif (ret) {\n\t\tpr_err(\"usb_add_hcd ss failed %d\\n\", ret);\n\t\tgoto put_usb3_hcd;\n\t}\n\n\tusbip_dbg_vhci_hc(\"bye\\n\");\n\treturn 0;\n\nput_usb3_hcd:\n\tusb_put_hcd(hcd_ss);\nremove_usb2_hcd:\n\tusb_remove_hcd(hcd_hs);\nput_usb2_hcd:\n\tusb_put_hcd(hcd_hs);\n\tvhci->vhci_hcd_hs = NULL;\n\tvhci->vhci_hcd_ss = NULL;\n\treturn ret;\n}\n\nstatic void vhci_hcd_remove(struct platform_device *pdev)\n{\n\tstruct vhci *vhci = *((void **)dev_get_platdata(&pdev->dev));\n\n\t \n\tusb_remove_hcd(vhci_hcd_to_hcd(vhci->vhci_hcd_ss));\n\tusb_put_hcd(vhci_hcd_to_hcd(vhci->vhci_hcd_ss));\n\n\tusb_remove_hcd(vhci_hcd_to_hcd(vhci->vhci_hcd_hs));\n\tusb_put_hcd(vhci_hcd_to_hcd(vhci->vhci_hcd_hs));\n\n\tvhci->vhci_hcd_hs = NULL;\n\tvhci->vhci_hcd_ss = NULL;\n}\n\n#ifdef CONFIG_PM\n\n \nstatic int vhci_hcd_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct usb_hcd *hcd;\n\tstruct vhci *vhci;\n\tint rhport;\n\tint connected = 0;\n\tint ret = 0;\n\tunsigned long flags;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\thcd = platform_get_drvdata(pdev);\n\tif (!hcd)\n\t\treturn 0;\n\n\tvhci = *((void **)dev_get_platdata(hcd->self.controller));\n\n\tspin_lock_irqsave(&vhci->lock, flags);\n\n\tfor (rhport = 0; rhport < VHCI_HC_PORTS; rhport++) {\n\t\tif (vhci->vhci_hcd_hs->port_status[rhport] &\n\t\t    USB_PORT_STAT_CONNECTION)\n\t\t\tconnected += 1;\n\n\t\tif (vhci->vhci_hcd_ss->port_status[rhport] &\n\t\t    USB_PORT_STAT_CONNECTION)\n\t\t\tconnected += 1;\n\t}\n\n\tspin_unlock_irqrestore(&vhci->lock, flags);\n\n\tif (connected > 0) {\n\t\tdev_info(&pdev->dev,\n\t\t\t \"We have %d active connection%s. Do not suspend.\\n\",\n\t\t\t connected, (connected == 1 ? \"\" : \"s\"));\n\t\tret =  -EBUSY;\n\t} else {\n\t\tdev_info(&pdev->dev, \"suspend vhci_hcd\");\n\t\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\t}\n\n\treturn ret;\n}\n\nstatic int vhci_hcd_resume(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd;\n\n\tdev_dbg(&pdev->dev, \"%s\\n\", __func__);\n\n\thcd = platform_get_drvdata(pdev);\n\tif (!hcd)\n\t\treturn 0;\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tusb_hcd_poll_rh_status(hcd);\n\n\treturn 0;\n}\n\n#else\n\n#define vhci_hcd_suspend\tNULL\n#define vhci_hcd_resume\t\tNULL\n\n#endif\n\nstatic struct platform_driver vhci_driver = {\n\t.probe\t= vhci_hcd_probe,\n\t.remove_new = vhci_hcd_remove,\n\t.suspend = vhci_hcd_suspend,\n\t.resume\t= vhci_hcd_resume,\n\t.driver\t= {\n\t\t.name = driver_name,\n\t},\n};\n\nstatic void del_platform_devices(void)\n{\n\tstruct platform_device *pdev;\n\tint i;\n\n\tfor (i = 0; i < vhci_num_controllers; i++) {\n\t\tpdev = vhcis[i].pdev;\n\t\tif (pdev != NULL)\n\t\t\tplatform_device_unregister(pdev);\n\t\tvhcis[i].pdev = NULL;\n\t}\n\tsysfs_remove_link(&platform_bus.kobj, driver_name);\n}\n\nstatic int __init vhci_hcd_init(void)\n{\n\tint i, ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (vhci_num_controllers < 1)\n\t\tvhci_num_controllers = 1;\n\n\tvhcis = kcalloc(vhci_num_controllers, sizeof(struct vhci), GFP_KERNEL);\n\tif (vhcis == NULL)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < vhci_num_controllers; i++) {\n\t\tvhcis[i].pdev = platform_device_alloc(driver_name, i);\n\t\tif (!vhcis[i].pdev) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_put(vhcis[i--].pdev);\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_device_alloc;\n\t\t}\n\t}\n\tfor (i = 0; i < vhci_num_controllers; i++) {\n\t\tvoid *vhci = &vhcis[i];\n\t\tret = platform_device_add_data(vhcis[i].pdev, &vhci, sizeof(void *));\n\t\tif (ret)\n\t\t\tgoto err_driver_register;\n\t}\n\n\tret = platform_driver_register(&vhci_driver);\n\tif (ret)\n\t\tgoto err_driver_register;\n\n\tfor (i = 0; i < vhci_num_controllers; i++) {\n\t\tret = platform_device_add(vhcis[i].pdev);\n\t\tif (ret < 0) {\n\t\t\ti--;\n\t\t\twhile (i >= 0)\n\t\t\t\tplatform_device_del(vhcis[i--].pdev);\n\t\t\tgoto err_add_hcd;\n\t\t}\n\t}\n\n\treturn ret;\n\nerr_add_hcd:\n\tplatform_driver_unregister(&vhci_driver);\nerr_driver_register:\n\tfor (i = 0; i < vhci_num_controllers; i++)\n\t\tplatform_device_put(vhcis[i].pdev);\nerr_device_alloc:\n\tkfree(vhcis);\n\treturn ret;\n}\n\nstatic void __exit vhci_hcd_exit(void)\n{\n\tdel_platform_devices();\n\tplatform_driver_unregister(&vhci_driver);\n\tkfree(vhcis);\n}\n\nmodule_init(vhci_hcd_init);\nmodule_exit(vhci_hcd_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}