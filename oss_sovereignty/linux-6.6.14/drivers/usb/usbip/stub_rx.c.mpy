{
  "module_name": "stub_rx.c",
  "hash_id": "4c3b7adba49be41522368f2a2d36f6cb1658d97cb3a1daf08dfcf2f6747213bf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/stub_rx.c",
  "human_readable_source": "\n \n\n#include <asm/byteorder.h>\n#include <linux/kthread.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/scatterlist.h>\n\n#include \"usbip_common.h\"\n#include \"stub.h\"\n\nstatic int is_clear_halt_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\n\treturn (req->bRequest == USB_REQ_CLEAR_FEATURE) &&\n\t       (req->bRequestType == USB_RECIP_ENDPOINT) &&\n\t       (req->wValue == USB_ENDPOINT_HALT);\n}\n\nstatic int is_set_interface_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\n\treturn (req->bRequest == USB_REQ_SET_INTERFACE) &&\n\t\t(req->bRequestType == USB_RECIP_INTERFACE);\n}\n\nstatic int is_set_configuration_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\n\treturn (req->bRequest == USB_REQ_SET_CONFIGURATION) &&\n\t\t(req->bRequestType == USB_RECIP_DEVICE);\n}\n\nstatic int is_reset_device_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\t__u16 value;\n\t__u16 index;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\tvalue = le16_to_cpu(req->wValue);\n\tindex = le16_to_cpu(req->wIndex);\n\n\tif ((req->bRequest == USB_REQ_SET_FEATURE) &&\n\t    (req->bRequestType == USB_RT_PORT) &&\n\t    (value == USB_PORT_FEAT_RESET)) {\n\t\tusbip_dbg_stub_rx(\"reset_device_cmd, port %u\\n\", index);\n\t\treturn 1;\n\t} else\n\t\treturn 0;\n}\n\nstatic int tweak_clear_halt_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\tint target_endp;\n\tint target_dir;\n\tint target_pipe;\n\tint ret;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\n\t \n\ttarget_endp = le16_to_cpu(req->wIndex) & 0x000f;\n\n\t \n\ttarget_dir = le16_to_cpu(req->wIndex) & 0x0080;\n\n\tif (target_dir)\n\t\ttarget_pipe = usb_rcvctrlpipe(urb->dev, target_endp);\n\telse\n\t\ttarget_pipe = usb_sndctrlpipe(urb->dev, target_endp);\n\n\tret = usb_clear_halt(urb->dev, target_pipe);\n\tif (ret < 0)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"usb_clear_halt error: devnum %d endp %d ret %d\\n\",\n\t\t\turb->dev->devnum, target_endp, ret);\n\telse\n\t\tdev_info(&urb->dev->dev,\n\t\t\t \"usb_clear_halt done: devnum %d endp %d\\n\",\n\t\t\t urb->dev->devnum, target_endp);\n\n\treturn ret;\n}\n\nstatic int tweak_set_interface_cmd(struct urb *urb)\n{\n\tstruct usb_ctrlrequest *req;\n\t__u16 alternate;\n\t__u16 interface;\n\tint ret;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\talternate = le16_to_cpu(req->wValue);\n\tinterface = le16_to_cpu(req->wIndex);\n\n\tusbip_dbg_stub_rx(\"set_interface: inf %u alt %u\\n\",\n\t\t\t  interface, alternate);\n\n\tret = usb_set_interface(urb->dev, interface, alternate);\n\tif (ret < 0)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"usb_set_interface error: inf %u alt %u ret %d\\n\",\n\t\t\tinterface, alternate, ret);\n\telse\n\t\tdev_info(&urb->dev->dev,\n\t\t\t\"usb_set_interface done: inf %u alt %u\\n\",\n\t\t\tinterface, alternate);\n\n\treturn ret;\n}\n\nstatic int tweak_set_configuration_cmd(struct urb *urb)\n{\n\tstruct stub_priv *priv = (struct stub_priv *) urb->context;\n\tstruct stub_device *sdev = priv->sdev;\n\tstruct usb_ctrlrequest *req;\n\t__u16 config;\n\tint err;\n\n\treq = (struct usb_ctrlrequest *) urb->setup_packet;\n\tconfig = le16_to_cpu(req->wValue);\n\n\tusb_lock_device(sdev->udev);\n\terr = usb_set_configuration(sdev->udev, config);\n\tusb_unlock_device(sdev->udev);\n\tif (err && err != -ENODEV)\n\t\tdev_err(&sdev->udev->dev, \"can't set config #%d, error %d\\n\",\n\t\t\tconfig, err);\n\treturn 0;\n}\n\nstatic int tweak_reset_device_cmd(struct urb *urb)\n{\n\tstruct stub_priv *priv = (struct stub_priv *) urb->context;\n\tstruct stub_device *sdev = priv->sdev;\n\n\tdev_info(&urb->dev->dev, \"usb_queue_reset_device\\n\");\n\n\tif (usb_lock_device_for_reset(sdev->udev, NULL) < 0) {\n\t\tdev_err(&urb->dev->dev, \"could not obtain lock to reset device\\n\");\n\t\treturn 0;\n\t}\n\tusb_reset_device(sdev->udev);\n\tusb_unlock_device(sdev->udev);\n\n\treturn 0;\n}\n\n \nstatic void tweak_special_requests(struct urb *urb)\n{\n\tif (!urb || !urb->setup_packet)\n\t\treturn;\n\n\tif (usb_pipetype(urb->pipe) != PIPE_CONTROL)\n\t\treturn;\n\n\tif (is_clear_halt_cmd(urb))\n\t\t \n\t\t tweak_clear_halt_cmd(urb);\n\n\telse if (is_set_interface_cmd(urb))\n\t\t \n\t\ttweak_set_interface_cmd(urb);\n\n\telse if (is_set_configuration_cmd(urb))\n\t\t \n\t\ttweak_set_configuration_cmd(urb);\n\n\telse if (is_reset_device_cmd(urb))\n\t\ttweak_reset_device_cmd(urb);\n\telse\n\t\tusbip_dbg_stub_rx(\"no need to tweak\\n\");\n}\n\n \nstatic int stub_recv_cmd_unlink(struct stub_device *sdev,\n\t\t\t\tstruct usbip_header *pdu)\n{\n\tint ret, i;\n\tunsigned long flags;\n\tstruct stub_priv *priv;\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tlist_for_each_entry(priv, &sdev->priv_init, list) {\n\t\tif (priv->seqnum != pdu->u.cmd_unlink.seqnum)\n\t\t\tcontinue;\n\n\t\t \n\t\tpriv->unlinking = 1;\n\n\t\t \n\t\tpriv->seqnum = pdu->base.seqnum;\n\n\t\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\t\t \n\t\t \n\t\tfor (i = priv->completed_urbs; i < priv->num_urbs; i++) {\n\t\t\tret = usb_unlink_urb(priv->urbs[i]);\n\t\t\tif (ret != -EINPROGRESS)\n\t\t\t\tdev_err(&priv->urbs[i]->dev->dev,\n\t\t\t\t\t\"failed to unlink %d/%d urb of seqnum %lu, ret %d\\n\",\n\t\t\t\t\ti + 1, priv->num_urbs,\n\t\t\t\t\tpriv->seqnum, ret);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tusbip_dbg_stub_rx(\"seqnum %d is not pending\\n\",\n\t\t\t  pdu->u.cmd_unlink.seqnum);\n\n\t \n\tstub_enqueue_ret_unlink(sdev, pdu->base.seqnum, 0);\n\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn 0;\n}\n\nstatic int valid_request(struct stub_device *sdev, struct usbip_header *pdu)\n{\n\tstruct usbip_device *ud = &sdev->ud;\n\tint valid = 0;\n\n\tif (pdu->base.devid == sdev->devid) {\n\t\tspin_lock_irq(&ud->lock);\n\t\tif (ud->status == SDEV_ST_USED) {\n\t\t\t \n\t\t\tvalid = 1;\n\t\t}\n\t\tspin_unlock_irq(&ud->lock);\n\t}\n\n\treturn valid;\n}\n\nstatic struct stub_priv *stub_priv_alloc(struct stub_device *sdev,\n\t\t\t\t\t struct usbip_header *pdu)\n{\n\tstruct stub_priv *priv;\n\tstruct usbip_device *ud = &sdev->ud;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tpriv = kmem_cache_zalloc(stub_priv_cache, GFP_ATOMIC);\n\tif (!priv) {\n\t\tdev_err(&sdev->udev->dev, \"alloc stub_priv\\n\");\n\t\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\treturn NULL;\n\t}\n\n\tpriv->seqnum = pdu->base.seqnum;\n\tpriv->sdev = sdev;\n\n\t \n\tlist_add_tail(&priv->list, &sdev->priv_init);\n\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn priv;\n}\n\nstatic int get_pipe(struct stub_device *sdev, struct usbip_header *pdu)\n{\n\tstruct usb_device *udev = sdev->udev;\n\tstruct usb_host_endpoint *ep;\n\tstruct usb_endpoint_descriptor *epd = NULL;\n\tint epnum = pdu->base.ep;\n\tint dir = pdu->base.direction;\n\n\tif (epnum < 0 || epnum > 15)\n\t\tgoto err_ret;\n\n\tif (dir == USBIP_DIR_IN)\n\t\tep = udev->ep_in[epnum & 0x7f];\n\telse\n\t\tep = udev->ep_out[epnum & 0x7f];\n\tif (!ep)\n\t\tgoto err_ret;\n\n\tepd = &ep->desc;\n\n\tif (usb_endpoint_xfer_control(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndctrlpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvctrlpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_bulk(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndbulkpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvbulkpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_int(epd)) {\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndintpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvintpipe(udev, epnum);\n\t}\n\n\tif (usb_endpoint_xfer_isoc(epd)) {\n\t\t \n\t\tif (pdu->u.cmd_submit.number_of_packets < 0 ||\n\t\t    pdu->u.cmd_submit.number_of_packets >\n\t\t    USBIP_MAX_ISO_PACKETS) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"CMD_SUBMIT: isoc invalid num packets %d\\n\",\n\t\t\t\tpdu->u.cmd_submit.number_of_packets);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dir == USBIP_DIR_OUT)\n\t\t\treturn usb_sndisocpipe(udev, epnum);\n\t\telse\n\t\t\treturn usb_rcvisocpipe(udev, epnum);\n\t}\n\nerr_ret:\n\t \n\tdev_err(&sdev->udev->dev, \"CMD_SUBMIT: invalid epnum %d\\n\", epnum);\n\treturn -1;\n}\n\nstatic void masking_bogus_flags(struct urb *urb)\n{\n\tint\t\t\t\txfertype;\n\tstruct usb_device\t\t*dev;\n\tstruct usb_host_endpoint\t*ep;\n\tint\t\t\t\tis_out;\n\tunsigned int\tallowed;\n\n\tif (!urb || urb->hcpriv || !urb->complete)\n\t\treturn;\n\tdev = urb->dev;\n\tif ((!dev) || (dev->state < USB_STATE_UNAUTHENTICATED))\n\t\treturn;\n\n\tep = (usb_pipein(urb->pipe) ? dev->ep_in : dev->ep_out)\n\t\t[usb_pipeendpoint(urb->pipe)];\n\tif (!ep)\n\t\treturn;\n\n\txfertype = usb_endpoint_type(&ep->desc);\n\tif (xfertype == USB_ENDPOINT_XFER_CONTROL) {\n\t\tstruct usb_ctrlrequest *setup =\n\t\t\t(struct usb_ctrlrequest *) urb->setup_packet;\n\n\t\tif (!setup)\n\t\t\treturn;\n\t\tis_out = !(setup->bRequestType & USB_DIR_IN) ||\n\t\t\t!setup->wLength;\n\t} else {\n\t\tis_out = usb_endpoint_dir_out(&ep->desc);\n\t}\n\n\t \n\tallowed = (URB_NO_TRANSFER_DMA_MAP | URB_NO_INTERRUPT |\n\t\t   URB_DIR_MASK | URB_FREE_BUFFER);\n\tswitch (xfertype) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (is_out)\n\t\t\tallowed |= URB_ZERO_PACKET;\n\t\tfallthrough;\n\tdefault:\t\t\t \n\t\tif (!is_out)\n\t\t\tallowed |= URB_SHORT_NOT_OK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tallowed |= URB_ISO_ASAP;\n\t\tbreak;\n\t}\n\turb->transfer_flags &= allowed;\n}\n\nstatic int stub_recv_xbuff(struct usbip_device *ud, struct stub_priv *priv)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < priv->num_urbs; i++) {\n\t\tret = usbip_recv_xbuff(ud, priv->urbs[i]);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic void stub_recv_cmd_submit(struct stub_device *sdev,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tstruct stub_priv *priv;\n\tstruct usbip_device *ud = &sdev->ud;\n\tstruct usb_device *udev = sdev->udev;\n\tstruct scatterlist *sgl = NULL, *sg;\n\tvoid *buffer = NULL;\n\tunsigned long long buf_len;\n\tint nents;\n\tint num_urbs = 1;\n\tint pipe = get_pipe(sdev, pdu);\n\tint use_sg = pdu->u.cmd_submit.transfer_flags & USBIP_URB_DMA_MAP_SG;\n\tint support_sg = 1;\n\tint np = 0;\n\tint ret, i;\n\n\tif (pipe == -1)\n\t\treturn;\n\n\t \n\tpriv = stub_priv_alloc(sdev, pdu);\n\tif (!priv)\n\t\treturn;\n\n\tbuf_len = (unsigned long long)pdu->u.cmd_submit.transfer_buffer_length;\n\n\tif (use_sg && !buf_len) {\n\t\tdev_err(&udev->dev, \"sg buffer with zero length\\n\");\n\t\tgoto err_malloc;\n\t}\n\n\t \n\tif (buf_len) {\n\t\tif (use_sg) {\n\t\t\tsgl = sgl_alloc(buf_len, GFP_KERNEL, &nents);\n\t\t\tif (!sgl)\n\t\t\t\tgoto err_malloc;\n\n\t\t\t \n\t\t\tif (!udev->bus->sg_tablesize) {\n\t\t\t\t \n\t\t\t\tsupport_sg = 0;\n\t\t\t\tnum_urbs = nents;\n\t\t\t\tpriv->completed_urbs = 0;\n\t\t\t\tpdu->u.cmd_submit.transfer_flags &=\n\t\t\t\t\t\t\t\t~USBIP_URB_DMA_MAP_SG;\n\t\t\t}\n\t\t} else {\n\t\t\tbuffer = kzalloc(buf_len, GFP_KERNEL);\n\t\t\tif (!buffer)\n\t\t\t\tgoto err_malloc;\n\t\t}\n\t}\n\n\t \n\tpriv->num_urbs = num_urbs;\n\tpriv->urbs = kmalloc_array(num_urbs, sizeof(*priv->urbs), GFP_KERNEL);\n\tif (!priv->urbs)\n\t\tgoto err_urbs;\n\n\t \n\tif (support_sg) {\n\t\tif (usb_pipeisoc(pipe))\n\t\t\tnp = pdu->u.cmd_submit.number_of_packets;\n\n\t\tpriv->urbs[0] = usb_alloc_urb(np, GFP_KERNEL);\n\t\tif (!priv->urbs[0])\n\t\t\tgoto err_urb;\n\n\t\tif (buf_len) {\n\t\t\tif (use_sg) {\n\t\t\t\tpriv->urbs[0]->sg = sgl;\n\t\t\t\tpriv->urbs[0]->num_sgs = nents;\n\t\t\t\tpriv->urbs[0]->transfer_buffer = NULL;\n\t\t\t} else {\n\t\t\t\tpriv->urbs[0]->transfer_buffer = buffer;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tpriv->urbs[0]->setup_packet = kmemdup(&pdu->u.cmd_submit.setup,\n\t\t\t\t\t8, GFP_KERNEL);\n\t\tif (!priv->urbs[0]->setup_packet) {\n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn;\n\t\t}\n\n\t\tusbip_pack_pdu(pdu, priv->urbs[0], USBIP_CMD_SUBMIT, 0);\n\t} else {\n\t\tfor_each_sg(sgl, sg, nents, i) {\n\t\t\tpriv->urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\t\t \n\t\t\tif (!priv->urbs[i])\n\t\t\t\tgoto err_urb;\n\n\t\t\tusbip_pack_pdu(pdu, priv->urbs[i], USBIP_CMD_SUBMIT, 0);\n\t\t\tpriv->urbs[i]->transfer_buffer = sg_virt(sg);\n\t\t\tpriv->urbs[i]->transfer_buffer_length = sg->length;\n\t\t}\n\t\tpriv->sgl = sgl;\n\t}\n\n\tfor (i = 0; i < num_urbs; i++) {\n\t\t \n\t\tpriv->urbs[i]->context = (void *) priv;\n\t\tpriv->urbs[i]->dev = udev;\n\t\tpriv->urbs[i]->pipe = pipe;\n\t\tpriv->urbs[i]->complete = stub_complete;\n\n\t\t \n\t\ttweak_special_requests(priv->urbs[i]);\n\n\t\tmasking_bogus_flags(priv->urbs[i]);\n\t}\n\n\tif (stub_recv_xbuff(ud, priv) < 0)\n\t\treturn;\n\n\tif (usbip_recv_iso(ud, priv->urbs[0]) < 0)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < priv->num_urbs; i++) {\n\t\tret = usb_submit_urb(priv->urbs[i], GFP_KERNEL);\n\n\t\tif (ret == 0)\n\t\t\tusbip_dbg_stub_rx(\"submit urb ok, seqnum %u\\n\",\n\t\t\t\t\tpdu->base.seqnum);\n\t\telse {\n\t\t\tdev_err(&udev->dev, \"submit_urb error, %d\\n\", ret);\n\t\t\tusbip_dump_header(pdu);\n\t\t\tusbip_dump_urb(priv->urbs[i]);\n\n\t\t\t \n\t\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tusbip_dbg_stub_rx(\"Leave\\n\");\n\treturn;\n\nerr_urb:\n\tkfree(priv->urbs);\nerr_urbs:\n\tkfree(buffer);\n\tsgl_free(sgl);\nerr_malloc:\n\tusbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC);\n}\n\n \nstatic void stub_rx_pdu(struct usbip_device *ud)\n{\n\tint ret;\n\tstruct usbip_header pdu;\n\tstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\n\tstruct device *dev = &sdev->udev->dev;\n\n\tusbip_dbg_stub_rx(\"Enter\\n\");\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\n\t \n\tret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\n\tif (ret != sizeof(pdu)) {\n\t\tdev_err(dev, \"recv a header, %d\\n\", ret);\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\treturn;\n\t}\n\n\tusbip_header_correct_endian(&pdu, 0);\n\n\tif (usbip_dbg_flag_stub_rx)\n\t\tusbip_dump_header(&pdu);\n\n\tif (!valid_request(sdev, &pdu)) {\n\t\tdev_err(dev, \"recv invalid request\\n\");\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\treturn;\n\t}\n\n\tswitch (pdu.base.command) {\n\tcase USBIP_CMD_UNLINK:\n\t\tstub_recv_cmd_unlink(sdev, &pdu);\n\t\tbreak;\n\n\tcase USBIP_CMD_SUBMIT:\n\t\tstub_recv_cmd_submit(sdev, &pdu);\n\t\tbreak;\n\n\tdefault:\n\t\t \n\t\tdev_err(dev, \"unknown pdu\\n\");\n\t\tusbip_event_add(ud, SDEV_EVENT_ERROR_TCP);\n\t\tbreak;\n\t}\n}\n\nint stub_rx_loop(void *data)\n{\n\tstruct usbip_device *ud = data;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (usbip_event_happened(ud))\n\t\t\tbreak;\n\n\t\tstub_rx_pdu(ud);\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}