{
  "module_name": "stub_tx.c",
  "hash_id": "4cc35ec6639300ff30debb6cea89757abcda097f2b4277b054f725ea16de7405",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/stub_tx.c",
  "human_readable_source": "\n \n\n#include <linux/kthread.h>\n#include <linux/socket.h>\n#include <linux/scatterlist.h>\n\n#include \"usbip_common.h\"\n#include \"stub.h\"\n\n \nvoid stub_enqueue_ret_unlink(struct stub_device *sdev, __u32 seqnum,\n\t\t\t     __u32 status)\n{\n\tstruct stub_unlink *unlink;\n\n\tunlink = kzalloc(sizeof(struct stub_unlink), GFP_ATOMIC);\n\tif (!unlink) {\n\t\tusbip_event_add(&sdev->ud, VDEV_EVENT_ERROR_MALLOC);\n\t\treturn;\n\t}\n\n\tunlink->seqnum = seqnum;\n\tunlink->status = status;\n\n\tlist_add_tail(&unlink->list, &sdev->unlink_tx);\n}\n\n \nvoid stub_complete(struct urb *urb)\n{\n\tstruct stub_priv *priv = (struct stub_priv *) urb->context;\n\tstruct stub_device *sdev = priv->sdev;\n\tunsigned long flags;\n\n\tusbip_dbg_stub_tx(\"complete! status %d\\n\", urb->status);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ENOENT:\n\t\tdev_info(&urb->dev->dev,\n\t\t\t \"stopped by a call to usb_kill_urb() because of cleaning up a virtual connection\\n\");\n\t\treturn;\n\tcase -ECONNRESET:\n\t\tdev_info(&urb->dev->dev,\n\t\t\t \"unlinked by a call to usb_unlink_urb()\\n\");\n\t\tbreak;\n\tcase -EPIPE:\n\t\tdev_info(&urb->dev->dev, \"endpoint %d is stalled\\n\",\n\t\t\t usb_pipeendpoint(urb->pipe));\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\t\tdev_info(&urb->dev->dev, \"device removed?\\n\");\n\t\tbreak;\n\tdefault:\n\t\tdev_info(&urb->dev->dev,\n\t\t\t \"urb completion with non-zero status %d\\n\",\n\t\t\t urb->status);\n\t\tbreak;\n\t}\n\n\t \n\tif (priv->sgl) {\n\t\tpriv->completed_urbs++;\n\n\t\t \n\t\tif (urb->status && !priv->urb_status)\n\t\t\tpriv->urb_status = urb->status;\n\n\t\tif (priv->completed_urbs < priv->num_urbs)\n\t\t\treturn;\n\t}\n\n\t \n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\tif (sdev->ud.tcp_socket == NULL) {\n\t\tusbip_dbg_stub_tx(\"ignore urb for closed connection\\n\");\n\t\t \n\t} else if (priv->unlinking) {\n\t\tstub_enqueue_ret_unlink(sdev, priv->seqnum, urb->status);\n\t\tstub_free_priv_and_urb(priv);\n\t} else {\n\t\tlist_move_tail(&priv->list, &sdev->priv_tx);\n\t}\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\t \n\twake_up(&sdev->tx_waitq);\n}\n\nstatic inline void setup_base_pdu(struct usbip_header_basic *base,\n\t\t\t\t  __u32 command, __u32 seqnum)\n{\n\tbase->command\t= command;\n\tbase->seqnum\t= seqnum;\n\tbase->devid\t= 0;\n\tbase->ep\t= 0;\n\tbase->direction = 0;\n}\n\nstatic void setup_ret_submit_pdu(struct usbip_header *rpdu, struct urb *urb)\n{\n\tstruct stub_priv *priv = (struct stub_priv *) urb->context;\n\n\tsetup_base_pdu(&rpdu->base, USBIP_RET_SUBMIT, priv->seqnum);\n\tusbip_pack_pdu(rpdu, urb, USBIP_RET_SUBMIT, 1);\n}\n\nstatic void setup_ret_unlink_pdu(struct usbip_header *rpdu,\n\t\t\t\t struct stub_unlink *unlink)\n{\n\tsetup_base_pdu(&rpdu->base, USBIP_RET_UNLINK, unlink->seqnum);\n\trpdu->u.ret_unlink.status = unlink->status;\n}\n\nstatic struct stub_priv *dequeue_from_priv_tx(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_priv *priv, *tmp;\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(priv, tmp, &sdev->priv_tx, list) {\n\t\tlist_move_tail(&priv->list, &sdev->priv_free);\n\t\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\t\treturn priv;\n\t}\n\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn NULL;\n}\n\nstatic int stub_send_ret_submit(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_priv *priv, *tmp;\n\n\tstruct msghdr msg;\n\tsize_t txsize;\n\n\tsize_t total_size = 0;\n\n\twhile ((priv = dequeue_from_priv_tx(sdev)) != NULL) {\n\t\tstruct urb *urb = priv->urbs[0];\n\t\tstruct usbip_header pdu_header;\n\t\tstruct usbip_iso_packet_descriptor *iso_buffer = NULL;\n\t\tstruct kvec *iov = NULL;\n\t\tstruct scatterlist *sg;\n\t\tu32 actual_length = 0;\n\t\tint iovnum = 0;\n\t\tint ret;\n\t\tint i;\n\n\t\ttxsize = 0;\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\n\t\tif (urb->actual_length > 0 && !urb->transfer_buffer &&\n\t\t   !urb->num_sgs) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"urb: actual_length %d transfer_buffer null\\n\",\n\t\t\t\turb->actual_length);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS)\n\t\t\tiovnum = 2 + urb->number_of_packets;\n\t\telse if (usb_pipein(urb->pipe) && urb->actual_length > 0 &&\n\t\t\turb->num_sgs)\n\t\t\tiovnum = 1 + urb->num_sgs;\n\t\telse if (usb_pipein(urb->pipe) && priv->sgl)\n\t\t\tiovnum = 1 + priv->num_urbs;\n\t\telse\n\t\t\tiovnum = 2;\n\n\t\tiov = kcalloc(iovnum, sizeof(struct kvec), GFP_KERNEL);\n\n\t\tif (!iov) {\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_MALLOC);\n\t\t\treturn -1;\n\t\t}\n\n\t\tiovnum = 0;\n\n\t\t \n\t\tsetup_ret_submit_pdu(&pdu_header, urb);\n\t\tusbip_dbg_stub_tx(\"setup txdata seqnum: %d\\n\",\n\t\t\t\t  pdu_header.base.seqnum);\n\n\t\tif (priv->sgl) {\n\t\t\tfor (i = 0; i < priv->num_urbs; i++)\n\t\t\t\tactual_length += priv->urbs[i]->actual_length;\n\n\t\t\tpdu_header.u.ret_submit.status = priv->urb_status;\n\t\t\tpdu_header.u.ret_submit.actual_length = actual_length;\n\t\t}\n\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\n\t\tiov[iovnum].iov_base = &pdu_header;\n\t\tiov[iovnum].iov_len  = sizeof(pdu_header);\n\t\tiovnum++;\n\t\ttxsize += sizeof(pdu_header);\n\n\t\t \n\t\tif (usb_pipein(urb->pipe) && priv->sgl) {\n\t\t\t \n\t\t\tfor (i = 0; i < priv->num_urbs; i++) {\n\t\t\t\tiov[iovnum].iov_base =\n\t\t\t\t\tpriv->urbs[i]->transfer_buffer;\n\t\t\t\tiov[iovnum].iov_len =\n\t\t\t\t\tpriv->urbs[i]->actual_length;\n\t\t\t\tiovnum++;\n\t\t\t}\n\t\t\ttxsize += actual_length;\n\t\t} else if (usb_pipein(urb->pipe) &&\n\t\t    usb_pipetype(urb->pipe) != PIPE_ISOCHRONOUS &&\n\t\t    urb->actual_length > 0) {\n\t\t\tif (urb->num_sgs) {\n\t\t\t\tunsigned int copy = urb->actual_length;\n\t\t\t\tint size;\n\n\t\t\t\tfor_each_sg(urb->sg, sg, urb->num_sgs, i) {\n\t\t\t\t\tif (copy == 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (copy < sg->length)\n\t\t\t\t\t\tsize = copy;\n\t\t\t\t\telse\n\t\t\t\t\t\tsize = sg->length;\n\n\t\t\t\t\tiov[iovnum].iov_base = sg_virt(sg);\n\t\t\t\t\tiov[iovnum].iov_len = size;\n\n\t\t\t\t\tiovnum++;\n\t\t\t\t\tcopy -= size;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tiov[iovnum].iov_base = urb->transfer_buffer;\n\t\t\t\tiov[iovnum].iov_len  = urb->actual_length;\n\t\t\t\tiovnum++;\n\t\t\t}\n\t\t\ttxsize += urb->actual_length;\n\t\t} else if (usb_pipein(urb->pipe) &&\n\t\t\t   usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\t \n\n\t\t\tint i;\n\n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\t\tiov[iovnum].iov_base = urb->transfer_buffer +\n\t\t\t\t\turb->iso_frame_desc[i].offset;\n\t\t\t\tiov[iovnum].iov_len =\n\t\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t\t\t\tiovnum++;\n\t\t\t\ttxsize += urb->iso_frame_desc[i].actual_length;\n\t\t\t}\n\n\t\t\tif (txsize != sizeof(pdu_header) + urb->actual_length) {\n\t\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\t\"actual length of urb %d does not match iso packet sizes %zu\\n\",\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\ttxsize-sizeof(pdu_header));\n\t\t\t\tkfree(iov);\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_TCP);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t\tssize_t len = 0;\n\n\t\t\tiso_buffer = usbip_alloc_iso_desc_pdu(urb, &len);\n\t\t\tif (!iso_buffer) {\n\t\t\t\tusbip_event_add(&sdev->ud,\n\t\t\t\t\t\tSDEV_EVENT_ERROR_MALLOC);\n\t\t\t\tkfree(iov);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tiov[iovnum].iov_base = iso_buffer;\n\t\t\tiov[iovnum].iov_len  = len;\n\t\t\ttxsize += len;\n\t\t\tiovnum++;\n\t\t}\n\n\t\tret = kernel_sendmsg(sdev->ud.tcp_socket, &msg,\n\t\t\t\t\t\tiov,  iovnum, txsize);\n\t\tif (ret != txsize) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"sendmsg failed!, retval %d for %zd\\n\",\n\t\t\t\tret, txsize);\n\t\t\tkfree(iov);\n\t\t\tkfree(iso_buffer);\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn -1;\n\t\t}\n\n\t\tkfree(iov);\n\t\tkfree(iso_buffer);\n\n\t\ttotal_size += txsize;\n\t}\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\tlist_for_each_entry_safe(priv, tmp, &sdev->priv_free, list) {\n\t\tstub_free_priv_and_urb(priv);\n\t}\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn total_size;\n}\n\nstatic struct stub_unlink *dequeue_from_unlink_tx(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_unlink *unlink, *tmp;\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_tx, list) {\n\t\tlist_move_tail(&unlink->list, &sdev->unlink_free);\n\t\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\t\treturn unlink;\n\t}\n\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn NULL;\n}\n\nstatic int stub_send_ret_unlink(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_unlink *unlink, *tmp;\n\n\tstruct msghdr msg;\n\tstruct kvec iov[1];\n\tsize_t txsize;\n\n\tsize_t total_size = 0;\n\n\twhile ((unlink = dequeue_from_unlink_tx(sdev)) != NULL) {\n\t\tint ret;\n\t\tstruct usbip_header pdu_header;\n\n\t\ttxsize = 0;\n\t\tmemset(&pdu_header, 0, sizeof(pdu_header));\n\t\tmemset(&msg, 0, sizeof(msg));\n\t\tmemset(&iov, 0, sizeof(iov));\n\n\t\tusbip_dbg_stub_tx(\"setup ret unlink %lu\\n\", unlink->seqnum);\n\n\t\t \n\t\tsetup_ret_unlink_pdu(&pdu_header, unlink);\n\t\tusbip_header_correct_endian(&pdu_header, 1);\n\n\t\tiov[0].iov_base = &pdu_header;\n\t\tiov[0].iov_len  = sizeof(pdu_header);\n\t\ttxsize += sizeof(pdu_header);\n\n\t\tret = kernel_sendmsg(sdev->ud.tcp_socket, &msg, iov,\n\t\t\t\t     1, txsize);\n\t\tif (ret != txsize) {\n\t\t\tdev_err(&sdev->udev->dev,\n\t\t\t\t\"sendmsg failed!, retval %d for %zd\\n\",\n\t\t\t\tret, txsize);\n\t\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_ERROR_TCP);\n\t\t\treturn -1;\n\t\t}\n\n\t\tusbip_dbg_stub_tx(\"send txdata\\n\");\n\t\ttotal_size += txsize;\n\t}\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_free, list) {\n\t\tlist_del(&unlink->list);\n\t\tkfree(unlink);\n\t}\n\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn total_size;\n}\n\nint stub_tx_loop(void *data)\n{\n\tstruct usbip_device *ud = data;\n\tstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (usbip_event_happened(ud))\n\t\t\tbreak;\n\n\t\t \n\t\tif (stub_send_ret_submit(sdev) < 0)\n\t\t\tbreak;\n\n\t\tif (stub_send_ret_unlink(sdev) < 0)\n\t\t\tbreak;\n\n\t\twait_event_interruptible(sdev->tx_waitq,\n\t\t\t\t\t (!list_empty(&sdev->priv_tx) ||\n\t\t\t\t\t  !list_empty(&sdev->unlink_tx) ||\n\t\t\t\t\t  kthread_should_stop()));\n\t}\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}