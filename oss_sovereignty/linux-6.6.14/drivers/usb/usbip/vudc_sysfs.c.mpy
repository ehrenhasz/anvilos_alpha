{
  "module_name": "vudc_sysfs.c",
  "hash_id": "a63ff4b85a02ef2aec2870be1637bc70cc30270d40763ac3099f2a673d491ae3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_sysfs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/list.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/ch9.h>\n#include <linux/sysfs.h>\n#include <linux/kthread.h>\n#include <linux/byteorder/generic.h>\n\n#include \"usbip_common.h\"\n#include \"vudc.h\"\n\n#include <net/sock.h>\n\n \nint get_gadget_descs(struct vudc *udc)\n{\n\tstruct vrequest *usb_req;\n\tstruct vep *ep0 = to_vep(udc->gadget.ep0);\n\tstruct usb_device_descriptor *ddesc = &udc->dev_desc;\n\tstruct usb_ctrlrequest req;\n\tint ret;\n\n\tif (!udc->driver || !udc->pullup)\n\t\treturn -EINVAL;\n\n\treq.bRequestType = USB_DIR_IN | USB_TYPE_STANDARD | USB_RECIP_DEVICE;\n\treq.bRequest = USB_REQ_GET_DESCRIPTOR;\n\treq.wValue = cpu_to_le16(USB_DT_DEVICE << 8);\n\treq.wIndex = cpu_to_le16(0);\n\treq.wLength = cpu_to_le16(sizeof(*ddesc));\n\n\tspin_unlock(&udc->lock);\n\tret = udc->driver->setup(&(udc->gadget), &req);\n\tspin_lock(&udc->lock);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t \n\tusb_req = list_last_entry(&ep0->req_queue, struct vrequest, req_entry);\n\tlist_del(&usb_req->req_entry);\n\n\tif (usb_req->req.length > sizeof(*ddesc)) {\n\t\tret = -EOVERFLOW;\n\t\tgoto giveback_req;\n\t}\n\n\tmemcpy(ddesc, usb_req->req.buf, sizeof(*ddesc));\n\tudc->desc_cached = 1;\n\tret = 0;\ngiveback_req:\n\tusb_req->req.status = 0;\n\tusb_req->req.actual = usb_req->req.length;\n\tusb_gadget_giveback_request(&(ep0->ep), &(usb_req->req));\nout:\n\treturn ret;\n}\n\n \nstatic ssize_t dev_desc_read(struct file *file, struct kobject *kobj,\n\t\t\t     struct bin_attribute *attr, char *out,\n\t\t\t     loff_t off, size_t count)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct vudc *udc = (struct vudc *)dev_get_drvdata(dev);\n\tchar *desc_ptr = (char *) &udc->dev_desc;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (!udc->desc_cached) {\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tmemcpy(out, desc_ptr + off, count);\n\tret = count;\nunlock:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\nstatic BIN_ATTR_RO(dev_desc, sizeof(struct usb_device_descriptor));\n\nstatic ssize_t usbip_sockfd_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *in, size_t count)\n{\n\tstruct vudc *udc = (struct vudc *) dev_get_drvdata(dev);\n\tint rv;\n\tint sockfd = 0;\n\tint err;\n\tstruct socket *socket;\n\tunsigned long flags;\n\tint ret;\n\tstruct task_struct *tcp_rx = NULL;\n\tstruct task_struct *tcp_tx = NULL;\n\n\trv = kstrtoint(in, 0, &sockfd);\n\tif (rv != 0)\n\t\treturn -EINVAL;\n\n\tif (!udc) {\n\t\tdev_err(dev, \"no device\");\n\t\treturn -ENODEV;\n\t}\n\tmutex_lock(&udc->ud.sysfs_lock);\n\tspin_lock_irqsave(&udc->lock, flags);\n\t \n\tif (!udc->driver || !udc->pullup) {\n\t\tdev_err(dev, \"gadget not bound\");\n\t\tret = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tif (sockfd != -1) {\n\t\tif (udc->connected) {\n\t\t\tdev_err(dev, \"Device already connected\");\n\t\t\tret = -EBUSY;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tspin_lock(&udc->ud.lock);\n\n\t\tif (udc->ud.status != SDEV_ST_AVAILABLE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_ud;\n\t\t}\n\n\t\tsocket = sockfd_lookup(sockfd, &err);\n\t\tif (!socket) {\n\t\t\tdev_err(dev, \"failed to lookup sock\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_ud;\n\t\t}\n\n\t\tif (socket->type != SOCK_STREAM) {\n\t\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n\t\t\t\tsocket->type);\n\t\t\tret = -EINVAL;\n\t\t\tgoto sock_err;\n\t\t}\n\n\t\t \n\t\tspin_unlock(&udc->ud.lock);\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\t\ttcp_rx = kthread_create(&v_rx_loop, &udc->ud, \"vudc_rx\");\n\t\tif (IS_ERR(tcp_rx)) {\n\t\t\tsockfd_put(socket);\n\t\t\tmutex_unlock(&udc->ud.sysfs_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\ttcp_tx = kthread_create(&v_tx_loop, &udc->ud, \"vudc_tx\");\n\t\tif (IS_ERR(tcp_tx)) {\n\t\t\tkthread_stop(tcp_rx);\n\t\t\tsockfd_put(socket);\n\t\t\tmutex_unlock(&udc->ud.sysfs_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t \n\t\tget_task_struct(tcp_rx);\n\t\tget_task_struct(tcp_tx);\n\n\t\t \n\t\tspin_lock_irqsave(&udc->lock, flags);\n\t\tspin_lock(&udc->ud.lock);\n\n\t\tudc->ud.tcp_socket = socket;\n\t\tudc->ud.tcp_rx = tcp_rx;\n\t\tudc->ud.tcp_tx = tcp_tx;\n\t\tudc->ud.status = SDEV_ST_USED;\n\n\t\tspin_unlock(&udc->ud.lock);\n\n\t\tktime_get_ts64(&udc->start_time);\n\t\tv_start_timer(udc);\n\t\tudc->connected = 1;\n\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\t\twake_up_process(udc->ud.tcp_rx);\n\t\twake_up_process(udc->ud.tcp_tx);\n\n\t\tmutex_unlock(&udc->ud.sysfs_lock);\n\t\treturn count;\n\n\t} else {\n\t\tif (!udc->connected) {\n\t\t\tdev_err(dev, \"Device not connected\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tspin_lock(&udc->ud.lock);\n\t\tif (udc->ud.status != SDEV_ST_USED) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto unlock_ud;\n\t\t}\n\t\tspin_unlock(&udc->ud.lock);\n\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_DOWN);\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tmutex_unlock(&udc->ud.sysfs_lock);\n\n\treturn count;\n\nsock_err:\n\tsockfd_put(socket);\nunlock_ud:\n\tspin_unlock(&udc->ud.lock);\nunlock:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tmutex_unlock(&udc->ud.sysfs_lock);\n\n\treturn ret;\n}\nstatic DEVICE_ATTR_WO(usbip_sockfd);\n\nstatic ssize_t usbip_status_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *out)\n{\n\tstruct vudc *udc = (struct vudc *) dev_get_drvdata(dev);\n\tint status;\n\n\tif (!udc) {\n\t\tdev_err(dev, \"no device\");\n\t\treturn -ENODEV;\n\t}\n\tspin_lock_irq(&udc->ud.lock);\n\tstatus = udc->ud.status;\n\tspin_unlock_irq(&udc->ud.lock);\n\n\treturn sysfs_emit(out, \"%d\\n\", status);\n}\nstatic DEVICE_ATTR_RO(usbip_status);\n\nstatic struct attribute *dev_attrs[] = {\n\t&dev_attr_usbip_sockfd.attr,\n\t&dev_attr_usbip_status.attr,\n\tNULL,\n};\n\nstatic struct bin_attribute *dev_bin_attrs[] = {\n\t&bin_attr_dev_desc,\n\tNULL,\n};\n\nstatic const struct attribute_group vudc_attr_group = {\n\t.attrs = dev_attrs,\n\t.bin_attrs = dev_bin_attrs,\n};\n\nconst struct attribute_group *vudc_groups[] = {\n\t&vudc_attr_group,\n\tNULL,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}