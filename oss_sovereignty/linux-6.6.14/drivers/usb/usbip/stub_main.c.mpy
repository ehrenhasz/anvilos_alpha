{
  "module_name": "stub_main.c",
  "hash_id": "92abde310e08f14d176f6a7f1cf8b9391efd3b25abd6cbe1cae969c9ecf0ec85",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/stub_main.c",
  "human_readable_source": "\n \n\n#include <linux/string.h>\n#include <linux/module.h>\n#include <linux/device.h>\n#include <linux/scatterlist.h>\n\n#include \"usbip_common.h\"\n#include \"stub.h\"\n\n#define DRIVER_AUTHOR \"Takahiro Hirofuchi\"\n#define DRIVER_DESC \"USB/IP Host Driver\"\n\nstruct kmem_cache *stub_priv_cache;\n\n \n#define MAX_BUSID 16\nstatic struct bus_id_priv busid_table[MAX_BUSID];\nstatic DEFINE_SPINLOCK(busid_table_lock);\n\nstatic void init_busid_table(void)\n{\n\tint i;\n\n\t \n\tmemset(busid_table, 0, sizeof(busid_table));\n\n\tfor (i = 0; i < MAX_BUSID; i++)\n\t\tspin_lock_init(&busid_table[i].busid_lock);\n}\n\n \nstatic int get_busid_idx(const char *busid)\n{\n\tint i;\n\tint idx = -1;\n\n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tspin_lock(&busid_table[i].busid_lock);\n\t\tif (busid_table[i].name[0])\n\t\t\tif (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {\n\t\t\t\tidx = i;\n\t\t\t\tspin_unlock(&busid_table[i].busid_lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tspin_unlock(&busid_table[i].busid_lock);\n\t}\n\treturn idx;\n}\n\n \nstruct bus_id_priv *get_busid_priv(const char *busid)\n{\n\tint idx;\n\tstruct bus_id_priv *bid = NULL;\n\n\tspin_lock(&busid_table_lock);\n\tidx = get_busid_idx(busid);\n\tif (idx >= 0) {\n\t\tbid = &(busid_table[idx]);\n\t\t \n\t\tspin_lock(&bid->busid_lock);\n\t}\n\tspin_unlock(&busid_table_lock);\n\n\treturn bid;\n}\n\nvoid put_busid_priv(struct bus_id_priv *bid)\n{\n\tif (bid)\n\t\tspin_unlock(&bid->busid_lock);\n}\n\nstatic int add_match_busid(char *busid)\n{\n\tint i;\n\tint ret = -1;\n\n\tspin_lock(&busid_table_lock);\n\t \n\tif (get_busid_idx(busid) >= 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tspin_lock(&busid_table[i].busid_lock);\n\t\tif (!busid_table[i].name[0]) {\n\t\t\tstrscpy(busid_table[i].name, busid, BUSID_SIZE);\n\t\t\tif ((busid_table[i].status != STUB_BUSID_ALLOC) &&\n\t\t\t    (busid_table[i].status != STUB_BUSID_REMOV))\n\t\t\t\tbusid_table[i].status = STUB_BUSID_ADDED;\n\t\t\tret = 0;\n\t\t\tspin_unlock(&busid_table[i].busid_lock);\n\t\t\tbreak;\n\t\t}\n\t\tspin_unlock(&busid_table[i].busid_lock);\n\t}\n\nout:\n\tspin_unlock(&busid_table_lock);\n\n\treturn ret;\n}\n\nint del_match_busid(char *busid)\n{\n\tint idx;\n\tint ret = -1;\n\n\tspin_lock(&busid_table_lock);\n\tidx = get_busid_idx(busid);\n\tif (idx < 0)\n\t\tgoto out;\n\n\t \n\tret = 0;\n\n\tspin_lock(&busid_table[idx].busid_lock);\n\n\tif (busid_table[idx].status == STUB_BUSID_OTHER)\n\t\tmemset(busid_table[idx].name, 0, BUSID_SIZE);\n\n\tif ((busid_table[idx].status != STUB_BUSID_OTHER) &&\n\t    (busid_table[idx].status != STUB_BUSID_ADDED))\n\t\tbusid_table[idx].status = STUB_BUSID_REMOV;\n\n\tspin_unlock(&busid_table[idx].busid_lock);\nout:\n\tspin_unlock(&busid_table_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t match_busid_show(struct device_driver *drv, char *buf)\n{\n\tint i;\n\tchar *out = buf;\n\n\tspin_lock(&busid_table_lock);\n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tspin_lock(&busid_table[i].busid_lock);\n\t\tif (busid_table[i].name[0])\n\t\t\tout += sprintf(out, \"%s \", busid_table[i].name);\n\t\tspin_unlock(&busid_table[i].busid_lock);\n\t}\n\tspin_unlock(&busid_table_lock);\n\tout += sprintf(out, \"\\n\");\n\n\treturn out - buf;\n}\n\nstatic ssize_t match_busid_store(struct device_driver *dev, const char *buf,\n\t\t\t\t size_t count)\n{\n\tchar busid[BUSID_SIZE];\n\n\tif (count < 5)\n\t\treturn -EINVAL;\n\n\t \n\tif (strscpy(busid, buf + 4, BUSID_SIZE) < 0)\n\t\treturn -EINVAL;\n\n\tif (!strncmp(buf, \"add \", 4)) {\n\t\tif (add_match_busid(busid) < 0)\n\t\t\treturn -ENOMEM;\n\n\t\tpr_debug(\"add busid %s\\n\", busid);\n\t\treturn count;\n\t}\n\n\tif (!strncmp(buf, \"del \", 4)) {\n\t\tif (del_match_busid(busid) < 0)\n\t\t\treturn -ENODEV;\n\n\t\tpr_debug(\"del busid %s\\n\", busid);\n\t\treturn count;\n\t}\n\n\treturn -EINVAL;\n}\nstatic DRIVER_ATTR_RW(match_busid);\n\nstatic int do_rebind(char *busid, struct bus_id_priv *busid_priv)\n{\n\tint ret = 0;\n\n\t \n\tif (busid_priv->udev->dev.parent)\n\t\tdevice_lock(busid_priv->udev->dev.parent);\n\tret = device_attach(&busid_priv->udev->dev);\n\tif (busid_priv->udev->dev.parent)\n\t\tdevice_unlock(busid_priv->udev->dev.parent);\n\tif (ret < 0)\n\t\tdev_err(&busid_priv->udev->dev, \"rebind failed\\n\");\n\treturn ret;\n}\n\nstatic void stub_device_rebind(void)\n{\n#if IS_MODULE(CONFIG_USBIP_HOST)\n\tstruct bus_id_priv *busid_priv;\n\tint i;\n\n\t \n\tspin_lock(&busid_table_lock);\n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tif (busid_table[i].name[0] &&\n\t\t    busid_table[i].shutdown_busid) {\n\t\t\tbusid_priv = &(busid_table[i]);\n\t\t\tbusid_priv->status = STUB_BUSID_OTHER;\n\t\t}\n\t}\n\tspin_unlock(&busid_table_lock);\n\n\t \n\tfor (i = 0; i < MAX_BUSID; i++) {\n\t\tif (busid_table[i].name[0] &&\n\t\t    busid_table[i].shutdown_busid) {\n\t\t\tbusid_priv = &(busid_table[i]);\n\t\t\tdo_rebind(busid_table[i].name, busid_priv);\n\t\t}\n\t}\n#endif\n}\n\nstatic ssize_t rebind_store(struct device_driver *dev, const char *buf,\n\t\t\t\t size_t count)\n{\n\tint ret;\n\tint len;\n\tstruct bus_id_priv *bid;\n\n\t \n\tlen = strnlen(buf, BUSID_SIZE);\n\n\tif (!(len < BUSID_SIZE))\n\t\treturn -EINVAL;\n\n\tbid = get_busid_priv(buf);\n\tif (!bid)\n\t\treturn -ENODEV;\n\n\t \n\tbid->status = STUB_BUSID_OTHER;\n\t \n\tput_busid_priv(bid);\n\n\tret = do_rebind((char *) buf, bid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t \n\tdel_match_busid((char *) buf);\n\n\treturn count;\n}\n\nstatic DRIVER_ATTR_WO(rebind);\n\nstatic struct stub_priv *stub_priv_pop_from_listhead(struct list_head *listhead)\n{\n\tstruct stub_priv *priv, *tmp;\n\n\tlist_for_each_entry_safe(priv, tmp, listhead, list) {\n\t\tlist_del_init(&priv->list);\n\t\treturn priv;\n\t}\n\n\treturn NULL;\n}\n\nvoid stub_free_priv_and_urb(struct stub_priv *priv)\n{\n\tstruct urb *urb;\n\tint i;\n\n\tfor (i = 0; i < priv->num_urbs; i++) {\n\t\turb = priv->urbs[i];\n\n\t\tif (!urb)\n\t\t\treturn;\n\n\t\tkfree(urb->setup_packet);\n\t\turb->setup_packet = NULL;\n\n\n\t\tif (urb->transfer_buffer && !priv->sgl) {\n\t\t\tkfree(urb->transfer_buffer);\n\t\t\turb->transfer_buffer = NULL;\n\t\t}\n\n\t\tif (urb->num_sgs) {\n\t\t\tsgl_free(urb->sg);\n\t\t\turb->sg = NULL;\n\t\t\turb->num_sgs = 0;\n\t\t}\n\n\t\tusb_free_urb(urb);\n\t}\n\tif (!list_empty(&priv->list))\n\t\tlist_del(&priv->list);\n\tif (priv->sgl)\n\t\tsgl_free(priv->sgl);\n\tkfree(priv->urbs);\n\tkmem_cache_free(stub_priv_cache, priv);\n}\n\nstatic struct stub_priv *stub_priv_pop(struct stub_device *sdev)\n{\n\tunsigned long flags;\n\tstruct stub_priv *priv;\n\n\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\n\tpriv = stub_priv_pop_from_listhead(&sdev->priv_init);\n\tif (priv)\n\t\tgoto done;\n\n\tpriv = stub_priv_pop_from_listhead(&sdev->priv_tx);\n\tif (priv)\n\t\tgoto done;\n\n\tpriv = stub_priv_pop_from_listhead(&sdev->priv_free);\n\ndone:\n\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\n\treturn priv;\n}\n\nvoid stub_device_cleanup_urbs(struct stub_device *sdev)\n{\n\tstruct stub_priv *priv;\n\tint i;\n\n\tdev_dbg(&sdev->udev->dev, \"Stub device cleaning up urbs\\n\");\n\n\twhile ((priv = stub_priv_pop(sdev))) {\n\t\tfor (i = 0; i < priv->num_urbs; i++)\n\t\t\tusb_kill_urb(priv->urbs[i]);\n\n\t\tstub_free_priv_and_urb(priv);\n\t}\n}\n\nstatic int __init usbip_host_init(void)\n{\n\tint ret;\n\n\tinit_busid_table();\n\n\tstub_priv_cache = KMEM_CACHE(stub_priv, SLAB_HWCACHE_ALIGN);\n\tif (!stub_priv_cache) {\n\t\tpr_err(\"kmem_cache_create failed\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = usb_register_device_driver(&stub_driver, THIS_MODULE);\n\tif (ret) {\n\t\tpr_err(\"usb_register failed %d\\n\", ret);\n\t\tgoto err_usb_register;\n\t}\n\n\tret = driver_create_file(&stub_driver.drvwrap.driver,\n\t\t\t\t &driver_attr_match_busid);\n\tif (ret) {\n\t\tpr_err(\"driver_create_file failed\\n\");\n\t\tgoto err_create_file;\n\t}\n\n\tret = driver_create_file(&stub_driver.drvwrap.driver,\n\t\t\t\t &driver_attr_rebind);\n\tif (ret) {\n\t\tpr_err(\"driver_create_file failed\\n\");\n\t\tgoto err_create_file;\n\t}\n\n\treturn ret;\n\nerr_create_file:\n\tusb_deregister_device_driver(&stub_driver);\nerr_usb_register:\n\tkmem_cache_destroy(stub_priv_cache);\n\treturn ret;\n}\n\nstatic void __exit usbip_host_exit(void)\n{\n\tdriver_remove_file(&stub_driver.drvwrap.driver,\n\t\t\t   &driver_attr_match_busid);\n\n\tdriver_remove_file(&stub_driver.drvwrap.driver,\n\t\t\t   &driver_attr_rebind);\n\n\t \n\tusb_deregister_device_driver(&stub_driver);\n\n\t \n\tstub_device_rebind();\n\n\tkmem_cache_destroy(stub_priv_cache);\n}\n\nmodule_init(usbip_host_init);\nmodule_exit(usbip_host_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}