{
  "module_name": "stub_dev.c",
  "hash_id": "6e383504d37e51f353b46087ff9331303a1d88948aea851e8b0625e97d5f7265",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/stub_dev.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/file.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n\n#include \"usbip_common.h\"\n#include \"stub.h\"\n\n \nstatic ssize_t usbip_status_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct stub_device *sdev = dev_get_drvdata(dev);\n\tint status;\n\n\tif (!sdev) {\n\t\tdev_err(dev, \"sdev is null\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irq(&sdev->ud.lock);\n\tstatus = sdev->ud.status;\n\tspin_unlock_irq(&sdev->ud.lock);\n\n\treturn sysfs_emit(buf, \"%d\\n\", status);\n}\nstatic DEVICE_ATTR_RO(usbip_status);\n\n \nstatic ssize_t usbip_sockfd_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct stub_device *sdev = dev_get_drvdata(dev);\n\tint sockfd = 0;\n\tstruct socket *socket;\n\tint rv;\n\tstruct task_struct *tcp_rx = NULL;\n\tstruct task_struct *tcp_tx = NULL;\n\n\tif (!sdev) {\n\t\tdev_err(dev, \"sdev is null\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trv = sscanf(buf, \"%d\", &sockfd);\n\tif (rv != 1)\n\t\treturn -EINVAL;\n\n\tif (sockfd != -1) {\n\t\tint err;\n\n\t\tdev_info(dev, \"stub up\\n\");\n\n\t\tmutex_lock(&sdev->ud.sysfs_lock);\n\t\tspin_lock_irq(&sdev->ud.lock);\n\n\t\tif (sdev->ud.status != SDEV_ST_AVAILABLE) {\n\t\t\tdev_err(dev, \"not ready\\n\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tsocket = sockfd_lookup(sockfd, &err);\n\t\tif (!socket) {\n\t\t\tdev_err(dev, \"failed to lookup sock\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (socket->type != SOCK_STREAM) {\n\t\t\tdev_err(dev, \"Expecting SOCK_STREAM - found %d\",\n\t\t\t\tsocket->type);\n\t\t\tgoto sock_err;\n\t\t}\n\n\t\t \n\t\tspin_unlock_irq(&sdev->ud.lock);\n\t\ttcp_rx = kthread_create(stub_rx_loop, &sdev->ud, \"stub_rx\");\n\t\tif (IS_ERR(tcp_rx)) {\n\t\t\tsockfd_put(socket);\n\t\t\tgoto unlock_mutex;\n\t\t}\n\t\ttcp_tx = kthread_create(stub_tx_loop, &sdev->ud, \"stub_tx\");\n\t\tif (IS_ERR(tcp_tx)) {\n\t\t\tkthread_stop(tcp_rx);\n\t\t\tsockfd_put(socket);\n\t\t\tgoto unlock_mutex;\n\t\t}\n\n\t\t \n\t\tget_task_struct(tcp_rx);\n\t\tget_task_struct(tcp_tx);\n\n\t\t \n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tsdev->ud.tcp_socket = socket;\n\t\tsdev->ud.sockfd = sockfd;\n\t\tsdev->ud.tcp_rx = tcp_rx;\n\t\tsdev->ud.tcp_tx = tcp_tx;\n\t\tsdev->ud.status = SDEV_ST_USED;\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\n\t\twake_up_process(sdev->ud.tcp_rx);\n\t\twake_up_process(sdev->ud.tcp_tx);\n\n\t\tmutex_unlock(&sdev->ud.sysfs_lock);\n\n\t} else {\n\t\tdev_info(dev, \"stub down\\n\");\n\n\t\tmutex_lock(&sdev->ud.sysfs_lock);\n\n\t\tspin_lock_irq(&sdev->ud.lock);\n\t\tif (sdev->ud.status != SDEV_ST_USED)\n\t\t\tgoto err;\n\n\t\tspin_unlock_irq(&sdev->ud.lock);\n\n\t\tusbip_event_add(&sdev->ud, SDEV_EVENT_DOWN);\n\t\tmutex_unlock(&sdev->ud.sysfs_lock);\n\t}\n\n\treturn count;\n\nsock_err:\n\tsockfd_put(socket);\nerr:\n\tspin_unlock_irq(&sdev->ud.lock);\nunlock_mutex:\n\tmutex_unlock(&sdev->ud.sysfs_lock);\n\treturn -EINVAL;\n}\nstatic DEVICE_ATTR_WO(usbip_sockfd);\n\nstatic struct attribute *usbip_attrs[] = {\n\t&dev_attr_usbip_status.attr,\n\t&dev_attr_usbip_sockfd.attr,\n\t&dev_attr_usbip_debug.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(usbip);\n\nstatic void stub_shutdown_connection(struct usbip_device *ud)\n{\n\tstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\n\n\t \n\tif (ud->tcp_socket) {\n\t\tdev_dbg(&sdev->udev->dev, \"shutdown sockfd %d\\n\", ud->sockfd);\n\t\tkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\n\t}\n\n\t \n\tif (ud->tcp_rx) {\n\t\tkthread_stop_put(ud->tcp_rx);\n\t\tud->tcp_rx = NULL;\n\t}\n\tif (ud->tcp_tx) {\n\t\tkthread_stop_put(ud->tcp_tx);\n\t\tud->tcp_tx = NULL;\n\t}\n\n\t \n\tif (ud->tcp_socket) {\n\t\tsockfd_put(ud->tcp_socket);\n\t\tud->tcp_socket = NULL;\n\t\tud->sockfd = -1;\n\t}\n\n\t \n\tstub_device_cleanup_urbs(sdev);\n\n\t \n\t{\n\t\tunsigned long flags;\n\t\tstruct stub_unlink *unlink, *tmp;\n\n\t\tspin_lock_irqsave(&sdev->priv_lock, flags);\n\t\tlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_tx, list) {\n\t\t\tlist_del(&unlink->list);\n\t\t\tkfree(unlink);\n\t\t}\n\t\tlist_for_each_entry_safe(unlink, tmp, &sdev->unlink_free,\n\t\t\t\t\t list) {\n\t\t\tlist_del(&unlink->list);\n\t\t\tkfree(unlink);\n\t\t}\n\t\tspin_unlock_irqrestore(&sdev->priv_lock, flags);\n\t}\n}\n\nstatic void stub_device_reset(struct usbip_device *ud)\n{\n\tstruct stub_device *sdev = container_of(ud, struct stub_device, ud);\n\tstruct usb_device *udev = sdev->udev;\n\tint ret;\n\n\tdev_dbg(&udev->dev, \"device reset\");\n\n\tret = usb_lock_device_for_reset(udev, NULL);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev, \"lock for reset\\n\");\n\t\tspin_lock_irq(&ud->lock);\n\t\tud->status = SDEV_ST_ERROR;\n\t\tspin_unlock_irq(&ud->lock);\n\t\treturn;\n\t}\n\n\t \n\tret = usb_reset_device(udev);\n\tusb_unlock_device(udev);\n\n\tspin_lock_irq(&ud->lock);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"device reset\\n\");\n\t\tud->status = SDEV_ST_ERROR;\n\t} else {\n\t\tdev_info(&udev->dev, \"device reset\\n\");\n\t\tud->status = SDEV_ST_AVAILABLE;\n\t}\n\tspin_unlock_irq(&ud->lock);\n}\n\nstatic void stub_device_unusable(struct usbip_device *ud)\n{\n\tspin_lock_irq(&ud->lock);\n\tud->status = SDEV_ST_ERROR;\n\tspin_unlock_irq(&ud->lock);\n}\n\n \nstatic struct stub_device *stub_device_alloc(struct usb_device *udev)\n{\n\tstruct stub_device *sdev;\n\tint busnum = udev->bus->busnum;\n\tint devnum = udev->devnum;\n\n\tdev_dbg(&udev->dev, \"allocating stub device\");\n\n\t \n\tsdev = kzalloc(sizeof(struct stub_device), GFP_KERNEL);\n\tif (!sdev)\n\t\treturn NULL;\n\n\tsdev->udev = usb_get_dev(udev);\n\n\t \n\tsdev->devid\t\t= (busnum << 16) | devnum;\n\tsdev->ud.side\t\t= USBIP_STUB;\n\tsdev->ud.status\t\t= SDEV_ST_AVAILABLE;\n\tspin_lock_init(&sdev->ud.lock);\n\tmutex_init(&sdev->ud.sysfs_lock);\n\tsdev->ud.tcp_socket\t= NULL;\n\tsdev->ud.sockfd\t\t= -1;\n\n\tINIT_LIST_HEAD(&sdev->priv_init);\n\tINIT_LIST_HEAD(&sdev->priv_tx);\n\tINIT_LIST_HEAD(&sdev->priv_free);\n\tINIT_LIST_HEAD(&sdev->unlink_free);\n\tINIT_LIST_HEAD(&sdev->unlink_tx);\n\tspin_lock_init(&sdev->priv_lock);\n\n\tinit_waitqueue_head(&sdev->tx_waitq);\n\n\tsdev->ud.eh_ops.shutdown = stub_shutdown_connection;\n\tsdev->ud.eh_ops.reset    = stub_device_reset;\n\tsdev->ud.eh_ops.unusable = stub_device_unusable;\n\n\tusbip_start_eh(&sdev->ud);\n\n\tdev_dbg(&udev->dev, \"register new device\\n\");\n\n\treturn sdev;\n}\n\nstatic void stub_device_free(struct stub_device *sdev)\n{\n\tkfree(sdev);\n}\n\nstatic int stub_probe(struct usb_device *udev)\n{\n\tstruct stub_device *sdev = NULL;\n\tconst char *udev_busid = dev_name(&udev->dev);\n\tstruct bus_id_priv *busid_priv;\n\tint rc = 0;\n\tchar save_status;\n\n\tdev_dbg(&udev->dev, \"Enter probe\\n\");\n\n\t \n\tsdev = stub_device_alloc(udev);\n\tif (!sdev)\n\t\treturn -ENOMEM;\n\n\t \n\tbusid_priv = get_busid_priv(udev_busid);\n\tif (!busid_priv || (busid_priv->status == STUB_BUSID_REMOV) ||\n\t    (busid_priv->status == STUB_BUSID_OTHER)) {\n\t\tdev_info(&udev->dev,\n\t\t\t\"%s is not in match_busid table... skip!\\n\",\n\t\t\tudev_busid);\n\n\t\t \n\t\trc = -ENODEV;\n\t\tif (!busid_priv)\n\t\t\tgoto sdev_free;\n\n\t\tgoto call_put_busid_priv;\n\t}\n\n\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {\n\t\tdev_dbg(&udev->dev, \"%s is a usb hub device... skip!\\n\",\n\t\t\t udev_busid);\n\t\trc = -ENODEV;\n\t\tgoto call_put_busid_priv;\n\t}\n\n\tif (!strcmp(udev->bus->bus_name, \"vhci_hcd\")) {\n\t\tdev_dbg(&udev->dev,\n\t\t\t\"%s is attached on vhci_hcd... skip!\\n\",\n\t\t\tudev_busid);\n\n\t\trc = -ENODEV;\n\t\tgoto call_put_busid_priv;\n\t}\n\n\n\tdev_info(&udev->dev,\n\t\t\"usbip-host: register new device (bus %u dev %u)\\n\",\n\t\tudev->bus->busnum, udev->devnum);\n\n\tbusid_priv->shutdown_busid = 0;\n\n\t \n\tdev_set_drvdata(&udev->dev, sdev);\n\n\tbusid_priv->sdev = sdev;\n\tbusid_priv->udev = udev;\n\n\tsave_status = busid_priv->status;\n\tbusid_priv->status = STUB_BUSID_ALLOC;\n\n\t \n\tput_busid_priv(busid_priv);\n\n\t \n\trc = usb_hub_claim_port(udev->parent, udev->portnum,\n\t\t\t(struct usb_dev_state *) udev);\n\tif (rc) {\n\t\tdev_dbg(&udev->dev, \"unable to claim port\\n\");\n\t\tgoto err_port;\n\t}\n\n\treturn 0;\n\nerr_port:\n\tdev_set_drvdata(&udev->dev, NULL);\n\n\t \n\tspin_lock(&busid_priv->busid_lock);\n\tbusid_priv->sdev = NULL;\n\tbusid_priv->status = save_status;\n\tspin_unlock(&busid_priv->busid_lock);\n\t \n\tgoto sdev_free;\n\ncall_put_busid_priv:\n\t \n\tput_busid_priv(busid_priv);\n\nsdev_free:\n\tusb_put_dev(udev);\n\tstub_device_free(sdev);\n\n\treturn rc;\n}\n\nstatic void shutdown_busid(struct bus_id_priv *busid_priv)\n{\n\tusbip_event_add(&busid_priv->sdev->ud, SDEV_EVENT_REMOVED);\n\n\t \n\tusbip_stop_eh(&busid_priv->sdev->ud);\n}\n\n \nstatic void stub_disconnect(struct usb_device *udev)\n{\n\tstruct stub_device *sdev;\n\tconst char *udev_busid = dev_name(&udev->dev);\n\tstruct bus_id_priv *busid_priv;\n\tint rc;\n\n\tdev_dbg(&udev->dev, \"Enter disconnect\\n\");\n\n\tbusid_priv = get_busid_priv(udev_busid);\n\tif (!busid_priv) {\n\t\tBUG();\n\t\treturn;\n\t}\n\n\tsdev = dev_get_drvdata(&udev->dev);\n\n\t \n\tif (!sdev) {\n\t\tdev_err(&udev->dev, \"could not get device\");\n\t\t \n\t\tput_busid_priv(busid_priv);\n\t\treturn;\n\t}\n\n\tdev_set_drvdata(&udev->dev, NULL);\n\n\t \n\tput_busid_priv(busid_priv);\n\n\t \n\n\t \n\trc = usb_hub_release_port(udev->parent, udev->portnum,\n\t\t\t\t  (struct usb_dev_state *) udev);\n\t \n\tif (rc && (rc != -ENODEV)) {\n\t\tdev_dbg(&udev->dev, \"unable to release port (%i)\\n\", rc);\n\t\treturn;\n\t}\n\n\t \n\tif (usbip_in_eh(current))\n\t\treturn;\n\n\t \n\tspin_lock(&busid_priv->busid_lock);\n\tif (!busid_priv->shutdown_busid)\n\t\tbusid_priv->shutdown_busid = 1;\n\t \n\tspin_unlock(&busid_priv->busid_lock);\n\n\t \n\tshutdown_busid(busid_priv);\n\n\tusb_put_dev(sdev->udev);\n\n\t \n\tspin_lock(&busid_priv->busid_lock);\n\t \n\tbusid_priv->sdev = NULL;\n\tstub_device_free(sdev);\n\n\tif (busid_priv->status == STUB_BUSID_ALLOC)\n\t\tbusid_priv->status = STUB_BUSID_ADDED;\n\t \n\tspin_unlock(&busid_priv->busid_lock);\n\treturn;\n}\n\n#ifdef CONFIG_PM\n\n \n\nstatic int stub_suspend(struct usb_device *udev, pm_message_t message)\n{\n\tdev_dbg(&udev->dev, \"stub_suspend\\n\");\n\n\treturn 0;\n}\n\nstatic int stub_resume(struct usb_device *udev, pm_message_t message)\n{\n\tdev_dbg(&udev->dev, \"stub_resume\\n\");\n\n\treturn 0;\n}\n\n#endif\t \n\nstruct usb_device_driver stub_driver = {\n\t.name\t\t= \"usbip-host\",\n\t.probe\t\t= stub_probe,\n\t.disconnect\t= stub_disconnect,\n#ifdef CONFIG_PM\n\t.suspend\t= stub_suspend,\n\t.resume\t\t= stub_resume,\n#endif\n\t.supports_autosuspend\t=\t0,\n\t.dev_groups\t= usbip_groups,\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}