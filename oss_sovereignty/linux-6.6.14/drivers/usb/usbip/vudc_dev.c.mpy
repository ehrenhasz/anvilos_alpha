{
  "module_name": "vudc_dev.c",
  "hash_id": "6bc2e6cbfdc7eccb0f8c6e232f1487fafa75e2f2b8e10a9f38a0e561a94014e1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_dev.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/hcd.h>\n#include <linux/kthread.h>\n#include <linux/file.h>\n#include <linux/byteorder/generic.h>\n\n#include \"usbip_common.h\"\n#include \"vudc.h\"\n\n#define VIRTUAL_ENDPOINTS (1   + 15   + 15  )\n\n \n\n\nstatic void free_urb(struct urb *urb)\n{\n\tif (!urb)\n\t\treturn;\n\n\tkfree(urb->setup_packet);\n\turb->setup_packet = NULL;\n\n\tkfree(urb->transfer_buffer);\n\turb->transfer_buffer = NULL;\n\n\tusb_free_urb(urb);\n}\n\nstruct urbp *alloc_urbp(void)\n{\n\tstruct urbp *urb_p;\n\n\turb_p = kzalloc(sizeof(*urb_p), GFP_KERNEL);\n\tif (!urb_p)\n\t\treturn urb_p;\n\n\turb_p->urb = NULL;\n\turb_p->ep = NULL;\n\tINIT_LIST_HEAD(&urb_p->urb_entry);\n\treturn urb_p;\n}\n\nstatic void free_urbp(struct urbp *urb_p)\n{\n\tkfree(urb_p);\n}\n\nvoid free_urbp_and_urb(struct urbp *urb_p)\n{\n\tif (!urb_p)\n\t\treturn;\n\tfree_urb(urb_p->urb);\n\tfree_urbp(urb_p);\n}\n\n\n \n\n \nstatic void nuke(struct vudc *udc, struct vep *ep)\n{\n\tstruct vrequest\t*req;\n\n\twhile (!list_empty(&ep->req_queue)) {\n\t\treq = list_first_entry(&ep->req_queue, struct vrequest,\n\t\t\t\t       req_entry);\n\t\tlist_del_init(&req->req_entry);\n\t\treq->req.status = -ESHUTDOWN;\n\n\t\tspin_unlock(&udc->lock);\n\t\tusb_gadget_giveback_request(&ep->ep, &req->req);\n\t\tspin_lock(&udc->lock);\n\t}\n}\n\n \nstatic void stop_activity(struct vudc *udc)\n{\n\tint i;\n\tstruct urbp *urb_p, *tmp;\n\n\tudc->address = 0;\n\n\tfor (i = 0; i < VIRTUAL_ENDPOINTS; i++)\n\t\tnuke(udc, &udc->ep[i]);\n\n\tlist_for_each_entry_safe(urb_p, tmp, &udc->urb_queue, urb_entry) {\n\t\tlist_del(&urb_p->urb_entry);\n\t\tfree_urbp_and_urb(urb_p);\n\t}\n}\n\nstruct vep *vudc_find_endpoint(struct vudc *udc, u8 address)\n{\n\tint i;\n\n\tif ((address & ~USB_DIR_IN) == 0)\n\t\treturn &udc->ep[0];\n\n\tfor (i = 1; i < VIRTUAL_ENDPOINTS; i++) {\n\t\tstruct vep *ep = &udc->ep[i];\n\n\t\tif (!ep->desc)\n\t\t\tcontinue;\n\t\tif (ep->desc->bEndpointAddress == address)\n\t\t\treturn ep;\n\t}\n\treturn NULL;\n}\n\n \n\nstatic int vgadget_get_frame(struct usb_gadget *_gadget)\n{\n\tstruct timespec64 now;\n\tstruct vudc *udc = usb_gadget_to_vudc(_gadget);\n\n\tktime_get_ts64(&now);\n\treturn ((now.tv_sec - udc->start_time.tv_sec) * 1000 +\n\t\t(now.tv_nsec - udc->start_time.tv_nsec) / NSEC_PER_MSEC)\n\t\t\t& 0x7FF;\n}\n\nstatic int vgadget_set_selfpowered(struct usb_gadget *_gadget, int value)\n{\n\tstruct vudc *udc = usb_gadget_to_vudc(_gadget);\n\n\tif (value)\n\t\tudc->devstatus |= (1 << USB_DEVICE_SELF_POWERED);\n\telse\n\t\tudc->devstatus &= ~(1 << USB_DEVICE_SELF_POWERED);\n\treturn 0;\n}\n\nstatic int vgadget_pullup(struct usb_gadget *_gadget, int value)\n{\n\tstruct vudc *udc = usb_gadget_to_vudc(_gadget);\n\tunsigned long flags;\n\tint ret;\n\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tvalue = !!value;\n\tif (value == udc->pullup)\n\t\tgoto unlock;\n\n\tudc->pullup = value;\n\tif (value) {\n\t\tudc->gadget.speed = min_t(u8, USB_SPEED_HIGH,\n\t\t\t\t\t   udc->driver->max_speed);\n\t\tudc->ep[0].ep.maxpacket = 64;\n\t\t \n\t\tret = get_gadget_descs(udc);\n\t\tif (ret) {\n\t\t\tdev_err(&udc->gadget.dev, \"Unable go get desc: %d\", ret);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\tusbip_start_eh(&udc->ud);\n\t} else {\n\t\t \n\t\tudc->desc_cached = 0;\n\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_REMOVED);\n\t\tusbip_stop_eh(&udc->ud);  \n\t}\n\n\treturn 0;\n\nunlock:\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic int vgadget_udc_start(struct usb_gadget *g,\n\t\tstruct usb_gadget_driver *driver)\n{\n\tstruct vudc *udc = usb_gadget_to_vudc(g);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->driver = driver;\n\tudc->pullup = udc->connected = udc->desc_cached = 0;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vgadget_udc_stop(struct usb_gadget *g)\n{\n\tstruct vudc *udc = usb_gadget_to_vudc(g);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tudc->driver = NULL;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn 0;\n}\n\nstatic const struct usb_gadget_ops vgadget_ops = {\n\t.get_frame\t= vgadget_get_frame,\n\t.set_selfpowered = vgadget_set_selfpowered,\n\t.pullup\t\t= vgadget_pullup,\n\t.udc_start\t= vgadget_udc_start,\n\t.udc_stop\t= vgadget_udc_stop,\n};\n\n\n \n\nstatic int vep_enable(struct usb_ep *_ep,\n\t\tconst struct usb_endpoint_descriptor *desc)\n{\n\tstruct vep\t*ep;\n\tstruct vudc\t*udc;\n\tunsigned int\tmaxp;\n\tunsigned long\tflags;\n\n\tep = to_vep(_ep);\n\tudc = ep_to_vudc(ep);\n\n\tif (!_ep || !desc || ep->desc || _ep->caps.type_control\n\t\t\t|| desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn -EINVAL;\n\n\tif (!udc->driver)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\n\tmaxp = usb_endpoint_maxp(desc);\n\t_ep->maxpacket = maxp;\n\tep->desc = desc;\n\tep->type = usb_endpoint_type(desc);\n\tep->halted = ep->wedged = 0;\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vep_disable(struct usb_ep *_ep)\n{\n\tstruct vep *ep;\n\tstruct vudc *udc;\n\tunsigned long flags;\n\n\tep = to_vep(_ep);\n\tudc = ep_to_vudc(ep);\n\tif (!_ep || !ep->desc || _ep->caps.type_control)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tep->desc = NULL;\n\tnuke(udc, ep);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic struct usb_request *vep_alloc_request(struct usb_ep *_ep,\n\t\tgfp_t mem_flags)\n{\n\tstruct vrequest *req;\n\n\tif (!_ep)\n\t\treturn NULL;\n\n\treq = kzalloc(sizeof(*req), mem_flags);\n\tif (!req)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&req->req_entry);\n\n\treturn &req->req;\n}\n\nstatic void vep_free_request(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct vrequest *req;\n\n\t \n\tif (!_req)\n\t\treturn;\n\n\treq = to_vrequest(_req);\n\tkfree(req);\n}\n\nstatic int vep_queue(struct usb_ep *_ep, struct usb_request *_req,\n\t\tgfp_t mem_flags)\n{\n\tstruct vep *ep;\n\tstruct vrequest *req;\n\tstruct vudc *udc;\n\tunsigned long flags;\n\n\tif (!_ep || !_req)\n\t\treturn -EINVAL;\n\n\tep = to_vep(_ep);\n\treq = to_vrequest(_req);\n\tudc = ep_to_vudc(ep);\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\t_req->actual = 0;\n\t_req->status = -EINPROGRESS;\n\n\tlist_add_tail(&req->req_entry, &ep->req_queue);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int vep_dequeue(struct usb_ep *_ep, struct usb_request *_req)\n{\n\tstruct vep *ep;\n\tstruct vrequest *req;\n\tstruct vudc *udc;\n\tstruct vrequest *lst;\n\tunsigned long flags;\n\tint ret = -EINVAL;\n\n\tif (!_ep || !_req)\n\t\treturn ret;\n\n\tep = to_vep(_ep);\n\treq = to_vrequest(_req);\n\tudc = req->udc;\n\n\tif (!udc->driver)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tlist_for_each_entry(lst, &ep->req_queue, req_entry) {\n\t\tif (&lst->req == _req) {\n\t\t\tlist_del_init(&lst->req_entry);\n\t\t\t_req->status = -ECONNRESET;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\tif (ret == 0)\n\t\tusb_gadget_giveback_request(_ep, _req);\n\n\treturn ret;\n}\n\nstatic int\nvep_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)\n{\n\tstruct vep *ep;\n\tstruct vudc *udc;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tep = to_vep(_ep);\n\tif (!_ep)\n\t\treturn -EINVAL;\n\n\tudc = ep_to_vudc(ep);\n\tif (!udc->driver)\n\t\treturn -ESHUTDOWN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tif (!value)\n\t\tep->halted = ep->wedged = 0;\n\telse if (ep->desc && (ep->desc->bEndpointAddress & USB_DIR_IN) &&\n\t\t\t!list_empty(&ep->req_queue))\n\t\tret = -EAGAIN;\n\telse {\n\t\tep->halted = 1;\n\t\tif (wedged)\n\t\t\tep->wedged = 1;\n\t}\n\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\treturn ret;\n}\n\nstatic int\nvep_set_halt(struct usb_ep *_ep, int value)\n{\n\treturn vep_set_halt_and_wedge(_ep, value, 0);\n}\n\nstatic int vep_set_wedge(struct usb_ep *_ep)\n{\n\treturn vep_set_halt_and_wedge(_ep, 1, 1);\n}\n\nstatic const struct usb_ep_ops vep_ops = {\n\t.enable\t\t= vep_enable,\n\t.disable\t= vep_disable,\n\n\t.alloc_request\t= vep_alloc_request,\n\t.free_request\t= vep_free_request,\n\n\t.queue\t\t= vep_queue,\n\t.dequeue\t= vep_dequeue,\n\n\t.set_halt\t= vep_set_halt,\n\t.set_wedge\t= vep_set_wedge,\n};\n\n\n \n\nstatic void vudc_shutdown(struct usbip_device *ud)\n{\n\tstruct vudc *udc = container_of(ud, struct vudc, ud);\n\tint call_disconnect = 0;\n\tunsigned long flags;\n\n\tdev_dbg(&udc->pdev->dev, \"device shutdown\");\n\tif (ud->tcp_socket)\n\t\tkernel_sock_shutdown(ud->tcp_socket, SHUT_RDWR);\n\n\tif (ud->tcp_rx) {\n\t\tkthread_stop_put(ud->tcp_rx);\n\t\tud->tcp_rx = NULL;\n\t}\n\tif (ud->tcp_tx) {\n\t\tkthread_stop_put(ud->tcp_tx);\n\t\tud->tcp_tx = NULL;\n\t}\n\n\tif (ud->tcp_socket) {\n\t\tsockfd_put(ud->tcp_socket);\n\t\tud->tcp_socket = NULL;\n\t}\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tstop_activity(udc);\n\tif (udc->connected && udc->driver->disconnect)\n\t\tcall_disconnect = 1;\n\tudc->connected = 0;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tif (call_disconnect)\n\t\tudc->driver->disconnect(&udc->gadget);\n}\n\nstatic void vudc_device_reset(struct usbip_device *ud)\n{\n\tstruct vudc *udc = container_of(ud, struct vudc, ud);\n\tunsigned long flags;\n\n\tdev_dbg(&udc->pdev->dev, \"device reset\");\n\tspin_lock_irqsave(&udc->lock, flags);\n\tstop_activity(udc);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\tif (udc->driver)\n\t\tusb_gadget_udc_reset(&udc->gadget, udc->driver);\n\tspin_lock_irqsave(&ud->lock, flags);\n\tud->status = SDEV_ST_AVAILABLE;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\nstatic void vudc_device_unusable(struct usbip_device *ud)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ud->lock, flags);\n\tud->status = SDEV_ST_ERROR;\n\tspin_unlock_irqrestore(&ud->lock, flags);\n}\n\n \n\nstruct vudc_device *alloc_vudc_device(int devid)\n{\n\tstruct vudc_device *udc_dev;\n\n\tudc_dev = kzalloc(sizeof(*udc_dev), GFP_KERNEL);\n\tif (!udc_dev)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&udc_dev->dev_entry);\n\n\tudc_dev->pdev = platform_device_alloc(GADGET_NAME, devid);\n\tif (!udc_dev->pdev) {\n\t\tkfree(udc_dev);\n\t\tudc_dev = NULL;\n\t}\n\n\treturn udc_dev;\n}\n\nvoid put_vudc_device(struct vudc_device *udc_dev)\n{\n\tplatform_device_put(udc_dev->pdev);\n\tkfree(udc_dev);\n}\n\nstatic int init_vudc_hw(struct vudc *udc)\n{\n\tint i;\n\tstruct usbip_device *ud = &udc->ud;\n\tstruct vep *ep;\n\n\tudc->ep = kcalloc(VIRTUAL_ENDPOINTS, sizeof(*udc->ep), GFP_KERNEL);\n\tif (!udc->ep)\n\t\tgoto nomem_ep;\n\n\tINIT_LIST_HEAD(&udc->gadget.ep_list);\n\n\t \n\tfor (i = 0; i < VIRTUAL_ENDPOINTS; ++i) {\n\t\tint is_out = i % 2;\n\t\tint num = (i + 1) / 2;\n\n\t\tep = &udc->ep[i];\n\n\t\tsprintf(ep->name, \"ep%d%s\", num,\n\t\t\ti ? (is_out ? \"out\" : \"in\") : \"\");\n\t\tep->ep.name = ep->name;\n\n\t\tep->ep.ops = &vep_ops;\n\n\t\tusb_ep_set_maxpacket_limit(&ep->ep, ~0);\n\t\tep->ep.max_streams = 16;\n\t\tep->gadget = &udc->gadget;\n\t\tINIT_LIST_HEAD(&ep->req_queue);\n\n\t\tif (i == 0) {\n\t\t\t \n\t\t\tep->ep.caps.type_control = true;\n\t\t\tep->ep.caps.dir_out = true;\n\t\t\tep->ep.caps.dir_in = true;\n\n\t\t\tudc->gadget.ep0 = &ep->ep;\n\t\t} else {\n\t\t\t \n\t\t\tep->ep.caps.type_iso = true;\n\t\t\tep->ep.caps.type_int = true;\n\t\t\tep->ep.caps.type_bulk = true;\n\n\t\t\tif (is_out)\n\t\t\t\tep->ep.caps.dir_out = true;\n\t\t\telse\n\t\t\t\tep->ep.caps.dir_in = true;\n\n\t\t\tlist_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);\n\t\t}\n\t}\n\n\tspin_lock_init(&udc->lock);\n\tspin_lock_init(&udc->lock_tx);\n\tINIT_LIST_HEAD(&udc->urb_queue);\n\tINIT_LIST_HEAD(&udc->tx_queue);\n\tinit_waitqueue_head(&udc->tx_waitq);\n\n\tspin_lock_init(&ud->lock);\n\tmutex_init(&ud->sysfs_lock);\n\tud->status = SDEV_ST_AVAILABLE;\n\tud->side = USBIP_VUDC;\n\n\tud->eh_ops.shutdown = vudc_shutdown;\n\tud->eh_ops.reset    = vudc_device_reset;\n\tud->eh_ops.unusable = vudc_device_unusable;\n\n\tv_init_timer(udc);\n\treturn 0;\n\nnomem_ep:\n\t\treturn -ENOMEM;\n}\n\nstatic void cleanup_vudc_hw(struct vudc *udc)\n{\n\tkfree(udc->ep);\n}\n\n \n\nint vudc_probe(struct platform_device *pdev)\n{\n\tstruct vudc *udc;\n\tint ret = -ENOMEM;\n\n\tudc = kzalloc(sizeof(*udc), GFP_KERNEL);\n\tif (!udc)\n\t\tgoto out;\n\n\tudc->gadget.name = GADGET_NAME;\n\tudc->gadget.ops = &vgadget_ops;\n\tudc->gadget.max_speed = USB_SPEED_HIGH;\n\tudc->gadget.dev.parent = &pdev->dev;\n\tudc->pdev = pdev;\n\n\tret = init_vudc_hw(udc);\n\tif (ret)\n\t\tgoto err_init_vudc_hw;\n\n\tret = usb_add_gadget_udc(&pdev->dev, &udc->gadget);\n\tif (ret < 0)\n\t\tgoto err_add_udc;\n\n\tplatform_set_drvdata(pdev, udc);\n\n\treturn ret;\n\nerr_add_udc:\n\tcleanup_vudc_hw(udc);\nerr_init_vudc_hw:\n\tkfree(udc);\nout:\n\treturn ret;\n}\n\nint vudc_remove(struct platform_device *pdev)\n{\n\tstruct vudc *udc = platform_get_drvdata(pdev);\n\n\tusb_del_gadget_udc(&udc->gadget);\n\tcleanup_vudc_hw(udc);\n\tkfree(udc);\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}