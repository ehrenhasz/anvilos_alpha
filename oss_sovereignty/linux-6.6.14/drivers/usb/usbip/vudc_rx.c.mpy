{
  "module_name": "vudc_rx.c",
  "hash_id": "e609ba37b266e10a1fb0fb45cb5153a2c57c29880ed38c27bb8ca0050a77548f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/usbip/vudc_rx.c",
  "human_readable_source": "\n \n\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/kthread.h>\n\n#include \"usbip_common.h\"\n#include \"vudc.h\"\n\nstatic int alloc_urb_from_cmd(struct urb **urbp,\n\t\t\t      struct usbip_header *pdu, u8 type)\n{\n\tstruct urb *urb;\n\n\tif (type == USB_ENDPOINT_XFER_ISOC)\n\t\turb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets,\n\t\t\t\t\t  GFP_KERNEL);\n\telse\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!urb)\n\t\tgoto err;\n\n\tusbip_pack_pdu(pdu, urb, USBIP_CMD_SUBMIT, 0);\n\n\tif (urb->transfer_buffer_length > 0) {\n\t\turb->transfer_buffer = kzalloc(urb->transfer_buffer_length,\n\t\t\tGFP_KERNEL);\n\t\tif (!urb->transfer_buffer)\n\t\t\tgoto free_urb;\n\t}\n\n\turb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8,\n\t\t\t    GFP_KERNEL);\n\tif (!urb->setup_packet)\n\t\tgoto free_buffer;\n\n\t \n\turb->pipe |= pdu->base.direction == USBIP_DIR_IN ?\n\t\t\tUSB_DIR_IN : USB_DIR_OUT;\n\n\t*urbp = urb;\n\treturn 0;\n\nfree_buffer:\n\tkfree(urb->transfer_buffer);\n\turb->transfer_buffer = NULL;\nfree_urb:\n\tusb_free_urb(urb);\nerr:\n\treturn -ENOMEM;\n}\n\nstatic int v_recv_cmd_unlink(struct vudc *udc,\n\t\t\t\tstruct usbip_header *pdu)\n{\n\tunsigned long flags;\n\tstruct urbp *urb_p;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tlist_for_each_entry(urb_p, &udc->urb_queue, urb_entry) {\n\t\tif (urb_p->seqnum != pdu->u.cmd_unlink.seqnum)\n\t\t\tcontinue;\n\t\turb_p->urb->unlinked = -ECONNRESET;\n\t\turb_p->seqnum = pdu->base.seqnum;\n\t\tv_kick_timer(udc, jiffies);\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\treturn 0;\n\t}\n\t \n\tspin_lock(&udc->lock_tx);\n\tv_enqueue_ret_unlink(udc, pdu->base.seqnum, 0);\n\twake_up(&udc->tx_waitq);\n\tspin_unlock(&udc->lock_tx);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n}\n\nstatic int v_recv_cmd_submit(struct vudc *udc,\n\t\t\t\t struct usbip_header *pdu)\n{\n\tint ret = 0;\n\tstruct urbp *urb_p;\n\tu8 address;\n\tunsigned long flags;\n\n\turb_p = alloc_urbp();\n\tif (!urb_p) {\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_MALLOC);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\taddress = pdu->base.ep;\n\tif (pdu->base.direction == USBIP_DIR_IN)\n\t\taddress |= USB_DIR_IN;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\turb_p->ep = vudc_find_endpoint(udc, address);\n\tif (!urb_p->ep) {\n\t\t \n\t\tdev_err(&udc->pdev->dev, \"request to nonexistent endpoint\");\n\t\tspin_unlock_irqrestore(&udc->lock, flags);\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_TCP);\n\t\tret = -EPIPE;\n\t\tgoto free_urbp;\n\t}\n\turb_p->type = urb_p->ep->type;\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\turb_p->new = 1;\n\turb_p->seqnum = pdu->base.seqnum;\n\n\tif (urb_p->ep->type == USB_ENDPOINT_XFER_ISOC) {\n\t\t \n\t\tunsigned int maxp, packets, bytes;\n\n\t\tmaxp = usb_endpoint_maxp(urb_p->ep->desc);\n\t\tmaxp *= usb_endpoint_maxp_mult(urb_p->ep->desc);\n\t\tbytes = pdu->u.cmd_submit.transfer_buffer_length;\n\t\tpackets = DIV_ROUND_UP(bytes, maxp);\n\n\t\tif (pdu->u.cmd_submit.number_of_packets < 0 ||\n\t\t    pdu->u.cmd_submit.number_of_packets > packets) {\n\t\t\tdev_err(&udc->gadget.dev,\n\t\t\t\t\"CMD_SUBMIT: isoc invalid num packets %d\\n\",\n\t\t\t\tpdu->u.cmd_submit.number_of_packets);\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto free_urbp;\n\t\t}\n\t}\n\n\tret = alloc_urb_from_cmd(&urb_p->urb, pdu, urb_p->ep->type);\n\tif (ret) {\n\t\tusbip_event_add(&udc->ud, VUDC_EVENT_ERROR_MALLOC);\n\t\tret = -ENOMEM;\n\t\tgoto free_urbp;\n\t}\n\n\turb_p->urb->status = -EINPROGRESS;\n\n\t \n\tBUILD_BUG_ON_MSG(PIPE_BULK != 3, \"PIPE_* doesn't range from 0 to 3\");\n\n\turb_p->urb->pipe &= ~(PIPE_BULK << 30);\n\tswitch (urb_p->ep->type) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\turb_p->urb->pipe |= (PIPE_BULK << 30);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\turb_p->urb->pipe |= (PIPE_INTERRUPT << 30);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\turb_p->urb->pipe |= (PIPE_CONTROL << 30);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\turb_p->urb->pipe |= (PIPE_ISOCHRONOUS << 30);\n\t\tbreak;\n\t}\n\tret = usbip_recv_xbuff(&udc->ud, urb_p->urb);\n\tif (ret < 0)\n\t\tgoto free_urbp;\n\n\tret = usbip_recv_iso(&udc->ud, urb_p->urb);\n\tif (ret < 0)\n\t\tgoto free_urbp;\n\n\tspin_lock_irqsave(&udc->lock, flags);\n\tv_kick_timer(udc, jiffies);\n\tlist_add_tail(&urb_p->urb_entry, &udc->urb_queue);\n\tspin_unlock_irqrestore(&udc->lock, flags);\n\n\treturn 0;\n\nfree_urbp:\n\tfree_urbp_and_urb(urb_p);\n\treturn ret;\n}\n\nstatic int v_rx_pdu(struct usbip_device *ud)\n{\n\tint ret;\n\tstruct usbip_header pdu;\n\tstruct vudc *udc = container_of(ud, struct vudc, ud);\n\n\tmemset(&pdu, 0, sizeof(pdu));\n\tret = usbip_recv(ud->tcp_socket, &pdu, sizeof(pdu));\n\tif (ret != sizeof(pdu)) {\n\t\tusbip_event_add(ud, VUDC_EVENT_ERROR_TCP);\n\t\tif (ret >= 0)\n\t\t\treturn -EPIPE;\n\t\treturn ret;\n\t}\n\tusbip_header_correct_endian(&pdu, 0);\n\n\tspin_lock_irq(&ud->lock);\n\tret = (ud->status == SDEV_ST_USED);\n\tspin_unlock_irq(&ud->lock);\n\tif (!ret) {\n\t\tusbip_event_add(ud, VUDC_EVENT_ERROR_TCP);\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (pdu.base.command) {\n\tcase USBIP_CMD_UNLINK:\n\t\tret = v_recv_cmd_unlink(udc, &pdu);\n\t\tbreak;\n\tcase USBIP_CMD_SUBMIT:\n\t\tret = v_recv_cmd_submit(udc, &pdu);\n\t\tbreak;\n\tdefault:\n\t\tret = -EPIPE;\n\t\tpr_err(\"rx: unknown command\");\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint v_rx_loop(void *data)\n{\n\tstruct usbip_device *ud = data;\n\tint ret = 0;\n\n\twhile (!kthread_should_stop()) {\n\t\tif (usbip_event_happened(ud))\n\t\t\tbreak;\n\t\tret = v_rx_pdu(ud);\n\t\tif (ret < 0) {\n\t\t\tpr_warn(\"v_rx exit with error %d\", ret);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}