{
  "module_name": "upd78f0730.c",
  "hash_id": "b8d8f39944414a5edf2ba1d04d9ebca0b6fee17f5d33813761c6c840447da865",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/upd78f0730.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_DESC \"Renesas uPD78F0730 USB to serial converter driver\"\n\n#define DRIVER_AUTHOR \"Maksim Salau <maksim.salau@gmail.com>\"\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x0409, 0x0063) },  \n\t{ USB_DEVICE(0x045B, 0x0212) },  \n\t{ USB_DEVICE(0x064B, 0x7825) },  \n\t{}\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstruct upd78f0730_port_private {\n\tstruct mutex\tlock;\t\t \n\tu8\t\tline_signals;\n};\n\n \n#define UPD78F0730_CMD_LINE_CONTROL\t0x00\n#define UPD78F0730_CMD_SET_DTR_RTS\t0x01\n#define UPD78F0730_CMD_SET_XON_XOFF_CHR\t0x02\n#define UPD78F0730_CMD_OPEN_CLOSE\t0x03\n#define UPD78F0730_CMD_SET_ERR_CHR\t0x04\n\n \n#define UPD78F0730_DATA_SIZE_7_BITS\t0x00\n#define UPD78F0730_DATA_SIZE_8_BITS\t0x01\n#define UPD78F0730_DATA_SIZE_MASK\t0x01\n\n \n#define UPD78F0730_STOP_BIT_1_BIT\t0x00\n#define UPD78F0730_STOP_BIT_2_BIT\t0x02\n#define UPD78F0730_STOP_BIT_MASK\t0x02\n\n \n#define UPD78F0730_PARITY_NONE\t0x00\n#define UPD78F0730_PARITY_EVEN\t0x04\n#define UPD78F0730_PARITY_ODD\t0x08\n#define UPD78F0730_PARITY_MASK\t0x0C\n\n \n#define UPD78F0730_FLOW_CONTROL_NONE\t0x00\n#define UPD78F0730_FLOW_CONTROL_HW\t0x10\n#define UPD78F0730_FLOW_CONTROL_SW\t0x20\n#define UPD78F0730_FLOW_CONTROL_MASK\t0x30\n\n \n#define UPD78F0730_RTS\t\t0x01\n#define UPD78F0730_DTR\t\t0x02\n#define UPD78F0730_BREAK\t0x04\n\n \n#define UPD78F0730_PORT_CLOSE\t0x00\n#define UPD78F0730_PORT_OPEN\t0x01\n\n \n#define UPD78F0730_ERR_CHR_DISABLED\t0x00\n#define UPD78F0730_ERR_CHR_ENABLED\t0x01\n\n \n\n \nstruct upd78f0730_line_control {\n\tu8\topcode;\n\t__le32\tbaud_rate;\n\tu8\tparams;\n} __packed;\n\n \nstruct upd78f0730_set_dtr_rts {\n\tu8 opcode;\n\tu8 params;\n};\n\n \nstruct upd78f0730_set_xon_xoff_chr {\n\tu8 opcode;\n\tu8 xon;\n\tu8 xoff;\n};\n\n \nstruct upd78f0730_open_close {\n\tu8 opcode;\n\tu8 state;\n};\n\n \nstruct upd78f0730_set_err_chr {\n\tu8 opcode;\n\tu8 state;\n\tu8 err_char;\n};\n\nstatic int upd78f0730_send_ctl(struct usb_serial_port *port,\n\t\t\tconst void *data, int size)\n{\n\tstruct usb_device *usbdev = port->serial->dev;\n\tvoid *buf;\n\tint res;\n\n\tif (size <= 0 || !data)\n\t\treturn -EINVAL;\n\n\tbuf = kmemdup(data, size, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tres = usb_control_msg(usbdev, usb_sndctrlpipe(usbdev, 0), 0x00,\n\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\t0x0000, 0x0000, buf, size, USB_CTRL_SET_TIMEOUT);\n\n\tkfree(buf);\n\n\tif (res < 0) {\n\t\tstruct device *dev = &port->dev;\n\n\t\tdev_err(dev, \"failed to send control request %02x: %d\\n\",\n\t\t\t*(u8 *)data, res);\n\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int upd78f0730_port_probe(struct usb_serial_port *port)\n{\n\tstruct upd78f0730_port_private *private;\n\n\tprivate = kzalloc(sizeof(*private), GFP_KERNEL);\n\tif (!private)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&private->lock);\n\tusb_set_serial_port_data(port, private);\n\n\treturn 0;\n}\n\nstatic void upd78f0730_port_remove(struct usb_serial_port *port)\n{\n\tstruct upd78f0730_port_private *private;\n\n\tprivate = usb_get_serial_port_data(port);\n\tmutex_destroy(&private->lock);\n\tkfree(private);\n}\n\nstatic int upd78f0730_tiocmget(struct tty_struct *tty)\n{\n\tstruct upd78f0730_port_private *private;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tint signals;\n\tint res;\n\n\tprivate = usb_get_serial_port_data(port);\n\n\tmutex_lock(&private->lock);\n\tsignals = private->line_signals;\n\tmutex_unlock(&private->lock);\n\n\tres = ((signals & UPD78F0730_DTR) ? TIOCM_DTR : 0) |\n\t\t((signals & UPD78F0730_RTS) ? TIOCM_RTS : 0);\n\n\tdev_dbg(&port->dev, \"%s - res = %x\\n\", __func__, res);\n\n\treturn res;\n}\n\nstatic int upd78f0730_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct upd78f0730_port_private *private;\n\tstruct upd78f0730_set_dtr_rts request;\n\tstruct device *dev = &port->dev;\n\tint res;\n\n\tprivate = usb_get_serial_port_data(port);\n\n\tmutex_lock(&private->lock);\n\tif (set & TIOCM_DTR) {\n\t\tprivate->line_signals |= UPD78F0730_DTR;\n\t\tdev_dbg(dev, \"%s - set DTR\\n\", __func__);\n\t}\n\tif (set & TIOCM_RTS) {\n\t\tprivate->line_signals |= UPD78F0730_RTS;\n\t\tdev_dbg(dev, \"%s - set RTS\\n\", __func__);\n\t}\n\tif (clear & TIOCM_DTR) {\n\t\tprivate->line_signals &= ~UPD78F0730_DTR;\n\t\tdev_dbg(dev, \"%s - clear DTR\\n\", __func__);\n\t}\n\tif (clear & TIOCM_RTS) {\n\t\tprivate->line_signals &= ~UPD78F0730_RTS;\n\t\tdev_dbg(dev, \"%s - clear RTS\\n\", __func__);\n\t}\n\trequest.opcode = UPD78F0730_CMD_SET_DTR_RTS;\n\trequest.params = private->line_signals;\n\n\tres = upd78f0730_send_ctl(port, &request, sizeof(request));\n\tmutex_unlock(&private->lock);\n\n\treturn res;\n}\n\nstatic int upd78f0730_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct upd78f0730_port_private *private;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct upd78f0730_set_dtr_rts request;\n\tstruct device *dev = &port->dev;\n\tint res;\n\n\tprivate = usb_get_serial_port_data(port);\n\n\tmutex_lock(&private->lock);\n\tif (break_state) {\n\t\tprivate->line_signals |= UPD78F0730_BREAK;\n\t\tdev_dbg(dev, \"%s - set BREAK\\n\", __func__);\n\t} else {\n\t\tprivate->line_signals &= ~UPD78F0730_BREAK;\n\t\tdev_dbg(dev, \"%s - clear BREAK\\n\", __func__);\n\t}\n\trequest.opcode = UPD78F0730_CMD_SET_DTR_RTS;\n\trequest.params = private->line_signals;\n\n\tres = upd78f0730_send_ctl(port, &request, sizeof(request));\n\tmutex_unlock(&private->lock);\n\n\treturn res;\n}\n\nstatic void upd78f0730_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct tty_struct *tty = port->port.tty;\n\tunsigned int set = 0;\n\tunsigned int clear = 0;\n\n\tif (on)\n\t\tset = TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tclear = TIOCM_DTR | TIOCM_RTS;\n\n\tupd78f0730_tiocmset(tty, set, clear);\n}\n\nstatic speed_t upd78f0730_get_baud_rate(struct tty_struct *tty)\n{\n\tconst speed_t baud_rate = tty_get_baud_rate(tty);\n\tstatic const speed_t supported[] = {\n\t\t0, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 153600\n\t};\n\tint i;\n\n\tfor (i = ARRAY_SIZE(supported) - 1; i >= 0; i--) {\n\t\tif (baud_rate == supported[i])\n\t\t\treturn baud_rate;\n\t}\n\n\t \n\ttty_encode_baud_rate(tty, 9600, 9600);\n\n\treturn tty_get_baud_rate(tty);\n}\n\nstatic void upd78f0730_set_termios(struct tty_struct *tty,\n\t\t\t\t   struct usb_serial_port *port,\n\t\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct device *dev = &port->dev;\n\tstruct upd78f0730_line_control request;\n\tspeed_t baud_rate;\n\n\tif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\n\t\treturn;\n\n\tif (C_BAUD(tty) == B0)\n\t\tupd78f0730_dtr_rts(port, 0);\n\telse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\tupd78f0730_dtr_rts(port, 1);\n\n\tbaud_rate = upd78f0730_get_baud_rate(tty);\n\trequest.opcode = UPD78F0730_CMD_LINE_CONTROL;\n\trequest.baud_rate = cpu_to_le32(baud_rate);\n\trequest.params = 0;\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, baud_rate);\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS7:\n\t\trequest.params |= UPD78F0730_DATA_SIZE_7_BITS;\n\t\tdev_dbg(dev, \"%s - 7 data bits\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\t\ttty->termios.c_cflag &= ~CSIZE;\n\t\ttty->termios.c_cflag |= CS8;\n\t\tdev_warn(dev, \"data size is not supported, using 8 bits\\n\");\n\t\tfallthrough;\n\tcase CS8:\n\t\trequest.params |= UPD78F0730_DATA_SIZE_8_BITS;\n\t\tdev_dbg(dev, \"%s - 8 data bits\\n\", __func__);\n\t\tbreak;\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\tif (C_PARODD(tty)) {\n\t\t\trequest.params |= UPD78F0730_PARITY_ODD;\n\t\t\tdev_dbg(dev, \"%s - odd parity\\n\", __func__);\n\t\t} else {\n\t\t\trequest.params |= UPD78F0730_PARITY_EVEN;\n\t\t\tdev_dbg(dev, \"%s - even parity\\n\", __func__);\n\t\t}\n\n\t\tif (C_CMSPAR(tty)) {\n\t\t\ttty->termios.c_cflag &= ~CMSPAR;\n\t\t\tdev_warn(dev, \"MARK/SPACE parity is not supported\\n\");\n\t\t}\n\t} else {\n\t\trequest.params |= UPD78F0730_PARITY_NONE;\n\t\tdev_dbg(dev, \"%s - no parity\\n\", __func__);\n\t}\n\n\tif (C_CSTOPB(tty)) {\n\t\trequest.params |= UPD78F0730_STOP_BIT_2_BIT;\n\t\tdev_dbg(dev, \"%s - 2 stop bits\\n\", __func__);\n\t} else {\n\t\trequest.params |= UPD78F0730_STOP_BIT_1_BIT;\n\t\tdev_dbg(dev, \"%s - 1 stop bit\\n\", __func__);\n\t}\n\n\tif (C_CRTSCTS(tty)) {\n\t\ttty->termios.c_cflag &= ~CRTSCTS;\n\t\tdev_warn(dev, \"RTSCTS flow control is not supported\\n\");\n\t}\n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\ttty->termios.c_iflag &= ~(IXOFF | IXON);\n\t\tdev_warn(dev, \"XON/XOFF flow control is not supported\\n\");\n\t}\n\trequest.params |= UPD78F0730_FLOW_CONTROL_NONE;\n\tdev_dbg(dev, \"%s - no flow control\\n\", __func__);\n\n\tupd78f0730_send_ctl(port, &request, sizeof(request));\n}\n\nstatic int upd78f0730_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstatic const struct upd78f0730_open_close request = {\n\t\t.opcode = UPD78F0730_CMD_OPEN_CLOSE,\n\t\t.state = UPD78F0730_PORT_OPEN\n\t};\n\tint res;\n\n\tres = upd78f0730_send_ctl(port, &request, sizeof(request));\n\tif (res)\n\t\treturn res;\n\n\tif (tty)\n\t\tupd78f0730_set_termios(tty, port, NULL);\n\n\treturn usb_serial_generic_open(tty, port);\n}\n\nstatic void upd78f0730_close(struct usb_serial_port *port)\n{\n\tstatic const struct upd78f0730_open_close request = {\n\t\t.opcode = UPD78F0730_CMD_OPEN_CLOSE,\n\t\t.state = UPD78F0730_PORT_CLOSE\n\t};\n\n\tusb_serial_generic_close(port);\n\tupd78f0730_send_ctl(port, &request, sizeof(request));\n}\n\nstatic struct usb_serial_driver upd78f0730_device = {\n\t.driver\t = {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"upd78f0730\",\n\t},\n\t.id_table\t= id_table,\n\t.num_ports\t= 1,\n\t.port_probe\t= upd78f0730_port_probe,\n\t.port_remove\t= upd78f0730_port_remove,\n\t.open\t\t= upd78f0730_open,\n\t.close\t\t= upd78f0730_close,\n\t.set_termios\t= upd78f0730_set_termios,\n\t.tiocmget\t= upd78f0730_tiocmget,\n\t.tiocmset\t= upd78f0730_tiocmset,\n\t.dtr_rts\t= upd78f0730_dtr_rts,\n\t.break_ctl\t= upd78f0730_break_ctl,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&upd78f0730_device,\n\tNULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}