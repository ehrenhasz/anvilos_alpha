{
  "module_name": "opticon.c",
  "hash_id": "9eeae58b312625e7ef498cc8e21768e8a11222961c79e75369d8dce97d15955c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/opticon.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n\n#define CONTROL_RTS\t\t\t0x02\n#define RESEND_CTS_STATE\t0x03\n\n \n#define URB_UPPER_LIMIT\t8\n\n \n#define DRIVER_DESC\t\"Opticon USB barcode to serial driver (1D)\"\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x065a, 0x0009) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstruct opticon_private {\n\tspinlock_t lock;\t \n\tbool rts;\n\tbool cts;\n\tint outstanding_urbs;\n\tint outstanding_bytes;\n\n\tstruct usb_anchor anchor;\n};\n\n\nstatic void opticon_process_data_packet(struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, size_t len)\n{\n\ttty_insert_flip_string(&port->port, buf, len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void opticon_process_status_packet(struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, size_t len)\n{\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (buf[0] == 0x00)\n\t\tpriv->cts = false;\n\telse\n\t\tpriv->cts = true;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic void opticon_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tconst unsigned char *hdr = urb->transfer_buffer;\n\tconst unsigned char *data = hdr + 2;\n\tsize_t data_len = urb->actual_length - 2;\n\n\tif (urb->actual_length <= 2) {\n\t\tdev_dbg(&port->dev, \"malformed packet received: %d bytes\\n\",\n\t\t\t\t\t\t\turb->actual_length);\n\t\treturn;\n\t}\n\t \n\tif ((hdr[0] == 0x00) && (hdr[1] == 0x00)) {\n\t\topticon_process_data_packet(port, data, data_len);\n\t} else if ((hdr[0] == 0x00) && (hdr[1] == 0x01)) {\n\t\topticon_process_status_packet(port, data, data_len);\n\t} else {\n\t\tdev_dbg(&port->dev, \"unknown packet received: %02x %02x\\n\",\n\t\t\t\t\t\t\thdr[0], hdr[1]);\n\t}\n}\n\nstatic int send_control_msg(struct usb_serial_port *port, u8 requesttype,\n\t\t\t\tu8 val)\n{\n\tstruct usb_serial *serial = port->serial;\n\tint retval;\n\tu8 *buffer;\n\n\tbuffer = kzalloc(1, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tbuffer[0] = val;\n\t \n\tretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\trequesttype,\n\t\t\t\tUSB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t\t0, 0, buffer, 1, USB_CTRL_SET_TIMEOUT);\n\tkfree(buffer);\n\n\tif (retval < 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic int opticon_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint res;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->rts = false;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tsend_control_msg(port, CONTROL_RTS, 0);\n\n\t \n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\n\tres = usb_serial_generic_open(tty, port);\n\tif (res)\n\t\treturn res;\n\n\t \n\tsend_control_msg(port, RESEND_CTS_STATE, 1);\n\n\treturn res;\n}\n\nstatic void opticon_close(struct usb_serial_port *port)\n{\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\n\tusb_kill_anchored_urbs(&priv->anchor);\n\n\tusb_serial_generic_close(port);\n}\n\nstatic void opticon_write_control_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tint status = urb->status;\n\tunsigned long flags;\n\n\t \n\tkfree(urb->transfer_buffer);\n\n\t \n\tkfree(urb->setup_packet);\n\n\tif (status)\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - non-zero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t--priv->outstanding_urbs;\n\tpriv->outstanding_bytes -= urb->transfer_buffer_length;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tusb_serial_port_softint(port);\n}\n\nstatic int opticon_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t const unsigned char *buf, int count)\n{\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tstruct urb *urb;\n\tunsigned char *buffer;\n\tunsigned long flags;\n\tstruct usb_ctrlrequest *dr;\n\tint ret = -ENOMEM;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->outstanding_urbs > URB_UPPER_LIMIT) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tdev_dbg(&port->dev, \"%s - write limit hit\\n\", __func__);\n\t\treturn 0;\n\t}\n\tpriv->outstanding_urbs++;\n\tpriv->outstanding_bytes += count;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tbuffer = kmemdup(buf, count, GFP_ATOMIC);\n\tif (!buffer)\n\t\tgoto error_no_buffer;\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto error_no_urb;\n\n\tusb_serial_debug_data(&port->dev, __func__, count, buffer);\n\n\t \n\tdr = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);\n\tif (!dr)\n\t\tgoto error_no_dr;\n\n\tdr->bRequestType = USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT;\n\tdr->bRequest = 0x01;\n\tdr->wValue = 0;\n\tdr->wIndex = 0;\n\tdr->wLength = cpu_to_le16(count);\n\n\tusb_fill_control_urb(urb, serial->dev,\n\t\tusb_sndctrlpipe(serial->dev, 0),\n\t\t(unsigned char *)dr, buffer, count,\n\t\topticon_write_control_callback, port);\n\n\tusb_anchor_urb(urb, &priv->anchor);\n\n\t \n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to submit write urb: %d\\n\", ret);\n\t\tusb_unanchor_urb(urb);\n\t\tgoto error;\n\t}\n\n\t \n\tusb_free_urb(urb);\n\n\treturn count;\nerror:\n\tkfree(dr);\nerror_no_dr:\n\tusb_free_urb(urb);\nerror_no_urb:\n\tkfree(buffer);\nerror_no_buffer:\n\tspin_lock_irqsave(&priv->lock, flags);\n\t--priv->outstanding_urbs;\n\tpriv->outstanding_bytes -= count;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn ret;\n}\n\nstatic unsigned int opticon_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->outstanding_urbs > URB_UPPER_LIMIT * 2 / 3) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tdev_dbg(&port->dev, \"%s - write limit hit\\n\", __func__);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 2048;\n}\n\nstatic unsigned int opticon_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int count;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcount = priv->outstanding_bytes;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn count;\n}\n\nstatic int opticon_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->rts)\n\t\tresult |= TIOCM_RTS;\n\tif (priv->cts)\n\t\tresult |= TIOCM_CTS;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - %x\\n\", __func__, result);\n\treturn result;\n}\n\nstatic int opticon_tiocmset(struct tty_struct *tty,\n\t\t\t   unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tbool rts;\n\tbool changed = false;\n\tint ret;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\trts = priv->rts;\n\tif (set & TIOCM_RTS)\n\t\tpriv->rts = true;\n\tif (clear & TIOCM_RTS)\n\t\tpriv->rts = false;\n\tchanged = rts ^ priv->rts;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (!changed)\n\t\treturn 0;\n\n\tret = send_control_msg(port, CONTROL_RTS, !rts);\n\tif (ret)\n\t\treturn usb_translate_errors(ret);\n\n\treturn 0;\n}\n\nstatic int opticon_port_probe(struct usb_serial_port *port)\n{\n\tstruct opticon_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tinit_usb_anchor(&priv->anchor);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void opticon_port_remove(struct usb_serial_port *port)\n{\n\tstruct opticon_private *priv = usb_get_serial_port_data(port);\n\n\tkfree(priv);\n}\n\nstatic struct usb_serial_driver opticon_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"opticon\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_bulk_in =\t\t1,\n\t.bulk_in_size =\t\t256,\n\t.port_probe =\t\topticon_port_probe,\n\t.port_remove =\t\topticon_port_remove,\n\t.open =\t\t\topticon_open,\n\t.close =\t\topticon_close,\n\t.write =\t\topticon_write,\n\t.write_room = \t\topticon_write_room,\n\t.chars_in_buffer =\topticon_chars_in_buffer,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.tiocmget =\t\topticon_tiocmget,\n\t.tiocmset =\t\topticon_tiocmset,\n\t.process_read_urb =\topticon_process_read_urb,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&opticon_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}