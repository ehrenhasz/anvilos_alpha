{
  "module_name": "oti6858.c",
  "hash_id": "55c742a71e40915609422a18a4c29e2ebd03573ed00ac8c5c7ea7f22f1a9cb3c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/oti6858.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n#include <linux/kfifo.h>\n#include \"oti6858.h\"\n\n#define OTI6858_DESCRIPTION \\\n\t\"Ours Technology Inc. OTi-6858 USB to serial adapter driver\"\n#define OTI6858_AUTHOR \"Tomasz Michal Lukaszewski <FIXME@FIXME>\"\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(OTI6858_VENDOR_ID, OTI6858_PRODUCT_ID) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \n#define\tOTI6858_REQ_GET_STATUS\t\t(USB_DIR_IN | USB_TYPE_VENDOR | 0x00)\n#define\tOTI6858_REQ_T_GET_STATUS\t0x01\n\n#define\tOTI6858_REQ_SET_LINE\t\t(USB_DIR_OUT | USB_TYPE_VENDOR | 0x00)\n#define\tOTI6858_REQ_T_SET_LINE\t\t0x00\n\n#define\tOTI6858_REQ_CHECK_TXBUFF\t(USB_DIR_IN | USB_TYPE_VENDOR | 0x01)\n#define\tOTI6858_REQ_T_CHECK_TXBUFF\t0x00\n\n \nstruct oti6858_control_pkt {\n\t__le16\tdivisor;\t \n#define OTI6858_MAX_BAUD_RATE\t3000000\n\tu8\tframe_fmt;\n#define FMT_STOP_BITS_MASK\t0xc0\n#define FMT_STOP_BITS_1\t\t0x00\n#define FMT_STOP_BITS_2\t\t0x40\t \n#define FMT_PARITY_MASK\t\t0x38\n#define FMT_PARITY_NONE\t\t0x00\n#define FMT_PARITY_ODD\t\t0x08\n#define FMT_PARITY_EVEN\t\t0x18\n#define FMT_PARITY_MARK\t\t0x28\n#define FMT_PARITY_SPACE\t0x38\n#define FMT_DATA_BITS_MASK\t0x03\n#define FMT_DATA_BITS_5\t\t0x00\n#define FMT_DATA_BITS_6\t\t0x01\n#define FMT_DATA_BITS_7\t\t0x02\n#define FMT_DATA_BITS_8\t\t0x03\n\tu8\tsomething;\t \n\tu8\tcontrol;\t \n#define CONTROL_MASK\t\t0x0c\n#define CONTROL_DTR_HIGH\t0x08\n#define CONTROL_RTS_HIGH\t0x04\n\tu8\ttx_status;\n#define\tTX_BUFFER_EMPTIED\t0x09\n\tu8\tpin_state;\n#define PIN_MASK\t\t0x3f\n#define PIN_MSR_MASK\t\t0x1b\n#define PIN_RTS\t\t\t0x20\t \n#define PIN_CTS\t\t\t0x10\t \n#define PIN_DSR\t\t\t0x08\t \n#define PIN_DTR\t\t\t0x04\t \n#define PIN_RI\t\t\t0x02\t \n#define PIN_DCD\t\t\t0x01\t \n\tu8\trx_bytes_avail;\t\t ;\n};\n\n#define OTI6858_CTRL_PKT_SIZE\tsizeof(struct oti6858_control_pkt)\n#define OTI6858_CTRL_EQUALS_PENDING(a, priv) \\\n\t(((a)->divisor == (priv)->pending_setup.divisor) \\\n\t  && ((a)->control == (priv)->pending_setup.control) \\\n\t  && ((a)->frame_fmt == (priv)->pending_setup.frame_fmt))\n\n \nstatic int oti6858_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void oti6858_close(struct usb_serial_port *port);\nstatic void oti6858_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios);\nstatic void oti6858_init_termios(struct tty_struct *tty);\nstatic void oti6858_read_int_callback(struct urb *urb);\nstatic void oti6858_read_bulk_callback(struct urb *urb);\nstatic void oti6858_write_bulk_callback(struct urb *urb);\nstatic int oti6858_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *buf, int count);\nstatic unsigned int oti6858_write_room(struct tty_struct *tty);\nstatic unsigned int oti6858_chars_in_buffer(struct tty_struct *tty);\nstatic int oti6858_tiocmget(struct tty_struct *tty);\nstatic int oti6858_tiocmset(struct tty_struct *tty,\n\t\t\t\tunsigned int set, unsigned int clear);\nstatic int oti6858_port_probe(struct usb_serial_port *port);\nstatic void oti6858_port_remove(struct usb_serial_port *port);\n\n \nstatic struct usb_serial_driver oti6858_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"oti6858\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_bulk_in =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.num_interrupt_in =\t1,\n\t.open =\t\t\toti6858_open,\n\t.close =\t\toti6858_close,\n\t.write =\t\toti6858_write,\n\t.set_termios =\t\toti6858_set_termios,\n\t.init_termios = \toti6858_init_termios,\n\t.tiocmget =\t\toti6858_tiocmget,\n\t.tiocmset =\t\toti6858_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.read_bulk_callback =\toti6858_read_bulk_callback,\n\t.read_int_callback =\toti6858_read_int_callback,\n\t.write_bulk_callback =\toti6858_write_bulk_callback,\n\t.write_room =\t\toti6858_write_room,\n\t.chars_in_buffer =\toti6858_chars_in_buffer,\n\t.port_probe =\t\toti6858_port_probe,\n\t.port_remove =\t\toti6858_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&oti6858_device, NULL\n};\n\nstruct oti6858_private {\n\tspinlock_t lock;\n\n\tstruct oti6858_control_pkt status;\n\n\tstruct {\n\t\tu8 read_urb_in_use;\n\t\tu8 write_urb_in_use;\n\t} flags;\n\tstruct delayed_work delayed_write_work;\n\n\tstruct {\n\t\t__le16 divisor;\n\t\tu8 frame_fmt;\n\t\tu8 control;\n\t} pending_setup;\n\tu8 transient;\n\tu8 setup_done;\n\tstruct delayed_work delayed_setup_work;\n\n\tstruct usb_serial_port *port;    \n};\n\nstatic void setup_line(struct work_struct *work)\n{\n\tstruct oti6858_private *priv = container_of(work,\n\t\t\tstruct oti6858_private, delayed_setup_work.work);\n\tstruct usb_serial_port *port = priv->port;\n\tstruct oti6858_control_pkt *new_setup;\n\tunsigned long flags;\n\tint result;\n\n\tnew_setup = kmalloc(OTI6858_CTRL_PKT_SIZE, GFP_KERNEL);\n\tif (!new_setup) {\n\t\t \n\t\tschedule_delayed_work(&priv->delayed_setup_work,\n\t\t\t\t\t\tmsecs_to_jiffies(2));\n\t\treturn;\n\t}\n\n\tresult = usb_control_msg(port->serial->dev,\n\t\t\t\tusb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\tOTI6858_REQ_T_GET_STATUS,\n\t\t\t\tOTI6858_REQ_GET_STATUS,\n\t\t\t\t0, 0,\n\t\t\t\tnew_setup, OTI6858_CTRL_PKT_SIZE,\n\t\t\t\t100);\n\n\tif (result != OTI6858_CTRL_PKT_SIZE) {\n\t\tdev_err(&port->dev, \"%s(): error reading status\\n\", __func__);\n\t\tkfree(new_setup);\n\t\t \n\t\tschedule_delayed_work(&priv->delayed_setup_work,\n\t\t\t\t\t\t\tmsecs_to_jiffies(2));\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!OTI6858_CTRL_EQUALS_PENDING(new_setup, priv)) {\n\t\tnew_setup->divisor = priv->pending_setup.divisor;\n\t\tnew_setup->control = priv->pending_setup.control;\n\t\tnew_setup->frame_fmt = priv->pending_setup.frame_fmt;\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t\t\tOTI6858_REQ_T_SET_LINE,\n\t\t\t\t\tOTI6858_REQ_SET_LINE,\n\t\t\t\t\t0, 0,\n\t\t\t\t\tnew_setup, OTI6858_CTRL_PKT_SIZE,\n\t\t\t\t\t100);\n\t} else {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tresult = 0;\n\t}\n\tkfree(new_setup);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (result != OTI6858_CTRL_PKT_SIZE)\n\t\tpriv->transient = 0;\n\tpriv->setup_done = 1;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s(): submitting interrupt urb\\n\", __func__);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result != 0) {\n\t\tdev_err(&port->dev, \"%s(): usb_submit_urb() failed with error %d\\n\",\n\t\t\t__func__, result);\n\t}\n}\n\nstatic void send_data(struct work_struct *work)\n{\n\tstruct oti6858_private *priv = container_of(work,\n\t\t\tstruct oti6858_private, delayed_write_work.work);\n\tstruct usb_serial_port *port = priv->port;\n\tint count = 0, result;\n\tunsigned long flags;\n\tu8 *allow;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->flags.write_urb_in_use) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tschedule_delayed_work(&priv->delayed_write_work,\n\t\t\t\t\t\tmsecs_to_jiffies(2));\n\t\treturn;\n\t}\n\tpriv->flags.write_urb_in_use = 1;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tcount = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (count > port->bulk_out_size)\n\t\tcount = port->bulk_out_size;\n\n\tif (count != 0) {\n\t\tallow = kmalloc(1, GFP_KERNEL);\n\t\tif (!allow)\n\t\t\treturn;\n\n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t\tusb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\tOTI6858_REQ_T_CHECK_TXBUFF,\n\t\t\t\tOTI6858_REQ_CHECK_TXBUFF,\n\t\t\t\tcount, 0, allow, 1, 100);\n\t\tif (result != 1 || *allow != 0)\n\t\t\tcount = 0;\n\t\tkfree(allow);\n\t}\n\n\tif (count == 0) {\n\t\tpriv->flags.write_urb_in_use = 0;\n\n\t\tdev_dbg(&port->dev, \"%s(): submitting interrupt urb\\n\", __func__);\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\n\t\tif (result != 0) {\n\t\t\tdev_err(&port->dev, \"%s(): usb_submit_urb() failed with error %d\\n\",\n\t\t\t\t__func__, result);\n\t\t}\n\t\treturn;\n\t}\n\n\tcount = kfifo_out_locked(&port->write_fifo,\n\t\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\t\tcount, &port->lock);\n\tport->write_urb->transfer_buffer_length = count;\n\tresult = usb_submit_urb(port->write_urb, GFP_NOIO);\n\tif (result != 0) {\n\t\tdev_err_console(port, \"%s(): usb_submit_urb() failed with error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tpriv->flags.write_urb_in_use = 0;\n\t}\n\n\tusb_serial_port_softint(port);\n}\n\nstatic int oti6858_port_probe(struct usb_serial_port *port)\n{\n\tstruct oti6858_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->port = port;\n\tINIT_DELAYED_WORK(&priv->delayed_setup_work, setup_line);\n\tINIT_DELAYED_WORK(&priv->delayed_write_work, send_data);\n\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\t \n\n\treturn 0;\n}\n\nstatic void oti6858_port_remove(struct usb_serial_port *port)\n{\n\tstruct oti6858_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int oti6858_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *buf, int count)\n{\n\tif (!count)\n\t\treturn count;\n\n\tcount = kfifo_in_locked(&port->write_fifo, buf, count, &port->lock);\n\n\treturn count;\n}\n\nstatic unsigned int oti6858_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int room;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn room;\n}\n\nstatic unsigned int oti6858_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int chars;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tchars = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\treturn chars;\n}\n\nstatic void oti6858_init_termios(struct tty_struct *tty)\n{\n\ttty_encode_baud_rate(tty, 38400, 38400);\n}\n\nstatic void oti6858_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int cflag;\n\tu8 frame_fmt, control;\n\t__le16 divisor;\n\tint br;\n\n\tcflag = tty->termios.c_cflag;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tdivisor = priv->pending_setup.divisor;\n\tframe_fmt = priv->pending_setup.frame_fmt;\n\tcontrol = priv->pending_setup.control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tframe_fmt &= ~FMT_DATA_BITS_MASK;\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tframe_fmt |= FMT_DATA_BITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tframe_fmt |= FMT_DATA_BITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tframe_fmt |= FMT_DATA_BITS_7;\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tframe_fmt |= FMT_DATA_BITS_8;\n\t\tbreak;\n\t}\n\n\t \n\tbr = tty_get_baud_rate(tty);\n\tif (br == 0) {\n\t\tdivisor = 0;\n\t} else {\n\t\tint real_br;\n\t\tint new_divisor;\n\t\tbr = min(br, OTI6858_MAX_BAUD_RATE);\n\n\t\tnew_divisor = (96000000 + 8 * br) / (16 * br);\n\t\treal_br = 96000000 / (16 * new_divisor);\n\t\tdivisor = cpu_to_le16(new_divisor);\n\t\ttty_encode_baud_rate(tty, real_br, real_br);\n\t}\n\n\tframe_fmt &= ~FMT_STOP_BITS_MASK;\n\tif ((cflag & CSTOPB) != 0)\n\t\tframe_fmt |= FMT_STOP_BITS_2;\n\telse\n\t\tframe_fmt |= FMT_STOP_BITS_1;\n\n\tframe_fmt &= ~FMT_PARITY_MASK;\n\tif ((cflag & PARENB) != 0) {\n\t\tif ((cflag & PARODD) != 0)\n\t\t\tframe_fmt |= FMT_PARITY_ODD;\n\t\telse\n\t\t\tframe_fmt |= FMT_PARITY_EVEN;\n\t} else {\n\t\tframe_fmt |= FMT_PARITY_NONE;\n\t}\n\n\tcontrol &= ~CONTROL_MASK;\n\tif ((cflag & CRTSCTS) != 0)\n\t\tcontrol |= (CONTROL_DTR_HIGH | CONTROL_RTS_HIGH);\n\n\t \n\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (divisor != priv->pending_setup.divisor\n\t\t\t|| control != priv->pending_setup.control\n\t\t\t|| frame_fmt != priv->pending_setup.frame_fmt) {\n\t\tpriv->pending_setup.divisor = divisor;\n\t\tpriv->pending_setup.control = control;\n\t\tpriv->pending_setup.frame_fmt = frame_fmt;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int oti6858_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tstruct oti6858_control_pkt *buf;\n\tunsigned long flags;\n\tint result;\n\n\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\n\tbuf = kmalloc(OTI6858_CTRL_PKT_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\tOTI6858_REQ_T_GET_STATUS,\n\t\t\t\tOTI6858_REQ_GET_STATUS,\n\t\t\t\t0, 0,\n\t\t\t\tbuf, OTI6858_CTRL_PKT_SIZE,\n\t\t\t\t100);\n\tif (result != OTI6858_CTRL_PKT_SIZE) {\n\t\t \n\t\tbuf->divisor = cpu_to_le16(0x009c);\t \n\t\tbuf->frame_fmt = 0x03;\t \n\t\tbuf->something = 0x43;\n\t\tbuf->control = 0x4c;\t \n\t\tbuf->tx_status = 0x00;\n\t\tbuf->pin_state = 0x5b;\t \n\t\tbuf->rx_bytes_avail = 0x00;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmemcpy(&priv->status, buf, OTI6858_CTRL_PKT_SIZE);\n\tpriv->pending_setup.divisor = buf->divisor;\n\tpriv->pending_setup.frame_fmt = buf->frame_fmt;\n\tpriv->pending_setup.control = buf->control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tkfree(buf);\n\n\tdev_dbg(&port->dev, \"%s(): submitting interrupt urb\\n\", __func__);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result != 0) {\n\t\tdev_err(&port->dev, \"%s(): usb_submit_urb() failed with error %d\\n\",\n\t\t\t__func__, result);\n\t\toti6858_close(port);\n\t\treturn result;\n\t}\n\n\t \n\tif (tty)\n\t\toti6858_set_termios(tty, port, NULL);\n\n\treturn 0;\n}\n\nstatic void oti6858_close(struct usb_serial_port *port)\n{\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t \n\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s(): after buf_clear()\\n\", __func__);\n\n\t \n\tcancel_delayed_work_sync(&priv->delayed_setup_work);\n\tcancel_delayed_work_sync(&priv->delayed_write_work);\n\n\t \n\tdev_dbg(&port->dev, \"%s(): shutting down urbs\\n\", __func__);\n\tusb_kill_urb(port->write_urb);\n\tusb_kill_urb(port->read_urb);\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic int oti6858_tiocmset(struct tty_struct *tty,\n\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\n\tdev_dbg(&port->dev, \"%s(set = 0x%08x, clear = 0x%08x)\\n\",\n\t\t__func__, set, clear);\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol = priv->pending_setup.control;\n\tif ((set & TIOCM_RTS) != 0)\n\t\tcontrol |= CONTROL_RTS_HIGH;\n\tif ((set & TIOCM_DTR) != 0)\n\t\tcontrol |= CONTROL_DTR_HIGH;\n\tif ((clear & TIOCM_RTS) != 0)\n\t\tcontrol &= ~CONTROL_RTS_HIGH;\n\tif ((clear & TIOCM_DTR) != 0)\n\t\tcontrol &= ~CONTROL_DTR_HIGH;\n\n\tif (control != priv->pending_setup.control)\n\t\tpriv->pending_setup.control = control;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn 0;\n}\n\nstatic int oti6858_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned pin_state;\n\tunsigned result = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpin_state = priv->status.pin_state & PIN_MASK;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tif ((pin_state & PIN_RTS) != 0)\n\t\tresult |= TIOCM_RTS;\n\tif ((pin_state & PIN_CTS) != 0)\n\t\tresult |= TIOCM_CTS;\n\tif ((pin_state & PIN_DSR) != 0)\n\t\tresult |= TIOCM_DSR;\n\tif ((pin_state & PIN_DTR) != 0)\n\t\tresult |= TIOCM_DTR;\n\tif ((pin_state & PIN_RI) != 0)\n\t\tresult |= TIOCM_RI;\n\tif ((pin_state & PIN_DCD) != 0)\n\t\tresult |= TIOCM_CD;\n\n\tdev_dbg(&port->dev, \"%s() = 0x%08x\\n\", __func__, result);\n\n\treturn result;\n}\n\nstatic void oti6858_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port =  urb->context;\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tint transient = 0, can_recv = 0, resubmit = 1;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s(): urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&urb->dev->dev, \"%s(): nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tbreak;\n\t}\n\n\tif (status == 0 && urb->actual_length == OTI6858_CTRL_PKT_SIZE) {\n\t\tstruct oti6858_control_pkt *xs = urb->transfer_buffer;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\tif (!priv->transient) {\n\t\t\tif (!OTI6858_CTRL_EQUALS_PENDING(xs, priv)) {\n\t\t\t\tif (xs->rx_bytes_avail == 0) {\n\t\t\t\t\tpriv->transient = 4;\n\t\t\t\t\tpriv->setup_done = 0;\n\t\t\t\t\tresubmit = 0;\n\t\t\t\t\tdev_dbg(&port->dev, \"%s(): scheduling setup_line()\\n\", __func__);\n\t\t\t\t\tschedule_delayed_work(&priv->delayed_setup_work, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (OTI6858_CTRL_EQUALS_PENDING(xs, priv)) {\n\t\t\t\tpriv->transient = 0;\n\t\t\t} else if (!priv->setup_done) {\n\t\t\t\tresubmit = 0;\n\t\t\t} else if (--priv->transient == 0) {\n\t\t\t\tif (xs->rx_bytes_avail == 0) {\n\t\t\t\t\tpriv->transient = 4;\n\t\t\t\t\tpriv->setup_done = 0;\n\t\t\t\t\tresubmit = 0;\n\t\t\t\t\tdev_dbg(&port->dev, \"%s(): scheduling setup_line()\\n\", __func__);\n\t\t\t\t\tschedule_delayed_work(&priv->delayed_setup_work, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!priv->transient) {\n\t\t\tu8 delta = xs->pin_state ^ priv->status.pin_state;\n\n\t\t\tif (delta & PIN_MSR_MASK) {\n\t\t\t\tif (delta & PIN_CTS)\n\t\t\t\t\tport->icount.cts++;\n\t\t\t\tif (delta & PIN_DSR)\n\t\t\t\t\tport->icount.dsr++;\n\t\t\t\tif (delta & PIN_RI)\n\t\t\t\t\tport->icount.rng++;\n\t\t\t\tif (delta & PIN_DCD)\n\t\t\t\t\tport->icount.dcd++;\n\n\t\t\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t\t\t}\n\n\t\t\tmemcpy(&priv->status, xs, OTI6858_CTRL_PKT_SIZE);\n\t\t}\n\n\t\tif (!priv->transient && xs->rx_bytes_avail != 0) {\n\t\t\tcan_recv = xs->rx_bytes_avail;\n\t\t\tpriv->flags.read_urb_in_use = 1;\n\t\t}\n\n\t\ttransient = priv->transient;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\tif (can_recv) {\n\t\tint result;\n\n\t\tresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\t\tif (result != 0) {\n\t\t\tpriv->flags.read_urb_in_use = 0;\n\t\t\tdev_err(&port->dev, \"%s(): usb_submit_urb() failed,\"\n\t\t\t\t\t\" error %d\\n\", __func__, result);\n\t\t} else {\n\t\t\tresubmit = 0;\n\t\t}\n\t} else if (!transient) {\n\t\tunsigned long flags;\n\t\tint count;\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tcount = kfifo_len(&port->write_fifo);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\tif (priv->flags.write_urb_in_use == 0 && count != 0) {\n\t\t\tschedule_delayed_work(&priv->delayed_write_work, 0);\n\t\t\tresubmit = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\tif (resubmit) {\n\t\tint result;\n\n \n\t\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (result != 0) {\n\t\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\t\"%s(): usb_submit_urb() failed with\"\n\t\t\t\t\t\" error %d\\n\", __func__, result);\n\t\t}\n\t}\n}\n\nstatic void oti6858_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port =  urb->context;\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned long flags;\n\tint status = urb->status;\n\tint result;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->flags.read_urb_in_use = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (status != 0) {\n\t\tdev_dbg(&urb->dev->dev, \"%s(): unable to handle the error, exiting\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length > 0) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\tif (result != 0 && result != -EPERM) {\n\t\tdev_err(&port->dev, \"%s(): usb_submit_urb() failed,\"\n\t\t\t\t\" error %d\\n\", __func__, result);\n\t}\n}\n\nstatic void oti6858_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port =  urb->context;\n\tstruct oti6858_private *priv = usb_get_serial_port_data(port);\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s(): urb shutting down with status: %d\\n\", __func__, status);\n\t\tpriv->flags.write_urb_in_use = 0;\n\t\treturn;\n\tdefault:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s(): nonzero write bulk status received: %d\\n\", __func__, status);\n\t\tdev_dbg(&urb->dev->dev, \"%s(): overflow in write\\n\", __func__);\n\n\t\tport->write_urb->transfer_buffer_length = 1;\n\t\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\t\tif (result) {\n\t\t\tdev_err_console(port, \"%s(): usb_submit_urb() failed,\"\n\t\t\t\t\t\" error %d\\n\", __func__, result);\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tpriv->flags.write_urb_in_use = 0;\n\n\t \n\tdev_dbg(&port->dev, \"%s(): submitting interrupt urb\\n\", __func__);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\tif (result != 0) {\n\t\tdev_err(&port->dev, \"%s(): failed submitting int urb,\"\n\t\t\t\t\t\" error %d\\n\", __func__, result);\n\t}\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(OTI6858_DESCRIPTION);\nMODULE_AUTHOR(OTI6858_AUTHOR);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}