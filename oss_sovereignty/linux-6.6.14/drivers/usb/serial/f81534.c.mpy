{
  "module_name": "f81534.c",
  "hash_id": "9c2b2eb9cc825b7d90841ca4eef0dcba05bb19b91487a2373ec2b3356bc4dbbc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/f81534.c",
  "human_readable_source": "\n \n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n \n#define F81534_UART_BASE_ADDRESS\t0x1200\n#define F81534_UART_OFFSET\t\t0x10\n#define F81534_DIVISOR_LSB_REG\t\t(0x00 + F81534_UART_BASE_ADDRESS)\n#define F81534_DIVISOR_MSB_REG\t\t(0x01 + F81534_UART_BASE_ADDRESS)\n#define F81534_INTERRUPT_ENABLE_REG\t(0x01 + F81534_UART_BASE_ADDRESS)\n#define F81534_FIFO_CONTROL_REG\t\t(0x02 + F81534_UART_BASE_ADDRESS)\n#define F81534_LINE_CONTROL_REG\t\t(0x03 + F81534_UART_BASE_ADDRESS)\n#define F81534_MODEM_CONTROL_REG\t(0x04 + F81534_UART_BASE_ADDRESS)\n#define F81534_LINE_STATUS_REG\t\t(0x05 + F81534_UART_BASE_ADDRESS)\n#define F81534_MODEM_STATUS_REG\t\t(0x06 + F81534_UART_BASE_ADDRESS)\n#define F81534_CLOCK_REG\t\t(0x08 + F81534_UART_BASE_ADDRESS)\n#define F81534_CONFIG1_REG\t\t(0x09 + F81534_UART_BASE_ADDRESS)\n\n#define F81534_DEF_CONF_ADDRESS_START\t0x3000\n#define F81534_DEF_CONF_SIZE\t\t12\n\n#define F81534_CUSTOM_ADDRESS_START\t0x2f00\n#define F81534_CUSTOM_DATA_SIZE\t\t0x10\n#define F81534_CUSTOM_NO_CUSTOM_DATA\t0xff\n#define F81534_CUSTOM_VALID_TOKEN\t0xf0\n#define F81534_CONF_OFFSET\t\t1\n#define F81534_CONF_INIT_GPIO_OFFSET\t4\n#define F81534_CONF_WORK_GPIO_OFFSET\t8\n#define F81534_CONF_GPIO_SHUTDOWN\t7\n#define F81534_CONF_GPIO_RS232\t\t1\n\n#define F81534_MAX_DATA_BLOCK\t\t64\n#define F81534_MAX_BUS_RETRY\t\t20\n\n \n#define F81534_USB_MAX_RETRY\t\t10\n#define F81534_USB_TIMEOUT\t\t2000\n#define F81534_SET_GET_REGISTER\t\t0xA0\n\n#define F81534_NUM_PORT\t\t\t4\n#define F81534_UNUSED_PORT\t\t0xff\n#define F81534_WRITE_BUFFER_SIZE\t512\n\n#define DRIVER_DESC\t\t\t\"Fintek F81532/F81534\"\n#define FINTEK_VENDOR_ID_1\t\t0x1934\n#define FINTEK_VENDOR_ID_2\t\t0x2C42\n#define FINTEK_DEVICE_ID\t\t0x1202\n#define F81534_MAX_TX_SIZE\t\t124\n#define F81534_MAX_RX_SIZE\t\t124\n#define F81534_RECEIVE_BLOCK_SIZE\t128\n#define F81534_MAX_RECEIVE_BLOCK_SIZE\t512\n\n#define F81534_TOKEN_RECEIVE\t\t0x01\n#define F81534_TOKEN_WRITE\t\t0x02\n#define F81534_TOKEN_TX_EMPTY\t\t0x03\n#define F81534_TOKEN_MSR_CHANGE\t\t0x04\n\n \n#define F81534_BUS_BUSY\t\t\t(BIT(0) | BIT(1))\n#define F81534_BUS_IDLE\t\t\tBIT(2)\n#define F81534_BUS_READ_DATA\t\t0x1004\n#define F81534_BUS_REG_STATUS\t\t0x1003\n#define F81534_BUS_REG_START\t\t0x1002\n#define F81534_BUS_REG_END\t\t0x1001\n\n#define F81534_CMD_READ\t\t\t0x03\n\n#define F81534_DEFAULT_BAUD_RATE\t9600\n\n#define F81534_PORT_CONF_RS232\t\t0\n#define F81534_PORT_CONF_RS485\t\tBIT(0)\n#define F81534_PORT_CONF_RS485_INVERT\t(BIT(0) | BIT(1))\n#define F81534_PORT_CONF_MODE_MASK\tGENMASK(1, 0)\n#define F81534_PORT_CONF_DISABLE_PORT\tBIT(3)\n#define F81534_PORT_CONF_NOT_EXIST_PORT\tBIT(7)\n#define F81534_PORT_UNAVAILABLE\t\t\\\n\t(F81534_PORT_CONF_DISABLE_PORT | F81534_PORT_CONF_NOT_EXIST_PORT)\n\n\n#define F81534_1X_RXTRIGGER\t\t0xc3\n#define F81534_8X_RXTRIGGER\t\t0xcf\n\n \n\n#define F81534_UART_EN\t\t\tBIT(0)\n#define F81534_CLK_1_846_MHZ\t\t0\n#define F81534_CLK_18_46_MHZ\t\tBIT(1)\n#define F81534_CLK_24_MHZ\t\tBIT(2)\n#define F81534_CLK_14_77_MHZ\t\t(BIT(1) | BIT(2))\n#define F81534_CLK_MASK\t\t\tGENMASK(2, 1)\n#define F81534_CLK_TX_DELAY_1BIT\tBIT(3)\n#define F81534_CLK_RS485_MODE\t\tBIT(4)\n#define F81534_CLK_RS485_INVERT\t\tBIT(5)\n\nstatic const struct usb_device_id f81534_id_table[] = {\n\t{ USB_DEVICE(FINTEK_VENDOR_ID_1, FINTEK_DEVICE_ID) },\n\t{ USB_DEVICE(FINTEK_VENDOR_ID_2, FINTEK_DEVICE_ID) },\n\t{}\t\t\t \n};\n\n#define F81534_TX_EMPTY_BIT\t\t0\n\nstruct f81534_serial_private {\n\tu8 conf_data[F81534_DEF_CONF_SIZE];\n\tint tty_idx[F81534_NUM_PORT];\n\tu8 setting_idx;\n\tint opened_port;\n\tstruct mutex urb_mutex;\n};\n\nstruct f81534_port_private {\n\tstruct mutex mcr_mutex;\n\tstruct mutex lcr_mutex;\n\tstruct work_struct lsr_work;\n\tstruct usb_serial_port *port;\n\tunsigned long tx_empty;\n\tspinlock_t msr_lock;\n\tu32 baud_base;\n\tu8 shadow_mcr;\n\tu8 shadow_lcr;\n\tu8 shadow_msr;\n\tu8 shadow_clk;\n\tu8 phy_num;\n};\n\nstruct f81534_pin_data {\n\tconst u16 reg_addr;\n\tconst u8 reg_mask;\n};\n\nstruct f81534_port_out_pin {\n\tstruct f81534_pin_data pin[3];\n};\n\n \nstatic const struct f81534_port_out_pin f81534_port_out_pins[] = {\n\t { { { 0x2ae8, BIT(7) }, { 0x2a90, BIT(5) }, { 0x2a90, BIT(4) } } },\n\t { { { 0x2ae8, BIT(6) }, { 0x2ae8, BIT(0) }, { 0x2ae8, BIT(3) } } },\n\t { { { 0x2a90, BIT(0) }, { 0x2ae8, BIT(2) }, { 0x2a80, BIT(6) } } },\n\t { { { 0x2a90, BIT(3) }, { 0x2a90, BIT(2) }, { 0x2a90, BIT(1) } } },\n};\n\nstatic u32 const baudrate_table[] = { 115200, 921600, 1152000, 1500000 };\nstatic u8 const clock_table[] = { F81534_CLK_1_846_MHZ, F81534_CLK_14_77_MHZ,\n\t\t\t\tF81534_CLK_18_46_MHZ, F81534_CLK_24_MHZ };\n\nstatic int f81534_logic_to_phy_port(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_port *port)\n{\n\tstruct f81534_serial_private *serial_priv =\n\t\t\tusb_get_serial_data(port->serial);\n\tint count = 0;\n\tint i;\n\n\tfor (i = 0; i < F81534_NUM_PORT; ++i) {\n\t\tif (serial_priv->conf_data[i] & F81534_PORT_UNAVAILABLE)\n\t\t\tcontinue;\n\n\t\tif (port->port_number == count)\n\t\t\treturn i;\n\n\t\t++count;\n\t}\n\n\treturn -ENODEV;\n}\n\nstatic int f81534_set_register(struct usb_serial *serial, u16 reg, u8 data)\n{\n\tstruct usb_interface *interface = serial->interface;\n\tstruct usb_device *dev = serial->dev;\n\tsize_t count = F81534_USB_MAX_RETRY;\n\tint status;\n\tu8 *tmp;\n\n\ttmp = kmalloc(sizeof(u8), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t*tmp = data;\n\n\t \n\twhile (count--) {\n\t\tstatus = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t\t F81534_SET_GET_REGISTER,\n\t\t\t\t\t USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t\t\t reg, 0, tmp, sizeof(u8),\n\t\t\t\t\t F81534_USB_TIMEOUT);\n\t\tif (status == sizeof(u8)) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (status < 0) {\n\t\tdev_err(&interface->dev, \"%s: reg: %x data: %x failed: %d\\n\",\n\t\t\t\t__func__, reg, data, status);\n\t}\n\n\tkfree(tmp);\n\treturn status;\n}\n\nstatic int f81534_get_register(struct usb_serial *serial, u16 reg, u8 *data)\n{\n\tstruct usb_interface *interface = serial->interface;\n\tstruct usb_device *dev = serial->dev;\n\tsize_t count = F81534_USB_MAX_RETRY;\n\tint status;\n\tu8 *tmp;\n\n\ttmp = kmalloc(sizeof(u8), GFP_KERNEL);\n\tif (!tmp)\n\t\treturn -ENOMEM;\n\n\t \n\twhile (count--) {\n\t\tstatus = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\t\t F81534_SET_GET_REGISTER,\n\t\t\t\t\t USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t\t\t reg, 0, tmp, sizeof(u8),\n\t\t\t\t\t F81534_USB_TIMEOUT);\n\t\tif (status > 0) {\n\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\t} else if (status == 0) {\n\t\t\tstatus = -EIO;\n\t\t}\n\t}\n\n\tif (status < 0) {\n\t\tdev_err(&interface->dev, \"%s: reg: %x failed: %d\\n\", __func__,\n\t\t\t\treg, status);\n\t\tgoto end;\n\t}\n\n\t*data = *tmp;\n\nend:\n\tkfree(tmp);\n\treturn status;\n}\n\nstatic int f81534_set_mask_register(struct usb_serial *serial, u16 reg,\n\t\t\t\t\tu8 mask, u8 data)\n{\n\tint status;\n\tu8 tmp;\n\n\tstatus = f81534_get_register(serial, reg, &tmp);\n\tif (status)\n\t\treturn status;\n\n\ttmp &= ~mask;\n\ttmp |= (mask & data);\n\n\treturn f81534_set_register(serial, reg, tmp);\n}\n\nstatic int f81534_set_phy_port_register(struct usb_serial *serial, int phy,\n\t\t\t\t\tu16 reg, u8 data)\n{\n\treturn f81534_set_register(serial, reg + F81534_UART_OFFSET * phy,\n\t\t\t\t\tdata);\n}\n\nstatic int f81534_get_phy_port_register(struct usb_serial *serial, int phy,\n\t\t\t\t\tu16 reg, u8 *data)\n{\n\treturn f81534_get_register(serial, reg + F81534_UART_OFFSET * phy,\n\t\t\t\t\tdata);\n}\n\nstatic int f81534_set_port_register(struct usb_serial_port *port, u16 reg,\n\t\t\t\t\tu8 data)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\n\treturn f81534_set_register(port->serial,\n\t\t\treg + port_priv->phy_num * F81534_UART_OFFSET, data);\n}\n\nstatic int f81534_get_port_register(struct usb_serial_port *port, u16 reg,\n\t\t\t\t\tu8 *data)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\n\treturn f81534_get_register(port->serial,\n\t\t\treg + port_priv->phy_num * F81534_UART_OFFSET, data);\n}\n\n \nstatic int f81534_wait_for_spi_idle(struct usb_serial *serial)\n{\n\tsize_t count = F81534_MAX_BUS_RETRY;\n\tu8 tmp;\n\tint status;\n\n\tdo {\n\t\tstatus = f81534_get_register(serial, F81534_BUS_REG_STATUS,\n\t\t\t\t\t\t&tmp);\n\t\tif (status)\n\t\t\treturn status;\n\n\t\tif (tmp & F81534_BUS_BUSY)\n\t\t\tcontinue;\n\n\t\tif (tmp & F81534_BUS_IDLE)\n\t\t\tbreak;\n\n\t} while (--count);\n\n\tif (!count) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\t\"%s: timed out waiting for idle SPI bus\\n\",\n\t\t\t\t__func__);\n\t\treturn -EIO;\n\t}\n\n\treturn f81534_set_register(serial, F81534_BUS_REG_STATUS,\n\t\t\t\ttmp & ~F81534_BUS_IDLE);\n}\n\nstatic int f81534_get_spi_register(struct usb_serial *serial, u16 reg,\n\t\t\t\t\tu8 *data)\n{\n\tint status;\n\n\tstatus = f81534_get_register(serial, reg, data);\n\tif (status)\n\t\treturn status;\n\n\treturn f81534_wait_for_spi_idle(serial);\n}\n\nstatic int f81534_set_spi_register(struct usb_serial *serial, u16 reg, u8 data)\n{\n\tint status;\n\n\tstatus = f81534_set_register(serial, reg, data);\n\tif (status)\n\t\treturn status;\n\n\treturn f81534_wait_for_spi_idle(serial);\n}\n\nstatic int f81534_read_flash(struct usb_serial *serial, u32 address,\n\t\t\t\tsize_t size, u8 *buf)\n{\n\tu8 tmp_buf[F81534_MAX_DATA_BLOCK];\n\tsize_t block = 0;\n\tsize_t read_size;\n\tsize_t count;\n\tint status;\n\tint offset;\n\tu16 reg_tmp;\n\n\tstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\n\t\t\t\t\tF81534_CMD_READ);\n\tif (status)\n\t\treturn status;\n\n\tstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\n\t\t\t\t\t(address >> 16) & 0xff);\n\tif (status)\n\t\treturn status;\n\n\tstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\n\t\t\t\t\t(address >> 8) & 0xff);\n\tif (status)\n\t\treturn status;\n\n\tstatus = f81534_set_spi_register(serial, F81534_BUS_REG_START,\n\t\t\t\t\t(address >> 0) & 0xff);\n\tif (status)\n\t\treturn status;\n\n\t \n\tdo {\n\t\tread_size = min_t(size_t, F81534_MAX_DATA_BLOCK, size);\n\n\t\tfor (count = 0; count < read_size; ++count) {\n\t\t\t \n\t\t\tif (size <= F81534_MAX_DATA_BLOCK &&\n\t\t\t\t\tread_size == count + 1)\n\t\t\t\treg_tmp = F81534_BUS_REG_END;\n\t\t\telse\n\t\t\t\treg_tmp = F81534_BUS_REG_START;\n\n\t\t\t \n\t\t\tstatus = f81534_set_spi_register(serial, reg_tmp,\n\t\t\t\t\t0xf1);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\n\t\t\tstatus = f81534_get_spi_register(serial,\n\t\t\t\t\t\tF81534_BUS_READ_DATA,\n\t\t\t\t\t\t&tmp_buf[count]);\n\t\t\tif (status)\n\t\t\t\treturn status;\n\n\t\t\toffset = count + block * F81534_MAX_DATA_BLOCK;\n\t\t\tbuf[offset] = tmp_buf[count];\n\t\t}\n\n\t\tsize -= read_size;\n\t\t++block;\n\t} while (size);\n\n\treturn 0;\n}\n\nstatic void f81534_prepare_write_buffer(struct usb_serial_port *port, u8 *buf)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint phy_num = port_priv->phy_num;\n\tu8 tx_len;\n\tint i;\n\n\t \n\tfor (i = 0; i < F81534_NUM_PORT; ++i) {\n\t\tbuf[i * F81534_RECEIVE_BLOCK_SIZE] = i;\n\t\tbuf[i * F81534_RECEIVE_BLOCK_SIZE + 1] = F81534_TOKEN_WRITE;\n\t\tbuf[i * F81534_RECEIVE_BLOCK_SIZE + 2] = 0;\n\t\tbuf[i * F81534_RECEIVE_BLOCK_SIZE + 3] = 0;\n\t}\n\n\ttx_len = kfifo_out_locked(&port->write_fifo,\n\t\t\t\t&buf[phy_num * F81534_RECEIVE_BLOCK_SIZE + 4],\n\t\t\t\tF81534_MAX_TX_SIZE, &port->lock);\n\n\tbuf[phy_num * F81534_RECEIVE_BLOCK_SIZE + 2] = tx_len;\n}\n\nstatic int f81534_submit_writer(struct usb_serial_port *port, gfp_t mem_flags)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tstruct urb *urb;\n\tunsigned long flags;\n\tint result;\n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\tif (kfifo_is_empty(&port->write_fifo)) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn 0;\n\t}\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tif (!test_and_clear_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty))\n\t\treturn 0;\n\n\turb = port->write_urbs[0];\n\tf81534_prepare_write_buffer(port, port->bulk_out_buffers[0]);\n\turb->transfer_buffer_length = F81534_WRITE_BUFFER_SIZE;\n\n\tresult = usb_submit_urb(urb, mem_flags);\n\tif (result) {\n\t\tset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\n\t\tdev_err(&port->dev, \"%s: submit failed: %d\\n\", __func__,\n\t\t\t\tresult);\n\t\treturn result;\n\t}\n\n\tusb_serial_port_softint(port);\n\treturn 0;\n}\n\nstatic u32 f81534_calc_baud_divisor(u32 baudrate, u32 clockrate)\n{\n\t \n\treturn DIV_ROUND_CLOSEST(clockrate, baudrate);\n}\n\nstatic int f81534_find_clk(u32 baudrate)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(baudrate_table); ++idx) {\n\t\tif (baudrate <= baudrate_table[idx] &&\n\t\t\t\tbaudrate_table[idx] % baudrate == 0)\n\t\t\treturn idx;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic int f81534_set_port_config(struct usb_serial_port *port,\n\t\tstruct tty_struct *tty, u32 baudrate, u32 old_baudrate, u8 lcr)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tu32 divisor;\n\tint status;\n\tint i;\n\tint idx;\n\tu8 value;\n\tu32 baud_list[] = {baudrate, old_baudrate, F81534_DEFAULT_BAUD_RATE};\n\n\tfor (i = 0; i < ARRAY_SIZE(baud_list); ++i) {\n\t\tbaudrate = baud_list[i];\n\t\tif (baudrate == 0) {\n\t\t\ttty_encode_baud_rate(tty, 0, 0);\n\t\t\treturn 0;\n\t\t}\n\n\t\tidx = f81534_find_clk(baudrate);\n\t\tif (idx >= 0) {\n\t\t\ttty_encode_baud_rate(tty, baudrate, baudrate);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx < 0)\n\t\treturn -EINVAL;\n\n\tport_priv->baud_base = baudrate_table[idx];\n\tport_priv->shadow_clk &= ~F81534_CLK_MASK;\n\tport_priv->shadow_clk |= clock_table[idx];\n\n\tstatus = f81534_set_port_register(port, F81534_CLOCK_REG,\n\t\t\tport_priv->shadow_clk);\n\tif (status) {\n\t\tdev_err(&port->dev, \"CLOCK_REG setting failed\\n\");\n\t\treturn status;\n\t}\n\n\tif (baudrate <= 1200)\n\t\tvalue = F81534_1X_RXTRIGGER;\t \n\telse\n\t\tvalue = F81534_8X_RXTRIGGER;\t \n\n\tstatus = f81534_set_port_register(port, F81534_CONFIG1_REG, value);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: CONFIG1 setting failed\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tif (baudrate <= 1200)\n\t\tvalue = UART_FCR_TRIGGER_1 | UART_FCR_ENABLE_FIFO;  \n\telse\n\t\tvalue = UART_FCR_TRIGGER_8 | UART_FCR_ENABLE_FIFO;  \n\n\tstatus = f81534_set_port_register(port, F81534_FIFO_CONTROL_REG,\n\t\t\t\t\t\tvalue);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: FCR setting failed\\n\", __func__);\n\t\treturn status;\n\t}\n\n\tdivisor = f81534_calc_baud_divisor(baudrate, port_priv->baud_base);\n\n\tmutex_lock(&port_priv->lcr_mutex);\n\n\tvalue = UART_LCR_DLAB;\n\tstatus = f81534_set_port_register(port, F81534_LINE_CONTROL_REG,\n\t\t\t\t\t\tvalue);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: set LCR failed\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\tvalue = divisor & 0xff;\n\tstatus = f81534_set_port_register(port, F81534_DIVISOR_LSB_REG, value);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: set DLAB LSB failed\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\tvalue = (divisor >> 8) & 0xff;\n\tstatus = f81534_set_port_register(port, F81534_DIVISOR_MSB_REG, value);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: set DLAB MSB failed\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\tvalue = lcr | (port_priv->shadow_lcr & UART_LCR_SBC);\n\tstatus = f81534_set_port_register(port, F81534_LINE_CONTROL_REG,\n\t\t\t\t\t\tvalue);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: set LCR failed\\n\", __func__);\n\t\tgoto out_unlock;\n\t}\n\n\tport_priv->shadow_lcr = value;\nout_unlock:\n\tmutex_unlock(&port_priv->lcr_mutex);\n\n\treturn status;\n}\n\nstatic int f81534_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint status;\n\n\tmutex_lock(&port_priv->lcr_mutex);\n\n\tif (break_state)\n\t\tport_priv->shadow_lcr |= UART_LCR_SBC;\n\telse\n\t\tport_priv->shadow_lcr &= ~UART_LCR_SBC;\n\n\tstatus = f81534_set_port_register(port, F81534_LINE_CONTROL_REG,\n\t\t\t\t\tport_priv->shadow_lcr);\n\tif (status)\n\t\tdev_err(&port->dev, \"set break failed: %d\\n\", status);\n\n\tmutex_unlock(&port_priv->lcr_mutex);\n\n\treturn status;\n}\n\nstatic int f81534_update_mctrl(struct usb_serial_port *port, unsigned int set,\n\t\t\t\tunsigned int clear)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint status;\n\tu8 tmp;\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0)\n\t\treturn 0;\t \n\n\tmutex_lock(&port_priv->mcr_mutex);\n\n\t \n\tclear &= ~set;\n\n\t \n\ttmp = UART_MCR_OUT2 | port_priv->shadow_mcr;\n\n\tif (clear & TIOCM_DTR)\n\t\ttmp &= ~UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\ttmp &= ~UART_MCR_RTS;\n\n\tif (set & TIOCM_DTR)\n\t\ttmp |= UART_MCR_DTR;\n\n\tif (set & TIOCM_RTS)\n\t\ttmp |= UART_MCR_RTS;\n\n\tstatus = f81534_set_port_register(port, F81534_MODEM_CONTROL_REG, tmp);\n\tif (status < 0) {\n\t\tdev_err(&port->dev, \"%s: MCR write failed\\n\", __func__);\n\t\tmutex_unlock(&port_priv->mcr_mutex);\n\t\treturn status;\n\t}\n\n\tport_priv->shadow_mcr = tmp;\n\tmutex_unlock(&port_priv->mcr_mutex);\n\treturn 0;\n}\n\n \nstatic int f81534_find_config_idx(struct usb_serial *serial, u8 *index)\n{\n\tu8 tmp;\n\tint status;\n\n\tstatus = f81534_read_flash(serial, F81534_CUSTOM_ADDRESS_START, 1,\n\t\t\t\t\t&tmp);\n\tif (status) {\n\t\tdev_err(&serial->interface->dev, \"%s: read failed: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t \n\tif (tmp == F81534_CUSTOM_VALID_TOKEN)\n\t\t*index = 0;\n\telse\n\t\t*index = F81534_CUSTOM_NO_CUSTOM_DATA;\n\n\treturn 0;\n}\n\n \nstatic bool f81534_check_port_hw_disabled(struct usb_serial *serial, int phy)\n{\n\tint status;\n\tu8 old_mcr;\n\tu8 msr;\n\tu8 lsr;\n\tu8 msr_mask;\n\n\tmsr_mask = UART_MSR_DCD | UART_MSR_RI | UART_MSR_DSR | UART_MSR_CTS;\n\n\tstatus = f81534_get_phy_port_register(serial, phy,\n\t\t\t\tF81534_MODEM_STATUS_REG, &msr);\n\tif (status)\n\t\treturn false;\n\n\tif ((msr & msr_mask) != msr_mask)\n\t\treturn false;\n\n\tstatus = f81534_set_phy_port_register(serial, phy,\n\t\t\t\tF81534_FIFO_CONTROL_REG, UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tif (status)\n\t\treturn false;\n\n\tstatus = f81534_get_phy_port_register(serial, phy,\n\t\t\t\tF81534_MODEM_CONTROL_REG, &old_mcr);\n\tif (status)\n\t\treturn false;\n\n\tstatus = f81534_set_phy_port_register(serial, phy,\n\t\t\t\tF81534_MODEM_CONTROL_REG, UART_MCR_LOOP);\n\tif (status)\n\t\treturn false;\n\n\tstatus = f81534_set_phy_port_register(serial, phy,\n\t\t\t\tF81534_MODEM_CONTROL_REG, 0x0);\n\tif (status)\n\t\treturn false;\n\n\tmsleep(60);\n\n\tstatus = f81534_get_phy_port_register(serial, phy,\n\t\t\t\tF81534_LINE_STATUS_REG, &lsr);\n\tif (status)\n\t\treturn false;\n\n\tstatus = f81534_set_phy_port_register(serial, phy,\n\t\t\t\tF81534_MODEM_CONTROL_REG, old_mcr);\n\tif (status)\n\t\treturn false;\n\n\tif ((lsr & UART_LSR_BI) == UART_LSR_BI)\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic int f81534_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct f81534_serial_private *serial_priv;\n\tstruct device *dev = &serial->interface->dev;\n\tint size_bulk_in = usb_endpoint_maxp(epds->bulk_in[0]);\n\tint size_bulk_out = usb_endpoint_maxp(epds->bulk_out[0]);\n\tu8 num_port = 0;\n\tint index = 0;\n\tint status;\n\tint i;\n\n\tif (size_bulk_out != F81534_WRITE_BUFFER_SIZE ||\n\t\t\tsize_bulk_in != F81534_MAX_RECEIVE_BLOCK_SIZE) {\n\t\tdev_err(dev, \"unsupported endpoint max packet size\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tserial_priv = devm_kzalloc(&serial->interface->dev,\n\t\t\t\t\tsizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_data(serial, serial_priv);\n\tmutex_init(&serial_priv->urb_mutex);\n\n\t \n\tstatus = f81534_find_config_idx(serial, &serial_priv->setting_idx);\n\tif (status) {\n\t\tdev_err(&serial->interface->dev, \"%s: find idx failed: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t \n\tif (serial_priv->setting_idx != F81534_CUSTOM_NO_CUSTOM_DATA) {\n\t\tstatus = f81534_read_flash(serial,\n\t\t\t\t\t\tF81534_CUSTOM_ADDRESS_START +\n\t\t\t\t\t\tF81534_CONF_OFFSET,\n\t\t\t\t\t\tsizeof(serial_priv->conf_data),\n\t\t\t\t\t\tserial_priv->conf_data);\n\t\tif (status) {\n\t\t\tdev_err(&serial->interface->dev,\n\t\t\t\t\t\"%s: get custom data failed: %d\\n\",\n\t\t\t\t\t__func__, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tdev_dbg(&serial->interface->dev,\n\t\t\t\t\"%s: read config from block: %d\\n\", __func__,\n\t\t\t\tserial_priv->setting_idx);\n\t} else {\n\t\t \n\t\tstatus = f81534_read_flash(serial,\n\t\t\t\tF81534_DEF_CONF_ADDRESS_START,\n\t\t\t\tsizeof(serial_priv->conf_data),\n\t\t\t\tserial_priv->conf_data);\n\t\tif (status) {\n\t\t\tdev_err(&serial->interface->dev,\n\t\t\t\t\t\"%s: read failed: %d\\n\", __func__,\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\n\t\tdev_dbg(&serial->interface->dev, \"%s: read default config\\n\",\n\t\t\t\t__func__);\n\t}\n\n\t \n\tfor (i = 0; i < F81534_NUM_PORT; ++i) {\n\t\tif (f81534_check_port_hw_disabled(serial, i))\n\t\t\tserial_priv->conf_data[i] |= F81534_PORT_UNAVAILABLE;\n\n\t\tif (serial_priv->conf_data[i] & F81534_PORT_UNAVAILABLE)\n\t\t\tcontinue;\n\n\t\t++num_port;\n\t}\n\n\tif (!num_port) {\n\t\tdev_warn(&serial->interface->dev,\n\t\t\t\"no config found, assuming 4 ports\\n\");\n\t\tnum_port = 4;\t\t \n\t}\n\n\t \n\tfor (i = 0; i < F81534_NUM_PORT; ++i) {\n\t\tif (serial_priv->conf_data[i] & F81534_PORT_UNAVAILABLE)\n\t\t\tcontinue;\n\n\t\tserial_priv->tty_idx[i] = index++;\n\t\tdev_dbg(&serial->interface->dev,\n\t\t\t\t\"%s: phy_num: %d, tty_idx: %d\\n\", __func__, i,\n\t\t\t\tserial_priv->tty_idx[i]);\n\t}\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(epds->bulk_out) < F81534_NUM_PORT);\n\n\tfor (i = 1; i < num_port; ++i)\n\t\tepds->bulk_out[i] = epds->bulk_out[0];\n\n\tepds->num_bulk_out = num_port;\n\n\treturn num_port;\n}\n\nstatic void f81534_set_termios(struct tty_struct *tty,\n\t\t\t       struct usb_serial_port *port,\n\t\t\t       const struct ktermios *old_termios)\n{\n\tu8 new_lcr = 0;\n\tint status;\n\tu32 baud;\n\tu32 old_baud;\n\n\tif (C_BAUD(tty) == B0)\n\t\tf81534_update_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\n\telse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\tf81534_update_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\n\n\tif (C_PARENB(tty)) {\n\t\tnew_lcr |= UART_LCR_PARITY;\n\n\t\tif (!C_PARODD(tty))\n\t\t\tnew_lcr |= UART_LCR_EPAR;\n\n\t\tif (C_CMSPAR(tty))\n\t\t\tnew_lcr |= UART_LCR_SPAR;\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tnew_lcr |= UART_LCR_STOP;\n\n\tnew_lcr |= UART_LCR_WLEN(tty_get_char_size(tty->termios.c_cflag));\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\treturn;\n\n\tif (old_termios)\n\t\told_baud = tty_termios_baud_rate(old_termios);\n\telse\n\t\told_baud = F81534_DEFAULT_BAUD_RATE;\n\n\tdev_dbg(&port->dev, \"%s: baud: %d\\n\", __func__, baud);\n\n\tstatus = f81534_set_port_config(port, tty, baud, old_baud, new_lcr);\n\tif (status < 0) {\n\t\tdev_err(&port->dev, \"%s: set port config failed: %d\\n\",\n\t\t\t\t__func__, status);\n\t}\n}\n\nstatic int f81534_submit_read_urb(struct usb_serial *serial, gfp_t flags)\n{\n\treturn usb_serial_generic_submit_read_urbs(serial->port[0], flags);\n}\n\nstatic void f81534_msr_changed(struct usb_serial_port *port, u8 msr)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\tu8 old_msr;\n\n\tif (!(msr & UART_MSR_ANY_DELTA))\n\t\treturn;\n\n\tspin_lock_irqsave(&port_priv->msr_lock, flags);\n\told_msr = port_priv->shadow_msr;\n\tport_priv->shadow_msr = msr;\n\tspin_unlock_irqrestore(&port_priv->msr_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s: MSR from %02x to %02x\\n\", __func__, old_msr,\n\t\t\tmsr);\n\n\t \n\tif (msr & UART_MSR_DCTS)\n\t\tport->icount.cts++;\n\tif (msr & UART_MSR_DDSR)\n\t\tport->icount.dsr++;\n\tif (msr & UART_MSR_DDCD)\n\t\tport->icount.dcd++;\n\tif (msr & UART_MSR_TERI)\n\t\tport->icount.rng++;\n\n\twake_up_interruptible(&port->port.delta_msr_wait);\n\n\tif (!(msr & UART_MSR_DDCD))\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s: DCD Changed: phy_num: %d from %x to %x\\n\",\n\t\t\t__func__, port_priv->phy_num, old_msr, msr);\n\n\ttty = tty_port_tty_get(&port->port);\n\tif (!tty)\n\t\treturn;\n\n\tusb_serial_handle_dcd_change(port, tty, msr & UART_MSR_DCD);\n\ttty_kref_put(tty);\n}\n\nstatic int f81534_read_msr(struct usb_serial_port *port)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint status;\n\tu8 msr;\n\n\t \n\tstatus = f81534_get_port_register(port, F81534_MODEM_STATUS_REG, &msr);\n\tif (status)\n\t\treturn status;\n\n\t \n\tspin_lock_irqsave(&port_priv->msr_lock, flags);\n\tport_priv->shadow_msr = msr;\n\tspin_unlock_irqrestore(&port_priv->msr_lock, flags);\n\n\treturn 0;\n}\n\nstatic int f81534_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct f81534_serial_private *serial_priv =\n\t\t\tusb_get_serial_data(port->serial);\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint status;\n\n\tstatus = f81534_set_port_register(port,\n\t\t\t\tF81534_FIFO_CONTROL_REG, UART_FCR_ENABLE_FIFO |\n\t\t\t\tUART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: Clear FIFO failed: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\treturn status;\n\t}\n\n\tif (tty)\n\t\tf81534_set_termios(tty, port, NULL);\n\n\tstatus = f81534_read_msr(port);\n\tif (status)\n\t\treturn status;\n\n\tmutex_lock(&serial_priv->urb_mutex);\n\n\t \n\tif (!serial_priv->opened_port) {\n\t\tstatus = f81534_submit_read_urb(port->serial, GFP_KERNEL);\n\t\tif (status)\n\t\t\tgoto exit;\n\t}\n\n\tserial_priv->opened_port++;\n\nexit:\n\tmutex_unlock(&serial_priv->urb_mutex);\n\n\tset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\n\treturn status;\n}\n\nstatic void f81534_close(struct usb_serial_port *port)\n{\n\tstruct f81534_serial_private *serial_priv =\n\t\t\tusb_get_serial_data(port->serial);\n\tstruct usb_serial_port *port0 = port->serial->port[0];\n\tunsigned long flags;\n\tsize_t i;\n\n\tusb_kill_urb(port->write_urbs[0]);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t \n\tmutex_lock(&serial_priv->urb_mutex);\n\tserial_priv->opened_port--;\n\n\tif (!serial_priv->opened_port) {\n\t\tfor (i = 0; i < ARRAY_SIZE(port0->read_urbs); ++i)\n\t\t\tusb_kill_urb(port0->read_urbs[i]);\n\t}\n\n\tmutex_unlock(&serial_priv->urb_mutex);\n}\n\nstatic void f81534_get_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81534_port_private *port_priv;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\tss->baud_base = port_priv->baud_base;\n}\n\nstatic void f81534_process_per_serial_block(struct usb_serial_port *port,\n\t\tu8 *data)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint phy_num = data[0];\n\tsize_t read_size = 0;\n\tsize_t i;\n\tchar tty_flag;\n\tint status;\n\tu8 lsr;\n\n\t \n\tswitch (data[1]) {\n\tcase F81534_TOKEN_TX_EMPTY:\n\t\tset_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\n\n\t\t \n\t\tstatus = f81534_submit_writer(port, GFP_ATOMIC);\n\t\tif (status)\n\t\t\tdev_err(&port->dev, \"%s: submit failed\\n\", __func__);\n\t\treturn;\n\n\tcase F81534_TOKEN_MSR_CHANGE:\n\t\tf81534_msr_changed(port, data[3]);\n\t\treturn;\n\n\tcase F81534_TOKEN_RECEIVE:\n\t\tread_size = data[2];\n\t\tif (read_size > F81534_MAX_RX_SIZE) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s: phy: %d read_size: %zu larger than: %d\\n\",\n\t\t\t\t__func__, phy_num, read_size,\n\t\t\t\tF81534_MAX_RX_SIZE);\n\t\t\treturn;\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(&port->dev, \"%s: unknown token: %02x\\n\", __func__,\n\t\t\t\tdata[1]);\n\t\treturn;\n\t}\n\n\tfor (i = 4; i < 4 + read_size; i += 2) {\n\t\ttty_flag = TTY_NORMAL;\n\t\tlsr = data[i + 1];\n\n\t\tif (lsr & UART_LSR_BRK_ERROR_BITS) {\n\t\t\tif (lsr & UART_LSR_BI) {\n\t\t\t\ttty_flag = TTY_BREAK;\n\t\t\t\tport->icount.brk++;\n\t\t\t\tusb_serial_handle_break(port);\n\t\t\t} else if (lsr & UART_LSR_PE) {\n\t\t\t\ttty_flag = TTY_PARITY;\n\t\t\t\tport->icount.parity++;\n\t\t\t} else if (lsr & UART_LSR_FE) {\n\t\t\t\ttty_flag = TTY_FRAME;\n\t\t\t\tport->icount.frame++;\n\t\t\t}\n\n\t\t\tif (lsr & UART_LSR_OE) {\n\t\t\t\tport->icount.overrun++;\n\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t}\n\n\t\t\tschedule_work(&port_priv->lsr_work);\n\t\t}\n\n\t\tif (port->sysrq) {\n\t\t\tif (usb_serial_handle_sysrq_char(port, data[i]))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttty_insert_flip_char(&port->port, data[i], tty_flag);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void f81534_process_read_urb(struct urb *urb)\n{\n\tstruct f81534_serial_private *serial_priv;\n\tstruct usb_serial_port *port;\n\tstruct usb_serial *serial;\n\tu8 *buf;\n\tint phy_port_num;\n\tint tty_port_num;\n\tsize_t i;\n\n\tif (!urb->actual_length ||\n\t\t\turb->actual_length % F81534_RECEIVE_BLOCK_SIZE) {\n\t\treturn;\n\t}\n\n\tport = urb->context;\n\tserial = port->serial;\n\tbuf = urb->transfer_buffer;\n\tserial_priv = usb_get_serial_data(serial);\n\n\tfor (i = 0; i < urb->actual_length; i += F81534_RECEIVE_BLOCK_SIZE) {\n\t\tphy_port_num = buf[i];\n\t\tif (phy_port_num >= F81534_NUM_PORT) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s: phy_port_num: %d larger than: %d\\n\",\n\t\t\t\t__func__, phy_port_num, F81534_NUM_PORT);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttty_port_num = serial_priv->tty_idx[phy_port_num];\n\t\tport = serial->port[tty_port_num];\n\n\t\tif (tty_port_initialized(&port->port))\n\t\t\tf81534_process_per_serial_block(port, &buf[i]);\n\t}\n}\n\nstatic void f81534_write_usb_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&port->dev, \"%s - urb stopped: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\treturn;\n\tcase -EPIPE:\n\t\tdev_err(&port->dev, \"%s - urb stopped: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status: %d\\n\",\n\t\t\t\t__func__, urb->status);\n\t\tbreak;\n\t}\n}\n\nstatic void f81534_lsr_worker(struct work_struct *work)\n{\n\tstruct f81534_port_private *port_priv;\n\tstruct usb_serial_port *port;\n\tint status;\n\tu8 tmp;\n\n\tport_priv = container_of(work, struct f81534_port_private, lsr_work);\n\tport = port_priv->port;\n\n\tstatus = f81534_get_port_register(port, F81534_LINE_STATUS_REG, &tmp);\n\tif (status)\n\t\tdev_warn(&port->dev, \"read LSR failed: %d\\n\", status);\n}\n\nstatic int f81534_set_port_output_pin(struct usb_serial_port *port)\n{\n\tstruct f81534_serial_private *serial_priv;\n\tstruct f81534_port_private *port_priv;\n\tstruct usb_serial *serial;\n\tconst struct f81534_port_out_pin *pins;\n\tint status;\n\tint i;\n\tu8 value;\n\tu8 idx;\n\n\tserial = port->serial;\n\tserial_priv = usb_get_serial_data(serial);\n\tport_priv = usb_get_serial_port_data(port);\n\n\tidx = F81534_CONF_INIT_GPIO_OFFSET + port_priv->phy_num;\n\tvalue = serial_priv->conf_data[idx];\n\tif (value >= F81534_CONF_GPIO_SHUTDOWN) {\n\t\t \n\t\tidx = F81534_CONF_WORK_GPIO_OFFSET + port_priv->phy_num;\n\t\tvalue = serial_priv->conf_data[idx];\n\t\tif (value >= F81534_CONF_GPIO_SHUTDOWN)\n\t\t\tvalue = F81534_CONF_GPIO_RS232;\n\t}\n\n\tpins = &f81534_port_out_pins[port_priv->phy_num];\n\n\tfor (i = 0; i < ARRAY_SIZE(pins->pin); ++i) {\n\t\tstatus = f81534_set_mask_register(serial,\n\t\t\t\tpins->pin[i].reg_addr, pins->pin[i].reg_mask,\n\t\t\t\tvalue & BIT(i) ? pins->pin[i].reg_mask : 0);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\n\tdev_dbg(&port->dev, \"Output pin (M0/M1/M2): %d\\n\", value);\n\treturn 0;\n}\n\nstatic int f81534_port_probe(struct usb_serial_port *port)\n{\n\tstruct f81534_serial_private *serial_priv;\n\tstruct f81534_port_private *port_priv;\n\tint ret;\n\tu8 value;\n\n\tserial_priv = usb_get_serial_data(port->serial);\n\tport_priv = devm_kzalloc(&port->dev, sizeof(*port_priv), GFP_KERNEL);\n\tif (!port_priv)\n\t\treturn -ENOMEM;\n\n\t \n\tport_priv->shadow_clk = F81534_UART_EN | F81534_CLK_TX_DELAY_1BIT;\n\tspin_lock_init(&port_priv->msr_lock);\n\tmutex_init(&port_priv->mcr_mutex);\n\tmutex_init(&port_priv->lcr_mutex);\n\tINIT_WORK(&port_priv->lsr_work, f81534_lsr_worker);\n\n\t \n\tret = f81534_logic_to_phy_port(port->serial, port);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tport_priv->phy_num = ret;\n\tport_priv->port = port;\n\tusb_set_serial_port_data(port, port_priv);\n\tdev_dbg(&port->dev, \"%s: port_number: %d, phy_num: %d\\n\", __func__,\n\t\t\tport->port_number, port_priv->phy_num);\n\n\t \n\tret = f81534_set_port_register(port, F81534_INTERRUPT_ENABLE_REG,\n\t\t\tUART_IER_RDI | UART_IER_THRI | UART_IER_MSI);\n\tif (ret)\n\t\treturn ret;\n\n\tvalue = serial_priv->conf_data[port_priv->phy_num];\n\tswitch (value & F81534_PORT_CONF_MODE_MASK) {\n\tcase F81534_PORT_CONF_RS485_INVERT:\n\t\tport_priv->shadow_clk |= F81534_CLK_RS485_MODE |\n\t\t\t\t\tF81534_CLK_RS485_INVERT;\n\t\tdev_dbg(&port->dev, \"RS485 invert mode\\n\");\n\t\tbreak;\n\tcase F81534_PORT_CONF_RS485:\n\t\tport_priv->shadow_clk |= F81534_CLK_RS485_MODE;\n\t\tdev_dbg(&port->dev, \"RS485 mode\\n\");\n\t\tbreak;\n\n\tdefault:\n\tcase F81534_PORT_CONF_RS232:\n\t\tdev_dbg(&port->dev, \"RS232 mode\\n\");\n\t\tbreak;\n\t}\n\n\treturn f81534_set_port_output_pin(port);\n}\n\nstatic void f81534_port_remove(struct usb_serial_port *port)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\n\tflush_work(&port_priv->lsr_work);\n}\n\nstatic int f81534_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\tint status;\n\tint r;\n\tu8 msr;\n\tu8 mcr;\n\n\t \n\tstatus = f81534_get_port_register(port, F81534_MODEM_STATUS_REG, &msr);\n\tif (status)\n\t\treturn status;\n\n\tmutex_lock(&port_priv->mcr_mutex);\n\tmcr = port_priv->shadow_mcr;\n\tmutex_unlock(&port_priv->mcr_mutex);\n\n\tr = (mcr & UART_MCR_DTR ? TIOCM_DTR : 0) |\n\t    (mcr & UART_MCR_RTS ? TIOCM_RTS : 0) |\n\t    (msr & UART_MSR_CTS ? TIOCM_CTS : 0) |\n\t    (msr & UART_MSR_DCD ? TIOCM_CAR : 0) |\n\t    (msr & UART_MSR_RI ? TIOCM_RI : 0) |\n\t    (msr & UART_MSR_DSR ? TIOCM_DSR : 0);\n\n\treturn r;\n}\n\nstatic int f81534_tiocmset(struct tty_struct *tty, unsigned int set,\n\t\t\t\tunsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn f81534_update_mctrl(port, set, clear);\n}\n\nstatic void f81534_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tif (on)\n\t\tf81534_update_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\n\telse\n\t\tf81534_update_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic int f81534_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst u8 *buf, int count)\n{\n\tint bytes_out, status;\n\n\tif (!count)\n\t\treturn 0;\n\n\tbytes_out = kfifo_in_locked(&port->write_fifo, buf, count,\n\t\t\t\t\t&port->lock);\n\n\tstatus = f81534_submit_writer(port, GFP_ATOMIC);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s: submit failed\\n\", __func__);\n\t\treturn status;\n\t}\n\n\treturn bytes_out;\n}\n\nstatic bool f81534_tx_empty(struct usb_serial_port *port)\n{\n\tstruct f81534_port_private *port_priv = usb_get_serial_port_data(port);\n\n\treturn test_bit(F81534_TX_EMPTY_BIT, &port_priv->tx_empty);\n}\n\nstatic int f81534_resume(struct usb_serial *serial)\n{\n\tstruct f81534_serial_private *serial_priv =\n\t\t\tusb_get_serial_data(serial);\n\tstruct usb_serial_port *port;\n\tint error = 0;\n\tint status;\n\tsize_t i;\n\n\t \n\tmutex_lock(&serial_priv->urb_mutex);\n\n\tif (serial_priv->opened_port) {\n\t\tstatus = f81534_submit_read_urb(serial, GFP_NOIO);\n\t\tif (status) {\n\t\t\tmutex_unlock(&serial_priv->urb_mutex);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tmutex_unlock(&serial_priv->urb_mutex);\n\n\tfor (i = 0; i < serial->num_ports; i++) {\n\t\tport = serial->port[i];\n\t\tif (!tty_port_initialized(&port->port))\n\t\t\tcontinue;\n\n\t\tstatus = f81534_submit_writer(port, GFP_NOIO);\n\t\tif (status) {\n\t\t\tdev_err(&port->dev, \"%s: submit failed\\n\", __func__);\n\t\t\t++error;\n\t\t}\n\t}\n\n\tif (error)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic struct usb_serial_driver f81534_device = {\n\t.driver = {\n\t\t   .owner = THIS_MODULE,\n\t\t   .name = \"f81534\",\n\t},\n\t.description =\t\tDRIVER_DESC,\n\t.id_table =\t\tf81534_id_table,\n\t.num_bulk_in =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.open =\t\t\tf81534_open,\n\t.close =\t\tf81534_close,\n\t.write =\t\tf81534_write,\n\t.tx_empty =\t\tf81534_tx_empty,\n\t.calc_num_ports =\tf81534_calc_num_ports,\n\t.port_probe =\t\tf81534_port_probe,\n\t.port_remove =\t\tf81534_port_remove,\n\t.break_ctl =\t\tf81534_break_ctl,\n\t.dtr_rts =\t\tf81534_dtr_rts,\n\t.process_read_urb =\tf81534_process_read_urb,\n\t.get_serial =\t\tf81534_get_serial_info,\n\t.tiocmget =\t\tf81534_tiocmget,\n\t.tiocmset =\t\tf81534_tiocmset,\n\t.write_bulk_callback =\tf81534_write_usb_callback,\n\t.set_termios =\t\tf81534_set_termios,\n\t.resume =\t\tf81534_resume,\n};\n\nstatic struct usb_serial_driver *const serial_drivers[] = {\n\t&f81534_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, f81534_id_table);\n\nMODULE_DEVICE_TABLE(usb, f81534_id_table);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Peter Hong <Peter_Hong@fintek.com.tw>\");\nMODULE_AUTHOR(\"Tom Tsai <Tom_Tsai@fintek.com.tw>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}