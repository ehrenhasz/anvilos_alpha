{
  "module_name": "metro-usb.c",
  "hash_id": "61fc1687f544d255c9b4bbe277fbebb343ef92f210999ed6dcf1f9ae20bbc141",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/metro-usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/tty.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_DESC \"Metrologic Instruments Inc. - USB-POS driver\"\n\n \n#define FOCUS_VENDOR_ID\t\t\t0x0C2E\n#define FOCUS_PRODUCT_ID_BI\t\t0x0720\n#define FOCUS_PRODUCT_ID_UNI\t\t0x0700\n\n#define METROUSB_SET_REQUEST_TYPE\t0x40\n#define METROUSB_SET_MODEM_CTRL_REQUEST\t10\n#define METROUSB_SET_BREAK_REQUEST\t0x40\n#define METROUSB_MCR_NONE\t\t0x08\t \n#define METROUSB_MCR_RTS\t\t0x0a\t \n#define METROUSB_MCR_DTR\t\t0x09\t \n#define WDR_TIMEOUT\t\t\t5000\t \n\n \nstruct metrousb_private {\n\tspinlock_t lock;\n\tint throttled;\n\tunsigned long control_state;\n};\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(FOCUS_VENDOR_ID, FOCUS_PRODUCT_ID_BI) },\n\t{ USB_DEVICE(FOCUS_VENDOR_ID, FOCUS_PRODUCT_ID_UNI) },\n\t{ USB_DEVICE_INTERFACE_CLASS(0x0c2e, 0x0730, 0xff) },\t \n\t{ },  \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \n#define UNI_CMD_OPEN\t0x80\n#define UNI_CMD_CLOSE\t0xFF\n\nstatic int metrousb_is_unidirectional_mode(struct usb_serial *serial)\n{\n\tu16 product_id = le16_to_cpu(serial->dev->descriptor.idProduct);\n\n\treturn product_id == FOCUS_PRODUCT_ID_UNI;\n}\n\nstatic int metrousb_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t   struct usb_serial_endpoints *epds)\n{\n\tif (metrousb_is_unidirectional_mode(serial)) {\n\t\tif (epds->num_interrupt_out == 0) {\n\t\t\tdev_err(&serial->interface->dev, \"interrupt-out endpoint missing\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\nstatic int metrousb_send_unidirectional_cmd(u8 cmd, struct usb_serial_port *port)\n{\n\tint ret;\n\tint actual_len;\n\tu8 *buffer_cmd = NULL;\n\n\tif (!metrousb_is_unidirectional_mode(port->serial))\n\t\treturn 0;\n\n\tbuffer_cmd = kzalloc(sizeof(cmd), GFP_KERNEL);\n\tif (!buffer_cmd)\n\t\treturn -ENOMEM;\n\n\t*buffer_cmd = cmd;\n\n\tret = usb_interrupt_msg(port->serial->dev,\n\t\tusb_sndintpipe(port->serial->dev, port->interrupt_out_endpointAddress),\n\t\tbuffer_cmd, sizeof(cmd),\n\t\t&actual_len, USB_CTRL_SET_TIMEOUT);\n\n\tkfree(buffer_cmd);\n\n\tif (ret < 0)\n\t\treturn ret;\n\telse if (actual_len != sizeof(cmd))\n\t\treturn -EIO;\n\treturn 0;\n}\n\nstatic void metrousb_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned long flags;\n\tint throttled = 0;\n\tint result = 0;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - urb shutting down, error code=%d\\n\",\n\t\t\t__func__, urb->status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - non-zero urb received, error code=%d\\n\",\n\t\t\t__func__, urb->status);\n\t\tgoto exit;\n\t}\n\n\n\t \n\tif (urb->actual_length) {\n\t\t \n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\n\t\t \n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tthrottled = metro_priv->throttled;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n\n\tif (throttled)\n\t\treturn;\nexit:\n\t \n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting interrupt in urb, error code=%d\\n\",\n\t\t\t__func__, result);\n}\n\nstatic void metrousb_cleanup(struct usb_serial_port *port)\n{\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\tmetrousb_send_unidirectional_cmd(UNI_CMD_CLOSE, port);\n}\n\nstatic int metrousb_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result = 0;\n\n\t \n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tmetro_priv->control_state = 0;\n\tmetro_priv->throttled = 0;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n\n\t \n\tusb_clear_halt(serial->dev, port->interrupt_in_urb->pipe);\n\n\t \n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\t\t  usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\t\t   port->interrupt_in_urb->transfer_buffer,\n\t\t\t   port->interrupt_in_urb->transfer_buffer_length,\n\t\t\t   metrousb_read_int_callback, port, 1);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting interrupt in urb, error code=%d\\n\",\n\t\t\t__func__, result);\n\t\treturn result;\n\t}\n\n\t \n\tresult = metrousb_send_unidirectional_cmd(UNI_CMD_OPEN, port);\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed to configure device, error code=%d\\n\",\n\t\t\t__func__, result);\n\t\tgoto err_kill_urb;\n\t}\n\n\treturn 0;\n\nerr_kill_urb:\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\treturn result;\n}\n\nstatic int metrousb_set_modem_ctrl(struct usb_serial *serial, unsigned int control_state)\n{\n\tint retval = 0;\n\tunsigned char mcr = METROUSB_MCR_NONE;\n\n\tdev_dbg(&serial->dev->dev, \"%s - control state = %d\\n\",\n\t\t__func__, control_state);\n\n\t \n\tif (control_state & TIOCM_DTR)\n\t\tmcr |= METROUSB_MCR_DTR;\n\tif (control_state & TIOCM_RTS)\n\t\tmcr |= METROUSB_MCR_RTS;\n\n\t \n\tretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\tMETROUSB_SET_REQUEST_TYPE, METROUSB_SET_MODEM_CTRL_REQUEST,\n\t\t\t\tcontrol_state, 0, NULL, 0, WDR_TIMEOUT);\n\tif (retval < 0)\n\t\tdev_err(&serial->dev->dev,\n\t\t\t\"%s - set modem ctrl=0x%x failed, error code=%d\\n\",\n\t\t\t__func__, mcr, retval);\n\n\treturn retval;\n}\n\nstatic int metrousb_port_probe(struct usb_serial_port *port)\n{\n\tstruct metrousb_private *metro_priv;\n\n\tmetro_priv = kzalloc(sizeof(*metro_priv), GFP_KERNEL);\n\tif (!metro_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&metro_priv->lock);\n\n\tusb_set_serial_port_data(port, metro_priv);\n\n\treturn 0;\n}\n\nstatic void metrousb_port_remove(struct usb_serial_port *port)\n{\n\tstruct metrousb_private *metro_priv;\n\n\tmetro_priv = usb_get_serial_port_data(port);\n\tkfree(metro_priv);\n}\n\nstatic void metrousb_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tmetro_priv->throttled = 1;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n}\n\nstatic int metrousb_tiocmget(struct tty_struct *tty)\n{\n\tunsigned long control_state = 0;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tcontrol_state = metro_priv->control_state;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n\n\treturn control_state;\n}\n\nstatic int metrousb_tiocmset(struct tty_struct *tty,\n\t\t\t     unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned long control_state = 0;\n\n\tdev_dbg(&port->dev, \"%s - set=%d, clear=%d\\n\", __func__, set, clear);\n\n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tcontrol_state = metro_priv->control_state;\n\n\t \n\tif (set & TIOCM_RTS)\n\t\tcontrol_state |= TIOCM_RTS;\n\tif (set & TIOCM_DTR)\n\t\tcontrol_state |= TIOCM_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tcontrol_state &= ~TIOCM_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tcontrol_state &= ~TIOCM_DTR;\n\n\tmetro_priv->control_state = control_state;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n\treturn metrousb_set_modem_ctrl(serial, control_state);\n}\n\nstatic void metrousb_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct metrousb_private *metro_priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result = 0;\n\n\t \n\tspin_lock_irqsave(&metro_priv->lock, flags);\n\tmetro_priv->throttled = 0;\n\tspin_unlock_irqrestore(&metro_priv->lock, flags);\n\n\t \n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&port->dev,\n\t\t\t\"failed submitting interrupt in urb error code=%d\\n\",\n\t\t\tresult);\n}\n\nstatic struct usb_serial_driver metrousb_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"metro-usb\",\n\t},\n\t.description\t\t= \"Metrologic USB to Serial\",\n\t.id_table\t\t= id_table,\n\t.num_interrupt_in\t= 1,\n\t.calc_num_ports\t\t= metrousb_calc_num_ports,\n\t.open\t\t\t= metrousb_open,\n\t.close\t\t\t= metrousb_cleanup,\n\t.read_int_callback\t= metrousb_read_int_callback,\n\t.port_probe\t\t= metrousb_port_probe,\n\t.port_remove\t\t= metrousb_port_remove,\n\t.throttle\t\t= metrousb_throttle,\n\t.unthrottle\t\t= metrousb_unthrottle,\n\t.tiocmget\t\t= metrousb_tiocmget,\n\t.tiocmset\t\t= metrousb_tiocmset,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&metrousb_device,\n\tNULL,\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_LICENSE(\"GPL v2\");\nMODULE_AUTHOR(\"Philip Nicastro\");\nMODULE_AUTHOR(\"Aleksey Babahin <tamerlan311@gmail.com>\");\nMODULE_DESCRIPTION(DRIVER_DESC);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}