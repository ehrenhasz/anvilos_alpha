{
  "module_name": "usb_wwan.c",
  "hash_id": "6c9ac69a9ba72423d7e6a3c74acd70706075a75d1654f0e7bc6ffdabd578e278",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/usb_wwan.c",
  "human_readable_source": "\n \n\n#define DRIVER_AUTHOR \"Matthias Urlichs <smurf@smurf.noris.de>\"\n#define DRIVER_DESC \"USB Driver for GSM modems\"\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/serial.h>\n#include <linux/serial.h>\n#include \"usb-wwan.h\"\n\n \nstatic int usb_wwan_send_setup(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_wwan_port_private *portdata;\n\tint val = 0;\n\tint ifnum;\n\tint res;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tif (portdata->dtr_state)\n\t\tval |= USB_CDC_CTRL_DTR;\n\tif (portdata->rts_state)\n\t\tval |= USB_CDC_CTRL_RTS;\n\n\tifnum = serial->interface->cur_altsetting->desc.bInterfaceNumber;\n\n\tres = usb_autopm_get_interface(serial->interface);\n\tif (res)\n\t\treturn res;\n\n\tres = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\tUSB_CDC_REQ_SET_CONTROL_LINE_STATE,\n\t\t\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t\tval, ifnum, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\n\tusb_autopm_put_interface(port->serial->interface);\n\n\treturn res;\n}\n\nvoid usb_wwan_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata;\n\n\tintfdata = usb_get_serial_data(port->serial);\n\n\tif (!intfdata->use_send_setup)\n\t\treturn;\n\n\tportdata = usb_get_serial_port_data(port);\n\t \n\tportdata->rts_state = on;\n\tportdata->dtr_state = on;\n\n\tusb_wwan_send_setup(port);\n}\nEXPORT_SYMBOL(usb_wwan_dtr_rts);\n\nint usb_wwan_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int value;\n\tstruct usb_wwan_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tvalue = ((portdata->rts_state) ? TIOCM_RTS : 0) |\n\t    ((portdata->dtr_state) ? TIOCM_DTR : 0) |\n\t    ((portdata->cts_state) ? TIOCM_CTS : 0) |\n\t    ((portdata->dsr_state) ? TIOCM_DSR : 0) |\n\t    ((portdata->dcd_state) ? TIOCM_CAR : 0) |\n\t    ((portdata->ri_state) ? TIOCM_RNG : 0);\n\n\treturn value;\n}\nEXPORT_SYMBOL(usb_wwan_tiocmget);\n\nint usb_wwan_tiocmset(struct tty_struct *tty,\n\t\t      unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\tintfdata = usb_get_serial_data(port->serial);\n\n\tif (!intfdata->use_send_setup)\n\t\treturn -EINVAL;\n\n\t \n\tif (set & TIOCM_RTS)\n\t\tportdata->rts_state = 1;\n\tif (set & TIOCM_DTR)\n\t\tportdata->dtr_state = 1;\n\n\tif (clear & TIOCM_RTS)\n\t\tportdata->rts_state = 0;\n\tif (clear & TIOCM_DTR)\n\t\tportdata->dtr_state = 0;\n\treturn usb_wwan_send_setup(port);\n}\nEXPORT_SYMBOL(usb_wwan_tiocmset);\n\nint usb_wwan_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t   const unsigned char *buf, int count)\n{\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata;\n\tint i;\n\tint left, todo;\n\tstruct urb *this_urb = NULL;\t \n\tint err;\n\tunsigned long flags;\n\n\tportdata = usb_get_serial_port_data(port);\n\tintfdata = usb_get_serial_data(port->serial);\n\n\tdev_dbg(&port->dev, \"%s: write (%d chars)\\n\", __func__, count);\n\n\tleft = count;\n\tfor (i = 0; left > 0 && i < N_OUT_URB; i++) {\n\t\ttodo = left;\n\t\tif (todo > OUT_BUFLEN)\n\t\t\ttodo = OUT_BUFLEN;\n\n\t\tthis_urb = portdata->out_urbs[i];\n\t\tif (test_and_set_bit(i, &portdata->out_busy)) {\n\t\t\tif (time_before(jiffies,\n\t\t\t\t\tportdata->tx_start_time[i] + 10 * HZ))\n\t\t\t\tcontinue;\n\t\t\tusb_unlink_urb(this_urb);\n\t\t\tcontinue;\n\t\t}\n\t\tdev_dbg(&port->dev, \"%s: endpoint %d buf %d\\n\", __func__,\n\t\t\tusb_pipeendpoint(this_urb->pipe), i);\n\n\t\terr = usb_autopm_get_interface_async(port->serial->interface);\n\t\tif (err < 0) {\n\t\t\tclear_bit(i, &portdata->out_busy);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tmemcpy(this_urb->transfer_buffer, buf, todo);\n\t\tthis_urb->transfer_buffer_length = todo;\n\n\t\tspin_lock_irqsave(&intfdata->susp_lock, flags);\n\t\tif (intfdata->suspended) {\n\t\t\tusb_anchor_urb(this_urb, &portdata->delayed);\n\t\t\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\t\t} else {\n\t\t\tintfdata->in_flight++;\n\t\t\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\t\t\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&port->dev,\n\t\t\t\t\t\"%s: submit urb %d failed: %d\\n\",\n\t\t\t\t\t__func__, i, err);\n\t\t\t\tclear_bit(i, &portdata->out_busy);\n\t\t\t\tspin_lock_irqsave(&intfdata->susp_lock, flags);\n\t\t\t\tintfdata->in_flight--;\n\t\t\t\tspin_unlock_irqrestore(&intfdata->susp_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tusb_autopm_put_interface_async(port->serial->interface);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tportdata->tx_start_time[i] = jiffies;\n\t\tbuf += todo;\n\t\tleft -= todo;\n\t}\n\n\tcount -= left;\n\tdev_dbg(&port->dev, \"%s: wrote (did %d)\\n\", __func__, count);\n\treturn count;\n}\nEXPORT_SYMBOL(usb_wwan_write);\n\nstatic void usb_wwan_indat_callback(struct urb *urb)\n{\n\tint err;\n\tint endpoint;\n\tstruct usb_serial_port *port;\n\tstruct device *dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tendpoint = usb_pipeendpoint(urb->pipe);\n\tport = urb->context;\n\tdev = &port->dev;\n\n\tif (status) {\n\t\tdev_dbg(dev, \"%s: nonzero status: %d on endpoint %02x.\\n\",\n\t\t\t__func__, status, endpoint);\n\n\t\t \n\t\tif (status == -ESHUTDOWN || status == -ENOENT)\n\t\t\treturn;\n\t} else {\n\t\tif (urb->actual_length) {\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\t\ttty_flip_buffer_push(&port->port);\n\t\t} else\n\t\t\tdev_dbg(dev, \"%s: empty read urb received\\n\", __func__);\n\t}\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err) {\n\t\tif (err != -EPERM && err != -ENODEV) {\n\t\t\tdev_err(dev, \"%s: resubmit read urb failed. (%d)\\n\",\n\t\t\t\t__func__, err);\n\t\t\t \n\t\t\tusb_mark_last_busy(port->serial->dev);\n\t\t}\n\t} else {\n\t\tusb_mark_last_busy(port->serial->dev);\n\t}\n}\n\nstatic void usb_wwan_outdat_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata;\n\tunsigned long flags;\n\tint i;\n\n\tport = urb->context;\n\tintfdata = usb_get_serial_data(port->serial);\n\n\tusb_serial_port_softint(port);\n\tusb_autopm_put_interface_async(port->serial->interface);\n\tportdata = usb_get_serial_port_data(port);\n\tspin_lock_irqsave(&intfdata->susp_lock, flags);\n\tintfdata->in_flight--;\n\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\n\tfor (i = 0; i < N_OUT_URB; ++i) {\n\t\tif (portdata->out_urbs[i] == urb) {\n\t\t\tsmp_mb__before_atomic();\n\t\t\tclear_bit(i, &portdata->out_busy);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nunsigned int usb_wwan_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_wwan_port_private *portdata;\n\tint i;\n\tunsigned int data_len = 0;\n\tstruct urb *this_urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tthis_urb = portdata->out_urbs[i];\n\t\tif (this_urb && !test_bit(i, &portdata->out_busy))\n\t\t\tdata_len += OUT_BUFLEN;\n\t}\n\n\tdev_dbg(&port->dev, \"%s: %u\\n\", __func__, data_len);\n\treturn data_len;\n}\nEXPORT_SYMBOL(usb_wwan_write_room);\n\nunsigned int usb_wwan_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_wwan_port_private *portdata;\n\tint i;\n\tunsigned int data_len = 0;\n\tstruct urb *this_urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tthis_urb = portdata->out_urbs[i];\n\t\t \n\t\tif (this_urb && test_bit(i, &portdata->out_busy))\n\t\t\tdata_len += this_urb->transfer_buffer_length;\n\t}\n\tdev_dbg(&port->dev, \"%s: %u\\n\", __func__, data_len);\n\treturn data_len;\n}\nEXPORT_SYMBOL(usb_wwan_chars_in_buffer);\n\nint usb_wwan_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata;\n\tstruct usb_serial *serial = port->serial;\n\tint i, err;\n\tstruct urb *urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\tintfdata = usb_get_serial_data(serial);\n\n\tif (port->interrupt_in_urb) {\n\t\terr = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev, \"%s: submit int urb failed: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < N_IN_URB; i++) {\n\t\turb = portdata->in_urbs[i];\n\t\tif (!urb)\n\t\t\tcontinue;\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s: submit read urb %d failed: %d\\n\",\n\t\t\t\t__func__, i, err);\n\t\t}\n\t}\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (++intfdata->open_ports == 1)\n\t\tserial->interface->needs_remote_wakeup = 1;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\t \n\tusb_autopm_put_interface(serial->interface);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(usb_wwan_open);\n\nstatic void unbusy_queued_urb(struct urb *urb,\n\t\t\t\t\tstruct usb_wwan_port_private *portdata)\n{\n\tint i;\n\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tif (urb == portdata->out_urbs[i]) {\n\t\t\tclear_bit(i, &portdata->out_busy);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid usb_wwan_close(struct usb_serial_port *port)\n{\n\tint i;\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_wwan_port_private *portdata;\n\tstruct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);\n\tstruct urb *urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\t \n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (--intfdata->open_ports == 0)\n\t\tserial->interface->needs_remote_wakeup = 0;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\tfor (;;) {\n\t\turb = usb_get_from_anchor(&portdata->delayed);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\tunbusy_queued_urb(urb, portdata);\n\t\tusb_autopm_put_interface_async(serial->interface);\n\t}\n\n\tfor (i = 0; i < N_IN_URB; i++)\n\t\tusb_kill_urb(portdata->in_urbs[i]);\n\tfor (i = 0; i < N_OUT_URB; i++)\n\t\tusb_kill_urb(portdata->out_urbs[i]);\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\tusb_autopm_get_interface_no_resume(serial->interface);\n}\nEXPORT_SYMBOL(usb_wwan_close);\n\nstatic struct urb *usb_wwan_setup_urb(struct usb_serial_port *port,\n\t\t\t\t      int endpoint,\n\t\t\t\t      int dir, void *ctx, char *buf, int len,\n\t\t\t\t      void (*callback) (struct urb *))\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);\n\tstruct urb *urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\t \n\tif (!urb)\n\t\treturn NULL;\n\n\tusb_fill_bulk_urb(urb, serial->dev,\n\t\t\t  usb_sndbulkpipe(serial->dev, endpoint) | dir,\n\t\t\t  buf, len, callback, ctx);\n\n\tif (intfdata->use_zlp && dir == USB_DIR_OUT)\n\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\treturn urb;\n}\n\nint usb_wwan_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_wwan_port_private *portdata;\n\tstruct urb *urb;\n\tu8 *buffer;\n\tint i;\n\n\tif (!port->bulk_in_size || !port->bulk_out_size)\n\t\treturn -ENODEV;\n\n\tportdata = kzalloc(sizeof(*portdata), GFP_KERNEL);\n\tif (!portdata)\n\t\treturn -ENOMEM;\n\n\tinit_usb_anchor(&portdata->delayed);\n\n\tfor (i = 0; i < N_IN_URB; i++) {\n\t\tbuffer = (u8 *)__get_free_page(GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\tgoto bail_out_error;\n\t\tportdata->in_buffer[i] = buffer;\n\n\t\turb = usb_wwan_setup_urb(port, port->bulk_in_endpointAddress,\n\t\t\t\t\t\tUSB_DIR_IN, port,\n\t\t\t\t\t\tbuffer, IN_BUFLEN,\n\t\t\t\t\t\tusb_wwan_indat_callback);\n\t\tportdata->in_urbs[i] = urb;\n\t}\n\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tbuffer = kmalloc(OUT_BUFLEN, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\tgoto bail_out_error2;\n\t\tportdata->out_buffer[i] = buffer;\n\n\t\turb = usb_wwan_setup_urb(port, port->bulk_out_endpointAddress,\n\t\t\t\t\t\tUSB_DIR_OUT, port,\n\t\t\t\t\t\tbuffer, OUT_BUFLEN,\n\t\t\t\t\t\tusb_wwan_outdat_callback);\n\t\tportdata->out_urbs[i] = urb;\n\t}\n\n\tusb_set_serial_port_data(port, portdata);\n\n\treturn 0;\n\nbail_out_error2:\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tusb_free_urb(portdata->out_urbs[i]);\n\t\tkfree(portdata->out_buffer[i]);\n\t}\nbail_out_error:\n\tfor (i = 0; i < N_IN_URB; i++) {\n\t\tusb_free_urb(portdata->in_urbs[i]);\n\t\tfree_page((unsigned long)portdata->in_buffer[i]);\n\t}\n\tkfree(portdata);\n\n\treturn -ENOMEM;\n}\nEXPORT_SYMBOL_GPL(usb_wwan_port_probe);\n\nvoid usb_wwan_port_remove(struct usb_serial_port *port)\n{\n\tint i;\n\tstruct usb_wwan_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\tusb_set_serial_port_data(port, NULL);\n\n\tfor (i = 0; i < N_IN_URB; i++) {\n\t\tusb_free_urb(portdata->in_urbs[i]);\n\t\tfree_page((unsigned long)portdata->in_buffer[i]);\n\t}\n\tfor (i = 0; i < N_OUT_URB; i++) {\n\t\tusb_free_urb(portdata->out_urbs[i]);\n\t\tkfree(portdata->out_buffer[i]);\n\t}\n\n\tkfree(portdata);\n}\nEXPORT_SYMBOL(usb_wwan_port_remove);\n\n#ifdef CONFIG_PM\nstatic void stop_urbs(struct usb_serial *serial)\n{\n\tint i, j;\n\tstruct usb_serial_port *port;\n\tstruct usb_wwan_port_private *portdata;\n\n\tfor (i = 0; i < serial->num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tportdata = usb_get_serial_port_data(port);\n\t\tif (!portdata)\n\t\t\tcontinue;\n\t\tfor (j = 0; j < N_IN_URB; j++)\n\t\t\tusb_kill_urb(portdata->in_urbs[j]);\n\t\tfor (j = 0; j < N_OUT_URB; j++)\n\t\t\tusb_kill_urb(portdata->out_urbs[j]);\n\t\tusb_kill_urb(port->interrupt_in_urb);\n\t}\n}\n\nint usb_wwan_suspend(struct usb_serial *serial, pm_message_t message)\n{\n\tstruct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (PMSG_IS_AUTO(message)) {\n\t\tif (intfdata->in_flight) {\n\t\t\tspin_unlock_irq(&intfdata->susp_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tintfdata->suspended = 1;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\tstop_urbs(serial);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(usb_wwan_suspend);\n\n \nstatic int usb_wwan_submit_delayed_urbs(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_wwan_intf_private *data = usb_get_serial_data(serial);\n\tstruct usb_wwan_port_private *portdata;\n\tstruct urb *urb;\n\tint err_count = 0;\n\tint err;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tfor (;;) {\n\t\turb = usb_get_from_anchor(&portdata->delayed);\n\t\tif (!urb)\n\t\t\tbreak;\n\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev, \"%s: submit urb failed: %d\\n\",\n\t\t\t\t\t__func__, err);\n\t\t\terr_count++;\n\t\t\tunbusy_queued_urb(urb, portdata);\n\t\t\tusb_autopm_put_interface_async(serial->interface);\n\t\t\tcontinue;\n\t\t}\n\t\tdata->in_flight++;\n\t}\n\n\tif (err_count)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nint usb_wwan_resume(struct usb_serial *serial)\n{\n\tint i, j;\n\tstruct usb_serial_port *port;\n\tstruct usb_wwan_intf_private *intfdata = usb_get_serial_data(serial);\n\tstruct usb_wwan_port_private *portdata;\n\tstruct urb *urb;\n\tint err;\n\tint err_count = 0;\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tfor (i = 0; i < serial->num_ports; i++) {\n\t\tport = serial->port[i];\n\n\t\tif (!tty_port_initialized(&port->port))\n\t\t\tcontinue;\n\n\t\tportdata = usb_get_serial_port_data(port);\n\n\t\tif (port->interrupt_in_urb) {\n\t\t\terr = usb_submit_urb(port->interrupt_in_urb,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tif (err) {\n\t\t\t\tdev_err(&port->dev,\n\t\t\t\t\t\"%s: submit int urb failed: %d\\n\",\n\t\t\t\t\t__func__, err);\n\t\t\t\terr_count++;\n\t\t\t}\n\t\t}\n\n\t\terr = usb_wwan_submit_delayed_urbs(port);\n\t\tif (err)\n\t\t\terr_count++;\n\n\t\tfor (j = 0; j < N_IN_URB; j++) {\n\t\t\turb = portdata->in_urbs[j];\n\t\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(&port->dev,\n\t\t\t\t\t\"%s: submit read urb %d failed: %d\\n\",\n\t\t\t\t\t__func__, i, err);\n\t\t\t\terr_count++;\n\t\t\t}\n\t\t}\n\t}\n\tintfdata->suspended = 0;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\tif (err_count)\n\t\treturn -EIO;\n\n\treturn 0;\n}\nEXPORT_SYMBOL(usb_wwan_resume);\n#endif\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}