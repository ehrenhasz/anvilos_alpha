{
  "module_name": "f81232.c",
  "hash_id": "2784f45a2e72ad36d1c7c028a0c0c3e8e690f243dd82c856482fd7f478b5fa03",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/f81232.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial_reg.h>\n\n#define F81232_ID\t\t\\\n\t{ USB_DEVICE(0x1934, 0x0706) }\t \n\n#define F81534A_SERIES_ID\t\\\n\t{ USB_DEVICE(0x2c42, 0x1602) },\t \t\\\n\t{ USB_DEVICE(0x2c42, 0x1604) },\t \t\\\n\t{ USB_DEVICE(0x2c42, 0x1605) },\t \t\\\n\t{ USB_DEVICE(0x2c42, 0x1606) },\t  \\\n\t{ USB_DEVICE(0x2c42, 0x1608) },\t  \\\n\t{ USB_DEVICE(0x2c42, 0x1632) },\t  \\\n\t{ USB_DEVICE(0x2c42, 0x1634) },\t  \\\n\t{ USB_DEVICE(0x2c42, 0x1635) },\t  \\\n\t{ USB_DEVICE(0x2c42, 0x1636) }\t \n\n#define F81534A_CTRL_ID\t\t\\\n\t{ USB_DEVICE(0x2c42, 0x16f8) }\t \n\nstatic const struct usb_device_id f81232_id_table[] = {\n\tF81232_ID,\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id f81534a_id_table[] = {\n\tF81534A_SERIES_ID,\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id f81534a_ctrl_id_table[] = {\n\tF81534A_CTRL_ID,\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id combined_id_table[] = {\n\tF81232_ID,\n\tF81534A_SERIES_ID,\n\tF81534A_CTRL_ID,\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, combined_id_table);\n\n \n#define F81232_MAX_BAUDRATE\t\t1500000\n#define F81232_DEF_BAUDRATE\t\t9600\n\n \n#define F81232_REGISTER_REQUEST\t\t0xa0\n#define F81232_GET_REGISTER\t\t0xc0\n#define F81232_SET_REGISTER\t\t0x40\n#define F81534A_ACCESS_REG_RETRY\t2\n\n#define SERIAL_BASE_ADDRESS\t\t0x0120\n#define RECEIVE_BUFFER_REGISTER\t\t(0x00 + SERIAL_BASE_ADDRESS)\n#define INTERRUPT_ENABLE_REGISTER\t(0x01 + SERIAL_BASE_ADDRESS)\n#define FIFO_CONTROL_REGISTER\t\t(0x02 + SERIAL_BASE_ADDRESS)\n#define LINE_CONTROL_REGISTER\t\t(0x03 + SERIAL_BASE_ADDRESS)\n#define MODEM_CONTROL_REGISTER\t\t(0x04 + SERIAL_BASE_ADDRESS)\n#define LINE_STATUS_REGISTER\t\t(0x05 + SERIAL_BASE_ADDRESS)\n#define MODEM_STATUS_REGISTER\t\t(0x06 + SERIAL_BASE_ADDRESS)\n\n \n#define F81232_CLK_REGISTER\t\t0x106\n#define F81232_CLK_1_846_MHZ\t\t0\n#define F81232_CLK_18_46_MHZ\t\tBIT(0)\n#define F81232_CLK_24_MHZ\t\tBIT(1)\n#define F81232_CLK_14_77_MHZ\t\t(BIT(1) | BIT(0))\n#define F81232_CLK_MASK\t\t\tGENMASK(1, 0)\n\n#define F81534A_MODE_REG\t\t0x107\n#define F81534A_TRIGGER_MASK\t\tGENMASK(3, 2)\n#define F81534A_TRIGGER_MULTIPLE_4X\tBIT(3)\n#define F81534A_FIFO_128BYTE\t\t(BIT(1) | BIT(0))\n\n \n#define F81534A_GPIO_REG\t\t0x10e\n#define F81534A_GPIO_MODE2_DIR\t\tBIT(6)  \n#define F81534A_GPIO_MODE1_DIR\t\tBIT(5)\n#define F81534A_GPIO_MODE0_DIR\t\tBIT(4)\n#define F81534A_GPIO_MODE2_OUTPUT\tBIT(2)\n#define F81534A_GPIO_MODE1_OUTPUT\tBIT(1)\n#define F81534A_GPIO_MODE0_OUTPUT\tBIT(0)\n\n#define F81534A_CTRL_CMD_ENABLE_PORT\t0x116\n\nstruct f81232_private {\n\tstruct mutex lock;\n\tu8 modem_control;\n\tu8 modem_status;\n\tu8 shadow_lcr;\n\tspeed_t baud_base;\n\tstruct work_struct lsr_work;\n\tstruct work_struct interrupt_work;\n\tstruct usb_serial_port *port;\n};\n\nstatic u32 const baudrate_table[] = { 115200, 921600, 1152000, 1500000 };\nstatic u8 const clock_table[] = { F81232_CLK_1_846_MHZ, F81232_CLK_14_77_MHZ,\n\t\t\t\tF81232_CLK_18_46_MHZ, F81232_CLK_24_MHZ };\n\nstatic int calc_baud_divisor(speed_t baudrate, speed_t clockrate)\n{\n\treturn DIV_ROUND_CLOSEST(clockrate, baudrate);\n}\n\nstatic int f81232_get_register(struct usb_serial_port *port, u16 reg, u8 *val)\n{\n\tint status;\n\tstruct usb_device *dev = port->serial->dev;\n\n\tstatus = usb_control_msg_recv(dev,\n\t\t\t\t      0,\n\t\t\t\t      F81232_REGISTER_REQUEST,\n\t\t\t\t      F81232_GET_REGISTER,\n\t\t\t\t      reg,\n\t\t\t\t      0,\n\t\t\t\t      val,\n\t\t\t\t      sizeof(*val),\n\t\t\t\t      USB_CTRL_GET_TIMEOUT,\n\t\t\t\t      GFP_KERNEL);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed status: %d\\n\", __func__, status);\n\t\tstatus = usb_translate_errors(status);\n\t}\n\n\treturn status;\n}\n\nstatic int f81232_set_register(struct usb_serial_port *port, u16 reg, u8 val)\n{\n\tint status;\n\tstruct usb_device *dev = port->serial->dev;\n\n\tstatus = usb_control_msg_send(dev,\n\t\t\t\t      0,\n\t\t\t\t      F81232_REGISTER_REQUEST,\n\t\t\t\t      F81232_SET_REGISTER,\n\t\t\t\t      reg,\n\t\t\t\t      0,\n\t\t\t\t      &val,\n\t\t\t\t      sizeof(val),\n\t\t\t\t      USB_CTRL_SET_TIMEOUT,\n\t\t\t\t      GFP_KERNEL);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed status: %d\\n\", __func__, status);\n\t\tstatus = usb_translate_errors(status);\n\t}\n\n\treturn status;\n}\n\nstatic int f81232_set_mask_register(struct usb_serial_port *port, u16 reg,\n\t\t\t\t\tu8 mask, u8 val)\n{\n\tint status;\n\tu8 tmp;\n\n\tstatus = f81232_get_register(port, reg, &tmp);\n\tif (status)\n\t\treturn status;\n\n\ttmp = (tmp & ~mask) | (val & mask);\n\n\treturn f81232_set_register(port, reg, tmp);\n}\n\nstatic void f81232_read_msr(struct usb_serial_port *port)\n{\n\tint status;\n\tu8 current_msr;\n\tstruct tty_struct *tty;\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\n\tmutex_lock(&priv->lock);\n\tstatus = f81232_get_register(port, MODEM_STATUS_REGISTER,\n\t\t\t&current_msr);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s fail, status: %d\\n\", __func__, status);\n\t\tmutex_unlock(&priv->lock);\n\t\treturn;\n\t}\n\n\tif (!(current_msr & UART_MSR_ANY_DELTA)) {\n\t\tmutex_unlock(&priv->lock);\n\t\treturn;\n\t}\n\n\tpriv->modem_status = current_msr;\n\n\tif (current_msr & UART_MSR_DCTS)\n\t\tport->icount.cts++;\n\tif (current_msr & UART_MSR_DDSR)\n\t\tport->icount.dsr++;\n\tif (current_msr & UART_MSR_TERI)\n\t\tport->icount.rng++;\n\tif (current_msr & UART_MSR_DDCD) {\n\t\tport->icount.dcd++;\n\t\ttty = tty_port_tty_get(&port->port);\n\t\tif (tty) {\n\t\t\tusb_serial_handle_dcd_change(port, tty,\n\t\t\t\t\tcurrent_msr & UART_MSR_DCD);\n\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t}\n\n\twake_up_interruptible(&port->port.delta_msr_wait);\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int f81232_set_mctrl(struct usb_serial_port *port,\n\t\t\t\t\t   unsigned int set, unsigned int clear)\n{\n\tu8 val;\n\tint status;\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0)\n\t\treturn 0;\t \n\n\t \n\tclear &= ~set;\n\n\t \n\tmutex_lock(&priv->lock);\n\tval = UART_MCR_OUT2 | priv->modem_control;\n\n\tif (clear & TIOCM_DTR)\n\t\tval &= ~UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tval &= ~UART_MCR_RTS;\n\n\tif (set & TIOCM_DTR)\n\t\tval |= UART_MCR_DTR;\n\n\tif (set & TIOCM_RTS)\n\t\tval |= UART_MCR_RTS;\n\n\tdev_dbg(&port->dev, \"%s new:%02x old:%02x\\n\", __func__,\n\t\t\tval, priv->modem_control);\n\n\tstatus = f81232_set_register(port, MODEM_CONTROL_REGISTER, val);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s set MCR status < 0\\n\", __func__);\n\t\tmutex_unlock(&priv->lock);\n\t\treturn status;\n\t}\n\n\tpriv->modem_control = val;\n\tmutex_unlock(&priv->lock);\n\n\treturn 0;\n}\n\nstatic void f81232_update_line_status(struct usb_serial_port *port,\n\t\t\t\t      unsigned char *data,\n\t\t\t\t      size_t actual_length)\n{\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\n\tif (!actual_length)\n\t\treturn;\n\n\tswitch (data[0] & 0x07) {\n\tcase 0x00:  \n\t\tdev_dbg(&port->dev, \"IIR: MSR Change: %02x\\n\", data[0]);\n\t\tschedule_work(&priv->interrupt_work);\n\t\tbreak;\n\tcase 0x02:  \n\t\tbreak;\n\tcase 0x04:  \n\t\tbreak;\n\tcase 0x06:  \n\t\t \n\t\tdev_dbg(&port->dev, \"IIR: LSR Change: %02x\\n\", data[0]);\n\t\tbreak;\n\t}\n}\n\nstatic void f81232_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port =  urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned int actual_length = urb->actual_length;\n\tint status = urb->status;\n\tint retval;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__,\n\t\t\t      urb->actual_length, urb->transfer_buffer);\n\n\tf81232_update_line_status(port, data, actual_length);\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic char f81232_handle_lsr(struct usb_serial_port *port, u8 lsr)\n{\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\tchar tty_flag = TTY_NORMAL;\n\n\tif (!(lsr & UART_LSR_BRK_ERROR_BITS))\n\t\treturn tty_flag;\n\n\tif (lsr & UART_LSR_BI) {\n\t\ttty_flag = TTY_BREAK;\n\t\tport->icount.brk++;\n\t\tusb_serial_handle_break(port);\n\t} else if (lsr & UART_LSR_PE) {\n\t\ttty_flag = TTY_PARITY;\n\t\tport->icount.parity++;\n\t} else if (lsr & UART_LSR_FE) {\n\t\ttty_flag = TTY_FRAME;\n\t\tport->icount.frame++;\n\t}\n\n\tif (lsr & UART_LSR_OE) {\n\t\tport->icount.overrun++;\n\t\tschedule_work(&priv->lsr_work);\n\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t}\n\n\treturn tty_flag;\n}\n\nstatic void f81232_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tchar tty_flag;\n\tunsigned int i;\n\tu8 lsr;\n\n\t \n\tif ((urb->actual_length < 2) || (urb->actual_length % 2))\n\t\treturn;\n\n\t \n\n\tfor (i = 0; i < urb->actual_length; i += 2) {\n\t\tlsr = data[i];\n\t\ttty_flag = f81232_handle_lsr(port, lsr);\n\n\t\tif (port->sysrq) {\n\t\t\tif (usb_serial_handle_sysrq_char(port, data[i + 1]))\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttty_insert_flip_char(&port->port, data[i + 1], tty_flag);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void f81534a_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tchar tty_flag;\n\tunsigned int i;\n\tu8 lsr;\n\tu8 len;\n\n\tif (urb->actual_length < 3) {\n\t\tdev_err(&port->dev, \"short message received: %d\\n\",\n\t\t\t\turb->actual_length);\n\t\treturn;\n\t}\n\n\tlen = data[0];\n\tif (len != urb->actual_length) {\n\t\tdev_err(&port->dev, \"malformed message received: %d (%d)\\n\",\n\t\t\t\turb->actual_length, len);\n\t\treturn;\n\t}\n\n\t \n\tlsr = data[len - 1];\n\ttty_flag = f81232_handle_lsr(port, lsr);\n\n\tif (port->sysrq) {\n\t\tfor (i = 1; i < len - 1; ++i) {\n\t\t\tif (!usb_serial_handle_sysrq_char(port, data[i])) {\n\t\t\t\ttty_insert_flip_char(&port->port, data[i],\n\t\t\t\t\t\ttty_flag);\n\t\t\t}\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string_fixed_flag(&port->port, &data[1],\n\t\t\t\t\t\t\ttty_flag, len - 2);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int f81232_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\tint status;\n\n\tmutex_lock(&priv->lock);\n\n\tif (break_state)\n\t\tpriv->shadow_lcr |= UART_LCR_SBC;\n\telse\n\t\tpriv->shadow_lcr &= ~UART_LCR_SBC;\n\n\tstatus = f81232_set_register(port, LINE_CONTROL_REGISTER,\n\t\t\t\t\tpriv->shadow_lcr);\n\tif (status)\n\t\tdev_err(&port->dev, \"set break failed: %d\\n\", status);\n\n\tmutex_unlock(&priv->lock);\n\n\treturn status;\n}\n\nstatic int f81232_find_clk(speed_t baudrate)\n{\n\tint idx;\n\n\tfor (idx = 0; idx < ARRAY_SIZE(baudrate_table); ++idx) {\n\t\tif (baudrate <= baudrate_table[idx] &&\n\t\t\t\tbaudrate_table[idx] % baudrate == 0)\n\t\t\treturn idx;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic void f81232_set_baudrate(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port, speed_t baudrate,\n\t\t\t\tspeed_t old_baudrate)\n{\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\tu8 lcr;\n\tint divisor;\n\tint status = 0;\n\tint i;\n\tint idx;\n\tspeed_t baud_list[] = { baudrate, old_baudrate, F81232_DEF_BAUDRATE };\n\n\tfor (i = 0; i < ARRAY_SIZE(baud_list); ++i) {\n\t\tbaudrate = baud_list[i];\n\t\tif (baudrate == 0) {\n\t\t\ttty_encode_baud_rate(tty, 0, 0);\n\t\t\treturn;\n\t\t}\n\n\t\tidx = f81232_find_clk(baudrate);\n\t\tif (idx >= 0) {\n\t\t\ttty_encode_baud_rate(tty, baudrate, baudrate);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (idx < 0)\n\t\treturn;\n\n\tpriv->baud_base = baudrate_table[idx];\n\tdivisor = calc_baud_divisor(baudrate, priv->baud_base);\n\n\tstatus = f81232_set_mask_register(port, F81232_CLK_REGISTER,\n\t\t\tF81232_CLK_MASK, clock_table[idx]);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set CLK_REG: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tstatus = f81232_get_register(port, LINE_CONTROL_REGISTER,\n\t\t\t &lcr);  \n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to get LCR: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tstatus = f81232_set_register(port, LINE_CONTROL_REGISTER,\n\t\t\t lcr | UART_LCR_DLAB);  \n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set DLAB: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tstatus = f81232_set_register(port, RECEIVE_BUFFER_REGISTER,\n\t\t\t divisor & 0x00ff);  \n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set baudrate MSB: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto reapply_lcr;\n\t}\n\n\tstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER,\n\t\t\t (divisor & 0xff00) >> 8);  \n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set baudrate LSB: %d\\n\",\n\t\t\t__func__, status);\n\t}\n\nreapply_lcr:\n\tstatus = f81232_set_register(port, LINE_CONTROL_REGISTER,\n\t\t\tlcr & ~UART_LCR_DLAB);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set DLAB: %d\\n\",\n\t\t\t__func__, status);\n\t}\n}\n\nstatic int f81232_port_enable(struct usb_serial_port *port)\n{\n\tu8 val;\n\tint status;\n\n\t \n\tval = UART_FCR_TRIGGER_8 | UART_FCR_ENABLE_FIFO | UART_FCR_CLEAR_RCVR |\n\t\t\tUART_FCR_CLEAR_XMIT;\n\n\tstatus = f81232_set_register(port, FIFO_CONTROL_REGISTER, val);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set FCR: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\t \n\tstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER,\n\t\t\tUART_IER_MSI);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set IER: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int f81232_port_disable(struct usb_serial_port *port)\n{\n\tint status;\n\n\tstatus = f81232_set_register(port, INTERRUPT_ENABLE_REGISTER, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set IER: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic void f81232_set_termios(struct tty_struct *tty,\n\t\t\t       struct usb_serial_port *port,\n\t\t\t       const struct ktermios *old_termios)\n{\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\tu8 new_lcr = 0;\n\tint status = 0;\n\tspeed_t baudrate;\n\tspeed_t old_baud;\n\n\t \n\tif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\n\t\treturn;\n\n\tif (C_BAUD(tty) == B0)\n\t\tf81232_set_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\n\telse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\tf81232_set_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\n\n\tbaudrate = tty_get_baud_rate(tty);\n\tif (baudrate > 0) {\n\t\tif (old_termios)\n\t\t\told_baud = tty_termios_baud_rate(old_termios);\n\t\telse\n\t\t\told_baud = F81232_DEF_BAUDRATE;\n\n\t\tf81232_set_baudrate(tty, port, baudrate, old_baud);\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\tnew_lcr |= UART_LCR_PARITY;\n\n\t\tif (!C_PARODD(tty))\n\t\t\tnew_lcr |= UART_LCR_EPAR;\n\n\t\tif (C_CMSPAR(tty))\n\t\t\tnew_lcr |= UART_LCR_SPAR;\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tnew_lcr |= UART_LCR_STOP;\n\n\tnew_lcr |= UART_LCR_WLEN(tty_get_char_size(tty->termios.c_cflag));\n\n\tmutex_lock(&priv->lock);\n\n\tnew_lcr |= (priv->shadow_lcr & UART_LCR_SBC);\n\tstatus = f81232_set_register(port, LINE_CONTROL_REGISTER, new_lcr);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s failed to set LCR: %d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\tpriv->shadow_lcr = new_lcr;\n\n\tmutex_unlock(&priv->lock);\n}\n\nstatic int f81232_tiocmget(struct tty_struct *tty)\n{\n\tint r;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81232_private *port_priv = usb_get_serial_port_data(port);\n\tu8 mcr, msr;\n\n\t \n\tf81232_read_msr(port);\n\n\tmutex_lock(&port_priv->lock);\n\tmcr = port_priv->modem_control;\n\tmsr = port_priv->modem_status;\n\tmutex_unlock(&port_priv->lock);\n\n\tr = (mcr & UART_MCR_DTR ? TIOCM_DTR : 0) |\n\t\t(mcr & UART_MCR_RTS ? TIOCM_RTS : 0) |\n\t\t(msr & UART_MSR_CTS ? TIOCM_CTS : 0) |\n\t\t(msr & UART_MSR_DCD ? TIOCM_CAR : 0) |\n\t\t(msr & UART_MSR_RI ? TIOCM_RI : 0) |\n\t\t(msr & UART_MSR_DSR ? TIOCM_DSR : 0);\n\n\treturn r;\n}\n\nstatic int f81232_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn f81232_set_mctrl(port, set, clear);\n}\n\nstatic int f81232_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result;\n\n\tresult = f81232_port_enable(port);\n\tif (result)\n\t\treturn result;\n\n\t \n\tif (tty)\n\t\tf81232_set_termios(tty, port, NULL);\n\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"%s - failed submitting interrupt urb,\"\n\t\t\t\" error %d\\n\", __func__, result);\n\t\treturn result;\n\t}\n\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result) {\n\t\tusb_kill_urb(port->interrupt_in_urb);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic int f81534a_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint status;\n\tu8 mask;\n\tu8 val;\n\n\tval = F81534A_TRIGGER_MULTIPLE_4X | F81534A_FIFO_128BYTE;\n\tmask = F81534A_TRIGGER_MASK | F81534A_FIFO_128BYTE;\n\n\tstatus = f81232_set_mask_register(port, F81534A_MODE_REG, mask, val);\n\tif (status) {\n\t\tdev_err(&port->dev, \"failed to set MODE_REG: %d\\n\", status);\n\t\treturn status;\n\t}\n\n\treturn f81232_open(tty, port);\n}\n\nstatic void f81232_close(struct usb_serial_port *port)\n{\n\tstruct f81232_private *port_priv = usb_get_serial_port_data(port);\n\n\tf81232_port_disable(port);\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n\tflush_work(&port_priv->interrupt_work);\n\tflush_work(&port_priv->lsr_work);\n}\n\nstatic void f81232_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tif (on)\n\t\tf81232_set_mctrl(port, TIOCM_DTR | TIOCM_RTS, 0);\n\telse\n\t\tf81232_set_mctrl(port, 0, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic bool f81232_tx_empty(struct usb_serial_port *port)\n{\n\tint status;\n\tu8 tmp;\n\n\tstatus = f81232_get_register(port, LINE_STATUS_REGISTER, &tmp);\n\tif (!status) {\n\t\tif ((tmp & UART_LSR_TEMT) != UART_LSR_TEMT)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic int f81232_carrier_raised(struct usb_serial_port *port)\n{\n\tu8 msr;\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\n\tmutex_lock(&priv->lock);\n\tmsr = priv->modem_status;\n\tmutex_unlock(&priv->lock);\n\n\tif (msr & UART_MSR_DCD)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void f81232_get_serial(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct f81232_private *priv = usb_get_serial_port_data(port);\n\n\tss->baud_base = priv->baud_base;\n}\n\nstatic void  f81232_interrupt_work(struct work_struct *work)\n{\n\tstruct f81232_private *priv =\n\t\tcontainer_of(work, struct f81232_private, interrupt_work);\n\n\tf81232_read_msr(priv->port);\n}\n\nstatic void f81232_lsr_worker(struct work_struct *work)\n{\n\tstruct f81232_private *priv;\n\tstruct usb_serial_port *port;\n\tint status;\n\tu8 tmp;\n\n\tpriv = container_of(work, struct f81232_private, lsr_work);\n\tport = priv->port;\n\n\tstatus = f81232_get_register(port, LINE_STATUS_REGISTER, &tmp);\n\tif (status)\n\t\tdev_warn(&port->dev, \"read LSR failed: %d\\n\", status);\n}\n\nstatic int f81534a_ctrl_set_register(struct usb_interface *intf, u16 reg,\n\t\t\t\t\tu16 size, void *val)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tint retry = F81534A_ACCESS_REG_RETRY;\n\tint status;\n\n\twhile (retry--) {\n\t\tstatus = usb_control_msg_send(dev,\n\t\t\t\t\t      0,\n\t\t\t\t\t      F81232_REGISTER_REQUEST,\n\t\t\t\t\t      F81232_SET_REGISTER,\n\t\t\t\t\t      reg,\n\t\t\t\t\t      0,\n\t\t\t\t\t      val,\n\t\t\t\t\t      size,\n\t\t\t\t\t      USB_CTRL_SET_TIMEOUT,\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (status) {\n\t\t\tstatus = usb_translate_errors(status);\n\t\t\tif (status == -EIO)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (status) {\n\t\tdev_err(&intf->dev, \"failed to set register 0x%x: %d\\n\",\n\t\t\t\treg, status);\n\t}\n\n\treturn status;\n}\n\nstatic int f81534a_ctrl_enable_all_ports(struct usb_interface *intf, bool en)\n{\n\tunsigned char enable[2] = {0};\n\tint status;\n\n\t \n\tif (en) {\n\t\tenable[0] = 0xff;\n\t\tenable[1] = 0x8f;\n\t}\n\n\tstatus = f81534a_ctrl_set_register(intf, F81534A_CTRL_CMD_ENABLE_PORT,\n\t\t\tsizeof(enable), enable);\n\tif (status)\n\t\tdev_err(&intf->dev, \"failed to enable ports: %d\\n\", status);\n\n\treturn status;\n}\n\nstatic int f81534a_ctrl_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\treturn f81534a_ctrl_enable_all_ports(intf, true);\n}\n\nstatic void f81534a_ctrl_disconnect(struct usb_interface *intf)\n{\n\tf81534a_ctrl_enable_all_ports(intf, false);\n}\n\nstatic int f81534a_ctrl_resume(struct usb_interface *intf)\n{\n\treturn f81534a_ctrl_enable_all_ports(intf, true);\n}\n\nstatic int f81232_port_probe(struct usb_serial_port *port)\n{\n\tstruct f81232_private *priv;\n\n\tpriv = devm_kzalloc(&port->dev, sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->lock);\n\tINIT_WORK(&priv->interrupt_work,  f81232_interrupt_work);\n\tINIT_WORK(&priv->lsr_work, f81232_lsr_worker);\n\n\tusb_set_serial_port_data(port, priv);\n\n\tpriv->port = port;\n\n\treturn 0;\n}\n\nstatic int f81534a_port_probe(struct usb_serial_port *port)\n{\n\tint status;\n\n\t \n\tstatus = f81232_set_register(port, F81534A_GPIO_REG,\n\t\t\t\t\tF81534A_GPIO_MODE2_DIR);\n\tif (status)\n\t\treturn status;\n\n\treturn f81232_port_probe(port);\n}\n\nstatic int f81232_suspend(struct usb_serial *serial, pm_message_t message)\n{\n\tstruct usb_serial_port *port = serial->port[0];\n\tstruct f81232_private *port_priv = usb_get_serial_port_data(port);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\n\t\tusb_kill_urb(port->read_urbs[i]);\n\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\tif (port_priv) {\n\t\tflush_work(&port_priv->interrupt_work);\n\t\tflush_work(&port_priv->lsr_work);\n\t}\n\n\treturn 0;\n}\n\nstatic int f81232_resume(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port = serial->port[0];\n\tint result;\n\n\tif (tty_port_initialized(&port->port)) {\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_NOIO);\n\t\tif (result) {\n\t\t\tdev_err(&port->dev, \"submit interrupt urb failed: %d\\n\",\n\t\t\t\t\tresult);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\treturn usb_serial_generic_resume(serial);\n}\n\nstatic struct usb_serial_driver f81232_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"f81232\",\n\t},\n\t.id_table =\t\tf81232_id_table,\n\t.num_ports =\t\t1,\n\t.bulk_in_size =\t\t256,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tf81232_open,\n\t.close =\t\tf81232_close,\n\t.dtr_rts =\t\tf81232_dtr_rts,\n\t.carrier_raised =\tf81232_carrier_raised,\n\t.get_serial =\t\tf81232_get_serial,\n\t.break_ctl =\t\tf81232_break_ctl,\n\t.set_termios =\t\tf81232_set_termios,\n\t.tiocmget =\t\tf81232_tiocmget,\n\t.tiocmset =\t\tf81232_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.tx_empty =\t\tf81232_tx_empty,\n\t.process_read_urb =\tf81232_process_read_urb,\n\t.read_int_callback =\tf81232_read_int_callback,\n\t.port_probe =\t\tf81232_port_probe,\n\t.suspend =\t\tf81232_suspend,\n\t.resume =\t\tf81232_resume,\n};\n\nstatic struct usb_serial_driver f81534a_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"f81534a\",\n\t},\n\t.id_table =\t\tf81534a_id_table,\n\t.num_ports =\t\t1,\n\t.open =\t\t\tf81534a_open,\n\t.close =\t\tf81232_close,\n\t.dtr_rts =\t\tf81232_dtr_rts,\n\t.carrier_raised =\tf81232_carrier_raised,\n\t.get_serial =\t\tf81232_get_serial,\n\t.break_ctl =\t\tf81232_break_ctl,\n\t.set_termios =\t\tf81232_set_termios,\n\t.tiocmget =\t\tf81232_tiocmget,\n\t.tiocmset =\t\tf81232_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.tx_empty =\t\tf81232_tx_empty,\n\t.process_read_urb =\tf81534a_process_read_urb,\n\t.read_int_callback =\tf81232_read_int_callback,\n\t.port_probe =\t\tf81534a_port_probe,\n\t.suspend =\t\tf81232_suspend,\n\t.resume =\t\tf81232_resume,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&f81232_device,\n\t&f81534a_device,\n\tNULL,\n};\n\nstatic struct usb_driver f81534a_ctrl_driver = {\n\t.name =\t\t\"f81534a_ctrl\",\n\t.id_table =\tf81534a_ctrl_id_table,\n\t.probe =\tf81534a_ctrl_probe,\n\t.disconnect =\tf81534a_ctrl_disconnect,\n\t.resume =\tf81534a_ctrl_resume,\n};\n\nstatic int __init f81232_init(void)\n{\n\tint status;\n\n\tstatus = usb_register_driver(&f81534a_ctrl_driver, THIS_MODULE,\n\t\t\tKBUILD_MODNAME);\n\tif (status)\n\t\treturn status;\n\n\tstatus = usb_serial_register_drivers(serial_drivers, KBUILD_MODNAME,\n\t\t\tcombined_id_table);\n\tif (status) {\n\t\tusb_deregister(&f81534a_ctrl_driver);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic void __exit f81232_exit(void)\n{\n\tusb_serial_deregister_drivers(serial_drivers);\n\tusb_deregister(&f81534a_ctrl_driver);\n}\n\nmodule_init(f81232_init);\nmodule_exit(f81232_exit);\n\nMODULE_DESCRIPTION(\"Fintek F81232/532A/534A/535/536 USB to serial driver\");\nMODULE_AUTHOR(\"Greg Kroah-Hartman <gregkh@linuxfoundation.org>\");\nMODULE_AUTHOR(\"Peter Hong <peter_hong@fintek.com.tw>\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}