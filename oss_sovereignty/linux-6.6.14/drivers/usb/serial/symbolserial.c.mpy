{
  "module_name": "symbolserial.c",
  "hash_id": "4c93f42daeda8368e6ecaddbcd87736e7fa9a0078c6ad3aab8c31590f73c16dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/symbolserial.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x05e0, 0x0600) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct symbol_private {\n\tspinlock_t lock;\t \n\tbool throttled;\n\tbool actually_throttled;\n};\n\nstatic void symbol_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct symbol_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint result;\n\tint data_length;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\t \n\tif (urb->actual_length > 1) {\n\t\tdata_length = data[0];\n\t\tif (data_length > (urb->actual_length - 1))\n\t\t\tdata_length = urb->actual_length - 1;\n\t\ttty_insert_flip_string(&port->port, &data[1], data_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t} else {\n\t\tdev_dbg(&port->dev, \"%s - short packet\\n\", __func__);\n\t}\n\nexit:\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tif (!priv->throttled) {\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t    \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t} else\n\t\tpriv->actually_throttled = true;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int symbol_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct symbol_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->throttled = false;\n\tpriv->actually_throttled = false;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n\treturn result;\n}\n\nstatic void symbol_close(struct usb_serial_port *port)\n{\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic void symbol_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct symbol_private *priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irq(&priv->lock);\n\tpriv->throttled = true;\n\tspin_unlock_irq(&priv->lock);\n}\n\nstatic void symbol_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct symbol_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\tbool was_throttled;\n\n\tspin_lock_irq(&priv->lock);\n\tpriv->throttled = false;\n\twas_throttled = priv->actually_throttled;\n\tpriv->actually_throttled = false;\n\tspin_unlock_irq(&priv->lock);\n\n\tif (was_throttled) {\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t}\n}\n\nstatic int symbol_port_probe(struct usb_serial_port *port)\n{\n\tstruct symbol_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void symbol_port_remove(struct usb_serial_port *port)\n{\n\tstruct symbol_private *priv = usb_get_serial_port_data(port);\n\n\tkfree(priv);\n}\n\nstatic struct usb_serial_driver symbol_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"symbol\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_interrupt_in =\t1,\n\t.port_probe =\t\tsymbol_port_probe,\n\t.port_remove =\t\tsymbol_port_remove,\n\t.open =\t\t\tsymbol_open,\n\t.close =\t\tsymbol_close,\n\t.throttle = \t\tsymbol_throttle,\n\t.unthrottle =\t\tsymbol_unthrottle,\n\t.read_int_callback =\tsymbol_int_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&symbol_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}