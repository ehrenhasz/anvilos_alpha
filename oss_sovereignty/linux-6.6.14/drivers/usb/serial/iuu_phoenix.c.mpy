{
  "module_name": "iuu_phoenix.c",
  "hash_id": "d261bb0c1a3933aa90c031c21385111cdbc58668791bfd7303fc49d312bb1a13",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/iuu_phoenix.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"iuu_phoenix.h\"\n#include <linux/random.h>\n\n#define DRIVER_DESC \"Infinity USB Unlimited Phoenix driver\"\n\nstatic const struct usb_device_id id_table[] = {\n\t{USB_DEVICE(IUU_USB_VENDOR_ID, IUU_USB_PRODUCT_ID)},\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstatic int boost = 100;\nstatic int clockmode = 1;\nstatic int cdmode = 1;\nstatic int iuu_cardin;\nstatic int iuu_cardout;\nstatic bool xmas;\nstatic int vcc_default = 5;\n\nstatic int iuu_create_sysfs_attrs(struct usb_serial_port *port);\nstatic int iuu_remove_sysfs_attrs(struct usb_serial_port *port);\nstatic void read_rxcmd_callback(struct urb *urb);\n\nstruct iuu_private {\n\tspinlock_t lock;\t \n\tu8 line_status;\n\tint tiostatus;\t\t \n\tu8 reset;\t\t \n\tint poll;\t\t \n\tu8 *writebuf;\t\t \n\tint writelen;\t\t \n\tu8 *buf;\t\t \n\tu8 len;\n\tint vcc;\t\t \n\tu32 boost;\n\tu32 clk;\n};\n\nstatic int iuu_port_probe(struct usb_serial_port *port)\n{\n\tstruct iuu_private *priv;\n\tint ret;\n\n\tpriv = kzalloc(sizeof(struct iuu_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->buf = kzalloc(256, GFP_KERNEL);\n\tif (!priv->buf) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->writebuf = kzalloc(256, GFP_KERNEL);\n\tif (!priv->writebuf) {\n\t\tkfree(priv->buf);\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\tpriv->vcc = vcc_default;\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\tret = iuu_create_sysfs_attrs(port);\n\tif (ret) {\n\t\tkfree(priv->writebuf);\n\t\tkfree(priv->buf);\n\t\tkfree(priv);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void iuu_port_remove(struct usb_serial_port *port)\n{\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\n\tiuu_remove_sysfs_attrs(port);\n\tkfree(priv->writebuf);\n\tkfree(priv->buf);\n\tkfree(priv);\n}\n\nstatic int iuu_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\t \n\tdev_dbg(&port->dev, \"%s msg : SET = 0x%04x, CLEAR = 0x%04x\\n\",\n\t\t__func__, set, clear);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif ((set & TIOCM_RTS) && !(priv->tiostatus == TIOCM_RTS)) {\n\t\tdev_dbg(&port->dev, \"%s TIOCMSET RESET called !!!\\n\", __func__);\n\t\tpriv->reset = 1;\n\t}\n\tif (set & TIOCM_RTS)\n\t\tpriv->tiostatus = TIOCM_RTS;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn 0;\n}\n\n \nstatic int iuu_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\trc = priv->tiostatus;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn rc;\n}\n\nstatic void iuu_rxcmd(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - status = %d\\n\", __func__, status);\n\t\t \n\t\treturn;\n\t}\n\n\n\tmemset(port->write_urb->transfer_buffer, IUU_UART_RX, 1);\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 1,\n\t\t\t  read_rxcmd_callback, port);\n\tusb_submit_urb(port->write_urb, GFP_ATOMIC);\n}\n\nstatic int iuu_reset(struct usb_serial_port *port, u8 wt)\n{\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\tchar *buf_ptr = port->write_urb->transfer_buffer;\n\n\t \n\n\t*buf_ptr++ = IUU_RST_SET;\n\t*buf_ptr++ = IUU_DELAY_MS;\n\t*buf_ptr++ = wt;\n\t*buf_ptr = IUU_RST_CLEAR;\n\n\t \n\n\tusb_fill_bulk_urb(port->write_urb,\n\t\t\t  port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 4, iuu_rxcmd, port);\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tpriv->reset = 0;\n\treturn result;\n}\n\n \nstatic void iuu_update_status_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tu8 *st;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - status = %d\\n\", __func__, status);\n\t\t \n\t\treturn;\n\t}\n\n\tst = urb->transfer_buffer;\n\tdev_dbg(&port->dev, \"%s - enter\\n\", __func__);\n\tif (urb->actual_length == 1) {\n\t\tswitch (st[0]) {\n\t\tcase 0x1:\n\t\t\tpriv->tiostatus = iuu_cardout;\n\t\t\tbreak;\n\t\tcase 0x0:\n\t\t\tpriv->tiostatus = iuu_cardin;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpriv->tiostatus = iuu_cardin;\n\t\t}\n\t}\n\tiuu_rxcmd(urb);\n}\n\nstatic void iuu_status_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\n\tdev_dbg(&port->dev, \"%s - status = %d\\n\", __func__, status);\n\tusb_fill_bulk_urb(port->read_urb, port->serial->dev,\n\t\t\t  usb_rcvbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_in_endpointAddress),\n\t\t\t  port->read_urb->transfer_buffer, 256,\n\t\t\t  iuu_update_status_callback, port);\n\tusb_submit_urb(port->read_urb, GFP_ATOMIC);\n}\n\nstatic int iuu_status(struct usb_serial_port *port)\n{\n\tint result;\n\n\tmemset(port->write_urb->transfer_buffer, IUU_GET_STATE_REGISTER, 1);\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 1,\n\t\t\t  iuu_status_callback, port);\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\treturn result;\n\n}\n\nstatic int bulk_immediate(struct usb_serial_port *port, u8 *buf, u8 count)\n{\n\tint status;\n\tstruct usb_serial *serial = port->serial;\n\tint actual = 0;\n\n\t \n\n\tstatus =\n\t    usb_bulk_msg(serial->dev,\n\t\t\t usb_sndbulkpipe(serial->dev,\n\t\t\t\t\t port->bulk_out_endpointAddress), buf,\n\t\t\t count, &actual, 1000);\n\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - error = %2x\\n\", __func__, status);\n\telse\n\t\tdev_dbg(&port->dev, \"%s - write OK !\\n\", __func__);\n\treturn status;\n}\n\nstatic int read_immediate(struct usb_serial_port *port, u8 *buf, u8 count)\n{\n\tint status;\n\tstruct usb_serial *serial = port->serial;\n\tint actual = 0;\n\n\t \n\tstatus =\n\t    usb_bulk_msg(serial->dev,\n\t\t\t usb_rcvbulkpipe(serial->dev,\n\t\t\t\t\t port->bulk_in_endpointAddress), buf,\n\t\t\t count, &actual, 1000);\n\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - error = %2x\\n\", __func__, status);\n\telse\n\t\tdev_dbg(&port->dev, \"%s - read OK !\\n\", __func__);\n\treturn status;\n}\n\nstatic int iuu_led(struct usb_serial_port *port, unsigned int R,\n\t\t   unsigned int G, unsigned int B, u8 f)\n{\n\tint status;\n\tu8 *buf;\n\tbuf = kmalloc(8, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = IUU_SET_LED;\n\tbuf[1] = R & 0xFF;\n\tbuf[2] = (R >> 8) & 0xFF;\n\tbuf[3] = G & 0xFF;\n\tbuf[4] = (G >> 8) & 0xFF;\n\tbuf[5] = B & 0xFF;\n\tbuf[6] = (B >> 8) & 0xFF;\n\tbuf[7] = f;\n\tstatus = bulk_immediate(port, buf, 8);\n\tkfree(buf);\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - led error status = %2x\\n\", __func__, status);\n\telse\n\t\tdev_dbg(&port->dev, \"%s - led OK !\\n\", __func__);\n\treturn IUU_OPERATION_OK;\n}\n\nstatic void iuu_rgbf_fill_buffer(u8 *buf, u8 r1, u8 r2, u8 g1, u8 g2, u8 b1,\n\t\t\t\t u8 b2, u8 freq)\n{\n\t*buf++ = IUU_SET_LED;\n\t*buf++ = r1;\n\t*buf++ = r2;\n\t*buf++ = g1;\n\t*buf++ = g2;\n\t*buf++ = b1;\n\t*buf++ = b2;\n\t*buf = freq;\n}\n\nstatic void iuu_led_activity_on(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tchar *buf_ptr = port->write_urb->transfer_buffer;\n\n\tif (xmas) {\n\t\tbuf_ptr[0] = IUU_SET_LED;\n\t\tget_random_bytes(buf_ptr + 1, 6);\n\t\tbuf_ptr[7] = 1;\n\t} else {\n\t\tiuu_rgbf_fill_buffer(buf_ptr, 255, 255, 0, 0, 0, 0, 255);\n\t}\n\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 8 ,\n\t\t\t  iuu_rxcmd, port);\n\tusb_submit_urb(port->write_urb, GFP_ATOMIC);\n}\n\nstatic void iuu_led_activity_off(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tchar *buf_ptr = port->write_urb->transfer_buffer;\n\n\tif (xmas) {\n\t\tiuu_rxcmd(urb);\n\t\treturn;\n\t}\n\n\tiuu_rgbf_fill_buffer(buf_ptr, 0, 0, 255, 255, 0, 0, 255);\n\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 8 ,\n\t\t\t  iuu_rxcmd, port);\n\tusb_submit_urb(port->write_urb, GFP_ATOMIC);\n}\n\n\n\nstatic int iuu_clk(struct usb_serial_port *port, int dwFrq)\n{\n\tint status;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tint Count = 0;\n\tu8 FrqGenAdr = 0x69;\n\tu8 DIV = 0;\t\t \n\tu8 XDRV = 0;\t\t \n\tu8 PUMP = 0;\t\t \n\tu8 PBmsb = 0;\t\t \n\tu8 PBlsb = 0;\t\t \n\tu8 PO = 0;\t\t \n\tu8 Q = 0;\t\t \n\t \n\tunsigned int P = 0;\n\tunsigned int P2 = 0;\n\tint frq = (int)dwFrq;\n\n\tif (frq == 0) {\n\t\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\n\t\tpriv->buf[Count++] = FrqGenAdr << 1;\n\t\tpriv->buf[Count++] = 0x09;\n\t\tpriv->buf[Count++] = 0x00;\n\n\t\tstatus = bulk_immediate(port, (u8 *) priv->buf, Count);\n\t\tif (status != 0) {\n\t\t\tdev_dbg(&port->dev, \"%s - write error\\n\", __func__);\n\t\t\treturn status;\n\t\t}\n\t} else if (frq == 3579000) {\n\t\tDIV = 100;\n\t\tP = 1193;\n\t\tQ = 40;\n\t\tXDRV = 0;\n\t} else if (frq == 3680000) {\n\t\tDIV = 105;\n\t\tP = 161;\n\t\tQ = 5;\n\t\tXDRV = 0;\n\t} else if (frq == 6000000) {\n\t\tDIV = 66;\n\t\tP = 66;\n\t\tQ = 2;\n\t\tXDRV = 0x28;\n\t} else {\n\t\tunsigned int result = 0;\n\t\tunsigned int tmp = 0;\n\t\tunsigned int check;\n\t\tunsigned int check2;\n\t\tchar found = 0x00;\n\t\tunsigned int lQ = 2;\n\t\tunsigned int lP = 2055;\n\t\tunsigned int lDiv = 4;\n\n\t\tfor (lQ = 2; lQ <= 47 && !found; lQ++)\n\t\t\tfor (lP = 2055; lP >= 8 && !found; lP--)\n\t\t\t\tfor (lDiv = 4; lDiv <= 127 && !found; lDiv++) {\n\t\t\t\t\ttmp = (12000000 / lDiv) * (lP / lQ);\n\t\t\t\t\tif (abs((int)(tmp - frq)) <\n\t\t\t\t\t    abs((int)(frq - result))) {\n\t\t\t\t\t\tcheck2 = (12000000 / lQ);\n\t\t\t\t\t\tif (check2 < 250000)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tcheck = (12000000 / lQ) * lP;\n\t\t\t\t\t\tif (check > 400000000)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (check < 100000000)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (lDiv < 4 || lDiv > 127)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tresult = tmp;\n\t\t\t\t\t\tP = lP;\n\t\t\t\t\t\tDIV = lDiv;\n\t\t\t\t\t\tQ = lQ;\n\t\t\t\t\t\tif (result == frq)\n\t\t\t\t\t\t\tfound = 0x01;\n\t\t\t\t\t}\n\t\t\t\t}\n\t}\n\tP2 = ((P - PO) / 2) - 4;\n\tPUMP = 0x04;\n\tPBmsb = (P2 >> 8 & 0x03);\n\tPBlsb = P2 & 0xFF;\n\tPO = (P >> 10) & 0x01;\n\tQ = Q - 2;\n\n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x09;\n\tpriv->buf[Count++] = 0x20;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x0C;\n\tpriv->buf[Count++] = DIV;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x12;\n\tpriv->buf[Count++] = XDRV;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x13;\n\tpriv->buf[Count++] = 0x6B;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x40;\n\tpriv->buf[Count++] = (0xC0 | ((PUMP & 0x07) << 2)) |\n\t\t\t     (PBmsb & 0x03);\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x41;\n\tpriv->buf[Count++] = PBlsb;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x42;\n\tpriv->buf[Count++] = Q | (((PO & 0x01) << 7));\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x44;\n\tpriv->buf[Count++] = (char)0xFF;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x45;\n\tpriv->buf[Count++] = (char)0xFE;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x46;\n\tpriv->buf[Count++] = 0x7F;\t \n\tpriv->buf[Count++] = IUU_UART_WRITE_I2C;\t \n\tpriv->buf[Count++] = FrqGenAdr << 1;\n\tpriv->buf[Count++] = 0x47;\n\tpriv->buf[Count++] = (char)0x84;\t \n\n\tstatus = bulk_immediate(port, (u8 *) priv->buf, Count);\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - write error\\n\", __func__);\n\treturn status;\n}\n\nstatic int iuu_uart_flush(struct usb_serial_port *port)\n{\n\tstruct device *dev = &port->dev;\n\tint i;\n\tint status;\n\tu8 *rxcmd;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\n\tif (iuu_led(port, 0xF000, 0, 0, 0xFF) < 0)\n\t\treturn -EIO;\n\n\trxcmd = kmalloc(1, GFP_KERNEL);\n\tif (!rxcmd)\n\t\treturn -ENOMEM;\n\n\trxcmd[0] = IUU_UART_RX;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tstatus = bulk_immediate(port, rxcmd, 1);\n\t\tif (status != IUU_OPERATION_OK) {\n\t\t\tdev_dbg(dev, \"%s - uart_flush_write error\\n\", __func__);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tstatus = read_immediate(port, &priv->len, 1);\n\t\tif (status != IUU_OPERATION_OK) {\n\t\t\tdev_dbg(dev, \"%s - uart_flush_read error\\n\", __func__);\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tif (priv->len > 0) {\n\t\t\tdev_dbg(dev, \"%s - uart_flush datalen is : %i\\n\", __func__, priv->len);\n\t\t\tstatus = read_immediate(port, priv->buf, priv->len);\n\t\t\tif (status != IUU_OPERATION_OK) {\n\t\t\t\tdev_dbg(dev, \"%s - uart_flush_read error\\n\", __func__);\n\t\t\t\tgoto out_free;\n\t\t\t}\n\t\t}\n\t}\n\tdev_dbg(dev, \"%s - uart_flush_read OK!\\n\", __func__);\n\tiuu_led(port, 0, 0xF000, 0, 0xFF);\n\nout_free:\n\tkfree(rxcmd);\n\n\treturn status;\n}\n\nstatic void read_buf_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tif (status == -EPROTO) {\n\t\t\t \n\t\t}\n\t\treturn;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - %i chars to write\\n\", __func__, urb->actual_length);\n\n\tif (urb->actual_length) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\tiuu_led_activity_on(urb);\n}\n\nstatic int iuu_bulk_write(struct usb_serial_port *port)\n{\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result;\n\tint buf_len;\n\tchar *buf_ptr = port->write_urb->transfer_buffer;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t*buf_ptr++ = IUU_UART_ESC;\n\t*buf_ptr++ = IUU_UART_TX;\n\t*buf_ptr++ = priv->writelen;\n\n\tmemcpy(buf_ptr, priv->writebuf, priv->writelen);\n\tbuf_len = priv->writelen;\n\tpriv->writelen = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - writing %i chars : %*ph\\n\", __func__,\n\t\tbuf_len, buf_len, buf_ptr);\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, buf_len + 3,\n\t\t\t  iuu_rxcmd, port);\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tusb_serial_port_softint(port);\n\treturn result;\n}\n\nstatic int iuu_read_buf(struct usb_serial_port *port, int len)\n{\n\tint result;\n\n\tusb_fill_bulk_urb(port->read_urb, port->serial->dev,\n\t\t\t  usb_rcvbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_in_endpointAddress),\n\t\t\t  port->read_urb->transfer_buffer, len,\n\t\t\t  read_buf_callback, port);\n\tresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\treturn result;\n}\n\nstatic void iuu_uart_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint status = urb->status;\n\tint len = 0;\n\tunsigned char *data = urb->transfer_buffer;\n\tpriv->poll++;\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - status = %d\\n\", __func__, status);\n\t\t \n\t\treturn;\n\t}\n\n\tif (urb->actual_length == 1)\n\t\tlen = (int) data[0];\n\n\tif (urb->actual_length > 1) {\n\t\tdev_dbg(&port->dev, \"%s - urb->actual_length = %i\\n\", __func__,\n\t\t    urb->actual_length);\n\t\treturn;\n\t}\n\t \n\n\tif (len > 0) {\n\t\tdev_dbg(&port->dev, \"%s - call read buf - len to read is %i\\n\",\n\t\t\t__func__, len);\n\t\tstatus = iuu_read_buf(port, len);\n\t\treturn;\n\t}\n\t \n\tif (priv->poll > 99) {\n\t\tstatus = iuu_status(port);\n\t\tpriv->poll = 0;\n\t\treturn;\n\t}\n\n\t \n\n\tif (priv->reset == 1) {\n\t\tstatus = iuu_reset(port, 0xC);\n\t\treturn;\n\t}\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->writelen > 0) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tstatus = iuu_bulk_write(port);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\t \n\tdev_dbg(&port->dev, \"%s - rxcmd recall\\n\", __func__);\n\tiuu_led_activity_off(urb);\n}\n\nstatic int iuu_uart_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t  const u8 *buf, int count)\n{\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tcount = min(count, 256 - priv->writelen);\n\tif (count == 0)\n\t\tgoto out;\n\n\t \n\tmemcpy(priv->writebuf + priv->writelen, buf, count);\n\tpriv->writelen += count;\nout:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn count;\n}\n\nstatic void read_rxcmd_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint result;\n\tint status = urb->status;\n\n\tif (status) {\n\t\t \n\t\treturn;\n\t}\n\n\tusb_fill_bulk_urb(port->read_urb, port->serial->dev,\n\t\t\t  usb_rcvbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_in_endpointAddress),\n\t\t\t  port->read_urb->transfer_buffer, 256,\n\t\t\t  iuu_uart_read_callback, port);\n\tresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\tdev_dbg(&port->dev, \"%s - submit result = %d\\n\", __func__, result);\n}\n\nstatic int iuu_uart_on(struct usb_serial_port *port)\n{\n\tint status;\n\tu8 *buf;\n\n\tbuf = kmalloc(4, GFP_KERNEL);\n\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = IUU_UART_ENABLE;\n\tbuf[1] = (u8) ((IUU_BAUD_9600 >> 8) & 0x00FF);\n\tbuf[2] = (u8) (0x00FF & IUU_BAUD_9600);\n\tbuf[3] = (u8) (0x0F0 & IUU_ONE_STOP_BIT) | (0x07 & IUU_PARITY_EVEN);\n\n\tstatus = bulk_immediate(port, buf, 4);\n\tif (status != IUU_OPERATION_OK) {\n\t\tdev_dbg(&port->dev, \"%s - uart_on error\\n\", __func__);\n\t\tgoto uart_enable_failed;\n\t}\n\t \n\tstatus = iuu_uart_flush(port);\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - uart_flush error\\n\", __func__);\nuart_enable_failed:\n\tkfree(buf);\n\treturn status;\n}\n\n \nstatic int iuu_uart_off(struct usb_serial_port *port)\n{\n\tint status;\n\tu8 *buf;\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\tbuf[0] = IUU_UART_DISABLE;\n\n\tstatus = bulk_immediate(port, buf, 1);\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - uart_off error\\n\", __func__);\n\n\tkfree(buf);\n\treturn status;\n}\n\nstatic int iuu_uart_baud(struct usb_serial_port *port, u32 baud_base,\n\t\t\t u32 *actual, u8 parity)\n{\n\tint status;\n\tu32 baud;\n\tu8 *dataout;\n\tu8 DataCount = 0;\n\tu8 T1Frekvens = 0;\n\tu8 T1reload = 0;\n\tunsigned int T1FrekvensHZ = 0;\n\n\tdev_dbg(&port->dev, \"%s - enter baud_base=%d\\n\", __func__, baud_base);\n\tdataout = kmalloc(5, GFP_KERNEL);\n\n\tif (!dataout)\n\t\treturn -ENOMEM;\n\t \n\tbaud = baud_base;\n\n\tif (baud < 1200 || baud > 230400) {\n\t\tkfree(dataout);\n\t\treturn IUU_INVALID_PARAMETER;\n\t}\n\tif (baud > 977) {\n\t\tT1Frekvens = 3;\n\t\tT1FrekvensHZ = 500000;\n\t}\n\n\tif (baud > 3906) {\n\t\tT1Frekvens = 2;\n\t\tT1FrekvensHZ = 2000000;\n\t}\n\n\tif (baud > 11718) {\n\t\tT1Frekvens = 1;\n\t\tT1FrekvensHZ = 6000000;\n\t}\n\n\tif (baud > 46875) {\n\t\tT1Frekvens = 0;\n\t\tT1FrekvensHZ = 24000000;\n\t}\n\n\tT1reload = 256 - (u8) (T1FrekvensHZ / (baud * 2));\n\n\t \n\tdataout[DataCount++] = IUU_UART_ESC;\n\t \n\tdataout[DataCount++] = IUU_UART_CHANGE;\n\tdataout[DataCount++] = T1Frekvens;\n\tdataout[DataCount++] = T1reload;\n\n\t*actual = (T1FrekvensHZ / (256 - T1reload)) / 2;\n\n\tswitch (parity & 0x0F) {\n\tcase IUU_PARITY_NONE:\n\t\tdataout[DataCount++] = 0x00;\n\t\tbreak;\n\tcase IUU_PARITY_EVEN:\n\t\tdataout[DataCount++] = 0x01;\n\t\tbreak;\n\tcase IUU_PARITY_ODD:\n\t\tdataout[DataCount++] = 0x02;\n\t\tbreak;\n\tcase IUU_PARITY_MARK:\n\t\tdataout[DataCount++] = 0x03;\n\t\tbreak;\n\tcase IUU_PARITY_SPACE:\n\t\tdataout[DataCount++] = 0x04;\n\t\tbreak;\n\tdefault:\n\t\tkfree(dataout);\n\t\treturn IUU_INVALID_PARAMETER;\n\t}\n\n\tswitch (parity & 0xF0) {\n\tcase IUU_ONE_STOP_BIT:\n\t\tdataout[DataCount - 1] |= IUU_ONE_STOP_BIT;\n\t\tbreak;\n\n\tcase IUU_TWO_STOP_BITS:\n\t\tdataout[DataCount - 1] |= IUU_TWO_STOP_BITS;\n\t\tbreak;\n\tdefault:\n\t\tkfree(dataout);\n\t\treturn IUU_INVALID_PARAMETER;\n\t}\n\n\tstatus = bulk_immediate(port, dataout, DataCount);\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - uart_off error\\n\", __func__);\n\tkfree(dataout);\n\treturn status;\n}\n\nstatic void iuu_set_termios(struct tty_struct *tty,\n\t\t\t    struct usb_serial_port *port,\n\t\t\t    const struct ktermios *old_termios)\n{\n\tconst u32 supported_mask = CMSPAR|PARENB|PARODD;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned int cflag = tty->termios.c_cflag;\n\tint status;\n\tu32 actual;\n\tu32 parity;\n\tint csize = CS7;\n\tint baud;\n\tu32 newval = cflag & supported_mask;\n\n\t \n\tbaud = tty->termios.c_ospeed;\n\n\tdev_dbg(&port->dev, \"%s - enter c_ospeed or baud=%d\\n\", __func__, baud);\n\n\t \n\tparity = 0;\n\tif (cflag & CMSPAR) {\t \n\t\tif (cflag & PARODD)\n\t\t\tparity |= IUU_PARITY_SPACE;\n\t\telse\n\t\t\tparity |= IUU_PARITY_MARK;\n\t} else if (!(cflag & PARENB)) {\n\t\tparity |= IUU_PARITY_NONE;\n\t\tcsize = CS8;\n\t} else if (cflag & PARODD)\n\t\tparity |= IUU_PARITY_ODD;\n\telse\n\t\tparity |= IUU_PARITY_EVEN;\n\n\tparity |= (cflag & CSTOPB ? IUU_TWO_STOP_BITS : IUU_ONE_STOP_BIT);\n\n\t \n\tstatus = iuu_uart_baud(port,\n\t\t\tbaud * priv->boost / 100,\n\t\t\t&actual, parity);\n\n\t \n\tif (old_termios)\n\t\ttty_termios_copy_hw(&tty->termios, old_termios);\n\tif (status != 0)\t \n\t\treturn;\n\t \n\ttty_encode_baud_rate(tty, baud, baud);\n\ttty->termios.c_cflag &= ~(supported_mask|CSIZE);\n\ttty->termios.c_cflag |= newval | csize;\n}\n\nstatic void iuu_close(struct usb_serial_port *port)\n{\n\t \n\n\tiuu_uart_off(port);\n\n\tusb_kill_urb(port->write_urb);\n\tusb_kill_urb(port->read_urb);\n\n\tiuu_led(port, 0, 0, 0xF000, 0xFF);\n}\n\nstatic void iuu_init_termios(struct tty_struct *tty)\n{\n\ttty->termios.c_cflag = B9600 | CS8 | CSTOPB | CREAD | PARENB | CLOCAL;\n\ttty->termios.c_ispeed = 9600;\n\ttty->termios.c_ospeed = 9600;\n\ttty->termios.c_lflag = 0;\n\ttty->termios.c_oflag = 0;\n\ttty->termios.c_iflag = 0;\n}\n\nstatic int iuu_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct device *dev = &port->dev;\n\tint result;\n\tint baud;\n\tu32 actual;\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\n\tbaud = tty->termios.c_ospeed;\n\n\tdev_dbg(dev, \"%s - baud %d\\n\", __func__, baud);\n\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\n\tpriv->poll = 0;\n\n#define SOUP(a, b, c, d)  do { \\\n\tresult = usb_control_msg(port->serial->dev,\t\\\n\t\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\t\\\n\t\t\t\tb, a, c, d, NULL, 0, 1000); \\\n\tdev_dbg(dev, \"0x%x:0x%x:0x%x:0x%x  %d\\n\", a, b, c, d, result); } while (0)\n\n\t \n\t \n\t \n\t \n\n\tSOUP(0x03, 0x02, 0x02, 0x0);\n\n\tiuu_led(port, 0xF000, 0xF000, 0, 0xFF);\n\tiuu_uart_on(port);\n\tif (boost < 100)\n\t\tboost = 100;\n\tpriv->boost = boost;\n\tswitch (clockmode) {\n\tcase 2:\t\t \n\t\tpriv->clk = IUU_CLK_3680000;\n\t\tiuu_clk(port, IUU_CLK_3680000 * boost / 100);\n\t\tresult =\n\t\t    iuu_uart_baud(port, baud * boost / 100, &actual,\n\t\t\t\t  IUU_PARITY_EVEN);\n\t\tbreak;\n\tcase 3:\t\t \n\t\tiuu_clk(port, IUU_CLK_6000000 * boost / 100);\n\t\tpriv->clk = IUU_CLK_6000000;\n\t\t \n\t\tresult =\n\t\t    iuu_uart_baud(port, 16457 * boost / 100, &actual,\n\t\t\t\t  IUU_PARITY_EVEN);\n\t\tbreak;\n\tdefault:\t\t \n\t\tiuu_clk(port, IUU_CLK_3579000 * boost / 100);\n\t\tpriv->clk = IUU_CLK_3579000;\n\t\tresult =\n\t\t    iuu_uart_baud(port, baud * boost / 100, &actual,\n\t\t\t\t  IUU_PARITY_EVEN);\n\t}\n\n\t \n\tswitch (cdmode) {\n\tcase 0:\n\t\tiuu_cardin = 0;\n\t\tiuu_cardout = 0;\n\t\tbreak;\n\tcase 1:\n\t\tiuu_cardin = TIOCM_CD;\n\t\tiuu_cardout =  0;\n\t\tbreak;\n\tcase 2:\n\t\tiuu_cardin = 0;\n\t\tiuu_cardout = TIOCM_CD;\n\t\tbreak;\n\tcase 3:\n\t\tiuu_cardin = TIOCM_DSR;\n\t\tiuu_cardout = 0;\n\t\tbreak;\n\tcase 4:\n\t\tiuu_cardin = 0;\n\t\tiuu_cardout = TIOCM_DSR;\n\t\tbreak;\n\tcase 5:\n\t\tiuu_cardin = TIOCM_CTS;\n\t\tiuu_cardout = 0;\n\t\tbreak;\n\tcase 6:\n\t\tiuu_cardin = 0;\n\t\tiuu_cardout = TIOCM_CTS;\n\t\tbreak;\n\tcase 7:\n\t\tiuu_cardin = TIOCM_RNG;\n\t\tiuu_cardout = 0;\n\t\tbreak;\n\tcase 8:\n\t\tiuu_cardin = 0;\n\t\tiuu_cardout = TIOCM_RNG;\n\t}\n\n\tiuu_uart_flush(port);\n\n\tdev_dbg(dev, \"%s - initialization done\\n\", __func__);\n\n\tmemset(port->write_urb->transfer_buffer, IUU_UART_RX, 1);\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t  usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  port->write_urb->transfer_buffer, 1,\n\t\t\t  read_rxcmd_callback, port);\n\tresult = usb_submit_urb(port->write_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(dev, \"%s - failed submitting read urb, error %d\\n\", __func__, result);\n\t\tiuu_close(port);\n\t} else {\n\t\tdev_dbg(dev, \"%s - rxcmd OK\\n\", __func__);\n\t}\n\n\treturn result;\n}\n\n \nstatic int iuu_vcc_set(struct usb_serial_port *port, unsigned int vcc)\n{\n\tint status;\n\tu8 *buf;\n\n\tbuf = kmalloc(5, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = IUU_SET_VCC;\n\tbuf[1] = vcc & 0xFF;\n\tbuf[2] = (vcc >> 8) & 0xFF;\n\tbuf[3] = (vcc >> 16) & 0xFF;\n\tbuf[4] = (vcc >> 24) & 0xFF;\n\n\tstatus = bulk_immediate(port, buf, 5);\n\tkfree(buf);\n\n\tif (status != IUU_OPERATION_OK)\n\t\tdev_dbg(&port->dev, \"%s - vcc error status = %2x\\n\", __func__, status);\n\telse\n\t\tdev_dbg(&port->dev, \"%s - vcc OK !\\n\", __func__);\n\n\treturn status;\n}\n\n \n\nstatic ssize_t vcc_mode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\n\treturn sprintf(buf, \"%d\\n\", priv->vcc);\n}\n\nstatic ssize_t vcc_mode_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct iuu_private *priv = usb_get_serial_port_data(port);\n\tunsigned long v;\n\n\tif (kstrtoul(buf, 10, &v)) {\n\t\tdev_err(dev, \"%s - vcc_mode: %s is not a unsigned long\\n\",\n\t\t\t\t__func__, buf);\n\t\tgoto fail_store_vcc_mode;\n\t}\n\n\tdev_dbg(dev, \"%s: setting vcc_mode = %ld\\n\", __func__, v);\n\n\tif ((v != 3) && (v != 5)) {\n\t\tdev_err(dev, \"%s - vcc_mode %ld is invalid\\n\", __func__, v);\n\t} else {\n\t\tiuu_vcc_set(port, v);\n\t\tpriv->vcc = v;\n\t}\nfail_store_vcc_mode:\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(vcc_mode);\n\nstatic int iuu_create_sysfs_attrs(struct usb_serial_port *port)\n{\n\treturn device_create_file(&port->dev, &dev_attr_vcc_mode);\n}\n\nstatic int iuu_remove_sysfs_attrs(struct usb_serial_port *port)\n{\n\tdevice_remove_file(&port->dev, &dev_attr_vcc_mode);\n\treturn 0;\n}\n\n \n\nstatic struct usb_serial_driver iuu_device = {\n\t.driver = {\n\t\t   .owner = THIS_MODULE,\n\t\t   .name = \"iuu_phoenix\",\n\t\t   },\n\t.id_table = id_table,\n\t.num_ports = 1,\n\t.num_bulk_in = 1,\n\t.num_bulk_out = 1,\n\t.bulk_in_size = 512,\n\t.bulk_out_size = 512,\n\t.open = iuu_open,\n\t.close = iuu_close,\n\t.write = iuu_uart_write,\n\t.read_bulk_callback = iuu_uart_read_callback,\n\t.tiocmget = iuu_tiocmget,\n\t.tiocmset = iuu_tiocmset,\n\t.set_termios = iuu_set_termios,\n\t.init_termios = iuu_init_termios,\n\t.port_probe = iuu_port_probe,\n\t.port_remove = iuu_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&iuu_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(\"Alain Degreffe eczema@ecze.com\");\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(xmas, bool, 0644);\nMODULE_PARM_DESC(xmas, \"Xmas colors enabled or not\");\n\nmodule_param(boost, int, 0644);\nMODULE_PARM_DESC(boost, \"Card overclock boost (in percent 100-500)\");\n\nmodule_param(clockmode, int, 0644);\nMODULE_PARM_DESC(clockmode, \"Card clock mode (1=3.579 MHz, 2=3.680 MHz, \"\n\t\t\"3=6 Mhz)\");\n\nmodule_param(cdmode, int, 0644);\nMODULE_PARM_DESC(cdmode, \"Card detect mode (0=none, 1=CD, 2=!CD, 3=DSR, \"\n\t\t \"4=!DSR, 5=CTS, 6=!CTS, 7=RING, 8=!RING)\");\n\nmodule_param(vcc_default, int, 0644);\nMODULE_PARM_DESC(vcc_default, \"Set default VCC (either 3 for 3.3V or 5 \"\n\t\t\"for 5V). Default to 5.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}