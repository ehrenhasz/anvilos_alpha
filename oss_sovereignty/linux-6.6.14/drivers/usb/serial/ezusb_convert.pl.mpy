{
  "module_name": "ezusb_convert.pl",
  "hash_id": "75c2974ad471aa445658ef1d4390b268d83143209103b7f28727cc72a75bf473",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ezusb_convert.pl",
  "human_readable_source": "#! /usr/bin/perl -w\n# SPDX-License-Identifier: GPL-2.0\n\n\n# convert an Intel HEX file into a set of C records usable by the firmware\n# loading code in usb-serial.c (or others)\n\n# accepts the .hex file(s) on stdin, a basename (to name the initialized\n# array) as an argument, and prints the .h file to stdout. Typical usage:\n#  perl ezusb_convert.pl foo <foo.hex >fw_foo.h\n\n\nmy $basename = $ARGV[0];\ndie \"no base name specified\" unless $basename;\n\nwhile (<STDIN>) {\n    # ':' <len> <addr> <type> <len-data> <crc> '\\r'\n    #  len, type, crc are 2-char hex, addr is 4-char hex. type is 00 for\n    # normal records, 01 for EOF\n    my($lenstring, $addrstring, $typestring, $reststring, $doscrap) =\n      /^:(\\w\\w)(\\w\\w\\w\\w)(\\w\\w)(\\w+)(\\r?)$/;\n    die \"malformed line: $_\" unless $reststring;\n    last if $typestring eq '01';\n    my($len) = hex($lenstring);\n    my($addr) = hex($addrstring);\n    my(@bytes) = unpack(\"C*\", pack(\"H\".(2*$len), $reststring));\n    #pop(@bytes); # last byte is a CRC\n    push(@records, [$addr, \\@bytes]);\n}\n\n@sorted_records = sort { $a->[0] <=> $b->[0] } @records;\n\nprint <<\"EOF\";\n/*\n * ${basename}_fw.h\n *\n * Generated from ${basename}.s by ezusb_convert.pl\n * This file is presumed to be under the same copyright as the source file\n * from which it was derived.\n */\n\nEOF\n\nprint \"static const struct ezusb_hex_record ${basename}_firmware[] = {\\n\";\nforeach $r (@sorted_records) {\n    printf(\"{ 0x%04x,\\t%d,\\t{\", $r->[0], scalar(@{$r->[1]}));\n    print join(\", \", map {sprintf('0x%02x', $_);} @{$r->[1]});\n    print \"} },\\n\";\n}\nprint \"{ 0xffff,\\t0,\\t{0x00} }\\n\";\nprint \"};\\n\";\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}