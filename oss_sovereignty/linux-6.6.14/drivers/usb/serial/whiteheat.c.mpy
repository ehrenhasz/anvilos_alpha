{
  "module_name": "whiteheat.c",
  "hash_id": "5f1c8efd94e9929f811bff97e85d5e20499e159cfb70c2f78af01979a89c86fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/whiteheat.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <asm/termbits.h>\n#include <linux/usb.h>\n#include <linux/serial_reg.h>\n#include <linux/serial.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n#include \"whiteheat.h\"\t\t\t \n\n \n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Stuart MacDonald <stuartm@connecttech.com>\"\n#define DRIVER_DESC \"USB ConnectTech WhiteHEAT driver\"\n\n#define CONNECT_TECH_VENDOR_ID\t\t0x0710\n#define CONNECT_TECH_FAKE_WHITE_HEAT_ID\t0x0001\n#define CONNECT_TECH_WHITE_HEAT_ID\t0x8001\n\n \nstatic const struct usb_device_id id_table_std[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_prerenumeration[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_WHITE_HEAT_ID) },\n\t{ USB_DEVICE(CONNECT_TECH_VENDOR_ID, CONNECT_TECH_FAKE_WHITE_HEAT_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n\n \nstatic int  whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  whiteheat_firmware_attach(struct usb_serial *serial);\n\n \nstatic int  whiteheat_attach(struct usb_serial *serial);\nstatic void whiteheat_release(struct usb_serial *serial);\nstatic int  whiteheat_port_probe(struct usb_serial_port *port);\nstatic void whiteheat_port_remove(struct usb_serial_port *port);\nstatic int  whiteheat_open(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port);\nstatic void whiteheat_close(struct usb_serial_port *port);\nstatic void whiteheat_get_serial(struct tty_struct *tty,\n\t\t\tstruct serial_struct *ss);\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\t\t\t\t  struct usb_serial_port *port,\n\t\t\t\t  const struct ktermios *old_termios);\nstatic int  whiteheat_tiocmget(struct tty_struct *tty);\nstatic int  whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic int whiteheat_break_ctl(struct tty_struct *tty, int break_state);\n\nstatic struct usb_serial_driver whiteheat_fake_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheatnofirm\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT - (prerenumeration)\",\n\t.id_table =\t\tid_table_prerenumeration,\n\t.num_ports =\t\t1,\n\t.probe =\t\twhiteheat_firmware_download,\n\t.attach =\t\twhiteheat_firmware_attach,\n};\n\nstatic struct usb_serial_driver whiteheat_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"whiteheat\",\n\t},\n\t.description =\t\t\"Connect Tech - WhiteHEAT\",\n\t.id_table =\t\tid_table_std,\n\t.num_ports =\t\t4,\n\t.num_bulk_in =\t\t5,\n\t.num_bulk_out =\t\t5,\n\t.attach =\t\twhiteheat_attach,\n\t.release =\t\twhiteheat_release,\n\t.port_probe =\t\twhiteheat_port_probe,\n\t.port_remove =\t\twhiteheat_port_remove,\n\t.open =\t\t\twhiteheat_open,\n\t.close =\t\twhiteheat_close,\n\t.get_serial =\t\twhiteheat_get_serial,\n\t.set_termios =\t\twhiteheat_set_termios,\n\t.break_ctl =\t\twhiteheat_break_ctl,\n\t.tiocmget =\t\twhiteheat_tiocmget,\n\t.tiocmset =\t\twhiteheat_tiocmset,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&whiteheat_fake_device, &whiteheat_device, NULL\n};\n\nstruct whiteheat_command_private {\n\tstruct mutex\t\tmutex;\n\t__u8\t\t\tport_running;\n\t__u8\t\t\tcommand_finished;\n\twait_queue_head_t\twait_command;  \n\t__u8\t\t\tresult_buffer[64];\n};\n\nstruct whiteheat_private {\n\t__u8\t\t\tmcr;\t\t \n};\n\n\n \nstatic int start_command_port(struct usb_serial *serial);\nstatic void stop_command_port(struct usb_serial *serial);\nstatic void command_port_write_callback(struct urb *urb);\nstatic void command_port_read_callback(struct urb *urb);\n\nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize);\nstatic int firm_open(struct usb_serial_port *port);\nstatic int firm_close(struct usb_serial_port *port);\nstatic void firm_setup_port(struct tty_struct *tty);\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff);\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx);\nstatic int firm_get_dtr_rts(struct usb_serial_port *port);\nstatic int firm_report_tx_done(struct usb_serial_port *port);\n\n\n#define COMMAND_PORT\t\t4\n#define COMMAND_TIMEOUT\t\t(2*HZ)\t \n#define\tCOMMAND_TIMEOUT_MS\t2000\n\n\n \n\n \nstatic int whiteheat_firmware_download(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint response;\n\n\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat_loader.fw\");\n\tif (response >= 0) {\n\t\tresponse = ezusb_fx1_ihex_firmware_download(serial->dev, \"whiteheat.fw\");\n\t\tif (response >= 0)\n\t\t\treturn 0;\n\t}\n\treturn -ENOENT;\n}\n\n\nstatic int whiteheat_firmware_attach(struct usb_serial *serial)\n{\n\t \n\treturn 1;\n}\n\n\n \n\nstatic int whiteheat_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_hw_info *hw_info;\n\tint pipe;\n\tint ret;\n\tint alen;\n\t__u8 *command;\n\t__u8 *result;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\n\tpipe = usb_sndbulkpipe(serial->dev,\n\t\t\tcommand_port->bulk_out_endpointAddress);\n\tcommand = kmalloc(2, GFP_KERNEL);\n\tif (!command)\n\t\tgoto no_command_buffer;\n\tcommand[0] = WHITEHEAT_GET_HW_INFO;\n\tcommand[1] = 0;\n\n\tresult = kmalloc(sizeof(*hw_info) + 1, GFP_KERNEL);\n\tif (!result)\n\t\tgoto no_result_buffer;\n\t \n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, command, 2,\n\t\t\t\t\t\t&alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't send command [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != 2) {\n\t\tdev_err(&serial->dev->dev, \"%s: Send command incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t}\n\n\tpipe = usb_rcvbulkpipe(serial->dev,\n\t\t\t\tcommand_port->bulk_in_endpointAddress);\n\t \n\tusb_clear_halt(serial->dev, pipe);\n\tret = usb_bulk_msg(serial->dev, pipe, result,\n\t\t\tsizeof(*hw_info) + 1, &alen, COMMAND_TIMEOUT_MS);\n\tif (ret) {\n\t\tdev_err(&serial->dev->dev, \"%s: Couldn't get results [%d]\\n\",\n\t\t\tserial->type->description, ret);\n\t\tgoto no_firmware;\n\t} else if (alen != sizeof(*hw_info) + 1) {\n\t\tdev_err(&serial->dev->dev, \"%s: Get results incomplete [%d]\\n\",\n\t\t\tserial->type->description, alen);\n\t\tgoto no_firmware;\n\t} else if (result[0] != command[0]) {\n\t\tdev_err(&serial->dev->dev, \"%s: Command failed [%d]\\n\",\n\t\t\tserial->type->description, result[0]);\n\t\tgoto no_firmware;\n\t}\n\n\thw_info = (struct whiteheat_hw_info *)&result[1];\n\n\tdev_info(&serial->dev->dev, \"%s: Firmware v%d.%02d\\n\",\n\t\t serial->type->description,\n\t\t hw_info->sw_major_rev, hw_info->sw_minor_rev);\n\n\tcommand_info = kmalloc(sizeof(struct whiteheat_command_private),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!command_info)\n\t\tgoto no_command_private;\n\n\tmutex_init(&command_info->mutex);\n\tcommand_info->port_running = 0;\n\tinit_waitqueue_head(&command_info->wait_command);\n\tusb_set_serial_port_data(command_port, command_info);\n\tcommand_port->write_urb->complete = command_port_write_callback;\n\tcommand_port->read_urb->complete = command_port_read_callback;\n\tkfree(result);\n\tkfree(command);\n\n\treturn 0;\n\nno_firmware:\n\t \n\tdev_err(&serial->dev->dev,\n\t\t\"%s: Unable to retrieve firmware version, try replugging\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: If the firmware is not running (status led not blinking)\\n\",\n\t\tserial->type->description);\n\tdev_err(&serial->dev->dev,\n\t\t\"%s: please contact support@connecttech.com\\n\",\n\t\tserial->type->description);\n\tkfree(result);\n\tkfree(command);\n\treturn -ENODEV;\n\nno_command_private:\n\tkfree(result);\nno_result_buffer:\n\tkfree(command);\nno_command_buffer:\n\treturn -ENOMEM;\n}\n\nstatic void whiteheat_release(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\n\t \n\tcommand_port = serial->port[COMMAND_PORT];\n\tkfree(usb_get_serial_port_data(command_port));\n}\n\nstatic int whiteheat_port_probe(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = kzalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, info);\n\n\treturn 0;\n}\n\nstatic void whiteheat_port_remove(struct usb_serial_port *port)\n{\n\tstruct whiteheat_private *info;\n\n\tinfo = usb_get_serial_port_data(port);\n\tkfree(info);\n}\n\nstatic int whiteheat_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint retval;\n\n\tretval = start_command_port(port->serial);\n\tif (retval)\n\t\tgoto exit;\n\n\t \n\tretval = firm_open(port);\n\tif (retval) {\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tretval = firm_purge(port, WHITEHEAT_PURGE_RX | WHITEHEAT_PURGE_TX);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\n\n\tif (tty)\n\t\tfirm_setup_port(tty);\n\n\t \n\tusb_clear_halt(port->serial->dev, port->read_urb->pipe);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval) {\n\t\tfirm_close(port);\n\t\tstop_command_port(port->serial);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}\n\n\nstatic void whiteheat_close(struct usb_serial_port *port)\n{\n\tfirm_report_tx_done(port);\n\tfirm_close(port);\n\n\tusb_serial_generic_close(port);\n\n\tstop_command_port(port->serial);\n}\n\nstatic int whiteheat_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\tunsigned int modem_signals = 0;\n\n\tfirm_get_dtr_rts(port);\n\tif (info->mcr & UART_MCR_DTR)\n\t\tmodem_signals |= TIOCM_DTR;\n\tif (info->mcr & UART_MCR_RTS)\n\t\tmodem_signals |= TIOCM_RTS;\n\n\treturn modem_signals;\n}\n\nstatic int whiteheat_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct whiteheat_private *info = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tinfo->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tinfo->mcr |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tinfo->mcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tinfo->mcr &= ~UART_MCR_DTR;\n\n\tfirm_set_dtr(port, info->mcr & UART_MCR_DTR);\n\tfirm_set_rts(port, info->mcr & UART_MCR_RTS);\n\treturn 0;\n}\n\n\nstatic void whiteheat_get_serial(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tss->baud_base = 460800;\n}\n\n\nstatic void whiteheat_set_termios(struct tty_struct *tty,\n\t\t\t\t  struct usb_serial_port *port,\n\t\t\t\t  const struct ktermios *old_termios)\n{\n\tfirm_setup_port(tty);\n}\n\nstatic int whiteheat_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn firm_set_break(port, break_state);\n}\n\n\n \nstatic void command_port_write_callback(struct urb *urb)\n{\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero urb status: %d\\n\", status);\n\t\treturn;\n\t}\n}\n\n\nstatic void command_port_read_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *command_port = urb->context;\n\tstruct whiteheat_command_private *command_info;\n\tint status = urb->status;\n\tunsigned char *data = urb->transfer_buffer;\n\tint result;\n\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tif (!command_info) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - command_info is NULL, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (!urb->actual_length) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - empty response, exiting.\\n\", __func__);\n\t\treturn;\n\t}\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\", __func__, status);\n\t\tif (status != -ENOENT)\n\t\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t\treturn;\n\t}\n\n\tusb_serial_debug_data(&command_port->dev, __func__, urb->actual_length, data);\n\n\tif (data[0] == WHITEHEAT_CMD_COMPLETE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_CMD_FAILURE) {\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_FAILURE;\n\t\twake_up(&command_info->wait_command);\n\t} else if (data[0] == WHITEHEAT_EVENT) {\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s - event received\\n\", __func__);\n\t} else if ((data[0] == WHITEHEAT_GET_DTR_RTS) &&\n\t\t(urb->actual_length - 1 <= sizeof(command_info->result_buffer))) {\n\t\tmemcpy(command_info->result_buffer, &data[1],\n\t\t\t\t\t\turb->actual_length - 1);\n\t\tcommand_info->command_finished = WHITEHEAT_CMD_COMPLETE;\n\t\twake_up(&command_info->wait_command);\n\t} else\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad reply from firmware\\n\", __func__);\n\n\t \n\tresult = usb_submit_urb(command_port->read_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_dbg(&urb->dev->dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t__func__, result);\n}\n\n\n \nstatic int firm_send_command(struct usb_serial_port *port, __u8 command,\n\t\t\t\t\t\t__u8 *data, __u8 datasize)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tstruct whiteheat_private *info;\n\tstruct device *dev = &port->dev;\n\t__u8 *transfer_buffer;\n\tint retval = 0;\n\tint t;\n\n\tdev_dbg(dev, \"%s - command %d\\n\", __func__, command);\n\n\tcommand_port = port->serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\n\tif (command_port->bulk_out_size < datasize + 1)\n\t\treturn -EIO;\n\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->command_finished = false;\n\n\ttransfer_buffer = (__u8 *)command_port->write_urb->transfer_buffer;\n\ttransfer_buffer[0] = command;\n\tmemcpy(&transfer_buffer[1], data, datasize);\n\tcommand_port->write_urb->transfer_buffer_length = datasize + 1;\n\tretval = usb_submit_urb(command_port->write_urb, GFP_NOIO);\n\tif (retval) {\n\t\tdev_dbg(dev, \"%s - submit urb failed\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\t \n\tt = wait_event_timeout(command_info->wait_command,\n\t\t(bool)command_info->command_finished, COMMAND_TIMEOUT);\n\tif (!t)\n\t\tusb_kill_urb(command_port->write_urb);\n\n\tif (command_info->command_finished == false) {\n\t\tdev_dbg(dev, \"%s - command timed out.\\n\", __func__);\n\t\tretval = -ETIMEDOUT;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_FAILURE) {\n\t\tdev_dbg(dev, \"%s - command failed.\\n\", __func__);\n\t\tretval = -EIO;\n\t\tgoto exit;\n\t}\n\n\tif (command_info->command_finished == WHITEHEAT_CMD_COMPLETE) {\n\t\tdev_dbg(dev, \"%s - command completed.\\n\", __func__);\n\t\tswitch (command) {\n\t\tcase WHITEHEAT_GET_DTR_RTS:\n\t\t\tinfo = usb_get_serial_port_data(port);\n\t\t\tinfo->mcr = command_info->result_buffer[0];\n\t\t\tbreak;\n\t\t}\n\t}\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic int firm_open(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple open_command;\n\n\topen_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_OPEN,\n\t\t(__u8 *)&open_command, sizeof(open_command));\n}\n\n\nstatic int firm_close(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_CLOSE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\nstatic void firm_setup_port(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct whiteheat_port_settings port_settings;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tspeed_t baud;\n\n\tport_settings.port = port->port_number + 1;\n\n\tport_settings.bits = tty_get_char_size(cflag);\n\tdev_dbg(dev, \"%s - data bits = %d\\n\", __func__, port_settings.bits);\n\n\t \n\tif (cflag & PARENB)\n\t\tif (cflag & CMSPAR)\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_MARK;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_SPACE;\n\t\telse\n\t\t\tif (cflag & PARODD)\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_ODD;\n\t\t\telse\n\t\t\t\tport_settings.parity = WHITEHEAT_PAR_EVEN;\n\telse\n\t\tport_settings.parity = WHITEHEAT_PAR_NONE;\n\tdev_dbg(dev, \"%s - parity = %c\\n\", __func__, port_settings.parity);\n\n\t \n\tif (cflag & CSTOPB)\n\t\tport_settings.stop = 2;\n\telse\n\t\tport_settings.stop = 1;\n\tdev_dbg(dev, \"%s - stop bits = %d\\n\", __func__, port_settings.stop);\n\n\t \n\tif (cflag & CRTSCTS)\n\t\tport_settings.hflow = (WHITEHEAT_HFLOW_CTS |\n\t\t\t\t\t\tWHITEHEAT_HFLOW_RTS);\n\telse\n\t\tport_settings.hflow = WHITEHEAT_HFLOW_NONE;\n\tdev_dbg(dev, \"%s - hardware flow control = %s %s %s %s\\n\", __func__,\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_CTS) ? \"CTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_RTS) ? \"RTS\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DSR) ? \"DSR\" : \"\",\n\t    (port_settings.hflow & WHITEHEAT_HFLOW_DTR) ? \"DTR\" : \"\");\n\n\t \n\tif (I_IXOFF(tty))\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_RXTX;\n\telse\n\t\tport_settings.sflow = WHITEHEAT_SFLOW_NONE;\n\tdev_dbg(dev, \"%s - software flow control = %c\\n\", __func__, port_settings.sflow);\n\n\tport_settings.xon = START_CHAR(tty);\n\tport_settings.xoff = STOP_CHAR(tty);\n\tdev_dbg(dev, \"%s - XON = %2x, XOFF = %2x\\n\", __func__, port_settings.xon, port_settings.xoff);\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tport_settings.baud = cpu_to_le32(baud);\n\tdev_dbg(dev, \"%s - baud rate = %u\\n\", __func__, baud);\n\n\t \n\ttty_encode_baud_rate(tty, baud, baud);\n\n\t \n\tport_settings.lloop = 0;\n\n\t \n\tfirm_send_command(port, WHITEHEAT_SETUP_PORT,\n\t\t\t(__u8 *)&port_settings, sizeof(port_settings));\n}\n\n\nstatic int firm_set_rts(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb rts_command;\n\n\trts_command.port = port->port_number + 1;\n\trts_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_RTS,\n\t\t\t(__u8 *)&rts_command, sizeof(rts_command));\n}\n\n\nstatic int firm_set_dtr(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb dtr_command;\n\n\tdtr_command.port = port->port_number + 1;\n\tdtr_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_DTR,\n\t\t\t(__u8 *)&dtr_command, sizeof(dtr_command));\n}\n\n\nstatic int firm_set_break(struct usb_serial_port *port, __u8 onoff)\n{\n\tstruct whiteheat_set_rdb break_command;\n\n\tbreak_command.port = port->port_number + 1;\n\tbreak_command.state = onoff;\n\treturn firm_send_command(port, WHITEHEAT_SET_BREAK,\n\t\t\t(__u8 *)&break_command, sizeof(break_command));\n}\n\n\nstatic int firm_purge(struct usb_serial_port *port, __u8 rxtx)\n{\n\tstruct whiteheat_purge purge_command;\n\n\tpurge_command.port = port->port_number + 1;\n\tpurge_command.what = rxtx;\n\treturn firm_send_command(port, WHITEHEAT_PURGE,\n\t\t\t(__u8 *)&purge_command, sizeof(purge_command));\n}\n\n\nstatic int firm_get_dtr_rts(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple get_dr_command;\n\n\tget_dr_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_GET_DTR_RTS,\n\t\t\t(__u8 *)&get_dr_command, sizeof(get_dr_command));\n}\n\n\nstatic int firm_report_tx_done(struct usb_serial_port *port)\n{\n\tstruct whiteheat_simple close_command;\n\n\tclose_command.port = port->port_number + 1;\n\treturn firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,\n\t\t\t(__u8 *)&close_command, sizeof(close_command));\n}\n\n\n \nstatic int start_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\tint retval = 0;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tif (!command_info->port_running) {\n\t\t \n\t\tusb_clear_halt(serial->dev, command_port->read_urb->pipe);\n\n\t\tretval = usb_submit_urb(command_port->read_urb, GFP_KERNEL);\n\t\tif (retval) {\n\t\t\tdev_err(&serial->dev->dev,\n\t\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tgoto exit;\n\t\t}\n\t}\n\tcommand_info->port_running++;\n\nexit:\n\tmutex_unlock(&command_info->mutex);\n\treturn retval;\n}\n\n\nstatic void stop_command_port(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *command_port;\n\tstruct whiteheat_command_private *command_info;\n\n\tcommand_port = serial->port[COMMAND_PORT];\n\tcommand_info = usb_get_serial_port_data(command_port);\n\tmutex_lock(&command_info->mutex);\n\tcommand_info->port_running--;\n\tif (!command_info->port_running)\n\t\tusb_kill_urb(command_port->read_urb);\n\tmutex_unlock(&command_info->mutex);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"whiteheat.fw\");\nMODULE_FIRMWARE(\"whiteheat_loader.fw\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}