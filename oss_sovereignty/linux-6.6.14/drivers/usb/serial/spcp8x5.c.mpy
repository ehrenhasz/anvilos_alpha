{
  "module_name": "spcp8x5.c",
  "hash_id": "ef57ac5f232f8c6e619c2c57472f6be44c512f2e1cbc3d9f47dd68b4e29269bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/spcp8x5.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_DESC\t\"SPCP8x5 USB to serial adaptor driver\"\n\n#define SPCP825_QUIRK_NO_UART_STATUS\t0x01\n#define SPCP825_QUIRK_NO_WORK_MODE\t0x02\n\n#define SPCP8x5_007_VID\t\t0x04FC\n#define SPCP8x5_007_PID\t\t0x0201\n#define SPCP8x5_008_VID\t\t0x04fc\n#define SPCP8x5_008_PID\t\t0x0235\n#define SPCP8x5_PHILIPS_VID\t0x0471\n#define SPCP8x5_PHILIPS_PID\t0x081e\n#define SPCP8x5_INTERMATIC_VID\t0x04FC\n#define SPCP8x5_INTERMATIC_PID\t0x0204\n#define SPCP8x5_835_VID\t\t0x04fc\n#define SPCP8x5_835_PID\t\t0x0231\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(SPCP8x5_PHILIPS_VID , SPCP8x5_PHILIPS_PID)},\n\t{ USB_DEVICE(SPCP8x5_INTERMATIC_VID, SPCP8x5_INTERMATIC_PID)},\n\t{ USB_DEVICE(SPCP8x5_835_VID, SPCP8x5_835_PID)},\n\t{ USB_DEVICE(SPCP8x5_008_VID, SPCP8x5_008_PID)},\n\t{ USB_DEVICE(SPCP8x5_007_VID, SPCP8x5_007_PID),\n\t  .driver_info = SPCP825_QUIRK_NO_UART_STATUS |\n\t\t\t\tSPCP825_QUIRK_NO_WORK_MODE },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct spcp8x5_usb_ctrl_arg {\n\tu8\ttype;\n\tu8\tcmd;\n\tu8\tcmd_type;\n\tu16\tvalue;\n\tu16\tindex;\n\tu16\tlength;\n};\n\n\n \n#define MCR_CONTROL_LINE_RTS\t\t0x02\n#define MCR_CONTROL_LINE_DTR\t\t0x01\n#define MCR_DTR\t\t\t\t0x01\n#define MCR_RTS\t\t\t\t0x02\n\n#define MSR_STATUS_LINE_DCD\t\t0x80\n#define MSR_STATUS_LINE_RI\t\t0x40\n#define MSR_STATUS_LINE_DSR\t\t0x20\n#define MSR_STATUS_LINE_CTS\t\t0x10\n\n \n#define SET_DEFAULT\t\t\t0x40\n#define SET_DEFAULT_TYPE\t\t0x20\n\n#define SET_UART_FORMAT\t\t\t0x40\n#define SET_UART_FORMAT_TYPE\t\t0x21\n#define SET_UART_FORMAT_SIZE_5\t\t0x00\n#define SET_UART_FORMAT_SIZE_6\t\t0x01\n#define SET_UART_FORMAT_SIZE_7\t\t0x02\n#define SET_UART_FORMAT_SIZE_8\t\t0x03\n#define SET_UART_FORMAT_STOP_1\t\t0x00\n#define SET_UART_FORMAT_STOP_2\t\t0x04\n#define SET_UART_FORMAT_PAR_NONE\t0x00\n#define SET_UART_FORMAT_PAR_ODD\t\t0x10\n#define SET_UART_FORMAT_PAR_EVEN\t0x30\n#define SET_UART_FORMAT_PAR_MASK\t0xD0\n#define SET_UART_FORMAT_PAR_SPACE\t0x90\n\n#define GET_UART_STATUS_TYPE\t\t0xc0\n#define GET_UART_STATUS\t\t\t0x22\n#define GET_UART_STATUS_MSR\t\t0x06\n\n#define SET_UART_STATUS\t\t\t0x40\n#define SET_UART_STATUS_TYPE\t\t0x23\n#define SET_UART_STATUS_MCR\t\t0x0004\n#define SET_UART_STATUS_MCR_DTR\t\t0x01\n#define SET_UART_STATUS_MCR_RTS\t\t0x02\n#define SET_UART_STATUS_MCR_LOOP\t0x10\n\n#define SET_WORKING_MODE\t\t0x40\n#define SET_WORKING_MODE_TYPE\t\t0x24\n#define SET_WORKING_MODE_U2C\t\t0x00\n#define SET_WORKING_MODE_RS485\t\t0x01\n#define SET_WORKING_MODE_PDMA\t\t0x02\n#define SET_WORKING_MODE_SPP\t\t0x03\n\n#define SET_FLOWCTL_CHAR\t\t0x40\n#define SET_FLOWCTL_CHAR_TYPE\t\t0x25\n\n#define GET_VERSION\t\t\t0xc0\n#define GET_VERSION_TYPE\t\t0x26\n\n#define SET_REGISTER\t\t\t0x40\n#define SET_REGISTER_TYPE\t\t0x27\n\n#define\tGET_REGISTER\t\t\t0xc0\n#define GET_REGISTER_TYPE\t\t0x28\n\n#define SET_RAM\t\t\t\t0x40\n#define SET_RAM_TYPE\t\t\t0x31\n\n#define GET_RAM\t\t\t\t0xc0\n#define GET_RAM_TYPE\t\t\t0x32\n\n \n#define UART_STATE\t\t\t0x08\n#define UART_STATE_TRANSIENT_MASK\t0x75\n#define UART_DCD\t\t\t0x01\n#define UART_DSR\t\t\t0x02\n#define UART_BREAK_ERROR\t\t0x04\n#define UART_RING\t\t\t0x08\n#define UART_FRAME_ERROR\t\t0x10\n#define UART_PARITY_ERROR\t\t0x20\n#define UART_OVERRUN_ERROR\t\t0x40\n#define UART_CTS\t\t\t0x80\n\nstruct spcp8x5_private {\n\tunsigned\t\tquirks;\n\tspinlock_t\t\tlock;\n\tu8\t\t\tline_control;\n};\n\nstatic int spcp8x5_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tusb_set_serial_data(serial, (void *)id);\n\n\treturn 0;\n}\n\nstatic int spcp8x5_port_probe(struct usb_serial_port *port)\n{\n\tconst struct usb_device_id *id = usb_get_serial_data(port->serial);\n\tstruct spcp8x5_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->quirks = id->driver_info;\n\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}\n\nstatic void spcp8x5_port_remove(struct usb_serial_port *port)\n{\n\tstruct spcp8x5_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int spcp8x5_set_ctrl_line(struct usb_serial_port *port, u8 mcr)\n{\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *dev = port->serial->dev;\n\tint retval;\n\n\tif (priv->quirks & SPCP825_QUIRK_NO_UART_STATUS)\n\t\treturn -EPERM;\n\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t SET_UART_STATUS_TYPE, SET_UART_STATUS,\n\t\t\t\t mcr, 0x04, NULL, 0, 100);\n\tif (retval != 0) {\n\t\tdev_err(&port->dev, \"failed to set control lines: %d\\n\",\n\t\t\t\t\t\t\t\tretval);\n\t}\n\treturn retval;\n}\n\nstatic int spcp8x5_get_msr(struct usb_serial_port *port, u8 *status)\n{\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *dev = port->serial->dev;\n\tu8 *buf;\n\tint ret;\n\n\tif (priv->quirks & SPCP825_QUIRK_NO_UART_STATUS)\n\t\treturn -EPERM;\n\n\tbuf = kzalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      GET_UART_STATUS, GET_UART_STATUS_TYPE,\n\t\t\t      0, GET_UART_STATUS_MSR, buf, 1, 100);\n\tif (ret < 1) {\n\t\tdev_err(&port->dev, \"failed to get modem status: %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\tdev_dbg(&port->dev, \"0xc0:0x22:0:6  %d - 0x02%x\\n\", ret, *buf);\n\t*status = *buf;\n\tret = 0;\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic void spcp8x5_set_work_mode(struct usb_serial_port *port, u16 value,\n\t\t\t\t\t\t\t\t u16 index)\n{\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *dev = port->serial->dev;\n\tint ret;\n\n\tif (priv->quirks & SPCP825_QUIRK_NO_WORK_MODE)\n\t\treturn;\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t      SET_WORKING_MODE_TYPE, SET_WORKING_MODE,\n\t\t\t      value, index, NULL, 0, 100);\n\tdev_dbg(&port->dev, \"value = %#x , index = %#x\\n\", value, index);\n\tif (ret < 0)\n\t\tdev_err(&port->dev, \"failed to set work mode: %d\\n\", ret);\n}\n\nstatic int spcp8x5_carrier_raised(struct usb_serial_port *port)\n{\n\tu8 msr;\n\tint ret;\n\n\tret = spcp8x5_get_msr(port, &msr);\n\tif (ret || msr & MSR_STATUS_LINE_DCD)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void spcp8x5_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (on)\n\t\tpriv->line_control = MCR_CONTROL_LINE_DTR\n\t\t\t\t\t\t| MCR_CONTROL_LINE_RTS;\n\telse\n\t\tpriv->line_control &= ~ (MCR_CONTROL_LINE_DTR\n\t\t\t\t\t\t| MCR_CONTROL_LINE_RTS);\n\tcontrol = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tspcp8x5_set_ctrl_line(port, control);\n}\n\nstatic void spcp8x5_init_termios(struct tty_struct *tty)\n{\n\ttty_encode_baud_rate(tty, 115200, 115200);\n}\n\nstatic void spcp8x5_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned short uartdata;\n\tunsigned char buf[2] = {0, 0};\n\tint baud;\n\tint i;\n\tu8 control;\n\n\t \n\tif (old_termios && !tty_termios_hw_change(&tty->termios, old_termios))\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol = priv->line_control;\n\tif (old_termios && (old_termios->c_cflag & CBAUD) == B0) {\n\t\tpriv->line_control |= MCR_DTR;\n\t\tif (!(old_termios->c_cflag & CRTSCTS))\n\t\t\tpriv->line_control |= MCR_RTS;\n\t}\n\tif (control != priv->line_control) {\n\t\tcontrol = priv->line_control;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tspcp8x5_set_ctrl_line(port, control);\n\t} else {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tswitch (baud) {\n\tcase 300:\tbuf[0] = 0x00;\tbreak;\n\tcase 600:\tbuf[0] = 0x01;\tbreak;\n\tcase 1200:\tbuf[0] = 0x02;\tbreak;\n\tcase 2400:\tbuf[0] = 0x03;\tbreak;\n\tcase 4800:\tbuf[0] = 0x04;\tbreak;\n\tcase 9600:\tbuf[0] = 0x05;\tbreak;\n\tcase 19200:\tbuf[0] = 0x07;\tbreak;\n\tcase 38400:\tbuf[0] = 0x09;\tbreak;\n\tcase 57600:\tbuf[0] = 0x0a;\tbreak;\n\tcase 115200:\tbuf[0] = 0x0b;\tbreak;\n\tcase 230400:\tbuf[0] = 0x0c;\tbreak;\n\tcase 460800:\tbuf[0] = 0x0d;\tbreak;\n\tcase 921600:\tbuf[0] = 0x0e;\tbreak;\n \n \n\tcase 3000000:\tbuf[0] = 0x11;\tbreak;\n \n\tcase 0:\n\tcase 1000000:\n\t\t\tbuf[0] = 0x0b;\tbreak;\n\tdefault:\n\t\tdev_err(&port->dev, \"unsupported baudrate, using 9600\\n\");\n\t}\n\n\t \n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tbuf[1] |= SET_UART_FORMAT_SIZE_5;\n\t\tbreak;\n\tcase CS6:\n\t\tbuf[1] |= SET_UART_FORMAT_SIZE_6;\n\t\tbreak;\n\tcase CS7:\n\t\tbuf[1] |= SET_UART_FORMAT_SIZE_7;\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tbuf[1] |= SET_UART_FORMAT_SIZE_8;\n\t\tbreak;\n\t}\n\n\t \n\tbuf[1] |= (cflag & CSTOPB) ? SET_UART_FORMAT_STOP_2 :\n\t\t\t\t     SET_UART_FORMAT_STOP_1;\n\n\t \n\tif (cflag & PARENB) {\n\t\tbuf[1] |= (cflag & PARODD) ?\n\t\tSET_UART_FORMAT_PAR_ODD : SET_UART_FORMAT_PAR_EVEN ;\n\t} else {\n\t\tbuf[1] |= SET_UART_FORMAT_PAR_NONE;\n\t}\n\tuartdata = buf[0] | buf[1]<<8;\n\n\ti = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t    SET_UART_FORMAT_TYPE, SET_UART_FORMAT,\n\t\t\t    uartdata, 0, NULL, 0, 100);\n\tif (i < 0)\n\t\tdev_err(&port->dev, \"Set UART format %#x failed (error = %d)\\n\",\n\t\t\tuartdata, i);\n\tdev_dbg(&port->dev, \"0x21:0x40:0:0  %d\\n\", i);\n\n\tif (cflag & CRTSCTS) {\n\t\t \n\t\tspcp8x5_set_work_mode(port, 0x000a, SET_WORKING_MODE_U2C);\n\t}\n}\n\nstatic int spcp8x5_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tint ret;\n\n\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\n\tret = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t      0x09, 0x00,\n\t\t\t      0x01, 0x00, NULL, 0x00, 100);\n\tif (ret)\n\t\treturn ret;\n\n\tspcp8x5_set_ctrl_line(port, priv->line_control);\n\n\tif (tty)\n\t\tspcp8x5_set_termios(tty, port, NULL);\n\n\treturn usb_serial_generic_open(tty, port);\n}\n\nstatic int spcp8x5_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (set & TIOCM_RTS)\n\t\tpriv->line_control |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tpriv->line_control |= MCR_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tpriv->line_control &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tpriv->line_control &= ~MCR_DTR;\n\tcontrol = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn spcp8x5_set_ctrl_line(port, control);\n}\n\nstatic int spcp8x5_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct spcp8x5_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int mcr;\n\tu8 status;\n\tunsigned int result;\n\n\tresult = spcp8x5_get_msr(port, &status);\n\tif (result)\n\t\treturn result;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmcr = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tresult = ((mcr & MCR_DTR)\t\t\t? TIOCM_DTR : 0)\n\t\t  | ((mcr & MCR_RTS)\t\t\t? TIOCM_RTS : 0)\n\t\t  | ((status & MSR_STATUS_LINE_CTS)\t? TIOCM_CTS : 0)\n\t\t  | ((status & MSR_STATUS_LINE_DSR)\t? TIOCM_DSR : 0)\n\t\t  | ((status & MSR_STATUS_LINE_RI)\t? TIOCM_RI  : 0)\n\t\t  | ((status & MSR_STATUS_LINE_DCD)\t? TIOCM_CD  : 0);\n\n\treturn result;\n}\n\nstatic struct usb_serial_driver spcp8x5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"SPCP8x5\",\n\t},\n\t.id_table\t\t= id_table,\n\t.num_ports\t\t= 1,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.open\t\t\t= spcp8x5_open,\n\t.dtr_rts\t\t= spcp8x5_dtr_rts,\n\t.carrier_raised\t\t= spcp8x5_carrier_raised,\n\t.set_termios\t\t= spcp8x5_set_termios,\n\t.init_termios\t\t= spcp8x5_init_termios,\n\t.tiocmget\t\t= spcp8x5_tiocmget,\n\t.tiocmset\t\t= spcp8x5_tiocmset,\n\t.probe\t\t\t= spcp8x5_probe,\n\t.port_probe\t\t= spcp8x5_port_probe,\n\t.port_remove\t\t= spcp8x5_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&spcp8x5_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}