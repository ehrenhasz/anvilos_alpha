{
  "module_name": "belkin_sa.c",
  "hash_id": "bc3e3613f9a61d7f1b6e8b55d2883bfdba1669e59cd686c2910b51f4469ed673",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/belkin_sa.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"belkin_sa.h\"\n\n#define DRIVER_AUTHOR \"William Greathouse <wgreathouse@smva.com>\"\n#define DRIVER_DESC \"USB Belkin Serial converter driver\"\n\n \nstatic int belkin_sa_port_probe(struct usb_serial_port *port);\nstatic void belkin_sa_port_remove(struct usb_serial_port *port);\nstatic int  belkin_sa_open(struct tty_struct *tty,\n\t\t\tstruct usb_serial_port *port);\nstatic void belkin_sa_close(struct usb_serial_port *port);\nstatic void belkin_sa_read_int_callback(struct urb *urb);\nstatic void belkin_sa_process_read_urb(struct urb *urb);\nstatic void belkin_sa_set_termios(struct tty_struct *tty,\n\t\t\t\t  struct usb_serial_port *port,\n\t\t\t\t  const struct ktermios *old_termios);\nstatic int belkin_sa_break_ctl(struct tty_struct *tty, int break_state);\nstatic int  belkin_sa_tiocmget(struct tty_struct *tty);\nstatic int  belkin_sa_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear);\n\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(BELKIN_SA_VID, BELKIN_SA_PID) },\n\t{ USB_DEVICE(BELKIN_OLD_VID, BELKIN_OLD_PID) },\n\t{ USB_DEVICE(PERACOM_VID, PERACOM_PID) },\n\t{ USB_DEVICE(GOHUBS_VID, GOHUBS_PID) },\n\t{ USB_DEVICE(GOHUBS_VID, HANDYLINK_PID) },\n\t{ USB_DEVICE(BELKIN_DOCKSTATION_VID, BELKIN_DOCKSTATION_PID) },\n\t{ }\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstatic struct usb_serial_driver belkin_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"belkin\",\n\t},\n\t.description =\t\t\"Belkin / Peracom / GoHubs USB Serial Adapter\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.open =\t\t\tbelkin_sa_open,\n\t.close =\t\tbelkin_sa_close,\n\t.read_int_callback =\tbelkin_sa_read_int_callback,\n\t.process_read_urb =\tbelkin_sa_process_read_urb,\n\t.set_termios =\t\tbelkin_sa_set_termios,\n\t.break_ctl =\t\tbelkin_sa_break_ctl,\n\t.tiocmget =\t\tbelkin_sa_tiocmget,\n\t.tiocmset =\t\tbelkin_sa_tiocmset,\n\t.port_probe =\t\tbelkin_sa_port_probe,\n\t.port_remove =\t\tbelkin_sa_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&belkin_device, NULL\n};\n\nstruct belkin_sa_private {\n\tspinlock_t\t\tlock;\n\tunsigned long\t\tcontrol_state;\n\tunsigned char\t\tlast_lsr;\n\tunsigned char\t\tlast_msr;\n\tint\t\t\tbad_flow_control;\n};\n\n\n \n\n#define WDR_TIMEOUT 5000  \n\n \n#define BSA_USB_CMD(c, v) usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0), \\\n\t\t\t\t\t    (c), BELKIN_SA_SET_REQUEST_TYPE, \\\n\t\t\t\t\t    (v), 0, NULL, 0, WDR_TIMEOUT)\n\nstatic int belkin_sa_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct belkin_sa_private *priv;\n\n\tpriv = kmalloc(sizeof(struct belkin_sa_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->control_state = 0;\n\tpriv->last_lsr = 0;\n\tpriv->last_msr = 0;\n\t \n\tpriv->bad_flow_control =\n\t\t(le16_to_cpu(dev->descriptor.bcdDevice) <= 0x0206) ? 1 : 0;\n\tdev_info(&dev->dev, \"bcdDevice: %04x, bfc: %d\\n\",\n\t\t\t\t\tle16_to_cpu(dev->descriptor.bcdDevice),\n\t\t\t\t\tpriv->bad_flow_control);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void belkin_sa_port_remove(struct usb_serial_port *port)\n{\n\tstruct belkin_sa_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int belkin_sa_open(struct tty_struct *tty,\n\t\t\t\t\tstruct usb_serial_port *port)\n{\n\tint retval;\n\n\tretval = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&port->dev, \"usb_submit_urb(read int) failed\\n\");\n\t\treturn retval;\n\t}\n\n\tretval = usb_serial_generic_open(tty, port);\n\tif (retval)\n\t\tusb_kill_urb(port->interrupt_in_urb);\n\n\treturn retval;\n}\n\nstatic void belkin_sa_close(struct usb_serial_port *port)\n{\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic void belkin_sa_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct belkin_sa_private *priv;\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\t \n\t \n\n\tpriv = usb_get_serial_port_data(port);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->last_msr = data[BELKIN_SA_MSR_INDEX];\n\n\t \n\tif (priv->last_msr & BELKIN_SA_MSR_DSR)\n\t\tpriv->control_state |= TIOCM_DSR;\n\telse\n\t\tpriv->control_state &= ~TIOCM_DSR;\n\n\tif (priv->last_msr & BELKIN_SA_MSR_CTS)\n\t\tpriv->control_state |= TIOCM_CTS;\n\telse\n\t\tpriv->control_state &= ~TIOCM_CTS;\n\n\tif (priv->last_msr & BELKIN_SA_MSR_RI)\n\t\tpriv->control_state |= TIOCM_RI;\n\telse\n\t\tpriv->control_state &= ~TIOCM_RI;\n\n\tif (priv->last_msr & BELKIN_SA_MSR_CD)\n\t\tpriv->control_state |= TIOCM_CD;\n\telse\n\t\tpriv->control_state &= ~TIOCM_CD;\n\n\tpriv->last_lsr = data[BELKIN_SA_LSR_INDEX];\n\tspin_unlock_irqrestore(&priv->lock, flags);\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&port->dev, \"%s - usb_submit_urb failed with \"\n\t\t\t\"result %d\\n\", __func__, retval);\n}\n\nstatic void belkin_sa_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned long flags;\n\tunsigned char status;\n\tchar tty_flag;\n\n\t \n\ttty_flag = TTY_NORMAL;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tstatus = priv->last_lsr;\n\tpriv->last_lsr &= ~BELKIN_SA_LSR_ERR;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (status & BELKIN_SA_LSR_ERR) {\n\t\t \n\t\tif (status & BELKIN_SA_LSR_BI)\n\t\t\ttty_flag = TTY_BREAK;\n\t\telse if (status & BELKIN_SA_LSR_PE)\n\t\t\ttty_flag = TTY_PARITY;\n\t\telse if (status & BELKIN_SA_LSR_FE)\n\t\t\ttty_flag = TTY_FRAME;\n\t\tdev_dbg(&port->dev, \"tty_flag = %d\\n\", tty_flag);\n\n\t\t \n\t\tif (status & BELKIN_SA_LSR_OE)\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t}\n\n\ttty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\n\t\t\t\t\t\t\turb->actual_length);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void belkin_sa_set_termios(struct tty_struct *tty,\n\t\t\t\t  struct usb_serial_port *port,\n\t\t\t\t  const struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\n\tunsigned int iflag;\n\tunsigned int cflag;\n\tunsigned int old_iflag = 0;\n\tunsigned int old_cflag = 0;\n\t__u16 urb_value = 0;  \n\tunsigned long flags;\n\tunsigned long control_state;\n\tint bad_flow_control;\n\tspeed_t baud;\n\tstruct ktermios *termios = &tty->termios;\n\n\tiflag = termios->c_iflag;\n\tcflag = termios->c_cflag;\n\n\ttermios->c_cflag &= ~CMSPAR;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\tbad_flow_control = priv->bad_flow_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\told_iflag = old_termios->c_iflag;\n\told_cflag = old_termios->c_cflag;\n\n\t \n\tif ((cflag & CBAUD) != (old_cflag & CBAUD)) {\n\t\t \n\t\tif ((old_cflag & CBAUD) == B0) {\n\t\t\tcontrol_state |= (TIOCM_DTR|TIOCM_RTS);\n\t\t\tif (BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, 1) < 0)\n\t\t\t\tdev_err(&port->dev, \"Set DTR error\\n\");\n\t\t\t \n\t\t\tif (!(old_cflag & CRTSCTS))\n\t\t\t\tif (BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST\n\t\t\t\t\t\t\t\t, 1) < 0)\n\t\t\t\t\tdev_err(&port->dev, \"Set RTS error\\n\");\n\t\t}\n\t}\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (baud) {\n\t\turb_value = BELKIN_SA_BAUD(baud);\n\t\t \n\t\tif (urb_value == 0)\n\t\t\turb_value = 1;\n\t\t \n\t\tbaud = BELKIN_SA_BAUD(urb_value);\n\n\t\t \n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_BAUDRATE_REQUEST, urb_value) < 0)\n\t\t\tdev_err(&port->dev, \"Set baudrate error\\n\");\n\t} else {\n\t\t \n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_FLOW_CTRL_REQUEST,\n\t\t\t\t\t\tBELKIN_SA_FLOW_NONE) < 0)\n\t\t\tdev_err(&port->dev, \"Disable flowcontrol error\\n\");\n\t\t \n\t\tcontrol_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, 0) < 0)\n\t\t\tdev_err(&port->dev, \"DTR LOW error\\n\");\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST, 0) < 0)\n\t\t\tdev_err(&port->dev, \"RTS LOW error\\n\");\n\t}\n\n\t \n\tif ((cflag ^ old_cflag) & (PARENB | PARODD)) {\n\t\tif (cflag & PARENB)\n\t\t\turb_value = (cflag & PARODD) ?  BELKIN_SA_PARITY_ODD\n\t\t\t\t\t\t: BELKIN_SA_PARITY_EVEN;\n\t\telse\n\t\t\turb_value = BELKIN_SA_PARITY_NONE;\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_PARITY_REQUEST, urb_value) < 0)\n\t\t\tdev_err(&port->dev, \"Set parity error\\n\");\n\t}\n\n\t \n\tif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\n\t\turb_value = BELKIN_SA_DATA_BITS(tty_get_char_size(cflag));\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_DATA_BITS_REQUEST, urb_value) < 0)\n\t\t\tdev_err(&port->dev, \"Set data bits error\\n\");\n\t}\n\n\t \n\tif ((cflag & CSTOPB) != (old_cflag & CSTOPB)) {\n\t\turb_value = (cflag & CSTOPB) ? BELKIN_SA_STOP_BITS(2)\n\t\t\t\t\t\t: BELKIN_SA_STOP_BITS(1);\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_STOP_BITS_REQUEST,\n\t\t\t\t\t\t\turb_value) < 0)\n\t\t\tdev_err(&port->dev, \"Set stop bits error\\n\");\n\t}\n\n\t \n\tif (((iflag ^ old_iflag) & (IXOFF | IXON)) ||\n\t\t((cflag ^ old_cflag) & CRTSCTS)) {\n\t\turb_value = 0;\n\t\tif ((iflag & IXOFF) || (iflag & IXON))\n\t\t\turb_value |= (BELKIN_SA_FLOW_OXON | BELKIN_SA_FLOW_IXON);\n\t\telse\n\t\t\turb_value &= ~(BELKIN_SA_FLOW_OXON | BELKIN_SA_FLOW_IXON);\n\n\t\tif (cflag & CRTSCTS)\n\t\t\turb_value |=  (BELKIN_SA_FLOW_OCTS | BELKIN_SA_FLOW_IRTS);\n\t\telse\n\t\t\turb_value &= ~(BELKIN_SA_FLOW_OCTS | BELKIN_SA_FLOW_IRTS);\n\n\t\tif (bad_flow_control)\n\t\t\turb_value &= ~(BELKIN_SA_FLOW_IRTS);\n\n\t\tif (BSA_USB_CMD(BELKIN_SA_SET_FLOW_CTRL_REQUEST, urb_value) < 0)\n\t\t\tdev_err(&port->dev, \"Set flow control error\\n\");\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->control_state = control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}\n\nstatic int belkin_sa_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tint ret;\n\n\tret = BSA_USB_CMD(BELKIN_SA_SET_BREAK_REQUEST, break_state ? 1 : 0);\n\tif (ret < 0) {\n\t\tdev_err(&port->dev, \"Set break_ctl %d\\n\", break_state);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int belkin_sa_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\n\tunsigned long control_state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn control_state;\n}\n\nstatic int belkin_sa_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tstruct belkin_sa_private *priv = usb_get_serial_port_data(port);\n\tunsigned long control_state;\n\tunsigned long flags;\n\tint retval;\n\tint rts = 0;\n\tint dtr = 0;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\n\tif (set & TIOCM_RTS) {\n\t\tcontrol_state |= TIOCM_RTS;\n\t\trts = 1;\n\t}\n\tif (set & TIOCM_DTR) {\n\t\tcontrol_state |= TIOCM_DTR;\n\t\tdtr = 1;\n\t}\n\tif (clear & TIOCM_RTS) {\n\t\tcontrol_state &= ~TIOCM_RTS;\n\t\trts = 0;\n\t}\n\tif (clear & TIOCM_DTR) {\n\t\tcontrol_state &= ~TIOCM_DTR;\n\t\tdtr = 0;\n\t}\n\n\tpriv->control_state = control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tretval = BSA_USB_CMD(BELKIN_SA_SET_RTS_REQUEST, rts);\n\tif (retval < 0) {\n\t\tdev_err(&port->dev, \"Set RTS error %d\\n\", retval);\n\t\tgoto exit;\n\t}\n\n\tretval = BSA_USB_CMD(BELKIN_SA_SET_DTR_REQUEST, dtr);\n\tif (retval < 0) {\n\t\tdev_err(&port->dev, \"Set DTR error %d\\n\", retval);\n\t\tgoto exit;\n\t}\nexit:\n\treturn retval;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}