{
  "module_name": "mct_u232.c",
  "hash_id": "5c97349b306df751f17fa652fd7a2abf2b112b405b39806786a8ad56e33d46ed",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/mct_u232.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial.h>\n#include \"mct_u232.h\"\n\n#define DRIVER_AUTHOR \"Wolfgang Grandegger <wolfgang@ces.ch>\"\n#define DRIVER_DESC \"Magic Control Technology USB-RS232 converter driver\"\n\n \nstatic int  mct_u232_port_probe(struct usb_serial_port *port);\nstatic void mct_u232_port_remove(struct usb_serial_port *remove);\nstatic int  mct_u232_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void mct_u232_close(struct usb_serial_port *port);\nstatic void mct_u232_dtr_rts(struct usb_serial_port *port, int on);\nstatic void mct_u232_read_int_callback(struct urb *urb);\nstatic void mct_u232_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t const struct ktermios *old_termios);\nstatic int  mct_u232_break_ctl(struct tty_struct *tty, int break_state);\nstatic int  mct_u232_tiocmget(struct tty_struct *tty);\nstatic int  mct_u232_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic void mct_u232_throttle(struct tty_struct *tty);\nstatic void mct_u232_unthrottle(struct tty_struct *tty);\n\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(MCT_U232_VID, MCT_U232_PID) },\n\t{ USB_DEVICE(MCT_U232_VID, MCT_U232_SITECOM_PID) },\n\t{ USB_DEVICE(MCT_U232_VID, MCT_U232_DU_H3SP_PID) },\n\t{ USB_DEVICE(MCT_U232_BELKIN_F5U109_VID, MCT_U232_BELKIN_F5U109_PID) },\n\t{ }\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver mct_u232_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"mct_u232\",\n\t},\n\t.description =\t     \"MCT U232\",\n\t.id_table =\t     id_table,\n\t.num_ports =\t     1,\n\t.open =\t\t     mct_u232_open,\n\t.close =\t     mct_u232_close,\n\t.dtr_rts =\t     mct_u232_dtr_rts,\n\t.throttle =\t     mct_u232_throttle,\n\t.unthrottle =\t     mct_u232_unthrottle,\n\t.read_int_callback = mct_u232_read_int_callback,\n\t.set_termios =\t     mct_u232_set_termios,\n\t.break_ctl =\t     mct_u232_break_ctl,\n\t.tiocmget =\t     mct_u232_tiocmget,\n\t.tiocmset =\t     mct_u232_tiocmset,\n\t.tiocmiwait =        usb_serial_generic_tiocmiwait,\n\t.port_probe =        mct_u232_port_probe,\n\t.port_remove =       mct_u232_port_remove,\n\t.get_icount =        usb_serial_generic_get_icount,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&mct_u232_device, NULL\n};\n\nstruct mct_u232_private {\n\tstruct urb *read_urb;\n\tspinlock_t lock;\n\tunsigned int\t     control_state;  \n\tunsigned char        last_lcr;       \n\tunsigned char\t     last_lsr;       \n\tunsigned char\t     last_msr;       \n\tunsigned int\t     rx_flags;       \n};\n\n#define THROTTLED\t\t0x01\n\n \n\n#define WDR_TIMEOUT 5000  \n\n \nstatic int mct_u232_calculate_baud_rate(struct usb_serial *serial,\n\t\t\t\t\tspeed_t value, speed_t *result)\n{\n\t*result = value;\n\n\tif (le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_SITECOM_PID\n\t\t|| le16_to_cpu(serial->dev->descriptor.idProduct) == MCT_U232_BELKIN_F5U109_PID) {\n\t\tswitch (value) {\n\t\tcase 300:\n\t\t\treturn 0x01;\n\t\tcase 600:\n\t\t\treturn 0x02;  \n\t\tcase 1200:\n\t\t\treturn 0x03;\n\t\tcase 2400:\n\t\t\treturn 0x04;\n\t\tcase 4800:\n\t\t\treturn 0x06;\n\t\tcase 9600:\n\t\t\treturn 0x08;\n\t\tcase 19200:\n\t\t\treturn 0x09;\n\t\tcase 38400:\n\t\t\treturn 0x0a;\n\t\tcase 57600:\n\t\t\treturn 0x0b;\n\t\tcase 115200:\n\t\t\treturn 0x0c;\n\t\tdefault:\n\t\t\t*result = 9600;\n\t\t\treturn 0x08;\n\t\t}\n\t} else {\n\t\t \n\t\tswitch (value) {\n\t\tcase 300: break;\n\t\tcase 600: break;\n\t\tcase 1200: break;\n\t\tcase 2400: break;\n\t\tcase 4800: break;\n\t\tcase 9600: break;\n\t\tcase 19200: break;\n\t\tcase 38400: break;\n\t\tcase 57600: break;\n\t\tcase 115200: break;\n\t\tdefault:\n\t\t\tvalue = 9600;\n\t\t\t*result = 9600;\n\t\t}\n\t\treturn 115200/value;\n\t}\n}\n\nstatic int mct_u232_set_baud_rate(struct tty_struct *tty,\n\tstruct usb_serial *serial, struct usb_serial_port *port, speed_t value)\n{\n\tunsigned int divisor;\n\tint rc;\n\tunsigned char *buf;\n\tunsigned char cts_enable_byte = 0;\n\tspeed_t speed;\n\n\tbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tdivisor = mct_u232_calculate_baud_rate(serial, value, &speed);\n\tput_unaligned_le32(divisor, buf);\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\tMCT_U232_SET_BAUD_RATE_REQUEST,\n\t\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t\t0, 0, buf, MCT_U232_SET_BAUD_RATE_SIZE,\n\t\t\t\tWDR_TIMEOUT);\n\tif (rc < 0)\t \n\t\tdev_err(&port->dev, \"Set BAUD RATE %d failed (error = %d)\\n\",\n\t\t\tvalue, rc);\n\telse\n\t\ttty_encode_baud_rate(tty, speed, speed);\n\tdev_dbg(&port->dev, \"set_baud_rate: value: 0x%x, divisor: 0x%x\\n\", value, divisor);\n\n\t \n\n\tbuf[0] = 0;\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\tMCT_U232_SET_UNKNOWN1_REQUEST,\n\t\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t\t0, 0, buf, MCT_U232_SET_UNKNOWN1_SIZE,\n\t\t\t\tWDR_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Sending USB device request code %d \"\n\t\t\t\"failed (error = %d)\\n\", MCT_U232_SET_UNKNOWN1_REQUEST,\n\t\t\trc);\n\n\tif (port && C_CRTSCTS(tty))\n\t   cts_enable_byte = 1;\n\n\tdev_dbg(&port->dev, \"set_baud_rate: send second control message, data = %02X\\n\",\n\t\tcts_enable_byte);\n\tbuf[0] = cts_enable_byte;\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\tMCT_U232_SET_CTS_REQUEST,\n\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t0, 0, buf, MCT_U232_SET_CTS_SIZE,\n\t\t\tWDR_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Sending USB device request code %d \"\n\t\t\t\"failed (error = %d)\\n\", MCT_U232_SET_CTS_REQUEST, rc);\n\n\tkfree(buf);\n\treturn rc;\n}  \n\nstatic int mct_u232_set_line_ctrl(struct usb_serial_port *port,\n\t\t\t\t  unsigned char lcr)\n{\n\tint rc;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tbuf[0] = lcr;\n\trc = usb_control_msg(port->serial->dev, usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tMCT_U232_SET_LINE_CTRL_REQUEST,\n\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t0, 0, buf, MCT_U232_SET_LINE_CTRL_SIZE,\n\t\t\tWDR_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"Set LINE CTRL 0x%x failed (error = %d)\\n\", lcr, rc);\n\tdev_dbg(&port->dev, \"set_line_ctrl: 0x%x\\n\", lcr);\n\tkfree(buf);\n\treturn rc;\n}  \n\nstatic int mct_u232_set_modem_ctrl(struct usb_serial_port *port,\n\t\t\t\t   unsigned int control_state)\n{\n\tint rc;\n\tunsigned char mcr;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tmcr = MCT_U232_MCR_NONE;\n\tif (control_state & TIOCM_DTR)\n\t\tmcr |= MCT_U232_MCR_DTR;\n\tif (control_state & TIOCM_RTS)\n\t\tmcr |= MCT_U232_MCR_RTS;\n\n\tbuf[0] = mcr;\n\trc = usb_control_msg(port->serial->dev, usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tMCT_U232_SET_MODEM_CTRL_REQUEST,\n\t\t\tMCT_U232_SET_REQUEST_TYPE,\n\t\t\t0, 0, buf, MCT_U232_SET_MODEM_CTRL_SIZE,\n\t\t\tWDR_TIMEOUT);\n\tkfree(buf);\n\n\tdev_dbg(&port->dev, \"set_modem_ctrl: state=0x%x ==> mcr=0x%x\\n\", control_state, mcr);\n\n\tif (rc < 0) {\n\t\tdev_err(&port->dev, \"Set MODEM CTRL 0x%x failed (error = %d)\\n\", mcr, rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}  \n\nstatic int mct_u232_get_modem_stat(struct usb_serial_port *port,\n\t\t\t\t   unsigned char *msr)\n{\n\tint rc;\n\tunsigned char *buf;\n\n\tbuf = kmalloc(MCT_U232_MAX_SIZE, GFP_KERNEL);\n\tif (buf == NULL) {\n\t\t*msr = 0;\n\t\treturn -ENOMEM;\n\t}\n\trc = usb_control_msg(port->serial->dev, usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\tMCT_U232_GET_MODEM_STAT_REQUEST,\n\t\t\tMCT_U232_GET_REQUEST_TYPE,\n\t\t\t0, 0, buf, MCT_U232_GET_MODEM_STAT_SIZE,\n\t\t\tWDR_TIMEOUT);\n\tif (rc < MCT_U232_GET_MODEM_STAT_SIZE) {\n\t\tdev_err(&port->dev, \"Get MODEM STATus failed (error = %d)\\n\", rc);\n\n\t\tif (rc >= 0)\n\t\t\trc = -EIO;\n\n\t\t*msr = 0;\n\t} else {\n\t\t*msr = buf[0];\n\t}\n\tdev_dbg(&port->dev, \"get_modem_stat: 0x%x\\n\", *msr);\n\tkfree(buf);\n\treturn rc;\n}  \n\nstatic void mct_u232_msr_to_icount(struct async_icount *icount,\n\t\t\t\t\t\tunsigned char msr)\n{\n\t \n\tif (msr & MCT_U232_MSR_DDSR)\n\t\ticount->dsr++;\n\tif (msr & MCT_U232_MSR_DCTS)\n\t\ticount->cts++;\n\tif (msr & MCT_U232_MSR_DRI)\n\t\ticount->rng++;\n\tif (msr & MCT_U232_MSR_DCD)\n\t\ticount->dcd++;\n}  \n\nstatic void mct_u232_msr_to_state(struct usb_serial_port *port,\n\t\t\t\t  unsigned int *control_state, unsigned char msr)\n{\n\t \n\tif (msr & MCT_U232_MSR_DSR)\n\t\t*control_state |=  TIOCM_DSR;\n\telse\n\t\t*control_state &= ~TIOCM_DSR;\n\tif (msr & MCT_U232_MSR_CTS)\n\t\t*control_state |=  TIOCM_CTS;\n\telse\n\t\t*control_state &= ~TIOCM_CTS;\n\tif (msr & MCT_U232_MSR_RI)\n\t\t*control_state |=  TIOCM_RI;\n\telse\n\t\t*control_state &= ~TIOCM_RI;\n\tif (msr & MCT_U232_MSR_CD)\n\t\t*control_state |=  TIOCM_CD;\n\telse\n\t\t*control_state &= ~TIOCM_CD;\n\tdev_dbg(&port->dev, \"msr_to_state: msr=0x%x ==> state=0x%x\\n\", msr, *control_state);\n}  \n\n \n\nstatic int mct_u232_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv;\n\n\t \n\tif (!serial->port[1] || !serial->port[1]->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"expected endpoint missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->read_urb = serial->port[1]->interrupt_in_urb;\n\tpriv->read_urb->context = port;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void mct_u232_port_remove(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int  mct_u232_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tint retval = 0;\n\tunsigned int control_state;\n\tunsigned long flags;\n\tunsigned char last_lcr;\n\tunsigned char last_msr;\n\n\t \n\tif (le16_to_cpu(serial->dev->descriptor.idProduct)\n\t\t\t\t\t\t== MCT_U232_SITECOM_PID)\n\t\tport->bulk_out_size = 16;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (tty && C_BAUD(tty))\n\t\tpriv->control_state = TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tpriv->control_state = 0;\n\n\tpriv->last_lcr = (MCT_U232_DATA_BITS_8 |\n\t\t\t  MCT_U232_PARITY_NONE |\n\t\t\t  MCT_U232_STOP_BITS_1);\n\tcontrol_state = priv->control_state;\n\tlast_lcr = priv->last_lcr;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tmct_u232_set_modem_ctrl(port, control_state);\n\tmct_u232_set_line_ctrl(port, last_lcr);\n\n\t \n\tmct_u232_get_modem_stat(port, &last_msr);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->last_msr = last_msr;\n\tmct_u232_msr_to_state(port, &priv->control_state, priv->last_msr);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tretval = usb_submit_urb(priv->read_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&port->dev,\n\t\t\t\"usb_submit_urb(read) failed pipe 0x%x err %d\\n\",\n\t\t\tport->read_urb->pipe, retval);\n\t\tgoto error;\n\t}\n\n\tretval = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tusb_kill_urb(priv->read_urb);\n\t\tdev_err(&port->dev,\n\t\t\t\"usb_submit_urb(read int) failed pipe 0x%x err %d\",\n\t\t\tport->interrupt_in_urb->pipe, retval);\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\treturn retval;\n}  \n\nstatic void mct_u232_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tunsigned int control_state;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irq(&priv->lock);\n\tif (on)\n\t\tpriv->control_state |= TIOCM_DTR | TIOCM_RTS;\n\telse\n\t\tpriv->control_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\tcontrol_state = priv->control_state;\n\tspin_unlock_irq(&priv->lock);\n\n\tmct_u232_set_modem_ctrl(port, control_state);\n}\n\nstatic void mct_u232_close(struct usb_serial_port *port)\n{\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\n\tusb_kill_urb(priv->read_urb);\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\tusb_serial_generic_close(port);\n}  \n\n\nstatic void mct_u232_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tint retval;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\t \n\tif (urb->transfer_buffer_length > 2) {\n\t\tif (urb->actual_length) {\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\t\ttty_flip_buffer_push(&port->port);\n\t\t}\n\t\tgoto exit;\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->last_msr = data[MCT_U232_MSR_INDEX];\n\n\t \n\tmct_u232_msr_to_state(port, &priv->control_state, priv->last_msr);\n\n\tmct_u232_msr_to_icount(&port->icount, priv->last_msr);\n\n#if 0\n\t \n\t \n\tpriv->last_lsr = data[MCT_U232_LSR_INDEX];\n\t \n\tif (priv->last_lsr & MCT_U232_LSR_ERR) {\n\t\ttty = tty_port_tty_get(&port->port);\n\t\t \n\t\tif (priv->last_lsr & MCT_U232_LSR_OE) {\n\t\t}\n\t\t \n\t\tif (priv->last_lsr & MCT_U232_LSR_PE) {\n\t\t}\n\t\t \n\t\tif (priv->last_lsr & MCT_U232_LSR_FE) {\n\t\t}\n\t\t \n\t\tif (priv->last_lsr & MCT_U232_LSR_BI) {\n\t\t}\n\t\ttty_kref_put(tty);\n\t}\n#endif\n\twake_up_interruptible(&port->port.delta_msr_wait);\n\tspin_unlock_irqrestore(&priv->lock, flags);\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}  \n\nstatic void mct_u232_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t const struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tstruct ktermios *termios = &tty->termios;\n\tunsigned int cflag = termios->c_cflag;\n\tunsigned int old_cflag = old_termios->c_cflag;\n\tunsigned long flags;\n\tunsigned int control_state;\n\tunsigned char last_lcr;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tlast_lcr = 0;\n\n\t \n\n\t \n\tif ((old_cflag & CBAUD) == B0) {\n\t\tdev_dbg(&port->dev, \"%s: baud was B0\\n\", __func__);\n\t\tcontrol_state |= TIOCM_DTR | TIOCM_RTS;\n\t\tmct_u232_set_modem_ctrl(port, control_state);\n\t}\n\n\tmct_u232_set_baud_rate(tty, serial, port, tty_get_baud_rate(tty));\n\n\tif ((cflag & CBAUD) == B0) {\n\t\tdev_dbg(&port->dev, \"%s: baud is B0\\n\", __func__);\n\t\t \n\t\tcontrol_state &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tmct_u232_set_modem_ctrl(port, control_state);\n\t}\n\n\t \n\n\t \n\tif (cflag & PARENB)\n\t\tlast_lcr |= (cflag & PARODD) ?\n\t\t\tMCT_U232_PARITY_ODD : MCT_U232_PARITY_EVEN;\n\telse\n\t\tlast_lcr |= MCT_U232_PARITY_NONE;\n\n\t \n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tlast_lcr |= MCT_U232_DATA_BITS_5; break;\n\tcase CS6:\n\t\tlast_lcr |= MCT_U232_DATA_BITS_6; break;\n\tcase CS7:\n\t\tlast_lcr |= MCT_U232_DATA_BITS_7; break;\n\tcase CS8:\n\t\tlast_lcr |= MCT_U232_DATA_BITS_8; break;\n\tdefault:\n\t\tdev_err(&port->dev,\n\t\t\t\"CSIZE was not CS5-CS8, using default of 8\\n\");\n\t\tlast_lcr |= MCT_U232_DATA_BITS_8;\n\t\tbreak;\n\t}\n\n\ttermios->c_cflag &= ~CMSPAR;\n\n\t \n\tlast_lcr |= (cflag & CSTOPB) ?\n\t\tMCT_U232_STOP_BITS_2 : MCT_U232_STOP_BITS_1;\n\n\tmct_u232_set_line_ctrl(port, last_lcr);\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->control_state = control_state;\n\tpriv->last_lcr = last_lcr;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n}  \n\nstatic int mct_u232_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned char lcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tlcr = priv->last_lcr;\n\n\tif (break_state)\n\t\tlcr |= MCT_U232_SET_BREAK;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn mct_u232_set_line_ctrl(port, lcr);\n}  \n\n\nstatic int mct_u232_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned int control_state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn control_state;\n}\n\nstatic int mct_u232_tiocmset(struct tty_struct *tty,\n\t\t\t      unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned int control_state;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol_state = priv->control_state;\n\n\tif (set & TIOCM_RTS)\n\t\tcontrol_state |= TIOCM_RTS;\n\tif (set & TIOCM_DTR)\n\t\tcontrol_state |= TIOCM_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tcontrol_state &= ~TIOCM_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tcontrol_state &= ~TIOCM_DTR;\n\n\tpriv->control_state = control_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\treturn mct_u232_set_modem_ctrl(port, control_state);\n}\n\nstatic void mct_u232_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned int control_state;\n\n\tspin_lock_irq(&priv->lock);\n\tpriv->rx_flags |= THROTTLED;\n\tif (C_CRTSCTS(tty)) {\n\t\tpriv->control_state &= ~TIOCM_RTS;\n\t\tcontrol_state = priv->control_state;\n\t\tspin_unlock_irq(&priv->lock);\n\t\tmct_u232_set_modem_ctrl(port, control_state);\n\t} else {\n\t\tspin_unlock_irq(&priv->lock);\n\t}\n}\n\nstatic void mct_u232_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mct_u232_private *priv = usb_get_serial_port_data(port);\n\tunsigned int control_state;\n\n\tspin_lock_irq(&priv->lock);\n\tif ((priv->rx_flags & THROTTLED) && C_CRTSCTS(tty)) {\n\t\tpriv->rx_flags &= ~THROTTLED;\n\t\tpriv->control_state |= TIOCM_RTS;\n\t\tcontrol_state = priv->control_state;\n\t\tspin_unlock_irq(&priv->lock);\n\t\tmct_u232_set_modem_ctrl(port, control_state);\n\t} else {\n\t\tspin_unlock_irq(&priv->lock);\n\t}\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}