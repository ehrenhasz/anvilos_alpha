{
  "module_name": "omninet.c",
  "hash_id": "f7d41869b6b529b200faf63ea90bab46e2e9401d78c4729c90953fd08ef68f90",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/omninet.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_AUTHOR \"Alessandro Zummo\"\n#define DRIVER_DESC \"USB ZyXEL omni.net Driver\"\n\n#define ZYXEL_VENDOR_ID\t\t0x0586\n#define ZYXEL_OMNINET_ID\t0x1000\n#define ZYXEL_OMNI_56K_PLUS_ID\t0x1500\n \n#define BT_IGNITIONPRO_ID\t0x2000\n\n \nstatic void omninet_process_read_urb(struct urb *urb);\nstatic int omninet_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\tvoid *buf, size_t count);\nstatic int omninet_calc_num_ports(struct usb_serial *serial,\n\t\t\t\tstruct usb_serial_endpoints *epds);\nstatic int omninet_port_probe(struct usb_serial_port *port);\nstatic void omninet_port_remove(struct usb_serial_port *port);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNINET_ID) },\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNI_56K_PLUS_ID) },\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, BT_IGNITIONPRO_ID) },\n\t{ }\t\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver zyxel_omninet_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"omninet\",\n\t},\n\t.description =\t\t\"ZyXEL - omni.net usb\",\n\t.id_table =\t\tid_table,\n\t.num_bulk_out =\t\t2,\n\t.calc_num_ports =\tomninet_calc_num_ports,\n\t.port_probe =\t\tomninet_port_probe,\n\t.port_remove =\t\tomninet_port_remove,\n\t.process_read_urb =\tomninet_process_read_urb,\n\t.prepare_write_buffer =\tomninet_prepare_write_buffer,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&zyxel_omninet_device, NULL\n};\n\n\n \nstruct omninet_header {\n\t__u8\toh_seq;\n\t__u8\toh_len;\n\t__u8\toh_xxx;\n\t__u8\toh_pad;\n};\n\nstruct omninet_data {\n\t__u8\tod_outseq;\t \n};\n\nstatic int omninet_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\t \n\tepds->bulk_out[0] = epds->bulk_out[1];\n\tepds->num_bulk_out = 1;\n\n\treturn 1;\n}\n\nstatic int omninet_port_probe(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = kzalloc(sizeof(*od), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, od);\n\n\treturn 0;\n}\n\nstatic void omninet_port_remove(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = usb_get_serial_port_data(port);\n\tkfree(od);\n}\n\n#define OMNINET_HEADERLEN\t4\n#define OMNINET_BULKOUTSIZE\t64\n#define OMNINET_PAYLOADSIZE\t(OMNINET_BULKOUTSIZE - OMNINET_HEADERLEN)\n\nstatic void omninet_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tconst struct omninet_header *hdr = urb->transfer_buffer;\n\tconst unsigned char *data;\n\tsize_t data_len;\n\n\tif (urb->actual_length <= OMNINET_HEADERLEN || !hdr->oh_len)\n\t\treturn;\n\n\tdata = (char *)urb->transfer_buffer + OMNINET_HEADERLEN;\n\tdata_len = min_t(size_t, urb->actual_length - OMNINET_HEADERLEN,\n\t\t\t\t\t\t\t\thdr->oh_len);\n\ttty_insert_flip_string(&port->port, data, data_len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int omninet_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\tvoid *buf, size_t count)\n{\n\tstruct omninet_data *od = usb_get_serial_port_data(port);\n\tstruct omninet_header *header = buf;\n\n\tcount = min_t(size_t, count, OMNINET_PAYLOADSIZE);\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + OMNINET_HEADERLEN,\n\t\t\tcount, &port->lock);\n\n\theader->oh_seq = od->od_outseq++;\n\theader->oh_len = count;\n\theader->oh_xxx = 0x03;\n\theader->oh_pad = 0x00;\n\n\t \n\treturn OMNINET_BULKOUTSIZE;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}