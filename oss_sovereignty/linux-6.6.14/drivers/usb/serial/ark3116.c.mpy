{
  "module_name": "ark3116.c",
  "hash_id": "c83acfbedcaf757199e1e7800ac2370978c0be4ff682cea05b99c3ceab571a3a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ark3116.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/ioctl.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n#include <linux/spinlock.h>\n\n#define DRIVER_AUTHOR \"Bart Hartgers <bart.hartgers+ark3116@gmail.com>\"\n#define DRIVER_DESC \"USB ARK3116 serial/IrDA driver\"\n#define DRIVER_DEV_DESC \"ARK3116 RS232/IrDA\"\n#define DRIVER_NAME \"ark3116\"\n\n \n#define ARK_TIMEOUT 1000\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x6547, 0x0232) },\n\t{ USB_DEVICE(0x18ec, 0x3118) },\t\t \n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic int is_irda(struct usb_serial *serial)\n{\n\tstruct usb_device *dev = serial->dev;\n\tif (le16_to_cpu(dev->descriptor.idVendor) == 0x18ec &&\n\t\t\tle16_to_cpu(dev->descriptor.idProduct) == 0x3118)\n\t\treturn 1;\n\treturn 0;\n}\n\nstruct ark3116_private {\n\tint\t\t\tirda;\t \n\n\t \n\tstruct mutex\t\thw_lock;\n\n\tint\t\t\tquot;\t \n\t__u32\t\t\tlcr;\t \n\t__u32\t\t\thcr;\t \n\t__u32\t\t\tmcr;\t \n\n\t \n\tspinlock_t\t\tstatus_lock;\n\t__u32\t\t\tmsr;\t \n\t__u32\t\t\tlsr;\t \n};\n\nstatic int ark3116_write_reg(struct usb_serial *serial,\n\t\t\t     unsigned reg, __u8 val)\n{\n\tint result;\n\t  \n\tresult = usb_control_msg(serial->dev,\n\t\t\t\t usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t 0xfe, 0x40, val, reg,\n\t\t\t\t NULL, 0, ARK_TIMEOUT);\n\tif (result)\n\t\treturn result;\n\n\treturn 0;\n}\n\nstatic int ark3116_read_reg(struct usb_serial *serial,\n\t\t\t    unsigned reg, unsigned char *buf)\n{\n\tint result;\n\t \n\tresult = usb_control_msg(serial->dev,\n\t\t\t\t usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t 0xfe, 0xc0, 0, reg,\n\t\t\t\t buf, 1, ARK_TIMEOUT);\n\tif (result < 1) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\t\"failed to read register %u: %d\\n\",\n\t\t\t\treg, result);\n\t\tif (result >= 0)\n\t\t\tresult = -EIO;\n\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int calc_divisor(int bps)\n{\n\t \n\treturn (12000000 + 2*bps) / (4*bps);\n}\n\nstatic int ark3116_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct ark3116_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->hw_lock);\n\tspin_lock_init(&priv->status_lock);\n\n\tpriv->irda = is_irda(serial);\n\n\tusb_set_serial_port_data(port, priv);\n\n\t \n\tark3116_write_reg(serial, UART_IER, 0);\n\t \n\tark3116_write_reg(serial, UART_FCR, 0);\n\t \n\tpriv->hcr = 0;\n\tark3116_write_reg(serial, 0x8     , 0);\n\t \n\tpriv->mcr = 0;\n\tark3116_write_reg(serial, UART_MCR, 0);\n\n\tif (!(priv->irda)) {\n\t\tark3116_write_reg(serial, 0xb , 0);\n\t} else {\n\t\tark3116_write_reg(serial, 0xb , 1);\n\t\tark3116_write_reg(serial, 0xc , 0);\n\t\tark3116_write_reg(serial, 0xd , 0x41);\n\t\tark3116_write_reg(serial, 0xa , 1);\n\t}\n\n\t \n\tark3116_write_reg(serial, UART_LCR, UART_LCR_DLAB);\n\n\t \n\tpriv->quot = calc_divisor(9600);\n\tark3116_write_reg(serial, UART_DLL, priv->quot & 0xff);\n\tark3116_write_reg(serial, UART_DLM, (priv->quot>>8) & 0xff);\n\n\tpriv->lcr = UART_LCR_WLEN8;\n\tark3116_write_reg(serial, UART_LCR, UART_LCR_WLEN8);\n\n\tark3116_write_reg(serial, 0xe, 0);\n\n\tif (priv->irda)\n\t\tark3116_write_reg(serial, 0x9, 0);\n\n\tdev_info(&port->dev, \"using %s mode\\n\", priv->irda ? \"IrDA\" : \"RS232\");\n\n\treturn 0;\n}\n\nstatic void ark3116_port_remove(struct usb_serial_port *port)\n{\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\n\t \n\tmutex_destroy(&priv->hw_lock);\n\tkfree(priv);\n}\n\nstatic void ark3116_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tstruct ktermios *termios = &tty->termios;\n\tunsigned int cflag = termios->c_cflag;\n\tint bps = tty_get_baud_rate(tty);\n\tint quot;\n\t__u8 lcr, hcr, eval;\n\n\t \n\tlcr = UART_LCR_WLEN(tty_get_char_size(cflag));\n\n\tif (cflag & CSTOPB)\n\t\tlcr |= UART_LCR_STOP;\n\tif (cflag & PARENB)\n\t\tlcr |= UART_LCR_PARITY;\n\tif (!(cflag & PARODD))\n\t\tlcr |= UART_LCR_EPAR;\n\tif (cflag & CMSPAR)\n\t\tlcr |= UART_LCR_SPAR;\n\n\t \n\thcr = (cflag & CRTSCTS) ? 0x03 : 0x00;\n\n\t \n\tdev_dbg(&port->dev, \"%s - setting bps to %d\\n\", __func__, bps);\n\teval = 0;\n\tswitch (bps) {\n\tcase 0:\n\t\tquot = calc_divisor(9600);\n\t\tbreak;\n\tdefault:\n\t\tif ((bps < 75) || (bps > 3000000))\n\t\t\tbps = 9600;\n\t\tquot = calc_divisor(bps);\n\t\tbreak;\n\tcase 460800:\n\t\teval = 1;\n\t\tquot = calc_divisor(bps);\n\t\tbreak;\n\tcase 921600:\n\t\teval = 2;\n\t\tquot = calc_divisor(bps);\n\t\tbreak;\n\t}\n\n\t \n\tmutex_lock(&priv->hw_lock);\n\n\t \n\tlcr |= (priv->lcr & UART_LCR_SBC);\n\n\tdev_dbg(&port->dev, \"%s - setting hcr:0x%02x,lcr:0x%02x,quot:%d\\n\",\n\t\t__func__, hcr, lcr, quot);\n\n\t \n\tif (priv->hcr != hcr) {\n\t\tpriv->hcr = hcr;\n\t\tark3116_write_reg(serial, 0x8, hcr);\n\t}\n\n\t \n\tif (priv->quot != quot) {\n\t\tpriv->quot = quot;\n\t\tpriv->lcr = lcr;  \n\n\t\t \n\t\tark3116_write_reg(serial, UART_FCR, 0);\n\n\t\tark3116_write_reg(serial, UART_LCR,\n\t\t\t\t  lcr|UART_LCR_DLAB);\n\t\tark3116_write_reg(serial, UART_DLL, quot & 0xff);\n\t\tark3116_write_reg(serial, UART_DLM, (quot>>8) & 0xff);\n\n\t\t \n\t\tark3116_write_reg(serial, UART_LCR, lcr);\n\t\t \n\t\tark3116_write_reg(serial, 0xe, eval);\n\n\t\t \n\t\tark3116_write_reg(serial, UART_FCR, UART_FCR_DMA_SELECT);\n\t} else if (priv->lcr != lcr) {\n\t\tpriv->lcr = lcr;\n\t\tark3116_write_reg(serial, UART_LCR, lcr);\n\t}\n\n\tmutex_unlock(&priv->hw_lock);\n\n\t \n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tdev_warn(&port->dev,\n\t\t\t\t\"software flow control not implemented\\n\");\n\t}\n\n\t \n\tif (tty_termios_baud_rate(termios))\n\t\ttty_termios_encode_baud_rate(termios, bps, bps);\n}\n\nstatic void ark3116_close(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\n\t \n\tark3116_write_reg(serial, UART_FCR, 0);\n\n\t \n\tark3116_write_reg(serial, UART_IER, 0);\n\n\tusb_serial_generic_close(port);\n\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic int ark3116_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned char *buf;\n\tint result;\n\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result) {\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - usb_serial_generic_open failed: %d\\n\",\n\t\t\t__func__, result);\n\t\tgoto err_free;\n\t}\n\n\t \n\tark3116_read_reg(serial, UART_RX, buf);\n\n\t \n\tresult = ark3116_read_reg(serial, UART_MSR, buf);\n\tif (result)\n\t\tgoto err_close;\n\tpriv->msr = *buf;\n\n\t \n\tresult = ark3116_read_reg(serial, UART_LSR, buf);\n\tif (result)\n\t\tgoto err_close;\n\tpriv->lsr = *buf;\n\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"submit irq_in urb failed %d\\n\",\n\t\t\tresult);\n\t\tgoto err_close;\n\t}\n\n\t \n\tark3116_write_reg(port->serial, UART_IER, UART_IER_MSI|UART_IER_RLSI);\n\n\t \n\tark3116_write_reg(port->serial, UART_FCR, UART_FCR_DMA_SELECT);\n\n\t \n\tif (tty)\n\t\tark3116_set_termios(tty, port, NULL);\n\n\tkfree(buf);\n\n\treturn 0;\n\nerr_close:\n\tusb_serial_generic_close(port);\nerr_free:\n\tkfree(buf);\n\n\treturn result;\n}\n\nstatic int ark3116_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\t__u32 status;\n\t__u32 ctrl;\n\tunsigned long flags;\n\n\tmutex_lock(&priv->hw_lock);\n\tctrl = priv->mcr;\n\tmutex_unlock(&priv->hw_lock);\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tstatus = priv->msr;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\treturn  (status & UART_MSR_DSR  ? TIOCM_DSR  : 0) |\n\t\t(status & UART_MSR_CTS  ? TIOCM_CTS  : 0) |\n\t\t(status & UART_MSR_RI   ? TIOCM_RI   : 0) |\n\t\t(status & UART_MSR_DCD  ? TIOCM_CD   : 0) |\n\t\t(ctrl   & UART_MCR_DTR  ? TIOCM_DTR  : 0) |\n\t\t(ctrl   & UART_MCR_RTS  ? TIOCM_RTS  : 0) |\n\t\t(ctrl   & UART_MCR_OUT1 ? TIOCM_OUT1 : 0) |\n\t\t(ctrl   & UART_MCR_OUT2 ? TIOCM_OUT2 : 0);\n}\n\nstatic int ark3116_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned set, unsigned clr)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\n\t \n\n\tmutex_lock(&priv->hw_lock);\n\n\tif (set & TIOCM_RTS)\n\t\tpriv->mcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tpriv->mcr |= UART_MCR_DTR;\n\tif (set & TIOCM_OUT1)\n\t\tpriv->mcr |= UART_MCR_OUT1;\n\tif (set & TIOCM_OUT2)\n\t\tpriv->mcr |= UART_MCR_OUT2;\n\tif (clr & TIOCM_RTS)\n\t\tpriv->mcr &= ~UART_MCR_RTS;\n\tif (clr & TIOCM_DTR)\n\t\tpriv->mcr &= ~UART_MCR_DTR;\n\tif (clr & TIOCM_OUT1)\n\t\tpriv->mcr &= ~UART_MCR_OUT1;\n\tif (clr & TIOCM_OUT2)\n\t\tpriv->mcr &= ~UART_MCR_OUT2;\n\n\tark3116_write_reg(port->serial, UART_MCR, priv->mcr);\n\n\tmutex_unlock(&priv->hw_lock);\n\n\treturn 0;\n}\n\nstatic int ark3116_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tint ret;\n\n\t \n\tmutex_lock(&priv->hw_lock);\n\n\tif (break_state)\n\t\tpriv->lcr |= UART_LCR_SBC;\n\telse\n\t\tpriv->lcr &= ~UART_LCR_SBC;\n\n\tret = ark3116_write_reg(port->serial, UART_LCR, priv->lcr);\n\n\tmutex_unlock(&priv->hw_lock);\n\n\treturn ret;\n}\n\nstatic void ark3116_update_msr(struct usb_serial_port *port, __u8 msr)\n{\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tpriv->msr = msr;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\tif (msr & UART_MSR_ANY_DELTA) {\n\t\t \n\t\tif (msr & UART_MSR_DCTS)\n\t\t\tport->icount.cts++;\n\t\tif (msr & UART_MSR_DDSR)\n\t\t\tport->icount.dsr++;\n\t\tif (msr & UART_MSR_DDCD)\n\t\t\tport->icount.dcd++;\n\t\tif (msr & UART_MSR_TERI)\n\t\t\tport->icount.rng++;\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t}\n}\n\nstatic void ark3116_update_lsr(struct usb_serial_port *port, __u8 lsr)\n{\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\t \n\tpriv->lsr |= lsr;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\tif (lsr&UART_LSR_BRK_ERROR_BITS) {\n\t\tif (lsr & UART_LSR_BI)\n\t\t\tport->icount.brk++;\n\t\tif (lsr & UART_LSR_FE)\n\t\t\tport->icount.frame++;\n\t\tif (lsr & UART_LSR_PE)\n\t\t\tport->icount.parity++;\n\t\tif (lsr & UART_LSR_OE)\n\t\t\tport->icount.overrun++;\n\t}\n}\n\nstatic void ark3116_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tconst __u8 *data = urb->transfer_buffer;\n\tint result;\n\n\tswitch (status) {\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tbreak;\n\tcase 0:  \n\t\t \n\t\tif ((urb->actual_length == 4) && (data[0] == 0xe8)) {\n\t\t\tconst __u8 id = data[1]&UART_IIR_ID;\n\t\t\tdev_dbg(&port->dev, \"%s: iir=%02x\\n\", __func__, data[1]);\n\t\t\tif (id == UART_IIR_MSI) {\n\t\t\t\tdev_dbg(&port->dev, \"%s: msr=%02x\\n\",\n\t\t\t\t\t__func__, data[3]);\n\t\t\t\tark3116_update_msr(port, data[3]);\n\t\t\t\tbreak;\n\t\t\t} else if (id == UART_IIR_RLSI) {\n\t\t\t\tdev_dbg(&port->dev, \"%s: lsr=%02x\\n\",\n\t\t\t\t\t__func__, data[2]);\n\t\t\t\tark3116_update_lsr(port, data[2]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tusb_serial_debug_data(&port->dev, __func__,\n\t\t\t\t      urb->actual_length,\n\t\t\t\t      urb->transfer_buffer);\n\t\tbreak;\n\t}\n\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&port->dev, \"failed to resubmit interrupt urb: %d\\n\",\n\t\t\tresult);\n}\n\n\n \nstatic void ark3116_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct ark3116_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tchar tty_flag = TTY_NORMAL;\n\tunsigned long flags;\n\t__u32 lsr;\n\n\t \n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tlsr = priv->lsr;\n\tpriv->lsr &= ~UART_LSR_BRK_ERROR_BITS;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (lsr & UART_LSR_BRK_ERROR_BITS) {\n\t\tif (lsr & UART_LSR_BI)\n\t\t\ttty_flag = TTY_BREAK;\n\t\telse if (lsr & UART_LSR_PE)\n\t\t\ttty_flag = TTY_PARITY;\n\t\telse if (lsr & UART_LSR_FE)\n\t\t\ttty_flag = TTY_FRAME;\n\n\t\t \n\t\tif (lsr & UART_LSR_OE)\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t}\n\ttty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\n\t\t\t\t\t\t\turb->actual_length);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic struct usb_serial_driver ark3116_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"ark3116\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_bulk_in =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.num_interrupt_in =\t1,\n\t.port_probe =\t\tark3116_port_probe,\n\t.port_remove =\t\tark3116_port_remove,\n\t.set_termios =\t\tark3116_set_termios,\n\t.tiocmget =\t\tark3116_tiocmget,\n\t.tiocmset =\t\tark3116_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.get_icount =\t\tusb_serial_generic_get_icount,\n\t.open =\t\t\tark3116_open,\n\t.close =\t\tark3116_close,\n\t.break_ctl = \t\tark3116_break_ctl,\n\t.read_int_callback = \tark3116_read_int_callback,\n\t.process_read_urb =\tark3116_process_read_urb,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ark3116_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_LICENSE(\"GPL\");\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}