{
  "module_name": "ti_usb_3410_5052.c",
  "hash_id": "052c5a8bff1b8d635bf77321d2f75706b87fa364d170becf01ffd7b3945f0b1d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ti_usb_3410_5052.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/firmware.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/ioctl.h>\n#include <linux/serial.h>\n#include <linux/kfifo.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n \n#define TI_BOOT_CONFIG\t\t\t1\n#define TI_ACTIVE_CONFIG\t\t2\n\n \n#define TI_VENDOR_ID\t\t\t0x0451\n#define IBM_VENDOR_ID\t\t\t0x04b3\n#define STARTECH_VENDOR_ID\t\t0x14b0\n#define TI_3410_PRODUCT_ID\t\t0x3410\n#define IBM_4543_PRODUCT_ID\t\t0x4543\n#define IBM_454B_PRODUCT_ID\t\t0x454b\n#define IBM_454C_PRODUCT_ID\t\t0x454c\n#define TI_3410_EZ430_ID\t\t0xF430   \n#define TI_5052_BOOT_PRODUCT_ID\t\t0x5052\t \n#define TI_5152_BOOT_PRODUCT_ID\t\t0x5152\t \n#define TI_5052_EEPROM_PRODUCT_ID\t0x505A\t \n#define TI_5052_FIRMWARE_PRODUCT_ID\t0x505F\t \n#define FRI2_PRODUCT_ID\t\t\t0x5053   \n\n \n#define MTS_VENDOR_ID\t\t\t0x06E0\n#define MTS_GSM_NO_FW_PRODUCT_ID\t0xF108\n#define MTS_CDMA_NO_FW_PRODUCT_ID\t0xF109\n#define MTS_CDMA_PRODUCT_ID\t\t0xF110\n#define MTS_GSM_PRODUCT_ID\t\t0xF111\n#define MTS_EDGE_PRODUCT_ID\t\t0xF112\n#define MTS_MT9234MU_PRODUCT_ID\t\t0xF114\n#define MTS_MT9234ZBA_PRODUCT_ID\t0xF115\n#define MTS_MT9234ZBAOLD_PRODUCT_ID\t0x0319\n\n \n#define ABBOTT_VENDOR_ID\t\t0x1a61\n#define ABBOTT_STEREO_PLUG_ID\t\t0x3410\n#define ABBOTT_PRODUCT_ID\t\tABBOTT_STEREO_PLUG_ID\n#define ABBOTT_STRIP_PORT_ID\t\t0x3420\n\n \n#define HONEYWELL_VENDOR_ID\t\t0x10ac\n#define HONEYWELL_HGI80_PRODUCT_ID\t0x0102   \n\n \n#define MXU1_VENDOR_ID\t\t\t\t0x110a\n#define MXU1_1110_PRODUCT_ID\t\t\t0x1110\n#define MXU1_1130_PRODUCT_ID\t\t\t0x1130\n#define MXU1_1150_PRODUCT_ID\t\t\t0x1150\n#define MXU1_1151_PRODUCT_ID\t\t\t0x1151\n#define MXU1_1131_PRODUCT_ID\t\t\t0x1131\n\n \n#define TI_GET_VERSION\t\t\t0x01\n#define TI_GET_PORT_STATUS\t\t0x02\n#define TI_GET_PORT_DEV_INFO\t\t0x03\n#define TI_GET_CONFIG\t\t\t0x04\n#define TI_SET_CONFIG\t\t\t0x05\n#define TI_OPEN_PORT\t\t\t0x06\n#define TI_CLOSE_PORT\t\t\t0x07\n#define TI_START_PORT\t\t\t0x08\n#define TI_STOP_PORT\t\t\t0x09\n#define TI_TEST_PORT\t\t\t0x0A\n#define TI_PURGE_PORT\t\t\t0x0B\n#define TI_RESET_EXT_DEVICE\t\t0x0C\n#define TI_WRITE_DATA\t\t\t0x80\n#define TI_READ_DATA\t\t\t0x81\n#define TI_REQ_TYPE_CLASS\t\t0x82\n\n \n#define TI_I2C_PORT\t\t\t0x01\n#define TI_IEEE1284_PORT\t\t0x02\n#define TI_UART1_PORT\t\t\t0x03\n#define TI_UART2_PORT\t\t\t0x04\n#define TI_RAM_PORT\t\t\t0x05\n\n \n#define TI_MSR_DELTA_CTS\t\t0x01\n#define TI_MSR_DELTA_DSR\t\t0x02\n#define TI_MSR_DELTA_RI\t\t\t0x04\n#define TI_MSR_DELTA_CD\t\t\t0x08\n#define TI_MSR_CTS\t\t\t0x10\n#define TI_MSR_DSR\t\t\t0x20\n#define TI_MSR_RI\t\t\t0x40\n#define TI_MSR_CD\t\t\t0x80\n#define TI_MSR_DELTA_MASK\t\t0x0F\n#define TI_MSR_MASK\t\t\t0xF0\n\n \n#define TI_LSR_OVERRUN_ERROR\t\t0x01\n#define TI_LSR_PARITY_ERROR\t\t0x02\n#define TI_LSR_FRAMING_ERROR\t\t0x04\n#define TI_LSR_BREAK\t\t\t0x08\n#define TI_LSR_ERROR\t\t\t0x0F\n#define TI_LSR_RX_FULL\t\t\t0x10\n#define TI_LSR_TX_EMPTY\t\t\t0x20\n#define TI_LSR_TX_EMPTY_BOTH\t\t0x40\n\n \n#define TI_LCR_BREAK\t\t\t0x40\n\n \n#define TI_MCR_LOOP\t\t\t0x04\n#define TI_MCR_DTR\t\t\t0x10\n#define TI_MCR_RTS\t\t\t0x20\n\n \n#define TI_UART_ENABLE_RTS_IN\t\t0x0001\n#define TI_UART_DISABLE_RTS\t\t0x0002\n#define TI_UART_ENABLE_PARITY_CHECKING\t0x0008\n#define TI_UART_ENABLE_DSR_OUT\t\t0x0010\n#define TI_UART_ENABLE_CTS_OUT\t\t0x0020\n#define TI_UART_ENABLE_X_OUT\t\t0x0040\n#define TI_UART_ENABLE_XA_OUT\t\t0x0080\n#define TI_UART_ENABLE_X_IN\t\t0x0100\n#define TI_UART_ENABLE_DTR_IN\t\t0x0800\n#define TI_UART_DISABLE_DTR\t\t0x1000\n#define TI_UART_ENABLE_MS_INTS\t\t0x2000\n#define TI_UART_ENABLE_AUTO_START_DMA\t0x4000\n\n \n#define TI_UART_NO_PARITY\t\t0x00\n#define TI_UART_ODD_PARITY\t\t0x01\n#define TI_UART_EVEN_PARITY\t\t0x02\n#define TI_UART_MARK_PARITY\t\t0x03\n#define TI_UART_SPACE_PARITY\t\t0x04\n\n \n#define TI_UART_1_STOP_BITS\t\t0x00\n#define TI_UART_1_5_STOP_BITS\t\t0x01\n#define TI_UART_2_STOP_BITS\t\t0x02\n\n \n#define TI_UART_5_DATA_BITS\t\t0x00\n#define TI_UART_6_DATA_BITS\t\t0x01\n#define TI_UART_7_DATA_BITS\t\t0x02\n#define TI_UART_8_DATA_BITS\t\t0x03\n\n \n#define TI_UART_232\t\t\t0x00\n#define TI_UART_485_RECEIVER_DISABLED\t0x01\n#define TI_UART_485_RECEIVER_ENABLED\t0x02\n\n \n#define TI_PIPE_MODE_CONTINUOUS\t\t0x01\n#define TI_PIPE_MODE_MASK\t\t0x03\n#define TI_PIPE_TIMEOUT_MASK\t\t0x7C\n#define TI_PIPE_TIMEOUT_ENABLE\t\t0x80\n\n \nstruct ti_uart_config {\n\t__be16\twBaudRate;\n\t__be16\twFlags;\n\tu8\tbDataBits;\n\tu8\tbParity;\n\tu8\tbStopBits;\n\tchar\tcXon;\n\tchar\tcXoff;\n\tu8\tbUartMode;\n};\n\n \nstruct ti_port_status {\n\tu8 bCmdCode;\n\tu8 bModuleId;\n\tu8 bErrorCode;\n\tu8 bMSR;\n\tu8 bLSR;\n};\n\n \n#define TI_PURGE_OUTPUT\t\t\t0x00\n#define TI_PURGE_INPUT\t\t\t0x80\n\n \n#define TI_RW_DATA_ADDR_SFR\t\t0x10\n#define TI_RW_DATA_ADDR_IDATA\t\t0x20\n#define TI_RW_DATA_ADDR_XDATA\t\t0x30\n#define TI_RW_DATA_ADDR_CODE\t\t0x40\n#define TI_RW_DATA_ADDR_GPIO\t\t0x50\n#define TI_RW_DATA_ADDR_I2C\t\t0x60\n#define TI_RW_DATA_ADDR_FLASH\t\t0x70\n#define TI_RW_DATA_ADDR_DSP\t\t0x80\n\n#define TI_RW_DATA_UNSPECIFIED\t\t0x00\n#define TI_RW_DATA_BYTE\t\t\t0x01\n#define TI_RW_DATA_WORD\t\t\t0x02\n#define TI_RW_DATA_DOUBLE_WORD\t\t0x04\n\nstruct ti_write_data_bytes {\n\tu8\tbAddrType;\n\tu8\tbDataType;\n\tu8\tbDataCounter;\n\t__be16\twBaseAddrHi;\n\t__be16\twBaseAddrLo;\n\tu8\tbData[];\n} __packed;\n\nstruct ti_read_data_request {\n\tu8\tbAddrType;\n\tu8\tbDataType;\n\tu8\tbDataCounter;\n\t__be16\twBaseAddrHi;\n\t__be16\twBaseAddrLo;\n} __packed;\n\nstruct ti_read_data_bytes {\n\tu8\tbCmdCode;\n\tu8\tbModuleId;\n\tu8\tbErrorCode;\n\tu8\tbData[];\n};\n\n \nstruct ti_interrupt {\n\tu8\tbICode;\n\tu8\tbIInfo;\n};\n\n \n#define TI_CODE_HARDWARE_ERROR\t\t0xFF\n#define TI_CODE_DATA_ERROR\t\t0x03\n#define TI_CODE_MODEM_STATUS\t\t0x04\n\n \n#define TI_DOWNLOAD_MAX_PACKET_SIZE\t64\n\n \nstruct ti_firmware_header {\n\t__le16\twLength;\n\tu8\tbCheckSum;\n} __packed;\n\n \n#define TI_UART1_BASE_ADDR\t\t0xFFA0\t \n#define TI_UART2_BASE_ADDR\t\t0xFFB0\t \n#define TI_UART_OFFSET_LCR\t\t0x0002\t \n#define TI_UART_OFFSET_MCR\t\t0x0004\t \n\n#define TI_DRIVER_AUTHOR\t\"Al Borchers <alborchers@steinerpoint.com>\"\n#define TI_DRIVER_DESC\t\t\"TI USB 3410/5052 Serial Driver\"\n\n#define TI_FIRMWARE_BUF_SIZE\t16284\n\n#define TI_TRANSFER_TIMEOUT\t2\n\n \n#define TI_READ_URB_RUNNING\t0\n#define TI_READ_URB_STOPPING\t1\n#define TI_READ_URB_STOPPED\t2\n\n#define TI_EXTRA_VID_PID_COUNT\t5\n\nstruct ti_port {\n\tint\t\t\ttp_is_open;\n\tu8\t\t\ttp_msr;\n\tu8\t\t\ttp_shadow_mcr;\n\tu8\t\t\ttp_uart_mode;\t \n\tunsigned int\t\ttp_uart_base_addr;\n\tstruct ti_device\t*tp_tdev;\n\tstruct usb_serial_port\t*tp_port;\n\tspinlock_t\t\ttp_lock;\n\tint\t\t\ttp_read_urb_state;\n\tint\t\t\ttp_write_urb_in_use;\n};\n\nstruct ti_device {\n\tstruct mutex\t\ttd_open_close_lock;\n\tint\t\t\ttd_open_port_count;\n\tstruct usb_serial\t*td_serial;\n\tint\t\t\ttd_is_3410;\n\tbool\t\t\ttd_rs485_only;\n};\n\nstatic int ti_startup(struct usb_serial *serial);\nstatic void ti_release(struct usb_serial *serial);\nstatic int ti_port_probe(struct usb_serial_port *port);\nstatic void ti_port_remove(struct usb_serial_port *port);\nstatic int ti_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void ti_close(struct usb_serial_port *port);\nstatic int ti_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\tconst unsigned char *data, int count);\nstatic unsigned int ti_write_room(struct tty_struct *tty);\nstatic unsigned int ti_chars_in_buffer(struct tty_struct *tty);\nstatic bool ti_tx_empty(struct usb_serial_port *port);\nstatic void ti_throttle(struct tty_struct *tty);\nstatic void ti_unthrottle(struct tty_struct *tty);\nstatic void ti_set_termios(struct tty_struct *tty,\n\t\t\t   struct usb_serial_port *port,\n\t\t\t   const struct ktermios *old_termios);\nstatic int ti_tiocmget(struct tty_struct *tty);\nstatic int ti_tiocmset(struct tty_struct *tty,\n\t\tunsigned int set, unsigned int clear);\nstatic int ti_break(struct tty_struct *tty, int break_state);\nstatic void ti_interrupt_callback(struct urb *urb);\nstatic void ti_bulk_in_callback(struct urb *urb);\nstatic void ti_bulk_out_callback(struct urb *urb);\n\nstatic void ti_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length);\nstatic void ti_send(struct ti_port *tport);\nstatic int ti_set_mcr(struct ti_port *tport, unsigned int mcr);\nstatic int ti_get_lsr(struct ti_port *tport, u8 *lsr);\nstatic void ti_get_serial_info(struct tty_struct *tty, struct serial_struct *ss);\nstatic void ti_handle_new_msr(struct ti_port *tport, u8 msr);\n\nstatic void ti_stop_read(struct ti_port *tport, struct tty_struct *tty);\nstatic int ti_restart_read(struct ti_port *tport, struct tty_struct *tty);\n\nstatic int ti_command_out_sync(struct usb_device *udev, u8 command,\n\t\tu16 moduleid, u16 value, void *data, int size);\nstatic int ti_command_in_sync(struct usb_device *udev, u8 command,\n\t\tu16 moduleid, u16 value, void *data, int size);\nstatic int ti_port_cmd_out(struct usb_serial_port *port, u8 command,\n\t\tu16 value, void *data, int size);\nstatic int ti_port_cmd_in(struct usb_serial_port *port, u8 command,\n\t\tu16 value, void *data, int size);\n\nstatic int ti_write_byte(struct usb_serial_port *port, struct ti_device *tdev,\n\t\t\t unsigned long addr, u8 mask, u8 byte);\n\nstatic int ti_download_firmware(struct ti_device *tdev);\n\nstatic const struct usb_device_id ti_id_table_3410[] = {\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_CDMA_NO_FW_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_CDMA_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_EDGE_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234MU_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234ZBA_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234ZBAOLD_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_4543_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_454B_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_454C_PRODUCT_ID) },\n\t{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STEREO_PLUG_ID) },\n\t{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },\n\t{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1110_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1130_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1131_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1150_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1151_PRODUCT_ID) },\n\t{ USB_DEVICE(STARTECH_VENDOR_ID, TI_3410_PRODUCT_ID) },\n\t{ }\t \n};\n\nstatic const struct usb_device_id ti_id_table_5052[] = {\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_BOOT_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5152_BOOT_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_EEPROM_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_FIRMWARE_PRODUCT_ID) },\n\t{ }\n};\n\nstatic const struct usb_device_id ti_id_table_combined[] = {\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_CDMA_NO_FW_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_CDMA_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_EDGE_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234MU_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234ZBA_PRODUCT_ID) },\n\t{ USB_DEVICE(MTS_VENDOR_ID, MTS_MT9234ZBAOLD_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_BOOT_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5152_BOOT_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_EEPROM_PRODUCT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, TI_5052_FIRMWARE_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_4543_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_454B_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_454C_PRODUCT_ID) },\n\t{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_PRODUCT_ID) },\n\t{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },\n\t{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },\n\t{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1110_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1130_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1131_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1150_PRODUCT_ID) },\n\t{ USB_DEVICE(MXU1_VENDOR_ID, MXU1_1151_PRODUCT_ID) },\n\t{ USB_DEVICE(STARTECH_VENDOR_ID, TI_3410_PRODUCT_ID) },\n\t{ }\t \n};\n\nstatic struct usb_serial_driver ti_1port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"ti_usb_3410_5052_1\",\n\t},\n\t.description\t\t= \"TI USB 3410 1 port adapter\",\n\t.id_table\t\t= ti_id_table_3410,\n\t.num_ports\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.attach\t\t\t= ti_startup,\n\t.release\t\t= ti_release,\n\t.port_probe\t\t= ti_port_probe,\n\t.port_remove\t\t= ti_port_remove,\n\t.open\t\t\t= ti_open,\n\t.close\t\t\t= ti_close,\n\t.write\t\t\t= ti_write,\n\t.write_room\t\t= ti_write_room,\n\t.chars_in_buffer\t= ti_chars_in_buffer,\n\t.tx_empty\t\t= ti_tx_empty,\n\t.throttle\t\t= ti_throttle,\n\t.unthrottle\t\t= ti_unthrottle,\n\t.get_serial\t\t= ti_get_serial_info,\n\t.set_termios\t\t= ti_set_termios,\n\t.tiocmget\t\t= ti_tiocmget,\n\t.tiocmset\t\t= ti_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.break_ctl\t\t= ti_break,\n\t.read_int_callback\t= ti_interrupt_callback,\n\t.read_bulk_callback\t= ti_bulk_in_callback,\n\t.write_bulk_callback\t= ti_bulk_out_callback,\n};\n\nstatic struct usb_serial_driver ti_2port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"ti_usb_3410_5052_2\",\n\t},\n\t.description\t\t= \"TI USB 5052 2 port adapter\",\n\t.id_table\t\t= ti_id_table_5052,\n\t.num_ports\t\t= 2,\n\t.num_bulk_out\t\t= 1,\n\t.attach\t\t\t= ti_startup,\n\t.release\t\t= ti_release,\n\t.port_probe\t\t= ti_port_probe,\n\t.port_remove\t\t= ti_port_remove,\n\t.open\t\t\t= ti_open,\n\t.close\t\t\t= ti_close,\n\t.write\t\t\t= ti_write,\n\t.write_room\t\t= ti_write_room,\n\t.chars_in_buffer\t= ti_chars_in_buffer,\n\t.tx_empty\t\t= ti_tx_empty,\n\t.throttle\t\t= ti_throttle,\n\t.unthrottle\t\t= ti_unthrottle,\n\t.get_serial\t\t= ti_get_serial_info,\n\t.set_termios\t\t= ti_set_termios,\n\t.tiocmget\t\t= ti_tiocmget,\n\t.tiocmset\t\t= ti_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.break_ctl\t\t= ti_break,\n\t.read_int_callback\t= ti_interrupt_callback,\n\t.read_bulk_callback\t= ti_bulk_in_callback,\n\t.write_bulk_callback\t= ti_bulk_out_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ti_1port_device, &ti_2port_device, NULL\n};\n\nMODULE_AUTHOR(TI_DRIVER_AUTHOR);\nMODULE_DESCRIPTION(TI_DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"ti_3410.fw\");\nMODULE_FIRMWARE(\"ti_5052.fw\");\nMODULE_FIRMWARE(\"mts_cdma.fw\");\nMODULE_FIRMWARE(\"mts_gsm.fw\");\nMODULE_FIRMWARE(\"mts_edge.fw\");\nMODULE_FIRMWARE(\"mts_mt9234mu.fw\");\nMODULE_FIRMWARE(\"mts_mt9234zba.fw\");\nMODULE_FIRMWARE(\"moxa/moxa-1110.fw\");\nMODULE_FIRMWARE(\"moxa/moxa-1130.fw\");\nMODULE_FIRMWARE(\"moxa/moxa-1131.fw\");\nMODULE_FIRMWARE(\"moxa/moxa-1150.fw\");\nMODULE_FIRMWARE(\"moxa/moxa-1151.fw\");\n\nMODULE_DEVICE_TABLE(usb, ti_id_table_combined);\n\nmodule_usb_serial_driver(serial_drivers, ti_id_table_combined);\n\nstatic int ti_startup(struct usb_serial *serial)\n{\n\tstruct ti_device *tdev;\n\tstruct usb_device *dev = serial->dev;\n\tstruct usb_host_interface *cur_altsetting;\n\tint num_endpoints;\n\tu16 vid, pid;\n\tint status;\n\n\tdev_dbg(&dev->dev,\n\t\t\"%s - product 0x%4X, num configurations %d, configuration value %d\\n\",\n\t\t__func__, le16_to_cpu(dev->descriptor.idProduct),\n\t\tdev->descriptor.bNumConfigurations,\n\t\tdev->actconfig->desc.bConfigurationValue);\n\n\ttdev = kzalloc(sizeof(struct ti_device), GFP_KERNEL);\n\tif (!tdev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&tdev->td_open_close_lock);\n\ttdev->td_serial = serial;\n\tusb_set_serial_data(serial, tdev);\n\n\t \n\tif (serial->type == &ti_1port_device)\n\t\ttdev->td_is_3410 = 1;\n\tdev_dbg(&dev->dev, \"%s - device type is %s\\n\", __func__,\n\t\ttdev->td_is_3410 ? \"3410\" : \"5052\");\n\n\tvid = le16_to_cpu(dev->descriptor.idVendor);\n\tpid = le16_to_cpu(dev->descriptor.idProduct);\n\tif (vid == MXU1_VENDOR_ID) {\n\t\tswitch (pid) {\n\t\tcase MXU1_1130_PRODUCT_ID:\n\t\tcase MXU1_1131_PRODUCT_ID:\n\t\t\ttdev->td_rs485_only = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcur_altsetting = serial->interface->cur_altsetting;\n\tnum_endpoints = cur_altsetting->desc.bNumEndpoints;\n\n\t \n\tif (dev->descriptor.bNumConfigurations == 1 && num_endpoints == 1) {\n\t\tstatus = ti_download_firmware(tdev);\n\n\t\tif (status != 0)\n\t\t\tgoto free_tdev;\n\n\t\t \n\t\tif (tdev->td_is_3410) {\n\t\t\tmsleep_interruptible(100);\n\t\t\tusb_reset_device(dev);\n\t\t}\n\n\t\tstatus = -ENODEV;\n\t\tgoto free_tdev;\n\t}\n\n\t \n\tif (dev->actconfig->desc.bConfigurationValue == TI_BOOT_CONFIG) {\n\t\tstatus = usb_driver_set_configuration(dev, TI_ACTIVE_CONFIG);\n\t\tstatus = status ? status : -ENODEV;\n\t\tgoto free_tdev;\n\t}\n\n\tif (serial->num_bulk_in < serial->num_ports ||\n\t\t\tserial->num_bulk_out < serial->num_ports) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\tstatus = -ENODEV;\n\t\tgoto free_tdev;\n\t}\n\n\treturn 0;\n\nfree_tdev:\n\tkfree(tdev);\n\tusb_set_serial_data(serial, NULL);\n\treturn status;\n}\n\n\nstatic void ti_release(struct usb_serial *serial)\n{\n\tstruct ti_device *tdev = usb_get_serial_data(serial);\n\n\tkfree(tdev);\n}\n\nstatic int ti_port_probe(struct usb_serial_port *port)\n{\n\tstruct ti_port *tport;\n\n\ttport = kzalloc(sizeof(*tport), GFP_KERNEL);\n\tif (!tport)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&tport->tp_lock);\n\tif (port == port->serial->port[0])\n\t\ttport->tp_uart_base_addr = TI_UART1_BASE_ADDR;\n\telse\n\t\ttport->tp_uart_base_addr = TI_UART2_BASE_ADDR;\n\ttport->tp_port = port;\n\ttport->tp_tdev = usb_get_serial_data(port->serial);\n\n\tif (tport->tp_tdev->td_rs485_only)\n\t\ttport->tp_uart_mode = TI_UART_485_RECEIVER_DISABLED;\n\telse\n\t\ttport->tp_uart_mode = TI_UART_232;\n\n\tusb_set_serial_port_data(port, tport);\n\n\t \n\tif (!tport->tp_tdev->td_is_3410)\n\t\tport->port.drain_delay = 1;\n\n\treturn 0;\n}\n\nstatic void ti_port_remove(struct usb_serial_port *port)\n{\n\tstruct ti_port *tport;\n\n\ttport = usb_get_serial_port_data(port);\n\tkfree(tport);\n}\n\nstatic int ti_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tstruct ti_device *tdev;\n\tstruct usb_device *dev;\n\tstruct urb *urb;\n\tint status;\n\tu16 open_settings;\n\n\topen_settings = (TI_PIPE_MODE_CONTINUOUS |\n\t\t\t TI_PIPE_TIMEOUT_ENABLE |\n\t\t\t (TI_TRANSFER_TIMEOUT << 2));\n\n\tdev = port->serial->dev;\n\ttdev = tport->tp_tdev;\n\n\t \n\tif (mutex_lock_interruptible(&tdev->td_open_close_lock))\n\t\treturn -ERESTARTSYS;\n\n\ttport->tp_msr = 0;\n\ttport->tp_shadow_mcr |= (TI_MCR_RTS | TI_MCR_DTR);\n\n\t \n\tif (tdev->td_open_port_count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - start interrupt in urb\\n\", __func__);\n\t\turb = tdev->td_serial->port[0]->interrupt_in_urb;\n\t\tif (!urb) {\n\t\t\tdev_err(&port->dev, \"%s - no interrupt urb\\n\", __func__);\n\t\t\tstatus = -EINVAL;\n\t\t\tgoto release_lock;\n\t\t}\n\t\turb->context = tdev;\n\t\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tdev_err(&port->dev, \"%s - submit interrupt urb failed, %d\\n\", __func__, status);\n\t\t\tgoto release_lock;\n\t\t}\n\t}\n\n\tif (tty)\n\t\tti_set_termios(tty, port, &tty->termios);\n\n\tstatus = ti_port_cmd_out(port, TI_OPEN_PORT, open_settings, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send open command, %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\tstatus = ti_port_cmd_out(port, TI_START_PORT, 0, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send start command, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\tstatus = ti_port_cmd_out(port, TI_PURGE_PORT, TI_PURGE_INPUT, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot clear input buffers, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\tstatus = ti_port_cmd_out(port, TI_PURGE_PORT, TI_PURGE_OUTPUT, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot clear output buffers, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\t \n\tusb_clear_halt(dev, port->write_urb->pipe);\n\tusb_clear_halt(dev, port->read_urb->pipe);\n\n\tif (tty)\n\t\tti_set_termios(tty, port, &tty->termios);\n\n\tstatus = ti_port_cmd_out(port, TI_OPEN_PORT, open_settings, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send open command (2), %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\tstatus = ti_port_cmd_out(port, TI_START_PORT, 0, NULL, 0);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - cannot send start command (2), %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\t \n\turb = port->read_urb;\n\tif (!urb) {\n\t\tdev_err(&port->dev, \"%s - no read urb\\n\", __func__);\n\t\tstatus = -EINVAL;\n\t\tgoto unlink_int_urb;\n\t}\n\ttport->tp_read_urb_state = TI_READ_URB_RUNNING;\n\turb->context = tport;\n\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - submit read urb failed, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto unlink_int_urb;\n\t}\n\n\ttport->tp_is_open = 1;\n\t++tdev->td_open_port_count;\n\n\tgoto release_lock;\n\nunlink_int_urb:\n\tif (tdev->td_open_port_count == 0)\n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\nrelease_lock:\n\tmutex_unlock(&tdev->td_open_close_lock);\n\treturn status;\n}\n\n\nstatic void ti_close(struct usb_serial_port *port)\n{\n\tstruct ti_device *tdev;\n\tstruct ti_port *tport;\n\tint status;\n\tunsigned long flags;\n\n\ttdev = usb_get_serial_data(port->serial);\n\ttport = usb_get_serial_port_data(port);\n\n\ttport->tp_is_open = 0;\n\n\tusb_kill_urb(port->read_urb);\n\tusb_kill_urb(port->write_urb);\n\ttport->tp_write_urb_in_use = 0;\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tkfifo_reset_out(&port->write_fifo);\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\tstatus = ti_port_cmd_out(port, TI_CLOSE_PORT, 0, NULL, 0);\n\tif (status)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - cannot send close port command, %d\\n\"\n\t\t\t\t\t\t\t, __func__, status);\n\n\tmutex_lock(&tdev->td_open_close_lock);\n\t--tdev->td_open_port_count;\n\tif (tdev->td_open_port_count == 0) {\n\t\t \n\t\tusb_kill_urb(port->serial->port[0]->interrupt_in_urb);\n\t}\n\tmutex_unlock(&tdev->td_open_close_lock);\n}\n\n\nstatic int ti_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *data, int count)\n{\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\n\tif (count == 0) {\n\t\treturn 0;\n\t}\n\n\tif (!tport->tp_is_open)\n\t\treturn -ENODEV;\n\n\tcount = kfifo_in_locked(&port->write_fifo, data, count,\n\t\t\t\t\t\t\t&tport->tp_lock);\n\tti_send(tport);\n\n\treturn count;\n}\n\n\nstatic unsigned int ti_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tunsigned int room;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n}\n\n\nstatic unsigned int ti_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tunsigned int chars;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tchars = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, chars);\n\treturn chars;\n}\n\nstatic bool ti_tx_empty(struct usb_serial_port *port)\n{\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tu8 lsr, mask;\n\tint ret;\n\n\t \n\tif (tport->tp_tdev->td_is_3410)\n\t\tmask = TI_LSR_TX_EMPTY_BOTH;\n\telse\n\t\tmask = TI_LSR_TX_EMPTY;\n\n\tret = ti_get_lsr(tport, &lsr);\n\tif (!ret && !(lsr & mask))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void ti_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\n\tif (I_IXOFF(tty) || C_CRTSCTS(tty))\n\t\tti_stop_read(tport, tty);\n\n}\n\n\nstatic void ti_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (I_IXOFF(tty) || C_CRTSCTS(tty)) {\n\t\tstatus = ti_restart_read(tport, tty);\n\t\tif (status)\n\t\t\tdev_err(&port->dev, \"%s - cannot restart read, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t}\n}\n\nstatic void ti_set_termios(struct tty_struct *tty,\n\t\t\t   struct usb_serial_port *port,\n\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tstruct ti_uart_config *config;\n\tint baud;\n\tint status;\n\tunsigned int mcr;\n\tu16 wbaudrate;\n\tu16 wflags = 0;\n\n\tconfig = kmalloc(sizeof(*config), GFP_KERNEL);\n\tif (!config)\n\t\treturn;\n\n\t \n\twflags |= TI_UART_ENABLE_MS_INTS;\n\twflags |= TI_UART_ENABLE_AUTO_START_DMA;\n\tconfig->bUartMode = tport->tp_uart_mode;\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\t\tconfig->bDataBits = TI_UART_5_DATA_BITS;\n\t\tbreak;\n\tcase CS6:\n\t\tconfig->bDataBits = TI_UART_6_DATA_BITS;\n\t\tbreak;\n\tcase CS7:\n\t\tconfig->bDataBits = TI_UART_7_DATA_BITS;\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tconfig->bDataBits = TI_UART_8_DATA_BITS;\n\t\tbreak;\n\t}\n\n\t \n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\tif (C_PARENB(tty)) {\n\t\tif (C_PARODD(tty)) {\n\t\t\twflags |= TI_UART_ENABLE_PARITY_CHECKING;\n\t\t\tconfig->bParity = TI_UART_ODD_PARITY;\n\t\t} else {\n\t\t\twflags |= TI_UART_ENABLE_PARITY_CHECKING;\n\t\t\tconfig->bParity = TI_UART_EVEN_PARITY;\n\t\t}\n\t} else {\n\t\twflags &= ~TI_UART_ENABLE_PARITY_CHECKING;\n\t\tconfig->bParity = TI_UART_NO_PARITY;\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tconfig->bStopBits = TI_UART_2_STOP_BITS;\n\telse\n\t\tconfig->bStopBits = TI_UART_1_STOP_BITS;\n\n\tif (C_CRTSCTS(tty)) {\n\t\t \n\t\tif ((C_BAUD(tty)) != B0)\n\t\t\twflags |= TI_UART_ENABLE_RTS_IN;\n\t\twflags |= TI_UART_ENABLE_CTS_OUT;\n\t} else {\n\t\tti_restart_read(tport, tty);\n\t}\n\n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tconfig->cXon  = START_CHAR(tty);\n\t\tconfig->cXoff = STOP_CHAR(tty);\n\n\t\tif (I_IXOFF(tty))\n\t\t\twflags |= TI_UART_ENABLE_X_IN;\n\t\telse\n\t\t\tti_restart_read(tport, tty);\n\n\t\tif (I_IXON(tty))\n\t\t\twflags |= TI_UART_ENABLE_X_OUT;\n\t}\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\tbaud = 9600;\n\tif (tport->tp_tdev->td_is_3410)\n\t\twbaudrate = (923077 + baud/2) / baud;\n\telse\n\t\twbaudrate = (461538 + baud/2) / baud;\n\n\t \n\tif ((C_BAUD(tty)) != B0)\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\n\tdev_dbg(&port->dev,\n\t\t\"%s - BaudRate=%d, wBaudRate=%d, wFlags=0x%04X, bDataBits=%d, bParity=%d, bStopBits=%d, cXon=%d, cXoff=%d, bUartMode=%d\\n\",\n\t\t__func__, baud, wbaudrate, wflags,\n\t\tconfig->bDataBits, config->bParity, config->bStopBits,\n\t\tconfig->cXon, config->cXoff, config->bUartMode);\n\n\tconfig->wBaudRate = cpu_to_be16(wbaudrate);\n\tconfig->wFlags = cpu_to_be16(wflags);\n\n\tstatus = ti_port_cmd_out(port, TI_SET_CONFIG, 0, config,\n\t\t\tsizeof(*config));\n\tif (status)\n\t\tdev_err(&port->dev, \"%s - cannot set config on port %d, %d\\n\",\n\t\t\t\t__func__, port->port_number, status);\n\n\t \n\tmcr = tport->tp_shadow_mcr;\n\t \n\tif (C_BAUD(tty) == B0)\n\t\tmcr &= ~(TI_MCR_DTR | TI_MCR_RTS);\n\tstatus = ti_set_mcr(tport, mcr);\n\tif (status)\n\t\tdev_err(&port->dev, \"%s - cannot set modem control on port %d, %d\\n\",\n\t\t\t\t__func__, port->port_number, status);\n\n\tkfree(config);\n}\n\n\nstatic int ti_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tunsigned int result;\n\tunsigned int msr;\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tmsr = tport->tp_msr;\n\tmcr = tport->tp_shadow_mcr;\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\tresult = ((mcr & TI_MCR_DTR) ? TIOCM_DTR : 0)\n\t\t| ((mcr & TI_MCR_RTS) ? TIOCM_RTS : 0)\n\t\t| ((mcr & TI_MCR_LOOP) ? TIOCM_LOOP : 0)\n\t\t| ((msr & TI_MSR_CTS) ? TIOCM_CTS : 0)\n\t\t| ((msr & TI_MSR_CD) ? TIOCM_CAR : 0)\n\t\t| ((msr & TI_MSR_RI) ? TIOCM_RI : 0)\n\t\t| ((msr & TI_MSR_DSR) ? TIOCM_DSR : 0);\n\n\tdev_dbg(&port->dev, \"%s - 0x%04X\\n\", __func__, result);\n\n\treturn result;\n}\n\n\nstatic int ti_tiocmset(struct tty_struct *tty,\n\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tmcr = tport->tp_shadow_mcr;\n\n\tif (set & TIOCM_RTS)\n\t\tmcr |= TI_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= TI_MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= TI_MCR_LOOP;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~TI_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~TI_MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~TI_MCR_LOOP;\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\treturn ti_set_mcr(tport, mcr);\n}\n\n\nstatic int ti_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\tint status;\n\n\tdev_dbg(&port->dev, \"%s - state = %d\\n\", __func__, break_state);\n\n\tstatus = ti_write_byte(port, tport->tp_tdev,\n\t\ttport->tp_uart_base_addr + TI_UART_OFFSET_LCR,\n\t\tTI_LCR_BREAK, break_state == -1 ? TI_LCR_BREAK : 0);\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - error setting break, %d\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int ti_get_port_from_code(unsigned char code)\n{\n\treturn (code >> 6) & 0x01;\n}\n\nstatic int ti_get_func_from_code(unsigned char code)\n{\n\treturn code & 0x0f;\n}\n\nstatic void ti_interrupt_callback(struct urb *urb)\n{\n\tstruct ti_device *tdev = urb->context;\n\tstruct usb_serial_port *port;\n\tstruct usb_serial *serial = tdev->td_serial;\n\tstruct ti_port *tport;\n\tstruct device *dev = &urb->dev->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint length = urb->actual_length;\n\tint port_number;\n\tint function;\n\tint status = urb->status;\n\tint retval;\n\tu8 msr;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(dev, \"%s - urb shutting down, %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(dev, \"%s - nonzero urb status, %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tif (length != 2) {\n\t\tdev_dbg(dev, \"%s - bad packet size, %d\\n\", __func__, length);\n\t\tgoto exit;\n\t}\n\n\tif (data[0] == TI_CODE_HARDWARE_ERROR) {\n\t\tdev_err(dev, \"%s - hardware error, %d\\n\", __func__, data[1]);\n\t\tgoto exit;\n\t}\n\n\tport_number = ti_get_port_from_code(data[0]);\n\tfunction = ti_get_func_from_code(data[0]);\n\n\tdev_dbg(dev, \"%s - port_number %d, function %d, data 0x%02X\\n\",\n\t\t__func__, port_number, function, data[1]);\n\n\tif (port_number >= serial->num_ports) {\n\t\tdev_err(dev, \"%s - bad port number, %d\\n\",\n\t\t\t\t\t\t__func__, port_number);\n\t\tgoto exit;\n\t}\n\n\tport = serial->port[port_number];\n\n\ttport = usb_get_serial_port_data(port);\n\tif (!tport)\n\t\tgoto exit;\n\n\tswitch (function) {\n\tcase TI_CODE_DATA_ERROR:\n\t\tdev_err(dev, \"%s - DATA ERROR, port %d, data 0x%02X\\n\",\n\t\t\t__func__, port_number, data[1]);\n\t\tbreak;\n\n\tcase TI_CODE_MODEM_STATUS:\n\t\tmsr = data[1];\n\t\tdev_dbg(dev, \"%s - port %d, msr 0x%02X\\n\", __func__, port_number, msr);\n\t\tti_handle_new_msr(tport, msr);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(dev, \"%s - unknown interrupt code, 0x%02X\\n\",\n\t\t\t\t\t\t\t__func__, data[1]);\n\t\tbreak;\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(dev, \"%s - resubmit interrupt urb failed, %d\\n\",\n\t\t\t__func__, retval);\n}\n\n\nstatic void ti_bulk_in_callback(struct urb *urb)\n{\n\tstruct ti_port *tport = urb->context;\n\tstruct usb_serial_port *port = tport->tp_port;\n\tstruct device *dev = &urb->dev->dev;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(dev, \"%s - urb shutting down, %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(dev, \"%s - nonzero urb status, %d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\tif (status == -EPIPE)\n\t\tgoto exit;\n\n\tif (status) {\n\t\tdev_err(dev, \"%s - stopping read!\\n\", __func__);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(dev, __func__, urb->actual_length,\n\t\t\t\t      urb->transfer_buffer);\n\n\t\tif (!tport->tp_is_open)\n\t\t\tdev_dbg(dev, \"%s - port closed, dropping data\\n\",\n\t\t\t\t__func__);\n\t\telse\n\t\t\tti_recv(port, urb->transfer_buffer, urb->actual_length);\n\t\tspin_lock_irqsave(&tport->tp_lock, flags);\n\t\tport->icount.rx += urb->actual_length;\n\t\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\t}\n\nexit:\n\t \n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tif (tport->tp_read_urb_state == TI_READ_URB_RUNNING)\n\t\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\telse if (tport->tp_read_urb_state == TI_READ_URB_STOPPING)\n\t\ttport->tp_read_urb_state = TI_READ_URB_STOPPED;\n\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\tif (retval)\n\t\tdev_err(dev, \"%s - resubmit read urb failed, %d\\n\",\n\t\t\t__func__, retval);\n}\n\n\nstatic void ti_bulk_out_callback(struct urb *urb)\n{\n\tstruct ti_port *tport = urb->context;\n\tstruct usb_serial_port *port = tport->tp_port;\n\tint status = urb->status;\n\n\ttport->tp_write_urb_in_use = 0;\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&port->dev, \"%s - urb shutting down, %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err_console(port, \"%s - nonzero urb status, %d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\t \n\tti_send(tport);\n}\n\n\nstatic void ti_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint cnt;\n\n\tdo {\n\t\tcnt = tty_insert_flip_string(&port->port, data, length);\n\t\tif (cnt < length) {\n\t\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t\t\t\t__func__, length - cnt);\n\t\t\tif (cnt == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\ttty_flip_buffer_push(&port->port);\n\t\tdata += cnt;\n\t\tlength -= cnt;\n\t} while (length > 0);\n}\n\n\nstatic void ti_send(struct ti_port *tport)\n{\n\tint count, result;\n\tstruct usb_serial_port *port = tport->tp_port;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\n\tif (tport->tp_write_urb_in_use)\n\t\tgoto unlock;\n\n\tcount = kfifo_out(&port->write_fifo,\n\t\t\t\tport->write_urb->transfer_buffer,\n\t\t\t\tport->bulk_out_size);\n\n\tif (count == 0)\n\t\tgoto unlock;\n\n\ttport->tp_write_urb_in_use = 1;\n\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\tusb_serial_debug_data(&port->dev, __func__, count,\n\t\t\t      port->write_urb->transfer_buffer);\n\n\tusb_fill_bulk_urb(port->write_urb, port->serial->dev,\n\t\t\t   usb_sndbulkpipe(port->serial->dev,\n\t\t\t\t\t    port->bulk_out_endpointAddress),\n\t\t\t   port->write_urb->transfer_buffer, count,\n\t\t\t   ti_bulk_out_callback, tport);\n\n\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port, \"%s - submit write urb failed, %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\ttport->tp_write_urb_in_use = 0;\n\t\t \n\t} else {\n\t\tspin_lock_irqsave(&tport->tp_lock, flags);\n\t\tport->icount.tx += count;\n\t\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\t}\n\n\t \n\ttty_port_tty_wakeup(&port->port);\n\n\treturn;\nunlock:\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\treturn;\n}\n\n\nstatic int ti_set_mcr(struct ti_port *tport, unsigned int mcr)\n{\n\tunsigned long flags;\n\tint status;\n\n\tstatus = ti_write_byte(tport->tp_port, tport->tp_tdev,\n\t\ttport->tp_uart_base_addr + TI_UART_OFFSET_MCR,\n\t\tTI_MCR_RTS | TI_MCR_DTR | TI_MCR_LOOP, mcr);\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\tif (!status)\n\t\ttport->tp_shadow_mcr = mcr;\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\n\treturn status;\n}\n\n\nstatic int ti_get_lsr(struct ti_port *tport, u8 *lsr)\n{\n\tint size, status;\n\tstruct usb_serial_port *port = tport->tp_port;\n\tstruct ti_port_status *data;\n\n\tsize = sizeof(struct ti_port_status);\n\tdata = kmalloc(size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tstatus = ti_port_cmd_in(port, TI_GET_PORT_STATUS, 0, data, size);\n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - get port status command failed, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tgoto free_data;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - lsr 0x%02X\\n\", __func__, data->bLSR);\n\n\t*lsr = data->bLSR;\n\nfree_data:\n\tkfree(data);\n\treturn status;\n}\n\n\nstatic void ti_get_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ti_port *tport = usb_get_serial_port_data(port);\n\n\tss->baud_base = tport->tp_tdev->td_is_3410 ? 921600 : 460800;\n}\n\n\nstatic void ti_handle_new_msr(struct ti_port *tport, u8 msr)\n{\n\tstruct async_icount *icount;\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\n\tdev_dbg(&tport->tp_port->dev, \"%s - msr 0x%02X\\n\", __func__, msr);\n\n\tif (msr & TI_MSR_DELTA_MASK) {\n\t\tspin_lock_irqsave(&tport->tp_lock, flags);\n\t\ticount = &tport->tp_port->icount;\n\t\tif (msr & TI_MSR_DELTA_CTS)\n\t\t\ticount->cts++;\n\t\tif (msr & TI_MSR_DELTA_DSR)\n\t\t\ticount->dsr++;\n\t\tif (msr & TI_MSR_DELTA_CD)\n\t\t\ticount->dcd++;\n\t\tif (msr & TI_MSR_DELTA_RI)\n\t\t\ticount->rng++;\n\t\twake_up_interruptible(&tport->tp_port->port.delta_msr_wait);\n\t\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\t}\n\n\ttport->tp_msr = msr & TI_MSR_MASK;\n\n\t \n\ttty = tty_port_tty_get(&tport->tp_port->port);\n\tif (tty && C_CRTSCTS(tty)) {\n\t\tif (msr & TI_MSR_CTS)\n\t\t\ttty_wakeup(tty);\n\t}\n\ttty_kref_put(tty);\n}\n\n\nstatic void ti_stop_read(struct ti_port *tport, struct tty_struct *tty)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\n\tif (tport->tp_read_urb_state == TI_READ_URB_RUNNING)\n\t\ttport->tp_read_urb_state = TI_READ_URB_STOPPING;\n\n\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n}\n\n\nstatic int ti_restart_read(struct ti_port *tport, struct tty_struct *tty)\n{\n\tstruct urb *urb;\n\tint status = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tport->tp_lock, flags);\n\n\tif (tport->tp_read_urb_state == TI_READ_URB_STOPPED) {\n\t\ttport->tp_read_urb_state = TI_READ_URB_RUNNING;\n\t\turb = tport->tp_port->read_urb;\n\t\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\t\turb->context = tport;\n\t\tstatus = usb_submit_urb(urb, GFP_KERNEL);\n\t} else  {\n\t\ttport->tp_read_urb_state = TI_READ_URB_RUNNING;\n\t\tspin_unlock_irqrestore(&tport->tp_lock, flags);\n\t}\n\n\treturn status;\n}\n\nstatic int ti_command_out_sync(struct usb_device *udev, u8 command,\n\t\tu16 moduleid, u16 value, void *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(udev, usb_sndctrlpipe(udev, 0), command,\n\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_OUT,\n\t\t\tvalue, moduleid, data, size, 1000);\n\tif (status < 0)\n\t\treturn status;\n\n\treturn 0;\n}\n\nstatic int ti_command_in_sync(struct usb_device *udev, u8 command,\n\t\tu16 moduleid, u16 value, void *data, int size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0), command,\n\t\t\tUSB_TYPE_VENDOR | USB_RECIP_DEVICE | USB_DIR_IN,\n\t\t\tvalue, moduleid, data, size, 1000);\n\tif (status == size)\n\t\tstatus = 0;\n\telse if (status >= 0)\n\t\tstatus = -ECOMM;\n\n\treturn status;\n}\n\nstatic int ti_port_cmd_out(struct usb_serial_port *port, u8 command,\n\t\tu16 value, void *data, int size)\n{\n\treturn ti_command_out_sync(port->serial->dev, command,\n\t\t\tTI_UART1_PORT + port->port_number,\n\t\t\tvalue, data, size);\n}\n\nstatic int ti_port_cmd_in(struct usb_serial_port *port, u8 command,\n\t\tu16 value, void *data, int size)\n{\n\treturn ti_command_in_sync(port->serial->dev, command,\n\t\t\tTI_UART1_PORT + port->port_number,\n\t\t\tvalue, data, size);\n}\n\nstatic int ti_write_byte(struct usb_serial_port *port,\n\t\t\t struct ti_device *tdev, unsigned long addr,\n\t\t\t u8 mask, u8 byte)\n{\n\tint status;\n\tunsigned int size;\n\tstruct ti_write_data_bytes *data;\n\n\tdev_dbg(&port->dev, \"%s - addr 0x%08lX, mask 0x%02X, byte 0x%02X\\n\", __func__,\n\t\taddr, mask, byte);\n\n\tsize = sizeof(struct ti_write_data_bytes) + 2;\n\tdata = kmalloc(size, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->bAddrType = TI_RW_DATA_ADDR_XDATA;\n\tdata->bDataType = TI_RW_DATA_BYTE;\n\tdata->bDataCounter = 1;\n\tdata->wBaseAddrHi = cpu_to_be16(addr>>16);\n\tdata->wBaseAddrLo = cpu_to_be16(addr);\n\tdata->bData[0] = mask;\n\tdata->bData[1] = byte;\n\n\tstatus = ti_command_out_sync(port->serial->dev, TI_WRITE_DATA,\n\t\t\tTI_RAM_PORT, 0, data, size);\n\tif (status < 0)\n\t\tdev_err(&port->dev, \"%s - failed, %d\\n\", __func__, status);\n\n\tkfree(data);\n\n\treturn status;\n}\n\nstatic int ti_do_download(struct usb_device *dev, int pipe,\n\t\t\t\t\t\tu8 *buffer, int size)\n{\n\tint pos;\n\tu8 cs = 0;\n\tint done;\n\tstruct ti_firmware_header *header;\n\tint status = 0;\n\tint len;\n\n\tfor (pos = sizeof(struct ti_firmware_header); pos < size; pos++)\n\t\tcs = (u8)(cs + buffer[pos]);\n\n\theader = (struct ti_firmware_header *)buffer;\n\theader->wLength = cpu_to_le16(size - sizeof(*header));\n\theader->bCheckSum = cs;\n\n\tdev_dbg(&dev->dev, \"%s - downloading firmware\\n\", __func__);\n\tfor (pos = 0; pos < size; pos += done) {\n\t\tlen = min(size - pos, TI_DOWNLOAD_MAX_PACKET_SIZE);\n\t\tstatus = usb_bulk_msg(dev, pipe, buffer + pos, len,\n\t\t\t\t\t\t\t\t&done, 1000);\n\t\tif (status)\n\t\t\tbreak;\n\t}\n\treturn status;\n}\n\nstatic int ti_download_firmware(struct ti_device *tdev)\n{\n\tint status;\n\tint buffer_size;\n\tu8 *buffer;\n\tstruct usb_device *dev = tdev->td_serial->dev;\n\tunsigned int pipe = usb_sndbulkpipe(dev,\n\t\ttdev->td_serial->port[0]->bulk_out_endpointAddress);\n\tconst struct firmware *fw_p;\n\tchar buf[32];\n\n\tif (le16_to_cpu(dev->descriptor.idVendor) == MXU1_VENDOR_ID) {\n\t\tsnprintf(buf,\n\t\t\tsizeof(buf),\n\t\t\t\"moxa/moxa-%04x.fw\",\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\n\t\tstatus = request_firmware(&fw_p, buf, &dev->dev);\n\t\tgoto check_firmware;\n\t}\n\n\t \n\tsprintf(buf, \"ti_usb-v%04x-p%04x.fw\",\n\t\t\tle16_to_cpu(dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(dev->descriptor.idProduct));\n\tstatus = request_firmware(&fw_p, buf, &dev->dev);\n\n\tif (status != 0) {\n\t\tbuf[0] = '\\0';\n\t\tif (le16_to_cpu(dev->descriptor.idVendor) == MTS_VENDOR_ID) {\n\t\t\tswitch (le16_to_cpu(dev->descriptor.idProduct)) {\n\t\t\tcase MTS_CDMA_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_cdma.fw\");\n\t\t\t\tbreak;\n\t\t\tcase MTS_GSM_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_gsm.fw\");\n\t\t\t\tbreak;\n\t\t\tcase MTS_EDGE_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_edge.fw\");\n\t\t\t\tbreak;\n\t\t\tcase MTS_MT9234MU_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_mt9234mu.fw\");\n\t\t\t\tbreak;\n\t\t\tcase MTS_MT9234ZBA_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_mt9234zba.fw\");\n\t\t\t\tbreak;\n\t\t\tcase MTS_MT9234ZBAOLD_PRODUCT_ID:\n\t\t\t\tstrcpy(buf, \"mts_mt9234zba.fw\");\n\t\t\t\tbreak;\t\t\t}\n\t\t}\n\t\tif (buf[0] == '\\0') {\n\t\t\tif (tdev->td_is_3410)\n\t\t\t\tstrcpy(buf, \"ti_3410.fw\");\n\t\t\telse\n\t\t\t\tstrcpy(buf, \"ti_5052.fw\");\n\t\t}\n\t\tstatus = request_firmware(&fw_p, buf, &dev->dev);\n\t}\n\ncheck_firmware:\n\tif (status) {\n\t\tdev_err(&dev->dev, \"%s - firmware not found\\n\", __func__);\n\t\treturn -ENOENT;\n\t}\n\tif (fw_p->size > TI_FIRMWARE_BUF_SIZE) {\n\t\tdev_err(&dev->dev, \"%s - firmware too large %zu\\n\", __func__, fw_p->size);\n\t\trelease_firmware(fw_p);\n\t\treturn -ENOENT;\n\t}\n\n\tbuffer_size = TI_FIRMWARE_BUF_SIZE + sizeof(struct ti_firmware_header);\n\tbuffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (buffer) {\n\t\tmemcpy(buffer, fw_p->data, fw_p->size);\n\t\tmemset(buffer + fw_p->size, 0xff, buffer_size - fw_p->size);\n\t\tstatus = ti_do_download(dev, pipe, buffer, fw_p->size);\n\t\tkfree(buffer);\n\t} else {\n\t\tstatus = -ENOMEM;\n\t}\n\trelease_firmware(fw_p);\n\tif (status) {\n\t\tdev_err(&dev->dev, \"%s - error downloading firmware, %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\tdev_dbg(&dev->dev, \"%s - download successful\\n\", __func__);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}