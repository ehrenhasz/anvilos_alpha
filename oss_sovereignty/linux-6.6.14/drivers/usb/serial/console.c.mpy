{
  "module_name": "console.c",
  "hash_id": "552bc0901b914e811fe1277176101855c2d1b7fb991d2508bcb465a9d5cc6be1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/console.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\n\n \n\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\n\n \nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\n\t \n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\n\tif (doflow)\n\t\tcflag |= CRTSCTS;\n\n\t \n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t \n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t \n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t \n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_save_termios(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, true);\n\t}\n\t \n\t--port->port.count;\n\t \n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tinfo->port = NULL;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tmutex_unlock(&serial->disc_mutex);\n\tusb_serial_put(serial);\n\treturn retval;\n}\n\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\n\tif (count == 0)\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\t \n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t \n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\t \n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\n\nstatic struct tty_driver *usb_console_device(struct console *co, int *index)\n{\n\tstruct tty_driver **p = (struct tty_driver **)co->data;\n\n\tif (!*p)\n\t\treturn NULL;\n\n\t*index = co->index;\n\treturn *p;\n}\n\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n\nvoid usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}\n\nvoid usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t \n\t\t \n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}\n\nvoid usb_serial_console_exit(void)\n{\n\tif (usbcons_info.port) {\n\t\tunregister_console(&usbcons);\n\t\tusbcons_info.port->port.console = 0;\n\t\tusbcons_info.port = NULL;\n\t}\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}