{
  "module_name": "usb-serial.c",
  "hash_id": "38fc9d3fe819dc61887dc4bc0b0bb24928a1c853f95ff9e2a797006537890c62",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/usb-serial.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/seq_file.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/kfifo.h>\n#include <linux/idr.h>\n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <gregkh@linuxfoundation.org>\"\n#define DRIVER_DESC \"USB Serial Driver core\"\n\n#define USB_SERIAL_TTY_MAJOR\t188\n#define USB_SERIAL_TTY_MINORS\t512\t \n\n \n\nstatic DEFINE_IDR(serial_minors);\nstatic DEFINE_MUTEX(table_lock);\nstatic LIST_HEAD(usb_serial_driver_list);\n\n \nstruct usb_serial_port *usb_serial_port_get_by_minor(unsigned minor)\n{\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\n\tmutex_lock(&table_lock);\n\tport = idr_find(&serial_minors, minor);\n\tif (!port)\n\t\tgoto exit;\n\n\tserial = port->serial;\n\tmutex_lock(&serial->disc_mutex);\n\tif (serial->disconnected) {\n\t\tmutex_unlock(&serial->disc_mutex);\n\t\tport = NULL;\n\t} else {\n\t\tkref_get(&serial->kref);\n\t}\nexit:\n\tmutex_unlock(&table_lock);\n\treturn port;\n}\n\nstatic int allocate_minors(struct usb_serial *serial, int num_ports)\n{\n\tstruct usb_serial_port *port;\n\tunsigned int i, j;\n\tint minor;\n\n\tdev_dbg(&serial->interface->dev, \"%s %d\\n\", __func__, num_ports);\n\n\tmutex_lock(&table_lock);\n\tfor (i = 0; i < num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tminor = idr_alloc(&serial_minors, port, 0,\n\t\t\t\t\tUSB_SERIAL_TTY_MINORS, GFP_KERNEL);\n\t\tif (minor < 0)\n\t\t\tgoto error;\n\t\tport->minor = minor;\n\t\tport->port_number = i;\n\t}\n\tserial->minors_reserved = 1;\n\tmutex_unlock(&table_lock);\n\treturn 0;\nerror:\n\t \n\tfor (j = 0; j < i; ++j)\n\t\tidr_remove(&serial_minors, serial->port[j]->minor);\n\tmutex_unlock(&table_lock);\n\treturn minor;\n}\n\nstatic void release_minors(struct usb_serial *serial)\n{\n\tint i;\n\n\tmutex_lock(&table_lock);\n\tfor (i = 0; i < serial->num_ports; ++i)\n\t\tidr_remove(&serial_minors, serial->port[i]->minor);\n\tmutex_unlock(&table_lock);\n\tserial->minors_reserved = 0;\n}\n\nint usb_serial_claim_interface(struct usb_serial *serial, struct usb_interface *intf)\n{\n\tstruct usb_driver *driver = serial->type->usb_driver;\n\tint ret;\n\n\tif (serial->sibling)\n\t\treturn -EBUSY;\n\n\tret = usb_driver_claim_interface(driver, intf, serial);\n\tif (ret) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\t\"failed to claim sibling interface: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tserial->sibling = intf;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_serial_claim_interface);\n\nstatic void release_sibling(struct usb_serial *serial, struct usb_interface *intf)\n{\n\tstruct usb_driver *driver = serial->type->usb_driver;\n\tstruct usb_interface *sibling;\n\n\tif (!serial->sibling)\n\t\treturn;\n\n\tif (intf == serial->sibling)\n\t\tsibling = serial->interface;\n\telse\n\t\tsibling = serial->sibling;\n\n\tusb_set_intfdata(sibling, NULL);\n\tusb_driver_release_interface(driver, sibling);\n}\n\nstatic void destroy_serial(struct kref *kref)\n{\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint i;\n\n\tserial = to_usb_serial(kref);\n\n\t \n\tif (serial->minors_reserved)\n\t\trelease_minors(serial);\n\n\tif (serial->attached && serial->type->release)\n\t\tserial->type->release(serial);\n\n\t \n\tfor (i = 0; i < serial->num_port_pointers; ++i) {\n\t\tport = serial->port[i];\n\t\tif (port) {\n\t\t\tport->serial = NULL;\n\t\t\tput_device(&port->dev);\n\t\t}\n\t}\n\n\tusb_put_intf(serial->interface);\n\tusb_put_dev(serial->dev);\n\tkfree(serial);\n}\n\nvoid usb_serial_put(struct usb_serial *serial)\n{\n\tkref_put(&serial->kref, destroy_serial);\n}\n\n \n\n \nstatic int serial_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tint idx = tty->index;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tbool init_termios;\n\tint retval = -ENODEV;\n\n\tport = usb_serial_port_get_by_minor(idx);\n\tif (!port)\n\t\treturn retval;\n\n\tserial = port->serial;\n\tif (!try_module_get(serial->type->driver.owner))\n\t\tgoto err_put_serial;\n\n\tinit_termios = (driver->termios[idx] == NULL);\n\n\tretval = tty_standard_install(driver, tty);\n\tif (retval)\n\t\tgoto err_put_module;\n\n\tmutex_unlock(&serial->disc_mutex);\n\n\t \n\tif (init_termios && serial->type->init_termios)\n\t\tserial->type->init_termios(tty);\n\n\ttty->driver_data = port;\n\n\treturn retval;\n\nerr_put_module:\n\tmodule_put(serial->type->driver.owner);\nerr_put_serial:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n\nstatic int serial_port_activate(struct tty_port *tport, struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port =\n\t\tcontainer_of(tport, struct usb_serial_port, port);\n\tstruct usb_serial *serial = port->serial;\n\tint retval;\n\n\tmutex_lock(&serial->disc_mutex);\n\tif (serial->disconnected) {\n\t\tretval = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tretval = port->serial->type->open(tty, port);\n\tif (retval)\n\t\tusb_autopm_put_interface(serial->interface);\nout_unlock:\n\tmutex_unlock(&serial->disc_mutex);\n\n\tif (retval < 0)\n\t\tretval = usb_translate_errors(retval);\n\n\treturn retval;\n}\n\nstatic int serial_open(struct tty_struct *tty, struct file *filp)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\treturn tty_port_open(&port->port, tty, filp);\n}\n\n \nstatic void serial_port_shutdown(struct tty_port *tport)\n{\n\tstruct usb_serial_port *port =\n\t\tcontainer_of(tport, struct usb_serial_port, port);\n\tstruct usb_serial_driver *drv = port->serial->type;\n\n\tif (drv->close)\n\t\tdrv->close(port);\n\n\tusb_autopm_put_interface(port->serial->interface);\n}\n\nstatic void serial_hangup(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\ttty_port_hangup(&port->port);\n}\n\nstatic void serial_close(struct tty_struct *tty, struct file *filp)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\ttty_port_close(&port->port, tty, filp);\n}\n\n \nstatic void serial_cleanup(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial;\n\tstruct module *owner;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\t \n\tif (port->port.console)\n\t\treturn;\n\n\ttty->driver_data = NULL;\n\n\tserial = port->serial;\n\towner = serial->type->driver.owner;\n\n\tusb_serial_put(serial);\n\tmodule_put(owner);\n}\n\nstatic ssize_t serial_write(struct tty_struct *tty, const u8 *buf, size_t count)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tint retval = -ENODEV;\n\n\tif (port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\tgoto exit;\n\n\tdev_dbg(&port->dev, \"%s - %zu byte(s)\\n\", __func__, count);\n\n\tretval = port->serial->type->write(tty, port, buf, count);\n\tif (retval < 0)\n\t\tretval = usb_translate_errors(retval);\nexit:\n\treturn retval;\n}\n\nstatic unsigned int serial_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\treturn port->serial->type->write_room(tty);\n}\n\nstatic unsigned int serial_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (serial->disconnected)\n\t\treturn 0;\n\n\treturn serial->type->chars_in_buffer(tty);\n}\n\nstatic void serial_wait_until_sent(struct tty_struct *tty, int timeout)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (!port->serial->type->wait_until_sent)\n\t\treturn;\n\n\tmutex_lock(&serial->disc_mutex);\n\tif (!serial->disconnected)\n\t\tport->serial->type->wait_until_sent(tty, timeout);\n\tmutex_unlock(&serial->disc_mutex);\n}\n\nstatic void serial_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->throttle)\n\t\tport->serial->type->throttle(tty);\n}\n\nstatic void serial_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->unthrottle)\n\t\tport->serial->type->unthrottle(tty);\n}\n\nstatic int serial_get_serial(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct tty_port *tport = &port->port;\n\tunsigned int close_delay, closing_wait;\n\n\tmutex_lock(&tport->mutex);\n\n\tclose_delay = jiffies_to_msecs(tport->close_delay) / 10;\n\tclosing_wait = tport->closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = jiffies_to_msecs(closing_wait) / 10;\n\n\tss->line = port->minor;\n\tss->close_delay = close_delay;\n\tss->closing_wait = closing_wait;\n\n\tif (port->serial->type->get_serial)\n\t\tport->serial->type->get_serial(tty, ss);\n\n\tmutex_unlock(&tport->mutex);\n\n\treturn 0;\n}\n\nstatic int serial_set_serial(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct tty_port *tport = &port->port;\n\tunsigned int close_delay, closing_wait;\n\tint ret = 0;\n\n\tclose_delay = msecs_to_jiffies(ss->close_delay * 10);\n\tclosing_wait = ss->closing_wait;\n\tif (closing_wait != ASYNC_CLOSING_WAIT_NONE)\n\t\tclosing_wait = msecs_to_jiffies(closing_wait * 10);\n\n\tmutex_lock(&tport->mutex);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif (close_delay != tport->close_delay ||\n\t\t\t\tclosing_wait != tport->closing_wait) {\n\t\t\tret = -EPERM;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (port->serial->type->set_serial) {\n\t\tret = port->serial->type->set_serial(tty, ss);\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\t}\n\n\ttport->close_delay = close_delay;\n\ttport->closing_wait = closing_wait;\nout_unlock:\n\tmutex_unlock(&tport->mutex);\n\n\treturn ret;\n}\n\nstatic int serial_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tint retval = -ENOIOCTLCMD;\n\n\tdev_dbg(&port->dev, \"%s - cmd 0x%04x\\n\", __func__, cmd);\n\n\tswitch (cmd) {\n\tcase TIOCMIWAIT:\n\t\tif (port->serial->type->tiocmiwait)\n\t\t\tretval = port->serial->type->tiocmiwait(tty, arg);\n\t\tbreak;\n\tdefault:\n\t\tif (port->serial->type->ioctl)\n\t\t\tretval = port->serial->type->ioctl(tty, cmd, arg);\n\t}\n\n\treturn retval;\n}\n\nstatic void serial_set_termios(struct tty_struct *tty,\n\t\t               const struct ktermios *old)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->set_termios)\n\t\tport->serial->type->set_termios(tty, port, old);\n\telse\n\t\ttty_termios_copy_hw(&tty->termios, old);\n}\n\nstatic int serial_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->break_ctl)\n\t\treturn port->serial->type->break_ctl(tty, break_state);\n\n\treturn -ENOTTY;\n}\n\nstatic int serial_proc_show(struct seq_file *m, void *v)\n{\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint i;\n\tchar tmp[40];\n\n\tseq_puts(m, \"usbserinfo:1.0 driver:2.0\\n\");\n\tfor (i = 0; i < USB_SERIAL_TTY_MINORS; ++i) {\n\t\tport = usb_serial_port_get_by_minor(i);\n\t\tif (port == NULL)\n\t\t\tcontinue;\n\t\tserial = port->serial;\n\n\t\tseq_printf(m, \"%d:\", i);\n\t\tif (serial->type->driver.owner)\n\t\t\tseq_printf(m, \" module:%s\",\n\t\t\t\tmodule_name(serial->type->driver.owner));\n\t\tseq_printf(m, \" name:\\\"%s\\\"\",\n\t\t\t\tserial->type->description);\n\t\tseq_printf(m, \" vendor:%04x product:%04x\",\n\t\t\tle16_to_cpu(serial->dev->descriptor.idVendor),\n\t\t\tle16_to_cpu(serial->dev->descriptor.idProduct));\n\t\tseq_printf(m, \" num_ports:%d\", serial->num_ports);\n\t\tseq_printf(m, \" port:%d\", port->port_number);\n\t\tusb_make_path(serial->dev, tmp, sizeof(tmp));\n\t\tseq_printf(m, \" path:%s\", tmp);\n\n\t\tseq_putc(m, '\\n');\n\t\tusb_serial_put(serial);\n\t\tmutex_unlock(&serial->disc_mutex);\n\t}\n\treturn 0;\n}\n\nstatic int serial_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->tiocmget)\n\t\treturn port->serial->type->tiocmget(tty);\n\treturn -ENOTTY;\n}\n\nstatic int serial_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->tiocmset)\n\t\treturn port->serial->type->tiocmset(tty, set, clear);\n\treturn -ENOTTY;\n}\n\nstatic int serial_get_icount(struct tty_struct *tty,\n\t\t\t\tstruct serial_icounter_struct *icount)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tif (port->serial->type->get_icount)\n\t\treturn port->serial->type->get_icount(tty, icount);\n\treturn -ENOTTY;\n}\n\n \nvoid usb_serial_port_softint(struct usb_serial_port *port)\n{\n\tschedule_work(&port->work);\n}\nEXPORT_SYMBOL_GPL(usb_serial_port_softint);\n\nstatic void usb_serial_port_work(struct work_struct *work)\n{\n\tstruct usb_serial_port *port =\n\t\tcontainer_of(work, struct usb_serial_port, work);\n\n\ttty_port_tty_wakeup(&port->port);\n}\n\nstatic void usb_serial_port_poison_urbs(struct usb_serial_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\n\t\tusb_poison_urb(port->read_urbs[i]);\n\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i)\n\t\tusb_poison_urb(port->write_urbs[i]);\n\n\tusb_poison_urb(port->interrupt_in_urb);\n\tusb_poison_urb(port->interrupt_out_urb);\n}\n\nstatic void usb_serial_port_unpoison_urbs(struct usb_serial_port *port)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\n\t\tusb_unpoison_urb(port->read_urbs[i]);\n\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i)\n\t\tusb_unpoison_urb(port->write_urbs[i]);\n\n\tusb_unpoison_urb(port->interrupt_in_urb);\n\tusb_unpoison_urb(port->interrupt_out_urb);\n}\n\nstatic void usb_serial_port_release(struct device *dev)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tint i;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tusb_free_urb(port->interrupt_in_urb);\n\tusb_free_urb(port->interrupt_out_urb);\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {\n\t\tusb_free_urb(port->read_urbs[i]);\n\t\tkfree(port->bulk_in_buffers[i]);\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i) {\n\t\tusb_free_urb(port->write_urbs[i]);\n\t\tkfree(port->bulk_out_buffers[i]);\n\t}\n\tkfifo_free(&port->write_fifo);\n\tkfree(port->interrupt_in_buffer);\n\tkfree(port->interrupt_out_buffer);\n\ttty_port_destroy(&port->port);\n\tkfree(port);\n}\n\nstatic struct usb_serial *create_serial(struct usb_device *dev,\n\t\t\t\t\tstruct usb_interface *interface,\n\t\t\t\t\tstruct usb_serial_driver *driver)\n{\n\tstruct usb_serial *serial;\n\n\tserial = kzalloc(sizeof(*serial), GFP_KERNEL);\n\tif (!serial)\n\t\treturn NULL;\n\tserial->dev = usb_get_dev(dev);\n\tserial->type = driver;\n\tserial->interface = usb_get_intf(interface);\n\tkref_init(&serial->kref);\n\tmutex_init(&serial->disc_mutex);\n\tserial->minors_reserved = 0;\n\n\treturn serial;\n}\n\nstatic const struct usb_device_id *match_dynamic_id(struct usb_interface *intf,\n\t\t\t\t\t    struct usb_serial_driver *drv)\n{\n\tstruct usb_dynid *dynid;\n\n\tspin_lock(&drv->dynids.lock);\n\tlist_for_each_entry(dynid, &drv->dynids.list, node) {\n\t\tif (usb_match_one_id(intf, &dynid->id)) {\n\t\t\tspin_unlock(&drv->dynids.lock);\n\t\t\treturn &dynid->id;\n\t\t}\n\t}\n\tspin_unlock(&drv->dynids.lock);\n\treturn NULL;\n}\n\nstatic const struct usb_device_id *get_iface_id(struct usb_serial_driver *drv,\n\t\t\t\t\t\tstruct usb_interface *intf)\n{\n\tconst struct usb_device_id *id;\n\n\tid = usb_match_id(intf, drv->id_table);\n\tif (id) {\n\t\tdev_dbg(&intf->dev, \"static descriptor matches\\n\");\n\t\tgoto exit;\n\t}\n\tid = match_dynamic_id(intf, drv);\n\tif (id)\n\t\tdev_dbg(&intf->dev, \"dynamic descriptor matches\\n\");\nexit:\n\treturn id;\n}\n\n \nstatic struct usb_serial_driver *search_serial_device(\n\t\t\t\t\tstruct usb_interface *iface)\n{\n\tconst struct usb_device_id *id = NULL;\n\tstruct usb_serial_driver *drv;\n\tstruct usb_driver *driver = to_usb_driver(iface->dev.driver);\n\n\t \n\tlist_for_each_entry(drv, &usb_serial_driver_list, driver_list) {\n\t\tif (drv->usb_driver == driver)\n\t\t\tid = get_iface_id(drv, iface);\n\t\tif (id)\n\t\t\treturn drv;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool serial_port_carrier_raised(struct tty_port *port)\n{\n\tstruct usb_serial_port *p = container_of(port, struct usb_serial_port, port);\n\tstruct usb_serial_driver *drv = p->serial->type;\n\n\tif (drv->carrier_raised)\n\t\treturn drv->carrier_raised(p);\n\t \n\treturn true;\n}\n\nstatic void serial_port_dtr_rts(struct tty_port *port, bool on)\n{\n\tstruct usb_serial_port *p = container_of(port, struct usb_serial_port, port);\n\tstruct usb_serial_driver *drv = p->serial->type;\n\n\tif (drv->dtr_rts)\n\t\tdrv->dtr_rts(p, on);\n}\n\nstatic ssize_t port_number_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\n\treturn sprintf(buf, \"%u\\n\", port->port_number);\n}\nstatic DEVICE_ATTR_RO(port_number);\n\nstatic struct attribute *usb_serial_port_attrs[] = {\n\t&dev_attr_port_number.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(usb_serial_port);\n\nstatic const struct tty_port_operations serial_port_ops = {\n\t.carrier_raised\t\t= serial_port_carrier_raised,\n\t.dtr_rts\t\t= serial_port_dtr_rts,\n\t.activate\t\t= serial_port_activate,\n\t.shutdown\t\t= serial_port_shutdown,\n};\n\nstatic void store_endpoint(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds,\n\t\t\t\t\tstruct usb_endpoint_descriptor *epd)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tu8 addr = epd->bEndpointAddress;\n\n\tif (usb_endpoint_is_bulk_in(epd)) {\n\t\tif (epds->num_bulk_in == ARRAY_SIZE(epds->bulk_in))\n\t\t\treturn;\n\t\tdev_dbg(dev, \"found bulk in endpoint %02x\\n\", addr);\n\t\tepds->bulk_in[epds->num_bulk_in++] = epd;\n\t} else if (usb_endpoint_is_bulk_out(epd)) {\n\t\tif (epds->num_bulk_out == ARRAY_SIZE(epds->bulk_out))\n\t\t\treturn;\n\t\tdev_dbg(dev, \"found bulk out endpoint %02x\\n\", addr);\n\t\tepds->bulk_out[epds->num_bulk_out++] = epd;\n\t} else if (usb_endpoint_is_int_in(epd)) {\n\t\tif (epds->num_interrupt_in == ARRAY_SIZE(epds->interrupt_in))\n\t\t\treturn;\n\t\tdev_dbg(dev, \"found interrupt in endpoint %02x\\n\", addr);\n\t\tepds->interrupt_in[epds->num_interrupt_in++] = epd;\n\t} else if (usb_endpoint_is_int_out(epd)) {\n\t\tif (epds->num_interrupt_out == ARRAY_SIZE(epds->interrupt_out))\n\t\t\treturn;\n\t\tdev_dbg(dev, \"found interrupt out endpoint %02x\\n\", addr);\n\t\tepds->interrupt_out[epds->num_interrupt_out++] = epd;\n\t}\n}\n\nstatic void find_endpoints(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds,\n\t\t\t\t\tstruct usb_interface *intf)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *epd;\n\tunsigned int i;\n\n\tiface_desc = intf->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tepd = &iface_desc->endpoint[i].desc;\n\t\tstore_endpoint(serial, epds, epd);\n\t}\n}\n\nstatic int setup_port_bulk_in(struct usb_serial_port *port,\n\t\t\t\t\tstruct usb_endpoint_descriptor *epd)\n{\n\tstruct usb_serial_driver *type = port->serial->type;\n\tstruct usb_device *udev = port->serial->dev;\n\tint buffer_size;\n\tint i;\n\n\tbuffer_size = max_t(int, type->bulk_in_size, usb_endpoint_maxp(epd));\n\tport->bulk_in_size = buffer_size;\n\tport->bulk_in_endpointAddress = epd->bEndpointAddress;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {\n\t\tset_bit(i, &port->read_urbs_free);\n\t\tport->read_urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!port->read_urbs[i])\n\t\t\treturn -ENOMEM;\n\t\tport->bulk_in_buffers[i] = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!port->bulk_in_buffers[i])\n\t\t\treturn -ENOMEM;\n\t\tusb_fill_bulk_urb(port->read_urbs[i], udev,\n\t\t\t\tusb_rcvbulkpipe(udev, epd->bEndpointAddress),\n\t\t\t\tport->bulk_in_buffers[i], buffer_size,\n\t\t\t\ttype->read_bulk_callback, port);\n\t}\n\n\tport->read_urb = port->read_urbs[0];\n\tport->bulk_in_buffer = port->bulk_in_buffers[0];\n\n\treturn 0;\n}\n\nstatic int setup_port_bulk_out(struct usb_serial_port *port,\n\t\t\t\t\tstruct usb_endpoint_descriptor *epd)\n{\n\tstruct usb_serial_driver *type = port->serial->type;\n\tstruct usb_device *udev = port->serial->dev;\n\tint buffer_size;\n\tint i;\n\n\tif (kfifo_alloc(&port->write_fifo, PAGE_SIZE, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\tif (type->bulk_out_size)\n\t\tbuffer_size = type->bulk_out_size;\n\telse\n\t\tbuffer_size = usb_endpoint_maxp(epd);\n\tport->bulk_out_size = buffer_size;\n\tport->bulk_out_endpointAddress = epd->bEndpointAddress;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i) {\n\t\tset_bit(i, &port->write_urbs_free);\n\t\tport->write_urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!port->write_urbs[i])\n\t\t\treturn -ENOMEM;\n\t\tport->bulk_out_buffers[i] = kmalloc(buffer_size, GFP_KERNEL);\n\t\tif (!port->bulk_out_buffers[i])\n\t\t\treturn -ENOMEM;\n\t\tusb_fill_bulk_urb(port->write_urbs[i], udev,\n\t\t\t\tusb_sndbulkpipe(udev, epd->bEndpointAddress),\n\t\t\t\tport->bulk_out_buffers[i], buffer_size,\n\t\t\t\ttype->write_bulk_callback, port);\n\t}\n\n\tport->write_urb = port->write_urbs[0];\n\tport->bulk_out_buffer = port->bulk_out_buffers[0];\n\n\treturn 0;\n}\n\nstatic int setup_port_interrupt_in(struct usb_serial_port *port,\n\t\t\t\t\tstruct usb_endpoint_descriptor *epd)\n{\n\tstruct usb_serial_driver *type = port->serial->type;\n\tstruct usb_device *udev = port->serial->dev;\n\tint buffer_size;\n\n\tport->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!port->interrupt_in_urb)\n\t\treturn -ENOMEM;\n\tbuffer_size = usb_endpoint_maxp(epd);\n\tport->interrupt_in_endpointAddress = epd->bEndpointAddress;\n\tport->interrupt_in_buffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (!port->interrupt_in_buffer)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(port->interrupt_in_urb, udev,\n\t\t\tusb_rcvintpipe(udev, epd->bEndpointAddress),\n\t\t\tport->interrupt_in_buffer, buffer_size,\n\t\t\ttype->read_int_callback, port,\n\t\t\tepd->bInterval);\n\n\treturn 0;\n}\n\nstatic int setup_port_interrupt_out(struct usb_serial_port *port,\n\t\t\t\t\tstruct usb_endpoint_descriptor *epd)\n{\n\tstruct usb_serial_driver *type = port->serial->type;\n\tstruct usb_device *udev = port->serial->dev;\n\tint buffer_size;\n\n\tport->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!port->interrupt_out_urb)\n\t\treturn -ENOMEM;\n\tbuffer_size = usb_endpoint_maxp(epd);\n\tport->interrupt_out_size = buffer_size;\n\tport->interrupt_out_endpointAddress = epd->bEndpointAddress;\n\tport->interrupt_out_buffer = kmalloc(buffer_size, GFP_KERNEL);\n\tif (!port->interrupt_out_buffer)\n\t\treturn -ENOMEM;\n\tusb_fill_int_urb(port->interrupt_out_urb, udev,\n\t\t\tusb_sndintpipe(udev, epd->bEndpointAddress),\n\t\t\tport->interrupt_out_buffer, buffer_size,\n\t\t\ttype->write_int_callback, port,\n\t\t\tepd->bInterval);\n\n\treturn 0;\n}\n\nstatic int usb_serial_probe(struct usb_interface *interface,\n\t\t\t       const struct usb_device_id *id)\n{\n\tstruct device *ddev = &interface->dev;\n\tstruct usb_device *dev = interface_to_usbdev(interface);\n\tstruct usb_serial *serial = NULL;\n\tstruct usb_serial_port *port;\n\tstruct usb_serial_endpoints *epds;\n\tstruct usb_serial_driver *type = NULL;\n\tint retval;\n\tint i;\n\tint num_ports = 0;\n\tunsigned char max_endpoints;\n\n\tmutex_lock(&table_lock);\n\ttype = search_serial_device(interface);\n\tif (!type) {\n\t\tmutex_unlock(&table_lock);\n\t\tdev_dbg(ddev, \"none matched\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (!try_module_get(type->driver.owner)) {\n\t\tmutex_unlock(&table_lock);\n\t\tdev_err(ddev, \"module get failed, exiting\\n\");\n\t\treturn -EIO;\n\t}\n\tmutex_unlock(&table_lock);\n\n\tserial = create_serial(dev, interface, type);\n\tif (!serial) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_put_module;\n\t}\n\n\t \n\tif (type->probe) {\n\t\tconst struct usb_device_id *id;\n\n\t\tid = get_iface_id(type, interface);\n\t\tretval = type->probe(serial, id);\n\n\t\tif (retval) {\n\t\t\tdev_dbg(ddev, \"sub driver rejected device\\n\");\n\t\t\tgoto err_release_sibling;\n\t\t}\n\t}\n\n\t \n\tepds = kzalloc(sizeof(*epds), GFP_KERNEL);\n\tif (!epds) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_release_sibling;\n\t}\n\n\tfind_endpoints(serial, epds, interface);\n\tif (serial->sibling)\n\t\tfind_endpoints(serial, epds, serial->sibling);\n\n\tif (epds->num_bulk_in < type->num_bulk_in ||\n\t\t\tepds->num_bulk_out < type->num_bulk_out ||\n\t\t\tepds->num_interrupt_in < type->num_interrupt_in ||\n\t\t\tepds->num_interrupt_out < type->num_interrupt_out) {\n\t\tdev_err(ddev, \"required endpoints missing\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err_free_epds;\n\t}\n\n\tif (type->calc_num_ports) {\n\t\tretval = type->calc_num_ports(serial, epds);\n\t\tif (retval < 0)\n\t\t\tgoto err_free_epds;\n\t\tnum_ports = retval;\n\t}\n\n\tif (!num_ports)\n\t\tnum_ports = type->num_ports;\n\n\tif (num_ports > MAX_NUM_PORTS) {\n\t\tdev_warn(ddev, \"too many ports requested: %d\\n\", num_ports);\n\t\tnum_ports = MAX_NUM_PORTS;\n\t}\n\n\tserial->num_ports = (unsigned char)num_ports;\n\tserial->num_bulk_in = epds->num_bulk_in;\n\tserial->num_bulk_out = epds->num_bulk_out;\n\tserial->num_interrupt_in = epds->num_interrupt_in;\n\tserial->num_interrupt_out = epds->num_interrupt_out;\n\n\t \n\tdev_info(ddev, \"%s converter detected\\n\", type->description);\n\n\t \n\t \n\tmax_endpoints = max(epds->num_bulk_in, epds->num_bulk_out);\n\tmax_endpoints = max(max_endpoints, epds->num_interrupt_in);\n\tmax_endpoints = max(max_endpoints, epds->num_interrupt_out);\n\tmax_endpoints = max(max_endpoints, serial->num_ports);\n\tserial->num_port_pointers = max_endpoints;\n\n\tdev_dbg(ddev, \"setting up %d port structure(s)\\n\", max_endpoints);\n\tfor (i = 0; i < max_endpoints; ++i) {\n\t\tport = kzalloc(sizeof(struct usb_serial_port), GFP_KERNEL);\n\t\tif (!port) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err_free_epds;\n\t\t}\n\t\ttty_port_init(&port->port);\n\t\tport->port.ops = &serial_port_ops;\n\t\tport->serial = serial;\n\t\tspin_lock_init(&port->lock);\n\t\t \n\t\tINIT_WORK(&port->work, usb_serial_port_work);\n\t\tserial->port[i] = port;\n\t\tport->dev.parent = &interface->dev;\n\t\tport->dev.driver = NULL;\n\t\tport->dev.bus = &usb_serial_bus_type;\n\t\tport->dev.release = &usb_serial_port_release;\n\t\tport->dev.groups = usb_serial_port_groups;\n\t\tdevice_initialize(&port->dev);\n\t}\n\n\t \n\tfor (i = 0; i < epds->num_bulk_in; ++i) {\n\t\tretval = setup_port_bulk_in(serial->port[i], epds->bulk_in[i]);\n\t\tif (retval)\n\t\t\tgoto err_free_epds;\n\t}\n\n\tfor (i = 0; i < epds->num_bulk_out; ++i) {\n\t\tretval = setup_port_bulk_out(serial->port[i],\n\t\t\t\tepds->bulk_out[i]);\n\t\tif (retval)\n\t\t\tgoto err_free_epds;\n\t}\n\n\tif (serial->type->read_int_callback) {\n\t\tfor (i = 0; i < epds->num_interrupt_in; ++i) {\n\t\t\tretval = setup_port_interrupt_in(serial->port[i],\n\t\t\t\t\tepds->interrupt_in[i]);\n\t\t\tif (retval)\n\t\t\t\tgoto err_free_epds;\n\t\t}\n\t} else if (epds->num_interrupt_in) {\n\t\tdev_dbg(ddev, \"The device claims to support interrupt in transfers, but read_int_callback is not defined\\n\");\n\t}\n\n\tif (serial->type->write_int_callback) {\n\t\tfor (i = 0; i < epds->num_interrupt_out; ++i) {\n\t\t\tretval = setup_port_interrupt_out(serial->port[i],\n\t\t\t\t\tepds->interrupt_out[i]);\n\t\t\tif (retval)\n\t\t\t\tgoto err_free_epds;\n\t\t}\n\t} else if (epds->num_interrupt_out) {\n\t\tdev_dbg(ddev, \"The device claims to support interrupt out transfers, but write_int_callback is not defined\\n\");\n\t}\n\n\tusb_set_intfdata(interface, serial);\n\n\t \n\tif (type->attach) {\n\t\tretval = type->attach(serial);\n\t\tif (retval < 0)\n\t\t\tgoto err_free_epds;\n\t\tserial->attached = 1;\n\t\tif (retval > 0) {\n\t\t\t \n\t\t\tserial->num_ports = 0;\n\t\t\tgoto exit;\n\t\t}\n\t} else {\n\t\tserial->attached = 1;\n\t}\n\n\tretval = allocate_minors(serial, num_ports);\n\tif (retval) {\n\t\tdev_err(ddev, \"No more free serial minor numbers\\n\");\n\t\tgoto err_free_epds;\n\t}\n\n\t \n\tfor (i = 0; i < num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tdev_set_name(&port->dev, \"ttyUSB%d\", port->minor);\n\t\tdev_dbg(ddev, \"registering %s\\n\", dev_name(&port->dev));\n\t\tdevice_enable_async_suspend(&port->dev);\n\n\t\tretval = device_add(&port->dev);\n\t\tif (retval)\n\t\t\tdev_err(ddev, \"Error registering port device, continuing\\n\");\n\t}\n\n\tif (num_ports > 0)\n\t\tusb_serial_console_init(serial->port[0]->minor);\nexit:\n\tkfree(epds);\n\tmodule_put(type->driver.owner);\n\treturn 0;\n\nerr_free_epds:\n\tkfree(epds);\nerr_release_sibling:\n\trelease_sibling(serial, interface);\n\tusb_serial_put(serial);\nerr_put_module:\n\tmodule_put(type->driver.owner);\n\n\treturn retval;\n}\n\nstatic void usb_serial_disconnect(struct usb_interface *interface)\n{\n\tint i;\n\tstruct usb_serial *serial = usb_get_intfdata(interface);\n\tstruct device *dev = &interface->dev;\n\tstruct usb_serial_port *port;\n\tstruct tty_struct *tty;\n\n\t \n\tif (!serial)\n\t\treturn;\n\n\tusb_serial_console_disconnect(serial);\n\n\tmutex_lock(&serial->disc_mutex);\n\t \n\tserial->disconnected = 1;\n\tmutex_unlock(&serial->disc_mutex);\n\n\tfor (i = 0; i < serial->num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\ttty = tty_port_tty_get(&port->port);\n\t\tif (tty) {\n\t\t\ttty_vhangup(tty);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\tusb_serial_port_poison_urbs(port);\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t\tcancel_work_sync(&port->work);\n\t\tif (device_is_registered(&port->dev))\n\t\t\tdevice_del(&port->dev);\n\t}\n\tif (serial->type->disconnect)\n\t\tserial->type->disconnect(serial);\n\n\trelease_sibling(serial, interface);\n\n\t \n\tusb_serial_put(serial);\n\tdev_info(dev, \"device disconnected\\n\");\n}\n\nint usb_serial_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_serial *serial = usb_get_intfdata(intf);\n\tint i, r;\n\n\t \n\tif (serial->suspend_count++)\n\t\treturn 0;\n\n\t \n\tif (serial->type->suspend) {\n\t\tr = serial->type->suspend(serial, message);\n\t\tif (r < 0) {\n\t\t\tserial->suspend_count--;\n\t\t\treturn r;\n\t\t}\n\t}\n\n\tfor (i = 0; i < serial->num_ports; ++i)\n\t\tusb_serial_port_poison_urbs(serial->port[i]);\n\n\treturn 0;\n}\nEXPORT_SYMBOL(usb_serial_suspend);\n\nstatic void usb_serial_unpoison_port_urbs(struct usb_serial *serial)\n{\n\tint i;\n\n\tfor (i = 0; i < serial->num_ports; ++i)\n\t\tusb_serial_port_unpoison_urbs(serial->port[i]);\n}\n\nint usb_serial_resume(struct usb_interface *intf)\n{\n\tstruct usb_serial *serial = usb_get_intfdata(intf);\n\tint rv;\n\n\t \n\tif (--serial->suspend_count)\n\t\treturn 0;\n\n\tusb_serial_unpoison_port_urbs(serial);\n\n\tif (serial->type->resume)\n\t\trv = serial->type->resume(serial);\n\telse\n\t\trv = usb_serial_generic_resume(serial);\n\n\treturn rv;\n}\nEXPORT_SYMBOL(usb_serial_resume);\n\nstatic int usb_serial_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_serial *serial = usb_get_intfdata(intf);\n\tint rv;\n\n\t \n\tif (--serial->suspend_count)\n\t\treturn 0;\n\n\tusb_serial_unpoison_port_urbs(serial);\n\n\tif (serial->type->reset_resume) {\n\t\trv = serial->type->reset_resume(serial);\n\t} else {\n\t\trv = -EOPNOTSUPP;\n\t\tintf->needs_binding = 1;\n\t}\n\n\treturn rv;\n}\n\nstatic const struct tty_operations serial_ops = {\n\t.open =\t\t\tserial_open,\n\t.close =\t\tserial_close,\n\t.write =\t\tserial_write,\n\t.hangup =\t\tserial_hangup,\n\t.write_room =\t\tserial_write_room,\n\t.ioctl =\t\tserial_ioctl,\n\t.set_termios =\t\tserial_set_termios,\n\t.throttle =\t\tserial_throttle,\n\t.unthrottle =\t\tserial_unthrottle,\n\t.break_ctl =\t\tserial_break,\n\t.chars_in_buffer =\tserial_chars_in_buffer,\n\t.wait_until_sent =\tserial_wait_until_sent,\n\t.tiocmget =\t\tserial_tiocmget,\n\t.tiocmset =\t\tserial_tiocmset,\n\t.get_icount =\t\tserial_get_icount,\n\t.set_serial =\t\tserial_set_serial,\n\t.get_serial =\t\tserial_get_serial,\n\t.cleanup =\t\tserial_cleanup,\n\t.install =\t\tserial_install,\n\t.proc_show =\t\tserial_proc_show,\n};\n\n\nstruct tty_driver *usb_serial_tty_driver;\n\nstatic int __init usb_serial_init(void)\n{\n\tint result;\n\n\tusb_serial_tty_driver = tty_alloc_driver(USB_SERIAL_TTY_MINORS,\n\t\t\tTTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(usb_serial_tty_driver))\n\t\treturn PTR_ERR(usb_serial_tty_driver);\n\n\t \n\tresult = bus_register(&usb_serial_bus_type);\n\tif (result) {\n\t\tpr_err(\"%s - registering bus driver failed\\n\", __func__);\n\t\tgoto err_put_driver;\n\t}\n\n\tusb_serial_tty_driver->driver_name = \"usbserial\";\n\tusb_serial_tty_driver->name = \"ttyUSB\";\n\tusb_serial_tty_driver->major = USB_SERIAL_TTY_MAJOR;\n\tusb_serial_tty_driver->minor_start = 0;\n\tusb_serial_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tusb_serial_tty_driver->subtype = SERIAL_TYPE_NORMAL;\n\tusb_serial_tty_driver->init_termios = tty_std_termios;\n\tusb_serial_tty_driver->init_termios.c_cflag = B9600 | CS8 | CREAD\n\t\t\t\t\t\t\t| HUPCL | CLOCAL;\n\tusb_serial_tty_driver->init_termios.c_ispeed = 9600;\n\tusb_serial_tty_driver->init_termios.c_ospeed = 9600;\n\ttty_set_operations(usb_serial_tty_driver, &serial_ops);\n\tresult = tty_register_driver(usb_serial_tty_driver);\n\tif (result) {\n\t\tpr_err(\"%s - tty_register_driver failed\\n\", __func__);\n\t\tgoto err_unregister_bus;\n\t}\n\n\t \n\tresult = usb_serial_generic_register();\n\tif (result < 0) {\n\t\tpr_err(\"%s - registering generic driver failed\\n\", __func__);\n\t\tgoto err_unregister_driver;\n\t}\n\n\treturn result;\n\nerr_unregister_driver:\n\ttty_unregister_driver(usb_serial_tty_driver);\nerr_unregister_bus:\n\tbus_unregister(&usb_serial_bus_type);\nerr_put_driver:\n\tpr_err(\"%s - returning with error %d\\n\", __func__, result);\n\ttty_driver_kref_put(usb_serial_tty_driver);\n\treturn result;\n}\n\n\nstatic void __exit usb_serial_exit(void)\n{\n\tusb_serial_console_exit();\n\n\tusb_serial_generic_deregister();\n\n\ttty_unregister_driver(usb_serial_tty_driver);\n\ttty_driver_kref_put(usb_serial_tty_driver);\n\tbus_unregister(&usb_serial_bus_type);\n\tidr_destroy(&serial_minors);\n}\n\n\nmodule_init(usb_serial_init);\nmodule_exit(usb_serial_exit);\n\n#define set_to_generic_if_null(type, function)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tif (!type->function) {\t\t\t\t\t\\\n\t\t\ttype->function = usb_serial_generic_##function;\t\\\n\t\t\tpr_debug(\"%s: using generic \" #function\t\"\\n\",\t\\\n\t\t\t\t\t\ttype->driver.name);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\nstatic void usb_serial_operations_init(struct usb_serial_driver *device)\n{\n\tset_to_generic_if_null(device, open);\n\tset_to_generic_if_null(device, write);\n\tset_to_generic_if_null(device, close);\n\tset_to_generic_if_null(device, write_room);\n\tset_to_generic_if_null(device, chars_in_buffer);\n\tif (device->tx_empty)\n\t\tset_to_generic_if_null(device, wait_until_sent);\n\tset_to_generic_if_null(device, read_bulk_callback);\n\tset_to_generic_if_null(device, write_bulk_callback);\n\tset_to_generic_if_null(device, process_read_urb);\n\tset_to_generic_if_null(device, prepare_write_buffer);\n}\n\nstatic int usb_serial_register(struct usb_serial_driver *driver)\n{\n\tint retval;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (!driver->description)\n\t\tdriver->description = driver->driver.name;\n\tif (!driver->usb_driver) {\n\t\tWARN(1, \"Serial driver %s has no usb_driver\\n\",\n\t\t\t\tdriver->description);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tdriver->driver.suppress_bind_attrs = true;\n\n\tusb_serial_operations_init(driver);\n\n\t \n\tmutex_lock(&table_lock);\n\tlist_add(&driver->driver_list, &usb_serial_driver_list);\n\n\tretval = usb_serial_bus_register(driver);\n\tif (retval) {\n\t\tpr_err(\"problem %d when registering driver %s\\n\", retval, driver->description);\n\t\tlist_del(&driver->driver_list);\n\t} else {\n\t\tpr_info(\"USB Serial support registered for %s\\n\", driver->description);\n\t}\n\tmutex_unlock(&table_lock);\n\treturn retval;\n}\n\nstatic void usb_serial_deregister(struct usb_serial_driver *device)\n{\n\tpr_info(\"USB Serial deregistering driver %s\\n\", device->description);\n\n\tmutex_lock(&table_lock);\n\tlist_del(&device->driver_list);\n\tmutex_unlock(&table_lock);\n\n\tusb_serial_bus_deregister(device);\n}\n\n \nint usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[],\n\t\t\t\tconst char *name,\n\t\t\t\tconst struct usb_device_id *id_table)\n{\n\tint rc;\n\tstruct usb_driver *udriver;\n\tstruct usb_serial_driver * const *sd;\n\n\t \n\tudriver = kzalloc(sizeof(*udriver), GFP_KERNEL);\n\tif (!udriver)\n\t\treturn -ENOMEM;\n\n\tudriver->name = name;\n\tudriver->no_dynamic_id = 1;\n\tudriver->supports_autosuspend = 1;\n\tudriver->suspend = usb_serial_suspend;\n\tudriver->resume = usb_serial_resume;\n\tudriver->probe = usb_serial_probe;\n\tudriver->disconnect = usb_serial_disconnect;\n\n\t \n\tfor (sd = serial_drivers; *sd; ++sd) {\n\t\tif ((*sd)->reset_resume) {\n\t\t\tudriver->reset_resume = usb_serial_reset_resume;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = usb_register(udriver);\n\tif (rc)\n\t\tgoto err_free_driver;\n\n\tfor (sd = serial_drivers; *sd; ++sd) {\n\t\t(*sd)->usb_driver = udriver;\n\t\trc = usb_serial_register(*sd);\n\t\tif (rc)\n\t\t\tgoto err_deregister_drivers;\n\t}\n\n\t \n\tudriver->id_table = id_table;\n\trc = driver_attach(&udriver->drvwrap.driver);\n\treturn 0;\n\nerr_deregister_drivers:\n\twhile (sd-- > serial_drivers)\n\t\tusb_serial_deregister(*sd);\n\tusb_deregister(udriver);\nerr_free_driver:\n\tkfree(udriver);\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_serial_register_drivers);\n\n \nvoid usb_serial_deregister_drivers(struct usb_serial_driver *const serial_drivers[])\n{\n\tstruct usb_driver *udriver = (*serial_drivers)->usb_driver;\n\n\tfor (; *serial_drivers; ++serial_drivers)\n\t\tusb_serial_deregister(*serial_drivers);\n\tusb_deregister(udriver);\n\tkfree(udriver);\n}\nEXPORT_SYMBOL_GPL(usb_serial_deregister_drivers);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}