{
  "module_name": "cyberjack.c",
  "hash_id": "592a76dea797d8a6336d40d7eea75de982efbca967457075ec85d3df6561bd48",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/cyberjack.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define CYBERJACK_LOCAL_BUF_SIZE 32\n\n#define DRIVER_AUTHOR \"Matthias Bruestle\"\n#define DRIVER_DESC \"REINER SCT cyberJack pinpad/e-com USB Chipcard Reader Driver\"\n\n\n#define CYBERJACK_VENDOR_ID\t0x0C4B\n#define CYBERJACK_PRODUCT_ID\t0x0100\n\n \nstatic int cyberjack_port_probe(struct usb_serial_port *port);\nstatic void cyberjack_port_remove(struct usb_serial_port *port);\nstatic int  cyberjack_open(struct tty_struct *tty,\n\tstruct usb_serial_port *port);\nstatic void cyberjack_close(struct usb_serial_port *port);\nstatic int cyberjack_write(struct tty_struct *tty,\n\tstruct usb_serial_port *port, const unsigned char *buf, int count);\nstatic unsigned int cyberjack_write_room(struct tty_struct *tty);\nstatic void cyberjack_read_int_callback(struct urb *urb);\nstatic void cyberjack_read_bulk_callback(struct urb *urb);\nstatic void cyberjack_write_bulk_callback(struct urb *urb);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(CYBERJACK_VENDOR_ID, CYBERJACK_PRODUCT_ID) },\n\t{ }\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver cyberjack_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"cyberjack\",\n\t},\n\t.description =\t\t\"Reiner SCT Cyberjack USB card reader\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.port_probe =\t\tcyberjack_port_probe,\n\t.port_remove =\t\tcyberjack_port_remove,\n\t.open =\t\t\tcyberjack_open,\n\t.close =\t\tcyberjack_close,\n\t.write =\t\tcyberjack_write,\n\t.write_room =\t\tcyberjack_write_room,\n\t.read_int_callback =\tcyberjack_read_int_callback,\n\t.read_bulk_callback =\tcyberjack_read_bulk_callback,\n\t.write_bulk_callback =\tcyberjack_write_bulk_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&cyberjack_device, NULL\n};\n\nstruct cyberjack_private {\n\tspinlock_t\tlock;\t\t \n\tshort\t\trdtodo;\t\t \n\tunsigned char\twrbuf[5*64];\t \n\tshort\t\twrfilled;\t \n\tshort\t\twrsent;\t\t \n};\n\nstatic int cyberjack_port_probe(struct usb_serial_port *port)\n{\n\tstruct cyberjack_private *priv;\n\tint result;\n\n\tpriv = kmalloc(sizeof(struct cyberjack_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\tpriv->rdtodo = 0;\n\tpriv->wrfilled = 0;\n\tpriv->wrsent = 0;\n\n\tusb_set_serial_port_data(port, priv);\n\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result)\n\t\tdev_err(&port->dev, \"usb_submit_urb(read int) failed\\n\");\n\n\treturn 0;\n}\n\nstatic void cyberjack_port_remove(struct usb_serial_port *port)\n{\n\tstruct cyberjack_private *priv;\n\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int  cyberjack_open(struct tty_struct *tty,\n\t\t\t\t\tstruct usb_serial_port *port)\n{\n\tstruct cyberjack_private *priv;\n\tunsigned long flags;\n\n\tdev_dbg(&port->dev, \"%s - usb_clear_halt\\n\", __func__);\n\tusb_clear_halt(port->serial->dev, port->write_urb->pipe);\n\n\tpriv = usb_get_serial_port_data(port);\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->rdtodo = 0;\n\tpriv->wrfilled = 0;\n\tpriv->wrsent = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn 0;\n}\n\nstatic void cyberjack_close(struct usb_serial_port *port)\n{\n\tusb_kill_urb(port->write_urb);\n\tusb_kill_urb(port->read_urb);\n}\n\nstatic int cyberjack_write(struct tty_struct *tty,\n\tstruct usb_serial_port *port, const unsigned char *buf, int count)\n{\n\tstruct device *dev = &port->dev;\n\tstruct cyberjack_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint result;\n\tint wrexpected;\n\n\tif (count == 0) {\n\t\tdev_dbg(dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (!test_and_clear_bit(0, &port->write_urbs_free)) {\n\t\tdev_dbg(dev, \"%s - already writing\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\tif (count+priv->wrfilled > sizeof(priv->wrbuf)) {\n\t\t \n\t\tpriv->wrfilled = 0;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tset_bit(0, &port->write_urbs_free);\n\t\treturn 0;\n\t}\n\n\t \n\tmemcpy(priv->wrbuf + priv->wrfilled, buf, count);\n\n\tusb_serial_debug_data(dev, __func__, count, priv->wrbuf + priv->wrfilled);\n\tpriv->wrfilled += count;\n\n\tif (priv->wrfilled >= 3) {\n\t\twrexpected = ((int)priv->wrbuf[2]<<8)+priv->wrbuf[1]+3;\n\t\tdev_dbg(dev, \"%s - expected data: %d\\n\", __func__, wrexpected);\n\t} else\n\t\twrexpected = sizeof(priv->wrbuf);\n\n\tif (priv->wrfilled >= wrexpected) {\n\t\t \n\t\tint length;\n\n\t\tdev_dbg(dev, \"%s - transmitting data (frame 1)\\n\", __func__);\n\t\tlength = (wrexpected > port->bulk_out_size) ?\n\t\t\t\t\tport->bulk_out_size : wrexpected;\n\n\t\tmemcpy(port->write_urb->transfer_buffer, priv->wrbuf, length);\n\t\tpriv->wrsent = length;\n\n\t\t \n\t\tport->write_urb->transfer_buffer_length = length;\n\n\t\t \n\t\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\t\tif (result) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\t\t \n\t\t\tpriv->wrfilled = 0;\n\t\t\tpriv->wrsent = 0;\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tset_bit(0, &port->write_urbs_free);\n\t\t\treturn 0;\n\t\t}\n\n\t\tdev_dbg(dev, \"%s - priv->wrsent=%d\\n\", __func__, priv->wrsent);\n\t\tdev_dbg(dev, \"%s - priv->wrfilled=%d\\n\", __func__, priv->wrfilled);\n\n\t\tif (priv->wrsent >= priv->wrfilled) {\n\t\t\tdev_dbg(dev, \"%s - buffer cleaned\\n\", __func__);\n\t\t\tmemset(priv->wrbuf, 0, sizeof(priv->wrbuf));\n\t\t\tpriv->wrfilled = 0;\n\t\t\tpriv->wrsent = 0;\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn count;\n}\n\nstatic unsigned int cyberjack_write_room(struct tty_struct *tty)\n{\n\t \n\treturn CYBERJACK_LOCAL_BUF_SIZE;\n}\n\nstatic void cyberjack_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cyberjack_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint result;\n\n\t \n\tif (status)\n\t\treturn;\n\n\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\n\t \n\tif (urb->actual_length == 4 && data[0] == 0x01) {\n\t\tshort old_rdtodo;\n\n\t\t \n\t\tunsigned short size = ((unsigned short)data[3]<<8)+data[2]+3;\n\n\t\tspin_lock_irqsave(&priv->lock, flags);\n\n\t\told_rdtodo = priv->rdtodo;\n\n\t\tif (old_rdtodo > SHRT_MAX - size) {\n\t\t\tdev_dbg(dev, \"Too many bulk_in urbs to do.\\n\");\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto resubmit;\n\t\t}\n\n\t\t \n\t\tpriv->rdtodo += size;\n\n\t\tdev_dbg(dev, \"%s - rdtodo: %d\\n\", __func__, priv->rdtodo);\n\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t\tif (!old_rdtodo) {\n\t\t\tresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\t\t\tif (result)\n\t\t\t\tdev_err(dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t\t\t__func__, result);\n\t\t\tdev_dbg(dev, \"%s - usb_submit_urb(read urb)\\n\", __func__);\n\t\t}\n\t}\n\nresubmit:\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&port->dev, \"usb_submit_urb(read int) failed\\n\");\n\tdev_dbg(dev, \"%s - usb_submit_urb(int urb)\\n\", __func__);\n}\n\nstatic void cyberjack_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cyberjack_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned long flags;\n\tshort todo;\n\tint result;\n\tint status = urb->status;\n\n\tusb_serial_debug_data(dev, __func__, urb->actual_length, data);\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - nonzero read bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tpriv->rdtodo -= urb->actual_length;\n\t \n\tif (priv->rdtodo < 0)\n\t\tpriv->rdtodo = 0;\n\ttodo = priv->rdtodo;\n\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(dev, \"%s - rdtodo: %d\\n\", __func__, todo);\n\n\t \n\tif (todo  ) {\n\t\tresult = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\t\tif (result)\n\t\t\tdev_err(dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\tdev_dbg(dev, \"%s - usb_submit_urb(read urb)\\n\", __func__);\n\t}\n}\n\nstatic void cyberjack_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cyberjack_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tint status = urb->status;\n\tunsigned long flags;\n\tbool resubmitted = false;\n\n\tif (status) {\n\t\tdev_dbg(dev, \"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tset_bit(0, &port->write_urbs_free);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tif (priv->wrfilled) {\n\t\tint length, blksize, result;\n\n\t\tdev_dbg(dev, \"%s - transmitting data (frame n)\\n\", __func__);\n\n\t\tlength = ((priv->wrfilled - priv->wrsent) > port->bulk_out_size) ?\n\t\t\tport->bulk_out_size : (priv->wrfilled - priv->wrsent);\n\n\t\tmemcpy(port->write_urb->transfer_buffer,\n\t\t\t\t\tpriv->wrbuf + priv->wrsent, length);\n\t\tpriv->wrsent += length;\n\n\t\t \n\t\tport->write_urb->transfer_buffer_length = length;\n\n\t\t \n\t\tresult = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\t\tif (result) {\n\t\t\tdev_err(dev, \"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\t\t \n\t\t\tpriv->wrfilled = 0;\n\t\t\tpriv->wrsent = 0;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tresubmitted = true;\n\n\t\tdev_dbg(dev, \"%s - priv->wrsent=%d\\n\", __func__, priv->wrsent);\n\t\tdev_dbg(dev, \"%s - priv->wrfilled=%d\\n\", __func__, priv->wrfilled);\n\n\t\tblksize = ((int)priv->wrbuf[2]<<8)+priv->wrbuf[1]+3;\n\n\t\tif (priv->wrsent >= priv->wrfilled ||\n\t\t\t\t\tpriv->wrsent >= blksize) {\n\t\t\tdev_dbg(dev, \"%s - buffer cleaned\\n\", __func__);\n\t\t\tmemset(priv->wrbuf, 0, sizeof(priv->wrbuf));\n\t\t\tpriv->wrfilled = 0;\n\t\t\tpriv->wrsent = 0;\n\t\t}\n\t}\n\nexit:\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tif (!resubmitted)\n\t\tset_bit(0, &port->write_urbs_free);\n\tusb_serial_port_softint(port);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}