{
  "module_name": "cp210x.c",
  "hash_id": "c22394a9a6cfa5f6832616ce816a4c7a2f119985e260dffde174a56e78e75e18",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/cp210x.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/gpio/driver.h>\n#include <linux/bitops.h>\n#include <linux/mutex.h>\n\n#define DRIVER_DESC \"Silicon Labs CP210x RS232 serial adaptor driver\"\n\n \nstatic int cp210x_open(struct tty_struct *tty, struct usb_serial_port *);\nstatic void cp210x_close(struct usb_serial_port *);\nstatic void cp210x_change_speed(struct tty_struct *, struct usb_serial_port *,\n\t\t\t\tconst struct ktermios *);\nstatic void cp210x_set_termios(struct tty_struct *, struct usb_serial_port *,\n\t\t\t       const struct ktermios *);\nstatic bool cp210x_tx_empty(struct usb_serial_port *port);\nstatic int cp210x_tiocmget(struct tty_struct *);\nstatic int cp210x_tiocmset(struct tty_struct *, unsigned int, unsigned int);\nstatic int cp210x_tiocmset_port(struct usb_serial_port *port,\n\t\tunsigned int, unsigned int);\nstatic int cp210x_break_ctl(struct tty_struct *, int);\nstatic int cp210x_attach(struct usb_serial *);\nstatic void cp210x_disconnect(struct usb_serial *);\nstatic void cp210x_release(struct usb_serial *);\nstatic int cp210x_port_probe(struct usb_serial_port *);\nstatic void cp210x_port_remove(struct usb_serial_port *);\nstatic void cp210x_dtr_rts(struct usb_serial_port *port, int on);\nstatic void cp210x_process_read_urb(struct urb *urb);\nstatic void cp210x_enable_event_mode(struct usb_serial_port *port);\nstatic void cp210x_disable_event_mode(struct usb_serial_port *port);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x0404, 0x034C) },\t \n\t{ USB_DEVICE(0x045B, 0x0053) },  \n\t{ USB_DEVICE(0x0471, 0x066A) },  \n\t{ USB_DEVICE(0x0489, 0xE000) },  \n\t{ USB_DEVICE(0x0489, 0xE003) },  \n\t{ USB_DEVICE(0x0745, 0x1000) },  \n\t{ USB_DEVICE(0x0846, 0x1100) },  \n\t{ USB_DEVICE(0x08e6, 0x5501) },  \n\t{ USB_DEVICE(0x08FD, 0x000A) },  \n\t{ USB_DEVICE(0x0908, 0x0070) },  \n\t{ USB_DEVICE(0x0908, 0x01FF) },  \n\t{ USB_DEVICE(0x0988, 0x0578) },  \n\t{ USB_DEVICE(0x0B00, 0x3070) },  \n\t{ USB_DEVICE(0x0BED, 0x1100) },  \n\t{ USB_DEVICE(0x0BED, 0x1101) },  \n\t{ USB_DEVICE(0x0FCF, 0x1003) },  \n\t{ USB_DEVICE(0x0FCF, 0x1004) },  \n\t{ USB_DEVICE(0x0FCF, 0x1006) },  \n\t{ USB_DEVICE(0x0FDE, 0xCA05) },  \n\t{ USB_DEVICE(0x106F, 0x0003) },\t \n\t{ USB_DEVICE(0x10A6, 0xAA26) },  \n\t{ USB_DEVICE(0x10AB, 0x10C5) },  \n\t{ USB_DEVICE(0x10B5, 0xAC70) },  \n\t{ USB_DEVICE(0x10C4, 0x0F91) },  \n\t{ USB_DEVICE(0x10C4, 0x1101) },  \n\t{ USB_DEVICE(0x10C4, 0x1601) },  \n\t{ USB_DEVICE(0x10C4, 0x800A) },  \n\t{ USB_DEVICE(0x10C4, 0x803B) },  \n\t{ USB_DEVICE(0x10C4, 0x8044) },  \n\t{ USB_DEVICE(0x10C4, 0x804E) },  \n\t{ USB_DEVICE(0x10C4, 0x8053) },  \n\t{ USB_DEVICE(0x10C4, 0x8054) },  \n\t{ USB_DEVICE(0x10C4, 0x8056) },  \n\t{ USB_DEVICE(0x10C4, 0x8066) },  \n\t{ USB_DEVICE(0x10C4, 0x806F) },  \n\t{ USB_DEVICE(0x10C4, 0x807A) },  \n\t{ USB_DEVICE(0x10C4, 0x80C4) },  \n\t{ USB_DEVICE(0x10C4, 0x80CA) },  \n\t{ USB_DEVICE(0x10C4, 0x80DD) },  \n\t{ USB_DEVICE(0x10C4, 0x80F6) },  \n\t{ USB_DEVICE(0x10C4, 0x8115) },  \n\t{ USB_DEVICE(0x10C4, 0x813D) },  \n\t{ USB_DEVICE(0x10C4, 0x813F) },  \n\t{ USB_DEVICE(0x10C4, 0x814A) },  \n\t{ USB_DEVICE(0x10C4, 0x814B) },  \n\t{ USB_DEVICE(0x2405, 0x0003) },  \n\t{ USB_DEVICE(0x10C4, 0x8156) },  \n\t{ USB_DEVICE(0x10C4, 0x815E) },  \n\t{ USB_DEVICE(0x10C4, 0x815F) },  \n\t{ USB_DEVICE(0x10C4, 0x817C) },  \n\t{ USB_DEVICE(0x10C4, 0x817D) },  \n\t{ USB_DEVICE(0x10C4, 0x817E) },  \n\t{ USB_DEVICE(0x10C4, 0x818B) },  \n\t{ USB_DEVICE(0x10C4, 0x819F) },  \n\t{ USB_DEVICE(0x10C4, 0x81A6) },  \n\t{ USB_DEVICE(0x10C4, 0x81A9) },  \n\t{ USB_DEVICE(0x10C4, 0x81AC) },  \n\t{ USB_DEVICE(0x10C4, 0x81AD) },  \n\t{ USB_DEVICE(0x10C4, 0x81C8) },  \n\t{ USB_DEVICE(0x10C4, 0x81D7) },  \n\t{ USB_DEVICE(0x10C4, 0x81E2) },  \n\t{ USB_DEVICE(0x10C4, 0x81E7) },  \n\t{ USB_DEVICE(0x10C4, 0x81E8) },  \n\t{ USB_DEVICE(0x10C4, 0x81F2) },  \n\t{ USB_DEVICE(0x10C4, 0x8218) },  \n\t{ USB_DEVICE(0x10C4, 0x822B) },  \n\t{ USB_DEVICE(0x10C4, 0x826B) },  \n\t{ USB_DEVICE(0x10C4, 0x8281) },  \n\t{ USB_DEVICE(0x10C4, 0x8293) },  \n\t{ USB_DEVICE(0x10C4, 0x82AA) },  \n\t{ USB_DEVICE(0x10C4, 0x82EF) },  \n\t{ USB_DEVICE(0x10C4, 0x82F1) },  \n\t{ USB_DEVICE(0x10C4, 0x82F2) },  \n\t{ USB_DEVICE(0x10C4, 0x82F4) },  \n\t{ USB_DEVICE(0x10C4, 0x82F9) },  \n\t{ USB_DEVICE(0x10C4, 0x8341) },  \n\t{ USB_DEVICE(0x10C4, 0x8382) },  \n\t{ USB_DEVICE(0x10C4, 0x83A8) },  \n\t{ USB_DEVICE(0x10C4, 0x83AA) },  \n\t{ USB_DEVICE(0x10C4, 0x83D8) },  \n\t{ USB_DEVICE(0x10C4, 0x8411) },  \n\t{ USB_DEVICE(0x10C4, 0x8414) },  \n\t{ USB_DEVICE(0x10C4, 0x8418) },  \n\t{ USB_DEVICE(0x10C4, 0x846E) },  \n\t{ USB_DEVICE(0x10C4, 0x8470) },  \n\t{ USB_DEVICE(0x10C4, 0x8477) },  \n\t{ USB_DEVICE(0x10C4, 0x84B6) },  \n\t{ USB_DEVICE(0x10C4, 0x851E) },  \n\t{ USB_DEVICE(0x10C4, 0x85A7) },  \n\t{ USB_DEVICE(0x10C4, 0x85B8) },  \n\t{ USB_DEVICE(0x10C4, 0x85EA) },  \n\t{ USB_DEVICE(0x10C4, 0x85EB) },  \n\t{ USB_DEVICE(0x10C4, 0x85F8) },  \n\t{ USB_DEVICE(0x10C4, 0x8664) },  \n\t{ USB_DEVICE(0x10C4, 0x8665) },  \n\t{ USB_DEVICE(0x10C4, 0x8856) },\t \n\t{ USB_DEVICE(0x10C4, 0x8857) },\t \n\t{ USB_DEVICE(0x10C4, 0x88A4) },  \n\t{ USB_DEVICE(0x10C4, 0x88A5) },  \n\t{ USB_DEVICE(0x10C4, 0x88D8) },  \n\t{ USB_DEVICE(0x10C4, 0x88FB) },  \n\t{ USB_DEVICE(0x10C4, 0x8938) },  \n\t{ USB_DEVICE(0x10C4, 0x8946) },  \n\t{ USB_DEVICE(0x10C4, 0x8962) },  \n\t{ USB_DEVICE(0x10C4, 0x8977) },\t \n\t{ USB_DEVICE(0x10C4, 0x8998) },  \n\t{ USB_DEVICE(0x10C4, 0x89A4) },  \n\t{ USB_DEVICE(0x10C4, 0x89FB) },  \n\t{ USB_DEVICE(0x10C4, 0x8A2A) },  \n\t{ USB_DEVICE(0x10C4, 0x8A5B) },  \n\t{ USB_DEVICE(0x10C4, 0x8A5E) },  \n\t{ USB_DEVICE(0x10C4, 0x8B34) },  \n\t{ USB_DEVICE(0x10C4, 0xEA60) },  \n\t{ USB_DEVICE(0x10C4, 0xEA61) },  \n\t{ USB_DEVICE(0x10C4, 0xEA63) },  \n\t{ USB_DEVICE(0x10C4, 0xEA70) },  \n\t{ USB_DEVICE(0x10C4, 0xEA71) },  \n\t{ USB_DEVICE(0x10C4, 0xEA7A) },  \n\t{ USB_DEVICE(0x10C4, 0xEA7B) },  \n\t{ USB_DEVICE(0x10C4, 0xF001) },  \n\t{ USB_DEVICE(0x10C4, 0xF002) },  \n\t{ USB_DEVICE(0x10C4, 0xF003) },  \n\t{ USB_DEVICE(0x10C4, 0xF004) },  \n\t{ USB_DEVICE(0x10C5, 0xEA61) },  \n\t{ USB_DEVICE(0x10CE, 0xEA6A) },  \n\t{ USB_DEVICE(0x12B8, 0xEC60) },  \n\t{ USB_DEVICE(0x12B8, 0xEC62) },  \n\t{ USB_DEVICE(0x13AD, 0x9999) },  \n\t{ USB_DEVICE(0x1555, 0x0004) },  \n\t{ USB_DEVICE(0x155A, 0x1006) },\t \n\t{ USB_DEVICE(0x166A, 0x0201) },  \n\t{ USB_DEVICE(0x166A, 0x0301) },  \n\t{ USB_DEVICE(0x166A, 0x0303) },  \n\t{ USB_DEVICE(0x166A, 0x0304) },  \n\t{ USB_DEVICE(0x166A, 0x0305) },  \n\t{ USB_DEVICE(0x166A, 0x0401) },  \n\t{ USB_DEVICE(0x166A, 0x0101) },  \n\t{ USB_DEVICE(0x16C0, 0x09B0) },  \n\t{ USB_DEVICE(0x16C0, 0x09B1) },  \n\t{ USB_DEVICE(0x16D6, 0x0001) },  \n\t{ USB_DEVICE(0x16DC, 0x0010) },  \n\t{ USB_DEVICE(0x16DC, 0x0011) },  \n\t{ USB_DEVICE(0x16DC, 0x0012) },  \n\t{ USB_DEVICE(0x16DC, 0x0015) },  \n\t{ USB_DEVICE(0x17A8, 0x0001) },  \n\t{ USB_DEVICE(0x17A8, 0x0005) },  \n\t{ USB_DEVICE(0x17A8, 0x0011) },  \n\t{ USB_DEVICE(0x17A8, 0x0013) },  \n\t{ USB_DEVICE(0x17A8, 0x0101) },  \n\t{ USB_DEVICE(0x17A8, 0x0102) },  \n\t{ USB_DEVICE(0x17F4, 0xAAAA) },  \n\t{ USB_DEVICE(0x1843, 0x0200) },  \n\t{ USB_DEVICE(0x18EF, 0xE00F) },  \n\t{ USB_DEVICE(0x18EF, 0xE025) },  \n\t{ USB_DEVICE(0x18EF, 0xE030) },  \n\t{ USB_DEVICE(0x18EF, 0xE032) },  \n\t{ USB_DEVICE(0x1901, 0x0190) },  \n\t{ USB_DEVICE(0x1901, 0x0193) },  \n\t{ USB_DEVICE(0x1901, 0x0194) },\t \n\t{ USB_DEVICE(0x1901, 0x0195) },\t \n\t{ USB_DEVICE(0x1901, 0x0196) },\t \n\t{ USB_DEVICE(0x1901, 0x0197) },  \n\t{ USB_DEVICE(0x1901, 0x0198) },  \n\t{ USB_DEVICE(0x199B, 0xBA30) },  \n\t{ USB_DEVICE(0x19CF, 0x3000) },  \n\t{ USB_DEVICE(0x1ADB, 0x0001) },  \n\t{ USB_DEVICE(0x1B1C, 0x1C00) },  \n\t{ USB_DEVICE(0x1BA4, 0x0002) },\t \n\t{ USB_DEVICE(0x1BE3, 0x07A6) },  \n\t{ USB_DEVICE(0x1D6F, 0x0010) },  \n\t{ USB_DEVICE(0x1E29, 0x0102) },  \n\t{ USB_DEVICE(0x1E29, 0x0501) },  \n\t{ USB_DEVICE(0x1FB9, 0x0100) },  \n\t{ USB_DEVICE(0x1FB9, 0x0200) },  \n\t{ USB_DEVICE(0x1FB9, 0x0201) },  \n\t{ USB_DEVICE(0x1FB9, 0x0202) },  \n\t{ USB_DEVICE(0x1FB9, 0x0203) },  \n\t{ USB_DEVICE(0x1FB9, 0x0300) },  \n\t{ USB_DEVICE(0x1FB9, 0x0301) },  \n\t{ USB_DEVICE(0x1FB9, 0x0302) },  \n\t{ USB_DEVICE(0x1FB9, 0x0303) },  \n\t{ USB_DEVICE(0x1FB9, 0x0400) },  \n\t{ USB_DEVICE(0x1FB9, 0x0401) },  \n\t{ USB_DEVICE(0x1FB9, 0x0402) },  \n\t{ USB_DEVICE(0x1FB9, 0x0403) },  \n\t{ USB_DEVICE(0x1FB9, 0x0404) },  \n\t{ USB_DEVICE(0x1FB9, 0x0600) },  \n\t{ USB_DEVICE(0x1FB9, 0x0601) },  \n\t{ USB_DEVICE(0x1FB9, 0x0602) },  \n\t{ USB_DEVICE(0x1FB9, 0x0700) },  \n\t{ USB_DEVICE(0x1FB9, 0x0701) },  \n\t{ USB_DEVICE(0x2184, 0x0030) },  \n\t{ USB_DEVICE(0x2626, 0xEA60) },  \n\t{ USB_DEVICE(0x3195, 0xF190) },  \n\t{ USB_DEVICE(0x3195, 0xF280) },  \n\t{ USB_DEVICE(0x3195, 0xF281) },  \n\t{ USB_DEVICE(0x3923, 0x7A0B) },  \n\t{ USB_DEVICE(0x413C, 0x9500) },  \n\t{ }  \n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct cp210x_serial_private {\n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip\tgc;\n\tbool\t\t\tgpio_registered;\n\tu16\t\t\tgpio_pushpull;\n\tu16\t\t\tgpio_altfunc;\n\tu16\t\t\tgpio_input;\n#endif\n\tu8\t\t\tpartnum;\n\tu32\t\t\tfw_version;\n\tspeed_t\t\t\tmin_speed;\n\tspeed_t\t\t\tmax_speed;\n\tbool\t\t\tuse_actual_rate;\n\tbool\t\t\tno_flow_control;\n\tbool\t\t\tno_event_mode;\n};\n\nenum cp210x_event_state {\n\tES_DATA,\n\tES_ESCAPE,\n\tES_LSR,\n\tES_LSR_DATA_0,\n\tES_LSR_DATA_1,\n\tES_MSR\n};\n\nstruct cp210x_port_private {\n\tu8\t\t\tbInterfaceNumber;\n\tbool\t\t\tevent_mode;\n\tenum cp210x_event_state event_state;\n\tu8\t\t\tlsr;\n\n\tstruct mutex\t\tmutex;\n\tbool\t\t\tcrtscts;\n\tbool\t\t\tdtr;\n\tbool\t\t\trts;\n};\n\nstatic struct usb_serial_driver cp210x_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"cp210x\",\n\t},\n\t.id_table\t\t= id_table,\n\t.num_ports\t\t= 1,\n\t.bulk_in_size\t\t= 256,\n\t.bulk_out_size\t\t= 256,\n\t.open\t\t\t= cp210x_open,\n\t.close\t\t\t= cp210x_close,\n\t.break_ctl\t\t= cp210x_break_ctl,\n\t.set_termios\t\t= cp210x_set_termios,\n\t.tx_empty\t\t= cp210x_tx_empty,\n\t.throttle\t\t= usb_serial_generic_throttle,\n\t.unthrottle\t\t= usb_serial_generic_unthrottle,\n\t.tiocmget\t\t= cp210x_tiocmget,\n\t.tiocmset\t\t= cp210x_tiocmset,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.attach\t\t\t= cp210x_attach,\n\t.disconnect\t\t= cp210x_disconnect,\n\t.release\t\t= cp210x_release,\n\t.port_probe\t\t= cp210x_port_probe,\n\t.port_remove\t\t= cp210x_port_remove,\n\t.dtr_rts\t\t= cp210x_dtr_rts,\n\t.process_read_urb\t= cp210x_process_read_urb,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&cp210x_device, NULL\n};\n\n \n#define REQTYPE_HOST_TO_INTERFACE\t0x41\n#define REQTYPE_INTERFACE_TO_HOST\t0xc1\n#define REQTYPE_HOST_TO_DEVICE\t0x40\n#define REQTYPE_DEVICE_TO_HOST\t0xc0\n\n \n#define CP210X_IFC_ENABLE\t0x00\n#define CP210X_SET_BAUDDIV\t0x01\n#define CP210X_GET_BAUDDIV\t0x02\n#define CP210X_SET_LINE_CTL\t0x03\n#define CP210X_GET_LINE_CTL\t0x04\n#define CP210X_SET_BREAK\t0x05\n#define CP210X_IMM_CHAR\t\t0x06\n#define CP210X_SET_MHS\t\t0x07\n#define CP210X_GET_MDMSTS\t0x08\n#define CP210X_SET_XON\t\t0x09\n#define CP210X_SET_XOFF\t\t0x0A\n#define CP210X_SET_EVENTMASK\t0x0B\n#define CP210X_GET_EVENTMASK\t0x0C\n#define CP210X_SET_CHAR\t\t0x0D\n#define CP210X_GET_CHARS\t0x0E\n#define CP210X_GET_PROPS\t0x0F\n#define CP210X_GET_COMM_STATUS\t0x10\n#define CP210X_RESET\t\t0x11\n#define CP210X_PURGE\t\t0x12\n#define CP210X_SET_FLOW\t\t0x13\n#define CP210X_GET_FLOW\t\t0x14\n#define CP210X_EMBED_EVENTS\t0x15\n#define CP210X_GET_EVENTSTATE\t0x16\n#define CP210X_SET_CHARS\t0x19\n#define CP210X_GET_BAUDRATE\t0x1D\n#define CP210X_SET_BAUDRATE\t0x1E\n#define CP210X_VENDOR_SPECIFIC\t0xFF\n\n \n#define UART_ENABLE\t\t0x0001\n#define UART_DISABLE\t\t0x0000\n\n \n#define BAUD_RATE_GEN_FREQ\t0x384000\n\n \n#define BITS_DATA_MASK\t\t0X0f00\n#define BITS_DATA_5\t\t0X0500\n#define BITS_DATA_6\t\t0X0600\n#define BITS_DATA_7\t\t0X0700\n#define BITS_DATA_8\t\t0X0800\n#define BITS_DATA_9\t\t0X0900\n\n#define BITS_PARITY_MASK\t0x00f0\n#define BITS_PARITY_NONE\t0x0000\n#define BITS_PARITY_ODD\t\t0x0010\n#define BITS_PARITY_EVEN\t0x0020\n#define BITS_PARITY_MARK\t0x0030\n#define BITS_PARITY_SPACE\t0x0040\n\n#define BITS_STOP_MASK\t\t0x000f\n#define BITS_STOP_1\t\t0x0000\n#define BITS_STOP_1_5\t\t0x0001\n#define BITS_STOP_2\t\t0x0002\n\n \n#define BREAK_ON\t\t0x0001\n#define BREAK_OFF\t\t0x0000\n\n \n#define CONTROL_DTR\t\t0x0001\n#define CONTROL_RTS\t\t0x0002\n#define CONTROL_CTS\t\t0x0010\n#define CONTROL_DSR\t\t0x0020\n#define CONTROL_RING\t\t0x0040\n#define CONTROL_DCD\t\t0x0080\n#define CONTROL_WRITE_DTR\t0x0100\n#define CONTROL_WRITE_RTS\t0x0200\n\n \nstruct cp210x_special_chars {\n\tu8\tbEofChar;\n\tu8\tbErrorChar;\n\tu8\tbBreakChar;\n\tu8\tbEventChar;\n\tu8\tbXonChar;\n\tu8\tbXoffChar;\n};\n\n \n#define CP210X_GET_FW_VER\t0x000E\n#define CP210X_READ_2NCONFIG\t0x000E\n#define CP210X_GET_FW_VER_2N\t0x0010\n#define CP210X_READ_LATCH\t0x00C2\n#define CP210X_GET_PARTNUM\t0x370B\n#define CP210X_GET_PORTCONFIG\t0x370C\n#define CP210X_GET_DEVICEMODE\t0x3711\n#define CP210X_WRITE_LATCH\t0x37E1\n\n \n#define CP210X_PARTNUM_CP2101\t0x01\n#define CP210X_PARTNUM_CP2102\t0x02\n#define CP210X_PARTNUM_CP2103\t0x03\n#define CP210X_PARTNUM_CP2104\t0x04\n#define CP210X_PARTNUM_CP2105\t0x05\n#define CP210X_PARTNUM_CP2108\t0x08\n#define CP210X_PARTNUM_CP2102N_QFN28\t0x20\n#define CP210X_PARTNUM_CP2102N_QFN24\t0x21\n#define CP210X_PARTNUM_CP2102N_QFN20\t0x22\n#define CP210X_PARTNUM_UNKNOWN\t0xFF\n\n \nstruct cp210x_comm_status {\n\t__le32   ulErrors;\n\t__le32   ulHoldReasons;\n\t__le32   ulAmountInInQueue;\n\t__le32   ulAmountInOutQueue;\n\tu8       bEofReceived;\n\tu8       bWaitForImmediate;\n\tu8       bReserved;\n} __packed;\n\n \n#define PURGE_ALL\t\t0x000f\n\n \n#define CP210X_ESCCHAR\t\t0xec\n\n#define CP210X_LSR_OVERRUN\tBIT(1)\n#define CP210X_LSR_PARITY\tBIT(2)\n#define CP210X_LSR_FRAME\tBIT(3)\n#define CP210X_LSR_BREAK\tBIT(4)\n\n\n \nstruct cp210x_flow_ctl {\n\t__le32\tulControlHandshake;\n\t__le32\tulFlowReplace;\n\t__le32\tulXonLimit;\n\t__le32\tulXoffLimit;\n};\n\n \n#define CP210X_SERIAL_DTR_MASK\t\tGENMASK(1, 0)\n#define CP210X_SERIAL_DTR_INACTIVE\t(0 << 0)\n#define CP210X_SERIAL_DTR_ACTIVE\t(1 << 0)\n#define CP210X_SERIAL_DTR_FLOW_CTL\t(2 << 0)\n#define CP210X_SERIAL_CTS_HANDSHAKE\tBIT(3)\n#define CP210X_SERIAL_DSR_HANDSHAKE\tBIT(4)\n#define CP210X_SERIAL_DCD_HANDSHAKE\tBIT(5)\n#define CP210X_SERIAL_DSR_SENSITIVITY\tBIT(6)\n\n \n#define CP210X_SERIAL_AUTO_TRANSMIT\tBIT(0)\n#define CP210X_SERIAL_AUTO_RECEIVE\tBIT(1)\n#define CP210X_SERIAL_ERROR_CHAR\tBIT(2)\n#define CP210X_SERIAL_NULL_STRIPPING\tBIT(3)\n#define CP210X_SERIAL_BREAK_CHAR\tBIT(4)\n#define CP210X_SERIAL_RTS_MASK\t\tGENMASK(7, 6)\n#define CP210X_SERIAL_RTS_INACTIVE\t(0 << 6)\n#define CP210X_SERIAL_RTS_ACTIVE\t(1 << 6)\n#define CP210X_SERIAL_RTS_FLOW_CTL\t(2 << 6)\n#define CP210X_SERIAL_XOFF_CONTINUE\tBIT(31)\n\n \nstruct cp210x_pin_mode {\n\tu8\teci;\n\tu8\tsci;\n};\n\n#define CP210X_PIN_MODE_MODEM\t\t0\n#define CP210X_PIN_MODE_GPIO\t\tBIT(0)\n\n \nstruct cp210x_dual_port_config {\n\t__le16\tgpio_mode;\n\tu8\t__pad0[2];\n\t__le16\treset_state;\n\tu8\t__pad1[4];\n\t__le16\tsuspend_state;\n\tu8\tsci_cfg;\n\tu8\teci_cfg;\n\tu8\tdevice_cfg;\n} __packed;\n\n \nstruct cp210x_single_port_config {\n\t__le16\tgpio_mode;\n\tu8\t__pad0[2];\n\t__le16\treset_state;\n\tu8\t__pad1[4];\n\t__le16\tsuspend_state;\n\tu8\tdevice_cfg;\n} __packed;\n\n \n#define CP210X_SCI_GPIO_MODE_OFFSET\t9\n#define CP210X_SCI_GPIO_MODE_MASK\tGENMASK(11, 9)\n\n#define CP210X_ECI_GPIO_MODE_OFFSET\t2\n#define CP210X_ECI_GPIO_MODE_MASK\tGENMASK(3, 2)\n\n#define CP210X_GPIO_MODE_OFFSET\t\t8\n#define CP210X_GPIO_MODE_MASK\t\tGENMASK(11, 8)\n\n \n#define CP2105_GPIO0_TXLED_MODE\t\tBIT(0)\n#define CP2105_GPIO1_RXLED_MODE\t\tBIT(1)\n#define CP2105_GPIO1_RS485_MODE\t\tBIT(2)\n\n \n#define CP2104_GPIO0_TXLED_MODE\t\tBIT(0)\n#define CP2104_GPIO1_RXLED_MODE\t\tBIT(1)\n#define CP2104_GPIO2_RS485_MODE\t\tBIT(2)\n\nstruct cp210x_quad_port_state {\n\t__le16 gpio_mode_pb0;\n\t__le16 gpio_mode_pb1;\n\t__le16 gpio_mode_pb2;\n\t__le16 gpio_mode_pb3;\n\t__le16 gpio_mode_pb4;\n\n\t__le16 gpio_lowpower_pb0;\n\t__le16 gpio_lowpower_pb1;\n\t__le16 gpio_lowpower_pb2;\n\t__le16 gpio_lowpower_pb3;\n\t__le16 gpio_lowpower_pb4;\n\n\t__le16 gpio_latch_pb0;\n\t__le16 gpio_latch_pb1;\n\t__le16 gpio_latch_pb2;\n\t__le16 gpio_latch_pb3;\n\t__le16 gpio_latch_pb4;\n};\n\n \nstruct cp210x_quad_port_config {\n\tstruct cp210x_quad_port_state reset_state;\n\tstruct cp210x_quad_port_state suspend_state;\n\tu8 ipdelay_ifc[4];\n\tu8 enhancedfxn_ifc[4];\n\tu8 enhancedfxn_device;\n\tu8 extclkfreq[4];\n} __packed;\n\n#define CP2108_EF_IFC_GPIO_TXLED\t\t0x01\n#define CP2108_EF_IFC_GPIO_RXLED\t\t0x02\n#define CP2108_EF_IFC_GPIO_RS485\t\t0x04\n#define CP2108_EF_IFC_GPIO_RS485_LOGIC\t\t0x08\n#define CP2108_EF_IFC_GPIO_CLOCK\t\t0x10\n#define CP2108_EF_IFC_DYNAMIC_SUSPEND\t\t0x40\n\n \n#define CP210X_2NCONFIG_CONFIG_VERSION_IDX\t2\n#define CP210X_2NCONFIG_GPIO_MODE_IDX\t\t581\n#define CP210X_2NCONFIG_GPIO_RSTLATCH_IDX\t587\n#define CP210X_2NCONFIG_GPIO_CONTROL_IDX\t600\n\n \n#define CP2102N_QFN20_GPIO2_TXLED_MODE\t\tBIT(2)\n#define CP2102N_QFN20_GPIO3_RXLED_MODE\t\tBIT(3)\n#define CP2102N_QFN20_GPIO1_RS485_MODE\t\tBIT(4)\n#define CP2102N_QFN20_GPIO0_CLK_MODE\t\tBIT(6)\n\n \nstruct cp210x_gpio_write {\n\tu8\tmask;\n\tu8\tstate;\n};\n\n \nstruct cp210x_gpio_write16 {\n\t__le16\tmask;\n\t__le16\tstate;\n};\n\n \nstatic u8 cp210x_interface_num(struct usb_serial *serial)\n{\n\tstruct usb_host_interface *cur_altsetting;\n\n\tcur_altsetting = serial->interface->cur_altsetting;\n\n\treturn cur_altsetting->desc.bInterfaceNumber;\n}\n\n \nstatic int cp210x_read_reg_block(struct usb_serial_port *port, u8 req,\n\t\tvoid *buf, int bufsize)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint result;\n\n\n\tresult = usb_control_msg_recv(serial->dev, 0, req,\n\t\t\tREQTYPE_INTERFACE_TO_HOST, 0,\n\t\t\tport_priv->bInterfaceNumber, buf, bufsize,\n\t\t\tUSB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"failed get req 0x%x size %d status: %d\\n\",\n\t\t\t\treq, bufsize, result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cp210x_read_u8_reg(struct usb_serial_port *port, u8 req, u8 *val)\n{\n\treturn cp210x_read_reg_block(port, req, val, sizeof(*val));\n}\n\n \nstatic int cp210x_read_vendor_block(struct usb_serial *serial, u8 type, u16 val,\n\t\t\t\t    void *buf, int bufsize)\n{\n\tint result;\n\n\tresult = usb_control_msg_recv(serial->dev, 0, CP210X_VENDOR_SPECIFIC,\n\t\t\ttype, val, cp210x_interface_num(serial), buf, bufsize,\n\t\t\tUSB_CTRL_GET_TIMEOUT, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"failed to get vendor val 0x%04x size %d: %d\\n\", val,\n\t\t\tbufsize, result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cp210x_write_u16_reg(struct usb_serial_port *port, u8 req, u16 val)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\treq, REQTYPE_HOST_TO_INTERFACE, val,\n\t\t\tport_priv->bInterfaceNumber, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tif (result < 0) {\n\t\tdev_err(&port->dev, \"failed set request 0x%x status: %d\\n\",\n\t\t\t\treq, result);\n\t}\n\n\treturn result;\n}\n\n \nstatic int cp210x_write_reg_block(struct usb_serial_port *port, u8 req,\n\t\tvoid *buf, int bufsize)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tresult = usb_control_msg_send(serial->dev, 0, req,\n\t\t\tREQTYPE_HOST_TO_INTERFACE, 0,\n\t\t\tport_priv->bInterfaceNumber, buf, bufsize,\n\t\t\tUSB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"failed set req 0x%x size %d status: %d\\n\",\n\t\t\t\treq, bufsize, result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int cp210x_write_u32_reg(struct usb_serial_port *port, u8 req, u32 val)\n{\n\t__le32 le32_val;\n\n\tle32_val = cpu_to_le32(val);\n\n\treturn cp210x_write_reg_block(port, req, &le32_val, sizeof(le32_val));\n}\n\n#ifdef CONFIG_GPIOLIB\n \nstatic int cp210x_write_vendor_block(struct usb_serial *serial, u8 type,\n\t\t\t\t     u16 val, void *buf, int bufsize)\n{\n\tint result;\n\n\tresult = usb_control_msg_send(serial->dev, 0, CP210X_VENDOR_SPECIFIC,\n\t\t\ttype, val, cp210x_interface_num(serial), buf, bufsize,\n\t\t\tUSB_CTRL_SET_TIMEOUT, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"failed to set vendor val 0x%04x size %d: %d\\n\", val,\n\t\t\tbufsize, result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n#endif\n\nstatic int cp210x_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tresult = cp210x_write_u16_reg(port, CP210X_IFC_ENABLE, UART_ENABLE);\n\tif (result) {\n\t\tdev_err(&port->dev, \"%s - Unable to enable UART\\n\", __func__);\n\t\treturn result;\n\t}\n\n\tif (tty)\n\t\tcp210x_set_termios(tty, port, NULL);\n\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result)\n\t\tgoto err_disable;\n\n\treturn 0;\n\nerr_disable:\n\tcp210x_write_u16_reg(port, CP210X_IFC_ENABLE, UART_DISABLE);\n\tport_priv->event_mode = false;\n\n\treturn result;\n}\n\nstatic void cp210x_close(struct usb_serial_port *port)\n{\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\n\tusb_serial_generic_close(port);\n\n\t \n\tcp210x_write_u16_reg(port, CP210X_PURGE, PURGE_ALL);\n\n\tcp210x_write_u16_reg(port, CP210X_IFC_ENABLE, UART_DISABLE);\n\n\t \n\tport_priv->event_mode = false;\n}\n\nstatic void cp210x_process_lsr(struct usb_serial_port *port, unsigned char lsr, char *flag)\n{\n\tif (lsr & CP210X_LSR_BREAK) {\n\t\tport->icount.brk++;\n\t\t*flag = TTY_BREAK;\n\t} else if (lsr & CP210X_LSR_PARITY) {\n\t\tport->icount.parity++;\n\t\t*flag = TTY_PARITY;\n\t} else if (lsr & CP210X_LSR_FRAME) {\n\t\tport->icount.frame++;\n\t\t*flag = TTY_FRAME;\n\t}\n\n\tif (lsr & CP210X_LSR_OVERRUN) {\n\t\tport->icount.overrun++;\n\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t}\n}\n\nstatic bool cp210x_process_char(struct usb_serial_port *port, unsigned char *ch, char *flag)\n{\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\n\tswitch (port_priv->event_state) {\n\tcase ES_DATA:\n\t\tif (*ch == CP210X_ESCCHAR) {\n\t\t\tport_priv->event_state = ES_ESCAPE;\n\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\tcase ES_ESCAPE:\n\t\tswitch (*ch) {\n\t\tcase 0:\n\t\t\tdev_dbg(&port->dev, \"%s - escape char\\n\", __func__);\n\t\t\t*ch = CP210X_ESCCHAR;\n\t\t\tport_priv->event_state = ES_DATA;\n\t\t\treturn false;\n\t\tcase 1:\n\t\t\tport_priv->event_state = ES_LSR_DATA_0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tport_priv->event_state = ES_LSR;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tport_priv->event_state = ES_MSR;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(&port->dev, \"malformed event 0x%02x\\n\", *ch);\n\t\t\tport_priv->event_state = ES_DATA;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ES_LSR_DATA_0:\n\t\tport_priv->lsr = *ch;\n\t\tport_priv->event_state = ES_LSR_DATA_1;\n\t\tbreak;\n\tcase ES_LSR_DATA_1:\n\t\tdev_dbg(&port->dev, \"%s - lsr = 0x%02x, data = 0x%02x\\n\",\n\t\t\t\t__func__, port_priv->lsr, *ch);\n\t\tcp210x_process_lsr(port, port_priv->lsr, flag);\n\t\tport_priv->event_state = ES_DATA;\n\t\treturn false;\n\tcase ES_LSR:\n\t\tdev_dbg(&port->dev, \"%s - lsr = 0x%02x\\n\", __func__, *ch);\n\t\tport_priv->lsr = *ch;\n\t\tcp210x_process_lsr(port, port_priv->lsr, flag);\n\t\tport_priv->event_state = ES_DATA;\n\t\tbreak;\n\tcase ES_MSR:\n\t\tdev_dbg(&port->dev, \"%s - msr = 0x%02x\\n\", __func__, *ch);\n\t\t \n\t\tport_priv->event_state = ES_DATA;\n\t\tbreak;\n\t}\n\n\treturn true;\n}\n\nstatic void cp210x_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tunsigned char *ch = urb->transfer_buffer;\n\tchar flag;\n\tint i;\n\n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (port_priv->event_mode) {\n\t\tfor (i = 0; i < urb->actual_length; i++, ch++) {\n\t\t\tflag = TTY_NORMAL;\n\n\t\t\tif (cp210x_process_char(port, ch, &flag))\n\t\t\t\tcontinue;\n\n\t\t\ttty_insert_flip_char(&port->port, *ch, flag);\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string(&port->port, ch, urb->actual_length);\n\t}\n\ttty_flip_buffer_push(&port->port);\n}\n\n \nstatic int cp210x_get_tx_queue_byte_count(struct usb_serial_port *port,\n\t\tu32 *count)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tstruct cp210x_comm_status sts;\n\tint result;\n\n\tresult = usb_control_msg_recv(serial->dev, 0, CP210X_GET_COMM_STATUS,\n\t\t\tREQTYPE_INTERFACE_TO_HOST, 0,\n\t\t\tport_priv->bInterfaceNumber, &sts, sizeof(sts),\n\t\t\tUSB_CTRL_GET_TIMEOUT, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"failed to get comm status: %d\\n\", result);\n\t\treturn result;\n\t}\n\n\t*count = le32_to_cpu(sts.ulAmountInOutQueue);\n\n\treturn 0;\n}\n\nstatic bool cp210x_tx_empty(struct usb_serial_port *port)\n{\n\tint err;\n\tu32 count;\n\n\terr = cp210x_get_tx_queue_byte_count(port, &count);\n\tif (err)\n\t\treturn true;\n\n\treturn !count;\n}\n\nstruct cp210x_rate {\n\tspeed_t rate;\n\tspeed_t high;\n};\n\nstatic const struct cp210x_rate cp210x_an205_table1[] = {\n\t{ 300, 300 },\n\t{ 600, 600 },\n\t{ 1200, 1200 },\n\t{ 1800, 1800 },\n\t{ 2400, 2400 },\n\t{ 4000, 4000 },\n\t{ 4800, 4803 },\n\t{ 7200, 7207 },\n\t{ 9600, 9612 },\n\t{ 14400, 14428 },\n\t{ 16000, 16062 },\n\t{ 19200, 19250 },\n\t{ 28800, 28912 },\n\t{ 38400, 38601 },\n\t{ 51200, 51558 },\n\t{ 56000, 56280 },\n\t{ 57600, 58053 },\n\t{ 64000, 64111 },\n\t{ 76800, 77608 },\n\t{ 115200, 117028 },\n\t{ 128000, 129347 },\n\t{ 153600, 156868 },\n\t{ 230400, 237832 },\n\t{ 250000, 254234 },\n\t{ 256000, 273066 },\n\t{ 460800, 491520 },\n\t{ 500000, 567138 },\n\t{ 576000, 670254 },\n\t{ 921600, UINT_MAX }\n};\n\n \nstatic speed_t cp210x_get_an205_rate(speed_t baud)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(cp210x_an205_table1); ++i) {\n\t\tif (baud <= cp210x_an205_table1[i].high)\n\t\t\tbreak;\n\t}\n\n\treturn cp210x_an205_table1[i].rate;\n}\n\nstatic speed_t cp210x_get_actual_rate(speed_t baud)\n{\n\tunsigned int prescale = 1;\n\tunsigned int div;\n\n\tif (baud <= 365)\n\t\tprescale = 4;\n\n\tdiv = DIV_ROUND_CLOSEST(48000000, 2 * prescale * baud);\n\tbaud = 48000000 / (2 * prescale * div);\n\n\treturn baud;\n}\n\n \nstatic void cp210x_change_speed(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tu32 baud;\n\n\tif (tty->termios.c_ospeed == 0)\n\t\treturn;\n\n\t \n\tbaud = clamp(tty->termios.c_ospeed, priv->min_speed, priv->max_speed);\n\n\tif (priv->use_actual_rate)\n\t\tbaud = cp210x_get_actual_rate(baud);\n\telse if (baud < 1000000)\n\t\tbaud = cp210x_get_an205_rate(baud);\n\n\tdev_dbg(&port->dev, \"%s - setting baud rate to %u\\n\", __func__, baud);\n\tif (cp210x_write_u32_reg(port, CP210X_SET_BAUDRATE, baud)) {\n\t\tdev_warn(&port->dev, \"failed to set baud rate to %u\\n\", baud);\n\t\tif (old_termios)\n\t\t\tbaud = old_termios->c_ospeed;\n\t\telse\n\t\t\tbaud = 9600;\n\t}\n\n\ttty_encode_baud_rate(tty, baud, baud);\n}\n\nstatic void cp210x_enable_event_mode(struct usb_serial_port *port)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(port->serial);\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint ret;\n\n\tif (port_priv->event_mode)\n\t\treturn;\n\n\tif (priv->no_event_mode)\n\t\treturn;\n\n\tport_priv->event_state = ES_DATA;\n\tport_priv->event_mode = true;\n\n\tret = cp210x_write_u16_reg(port, CP210X_EMBED_EVENTS, CP210X_ESCCHAR);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to enable events: %d\\n\", ret);\n\t\tport_priv->event_mode = false;\n\t}\n}\n\nstatic void cp210x_disable_event_mode(struct usb_serial_port *port)\n{\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tint ret;\n\n\tif (!port_priv->event_mode)\n\t\treturn;\n\n\tret = cp210x_write_u16_reg(port, CP210X_EMBED_EVENTS, 0);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to disable events: %d\\n\", ret);\n\t\treturn;\n\t}\n\n\tport_priv->event_mode = false;\n}\n\nstatic bool cp210x_termios_change(const struct ktermios *a, const struct ktermios *b)\n{\n\tbool iflag_change, cc_change;\n\n\tiflag_change = ((a->c_iflag ^ b->c_iflag) & (INPCK | IXON | IXOFF));\n\tcc_change = a->c_cc[VSTART] != b->c_cc[VSTART] ||\n\t\t\ta->c_cc[VSTOP] != b->c_cc[VSTOP];\n\n\treturn tty_termios_hw_change(a, b) || iflag_change || cc_change;\n}\n\nstatic void cp210x_set_flow_control(struct tty_struct *tty,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    const struct ktermios *old_termios)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(port->serial);\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tstruct cp210x_special_chars chars;\n\tstruct cp210x_flow_ctl flow_ctl;\n\tu32 flow_repl;\n\tu32 ctl_hs;\n\tbool crtscts;\n\tint ret;\n\n\t \n\tif (priv->no_flow_control) {\n\t\ttty->termios.c_cflag &= ~CRTSCTS;\n\t\ttty->termios.c_iflag &= ~(IXON | IXOFF);\n\t}\n\n\tif (tty->termios.c_ospeed != 0 &&\n\t\t\told_termios && old_termios->c_ospeed != 0 &&\n\t\t\tC_CRTSCTS(tty) == (old_termios->c_cflag & CRTSCTS) &&\n\t\t\tI_IXON(tty) == (old_termios->c_iflag & IXON) &&\n\t\t\tI_IXOFF(tty) == (old_termios->c_iflag & IXOFF) &&\n\t\t\tSTART_CHAR(tty) == old_termios->c_cc[VSTART] &&\n\t\t\tSTOP_CHAR(tty) == old_termios->c_cc[VSTOP]) {\n\t\treturn;\n\t}\n\n\tif (I_IXON(tty) || I_IXOFF(tty)) {\n\t\tmemset(&chars, 0, sizeof(chars));\n\n\t\tchars.bXonChar = START_CHAR(tty);\n\t\tchars.bXoffChar = STOP_CHAR(tty);\n\n\t\tret = cp210x_write_reg_block(port, CP210X_SET_CHARS, &chars,\n\t\t\t\tsizeof(chars));\n\t\tif (ret) {\n\t\t\tdev_err(&port->dev, \"failed to set special chars: %d\\n\",\n\t\t\t\t\tret);\n\t\t}\n\t}\n\n\tmutex_lock(&port_priv->mutex);\n\n\tif (tty->termios.c_ospeed == 0) {\n\t\tport_priv->dtr = false;\n\t\tport_priv->rts = false;\n\t} else if (old_termios && old_termios->c_ospeed == 0) {\n\t\tport_priv->dtr = true;\n\t\tport_priv->rts = true;\n\t}\n\n\tret = cp210x_read_reg_block(port, CP210X_GET_FLOW, &flow_ctl,\n\t\t\tsizeof(flow_ctl));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tctl_hs = le32_to_cpu(flow_ctl.ulControlHandshake);\n\tflow_repl = le32_to_cpu(flow_ctl.ulFlowReplace);\n\n\tctl_hs &= ~CP210X_SERIAL_DSR_HANDSHAKE;\n\tctl_hs &= ~CP210X_SERIAL_DCD_HANDSHAKE;\n\tctl_hs &= ~CP210X_SERIAL_DSR_SENSITIVITY;\n\tctl_hs &= ~CP210X_SERIAL_DTR_MASK;\n\tif (port_priv->dtr)\n\t\tctl_hs |= CP210X_SERIAL_DTR_ACTIVE;\n\telse\n\t\tctl_hs |= CP210X_SERIAL_DTR_INACTIVE;\n\n\tflow_repl &= ~CP210X_SERIAL_RTS_MASK;\n\tif (C_CRTSCTS(tty)) {\n\t\tctl_hs |= CP210X_SERIAL_CTS_HANDSHAKE;\n\t\tif (port_priv->rts)\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_FLOW_CTL;\n\t\telse\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_INACTIVE;\n\t\tcrtscts = true;\n\t} else {\n\t\tctl_hs &= ~CP210X_SERIAL_CTS_HANDSHAKE;\n\t\tif (port_priv->rts)\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_ACTIVE;\n\t\telse\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_INACTIVE;\n\t\tcrtscts = false;\n\t}\n\n\tif (I_IXOFF(tty)) {\n\t\tflow_repl |= CP210X_SERIAL_AUTO_RECEIVE;\n\n\t\tflow_ctl.ulXonLimit = cpu_to_le32(128);\n\t\tflow_ctl.ulXoffLimit = cpu_to_le32(128);\n\t} else {\n\t\tflow_repl &= ~CP210X_SERIAL_AUTO_RECEIVE;\n\t}\n\n\tif (I_IXON(tty))\n\t\tflow_repl |= CP210X_SERIAL_AUTO_TRANSMIT;\n\telse\n\t\tflow_repl &= ~CP210X_SERIAL_AUTO_TRANSMIT;\n\n\tdev_dbg(&port->dev, \"%s - ctrl = 0x%02x, flow = 0x%02x\\n\", __func__,\n\t\t\tctl_hs, flow_repl);\n\n\tflow_ctl.ulControlHandshake = cpu_to_le32(ctl_hs);\n\tflow_ctl.ulFlowReplace = cpu_to_le32(flow_repl);\n\n\tret = cp210x_write_reg_block(port, CP210X_SET_FLOW, &flow_ctl,\n\t\t\tsizeof(flow_ctl));\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tport_priv->crtscts = crtscts;\nout_unlock:\n\tmutex_unlock(&port_priv->mutex);\n}\n\nstatic void cp210x_set_termios(struct tty_struct *tty,\n\t\t               struct usb_serial_port *port,\n\t\t               const struct ktermios *old_termios)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(port->serial);\n\tu16 bits;\n\tint ret;\n\n\tif (old_termios && !cp210x_termios_change(&tty->termios, old_termios) &&\n\t\t\ttty->termios.c_ospeed != 0)\n\t\treturn;\n\n\tif (!old_termios || tty->termios.c_ospeed != old_termios->c_ospeed)\n\t\tcp210x_change_speed(tty, port, old_termios);\n\n\t \n\tif (priv->partnum == CP210X_PARTNUM_CP2101) {\n\t\ttty->termios.c_cflag &= ~(CSIZE | CSTOPB | CMSPAR);\n\t\ttty->termios.c_cflag |= CS8;\n\t}\n\n\tbits = 0;\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\t\tbits |= BITS_DATA_5;\n\t\tbreak;\n\tcase CS6:\n\t\tbits |= BITS_DATA_6;\n\t\tbreak;\n\tcase CS7:\n\t\tbits |= BITS_DATA_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tbits |= BITS_DATA_8;\n\t\tbreak;\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\tif (C_CMSPAR(tty)) {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tbits |= BITS_PARITY_MARK;\n\t\t\telse\n\t\t\t\tbits |= BITS_PARITY_SPACE;\n\t\t} else {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tbits |= BITS_PARITY_ODD;\n\t\t\telse\n\t\t\t\tbits |= BITS_PARITY_EVEN;\n\t\t}\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tbits |= BITS_STOP_2;\n\telse\n\t\tbits |= BITS_STOP_1;\n\n\tret = cp210x_write_u16_reg(port, CP210X_SET_LINE_CTL, bits);\n\tif (ret)\n\t\tdev_err(&port->dev, \"failed to set line control: %d\\n\", ret);\n\n\tcp210x_set_flow_control(tty, port, old_termios);\n\n\t \n\tif (I_INPCK(tty))\n\t\tcp210x_enable_event_mode(port);\n\telse\n\t\tcp210x_disable_event_mode(port);\n}\n\nstatic int cp210x_tiocmset(struct tty_struct *tty,\n\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\treturn cp210x_tiocmset_port(port, set, clear);\n}\n\nstatic int cp210x_tiocmset_port(struct usb_serial_port *port,\n\t\tunsigned int set, unsigned int clear)\n{\n\tstruct cp210x_port_private *port_priv = usb_get_serial_port_data(port);\n\tstruct cp210x_flow_ctl flow_ctl;\n\tu32 ctl_hs, flow_repl;\n\tu16 control = 0;\n\tint ret;\n\n\tmutex_lock(&port_priv->mutex);\n\n\tif (set & TIOCM_RTS) {\n\t\tport_priv->rts = true;\n\t\tcontrol |= CONTROL_RTS;\n\t\tcontrol |= CONTROL_WRITE_RTS;\n\t}\n\tif (set & TIOCM_DTR) {\n\t\tport_priv->dtr = true;\n\t\tcontrol |= CONTROL_DTR;\n\t\tcontrol |= CONTROL_WRITE_DTR;\n\t}\n\tif (clear & TIOCM_RTS) {\n\t\tport_priv->rts = false;\n\t\tcontrol &= ~CONTROL_RTS;\n\t\tcontrol |= CONTROL_WRITE_RTS;\n\t}\n\tif (clear & TIOCM_DTR) {\n\t\tport_priv->dtr = false;\n\t\tcontrol &= ~CONTROL_DTR;\n\t\tcontrol |= CONTROL_WRITE_DTR;\n\t}\n\n\t \n\tif (port_priv->crtscts && control & CONTROL_WRITE_RTS) {\n\t\tret = cp210x_read_reg_block(port, CP210X_GET_FLOW, &flow_ctl,\n\t\t\t\tsizeof(flow_ctl));\n\t\tif (ret)\n\t\t\tgoto out_unlock;\n\n\t\tctl_hs = le32_to_cpu(flow_ctl.ulControlHandshake);\n\t\tflow_repl = le32_to_cpu(flow_ctl.ulFlowReplace);\n\n\t\tctl_hs &= ~CP210X_SERIAL_DTR_MASK;\n\t\tif (port_priv->dtr)\n\t\t\tctl_hs |= CP210X_SERIAL_DTR_ACTIVE;\n\t\telse\n\t\t\tctl_hs |= CP210X_SERIAL_DTR_INACTIVE;\n\n\t\tflow_repl &= ~CP210X_SERIAL_RTS_MASK;\n\t\tif (port_priv->rts)\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_FLOW_CTL;\n\t\telse\n\t\t\tflow_repl |= CP210X_SERIAL_RTS_INACTIVE;\n\n\t\tflow_ctl.ulControlHandshake = cpu_to_le32(ctl_hs);\n\t\tflow_ctl.ulFlowReplace = cpu_to_le32(flow_repl);\n\n\t\tdev_dbg(&port->dev, \"%s - ctrl = 0x%02x, flow = 0x%02x\\n\",\n\t\t\t\t__func__, ctl_hs, flow_repl);\n\n\t\tret = cp210x_write_reg_block(port, CP210X_SET_FLOW, &flow_ctl,\n\t\t\t\tsizeof(flow_ctl));\n\t} else {\n\t\tdev_dbg(&port->dev, \"%s - control = 0x%04x\\n\", __func__, control);\n\n\t\tret = cp210x_write_u16_reg(port, CP210X_SET_MHS, control);\n\t}\nout_unlock:\n\tmutex_unlock(&port_priv->mutex);\n\n\treturn ret;\n}\n\nstatic void cp210x_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tif (on)\n\t\tcp210x_tiocmset_port(port, TIOCM_DTR | TIOCM_RTS, 0);\n\telse\n\t\tcp210x_tiocmset_port(port, 0, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic int cp210x_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tu8 control;\n\tint result;\n\n\tresult = cp210x_read_u8_reg(port, CP210X_GET_MDMSTS, &control);\n\tif (result)\n\t\treturn result;\n\n\tresult = ((control & CONTROL_DTR) ? TIOCM_DTR : 0)\n\t\t|((control & CONTROL_RTS) ? TIOCM_RTS : 0)\n\t\t|((control & CONTROL_CTS) ? TIOCM_CTS : 0)\n\t\t|((control & CONTROL_DSR) ? TIOCM_DSR : 0)\n\t\t|((control & CONTROL_RING)? TIOCM_RI  : 0)\n\t\t|((control & CONTROL_DCD) ? TIOCM_CD  : 0);\n\n\tdev_dbg(&port->dev, \"%s - control = 0x%02x\\n\", __func__, control);\n\n\treturn result;\n}\n\nstatic int cp210x_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(port->serial);\n\tu16 state;\n\n\tif (priv->partnum == CP210X_PARTNUM_CP2105) {\n\t\tif (cp210x_interface_num(port->serial) == 1)\n\t\t\treturn -ENOTTY;\n\t}\n\n\tif (break_state == 0)\n\t\tstate = BREAK_OFF;\n\telse\n\t\tstate = BREAK_ON;\n\n\tdev_dbg(&port->dev, \"%s - turning break %s\\n\", __func__,\n\t\tstate == BREAK_OFF ? \"off\" : \"on\");\n\n\treturn cp210x_write_u16_reg(port, CP210X_SET_BREAK, state);\n}\n\n#ifdef CONFIG_GPIOLIB\nstatic int cp210x_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tu8 req_type;\n\tu16 mask;\n\tint result;\n\tint len;\n\n\tresult = usb_autopm_get_interface(serial->interface);\n\tif (result)\n\t\treturn result;\n\n\tswitch (priv->partnum) {\n\tcase CP210X_PARTNUM_CP2105:\n\t\treq_type = REQTYPE_INTERFACE_TO_HOST;\n\t\tlen = 1;\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2108:\n\t\treq_type = REQTYPE_INTERFACE_TO_HOST;\n\t\tlen = 2;\n\t\tbreak;\n\tdefault:\n\t\treq_type = REQTYPE_DEVICE_TO_HOST;\n\t\tlen = 1;\n\t\tbreak;\n\t}\n\n\tmask = 0;\n\tresult = cp210x_read_vendor_block(serial, req_type, CP210X_READ_LATCH,\n\t\t\t\t\t  &mask, len);\n\n\tusb_autopm_put_interface(serial->interface);\n\n\tif (result < 0)\n\t\treturn result;\n\n\tle16_to_cpus(&mask);\n\n\treturn !!(mask & BIT(gpio));\n}\n\nstatic void cp210x_gpio_set(struct gpio_chip *gc, unsigned int gpio, int value)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tstruct cp210x_gpio_write16 buf16;\n\tstruct cp210x_gpio_write buf;\n\tu16 mask, state;\n\tu16 wIndex;\n\tint result;\n\n\tif (value == 1)\n\t\tstate = BIT(gpio);\n\telse\n\t\tstate = 0;\n\n\tmask = BIT(gpio);\n\n\tresult = usb_autopm_get_interface(serial->interface);\n\tif (result)\n\t\tgoto out;\n\n\tswitch (priv->partnum) {\n\tcase CP210X_PARTNUM_CP2105:\n\t\tbuf.mask = (u8)mask;\n\t\tbuf.state = (u8)state;\n\t\tresult = cp210x_write_vendor_block(serial,\n\t\t\t\t\t\t   REQTYPE_HOST_TO_INTERFACE,\n\t\t\t\t\t\t   CP210X_WRITE_LATCH, &buf,\n\t\t\t\t\t\t   sizeof(buf));\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2108:\n\t\tbuf16.mask = cpu_to_le16(mask);\n\t\tbuf16.state = cpu_to_le16(state);\n\t\tresult = cp210x_write_vendor_block(serial,\n\t\t\t\t\t\t   REQTYPE_HOST_TO_INTERFACE,\n\t\t\t\t\t\t   CP210X_WRITE_LATCH, &buf16,\n\t\t\t\t\t\t   sizeof(buf16));\n\t\tbreak;\n\tdefault:\n\t\twIndex = state << 8 | mask;\n\t\tresult = usb_control_msg(serial->dev,\n\t\t\t\t\t usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t\t CP210X_VENDOR_SPECIFIC,\n\t\t\t\t\t REQTYPE_HOST_TO_DEVICE,\n\t\t\t\t\t CP210X_WRITE_LATCH,\n\t\t\t\t\t wIndex,\n\t\t\t\t\t NULL, 0, USB_CTRL_SET_TIMEOUT);\n\t\tbreak;\n\t}\n\n\tusb_autopm_put_interface(serial->interface);\nout:\n\tif (result < 0) {\n\t\tdev_err(&serial->interface->dev, \"failed to set GPIO value: %d\\n\",\n\t\t\t\tresult);\n\t}\n}\n\nstatic int cp210x_gpio_direction_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\n\treturn priv->gpio_input & BIT(gpio);\n}\n\nstatic int cp210x_gpio_direction_input(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\n\tif (priv->partnum == CP210X_PARTNUM_CP2105) {\n\t\t \n\t\treturn -ENOTSUPP;\n\t}\n\n\t \n\tif (priv->gpio_pushpull & BIT(gpio))\n\t\treturn -EINVAL;\n\n\t \n\tcp210x_gpio_set(gc, gpio, 1);\n\n\tpriv->gpio_input |= BIT(gpio);\n\n\treturn 0;\n}\n\nstatic int cp210x_gpio_direction_output(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t\tint value)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\n\tpriv->gpio_input &= ~BIT(gpio);\n\tcp210x_gpio_set(gc, gpio, value);\n\n\treturn 0;\n}\n\nstatic int cp210x_gpio_set_config(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t  unsigned long config)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tenum pin_config_param param = pinconf_to_config_param(config);\n\n\t \n\tif ((param == PIN_CONFIG_DRIVE_PUSH_PULL) &&\n\t    (priv->gpio_pushpull & BIT(gpio)))\n\t\treturn 0;\n\n\tif ((param == PIN_CONFIG_DRIVE_OPEN_DRAIN) &&\n\t    !(priv->gpio_pushpull & BIT(gpio)))\n\t\treturn 0;\n\n\treturn -ENOTSUPP;\n}\n\nstatic int cp210x_gpio_init_valid_mask(struct gpio_chip *gc,\n\t\tunsigned long *valid_mask, unsigned int ngpios)\n{\n\tstruct usb_serial *serial = gpiochip_get_data(gc);\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tstruct device *dev = &serial->interface->dev;\n\tunsigned long altfunc_mask = priv->gpio_altfunc;\n\n\tbitmap_complement(valid_mask, &altfunc_mask, ngpios);\n\n\tif (bitmap_empty(valid_mask, ngpios))\n\t\tdev_dbg(dev, \"no pin configured for GPIO\\n\");\n\telse\n\t\tdev_dbg(dev, \"GPIO.%*pbl configured for GPIO\\n\", ngpios,\n\t\t\t\tvalid_mask);\n\treturn 0;\n}\n\n \nstatic int cp2105_gpioconf_init(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tstruct cp210x_pin_mode mode;\n\tstruct cp210x_dual_port_config config;\n\tu8 intf_num = cp210x_interface_num(serial);\n\tu8 iface_config;\n\tint result;\n\n\tresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\n\t\t\t\t\t  CP210X_GET_DEVICEMODE, &mode,\n\t\t\t\t\t  sizeof(mode));\n\tif (result < 0)\n\t\treturn result;\n\n\tresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\n\t\t\t\t\t  CP210X_GET_PORTCONFIG, &config,\n\t\t\t\t\t  sizeof(config));\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tif (intf_num == 0) {\n\t\tpriv->gc.ngpio = 2;\n\n\t\tif (mode.eci == CP210X_PIN_MODE_MODEM) {\n\t\t\t \n\t\t\tpriv->gpio_altfunc = 0xff;\n\t\t\treturn 0;\n\t\t}\n\n\t\tiface_config = config.eci_cfg;\n\t\tpriv->gpio_pushpull = (u8)((le16_to_cpu(config.gpio_mode) &\n\t\t\t\t\t\tCP210X_ECI_GPIO_MODE_MASK) >>\n\t\t\t\t\t\tCP210X_ECI_GPIO_MODE_OFFSET);\n\t} else if (intf_num == 1) {\n\t\tpriv->gc.ngpio = 3;\n\n\t\tif (mode.sci == CP210X_PIN_MODE_MODEM) {\n\t\t\t \n\t\t\tpriv->gpio_altfunc = 0xff;\n\t\t\treturn 0;\n\t\t}\n\n\t\tiface_config = config.sci_cfg;\n\t\tpriv->gpio_pushpull = (u8)((le16_to_cpu(config.gpio_mode) &\n\t\t\t\t\t\tCP210X_SCI_GPIO_MODE_MASK) >>\n\t\t\t\t\t\tCP210X_SCI_GPIO_MODE_OFFSET);\n\t} else {\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (iface_config & CP2105_GPIO0_TXLED_MODE)\t \n\t\tpriv->gpio_altfunc |= BIT(0);\n\tif (iface_config & (CP2105_GPIO1_RXLED_MODE |\t \n\t\t\tCP2105_GPIO1_RS485_MODE))\n\t\tpriv->gpio_altfunc |= BIT(1);\n\n\t \n\tpriv->gpio_input = 0;\n\n\treturn 0;\n}\n\nstatic int cp2104_gpioconf_init(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tstruct cp210x_single_port_config config;\n\tu8 iface_config;\n\tu8 gpio_latch;\n\tint result;\n\tu8 i;\n\n\tresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\n\t\t\t\t\t  CP210X_GET_PORTCONFIG, &config,\n\t\t\t\t\t  sizeof(config));\n\tif (result < 0)\n\t\treturn result;\n\n\tpriv->gc.ngpio = 4;\n\n\tiface_config = config.device_cfg;\n\tpriv->gpio_pushpull = (u8)((le16_to_cpu(config.gpio_mode) &\n\t\t\t\t\tCP210X_GPIO_MODE_MASK) >>\n\t\t\t\t\tCP210X_GPIO_MODE_OFFSET);\n\tgpio_latch = (u8)((le16_to_cpu(config.reset_state) &\n\t\t\t\t\tCP210X_GPIO_MODE_MASK) >>\n\t\t\t\t\tCP210X_GPIO_MODE_OFFSET);\n\n\t \n\tif (iface_config & CP2104_GPIO0_TXLED_MODE)\t \n\t\tpriv->gpio_altfunc |= BIT(0);\n\tif (iface_config & CP2104_GPIO1_RXLED_MODE)\t \n\t\tpriv->gpio_altfunc |= BIT(1);\n\tif (iface_config & CP2104_GPIO2_RS485_MODE)\t \n\t\tpriv->gpio_altfunc |= BIT(2);\n\n\t \n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\t \n\t\tif (!(priv->gpio_pushpull & BIT(i)) && (gpio_latch & BIT(i)))\n\t\t\tpriv->gpio_input |= BIT(i);\n\t}\n\n\treturn 0;\n}\n\nstatic int cp2108_gpio_init(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tstruct cp210x_quad_port_config config;\n\tu16 gpio_latch;\n\tint result;\n\tu8 i;\n\n\tresult = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\n\t\t\t\t\t  CP210X_GET_PORTCONFIG, &config,\n\t\t\t\t\t  sizeof(config));\n\tif (result < 0)\n\t\treturn result;\n\n\tpriv->gc.ngpio = 16;\n\tpriv->gpio_pushpull = le16_to_cpu(config.reset_state.gpio_mode_pb1);\n\tgpio_latch = le16_to_cpu(config.reset_state.gpio_latch_pb1);\n\n\t \n\tfor (i = 0; i < 4; i++) {\n\t\tif (config.enhancedfxn_ifc[i] & CP2108_EF_IFC_GPIO_TXLED)\n\t\t\tpriv->gpio_altfunc |= BIT(i * 4);\n\t\tif (config.enhancedfxn_ifc[i] & CP2108_EF_IFC_GPIO_RXLED)\n\t\t\tpriv->gpio_altfunc |= BIT((i * 4) + 1);\n\t\tif (config.enhancedfxn_ifc[i] & CP2108_EF_IFC_GPIO_RS485)\n\t\t\tpriv->gpio_altfunc |= BIT((i * 4) + 2);\n\t\tif (config.enhancedfxn_ifc[i] & CP2108_EF_IFC_GPIO_CLOCK)\n\t\t\tpriv->gpio_altfunc |= BIT((i * 4) + 3);\n\t}\n\n\t \n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\t \n\t\tif (!(priv->gpio_pushpull & BIT(i)) && (gpio_latch & BIT(i)))\n\t\t\tpriv->gpio_input |= BIT(i);\n\t}\n\n\treturn 0;\n}\n\nstatic int cp2102n_gpioconf_init(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tconst u16 config_size = 0x02a6;\n\tu8 gpio_rst_latch;\n\tu8 config_version;\n\tu8 gpio_pushpull;\n\tu8 *config_buf;\n\tu8 gpio_latch;\n\tu8 gpio_ctrl;\n\tint result;\n\tu8 i;\n\n\t \n\tconfig_buf = kmalloc(config_size, GFP_KERNEL);\n\tif (!config_buf)\n\t\treturn -ENOMEM;\n\n\tresult = cp210x_read_vendor_block(serial,\n\t\t\t\t\t  REQTYPE_DEVICE_TO_HOST,\n\t\t\t\t\t  CP210X_READ_2NCONFIG,\n\t\t\t\t\t  config_buf,\n\t\t\t\t\t  config_size);\n\tif (result < 0) {\n\t\tkfree(config_buf);\n\t\treturn result;\n\t}\n\n\tconfig_version = config_buf[CP210X_2NCONFIG_CONFIG_VERSION_IDX];\n\tgpio_pushpull = config_buf[CP210X_2NCONFIG_GPIO_MODE_IDX];\n\tgpio_ctrl = config_buf[CP210X_2NCONFIG_GPIO_CONTROL_IDX];\n\tgpio_rst_latch = config_buf[CP210X_2NCONFIG_GPIO_RSTLATCH_IDX];\n\n\tkfree(config_buf);\n\n\t \n\tif (config_version != 0x01)\n\t\treturn -ENOTSUPP;\n\n\tpriv->gc.ngpio = 4;\n\n\t \n\tgpio_latch = (gpio_rst_latch >> 3) & 0x0f;\n\n\t \n\tpriv->gpio_pushpull = (gpio_pushpull >> 3) & 0x0f;\n\n\t \n\tif (priv->partnum == CP210X_PARTNUM_CP2102N_QFN20) {\n\t\t \n\t\tif (gpio_ctrl & CP2102N_QFN20_GPIO0_CLK_MODE)    \n\t\t\tpriv->gpio_altfunc |= BIT(0);\n\t\tif (gpio_ctrl & CP2102N_QFN20_GPIO1_RS485_MODE)  \n\t\t\tpriv->gpio_altfunc |= BIT(1);\n\t\tif (gpio_ctrl & CP2102N_QFN20_GPIO2_TXLED_MODE)  \n\t\t\tpriv->gpio_altfunc |= BIT(2);\n\t\tif (gpio_ctrl & CP2102N_QFN20_GPIO3_RXLED_MODE)  \n\t\t\tpriv->gpio_altfunc |= BIT(3);\n\t} else {\n\t\tpriv->gpio_altfunc = (gpio_ctrl >> 2) & 0x0f;\n\t}\n\n\tif (priv->partnum == CP210X_PARTNUM_CP2102N_QFN28) {\n\t\t \n\t\tpriv->gc.ngpio = 7;\n\t\tgpio_latch |= (gpio_rst_latch & 7) << 4;\n\t\tpriv->gpio_pushpull |= (gpio_pushpull & 7) << 4;\n\t}\n\n\t \n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\t \n\t\tif (!(priv->gpio_pushpull & BIT(i)) && (gpio_latch & BIT(i)))\n\t\t\tpriv->gpio_input |= BIT(i);\n\t}\n\n\treturn 0;\n}\n\nstatic int cp210x_gpio_init(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tint result;\n\n\tswitch (priv->partnum) {\n\tcase CP210X_PARTNUM_CP2104:\n\t\tresult = cp2104_gpioconf_init(serial);\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2105:\n\t\tresult = cp2105_gpioconf_init(serial);\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2108:\n\t\t \n\t\tif (cp210x_interface_num(serial) != 0)\n\t\t\treturn 0;\n\t\tresult = cp2108_gpio_init(serial);\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2102N_QFN28:\n\tcase CP210X_PARTNUM_CP2102N_QFN24:\n\tcase CP210X_PARTNUM_CP2102N_QFN20:\n\t\tresult = cp2102n_gpioconf_init(serial);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (result < 0)\n\t\treturn result;\n\n\tpriv->gc.label = \"cp210x\";\n\tpriv->gc.get_direction = cp210x_gpio_direction_get;\n\tpriv->gc.direction_input = cp210x_gpio_direction_input;\n\tpriv->gc.direction_output = cp210x_gpio_direction_output;\n\tpriv->gc.get = cp210x_gpio_get;\n\tpriv->gc.set = cp210x_gpio_set;\n\tpriv->gc.set_config = cp210x_gpio_set_config;\n\tpriv->gc.init_valid_mask = cp210x_gpio_init_valid_mask;\n\tpriv->gc.owner = THIS_MODULE;\n\tpriv->gc.parent = &serial->interface->dev;\n\tpriv->gc.base = -1;\n\tpriv->gc.can_sleep = true;\n\n\tresult = gpiochip_add_data(&priv->gc, serial);\n\tif (!result)\n\t\tpriv->gpio_registered = true;\n\n\treturn result;\n}\n\nstatic void cp210x_gpio_remove(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\n\tif (priv->gpio_registered) {\n\t\tgpiochip_remove(&priv->gc);\n\t\tpriv->gpio_registered = false;\n\t}\n}\n\n#else\n\nstatic int cp210x_gpio_init(struct usb_serial *serial)\n{\n\treturn 0;\n}\n\nstatic void cp210x_gpio_remove(struct usb_serial *serial)\n{\n\t \n}\n\n#endif\n\nstatic int cp210x_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cp210x_port_private *port_priv;\n\n\tport_priv = kzalloc(sizeof(*port_priv), GFP_KERNEL);\n\tif (!port_priv)\n\t\treturn -ENOMEM;\n\n\tport_priv->bInterfaceNumber = cp210x_interface_num(serial);\n\tmutex_init(&port_priv->mutex);\n\n\tusb_set_serial_port_data(port, port_priv);\n\n\treturn 0;\n}\n\nstatic void cp210x_port_remove(struct usb_serial_port *port)\n{\n\tstruct cp210x_port_private *port_priv;\n\n\tport_priv = usb_get_serial_port_data(port);\n\tkfree(port_priv);\n}\n\nstatic void cp210x_init_max_speed(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tbool use_actual_rate = false;\n\tspeed_t min = 300;\n\tspeed_t max;\n\n\tswitch (priv->partnum) {\n\tcase CP210X_PARTNUM_CP2101:\n\t\tmax = 921600;\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2102:\n\tcase CP210X_PARTNUM_CP2103:\n\t\tmax = 1000000;\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2104:\n\t\tuse_actual_rate = true;\n\t\tmax = 2000000;\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2108:\n\t\tmax = 2000000;\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2105:\n\t\tif (cp210x_interface_num(serial) == 0) {\n\t\t\tuse_actual_rate = true;\n\t\t\tmax = 2000000;\t \n\t\t} else {\n\t\t\tmin = 2400;\n\t\t\tmax = 921600;\t \n\t\t}\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2102N_QFN28:\n\tcase CP210X_PARTNUM_CP2102N_QFN24:\n\tcase CP210X_PARTNUM_CP2102N_QFN20:\n\t\tuse_actual_rate = true;\n\t\tmax = 3000000;\n\t\tbreak;\n\tdefault:\n\t\tmax = 2000000;\n\t\tbreak;\n\t}\n\n\tpriv->min_speed = min;\n\tpriv->max_speed = max;\n\tpriv->use_actual_rate = use_actual_rate;\n}\n\nstatic void cp2102_determine_quirks(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tu8 *buf;\n\tint ret;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\t \n\tret = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\tCP210X_VENDOR_SPECIFIC, REQTYPE_DEVICE_TO_HOST,\n\t\t\tCP210X_GET_PARTNUM, 0, buf, 2, USB_CTRL_GET_TIMEOUT);\n\tif (ret == 1) {\n\t\tdev_dbg(&serial->interface->dev,\n\t\t\t\t\"device does not support event-insertion mode\\n\");\n\t\tpriv->no_event_mode = true;\n\t}\n\n\tkfree(buf);\n}\n\nstatic int cp210x_get_fw_version(struct usb_serial *serial, u16 value)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tu8 ver[3];\n\tint ret;\n\n\tret = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST, value,\n\t\t\tver, sizeof(ver));\n\tif (ret)\n\t\treturn ret;\n\n\tdev_dbg(&serial->interface->dev, \"%s - %d.%d.%d\\n\", __func__,\n\t\t\tver[0], ver[1], ver[2]);\n\n\tpriv->fw_version = ver[0] << 16 | ver[1] << 8 | ver[2];\n\n\treturn 0;\n}\n\nstatic void cp210x_determine_type(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\tint ret;\n\n\tret = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,\n\t\t\tCP210X_GET_PARTNUM, &priv->partnum,\n\t\t\tsizeof(priv->partnum));\n\tif (ret < 0) {\n\t\tdev_warn(&serial->interface->dev,\n\t\t\t\t\"querying part number failed\\n\");\n\t\tpriv->partnum = CP210X_PARTNUM_UNKNOWN;\n\t\treturn;\n\t}\n\n\tdev_dbg(&serial->interface->dev, \"partnum = 0x%02x\\n\", priv->partnum);\n\n\tswitch (priv->partnum) {\n\tcase CP210X_PARTNUM_CP2102:\n\t\tcp2102_determine_quirks(serial);\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2105:\n\tcase CP210X_PARTNUM_CP2108:\n\t\tcp210x_get_fw_version(serial, CP210X_GET_FW_VER);\n\t\tbreak;\n\tcase CP210X_PARTNUM_CP2102N_QFN28:\n\tcase CP210X_PARTNUM_CP2102N_QFN24:\n\tcase CP210X_PARTNUM_CP2102N_QFN20:\n\t\tret = cp210x_get_fw_version(serial, CP210X_GET_FW_VER_2N);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (priv->fw_version <= 0x10004)\n\t\t\tpriv->no_flow_control = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic int cp210x_attach(struct usb_serial *serial)\n{\n\tint result;\n\tstruct cp210x_serial_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_data(serial, priv);\n\n\tcp210x_determine_type(serial);\n\tcp210x_init_max_speed(serial);\n\n\tresult = cp210x_gpio_init(serial);\n\tif (result < 0) {\n\t\tdev_err(&serial->interface->dev, \"GPIO initialisation failed: %d\\n\",\n\t\t\t\tresult);\n\t}\n\n\treturn 0;\n}\n\nstatic void cp210x_disconnect(struct usb_serial *serial)\n{\n\tcp210x_gpio_remove(serial);\n}\n\nstatic void cp210x_release(struct usb_serial *serial)\n{\n\tstruct cp210x_serial_private *priv = usb_get_serial_data(serial);\n\n\tcp210x_gpio_remove(serial);\n\n\tkfree(priv);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}