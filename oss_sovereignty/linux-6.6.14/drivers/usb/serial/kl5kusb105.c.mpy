{
  "module_name": "kl5kusb105.c",
  "hash_id": "f4c74bb77418899bc870baa5eebf615b1fda93cc03855ec614d2431f57af14ea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/kl5kusb105.c",
  "human_readable_source": "\n \n\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"kl5kusb105.h\"\n\n#define DRIVER_AUTHOR \"Utz-Uwe Haus <haus@uuhaus.de>, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"KLSI KL5KUSB105 chipset USB->Serial Converter driver\"\n\n\n \nstatic int klsi_105_port_probe(struct usb_serial_port *port);\nstatic void klsi_105_port_remove(struct usb_serial_port *port);\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void klsi_105_close(struct usb_serial_port *port);\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t const struct ktermios *old_termios);\nstatic int  klsi_105_tiocmget(struct tty_struct *tty);\nstatic void klsi_105_process_read_urb(struct urb *urb);\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size);\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(PALMCONNECT_VID, PALMCONNECT_PID) },\n\t{ }\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver kl5kusb105d_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"kl5kusb105d\",\n\t},\n\t.description =\t\t\"KL5KUSB105D / PalmConnect\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t64,\n\t.open =\t\t\tklsi_105_open,\n\t.close =\t\tklsi_105_close,\n\t.set_termios =\t\tklsi_105_set_termios,\n\t.tiocmget =\t\tklsi_105_tiocmget,\n\t.port_probe =\t\tklsi_105_port_probe,\n\t.port_remove =\t\tklsi_105_port_remove,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.process_read_urb =\tklsi_105_process_read_urb,\n\t.prepare_write_buffer =\tklsi_105_prepare_write_buffer,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&kl5kusb105d_device, NULL\n};\n\nstruct klsi_105_port_settings {\n\tu8\tpktlen;\t\t \n\tu8\tbaudrate;\n\tu8\tdatabits;\n\tu8\tunknown1;\n\tu8\tunknown2;\n};\n\nstruct klsi_105_private {\n\tstruct klsi_105_port_settings\tcfg;\n\tunsigned long\t\t\tline_state;  \n\tspinlock_t\t\t\tlock;\n};\n\n\n \n\n\n#define KLSI_TIMEOUT\t 5000  \n\nstatic int klsi_105_chg_port_settings(struct usb_serial_port *port,\n\t\t\t\t      struct klsi_105_port_settings *settings)\n{\n\tint rc;\n\n\trc = usb_control_msg_send(port->serial->dev,\n\t\t\t\t  0,\n\t\t\t\t  KL5KUSB105A_SIO_SET_DATA,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_OUT |\n\t\t\t\t  USB_RECIP_INTERFACE,\n\t\t\t\t  0,  \n\t\t\t\t  0,  \n\t\t\t\t  settings,\n\t\t\t\t  sizeof(struct klsi_105_port_settings),\n\t\t\t\t  KLSI_TIMEOUT,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc)\n\t\tdev_err(&port->dev,\n\t\t\t\"Change port settings failed (error = %d)\\n\", rc);\n\n\tdev_dbg(&port->dev,\n\t\t\"pktlen %u, baudrate 0x%02x, databits %u, u1 %u, u2 %u\\n\",\n\t\tsettings->pktlen, settings->baudrate, settings->databits,\n\t\tsettings->unknown1, settings->unknown2);\n\n\treturn rc;\n}\n\n \nstatic int klsi_105_get_line_state(struct usb_serial_port *port,\n\t\t\t\t   unsigned long *state)\n{\n\tu16 status;\n\tint rc;\n\n\trc = usb_control_msg_recv(port->serial->dev, 0,\n\t\t\t\t  KL5KUSB105A_SIO_POLL,\n\t\t\t\t  USB_TYPE_VENDOR | USB_DIR_IN,\n\t\t\t\t  0,  \n\t\t\t\t  0,  \n\t\t\t\t  &status, sizeof(status),\n\t\t\t\t  10000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc) {\n\t\tdev_err(&port->dev, \"reading line status failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tle16_to_cpus(&status);\n\n\tdev_dbg(&port->dev, \"read status %04x\\n\", status);\n\n\t*state = ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0) |\n\t\t ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0);\n\n\treturn 0;\n}\n\n\n \n\nstatic int klsi_105_port_probe(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = kmalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\t \n\tpriv->cfg.pktlen    = 5;\n\tpriv->cfg.baudrate  = kl5kusb105a_sio_b9600;\n\tpriv->cfg.databits  = kl5kusb105a_dtb_8;\n\tpriv->cfg.unknown1  = 0;\n\tpriv->cfg.unknown2  = 1;\n\n\tpriv->line_state    = 0;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void klsi_105_port_remove(struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int  klsi_105_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tint retval = 0;\n\tint rc;\n\tunsigned long line_state;\n\tstruct klsi_105_port_settings cfg;\n\tunsigned long flags;\n\n\t \n\n\tcfg.pktlen   = 5;\n\tcfg.baudrate = kl5kusb105a_sio_b9600;\n\tcfg.databits = kl5kusb105a_dtb_8;\n\tcfg.unknown1 = 0;\n\tcfg.unknown2 = 1;\n\tklsi_105_chg_port_settings(port, &cfg);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->cfg.pktlen   = cfg.pktlen;\n\tpriv->cfg.baudrate = cfg.baudrate;\n\tpriv->cfg.databits = cfg.databits;\n\tpriv->cfg.unknown1 = cfg.unknown1;\n\tpriv->cfg.unknown2 = cfg.unknown2;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\trc = usb_serial_generic_open(tty, port);\n\tif (rc)\n\t\treturn rc;\n\n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR|USB_DIR_OUT|USB_RECIP_INTERFACE,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_ON,\n\t\t\t     0,  \n\t\t\t     NULL,\n\t\t\t     0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev, \"Enabling read failed (error = %d)\\n\", rc);\n\t\tretval = rc;\n\t\tgoto err_generic_close;\n\t} else\n\t\tdev_dbg(&port->dev, \"%s - enabled reading\\n\", __func__);\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tretval = rc;\n\t\tgoto err_disable_read;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__,\n\t\t\tline_state);\n\n\treturn 0;\n\nerr_disable_read:\n\tusb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0,  \n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\nerr_generic_close:\n\tusb_serial_generic_close(port);\n\n\treturn retval;\n}\n\nstatic void klsi_105_close(struct usb_serial_port *port)\n{\n\tint rc;\n\n\t \n\trc = usb_control_msg(port->serial->dev,\n\t\t\t     usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE,\n\t\t\t     USB_TYPE_VENDOR | USB_DIR_OUT,\n\t\t\t     KL5KUSB105A_SIO_CONFIGURE_READ_OFF,\n\t\t\t     0,  \n\t\t\t     NULL, 0,\n\t\t\t     KLSI_TIMEOUT);\n\tif (rc < 0)\n\t\tdev_err(&port->dev, \"failed to disable read: %d\\n\", rc);\n\n\t \n\tusb_serial_generic_close(port);\n}\n\n \n#define KLSI_HDR_LEN\t\t2\nstatic int klsi_105_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tunsigned char *buf = dest;\n\tint count;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + KLSI_HDR_LEN, size,\n\t\t\t\t\t\t\t\t&port->lock);\n\tput_unaligned_le16(count, buf);\n\n\treturn count + KLSI_HDR_LEN;\n}\n\n \nstatic void klsi_105_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned len;\n\n\t \n\tif (!urb->actual_length)\n\t\treturn;\n\n\tif (urb->actual_length <= KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - malformed packet\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlen = get_unaligned_le16(data);\n\tif (len > urb->actual_length - KLSI_HDR_LEN) {\n\t\tdev_dbg(&port->dev, \"%s - packet length mismatch\\n\", __func__);\n\t\tlen = urb->actual_length - KLSI_HDR_LEN;\n\t}\n\n\ttty_insert_flip_string(&port->port, data + KLSI_HDR_LEN, len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void klsi_105_set_termios(struct tty_struct *tty,\n\t\t\t\t struct usb_serial_port *port,\n\t\t\t\t const struct ktermios *old_termios)\n{\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned int iflag = tty->termios.c_iflag;\n\tunsigned int old_iflag = old_termios->c_iflag;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned int old_cflag = old_termios->c_cflag;\n\tstruct klsi_105_port_settings *cfg;\n\tunsigned long flags;\n\tspeed_t baud;\n\n\tcfg = kmalloc(sizeof(*cfg), GFP_KERNEL);\n\tif (!cfg)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\n\tswitch (baud) {\n\tcase 0:  \n\t\tbreak;\n\tcase 1200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b1200;\n\t\tbreak;\n\tcase 2400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b2400;\n\t\tbreak;\n\tcase 4800:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b4800;\n\t\tbreak;\n\tcase 9600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbreak;\n\tcase 19200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b19200;\n\t\tbreak;\n\tcase 38400:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b38400;\n\t\tbreak;\n\tcase 57600:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b57600;\n\t\tbreak;\n\tcase 115200:\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b115200;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"unsupported baudrate, using 9600\\n\");\n\t\tpriv->cfg.baudrate = kl5kusb105a_sio_b9600;\n\t\tbaud = 9600;\n\t\tbreak;\n\t}\n\n\t \n\n\ttty_encode_baud_rate(tty, baud, baud);\n\n\tif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\n\t\t \n\t\tswitch (cflag & CSIZE) {\n\t\tcase CS5:\n\t\t\tdev_dbg(dev, \"%s - 5 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS6:\n\t\t\tdev_dbg(dev, \"%s - 6 bits/byte not supported\\n\", __func__);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\tgoto err;\n\t\tcase CS7:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_7;\n\t\t\tbreak;\n\t\tcase CS8:\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_err(dev, \"CSIZE was not CS5-CS8, using default of 8\\n\");\n\t\t\tpriv->cfg.databits = kl5kusb105a_dtb_8;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif ((cflag & (PARENB|PARODD)) != (old_cflag & (PARENB|PARODD))\n\t    || (cflag & CSTOPB) != (old_cflag & CSTOPB)) {\n\t\t \n\t\ttty->termios.c_cflag &= ~(PARENB|PARODD|CSTOPB);\n\t}\n\t \n\tif ((iflag & IXOFF) != (old_iflag & IXOFF)\n\t    || (iflag & IXON) != (old_iflag & IXON)\n\t    ||  (cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\n\t\t \n\t\ttty->termios.c_cflag &= ~CRTSCTS;\n\t}\n\tmemcpy(cfg, &priv->cfg, sizeof(*cfg));\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tklsi_105_chg_port_settings(port, cfg);\nerr:\n\tkfree(cfg);\n}\n\nstatic int klsi_105_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct klsi_105_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tint rc;\n\tunsigned long line_state;\n\n\trc = klsi_105_get_line_state(port, &line_state);\n\tif (rc < 0) {\n\t\tdev_err(&port->dev,\n\t\t\t\"Reading line control failed (error = %d)\\n\", rc);\n\t\t \n\t\treturn rc;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->line_state = line_state;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tdev_dbg(&port->dev, \"%s - read line state 0x%lx\\n\", __func__, line_state);\n\treturn (int)line_state;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}