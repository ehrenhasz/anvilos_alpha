{
  "module_name": "quatech2.c",
  "hash_id": "b96a781a9f639c5f76435411bd242cba9c9c588ece2dc007d0525cf7fe583b10",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/quatech2.c",
  "human_readable_source": "\n \n\n#include <asm/unaligned.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/uaccess.h>\n\n \n#define QT2_USB_TIMEOUT USB_CTRL_SET_TIMEOUT\n\n#define QT_OPEN_CLOSE_CHANNEL       0xca\n#define QT_SET_GET_DEVICE           0xc2\n#define QT_SET_GET_REGISTER         0xc0\n#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc\n#define QT_SET_ATF                  0xcd\n#define QT_TRANSFER_IN              0xc0\n#define QT_HW_FLOW_CONTROL_MASK     0xc5\n#define QT_SW_FLOW_CONTROL_MASK     0xc6\n#define QT2_BREAK_CONTROL\t    0xc8\n#define QT2_GET_SET_UART            0xc1\n#define QT2_FLUSH_DEVICE\t    0xc4\n#define QT2_GET_SET_QMCR            0xe1\n#define QT2_QMCR_RS232              0x40\n#define QT2_QMCR_RS422              0x10\n\n#define  SERIAL_CRTSCTS ((UART_MCR_RTS << 8) | UART_MSR_CTS)\n\n#define  SERIAL_EVEN_PARITY         (UART_LCR_PARITY | UART_LCR_EPAR)\n\n \n#define QT2_CONTROL_BYTE    0x1b\n#define QT2_LINE_STATUS     0x00   \n#define QT2_MODEM_STATUS    0x01   \n#define QT2_XMIT_HOLD       0x02   \n#define QT2_CHANGE_PORT     0x03   \n#define QT2_REC_FLUSH       0x04   \n#define QT2_XMIT_FLUSH      0x05   \n#define QT2_CONTROL_ESCAPE  0xff   \n\n#define  MAX_BAUD_RATE              921600\n#define  DEFAULT_BAUD_RATE          9600\n\n#define QT2_READ_BUFFER_SIZE    512   \n#define QT2_WRITE_BUFFER_SIZE   512   \n#define QT2_WRITE_CONTROL_SIZE  5     \n\n#define DRIVER_DESC \"Quatech 2nd gen USB to Serial Driver\"\n\n#define\tUSB_VENDOR_ID_QUATECH\t0x061d\n#define QUATECH_SSU2_100\t0xC120\t \n#define QUATECH_DSU2_100\t0xC140\t \n#define QUATECH_DSU2_400\t0xC150\t \n#define QUATECH_QSU2_100\t0xC160\t \n#define QUATECH_QSU2_400\t0xC170\t \n#define QUATECH_ESU2_100\t0xC1A0\t \n#define QUATECH_ESU2_400\t0xC180\t \n\nstruct qt2_device_detail {\n\tint product_id;\n\tint num_ports;\n};\n\n#define QT_DETAILS(prod, ports)\t\\\n\t.product_id = (prod),   \\\n\t.num_ports = (ports)\n\nstatic const struct qt2_device_detail qt2_device_details[] = {\n\t{QT_DETAILS(QUATECH_SSU2_100, 1)},\n\t{QT_DETAILS(QUATECH_DSU2_400, 2)},\n\t{QT_DETAILS(QUATECH_DSU2_100, 2)},\n\t{QT_DETAILS(QUATECH_QSU2_400, 4)},\n\t{QT_DETAILS(QUATECH_QSU2_100, 4)},\n\t{QT_DETAILS(QUATECH_ESU2_400, 8)},\n\t{QT_DETAILS(QUATECH_ESU2_100, 8)},\n\t{QT_DETAILS(0, 0)}\t \n};\n\nstatic const struct usb_device_id id_table[] = {\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU2_100)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU2_100)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_DSU2_400)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU2_100)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_QSU2_400)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU2_100)},\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_ESU2_400)},\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct qt2_serial_private {\n\tunsigned char current_port;   \n\n\tstruct urb\t*read_urb;    \n\tchar\t\t*read_buffer;\n};\n\nstruct qt2_port_private {\n\tu8   device_port;\n\n\tspinlock_t urb_lock;\n\tbool       urb_in_use;\n\tstruct urb *write_urb;\n\tchar       *write_buffer;\n\n\tspinlock_t  lock;\n\tu8          shadowLSR;\n\tu8          shadowMSR;\n\n\tstruct usb_serial_port *port;\n};\n\nstatic void qt2_update_lsr(struct usb_serial_port *port, unsigned char *ch);\nstatic void qt2_update_msr(struct usb_serial_port *port, unsigned char *ch);\nstatic void qt2_write_bulk_callback(struct urb *urb);\nstatic void qt2_read_bulk_callback(struct urb *urb);\n\nstatic void qt2_release(struct usb_serial *serial)\n{\n\tstruct qt2_serial_private *serial_priv;\n\n\tserial_priv = usb_get_serial_data(serial);\n\n\tusb_kill_urb(serial_priv->read_urb);\n\tusb_free_urb(serial_priv->read_urb);\n\tkfree(serial_priv->read_buffer);\n\tkfree(serial_priv);\n}\n\nstatic inline int calc_baud_divisor(int baudrate)\n{\n\tint divisor, rem;\n\n\tdivisor = MAX_BAUD_RATE / baudrate;\n\trem = MAX_BAUD_RATE % baudrate;\n\t \n\tif (((rem * 2) >= baudrate) && (baudrate != 110))\n\t\tdivisor++;\n\n\treturn divisor;\n}\n\nstatic inline int qt2_set_port_config(struct usb_device *dev,\n\t\t\t\t      unsigned char port_number,\n\t\t\t\t      u16 baudrate, u16 lcr)\n{\n\tint divisor = calc_baud_divisor(baudrate);\n\tu16 index = ((u16) (lcr << 8) | (u16) (port_number));\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t       QT2_GET_SET_UART, 0x40,\n\t\t\t       divisor, index, NULL, 0, QT2_USB_TIMEOUT);\n}\n\nstatic inline int qt2_control_msg(struct usb_device *dev,\n\t\t\t\t  u8 request, u16 data, u16 index)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t       request, 0x40, data, index,\n\t\t\t       NULL, 0, QT2_USB_TIMEOUT);\n}\n\nstatic inline int qt2_getregister(struct usb_device *dev,\n\t\t\t\t  u8 uart,\n\t\t\t\t  u8 reg,\n\t\t\t\t  u8 *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      QT_SET_GET_REGISTER, 0xc0, reg,\n\t\t\t      uart, data, sizeof(*data), QT2_USB_TIMEOUT);\n\tif (ret < (int)sizeof(*data)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int qt2_setregister(struct usb_device *dev,\n\t\t\t\t  u8 uart, u8 reg, u16 data)\n{\n\tu16 value = (data << 8) | reg;\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t       QT_SET_GET_REGISTER, 0x40, value, uart,\n\t\t\t       NULL, 0, QT2_USB_TIMEOUT);\n}\n\nstatic inline int update_mctrl(struct qt2_port_private *port_priv,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = port_priv->port;\n\tstruct usb_device *dev = port->serial->dev;\n\tunsigned urb_value;\n\tint status;\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\n\t\tdev_dbg(&port->dev,\n\t\t\t\"update_mctrl - DTR|RTS not being set|cleared\\n\");\n\t\treturn 0;\t \n\t}\n\n\tclear &= ~set;\t \n\turb_value = 0;\n\tif (set & TIOCM_DTR)\n\t\turb_value |= UART_MCR_DTR;\n\tif (set & TIOCM_RTS)\n\t\turb_value |= UART_MCR_RTS;\n\n\tstatus = qt2_setregister(dev, port_priv->device_port, UART_MCR,\n\t\t\t\t urb_value);\n\tif (status < 0)\n\t\tdev_err(&port->dev,\n\t\t\t\"update_mctrl - Error from MODEM_CTRL urb: %i\\n\",\n\t\t\tstatus);\n\treturn status;\n}\n\nstatic int qt2_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct qt2_device_detail d;\n\tint i;\n\n\tfor (i = 0; d = qt2_device_details[i], d.product_id != 0; i++) {\n\t\tif (d.product_id == le16_to_cpu(serial->dev->descriptor.idProduct))\n\t\t\treturn d.num_ports;\n\t}\n\n\t \n\tdev_err(&serial->dev->dev,\n\t\t \"don't know the number of ports, assuming 1\\n\");\n\n\treturn 1;\n}\n\nstatic void qt2_set_termios(struct tty_struct *tty,\n\t\t            struct usb_serial_port *port,\n\t\t            const struct ktermios *old_termios)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct qt2_port_private *port_priv;\n\tstruct ktermios *termios = &tty->termios;\n\tu16 baud;\n\tunsigned int cflag = termios->c_cflag;\n\tu16 new_lcr = 0;\n\tint status;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD)\n\t\t\tnew_lcr |= UART_LCR_PARITY;\n\t\telse\n\t\t\tnew_lcr |= SERIAL_EVEN_PARITY;\n\t}\n\n\tnew_lcr |= UART_LCR_WLEN(tty_get_char_size(cflag));\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\tbaud = 9600;\n\n\tstatus = qt2_set_port_config(dev, port_priv->device_port, baud,\n\t\t\t\t     new_lcr);\n\tif (status < 0)\n\t\tdev_err(&port->dev, \"%s - qt2_set_port_config failed: %i\\n\",\n\t\t\t__func__, status);\n\n\tif (cflag & CRTSCTS)\n\t\tstatus = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\n\t\t\t\t\t SERIAL_CRTSCTS,\n\t\t\t\t\t port_priv->device_port);\n\telse\n\t\tstatus = qt2_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\n\t\t\t\t\t 0, port_priv->device_port);\n\tif (status < 0)\n\t\tdev_err(&port->dev, \"%s - set HW flow control failed: %i\\n\",\n\t\t\t__func__, status);\n\n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tu16 x = ((u16) (START_CHAR(tty) << 8) | (u16) (STOP_CHAR(tty)));\n\n\t\tstatus = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\n\t\t\t\t\t x, port_priv->device_port);\n\t} else\n\t\tstatus = qt2_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\n\t\t\t\t\t 0, port_priv->device_port);\n\n\tif (status < 0)\n\t\tdev_err(&port->dev, \"%s - set SW flow control failed: %i\\n\",\n\t\t\t__func__, status);\n\n}\n\nstatic int qt2_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial;\n\tstruct qt2_port_private *port_priv;\n\tu8 *data;\n\tu16 device_port;\n\tint status;\n\tunsigned long flags;\n\n\tdevice_port = port->port_number;\n\n\tserial = port->serial;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\t \n\tstatus = qt2_control_msg(serial->dev, QT2_GET_SET_QMCR,\n\t\t\t\t QT2_QMCR_RS232, device_port);\n\tif (status < 0) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s failed to set RS232 mode for port %i error %i\\n\",\n\t\t\t__func__, device_port, status);\n\t\treturn status;\n\t}\n\n\tdata = kzalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\tstatus = usb_control_msg(serial->dev,\n\t\t\t\t usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t QT_OPEN_CLOSE_CHANNEL,\n\t\t\t\t 0xc0, 0,\n\t\t\t\t device_port, data, 2, QT2_USB_TIMEOUT);\n\n\tif (status < 2) {\n\t\tdev_err(&port->dev, \"%s - open port failed %i\\n\", __func__,\n\t\t\tstatus);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\tkfree(data);\n\t\treturn status;\n\t}\n\n\tspin_lock_irqsave(&port_priv->lock, flags);\n\tport_priv->shadowLSR = data[0];\n\tport_priv->shadowMSR = data[1];\n\tspin_unlock_irqrestore(&port_priv->lock, flags);\n\n\tkfree(data);\n\n\t \n\tstatus = qt2_set_port_config(serial->dev, device_port,\n\t\t\t\t     DEFAULT_BAUD_RATE, UART_LCR_WLEN8);\n\tif (status < 0) {\n\t\tdev_err(&port->dev, \"%s - initial setup failed (%i)\\n\",\n\t\t\t__func__, device_port);\n\t\treturn status;\n\t}\n\n\tport_priv->device_port = (u8) device_port;\n\n\tif (tty)\n\t\tqt2_set_termios(tty, port, &tty->termios);\n\n\treturn 0;\n\n}\n\nstatic void qt2_close(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial;\n\tstruct qt2_port_private *port_priv;\n\tint i;\n\n\tserial = port->serial;\n\tport_priv = usb_get_serial_port_data(port);\n\n\tusb_kill_urb(port_priv->write_urb);\n\n\t \n\ti = usb_control_msg(serial->dev,\n\t\t\t    usb_sndctrlpipe(serial->dev, 0),\n\t\t\t    QT2_FLUSH_DEVICE, 0x40, 1,\n\t\t\t    port_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\n\n\tif (i < 0)\n\t\tdev_err(&port->dev, \"%s - transmit buffer flush failed: %i\\n\",\n\t\t\t__func__, i);\n\n\t \n\ti = usb_control_msg(serial->dev,\n\t\t\t    usb_sndctrlpipe(serial->dev, 0),\n\t\t\t    QT2_FLUSH_DEVICE, 0x40, 0,\n\t\t\t    port_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\n\n\tif (i < 0)\n\t\tdev_err(&port->dev, \"%s - receive buffer flush failed: %i\\n\",\n\t\t\t__func__, i);\n\n\t \n\ti = usb_control_msg(serial->dev,\n\t\t\t    usb_sndctrlpipe(serial->dev, 0),\n\t\t\t    QT_OPEN_CLOSE_CHANNEL,\n\t\t\t    0x40, 0,\n\t\t\t    port_priv->device_port, NULL, 0, QT2_USB_TIMEOUT);\n\n\tif (i < 0)\n\t\tdev_err(&port->dev, \"%s - close port failed %i\\n\",\n\t\t\t__func__, i);\n}\n\nstatic void qt2_disconnect(struct usb_serial *serial)\n{\n\tstruct qt2_serial_private *serial_priv = usb_get_serial_data(serial);\n\n\tusb_kill_urb(serial_priv->read_urb);\n}\n\nstatic void qt2_process_status(struct usb_serial_port *port, unsigned char *ch)\n{\n\tswitch (*ch) {\n\tcase QT2_LINE_STATUS:\n\t\tqt2_update_lsr(port, ch + 1);\n\t\tbreak;\n\tcase QT2_MODEM_STATUS:\n\t\tqt2_update_msr(port, ch + 1);\n\t\tbreak;\n\t}\n}\n\nstatic void qt2_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial *serial;\n\tstruct qt2_serial_private *serial_priv;\n\tstruct usb_serial_port *port;\n\tbool escapeflag;\n\tunsigned char *ch;\n\tint i;\n\tunsigned char newport;\n\tint len = urb->actual_length;\n\n\tif (!len)\n\t\treturn;\n\n\tch = urb->transfer_buffer;\n\tserial = urb->context;\n\tserial_priv = usb_get_serial_data(serial);\n\tport = serial->port[serial_priv->current_port];\n\n\tfor (i = 0; i < urb->actual_length; i++) {\n\t\tch = (unsigned char *)urb->transfer_buffer + i;\n\t\tif ((i <= (len - 3)) &&\n\t\t    (*ch == QT2_CONTROL_BYTE) &&\n\t\t    (*(ch + 1) == QT2_CONTROL_BYTE)) {\n\t\t\tescapeflag = false;\n\t\t\tswitch (*(ch + 2)) {\n\t\t\tcase QT2_LINE_STATUS:\n\t\t\tcase QT2_MODEM_STATUS:\n\t\t\t\tif (i > (len - 4)) {\n\t\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t\t \"%s - status message too short\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tqt2_process_status(port, ch + 2);\n\t\t\t\ti += 3;\n\t\t\t\tescapeflag = true;\n\t\t\t\tbreak;\n\t\t\tcase QT2_XMIT_HOLD:\n\t\t\t\tif (i > (len - 5)) {\n\t\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t\t \"%s - xmit_empty message too short\\n\",\n\t\t\t\t\t\t __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\ti += 4;\n\t\t\t\tescapeflag = true;\n\t\t\t\tbreak;\n\t\t\tcase QT2_CHANGE_PORT:\n\t\t\t\tif (i > (len - 4)) {\n\t\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t\t \"%s - change_port message too short\\n\",\n\t\t\t\t\t\t __func__);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttty_flip_buffer_push(&port->port);\n\n\t\t\t\tnewport = *(ch + 3);\n\n\t\t\t\tif (newport > serial->num_ports) {\n\t\t\t\t\tdev_err(&port->dev,\n\t\t\t\t\t\t\"%s - port change to invalid port: %i\\n\",\n\t\t\t\t\t\t__func__, newport);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tserial_priv->current_port = newport;\n\t\t\t\tport = serial->port[serial_priv->current_port];\n\t\t\t\ti += 3;\n\t\t\t\tescapeflag = true;\n\t\t\t\tbreak;\n\t\t\tcase QT2_REC_FLUSH:\n\t\t\tcase QT2_XMIT_FLUSH:\n\t\t\t\ti += 2;\n\t\t\t\tescapeflag = true;\n\t\t\t\tbreak;\n\t\t\tcase QT2_CONTROL_ESCAPE:\n\t\t\t\ttty_insert_flip_string(&port->port, ch, 2);\n\t\t\t\ti += 2;\n\t\t\t\tescapeflag = true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_warn(&port->dev,\n\t\t\t\t\t \"%s - unsupported command %i\\n\",\n\t\t\t\t\t __func__, *(ch + 2));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (escapeflag)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\ttty_insert_flip_char(&port->port, *ch, TTY_NORMAL);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void qt2_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct qt2_port_private *port_priv;\n\tunsigned long flags;\n\n\tport = urb->context;\n\tport_priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irqsave(&port_priv->urb_lock, flags);\n\n\tport_priv->urb_in_use = false;\n\tusb_serial_port_softint(port);\n\n\tspin_unlock_irqrestore(&port_priv->urb_lock, flags);\n\n}\n\nstatic void qt2_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial *serial = urb->context;\n\tint status;\n\n\tif (urb->status) {\n\t\tdev_warn(&serial->dev->dev,\n\t\t\t \"%s - non-zero urb status: %i\\n\", __func__,\n\t\t\t urb->status);\n\t\treturn;\n\t}\n\n\tqt2_process_read_urb(urb);\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status != 0)\n\t\tdev_err(&serial->dev->dev,\n\t\t\t\"%s - resubmit read urb failed: %i\\n\",\n\t\t\t__func__, status);\n}\n\nstatic int qt2_setup_urbs(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port0;\n\tstruct qt2_serial_private *serial_priv;\n\tint status;\n\n\tport0 = serial->port[0];\n\n\tserial_priv = usb_get_serial_data(serial);\n\tserial_priv->read_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!serial_priv->read_urb)\n\t\treturn -ENOMEM;\n\n\tusb_fill_bulk_urb(serial_priv->read_urb, serial->dev,\n\t\t\t  usb_rcvbulkpipe(serial->dev,\n\t\t\t\t\t  port0->bulk_in_endpointAddress),\n\t\t\t  serial_priv->read_buffer,\n\t\t\t  QT2_READ_BUFFER_SIZE,\n\t\t\t  qt2_read_bulk_callback, serial);\n\n\tstatus = usb_submit_urb(serial_priv->read_urb, GFP_KERNEL);\n\tif (status != 0) {\n\t\tdev_err(&serial->dev->dev,\n\t\t\t\"%s - submit read urb failed %i\\n\", __func__, status);\n\t\tusb_free_urb(serial_priv->read_urb);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int qt2_attach(struct usb_serial *serial)\n{\n\tstruct qt2_serial_private *serial_priv;\n\tint status;\n\n\t \n\tstatus = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t 0xc2, 0x40, 0x8000, 0, NULL, 0,\n\t\t\t\t QT2_USB_TIMEOUT);\n\tif (status < 0) {\n\t\tdev_err(&serial->dev->dev,\n\t\t\t\"%s - failed to power on unit: %i\\n\", __func__, status);\n\t\treturn status;\n\t}\n\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tserial_priv->read_buffer = kmalloc(QT2_READ_BUFFER_SIZE, GFP_KERNEL);\n\tif (!serial_priv->read_buffer) {\n\t\tstatus = -ENOMEM;\n\t\tgoto err_buf;\n\t}\n\n\tusb_set_serial_data(serial, serial_priv);\n\n\tstatus = qt2_setup_urbs(serial);\n\tif (status != 0)\n\t\tgoto attach_failed;\n\n\treturn 0;\n\nattach_failed:\n\tkfree(serial_priv->read_buffer);\nerr_buf:\n\tkfree(serial_priv);\n\treturn status;\n}\n\nstatic int qt2_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct qt2_port_private *port_priv;\n\tu8 bEndpointAddress;\n\n\tport_priv = kzalloc(sizeof(*port_priv), GFP_KERNEL);\n\tif (!port_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&port_priv->lock);\n\tspin_lock_init(&port_priv->urb_lock);\n\tport_priv->port = port;\n\n\tport_priv->write_buffer = kmalloc(QT2_WRITE_BUFFER_SIZE, GFP_KERNEL);\n\tif (!port_priv->write_buffer)\n\t\tgoto err_buf;\n\n\tport_priv->write_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!port_priv->write_urb)\n\t\tgoto err_urb;\n\n\tbEndpointAddress = serial->port[0]->bulk_out_endpointAddress;\n\tusb_fill_bulk_urb(port_priv->write_urb, serial->dev,\n\t\t\t\tusb_sndbulkpipe(serial->dev, bEndpointAddress),\n\t\t\t\tport_priv->write_buffer,\n\t\t\t\tQT2_WRITE_BUFFER_SIZE,\n\t\t\t\tqt2_write_bulk_callback, port);\n\n\tusb_set_serial_port_data(port, port_priv);\n\n\treturn 0;\nerr_urb:\n\tkfree(port_priv->write_buffer);\nerr_buf:\n\tkfree(port_priv);\n\treturn -ENOMEM;\n}\n\nstatic void qt2_port_remove(struct usb_serial_port *port)\n{\n\tstruct qt2_port_private *port_priv;\n\n\tport_priv = usb_get_serial_port_data(port);\n\tusb_free_urb(port_priv->write_urb);\n\tkfree(port_priv->write_buffer);\n\tkfree(port_priv);\n}\n\nstatic int qt2_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct qt2_port_private *port_priv = usb_get_serial_port_data(port);\n\tu8 *d;\n\tint r;\n\n\td = kzalloc(2, GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tr = qt2_getregister(dev, port_priv->device_port, UART_MCR, d);\n\tif (r < 0)\n\t\tgoto mget_out;\n\n\tr = qt2_getregister(dev, port_priv->device_port, UART_MSR, d + 1);\n\tif (r < 0)\n\t\tgoto mget_out;\n\n\tr = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |\n\t    (d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |\n\t    (d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |\n\t    (d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |\n\t    (d[1] & UART_MSR_RI ? TIOCM_RI : 0) |\n\t    (d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);\n\nmget_out:\n\tkfree(d);\n\treturn r;\n}\n\nstatic int qt2_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct qt2_port_private *port_priv;\n\n\tport_priv = usb_get_serial_port_data(tty->driver_data);\n\treturn update_mctrl(port_priv, set, clear);\n}\n\nstatic int qt2_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct qt2_port_private *port_priv;\n\tint status;\n\tu16 val;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\tval = (break_state == -1) ? 1 : 0;\n\n\tstatus = qt2_control_msg(port->serial->dev, QT2_BREAK_CONTROL,\n\t\t\t\t val, port_priv->device_port);\n\tif (status < 0) {\n\t\tdev_warn(&port->dev,\n\t\t\t \"%s - failed to send control message: %i\\n\", __func__,\n\t\t\t status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n\n\nstatic void qt2_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct qt2_port_private *port_priv = usb_get_serial_port_data(port);\n\n\t \n\tif (!on) {\n\t\tif (qt2_setregister(dev, port_priv->device_port,\n\t\t\t\t\t   UART_MCR, 0) < 0)\n\t\t\tdev_warn(&port->dev, \"error from flowcontrol urb\\n\");\n\t}\n\t \n\tif (on)\n\t\tupdate_mctrl(port_priv, TIOCM_DTR | TIOCM_RTS, 0);\n\telse\n\t\tupdate_mctrl(port_priv, 0, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic void qt2_update_msr(struct usb_serial_port *port, unsigned char *ch)\n{\n\tstruct qt2_port_private *port_priv;\n\tu8 newMSR = (u8) *ch;\n\tunsigned long flags;\n\n\t \n\tport_priv = usb_get_serial_port_data(port);\n\tif (!port_priv)\n\t\treturn;\n\n\tspin_lock_irqsave(&port_priv->lock, flags);\n\tport_priv->shadowMSR = newMSR;\n\tspin_unlock_irqrestore(&port_priv->lock, flags);\n\n\tif (newMSR & UART_MSR_ANY_DELTA) {\n\t\t \n\t\tif (newMSR & UART_MSR_DCTS)\n\t\t\tport->icount.cts++;\n\t\tif (newMSR & UART_MSR_DDSR)\n\t\t\tport->icount.dsr++;\n\t\tif (newMSR & UART_MSR_DDCD)\n\t\t\tport->icount.dcd++;\n\t\tif (newMSR & UART_MSR_TERI)\n\t\t\tport->icount.rng++;\n\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t}\n}\n\nstatic void qt2_update_lsr(struct usb_serial_port *port, unsigned char *ch)\n{\n\tstruct qt2_port_private *port_priv;\n\tstruct async_icount *icount;\n\tunsigned long flags;\n\tu8 newLSR = (u8) *ch;\n\n\t \n\tport_priv = usb_get_serial_port_data(port);\n\tif (!port_priv)\n\t\treturn;\n\n\tif (newLSR & UART_LSR_BI)\n\t\tnewLSR &= (u8) (UART_LSR_OE | UART_LSR_BI);\n\n\tspin_lock_irqsave(&port_priv->lock, flags);\n\tport_priv->shadowLSR = newLSR;\n\tspin_unlock_irqrestore(&port_priv->lock, flags);\n\n\ticount = &port->icount;\n\n\tif (newLSR & UART_LSR_BRK_ERROR_BITS) {\n\n\t\tif (newLSR & UART_LSR_BI)\n\t\t\ticount->brk++;\n\n\t\tif (newLSR & UART_LSR_OE)\n\t\t\ticount->overrun++;\n\n\t\tif (newLSR & UART_LSR_PE)\n\t\t\ticount->parity++;\n\n\t\tif (newLSR & UART_LSR_FE)\n\t\t\ticount->frame++;\n\t}\n\n}\n\nstatic unsigned int qt2_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct qt2_port_private *port_priv;\n\tunsigned long flags;\n\tunsigned int r;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irqsave(&port_priv->urb_lock, flags);\n\n\tif (port_priv->urb_in_use)\n\t\tr = 0;\n\telse\n\t\tr = QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE;\n\n\tspin_unlock_irqrestore(&port_priv->urb_lock, flags);\n\n\treturn r;\n}\n\nstatic int qt2_write(struct tty_struct *tty,\n\t\t     struct usb_serial_port *port,\n\t\t     const unsigned char *buf, int count)\n{\n\tstruct qt2_port_private *port_priv;\n\tstruct urb *write_urb;\n\tunsigned char *data;\n\tunsigned long flags;\n\tint status;\n\tint bytes_out = 0;\n\n\tport_priv = usb_get_serial_port_data(port);\n\n\tif (port_priv->write_urb == NULL) {\n\t\tdev_err(&port->dev, \"%s - no output urb\\n\", __func__);\n\t\treturn 0;\n\t}\n\twrite_urb = port_priv->write_urb;\n\n\tcount = min(count, QT2_WRITE_BUFFER_SIZE - QT2_WRITE_CONTROL_SIZE);\n\n\tdata = write_urb->transfer_buffer;\n\tspin_lock_irqsave(&port_priv->urb_lock, flags);\n\tif (port_priv->urb_in_use) {\n\t\tdev_err(&port->dev, \"qt2_write - urb is in use\\n\");\n\t\tgoto write_out;\n\t}\n\n\t*data++ = QT2_CONTROL_BYTE;\n\t*data++ = QT2_CONTROL_BYTE;\n\t*data++ = port_priv->device_port;\n\tput_unaligned_le16(count, data);\n\tdata += 2;\n\tmemcpy(data, buf, count);\n\n\twrite_urb->transfer_buffer_length = count + QT2_WRITE_CONTROL_SIZE;\n\n\tstatus = usb_submit_urb(write_urb, GFP_ATOMIC);\n\tif (status == 0) {\n\t\tport_priv->urb_in_use = true;\n\t\tbytes_out += count;\n\t}\n\nwrite_out:\n\tspin_unlock_irqrestore(&port_priv->urb_lock, flags);\n\treturn bytes_out;\n}\n\n\nstatic struct usb_serial_driver qt2_device = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"quatech-serial\",\n\t},\n\t.description\t     = DRIVER_DESC,\n\t.id_table\t     = id_table,\n\t.open\t\t     = qt2_open,\n\t.close\t\t     = qt2_close,\n\t.write               = qt2_write,\n\t.write_room          = qt2_write_room,\n\t.calc_num_ports      = qt2_calc_num_ports,\n\t.attach              = qt2_attach,\n\t.release             = qt2_release,\n\t.disconnect          = qt2_disconnect,\n\t.port_probe          = qt2_port_probe,\n\t.port_remove         = qt2_port_remove,\n\t.dtr_rts             = qt2_dtr_rts,\n\t.break_ctl           = qt2_break_ctl,\n\t.tiocmget            = qt2_tiocmget,\n\t.tiocmset            = qt2_tiocmset,\n\t.tiocmiwait          = usb_serial_generic_tiocmiwait,\n\t.get_icount\t     = usb_serial_generic_get_icount,\n\t.set_termios         = qt2_set_termios,\n};\n\nstatic struct usb_serial_driver *const serial_drivers[] = {\n\t&qt2_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}