{
  "module_name": "xr_serial.c",
  "hash_id": "f8e9680b110950c98cd5f0caaaba6cd41e007fbc0b6851202bfa48e2fa66f2b6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/xr_serial.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/usb.h>\n#include <linux/usb/cdc.h>\n#include <linux/usb/serial.h>\n\nstruct xr_txrx_clk_mask {\n\tu16 tx;\n\tu16 rx0;\n\tu16 rx1;\n};\n\n#define XR_INT_OSC_HZ\t\t\t48000000U\n#define XR21V141X_MIN_SPEED\t\t46U\n#define XR21V141X_MAX_SPEED\t\tXR_INT_OSC_HZ\n\n \n#define XR21V141X_UART_REG_BLOCK\t0\n#define XR21V141X_UM_REG_BLOCK\t\t4\n#define XR21V141X_UART_CUSTOM_BLOCK\t0x66\n\n \n#define XR21V141X_CLOCK_DIVISOR_0\t0x04\n#define XR21V141X_CLOCK_DIVISOR_1\t0x05\n#define XR21V141X_CLOCK_DIVISOR_2\t0x06\n#define XR21V141X_TX_CLOCK_MASK_0\t0x07\n#define XR21V141X_TX_CLOCK_MASK_1\t0x08\n#define XR21V141X_RX_CLOCK_MASK_0\t0x09\n#define XR21V141X_RX_CLOCK_MASK_1\t0x0a\n#define XR21V141X_REG_FORMAT\t\t0x0b\n\n \n#define XR21V141X_UM_FIFO_ENABLE_REG\t0x10\n#define XR21V141X_UM_ENABLE_TX_FIFO\t0x01\n#define XR21V141X_UM_ENABLE_RX_FIFO\t0x02\n\n#define XR21V141X_UM_RX_FIFO_RESET\t0x18\n#define XR21V141X_UM_TX_FIFO_RESET\t0x1c\n\n#define XR_UART_ENABLE_TX\t\t0x1\n#define XR_UART_ENABLE_RX\t\t0x2\n\n#define XR_GPIO_RI\t\t\tBIT(0)\n#define XR_GPIO_CD\t\t\tBIT(1)\n#define XR_GPIO_DSR\t\t\tBIT(2)\n#define XR_GPIO_DTR\t\t\tBIT(3)\n#define XR_GPIO_CTS\t\t\tBIT(4)\n#define XR_GPIO_RTS\t\t\tBIT(5)\n#define XR_GPIO_CLK\t\t\tBIT(6)\n#define XR_GPIO_XEN\t\t\tBIT(7)\n#define XR_GPIO_TXT\t\t\tBIT(8)\n#define XR_GPIO_RXT\t\t\tBIT(9)\n\n#define XR_UART_DATA_MASK\t\tGENMASK(3, 0)\n#define XR_UART_DATA_7\t\t\t0x7\n#define XR_UART_DATA_8\t\t\t0x8\n\n#define XR_UART_PARITY_MASK\t\tGENMASK(6, 4)\n#define XR_UART_PARITY_SHIFT\t\t4\n#define XR_UART_PARITY_NONE\t\t(0x0 << XR_UART_PARITY_SHIFT)\n#define XR_UART_PARITY_ODD\t\t(0x1 << XR_UART_PARITY_SHIFT)\n#define XR_UART_PARITY_EVEN\t\t(0x2 <<\tXR_UART_PARITY_SHIFT)\n#define XR_UART_PARITY_MARK\t\t(0x3 << XR_UART_PARITY_SHIFT)\n#define XR_UART_PARITY_SPACE\t\t(0x4 << XR_UART_PARITY_SHIFT)\n\n#define XR_UART_STOP_MASK\t\tBIT(7)\n#define XR_UART_STOP_SHIFT\t\t7\n#define XR_UART_STOP_1\t\t\t(0x0 << XR_UART_STOP_SHIFT)\n#define XR_UART_STOP_2\t\t\t(0x1 << XR_UART_STOP_SHIFT)\n\n#define XR_UART_FLOW_MODE_NONE\t\t0x0\n#define XR_UART_FLOW_MODE_HW\t\t0x1\n#define XR_UART_FLOW_MODE_SW\t\t0x2\n\n#define XR_GPIO_MODE_SEL_MASK\t\tGENMASK(2, 0)\n#define XR_GPIO_MODE_SEL_RTS_CTS\t0x1\n#define XR_GPIO_MODE_SEL_DTR_DSR\t0x2\n#define XR_GPIO_MODE_SEL_RS485\t\t0x3\n#define XR_GPIO_MODE_SEL_RS485_ADDR\t0x4\n#define XR_GPIO_MODE_RS485_TX_H\t\t0x8\n#define XR_GPIO_MODE_TX_TOGGLE\t\t0x100\n#define XR_GPIO_MODE_RX_TOGGLE\t\t0x200\n\n#define XR_FIFO_RESET\t\t\t0x1\n\n#define XR_CUSTOM_DRIVER_ACTIVE\t\t0x1\n\nstatic int xr21v141x_uart_enable(struct usb_serial_port *port);\nstatic int xr21v141x_uart_disable(struct usb_serial_port *port);\nstatic int xr21v141x_fifo_reset(struct usb_serial_port *port);\nstatic void xr21v141x_set_line_settings(struct tty_struct *tty,\n\t\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\t\tconst struct ktermios *old_termios);\n\nstruct xr_type {\n\tint reg_width;\n\tu8 reg_recipient;\n\tu8 set_reg;\n\tu8 get_reg;\n\n\tu16 uart_enable;\n\tu16 flow_control;\n\tu16 xon_char;\n\tu16 xoff_char;\n\tu16 tx_break;\n\tu16 gpio_mode;\n\tu16 gpio_direction;\n\tu16 gpio_set;\n\tu16 gpio_clear;\n\tu16 gpio_status;\n\tu16 tx_fifo_reset;\n\tu16 rx_fifo_reset;\n\tu16 custom_driver;\n\n\tbool have_5_6_bit_mode;\n\tbool have_xmit_toggle;\n\n\tint (*enable)(struct usb_serial_port *port);\n\tint (*disable)(struct usb_serial_port *port);\n\tint (*fifo_reset)(struct usb_serial_port *port);\n\tvoid (*set_line_settings)(struct tty_struct *tty,\n\t\t\t\t  struct usb_serial_port *port,\n\t\t\t\t  const struct ktermios *old_termios);\n};\n\nenum xr_type_id {\n\tXR21V141X,\n\tXR21B142X,\n\tXR21B1411,\n\tXR2280X,\n\tXR_TYPE_COUNT,\n};\n\nstatic const struct xr_type xr_types[] = {\n\t[XR21V141X] = {\n\t\t.reg_width\t= 8,\n\t\t.reg_recipient\t= USB_RECIP_DEVICE,\n\t\t.set_reg\t= 0x00,\n\t\t.get_reg\t= 0x01,\n\n\t\t.uart_enable\t= 0x03,\n\t\t.flow_control\t= 0x0c,\n\t\t.xon_char\t= 0x10,\n\t\t.xoff_char\t= 0x11,\n\t\t.tx_break\t= 0x14,\n\t\t.gpio_mode\t= 0x1a,\n\t\t.gpio_direction\t= 0x1b,\n\t\t.gpio_set\t= 0x1d,\n\t\t.gpio_clear\t= 0x1e,\n\t\t.gpio_status\t= 0x1f,\n\n\t\t.enable\t\t\t= xr21v141x_uart_enable,\n\t\t.disable\t\t= xr21v141x_uart_disable,\n\t\t.fifo_reset\t\t= xr21v141x_fifo_reset,\n\t\t.set_line_settings\t= xr21v141x_set_line_settings,\n\t},\n\t[XR21B142X] = {\n\t\t.reg_width\t= 16,\n\t\t.reg_recipient\t= USB_RECIP_INTERFACE,\n\t\t.set_reg\t= 0x00,\n\t\t.get_reg\t= 0x00,\n\n\t\t.uart_enable\t= 0x00,\n\t\t.flow_control\t= 0x06,\n\t\t.xon_char\t= 0x07,\n\t\t.xoff_char\t= 0x08,\n\t\t.tx_break\t= 0x0a,\n\t\t.gpio_mode\t= 0x0c,\n\t\t.gpio_direction\t= 0x0d,\n\t\t.gpio_set\t= 0x0e,\n\t\t.gpio_clear\t= 0x0f,\n\t\t.gpio_status\t= 0x10,\n\t\t.tx_fifo_reset\t= 0x40,\n\t\t.rx_fifo_reset\t= 0x43,\n\t\t.custom_driver\t= 0x60,\n\n\t\t.have_5_6_bit_mode\t= true,\n\t\t.have_xmit_toggle\t= true,\n\t},\n\t[XR21B1411] = {\n\t\t.reg_width\t= 12,\n\t\t.reg_recipient\t= USB_RECIP_DEVICE,\n\t\t.set_reg\t= 0x00,\n\t\t.get_reg\t= 0x01,\n\n\t\t.uart_enable\t= 0xc00,\n\t\t.flow_control\t= 0xc06,\n\t\t.xon_char\t= 0xc07,\n\t\t.xoff_char\t= 0xc08,\n\t\t.tx_break\t= 0xc0a,\n\t\t.gpio_mode\t= 0xc0c,\n\t\t.gpio_direction\t= 0xc0d,\n\t\t.gpio_set\t= 0xc0e,\n\t\t.gpio_clear\t= 0xc0f,\n\t\t.gpio_status\t= 0xc10,\n\t\t.tx_fifo_reset\t= 0xc80,\n\t\t.rx_fifo_reset\t= 0xcc0,\n\t\t.custom_driver\t= 0x20d,\n\t},\n\t[XR2280X] = {\n\t\t.reg_width\t= 16,\n\t\t.reg_recipient\t= USB_RECIP_DEVICE,\n\t\t.set_reg\t= 0x05,\n\t\t.get_reg\t= 0x05,\n\n\t\t.uart_enable\t= 0x40,\n\t\t.flow_control\t= 0x46,\n\t\t.xon_char\t= 0x47,\n\t\t.xoff_char\t= 0x48,\n\t\t.tx_break\t= 0x4a,\n\t\t.gpio_mode\t= 0x4c,\n\t\t.gpio_direction\t= 0x4d,\n\t\t.gpio_set\t= 0x4e,\n\t\t.gpio_clear\t= 0x4f,\n\t\t.gpio_status\t= 0x50,\n\t\t.tx_fifo_reset\t= 0x60,\n\t\t.rx_fifo_reset\t= 0x63,\n\t\t.custom_driver\t= 0x81,\n\t},\n};\n\nstruct xr_data {\n\tconst struct xr_type *type;\n\tu8 channel;\t\t\t \n\tstruct serial_rs485 rs485;\n};\n\nstatic int xr_set_reg(struct usb_serial_port *port, u8 channel, u16 reg, u16 val)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tconst struct xr_type *type = data->type;\n\tstruct usb_serial *serial = port->serial;\n\tint ret;\n\n\tret = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\ttype->set_reg,\n\t\t\tUSB_DIR_OUT | USB_TYPE_VENDOR | type->reg_recipient,\n\t\t\tval, (channel << 8) | reg, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&port->dev, \"Failed to set reg 0x%02x: %d\\n\", reg, ret);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xr_get_reg(struct usb_serial_port *port, u8 channel, u16 reg, u16 *val)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tconst struct xr_type *type = data->type;\n\tstruct usb_serial *serial = port->serial;\n\tu8 *dmabuf;\n\tint ret, len;\n\n\tif (type->reg_width == 8)\n\t\tlen = 1;\n\telse\n\t\tlen = 2;\n\n\tdmabuf = kmalloc(len, GFP_KERNEL);\n\tif (!dmabuf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\ttype->get_reg,\n\t\t\tUSB_DIR_IN | USB_TYPE_VENDOR | type->reg_recipient,\n\t\t\t0, (channel << 8) | reg, dmabuf, len,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\tif (ret == len) {\n\t\tif (len == 2)\n\t\t\t*val = le16_to_cpup((__le16 *)dmabuf);\n\t\telse\n\t\t\t*val = *dmabuf;\n\t\tret = 0;\n\t} else {\n\t\tdev_err(&port->dev, \"Failed to get reg 0x%02x: %d\\n\", reg, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\tkfree(dmabuf);\n\n\treturn ret;\n}\n\nstatic int xr_set_reg_uart(struct usb_serial_port *port, u16 reg, u16 val)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\treturn xr_set_reg(port, data->channel, reg, val);\n}\n\nstatic int xr_get_reg_uart(struct usb_serial_port *port, u16 reg, u16 *val)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\treturn xr_get_reg(port, data->channel, reg, val);\n}\n\nstatic int xr_set_reg_um(struct usb_serial_port *port, u8 reg_base, u8 val)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tu8 reg;\n\n\treg = reg_base + data->channel;\n\n\treturn xr_set_reg(port, XR21V141X_UM_REG_BLOCK, reg, val);\n}\n\nstatic int __xr_uart_enable(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\treturn xr_set_reg_uart(port, data->type->uart_enable,\n\t\t\tXR_UART_ENABLE_TX | XR_UART_ENABLE_RX);\n}\n\nstatic int __xr_uart_disable(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\treturn xr_set_reg_uart(port, data->type->uart_enable, 0);\n}\n\n \nstatic int xr21v141x_uart_enable(struct usb_serial_port *port)\n{\n\tint ret;\n\n\tret = xr_set_reg_um(port, XR21V141X_UM_FIFO_ENABLE_REG,\n\t\t\t    XR21V141X_UM_ENABLE_TX_FIFO);\n\tif (ret)\n\t\treturn ret;\n\n\tret = __xr_uart_enable(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_um(port, XR21V141X_UM_FIFO_ENABLE_REG,\n\t\t\t    XR21V141X_UM_ENABLE_TX_FIFO | XR21V141X_UM_ENABLE_RX_FIFO);\n\tif (ret)\n\t\t__xr_uart_disable(port);\n\n\treturn ret;\n}\n\nstatic int xr21v141x_uart_disable(struct usb_serial_port *port)\n{\n\tint ret;\n\n\tret = __xr_uart_disable(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_um(port, XR21V141X_UM_FIFO_ENABLE_REG, 0);\n\n\treturn ret;\n}\n\nstatic int xr_uart_enable(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\tif (data->type->enable)\n\t\treturn data->type->enable(port);\n\n\treturn __xr_uart_enable(port);\n}\n\nstatic int xr_uart_disable(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\tif (data->type->disable)\n\t\treturn data->type->disable(port);\n\n\treturn __xr_uart_disable(port);\n}\n\nstatic int xr21v141x_fifo_reset(struct usb_serial_port *port)\n{\n\tint ret;\n\n\tret = xr_set_reg_um(port, XR21V141X_UM_TX_FIFO_RESET, XR_FIFO_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_um(port, XR21V141X_UM_RX_FIFO_RESET, XR_FIFO_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xr_fifo_reset(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tint ret;\n\n\tif (data->type->fifo_reset)\n\t\treturn data->type->fifo_reset(port);\n\n\tret = xr_set_reg_uart(port, data->type->tx_fifo_reset, XR_FIFO_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, data->type->rx_fifo_reset, XR_FIFO_RESET);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xr_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tu16 status;\n\tint ret;\n\n\tret = xr_get_reg_uart(port, data->type->gpio_status, &status);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tret = ((status & XR_GPIO_DTR) ? 0 : TIOCM_DTR) |\n\t      ((status & XR_GPIO_RTS) ? 0 : TIOCM_RTS) |\n\t      ((status & XR_GPIO_CTS) ? 0 : TIOCM_CTS) |\n\t      ((status & XR_GPIO_DSR) ? 0 : TIOCM_DSR) |\n\t      ((status & XR_GPIO_RI) ? 0 : TIOCM_RI) |\n\t      ((status & XR_GPIO_CD) ? 0 : TIOCM_CD);\n\n\treturn ret;\n}\n\nstatic int xr_tiocmset_port(struct usb_serial_port *port,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tconst struct xr_type *type = data->type;\n\tu16 gpio_set = 0;\n\tu16 gpio_clr = 0;\n\tint ret = 0;\n\n\t \n\tif (set & TIOCM_RTS)\n\t\tgpio_clr |= XR_GPIO_RTS;\n\tif (set & TIOCM_DTR)\n\t\tgpio_clr |= XR_GPIO_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tgpio_set |= XR_GPIO_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tgpio_set |= XR_GPIO_DTR;\n\n\t \n\tif (gpio_clr)\n\t\tret = xr_set_reg_uart(port, type->gpio_clear, gpio_clr);\n\n\tif (gpio_set)\n\t\tret = xr_set_reg_uart(port, type->gpio_set, gpio_set);\n\n\treturn ret;\n}\n\nstatic int xr_tiocmset(struct tty_struct *tty,\n\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn xr_tiocmset_port(port, set, clear);\n}\n\nstatic void xr_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tif (on)\n\t\txr_tiocmset_port(port, TIOCM_DTR | TIOCM_RTS, 0);\n\telse\n\t\txr_tiocmset_port(port, 0, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic int xr_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tconst struct xr_type *type = data->type;\n\tu16 state;\n\n\tif (break_state == 0)\n\t\tstate = 0;\n\telse\n\t\tstate = GENMASK(type->reg_width - 1, 0);\n\n\tdev_dbg(&port->dev, \"Turning break %s\\n\", state == 0 ? \"off\" : \"on\");\n\n\treturn xr_set_reg_uart(port, type->tx_break, state);\n}\n\n \nstatic const struct xr_txrx_clk_mask xr21v141x_txrx_clk_masks[] = {\n\t{ 0x000, 0x000, 0x000 },\n\t{ 0x000, 0x000, 0x000 },\n\t{ 0x100, 0x000, 0x100 },\n\t{ 0x020, 0x400, 0x020 },\n\t{ 0x010, 0x100, 0x010 },\n\t{ 0x208, 0x040, 0x208 },\n\t{ 0x104, 0x820, 0x108 },\n\t{ 0x844, 0x210, 0x884 },\n\t{ 0x444, 0x110, 0x444 },\n\t{ 0x122, 0x888, 0x224 },\n\t{ 0x912, 0x448, 0x924 },\n\t{ 0x492, 0x248, 0x492 },\n\t{ 0x252, 0x928, 0x292 },\n\t{ 0x94a, 0x4a4, 0xa52 },\n\t{ 0x52a, 0xaa4, 0x54a },\n\t{ 0xaaa, 0x954, 0x4aa },\n\t{ 0xaaa, 0x554, 0xaaa },\n\t{ 0x555, 0xad4, 0x5aa },\n\t{ 0xb55, 0xab4, 0x55a },\n\t{ 0x6b5, 0x5ac, 0xb56 },\n\t{ 0x5b5, 0xd6c, 0x6d6 },\n\t{ 0xb6d, 0xb6a, 0xdb6 },\n\t{ 0x76d, 0x6da, 0xbb6 },\n\t{ 0xedd, 0xdda, 0x76e },\n\t{ 0xddd, 0xbba, 0xeee },\n\t{ 0x7bb, 0xf7a, 0xdde },\n\t{ 0xf7b, 0xef6, 0x7de },\n\t{ 0xdf7, 0xbf6, 0xf7e },\n\t{ 0x7f7, 0xfee, 0xefe },\n\t{ 0xfdf, 0xfbe, 0x7fe },\n\t{ 0xf7f, 0xefe, 0xffe },\n\t{ 0xfff, 0xffe, 0xffd },\n};\n\nstatic int xr21v141x_set_baudrate(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tu32 divisor, baud, idx;\n\tu16 tx_mask, rx_mask;\n\tint ret;\n\n\tbaud = tty->termios.c_ospeed;\n\tif (!baud)\n\t\treturn 0;\n\n\tbaud = clamp(baud, XR21V141X_MIN_SPEED, XR21V141X_MAX_SPEED);\n\tdivisor = XR_INT_OSC_HZ / baud;\n\tidx = ((32 * XR_INT_OSC_HZ) / baud) & 0x1f;\n\ttx_mask = xr21v141x_txrx_clk_masks[idx].tx;\n\n\tif (divisor & 0x01)\n\t\trx_mask = xr21v141x_txrx_clk_masks[idx].rx1;\n\telse\n\t\trx_mask = xr21v141x_txrx_clk_masks[idx].rx0;\n\n\tdev_dbg(&port->dev, \"Setting baud rate: %u\\n\", baud);\n\t \n\tret = xr_set_reg_uart(port, XR21V141X_CLOCK_DIVISOR_0,\n\t\t\t      divisor & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_CLOCK_DIVISOR_1,\n\t\t\t      (divisor >>  8) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_CLOCK_DIVISOR_2,\n\t\t\t      (divisor >> 16) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_TX_CLOCK_MASK_0,\n\t\t\t      tx_mask & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_TX_CLOCK_MASK_1,\n\t\t\t      (tx_mask >>  8) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_RX_CLOCK_MASK_0,\n\t\t\t      rx_mask & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, XR21V141X_RX_CLOCK_MASK_1,\n\t\t\t      (rx_mask >>  8) & 0xff);\n\tif (ret)\n\t\treturn ret;\n\n\ttty_encode_baud_rate(tty, baud, baud);\n\n\treturn 0;\n}\n\nstatic void xr_set_flow_mode(struct tty_struct *tty,\n\t\t             struct usb_serial_port *port,\n\t\t             const struct ktermios *old_termios)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tconst struct xr_type *type = data->type;\n\tu16 flow, gpio_mode;\n\tbool rs485_enabled;\n\tint ret;\n\n\tret = xr_get_reg_uart(port, type->gpio_mode, &gpio_mode);\n\tif (ret)\n\t\treturn;\n\n\t \n\txr_uart_disable(port);\n\n\t \n\tgpio_mode &= ~XR_GPIO_MODE_SEL_MASK;\n\n\trs485_enabled = !!(data->rs485.flags & SER_RS485_ENABLED);\n\tif (rs485_enabled) {\n\t\tdev_dbg(&port->dev, \"Enabling RS-485\\n\");\n\t\tgpio_mode |= XR_GPIO_MODE_SEL_RS485;\n\t\tif (data->rs485.flags & SER_RS485_RTS_ON_SEND)\n\t\t\tgpio_mode &= ~XR_GPIO_MODE_RS485_TX_H;\n\t\telse\n\t\t\tgpio_mode |= XR_GPIO_MODE_RS485_TX_H;\n\t}\n\n\tif (C_CRTSCTS(tty) && C_BAUD(tty) != B0 && !rs485_enabled) {\n\t\tdev_dbg(&port->dev, \"Enabling hardware flow ctrl\\n\");\n\t\tgpio_mode |= XR_GPIO_MODE_SEL_RTS_CTS;\n\t\tflow = XR_UART_FLOW_MODE_HW;\n\t} else if (I_IXON(tty)) {\n\t\tu8 start_char = START_CHAR(tty);\n\t\tu8 stop_char = STOP_CHAR(tty);\n\n\t\tdev_dbg(&port->dev, \"Enabling sw flow ctrl\\n\");\n\t\tflow = XR_UART_FLOW_MODE_SW;\n\n\t\txr_set_reg_uart(port, type->xon_char, start_char);\n\t\txr_set_reg_uart(port, type->xoff_char, stop_char);\n\t} else {\n\t\tdev_dbg(&port->dev, \"Disabling flow ctrl\\n\");\n\t\tflow = XR_UART_FLOW_MODE_NONE;\n\t}\n\n\txr_set_reg_uart(port, type->flow_control, flow);\n\txr_set_reg_uart(port, type->gpio_mode, gpio_mode);\n\n\txr_uart_enable(port);\n\n\tif (C_BAUD(tty) == B0)\n\t\txr_dtr_rts(port, 0);\n\telse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\txr_dtr_rts(port, 1);\n}\n\nstatic void xr21v141x_set_line_settings(struct tty_struct *tty,\n\t\t\t\t        struct usb_serial_port *port,\n\t\t\t\t        const struct ktermios *old_termios)\n{\n\tstruct ktermios *termios = &tty->termios;\n\tu8 bits = 0;\n\tint ret;\n\n\tif (!old_termios || (tty->termios.c_ospeed != old_termios->c_ospeed))\n\t\txr21v141x_set_baudrate(tty, port);\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\tcase CS6:\n\t\t \n\t\ttermios->c_cflag &= ~CSIZE;\n\t\tif (old_termios)\n\t\t\ttermios->c_cflag |= old_termios->c_cflag & CSIZE;\n\t\telse\n\t\t\ttermios->c_cflag |= CS8;\n\n\t\tif (C_CSIZE(tty) == CS7)\n\t\t\tbits |= XR_UART_DATA_7;\n\t\telse\n\t\t\tbits |= XR_UART_DATA_8;\n\t\tbreak;\n\tcase CS7:\n\t\tbits |= XR_UART_DATA_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tbits |= XR_UART_DATA_8;\n\t\tbreak;\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\tif (C_CMSPAR(tty)) {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tbits |= XR_UART_PARITY_MARK;\n\t\t\telse\n\t\t\t\tbits |= XR_UART_PARITY_SPACE;\n\t\t} else {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tbits |= XR_UART_PARITY_ODD;\n\t\t\telse\n\t\t\t\tbits |= XR_UART_PARITY_EVEN;\n\t\t}\n\t}\n\n\tif (C_CSTOPB(tty))\n\t\tbits |= XR_UART_STOP_2;\n\telse\n\t\tbits |= XR_UART_STOP_1;\n\n\tret = xr_set_reg_uart(port, XR21V141X_REG_FORMAT, bits);\n\tif (ret)\n\t\treturn;\n}\n\nstatic void xr_cdc_set_line_coding(struct tty_struct *tty,\n\t\t\t\t   struct usb_serial_port *port,\n\t\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tstruct usb_host_interface *alt = port->serial->interface->cur_altsetting;\n\tstruct usb_device *udev = port->serial->dev;\n\tstruct usb_cdc_line_coding *lc;\n\tint ret;\n\n\tlc = kzalloc(sizeof(*lc), GFP_KERNEL);\n\tif (!lc)\n\t\treturn;\n\n\tif (tty->termios.c_ospeed)\n\t\tlc->dwDTERate = cpu_to_le32(tty->termios.c_ospeed);\n\telse\n\t\tlc->dwDTERate = cpu_to_le32(9600);\n\n\tif (C_CSTOPB(tty))\n\t\tlc->bCharFormat = USB_CDC_2_STOP_BITS;\n\telse\n\t\tlc->bCharFormat = USB_CDC_1_STOP_BITS;\n\n\tif (C_PARENB(tty)) {\n\t\tif (C_CMSPAR(tty)) {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tlc->bParityType = USB_CDC_MARK_PARITY;\n\t\t\telse\n\t\t\t\tlc->bParityType = USB_CDC_SPACE_PARITY;\n\t\t} else {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tlc->bParityType = USB_CDC_ODD_PARITY;\n\t\t\telse\n\t\t\t\tlc->bParityType = USB_CDC_EVEN_PARITY;\n\t\t}\n\t} else {\n\t\tlc->bParityType = USB_CDC_NO_PARITY;\n\t}\n\n\tif (!data->type->have_5_6_bit_mode &&\n\t\t\t(C_CSIZE(tty) == CS5 || C_CSIZE(tty) == CS6)) {\n\t\ttty->termios.c_cflag &= ~CSIZE;\n\t\tif (old_termios)\n\t\t\ttty->termios.c_cflag |= old_termios->c_cflag & CSIZE;\n\t\telse\n\t\t\ttty->termios.c_cflag |= CS8;\n\t}\n\n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\t\tlc->bDataBits = 5;\n\t\tbreak;\n\tcase CS6:\n\t\tlc->bDataBits = 6;\n\t\tbreak;\n\tcase CS7:\n\t\tlc->bDataBits = 7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tlc->bDataBits = 8;\n\t\tbreak;\n\t}\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_CDC_REQ_SET_LINE_CODING,\n\t\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, alt->desc.bInterfaceNumber,\n\t\t\tlc, sizeof(*lc), USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(&port->dev, \"Failed to set line coding: %d\\n\", ret);\n\n\tkfree(lc);\n}\n\nstatic void xr_sanitize_serial_rs485(struct serial_rs485 *rs485)\n{\n\tif (!(rs485->flags & SER_RS485_ENABLED)) {\n\t\tmemset(rs485, 0, sizeof(*rs485));\n\t\treturn;\n\t}\n\n\t \n\tif (rs485->flags & SER_RS485_RTS_ON_SEND)\n\t\trs485->flags &= ~SER_RS485_RTS_AFTER_SEND;\n\telse\n\t\trs485->flags |= SER_RS485_RTS_AFTER_SEND;\n\n\t \n\trs485->flags &= SER_RS485_ENABLED | SER_RS485_RTS_ON_SEND |\n\t\t\tSER_RS485_RTS_AFTER_SEND;\n\trs485->delay_rts_before_send = 0;\n\trs485->delay_rts_after_send = 0;\n\tmemset(rs485->padding, 0, sizeof(rs485->padding));\n}\n\nstatic int xr_get_rs485_config(struct tty_struct *tty,\n\t\t\t       struct serial_rs485 __user *argp)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\tdown_read(&tty->termios_rwsem);\n\tif (copy_to_user(argp, &data->rs485, sizeof(data->rs485))) {\n\t\tup_read(&tty->termios_rwsem);\n\t\treturn -EFAULT;\n\t}\n\tup_read(&tty->termios_rwsem);\n\n\treturn 0;\n}\n\nstatic int xr_set_rs485_config(struct tty_struct *tty,\n\t\t\t       struct serial_rs485 __user *argp)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\tstruct serial_rs485 rs485;\n\n\tif (copy_from_user(&rs485, argp, sizeof(rs485)))\n\t\treturn -EFAULT;\n\txr_sanitize_serial_rs485(&rs485);\n\n\tdown_write(&tty->termios_rwsem);\n\tdata->rs485 = rs485;\n\txr_set_flow_mode(tty, port, NULL);\n\tup_write(&tty->termios_rwsem);\n\n\tif (copy_to_user(argp, &rs485, sizeof(rs485)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int xr_ioctl(struct tty_struct *tty, unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCGRS485:\n\t\treturn xr_get_rs485_config(tty, argp);\n\tcase TIOCSRS485:\n\t\treturn xr_set_rs485_config(tty, argp);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic void xr_set_termios(struct tty_struct *tty,\n\t\t\t   struct usb_serial_port *port,\n\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\t \n\tif (data->type->set_line_settings)\n\t\tdata->type->set_line_settings(tty, port, old_termios);\n\telse\n\t\txr_cdc_set_line_coding(tty, port, old_termios);\n\n\txr_set_flow_mode(tty, port, old_termios);\n}\n\nstatic int xr_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint ret;\n\n\tret = xr_fifo_reset(port);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_uart_enable(port);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"Failed to enable UART\\n\");\n\t\treturn ret;\n\t}\n\n\t \n\tif (tty)\n\t\txr_set_termios(tty, port, NULL);\n\n\tret = usb_serial_generic_open(tty, port);\n\tif (ret) {\n\t\txr_uart_disable(port);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic void xr_close(struct usb_serial_port *port)\n{\n\tusb_serial_generic_close(port);\n\n\txr_uart_disable(port);\n}\n\nstatic int xr_probe(struct usb_serial *serial, const struct usb_device_id *id)\n{\n\tstruct usb_interface *control = serial->interface;\n\tstruct usb_host_interface *alt = control->cur_altsetting;\n\tstruct usb_cdc_parsed_header hdrs;\n\tstruct usb_cdc_union_desc *desc;\n\tstruct usb_interface *data;\n\tint ret;\n\n\tret = cdc_parse_cdc_header(&hdrs, control, alt->extra, alt->extralen);\n\tif (ret < 0)\n\t\treturn -ENODEV;\n\n\tdesc = hdrs.usb_cdc_union_desc;\n\tif (!desc)\n\t\treturn -ENODEV;\n\n\tdata = usb_ifnum_to_if(serial->dev, desc->bSlaveInterface0);\n\tif (!data)\n\t\treturn -ENODEV;\n\n\tret = usb_serial_claim_interface(serial, data);\n\tif (ret)\n\t\treturn ret;\n\n\tusb_set_serial_data(serial, (void *)id->driver_info);\n\n\treturn 0;\n}\n\nstatic int xr_gpio_init(struct usb_serial_port *port, const struct xr_type *type)\n{\n\tu16 mask, mode;\n\tint ret;\n\n\t \n\tmode = 0;\n\tif (type->have_xmit_toggle)\n\t\tmode |= XR_GPIO_MODE_RX_TOGGLE | XR_GPIO_MODE_TX_TOGGLE;\n\n\tret = xr_set_reg_uart(port, type->gpio_mode, mode);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tmask = XR_GPIO_DTR | XR_GPIO_RTS;\n\tret = xr_set_reg_uart(port, type->gpio_direction, mask);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xr_set_reg_uart(port, type->gpio_set, mask);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic int xr_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_interface_descriptor *desc;\n\tconst struct xr_type *type;\n\tstruct xr_data *data;\n\tenum xr_type_id type_id;\n\tint ret;\n\n\ttype_id = (int)(unsigned long)usb_get_serial_data(port->serial);\n\ttype = &xr_types[type_id];\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->type = type;\n\n\tdesc = &port->serial->interface->cur_altsetting->desc;\n\tif (type_id == XR21V141X)\n\t\tdata->channel = desc->bInterfaceNumber / 2;\n\telse\n\t\tdata->channel = desc->bInterfaceNumber;\n\n\tusb_set_serial_port_data(port, data);\n\n\tif (type->custom_driver) {\n\t\tret = xr_set_reg_uart(port, type->custom_driver,\n\t\t\t\tXR_CUSTOM_DRIVER_ACTIVE);\n\t\tif (ret)\n\t\t\tgoto err_free;\n\t}\n\n\tret = xr_gpio_init(port, type);\n\tif (ret)\n\t\tgoto err_free;\n\n\treturn 0;\n\nerr_free:\n\tkfree(data);\n\n\treturn ret;\n}\n\nstatic void xr_port_remove(struct usb_serial_port *port)\n{\n\tstruct xr_data *data = usb_get_serial_port_data(port);\n\n\tkfree(data);\n}\n\n#define XR_DEVICE(vid, pid, type)\t\t\t\t\t\\\n\tUSB_DEVICE_INTERFACE_CLASS((vid), (pid), USB_CLASS_COMM),\t\\\n\t.driver_info = (type)\n\nstatic const struct usb_device_id id_table[] = {\n\t{ XR_DEVICE(0x04e2, 0x1400, XR2280X) },\n\t{ XR_DEVICE(0x04e2, 0x1401, XR2280X) },\n\t{ XR_DEVICE(0x04e2, 0x1402, XR2280X) },\n\t{ XR_DEVICE(0x04e2, 0x1403, XR2280X) },\n\t{ XR_DEVICE(0x04e2, 0x1410, XR21V141X) },\n\t{ XR_DEVICE(0x04e2, 0x1411, XR21B1411) },\n\t{ XR_DEVICE(0x04e2, 0x1412, XR21V141X) },\n\t{ XR_DEVICE(0x04e2, 0x1414, XR21V141X) },\n\t{ XR_DEVICE(0x04e2, 0x1420, XR21B142X) },\n\t{ XR_DEVICE(0x04e2, 0x1422, XR21B142X) },\n\t{ XR_DEVICE(0x04e2, 0x1424, XR21B142X) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver xr_device = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name =\t\"xr_serial\",\n\t},\n\t.id_table\t\t= id_table,\n\t.num_ports\t\t= 1,\n\t.probe\t\t\t= xr_probe,\n\t.port_probe\t\t= xr_port_probe,\n\t.port_remove\t\t= xr_port_remove,\n\t.open\t\t\t= xr_open,\n\t.close\t\t\t= xr_close,\n\t.break_ctl\t\t= xr_break_ctl,\n\t.set_termios\t\t= xr_set_termios,\n\t.tiocmget\t\t= xr_tiocmget,\n\t.tiocmset\t\t= xr_tiocmset,\n\t.ioctl\t\t\t= xr_ioctl,\n\t.dtr_rts\t\t= xr_dtr_rts\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&xr_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(\"Manivannan Sadhasivam <mani@kernel.org>\");\nMODULE_DESCRIPTION(\"MaxLinear/Exar USB to Serial driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}