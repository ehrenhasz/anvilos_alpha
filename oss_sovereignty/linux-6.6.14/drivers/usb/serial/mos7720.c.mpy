{
  "module_name": "mos7720.c",
  "hash_id": "16e09121c1acb72997175804ee769d53c4527b6db70c36daa119c4478ef7ead5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/mos7720.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n#include <linux/parport.h>\n\n#define DRIVER_AUTHOR \"Aspire Communications pvt Ltd.\"\n#define DRIVER_DESC \"Moschip USB Serial Driver\"\n\n \n#define MOS_WDR_TIMEOUT\t5000\n\n#define MOS_MAX_PORT\t0x02\n#define MOS_WRITE\t0x0E\n#define MOS_READ\t0x0D\n\n \n#define SERIAL_IIR_RLS\t0x06\n#define SERIAL_IIR_RDA\t0x04\n#define SERIAL_IIR_CTI\t0x0c\n#define SERIAL_IIR_THR\t0x02\n#define SERIAL_IIR_MS\t0x00\n\n#define NUM_URBS\t\t\t16\t \n#define URB_TRANSFER_BUFFER_SIZE\t32\t \n\n \nstruct moschip_port {\n\t__u8\tshadowLCR;\t\t \n\t__u8\tshadowMCR;\t\t \n\t__u8\tshadowMSR;\t\t \n\tchar\t\t\topen;\n\tstruct usb_serial_port\t*port;\t \n\tstruct urb\t\t*write_urb_pool[NUM_URBS];\n};\n\n#define USB_VENDOR_ID_MOSCHIP\t\t0x9710\n#define MOSCHIP_DEVICE_ID_7720\t\t0x7720\n#define MOSCHIP_DEVICE_ID_7715\t\t0x7715\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7720) },\n\t{ USB_DEVICE(USB_VENDOR_ID_MOSCHIP, MOSCHIP_DEVICE_ID_7715) },\n\t{ }  \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\n\n \n#define DCR_INIT_VAL       0x0c\t \n#define ECR_INIT_VAL       0x00\t \n\nenum mos7715_pp_modes {\n\tSPP = 0<<5,\n\tPS2 = 1<<5,       \n\tPPF = 2<<5,\t  \n};\n\nstruct mos7715_parport {\n\tstruct parport          *pp;\t        \n\tstruct kref             ref_count;      \n\tbool                    msg_pending;    \n\tstruct completion       syncmsg_compl;  \n\tstruct work_struct      work;           \n\tstruct usb_serial       *serial;        \n\t__u8\t                shadowECR;      \n\t__u8\t                shadowDCR;\n\tatomic_t                shadowDSR;      \n};\n\n \nstatic DEFINE_SPINLOCK(release_lock);\n\n#endif\t \n\nstatic const unsigned int dummy;  \n\nenum mos_regs {\n\tMOS7720_THR,\t\t   \n\tMOS7720_RHR,\n\tMOS7720_IER,\n\tMOS7720_FCR,\n\tMOS7720_ISR,\n\tMOS7720_LCR,\n\tMOS7720_MCR,\n\tMOS7720_LSR,\n\tMOS7720_MSR,\n\tMOS7720_SPR,\n\tMOS7720_DLL,\n\tMOS7720_DLM,\n\tMOS7720_DPR,\t\t   \n\tMOS7720_DSR,\n\tMOS7720_DCR,\n\tMOS7720_ECR,\n\tMOS7720_SP1_REG,\t   \n\tMOS7720_SP2_REG,\t   \n\tMOS7720_PP_REG,\n\tMOS7720_SP_CONTROL_REG,\n};\n\n \nstatic inline __u16 get_reg_index(enum mos_regs reg)\n{\n\tstatic const __u16 mos7715_index_lookup_table[] = {\n\t\t0x00,\t\t \n\t\t0x00,\t\t \n\t\t0x01,\t\t \n\t\t0x02,\t\t \n\t\t0x02,\t\t \n\t\t0x03,\t\t \n\t\t0x04,\t\t \n\t\t0x05,\t\t \n\t\t0x06,\t\t \n\t\t0x07,\t\t \n\t\t0x00,\t\t \n\t\t0x01,\t\t \n\t\t0x00,\t\t \n\t\t0x01,\t\t \n\t\t0x02,\t\t \n\t\t0x0a,\t\t \n\t\t0x01,\t\t \n\t\t0x02,\t\t \n\t\t0x04,\t\t \n\t\t0x08,\t\t \n\t};\n\treturn mos7715_index_lookup_table[reg];\n}\n\n \nstatic inline __u16 get_reg_value(enum mos_regs reg,\n\t\t\t\t  unsigned int serial_portnum)\n{\n\tif (reg >= MOS7720_SP1_REG)\t \n\t\treturn 0x0000;\n\n\telse if (reg >= MOS7720_DPR)\t \n\t\treturn 0x0100;\n\n\telse\t\t\t       \n\t\treturn (serial_portnum + 2) << 8;\n}\n\n \nstatic int write_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\n\t\t\t enum mos_regs reg, __u8 data)\n{\n\tstruct usb_device *usbdev = serial->dev;\n\tunsigned int pipe = usb_sndctrlpipe(usbdev, 0);\n\t__u8 request = (__u8)0x0e;\n\t__u8 requesttype = (__u8)0x40;\n\t__u16 index = get_reg_index(reg);\n\t__u16 value = get_reg_value(reg, serial_portnum) + data;\n\tint status = usb_control_msg(usbdev, pipe, request, requesttype, value,\n\t\t\t\t     index, NULL, 0, MOS_WDR_TIMEOUT);\n\tif (status < 0)\n\t\tdev_err(&usbdev->dev,\n\t\t\t\"mos7720: usb_control_msg() failed: %d\\n\", status);\n\treturn status;\n}\n\n \nstatic int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,\n\t\t\tenum mos_regs reg, __u8 *data)\n{\n\tstruct usb_device *usbdev = serial->dev;\n\tunsigned int pipe = usb_rcvctrlpipe(usbdev, 0);\n\t__u8 request = (__u8)0x0d;\n\t__u8 requesttype = (__u8)0xc0;\n\t__u16 index = get_reg_index(reg);\n\t__u16 value = get_reg_value(reg, serial_portnum);\n\tu8 *buf;\n\tint status;\n\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (!buf) {\n\t\t*data = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\tstatus = usb_control_msg(usbdev, pipe, request, requesttype, value,\n\t\t\t\t     index, buf, 1, MOS_WDR_TIMEOUT);\n\tif (status == 1) {\n\t\t*data = *buf;\n\t} else {\n\t\tdev_err(&usbdev->dev,\n\t\t\t\"mos7720: usb_control_msg() failed: %d\\n\", status);\n\t\tif (status >= 0)\n\t\t\tstatus = -EIO;\n\t\t*data = 0;\n\t}\n\n\tkfree(buf);\n\n\treturn status;\n}\n\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\n\nstatic inline int mos7715_change_mode(struct mos7715_parport *mos_parport,\n\t\t\t\t      enum mos7715_pp_modes mode)\n{\n\tmos_parport->shadowECR = mode;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_ECR,\n\t\t      mos_parport->shadowECR);\n\treturn 0;\n}\n\nstatic void destroy_mos_parport(struct kref *kref)\n{\n\tstruct mos7715_parport *mos_parport =\n\t\tcontainer_of(kref, struct mos7715_parport, ref_count);\n\n\tkfree(mos_parport);\n}\n\n \nstatic int parport_prologue(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport;\n\n\tspin_lock(&release_lock);\n\tmos_parport = pp->private_data;\n\tif (unlikely(mos_parport == NULL)) {\n\t\t \n\t\tspin_unlock(&release_lock);\n\t\treturn -1;\n\t}\n\tmos_parport->msg_pending = true;    \n\treinit_completion(&mos_parport->syncmsg_compl);\n\tspin_unlock(&release_lock);\n\n\t \n\tif (work_pending(&mos_parport->work))\n\t\tflush_work(&mos_parport->work);\n\n\tmutex_lock(&mos_parport->serial->disc_mutex);\n\tif (mos_parport->serial->disconnected) {\n\t\t \n\t\tmutex_unlock(&mos_parport->serial->disc_mutex);\n\t\tmos_parport->msg_pending = false;\n\t\tcomplete(&mos_parport->syncmsg_compl);\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n \nstatic inline void parport_epilogue(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\tmutex_unlock(&mos_parport->serial->disc_mutex);\n\tmos_parport->msg_pending = false;\n\tcomplete(&mos_parport->syncmsg_compl);\n}\n\nstatic void deferred_restore_writes(struct work_struct *work)\n{\n\tstruct mos7715_parport *mos_parport;\n\n\tmos_parport = container_of(work, struct mos7715_parport, work);\n\n\tmutex_lock(&mos_parport->serial->disc_mutex);\n\n\t \n\tif (mos_parport->serial->disconnected)\n\t\tgoto done;\n\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\n\t\t      mos_parport->shadowDCR);\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_ECR,\n\t\t      mos_parport->shadowECR);\ndone:\n\tmutex_unlock(&mos_parport->serial->disc_mutex);\n}\n\nstatic void parport_mos7715_write_data(struct parport *pp, unsigned char d)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn;\n\tmos7715_change_mode(mos_parport, SPP);\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DPR, (__u8)d);\n\tparport_epilogue(pp);\n}\n\nstatic unsigned char parport_mos7715_read_data(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\tunsigned char d;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn 0;\n\tread_mos_reg(mos_parport->serial, dummy, MOS7720_DPR, &d);\n\tparport_epilogue(pp);\n\treturn d;\n}\n\nstatic void parport_mos7715_write_control(struct parport *pp, unsigned char d)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\t__u8 data;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn;\n\tdata = ((__u8)d & 0x0f) | (mos_parport->shadowDCR & 0xf0);\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR, data);\n\tmos_parport->shadowDCR = data;\n\tparport_epilogue(pp);\n}\n\nstatic unsigned char parport_mos7715_read_control(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport;\n\t__u8 dcr;\n\n\tspin_lock(&release_lock);\n\tmos_parport = pp->private_data;\n\tif (unlikely(mos_parport == NULL)) {\n\t\tspin_unlock(&release_lock);\n\t\treturn 0;\n\t}\n\tdcr = mos_parport->shadowDCR & 0x0f;\n\tspin_unlock(&release_lock);\n\treturn dcr;\n}\n\nstatic unsigned char parport_mos7715_frob_control(struct parport *pp,\n\t\t\t\t\t\t  unsigned char mask,\n\t\t\t\t\t\t  unsigned char val)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\t__u8 dcr;\n\n\tmask &= 0x0f;\n\tval &= 0x0f;\n\tif (parport_prologue(pp) < 0)\n\t\treturn 0;\n\tmos_parport->shadowDCR = (mos_parport->shadowDCR & (~mask)) ^ val;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\n\t\t      mos_parport->shadowDCR);\n\tdcr = mos_parport->shadowDCR & 0x0f;\n\tparport_epilogue(pp);\n\treturn dcr;\n}\n\nstatic unsigned char parport_mos7715_read_status(struct parport *pp)\n{\n\tunsigned char status;\n\tstruct mos7715_parport *mos_parport;\n\n\tspin_lock(&release_lock);\n\tmos_parport = pp->private_data;\n\tif (unlikely(mos_parport == NULL)) {\t \n\t\tspin_unlock(&release_lock);\n\t\treturn 0;\n\t}\n\tstatus = atomic_read(&mos_parport->shadowDSR) & 0xf8;\n\tspin_unlock(&release_lock);\n\treturn status;\n}\n\nstatic void parport_mos7715_enable_irq(struct parport *pp)\n{\n}\n\nstatic void parport_mos7715_disable_irq(struct parport *pp)\n{\n}\n\nstatic void parport_mos7715_data_forward(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn;\n\tmos7715_change_mode(mos_parport, PS2);\n\tmos_parport->shadowDCR &=  ~0x20;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\n\t\t      mos_parport->shadowDCR);\n\tparport_epilogue(pp);\n}\n\nstatic void parport_mos7715_data_reverse(struct parport *pp)\n{\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn;\n\tmos7715_change_mode(mos_parport, PS2);\n\tmos_parport->shadowDCR |= 0x20;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\n\t\t      mos_parport->shadowDCR);\n\tparport_epilogue(pp);\n}\n\nstatic void parport_mos7715_init_state(struct pardevice *dev,\n\t\t\t\t       struct parport_state *s)\n{\n\ts->u.pc.ctr = DCR_INIT_VAL;\n\ts->u.pc.ecr = ECR_INIT_VAL;\n}\n\n \nstatic void parport_mos7715_save_state(struct parport *pp,\n\t\t\t\t       struct parport_state *s)\n{\n\tstruct mos7715_parport *mos_parport;\n\n\tspin_lock(&release_lock);\n\tmos_parport = pp->private_data;\n\tif (unlikely(mos_parport == NULL)) {\t \n\t\tspin_unlock(&release_lock);\n\t\treturn;\n\t}\n\ts->u.pc.ctr = mos_parport->shadowDCR;\n\ts->u.pc.ecr = mos_parport->shadowECR;\n\tspin_unlock(&release_lock);\n}\n\n \nstatic void parport_mos7715_restore_state(struct parport *pp,\n\t\t\t\t\t  struct parport_state *s)\n{\n\tstruct mos7715_parport *mos_parport;\n\n\tspin_lock(&release_lock);\n\tmos_parport = pp->private_data;\n\tif (unlikely(mos_parport == NULL)) {\t \n\t\tspin_unlock(&release_lock);\n\t\treturn;\n\t}\n\tmos_parport->shadowDCR = s->u.pc.ctr;\n\tmos_parport->shadowECR = s->u.pc.ecr;\n\n\tschedule_work(&mos_parport->work);\n\tspin_unlock(&release_lock);\n}\n\nstatic size_t parport_mos7715_write_compat(struct parport *pp,\n\t\t\t\t\t   const void *buffer,\n\t\t\t\t\t   size_t len, int flags)\n{\n\tint retval;\n\tstruct mos7715_parport *mos_parport = pp->private_data;\n\tint actual_len;\n\n\tif (parport_prologue(pp) < 0)\n\t\treturn 0;\n\tmos7715_change_mode(mos_parport, PPF);\n\tretval = usb_bulk_msg(mos_parport->serial->dev,\n\t\t\t      usb_sndbulkpipe(mos_parport->serial->dev, 2),\n\t\t\t      (void *)buffer, len, &actual_len,\n\t\t\t      MOS_WDR_TIMEOUT);\n\tparport_epilogue(pp);\n\tif (retval) {\n\t\tdev_err(&mos_parport->serial->dev->dev,\n\t\t\t\"mos7720: usb_bulk_msg() failed: %d\\n\", retval);\n\t\treturn 0;\n\t}\n\treturn actual_len;\n}\n\nstatic struct parport_operations parport_mos7715_ops = {\n\t.owner =\t\tTHIS_MODULE,\n\t.write_data =\t\tparport_mos7715_write_data,\n\t.read_data =\t\tparport_mos7715_read_data,\n\n\t.write_control =\tparport_mos7715_write_control,\n\t.read_control =\t\tparport_mos7715_read_control,\n\t.frob_control =\t\tparport_mos7715_frob_control,\n\n\t.read_status =\t\tparport_mos7715_read_status,\n\n\t.enable_irq =\t\tparport_mos7715_enable_irq,\n\t.disable_irq =\t\tparport_mos7715_disable_irq,\n\n\t.data_forward =\t\tparport_mos7715_data_forward,\n\t.data_reverse =\t\tparport_mos7715_data_reverse,\n\n\t.init_state =\t\tparport_mos7715_init_state,\n\t.save_state =\t\tparport_mos7715_save_state,\n\t.restore_state =\tparport_mos7715_restore_state,\n\n\t.compat_write_data =\tparport_mos7715_write_compat,\n\n\t.nibble_read_data =\tparport_ieee1284_read_nibble,\n\t.byte_read_data =\tparport_ieee1284_read_byte,\n};\n\n \nstatic int mos7715_parport_init(struct usb_serial *serial)\n{\n\tstruct mos7715_parport *mos_parport;\n\n\t \n\tmos_parport = kzalloc(sizeof(struct mos7715_parport), GFP_KERNEL);\n\tif (!mos_parport)\n\t\treturn -ENOMEM;\n\n\tmos_parport->msg_pending = false;\n\tkref_init(&mos_parport->ref_count);\n\tusb_set_serial_data(serial, mos_parport);  \n\tmos_parport->serial = serial;\n\tINIT_WORK(&mos_parport->work, deferred_restore_writes);\n\tinit_completion(&mos_parport->syncmsg_compl);\n\n\t \n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_PP_REG, (__u8)0x80);\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_PP_REG, (__u8)0x00);\n\n\t \n\tmos_parport->shadowDCR = DCR_INIT_VAL;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_DCR,\n\t\t      mos_parport->shadowDCR);\n\tmos_parport->shadowECR = ECR_INIT_VAL;\n\twrite_mos_reg(mos_parport->serial, dummy, MOS7720_ECR,\n\t\t      mos_parport->shadowECR);\n\n\t \n\tmos_parport->pp = parport_register_port(0, PARPORT_IRQ_NONE,\n\t\t\t\t\t\tPARPORT_DMA_NONE,\n\t\t\t\t\t\t&parport_mos7715_ops);\n\tif (mos_parport->pp == NULL) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"Could not register parport\\n\");\n\t\tkref_put(&mos_parport->ref_count, destroy_mos_parport);\n\t\treturn -EIO;\n\t}\n\tmos_parport->pp->private_data = mos_parport;\n\tmos_parport->pp->modes = PARPORT_MODE_COMPAT | PARPORT_MODE_PCSPP;\n\tmos_parport->pp->dev = &serial->interface->dev;\n\tparport_announce_port(mos_parport->pp);\n\n\treturn 0;\n}\n#endif\t \n\n \nstatic void mos7720_interrupt_callback(struct urb *urb)\n{\n\tint result;\n\tint length;\n\tint status = urb->status;\n\tstruct device *dev = &urb->dev->dev;\n\t__u8 *data;\n\t__u8 sp1;\n\t__u8 sp2;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tlength = urb->actual_length;\n\tdata = urb->transfer_buffer;\n\n\t \n\n\t \n\n\tif (unlikely(length != 4)) {\n\t\tdev_dbg(dev, \"Wrong data !!!\\n\");\n\t\treturn;\n\t}\n\n\tsp1 = data[3];\n\tsp2 = data[2];\n\n\tif ((sp1 | sp2) & 0x01) {\n\t\t \n\t\tdev_dbg(dev, \"No Interrupt !!!\\n\");\n\t} else {\n\t\tswitch (sp1 & 0x0f) {\n\t\tcase SERIAL_IIR_RLS:\n\t\t\tdev_dbg(dev, \"Serial Port 1: Receiver status error or address bit detected in 9-bit mode\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_CTI:\n\t\t\tdev_dbg(dev, \"Serial Port 1: Receiver time out\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_MS:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (sp2 & 0x0f) {\n\t\tcase SERIAL_IIR_RLS:\n\t\t\tdev_dbg(dev, \"Serial Port 2: Receiver status error or address bit detected in 9-bit mode\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_CTI:\n\t\t\tdev_dbg(dev, \"Serial Port 2: Receiver time out\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_MS:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(dev, \"%s - Error %d submitting control urb\\n\", __func__, result);\n}\n\n \nstatic void mos7715_interrupt_callback(struct urb *urb)\n{\n\tint result;\n\tint length;\n\tint status = urb->status;\n\tstruct device *dev = &urb->dev->dev;\n\t__u8 *data;\n\t__u8 iir;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -ENODEV:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tlength = urb->actual_length;\n\tdata = urb->transfer_buffer;\n\n\t \n\n\tif (unlikely(length != 4)) {\n\t\tdev_dbg(dev, \"Wrong data !!!\\n\");\n\t\treturn;\n\t}\n\n\tiir = data[0];\n\tif (!(iir & 0x01)) {\t \n\t\tswitch (iir & 0x0f) {\n\t\tcase SERIAL_IIR_RLS:\n\t\t\tdev_dbg(dev, \"Serial Port: Receiver status error or address bit detected in 9-bit mode\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_CTI:\n\t\t\tdev_dbg(dev, \"Serial Port: Receiver time out\\n\");\n\t\t\tbreak;\n\t\tcase SERIAL_IIR_MS:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\n\t{        \n\t\tstruct usb_serial_port *port = urb->context;\n\t\tstruct mos7715_parport *mos_parport = port->serial->private;\n\t\tif (unlikely(mos_parport == NULL))\n\t\t\treturn;\n\t\tatomic_set(&mos_parport->shadowDSR, data[2]);\n\t}\n#endif\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(dev, \"%s - Error %d submitting control urb\\n\", __func__, result);\n}\n\n \nstatic void mos7720_bulk_in_callback(struct urb *urb)\n{\n\tint retval;\n\tunsigned char *data ;\n\tstruct usb_serial_port *port;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero read bulk status received: %d\\n\", status);\n\t\treturn;\n\t}\n\n\tport = urb->context;\n\n\tdev_dbg(&port->dev, \"Entering...%s\\n\", __func__);\n\n\tdata = urb->transfer_buffer;\n\n\tif (urb->actual_length) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\tif (port->read_urb->status != -EINPROGRESS) {\n\t\tretval = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\t\tif (retval)\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, retval = %d\\n\", retval);\n\t}\n}\n\n \nstatic void mos7720_bulk_out_data_callback(struct urb *urb)\n{\n\tstruct moschip_port *mos7720_port;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero write bulk status received:%d\\n\", status);\n\t\treturn;\n\t}\n\n\tmos7720_port = urb->context;\n\tif (!mos7720_port) {\n\t\tdev_dbg(&urb->dev->dev, \"NULL mos7720_port pointer\\n\");\n\t\treturn ;\n\t}\n\n\tif (mos7720_port->open)\n\t\ttty_port_tty_wakeup(&mos7720_port->port->port);\n}\n\nstatic int mos77xx_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tu16 product = le16_to_cpu(serial->dev->descriptor.idProduct);\n\n\tif (product == MOSCHIP_DEVICE_ID_7715) {\n\t\t \n\t\tswap(epds->bulk_in[0], epds->bulk_in[1]);\n\t\tswap(epds->bulk_out[0], epds->bulk_out[1]);\n\n\t\treturn 1;\n\t}\n\n\treturn 2;\n}\n\nstatic int mos7720_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial;\n\tstruct urb *urb;\n\tstruct moschip_port *mos7720_port;\n\tint response;\n\tint port_number;\n\t__u8 data;\n\tint allocated_urbs = 0;\n\tint j;\n\n\tserial = port->serial;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tif (mos7720_port == NULL)\n\t\treturn -ENODEV;\n\n\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\n\t \n\tfor (j = 0; j < NUM_URBS; ++j) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tmos7720_port->write_urb_pool[j] = urb;\n\t\tif (!urb)\n\t\t\tcontinue;\n\n\t\turb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\n\t\t\t\t\t       GFP_KERNEL);\n\t\tif (!urb->transfer_buffer) {\n\t\t\tusb_free_urb(mos7720_port->write_urb_pool[j]);\n\t\t\tmos7720_port->write_urb_pool[j] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tallocated_urbs++;\n\t}\n\n\tif (!allocated_urbs)\n\t\treturn -ENOMEM;\n\n\t  \n\tport_number = port->port_number;\n\tread_mos_reg(serial, port_number, MOS7720_LSR, &data);\n\n\tdev_dbg(&port->dev, \"SS::%p LSR:%x\\n\", mos7720_port, data);\n\n\twrite_mos_reg(serial, dummy, MOS7720_SP1_REG, 0x02);\n\twrite_mos_reg(serial, dummy, MOS7720_SP2_REG, 0x02);\n\n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\n\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\n\tmos7720_port->shadowLCR = 0x03;\n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\tmos7720_port->shadowMCR = 0x0b;\n\twrite_mos_reg(serial, port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\n\twrite_mos_reg(serial, port_number, MOS7720_SP_CONTROL_REG, 0x00);\n\tread_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, &data);\n\tdata = data | (port->port_number + 1);\n\twrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, data);\n\tmos7720_port->shadowLCR = 0x83;\n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\twrite_mos_reg(serial, port_number, MOS7720_THR, 0x0c);\n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\n\tmos7720_port->shadowLCR = 0x03;\n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\n\n\tresponse = usb_submit_urb(port->read_urb, GFP_KERNEL);\n\tif (response)\n\t\tdev_err(&port->dev, \"%s - Error %d submitting read urb\\n\",\n\t\t\t\t\t\t\t__func__, response);\n\n\t \n\tmos7720_port->shadowMCR = UART_MCR_OUT2;  \n\n\t \n\tmos7720_port->open = 1;\n\n\treturn 0;\n}\n\n \nstatic unsigned int mos7720_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\n\tint i;\n\tunsigned int chars = 0;\n\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (mos7720_port->write_urb_pool[i] &&\n\t\t    mos7720_port->write_urb_pool[i]->status == -EINPROGRESS)\n\t\t\tchars += URB_TRANSFER_BUFFER_SIZE;\n\t}\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, chars);\n\treturn chars;\n}\n\nstatic void mos7720_close(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial;\n\tstruct moschip_port *mos7720_port;\n\tint j;\n\n\tserial = port->serial;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tif (mos7720_port == NULL)\n\t\treturn;\n\n\tfor (j = 0; j < NUM_URBS; ++j)\n\t\tusb_kill_urb(mos7720_port->write_urb_pool[j]);\n\n\t \n\tfor (j = 0; j < NUM_URBS; ++j) {\n\t\tif (mos7720_port->write_urb_pool[j]) {\n\t\t\tkfree(mos7720_port->write_urb_pool[j]->transfer_buffer);\n\t\t\tusb_free_urb(mos7720_port->write_urb_pool[j]);\n\t\t}\n\t}\n\n\t \n\tusb_kill_urb(port->write_urb);\n\tusb_kill_urb(port->read_urb);\n\n\twrite_mos_reg(serial, port->port_number, MOS7720_MCR, 0x00);\n\twrite_mos_reg(serial, port->port_number, MOS7720_IER, 0x00);\n\n\tmos7720_port->open = 0;\n}\n\nstatic int mos7720_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned char data;\n\tstruct usb_serial *serial;\n\tstruct moschip_port *mos7720_port;\n\n\tserial = port->serial;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tif (mos7720_port == NULL)\n\t\treturn -ENODEV;\n\n\tif (break_state == -1)\n\t\tdata = mos7720_port->shadowLCR | UART_LCR_SBC;\n\telse\n\t\tdata = mos7720_port->shadowLCR & ~UART_LCR_SBC;\n\n\tmos7720_port->shadowLCR  = data;\n\n\treturn write_mos_reg(serial, port->port_number, MOS7720_LCR,\n\t\t\t     mos7720_port->shadowLCR);\n}\n\n \nstatic unsigned int mos7720_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\n\tunsigned int room = 0;\n\tint i;\n\n\t \n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (mos7720_port->write_urb_pool[i] &&\n\t\t    mos7720_port->write_urb_pool[i]->status != -EINPROGRESS)\n\t\t\troom += URB_TRANSFER_BUFFER_SIZE;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n}\n\nstatic int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t const unsigned char *data, int count)\n{\n\tint status;\n\tint i;\n\tint bytes_sent = 0;\n\tint transfer_size;\n\n\tstruct moschip_port *mos7720_port;\n\tstruct usb_serial *serial;\n\tstruct urb    *urb;\n\tconst unsigned char *current_position = data;\n\n\tserial = port->serial;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tif (mos7720_port == NULL)\n\t\treturn -ENODEV;\n\n\t \n\turb = NULL;\n\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (mos7720_port->write_urb_pool[i] &&\n\t\t    mos7720_port->write_urb_pool[i]->status != -EINPROGRESS) {\n\t\t\turb = mos7720_port->write_urb_pool[i];\n\t\t\tdev_dbg(&port->dev, \"URB:%d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - no more free urbs\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tif (urb->transfer_buffer == NULL) {\n\t\turb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!urb->transfer_buffer) {\n\t\t\tbytes_sent = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\ttransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\n\n\tmemcpy(urb->transfer_buffer, current_position, transfer_size);\n\tusb_serial_debug_data(&port->dev, __func__, transfer_size,\n\t\t\t      urb->transfer_buffer);\n\n\t \n\tusb_fill_bulk_urb(urb, serial->dev,\n\t\t\t  usb_sndbulkpipe(serial->dev,\n\t\t\t\t\tport->bulk_out_endpointAddress),\n\t\t\t  urb->transfer_buffer, transfer_size,\n\t\t\t  mos7720_bulk_out_data_callback, mos7720_port);\n\n\t \n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\tdev_err_console(port, \"%s - usb_submit_urb(write bulk) failed \"\n\t\t\t\"with status = %d\\n\", __func__, status);\n\t\tbytes_sent = status;\n\t\tgoto exit;\n\t}\n\tbytes_sent = transfer_size;\n\nexit:\n\treturn bytes_sent;\n}\n\nstatic void mos7720_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port;\n\tint status;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\n\tif (mos7720_port == NULL)\n\t\treturn;\n\n\tif (!mos7720_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char stop_char = STOP_CHAR(tty);\n\t\tstatus = mos7720_write(tty, port, &stop_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tmos7720_port->shadowMCR &= ~UART_MCR_RTS;\n\t\twrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\n\t\t\t      mos7720_port->shadowMCR);\n\t}\n}\n\nstatic void mos7720_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (mos7720_port == NULL)\n\t\treturn;\n\n\tif (!mos7720_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char start_char = START_CHAR(tty);\n\t\tstatus = mos7720_write(tty, port, &start_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tmos7720_port->shadowMCR |= UART_MCR_RTS;\n\t\twrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\n\t\t\t      mos7720_port->shadowMCR);\n\t}\n}\n\n \nstatic int set_higher_rates(struct moschip_port *mos7720_port,\n\t\t\t    unsigned int baud)\n{\n\tstruct usb_serial_port *port;\n\tstruct usb_serial *serial;\n\tint port_number;\n\tenum mos_regs sp_reg;\n\tif (mos7720_port == NULL)\n\t\treturn -EINVAL;\n\n\tport = mos7720_port->port;\n\tserial = port->serial;\n\n\t  \n\tdev_dbg(&port->dev, \"Sending Setting Commands ..........\\n\");\n\tport_number = port->port_number;\n\n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\n\tmos7720_port->shadowMCR = 0x0b;\n\twrite_mos_reg(serial, port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\twrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, 0x00);\n\n\t \n\t \n\tif (port_number == 0)\n\t\tsp_reg = MOS7720_SP1_REG;\n\telse\n\t\tsp_reg = MOS7720_SP2_REG;\n\twrite_mos_reg(serial, dummy, sp_reg, baud * 0x10);\n\twrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG, 0x03);\n\tmos7720_port->shadowMCR = 0x2b;\n\twrite_mos_reg(serial, port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\n\t \n\tmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\twrite_mos_reg(serial, port_number, MOS7720_DLL, 0x01);\n\twrite_mos_reg(serial, port_number, MOS7720_DLM, 0x00);\n\tmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\n\treturn 0;\n}\n\n \nstruct divisor_table_entry {\n\t__u32  baudrate;\n\t__u16  divisor;\n};\n\n \nstatic const struct divisor_table_entry divisor_table[] = {\n\t{   50,\t\t2304},\n\t{   110,\t1047},\t \n\t{   134,\t857},\t \n\t{   150,\t768},\n\t{   300,\t384},\n\t{   600,\t192},\n\t{   1200,\t96},\n\t{   1800,\t64},\n\t{   2400,\t48},\n\t{   4800,\t24},\n\t{   7200,\t16},\n\t{   9600,\t12},\n\t{   19200,\t6},\n\t{   38400,\t3},\n\t{   57600,\t2},\n\t{   115200,\t1},\n};\n\n \nstatic int calc_baud_rate_divisor(struct usb_serial_port *port, int baudrate, int *divisor)\n{\n\tint i;\n\t__u16 custom;\n\t__u16 round1;\n\t__u16 round;\n\n\n\tdev_dbg(&port->dev, \"%s - %d\\n\", __func__, baudrate);\n\n\tfor (i = 0; i < ARRAY_SIZE(divisor_table); i++) {\n\t\tif (divisor_table[i].baudrate == baudrate) {\n\t\t\t*divisor = divisor_table[i].divisor;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (baudrate > 75 &&  baudrate < 230400) {\n\t\t \n\t\tcustom = (__u16)(230400L  / baudrate);\n\n\t\t \n\t\tround1 = (__u16)(2304000L / baudrate);\n\t\tround = (__u16)(round1 - (custom * 10));\n\t\tif (round > 4)\n\t\t\tcustom++;\n\t\t*divisor = custom;\n\n\t\tdev_dbg(&port->dev, \"Baud %d = %d\\n\", baudrate, custom);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(&port->dev, \"Baud calculation Failed...\\n\");\n\treturn -EINVAL;\n}\n\n \nstatic int send_cmd_write_baud_rate(struct moschip_port *mos7720_port,\n\t\t\t\t    int baudrate)\n{\n\tstruct usb_serial_port *port;\n\tstruct usb_serial *serial;\n\tint divisor;\n\tint status;\n\tunsigned char number;\n\n\tif (mos7720_port == NULL)\n\t\treturn -1;\n\n\tport = mos7720_port->port;\n\tserial = port->serial;\n\n\tnumber = port->port_number;\n\tdev_dbg(&port->dev, \"%s - baud = %d\\n\", __func__, baudrate);\n\n\t \n\tstatus = calc_baud_rate_divisor(port, baudrate, &divisor);\n\tif (status) {\n\t\tdev_err(&port->dev, \"%s - bad baud rate\\n\", __func__);\n\t\treturn status;\n\t}\n\n\t \n\tmos7720_port->shadowLCR = mos7720_port->shadowLCR | UART_LCR_DLAB;\n\twrite_mos_reg(serial, number, MOS7720_LCR, mos7720_port->shadowLCR);\n\n\t \n\twrite_mos_reg(serial, number, MOS7720_DLL, (__u8)(divisor & 0xff));\n\twrite_mos_reg(serial, number, MOS7720_DLM,\n\t\t      (__u8)((divisor & 0xff00) >> 8));\n\n\t \n\tmos7720_port->shadowLCR = mos7720_port->shadowLCR & ~UART_LCR_DLAB;\n\twrite_mos_reg(serial, number, MOS7720_LCR, mos7720_port->shadowLCR);\n\n\treturn status;\n}\n\n \nstatic void change_port_settings(struct tty_struct *tty,\n\t\t\t\t struct moschip_port *mos7720_port,\n\t\t\t\t const struct ktermios *old_termios)\n{\n\tstruct usb_serial_port *port;\n\tstruct usb_serial *serial;\n\tint baud;\n\tunsigned cflag;\n\t__u8 lData;\n\t__u8 lParity;\n\t__u8 lStop;\n\tint status;\n\tint port_number;\n\n\tif (mos7720_port == NULL)\n\t\treturn ;\n\n\tport = mos7720_port->port;\n\tserial = port->serial;\n\tport_number = port->port_number;\n\n\tif (!mos7720_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\tlStop = 0x00;\t \n\tlParity = 0x00;\t \n\n\tcflag = tty->termios.c_cflag;\n\n\tlData = UART_LCR_WLEN(tty_get_char_size(cflag));\n\n\t \n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tlParity = UART_LCR_PARITY;\n\t\t\tdev_dbg(&port->dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tlParity = (UART_LCR_EPAR | UART_LCR_PARITY);\n\t\t\tdev_dbg(&port->dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\n\t} else {\n\t\tdev_dbg(&port->dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CMSPAR)\n\t\tlParity = lParity | 0x20;\n\n\t \n\tif (cflag & CSTOPB) {\n\t\tlStop = UART_LCR_STOP;\n\t\tdev_dbg(&port->dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tlStop = 0x00;\n\t\tdev_dbg(&port->dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n#define LCR_BITS_MASK\t\t0x03\t \n#define LCR_STOP_MASK\t\t0x04\t \n#define LCR_PAR_MASK\t\t0x38\t \n\n\t \n\tmos7720_port->shadowLCR &=\n\t\t~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\n\tmos7720_port->shadowLCR |= (lData | lParity | lStop);\n\n\n\t \n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x00);\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0x00);\n\twrite_mos_reg(serial, port_number, MOS7720_FCR, 0xcf);\n\n\t \n\twrite_mos_reg(serial, port_number, MOS7720_LCR,\n\t\t      mos7720_port->shadowLCR);\n\tmos7720_port->shadowMCR = 0x0b;\n\twrite_mos_reg(serial, port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\n\t \n\tmos7720_port->shadowMCR = UART_MCR_OUT2;\n\tif (cflag & CBAUD)\n\t\tmos7720_port->shadowMCR |= (UART_MCR_DTR | UART_MCR_RTS);\n\n\tif (cflag & CRTSCTS) {\n\t\tmos7720_port->shadowMCR |= (UART_MCR_XONANY);\n\t\t \n\t\tif (port_number)\n\t\t\twrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG,\n\t\t\t\t      0x01);\n\t\telse\n\t\t\twrite_mos_reg(serial, dummy, MOS7720_SP_CONTROL_REG,\n\t\t\t\t      0x02);\n\n\t} else\n\t\tmos7720_port->shadowMCR &= ~(UART_MCR_XONANY);\n\n\twrite_mos_reg(serial, port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t \n\t\tdev_dbg(&port->dev, \"Picked default baud...\\n\");\n\t\tbaud = 9600;\n\t}\n\n\tif (baud >= 230400) {\n\t\tset_higher_rates(mos7720_port, baud);\n\t\t \n\t\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\n\t\treturn;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - baud rate = %d\\n\", __func__, baud);\n\tstatus = send_cmd_write_baud_rate(mos7720_port, baud);\n\t \n\tif (cflag & CBAUD)\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t \n\twrite_mos_reg(serial, port_number, MOS7720_IER, 0x0c);\n\n\tif (port->read_urb->status != -EINPROGRESS) {\n\t\tstatus = usb_submit_urb(port->read_urb, GFP_KERNEL);\n\t\tif (status)\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, status = %d\\n\", status);\n\t}\n}\n\n \nstatic void mos7720_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tint status;\n\tstruct moschip_port *mos7720_port;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\n\tif (mos7720_port == NULL)\n\t\treturn;\n\n\tif (!mos7720_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tchange_port_settings(tty, mos7720_port, old_termios);\n\n\tif (port->read_urb->status != -EINPROGRESS) {\n\t\tstatus = usb_submit_urb(port->read_urb, GFP_KERNEL);\n\t\tif (status)\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, status = %d\\n\", status);\n\t}\n}\n\n \nstatic int get_lsr_info(struct tty_struct *tty,\n\t\tstruct moschip_port *mos7720_port, unsigned int __user *value)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int result = 0;\n\tunsigned char data = 0;\n\tint port_number = port->port_number;\n\tint count;\n\n\tcount = mos7720_chars_in_buffer(tty);\n\tif (count == 0) {\n\t\tread_mos_reg(port->serial, port_number, MOS7720_LSR, &data);\n\t\tif ((data & (UART_LSR_TEMT | UART_LSR_THRE))\n\t\t\t\t\t== (UART_LSR_TEMT | UART_LSR_THRE)) {\n\t\t\tdev_dbg(&port->dev, \"%s -- Empty\\n\", __func__);\n\t\t\tresult = TIOCSER_TEMT;\n\t\t}\n\t}\n\tif (copy_to_user(value, &result, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int mos7720_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\n\tunsigned int result = 0;\n\tunsigned int mcr ;\n\tunsigned int msr ;\n\n\tmcr = mos7720_port->shadowMCR;\n\tmsr = mos7720_port->shadowMSR;\n\n\tresult = ((mcr & UART_MCR_DTR)  ? TIOCM_DTR : 0)    \n\t  | ((mcr & UART_MCR_RTS)   ? TIOCM_RTS : 0)    \n\t  | ((msr & UART_MSR_CTS)   ? TIOCM_CTS : 0)    \n\t  | ((msr & UART_MSR_DCD)   ? TIOCM_CAR : 0)    \n\t  | ((msr & UART_MSR_RI)    ? TIOCM_RI :  0)    \n\t  | ((msr & UART_MSR_DSR)   ? TIOCM_DSR : 0);   \n\n\treturn result;\n}\n\nstatic int mos7720_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port = usb_get_serial_port_data(port);\n\tunsigned int mcr ;\n\n\tmcr = mos7720_port->shadowMCR;\n\n\tif (set & TIOCM_RTS)\n\t\tmcr |= UART_MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= UART_MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= UART_MCR_LOOP;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~UART_MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~UART_MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~UART_MCR_LOOP;\n\n\tmos7720_port->shadowMCR = mcr;\n\twrite_mos_reg(port->serial, port->port_number, MOS7720_MCR,\n\t\t      mos7720_port->shadowMCR);\n\n\treturn 0;\n}\n\nstatic int mos7720_ioctl(struct tty_struct *tty,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7720_port;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tif (mos7720_port == NULL)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase TIOCSERGETLSR:\n\t\tdev_dbg(&port->dev, \"%s TIOCSERGETLSR\\n\", __func__);\n\t\treturn get_lsr_info(tty, mos7720_port,\n\t\t\t\t\t(unsigned int __user *)arg);\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic int mos7720_startup(struct usb_serial *serial)\n{\n\tstruct usb_device *dev;\n\tchar data;\n\tu16 product;\n\tint ret_val;\n\n\tproduct = le16_to_cpu(serial->dev->descriptor.idProduct);\n\tdev = serial->dev;\n\n\tif (product == MOSCHIP_DEVICE_ID_7715) {\n\t\tstruct urb *urb = serial->port[0]->interrupt_in_urb;\n\n\t\turb->complete = mos7715_interrupt_callback;\n\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\n\t\tret_val = mos7715_parport_init(serial);\n\t\tif (ret_val < 0)\n\t\t\treturn ret_val;\n#endif\n\t}\n\t \n\tret_val = usb_submit_urb(serial->port[0]->interrupt_in_urb, GFP_KERNEL);\n\tif (ret_val) {\n\t\tdev_err(&dev->dev, \"failed to submit interrupt urb: %d\\n\",\n\t\t\tret_val);\n\t}\n\n\t \n\tread_mos_reg(serial, 0, MOS7720_LSR, &data);\n\tdev_dbg(&dev->dev, \"LSR:%x\\n\", data);\n\n\treturn 0;\n}\n\nstatic void mos7720_release(struct usb_serial *serial)\n{\n\tusb_kill_urb(serial->port[0]->interrupt_in_urb);\n\n#ifdef CONFIG_USB_SERIAL_MOS7715_PARPORT\n\t \n\n\tif (le16_to_cpu(serial->dev->descriptor.idProduct)\n\t    == MOSCHIP_DEVICE_ID_7715) {\n\t\tstruct mos7715_parport *mos_parport =\n\t\t\tusb_get_serial_data(serial);\n\n\t\t \n\t\tspin_lock(&release_lock);\n\t\tmos_parport->pp->private_data = NULL;\n\t\tspin_unlock(&release_lock);\n\n\t\t \n\t\tif (mos_parport->msg_pending)\n\t\t\twait_for_completion_timeout(&mos_parport->syncmsg_compl,\n\t\t\t\t\t    msecs_to_jiffies(MOS_WDR_TIMEOUT));\n\t\t \n\t\tcancel_work_sync(&mos_parport->work);\n\n\t\tparport_remove_port(mos_parport->pp);\n\t\tusb_set_serial_data(serial, NULL);\n\t\tmos_parport->serial = NULL;\n\n\t\tparport_del_port(mos_parport->pp);\n\n\t\tkref_put(&mos_parport->ref_count, destroy_mos_parport);\n\t}\n#endif\n}\n\nstatic int mos7720_port_probe(struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7720_port;\n\n\tmos7720_port = kzalloc(sizeof(*mos7720_port), GFP_KERNEL);\n\tif (!mos7720_port)\n\t\treturn -ENOMEM;\n\n\tmos7720_port->port = port;\n\n\tusb_set_serial_port_data(port, mos7720_port);\n\n\treturn 0;\n}\n\nstatic void mos7720_port_remove(struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7720_port;\n\n\tmos7720_port = usb_get_serial_port_data(port);\n\tkfree(mos7720_port);\n}\n\nstatic struct usb_serial_driver moschip7720_2port_driver = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"moschip7720\",\n\t},\n\t.description\t\t= \"Moschip 2 port adapter\",\n\t.id_table\t\t= id_table,\n\t.num_bulk_in\t\t= 2,\n\t.num_bulk_out\t\t= 2,\n\t.num_interrupt_in\t= 1,\n\t.calc_num_ports\t\t= mos77xx_calc_num_ports,\n\t.open\t\t\t= mos7720_open,\n\t.close\t\t\t= mos7720_close,\n\t.throttle\t\t= mos7720_throttle,\n\t.unthrottle\t\t= mos7720_unthrottle,\n\t.attach\t\t\t= mos7720_startup,\n\t.release\t\t= mos7720_release,\n\t.port_probe\t\t= mos7720_port_probe,\n\t.port_remove\t\t= mos7720_port_remove,\n\t.ioctl\t\t\t= mos7720_ioctl,\n\t.tiocmget\t\t= mos7720_tiocmget,\n\t.tiocmset\t\t= mos7720_tiocmset,\n\t.set_termios\t\t= mos7720_set_termios,\n\t.write\t\t\t= mos7720_write,\n\t.write_room\t\t= mos7720_write_room,\n\t.chars_in_buffer\t= mos7720_chars_in_buffer,\n\t.break_ctl\t\t= mos7720_break,\n\t.read_bulk_callback\t= mos7720_bulk_in_callback,\n\t.read_int_callback\t= mos7720_interrupt_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&moschip7720_2port_driver, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}