{
  "module_name": "digi_acceleport.c",
  "hash_id": "67d7b09152961774a7d1ee9f94abf3c4cb9f0d5a61381160a7600778ff0ba61b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/digi_acceleport.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/sched/signal.h>\n#include <linux/usb/serial.h>\n\n \n\n#define DRIVER_AUTHOR \"Peter Berger <pberger@brimson.com>, Al Borchers <borchers@steinerpoint.com>\"\n#define DRIVER_DESC \"Digi AccelePort USB-2/USB-4 Serial Converter driver\"\n\n \n \n#define DIGI_OUT_BUF_SIZE\t\t8\n\n \n \n#define DIGI_IN_BUF_SIZE\t\t64\n\n \n#define DIGI_RETRY_TIMEOUT\t\t(HZ/10)\n\n \n \n \n#define DIGI_CLOSE_TIMEOUT\t\t(5*HZ)\n\n\n \n\n \n#define DIGI_VENDOR_ID\t\t\t0x05c5\n#define DIGI_2_ID\t\t\t0x0002\t \n#define DIGI_4_ID\t\t\t0x0004\t \n\n \n#define DIGI_CMD_SET_BAUD_RATE\t\t\t0\t \n#define DIGI_CMD_SET_WORD_SIZE\t\t\t1\t \n#define DIGI_CMD_SET_PARITY\t\t\t2\t \n#define DIGI_CMD_SET_STOP_BITS\t\t\t3\t \n#define DIGI_CMD_SET_INPUT_FLOW_CONTROL\t\t4\t \n#define DIGI_CMD_SET_OUTPUT_FLOW_CONTROL\t5\t \n#define DIGI_CMD_SET_DTR_SIGNAL\t\t\t6\t \n#define DIGI_CMD_SET_RTS_SIGNAL\t\t\t7\t \n#define DIGI_CMD_READ_INPUT_SIGNALS\t\t8\t \n#define DIGI_CMD_IFLUSH_FIFO\t\t\t9\t \n#define DIGI_CMD_RECEIVE_ENABLE\t\t\t10\t \n#define DIGI_CMD_BREAK_CONTROL\t\t\t11\t \n#define DIGI_CMD_LOCAL_LOOPBACK\t\t\t12\t \n#define DIGI_CMD_TRANSMIT_IDLE\t\t\t13\t \n#define DIGI_CMD_READ_UART_REGISTER\t\t14\t \n#define DIGI_CMD_WRITE_UART_REGISTER\t\t15\t \n#define DIGI_CMD_AND_UART_REGISTER\t\t16\t \n#define DIGI_CMD_OR_UART_REGISTER\t\t17\t \n#define DIGI_CMD_SEND_DATA\t\t\t18\t \n#define DIGI_CMD_RECEIVE_DATA\t\t\t19\t \n#define DIGI_CMD_RECEIVE_DISABLE\t\t20\t \n#define DIGI_CMD_GET_PORT_TYPE\t\t\t21\t \n\n \n#define DIGI_BAUD_50\t\t\t\t0\n#define DIGI_BAUD_75\t\t\t\t1\n#define DIGI_BAUD_110\t\t\t\t2\n#define DIGI_BAUD_150\t\t\t\t3\n#define DIGI_BAUD_200\t\t\t\t4\n#define DIGI_BAUD_300\t\t\t\t5\n#define DIGI_BAUD_600\t\t\t\t6\n#define DIGI_BAUD_1200\t\t\t\t7\n#define DIGI_BAUD_1800\t\t\t\t8\n#define DIGI_BAUD_2400\t\t\t\t9\n#define DIGI_BAUD_4800\t\t\t\t10\n#define DIGI_BAUD_7200\t\t\t\t11\n#define DIGI_BAUD_9600\t\t\t\t12\n#define DIGI_BAUD_14400\t\t\t\t13\n#define DIGI_BAUD_19200\t\t\t\t14\n#define DIGI_BAUD_28800\t\t\t\t15\n#define DIGI_BAUD_38400\t\t\t\t16\n#define DIGI_BAUD_57600\t\t\t\t17\n#define DIGI_BAUD_76800\t\t\t\t18\n#define DIGI_BAUD_115200\t\t\t19\n#define DIGI_BAUD_153600\t\t\t20\n#define DIGI_BAUD_230400\t\t\t21\n#define DIGI_BAUD_460800\t\t\t22\n\n \n#define DIGI_WORD_SIZE_5\t\t\t0\n#define DIGI_WORD_SIZE_6\t\t\t1\n#define DIGI_WORD_SIZE_7\t\t\t2\n#define DIGI_WORD_SIZE_8\t\t\t3\n\n#define DIGI_PARITY_NONE\t\t\t0\n#define DIGI_PARITY_ODD\t\t\t\t1\n#define DIGI_PARITY_EVEN\t\t\t2\n#define DIGI_PARITY_MARK\t\t\t3\n#define DIGI_PARITY_SPACE\t\t\t4\n\n#define DIGI_STOP_BITS_1\t\t\t0\n#define DIGI_STOP_BITS_2\t\t\t1\n\n#define DIGI_INPUT_FLOW_CONTROL_XON_XOFF\t1\n#define DIGI_INPUT_FLOW_CONTROL_RTS\t\t2\n#define DIGI_INPUT_FLOW_CONTROL_DTR\t\t4\n\n#define DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF\t1\n#define DIGI_OUTPUT_FLOW_CONTROL_CTS\t\t2\n#define DIGI_OUTPUT_FLOW_CONTROL_DSR\t\t4\n\n#define DIGI_DTR_INACTIVE\t\t\t0\n#define DIGI_DTR_ACTIVE\t\t\t\t1\n#define DIGI_DTR_INPUT_FLOW_CONTROL\t\t2\n\n#define DIGI_RTS_INACTIVE\t\t\t0\n#define DIGI_RTS_ACTIVE\t\t\t\t1\n#define DIGI_RTS_INPUT_FLOW_CONTROL\t\t2\n#define DIGI_RTS_TOGGLE\t\t\t\t3\n\n#define DIGI_FLUSH_TX\t\t\t\t1\n#define DIGI_FLUSH_RX\t\t\t\t2\n#define DIGI_RESUME_TX\t\t\t\t4  \n\n#define DIGI_TRANSMIT_NOT_IDLE\t\t\t0\n#define DIGI_TRANSMIT_IDLE\t\t\t1\n\n#define DIGI_DISABLE\t\t\t\t0\n#define DIGI_ENABLE\t\t\t\t1\n\n#define DIGI_DEASSERT\t\t\t\t0\n#define DIGI_ASSERT\t\t\t\t1\n\n \n#define DIGI_OVERRUN_ERROR\t\t\t4\n#define DIGI_PARITY_ERROR\t\t\t8\n#define DIGI_FRAMING_ERROR\t\t\t16\n#define DIGI_BREAK_ERROR\t\t\t32\n\n \n#define DIGI_NO_ERROR\t\t\t\t0\n#define DIGI_BAD_FIRST_PARAMETER\t\t1\n#define DIGI_BAD_SECOND_PARAMETER\t\t2\n#define DIGI_INVALID_LINE\t\t\t3\n#define DIGI_INVALID_OPCODE\t\t\t4\n\n \n#define DIGI_READ_INPUT_SIGNALS_SLOT\t\t1\n#define DIGI_READ_INPUT_SIGNALS_ERR\t\t2\n#define DIGI_READ_INPUT_SIGNALS_BUSY\t\t4\n#define DIGI_READ_INPUT_SIGNALS_PE\t\t8\n#define DIGI_READ_INPUT_SIGNALS_CTS\t\t16\n#define DIGI_READ_INPUT_SIGNALS_DSR\t\t32\n#define DIGI_READ_INPUT_SIGNALS_RI\t\t64\n#define DIGI_READ_INPUT_SIGNALS_DCD\t\t128\n\n\n \n\nstruct digi_serial {\n\tspinlock_t ds_serial_lock;\n\tstruct usb_serial_port *ds_oob_port;\t \n\tint ds_oob_port_num;\t\t\t \n\tint ds_device_started;\n};\n\nstruct digi_port {\n\tspinlock_t dp_port_lock;\n\tint dp_port_num;\n\tint dp_out_buf_len;\n\tunsigned char dp_out_buf[DIGI_OUT_BUF_SIZE];\n\tint dp_write_urb_in_use;\n\tunsigned int dp_modem_signals;\n\tint dp_transmit_idle;\n\twait_queue_head_t dp_transmit_idle_wait;\n\tint dp_throttled;\n\tint dp_throttle_restart;\n\twait_queue_head_t dp_flush_wait;\n\twait_queue_head_t dp_close_wait;\t \n\twait_queue_head_t write_wait;\n\tstruct usb_serial_port *dp_port;\n};\n\n\n \n\nstatic int digi_write_oob_command(struct usb_serial_port *port,\n\tunsigned char *buf, int count, int interruptible);\nstatic int digi_write_inb_command(struct usb_serial_port *port,\n\tunsigned char *buf, int count, unsigned long timeout);\nstatic int digi_set_modem_signals(struct usb_serial_port *port,\n\tunsigned int modem_signals, int interruptible);\nstatic int digi_transmit_idle(struct usb_serial_port *port,\n\tunsigned long timeout);\nstatic void digi_rx_throttle(struct tty_struct *tty);\nstatic void digi_rx_unthrottle(struct tty_struct *tty);\nstatic void digi_set_termios(struct tty_struct *tty,\n\t\t\t     struct usb_serial_port *port,\n\t\t\t     const struct ktermios *old_termios);\nstatic int digi_break_ctl(struct tty_struct *tty, int break_state);\nstatic int digi_tiocmget(struct tty_struct *tty);\nstatic int digi_tiocmset(struct tty_struct *tty, unsigned int set,\n\t\tunsigned int clear);\nstatic int digi_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\tconst unsigned char *buf, int count);\nstatic void digi_write_bulk_callback(struct urb *urb);\nstatic unsigned int digi_write_room(struct tty_struct *tty);\nstatic unsigned int digi_chars_in_buffer(struct tty_struct *tty);\nstatic int digi_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void digi_close(struct usb_serial_port *port);\nstatic void digi_dtr_rts(struct usb_serial_port *port, int on);\nstatic int digi_startup_device(struct usb_serial *serial);\nstatic int digi_startup(struct usb_serial *serial);\nstatic void digi_disconnect(struct usb_serial *serial);\nstatic void digi_release(struct usb_serial *serial);\nstatic int digi_port_probe(struct usb_serial_port *port);\nstatic void digi_port_remove(struct usb_serial_port *port);\nstatic void digi_read_bulk_callback(struct urb *urb);\nstatic int digi_read_inb_callback(struct urb *urb);\nstatic int digi_read_oob_callback(struct urb *urb);\n\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_2_ID) },\n\t{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_4_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_2[] = {\n\t{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_2_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_4[] = {\n\t{ USB_DEVICE(DIGI_VENDOR_ID, DIGI_4_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n \n\nstatic struct usb_serial_driver digi_acceleport_2_device = {\n\t.driver = {\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.name =\t\t\t\"digi_2\",\n\t},\n\t.description =\t\t\t\"Digi 2 port USB adapter\",\n\t.id_table =\t\t\tid_table_2,\n\t.num_ports =\t\t\t3,\n\t.num_bulk_in =\t\t\t4,\n\t.num_bulk_out =\t\t\t4,\n\t.open =\t\t\t\tdigi_open,\n\t.close =\t\t\tdigi_close,\n\t.dtr_rts =\t\t\tdigi_dtr_rts,\n\t.write =\t\t\tdigi_write,\n\t.write_room =\t\t\tdigi_write_room,\n\t.write_bulk_callback = \t\tdigi_write_bulk_callback,\n\t.read_bulk_callback =\t\tdigi_read_bulk_callback,\n\t.chars_in_buffer =\t\tdigi_chars_in_buffer,\n\t.throttle =\t\t\tdigi_rx_throttle,\n\t.unthrottle =\t\t\tdigi_rx_unthrottle,\n\t.set_termios =\t\t\tdigi_set_termios,\n\t.break_ctl =\t\t\tdigi_break_ctl,\n\t.tiocmget =\t\t\tdigi_tiocmget,\n\t.tiocmset =\t\t\tdigi_tiocmset,\n\t.attach =\t\t\tdigi_startup,\n\t.disconnect =\t\t\tdigi_disconnect,\n\t.release =\t\t\tdigi_release,\n\t.port_probe =\t\t\tdigi_port_probe,\n\t.port_remove =\t\t\tdigi_port_remove,\n};\n\nstatic struct usb_serial_driver digi_acceleport_4_device = {\n\t.driver = {\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.name =\t\t\t\"digi_4\",\n\t},\n\t.description =\t\t\t\"Digi 4 port USB adapter\",\n\t.id_table =\t\t\tid_table_4,\n\t.num_ports =\t\t\t4,\n\t.num_bulk_in =\t\t\t5,\n\t.num_bulk_out =\t\t\t5,\n\t.open =\t\t\t\tdigi_open,\n\t.close =\t\t\tdigi_close,\n\t.write =\t\t\tdigi_write,\n\t.write_room =\t\t\tdigi_write_room,\n\t.write_bulk_callback = \t\tdigi_write_bulk_callback,\n\t.read_bulk_callback =\t\tdigi_read_bulk_callback,\n\t.chars_in_buffer =\t\tdigi_chars_in_buffer,\n\t.throttle =\t\t\tdigi_rx_throttle,\n\t.unthrottle =\t\t\tdigi_rx_unthrottle,\n\t.set_termios =\t\t\tdigi_set_termios,\n\t.break_ctl =\t\t\tdigi_break_ctl,\n\t.tiocmget =\t\t\tdigi_tiocmget,\n\t.tiocmset =\t\t\tdigi_tiocmset,\n\t.attach =\t\t\tdigi_startup,\n\t.disconnect =\t\t\tdigi_disconnect,\n\t.release =\t\t\tdigi_release,\n\t.port_probe =\t\t\tdigi_port_probe,\n\t.port_remove =\t\t\tdigi_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&digi_acceleport_2_device, &digi_acceleport_4_device, NULL\n};\n\n \n\n \n\nstatic long cond_wait_interruptible_timeout_irqrestore(\n\twait_queue_head_t *q, long timeout,\n\tspinlock_t *lock, unsigned long flags)\n__releases(lock)\n{\n\tDEFINE_WAIT(wait);\n\n\tprepare_to_wait(q, &wait, TASK_INTERRUPTIBLE);\n\tspin_unlock_irqrestore(lock, flags);\n\ttimeout = schedule_timeout(timeout);\n\tfinish_wait(q, &wait);\n\n\treturn timeout;\n}\n\n \n\nstatic int digi_write_oob_command(struct usb_serial_port *port,\n\tunsigned char *buf, int count, int interruptible)\n{\n\tint ret = 0;\n\tint len;\n\tstruct usb_serial_port *oob_port = (struct usb_serial_port *)((struct digi_serial *)(usb_get_serial_data(port->serial)))->ds_oob_port;\n\tstruct digi_port *oob_priv = usb_get_serial_port_data(oob_port);\n\tunsigned long flags;\n\n\tdev_dbg(&port->dev,\n\t\t\"digi_write_oob_command: TOP: port=%d, count=%d\\n\",\n\t\toob_priv->dp_port_num, count);\n\n\tspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\n\twhile (count > 0) {\n\t\twhile (oob_priv->dp_write_urb_in_use) {\n\t\t\tcond_wait_interruptible_timeout_irqrestore(\n\t\t\t\t&oob_priv->write_wait, DIGI_RETRY_TIMEOUT,\n\t\t\t\t&oob_priv->dp_port_lock, flags);\n\t\t\tif (interruptible && signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t\tspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\n\t\t}\n\n\t\t \n\t\tlen = min(count, oob_port->bulk_out_size);\n\t\tif (len > 4)\n\t\t\tlen &= ~3;\n\t\tmemcpy(oob_port->write_urb->transfer_buffer, buf, len);\n\t\toob_port->write_urb->transfer_buffer_length = len;\n\t\tret = usb_submit_urb(oob_port->write_urb, GFP_ATOMIC);\n\t\tif (ret == 0) {\n\t\t\toob_priv->dp_write_urb_in_use = 1;\n\t\t\tcount -= len;\n\t\t\tbuf += len;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&oob_priv->dp_port_lock, flags);\n\tif (ret)\n\t\tdev_err(&port->dev, \"%s: usb_submit_urb failed, ret=%d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n\n}\n\n\n \n\nstatic int digi_write_inb_command(struct usb_serial_port *port,\n\tunsigned char *buf, int count, unsigned long timeout)\n{\n\tint ret = 0;\n\tint len;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = port->write_urb->transfer_buffer;\n\tunsigned long flags;\n\n\tdev_dbg(&port->dev, \"digi_write_inb_command: TOP: port=%d, count=%d\\n\",\n\t\tpriv->dp_port_num, count);\n\n\tif (timeout)\n\t\ttimeout += jiffies;\n\telse\n\t\ttimeout = ULONG_MAX;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\twhile (count > 0 && ret == 0) {\n\t\twhile (priv->dp_write_urb_in_use &&\n\t\t       time_before(jiffies, timeout)) {\n\t\t\tcond_wait_interruptible_timeout_irqrestore(\n\t\t\t\t&priv->write_wait, DIGI_RETRY_TIMEOUT,\n\t\t\t\t&priv->dp_port_lock, flags);\n\t\t\tif (signal_pending(current))\n\t\t\t\treturn -EINTR;\n\t\t\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\t\t}\n\n\t\t \n\t\t \n\t\t \n\t\tlen = min(count, port->bulk_out_size-2-priv->dp_out_buf_len);\n\t\tif (len > 4)\n\t\t\tlen &= ~3;\n\n\t\t \n\t\tif (priv->dp_out_buf_len > 0) {\n\t\t\tdata[0] = DIGI_CMD_SEND_DATA;\n\t\t\tdata[1] = priv->dp_out_buf_len;\n\t\t\tmemcpy(data + 2, priv->dp_out_buf,\n\t\t\t\tpriv->dp_out_buf_len);\n\t\t\tmemcpy(data + 2 + priv->dp_out_buf_len, buf, len);\n\t\t\tport->write_urb->transfer_buffer_length\n\t\t\t\t= priv->dp_out_buf_len + 2 + len;\n\t\t} else {\n\t\t\tmemcpy(data, buf, len);\n\t\t\tport->write_urb->transfer_buffer_length = len;\n\t\t}\n\n\t\tret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\t\tif (ret == 0) {\n\t\t\tpriv->dp_write_urb_in_use = 1;\n\t\t\tpriv->dp_out_buf_len = 0;\n\t\t\tcount -= len;\n\t\t\tbuf += len;\n\t\t}\n\n\t}\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tif (ret)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s: usb_submit_urb failed, ret=%d, port=%d\\n\",\n\t\t\t__func__, ret, priv->dp_port_num);\n\treturn ret;\n}\n\n\n \n\nstatic int digi_set_modem_signals(struct usb_serial_port *port,\n\tunsigned int modem_signals, int interruptible)\n{\n\n\tint ret;\n\tstruct digi_port *port_priv = usb_get_serial_port_data(port);\n\tstruct usb_serial_port *oob_port = (struct usb_serial_port *) ((struct digi_serial *)(usb_get_serial_data(port->serial)))->ds_oob_port;\n\tstruct digi_port *oob_priv = usb_get_serial_port_data(oob_port);\n\tunsigned char *data = oob_port->write_urb->transfer_buffer;\n\tunsigned long flags;\n\n\tdev_dbg(&port->dev,\n\t\t\"digi_set_modem_signals: TOP: port=%d, modem_signals=0x%x\\n\",\n\t\tport_priv->dp_port_num, modem_signals);\n\n\tspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\n\tspin_lock(&port_priv->dp_port_lock);\n\n\twhile (oob_priv->dp_write_urb_in_use) {\n\t\tspin_unlock(&port_priv->dp_port_lock);\n\t\tcond_wait_interruptible_timeout_irqrestore(\n\t\t\t&oob_priv->write_wait, DIGI_RETRY_TIMEOUT,\n\t\t\t&oob_priv->dp_port_lock, flags);\n\t\tif (interruptible && signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tspin_lock_irqsave(&oob_priv->dp_port_lock, flags);\n\t\tspin_lock(&port_priv->dp_port_lock);\n\t}\n\tdata[0] = DIGI_CMD_SET_DTR_SIGNAL;\n\tdata[1] = port_priv->dp_port_num;\n\tdata[2] = (modem_signals & TIOCM_DTR) ?\n\t\t\t\t\tDIGI_DTR_ACTIVE : DIGI_DTR_INACTIVE;\n\tdata[3] = 0;\n\tdata[4] = DIGI_CMD_SET_RTS_SIGNAL;\n\tdata[5] = port_priv->dp_port_num;\n\tdata[6] = (modem_signals & TIOCM_RTS) ?\n\t\t\t\t\tDIGI_RTS_ACTIVE : DIGI_RTS_INACTIVE;\n\tdata[7] = 0;\n\n\toob_port->write_urb->transfer_buffer_length = 8;\n\n\tret = usb_submit_urb(oob_port->write_urb, GFP_ATOMIC);\n\tif (ret == 0) {\n\t\toob_priv->dp_write_urb_in_use = 1;\n\t\tport_priv->dp_modem_signals &= ~(TIOCM_DTR | TIOCM_RTS);\n\t\tport_priv->dp_modem_signals |=\n\t\t\t\tmodem_signals & (TIOCM_DTR | TIOCM_RTS);\n\t}\n\tspin_unlock(&port_priv->dp_port_lock);\n\tspin_unlock_irqrestore(&oob_priv->dp_port_lock, flags);\n\tif (ret)\n\t\tdev_err(&port->dev, \"%s: usb_submit_urb failed, ret=%d\\n\",\n\t\t\t__func__, ret);\n\treturn ret;\n}\n\n \n\nstatic int digi_transmit_idle(struct usb_serial_port *port,\n\tunsigned long timeout)\n{\n\tint ret;\n\tunsigned char buf[2];\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tpriv->dp_transmit_idle = 0;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tbuf[0] = DIGI_CMD_TRANSMIT_IDLE;\n\tbuf[1] = 0;\n\n\ttimeout += jiffies;\n\n\tret = digi_write_inb_command(port, buf, 2, timeout - jiffies);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\n\twhile (time_before(jiffies, timeout) && !priv->dp_transmit_idle) {\n\t\tcond_wait_interruptible_timeout_irqrestore(\n\t\t\t&priv->dp_transmit_idle_wait, DIGI_RETRY_TIMEOUT,\n\t\t\t&priv->dp_port_lock, flags);\n\t\tif (signal_pending(current))\n\t\t\treturn -EINTR;\n\t\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\t}\n\tpriv->dp_transmit_idle = 0;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\treturn 0;\n\n}\n\n\nstatic void digi_rx_throttle(struct tty_struct *tty)\n{\n\tunsigned long flags;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\n\t \n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tpriv->dp_throttled = 1;\n\tpriv->dp_throttle_restart = 0;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n}\n\n\nstatic void digi_rx_unthrottle(struct tty_struct *tty)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\n\t \n\tif (priv->dp_throttle_restart)\n\t\tret = usb_submit_urb(port->read_urb, GFP_ATOMIC);\n\n\t \n\tpriv->dp_throttled = 0;\n\tpriv->dp_throttle_restart = 0;\n\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tif (ret)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s: usb_submit_urb failed, ret=%d, port=%d\\n\",\n\t\t\t__func__, ret, priv->dp_port_num);\n}\n\n\nstatic void digi_set_termios(struct tty_struct *tty,\n\t\t\t     struct usb_serial_port *port,\n\t\t\t     const struct ktermios *old_termios)\n{\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned int iflag = tty->termios.c_iflag;\n\tunsigned int cflag = tty->termios.c_cflag;\n\tunsigned int old_iflag = old_termios->c_iflag;\n\tunsigned int old_cflag = old_termios->c_cflag;\n\tunsigned char buf[32];\n\tunsigned int modem_signals;\n\tint arg, ret;\n\tint i = 0;\n\tspeed_t baud;\n\n\tdev_dbg(dev,\n\t\t\"digi_set_termios: TOP: port=%d, iflag=0x%x, old_iflag=0x%x, cflag=0x%x, old_cflag=0x%x\\n\",\n\t\tpriv->dp_port_num, iflag, old_iflag, cflag, old_cflag);\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tif (baud != tty_termios_baud_rate(old_termios)) {\n\t\targ = -1;\n\n\t\t \n\t\tif ((old_cflag & CBAUD) == B0) {\n\t\t\t \n\t\t\t \n\t\t\tmodem_signals = TIOCM_DTR;\n\t\t\tif (!C_CRTSCTS(tty) || !tty_throttled(tty))\n\t\t\t\tmodem_signals |= TIOCM_RTS;\n\t\t\tdigi_set_modem_signals(port, modem_signals, 1);\n\t\t}\n\t\tswitch (baud) {\n\t\t \n\t\tcase 0: digi_set_modem_signals(port, 0, 1); break;\n\t\tcase 50: arg = DIGI_BAUD_50; break;\n\t\tcase 75: arg = DIGI_BAUD_75; break;\n\t\tcase 110: arg = DIGI_BAUD_110; break;\n\t\tcase 150: arg = DIGI_BAUD_150; break;\n\t\tcase 200: arg = DIGI_BAUD_200; break;\n\t\tcase 300: arg = DIGI_BAUD_300; break;\n\t\tcase 600: arg = DIGI_BAUD_600; break;\n\t\tcase 1200: arg = DIGI_BAUD_1200; break;\n\t\tcase 1800: arg = DIGI_BAUD_1800; break;\n\t\tcase 2400: arg = DIGI_BAUD_2400; break;\n\t\tcase 4800: arg = DIGI_BAUD_4800; break;\n\t\tcase 9600: arg = DIGI_BAUD_9600; break;\n\t\tcase 19200: arg = DIGI_BAUD_19200; break;\n\t\tcase 38400: arg = DIGI_BAUD_38400; break;\n\t\tcase 57600: arg = DIGI_BAUD_57600; break;\n\t\tcase 115200: arg = DIGI_BAUD_115200; break;\n\t\tcase 230400: arg = DIGI_BAUD_230400; break;\n\t\tcase 460800: arg = DIGI_BAUD_460800; break;\n\t\tdefault:\n\t\t\targ = DIGI_BAUD_9600;\n\t\t\tbaud = 9600;\n\t\t\tbreak;\n\t\t}\n\t\tif (arg != -1) {\n\t\t\tbuf[i++] = DIGI_CMD_SET_BAUD_RATE;\n\t\t\tbuf[i++] = priv->dp_port_num;\n\t\t\tbuf[i++] = arg;\n\t\t\tbuf[i++] = 0;\n\t\t}\n\t}\n\t \n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\tif ((cflag & (PARENB | PARODD)) != (old_cflag & (PARENB | PARODD))) {\n\t\tif (cflag & PARENB) {\n\t\t\tif (cflag & PARODD)\n\t\t\t\targ = DIGI_PARITY_ODD;\n\t\t\telse\n\t\t\t\targ = DIGI_PARITY_EVEN;\n\t\t} else {\n\t\t\targ = DIGI_PARITY_NONE;\n\t\t}\n\t\tbuf[i++] = DIGI_CMD_SET_PARITY;\n\t\tbuf[i++] = priv->dp_port_num;\n\t\tbuf[i++] = arg;\n\t\tbuf[i++] = 0;\n\t}\n\t \n\tif ((cflag & CSIZE) != (old_cflag & CSIZE)) {\n\t\targ = -1;\n\t\tswitch (cflag & CSIZE) {\n\t\tcase CS5: arg = DIGI_WORD_SIZE_5; break;\n\t\tcase CS6: arg = DIGI_WORD_SIZE_6; break;\n\t\tcase CS7: arg = DIGI_WORD_SIZE_7; break;\n\t\tcase CS8: arg = DIGI_WORD_SIZE_8; break;\n\t\tdefault:\n\t\t\tdev_dbg(dev,\n\t\t\t\t\"digi_set_termios: can't handle word size %d\\n\",\n\t\t\t\tcflag & CSIZE);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (arg != -1) {\n\t\t\tbuf[i++] = DIGI_CMD_SET_WORD_SIZE;\n\t\t\tbuf[i++] = priv->dp_port_num;\n\t\t\tbuf[i++] = arg;\n\t\t\tbuf[i++] = 0;\n\t\t}\n\n\t}\n\n\t \n\tif ((cflag & CSTOPB) != (old_cflag & CSTOPB)) {\n\n\t\tif ((cflag & CSTOPB))\n\t\t\targ = DIGI_STOP_BITS_2;\n\t\telse\n\t\t\targ = DIGI_STOP_BITS_1;\n\n\t\tbuf[i++] = DIGI_CMD_SET_STOP_BITS;\n\t\tbuf[i++] = priv->dp_port_num;\n\t\tbuf[i++] = arg;\n\t\tbuf[i++] = 0;\n\n\t}\n\n\t \n\tif ((iflag & IXOFF) != (old_iflag & IXOFF) ||\n\t\t\t(cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\n\t\targ = 0;\n\t\tif (iflag & IXOFF)\n\t\t\targ |= DIGI_INPUT_FLOW_CONTROL_XON_XOFF;\n\t\telse\n\t\t\targ &= ~DIGI_INPUT_FLOW_CONTROL_XON_XOFF;\n\n\t\tif (cflag & CRTSCTS) {\n\t\t\targ |= DIGI_INPUT_FLOW_CONTROL_RTS;\n\n\t\t\t \n\t\t\t \n\t\t\tbuf[i++] = DIGI_CMD_SET_RTS_SIGNAL;\n\t\t\tbuf[i++] = priv->dp_port_num;\n\t\t\tbuf[i++] = DIGI_RTS_ACTIVE;\n\t\t\tbuf[i++] = 0;\n\n\t\t} else {\n\t\t\targ &= ~DIGI_INPUT_FLOW_CONTROL_RTS;\n\t\t}\n\t\tbuf[i++] = DIGI_CMD_SET_INPUT_FLOW_CONTROL;\n\t\tbuf[i++] = priv->dp_port_num;\n\t\tbuf[i++] = arg;\n\t\tbuf[i++] = 0;\n\t}\n\n\t \n\tif ((iflag & IXON) != (old_iflag & IXON) ||\n\t\t\t(cflag & CRTSCTS) != (old_cflag & CRTSCTS)) {\n\t\targ = 0;\n\t\tif (iflag & IXON)\n\t\t\targ |= DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF;\n\t\telse\n\t\t\targ &= ~DIGI_OUTPUT_FLOW_CONTROL_XON_XOFF;\n\n\t\tif (cflag & CRTSCTS)\n\t\t\targ |= DIGI_OUTPUT_FLOW_CONTROL_CTS;\n\t\telse\n\t\t\targ &= ~DIGI_OUTPUT_FLOW_CONTROL_CTS;\n\n\t\tbuf[i++] = DIGI_CMD_SET_OUTPUT_FLOW_CONTROL;\n\t\tbuf[i++] = priv->dp_port_num;\n\t\tbuf[i++] = arg;\n\t\tbuf[i++] = 0;\n\t}\n\n\t \n\tif ((cflag & CREAD) != (old_cflag & CREAD)) {\n\t\tif (cflag & CREAD)\n\t\t\targ = DIGI_ENABLE;\n\t\telse\n\t\t\targ = DIGI_DISABLE;\n\n\t\tbuf[i++] = DIGI_CMD_RECEIVE_ENABLE;\n\t\tbuf[i++] = priv->dp_port_num;\n\t\tbuf[i++] = arg;\n\t\tbuf[i++] = 0;\n\t}\n\tret = digi_write_oob_command(port, buf, i, 1);\n\tif (ret != 0)\n\t\tdev_dbg(dev, \"digi_set_termios: write oob failed, ret=%d\\n\", ret);\n\ttty_encode_baud_rate(tty, baud, baud);\n}\n\n\nstatic int digi_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned char buf[4];\n\n\tbuf[0] = DIGI_CMD_BREAK_CONTROL;\n\tbuf[1] = 2;\t\t\t\t \n\tbuf[2] = break_state ? 1 : 0;\n\tbuf[3] = 0;\t\t\t\t \n\n\treturn digi_write_inb_command(port, buf, 4, 0);\n}\n\n\nstatic int digi_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned int val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tval = priv->dp_modem_signals;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\treturn val;\n}\n\n\nstatic int digi_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned int val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tval = (priv->dp_modem_signals & ~clear) | set;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\treturn digi_set_modem_signals(port, val, 1);\n}\n\n\nstatic int digi_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, int count)\n{\n\n\tint ret, data_len, new_len;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = port->write_urb->transfer_buffer;\n\tunsigned long flags;\n\n\tdev_dbg(&port->dev, \"digi_write: TOP: port=%d, count=%d\\n\",\n\t\tpriv->dp_port_num, count);\n\n\t \n\tcount = min(count, port->bulk_out_size-2);\n\tcount = min(64, count);\n\n\t \n\t \n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\n\t \n\tif (priv->dp_write_urb_in_use) {\n\t\t \n\t\tif (count == 1 && priv->dp_out_buf_len < DIGI_OUT_BUF_SIZE) {\n\t\t\tpriv->dp_out_buf[priv->dp_out_buf_len++] = *buf;\n\t\t\tnew_len = 1;\n\t\t} else {\n\t\t\tnew_len = 0;\n\t\t}\n\t\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\t\treturn new_len;\n\t}\n\n\t \n\t \n\tnew_len = min(count, port->bulk_out_size-2-priv->dp_out_buf_len);\n\tdata_len = new_len + priv->dp_out_buf_len;\n\n\tif (data_len == 0) {\n\t\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\t\treturn 0;\n\t}\n\n\tport->write_urb->transfer_buffer_length = data_len+2;\n\n\t*data++ = DIGI_CMD_SEND_DATA;\n\t*data++ = data_len;\n\n\t \n\tmemcpy(data, priv->dp_out_buf, priv->dp_out_buf_len);\n\tdata += priv->dp_out_buf_len;\n\n\t \n\tmemcpy(data, buf, new_len);\n\n\tret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\tif (ret == 0) {\n\t\tpriv->dp_write_urb_in_use = 1;\n\t\tret = new_len;\n\t\tpriv->dp_out_buf_len = 0;\n\t}\n\n\t \n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\tif (ret < 0)\n\t\tdev_err_console(port,\n\t\t\t\"%s: usb_submit_urb failed, ret=%d, port=%d\\n\",\n\t\t\t__func__, ret, priv->dp_port_num);\n\tdev_dbg(&port->dev, \"digi_write: returning %d\\n\", ret);\n\treturn ret;\n\n}\n\nstatic void digi_write_bulk_callback(struct urb *urb)\n{\n\n\tstruct usb_serial_port *port = urb->context;\n\tstruct usb_serial *serial;\n\tstruct digi_port *priv;\n\tstruct digi_serial *serial_priv;\n\tunsigned long flags;\n\tint ret = 0;\n\tint status = urb->status;\n\tbool wakeup;\n\n\t \n\tif (port == NULL || (priv = usb_get_serial_port_data(port)) == NULL) {\n\t\tpr_err(\"%s: port or port->private is NULL, status=%d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\tserial = port->serial;\n\tif (serial == NULL || (serial_priv = usb_get_serial_data(serial)) == NULL) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s: serial or serial->private is NULL, status=%d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\t \n\tif (priv->dp_port_num == serial_priv->ds_oob_port_num) {\n\t\tdev_dbg(&port->dev, \"digi_write_bulk_callback: oob callback\\n\");\n\t\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\t\tpriv->dp_write_urb_in_use = 0;\n\t\twake_up_interruptible(&priv->write_wait);\n\t\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\twakeup = true;\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tpriv->dp_write_urb_in_use = 0;\n\tif (priv->dp_out_buf_len > 0) {\n\t\t*((unsigned char *)(port->write_urb->transfer_buffer))\n\t\t\t= (unsigned char)DIGI_CMD_SEND_DATA;\n\t\t*((unsigned char *)(port->write_urb->transfer_buffer) + 1)\n\t\t\t= (unsigned char)priv->dp_out_buf_len;\n\t\tport->write_urb->transfer_buffer_length =\n\t\t\t\t\t\tpriv->dp_out_buf_len + 2;\n\t\tmemcpy(port->write_urb->transfer_buffer + 2, priv->dp_out_buf,\n\t\t\tpriv->dp_out_buf_len);\n\t\tret = usb_submit_urb(port->write_urb, GFP_ATOMIC);\n\t\tif (ret == 0) {\n\t\t\tpriv->dp_write_urb_in_use = 1;\n\t\t\tpriv->dp_out_buf_len = 0;\n\t\t\twakeup = false;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tif (ret && ret != -EPERM)\n\t\tdev_err_console(port,\n\t\t\t\"%s: usb_submit_urb failed, ret=%d, port=%d\\n\",\n\t\t\t__func__, ret, priv->dp_port_num);\n\n\tif (wakeup)\n\t\ttty_port_tty_wakeup(&port->port);\n}\n\nstatic unsigned int digi_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int room;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\n\tif (priv->dp_write_urb_in_use)\n\t\troom = 0;\n\telse\n\t\troom = port->bulk_out_size - 2 - priv->dp_out_buf_len;\n\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\tdev_dbg(&port->dev, \"digi_write_room: port=%d, room=%u\\n\", priv->dp_port_num, room);\n\treturn room;\n\n}\n\nstatic unsigned int digi_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int chars;\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\tif (priv->dp_write_urb_in_use)\n\t\tchars = port->bulk_out_size - 2;\n\telse\n\t\tchars = priv->dp_out_buf_len;\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s: port=%d, chars=%d\\n\", __func__,\n\t\t\tpriv->dp_port_num, chars);\n\treturn chars;\n}\n\nstatic void digi_dtr_rts(struct usb_serial_port *port, int on)\n{\n\t \n\tdigi_set_modem_signals(port, on * (TIOCM_DTR | TIOCM_RTS), 1);\n}\n\nstatic int digi_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint ret;\n\tunsigned char buf[32];\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tstruct ktermios not_termios;\n\n\t \n\tif (digi_startup_device(port->serial) != 0)\n\t\treturn -ENXIO;\n\n\t \n\tbuf[0] = DIGI_CMD_READ_INPUT_SIGNALS;\n\tbuf[1] = priv->dp_port_num;\n\tbuf[2] = DIGI_ENABLE;\n\tbuf[3] = 0;\n\n\t \n\tbuf[4] = DIGI_CMD_IFLUSH_FIFO;\n\tbuf[5] = priv->dp_port_num;\n\tbuf[6] = DIGI_FLUSH_TX | DIGI_FLUSH_RX;\n\tbuf[7] = 0;\n\n\tret = digi_write_oob_command(port, buf, 8, 1);\n\tif (ret != 0)\n\t\tdev_dbg(&port->dev, \"digi_open: write oob failed, ret=%d\\n\", ret);\n\n\t \n\tif (tty) {\n\t\tnot_termios.c_cflag = ~tty->termios.c_cflag;\n\t\tnot_termios.c_iflag = ~tty->termios.c_iflag;\n\t\tdigi_set_termios(tty, port, &not_termios);\n\t}\n\treturn 0;\n}\n\n\nstatic void digi_close(struct usb_serial_port *port)\n{\n\tDEFINE_WAIT(wait);\n\tint ret;\n\tunsigned char buf[32];\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\n\tmutex_lock(&port->serial->disc_mutex);\n\t \n\tif (port->serial->disconnected)\n\t\tgoto exit;\n\n\t \n\tdigi_transmit_idle(port, DIGI_CLOSE_TIMEOUT);\n\n\t \n\tbuf[0] = DIGI_CMD_SET_INPUT_FLOW_CONTROL;\n\tbuf[1] = priv->dp_port_num;\n\tbuf[2] = DIGI_DISABLE;\n\tbuf[3] = 0;\n\n\t \n\tbuf[4] = DIGI_CMD_SET_OUTPUT_FLOW_CONTROL;\n\tbuf[5] = priv->dp_port_num;\n\tbuf[6] = DIGI_DISABLE;\n\tbuf[7] = 0;\n\n\t \n\tbuf[8] = DIGI_CMD_READ_INPUT_SIGNALS;\n\tbuf[9] = priv->dp_port_num;\n\tbuf[10] = DIGI_DISABLE;\n\tbuf[11] = 0;\n\n\t \n\tbuf[12] = DIGI_CMD_RECEIVE_ENABLE;\n\tbuf[13] = priv->dp_port_num;\n\tbuf[14] = DIGI_DISABLE;\n\tbuf[15] = 0;\n\n\t \n\tbuf[16] = DIGI_CMD_IFLUSH_FIFO;\n\tbuf[17] = priv->dp_port_num;\n\tbuf[18] = DIGI_FLUSH_TX | DIGI_FLUSH_RX;\n\tbuf[19] = 0;\n\n\tret = digi_write_oob_command(port, buf, 20, 0);\n\tif (ret != 0)\n\t\tdev_dbg(&port->dev, \"digi_close: write oob failed, ret=%d\\n\",\n\t\t\t\t\t\t\t\t\tret);\n\t \n\tprepare_to_wait(&priv->dp_flush_wait, &wait,\n\t\t\tTASK_INTERRUPTIBLE);\n\tschedule_timeout(DIGI_CLOSE_TIMEOUT);\n\tfinish_wait(&priv->dp_flush_wait, &wait);\n\n\t \n\tusb_kill_urb(port->write_urb);\nexit:\n\tspin_lock_irq(&priv->dp_port_lock);\n\tpriv->dp_write_urb_in_use = 0;\n\twake_up_interruptible(&priv->dp_close_wait);\n\tspin_unlock_irq(&priv->dp_port_lock);\n\tmutex_unlock(&port->serial->disc_mutex);\n}\n\n\n \n\nstatic int digi_startup_device(struct usb_serial *serial)\n{\n\tint i, ret = 0;\n\tstruct digi_serial *serial_priv = usb_get_serial_data(serial);\n\tstruct usb_serial_port *port;\n\n\t \n\tspin_lock(&serial_priv->ds_serial_lock);\n\tif (serial_priv->ds_device_started) {\n\t\tspin_unlock(&serial_priv->ds_serial_lock);\n\t\treturn 0;\n\t}\n\tserial_priv->ds_device_started = 1;\n\tspin_unlock(&serial_priv->ds_serial_lock);\n\n\t \n\t \n\tfor (i = 0; i < serial->type->num_ports + 1; i++) {\n\t\tport = serial->port[i];\n\t\tret = usb_submit_urb(port->read_urb, GFP_KERNEL);\n\t\tif (ret != 0) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s: usb_submit_urb failed, ret=%d, port=%d\\n\",\n\t\t\t\t__func__, ret, i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int digi_port_init(struct usb_serial_port *port, unsigned port_num)\n{\n\tstruct digi_port *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->dp_port_lock);\n\tpriv->dp_port_num = port_num;\n\tinit_waitqueue_head(&priv->dp_transmit_idle_wait);\n\tinit_waitqueue_head(&priv->dp_flush_wait);\n\tinit_waitqueue_head(&priv->dp_close_wait);\n\tinit_waitqueue_head(&priv->write_wait);\n\tpriv->dp_port = port;\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic int digi_startup(struct usb_serial *serial)\n{\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\n\tserial_priv = kzalloc(sizeof(*serial_priv), GFP_KERNEL);\n\tif (!serial_priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&serial_priv->ds_serial_lock);\n\tserial_priv->ds_oob_port_num = serial->type->num_ports;\n\tserial_priv->ds_oob_port = serial->port[serial_priv->ds_oob_port_num];\n\n\tret = digi_port_init(serial_priv->ds_oob_port,\n\t\t\t\t\t\tserial_priv->ds_oob_port_num);\n\tif (ret) {\n\t\tkfree(serial_priv);\n\t\treturn ret;\n\t}\n\n\tusb_set_serial_data(serial, serial_priv);\n\n\treturn 0;\n}\n\n\nstatic void digi_disconnect(struct usb_serial *serial)\n{\n\tint i;\n\n\t \n\tfor (i = 0; i < serial->type->num_ports + 1; i++) {\n\t\tusb_kill_urb(serial->port[i]->read_urb);\n\t\tusb_kill_urb(serial->port[i]->write_urb);\n\t}\n}\n\n\nstatic void digi_release(struct usb_serial *serial)\n{\n\tstruct digi_serial *serial_priv;\n\tstruct digi_port *priv;\n\n\tserial_priv = usb_get_serial_data(serial);\n\n\tpriv = usb_get_serial_port_data(serial_priv->ds_oob_port);\n\tkfree(priv);\n\n\tkfree(serial_priv);\n}\n\nstatic int digi_port_probe(struct usb_serial_port *port)\n{\n\treturn digi_port_init(port, port->port_number);\n}\n\nstatic void digi_port_remove(struct usb_serial_port *port)\n{\n\tstruct digi_port *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic void digi_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct digi_port *priv;\n\tstruct digi_serial *serial_priv;\n\tint ret;\n\tint status = urb->status;\n\n\t \n\tif (port == NULL)\n\t\treturn;\n\tpriv = usb_get_serial_port_data(port);\n\tif (priv == NULL) {\n\t\tdev_err(&port->dev, \"%s: port->private is NULL, status=%d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\tif (port->serial == NULL ||\n\t\t(serial_priv = usb_get_serial_data(port->serial)) == NULL) {\n\t\tdev_err(&port->dev, \"%s: serial is bad or serial->private \"\n\t\t\t\"is NULL, status=%d\\n\", __func__, status);\n\t\treturn;\n\t}\n\n\t \n\tif (status) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s: nonzero read bulk status: status=%d, port=%d\\n\",\n\t\t\t__func__, status, priv->dp_port_num);\n\t\treturn;\n\t}\n\n\t \n\tif (priv->dp_port_num == serial_priv->ds_oob_port_num) {\n\t\tif (digi_read_oob_callback(urb) != 0)\n\t\t\treturn;\n\t} else {\n\t\tif (digi_read_inb_callback(urb) != 0)\n\t\t\treturn;\n\t}\n\n\t \n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret != 0 && ret != -EPERM) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s: failed resubmitting urb, ret=%d, port=%d\\n\",\n\t\t\t__func__, ret, priv->dp_port_num);\n\t}\n\n}\n\n \n\nstatic int digi_read_inb_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct digi_port *priv = usb_get_serial_port_data(port);\n\tunsigned char *buf = urb->transfer_buffer;\n\tunsigned long flags;\n\tint opcode;\n\tint len;\n\tint port_status;\n\tunsigned char *data;\n\tint tty_flag, throttled;\n\n\t \n\tif (urb->actual_length < 2) {\n\t\tdev_warn(&port->dev, \"short packet received\\n\");\n\t\treturn -1;\n\t}\n\n\topcode = buf[0];\n\tlen = buf[1];\n\n\tif (urb->actual_length != len + 2) {\n\t\tdev_err(&port->dev, \"malformed packet received: port=%d, opcode=%d, len=%d, actual_length=%u\\n\",\n\t\t\tpriv->dp_port_num, opcode, len, urb->actual_length);\n\t\treturn -1;\n\t}\n\n\tif (opcode == DIGI_CMD_RECEIVE_DATA && len < 1) {\n\t\tdev_err(&port->dev, \"malformed data packet received\\n\");\n\t\treturn -1;\n\t}\n\n\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\n\t \n\t \n\tthrottled = priv->dp_throttled;\n\tif (throttled)\n\t\tpriv->dp_throttle_restart = 1;\n\n\t \n\tif (opcode == DIGI_CMD_RECEIVE_DATA) {\n\t\tport_status = buf[2];\n\t\tdata = &buf[3];\n\n\t\t \n\t\ttty_flag = 0;\n\n\t\t \n\t\tif (port_status & DIGI_OVERRUN_ERROR)\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\n\t\t \n\t\t \n\t\tif (port_status & DIGI_BREAK_ERROR)\n\t\t\ttty_flag = TTY_BREAK;\n\t\telse if (port_status & DIGI_PARITY_ERROR)\n\t\t\ttty_flag = TTY_PARITY;\n\t\telse if (port_status & DIGI_FRAMING_ERROR)\n\t\t\ttty_flag = TTY_FRAME;\n\n\t\t \n\t\t--len;\n\t\tif (len > 0) {\n\t\t\ttty_insert_flip_string_fixed_flag(&port->port, data,\n\t\t\t\t\ttty_flag, len);\n\t\t\ttty_flip_buffer_push(&port->port);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\tif (opcode == DIGI_CMD_RECEIVE_DISABLE)\n\t\tdev_dbg(&port->dev, \"%s: got RECEIVE_DISABLE\\n\", __func__);\n\telse if (opcode != DIGI_CMD_RECEIVE_DATA)\n\t\tdev_dbg(&port->dev, \"%s: unknown opcode: %d\\n\", __func__, opcode);\n\n\treturn throttled ? 1 : 0;\n\n}\n\n\n \n\nstatic int digi_read_oob_callback(struct urb *urb)\n{\n\n\tstruct usb_serial_port *port = urb->context;\n\tstruct usb_serial *serial = port->serial;\n\tstruct tty_struct *tty;\n\tstruct digi_port *priv;\n\tunsigned char *buf = urb->transfer_buffer;\n\tint opcode, line, status, val;\n\tunsigned long flags;\n\tint i;\n\tunsigned int rts;\n\n\tif (urb->actual_length < 4)\n\t\treturn -1;\n\n\t \n\tfor (i = 0; i < urb->actual_length - 3; i += 4) {\n\t\topcode = buf[i];\n\t\tline = buf[i + 1];\n\t\tstatus = buf[i + 2];\n\t\tval = buf[i + 3];\n\n\t\tdev_dbg(&port->dev, \"digi_read_oob_callback: opcode=%d, line=%d, status=%d, val=%d\\n\",\n\t\t\topcode, line, status, val);\n\n\t\tif (status != 0 || line >= serial->type->num_ports)\n\t\t\tcontinue;\n\n\t\tport = serial->port[line];\n\n\t\tpriv = usb_get_serial_port_data(port);\n\t\tif (priv == NULL)\n\t\t\treturn -1;\n\n\t\ttty = tty_port_tty_get(&port->port);\n\n\t\trts = 0;\n\t\tif (tty)\n\t\t\trts = C_CRTSCTS(tty);\n\n\t\tif (tty && opcode == DIGI_CMD_READ_INPUT_SIGNALS) {\n\t\t\tbool wakeup = false;\n\n\t\t\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\t\t\t \n\t\t\tif (val & DIGI_READ_INPUT_SIGNALS_CTS) {\n\t\t\t\tpriv->dp_modem_signals |= TIOCM_CTS;\n\t\t\t\tif (rts)\n\t\t\t\t\twakeup = true;\n\t\t\t} else {\n\t\t\t\tpriv->dp_modem_signals &= ~TIOCM_CTS;\n\t\t\t\t \n\t\t\t}\n\t\t\tif (val & DIGI_READ_INPUT_SIGNALS_DSR)\n\t\t\t\tpriv->dp_modem_signals |= TIOCM_DSR;\n\t\t\telse\n\t\t\t\tpriv->dp_modem_signals &= ~TIOCM_DSR;\n\t\t\tif (val & DIGI_READ_INPUT_SIGNALS_RI)\n\t\t\t\tpriv->dp_modem_signals |= TIOCM_RI;\n\t\t\telse\n\t\t\t\tpriv->dp_modem_signals &= ~TIOCM_RI;\n\t\t\tif (val & DIGI_READ_INPUT_SIGNALS_DCD)\n\t\t\t\tpriv->dp_modem_signals |= TIOCM_CD;\n\t\t\telse\n\t\t\t\tpriv->dp_modem_signals &= ~TIOCM_CD;\n\n\t\t\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\n\t\t\tif (wakeup)\n\t\t\t\ttty_port_tty_wakeup(&port->port);\n\t\t} else if (opcode == DIGI_CMD_TRANSMIT_IDLE) {\n\t\t\tspin_lock_irqsave(&priv->dp_port_lock, flags);\n\t\t\tpriv->dp_transmit_idle = 1;\n\t\t\twake_up_interruptible(&priv->dp_transmit_idle_wait);\n\t\t\tspin_unlock_irqrestore(&priv->dp_port_lock, flags);\n\t\t} else if (opcode == DIGI_CMD_IFLUSH_FIFO) {\n\t\t\twake_up_interruptible(&priv->dp_flush_wait);\n\t\t}\n\t\ttty_kref_put(tty);\n\t}\n\treturn 0;\n\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}