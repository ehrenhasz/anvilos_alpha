{
  "module_name": "generic.c",
  "hash_id": "e296ae34a5d56bf252633b75b8ffce8f89d850052618fc309107540b8c01ac0d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/generic.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/sysrq.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n#include <linux/kfifo.h>\n#include <linux/serial.h>\n\n#ifdef CONFIG_USB_SERIAL_GENERIC\n\nstatic __u16 vendor  = 0x05f9;\nstatic __u16 product = 0xffff;\n\nmodule_param(vendor, ushort, 0);\nMODULE_PARM_DESC(vendor, \"User specified USB idVendor\");\n\nmodule_param(product, ushort, 0);\nMODULE_PARM_DESC(product, \"User specified USB idProduct\");\n\nstatic struct usb_device_id generic_device_ids[2];  \n\nstatic int usb_serial_generic_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->interface->dev;\n\n\tdev_info(dev, \"The \\\"generic\\\" usb-serial driver is only for testing and one-off prototypes.\\n\");\n\tdev_info(dev, \"Tell linux-usb@vger.kernel.org to add your device to a proper driver.\\n\");\n\n\treturn 0;\n}\n\nstatic int usb_serial_generic_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tint num_ports;\n\n\tnum_ports = max(epds->num_bulk_in, epds->num_bulk_out);\n\n\tif (num_ports == 0) {\n\t\tdev_err(dev, \"device has no bulk endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn num_ports;\n}\n\nstatic struct usb_serial_driver usb_serial_generic_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"generic\",\n\t},\n\t.id_table =\t\tgeneric_device_ids,\n\t.probe =\t\tusb_serial_generic_probe,\n\t.calc_num_ports =\tusb_serial_generic_calc_num_ports,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.resume =\t\tusb_serial_generic_resume,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&usb_serial_generic_device, NULL\n};\n\n#endif\n\nint usb_serial_generic_register(void)\n{\n\tint retval = 0;\n\n#ifdef CONFIG_USB_SERIAL_GENERIC\n\tgeneric_device_ids[0].idVendor = vendor;\n\tgeneric_device_ids[0].idProduct = product;\n\tgeneric_device_ids[0].match_flags =\n\t\tUSB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_PRODUCT;\n\n\tretval = usb_serial_register_drivers(serial_drivers,\n\t\t\t\"usbserial_generic\", generic_device_ids);\n#endif\n\treturn retval;\n}\n\nvoid usb_serial_generic_deregister(void)\n{\n#ifdef CONFIG_USB_SERIAL_GENERIC\n\tusb_serial_deregister_drivers(serial_drivers);\n#endif\n}\n\nint usb_serial_generic_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result = 0;\n\n\tclear_bit(USB_SERIAL_THROTTLED, &port->flags);\n\n\tif (port->bulk_in_size)\n\t\tresult = usb_serial_generic_submit_read_urbs(port, GFP_KERNEL);\n\n\treturn result;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_open);\n\nvoid usb_serial_generic_close(struct usb_serial_port *port)\n{\n\tunsigned long flags;\n\tint i;\n\n\tif (port->bulk_out_size) {\n\t\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i)\n\t\t\tusb_kill_urb(port->write_urbs[i]);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tkfifo_reset_out(&port->write_fifo);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t}\n\tif (port->bulk_in_size) {\n\t\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i)\n\t\t\tusb_kill_urb(port->read_urbs[i]);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_close);\n\nint usb_serial_generic_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\treturn kfifo_out_locked(&port->write_fifo, dest, size, &port->lock);\n}\n\n \nint usb_serial_generic_write_start(struct usb_serial_port *port,\n\t\t\t\t\t\t\tgfp_t mem_flags)\n{\n\tstruct urb *urb;\n\tint count, result;\n\tunsigned long flags;\n\tint i;\n\n\tif (test_and_set_bit_lock(USB_SERIAL_WRITE_BUSY, &port->flags))\n\t\treturn 0;\nretry:\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (!port->write_urbs_free || !kfifo_len(&port->write_fifo)) {\n\t\tclear_bit_unlock(USB_SERIAL_WRITE_BUSY, &port->flags);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn 0;\n\t}\n\ti = (int)find_first_bit(&port->write_urbs_free,\n\t\t\t\t\t\tARRAY_SIZE(port->write_urbs));\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\turb = port->write_urbs[i];\n\tcount = port->serial->type->prepare_write_buffer(port,\n\t\t\t\t\t\turb->transfer_buffer,\n\t\t\t\t\t\tport->bulk_out_size);\n\turb->transfer_buffer_length = count;\n\tusb_serial_debug_data(&port->dev, __func__, count, urb->transfer_buffer);\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->tx_bytes += count;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tclear_bit(i, &port->write_urbs_free);\n\tresult = usb_submit_urb(urb, mem_flags);\n\tif (result) {\n\t\tdev_err_console(port, \"%s - error submitting urb: %d\\n\",\n\t\t\t\t\t\t__func__, result);\n\t\tset_bit(i, &port->write_urbs_free);\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->tx_bytes -= count;\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tclear_bit_unlock(USB_SERIAL_WRITE_BUSY, &port->flags);\n\t\treturn result;\n\t}\n\n\tgoto retry;\t \n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_write_start);\n\n \nint usb_serial_generic_write(struct tty_struct *tty,\n\tstruct usb_serial_port *port, const unsigned char *buf, int count)\n{\n\tint result;\n\n\tif (!port->bulk_out_size)\n\t\treturn -ENODEV;\n\n\tif (!count)\n\t\treturn 0;\n\n\tcount = kfifo_in_locked(&port->write_fifo, buf, count, &port->lock);\n\tresult = usb_serial_generic_write_start(port, GFP_ATOMIC);\n\tif (result)\n\t\treturn result;\n\n\treturn count;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_write);\n\nunsigned int usb_serial_generic_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int room;\n\n\tif (!port->bulk_out_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n}\n\nunsigned int usb_serial_generic_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned long flags;\n\tunsigned int chars;\n\n\tif (!port->bulk_out_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tchars = kfifo_len(&port->write_fifo) + port->tx_bytes;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, chars);\n\treturn chars;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_chars_in_buffer);\n\nvoid usb_serial_generic_wait_until_sent(struct tty_struct *tty, long timeout)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int bps;\n\tunsigned long period;\n\tunsigned long expire;\n\n\tbps = tty_get_baud_rate(tty);\n\tif (!bps)\n\t\tbps = 9600;\t \n\t \n\tperiod = max_t(unsigned long, (10 * HZ / bps), 1);\n\tif (timeout)\n\t\tperiod = min_t(unsigned long, period, timeout);\n\n\tdev_dbg(&port->dev, \"%s - timeout = %u ms, period = %u ms\\n\",\n\t\t\t\t\t__func__, jiffies_to_msecs(timeout),\n\t\t\t\t\tjiffies_to_msecs(period));\n\texpire = jiffies + timeout;\n\twhile (!port->serial->type->tx_empty(port)) {\n\t\tschedule_timeout_interruptible(period);\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\t\tif (timeout && time_after(jiffies, expire))\n\t\t\tbreak;\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_wait_until_sent);\n\nstatic int usb_serial_generic_submit_read_urb(struct usb_serial_port *port,\n\t\t\t\t\t\tint index, gfp_t mem_flags)\n{\n\tint res;\n\n\tif (!test_and_clear_bit(index, &port->read_urbs_free))\n\t\treturn 0;\n\n\tdev_dbg(&port->dev, \"%s - urb %d\\n\", __func__, index);\n\n\tres = usb_submit_urb(port->read_urbs[index], mem_flags);\n\tif (res) {\n\t\tif (res != -EPERM && res != -ENODEV) {\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\t\"%s - usb_submit_urb failed: %d\\n\",\n\t\t\t\t\t__func__, res);\n\t\t}\n\t\tset_bit(index, &port->read_urbs_free);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nint usb_serial_generic_submit_read_urbs(struct usb_serial_port *port,\n\t\t\t\t\tgfp_t mem_flags)\n{\n\tint res;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {\n\t\tres = usb_serial_generic_submit_read_urb(port, i, mem_flags);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\treturn 0;\nerr:\n\tfor (; i >= 0; --i)\n\t\tusb_kill_urb(port->read_urbs[i]);\n\n\treturn res;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_submit_read_urbs);\n\nvoid usb_serial_generic_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tchar *ch = urb->transfer_buffer;\n\tint i;\n\n\tif (!urb->actual_length)\n\t\treturn;\n\t \n\tif (port->sysrq) {\n\t\tfor (i = 0; i < urb->actual_length; i++, ch++) {\n\t\t\tif (!usb_serial_handle_sysrq_char(port, *ch))\n\t\t\t\ttty_insert_flip_char(&port->port, *ch, TTY_NORMAL);\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string(&port->port, ch, urb->actual_length);\n\t}\n\ttty_flip_buffer_push(&port->port);\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_process_read_urb);\n\nvoid usb_serial_generic_read_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tbool stopped = false;\n\tint status = urb->status;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->read_urbs); ++i) {\n\t\tif (urb == port->read_urbs[i])\n\t\t\tbreak;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - urb %d, len %d\\n\", __func__, i,\n\t\t\t\t\t\t\turb->actual_length);\n\tswitch (status) {\n\tcase 0:\n\t\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\n\t\t\t\t\t\t\tdata);\n\t\tport->serial->type->process_read_urb(urb);\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&port->dev, \"%s - urb stopped: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tstopped = true;\n\t\tbreak;\n\tcase -EPIPE:\n\t\tdev_err(&port->dev, \"%s - urb stopped: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tstopped = true;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tbreak;\n\t}\n\n\t \n\tsmp_mb__before_atomic();\n\tset_bit(i, &port->read_urbs_free);\n\t \n\tsmp_mb__after_atomic();\n\n\tif (stopped)\n\t\treturn;\n\n\tif (test_bit(USB_SERIAL_THROTTLED, &port->flags))\n\t\treturn;\n\n\tusb_serial_generic_submit_read_urb(port, i, GFP_ATOMIC);\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_read_bulk_callback);\n\nvoid usb_serial_generic_write_bulk_callback(struct urb *urb)\n{\n\tunsigned long flags;\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(port->write_urbs); ++i) {\n\t\tif (port->write_urbs[i] == urb)\n\t\t\tbreak;\n\t}\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->tx_bytes -= urb->transfer_buffer_length;\n\tset_bit(i, &port->write_urbs_free);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&port->dev, \"%s - urb stopped: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn;\n\tcase -EPIPE:\n\t\tdev_err_console(port, \"%s - urb stopped: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_err_console(port, \"%s - nonzero urb status: %d\\n\",\n\t\t\t\t\t\t\t__func__, status);\n\t\tbreak;\n\t}\n\n\tusb_serial_generic_write_start(port, GFP_ATOMIC);\n\tusb_serial_port_softint(port);\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_write_bulk_callback);\n\nvoid usb_serial_generic_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tset_bit(USB_SERIAL_THROTTLED, &port->flags);\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_throttle);\n\nvoid usb_serial_generic_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\tclear_bit(USB_SERIAL_THROTTLED, &port->flags);\n\n\t \n\tsmp_mb__after_atomic();\n\n\tusb_serial_generic_submit_read_urbs(port, GFP_KERNEL);\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_unthrottle);\n\nstatic bool usb_serial_generic_msr_changed(struct tty_struct *tty,\n\t\t\t\tunsigned long arg, struct async_icount *cprev)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\tbool ret;\n\n\t \n\tif (!tty_port_initialized(&port->port))\n\t\treturn true;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tcnow = port->icount;\t\t\t\t \n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret =\t((arg & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||\n\t\t((arg & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||\n\t\t((arg & TIOCM_CD)  && (cnow.dcd != cprev->dcd)) ||\n\t\t((arg & TIOCM_CTS) && (cnow.cts != cprev->cts));\n\n\t*cprev = cnow;\n\n\treturn ret;\n}\n\nint usb_serial_generic_tiocmiwait(struct tty_struct *tty, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\tint ret;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tcnow = port->icount;\t\t\t\t \n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tret = wait_event_interruptible(port->port.delta_msr_wait,\n\t\t\tusb_serial_generic_msr_changed(tty, arg, &cnow));\n\tif (!ret && !tty_port_initialized(&port->port))\n\t\tret = -EIO;\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_tiocmiwait);\n\nint usb_serial_generic_get_icount(struct tty_struct *tty,\n\t\t\t\t\tstruct serial_icounter_struct *icount)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct async_icount cnow;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tcnow = port->icount;\t\t\t\t \n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\ticount->cts = cnow.cts;\n\ticount->dsr = cnow.dsr;\n\ticount->rng = cnow.rng;\n\ticount->dcd = cnow.dcd;\n\ticount->tx = cnow.tx;\n\ticount->rx = cnow.rx;\n\ticount->frame = cnow.frame;\n\ticount->parity = cnow.parity;\n\ticount->overrun = cnow.overrun;\n\ticount->brk = cnow.brk;\n\ticount->buf_overrun = cnow.buf_overrun;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_get_icount);\n\n#if defined(CONFIG_USB_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)\nint usb_serial_handle_sysrq_char(struct usb_serial_port *port, unsigned int ch)\n{\n\tif (port->sysrq) {\n\t\tif (ch && time_before(jiffies, port->sysrq)) {\n\t\t\thandle_sysrq(ch);\n\t\t\tport->sysrq = 0;\n\t\t\treturn 1;\n\t\t}\n\t\tport->sysrq = 0;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_serial_handle_sysrq_char);\n\nint usb_serial_handle_break(struct usb_serial_port *port)\n{\n\tif (!port->port.console)\n\t\treturn 0;\n\n\tif (!port->sysrq) {\n\t\tport->sysrq = jiffies + HZ*5;\n\t\treturn 1;\n\t}\n\tport->sysrq = 0;\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_serial_handle_break);\n#endif\n\n \nvoid usb_serial_handle_dcd_change(struct usb_serial_port *port,\n\t\t\t\tstruct tty_struct *tty, unsigned int status)\n{\n\tdev_dbg(&port->dev, \"%s - status %d\\n\", __func__, status);\n\n\tif (tty) {\n\t\tstruct tty_ldisc *ld = tty_ldisc_ref(tty);\n\n\t\tif (ld) {\n\t\t\tif (ld->ops->dcd_change)\n\t\t\t\tld->ops->dcd_change(tty, status);\n\t\t\ttty_ldisc_deref(ld);\n\t\t}\n\t}\n\n\tif (status)\n\t\twake_up_interruptible(&port->port.open_wait);\n\telse if (tty && !C_CLOCAL(tty))\n\t\ttty_hangup(tty);\n}\nEXPORT_SYMBOL_GPL(usb_serial_handle_dcd_change);\n\nint usb_serial_generic_resume(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tint i, c = 0, r;\n\n\tfor (i = 0; i < serial->num_ports; i++) {\n\t\tport = serial->port[i];\n\t\tif (!tty_port_initialized(&port->port))\n\t\t\tcontinue;\n\n\t\tif (port->bulk_in_size) {\n\t\t\tr = usb_serial_generic_submit_read_urbs(port,\n\t\t\t\t\t\t\t\tGFP_NOIO);\n\t\t\tif (r < 0)\n\t\t\t\tc++;\n\t\t}\n\n\t\tif (port->bulk_out_size) {\n\t\t\tr = usb_serial_generic_write_start(port, GFP_NOIO);\n\t\t\tif (r < 0)\n\t\t\t\tc++;\n\t\t}\n\t}\n\n\treturn c ? -EIO : 0;\n}\nEXPORT_SYMBOL_GPL(usb_serial_generic_resume);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}