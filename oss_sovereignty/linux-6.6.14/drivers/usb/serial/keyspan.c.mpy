{
  "module_name": "keyspan.c",
  "hash_id": "7db9a750db9f2d60fee226dd5158c0c0ae015a9a37872a05a93df7dd5cdb7f70",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/keyspan.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n\n#define DRIVER_AUTHOR \"Hugh Blemings <hugh@misc.nu\"\n#define DRIVER_DESC \"Keyspan USB to Serial Converter Driver\"\n\nstatic void keyspan_send_setup(struct usb_serial_port *port, int reset_port);\n\nstatic int keyspan_usa19_calc_baud(struct usb_serial_port *port,\n\t\t\t\t   u32 baud_rate, u32 baudclk,\n\t\t\t\t   u8 *rate_hi, u8 *rate_low,\n\t\t\t\t   u8 *prescaler, int portnum);\nstatic int keyspan_usa19w_calc_baud(struct usb_serial_port *port,\n\t\t\t\t    u32 baud_rate, u32 baudclk,\n\t\t\t\t    u8 *rate_hi, u8 *rate_low,\n\t\t\t\t    u8 *prescaler, int portnum);\nstatic int keyspan_usa28_calc_baud(struct usb_serial_port *port,\n\t\t\t\t   u32 baud_rate, u32 baudclk,\n\t\t\t\t   u8 *rate_hi, u8 *rate_low,\n\t\t\t\t   u8 *prescaler, int portnum);\nstatic int keyspan_usa19hs_calc_baud(struct usb_serial_port *port,\n\t\t\t\t     u32 baud_rate, u32 baudclk,\n\t\t\t\t     u8 *rate_hi, u8 *rate_low,\n\t\t\t\t     u8 *prescaler, int portnum);\n\nstatic int keyspan_usa28_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port);\nstatic int keyspan_usa26_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port);\nstatic int keyspan_usa49_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port);\nstatic int keyspan_usa90_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port);\nstatic int keyspan_usa67_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port);\n\n \n#define KEYSPAN_INVALID_BAUD_RATE\t\t(-1)\n#define KEYSPAN_BAUD_RATE_OK\t\t\t(0)\n#define KEYSPAN_USA18X_BAUDCLK\t\t\t(12000000L)\t \n#define KEYSPAN_USA19_BAUDCLK\t\t\t(12000000L)\n#define KEYSPAN_USA19W_BAUDCLK\t\t\t(24000000L)\n#define KEYSPAN_USA19HS_BAUDCLK\t\t\t(14769231L)\n#define KEYSPAN_USA28_BAUDCLK\t\t\t(1843200L)\n#define KEYSPAN_USA28X_BAUDCLK\t\t\t(12000000L)\n#define KEYSPAN_USA49W_BAUDCLK\t\t\t(48000000L)\n\n \n#define KEYSPAN_MAX_NUM_PORTS\t\t\t(4)\n#define KEYSPAN_MAX_FLIPS\t\t\t(2)\n\n \n#define KEYSPAN_VENDOR_ID\t\t\t(0x06cd)\n\n \n#define keyspan_usa18x_pre_product_id\t\t0x0105\n#define keyspan_usa19_pre_product_id\t\t0x0103\n#define keyspan_usa19qi_pre_product_id\t\t0x010b\n#define keyspan_mpr_pre_product_id\t\t0x011b\n#define keyspan_usa19qw_pre_product_id\t\t0x0118\n#define keyspan_usa19w_pre_product_id\t\t0x0106\n#define keyspan_usa28_pre_product_id\t\t0x0101\n#define keyspan_usa28x_pre_product_id\t\t0x0102\n#define keyspan_usa28xa_pre_product_id\t\t0x0114\n#define keyspan_usa28xb_pre_product_id\t\t0x0113\n#define keyspan_usa49w_pre_product_id\t\t0x0109\n#define keyspan_usa49wlc_pre_product_id\t\t0x011a\n\n \n#define keyspan_usa18x_product_id\t\t0x0112\n#define keyspan_usa19_product_id\t\t0x0107\n#define keyspan_usa19qi_product_id\t\t0x010c\n#define keyspan_usa19hs_product_id\t\t0x0121\n#define keyspan_mpr_product_id\t\t\t0x011c\n#define keyspan_usa19qw_product_id\t\t0x0119\n#define keyspan_usa19w_product_id\t\t0x0108\n#define keyspan_usa28_product_id\t\t0x010f\n#define keyspan_usa28x_product_id\t\t0x0110\n#define keyspan_usa28xa_product_id\t\t0x0115\n#define keyspan_usa28xb_product_id\t\t0x0110\n#define keyspan_usa28xg_product_id\t\t0x0135\n#define keyspan_usa49w_product_id\t\t0x010a\n#define keyspan_usa49wlc_product_id\t\t0x012a\n#define keyspan_usa49wg_product_id\t\t0x0131\n\nstruct keyspan_device_details {\n\t \n\tint\tproduct_id;\n\n\tenum\t{msg_usa26, msg_usa28, msg_usa49, msg_usa90, msg_usa67} msg_format;\n\n\t\t \n\tint\tnum_ports;\n\n\t\t \n\tint\tindat_endp_flip;\n\n\t\t \n\tint\toutdat_endp_flip;\n\n\t\t \n\tint\tindat_endpoints[KEYSPAN_MAX_NUM_PORTS];\n\n\t\t \n\tint\toutdat_endpoints[KEYSPAN_MAX_NUM_PORTS];\n\n\t\t \n\tint\tinack_endpoints[KEYSPAN_MAX_NUM_PORTS];\n\n\t\t \n\tint\toutcont_endpoints[KEYSPAN_MAX_NUM_PORTS];\n\n\t\t \n\tint\tinstat_endpoint;\n\n\t\t \n\tint\tindat_endpoint;\n\n\t\t \n\tint\tglocont_endpoint;\n\n\tint\t(*calculate_baud_rate)(struct usb_serial_port *port,\n\t\t\t\t       u32 baud_rate, u32 baudclk,\n\t\t\t\t       u8 *rate_hi, u8 *rate_low, u8 *prescaler,\n\t\t\t\t       int portnum);\n\tu32\tbaudclk;\n};\n\n \n\nstatic const struct keyspan_device_details usa18x_device_details = {\n\t.product_id\t\t= keyspan_usa18x_product_id,\n\t.msg_format\t\t= msg_usa26,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x85},\n\t.outcont_endpoints\t= {0x05},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA18X_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa19_device_details = {\n\t.product_id\t\t= keyspan_usa19_product_id,\n\t.msg_format\t\t= msg_usa28,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 1,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x83},\n\t.outcont_endpoints\t= {0x03},\n\t.instat_endpoint\t= 0x84,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= -1,\n\t.calculate_baud_rate\t= keyspan_usa19_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa19qi_device_details = {\n\t.product_id\t\t= keyspan_usa19qi_product_id,\n\t.msg_format\t\t= msg_usa28,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 1,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x83},\n\t.outcont_endpoints\t= {0x03},\n\t.instat_endpoint\t= 0x84,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= -1,\n\t.calculate_baud_rate\t= keyspan_usa28_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details mpr_device_details = {\n\t.product_id\t\t= keyspan_mpr_product_id,\n\t.msg_format\t\t= msg_usa28,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 1,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x83},\n\t.outcont_endpoints\t= {0x03},\n\t.instat_endpoint\t= 0x84,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= -1,\n\t.calculate_baud_rate\t= keyspan_usa28_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa19qw_device_details = {\n\t.product_id\t\t= keyspan_usa19qw_product_id,\n\t.msg_format\t\t= msg_usa26,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x85},\n\t.outcont_endpoints\t= {0x05},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19W_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa19w_device_details = {\n\t.product_id\t\t= keyspan_usa19w_product_id,\n\t.msg_format\t\t= msg_usa26,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {0x85},\n\t.outcont_endpoints\t= {0x05},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19W_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa19hs_device_details = {\n\t.product_id\t\t= keyspan_usa19hs_product_id,\n\t.msg_format\t\t= msg_usa90,\n\t.num_ports\t\t= 1,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 0,\n\t.indat_endpoints\t= {0x81},\n\t.outdat_endpoints\t= {0x01},\n\t.inack_endpoints\t= {-1},\n\t.outcont_endpoints\t= {0x02},\n\t.instat_endpoint\t= 0x82,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= -1,\n\t.calculate_baud_rate\t= keyspan_usa19hs_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19HS_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa28_device_details = {\n\t.product_id\t\t= keyspan_usa28_product_id,\n\t.msg_format\t\t= msg_usa28,\n\t.num_ports\t\t= 2,\n\t.indat_endp_flip\t= 1,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81, 0x83},\n\t.outdat_endpoints\t= {0x01, 0x03},\n\t.inack_endpoints\t= {0x85, 0x86},\n\t.outcont_endpoints\t= {0x05, 0x06},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa28_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA28_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa28x_device_details = {\n\t.product_id\t\t= keyspan_usa28x_product_id,\n\t.msg_format\t\t= msg_usa26,\n\t.num_ports\t\t= 2,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81, 0x83},\n\t.outdat_endpoints\t= {0x01, 0x03},\n\t.inack_endpoints\t= {0x85, 0x86},\n\t.outcont_endpoints\t= {0x05, 0x06},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA28X_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa28xa_device_details = {\n\t.product_id\t\t= keyspan_usa28xa_product_id,\n\t.msg_format\t\t= msg_usa26,\n\t.num_ports\t\t= 2,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 1,\n\t.indat_endpoints\t= {0x81, 0x83},\n\t.outdat_endpoints\t= {0x01, 0x03},\n\t.inack_endpoints\t= {0x85, 0x86},\n\t.outcont_endpoints\t= {0x05, 0x06},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA28X_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa28xg_device_details = {\n\t.product_id\t\t= keyspan_usa28xg_product_id,\n\t.msg_format\t\t= msg_usa67,\n\t.num_ports\t\t= 2,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 0,\n\t.indat_endpoints\t= {0x84, 0x88},\n\t.outdat_endpoints\t= {0x02, 0x06},\n\t.inack_endpoints\t= {-1, -1},\n\t.outcont_endpoints\t= {-1, -1},\n\t.instat_endpoint\t= 0x81,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x01,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA28X_BAUDCLK,\n};\n \n\nstatic const struct keyspan_device_details usa49w_device_details = {\n\t.product_id\t\t= keyspan_usa49w_product_id,\n\t.msg_format\t\t= msg_usa49,\n\t.num_ports\t\t= 4,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 0,\n\t.indat_endpoints\t= {0x81, 0x82, 0x83, 0x84},\n\t.outdat_endpoints\t= {0x01, 0x02, 0x03, 0x04},\n\t.inack_endpoints\t= {-1, -1, -1, -1},\n\t.outcont_endpoints\t= {-1, -1, -1, -1},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA49W_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa49wlc_device_details = {\n\t.product_id\t\t= keyspan_usa49wlc_product_id,\n\t.msg_format\t\t= msg_usa49,\n\t.num_ports\t\t= 4,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 0,\n\t.indat_endpoints\t= {0x81, 0x82, 0x83, 0x84},\n\t.outdat_endpoints\t= {0x01, 0x02, 0x03, 0x04},\n\t.inack_endpoints\t= {-1, -1, -1, -1},\n\t.outcont_endpoints\t= {-1, -1, -1, -1},\n\t.instat_endpoint\t= 0x87,\n\t.indat_endpoint\t\t= -1,\n\t.glocont_endpoint\t= 0x07,\n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19W_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details usa49wg_device_details = {\n\t.product_id\t\t= keyspan_usa49wg_product_id,\n\t.msg_format\t\t= msg_usa49,\n\t.num_ports\t\t= 4,\n\t.indat_endp_flip\t= 0,\n\t.outdat_endp_flip\t= 0,\n\t.indat_endpoints\t= {-1, -1, -1, -1},\t \n\t.outdat_endpoints\t= {0x01, 0x02, 0x04, 0x06},\n\t.inack_endpoints\t= {-1, -1, -1, -1},\n\t.outcont_endpoints\t= {-1, -1, -1, -1},\n\t.instat_endpoint\t= 0x81,\n\t.indat_endpoint\t\t= 0x88,\n\t.glocont_endpoint\t= 0x00,\t\t\t \n\t.calculate_baud_rate\t= keyspan_usa19w_calc_baud,\n\t.baudclk\t\t= KEYSPAN_USA19W_BAUDCLK,\n};\n\nstatic const struct keyspan_device_details *keyspan_devices[] = {\n\t&usa18x_device_details,\n\t&usa19_device_details,\n\t&usa19qi_device_details,\n\t&mpr_device_details,\n\t&usa19qw_device_details,\n\t&usa19w_device_details,\n\t&usa19hs_device_details,\n\t&usa28_device_details,\n\t&usa28x_device_details,\n\t&usa28xa_device_details,\n\t&usa28xg_device_details,\n\t \n\t&usa49w_device_details,\n\t&usa49wlc_device_details,\n\t&usa49wg_device_details,\n\tNULL,\n};\n\nstatic const struct usb_device_id keyspan_ids_combined[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xb_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wlc_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19hs_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xg_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_product_id)},\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wlc_product_id)},\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wg_product_id)},\n\t{ }  \n};\n\nMODULE_DEVICE_TABLE(usb, keyspan_ids_combined);\n\n \nstatic const struct usb_device_id keyspan_pre_ids[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xb_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_pre_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wlc_pre_product_id) },\n\t{ }  \n};\n\nstatic const struct usb_device_id keyspan_1port_ids[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa18x_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qi_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19qw_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19w_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa19hs_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_mpr_product_id) },\n\t{ }  \n};\n\nstatic const struct usb_device_id keyspan_2port_ids[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28x_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xa_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa28xg_product_id) },\n\t{ }  \n};\n\nstatic const struct usb_device_id keyspan_4port_ids[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49w_product_id) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wlc_product_id)},\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, keyspan_usa49wg_product_id)},\n\t{ }  \n};\n\n#define INSTAT_BUFLEN\t32\n#define GLOCONT_BUFLEN\t64\n#define INDAT49W_BUFLEN\t512\n#define IN_BUFLEN\t64\n#define OUT_BUFLEN\t64\n#define INACK_BUFLEN\t1\n#define OUTCONT_BUFLEN\t64\n\n\t \nstruct keyspan_serial_private {\n\tconst struct keyspan_device_details\t*device_details;\n\n\tstruct urb\t*instat_urb;\n\tchar\t\t*instat_buf;\n\n\t \n\tstruct urb\t*indat_urb;\n\tchar\t\t*indat_buf;\n\n\t \n\tstruct urb\t*glocont_urb;\n\tchar\t\t*glocont_buf;\n\tchar\t\t*ctrl_buf;\t \n};\n\nstruct keyspan_port_private {\n\t \n\tint\t\tin_flip;\n\tint\t\tout_flip;\n\n\t \n\tconst struct keyspan_device_details\t*device_details;\n\n\t \n\tstruct urb\t*in_urbs[2];\n\tchar\t\t*in_buffer[2];\n\t \n\tstruct urb\t*out_urbs[2];\n\tchar\t\t*out_buffer[2];\n\n\t \n\tstruct urb\t*inack_urb;\n\tchar\t\t*inack_buffer;\n\n\t \n\tstruct urb\t*outcont_urb;\n\tchar\t\t*outcont_buffer;\n\n\t \n\tint\t\tbaud;\n\tint\t\told_baud;\n\tunsigned int\tcflag;\n\tunsigned int\told_cflag;\n\tenum\t\t{flow_none, flow_cts, flow_xon} flow_control;\n\tint\t\trts_state;\t \n\tint\t\tdtr_state;\n\tint\t\tcts_state;\t \n\tint\t\tdsr_state;\n\tint\t\tdcd_state;\n\tint\t\tri_state;\n\tint\t\tbreak_on;\n\n\tunsigned long\ttx_start_time[2];\n\tint\t\tresend_cont;\t \n};\n\n \n#include \"keyspan_usa26msg.h\"\n#include \"keyspan_usa28msg.h\"\n#include \"keyspan_usa49msg.h\"\n#include \"keyspan_usa90msg.h\"\n#include \"keyspan_usa67msg.h\"\n\n\nstatic int keyspan_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct keyspan_port_private \t*p_priv;\n\n\tp_priv = usb_get_serial_port_data(port);\n\n\tif (break_state == -1)\n\t\tp_priv->break_on = 1;\n\telse\n\t\tp_priv->break_on = 0;\n\n\t \n\tkeyspan_send_setup(port, 0);\n\n\treturn 0;\n}\n\n\nstatic void keyspan_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tint\t\t\t\tbaud_rate, device_port;\n\tstruct keyspan_port_private \t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tunsigned int \t\t\tcflag;\n\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = p_priv->device_details;\n\tcflag = tty->termios.c_cflag;\n\tdevice_port = port->port_number;\n\n\t \n\tbaud_rate = tty_get_baud_rate(tty);\n\t \n\tif (d_details->calculate_baud_rate(port, baud_rate, d_details->baudclk,\n\t\t\t\tNULL, NULL, NULL, device_port) == KEYSPAN_BAUD_RATE_OK) {\n\t\t \n\t\t \n\t\tp_priv->baud = baud_rate;\n\t} else\n\t\tbaud_rate = tty_termios_baud_rate(old_termios);\n\n\ttty_encode_baud_rate(tty, baud_rate, baud_rate);\n\t \n\tp_priv->cflag = cflag;\n\tp_priv->flow_control = (cflag & CRTSCTS) ? flow_cts : flow_none;\n\n\t \n\ttty->termios.c_cflag &= ~CMSPAR;\n\n\tkeyspan_send_setup(port, 0);\n}\n\nstatic int keyspan_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\n\tunsigned int\t\t\tvalue;\n\n\tvalue = ((p_priv->rts_state) ? TIOCM_RTS : 0) |\n\t\t((p_priv->dtr_state) ? TIOCM_DTR : 0) |\n\t\t((p_priv->cts_state) ? TIOCM_CTS : 0) |\n\t\t((p_priv->dsr_state) ? TIOCM_DSR : 0) |\n\t\t((p_priv->dcd_state) ? TIOCM_CAR : 0) |\n\t\t((p_priv->ri_state) ? TIOCM_RNG : 0);\n\n\treturn value;\n}\n\nstatic int keyspan_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tp_priv->rts_state = 1;\n\tif (set & TIOCM_DTR)\n\t\tp_priv->dtr_state = 1;\n\tif (clear & TIOCM_RTS)\n\t\tp_priv->rts_state = 0;\n\tif (clear & TIOCM_DTR)\n\t\tp_priv->dtr_state = 0;\n\tkeyspan_send_setup(port, 0);\n\treturn 0;\n}\n\n \nstatic int keyspan_write(struct tty_struct *tty,\n\tstruct usb_serial_port *port, const unsigned char *buf, int count)\n{\n\tstruct keyspan_port_private \t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tint\t\t\t\tflip;\n\tint \t\t\t\tleft, todo;\n\tstruct urb\t\t\t*this_urb;\n\tint \t\t\t\terr, maxDataLen, dataOffset;\n\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = p_priv->device_details;\n\n\tif (d_details->msg_format == msg_usa90) {\n\t\tmaxDataLen = 64;\n\t\tdataOffset = 0;\n\t} else {\n\t\tmaxDataLen = 63;\n\t\tdataOffset = 1;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - %d chars, flip=%d\\n\", __func__, count,\n\t\tp_priv->out_flip);\n\n\tfor (left = count; left > 0; left -= todo) {\n\t\ttodo = left;\n\t\tif (todo > maxDataLen)\n\t\t\ttodo = maxDataLen;\n\n\t\tflip = p_priv->out_flip;\n\n\t\t \n\t\tthis_urb = p_priv->out_urbs[flip];\n\t\tif (this_urb == NULL) {\n\t\t\t \n\t\t\tdev_dbg(&port->dev, \"%s - no output urb :(\\n\", __func__);\n\t\t\treturn count;\n\t\t}\n\n\t\tdev_dbg(&port->dev, \"%s - endpoint %x flip %d\\n\",\n\t\t\t__func__, usb_pipeendpoint(this_urb->pipe), flip);\n\n\t\tif (this_urb->status == -EINPROGRESS) {\n\t\t\tif (time_before(jiffies,\n\t\t\t\t\tp_priv->tx_start_time[flip] + 10 * HZ))\n\t\t\t\tbreak;\n\t\t\tusb_unlink_urb(this_urb);\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\t((char *)this_urb->transfer_buffer)[0] = 0;\n\n\t\tmemcpy(this_urb->transfer_buffer + dataOffset, buf, todo);\n\t\tbuf += todo;\n\n\t\t \n\t\tthis_urb->transfer_buffer_length = todo + dataOffset;\n\n\t\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\t\tif (err != 0)\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(write bulk) failed (%d)\\n\", err);\n\t\tp_priv->tx_start_time[flip] = jiffies;\n\n\t\t \n\t\tp_priv->out_flip = (flip + 1) & d_details->outdat_endp_flip;\n\t}\n\n\treturn count - left;\n}\n\nstatic void\tusa26_indat_callback(struct urb *urb)\n{\n\tint\t\t\ti, err;\n\tint\t\t\tendpoint;\n\tstruct usb_serial_port\t*port;\n\tunsigned char \t\t*data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tendpoint = usb_pipeendpoint(urb->pipe);\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status %d on endpoint %x\\n\",\n\t\t\t__func__, status, endpoint);\n\t\treturn;\n\t}\n\n\tport =  urb->context;\n\tif (urb->actual_length) {\n\t\t \n\t\tif ((data[0] & 0x80) == 0) {\n\t\t\t \n\t\t\tif (data[0] & RXERROR_OVERRUN) {\n\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t}\n\t\t\tfor (i = 1; i < urb->actual_length ; ++i)\n\t\t\t\ttty_insert_flip_char(&port->port, data[i],\n\t\t\t\t\t\t\t\tTTY_NORMAL);\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(&port->dev, \"%s - RX error!!!!\\n\", __func__);\n\t\t\tfor (i = 0; i + 1 < urb->actual_length; i += 2) {\n\t\t\t\tint stat = data[i];\n\t\t\t\tint flag = TTY_NORMAL;\n\n\t\t\t\tif (stat & RXERROR_OVERRUN) {\n\t\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (stat & RXERROR_PARITY)\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\telse if (stat & RXERROR_FRAMING)\n\t\t\t\t\tflag = TTY_FRAME;\n\n\t\t\t\ttty_insert_flip_char(&port->port, data[i+1],\n\t\t\t\t\t\tflag);\n\t\t\t}\n\t\t}\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\n}\n\n \nstatic void\tusa2x_outdat_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\tdev_dbg(&port->dev, \"%s - urb %d\\n\", __func__, urb == p_priv->out_urbs[1]);\n\n\tusb_serial_port_softint(port);\n}\n\nstatic void\tusa26_inack_callback(struct urb *urb)\n{\n}\n\nstatic void\tusa26_outcont_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\n\tif (p_priv->resend_cont) {\n\t\tdev_dbg(&port->dev, \"%s - sending setup\\n\", __func__);\n\t\tkeyspan_usa26_send_setup(port->serial, port,\n\t\t\t\t\t\tp_priv->resend_cont - 1);\n\t}\n}\n\nstatic void\tusa26_instat_callback(struct urb *urb)\n{\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa26_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state, err;\n\tint status = urb->status;\n\n\tserial =  urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\tif (urb->actual_length != 9) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - %d byte report??\\n\", __func__, urb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tmsg = (struct keyspan_usa26_portStatusMessage *)data;\n\n\t \n\tif (msg->port >= serial->num_ports) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - Unexpected port number %d\\n\", __func__, msg->port);\n\t\tgoto exit;\n\t}\n\tport = serial->port[msg->port];\n\tp_priv = usb_get_serial_port_data(port);\n\tif (!p_priv)\n\t\tgoto resubmit;\n\n\t \n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->hskia_cts) ? 1 : 0);\n\tp_priv->dsr_state = ((msg->dsr) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->gpia_dcd) ? 1 : 0);\n\tp_priv->ri_state = ((msg->ri) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state)\n\t\ttty_port_tty_hangup(&port->port, true);\nresubmit:\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\nexit: ;\n}\n\nstatic void\tusa26_glocont_callback(struct urb *urb)\n{\n}\n\n\nstatic void usa28_indat_callback(struct urb *urb)\n{\n\tint                     err;\n\tstruct usb_serial_port  *port;\n\tunsigned char           *data;\n\tstruct keyspan_port_private             *p_priv;\n\tint status = urb->status;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\tdata = urb->transfer_buffer;\n\n\tif (urb != p_priv->in_urbs[p_priv->in_flip])\n\t\treturn;\n\n\tdo {\n\t\tif (status) {\n\t\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status %d on endpoint %x\\n\",\n\t\t\t\t__func__, status, usb_pipeendpoint(urb->pipe));\n\t\t\treturn;\n\t\t}\n\n\t\tport =  urb->context;\n\t\tp_priv = usb_get_serial_port_data(port);\n\t\tdata = urb->transfer_buffer;\n\n\t\tif (urb->actual_length) {\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\t\ttty_flip_buffer_push(&port->port);\n\t\t}\n\n\t\t \n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err != 0)\n\t\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\",\n\t\t\t\t\t\t\t__func__, err);\n\t\tp_priv->in_flip ^= 1;\n\n\t\turb = p_priv->in_urbs[p_priv->in_flip];\n\t} while (urb->status != -EINPROGRESS);\n}\n\nstatic void\tusa28_inack_callback(struct urb *urb)\n{\n}\n\nstatic void\tusa28_outcont_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\n\tif (p_priv->resend_cont) {\n\t\tdev_dbg(&port->dev, \"%s - sending setup\\n\", __func__);\n\t\tkeyspan_usa28_send_setup(port->serial, port,\n\t\t\t\t\t\tp_priv->resend_cont - 1);\n\t}\n}\n\nstatic void\tusa28_instat_callback(struct urb *urb)\n{\n\tint\t\t\t\t\terr;\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa28_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state;\n\tint status = urb->status;\n\n\tserial =  urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length != sizeof(struct keyspan_usa28_portStatusMessage)) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad length %d\\n\", __func__, urb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tmsg = (struct keyspan_usa28_portStatusMessage *)data;\n\n\t \n\tif (msg->port >= serial->num_ports) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - Unexpected port number %d\\n\", __func__, msg->port);\n\t\tgoto exit;\n\t}\n\tport = serial->port[msg->port];\n\tp_priv = usb_get_serial_port_data(port);\n\tif (!p_priv)\n\t\tgoto resubmit;\n\n\t \n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->cts) ? 1 : 0);\n\tp_priv->dsr_state = ((msg->dsr) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->dcd) ? 1 : 0);\n\tp_priv->ri_state = ((msg->ri) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state)\n\t\ttty_port_tty_hangup(&port->port, true);\nresubmit:\n\t\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\nexit: ;\n}\n\nstatic void\tusa28_glocont_callback(struct urb *urb)\n{\n}\n\n\nstatic void\tusa49_glocont_callback(struct urb *urb)\n{\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\tint i;\n\n\tserial =  urb->context;\n\tfor (i = 0; i < serial->num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tp_priv = usb_get_serial_port_data(port);\n\t\tif (!p_priv)\n\t\t\tcontinue;\n\n\t\tif (p_priv->resend_cont) {\n\t\t\tdev_dbg(&port->dev, \"%s - sending setup\\n\", __func__);\n\t\t\tkeyspan_usa49_send_setup(serial, port,\n\t\t\t\t\t\tp_priv->resend_cont - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\t \nstatic void\tusa49_instat_callback(struct urb *urb)\n{\n\tint\t\t\t\t\terr;\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa49_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state;\n\tint status = urb->status;\n\n\tserial =  urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length !=\n\t\t\tsizeof(struct keyspan_usa49_portStatusMessage)) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad length %d\\n\", __func__, urb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tmsg = (struct keyspan_usa49_portStatusMessage *)data;\n\n\t \n\tif (msg->portNumber >= serial->num_ports) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - Unexpected port number %d\\n\",\n\t\t\t__func__, msg->portNumber);\n\t\tgoto exit;\n\t}\n\tport = serial->port[msg->portNumber];\n\tp_priv = usb_get_serial_port_data(port);\n\tif (!p_priv)\n\t\tgoto resubmit;\n\n\t \n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->cts) ? 1 : 0);\n\tp_priv->dsr_state = ((msg->dsr) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->dcd) ? 1 : 0);\n\tp_priv->ri_state = ((msg->ri) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state)\n\t\ttty_port_tty_hangup(&port->port, true);\nresubmit:\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\nexit:\t;\n}\n\nstatic void\tusa49_inack_callback(struct urb *urb)\n{\n}\n\nstatic void\tusa49_indat_callback(struct urb *urb)\n{\n\tint\t\t\ti, err;\n\tint\t\t\tendpoint;\n\tstruct usb_serial_port\t*port;\n\tunsigned char \t\t*data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tendpoint = usb_pipeendpoint(urb->pipe);\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status %d on endpoint %x\\n\",\n\t\t\t__func__, status, endpoint);\n\t\treturn;\n\t}\n\n\tport =  urb->context;\n\tif (urb->actual_length) {\n\t\t \n\t\tif ((data[0] & 0x80) == 0) {\n\t\t\t \n\t\t\ttty_insert_flip_string(&port->port, data + 1,\n\t\t\t\t\t\turb->actual_length - 1);\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i + 1 < urb->actual_length; i += 2) {\n\t\t\t\tint stat = data[i];\n\t\t\t\tint flag = TTY_NORMAL;\n\n\t\t\t\tif (stat & RXERROR_OVERRUN) {\n\t\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (stat & RXERROR_PARITY)\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\telse if (stat & RXERROR_FRAMING)\n\t\t\t\t\tflag = TTY_FRAME;\n\n\t\t\t\ttty_insert_flip_char(&port->port, data[i+1],\n\t\t\t\t\t\tflag);\n\t\t\t}\n\t\t}\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\n}\n\nstatic void usa49wg_indat_callback(struct urb *urb)\n{\n\tint\t\t\ti, len, x, err;\n\tstruct usb_serial\t*serial;\n\tstruct usb_serial_port\t*port;\n\tunsigned char \t\t*data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tserial = urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\t \n\ti = 0;\n\tlen = 0;\n\n\twhile (i < urb->actual_length) {\n\n\t\t \n\t\tif (data[i] >= serial->num_ports) {\n\t\t\tdev_dbg(&urb->dev->dev, \"%s - Unexpected port number %d\\n\",\n\t\t\t\t__func__, data[i]);\n\t\t\treturn;\n\t\t}\n\t\tport = serial->port[data[i++]];\n\t\tlen = data[i++];\n\n\t\t \n\t\tif ((data[i] & 0x80) == 0) {\n\t\t\t \n\t\t\ti++;\n\t\t\tfor (x = 1; x < len && i < urb->actual_length; ++x)\n\t\t\t\ttty_insert_flip_char(&port->port,\n\t\t\t\t\t\tdata[i++], 0);\n\t\t} else {\n\t\t\t \n\t\t\tfor (x = 0; x + 1 < len &&\n\t\t\t\t    i + 1 < urb->actual_length; x += 2) {\n\t\t\t\tint stat = data[i];\n\t\t\t\tint flag = TTY_NORMAL;\n\n\t\t\t\tif (stat & RXERROR_OVERRUN) {\n\t\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (stat & RXERROR_PARITY)\n\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\telse if (stat & RXERROR_FRAMING)\n\t\t\t\t\tflag = TTY_FRAME;\n\n\t\t\t\ttty_insert_flip_char(&port->port, data[i+1],\n\t\t\t\t\t\t     flag);\n\t\t\t\ti += 2;\n\t\t\t}\n\t\t}\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&urb->dev->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\n}\n\n \nstatic void usa49_outcont_callback(struct urb *urb)\n{\n}\n\nstatic void usa90_indat_callback(struct urb *urb)\n{\n\tint\t\t\ti, err;\n\tint\t\t\tendpoint;\n\tstruct usb_serial_port\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tunsigned char \t\t*data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tendpoint = usb_pipeendpoint(urb->pipe);\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status %d on endpoint %x\\n\",\n\t\t\t__func__, status, endpoint);\n\t\treturn;\n\t}\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\n\tif (urb->actual_length) {\n\t\t \n\n\t\tif (p_priv->baud > 57600)\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\t\turb->actual_length);\n\t\telse {\n\t\t\t \n\t\t\tif ((data[0] & 0x80) == 0) {\n\t\t\t\t \n\t\t\t\tif (data[0] & RXERROR_OVERRUN) {\n\t\t\t\t\ttty_insert_flip_char(&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t\t}\n\t\t\t\tfor (i = 1; i < urb->actual_length ; ++i)\n\t\t\t\t\ttty_insert_flip_char(&port->port,\n\t\t\t\t\t\t\tdata[i], TTY_NORMAL);\n\t\t\t}  else {\n\t\t\t \n\t\t\t\tdev_dbg(&port->dev, \"%s - RX error!!!!\\n\", __func__);\n\t\t\t\tfor (i = 0; i + 1 < urb->actual_length; i += 2) {\n\t\t\t\t\tint stat = data[i];\n\t\t\t\t\tint flag = TTY_NORMAL;\n\n\t\t\t\t\tif (stat & RXERROR_OVERRUN) {\n\t\t\t\t\t\ttty_insert_flip_char(\n\t\t\t\t\t\t\t\t&port->port, 0,\n\t\t\t\t\t\t\t\tTTY_OVERRUN);\n\t\t\t\t\t}\n\t\t\t\t\t \n\t\t\t\t\tif (stat & RXERROR_PARITY)\n\t\t\t\t\t\tflag = TTY_PARITY;\n\t\t\t\t\telse if (stat & RXERROR_FRAMING)\n\t\t\t\t\t\tflag = TTY_FRAME;\n\n\t\t\t\t\ttty_insert_flip_char(&port->port,\n\t\t\t\t\t\t\tdata[i+1], flag);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\n}\n\n\nstatic void\tusa90_instat_callback(struct urb *urb)\n{\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa90_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state, err;\n\tint status = urb->status;\n\n\tserial =  urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\tif (urb->actual_length < 14) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - %d byte report??\\n\", __func__, urb->actual_length);\n\t\tgoto exit;\n\t}\n\n\tmsg = (struct keyspan_usa90_portStatusMessage *)data;\n\n\t \n\n\tport = serial->port[0];\n\tp_priv = usb_get_serial_port_data(port);\n\tif (!p_priv)\n\t\tgoto resubmit;\n\n\t \n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->cts) ? 1 : 0);\n\tp_priv->dsr_state = ((msg->dsr) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->dcd) ? 1 : 0);\n\tp_priv->ri_state = ((msg->ri) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state)\n\t\ttty_port_tty_hangup(&port->port, true);\nresubmit:\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\nexit:\n\t;\n}\n\nstatic void\tusa90_outcont_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\n\tport =  urb->context;\n\tp_priv = usb_get_serial_port_data(port);\n\n\tif (p_priv->resend_cont) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - sending setup\\n\", __func__);\n\t\tkeyspan_usa90_send_setup(port->serial, port,\n\t\t\t\t\t\tp_priv->resend_cont - 1);\n\t}\n}\n\n \nstatic void\tusa67_instat_callback(struct urb *urb)\n{\n\tint\t\t\t\t\terr;\n\tunsigned char \t\t\t\t*data = urb->transfer_buffer;\n\tstruct keyspan_usa67_portStatusMessage\t*msg;\n\tstruct usb_serial\t\t\t*serial;\n\tstruct usb_serial_port\t\t\t*port;\n\tstruct keyspan_port_private\t \t*p_priv;\n\tint old_dcd_state;\n\tint status = urb->status;\n\n\tserial = urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero status: %d\\n\",\n\t\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length !=\n\t\t\tsizeof(struct keyspan_usa67_portStatusMessage)) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - bad length %d\\n\", __func__, urb->actual_length);\n\t\treturn;\n\t}\n\n\n\t \n\tmsg = (struct keyspan_usa67_portStatusMessage *)data;\n\n\t \n\tif (msg->port >= serial->num_ports) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - Unexpected port number %d\\n\", __func__, msg->port);\n\t\treturn;\n\t}\n\n\tport = serial->port[msg->port];\n\tp_priv = usb_get_serial_port_data(port);\n\tif (!p_priv)\n\t\tgoto resubmit;\n\n\t \n\told_dcd_state = p_priv->dcd_state;\n\tp_priv->cts_state = ((msg->hskia_cts) ? 1 : 0);\n\tp_priv->dcd_state = ((msg->gpia_dcd) ? 1 : 0);\n\n\tif (old_dcd_state != p_priv->dcd_state && old_dcd_state)\n\t\ttty_port_tty_hangup(&port->port, true);\nresubmit:\n\t \n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - resubmit read urb failed. (%d)\\n\", __func__, err);\n}\n\nstatic void usa67_glocont_callback(struct urb *urb)\n{\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tstruct keyspan_port_private *p_priv;\n\tint i;\n\n\tserial = urb->context;\n\tfor (i = 0; i < serial->num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tp_priv = usb_get_serial_port_data(port);\n\t\tif (!p_priv)\n\t\t\tcontinue;\n\n\t\tif (p_priv->resend_cont) {\n\t\t\tdev_dbg(&port->dev, \"%s - sending setup\\n\", __func__);\n\t\t\tkeyspan_usa67_send_setup(serial, port,\n\t\t\t\t\t\tp_priv->resend_cont - 1);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic unsigned int keyspan_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct keyspan_port_private\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tint\t\t\t\tflip;\n\tunsigned int\t\t\tdata_len;\n\tstruct urb\t\t\t*this_urb;\n\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = p_priv->device_details;\n\n\t \n\tif (d_details->msg_format == msg_usa90)\n\t\tdata_len = 64;\n\telse\n\t\tdata_len = 63;\n\n\tflip = p_priv->out_flip;\n\n\t \n\tthis_urb = p_priv->out_urbs[flip];\n\tif (this_urb != NULL) {\n\t\tif (this_urb->status != -EINPROGRESS)\n\t\t\treturn data_len;\n\t\tflip = (flip + 1) & d_details->outdat_endp_flip;\n\t\tthis_urb = p_priv->out_urbs[flip];\n\t\tif (this_urb != NULL) {\n\t\t\tif (this_urb->status != -EINPROGRESS)\n\t\t\t\treturn data_len;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nstatic int keyspan_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct keyspan_port_private \t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tint\t\t\t\ti, err;\n\tint\t\t\t\tbaud_rate, device_port;\n\tstruct urb\t\t\t*urb;\n\tunsigned int\t\t\tcflag = 0;\n\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = p_priv->device_details;\n\n\t \n\tp_priv->rts_state = 1;\n\tp_priv->dtr_state = 1;\n\tp_priv->baud = 9600;\n\n\t \n\tp_priv->old_baud = 0;\n\tp_priv->old_cflag = 0;\n\n\tp_priv->out_flip = 0;\n\tp_priv->in_flip = 0;\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\turb = p_priv->in_urbs[i];\n\t\tif (urb == NULL)\n\t\t\tcontinue;\n\n\t\t \n\t\tusb_clear_halt(urb->dev, urb->pipe);\n\t\terr = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (err != 0)\n\t\t\tdev_dbg(&port->dev, \"%s - submit urb %d failed (%d)\\n\", __func__, i, err);\n\t}\n\n\t \n\tfor (i = 0; i < 2; i++) {\n\t\turb = p_priv->out_urbs[i];\n\t\tif (urb == NULL)\n\t\t\tcontinue;\n\t\t \n\t}\n\n\t \n\n\tdevice_port = port->port_number;\n\tif (tty) {\n\t\tcflag = tty->termios.c_cflag;\n\t\t \n\t\tbaud_rate = tty_get_baud_rate(tty);\n\t\t \n\t\tif (baud_rate >= 0\n\t\t    && d_details->calculate_baud_rate(port, baud_rate, d_details->baudclk,\n\t\t\t\t\tNULL, NULL, NULL, device_port) == KEYSPAN_BAUD_RATE_OK) {\n\t\t\tp_priv->baud = baud_rate;\n\t\t}\n\t}\n\t \n\tp_priv->cflag = cflag;\n\tp_priv->flow_control = (cflag & CRTSCTS) ? flow_cts : flow_none;\n\n\tkeyspan_send_setup(port, 1);\n\t \n\t \n\n\treturn 0;\n}\n\nstatic void keyspan_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct keyspan_port_private *p_priv = usb_get_serial_port_data(port);\n\n\tp_priv->rts_state = on;\n\tp_priv->dtr_state = on;\n\tkeyspan_send_setup(port, 0);\n}\n\nstatic void keyspan_close(struct usb_serial_port *port)\n{\n\tint\t\t\ti;\n\tstruct keyspan_port_private \t*p_priv;\n\n\tp_priv = usb_get_serial_port_data(port);\n\n\tp_priv->rts_state = 0;\n\tp_priv->dtr_state = 0;\n\n\tkeyspan_send_setup(port, 2);\n\t \n\tmdelay(100);\n\n\tp_priv->out_flip = 0;\n\tp_priv->in_flip = 0;\n\n\tusb_kill_urb(p_priv->inack_urb);\n\tfor (i = 0; i < 2; i++) {\n\t\tusb_kill_urb(p_priv->in_urbs[i]);\n\t\tusb_kill_urb(p_priv->out_urbs[i]);\n\t}\n}\n\n \nstatic int keyspan_fake_startup(struct usb_serial *serial)\n{\n\tchar\t*fw_name;\n\n\tdev_dbg(&serial->dev->dev, \"Keyspan startup version %04x product %04x\\n\",\n\t\tle16_to_cpu(serial->dev->descriptor.bcdDevice),\n\t\tle16_to_cpu(serial->dev->descriptor.idProduct));\n\n\tif ((le16_to_cpu(serial->dev->descriptor.bcdDevice) & 0x8000)\n\t\t\t\t\t\t\t\t!= 0x8000) {\n\t\tdev_dbg(&serial->dev->dev, \"Firmware already loaded.  Quitting.\\n\");\n\t\treturn 1;\n\t}\n\n\t\t \n\tswitch (le16_to_cpu(serial->dev->descriptor.idProduct)) {\n\tcase keyspan_usa28_pre_product_id:\n\t\tfw_name = \"keyspan/usa28.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28x_pre_product_id:\n\t\tfw_name = \"keyspan/usa28x.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28xa_pre_product_id:\n\t\tfw_name = \"keyspan/usa28xa.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa28xb_pre_product_id:\n\t\tfw_name = \"keyspan/usa28xb.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19_pre_product_id:\n\t\tfw_name = \"keyspan/usa19.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19qi_pre_product_id:\n\t\tfw_name = \"keyspan/usa19qi.fw\";\n\t\tbreak;\n\n\tcase keyspan_mpr_pre_product_id:\n\t\tfw_name = \"keyspan/mpr.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19qw_pre_product_id:\n\t\tfw_name = \"keyspan/usa19qw.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa18x_pre_product_id:\n\t\tfw_name = \"keyspan/usa18x.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa19w_pre_product_id:\n\t\tfw_name = \"keyspan/usa19w.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa49w_pre_product_id:\n\t\tfw_name = \"keyspan/usa49w.fw\";\n\t\tbreak;\n\n\tcase keyspan_usa49wlc_pre_product_id:\n\t\tfw_name = \"keyspan/usa49wlc.fw\";\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(&serial->dev->dev, \"Unknown product ID (%04x)\\n\",\n\t\t\tle16_to_cpu(serial->dev->descriptor.idProduct));\n\t\treturn 1;\n\t}\n\n\tdev_dbg(&serial->dev->dev, \"Uploading Keyspan %s firmware.\\n\", fw_name);\n\n\tif (ezusb_fx1_ihex_firmware_download(serial->dev, fw_name) < 0) {\n\t\tdev_err(&serial->dev->dev, \"failed to load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\t \n\treturn 1;\n}\n\n \nstatic struct usb_endpoint_descriptor const *find_ep(struct usb_serial const *serial,\n\t\t\t\t\t\t     int endpoint)\n{\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *ep;\n\tint i;\n\n\tiface_desc = serial->interface->cur_altsetting;\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tep = &iface_desc->endpoint[i].desc;\n\t\tif (ep->bEndpointAddress == endpoint)\n\t\t\treturn ep;\n\t}\n\tdev_warn(&serial->interface->dev, \"found no endpoint descriptor for endpoint %x\\n\",\n\t\t\tendpoint);\n\treturn NULL;\n}\n\nstatic struct urb *keyspan_setup_urb(struct usb_serial *serial, int endpoint,\n\t\t\t\t      int dir, void *ctx, char *buf, int len,\n\t\t\t\t      void (*callback)(struct urb *))\n{\n\tstruct urb *urb;\n\tstruct usb_endpoint_descriptor const *ep_desc;\n\tchar const *ep_type_name;\n\n\tif (endpoint == -1)\n\t\treturn NULL;\t\t \n\n\tdev_dbg(&serial->interface->dev, \"%s - alloc for endpoint %x\\n\",\n\t\t\t__func__, endpoint);\n\turb = usb_alloc_urb(0, GFP_KERNEL);\t\t \n\tif (!urb)\n\t\treturn NULL;\n\n\tif (endpoint == 0) {\n\t\t \n\t\treturn urb;\n\t}\n\n\tep_desc = find_ep(serial, endpoint);\n\tif (!ep_desc) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\tif (usb_endpoint_xfer_int(ep_desc)) {\n\t\tep_type_name = \"INT\";\n\t\tusb_fill_int_urb(urb, serial->dev,\n\t\t\t\t usb_sndintpipe(serial->dev, endpoint) | dir,\n\t\t\t\t buf, len, callback, ctx,\n\t\t\t\t ep_desc->bInterval);\n\t} else if (usb_endpoint_xfer_bulk(ep_desc)) {\n\t\tep_type_name = \"BULK\";\n\t\tusb_fill_bulk_urb(urb, serial->dev,\n\t\t\t\t  usb_sndbulkpipe(serial->dev, endpoint) | dir,\n\t\t\t\t  buf, len, callback, ctx);\n\t} else {\n\t\tdev_warn(&serial->interface->dev,\n\t\t\t \"unsupported endpoint type %x\\n\",\n\t\t\t usb_endpoint_type(ep_desc));\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\tdev_dbg(&serial->interface->dev, \"%s - using urb %p for %s endpoint %x\\n\",\n\t    __func__, urb, ep_type_name, endpoint);\n\treturn urb;\n}\n\nstatic struct callbacks {\n\tvoid\t(*instat_callback)(struct urb *);\n\tvoid\t(*glocont_callback)(struct urb *);\n\tvoid\t(*indat_callback)(struct urb *);\n\tvoid\t(*outdat_callback)(struct urb *);\n\tvoid\t(*inack_callback)(struct urb *);\n\tvoid\t(*outcont_callback)(struct urb *);\n} keyspan_callbacks[] = {\n\t{\n\t\t \n\t\t.instat_callback =\tusa26_instat_callback,\n\t\t.glocont_callback =\tusa26_glocont_callback,\n\t\t.indat_callback =\tusa26_indat_callback,\n\t\t.outdat_callback =\tusa2x_outdat_callback,\n\t\t.inack_callback =\tusa26_inack_callback,\n\t\t.outcont_callback =\tusa26_outcont_callback,\n\t}, {\n\t\t \n\t\t.instat_callback =\tusa28_instat_callback,\n\t\t.glocont_callback =\tusa28_glocont_callback,\n\t\t.indat_callback =\tusa28_indat_callback,\n\t\t.outdat_callback =\tusa2x_outdat_callback,\n\t\t.inack_callback =\tusa28_inack_callback,\n\t\t.outcont_callback =\tusa28_outcont_callback,\n\t}, {\n\t\t \n\t\t.instat_callback =\tusa49_instat_callback,\n\t\t.glocont_callback =\tusa49_glocont_callback,\n\t\t.indat_callback =\tusa49_indat_callback,\n\t\t.outdat_callback =\tusa2x_outdat_callback,\n\t\t.inack_callback =\tusa49_inack_callback,\n\t\t.outcont_callback =\tusa49_outcont_callback,\n\t}, {\n\t\t \n\t\t.instat_callback =\tusa90_instat_callback,\n\t\t.glocont_callback =\tusa28_glocont_callback,\n\t\t.indat_callback =\tusa90_indat_callback,\n\t\t.outdat_callback =\tusa2x_outdat_callback,\n\t\t.inack_callback =\tusa28_inack_callback,\n\t\t.outcont_callback =\tusa90_outcont_callback,\n\t}, {\n\t\t \n\t\t.instat_callback =\tusa67_instat_callback,\n\t\t.glocont_callback =\tusa67_glocont_callback,\n\t\t.indat_callback =\tusa26_indat_callback,\n\t\t.outdat_callback =\tusa2x_outdat_callback,\n\t\t.inack_callback =\tusa26_inack_callback,\n\t\t.outcont_callback =\tusa26_outcont_callback,\n\t}\n};\n\n\t \nstatic void keyspan_setup_urbs(struct usb_serial *serial)\n{\n\tstruct keyspan_serial_private \t*s_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct callbacks\t\t*cback;\n\n\ts_priv = usb_get_serial_data(serial);\n\td_details = s_priv->device_details;\n\n\t \n\tcback = &keyspan_callbacks[d_details->msg_format];\n\n\t \n\ts_priv->instat_urb = keyspan_setup_urb\n\t\t(serial, d_details->instat_endpoint, USB_DIR_IN,\n\t\t serial, s_priv->instat_buf, INSTAT_BUFLEN,\n\t\t cback->instat_callback);\n\n\ts_priv->indat_urb = keyspan_setup_urb\n\t\t(serial, d_details->indat_endpoint, USB_DIR_IN,\n\t\t serial, s_priv->indat_buf, INDAT49W_BUFLEN,\n\t\t usa49wg_indat_callback);\n\n\ts_priv->glocont_urb = keyspan_setup_urb\n\t\t(serial, d_details->glocont_endpoint, USB_DIR_OUT,\n\t\t serial, s_priv->glocont_buf, GLOCONT_BUFLEN,\n\t\t cback->glocont_callback);\n}\n\n \nstatic int keyspan_usa19_calc_baud(struct usb_serial_port *port,\n\t\t\t\t   u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t   u8 *rate_low, u8 *prescaler, int portnum)\n{\n\tu32 \tb16,\t \n\t\tdiv,\t \n\t\tcnt;\t \n\n\tdev_dbg(&port->dev, \"%s - %d.\\n\", __func__, baud_rate);\n\n\t \n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t \n\tif (baud_rate > 57600)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\tdiv = baudclk / b16;\n\tif (div == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\telse\n\t\tcnt = 0 - div;\n\n\tif (div > 0xffff)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\tif (rate_low)\n\t\t*rate_low = (u8) (cnt & 0xff);\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((cnt >> 8) & 0xff);\n\tif (rate_low && rate_hi)\n\t\tdev_dbg(&port->dev, \"%s - %d %02x %02x.\\n\",\n\t\t\t\t__func__, baud_rate, *rate_hi, *rate_low);\n\treturn KEYSPAN_BAUD_RATE_OK;\n}\n\n \nstatic int keyspan_usa19hs_calc_baud(struct usb_serial_port *port,\n\t\t\t\t     u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t     u8 *rate_low, u8 *prescaler, int portnum)\n{\n\tu32 \tb16,\t \n\t\t\tdiv;\t \n\n\tdev_dbg(&port->dev, \"%s - %d.\\n\", __func__, baud_rate);\n\n\t \n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\tdiv = baudclk / b16;\n\tif (div == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\tif (div > 0xffff)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\tif (rate_low)\n\t\t*rate_low = (u8) (div & 0xff);\n\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((div >> 8) & 0xff);\n\n\tif (rate_low && rate_hi)\n\t\tdev_dbg(&port->dev, \"%s - %d %02x %02x.\\n\",\n\t\t\t__func__, baud_rate, *rate_hi, *rate_low);\n\n\treturn KEYSPAN_BAUD_RATE_OK;\n}\n\nstatic int keyspan_usa19w_calc_baud(struct usb_serial_port *port,\n\t\t\t\t    u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t    u8 *rate_low, u8 *prescaler, int portnum)\n{\n\tu32 \tb16,\t \n\t\tclk,\t \n\t\tdiv,\t \n\t\tres,\t \n\t\tdiff,\t \n\t\tsmallest_diff;\n\tu8\tbest_prescaler;\n\tint\ti;\n\n\tdev_dbg(&port->dev, \"%s - %d.\\n\", __func__, baud_rate);\n\n\t \n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\n\t \n\tsmallest_diff = 0xffffffff;\n\n\t\t \n\tbest_prescaler = 0;\n\n\tfor (i = 8; i <= 0xff; ++i) {\n\t\tclk = (baudclk * 8) / (u32) i;\n\n\t\tdiv = clk / b16;\n\t\tif (div == 0)\n\t\t\tcontinue;\n\n\t\tres = clk / div;\n\t\tdiff = (res > b16) ? (res-b16) : (b16-res);\n\n\t\tif (diff < smallest_diff) {\n\t\t\tbest_prescaler = i;\n\t\t\tsmallest_diff = diff;\n\t\t}\n\t}\n\n\tif (best_prescaler == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\tclk = (baudclk * 8) / (u32) best_prescaler;\n\tdiv = clk / b16;\n\n\t \n\tif (rate_low)\n\t\t*rate_low = (u8) (div & 0xff);\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((div >> 8) & 0xff);\n\tif (prescaler) {\n\t\t*prescaler = best_prescaler;\n\t\t \n\t}\n\treturn KEYSPAN_BAUD_RATE_OK;\n}\n\n\t \nstatic int keyspan_usa28_calc_baud(struct usb_serial_port *port,\n\t\t\t\t   u32 baud_rate, u32 baudclk, u8 *rate_hi,\n\t\t\t\t   u8 *rate_low, u8 *prescaler, int portnum)\n{\n\tu32 \tb16,\t \n\t\tdiv,\t \n\t\tcnt;\t \n\n\tdev_dbg(&port->dev, \"%s - %d.\\n\", __func__, baud_rate);\n\n\t\t \n\tb16 = baud_rate * 16L;\n\tif (b16 == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\n\t \n\tdiv = KEYSPAN_USA28_BAUDCLK / b16;\n\tif (div == 0)\n\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\telse\n\t\tcnt = 0 - div;\n\n\t \n\tif (portnum == 0) {\n\t\tif (div > 0xffff)\n\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t} else {\n\t\tif (portnum == 1) {\n\t\t\tif (div > 0xff)\n\t\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t\t} else\n\t\t\treturn KEYSPAN_INVALID_BAUD_RATE;\n\t}\n\n\t\t \n\tif (rate_low)\n\t\t*rate_low = (u8) (cnt & 0xff);\n\tif (rate_hi)\n\t\t*rate_hi = (u8) ((cnt >> 8) & 0xff);\n\tdev_dbg(&port->dev, \"%s - %d OK.\\n\", __func__, baud_rate);\n\treturn KEYSPAN_BAUD_RATE_OK;\n}\n\nstatic int keyspan_usa26_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port)\n{\n\tstruct keyspan_usa26_portControlMessage\tmsg;\n\tstruct keyspan_serial_private \t\t*s_priv;\n\tstruct keyspan_port_private \t\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct urb\t\t\t\t*this_urb;\n\tint \t\t\t\t\tdevice_port, err;\n\n\tdev_dbg(&port->dev, \"%s reset=%d\\n\", __func__, reset_port);\n\n\ts_priv = usb_get_serial_data(serial);\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = s_priv->device_details;\n\tdevice_port = port->port_number;\n\n\tthis_urb = p_priv->outcont_urb;\n\n\t\t \n\tif (this_urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - oops no urb.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - endpoint %x\\n\",\n\t\t\t__func__, usb_pipeendpoint(this_urb->pipe));\n\n\t \n\tif ((reset_port + 1) > p_priv->resend_cont)\n\t\tp_priv->resend_cont = reset_port + 1;\n\tif (this_urb->status == -EINPROGRESS) {\n\t\t \n\t\tmdelay(5);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct keyspan_usa26_portControlMessage));\n\n\t \n\tif (p_priv->old_baud != p_priv->baud) {\n\t\tp_priv->old_baud = p_priv->baud;\n\t\tmsg.setClocking = 0xff;\n\t\tif (d_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t\t\t   &msg.baudHi, &msg.baudLo, &msg.prescaler,\n\t\t\t\t\t\t   device_port) == KEYSPAN_INVALID_BAUD_RATE) {\n\t\t\tdev_dbg(&port->dev, \"%s - Invalid baud rate %d requested, using 9600.\\n\",\n\t\t\t\t__func__, p_priv->baud);\n\t\t\tmsg.baudLo = 0;\n\t\t\tmsg.baudHi = 125;\t \n\t\t\tmsg.prescaler = 10;\n\t\t}\n\t\tmsg.setPrescaler = 0xff;\n\t}\n\n\tmsg.lcr = (p_priv->cflag & CSTOPB) ? STOPBITS_678_2 : STOPBITS_5678_1;\n\tswitch (p_priv->cflag & CSIZE) {\n\tcase CS5:\n\t\tmsg.lcr |= USA_DATABITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmsg.lcr |= USA_DATABITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmsg.lcr |= USA_DATABITS_7;\n\t\tbreak;\n\tcase CS8:\n\t\tmsg.lcr |= USA_DATABITS_8;\n\t\tbreak;\n\t}\n\tif (p_priv->cflag & PARENB) {\n\t\t \n\t\tmsg.lcr |= (p_priv->cflag & PARODD) ?\n\t\t\tUSA_PARITY_ODD : USA_PARITY_EVEN;\n\t}\n\tmsg.setLcr = 0xff;\n\n\tmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\n\tmsg.xonFlowControl = 0;\n\tmsg.setFlowControl = 0xff;\n\tmsg.forwardingLength = 16;\n\tmsg.xonChar = 17;\n\tmsg.xoffChar = 19;\n\n\t \n\tif (reset_port == 1) {\n\t\tmsg._txOn = 1;\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 1;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0xff;\n\t}\n\n\t \n\telse if (reset_port == 2) {\n\t\tmsg._txOn = 0;\n\t\tmsg._txOff = 1;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 1;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0;\n\t}\n\n\t \n\telse {\n\t\tmsg._txOn = (!p_priv->break_on);\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 0;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0x0;\n\t}\n\n\t \n\tmsg.setTxTriState_setRts = 0xff;\n\tmsg.txTriState_rts = p_priv->rts_state;\n\n\tmsg.setHskoa_setDtr = 0xff;\n\tmsg.hskoa_dtr = p_priv->dtr_state;\n\n\tp_priv->resend_cont = 0;\n\tmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\n\n\t \n\tthis_urb->transfer_buffer_length = sizeof(msg);\n\n\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(setup) failed (%d)\\n\", __func__, err);\n\treturn 0;\n}\n\nstatic int keyspan_usa28_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port)\n{\n\tstruct keyspan_usa28_portControlMessage\tmsg;\n\tstruct keyspan_serial_private\t \t*s_priv;\n\tstruct keyspan_port_private \t\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct urb\t\t\t\t*this_urb;\n\tint \t\t\t\t\tdevice_port, err;\n\n\ts_priv = usb_get_serial_data(serial);\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = s_priv->device_details;\n\tdevice_port = port->port_number;\n\n\t \n\tthis_urb = p_priv->outcont_urb;\n\tif (this_urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - oops no urb.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tif ((reset_port + 1) > p_priv->resend_cont)\n\t\tp_priv->resend_cont = reset_port + 1;\n\tif (this_urb->status == -EINPROGRESS) {\n\t\tdev_dbg(&port->dev, \"%s already writing\\n\", __func__);\n\t\tmdelay(5);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct keyspan_usa28_portControlMessage));\n\n\tmsg.setBaudRate = 1;\n\tif (d_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t\t   &msg.baudHi, &msg.baudLo, NULL,\n\t\t\t\t\t   device_port) == KEYSPAN_INVALID_BAUD_RATE) {\n\t\tdev_dbg(&port->dev, \"%s - Invalid baud rate requested %d.\\n\",\n\t\t\t\t\t\t__func__, p_priv->baud);\n\t\tmsg.baudLo = 0xff;\n\t\tmsg.baudHi = 0xb2;\t \n\t}\n\n\t \n\tmsg.parity = 0;\t\t \n\n\tmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\n\tmsg.xonFlowControl = 0;\n\n\t \n\tmsg.rts = p_priv->rts_state;\n\tmsg.dtr = p_priv->dtr_state;\n\n\tmsg.forwardingLength = 16;\n\tmsg.forwardMs = 10;\n\tmsg.breakThreshold = 45;\n\tmsg.xonChar = 17;\n\tmsg.xoffChar = 19;\n\n\t \n\t \n\tif (reset_port == 1) {\n\t\tmsg._txOn = 1;\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txForceXoff = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 1;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0xff;\n\t}\n\t \n\telse if (reset_port == 2) {\n\t\tmsg._txOn = 0;\n\t\tmsg._txOff = 1;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txForceXoff = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 1;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0;\n\t}\n\t \n\telse {\n\t\tmsg._txOn = (!p_priv->break_on);\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txForceXoff = 0;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 0;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0x0;\n\t}\n\n\tp_priv->resend_cont = 0;\n\tmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\n\n\t \n\tthis_urb->transfer_buffer_length = sizeof(msg);\n\n\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(setup) failed\\n\", __func__);\n\n\treturn 0;\n}\n\nstatic int keyspan_usa49_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port)\n{\n\tstruct keyspan_usa49_portControlMessage\tmsg;\n\tstruct usb_ctrlrequest \t\t\t*dr = NULL;\n\tstruct keyspan_serial_private \t\t*s_priv;\n\tstruct keyspan_port_private \t\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct urb\t\t\t\t*this_urb;\n\tint \t\t\t\t\terr, device_port;\n\n\ts_priv = usb_get_serial_data(serial);\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = s_priv->device_details;\n\n\tthis_urb = s_priv->glocont_urb;\n\n\t \n\tdevice_port = port->port_number;\n\n\t \n\tif (this_urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - oops no urb for port.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - endpoint %x (%d)\\n\",\n\t\t__func__, usb_pipeendpoint(this_urb->pipe), device_port);\n\n\t \n\tif ((reset_port + 1) > p_priv->resend_cont)\n\t\tp_priv->resend_cont = reset_port + 1;\n\n\tif (this_urb->status == -EINPROGRESS) {\n\t\t \n\t\tmdelay(5);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct keyspan_usa49_portControlMessage));\n\n\tmsg.portNumber = device_port;\n\n\t \n\tif (p_priv->old_baud != p_priv->baud) {\n\t\tp_priv->old_baud = p_priv->baud;\n\t\tmsg.setClocking = 0xff;\n\t\tif (d_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t\t\t   &msg.baudHi, &msg.baudLo, &msg.prescaler,\n\t\t\t\t\t\t   device_port) == KEYSPAN_INVALID_BAUD_RATE) {\n\t\t\tdev_dbg(&port->dev, \"%s - Invalid baud rate %d requested, using 9600.\\n\",\n\t\t\t\t__func__, p_priv->baud);\n\t\t\tmsg.baudLo = 0;\n\t\t\tmsg.baudHi = 125;\t \n\t\t\tmsg.prescaler = 10;\n\t\t}\n\t\t \n\t}\n\n\tmsg.lcr = (p_priv->cflag & CSTOPB) ? STOPBITS_678_2 : STOPBITS_5678_1;\n\tswitch (p_priv->cflag & CSIZE) {\n\tcase CS5:\n\t\tmsg.lcr |= USA_DATABITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmsg.lcr |= USA_DATABITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmsg.lcr |= USA_DATABITS_7;\n\t\tbreak;\n\tcase CS8:\n\t\tmsg.lcr |= USA_DATABITS_8;\n\t\tbreak;\n\t}\n\tif (p_priv->cflag & PARENB) {\n\t\t \n\t\tmsg.lcr |= (p_priv->cflag & PARODD) ?\n\t\t\tUSA_PARITY_ODD : USA_PARITY_EVEN;\n\t}\n\tmsg.setLcr = 0xff;\n\n\tmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\n\tmsg.xonFlowControl = 0;\n\tmsg.setFlowControl = 0xff;\n\n\tmsg.forwardingLength = 16;\n\tmsg.xonChar = 17;\n\tmsg.xoffChar = 19;\n\n\t \n\tif (reset_port == 1) {\n\t\tmsg._txOn = 1;\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 1;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0xff;\n\t\tmsg.enablePort = 1;\n\t\tmsg.disablePort = 0;\n\t}\n\t \n\telse if (reset_port == 2) {\n\t\tmsg._txOn = 0;\n\t\tmsg._txOff = 1;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 1;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0;\n\t\tmsg.enablePort = 0;\n\t\tmsg.disablePort = 1;\n\t}\n\t \n\telse {\n\t\tmsg._txOn = (!p_priv->break_on);\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 0;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0x0;\n\t\tmsg.enablePort = 0;\n\t\tmsg.disablePort = 0;\n\t}\n\n\t \n\tmsg.setRts = 0xff;\n\tmsg.rts = p_priv->rts_state;\n\n\tmsg.setDtr = 0xff;\n\tmsg.dtr = p_priv->dtr_state;\n\n\tp_priv->resend_cont = 0;\n\n\t \n\n\tif (d_details->product_id == keyspan_usa49wg_product_id) {\n\t\tdr = (void *)(s_priv->ctrl_buf);\n\t\tdr->bRequestType = USB_TYPE_VENDOR | USB_DIR_OUT;\n\t\tdr->bRequest = 0xB0;\t \n\t\tdr->wValue = 0;\n\t\tdr->wIndex = 0;\n\t\tdr->wLength = cpu_to_le16(sizeof(msg));\n\n\t\tmemcpy(s_priv->glocont_buf, &msg, sizeof(msg));\n\n\t\tusb_fill_control_urb(this_urb, serial->dev,\n\t\t\t\tusb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t(unsigned char *)dr, s_priv->glocont_buf,\n\t\t\t\tsizeof(msg), usa49_glocont_callback, serial);\n\n\t} else {\n\t\tmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\n\n\t\t \n\t\tthis_urb->transfer_buffer_length = sizeof(msg);\n\t}\n\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(setup) failed (%d)\\n\", __func__, err);\n\n\treturn 0;\n}\n\nstatic int keyspan_usa90_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port)\n{\n\tstruct keyspan_usa90_portControlMessage\tmsg;\n\tstruct keyspan_serial_private \t\t*s_priv;\n\tstruct keyspan_port_private \t\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct urb\t\t\t\t*this_urb;\n\tint \t\t\t\t\terr;\n\tu8\t\t\t\t\t\tprescaler;\n\n\ts_priv = usb_get_serial_data(serial);\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = s_priv->device_details;\n\n\t \n\tthis_urb = p_priv->outcont_urb;\n\tif (this_urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - oops no urb.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tif ((reset_port + 1) > p_priv->resend_cont)\n\t\tp_priv->resend_cont = reset_port + 1;\n\tif (this_urb->status == -EINPROGRESS) {\n\t\tdev_dbg(&port->dev, \"%s already writing\\n\", __func__);\n\t\tmdelay(5);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct keyspan_usa90_portControlMessage));\n\n\t \n\tif (p_priv->old_baud != p_priv->baud) {\n\t\tp_priv->old_baud = p_priv->baud;\n\t\tmsg.setClocking = 0x01;\n\t\tif (d_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t\t\t   &msg.baudHi, &msg.baudLo, &prescaler, 0) == KEYSPAN_INVALID_BAUD_RATE) {\n\t\t\tdev_dbg(&port->dev, \"%s - Invalid baud rate %d requested, using 9600.\\n\",\n\t\t\t\t__func__, p_priv->baud);\n\t\t\tp_priv->baud = 9600;\n\t\t\td_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t&msg.baudHi, &msg.baudLo, &prescaler, 0);\n\t\t}\n\t\tmsg.setRxMode = 1;\n\t\tmsg.setTxMode = 1;\n\t}\n\n\t \n\tif (p_priv->baud > 57600) {\n\t\tmsg.rxMode = RXMODE_DMA;\n\t\tmsg.txMode = TXMODE_DMA;\n\t} else {\n\t\tmsg.rxMode = RXMODE_BYHAND;\n\t\tmsg.txMode = TXMODE_BYHAND;\n\t}\n\n\tmsg.lcr = (p_priv->cflag & CSTOPB) ? STOPBITS_678_2 : STOPBITS_5678_1;\n\tswitch (p_priv->cflag & CSIZE) {\n\tcase CS5:\n\t\tmsg.lcr |= USA_DATABITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmsg.lcr |= USA_DATABITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmsg.lcr |= USA_DATABITS_7;\n\t\tbreak;\n\tcase CS8:\n\t\tmsg.lcr |= USA_DATABITS_8;\n\t\tbreak;\n\t}\n\tif (p_priv->cflag & PARENB) {\n\t\t \n\t\tmsg.lcr |= (p_priv->cflag & PARODD) ?\n\t\t\tUSA_PARITY_ODD : USA_PARITY_EVEN;\n\t}\n\tif (p_priv->old_cflag != p_priv->cflag) {\n\t\tp_priv->old_cflag = p_priv->cflag;\n\t\tmsg.setLcr = 0x01;\n\t}\n\n\tif (p_priv->flow_control == flow_cts)\n\t\tmsg.txFlowControl = TXFLOW_CTS;\n\tmsg.setTxFlowControl = 0x01;\n\tmsg.setRxFlowControl = 0x01;\n\n\tmsg.rxForwardingLength = 16;\n\tmsg.rxForwardingTimeout = 16;\n\tmsg.txAckSetting = 0;\n\tmsg.xonChar = 17;\n\tmsg.xoffChar = 19;\n\n\t \n\tif (reset_port == 1) {\n\t\tmsg.portEnabled = 1;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t}\n\t \n\telse if (reset_port == 2)\n\t\tmsg.portEnabled = 0;\n\t \n\telse {\n\t\tmsg.portEnabled = 1;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t}\n\n\t \n\tmsg.setRts = 0x01;\n\tmsg.rts = p_priv->rts_state;\n\n\tmsg.setDtr = 0x01;\n\tmsg.dtr = p_priv->dtr_state;\n\n\tp_priv->resend_cont = 0;\n\tmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\n\n\t \n\tthis_urb->transfer_buffer_length = sizeof(msg);\n\n\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(setup) failed (%d)\\n\", __func__, err);\n\treturn 0;\n}\n\nstatic int keyspan_usa67_send_setup(struct usb_serial *serial,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    int reset_port)\n{\n\tstruct keyspan_usa67_portControlMessage\tmsg;\n\tstruct keyspan_serial_private \t\t*s_priv;\n\tstruct keyspan_port_private \t\t*p_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\tstruct urb\t\t\t\t*this_urb;\n\tint \t\t\t\t\terr, device_port;\n\n\ts_priv = usb_get_serial_data(serial);\n\tp_priv = usb_get_serial_port_data(port);\n\td_details = s_priv->device_details;\n\n\tthis_urb = s_priv->glocont_urb;\n\n\t \n\tdevice_port = port->port_number;\n\n\t \n\tif (this_urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - oops no urb for port.\\n\", __func__);\n\t\treturn -1;\n\t}\n\n\t \n\tif ((reset_port + 1) > p_priv->resend_cont)\n\t\tp_priv->resend_cont = reset_port + 1;\n\tif (this_urb->status == -EINPROGRESS) {\n\t\t \n\t\tmdelay(5);\n\t\treturn -1;\n\t}\n\n\tmemset(&msg, 0, sizeof(struct keyspan_usa67_portControlMessage));\n\n\tmsg.port = device_port;\n\n\t \n\tif (p_priv->old_baud != p_priv->baud) {\n\t\tp_priv->old_baud = p_priv->baud;\n\t\tmsg.setClocking = 0xff;\n\t\tif (d_details->calculate_baud_rate(port, p_priv->baud, d_details->baudclk,\n\t\t\t\t\t\t   &msg.baudHi, &msg.baudLo, &msg.prescaler,\n\t\t\t\t\t\t   device_port) == KEYSPAN_INVALID_BAUD_RATE) {\n\t\t\tdev_dbg(&port->dev, \"%s - Invalid baud rate %d requested, using 9600.\\n\",\n\t\t\t\t__func__, p_priv->baud);\n\t\t\tmsg.baudLo = 0;\n\t\t\tmsg.baudHi = 125;\t \n\t\t\tmsg.prescaler = 10;\n\t\t}\n\t\tmsg.setPrescaler = 0xff;\n\t}\n\n\tmsg.lcr = (p_priv->cflag & CSTOPB) ? STOPBITS_678_2 : STOPBITS_5678_1;\n\tswitch (p_priv->cflag & CSIZE) {\n\tcase CS5:\n\t\tmsg.lcr |= USA_DATABITS_5;\n\t\tbreak;\n\tcase CS6:\n\t\tmsg.lcr |= USA_DATABITS_6;\n\t\tbreak;\n\tcase CS7:\n\t\tmsg.lcr |= USA_DATABITS_7;\n\t\tbreak;\n\tcase CS8:\n\t\tmsg.lcr |= USA_DATABITS_8;\n\t\tbreak;\n\t}\n\tif (p_priv->cflag & PARENB) {\n\t\t \n\t\tmsg.lcr |= (p_priv->cflag & PARODD) ?\n\t\t\t\t\tUSA_PARITY_ODD : USA_PARITY_EVEN;\n\t}\n\tmsg.setLcr = 0xff;\n\n\tmsg.ctsFlowControl = (p_priv->flow_control == flow_cts);\n\tmsg.xonFlowControl = 0;\n\tmsg.setFlowControl = 0xff;\n\tmsg.forwardingLength = 16;\n\tmsg.xonChar = 17;\n\tmsg.xoffChar = 19;\n\n\tif (reset_port == 1) {\n\t\t \n\t\tmsg._txOn = 1;\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 1;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0xff;\n\t} else if (reset_port == 2) {\n\t\t \n\t\tmsg._txOn = 0;\n\t\tmsg._txOff = 1;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = 0;\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 1;\n\t\tmsg.rxFlush = 1;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0;\n\t} else {\n\t\t \n\t\tmsg._txOn = (!p_priv->break_on);\n\t\tmsg._txOff = 0;\n\t\tmsg.txFlush = 0;\n\t\tmsg.txBreak = (p_priv->break_on);\n\t\tmsg.rxOn = 0;\n\t\tmsg.rxOff = 0;\n\t\tmsg.rxFlush = 0;\n\t\tmsg.rxForward = 0;\n\t\tmsg.returnStatus = 0;\n\t\tmsg.resetDataToggle = 0x0;\n\t}\n\n\t \n\tmsg.setTxTriState_setRts = 0xff;\n\tmsg.txTriState_rts = p_priv->rts_state;\n\n\tmsg.setHskoa_setDtr = 0xff;\n\tmsg.hskoa_dtr = p_priv->dtr_state;\n\n\tp_priv->resend_cont = 0;\n\n\tmemcpy(this_urb->transfer_buffer, &msg, sizeof(msg));\n\n\t \n\tthis_urb->transfer_buffer_length = sizeof(msg);\n\n\terr = usb_submit_urb(this_urb, GFP_ATOMIC);\n\tif (err != 0)\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(setup) failed (%d)\\n\", __func__, err);\n\treturn 0;\n}\n\nstatic void keyspan_send_setup(struct usb_serial_port *port, int reset_port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct keyspan_serial_private *s_priv;\n\tconst struct keyspan_device_details *d_details;\n\n\ts_priv = usb_get_serial_data(serial);\n\td_details = s_priv->device_details;\n\n\tswitch (d_details->msg_format) {\n\tcase msg_usa26:\n\t\tkeyspan_usa26_send_setup(serial, port, reset_port);\n\t\tbreak;\n\tcase msg_usa28:\n\t\tkeyspan_usa28_send_setup(serial, port, reset_port);\n\t\tbreak;\n\tcase msg_usa49:\n\t\tkeyspan_usa49_send_setup(serial, port, reset_port);\n\t\tbreak;\n\tcase msg_usa90:\n\t\tkeyspan_usa90_send_setup(serial, port, reset_port);\n\t\tbreak;\n\tcase msg_usa67:\n\t\tkeyspan_usa67_send_setup(serial, port, reset_port);\n\t\tbreak;\n\t}\n}\n\n\n \nstatic int keyspan_startup(struct usb_serial *serial)\n{\n\tint\t\t\t\ti, err;\n\tstruct keyspan_serial_private \t*s_priv;\n\tconst struct keyspan_device_details\t*d_details;\n\n\tfor (i = 0; (d_details = keyspan_devices[i]) != NULL; ++i)\n\t\tif (d_details->product_id ==\n\t\t\t\tle16_to_cpu(serial->dev->descriptor.idProduct))\n\t\t\tbreak;\n\tif (d_details == NULL) {\n\t\tdev_err(&serial->dev->dev, \"%s - unknown product id %x\\n\",\n\t\t    __func__, le16_to_cpu(serial->dev->descriptor.idProduct));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\ts_priv = kzalloc(sizeof(struct keyspan_serial_private), GFP_KERNEL);\n\tif (!s_priv)\n\t\treturn -ENOMEM;\n\n\ts_priv->instat_buf = kzalloc(INSTAT_BUFLEN, GFP_KERNEL);\n\tif (!s_priv->instat_buf)\n\t\tgoto err_instat_buf;\n\n\ts_priv->indat_buf = kzalloc(INDAT49W_BUFLEN, GFP_KERNEL);\n\tif (!s_priv->indat_buf)\n\t\tgoto err_indat_buf;\n\n\ts_priv->glocont_buf = kzalloc(GLOCONT_BUFLEN, GFP_KERNEL);\n\tif (!s_priv->glocont_buf)\n\t\tgoto err_glocont_buf;\n\n\ts_priv->ctrl_buf = kzalloc(sizeof(struct usb_ctrlrequest), GFP_KERNEL);\n\tif (!s_priv->ctrl_buf)\n\t\tgoto err_ctrl_buf;\n\n\ts_priv->device_details = d_details;\n\tusb_set_serial_data(serial, s_priv);\n\n\tkeyspan_setup_urbs(serial);\n\n\tif (s_priv->instat_urb != NULL) {\n\t\terr = usb_submit_urb(s_priv->instat_urb, GFP_KERNEL);\n\t\tif (err != 0)\n\t\t\tdev_dbg(&serial->dev->dev, \"%s - submit instat urb failed %d\\n\", __func__, err);\n\t}\n\tif (s_priv->indat_urb != NULL) {\n\t\terr = usb_submit_urb(s_priv->indat_urb, GFP_KERNEL);\n\t\tif (err != 0)\n\t\t\tdev_dbg(&serial->dev->dev, \"%s - submit indat urb failed %d\\n\", __func__, err);\n\t}\n\n\treturn 0;\n\nerr_ctrl_buf:\n\tkfree(s_priv->glocont_buf);\nerr_glocont_buf:\n\tkfree(s_priv->indat_buf);\nerr_indat_buf:\n\tkfree(s_priv->instat_buf);\nerr_instat_buf:\n\tkfree(s_priv);\n\n\treturn -ENOMEM;\n}\n\nstatic void keyspan_disconnect(struct usb_serial *serial)\n{\n\tstruct keyspan_serial_private *s_priv;\n\n\ts_priv = usb_get_serial_data(serial);\n\n\tusb_kill_urb(s_priv->instat_urb);\n\tusb_kill_urb(s_priv->glocont_urb);\n\tusb_kill_urb(s_priv->indat_urb);\n}\n\nstatic void keyspan_release(struct usb_serial *serial)\n{\n\tstruct keyspan_serial_private *s_priv;\n\n\ts_priv = usb_get_serial_data(serial);\n\n\t \n\tusb_kill_urb(s_priv->instat_urb);\n\tusb_kill_urb(s_priv->indat_urb);\n\n\tusb_free_urb(s_priv->instat_urb);\n\tusb_free_urb(s_priv->indat_urb);\n\tusb_free_urb(s_priv->glocont_urb);\n\n\tkfree(s_priv->ctrl_buf);\n\tkfree(s_priv->glocont_buf);\n\tkfree(s_priv->indat_buf);\n\tkfree(s_priv->instat_buf);\n\n\tkfree(s_priv);\n}\n\nstatic int keyspan_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct keyspan_serial_private *s_priv;\n\tstruct keyspan_port_private *p_priv;\n\tconst struct keyspan_device_details *d_details;\n\tstruct callbacks *cback;\n\tint endp;\n\tint port_num;\n\tint i;\n\n\ts_priv = usb_get_serial_data(serial);\n\td_details = s_priv->device_details;\n\n\tp_priv = kzalloc(sizeof(*p_priv), GFP_KERNEL);\n\tif (!p_priv)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->in_buffer); ++i) {\n\t\tp_priv->in_buffer[i] = kzalloc(IN_BUFLEN, GFP_KERNEL);\n\t\tif (!p_priv->in_buffer[i])\n\t\t\tgoto err_free_in_buffer;\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->out_buffer); ++i) {\n\t\tp_priv->out_buffer[i] = kzalloc(OUT_BUFLEN, GFP_KERNEL);\n\t\tif (!p_priv->out_buffer[i])\n\t\t\tgoto err_free_out_buffer;\n\t}\n\n\tp_priv->inack_buffer = kzalloc(INACK_BUFLEN, GFP_KERNEL);\n\tif (!p_priv->inack_buffer)\n\t\tgoto err_free_out_buffer;\n\n\tp_priv->outcont_buffer = kzalloc(OUTCONT_BUFLEN, GFP_KERNEL);\n\tif (!p_priv->outcont_buffer)\n\t\tgoto err_free_inack_buffer;\n\n\tp_priv->device_details = d_details;\n\n\t \n\tcback = &keyspan_callbacks[d_details->msg_format];\n\n\tport_num = port->port_number;\n\n\t \n\tendp = d_details->indat_endpoints[port_num];\n\tfor (i = 0; i <= d_details->indat_endp_flip; ++i, ++endp) {\n\t\tp_priv->in_urbs[i] = keyspan_setup_urb(serial, endp,\n\t\t\t\t\t\tUSB_DIR_IN, port,\n\t\t\t\t\t\tp_priv->in_buffer[i],\n\t\t\t\t\t\tIN_BUFLEN,\n\t\t\t\t\t\tcback->indat_callback);\n\t}\n\t \n\tendp = d_details->outdat_endpoints[port_num];\n\tfor (i = 0; i <= d_details->outdat_endp_flip; ++i, ++endp) {\n\t\tp_priv->out_urbs[i] = keyspan_setup_urb(serial, endp,\n\t\t\t\t\t\tUSB_DIR_OUT, port,\n\t\t\t\t\t\tp_priv->out_buffer[i],\n\t\t\t\t\t\tOUT_BUFLEN,\n\t\t\t\t\t\tcback->outdat_callback);\n\t}\n\t \n\tp_priv->inack_urb = keyspan_setup_urb(serial,\n\t\t\t\t\td_details->inack_endpoints[port_num],\n\t\t\t\t\tUSB_DIR_IN, port,\n\t\t\t\t\tp_priv->inack_buffer,\n\t\t\t\t\tINACK_BUFLEN,\n\t\t\t\t\tcback->inack_callback);\n\t \n\tp_priv->outcont_urb = keyspan_setup_urb(serial,\n\t\t\t\t\td_details->outcont_endpoints[port_num],\n\t\t\t\t\tUSB_DIR_OUT, port,\n\t\t\t\t\tp_priv->outcont_buffer,\n\t\t\t\t\tOUTCONT_BUFLEN,\n\t\t\t\t\t cback->outcont_callback);\n\n\tusb_set_serial_port_data(port, p_priv);\n\n\treturn 0;\n\nerr_free_inack_buffer:\n\tkfree(p_priv->inack_buffer);\nerr_free_out_buffer:\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->out_buffer); ++i)\n\t\tkfree(p_priv->out_buffer[i]);\nerr_free_in_buffer:\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->in_buffer); ++i)\n\t\tkfree(p_priv->in_buffer[i]);\n\tkfree(p_priv);\n\n\treturn -ENOMEM;\n}\n\nstatic void keyspan_port_remove(struct usb_serial_port *port)\n{\n\tstruct keyspan_port_private *p_priv;\n\tint i;\n\n\tp_priv = usb_get_serial_port_data(port);\n\n\tusb_kill_urb(p_priv->inack_urb);\n\tusb_kill_urb(p_priv->outcont_urb);\n\tfor (i = 0; i < 2; i++) {\n\t\tusb_kill_urb(p_priv->in_urbs[i]);\n\t\tusb_kill_urb(p_priv->out_urbs[i]);\n\t}\n\n\tusb_free_urb(p_priv->inack_urb);\n\tusb_free_urb(p_priv->outcont_urb);\n\tfor (i = 0; i < 2; i++) {\n\t\tusb_free_urb(p_priv->in_urbs[i]);\n\t\tusb_free_urb(p_priv->out_urbs[i]);\n\t}\n\n\tkfree(p_priv->outcont_buffer);\n\tkfree(p_priv->inack_buffer);\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->out_buffer); ++i)\n\t\tkfree(p_priv->out_buffer[i]);\n\tfor (i = 0; i < ARRAY_SIZE(p_priv->in_buffer); ++i)\n\t\tkfree(p_priv->in_buffer[i]);\n\n\tkfree(p_priv);\n}\n\n \nstatic struct usb_serial_driver keyspan_pre_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"keyspan_no_firm\",\n\t},\n\t.description\t\t= \"Keyspan - (without firmware)\",\n\t.id_table\t\t= keyspan_pre_ids,\n\t.num_ports\t\t= 1,\n\t.attach\t\t\t= keyspan_fake_startup,\n};\n\nstatic struct usb_serial_driver keyspan_1port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"keyspan_1\",\n\t},\n\t.description\t\t= \"Keyspan 1 port adapter\",\n\t.id_table\t\t= keyspan_1port_ids,\n\t.num_ports\t\t= 1,\n\t.open\t\t\t= keyspan_open,\n\t.close\t\t\t= keyspan_close,\n\t.dtr_rts\t\t= keyspan_dtr_rts,\n\t.write\t\t\t= keyspan_write,\n\t.write_room\t\t= keyspan_write_room,\n\t.set_termios\t\t= keyspan_set_termios,\n\t.break_ctl\t\t= keyspan_break_ctl,\n\t.tiocmget\t\t= keyspan_tiocmget,\n\t.tiocmset\t\t= keyspan_tiocmset,\n\t.attach\t\t\t= keyspan_startup,\n\t.disconnect\t\t= keyspan_disconnect,\n\t.release\t\t= keyspan_release,\n\t.port_probe\t\t= keyspan_port_probe,\n\t.port_remove\t\t= keyspan_port_remove,\n};\n\nstatic struct usb_serial_driver keyspan_2port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"keyspan_2\",\n\t},\n\t.description\t\t= \"Keyspan 2 port adapter\",\n\t.id_table\t\t= keyspan_2port_ids,\n\t.num_ports\t\t= 2,\n\t.open\t\t\t= keyspan_open,\n\t.close\t\t\t= keyspan_close,\n\t.dtr_rts\t\t= keyspan_dtr_rts,\n\t.write\t\t\t= keyspan_write,\n\t.write_room\t\t= keyspan_write_room,\n\t.set_termios\t\t= keyspan_set_termios,\n\t.break_ctl\t\t= keyspan_break_ctl,\n\t.tiocmget\t\t= keyspan_tiocmget,\n\t.tiocmset\t\t= keyspan_tiocmset,\n\t.attach\t\t\t= keyspan_startup,\n\t.disconnect\t\t= keyspan_disconnect,\n\t.release\t\t= keyspan_release,\n\t.port_probe\t\t= keyspan_port_probe,\n\t.port_remove\t\t= keyspan_port_remove,\n};\n\nstatic struct usb_serial_driver keyspan_4port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"keyspan_4\",\n\t},\n\t.description\t\t= \"Keyspan 4 port adapter\",\n\t.id_table\t\t= keyspan_4port_ids,\n\t.num_ports\t\t= 4,\n\t.open\t\t\t= keyspan_open,\n\t.close\t\t\t= keyspan_close,\n\t.dtr_rts\t\t= keyspan_dtr_rts,\n\t.write\t\t\t= keyspan_write,\n\t.write_room\t\t= keyspan_write_room,\n\t.set_termios\t\t= keyspan_set_termios,\n\t.break_ctl\t\t= keyspan_break_ctl,\n\t.tiocmget\t\t= keyspan_tiocmget,\n\t.tiocmset\t\t= keyspan_tiocmset,\n\t.attach\t\t\t= keyspan_startup,\n\t.disconnect\t\t= keyspan_disconnect,\n\t.release\t\t= keyspan_release,\n\t.port_probe\t\t= keyspan_port_probe,\n\t.port_remove\t\t= keyspan_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&keyspan_pre_device, &keyspan_1port_device,\n\t&keyspan_2port_device, &keyspan_4port_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, keyspan_ids_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"keyspan/usa28.fw\");\nMODULE_FIRMWARE(\"keyspan/usa28x.fw\");\nMODULE_FIRMWARE(\"keyspan/usa28xa.fw\");\nMODULE_FIRMWARE(\"keyspan/usa28xb.fw\");\nMODULE_FIRMWARE(\"keyspan/usa19.fw\");\nMODULE_FIRMWARE(\"keyspan/usa19qi.fw\");\nMODULE_FIRMWARE(\"keyspan/mpr.fw\");\nMODULE_FIRMWARE(\"keyspan/usa19qw.fw\");\nMODULE_FIRMWARE(\"keyspan/usa18x.fw\");\nMODULE_FIRMWARE(\"keyspan/usa19w.fw\");\nMODULE_FIRMWARE(\"keyspan/usa49w.fw\");\nMODULE_FIRMWARE(\"keyspan/usa49wlc.fw\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}