{
  "module_name": "keyspan_pda.c",
  "hash_id": "a64e1d621db4943812b27e84b88b944381073f1c0540361b4fb44c0d5f4f4bd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/keyspan_pda.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/ezusb.h>\n\n#define DRIVER_AUTHOR \"Brian Warner <warner@lothar.com>, Johan Hovold <johan@kernel.org>\"\n#define DRIVER_DESC \"USB Keyspan PDA Converter driver\"\n\n#define KEYSPAN_TX_THRESHOLD\t128\n\nstruct keyspan_pda_private {\n\tint\t\t\ttx_room;\n\tstruct work_struct\tunthrottle_work;\n\tstruct usb_serial\t*serial;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic int keyspan_pda_write_start(struct usb_serial_port *port);\n\n#define KEYSPAN_VENDOR_ID\t\t0x06cd\n#define KEYSPAN_PDA_FAKE_ID\t\t0x0103\n#define KEYSPAN_PDA_ID\t\t\t0x0104  \n\n \n#define XIRCOM_VENDOR_ID\t\t0x085a\n#define XIRCOM_FAKE_ID\t\t\t0x8027\n#define XIRCOM_FAKE_ID_2\t\t0x8025  \n#define ENTREGA_VENDOR_ID\t\t0x1645\n#define ENTREGA_FAKE_ID\t\t\t0x8093\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_FAKE_ID) },\n\t{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },\n\t{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },\n\t{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_ID) },\n\t{ }\t\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\nstatic const struct usb_device_id id_table_std[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_fake[] = {\n\t{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_FAKE_ID) },\n\t{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },\n\t{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },\n\t{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic int keyspan_pda_get_write_room(struct keyspan_pda_private *priv)\n{\n\tstruct usb_serial_port *port = priv->port;\n\tstruct usb_serial *serial = port->serial;\n\tu8 room;\n\tint rc;\n\n\trc = usb_control_msg_recv(serial->dev,\n\t\t\t\t  0,\n\t\t\t\t  6,  \n\t\t\t\t  USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t  0,  \n\t\t\t\t  0,  \n\t\t\t\t  &room,\n\t\t\t\t  1,\n\t\t\t\t  2000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc) {\n\t\tdev_dbg(&port->dev, \"roomquery failed: %d\\n\", rc);\n\t\treturn rc;\n\t}\n\n\tdev_dbg(&port->dev, \"roomquery says %d\\n\", room);\n\n\treturn room;\n}\n\nstatic void keyspan_pda_request_unthrottle(struct work_struct *work)\n{\n\tstruct keyspan_pda_private *priv =\n\t\tcontainer_of(work, struct keyspan_pda_private, unthrottle_work);\n\tstruct usb_serial_port *port = priv->port;\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\t \n\tresult = usb_control_msg(serial->dev,\n\t\t\t\t usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t 7,  \n\t\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE\n\t\t\t\t | USB_DIR_OUT,\n\t\t\t\t KEYSPAN_TX_THRESHOLD,\n\t\t\t\t 0,  \n\t\t\t\t NULL,\n\t\t\t\t 0,\n\t\t\t\t 2000);\n\tif (result < 0)\n\t\tdev_dbg(&serial->dev->dev, \"%s - error %d from usb_control_msg\\n\",\n\t\t\t__func__, result);\n\t \n\tresult = keyspan_pda_get_write_room(priv);\n\tif (result > KEYSPAN_TX_THRESHOLD) {\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tpriv->tx_room = max(priv->tx_room, result);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\tusb_serial_port_softint(port);\n\t}\n}\n\nstatic void keyspan_pda_rx_interrupt(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned int len = urb->actual_length;\n\tint retval;\n\tint status = urb->status;\n\tstruct keyspan_pda_private *priv;\n\tunsigned long flags;\n\n\tpriv = usb_get_serial_port_data(port);\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tif (len < 1) {\n\t\tdev_warn(&port->dev, \"short message received\\n\");\n\t\tgoto exit;\n\t}\n\n\t \n\tswitch (data[0]) {\n\tcase 0:\n\t\t  \n\t\tif (len < 2)\n\t\t\tbreak;\n\t\ttty_insert_flip_string(&port->port, data + 1, len - 1);\n\t\ttty_flip_buffer_push(&port->port);\n\t\tbreak;\n\tcase 1:\n\t\t \n\t\tif (len < 2) {\n\t\t\tdev_warn(&port->dev, \"short interrupt message received\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tdev_dbg(&port->dev, \"rx int, d1=%d\\n\", data[1]);\n\t\tswitch (data[1]) {\n\t\tcase 1:  \n\t\t\tbreak;\n\t\tcase 2:  \n\t\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t\tpriv->tx_room = max(priv->tx_room, KEYSPAN_TX_THRESHOLD);\n\t\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\t\tkeyspan_pda_write_start(port);\n\n\t\t\tusb_serial_port_softint(port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n}\n\nstatic void keyspan_pda_rx_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\t \n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic void keyspan_pda_rx_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\t \n\tif (usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL))\n\t\tdev_dbg(&port->dev, \"usb_submit_urb(read urb) failed\\n\");\n}\n\nstatic speed_t keyspan_pda_setbaud(struct usb_serial *serial, speed_t baud)\n{\n\tint rc;\n\tint bindex;\n\n\tswitch (baud) {\n\tcase 110:\n\t\tbindex = 0;\n\t\tbreak;\n\tcase 300:\n\t\tbindex = 1;\n\t\tbreak;\n\tcase 1200:\n\t\tbindex = 2;\n\t\tbreak;\n\tcase 2400:\n\t\tbindex = 3;\n\t\tbreak;\n\tcase 4800:\n\t\tbindex = 4;\n\t\tbreak;\n\tcase 9600:\n\t\tbindex = 5;\n\t\tbreak;\n\tcase 19200:\n\t\tbindex = 6;\n\t\tbreak;\n\tcase 38400:\n\t\tbindex = 7;\n\t\tbreak;\n\tcase 57600:\n\t\tbindex = 8;\n\t\tbreak;\n\tcase 115200:\n\t\tbindex = 9;\n\t\tbreak;\n\tdefault:\n\t\tbindex = 5;\t \n\t\tbaud = 9600;\n\t}\n\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t     0,  \n\t\t\t     USB_TYPE_VENDOR\n\t\t\t     | USB_RECIP_INTERFACE\n\t\t\t     | USB_DIR_OUT,  \n\t\t\t     bindex,  \n\t\t\t     0,  \n\t\t\t     NULL,  \n\t\t\t     0,  \n\t\t\t     2000);  \n\tif (rc < 0)\n\t\treturn 0;\n\n\treturn baud;\n}\n\nstatic int keyspan_pda_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tint value;\n\tint result;\n\n\tif (break_state == -1)\n\t\tvalue = 1;  \n\telse\n\t\tvalue = 0;  \n\n\tresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t4,  \n\t\t\tUSB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\tvalue, 0, NULL, 0, 2000);\n\tif (result < 0) {\n\t\tdev_dbg(&port->dev, \"%s - error %d from usb_control_msg\\n\",\n\t\t\t__func__, result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic void keyspan_pda_set_termios(struct tty_struct *tty,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    const struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tspeed_t speed;\n\n\t \n\tspeed = tty_get_baud_rate(tty);\n\tspeed = keyspan_pda_setbaud(serial, speed);\n\n\tif (speed == 0) {\n\t\tdev_dbg(&port->dev, \"can't handle requested baud rate\\n\");\n\t\t \n\t\tspeed = tty_termios_baud_rate(old_termios);\n\t}\n\t \n\ttty_termios_copy_hw(&tty->termios, old_termios);\n\ttty_encode_baud_rate(tty, speed, speed);\n}\n\n \nstatic int keyspan_pda_get_modem_info(struct usb_serial *serial,\n\t\t\t\t      unsigned char *value)\n{\n\tint rc;\n\tu8 data;\n\n\trc = usb_control_msg_recv(serial->dev, 0,\n\t\t\t\t  3,  \n\t\t\t\t  USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t\t\t  0,\n\t\t\t\t  0,\n\t\t\t\t  &data,\n\t\t\t\t  1,\n\t\t\t\t  2000,\n\t\t\t\t  GFP_KERNEL);\n\tif (rc == 0)\n\t\t*value = data;\n\n\treturn rc;\n}\n\nstatic int keyspan_pda_set_modem_info(struct usb_serial *serial,\n\t\t\t\t      unsigned char value)\n{\n\tint rc;\n\trc = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t     3,  \n\t\t\t     USB_TYPE_VENDOR|USB_RECIP_INTERFACE|USB_DIR_OUT,\n\t\t\t     value, 0, NULL, 0, 2000);\n\treturn rc;\n}\n\nstatic int keyspan_pda_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tint rc;\n\tunsigned char status;\n\tint value;\n\n\trc = keyspan_pda_get_modem_info(serial, &status);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tvalue = ((status & BIT(7)) ? TIOCM_DTR : 0) |\n\t\t((status & BIT(6)) ? TIOCM_CAR : 0) |\n\t\t((status & BIT(5)) ? TIOCM_RNG : 0) |\n\t\t((status & BIT(4)) ? TIOCM_DSR : 0) |\n\t\t((status & BIT(3)) ? TIOCM_CTS : 0) |\n\t\t((status & BIT(2)) ? TIOCM_RTS : 0);\n\n\treturn value;\n}\n\nstatic int keyspan_pda_tiocmset(struct tty_struct *tty,\n\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tint rc;\n\tunsigned char status;\n\n\trc = keyspan_pda_get_modem_info(serial, &status);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tif (set & TIOCM_RTS)\n\t\tstatus |= BIT(2);\n\tif (set & TIOCM_DTR)\n\t\tstatus |= BIT(7);\n\n\tif (clear & TIOCM_RTS)\n\t\tstatus &= ~BIT(2);\n\tif (clear & TIOCM_DTR)\n\t\tstatus &= ~BIT(7);\n\trc = keyspan_pda_set_modem_info(serial, status);\n\treturn rc;\n}\n\nstatic int keyspan_pda_write_start(struct usb_serial_port *port)\n{\n\tstruct keyspan_pda_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint count;\n\tint room;\n\tint rc;\n\n\t \n\n\t \n\tspin_lock_irqsave(&port->lock, flags);\n\n\troom = priv->tx_room;\n\tcount = kfifo_len(&port->write_fifo);\n\n\tif (!test_bit(0, &port->write_urbs_free) || count == 0 || room == 0) {\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t\treturn 0;\n\t}\n\t__clear_bit(0, &port->write_urbs_free);\n\n\tif (count > room)\n\t\tcount = room;\n\tif (count > port->bulk_out_size)\n\t\tcount = port->bulk_out_size;\n\n\turb = port->write_urb;\n\tcount = kfifo_out(&port->write_fifo, urb->transfer_buffer, count);\n\turb->transfer_buffer_length = count;\n\n\tport->tx_bytes += count;\n\tpriv->tx_room -= count;\n\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - count = %d, txroom = %d\\n\", __func__, count, room);\n\n\trc = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (rc) {\n\t\tdev_dbg(&port->dev, \"usb_submit_urb(write bulk) failed\\n\");\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tport->tx_bytes -= count;\n\t\tpriv->tx_room = max(priv->tx_room, room + count);\n\t\t__set_bit(0, &port->write_urbs_free);\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\treturn rc;\n\t}\n\n\tif (count == room)\n\t\tschedule_work(&priv->unthrottle_work);\n\n\treturn count;\n}\n\nstatic void keyspan_pda_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tport->tx_bytes -= urb->transfer_buffer_length;\n\t__set_bit(0, &port->write_urbs_free);\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tkeyspan_pda_write_start(port);\n\n\tusb_serial_port_softint(port);\n}\n\nstatic int keyspan_pda_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\tconst unsigned char *buf, int count)\n{\n\tint rc;\n\n\tdev_dbg(&port->dev, \"%s - count = %d\\n\", __func__, count);\n\n\tif (!count)\n\t\treturn 0;\n\n\tcount = kfifo_in_locked(&port->write_fifo, buf, count, &port->lock);\n\n\trc = keyspan_pda_write_start(port);\n\tif (rc)\n\t\treturn rc;\n\n\treturn count;\n}\n\nstatic void keyspan_pda_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct usb_serial *serial = port->serial;\n\n\tif (on)\n\t\tkeyspan_pda_set_modem_info(serial, BIT(7) | BIT(2));\n\telse\n\t\tkeyspan_pda_set_modem_info(serial, 0);\n}\n\n\nstatic int keyspan_pda_open(struct tty_struct *tty,\n\t\t\t\t\tstruct usb_serial_port *port)\n{\n\tstruct keyspan_pda_private *priv = usb_get_serial_port_data(port);\n\tint rc;\n\n\t \n\trc = keyspan_pda_get_write_room(priv);\n\tif (rc < 0)\n\t\treturn rc;\n\n\tspin_lock_irq(&port->lock);\n\tpriv->tx_room = rc;\n\tspin_unlock_irq(&port->lock);\n\n\trc = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (rc) {\n\t\tdev_dbg(&port->dev, \"%s - usb_submit_urb(read int) failed\\n\", __func__);\n\t\treturn rc;\n\t}\n\n\treturn 0;\n}\n\nstatic void keyspan_pda_close(struct usb_serial_port *port)\n{\n\tstruct keyspan_pda_private *priv = usb_get_serial_port_data(port);\n\n\t \n\tusb_kill_urb(port->interrupt_in_urb);\n\tusb_kill_urb(port->write_urb);\n\n\tcancel_work_sync(&priv->unthrottle_work);\n\n\tspin_lock_irq(&port->lock);\n\tkfifo_reset(&port->write_fifo);\n\tspin_unlock_irq(&port->lock);\n}\n\n \nstatic int keyspan_pda_fake_startup(struct usb_serial *serial)\n{\n\tunsigned int vid = le16_to_cpu(serial->dev->descriptor.idVendor);\n\tconst char *fw_name;\n\n\t \n\tezusb_fx1_set_reset(serial->dev, 1);\n\n\tswitch (vid) {\n\tcase KEYSPAN_VENDOR_ID:\n\t\tfw_name = \"keyspan_pda/keyspan_pda.fw\";\n\t\tbreak;\n\tcase XIRCOM_VENDOR_ID:\n\tcase ENTREGA_VENDOR_ID:\n\t\tfw_name = \"keyspan_pda/xircom_pgs.fw\";\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&serial->dev->dev, \"%s: unknown vendor, aborting.\\n\",\n\t\t\t__func__);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ezusb_fx1_ihex_firmware_download(serial->dev, fw_name) < 0) {\n\t\tdev_err(&serial->dev->dev, \"failed to load firmware \\\"%s\\\"\\n\",\n\t\t\tfw_name);\n\t\treturn -ENOENT;\n\t}\n\n\t \n\n\t \n\treturn 1;\n}\n\nMODULE_FIRMWARE(\"keyspan_pda/keyspan_pda.fw\");\nMODULE_FIRMWARE(\"keyspan_pda/xircom_pgs.fw\");\n\nstatic int keyspan_pda_port_probe(struct usb_serial_port *port)\n{\n\n\tstruct keyspan_pda_private *priv;\n\n\tpriv = kmalloc(sizeof(struct keyspan_pda_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&priv->unthrottle_work, keyspan_pda_request_unthrottle);\n\tpriv->port = port;\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void keyspan_pda_port_remove(struct usb_serial_port *port)\n{\n\tstruct keyspan_pda_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic struct usb_serial_driver keyspan_pda_fake_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"keyspan_pda_pre\",\n\t},\n\t.description =\t\t\"Keyspan PDA - (prerenumeration)\",\n\t.id_table =\t\tid_table_fake,\n\t.num_ports =\t\t1,\n\t.attach =\t\tkeyspan_pda_fake_startup,\n};\n\nstatic struct usb_serial_driver keyspan_pda_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"keyspan_pda\",\n\t},\n\t.description =\t\t\"Keyspan PDA\",\n\t.id_table =\t\tid_table_std,\n\t.num_ports =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.num_interrupt_in =\t1,\n\t.dtr_rts =\t\tkeyspan_pda_dtr_rts,\n\t.open =\t\t\tkeyspan_pda_open,\n\t.close =\t\tkeyspan_pda_close,\n\t.write =\t\tkeyspan_pda_write,\n\t.write_bulk_callback =\tkeyspan_pda_write_bulk_callback,\n\t.read_int_callback =\tkeyspan_pda_rx_interrupt,\n\t.throttle =\t\tkeyspan_pda_rx_throttle,\n\t.unthrottle =\t\tkeyspan_pda_rx_unthrottle,\n\t.set_termios =\t\tkeyspan_pda_set_termios,\n\t.break_ctl =\t\tkeyspan_pda_break_ctl,\n\t.tiocmget =\t\tkeyspan_pda_tiocmget,\n\t.tiocmset =\t\tkeyspan_pda_tiocmset,\n\t.port_probe =\t\tkeyspan_pda_port_probe,\n\t.port_remove =\t\tkeyspan_pda_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&keyspan_pda_device,\n\t&keyspan_pda_fake_device,\n\tNULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}