{
  "module_name": "safe_serial.c",
  "hash_id": "190d525d6a1be3f8c890e9ccbbf937b2f455a47e482927febadf1141ac2697fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/safe_serial.c",
  "human_readable_source": "\n \n\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/gfp.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstatic bool safe = true;\nstatic bool padded = IS_ENABLED(CONFIG_USB_SERIAL_SAFE_PADDED);\n\n#define DRIVER_AUTHOR \"sl@lineo.com, tbr@lineo.com, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"USB Safe Encapsulated Serial\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(safe, bool, 0);\nMODULE_PARM_DESC(safe, \"Turn Safe Encapsulation On/Off\");\n\nmodule_param(padded, bool, 0);\nMODULE_PARM_DESC(padded, \"Pad to full wMaxPacketSize On/Off\");\n\n#define CDC_DEVICE_CLASS                        0x02\n\n#define CDC_INTERFACE_CLASS                     0x02\n#define CDC_INTERFACE_SUBCLASS                  0x06\n\n#define LINEO_INTERFACE_CLASS                   0xff\n\n#define LINEO_INTERFACE_SUBCLASS_SAFENET        0x01\n#define LINEO_SAFENET_CRC                       0x01\n#define LINEO_SAFENET_CRC_PADDED                0x02\n\n#define LINEO_INTERFACE_SUBCLASS_SAFESERIAL     0x02\n#define LINEO_SAFESERIAL_CRC                    0x01\n#define LINEO_SAFESERIAL_CRC_PADDED             0x02\n\n\n#define MY_USB_DEVICE(vend, prod, dc, ic, isc) \\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE | \\\n\t\t       USB_DEVICE_ID_MATCH_DEV_CLASS | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS | \\\n\t\t       USB_DEVICE_ID_MATCH_INT_SUBCLASS, \\\n\t.idVendor = (vend), \\\n\t.idProduct = (prod),\\\n\t.bDeviceClass = (dc),\\\n\t.bInterfaceClass = (ic), \\\n\t.bInterfaceSubClass = (isc),\n\nstatic const struct usb_device_id id_table[] = {\n\t{MY_USB_DEVICE(0x49f, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x3f0, 0x2101, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x4dd, 0x8001, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x4dd, 0x8002, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x4dd, 0x8003, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x4dd, 0x8004, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{MY_USB_DEVICE(0x5f9, 0xffff, CDC_DEVICE_CLASS, LINEO_INTERFACE_CLASS, LINEO_INTERFACE_SUBCLASS_SAFESERIAL)},\t \n\t{}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic const __u16 crc10_table[256] = {\n\t0x000, 0x233, 0x255, 0x066, 0x299, 0x0aa, 0x0cc, 0x2ff,\n\t0x301, 0x132, 0x154, 0x367, 0x198, 0x3ab, 0x3cd, 0x1fe,\n\t0x031, 0x202, 0x264, 0x057, 0x2a8, 0x09b, 0x0fd, 0x2ce,\n\t0x330, 0x103, 0x165, 0x356, 0x1a9, 0x39a, 0x3fc, 0x1cf,\n\t0x062, 0x251, 0x237, 0x004, 0x2fb, 0x0c8, 0x0ae, 0x29d,\n\t0x363, 0x150, 0x136, 0x305, 0x1fa, 0x3c9, 0x3af, 0x19c,\n\t0x053, 0x260, 0x206, 0x035, 0x2ca, 0x0f9, 0x09f, 0x2ac,\n\t0x352, 0x161, 0x107, 0x334, 0x1cb, 0x3f8, 0x39e, 0x1ad,\n\t0x0c4, 0x2f7, 0x291, 0x0a2, 0x25d, 0x06e, 0x008, 0x23b,\n\t0x3c5, 0x1f6, 0x190, 0x3a3, 0x15c, 0x36f, 0x309, 0x13a,\n\t0x0f5, 0x2c6, 0x2a0, 0x093, 0x26c, 0x05f, 0x039, 0x20a,\n\t0x3f4, 0x1c7, 0x1a1, 0x392, 0x16d, 0x35e, 0x338, 0x10b,\n\t0x0a6, 0x295, 0x2f3, 0x0c0, 0x23f, 0x00c, 0x06a, 0x259,\n\t0x3a7, 0x194, 0x1f2, 0x3c1, 0x13e, 0x30d, 0x36b, 0x158,\n\t0x097, 0x2a4, 0x2c2, 0x0f1, 0x20e, 0x03d, 0x05b, 0x268,\n\t0x396, 0x1a5, 0x1c3, 0x3f0, 0x10f, 0x33c, 0x35a, 0x169,\n\t0x188, 0x3bb, 0x3dd, 0x1ee, 0x311, 0x122, 0x144, 0x377,\n\t0x289, 0x0ba, 0x0dc, 0x2ef, 0x010, 0x223, 0x245, 0x076,\n\t0x1b9, 0x38a, 0x3ec, 0x1df, 0x320, 0x113, 0x175, 0x346,\n\t0x2b8, 0x08b, 0x0ed, 0x2de, 0x021, 0x212, 0x274, 0x047,\n\t0x1ea, 0x3d9, 0x3bf, 0x18c, 0x373, 0x140, 0x126, 0x315,\n\t0x2eb, 0x0d8, 0x0be, 0x28d, 0x072, 0x241, 0x227, 0x014,\n\t0x1db, 0x3e8, 0x38e, 0x1bd, 0x342, 0x171, 0x117, 0x324,\n\t0x2da, 0x0e9, 0x08f, 0x2bc, 0x043, 0x270, 0x216, 0x025,\n\t0x14c, 0x37f, 0x319, 0x12a, 0x3d5, 0x1e6, 0x180, 0x3b3,\n\t0x24d, 0x07e, 0x018, 0x22b, 0x0d4, 0x2e7, 0x281, 0x0b2,\n\t0x17d, 0x34e, 0x328, 0x11b, 0x3e4, 0x1d7, 0x1b1, 0x382,\n\t0x27c, 0x04f, 0x029, 0x21a, 0x0e5, 0x2d6, 0x2b0, 0x083,\n\t0x12e, 0x31d, 0x37b, 0x148, 0x3b7, 0x184, 0x1e2, 0x3d1,\n\t0x22f, 0x01c, 0x07a, 0x249, 0x0b6, 0x285, 0x2e3, 0x0d0,\n\t0x11f, 0x32c, 0x34a, 0x179, 0x386, 0x1b5, 0x1d3, 0x3e0,\n\t0x21e, 0x02d, 0x04b, 0x278, 0x087, 0x2b4, 0x2d2, 0x0e1,\n};\n\n#define CRC10_INITFCS     0x000\t \n#define CRC10_GOODFCS     0x000\t \n#define CRC10_FCS(fcs, c) ((((fcs) << 8) & 0x3ff) ^ crc10_table[((fcs) >> 2) & 0xff] ^ (c))\n\n \nstatic inline __u16 fcs_compute10(unsigned char *sp, int len, __u16 fcs)\n{\n\tfor (; len-- > 0; fcs = CRC10_FCS(fcs, *sp++));\n\treturn fcs;\n}\n\nstatic void safe_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned char length = urb->actual_length;\n\tint actual_length;\n\t__u16 fcs;\n\n\tif (!length)\n\t\treturn;\n\n\tif (!safe)\n\t\tgoto out;\n\n\tif (length < 2) {\n\t\tdev_err(&port->dev, \"malformed packet\\n\");\n\t\treturn;\n\t}\n\n\tfcs = fcs_compute10(data, length, CRC10_INITFCS);\n\tif (fcs) {\n\t\tdev_err(&port->dev, \"%s - bad CRC %x\\n\", __func__, fcs);\n\t\treturn;\n\t}\n\n\tactual_length = data[length - 2] >> 2;\n\tif (actual_length > (length - 2)) {\n\t\tdev_err(&port->dev, \"%s - inconsistent lengths %d:%d\\n\",\n\t\t\t\t__func__, actual_length, length);\n\t\treturn;\n\t}\n\tdev_info(&urb->dev->dev, \"%s - actual: %d\\n\", __func__, actual_length);\n\tlength = actual_length;\nout:\n\ttty_insert_flip_string(&port->port, data, length);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int safe_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tunsigned char *buf = dest;\n\tint count;\n\tint trailer_len;\n\tint pkt_len;\n\t__u16 fcs;\n\n\ttrailer_len = safe ? 2 : 0;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf, size - trailer_len,\n\t\t\t\t\t\t\t\t&port->lock);\n\tif (!safe)\n\t\treturn count;\n\n\t \n\tif (padded) {\n\t\tpkt_len = size;\n\t\tmemset(buf + count, '0', pkt_len - count - trailer_len);\n\t} else {\n\t\tpkt_len = count + trailer_len;\n\t}\n\n\t \n\tbuf[pkt_len - 2] = count << 2;\n\tbuf[pkt_len - 1] = 0;\n\n\t \n\tfcs = fcs_compute10(buf, pkt_len, CRC10_INITFCS);\n\tbuf[pkt_len - 2] |= fcs >> 8;\n\tbuf[pkt_len - 1] |= fcs & 0xff;\n\n\treturn pkt_len;\n}\n\nstatic int safe_startup(struct usb_serial *serial)\n{\n\tstruct usb_interface_descriptor\t*desc;\n\n\tif (serial->dev->descriptor.bDeviceClass != CDC_DEVICE_CLASS)\n\t\treturn -ENODEV;\n\n\tdesc = &serial->interface->cur_altsetting->desc;\n\n\tif (desc->bInterfaceClass != LINEO_INTERFACE_CLASS)\n\t\treturn -ENODEV;\n\tif (desc->bInterfaceSubClass != LINEO_INTERFACE_SUBCLASS_SAFESERIAL)\n\t\treturn -ENODEV;\n\n\tswitch (desc->bInterfaceProtocol) {\n\tcase LINEO_SAFESERIAL_CRC:\n\t\tbreak;\n\tcase LINEO_SAFESERIAL_CRC_PADDED:\n\t\tpadded = true;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct usb_serial_driver safe_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"safe_serial\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.process_read_urb =\tsafe_process_read_urb,\n\t.prepare_write_buffer =\tsafe_prepare_write_buffer,\n\t.attach =\t\tsafe_startup,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&safe_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}