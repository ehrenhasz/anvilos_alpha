{
  "module_name": "ipw.c",
  "hash_id": "bb0c74107065508f0b2eb310719f9ef547cfaccd8e909895e5fa8153cebadc5d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ipw.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n#include \"usb-wwan.h\"\n\n#define DRIVER_AUTHOR\t\"Roelf Diedericks\"\n#define DRIVER_DESC\t\"IPWireless tty driver\"\n\n#define IPW_TTY_MAJOR\t240\t \n#define IPW_TTY_MINORS\t256\t \n\n#define USB_IPW_MAGIC\t0x6d02\t \n\n\n \n#define EVENT_BUFFER_SIZE\t0xFF\n#define CHAR2INT16(c1, c0)\t(((u32)((c1) & 0xff) << 8) + (u32)((c0) & 0xff))\n\n \n#define IPW_VID\t\t0x0bc3\n#define IPW_PID\t\t0x0001\n\n\n \n\n \nenum {\n\tipw_sio_b256000 = 0x000e,\n\tipw_sio_b128000 = 0x001d,\n\tipw_sio_b115200 = 0x0020,\n\tipw_sio_b57600  = 0x0040,\n\tipw_sio_b56000  = 0x0042,\n\tipw_sio_b38400  = 0x0060,\n\tipw_sio_b19200  = 0x00c0,\n\tipw_sio_b14400  = 0x0100,\n\tipw_sio_b9600   = 0x0180,\n\tipw_sio_b4800   = 0x0300,\n\tipw_sio_b2400   = 0x0600,\n\tipw_sio_b1200   = 0x0c00,\n\tipw_sio_b600    = 0x1800\n};\n\n \n#define ipw_dtb_7\t\t0x700\n#define ipw_dtb_8\t\t0x810\t \n\t\t\t\t\t \n\n \n#define IPW_SIO_RXCTL\t\t0x00\t \n#define IPW_SIO_SET_BAUD\t0x01\t \n#define IPW_SIO_SET_LINE\t0x03\t \n#define IPW_SIO_SET_PIN\t\t0x03\t \n#define IPW_SIO_POLL\t\t0x08\t \n#define IPW_SIO_INIT\t\t0x11\t \n#define IPW_SIO_PURGE\t\t0x12\t \n#define IPW_SIO_HANDFLOW\t0x13\t \n#define IPW_SIO_SETCHARS\t0x13\t \n\t\t\t\t\t \n\n \n#define IPW_PIN_SETDTR\t\t0x101\n#define IPW_PIN_SETRTS\t\t0x202\n#define IPW_PIN_CLRDTR\t\t0x100\n#define IPW_PIN_CLRRTS\t\t0x200  \n\n \n#define IPW_RXBULK_ON\t\t1\n#define IPW_RXBULK_OFF\t\t0\n\n \n#define IPW_BYTES_FLOWINIT\t{ 0x01, 0, 0, 0, 0x40, 0, 0, 0, \\\n\t\t\t\t\t0, 0, 0, 0, 0, 0, 0, 0 }\n\n \n \n#define IPW_DSR\t\t\t((1<<4) | (1<<5))\n#define IPW_CTS\t\t\t((1<<5) | (1<<4))\n\n#define IPW_WANTS_TO_SEND\t0x30\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(IPW_VID, IPW_PID) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic int ipw_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tstruct device *dev = &port->dev;\n\tu8 buf_flow_static[16] = IPW_BYTES_FLOWINIT;\n\tu8 *buf_flow_init;\n\tint result;\n\n\tbuf_flow_init = kmemdup(buf_flow_static, 16, GFP_KERNEL);\n\tif (!buf_flow_init)\n\t\treturn -ENOMEM;\n\n\t \n\tdev_dbg(dev, \"%s: Sending SIO_INIT (we guess)\\n\", __func__);\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_INIT,\n\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t 0,\n\t\t\t 0,  \n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 100000);\n\tif (result < 0)\n\t\tdev_err(dev, \"Init of modem failed (error = %d)\\n\", result);\n\n\t \n\tusb_clear_halt(udev, usb_rcvbulkpipe(udev, port->bulk_in_endpointAddress));\n\tusb_clear_halt(udev, usb_sndbulkpipe(udev, port->bulk_out_endpointAddress));\n\n\t \n\tdev_dbg(dev, \"%s: setting up bulk read callback\\n\", __func__);\n\tusb_wwan_open(tty, port);\n\n\t \n\tdev_dbg(dev, \"%s:asking modem for RxRead (RXBULK_ON)\\n\", __func__);\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_RXCTL,\n\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t IPW_RXBULK_ON,\n\t\t\t 0,  \n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 100000);\n\tif (result < 0)\n\t\tdev_err(dev, \"Enabling bulk RxRead failed (error = %d)\\n\", result);\n\n\t \n\tdev_dbg(dev, \"%s:setting init flowcontrol (%s)\\n\", __func__, buf_flow_init);\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_HANDFLOW,\n\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t 0,\n\t\t\t 0,\n\t\t\t buf_flow_init,\n\t\t\t 0x10,\n\t\t\t 200000);\n\tif (result < 0)\n\t\tdev_err(dev, \"initial flowcontrol failed (error = %d)\\n\", result);\n\n\tkfree(buf_flow_init);\n\treturn 0;\n}\n\nstatic int ipw_attach(struct usb_serial *serial)\n{\n\tstruct usb_wwan_intf_private *data;\n\n\tdata = kzalloc(sizeof(struct usb_wwan_intf_private), GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&data->susp_lock);\n\tusb_set_serial_data(serial, data);\n\treturn 0;\n}\n\nstatic void ipw_release(struct usb_serial *serial)\n{\n\tstruct usb_wwan_intf_private *data = usb_get_serial_data(serial);\n\n\tusb_set_serial_data(serial, NULL);\n\tkfree(data);\n}\n\nstatic void ipw_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tstruct device *dev = &port->dev;\n\tint result;\n\n\tdev_dbg(dev, \"%s: on = %d\\n\", __func__, on);\n\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_SET_PIN,\n\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t on ? IPW_PIN_SETDTR : IPW_PIN_CLRDTR,\n\t\t\t 0,\n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 200000);\n\tif (result < 0)\n\t\tdev_err(dev, \"setting dtr failed (error = %d)\\n\", result);\n\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_SET_PIN, USB_TYPE_VENDOR |\n\t\t\t\t\tUSB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t on ? IPW_PIN_SETRTS : IPW_PIN_CLRRTS,\n\t\t\t 0,\n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 200000);\n\tif (result < 0)\n\t\tdev_err(dev, \"setting rts failed (error = %d)\\n\", result);\n}\n\nstatic void ipw_close(struct usb_serial_port *port)\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tstruct device *dev = &port->dev;\n\tint result;\n\n\t \n\tdev_dbg(dev, \"%s:sending purge\\n\", __func__);\n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_PURGE, USB_TYPE_VENDOR |\n\t\t\t \t\tUSB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t 0x03,\n\t\t\t 0,\n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 200000);\n\tif (result < 0)\n\t\tdev_err(dev, \"purge failed (error = %d)\\n\", result);\n\n\n\t \n\tresult = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t IPW_SIO_RXCTL,\n\t\t\t USB_TYPE_VENDOR | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t IPW_RXBULK_OFF,\n\t\t\t 0,  \n\t\t\t NULL,\n\t\t\t 0,\n\t\t\t 100000);\n\n\tif (result < 0)\n\t\tdev_err(dev, \"Disabling bulk RxRead failed (error = %d)\\n\", result);\n\n\tusb_wwan_close(port);\n}\n\nstatic struct usb_serial_driver ipw_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"ipw\",\n\t},\n\t.description =\t\t\"IPWireless converter\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.open =\t\t\tipw_open,\n\t.close =\t\tipw_close,\n\t.attach =\t\tipw_attach,\n\t.release =\t\tipw_release,\n\t.port_probe =\t\tusb_wwan_port_probe,\n\t.port_remove =\t\tusb_wwan_port_remove,\n\t.dtr_rts =\t\tipw_dtr_rts,\n\t.write =\t\tusb_wwan_write,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ipw_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\n \nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}