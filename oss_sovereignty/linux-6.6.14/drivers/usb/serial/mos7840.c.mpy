{
  "module_name": "mos7840.c",
  "hash_id": "564262ba3c7bd480615f90ab1aebebe3a3346dbffb51fd376892be30f5b08d49",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/mos7840.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/uaccess.h>\n\n#define DRIVER_DESC \"Moschip 7840/7820 USB Serial Driver\"\n\n \n\n#define LCR_BITS_5             0x00\t \n#define LCR_BITS_6             0x01\t \n#define LCR_BITS_7             0x02\t \n#define LCR_BITS_8             0x03\t \n#define LCR_BITS_MASK          0x03\t \n\n#define LCR_STOP_1             0x00\t \n#define LCR_STOP_1_5           0x04\t \n#define LCR_STOP_2             0x04\t \n#define LCR_STOP_MASK          0x04\t \n\n#define LCR_PAR_NONE           0x00\t \n#define LCR_PAR_ODD            0x08\t \n#define LCR_PAR_EVEN           0x18\t \n#define LCR_PAR_MARK           0x28\t \n#define LCR_PAR_SPACE          0x38\t \n#define LCR_PAR_MASK           0x38\t \n\n#define LCR_SET_BREAK          0x40\t \n#define LCR_DL_ENABLE          0x80\t \n\n#define MCR_DTR                0x01\t \n#define MCR_RTS                0x02\t \n#define MCR_OUT1               0x04\t \n#define MCR_MASTER_IE          0x08\t \n#define MCR_LOOPBACK           0x10\t \n#define MCR_XON_ANY            0x20\t \n\n#define MOS7840_MSR_CTS        0x10\t \n#define MOS7840_MSR_DSR        0x20\t \n#define MOS7840_MSR_RI         0x40\t \n#define MOS7840_MSR_CD         0x80\t \n\n \n\n#define MOS_WDR_TIMEOUT\t\t5000\t \n\n#define MOS_PORT1       0x0200\n#define MOS_PORT2       0x0300\n#define MOS_VENREG      0x0000\n#define MOS_MAX_PORT\t0x02\n#define MOS_WRITE       0x0E\n#define MOS_READ        0x0D\n\n \n#define MCS_RD_RTYPE    0xC0\n#define MCS_WR_RTYPE    0x40\n#define MCS_RDREQ       0x0D\n#define MCS_WRREQ       0x0E\n#define MCS_CTRL_TIMEOUT        500\n#define VENDOR_READ_LENGTH      (0x01)\n\n#define MAX_NAME_LEN    64\n\n#define ZLP_REG1  0x3A\t\t \n#define ZLP_REG5  0x3E\t\t \n\n \n#define TIOCEXBAUD     0x5462\n\n \n#define USB_VENDOR_ID_BANDB              0x0856\n#define BANDB_DEVICE_ID_USO9ML2_2        0xAC22\n#define BANDB_DEVICE_ID_USO9ML2_2P       0xBC00\n#define BANDB_DEVICE_ID_USO9ML2_4        0xAC24\n#define BANDB_DEVICE_ID_USO9ML2_4P       0xBC01\n#define BANDB_DEVICE_ID_US9ML2_2         0xAC29\n#define BANDB_DEVICE_ID_US9ML2_4         0xAC30\n#define BANDB_DEVICE_ID_USPTL4_2         0xAC31\n#define BANDB_DEVICE_ID_USPTL4_4         0xAC32\n#define BANDB_DEVICE_ID_USOPTL4_2        0xAC42\n#define BANDB_DEVICE_ID_USOPTL4_2P       0xBC02\n#define BANDB_DEVICE_ID_USOPTL4_4        0xAC44\n#define BANDB_DEVICE_ID_USOPTL4_4P       0xBC03\n\n \n\n#define SERIAL_IIR_RLS      0x06\n#define SERIAL_IIR_MS       0x00\n\n \n#define SERIAL_LSR_DR       0x0001\n#define SERIAL_LSR_OE       0x0002\n#define SERIAL_LSR_PE       0x0004\n#define SERIAL_LSR_FE       0x0008\n#define SERIAL_LSR_BI       0x0010\n\n#define MOS_MSR_DELTA_CTS   0x10\n#define MOS_MSR_DELTA_DSR   0x20\n#define MOS_MSR_DELTA_RI    0x40\n#define MOS_MSR_DELTA_CD    0x80\n\n \n#define INTERRUPT_ENABLE_REGISTER  ((__u16)(0x01))\n#define FIFO_CONTROL_REGISTER      ((__u16)(0x02))\n#define LINE_CONTROL_REGISTER      ((__u16)(0x03))\n#define MODEM_CONTROL_REGISTER     ((__u16)(0x04))\n#define LINE_STATUS_REGISTER       ((__u16)(0x05))\n#define MODEM_STATUS_REGISTER      ((__u16)(0x06))\n#define SCRATCH_PAD_REGISTER       ((__u16)(0x07))\n#define DIVISOR_LATCH_LSB          ((__u16)(0x00))\n#define DIVISOR_LATCH_MSB          ((__u16)(0x01))\n\n#define CLK_MULTI_REGISTER         ((__u16)(0x02))\n#define CLK_START_VALUE_REGISTER   ((__u16)(0x03))\n#define GPIO_REGISTER              ((__u16)(0x07))\n\n#define SERIAL_LCR_DLAB            ((__u16)(0x0080))\n\n \n#define NUM_URBS                        16\t \n#define URB_TRANSFER_BUFFER_SIZE        32\t \n\n \n#define LED_ON_MS\t500\n#define LED_OFF_MS\t500\n\nenum mos7840_flag {\n\tMOS7840_FLAG_LED_BUSY,\n};\n\n#define MCS_PORT_MASK\tGENMASK(2, 0)\n#define MCS_PORTS(nr)\t((nr) & MCS_PORT_MASK)\n#define MCS_LED\t\tBIT(3)\n\n#define MCS_DEVICE(vid, pid, flags) \\\n\t\tUSB_DEVICE((vid), (pid)), .driver_info = (flags)\n\nstatic const struct usb_device_id id_table[] = {\n\t{ MCS_DEVICE(0x0557, 0x2011, MCS_PORTS(4)) },\t \n\t{ MCS_DEVICE(0x0557, 0x7820, MCS_PORTS(2)) },\t \n\t{ MCS_DEVICE(0x110a, 0x2210, MCS_PORTS(2)) },\t \n\t{ MCS_DEVICE(0x9710, 0x7810, MCS_PORTS(1) | MCS_LED) },  \n\t{ MCS_DEVICE(0x9710, 0x7820, MCS_PORTS(2)) },\t \n\t{ MCS_DEVICE(0x9710, 0x7840, MCS_PORTS(4)) },\t \n\t{ MCS_DEVICE(0x9710, 0x7843, MCS_PORTS(3)) },\t \n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_2P) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USO9ML2_4P) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_US9ML2_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USPTL4_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_2P) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_BANDB, BANDB_DEVICE_ID_USOPTL4_4P) },\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \n\nstruct moschip_port {\n\tint port_num;\t\t \n\tstruct urb *read_urb;\t \n\t__u8 shadowLCR;\t\t \n\t__u8 shadowMCR;\t\t \n\tstruct usb_serial_port *port;\t \n\n\t \n\t__u8 SpRegOffset;\n\t__u8 ControlRegOffset;\n\t__u8 DcrRegOffset;\n\n\tspinlock_t pool_lock;\n\tstruct urb *write_urb_pool[NUM_URBS];\n\tchar busy[NUM_URBS];\n\tbool read_urb_busy;\n\n\t \n\tbool has_led;\n\tstruct timer_list led_timer1;\t \n\tstruct timer_list led_timer2;\t \n\tstruct urb *led_urb;\n\tstruct usb_ctrlrequest *led_dr;\n\n\tunsigned long flags;\n};\n\n \n\nstatic int mos7840_set_reg_sync(struct usb_serial_port *port, __u16 reg,\n\t\t\t\t__u16 val)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tval = val & 0x00ff;\n\tdev_dbg(&port->dev, \"mos7840_set_reg_sync offset is %x, value %x\\n\", reg, val);\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\n\t\t\t       MCS_WR_RTYPE, val, reg, NULL, 0,\n\t\t\t       MOS_WDR_TIMEOUT);\n}\n\n \n\nstatic int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,\n\t\t\t\t__u16 *val)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tint ret = 0;\n\tu8 *buf;\n\n\tbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\n\t\t\t      MCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,\n\t\t\t      MOS_WDR_TIMEOUT);\n\tif (ret < VENDOR_READ_LENGTH) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\n\t*val = buf[0];\n\tdev_dbg(&port->dev, \"%s offset is %x, return val %x\\n\", __func__, reg, *val);\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\n \n\nstatic int mos7840_set_uart_reg(struct usb_serial_port *port, __u16 reg,\n\t\t\t\t__u16 val)\n{\n\n\tstruct usb_device *dev = port->serial->dev;\n\tval = val & 0x00ff;\n\t \n\tif (port->serial->num_ports == 2 && port->port_number != 0)\n\t\tval |= ((__u16)port->port_number + 2) << 8;\n\telse\n\t\tval |= ((__u16)port->port_number + 1) << 8;\n\tdev_dbg(&port->dev, \"%s application number is %x\\n\", __func__, val);\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ,\n\t\t\t       MCS_WR_RTYPE, val, reg, NULL, 0,\n\t\t\t       MOS_WDR_TIMEOUT);\n\n}\n\n \nstatic int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,\n\t\t\t\t__u16 *val)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tint ret = 0;\n\t__u16 Wval;\n\tu8 *buf;\n\n\tbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tif (port->serial->num_ports == 2 && port->port_number != 0)\n\t\tWval = ((__u16)port->port_number + 2) << 8;\n\telse\n\t\tWval = ((__u16)port->port_number + 1) << 8;\n\tdev_dbg(&port->dev, \"%s application number is %x\\n\", __func__, Wval);\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,\n\t\t\t      MCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,\n\t\t\t      MOS_WDR_TIMEOUT);\n\tif (ret < VENDOR_READ_LENGTH) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\t*val = buf[0];\nout:\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic void mos7840_dump_serial_port(struct usb_serial_port *port,\n\t\t\t\t     struct moschip_port *mos7840_port)\n{\n\n\tdev_dbg(&port->dev, \"SpRegOffset is %2x\\n\", mos7840_port->SpRegOffset);\n\tdev_dbg(&port->dev, \"ControlRegOffset is %2x\\n\", mos7840_port->ControlRegOffset);\n\tdev_dbg(&port->dev, \"DCRRegOffset is %2x\\n\", mos7840_port->DcrRegOffset);\n\n}\n\n \n \n \n \n \n \n\nstatic void mos7840_set_led_callback(struct urb *urb)\n{\n\tswitch (urb->status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down: %d\\n\",\n\t\t\t__func__, urb->status);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status: %d\\n\",\n\t\t\t__func__, urb->status);\n\t}\n}\n\nstatic void mos7840_set_led_async(struct moschip_port *mcs, __u16 wval,\n\t\t\t\t__u16 reg)\n{\n\tstruct usb_device *dev = mcs->port->serial->dev;\n\tstruct usb_ctrlrequest *dr = mcs->led_dr;\n\n\tdr->bRequestType = MCS_WR_RTYPE;\n\tdr->bRequest = MCS_WRREQ;\n\tdr->wValue = cpu_to_le16(wval);\n\tdr->wIndex = cpu_to_le16(reg);\n\tdr->wLength = cpu_to_le16(0);\n\n\tusb_fill_control_urb(mcs->led_urb, dev, usb_sndctrlpipe(dev, 0),\n\t\t(unsigned char *)dr, NULL, 0, mos7840_set_led_callback, NULL);\n\n\tusb_submit_urb(mcs->led_urb, GFP_ATOMIC);\n}\n\nstatic void mos7840_set_led_sync(struct usb_serial_port *port, __u16 reg,\n\t\t\t\t__u16 val)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\n\tusb_control_msg(dev, usb_sndctrlpipe(dev, 0), MCS_WRREQ, MCS_WR_RTYPE,\n\t\t\tval, reg, NULL, 0, MOS_WDR_TIMEOUT);\n}\n\nstatic void mos7840_led_off(struct timer_list *t)\n{\n\tstruct moschip_port *mcs = from_timer(mcs, t, led_timer1);\n\n\t \n\tmos7840_set_led_async(mcs, 0x0300, MODEM_CONTROL_REGISTER);\n\tmod_timer(&mcs->led_timer2,\n\t\t\t\tjiffies + msecs_to_jiffies(LED_OFF_MS));\n}\n\nstatic void mos7840_led_flag_off(struct timer_list *t)\n{\n\tstruct moschip_port *mcs = from_timer(mcs, t, led_timer2);\n\n\tclear_bit_unlock(MOS7840_FLAG_LED_BUSY, &mcs->flags);\n}\n\nstatic void mos7840_led_activity(struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\n\tif (test_and_set_bit_lock(MOS7840_FLAG_LED_BUSY, &mos7840_port->flags))\n\t\treturn;\n\n\tmos7840_set_led_async(mos7840_port, 0x0301, MODEM_CONTROL_REGISTER);\n\tmod_timer(&mos7840_port->led_timer1,\n\t\t\t\tjiffies + msecs_to_jiffies(LED_ON_MS));\n}\n\n \n\nstatic void mos7840_bulk_in_callback(struct urb *urb)\n{\n\tstruct moschip_port *mos7840_port = urb->context;\n\tstruct usb_serial_port *port = mos7840_port->port;\n\tint retval;\n\tunsigned char *data;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"nonzero read bulk status received: %d\\n\", status);\n\t\tmos7840_port->read_urb_busy = false;\n\t\treturn;\n\t}\n\n\tdata = urb->transfer_buffer;\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\tif (urb->actual_length) {\n\t\tstruct tty_port *tport = &mos7840_port->port->port;\n\t\ttty_insert_flip_string(tport, data, urb->actual_length);\n\t\ttty_flip_buffer_push(tport);\n\t\tport->icount.rx += urb->actual_length;\n\t\tdev_dbg(&port->dev, \"icount.rx is %d:\\n\", port->icount.rx);\n\t}\n\n\tif (mos7840_port->has_led)\n\t\tmos7840_led_activity(port);\n\n\tmos7840_port->read_urb_busy = true;\n\tretval = usb_submit_urb(mos7840_port->read_urb, GFP_ATOMIC);\n\n\tif (retval) {\n\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, retval = %d\\n\", retval);\n\t\tmos7840_port->read_urb_busy = false;\n\t}\n}\n\n \n\nstatic void mos7840_bulk_out_data_callback(struct urb *urb)\n{\n\tstruct moschip_port *mos7840_port = urb->context;\n\tstruct usb_serial_port *port = mos7840_port->port;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint i;\n\n\tspin_lock_irqsave(&mos7840_port->pool_lock, flags);\n\tfor (i = 0; i < NUM_URBS; i++) {\n\t\tif (urb == mos7840_port->write_urb_pool[i]) {\n\t\t\tmos7840_port->busy[i] = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"nonzero write bulk status received:%d\\n\", status);\n\t\treturn;\n\t}\n\n\ttty_port_tty_wakeup(&port->port);\n\n}\n\n \n \n \n\n \n\nstatic int mos7840_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint response;\n\tint j;\n\tstruct urb *urb;\n\t__u16 Data;\n\tint status;\n\n\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\n\t \n\tfor (j = 0; j < NUM_URBS; ++j) {\n\t\turb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tmos7840_port->write_urb_pool[j] = urb;\n\t\tif (!urb)\n\t\t\tcontinue;\n\n\t\turb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!urb->transfer_buffer) {\n\t\t\tusb_free_urb(urb);\n\t\t\tmos7840_port->write_urb_pool[j] = NULL;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n \n\n\t \n\n\tData = 0x0;\n\tstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Reading Spreg failed\\n\");\n\t\tgoto err;\n\t}\n\tData |= 0x80;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"writing Spreg failed\\n\");\n\t\tgoto err;\n\t}\n\n\tData &= ~0x80;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"writing Spreg failed\\n\");\n\t\tgoto err;\n\t}\n\t \n\n\tData = 0x0;\n\tstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\n\t\t\t\t\t\t\t\t\t&Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Reading Controlreg failed\\n\");\n\t\tgoto err;\n\t}\n\tData |= 0x08;\t\t \n\tData |= 0x20;\t\t \n\tstatus = mos7840_set_reg_sync(port,\n\t\t\t\tmos7840_port->ControlRegOffset, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"writing Controlreg failed\\n\");\n\t\tgoto err;\n\t}\n\t \n\t \n\t \n\tData = 0x00;\n\tstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"disabling interrupts failed\\n\");\n\t\tgoto err;\n\t}\n\t \n\tData = 0x00;\n\tstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing FIFO_CONTROL_REGISTER  failed\\n\");\n\t\tgoto err;\n\t}\n\n\tData = 0xcf;\n\tstatus = mos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing FIFO_CONTROL_REGISTER  failed\\n\");\n\t\tgoto err;\n\t}\n\n\tData = 0x03;\n\tstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\tmos7840_port->shadowLCR = Data;\n\n\tData = 0x0b;\n\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\n\tmos7840_port->shadowMCR = Data;\n\n\tData = 0x00;\n\tstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\n\tmos7840_port->shadowLCR = Data;\n\n\tData |= SERIAL_LCR_DLAB;\t \n\tstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\n\tData = 0x0c;\n\tstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\n\n\tData = 0x0;\n\tstatus = mos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\n\n\tData = 0x00;\n\tstatus = mos7840_get_uart_reg(port, LINE_CONTROL_REGISTER, &Data);\n\n\tData = Data & ~SERIAL_LCR_DLAB;\n\tstatus = mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\tmos7840_port->shadowLCR = Data;\n\n\t \n\tData = 0x0;\n\tstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset, &Data);\n\n\tData = Data | 0x0c;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\n\n\tData = Data & ~0x0c;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset, Data);\n\t \n\tData = 0x0c;\n\tstatus = mos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\n\n\t \n\tData = 0x0;\n\tstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\n\t\t\t\t\t\t\t\t\t&Data);\n\tData = Data & ~0x20;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\n\t\t\t\t\t\t\t\t\tData);\n\n\t \n\tData = 0x0;\n\tstatus = mos7840_get_reg_sync(port, mos7840_port->ControlRegOffset,\n\t\t\t\t\t\t\t\t\t&Data);\n\tData = Data | 0x10;\n\tstatus = mos7840_set_reg_sync(port, mos7840_port->ControlRegOffset,\n\t\t\t\t\t\t\t\t\tData);\n\n\tdev_dbg(&port->dev, \"port number is %d\\n\", port->port_number);\n\tdev_dbg(&port->dev, \"minor number is %d\\n\", port->minor);\n\tdev_dbg(&port->dev, \"Bulkin endpoint is %d\\n\", port->bulk_in_endpointAddress);\n\tdev_dbg(&port->dev, \"BulkOut endpoint is %d\\n\", port->bulk_out_endpointAddress);\n\tdev_dbg(&port->dev, \"Interrupt endpoint is %d\\n\", port->interrupt_in_endpointAddress);\n\tdev_dbg(&port->dev, \"port's number in the device is %d\\n\", mos7840_port->port_num);\n\tmos7840_port->read_urb = port->read_urb;\n\n\t \n\tif ((serial->num_ports == 2) && (((__u16)port->port_number % 2) != 0)) {\n\t\tusb_fill_bulk_urb(mos7840_port->read_urb,\n\t\t\tserial->dev,\n\t\t\tusb_rcvbulkpipe(serial->dev,\n\t\t\t\t(port->bulk_in_endpointAddress) + 2),\n\t\t\tport->bulk_in_buffer,\n\t\t\tmos7840_port->read_urb->transfer_buffer_length,\n\t\t\tmos7840_bulk_in_callback, mos7840_port);\n\t} else {\n\t\tusb_fill_bulk_urb(mos7840_port->read_urb,\n\t\t\tserial->dev,\n\t\t\tusb_rcvbulkpipe(serial->dev,\n\t\t\t\tport->bulk_in_endpointAddress),\n\t\t\tport->bulk_in_buffer,\n\t\t\tmos7840_port->read_urb->transfer_buffer_length,\n\t\t\tmos7840_bulk_in_callback, mos7840_port);\n\t}\n\n\tdev_dbg(&port->dev, \"%s: bulkin endpoint is %d\\n\", __func__, port->bulk_in_endpointAddress);\n\tmos7840_port->read_urb_busy = true;\n\tresponse = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\n\tif (response) {\n\t\tdev_err(&port->dev, \"%s - Error %d submitting control urb\\n\",\n\t\t\t__func__, response);\n\t\tmos7840_port->read_urb_busy = false;\n\t}\n\n\t \n\t \n\tmos7840_port->shadowMCR = MCR_MASTER_IE;\n\n\treturn 0;\nerr:\n\tfor (j = 0; j < NUM_URBS; ++j) {\n\t\turb = mos7840_port->write_urb_pool[j];\n\t\tif (!urb)\n\t\t\tcontinue;\n\t\tkfree(urb->transfer_buffer);\n\t\tusb_free_urb(urb);\n\t}\n\treturn status;\n}\n\n \n\nstatic unsigned int mos7840_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint i;\n\tunsigned int chars = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mos7840_port->pool_lock, flags);\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (mos7840_port->busy[i]) {\n\t\t\tstruct urb *urb = mos7840_port->write_urb_pool[i];\n\t\t\tchars += urb->transfer_buffer_length;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, chars);\n\treturn chars;\n\n}\n\n \n\nstatic void mos7840_close(struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint j;\n\t__u16 Data;\n\n\tfor (j = 0; j < NUM_URBS; ++j)\n\t\tusb_kill_urb(mos7840_port->write_urb_pool[j]);\n\n\t \n\tfor (j = 0; j < NUM_URBS; ++j) {\n\t\tif (mos7840_port->write_urb_pool[j]) {\n\t\t\tkfree(mos7840_port->write_urb_pool[j]->transfer_buffer);\n\t\t\tusb_free_urb(mos7840_port->write_urb_pool[j]);\n\t\t}\n\t}\n\n\tusb_kill_urb(mos7840_port->read_urb);\n\tmos7840_port->read_urb_busy = false;\n\n\tData = 0x0;\n\tmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\n\n\tData = 0x00;\n\tmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\n}\n\n \nstatic int mos7840_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tunsigned char data;\n\n\tif (break_state == -1)\n\t\tdata = mos7840_port->shadowLCR | LCR_SET_BREAK;\n\telse\n\t\tdata = mos7840_port->shadowLCR & ~LCR_SET_BREAK;\n\n\t \n\tmos7840_port->shadowLCR = data;\n\tdev_dbg(&port->dev, \"%s mos7840_port->shadowLCR is %x\\n\", __func__, mos7840_port->shadowLCR);\n\n\treturn mos7840_set_uart_reg(port, LINE_CONTROL_REGISTER,\n\t\t\t\t    mos7840_port->shadowLCR);\n}\n\n \n\nstatic unsigned int mos7840_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint i;\n\tunsigned int room = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&mos7840_port->pool_lock, flags);\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (!mos7840_port->busy[i])\n\t\t\troom += URB_TRANSFER_BUFFER_SIZE;\n\t}\n\tspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\n\n\troom = (room == 0) ? 0 : room - URB_TRANSFER_BUFFER_SIZE + 1;\n\tdev_dbg(&mos7840_port->port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n\n}\n\n \n\nstatic int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t const unsigned char *data, int count)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint status;\n\tint i;\n\tint bytes_sent = 0;\n\tint transfer_size;\n\tunsigned long flags;\n\tstruct urb *urb;\n\t \n\tconst unsigned char *current_position = data;\n\n\t \n\turb = NULL;\n\n\tspin_lock_irqsave(&mos7840_port->pool_lock, flags);\n\tfor (i = 0; i < NUM_URBS; ++i) {\n\t\tif (!mos7840_port->busy[i]) {\n\t\t\tmos7840_port->busy[i] = 1;\n\t\t\turb = mos7840_port->write_urb_pool[i];\n\t\t\tdev_dbg(&port->dev, \"URB:%d\\n\", i);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&mos7840_port->pool_lock, flags);\n\n\tif (urb == NULL) {\n\t\tdev_dbg(&port->dev, \"%s - no more free urbs\\n\", __func__);\n\t\tgoto exit;\n\t}\n\n\tif (urb->transfer_buffer == NULL) {\n\t\turb->transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,\n\t\t\t\t\t       GFP_ATOMIC);\n\t\tif (!urb->transfer_buffer) {\n\t\t\tbytes_sent = -ENOMEM;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\ttransfer_size = min(count, URB_TRANSFER_BUFFER_SIZE);\n\n\tmemcpy(urb->transfer_buffer, current_position, transfer_size);\n\n\t \n\tif ((serial->num_ports == 2) && (((__u16)port->port_number % 2) != 0)) {\n\t\tusb_fill_bulk_urb(urb,\n\t\t\tserial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev,\n\t\t\t\t(port->bulk_out_endpointAddress) + 2),\n\t\t\turb->transfer_buffer,\n\t\t\ttransfer_size,\n\t\t\tmos7840_bulk_out_data_callback, mos7840_port);\n\t} else {\n\t\tusb_fill_bulk_urb(urb,\n\t\t\tserial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev,\n\t\t\t\tport->bulk_out_endpointAddress),\n\t\t\turb->transfer_buffer,\n\t\t\ttransfer_size,\n\t\t\tmos7840_bulk_out_data_callback, mos7840_port);\n\t}\n\n\tdev_dbg(&port->dev, \"bulkout endpoint is %d\\n\", port->bulk_out_endpointAddress);\n\n\tif (mos7840_port->has_led)\n\t\tmos7840_led_activity(port);\n\n\t \n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (status) {\n\t\tmos7840_port->busy[i] = 0;\n\t\tdev_err_console(port, \"%s - usb_submit_urb(write bulk) failed \"\n\t\t\t\"with status = %d\\n\", __func__, status);\n\t\tbytes_sent = status;\n\t\tgoto exit;\n\t}\n\tbytes_sent = transfer_size;\n\tport->icount.tx += transfer_size;\n\tdev_dbg(&port->dev, \"icount.tx is %d:\\n\", port->icount.tx);\nexit:\n\treturn bytes_sent;\n\n}\n\n \n\nstatic void mos7840_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint status;\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char stop_char = STOP_CHAR(tty);\n\t\tstatus = mos7840_write(tty, port, &stop_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tmos7840_port->shadowMCR &= ~MCR_RTS;\n\t\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\n\t\t\t\t\t mos7840_port->shadowMCR);\n\t\tif (status < 0)\n\t\t\treturn;\n\t}\n}\n\n \nstatic void mos7840_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint status;\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char start_char = START_CHAR(tty);\n\t\tstatus = mos7840_write(tty, port, &start_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tmos7840_port->shadowMCR |= MCR_RTS;\n\t\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\n\t\t\t\t\t mos7840_port->shadowMCR);\n\t\tif (status < 0)\n\t\t\treturn;\n\t}\n}\n\nstatic int mos7840_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int result;\n\t__u16 msr;\n\t__u16 mcr;\n\tint status;\n\n\tstatus = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &msr);\n\tif (status < 0)\n\t\treturn -EIO;\n\tstatus = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &mcr);\n\tif (status < 0)\n\t\treturn -EIO;\n\tresult = ((mcr & MCR_DTR) ? TIOCM_DTR : 0)\n\t    | ((mcr & MCR_RTS) ? TIOCM_RTS : 0)\n\t    | ((mcr & MCR_LOOPBACK) ? TIOCM_LOOP : 0)\n\t    | ((msr & MOS7840_MSR_CTS) ? TIOCM_CTS : 0)\n\t    | ((msr & MOS7840_MSR_CD) ? TIOCM_CAR : 0)\n\t    | ((msr & MOS7840_MSR_RI) ? TIOCM_RI : 0)\n\t    | ((msr & MOS7840_MSR_DSR) ? TIOCM_DSR : 0);\n\n\tdev_dbg(&port->dev, \"%s - 0x%04X\\n\", __func__, result);\n\n\treturn result;\n}\n\nstatic int mos7840_tiocmset(struct tty_struct *tty,\n\t\t\t    unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\tint status;\n\n\t \n\tmcr = mos7840_port->shadowMCR;\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~MCR_LOOPBACK;\n\n\tif (set & TIOCM_RTS)\n\t\tmcr |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= MCR_LOOPBACK;\n\n\tmos7840_port->shadowMCR = mcr;\n\n\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, mcr);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"setting MODEM_CONTROL_REGISTER Failed\\n\");\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mos7840_calc_baud_rate_divisor(struct usb_serial_port *port,\n\t\t\t\t\t  int baudRate, int *divisor,\n\t\t\t\t\t  __u16 *clk_sel_val)\n{\n\tdev_dbg(&port->dev, \"%s - %d\\n\", __func__, baudRate);\n\n\tif (baudRate <= 115200) {\n\t\t*divisor = 115200 / baudRate;\n\t\t*clk_sel_val = 0x0;\n\t}\n\tif ((baudRate > 115200) && (baudRate <= 230400)) {\n\t\t*divisor = 230400 / baudRate;\n\t\t*clk_sel_val = 0x10;\n\t} else if ((baudRate > 230400) && (baudRate <= 403200)) {\n\t\t*divisor = 403200 / baudRate;\n\t\t*clk_sel_val = 0x20;\n\t} else if ((baudRate > 403200) && (baudRate <= 460800)) {\n\t\t*divisor = 460800 / baudRate;\n\t\t*clk_sel_val = 0x30;\n\t} else if ((baudRate > 460800) && (baudRate <= 806400)) {\n\t\t*divisor = 806400 / baudRate;\n\t\t*clk_sel_val = 0x40;\n\t} else if ((baudRate > 806400) && (baudRate <= 921600)) {\n\t\t*divisor = 921600 / baudRate;\n\t\t*clk_sel_val = 0x50;\n\t} else if ((baudRate > 921600) && (baudRate <= 1572864)) {\n\t\t*divisor = 1572864 / baudRate;\n\t\t*clk_sel_val = 0x60;\n\t} else if ((baudRate > 1572864) && (baudRate <= 3145728)) {\n\t\t*divisor = 3145728 / baudRate;\n\t\t*clk_sel_val = 0x70;\n\t}\n\treturn 0;\n}\n\n \n\nstatic int mos7840_send_cmd_write_baud_rate(struct moschip_port *mos7840_port,\n\t\t\t\t\t    int baudRate)\n{\n\tstruct usb_serial_port *port = mos7840_port->port;\n\tint divisor = 0;\n\tint status;\n\t__u16 Data;\n\t__u16 clk_sel_val;\n\n\tdev_dbg(&port->dev, \"%s - baud = %d\\n\", __func__, baudRate);\n\t \n\tif (baudRate > 115200) {\n#ifdef HW_flow_control\n\t\t \n\t\t \n\t\tData = 0x2b;\n\t\tmos7840_port->shadowMCR = Data;\n\t\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\n\t\t\t\t\t\t\t\t\tData);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"Writing spreg failed in set_serial_baud\\n\");\n\t\t\treturn -1;\n\t\t}\n#endif\n\n\t} else {\n#ifdef HW_flow_control\n\t\t \n\t\tData = 0xb;\n\t\tmos7840_port->shadowMCR = Data;\n\t\tstatus = mos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER,\n\t\t\t\t\t\t\t\t\tData);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"Writing spreg failed in set_serial_baud\\n\");\n\t\t\treturn -1;\n\t\t}\n#endif\n\n\t}\n\n\tif (1) {\t\t \n\t\tclk_sel_val = 0x0;\n\t\tData = 0x0;\n\t\tstatus = mos7840_calc_baud_rate_divisor(port, baudRate, &divisor,\n\t\t\t\t\t\t   &clk_sel_val);\n\t\tstatus = mos7840_get_reg_sync(port, mos7840_port->SpRegOffset,\n\t\t\t\t\t\t\t\t &Data);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"reading spreg failed in set_serial_baud\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tData = (Data & 0x8f) | clk_sel_val;\n\t\tstatus = mos7840_set_reg_sync(port, mos7840_port->SpRegOffset,\n\t\t\t\t\t\t\t\tData);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"Writing spreg failed in set_serial_baud\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\t \n\n\t\tif (status) {\n\t\t\tdev_err(&port->dev, \"%s - bad baud rate\\n\", __func__);\n\t\t\treturn status;\n\t\t}\n\t\t \n\t\tData = mos7840_port->shadowLCR | SERIAL_LCR_DLAB;\n\t\tmos7840_port->shadowLCR = Data;\n\t\tmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\n\t\t \n\t\tData = (unsigned char)(divisor & 0xff);\n\t\tdev_dbg(&port->dev, \"set_serial_baud Value to write DLL is %x\\n\", Data);\n\t\tmos7840_set_uart_reg(port, DIVISOR_LATCH_LSB, Data);\n\n\t\tData = (unsigned char)((divisor & 0xff00) >> 8);\n\t\tdev_dbg(&port->dev, \"set_serial_baud Value to write DLM is %x\\n\", Data);\n\t\tmos7840_set_uart_reg(port, DIVISOR_LATCH_MSB, Data);\n\n\t\t \n\t\tData = mos7840_port->shadowLCR & ~SERIAL_LCR_DLAB;\n\t\tmos7840_port->shadowLCR = Data;\n\t\tmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\n\t}\n\treturn status;\n}\n\n \n\nstatic void mos7840_change_port_settings(struct tty_struct *tty,\n\t\t\t\t\t struct moschip_port *mos7840_port,\n\t\t\t\t\t const struct ktermios *old_termios)\n{\n\tstruct usb_serial_port *port = mos7840_port->port;\n\tint baud;\n\tunsigned cflag;\n\t__u8 lData;\n\t__u8 lParity;\n\t__u8 lStop;\n\tint status;\n\t__u16 Data;\n\n\tlData = LCR_BITS_8;\n\tlStop = LCR_STOP_1;\n\tlParity = LCR_PAR_NONE;\n\n\tcflag = tty->termios.c_cflag;\n\n\t \n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tlData = LCR_BITS_5;\n\t\tbreak;\n\n\tcase CS6:\n\t\tlData = LCR_BITS_6;\n\t\tbreak;\n\n\tcase CS7:\n\t\tlData = LCR_BITS_7;\n\t\tbreak;\n\n\tdefault:\n\tcase CS8:\n\t\tlData = LCR_BITS_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD) {\n\t\t\tlParity = LCR_PAR_ODD;\n\t\t\tdev_dbg(&port->dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tlParity = LCR_PAR_EVEN;\n\t\t\tdev_dbg(&port->dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\n\t} else {\n\t\tdev_dbg(&port->dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CMSPAR)\n\t\tlParity = lParity | 0x20;\n\n\t \n\tif (cflag & CSTOPB) {\n\t\tlStop = LCR_STOP_2;\n\t\tdev_dbg(&port->dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tlStop = LCR_STOP_1;\n\t\tdev_dbg(&port->dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t \n\tmos7840_port->shadowLCR &=\n\t    ~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\n\tmos7840_port->shadowLCR |= (lData | lParity | lStop);\n\n\tdev_dbg(&port->dev, \"%s - mos7840_port->shadowLCR is %x\\n\", __func__,\n\t\tmos7840_port->shadowLCR);\n\t \n\tData = 0x00;\n\tmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\n\n\tData = 0x00;\n\tmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\n\n\tData = 0xcf;\n\tmos7840_set_uart_reg(port, FIFO_CONTROL_REGISTER, Data);\n\n\t \n\tData = mos7840_port->shadowLCR;\n\n\tmos7840_set_uart_reg(port, LINE_CONTROL_REGISTER, Data);\n\n\tData = 0x00b;\n\tmos7840_port->shadowMCR = Data;\n\tmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\n\tData = 0x00b;\n\tmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\n\n\t \n\n\tmos7840_port->shadowMCR = MCR_MASTER_IE;\n\tif (cflag & CBAUD)\n\t\tmos7840_port->shadowMCR |= (MCR_DTR | MCR_RTS);\n\n\tif (cflag & CRTSCTS)\n\t\tmos7840_port->shadowMCR |= (MCR_XON_ANY);\n\telse\n\t\tmos7840_port->shadowMCR &= ~(MCR_XON_ANY);\n\n\tData = mos7840_port->shadowMCR;\n\tmos7840_set_uart_reg(port, MODEM_CONTROL_REGISTER, Data);\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\n\tif (!baud) {\n\t\t \n\t\tdev_dbg(&port->dev, \"%s\", \"Picked default baud...\\n\");\n\t\tbaud = 9600;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - baud rate = %d\\n\", __func__, baud);\n\tstatus = mos7840_send_cmd_write_baud_rate(mos7840_port, baud);\n\n\t \n\tData = 0x0c;\n\tmos7840_set_uart_reg(port, INTERRUPT_ENABLE_REGISTER, Data);\n\n\tif (!mos7840_port->read_urb_busy) {\n\t\tmos7840_port->read_urb_busy = true;\n\t\tstatus = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, status = %d\\n\",\n\t\t\t    status);\n\t\t\tmos7840_port->read_urb_busy = false;\n\t\t}\n\t}\n\tdev_dbg(&port->dev, \"%s - mos7840_port->shadowLCR is End %x\\n\", __func__,\n\t\tmos7840_port->shadowLCR);\n}\n\n \n\nstatic void mos7840_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\tint status;\n\n\t \n\n\tmos7840_change_port_settings(tty, mos7840_port, old_termios);\n\n\tif (!mos7840_port->read_urb_busy) {\n\t\tmos7840_port->read_urb_busy = true;\n\t\tstatus = usb_submit_urb(mos7840_port->read_urb, GFP_KERNEL);\n\t\tif (status) {\n\t\t\tdev_dbg(&port->dev, \"usb_submit_urb(read bulk) failed, status = %d\\n\",\n\t\t\t    status);\n\t\t\tmos7840_port->read_urb_busy = false;\n\t\t}\n\t}\n}\n\n \n\nstatic int mos7840_get_lsr_info(struct tty_struct *tty,\n\t\t\t\tunsigned int __user *value)\n{\n\tint count;\n\tunsigned int result = 0;\n\n\tcount = mos7840_chars_in_buffer(tty);\n\tif (count == 0)\n\t\tresult = TIOCSER_TEMT;\n\n\tif (copy_to_user(value, &result, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\n \n\nstatic int mos7840_ioctl(struct tty_struct *tty,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\t\t \n\n\tcase TIOCSERGETLSR:\n\t\tdev_dbg(&port->dev, \"%s TIOCSERGETLSR\\n\", __func__);\n\t\treturn mos7840_get_lsr_info(tty, argp);\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n \nstatic int mos7810_check(struct usb_serial *serial)\n{\n\tint i, pass_count = 0;\n\tu8 *buf;\n\t__u16 data = 0, mcr_data = 0;\n\t__u16 test_pattern = 0x55AA;\n\tint res;\n\n\tbuf = kmalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\n\tif (!buf)\n\t\treturn 0;\t \n\n\t \n\tres = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\tMCS_RDREQ, MCS_RD_RTYPE, 0x0300, MODEM_CONTROL_REGISTER,\n\t\tbuf, VENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\n\tif (res == VENDOR_READ_LENGTH)\n\t\tmcr_data = *buf;\n\n\tfor (i = 0; i < 16; i++) {\n\t\t \n\t\tusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\tMCS_WRREQ, MCS_WR_RTYPE,\n\t\t\t(0x0300 | (((test_pattern >> i) & 0x0001) << 1)),\n\t\t\tMODEM_CONTROL_REGISTER, NULL, 0, MOS_WDR_TIMEOUT);\n\n\t\t \n\t\tres = usb_control_msg(serial->dev,\n\t\t\t\tusb_rcvctrlpipe(serial->dev, 0), MCS_RDREQ,\n\t\t\t\tMCS_RD_RTYPE, 0, GPIO_REGISTER, buf,\n\t\t\t\tVENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\n\t\tif (res == VENDOR_READ_LENGTH)\n\t\t\tdata = *buf;\n\n\t\t \n\t\tif (((test_pattern >> i) ^ (~data >> 1)) & 0x0001)\n\t\t\tbreak;\n\n\t\tpass_count++;\n\t}\n\n\t \n\tusb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0), MCS_WRREQ,\n\t\tMCS_WR_RTYPE, 0x0300 | mcr_data, MODEM_CONTROL_REGISTER, NULL,\n\t\t0, MOS_WDR_TIMEOUT);\n\n\tkfree(buf);\n\n\tif (pass_count == 16)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int mos7840_probe(struct usb_serial *serial,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tunsigned long device_flags = id->driver_info;\n\tu8 *buf;\n\n\t \n\tif (device_flags)\n\t\tgoto out;\n\n\tbuf = kzalloc(VENDOR_READ_LENGTH, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tusb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\tMCS_RDREQ, MCS_RD_RTYPE, 0, GPIO_REGISTER, buf,\n\t\t\tVENDOR_READ_LENGTH, MOS_WDR_TIMEOUT);\n\n\t \n\tif (buf[0] & 0x01)\n\t\tdevice_flags = MCS_PORTS(4);\n\telse if (mos7810_check(serial))\n\t\tdevice_flags = MCS_PORTS(1) | MCS_LED;\n\telse\n\t\tdevice_flags = MCS_PORTS(2);\n\n\tkfree(buf);\nout:\n\tusb_set_serial_data(serial, (void *)device_flags);\n\n\treturn 0;\n}\n\nstatic int mos7840_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tunsigned long device_flags = (unsigned long)usb_get_serial_data(serial);\n\tint num_ports = MCS_PORTS(device_flags);\n\n\tif (num_ports == 0 || num_ports > 4)\n\t\treturn -ENODEV;\n\n\tif (epds->num_bulk_in < num_ports || epds->num_bulk_out < num_ports) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn num_ports;\n}\n\nstatic int mos7840_attach(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->interface->dev;\n\tint status;\n\tu16 val;\n\n\t \n\tval = 0x0f;\n\tstatus = mos7840_set_reg_sync(serial->port[0], ZLP_REG5, val);\n\tif (status < 0)\n\t\tdev_dbg(dev, \"Writing ZLP_REG5 failed status-0x%x\\n\", status);\n\telse\n\t\tdev_dbg(dev, \"ZLP_REG5 Writing success status%d\\n\", status);\n\n\treturn status;\n}\n\nstatic int mos7840_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long device_flags = (unsigned long)usb_get_serial_data(serial);\n\tstruct moschip_port *mos7840_port;\n\tint status;\n\tint pnum;\n\t__u16 Data;\n\n\t \n\n\tpnum = port->port_number;\n\n\tdev_dbg(&port->dev, \"mos7840_startup: configuring port %d\\n\", pnum);\n\tmos7840_port = kzalloc(sizeof(struct moschip_port), GFP_KERNEL);\n\tif (!mos7840_port)\n\t\treturn -ENOMEM;\n\n\t \n\n\tmos7840_port->port = port;\n\tspin_lock_init(&mos7840_port->pool_lock);\n\n\t \n\tmos7840_port->port_num = pnum + 1;\n\tdev_dbg(&port->dev, \"port->minor = %d\\n\", port->minor);\n\tdev_dbg(&port->dev, \"mos7840_port->port_num = %d\\n\", mos7840_port->port_num);\n\n\tif (mos7840_port->port_num == 1) {\n\t\tmos7840_port->SpRegOffset = 0x0;\n\t\tmos7840_port->ControlRegOffset = 0x1;\n\t\tmos7840_port->DcrRegOffset = 0x4;\n\t} else {\n\t\tu8 phy_num = mos7840_port->port_num;\n\n\t\t \n\t\tif (serial->num_ports == 2)\n\t\t\tphy_num = 3;\n\n\t\tmos7840_port->SpRegOffset = 0x8 + 2 * (phy_num - 2);\n\t\tmos7840_port->ControlRegOffset = 0x9 + 2 * (phy_num - 2);\n\t\tmos7840_port->DcrRegOffset = 0x16 + 3 * (phy_num - 2);\n\t}\n\tmos7840_dump_serial_port(port, mos7840_port);\n\tusb_set_serial_port_data(port, mos7840_port);\n\n\t \n\tstatus = mos7840_get_reg_sync(port,\n\t\t\tmos7840_port->ControlRegOffset, &Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Reading ControlReg failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"ControlReg Reading success val is %x, status%d\\n\", Data, status);\n\tData |= 0x08;\t \n\tData |= 0x04;\t \n\n\t \n\tstatus = mos7840_set_reg_sync(port,\n\t\t\tmos7840_port->ControlRegOffset, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing ControlReg failed(rx_disable) status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"ControlReg Writing success(rx_disable) status%d\\n\", status);\n\n\t \n\tData = 0x01;\n\tstatus = mos7840_set_reg_sync(port,\n\t\t\t(__u16) (mos7840_port->DcrRegOffset + 0), Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing DCR0 failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"DCR0 Writing success status%d\\n\", status);\n\n\tData = 0x05;\n\tstatus = mos7840_set_reg_sync(port,\n\t\t\t(__u16) (mos7840_port->DcrRegOffset + 1), Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing DCR1 failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"DCR1 Writing success status%d\\n\", status);\n\n\tData = 0x24;\n\tstatus = mos7840_set_reg_sync(port,\n\t\t\t(__u16) (mos7840_port->DcrRegOffset + 2), Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing DCR2 failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"DCR2 Writing success status%d\\n\", status);\n\n\t \n\tData = 0x0;\n\tstatus = mos7840_set_reg_sync(port, CLK_START_VALUE_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing CLK_START_VALUE_REGISTER failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"CLK_START_VALUE_REGISTER Writing success status%d\\n\", status);\n\n\tData = 0x20;\n\tstatus = mos7840_set_reg_sync(port, CLK_MULTI_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing CLK_MULTI_REGISTER failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"CLK_MULTI_REGISTER Writing success status%d\\n\", status);\n\n\t \n\tData = 0x00;\n\tstatus = mos7840_set_uart_reg(port, SCRATCH_PAD_REGISTER, Data);\n\tif (status < 0) {\n\t\tdev_dbg(&port->dev, \"Writing SCRATCH_PAD_REGISTER failed status-0x%x\\n\", status);\n\t\tgoto error;\n\t} else\n\t\tdev_dbg(&port->dev, \"SCRATCH_PAD_REGISTER Writing success status%d\\n\", status);\n\n\t \n\tif ((mos7840_port->port_num != 1) && (serial->num_ports == 2)) {\n\t\tData = 0xff;\n\t\tstatus = mos7840_set_reg_sync(port,\n\t\t\t\t(__u16) (ZLP_REG1 +\n\t\t\t\t\t((__u16)mos7840_port->port_num)), Data);\n\t\tdev_dbg(&port->dev, \"ZLIP offset %x\\n\",\n\t\t\t\t(__u16)(ZLP_REG1 + ((__u16) mos7840_port->port_num)));\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"Writing ZLP_REG%d failed status-0x%x\\n\", pnum + 2, status);\n\t\t\tgoto error;\n\t\t} else\n\t\t\tdev_dbg(&port->dev, \"ZLP_REG%d Writing success status%d\\n\", pnum + 2, status);\n\t} else {\n\t\tData = 0xff;\n\t\tstatus = mos7840_set_reg_sync(port,\n\t\t\t\t(__u16) (ZLP_REG1 +\n\t\t\t\t\t((__u16)mos7840_port->port_num) - 0x1), Data);\n\t\tdev_dbg(&port->dev, \"ZLIP offset %x\\n\",\n\t\t\t\t(__u16)(ZLP_REG1 + ((__u16) mos7840_port->port_num) - 0x1));\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&port->dev, \"Writing ZLP_REG%d failed status-0x%x\\n\", pnum + 1, status);\n\t\t\tgoto error;\n\t\t} else\n\t\t\tdev_dbg(&port->dev, \"ZLP_REG%d Writing success status%d\\n\", pnum + 1, status);\n\n\t}\n\n\tmos7840_port->has_led = device_flags & MCS_LED;\n\n\t \n\tif (mos7840_port->has_led) {\n\t\tmos7840_port->led_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tmos7840_port->led_dr = kmalloc(sizeof(*mos7840_port->led_dr),\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (!mos7840_port->led_urb || !mos7840_port->led_dr) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\n\t\ttimer_setup(&mos7840_port->led_timer1, mos7840_led_off, 0);\n\t\tmos7840_port->led_timer1.expires =\n\t\t\tjiffies + msecs_to_jiffies(LED_ON_MS);\n\t\ttimer_setup(&mos7840_port->led_timer2, mos7840_led_flag_off,\n\t\t\t    0);\n\t\tmos7840_port->led_timer2.expires =\n\t\t\tjiffies + msecs_to_jiffies(LED_OFF_MS);\n\n\t\t \n\t\tmos7840_set_led_sync(port, MODEM_CONTROL_REGISTER, 0x0300);\n\t}\n\n\treturn 0;\nerror:\n\tkfree(mos7840_port->led_dr);\n\tusb_free_urb(mos7840_port->led_urb);\n\tkfree(mos7840_port);\n\n\treturn status;\n}\n\nstatic void mos7840_port_remove(struct usb_serial_port *port)\n{\n\tstruct moschip_port *mos7840_port = usb_get_serial_port_data(port);\n\n\tif (mos7840_port->has_led) {\n\t\t \n\t\tmos7840_set_led_sync(port, MODEM_CONTROL_REGISTER, 0x0300);\n\n\t\ttimer_shutdown_sync(&mos7840_port->led_timer1);\n\t\ttimer_shutdown_sync(&mos7840_port->led_timer2);\n\n\t\tusb_kill_urb(mos7840_port->led_urb);\n\t\tusb_free_urb(mos7840_port->led_urb);\n\t\tkfree(mos7840_port->led_dr);\n\t}\n\n\tkfree(mos7840_port);\n}\n\nstatic struct usb_serial_driver moschip7840_4port_device = {\n\t.driver = {\n\t\t   .owner = THIS_MODULE,\n\t\t   .name = \"mos7840\",\n\t\t   },\n\t.description = DRIVER_DESC,\n\t.id_table = id_table,\n\t.num_interrupt_in = 1,\n\t.open = mos7840_open,\n\t.close = mos7840_close,\n\t.write = mos7840_write,\n\t.write_room = mos7840_write_room,\n\t.chars_in_buffer = mos7840_chars_in_buffer,\n\t.throttle = mos7840_throttle,\n\t.unthrottle = mos7840_unthrottle,\n\t.calc_num_ports = mos7840_calc_num_ports,\n\t.probe = mos7840_probe,\n\t.attach = mos7840_attach,\n\t.ioctl = mos7840_ioctl,\n\t.set_termios = mos7840_set_termios,\n\t.break_ctl = mos7840_break,\n\t.tiocmget = mos7840_tiocmget,\n\t.tiocmset = mos7840_tiocmset,\n\t.get_icount = usb_serial_generic_get_icount,\n\t.port_probe = mos7840_port_probe,\n\t.port_remove = mos7840_port_remove,\n\t.read_bulk_callback = mos7840_bulk_in_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&moschip7840_4port_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}