{
  "module_name": "navman.c",
  "hash_id": "3f8c23f2ee3e7762990dfc4a98371982974d5ad80ccac842dd76de98fc8a75f3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/navman.c",
  "human_readable_source": "\n \n\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x0a99, 0x0001) },\t \n\t{ USB_DEVICE(0x0df7, 0x0900) },\t \n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic void navman_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\tif (urb->actual_length) {\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - Error %d submitting interrupt urb\\n\",\n\t\t\t__func__, result);\n}\n\nstatic int navman_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result = 0;\n\n\tif (port->interrupt_in_urb) {\n\t\tdev_dbg(&port->dev, \"%s - adding interrupt input for treo\\n\",\n\t\t\t__func__);\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t\t\"%s - failed submitting interrupt urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t}\n\treturn result;\n}\n\nstatic void navman_close(struct usb_serial_port *port)\n{\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic int navman_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *buf, int count)\n{\n\t \n\treturn -EOPNOTSUPP;\n}\n\nstatic struct usb_serial_driver navman_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"navman\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.open =\t\t\tnavman_open,\n\t.close = \t\tnavman_close,\n\t.write = \t\tnavman_write,\n\t.read_int_callback =\tnavman_read_int_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&navman_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}