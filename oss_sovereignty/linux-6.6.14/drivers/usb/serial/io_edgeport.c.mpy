{
  "module_name": "io_edgeport.c",
  "hash_id": "a9d0c1a303b3eaa3cae1ac2602911c4ba039da59aedfc80cecc0489f73a388d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/io_edgeport.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/serial.h>\n#include <linux/ioctl.h>\n#include <linux/wait.h>\n#include <linux/firmware.h>\n#include <linux/ihex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include \"io_edgeport.h\"\n#include \"io_ionsp.h\"\t\t \n#include \"io_16654.h\"\t\t \n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com> and David Iacovelli\"\n#define DRIVER_DESC \"Edgeport USB Serial Driver\"\n\n#define MAX_NAME_LEN\t\t64\n\n#define OPEN_TIMEOUT\t\t(5*HZ)\t\t \n\nstatic const struct usb_device_id edgeport_2port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_2_DIN) },\n\t{ }\n};\n\nstatic const struct usb_device_id edgeport_4port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_RAPIDPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4T) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_MT4X56USB) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8_DUAL_CPU) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_4_DIN) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_COMPATIBLE) },\n\t{ }\n};\n\nstatic const struct usb_device_id edgeport_8port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8R) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8RR) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_8) },\n\t{ }\n};\n\nstatic const struct usb_device_id Epic_port_id_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0202) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0203) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0310) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0311) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0312) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A758) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A794) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A225) },\n\t{ }\n};\n\n \nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_RAPIDPORT_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_4T) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_MT4X56USB) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_4I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_2I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_421) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_21) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_8_DUAL_CPU) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_2_DIN) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_4_DIN) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_16_DUAL_CPU) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_22I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_4) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_COMPATIBLE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION,\tION_DEVICE_ID_EDGEPORT_8I) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8R) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_8RR) },\n\t{ USB_DEVICE(USB_VENDOR_ID_ION, ION_DEVICE_ID_EDGEPORT_412_8) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0202) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0203) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0310) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0311) },\n\t{ USB_DEVICE(USB_VENDOR_ID_NCR, NCR_DEVICE_ID_EPIC_0312) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A758) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A794) },\n\t{ USB_DEVICE(USB_VENDOR_ID_AXIOHM, AXIOHM_DEVICE_ID_EPIC_A225) },\n\t{ }  \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n\n \nenum RXSTATE {\n\tEXPECT_HDR1 = 0,     \n\tEXPECT_HDR2 = 1,     \n\tEXPECT_DATA = 2,     \n\tEXPECT_HDR3 = 3,     \n};\n\n\n \nstruct TxFifo {\n\tunsigned int\thead;\t \n\tunsigned int\ttail;\t \n\tunsigned int\tcount;\t \n\tunsigned int\tsize;\t \n\tunsigned char\t*fifo;\t \n};\n\n \nstruct edgeport_port {\n\t__u16\t\t\ttxCredits;\t\t \n\t__u16\t\t\tmaxTxCredits;\t\t \n\n\tstruct TxFifo\t\ttxfifo;\t\t\t \n\tstruct urb\t\t*write_urb;\t\t \n\tbool\t\t\twrite_in_progress;\t \n\tspinlock_t\t\tep_lock;\n\n\t__u8\t\t\tshadowLCR;\t\t \n\t__u8\t\t\tshadowMCR;\t\t \n\t__u8\t\t\tshadowMSR;\t\t \n\t__u8\t\t\tshadowLSR;\t\t \n\t__u8\t\t\tshadowXonChar;\t\t \n\t__u8\t\t\tshadowXoffChar;\t\t \n\t__u8\t\t\tvalidDataMask;\n\t__u32\t\t\tbaudRate;\n\n\tbool\t\t\topen;\n\tbool\t\t\topenPending;\n\tbool\t\t\tcommandPending;\n\tbool\t\t\tclosePending;\n\tbool\t\t\tchaseResponsePending;\n\n\twait_queue_head_t\twait_chase;\t\t \n\twait_queue_head_t\twait_open;\t\t \n\twait_queue_head_t\twait_command;\t\t \n\n\tstruct usb_serial_port\t*port;\t\t\t \n};\n\n\n \nstruct edgeport_serial {\n\tchar\t\t\tname[MAX_NAME_LEN+2];\t\t \n\n\tstruct edge_manuf_descriptor\tmanuf_descriptor;\t \n\tstruct edge_boot_descriptor\tboot_descriptor;\t \n\tstruct edgeport_product_info\tproduct_info;\t\t \n\tstruct edge_compatibility_descriptor epic_descriptor;\t \n\tint\t\t\tis_epic;\t\t\t \n\n\t__u8\t\t\tinterrupt_in_endpoint;\t\t \n\tunsigned char\t\t*interrupt_in_buffer;\t\t \n\tstruct urb\t\t*interrupt_read_urb;\t\t \n\n\t__u8\t\t\tbulk_in_endpoint;\t\t \n\tunsigned char\t\t*bulk_in_buffer;\t\t \n\tstruct urb\t\t*read_urb;\t\t\t \n\tbool\t\t\tread_in_progress;\n\tspinlock_t\t\tes_lock;\n\n\t__u8\t\t\tbulk_out_endpoint;\t\t \n\n\t__s16\t\t\trxBytesAvail;\t\t\t \n\n\tenum RXSTATE\t\trxState;\t\t\t \n\t__u8\t\t\trxHeader1;\t\t\t \n\t__u8\t\t\trxHeader2;\t\t\t \n\t__u8\t\t\trxHeader3;\t\t\t \n\t__u8\t\t\trxPort;\t\t\t\t \n\t__u8\t\t\trxStatusCode;\t\t\t \n\t__u8\t\t\trxStatusParam;\t\t\t \n\t__s16\t\t\trxBytesRemaining;\t\t \n\tstruct usb_serial\t*serial;\t\t\t \n};\n\n \nstruct divisor_table_entry {\n\t__u32   BaudRate;\n\t__u16  Divisor;\n};\n\n \n\nstatic const struct divisor_table_entry divisor_table[] = {\n\t{   50,\t\t4608},\n\t{   75,\t\t3072},\n\t{   110,\t2095},\t \n\t{   134,\t1713},\t \n\t{   150,\t1536},\n\t{   300,\t768},\n\t{   600,\t384},\n\t{   1200,\t192},\n\t{   1800,\t128},\n\t{   2400,\t96},\n\t{   4800,\t48},\n\t{   7200,\t32},\n\t{   9600,\t24},\n\t{   14400,\t16},\n\t{   19200,\t12},\n\t{   38400,\t6},\n\t{   57600,\t4},\n\t{   115200,\t2},\n\t{   230400,\t1},\n};\n\n \nstatic atomic_t CmdUrbs = ATOMIC_INIT(0);\n\n\n \n\nstatic void edge_close(struct usb_serial_port *port);\n\nstatic void  process_rcvd_data(struct edgeport_serial *edge_serial,\n\t\t\t\tunsigned char *buffer, __u16 bufferLength);\nstatic void process_rcvd_status(struct edgeport_serial *edge_serial,\n\t\t\t\t__u8 byte2, __u8 byte3);\nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length);\nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 newMsr);\nstatic void handle_new_lsr(struct edgeport_port *edge_port, __u8 lsrData,\n\t\t\t\t__u8 lsr, __u8 data);\nstatic int  send_iosp_ext_cmd(struct edgeport_port *edge_port, __u8 command,\n\t\t\t\t__u8 param);\nstatic int  calc_baud_rate_divisor(struct device *dev, int baud_rate, int *divisor);\nstatic void change_port_settings(struct tty_struct *tty,\n\t\t\t\tstruct edgeport_port *edge_port,\n\t\t\t\tconst struct ktermios *old_termios);\nstatic int  send_cmd_write_uart_register(struct edgeport_port *edge_port,\n\t\t\t\t__u8 regNum, __u8 regValue);\nstatic int  write_cmd_usb(struct edgeport_port *edge_port,\n\t\t\t\tunsigned char *buffer, int writeLength);\nstatic void send_more_port_data(struct edgeport_serial *edge_serial,\n\t\t\t\tstruct edgeport_port *edge_port);\n\nstatic int rom_write(struct usb_serial *serial, __u16 extAddr, __u16 addr,\n\t\t\t\t\t__u16 length, const __u8 *data);\n\n \n \n \n \n\n \nstatic void update_edgeport_E2PROM(struct edgeport_serial *edge_serial)\n{\n\tstruct device *dev = &edge_serial->serial->dev->dev;\n\t__u32 BootCurVer;\n\t__u32 BootNewVer;\n\t__u8 BootMajorVersion;\n\t__u8 BootMinorVersion;\n\t__u16 BootBuildNumber;\n\t__u32 Bootaddr;\n\tconst struct ihex_binrec *rec;\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tint response;\n\n\tswitch (edge_serial->product_info.iDownloadFile) {\n\tcase EDGE_DOWNLOAD_FILE_I930:\n\t\tfw_name\t= \"edgeport/boot.fw\";\n\t\tbreak;\n\tcase EDGE_DOWNLOAD_FILE_80251:\n\t\tfw_name\t= \"edgeport/boot2.fw\";\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\n\tresponse = request_ihex_firmware(&fw, fw_name,\n\t\t\t\t\t &edge_serial->serial->dev->dev);\n\tif (response) {\n\t\tdev_err(dev, \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fw_name, response);\n\t\treturn;\n\t}\n\n\trec = (const struct ihex_binrec *)fw->data;\n\tBootMajorVersion = rec->data[0];\n\tBootMinorVersion = rec->data[1];\n\tBootBuildNumber = (rec->data[2] << 8) | rec->data[3];\n\n\t \n\tBootCurVer = (edge_serial->boot_descriptor.MajorVersion << 24) +\n\t\t     (edge_serial->boot_descriptor.MinorVersion << 16) +\n\t\t      le16_to_cpu(edge_serial->boot_descriptor.BuildNumber);\n\n\tBootNewVer = (BootMajorVersion << 24) +\n\t\t     (BootMinorVersion << 16) +\n\t\t      BootBuildNumber;\n\n\tdev_dbg(dev, \"Current Boot Image version %d.%d.%d\\n\",\n\t    edge_serial->boot_descriptor.MajorVersion,\n\t    edge_serial->boot_descriptor.MinorVersion,\n\t    le16_to_cpu(edge_serial->boot_descriptor.BuildNumber));\n\n\n\tif (BootNewVer > BootCurVer) {\n\t\tdev_dbg(dev, \"**Update Boot Image from %d.%d.%d to %d.%d.%d\\n\",\n\t\t    edge_serial->boot_descriptor.MajorVersion,\n\t\t    edge_serial->boot_descriptor.MinorVersion,\n\t\t    le16_to_cpu(edge_serial->boot_descriptor.BuildNumber),\n\t\t    BootMajorVersion, BootMinorVersion, BootBuildNumber);\n\n\t\tdev_dbg(dev, \"Downloading new Boot Image\\n\");\n\n\t\tfor (rec = ihex_next_binrec(rec); rec;\n\t\t     rec = ihex_next_binrec(rec)) {\n\t\t\tBootaddr = be32_to_cpu(rec->addr);\n\t\t\tresponse = rom_write(edge_serial->serial,\n\t\t\t\t\t     Bootaddr >> 16,\n\t\t\t\t\t     Bootaddr & 0xFFFF,\n\t\t\t\t\t     be16_to_cpu(rec->len),\n\t\t\t\t\t     &rec->data[0]);\n\t\t\tif (response < 0) {\n\t\t\t\tdev_err(&edge_serial->serial->dev->dev,\n\t\t\t\t\t\"rom_write failed (%x, %x, %d)\\n\",\n\t\t\t\t\tBootaddr >> 16, Bootaddr & 0xFFFF,\n\t\t\t\t\tbe16_to_cpu(rec->len));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tdev_dbg(dev, \"Boot Image -- already up to date\\n\");\n\t}\n\trelease_firmware(fw);\n}\n\nstatic void dump_product_info(struct edgeport_serial *edge_serial,\n\t\t\t      struct edgeport_product_info *product_info)\n{\n\tstruct device *dev = &edge_serial->serial->dev->dev;\n\n\t \n\tdev_dbg(dev, \"**Product Information:\\n\");\n\tdev_dbg(dev, \"  ProductId             %x\\n\", product_info->ProductId);\n\tdev_dbg(dev, \"  NumPorts              %d\\n\", product_info->NumPorts);\n\tdev_dbg(dev, \"  ProdInfoVer           %d\\n\", product_info->ProdInfoVer);\n\tdev_dbg(dev, \"  IsServer              %d\\n\", product_info->IsServer);\n\tdev_dbg(dev, \"  IsRS232               %d\\n\", product_info->IsRS232);\n\tdev_dbg(dev, \"  IsRS422               %d\\n\", product_info->IsRS422);\n\tdev_dbg(dev, \"  IsRS485               %d\\n\", product_info->IsRS485);\n\tdev_dbg(dev, \"  RomSize               %d\\n\", product_info->RomSize);\n\tdev_dbg(dev, \"  RamSize               %d\\n\", product_info->RamSize);\n\tdev_dbg(dev, \"  CpuRev                %x\\n\", product_info->CpuRev);\n\tdev_dbg(dev, \"  BoardRev              %x\\n\", product_info->BoardRev);\n\tdev_dbg(dev, \"  BootMajorVersion      %d.%d.%d\\n\",\n\t\tproduct_info->BootMajorVersion,\n\t\tproduct_info->BootMinorVersion,\n\t\tle16_to_cpu(product_info->BootBuildNumber));\n\tdev_dbg(dev, \"  FirmwareMajorVersion  %d.%d.%d\\n\",\n\t\tproduct_info->FirmwareMajorVersion,\n\t\tproduct_info->FirmwareMinorVersion,\n\t\tle16_to_cpu(product_info->FirmwareBuildNumber));\n\tdev_dbg(dev, \"  ManufactureDescDate   %d/%d/%d\\n\",\n\t\tproduct_info->ManufactureDescDate[0],\n\t\tproduct_info->ManufactureDescDate[1],\n\t\tproduct_info->ManufactureDescDate[2]+1900);\n\tdev_dbg(dev, \"  iDownloadFile         0x%x\\n\",\n\t\tproduct_info->iDownloadFile);\n\tdev_dbg(dev, \"  EpicVer               %d\\n\", product_info->EpicVer);\n}\n\nstatic void get_product_info(struct edgeport_serial *edge_serial)\n{\n\tstruct edgeport_product_info *product_info = &edge_serial->product_info;\n\n\tmemset(product_info, 0, sizeof(struct edgeport_product_info));\n\n\tproduct_info->ProductId = (__u16)(le16_to_cpu(edge_serial->serial->dev->descriptor.idProduct) & ~ION_DEVICE_ID_80251_NETCHIP);\n\tproduct_info->NumPorts = edge_serial->manuf_descriptor.NumPorts;\n\tproduct_info->ProdInfoVer = 0;\n\n\tproduct_info->RomSize = edge_serial->manuf_descriptor.RomSize;\n\tproduct_info->RamSize = edge_serial->manuf_descriptor.RamSize;\n\tproduct_info->CpuRev = edge_serial->manuf_descriptor.CpuRev;\n\tproduct_info->BoardRev = edge_serial->manuf_descriptor.BoardRev;\n\n\tproduct_info->BootMajorVersion =\n\t\t\t\tedge_serial->boot_descriptor.MajorVersion;\n\tproduct_info->BootMinorVersion =\n\t\t\t\tedge_serial->boot_descriptor.MinorVersion;\n\tproduct_info->BootBuildNumber =\n\t\t\t\tedge_serial->boot_descriptor.BuildNumber;\n\n\tmemcpy(product_info->ManufactureDescDate,\n\t\t\tedge_serial->manuf_descriptor.DescDate,\n\t\t\tsizeof(edge_serial->manuf_descriptor.DescDate));\n\n\t \n\tif (le16_to_cpu(edge_serial->serial->dev->descriptor.idProduct)\n\t\t\t\t\t    & ION_DEVICE_ID_80251_NETCHIP)\n\t\tproduct_info->iDownloadFile = EDGE_DOWNLOAD_FILE_80251;\n\telse\n\t\tproduct_info->iDownloadFile = EDGE_DOWNLOAD_FILE_I930;\n\n\t \n\tswitch (DEVICE_ID_FROM_USB_PRODUCT_ID(product_info->ProductId)) {\n\tcase ION_DEVICE_ID_EDGEPORT_COMPATIBLE:\n\tcase ION_DEVICE_ID_EDGEPORT_4T:\n\tcase ION_DEVICE_ID_EDGEPORT_4:\n\tcase ION_DEVICE_ID_EDGEPORT_2:\n\tcase ION_DEVICE_ID_EDGEPORT_8_DUAL_CPU:\n\tcase ION_DEVICE_ID_EDGEPORT_8:\n\tcase ION_DEVICE_ID_EDGEPORT_421:\n\tcase ION_DEVICE_ID_EDGEPORT_21:\n\tcase ION_DEVICE_ID_EDGEPORT_2_DIN:\n\tcase ION_DEVICE_ID_EDGEPORT_4_DIN:\n\tcase ION_DEVICE_ID_EDGEPORT_16_DUAL_CPU:\n\t\tproduct_info->IsRS232 = 1;\n\t\tbreak;\n\n\tcase ION_DEVICE_ID_EDGEPORT_2I:\t \n\t\tproduct_info->IsRS422 = 1;\n\t\tproduct_info->IsRS485 = 1;\n\t\tbreak;\n\n\tcase ION_DEVICE_ID_EDGEPORT_8I:\t \n\tcase ION_DEVICE_ID_EDGEPORT_4I:\t \n\t\tproduct_info->IsRS422 = 1;\n\t\tbreak;\n\t}\n\n\tdump_product_info(edge_serial, product_info);\n}\n\nstatic int get_epic_descriptor(struct edgeport_serial *ep)\n{\n\tint result;\n\tstruct usb_serial *serial = ep->serial;\n\tstruct edgeport_product_info *product_info = &ep->product_info;\n\tstruct edge_compatibility_descriptor *epic;\n\tstruct edge_compatibility_bits *bits;\n\tstruct device *dev = &serial->dev->dev;\n\n\tep->is_epic = 0;\n\n\tepic = kmalloc(sizeof(*epic), GFP_KERNEL);\n\tif (!epic)\n\t\treturn -ENOMEM;\n\n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t USB_REQUEST_ION_GET_EPIC_DESC,\n\t\t\t\t 0xC0, 0x00, 0x00,\n\t\t\t\t epic, sizeof(*epic),\n\t\t\t\t 300);\n\tif (result == sizeof(*epic)) {\n\t\tep->is_epic = 1;\n\t\tmemcpy(&ep->epic_descriptor, epic, sizeof(*epic));\n\t\tmemset(product_info, 0, sizeof(struct edgeport_product_info));\n\n\t\tproduct_info->NumPorts = epic->NumPorts;\n\t\tproduct_info->ProdInfoVer = 0;\n\t\tproduct_info->FirmwareMajorVersion = epic->MajorVersion;\n\t\tproduct_info->FirmwareMinorVersion = epic->MinorVersion;\n\t\tproduct_info->FirmwareBuildNumber = epic->BuildNumber;\n\t\tproduct_info->iDownloadFile = epic->iDownloadFile;\n\t\tproduct_info->EpicVer = epic->EpicVer;\n\t\tproduct_info->Epic = epic->Supports;\n\t\tproduct_info->ProductId = ION_DEVICE_ID_EDGEPORT_COMPATIBLE;\n\t\tdump_product_info(ep, product_info);\n\n\t\tbits = &ep->epic_descriptor.Supports;\n\t\tdev_dbg(dev, \"**EPIC descriptor:\\n\");\n\t\tdev_dbg(dev, \"  VendEnableSuspend: %s\\n\", bits->VendEnableSuspend ? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPOpen         : %s\\n\", bits->IOSPOpen\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPClose        : %s\\n\", bits->IOSPClose\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPChase        : %s\\n\", bits->IOSPChase\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPSetRxFlow    : %s\\n\", bits->IOSPSetRxFlow\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPSetTxFlow    : %s\\n\", bits->IOSPSetTxFlow\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPSetXChar     : %s\\n\", bits->IOSPSetXChar\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPRxCheck      : %s\\n\", bits->IOSPRxCheck\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPSetClrBreak  : %s\\n\", bits->IOSPSetClrBreak\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPWriteMCR     : %s\\n\", bits->IOSPWriteMCR\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPWriteLCR     : %s\\n\", bits->IOSPWriteLCR\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  IOSPSetBaudRate  : %s\\n\", bits->IOSPSetBaudRate\t? \"TRUE\": \"FALSE\");\n\t\tdev_dbg(dev, \"  TrueEdgeport     : %s\\n\", bits->TrueEdgeport\t? \"TRUE\": \"FALSE\");\n\n\t\tresult = 0;\n\t} else if (result >= 0) {\n\t\tdev_warn(&serial->interface->dev, \"short epic descriptor received: %d\\n\",\n\t\t\t result);\n\t\tresult = -EIO;\n\t}\n\n\tkfree(epic);\n\n\treturn result;\n}\n\n\n \n \n \n \n \n \n\n \nstatic void edge_interrupt_callback(struct urb *urb)\n{\n\tstruct edgeport_serial *edge_serial = urb->context;\n\tstruct device *dev;\n\tstruct edgeport_port *edge_port;\n\tstruct usb_serial_port *port;\n\tunsigned char *data = urb->transfer_buffer;\n\tint length = urb->actual_length;\n\tunsigned long flags;\n\tint bytes_avail;\n\tint position;\n\tint txCredits;\n\tint portNumber;\n\tint result;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&urb->dev->dev, \"%s - urb shutting down with status: %d\\n\", __func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero urb status received: %d\\n\", __func__, status);\n\t\tgoto exit;\n\t}\n\n\tdev = &edge_serial->serial->dev->dev;\n\n\t \n\tif (length) {\n\t\tusb_serial_debug_data(dev, __func__, length, data);\n\n\t\tif (length > 1) {\n\t\t\tbytes_avail = data[0] | (data[1] << 8);\n\t\t\tif (bytes_avail) {\n\t\t\t\tspin_lock_irqsave(&edge_serial->es_lock, flags);\n\t\t\t\tedge_serial->rxBytesAvail += bytes_avail;\n\t\t\t\tdev_dbg(dev,\n\t\t\t\t\t\"%s - bytes_avail=%d, rxBytesAvail=%d, read_in_progress=%d\\n\",\n\t\t\t\t\t__func__, bytes_avail,\n\t\t\t\t\tedge_serial->rxBytesAvail,\n\t\t\t\t\tedge_serial->read_in_progress);\n\n\t\t\t\tif (edge_serial->rxBytesAvail > 0 &&\n\t\t\t\t    !edge_serial->read_in_progress) {\n\t\t\t\t\tdev_dbg(dev, \"%s - posting a read\\n\", __func__);\n\t\t\t\t\tedge_serial->read_in_progress = true;\n\n\t\t\t\t\t \n\t\t\t\t\tresult = usb_submit_urb(edge_serial->read_urb, GFP_ATOMIC);\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tdev_err(dev,\n\t\t\t\t\t\t\t\"%s - usb_submit_urb(read bulk) failed with result = %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\t\t\t\t\tedge_serial->read_in_progress = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&edge_serial->es_lock,\n\t\t\t\t\t\t       flags);\n\t\t\t}\n\t\t}\n\t\t \n\t\tposition = 2;\n\t\tportNumber = 0;\n\t\twhile ((position < length - 1) &&\n\t\t\t\t(portNumber < edge_serial->serial->num_ports)) {\n\t\t\ttxCredits = data[position] | (data[position+1] << 8);\n\t\t\tif (txCredits) {\n\t\t\t\tport = edge_serial->serial->port[portNumber];\n\t\t\t\tedge_port = usb_get_serial_port_data(port);\n\t\t\t\tif (edge_port && edge_port->open) {\n\t\t\t\t\tspin_lock_irqsave(&edge_port->ep_lock,\n\t\t\t\t\t\t\t  flags);\n\t\t\t\t\tedge_port->txCredits += txCredits;\n\t\t\t\t\tspin_unlock_irqrestore(&edge_port->ep_lock,\n\t\t\t\t\t\t\t       flags);\n\t\t\t\t\tdev_dbg(dev, \"%s - txcredits for port%d = %d\\n\",\n\t\t\t\t\t\t__func__, portNumber,\n\t\t\t\t\t\tedge_port->txCredits);\n\n\t\t\t\t\t \n\t\t\t\t\ttty_port_tty_wakeup(&edge_port->port->port);\n\t\t\t\t\t \n\t\t\t\t\tsend_more_port_data(edge_serial,\n\t\t\t\t\t\t\t\tedge_port);\n\t\t\t\t}\n\t\t\t}\n\t\t\tposition += 2;\n\t\t\t++portNumber;\n\t\t}\n\t}\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\"%s - Error %d submitting control urb\\n\",\n\t\t\t\t\t\t__func__, result);\n}\n\n\n \nstatic void edge_bulk_in_callback(struct urb *urb)\n{\n\tstruct edgeport_serial\t*edge_serial = urb->context;\n\tstruct device *dev;\n\tunsigned char\t\t*data = urb->transfer_buffer;\n\tint\t\t\tretval;\n\t__u16\t\t\traw_data_length;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - nonzero read bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tedge_serial->read_in_progress = false;\n\t\treturn;\n\t}\n\n\tif (urb->actual_length == 0) {\n\t\tdev_dbg(&urb->dev->dev, \"%s - read bulk callback with no data\\n\", __func__);\n\t\tedge_serial->read_in_progress = false;\n\t\treturn;\n\t}\n\n\tdev = &edge_serial->serial->dev->dev;\n\traw_data_length = urb->actual_length;\n\n\tusb_serial_debug_data(dev, __func__, raw_data_length, data);\n\n\tspin_lock_irqsave(&edge_serial->es_lock, flags);\n\n\t \n\tedge_serial->rxBytesAvail -= raw_data_length;\n\n\tdev_dbg(dev, \"%s - Received = %d, rxBytesAvail %d\\n\", __func__,\n\t\traw_data_length, edge_serial->rxBytesAvail);\n\n\tprocess_rcvd_data(edge_serial, data, urb->actual_length);\n\n\t \n\tif (edge_serial->rxBytesAvail > 0) {\n\t\tdev_dbg(dev, \"%s - posting a read\\n\", __func__);\n\t\tretval = usb_submit_urb(edge_serial->read_urb, GFP_ATOMIC);\n\t\tif (retval) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"%s - usb_submit_urb(read bulk) failed, retval = %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tedge_serial->read_in_progress = false;\n\t\t}\n\t} else {\n\t\tedge_serial->read_in_progress = false;\n\t}\n\n\tspin_unlock_irqrestore(&edge_serial->es_lock, flags);\n}\n\n\n \nstatic void edge_bulk_out_data_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t}\n\n\tif (edge_port->open)\n\t\ttty_port_tty_wakeup(&edge_port->port->port);\n\n\t \n\tedge_port->write_in_progress = false;\n\n\t \n\tsend_more_port_data((struct edgeport_serial *)\n\t\t(usb_get_serial_data(edge_port->port->serial)), edge_port);\n}\n\n\n \nstatic void edge_bulk_out_cmd_callback(struct urb *urb)\n{\n\tstruct edgeport_port *edge_port = urb->context;\n\tint status = urb->status;\n\n\tatomic_dec(&CmdUrbs);\n\tdev_dbg(&urb->dev->dev, \"%s - FREE URB %p (outstanding %d)\\n\",\n\t\t__func__, urb, atomic_read(&CmdUrbs));\n\n\n\t \n\tkfree(urb->transfer_buffer);\n\n\t \n\tusb_free_urb(urb);\n\n\tif (status) {\n\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\t \n\tif (edge_port->open)\n\t\ttty_port_tty_wakeup(&edge_port->port->port);\n\n\t \n\tedge_port->commandPending = false;\n\twake_up(&edge_port->wait_command);\n}\n\n\n \n\n \nstatic int edge_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tstruct usb_serial *serial;\n\tstruct edgeport_serial *edge_serial;\n\tint response;\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tserial = port->serial;\n\tedge_serial = usb_get_serial_data(serial);\n\tif (edge_serial == NULL)\n\t\treturn -ENODEV;\n\tif (edge_serial->interrupt_in_buffer == NULL) {\n\t\tstruct usb_serial_port *port0 = serial->port[0];\n\n\t\t \n\t\tedge_serial->interrupt_in_buffer =\n\t\t\t\t\tport0->interrupt_in_buffer;\n\t\tedge_serial->interrupt_in_endpoint =\n\t\t\t\t\tport0->interrupt_in_endpointAddress;\n\t\tedge_serial->interrupt_read_urb = port0->interrupt_in_urb;\n\t\tedge_serial->bulk_in_buffer = port0->bulk_in_buffer;\n\t\tedge_serial->bulk_in_endpoint =\n\t\t\t\t\tport0->bulk_in_endpointAddress;\n\t\tedge_serial->read_urb = port0->read_urb;\n\t\tedge_serial->bulk_out_endpoint =\n\t\t\t\t\tport0->bulk_out_endpointAddress;\n\n\t\t \n\t\tusb_fill_int_urb(edge_serial->interrupt_read_urb,\n\t\t      serial->dev,\n\t\t      usb_rcvintpipe(serial->dev,\n\t\t\t\tport0->interrupt_in_endpointAddress),\n\t\t      port0->interrupt_in_buffer,\n\t\t      edge_serial->interrupt_read_urb->transfer_buffer_length,\n\t\t      edge_interrupt_callback, edge_serial,\n\t\t      edge_serial->interrupt_read_urb->interval);\n\n\t\t \n\t\tusb_fill_bulk_urb(edge_serial->read_urb, serial->dev,\n\t\t\tusb_rcvbulkpipe(serial->dev,\n\t\t\t\tport0->bulk_in_endpointAddress),\n\t\t\tport0->bulk_in_buffer,\n\t\t\tedge_serial->read_urb->transfer_buffer_length,\n\t\t\tedge_bulk_in_callback, edge_serial);\n\t\tedge_serial->read_in_progress = false;\n\n\t\t \n\t\tresponse = usb_submit_urb(edge_serial->interrupt_read_urb,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (response) {\n\t\t\tdev_err(dev, \"%s - Error %d submitting control urb\\n\",\n\t\t\t\t__func__, response);\n\t\t}\n\t}\n\n\t \n\tinit_waitqueue_head(&edge_port->wait_open);\n\tinit_waitqueue_head(&edge_port->wait_chase);\n\tinit_waitqueue_head(&edge_port->wait_command);\n\n\t \n\tedge_port->txCredits = 0;\t \n\t \n\tedge_port->shadowMCR = MCR_MASTER_IE;\n\tedge_port->chaseResponsePending = false;\n\n\t \n\tedge_port->openPending = true;\n\tedge_port->open        = false;\n\tresponse = send_iosp_ext_cmd(edge_port, IOSP_CMD_OPEN_PORT, 0);\n\n\tif (response < 0) {\n\t\tdev_err(dev, \"%s - error sending open port command\\n\", __func__);\n\t\tedge_port->openPending = false;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\twait_event_timeout(edge_port->wait_open, !edge_port->openPending,\n\t\t\t\t\t\t\t\tOPEN_TIMEOUT);\n\n\tif (!edge_port->open) {\n\t\t \n\t\tdev_dbg(dev, \"%s - open timeout\\n\", __func__);\n\t\tedge_port->openPending = false;\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tedge_port->txfifo.head\t= 0;\n\tedge_port->txfifo.tail\t= 0;\n\tedge_port->txfifo.count\t= 0;\n\tedge_port->txfifo.size\t= edge_port->maxTxCredits;\n\tedge_port->txfifo.fifo\t= kmalloc(edge_port->maxTxCredits, GFP_KERNEL);\n\n\tif (!edge_port->txfifo.fifo) {\n\t\tedge_close(port);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tedge_port->write_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tedge_port->write_in_progress = false;\n\n\tif (!edge_port->write_urb) {\n\t\tedge_close(port);\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_dbg(dev, \"%s - Initialize TX fifo to %d bytes\\n\",\n\t\t__func__, edge_port->maxTxCredits);\n\n\treturn 0;\n}\n\n\n \nstatic void block_until_chase_response(struct edgeport_port *edge_port)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tDEFINE_WAIT(wait);\n\t__u16 lastCredits;\n\tint timeout = 1*HZ;\n\tint loop = 10;\n\n\twhile (1) {\n\t\t \n\t\tlastCredits = edge_port->txCredits;\n\n\t\t \n\t\tif (!edge_port->chaseResponsePending) {\n\t\t\tdev_dbg(dev, \"%s - Got Chase Response\\n\", __func__);\n\n\t\t\t \n\t\t\tif (edge_port->txCredits == edge_port->maxTxCredits) {\n\t\t\t\tdev_dbg(dev, \"%s - Got all credits\\n\", __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tprepare_to_wait(&edge_port->wait_chase, &wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(timeout);\n\t\tfinish_wait(&edge_port->wait_chase, &wait);\n\n\t\tif (lastCredits == edge_port->txCredits) {\n\t\t\t \n\t\t\tloop--;\n\t\t\tif (loop == 0) {\n\t\t\t\tedge_port->chaseResponsePending = false;\n\t\t\t\tdev_dbg(dev, \"%s - Chase TIMEOUT\\n\", __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tdev_dbg(dev, \"%s - Last %d, Current %d\\n\", __func__,\n\t\t\t\t\tlastCredits, edge_port->txCredits);\n\t\t\tloop = 10;\n\t\t}\n\t}\n}\n\n\n \nstatic void block_until_tx_empty(struct edgeport_port *edge_port)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tDEFINE_WAIT(wait);\n\tstruct TxFifo *fifo = &edge_port->txfifo;\n\t__u32 lastCount;\n\tint timeout = HZ/10;\n\tint loop = 30;\n\n\twhile (1) {\n\t\t \n\t\tlastCount = fifo->count;\n\n\t\t \n\t\tif (lastCount == 0) {\n\t\t\tdev_dbg(dev, \"%s - TX Buffer Empty\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tprepare_to_wait(&edge_port->wait_chase, &wait,\n\t\t\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tschedule_timeout(timeout);\n\t\tfinish_wait(&edge_port->wait_chase, &wait);\n\n\t\tdev_dbg(dev, \"%s wait\\n\", __func__);\n\n\t\tif (lastCount == fifo->count) {\n\t\t\t \n\t\t\tloop--;\n\t\t\tif (loop == 0) {\n\t\t\t\tdev_dbg(dev, \"%s - TIMEOUT\\n\", __func__);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\t \n\t\t\tloop = 30;\n\t\t}\n\t}\n}\n\n\n \nstatic void edge_close(struct usb_serial_port *port)\n{\n\tstruct edgeport_serial *edge_serial;\n\tstruct edgeport_port *edge_port;\n\tint status;\n\n\tedge_serial = usb_get_serial_data(port->serial);\n\tedge_port = usb_get_serial_port_data(port);\n\tif (edge_serial == NULL || edge_port == NULL)\n\t\treturn;\n\n\t \n\tblock_until_tx_empty(edge_port);\n\n\tedge_port->closePending = true;\n\n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPChase) {\n\t\t \n\t\tedge_port->chaseResponsePending = true;\n\n\t\tdev_dbg(&port->dev, \"%s - Sending IOSP_CMD_CHASE_PORT\\n\", __func__);\n\t\tstatus = send_iosp_ext_cmd(edge_port, IOSP_CMD_CHASE_PORT, 0);\n\t\tif (status == 0)\n\t\t\t \n\t\t\tblock_until_chase_response(edge_port);\n\t\telse\n\t\t\tedge_port->chaseResponsePending = false;\n\t}\n\n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPClose) {\n\t        \n\t\tdev_dbg(&port->dev, \"%s - Sending IOSP_CMD_CLOSE_PORT\\n\", __func__);\n\t\tsend_iosp_ext_cmd(edge_port, IOSP_CMD_CLOSE_PORT, 0);\n\t}\n\n\t \n\tedge_port->closePending = false;\n\tedge_port->open = false;\n\tedge_port->openPending = false;\n\n\tusb_kill_urb(edge_port->write_urb);\n\n\tif (edge_port->write_urb) {\n\t\t \n\t\tkfree(edge_port->write_urb->transfer_buffer);\n\t\tusb_free_urb(edge_port->write_urb);\n\t\tedge_port->write_urb = NULL;\n\t}\n\tkfree(edge_port->txfifo.fifo);\n\tedge_port->txfifo.fifo = NULL;\n}\n\n \nstatic int edge_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *data, int count)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct TxFifo *fifo;\n\tint copySize;\n\tint bytesleft;\n\tint firsthalf;\n\tint secondhalf;\n\tunsigned long flags;\n\n\tif (edge_port == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tfifo = &edge_port->txfifo;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\t \n\tcopySize = min((unsigned int)count,\n\t\t\t\t(edge_port->txCredits - fifo->count));\n\n\tdev_dbg(&port->dev, \"%s of %d byte(s) Fifo room  %d -- will copy %d bytes\\n\",\n\t\t__func__, count, edge_port->txCredits - fifo->count, copySize);\n\n\t \n\tif (copySize == 0) {\n\t\tdev_dbg(&port->dev, \"%s - copySize = Zero\\n\", __func__);\n\t\tgoto finish_write;\n\t}\n\n\t \n\tbytesleft = fifo->size - fifo->head;\n\tfirsthalf = min(bytesleft, copySize);\n\tdev_dbg(&port->dev, \"%s - copy %d bytes of %d into fifo \\n\", __func__,\n\t\tfirsthalf, bytesleft);\n\n\t \n\tmemcpy(&fifo->fifo[fifo->head], data, firsthalf);\n\tusb_serial_debug_data(&port->dev, __func__, firsthalf, &fifo->fifo[fifo->head]);\n\n\t \n\tfifo->head  += firsthalf;\n\tfifo->count += firsthalf;\n\n\t \n\tif (fifo->head == fifo->size)\n\t\tfifo->head = 0;\n\n\tsecondhalf = copySize-firsthalf;\n\n\tif (secondhalf) {\n\t\tdev_dbg(&port->dev, \"%s - copy rest of data %d\\n\", __func__, secondhalf);\n\t\tmemcpy(&fifo->fifo[fifo->head], &data[firsthalf], secondhalf);\n\t\tusb_serial_debug_data(&port->dev, __func__, secondhalf, &fifo->fifo[fifo->head]);\n\t\t \n\t\tfifo->count += secondhalf;\n\t\tfifo->head  += secondhalf;\n\t\t \n\t}\n\nfinish_write:\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tsend_more_port_data((struct edgeport_serial *)\n\t\t\tusb_get_serial_data(port->serial), edge_port);\n\n\tdev_dbg(&port->dev, \"%s wrote %d byte(s) TxCredits %d, Fifo %d\\n\",\n\t\t__func__, copySize, edge_port->txCredits, fifo->count);\n\n\treturn copySize;\n}\n\n\n \nstatic void send_more_port_data(struct edgeport_serial *edge_serial,\n\t\t\t\t\tstruct edgeport_port *edge_port)\n{\n\tstruct TxFifo\t*fifo = &edge_port->txfifo;\n\tstruct device\t*dev = &edge_port->port->dev;\n\tstruct urb\t*urb;\n\tunsigned char\t*buffer;\n\tint\t\tstatus;\n\tint\t\tcount;\n\tint\t\tbytesleft;\n\tint\t\tfirsthalf;\n\tint\t\tsecondhalf;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\n\tif (edge_port->write_in_progress ||\n\t    !edge_port->open             ||\n\t    (fifo->count == 0)) {\n\t\tdev_dbg(dev, \"%s EXIT - fifo %d, PendingWrite = %d\\n\",\n\t\t\t__func__, fifo->count, edge_port->write_in_progress);\n\t\tgoto exit_send;\n\t}\n\n\t \n\tif (edge_port->txCredits < EDGE_FW_GET_TX_CREDITS_SEND_THRESHOLD(edge_port->maxTxCredits, EDGE_FW_BULK_MAX_PACKET_SIZE)) {\n\t\tdev_dbg(dev, \"%s Not enough credit - fifo %d TxCredit %d\\n\",\n\t\t\t__func__, fifo->count, edge_port->txCredits);\n\t\tgoto exit_send;\n\t}\n\n\t \n\tedge_port->write_in_progress = true;\n\n\t \n\turb = edge_port->write_urb;\n\n\t \n\tkfree(urb->transfer_buffer);\n\turb->transfer_buffer = NULL;\n\n\t \n\tcount = fifo->count;\n\tbuffer = kmalloc(count+2, GFP_ATOMIC);\n\tif (!buffer) {\n\t\tedge_port->write_in_progress = false;\n\t\tgoto exit_send;\n\t}\n\tbuffer[0] = IOSP_BUILD_DATA_HDR1(edge_port->port->port_number, count);\n\tbuffer[1] = IOSP_BUILD_DATA_HDR2(edge_port->port->port_number, count);\n\n\t \n\tbytesleft =  fifo->size - fifo->tail;\n\tfirsthalf = min(bytesleft, count);\n\tmemcpy(&buffer[2], &fifo->fifo[fifo->tail], firsthalf);\n\tfifo->tail  += firsthalf;\n\tfifo->count -= firsthalf;\n\tif (fifo->tail == fifo->size)\n\t\tfifo->tail = 0;\n\n\tsecondhalf = count-firsthalf;\n\tif (secondhalf) {\n\t\tmemcpy(&buffer[2+firsthalf], &fifo->fifo[fifo->tail],\n\t\t\t\t\t\t\t\tsecondhalf);\n\t\tfifo->tail  += secondhalf;\n\t\tfifo->count -= secondhalf;\n\t}\n\n\tif (count)\n\t\tusb_serial_debug_data(&edge_port->port->dev, __func__, count, &buffer[2]);\n\n\t \n\tusb_fill_bulk_urb(urb, edge_serial->serial->dev,\n\t\t\tusb_sndbulkpipe(edge_serial->serial->dev,\n\t\t\t\t\tedge_serial->bulk_out_endpoint),\n\t\t\tbuffer, count+2,\n\t\t\tedge_bulk_out_data_callback, edge_port);\n\n\t \n\tedge_port->txCredits -= count;\n\tedge_port->port->icount.tx += count;\n\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\t \n\t\tdev_err_console(edge_port->port,\n\t\t\t\"%s - usb_submit_urb(write bulk) failed, status = %d, data lost\\n\",\n\t\t\t\t__func__, status);\n\t\tedge_port->write_in_progress = false;\n\n\t\t \n\t\tedge_port->txCredits += count;\n\t\tedge_port->port->icount.tx -= count;\n\t}\n\tdev_dbg(dev, \"%s wrote %d byte(s) TxCredit %d, Fifo %d\\n\",\n\t\t__func__, count, edge_port->txCredits, fifo->count);\n\nexit_send:\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n}\n\n\n \nstatic unsigned int edge_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int room;\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\troom = edge_port->txCredits - edge_port->txfifo.count;\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n}\n\n\n \nstatic unsigned int edge_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int num_chars;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tnum_chars = edge_port->maxTxCredits - edge_port->txCredits +\n\t\t\t\t\t\tedge_port->txfifo.count;\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\tif (num_chars) {\n\t\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, num_chars);\n\t}\n\n\treturn num_chars;\n}\n\n\n \nstatic void edge_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\tif (!edge_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char stop_char = STOP_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &stop_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tedge_port->shadowMCR &= ~MCR_RTS;\n\t\tstatus = send_cmd_write_uart_register(edge_port, MCR,\n\t\t\t\t\t\t\tedge_port->shadowMCR);\n\t\tif (status != 0)\n\t\t\treturn;\n\t}\n}\n\n\n \nstatic void edge_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tint status;\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\tif (!edge_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tif (I_IXOFF(tty)) {\n\t\tunsigned char start_char = START_CHAR(tty);\n\t\tstatus = edge_write(tty, port, &start_char, 1);\n\t\tif (status <= 0)\n\t\t\treturn;\n\t}\n\t \n\tif (C_CRTSCTS(tty)) {\n\t\tedge_port->shadowMCR |= MCR_RTS;\n\t\tsend_cmd_write_uart_register(edge_port, MCR,\n\t\t\t\t\t\tedge_port->shadowMCR);\n\t}\n}\n\n\n \nstatic void edge_set_termios(struct tty_struct *tty,\n\t\t\t     struct usb_serial_port *port,\n\t\t\t     const struct ktermios *old_termios)\n{\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tif (edge_port == NULL)\n\t\treturn;\n\n\tif (!edge_port->open) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\t \n\tchange_port_settings(tty, edge_port, old_termios);\n}\n\n\n \nstatic int get_lsr_info(struct edgeport_port *edge_port,\n\t\t\t\t\t\tunsigned int __user *value)\n{\n\tunsigned int result = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&edge_port->ep_lock, flags);\n\tif (edge_port->maxTxCredits == edge_port->txCredits &&\n\t    edge_port->txfifo.count == 0) {\n\t\tdev_dbg(&edge_port->port->dev, \"%s -- Empty\\n\", __func__);\n\t\tresult = TIOCSER_TEMT;\n\t}\n\tspin_unlock_irqrestore(&edge_port->ep_lock, flags);\n\n\tif (copy_to_user(value, &result, sizeof(int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int edge_tiocmset(struct tty_struct *tty,\n\t\t\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int mcr;\n\n\tmcr = edge_port->shadowMCR;\n\tif (set & TIOCM_RTS)\n\t\tmcr |= MCR_RTS;\n\tif (set & TIOCM_DTR)\n\t\tmcr |= MCR_DTR;\n\tif (set & TIOCM_LOOP)\n\t\tmcr |= MCR_LOOPBACK;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr &= ~MCR_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tmcr &= ~MCR_DTR;\n\tif (clear & TIOCM_LOOP)\n\t\tmcr &= ~MCR_LOOPBACK;\n\n\tedge_port->shadowMCR = mcr;\n\n\tsend_cmd_write_uart_register(edge_port, MCR, edge_port->shadowMCR);\n\n\treturn 0;\n}\n\nstatic int edge_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tunsigned int result = 0;\n\tunsigned int msr;\n\tunsigned int mcr;\n\n\tmsr = edge_port->shadowMSR;\n\tmcr = edge_port->shadowMCR;\n\tresult = ((mcr & MCR_DTR)\t? TIOCM_DTR: 0)\t   \n\t\t  | ((mcr & MCR_RTS)\t? TIOCM_RTS: 0)    \n\t\t  | ((msr & EDGEPORT_MSR_CTS)\t? TIOCM_CTS: 0)    \n\t\t  | ((msr & EDGEPORT_MSR_CD)\t? TIOCM_CAR: 0)    \n\t\t  | ((msr & EDGEPORT_MSR_RI)\t? TIOCM_RI:  0)    \n\t\t  | ((msr & EDGEPORT_MSR_DSR)\t? TIOCM_DSR: 0);   \n\n\treturn result;\n}\n\n \nstatic int edge_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\n\tswitch (cmd) {\n\tcase TIOCSERGETLSR:\n\t\tdev_dbg(&port->dev, \"%s TIOCSERGETLSR\\n\", __func__);\n\t\treturn get_lsr_info(edge_port, (unsigned int __user *) arg);\n\t}\n\treturn -ENOIOCTLCMD;\n}\n\n\n \nstatic int edge_break(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct edgeport_port *edge_port = usb_get_serial_port_data(port);\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(port->serial);\n\tint status = 0;\n\n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPChase) {\n\t\t \n\t\tedge_port->chaseResponsePending = true;\n\n\t\tdev_dbg(&port->dev, \"%s - Sending IOSP_CMD_CHASE_PORT\\n\", __func__);\n\t\tstatus = send_iosp_ext_cmd(edge_port, IOSP_CMD_CHASE_PORT, 0);\n\t\tif (status == 0) {\n\t\t\t \n\t\t\tblock_until_chase_response(edge_port);\n\t\t} else {\n\t\t\tedge_port->chaseResponsePending = false;\n\t\t}\n\t}\n\n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPSetClrBreak) {\n\t\tif (break_state == -1) {\n\t\t\tdev_dbg(&port->dev, \"%s - Sending IOSP_CMD_SET_BREAK\\n\", __func__);\n\t\t\tstatus = send_iosp_ext_cmd(edge_port,\n\t\t\t\t\t\tIOSP_CMD_SET_BREAK, 0);\n\t\t} else {\n\t\t\tdev_dbg(&port->dev, \"%s - Sending IOSP_CMD_CLEAR_BREAK\\n\", __func__);\n\t\t\tstatus = send_iosp_ext_cmd(edge_port,\n\t\t\t\t\t\tIOSP_CMD_CLEAR_BREAK, 0);\n\t\t}\n\t\tif (status)\n\t\t\tdev_dbg(&port->dev, \"%s - error sending break set/clear command.\\n\",\n\t\t\t\t__func__);\n\t}\n\n\treturn status;\n}\n\n\n \nstatic void process_rcvd_data(struct edgeport_serial *edge_serial,\n\t\t\t\tunsigned char *buffer, __u16 bufferLength)\n{\n\tstruct usb_serial *serial = edge_serial->serial;\n\tstruct device *dev = &serial->dev->dev;\n\tstruct usb_serial_port *port;\n\tstruct edgeport_port *edge_port;\n\t__u16 lastBufferLength;\n\t__u16 rxLen;\n\n\tlastBufferLength = bufferLength + 1;\n\n\twhile (bufferLength > 0) {\n\t\t \n\t\tif (lastBufferLength == bufferLength) {\n\t\t\tdev_dbg(dev, \"%s - stuck in loop, exiting it.\\n\", __func__);\n\t\t\tbreak;\n\t\t}\n\t\tlastBufferLength = bufferLength;\n\n\t\tswitch (edge_serial->rxState) {\n\t\tcase EXPECT_HDR1:\n\t\t\tedge_serial->rxHeader1 = *buffer;\n\t\t\t++buffer;\n\t\t\t--bufferLength;\n\n\t\t\tif (bufferLength == 0) {\n\t\t\t\tedge_serial->rxState = EXPECT_HDR2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase EXPECT_HDR2:\n\t\t\tedge_serial->rxHeader2 = *buffer;\n\t\t\t++buffer;\n\t\t\t--bufferLength;\n\n\t\t\tdev_dbg(dev, \"%s - Hdr1=%02X Hdr2=%02X\\n\", __func__,\n\t\t\t\tedge_serial->rxHeader1, edge_serial->rxHeader2);\n\t\t\t \n\n\t\t\tif (IS_CMD_STAT_HDR(edge_serial->rxHeader1)) {\n\t\t\t\t \n\t\t\t\tedge_serial->rxPort =\n\t\t\t\t    IOSP_GET_HDR_PORT(edge_serial->rxHeader1);\n\t\t\t\tedge_serial->rxStatusCode =\n\t\t\t\t    IOSP_GET_STATUS_CODE(\n\t\t\t\t\t\tedge_serial->rxHeader1);\n\n\t\t\t\tif (!IOSP_STATUS_IS_2BYTE(\n\t\t\t\t\t\tedge_serial->rxStatusCode)) {\n\t\t\t\t\t \n\t\t\t\t\tedge_serial->rxStatusParam\n\t\t\t\t\t\t= edge_serial->rxHeader2;\n\t\t\t\t\tedge_serial->rxState = EXPECT_HDR3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tprocess_rcvd_status(edge_serial,\n\t\t\t\t\t\tedge_serial->rxHeader2, 0);\n\t\t\t\tedge_serial->rxState = EXPECT_HDR1;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tedge_serial->rxPort = IOSP_GET_HDR_PORT(edge_serial->rxHeader1);\n\t\t\tedge_serial->rxBytesRemaining = IOSP_GET_HDR_DATA_LEN(edge_serial->rxHeader1,\n\t\t\t\t\t\t\t\t\t      edge_serial->rxHeader2);\n\t\t\tdev_dbg(dev, \"%s - Data for Port %u Len %u\\n\", __func__,\n\t\t\t\tedge_serial->rxPort,\n\t\t\t\tedge_serial->rxBytesRemaining);\n\n\t\t\tif (bufferLength == 0) {\n\t\t\t\tedge_serial->rxState = EXPECT_DATA;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfallthrough;\n\t\tcase EXPECT_DATA:  \n\t\t\tif (bufferLength < edge_serial->rxBytesRemaining) {\n\t\t\t\trxLen = bufferLength;\n\t\t\t\t \n\t\t\t\tedge_serial->rxState = EXPECT_DATA;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\trxLen = edge_serial->rxBytesRemaining;\n\t\t\t\t \n\t\t\t\tedge_serial->rxState = EXPECT_HDR1;\n\t\t\t}\n\n\t\t\tbufferLength -= rxLen;\n\t\t\tedge_serial->rxBytesRemaining -= rxLen;\n\n\t\t\t \n\t\t\tif (rxLen && edge_serial->rxPort < serial->num_ports) {\n\t\t\t\tport = serial->port[edge_serial->rxPort];\n\t\t\t\tedge_port = usb_get_serial_port_data(port);\n\t\t\t\tif (edge_port && edge_port->open) {\n\t\t\t\t\tdev_dbg(dev, \"%s - Sending %d bytes to TTY for port %d\\n\",\n\t\t\t\t\t\t__func__, rxLen,\n\t\t\t\t\t\tedge_serial->rxPort);\n\t\t\t\t\tedge_tty_recv(edge_port->port, buffer,\n\t\t\t\t\t\t\trxLen);\n\t\t\t\t\tedge_port->port->icount.rx += rxLen;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuffer += rxLen;\n\t\t\tbreak;\n\n\t\tcase EXPECT_HDR3:\t \n\t\t\tedge_serial->rxHeader3 = *buffer;\n\t\t\t++buffer;\n\t\t\t--bufferLength;\n\n\t\t\t \n\t\t\tprocess_rcvd_status(edge_serial,\n\t\t\t\tedge_serial->rxStatusParam,\n\t\t\t\tedge_serial->rxHeader3);\n\t\t\tedge_serial->rxState = EXPECT_HDR1;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\n \nstatic void process_rcvd_status(struct edgeport_serial *edge_serial,\n\t\t\t\t\t\t__u8 byte2, __u8 byte3)\n{\n\tstruct usb_serial_port *port;\n\tstruct edgeport_port *edge_port;\n\tstruct tty_struct *tty;\n\tstruct device *dev;\n\t__u8 code = edge_serial->rxStatusCode;\n\n\t \n\tif (edge_serial->rxPort >= edge_serial->serial->num_ports)\n\t\treturn;\n\tport = edge_serial->serial->port[edge_serial->rxPort];\n\tedge_port = usb_get_serial_port_data(port);\n\tif (edge_port == NULL) {\n\t\tdev_err(&edge_serial->serial->dev->dev,\n\t\t\t\"%s - edge_port == NULL for port %d\\n\",\n\t\t\t\t\t__func__, edge_serial->rxPort);\n\t\treturn;\n\t}\n\tdev = &port->dev;\n\n\tif (code == IOSP_EXT_STATUS) {\n\t\tswitch (byte2) {\n\t\tcase IOSP_EXT_STATUS_CHASE_RSP:\n\t\t\t \n\t\t\tdev_dbg(dev, \"%s - Port %u EXT CHASE_RSP Data = %02x\\n\",\n\t\t\t\t__func__, edge_serial->rxPort, byte3);\n\t\t\t \n\t\t\tedge_port->chaseResponsePending = false;\n\t\t\twake_up(&edge_port->wait_chase);\n\t\t\treturn;\n\n\t\tcase IOSP_EXT_STATUS_RX_CHECK_RSP:\n\t\t\tdev_dbg(dev, \"%s ========== Port %u CHECK_RSP Sequence = %02x =============\\n\",\n\t\t\t\t__func__, edge_serial->rxPort, byte3);\n\t\t\t \n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (code == IOSP_STATUS_OPEN_RSP) {\n\t\tedge_port->txCredits = GET_TX_BUFFER_SIZE(byte3);\n\t\tedge_port->maxTxCredits = edge_port->txCredits;\n\t\tdev_dbg(dev, \"%s - Port %u Open Response Initial MSR = %02x TxBufferSize = %d\\n\",\n\t\t\t__func__, edge_serial->rxPort, byte2, edge_port->txCredits);\n\t\thandle_new_msr(edge_port, byte2);\n\n\t\t \n\t\ttty = tty_port_tty_get(&edge_port->port->port);\n\t\tif (tty) {\n\t\t\tchange_port_settings(tty,\n\t\t\t\tedge_port, &tty->termios);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\n\t\t \n\t\tedge_port->openPending = false;\n\t\tedge_port->open = true;\n\t\twake_up(&edge_port->wait_open);\n\t\treturn;\n\t}\n\n\t \n\tif (!edge_port->open || edge_port->closePending)\n\t\treturn;\n\n\tswitch (code) {\n\t \n\tcase IOSP_STATUS_LSR:\n\t\tdev_dbg(dev, \"%s - Port %u LSR Status = %02x\\n\",\n\t\t\t__func__, edge_serial->rxPort, byte2);\n\t\thandle_new_lsr(edge_port, false, byte2, 0);\n\t\tbreak;\n\n\tcase IOSP_STATUS_LSR_DATA:\n\t\tdev_dbg(dev, \"%s - Port %u LSR Status = %02x, Data = %02x\\n\",\n\t\t\t__func__, edge_serial->rxPort, byte2, byte3);\n\t\t \n\t\t \n\t\thandle_new_lsr(edge_port, true, byte2, byte3);\n\t\tbreak;\n\t \n\tcase IOSP_STATUS_MSR:\n\t\tdev_dbg(dev, \"%s - Port %u MSR Status = %02x\\n\",\n\t\t\t__func__, edge_serial->rxPort, byte2);\n\t\t \n\t\thandle_new_msr(edge_port, byte2);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(dev, \"%s - Unrecognized IOSP status code %u\\n\", __func__, code);\n\t\tbreak;\n\t}\n}\n\n\n \nstatic void edge_tty_recv(struct usb_serial_port *port, unsigned char *data,\n\t\tint length)\n{\n\tint cnt;\n\n\tcnt = tty_insert_flip_string(&port->port, data, length);\n\tif (cnt < length) {\n\t\tdev_err(&port->dev, \"%s - dropping data, %d bytes lost\\n\",\n\t\t\t\t__func__, length - cnt);\n\t}\n\tdata += cnt;\n\tlength -= cnt;\n\n\ttty_flip_buffer_push(&port->port);\n}\n\n\n \nstatic void handle_new_msr(struct edgeport_port *edge_port, __u8 newMsr)\n{\n\tstruct  async_icount *icount;\n\n\tif (newMsr & (EDGEPORT_MSR_DELTA_CTS | EDGEPORT_MSR_DELTA_DSR |\n\t\t\tEDGEPORT_MSR_DELTA_RI | EDGEPORT_MSR_DELTA_CD)) {\n\t\ticount = &edge_port->port->icount;\n\n\t\t \n\t\tif (newMsr & EDGEPORT_MSR_DELTA_CTS)\n\t\t\ticount->cts++;\n\t\tif (newMsr & EDGEPORT_MSR_DELTA_DSR)\n\t\t\ticount->dsr++;\n\t\tif (newMsr & EDGEPORT_MSR_DELTA_CD)\n\t\t\ticount->dcd++;\n\t\tif (newMsr & EDGEPORT_MSR_DELTA_RI)\n\t\t\ticount->rng++;\n\t\twake_up_interruptible(&edge_port->port->port.delta_msr_wait);\n\t}\n\n\t \n\tedge_port->shadowMSR = newMsr & 0xf0;\n}\n\n\n \nstatic void handle_new_lsr(struct edgeport_port *edge_port, __u8 lsrData,\n\t\t\t\t\t\t\t__u8 lsr, __u8 data)\n{\n\t__u8 newLsr = (__u8) (lsr & (__u8)\n\t\t(LSR_OVER_ERR | LSR_PAR_ERR | LSR_FRM_ERR | LSR_BREAK));\n\tstruct async_icount *icount;\n\n\tedge_port->shadowLSR = lsr;\n\n\tif (newLsr & LSR_BREAK) {\n\t\t \n\t\tnewLsr &= (__u8)(LSR_OVER_ERR | LSR_BREAK);\n\t}\n\n\t \n\tif (lsrData)\n\t\tedge_tty_recv(edge_port->port, &data, 1);\n\n\t \n\ticount = &edge_port->port->icount;\n\tif (newLsr & LSR_BREAK)\n\t\ticount->brk++;\n\tif (newLsr & LSR_OVER_ERR)\n\t\ticount->overrun++;\n\tif (newLsr & LSR_PAR_ERR)\n\t\ticount->parity++;\n\tif (newLsr & LSR_FRM_ERR)\n\t\ticount->frame++;\n}\n\n\n \nstatic int sram_write(struct usb_serial *serial, __u16 extAddr, __u16 addr,\n\t\t\t\t\t__u16 length, const __u8 *data)\n{\n\tint result;\n\t__u16 current_length;\n\tunsigned char *transfer_buffer;\n\n\tdev_dbg(&serial->dev->dev, \"%s - %x, %x, %d\\n\", __func__, extAddr, addr, length);\n\n\ttransfer_buffer =  kmalloc(64, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = 0;\n\twhile (length > 0) {\n\t\tif (length > 64)\n\t\t\tcurrent_length = 64;\n\t\telse\n\t\t\tcurrent_length = length;\n\n \n\t\tmemcpy(transfer_buffer, data, current_length);\n\t\tresult = usb_control_msg(serial->dev,\n\t\t\t\t\tusb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t\tUSB_REQUEST_ION_WRITE_RAM,\n\t\t\t\t\t0x40, addr, extAddr, transfer_buffer,\n\t\t\t\t\tcurrent_length, 300);\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tlength -= current_length;\n\t\taddr += current_length;\n\t\tdata += current_length;\n\t}\n\n\tkfree(transfer_buffer);\n\treturn result;\n}\n\n\n \nstatic int rom_write(struct usb_serial *serial, __u16 extAddr, __u16 addr,\n\t\t\t\t\t__u16 length, const __u8 *data)\n{\n\tint result;\n\t__u16 current_length;\n\tunsigned char *transfer_buffer;\n\n\ttransfer_buffer =  kmalloc(64, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = 0;\n\twhile (length > 0) {\n\t\tif (length > 64)\n\t\t\tcurrent_length = 64;\n\t\telse\n\t\t\tcurrent_length = length;\n\t\tmemcpy(transfer_buffer, data, current_length);\n\t\tresult = usb_control_msg(serial->dev,\n\t\t\t\t\tusb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t\tUSB_REQUEST_ION_WRITE_ROM, 0x40,\n\t\t\t\t\taddr, extAddr,\n\t\t\t\t\ttransfer_buffer, current_length, 300);\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tlength -= current_length;\n\t\taddr += current_length;\n\t\tdata += current_length;\n\t}\n\n\tkfree(transfer_buffer);\n\treturn result;\n}\n\n\n \nstatic int rom_read(struct usb_serial *serial, __u16 extAddr,\n\t\t\t\t\t__u16 addr, __u16 length, __u8 *data)\n{\n\tint result;\n\t__u16 current_length;\n\tunsigned char *transfer_buffer;\n\n\ttransfer_buffer =  kmalloc(64, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = 0;\n\twhile (length > 0) {\n\t\tif (length > 64)\n\t\t\tcurrent_length = 64;\n\t\telse\n\t\t\tcurrent_length = length;\n\t\tresult = usb_control_msg(serial->dev,\n\t\t\t\t\tusb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t\tUSB_REQUEST_ION_READ_ROM,\n\t\t\t\t\t0xC0, addr, extAddr, transfer_buffer,\n\t\t\t\t\tcurrent_length, 300);\n\t\tif (result < current_length) {\n\t\t\tif (result >= 0)\n\t\t\t\tresult = -EIO;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy(data, transfer_buffer, current_length);\n\t\tlength -= current_length;\n\t\taddr += current_length;\n\t\tdata += current_length;\n\n\t\tresult = 0;\n\t}\n\n\tkfree(transfer_buffer);\n\treturn result;\n}\n\n\n \nstatic int send_iosp_ext_cmd(struct edgeport_port *edge_port,\n\t\t\t\t\t\t__u8 command, __u8 param)\n{\n\tunsigned char   *buffer;\n\tunsigned char   *currentCommand;\n\tint             length = 0;\n\tint             status = 0;\n\n\tbuffer = kmalloc(10, GFP_ATOMIC);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tcurrentCommand = buffer;\n\n\tMAKE_CMD_EXT_CMD(&currentCommand, &length, edge_port->port->port_number,\n\t\t\t command, param);\n\n\tstatus = write_cmd_usb(edge_port, buffer, length);\n\tif (status) {\n\t\t \n\t\tkfree(buffer);\n\t}\n\n\treturn status;\n}\n\n\n \nstatic int write_cmd_usb(struct edgeport_port *edge_port,\n\t\t\t\t\tunsigned char *buffer, int length)\n{\n\tstruct edgeport_serial *edge_serial =\n\t\t\t\tusb_get_serial_data(edge_port->port->serial);\n\tstruct device *dev = &edge_port->port->dev;\n\tint status = 0;\n\tstruct urb *urb;\n\n\tusb_serial_debug_data(dev, __func__, length, buffer);\n\n\t \n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tatomic_inc(&CmdUrbs);\n\tdev_dbg(dev, \"%s - ALLOCATE URB %p (outstanding %d)\\n\",\n\t\t__func__, urb, atomic_read(&CmdUrbs));\n\n\tusb_fill_bulk_urb(urb, edge_serial->serial->dev,\n\t\t\tusb_sndbulkpipe(edge_serial->serial->dev,\n\t\t\t\t\tedge_serial->bulk_out_endpoint),\n\t\t\tbuffer, length, edge_bulk_out_cmd_callback, edge_port);\n\n\tedge_port->commandPending = true;\n\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\n\tif (status) {\n\t\t \n\t\tdev_err(dev, \"%s - usb_submit_urb(write command) failed, status = %d\\n\",\n\t\t\t__func__, status);\n\t\tusb_free_urb(urb);\n\t\tatomic_dec(&CmdUrbs);\n\t\treturn status;\n\t}\n\n#if 0\n\twait_event(&edge_port->wait_command, !edge_port->commandPending);\n\n\tif (edge_port->commandPending) {\n\t\t \n\t\tdev_dbg(dev, \"%s - command timed out\\n\", __func__);\n\t\tstatus = -EINVAL;\n\t}\n#endif\n\treturn status;\n}\n\n\n \nstatic int send_cmd_write_baud_rate(struct edgeport_port *edge_port,\n\t\t\t\t\t\t\t\tint baudRate)\n{\n\tstruct edgeport_serial *edge_serial =\n\t\t\t\tusb_get_serial_data(edge_port->port->serial);\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *cmdBuffer;\n\tunsigned char *currCmd;\n\tint cmdLen = 0;\n\tint divisor;\n\tint status;\n\tu32 number = edge_port->port->port_number;\n\n\tif (edge_serial->is_epic &&\n\t    !edge_serial->epic_descriptor.Supports.IOSPSetBaudRate) {\n\t\tdev_dbg(dev, \"SendCmdWriteBaudRate - NOT Setting baud rate for port, baud = %d\\n\",\n\t\t\tbaudRate);\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"%s - baud = %d\\n\", __func__, baudRate);\n\n\tstatus = calc_baud_rate_divisor(dev, baudRate, &divisor);\n\tif (status) {\n\t\tdev_err(dev, \"%s - bad baud rate\\n\", __func__);\n\t\treturn status;\n\t}\n\n\t \n\tcmdBuffer =  kmalloc(0x100, GFP_ATOMIC);\n\tif (!cmdBuffer)\n\t\treturn -ENOMEM;\n\n\tcurrCmd = cmdBuffer;\n\n\t \n\tMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, LCR, LCR_DL_ENABLE);\n\n\t \n\tMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, DLL, LOW8(divisor));\n\tMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, DLM, HIGH8(divisor));\n\n\t \n\tMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, number, LCR,\n\t\t\t\t\t\tedge_port->shadowLCR);\n\n\tstatus = write_cmd_usb(edge_port, cmdBuffer, cmdLen);\n\tif (status) {\n\t\t \n\t\tkfree(cmdBuffer);\n\t}\n\n\treturn status;\n}\n\n\n \nstatic int calc_baud_rate_divisor(struct device *dev, int baudrate, int *divisor)\n{\n\tint i;\n\t__u16 custom;\n\n\tfor (i = 0; i < ARRAY_SIZE(divisor_table); i++) {\n\t\tif (divisor_table[i].BaudRate == baudrate) {\n\t\t\t*divisor = divisor_table[i].Divisor;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\tif (baudrate > 50 && baudrate < 230400) {\n\t\t \n\t\tcustom = (__u16)((230400L + baudrate/2) / baudrate);\n\n\t\t*divisor = custom;\n\n\t\tdev_dbg(dev, \"%s - Baud %d = %d\\n\", __func__, baudrate, custom);\n\t\treturn 0;\n\t}\n\n\treturn -1;\n}\n\n\n \nstatic int send_cmd_write_uart_register(struct edgeport_port *edge_port,\n\t\t\t\t\t\t__u8 regNum, __u8 regValue)\n{\n\tstruct edgeport_serial *edge_serial =\n\t\t\t\tusb_get_serial_data(edge_port->port->serial);\n\tstruct device *dev = &edge_port->port->dev;\n\tunsigned char *cmdBuffer;\n\tunsigned char *currCmd;\n\tunsigned long cmdLen = 0;\n\tint status;\n\n\tdev_dbg(dev, \"%s - write to %s register 0x%02x\\n\",\n\t\t(regNum == MCR) ? \"MCR\" : \"LCR\", __func__, regValue);\n\n\tif (edge_serial->is_epic &&\n\t    !edge_serial->epic_descriptor.Supports.IOSPWriteMCR &&\n\t    regNum == MCR) {\n\t\tdev_dbg(dev, \"SendCmdWriteUartReg - Not writing to MCR Register\\n\");\n\t\treturn 0;\n\t}\n\n\tif (edge_serial->is_epic &&\n\t    !edge_serial->epic_descriptor.Supports.IOSPWriteLCR &&\n\t    regNum == LCR) {\n\t\tdev_dbg(dev, \"SendCmdWriteUartReg - Not writing to LCR Register\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tcmdBuffer = kmalloc(0x10, GFP_ATOMIC);\n\tif (cmdBuffer == NULL)\n\t\treturn -ENOMEM;\n\n\tcurrCmd = cmdBuffer;\n\n\t \n\tMAKE_CMD_WRITE_REG(&currCmd, &cmdLen, edge_port->port->port_number,\n\t\t\t   regNum, regValue);\n\n\tstatus = write_cmd_usb(edge_port, cmdBuffer, cmdLen);\n\tif (status) {\n\t\t \n\t\tkfree(cmdBuffer);\n\t}\n\n\treturn status;\n}\n\n\n \n\nstatic void change_port_settings(struct tty_struct *tty,\n\tstruct edgeport_port *edge_port, const struct ktermios *old_termios)\n{\n\tstruct device *dev = &edge_port->port->dev;\n\tstruct edgeport_serial *edge_serial =\n\t\t\tusb_get_serial_data(edge_port->port->serial);\n\tint baud;\n\tunsigned cflag;\n\t__u8 mask = 0xff;\n\t__u8 lData;\n\t__u8 lParity;\n\t__u8 lStop;\n\t__u8 rxFlow;\n\t__u8 txFlow;\n\tint status;\n\n\tif (!edge_port->open &&\n\t    !edge_port->openPending) {\n\t\tdev_dbg(dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\tcflag = tty->termios.c_cflag;\n\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tlData = LCR_BITS_5; mask = 0x1f;\n\t\tdev_dbg(dev, \"%s - data bits = 5\\n\", __func__);\n\t\tbreak;\n\tcase CS6:\n\t\tlData = LCR_BITS_6; mask = 0x3f;\n\t\tdev_dbg(dev, \"%s - data bits = 6\\n\", __func__);\n\t\tbreak;\n\tcase CS7:\n\t\tlData = LCR_BITS_7; mask = 0x7f;\n\t\tdev_dbg(dev, \"%s - data bits = 7\\n\", __func__);\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tlData = LCR_BITS_8;\n\t\tdev_dbg(dev, \"%s - data bits = 8\\n\", __func__);\n\t\tbreak;\n\t}\n\n\tlParity = LCR_PAR_NONE;\n\tif (cflag & PARENB) {\n\t\tif (cflag & CMSPAR) {\n\t\t\tif (cflag & PARODD) {\n\t\t\t\tlParity = LCR_PAR_MARK;\n\t\t\t\tdev_dbg(dev, \"%s - parity = mark\\n\", __func__);\n\t\t\t} else {\n\t\t\t\tlParity = LCR_PAR_SPACE;\n\t\t\t\tdev_dbg(dev, \"%s - parity = space\\n\", __func__);\n\t\t\t}\n\t\t} else if (cflag & PARODD) {\n\t\t\tlParity = LCR_PAR_ODD;\n\t\t\tdev_dbg(dev, \"%s - parity = odd\\n\", __func__);\n\t\t} else {\n\t\t\tlParity = LCR_PAR_EVEN;\n\t\t\tdev_dbg(dev, \"%s - parity = even\\n\", __func__);\n\t\t}\n\t} else {\n\t\tdev_dbg(dev, \"%s - parity = none\\n\", __func__);\n\t}\n\n\tif (cflag & CSTOPB) {\n\t\tlStop = LCR_STOP_2;\n\t\tdev_dbg(dev, \"%s - stop bits = 2\\n\", __func__);\n\t} else {\n\t\tlStop = LCR_STOP_1;\n\t\tdev_dbg(dev, \"%s - stop bits = 1\\n\", __func__);\n\t}\n\n\t \n\trxFlow = txFlow = 0x00;\n\tif (cflag & CRTSCTS) {\n\t\trxFlow |= IOSP_RX_FLOW_RTS;\n\t\ttxFlow |= IOSP_TX_FLOW_CTS;\n\t\tdev_dbg(dev, \"%s - RTS/CTS is enabled\\n\", __func__);\n\t} else {\n\t\tdev_dbg(dev, \"%s - RTS/CTS is disabled\\n\", __func__);\n\t}\n\n\t \n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tunsigned char stop_char  = STOP_CHAR(tty);\n\t\tunsigned char start_char = START_CHAR(tty);\n\n\t\tif (!edge_serial->is_epic ||\n\t\t    edge_serial->epic_descriptor.Supports.IOSPSetXChar) {\n\t\t\tsend_iosp_ext_cmd(edge_port,\n\t\t\t\t\tIOSP_CMD_SET_XON_CHAR, start_char);\n\t\t\tsend_iosp_ext_cmd(edge_port,\n\t\t\t\t\tIOSP_CMD_SET_XOFF_CHAR, stop_char);\n\t\t}\n\n\t\t \n\t\tif (I_IXOFF(tty)) {\n\t\t\trxFlow |= IOSP_RX_FLOW_XON_XOFF;\n\t\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t\t__func__, start_char, stop_char);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - INBOUND XON/XOFF is disabled\\n\", __func__);\n\t\t}\n\n\t\t \n\t\tif (I_IXON(tty)) {\n\t\t\ttxFlow |= IOSP_TX_FLOW_XON_XOFF;\n\t\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is enabled, XON = %2x, XOFF = %2x\\n\",\n\t\t\t\t__func__, start_char, stop_char);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - OUTBOUND XON/XOFF is disabled\\n\", __func__);\n\t\t}\n\t}\n\n\t \n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPSetRxFlow)\n\t\tsend_iosp_ext_cmd(edge_port, IOSP_CMD_SET_RX_FLOW, rxFlow);\n\tif (!edge_serial->is_epic ||\n\t    edge_serial->epic_descriptor.Supports.IOSPSetTxFlow)\n\t\tsend_iosp_ext_cmd(edge_port, IOSP_CMD_SET_TX_FLOW, txFlow);\n\n\n\tedge_port->shadowLCR &= ~(LCR_BITS_MASK | LCR_STOP_MASK | LCR_PAR_MASK);\n\tedge_port->shadowLCR |= (lData | lParity | lStop);\n\n\tedge_port->validDataMask = mask;\n\n\t \n\tstatus = send_cmd_write_uart_register(edge_port, LCR,\n\t\t\t\t\t\t\tedge_port->shadowLCR);\n\tif (status != 0)\n\t\treturn;\n\n\t \n\tedge_port->shadowMCR = MCR_MASTER_IE;\n\tif (cflag & CBAUD)\n\t\tedge_port->shadowMCR |= (MCR_DTR | MCR_RTS);\n\n\tstatus = send_cmd_write_uart_register(edge_port, MCR,\n\t\t\t\t\t\tedge_port->shadowMCR);\n\tif (status != 0)\n\t\treturn;\n\n\t \n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud) {\n\t\t \n\t\tbaud = 9600;\n\t}\n\n\tdev_dbg(dev, \"%s - baud rate = %d\\n\", __func__, baud);\n\tstatus = send_cmd_write_baud_rate(edge_port, baud);\n\tif (status == -1) {\n\t\t \n\t\tbaud = tty_termios_baud_rate(old_termios);\n\t\ttty_encode_baud_rate(tty, baud, baud);\n\t}\n}\n\n\n \nstatic void unicode_to_ascii(char *string, int buflen,\n\t\t\t\t\t__le16 *unicode, int unicode_size)\n{\n\tint i;\n\n\tif (buflen <= 0)\t \n\t\treturn;\n\t--buflen;\t\t \n\n\tfor (i = 0; i < unicode_size; i++) {\n\t\tif (i >= buflen)\n\t\t\tbreak;\n\t\tstring[i] = (char)(le16_to_cpu(unicode[i]));\n\t}\n\tstring[i] = 0x00;\n}\n\n\n \nstatic void get_manufacturing_desc(struct edgeport_serial *edge_serial)\n{\n\tstruct device *dev = &edge_serial->serial->dev->dev;\n\tint response;\n\n\tdev_dbg(dev, \"getting manufacturer descriptor\\n\");\n\n\tresponse = rom_read(edge_serial->serial,\n\t\t\t\t(EDGE_MANUF_DESC_ADDR & 0xffff0000) >> 16,\n\t\t\t\t(__u16)(EDGE_MANUF_DESC_ADDR & 0x0000ffff),\n\t\t\t\tEDGE_MANUF_DESC_LEN,\n\t\t\t\t(__u8 *)(&edge_serial->manuf_descriptor));\n\n\tif (response < 0) {\n\t\tdev_err(dev, \"error in getting manufacturer descriptor: %d\\n\",\n\t\t\t\tresponse);\n\t} else {\n\t\tchar string[30];\n\t\tdev_dbg(dev, \"**Manufacturer Descriptor\\n\");\n\t\tdev_dbg(dev, \"  RomSize:        %dK\\n\",\n\t\t\tedge_serial->manuf_descriptor.RomSize);\n\t\tdev_dbg(dev, \"  RamSize:        %dK\\n\",\n\t\t\tedge_serial->manuf_descriptor.RamSize);\n\t\tdev_dbg(dev, \"  CpuRev:         %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.CpuRev);\n\t\tdev_dbg(dev, \"  BoardRev:       %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.BoardRev);\n\t\tdev_dbg(dev, \"  NumPorts:       %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.NumPorts);\n\t\tdev_dbg(dev, \"  DescDate:       %d/%d/%d\\n\",\n\t\t\tedge_serial->manuf_descriptor.DescDate[0],\n\t\t\tedge_serial->manuf_descriptor.DescDate[1],\n\t\t\tedge_serial->manuf_descriptor.DescDate[2]+1900);\n\t\tunicode_to_ascii(string, sizeof(string),\n\t\t\tedge_serial->manuf_descriptor.SerialNumber,\n\t\t\tedge_serial->manuf_descriptor.SerNumLength/2);\n\t\tdev_dbg(dev, \"  SerialNumber: %s\\n\", string);\n\t\tunicode_to_ascii(string, sizeof(string),\n\t\t\tedge_serial->manuf_descriptor.AssemblyNumber,\n\t\t\tedge_serial->manuf_descriptor.AssemblyNumLength/2);\n\t\tdev_dbg(dev, \"  AssemblyNumber: %s\\n\", string);\n\t\tunicode_to_ascii(string, sizeof(string),\n\t\t    edge_serial->manuf_descriptor.OemAssyNumber,\n\t\t    edge_serial->manuf_descriptor.OemAssyNumLength/2);\n\t\tdev_dbg(dev, \"  OemAssyNumber:  %s\\n\", string);\n\t\tdev_dbg(dev, \"  UartType:       %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.UartType);\n\t\tdev_dbg(dev, \"  IonPid:         %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.IonPid);\n\t\tdev_dbg(dev, \"  IonConfig:      %d\\n\",\n\t\t\tedge_serial->manuf_descriptor.IonConfig);\n\t}\n}\n\n\n \nstatic void get_boot_desc(struct edgeport_serial *edge_serial)\n{\n\tstruct device *dev = &edge_serial->serial->dev->dev;\n\tint response;\n\n\tdev_dbg(dev, \"getting boot descriptor\\n\");\n\n\tresponse = rom_read(edge_serial->serial,\n\t\t\t\t(EDGE_BOOT_DESC_ADDR & 0xffff0000) >> 16,\n\t\t\t\t(__u16)(EDGE_BOOT_DESC_ADDR & 0x0000ffff),\n\t\t\t\tEDGE_BOOT_DESC_LEN,\n\t\t\t\t(__u8 *)(&edge_serial->boot_descriptor));\n\n\tif (response < 0) {\n\t\tdev_err(dev, \"error in getting boot descriptor: %d\\n\",\n\t\t\t\tresponse);\n\t} else {\n\t\tdev_dbg(dev, \"**Boot Descriptor:\\n\");\n\t\tdev_dbg(dev, \"  BootCodeLength: %d\\n\",\n\t\t\tle16_to_cpu(edge_serial->boot_descriptor.BootCodeLength));\n\t\tdev_dbg(dev, \"  MajorVersion:   %d\\n\",\n\t\t\tedge_serial->boot_descriptor.MajorVersion);\n\t\tdev_dbg(dev, \"  MinorVersion:   %d\\n\",\n\t\t\tedge_serial->boot_descriptor.MinorVersion);\n\t\tdev_dbg(dev, \"  BuildNumber:    %d\\n\",\n\t\t\tle16_to_cpu(edge_serial->boot_descriptor.BuildNumber));\n\t\tdev_dbg(dev, \"  Capabilities:   0x%x\\n\",\n\t\t      le16_to_cpu(edge_serial->boot_descriptor.Capabilities));\n\t\tdev_dbg(dev, \"  UConfig0:       %d\\n\",\n\t\t\tedge_serial->boot_descriptor.UConfig0);\n\t\tdev_dbg(dev, \"  UConfig1:       %d\\n\",\n\t\t\tedge_serial->boot_descriptor.UConfig1);\n\t}\n}\n\n\n \nstatic void load_application_firmware(struct edgeport_serial *edge_serial)\n{\n\tstruct device *dev = &edge_serial->serial->dev->dev;\n\tconst struct ihex_binrec *rec;\n\tconst struct firmware *fw;\n\tconst char *fw_name;\n\tconst char *fw_info;\n\tint response;\n\t__u32 Operaddr;\n\t__u16 build;\n\n\tswitch (edge_serial->product_info.iDownloadFile) {\n\t\tcase EDGE_DOWNLOAD_FILE_I930:\n\t\t\tfw_info = \"downloading firmware version (930)\";\n\t\t\tfw_name\t= \"edgeport/down.fw\";\n\t\t\tbreak;\n\n\t\tcase EDGE_DOWNLOAD_FILE_80251:\n\t\t\tfw_info = \"downloading firmware version (80251)\";\n\t\t\tfw_name\t= \"edgeport/down2.fw\";\n\t\t\tbreak;\n\n\t\tcase EDGE_DOWNLOAD_FILE_NONE:\n\t\t\tdev_dbg(dev, \"No download file specified, skipping download\\n\");\n\t\t\treturn;\n\n\t\tdefault:\n\t\t\treturn;\n\t}\n\n\tresponse = request_ihex_firmware(&fw, fw_name,\n\t\t\t\t    &edge_serial->serial->dev->dev);\n\tif (response) {\n\t\tdev_err(dev, \"Failed to load image \\\"%s\\\" err %d\\n\",\n\t\t       fw_name, response);\n\t\treturn;\n\t}\n\n\trec = (const struct ihex_binrec *)fw->data;\n\tbuild = (rec->data[2] << 8) | rec->data[3];\n\n\tdev_dbg(dev, \"%s %d.%d.%d\\n\", fw_info, rec->data[0], rec->data[1], build);\n\n\tedge_serial->product_info.FirmwareMajorVersion = rec->data[0];\n\tedge_serial->product_info.FirmwareMinorVersion = rec->data[1];\n\tedge_serial->product_info.FirmwareBuildNumber = cpu_to_le16(build);\n\n\tfor (rec = ihex_next_binrec(rec); rec;\n\t     rec = ihex_next_binrec(rec)) {\n\t\tOperaddr = be32_to_cpu(rec->addr);\n\t\tresponse = sram_write(edge_serial->serial,\n\t\t\t\t     Operaddr >> 16,\n\t\t\t\t     Operaddr & 0xFFFF,\n\t\t\t\t     be16_to_cpu(rec->len),\n\t\t\t\t     &rec->data[0]);\n\t\tif (response < 0) {\n\t\t\tdev_err(&edge_serial->serial->dev->dev,\n\t\t\t\t\"sram_write failed (%x, %x, %d)\\n\",\n\t\t\t\tOperaddr >> 16, Operaddr & 0xFFFF,\n\t\t\t\tbe16_to_cpu(rec->len));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdev_dbg(dev, \"sending exec_dl_code\\n\");\n\tresponse = usb_control_msg (edge_serial->serial->dev,\n\t\t\t\t    usb_sndctrlpipe(edge_serial->serial->dev, 0),\n\t\t\t\t    USB_REQUEST_ION_EXEC_DL_CODE,\n\t\t\t\t    0x40, 0x4000, 0x0001, NULL, 0, 3000);\n\n\trelease_firmware(fw);\n}\n\n\n \nstatic int edge_startup(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial;\n\tstruct usb_device *dev;\n\tstruct device *ddev = &serial->dev->dev;\n\tint i;\n\tint response;\n\tbool interrupt_in_found;\n\tbool bulk_in_found;\n\tbool bulk_out_found;\n\tstatic const __u32 descriptor[3] = {\tEDGE_COMPATIBILITY_MASK0,\n\t\t\t\t\t\tEDGE_COMPATIBILITY_MASK1,\n\t\t\t\t\t\tEDGE_COMPATIBILITY_MASK2 };\n\n\tdev = serial->dev;\n\n\t \n\tedge_serial = kzalloc(sizeof(struct edgeport_serial), GFP_KERNEL);\n\tif (!edge_serial)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&edge_serial->es_lock);\n\tedge_serial->serial = serial;\n\tusb_set_serial_data(serial, edge_serial);\n\n\t \n\ti = usb_string(dev, dev->descriptor.iManufacturer,\n\t    &edge_serial->name[0], MAX_NAME_LEN+1);\n\tif (i < 0)\n\t\ti = 0;\n\tedge_serial->name[i++] = ' ';\n\tusb_string(dev, dev->descriptor.iProduct,\n\t    &edge_serial->name[i], MAX_NAME_LEN+2 - i);\n\n\tdev_info(&serial->dev->dev, \"%s detected\\n\", edge_serial->name);\n\n\t \n\tif (get_epic_descriptor(edge_serial) < 0) {\n\t\t \n\t\tmemcpy(&edge_serial->epic_descriptor.Supports, descriptor,\n\t\t       sizeof(struct edge_compatibility_bits));\n\n\t\t \n\t\tget_manufacturing_desc(edge_serial);\n\n\t\t \n\t\tget_boot_desc(edge_serial);\n\n\t\tget_product_info(edge_serial);\n\t}\n\n\t \n\t \n\tif ((!edge_serial->is_epic) &&\n\t    (edge_serial->product_info.NumPorts != serial->num_ports)) {\n\t\tdev_warn(ddev,\n\t\t\t\"Device Reported %d serial ports vs. core thinking we have %d ports, email greg@kroah.com this information.\\n\",\n\t\t\t edge_serial->product_info.NumPorts,\n\t\t\t serial->num_ports);\n\t}\n\n\tdev_dbg(ddev, \"%s - time 1 %ld\\n\", __func__, jiffies);\n\n\t \n\tif (!edge_serial->is_epic) {\n\t\t \n\t\tload_application_firmware(edge_serial);\n\n\t\tdev_dbg(ddev, \"%s - time 2 %ld\\n\", __func__, jiffies);\n\n\t\t \n\t\tupdate_edgeport_E2PROM(edge_serial);\n\n\t\tdev_dbg(ddev, \"%s - time 3 %ld\\n\", __func__, jiffies);\n\n\t\t \n \n \n\t}\n\tdev_dbg(ddev, \"  FirmwareMajorVersion  %d.%d.%d\\n\",\n\t    edge_serial->product_info.FirmwareMajorVersion,\n\t    edge_serial->product_info.FirmwareMinorVersion,\n\t    le16_to_cpu(edge_serial->product_info.FirmwareBuildNumber));\n\n\t \n\n\tresponse = 0;\n\n\tif (edge_serial->is_epic) {\n\t\tstruct usb_host_interface *alt;\n\n\t\talt = serial->interface->cur_altsetting;\n\n\t\t \n\t\tinterrupt_in_found = bulk_in_found = bulk_out_found = false;\n\t\tfor (i = 0; i < alt->desc.bNumEndpoints; ++i) {\n\t\t\tstruct usb_endpoint_descriptor *endpoint;\n\t\t\tint buffer_size;\n\n\t\t\tendpoint = &alt->endpoint[i].desc;\n\t\t\tbuffer_size = usb_endpoint_maxp(endpoint);\n\t\t\tif (!interrupt_in_found &&\n\t\t\t    (usb_endpoint_is_int_in(endpoint))) {\n\t\t\t\t \n\t\t\t\tdev_dbg(ddev, \"found interrupt in\\n\");\n\n\t\t\t\t \n\t\t\t\tedge_serial->interrupt_read_urb =\n\t\t\t\t\t\tusb_alloc_urb(0, GFP_KERNEL);\n\t\t\t\tif (!edge_serial->interrupt_read_urb) {\n\t\t\t\t\tresponse = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tedge_serial->interrupt_in_buffer =\n\t\t\t\t\tkmalloc(buffer_size, GFP_KERNEL);\n\t\t\t\tif (!edge_serial->interrupt_in_buffer) {\n\t\t\t\t\tresponse = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedge_serial->interrupt_in_endpoint =\n\t\t\t\t\t\tendpoint->bEndpointAddress;\n\n\t\t\t\t \n\t\t\t\tusb_fill_int_urb(\n\t\t\t\t\tedge_serial->interrupt_read_urb,\n\t\t\t\t\tdev,\n\t\t\t\t\tusb_rcvintpipe(dev,\n\t\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t\t\tedge_serial->interrupt_in_buffer,\n\t\t\t\t\tbuffer_size,\n\t\t\t\t\tedge_interrupt_callback,\n\t\t\t\t\tedge_serial,\n\t\t\t\t\tendpoint->bInterval);\n\n\t\t\t\tinterrupt_in_found = true;\n\t\t\t}\n\n\t\t\tif (!bulk_in_found &&\n\t\t\t\t(usb_endpoint_is_bulk_in(endpoint))) {\n\t\t\t\t \n\t\t\t\tdev_dbg(ddev, \"found bulk in\\n\");\n\n\t\t\t\t \n\t\t\t\tedge_serial->read_urb =\n\t\t\t\t\t\tusb_alloc_urb(0, GFP_KERNEL);\n\t\t\t\tif (!edge_serial->read_urb) {\n\t\t\t\t\tresponse = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tedge_serial->bulk_in_buffer =\n\t\t\t\t\tkmalloc(buffer_size, GFP_KERNEL);\n\t\t\t\tif (!edge_serial->bulk_in_buffer) {\n\t\t\t\t\tresponse = -ENOMEM;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tedge_serial->bulk_in_endpoint =\n\t\t\t\t\t\tendpoint->bEndpointAddress;\n\n\t\t\t\t \n\t\t\t\tusb_fill_bulk_urb(edge_serial->read_urb, dev,\n\t\t\t\t\tusb_rcvbulkpipe(dev,\n\t\t\t\t\t\tendpoint->bEndpointAddress),\n\t\t\t\t\tedge_serial->bulk_in_buffer,\n\t\t\t\t\tusb_endpoint_maxp(endpoint),\n\t\t\t\t\tedge_bulk_in_callback,\n\t\t\t\t\tedge_serial);\n\t\t\t\tbulk_in_found = true;\n\t\t\t}\n\n\t\t\tif (!bulk_out_found &&\n\t\t\t    (usb_endpoint_is_bulk_out(endpoint))) {\n\t\t\t\t \n\t\t\t\tdev_dbg(ddev, \"found bulk out\\n\");\n\t\t\t\tedge_serial->bulk_out_endpoint =\n\t\t\t\t\t\tendpoint->bEndpointAddress;\n\t\t\t\tbulk_out_found = true;\n\t\t\t}\n\t\t}\n\n\t\tif (response || !interrupt_in_found || !bulk_in_found ||\n\t\t\t\t\t\t\t!bulk_out_found) {\n\t\t\tif (!response) {\n\t\t\t\tdev_err(ddev, \"expected endpoints not found\\n\");\n\t\t\t\tresponse = -ENODEV;\n\t\t\t}\n\n\t\t\tgoto error;\n\t\t}\n\n\t\t \n\t\tresponse = usb_submit_urb(edge_serial->interrupt_read_urb,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\t\tif (response) {\n\t\t\tdev_err(ddev, \"%s - Error %d submitting control urb\\n\",\n\t\t\t\t__func__, response);\n\n\t\t\tgoto error;\n\t\t}\n\t}\n\treturn response;\n\nerror:\n\tusb_free_urb(edge_serial->interrupt_read_urb);\n\tkfree(edge_serial->interrupt_in_buffer);\n\n\tusb_free_urb(edge_serial->read_urb);\n\tkfree(edge_serial->bulk_in_buffer);\n\n\tkfree(edge_serial);\n\n\treturn response;\n}\n\n\n \nstatic void edge_disconnect(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tif (edge_serial->is_epic) {\n\t\tusb_kill_urb(edge_serial->interrupt_read_urb);\n\t\tusb_kill_urb(edge_serial->read_urb);\n\t}\n}\n\n\n \nstatic void edge_release(struct usb_serial *serial)\n{\n\tstruct edgeport_serial *edge_serial = usb_get_serial_data(serial);\n\n\tif (edge_serial->is_epic) {\n\t\tusb_kill_urb(edge_serial->interrupt_read_urb);\n\t\tusb_free_urb(edge_serial->interrupt_read_urb);\n\t\tkfree(edge_serial->interrupt_in_buffer);\n\n\t\tusb_kill_urb(edge_serial->read_urb);\n\t\tusb_free_urb(edge_serial->read_urb);\n\t\tkfree(edge_serial->bulk_in_buffer);\n\t}\n\n\tkfree(edge_serial);\n}\n\nstatic int edge_port_probe(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\n\tedge_port = kzalloc(sizeof(*edge_port), GFP_KERNEL);\n\tif (!edge_port)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&edge_port->ep_lock);\n\tedge_port->port = port;\n\n\tusb_set_serial_port_data(port, edge_port);\n\n\treturn 0;\n}\n\nstatic void edge_port_remove(struct usb_serial_port *port)\n{\n\tstruct edgeport_port *edge_port;\n\n\tedge_port = usb_get_serial_port_data(port);\n\tkfree(edge_port);\n}\n\nstatic struct usb_serial_driver edgeport_2port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_2\",\n\t},\n\t.description\t\t= \"Edgeport 2 port adapter\",\n\t.id_table\t\t= edgeport_2port_id_table,\n\t.num_ports\t\t= 2,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.num_interrupt_in\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_data_callback,\n};\n\nstatic struct usb_serial_driver edgeport_4port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_4\",\n\t},\n\t.description\t\t= \"Edgeport 4 port adapter\",\n\t.id_table\t\t= edgeport_4port_id_table,\n\t.num_ports\t\t= 4,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.num_interrupt_in\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_data_callback,\n};\n\nstatic struct usb_serial_driver edgeport_8port_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"edgeport_8\",\n\t},\n\t.description\t\t= \"Edgeport 8 port adapter\",\n\t.id_table\t\t= edgeport_8port_id_table,\n\t.num_ports\t\t= 8,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.num_interrupt_in\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_data_callback,\n};\n\nstatic struct usb_serial_driver epic_device = {\n\t.driver = {\n\t\t.owner\t\t= THIS_MODULE,\n\t\t.name\t\t= \"epic\",\n\t},\n\t.description\t\t= \"EPiC device\",\n\t.id_table\t\t= Epic_port_id_table,\n\t.num_ports\t\t= 1,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.num_interrupt_in\t= 1,\n\t.open\t\t\t= edge_open,\n\t.close\t\t\t= edge_close,\n\t.throttle\t\t= edge_throttle,\n\t.unthrottle\t\t= edge_unthrottle,\n\t.attach\t\t\t= edge_startup,\n\t.disconnect\t\t= edge_disconnect,\n\t.release\t\t= edge_release,\n\t.port_probe\t\t= edge_port_probe,\n\t.port_remove\t\t= edge_port_remove,\n\t.ioctl\t\t\t= edge_ioctl,\n\t.set_termios\t\t= edge_set_termios,\n\t.tiocmget\t\t= edge_tiocmget,\n\t.tiocmset\t\t= edge_tiocmset,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.write\t\t\t= edge_write,\n\t.write_room\t\t= edge_write_room,\n\t.chars_in_buffer\t= edge_chars_in_buffer,\n\t.break_ctl\t\t= edge_break,\n\t.read_int_callback\t= edge_interrupt_callback,\n\t.read_bulk_callback\t= edge_bulk_in_callback,\n\t.write_bulk_callback\t= edge_bulk_out_data_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&edgeport_2port_device, &edgeport_4port_device,\n\t&edgeport_8port_device, &epic_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_FIRMWARE(\"edgeport/boot.fw\");\nMODULE_FIRMWARE(\"edgeport/boot2.fw\");\nMODULE_FIRMWARE(\"edgeport/down.fw\");\nMODULE_FIRMWARE(\"edgeport/down2.fw\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}