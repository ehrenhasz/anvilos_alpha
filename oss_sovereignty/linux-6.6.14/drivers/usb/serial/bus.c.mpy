{
  "module_name": "bus.c",
  "hash_id": "7576a2b8b5ca176b242dddd62694193d4acddb53cc593d42d67f1faab41cfa99",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/bus.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstatic int usb_serial_device_match(struct device *dev,\n\t\t\t\t\t\tstruct device_driver *drv)\n{\n\tconst struct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct usb_serial_driver *driver = to_usb_serial_driver(drv);\n\n\t \n\tif (driver == port->serial->type)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int usb_serial_device_probe(struct device *dev)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct usb_serial_driver *driver;\n\tstruct device *tty_dev;\n\tint retval = 0;\n\tint minor;\n\n\t \n\tretval = usb_autopm_get_interface(port->serial->interface);\n\tif (retval)\n\t\treturn retval;\n\n\tdriver = port->serial->type;\n\tif (driver->port_probe) {\n\t\tretval = driver->port_probe(port);\n\t\tif (retval)\n\t\t\tgoto err_autopm_put;\n\t}\n\n\tminor = port->minor;\n\ttty_dev = tty_port_register_device(&port->port, usb_serial_tty_driver,\n\t\t\t\t\t   minor, dev);\n\tif (IS_ERR(tty_dev)) {\n\t\tretval = PTR_ERR(tty_dev);\n\t\tgoto err_port_remove;\n\t}\n\n\tusb_autopm_put_interface(port->serial->interface);\n\n\tdev_info(&port->serial->dev->dev,\n\t\t \"%s converter now attached to ttyUSB%d\\n\",\n\t\t driver->description, minor);\n\n\treturn 0;\n\nerr_port_remove:\n\tif (driver->port_remove)\n\t\tdriver->port_remove(port);\nerr_autopm_put:\n\tusb_autopm_put_interface(port->serial->interface);\n\n\treturn retval;\n}\n\nstatic void usb_serial_device_remove(struct device *dev)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct usb_serial_driver *driver;\n\tint minor;\n\tint autopm_err;\n\n\t \n\tautopm_err = usb_autopm_get_interface(port->serial->interface);\n\n\tminor = port->minor;\n\ttty_unregister_device(usb_serial_tty_driver, minor);\n\n\tdriver = port->serial->type;\n\tif (driver->port_remove)\n\t\tdriver->port_remove(port);\n\n\tdev_info(dev, \"%s converter now disconnected from ttyUSB%d\\n\",\n\t\t driver->description, minor);\n\n\tif (!autopm_err)\n\t\tusb_autopm_put_interface(port->serial->interface);\n}\n\nstatic ssize_t new_id_store(struct device_driver *driver,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct usb_serial_driver *usb_drv = to_usb_serial_driver(driver);\n\tssize_t retval = usb_store_new_id(&usb_drv->dynids, usb_drv->id_table,\n\t\t\t\t\t driver, buf, count);\n\n\tif (retval >= 0 && usb_drv->usb_driver != NULL)\n\t\tretval = usb_store_new_id(&usb_drv->usb_driver->dynids,\n\t\t\t\t\t  usb_drv->usb_driver->id_table,\n\t\t\t\t\t  &usb_drv->usb_driver->drvwrap.driver,\n\t\t\t\t\t  buf, count);\n\treturn retval;\n}\n\nstatic ssize_t new_id_show(struct device_driver *driver, char *buf)\n{\n\tstruct usb_serial_driver *usb_drv = to_usb_serial_driver(driver);\n\n\treturn usb_show_dynids(&usb_drv->dynids, buf);\n}\nstatic DRIVER_ATTR_RW(new_id);\n\nstatic struct attribute *usb_serial_drv_attrs[] = {\n\t&driver_attr_new_id.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(usb_serial_drv);\n\nstatic void free_dynids(struct usb_serial_driver *drv)\n{\n\tstruct usb_dynid *dynid, *n;\n\n\tspin_lock(&drv->dynids.lock);\n\tlist_for_each_entry_safe(dynid, n, &drv->dynids.list, node) {\n\t\tlist_del(&dynid->node);\n\t\tkfree(dynid);\n\t}\n\tspin_unlock(&drv->dynids.lock);\n}\n\nconst struct bus_type usb_serial_bus_type = {\n\t.name =\t\t\"usb-serial\",\n\t.match =\tusb_serial_device_match,\n\t.probe =\tusb_serial_device_probe,\n\t.remove =\tusb_serial_device_remove,\n\t.drv_groups = \tusb_serial_drv_groups,\n};\n\nint usb_serial_bus_register(struct usb_serial_driver *driver)\n{\n\tint retval;\n\n\tdriver->driver.bus = &usb_serial_bus_type;\n\tspin_lock_init(&driver->dynids.lock);\n\tINIT_LIST_HEAD(&driver->dynids.list);\n\n\tretval = driver_register(&driver->driver);\n\n\treturn retval;\n}\n\nvoid usb_serial_bus_deregister(struct usb_serial_driver *driver)\n{\n\tfree_dynids(driver);\n\tdriver_unregister(&driver->driver);\n}\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}