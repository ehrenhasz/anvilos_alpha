{
  "module_name": "mxuport.c",
  "hash_id": "e206ce5b32e568b733831b064b70d7e1e61b6a8b99af8ed4931b177799fd2535",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/mxuport.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/firmware.h>\n#include <linux/jiffies.h>\n#include <linux/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <asm/unaligned.h>\n\n \n#define MX_USBSERIAL_VID\t0x110A\n#define MX_UPORT1250_PID\t0x1250\n#define MX_UPORT1251_PID\t0x1251\n#define MX_UPORT1410_PID\t0x1410\n#define MX_UPORT1450_PID\t0x1450\n#define MX_UPORT1451_PID\t0x1451\n#define MX_UPORT1618_PID\t0x1618\n#define MX_UPORT1658_PID\t0x1658\n#define MX_UPORT1613_PID\t0x1613\n#define MX_UPORT1653_PID\t0x1653\n\n \n#define HEADER_SIZE\t\t4\n#define EVENT_LENGTH\t\t8\n#define DOWN_BLOCK_SIZE\t\t64\n\n \n#define VER_ADDR_1\t\t0x20\n#define VER_ADDR_2\t\t0x24\n#define VER_ADDR_3\t\t0x28\n\n \n#define RQ_VENDOR_NONE\t\t\t0x00\n#define RQ_VENDOR_SET_BAUD\t\t0x01  \n#define RQ_VENDOR_SET_LINE\t\t0x02  \n#define RQ_VENDOR_SET_CHARS\t\t0x03  \n#define RQ_VENDOR_SET_RTS\t\t0x04  \n#define RQ_VENDOR_SET_DTR\t\t0x05  \n#define RQ_VENDOR_SET_XONXOFF\t\t0x06  \n#define RQ_VENDOR_SET_RX_HOST_EN\t0x07  \n#define RQ_VENDOR_SET_OPEN\t\t0x08  \n#define RQ_VENDOR_PURGE\t\t\t0x09  \n#define RQ_VENDOR_SET_MCR\t\t0x0A  \n#define RQ_VENDOR_SET_BREAK\t\t0x0B  \n\n#define RQ_VENDOR_START_FW_DOWN\t\t0x0C  \n#define RQ_VENDOR_STOP_FW_DOWN\t\t0x0D  \n#define RQ_VENDOR_QUERY_FW_READY\t0x0E  \n\n#define RQ_VENDOR_SET_FIFO_DISABLE\t0x0F  \n#define RQ_VENDOR_SET_INTERFACE\t\t0x10  \n#define RQ_VENDOR_SET_HIGH_PERFOR\t0x11  \n\n#define RQ_VENDOR_ERASE_BLOCK\t\t0x12  \n#define RQ_VENDOR_WRITE_PAGE\t\t0x13  \n#define RQ_VENDOR_PREPARE_WRITE\t\t0x14  \n#define RQ_VENDOR_CONFIRM_WRITE\t\t0x15  \n#define RQ_VENDOR_LOCATE\t\t0x16  \n\n#define RQ_VENDOR_START_ROM_DOWN\t0x17  \n#define RQ_VENDOR_ROM_DATA\t\t0x18  \n#define RQ_VENDOR_STOP_ROM_DOWN\t\t0x19  \n#define RQ_VENDOR_FW_DATA\t\t0x20  \n\n#define RQ_VENDOR_RESET_DEVICE\t\t0x23  \n#define RQ_VENDOR_QUERY_FW_CONFIG\t0x24\n\n#define RQ_VENDOR_GET_VERSION\t\t0x81  \n#define RQ_VENDOR_GET_PAGE\t\t0x82  \n#define RQ_VENDOR_GET_ROM_PROC\t\t0x83  \n\n#define RQ_VENDOR_GET_INQUEUE\t\t0x84  \n#define RQ_VENDOR_GET_OUTQUEUE\t\t0x85  \n\n#define RQ_VENDOR_GET_MSR\t\t0x86  \n\n \n#define UPORT_EVENT_NONE\t\t0  \n#define UPORT_EVENT_TXBUF_THRESHOLD\t1  \n#define UPORT_EVENT_SEND_NEXT\t\t2  \n#define UPORT_EVENT_MSR\t\t\t3  \n#define UPORT_EVENT_LSR\t\t\t4  \n#define UPORT_EVENT_MCR\t\t\t5  \n\n \n#define SERIAL_EV_CTS\t\t\t0x0008\t \n#define SERIAL_EV_DSR\t\t\t0x0010\t \n#define SERIAL_EV_RLSD\t\t\t0x0020\t \n\n \n#define SERIAL_EV_XOFF\t\t\t0x40\t \n\n \n#define MX_WORDLENGTH_5\t\t\t5\n#define MX_WORDLENGTH_6\t\t\t6\n#define MX_WORDLENGTH_7\t\t\t7\n#define MX_WORDLENGTH_8\t\t\t8\n\n#define MX_PARITY_NONE\t\t\t0\n#define MX_PARITY_ODD\t\t\t1\n#define MX_PARITY_EVEN\t\t\t2\n#define MX_PARITY_MARK\t\t\t3\n#define MX_PARITY_SPACE\t\t\t4\n\n#define MX_STOP_BITS_1\t\t\t0\n#define MX_STOP_BITS_1_5\t\t1\n#define MX_STOP_BITS_2\t\t\t2\n\n#define MX_RTS_DISABLE\t\t\t0x0\n#define MX_RTS_ENABLE\t\t\t0x1\n#define MX_RTS_HW\t\t\t0x2\n#define MX_RTS_NO_CHANGE\t\t0x3  \n\n#define MX_INT_RS232\t\t\t0\n#define MX_INT_2W_RS485\t\t\t1\n#define MX_INT_RS422\t\t\t2\n#define MX_INT_4W_RS485\t\t\t3\n\n \n#define MX_WAIT_FOR_CTS\t\t\t0x0001\n#define MX_WAIT_FOR_DSR\t\t\t0x0002\n#define MX_WAIT_FOR_DCD\t\t\t0x0004\n#define MX_WAIT_FOR_XON\t\t\t0x0008\n#define MX_WAIT_FOR_START_TX\t\t0x0010\n#define MX_WAIT_FOR_UNTHROTTLE\t\t0x0020\n#define MX_WAIT_FOR_LOW_WATER\t\t0x0040\n#define MX_WAIT_FOR_SEND_NEXT\t\t0x0080\n\n#define MX_UPORT_2_PORT\t\t\tBIT(0)\n#define MX_UPORT_4_PORT\t\t\tBIT(1)\n#define MX_UPORT_8_PORT\t\t\tBIT(2)\n#define MX_UPORT_16_PORT\t\tBIT(3)\n\n \nstruct mxuport_port {\n\tu8 mcr_state;\t\t \n\tu8 msr_state;\t\t \n\tstruct mutex mutex;\t \n\tspinlock_t spinlock;\t \n};\n\n \nstatic const struct usb_device_id mxuport_idtable[] = {\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1250_PID),\n\t  .driver_info = MX_UPORT_2_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1251_PID),\n\t  .driver_info = MX_UPORT_2_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1410_PID),\n\t  .driver_info = MX_UPORT_4_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1450_PID),\n\t  .driver_info = MX_UPORT_4_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1451_PID),\n\t  .driver_info = MX_UPORT_4_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1618_PID),\n\t  .driver_info = MX_UPORT_8_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1658_PID),\n\t  .driver_info = MX_UPORT_8_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1613_PID),\n\t  .driver_info = MX_UPORT_16_PORT },\n\t{ USB_DEVICE(MX_USBSERIAL_VID, MX_UPORT1653_PID),\n\t  .driver_info = MX_UPORT_16_PORT },\n\t{}\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, mxuport_idtable);\n\n \nstatic int mxuport_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\tvoid *dest, size_t size)\n{\n\tu8 *buf = dest;\n\tint count;\n\n\tcount = kfifo_out_locked(&port->write_fifo, buf + HEADER_SIZE,\n\t\t\t\t size - HEADER_SIZE,\n\t\t\t\t &port->lock);\n\n\tput_unaligned_be16(port->port_number, buf);\n\tput_unaligned_be16(count, buf + 2);\n\n\tdev_dbg(&port->dev, \"%s - size %zd count %d\\n\", __func__,\n\t\tsize, count);\n\n\treturn count + HEADER_SIZE;\n}\n\n \nstatic int mxuport_recv_ctrl_urb(struct usb_serial *serial,\n\t\t\t\t u8 request, u16 value, u16 index,\n\t\t\t\t u8 *data, size_t size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(serial->dev,\n\t\t\t\t usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t request,\n\t\t\t\t (USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t\t  USB_RECIP_DEVICE), value, index,\n\t\t\t\t data, size,\n\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\tif (status < 0) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"%s - usb_control_msg failed (%d)\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\tif (status != size) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"%s - short read (%d / %zd)\\n\",\n\t\t\t__func__, status, size);\n\t\treturn -EIO;\n\t}\n\n\treturn status;\n}\n\n \nstatic int mxuport_send_ctrl_data_urb(struct usb_serial *serial,\n\t\t\t\t      u8 request,\n\t\t\t\t      u16 value, u16 index,\n\t\t\t\t      u8 *data, size_t size)\n{\n\tint status;\n\n\tstatus = usb_control_msg(serial->dev,\n\t\t\t\t usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t request,\n\t\t\t\t (USB_DIR_OUT | USB_TYPE_VENDOR |\n\t\t\t\t  USB_RECIP_DEVICE), value, index,\n\t\t\t\t data, size,\n\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\tif (status < 0) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"%s - usb_control_msg failed (%d)\\n\",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\n \nstatic int mxuport_send_ctrl_urb(struct usb_serial *serial,\n\t\t\t\t u8 request, u16 value, u16 index)\n{\n\treturn mxuport_send_ctrl_data_urb(serial, request, value, index,\n\t\t\t\t\t  NULL, 0);\n}\n\n \nstatic void mxuport_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\n\t\t\t      0, port->port_number);\n}\n\n \nstatic void mxuport_unthrottle(struct tty_struct *tty)\n{\n\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\n\tdev_dbg(&port->dev, \"%s\\n\", __func__);\n\n\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\n\t\t\t      1, port->port_number);\n}\n\n \nstatic void mxuport_process_read_urb_data(struct usb_serial_port *port,\n\t\t\t\t\t  char *data, int size)\n{\n\tint i;\n\n\tif (port->sysrq) {\n\t\tfor (i = 0; i < size; i++, data++) {\n\t\t\tif (!usb_serial_handle_sysrq_char(port, *data))\n\t\t\t\ttty_insert_flip_char(&port->port, *data,\n\t\t\t\t\t\t     TTY_NORMAL);\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string(&port->port, data, size);\n\t}\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void mxuport_msr_event(struct usb_serial_port *port, u8 buf[4])\n{\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tu8 rcv_msr_hold = buf[2] & 0xF0;\n\tu16 rcv_msr_event = get_unaligned_be16(buf);\n\tunsigned long flags;\n\n\tif (rcv_msr_event == 0)\n\t\treturn;\n\n\t \n\tspin_lock_irqsave(&mxport->spinlock, flags);\n\n\tdev_dbg(&port->dev, \"%s - current MSR status = 0x%x\\n\",\n\t\t__func__, mxport->msr_state);\n\n\tif (rcv_msr_hold & UART_MSR_CTS) {\n\t\tmxport->msr_state |= UART_MSR_CTS;\n\t\tdev_dbg(&port->dev, \"%s - CTS high\\n\", __func__);\n\t} else {\n\t\tmxport->msr_state &= ~UART_MSR_CTS;\n\t\tdev_dbg(&port->dev, \"%s - CTS low\\n\", __func__);\n\t}\n\n\tif (rcv_msr_hold & UART_MSR_DSR) {\n\t\tmxport->msr_state |= UART_MSR_DSR;\n\t\tdev_dbg(&port->dev, \"%s - DSR high\\n\", __func__);\n\t} else {\n\t\tmxport->msr_state &= ~UART_MSR_DSR;\n\t\tdev_dbg(&port->dev, \"%s - DSR low\\n\", __func__);\n\t}\n\n\tif (rcv_msr_hold & UART_MSR_DCD) {\n\t\tmxport->msr_state |= UART_MSR_DCD;\n\t\tdev_dbg(&port->dev, \"%s - DCD high\\n\", __func__);\n\t} else {\n\t\tmxport->msr_state &= ~UART_MSR_DCD;\n\t\tdev_dbg(&port->dev, \"%s - DCD low\\n\", __func__);\n\t}\n\tspin_unlock_irqrestore(&mxport->spinlock, flags);\n\n\tif (rcv_msr_event &\n\t    (SERIAL_EV_CTS | SERIAL_EV_DSR | SERIAL_EV_RLSD)) {\n\n\t\tif (rcv_msr_event & SERIAL_EV_CTS) {\n\t\t\tport->icount.cts++;\n\t\t\tdev_dbg(&port->dev, \"%s - CTS change\\n\", __func__);\n\t\t}\n\n\t\tif (rcv_msr_event & SERIAL_EV_DSR) {\n\t\t\tport->icount.dsr++;\n\t\t\tdev_dbg(&port->dev, \"%s - DSR change\\n\", __func__);\n\t\t}\n\n\t\tif (rcv_msr_event & SERIAL_EV_RLSD) {\n\t\t\tport->icount.dcd++;\n\t\t\tdev_dbg(&port->dev, \"%s - DCD change\\n\", __func__);\n\t\t}\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t}\n}\n\nstatic void mxuport_lsr_event(struct usb_serial_port *port, u8 buf[4])\n{\n\tu8 lsr_event = buf[2];\n\n\tif (lsr_event & UART_LSR_BI) {\n\t\tport->icount.brk++;\n\t\tdev_dbg(&port->dev, \"%s - break error\\n\", __func__);\n\t}\n\n\tif (lsr_event & UART_LSR_FE) {\n\t\tport->icount.frame++;\n\t\tdev_dbg(&port->dev, \"%s - frame error\\n\", __func__);\n\t}\n\n\tif (lsr_event & UART_LSR_PE) {\n\t\tport->icount.parity++;\n\t\tdev_dbg(&port->dev, \"%s - parity error\\n\", __func__);\n\t}\n\n\tif (lsr_event & UART_LSR_OE) {\n\t\tport->icount.overrun++;\n\t\tdev_dbg(&port->dev, \"%s - overrun error\\n\", __func__);\n\t}\n}\n\n \nstatic void mxuport_process_read_urb_event(struct usb_serial_port *port,\n\t\t\t\t\t   u8 buf[4], u32 event)\n{\n\tdev_dbg(&port->dev, \"%s - receive event : %04x\\n\", __func__, event);\n\n\tswitch (event) {\n\tcase UPORT_EVENT_SEND_NEXT:\n\t\t \n\t\tbreak;\n\tcase UPORT_EVENT_MSR:\n\t\tmxuport_msr_event(port, buf);\n\t\tbreak;\n\tcase UPORT_EVENT_LSR:\n\t\tmxuport_lsr_event(port, buf);\n\t\tbreak;\n\tcase UPORT_EVENT_MCR:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"Unexpected event\\n\");\n\t\tbreak;\n\t}\n}\n\n \nstatic void mxuport_process_read_urb_demux_data(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct usb_serial *serial = port->serial;\n\tu8 *data = urb->transfer_buffer;\n\tu8 *end = data + urb->actual_length;\n\tstruct usb_serial_port *demux_port;\n\tu8 *ch;\n\tu16 rcv_port;\n\tu16 rcv_len;\n\n\twhile (data < end) {\n\t\tif (data + HEADER_SIZE > end) {\n\t\t\tdev_warn(&port->dev, \"%s - message with short header\\n\",\n\t\t\t\t __func__);\n\t\t\treturn;\n\t\t}\n\n\t\trcv_port = get_unaligned_be16(data);\n\t\tif (rcv_port >= serial->num_ports) {\n\t\t\tdev_warn(&port->dev, \"%s - message for invalid port\\n\",\n\t\t\t\t __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tdemux_port = serial->port[rcv_port];\n\t\trcv_len = get_unaligned_be16(data + 2);\n\t\tif (!rcv_len || data + HEADER_SIZE + rcv_len > end) {\n\t\t\tdev_warn(&port->dev, \"%s - short data\\n\", __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tif (tty_port_initialized(&demux_port->port)) {\n\t\t\tch = data + HEADER_SIZE;\n\t\t\tmxuport_process_read_urb_data(demux_port, ch, rcv_len);\n\t\t} else {\n\t\t\tdev_dbg(&demux_port->dev, \"%s - data for closed port\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t\tdata += HEADER_SIZE + rcv_len;\n\t}\n}\n\n \nstatic void mxuport_process_read_urb_demux_event(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct usb_serial *serial = port->serial;\n\tu8 *data = urb->transfer_buffer;\n\tu8 *end = data + urb->actual_length;\n\tstruct usb_serial_port *demux_port;\n\tu8 *ch;\n\tu16 rcv_port;\n\tu16 rcv_event;\n\n\twhile (data < end) {\n\t\tif (data + EVENT_LENGTH > end) {\n\t\t\tdev_warn(&port->dev, \"%s - message with short event\\n\",\n\t\t\t\t __func__);\n\t\t\treturn;\n\t\t}\n\n\t\trcv_port = get_unaligned_be16(data);\n\t\tif (rcv_port >= serial->num_ports) {\n\t\t\tdev_warn(&port->dev, \"%s - message for invalid port\\n\",\n\t\t\t\t __func__);\n\t\t\treturn;\n\t\t}\n\n\t\tdemux_port = serial->port[rcv_port];\n\t\tif (tty_port_initialized(&demux_port->port)) {\n\t\t\tch = data + HEADER_SIZE;\n\t\t\trcv_event = get_unaligned_be16(data + 2);\n\t\t\tmxuport_process_read_urb_event(demux_port, ch,\n\t\t\t\t\t\t       rcv_event);\n\t\t} else {\n\t\t\tdev_dbg(&demux_port->dev,\n\t\t\t\t\"%s - event for closed port\\n\", __func__);\n\t\t}\n\t\tdata += EVENT_LENGTH;\n\t}\n}\n\n \nstatic void mxuport_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct usb_serial *serial = port->serial;\n\n\tif (port == serial->port[0])\n\t\tmxuport_process_read_urb_demux_data(urb);\n\n\tif (port == serial->port[1])\n\t\tmxuport_process_read_urb_demux_event(urb);\n}\n\n \nstatic bool mxuport_tx_empty(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tbool is_empty = true;\n\tu32 txlen;\n\tu8 *len_buf;\n\tint err;\n\n\tlen_buf = kzalloc(4, GFP_KERNEL);\n\tif (!len_buf)\n\t\tgoto out;\n\n\terr = mxuport_recv_ctrl_urb(serial, RQ_VENDOR_GET_OUTQUEUE, 0,\n\t\t\t\t    port->port_number, len_buf, 4);\n\tif (err < 0)\n\t\tgoto out;\n\n\ttxlen = get_unaligned_be32(len_buf);\n\tdev_dbg(&port->dev, \"%s - tx len = %u\\n\", __func__, txlen);\n\n\tif (txlen != 0)\n\t\tis_empty = false;\n\nout:\n\tkfree(len_buf);\n\treturn is_empty;\n}\n\nstatic int mxuport_set_mcr(struct usb_serial_port *port, u8 mcr_state)\n{\n\tstruct usb_serial *serial = port->serial;\n\tint err;\n\n\tdev_dbg(&port->dev, \"%s - %02x\\n\", __func__, mcr_state);\n\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_MCR,\n\t\t\t\t    mcr_state, port->port_number);\n\tif (err)\n\t\tdev_err(&port->dev, \"%s - failed to change MCR\\n\", __func__);\n\n\treturn err;\n}\n\nstatic int mxuport_set_dtr(struct usb_serial_port *port, int on)\n{\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint err;\n\n\tmutex_lock(&mxport->mutex);\n\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_DTR,\n\t\t\t\t    !!on, port->port_number);\n\tif (!err) {\n\t\tif (on)\n\t\t\tmxport->mcr_state |= UART_MCR_DTR;\n\t\telse\n\t\t\tmxport->mcr_state &= ~UART_MCR_DTR;\n\t}\n\n\tmutex_unlock(&mxport->mutex);\n\n\treturn err;\n}\n\nstatic int mxuport_set_rts(struct usb_serial_port *port, u8 state)\n{\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint err;\n\tu8 mcr_state;\n\n\tmutex_lock(&mxport->mutex);\n\tmcr_state = mxport->mcr_state;\n\n\tswitch (state) {\n\tcase MX_RTS_DISABLE:\n\t\tmcr_state &= ~UART_MCR_RTS;\n\t\tbreak;\n\tcase MX_RTS_ENABLE:\n\t\tmcr_state |= UART_MCR_RTS;\n\t\tbreak;\n\tcase MX_RTS_HW:\n\t\t \n\t\tbreak;\n\tdefault:\n\t\t \n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RTS,\n\t\t\t\t    state, port->port_number);\n\tif (!err)\n\t\tmxport->mcr_state = mcr_state;\n\nout:\n\tmutex_unlock(&mxport->mutex);\n\n\treturn err;\n}\n\nstatic void mxuport_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tu8 mcr_state;\n\tint err;\n\n\tmutex_lock(&mxport->mutex);\n\tmcr_state = mxport->mcr_state;\n\n\tif (on)\n\t\tmcr_state |= (UART_MCR_RTS | UART_MCR_DTR);\n\telse\n\t\tmcr_state &= ~(UART_MCR_RTS | UART_MCR_DTR);\n\n\terr = mxuport_set_mcr(port, mcr_state);\n\tif (!err)\n\t\tmxport->mcr_state = mcr_state;\n\n\tmutex_unlock(&mxport->mutex);\n}\n\nstatic int mxuport_tiocmset(struct tty_struct *tty, unsigned int set,\n\t\t\t    unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tint err;\n\tu8 mcr_state;\n\n\tmutex_lock(&mxport->mutex);\n\tmcr_state = mxport->mcr_state;\n\n\tif (set & TIOCM_RTS)\n\t\tmcr_state |= UART_MCR_RTS;\n\n\tif (set & TIOCM_DTR)\n\t\tmcr_state |= UART_MCR_DTR;\n\n\tif (clear & TIOCM_RTS)\n\t\tmcr_state &= ~UART_MCR_RTS;\n\n\tif (clear & TIOCM_DTR)\n\t\tmcr_state &= ~UART_MCR_DTR;\n\n\terr = mxuport_set_mcr(port, mcr_state);\n\tif (!err)\n\t\tmxport->mcr_state = mcr_state;\n\n\tmutex_unlock(&mxport->mutex);\n\n\treturn err;\n}\n\nstatic int mxuport_tiocmget(struct tty_struct *tty)\n{\n\tstruct mxuport_port *mxport;\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int result;\n\tunsigned long flags;\n\tunsigned int msr;\n\tunsigned int mcr;\n\n\tmxport = usb_get_serial_port_data(port);\n\n\tmutex_lock(&mxport->mutex);\n\tspin_lock_irqsave(&mxport->spinlock, flags);\n\n\tmsr = mxport->msr_state;\n\tmcr = mxport->mcr_state;\n\n\tspin_unlock_irqrestore(&mxport->spinlock, flags);\n\tmutex_unlock(&mxport->mutex);\n\n\tresult = (((mcr & UART_MCR_DTR) ? TIOCM_DTR : 0) |\t \n\t\t  ((mcr & UART_MCR_RTS) ? TIOCM_RTS : 0) |\t \n\t\t  ((msr & UART_MSR_CTS) ? TIOCM_CTS : 0) |\t \n\t\t  ((msr & UART_MSR_DCD) ? TIOCM_CAR : 0) |\t \n\t\t  ((msr & UART_MSR_RI) ? TIOCM_RI : 0) |\t \n\t\t  ((msr & UART_MSR_DSR) ? TIOCM_DSR : 0));\t \n\n\tdev_dbg(&port->dev, \"%s - 0x%04x\\n\", __func__, result);\n\n\treturn result;\n}\n\nstatic int mxuport_set_termios_flow(struct tty_struct *tty,\n\t\t\t\t    const struct ktermios *old_termios,\n\t\t\t\t    struct usb_serial_port *port,\n\t\t\t\t    struct usb_serial *serial)\n{\n\tu8 xon = START_CHAR(tty);\n\tu8 xoff = STOP_CHAR(tty);\n\tint enable;\n\tint err;\n\tu8 *buf;\n\tu8 rts;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\t \n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tenable = 1;\n\t\tbuf[0] = xon;\n\t\tbuf[1] = xoff;\n\n\t\terr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_CHARS,\n\t\t\t\t\t\t 0, port->port_number,\n\t\t\t\t\t\t buf, 2);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\tdev_dbg(&port->dev, \"%s - XON = 0x%02x, XOFF = 0x%02x\\n\",\n\t\t\t__func__, xon, xoff);\n\t} else {\n\t\tenable = 0;\n\t}\n\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_XONXOFF,\n\t\t\t\t    enable, port->port_number);\n\tif (err)\n\t\tgoto out;\n\n\trts = MX_RTS_NO_CHANGE;\n\n\t \n\tif (!old_termios ||\n\t    C_CRTSCTS(tty) != (old_termios->c_cflag & CRTSCTS)) {\n\t\tif (C_CRTSCTS(tty))\n\t\t\trts = MX_RTS_HW;\n\t\telse\n\t\t\trts = MX_RTS_ENABLE;\n\t}\n\n\tif (C_BAUD(tty)) {\n\t\tif (old_termios && (old_termios->c_cflag & CBAUD) == B0) {\n\t\t\t \n\t\t\tif (C_CRTSCTS(tty))\n\t\t\t\trts = MX_RTS_HW;\n\t\t\telse\n\t\t\t\trts = MX_RTS_ENABLE;\n\t\t\tmxuport_set_dtr(port, 1);\n\t\t}\n\t} else {\n\t\t \n\t\trts = MX_RTS_DISABLE;\n\t\tmxuport_set_dtr(port, 0);\n\t}\n\n\tif (rts != MX_RTS_NO_CHANGE)\n\t\terr = mxuport_set_rts(port, rts);\n\nout:\n\tkfree(buf);\n\treturn err;\n}\n\nstatic void mxuport_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tu8 *buf;\n\tu8 data_bits;\n\tu8 stop_bits;\n\tu8 parity;\n\tint baud;\n\tint err;\n\n\tif (old_termios &&\n\t    !tty_termios_hw_change(&tty->termios, old_termios) &&\n\t    tty->termios.c_iflag == old_termios->c_iflag) {\n\t\tdev_dbg(&port->dev, \"%s - nothing to change\\n\", __func__);\n\t\treturn;\n\t}\n\n\tbuf = kmalloc(4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn;\n\n\t \n\tswitch (C_CSIZE(tty)) {\n\tcase CS5:\n\t\tdata_bits = MX_WORDLENGTH_5;\n\t\tbreak;\n\tcase CS6:\n\t\tdata_bits = MX_WORDLENGTH_6;\n\t\tbreak;\n\tcase CS7:\n\t\tdata_bits = MX_WORDLENGTH_7;\n\t\tbreak;\n\tcase CS8:\n\tdefault:\n\t\tdata_bits = MX_WORDLENGTH_8;\n\t\tbreak;\n\t}\n\n\t \n\tif (C_PARENB(tty)) {\n\t\tif (C_CMSPAR(tty)) {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tparity = MX_PARITY_MARK;\n\t\t\telse\n\t\t\t\tparity = MX_PARITY_SPACE;\n\t\t} else {\n\t\t\tif (C_PARODD(tty))\n\t\t\t\tparity = MX_PARITY_ODD;\n\t\t\telse\n\t\t\t\tparity = MX_PARITY_EVEN;\n\t\t}\n\t} else {\n\t\tparity = MX_PARITY_NONE;\n\t}\n\n\t \n\tif (C_CSTOPB(tty))\n\t\tstop_bits = MX_STOP_BITS_2;\n\telse\n\t\tstop_bits = MX_STOP_BITS_1;\n\n\tbuf[0] = data_bits;\n\tbuf[1] = parity;\n\tbuf[2] = stop_bits;\n\tbuf[3] = 0;\n\n\terr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_LINE,\n\t\t\t\t\t 0, port->port_number, buf, 4);\n\tif (err)\n\t\tgoto out;\n\n\terr = mxuport_set_termios_flow(tty, old_termios, port, serial);\n\tif (err)\n\t\tgoto out;\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\tbaud = 9600;\n\n\t \n\tput_unaligned_le32(baud, buf);\n\n\terr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_SET_BAUD,\n\t\t\t\t\t 0, port->port_number,\n\t\t\t\t\t buf, 4);\n\tif (err)\n\t\tgoto out;\n\n\tdev_dbg(&port->dev, \"baud_rate\t: %d\\n\", baud);\n\tdev_dbg(&port->dev, \"data_bits\t: %d\\n\", data_bits);\n\tdev_dbg(&port->dev, \"parity\t: %d\\n\", parity);\n\tdev_dbg(&port->dev, \"stop_bits\t: %d\\n\", stop_bits);\n\nout:\n\tkfree(buf);\n}\n\n \nstatic int mxuport_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tunsigned long features = (unsigned long)usb_get_serial_data(serial);\n\tint num_ports;\n\tint i;\n\n\tif (features & MX_UPORT_2_PORT) {\n\t\tnum_ports = 2;\n\t} else if (features & MX_UPORT_4_PORT) {\n\t\tnum_ports = 4;\n\t} else if (features & MX_UPORT_8_PORT) {\n\t\tnum_ports = 8;\n\t} else if (features & MX_UPORT_16_PORT) {\n\t\tnum_ports = 16;\n\t} else {\n\t\tdev_warn(&serial->interface->dev,\n\t\t\t\t\"unknown device, assuming two ports\\n\");\n\t\tnum_ports = 2;\n\t}\n\n\t \n\tBUILD_BUG_ON(ARRAY_SIZE(epds->bulk_out) < 16);\n\n\tfor (i = 1; i < num_ports; ++i)\n\t\tepds->bulk_out[i] = epds->bulk_out[0];\n\n\tepds->num_bulk_out = num_ports;\n\n\treturn num_ports;\n}\n\n \nstatic int mxuport_get_fw_version(struct usb_serial *serial, u32 *version)\n{\n\tu8 *ver_buf;\n\tint err;\n\n\tver_buf = kzalloc(4, GFP_KERNEL);\n\tif (!ver_buf)\n\t\treturn -ENOMEM;\n\n\t \n\terr = mxuport_recv_ctrl_urb(serial, RQ_VENDOR_GET_VERSION, 0, 0,\n\t\t\t\t    ver_buf, 4);\n\tif (err != 4) {\n\t\terr = -EIO;\n\t\tgoto out;\n\t}\n\n\t*version = (ver_buf[0] << 16) | (ver_buf[1] << 8) | ver_buf[2];\n\terr = 0;\nout:\n\tkfree(ver_buf);\n\treturn err;\n}\n\n \nstatic int mxuport_download_fw(struct usb_serial *serial,\n\t\t\t       const struct firmware *fw_p)\n{\n\tu8 *fw_buf;\n\tsize_t txlen;\n\tsize_t fwidx;\n\tint err;\n\n\tfw_buf = kmalloc(DOWN_BLOCK_SIZE, GFP_KERNEL);\n\tif (!fw_buf)\n\t\treturn -ENOMEM;\n\n\tdev_dbg(&serial->interface->dev, \"Starting firmware download...\\n\");\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_START_FW_DOWN, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tfwidx = 0;\n\tdo {\n\t\ttxlen = min_t(size_t, (fw_p->size - fwidx), DOWN_BLOCK_SIZE);\n\n\t\tmemcpy(fw_buf, &fw_p->data[fwidx], txlen);\n\t\terr = mxuport_send_ctrl_data_urb(serial, RQ_VENDOR_FW_DATA,\n\t\t\t\t\t\t 0, 0, fw_buf, txlen);\n\t\tif (err) {\n\t\t\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_STOP_FW_DOWN,\n\t\t\t\t\t      0, 0);\n\t\t\tgoto out;\n\t\t}\n\n\t\tfwidx += txlen;\n\t\tusleep_range(1000, 2000);\n\n\t} while (fwidx < fw_p->size);\n\n\tmsleep(1000);\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_STOP_FW_DOWN, 0, 0);\n\tif (err)\n\t\tgoto out;\n\n\tmsleep(1000);\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_QUERY_FW_READY, 0, 0);\n\nout:\n\tkfree(fw_buf);\n\treturn err;\n}\n\nstatic int mxuport_probe(struct usb_serial *serial,\n\t\t\t const struct usb_device_id *id)\n{\n\tu16 productid = le16_to_cpu(serial->dev->descriptor.idProduct);\n\tconst struct firmware *fw_p = NULL;\n\tu32 version;\n\tint local_ver;\n\tchar buf[32];\n\tint err;\n\n\t \n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_QUERY_FW_CONFIG, 0, 0);\n\tif (err) {\n\t\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_RESET_DEVICE, 0, 0);\n\t\treturn err;\n\t}\n\n\terr = mxuport_get_fw_version(serial, &version);\n\tif (err < 0)\n\t\treturn err;\n\n\tdev_dbg(&serial->interface->dev, \"Device firmware version v%x.%x.%x\\n\",\n\t\t(version & 0xff0000) >> 16,\n\t\t(version & 0xff00) >> 8,\n\t\t(version & 0xff));\n\n\tsnprintf(buf, sizeof(buf) - 1, \"moxa/moxa-%04x.fw\", productid);\n\n\terr = request_firmware(&fw_p, buf, &serial->interface->dev);\n\tif (err) {\n\t\tdev_warn(&serial->interface->dev, \"Firmware %s not found\\n\",\n\t\t\t buf);\n\n\t\t \n\t\terr = 0;\n\t} else {\n\t\tlocal_ver = ((fw_p->data[VER_ADDR_1] << 16) |\n\t\t\t     (fw_p->data[VER_ADDR_2] << 8) |\n\t\t\t     fw_p->data[VER_ADDR_3]);\n\t\tdev_dbg(&serial->interface->dev,\n\t\t\t\"Available firmware version v%x.%x.%x\\n\",\n\t\t\tfw_p->data[VER_ADDR_1], fw_p->data[VER_ADDR_2],\n\t\t\tfw_p->data[VER_ADDR_3]);\n\t\tif (local_ver > version) {\n\t\t\terr = mxuport_download_fw(serial, fw_p);\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t\terr  = mxuport_get_fw_version(serial, &version);\n\t\t\tif (err < 0)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdev_info(&serial->interface->dev,\n\t\t \"Using device firmware version v%x.%x.%x\\n\",\n\t\t (version & 0xff0000) >> 16,\n\t\t (version & 0xff00) >> 8,\n\t\t (version & 0xff));\n\n\t \n\tusb_set_serial_data(serial, (void *)id->driver_info);\nout:\n\tif (fw_p)\n\t\trelease_firmware(fw_p);\n\treturn err;\n}\n\n\nstatic int mxuport_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct mxuport_port *mxport;\n\tint err;\n\n\tmxport = devm_kzalloc(&port->dev, sizeof(struct mxuport_port),\n\t\t\t      GFP_KERNEL);\n\tif (!mxport)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&mxport->mutex);\n\tspin_lock_init(&mxport->spinlock);\n\n\t \n\tusb_set_serial_port_data(port, mxport);\n\n\t \n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_FIFO_DISABLE,\n\t\t\t\t    0, port->port_number);\n\tif (err)\n\t\treturn err;\n\n\t \n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_HIGH_PERFOR,\n\t\t\t\t    0, port->port_number);\n\tif (err)\n\t\treturn err;\n\n\t \n\treturn mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_INTERFACE,\n\t\t\t\t     MX_INT_RS232,\n\t\t\t\t     port->port_number);\n}\n\nstatic int mxuport_attach(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port0 = serial->port[0];\n\tstruct usb_serial_port *port1 = serial->port[1];\n\tint err;\n\n\t \n\terr = usb_serial_generic_submit_read_urbs(port0, GFP_KERNEL);\n\tif (err)\n\t\treturn err;\n\n\terr = usb_serial_generic_submit_read_urbs(port1, GFP_KERNEL);\n\tif (err) {\n\t\tusb_serial_generic_close(port0);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void mxuport_release(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port0 = serial->port[0];\n\tstruct usb_serial_port *port1 = serial->port[1];\n\n\tusb_serial_generic_close(port1);\n\tusb_serial_generic_close(port0);\n}\n\nstatic int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct mxuport_port *mxport = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint err;\n\n\t \n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\n\t\t\t\t    1, port->port_number);\n\tif (err)\n\t\treturn err;\n\n\terr = mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_OPEN,\n\t\t\t\t    1, port->port_number);\n\tif (err) {\n\t\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN,\n\t\t\t\t      0, port->port_number);\n\t\treturn err;\n\t}\n\n\t \n\tif (tty)\n\t\tmxuport_set_termios(tty, port, NULL);\n\n\t \n\tmxport->msr_state = 0;\n\n\treturn err;\n}\n\nstatic void mxuport_close(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\n\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_OPEN, 0,\n\t\t\t      port->port_number);\n\n\tmxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_RX_HOST_EN, 0,\n\t\t\t      port->port_number);\n}\n\n \nstatic int mxuport_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial *serial = port->serial;\n\tint enable;\n\n\tif (break_state == -1) {\n\t\tenable = 1;\n\t\tdev_dbg(&port->dev, \"%s - sending break\\n\", __func__);\n\t} else {\n\t\tenable = 0;\n\t\tdev_dbg(&port->dev, \"%s - clearing break\\n\", __func__);\n\t}\n\n\treturn mxuport_send_ctrl_urb(serial, RQ_VENDOR_SET_BREAK,\n\t\t\t\t     enable, port->port_number);\n}\n\nstatic int mxuport_resume(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tint c = 0;\n\tint i;\n\tint r;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tport = serial->port[i];\n\n\t\tr = usb_serial_generic_submit_read_urbs(port, GFP_NOIO);\n\t\tif (r < 0)\n\t\t\tc++;\n\t}\n\n\tfor (i = 0; i < serial->num_ports; i++) {\n\t\tport = serial->port[i];\n\t\tif (!tty_port_initialized(&port->port))\n\t\t\tcontinue;\n\n\t\tr = usb_serial_generic_write_start(port, GFP_NOIO);\n\t\tif (r < 0)\n\t\t\tc++;\n\t}\n\n\treturn c ? -EIO : 0;\n}\n\nstatic struct usb_serial_driver mxuport_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"mxuport\",\n\t},\n\t.description\t\t= \"MOXA UPort\",\n\t.id_table\t\t= mxuport_idtable,\n\t.num_bulk_in\t\t= 2,\n\t.num_bulk_out\t\t= 1,\n\t.probe\t\t\t= mxuport_probe,\n\t.port_probe\t\t= mxuport_port_probe,\n\t.attach\t\t\t= mxuport_attach,\n\t.release\t\t= mxuport_release,\n\t.calc_num_ports\t\t= mxuport_calc_num_ports,\n\t.open\t\t\t= mxuport_open,\n\t.close\t\t\t= mxuport_close,\n\t.set_termios\t\t= mxuport_set_termios,\n\t.break_ctl\t\t= mxuport_break_ctl,\n\t.tx_empty\t\t= mxuport_tx_empty,\n\t.tiocmiwait\t\t= usb_serial_generic_tiocmiwait,\n\t.get_icount\t\t= usb_serial_generic_get_icount,\n\t.throttle\t\t= mxuport_throttle,\n\t.unthrottle\t\t= mxuport_unthrottle,\n\t.tiocmget\t\t= mxuport_tiocmget,\n\t.tiocmset\t\t= mxuport_tiocmset,\n\t.dtr_rts\t\t= mxuport_dtr_rts,\n\t.process_read_urb\t= mxuport_process_read_urb,\n\t.prepare_write_buffer\t= mxuport_prepare_write_buffer,\n\t.resume\t\t\t= mxuport_resume,\n};\n\nstatic struct usb_serial_driver *const serial_drivers[] = {\n\t&mxuport_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, mxuport_idtable);\n\nMODULE_AUTHOR(\"Andrew Lunn <andrew@lunn.ch>\");\nMODULE_AUTHOR(\"<support@moxa.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}