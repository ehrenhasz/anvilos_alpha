{
  "module_name": "ir-usb.c",
  "hash_id": "a5fe32bb41bd13c203aa79d684adc4480b06b996a3564ab5e7cd422a3b8cdfb9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ir-usb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/irda.h>\n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"USB IR Dongle driver\"\n\n \nstatic int buffer_size;\n\n \nstatic int xbof = -1;\n\nstatic int  ir_startup (struct usb_serial *serial);\nstatic int ir_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\tconst unsigned char *buf, int count);\nstatic unsigned int ir_write_room(struct tty_struct *tty);\nstatic void ir_write_bulk_callback(struct urb *urb);\nstatic void ir_process_read_urb(struct urb *urb);\nstatic void ir_set_termios(struct tty_struct *tty,\n\t\t\t   struct usb_serial_port *port,\n\t\t\t   const struct ktermios *old_termios);\n\n \nstatic u8 ir_baud;\nstatic u8 ir_xbof;\nstatic u8 ir_add_bof;\n\nstatic const struct usb_device_id ir_id_table[] = {\n\t{ USB_DEVICE(0x050f, 0x0180) },\t\t \n\t{ USB_DEVICE(0x08e9, 0x0100) },\t\t \n\t{ USB_DEVICE(0x09c4, 0x0011) },\t\t \n\t{ USB_INTERFACE_INFO(USB_CLASS_APP_SPEC, USB_SUBCLASS_IRDA, 0) },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, ir_id_table);\n\nstatic struct usb_serial_driver ir_device = {\n\t.driver\t= {\n\t\t.owner\t= THIS_MODULE,\n\t\t.name\t= \"ir-usb\",\n\t},\n\t.description\t\t= \"IR Dongle\",\n\t.id_table\t\t= ir_id_table,\n\t.num_ports\t\t= 1,\n\t.num_bulk_in\t\t= 1,\n\t.num_bulk_out\t\t= 1,\n\t.set_termios\t\t= ir_set_termios,\n\t.attach\t\t\t= ir_startup,\n\t.write\t\t\t= ir_write,\n\t.write_room\t\t= ir_write_room,\n\t.write_bulk_callback\t= ir_write_bulk_callback,\n\t.process_read_urb\t= ir_process_read_urb,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ir_device, NULL\n};\n\nstatic inline void irda_usb_dump_class_desc(struct usb_serial *serial,\n\t\t\t\t\t    struct usb_irda_cs_descriptor *desc)\n{\n\tstruct device *dev = &serial->dev->dev;\n\n\tdev_dbg(dev, \"bLength=%x\\n\", desc->bLength);\n\tdev_dbg(dev, \"bDescriptorType=%x\\n\", desc->bDescriptorType);\n\tdev_dbg(dev, \"bcdSpecRevision=%x\\n\", __le16_to_cpu(desc->bcdSpecRevision));\n\tdev_dbg(dev, \"bmDataSize=%x\\n\", desc->bmDataSize);\n\tdev_dbg(dev, \"bmWindowSize=%x\\n\", desc->bmWindowSize);\n\tdev_dbg(dev, \"bmMinTurnaroundTime=%d\\n\", desc->bmMinTurnaroundTime);\n\tdev_dbg(dev, \"wBaudRate=%x\\n\", __le16_to_cpu(desc->wBaudRate));\n\tdev_dbg(dev, \"bmAdditionalBOFs=%x\\n\", desc->bmAdditionalBOFs);\n\tdev_dbg(dev, \"bIrdaRateSniff=%x\\n\", desc->bIrdaRateSniff);\n\tdev_dbg(dev, \"bMaxUnicastList=%x\\n\", desc->bMaxUnicastList);\n}\n\n \n \nstatic struct usb_irda_cs_descriptor *\nirda_usb_find_class_desc(struct usb_serial *serial, unsigned int ifnum)\n{\n\tstruct usb_device *dev = serial->dev;\n\tstruct usb_irda_cs_descriptor *desc;\n\tint ret;\n\n\tdesc = kzalloc(sizeof(*desc), GFP_KERNEL);\n\tif (!desc)\n\t\treturn NULL;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\tUSB_REQ_CS_IRDA_GET_CLASS_DESC,\n\t\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t0, ifnum, desc, sizeof(*desc), 1000);\n\n\tdev_dbg(&serial->dev->dev, \"%s -  ret=%d\\n\", __func__, ret);\n\tif (ret < (int)sizeof(*desc)) {\n\t\tdev_dbg(&serial->dev->dev,\n\t\t\t\"%s - class descriptor read %s (%d)\\n\", __func__,\n\t\t\t(ret < 0) ? \"failed\" : \"too short\", ret);\n\t\tgoto error;\n\t}\n\tif (desc->bDescriptorType != USB_DT_CS_IRDA) {\n\t\tdev_dbg(&serial->dev->dev, \"%s - bad class descriptor type\\n\",\n\t\t\t__func__);\n\t\tgoto error;\n\t}\n\n\tirda_usb_dump_class_desc(serial, desc);\n\treturn desc;\n\nerror:\n\tkfree(desc);\n\treturn NULL;\n}\n\nstatic u8 ir_xbof_change(u8 xbof)\n{\n\tu8 result;\n\n\t \n\tswitch (xbof) {\n\tcase 48:\n\t\tresult = 0x10;\n\t\tbreak;\n\tcase 28:\n\tcase 24:\n\t\tresult = 0x20;\n\t\tbreak;\n\tdefault:\n\tcase 12:\n\t\tresult = 0x30;\n\t\tbreak;\n\tcase  5:\n\tcase  6:\n\t\tresult = 0x40;\n\t\tbreak;\n\tcase  3:\n\t\tresult = 0x50;\n\t\tbreak;\n\tcase  2:\n\t\tresult = 0x60;\n\t\tbreak;\n\tcase  1:\n\t\tresult = 0x70;\n\t\tbreak;\n\tcase  0:\n\t\tresult = 0x80;\n\t\tbreak;\n\t}\n\n\treturn(result);\n}\n\nstatic int ir_startup(struct usb_serial *serial)\n{\n\tstruct usb_irda_cs_descriptor *irda_desc;\n\tint rates;\n\n\tirda_desc = irda_usb_find_class_desc(serial, 0);\n\tif (!irda_desc) {\n\t\tdev_err(&serial->dev->dev,\n\t\t\t\"IRDA class descriptor not found, device not bound\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\trates = le16_to_cpu(irda_desc->wBaudRate);\n\n\tdev_dbg(&serial->dev->dev,\n\t\t\"%s - Baud rates supported:%s%s%s%s%s%s%s%s%s\\n\",\n\t\t__func__,\n\t\t(rates & USB_IRDA_BR_2400) ? \" 2400\" : \"\",\n\t\t(rates & USB_IRDA_BR_9600) ? \" 9600\" : \"\",\n\t\t(rates & USB_IRDA_BR_19200) ? \" 19200\" : \"\",\n\t\t(rates & USB_IRDA_BR_38400) ? \" 38400\" : \"\",\n\t\t(rates & USB_IRDA_BR_57600) ? \" 57600\" : \"\",\n\t\t(rates & USB_IRDA_BR_115200) ? \" 115200\" : \"\",\n\t\t(rates & USB_IRDA_BR_576000) ? \" 576000\" : \"\",\n\t\t(rates & USB_IRDA_BR_1152000) ? \" 1152000\" : \"\",\n\t\t(rates & USB_IRDA_BR_4000000) ? \" 4000000\" : \"\");\n\n\tswitch (irda_desc->bmAdditionalBOFs) {\n\tcase USB_IRDA_AB_48:\n\t\tir_add_bof = 48;\n\t\tbreak;\n\tcase USB_IRDA_AB_24:\n\t\tir_add_bof = 24;\n\t\tbreak;\n\tcase USB_IRDA_AB_12:\n\t\tir_add_bof = 12;\n\t\tbreak;\n\tcase USB_IRDA_AB_6:\n\t\tir_add_bof = 6;\n\t\tbreak;\n\tcase USB_IRDA_AB_3:\n\t\tir_add_bof = 3;\n\t\tbreak;\n\tcase USB_IRDA_AB_2:\n\t\tir_add_bof = 2;\n\t\tbreak;\n\tcase USB_IRDA_AB_1:\n\t\tir_add_bof = 1;\n\t\tbreak;\n\tcase USB_IRDA_AB_0:\n\t\tir_add_bof = 0;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(irda_desc);\n\n\treturn 0;\n}\n\nstatic int ir_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\tconst unsigned char *buf, int count)\n{\n\tstruct urb *urb = NULL;\n\tunsigned long flags;\n\tint ret;\n\n\tif (port->bulk_out_size == 0)\n\t\treturn -EINVAL;\n\n\tif (count == 0)\n\t\treturn 0;\n\n\tcount = min(count, port->bulk_out_size - 1);\n\n\tspin_lock_irqsave(&port->lock, flags);\n\tif (__test_and_clear_bit(0, &port->write_urbs_free)) {\n\t\turb = port->write_urbs[0];\n\t\tport->tx_bytes += count;\n\t}\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tif (!urb)\n\t\treturn 0;\n\n\t \n\t*(u8 *)urb->transfer_buffer = ir_xbof | ir_baud;\n\n\tmemcpy(urb->transfer_buffer + 1, buf, count);\n\n\turb->transfer_buffer_length = count + 1;\n\turb->transfer_flags = URB_ZERO_PACKET;\n\n\tret = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (ret) {\n\t\tdev_err(&port->dev, \"failed to submit write urb: %d\\n\", ret);\n\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\t__set_bit(0, &port->write_urbs_free);\n\t\tport->tx_bytes -= count;\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\n\nstatic void ir_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&port->lock, flags);\n\t__set_bit(0, &port->write_urbs_free);\n\tport->tx_bytes -= urb->transfer_buffer_length - 1;\n\tspin_unlock_irqrestore(&port->lock, flags);\n\n\tswitch (status) {\n\tcase 0:\n\t\tbreak;\n\tcase -ENOENT:\n\tcase -ECONNRESET:\n\tcase -ESHUTDOWN:\n\t\tdev_dbg(&port->dev, \"write urb stopped: %d\\n\", status);\n\t\treturn;\n\tcase -EPIPE:\n\t\tdev_err(&port->dev, \"write urb stopped: %d\\n\", status);\n\t\treturn;\n\tdefault:\n\t\tdev_err(&port->dev, \"nonzero write-urb status: %d\\n\", status);\n\t\tbreak;\n\t}\n\n\tusb_serial_port_softint(port);\n}\n\nstatic unsigned int ir_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int count = 0;\n\n\tif (port->bulk_out_size == 0)\n\t\treturn 0;\n\n\tif (test_bit(0, &port->write_urbs_free))\n\t\tcount = port->bulk_out_size - 1;\n\n\treturn count;\n}\n\nstatic void ir_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\n\tif (!urb->actual_length)\n\t\treturn;\n\t \n\tif (*data & 0x0f)\n\t\tir_baud = *data & 0x0f;\n\n\tif (urb->actual_length == 1)\n\t\treturn;\n\n\ttty_insert_flip_string(&port->port, data + 1, urb->actual_length - 1);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic void ir_set_termios(struct tty_struct *tty,\n\t\t\t   struct usb_serial_port *port,\n\t\t\t   const struct ktermios *old_termios)\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tunsigned char *transfer_buffer;\n\tint actual_length;\n\tspeed_t baud;\n\tint ir_baud;\n\tint ret;\n\n\tbaud = tty_get_baud_rate(tty);\n\n\t \n\n\tswitch (baud) {\n\tcase 2400:\n\t\tir_baud = USB_IRDA_LS_2400;\n\t\tbreak;\n\tcase 9600:\n\t\tir_baud = USB_IRDA_LS_9600;\n\t\tbreak;\n\tcase 19200:\n\t\tir_baud = USB_IRDA_LS_19200;\n\t\tbreak;\n\tcase 38400:\n\t\tir_baud = USB_IRDA_LS_38400;\n\t\tbreak;\n\tcase 57600:\n\t\tir_baud = USB_IRDA_LS_57600;\n\t\tbreak;\n\tcase 115200:\n\t\tir_baud = USB_IRDA_LS_115200;\n\t\tbreak;\n\tcase 576000:\n\t\tir_baud = USB_IRDA_LS_576000;\n\t\tbreak;\n\tcase 1152000:\n\t\tir_baud = USB_IRDA_LS_1152000;\n\t\tbreak;\n\tcase 4000000:\n\t\tir_baud = USB_IRDA_LS_4000000;\n\t\tbreak;\n\tdefault:\n\t\tir_baud = USB_IRDA_LS_9600;\n\t\tbaud = 9600;\n\t}\n\n\tif (xbof == -1)\n\t\tir_xbof = ir_xbof_change(ir_add_bof);\n\telse\n\t\tir_xbof = ir_xbof_change(xbof) ;\n\n\t \n\ttty_termios_copy_hw(&tty->termios, old_termios);\n\ttty_encode_baud_rate(tty, baud, baud);\n\n\t \n\ttransfer_buffer = kmalloc(1, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn;\n\n\t*transfer_buffer = ir_xbof | ir_baud;\n\n\tret = usb_bulk_msg(udev,\n\t\t\tusb_sndbulkpipe(udev, port->bulk_out_endpointAddress),\n\t\t\ttransfer_buffer, 1, &actual_length, 5000);\n\tif (ret || actual_length != 1) {\n\t\tif (!ret)\n\t\t\tret = -EIO;\n\t\tdev_err(&port->dev, \"failed to change line speed: %d\\n\", ret);\n\t}\n\n\tkfree(transfer_buffer);\n}\n\nstatic int __init ir_init(void)\n{\n\tif (buffer_size) {\n\t\tir_device.bulk_in_size = buffer_size;\n\t\tir_device.bulk_out_size = buffer_size;\n\t}\n\n\treturn usb_serial_register_drivers(serial_drivers, KBUILD_MODNAME, ir_id_table);\n}\n\nstatic void __exit ir_exit(void)\n{\n\tusb_serial_deregister_drivers(serial_drivers);\n}\n\n\nmodule_init(ir_init);\nmodule_exit(ir_exit);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(xbof, int, 0);\nMODULE_PARM_DESC(xbof, \"Force specific number of XBOFs\");\nmodule_param(buffer_size, int, 0);\nMODULE_PARM_DESC(buffer_size, \"Size of the transfer buffers\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}