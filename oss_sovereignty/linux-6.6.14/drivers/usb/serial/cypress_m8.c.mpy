{
  "module_name": "cypress_m8.c",
  "hash_id": "5ca99de9ca84490875561bfc203833381c1520d8f60238cc8222efce62c67ed8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/cypress_m8.c",
  "human_readable_source": "\n \n\n \n \n \n \n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial.h>\n#include <linux/kfifo.h>\n#include <linux/delay.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n\n#include \"cypress_m8.h\"\n\n\nstatic bool stats;\nstatic int interval;\nstatic bool unstable_bauds;\n\n#define DRIVER_AUTHOR \"Lonnie Mendez <dignome@gmail.com>, Neil Whelchel <koyama@firstlight.net>\"\n#define DRIVER_DESC \"Cypress USB to Serial Driver\"\n\n \n#define CYPRESS_BUF_SIZE\t1024\n\nstatic const struct usb_device_id id_table_earthmate[] = {\n\t{ USB_DEVICE(VENDOR_ID_DELORME, PRODUCT_ID_EARTHMATEUSB) },\n\t{ USB_DEVICE(VENDOR_ID_DELORME, PRODUCT_ID_EARTHMATEUSB_LT20) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_cyphidcomrs232[] = {\n\t{ USB_DEVICE(VENDOR_ID_CYPRESS, PRODUCT_ID_CYPHIDCOM) },\n\t{ USB_DEVICE(VENDOR_ID_SAI, PRODUCT_ID_CYPHIDCOM) },\n\t{ USB_DEVICE(VENDOR_ID_POWERCOM, PRODUCT_ID_UPS) },\n\t{ USB_DEVICE(VENDOR_ID_FRWD, PRODUCT_ID_CYPHIDCOM_FRWD) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_nokiaca42v2[] = {\n\t{ USB_DEVICE(VENDOR_ID_DAZZLE, PRODUCT_ID_CA42) },\n\t{ }\t\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(VENDOR_ID_DELORME, PRODUCT_ID_EARTHMATEUSB) },\n\t{ USB_DEVICE(VENDOR_ID_DELORME, PRODUCT_ID_EARTHMATEUSB_LT20) },\n\t{ USB_DEVICE(VENDOR_ID_CYPRESS, PRODUCT_ID_CYPHIDCOM) },\n\t{ USB_DEVICE(VENDOR_ID_SAI, PRODUCT_ID_CYPHIDCOM) },\n\t{ USB_DEVICE(VENDOR_ID_POWERCOM, PRODUCT_ID_UPS) },\n\t{ USB_DEVICE(VENDOR_ID_FRWD, PRODUCT_ID_CYPHIDCOM_FRWD) },\n\t{ USB_DEVICE(VENDOR_ID_DAZZLE, PRODUCT_ID_CA42) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\nenum packet_format {\n\tpacket_format_1,   \n\tpacket_format_2    \n};\n\nstruct cypress_private {\n\tspinlock_t lock;\t\t    \n\tint chiptype;\t\t\t    \n\tint bytes_in;\t\t\t    \n\tint bytes_out;\t\t\t    \n\tint cmd_count;\t\t\t    \n\tint cmd_ctrl;\t\t\t    \n\tstruct kfifo write_fifo;\t    \n\tint write_urb_in_use;\t\t    \n\tint write_urb_interval;             \n\tint read_urb_interval;              \n\tint comm_is_ok;                     \n\t__u8 line_control;\t   \t    \n\t__u8 current_status;\t   \t    \n\t__u8 current_config;\t   \t    \n\t__u8 rx_flags;\t\t\t    \n\tenum packet_format pkt_fmt;\t    \n\tint get_cfg_unsafe;\t\t    \n\tint baud_rate;\t\t\t    \n\tchar prev_status;\t\t    \n};\n\n \nstatic int  cypress_earthmate_port_probe(struct usb_serial_port *port);\nstatic int  cypress_hidcom_port_probe(struct usb_serial_port *port);\nstatic int  cypress_ca42v2_port_probe(struct usb_serial_port *port);\nstatic void cypress_port_remove(struct usb_serial_port *port);\nstatic int  cypress_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void cypress_close(struct usb_serial_port *port);\nstatic void cypress_dtr_rts(struct usb_serial_port *port, int on);\nstatic int  cypress_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *buf, int count);\nstatic void cypress_send(struct usb_serial_port *port);\nstatic unsigned int cypress_write_room(struct tty_struct *tty);\nstatic void cypress_earthmate_init_termios(struct tty_struct *tty);\nstatic void cypress_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios);\nstatic int  cypress_tiocmget(struct tty_struct *tty);\nstatic int  cypress_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear);\nstatic unsigned int cypress_chars_in_buffer(struct tty_struct *tty);\nstatic void cypress_throttle(struct tty_struct *tty);\nstatic void cypress_unthrottle(struct tty_struct *tty);\nstatic void cypress_set_dead(struct usb_serial_port *port);\nstatic void cypress_read_int_callback(struct urb *urb);\nstatic void cypress_write_int_callback(struct urb *urb);\n\nstatic struct usb_serial_driver cypress_earthmate_device = {\n\t.driver = {\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.name =\t\t\t\"earthmate\",\n\t},\n\t.description =\t\t\t\"DeLorme Earthmate USB\",\n\t.id_table =\t\t\tid_table_earthmate,\n\t.num_ports =\t\t\t1,\n\t.port_probe =\t\t\tcypress_earthmate_port_probe,\n\t.port_remove =\t\t\tcypress_port_remove,\n\t.open =\t\t\t\tcypress_open,\n\t.close =\t\t\tcypress_close,\n\t.dtr_rts =\t\t\tcypress_dtr_rts,\n\t.write =\t\t\tcypress_write,\n\t.write_room =\t\t\tcypress_write_room,\n\t.init_termios =\t\t\tcypress_earthmate_init_termios,\n\t.set_termios =\t\t\tcypress_set_termios,\n\t.tiocmget =\t\t\tcypress_tiocmget,\n\t.tiocmset =\t\t\tcypress_tiocmset,\n\t.tiocmiwait =\t\t\tusb_serial_generic_tiocmiwait,\n\t.chars_in_buffer =\t\tcypress_chars_in_buffer,\n\t.throttle =\t\t \tcypress_throttle,\n\t.unthrottle =\t\t\tcypress_unthrottle,\n\t.read_int_callback =\t\tcypress_read_int_callback,\n\t.write_int_callback =\t\tcypress_write_int_callback,\n};\n\nstatic struct usb_serial_driver cypress_hidcom_device = {\n\t.driver = {\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.name =\t\t\t\"cyphidcom\",\n\t},\n\t.description =\t\t\t\"HID->COM RS232 Adapter\",\n\t.id_table =\t\t\tid_table_cyphidcomrs232,\n\t.num_ports =\t\t\t1,\n\t.port_probe =\t\t\tcypress_hidcom_port_probe,\n\t.port_remove =\t\t\tcypress_port_remove,\n\t.open =\t\t\t\tcypress_open,\n\t.close =\t\t\tcypress_close,\n\t.dtr_rts =\t\t\tcypress_dtr_rts,\n\t.write =\t\t\tcypress_write,\n\t.write_room =\t\t\tcypress_write_room,\n\t.set_termios =\t\t\tcypress_set_termios,\n\t.tiocmget =\t\t\tcypress_tiocmget,\n\t.tiocmset =\t\t\tcypress_tiocmset,\n\t.tiocmiwait =\t\t\tusb_serial_generic_tiocmiwait,\n\t.chars_in_buffer =\t\tcypress_chars_in_buffer,\n\t.throttle =\t\t\tcypress_throttle,\n\t.unthrottle =\t\t\tcypress_unthrottle,\n\t.read_int_callback =\t\tcypress_read_int_callback,\n\t.write_int_callback =\t\tcypress_write_int_callback,\n};\n\nstatic struct usb_serial_driver cypress_ca42v2_device = {\n\t.driver = {\n\t\t.owner =\t\tTHIS_MODULE,\n\t\t.name =\t\t\t\"nokiaca42v2\",\n\t},\n\t.description =\t\t\t\"Nokia CA-42 V2 Adapter\",\n\t.id_table =\t\t\tid_table_nokiaca42v2,\n\t.num_ports =\t\t\t1,\n\t.port_probe =\t\t\tcypress_ca42v2_port_probe,\n\t.port_remove =\t\t\tcypress_port_remove,\n\t.open =\t\t\t\tcypress_open,\n\t.close =\t\t\tcypress_close,\n\t.dtr_rts =\t\t\tcypress_dtr_rts,\n\t.write =\t\t\tcypress_write,\n\t.write_room =\t\t\tcypress_write_room,\n\t.set_termios =\t\t\tcypress_set_termios,\n\t.tiocmget =\t\t\tcypress_tiocmget,\n\t.tiocmset =\t\t\tcypress_tiocmset,\n\t.tiocmiwait =\t\t\tusb_serial_generic_tiocmiwait,\n\t.chars_in_buffer =\t\tcypress_chars_in_buffer,\n\t.throttle =\t\t\tcypress_throttle,\n\t.unthrottle =\t\t\tcypress_unthrottle,\n\t.read_int_callback =\t\tcypress_read_int_callback,\n\t.write_int_callback =\t\tcypress_write_int_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&cypress_earthmate_device, &cypress_hidcom_device,\n\t&cypress_ca42v2_device, NULL\n};\n\n \n\n \nstatic inline bool is_frwd(struct usb_device *dev)\n{\n\treturn ((le16_to_cpu(dev->descriptor.idVendor) == VENDOR_ID_FRWD) &&\n\t\t(le16_to_cpu(dev->descriptor.idProduct) == PRODUCT_ID_CYPHIDCOM_FRWD));\n}\n\nstatic int analyze_baud_rate(struct usb_serial_port *port, speed_t new_rate)\n{\n\tstruct cypress_private *priv;\n\tpriv = usb_get_serial_port_data(port);\n\n\tif (unstable_bauds)\n\t\treturn new_rate;\n\n\t \n\tif (is_frwd(port->serial->dev))\n\t\treturn new_rate;\n\n\t \n\tif (port->serial->dev->speed == USB_SPEED_LOW) {\n\t\t \n\t\tif (new_rate > 4800) {\n\t\t\tdev_dbg(&port->dev,\n\t\t\t\t\"%s - failed setting baud rate, device incapable speed %d\\n\",\n\t\t\t\t__func__, new_rate);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tswitch (priv->chiptype) {\n\tcase CT_EARTHMATE:\n\t\tif (new_rate <= 600) {\n\t\t\t \n\t\t\tdev_dbg(&port->dev,\n\t\t\t\t\"%s - failed setting baud rate, unsupported speed of %d on Earthmate GPS\\n\",\n\t\t\t\t__func__, new_rate);\n\t\t\treturn -1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn new_rate;\n}\n\n\n \nstatic int cypress_serial_control(struct tty_struct *tty,\n\tstruct usb_serial_port *port, speed_t baud_rate, int data_bits,\n\tint stop_bits, int parity_enable, int parity_type, int reset,\n\tint cypress_request_type)\n{\n\tint new_baudrate = 0, retval = 0, tries = 0;\n\tstruct cypress_private *priv;\n\tstruct device *dev = &port->dev;\n\tu8 *feature_buffer;\n\tconst unsigned int feature_len = 5;\n\tunsigned long flags;\n\n\tpriv = usb_get_serial_port_data(port);\n\n\tif (!priv->comm_is_ok)\n\t\treturn -ENODEV;\n\n\tfeature_buffer = kcalloc(feature_len, sizeof(u8), GFP_KERNEL);\n\tif (!feature_buffer)\n\t\treturn -ENOMEM;\n\n\tswitch (cypress_request_type) {\n\tcase CYPRESS_SET_CONFIG:\n\t\t \n\t\tnew_baudrate = priv->baud_rate;\n\t\tif (baud_rate && baud_rate != priv->baud_rate) {\n\t\t\tdev_dbg(dev, \"%s - baud rate is changing\\n\", __func__);\n\t\t\tretval = analyze_baud_rate(port, baud_rate);\n\t\t\tif (retval >= 0) {\n\t\t\t\tnew_baudrate = retval;\n\t\t\t\tdev_dbg(dev, \"%s - New baud rate set to %d\\n\",\n\t\t\t\t\t__func__, new_baudrate);\n\t\t\t}\n\t\t}\n\t\tdev_dbg(dev, \"%s - baud rate is being sent as %d\\n\", __func__,\n\t\t\tnew_baudrate);\n\n\t\t \n\t\tput_unaligned_le32(new_baudrate, feature_buffer);\n\t\tfeature_buffer[4] |= data_bits - 5;    \n\t\t \n\t\tfeature_buffer[4] |= (stop_bits << 3);    \n\t\tfeature_buffer[4] |= (parity_enable << 4);    \n\t\tfeature_buffer[4] |= (parity_type << 5);    \n\t\t \n\t\tfeature_buffer[4] |= (reset << 7);    \n\n\t\tdev_dbg(dev, \"%s - device is being sent this feature report:\\n\", __func__);\n\t\tdev_dbg(dev, \"%s - %02X - %02X - %02X - %02X - %02X\\n\", __func__,\n\t\t\tfeature_buffer[0], feature_buffer[1],\n\t\t\tfeature_buffer[2], feature_buffer[3],\n\t\t\tfeature_buffer[4]);\n\n\t\tdo {\n\t\t\tretval = usb_control_msg(port->serial->dev,\n\t\t\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t\t\tHID_REQ_SET_REPORT,\n\t\t\t\t\tUSB_DIR_OUT | USB_RECIP_INTERFACE | USB_TYPE_CLASS,\n\t\t\t\t\t0x0300, 0, feature_buffer,\n\t\t\t\t\tfeature_len, 500);\n\n\t\t\tif (tries++ >= 3)\n\t\t\t\tbreak;\n\n\t\t} while (retval != feature_len &&\n\t\t\t retval != -ENODEV);\n\n\t\tif (retval != feature_len) {\n\t\t\tdev_err(dev, \"%s - failed sending serial line settings - %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tcypress_set_dead(port);\n\t\t} else {\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\t\tpriv->baud_rate = new_baudrate;\n\t\t\tpriv->current_config = feature_buffer[4];\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t\t \n\t\t\tif (baud_rate)\n\t\t\t\ttty_encode_baud_rate(tty,\n\t\t\t\t\tnew_baudrate, new_baudrate);\n\t\t}\n\tbreak;\n\tcase CYPRESS_GET_CONFIG:\n\t\tif (priv->get_cfg_unsafe) {\n\t\t\t \n\t\t\tretval = -ENOTTY;\n\t\t\tgoto out;\n\t\t}\n\t\tdev_dbg(dev, \"%s - retrieving serial line settings\\n\", __func__);\n\t\tdo {\n\t\t\tretval = usb_control_msg(port->serial->dev,\n\t\t\t\t\tusb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\t\tHID_REQ_GET_REPORT,\n\t\t\t\t\tUSB_DIR_IN | USB_RECIP_INTERFACE | USB_TYPE_CLASS,\n\t\t\t\t\t0x0300, 0, feature_buffer,\n\t\t\t\t\tfeature_len, 500);\n\n\t\t\tif (tries++ >= 3)\n\t\t\t\tbreak;\n\t\t} while (retval != feature_len\n\t\t\t\t\t\t&& retval != -ENODEV);\n\n\t\tif (retval != feature_len) {\n\t\t\tdev_err(dev, \"%s - failed to retrieve serial line settings - %d\\n\",\n\t\t\t\t__func__, retval);\n\t\t\tcypress_set_dead(port);\n\t\t\tgoto out;\n\t\t} else {\n\t\t\tspin_lock_irqsave(&priv->lock, flags);\n\t\t\t \n\t\t\tpriv->current_config = feature_buffer[4];\n\t\t\tpriv->baud_rate = get_unaligned_le32(feature_buffer);\n\t\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\t}\n\t}\n\tspin_lock_irqsave(&priv->lock, flags);\n\t++priv->cmd_count;\n\tspin_unlock_irqrestore(&priv->lock, flags);\nout:\n\tkfree(feature_buffer);\n\treturn retval;\n}  \n\n\nstatic void cypress_set_dead(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (!priv->comm_is_ok) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn;\n\t}\n\tpriv->comm_is_ok = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_err(&port->dev, \"cypress_m8 suspending failing port %d - \"\n\t\t\"interval might be too short\\n\", port->port_number);\n}\n\n\n \n\n\nstatic int cypress_generic_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\n\tif (!port->interrupt_out_urb || !port->interrupt_in_urb) {\n\t\tdev_err(&port->dev, \"required endpoint is missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tpriv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->comm_is_ok = !0;\n\tspin_lock_init(&priv->lock);\n\tif (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) {\n\t\tkfree(priv);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tif (!is_frwd(serial->dev))\n\t\tusb_reset_configuration(serial->dev);\n\n\tpriv->cmd_ctrl = 0;\n\tpriv->line_control = 0;\n\tpriv->rx_flags = 0;\n\t \n\tif (port->interrupt_out_size > 9)\n\t\tpriv->pkt_fmt = packet_format_1;\n\telse\n\t\tpriv->pkt_fmt = packet_format_2;\n\n\tif (interval > 0) {\n\t\tpriv->write_urb_interval = interval;\n\t\tpriv->read_urb_interval = interval;\n\t\tdev_dbg(&port->dev, \"%s - read & write intervals forced to %d\\n\",\n\t\t\t__func__, interval);\n\t} else {\n\t\tpriv->write_urb_interval = port->interrupt_out_urb->interval;\n\t\tpriv->read_urb_interval = port->interrupt_in_urb->interval;\n\t\tdev_dbg(&port->dev, \"%s - intervals: read=%d write=%d\\n\",\n\t\t\t__func__, priv->read_urb_interval,\n\t\t\tpriv->write_urb_interval);\n\t}\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}\n\n\nstatic int cypress_earthmate_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct cypress_private *priv;\n\tint ret;\n\n\tret = cypress_generic_port_probe(port);\n\tif (ret) {\n\t\tdev_dbg(&port->dev, \"%s - Failed setting up port\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpriv = usb_get_serial_port_data(port);\n\tpriv->chiptype = CT_EARTHMATE;\n\t \n\tpriv->pkt_fmt = packet_format_1;\n\tif (serial->dev->descriptor.idProduct !=\n\t\t\t\tcpu_to_le16(PRODUCT_ID_EARTHMATEUSB)) {\n\t\t \n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - Marking this device as unsafe for GET_CONFIG commands\\n\",\n\t\t\t__func__);\n\t\tpriv->get_cfg_unsafe = !0;\n\t}\n\n\treturn 0;\n}\n\nstatic int cypress_hidcom_port_probe(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv;\n\tint ret;\n\n\tret = cypress_generic_port_probe(port);\n\tif (ret) {\n\t\tdev_dbg(&port->dev, \"%s - Failed setting up port\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpriv = usb_get_serial_port_data(port);\n\tpriv->chiptype = CT_CYPHIDCOM;\n\n\treturn 0;\n}\n\nstatic int cypress_ca42v2_port_probe(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv;\n\tint ret;\n\n\tret = cypress_generic_port_probe(port);\n\tif (ret) {\n\t\tdev_dbg(&port->dev, \"%s - Failed setting up port\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tpriv = usb_get_serial_port_data(port);\n\tpriv->chiptype = CT_CA42V2;\n\n\treturn 0;\n}\n\nstatic void cypress_port_remove(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\n\tkfifo_free(&priv->write_fifo);\n\tkfree(priv);\n}\n\nstatic int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tint result = 0;\n\n\tif (!priv->comm_is_ok)\n\t\treturn -EIO;\n\n\t \n\tusb_clear_halt(serial->dev, 0x81);\n\tusb_clear_halt(serial->dev, 0x02);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t \n\tpriv->bytes_in = 0;\n\tpriv->bytes_out = 0;\n\tpriv->cmd_count = 0;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tcypress_send(port);\n\n\tif (tty)\n\t\tcypress_set_termios(tty, port, NULL);\n\n\t \n\tusb_fill_int_urb(port->interrupt_in_urb, serial->dev,\n\t\tusb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),\n\t\tport->interrupt_in_urb->transfer_buffer,\n\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\tcypress_read_int_callback, port, priv->read_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\n\tif (result) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - failed submitting read urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tcypress_set_dead(port);\n\t}\n\n\treturn result;\n}  \n\nstatic void cypress_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\t \n\tspin_lock_irq(&priv->lock);\n\tif (on == 0)\n\t\tpriv->line_control = 0;\n\telse \n\t\tpriv->line_control = CONTROL_DTR | CONTROL_RTS;\n\tpriv->cmd_ctrl = 1;\n\tspin_unlock_irq(&priv->lock);\n\tcypress_write(NULL, port, NULL, 0);\n}\n\nstatic void cypress_close(struct usb_serial_port *port)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tkfifo_reset_out(&priv->write_fifo);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - stopping urbs\\n\", __func__);\n\tusb_kill_urb(port->interrupt_in_urb);\n\tusb_kill_urb(port->interrupt_out_urb);\n\n\tif (stats)\n\t\tdev_info(&port->dev, \"Statistics: %d Bytes In | %d Bytes Out | %d Commands Issued\\n\",\n\t\t\tpriv->bytes_in, priv->bytes_out, priv->cmd_count);\n}  \n\n\nstatic int cypress_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, int count)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\n\tdev_dbg(&port->dev, \"%s - %d bytes\\n\", __func__, count);\n\n\t \n\tif (priv->cmd_ctrl) {\n\t\tcount = 0;\n\t\tgoto finish;\n\t}\n\n\tif (!count)\n\t\treturn count;\n\n\tcount = kfifo_in_locked(&priv->write_fifo, buf, count, &priv->lock);\n\nfinish:\n\tcypress_send(port);\n\n\treturn count;\n}  \n\n\nstatic void cypress_send(struct usb_serial_port *port)\n{\n\tint count = 0, result, offset, actual_size;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned long flags;\n\n\tif (!priv->comm_is_ok)\n\t\treturn;\n\n\tdev_dbg(dev, \"%s - interrupt out size is %d\\n\", __func__,\n\t\tport->interrupt_out_size);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->write_urb_in_use) {\n\t\tdev_dbg(dev, \"%s - can't write, urb in use\\n\", __func__);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tmemset(port->interrupt_out_urb->transfer_buffer, 0,\n\t\t\t\t\t\tport->interrupt_out_size);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tswitch (priv->pkt_fmt) {\n\tdefault:\n\tcase packet_format_1:\n\t\t \n\t\toffset = 2;\n\t\tport->interrupt_out_buffer[0] = priv->line_control;\n\t\tbreak;\n\tcase packet_format_2:\n\t\t \n\t\toffset = 1;\n\t\tport->interrupt_out_buffer[0] = priv->line_control;\n\t\tbreak;\n\t}\n\n\tif (priv->line_control & CONTROL_RESET)\n\t\tpriv->line_control &= ~CONTROL_RESET;\n\n\tif (priv->cmd_ctrl) {\n\t\tpriv->cmd_count++;\n\t\tdev_dbg(dev, \"%s - line control command being issued\\n\", __func__);\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tgoto send;\n\t} else\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tcount = kfifo_out_locked(&priv->write_fifo,\n\t\t\t\t\t&port->interrupt_out_buffer[offset],\n\t\t\t\t\tport->interrupt_out_size - offset,\n\t\t\t\t\t&priv->lock);\n\tif (count == 0)\n\t\treturn;\n\n\tswitch (priv->pkt_fmt) {\n\tdefault:\n\tcase packet_format_1:\n\t\tport->interrupt_out_buffer[1] = count;\n\t\tbreak;\n\tcase packet_format_2:\n\t\tport->interrupt_out_buffer[0] |= count;\n\t}\n\n\tdev_dbg(dev, \"%s - count is %d\\n\", __func__, count);\n\nsend:\n\tspin_lock_irqsave(&priv->lock, flags);\n\tpriv->write_urb_in_use = 1;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (priv->cmd_ctrl)\n\t\tactual_size = 1;\n\telse\n\t\tactual_size = count +\n\t\t\t      (priv->pkt_fmt == packet_format_1 ? 2 : 1);\n\n\tusb_serial_debug_data(dev, __func__, port->interrupt_out_size,\n\t\t\t      port->interrupt_out_urb->transfer_buffer);\n\n\tusb_fill_int_urb(port->interrupt_out_urb, port->serial->dev,\n\t\tusb_sndintpipe(port->serial->dev, port->interrupt_out_endpointAddress),\n\t\tport->interrupt_out_buffer, actual_size,\n\t\tcypress_write_int_callback, port, priv->write_urb_interval);\n\tresult = usb_submit_urb(port->interrupt_out_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tdev_err_console(port,\n\t\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tpriv->write_urb_in_use = 0;\n\t\tcypress_set_dead(port);\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->cmd_ctrl)\n\t\tpriv->cmd_ctrl = 0;\n\n\t \n\tpriv->bytes_out += count;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tusb_serial_port_softint(port);\n}  \n\n\n \nstatic unsigned int cypress_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned int room;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\troom = kfifo_avail(&priv->write_fifo);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, room);\n\treturn room;\n}\n\n\nstatic int cypress_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\t__u8 status, control;\n\tunsigned int result = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol = priv->line_control;\n\tstatus = priv->current_status;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tresult = ((control & CONTROL_DTR)        ? TIOCM_DTR : 0)\n\t\t| ((control & CONTROL_RTS)       ? TIOCM_RTS : 0)\n\t\t| ((status & UART_CTS)        ? TIOCM_CTS : 0)\n\t\t| ((status & UART_DSR)        ? TIOCM_DSR : 0)\n\t\t| ((status & UART_RI)         ? TIOCM_RI  : 0)\n\t\t| ((status & UART_CD)         ? TIOCM_CD  : 0);\n\n\tdev_dbg(&port->dev, \"%s - result = %x\\n\", __func__, result);\n\n\treturn result;\n}\n\n\nstatic int cypress_tiocmset(struct tty_struct *tty,\n\t\t\t       unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (set & TIOCM_RTS)\n\t\tpriv->line_control |= CONTROL_RTS;\n\tif (set & TIOCM_DTR)\n\t\tpriv->line_control |= CONTROL_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tpriv->line_control &= ~CONTROL_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tpriv->line_control &= ~CONTROL_DTR;\n\tpriv->cmd_ctrl = 1;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\treturn cypress_write(tty, port, NULL, 0);\n}\n\nstatic void cypress_earthmate_init_termios(struct tty_struct *tty)\n{\n\ttty_encode_baud_rate(tty, 4800, 4800);\n}\n\nstatic void cypress_set_termios(struct tty_struct *tty,\n\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\tconst struct ktermios *old_termios)\n{\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tint data_bits, stop_bits, parity_type, parity_enable;\n\tunsigned int cflag;\n\tunsigned long flags;\n\t__u8 oldlines;\n\tint linechange = 0;\n\n\t \n\ttty->termios.c_cflag &= ~(CMSPAR|CRTSCTS);\n\n\tcflag = tty->termios.c_cflag;\n\n\t \n\t \n\n\t \n\tstop_bits = cflag & CSTOPB ? 1 : 0;\n\n\tif (cflag & PARENB) {\n\t\tparity_enable = 1;\n\t\t \n\t\tparity_type = cflag & PARODD ? 1 : 0;\n\t} else\n\t\tparity_enable = parity_type = 0;\n\n\tdata_bits = tty_get_char_size(cflag);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\toldlines = priv->line_control;\n\tif ((cflag & CBAUD) == B0) {\n\t\t \n\t\tdev_dbg(dev, \"%s - dropping the lines, baud rate 0bps\\n\", __func__);\n\t\tpriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\n\t} else\n\t\tpriv->line_control = (CONTROL_DTR | CONTROL_RTS);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(dev, \"%s - sending %d stop_bits, %d parity_enable, %d parity_type, %d data_bits (+5)\\n\",\n\t\t__func__, stop_bits, parity_enable, parity_type, data_bits);\n\n\tcypress_serial_control(tty, port, tty_get_baud_rate(tty),\n\t\t\tdata_bits, stop_bits,\n\t\t\tparity_enable, parity_type,\n\t\t\t0, CYPRESS_SET_CONFIG);\n\n\t \n\tcypress_serial_control(tty, port, 0, 0, 0, 0, 0, 0, CYPRESS_GET_CONFIG);\n\n\t \n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->chiptype == CT_EARTHMATE && priv->baud_rate == 4800) {\n\t\tdev_dbg(dev, \"Using custom termios settings for a baud rate of 4800bps.\\n\");\n\t\t \n\n\t\ttty->termios.c_iflag  \n\t\t\t&= ~(IGNBRK   \n\t\t\t| BRKINT      \n\t\t\t| PARMRK      \n\t\t\t| ISTRIP      \n\t\t\t| INLCR       \n\t\t\t| IGNCR       \n\t\t\t| ICRNL       \n\t\t\t| IXON);      \n\n\t\ttty->termios.c_oflag  \n\t\t\t&= ~OPOST;     \n\n\t\ttty->termios.c_lflag  \n\t\t\t&= ~(ECHO      \n\t\t\t| ECHONL       \n\t\t\t| ICANON       \n\t\t\t| ISIG         \n\t\t\t| IEXTEN);     \n\t}  \n\n\tlinechange = (priv->line_control != oldlines);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tif (linechange) {\n\t\tpriv->cmd_ctrl = 1;\n\t\tcypress_write(tty, port, NULL, 0);\n\t}\n}  \n\n\n \nstatic unsigned int cypress_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tunsigned int chars;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tchars = kfifo_len(&priv->write_fifo);\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - returns %u\\n\", __func__, chars);\n\treturn chars;\n}\n\n\nstatic void cypress_throttle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\n\tspin_lock_irq(&priv->lock);\n\tpriv->rx_flags = THROTTLED;\n\tspin_unlock_irq(&priv->lock);\n}\n\n\nstatic void cypress_unthrottle(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tint actually_throttled, result;\n\n\tspin_lock_irq(&priv->lock);\n\tactually_throttled = priv->rx_flags & ACTUALLY_THROTTLED;\n\tpriv->rx_flags = 0;\n\tspin_unlock_irq(&priv->lock);\n\n\tif (!priv->comm_is_ok)\n\t\treturn;\n\n\tif (actually_throttled) {\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result) {\n\t\t\tdev_err(&port->dev, \"%s - failed submitting read urb, \"\n\t\t\t\t\t\"error %d\\n\", __func__, result);\n\t\t\tcypress_set_dead(port);\n\t\t}\n\t}\n}\n\n\nstatic void cypress_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &urb->dev->dev;\n\tstruct tty_struct *tty;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned long flags;\n\tchar tty_flag = TTY_NORMAL;\n\tint bytes = 0;\n\tint result;\n\tint i = 0;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:  \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\treturn;\n\tcase -EPIPE:\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tdev_err(dev, \"%s - unexpected nonzero read status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tcypress_set_dead(port);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->rx_flags & THROTTLED) {\n\t\tdev_dbg(dev, \"%s - now throttling\\n\", __func__);\n\t\tpriv->rx_flags |= ACTUALLY_THROTTLED;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\ttty = tty_port_tty_get(&port->port);\n\tif (!tty) {\n\t\tdev_dbg(dev, \"%s - bad tty pointer - exiting\\n\", __func__);\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tresult = urb->actual_length;\n\tswitch (priv->pkt_fmt) {\n\tdefault:\n\tcase packet_format_1:\n\t\t \n\t\tpriv->current_status = data[0] & 0xF8;\n\t\tbytes = data[1] + 2;\n\t\ti = 2;\n\t\tbreak;\n\tcase packet_format_2:\n\t\t \n\t\tpriv->current_status = data[0] & 0xF8;\n\t\tbytes = (data[0] & 0x07) + 1;\n\t\ti = 1;\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\tif (result < bytes) {\n\t\tdev_dbg(dev,\n\t\t\t\"%s - wrong packet size - received %d bytes but packet said %d bytes\\n\",\n\t\t\t__func__, result, bytes);\n\t\tgoto continue_read;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length, data);\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t \n\tif (priv->current_status != priv->prev_status) {\n\t\tu8 delta = priv->current_status ^ priv->prev_status;\n\n\t\tif (delta & UART_MSR_MASK) {\n\t\t\tif (delta & UART_CTS)\n\t\t\t\tport->icount.cts++;\n\t\t\tif (delta & UART_DSR)\n\t\t\t\tport->icount.dsr++;\n\t\t\tif (delta & UART_RI)\n\t\t\t\tport->icount.rng++;\n\t\t\tif (delta & UART_CD)\n\t\t\t\tport->icount.dcd++;\n\n\t\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t\t}\n\n\t\tpriv->prev_status = priv->current_status;\n\t}\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tif (tty && !C_CLOCAL(tty) && !(priv->current_status & UART_CD)) {\n\t\tdev_dbg(dev, \"%s - calling hangup\\n\", __func__);\n\t\ttty_hangup(tty);\n\t\tgoto continue_read;\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (priv->current_status & CYP_ERROR) {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\ttty_flag = TTY_PARITY;\n\t\tdev_dbg(dev, \"%s - Parity Error detected\\n\", __func__);\n\t} else\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\t \n\tif (bytes > i) {\n\t\ttty_insert_flip_string_fixed_flag(&port->port, data + i,\n\t\t\t\ttty_flag, bytes - i);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\t \n\tpriv->bytes_in += bytes;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\ncontinue_read:\n\ttty_kref_put(tty);\n\n\t \n\n\tif (priv->comm_is_ok) {\n\t\tusb_fill_int_urb(port->interrupt_in_urb, port->serial->dev,\n\t\t\t\tusb_rcvintpipe(port->serial->dev,\n\t\t\t\t\tport->interrupt_in_endpointAddress),\n\t\t\t\tport->interrupt_in_urb->transfer_buffer,\n\t\t\t\tport->interrupt_in_urb->transfer_buffer_length,\n\t\t\t\tcypress_read_int_callback, port,\n\t\t\t\tpriv->read_urb_interval);\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\t\tif (result && result != -EPERM) {\n\t\t\tdev_err(dev, \"%s - failed resubmitting read urb, error %d\\n\",\n\t\t\t\t__func__, result);\n\t\t\tcypress_set_dead(port);\n\t\t}\n\t}\n}  \n\n\nstatic void cypress_write_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct cypress_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &urb->dev->dev;\n\tint status = urb->status;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\tpriv->write_urb_in_use = 0;\n\t\treturn;\n\tcase -EPIPE:\n\t\t \n\t\tfallthrough;\n\tdefault:\n\t\tdev_err(dev, \"%s - unexpected nonzero write status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tcypress_set_dead(port);\n\t\tbreak;\n\t}\n\tpriv->write_urb_in_use = 0;\n\n\t \n\tcypress_send(port);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(stats, bool, 0644);\nMODULE_PARM_DESC(stats, \"Enable statistics or not\");\nmodule_param(interval, int, 0644);\nMODULE_PARM_DESC(interval, \"Overrides interrupt interval\");\nmodule_param(unstable_bauds, bool, 0644);\nMODULE_PARM_DESC(unstable_bauds, \"Allow unstable baud rates\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}