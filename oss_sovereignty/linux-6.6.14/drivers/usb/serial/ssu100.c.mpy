{
  "module_name": "ssu100.c",
  "hash_id": "4e5deaded9a7319385c9b9612ae363e5a444d47a949da25b1d4332c26907df1c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ssu100.c",
  "human_readable_source": "\n \n\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/serial_reg.h>\n#include <linux/uaccess.h>\n\n#define QT_OPEN_CLOSE_CHANNEL       0xca\n#define QT_SET_GET_DEVICE           0xc2\n#define QT_SET_GET_REGISTER         0xc0\n#define QT_GET_SET_PREBUF_TRIG_LVL  0xcc\n#define QT_SET_ATF                  0xcd\n#define QT_GET_SET_UART             0xc1\n#define QT_TRANSFER_IN              0xc0\n#define QT_HW_FLOW_CONTROL_MASK     0xc5\n#define QT_SW_FLOW_CONTROL_MASK     0xc6\n\n#define  SERIAL_MSR_MASK            0xf0\n\n#define  SERIAL_CRTSCTS ((UART_MCR_RTS << 8) | UART_MSR_CTS)\n\n#define  SERIAL_EVEN_PARITY         (UART_LCR_PARITY | UART_LCR_EPAR)\n\n#define  MAX_BAUD_RATE              460800\n\n#define ATC_DISABLED                0x00\n#define DUPMODE_BITS        0xc0\n#define RR_BITS             0x03\n#define LOOPMODE_BITS       0x41\n#define RS232_MODE          0x00\n#define RTSCTS_TO_CONNECTOR 0x40\n#define CLKS_X4             0x02\n#define FULLPWRBIT          0x00000080\n#define NEXT_BOARD_POWER_BIT        0x00000004\n\n#define DRIVER_DESC \"Quatech SSU-100 USB to Serial Driver\"\n\n#define\tUSB_VENDOR_ID_QUATECH\t0x061d\t \n#define QUATECH_SSU100\t0xC020\t \n\nstatic const struct usb_device_id id_table[] = {\n\t{USB_DEVICE(USB_VENDOR_ID_QUATECH, QUATECH_SSU100)},\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct ssu100_port_private {\n\tspinlock_t status_lock;\n\tu8 shadowLSR;\n\tu8 shadowMSR;\n};\n\nstatic inline int ssu100_control_msg(struct usb_device *dev,\n\t\t\t\t     u8 request, u16 data, u16 index)\n{\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t       request, 0x40, data, index,\n\t\t\t       NULL, 0, 300);\n}\n\nstatic inline int ssu100_setdevice(struct usb_device *dev, u8 *data)\n{\n\tu16 x = ((u16)(data[1] << 8) | (u16)(data[0]));\n\n\treturn ssu100_control_msg(dev, QT_SET_GET_DEVICE, x, 0);\n}\n\n\nstatic inline int ssu100_getdevice(struct usb_device *dev, u8 *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      QT_SET_GET_DEVICE, 0xc0, 0, 0,\n\t\t\t      data, 3, 300);\n\tif (ret < 3) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\nstatic inline int ssu100_getregister(struct usb_device *dev,\n\t\t\t\t     unsigned short uart,\n\t\t\t\t     unsigned short reg,\n\t\t\t\t     u8 *data)\n{\n\tint ret;\n\n\tret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t      QT_SET_GET_REGISTER, 0xc0, reg,\n\t\t\t      uart, data, sizeof(*data), 300);\n\tif (ret < (int)sizeof(*data)) {\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t}\n\n\treturn ret;\n}\n\n\nstatic inline int ssu100_setregister(struct usb_device *dev,\n\t\t\t\t     unsigned short uart,\n\t\t\t\t     unsigned short reg,\n\t\t\t\t     u16 data)\n{\n\tu16 value = (data << 8) | reg;\n\n\treturn usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t       QT_SET_GET_REGISTER, 0x40, value, uart,\n\t\t\t       NULL, 0, 300);\n\n}\n\n#define set_mctrl(dev, set)\t\tupdate_mctrl((dev), (set), 0)\n#define clear_mctrl(dev, clear)\tupdate_mctrl((dev), 0, (clear))\n\n \nstatic inline int update_mctrl(struct usb_device *dev, unsigned int set,\n\t\t\t       unsigned int clear)\n{\n\tunsigned urb_value;\n\tint result;\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\n\t\tdev_dbg(&dev->dev, \"%s - DTR|RTS not being set|cleared\\n\", __func__);\n\t\treturn 0;\t \n\t}\n\n\tclear &= ~set;\t \n\turb_value = 0;\n\tif (set & TIOCM_DTR)\n\t\turb_value |= UART_MCR_DTR;\n\tif (set & TIOCM_RTS)\n\t\turb_value |= UART_MCR_RTS;\n\n\tresult = ssu100_setregister(dev, 0, UART_MCR, urb_value);\n\tif (result < 0)\n\t\tdev_dbg(&dev->dev, \"%s Error from MODEM_CTRL urb\\n\", __func__);\n\n\treturn result;\n}\n\nstatic int ssu100_initdevice(struct usb_device *dev)\n{\n\tu8 *data;\n\tint result = 0;\n\n\tdata = kzalloc(3, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tresult = ssu100_getdevice(dev, data);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - get_device failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\n\tdata[1] &= ~FULLPWRBIT;\n\n\tresult = ssu100_setdevice(dev, data);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - setdevice failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = ssu100_control_msg(dev, QT_GET_SET_PREBUF_TRIG_LVL, 128, 0);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - set prebuffer level failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = ssu100_control_msg(dev, QT_SET_ATF, ATC_DISABLED, 0);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - set ATFprebuffer level failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\n\tresult = ssu100_getdevice(dev, data);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - get_device failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\n\tdata[0] &= ~(RR_BITS | DUPMODE_BITS);\n\tdata[0] |= CLKS_X4;\n\tdata[1] &= ~(LOOPMODE_BITS);\n\tdata[1] |= RS232_MODE;\n\n\tresult = ssu100_setdevice(dev, data);\n\tif (result < 0) {\n\t\tdev_dbg(&dev->dev, \"%s - setdevice failed %i\\n\", __func__, result);\n\t\tgoto out;\n\t}\n\nout:\tkfree(data);\n\treturn result;\n\n}\n\n\nstatic void ssu100_set_termios(struct tty_struct *tty,\n\t\t               struct usb_serial_port *port,\n\t\t               const struct ktermios *old_termios)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct ktermios *termios = &tty->termios;\n\tu16 baud, divisor, remainder;\n\tunsigned int cflag = termios->c_cflag;\n\tu16 urb_value = 0;  \n\tint result;\n\n\tif (cflag & PARENB) {\n\t\tif (cflag & PARODD)\n\t\t\turb_value |= UART_LCR_PARITY;\n\t\telse\n\t\t\turb_value |= SERIAL_EVEN_PARITY;\n\t}\n\n\turb_value |= UART_LCR_WLEN(tty_get_char_size(cflag));\n\n\tbaud = tty_get_baud_rate(tty);\n\tif (!baud)\n\t\tbaud = 9600;\n\n\tdev_dbg(&port->dev, \"%s - got baud = %d\\n\", __func__, baud);\n\n\n\tdivisor = MAX_BAUD_RATE / baud;\n\tremainder = MAX_BAUD_RATE % baud;\n\tif (((remainder * 2) >= baud) && (baud != 110))\n\t\tdivisor++;\n\n\turb_value = urb_value << 8;\n\n\tresult = ssu100_control_msg(dev, QT_GET_SET_UART, divisor, urb_value);\n\tif (result < 0)\n\t\tdev_dbg(&port->dev, \"%s - set uart failed\\n\", __func__);\n\n\tif (cflag & CRTSCTS)\n\t\tresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\n\t\t\t\t\t    SERIAL_CRTSCTS, 0);\n\telse\n\t\tresult = ssu100_control_msg(dev, QT_HW_FLOW_CONTROL_MASK,\n\t\t\t\t\t    0, 0);\n\tif (result < 0)\n\t\tdev_dbg(&port->dev, \"%s - set HW flow control failed\\n\", __func__);\n\n\tif (I_IXOFF(tty) || I_IXON(tty)) {\n\t\tu16 x = ((u16)(START_CHAR(tty) << 8) | (u16)(STOP_CHAR(tty)));\n\n\t\tresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\n\t\t\t\t\t    x, 0);\n\t} else\n\t\tresult = ssu100_control_msg(dev, QT_SW_FLOW_CONTROL_MASK,\n\t\t\t\t\t    0, 0);\n\n\tif (result < 0)\n\t\tdev_dbg(&port->dev, \"%s - set SW flow control failed\\n\", __func__);\n\n}\n\n\nstatic int ssu100_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\n\tu8 *data;\n\tint result;\n\tunsigned long flags;\n\n\tdata = kzalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tresult = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t\t QT_OPEN_CLOSE_CHANNEL,\n\t\t\t\t QT_TRANSFER_IN, 0x01,\n\t\t\t\t 0, data, 2, 300);\n\tif (result < 2) {\n\t\tdev_dbg(&port->dev, \"%s - open failed %i\\n\", __func__, result);\n\t\tif (result >= 0)\n\t\t\tresult = -EIO;\n\t\tkfree(data);\n\t\treturn result;\n\t}\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tpriv->shadowLSR = data[0];\n\tpriv->shadowMSR = data[1];\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\tkfree(data);\n\n \n\tresult = ssu100_control_msg(dev, QT_GET_SET_UART, 0x30, 0x0300);\n\tif (result < 0)\n\t\tdev_dbg(&port->dev, \"%s - set uart failed\\n\", __func__);\n\n\tif (tty)\n\t\tssu100_set_termios(tty, port, &tty->termios);\n\n\treturn usb_serial_generic_open(tty, port);\n}\n\nstatic int ssu100_attach(struct usb_serial *serial)\n{\n\treturn ssu100_initdevice(serial->dev);\n}\n\nstatic int ssu100_port_probe(struct usb_serial_port *port)\n{\n\tstruct ssu100_port_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->status_lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\nstatic void ssu100_port_remove(struct usb_serial_port *port)\n{\n\tstruct ssu100_port_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic int ssu100_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_device *dev = port->serial->dev;\n\tu8 *d;\n\tint r;\n\n\td = kzalloc(2, GFP_KERNEL);\n\tif (!d)\n\t\treturn -ENOMEM;\n\n\tr = ssu100_getregister(dev, 0, UART_MCR, d);\n\tif (r < 0)\n\t\tgoto mget_out;\n\n\tr = ssu100_getregister(dev, 0, UART_MSR, d+1);\n\tif (r < 0)\n\t\tgoto mget_out;\n\n\tr = (d[0] & UART_MCR_DTR ? TIOCM_DTR : 0) |\n\t\t(d[0] & UART_MCR_RTS ? TIOCM_RTS : 0) |\n\t\t(d[1] & UART_MSR_CTS ? TIOCM_CTS : 0) |\n\t\t(d[1] & UART_MSR_DCD ? TIOCM_CAR : 0) |\n\t\t(d[1] & UART_MSR_RI ? TIOCM_RI : 0) |\n\t\t(d[1] & UART_MSR_DSR ? TIOCM_DSR : 0);\n\nmget_out:\n\tkfree(d);\n\treturn r;\n}\n\nstatic int ssu100_tiocmset(struct tty_struct *tty,\n\t\t\t   unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_device *dev = port->serial->dev;\n\n\treturn update_mctrl(dev, set, clear);\n}\n\nstatic void ssu100_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\n\t \n\tif (!on) {\n\t\tif (ssu100_setregister(dev, 0, UART_MCR, 0) < 0)\n\t\t\tdev_err(&port->dev, \"error from flowcontrol urb\\n\");\n\t}\n\t \n\tif (on)\n\t\tset_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\n\telse\n\t\tclear_mctrl(dev, TIOCM_DTR | TIOCM_RTS);\n}\n\nstatic void ssu100_update_msr(struct usb_serial_port *port, u8 msr)\n{\n\tstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tpriv->shadowMSR = msr;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\tif (msr & UART_MSR_ANY_DELTA) {\n\t\t \n\t\tif (msr & UART_MSR_DCTS)\n\t\t\tport->icount.cts++;\n\t\tif (msr & UART_MSR_DDSR)\n\t\t\tport->icount.dsr++;\n\t\tif (msr & UART_MSR_DDCD)\n\t\t\tport->icount.dcd++;\n\t\tif (msr & UART_MSR_TERI)\n\t\t\tport->icount.rng++;\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t}\n}\n\nstatic void ssu100_update_lsr(struct usb_serial_port *port, u8 lsr,\n\t\t\t      char *tty_flag)\n{\n\tstruct ssu100_port_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&priv->status_lock, flags);\n\tpriv->shadowLSR = lsr;\n\tspin_unlock_irqrestore(&priv->status_lock, flags);\n\n\t*tty_flag = TTY_NORMAL;\n\tif (lsr & UART_LSR_BRK_ERROR_BITS) {\n\t\t \n\t\tif (lsr & UART_LSR_BI) {\n\t\t\tport->icount.brk++;\n\t\t\t*tty_flag = TTY_BREAK;\n\t\t\tusb_serial_handle_break(port);\n\t\t}\n\t\tif (lsr & UART_LSR_PE) {\n\t\t\tport->icount.parity++;\n\t\t\tif (*tty_flag == TTY_NORMAL)\n\t\t\t\t*tty_flag = TTY_PARITY;\n\t\t}\n\t\tif (lsr & UART_LSR_FE) {\n\t\t\tport->icount.frame++;\n\t\t\tif (*tty_flag == TTY_NORMAL)\n\t\t\t\t*tty_flag = TTY_FRAME;\n\t\t}\n\t\tif (lsr & UART_LSR_OE) {\n\t\t\tport->icount.overrun++;\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t\t}\n\t}\n\n}\n\nstatic void ssu100_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tchar *packet = urb->transfer_buffer;\n\tchar flag = TTY_NORMAL;\n\tu32 len = urb->actual_length;\n\tint i;\n\tchar *ch;\n\n\tif ((len >= 4) &&\n\t    (packet[0] == 0x1b) && (packet[1] == 0x1b) &&\n\t    ((packet[2] == 0x00) || (packet[2] == 0x01))) {\n\t\tif (packet[2] == 0x00)\n\t\t\tssu100_update_lsr(port, packet[3], &flag);\n\t\tif (packet[2] == 0x01)\n\t\t\tssu100_update_msr(port, packet[3]);\n\n\t\tlen -= 4;\n\t\tch = packet + 4;\n\t} else\n\t\tch = packet;\n\n\tif (!len)\n\t\treturn;\t \n\n\tif (port->sysrq) {\n\t\tfor (i = 0; i < len; i++, ch++) {\n\t\t\tif (!usb_serial_handle_sysrq_char(port, *ch))\n\t\t\t\ttty_insert_flip_char(&port->port, *ch, flag);\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string_fixed_flag(&port->port, ch, flag, len);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic struct usb_serial_driver ssu100_device = {\n\t.driver = {\n\t\t.owner = THIS_MODULE,\n\t\t.name = \"ssu100\",\n\t},\n\t.description\t     = DRIVER_DESC,\n\t.id_table\t     = id_table,\n\t.num_ports\t     = 1,\n\t.open\t\t     = ssu100_open,\n\t.attach              = ssu100_attach,\n\t.port_probe          = ssu100_port_probe,\n\t.port_remove         = ssu100_port_remove,\n\t.dtr_rts             = ssu100_dtr_rts,\n\t.process_read_urb    = ssu100_process_read_urb,\n\t.tiocmget            = ssu100_tiocmget,\n\t.tiocmset            = ssu100_tiocmset,\n\t.tiocmiwait          = usb_serial_generic_tiocmiwait,\n\t.get_icount\t     = usb_serial_generic_get_icount,\n\t.set_termios         = ssu100_set_termios,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ssu100_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}