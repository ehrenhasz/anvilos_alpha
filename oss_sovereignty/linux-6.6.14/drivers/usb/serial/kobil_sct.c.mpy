{
  "module_name": "kobil_sct.c",
  "hash_id": "9507794bcd3d078a561142030d446a4b08fe2d2e77c506e1ddbf96a4da72387a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/kobil_sct.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/ioctl.h>\n#include \"kobil_sct.h\"\n\n#define DRIVER_AUTHOR \"KOBIL Systems GmbH - http://www.kobil.com\"\n#define DRIVER_DESC \"KOBIL USB Smart Card Terminal Driver (experimental)\"\n\n#define KOBIL_VENDOR_ID\t\t\t0x0D46\n#define KOBIL_ADAPTER_B_PRODUCT_ID\t0x2011\n#define KOBIL_ADAPTER_K_PRODUCT_ID\t0x2012\n#define KOBIL_USBTWIN_PRODUCT_ID\t0x0078\n#define KOBIL_KAAN_SIM_PRODUCT_ID       0x0081\n\n#define KOBIL_TIMEOUT\t\t500\n#define KOBIL_BUF_LENGTH\t300\n\n\n \nstatic int kobil_port_probe(struct usb_serial_port *probe);\nstatic void kobil_port_remove(struct usb_serial_port *probe);\nstatic int  kobil_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void kobil_close(struct usb_serial_port *port);\nstatic int  kobil_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t const unsigned char *buf, int count);\nstatic unsigned int kobil_write_room(struct tty_struct *tty);\nstatic int  kobil_ioctl(struct tty_struct *tty,\n\t\t\tunsigned int cmd, unsigned long arg);\nstatic int  kobil_tiocmget(struct tty_struct *tty);\nstatic int  kobil_tiocmset(struct tty_struct *tty,\n\t\t\t   unsigned int set, unsigned int clear);\nstatic void kobil_read_int_callback(struct urb *urb);\nstatic void kobil_write_int_callback(struct urb *urb);\nstatic void kobil_set_termios(struct tty_struct *tty,\n\t\t\t      struct usb_serial_port *port,\n\t\t\t      const struct ktermios *old);\nstatic void kobil_init_termios(struct tty_struct *tty);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(KOBIL_VENDOR_ID, KOBIL_ADAPTER_B_PRODUCT_ID) },\n\t{ USB_DEVICE(KOBIL_VENDOR_ID, KOBIL_ADAPTER_K_PRODUCT_ID) },\n\t{ USB_DEVICE(KOBIL_VENDOR_ID, KOBIL_USBTWIN_PRODUCT_ID) },\n\t{ USB_DEVICE(KOBIL_VENDOR_ID, KOBIL_KAAN_SIM_PRODUCT_ID) },\n\t{ }\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver kobil_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"kobil\",\n\t},\n\t.description =\t\t\"KOBIL USB smart card terminal\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.num_interrupt_out =\t1,\n\t.port_probe =\t\tkobil_port_probe,\n\t.port_remove =\t\tkobil_port_remove,\n\t.ioctl =\t\tkobil_ioctl,\n\t.set_termios =\t\tkobil_set_termios,\n\t.init_termios =\t\tkobil_init_termios,\n\t.tiocmget =\t\tkobil_tiocmget,\n\t.tiocmset =\t\tkobil_tiocmset,\n\t.open =\t\t\tkobil_open,\n\t.close =\t\tkobil_close,\n\t.write =\t\tkobil_write,\n\t.write_room =\t\tkobil_write_room,\n\t.read_int_callback =\tkobil_read_int_callback,\n\t.write_int_callback =\tkobil_write_int_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&kobil_device, NULL\n};\n\nstruct kobil_private {\n\tunsigned char buf[KOBIL_BUF_LENGTH];  \n\tint filled;   \n\tint cur_pos;  \n\t__u16 device_type;\n};\n\n\nstatic int kobil_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct kobil_private *priv;\n\n\tpriv = kmalloc(sizeof(struct kobil_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tpriv->filled = 0;\n\tpriv->cur_pos = 0;\n\tpriv->device_type = le16_to_cpu(serial->dev->descriptor.idProduct);\n\n\tswitch (priv->device_type) {\n\tcase KOBIL_ADAPTER_B_PRODUCT_ID:\n\t\tdev_dbg(&serial->dev->dev, \"KOBIL B1 PRO / KAAN PRO detected\\n\");\n\t\tbreak;\n\tcase KOBIL_ADAPTER_K_PRODUCT_ID:\n\t\tdev_dbg(&serial->dev->dev, \"KOBIL KAAN Standard Plus / SecOVID Reader Plus detected\\n\");\n\t\tbreak;\n\tcase KOBIL_USBTWIN_PRODUCT_ID:\n\t\tdev_dbg(&serial->dev->dev, \"KOBIL USBTWIN detected\\n\");\n\t\tbreak;\n\tcase KOBIL_KAAN_SIM_PRODUCT_ID:\n\t\tdev_dbg(&serial->dev->dev, \"KOBIL KAAN SIM detected\\n\");\n\t\tbreak;\n\t}\n\tusb_set_serial_port_data(port, priv);\n\n\treturn 0;\n}\n\n\nstatic void kobil_port_remove(struct usb_serial_port *port)\n{\n\tstruct kobil_private *priv;\n\n\tpriv = usb_get_serial_port_data(port);\n\tkfree(priv);\n}\n\nstatic void kobil_init_termios(struct tty_struct *tty)\n{\n\t \n\ttty->termios.c_lflag = 0;\n\ttty->termios.c_iflag &= ~(ISIG | ICANON | ECHO | IEXTEN | XCASE);\n\ttty->termios.c_iflag |= IGNBRK | IGNPAR | IXOFF;\n\t \n\ttty->termios.c_oflag &= ~ONLCR;\n}\n\nstatic int kobil_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct device *dev = &port->dev;\n\tint result = 0;\n\tstruct kobil_private *priv;\n\tunsigned char *transfer_buffer;\n\tint transfer_buffer_length = 8;\n\n\tpriv = usb_get_serial_port_data(port);\n\n\t \n\ttransfer_buffer = kzalloc(transfer_buffer_length, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_GetMisc,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_IN,\n\t\t\t  SUSBCR_MSC_GetHWVersion,\n\t\t\t  0,\n\t\t\t  transfer_buffer,\n\t\t\t  transfer_buffer_length,\n\t\t\t  KOBIL_TIMEOUT\n\t);\n\tdev_dbg(dev, \"%s - Send get_HW_version URB returns: %i\\n\", __func__, result);\n\tif (result >= 3) {\n\t\tdev_dbg(dev, \"Hardware version: %i.%i.%i\\n\", transfer_buffer[0],\n\t\t\t\ttransfer_buffer[1], transfer_buffer[2]);\n\t}\n\n\t \n\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_GetMisc,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_IN,\n\t\t\t  SUSBCR_MSC_GetFWVersion,\n\t\t\t  0,\n\t\t\t  transfer_buffer,\n\t\t\t  transfer_buffer_length,\n\t\t\t  KOBIL_TIMEOUT\n\t);\n\tdev_dbg(dev, \"%s - Send get_FW_version URB returns: %i\\n\", __func__, result);\n\tif (result >= 3) {\n\t\tdev_dbg(dev, \"Firmware version: %i.%i.%i\\n\", transfer_buffer[0],\n\t\t\t\ttransfer_buffer[1], transfer_buffer[2]);\n\t}\n\n\tif (priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID ||\n\t\t\tpriv->device_type == KOBIL_ADAPTER_K_PRODUCT_ID) {\n\t\t \n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_SetBaudRateParityAndStopBits,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t  SUSBCR_SBR_9600 | SUSBCR_SPASB_EvenParity |\n\t\t\t\t\t\t\tSUSBCR_SPASB_1StopBit,\n\t\t\t  0,\n\t\t\t  NULL,\n\t\t\t  0,\n\t\t\t  KOBIL_TIMEOUT\n\t\t);\n\t\tdev_dbg(dev, \"%s - Send set_baudrate URB returns: %i\\n\", __func__, result);\n\n\t\t \n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_Misc,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t  SUSBCR_MSC_ResetAllQueues,\n\t\t\t  0,\n\t\t\t  NULL,\n\t\t\t  0,\n\t\t\t  KOBIL_TIMEOUT\n\t\t);\n\t\tdev_dbg(dev, \"%s - Send reset_all_queues URB returns: %i\\n\", __func__, result);\n\t}\n\tif (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID ||\n\t    priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID ||\n\t    priv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID) {\n\t\t \n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tdev_dbg(dev, \"%s - Send read URB returns: %i\\n\", __func__, result);\n\t}\n\n\tkfree(transfer_buffer);\n\treturn 0;\n}\n\n\nstatic void kobil_close(struct usb_serial_port *port)\n{\n\t \n\tusb_kill_urb(port->interrupt_out_urb);\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\n\nstatic void kobil_read_int_callback(struct urb *urb)\n{\n\tint result;\n\tstruct usb_serial_port *port = urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - Read int status not zero: %d\\n\", __func__, status);\n\t\treturn;\n\t}\n\n\tif (urb->actual_length) {\n\t\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\n\t\t\t\t\t\t\t\t\tdata);\n\t\ttty_insert_flip_string(&port->port, data, urb->actual_length);\n\t\ttty_flip_buffer_push(&port->port);\n\t}\n\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_ATOMIC);\n\tdev_dbg(&port->dev, \"%s - Send read URB returns: %i\\n\", __func__, result);\n}\n\n\nstatic void kobil_write_int_callback(struct urb *urb)\n{\n}\n\n\nstatic int kobil_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\tconst unsigned char *buf, int count)\n{\n\tint length = 0;\n\tint result = 0;\n\tint todo = 0;\n\tstruct kobil_private *priv;\n\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tpriv = usb_get_serial_port_data(port);\n\n\tif (count > (KOBIL_BUF_LENGTH - priv->filled)) {\n\t\tdev_dbg(&port->dev, \"%s - Error: write request bigger than buffer size\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tmemcpy(priv->buf + priv->filled, buf, count);\n\tusb_serial_debug_data(&port->dev, __func__, count, priv->buf + priv->filled);\n\tpriv->filled = priv->filled + count;\n\n\t \n\tif (((priv->device_type != KOBIL_ADAPTER_B_PRODUCT_ID) && (priv->filled > 2) && (priv->filled >= (priv->buf[1] + 3))) ||\n\t     ((priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID) && (priv->filled > 3) && (priv->filled >= (priv->buf[2] + 4)))) {\n\t\t \n\t\tif ((priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID)\n\t\t\t|| (priv->device_type == KOBIL_ADAPTER_K_PRODUCT_ID))\n\t\t\tusb_kill_urb(port->interrupt_in_urb);\n\n\t\ttodo = priv->filled - priv->cur_pos;\n\n\t\twhile (todo > 0) {\n\t\t\t \n\t\t\tlength = min(todo, port->interrupt_out_size);\n\t\t\t \n\t\t\tmemcpy(port->interrupt_out_buffer,\n\t\t\t\t\tpriv->buf + priv->cur_pos, length);\n\t\t\tport->interrupt_out_urb->transfer_buffer_length = length;\n\n\t\t\tpriv->cur_pos = priv->cur_pos + length;\n\t\t\tresult = usb_submit_urb(port->interrupt_out_urb,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tdev_dbg(&port->dev, \"%s - Send write URB returns: %i\\n\", __func__, result);\n\t\t\ttodo = priv->filled - priv->cur_pos;\n\n\t\t\tif (todo > 0)\n\t\t\t\tmsleep(24);\n\t\t}\n\n\t\tpriv->filled = 0;\n\t\tpriv->cur_pos = 0;\n\n\t\t \n\t\tif (priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID ||\n\t\t\tpriv->device_type == KOBIL_ADAPTER_K_PRODUCT_ID) {\n\t\t\tresult = usb_submit_urb(port->interrupt_in_urb,\n\t\t\t\t\tGFP_ATOMIC);\n\t\t\tdev_dbg(&port->dev, \"%s - Send read URB returns: %i\\n\", __func__, result);\n\t\t}\n\t}\n\treturn count;\n}\n\n\nstatic unsigned int kobil_write_room(struct tty_struct *tty)\n{\n\t \n\treturn 8;\n}\n\n\nstatic int kobil_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct kobil_private *priv;\n\tint result;\n\tunsigned char *transfer_buffer;\n\tint transfer_buffer_length = 8;\n\n\tpriv = usb_get_serial_port_data(port);\n\tif (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID\n\t\t\t|| priv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\t \n\ttransfer_buffer = kzalloc(transfer_buffer_length, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_GetStatusLineState,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_IN,\n\t\t\t  0,\n\t\t\t  0,\n\t\t\t  transfer_buffer,\n\t\t\t  transfer_buffer_length,\n\t\t\t  KOBIL_TIMEOUT);\n\n\tdev_dbg(&port->dev, \"Send get_status_line_state URB returns: %i\\n\",\n\t\t\tresult);\n\tif (result < 1) {\n\t\tif (result >= 0)\n\t\t\tresult = -EIO;\n\t\tgoto out_free;\n\t}\n\n\tdev_dbg(&port->dev, \"Statusline: %02x\\n\", transfer_buffer[0]);\n\n\tresult = 0;\n\tif ((transfer_buffer[0] & SUSBCR_GSL_DSR) != 0)\n\t\tresult = TIOCM_DSR;\nout_free:\n\tkfree(transfer_buffer);\n\treturn result;\n}\n\nstatic int kobil_tiocmset(struct tty_struct *tty,\n\t\t\t   unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct device *dev = &port->dev;\n\tstruct kobil_private *priv;\n\tint result;\n\tint dtr = 0;\n\tint rts = 0;\n\n\t \n\tpriv = usb_get_serial_port_data(port);\n\tif (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID\n\t\t|| priv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID) {\n\t\t \n\t\treturn -EINVAL;\n\t}\n\n\tif (set & TIOCM_RTS)\n\t\trts = 1;\n\tif (set & TIOCM_DTR)\n\t\tdtr = 1;\n\tif (clear & TIOCM_RTS)\n\t\trts = 0;\n\tif (clear & TIOCM_DTR)\n\t\tdtr = 0;\n\n\tif (priv->device_type == KOBIL_ADAPTER_B_PRODUCT_ID) {\n\t\tif (dtr != 0)\n\t\t\tdev_dbg(dev, \"%s - Setting DTR\\n\", __func__);\n\t\telse\n\t\t\tdev_dbg(dev, \"%s - Clearing DTR\\n\", __func__);\n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_SetStatusLinesOrQueues,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t  ((dtr != 0) ? SUSBCR_SSL_SETDTR : SUSBCR_SSL_CLRDTR),\n\t\t\t  0,\n\t\t\t  NULL,\n\t\t\t  0,\n\t\t\t  KOBIL_TIMEOUT);\n\t} else {\n\t\tif (rts != 0)\n\t\t\tdev_dbg(dev, \"%s - Setting RTS\\n\", __func__);\n\t\telse\n\t\t\tdev_dbg(dev, \"%s - Clearing RTS\\n\", __func__);\n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tSUSBCRequest_SetStatusLinesOrQueues,\n\t\t\tUSB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t((rts != 0) ? SUSBCR_SSL_SETRTS : SUSBCR_SSL_CLRRTS),\n\t\t\t0,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tKOBIL_TIMEOUT);\n\t}\n\tdev_dbg(dev, \"%s - Send set_status_line URB returns: %i\\n\", __func__, result);\n\treturn (result < 0) ? result : 0;\n}\n\nstatic void kobil_set_termios(struct tty_struct *tty,\n\t\t\t      struct usb_serial_port *port,\n\t\t\t      const struct ktermios *old)\n{\n\tstruct kobil_private *priv;\n\tint result;\n\tunsigned short urb_val = 0;\n\tint c_cflag = tty->termios.c_cflag;\n\tspeed_t speed;\n\n\tpriv = usb_get_serial_port_data(port);\n\tif (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID ||\n\t\t\tpriv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID) {\n\t\t \n\t\ttty_termios_copy_hw(&tty->termios, old);\n\t\treturn;\n\t}\n\n\tspeed = tty_get_baud_rate(tty);\n\tswitch (speed) {\n\tcase 1200:\n\t\turb_val = SUSBCR_SBR_1200;\n\t\tbreak;\n\tdefault:\n\t\tspeed = 9600;\n\t\tfallthrough;\n\tcase 9600:\n\t\turb_val = SUSBCR_SBR_9600;\n\t\tbreak;\n\t}\n\turb_val |= (c_cflag & CSTOPB) ? SUSBCR_SPASB_2StopBits :\n\t\t\t\t\t\t\tSUSBCR_SPASB_1StopBit;\n\tif (c_cflag & PARENB) {\n\t\tif  (c_cflag & PARODD)\n\t\t\turb_val |= SUSBCR_SPASB_OddParity;\n\t\telse\n\t\t\turb_val |= SUSBCR_SPASB_EvenParity;\n\t} else\n\t\turb_val |= SUSBCR_SPASB_NoParity;\n\ttty->termios.c_cflag &= ~CMSPAR;\n\ttty_encode_baud_rate(tty, speed, speed);\n\n\tresult = usb_control_msg(port->serial->dev,\n\t\t  usb_sndctrlpipe(port->serial->dev, 0),\n\t\t  SUSBCRequest_SetBaudRateParityAndStopBits,\n\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t  urb_val,\n\t\t  0,\n\t\t  NULL,\n\t\t  0,\n\t\t  KOBIL_TIMEOUT\n\t\t);\n\tif (result) {\n\t\tdev_err(&port->dev, \"failed to update line settings: %d\\n\",\n\t\t\t\tresult);\n\t}\n}\n\nstatic int kobil_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct kobil_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tif (priv->device_type == KOBIL_USBTWIN_PRODUCT_ID ||\n\t\t\tpriv->device_type == KOBIL_KAAN_SIM_PRODUCT_ID)\n\t\t \n\t\treturn -ENOIOCTLCMD;\n\n\tswitch (cmd) {\n\tcase TCFLSH:\n\t\tresult = usb_control_msg(port->serial->dev,\n\t\t\t  usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t  SUSBCRequest_Misc,\n\t\t\t  USB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT,\n\t\t\t  SUSBCR_MSC_ResetAllQueues,\n\t\t\t  0,\n\t\t\t  NULL,\n\t\t\t  0,\n\t\t\t  KOBIL_TIMEOUT\n\t\t\t);\n\n\t\tdev_dbg(&port->dev,\n\t\t\t\"%s - Send reset_all_queues (FLUSH) URB returns: %i\\n\",\n\t\t\t__func__, result);\n\t\treturn (result < 0) ? -EIO: 0;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}