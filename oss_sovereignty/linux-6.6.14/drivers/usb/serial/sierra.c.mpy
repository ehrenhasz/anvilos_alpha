{
  "module_name": "sierra.c",
  "hash_id": "0f0d258b8ea1ed177fda1e03d31c58861703450ae517cb7d196fca5f24fdf2d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/sierra.c",
  "human_readable_source": "\n \n \n \n\n#define DRIVER_AUTHOR \"Kevin Lloyd, Elina Pasheva, Matthew Safar, Rory Filer\"\n#define DRIVER_DESC \"USB Driver for Sierra Wireless USB modems\"\n\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/errno.h>\n#include <linux/tty.h>\n#include <linux/slab.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define SWIMS_USB_REQUEST_SetPower\t0x00\n#define SWIMS_USB_REQUEST_SetNmea\t0x07\n\n#define N_IN_URB_HM\t8\n#define N_OUT_URB_HM\t64\n#define N_IN_URB\t4\n#define N_OUT_URB\t4\n#define IN_BUFLEN\t4096\n\n#define MAX_TRANSFER\t\t(PAGE_SIZE - 512)\n \n\nstatic bool nmea;\n\nstruct sierra_iface_list {\n\tconst u8 *nums;\t\t \n\tsize_t count;\t\t \n};\n\nstruct sierra_intf_private {\n\tspinlock_t susp_lock;\n\tunsigned int suspended:1;\n\tint in_flight;\n\tunsigned int open_ports;\n};\n\nstatic int sierra_set_power_state(struct usb_device *udev, __u16 swiState)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tSWIMS_USB_REQUEST_SetPower,\t \n\t\t\tUSB_TYPE_VENDOR,\t\t \n\t\t\tswiState,\t\t\t \n\t\t\t0,\t\t\t\t \n\t\t\tNULL,\t\t\t\t \n\t\t\t0,\t\t\t\t \n\t\t\tUSB_CTRL_SET_TIMEOUT);\t\t \n}\n\nstatic int sierra_vsc_set_nmea(struct usb_device *udev, __u16 enable)\n{\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tSWIMS_USB_REQUEST_SetNmea,\t \n\t\t\tUSB_TYPE_VENDOR,\t\t \n\t\t\tenable,\t\t\t\t \n\t\t\t0x0000,\t\t\t\t \n\t\t\tNULL,\t\t\t\t \n\t\t\t0,\t\t\t\t \n\t\t\tUSB_CTRL_SET_TIMEOUT);\t\t \n}\n\nstatic int sierra_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tint num_ports = 0;\n\tu8 ifnum, numendpoints;\n\n\tifnum = serial->interface->cur_altsetting->desc.bInterfaceNumber;\n\tnumendpoints = serial->interface->cur_altsetting->desc.bNumEndpoints;\n\n\t \n\tif (ifnum == 0x99)\n\t\tnum_ports = 0;\n\telse if (numendpoints <= 3)\n\t\tnum_ports = 1;\n\telse\n\t\tnum_ports = (numendpoints-1)/2;\n\treturn num_ports;\n}\n\nstatic bool is_listed(const u8 ifnum, const struct sierra_iface_list *list)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn false;\n\n\tfor (i = 0; i < list->count; i++) {\n\t\tif (list->nums[i] == ifnum)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic u8 sierra_interface_num(struct usb_serial *serial)\n{\n\treturn serial->interface->cur_altsetting->desc.bInterfaceNumber;\n}\n\nstatic int sierra_probe(struct usb_serial *serial,\n\t\t\tconst struct usb_device_id *id)\n{\n\tconst struct sierra_iface_list *ignore_list;\n\tint result = 0;\n\tstruct usb_device *udev;\n\tu8 ifnum;\n\n\tudev = serial->dev;\n\tifnum = sierra_interface_num(serial);\n\n\t \n\tif (serial->interface->num_altsetting == 2) {\n\t\tdev_dbg(&udev->dev, \"Selecting alt setting for interface %d\\n\",\n\t\t\tifnum);\n\t\t \n\t\tusb_set_interface(udev, ifnum, 1);\n\t}\n\n\tignore_list = (const struct sierra_iface_list *)id->driver_info;\n\n\tif (is_listed(ifnum, ignore_list)) {\n\t\tdev_dbg(&serial->dev->dev, \"Ignoring interface #%d\\n\", ifnum);\n\t\treturn -ENODEV;\n\t}\n\n\treturn result;\n}\n\n \nstatic const u8 hi_memory_typeA_ifaces[] = { 0, 2 };\nstatic const struct sierra_iface_list typeA_interface_list = {\n\t.nums\t= hi_memory_typeA_ifaces,\n\t.count\t= ARRAY_SIZE(hi_memory_typeA_ifaces),\n};\n\nstatic const u8 hi_memory_typeB_ifaces[] = { 3, 4, 5, 6 };\nstatic const struct sierra_iface_list typeB_interface_list = {\n\t.nums\t= hi_memory_typeB_ifaces,\n\t.count\t= ARRAY_SIZE(hi_memory_typeB_ifaces),\n};\n\n \nstatic const u8 direct_ip_non_serial_ifaces[] = { 7, 8, 9, 10, 11, 19, 20 };\nstatic const struct sierra_iface_list direct_ip_interface_ignore = {\n\t.nums\t= direct_ip_non_serial_ifaces,\n\t.count\t= ARRAY_SIZE(direct_ip_non_serial_ifaces),\n};\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(0x0F3D, 0x0112) },  \n\t{ USB_DEVICE(0x03F0, 0x1B1D) },\t \n\t{ USB_DEVICE(0x03F0, 0x211D) },  \n\t{ USB_DEVICE(0x03F0, 0x1E1D) },\t \n\n\t{ USB_DEVICE(0x1199, 0x0017) },\t \n\t{ USB_DEVICE(0x1199, 0x0018) },\t \n\t{ USB_DEVICE(0x1199, 0x0218) },\t \n\t{ USB_DEVICE(0x1199, 0x0020) },\t \n\t{ USB_DEVICE(0x1199, 0x0220) },\t \n\t{ USB_DEVICE(0x1199, 0x0022) },\t \n\t{ USB_DEVICE(0x1199, 0x0024) },\t \n\t{ USB_DEVICE(0x1199, 0x0224) },\t \n\t{ USB_DEVICE(0x1199, 0x0019) },\t \n\t{ USB_DEVICE(0x1199, 0x0021) },\t \n\t{ USB_DEVICE(0x1199, 0x0112) },  \n\t{ USB_DEVICE(0x1199, 0x0120) },\t \n\t{ USB_DEVICE(0x1199, 0x0301) },\t \n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x0023, 0xFF, 0xFF, 0xFF) },\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x0025, 0xFF, 0xFF, 0xFF) },\n\t{ USB_DEVICE(0x1199, 0x0026) },  \n\t{ USB_DEVICE(0x1199, 0x0027) },  \n\t{ USB_DEVICE(0x1199, 0x0028) },  \n\t{ USB_DEVICE(0x1199, 0x0029) },  \n\n\t{ USB_DEVICE(0x1199, 0x6802) },\t \n\t{ USB_DEVICE(0x1199, 0x6803) },\t \n\t{ USB_DEVICE(0x1199, 0x6804) },\t \n\t{ USB_DEVICE(0x1199, 0x6805) },\t \n\t{ USB_DEVICE(0x1199, 0x6808) },\t \n\t{ USB_DEVICE(0x1199, 0x6809) },\t \n\t{ USB_DEVICE(0x1199, 0x6812) },\t \n\t{ USB_DEVICE(0x1199, 0x6813) },\t \n\t{ USB_DEVICE(0x1199, 0x6815) },\t \n\t{ USB_DEVICE(0x1199, 0x6816) },\t \n\t{ USB_DEVICE(0x1199, 0x6820) },\t \n\t{ USB_DEVICE(0x1199, 0x6821) },\t \n\t{ USB_DEVICE(0x1199, 0x6822) },\t \n\t{ USB_DEVICE(0x1199, 0x6832) },\t \n\t{ USB_DEVICE(0x1199, 0x6833) },\t \n\t{ USB_DEVICE(0x1199, 0x6834) },\t \n\t{ USB_DEVICE(0x1199, 0x6835) },\t \n\t{ USB_DEVICE(0x1199, 0x6838) },\t \n\t{ USB_DEVICE(0x1199, 0x6839) },\t \n\t{ USB_DEVICE(0x1199, 0x683A) },\t \n\t{ USB_DEVICE(0x1199, 0x683B) },\t \n\t \n\t{ USB_DEVICE(0x1199, 0x683C) },\n\t{ USB_DEVICE(0x1199, 0x683D) },\t \n\t \n\t{ USB_DEVICE(0x1199, 0x683E) },\n\t{ USB_DEVICE(0x1199, 0x6850) },\t \n\t{ USB_DEVICE(0x1199, 0x6851) },\t \n\t{ USB_DEVICE(0x1199, 0x6852) },\t \n\t{ USB_DEVICE(0x1199, 0x6853) },\t \n\t{ USB_DEVICE(0x1199, 0x6855) },\t \n\t{ USB_DEVICE(0x1199, 0x6856) },\t \n\t{ USB_DEVICE(0x1199, 0x6859) },\t \n\t{ USB_DEVICE(0x1199, 0x685A) },\t \n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x6880, 0xFF, 0xFF, 0xFF)},\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x6890, 0xFF, 0xFF, 0xFF)},\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x6891, 0xFF, 0xFF, 0xFF)},\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x6892, 0xFF, 0xFF, 0xFF)},\n\t{ USB_DEVICE(0x1199, 0x6893) },\t \n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68A3, 0xFF, 0xFF, 0xFF),\n\t  .driver_info = (kernel_ulong_t)&direct_ip_interface_ignore\n\t},\n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68AA, 0xFF, 0xFF, 0xFF),\n\t  .driver_info = (kernel_ulong_t)&direct_ip_interface_ignore\n\t},\n\t{ USB_DEVICE(0x1199, 0x68AB) },  \n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68AA, 0xFF, 0xFF, 0xFF),\n\t  .driver_info = (kernel_ulong_t)&direct_ip_interface_ignore\n\t},\n\t \n\t{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68A3, 0xFF, 0xFF, 0xFF),\n\t  .driver_info = (kernel_ulong_t)&direct_ip_interface_ignore\n\t},\n\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n\nstruct sierra_port_private {\n\tspinlock_t lock;\t \n\tint outstanding_urbs;\t \n\tstruct usb_anchor active;\n\tstruct usb_anchor delayed;\n\n\tint num_out_urbs;\n\tint num_in_urbs;\n\t \n\tstruct urb *in_urbs[N_IN_URB_HM];\n\n\t \n\tint rts_state;\t \n\tint dtr_state;\n\tint cts_state;\t \n\tint dsr_state;\n\tint dcd_state;\n\tint ri_state;\n};\n\nstatic int sierra_send_setup(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct sierra_port_private *portdata;\n\t__u16 interface = 0;\n\tint val = 0;\n\tint do_send = 0;\n\tint retval;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tif (portdata->dtr_state)\n\t\tval |= 0x01;\n\tif (portdata->rts_state)\n\t\tval |= 0x02;\n\n\t \n\tif (serial->num_ports == 1) {\n\t\tinterface = sierra_interface_num(serial);\n\t\t \n\t\tif (port->interrupt_in_urb) {\n\t\t\t \n\t\t\tdo_send = 1;\n\t\t}\n\t}\n\n\t \n\telse {\n\t\tif (port->bulk_out_endpointAddress == 2)\n\t\t\tinterface = 0;\n\t\telse if (port->bulk_out_endpointAddress == 4)\n\t\t\tinterface = 1;\n\t\telse if (port->bulk_out_endpointAddress == 5)\n\t\t\tinterface = 2;\n\n\t\tdo_send = 1;\n\t}\n\tif (!do_send)\n\t\treturn 0;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval < 0)\n\t\treturn retval;\n\n\tretval = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t0x22, 0x21, val, interface, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\tusb_autopm_put_interface(serial->interface);\n\n\treturn retval;\n}\n\nstatic int sierra_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tunsigned int value;\n\tstruct sierra_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tvalue = ((portdata->rts_state) ? TIOCM_RTS : 0) |\n\t\t((portdata->dtr_state) ? TIOCM_DTR : 0) |\n\t\t((portdata->cts_state) ? TIOCM_CTS : 0) |\n\t\t((portdata->dsr_state) ? TIOCM_DSR : 0) |\n\t\t((portdata->dcd_state) ? TIOCM_CAR : 0) |\n\t\t((portdata->ri_state) ? TIOCM_RNG : 0);\n\n\treturn value;\n}\n\nstatic int sierra_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct sierra_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tif (set & TIOCM_RTS)\n\t\tportdata->rts_state = 1;\n\tif (set & TIOCM_DTR)\n\t\tportdata->dtr_state = 1;\n\n\tif (clear & TIOCM_RTS)\n\t\tportdata->rts_state = 0;\n\tif (clear & TIOCM_DTR)\n\t\tportdata->dtr_state = 0;\n\treturn sierra_send_setup(port);\n}\n\nstatic void sierra_release_urb(struct urb *urb)\n{\n\tif (urb) {\n\t\tkfree(urb->transfer_buffer);\n\t\tusb_free_urb(urb);\n\t}\n}\n\nstatic void sierra_outdat_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\tstruct sierra_intf_private *intfdata;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tintfdata = usb_get_serial_data(port->serial);\n\n\t \n\tkfree(urb->transfer_buffer);\n\tusb_autopm_put_interface_async(port->serial->interface);\n\tif (status)\n\t\tdev_dbg(&port->dev, \"%s - nonzero write bulk status \"\n\t\t    \"received: %d\\n\", __func__, status);\n\n\tspin_lock_irqsave(&portdata->lock, flags);\n\t--portdata->outstanding_urbs;\n\tspin_unlock_irqrestore(&portdata->lock, flags);\n\tspin_lock_irqsave(&intfdata->susp_lock, flags);\n\t--intfdata->in_flight;\n\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\n\tusb_serial_port_softint(port);\n}\n\n \nstatic int sierra_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, int count)\n{\n\tstruct sierra_port_private *portdata;\n\tstruct sierra_intf_private *intfdata;\n\tstruct usb_serial *serial = port->serial;\n\tunsigned long flags;\n\tunsigned char *buffer;\n\tstruct urb *urb;\n\tsize_t writesize = min((size_t)count, (size_t)MAX_TRANSFER);\n\tint retval = 0;\n\n\t \n\tif (count == 0)\n\t\treturn 0;\n\n\tportdata = usb_get_serial_port_data(port);\n\tintfdata = usb_get_serial_data(serial);\n\n\tdev_dbg(&port->dev, \"%s: write (%zd bytes)\\n\", __func__, writesize);\n\tspin_lock_irqsave(&portdata->lock, flags);\n\tdev_dbg(&port->dev, \"%s - outstanding_urbs: %d\\n\", __func__,\n\t\tportdata->outstanding_urbs);\n\tif (portdata->outstanding_urbs > portdata->num_out_urbs) {\n\t\tspin_unlock_irqrestore(&portdata->lock, flags);\n\t\tdev_dbg(&port->dev, \"%s - write limit hit\\n\", __func__);\n\t\treturn 0;\n\t}\n\tportdata->outstanding_urbs++;\n\tdev_dbg(&port->dev, \"%s - 1, outstanding_urbs: %d\\n\", __func__,\n\t\tportdata->outstanding_urbs);\n\tspin_unlock_irqrestore(&portdata->lock, flags);\n\n\tretval = usb_autopm_get_interface_async(serial->interface);\n\tif (retval < 0) {\n\t\tspin_lock_irqsave(&portdata->lock, flags);\n\t\tportdata->outstanding_urbs--;\n\t\tspin_unlock_irqrestore(&portdata->lock, flags);\n\t\tgoto error_simple;\n\t}\n\n\tbuffer = kmemdup(buf, writesize, GFP_ATOMIC);\n\tif (!buffer) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_no_buffer;\n\t}\n\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_no_urb;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__, writesize, buffer);\n\n\tusb_fill_bulk_urb(urb, serial->dev,\n\t\t\t  usb_sndbulkpipe(serial->dev,\n\t\t\t\t\t  port->bulk_out_endpointAddress),\n\t\t\t  buffer, writesize, sierra_outdat_callback, port);\n\n\t \n\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\tspin_lock_irqsave(&intfdata->susp_lock, flags);\n\n\tif (intfdata->suspended) {\n\t\tusb_anchor_urb(urb, &portdata->delayed);\n\t\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\t\tgoto skip_power;\n\t} else {\n\t\tusb_anchor_urb(urb, &portdata->active);\n\t}\n\t \n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tusb_unanchor_urb(urb);\n\t\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\t\tdev_err(&port->dev, \"%s - usb_submit_urb(write bulk) failed \"\n\t\t\t\"with status = %d\\n\", __func__, retval);\n\t\tgoto error;\n\t} else {\n\t\tintfdata->in_flight++;\n\t\tspin_unlock_irqrestore(&intfdata->susp_lock, flags);\n\t}\n\nskip_power:\n\t \n\tusb_free_urb(urb);\n\n\treturn writesize;\nerror:\n\tusb_free_urb(urb);\nerror_no_urb:\n\tkfree(buffer);\nerror_no_buffer:\n\tspin_lock_irqsave(&portdata->lock, flags);\n\t--portdata->outstanding_urbs;\n\tdev_dbg(&port->dev, \"%s - 2. outstanding_urbs: %d\\n\", __func__,\n\t\tportdata->outstanding_urbs);\n\tspin_unlock_irqrestore(&portdata->lock, flags);\n\tusb_autopm_put_interface_async(serial->interface);\nerror_simple:\n\treturn retval;\n}\n\nstatic void sierra_indat_callback(struct urb *urb)\n{\n\tint err;\n\tint endpoint;\n\tstruct usb_serial_port *port;\n\tunsigned char *data = urb->transfer_buffer;\n\tint status = urb->status;\n\n\tendpoint = usb_pipeendpoint(urb->pipe);\n\tport = urb->context;\n\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s: nonzero status: %d on\"\n\t\t\t\" endpoint %02x\\n\", __func__, status, endpoint);\n\t} else {\n\t\tif (urb->actual_length) {\n\t\t\ttty_insert_flip_string(&port->port, data,\n\t\t\t\turb->actual_length);\n\t\t\ttty_flip_buffer_push(&port->port);\n\n\t\t\tusb_serial_debug_data(&port->dev, __func__,\n\t\t\t\t\t      urb->actual_length, data);\n\t\t} else {\n\t\t\tdev_dbg(&port->dev, \"%s: empty read urb\"\n\t\t\t\t\" received\\n\", __func__);\n\t\t}\n\t}\n\n\t \n\tif (status != -ESHUTDOWN && status != -EPERM) {\n\t\tusb_mark_last_busy(port->serial->dev);\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err && err != -EPERM)\n\t\t\tdev_err(&port->dev, \"resubmit read urb failed.\"\n\t\t\t\t\"(%d)\\n\", err);\n\t}\n}\n\nstatic void sierra_instat_callback(struct urb *urb)\n{\n\tint err;\n\tint status = urb->status;\n\tstruct usb_serial_port *port =  urb->context;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\n\tdev_dbg(&port->dev, \"%s: urb %p port %p has data %p\\n\", __func__,\n\t\turb, port, portdata);\n\n\tif (status == 0) {\n\t\tstruct usb_ctrlrequest *req_pkt = urb->transfer_buffer;\n\n\t\tif (!req_pkt) {\n\t\t\tdev_dbg(&port->dev, \"%s: NULL req_pkt\\n\",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\t\tif ((req_pkt->bRequestType == 0xA1) &&\n\t\t\t\t(req_pkt->bRequest == 0x20)) {\n\t\t\tint old_dcd_state;\n\t\t\tunsigned char signals = *((unsigned char *)\n\t\t\t\t\turb->transfer_buffer +\n\t\t\t\t\tsizeof(struct usb_ctrlrequest));\n\n\t\t\tdev_dbg(&port->dev, \"%s: signal x%x\\n\", __func__,\n\t\t\t\tsignals);\n\n\t\t\told_dcd_state = portdata->dcd_state;\n\t\t\tportdata->cts_state = 1;\n\t\t\tportdata->dcd_state = ((signals & 0x01) ? 1 : 0);\n\t\t\tportdata->dsr_state = ((signals & 0x02) ? 1 : 0);\n\t\t\tportdata->ri_state = ((signals & 0x08) ? 1 : 0);\n\n\t\t\tif (old_dcd_state && !portdata->dcd_state)\n\t\t\t\ttty_port_tty_hangup(&port->port, true);\n\t\t} else {\n\t\t\tdev_dbg(&port->dev, \"%s: type %x req %x\\n\",\n\t\t\t\t__func__, req_pkt->bRequestType,\n\t\t\t\treq_pkt->bRequest);\n\t\t}\n\t} else\n\t\tdev_dbg(&port->dev, \"%s: error %d\\n\", __func__, status);\n\n\t \n\tif (status != -ESHUTDOWN && status != -ENOENT) {\n\t\tusb_mark_last_busy(serial->dev);\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err && err != -EPERM)\n\t\t\tdev_err(&port->dev, \"%s: resubmit intr urb \"\n\t\t\t\t\"failed. (%d)\\n\", __func__, err);\n\t}\n}\n\nstatic unsigned int sierra_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\n\t \n\tspin_lock_irqsave(&portdata->lock, flags);\n\tif (portdata->outstanding_urbs > (portdata->num_out_urbs * 2) / 3) {\n\t\tspin_unlock_irqrestore(&portdata->lock, flags);\n\t\tdev_dbg(&port->dev, \"%s - write limit hit\\n\", __func__);\n\t\treturn 0;\n\t}\n\tspin_unlock_irqrestore(&portdata->lock, flags);\n\n\treturn 2048;\n}\n\nstatic unsigned int sierra_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int chars;\n\n\t \n\tspin_lock_irqsave(&portdata->lock, flags);\n\tchars = portdata->outstanding_urbs * MAX_TRANSFER;\n\tspin_unlock_irqrestore(&portdata->lock, flags);\n\n\tdev_dbg(&port->dev, \"%s - %u\\n\", __func__, chars);\n\n\treturn chars;\n}\n\nstatic void sierra_stop_rx_urbs(struct usb_serial_port *port)\n{\n\tint i;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\n\tfor (i = 0; i < portdata->num_in_urbs; i++)\n\t\tusb_kill_urb(portdata->in_urbs[i]);\n\n\tusb_kill_urb(port->interrupt_in_urb);\n}\n\nstatic int sierra_submit_rx_urbs(struct usb_serial_port *port, gfp_t mem_flags)\n{\n\tint ok_cnt;\n\tint err = -EINVAL;\n\tint i;\n\tstruct urb *urb;\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\n\tok_cnt = 0;\n\tfor (i = 0; i < portdata->num_in_urbs; i++) {\n\t\turb = portdata->in_urbs[i];\n\t\tif (!urb)\n\t\t\tcontinue;\n\t\terr = usb_submit_urb(urb, mem_flags);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev, \"%s: submit urb failed: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t} else {\n\t\t\tok_cnt++;\n\t\t}\n\t}\n\n\tif (ok_cnt && port->interrupt_in_urb) {\n\t\terr = usb_submit_urb(port->interrupt_in_urb, mem_flags);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev, \"%s: submit intr urb failed: %d\\n\",\n\t\t\t\t__func__, err);\n\t\t}\n\t}\n\n\tif (ok_cnt > 0)  \n\t\treturn 0;\n\telse\n\t\treturn err;\n}\n\nstatic struct urb *sierra_setup_urb(struct usb_serial *serial, int endpoint,\n\t\t\t\t\tint dir, void *ctx, int len,\n\t\t\t\t\tgfp_t mem_flags,\n\t\t\t\t\tusb_complete_t callback)\n{\n\tstruct urb\t*urb;\n\tu8\t\t*buf;\n\n\turb = usb_alloc_urb(0, mem_flags);\n\tif (!urb)\n\t\treturn NULL;\n\n\tbuf = kmalloc(len, mem_flags);\n\tif (buf) {\n\t\t \n\t\tusb_fill_bulk_urb(urb, serial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev, endpoint) | dir,\n\t\t\tbuf, len, callback, ctx);\n\n\t\tdev_dbg(&serial->dev->dev, \"%s %c u : %p d:%p\\n\", __func__,\n\t\t\t\tdir == USB_DIR_IN ? 'i' : 'o', urb, buf);\n\t} else {\n\t\tsierra_release_urb(urb);\n\t\turb = NULL;\n\t}\n\n\treturn urb;\n}\n\nstatic void sierra_close(struct usb_serial_port *port)\n{\n\tint i;\n\tstruct usb_serial *serial = port->serial;\n\tstruct sierra_port_private *portdata;\n\tstruct sierra_intf_private *intfdata = usb_get_serial_data(serial);\n\tstruct urb *urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\t \n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (--intfdata->open_ports == 0)\n\t\tserial->interface->needs_remote_wakeup = 0;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\tfor (;;) {\n\t\turb = usb_get_from_anchor(&portdata->delayed);\n\t\tif (!urb)\n\t\t\tbreak;\n\t\tkfree(urb->transfer_buffer);\n\t\tusb_free_urb(urb);\n\t\tusb_autopm_put_interface_async(serial->interface);\n\t\tspin_lock_irq(&portdata->lock);\n\t\tportdata->outstanding_urbs--;\n\t\tspin_unlock_irq(&portdata->lock);\n\t}\n\n\tsierra_stop_rx_urbs(port);\n\tusb_kill_anchored_urbs(&portdata->active);\n\n\tfor (i = 0; i < portdata->num_in_urbs; i++) {\n\t\tsierra_release_urb(portdata->in_urbs[i]);\n\t\tportdata->in_urbs[i] = NULL;\n\t}\n\n\tusb_autopm_get_interface_no_resume(serial->interface);\n}\n\nstatic int sierra_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct sierra_port_private *portdata;\n\tstruct usb_serial *serial = port->serial;\n\tstruct sierra_intf_private *intfdata = usb_get_serial_data(serial);\n\tint i;\n\tint err;\n\tint endpoint;\n\tstruct urb *urb;\n\n\tportdata = usb_get_serial_port_data(port);\n\n\tendpoint = port->bulk_in_endpointAddress;\n\tfor (i = 0; i < portdata->num_in_urbs; i++) {\n\t\turb = sierra_setup_urb(serial, endpoint, USB_DIR_IN, port,\n\t\t\t\t\tIN_BUFLEN, GFP_KERNEL,\n\t\t\t\t\tsierra_indat_callback);\n\t\tportdata->in_urbs[i] = urb;\n\t}\n\t \n\tusb_clear_halt(serial->dev,\n\t\t\tusb_sndbulkpipe(serial->dev, endpoint) | USB_DIR_IN);\n\n\terr = sierra_submit_rx_urbs(port, GFP_KERNEL);\n\tif (err)\n\t\tgoto err_submit;\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (++intfdata->open_ports == 1)\n\t\tserial->interface->needs_remote_wakeup = 1;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\tusb_autopm_put_interface(serial->interface);\n\n\treturn 0;\n\nerr_submit:\n\tsierra_stop_rx_urbs(port);\n\n\tfor (i = 0; i < portdata->num_in_urbs; i++) {\n\t\tsierra_release_urb(portdata->in_urbs[i]);\n\t\tportdata->in_urbs[i] = NULL;\n\t}\n\n\treturn err;\n}\n\n\nstatic void sierra_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct sierra_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\tportdata->rts_state = on;\n\tportdata->dtr_state = on;\n\n\tsierra_send_setup(port);\n}\n\nstatic int sierra_startup(struct usb_serial *serial)\n{\n\tstruct sierra_intf_private *intfdata;\n\n\tintfdata = kzalloc(sizeof(*intfdata), GFP_KERNEL);\n\tif (!intfdata)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&intfdata->susp_lock);\n\n\tusb_set_serial_data(serial, intfdata);\n\n\t \n\tsierra_set_power_state(serial->dev, 0x0000);\n\n\t \n\tif (nmea)\n\t\tsierra_vsc_set_nmea(serial->dev, 1);\n\n\treturn 0;\n}\n\nstatic void sierra_release(struct usb_serial *serial)\n{\n\tstruct sierra_intf_private *intfdata;\n\n\tintfdata = usb_get_serial_data(serial);\n\tkfree(intfdata);\n}\n\nstatic int sierra_port_probe(struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct sierra_port_private *portdata;\n\tconst struct sierra_iface_list *himemory_list;\n\tu8 ifnum;\n\n\tportdata = kzalloc(sizeof(*portdata), GFP_KERNEL);\n\tif (!portdata)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&portdata->lock);\n\tinit_usb_anchor(&portdata->active);\n\tinit_usb_anchor(&portdata->delayed);\n\n\t \n\tportdata->num_out_urbs = N_OUT_URB;\n\tportdata->num_in_urbs  = N_IN_URB;\n\n\t \n\tif (serial->num_ports == 1) {\n\t\t \n\t\tifnum = sierra_interface_num(serial);\n\t\thimemory_list = &typeB_interface_list;\n\t} else {\n\t\t \n\t\tifnum = port->port_number;\n\t\thimemory_list = &typeA_interface_list;\n\t}\n\n\tif (is_listed(ifnum, himemory_list)) {\n\t\tportdata->num_out_urbs = N_OUT_URB_HM;\n\t\tportdata->num_in_urbs  = N_IN_URB_HM;\n\t}\n\n\tdev_dbg(&port->dev,\n\t\t\t\"Memory usage (urbs) interface #%d, in=%d, out=%d\\n\",\n\t\t\tifnum, portdata->num_in_urbs, portdata->num_out_urbs);\n\n\tusb_set_serial_port_data(port, portdata);\n\n\treturn 0;\n}\n\nstatic void sierra_port_remove(struct usb_serial_port *port)\n{\n\tstruct sierra_port_private *portdata;\n\n\tportdata = usb_get_serial_port_data(port);\n\tusb_set_serial_port_data(port, NULL);\n\tkfree(portdata);\n}\n\n#ifdef CONFIG_PM\nstatic void stop_read_write_urbs(struct usb_serial *serial)\n{\n\tint i;\n\tstruct usb_serial_port *port;\n\tstruct sierra_port_private *portdata;\n\n\t \n\tfor (i = 0; i < serial->num_ports; ++i) {\n\t\tport = serial->port[i];\n\t\tportdata = usb_get_serial_port_data(port);\n\t\tif (!portdata)\n\t\t\tcontinue;\n\t\tsierra_stop_rx_urbs(port);\n\t\tusb_kill_anchored_urbs(&portdata->active);\n\t}\n}\n\nstatic int sierra_suspend(struct usb_serial *serial, pm_message_t message)\n{\n\tstruct sierra_intf_private *intfdata = usb_get_serial_data(serial);\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tif (PMSG_IS_AUTO(message)) {\n\t\tif (intfdata->in_flight) {\n\t\t\tspin_unlock_irq(&intfdata->susp_lock);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\tintfdata->suspended = 1;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\tstop_read_write_urbs(serial);\n\n\treturn 0;\n}\n\n \nstatic int sierra_submit_delayed_urbs(struct usb_serial_port *port)\n{\n\tstruct sierra_port_private *portdata = usb_get_serial_port_data(port);\n\tstruct sierra_intf_private *intfdata;\n\tstruct urb *urb;\n\tint ec = 0;\n\tint err;\n\n\tintfdata = usb_get_serial_data(port->serial);\n\n\tfor (;;) {\n\t\turb = usb_get_from_anchor(&portdata->delayed);\n\t\tif (!urb)\n\t\t\tbreak;\n\n\t\tusb_anchor_urb(urb, &portdata->active);\n\t\tintfdata->in_flight++;\n\t\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tdev_err(&port->dev, \"%s - submit urb failed: %d\",\n\t\t\t\t\t__func__, err);\n\t\t\tec++;\n\t\t\tintfdata->in_flight--;\n\t\t\tusb_unanchor_urb(urb);\n\t\t\tkfree(urb->transfer_buffer);\n\t\t\tusb_free_urb(urb);\n\n\t\t\tspin_lock(&portdata->lock);\n\t\t\tportdata->outstanding_urbs--;\n\t\t\tspin_unlock(&portdata->lock);\n\t\t}\n\t}\n\n\tif (ec)\n\t\treturn -EIO;\n\n\treturn 0;\n}\n\nstatic int sierra_resume(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *port;\n\tstruct sierra_intf_private *intfdata = usb_get_serial_data(serial);\n\tint ec = 0;\n\tint i, err;\n\n\tspin_lock_irq(&intfdata->susp_lock);\n\tfor (i = 0; i < serial->num_ports; i++) {\n\t\tport = serial->port[i];\n\n\t\tif (!tty_port_initialized(&port->port))\n\t\t\tcontinue;\n\n\t\terr = sierra_submit_delayed_urbs(port);\n\t\tif (err)\n\t\t\tec++;\n\n\t\terr = sierra_submit_rx_urbs(port, GFP_ATOMIC);\n\t\tif (err)\n\t\t\tec++;\n\t}\n\tintfdata->suspended = 0;\n\tspin_unlock_irq(&intfdata->susp_lock);\n\n\treturn ec ? -EIO : 0;\n}\n\n#else\n#define sierra_suspend NULL\n#define sierra_resume NULL\n#endif\n\nstatic struct usb_serial_driver sierra_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"sierra\",\n\t},\n\t.description       = \"Sierra USB modem\",\n\t.id_table          = id_table,\n\t.calc_num_ports\t   = sierra_calc_num_ports,\n\t.probe\t\t   = sierra_probe,\n\t.open              = sierra_open,\n\t.close             = sierra_close,\n\t.dtr_rts\t   = sierra_dtr_rts,\n\t.write             = sierra_write,\n\t.write_room        = sierra_write_room,\n\t.chars_in_buffer   = sierra_chars_in_buffer,\n\t.tiocmget          = sierra_tiocmget,\n\t.tiocmset          = sierra_tiocmset,\n\t.attach            = sierra_startup,\n\t.release           = sierra_release,\n\t.port_probe        = sierra_port_probe,\n\t.port_remove       = sierra_port_remove,\n\t.suspend\t   = sierra_suspend,\n\t.resume\t\t   = sierra_resume,\n\t.read_int_callback = sierra_instat_callback,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&sierra_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n\nmodule_param(nmea, bool, 0644);\nMODULE_PARM_DESC(nmea, \"NMEA streaming\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}