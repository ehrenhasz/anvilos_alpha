{
  "module_name": "ftdi_sio.c",
  "hash_id": "df8379241d1a9639394c390e7615c619fb7488911eaa34455e066d011c437e0e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/ftdi_sio.c",
  "human_readable_source": "\n \n\n \n \n \n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/serial.h>\n#include <linux/gpio/driver.h>\n#include <linux/usb/serial.h>\n#include \"ftdi_sio.h\"\n#include \"ftdi_sio_ids.h\"\n\n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>, Bill Ryder <bryder@sgi.com>, Kuba Ober <kuba@mareimbrium.org>, Andreas Mohr, Johan Hovold <jhovold@gmail.com>\"\n#define DRIVER_DESC \"USB FTDI Serial Converters Driver\"\n\nenum ftdi_chip_type {\n\tSIO,\n\tFT232A,\n\tFT232B,\n\tFT2232C,\n\tFT232R,\n\tFT232H,\n\tFT2232H,\n\tFT4232H,\n\tFT4232HA,\n\tFT232HP,\n\tFT233HP,\n\tFT2232HP,\n\tFT2233HP,\n\tFT4232HP,\n\tFT4233HP,\n\tFTX,\n};\n\nstruct ftdi_private {\n\tenum ftdi_chip_type chip_type;\n\tint baud_base;\t\t \n\tint custom_divisor;\t \n\tu16 last_set_data_value;  \n\tint flags;\t\t \n\tunsigned long last_dtr_rts;\t \n\tchar prev_status;         \n\tchar transmit_empty;\t \n\tu16 channel;\t\t \n\n\tspeed_t force_baud;\t \n\tint force_rtscts;\t \n\n\tunsigned int latency;\t\t \n\tunsigned short max_packet_size;\n\tstruct mutex cfg_lock;  \n#ifdef CONFIG_GPIOLIB\n\tstruct gpio_chip gc;\n\tstruct mutex gpio_lock;\t \n\tbool gpio_registered;\t \n\tbool gpio_used;\t\t \n\tu8 gpio_altfunc;\t \n\tu8 gpio_output;\t\t \n\tu8 gpio_value;\t\t \n#endif\n};\n\nstruct ftdi_quirk {\n\tint (*probe)(struct usb_serial *);\n\t \n\tvoid (*port_probe)(struct ftdi_private *);\n};\n\nstatic int   ftdi_jtag_probe(struct usb_serial *serial);\nstatic int   ftdi_NDI_device_setup(struct usb_serial *serial);\nstatic int   ftdi_stmclite_probe(struct usb_serial *serial);\nstatic int   ftdi_8u2232c_probe(struct usb_serial *serial);\nstatic void  ftdi_USB_UIRT_setup(struct ftdi_private *priv);\nstatic void  ftdi_HE_TIRA1_setup(struct ftdi_private *priv);\n\nstatic const struct ftdi_quirk ftdi_jtag_quirk = {\n\t.probe\t= ftdi_jtag_probe,\n};\n\nstatic const struct ftdi_quirk ftdi_NDI_device_quirk = {\n\t.probe\t= ftdi_NDI_device_setup,\n};\n\nstatic const struct ftdi_quirk ftdi_USB_UIRT_quirk = {\n\t.port_probe = ftdi_USB_UIRT_setup,\n};\n\nstatic const struct ftdi_quirk ftdi_HE_TIRA1_quirk = {\n\t.port_probe = ftdi_HE_TIRA1_setup,\n};\n\nstatic const struct ftdi_quirk ftdi_stmclite_quirk = {\n\t.probe\t= ftdi_stmclite_probe,\n};\n\nstatic const struct ftdi_quirk ftdi_8u2232c_quirk = {\n\t.probe\t= ftdi_8u2232c_probe,\n};\n\n \n\n\n\n \nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(FTDI_VID, FTDI_BRICK_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ZEITCONTROL_TAGTRACE_MIFARE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CTI_MINI_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CTI_NANO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_AMC232_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CANUSB_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CANDAPTER_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_BM_ATOM_NANO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NXTCAM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_EV3CON_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_4_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_5_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_6_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCS_DEVICE_7_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_USINT_CAT_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_USINT_WKEY_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_USINT_RS232_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ACTZWAVE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IRTRANS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IPLUS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IPLUS2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_DMX4ALL) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SIO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_8U232AM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_8U232AM_ALT_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_232RL_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_8U2232C_PID) ,\n\t\t.driver_info = (kernel_ulong_t)&ftdi_8u2232c_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_4232H_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_232H_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FTX_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT2233HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT4233HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT2232HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT4232HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT233HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT232HP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FT4232HA_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MICRO_CHAMELEON_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_RELAIS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_SNIFFER_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_THROTTLE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_GATEWAY_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_GBM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OPENDCC_GBM_BOOST_PID) },\n\t{ USB_DEVICE(NEWPORT_VID, NEWPORT_AGILIS_PID) },\n\t{ USB_DEVICE(NEWPORT_VID, NEWPORT_CONEX_CC_PID) },\n\t{ USB_DEVICE(NEWPORT_VID, NEWPORT_CONEX_AGP_PID) },\n\t{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_IOBOARD_PID) },\n\t{ USB_DEVICE(INTERBIOMETRICS_VID, INTERBIOMETRICS_MINI_IOBOARD_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SPROG_II) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TAGSYS_LP101_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TAGSYS_P200X_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_LENZ_LIUSB_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_632_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_634_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_547_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_633_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_631_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_635_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_640_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_XF_642_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_DSS20_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_URBAN_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_URBAN_1_PID) },\n\t{ USB_DEVICE(FTDI_NF_RIC_VID, FTDI_NF_RIC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_VNHCPCUSB_D_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_4_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_5_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MTXORB_6_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_R2000KU_TRUE_RNG) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_VARDAAN_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_AUTO_M3_OP_COM_V2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0100_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0101_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0102_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0103_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0104_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0105_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0106_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0107_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0108_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0109_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_010F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0110_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0111_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0112_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0113_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0114_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0115_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0116_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0117_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0118_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0119_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_011F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0120_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0121_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0122_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0123_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0124_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0125_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0126_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0127_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0128_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0129_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_012F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0130_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0131_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0132_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0133_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0134_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0135_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0136_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0137_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0138_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0139_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_013F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0140_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0141_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0142_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0143_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0144_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0145_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0146_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0147_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0148_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0149_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_014F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0150_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0151_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0152_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0153_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0154_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0155_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0156_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0157_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0158_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0159_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_015F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0160_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0161_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0162_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0163_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0164_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0165_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0166_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0167_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0168_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0169_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_016F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0170_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0171_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0172_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0173_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0174_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0175_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0176_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0177_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0178_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0179_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_017F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0180_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0181_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0182_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0183_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0184_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0185_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0186_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0187_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0188_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0189_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_018F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0190_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0191_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0192_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0193_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0194_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0195_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0196_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0197_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0198_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_0199_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_019F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01A9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AD_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01AF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01B9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BD_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01BF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01C9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CD_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01CF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01D9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DD_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01DF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01E9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01EA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01EB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01EC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01ED_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01EE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01EF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F0_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F1_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F2_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F3_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F4_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F5_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F6_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F7_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F8_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01F9_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FA_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FB_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FC_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FD_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FE_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_01FF_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_4701_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9300_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9301_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9302_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9303_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9304_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9305_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9306_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9307_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9308_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9309_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_930F_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9310_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9311_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9312_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9313_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9314_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9315_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9316_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9317_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9318_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_9319_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931A_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931B_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931C_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931D_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931E_PID) },\n\t{ USB_DEVICE(MTXORB_VID, MTXORB_FTDI_RANGE_931F_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PERLE_ULTRAPORT_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PIEGROUP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TNC_X_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_USBX_707_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2101_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2102_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2103_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2104_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2106_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2201_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2201_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2202_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2202_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2203_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2203_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2401_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2401_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2401_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2401_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2402_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2402_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2402_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2402_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2403_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2403_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2403_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2403_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_5_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_6_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_7_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2801_8_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_5_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_6_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_7_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2802_8_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_4_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_5_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_6_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_7_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803_8_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803R_1_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803R_2_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803R_3_PID) },\n\t{ USB_DEVICE(SEALEVEL_VID, SEALEVEL_2803R_4_PID) },\n\t{ USB_DEVICE(IDTECH_VID, IDTECH_IDT1221U_PID) },\n\t{ USB_DEVICE(OCT_VID, OCT_US101_PID) },\n\t{ USB_DEVICE(OCT_VID, OCT_DK201_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_HE_TIRA1_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_HE_TIRA1_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_USB_UIRT_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_USB_UIRT_quirk },\n\t{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_1) },\n\t{ USB_DEVICE(FTDI_VID, PROTEGO_R2X0) },\n\t{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_3) },\n\t{ USB_DEVICE(FTDI_VID, PROTEGO_SPECIAL_4) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E808_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E809_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80A_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80B_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80C_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80D_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80E_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E80F_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E888_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E889_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88A_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88B_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88C_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88D_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88E_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GUDEADS_E88F_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UO100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UM100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UR100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_ALC8500_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PYRAMID_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_FHZ1000PC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_US485_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_PICPRO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_PCMCIA_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_PK1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_RS232MON_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_APP70_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_PEDO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IBS_PROD_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TAVIR_STK500_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TIAO_UMPA_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLX_PLUS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NT_ORION_IO_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONMX_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2WI_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX3_PID) },\n\t \n\t{ USB_DEVICE(FTDI_ELV_VID, FTDI_ELV_WS300_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_USR_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_MSM1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_KL100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS550_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_EC3000_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS888_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_TWS550_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_FEM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_CLI7000_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_PPS7330_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFM100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UDF77_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UIO88_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UAD8_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UDA7_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_USI2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_T1100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_PCD200_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_ULA200_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_CSI8_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_EM1000DL_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_PCK100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_RFP500_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_FS20SIG_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UTP8_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS300PC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS444PC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_FHZ1300PC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_EM1010PC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS500_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_HS485_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_UMS100_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },\n\t{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },\n\t{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },\n\t{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, LINX_FUTURE_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, LINX_FUTURE_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU20_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU40_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSMACHX_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSLOAD_N_GO_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSICDU64_4_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CCSPRIME8_5_PID) },\n\t{ USB_DEVICE(FTDI_VID, INSIDE_ACCESSO) },\n\t{ USB_DEVICE(INTREPID_VID, INTREPID_VALUECAN_PID) },\n\t{ USB_DEVICE(INTREPID_VID, INTREPID_NEOVI_PID) },\n\t{ USB_DEVICE(FALCOM_VID, FALCOM_TWIST_PID) },\n\t{ USB_DEVICE(FALCOM_VID, FALCOM_SAMBA_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SUUNTO_SPORTS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OCEANIC_PID) },\n\t{ USB_DEVICE(TTI_VID, TTI_QL355P_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_RM_CANVIEW_PID) },\n\t{ USB_DEVICE(ACTON_VID, ACTON_SPECTRAPRO_PID) },\n\t{ USB_DEVICE(CONTEC_VID, CONTEC_COM1USBH_PID) },\n\t{ USB_DEVICE(MITSUBISHI_VID, MITSUBISHI_FXUSB_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USOTL4_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USTL4_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USPTL4_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2DR_2_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USO9ML2DR_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4DR2_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_USOPTL4DR_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_485USB9F_2W_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_485USB9F_4W_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_232USB9M_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_485USBTB_2W_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_485USBTB_4W_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_TTL5USB9M_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_TTL3USB9M_PID) },\n\t{ USB_DEVICE(BANDB_VID, BANDB_ZZ_PROG1_USB_PID) },\n\t{ USB_DEVICE(FTDI_VID, EVER_ECO_PRO_CDS) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_4N_GALAXY_DE_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_4N_GALAXY_DE_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_4N_GALAXY_DE_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_0_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_1_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_2_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_4_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_5_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_6_PID) },\n\t{ USB_DEVICE(FTDI_VID, XSENS_CONVERTER_7_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_DONGLE_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_AWINDA_STATION_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_CONVERTER_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_MTDEVBOARD_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_MTIUSBCONVERTER_PID) },\n\t{ USB_DEVICE(XSENS_VID, XSENS_MTW_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },\n\t{ USB_DEVICE(MOBILITY_VID, MOBILITY_USB_SERIAL_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ACTIVE_ROBOTS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_KW_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_YS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_Y6_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_Y8_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_IC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_DB9_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_RS232_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MHAM_Y9_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TERATRONIK_VCP_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TERATRONIK_D2XX_PID) },\n\t{ USB_DEVICE(EVOLUTION_VID, EVOLUTION_ER1_PID) },\n\t{ USB_DEVICE(EVOLUTION_VID, EVO_HYBRID_PID) },\n\t{ USB_DEVICE(EVOLUTION_VID, EVO_RCM4_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ARTEMIS_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16C_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16HR_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16HRC_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ATIK_ATK16IC_PID) },\n\t{ USB_DEVICE(KOBIL_VID, KOBIL_CONV_B1_PID) },\n\t{ USB_DEVICE(KOBIL_VID, KOBIL_CONV_KAAN_PID) },\n\t{ USB_DEVICE(POSIFLEX_VID, POSIFLEX_PP7000_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TTUSB_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ECLO_COM_1WIRE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_WESTREX_MODEL_777_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_WESTREX_MODEL_8900F_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PCDJ_DAC2_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_RRCIRKITS_LOCOBUFFER_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ASK_RDR400_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NZR_SEM_USB_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_1_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_OPC_U_UC_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2C1_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2C2_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2D_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2VT_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2VR_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP4KVT_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP4KVR_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2KVT_PID) },\n\t{ USB_DEVICE(ICOM_VID, ICOM_ID_RP2KVR_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ACG_HFDUAL_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_YEI_SERVOCENTER31_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_THORLABS_PID) },\n\t{ USB_DEVICE(TESTO_VID, TESTO_1_PID) },\n\t{ USB_DEVICE(TESTO_VID, TESTO_3_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_GAMMA_SCOUT_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TACTRIX_OPENPORT_13M_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TACTRIX_OPENPORT_13S_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TACTRIX_OPENPORT_13U_PID) },\n\t{ USB_DEVICE(ELEKTOR_VID, ELEKTOR_FT323R_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NDI_HUC_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NDI_SPECTRA_SCU_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NDI_FUTURE_2_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NDI_FUTURE_3_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_NDI_AURORA_SCU_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_NDI_device_quirk },\n\t{ USB_DEVICE(TELLDUS_VID, TELLDUS_TELLSTICK_PID) },\n\t{ USB_DEVICE(NOVITUS_VID, NOVITUS_BONO_E_PID) },\n\t{ USB_DEVICE(FTDI_VID, RTSYSTEMS_USB_VX8_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_S03_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_59_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_57A_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_57B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_29A_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_29B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_29F_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_62B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_S01_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_63_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_29C_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_81B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_82B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_K5D_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_K4Y_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_K5G_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_S05_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_60_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_61_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_62_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_63B_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_64_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_65_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_92_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_92D_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_W5R_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_A5R_PID) },\n\t{ USB_DEVICE(RTSYSTEMS_VID, RTSYSTEMS_USB_PW1_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_MAXSTREAM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PHI_FISCO_PID) },\n\t{ USB_DEVICE(TML_VID, TML_USB_SERIAL_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_ELSTER_UNICOM_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_JTAGCABLEII_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_ISPCABLEIII_PID) },\n\t{ USB_DEVICE(FTDI_VID, CYBER_CORTEX_AV_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE_INTERFACE_NUMBER(OLIMEX_VID, OLIMEX_ARM_USB_OCD_PID, 1) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(OLIMEX_VID, OLIMEX_ARM_USB_OCD_H_PID, 1) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(OLIMEX_VID, OLIMEX_ARM_USB_TINY_PID, 1) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(OLIMEX_VID, OLIMEX_ARM_USB_TINY_H_PID, 1) },\n\t{ USB_DEVICE(FIC_VID, FIC_NEO1973_DEBUG_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_OOCDLINK_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, LMI_LM3S_DEVEL_BOARD_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, LMI_LM3S_EVAL_BOARD_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, LMI_LM3S_ICDI_BOARD_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_TURTELIZER_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },\n\t{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_SCU18) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_REU_TINY_PID) },\n\n\t \n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB485_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_AP485_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB422_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB485_2_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_AP485_2_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB422_2_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB485S_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB485C_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_LEC_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SB232_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_TMU_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_IRAMP_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_DRAK5_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO8x8_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO4x4_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO2x2_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO10x1_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO30x3_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO60x3_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO2x16_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_QUIDO3x32_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_DRAK6_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_UPSUSB_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_MU_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_SIMUKEY_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_AD4USB_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_GMUX_PID) },\n\t{ USB_DEVICE(PAPOUCH_VID, PAPOUCH_GMSR_PID) },\n\n\t{ USB_DEVICE(FTDI_VID, FTDI_DOMINTELL_DGQG_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_DOMINTELL_DUSB_PID) },\n\t{ USB_DEVICE(ALTI2_VID, ALTI2_N3_PID) },\n\t{ USB_DEVICE(FTDI_VID, DIEBOLD_BCS_SE923_PID) },\n\t{ USB_DEVICE(ATMEL_VID, STK541_PID) },\n\t{ USB_DEVICE(DE_VID, STB_PID) },\n\t{ USB_DEVICE(DE_VID, WHT_PID) },\n\t{ USB_DEVICE(ADI_VID, ADI_GNICE_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(ADI_VID, ADI_GNICEPLUS_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE_AND_INTERFACE_INFO(MICROCHIP_VID, MICROCHIP_USB_BOARD_PID,\n\t\t\t\t\tUSB_CLASS_VENDOR_SPEC,\n\t\t\t\t\tUSB_SUBCLASS_VENDOR_SPEC, 0x00) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(ACTEL_VID, MICROSEMI_ARROW_SF2PLUS_BOARD_PID, 2) },\n\t{ USB_DEVICE(JETI_VID, JETI_SPC1201_PID) },\n\t{ USB_DEVICE(MARVELL_VID, MARVELL_SHEEVAPLUG_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(LARSENBRUSGAARD_VID, LB_ALTITRACK_PID) },\n\t{ USB_DEVICE(GN_OTOMETRICS_VID, AURICAL_USB_PID) },\n\t{ USB_DEVICE(FTDI_VID, PI_C865_PID) },\n\t{ USB_DEVICE(FTDI_VID, PI_C857_PID) },\n\t{ USB_DEVICE(PI_VID, PI_C866_PID) },\n\t{ USB_DEVICE(PI_VID, PI_C663_PID) },\n\t{ USB_DEVICE(PI_VID, PI_C725_PID) },\n\t{ USB_DEVICE(PI_VID, PI_E517_PID) },\n\t{ USB_DEVICE(PI_VID, PI_C863_PID) },\n\t{ USB_DEVICE(PI_VID, PI_E861_PID) },\n\t{ USB_DEVICE(PI_VID, PI_C867_PID) },\n\t{ USB_DEVICE(PI_VID, PI_E609_PID) },\n\t{ USB_DEVICE(PI_VID, PI_E709_PID) },\n\t{ USB_DEVICE(PI_VID, PI_100F_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1011_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1012_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1013_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1014_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1015_PID) },\n\t{ USB_DEVICE(PI_VID, PI_1016_PID) },\n\t{ USB_DEVICE(KONDO_VID, KONDO_USB_SERIAL_PID) },\n\t{ USB_DEVICE(BAYER_VID, BAYER_CONTOUR_CABLE_PID) },\n\t{ USB_DEVICE(FTDI_VID, MARVELL_OPENRD_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, TI_XDS100V2_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, HAMEG_HO820_PID) },\n\t{ USB_DEVICE(FTDI_VID, HAMEG_HO720_PID) },\n\t{ USB_DEVICE(FTDI_VID, HAMEG_HO730_PID) },\n\t{ USB_DEVICE(FTDI_VID, HAMEG_HO870_PID) },\n\t{ USB_DEVICE(FTDI_VID, MJSG_GENERIC_PID) },\n\t{ USB_DEVICE(FTDI_VID, MJSG_SR_RADIO_PID) },\n\t{ USB_DEVICE(FTDI_VID, MJSG_HD_RADIO_PID) },\n\t{ USB_DEVICE(FTDI_VID, MJSG_XM_RADIO_PID) },\n\t{ USB_DEVICE(FTDI_VID, XVERVE_SIGNALYZER_ST_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, XVERVE_SIGNALYZER_SLITE_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, XVERVE_SIGNALYZER_SH2_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, XVERVE_SIGNALYZER_SH4_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, SEGWAY_RMP200_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACCESIO_COM4SM_PID) },\n\t{ USB_DEVICE(IONICS_VID, IONICS_PLUGCOMPUTER_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_24_MASTER_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_PC_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_USB_DMX_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_MIDI_TIMECODE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_MINI_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_MAXI_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_MEDIA_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CHAMSYS_WING_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_LOGBOOKML_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_LS_LOGBOOK_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_SCIENCESCOPE_HS_LOGBOOK_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_CINTERION_MC55I_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FHE_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_DOTEC_PID) },\n\t{ USB_DEVICE(QIHARDWARE_VID, MILKYMISTONE_JTAGSERIAL_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(ST_VID, ST_STMCLT_2232_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(ST_VID, ST_STMCLT_4232_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_stmclite_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_RF_R106) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_DISTORTEC_JTAG_LOCK_PICK_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_LUMEL_PD12_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, FTDI_CT_COMET_PID) },\n\t{ USB_DEVICE(FTDI_VID, FTDI_Z3X_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, FTDI_CRESSI_PID) },\n\t \n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_VX_001_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_VX_012_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_VX_023_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_VX_034_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_101_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_159_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_3_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_4_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_5_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_6_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_7_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_160_8_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_235_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_257_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_279_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_279_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_279_3_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_279_4_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_313_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_320_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_324_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_346_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_346_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_357_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_606_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_606_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_606_3_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_701_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_701_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_842_1_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_842_2_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_842_3_PID) },\n\t{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_842_4_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },\n\t \n\t{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC1798_PID, 1) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC2X7_PID, 1) },\n\t \n\t{ USB_DEVICE(GE_HEALTHCARE_VID, GE_HEALTHCARE_NEMO_TRACKER_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_NDC_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_USG_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_NGT_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_NGW_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_UID_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_USA_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_NGX_PID) },\n\t{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AF_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEAGAUGE_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASWITCH_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_NMEA2000_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ETHERNET_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_WIFI_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_DISPLAY_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_LITE_PID) },\n\t{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ANALOG_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, BELIMO_ZTH_PID) },\n\t{ USB_DEVICE(FTDI_VID, BELIMO_ZIP_PID) },\n\t \n\t{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },\n\t{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },\n\t{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },\n\t{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },\n\t{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },\n\t{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },\n\t{ USB_DEVICE(AIRBUS_DS_VID, AIRBUS_DS_P8GR) },\n\t \n\t{ USB_DEVICE(EZPROTOTYPES_VID, HJELMSLUND_USB485_ISO_PID) },\n\t{ USB_DEVICE_INTERFACE_NUMBER(UNJO_VID, UNJO_ISODEBUG_V1_PID, 1) },\n\t \n\t{ USB_DEVICE(FTDI_VID, FTDI_SIENNA_PID) },\n\t{ USB_DEVICE(ECHELON_VID, ECHELON_U20_PID) },\n\t \n\t{ USB_DEVICE(IDS_VID, IDS_SI31A_PID) },\n\t{ USB_DEVICE(IDS_VID, IDS_CM31A_PID) },\n\t \n\t{ USB_DEVICE(OMRON_VID, OMRON_CS1W_CIF31_PID) },\n\t \n\t{ USB_DEVICE(UBLOX_VID, UBLOX_C099F9P_ZED_PID) },\n\t{ USB_DEVICE(UBLOX_VID, UBLOX_C099F9P_ODIN_PID) },\n\t \n\t{ USB_DEVICE(FTDI_VID, FTDI_FALCONIA_JTAG_BUF_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ USB_DEVICE(FTDI_VID, FTDI_FALCONIA_JTAG_UNBUF_PID),\n\t\t.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\nstatic const char *ftdi_chip_name[] = {\n\t[SIO]\t\t= \"SIO\",\t \n\t[FT232A]\t= \"FT232A\",\n\t[FT232B]\t= \"FT232B\",\n\t[FT2232C]\t= \"FT2232C/D\",\n\t[FT232R]\t= \"FT232R\",\n\t[FT232H]\t= \"FT232H\",\n\t[FT2232H]\t= \"FT2232H\",\n\t[FT4232H]\t= \"FT4232H\",\n\t[FT4232HA]\t= \"FT4232HA\",\n\t[FT232HP]\t= \"FT232HP\",\n\t[FT233HP]\t= \"FT233HP\",\n\t[FT2232HP]\t= \"FT2232HP\",\n\t[FT2233HP]\t= \"FT2233HP\",\n\t[FT4232HP]\t= \"FT4232HP\",\n\t[FT4233HP]\t= \"FT4233HP\",\n\t[FTX]\t\t= \"FT-X\",\n};\n\n\n \n#define FTDI_STATUS_B0_MASK\t(FTDI_RS0_CTS | FTDI_RS0_DSR | FTDI_RS0_RI | FTDI_RS0_RLSD)\n#define FTDI_STATUS_B1_MASK\t(FTDI_RS_BI)\n \n\nstatic void ftdi_set_termios(struct tty_struct *tty,\n\t\t\t     struct usb_serial_port *port,\n\t\t\t     const struct ktermios *old_termios);\nstatic int ftdi_get_modem_status(struct usb_serial_port *port,\n\t\t\t\t\t\tunsigned char status[2]);\n\n#define WDR_TIMEOUT 5000  \n#define WDR_SHORT_TIMEOUT 1000\t \n\n \n\nstatic unsigned short int ftdi_232am_baud_base_to_divisor(int baud, int base)\n{\n\tunsigned short int divisor;\n\t \n\tint divisor3 = DIV_ROUND_CLOSEST(base, 2 * baud);\n\tif ((divisor3 & 0x7) == 7)\n\t\tdivisor3++;  \n\tdivisor = divisor3 >> 3;\n\tdivisor3 &= 0x7;\n\tif (divisor3 == 1)\n\t\tdivisor |= 0xc000;\t \n\telse if (divisor3 >= 4)\n\t\tdivisor |= 0x4000;\t \n\telse if (divisor3 != 0)\n\t\tdivisor |= 0x8000;\t \n\telse if (divisor == 1)\n\t\tdivisor = 0;\t\t \n\treturn divisor;\n}\n\nstatic unsigned short int ftdi_232am_baud_to_divisor(int baud)\n{\n\t return ftdi_232am_baud_base_to_divisor(baud, 48000000);\n}\n\nstatic u32 ftdi_232bm_baud_base_to_divisor(int baud, int base)\n{\n\tstatic const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };\n\tu32 divisor;\n\t \n\tint divisor3 = DIV_ROUND_CLOSEST(base, 2 * baud);\n\tdivisor = divisor3 >> 3;\n\tdivisor |= (u32)divfrac[divisor3 & 0x7] << 14;\n\t \n\tif (divisor == 1)\t\t \n\t\tdivisor = 0;\n\telse if (divisor == 0x4001)\t \n\t\tdivisor = 1;\n\treturn divisor;\n}\n\nstatic u32 ftdi_232bm_baud_to_divisor(int baud)\n{\n\t return ftdi_232bm_baud_base_to_divisor(baud, 48000000);\n}\n\nstatic u32 ftdi_2232h_baud_base_to_divisor(int baud, int base)\n{\n\tstatic const unsigned char divfrac[8] = { 0, 3, 2, 4, 1, 5, 6, 7 };\n\tu32 divisor;\n\tint divisor3;\n\n\t \n\tdivisor3 = DIV_ROUND_CLOSEST(8 * base, 10 * baud);\n\n\tdivisor = divisor3 >> 3;\n\tdivisor |= (u32)divfrac[divisor3 & 0x7] << 14;\n\t \n\tif (divisor == 1)\t\t \n\t\tdivisor = 0;\n\telse if (divisor == 0x4001)\t \n\t\tdivisor = 1;\n\t \n\tdivisor |= 0x00020000;\n\treturn divisor;\n}\n\nstatic u32 ftdi_2232h_baud_to_divisor(int baud)\n{\n\t return ftdi_2232h_baud_base_to_divisor(baud, 120000000);\n}\n\n#define set_mctrl(port, set)\t\tupdate_mctrl((port), (set), 0)\n#define clear_mctrl(port, clear)\tupdate_mctrl((port), 0, (clear))\n\nstatic int update_mctrl(struct usb_serial_port *port, unsigned int set,\n\t\t\t\t\t\t\tunsigned int clear)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tunsigned value;\n\tint rv;\n\n\tif (((set | clear) & (TIOCM_DTR | TIOCM_RTS)) == 0) {\n\t\tdev_dbg(dev, \"%s - DTR|RTS not being set|cleared\\n\", __func__);\n\t\treturn 0;\t \n\t}\n\n\tclear &= ~set;\t \n\tvalue = 0;\n\tif (clear & TIOCM_DTR)\n\t\tvalue |= FTDI_SIO_SET_DTR_LOW;\n\tif (clear & TIOCM_RTS)\n\t\tvalue |= FTDI_SIO_SET_RTS_LOW;\n\tif (set & TIOCM_DTR)\n\t\tvalue |= FTDI_SIO_SET_DTR_HIGH;\n\tif (set & TIOCM_RTS)\n\t\tvalue |= FTDI_SIO_SET_RTS_HIGH;\n\trv = usb_control_msg(port->serial->dev,\n\t\t\t       usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t       FTDI_SIO_SET_MODEM_CTRL_REQUEST,\n\t\t\t       FTDI_SIO_SET_MODEM_CTRL_REQUEST_TYPE,\n\t\t\t       value, priv->channel,\n\t\t\t       NULL, 0, WDR_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_dbg(dev, \"%s Error from MODEM_CTRL urb: DTR %s, RTS %s\\n\",\n\t\t\t__func__,\n\t\t\t(set & TIOCM_DTR) ? \"HIGH\" : (clear & TIOCM_DTR) ? \"LOW\" : \"unchanged\",\n\t\t\t(set & TIOCM_RTS) ? \"HIGH\" : (clear & TIOCM_RTS) ? \"LOW\" : \"unchanged\");\n\t\trv = usb_translate_errors(rv);\n\t} else {\n\t\tdev_dbg(dev, \"%s - DTR %s, RTS %s\\n\", __func__,\n\t\t\t(set & TIOCM_DTR) ? \"HIGH\" : (clear & TIOCM_DTR) ? \"LOW\" : \"unchanged\",\n\t\t\t(set & TIOCM_RTS) ? \"HIGH\" : (clear & TIOCM_RTS) ? \"LOW\" : \"unchanged\");\n\t\t \n\t\tpriv->last_dtr_rts = (priv->last_dtr_rts & ~clear) | set;\n\t}\n\treturn rv;\n}\n\n\nstatic u32 get_ftdi_divisor(struct tty_struct *tty,\n\t\t\t\t\t\tstruct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct device *dev = &port->dev;\n\tu32 div_value = 0;\n\tint div_okay = 1;\n\tint baud;\n\n\tbaud = tty_get_baud_rate(tty);\n\tdev_dbg(dev, \"%s - tty_get_baud_rate reports speed %d\\n\", __func__, baud);\n\n\t \n\tif (baud == 38400 &&\n\t    ((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST) &&\n\t     (priv->custom_divisor)) {\n\t\tbaud = priv->baud_base / priv->custom_divisor;\n\t\tdev_dbg(dev, \"%s - custom divisor %d sets baud rate to %d\\n\",\n\t\t\t__func__, priv->custom_divisor, baud);\n\t}\n\n\tif (!baud)\n\t\tbaud = 9600;\n\tswitch (priv->chip_type) {\n\tcase SIO:\n\t\tswitch (baud) {\n\t\tcase 300: div_value = ftdi_sio_b300; break;\n\t\tcase 600: div_value = ftdi_sio_b600; break;\n\t\tcase 1200: div_value = ftdi_sio_b1200; break;\n\t\tcase 2400: div_value = ftdi_sio_b2400; break;\n\t\tcase 4800: div_value = ftdi_sio_b4800; break;\n\t\tcase 9600: div_value = ftdi_sio_b9600; break;\n\t\tcase 19200: div_value = ftdi_sio_b19200; break;\n\t\tcase 38400: div_value = ftdi_sio_b38400; break;\n\t\tcase 57600: div_value = ftdi_sio_b57600;  break;\n\t\tcase 115200: div_value = ftdi_sio_b115200; break;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \"%s - Baudrate (%d) requested is not supported\\n\",\n\t\t\t\t__func__,  baud);\n\t\t\tdiv_value = ftdi_sio_b9600;\n\t\t\tbaud = 9600;\n\t\t\tdiv_okay = 0;\n\t\t}\n\t\tbreak;\n\tcase FT232A:\n\t\tif (baud <= 3000000) {\n\t\t\tdiv_value = ftdi_232am_baud_to_divisor(baud);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - Baud rate too high!\\n\", __func__);\n\t\t\tbaud = 9600;\n\t\t\tdiv_value = ftdi_232am_baud_to_divisor(9600);\n\t\t\tdiv_okay = 0;\n\t\t}\n\t\tbreak;\n\tcase FT232B:\n\tcase FT2232C:\n\tcase FT232R:\n\tcase FTX:\n\t\tif (baud <= 3000000) {\n\t\t\tu16 product_id = le16_to_cpu(\n\t\t\t\tport->serial->dev->descriptor.idProduct);\n\t\t\tif (((product_id == FTDI_NDI_HUC_PID)\t\t||\n\t\t\t     (product_id == FTDI_NDI_SPECTRA_SCU_PID)\t||\n\t\t\t     (product_id == FTDI_NDI_FUTURE_2_PID)\t||\n\t\t\t     (product_id == FTDI_NDI_FUTURE_3_PID)\t||\n\t\t\t     (product_id == FTDI_NDI_AURORA_SCU_PID))\t&&\n\t\t\t    (baud == 19200)) {\n\t\t\t\tbaud = 1200000;\n\t\t\t}\n\t\t\tdiv_value = ftdi_232bm_baud_to_divisor(baud);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - Baud rate too high!\\n\", __func__);\n\t\t\tdiv_value = ftdi_232bm_baud_to_divisor(9600);\n\t\t\tdiv_okay = 0;\n\t\t\tbaud = 9600;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tif ((baud <= 12000000) && (baud >= 1200)) {\n\t\t\tdiv_value = ftdi_2232h_baud_to_divisor(baud);\n\t\t} else if (baud < 1200) {\n\t\t\tdiv_value = ftdi_232bm_baud_to_divisor(baud);\n\t\t} else {\n\t\t\tdev_dbg(dev, \"%s - Baud rate too high!\\n\", __func__);\n\t\t\tdiv_value = ftdi_232bm_baud_to_divisor(9600);\n\t\t\tdiv_okay = 0;\n\t\t\tbaud = 9600;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (div_okay) {\n\t\tdev_dbg(dev, \"%s - Baud rate set to %d (divisor 0x%lX) on chip %s\\n\",\n\t\t\t__func__, baud, (unsigned long)div_value,\n\t\t\tftdi_chip_name[priv->chip_type]);\n\t}\n\n\ttty_encode_baud_rate(tty, baud, baud);\n\treturn div_value;\n}\n\nstatic int change_speed(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tu16 value;\n\tu16 index;\n\tu32 index_value;\n\tint rv;\n\n\tindex_value = get_ftdi_divisor(tty, port);\n\tvalue = (u16)index_value;\n\tindex = (u16)(index_value >> 16);\n\tif (priv->channel)\n\t\tindex = (u16)((index << 8) | priv->channel);\n\n\trv = usb_control_msg(port->serial->dev,\n\t\t\t    usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t    FTDI_SIO_SET_BAUDRATE_REQUEST,\n\t\t\t    FTDI_SIO_SET_BAUDRATE_REQUEST_TYPE,\n\t\t\t    value, index,\n\t\t\t    NULL, 0, WDR_SHORT_TIMEOUT);\n\treturn rv;\n}\n\nstatic int write_latency_timer(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *udev = port->serial->dev;\n\tint rv;\n\tint l = priv->latency;\n\n\tif (priv->chip_type == SIO || priv->chip_type == FT232A)\n\t\treturn -EINVAL;\n\n\tif (priv->flags & ASYNC_LOW_LATENCY)\n\t\tl = 1;\n\n\tdev_dbg(&port->dev, \"%s: setting latency timer = %i\\n\", __func__, l);\n\n\trv = usb_control_msg(udev,\n\t\t\t     usb_sndctrlpipe(udev, 0),\n\t\t\t     FTDI_SIO_SET_LATENCY_TIMER_REQUEST,\n\t\t\t     FTDI_SIO_SET_LATENCY_TIMER_REQUEST_TYPE,\n\t\t\t     l, priv->channel,\n\t\t\t     NULL, 0, WDR_TIMEOUT);\n\tif (rv < 0)\n\t\tdev_err(&port->dev, \"Unable to write latency timer: %i\\n\", rv);\n\treturn rv;\n}\n\nstatic int _read_latency_timer(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *udev = port->serial->dev;\n\tu8 buf;\n\tint rv;\n\n\trv = usb_control_msg_recv(udev, 0, FTDI_SIO_GET_LATENCY_TIMER_REQUEST,\n\t\t\t\t  FTDI_SIO_GET_LATENCY_TIMER_REQUEST_TYPE, 0,\n\t\t\t\t  priv->channel, &buf, 1, WDR_TIMEOUT,\n\t\t\t\t  GFP_KERNEL);\n\tif (rv == 0)\n\t\trv = buf;\n\n\treturn rv;\n}\n\nstatic int read_latency_timer(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tint rv;\n\n\tif (priv->chip_type == SIO || priv->chip_type == FT232A)\n\t\treturn -EINVAL;\n\n\trv = _read_latency_timer(port);\n\tif (rv < 0) {\n\t\tdev_err(&port->dev, \"Unable to read latency timer: %i\\n\", rv);\n\t\treturn rv;\n\t}\n\n\tpriv->latency = rv;\n\n\treturn 0;\n}\n\nstatic void get_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tss->flags = priv->flags;\n\tss->baud_base = priv->baud_base;\n\tss->custom_divisor = priv->custom_divisor;\n}\n\nstatic int set_serial_info(struct tty_struct *tty, struct serial_struct *ss)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tint old_flags, old_divisor;\n\n\tmutex_lock(&priv->cfg_lock);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tif ((ss->flags ^ priv->flags) & ~ASYNC_USR_MASK) {\n\t\t\tmutex_unlock(&priv->cfg_lock);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\told_flags = priv->flags;\n\told_divisor = priv->custom_divisor;\n\n\tpriv->flags = ss->flags & ASYNC_FLAGS;\n\tpriv->custom_divisor = ss->custom_divisor;\n\n\twrite_latency_timer(port);\n\n\tif ((priv->flags ^ old_flags) & ASYNC_SPD_MASK ||\n\t\t\t((priv->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&\n\t\t\t priv->custom_divisor != old_divisor)) {\n\n\t\t \n\t\tif (priv->flags & ASYNC_SPD_MASK)\n\t\t\tdev_warn_ratelimited(&port->dev, \"use of SPD flags is deprecated\\n\");\n\n\t\tchange_speed(tty, port);\n\t}\n\tmutex_unlock(&priv->cfg_lock);\n\treturn 0;\n}\n\nstatic int get_lsr_info(struct usb_serial_port *port,\n\t\t\tunsigned int __user *retinfo)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tunsigned int result = 0;\n\n\tif (priv->transmit_empty)\n\t\tresult = TIOCSER_TEMT;\n\n\tif (copy_to_user(retinfo, &result, sizeof(unsigned int)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n\nstatic int ftdi_determine_type(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_device *udev = serial->dev;\n\tunsigned int version, ifnum;\n\n\tversion = le16_to_cpu(udev->descriptor.bcdDevice);\n\tifnum = serial->interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t \n\tpriv->baud_base = 120000000 / 2;\n\tpriv->channel = CHANNEL_A + ifnum;\n\n\tswitch (version) {\n\tcase 0x200:\n\t\tpriv->chip_type = FT232A;\n\t\tpriv->baud_base = 48000000 / 2;\n\t\tpriv->channel = 0;\n\t\t \n\t\tif (udev->descriptor.iSerialNumber == 0 &&\n\t\t\t\t_read_latency_timer(port) >= 0) {\n\t\t\tpriv->chip_type = FT232B;\n\t\t}\n\t\tbreak;\n\tcase 0x400:\n\t\tpriv->chip_type = FT232B;\n\t\tpriv->baud_base = 48000000 / 2;\n\t\tpriv->channel = 0;\n\t\tbreak;\n\tcase 0x500:\n\t\tpriv->chip_type = FT2232C;\n\t\tpriv->baud_base = 48000000 / 2;\n\t\tbreak;\n\tcase 0x600:\n\t\tpriv->chip_type = FT232R;\n\t\tpriv->baud_base = 48000000 / 2;\n\t\tpriv->channel = 0;\n\t\tbreak;\n\tcase 0x700:\n\t\tpriv->chip_type = FT2232H;\n\t\tbreak;\n\tcase 0x800:\n\t\tpriv->chip_type = FT4232H;\n\t\tbreak;\n\tcase 0x900:\n\t\tpriv->chip_type = FT232H;\n\t\tbreak;\n\tcase 0x1000:\n\t\tpriv->chip_type = FTX;\n\t\tpriv->baud_base = 48000000 / 2;\n\t\tbreak;\n\tcase 0x2800:\n\t\tpriv->chip_type = FT2233HP;\n\t\tbreak;\n\tcase 0x2900:\n\t\tpriv->chip_type = FT4233HP;\n\t\tbreak;\n\tcase 0x3000:\n\t\tpriv->chip_type = FT2232HP;\n\t\tbreak;\n\tcase 0x3100:\n\t\tpriv->chip_type = FT4232HP;\n\t\tbreak;\n\tcase 0x3200:\n\t\tpriv->chip_type = FT233HP;\n\t\tbreak;\n\tcase 0x3300:\n\t\tpriv->chip_type = FT232HP;\n\t\tbreak;\n\tcase 0x3600:\n\t\tpriv->chip_type = FT4232HA;\n\t\tbreak;\n\tdefault:\n\t\tif (version < 0x200) {\n\t\t\tpriv->chip_type = SIO;\n\t\t\tpriv->baud_base = 12000000 / 16;\n\t\t\tpriv->channel = 0;\n\t\t} else {\n\t\t\tdev_err(&port->dev, \"unknown device type: 0x%02x\\n\", version);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tdev_info(&udev->dev, \"Detected %s\\n\", ftdi_chip_name[priv->chip_type]);\n\n\treturn 0;\n}\n\n\n \nstatic void ftdi_set_max_packet_size(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_interface *interface = port->serial->interface;\n\tstruct usb_endpoint_descriptor *ep_desc;\n\tunsigned num_endpoints;\n\tunsigned i;\n\n\tnum_endpoints = interface->cur_altsetting->desc.bNumEndpoints;\n\tif (!num_endpoints)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < num_endpoints; i++) {\n\t\tep_desc = &interface->cur_altsetting->endpoint[i].desc;\n\t\tif (!ep_desc->wMaxPacketSize) {\n\t\t\tep_desc->wMaxPacketSize = cpu_to_le16(0x40);\n\t\t\tdev_warn(&port->dev, \"Overriding wMaxPacketSize on endpoint %d\\n\",\n\t\t\t\t\tusb_endpoint_num(ep_desc));\n\t\t}\n\t}\n\n\t \n\tpriv->max_packet_size = usb_endpoint_maxp(ep_desc);\n}\n\n\n \n\nstatic ssize_t latency_timer_show(struct device *dev,\n\t\t\t\t  struct device_attribute *attr, char *buf)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tif (priv->flags & ASYNC_LOW_LATENCY)\n\t\treturn sprintf(buf, \"1\\n\");\n\telse\n\t\treturn sprintf(buf, \"%u\\n\", priv->latency);\n}\n\n \nstatic ssize_t latency_timer_store(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   const char *valbuf, size_t count)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tu8 v;\n\tint rv;\n\n\tif (kstrtou8(valbuf, 10, &v))\n\t\treturn -EINVAL;\n\n\tpriv->latency = v;\n\trv = write_latency_timer(port);\n\tif (rv < 0)\n\t\treturn -EIO;\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(latency_timer);\n\n \nstatic ssize_t event_char_store(struct device *dev,\n\tstruct device_attribute *attr, const char *valbuf, size_t count)\n{\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_device *udev = port->serial->dev;\n\tunsigned int v;\n\tint rv;\n\n\tif (kstrtouint(valbuf, 0, &v) || v >= 0x200)\n\t\treturn -EINVAL;\n\n\tdev_dbg(&port->dev, \"%s: setting event char = 0x%03x\\n\", __func__, v);\n\n\trv = usb_control_msg(udev,\n\t\t\t     usb_sndctrlpipe(udev, 0),\n\t\t\t     FTDI_SIO_SET_EVENT_CHAR_REQUEST,\n\t\t\t     FTDI_SIO_SET_EVENT_CHAR_REQUEST_TYPE,\n\t\t\t     v, priv->channel,\n\t\t\t     NULL, 0, WDR_TIMEOUT);\n\tif (rv < 0) {\n\t\tdev_dbg(&port->dev, \"Unable to write event character: %i\\n\", rv);\n\t\treturn -EIO;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(event_char);\n\nstatic struct attribute *ftdi_attrs[] = {\n\t&dev_attr_event_char.attr,\n\t&dev_attr_latency_timer.attr,\n\tNULL\n};\n\nstatic umode_t ftdi_is_visible(struct kobject *kobj, struct attribute *attr, int idx)\n{\n\tstruct device *dev = kobj_to_dev(kobj);\n\tstruct usb_serial_port *port = to_usb_serial_port(dev);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tenum ftdi_chip_type type = priv->chip_type;\n\n\tif (attr == &dev_attr_event_char.attr) {\n\t\tif (type == SIO)\n\t\t\treturn 0;\n\t}\n\n\tif (attr == &dev_attr_latency_timer.attr) {\n\t\tif (type == SIO || type == FT232A)\n\t\t\treturn 0;\n\t}\n\n\treturn attr->mode;\n}\n\nstatic const struct attribute_group ftdi_group = {\n\t.attrs\t\t= ftdi_attrs,\n\t.is_visible\t= ftdi_is_visible,\n};\n\nstatic const struct attribute_group *ftdi_groups[] = {\n\t&ftdi_group,\n\tNULL\n};\n\n#ifdef CONFIG_GPIOLIB\n\nstatic int ftdi_set_bitmode(struct usb_serial_port *port, u8 mode)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint result;\n\tu16 val;\n\n\tresult = usb_autopm_get_interface(serial->interface);\n\tif (result)\n\t\treturn result;\n\n\tval = (mode << 8) | (priv->gpio_output << 4) | priv->gpio_value;\n\tresult = usb_control_msg(serial->dev,\n\t\t\t\t usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t FTDI_SIO_SET_BITMODE_REQUEST,\n\t\t\t\t FTDI_SIO_SET_BITMODE_REQUEST_TYPE, val,\n\t\t\t\t priv->channel, NULL, 0, WDR_TIMEOUT);\n\tif (result < 0) {\n\t\tdev_err(&serial->interface->dev,\n\t\t\t\"bitmode request failed for value 0x%04x: %d\\n\",\n\t\t\tval, result);\n\t}\n\n\tusb_autopm_put_interface(serial->interface);\n\n\treturn result;\n}\n\nstatic int ftdi_set_cbus_pins(struct usb_serial_port *port)\n{\n\treturn ftdi_set_bitmode(port, FTDI_SIO_BITMODE_CBUS);\n}\n\nstatic int ftdi_exit_cbus_mode(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tpriv->gpio_output = 0;\n\tpriv->gpio_value = 0;\n\treturn ftdi_set_bitmode(port, FTDI_SIO_BITMODE_RESET);\n}\n\nstatic int ftdi_gpio_request(struct gpio_chip *gc, unsigned int offset)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tmutex_lock(&priv->gpio_lock);\n\tif (!priv->gpio_used) {\n\t\t \n\t\tpriv->gpio_output = 0x00;\n\t\tpriv->gpio_value = 0x00;\n\t\tresult = ftdi_set_cbus_pins(port);\n\t\tif (result) {\n\t\t\tmutex_unlock(&priv->gpio_lock);\n\t\t\treturn result;\n\t\t}\n\n\t\tpriv->gpio_used = true;\n\t}\n\tmutex_unlock(&priv->gpio_lock);\n\n\treturn 0;\n}\n\nstatic int ftdi_read_cbus_pins(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tu8 buf;\n\tint result;\n\n\tresult = usb_autopm_get_interface(serial->interface);\n\tif (result)\n\t\treturn result;\n\n\tresult = usb_control_msg_recv(serial->dev, 0,\n\t\t\t\t      FTDI_SIO_READ_PINS_REQUEST,\n\t\t\t\t      FTDI_SIO_READ_PINS_REQUEST_TYPE, 0,\n\t\t\t\t      priv->channel, &buf, 1, WDR_TIMEOUT,\n\t\t\t\t      GFP_KERNEL);\n\tif (result == 0)\n\t\tresult = buf;\n\n\tusb_autopm_put_interface(serial->interface);\n\n\treturn result;\n}\n\nstatic int ftdi_gpio_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tint result;\n\n\tresult = ftdi_read_cbus_pins(port);\n\tif (result < 0)\n\t\treturn result;\n\n\treturn !!(result & BIT(gpio));\n}\n\nstatic void ftdi_gpio_set(struct gpio_chip *gc, unsigned int gpio, int value)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tmutex_lock(&priv->gpio_lock);\n\n\tif (value)\n\t\tpriv->gpio_value |= BIT(gpio);\n\telse\n\t\tpriv->gpio_value &= ~BIT(gpio);\n\n\tftdi_set_cbus_pins(port);\n\n\tmutex_unlock(&priv->gpio_lock);\n}\n\nstatic int ftdi_gpio_get_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t\t\tunsigned long *bits)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tint result;\n\n\tresult = ftdi_read_cbus_pins(port);\n\tif (result < 0)\n\t\treturn result;\n\n\t*bits = result & *mask;\n\n\treturn 0;\n}\n\nstatic void ftdi_gpio_set_multiple(struct gpio_chip *gc, unsigned long *mask,\n\t\t\t\t\tunsigned long *bits)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tmutex_lock(&priv->gpio_lock);\n\n\tpriv->gpio_value &= ~(*mask);\n\tpriv->gpio_value |= *bits & *mask;\n\tftdi_set_cbus_pins(port);\n\n\tmutex_unlock(&priv->gpio_lock);\n}\n\nstatic int ftdi_gpio_direction_get(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\treturn !(priv->gpio_output & BIT(gpio));\n}\n\nstatic int ftdi_gpio_direction_input(struct gpio_chip *gc, unsigned int gpio)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tmutex_lock(&priv->gpio_lock);\n\n\tpriv->gpio_output &= ~BIT(gpio);\n\tresult = ftdi_set_cbus_pins(port);\n\n\tmutex_unlock(&priv->gpio_lock);\n\n\treturn result;\n}\n\nstatic int ftdi_gpio_direction_output(struct gpio_chip *gc, unsigned int gpio,\n\t\t\t\t\tint value)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tint result;\n\n\tmutex_lock(&priv->gpio_lock);\n\n\tpriv->gpio_output |= BIT(gpio);\n\tif (value)\n\t\tpriv->gpio_value |= BIT(gpio);\n\telse\n\t\tpriv->gpio_value &= ~BIT(gpio);\n\n\tresult = ftdi_set_cbus_pins(port);\n\n\tmutex_unlock(&priv->gpio_lock);\n\n\treturn result;\n}\n\nstatic int ftdi_gpio_init_valid_mask(struct gpio_chip *gc,\n\t\t\t\t     unsigned long *valid_mask,\n\t\t\t\t     unsigned int ngpios)\n{\n\tstruct usb_serial_port *port = gpiochip_get_data(gc);\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tunsigned long map = priv->gpio_altfunc;\n\n\tbitmap_complement(valid_mask, &map, ngpios);\n\n\tif (bitmap_empty(valid_mask, ngpios))\n\t\tdev_dbg(&port->dev, \"no CBUS pin configured for GPIO\\n\");\n\telse\n\t\tdev_dbg(&port->dev, \"CBUS%*pbl configured for GPIO\\n\", ngpios,\n\t\t\tvalid_mask);\n\n\treturn 0;\n}\n\nstatic int ftdi_read_eeprom(struct usb_serial *serial, void *dst, u16 addr,\n\t\t\t\tu16 nbytes)\n{\n\tint read = 0;\n\n\tif (addr % 2 != 0)\n\t\treturn -EINVAL;\n\tif (nbytes % 2 != 0)\n\t\treturn -EINVAL;\n\n\t \n\twhile (read < nbytes) {\n\t\tint rv;\n\n\t\trv = usb_control_msg(serial->dev,\n\t\t\t\t     usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t     FTDI_SIO_READ_EEPROM_REQUEST,\n\t\t\t\t     FTDI_SIO_READ_EEPROM_REQUEST_TYPE,\n\t\t\t\t     0, (addr + read) / 2, dst + read, 2,\n\t\t\t\t     WDR_TIMEOUT);\n\t\tif (rv < 2) {\n\t\t\tif (rv >= 0)\n\t\t\t\treturn -EIO;\n\t\t\telse\n\t\t\t\treturn rv;\n\t\t}\n\n\t\tread += rv;\n\t}\n\n\treturn 0;\n}\n\nstatic int ftdi_gpio_init_ft232h(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tu16 cbus_config;\n\tu8 *buf;\n\tint ret;\n\tint i;\n\n\tbuf = kmalloc(4, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ftdi_read_eeprom(port->serial, buf, 0x1a, 4);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\t \n\tcbus_config = buf[2] << 8 | (buf[1] & 0xf) << 4 | (buf[0] & 0xf0) >> 4;\n\n\tpriv->gc.ngpio = 4;\n\tpriv->gpio_altfunc = 0xff;\n\n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\tif ((cbus_config & 0xf) == FTDI_FTX_CBUS_MUX_GPIO)\n\t\t\tpriv->gpio_altfunc &= ~BIT(i);\n\t\tcbus_config >>= 4;\n\t}\n\nout_free:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int ftdi_gpio_init_ft232r(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tu16 cbus_config;\n\tu8 *buf;\n\tint ret;\n\tint i;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tret = ftdi_read_eeprom(port->serial, buf, 0x14, 2);\n\tif (ret < 0)\n\t\tgoto out_free;\n\n\tcbus_config = le16_to_cpup((__le16 *)buf);\n\tdev_dbg(&port->dev, \"cbus_config = 0x%04x\\n\", cbus_config);\n\n\tpriv->gc.ngpio = 4;\n\n\tpriv->gpio_altfunc = 0xff;\n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\tif ((cbus_config & 0xf) == FTDI_FT232R_CBUS_MUX_GPIO)\n\t\t\tpriv->gpio_altfunc &= ~BIT(i);\n\t\tcbus_config >>= 4;\n\t}\nout_free:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int ftdi_gpio_init_ftx(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tconst u16 cbus_cfg_addr = 0x1a;\n\tconst u16 cbus_cfg_size = 4;\n\tu8 *cbus_cfg_buf;\n\tint result;\n\tu8 i;\n\n\tcbus_cfg_buf = kmalloc(cbus_cfg_size, GFP_KERNEL);\n\tif (!cbus_cfg_buf)\n\t\treturn -ENOMEM;\n\n\tresult = ftdi_read_eeprom(serial, cbus_cfg_buf,\n\t\t\t\t  cbus_cfg_addr, cbus_cfg_size);\n\tif (result < 0)\n\t\tgoto out_free;\n\n\t \n\tpriv->gc.ngpio = 4;\n\n\t \n\tpriv->gpio_altfunc = 0xff;\n\tfor (i = 0; i < priv->gc.ngpio; ++i) {\n\t\tif (cbus_cfg_buf[i] == FTDI_FTX_CBUS_MUX_GPIO)\n\t\t\tpriv->gpio_altfunc &= ~BIT(i);\n\t}\n\nout_free:\n\tkfree(cbus_cfg_buf);\n\n\treturn result;\n}\n\nstatic int ftdi_gpio_init(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct usb_serial *serial = port->serial;\n\tint result;\n\n\tswitch (priv->chip_type) {\n\tcase FT232H:\n\t\tresult = ftdi_gpio_init_ft232h(port);\n\t\tbreak;\n\tcase FT232R:\n\t\tresult = ftdi_gpio_init_ft232r(port);\n\t\tbreak;\n\tcase FTX:\n\t\tresult = ftdi_gpio_init_ftx(port);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (result < 0)\n\t\treturn result;\n\n\tmutex_init(&priv->gpio_lock);\n\n\tpriv->gc.label = \"ftdi-cbus\";\n\tpriv->gc.request = ftdi_gpio_request;\n\tpriv->gc.get_direction = ftdi_gpio_direction_get;\n\tpriv->gc.direction_input = ftdi_gpio_direction_input;\n\tpriv->gc.direction_output = ftdi_gpio_direction_output;\n\tpriv->gc.init_valid_mask = ftdi_gpio_init_valid_mask;\n\tpriv->gc.get = ftdi_gpio_get;\n\tpriv->gc.set = ftdi_gpio_set;\n\tpriv->gc.get_multiple = ftdi_gpio_get_multiple;\n\tpriv->gc.set_multiple = ftdi_gpio_set_multiple;\n\tpriv->gc.owner = THIS_MODULE;\n\tpriv->gc.parent = &serial->interface->dev;\n\tpriv->gc.base = -1;\n\tpriv->gc.can_sleep = true;\n\n\tresult = gpiochip_add_data(&priv->gc, port);\n\tif (!result)\n\t\tpriv->gpio_registered = true;\n\n\treturn result;\n}\n\nstatic void ftdi_gpio_remove(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tif (priv->gpio_registered) {\n\t\tgpiochip_remove(&priv->gc);\n\t\tpriv->gpio_registered = false;\n\t}\n\n\tif (priv->gpio_used) {\n\t\t \n\t\tftdi_exit_cbus_mode(port);\n\t\tpriv->gpio_used = false;\n\t}\n}\n\n#else\n\nstatic int ftdi_gpio_init(struct usb_serial_port *port)\n{\n\treturn 0;\n}\n\nstatic void ftdi_gpio_remove(struct usb_serial_port *port) { }\n\n#endif\t \n\n \n\nstatic int ftdi_probe(struct usb_serial *serial, const struct usb_device_id *id)\n{\n\tconst struct ftdi_quirk *quirk = (struct ftdi_quirk *)id->driver_info;\n\n\tif (quirk && quirk->probe) {\n\t\tint ret = quirk->probe(serial);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\tusb_set_serial_data(serial, (void *)id->driver_info);\n\n\treturn 0;\n}\n\nstatic int ftdi_port_probe(struct usb_serial_port *port)\n{\n\tconst struct ftdi_quirk *quirk = usb_get_serial_data(port->serial);\n\tstruct ftdi_private *priv;\n\tint result;\n\n\tpriv = kzalloc(sizeof(struct ftdi_private), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&priv->cfg_lock);\n\n\tif (quirk && quirk->port_probe)\n\t\tquirk->port_probe(priv);\n\n\tusb_set_serial_port_data(port, priv);\n\n\tresult = ftdi_determine_type(port);\n\tif (result)\n\t\tgoto err_free;\n\n\tftdi_set_max_packet_size(port);\n\tif (read_latency_timer(port) < 0)\n\t\tpriv->latency = 16;\n\twrite_latency_timer(port);\n\n\tresult = ftdi_gpio_init(port);\n\tif (result < 0) {\n\t\tdev_err(&port->serial->interface->dev,\n\t\t\t\"GPIO initialisation failed: %d\\n\",\n\t\t\tresult);\n\t}\n\n\treturn 0;\n\nerr_free:\n\tkfree(priv);\n\n\treturn result;\n}\n\n \n \nstatic void ftdi_USB_UIRT_setup(struct ftdi_private *priv)\n{\n\tpriv->flags |= ASYNC_SPD_CUST;\n\tpriv->custom_divisor = 77;\n\tpriv->force_baud = 38400;\n}\n\n \n\nstatic void ftdi_HE_TIRA1_setup(struct ftdi_private *priv)\n{\n\tpriv->flags |= ASYNC_SPD_CUST;\n\tpriv->custom_divisor = 240;\n\tpriv->force_baud = 38400;\n\tpriv->force_rtscts = 1;\n}\n\n \nstatic int ndi_latency_timer = 1;\n\n \nstatic int ftdi_NDI_device_setup(struct usb_serial *serial)\n{\n\tstruct usb_device *udev = serial->dev;\n\tint latency = ndi_latency_timer;\n\n\tif (latency == 0)\n\t\tlatency = 1;\n\tif (latency > 99)\n\t\tlatency = 99;\n\n\tdev_dbg(&udev->dev, \"%s setting NDI device latency to %d\\n\", __func__, latency);\n\tdev_info(&udev->dev, \"NDI device with a latency value of %d\\n\", latency);\n\n\t \n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tFTDI_SIO_SET_LATENCY_TIMER_REQUEST,\n\t\t\t\tFTDI_SIO_SET_LATENCY_TIMER_REQUEST_TYPE,\n\t\t\t\tlatency, 0, NULL, 0, WDR_TIMEOUT);\n\treturn 0;\n}\n\n \nstatic int ftdi_jtag_probe(struct usb_serial *serial)\n{\n\tstruct usb_interface *intf = serial->interface;\n\tint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (ifnum == 0) {\n\t\tdev_info(&intf->dev, \"Ignoring interface reserved for JTAG\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int ftdi_8u2232c_probe(struct usb_serial *serial)\n{\n\tstruct usb_device *udev = serial->dev;\n\n\tif (udev->manufacturer && !strcmp(udev->manufacturer, \"CALAO Systems\"))\n\t\treturn ftdi_jtag_probe(serial);\n\n\tif (udev->product &&\n\t\t(!strcmp(udev->product, \"Arrow USB Blaster\") ||\n\t\t !strcmp(udev->product, \"BeagleBone/XDS100V2\") ||\n\t\t !strcmp(udev->product, \"SNAP Connect E10\")))\n\t\treturn ftdi_jtag_probe(serial);\n\n\treturn 0;\n}\n\n \nstatic int ftdi_stmclite_probe(struct usb_serial *serial)\n{\n\tstruct usb_interface *intf = serial->interface;\n\tint ifnum = intf->cur_altsetting->desc.bInterfaceNumber;\n\n\tif (ifnum < 2) {\n\t\tdev_info(&intf->dev, \"Ignoring interface reserved for JTAG\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic void ftdi_port_remove(struct usb_serial_port *port)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\tftdi_gpio_remove(port);\n\n\tkfree(priv);\n}\n\nstatic int ftdi_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\t \n\t \n\tusb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tFTDI_SIO_RESET_REQUEST, FTDI_SIO_RESET_REQUEST_TYPE,\n\t\t\tFTDI_SIO_RESET_SIO,\n\t\t\tpriv->channel, NULL, 0, WDR_TIMEOUT);\n\n\t \n\n\t \n\tif (tty)\n\t\tftdi_set_termios(tty, port, NULL);\n\n\treturn usb_serial_generic_open(tty, port);\n}\n\nstatic void ftdi_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\n\t \n\tif (!on) {\n\t\tif (usb_control_msg(port->serial->dev,\n\t\t\t    usb_sndctrlpipe(port->serial->dev, 0),\n\t\t\t    FTDI_SIO_SET_FLOW_CTRL_REQUEST,\n\t\t\t    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\n\t\t\t    0, priv->channel, NULL, 0,\n\t\t\t    WDR_TIMEOUT) < 0) {\n\t\t\tdev_err(&port->dev, \"error from flowcontrol urb\\n\");\n\t\t}\n\t}\n\t \n\tif (on)\n\t\tset_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\telse\n\t\tclear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n}\n\n \nstatic int ftdi_prepare_write_buffer(struct usb_serial_port *port,\n\t\t\t\t\t\tvoid *dest, size_t size)\n{\n\tstruct ftdi_private *priv;\n\tint count;\n\tunsigned long flags;\n\n\tpriv = usb_get_serial_port_data(port);\n\n\tif (priv->chip_type == SIO) {\n\t\tunsigned char *buffer = dest;\n\t\tint i, len, c;\n\n\t\tcount = 0;\n\t\tspin_lock_irqsave(&port->lock, flags);\n\t\tfor (i = 0; i < size - 1; i += priv->max_packet_size) {\n\t\t\tlen = min_t(int, size - i, priv->max_packet_size) - 1;\n\t\t\tc = kfifo_out(&port->write_fifo, &buffer[i + 1], len);\n\t\t\tif (!c)\n\t\t\t\tbreak;\n\t\t\tport->icount.tx += c;\n\t\t\tbuffer[i] = (c << 2) + 1;\n\t\t\tcount += c + 1;\n\t\t}\n\t\tspin_unlock_irqrestore(&port->lock, flags);\n\t} else {\n\t\tcount = kfifo_out_locked(&port->write_fifo, dest, size,\n\t\t\t\t\t\t\t\t&port->lock);\n\t\tport->icount.tx += count;\n\t}\n\n\treturn count;\n}\n\n#define FTDI_RS_ERR_MASK (FTDI_RS_BI | FTDI_RS_PE | FTDI_RS_FE | FTDI_RS_OE)\n\nstatic int ftdi_process_packet(struct usb_serial_port *port,\n\t\tstruct ftdi_private *priv, unsigned char *buf, int len)\n{\n\tunsigned char status;\n\tbool brkint = false;\n\tint i;\n\tchar flag;\n\n\tif (len < 2) {\n\t\tdev_dbg(&port->dev, \"malformed packet\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tstatus = buf[0] & FTDI_STATUS_B0_MASK;\n\tif (status != priv->prev_status) {\n\t\tchar diff_status = status ^ priv->prev_status;\n\n\t\tif (diff_status & FTDI_RS0_CTS)\n\t\t\tport->icount.cts++;\n\t\tif (diff_status & FTDI_RS0_DSR)\n\t\t\tport->icount.dsr++;\n\t\tif (diff_status & FTDI_RS0_RI)\n\t\t\tport->icount.rng++;\n\t\tif (diff_status & FTDI_RS0_RLSD) {\n\t\t\tstruct tty_struct *tty;\n\n\t\t\tport->icount.dcd++;\n\t\t\ttty = tty_port_tty_get(&port->port);\n\t\t\tif (tty)\n\t\t\t\tusb_serial_handle_dcd_change(port, tty,\n\t\t\t\t\t\tstatus & FTDI_RS0_RLSD);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t\tpriv->prev_status = status;\n\t}\n\n\t \n\tif (buf[1] & FTDI_RS_TEMT)\n\t\tpriv->transmit_empty = 1;\n\telse\n\t\tpriv->transmit_empty = 0;\n\n\tif (len == 2)\n\t\treturn 0;\t \n\n\t \n\tflag = TTY_NORMAL;\n\tif (buf[1] & FTDI_RS_ERR_MASK) {\n\t\t \n\t\tif (buf[1] & FTDI_RS_BI && buf[len - 1] == '\\0') {\n\t\t\tport->icount.brk++;\n\t\t\tbrkint = true;\n\t\t}\n\t\tif (buf[1] & FTDI_RS_PE) {\n\t\t\tflag = TTY_PARITY;\n\t\t\tport->icount.parity++;\n\t\t} else if (buf[1] & FTDI_RS_FE) {\n\t\t\tflag = TTY_FRAME;\n\t\t\tport->icount.frame++;\n\t\t}\n\t\t \n\t\tif (buf[1] & FTDI_RS_OE) {\n\t\t\tport->icount.overrun++;\n\t\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\t\t}\n\t}\n\n\tport->icount.rx += len - 2;\n\n\tif (brkint || port->sysrq) {\n\t\tfor (i = 2; i < len; i++) {\n\t\t\tif (brkint && i == len - 1) {\n\t\t\t\tif (usb_serial_handle_break(port))\n\t\t\t\t\treturn len - 3;\n\t\t\t\tflag = TTY_BREAK;\n\t\t\t}\n\t\t\tif (usb_serial_handle_sysrq_char(port, buf[i]))\n\t\t\t\tcontinue;\n\t\t\ttty_insert_flip_char(&port->port, buf[i], flag);\n\t\t}\n\t} else {\n\t\ttty_insert_flip_string_fixed_flag(&port->port, buf + 2, flag,\n\t\t\t\tlen - 2);\n\t}\n\n\treturn len - 2;\n}\n\nstatic void ftdi_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tchar *data = urb->transfer_buffer;\n\tint i;\n\tint len;\n\tint count = 0;\n\n\tfor (i = 0; i < urb->actual_length; i += priv->max_packet_size) {\n\t\tlen = min_t(int, urb->actual_length - i, priv->max_packet_size);\n\t\tcount += ftdi_process_packet(port, priv, &data[i], len);\n\t}\n\n\tif (count)\n\t\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int ftdi_break_ctl(struct tty_struct *tty, int break_state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tu16 value;\n\tint ret;\n\n\t \n\t \n\t \n\n\tif (break_state)\n\t\tvalue = priv->last_set_data_value | FTDI_SIO_SET_BREAK;\n\telse\n\t\tvalue = priv->last_set_data_value;\n\n\tret = usb_control_msg(port->serial->dev,\n\t\t\tusb_sndctrlpipe(port->serial->dev, 0),\n\t\t\tFTDI_SIO_SET_DATA_REQUEST,\n\t\t\tFTDI_SIO_SET_DATA_REQUEST_TYPE,\n\t\t\tvalue, priv->channel,\n\t\t\tNULL, 0, WDR_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&port->dev, \"%s FAILED to enable/disable break state (state was %d)\\n\",\n\t\t\t__func__, break_state);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&port->dev, \"%s break state is %d - urb is %d\\n\", __func__,\n\t\tbreak_state, value);\n\n\treturn 0;\n}\n\nstatic bool ftdi_tx_empty(struct usb_serial_port *port)\n{\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = ftdi_get_modem_status(port, buf);\n\tif (ret == 2) {\n\t\tif (!(buf[1] & FTDI_RS_TEMT))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n \nstatic void ftdi_set_termios(struct tty_struct *tty,\n\t\t             struct usb_serial_port *port,\n\t\t             const struct ktermios *old_termios)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tstruct device *ddev = &port->dev;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tstruct ktermios *termios = &tty->termios;\n\tunsigned int cflag = termios->c_cflag;\n\tu16 value, index;\n\tint ret;\n\n\t \n\tif (priv->force_baud && ((termios->c_cflag & CBAUD) != B0)) {\n\t\tdev_dbg(ddev, \"%s: forcing baud rate for this device\\n\", __func__);\n\t\ttty_encode_baud_rate(tty, priv->force_baud,\n\t\t\t\t\tpriv->force_baud);\n\t}\n\n\t \n\tif (priv->force_rtscts) {\n\t\tdev_dbg(ddev, \"%s: forcing rtscts for this device\\n\", __func__);\n\t\ttermios->c_cflag |= CRTSCTS;\n\t}\n\n\t \n\tif (C_CSIZE(tty) == CS6) {\n\t\tdev_warn(ddev, \"requested CSIZE setting not supported\\n\");\n\n\t\ttermios->c_cflag &= ~CSIZE;\n\t\tif (old_termios)\n\t\t\ttermios->c_cflag |= old_termios->c_cflag & CSIZE;\n\t\telse\n\t\t\ttermios->c_cflag |= CS8;\n\t}\n\n\tcflag = termios->c_cflag;\n\n\tif (!old_termios)\n\t\tgoto no_skip;\n\n\tif (old_termios->c_cflag == termios->c_cflag\n\t    && old_termios->c_ispeed == termios->c_ispeed\n\t    && old_termios->c_ospeed == termios->c_ospeed)\n\t\tgoto no_c_cflag_changes;\n\n\t \n\n\tif ((old_termios->c_cflag & (CSIZE|PARODD|PARENB|CMSPAR|CSTOPB)) ==\n\t    (termios->c_cflag & (CSIZE|PARODD|PARENB|CMSPAR|CSTOPB)))\n\t\tgoto no_data_parity_stop_changes;\n\nno_skip:\n\t \n\n\tvalue = 0;\n\tvalue |= (cflag & CSTOPB ? FTDI_SIO_SET_DATA_STOP_BITS_2 :\n\t\t\tFTDI_SIO_SET_DATA_STOP_BITS_1);\n\tif (cflag & PARENB) {\n\t\tif (cflag & CMSPAR)\n\t\t\tvalue |= cflag & PARODD ?\n\t\t\t\t\tFTDI_SIO_SET_DATA_PARITY_MARK :\n\t\t\t\t\tFTDI_SIO_SET_DATA_PARITY_SPACE;\n\t\telse\n\t\t\tvalue |= cflag & PARODD ?\n\t\t\t\t\tFTDI_SIO_SET_DATA_PARITY_ODD :\n\t\t\t\t\tFTDI_SIO_SET_DATA_PARITY_EVEN;\n\t} else {\n\t\tvalue |= FTDI_SIO_SET_DATA_PARITY_NONE;\n\t}\n\tswitch (cflag & CSIZE) {\n\tcase CS5:\n\t\tdev_dbg(ddev, \"Setting CS5 quirk\\n\");\n\t\tbreak;\n\tcase CS7:\n\t\tvalue |= 7;\n\t\tdev_dbg(ddev, \"Setting CS7\\n\");\n\t\tbreak;\n\tdefault:\n\tcase CS8:\n\t\tvalue |= 8;\n\t\tdev_dbg(ddev, \"Setting CS8\\n\");\n\t\tbreak;\n\t}\n\n\t \n\tpriv->last_set_data_value = value;\n\n\tif (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t    FTDI_SIO_SET_DATA_REQUEST,\n\t\t\t    FTDI_SIO_SET_DATA_REQUEST_TYPE,\n\t\t\t    value, priv->channel,\n\t\t\t    NULL, 0, WDR_SHORT_TIMEOUT) < 0) {\n\t\tdev_err(ddev, \"%s FAILED to set databits/stopbits/parity\\n\",\n\t\t\t__func__);\n\t}\n\n\t \nno_data_parity_stop_changes:\n\tif ((cflag & CBAUD) == B0) {\n\t\t \n\t\tif (usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t    FTDI_SIO_SET_FLOW_CTRL_REQUEST,\n\t\t\t\t    FTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\n\t\t\t\t    0, priv->channel,\n\t\t\t\t    NULL, 0, WDR_TIMEOUT) < 0) {\n\t\t\tdev_err(ddev, \"%s error from disable flowcontrol urb\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t\t \n\t\tclear_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\t} else {\n\t\t \n\t\tmutex_lock(&priv->cfg_lock);\n\t\tif (change_speed(tty, port))\n\t\t\tdev_err(ddev, \"%s urb failed to set baudrate\\n\", __func__);\n\t\tmutex_unlock(&priv->cfg_lock);\n\t\t \n\t\tif (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\t\tset_mctrl(port, TIOCM_DTR | TIOCM_RTS);\n\t}\n\nno_c_cflag_changes:\n\t \n\tvalue = 0;\n\n\tif (C_CRTSCTS(tty)) {\n\t\tdev_dbg(&port->dev, \"enabling rts/cts flow control\\n\");\n\t\tindex = FTDI_SIO_RTS_CTS_HS;\n\t} else if (I_IXON(tty)) {\n\t\tdev_dbg(&port->dev, \"enabling xon/xoff flow control\\n\");\n\t\tindex = FTDI_SIO_XON_XOFF_HS;\n\t\tvalue = STOP_CHAR(tty) << 8 | START_CHAR(tty);\n\t} else {\n\t\tdev_dbg(&port->dev, \"disabling flow control\\n\");\n\t\tindex = FTDI_SIO_DISABLE_FLOW_CTRL;\n\t}\n\n\tindex |= priv->channel;\n\n\tret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\tFTDI_SIO_SET_FLOW_CTRL_REQUEST,\n\t\t\tFTDI_SIO_SET_FLOW_CTRL_REQUEST_TYPE,\n\t\t\tvalue, index, NULL, 0, WDR_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(&port->dev, \"failed to set flow control: %d\\n\", ret);\n}\n\n \nstatic int ftdi_get_modem_status(struct usb_serial_port *port,\n\t\t\t\t\t\tunsigned char status[2])\n{\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *buf;\n\tint len;\n\tint ret;\n\n\tbuf = kmalloc(2, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\t \n\tif (priv->chip_type == SIO)\n\t\tlen = 1;\n\telse\n\t\tlen = 2;\n\n\tret = usb_control_msg(port->serial->dev,\n\t\t\tusb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\tFTDI_SIO_GET_MODEM_STATUS_REQUEST,\n\t\t\tFTDI_SIO_GET_MODEM_STATUS_REQUEST_TYPE,\n\t\t\t0, priv->channel,\n\t\t\tbuf, len, WDR_TIMEOUT);\n\n\t \n\tif (ret < 1) {\n\t\tdev_err(&port->dev, \"failed to get modem status: %d\\n\", ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t\tret = usb_translate_errors(ret);\n\t\tgoto out;\n\t}\n\n\tstatus[0] = buf[0];\n\tif (ret > 1)\n\t\tstatus[1] = buf[1];\n\telse\n\t\tstatus[1] = 0;\n\n\tdev_dbg(&port->dev, \"%s - 0x%02x%02x\\n\", __func__, status[0],\n\t\t\t\t\t\t\t\tstatus[1]);\nout:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int ftdi_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct ftdi_private *priv = usb_get_serial_port_data(port);\n\tunsigned char buf[2];\n\tint ret;\n\n\tret = ftdi_get_modem_status(port, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret =\t(buf[0] & FTDI_SIO_DSR_MASK  ? TIOCM_DSR : 0) |\n\t\t(buf[0] & FTDI_SIO_CTS_MASK  ? TIOCM_CTS : 0) |\n\t\t(buf[0] & FTDI_SIO_RI_MASK   ? TIOCM_RI  : 0) |\n\t\t(buf[0] & FTDI_SIO_RLSD_MASK ? TIOCM_CD  : 0) |\n\t\tpriv->last_dtr_rts;\n\n\treturn ret;\n}\n\nstatic int ftdi_tiocmset(struct tty_struct *tty,\n\t\t\tunsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn update_mctrl(port, set, clear);\n}\n\nstatic int ftdi_ioctl(struct tty_struct *tty,\n\t\t\t\t\tunsigned int cmd, unsigned long arg)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tvoid __user *argp = (void __user *)arg;\n\n\tswitch (cmd) {\n\tcase TIOCSERGETLSR:\n\t\treturn get_lsr_info(port, argp);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic struct usb_serial_driver ftdi_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"ftdi_sio\",\n\t\t.dev_groups =\tftdi_groups,\n\t},\n\t.description =\t\t\"FTDI USB Serial Device\",\n\t.id_table =\t\tid_table_combined,\n\t.num_ports =\t\t1,\n\t.bulk_in_size =\t\t512,\n\t.bulk_out_size =\t256,\n\t.probe =\t\tftdi_probe,\n\t.port_probe =\t\tftdi_port_probe,\n\t.port_remove =\t\tftdi_port_remove,\n\t.open =\t\t\tftdi_open,\n\t.dtr_rts =\t\tftdi_dtr_rts,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.process_read_urb =\tftdi_process_read_urb,\n\t.prepare_write_buffer =\tftdi_prepare_write_buffer,\n\t.tiocmget =\t\tftdi_tiocmget,\n\t.tiocmset =\t\tftdi_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.get_icount =\t\tusb_serial_generic_get_icount,\n\t.ioctl =\t\tftdi_ioctl,\n\t.get_serial =\t\tget_serial_info,\n\t.set_serial =\t\tset_serial_info,\n\t.set_termios =\t\tftdi_set_termios,\n\t.break_ctl =\t\tftdi_break_ctl,\n\t.tx_empty =\t\tftdi_tx_empty,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&ftdi_device, NULL\n};\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nmodule_param(ndi_latency_timer, int, 0644);\nMODULE_PARM_DESC(ndi_latency_timer, \"NDI device latency timer override\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}