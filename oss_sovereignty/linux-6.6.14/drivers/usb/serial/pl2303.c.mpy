{
  "module_name": "pl2303.c",
  "hash_id": "8bcd9d8194fa33939c3c024a4fe94056c706ccbb54ac9621f4ba5b0f6dc53821",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/pl2303.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/serial.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <asm/unaligned.h>\n#include \"pl2303.h\"\n\n\n#define PL2303_QUIRK_UART_STATE_IDX0\t\tBIT(0)\n#define PL2303_QUIRK_LEGACY\t\t\tBIT(1)\n#define PL2303_QUIRK_ENDPOINT_HACK\t\tBIT(2)\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ2) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_DCU11) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_RSAQ3) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_CHILITAG) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_PHAROS) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ALDIGA) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MMX) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GPRS) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_HCR331) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_MOTOROLA) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_ZTEK) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_TB) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GC) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GB) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GT) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GL) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GE) },\n\t{ USB_DEVICE(PL2303_VENDOR_ID, PL2303_PRODUCT_ID_GS) },\n\t{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID) },\n\t{ USB_DEVICE(IODATA_VENDOR_ID, IODATA_PRODUCT_ID_RSAQ5) },\n\t{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_UC485),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_UC232B),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(ATEN_VENDOR_ID, ATEN_PRODUCT_ID2) },\n\t{ USB_DEVICE(ATEN_VENDOR_ID2, ATEN_PRODUCT_ID) },\n\t{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID) },\n\t{ USB_DEVICE(ELCOM_VENDOR_ID, ELCOM_PRODUCT_ID_UCSGT) },\n\t{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID) },\n\t{ USB_DEVICE(ITEGNO_VENDOR_ID, ITEGNO_PRODUCT_ID_2080) },\n\t{ USB_DEVICE(MA620_VENDOR_ID, MA620_PRODUCT_ID) },\n\t{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID) },\n\t{ USB_DEVICE(TRIPP_VENDOR_ID, TRIPP_PRODUCT_ID) },\n\t{ USB_DEVICE(RADIOSHACK_VENDOR_ID, RADIOSHACK_PRODUCT_ID) },\n\t{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },\n\t{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },\n\t{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },\n\t{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),\n\t\t.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },\n\t{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),\n\t\t.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },\n\t{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X75),\n\t\t.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },\n\t{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_EF81),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_ID_S81) },  \n\t{ USB_DEVICE(SYNTECH_VENDOR_ID, SYNTECH_PRODUCT_ID) },\n\t{ USB_DEVICE(NOKIA_CA42_VENDOR_ID, NOKIA_CA42_PRODUCT_ID) },\n\t{ USB_DEVICE(CA_42_CA42_VENDOR_ID, CA_42_CA42_PRODUCT_ID) },\n\t{ USB_DEVICE(SAGEM_VENDOR_ID, SAGEM_PRODUCT_ID) },\n\t{ USB_DEVICE(LEADTEK_VENDOR_ID, LEADTEK_9531_PRODUCT_ID) },\n\t{ USB_DEVICE(SPEEDDRAGON_VENDOR_ID, SPEEDDRAGON_PRODUCT_ID) },\n\t{ USB_DEVICE(DATAPILOT_U2_VENDOR_ID, DATAPILOT_U2_PRODUCT_ID) },\n\t{ USB_DEVICE(BELKIN_VENDOR_ID, BELKIN_PRODUCT_ID) },\n\t{ USB_DEVICE(ALCOR_VENDOR_ID, ALCOR_PRODUCT_ID),\n\t\t.driver_info = PL2303_QUIRK_ENDPOINT_HACK },\n\t{ USB_DEVICE(WS002IN_VENDOR_ID, WS002IN_PRODUCT_ID) },\n\t{ USB_DEVICE(COREGA_VENDOR_ID, COREGA_PRODUCT_ID) },\n\t{ USB_DEVICE(YCCABLE_VENDOR_ID, YCCABLE_PRODUCT_ID) },\n\t{ USB_DEVICE(SUPERIAL_VENDOR_ID, SUPERIAL_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD220_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD220TA_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD381_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD381GC_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD960_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LD960TA_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LCM220_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LCM960_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LM920_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LM930_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_LM940_PRODUCT_ID) },\n\t{ USB_DEVICE(HP_VENDOR_ID, HP_TD620_PRODUCT_ID) },\n\t{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },\n\t{ USB_DEVICE(ZEAGLE_VENDOR_ID, ZEAGLE_N2ITION3_PRODUCT_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },\n\t{ USB_DEVICE(SANWA_VENDOR_ID, SANWA_PRODUCT_ID) },\n\t{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530_PRODUCT_ID) },\n\t{ USB_DEVICE(ADLINK_VENDOR_ID, ADLINK_ND6530GC_PRODUCT_ID) },\n\t{ USB_DEVICE(SMART_VENDOR_ID, SMART_PRODUCT_ID) },\n\t{ USB_DEVICE(AT_VENDOR_ID, AT_VTKIT3_PRODUCT_ID) },\n\t{ USB_DEVICE(IBM_VENDOR_ID, IBM_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table);\n\n#define SET_LINE_REQUEST_TYPE\t\t0x21\n#define SET_LINE_REQUEST\t\t0x20\n\n#define SET_CONTROL_REQUEST_TYPE\t0x21\n#define SET_CONTROL_REQUEST\t\t0x22\n#define CONTROL_DTR\t\t\t0x01\n#define CONTROL_RTS\t\t\t0x02\n\n#define BREAK_REQUEST_TYPE\t\t0x21\n#define BREAK_REQUEST\t\t\t0x23\n#define BREAK_ON\t\t\t0xffff\n#define BREAK_OFF\t\t\t0x0000\n\n#define GET_LINE_REQUEST_TYPE\t\t0xa1\n#define GET_LINE_REQUEST\t\t0x21\n\n#define VENDOR_WRITE_REQUEST_TYPE\t0x40\n#define VENDOR_WRITE_REQUEST\t\t0x01\n#define VENDOR_WRITE_NREQUEST\t\t0x80\n\n#define VENDOR_READ_REQUEST_TYPE\t0xc0\n#define VENDOR_READ_REQUEST\t\t0x01\n#define VENDOR_READ_NREQUEST\t\t0x81\n\n#define UART_STATE_INDEX\t\t8\n#define UART_STATE_MSR_MASK\t\t0x8b\n#define UART_STATE_TRANSIENT_MASK\t0x74\n#define UART_DCD\t\t\t0x01\n#define UART_DSR\t\t\t0x02\n#define UART_BREAK_ERROR\t\t0x04\n#define UART_RING\t\t\t0x08\n#define UART_FRAME_ERROR\t\t0x10\n#define UART_PARITY_ERROR\t\t0x20\n#define UART_OVERRUN_ERROR\t\t0x40\n#define UART_CTS\t\t\t0x80\n\n#define PL2303_FLOWCTRL_MASK\t\t0xf0\n\n#define PL2303_READ_TYPE_HX_STATUS\t0x8080\n\n#define PL2303_HXN_RESET_REG\t\t0x07\n#define PL2303_HXN_RESET_UPSTREAM_PIPE\t0x02\n#define PL2303_HXN_RESET_DOWNSTREAM_PIPE\t0x01\n\n#define PL2303_HXN_FLOWCTRL_REG\t\t0x0a\n#define PL2303_HXN_FLOWCTRL_MASK\t0x1c\n#define PL2303_HXN_FLOWCTRL_NONE\t0x1c\n#define PL2303_HXN_FLOWCTRL_RTS_CTS\t0x18\n#define PL2303_HXN_FLOWCTRL_XON_XOFF\t0x0c\n\nstatic int pl2303_set_break(struct usb_serial_port *port, bool enable);\n\nenum pl2303_type {\n\tTYPE_H,\n\tTYPE_HX,\n\tTYPE_TA,\n\tTYPE_TB,\n\tTYPE_HXD,\n\tTYPE_HXN,\n\tTYPE_COUNT\n};\n\nstruct pl2303_type_data {\n\tconst char *name;\n\tspeed_t max_baud_rate;\n\tunsigned long quirks;\n\tunsigned int no_autoxonxoff:1;\n\tunsigned int no_divisors:1;\n\tunsigned int alt_divisors:1;\n};\n\nstruct pl2303_serial_private {\n\tconst struct pl2303_type_data *type;\n\tunsigned long quirks;\n};\n\nstruct pl2303_private {\n\tspinlock_t lock;\n\tu8 line_control;\n\tu8 line_status;\n\n\tu8 line_settings[7];\n};\n\nstatic const struct pl2303_type_data pl2303_type_data[TYPE_COUNT] = {\n\t[TYPE_H] = {\n\t\t.name\t\t\t= \"H\",\n\t\t.max_baud_rate\t\t= 1228800,\n\t\t.quirks\t\t\t= PL2303_QUIRK_LEGACY,\n\t\t.no_autoxonxoff\t\t= true,\n\t},\n\t[TYPE_HX] = {\n\t\t.name\t\t\t= \"HX\",\n\t\t.max_baud_rate\t\t= 6000000,\n\t},\n\t[TYPE_TA] = {\n\t\t.name\t\t\t= \"TA\",\n\t\t.max_baud_rate\t\t= 6000000,\n\t\t.alt_divisors\t\t= true,\n\t},\n\t[TYPE_TB] = {\n\t\t.name\t\t\t= \"TB\",\n\t\t.max_baud_rate\t\t= 12000000,\n\t\t.alt_divisors\t\t= true,\n\t},\n\t[TYPE_HXD] = {\n\t\t.name\t\t\t= \"HXD\",\n\t\t.max_baud_rate\t\t= 12000000,\n\t},\n\t[TYPE_HXN] = {\n\t\t.name\t\t\t= \"G\",\n\t\t.max_baud_rate\t\t= 12000000,\n\t\t.no_divisors\t\t= true,\n\t},\n};\n\nstatic int pl2303_vendor_read(struct usb_serial *serial, u16 value,\n\t\t\t\t\t\t\tunsigned char buf[1])\n{\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tstruct device *dev = &serial->interface->dev;\n\tu8 request;\n\tint res;\n\n\tif (spriv->type == &pl2303_type_data[TYPE_HXN])\n\t\trequest = VENDOR_READ_NREQUEST;\n\telse\n\t\trequest = VENDOR_READ_REQUEST;\n\n\tres = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\trequest, VENDOR_READ_REQUEST_TYPE,\n\t\t\tvalue, 0, buf, 1, 100);\n\tif (res != 1) {\n\t\tdev_err(dev, \"%s - failed to read [%04x]: %d\\n\", __func__,\n\t\t\t\t\t\t\t\tvalue, res);\n\t\tif (res >= 0)\n\t\t\tres = -EIO;\n\n\t\treturn res;\n\t}\n\n\tdev_dbg(dev, \"%s - [%04x] = %02x\\n\", __func__, value, buf[0]);\n\n\treturn 0;\n}\n\nstatic int pl2303_vendor_write(struct usb_serial *serial, u16 value, u16 index)\n{\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tstruct device *dev = &serial->interface->dev;\n\tu8 request;\n\tint res;\n\n\tdev_dbg(dev, \"%s - [%04x] = %02x\\n\", __func__, value, index);\n\n\tif (spriv->type == &pl2303_type_data[TYPE_HXN])\n\t\trequest = VENDOR_WRITE_NREQUEST;\n\telse\n\t\trequest = VENDOR_WRITE_REQUEST;\n\n\tres = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\trequest, VENDOR_WRITE_REQUEST_TYPE,\n\t\t\tvalue, index, NULL, 0, 100);\n\tif (res) {\n\t\tdev_err(dev, \"%s - failed to write [%04x]: %d\\n\", __func__,\n\t\t\t\t\t\t\t\tvalue, res);\n\t\treturn res;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl2303_update_reg(struct usb_serial *serial, u8 reg, u8 mask, u8 val)\n{\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tint ret = 0;\n\tu8 *buf;\n\n\tbuf = kmalloc(1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tif (spriv->type == &pl2303_type_data[TYPE_HXN])\n\t\tret = pl2303_vendor_read(serial, reg, buf);\n\telse\n\t\tret = pl2303_vendor_read(serial, reg | 0x80, buf);\n\n\tif (ret)\n\t\tgoto out_free;\n\n\t*buf &= ~mask;\n\t*buf |= val & mask;\n\n\tret = pl2303_vendor_write(serial, reg, *buf);\nout_free:\n\tkfree(buf);\n\n\treturn ret;\n}\n\nstatic int pl2303_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tusb_set_serial_data(serial, (void *)id->driver_info);\n\n\treturn 0;\n}\n\n \nstatic int pl2303_endpoint_hack(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tstruct usb_interface *interface = serial->interface;\n\tstruct usb_device *dev = serial->dev;\n\tstruct device *ddev = &interface->dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tunsigned int i;\n\n\tif (interface == dev->actconfig->interface[0])\n\t\treturn 0;\n\n\t \n\tiface_desc = dev->actconfig->interface[0]->cur_altsetting;\n\n\tfor (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {\n\t\tendpoint = &iface_desc->endpoint[i].desc;\n\n\t\tif (!usb_endpoint_is_int_in(endpoint))\n\t\t\tcontinue;\n\n\t\tdev_dbg(ddev, \"found interrupt in on separate interface\\n\");\n\t\tif (epds->num_interrupt_in < ARRAY_SIZE(epds->interrupt_in))\n\t\t\tepds->interrupt_in[epds->num_interrupt_in++] = endpoint;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl2303_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tunsigned long quirks = (unsigned long)usb_get_serial_data(serial);\n\tstruct device *dev = &serial->interface->dev;\n\tint ret;\n\n\tif (quirks & PL2303_QUIRK_ENDPOINT_HACK) {\n\t\tret = pl2303_endpoint_hack(serial, epds);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (epds->num_interrupt_in < 1) {\n\t\tdev_err(dev, \"required interrupt-in endpoint missing\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 1;\n}\n\nstatic bool pl2303_supports_hx_status(struct usb_serial *serial)\n{\n\tint ret;\n\tu8 buf;\n\n\tret = usb_control_msg_recv(serial->dev, 0, VENDOR_READ_REQUEST,\n\t\t\tVENDOR_READ_REQUEST_TYPE, PL2303_READ_TYPE_HX_STATUS,\n\t\t\t0, &buf, 1, 100, GFP_KERNEL);\n\n\treturn ret == 0;\n}\n\nstatic int pl2303_detect_type(struct usb_serial *serial)\n{\n\tstruct usb_device_descriptor *desc = &serial->dev->descriptor;\n\tu16 bcdDevice, bcdUSB;\n\n\t \n\tif (desc->bDeviceClass == 0x02)\n\t\treturn TYPE_H;\t\t \n\n\tif (desc->bMaxPacketSize0 != 0x40) {\n\t\tif (desc->bDeviceClass == 0x00 || desc->bDeviceClass == 0xff)\n\t\t\treturn TYPE_H;\t \n\n\t\treturn TYPE_H;\t\t \n\t}\n\n\tbcdDevice = le16_to_cpu(desc->bcdDevice);\n\tbcdUSB = le16_to_cpu(desc->bcdUSB);\n\n\tswitch (bcdUSB) {\n\tcase 0x101:\n\t\t \n\t\tfallthrough;\n\tcase 0x110:\n\t\tswitch (bcdDevice) {\n\t\tcase 0x300:\n\t\t\treturn TYPE_HX;\n\t\tcase 0x400:\n\t\t\treturn TYPE_HXD;\n\t\tdefault:\n\t\t\treturn TYPE_HX;\n\t\t}\n\t\tbreak;\n\tcase 0x200:\n\t\tswitch (bcdDevice) {\n\t\tcase 0x100:\t \n\t\tcase 0x105:\n\t\t\treturn TYPE_HXN;\n\t\tcase 0x300:\t \n\t\t\tif (pl2303_supports_hx_status(serial))\n\t\t\t\treturn TYPE_TA;\n\t\t\tfallthrough;\n\t\tcase 0x305:\n\t\tcase 0x400:\t \n\t\tcase 0x405:\n\t\t\treturn TYPE_HXN;\n\t\tcase 0x500:\t \n\t\t\tif (pl2303_supports_hx_status(serial))\n\t\t\t\treturn TYPE_TB;\n\t\t\tfallthrough;\n\t\tcase 0x505:\n\t\tcase 0x600:\t \n\t\tcase 0x605:\n\t\tcase 0x700:\t \n\t\tcase 0x705:\n\t\t\treturn TYPE_HXN;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdev_err(&serial->interface->dev,\n\t\t\t\"unknown device type, please report to linux-usb@vger.kernel.org\\n\");\n\treturn -ENODEV;\n}\n\nstatic int pl2303_startup(struct usb_serial *serial)\n{\n\tstruct pl2303_serial_private *spriv;\n\tenum pl2303_type type;\n\tunsigned char *buf;\n\tint ret;\n\n\tret = pl2303_detect_type(serial);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ttype = ret;\n\tdev_dbg(&serial->interface->dev, \"device type: %s\\n\", pl2303_type_data[type].name);\n\n\tspriv = kzalloc(sizeof(*spriv), GFP_KERNEL);\n\tif (!spriv)\n\t\treturn -ENOMEM;\n\n\tspriv->type = &pl2303_type_data[type];\n\tspriv->quirks = (unsigned long)usb_get_serial_data(serial);\n\tspriv->quirks |= spriv->type->quirks;\n\n\tusb_set_serial_data(serial, spriv);\n\n\tif (type != TYPE_HXN) {\n\t\tbuf = kmalloc(1, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tkfree(spriv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tpl2303_vendor_read(serial, 0x8484, buf);\n\t\tpl2303_vendor_write(serial, 0x0404, 0);\n\t\tpl2303_vendor_read(serial, 0x8484, buf);\n\t\tpl2303_vendor_read(serial, 0x8383, buf);\n\t\tpl2303_vendor_read(serial, 0x8484, buf);\n\t\tpl2303_vendor_write(serial, 0x0404, 1);\n\t\tpl2303_vendor_read(serial, 0x8484, buf);\n\t\tpl2303_vendor_read(serial, 0x8383, buf);\n\t\tpl2303_vendor_write(serial, 0, 1);\n\t\tpl2303_vendor_write(serial, 1, 0);\n\t\tif (spriv->quirks & PL2303_QUIRK_LEGACY)\n\t\t\tpl2303_vendor_write(serial, 2, 0x24);\n\t\telse\n\t\t\tpl2303_vendor_write(serial, 2, 0x44);\n\n\t\tkfree(buf);\n\t}\n\n\treturn 0;\n}\n\nstatic void pl2303_release(struct usb_serial *serial)\n{\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\n\tkfree(spriv);\n}\n\nstatic int pl2303_port_probe(struct usb_serial_port *port)\n{\n\tstruct pl2303_private *priv;\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&priv->lock);\n\n\tusb_set_serial_port_data(port, priv);\n\n\tport->port.drain_delay = 256;\n\n\treturn 0;\n}\n\nstatic void pl2303_port_remove(struct usb_serial_port *port)\n{\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\n\tkfree(priv);\n}\n\nstatic int pl2303_set_control_lines(struct usb_serial_port *port, u8 value)\n{\n\tstruct usb_device *dev = port->serial->dev;\n\tint retval;\n\n\tdev_dbg(&port->dev, \"%s - %02x\\n\", __func__, value);\n\n\tretval = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),\n\t\t\t\t SET_CONTROL_REQUEST, SET_CONTROL_REQUEST_TYPE,\n\t\t\t\t value, 0, NULL, 0, 100);\n\tif (retval)\n\t\tdev_err(&port->dev, \"%s - failed: %d\\n\", __func__, retval);\n\n\treturn retval;\n}\n\n \nstatic speed_t pl2303_get_supported_baud_rate(speed_t baud)\n{\n\tstatic const speed_t baud_sup[] = {\n\t\t75, 150, 300, 600, 1200, 1800, 2400, 3600, 4800, 7200, 9600,\n\t\t14400, 19200, 28800, 38400, 57600, 115200, 230400, 460800,\n\t\t614400, 921600, 1228800, 2457600, 3000000, 6000000\n\t};\n\n\tunsigned i;\n\n\tfor (i = 0; i < ARRAY_SIZE(baud_sup); ++i) {\n\t\tif (baud_sup[i] > baud)\n\t\t\tbreak;\n\t}\n\n\tif (i == ARRAY_SIZE(baud_sup))\n\t\tbaud = baud_sup[i - 1];\n\telse if (i > 0 && (baud_sup[i] - baud) > (baud - baud_sup[i - 1]))\n\t\tbaud = baud_sup[i - 1];\n\telse\n\t\tbaud = baud_sup[i];\n\n\treturn baud;\n}\n\n \nstatic speed_t pl2303_encode_baud_rate_direct(unsigned char buf[4],\n\t\t\t\t\t\t\t\tspeed_t baud)\n{\n\tput_unaligned_le32(baud, buf);\n\n\treturn baud;\n}\n\nstatic speed_t pl2303_encode_baud_rate_divisor(unsigned char buf[4],\n\t\t\t\t\t\t\t\tspeed_t baud)\n{\n\tunsigned int baseline, mantissa, exponent;\n\n\t \n\tbaseline = 12000000 * 32;\n\tmantissa = baseline / baud;\n\tif (mantissa == 0)\n\t\tmantissa = 1;\t \n\texponent = 0;\n\twhile (mantissa >= 512) {\n\t\tif (exponent < 7) {\n\t\t\tmantissa >>= 2;\t \n\t\t\texponent++;\n\t\t} else {\n\t\t\t \n\t\t\tmantissa = 511;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbuf[3] = 0x80;\n\tbuf[2] = 0;\n\tbuf[1] = exponent << 1 | mantissa >> 8;\n\tbuf[0] = mantissa & 0xff;\n\n\t \n\tbaud = (baseline / mantissa) >> (exponent << 1);\n\n\treturn baud;\n}\n\nstatic speed_t pl2303_encode_baud_rate_divisor_alt(unsigned char buf[4],\n\t\t\t\t\t\t\t\tspeed_t baud)\n{\n\tunsigned int baseline, mantissa, exponent;\n\n\t \n\tbaseline = 12000000 * 32;\n\tmantissa = baseline / baud;\n\tif (mantissa == 0)\n\t\tmantissa = 1;    \n\texponent = 0;\n\twhile (mantissa >= 2048) {\n\t\tif (exponent < 15) {\n\t\t\tmantissa >>= 1;  \n\t\t\texponent++;\n\t\t} else {\n\t\t\t \n\t\t\tmantissa = 2047;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tbuf[3] = 0x80;\n\tbuf[2] = exponent & 0x01;\n\tbuf[1] = (exponent & ~0x01) << 4 | mantissa >> 8;\n\tbuf[0] = mantissa & 0xff;\n\n\t \n\tbaud = (baseline / mantissa) >> exponent;\n\n\treturn baud;\n}\n\nstatic void pl2303_encode_baud_rate(struct tty_struct *tty,\n\t\t\t\t\tstruct usb_serial_port *port,\n\t\t\t\t\tu8 buf[4])\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tspeed_t\tbaud_sup;\n\tspeed_t baud;\n\n\tbaud = tty_get_baud_rate(tty);\n\tdev_dbg(&port->dev, \"baud requested = %u\\n\", baud);\n\tif (!baud)\n\t\treturn;\n\n\tif (spriv->type->max_baud_rate)\n\t\tbaud = min_t(speed_t, baud, spriv->type->max_baud_rate);\n\t \n\tif (spriv->type->no_divisors)\n\t\tbaud_sup = baud;\n\telse\n\t\tbaud_sup = pl2303_get_supported_baud_rate(baud);\n\n\tif (baud == baud_sup)\n\t\tbaud = pl2303_encode_baud_rate_direct(buf, baud);\n\telse if (spriv->type->alt_divisors)\n\t\tbaud = pl2303_encode_baud_rate_divisor_alt(buf, baud);\n\telse\n\t\tbaud = pl2303_encode_baud_rate_divisor(buf, baud);\n\n\t \n\ttty_encode_baud_rate(tty, baud, baud);\n\tdev_dbg(&port->dev, \"baud set = %u\\n\", baud);\n}\n\nstatic int pl2303_get_line_request(struct usb_serial_port *port,\n\t\t\t\t\t\t\tunsigned char buf[7])\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\tGET_LINE_REQUEST, GET_LINE_REQUEST_TYPE,\n\t\t\t\t0, 0, buf, 7, 100);\n\tif (ret != 7) {\n\t\tdev_err(&port->dev, \"%s - failed: %d\\n\", __func__, ret);\n\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - %7ph\\n\", __func__, buf);\n\n\treturn 0;\n}\n\nstatic int pl2303_set_line_request(struct usb_serial_port *port,\n\t\t\t\t\t\t\tunsigned char buf[7])\n{\n\tstruct usb_device *udev = port->serial->dev;\n\tint ret;\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tSET_LINE_REQUEST, SET_LINE_REQUEST_TYPE,\n\t\t\t\t0, 0, buf, 7, 100);\n\tif (ret < 0) {\n\t\tdev_err(&port->dev, \"%s - failed: %d\\n\", __func__, ret);\n\t\treturn ret;\n\t}\n\n\tdev_dbg(&port->dev, \"%s - %7ph\\n\", __func__, buf);\n\n\treturn 0;\n}\n\nstatic bool pl2303_termios_change(const struct ktermios *a, const struct ktermios *b)\n{\n\tbool ixon_change;\n\n\tixon_change = ((a->c_iflag ^ b->c_iflag) & (IXON | IXANY)) ||\n\t\t\ta->c_cc[VSTART] != b->c_cc[VSTART] ||\n\t\t\ta->c_cc[VSTOP] != b->c_cc[VSTOP];\n\n\treturn tty_termios_hw_change(a, b) || ixon_change;\n}\n\nstatic bool pl2303_enable_xonxoff(struct tty_struct *tty, const struct pl2303_type_data *type)\n{\n\tif (!I_IXON(tty) || I_IXANY(tty))\n\t\treturn false;\n\n\tif (START_CHAR(tty) != 0x11 || STOP_CHAR(tty) != 0x13)\n\t\treturn false;\n\n\tif (type->no_autoxonxoff)\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic void pl2303_set_termios(struct tty_struct *tty,\n\t\t\t       struct usb_serial_port *port,\n\t\t\t       const struct ktermios *old_termios)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned char *buf;\n\tint ret;\n\tu8 control;\n\n\tif (old_termios && !pl2303_termios_change(&tty->termios, old_termios))\n\t\treturn;\n\n\tbuf = kzalloc(7, GFP_KERNEL);\n\tif (!buf) {\n\t\t \n\t\tif (old_termios)\n\t\t\ttty->termios = *old_termios;\n\t\treturn;\n\t}\n\n\tpl2303_get_line_request(port, buf);\n\n\tbuf[6] = tty_get_char_size(tty->termios.c_cflag);\n\tdev_dbg(&port->dev, \"data bits = %d\\n\", buf[6]);\n\n\t \n\tpl2303_encode_baud_rate(tty, port, &buf[0]);\n\n\t \n\t \n\t \n\tif (C_CSTOPB(tty)) {\n\t\t \n\t\tif (C_CSIZE(tty) == CS5) {\n\t\t\tbuf[4] = 1;\n\t\t\tdev_dbg(&port->dev, \"stop bits = 1.5\\n\");\n\t\t} else {\n\t\t\tbuf[4] = 2;\n\t\t\tdev_dbg(&port->dev, \"stop bits = 2\\n\");\n\t\t}\n\t} else {\n\t\tbuf[4] = 0;\n\t\tdev_dbg(&port->dev, \"stop bits = 1\\n\");\n\t}\n\n\tif (C_PARENB(tty)) {\n\t\t \n\t\t \n\t\t \n\t\t \n\t\t \n\t\tif (C_PARODD(tty)) {\n\t\t\tif (C_CMSPAR(tty)) {\n\t\t\t\tbuf[5] = 3;\n\t\t\t\tdev_dbg(&port->dev, \"parity = mark\\n\");\n\t\t\t} else {\n\t\t\t\tbuf[5] = 1;\n\t\t\t\tdev_dbg(&port->dev, \"parity = odd\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tif (C_CMSPAR(tty)) {\n\t\t\t\tbuf[5] = 4;\n\t\t\t\tdev_dbg(&port->dev, \"parity = space\\n\");\n\t\t\t} else {\n\t\t\t\tbuf[5] = 2;\n\t\t\t\tdev_dbg(&port->dev, \"parity = even\\n\");\n\t\t\t}\n\t\t}\n\t} else {\n\t\tbuf[5] = 0;\n\t\tdev_dbg(&port->dev, \"parity = none\\n\");\n\t}\n\n\t \n\tif (!old_termios || memcmp(buf, priv->line_settings, 7)) {\n\t\tret = pl2303_set_line_request(port, buf);\n\t\tif (!ret)\n\t\t\tmemcpy(priv->line_settings, buf, 7);\n\t}\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tcontrol = priv->line_control;\n\tif (C_BAUD(tty) == B0)\n\t\tpriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\n\telse if (old_termios && (old_termios->c_cflag & CBAUD) == B0)\n\t\tpriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\n\tif (control != priv->line_control) {\n\t\tcontrol = priv->line_control;\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t\tpl2303_set_control_lines(port, control);\n\t} else {\n\t\tspin_unlock_irqrestore(&priv->lock, flags);\n\t}\n\n\tif (C_CRTSCTS(tty)) {\n\t\tif (spriv->quirks & PL2303_QUIRK_LEGACY) {\n\t\t\tpl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x40);\n\t\t} else if (spriv->type == &pl2303_type_data[TYPE_HXN]) {\n\t\t\tpl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_MASK,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_RTS_CTS);\n\t\t} else {\n\t\t\tpl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0x60);\n\t\t}\n\t} else if (pl2303_enable_xonxoff(tty, spriv->type)) {\n\t\tif (spriv->type == &pl2303_type_data[TYPE_HXN]) {\n\t\t\tpl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_MASK,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_XON_XOFF);\n\t\t} else {\n\t\t\tpl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0xc0);\n\t\t}\n\t} else {\n\t\tif (spriv->type == &pl2303_type_data[TYPE_HXN]) {\n\t\t\tpl2303_update_reg(serial, PL2303_HXN_FLOWCTRL_REG,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_MASK,\n\t\t\t\t\tPL2303_HXN_FLOWCTRL_NONE);\n\t\t} else {\n\t\t\tpl2303_update_reg(serial, 0, PL2303_FLOWCTRL_MASK, 0);\n\t\t}\n\t}\n\n\tkfree(buf);\n}\n\nstatic void pl2303_dtr_rts(struct usb_serial_port *port, int on)\n{\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (on)\n\t\tpriv->line_control |= (CONTROL_DTR | CONTROL_RTS);\n\telse\n\t\tpriv->line_control &= ~(CONTROL_DTR | CONTROL_RTS);\n\tcontrol = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tpl2303_set_control_lines(port, control);\n}\n\nstatic void pl2303_close(struct usb_serial_port *port)\n{\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n\tpl2303_set_break(port, false);\n}\n\nstatic int pl2303_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tint result;\n\n\tif (spriv->quirks & PL2303_QUIRK_LEGACY) {\n\t\tusb_clear_halt(serial->dev, port->write_urb->pipe);\n\t\tusb_clear_halt(serial->dev, port->read_urb->pipe);\n\t} else {\n\t\t \n\t\tif (spriv->type == &pl2303_type_data[TYPE_HXN]) {\n\t\t\tpl2303_vendor_write(serial, PL2303_HXN_RESET_REG,\n\t\t\t\t\tPL2303_HXN_RESET_UPSTREAM_PIPE |\n\t\t\t\t\tPL2303_HXN_RESET_DOWNSTREAM_PIPE);\n\t\t} else {\n\t\t\tpl2303_vendor_write(serial, 8, 0);\n\t\t\tpl2303_vendor_write(serial, 9, 0);\n\t\t}\n\t}\n\n\t \n\tif (tty)\n\t\tpl2303_set_termios(tty, port, NULL);\n\n\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(&port->dev, \"failed to submit interrupt urb: %d\\n\",\n\t\t\tresult);\n\t\treturn result;\n\t}\n\n\tresult = usb_serial_generic_open(tty, port);\n\tif (result) {\n\t\tusb_kill_urb(port->interrupt_in_urb);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl2303_tiocmset(struct tty_struct *tty,\n\t\t\t   unsigned int set, unsigned int clear)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tu8 control;\n\tint ret;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tif (set & TIOCM_RTS)\n\t\tpriv->line_control |= CONTROL_RTS;\n\tif (set & TIOCM_DTR)\n\t\tpriv->line_control |= CONTROL_DTR;\n\tif (clear & TIOCM_RTS)\n\t\tpriv->line_control &= ~CONTROL_RTS;\n\tif (clear & TIOCM_DTR)\n\t\tpriv->line_control &= ~CONTROL_DTR;\n\tcontrol = priv->line_control;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tret = pl2303_set_control_lines(port, control);\n\tif (ret)\n\t\treturn usb_translate_errors(ret);\n\n\treturn 0;\n}\n\nstatic int pl2303_tiocmget(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned long flags;\n\tunsigned int mcr;\n\tunsigned int status;\n\tunsigned int result;\n\n\tspin_lock_irqsave(&priv->lock, flags);\n\tmcr = priv->line_control;\n\tstatus = priv->line_status;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tresult = ((mcr & CONTROL_DTR)\t\t? TIOCM_DTR : 0)\n\t\t  | ((mcr & CONTROL_RTS)\t? TIOCM_RTS : 0)\n\t\t  | ((status & UART_CTS)\t? TIOCM_CTS : 0)\n\t\t  | ((status & UART_DSR)\t? TIOCM_DSR : 0)\n\t\t  | ((status & UART_RING)\t? TIOCM_RI  : 0)\n\t\t  | ((status & UART_DCD)\t? TIOCM_CD  : 0);\n\n\tdev_dbg(&port->dev, \"%s - result = %x\\n\", __func__, result);\n\n\treturn result;\n}\n\nstatic int pl2303_carrier_raised(struct usb_serial_port *port)\n{\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\n\tif (priv->line_status & UART_DCD)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int pl2303_set_break(struct usb_serial_port *port, bool enable)\n{\n\tstruct usb_serial *serial = port->serial;\n\tu16 state;\n\tint result;\n\n\tif (enable)\n\t\tstate = BREAK_ON;\n\telse\n\t\tstate = BREAK_OFF;\n\n\tdev_dbg(&port->dev, \"%s - turning break %s\\n\", __func__,\n\t\t\tstate == BREAK_OFF ? \"off\" : \"on\");\n\n\tresult = usb_control_msg(serial->dev, usb_sndctrlpipe(serial->dev, 0),\n\t\t\t\t BREAK_REQUEST, BREAK_REQUEST_TYPE, state,\n\t\t\t\t 0, NULL, 0, 100);\n\tif (result) {\n\t\tdev_err(&port->dev, \"error sending break = %d\\n\", result);\n\t\treturn result;\n\t}\n\n\treturn 0;\n}\n\nstatic int pl2303_break_ctl(struct tty_struct *tty, int state)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\n\treturn pl2303_set_break(port, state);\n}\n\nstatic void pl2303_update_line_status(struct usb_serial_port *port,\n\t\t\t\t      unsigned char *data,\n\t\t\t\t      unsigned int actual_length)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct pl2303_serial_private *spriv = usb_get_serial_data(serial);\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tstruct tty_struct *tty;\n\tunsigned long flags;\n\tunsigned int status_idx = UART_STATE_INDEX;\n\tu8 status;\n\tu8 delta;\n\n\tif (spriv->quirks & PL2303_QUIRK_UART_STATE_IDX0)\n\t\tstatus_idx = 0;\n\n\tif (actual_length < status_idx + 1)\n\t\treturn;\n\n\tstatus = data[status_idx];\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tdelta = priv->line_status ^ status;\n\tpriv->line_status = status;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (status & UART_BREAK_ERROR)\n\t\tusb_serial_handle_break(port);\n\n\tif (delta & UART_STATE_MSR_MASK) {\n\t\tif (delta & UART_CTS)\n\t\t\tport->icount.cts++;\n\t\tif (delta & UART_DSR)\n\t\t\tport->icount.dsr++;\n\t\tif (delta & UART_RING)\n\t\t\tport->icount.rng++;\n\t\tif (delta & UART_DCD) {\n\t\t\tport->icount.dcd++;\n\t\t\ttty = tty_port_tty_get(&port->port);\n\t\t\tif (tty) {\n\t\t\t\tusb_serial_handle_dcd_change(port, tty,\n\t\t\t\t\t\t\tstatus & UART_DCD);\n\t\t\t\ttty_kref_put(tty);\n\t\t\t}\n\t\t}\n\n\t\twake_up_interruptible(&port->port.delta_msr_wait);\n\t}\n}\n\nstatic void pl2303_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port =  urb->context;\n\tunsigned char *data = urb->transfer_buffer;\n\tunsigned int actual_length = urb->actual_length;\n\tint status = urb->status;\n\tint retval;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tusb_serial_debug_data(&port->dev, __func__,\n\t\t\t      urb->actual_length, urb->transfer_buffer);\n\n\tpl2303_update_line_status(port, data, actual_length);\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&port->dev,\n\t\t\t\"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\nstatic void pl2303_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tstruct pl2303_private *priv = usb_get_serial_port_data(port);\n\tunsigned char *data = urb->transfer_buffer;\n\tchar tty_flag = TTY_NORMAL;\n\tunsigned long flags;\n\tu8 line_status;\n\tint i;\n\n\t \n\tspin_lock_irqsave(&priv->lock, flags);\n\tline_status = priv->line_status;\n\tpriv->line_status &= ~UART_STATE_TRANSIENT_MASK;\n\tspin_unlock_irqrestore(&priv->lock, flags);\n\n\tif (!urb->actual_length)\n\t\treturn;\n\n\t \n\tif (line_status & UART_BREAK_ERROR)\n\t\ttty_flag = TTY_BREAK;\n\telse if (line_status & UART_PARITY_ERROR)\n\t\ttty_flag = TTY_PARITY;\n\telse if (line_status & UART_FRAME_ERROR)\n\t\ttty_flag = TTY_FRAME;\n\n\tif (tty_flag != TTY_NORMAL)\n\t\tdev_dbg(&port->dev, \"%s - tty_flag = %d\\n\", __func__,\n\t\t\t\t\t\t\t\ttty_flag);\n\t \n\tif (line_status & UART_OVERRUN_ERROR)\n\t\ttty_insert_flip_char(&port->port, 0, TTY_OVERRUN);\n\n\tif (port->sysrq) {\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tif (!usb_serial_handle_sysrq_char(port, data[i]))\n\t\t\t\ttty_insert_flip_char(&port->port, data[i],\n\t\t\t\t\t\ttty_flag);\n\t} else {\n\t\ttty_insert_flip_string_fixed_flag(&port->port, data, tty_flag,\n\t\t\t\t\t\t\turb->actual_length);\n\t}\n\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic struct usb_serial_driver pl2303_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"pl2303\",\n\t},\n\t.id_table =\t\tid_table,\n\t.num_bulk_in =\t\t1,\n\t.num_bulk_out =\t\t1,\n\t.num_interrupt_in =\t0,\t \n\t.bulk_in_size =\t\t256,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tpl2303_open,\n\t.close =\t\tpl2303_close,\n\t.dtr_rts =\t\tpl2303_dtr_rts,\n\t.carrier_raised =\tpl2303_carrier_raised,\n\t.break_ctl =\t\tpl2303_break_ctl,\n\t.set_termios =\t\tpl2303_set_termios,\n\t.tiocmget =\t\tpl2303_tiocmget,\n\t.tiocmset =\t\tpl2303_tiocmset,\n\t.tiocmiwait =\t\tusb_serial_generic_tiocmiwait,\n\t.process_read_urb =\tpl2303_process_read_urb,\n\t.read_int_callback =\tpl2303_read_int_callback,\n\t.probe =\t\tpl2303_probe,\n\t.calc_num_ports =\tpl2303_calc_num_ports,\n\t.attach =\t\tpl2303_startup,\n\t.release =\t\tpl2303_release,\n\t.port_probe =\t\tpl2303_port_probe,\n\t.port_remove =\t\tpl2303_port_remove,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&pl2303_device, NULL\n};\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_DESCRIPTION(\"Prolific PL2303 USB to serial adaptor driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}