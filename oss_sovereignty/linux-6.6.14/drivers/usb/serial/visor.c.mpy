{
  "module_name": "visor.c",
  "hash_id": "486f0aea3a4ee13b6c16ebdef38de46ddf8652d1694ef6853e6b9fb75ed8e9d3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/serial/visor.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/spinlock.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n#include <linux/usb/cdc.h>\n#include \"visor.h\"\n\n \n#define DRIVER_AUTHOR \"Greg Kroah-Hartman <greg@kroah.com>\"\n#define DRIVER_DESC \"USB HandSpring Visor / Palm OS driver\"\n\n \nstatic int  visor_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void visor_close(struct usb_serial_port *port);\nstatic int  visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int  visor_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds);\nstatic int  clie_5_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds);\nstatic void visor_read_int_callback(struct urb *urb);\nstatic int  clie_3_5_startup(struct usb_serial *serial);\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_3_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id clie_id_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID),\n\t\t.driver_info = (kernel_ulong_t)&palm_os_4_probe },\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id clie_id_3_5_table[] = {\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ }\t\t\t\t\t \n};\n\nstatic const struct usb_device_id id_table_combined[] = {\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_VISOR_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO_ID) },\n\t{ USB_DEVICE(HANDSPRING_VENDOR_ID, HANDSPRING_TREO600_ID) },\n\t{ USB_DEVICE(GSPDA_VENDOR_ID, GSPDA_XPLORE_M68_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M500_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M505_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M515_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_I705_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M100_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M125_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_M130_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_T_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TREO_650) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_TUNGSTEN_Z_ID) },\n\t{ USB_DEVICE(PALM_VENDOR_ID, PALM_ZIRE_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_3_5_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_0_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_S360_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_4_1_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NX60_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_NZ90V_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_UX50_ID) },\n\t{ USB_DEVICE(SONY_VENDOR_ID, SONY_CLIE_TJ25_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID) },\n\t{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID) },\n\t{ USB_DEVICE(TAPWAVE_VENDOR_ID, TAPWAVE_ZODIAC_ID) },\n\t{ USB_DEVICE(GARMIN_VENDOR_ID, GARMIN_IQUE_3600_ID) },\n\t{ USB_DEVICE(ACEECA_VENDOR_ID, ACEECA_MEZ1000_ID) },\n\t{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_7135_ID) },\n\t{ USB_DEVICE(FOSSIL_VENDOR_ID, FOSSIL_ABACUS_ID) },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, id_table_combined);\n\n \nstatic struct usb_serial_driver handspring_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"visor\",\n\t},\n\t.description =\t\t\"Handspring Visor / Palm OS\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tvisor_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n \nstatic struct usb_serial_driver clie_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_5\",\n\t},\n\t.description =\t\t\"Sony Clie 5.0\",\n\t.id_table =\t\tclie_id_5_table,\n\t.num_ports =\t\t2,\n\t.num_bulk_out =\t\t2,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.probe =\t\tvisor_probe,\n\t.calc_num_ports =\tclie_5_calc_num_ports,\n\t.read_int_callback =\tvisor_read_int_callback,\n};\n\n \nstatic struct usb_serial_driver clie_3_5_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"clie_3.5\",\n\t},\n\t.description =\t\t\"Sony Clie 3.5\",\n\t.id_table =\t\tclie_id_3_5_table,\n\t.num_ports =\t\t1,\n\t.bulk_out_size =\t256,\n\t.open =\t\t\tvisor_open,\n\t.close =\t\tvisor_close,\n\t.throttle =\t\tusb_serial_generic_throttle,\n\t.unthrottle =\t\tusb_serial_generic_unthrottle,\n\t.attach =\t\tclie_3_5_startup,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&handspring_device, &clie_5_device, &clie_3_5_device, NULL\n};\n\n \nstatic int visor_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tint result = 0;\n\n\tif (!port->read_urb) {\n\t\t \n\t\tdev_err(&port->dev, \"Device lied about number of ports, please use a lower one.\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tresult = usb_serial_generic_open(tty, port);\n\tif (result)\n\t\tgoto exit;\n\n\tif (port->interrupt_in_urb) {\n\t\tdev_dbg(&port->dev, \"adding interrupt input for treo\\n\");\n\t\tresult = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);\n\t\tif (result)\n\t\t\tdev_err(&port->dev,\n\t\t\t    \"%s - failed submitting interrupt urb, error %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t}\nexit:\n\treturn result;\n}\n\n\nstatic void visor_close(struct usb_serial_port *port)\n{\n\tunsigned char *transfer_buffer;\n\n\tusb_serial_generic_close(port);\n\tusb_kill_urb(port->interrupt_in_urb);\n\n\ttransfer_buffer = kmalloc(0x12, GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn;\n\tusb_control_msg(port->serial->dev,\n\t\t\t\t\t usb_rcvctrlpipe(port->serial->dev, 0),\n\t\t\t\t\t VISOR_CLOSE_NOTIFICATION, 0xc2,\n\t\t\t\t\t 0x0000, 0x0000,\n\t\t\t\t\t transfer_buffer, 0x12, 300);\n\tkfree(transfer_buffer);\n}\n\nstatic void visor_read_int_callback(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tint status = urb->status;\n\tint result;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(&port->dev, \"%s - urb shutting down with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(&port->dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\t \n\tusb_serial_debug_data(&port->dev, __func__, urb->actual_length,\n\t\t\t      urb->transfer_buffer);\n\nexit:\n\tresult = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (result)\n\t\tdev_err(&urb->dev->dev,\n\t\t\t\t\"%s - Error %d submitting interrupt urb\\n\",\n\t\t\t\t\t\t\t__func__, result);\n}\n\nstatic int palm_os_3_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct visor_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tchar *string;\n\tint retval = 0;\n\tint i;\n\tint num_ports = 0;\n\n\ttransfer_buffer = kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\t \n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_GET_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0) {\n\t\tdev_err(dev, \"%s - error %d getting connection information\\n\",\n\t\t\t__func__, retval);\n\t\tgoto exit;\n\t}\n\n\tif (retval != sizeof(*connection_info)) {\n\t\tdev_err(dev, \"Invalid connection information received from device\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tconnection_info = (struct visor_connection_info *)transfer_buffer;\n\n\tnum_ports = le16_to_cpu(connection_info->num_ports);\n\n\t \n\tif (num_ports == 0 || num_ports > 2) {\n\t\tdev_warn(dev, \"%s: No valid connect info available\\n\",\n\t\t\tserial->type->description);\n\t\tnum_ports = 2;\n\t}\n\n\tfor (i = 0; i < num_ports; ++i) {\n\t\tswitch (connection_info->connections[i].port_function_id) {\n\t\tcase VISOR_FUNCTION_GENERIC:\n\t\t\tstring = \"Generic\";\n\t\t\tbreak;\n\t\tcase VISOR_FUNCTION_DEBUGGER:\n\t\t\tstring = \"Debugger\";\n\t\t\tbreak;\n\t\tcase VISOR_FUNCTION_HOTSYNC:\n\t\t\tstring = \"HotSync\";\n\t\t\tbreak;\n\t\tcase VISOR_FUNCTION_CONSOLE:\n\t\t\tstring = \"Console\";\n\t\t\tbreak;\n\t\tcase VISOR_FUNCTION_REMOTE_FILE_SYS:\n\t\t\tstring = \"Remote File System\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstring = \"unknown\";\n\t\t\tbreak;\n\t\t}\n\t\tdev_info(dev, \"%s: port %d, is for %s use\\n\",\n\t\t\tserial->type->description,\n\t\t\tconnection_info->connections[i].port, string);\n\t}\n\tdev_info(dev, \"%s: Number of ports: %d\\n\", serial->type->description,\n\t\tnum_ports);\n\n\t \n\tusb_set_serial_data(serial, (void *)(long)num_ports);\n\n\t \n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  VISOR_REQUEST_BYTES_AVAILABLE,\n\t\t\t\t  0xc2, 0x0000, 0x0005, transfer_buffer,\n\t\t\t\t  0x02, 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting bytes available request\\n\",\n\t\t\t__func__, retval);\n\tretval = 0;\n\nexit:\n\tkfree(transfer_buffer);\n\n\treturn retval;\n}\n\nstatic int palm_os_4_probe(struct usb_serial *serial,\n\t\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tstruct palm_ext_connection_info *connection_info;\n\tunsigned char *transfer_buffer;\n\tint retval;\n\n\ttransfer_buffer =  kmalloc(sizeof(*connection_info), GFP_KERNEL);\n\tif (!transfer_buffer)\n\t\treturn -ENOMEM;\n\n\tretval = usb_control_msg(serial->dev,\n\t\t\t\t  usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  PALM_GET_EXT_CONNECTION_INFORMATION,\n\t\t\t\t  0xc2, 0x0000, 0x0000, transfer_buffer,\n\t\t\t\t  sizeof(*connection_info), 300);\n\tif (retval < 0)\n\t\tdev_err(dev, \"%s - error %d getting connection info\\n\",\n\t\t\t__func__, retval);\n\telse\n\t\tusb_serial_debug_data(dev, __func__, retval, transfer_buffer);\n\n\tkfree(transfer_buffer);\n\treturn 0;\n}\n\n\nstatic int visor_probe(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id)\n{\n\tint retval = 0;\n\tint (*startup)(struct usb_serial *serial,\n\t\t\t\t\tconst struct usb_device_id *id);\n\n\t \n\tif (id->idVendor == SAMSUNG_VENDOR_ID &&\n\t\tid->idProduct == SAMSUNG_SPH_I500_ID &&\n\t\tserial->dev->descriptor.bDeviceClass == USB_CLASS_COMM &&\n\t\tserial->dev->descriptor.bDeviceSubClass ==\n\t\t\tUSB_CDC_SUBCLASS_ACM)\n\t\treturn -ENODEV;\n\n\tif (serial->dev->actconfig->desc.bConfigurationValue != 1) {\n\t\tdev_err(&serial->dev->dev, \"active config #%d != 1 ??\\n\",\n\t\t\tserial->dev->actconfig->desc.bConfigurationValue);\n\t\treturn -ENODEV;\n\t}\n\n\tif (id->driver_info) {\n\t\tstartup = (void *)id->driver_info;\n\t\tretval = startup(serial, id);\n\t}\n\n\treturn retval;\n}\n\nstatic int visor_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\tunsigned int vid = le16_to_cpu(serial->dev->descriptor.idVendor);\n\tint num_ports = (int)(long)(usb_get_serial_data(serial));\n\n\tif (num_ports)\n\t\tusb_set_serial_data(serial, NULL);\n\n\t \n\tif (!(vid == HANDSPRING_VENDOR_ID || vid == KYOCERA_VENDOR_ID) ||\n\t\t\tepds->num_interrupt_in == 0)\n\t\tgoto out;\n\n\tif (epds->num_bulk_in < 2 || epds->num_interrupt_in < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tswap(epds->bulk_in[0], epds->bulk_in[1]);\n\tswap(epds->interrupt_in[0], epds->interrupt_in[1]);\nout:\n\treturn num_ports;\n}\n\nstatic int clie_5_calc_num_ports(struct usb_serial *serial,\n\t\t\t\t\tstruct usb_serial_endpoints *epds)\n{\n\t \n\n\t \n\tepds->bulk_out[0] = epds->bulk_out[1];\n\n\treturn serial->type->num_ports;\n}\n\nstatic int clie_3_5_startup(struct usb_serial *serial)\n{\n\tstruct device *dev = &serial->dev->dev;\n\tint result;\n\tu8 *data;\n\n\tdata = kmalloc(1, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t \n\n\t \n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_CONFIGURATION, USB_DIR_IN,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get config number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev, \"%s: get config number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\t \n\tresult = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n\t\t\t\t  USB_REQ_GET_INTERFACE,\n\t\t\t\t  USB_DIR_IN | USB_RECIP_INTERFACE,\n\t\t\t\t  0, 0, data, 1, 3000);\n\tif (result < 0) {\n\t\tdev_err(dev, \"%s: get interface number failed: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tgoto out;\n\t}\n\tif (result != 1) {\n\t\tdev_err(dev,\n\t\t\t\"%s: get interface number bad return length: %d\\n\",\n\t\t\t\t\t\t\t__func__, result);\n\t\tresult = -EIO;\n\t\tgoto out;\n\t}\n\n\tresult = 0;\nout:\n\tkfree(data);\n\n\treturn result;\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table_combined);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}