{
  "module_name": "lvstest.c",
  "hash_id": "eca7eb63b0e753fa58cba0955e17ca974123b7c4e26baf5c39e581cca2ec772e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/lvstest.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/ch11.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/phy.h>\n\nstruct lvs_rh {\n\t \n\tstruct usb_interface *intf;\n\t \n\tbool present;\n\t \n\tint portnum;\n\t \n\tu8 buffer[8];\n\t \n\tstruct usb_hub_descriptor descriptor;\n\t \n\tstruct urb *urb;\n\t \n\tstruct work_struct\trh_work;\n\t \n\tstruct usb_port_status port_status;\n};\n\nstatic struct usb_device *create_lvs_device(struct usb_interface *intf)\n{\n\tstruct usb_device *udev, *hdev;\n\tstruct usb_hcd *hcd;\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\n\tif (!lvs->present) {\n\t\tdev_err(&intf->dev, \"No LVS device is present\\n\");\n\t\treturn NULL;\n\t}\n\n\thdev = interface_to_usbdev(intf);\n\thcd = bus_to_hcd(hdev->bus);\n\n\tudev = usb_alloc_dev(hdev, hdev->bus, lvs->portnum);\n\tif (!udev) {\n\t\tdev_err(&intf->dev, \"Could not allocate lvs udev\\n\");\n\t\treturn NULL;\n\t}\n\tudev->speed = USB_SPEED_SUPER;\n\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\n\tif (hcd->driver->enable_device) {\n\t\tif (hcd->driver->enable_device(hcd, udev) < 0) {\n\t\t\tdev_err(&intf->dev, \"Failed to enable\\n\");\n\t\t\tusb_put_dev(udev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn udev;\n}\n\nstatic void destroy_lvs_device(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\n\tif (hcd->driver->free_dev)\n\t\thcd->driver->free_dev(hcd, udev);\n\n\tusb_put_dev(udev);\n}\n\nstatic int lvs_rh_clear_port_feature(struct usb_device *hdev,\n\t\tint port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic int lvs_rh_set_port_feature(struct usb_device *hdev,\n\t\tint port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic ssize_t u3_entry_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tstruct usb_device *udev;\n\tint ret;\n\n\tudev = create_lvs_device(intf);\n\tif (!udev) {\n\t\tdev_err(dev, \"failed to create lvs device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = lvs_rh_set_port_feature(hdev, lvs->portnum,\n\t\t\tUSB_PORT_FEAT_SUSPEND);\n\tif (ret < 0)\n\t\tdev_err(dev, \"can't issue U3 entry %d\\n\", ret);\n\n\tdestroy_lvs_device(udev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(u3_entry);\n\nstatic ssize_t u3_exit_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tstruct usb_device *udev;\n\tint ret;\n\n\tudev = create_lvs_device(intf);\n\tif (!udev) {\n\t\tdev_err(dev, \"failed to create lvs device\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tret = lvs_rh_clear_port_feature(hdev, lvs->portnum,\n\t\t\tUSB_PORT_FEAT_SUSPEND);\n\tif (ret < 0)\n\t\tdev_err(dev, \"can't issue U3 exit %d\\n\", ret);\n\n\tdestroy_lvs_device(udev);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(u3_exit);\n\nstatic ssize_t hot_reset_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tint ret;\n\n\tret = lvs_rh_set_port_feature(hdev, lvs->portnum,\n\t\t\tUSB_PORT_FEAT_RESET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't issue hot reset %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(hot_reset);\n\nstatic ssize_t warm_reset_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tint ret;\n\n\tret = lvs_rh_set_port_feature(hdev, lvs->portnum,\n\t\t\tUSB_PORT_FEAT_BH_PORT_RESET);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't issue warm reset %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(warm_reset);\n\nstatic ssize_t u2_timeout_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"couldn't parse string %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val > 127)\n\t\treturn -EINVAL;\n\n\tret = lvs_rh_set_port_feature(hdev, lvs->portnum | (val << 8),\n\t\t\tUSB_PORT_FEAT_U2_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error %d while setting U2 timeout %ld\\n\", ret, val);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(u2_timeout);\n\nstatic ssize_t u1_timeout_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul(buf, 10, &val);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"couldn't parse string %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tif (val > 127)\n\t\treturn -EINVAL;\n\n\tret = lvs_rh_set_port_feature(hdev, lvs->portnum | (val << 8),\n\t\t\tUSB_PORT_FEAT_U1_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"Error %d while setting U1 timeout %ld\\n\", ret, val);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(u1_timeout);\n\nstatic ssize_t get_dev_desc_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *udev;\n\tstruct usb_device_descriptor *descriptor;\n\tint ret;\n\n\tdescriptor = kmalloc(sizeof(*descriptor), GFP_KERNEL);\n\tif (!descriptor)\n\t\treturn -ENOMEM;\n\n\tudev = create_lvs_device(intf);\n\tif (!udev) {\n\t\tdev_err(dev, \"failed to create lvs device\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto free_desc;\n\t}\n\n\tret = usb_control_msg(udev, (PIPE_CONTROL << 30) | USB_DIR_IN,\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN, USB_DT_DEVICE << 8,\n\t\t\t0, descriptor, sizeof(*descriptor),\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\tif (ret < 0)\n\t\tdev_err(dev, \"can't read device descriptor %d\\n\", ret);\n\n\tdestroy_lvs_device(udev);\n\nfree_desc:\n\tkfree(descriptor);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(get_dev_desc);\n\nstatic ssize_t enable_compliance_store(struct device *dev,\n\t\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\tint ret;\n\n\tret = lvs_rh_set_port_feature(hdev,\n\t\t\tlvs->portnum | USB_SS_PORT_LS_COMP_MOD << 3,\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't enable compliance mode %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\treturn count;\n}\nstatic DEVICE_ATTR_WO(enable_compliance);\n\nstatic struct attribute *lvs_attrs[] = {\n\t&dev_attr_get_dev_desc.attr,\n\t&dev_attr_u1_timeout.attr,\n\t&dev_attr_u2_timeout.attr,\n\t&dev_attr_hot_reset.attr,\n\t&dev_attr_warm_reset.attr,\n\t&dev_attr_u3_entry.attr,\n\t&dev_attr_u3_exit.attr,\n\t&dev_attr_enable_compliance.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(lvs);\n\nstatic void lvs_rh_work(struct work_struct *work)\n{\n\tstruct lvs_rh *lvs = container_of(work, struct lvs_rh, rh_work);\n\tstruct usb_interface *intf = lvs->intf;\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_hub_descriptor *descriptor = &lvs->descriptor;\n\tstruct usb_port_status *port_status = &lvs->port_status;\n\tint i, ret = 0;\n\tu16 portchange;\n\n\t \n\tfor (i = 1; i <= descriptor->bNbrPorts; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, i,\n\t\t\tport_status, sizeof(*port_status), 1000);\n\t\tif (ret < 4)\n\t\t\tcontinue;\n\n\t\tportchange = le16_to_cpu(port_status->wPortChange);\n\n\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\tlvs_rh_clear_port_feature(hdev, i,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tlvs_rh_clear_port_feature(hdev, i,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\tif (portchange & USB_PORT_STAT_C_RESET)\n\t\t\tlvs_rh_clear_port_feature(hdev, i,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\tif (portchange & USB_PORT_STAT_C_BH_RESET)\n\t\t\tlvs_rh_clear_port_feature(hdev, i,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tlvs_rh_clear_port_feature(hdev, i,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\tif (le16_to_cpu(port_status->wPortStatus) &\n\t\t\t\t\tUSB_PORT_STAT_CONNECTION) {\n\t\t\t\tlvs->present = true;\n\t\t\t\tlvs->portnum = i;\n\t\t\t\tif (hcd->usb_phy)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tUSB_SPEED_SUPER);\n\t\t\t} else {\n\t\t\t\tlvs->present = false;\n\t\t\t\tif (hcd->usb_phy)\n\t\t\t\t\tusb_phy_notify_disconnect(hcd->usb_phy,\n\t\t\t\t\t\t\tUSB_SPEED_SUPER);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = usb_submit_urb(lvs->urb, GFP_KERNEL);\n\tif (ret != 0 && ret != -ENODEV && ret != -EPERM)\n\t\tdev_err(&intf->dev, \"urb resubmit error %d\\n\", ret);\n}\n\nstatic void lvs_rh_irq(struct urb *urb)\n{\n\tstruct lvs_rh *lvs = urb->context;\n\n\tschedule_work(&lvs->rh_work);\n}\n\nstatic int lvs_rh_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_host_interface *desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct lvs_rh *lvs;\n\tunsigned int pipe;\n\tint ret, maxp;\n\n\thdev = interface_to_usbdev(intf);\n\tdesc = intf->cur_altsetting;\n\n\tret = usb_find_int_in_endpoint(desc, &endpoint);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (hdev->descriptor.bDeviceProtocol != USB_HUB_PR_SS || hdev->parent) {\n\t\tdev_err(&intf->dev, \"Bind LVS driver with SS root Hub only\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tlvs = devm_kzalloc(&intf->dev, sizeof(*lvs), GFP_KERNEL);\n\tif (!lvs)\n\t\treturn -ENOMEM;\n\n\tlvs->intf = intf;\n\tusb_set_intfdata(intf, lvs);\n\n\t \n\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tUSB_DT_SS_HUB << 8, 0, &lvs->descriptor,\n\t\t\tUSB_DT_SS_HUB_SIZE, USB_CTRL_GET_TIMEOUT);\n\tif (ret < (USB_DT_HUB_NONVAR_SIZE + 2)) {\n\t\tdev_err(&hdev->dev, \"wrong root hub descriptor read %d\\n\", ret);\n\t\treturn ret < 0 ? ret : -EINVAL;\n\t}\n\n\t \n\tlvs->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!lvs->urb)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&lvs->rh_work, lvs_rh_work);\n\n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe);\n\tusb_fill_int_urb(lvs->urb, hdev, pipe, &lvs->buffer[0], maxp,\n\t\t\tlvs_rh_irq, lvs, endpoint->bInterval);\n\n\tret = usb_submit_urb(lvs->urb, GFP_KERNEL);\n\tif (ret < 0) {\n\t\tdev_err(&intf->dev, \"couldn't submit lvs urb %d\\n\", ret);\n\t\tgoto free_urb;\n\t}\n\n\treturn ret;\n\nfree_urb:\n\tusb_free_urb(lvs->urb);\n\treturn ret;\n}\n\nstatic void lvs_rh_disconnect(struct usb_interface *intf)\n{\n\tstruct lvs_rh *lvs = usb_get_intfdata(intf);\n\n\tusb_poison_urb(lvs->urb);  \n\tflush_work(&lvs->rh_work);\n\tusb_free_urb(lvs->urb);\n}\n\nstatic struct usb_driver lvs_driver = {\n\t.name =\t\t\"lvs\",\n\t.probe =\tlvs_rh_probe,\n\t.disconnect =\tlvs_rh_disconnect,\n\t.dev_groups =\tlvs_groups,\n};\n\nmodule_usb_driver(lvs_driver);\n\nMODULE_DESCRIPTION(\"Link Layer Validation System Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}