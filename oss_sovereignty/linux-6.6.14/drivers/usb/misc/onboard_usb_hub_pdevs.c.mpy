{
  "module_name": "onboard_usb_hub_pdevs.c",
  "hash_id": "adb3c3ec9c0b0eb3eca8dbe913c7766b40a279e9a6130708a6808131096b5379",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/onboard_usb_hub_pdevs.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/of.h>\n#include <linux/usb/onboard_hub.h>\n\n#include \"onboard_usb_hub.h\"\n\nstruct pdev_list_entry {\n\tstruct platform_device *pdev;\n\tstruct list_head node;\n};\n\nstatic bool of_is_onboard_usb_hub(const struct device_node *np)\n{\n\treturn !!of_match_node(onboard_hub_match, np);\n}\n\n \nvoid onboard_hub_create_pdevs(struct usb_device *parent_hub, struct list_head *pdev_list)\n{\n\tint i;\n\tstruct usb_hcd *hcd = bus_to_hcd(parent_hub->bus);\n\tstruct device_node *np, *npc;\n\tstruct platform_device *pdev;\n\tstruct pdev_list_entry *pdle;\n\n\tif (!parent_hub->dev.of_node)\n\t\treturn;\n\n\tif (!parent_hub->parent && !usb_hcd_is_primary_hcd(hcd))\n\t\treturn;\n\n\tfor (i = 1; i <= parent_hub->maxchild; i++) {\n\t\tnp = usb_of_get_device_node(parent_hub, i);\n\t\tif (!np)\n\t\t\tcontinue;\n\n\t\tif (!of_is_onboard_usb_hub(np))\n\t\t\tgoto node_put;\n\n\t\tnpc = of_parse_phandle(np, \"peer-hub\", 0);\n\t\tif (npc) {\n\t\t\tif (!usb_hcd_is_primary_hcd(hcd)) {\n\t\t\t\tof_node_put(npc);\n\t\t\t\tgoto node_put;\n\t\t\t}\n\n\t\t\tpdev = of_find_device_by_node(npc);\n\t\t\tof_node_put(npc);\n\n\t\t\tif (pdev) {\n\t\t\t\tput_device(&pdev->dev);\n\t\t\t\tgoto node_put;\n\t\t\t}\n\t\t}\n\n\t\tpdev = of_platform_device_create(np, NULL, &parent_hub->dev);\n\t\tif (!pdev) {\n\t\t\tdev_err(&parent_hub->dev,\n\t\t\t\t\"failed to create platform device for onboard hub '%pOF'\\n\", np);\n\t\t\tgoto node_put;\n\t\t}\n\n\t\tpdle = kzalloc(sizeof(*pdle), GFP_KERNEL);\n\t\tif (!pdle) {\n\t\t\tof_platform_device_destroy(&pdev->dev, NULL);\n\t\t\tgoto node_put;\n\t\t}\n\n\t\tpdle->pdev = pdev;\n\t\tlist_add(&pdle->node, pdev_list);\n\nnode_put:\n\t\tof_node_put(np);\n\t}\n}\nEXPORT_SYMBOL_GPL(onboard_hub_create_pdevs);\n\n \nvoid onboard_hub_destroy_pdevs(struct list_head *pdev_list)\n{\n\tstruct pdev_list_entry *pdle, *tmp;\n\n\tlist_for_each_entry_safe(pdle, tmp, pdev_list, node) {\n\t\tlist_del(&pdle->node);\n\t\tof_platform_device_destroy(&pdle->pdev->dev, NULL);\n\t\tkfree(pdle);\n\t}\n}\nEXPORT_SYMBOL_GPL(onboard_hub_destroy_pdevs);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}