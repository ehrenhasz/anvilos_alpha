{
  "module_name": "usb3503.c",
  "hash_id": "ce211378b4aef06de3f422bbcf1f65e43904da6afc552c9c6b11de265d3373d8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/usb3503.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/i2c.h>\n#include <linux/gpio/consumer.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/usb3503.h>\n#include <linux/regmap.h>\n\n#define USB3503_VIDL\t\t0x00\n#define USB3503_VIDM\t\t0x01\n#define USB3503_PIDL\t\t0x02\n#define USB3503_PIDM\t\t0x03\n#define USB3503_DIDL\t\t0x04\n#define USB3503_DIDM\t\t0x05\n\n#define USB3503_CFG1\t\t0x06\n#define USB3503_SELF_BUS_PWR\t(1 << 7)\n\n#define USB3503_CFG2\t\t0x07\n#define USB3503_CFG3\t\t0x08\n#define USB3503_NRD\t\t0x09\n\n#define USB3503_PDS\t\t0x0a\n\n#define USB3503_SP_ILOCK\t0xe7\n#define USB3503_SPILOCK_CONNECT\t(1 << 1)\n#define USB3503_SPILOCK_CONFIG\t(1 << 0)\n\n#define USB3503_CFGP\t\t0xee\n#define USB3503_CLKSUSP\t\t(1 << 7)\n\n#define USB3503_RESET\t\t0xff\n\nstruct usb3503 {\n\tenum usb3503_mode\tmode;\n\tstruct regmap\t\t*regmap;\n\tstruct device\t\t*dev;\n\tstruct clk\t\t*clk;\n\tu8\tport_off_mask;\n\tstruct gpio_desc\t*bypass;\n\tstruct gpio_desc\t*intn;\n\tstruct gpio_desc \t*reset;\n\tstruct gpio_desc \t*connect;\n\tbool\tsecondary_ref_clk;\n};\n\nstatic int usb3503_connect(struct usb3503 *hub)\n{\n\tstruct device *dev = hub->dev;\n\tint err;\n\n\tif (hub->regmap) {\n\t\t \n\t\terr = regmap_write(hub->regmap, USB3503_SP_ILOCK,\n\t\t\t   (USB3503_SPILOCK_CONNECT\n\t\t\t\t | USB3503_SPILOCK_CONFIG));\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"SP_ILOCK failed (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\tif (hub->port_off_mask) {\n\t\t\terr = regmap_update_bits(hub->regmap, USB3503_PDS,\n\t\t\t\t\thub->port_off_mask,\n\t\t\t\t\thub->port_off_mask);\n\t\t\tif (err < 0) {\n\t\t\t\tdev_err(dev, \"PDS failed (%d)\\n\", err);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\terr = regmap_update_bits(hub->regmap, USB3503_CFG1,\n\t\t\t\t\t USB3503_SELF_BUS_PWR,\n\t\t\t\t\t USB3503_SELF_BUS_PWR);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"CFG1 failed (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\n\t\t \n\t\terr = regmap_update_bits(hub->regmap, USB3503_SP_ILOCK,\n\t\t\t\t\t (USB3503_SPILOCK_CONNECT\n\t\t\t\t\t  | USB3503_SPILOCK_CONFIG), 0);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"SP_ILOCK failed (%d)\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tif (hub->connect)\n\t\tgpiod_set_value_cansleep(hub->connect, 1);\n\n\thub->mode = USB3503_MODE_HUB;\n\tdev_info(dev, \"switched to HUB mode\\n\");\n\n\treturn 0;\n}\n\nstatic int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)\n{\n\tstruct device *dev = hub->dev;\n\tint rst, bypass, conn;\n\n\tswitch (mode) {\n\tcase USB3503_MODE_HUB:\n\t\tconn = 1;\n\t\trst = 0;\n\t\tbypass = 0;\n\t\tbreak;\n\tcase USB3503_MODE_STANDBY:\n\t\tconn = 0;\n\t\trst = 1;\n\t\tbypass = 1;\n\t\tdev_info(dev, \"switched to STANDBY mode\\n\");\n\t\tbreak;\n\tcase USB3503_MODE_BYPASS:\n\t\tconn = 0;\n\t\trst = 0;\n\t\tbypass = 1;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"unknown mode is requested\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!conn && hub->connect)\n\t\tgpiod_set_value_cansleep(hub->connect, 0);\n\n\tif (hub->reset)\n\t\tgpiod_set_value_cansleep(hub->reset, rst);\n\n\tif (hub->bypass)\n\t\tgpiod_set_value_cansleep(hub->bypass, bypass);\n\n\tif (conn) {\n\t\t \n\t\tusleep_range(4000, 10000);\n\t\treturn usb3503_connect(hub);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct regmap_config usb3503_regmap_config = {\n\t.reg_bits = 8,\n\t.val_bits = 8,\n\n\t.max_register = USB3503_RESET,\n};\n\nstatic int usb3503_probe(struct usb3503 *hub)\n{\n\tstruct device *dev = hub->dev;\n\tstruct usb3503_platform_data *pdata = dev_get_platdata(dev);\n\tstruct device_node *np = dev->of_node;\n\tint err;\n\tbool is_clk_enabled = false;\n\tu32 mode = USB3503_MODE_HUB;\n\tconst u32 *property;\n\tenum gpiod_flags flags;\n\tint len;\n\n\tif (pdata) {\n\t\thub->port_off_mask\t= pdata->port_off_mask;\n\t\thub->mode\t\t= pdata->initial_mode;\n\t} else if (np) {\n\t\tu32 rate = 0;\n\t\thub->port_off_mask = 0;\n\n\t\tif (!of_property_read_u32(np, \"refclk-frequency\", &rate)) {\n\t\t\tswitch (rate) {\n\t\t\tcase 38400000:\n\t\t\tcase 26000000:\n\t\t\tcase 19200000:\n\t\t\tcase 12000000:\n\t\t\t\thub->secondary_ref_clk = 0;\n\t\t\t\tbreak;\n\t\t\tcase 24000000:\n\t\t\tcase 27000000:\n\t\t\tcase 25000000:\n\t\t\tcase 50000000:\n\t\t\t\thub->secondary_ref_clk = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"unsupported reference clock rate (%d)\\n\",\n\t\t\t\t\t(int) rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\thub->clk = devm_clk_get_optional(dev, \"refclk\");\n\t\tif (IS_ERR(hub->clk)) {\n\t\t\tdev_err(dev, \"unable to request refclk (%ld)\\n\",\n\t\t\t\t\tPTR_ERR(hub->clk));\n\t\t\treturn PTR_ERR(hub->clk);\n\t\t}\n\n\t\tif (rate != 0) {\n\t\t\terr = clk_set_rate(hub->clk, rate);\n\t\t\tif (err) {\n\t\t\t\tdev_err(dev,\n\t\t\t\t\t\"unable to set reference clock rate to %d\\n\",\n\t\t\t\t\t(int)rate);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t}\n\n\t\terr = clk_prepare_enable(hub->clk);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"unable to enable reference clock\\n\");\n\t\t\treturn err;\n\t\t}\n\n\t\tis_clk_enabled = true;\n\t\tproperty = of_get_property(np, \"disabled-ports\", &len);\n\t\tif (property && (len / sizeof(u32)) > 0) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < len / sizeof(u32); i++) {\n\t\t\t\tu32 port = be32_to_cpu(property[i]);\n\t\t\t\tif ((1 <= port) && (port <= 3))\n\t\t\t\t\thub->port_off_mask |= (1 << port);\n\t\t\t}\n\t\t}\n\n\t\tof_property_read_u32(np, \"initial-mode\", &mode);\n\t\thub->mode = mode;\n\t}\n\n\tif (hub->secondary_ref_clk)\n\t\tflags = GPIOD_OUT_LOW;\n\telse\n\t\tflags = GPIOD_OUT_HIGH;\n\thub->intn = devm_gpiod_get_optional(dev, \"intn\", flags);\n\tif (IS_ERR(hub->intn)) {\n\t\terr = PTR_ERR(hub->intn);\n\t\tgoto err_clk;\n\t}\n\tif (hub->intn)\n\t\tgpiod_set_consumer_name(hub->intn, \"usb3503 intn\");\n\n\thub->connect = devm_gpiod_get_optional(dev, \"connect\", GPIOD_OUT_LOW);\n\tif (IS_ERR(hub->connect)) {\n\t\terr = PTR_ERR(hub->connect);\n\t\tgoto err_clk;\n\t}\n\tif (hub->connect)\n\t\tgpiod_set_consumer_name(hub->connect, \"usb3503 connect\");\n\n\thub->bypass = devm_gpiod_get_optional(dev, \"bypass\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hub->bypass)) {\n\t\terr = PTR_ERR(hub->bypass);\n\t\tgoto err_clk;\n\t}\n\tif (hub->bypass)\n\t\tgpiod_set_consumer_name(hub->bypass, \"usb3503 bypass\");\n\n\thub->reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hub->reset)) {\n\t\terr = PTR_ERR(hub->reset);\n\t\tgoto err_clk;\n\t}\n\tif (hub->reset) {\n\t\t \n\t\tusleep_range(100, 10000);\n\t\tgpiod_set_consumer_name(hub->reset, \"usb3503 reset\");\n\t}\n\n\tif (hub->port_off_mask && !hub->regmap)\n\t\tdev_err(dev, \"Ports disabled with no control interface\\n\");\n\n\tusb3503_switch_mode(hub, hub->mode);\n\n\tdev_info(dev, \"%s: probed in %s mode\\n\", __func__,\n\t\t\t(hub->mode == USB3503_MODE_HUB) ? \"hub\" : \"standby\");\n\n\treturn 0;\n\nerr_clk:\n\tif (is_clk_enabled)\n\t\tclk_disable_unprepare(hub->clk);\n\treturn err;\n}\n\nstatic int usb3503_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct usb3503 *hub;\n\tint err;\n\n\thub = devm_kzalloc(&i2c->dev, sizeof(struct usb3503), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, hub);\n\thub->regmap = devm_regmap_init_i2c(i2c, &usb3503_regmap_config);\n\tif (IS_ERR(hub->regmap)) {\n\t\terr = PTR_ERR(hub->regmap);\n\t\tdev_err(&i2c->dev, \"Failed to initialise regmap: %d\\n\", err);\n\t\treturn err;\n\t}\n\thub->dev = &i2c->dev;\n\n\treturn usb3503_probe(hub);\n}\n\nstatic void usb3503_i2c_remove(struct i2c_client *i2c)\n{\n\tstruct usb3503 *hub;\n\n\thub = i2c_get_clientdata(i2c);\n\tclk_disable_unprepare(hub->clk);\n}\n\nstatic int usb3503_platform_probe(struct platform_device *pdev)\n{\n\tstruct usb3503 *hub;\n\n\thub = devm_kzalloc(&pdev->dev, sizeof(struct usb3503), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\thub->dev = &pdev->dev;\n\tplatform_set_drvdata(pdev, hub);\n\n\treturn usb3503_probe(hub);\n}\n\nstatic void usb3503_platform_remove(struct platform_device *pdev)\n{\n\tstruct usb3503 *hub;\n\n\thub = platform_get_drvdata(pdev);\n\tclk_disable_unprepare(hub->clk);\n}\n\nstatic int __maybe_unused usb3503_suspend(struct usb3503 *hub)\n{\n\tusb3503_switch_mode(hub, USB3503_MODE_STANDBY);\n\tclk_disable_unprepare(hub->clk);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused usb3503_resume(struct usb3503 *hub)\n{\n\tclk_prepare_enable(hub->clk);\n\tusb3503_switch_mode(hub, hub->mode);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused usb3503_i2c_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn usb3503_suspend(i2c_get_clientdata(client));\n}\n\nstatic int __maybe_unused usb3503_i2c_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\n\treturn usb3503_resume(i2c_get_clientdata(client));\n}\n\nstatic int __maybe_unused usb3503_platform_suspend(struct device *dev)\n{\n\treturn usb3503_suspend(dev_get_drvdata(dev));\n}\n\nstatic int __maybe_unused usb3503_platform_resume(struct device *dev)\n{\n\treturn usb3503_resume(dev_get_drvdata(dev));\n}\n\nstatic SIMPLE_DEV_PM_OPS(usb3503_i2c_pm_ops, usb3503_i2c_suspend,\n\t\tusb3503_i2c_resume);\n\nstatic SIMPLE_DEV_PM_OPS(usb3503_platform_pm_ops, usb3503_platform_suspend,\n\t\tusb3503_platform_resume);\n\nstatic const struct i2c_device_id usb3503_id[] = {\n\t{ USB3503_I2C_NAME, 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(i2c, usb3503_id);\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id usb3503_of_match[] = {\n\t{ .compatible = \"smsc,usb3503\", },\n\t{ .compatible = \"smsc,usb3503a\", },\n\t{ .compatible = \"smsc,usb3803\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, usb3503_of_match);\n#endif\n\nstatic struct i2c_driver usb3503_i2c_driver = {\n\t.driver = {\n\t\t.name = USB3503_I2C_NAME,\n\t\t.pm = pm_ptr(&usb3503_i2c_pm_ops),\n\t\t.of_match_table = of_match_ptr(usb3503_of_match),\n\t},\n\t.probe\t\t= usb3503_i2c_probe,\n\t.remove\t\t= usb3503_i2c_remove,\n\t.id_table\t= usb3503_id,\n};\n\nstatic struct platform_driver usb3503_platform_driver = {\n\t.driver = {\n\t\t.name = USB3503_I2C_NAME,\n\t\t.of_match_table = of_match_ptr(usb3503_of_match),\n\t\t.pm = pm_ptr(&usb3503_platform_pm_ops),\n\t},\n\t.probe\t\t= usb3503_platform_probe,\n\t.remove_new\t= usb3503_platform_remove,\n};\n\nstatic int __init usb3503_init(void)\n{\n\tint err;\n\n\terr = i2c_add_driver(&usb3503_i2c_driver);\n\tif (err) {\n\t\tpr_err(\"usb3503: Failed to register I2C driver: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\terr = platform_driver_register(&usb3503_platform_driver);\n\tif (err) {\n\t\tpr_err(\"usb3503: Failed to register platform driver: %d\\n\",\n\t\t       err);\n\t\ti2c_del_driver(&usb3503_i2c_driver);\n\t\treturn err;\n\t}\n\n\treturn 0;\n}\nmodule_init(usb3503_init);\n\nstatic void __exit usb3503_exit(void)\n{\n\tplatform_driver_unregister(&usb3503_platform_driver);\n\ti2c_del_driver(&usb3503_i2c_driver);\n}\nmodule_exit(usb3503_exit);\n\nMODULE_AUTHOR(\"Dongjin Kim <tobetter@gmail.com>\");\nMODULE_DESCRIPTION(\"USB3503 USB HUB driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}