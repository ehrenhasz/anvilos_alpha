{
  "module_name": "adutux.c",
  "hash_id": "ee8c756bd8c5e96fbd2bc1e5a4bb3e80c012f258d0b9de6ff09314be2ed0d885",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/adutux.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\n#define DRIVER_AUTHOR \"John Homppi\"\n#define DRIVER_DESC \"adutux (see www.ontrak.net)\"\n\n \n#define ADU_VENDOR_ID 0x0a07\n#define ADU_PRODUCT_ID 0x0064\n\n \nstatic const struct usb_device_id device_table[] = {\n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID) },\t\t \n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID+20) },\t \n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID+30) },\t \n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID+100) },\t \n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID+108) },\t \n\t{ USB_DEVICE(ADU_VENDOR_ID, ADU_PRODUCT_ID+118) },\t \n\t{ }  \n};\n\nMODULE_DEVICE_TABLE(usb, device_table);\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define ADU_MINOR_BASE\t0\n#else\n#define ADU_MINOR_BASE\t67\n#endif\n\n \n#define MAX_DEVICES\t16\n\n#define COMMAND_TIMEOUT\t(2*HZ)\n\n \n\n \nstruct adu_device {\n\tstruct mutex\t\tmtx;\n\tstruct usb_device *udev;  \n\tstruct usb_interface *interface;\n\tunsigned int\t\tminor;  \n\tchar\t\t\tserial_number[8];\n\n\tint\t\t\topen_count;  \n\tunsigned long\t\tdisconnected:1;\n\n\tchar\t\t*read_buffer_primary;\n\tint\t\t\tread_buffer_length;\n\tchar\t\t*read_buffer_secondary;\n\tint\t\t\tsecondary_head;\n\tint\t\t\tsecondary_tail;\n\tspinlock_t\t\tbuflock;\n\n\twait_queue_head_t\tread_wait;\n\twait_queue_head_t\twrite_wait;\n\n\tchar\t\t*interrupt_in_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_in_endpoint;\n\tstruct urb\t*interrupt_in_urb;\n\tint\t\t\tread_urb_finished;\n\n\tchar\t\t*interrupt_out_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_out_endpoint;\n\tstruct urb\t*interrupt_out_urb;\n\tint\t\t\tout_urb_finished;\n};\n\nstatic DEFINE_MUTEX(adutux_mutex);\n\nstatic struct usb_driver adu_driver;\n\nstatic inline void adu_debug_data(struct device *dev, const char *function,\n\t\t\t\t  int size, const unsigned char *data)\n{\n\tdev_dbg(dev, \"%s - length = %d, data = %*ph\\n\",\n\t\tfunction, size, size, data);\n}\n\n \nstatic void adu_abort_transfers(struct adu_device *dev)\n{\n\tunsigned long flags;\n\n\tif (dev->disconnected)\n\t\treturn;\n\n\t \n\n\t \n\tspin_lock_irqsave(&dev->buflock, flags);\n\tif (!dev->read_urb_finished) {\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\tusb_kill_urb(dev->interrupt_in_urb);\n\t} else\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\n\tspin_lock_irqsave(&dev->buflock, flags);\n\tif (!dev->out_urb_finished) {\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\twait_event_timeout(dev->write_wait, dev->out_urb_finished,\n\t\t\tCOMMAND_TIMEOUT);\n\t\tusb_kill_urb(dev->interrupt_out_urb);\n\t} else\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n}\n\nstatic void adu_delete(struct adu_device *dev)\n{\n\t \n\tusb_free_urb(dev->interrupt_in_urb);\n\tusb_free_urb(dev->interrupt_out_urb);\n\tkfree(dev->read_buffer_primary);\n\tkfree(dev->read_buffer_secondary);\n\tkfree(dev->interrupt_in_buffer);\n\tkfree(dev->interrupt_out_buffer);\n\tusb_put_dev(dev->udev);\n\tkfree(dev);\n}\n\nstatic void adu_interrupt_in_callback(struct urb *urb)\n{\n\tstruct adu_device *dev = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tadu_debug_data(&dev->udev->dev, __func__,\n\t\t       urb->actual_length, urb->transfer_buffer);\n\n\tspin_lock_irqsave(&dev->buflock, flags);\n\n\tif (status != 0) {\n\t\tif ((status != -ENOENT) && (status != -ECONNRESET) &&\n\t\t\t(status != -ESHUTDOWN)) {\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s : nonzero status received: %d\\n\",\n\t\t\t\t__func__, status);\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (urb->actual_length > 0 && dev->interrupt_in_buffer[0] != 0x00) {\n\t\tif (dev->read_buffer_length <\n\t\t    (4 * usb_endpoint_maxp(dev->interrupt_in_endpoint)) -\n\t\t     (urb->actual_length)) {\n\t\t\tmemcpy (dev->read_buffer_primary +\n\t\t\t\tdev->read_buffer_length,\n\t\t\t\tdev->interrupt_in_buffer, urb->actual_length);\n\n\t\t\tdev->read_buffer_length += urb->actual_length;\n\t\t\tdev_dbg(&dev->udev->dev, \"%s reading  %d\\n\", __func__,\n\t\t\t\turb->actual_length);\n\t\t} else {\n\t\t\tdev_dbg(&dev->udev->dev, \"%s : read_buffer overflow\\n\",\n\t\t\t\t__func__);\n\t\t}\n\t}\n\nexit:\n\tdev->read_urb_finished = 1;\n\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t \n\twake_up_interruptible(&dev->read_wait);\n}\n\nstatic void adu_interrupt_out_callback(struct urb *urb)\n{\n\tstruct adu_device *dev = urb->context;\n\tint status = urb->status;\n\tunsigned long flags;\n\n\tadu_debug_data(&dev->udev->dev, __func__,\n\t\t       urb->actual_length, urb->transfer_buffer);\n\n\tif (status != 0) {\n\t\tif ((status != -ENOENT) &&\n\t\t    (status != -ESHUTDOWN) &&\n\t\t    (status != -ECONNRESET)) {\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s :nonzero status received: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t}\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&dev->buflock, flags);\n\tdev->out_urb_finished = 1;\n\twake_up(&dev->write_wait);\n\tspin_unlock_irqrestore(&dev->buflock, flags);\n}\n\nstatic int adu_open(struct inode *inode, struct file *file)\n{\n\tstruct adu_device *dev = NULL;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval;\n\n\tsubminor = iminor(inode);\n\n\tretval = mutex_lock_interruptible(&adutux_mutex);\n\tif (retval)\n\t\tgoto exit_no_lock;\n\n\tinterface = usb_find_interface(&adu_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"%s - error, can't find device for minor %d\\n\",\n\t\t       __func__, subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit_no_device;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit_no_device;\n\t}\n\n\t \n\tif (dev->open_count) {\n\t\tretval = -EBUSY;\n\t\tgoto exit_no_device;\n\t}\n\n\t++dev->open_count;\n\tdev_dbg(&dev->udev->dev, \"%s: open count %d\\n\", __func__,\n\t\tdev->open_count);\n\n\t \n\tfile->private_data = dev;\n\n\t \n\tdev->read_buffer_length = 0;\n\n\t \n\tusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev,\n\t\t\t\t\tdev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_in_buffer,\n\t\t\t usb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t adu_interrupt_in_callback, dev,\n\t\t\t dev->interrupt_in_endpoint->bInterval);\n\tdev->read_urb_finished = 0;\n\tif (usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL))\n\t\tdev->read_urb_finished = 1;\n\t \n\t \n\n\t \n\tdev->out_urb_finished = 1;\n\n\tretval = 0;\n\nexit_no_device:\n\tmutex_unlock(&adutux_mutex);\nexit_no_lock:\n\treturn retval;\n}\n\nstatic void adu_release_internal(struct adu_device *dev)\n{\n\t \n\t--dev->open_count;\n\tdev_dbg(&dev->udev->dev, \"%s : open count %d\\n\", __func__,\n\t\tdev->open_count);\n\tif (dev->open_count <= 0) {\n\t\tadu_abort_transfers(dev);\n\t\tdev->open_count = 0;\n\t}\n}\n\nstatic int adu_release(struct inode *inode, struct file *file)\n{\n\tstruct adu_device *dev;\n\tint retval = 0;\n\n\tif (file == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = file->private_data;\n\tif (dev == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&adutux_mutex);  \n\n\tif (dev->open_count <= 0) {\n\t\tdev_dbg(&dev->udev->dev, \"%s : device not opened\\n\", __func__);\n\t\tretval = -ENODEV;\n\t\tgoto unlock;\n\t}\n\n\tadu_release_internal(dev);\n\tif (dev->disconnected) {\n\t\t \n\t\tif (!dev->open_count)\t \n\t\t\tadu_delete(dev);\n\t}\nunlock:\n\tmutex_unlock(&adutux_mutex);\nexit:\n\treturn retval;\n}\n\nstatic ssize_t adu_read(struct file *file, __user char *buffer, size_t count,\n\t\t\tloff_t *ppos)\n{\n\tstruct adu_device *dev;\n\tsize_t bytes_read = 0;\n\tsize_t bytes_to_read = count;\n\tint retval = 0;\n\tint timeout = 0;\n\tint should_submit = 0;\n\tunsigned long flags;\n\tDECLARE_WAITQUEUE(wait, current);\n\n\tdev = file->private_data;\n\tif (mutex_lock_interruptible(&dev->mtx))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"%s : read request of 0 bytes\\n\",\n\t\t\t__func__);\n\t\tgoto exit;\n\t}\n\n\ttimeout = COMMAND_TIMEOUT;\n\tdev_dbg(&dev->udev->dev, \"%s : about to start looping\\n\", __func__);\n\twhile (bytes_to_read) {\n\t\tsize_t data_in_secondary = dev->secondary_tail - dev->secondary_head;\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"%s : while, data_in_secondary=%zu, status=%d\\n\",\n\t\t\t__func__, data_in_secondary,\n\t\t\tdev->interrupt_in_urb->status);\n\n\t\tif (data_in_secondary) {\n\t\t\t \n\t\t\tsize_t amount = min(bytes_to_read, data_in_secondary);\n\t\t\tif (copy_to_user(buffer, dev->read_buffer_secondary+dev->secondary_head, amount)) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tdev->secondary_head += amount;\n\t\t\tbytes_read += amount;\n\t\t\tbytes_to_read -= amount;\n\t\t} else {\n\t\t\t \n\t\t\tspin_lock_irqsave (&dev->buflock, flags);\n\t\t\tif (dev->read_buffer_length) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\"%s : swap, read_buffer_length = %d\\n\",\n\t\t\t\t\t__func__, dev->read_buffer_length);\n\t\t\t\tswap(dev->read_buffer_primary, dev->read_buffer_secondary);\n\t\t\t\tdev->secondary_head = 0;\n\t\t\t\tdev->secondary_tail = dev->read_buffer_length;\n\t\t\t\tdev->read_buffer_length = 0;\n\t\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\t\t\t \n\t\t\t\tshould_submit = 1;\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tif (!dev->read_urb_finished) {\n\t\t\t\t\t \n\t\t\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\t\"%s : submitted already\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\t\"%s : initiate input\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tdev->read_urb_finished = 0;\n\t\t\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\n\t\t\t\t\tusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\n\t\t\t\t\t\t\tusb_rcvintpipe(dev->udev,\n\t\t\t\t\t\t\t\tdev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t\t\t\t\t dev->interrupt_in_buffer,\n\t\t\t\t\t\t\t usb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t\t\t\t\t adu_interrupt_in_callback,\n\t\t\t\t\t\t\t dev,\n\t\t\t\t\t\t\t dev->interrupt_in_endpoint->bInterval);\n\t\t\t\t\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\n\t\t\t\t\tif (retval) {\n\t\t\t\t\t\tdev->read_urb_finished = 1;\n\t\t\t\t\t\tif (retval == -ENOMEM) {\n\t\t\t\t\t\t\tretval = bytes_read ? bytes_read : -ENOMEM;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\t\t\"%s : submit failed\\n\",\n\t\t\t\t\t\t\t__func__);\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t \n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t\tadd_wait_queue(&dev->read_wait, &wait);\n\t\t\t\tspin_lock_irqsave(&dev->buflock, flags);\n\t\t\t\tif (!dev->read_urb_finished) {\n\t\t\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\t\t\t\ttimeout = schedule_timeout(COMMAND_TIMEOUT);\n\t\t\t\t} else {\n\t\t\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\t}\n\t\t\t\tremove_wait_queue(&dev->read_wait, &wait);\n\n\t\t\t\tif (timeout <= 0) {\n\t\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\t\"%s : timeout\\n\", __func__);\n\t\t\t\t\tretval = bytes_read ? bytes_read : -ETIMEDOUT;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\n\t\t\t\tif (signal_pending(current)) {\n\t\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\t\"%s : signal pending\\n\",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tretval = bytes_read ? bytes_read : -EINTR;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tretval = bytes_read;\n\t \n\tspin_lock_irqsave(&dev->buflock, flags);\n\tif (should_submit && dev->read_urb_finished) {\n\t\tdev->read_urb_finished = 0;\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\tusb_fill_int_urb(dev->interrupt_in_urb, dev->udev,\n\t\t\t\t usb_rcvintpipe(dev->udev,\n\t\t\t\t\tdev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t\tdev->interrupt_in_buffer,\n\t\t\t\tusb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t\tadu_interrupt_in_callback,\n\t\t\t\tdev,\n\t\t\t\tdev->interrupt_in_endpoint->bInterval);\n\t\tif (usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL) != 0)\n\t\t\tdev->read_urb_finished = 1;\n\t\t \n\t} else {\n\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t}\n\nexit:\n\t \n\tmutex_unlock(&dev->mtx);\n\n\treturn retval;\n}\n\nstatic ssize_t adu_write(struct file *file, const __user char *buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tDECLARE_WAITQUEUE(waita, current);\n\tstruct adu_device *dev;\n\tsize_t bytes_written = 0;\n\tsize_t bytes_to_write;\n\tsize_t buffer_size;\n\tunsigned long flags;\n\tint retval;\n\n\tdev = file->private_data;\n\n\tretval = mutex_lock_interruptible(&dev->mtx);\n\tif (retval)\n\t\tgoto exit_nolock;\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tpr_err(\"No device or device unplugged %d\\n\", retval);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"%s : write request of 0 bytes\\n\",\n\t\t\t__func__);\n\t\tgoto exit;\n\t}\n\n\twhile (count > 0) {\n\t\tadd_wait_queue(&dev->write_wait, &waita);\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tspin_lock_irqsave(&dev->buflock, flags);\n\t\tif (!dev->out_urb_finished) {\n\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tdev_dbg(&dev->udev->dev, \"%s : interrupted\\n\",\n\t\t\t\t\t__func__);\n\t\t\t\tset_current_state(TASK_RUNNING);\n\t\t\t\tretval = -EINTR;\n\t\t\t\tgoto exit_onqueue;\n\t\t\t}\n\t\t\tif (schedule_timeout(COMMAND_TIMEOUT) == 0) {\n\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\"%s - command timed out.\\n\", __func__);\n\t\t\t\tretval = -ETIMEDOUT;\n\t\t\t\tgoto exit_onqueue;\n\t\t\t}\n\t\t\tremove_wait_queue(&dev->write_wait, &waita);\n\t\t\tretval = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (retval) {\n\t\t\t\tretval = bytes_written ? bytes_written : retval;\n\t\t\t\tgoto exit_nolock;\n\t\t\t}\n\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s : in progress, count = %zd\\n\",\n\t\t\t\t__func__, count);\n\t\t} else {\n\t\t\tspin_unlock_irqrestore(&dev->buflock, flags);\n\t\t\tset_current_state(TASK_RUNNING);\n\t\t\tremove_wait_queue(&dev->write_wait, &waita);\n\t\t\tdev_dbg(&dev->udev->dev, \"%s : sending, count = %zd\\n\",\n\t\t\t\t__func__, count);\n\n\t\t\t \n\t\t\tbuffer_size = usb_endpoint_maxp(dev->interrupt_out_endpoint);\n\t\t\tbytes_to_write = count > buffer_size ? buffer_size : count;\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s : buffer_size = %zd, count = %zd, bytes_to_write = %zd\\n\",\n\t\t\t\t__func__, buffer_size, count, bytes_to_write);\n\n\t\t\tif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write) != 0) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\t \n\t\t\tusb_fill_int_urb(\n\t\t\t\tdev->interrupt_out_urb,\n\t\t\t\tdev->udev,\n\t\t\t\tusb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\n\t\t\t\tdev->interrupt_out_buffer,\n\t\t\t\tbytes_to_write,\n\t\t\t\tadu_interrupt_out_callback,\n\t\t\t\tdev,\n\t\t\t\tdev->interrupt_out_endpoint->bInterval);\n\t\t\tdev->interrupt_out_urb->actual_length = bytes_to_write;\n\t\t\tdev->out_urb_finished = 0;\n\t\t\tretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev->out_urb_finished = 1;\n\t\t\t\tdev_err(&dev->udev->dev, \"Couldn't submit \"\n\t\t\t\t\t\"interrupt_out_urb %d\\n\", retval);\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tbuffer += bytes_to_write;\n\t\t\tcount -= bytes_to_write;\n\n\t\t\tbytes_written += bytes_to_write;\n\t\t}\n\t}\n\tmutex_unlock(&dev->mtx);\n\treturn bytes_written;\n\nexit:\n\tmutex_unlock(&dev->mtx);\nexit_nolock:\n\treturn retval;\n\nexit_onqueue:\n\tremove_wait_queue(&dev->write_wait, &waita);\n\treturn retval;\n}\n\n \nstatic const struct file_operations adu_fops = {\n\t.owner = THIS_MODULE,\n\t.read  = adu_read,\n\t.write = adu_write,\n\t.open = adu_open,\n\t.release = adu_release,\n\t.llseek = noop_llseek,\n};\n\n \nstatic struct usb_class_driver adu_class = {\n\t.name = \"usb/adutux%d\",\n\t.fops = &adu_fops,\n\t.minor_base = ADU_MINOR_BASE,\n};\n\n \nstatic int adu_probe(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct adu_device *dev = NULL;\n\tint retval = -ENOMEM;\n\tint in_end_size;\n\tint out_end_size;\n\tint res;\n\n\t \n\tdev = kzalloc(sizeof(struct adu_device), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->mtx);\n\tspin_lock_init(&dev->buflock);\n\tdev->udev = usb_get_dev(udev);\n\tinit_waitqueue_head(&dev->read_wait);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\tres = usb_find_common_endpoints_reverse(interface->cur_altsetting,\n\t\t\tNULL, NULL,\n\t\t\t&dev->interrupt_in_endpoint,\n\t\t\t&dev->interrupt_out_endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, \"interrupt endpoints not found\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tin_end_size = usb_endpoint_maxp(dev->interrupt_in_endpoint);\n\tout_end_size = usb_endpoint_maxp(dev->interrupt_out_endpoint);\n\n\tdev->read_buffer_primary = kmalloc((4 * in_end_size), GFP_KERNEL);\n\tif (!dev->read_buffer_primary)\n\t\tgoto error;\n\n\t \n\tmemset(dev->read_buffer_primary, 'a', in_end_size);\n\tmemset(dev->read_buffer_primary + in_end_size, 'b', in_end_size);\n\tmemset(dev->read_buffer_primary + (2 * in_end_size), 'c', in_end_size);\n\tmemset(dev->read_buffer_primary + (3 * in_end_size), 'd', in_end_size);\n\n\tdev->read_buffer_secondary = kmalloc((4 * in_end_size), GFP_KERNEL);\n\tif (!dev->read_buffer_secondary)\n\t\tgoto error;\n\n\t \n\tmemset(dev->read_buffer_secondary, 'e', in_end_size);\n\tmemset(dev->read_buffer_secondary + in_end_size, 'f', in_end_size);\n\tmemset(dev->read_buffer_secondary + (2 * in_end_size), 'g', in_end_size);\n\tmemset(dev->read_buffer_secondary + (3 * in_end_size), 'h', in_end_size);\n\n\tdev->interrupt_in_buffer = kmalloc(in_end_size, GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\n\t \n\tmemset(dev->interrupt_in_buffer, 'i', in_end_size);\n\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc(out_end_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\n\tif (!usb_string(udev, udev->descriptor.iSerialNumber, dev->serial_number,\n\t\t\tsizeof(dev->serial_number))) {\n\t\tdev_err(&interface->dev, \"Could not retrieve serial number\\n\");\n\t\tretval = -EIO;\n\t\tgoto error;\n\t}\n\tdev_dbg(&interface->dev, \"serial_number=%s\", dev->serial_number);\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\tretval = usb_register_dev(interface, &adu_class);\n\n\tif (retval) {\n\t\t \n\t\tdev_err(&interface->dev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev->minor = interface->minor;\n\n\t \n\tdev_info(&interface->dev, \"ADU%d %s now attached to /dev/usb/adutux%d\\n\",\n\t\t le16_to_cpu(udev->descriptor.idProduct), dev->serial_number,\n\t\t (dev->minor - ADU_MINOR_BASE));\n\n\treturn 0;\n\nerror:\n\tadu_delete(dev);\n\treturn retval;\n}\n\n \nstatic void adu_disconnect(struct usb_interface *interface)\n{\n\tstruct adu_device *dev;\n\n\tdev = usb_get_intfdata(interface);\n\n\tusb_deregister_dev(interface, &adu_class);\n\n\tusb_poison_urb(dev->interrupt_in_urb);\n\tusb_poison_urb(dev->interrupt_out_urb);\n\n\tmutex_lock(&adutux_mutex);\n\tusb_set_intfdata(interface, NULL);\n\n\tmutex_lock(&dev->mtx);\t \n\tdev->disconnected = 1;\n\tmutex_unlock(&dev->mtx);\n\n\t \n\tif (!dev->open_count)\n\t\tadu_delete(dev);\n\n\tmutex_unlock(&adutux_mutex);\n}\n\n \nstatic struct usb_driver adu_driver = {\n\t.name = \"adutux\",\n\t.probe = adu_probe,\n\t.disconnect = adu_disconnect,\n\t.id_table = device_table,\n};\n\nmodule_usb_driver(adu_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}