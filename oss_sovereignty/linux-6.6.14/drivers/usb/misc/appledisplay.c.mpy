{
  "module_name": "appledisplay.c",
  "hash_id": "22b3a46d4c426557065fe9c8c64f4d4df970098e1cb71078776f919b97363334",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/appledisplay.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/backlight.h>\n#include <linux/timer.h>\n#include <linux/workqueue.h>\n#include <linux/atomic.h>\n\n#define APPLE_VENDOR_ID\t\t0x05AC\n\n#define USB_REQ_GET_REPORT\t0x01\n#define USB_REQ_SET_REPORT\t0x09\n\n#define ACD_USB_TIMEOUT\t\t250\n\n#define ACD_USB_EDID\t\t0x0302\n#define ACD_USB_BRIGHTNESS\t0x0310\n\n#define ACD_BTN_NONE\t\t0\n#define ACD_BTN_BRIGHT_UP\t3\n#define ACD_BTN_BRIGHT_DOWN\t4\n\n#define ACD_URB_BUFFER_LEN\t2\n#define ACD_MSG_BUFFER_LEN\t2\n\n#define APPLEDISPLAY_DEVICE(prod)\t\t\t\t\\\n\t.match_flags = USB_DEVICE_ID_MATCH_DEVICE |\t\t\\\n\t\t       USB_DEVICE_ID_MATCH_INT_CLASS |\t\t\\\n\t\t       USB_DEVICE_ID_MATCH_INT_PROTOCOL,\t\\\n\t.idVendor = APPLE_VENDOR_ID,\t\t\t\t\\\n\t.idProduct = (prod),\t\t\t\t\t\\\n\t.bInterfaceClass = USB_CLASS_HID,\t\t\t\\\n\t.bInterfaceProtocol = 0x00\n\n \nstatic const struct usb_device_id appledisplay_table[] = {\n\t{ APPLEDISPLAY_DEVICE(0x9218) },\n\t{ APPLEDISPLAY_DEVICE(0x9219) },\n\t{ APPLEDISPLAY_DEVICE(0x921c) },\n\t{ APPLEDISPLAY_DEVICE(0x921d) },\n\t{ APPLEDISPLAY_DEVICE(0x9222) },\n\t{ APPLEDISPLAY_DEVICE(0x9226) },\n\t{ APPLEDISPLAY_DEVICE(0x9236) },\n\n\t \n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, appledisplay_table);\n\n \nstruct appledisplay {\n\tstruct usb_device *udev;\t \n\tstruct urb *urb;\t\t \n\tstruct backlight_device *bd;\t \n\tu8 *urbdata;\t\t\t \n\tu8 *msgdata;\t\t\t \n\n\tstruct delayed_work work;\n\tint button_pressed;\n\tstruct mutex sysfslock;\t\t \n};\n\nstatic atomic_t count_displays = ATOMIC_INIT(0);\n\nstatic void appledisplay_complete(struct urb *urb)\n{\n\tstruct appledisplay *pdata = urb->context;\n\tstruct device *dev = &pdata->udev->dev;\n\tint status = urb->status;\n\tint retval;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -EOVERFLOW:\n\t\tdev_err(dev,\n\t\t\t\"OVERFLOW with data length %d, actual length is %d\\n\",\n\t\t\tACD_URB_BUFFER_LEN, pdata->urb->actual_length);\n\t\tfallthrough;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\t \n\t\tdev_dbg(dev, \"%s - urb shuttingdown with status: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\tdefault:\n\t\tdev_dbg(dev, \"%s - nonzero urb status received: %d\\n\",\n\t\t\t__func__, status);\n\t\tgoto exit;\n\t}\n\n\tswitch(pdata->urbdata[1]) {\n\tcase ACD_BTN_BRIGHT_UP:\n\tcase ACD_BTN_BRIGHT_DOWN:\n\t\tpdata->button_pressed = 1;\n\t\tschedule_delayed_work(&pdata->work, 0);\n\t\tbreak;\n\tcase ACD_BTN_NONE:\n\tdefault:\n\t\tpdata->button_pressed = 0;\n\t\tbreak;\n\t}\n\nexit:\n\tretval = usb_submit_urb(pdata->urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(dev, \"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\nstatic int appledisplay_bl_update_status(struct backlight_device *bd)\n{\n\tstruct appledisplay *pdata = bl_get_data(bd);\n\tint retval;\n\n\tmutex_lock(&pdata->sysfslock);\n\tpdata->msgdata[0] = 0x10;\n\tpdata->msgdata[1] = bd->props.brightness;\n\n\tretval = usb_control_msg(\n\t\tpdata->udev,\n\t\tusb_sndctrlpipe(pdata->udev, 0),\n\t\tUSB_REQ_SET_REPORT,\n\t\tUSB_DIR_OUT | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\tACD_USB_BRIGHTNESS,\n\t\t0,\n\t\tpdata->msgdata, 2,\n\t\tACD_USB_TIMEOUT);\n\tmutex_unlock(&pdata->sysfslock);\n\n\tif (retval < 0)\n\t\treturn retval;\n\telse\n\t\treturn 0;\n}\n\nstatic int appledisplay_bl_get_brightness(struct backlight_device *bd)\n{\n\tstruct appledisplay *pdata = bl_get_data(bd);\n\tint retval, brightness;\n\n\tmutex_lock(&pdata->sysfslock);\n\tretval = usb_control_msg(\n\t\tpdata->udev,\n\t\tusb_rcvctrlpipe(pdata->udev, 0),\n\t\tUSB_REQ_GET_REPORT,\n\t\tUSB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\tACD_USB_BRIGHTNESS,\n\t\t0,\n\t\tpdata->msgdata, 2,\n\t\tACD_USB_TIMEOUT);\n\tif (retval < 2) {\n\t\tif (retval >= 0)\n\t\t\tretval = -EMSGSIZE;\n\t} else {\n\t\tbrightness = pdata->msgdata[1];\n\t}\n\tmutex_unlock(&pdata->sysfslock);\n\n\tif (retval < 0)\n\t\treturn retval;\n\telse\n\t\treturn brightness;\n}\n\nstatic const struct backlight_ops appledisplay_bl_data = {\n\t.get_brightness\t= appledisplay_bl_get_brightness,\n\t.update_status\t= appledisplay_bl_update_status,\n};\n\nstatic void appledisplay_work(struct work_struct *work)\n{\n\tstruct appledisplay *pdata =\n\t\tcontainer_of(work, struct appledisplay, work.work);\n\tint retval;\n\n\tretval = appledisplay_bl_get_brightness(pdata->bd);\n\tif (retval >= 0)\n\t\tpdata->bd->props.brightness = retval;\n\n\t \n\tif (pdata->button_pressed)\n\t\tschedule_delayed_work(&pdata->work, HZ / 8);\n}\n\nstatic int appledisplay_probe(struct usb_interface *iface,\n\tconst struct usb_device_id *id)\n{\n\tstruct backlight_properties props;\n\tstruct appledisplay *pdata;\n\tstruct usb_device *udev = interface_to_usbdev(iface);\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint int_in_endpointAddr = 0;\n\tint retval, brightness;\n\tchar bl_name[20];\n\n\t \n\t \n\tretval = usb_find_int_in_endpoint(iface->cur_altsetting, &endpoint);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"Could not find int-in endpoint\\n\");\n\t\treturn retval;\n\t}\n\n\tint_in_endpointAddr = endpoint->bEndpointAddress;\n\n\t \n\tpdata = kzalloc(sizeof(struct appledisplay), GFP_KERNEL);\n\tif (!pdata) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpdata->udev = udev;\n\n\tINIT_DELAYED_WORK(&pdata->work, appledisplay_work);\n\tmutex_init(&pdata->sysfslock);\n\n\t \n\tpdata->msgdata = kmalloc(ACD_MSG_BUFFER_LEN, GFP_KERNEL);\n\tif (!pdata->msgdata) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tpdata->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!pdata->urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\t \n\tpdata->urbdata = usb_alloc_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\n\t\tGFP_KERNEL, &pdata->urb->transfer_dma);\n\tif (!pdata->urbdata) {\n\t\tretval = -ENOMEM;\n\t\tdev_err(&iface->dev, \"Allocating URB buffer failed\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tusb_fill_int_urb(pdata->urb, udev,\n\t\tusb_rcvintpipe(udev, int_in_endpointAddr),\n\t\tpdata->urbdata, ACD_URB_BUFFER_LEN, appledisplay_complete,\n\t\tpdata, 1);\n\tpdata->urb->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\tif (usb_submit_urb(pdata->urb, GFP_KERNEL)) {\n\t\tretval = -EIO;\n\t\tdev_err(&iface->dev, \"Submitting URB failed\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tsnprintf(bl_name, sizeof(bl_name), \"appledisplay%d\",\n\t\tatomic_inc_return(&count_displays) - 1);\n\tmemset(&props, 0, sizeof(struct backlight_properties));\n\tprops.type = BACKLIGHT_RAW;\n\tprops.max_brightness = 0xff;\n\tpdata->bd = backlight_device_register(bl_name, NULL, pdata,\n\t\t\t\t\t      &appledisplay_bl_data, &props);\n\tif (IS_ERR(pdata->bd)) {\n\t\tdev_err(&iface->dev, \"Backlight registration failed\\n\");\n\t\tretval = PTR_ERR(pdata->bd);\n\t\tgoto error;\n\t}\n\n\t \n\tbrightness = appledisplay_bl_get_brightness(pdata->bd);\n\n\tif (brightness < 0) {\n\t\tretval = brightness;\n\t\tdev_err(&iface->dev,\n\t\t\t\"Error while getting initial brightness: %d\\n\", retval);\n\t\tgoto error;\n\t}\n\n\t \n\tpdata->bd->props.brightness = brightness;\n\n\t \n\tusb_set_intfdata(iface, pdata);\n\n\tprintk(KERN_INFO \"appledisplay: Apple Cinema Display connected\\n\");\n\n\treturn 0;\n\nerror:\n\tif (pdata) {\n\t\tif (pdata->urb) {\n\t\t\tusb_kill_urb(pdata->urb);\n\t\t\tcancel_delayed_work_sync(&pdata->work);\n\t\t\tusb_free_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\n\t\t\t\t\tpdata->urbdata, pdata->urb->transfer_dma);\n\t\t\tusb_free_urb(pdata->urb);\n\t\t}\n\t\tif (!IS_ERR(pdata->bd))\n\t\t\tbacklight_device_unregister(pdata->bd);\n\t\tkfree(pdata->msgdata);\n\t}\n\tusb_set_intfdata(iface, NULL);\n\tkfree(pdata);\n\treturn retval;\n}\n\nstatic void appledisplay_disconnect(struct usb_interface *iface)\n{\n\tstruct appledisplay *pdata = usb_get_intfdata(iface);\n\n\tif (pdata) {\n\t\tusb_kill_urb(pdata->urb);\n\t\tcancel_delayed_work_sync(&pdata->work);\n\t\tbacklight_device_unregister(pdata->bd);\n\t\tusb_free_coherent(pdata->udev, ACD_URB_BUFFER_LEN,\n\t\t\tpdata->urbdata, pdata->urb->transfer_dma);\n\t\tusb_free_urb(pdata->urb);\n\t\tkfree(pdata->msgdata);\n\t\tkfree(pdata);\n\t}\n\n\tprintk(KERN_INFO \"appledisplay: Apple Cinema Display disconnected\\n\");\n}\n\nstatic struct usb_driver appledisplay_driver = {\n\t.name\t\t= \"appledisplay\",\n\t.probe\t\t= appledisplay_probe,\n\t.disconnect\t= appledisplay_disconnect,\n\t.id_table\t= appledisplay_table,\n};\nmodule_usb_driver(appledisplay_driver);\n\nMODULE_AUTHOR(\"Michael Hanselmann\");\nMODULE_DESCRIPTION(\"Apple Cinema Display driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}