{
  "module_name": "usb251xb.c",
  "hash_id": "057869cbf41a91abd53c0e50638ab02a69ad66f2bd4dba5d7f3d09d7a2f8b852",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/usb251xb.c",
  "human_readable_source": "\n \n\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/gpio/driver.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/nls.h>\n#include <linux/of.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n\n \n#define USB251XB_ADDR_VENDOR_ID_LSB\t0x00\n#define USB251XB_ADDR_VENDOR_ID_MSB\t0x01\n#define USB251XB_DEF_VENDOR_ID\t\t0x0424\n\n#define USB251XB_ADDR_PRODUCT_ID_LSB\t0x02\n#define USB251XB_ADDR_PRODUCT_ID_MSB\t0x03\n\n#define USB251XB_ADDR_DEVICE_ID_LSB\t0x04\n#define USB251XB_ADDR_DEVICE_ID_MSB\t0x05\n#define USB251XB_DEF_DEVICE_ID\t\t0x0BB3\n\n#define USB251XB_ADDR_CONFIG_DATA_1\t0x06\n#define USB251XB_DEF_CONFIG_DATA_1\t0x9B\n#define USB251XB_ADDR_CONFIG_DATA_2\t0x07\n#define USB251XB_DEF_CONFIG_DATA_2\t0x20\n#define USB251XB_ADDR_CONFIG_DATA_3\t0x08\n#define USB251XB_DEF_CONFIG_DATA_3\t0x02\n\n#define USB251XB_ADDR_NON_REMOVABLE_DEVICES\t0x09\n#define USB251XB_DEF_NON_REMOVABLE_DEVICES\t0x00\n\n#define USB251XB_ADDR_PORT_DISABLE_SELF\t0x0A\n#define USB251XB_DEF_PORT_DISABLE_SELF\t0x00\n#define USB251XB_ADDR_PORT_DISABLE_BUS\t0x0B\n#define USB251XB_DEF_PORT_DISABLE_BUS\t0x00\n\n#define USB251XB_ADDR_MAX_POWER_SELF\t0x0C\n#define USB251XB_DEF_MAX_POWER_SELF\t0x01\n#define USB251XB_ADDR_MAX_POWER_BUS\t0x0D\n#define USB251XB_DEF_MAX_POWER_BUS\t0x32\n\n#define USB251XB_ADDR_MAX_CURRENT_SELF\t0x0E\n#define USB251XB_DEF_MAX_CURRENT_SELF\t0x01\n#define USB251XB_ADDR_MAX_CURRENT_BUS\t0x0F\n#define USB251XB_DEF_MAX_CURRENT_BUS\t0x32\n\n#define USB251XB_ADDR_POWER_ON_TIME\t0x10\n#define USB251XB_DEF_POWER_ON_TIME\t0x32\n\n#define USB251XB_ADDR_LANGUAGE_ID_HIGH\t0x11\n#define USB251XB_ADDR_LANGUAGE_ID_LOW\t0x12\n#define USB251XB_DEF_LANGUAGE_ID\t0x0000\n\n#define USB251XB_STRING_BUFSIZE\t\t\t62\n#define USB251XB_ADDR_MANUFACTURER_STRING_LEN\t0x13\n#define USB251XB_ADDR_MANUFACTURER_STRING\t0x16\n#define USB251XB_DEF_MANUFACTURER_STRING\t\"Microchip\"\n\n#define USB251XB_ADDR_PRODUCT_STRING_LEN\t0x14\n#define USB251XB_ADDR_PRODUCT_STRING\t\t0x54\n\n#define USB251XB_ADDR_SERIAL_STRING_LEN\t\t0x15\n#define USB251XB_ADDR_SERIAL_STRING\t\t0x92\n#define USB251XB_DEF_SERIAL_STRING\t\t\"\"\n\n#define USB251XB_ADDR_BATTERY_CHARGING_ENABLE\t0xD0\n#define USB251XB_DEF_BATTERY_CHARGING_ENABLE\t0x00\n\n#define USB251XB_ADDR_BOOST_UP\t0xF6\n#define USB251XB_DEF_BOOST_UP\t0x00\n#define USB251XB_ADDR_BOOST_57\t0xF7\n#define USB251XB_DEF_BOOST_57\t0x00\n#define USB251XB_ADDR_BOOST_14\t0xF8\n#define USB251XB_DEF_BOOST_14\t0x00\n\n#define USB251XB_ADDR_PORT_SWAP\t0xFA\n#define USB251XB_DEF_PORT_SWAP\t0x00\n\n#define USB251XB_ADDR_PORT_MAP_12\t0xFB\n#define USB251XB_DEF_PORT_MAP_12\t0x00\n#define USB251XB_ADDR_PORT_MAP_34\t0xFC\n#define USB251XB_DEF_PORT_MAP_34\t0x00  \n#define USB251XB_ADDR_PORT_MAP_56\t0xFD\n#define USB251XB_DEF_PORT_MAP_56\t0x00  \n#define USB251XB_ADDR_PORT_MAP_7\t0xFE\n#define USB251XB_DEF_PORT_MAP_7\t\t0x00  \n\n#define USB251XB_ADDR_STATUS_COMMAND\t\t0xFF\n#define USB251XB_STATUS_COMMAND_SMBUS_DOWN\t0x04\n#define USB251XB_STATUS_COMMAND_RESET\t\t0x02\n#define USB251XB_STATUS_COMMAND_ATTACH\t\t0x01\n\n#define USB251XB_I2C_REG_SZ\t0x100\n#define USB251XB_I2C_WRITE_SZ\t0x10\n\n#define DRIVER_NAME\t\"usb251xb\"\n#define DRIVER_DESC\t\"Microchip USB 2.0 Hi-Speed Hub Controller\"\n\nstruct usb251xb {\n\tstruct device *dev;\n\tstruct i2c_client *i2c;\n\tstruct regulator *vdd;\n\tu8 skip_config;\n\tstruct gpio_desc *gpio_reset;\n\tu16 vendor_id;\n\tu16 product_id;\n\tu16 device_id;\n\tu8  conf_data1;\n\tu8  conf_data2;\n\tu8  conf_data3;\n\tu8  non_rem_dev;\n\tu8  port_disable_sp;\n\tu8  port_disable_bp;\n\tu8  max_power_sp;\n\tu8  max_power_bp;\n\tu8  max_current_sp;\n\tu8  max_current_bp;\n\tu8  power_on_time;\n\tu16 lang_id;\n\tu8 manufacturer_len;\n\tu8 product_len;\n\tu8 serial_len;\n\tchar manufacturer[USB251XB_STRING_BUFSIZE];\n\tchar product[USB251XB_STRING_BUFSIZE];\n\tchar serial[USB251XB_STRING_BUFSIZE];\n\tu8  bat_charge_en;\n\tu8  boost_up;\n\tu8  boost_57;\n\tu8  boost_14;\n\tu8  port_swap;\n\tu8  port_map12;\n\tu8  port_map34;\n\tu8  port_map56;\n\tu8  port_map7;\n\tu8  status;\n};\n\nstruct usb251xb_data {\n\tu16 product_id;\n\tu8 port_cnt;\n\tbool led_support;\n\tbool bat_support;\n\tchar product_str[USB251XB_STRING_BUFSIZE / 2];  \n};\n\nstatic const struct usb251xb_data usb2422_data = {\n\t.product_id = 0x2422,\n\t.port_cnt = 2,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2422\",\n};\n\nstatic const struct usb251xb_data usb2512b_data = {\n\t.product_id = 0x2512,\n\t.port_cnt = 2,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2512B\",\n};\n\nstatic const struct usb251xb_data usb2512bi_data = {\n\t.product_id = 0x2512,\n\t.port_cnt = 2,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2512Bi\",\n};\n\nstatic const struct usb251xb_data usb2513b_data = {\n\t.product_id = 0x2513,\n\t.port_cnt = 3,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2513B\",\n};\n\nstatic const struct usb251xb_data usb2513bi_data = {\n\t.product_id = 0x2513,\n\t.port_cnt = 3,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2513Bi\",\n};\n\nstatic const struct usb251xb_data usb2514b_data = {\n\t.product_id = 0x2514,\n\t.port_cnt = 4,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2514B\",\n};\n\nstatic const struct usb251xb_data usb2514bi_data = {\n\t.product_id = 0x2514,\n\t.port_cnt = 4,\n\t.led_support = false,\n\t.bat_support = true,\n\t.product_str = \"USB2514Bi\",\n};\n\nstatic const struct usb251xb_data usb2517_data = {\n\t.product_id = 0x2517,\n\t.port_cnt = 7,\n\t.led_support = true,\n\t.bat_support = false,\n\t.product_str = \"USB2517\",\n};\n\nstatic const struct usb251xb_data usb2517i_data = {\n\t.product_id = 0x2517,\n\t.port_cnt = 7,\n\t.led_support = true,\n\t.bat_support = false,\n\t.product_str = \"USB2517i\",\n};\n\n#ifdef CONFIG_GPIOLIB\nstatic int usb251xb_check_dev_children(struct device *dev, void *child)\n{\n\tif (dev->type == &i2c_adapter_type) {\n\t\treturn device_for_each_child(dev, child,\n\t\t\t\t\t     usb251xb_check_dev_children);\n\t}\n\n\treturn (dev == child);\n}\n\nstatic int usb251x_check_gpio_chip(struct usb251xb *hub)\n{\n\tstruct gpio_chip *gc = gpiod_to_chip(hub->gpio_reset);\n\tstruct i2c_adapter *adap = hub->i2c->adapter;\n\tint ret;\n\n\tif (!hub->gpio_reset)\n\t\treturn 0;\n\n\tif (!gc)\n\t\treturn -EINVAL;\n\n\tret = usb251xb_check_dev_children(&adap->dev, gc->parent);\n\tif (ret) {\n\t\tdev_err(hub->dev, \"Reset GPIO chip is at the same i2c-bus\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int usb251x_check_gpio_chip(struct usb251xb *hub)\n{\n\treturn 0;\n}\n#endif\n\nstatic void usb251xb_reset(struct usb251xb *hub)\n{\n\tif (!hub->gpio_reset)\n\t\treturn;\n\n\ti2c_lock_bus(hub->i2c->adapter, I2C_LOCK_SEGMENT);\n\n\tgpiod_set_value_cansleep(hub->gpio_reset, 1);\n\tusleep_range(1, 10);\t \n\tgpiod_set_value_cansleep(hub->gpio_reset, 0);\n\n\t \n\tusleep_range(500, 750);\t \n\n\ti2c_unlock_bus(hub->i2c->adapter, I2C_LOCK_SEGMENT);\n}\n\nstatic int usb251xb_connect(struct usb251xb *hub)\n{\n\tstruct device *dev = hub->dev;\n\tint err, i;\n\tchar i2c_wb[USB251XB_I2C_REG_SZ];\n\n\tmemset(i2c_wb, 0, USB251XB_I2C_REG_SZ);\n\n\tif (hub->skip_config) {\n\t\tdev_info(dev, \"Skip hub configuration, only attach.\\n\");\n\t\ti2c_wb[0] = 0x01;\n\t\ti2c_wb[1] = USB251XB_STATUS_COMMAND_ATTACH;\n\n\t\tusb251xb_reset(hub);\n\n\t\terr = i2c_smbus_write_i2c_block_data(hub->i2c,\n\t\t\t\tUSB251XB_ADDR_STATUS_COMMAND, 2, i2c_wb);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"attaching hub failed: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t\treturn 0;\n\t}\n\n\ti2c_wb[USB251XB_ADDR_VENDOR_ID_MSB]     = (hub->vendor_id >> 8) & 0xFF;\n\ti2c_wb[USB251XB_ADDR_VENDOR_ID_LSB]     = hub->vendor_id & 0xFF;\n\ti2c_wb[USB251XB_ADDR_PRODUCT_ID_MSB]    = (hub->product_id >> 8) & 0xFF;\n\ti2c_wb[USB251XB_ADDR_PRODUCT_ID_LSB]    = hub->product_id & 0xFF;\n\ti2c_wb[USB251XB_ADDR_DEVICE_ID_MSB]     = (hub->device_id >> 8) & 0xFF;\n\ti2c_wb[USB251XB_ADDR_DEVICE_ID_LSB]     = hub->device_id & 0xFF;\n\ti2c_wb[USB251XB_ADDR_CONFIG_DATA_1]     = hub->conf_data1;\n\ti2c_wb[USB251XB_ADDR_CONFIG_DATA_2]     = hub->conf_data2;\n\ti2c_wb[USB251XB_ADDR_CONFIG_DATA_3]     = hub->conf_data3;\n\ti2c_wb[USB251XB_ADDR_NON_REMOVABLE_DEVICES] = hub->non_rem_dev;\n\ti2c_wb[USB251XB_ADDR_PORT_DISABLE_SELF] = hub->port_disable_sp;\n\ti2c_wb[USB251XB_ADDR_PORT_DISABLE_BUS]  = hub->port_disable_bp;\n\ti2c_wb[USB251XB_ADDR_MAX_POWER_SELF]    = hub->max_power_sp;\n\ti2c_wb[USB251XB_ADDR_MAX_POWER_BUS]     = hub->max_power_bp;\n\ti2c_wb[USB251XB_ADDR_MAX_CURRENT_SELF]  = hub->max_current_sp;\n\ti2c_wb[USB251XB_ADDR_MAX_CURRENT_BUS]   = hub->max_current_bp;\n\ti2c_wb[USB251XB_ADDR_POWER_ON_TIME]     = hub->power_on_time;\n\ti2c_wb[USB251XB_ADDR_LANGUAGE_ID_HIGH]  = (hub->lang_id >> 8) & 0xFF;\n\ti2c_wb[USB251XB_ADDR_LANGUAGE_ID_LOW]   = hub->lang_id & 0xFF;\n\ti2c_wb[USB251XB_ADDR_MANUFACTURER_STRING_LEN] = hub->manufacturer_len;\n\ti2c_wb[USB251XB_ADDR_PRODUCT_STRING_LEN]      = hub->product_len;\n\ti2c_wb[USB251XB_ADDR_SERIAL_STRING_LEN]       = hub->serial_len;\n\tmemcpy(&i2c_wb[USB251XB_ADDR_MANUFACTURER_STRING], hub->manufacturer,\n\t       USB251XB_STRING_BUFSIZE);\n\tmemcpy(&i2c_wb[USB251XB_ADDR_SERIAL_STRING], hub->serial,\n\t       USB251XB_STRING_BUFSIZE);\n\tmemcpy(&i2c_wb[USB251XB_ADDR_PRODUCT_STRING], hub->product,\n\t       USB251XB_STRING_BUFSIZE);\n\ti2c_wb[USB251XB_ADDR_BATTERY_CHARGING_ENABLE] = hub->bat_charge_en;\n\ti2c_wb[USB251XB_ADDR_BOOST_UP]          = hub->boost_up;\n\ti2c_wb[USB251XB_ADDR_BOOST_57]          = hub->boost_57;\n\ti2c_wb[USB251XB_ADDR_BOOST_14]          = hub->boost_14;\n\ti2c_wb[USB251XB_ADDR_PORT_SWAP]         = hub->port_swap;\n\ti2c_wb[USB251XB_ADDR_PORT_MAP_12]       = hub->port_map12;\n\ti2c_wb[USB251XB_ADDR_PORT_MAP_34]       = hub->port_map34;\n\ti2c_wb[USB251XB_ADDR_PORT_MAP_56]       = hub->port_map56;\n\ti2c_wb[USB251XB_ADDR_PORT_MAP_7]        = hub->port_map7;\n\ti2c_wb[USB251XB_ADDR_STATUS_COMMAND] = USB251XB_STATUS_COMMAND_ATTACH;\n\n\tusb251xb_reset(hub);\n\n\t \n\tfor (i = 0; i < (USB251XB_I2C_REG_SZ / USB251XB_I2C_WRITE_SZ); i++) {\n\t\tint offset = i * USB251XB_I2C_WRITE_SZ;\n\t\tchar wbuf[USB251XB_I2C_WRITE_SZ + 1];\n\n\t\t \n\t\twbuf[0] = USB251XB_I2C_WRITE_SZ;\n\t\tmemcpy(&wbuf[1], &i2c_wb[offset], USB251XB_I2C_WRITE_SZ);\n\n\t\tdev_dbg(dev, \"writing %d byte block %d to 0x%02X\\n\",\n\t\t\tUSB251XB_I2C_WRITE_SZ, i, offset);\n\n\t\terr = i2c_smbus_write_i2c_block_data(hub->i2c, offset,\n\t\t\t\t\t\t     USB251XB_I2C_WRITE_SZ + 1,\n\t\t\t\t\t\t     wbuf);\n\t\tif (err)\n\t\t\tgoto out_err;\n\t}\n\n\tdev_info(dev, \"Hub configuration was successful.\\n\");\n\treturn 0;\n\nout_err:\n\tdev_err(dev, \"configuring block %d failed: %d\\n\", i, err);\n\treturn err;\n}\n\nstatic void usb251xb_get_ports_field(struct usb251xb *hub,\n\t\t\t\t    const char *prop_name, u8 port_cnt,\n\t\t\t\t    bool ds_only, u8 *fld)\n{\n\tstruct device *dev = hub->dev;\n\tstruct property *prop;\n\tconst __be32 *p;\n\tu32 port;\n\n\tof_property_for_each_u32(dev->of_node, prop_name, prop, p, port) {\n\t\tif ((port >= ds_only ? 1 : 0) && (port <= port_cnt))\n\t\t\t*fld |= BIT(port);\n\t\telse\n\t\t\tdev_warn(dev, \"port %u doesn't exist\\n\", port);\n\t}\n}\n\nstatic int usb251xb_get_ofdata(struct usb251xb *hub,\n\t\t\t       const struct usb251xb_data *data)\n{\n\tstruct device *dev = hub->dev;\n\tstruct device_node *np = dev->of_node;\n\tint len;\n\tu32 property_u32 = 0;\n\tconst char *cproperty_char;\n\tchar str[USB251XB_STRING_BUFSIZE / 2];\n\n\tif (!np) {\n\t\tdev_err(dev, \"failed to get ofdata\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thub->skip_config = of_property_read_bool(np, \"skip-config\");\n\n\thub->gpio_reset = devm_gpiod_get_optional(dev, \"reset\", GPIOD_OUT_HIGH);\n\tif (IS_ERR(hub->gpio_reset))\n\t\treturn dev_err_probe(dev, PTR_ERR(hub->gpio_reset),\n\t\t\t\t     \"unable to request GPIO reset pin\\n\");\n\n\tif (of_property_read_u16(np, \"vendor-id\", &hub->vendor_id))\n\t\thub->vendor_id = USB251XB_DEF_VENDOR_ID;\n\n\tif (of_property_read_u16(np, \"product-id\", &hub->product_id))\n\t\thub->product_id = data->product_id;\n\n\tif (of_property_read_u16(np, \"device-id\", &hub->device_id))\n\t\thub->device_id = USB251XB_DEF_DEVICE_ID;\n\n\thub->conf_data1 = USB251XB_DEF_CONFIG_DATA_1;\n\tif (of_property_read_bool(np, \"self-powered\")) {\n\t\thub->conf_data1 |= BIT(7);\n\n\t\t \n\t\thub->conf_data1 &= ~BIT(2);\n\t\tif (of_property_read_bool(np, \"ganged-sensing\"))\n\t\t\thub->conf_data1 &= ~BIT(1);\n\t\telse if (of_property_read_bool(np, \"individual-sensing\"))\n\t\t\thub->conf_data1 |= BIT(1);\n\t} else if (of_property_read_bool(np, \"bus-powered\")) {\n\t\thub->conf_data1 &= ~BIT(7);\n\n\t\t \n\t\thub->conf_data1 |= BIT(2);\n\t}\n\n\tif (of_property_read_bool(np, \"disable-hi-speed\"))\n\t\thub->conf_data1 |= BIT(5);\n\n\tif (of_property_read_bool(np, \"multi-tt\"))\n\t\thub->conf_data1 |= BIT(4);\n\telse if (of_property_read_bool(np, \"single-tt\"))\n\t\thub->conf_data1 &= ~BIT(4);\n\n\tif (of_property_read_bool(np, \"disable-eop\"))\n\t\thub->conf_data1 |= BIT(3);\n\n\tif (of_property_read_bool(np, \"individual-port-switching\"))\n\t\thub->conf_data1 |= BIT(0);\n\telse if (of_property_read_bool(np, \"ganged-port-switching\"))\n\t\thub->conf_data1 &= ~BIT(0);\n\n\thub->conf_data2 = USB251XB_DEF_CONFIG_DATA_2;\n\tif (of_property_read_bool(np, \"dynamic-power-switching\"))\n\t\thub->conf_data2 |= BIT(7);\n\n\tif (!of_property_read_u32(np, \"oc-delay-us\", &property_u32)) {\n\t\tif (property_u32 == 100) {\n\t\t\t \n\t\t\thub->conf_data2 &= ~BIT(5);\n\t\t\thub->conf_data2 &= ~BIT(4);\n\t\t} else if (property_u32 == 4000) {\n\t\t\t \n\t\t\thub->conf_data2 &= ~BIT(5);\n\t\t\thub->conf_data2 |= BIT(4);\n\t\t} else if (property_u32 == 16000) {\n\t\t\t \n\t\t\thub->conf_data2 |= BIT(5);\n\t\t\thub->conf_data2 |= BIT(4);\n\t\t} else {\n\t\t\t \n\t\t\thub->conf_data2 |= BIT(5);\n\t\t\thub->conf_data2 &= ~BIT(4);\n\t\t}\n\t}\n\n\tif (of_property_read_bool(np, \"compound-device\"))\n\t\thub->conf_data2 |= BIT(3);\n\n\thub->conf_data3 = USB251XB_DEF_CONFIG_DATA_3;\n\tif (of_property_read_bool(np, \"port-mapping-mode\"))\n\t\thub->conf_data3 |= BIT(3);\n\n\tif (data->led_support && of_get_property(np, \"led-usb-mode\", NULL))\n\t\thub->conf_data3 &= ~BIT(1);\n\n\tif (of_property_read_bool(np, \"string-support\"))\n\t\thub->conf_data3 |= BIT(0);\n\n\thub->non_rem_dev = USB251XB_DEF_NON_REMOVABLE_DEVICES;\n\tusb251xb_get_ports_field(hub, \"non-removable-ports\", data->port_cnt,\n\t\t\t\t true, &hub->non_rem_dev);\n\n\thub->port_disable_sp = USB251XB_DEF_PORT_DISABLE_SELF;\n\tusb251xb_get_ports_field(hub, \"sp-disabled-ports\", data->port_cnt,\n\t\t\t\t true, &hub->port_disable_sp);\n\n\thub->port_disable_bp = USB251XB_DEF_PORT_DISABLE_BUS;\n\tusb251xb_get_ports_field(hub, \"bp-disabled-ports\", data->port_cnt,\n\t\t\t\t true, &hub->port_disable_bp);\n\n\thub->max_power_sp = USB251XB_DEF_MAX_POWER_SELF;\n\tif (!of_property_read_u32(np, \"sp-max-total-current-microamp\",\n\t    &property_u32))\n\t\thub->max_power_sp = min_t(u8, property_u32 / 2000, 50);\n\n\thub->max_power_bp = USB251XB_DEF_MAX_POWER_BUS;\n\tif (!of_property_read_u32(np, \"bp-max-total-current-microamp\",\n\t    &property_u32))\n\t\thub->max_power_bp = min_t(u8, property_u32 / 2000, 255);\n\n\thub->max_current_sp = USB251XB_DEF_MAX_CURRENT_SELF;\n\tif (!of_property_read_u32(np, \"sp-max-removable-current-microamp\",\n\t    &property_u32))\n\t\thub->max_current_sp = min_t(u8, property_u32 / 2000, 50);\n\n\thub->max_current_bp = USB251XB_DEF_MAX_CURRENT_BUS;\n\tif (!of_property_read_u32(np, \"bp-max-removable-current-microamp\",\n\t    &property_u32))\n\t\thub->max_current_bp = min_t(u8, property_u32 / 2000, 255);\n\n\thub->power_on_time = USB251XB_DEF_POWER_ON_TIME;\n\tif (!of_property_read_u32(np, \"power-on-time-ms\", &property_u32))\n\t\thub->power_on_time = min_t(u8, property_u32 / 2, 255);\n\n\tif (of_property_read_u16(np, \"language-id\", &hub->lang_id))\n\t\thub->lang_id = USB251XB_DEF_LANGUAGE_ID;\n\n\tif (of_property_read_u8(np, \"boost-up\", &hub->boost_up))\n\t\thub->boost_up = USB251XB_DEF_BOOST_UP;\n\n\tcproperty_char = of_get_property(np, \"manufacturer\", NULL);\n\tstrscpy(str, cproperty_char ? : USB251XB_DEF_MANUFACTURER_STRING,\n\t\tsizeof(str));\n\thub->manufacturer_len = strlen(str) & 0xFF;\n\tmemset(hub->manufacturer, 0, USB251XB_STRING_BUFSIZE);\n\tlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\n\tlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\n\t\t\t      (wchar_t *)hub->manufacturer,\n\t\t\t      USB251XB_STRING_BUFSIZE);\n\n\tcproperty_char = of_get_property(np, \"product\", NULL);\n\tstrscpy(str, cproperty_char ? : data->product_str, sizeof(str));\n\thub->product_len = strlen(str) & 0xFF;\n\tmemset(hub->product, 0, USB251XB_STRING_BUFSIZE);\n\tlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\n\tlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\n\t\t\t      (wchar_t *)hub->product,\n\t\t\t      USB251XB_STRING_BUFSIZE);\n\n\tcproperty_char = of_get_property(np, \"serial\", NULL);\n\tstrscpy(str, cproperty_char ? : USB251XB_DEF_SERIAL_STRING,\n\t\tsizeof(str));\n\thub->serial_len = strlen(str) & 0xFF;\n\tmemset(hub->serial, 0, USB251XB_STRING_BUFSIZE);\n\tlen = min_t(size_t, USB251XB_STRING_BUFSIZE / 2, strlen(str));\n\tlen = utf8s_to_utf16s(str, len, UTF16_LITTLE_ENDIAN,\n\t\t\t      (wchar_t *)hub->serial,\n\t\t\t      USB251XB_STRING_BUFSIZE);\n\n\t \n\thub->port_swap = USB251XB_DEF_PORT_SWAP;\n\tusb251xb_get_ports_field(hub, \"swap-dx-lanes\", data->port_cnt,\n\t\t\t\t false, &hub->port_swap);\n\n\t \n\thub->bat_charge_en = USB251XB_DEF_BATTERY_CHARGING_ENABLE;\n\thub->boost_57 = USB251XB_DEF_BOOST_57;\n\thub->boost_14 = USB251XB_DEF_BOOST_14;\n\thub->port_map12 = USB251XB_DEF_PORT_MAP_12;\n\thub->port_map34 = USB251XB_DEF_PORT_MAP_34;\n\thub->port_map56 = USB251XB_DEF_PORT_MAP_56;\n\thub->port_map7  = USB251XB_DEF_PORT_MAP_7;\n\n\treturn 0;\n}\n\nstatic const struct of_device_id usb251xb_of_match[] = {\n\t{\n\t\t.compatible = \"microchip,usb2422\",\n\t\t.data = &usb2422_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2512b\",\n\t\t.data = &usb2512b_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2512bi\",\n\t\t.data = &usb2512bi_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2513b\",\n\t\t.data = &usb2513b_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2513bi\",\n\t\t.data = &usb2513bi_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2514b\",\n\t\t.data = &usb2514b_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2514bi\",\n\t\t.data = &usb2514bi_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2517\",\n\t\t.data = &usb2517_data,\n\t}, {\n\t\t.compatible = \"microchip,usb2517i\",\n\t\t.data = &usb2517i_data,\n\t}, {\n\t\t \n\t}\n};\nMODULE_DEVICE_TABLE(of, usb251xb_of_match);\n\nstatic void usb251xb_regulator_disable_action(void *data)\n{\n\tstruct usb251xb *hub = data;\n\n\tregulator_disable(hub->vdd);\n}\n\nstatic int usb251xb_probe(struct usb251xb *hub)\n{\n\tstruct device *dev = hub->dev;\n\tstruct device_node *np = dev->of_node;\n\tconst struct usb251xb_data *usb_data = of_device_get_match_data(dev);\n\tint err;\n\n\tif (np && usb_data) {\n\t\terr = usb251xb_get_ofdata(hub, usb_data);\n\t\tif (err) {\n\t\t\tdev_err(dev, \"failed to get ofdata: %d\\n\", err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\terr = usb251x_check_gpio_chip(hub);\n\tif (err)\n\t\treturn err;\n\n\thub->vdd = devm_regulator_get(dev, \"vdd\");\n\tif (IS_ERR(hub->vdd))\n\t\treturn PTR_ERR(hub->vdd);\n\n\terr = regulator_enable(hub->vdd);\n\tif (err)\n\t\treturn err;\n\n\terr = devm_add_action_or_reset(dev,\n\t\t\t\t       usb251xb_regulator_disable_action, hub);\n\tif (err)\n\t\treturn err;\n\n\terr = usb251xb_connect(hub);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to connect hub (%d)\\n\", err);\n\t\treturn err;\n\t}\n\n\tdev_info(dev, \"Hub probed successfully\\n\");\n\n\treturn 0;\n}\n\nstatic int usb251xb_i2c_probe(struct i2c_client *i2c)\n{\n\tstruct usb251xb *hub;\n\n\thub = devm_kzalloc(&i2c->dev, sizeof(struct usb251xb), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\ti2c_set_clientdata(i2c, hub);\n\thub->dev = &i2c->dev;\n\thub->i2c = i2c;\n\n\treturn usb251xb_probe(hub);\n}\n\nstatic int __maybe_unused usb251xb_suspend(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct usb251xb *hub = i2c_get_clientdata(client);\n\n\treturn regulator_disable(hub->vdd);\n}\n\nstatic int __maybe_unused usb251xb_resume(struct device *dev)\n{\n\tstruct i2c_client *client = to_i2c_client(dev);\n\tstruct usb251xb *hub = i2c_get_clientdata(client);\n\tint err;\n\n\terr = regulator_enable(hub->vdd);\n\tif (err)\n\t\treturn err;\n\n\treturn usb251xb_connect(hub);\n}\n\nstatic SIMPLE_DEV_PM_OPS(usb251xb_pm_ops, usb251xb_suspend, usb251xb_resume);\n\nstatic const struct i2c_device_id usb251xb_id[] = {\n\t{ \"usb2422\", 0 },\n\t{ \"usb2512b\", 0 },\n\t{ \"usb2512bi\", 0 },\n\t{ \"usb2513b\", 0 },\n\t{ \"usb2513bi\", 0 },\n\t{ \"usb2514b\", 0 },\n\t{ \"usb2514bi\", 0 },\n\t{ \"usb2517\", 0 },\n\t{ \"usb2517i\", 0 },\n\t{   }\n};\nMODULE_DEVICE_TABLE(i2c, usb251xb_id);\n\nstatic struct i2c_driver usb251xb_i2c_driver = {\n\t.driver = {\n\t\t.name = DRIVER_NAME,\n\t\t.of_match_table = usb251xb_of_match,\n\t\t.pm = &usb251xb_pm_ops,\n\t},\n\t.probe = usb251xb_i2c_probe,\n\t.id_table = usb251xb_id,\n};\n\nmodule_i2c_driver(usb251xb_i2c_driver);\n\nMODULE_AUTHOR(\"Richard Leitner <richard.leitner@skidata.com>\");\nMODULE_DESCRIPTION(\"USB251x/xBi USB 2.0 Hub Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}