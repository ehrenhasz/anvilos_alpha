{
  "module_name": "usblcd.c",
  "hash_id": "66b68ff0f43acf07ec0af1891ac0993f04a38a459bcccf2a826898c399c16772",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/usblcd.c",
  "human_readable_source": "\n \n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/mutex.h>\n#include <linux/rwsem.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n\n#define DRIVER_VERSION \"USBLCD Driver Version 1.05\"\n\n#define USBLCD_MINOR\t\t144\n\n#define IOCTL_GET_HARD_VERSION\t1\n#define IOCTL_GET_DRV_VERSION\t2\n\n\nstatic const struct usb_device_id id_table[] = {\n\t{ .idVendor = 0x10D2, .match_flags = USB_DEVICE_ID_MATCH_VENDOR, },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstruct usb_lcd {\n\tstruct usb_device\t*udev;\t\t\t \n\tstruct usb_interface\t*interface;\t\t \n\tunsigned char\t\t*bulk_in_buffer;\t \n\tsize_t\t\t\tbulk_in_size;\t\t \n\t__u8\t\t\tbulk_in_endpointAddr;\t \n\t__u8\t\t\tbulk_out_endpointAddr;\t \n\tstruct kref\t\tkref;\n\tstruct semaphore\tlimit_sem;\t\t \n\tstruct usb_anchor\tsubmitted;\t\t \n\tstruct rw_semaphore\tio_rwsem;\n\tunsigned long\t\tdisconnected:1;\n};\n#define to_lcd_dev(d) container_of(d, struct usb_lcd, kref)\n\n#define USB_LCD_CONCURRENT_WRITES\t5\n\nstatic struct usb_driver lcd_driver;\n\n\nstatic void lcd_delete(struct kref *kref)\n{\n\tstruct usb_lcd *dev = to_lcd_dev(kref);\n\n\tusb_put_dev(dev->udev);\n\tkfree(dev->bulk_in_buffer);\n\tkfree(dev);\n}\n\n\nstatic int lcd_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_lcd *dev;\n\tstruct usb_interface *interface;\n\tint subminor, r;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&lcd_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"USBLCD: %s - error, can't find device for minor %d\\n\",\n\t\t       __func__, subminor);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\n\t \n\tkref_get(&dev->kref);\n\n\t \n\tr = usb_autopm_get_interface(interface);\n\tif (r < 0) {\n\t\tkref_put(&dev->kref, lcd_delete);\n\t\treturn r;\n\t}\n\n\t \n\tfile->private_data = dev;\n\n\treturn 0;\n}\n\nstatic int lcd_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_lcd *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tusb_autopm_put_interface(dev->interface);\n\tkref_put(&dev->kref, lcd_delete);\n\treturn 0;\n}\n\nstatic ssize_t lcd_read(struct file *file, char __user * buffer,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct usb_lcd *dev;\n\tint retval = 0;\n\tint bytes_read;\n\n\tdev = file->private_data;\n\n\tdown_read(&dev->io_rwsem);\n\n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tgoto out_up_io;\n\t}\n\n\t \n\tretval = usb_bulk_msg(dev->udev,\n\t\t\t      usb_rcvbulkpipe(dev->udev,\n\t\t\t\t\t      dev->bulk_in_endpointAddr),\n\t\t\t      dev->bulk_in_buffer,\n\t\t\t      min(dev->bulk_in_size, count),\n\t\t\t      &bytes_read, 10000);\n\n\t \n\tif (!retval) {\n\t\tif (copy_to_user(buffer, dev->bulk_in_buffer, bytes_read))\n\t\t\tretval = -EFAULT;\n\t\telse\n\t\t\tretval = bytes_read;\n\t}\n\nout_up_io:\n\tup_read(&dev->io_rwsem);\n\n\treturn retval;\n}\n\nstatic long lcd_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct usb_lcd *dev;\n\tu16 bcdDevice;\n\tchar buf[30];\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tswitch (cmd) {\n\tcase IOCTL_GET_HARD_VERSION:\n\t\tbcdDevice = le16_to_cpu((dev->udev)->descriptor.bcdDevice);\n\t\tsprintf(buf, \"%1d%1d.%1d%1d\",\n\t\t\t(bcdDevice & 0xF000)>>12,\n\t\t\t(bcdDevice & 0xF00)>>8,\n\t\t\t(bcdDevice & 0xF0)>>4,\n\t\t\t(bcdDevice & 0xF));\n\t\tif (copy_to_user((void __user *)arg, buf, strlen(buf)) != 0)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tcase IOCTL_GET_DRV_VERSION:\n\t\tsprintf(buf, DRIVER_VERSION);\n\t\tif (copy_to_user((void __user *)arg, buf, strlen(buf)) != 0)\n\t\t\treturn -EFAULT;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\n\treturn 0;\n}\n\nstatic void lcd_write_bulk_callback(struct urb *urb)\n{\n\tstruct usb_lcd *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\n\t \n\tif (status &&\n\t    !(status == -ENOENT ||\n\t      status == -ECONNRESET ||\n\t      status == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\"nonzero write bulk status received: %d\\n\", status);\n\t}\n\n\t \n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\tup(&dev->limit_sem);\n}\n\nstatic ssize_t lcd_write(struct file *file, const char __user * user_buffer,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct usb_lcd *dev;\n\tint retval = 0, r;\n\tstruct urb *urb = NULL;\n\tchar *buf = NULL;\n\n\tdev = file->private_data;\n\n\t \n\tif (count == 0)\n\t\tgoto exit;\n\n\tr = down_interruptible(&dev->limit_sem);\n\tif (r < 0)\n\t\treturn -EINTR;\n\n\tdown_read(&dev->io_rwsem);\n\n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tgoto err_up_io;\n\t}\n\n\t \n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb) {\n\t\tretval = -ENOMEM;\n\t\tgoto err_up_io;\n\t}\n\n\tbuf = usb_alloc_coherent(dev->udev, count, GFP_KERNEL,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(buf, user_buffer, count)) {\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\n\t \n\tusb_fill_bulk_urb(urb, dev->udev,\n\t\t\t  usb_sndbulkpipe(dev->udev,\n\t\t\t  dev->bulk_out_endpointAddr),\n\t\t\t  buf, count, lcd_write_bulk_callback, dev);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\tusb_anchor_urb(urb, &dev->submitted);\n\n\t \n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto error_unanchor;\n\t}\n\n\t \n\tusb_free_urb(urb);\n\n\tup_read(&dev->io_rwsem);\nexit:\n\treturn count;\nerror_unanchor:\n\tusb_unanchor_urb(urb);\nerror:\n\tusb_free_coherent(dev->udev, count, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\nerr_up_io:\n\tup_read(&dev->io_rwsem);\n\tup(&dev->limit_sem);\n\treturn retval;\n}\n\nstatic const struct file_operations lcd_fops = {\n\t.owner =        THIS_MODULE,\n\t.read =         lcd_read,\n\t.write =        lcd_write,\n\t.open =         lcd_open,\n\t.unlocked_ioctl = lcd_ioctl,\n\t.release =      lcd_release,\n\t.llseek =\t noop_llseek,\n};\n\n \nstatic struct usb_class_driver lcd_class = {\n\t.name =         \"lcd%d\",\n\t.fops =         &lcd_fops,\n\t.minor_base =   USBLCD_MINOR,\n};\n\nstatic int lcd_probe(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_lcd *dev = NULL;\n\tstruct usb_endpoint_descriptor *bulk_in, *bulk_out;\n\tint i;\n\tint retval;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\n\tkref_init(&dev->kref);\n\tsema_init(&dev->limit_sem, USB_LCD_CONCURRENT_WRITES);\n\tinit_rwsem(&dev->io_rwsem);\n\tinit_usb_anchor(&dev->submitted);\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = interface;\n\n\tif (le16_to_cpu(dev->udev->descriptor.idProduct) != 0x0001) {\n\t\tdev_warn(&interface->dev, \"USBLCD model not supported.\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\t \n\t \n\tretval = usb_find_common_endpoints(interface->cur_altsetting,\n\t\t\t&bulk_in, &bulk_out, NULL, NULL);\n\tif (retval) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Could not find both bulk-in and bulk-out endpoints\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->bulk_in_size = usb_endpoint_maxp(bulk_in);\n\tdev->bulk_in_endpointAddr = bulk_in->bEndpointAddress;\n\tdev->bulk_in_buffer = kmalloc(dev->bulk_in_size, GFP_KERNEL);\n\tif (!dev->bulk_in_buffer) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdev->bulk_out_endpointAddr = bulk_out->bEndpointAddress;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\t \n\tretval = usb_register_dev(interface, &lcd_class);\n\tif (retval) {\n\t\t \n\t\tdev_err(&interface->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tgoto error;\n\t}\n\n\ti = le16_to_cpu(dev->udev->descriptor.bcdDevice);\n\n\tdev_info(&interface->dev, \"USBLCD Version %1d%1d.%1d%1d found \"\n\t\t \"at address %d\\n\", (i & 0xF000)>>12, (i & 0xF00)>>8,\n\t\t (i & 0xF0)>>4, (i & 0xF), dev->udev->devnum);\n\n\t \n\tdev_info(&interface->dev, \"USB LCD device now attached to USBLCD-%d\\n\",\n\t\t interface->minor);\n\treturn 0;\n\nerror:\n\tkref_put(&dev->kref, lcd_delete);\n\treturn retval;\n}\n\nstatic void lcd_draw_down(struct usb_lcd *dev)\n{\n\tint time;\n\n\ttime = usb_wait_anchor_empty_timeout(&dev->submitted, 1000);\n\tif (!time)\n\t\tusb_kill_anchored_urbs(&dev->submitted);\n}\n\nstatic int lcd_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_lcd *dev = usb_get_intfdata(intf);\n\n\tif (!dev)\n\t\treturn 0;\n\tlcd_draw_down(dev);\n\treturn 0;\n}\n\nstatic int lcd_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic void lcd_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_lcd *dev = usb_get_intfdata(interface);\n\tint minor = interface->minor;\n\n\t \n\tusb_deregister_dev(interface, &lcd_class);\n\n\tdown_write(&dev->io_rwsem);\n\tdev->disconnected = 1;\n\tup_write(&dev->io_rwsem);\n\n\tusb_kill_anchored_urbs(&dev->submitted);\n\n\t \n\tkref_put(&dev->kref, lcd_delete);\n\n\tdev_info(&interface->dev, \"USB LCD #%d now disconnected\\n\", minor);\n}\n\nstatic struct usb_driver lcd_driver = {\n\t.name =\t\t\"usblcd\",\n\t.probe =\tlcd_probe,\n\t.disconnect =\tlcd_disconnect,\n\t.suspend =\tlcd_suspend,\n\t.resume =\tlcd_resume,\n\t.id_table =\tid_table,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(lcd_driver);\n\nMODULE_AUTHOR(\"Georges Toth <g.toth@e-biz.lu>\");\nMODULE_DESCRIPTION(DRIVER_VERSION);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}