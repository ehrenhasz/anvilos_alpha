{
  "module_name": "ldusb.c",
  "hash_id": "d7228eeb091e9f15ece531768108f102b5902f0f67f931a0e4743c71fe178af7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/ldusb.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n\n#include <linux/uaccess.h>\n#include <linux/input.h>\n#include <linux/usb.h>\n#include <linux/poll.h>\n\n \n#define USB_VENDOR_ID_LD\t\t0x0f11\t \n#define USB_DEVICE_ID_LD_CASSY\t\t0x1000\t \n#define USB_DEVICE_ID_LD_CASSY2\t\t0x1001\t \n#define USB_DEVICE_ID_LD_POCKETCASSY\t0x1010\t \n#define USB_DEVICE_ID_LD_POCKETCASSY2\t0x1011\t \n#define USB_DEVICE_ID_LD_MOBILECASSY\t0x1020\t \n#define USB_DEVICE_ID_LD_MOBILECASSY2\t0x1021\t \n#define USB_DEVICE_ID_LD_MICROCASSYVOLTAGE\t0x1031\t \n#define USB_DEVICE_ID_LD_MICROCASSYCURRENT\t0x1032\t \n#define USB_DEVICE_ID_LD_MICROCASSYTIME\t\t0x1033\t \n#define USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE\t0x1035\t \n#define USB_DEVICE_ID_LD_MICROCASSYPH\t\t0x1038\t \n#define USB_DEVICE_ID_LD_POWERANALYSERCASSY\t0x1040\t \n#define USB_DEVICE_ID_LD_CONVERTERCONTROLLERCASSY\t0x1042\t \n#define USB_DEVICE_ID_LD_MACHINETESTCASSY\t0x1043\t \n#define USB_DEVICE_ID_LD_JWM\t\t0x1080\t \n#define USB_DEVICE_ID_LD_DMMP\t\t0x1081\t \n#define USB_DEVICE_ID_LD_UMIP\t\t0x1090\t \n#define USB_DEVICE_ID_LD_UMIC\t\t0x10A0\t \n#define USB_DEVICE_ID_LD_UMIB\t\t0x10B0\t \n#define USB_DEVICE_ID_LD_XRAY\t\t0x1100\t \n#define USB_DEVICE_ID_LD_XRAY2\t\t0x1101\t \n#define USB_DEVICE_ID_LD_XRAYCT\t\t0x1110\t \n#define USB_DEVICE_ID_LD_VIDEOCOM\t0x1200\t \n#define USB_DEVICE_ID_LD_MOTOR\t\t0x1210\t \n#define USB_DEVICE_ID_LD_COM3LAB\t0x2000\t \n#define USB_DEVICE_ID_LD_TELEPORT\t0x2010\t \n#define USB_DEVICE_ID_LD_NETWORKANALYSER 0x2020\t \n#define USB_DEVICE_ID_LD_POWERCONTROL\t0x2030\t \n#define USB_DEVICE_ID_LD_MACHINETEST\t0x2040\t \n#define USB_DEVICE_ID_LD_MOSTANALYSER\t0x2050\t \n#define USB_DEVICE_ID_LD_MOSTANALYSER2\t0x2051\t \n#define USB_DEVICE_ID_LD_ABSESP\t\t0x2060\t \n#define USB_DEVICE_ID_LD_AUTODATABUS\t0x2070\t \n#define USB_DEVICE_ID_LD_MCT\t\t0x2080\t \n#define USB_DEVICE_ID_LD_HYBRID\t\t0x2090\t \n#define USB_DEVICE_ID_LD_HEATCONTROL\t0x20A0\t \n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define USB_LD_MINOR_BASE\t0\n#else\n#define USB_LD_MINOR_BASE\t176\n#endif\n\n \nstatic const struct usb_device_id ld_usb_table[] = {\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CASSY2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POCKETCASSY2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOBILECASSY2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYVOLTAGE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYCURRENT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTIME) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYTEMPERATURE) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MICROCASSYPH) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POWERANALYSERCASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_CONVERTERCONTROLLERCASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MACHINETESTCASSY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_JWM) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_DMMP) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIP) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIC) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_UMIB) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_XRAY2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_VIDEOCOM) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOTOR) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_COM3LAB) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_TELEPORT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_NETWORKANALYSER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_POWERCONTROL) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MACHINETEST) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MOSTANALYSER2) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_ABSESP) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_AUTODATABUS) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_MCT) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HYBRID) },\n\t{ USB_DEVICE(USB_VENDOR_ID_LD, USB_DEVICE_ID_LD_HEATCONTROL) },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, ld_usb_table);\nMODULE_AUTHOR(\"Michael Hund <mhund@ld-didactic.de>\");\nMODULE_DESCRIPTION(\"LD USB Driver\");\nMODULE_LICENSE(\"GPL\");\n\n \nstatic int ring_buffer_size = 128;\nmodule_param(ring_buffer_size, int, 0000);\nMODULE_PARM_DESC(ring_buffer_size, \"Read ring buffer size in reports\");\n\n \nstatic int write_buffer_size = 10;\nmodule_param(write_buffer_size, int, 0000);\nMODULE_PARM_DESC(write_buffer_size, \"Write buffer size in reports\");\n\n \nstatic int min_interrupt_in_interval = 2;\nmodule_param(min_interrupt_in_interval, int, 0000);\nMODULE_PARM_DESC(min_interrupt_in_interval, \"Minimum interrupt in interval in ms\");\n\nstatic int min_interrupt_out_interval = 2;\nmodule_param(min_interrupt_out_interval, int, 0000);\nMODULE_PARM_DESC(min_interrupt_out_interval, \"Minimum interrupt out interval in ms\");\n\n \nstruct ld_usb {\n\tstruct mutex\t\tmutex;\t\t \n\tstruct usb_interface\t*intf;\t\t \n\tunsigned long\t\tdisconnected:1;\n\n\tint\t\t\topen_count;\t \n\n\tchar\t\t\t*ring_buffer;\n\tunsigned int\t\tring_head;\n\tunsigned int\t\tring_tail;\n\n\twait_queue_head_t\tread_wait;\n\twait_queue_head_t\twrite_wait;\n\n\tchar\t\t\t*interrupt_in_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_in_endpoint;\n\tstruct urb\t\t*interrupt_in_urb;\n\tint\t\t\tinterrupt_in_interval;\n\tsize_t\t\t\tinterrupt_in_endpoint_size;\n\tint\t\t\tinterrupt_in_running;\n\tint\t\t\tinterrupt_in_done;\n\tint\t\t\tbuffer_overflow;\n\tspinlock_t\t\trbsl;\n\n\tchar\t\t\t*interrupt_out_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_out_endpoint;\n\tstruct urb\t\t*interrupt_out_urb;\n\tint\t\t\tinterrupt_out_interval;\n\tsize_t\t\t\tinterrupt_out_endpoint_size;\n\tint\t\t\tinterrupt_out_busy;\n};\n\nstatic struct usb_driver ld_usb_driver;\n\n \nstatic void ld_usb_abort_transfers(struct ld_usb *dev)\n{\n\t \n\tif (dev->interrupt_in_running) {\n\t\tdev->interrupt_in_running = 0;\n\t\tusb_kill_urb(dev->interrupt_in_urb);\n\t}\n\tif (dev->interrupt_out_busy)\n\t\tusb_kill_urb(dev->interrupt_out_urb);\n}\n\n \nstatic void ld_usb_delete(struct ld_usb *dev)\n{\n\t \n\tusb_free_urb(dev->interrupt_in_urb);\n\tusb_free_urb(dev->interrupt_out_urb);\n\tkfree(dev->ring_buffer);\n\tkfree(dev->interrupt_in_buffer);\n\tkfree(dev->interrupt_out_buffer);\n\tkfree(dev);\n}\n\n \nstatic void ld_usb_interrupt_in_callback(struct urb *urb)\n{\n\tstruct ld_usb *dev = urb->context;\n\tsize_t *actual_buffer;\n\tunsigned int next_ring_head;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint retval;\n\n\tif (status) {\n\t\tif (status == -ENOENT ||\n\t\t    status == -ECONNRESET ||\n\t\t    status == -ESHUTDOWN) {\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tdev_dbg(&dev->intf->dev,\n\t\t\t\t\"%s: nonzero status received: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tspin_lock_irqsave(&dev->rbsl, flags);\n\t\t\tgoto resubmit;  \n\t\t}\n\t}\n\n\tspin_lock_irqsave(&dev->rbsl, flags);\n\tif (urb->actual_length > 0) {\n\t\tnext_ring_head = (dev->ring_head+1) % ring_buffer_size;\n\t\tif (next_ring_head != dev->ring_tail) {\n\t\t\tactual_buffer = (size_t *)(dev->ring_buffer + dev->ring_head * (sizeof(size_t)+dev->interrupt_in_endpoint_size));\n\t\t\t \n\t\t\t*actual_buffer = urb->actual_length;\n\t\t\tmemcpy(actual_buffer+1, dev->interrupt_in_buffer, urb->actual_length);\n\t\t\tdev->ring_head = next_ring_head;\n\t\t\tdev_dbg(&dev->intf->dev, \"%s: received %d bytes\\n\",\n\t\t\t\t__func__, urb->actual_length);\n\t\t} else {\n\t\t\tdev_warn(&dev->intf->dev,\n\t\t\t\t \"Ring buffer overflow, %d bytes dropped\\n\",\n\t\t\t\t urb->actual_length);\n\t\t\tdev->buffer_overflow = 1;\n\t\t}\n\t}\n\nresubmit:\n\t \n\tif (dev->interrupt_in_running && !dev->buffer_overflow) {\n\t\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);\n\t\tif (retval) {\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"usb_submit_urb failed (%d)\\n\", retval);\n\t\t\tdev->buffer_overflow = 1;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->rbsl, flags);\nexit:\n\tdev->interrupt_in_done = 1;\n\twake_up_interruptible(&dev->read_wait);\n}\n\n \nstatic void ld_usb_interrupt_out_callback(struct urb *urb)\n{\n\tstruct ld_usb *dev = urb->context;\n\tint status = urb->status;\n\n\t \n\tif (status && !(status == -ENOENT ||\n\t\t\tstatus == -ECONNRESET ||\n\t\t\tstatus == -ESHUTDOWN))\n\t\tdev_dbg(&dev->intf->dev,\n\t\t\t\"%s - nonzero write interrupt status received: %d\\n\",\n\t\t\t__func__, status);\n\n\tdev->interrupt_out_busy = 0;\n\twake_up_interruptible(&dev->write_wait);\n}\n\n \nstatic int ld_usb_open(struct inode *inode, struct file *file)\n{\n\tstruct ld_usb *dev;\n\tint subminor;\n\tint retval;\n\tstruct usb_interface *interface;\n\n\tstream_open(inode, file);\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&ld_usb_driver, subminor);\n\n\tif (!interface) {\n\t\tprintk(KERN_ERR \"%s - error, can't find device for minor %d\\n\",\n\t\t       __func__, subminor);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t \n\tif (mutex_lock_interruptible(&dev->mutex))\n\t\treturn -ERESTARTSYS;\n\n\t \n\tif (dev->open_count) {\n\t\tretval = -EBUSY;\n\t\tgoto unlock_exit;\n\t}\n\tdev->open_count = 1;\n\n\t \n\tdev->ring_head = 0;\n\tdev->ring_tail = 0;\n\tdev->buffer_overflow = 0;\n\tusb_fill_int_urb(dev->interrupt_in_urb,\n\t\t\t interface_to_usbdev(interface),\n\t\t\t usb_rcvintpipe(interface_to_usbdev(interface),\n\t\t\t\t\tdev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_in_buffer,\n\t\t\t dev->interrupt_in_endpoint_size,\n\t\t\t ld_usb_interrupt_in_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_in_interval);\n\n\tdev->interrupt_in_running = 1;\n\tdev->interrupt_in_done = 0;\n\n\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&interface->dev, \"Couldn't submit interrupt_in_urb %d\\n\", retval);\n\t\tdev->interrupt_in_running = 0;\n\t\tdev->open_count = 0;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tfile->private_data = dev;\n\nunlock_exit:\n\tmutex_unlock(&dev->mutex);\n\n\treturn retval;\n}\n\n \nstatic int ld_usb_release(struct inode *inode, struct file *file)\n{\n\tstruct ld_usb *dev;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\tif (dev == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&dev->mutex);\n\n\tif (dev->open_count != 1) {\n\t\tretval = -ENODEV;\n\t\tgoto unlock_exit;\n\t}\n\tif (dev->disconnected) {\n\t\t \n\t\tmutex_unlock(&dev->mutex);\n\t\t \n\t\tld_usb_delete(dev);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->interrupt_out_busy)\n\t\twait_event_interruptible_timeout(dev->write_wait, !dev->interrupt_out_busy, 2 * HZ);\n\tld_usb_abort_transfers(dev);\n\tdev->open_count = 0;\n\nunlock_exit:\n\tmutex_unlock(&dev->mutex);\n\nexit:\n\treturn retval;\n}\n\n \nstatic __poll_t ld_usb_poll(struct file *file, poll_table *wait)\n{\n\tstruct ld_usb *dev;\n\t__poll_t mask = 0;\n\n\tdev = file->private_data;\n\n\tif (dev->disconnected)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\tif (dev->ring_head != dev->ring_tail)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (!dev->interrupt_out_busy)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn mask;\n}\n\n \nstatic ssize_t ld_usb_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\tstruct ld_usb *dev;\n\tsize_t *actual_buffer;\n\tsize_t bytes_to_read;\n\tint retval = 0;\n\tint rv;\n\n\tdev = file->private_data;\n\n\t \n\tif (count == 0)\n\t\tgoto exit;\n\n\t \n\tif (mutex_lock_interruptible(&dev->mutex)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tprintk(KERN_ERR \"ldusb: No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tspin_lock_irq(&dev->rbsl);\n\twhile (dev->ring_head == dev->ring_tail) {\n\t\tdev->interrupt_in_done = 0;\n\t\tspin_unlock_irq(&dev->rbsl);\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible(dev->read_wait, dev->interrupt_in_done);\n\t\tif (retval < 0)\n\t\t\tgoto unlock_exit;\n\n\t\tspin_lock_irq(&dev->rbsl);\n\t}\n\tspin_unlock_irq(&dev->rbsl);\n\n\t \n\tactual_buffer = (size_t *)(dev->ring_buffer + dev->ring_tail * (sizeof(size_t)+dev->interrupt_in_endpoint_size));\n\tif (*actual_buffer > dev->interrupt_in_endpoint_size) {\n\t\tretval = -EIO;\n\t\tgoto unlock_exit;\n\t}\n\tbytes_to_read = min(count, *actual_buffer);\n\tif (bytes_to_read < *actual_buffer)\n\t\tdev_warn(&dev->intf->dev, \"Read buffer overflow, %zu bytes dropped\\n\",\n\t\t\t *actual_buffer-bytes_to_read);\n\n\t \n\tif (copy_to_user(buffer, actual_buffer+1, bytes_to_read)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\tretval = bytes_to_read;\n\n\tspin_lock_irq(&dev->rbsl);\n\tdev->ring_tail = (dev->ring_tail + 1) % ring_buffer_size;\n\n\tif (dev->buffer_overflow) {\n\t\tdev->buffer_overflow = 0;\n\t\tspin_unlock_irq(&dev->rbsl);\n\t\trv = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\n\t\tif (rv < 0)\n\t\t\tdev->buffer_overflow = 1;\n\t} else {\n\t\tspin_unlock_irq(&dev->rbsl);\n\t}\n\nunlock_exit:\n\t \n\tmutex_unlock(&dev->mutex);\n\nexit:\n\treturn retval;\n}\n\n \nstatic ssize_t ld_usb_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct ld_usb *dev;\n\tsize_t bytes_to_write;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\t \n\tif (count == 0)\n\t\tgoto exit;\n\n\t \n\tif (mutex_lock_interruptible(&dev->mutex)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tprintk(KERN_ERR \"ldusb: No device or device unplugged %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif (dev->interrupt_out_busy) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible(dev->write_wait, !dev->interrupt_out_busy);\n\t\tif (retval < 0) {\n\t\t\tgoto unlock_exit;\n\t\t}\n\t}\n\n\t \n\tbytes_to_write = min(count, write_buffer_size*dev->interrupt_out_endpoint_size);\n\tif (bytes_to_write < count)\n\t\tdev_warn(&dev->intf->dev, \"Write buffer overflow, %zu bytes dropped\\n\",\n\t\t\tcount - bytes_to_write);\n\tdev_dbg(&dev->intf->dev, \"%s: count = %zu, bytes_to_write = %zu\\n\",\n\t\t__func__, count, bytes_to_write);\n\n\tif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\tif (dev->interrupt_out_endpoint == NULL) {\n\t\t \n\t\tretval = usb_control_msg(interface_to_usbdev(dev->intf),\n\t\t\t\t\t usb_sndctrlpipe(interface_to_usbdev(dev->intf), 0),\n\t\t\t\t\t 9,\n\t\t\t\t\t USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT,\n\t\t\t\t\t 1 << 8, 0,\n\t\t\t\t\t dev->interrupt_out_buffer,\n\t\t\t\t\t bytes_to_write,\n\t\t\t\t\t USB_CTRL_SET_TIMEOUT);\n\t\tif (retval < 0)\n\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\"Couldn't submit HID_REQ_SET_REPORT %d\\n\",\n\t\t\t\tretval);\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tusb_fill_int_urb(dev->interrupt_out_urb,\n\t\t\t interface_to_usbdev(dev->intf),\n\t\t\t usb_sndintpipe(interface_to_usbdev(dev->intf),\n\t\t\t\t\tdev->interrupt_out_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_out_buffer,\n\t\t\t bytes_to_write,\n\t\t\t ld_usb_interrupt_out_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_out_interval);\n\n\tdev->interrupt_out_busy = 1;\n\twmb();\n\n\tretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev->interrupt_out_busy = 0;\n\t\tdev_err(&dev->intf->dev,\n\t\t\t\"Couldn't submit interrupt_out_urb %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\tretval = bytes_to_write;\n\nunlock_exit:\n\t \n\tmutex_unlock(&dev->mutex);\n\nexit:\n\treturn retval;\n}\n\n \nstatic const struct file_operations ld_usb_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read  =\tld_usb_read,\n\t.write =\tld_usb_write,\n\t.open =\t\tld_usb_open,\n\t.release =\tld_usb_release,\n\t.poll =\t\tld_usb_poll,\n\t.llseek =\tno_llseek,\n};\n\n \nstatic struct usb_class_driver ld_usb_class = {\n\t.name =\t\t\"ldusb%d\",\n\t.fops =\t\t&ld_usb_fops,\n\t.minor_base =\tUSB_LD_MINOR_BASE,\n};\n\n \nstatic int ld_usb_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(intf);\n\tstruct ld_usb *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tchar *buffer;\n\tint retval = -ENOMEM;\n\tint res;\n\n\t \n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto exit;\n\tmutex_init(&dev->mutex);\n\tspin_lock_init(&dev->rbsl);\n\tdev->intf = intf;\n\tinit_waitqueue_head(&dev->read_wait);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\t \n\tif ((le16_to_cpu(udev->descriptor.idVendor) == USB_VENDOR_ID_LD) &&\n\t    ((le16_to_cpu(udev->descriptor.idProduct) == USB_DEVICE_ID_LD_CASSY) ||\n\t     (le16_to_cpu(udev->descriptor.idProduct) == USB_DEVICE_ID_LD_COM3LAB)) &&\n\t    (le16_to_cpu(udev->descriptor.bcdDevice) <= 0x103)) {\n\t\tbuffer = kmalloc(256, GFP_KERNEL);\n\t\tif (!buffer)\n\t\t\tgoto error;\n\t\t \n\t\tusb_string(udev, 255, buffer, 256);\n\t\tkfree(buffer);\n\t}\n\n\tiface_desc = intf->cur_altsetting;\n\n\tres = usb_find_last_int_in_endpoint(iface_desc,\n\t\t\t&dev->interrupt_in_endpoint);\n\tif (res) {\n\t\tdev_err(&intf->dev, \"Interrupt in endpoint not found\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tres = usb_find_last_int_out_endpoint(iface_desc,\n\t\t\t&dev->interrupt_out_endpoint);\n\tif (res)\n\t\tdev_warn(&intf->dev, \"Interrupt out endpoint not found (using control endpoint instead)\\n\");\n\n\tdev->interrupt_in_endpoint_size = usb_endpoint_maxp(dev->interrupt_in_endpoint);\n\tdev->ring_buffer = kcalloc(ring_buffer_size,\n\t\t\tsizeof(size_t) + dev->interrupt_in_endpoint_size,\n\t\t\tGFP_KERNEL);\n\tif (!dev->ring_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc(dev->interrupt_in_endpoint_size, GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_endpoint_size = dev->interrupt_out_endpoint ? usb_endpoint_maxp(dev->interrupt_out_endpoint) :\n\t\t\t\t\t\t\t\t\t udev->descriptor.bMaxPacketSize0;\n\tdev->interrupt_out_buffer =\n\t\tkmalloc_array(write_buffer_size,\n\t\t\t      dev->interrupt_out_endpoint_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\tdev->interrupt_in_interval = max_t(int, min_interrupt_in_interval,\n\t\t\t\t\t   dev->interrupt_in_endpoint->bInterval);\n\tif (dev->interrupt_out_endpoint)\n\t\tdev->interrupt_out_interval = max_t(int, min_interrupt_out_interval,\n\t\t\t\t\t\t    dev->interrupt_out_endpoint->bInterval);\n\n\t \n\tusb_set_intfdata(intf, dev);\n\n\tretval = usb_register_dev(intf, &ld_usb_class);\n\tif (retval) {\n\t\t \n\t\tdev_err(&intf->dev, \"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(intf, NULL);\n\t\tgoto error;\n\t}\n\n\t \n\tdev_info(&intf->dev, \"LD USB Device #%d now attached to major %d minor %d\\n\",\n\t\t(intf->minor - USB_LD_MINOR_BASE), USB_MAJOR, intf->minor);\n\nexit:\n\treturn retval;\n\nerror:\n\tld_usb_delete(dev);\n\n\treturn retval;\n}\n\n \nstatic void ld_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct ld_usb *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tminor = intf->minor;\n\n\t \n\tusb_deregister_dev(intf, &ld_usb_class);\n\n\tusb_poison_urb(dev->interrupt_in_urb);\n\tusb_poison_urb(dev->interrupt_out_urb);\n\n\tmutex_lock(&dev->mutex);\n\n\t \n\tif (!dev->open_count) {\n\t\tmutex_unlock(&dev->mutex);\n\t\tld_usb_delete(dev);\n\t} else {\n\t\tdev->disconnected = 1;\n\t\t \n\t\twake_up_interruptible_all(&dev->read_wait);\n\t\twake_up_interruptible_all(&dev->write_wait);\n\t\tmutex_unlock(&dev->mutex);\n\t}\n\n\tdev_info(&intf->dev, \"LD USB Device #%d now disconnected\\n\",\n\t\t (minor - USB_LD_MINOR_BASE));\n}\n\n \nstatic struct usb_driver ld_usb_driver = {\n\t.name =\t\t\"ldusb\",\n\t.probe =\tld_usb_probe,\n\t.disconnect =\tld_usb_disconnect,\n\t.id_table =\tld_usb_table,\n};\n\nmodule_usb_driver(ld_usb_driver);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}