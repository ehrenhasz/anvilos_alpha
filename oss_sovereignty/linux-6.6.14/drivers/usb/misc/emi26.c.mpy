{
  "module_name": "emi26.c",
  "hash_id": "9e6bf8be4119b075785bef143baa64da42099b1394f4bf6c66414541b0dcf8ca",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/emi26.c",
  "human_readable_source": "\n \n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/delay.h>\n#include <linux/firmware.h>\n#include <linux/ihex.h>\n\n#define EMI26_VENDOR_ID \t\t0x086a   \n#define EMI26_PRODUCT_ID\t\t0x0100\t \n#define EMI26B_PRODUCT_ID\t\t0x0102\t \n\n#define ANCHOR_LOAD_INTERNAL\t0xA0\t \n#define ANCHOR_LOAD_EXTERNAL\t0xA3\t \n#define ANCHOR_LOAD_FPGA\t0xA5\t \n#define MAX_INTERNAL_ADDRESS\t0x1B3F\t \n#define CPUCS_REG\t\t0x7F92    \n#define INTERNAL_RAM(address)   (address <= MAX_INTERNAL_ADDRESS)\n\nstatic int emi26_writememory( struct usb_device *dev, int address,\n\t\t\t      const unsigned char *data, int length,\n\t\t\t      __u8 bRequest);\nstatic int emi26_set_reset(struct usb_device *dev, unsigned char reset_bit);\nstatic int emi26_load_firmware (struct usb_device *dev);\nstatic int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id);\nstatic void emi26_disconnect(struct usb_interface *intf);\n\n \nstatic int emi26_writememory (struct usb_device *dev, int address,\n\t\t\t      const unsigned char *data, int length,\n\t\t\t      __u8 request)\n{\n\tint result;\n\tunsigned char *buffer =  kmemdup(data, length, GFP_KERNEL);\n\n\tif (!buffer) {\n\t\tdev_err(&dev->dev, \"kmalloc(%d) failed.\\n\", length);\n\t\treturn -ENOMEM;\n\t}\n\t \n\tresult = usb_control_msg (dev, usb_sndctrlpipe(dev, 0), request, 0x40, address, 0, buffer, length, 300);\n\tkfree (buffer);\n\treturn result;\n}\n\n \nstatic int emi26_set_reset (struct usb_device *dev, unsigned char reset_bit)\n{\n\tint response;\n\tdev_info(&dev->dev, \"%s - %d\\n\", __func__, reset_bit);\n\t \n\tresponse = emi26_writememory (dev, CPUCS_REG, &reset_bit, 1, 0xa0);\n\tif (response < 0) {\n\t\tdev_err(&dev->dev, \"set_reset (%d) failed\\n\", reset_bit);\n\t}\n\treturn response;\n}\n\n#define FW_LOAD_SIZE\t\t1023\n\nstatic int emi26_load_firmware (struct usb_device *dev)\n{\n\tconst struct firmware *loader_fw = NULL;\n\tconst struct firmware *bitstream_fw = NULL;\n\tconst struct firmware *firmware_fw = NULL;\n\tconst struct ihex_binrec *rec;\n\tint err = -ENOMEM;\n\tint i;\n\t__u32 addr;\t \n\t__u8 *buf;\n\n\tbuf = kmalloc(FW_LOAD_SIZE, GFP_KERNEL);\n\tif (!buf)\n\t\tgoto wraperr;\n\n\terr = request_ihex_firmware(&loader_fw, \"emi26/loader.fw\", &dev->dev);\n\tif (err)\n\t\tgoto nofw;\n\n\terr = request_ihex_firmware(&bitstream_fw, \"emi26/bitstream.fw\",\n\t\t\t\t    &dev->dev);\n\tif (err)\n\t\tgoto nofw;\n\n\terr = request_ihex_firmware(&firmware_fw, \"emi26/firmware.fw\",\n\t\t\t\t    &dev->dev);\n\tif (err) {\n\tnofw:\n\t\tdev_err(&dev->dev, \"%s - request_firmware() failed\\n\",\n\t\t\t__func__);\n\t\tgoto wraperr;\n\t}\n\n\t \n\terr = emi26_set_reset(dev,1);\n\tif (err < 0)\n\t\tgoto wraperr;\n\n\trec = (const struct ihex_binrec *)loader_fw->data;\n\t \n\twhile (rec) {\n\t\terr = emi26_writememory(dev, be32_to_cpu(rec->addr),\n\t\t\t\t\trec->data, be16_to_cpu(rec->len),\n\t\t\t\t\tANCHOR_LOAD_INTERNAL);\n\t\tif (err < 0)\n\t\t\tgoto wraperr;\n\t\trec = ihex_next_binrec(rec);\n\t}\n\n\t \n\terr = emi26_set_reset(dev,0);\n\tif (err < 0)\n\t\tgoto wraperr;\n\tmsleep(250);\t \n\n\t \n\trec = (const struct ihex_binrec *)bitstream_fw->data;\n\tdo {\n\t\ti = 0;\n\t\taddr = be32_to_cpu(rec->addr);\n\n\t\t \n\t\twhile (rec && (i + be16_to_cpu(rec->len) < FW_LOAD_SIZE)) {\n\t\t\tmemcpy(buf + i, rec->data, be16_to_cpu(rec->len));\n\t\t\ti += be16_to_cpu(rec->len);\n\t\t\trec = ihex_next_binrec(rec);\n\t\t}\n\t\terr = emi26_writememory(dev, addr, buf, i, ANCHOR_LOAD_FPGA);\n\t\tif (err < 0)\n\t\t\tgoto wraperr;\n\t} while (rec);\n\n\t \n\terr = emi26_set_reset(dev,1);\n\tif (err < 0)\n\t\tgoto wraperr;\n\n\t \n\tfor (rec = (const struct ihex_binrec *)loader_fw->data;\n\t     rec; rec = ihex_next_binrec(rec)) {\n\t\terr = emi26_writememory(dev, be32_to_cpu(rec->addr),\n\t\t\t\t\trec->data, be16_to_cpu(rec->len),\n\t\t\t\t\tANCHOR_LOAD_INTERNAL);\n\t\tif (err < 0)\n\t\t\tgoto wraperr;\n\t}\n\tmsleep(250);\t \n\n\t \n\terr = emi26_set_reset(dev,0);\n\tif (err < 0)\n\t\tgoto wraperr;\n\n\t \n\n\tfor (rec = (const struct ihex_binrec *)firmware_fw->data;\n\t     rec; rec = ihex_next_binrec(rec)) {\n\t\tif (!INTERNAL_RAM(be32_to_cpu(rec->addr))) {\n\t\t\terr = emi26_writememory(dev, be32_to_cpu(rec->addr),\n\t\t\t\t\t\trec->data, be16_to_cpu(rec->len),\n\t\t\t\t\t\tANCHOR_LOAD_EXTERNAL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto wraperr;\n\t\t}\n\t}\n\n\t \n\terr = emi26_set_reset(dev,1);\n\tif (err < 0)\n\t\tgoto wraperr;\n\n\tfor (rec = (const struct ihex_binrec *)firmware_fw->data;\n\t     rec; rec = ihex_next_binrec(rec)) {\n\t\tif (INTERNAL_RAM(be32_to_cpu(rec->addr))) {\n\t\t\terr = emi26_writememory(dev, be32_to_cpu(rec->addr),\n\t\t\t\t\t\trec->data, be16_to_cpu(rec->len),\n\t\t\t\t\t\tANCHOR_LOAD_INTERNAL);\n\t\t\tif (err < 0)\n\t\t\t\tgoto wraperr;\n\t\t}\n\t}\n\n\t \n\terr = emi26_set_reset(dev,0);\n\tif (err < 0)\n\t\tgoto wraperr;\n\tmsleep(250);\t \n\n\t \n\terr = 1;\n\nwraperr:\n\tif (err < 0)\n\t\tdev_err(&dev->dev,\"%s - error loading firmware: error = %d\\n\",\n\t\t\t__func__, err);\n\n\trelease_firmware(loader_fw);\n\trelease_firmware(bitstream_fw);\n\trelease_firmware(firmware_fw);\n\n\tkfree(buf);\n\treturn err;\n}\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(EMI26_VENDOR_ID, EMI26_PRODUCT_ID) },\n\t{ USB_DEVICE(EMI26_VENDOR_ID, EMI26B_PRODUCT_ID) },\n\t{ }                                              \n};\n\nMODULE_DEVICE_TABLE (usb, id_table);\n\nstatic int emi26_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\n\tdev_info(&intf->dev, \"%s start\\n\", __func__);\n\n\temi26_load_firmware(dev);\n\n\t \n\treturn -EIO;\n}\n\nstatic void emi26_disconnect(struct usb_interface *intf)\n{\n}\n\nstatic struct usb_driver emi26_driver = {\n\t.name\t\t= \"emi26 - firmware loader\",\n\t.probe\t\t= emi26_probe,\n\t.disconnect\t= emi26_disconnect,\n\t.id_table\t= id_table,\n};\n\nmodule_usb_driver(emi26_driver);\n\nMODULE_AUTHOR(\"Tapio Laxstr\u00f6m\");\nMODULE_DESCRIPTION(\"Emagic EMI 2|6 firmware loader.\");\nMODULE_LICENSE(\"GPL\");\n\nMODULE_FIRMWARE(\"emi26/loader.fw\");\nMODULE_FIRMWARE(\"emi26/bitstream.fw\");\nMODULE_FIRMWARE(\"emi26/firmware.fw\");\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}