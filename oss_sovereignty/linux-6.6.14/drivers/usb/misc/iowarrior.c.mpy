{
  "module_name": "iowarrior.c",
  "hash_id": "878e0b5b6d13802ddb914ca1f12193cce37a9b638099a4c071cce44f285a35b3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/iowarrior.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/usb/iowarrior.h>\n\n#define DRIVER_AUTHOR \"Christian Lucht <lucht@codemercs.com>\"\n#define DRIVER_DESC \"USB IO-Warrior driver\"\n\n#define USB_VENDOR_ID_CODEMERCS\t\t1984\n \n#define USB_DEVICE_ID_CODEMERCS_IOW40\t0x1500\n#define USB_DEVICE_ID_CODEMERCS_IOW24\t0x1501\n#define USB_DEVICE_ID_CODEMERCS_IOWPV1\t0x1511\n#define USB_DEVICE_ID_CODEMERCS_IOWPV2\t0x1512\n \n#define USB_DEVICE_ID_CODEMERCS_IOW56\t0x1503\n \n#define USB_DEVICE_ID_CODEMERCS_IOW28\t0x1504\n#define USB_DEVICE_ID_CODEMERCS_IOW28L\t0x1505\n#define USB_DEVICE_ID_CODEMERCS_IOW100\t0x1506\n\n \n#define USB_DEVICE_ID_CODEMERCS_IOW24SAG\t0x158a\n#define USB_DEVICE_ID_CODEMERCS_IOW56AM\t\t0x158b\n\n \n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define IOWARRIOR_MINOR_BASE\t0\n#else\n#define IOWARRIOR_MINOR_BASE\t208\t\n#endif\n\n \n#define MAX_INTERRUPT_BUFFER 16\n \n#define MAX_WRITES_IN_FLIGHT 4\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic struct usb_driver iowarrior_driver;\n\n \n \n \n\n \nstruct iowarrior {\n\tstruct mutex mutex;\t\t\t \n\tstruct usb_device *udev;\t\t \n\tstruct usb_interface *interface;\t \n\tunsigned char minor;\t\t\t \n\tstruct usb_endpoint_descriptor *int_out_endpoint;\t \n\tstruct usb_endpoint_descriptor *int_in_endpoint;\t \n\tstruct urb *int_in_urb;\t\t \n\tunsigned char *int_in_buffer;\t \n\tunsigned char serial_number;\t \n\tunsigned char *read_queue;\t \n\twait_queue_head_t read_wait;\n\twait_queue_head_t write_wait;\t \n\tatomic_t write_busy;\t\t \n\tatomic_t read_idx;\n\tatomic_t intr_idx;\n\tatomic_t overflow_flag;\t\t \n\tint present;\t\t\t \n\tint opened;\t\t\t \n\tchar chip_serial[9];\t\t \n\tint report_size;\t\t \n\tu16 product_id;\n\tstruct usb_anchor submitted;\n};\n\n \n \n \n\n#define USB_REQ_GET_REPORT  0x01\n\nstatic int usb_get_report(struct usb_device *dev,\n\t\t\t  struct usb_host_interface *inter, unsigned char type,\n\t\t\t  unsigned char id, void *buf, int size)\n{\n\treturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t       USB_REQ_GET_REPORT,\n\t\t\t       USB_DIR_IN | USB_TYPE_CLASS |\n\t\t\t       USB_RECIP_INTERFACE, (type << 8) + id,\n\t\t\t       inter->desc.bInterfaceNumber, buf, size,\n\t\t\t       USB_CTRL_GET_TIMEOUT);\n}\n\n\n#define USB_REQ_SET_REPORT 0x09\n\nstatic int usb_set_report(struct usb_interface *intf, unsigned char type,\n\t\t\t  unsigned char id, void *buf, int size)\n{\n\treturn usb_control_msg(interface_to_usbdev(intf),\n\t\t\t       usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t       USB_REQ_SET_REPORT,\n\t\t\t       USB_TYPE_CLASS | USB_RECIP_INTERFACE,\n\t\t\t       (type << 8) + id,\n\t\t\t       intf->cur_altsetting->desc.bInterfaceNumber, buf,\n\t\t\t       size, 1000);\n}\n\n \n \n \n \nstatic const struct usb_device_id iowarrior_ids[] = {\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW40)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW24)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOWPV1)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOWPV2)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW56)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW24SAG)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW56AM)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW28)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW28L)},\n\t{USB_DEVICE(USB_VENDOR_ID_CODEMERCS, USB_DEVICE_ID_CODEMERCS_IOW100)},\n\t{}\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, iowarrior_ids);\n\n \nstatic void iowarrior_callback(struct urb *urb)\n{\n\tstruct iowarrior *dev = urb->context;\n\tint intr_idx;\n\tint read_idx;\n\tint aux_idx;\n\tint offset;\n\tint status = urb->status;\n\tint retval;\n\n\tswitch (status) {\n\tcase 0:\n\t\t \n\t\tbreak;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\t\treturn;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\tintr_idx = atomic_read(&dev->intr_idx);\n\t \n\taux_idx = (intr_idx == 0) ? (MAX_INTERRUPT_BUFFER - 1) : (intr_idx - 1);\n\tread_idx = atomic_read(&dev->read_idx);\n\n\t \n\tif ((intr_idx != read_idx)\n\t    && (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0)) {\n\t\t \n\t\toffset = aux_idx * (dev->report_size + 1);\n\t\tif (!memcmp\n\t\t    (dev->read_queue + offset, urb->transfer_buffer,\n\t\t     dev->report_size)) {\n\t\t\t \n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t \n\taux_idx = (intr_idx == (MAX_INTERRUPT_BUFFER - 1)) ? 0 : (intr_idx + 1);\n\tif (read_idx == aux_idx) {\n\t\t \n\t\tread_idx = (++read_idx == MAX_INTERRUPT_BUFFER) ? 0 : read_idx;\n\t\tatomic_set(&dev->read_idx, read_idx);\n\t\tatomic_set(&dev->overflow_flag, 1);\n\t}\n\n\t \n\toffset = intr_idx * (dev->report_size + 1);\n\tmemcpy(dev->read_queue + offset, urb->transfer_buffer,\n\t       dev->report_size);\n\t*(dev->read_queue + offset + (dev->report_size)) = dev->serial_number++;\n\n\tatomic_set(&dev->intr_idx, aux_idx);\n\t \n\twake_up_interruptible(&dev->read_wait);\n\nexit:\n\tretval = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (retval)\n\t\tdev_err(&dev->interface->dev, \"%s - usb_submit_urb failed with result %d\\n\",\n\t\t\t__func__, retval);\n\n}\n\n \nstatic void iowarrior_write_callback(struct urb *urb)\n{\n\tstruct iowarrior *dev;\n\tint status = urb->status;\n\n\tdev = urb->context;\n\t \n\tif (status &&\n\t    !(status == -ENOENT ||\n\t      status == -ECONNRESET || status == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\"nonzero write bulk status received: %d\\n\", status);\n\t}\n\t \n\tusb_free_coherent(urb->dev, urb->transfer_buffer_length,\n\t\t\t  urb->transfer_buffer, urb->transfer_dma);\n\t \n\tatomic_dec(&dev->write_busy);\n\twake_up_interruptible(&dev->write_wait);\n}\n\n \nstatic inline void iowarrior_delete(struct iowarrior *dev)\n{\n\tdev_dbg(&dev->interface->dev, \"minor %d\\n\", dev->minor);\n\tkfree(dev->int_in_buffer);\n\tusb_free_urb(dev->int_in_urb);\n\tkfree(dev->read_queue);\n\tusb_put_intf(dev->interface);\n\tkfree(dev);\n}\n\n \n \n \n\nstatic int read_index(struct iowarrior *dev)\n{\n\tint intr_idx, read_idx;\n\n\tread_idx = atomic_read(&dev->read_idx);\n\tintr_idx = atomic_read(&dev->intr_idx);\n\n\treturn (read_idx == intr_idx ? -1 : read_idx);\n}\n\n \nstatic ssize_t iowarrior_read(struct file *file, char __user *buffer,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct iowarrior *dev;\n\tint read_idx;\n\tint offset;\n\n\tdev = file->private_data;\n\n\t \n\tif (!dev || !dev->present)\n\t\treturn -ENODEV;\n\n\tdev_dbg(&dev->interface->dev, \"minor %d, count = %zd\\n\",\n\t\tdev->minor, count);\n\n\t \n\tif ((count != dev->report_size)\n\t    && (count != (dev->report_size + 1)))\n\t\treturn -EINVAL;\n\n\t \n\tdo {\n\t\tatomic_set(&dev->overflow_flag, 0);\n\t\tif ((read_idx = read_index(dev)) == -1) {\n\t\t\t \n\t\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\t\treturn -EAGAIN;\n\t\t\telse {\n\t\t\t\t \n\t\t\t\tint r = wait_event_interruptible(dev->read_wait,\n\t\t\t\t\t\t\t\t (!dev->present\n\t\t\t\t\t\t\t\t  || (read_idx =\n\t\t\t\t\t\t\t\t      read_index\n\t\t\t\t\t\t\t\t      (dev)) !=\n\t\t\t\t\t\t\t\t  -1));\n\t\t\t\tif (r) {\n\t\t\t\t\t \n\t\t\t\t\treturn -ERESTART;\n\t\t\t\t}\n\t\t\t\tif (!dev->present) {\n\t\t\t\t\t \n\t\t\t\t\treturn -ENODEV;\n\t\t\t\t}\n\t\t\t\tif (read_idx == -1) {\n\t\t\t\t\t \n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\toffset = read_idx * (dev->report_size + 1);\n\t\tif (copy_to_user(buffer, dev->read_queue + offset, count)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t} while (atomic_read(&dev->overflow_flag));\n\n\tread_idx = ++read_idx == MAX_INTERRUPT_BUFFER ? 0 : read_idx;\n\tatomic_set(&dev->read_idx, read_idx);\n\treturn count;\n}\n\n \nstatic ssize_t iowarrior_write(struct file *file,\n\t\t\t       const char __user *user_buffer,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct iowarrior *dev;\n\tint retval = 0;\n\tchar *buf = NULL;\t \n\tstruct urb *int_out_urb = NULL;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->mutex);\n\t \n\tif (!dev->present) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\tdev_dbg(&dev->interface->dev, \"minor %d, count = %zd\\n\",\n\t\tdev->minor, count);\n\t \n\tif (count == 0) {\n\t\tretval = 0;\n\t\tgoto exit;\n\t}\n\t \n\tif (count != dev->report_size) {\n\t\tretval = -EINVAL;\n\t\tgoto exit;\n\t}\n\tswitch (dev->product_id) {\n\tcase USB_DEVICE_ID_CODEMERCS_IOW24:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW24SAG:\n\tcase USB_DEVICE_ID_CODEMERCS_IOWPV1:\n\tcase USB_DEVICE_ID_CODEMERCS_IOWPV2:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW40:\n\t\t \n\t\tbuf = memdup_user(user_buffer, count);\n\t\tif (IS_ERR(buf)) {\n\t\t\tretval = PTR_ERR(buf);\n\t\t\tgoto exit;\n\t\t}\n\t\tretval = usb_set_report(dev->interface, 2, 0, buf, count);\n\t\tkfree(buf);\n\t\tgoto exit;\n\tcase USB_DEVICE_ID_CODEMERCS_IOW56:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW56AM:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW28:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW28L:\n\tcase USB_DEVICE_ID_CODEMERCS_IOW100:\n\t\t \n\t\tif (atomic_read(&dev->write_busy) == MAX_WRITES_IN_FLIGHT) {\n\t\t\t \n\t\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\t\tretval = -EAGAIN;\n\t\t\t\tgoto exit;\n\t\t\t} else {\n\t\t\t\tretval = wait_event_interruptible(dev->write_wait,\n\t\t\t\t\t\t\t\t  (!dev->present || (atomic_read (&dev-> write_busy) < MAX_WRITES_IN_FLIGHT)));\n\t\t\t\tif (retval) {\n\t\t\t\t\t \n\t\t\t\t\tretval = -ERESTART;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (!dev->present) {\n\t\t\t\t\t \n\t\t\t\t\tretval = -ENODEV;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif (!dev->opened) {\n\t\t\t\t\t \n\t\t\t\t\tretval = -ENODEV;\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tatomic_inc(&dev->write_busy);\n\t\tint_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!int_out_urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error_no_urb;\n\t\t}\n\t\tbuf = usb_alloc_coherent(dev->udev, dev->report_size,\n\t\t\t\t\t GFP_KERNEL, &int_out_urb->transfer_dma);\n\t\tif (!buf) {\n\t\t\tretval = -ENOMEM;\n\t\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\t\"Unable to allocate buffer\\n\");\n\t\t\tgoto error_no_buffer;\n\t\t}\n\t\tusb_fill_int_urb(int_out_urb, dev->udev,\n\t\t\t\t usb_sndintpipe(dev->udev,\n\t\t\t\t\t\tdev->int_out_endpoint->bEndpointAddress),\n\t\t\t\t buf, dev->report_size,\n\t\t\t\t iowarrior_write_callback, dev,\n\t\t\t\t dev->int_out_endpoint->bInterval);\n\t\tint_out_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\t\tif (copy_from_user(buf, user_buffer, count)) {\n\t\t\tretval = -EFAULT;\n\t\t\tgoto error;\n\t\t}\n\t\tusb_anchor_urb(int_out_urb, &dev->submitted);\n\t\tretval = usb_submit_urb(int_out_urb, GFP_KERNEL);\n\t\tif (retval) {\n\t\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\t\"submit error %d for urb nr.%d\\n\",\n\t\t\t\tretval, atomic_read(&dev->write_busy));\n\t\t\tusb_unanchor_urb(int_out_urb);\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\tretval = count;\n\t\tusb_free_urb(int_out_urb);\n\t\tgoto exit;\n\tdefault:\n\t\t \n\t\tdev_err(&dev->interface->dev, \"%s - not supported for product=0x%x\\n\",\n\t\t\t__func__, dev->product_id);\n\t\tretval = -EFAULT;\n\t\tgoto exit;\n\t}\nerror:\n\tusb_free_coherent(dev->udev, dev->report_size, buf,\n\t\t\t  int_out_urb->transfer_dma);\nerror_no_buffer:\n\tusb_free_urb(int_out_urb);\nerror_no_urb:\n\tatomic_dec(&dev->write_busy);\n\twake_up_interruptible(&dev->write_wait);\nexit:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\n\n \nstatic long iowarrior_ioctl(struct file *file, unsigned int cmd,\n\t\t\t\t\t\t\tunsigned long arg)\n{\n\tstruct iowarrior *dev = NULL;\n\t__u8 *buffer;\n\t__u8 __user *user_buffer;\n\tint retval;\n\tint io_res;\t\t \n\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tbuffer = kzalloc(dev->report_size, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&dev->mutex);\n\n\t \n\tif (!dev->present) {\n\t\tretval = -ENODEV;\n\t\tgoto error_out;\n\t}\n\n\tdev_dbg(&dev->interface->dev, \"minor %d, cmd 0x%.4x, arg %ld\\n\",\n\t\tdev->minor, cmd, arg);\n\n\tretval = 0;\n\tio_res = 0;\n\tswitch (cmd) {\n\tcase IOW_WRITE:\n\t\tif (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW24 ||\n\t\t    dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW24SAG ||\n\t\t    dev->product_id == USB_DEVICE_ID_CODEMERCS_IOWPV1 ||\n\t\t    dev->product_id == USB_DEVICE_ID_CODEMERCS_IOWPV2 ||\n\t\t    dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW40) {\n\t\t\tuser_buffer = (__u8 __user *)arg;\n\t\t\tio_res = copy_from_user(buffer, user_buffer,\n\t\t\t\t\t\tdev->report_size);\n\t\t\tif (io_res) {\n\t\t\t\tretval = -EFAULT;\n\t\t\t} else {\n\t\t\t\tio_res = usb_set_report(dev->interface, 2, 0,\n\t\t\t\t\t\t\tbuffer,\n\t\t\t\t\t\t\tdev->report_size);\n\t\t\t\tif (io_res < 0)\n\t\t\t\t\tretval = io_res;\n\t\t\t}\n\t\t} else {\n\t\t\tretval = -EINVAL;\n\t\t\tdev_err(&dev->interface->dev,\n\t\t\t\t\"ioctl 'IOW_WRITE' is not supported for product=0x%x.\\n\",\n\t\t\t\tdev->product_id);\n\t\t}\n\t\tbreak;\n\tcase IOW_READ:\n\t\tuser_buffer = (__u8 __user *)arg;\n\t\tio_res = usb_get_report(dev->udev,\n\t\t\t\t\tdev->interface->cur_altsetting, 1, 0,\n\t\t\t\t\tbuffer, dev->report_size);\n\t\tif (io_res < 0)\n\t\t\tretval = io_res;\n\t\telse {\n\t\t\tio_res = copy_to_user(user_buffer, buffer, dev->report_size);\n\t\t\tif (io_res)\n\t\t\t\tretval = -EFAULT;\n\t\t}\n\t\tbreak;\n\tcase IOW_GETINFO:\n\t\t{\n\t\t\t \n\t\t\tstruct iowarrior_info info;\n\t\t\t \n\t\t\tstruct usb_config_descriptor *cfg_descriptor = &dev->udev->actconfig->desc;\n\n\t\t\tmemset(&info, 0, sizeof(info));\n\t\t\t \n\t\t\tinfo.vendor = le16_to_cpu(dev->udev->descriptor.idVendor);\n\t\t\tinfo.product = dev->product_id;\n\t\t\tinfo.revision = le16_to_cpu(dev->udev->descriptor.bcdDevice);\n\n\t\t\t \n\t\t\tinfo.speed = dev->udev->speed;\n\t\t\tinfo.if_num = dev->interface->cur_altsetting->desc.bInterfaceNumber;\n\t\t\tinfo.report_size = dev->report_size;\n\n\t\t\t \n\t\t\tmemcpy(info.serial, dev->chip_serial,\n\t\t\t       sizeof(dev->chip_serial));\n\t\t\tif (cfg_descriptor == NULL) {\n\t\t\t\tinfo.power = -1;\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\tinfo.power = cfg_descriptor->bMaxPower * 2;\n\t\t\t}\n\t\t\tio_res = copy_to_user((struct iowarrior_info __user *)arg, &info,\n\t\t\t\t\t sizeof(struct iowarrior_info));\n\t\t\tif (io_res)\n\t\t\t\tretval = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\tdefault:\n\t\t \n\t\tretval = -ENOTTY;\n\t\tbreak;\n\t}\nerror_out:\n\t \n\tmutex_unlock(&dev->mutex);\n\tkfree(buffer);\n\treturn retval;\n}\n\n \nstatic int iowarrior_open(struct inode *inode, struct file *file)\n{\n\tstruct iowarrior *dev = NULL;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&iowarrior_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"%s - error, can't find device for minor %d\\n\",\n\t\t       __func__, subminor);\n\t\treturn -ENODEV;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&dev->mutex);\n\n\t \n\tif (dev->opened) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t \n\tif ((retval = usb_submit_urb(dev->int_in_urb, GFP_KERNEL)) < 0) {\n\t\tdev_err(&interface->dev, \"Error %d while submitting URB\\n\", retval);\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\t \n\t++dev->opened;\n\t \n\tfile->private_data = dev;\n\tretval = 0;\n\nout:\n\tmutex_unlock(&dev->mutex);\n\treturn retval;\n}\n\n \nstatic int iowarrior_release(struct inode *inode, struct file *file)\n{\n\tstruct iowarrior *dev;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\tdev_dbg(&dev->interface->dev, \"minor %d\\n\", dev->minor);\n\n\t \n\tmutex_lock(&dev->mutex);\n\n\tif (dev->opened <= 0) {\n\t\tretval = -ENODEV;\t \n\t\tmutex_unlock(&dev->mutex);\n\t} else {\n\t\tdev->opened = 0;\t \n\t\tretval = 0;\n\t\tif (dev->present) {\n\t\t\t \n\t\t\tusb_kill_urb(dev->int_in_urb);\n\t\t\twake_up_interruptible(&dev->read_wait);\n\t\t\twake_up_interruptible(&dev->write_wait);\n\t\t\tmutex_unlock(&dev->mutex);\n\t\t} else {\n\t\t\t \n\t\t\tmutex_unlock(&dev->mutex);\n\t\t\tiowarrior_delete(dev);\n\t\t}\n\t}\n\treturn retval;\n}\n\nstatic __poll_t iowarrior_poll(struct file *file, poll_table * wait)\n{\n\tstruct iowarrior *dev = file->private_data;\n\t__poll_t mask = 0;\n\n\tif (!dev->present)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\tif (!dev->present)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tif (read_index(dev) != -1)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\n\tif (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\treturn mask;\n}\n\n \nstatic const struct file_operations iowarrior_fops = {\n\t.owner = THIS_MODULE,\n\t.write = iowarrior_write,\n\t.read = iowarrior_read,\n\t.unlocked_ioctl = iowarrior_ioctl,\n\t.open = iowarrior_open,\n\t.release = iowarrior_release,\n\t.poll = iowarrior_poll,\n\t.llseek = noop_llseek,\n};\n\nstatic char *iowarrior_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\n \nstatic struct usb_class_driver iowarrior_class = {\n\t.name = \"iowarrior%d\",\n\t.devnode = iowarrior_devnode,\n\t.fops = &iowarrior_fops,\n\t.minor_base = IOWARRIOR_MINOR_BASE,\n};\n\n \n \n \n \nstatic int iowarrior_probe(struct usb_interface *interface,\n\t\t\t   const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct iowarrior *dev = NULL;\n\tstruct usb_host_interface *iface_desc;\n\tint retval = -ENOMEM;\n\tint res;\n\n\t \n\tdev = kzalloc(sizeof(struct iowarrior), GFP_KERNEL);\n\tif (!dev)\n\t\treturn retval;\n\n\tmutex_init(&dev->mutex);\n\n\tatomic_set(&dev->intr_idx, 0);\n\tatomic_set(&dev->read_idx, 0);\n\tatomic_set(&dev->overflow_flag, 0);\n\tinit_waitqueue_head(&dev->read_wait);\n\tatomic_set(&dev->write_busy, 0);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\tdev->udev = udev;\n\tdev->interface = usb_get_intf(interface);\n\n\tiface_desc = interface->cur_altsetting;\n\tdev->product_id = le16_to_cpu(udev->descriptor.idProduct);\n\n\tinit_usb_anchor(&dev->submitted);\n\n\tres = usb_find_last_int_in_endpoint(iface_desc, &dev->int_in_endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, \"no interrupt-in endpoint found\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tif ((dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW56) ||\n\t    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW56AM) ||\n\t    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW28) ||\n\t    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW28L) ||\n\t    (dev->product_id == USB_DEVICE_ID_CODEMERCS_IOW100)) {\n\t\tres = usb_find_last_int_out_endpoint(iface_desc,\n\t\t\t\t&dev->int_out_endpoint);\n\t\tif (res) {\n\t\t\tdev_err(&interface->dev, \"no interrupt-out endpoint found\\n\");\n\t\t\tretval = res;\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t \n\tdev->report_size = usb_endpoint_maxp(dev->int_in_endpoint);\n\n\t \n\tif (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t\tswitch (dev->product_id) {\n\t\tcase USB_DEVICE_ID_CODEMERCS_IOW56:\n\t\tcase USB_DEVICE_ID_CODEMERCS_IOW56AM:\n\t\t\tdev->report_size = 7;\n\t\t\tbreak;\n\n\t\tcase USB_DEVICE_ID_CODEMERCS_IOW28:\n\t\tcase USB_DEVICE_ID_CODEMERCS_IOW28L:\n\t\t\tdev->report_size = 4;\n\t\t\tbreak;\n\n\t\tcase USB_DEVICE_ID_CODEMERCS_IOW100:\n\t\t\tdev->report_size = 12;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tdev->int_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->int_in_urb)\n\t\tgoto error;\n\tdev->int_in_buffer = kmalloc(dev->report_size, GFP_KERNEL);\n\tif (!dev->int_in_buffer)\n\t\tgoto error;\n\tusb_fill_int_urb(dev->int_in_urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev,\n\t\t\t\t\tdev->int_in_endpoint->bEndpointAddress),\n\t\t\t dev->int_in_buffer, dev->report_size,\n\t\t\t iowarrior_callback, dev,\n\t\t\t dev->int_in_endpoint->bInterval);\n\t \n\tdev->read_queue =\n\t    kmalloc_array(dev->report_size + 1, MAX_INTERRUPT_BUFFER,\n\t\t\t  GFP_KERNEL);\n\tif (!dev->read_queue)\n\t\tgoto error;\n\t \n\tmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\n\tusb_string(udev, udev->descriptor.iSerialNumber, dev->chip_serial,\n\t\t   sizeof(dev->chip_serial));\n\tif (strlen(dev->chip_serial) != 8)\n\t\tmemset(dev->chip_serial, 0x00, sizeof(dev->chip_serial));\n\n\t \n\tif (dev->interface->cur_altsetting->desc.bInterfaceNumber == 0) {\n\t    usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t    0x0A,\n\t\t\t    USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0,\n\t\t\t    0, NULL, 0, USB_CTRL_SET_TIMEOUT);\n\t}\n\t \n\tdev->present = 1;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\tretval = usb_register_dev(interface, &iowarrior_class);\n\tif (retval) {\n\t\t \n\t\tdev_err(&interface->dev, \"Not able to get a minor for this device.\\n\");\n\t\tgoto error;\n\t}\n\n\tdev->minor = interface->minor;\n\n\t \n\tdev_info(&interface->dev, \"IOWarrior product=0x%x, serial=%s interface=%d \"\n\t\t \"now attached to iowarrior%d\\n\", dev->product_id, dev->chip_serial,\n\t\t iface_desc->desc.bInterfaceNumber, dev->minor - IOWARRIOR_MINOR_BASE);\n\treturn retval;\n\nerror:\n\tiowarrior_delete(dev);\n\treturn retval;\n}\n\n \nstatic void iowarrior_disconnect(struct usb_interface *interface)\n{\n\tstruct iowarrior *dev = usb_get_intfdata(interface);\n\tint minor = dev->minor;\n\n\tusb_deregister_dev(interface, &iowarrior_class);\n\n\tmutex_lock(&dev->mutex);\n\n\t \n\tdev->present = 0;\n\n\tif (dev->opened) {\n\t\t \n\t\tusb_kill_urb(dev->int_in_urb);\n\t\tusb_kill_anchored_urbs(&dev->submitted);\n\t\twake_up_interruptible(&dev->read_wait);\n\t\twake_up_interruptible(&dev->write_wait);\n\t\tmutex_unlock(&dev->mutex);\n\t} else {\n\t\t \n\t\tmutex_unlock(&dev->mutex);\n\t\tiowarrior_delete(dev);\n\t}\n\n\tdev_info(&interface->dev, \"I/O-Warror #%d now disconnected\\n\",\n\t\t minor - IOWARRIOR_MINOR_BASE);\n}\n\n \nstatic struct usb_driver iowarrior_driver = {\n\t.name = \"iowarrior\",\n\t.probe = iowarrior_probe,\n\t.disconnect = iowarrior_disconnect,\n\t.id_table = iowarrior_ids,\n};\n\nmodule_usb_driver(iowarrior_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}