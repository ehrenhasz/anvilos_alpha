{
  "module_name": "yurex.c",
  "hash_id": "614d46b565ac8b0adf8bd46dd6eac4bc2a55346bbfd08fc0715b2f4317c32a7a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/yurex.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/kref.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/hid.h>\n\n#define DRIVER_AUTHOR \"Tomoki Sekiyama\"\n#define DRIVER_DESC \"Driver for Meywa-Denki & KAYAC YUREX\"\n\n#define YUREX_VENDOR_ID\t\t0x0c45\n#define YUREX_PRODUCT_ID\t0x1010\n\n#define CMD_ACK\t\t'!'\n#define CMD_ANIMATE\t'A'\n#define CMD_COUNT\t'C'\n#define CMD_LED\t\t'L'\n#define CMD_READ\t'R'\n#define CMD_SET\t\t'S'\n#define CMD_VERSION\t'V'\n#define CMD_EOF\t\t0x0d\n#define CMD_PADDING\t0xff\n\n#define YUREX_BUF_SIZE\t\t8\n#define YUREX_WRITE_TIMEOUT\t(HZ*2)\n\n \nstatic struct usb_device_id yurex_table[] = {\n\t{ USB_DEVICE(YUREX_VENDOR_ID, YUREX_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, yurex_table);\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define YUREX_MINOR_BASE\t0\n#else\n#define YUREX_MINOR_BASE\t192\n#endif\n\n \nstruct usb_yurex {\n\tstruct usb_device\t*udev;\n\tstruct usb_interface\t*interface;\n\t__u8\t\t\tint_in_endpointAddr;\n\tstruct urb\t\t*urb;\t\t \n\tunsigned char           *int_buffer;\t \n\tstruct urb\t\t*cntl_urb;\t \n\tstruct usb_ctrlrequest\t*cntl_req;\t \n\tunsigned char\t\t*cntl_buffer;\t \n\n\tstruct kref\t\tkref;\n\tstruct mutex\t\tio_mutex;\n\tunsigned long\t\tdisconnected:1;\n\tstruct fasync_struct\t*async_queue;\n\twait_queue_head_t\twaitq;\n\n\tspinlock_t\t\tlock;\n\t__s64\t\t\tbbu;\t\t \n};\n#define to_yurex_dev(d) container_of(d, struct usb_yurex, kref)\n\nstatic struct usb_driver yurex_driver;\nstatic const struct file_operations yurex_fops;\n\n\nstatic void yurex_control_callback(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tint status = urb->status;\n\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"%s - control failed: %d\\n\",\n\t\t\t__func__, status);\n\t\twake_up_interruptible(&dev->waitq);\n\t\treturn;\n\t}\n\t \n}\n\nstatic void yurex_delete(struct kref *kref)\n{\n\tstruct usb_yurex *dev = to_yurex_dev(kref);\n\n\tdev_dbg(&dev->interface->dev, \"%s\\n\", __func__);\n\n\tif (dev->cntl_urb) {\n\t\tusb_kill_urb(dev->cntl_urb);\n\t\tkfree(dev->cntl_req);\n\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->cntl_buffer, dev->cntl_urb->transfer_dma);\n\t\tusb_free_urb(dev->cntl_urb);\n\t}\n\tif (dev->urb) {\n\t\tusb_kill_urb(dev->urb);\n\t\tusb_free_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\tdev->int_buffer, dev->urb->transfer_dma);\n\t\tusb_free_urb(dev->urb);\n\t}\n\tusb_put_intf(dev->interface);\n\tusb_put_dev(dev->udev);\n\tkfree(dev);\n}\n\n \nstatic struct usb_class_driver yurex_class = {\n\t.name =\t\t\"yurex%d\",\n\t.fops =\t\t&yurex_fops,\n\t.minor_base =\tYUREX_MINOR_BASE,\n};\n\nstatic void yurex_interrupt(struct urb *urb)\n{\n\tstruct usb_yurex *dev = urb->context;\n\tunsigned char *buf = dev->int_buffer;\n\tint status = urb->status;\n\tunsigned long flags;\n\tint retval, i;\n\n\tswitch (status) {\n\tcase 0:  \n\t\tbreak;\n\t \n\tcase -EOVERFLOW:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - overflow with length %d, actual length is %d\\n\",\n\t\t\t__func__, YUREX_BUF_SIZE, dev->urb->actual_length);\n\t\treturn;\n\tcase -ECONNRESET:\n\tcase -ENOENT:\n\tcase -ESHUTDOWN:\n\tcase -EILSEQ:\n\tcase -EPROTO:\n\tcase -ETIME:\n\t\treturn;\n\tdefault:\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - unknown status received: %d\\n\", __func__, status);\n\t\treturn;\n\t}\n\n\t \n\tswitch (buf[0]) {\n\tcase CMD_COUNT:\n\tcase CMD_READ:\n\t\tif (buf[6] == CMD_EOF) {\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tdev->bbu = 0;\n\t\t\tfor (i = 1; i < 6; i++) {\n\t\t\t\tdev->bbu += buf[i];\n\t\t\t\tif (i != 5)\n\t\t\t\t\tdev->bbu <<= 8;\n\t\t\t}\n\t\t\tdev_dbg(&dev->interface->dev, \"%s count: %lld\\n\",\n\t\t\t\t__func__, dev->bbu);\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\t\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\t\t}\n\t\telse\n\t\t\tdev_dbg(&dev->interface->dev,\n\t\t\t\t\"data format error - no EOF\\n\");\n\t\tbreak;\n\tcase CMD_ACK:\n\t\tdev_dbg(&dev->interface->dev, \"%s ack: %c\\n\",\n\t\t\t__func__, buf[1]);\n\t\twake_up_interruptible(&dev->waitq);\n\t\tbreak;\n\t}\n\n\tretval = usb_submit_urb(dev->urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&dev->interface->dev, \"%s - usb_submit_urb failed: %d\\n\",\n\t\t\t__func__, retval);\n\t}\n}\n\nstatic int yurex_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint retval = -ENOMEM;\n\tDEFINE_WAIT(wait);\n\tint res;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error;\n\tkref_init(&dev->kref);\n\tmutex_init(&dev->io_mutex);\n\tspin_lock_init(&dev->lock);\n\tinit_waitqueue_head(&dev->waitq);\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\tdev->interface = usb_get_intf(interface);\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\tres = usb_find_int_in_endpoint(iface_desc, &endpoint);\n\tif (res) {\n\t\tdev_err(&interface->dev, \"Could not find endpoints\\n\");\n\t\tretval = res;\n\t\tgoto error;\n\t}\n\n\tdev->int_in_endpointAddr = endpoint->bEndpointAddress;\n\n\t \n\tdev->cntl_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->cntl_urb)\n\t\tgoto error;\n\n\t \n\tdev->cntl_req = kmalloc(YUREX_BUF_SIZE, GFP_KERNEL);\n\tif (!dev->cntl_req)\n\t\tgoto error;\n\n\t \n\tdev->cntl_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\t      GFP_KERNEL,\n\t\t\t\t\t      &dev->cntl_urb->transfer_dma);\n\tif (!dev->cntl_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate cntl_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tdev->cntl_req->bRequestType = USB_DIR_OUT | USB_TYPE_CLASS |\n\t\t\t\t      USB_RECIP_INTERFACE;\n\tdev->cntl_req->bRequest\t= HID_REQ_SET_REPORT;\n\tdev->cntl_req->wValue\t= cpu_to_le16((HID_OUTPUT_REPORT + 1) << 8);\n\tdev->cntl_req->wIndex\t= cpu_to_le16(iface_desc->desc.bInterfaceNumber);\n\tdev->cntl_req->wLength\t= cpu_to_le16(YUREX_BUF_SIZE);\n\n\tusb_fill_control_urb(dev->cntl_urb, dev->udev,\n\t\t\t     usb_sndctrlpipe(dev->udev, 0),\n\t\t\t     (void *)dev->cntl_req, dev->cntl_buffer,\n\t\t\t     YUREX_BUF_SIZE, yurex_control_callback, dev);\n\tdev->cntl_urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\n\n\t \n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->urb)\n\t\tgoto error;\n\n\t \n\tdev->int_buffer = usb_alloc_coherent(dev->udev, YUREX_BUF_SIZE,\n\t\t\t\t\tGFP_KERNEL, &dev->urb->transfer_dma);\n\tif (!dev->int_buffer) {\n\t\tdev_err(&interface->dev, \"Could not allocate int_buffer\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tusb_fill_int_urb(dev->urb, dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, dev->int_in_endpointAddr),\n\t\t\t dev->int_buffer, YUREX_BUF_SIZE, yurex_interrupt,\n\t\t\t dev, 1);\n\tdev->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tif (usb_submit_urb(dev->urb, GFP_KERNEL)) {\n\t\tretval = -EIO;\n\t\tdev_err(&interface->dev, \"Could not submitting URB\\n\");\n\t\tgoto error;\n\t}\n\n\t \n\tusb_set_intfdata(interface, dev);\n\tdev->bbu = -1;\n\n\t \n\tretval = usb_register_dev(interface, &yurex_class);\n\tif (retval) {\n\t\tdev_err(&interface->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tusb_set_intfdata(interface, NULL);\n\t\tgoto error;\n\t}\n\n\tdev_info(&interface->dev,\n\t\t \"USB YUREX device now attached to Yurex #%d\\n\",\n\t\t interface->minor);\n\n\treturn 0;\n\nerror:\n\tif (dev)\n\t\t \n\t\tkref_put(&dev->kref, yurex_delete);\n\treturn retval;\n}\n\nstatic void yurex_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_yurex *dev;\n\tint minor = interface->minor;\n\n\tdev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\n\t \n\tusb_deregister_dev(interface, &yurex_class);\n\n\t \n\tusb_poison_urb(dev->urb);\n\tusb_poison_urb(dev->cntl_urb);\n\tmutex_lock(&dev->io_mutex);\n\tdev->disconnected = 1;\n\tmutex_unlock(&dev->io_mutex);\n\n\t \n\tkill_fasync(&dev->async_queue, SIGIO, POLL_IN);\n\twake_up_interruptible(&dev->waitq);\n\n\t \n\tkref_put(&dev->kref, yurex_delete);\n\n\tdev_info(&interface->dev, \"USB YUREX #%d now disconnected\\n\", minor);\n}\n\nstatic struct usb_driver yurex_driver = {\n\t.name =\t\t\"yurex\",\n\t.probe =\tyurex_probe,\n\t.disconnect =\tyurex_disconnect,\n\t.id_table =\tyurex_table,\n};\n\n\nstatic int yurex_fasync(int fd, struct file *file, int on)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\treturn fasync_helper(fd, file, on, &dev->async_queue);\n}\n\nstatic int yurex_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\tstruct usb_interface *interface;\n\tint subminor;\n\tint retval = 0;\n\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&yurex_driver, subminor);\n\tif (!interface) {\n\t\tprintk(KERN_ERR \"%s - error, can't find device for minor %d\",\n\t\t       __func__, subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tkref_get(&dev->kref);\n\n\t \n\tmutex_lock(&dev->io_mutex);\n\tfile->private_data = dev;\n\tmutex_unlock(&dev->io_mutex);\n\nexit:\n\treturn retval;\n}\n\nstatic int yurex_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_yurex *dev;\n\n\tdev = file->private_data;\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tkref_put(&dev->kref, yurex_delete);\n\treturn 0;\n}\n\nstatic ssize_t yurex_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint len = 0;\n\tchar in_buffer[20];\n\tunsigned long flags;\n\n\tdev = file->private_data;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (dev->disconnected) {\t\t \n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -ENODEV;\n\t}\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\tlen = snprintf(in_buffer, 20, \"%lld\\n\", dev->bbu);\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\tmutex_unlock(&dev->io_mutex);\n\n\tif (WARN_ON_ONCE(len >= sizeof(in_buffer)))\n\t\treturn -EIO;\n\n\treturn simple_read_from_buffer(buffer, count, ppos, in_buffer, len);\n}\n\nstatic ssize_t yurex_write(struct file *file, const char __user *user_buffer,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tstruct usb_yurex *dev;\n\tint i, set = 0, retval = 0;\n\tchar buffer[16 + 1];\n\tchar *data = buffer;\n\tunsigned long long c, c2 = 0;\n\tsigned long timeout = 0;\n\tDEFINE_WAIT(wait);\n\n\tcount = min(sizeof(buffer) - 1, count);\n\tdev = file->private_data;\n\n\t \n\tif (count == 0)\n\t\tgoto error;\n\n\tmutex_lock(&dev->io_mutex);\n\tif (dev->disconnected) {\t\t \n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -ENODEV;\n\t\tgoto error;\n\t}\n\n\tif (copy_from_user(buffer, user_buffer, count)) {\n\t\tmutex_unlock(&dev->io_mutex);\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tbuffer[count] = 0;\n\tmemset(dev->cntl_buffer, CMD_PADDING, YUREX_BUF_SIZE);\n\n\tswitch (buffer[0]) {\n\tcase CMD_ANIMATE:\n\tcase CMD_LED:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = buffer[1];\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_READ:\n\tcase CMD_VERSION:\n\t\tdev->cntl_buffer[0] = buffer[0];\n\t\tdev->cntl_buffer[1] = 0x00;\n\t\tdev->cntl_buffer[2] = CMD_EOF;\n\t\tbreak;\n\tcase CMD_SET:\n\t\tdata++;\n\t\tfallthrough;\n\tcase '0' ... '9':\n\t\tset = 1;\n\t\tc = c2 = simple_strtoull(data, NULL, 0);\n\t\tdev->cntl_buffer[0] = CMD_SET;\n\t\tfor (i = 1; i < 6; i++) {\n\t\t\tdev->cntl_buffer[i] = (c>>32) & 0xff;\n\t\t\tc <<= 8;\n\t\t}\n\t\tbuffer[6] = CMD_EOF;\n\t\tbreak;\n\tdefault:\n\t\tmutex_unlock(&dev->io_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tprepare_to_wait(&dev->waitq, &wait, TASK_INTERRUPTIBLE);\n\tdev_dbg(&dev->interface->dev, \"%s - submit %c\\n\", __func__,\n\t\tdev->cntl_buffer[0]);\n\tretval = usb_submit_urb(dev->cntl_urb, GFP_ATOMIC);\n\tif (retval >= 0)\n\t\ttimeout = schedule_timeout(YUREX_WRITE_TIMEOUT);\n\tfinish_wait(&dev->waitq, &wait);\n\n\t \n\tusb_kill_urb(dev->cntl_urb);\n\n\tmutex_unlock(&dev->io_mutex);\n\n\tif (retval < 0) {\n\t\tdev_err(&dev->interface->dev,\n\t\t\t\"%s - failed to send bulk msg, error %d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto error;\n\t}\n\tif (set && timeout)\n\t\tdev->bbu = c2;\n\treturn timeout ? count : -EIO;\n\nerror:\n\treturn retval;\n}\n\nstatic const struct file_operations yurex_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read =\t\tyurex_read,\n\t.write =\tyurex_write,\n\t.open =\t\tyurex_open,\n\t.release =\tyurex_release,\n\t.fasync\t=\tyurex_fasync,\n\t.llseek =\tdefault_llseek,\n};\n\nmodule_usb_driver(yurex_driver);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}