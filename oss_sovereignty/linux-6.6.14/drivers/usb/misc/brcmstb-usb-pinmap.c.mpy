{
  "module_name": "brcmstb-usb-pinmap.c",
  "hash_id": "2f25b4d056e4e2cfcb3d9ce1b6af0bcb20cc091a6aa38be4d87bb39288562acd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/brcmstb-usb-pinmap.c",
  "human_readable_source": "\n \n\n#include <linux/init.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/device.h>\n#include <linux/of.h>\n#include <linux/kernel.h>\n#include <linux/kdebug.h>\n#include <linux/gpio/consumer.h>\n\nstruct out_pin {\n\tu32 enable_mask;\n\tu32 value_mask;\n\tu32 changed_mask;\n\tu32 clr_changed_mask;\n\tstruct gpio_desc *gpiod;\n\tconst char *name;\n};\n\nstruct in_pin {\n\tu32 enable_mask;\n\tu32 value_mask;\n\tstruct gpio_desc *gpiod;\n\tconst char *name;\n\tstruct brcmstb_usb_pinmap_data *pdata;\n};\n\nstruct brcmstb_usb_pinmap_data {\n\tvoid __iomem *regs;\n\tint in_count;\n\tstruct in_pin *in_pins;\n\tint out_count;\n\tstruct out_pin *out_pins;\n};\n\n\nstatic void pinmap_set(void __iomem *reg, u32 mask)\n{\n\tu32 val;\n\n\tval = readl(reg);\n\tval |= mask;\n\twritel(val, reg);\n}\n\nstatic void pinmap_unset(void __iomem *reg, u32 mask)\n{\n\tu32 val;\n\n\tval = readl(reg);\n\tval &= ~mask;\n\twritel(val, reg);\n}\n\nstatic void sync_in_pin(struct in_pin *pin)\n{\n\tu32 val;\n\n\tval = gpiod_get_value(pin->gpiod);\n\tif (val)\n\t\tpinmap_set(pin->pdata->regs, pin->value_mask);\n\telse\n\t\tpinmap_unset(pin->pdata->regs, pin->value_mask);\n}\n\n \nstatic irqreturn_t brcmstb_usb_pinmap_ovr_isr(int irq, void *dev_id)\n{\n\tstruct brcmstb_usb_pinmap_data *pdata = dev_id;\n\tstruct out_pin *pout;\n\tu32 val;\n\tu32 bit;\n\tint x;\n\n\tpr_debug(\"%s: reg: 0x%x\\n\", __func__, readl(pdata->regs));\n\tpout = pdata->out_pins;\n\tfor (x = 0; x < pdata->out_count; x++) {\n\t\tval = readl(pdata->regs);\n\t\tif (val & pout->changed_mask) {\n\t\t\tpinmap_set(pdata->regs, pout->clr_changed_mask);\n\t\t\tpinmap_unset(pdata->regs, pout->clr_changed_mask);\n\t\t\tbit = val & pout->value_mask;\n\t\t\tgpiod_set_value(pout->gpiod, bit ? 1 : 0);\n\t\t\tpr_debug(\"%s: %s bit changed state to %d\\n\",\n\t\t\t\t __func__, pout->name, bit ? 1 : 0);\n\t\t}\n\t}\n\treturn IRQ_HANDLED;\n}\n\n \nstatic irqreturn_t brcmstb_usb_pinmap_gpio_isr(int irq, void *dev_id)\n{\n\tstruct in_pin *pin = dev_id;\n\n\tpr_debug(\"%s: %s pin changed state\\n\", __func__, pin->name);\n\tsync_in_pin(pin);\n\treturn IRQ_HANDLED;\n}\n\n\nstatic void get_pin_counts(struct device_node *dn, int *in_count,\n\t\t\t   int *out_count)\n{\n\tint in;\n\tint out;\n\n\t*in_count = 0;\n\t*out_count = 0;\n\tin = of_property_count_strings(dn, \"brcm,in-functions\");\n\tif (in < 0)\n\t\treturn;\n\tout = of_property_count_strings(dn, \"brcm,out-functions\");\n\tif (out < 0)\n\t\treturn;\n\t*in_count = in;\n\t*out_count = out;\n}\n\nstatic int parse_pins(struct device *dev, struct device_node *dn,\n\t\t      struct brcmstb_usb_pinmap_data *pdata)\n{\n\tstruct out_pin *pout;\n\tstruct in_pin *pin;\n\tint index;\n\tint res;\n\tint x;\n\n\tpin = pdata->in_pins;\n\tfor (x = 0, index = 0; x < pdata->in_count; x++) {\n\t\tpin->gpiod = devm_gpiod_get_index(dev, \"in\", x, GPIOD_IN);\n\t\tif (IS_ERR(pin->gpiod)) {\n\t\t\tdev_err(dev, \"Error getting gpio %s\\n\", pin->name);\n\t\t\treturn PTR_ERR(pin->gpiod);\n\n\t\t}\n\t\tres = of_property_read_string_index(dn, \"brcm,in-functions\", x,\n\t\t\t\t\t\t    &pin->name);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting brcm,in-functions for %s\\n\",\n\t\t\t\tpin->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,in-masks\", index++,\n\t\t\t\t\t\t &pin->enable_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 1st brcm,in-masks for %s\\n\",\n\t\t\t\tpin->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,in-masks\", index++,\n\t\t\t\t\t\t &pin->value_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 2nd brcm,in-masks for %s\\n\",\n\t\t\t\tpin->name);\n\t\t\treturn res;\n\t\t}\n\t\tpin->pdata = pdata;\n\t\tpin++;\n\t}\n\tpout = pdata->out_pins;\n\tfor (x = 0, index = 0; x < pdata->out_count; x++) {\n\t\tpout->gpiod = devm_gpiod_get_index(dev, \"out\", x,\n\t\t\t\t\t\t   GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(pout->gpiod)) {\n\t\t\tdev_err(dev, \"Error getting gpio %s\\n\", pin->name);\n\t\t\treturn PTR_ERR(pout->gpiod);\n\t\t}\n\t\tres = of_property_read_string_index(dn, \"brcm,out-functions\", x,\n\t\t\t\t\t\t    &pout->name);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting brcm,out-functions for %s\\n\",\n\t\t\t\tpout->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,out-masks\", index++,\n\t\t\t\t\t\t &pout->enable_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 1st brcm,out-masks for %s\\n\",\n\t\t\t\tpout->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,out-masks\", index++,\n\t\t\t\t\t\t &pout->value_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 2nd brcm,out-masks for %s\\n\",\n\t\t\t\tpout->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,out-masks\", index++,\n\t\t\t\t\t\t &pout->changed_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 3rd brcm,out-masks for %s\\n\",\n\t\t\t\tpout->name);\n\t\t\treturn res;\n\t\t}\n\t\tres = of_property_read_u32_index(dn, \"brcm,out-masks\", index++,\n\t\t\t\t\t\t &pout->clr_changed_mask);\n\t\tif (res < 0) {\n\t\t\tdev_err(dev, \"Error getting 4th out-masks for %s\\n\",\n\t\t\t\tpout->name);\n\t\t\treturn res;\n\t\t}\n\t\tpout++;\n\t}\n\treturn 0;\n}\n\nstatic void sync_all_pins(struct brcmstb_usb_pinmap_data *pdata)\n{\n\tstruct out_pin *pout;\n\tstruct in_pin *pin;\n\tint val;\n\tint x;\n\n\t \n\tpout = pdata->out_pins;\n\tfor (x = 0; x < pdata->out_count; x++) {\n\t\tpinmap_set(pdata->regs, pout->enable_mask);\n\t\tpinmap_set(pdata->regs, pout->clr_changed_mask);\n\t\tpinmap_unset(pdata->regs, pout->clr_changed_mask);\n\t\tval = readl(pdata->regs) & pout->value_mask;\n\t\tgpiod_set_value(pout->gpiod, val ? 1 : 0);\n\t\tpout++;\n\t}\n\n\t \n\tpin = pdata->in_pins;\n\tfor (x = 0; x < pdata->in_count; x++) {\n\t\tsync_in_pin(pin);\n\t\tpinmap_set(pdata->regs, pin->enable_mask);\n\t\tpin++;\n\t}\n}\n\nstatic int __init brcmstb_usb_pinmap_probe(struct platform_device *pdev)\n{\n\tstruct device_node *dn = pdev->dev.of_node;\n\tstruct brcmstb_usb_pinmap_data *pdata;\n\tstruct in_pin *pin;\n\tstruct resource *r;\n\tint out_count;\n\tint in_count;\n\tint err;\n\tint irq;\n\tint x;\n\n\tget_pin_counts(dn, &in_count, &out_count);\n\tif ((in_count + out_count) == 0)\n\t\treturn -EINVAL;\n\n\tr = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!r)\n\t\treturn -EINVAL;\n\n\tpdata = devm_kzalloc(&pdev->dev,\n\t\t\t     sizeof(*pdata) +\n\t\t\t     (sizeof(struct in_pin) * in_count) +\n\t\t\t     (sizeof(struct out_pin) * out_count), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdata->in_count = in_count;\n\tpdata->out_count = out_count;\n\tpdata->in_pins = (struct in_pin *)(pdata + 1);\n\tpdata->out_pins = (struct out_pin *)(pdata->in_pins + in_count);\n\n\tpdata->regs = devm_ioremap(&pdev->dev, r->start, resource_size(r));\n\tif (!pdata->regs)\n\t\treturn -ENOMEM;\n\tplatform_set_drvdata(pdev, pdata);\n\n\terr = parse_pins(&pdev->dev, dn, pdata);\n\tif (err)\n\t\treturn err;\n\n\tsync_all_pins(pdata);\n\n\tif (out_count) {\n\n\t\t \n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t\terr = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t       brcmstb_usb_pinmap_ovr_isr,\n\t\t\t\t       IRQF_TRIGGER_RISING,\n\t\t\t\t       pdev->name, pdata);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error requesting IRQ\\n\");\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tfor (x = 0, pin = pdata->in_pins; x < pdata->in_count; x++, pin++) {\n\t\tirq = gpiod_to_irq(pin->gpiod);\n\t\tif (irq < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error getting IRQ for %s pin\\n\",\n\t\t\t\tpin->name);\n\t\t\treturn irq;\n\t\t}\n\t\terr = devm_request_irq(&pdev->dev, irq,\n\t\t\t\t       brcmstb_usb_pinmap_gpio_isr,\n\t\t\t\t       IRQF_SHARED | IRQF_TRIGGER_RISING |\n\t\t\t\t       IRQF_TRIGGER_FALLING,\n\t\t\t\t       pdev->name, pin);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"Error requesting IRQ for %s pin\\n\",\n\t\t\t\tpin->name);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tdev_dbg(&pdev->dev, \"Driver probe succeeded\\n\");\n\tdev_dbg(&pdev->dev, \"In pin count: %d, out pin count: %d\\n\",\n\t\tpdata->in_count, pdata->out_count);\n\treturn 0;\n}\n\n\nstatic const struct of_device_id brcmstb_usb_pinmap_of_match[] = {\n\t{ .compatible = \"brcm,usb-pinmap\" },\n\t{ },\n};\n\nstatic struct platform_driver brcmstb_usb_pinmap_driver = {\n\t.driver = {\n\t\t.name\t= \"brcm-usb-pinmap\",\n\t\t.of_match_table = brcmstb_usb_pinmap_of_match,\n\t},\n};\n\nstatic int __init brcmstb_usb_pinmap_init(void)\n{\n\treturn platform_driver_probe(&brcmstb_usb_pinmap_driver,\n\t\t\t\t     brcmstb_usb_pinmap_probe);\n}\n\nmodule_init(brcmstb_usb_pinmap_init);\nMODULE_AUTHOR(\"Al Cooper <alcooperx@gmail.com>\");\nMODULE_DESCRIPTION(\"Broadcom USB Pinmap Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}