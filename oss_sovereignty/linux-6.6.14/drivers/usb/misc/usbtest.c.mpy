{
  "module_name": "usbtest.c",
  "hash_id": "11056af9a13d9f2c2dfbf4da07af8c1a81ab667042e301513d636c7cb8586eaa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/usbtest.c",
  "human_readable_source": "\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/scatterlist.h>\n#include <linux/mutex.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n\n#define SIMPLE_IO_TIMEOUT\t10000\t \n\n \n\nstatic int override_alt = -1;\nmodule_param_named(alt, override_alt, int, 0644);\nMODULE_PARM_DESC(alt, \">= 0 to override altsetting selection\");\nstatic void complicated_callback(struct urb *urb);\n\n \n\n \n\n \nstruct usbtest_param_32 {\n\t \n\t__u32\t\ttest_num;\t \n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t \n\t__s32\t\tduration_sec;\n\t__s32\t\tduration_usec;\n};\n\n \nstruct usbtest_param_64 {\n\t \n\t__u32\t\ttest_num;\t \n\t__u32\t\titerations;\n\t__u32\t\tlength;\n\t__u32\t\tvary;\n\t__u32\t\tsglen;\n\n\t \n\t__s64\t\tduration_sec;\n\t__s64\t\tduration_usec;\n};\n\n \n#define USBTEST_REQUEST_32    _IOWR('U', 100, struct usbtest_param_32)\n \n#define USBTEST_REQUEST_64    _IOWR('U', 100, struct usbtest_param_64)\n\n \n\n#define\tGENERIC\t\t \n\n \n\n\n\n \n\nstruct usbtest_info {\n\tconst char\t\t*name;\n\tu8\t\t\tep_in;\t\t \n\tu8\t\t\tep_out;\t\t \n\tunsigned\t\tautoconf:1;\n\tunsigned\t\tctrl_out:1;\n\tunsigned\t\tiso:1;\t\t \n\tunsigned\t\tintr:1;\t\t \n\tint\t\t\talt;\n};\n\n \nstruct usbtest_dev {\n\tstruct usb_interface\t*intf;\n\tstruct usbtest_info\t*info;\n\tint\t\t\tin_pipe;\n\tint\t\t\tout_pipe;\n\tint\t\t\tin_iso_pipe;\n\tint\t\t\tout_iso_pipe;\n\tint\t\t\tin_int_pipe;\n\tint\t\t\tout_int_pipe;\n\tstruct usb_endpoint_descriptor\t*iso_in, *iso_out;\n\tstruct usb_endpoint_descriptor\t*int_in, *int_out;\n\tstruct mutex\t\tlock;\n\n#define TBUF_SIZE\t256\n\tu8\t\t\t*buf;\n};\n\nstatic struct usb_device *testdev_to_usbdev(struct usbtest_dev *test)\n{\n\treturn interface_to_usbdev(test->intf);\n}\n\n \n#define\tINTERRUPT_RATE\t\t1\t \n\n#define ERROR(tdev, fmt, args...) \\\n\tdev_err(&(tdev)->intf->dev , fmt , ## args)\n#define WARNING(tdev, fmt, args...) \\\n\tdev_warn(&(tdev)->intf->dev , fmt , ## args)\n\n#define GUARD_BYTE\t0xA5\n#define MAX_SGLEN\t128\n\n \n\nstatic inline void endpoint_update(int edi,\n\t\t\t\t   struct usb_host_endpoint **in,\n\t\t\t\t   struct usb_host_endpoint **out,\n\t\t\t\t   struct usb_host_endpoint *e)\n{\n\tif (edi) {\n\t\tif (!*in)\n\t\t\t*in = e;\n\t} else {\n\t\tif (!*out)\n\t\t\t*out = e;\n\t}\n}\n\nstatic int\nget_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)\n{\n\tint\t\t\t\ttmp;\n\tstruct usb_host_interface\t*alt;\n\tstruct usb_host_endpoint\t*in, *out;\n\tstruct usb_host_endpoint\t*iso_in, *iso_out;\n\tstruct usb_host_endpoint\t*int_in, *int_out;\n\tstruct usb_device\t\t*udev;\n\n\tfor (tmp = 0; tmp < intf->num_altsetting; tmp++) {\n\t\tunsigned\tep;\n\n\t\tin = out = NULL;\n\t\tiso_in = iso_out = NULL;\n\t\tint_in = int_out = NULL;\n\t\talt = intf->altsetting + tmp;\n\n\t\tif (override_alt >= 0 &&\n\t\t\t\toverride_alt != alt->desc.bAlternateSetting)\n\t\t\tcontinue;\n\n\t\t \n\t\tfor (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {\n\t\t\tstruct usb_host_endpoint\t*e;\n\t\t\tint edi;\n\n\t\t\te = alt->endpoint + ep;\n\t\t\tedi = usb_endpoint_dir_in(&e->desc);\n\n\t\t\tswitch (usb_endpoint_type(&e->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tendpoint_update(edi, &in, &out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (dev->info->intr)\n\t\t\t\t\tendpoint_update(edi, &int_in, &int_out, e);\n\t\t\t\tcontinue;\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\t\tif (dev->info->iso)\n\t\t\t\t\tendpoint_update(edi, &iso_in, &iso_out, e);\n\t\t\t\tfallthrough;\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif ((in && out)  ||  iso_in || iso_out || int_in || int_out)\n\t\t\tgoto found;\n\t}\n\treturn -EINVAL;\n\nfound:\n\tudev = testdev_to_usbdev(dev);\n\tdev->info->alt = alt->desc.bAlternateSetting;\n\tif (alt->desc.bAlternateSetting != 0) {\n\t\ttmp = usb_set_interface(udev,\n\t\t\t\talt->desc.bInterfaceNumber,\n\t\t\t\talt->desc.bAlternateSetting);\n\t\tif (tmp < 0)\n\t\t\treturn tmp;\n\t}\n\n\tif (in)\n\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\tin->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\tif (out)\n\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\tout->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\n\tif (iso_in) {\n\t\tdev->iso_in = &iso_in->desc;\n\t\tdev->in_iso_pipe = usb_rcvisocpipe(udev,\n\t\t\t\tiso_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (iso_out) {\n\t\tdev->iso_out = &iso_out->desc;\n\t\tdev->out_iso_pipe = usb_sndisocpipe(udev,\n\t\t\t\tiso_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_in) {\n\t\tdev->int_in = &int_in->desc;\n\t\tdev->in_int_pipe = usb_rcvintpipe(udev,\n\t\t\t\tint_in->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\n\tif (int_out) {\n\t\tdev->int_out = &int_out->desc;\n\t\tdev->out_int_pipe = usb_sndintpipe(udev,\n\t\t\t\tint_out->desc.bEndpointAddress\n\t\t\t\t\t& USB_ENDPOINT_NUMBER_MASK);\n\t}\n\treturn 0;\n}\n\n \n\n \n\nstatic void simple_callback(struct urb *urb)\n{\n\tcomplete(urb->context);\n}\n\nstatic struct urb *usbtest_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tunsigned\t\ttransfer_flags,\n\tunsigned\t\toffset,\n\tu8\t\t\tbInterval,\n\tusb_complete_t\t\tcomplete_fn)\n{\n\tstruct urb\t\t*urb;\n\n\turb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\n\tif (bInterval)\n\t\tusb_fill_int_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL, bInterval);\n\telse\n\t\tusb_fill_bulk_urb(urb, udev, pipe, NULL, bytes, complete_fn,\n\t\t\t\tNULL);\n\n\turb->interval = (udev->speed == USB_SPEED_HIGH)\n\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t: INTERRUPT_RATE;\n\turb->transfer_flags = transfer_flags;\n\tif (usb_pipein(pipe))\n\t\turb->transfer_flags |= URB_SHORT_NOT_OK;\n\n\tif ((bytes + offset) == 0)\n\t\treturn urb;\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\tGFP_KERNEL, &urb->transfer_dma);\n\telse\n\t\turb->transfer_buffer = kmalloc(bytes + offset, GFP_KERNEL);\n\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\n\t \n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\t\turb->transfer_dma += offset;\n\t}\n\n\t \n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\treturn urb;\n}\n\nstatic struct urb *simple_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, simple_callback);\n}\n\nstatic struct urb *complicated_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tunsigned long\t\tbytes,\n\tu8\t\t\tbInterval)\n{\n\treturn usbtest_alloc_urb(udev, pipe, bytes, URB_NO_TRANSFER_DMA_MAP, 0,\n\t\t\tbInterval, complicated_callback);\n}\n\nstatic unsigned pattern;\nstatic unsigned mod_pattern;\nmodule_param_named(pattern, mod_pattern, uint, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(mod_pattern, \"i/o pattern (0 == zeroes)\");\n\nstatic unsigned get_maxpacket(struct usb_device *udev, int pipe)\n{\n\tstruct usb_host_endpoint\t*ep;\n\n\tep = usb_pipe_endpoint(udev, pipe);\n\treturn le16_to_cpup(&ep->desc.wMaxPacketSize);\n}\n\nstatic int ss_isoc_get_packet_num(struct usb_device *udev, int pipe)\n{\n\tstruct usb_host_endpoint *ep = usb_pipe_endpoint(udev, pipe);\n\n\treturn USB_SS_MULT(ep->ss_ep_comp.bmAttributes)\n\t\t* (1 + ep->ss_ep_comp.bMaxBurst);\n}\n\nstatic void simple_fill_buf(struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->transfer_buffer_length;\n\tunsigned\tmaxpacket;\n\n\tswitch (pattern) {\n\tdefault:\n\t\tfallthrough;\n\tcase 0:\n\t\tmemset(buf, 0, len);\n\t\tbreak;\n\tcase 1:\t\t\t \n\t\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\t\tfor (i = 0; i < len; i++)\n\t\t\t*buf++ = (u8) ((i % maxpacket) % 63);\n\t\tbreak;\n\t}\n}\n\nstatic inline unsigned long buffer_offset(void *buf)\n{\n\treturn (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);\n}\n\nstatic int check_guard_bytes(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tu8 *buf = urb->transfer_buffer;\n\tu8 *guard = buf - buffer_offset(buf);\n\tunsigned i;\n\n\tfor (i = 0; guard < buf; i++, guard++) {\n\t\tif (*guard != GUARD_BYTE) {\n\t\t\tERROR(tdev, \"guard byte[%d] %d (not %d)\\n\",\n\t\t\t\ti, *guard, GUARD_BYTE);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int simple_check_buf(struct usbtest_dev *tdev, struct urb *urb)\n{\n\tunsigned\ti;\n\tu8\t\texpected;\n\tu8\t\t*buf = urb->transfer_buffer;\n\tunsigned\tlen = urb->actual_length;\n\tunsigned\tmaxpacket = get_maxpacket(urb->dev, urb->pipe);\n\n\tint ret = check_guard_bytes(tdev, urb);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < len; i++, buf++) {\n\t\tswitch (pattern) {\n\t\t \n\t\tcase 0:\n\t\t\texpected = 0;\n\t\t\tbreak;\n\t\t \n\t\tcase 1:\t\t\t \n\t\t\texpected = (i % maxpacket) % 63;\n\t\t\tbreak;\n\t\t \n\t\tdefault:\n\t\t\texpected = !*buf;\n\t\t\tbreak;\n\t\t}\n\t\tif (*buf == expected)\n\t\t\tcontinue;\n\t\tERROR(tdev, \"buf[%d] = %d (not %d)\\n\", i, *buf, expected);\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic void simple_free_urb(struct urb *urb)\n{\n\tunsigned long offset = buffer_offset(urb->transfer_buffer);\n\n\tif (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP)\n\t\tusb_free_coherent(\n\t\t\turb->dev,\n\t\t\turb->transfer_buffer_length + offset,\n\t\t\turb->transfer_buffer - offset,\n\t\t\turb->transfer_dma - offset);\n\telse\n\t\tkfree(urb->transfer_buffer - offset);\n\tusb_free_urb(urb);\n}\n\nstatic int simple_io(\n\tstruct usbtest_dev\t*tdev,\n\tstruct urb\t\t*urb,\n\tint\t\t\titerations,\n\tint\t\t\tvary,\n\tint\t\t\texpected,\n\tconst char\t\t*label\n)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tmax = urb->transfer_buffer_length;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\tunsigned long\t\texpire;\n\n\turb->context = &completion;\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tinit_completion(&completion);\n\t\tif (usb_pipeout(urb->pipe)) {\n\t\t\tsimple_fill_buf(urb);\n\t\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\t\tif (retval != 0)\n\t\t\tbreak;\n\n\t\texpire = msecs_to_jiffies(SIMPLE_IO_TIMEOUT);\n\t\tif (!wait_for_completion_timeout(&completion, expire)) {\n\t\t\tusb_kill_urb(urb);\n\t\t\tretval = (urb->status == -ENOENT ?\n\t\t\t\t  -ETIMEDOUT : urb->status);\n\t\t} else {\n\t\t\tretval = urb->status;\n\t\t}\n\n\t\turb->dev = udev;\n\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\tretval = simple_check_buf(tdev, urb);\n\n\t\tif (vary) {\n\t\t\tint\tlen = urb->transfer_buffer_length;\n\n\t\t\tlen += vary;\n\t\t\tlen %= max;\n\t\t\tif (len == 0)\n\t\t\t\tlen = (vary < max) ? vary : max;\n\t\t\turb->transfer_buffer_length = len;\n\t\t}\n\n\t\t \n\t}\n\turb->transfer_buffer_length = max;\n\n\tif (expected != retval)\n\t\tdev_err(&udev->dev,\n\t\t\t\"%s failed, iterations left %d, status %d (not %d)\\n\",\n\t\t\t\tlabel, iterations, retval, expected);\n\treturn retval;\n}\n\n\n \n\n \n\nstatic void free_sglist(struct scatterlist *sg, int nents)\n{\n\tunsigned\t\ti;\n\n\tif (!sg)\n\t\treturn;\n\tfor (i = 0; i < nents; i++) {\n\t\tif (!sg_page(&sg[i]))\n\t\t\tcontinue;\n\t\tkfree(sg_virt(&sg[i]));\n\t}\n\tkfree(sg);\n}\n\nstatic struct scatterlist *\nalloc_sglist(int nents, int max, int vary, struct usbtest_dev *dev, int pipe)\n{\n\tstruct scatterlist\t*sg;\n\tunsigned int\t\tn_size = 0;\n\tunsigned\t\ti;\n\tunsigned\t\tsize = max;\n\tunsigned\t\tmaxpacket =\n\t\tget_maxpacket(interface_to_usbdev(dev->intf), pipe);\n\n\tif (max == 0)\n\t\treturn NULL;\n\n\tsg = kmalloc_array(nents, sizeof(*sg), GFP_KERNEL);\n\tif (!sg)\n\t\treturn NULL;\n\tsg_init_table(sg, nents);\n\n\tfor (i = 0; i < nents; i++) {\n\t\tchar\t\t*buf;\n\t\tunsigned\tj;\n\n\t\tbuf = kzalloc(size, GFP_KERNEL);\n\t\tif (!buf) {\n\t\t\tfree_sglist(sg, i);\n\t\t\treturn NULL;\n\t\t}\n\n\t\t \n\t\tsg_set_buf(&sg[i], buf, size);\n\n\t\tswitch (pattern) {\n\t\tcase 0:\n\t\t\t \n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tfor (j = 0; j < size; j++)\n\t\t\t\t*buf++ = (u8) (((j + n_size) % maxpacket) % 63);\n\t\t\tn_size += size;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (vary) {\n\t\t\tsize += vary;\n\t\t\tsize %= max;\n\t\t\tif (size == 0)\n\t\t\t\tsize = (vary < max) ? vary : max;\n\t\t}\n\t}\n\n\treturn sg;\n}\n\nstruct sg_timeout {\n\tstruct timer_list timer;\n\tstruct usb_sg_request *req;\n};\n\nstatic void sg_timeout(struct timer_list *t)\n{\n\tstruct sg_timeout *timeout = from_timer(timeout, t, timer);\n\n\tusb_sg_cancel(timeout->req);\n}\n\nstatic int perform_sglist(\n\tstruct usbtest_dev\t*tdev,\n\tunsigned\t\titerations,\n\tint\t\t\tpipe,\n\tstruct usb_sg_request\t*req,\n\tstruct scatterlist\t*sg,\n\tint\t\t\tnents\n)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(tdev);\n\tint\t\t\tretval = 0;\n\tstruct sg_timeout\ttimeout = {\n\t\t.req = req,\n\t};\n\n\ttimer_setup_on_stack(&timeout.timer, sg_timeout, 0);\n\n\twhile (retval == 0 && iterations-- > 0) {\n\t\tretval = usb_sg_init(req, udev, pipe,\n\t\t\t\t(udev->speed == USB_SPEED_HIGH)\n\t\t\t\t\t? (INTERRUPT_RATE << 3)\n\t\t\t\t\t: INTERRUPT_RATE,\n\t\t\t\tsg, nents, 0, GFP_KERNEL);\n\n\t\tif (retval)\n\t\t\tbreak;\n\t\tmod_timer(&timeout.timer, jiffies +\n\t\t\t\tmsecs_to_jiffies(SIMPLE_IO_TIMEOUT));\n\t\tusb_sg_wait(req);\n\t\tif (!del_timer_sync(&timeout.timer))\n\t\t\tretval = -ETIMEDOUT;\n\t\telse\n\t\t\tretval = req->status;\n\t\tdestroy_timer_on_stack(&timeout.timer);\n\n\t\t \n\n\t\t \n\t}\n\n\t \n\tif (retval)\n\t\tERROR(tdev, \"perform_sglist failed, \"\n\t\t\t\t\"iterations left %d, status %d\\n\",\n\t\t\t\titerations, retval);\n\treturn retval;\n}\n\n\n \n\n \n\nstatic unsigned realworld = 1;\nmodule_param(realworld, uint, 0);\nMODULE_PARM_DESC(realworld, \"clear to demand stricter spec compliance\");\n\nstatic int get_altsetting(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\tretval;\n\n\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\tUSB_REQ_GET_INTERFACE, USB_DIR_IN|USB_RECIP_INTERFACE,\n\t\t\t0, iface->altsetting[0].desc.bInterfaceNumber,\n\t\t\tdev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\tswitch (retval) {\n\tcase 1:\n\t\treturn dev->buf[0];\n\tcase 0:\n\t\tretval = -ERANGE;\n\t\tfallthrough;\n\tdefault:\n\t\treturn retval;\n\t}\n}\n\nstatic int set_altsetting(struct usbtest_dev *dev, int alternate)\n{\n\tstruct usb_interface\t\t*iface = dev->intf;\n\tstruct usb_device\t\t*udev;\n\n\tif (alternate < 0 || alternate >= 256)\n\t\treturn -EINVAL;\n\n\tudev = interface_to_usbdev(iface);\n\treturn usb_set_interface(udev,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber,\n\t\t\talternate);\n}\n\nstatic int is_good_config(struct usbtest_dev *tdev, int len)\n{\n\tstruct usb_config_descriptor\t*config;\n\n\tif (len < sizeof(*config))\n\t\treturn 0;\n\tconfig = (struct usb_config_descriptor *) tdev->buf;\n\n\tswitch (config->bDescriptorType) {\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\t\tif (config->bLength != 9) {\n\t\t\tERROR(tdev, \"bogus config descriptor length\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\t \n\t\tif (!realworld && !(config->bmAttributes & 0x80)) {\n\t\t\tERROR(tdev, \"high bit of config attributes not set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (config->bmAttributes & 0x1f) {\t \n\t\t\tERROR(tdev, \"reserved config bits set\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\tif (le16_to_cpu(config->wTotalLength) == len)\t \n\t\treturn 1;\n\tif (le16_to_cpu(config->wTotalLength) >= TBUF_SIZE)\t \n\t\treturn 1;\n\tERROR(tdev, \"bogus config descriptor read size\\n\");\n\treturn 0;\n}\n\nstatic int is_good_ext(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ext_cap_descriptor *ext;\n\tu32 attr;\n\n\text = (struct usb_ext_cap_descriptor *) buf;\n\n\tif (ext->bLength != USB_DT_USB_EXT_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus usb 2.0 extension descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tattr = le32_to_cpu(ext->bmAttributes);\n\t \n\tif (attr & ~0xfffe) {\t \n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_ss_cap(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_cap_descriptor *ss;\n\n\tss = (struct usb_ss_cap_descriptor *) buf;\n\n\tif (ss->bLength != USB_DT_USB_SS_CAP_SIZE) {\n\t\tERROR(tdev, \"bogus superspeed device capability descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (ss->bmAttributes & ~0x02) {\t \n\t\tERROR(tdev, \"reserved bits set in bmAttributes\\n\");\n\t\treturn 0;\n\t}\n\n\t \n\tif (le16_to_cpu(ss->wSpeedSupported) & ~0x0f) {\t \n\t\tERROR(tdev, \"reserved bits set in wSpeedSupported\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int is_good_con_id(struct usbtest_dev *tdev, u8 *buf)\n{\n\tstruct usb_ss_container_id_descriptor *con_id;\n\n\tcon_id = (struct usb_ss_container_id_descriptor *) buf;\n\n\tif (con_id->bLength != USB_DT_USB_SS_CONTN_ID_SIZE) {\n\t\tERROR(tdev, \"bogus container id descriptor length\\n\");\n\t\treturn 0;\n\t}\n\n\tif (con_id->bReserved) {\t \n\t\tERROR(tdev, \"reserved bits set\\n\");\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n \nstatic int ch9_postconfig(struct usbtest_dev *dev)\n{\n\tstruct usb_interface\t*iface = dev->intf;\n\tstruct usb_device\t*udev = interface_to_usbdev(iface);\n\tint\t\t\ti, alt, retval;\n\n\t \n\tfor (i = 0; i < iface->num_altsetting; i++) {\n\n\t\t \n\t\talt = iface->altsetting[i].desc.bAlternateSetting;\n\t\tif (alt < 0 || alt >= iface->num_altsetting) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"invalid alt [%d].bAltSetting = %d\\n\",\n\t\t\t\t\ti, alt);\n\t\t}\n\n\t\t \n\t\tif (realworld && iface->num_altsetting == 1)\n\t\t\tcontinue;\n\n\t\t \n\t\tretval = set_altsetting(dev, alt);\n\t\tif (retval) {\n\t\t\tdev_err(&iface->dev, \"can't set_interface = %d, %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn retval;\n\t\t}\n\n\t\t \n\t\tretval = get_altsetting(dev);\n\t\tif (retval != alt) {\n\t\t\tdev_err(&iface->dev, \"get alt should be %d, was %d\\n\",\n\t\t\t\t\talt, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t}\n\n\t \n\tif (!realworld || udev->descriptor.bNumConfigurations != 1) {\n\t\tint\texpected = udev->actconfig->desc.bConfigurationValue;\n\n\t\t \n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_GET_CONFIGURATION,\n\t\t\t\tUSB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t0, 0, dev->buf, 1, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != 1 || dev->buf[0] != expected) {\n\t\t\tdev_err(&iface->dev, \"get config --> %d %d (1 %d)\\n\",\n\t\t\t\tretval, dev->buf[0], expected);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\t}\n\n\t \n\tretval = usb_get_descriptor(udev, USB_DT_DEVICE, 0,\n\t\t\tdev->buf, sizeof(udev->descriptor));\n\tif (retval != sizeof(udev->descriptor)) {\n\t\tdev_err(&iface->dev, \"dev descriptor --> %d\\n\", retval);\n\t\treturn (retval < 0) ? retval : -EDOM;\n\t}\n\n\t \n\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0210) {\n\t\tstruct usb_bos_descriptor *bos = NULL;\n\t\tstruct usb_dev_cap_header *header = NULL;\n\t\tunsigned total, num, length;\n\t\tu8 *buf;\n\n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\tsizeof(*udev->bos->desc));\n\t\tif (retval != sizeof(*udev->bos->desc)) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tbos = (struct usb_bos_descriptor *)dev->buf;\n\t\ttotal = le16_to_cpu(bos->wTotalLength);\n\t\tnum = bos->bNumDeviceCaps;\n\n\t\tif (total > TBUF_SIZE)\n\t\t\ttotal = TBUF_SIZE;\n\n\t\t \n\t\tretval = usb_get_descriptor(udev, USB_DT_BOS, 0, dev->buf,\n\t\t\t\ttotal);\n\t\tif (retval != total) {\n\t\t\tdev_err(&iface->dev, \"bos descriptor set --> %d\\n\",\n\t\t\t\t\tretval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\tlength = sizeof(*udev->bos->desc);\n\t\tbuf = dev->buf;\n\t\tfor (i = 0; i < num; i++) {\n\t\t\tbuf += length;\n\t\t\tif (buf + sizeof(struct usb_dev_cap_header) >\n\t\t\t\t\tdev->buf + total)\n\t\t\t\tbreak;\n\n\t\t\theader = (struct usb_dev_cap_header *)buf;\n\t\t\tlength = header->bLength;\n\n\t\t\tif (header->bDescriptorType !=\n\t\t\t\t\tUSB_DT_DEVICE_CAPABILITY) {\n\t\t\t\tdev_warn(&udev->dev, \"not device capability descriptor, skip\\n\");\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (header->bDevCapabilityType) {\n\t\t\tcase USB_CAP_TYPE_EXT:\n\t\t\t\tif (buf + USB_DT_USB_EXT_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ext(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus usb 2.0 extension descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase USB_SS_CAP_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CAP_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_ss_cap(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus superspeed device capability descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase CONTAINER_ID_TYPE:\n\t\t\t\tif (buf + USB_DT_USB_SS_CONTN_ID_SIZE >\n\t\t\t\t\t\tdev->buf + total ||\n\t\t\t\t\t\t!is_good_con_id(dev, buf)) {\n\t\t\t\t\tdev_err(&iface->dev, \"bogus container id descriptor\\n\");\n\t\t\t\t\treturn -EDOM;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < udev->descriptor.bNumConfigurations; i++) {\n\t\tretval = usb_get_descriptor(udev, USB_DT_CONFIG, i,\n\t\t\t\tdev->buf, TBUF_SIZE);\n\t\tif (!is_good_config(dev, retval)) {\n\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\"config [%d] descriptor --> %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t}\n\n\t\t \n\t}\n\n\t \n\tif (le16_to_cpu(udev->descriptor.bcdUSB) == 0x0200) {\n\t\tstruct usb_qualifier_descriptor *d = NULL;\n\n\t\t \n\t\tretval = usb_get_descriptor(udev,\n\t\t\t\tUSB_DT_DEVICE_QUALIFIER, 0, dev->buf,\n\t\t\t\tsizeof(struct usb_qualifier_descriptor));\n\t\tif (retval == -EPIPE) {\n\t\t\tif (udev->speed == USB_SPEED_HIGH) {\n\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"hs dev qualifier --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\treturn retval;\n\t\t\t}\n\t\t\t \n\t\t} else if (retval != sizeof(struct usb_qualifier_descriptor)) {\n\t\t\tdev_err(&iface->dev, \"dev qualifier --> %d\\n\", retval);\n\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t} else\n\t\t\td = (struct usb_qualifier_descriptor *) dev->buf;\n\n\t\t \n\t\tif (d) {\n\t\t\tunsigned max = d->bNumConfigurations;\n\t\t\tfor (i = 0; i < max; i++) {\n\t\t\t\tretval = usb_get_descriptor(udev,\n\t\t\t\t\tUSB_DT_OTHER_SPEED_CONFIG, i,\n\t\t\t\t\tdev->buf, TBUF_SIZE);\n\t\t\t\tif (!is_good_config(dev, retval)) {\n\t\t\t\t\tdev_err(&iface->dev,\n\t\t\t\t\t\t\"other speed config --> %d\\n\",\n\t\t\t\t\t\tretval);\n\t\t\t\t\treturn (retval < 0) ? retval : -EDOM;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t \n\n\t \n\tretval = usb_get_std_status(udev, USB_RECIP_DEVICE, 0, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get dev status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t \n\n\tretval = usb_get_std_status(udev, USB_RECIP_INTERFACE,\n\t\t\tiface->altsetting[0].desc.bInterfaceNumber, dev->buf);\n\tif (retval) {\n\t\tdev_err(&iface->dev, \"get interface status --> %d\\n\", retval);\n\t\treturn retval;\n\t}\n\t \n\n\treturn 0;\n}\n\n \n\n \n\nstruct ctrl_ctx {\n\tspinlock_t\t\tlock;\n\tstruct usbtest_dev\t*dev;\n\tstruct completion\tcomplete;\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urb;\n\tstruct usbtest_param_32\t*param;\n\tint\t\t\tlast;\n};\n\n#define NUM_SUBCASES\t16\t\t \n\nstruct subcase {\n\tstruct usb_ctrlrequest\tsetup;\n\tint\t\t\tnumber;\n\tint\t\t\texpected;\n};\n\nstatic void ctrl_complete(struct urb *urb)\n{\n\tstruct ctrl_ctx\t\t*ctx = urb->context;\n\tstruct usb_ctrlrequest\t*reqp;\n\tstruct subcase\t\t*subcase;\n\tint\t\t\tstatus = urb->status;\n\tunsigned long\t\tflags;\n\n\treqp = (struct usb_ctrlrequest *)urb->setup_packet;\n\tsubcase = container_of(reqp, struct subcase, setup);\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\tctx->count--;\n\tctx->pending--;\n\n\t \n\tif (subcase->number > 0) {\n\t\tif ((subcase->number - ctx->last) != 1) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"subcase %d completed out of order, last %d\\n\",\n\t\t\t\tsubcase->number, ctx->last);\n\t\t\tstatus = -EDOM;\n\t\t\tctx->last = subcase->number;\n\t\t\tgoto error;\n\t\t}\n\t}\n\tctx->last = subcase->number;\n\n\t \n\tif (status == subcase->expected)\n\t\tstatus = 0;\n\n\t \n\telse if (status != -ECONNRESET) {\n\n\t\t \n\t\tif (subcase->expected > 0 && (\n\t\t\t  ((status == -subcase->expected\t \n\t\t\t   || status == 0))))\t\t\t \n\t\t\tstatus = 0;\n\t\t \n\t\telse if (subcase->number == 12 && status == -EPIPE)\n\t\t\tstatus = 0;\n\t\telse\n\t\t\tERROR(ctx->dev, \"subtest %d error, status %d\\n\",\n\t\t\t\t\tsubcase->number, status);\n\t}\n\n\t \n\tif (status) {\nerror:\n\t\tif (ctx->status == 0) {\n\t\t\tint\t\ti;\n\n\t\t\tctx->status = status;\n\t\t\tERROR(ctx->dev, \"control queue %02x.%02x, err %d, \"\n\t\t\t\t\t\"%d left, subcase %d, len %d/%d\\n\",\n\t\t\t\t\treqp->bRequestType, reqp->bRequest,\n\t\t\t\t\tstatus, ctx->count, subcase->number,\n\t\t\t\t\turb->actual_length,\n\t\t\t\t\turb->transfer_buffer_length);\n\n\t\t\t \n\n\t\t\t \n\t\t\tfor (i = 1; i < ctx->param->sglen; i++) {\n\t\t\t\tstruct urb *u = ctx->urb[\n\t\t\t\t\t\t\t(i + subcase->number)\n\t\t\t\t\t\t\t% ctx->param->sglen];\n\n\t\t\t\tif (u == urb || !u->dev)\n\t\t\t\t\tcontinue;\n\t\t\t\tspin_unlock(&ctx->lock);\n\t\t\t\tstatus = usb_unlink_urb(u);\n\t\t\t\tspin_lock(&ctx->lock);\n\t\t\t\tswitch (status) {\n\t\t\t\tcase -EINPROGRESS:\n\t\t\t\tcase -EBUSY:\n\t\t\t\tcase -EIDRM:\n\t\t\t\t\tcontinue;\n\t\t\t\tdefault:\n\t\t\t\t\tERROR(ctx->dev, \"urb unlink --> %d\\n\",\n\t\t\t\t\t\t\tstatus);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstatus = ctx->status;\n\t\t}\n\t}\n\n\t \n\tif ((status == 0) && (ctx->pending < ctx->count)) {\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tif (status != 0) {\n\t\t\tERROR(ctx->dev,\n\t\t\t\t\"can't resubmit ctrl %02x.%02x, err %d\\n\",\n\t\t\t\treqp->bRequestType, reqp->bRequest, status);\n\t\t\turb->dev = NULL;\n\t\t} else\n\t\t\tctx->pending++;\n\t} else\n\t\turb->dev = NULL;\n\n\t \n\tif (ctx->pending == 0)\n\t\tcomplete(&ctx->complete);\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n}\n\nstatic int\ntest_ctrl_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param)\n{\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t**urb;\n\tstruct ctrl_ctx\t\tcontext;\n\tint\t\t\ti;\n\n\tif (param->sglen == 0 || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock_init(&context.lock);\n\tcontext.dev = dev;\n\tinit_completion(&context.complete);\n\tcontext.count = param->sglen * param->iterations;\n\tcontext.pending = 0;\n\tcontext.status = -ENOMEM;\n\tcontext.param = param;\n\tcontext.last = -1;\n\n\t \n\turb = kcalloc(param->sglen, sizeof(struct urb *), GFP_KERNEL);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tint\t\t\tpipe = usb_rcvctrlpipe(udev, 0);\n\t\tunsigned\t\tlen;\n\t\tstruct urb\t\t*u;\n\t\tstruct usb_ctrlrequest\treq;\n\t\tstruct subcase\t\t*reqp;\n\n\t\t \n\t\tint\t\t\texpected = 0;\n\n\t\t \n\t\tmemset(&req, 0, sizeof(req));\n\t\treq.bRequest = USB_REQ_GET_DESCRIPTOR;\n\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\n\t\tswitch (i % NUM_SUBCASES) {\n\t\tcase 0:\t\t \n\t\t\treq.wValue = cpu_to_le16(USB_DT_DEVICE << 8);\n\t\t\tlen = sizeof(struct usb_device_descriptor);\n\t\t\tbreak;\n\t\tcase 1:\t\t \n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tbreak;\n\t\tcase 2:\t\t \n\t\t\treq.bRequest = USB_REQ_GET_INTERFACE;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t \n\t\t\tlen = 1;\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 3:\t\t \n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_INTERFACE;\n\t\t\t \n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 4:\t\t \n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_DEVICE;\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 5:\t\t \n\t\t\treq.wValue = cpu_to_le16 (USB_DT_DEVICE_QUALIFIER << 8);\n\t\t\tlen = sizeof(struct usb_qualifier_descriptor);\n\t\t\tif (udev->speed != USB_SPEED_HIGH)\n\t\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 6:\t\t \n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = sizeof(struct usb_config_descriptor);\n\t\t\tlen += sizeof(struct usb_interface_descriptor);\n\t\t\tbreak;\n\t\tcase 7:\t\t \n\t\t\treq.wValue = cpu_to_le16 (USB_DT_INTERFACE << 8);\n\t\t\t \n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\t \n\t\tcase 8:\t\t \n\t\t\treq.bRequest = USB_REQ_CLEAR_FEATURE;\n\t\t\treq.bRequestType = USB_RECIP_ENDPOINT;\n\t\t\t \n\t\t\t \n\t\t\tlen = 0;\n\t\t\tpipe = usb_sndctrlpipe(udev, 0);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\tcase 9:\t\t \n\t\t\treq.bRequest = USB_REQ_GET_STATUS;\n\t\t\treq.bRequestType = USB_DIR_IN|USB_RECIP_ENDPOINT;\n\t\t\t \n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase 10:\t \n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\tlen = 1024;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\t \n\t\tcase 11:\t \n\t\t\treq.wValue = cpu_to_le16(USB_DT_ENDPOINT << 8);\n\t\t\t \n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\texpected = EPIPE;\n\t\t\tbreak;\n\t\t \n\t\tcase 12:\t \n\t\t\treq.wValue = cpu_to_le16(USB_DT_STRING << 8);\n\t\t\t \n\t\t\tlen = sizeof(struct usb_interface_descriptor);\n\t\t\t \n\t\t\texpected = EREMOTEIO;\t \n\t\t\tbreak;\n\t\tcase 13:\t \n\t\t\treq.wValue = cpu_to_le16((USB_DT_CONFIG << 8) | 0);\n\t\t\t \n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 1024 - 512;\n\t\t\telse\n\t\t\t\tlen = 1024 - udev->descriptor.bMaxPacketSize0;\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 14:\t \n\t\t\treq.wValue = cpu_to_le16((USB_DT_DEVICE << 8) | 0);\n\t\t\t \n\t\t\tlen = udev->descriptor.bMaxPacketSize0;\n\t\t\tif (udev->speed == USB_SPEED_SUPER)\n\t\t\t\tlen = 512;\n\t\t\tswitch (len) {\n\t\t\tcase 8:\n\t\t\t\tlen = 24;\n\t\t\t\tbreak;\n\t\t\tcase 16:\n\t\t\t\tlen = 32;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\texpected = -EREMOTEIO;\n\t\t\tbreak;\n\t\tcase 15:\n\t\t\treq.wValue = cpu_to_le16(USB_DT_BOS << 8);\n\t\t\tif (udev->bos)\n\t\t\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\t\telse\n\t\t\t\tlen = sizeof(struct usb_bos_descriptor);\n\t\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) < 0x0201)\n\t\t\t\texpected = -EPIPE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERROR(dev, \"bogus number of ctrl queue testcases!\\n\");\n\t\t\tcontext.status = -EINVAL;\n\t\t\tgoto cleanup;\n\t\t}\n\t\treq.wLength = cpu_to_le16(len);\n\t\turb[i] = u = simple_alloc_urb(udev, pipe, len, 0);\n\t\tif (!u)\n\t\t\tgoto cleanup;\n\n\t\treqp = kmalloc(sizeof(*reqp), GFP_KERNEL);\n\t\tif (!reqp)\n\t\t\tgoto cleanup;\n\t\treqp->setup = req;\n\t\treqp->number = i % NUM_SUBCASES;\n\t\treqp->expected = expected;\n\t\tu->setup_packet = (char *) &reqp->setup;\n\n\t\tu->context = &context;\n\t\tu->complete = ctrl_complete;\n\t}\n\n\t \n\tcontext.urb = urb;\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tcontext.status = usb_submit_urb(urb[i], GFP_ATOMIC);\n\t\tif (context.status != 0) {\n\t\t\tERROR(dev, \"can't submit urb[%d], status %d\\n\",\n\t\t\t\t\ti, context.status);\n\t\t\tcontext.count = context.pending;\n\t\t\tbreak;\n\t\t}\n\t\tcontext.pending++;\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\t \n\n\t \n\tif (context.pending > 0)\n\t\twait_for_completion(&context.complete);\n\ncleanup:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (!urb[i])\n\t\t\tcontinue;\n\t\turb[i]->dev = udev;\n\t\tkfree(urb[i]->setup_packet);\n\t\tsimple_free_urb(urb[i]);\n\t}\n\tkfree(urb);\n\treturn context.status;\n}\n#undef NUM_SUBCASES\n\n\n \n\nstatic void unlink1_callback(struct urb *urb)\n{\n\tint\tstatus = urb->status;\n\n\t \n\tif (!status)\n\t\tstatus = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (status) {\n\t\turb->status = status;\n\t\tcomplete(urb->context);\n\t}\n}\n\nstatic int unlink1(struct usbtest_dev *dev, int pipe, int size, int async)\n{\n\tstruct urb\t\t*urb;\n\tstruct completion\tcompletion;\n\tint\t\t\tretval = 0;\n\n\tinit_completion(&completion);\n\turb = simple_alloc_urb(testdev_to_usbdev(dev), pipe, size, 0);\n\tif (!urb)\n\t\treturn -ENOMEM;\n\turb->context = &completion;\n\turb->complete = unlink1_callback;\n\n\tif (usb_pipeout(urb->pipe)) {\n\t\tsimple_fill_buf(urb);\n\t\turb->transfer_flags |= URB_ZERO_PACKET;\n\t}\n\n\t \n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval != 0) {\n\t\tdev_err(&dev->intf->dev, \"submit fail %d\\n\", retval);\n\t\treturn retval;\n\t}\n\n\t \n\tmsleep(jiffies % (2 * INTERRUPT_RATE));\n\tif (async) {\n\t\twhile (!completion_done(&completion)) {\n\t\t\tretval = usb_unlink_urb(urb);\n\n\t\t\tif (retval == 0 && usb_pipein(urb->pipe))\n\t\t\t\tretval = simple_check_buf(dev, urb);\n\n\t\t\tswitch (retval) {\n\t\t\tcase -EBUSY:\n\t\t\tcase -EIDRM:\n\t\t\t\t \n\t\t\t\tERROR(dev, \"unlink retry\\n\");\n\t\t\t\tcontinue;\n\t\t\tcase 0:\n\t\t\tcase -EINPROGRESS:\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tdev_err(&dev->intf->dev,\n\t\t\t\t\t\"unlink fail %d\\n\", retval);\n\t\t\t\treturn retval;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tusb_kill_urb(urb);\n\n\twait_for_completion(&completion);\n\tretval = urb->status;\n\tsimple_free_urb(urb);\n\n\tif (async)\n\t\treturn (retval == -ECONNRESET) ? 0 : retval - 1000;\n\telse\n\t\treturn (retval == -ENOENT || retval == -EPERM) ?\n\t\t\t\t0 : retval - 2000;\n}\n\nstatic int unlink_simple(struct usbtest_dev *dev, int pipe, int len)\n{\n\tint\t\t\tretval = 0;\n\n\t \n\tretval = unlink1(dev, pipe, len, 1);\n\tif (!retval)\n\t\tretval = unlink1(dev, pipe, len, 0);\n\treturn retval;\n}\n\n \n\nstruct queued_ctx {\n\tstruct completion\tcomplete;\n\tatomic_t\t\tpending;\n\tunsigned\t\tnum;\n\tint\t\t\tstatus;\n\tstruct urb\t\t**urbs;\n};\n\nstatic void unlink_queued_callback(struct urb *urb)\n{\n\tint\t\t\tstatus = urb->status;\n\tstruct queued_ctx\t*ctx = urb->context;\n\n\tif (ctx->status)\n\t\tgoto done;\n\tif (urb == ctx->urbs[ctx->num - 4] || urb == ctx->urbs[ctx->num - 2]) {\n\t\tif (status == -ECONNRESET)\n\t\t\tgoto done;\n\t\t \n\t}\n\tif (status != 0)\n\t\tctx->status = status;\n\n done:\n\tif (atomic_dec_and_test(&ctx->pending))\n\t\tcomplete(&ctx->complete);\n}\n\nstatic int unlink_queued(struct usbtest_dev *dev, int pipe, unsigned num,\n\t\tunsigned size)\n{\n\tstruct queued_ctx\tctx;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tvoid\t\t\t*buf;\n\tdma_addr_t\t\tbuf_dma;\n\tint\t\t\ti;\n\tint\t\t\tretval = -ENOMEM;\n\n\tinit_completion(&ctx.complete);\n\tatomic_set(&ctx.pending, 1);\t \n\tctx.num = num;\n\tctx.status = 0;\n\n\tbuf = usb_alloc_coherent(udev, size, GFP_KERNEL, &buf_dma);\n\tif (!buf)\n\t\treturn retval;\n\tmemset(buf, 0, size);\n\n\t \n\tctx.urbs = kcalloc(num, sizeof(struct urb *), GFP_KERNEL);\n\tif (!ctx.urbs)\n\t\tgoto free_buf;\n\tfor (i = 0; i < num; i++) {\n\t\tctx.urbs[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!ctx.urbs[i])\n\t\t\tgoto free_urbs;\n\t\tusb_fill_bulk_urb(ctx.urbs[i], udev, pipe, buf, size,\n\t\t\t\tunlink_queued_callback, &ctx);\n\t\tctx.urbs[i]->transfer_dma = buf_dma;\n\t\tctx.urbs[i]->transfer_flags = URB_NO_TRANSFER_DMA_MAP;\n\n\t\tif (usb_pipeout(ctx.urbs[i]->pipe)) {\n\t\t\tsimple_fill_buf(ctx.urbs[i]);\n\t\t\tctx.urbs[i]->transfer_flags |= URB_ZERO_PACKET;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < num; i++) {\n\t\tatomic_inc(&ctx.pending);\n\t\tretval = usb_submit_urb(ctx.urbs[i], GFP_KERNEL);\n\t\tif (retval != 0) {\n\t\t\tdev_err(&dev->intf->dev, \"submit urbs[%d] fail %d\\n\",\n\t\t\t\t\ti, retval);\n\t\t\tatomic_dec(&ctx.pending);\n\t\t\tctx.status = retval;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == num) {\n\t\tusb_unlink_urb(ctx.urbs[num - 4]);\n\t\tusb_unlink_urb(ctx.urbs[num - 2]);\n\t} else {\n\t\twhile (--i >= 0)\n\t\t\tusb_unlink_urb(ctx.urbs[i]);\n\t}\n\n\tif (atomic_dec_and_test(&ctx.pending))\t\t \n\t\tcomplete(&ctx.complete);\n\twait_for_completion(&ctx.complete);\n\tretval = ctx.status;\n\n free_urbs:\n\tfor (i = 0; i < num; i++)\n\t\tusb_free_urb(ctx.urbs[i]);\n\tkfree(ctx.urbs);\n free_buf:\n\tusb_free_coherent(udev, size, buf, buf_dma);\n\treturn retval;\n}\n\n \n\nstatic int verify_not_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t \n\tretval = usb_get_std_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get no-halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 0) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 0\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, 0, __func__);\n\tif (retval != 0)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int verify_halted(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\tu16\tstatus;\n\n\t \n\tretval = usb_get_std_status(urb->dev, USB_RECIP_ENDPOINT, ep, &status);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't get halt status, %d\\n\",\n\t\t\t\tep, retval);\n\t\treturn retval;\n\t}\n\tif (status != 1) {\n\t\tERROR(tdev, \"ep %02x bogus status: %04x != 1\\n\", ep, status);\n\t\treturn -EINVAL;\n\t}\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, __func__);\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\tretval = simple_io(tdev, urb, 1, 0, -EPIPE, \"verify_still_halted\");\n\tif (retval != -EPIPE)\n\t\treturn -EINVAL;\n\treturn 0;\n}\n\nstatic int test_halt(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\n\t \n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\tretval = usb_control_msg(urb->dev, usb_sndctrlpipe(urb->dev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_ENDPOINT,\n\t\t\tUSB_ENDPOINT_HALT, ep,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't set halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_halted(tdev, ep, urb);\n\tif (retval < 0) {\n\t\tint ret;\n\n\t\t \n\t\tret = usb_clear_halt(urb->dev, urb->pipe);\n\t\tif (ret)\n\t\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\",\n\t\t\t      ep, ret);\n\n\t\treturn retval;\n\t}\n\n\t \n\tretval = usb_clear_halt(urb->dev, urb->pipe);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\tretval = verify_not_halted(tdev, ep, urb);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\n\treturn 0;\n}\n\nstatic int test_toggle_sync(struct usbtest_dev *tdev, int ep, struct urb *urb)\n{\n\tint\tretval;\n\n\t \n\tretval = usb_clear_halt(urb->dev, urb->pipe);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\n\t \n\tretval = simple_io(tdev, urb, 1, 0, 0, __func__);\n\tif (retval != 0)\n\t\treturn -EINVAL;\n\n\t \n\tretval = usb_clear_halt(urb->dev, urb->pipe);\n\tif (retval < 0) {\n\t\tERROR(tdev, \"ep %02x couldn't clear halt, %d\\n\", ep, retval);\n\t\treturn retval;\n\t}\n\n\t \n\tretval = simple_io(tdev, urb, 1, 0, 0, __func__);\n\n\treturn retval;\n}\n\nstatic int halt_simple(struct usbtest_dev *dev)\n{\n\tint\t\t\tep;\n\tint\t\t\tretval = 0;\n\tstruct urb\t\t*urb;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\n\tif (udev->speed == USB_SPEED_SUPER)\n\t\turb = simple_alloc_urb(udev, 0, 1024, 0);\n\telse\n\t\turb = simple_alloc_urb(udev, 0, 512, 0);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (dev->in_pipe) {\n\t\tep = usb_pipeendpoint(dev->in_pipe) | USB_DIR_IN;\n\t\turb->pipe = dev->in_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t\tif (retval < 0)\n\t\t\tgoto done;\n\t}\n\n\tif (dev->out_pipe) {\n\t\tep = usb_pipeendpoint(dev->out_pipe);\n\t\turb->pipe = dev->out_pipe;\n\t\tretval = test_halt(dev, ep, urb);\n\t}\ndone:\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\nstatic int toggle_sync_simple(struct usbtest_dev *dev)\n{\n\tint\t\t\tep;\n\tint\t\t\tretval = 0;\n\tstruct urb\t\t*urb;\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tunsigned\t\tmaxp = get_maxpacket(udev, dev->out_pipe);\n\n\t \n\turb = simple_alloc_urb(udev, 0,  2 * maxp, 0);\n\tif (urb == NULL)\n\t\treturn -ENOMEM;\n\n\turb->transfer_flags |= URB_ZERO_PACKET;\n\n\tep = usb_pipeendpoint(dev->out_pipe);\n\turb->pipe = dev->out_pipe;\n\tretval = test_toggle_sync(dev, ep, urb);\n\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n \n\n \nstatic int ctrl_out(struct usbtest_dev *dev,\n\t\tunsigned count, unsigned length, unsigned vary, unsigned offset)\n{\n\tunsigned\t\ti, j, len;\n\tint\t\t\tretval;\n\tu8\t\t\t*buf;\n\tchar\t\t\t*what = \"?\";\n\tstruct usb_device\t*udev;\n\n\tif (length < 1 || length > 0xffff || vary >= length)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(length + offset, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf += offset;\n\tudev = testdev_to_usbdev(dev);\n\tlen = length;\n\tretval = 0;\n\n\t \n\tfor (i = 0; i < count; i++) {\n\t\t \n\t\tfor (j = 0; j < len; j++)\n\t\t\tbuf[j] = (u8)(i + j);\n\t\tretval = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\t0x5b, USB_DIR_OUT|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_SET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"write\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, wlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tretval = usb_control_msg(udev, usb_rcvctrlpipe(udev, 0),\n\t\t\t\t0x5c, USB_DIR_IN|USB_TYPE_VENDOR,\n\t\t\t\t0, 0, buf, len, USB_CTRL_GET_TIMEOUT);\n\t\tif (retval != len) {\n\t\t\twhat = \"read\";\n\t\t\tif (retval >= 0) {\n\t\t\t\tERROR(dev, \"ctrl_out, rlen %d (expected %d)\\n\",\n\t\t\t\t\t\tretval, len);\n\t\t\t\tretval = -EBADMSG;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tfor (j = 0; j < len; j++) {\n\t\t\tif (buf[j] != (u8)(i + j)) {\n\t\t\t\tERROR(dev, \"ctrl_out, byte %d is %d not %d\\n\",\n\t\t\t\t\tj, buf[j], (u8)(i + j));\n\t\t\t\tretval = -EBADMSG;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (retval < 0) {\n\t\t\twhat = \"verify\";\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += vary;\n\n\t\t \n\t\tif (len > length)\n\t\t\tlen = realworld ? 1 : 0;\n\t}\n\n\tif (retval < 0)\n\t\tERROR(dev, \"ctrl_out %s failed, code %d, count %d\\n\",\n\t\t\twhat, retval, i);\n\n\tkfree(buf - offset);\n\treturn retval;\n}\n\n \n\n \n\nstruct transfer_context {\n\tunsigned\t\tcount;\n\tunsigned\t\tpending;\n\tspinlock_t\t\tlock;\n\tstruct completion\tdone;\n\tint\t\t\tsubmit_error;\n\tunsigned long\t\terrors;\n\tunsigned long\t\tpacket_count;\n\tstruct usbtest_dev\t*dev;\n\tbool\t\t\tis_iso;\n};\n\nstatic void complicated_callback(struct urb *urb)\n{\n\tstruct transfer_context\t*ctx = urb->context;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ctx->lock, flags);\n\tctx->count--;\n\n\tctx->packet_count += urb->number_of_packets;\n\tif (urb->error_count > 0)\n\t\tctx->errors += urb->error_count;\n\telse if (urb->status != 0)\n\t\tctx->errors += (ctx->is_iso ? urb->number_of_packets : 1);\n\telse if (urb->actual_length != urb->transfer_buffer_length)\n\t\tctx->errors++;\n\telse if (check_guard_bytes(ctx->dev, urb) != 0)\n\t\tctx->errors++;\n\n\tif (urb->status == 0 && ctx->count > (ctx->pending - 1)\n\t\t\t&& !ctx->submit_error) {\n\t\tint status = usb_submit_urb(urb, GFP_ATOMIC);\n\t\tswitch (status) {\n\t\tcase 0:\n\t\t\tgoto done;\n\t\tdefault:\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\t\"resubmit err %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\tfallthrough;\n\t\tcase -ENODEV:\t\t\t \n\t\tcase -ESHUTDOWN:\t\t \n\t\t\tctx->submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->pending--;\n\tif (ctx->pending == 0) {\n\t\tif (ctx->errors)\n\t\t\tdev_err(&ctx->dev->intf->dev,\n\t\t\t\t\"during the test, %lu errors out of %lu\\n\",\n\t\t\t\tctx->errors, ctx->packet_count);\n\t\tcomplete(&ctx->done);\n\t}\ndone:\n\tspin_unlock_irqrestore(&ctx->lock, flags);\n}\n\nstatic struct urb *iso_alloc_urb(\n\tstruct usb_device\t*udev,\n\tint\t\t\tpipe,\n\tstruct usb_endpoint_descriptor\t*desc,\n\tlong\t\t\tbytes,\n\tunsigned offset\n)\n{\n\tstruct urb\t\t*urb;\n\tunsigned\t\ti, maxp, packets;\n\n\tif (bytes < 0 || !desc)\n\t\treturn NULL;\n\n\tmaxp = usb_endpoint_maxp(desc);\n\tif (udev->speed >= USB_SPEED_SUPER)\n\t\tmaxp *= ss_isoc_get_packet_num(udev, pipe);\n\telse\n\t\tmaxp *= usb_endpoint_maxp_mult(desc);\n\n\tpackets = DIV_ROUND_UP(bytes, maxp);\n\n\turb = usb_alloc_urb(packets, GFP_KERNEL);\n\tif (!urb)\n\t\treturn urb;\n\turb->dev = udev;\n\turb->pipe = pipe;\n\n\turb->number_of_packets = packets;\n\turb->transfer_buffer_length = bytes;\n\turb->transfer_buffer = usb_alloc_coherent(udev, bytes + offset,\n\t\t\t\t\t\t\tGFP_KERNEL,\n\t\t\t\t\t\t\t&urb->transfer_dma);\n\tif (!urb->transfer_buffer) {\n\t\tusb_free_urb(urb);\n\t\treturn NULL;\n\t}\n\tif (offset) {\n\t\tmemset(urb->transfer_buffer, GUARD_BYTE, offset);\n\t\turb->transfer_buffer += offset;\n\t\turb->transfer_dma += offset;\n\t}\n\t \n\tmemset(urb->transfer_buffer,\n\t\t\tusb_pipein(urb->pipe) ? GUARD_BYTE : 0,\n\t\t\tbytes);\n\n\tfor (i = 0; i < packets; i++) {\n\t\t \n\t\turb->iso_frame_desc[i].length = min((unsigned) bytes, maxp);\n\t\tbytes -= urb->iso_frame_desc[i].length;\n\n\t\turb->iso_frame_desc[i].offset = maxp * i;\n\t}\n\n\turb->complete = complicated_callback;\n\t \n\turb->interval = 1 << (desc->bInterval - 1);\n\turb->transfer_flags = URB_ISO_ASAP | URB_NO_TRANSFER_DMA_MAP;\n\treturn urb;\n}\n\nstatic int\ntest_queue(struct usbtest_dev *dev, struct usbtest_param_32 *param,\n\t\tint pipe, struct usb_endpoint_descriptor *desc, unsigned offset)\n{\n\tstruct transfer_context\tcontext;\n\tstruct usb_device\t*udev;\n\tunsigned\t\ti;\n\tunsigned long\t\tpackets = 0;\n\tint\t\t\tstatus = 0;\n\tstruct urb\t\t**urbs;\n\n\tif (!param->sglen || param->iterations > UINT_MAX / param->sglen)\n\t\treturn -EINVAL;\n\n\tif (param->sglen > MAX_SGLEN)\n\t\treturn -EINVAL;\n\n\turbs = kcalloc(param->sglen, sizeof(*urbs), GFP_KERNEL);\n\tif (!urbs)\n\t\treturn -ENOMEM;\n\n\tmemset(&context, 0, sizeof(context));\n\tcontext.count = param->iterations * param->sglen;\n\tcontext.dev = dev;\n\tcontext.is_iso = !!desc;\n\tinit_completion(&context.done);\n\tspin_lock_init(&context.lock);\n\n\tudev = testdev_to_usbdev(dev);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (context.is_iso)\n\t\t\turbs[i] = iso_alloc_urb(udev, pipe, desc,\n\t\t\t\t\tparam->length, offset);\n\t\telse\n\t\t\turbs[i] = complicated_alloc_urb(udev, pipe,\n\t\t\t\t\tparam->length, 0);\n\n\t\tif (!urbs[i]) {\n\t\t\tstatus = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpackets += urbs[i]->number_of_packets;\n\t\turbs[i]->context = &context;\n\t}\n\tpackets *= param->iterations;\n\n\tif (context.is_iso) {\n\t\tint transaction_num;\n\n\t\tif (udev->speed >= USB_SPEED_SUPER)\n\t\t\ttransaction_num = ss_isoc_get_packet_num(udev, pipe);\n\t\telse\n\t\t\ttransaction_num = usb_endpoint_maxp_mult(desc);\n\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"iso period %d %sframes, wMaxPacket %d, transactions: %d\\n\",\n\t\t\t1 << (desc->bInterval - 1),\n\t\t\t(udev->speed >= USB_SPEED_HIGH) ? \"micro\" : \"\",\n\t\t\tusb_endpoint_maxp(desc),\n\t\t\ttransaction_num);\n\n\t\tdev_info(&dev->intf->dev,\n\t\t\t\"total %lu msec (%lu packets)\\n\",\n\t\t\t(packets * (1 << (desc->bInterval - 1)))\n\t\t\t\t/ ((udev->speed >= USB_SPEED_HIGH) ? 8 : 1),\n\t\t\tpackets);\n\t}\n\n\tspin_lock_irq(&context.lock);\n\tfor (i = 0; i < param->sglen; i++) {\n\t\t++context.pending;\n\t\tstatus = usb_submit_urb(urbs[i], GFP_ATOMIC);\n\t\tif (status < 0) {\n\t\t\tERROR(dev, \"submit iso[%d], error %d\\n\", i, status);\n\t\t\tif (i == 0) {\n\t\t\t\tspin_unlock_irq(&context.lock);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n\t\t\tsimple_free_urb(urbs[i]);\n\t\t\turbs[i] = NULL;\n\t\t\tcontext.pending--;\n\t\t\tcontext.submit_error = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock_irq(&context.lock);\n\n\twait_for_completion(&context.done);\n\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\t \n\tif (status != 0)\n\t\t;\n\telse if (context.submit_error)\n\t\tstatus = -EACCES;\n\telse if (context.errors >\n\t\t\t(context.is_iso ? context.packet_count / 10 : 0))\n\t\tstatus = -EIO;\n\n\tkfree(urbs);\n\treturn status;\n\nfail:\n\tfor (i = 0; i < param->sglen; i++) {\n\t\tif (urbs[i])\n\t\t\tsimple_free_urb(urbs[i]);\n\t}\n\n\tkfree(urbs);\n\treturn status;\n}\n\nstatic int test_unaligned_bulk(\n\tstruct usbtest_dev *tdev,\n\tint pipe,\n\tunsigned length,\n\tint iterations,\n\tunsigned transfer_flags,\n\tconst char *label)\n{\n\tint retval;\n\tstruct urb *urb = usbtest_alloc_urb(testdev_to_usbdev(tdev),\n\t\t\tpipe, length, transfer_flags, 1, 0, simple_callback);\n\n\tif (!urb)\n\t\treturn -ENOMEM;\n\n\tretval = simple_io(tdev, urb, iterations, 0, 0, label);\n\tsimple_free_urb(urb);\n\treturn retval;\n}\n\n \nstatic int\nusbtest_do_ioctl(struct usb_interface *intf, struct usbtest_param_32 *param)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usb_device\t*udev = testdev_to_usbdev(dev);\n\tstruct urb\t\t*urb;\n\tstruct scatterlist\t*sg;\n\tstruct usb_sg_request\treq;\n\tunsigned\t\ti;\n\tint\tretval = -EOPNOTSUPP;\n\n\tif (param->iterations <= 0)\n\t\treturn -EINVAL;\n\tif (param->sglen > MAX_SGLEN)\n\t\treturn -EINVAL;\n\t \n\tswitch (param->test_num) {\n\n\tcase 0:\n\t\tdev_info(&intf->dev, \"TEST 0:  NOP\\n\");\n\t\tretval = 0;\n\t\tbreak;\n\n\t \n\tcase 1:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 1:  write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test1\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 2:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 2:  read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test2\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 3:\n\t\tif (dev->out_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 3:  write/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test3\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 4:\n\t\tif (dev->in_pipe == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 4:  read/%d 0..%d bytes %u times\\n\",\n\t\t\t\tparam->vary, param->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_pipe, param->length, 0);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, param->vary,\n\t\t\t\t\t0, \"test4\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\n\t \n\tcase 5:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 5:  write %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\tcase 6:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 6:  read %d sglists %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\t0, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 7:\n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 7:  write/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->out_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = perform_sglist(dev, param->iterations, dev->out_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\tcase 8:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || param->vary == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 8:  read/%d %d sglists %d entries 0..%d bytes\\n\",\n\t\t\t\tparam->vary, param->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tsg = alloc_sglist(param->sglen, param->length,\n\t\t\t\tparam->vary, dev, dev->in_pipe);\n\t\tif (!sg) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = perform_sglist(dev, param->iterations, dev->in_pipe,\n\t\t\t\t&req, sg, param->sglen);\n\t\tfree_sglist(sg, param->sglen);\n\t\tbreak;\n\n\t \n\tcase 9:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 9:  ch9 (subset) control tests, %d times\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--;  )\n\t\t\tretval = ch9_postconfig(dev);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"ch9 subset failed, \"\n\t\t\t\t\t\"iterations left %d\\n\", i);\n\t\tbreak;\n\n\t \n\tcase 10:\n\t\tretval = 0;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 10:  queue %d control calls, %d times\\n\",\n\t\t\t\tparam->sglen,\n\t\t\t\tparam->iterations);\n\t\tretval = test_ctrl_queue(dev, param);\n\t\tbreak;\n\n\t \n\tcase 11:\n\t\tif (dev->in_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 11:  unlink %d reads of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--;  )\n\t\t\tretval = unlink_simple(dev, dev->in_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink reads failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\tcase 12:\n\t\tif (dev->out_pipe == 0 || !param->length)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 12:  unlink %d writes of %d\\n\",\n\t\t\t\tparam->iterations, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i--;  )\n\t\t\tretval = unlink_simple(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->length);\n\t\tif (retval)\n\t\t\tdev_err(&intf->dev, \"unlink writes failed %d, \"\n\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\tbreak;\n\n\t \n\tcase 13:\n\t\tif (dev->out_pipe == 0 && dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 13:  set/clear %d halts\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i--;  )\n\t\t\tretval = halt_simple(dev);\n\n\t\tif (retval)\n\t\t\tERROR(dev, \"halts failed, iterations left %d\\n\", i);\n\t\tbreak;\n\n\t \n\tcase 14:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev, \"TEST 14:  %d ep0out, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 0);\n\t\tbreak;\n\n\t \n\tcase 15:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 15:  write %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t \n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 0);\n\t\tbreak;\n\n\t \n\tcase 16:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 16:  read %d iso, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\t \n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 0);\n\t\tbreak;\n\n\t \n\n\t \n\tcase 17:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 17:  write odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test17\");\n\t\tbreak;\n\n\tcase 18:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 18:  read odd addr %d bytes %u times core map\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\t0, \"test18\");\n\t\tbreak;\n\n\t \n\tcase 19:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 19:  write odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->out_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test19\");\n\t\tbreak;\n\n\tcase 20:\n\t\tif (dev->in_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 20:  read odd addr %d bytes %u times premapped\\n\",\n\t\t\tparam->length, param->iterations);\n\n\t\tretval = test_unaligned_bulk(\n\t\t\t\tdev, dev->in_pipe,\n\t\t\t\tparam->length, param->iterations,\n\t\t\t\tURB_NO_TRANSFER_DMA_MAP, \"test20\");\n\t\tbreak;\n\n\t \n\tcase 21:\n\t\tif (!dev->info->ctrl_out)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 21:  %d ep0out odd addr, %d..%d vary %d\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\trealworld ? 1 : 0, param->length,\n\t\t\t\tparam->vary);\n\t\tretval = ctrl_out(dev, param->iterations,\n\t\t\t\tparam->length, param->vary, 1);\n\t\tbreak;\n\n\t \n\tcase 22:\n\t\tif (dev->out_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 22:  write %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_iso_pipe, dev->iso_out, 1);\n\t\tbreak;\n\n\tcase 23:\n\t\tif (dev->in_iso_pipe == 0 || param->sglen == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 23:  read %d iso odd, %d entries of %d bytes\\n\",\n\t\t\t\tparam->iterations,\n\t\t\t\tparam->sglen, param->length);\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_iso_pipe, dev->iso_in, 1);\n\t\tbreak;\n\n\t \n\tcase 24:\n\t\tif (dev->out_pipe == 0 || !param->length || param->sglen < 4)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 24:  unlink from %d queues of \"\n\t\t\t\t\"%d %d-byte writes\\n\",\n\t\t\t\tparam->iterations, param->sglen, param->length);\n\t\tfor (i = param->iterations; retval == 0 && i > 0; --i) {\n\t\t\tretval = unlink_queued(dev, dev->out_pipe,\n\t\t\t\t\t\tparam->sglen, param->length);\n\t\t\tif (retval) {\n\t\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"unlink queued writes failed %d, \"\n\t\t\t\t\t\"iterations left %d\\n\", retval, i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\t \n\tcase 25:\n\t\tif (dev->out_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 25: write %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->out_int_pipe, param->length,\n\t\t\t\tdev->int_out->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test25\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 26:\n\t\tif (dev->in_int_pipe == 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\t\"TEST 26: read %d bytes %u times\\n\",\n\t\t\t\tparam->length, param->iterations);\n\t\turb = simple_alloc_urb(udev, dev->in_int_pipe, param->length,\n\t\t\t\tdev->int_in->bInterval);\n\t\tif (!urb) {\n\t\t\tretval = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tretval = simple_io(dev, urb, param->iterations, 0, 0, \"test26\");\n\t\tsimple_free_urb(urb);\n\t\tbreak;\n\tcase 27:\n\t\t \n\t\tif (dev->out_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 27: bulk write %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->out_pipe, NULL, 0);\n\t\tbreak;\n\tcase 28:\n\t\tif (dev->in_pipe == 0 || param->sglen == 0 || pattern != 0)\n\t\t\tbreak;\n\t\tdev_info(&intf->dev,\n\t\t\t\"TEST 28: bulk read %dMbytes\\n\", (param->iterations *\n\t\t\tparam->sglen * param->length) / (1024 * 1024));\n\t\tretval = test_queue(dev, param,\n\t\t\t\tdev->in_pipe, NULL, 0);\n\t\tbreak;\n\t \n\tcase 29:\n\t\tif (dev->out_pipe == 0)\n\t\t\tbreak;\n\t\tretval = 0;\n\t\tdev_info(&intf->dev, \"TEST 29: Clear toggle between bulk writes %d times\\n\",\n\t\t\t\tparam->iterations);\n\t\tfor (i = param->iterations; retval == 0 && i > 0; --i)\n\t\t\tretval = toggle_sync_simple(dev);\n\n\t\tif (retval)\n\t\t\tERROR(dev, \"toggle sync failed, iterations left %d\\n\",\n\t\t\t      i);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\n \n\n \n\nstatic int\nusbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)\n{\n\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\tstruct usbtest_param_64 *param_64 = buf;\n\tstruct usbtest_param_32 temp;\n\tstruct usbtest_param_32 *param_32 = buf;\n\tstruct timespec64 start;\n\tstruct timespec64 end;\n\tstruct timespec64 duration;\n\tint retval = -EOPNOTSUPP;\n\n\t \n\n\tpattern = mod_pattern;\n\n\tif (mutex_lock_interruptible(&dev->lock))\n\t\treturn -ERESTARTSYS;\n\n\t \n\n\t \n\tif (dev->info->alt >= 0) {\n\t\tif (intf->altsetting->desc.bInterfaceNumber) {\n\t\t\tretval = -ENODEV;\n\t\t\tgoto free_mutex;\n\t\t}\n\t\tretval = set_altsetting(dev, dev->info->alt);\n\t\tif (retval) {\n\t\t\tdev_err(&intf->dev,\n\t\t\t\t\t\"set altsetting to %d failed, %d\\n\",\n\t\t\t\t\tdev->info->alt, retval);\n\t\t\tgoto free_mutex;\n\t\t}\n\t}\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_64:\n\t\ttemp.test_num = param_64->test_num;\n\t\ttemp.iterations = param_64->iterations;\n\t\ttemp.length = param_64->length;\n\t\ttemp.sglen = param_64->sglen;\n\t\ttemp.vary = param_64->vary;\n\t\tparam_32 = &temp;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_32:\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EOPNOTSUPP;\n\t\tgoto free_mutex;\n\t}\n\n\tktime_get_ts64(&start);\n\n\tretval = usbtest_do_ioctl(intf, param_32);\n\tif (retval < 0)\n\t\tgoto free_mutex;\n\n\tktime_get_ts64(&end);\n\n\tduration = timespec64_sub(end, start);\n\n\ttemp.duration_sec = duration.tv_sec;\n\ttemp.duration_usec = duration.tv_nsec/NSEC_PER_USEC;\n\n\tswitch (code) {\n\tcase USBTEST_REQUEST_32:\n\t\tparam_32->duration_sec = temp.duration_sec;\n\t\tparam_32->duration_usec = temp.duration_usec;\n\t\tbreak;\n\n\tcase USBTEST_REQUEST_64:\n\t\tparam_64->duration_sec = temp.duration_sec;\n\t\tparam_64->duration_usec = temp.duration_usec;\n\t\tbreak;\n\t}\n\nfree_mutex:\n\tmutex_unlock(&dev->lock);\n\treturn retval;\n}\n\n \n\nstatic unsigned force_interrupt;\nmodule_param(force_interrupt, uint, 0);\nMODULE_PARM_DESC(force_interrupt, \"0 = test default; else interrupt\");\n\n#ifdef\tGENERIC\nstatic unsigned short vendor;\nmodule_param(vendor, ushort, 0);\nMODULE_PARM_DESC(vendor, \"vendor code (from usb-if)\");\n\nstatic unsigned short product;\nmodule_param(product, ushort, 0);\nMODULE_PARM_DESC(product, \"product code (from vendor)\");\n#endif\n\nstatic int\nusbtest_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_device\t*udev;\n\tstruct usbtest_dev\t*dev;\n\tstruct usbtest_info\t*info;\n\tchar\t\t\t*rtest, *wtest;\n\tchar\t\t\t*irtest, *iwtest;\n\tchar\t\t\t*intrtest, *intwtest;\n\n\tudev = interface_to_usbdev(intf);\n\n#ifdef\tGENERIC\n\t \n\tif (id->match_flags == 0) {\n\t\t \n\t\tif (!vendor || le16_to_cpu(udev->descriptor.idVendor) != (u16)vendor)\n\t\t\treturn -ENODEV;\n\t\tif (product && le16_to_cpu(udev->descriptor.idProduct) != (u16)product)\n\t\t\treturn -ENODEV;\n\t\tdev_info(&intf->dev, \"matched module params, \"\n\t\t\t\t\t\"vend=0x%04x prod=0x%04x\\n\",\n\t\t\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\t\t\tle16_to_cpu(udev->descriptor.idProduct));\n\t}\n#endif\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinfo = (struct usbtest_info *) id->driver_info;\n\tdev->info = info;\n\tmutex_init(&dev->lock);\n\n\tdev->intf = intf;\n\n\t \n\tdev->buf = kmalloc(TBUF_SIZE, GFP_KERNEL);\n\tif (dev->buf == NULL) {\n\t\tkfree(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\trtest = wtest = \"\";\n\tirtest = iwtest = \"\";\n\tintrtest = intwtest = \"\";\n\tif (force_interrupt || udev->speed == USB_SPEED_LOW) {\n\t\tif (info->ep_in) {\n\t\t\tdev->in_pipe = usb_rcvintpipe(udev, info->ep_in);\n\t\t\trtest = \" intr-in\";\n\t\t}\n\t\tif (info->ep_out) {\n\t\t\tdev->out_pipe = usb_sndintpipe(udev, info->ep_out);\n\t\t\twtest = \" intr-out\";\n\t\t}\n\t} else {\n\t\tif (override_alt >= 0 || info->autoconf) {\n\t\t\tint status;\n\n\t\t\tstatus = get_endpoints(dev, intf);\n\t\t\tif (status < 0) {\n\t\t\t\tWARNING(dev, \"couldn't get endpoints, %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t\t\tkfree(dev->buf);\n\t\t\t\tkfree(dev);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\t \n\t\t} else {\n\t\t\tif (info->ep_in)\n\t\t\t\tdev->in_pipe = usb_rcvbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_in);\n\t\t\tif (info->ep_out)\n\t\t\t\tdev->out_pipe = usb_sndbulkpipe(udev,\n\t\t\t\t\t\t\tinfo->ep_out);\n\t\t}\n\t\tif (dev->in_pipe)\n\t\t\trtest = \" bulk-in\";\n\t\tif (dev->out_pipe)\n\t\t\twtest = \" bulk-out\";\n\t\tif (dev->in_iso_pipe)\n\t\t\tirtest = \" iso-in\";\n\t\tif (dev->out_iso_pipe)\n\t\t\tiwtest = \" iso-out\";\n\t\tif (dev->in_int_pipe)\n\t\t\tintrtest = \" int-in\";\n\t\tif (dev->out_int_pipe)\n\t\t\tintwtest = \" int-out\";\n\t}\n\n\tusb_set_intfdata(intf, dev);\n\tdev_info(&intf->dev, \"%s\\n\", info->name);\n\tdev_info(&intf->dev, \"%s {control%s%s%s%s%s%s%s} tests%s\\n\",\n\t\t\tusb_speed_string(udev->speed),\n\t\t\tinfo->ctrl_out ? \" in/out\" : \"\",\n\t\t\trtest, wtest,\n\t\t\tirtest, iwtest,\n\t\t\tintrtest, intwtest,\n\t\t\tinfo->alt >= 0 ? \" (+alt)\" : \"\");\n\treturn 0;\n}\n\nstatic int usbtest_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int usbtest_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\n\nstatic void usbtest_disconnect(struct usb_interface *intf)\n{\n\tstruct usbtest_dev\t*dev = usb_get_intfdata(intf);\n\n\tusb_set_intfdata(intf, NULL);\n\tdev_dbg(&intf->dev, \"disconnect\\n\");\n\tkfree(dev->buf);\n\tkfree(dev);\n}\n\n \n\n \nstatic struct usbtest_info ez1_info = {\n\t.name\t\t= \"EZ-USB device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n \nstatic struct usbtest_info ez2_info = {\n\t.name\t\t= \"FX2 device\",\n\t.ep_in\t\t= 6,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n};\n\n \nstatic struct usbtest_info fw_info = {\n\t.name\t\t= \"usb test device\",\n\t.ep_in\t\t= 2,\n\t.ep_out\t\t= 2,\n\t.alt\t\t= 1,\n\t.autoconf\t= 1,\t\t \n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\t\t \n};\n\n \nstatic struct usbtest_info gz_info = {\n\t.name\t\t= \"Linux gadget zero\",\n\t.autoconf\t= 1,\n\t.ctrl_out\t= 1,\n\t.iso\t\t= 1,\n\t.intr\t\t= 1,\n\t.alt\t\t= 0,\n};\n\nstatic struct usbtest_info um_info = {\n\t.name\t\t= \"Linux user mode test driver\",\n\t.autoconf\t= 1,\n\t.alt\t\t= -1,\n};\n\nstatic struct usbtest_info um2_info = {\n\t.name\t\t= \"Linux user mode ISO test driver\",\n\t.autoconf\t= 1,\n\t.iso\t\t= 1,\n\t.alt\t\t= -1,\n};\n\n#ifdef IBOT2\n \nstatic struct usbtest_info ibot2_info = {\n\t.name\t\t= \"iBOT2 webcam\",\n\t.ep_in\t\t= 2,\n\t.alt\t\t= -1,\n};\n#endif\n\n#ifdef GENERIC\n \nstatic struct usbtest_info generic_info = {\n\t.name\t\t= \"Generic USB device\",\n\t.alt\t\t= -1,\n};\n#endif\n\n\nstatic const struct usb_device_id id_table[] = {\n\n\t \n\n\t \n\n\t \n\t{ USB_DEVICE(0x0547, 0x2235),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0x0547, 0x0080),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0x04b4, 0x8613),\n\t\t.driver_info = (unsigned long) &ez2_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0xfff0, 0xfff0),\n\t\t.driver_info = (unsigned long) &fw_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0x0525, 0xa4a0),\n\t\t.driver_info = (unsigned long) &gz_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0x0525, 0xa4a4),\n\t\t.driver_info = (unsigned long) &um_info,\n\t},\n\n\t \n\t{ USB_DEVICE(0x0525, 0xa4a3),\n\t\t.driver_info = (unsigned long) &um2_info,\n\t},\n\n#ifdef KEYSPAN_19Qi\n\t \n\t \n\t{ USB_DEVICE(0x06cd, 0x010b),\n\t\t.driver_info = (unsigned long) &ez1_info,\n\t},\n#endif\n\n\t \n\n#ifdef IBOT2\n\t \n\t \n\t{ USB_DEVICE(0x0b62, 0x0059),\n\t\t.driver_info = (unsigned long) &ibot2_info,\n\t},\n#endif\n\n\t \n\n#ifdef GENERIC\n\t \n\t{ .driver_info = (unsigned long) &generic_info, },\n#endif\n\n\t \n\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_driver usbtest_driver = {\n\t.name =\t\t\"usbtest\",\n\t.id_table =\tid_table,\n\t.probe =\tusbtest_probe,\n\t.unlocked_ioctl = usbtest_ioctl,\n\t.disconnect =\tusbtest_disconnect,\n\t.suspend =\tusbtest_suspend,\n\t.resume =\tusbtest_resume,\n};\n\n \n\nstatic int __init usbtest_init(void)\n{\n#ifdef GENERIC\n\tif (vendor)\n\t\tpr_debug(\"params: vend=0x%04x prod=0x%04x\\n\", vendor, product);\n#endif\n\treturn usb_register(&usbtest_driver);\n}\nmodule_init(usbtest_init);\n\nstatic void __exit usbtest_exit(void)\n{\n\tusb_deregister(&usbtest_driver);\n}\nmodule_exit(usbtest_exit);\n\nMODULE_DESCRIPTION(\"USB Core/HCD Testing Driver\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}