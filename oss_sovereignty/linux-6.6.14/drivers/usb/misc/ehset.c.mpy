{
  "module_name": "ehset.c",
  "hash_id": "fa0b227c46e2193e6794ee609a484321e2ff0f628a32fdf37383f6ce214e7539",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/ehset.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/ch11.h>\n\n#define TEST_SE0_NAK_PID\t\t\t0x0101\n#define TEST_J_PID\t\t\t\t0x0102\n#define TEST_K_PID\t\t\t\t0x0103\n#define TEST_PACKET_PID\t\t\t\t0x0104\n#define TEST_HS_HOST_PORT_SUSPEND_RESUME\t0x0106\n#define TEST_SINGLE_STEP_GET_DEV_DESC\t\t0x0107\n#define TEST_SINGLE_STEP_SET_FEATURE\t\t0x0108\n\nextern const struct usb_device_id *usb_device_match_id(struct usb_device *udev,\n\t\t\t\t\t\tconst struct usb_device_id *id);\n\n \nstatic const struct usb_device_id ehset_hub_list[] = {\n\t{ USB_DEVICE(0x0424, 0x4502) },\n\t{ USB_DEVICE(0x0424, 0x4913) },\n\t{ USB_DEVICE(0x0451, 0x8027) },\n\t{ }\n};\n\nstatic int ehset_prepare_port_for_testing(struct usb_device *hub_udev, u16 portnum)\n{\n\tint ret = 0;\n\n\t \n\tif (usb_device_match_id(hub_udev, ehset_hub_list)) {\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_CLEAR_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_ENABLE,\n\t\t\t\t\t   portnum, NULL, 0, 1000, GFP_KERNEL);\n\t\t \n\t\tmsleep(100);\n\t} else {\n\t\t \n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_SUSPEND,\n\t\t\t\t\t   portnum, NULL, 0, 1000, GFP_KERNEL);\n\t}\n\treturn ret;\n}\n\nstatic int ehset_probe(struct usb_interface *intf,\n\t\t       const struct usb_device_id *id)\n{\n\tint ret = -EINVAL;\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct usb_device *hub_udev = dev->parent;\n\tstruct usb_device_descriptor buf;\n\tu8 portnum = dev->portnum;\n\tu16 test_pid = le16_to_cpu(dev->descriptor.idProduct);\n\n\tswitch (test_pid) {\n\tcase TEST_SE0_NAK_PID:\n\t\tret = ehset_prepare_port_for_testing(hub_udev, portnum);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_TEST,\n\t\t\t\t\t   (USB_TEST_SE0_NAK << 8) | portnum,\n\t\t\t\t\t   NULL, 0, 1000, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_J_PID:\n\t\tret = ehset_prepare_port_for_testing(hub_udev, portnum);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_TEST,\n\t\t\t\t\t   (USB_TEST_J << 8) | portnum, NULL, 0,\n\t\t\t\t\t   1000, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_K_PID:\n\t\tret = ehset_prepare_port_for_testing(hub_udev, portnum);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_TEST,\n\t\t\t\t\t   (USB_TEST_K << 8) | portnum, NULL, 0,\n\t\t\t\t\t   1000, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_PACKET_PID:\n\t\tret = ehset_prepare_port_for_testing(hub_udev, portnum);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_TEST,\n\t\t\t\t\t   (USB_TEST_PACKET << 8) | portnum,\n\t\t\t\t\t   NULL, 0, 1000, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_HS_HOST_PORT_SUSPEND_RESUME:\n\t\t \n\t\tmsleep(15 * 1000);\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_SUSPEND,\n\t\t\t\t\t   portnum, NULL, 0, 1000, GFP_KERNEL);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tmsleep(15 * 1000);\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_CLEAR_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_SUSPEND,\n\t\t\t\t\t   portnum, NULL, 0, 1000, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_SINGLE_STEP_GET_DEV_DESC:\n\t\t \n\t\tmsleep(15 * 1000);\n\n\t\tret = usb_control_msg_recv(dev, 0, USB_REQ_GET_DESCRIPTOR,\n\t\t\t\t\t   USB_DIR_IN, USB_DT_DEVICE << 8, 0,\n\t\t\t\t\t   &buf, USB_DT_DEVICE_SIZE,\n\t\t\t\t\t   USB_CTRL_GET_TIMEOUT, GFP_KERNEL);\n\t\tbreak;\n\tcase TEST_SINGLE_STEP_SET_FEATURE:\n\t\t \n\t\tif (hub_udev != dev->bus->root_hub) {\n\t\t\tdev_err(&intf->dev, \"SINGLE_STEP_SET_FEATURE test only supported on root hub\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tret = usb_control_msg_send(hub_udev, 0, USB_REQ_SET_FEATURE,\n\t\t\t\t\t   USB_RT_PORT, USB_PORT_FEAT_TEST,\n\t\t\t\t\t   (6 << 8) | portnum, NULL, 0,\n\t\t\t\t\t   60 * 1000, GFP_KERNEL);\n\n\t\tbreak;\n\tdefault:\n\t\tdev_err(&intf->dev, \"%s: unsupported PID: 0x%x\\n\",\n\t\t\t__func__, test_pid);\n\t}\n\n\treturn ret;\n}\n\nstatic void ehset_disconnect(struct usb_interface *intf)\n{\n}\n\nstatic const struct usb_device_id ehset_id_table[] = {\n\t{ USB_DEVICE(0x1a0a, TEST_SE0_NAK_PID) },\n\t{ USB_DEVICE(0x1a0a, TEST_J_PID) },\n\t{ USB_DEVICE(0x1a0a, TEST_K_PID) },\n\t{ USB_DEVICE(0x1a0a, TEST_PACKET_PID) },\n\t{ USB_DEVICE(0x1a0a, TEST_HS_HOST_PORT_SUSPEND_RESUME) },\n\t{ USB_DEVICE(0x1a0a, TEST_SINGLE_STEP_GET_DEV_DESC) },\n\t{ USB_DEVICE(0x1a0a, TEST_SINGLE_STEP_SET_FEATURE) },\n\t{ }\t\t\t \n};\nMODULE_DEVICE_TABLE(usb, ehset_id_table);\n\nstatic struct usb_driver ehset_driver = {\n\t.name =\t\t\"usb_ehset_test\",\n\t.probe =\tehset_probe,\n\t.disconnect =\tehset_disconnect,\n\t.id_table =\tehset_id_table,\n};\n\nmodule_usb_driver(ehset_driver);\n\nMODULE_DESCRIPTION(\"USB Driver for EHSET Test Fixture\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}