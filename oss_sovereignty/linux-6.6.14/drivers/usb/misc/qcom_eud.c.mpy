{
  "module_name": "qcom_eud.c",
  "hash_id": "ec67697f98089566ed7e856a88e6d75b6c38ad64d2181b2d8f4a4d16ffd05813",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/qcom_eud.c",
  "human_readable_source": "\n \n\n#include <linux/bitops.h>\n#include <linux/err.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/usb/role.h>\n\n#define EUD_REG_INT1_EN_MASK\t0x0024\n#define EUD_REG_INT_STATUS_1\t0x0044\n#define EUD_REG_CTL_OUT_1\t0x0074\n#define EUD_REG_VBUS_INT_CLR\t0x0080\n#define EUD_REG_CSR_EUD_EN\t0x1014\n#define EUD_REG_SW_ATTACH_DET\t0x1018\n#define EUD_REG_EUD_EN2\t\t0x0000\n\n#define EUD_ENABLE\t\tBIT(0)\n#define EUD_INT_PET_EUD\t\tBIT(0)\n#define EUD_INT_VBUS\t\tBIT(2)\n#define EUD_INT_SAFE_MODE\tBIT(4)\n#define EUD_INT_ALL\t\t(EUD_INT_VBUS | EUD_INT_SAFE_MODE)\n\nstruct eud_chip {\n\tstruct device\t\t\t*dev;\n\tstruct usb_role_switch\t\t*role_sw;\n\tvoid __iomem\t\t\t*base;\n\tvoid __iomem\t\t\t*mode_mgr;\n\tunsigned int\t\t\tint_status;\n\tint\t\t\t\tirq;\n\tbool\t\t\t\tenabled;\n\tbool\t\t\t\tusb_attached;\n};\n\nstatic int enable_eud(struct eud_chip *priv)\n{\n\twritel(EUD_ENABLE, priv->base + EUD_REG_CSR_EUD_EN);\n\twritel(EUD_INT_VBUS | EUD_INT_SAFE_MODE,\n\t\t\tpriv->base + EUD_REG_INT1_EN_MASK);\n\twritel(1, priv->mode_mgr + EUD_REG_EUD_EN2);\n\n\treturn usb_role_switch_set_role(priv->role_sw, USB_ROLE_DEVICE);\n}\n\nstatic void disable_eud(struct eud_chip *priv)\n{\n\twritel(0, priv->base + EUD_REG_CSR_EUD_EN);\n\twritel(0, priv->mode_mgr + EUD_REG_EUD_EN2);\n}\n\nstatic ssize_t enable_show(struct device *dev,\n\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct eud_chip *chip = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", chip->enabled);\n}\n\nstatic ssize_t enable_store(struct device *dev,\n\t\tstruct device_attribute *attr,\n\t\tconst char *buf, size_t count)\n{\n\tstruct eud_chip *chip = dev_get_drvdata(dev);\n\tbool enable;\n\tint ret;\n\n\tif (kstrtobool(buf, &enable))\n\t\treturn -EINVAL;\n\n\tif (enable) {\n\t\tret = enable_eud(chip);\n\t\tif (!ret)\n\t\t\tchip->enabled = enable;\n\t\telse\n\t\t\tdisable_eud(chip);\n\t} else {\n\t\tdisable_eud(chip);\n\t}\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(enable);\n\nstatic struct attribute *eud_attrs[] = {\n\t&dev_attr_enable.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(eud);\n\nstatic void usb_attach_detach(struct eud_chip *chip)\n{\n\tu32 reg;\n\n\t \n\treg = readl(chip->base + EUD_REG_CTL_OUT_1);\n\tchip->usb_attached = reg & EUD_INT_SAFE_MODE;\n}\n\nstatic void pet_eud(struct eud_chip *chip)\n{\n\tu32 reg;\n\tint ret;\n\n\t \n\treg = readl(chip->base + EUD_REG_SW_ATTACH_DET);\n\tif (reg & EUD_INT_PET_EUD) {\n\t\t \n\t\twritel(0, chip->base + EUD_REG_SW_ATTACH_DET);\n\t\t \n\t\tret = readl_poll_timeout(chip->base + EUD_REG_SW_ATTACH_DET,\n\t\t\t\t\treg, (reg == 0), 1, 100);\n\t\tif (ret) {\n\t\t\tdev_err(chip->dev, \"Detach pet failed\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\t \n\twritel(EUD_INT_PET_EUD, chip->base + EUD_REG_SW_ATTACH_DET);\n}\n\nstatic irqreturn_t handle_eud_irq(int irq, void *data)\n{\n\tstruct eud_chip *chip = data;\n\tu32 reg;\n\n\treg = readl(chip->base + EUD_REG_INT_STATUS_1);\n\tswitch (reg & EUD_INT_ALL) {\n\tcase EUD_INT_VBUS:\n\t\tusb_attach_detach(chip);\n\t\treturn IRQ_WAKE_THREAD;\n\tcase EUD_INT_SAFE_MODE:\n\t\tpet_eud(chip);\n\t\treturn IRQ_HANDLED;\n\tdefault:\n\t\treturn IRQ_NONE;\n\t}\n}\n\nstatic irqreturn_t handle_eud_irq_thread(int irq, void *data)\n{\n\tstruct eud_chip *chip = data;\n\tint ret;\n\n\tif (chip->usb_attached)\n\t\tret = usb_role_switch_set_role(chip->role_sw, USB_ROLE_DEVICE);\n\telse\n\t\tret = usb_role_switch_set_role(chip->role_sw, USB_ROLE_HOST);\n\tif (ret)\n\t\tdev_err(chip->dev, \"failed to set role switch\\n\");\n\n\t \n\twritel(BIT(0), chip->base + EUD_REG_VBUS_INT_CLR);\n\twritel(0, chip->base + EUD_REG_VBUS_INT_CLR);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic void eud_role_switch_release(void *data)\n{\n\tstruct eud_chip *chip = data;\n\n\tusb_role_switch_put(chip->role_sw);\n}\n\nstatic int eud_probe(struct platform_device *pdev)\n{\n\tstruct eud_chip *chip;\n\tint ret;\n\n\tchip = devm_kzalloc(&pdev->dev, sizeof(*chip), GFP_KERNEL);\n\tif (!chip)\n\t\treturn -ENOMEM;\n\n\tchip->dev = &pdev->dev;\n\n\tchip->role_sw = usb_role_switch_get(&pdev->dev);\n\tif (IS_ERR(chip->role_sw))\n\t\treturn dev_err_probe(chip->dev, PTR_ERR(chip->role_sw),\n\t\t\t\t\t\"failed to get role switch\\n\");\n\n\tret = devm_add_action_or_reset(chip->dev, eud_role_switch_release, chip);\n\tif (ret)\n\t\treturn dev_err_probe(chip->dev, ret,\n\t\t\t\t\"failed to add role switch release action\\n\");\n\n\tchip->base = devm_platform_ioremap_resource(pdev, 0);\n\tif (IS_ERR(chip->base))\n\t\treturn PTR_ERR(chip->base);\n\n\tchip->mode_mgr = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(chip->mode_mgr))\n\t\treturn PTR_ERR(chip->mode_mgr);\n\n\tchip->irq = platform_get_irq(pdev, 0);\n\tret = devm_request_threaded_irq(&pdev->dev, chip->irq, handle_eud_irq,\n\t\t\thandle_eud_irq_thread, IRQF_ONESHOT, NULL, chip);\n\tif (ret)\n\t\treturn dev_err_probe(chip->dev, ret, \"failed to allocate irq\\n\");\n\n\tenable_irq_wake(chip->irq);\n\n\tplatform_set_drvdata(pdev, chip);\n\n\treturn 0;\n}\n\nstatic void eud_remove(struct platform_device *pdev)\n{\n\tstruct eud_chip *chip = platform_get_drvdata(pdev);\n\n\tif (chip->enabled)\n\t\tdisable_eud(chip);\n\n\tdevice_init_wakeup(&pdev->dev, false);\n\tdisable_irq_wake(chip->irq);\n}\n\nstatic const struct of_device_id eud_dt_match[] = {\n\t{ .compatible = \"qcom,sc7280-eud\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, eud_dt_match);\n\nstatic struct platform_driver eud_driver = {\n\t.probe\t= eud_probe,\n\t.remove_new = eud_remove,\n\t.driver\t= {\n\t\t.name = \"qcom_eud\",\n\t\t.dev_groups = eud_groups,\n\t\t.of_match_table = eud_dt_match,\n\t},\n};\nmodule_platform_driver(eud_driver);\n\nMODULE_DESCRIPTION(\"QTI EUD driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}