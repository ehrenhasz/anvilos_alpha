{
  "module_name": "usbsevseg.c",
  "hash_id": "c528fef8e7272ccbd3163eac494675f196097dbb85035474c5615f95708b93c3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/usbsevseg.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/string.h>\n#include <linux/usb.h>\n\n\n#define DRIVER_AUTHOR \"Harrison Metzger <harrisonmetz@gmail.com>\"\n#define DRIVER_DESC \"USB 7 Segment Driver\"\n\n#define VENDOR_ID\t0x0fc5\n#define PRODUCT_ID\t0x1227\n#define MAXLEN\t\t8\n\n \nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(VENDOR_ID, PRODUCT_ID) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\n \nstatic const char *display_textmodes[] = {\"raw\", \"hex\", \"ascii\"};\n\nstruct usb_sevsegdev {\n\tstruct usb_device *udev;\n\tstruct usb_interface *intf;\n\n\tu8 powered;\n\tu8 mode_msb;\n\tu8 mode_lsb;\n\tu8 decimals[MAXLEN];\n\tu8 textmode;\n\tu8 text[MAXLEN];\n\tu16 textlength;\n\n\tu8 shadow_power;  \n\tu8 has_interface_pm;\n};\n\n \nstatic inline size_t my_memlen(const char *buf, size_t count)\n{\n\tif (count > 0 && buf[count-1] == '\\n')\n\t\treturn count - 1;\n\telse\n\t\treturn count;\n}\n\nstatic void update_display_powered(struct usb_sevsegdev *mydev)\n{\n\tint rc;\n\n\tif (mydev->powered && !mydev->has_interface_pm) {\n\t\trc = usb_autopm_get_interface(mydev->intf);\n\t\tif (rc < 0)\n\t\t\treturn;\n\t\tmydev->has_interface_pm = 1;\n\t}\n\n\tif (mydev->shadow_power != 1)\n\t\treturn;\n\n\trc = usb_control_msg_send(mydev->udev, 0, 0x12, 0x48,\n\t\t\t\t  (80 * 0x100) + 10,  \n\t\t\t\t  (0x00 * 0x100) + (mydev->powered ? 1 : 0),\n\t\t\t\t  NULL, 0, 2000, GFP_KERNEL);\n\tif (rc < 0)\n\t\tdev_dbg(&mydev->udev->dev, \"power retval = %d\\n\", rc);\n\n\tif (!mydev->powered && mydev->has_interface_pm) {\n\t\tusb_autopm_put_interface(mydev->intf);\n\t\tmydev->has_interface_pm = 0;\n\t}\n}\n\nstatic void update_display_mode(struct usb_sevsegdev *mydev)\n{\n\tint rc;\n\n\tif(mydev->shadow_power != 1)\n\t\treturn;\n\n\trc = usb_control_msg_send(mydev->udev, 0, 0x12, 0x48,\n\t\t\t\t  (82 * 0x100) + 10,  \n\t\t\t\t  (mydev->mode_msb * 0x100) + mydev->mode_lsb,\n\t\t\t\t  NULL, 0, 2000, GFP_NOIO);\n\n\tif (rc < 0)\n\t\tdev_dbg(&mydev->udev->dev, \"mode retval = %d\\n\", rc);\n}\n\nstatic void update_display_visual(struct usb_sevsegdev *mydev, gfp_t mf)\n{\n\tint rc;\n\tint i;\n\tunsigned char buffer[MAXLEN] = {0};\n\tu8 decimals = 0;\n\n\tif(mydev->shadow_power != 1)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < mydev->textlength; i++)\n\t\tbuffer[i] = mydev->text[mydev->textlength-1-i];\n\n\trc = usb_control_msg_send(mydev->udev, 0, 0x12, 0x48,\n\t\t\t\t  (85 * 0x100) + 10,  \n\t\t\t\t  (0 * 0x100) + mydev->textmode,  \n\t\t\t\t  &buffer, mydev->textlength, 2000, mf);\n\n\tif (rc < 0)\n\t\tdev_dbg(&mydev->udev->dev, \"write retval = %d\\n\", rc);\n\n\t \n\tfor (i = 0; i < sizeof(mydev->decimals); i++)\n\t\tdecimals |= mydev->decimals[i] << i;\n\n\trc = usb_control_msg_send(mydev->udev, 0, 0x12, 0x48,\n\t\t\t\t  (86 * 0x100) + 10,  \n\t\t\t\t  (0 * 0x100) + decimals,  \n\t\t\t\t  NULL, 0, 2000, mf);\n\n\tif (rc < 0)\n\t\tdev_dbg(&mydev->udev->dev, \"decimal retval = %d\\n\", rc);\n}\n\n#define MYDEV_ATTR_SIMPLE_UNSIGNED(name, update_fcn)\t\t\\\nstatic ssize_t name##_show(struct device *dev,\t\t\t\\\n\tstruct device_attribute *attr, char *buf) \t\t\\\n{\t\t\t\t\t\t\t\t\\\n\tstruct usb_interface *intf = to_usb_interface(dev);\t\\\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn sprintf(buf, \"%u\\n\", mydev->name);\t\t\\\n}\t\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\nstatic ssize_t name##_store(struct device *dev,\t\t\t\\\n\tstruct device_attribute *attr, const char *buf, size_t count) \\\n{\t\t\t\t\t\t\t\t\\\n\tstruct usb_interface *intf = to_usb_interface(dev);\t\\\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\t\\\n\t\t\t\t\t\t\t\t\\\n\tmydev->name = simple_strtoul(buf, NULL, 10);\t\t\\\n\tupdate_fcn(mydev); \t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\treturn count;\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\t\\\nstatic DEVICE_ATTR_RW(name);\n\nstatic ssize_t text_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\n\treturn sysfs_emit(buf, \"%s\\n\", mydev->text);\n}\n\nstatic ssize_t text_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\tsize_t end = my_memlen(buf, count);\n\n\tif (end > sizeof(mydev->text))\n\t\treturn -EINVAL;\n\n\tmemset(mydev->text, 0, sizeof(mydev->text));\n\tmydev->textlength = end;\n\n\tif (end > 0)\n\t\tmemcpy(mydev->text, buf, end);\n\n\tupdate_display_visual(mydev, GFP_KERNEL);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(text);\n\nstatic ssize_t decimals_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\tint i;\n\tint pos;\n\n\tfor (i = 0; i < sizeof(mydev->decimals); i++) {\n\t\tpos = sizeof(mydev->decimals) - 1 - i;\n\t\tif (mydev->decimals[i] == 0)\n\t\t\tbuf[pos] = '0';\n\t\telse if (mydev->decimals[i] == 1)\n\t\t\tbuf[pos] = '1';\n\t\telse\n\t\t\tbuf[pos] = 'x';\n\t}\n\n\tbuf[sizeof(mydev->decimals)] = '\\n';\n\treturn sizeof(mydev->decimals) + 1;\n}\n\nstatic ssize_t decimals_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\tsize_t end = my_memlen(buf, count);\n\tint i;\n\n\tif (end > sizeof(mydev->decimals))\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < end; i++)\n\t\tif (buf[i] != '0' && buf[i] != '1')\n\t\t\treturn -EINVAL;\n\n\tmemset(mydev->decimals, 0, sizeof(mydev->decimals));\n\tfor (i = 0; i < end; i++)\n\t\tif (buf[i] == '1')\n\t\t\tmydev->decimals[end-1-i] = 1;\n\n\tupdate_display_visual(mydev, GFP_KERNEL);\n\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(decimals);\n\nstatic ssize_t textmode_show(struct device *dev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\tint i;\n\n\tbuf[0] = 0;\n\n\tfor (i = 0; i < ARRAY_SIZE(display_textmodes); i++) {\n\t\tif (mydev->textmode == i) {\n\t\t\tstrcat(buf, \" [\");\n\t\t\tstrcat(buf, display_textmodes[i]);\n\t\t\tstrcat(buf, \"] \");\n\t\t} else {\n\t\t\tstrcat(buf, \" \");\n\t\t\tstrcat(buf, display_textmodes[i]);\n\t\t\tstrcat(buf, \" \");\n\t\t}\n\t}\n\tstrcat(buf, \"\\n\");\n\n\n\treturn strlen(buf);\n}\n\nstatic ssize_t textmode_store(struct device *dev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_sevsegdev *mydev = usb_get_intfdata(intf);\n\tint i;\n\n\ti = sysfs_match_string(display_textmodes, buf);\n\tif (i < 0)\n\t\treturn i;\n\n\tmydev->textmode = i;\n\tupdate_display_visual(mydev, GFP_KERNEL);\n\treturn count;\n}\n\nstatic DEVICE_ATTR_RW(textmode);\n\n\nMYDEV_ATTR_SIMPLE_UNSIGNED(powered, update_display_powered);\nMYDEV_ATTR_SIMPLE_UNSIGNED(mode_msb, update_display_mode);\nMYDEV_ATTR_SIMPLE_UNSIGNED(mode_lsb, update_display_mode);\n\nstatic struct attribute *sevseg_attrs[] = {\n\t&dev_attr_powered.attr,\n\t&dev_attr_text.attr,\n\t&dev_attr_textmode.attr,\n\t&dev_attr_decimals.attr,\n\t&dev_attr_mode_msb.attr,\n\t&dev_attr_mode_lsb.attr,\n\tNULL\n};\nATTRIBUTE_GROUPS(sevseg);\n\nstatic int sevseg_probe(struct usb_interface *interface,\n\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_sevsegdev *mydev;\n\tint rc = -ENOMEM;\n\n\tmydev = kzalloc(sizeof(struct usb_sevsegdev), GFP_KERNEL);\n\tif (!mydev)\n\t\tgoto error_mem;\n\n\tmydev->udev = usb_get_dev(udev);\n\tmydev->intf = interface;\n\tusb_set_intfdata(interface, mydev);\n\n\t \n\tmydev->shadow_power = 1;  \n\tmydev->has_interface_pm = 0;  \n\n\t \n\tmydev->textmode = 0x02;  \n\tmydev->mode_msb = 0x06;  \n\tmydev->mode_lsb = 0x3f;  \n\n\tdev_info(&interface->dev, \"USB 7 Segment device now attached\\n\");\n\treturn 0;\n\nerror_mem:\n\treturn rc;\n}\n\nstatic void sevseg_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_sevsegdev *mydev;\n\n\tmydev = usb_get_intfdata(interface);\n\tusb_set_intfdata(interface, NULL);\n\tusb_put_dev(mydev->udev);\n\tkfree(mydev);\n\tdev_info(&interface->dev, \"USB 7 Segment now disconnected\\n\");\n}\n\nstatic int sevseg_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\tstruct usb_sevsegdev *mydev;\n\n\tmydev = usb_get_intfdata(intf);\n\tmydev->shadow_power = 0;\n\n\treturn 0;\n}\n\nstatic int sevseg_resume(struct usb_interface *intf)\n{\n\tstruct usb_sevsegdev *mydev;\n\n\tmydev = usb_get_intfdata(intf);\n\tmydev->shadow_power = 1;\n\tupdate_display_mode(mydev);\n\tupdate_display_visual(mydev, GFP_NOIO);\n\n\treturn 0;\n}\n\nstatic int sevseg_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_sevsegdev *mydev;\n\n\tmydev = usb_get_intfdata(intf);\n\tmydev->shadow_power = 1;\n\tupdate_display_mode(mydev);\n\tupdate_display_visual(mydev, GFP_NOIO);\n\n\treturn 0;\n}\n\nstatic struct usb_driver sevseg_driver = {\n\t.name =\t\t\"usbsevseg\",\n\t.probe =\tsevseg_probe,\n\t.disconnect =\tsevseg_disconnect,\n\t.suspend =\tsevseg_suspend,\n\t.resume =\tsevseg_resume,\n\t.reset_resume =\tsevseg_reset_resume,\n\t.id_table =\tid_table,\n\t.dev_groups =\tsevseg_groups,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(sevseg_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}