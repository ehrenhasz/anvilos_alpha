{
  "module_name": "uss720.c",
  "hash_id": "1091928aa39352221df2b47c405c2a68dc9cc0268156b7e66d8a2d6c2e10368f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/uss720.c",
  "human_readable_source": "\n \n\n \n\n \n\n#include <linux/module.h>\n#include <linux/socket.h>\n#include <linux/parport.h>\n#include <linux/init.h>\n#include <linux/usb.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kref.h>\n#include <linux/slab.h>\n#include <linux/sched/signal.h>\n\n#define DRIVER_AUTHOR \"Thomas M. Sailer, t.sailer@alumni.ethz.ch\"\n#define DRIVER_DESC \"USB Parport Cable driver for Cables using the Lucent Technologies USS720 Chip\"\n\n \n\nstruct parport_uss720_private {\n\tstruct usb_device *usbdev;\n\tstruct parport *pp;\n\tstruct kref ref_count;\n\t__u8 reg[7];   \n\tstruct list_head asynclist;\n\tspinlock_t asynclock;\n};\n\nstruct uss720_async_request {\n\tstruct parport_uss720_private *priv;\n\tstruct kref ref_count;\n\tstruct list_head asynclist;\n\tstruct completion compl;\n\tstruct urb *urb;\n\tstruct usb_ctrlrequest *dr;\n\t__u8 reg[7];\n};\n\n \n\nstatic void destroy_priv(struct kref *kref)\n{\n\tstruct parport_uss720_private *priv = container_of(kref, struct parport_uss720_private, ref_count);\n\n\tdev_dbg(&priv->usbdev->dev, \"destroying priv datastructure\\n\");\n\tusb_put_dev(priv->usbdev);\n\tpriv->usbdev = NULL;\n\tkfree(priv);\n}\n\nstatic void destroy_async(struct kref *kref)\n{\n\tstruct uss720_async_request *rq = container_of(kref, struct uss720_async_request, ref_count);\n\tstruct parport_uss720_private *priv = rq->priv;\n\tunsigned long flags;\n\n\tif (likely(rq->urb))\n\t\tusb_free_urb(rq->urb);\n\tkfree(rq->dr);\n\tspin_lock_irqsave(&priv->asynclock, flags);\n\tlist_del_init(&rq->asynclist);\n\tspin_unlock_irqrestore(&priv->asynclock, flags);\n\tkfree(rq);\n\tkref_put(&priv->ref_count, destroy_priv);\n}\n\n \n\nstatic void async_complete(struct urb *urb)\n{\n\tstruct uss720_async_request *rq;\n\tstruct parport *pp;\n\tstruct parport_uss720_private *priv;\n\tint status = urb->status;\n\n\trq = urb->context;\n\tpriv = rq->priv;\n\tpp = priv->pp;\n\tif (status) {\n\t\tdev_err(&urb->dev->dev, \"async_complete: urb error %d\\n\",\n\t\t\tstatus);\n\t} else if (rq->dr->bRequest == 3) {\n\t\tmemcpy(priv->reg, rq->reg, sizeof(priv->reg));\n#if 0\n\t\tdev_dbg(&priv->usbdev->dev, \"async_complete regs %7ph\\n\",\n\t\t\tpriv->reg);\n#endif\n\t\t \n\t\tif (rq->reg[2] & rq->reg[1] & 0x10 && pp)\n\t\t\tparport_generic_irq(pp);\n\t}\n\tcomplete(&rq->compl);\n\tkref_put(&rq->ref_count, destroy_async);\n}\n\nstatic struct uss720_async_request *submit_async_request(struct parport_uss720_private *priv,\n\t\t\t\t\t\t\t __u8 request, __u8 requesttype, __u16 value, __u16 index,\n\t\t\t\t\t\t\t gfp_t mem_flags)\n{\n\tstruct usb_device *usbdev;\n\tstruct uss720_async_request *rq;\n\tunsigned long flags;\n\tint ret;\n\n\tif (!priv)\n\t\treturn NULL;\n\tusbdev = priv->usbdev;\n\tif (!usbdev)\n\t\treturn NULL;\n\trq = kzalloc(sizeof(struct uss720_async_request), mem_flags);\n\tif (!rq)\n\t\treturn NULL;\n\tkref_init(&rq->ref_count);\n\tINIT_LIST_HEAD(&rq->asynclist);\n\tinit_completion(&rq->compl);\n\tkref_get(&priv->ref_count);\n\trq->priv = priv;\n\trq->urb = usb_alloc_urb(0, mem_flags);\n\tif (!rq->urb) {\n\t\tkref_put(&rq->ref_count, destroy_async);\n\t\treturn NULL;\n\t}\n\trq->dr = kmalloc(sizeof(*rq->dr), mem_flags);\n\tif (!rq->dr) {\n\t\tkref_put(&rq->ref_count, destroy_async);\n\t\treturn NULL;\n\t}\n\trq->dr->bRequestType = requesttype;\n\trq->dr->bRequest = request;\n\trq->dr->wValue = cpu_to_le16(value);\n\trq->dr->wIndex = cpu_to_le16(index);\n\trq->dr->wLength = cpu_to_le16((request == 3) ? sizeof(rq->reg) : 0);\n\tusb_fill_control_urb(rq->urb, usbdev, (requesttype & 0x80) ? usb_rcvctrlpipe(usbdev, 0) : usb_sndctrlpipe(usbdev, 0),\n\t\t\t     (unsigned char *)rq->dr,\n\t\t\t     (request == 3) ? rq->reg : NULL, (request == 3) ? sizeof(rq->reg) : 0, async_complete, rq);\n\t \n\tspin_lock_irqsave(&priv->asynclock, flags);\n\tlist_add_tail(&rq->asynclist, &priv->asynclist);\n\tspin_unlock_irqrestore(&priv->asynclock, flags);\n\tkref_get(&rq->ref_count);\n\tret = usb_submit_urb(rq->urb, mem_flags);\n\tif (!ret)\n\t\treturn rq;\n\tdestroy_async(&rq->ref_count);\n\tdev_err(&usbdev->dev, \"submit_async_request submit_urb failed with %d\\n\", ret);\n\treturn NULL;\n}\n\nstatic unsigned int kill_all_async_requests_priv(struct parport_uss720_private *priv)\n{\n\tstruct uss720_async_request *rq;\n\tunsigned long flags;\n\tunsigned int ret = 0;\n\n\tspin_lock_irqsave(&priv->asynclock, flags);\n\tlist_for_each_entry(rq, &priv->asynclist, asynclist) {\n\t\tusb_unlink_urb(rq->urb);\n\t\tret++;\n\t}\n\tspin_unlock_irqrestore(&priv->asynclock, flags);\n\treturn ret;\n}\n\n \n\nstatic int get_1284_register(struct parport *pp, unsigned char reg, unsigned char *val, gfp_t mem_flags)\n{\n\tstruct parport_uss720_private *priv;\n\tstruct uss720_async_request *rq;\n\tstatic const unsigned char regindex[9] = {\n\t\t4, 0, 1, 5, 5, 0, 2, 3, 6\n\t};\n\tint ret;\n\n\tif (!pp)\n\t\treturn -EIO;\n\tpriv = pp->private_data;\n\trq = submit_async_request(priv, 3, 0xc0, ((unsigned int)reg) << 8, 0, mem_flags);\n\tif (!rq) {\n\t\tdev_err(&priv->usbdev->dev, \"get_1284_register(%u) failed\",\n\t\t\t(unsigned int)reg);\n\t\treturn -EIO;\n\t}\n\tif (!val) {\n\t\tkref_put(&rq->ref_count, destroy_async);\n\t\treturn 0;\n\t}\n\tif (wait_for_completion_timeout(&rq->compl, HZ)) {\n\t\tret = rq->urb->status;\n\t\t*val = priv->reg[(reg >= 9) ? 0 : regindex[reg]];\n\t\tif (ret)\n\t\t\tprintk(KERN_WARNING \"get_1284_register: \"\n\t\t\t       \"usb error %d\\n\", ret);\n\t\tkref_put(&rq->ref_count, destroy_async);\n\t\treturn ret;\n\t}\n\tprintk(KERN_WARNING \"get_1284_register timeout\\n\");\n\tkill_all_async_requests_priv(priv);\n\treturn -EIO;\n}\n\nstatic int set_1284_register(struct parport *pp, unsigned char reg, unsigned char val, gfp_t mem_flags)\n{\n\tstruct parport_uss720_private *priv;\n\tstruct uss720_async_request *rq;\n\n\tif (!pp)\n\t\treturn -EIO;\n\tpriv = pp->private_data;\n\trq = submit_async_request(priv, 4, 0x40, (((unsigned int)reg) << 8) | val, 0, mem_flags);\n\tif (!rq) {\n\t\tdev_err(&priv->usbdev->dev, \"set_1284_register(%u,%u) failed\",\n\t\t\t(unsigned int)reg, (unsigned int)val);\n\t\treturn -EIO;\n\t}\n\tkref_put(&rq->ref_count, destroy_async);\n\treturn 0;\n}\n\n \n\n \n#define ECR_SPP 00\n#define ECR_PS2 01\n#define ECR_PPF 02\n#define ECR_ECP 03\n#define ECR_EPP 04\n\n \nstatic int change_mode(struct parport *pp, int m)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\n\tint mode;\n\t__u8 reg;\n\n\tif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\n\t\treturn -EIO;\n\t \n\tmode = (priv->reg[2] >> 5) & 0x7;\n\tif (mode == m)\n\t\treturn 0;\n\t \n\tif (mode > ECR_PS2 && m > ECR_PS2)\n\t\tif (change_mode(pp, ECR_PS2))\n\t\t\treturn -EIO;\n\n\tif (m <= ECR_PS2 && !(priv->reg[1] & 0x20)) {\n\t\t \n\t\tunsigned long expire = jiffies + pp->physport->cad->timeout;\n\t\tswitch (mode) {\n\t\tcase ECR_PPF:  \n\t\tcase ECR_ECP:  \n\t\t\t \n\t\t\tfor (;;) {\n\t\t\t\tif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\n\t\t\t\t\treturn -EIO;\n\t\t\t\tif (priv->reg[2] & 0x01)\n\t\t\t\t\tbreak;\n\t\t\t\tif (time_after_eq (jiffies, expire))\n\t\t\t\t\t \n\t\t\t\t\treturn -EBUSY;\n\t\t\t\tmsleep_interruptible(10);\n\t\t\t\tif (signal_pending (current))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t \n\tif (set_1284_register(pp, 6, m << 5, GFP_KERNEL))\n\t\treturn -EIO;\n\tif (get_1284_register(pp, 6, &reg, GFP_KERNEL))\n\t\treturn -EIO;\n\treturn 0;\n}\n\n \nstatic int clear_epp_timeout(struct parport *pp)\n{\n\tunsigned char stat;\n\n\tif (get_1284_register(pp, 1, &stat, GFP_KERNEL))\n\t\treturn 1;\n\treturn stat & 1;\n}\n\n \n#if 0\nstatic int uss720_irq(int usbstatus, void *buffer, int len, void *dev_id)\n{\n\tstruct parport *pp = (struct parport *)dev_id;\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\n\tif (usbstatus != 0 || len < 4 || !buffer)\n\t\treturn 1;\n\tmemcpy(priv->reg, buffer, 4);\n\t \n\tif (priv->reg[2] & priv->reg[1] & 0x10)\n\t\tparport_generic_irq(pp);\n\treturn 1;\n}\n#endif\n\nstatic void parport_uss720_write_data(struct parport *pp, unsigned char d)\n{\n\tset_1284_register(pp, 0, d, GFP_KERNEL);\n}\n\nstatic unsigned char parport_uss720_read_data(struct parport *pp)\n{\n\tunsigned char ret;\n\n\tif (get_1284_register(pp, 0, &ret, GFP_KERNEL))\n\t\treturn 0;\n\treturn ret;\n}\n\nstatic void parport_uss720_write_control(struct parport *pp, unsigned char d)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\n\td = (d & 0xf) | (priv->reg[1] & 0xf0);\n\tif (set_1284_register(pp, 2, d, GFP_KERNEL))\n\t\treturn;\n\tpriv->reg[1] = d;\n}\n\nstatic unsigned char parport_uss720_read_control(struct parport *pp)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\treturn priv->reg[1] & 0xf;  \n}\n\nstatic unsigned char parport_uss720_frob_control(struct parport *pp, unsigned char mask, unsigned char val)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tunsigned char d;\n\n\tmask &= 0x0f;\n\tval &= 0x0f;\n\td = (priv->reg[1] & (~mask)) ^ val;\n\tif (set_1284_register(pp, 2, d, GFP_ATOMIC))\n\t\treturn 0;\n\tpriv->reg[1] = d;\n\treturn d & 0xf;\n}\n\nstatic unsigned char parport_uss720_read_status(struct parport *pp)\n{\n\tunsigned char ret;\n\n\tif (get_1284_register(pp, 1, &ret, GFP_ATOMIC))\n\t\treturn 0;\n\treturn ret & 0xf8;\n}\n\nstatic void parport_uss720_disable_irq(struct parport *pp)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tunsigned char d;\n\n\td = priv->reg[1] & ~0x10;\n\tif (set_1284_register(pp, 2, d, GFP_KERNEL))\n\t\treturn;\n\tpriv->reg[1] = d;\n}\n\nstatic void parport_uss720_enable_irq(struct parport *pp)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tunsigned char d;\n\n\td = priv->reg[1] | 0x10;\n\tif (set_1284_register(pp, 2, d, GFP_KERNEL))\n\t\treturn;\n\tpriv->reg[1] = d;\n}\n\nstatic void parport_uss720_data_forward (struct parport *pp)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tunsigned char d;\n\n\td = priv->reg[1] & ~0x20;\n\tif (set_1284_register(pp, 2, d, GFP_KERNEL))\n\t\treturn;\n\tpriv->reg[1] = d;\n}\n\nstatic void parport_uss720_data_reverse (struct parport *pp)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tunsigned char d;\n\n\td = priv->reg[1] | 0x20;\n\tif (set_1284_register(pp, 2, d, GFP_KERNEL))\n\t\treturn;\n\tpriv->reg[1] = d;\n}\n\nstatic void parport_uss720_init_state(struct pardevice *dev, struct parport_state *s)\n{\n\ts->u.pc.ctr = 0xc | (dev->irq_func ? 0x10 : 0x0);\n\ts->u.pc.ecr = 0x24;\n}\n\nstatic void parport_uss720_save_state(struct parport *pp, struct parport_state *s)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\n#if 0\n\tif (get_1284_register(pp, 2, NULL, GFP_ATOMIC))\n\t\treturn;\n#endif\n\ts->u.pc.ctr = priv->reg[1];\n\ts->u.pc.ecr = priv->reg[2];\n}\n\nstatic void parport_uss720_restore_state(struct parport *pp, struct parport_state *s)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\n\n\tset_1284_register(pp, 2, s->u.pc.ctr, GFP_ATOMIC);\n\tset_1284_register(pp, 6, s->u.pc.ecr, GFP_ATOMIC);\n\tget_1284_register(pp, 2, NULL, GFP_ATOMIC);\n\tpriv->reg[1] = s->u.pc.ctr;\n\tpriv->reg[2] = s->u.pc.ecr;\n}\n\nstatic size_t parport_uss720_epp_read_data(struct parport *pp, void *buf, size_t length, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tsize_t got = 0;\n\n\tif (change_mode(pp, ECR_EPP))\n\t\treturn 0;\n\tfor (; got < length; got++) {\n\t\tif (get_1284_register(pp, 4, (char *)buf, GFP_KERNEL))\n\t\t\tbreak;\n\t\tbuf++;\n\t\tif (priv->reg[0] & 0x01) {\n\t\t\tclear_epp_timeout(pp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tchange_mode(pp, ECR_PS2);\n\treturn got;\n}\n\nstatic size_t parport_uss720_epp_write_data(struct parport *pp, const void *buf, size_t length, int flags)\n{\n#if 0\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tsize_t written = 0;\n\n\tif (change_mode(pp, ECR_EPP))\n\t\treturn 0;\n\tfor (; written < length; written++) {\n\t\tif (set_1284_register(pp, 4, (char *)buf, GFP_KERNEL))\n\t\t\tbreak;\n\t\t((char*)buf)++;\n\t\tif (get_1284_register(pp, 1, NULL, GFP_KERNEL))\n\t\t\tbreak;\n\t\tif (priv->reg[0] & 0x01) {\n\t\t\tclear_epp_timeout(pp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tchange_mode(pp, ECR_PS2);\n\treturn written;\n#else\n\tstruct parport_uss720_private *priv = pp->private_data;\n\tstruct usb_device *usbdev = priv->usbdev;\n\tint rlen = 0;\n\tint i;\n\n\tif (!usbdev)\n\t\treturn 0;\n\tif (change_mode(pp, ECR_EPP))\n\t\treturn 0;\n\ti = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buf, length, &rlen, 20000);\n\tif (i)\n\t\tprintk(KERN_ERR \"uss720: sendbulk ep 1 buf %p len %zu rlen %u\\n\", buf, length, rlen);\n\tchange_mode(pp, ECR_PS2);\n\treturn rlen;\n#endif\n}\n\nstatic size_t parport_uss720_epp_read_addr(struct parport *pp, void *buf, size_t length, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tsize_t got = 0;\n\n\tif (change_mode(pp, ECR_EPP))\n\t\treturn 0;\n\tfor (; got < length; got++) {\n\t\tif (get_1284_register(pp, 3, (char *)buf, GFP_KERNEL))\n\t\t\tbreak;\n\t\tbuf++;\n\t\tif (priv->reg[0] & 0x01) {\n\t\t\tclear_epp_timeout(pp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tchange_mode(pp, ECR_PS2);\n\treturn got;\n}\n\nstatic size_t parport_uss720_epp_write_addr(struct parport *pp, const void *buf, size_t length, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\t\n\tsize_t written = 0;\n\n\tif (change_mode(pp, ECR_EPP))\n\t\treturn 0;\n\tfor (; written < length; written++) {\n\t\tif (set_1284_register(pp, 3, *(char *)buf, GFP_KERNEL))\n\t\t\tbreak;\n\t\tbuf++;\n\t\tif (get_1284_register(pp, 1, NULL, GFP_KERNEL))\n\t\t\tbreak;\n\t\tif (priv->reg[0] & 0x01) {\n\t\t\tclear_epp_timeout(pp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tchange_mode(pp, ECR_PS2);\n\treturn written;\n}\n\nstatic size_t parport_uss720_ecp_write_data(struct parport *pp, const void *buffer, size_t len, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\n\tstruct usb_device *usbdev = priv->usbdev;\n\tint rlen = 0;\n\tint i;\n\n\tif (!usbdev)\n\t\treturn 0;\n\tif (change_mode(pp, ECR_ECP))\n\t\treturn 0;\n\ti = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buffer, len, &rlen, 20000);\n\tif (i)\n\t\tprintk(KERN_ERR \"uss720: sendbulk ep 1 buf %p len %zu rlen %u\\n\", buffer, len, rlen);\n\tchange_mode(pp, ECR_PS2);\n\treturn rlen;\n}\n\nstatic size_t parport_uss720_ecp_read_data(struct parport *pp, void *buffer, size_t len, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\n\tstruct usb_device *usbdev = priv->usbdev;\n\tint rlen = 0;\n\tint i;\n\n\tif (!usbdev)\n\t\treturn 0;\n\tif (change_mode(pp, ECR_ECP))\n\t\treturn 0;\n\ti = usb_bulk_msg(usbdev, usb_rcvbulkpipe(usbdev, 2), buffer, len, &rlen, 20000);\n\tif (i)\n\t\tprintk(KERN_ERR \"uss720: recvbulk ep 2 buf %p len %zu rlen %u\\n\", buffer, len, rlen);\n\tchange_mode(pp, ECR_PS2);\n\treturn rlen;\n}\n\nstatic size_t parport_uss720_ecp_write_addr(struct parport *pp, const void *buffer, size_t len, int flags)\n{\n\tsize_t written = 0;\n\n\tif (change_mode(pp, ECR_ECP))\n\t\treturn 0;\n\tfor (; written < len; written++) {\n\t\tif (set_1284_register(pp, 5, *(char *)buffer, GFP_KERNEL))\n\t\t\tbreak;\n\t\tbuffer++;\n\t}\n\tchange_mode(pp, ECR_PS2);\n\treturn written;\n}\n\nstatic size_t parport_uss720_write_compat(struct parport *pp, const void *buffer, size_t len, int flags)\n{\n\tstruct parport_uss720_private *priv = pp->private_data;\n\tstruct usb_device *usbdev = priv->usbdev;\n\tint rlen = 0;\n\tint i;\n\n\tif (!usbdev)\n\t\treturn 0;\n\tif (change_mode(pp, ECR_PPF))\n\t\treturn 0;\n\ti = usb_bulk_msg(usbdev, usb_sndbulkpipe(usbdev, 1), (void *)buffer, len, &rlen, 20000);\n\tif (i)\n\t\tprintk(KERN_ERR \"uss720: sendbulk ep 1 buf %p len %zu rlen %u\\n\", buffer, len, rlen);\n\tchange_mode(pp, ECR_PS2);\n\treturn rlen;\n}\n\n \n\nstatic struct parport_operations parport_uss720_ops = \n{\n\t.owner =\t\tTHIS_MODULE,\n\t.write_data =\t\tparport_uss720_write_data,\n\t.read_data =\t\tparport_uss720_read_data,\n\n\t.write_control =\tparport_uss720_write_control,\n\t.read_control =\t\tparport_uss720_read_control,\n\t.frob_control =\t\tparport_uss720_frob_control,\n\n\t.read_status =\t\tparport_uss720_read_status,\n\n\t.enable_irq =\t\tparport_uss720_enable_irq,\n\t.disable_irq =\t\tparport_uss720_disable_irq,\n\n\t.data_forward =\t\tparport_uss720_data_forward,\n\t.data_reverse =\t\tparport_uss720_data_reverse,\n\n\t.init_state =\t\tparport_uss720_init_state,\n\t.save_state =\t\tparport_uss720_save_state,\n\t.restore_state =\tparport_uss720_restore_state,\n\n\t.epp_write_data =\tparport_uss720_epp_write_data,\n\t.epp_read_data =\tparport_uss720_epp_read_data,\n\t.epp_write_addr =\tparport_uss720_epp_write_addr,\n\t.epp_read_addr =\tparport_uss720_epp_read_addr,\n\n\t.ecp_write_data =\tparport_uss720_ecp_write_data,\n\t.ecp_read_data =\tparport_uss720_ecp_read_data,\n\t.ecp_write_addr =\tparport_uss720_ecp_write_addr,\n\n\t.compat_write_data =\tparport_uss720_write_compat,\n\t.nibble_read_data =\tparport_ieee1284_read_nibble,\n\t.byte_read_data =\tparport_ieee1284_read_byte,\n};\n\n \n\nstatic int uss720_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *usbdev = usb_get_dev(interface_to_usbdev(intf));\n\tstruct usb_host_interface *interface;\n\tstruct usb_endpoint_descriptor *epd;\n\tstruct parport_uss720_private *priv;\n\tstruct parport *pp;\n\tunsigned char reg;\n\tint i;\n\n\tdev_dbg(&intf->dev, \"probe: vendor id 0x%x, device id 0x%x\\n\",\n\t\tle16_to_cpu(usbdev->descriptor.idVendor),\n\t\tle16_to_cpu(usbdev->descriptor.idProduct));\n\n\t \n\tif (intf->num_altsetting != 3) {\n\t\tusb_put_dev(usbdev);\n\t\treturn -ENODEV;\n\t}\n\ti = usb_set_interface(usbdev, intf->altsetting->desc.bInterfaceNumber, 2);\n\tdev_dbg(&intf->dev, \"set interface result %d\\n\", i);\n\n\tinterface = intf->cur_altsetting;\n\n\tif (interface->desc.bNumEndpoints < 3) {\n\t\tusb_put_dev(usbdev);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tpriv = kzalloc(sizeof(struct parport_uss720_private), GFP_KERNEL);\n\tif (!priv) {\n\t\tusb_put_dev(usbdev);\n\t\treturn -ENOMEM;\n\t}\n\tpriv->pp = NULL;\n\tpriv->usbdev = usbdev;\n\tkref_init(&priv->ref_count);\n\tspin_lock_init(&priv->asynclock);\n\tINIT_LIST_HEAD(&priv->asynclist);\n\tpp = parport_register_port(0, PARPORT_IRQ_NONE, PARPORT_DMA_NONE, &parport_uss720_ops);\n\tif (!pp) {\n\t\tprintk(KERN_WARNING \"uss720: could not register parport\\n\");\n\t\tgoto probe_abort;\n\t}\n\n\tpriv->pp = pp;\n\tpp->private_data = priv;\n\tpp->modes = PARPORT_MODE_PCSPP | PARPORT_MODE_TRISTATE | PARPORT_MODE_EPP | PARPORT_MODE_ECP | PARPORT_MODE_COMPAT;\n\n\t \n\tset_1284_register(pp, 7, 0x00, GFP_KERNEL);\n\tset_1284_register(pp, 6, 0x30, GFP_KERNEL);   \n\tset_1284_register(pp, 2, 0x0c, GFP_KERNEL);\n\t \n\tget_1284_register(pp, 0, &reg, GFP_KERNEL);\n\tdev_dbg(&intf->dev, \"reg: %7ph\\n\", priv->reg);\n\n\ti = usb_find_last_int_in_endpoint(interface, &epd);\n\tif (!i) {\n\t\tdev_dbg(&intf->dev, \"epaddr %d interval %d\\n\",\n\t\t\t\tepd->bEndpointAddress, epd->bInterval);\n\t}\n\tparport_announce_port(pp);\n\n\tusb_set_intfdata(intf, pp);\n\treturn 0;\n\nprobe_abort:\n\tkill_all_async_requests_priv(priv);\n\tkref_put(&priv->ref_count, destroy_priv);\n\treturn -ENODEV;\n}\n\nstatic void uss720_disconnect(struct usb_interface *intf)\n{\n\tstruct parport *pp = usb_get_intfdata(intf);\n\tstruct parport_uss720_private *priv;\n\n\tdev_dbg(&intf->dev, \"disconnect\\n\");\n\tusb_set_intfdata(intf, NULL);\n\tif (pp) {\n\t\tpriv = pp->private_data;\n\t\tpriv->pp = NULL;\n\t\tdev_dbg(&intf->dev, \"parport_remove_port\\n\");\n\t\tparport_remove_port(pp);\n\t\tparport_put_port(pp);\n\t\tkill_all_async_requests_priv(priv);\n\t\tkref_put(&priv->ref_count, destroy_priv);\n\t}\n\tdev_dbg(&intf->dev, \"disconnect done\\n\");\n}\n\n \nstatic const struct usb_device_id uss720_table[] = {\n\t{ USB_DEVICE(0x047e, 0x1001) },\n\t{ USB_DEVICE(0x04b8, 0x0002) },\n\t{ USB_DEVICE(0x04b8, 0x0003) },\n\t{ USB_DEVICE(0x050d, 0x0002) },\n\t{ USB_DEVICE(0x050d, 0x1202) },\n\t{ USB_DEVICE(0x0557, 0x2001) },\n\t{ USB_DEVICE(0x05ab, 0x0002) },\n\t{ USB_DEVICE(0x06c6, 0x0100) },\n\t{ USB_DEVICE(0x0729, 0x1284) },\n\t{ USB_DEVICE(0x1293, 0x0002) },\n\t{ }\t\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE (usb, uss720_table);\n\n\nstatic struct usb_driver uss720_driver = {\n\t.name =\t\t\"uss720\",\n\t.probe =\tuss720_probe,\n\t.disconnect =\tuss720_disconnect,\n\t.id_table =\tuss720_table,\n};\n\n \n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic int __init uss720_init(void)\n{\n\tint retval;\n\tretval = usb_register(&uss720_driver);\n\tif (retval)\n\t\tgoto out;\n\n\tprintk(KERN_INFO KBUILD_MODNAME \": \" DRIVER_DESC \"\\n\");\n\tprintk(KERN_INFO KBUILD_MODNAME \": NOTE: this is a special purpose \"\n\t       \"driver to allow nonstandard\\n\");\n\tprintk(KERN_INFO KBUILD_MODNAME \": protocols (eg. bitbang) over \"\n\t       \"USS720 usb to parallel cables\\n\");\n\tprintk(KERN_INFO KBUILD_MODNAME \": If you just want to connect to a \"\n\t       \"printer, use usblp instead\\n\");\nout:\n\treturn retval;\n}\n\nstatic void __exit uss720_cleanup(void)\n{\n\tusb_deregister(&uss720_driver);\n}\n\nmodule_init(uss720_init);\nmodule_exit(uss720_cleanup);\n\n \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}