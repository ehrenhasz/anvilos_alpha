{
  "module_name": "chaoskey.c",
  "hash_id": "2b1a83c786a98e591ec9f84103e0cca6f1df739af9171b480a04bb45f6ba6070",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/chaoskey.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/wait.h>\n#include <linux/hw_random.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n\nstatic struct usb_driver chaoskey_driver;\nstatic struct usb_class_driver chaoskey_class;\nstatic int chaoskey_rng_read(struct hwrng *rng, void *data,\n\t\t\t     size_t max, bool wait);\n\n#define usb_dbg(usb_if, format, arg...) \\\n\tdev_dbg(&(usb_if)->dev, format, ## arg)\n\n#define usb_err(usb_if, format, arg...) \\\n\tdev_err(&(usb_if)->dev, format, ## arg)\n\n \n#define DRIVER_AUTHOR\t\"Keith Packard, keithp@keithp.com\"\n#define DRIVER_DESC\t\"Altus Metrum ChaosKey driver\"\n#define DRIVER_SHORT\t\"chaoskey\"\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n#define CHAOSKEY_VENDOR_ID\t0x1d50\t \n#define CHAOSKEY_PRODUCT_ID\t0x60c6\t \n\n#define ALEA_VENDOR_ID\t\t0x12d8\t \n#define ALEA_PRODUCT_ID\t\t0x0001\t \n\n#define CHAOSKEY_BUF_LEN\t64\t \n\n#define NAK_TIMEOUT (HZ)\t\t \n#define ALEA_FIRST_TIMEOUT (HZ*3)\t \n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n#define USB_CHAOSKEY_MINOR_BASE 0\n#else\n\n \n#define USB_CHAOSKEY_MINOR_BASE 224\n#endif\n\nstatic const struct usb_device_id chaoskey_table[] = {\n\t{ USB_DEVICE(CHAOSKEY_VENDOR_ID, CHAOSKEY_PRODUCT_ID) },\n\t{ USB_DEVICE(ALEA_VENDOR_ID, ALEA_PRODUCT_ID) },\n\t{ },\n};\nMODULE_DEVICE_TABLE(usb, chaoskey_table);\n\nstatic void chaos_read_callback(struct urb *urb);\n\n \nstruct chaoskey {\n\tstruct usb_interface *interface;\n\tchar in_ep;\n\tstruct mutex lock;\n\tstruct mutex rng_lock;\n\tint open;\t\t\t \n\tbool present;\t\t\t \n\tbool reading;\t\t\t \n\tbool reads_started;\t\t \n\tint size;\t\t\t \n\tint valid;\t\t\t \n\tint used;\t\t\t \n\tchar *name;\t\t\t \n\tstruct hwrng hwrng;\t\t \n\tint hwrng_registered;\t\t \n\twait_queue_head_t wait_q;\t \n\tstruct urb *urb;\t\t \n\tchar *buf;\n};\n\nstatic void chaoskey_free(struct chaoskey *dev)\n{\n\tif (dev) {\n\t\tusb_dbg(dev->interface, \"free\");\n\t\tusb_free_urb(dev->urb);\n\t\tkfree(dev->name);\n\t\tkfree(dev->buf);\n\t\tusb_put_intf(dev->interface);\n\t\tkfree(dev);\n\t}\n}\n\nstatic int chaoskey_probe(struct usb_interface *interface,\n\t\t\t  const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_host_interface *altsetting = interface->cur_altsetting;\n\tstruct usb_endpoint_descriptor *epd;\n\tint in_ep;\n\tstruct chaoskey *dev;\n\tint result = -ENOMEM;\n\tint size;\n\tint res;\n\n\tusb_dbg(interface, \"probe %s-%s\", udev->product, udev->serial);\n\n\t \n\tres = usb_find_bulk_in_endpoint(altsetting, &epd);\n\tif (res) {\n\t\tusb_dbg(interface, \"no IN endpoint found\");\n\t\treturn res;\n\t}\n\n\tin_ep = usb_endpoint_num(epd);\n\tsize = usb_endpoint_maxp(epd);\n\n\t \n\tif (size <= 0) {\n\t\tusb_dbg(interface, \"invalid size (%d)\", size);\n\t\treturn -ENODEV;\n\t}\n\n\tif (size > CHAOSKEY_BUF_LEN) {\n\t\tusb_dbg(interface, \"size reduced from %d to %d\\n\",\n\t\t\tsize, CHAOSKEY_BUF_LEN);\n\t\tsize = CHAOSKEY_BUF_LEN;\n\t}\n\n\t \n\n\tdev = kzalloc(sizeof(struct chaoskey), GFP_KERNEL);\n\n\tif (dev == NULL)\n\t\tgoto out;\n\n\tdev->interface = usb_get_intf(interface);\n\n\tdev->buf = kmalloc(size, GFP_KERNEL);\n\n\tif (dev->buf == NULL)\n\t\tgoto out;\n\n\tdev->urb = usb_alloc_urb(0, GFP_KERNEL);\n\n\tif (!dev->urb)\n\t\tgoto out;\n\n\tusb_fill_bulk_urb(dev->urb,\n\t\tudev,\n\t\tusb_rcvbulkpipe(udev, in_ep),\n\t\tdev->buf,\n\t\tsize,\n\t\tchaos_read_callback,\n\t\tdev);\n\n\t \n\n\tif (udev->product && udev->serial) {\n\t\tdev->name = kasprintf(GFP_KERNEL, \"%s-%s\", udev->product,\n\t\t\t\t      udev->serial);\n\t\tif (dev->name == NULL)\n\t\t\tgoto out;\n\t}\n\n\tdev->in_ep = in_ep;\n\n\tif (le16_to_cpu(udev->descriptor.idVendor) != ALEA_VENDOR_ID)\n\t\tdev->reads_started = true;\n\n\tdev->size = size;\n\tdev->present = true;\n\n\tinit_waitqueue_head(&dev->wait_q);\n\n\tmutex_init(&dev->lock);\n\tmutex_init(&dev->rng_lock);\n\n\tusb_set_intfdata(interface, dev);\n\n\tresult = usb_register_dev(interface, &chaoskey_class);\n\tif (result) {\n\t\tusb_err(interface, \"Unable to allocate minor number.\");\n\t\tgoto out;\n\t}\n\n\tdev->hwrng.name = dev->name ? dev->name : chaoskey_driver.name;\n\tdev->hwrng.read = chaoskey_rng_read;\n\n\tdev->hwrng_registered = (hwrng_register(&dev->hwrng) == 0);\n\tif (!dev->hwrng_registered)\n\t\tusb_err(interface, \"Unable to register with hwrng\");\n\n\tusb_enable_autosuspend(udev);\n\n\tusb_dbg(interface, \"chaoskey probe success, size %d\", dev->size);\n\treturn 0;\n\nout:\n\tusb_set_intfdata(interface, NULL);\n\tchaoskey_free(dev);\n\treturn result;\n}\n\nstatic void chaoskey_disconnect(struct usb_interface *interface)\n{\n\tstruct chaoskey\t*dev;\n\n\tusb_dbg(interface, \"disconnect\");\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tusb_dbg(interface, \"disconnect failed - no dev\");\n\t\treturn;\n\t}\n\n\tif (dev->hwrng_registered)\n\t\thwrng_unregister(&dev->hwrng);\n\n\tusb_deregister_dev(interface, &chaoskey_class);\n\n\tusb_set_intfdata(interface, NULL);\n\tmutex_lock(&dev->lock);\n\n\tdev->present = false;\n\tusb_poison_urb(dev->urb);\n\n\tif (!dev->open) {\n\t\tmutex_unlock(&dev->lock);\n\t\tchaoskey_free(dev);\n\t} else\n\t\tmutex_unlock(&dev->lock);\n\n\tusb_dbg(interface, \"disconnect done\");\n}\n\nstatic int chaoskey_open(struct inode *inode, struct file *file)\n{\n\tstruct chaoskey *dev;\n\tstruct usb_interface *interface;\n\n\t \n\tinterface = usb_find_interface(&chaoskey_driver, iminor(inode));\n\tif (!interface)\n\t\treturn -ENODEV;\n\n\tusb_dbg(interface, \"open\");\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tusb_dbg(interface, \"open (dev)\");\n\t\treturn -ENODEV;\n\t}\n\n\tfile->private_data = dev;\n\tmutex_lock(&dev->lock);\n\t++dev->open;\n\tmutex_unlock(&dev->lock);\n\n\tusb_dbg(interface, \"open success\");\n\treturn 0;\n}\n\nstatic int chaoskey_release(struct inode *inode, struct file *file)\n{\n\tstruct chaoskey *dev = file->private_data;\n\tstruct usb_interface *interface;\n\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\tinterface = dev->interface;\n\n\tusb_dbg(interface, \"release\");\n\n\tmutex_lock(&dev->lock);\n\n\tusb_dbg(interface, \"open count at release is %d\", dev->open);\n\n\tif (dev->open <= 0) {\n\t\tusb_dbg(interface, \"invalid open count (%d)\", dev->open);\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\t--dev->open;\n\n\tif (!dev->present) {\n\t\tif (dev->open == 0) {\n\t\t\tmutex_unlock(&dev->lock);\n\t\t\tchaoskey_free(dev);\n\t\t} else\n\t\t\tmutex_unlock(&dev->lock);\n\t} else\n\t\tmutex_unlock(&dev->lock);\n\n\tusb_dbg(interface, \"release success\");\n\treturn 0;\n}\n\nstatic void chaos_read_callback(struct urb *urb)\n{\n\tstruct chaoskey *dev = urb->context;\n\tint status = urb->status;\n\n\tusb_dbg(dev->interface, \"callback status (%d)\", status);\n\n\tif (status == 0)\n\t\tdev->valid = urb->actual_length;\n\telse\n\t\tdev->valid = 0;\n\n\tdev->used = 0;\n\n\t \n\tsmp_wmb();\n\n\tdev->reading = false;\n\twake_up(&dev->wait_q);\n}\n\n \nstatic int _chaoskey_fill(struct chaoskey *dev)\n{\n\tDEFINE_WAIT(wait);\n\tint result;\n\tbool started;\n\n\tusb_dbg(dev->interface, \"fill\");\n\n\t \n\tif (dev->valid != dev->used) {\n\t\tusb_dbg(dev->interface, \"not empty yet (valid %d used %d)\",\n\t\t\tdev->valid, dev->used);\n\t\treturn 0;\n\t}\n\n\t \n\tif (!dev->present) {\n\t\tusb_dbg(dev->interface, \"device not present\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tresult = usb_autopm_get_interface(dev->interface);\n\tif (result) {\n\t\tusb_dbg(dev->interface, \"wakeup failed (result %d)\", result);\n\t\treturn result;\n\t}\n\n\tdev->reading = true;\n\tresult = usb_submit_urb(dev->urb, GFP_KERNEL);\n\tif (result < 0) {\n\t\tresult = usb_translate_errors(result);\n\t\tdev->reading = false;\n\t\tgoto out;\n\t}\n\n\t \n\tstarted = dev->reads_started;\n\tdev->reads_started = true;\n\tresult = wait_event_interruptible_timeout(\n\t\tdev->wait_q,\n\t\t!dev->reading,\n\t\t(started ? NAK_TIMEOUT : ALEA_FIRST_TIMEOUT) );\n\n\tif (result < 0) {\n\t\tusb_kill_urb(dev->urb);\n\t\tgoto out;\n\t}\n\n\tif (result == 0) {\n\t\tresult = -ETIMEDOUT;\n\t\tusb_kill_urb(dev->urb);\n\t} else {\n\t\tresult = dev->valid;\n\t}\nout:\n\t \n\tusb_autopm_put_interface(dev->interface);\n\n\tusb_dbg(dev->interface, \"read %d bytes\", dev->valid);\n\n\treturn result;\n}\n\nstatic ssize_t chaoskey_read(struct file *file,\n\t\t\t     char __user *buffer,\n\t\t\t     size_t count,\n\t\t\t     loff_t *ppos)\n{\n\tstruct chaoskey *dev;\n\tssize_t read_count = 0;\n\tint this_time;\n\tint result = 0;\n\tunsigned long remain;\n\n\tdev = file->private_data;\n\n\tif (dev == NULL || !dev->present)\n\t\treturn -ENODEV;\n\n\tusb_dbg(dev->interface, \"read %zu\", count);\n\n\twhile (count > 0) {\n\n\t\t \n\t\tresult = mutex_lock_interruptible(&dev->rng_lock);\n\t\tif (result)\n\t\t\tgoto bail;\n\t\tmutex_unlock(&dev->rng_lock);\n\n\t\tresult = mutex_lock_interruptible(&dev->lock);\n\t\tif (result)\n\t\t\tgoto bail;\n\t\tif (dev->valid == dev->used) {\n\t\t\tresult = _chaoskey_fill(dev);\n\t\t\tif (result < 0) {\n\t\t\t\tmutex_unlock(&dev->lock);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\n\t\tthis_time = dev->valid - dev->used;\n\t\tif (this_time > count)\n\t\t\tthis_time = count;\n\n\t\tremain = copy_to_user(buffer, dev->buf + dev->used, this_time);\n\t\tif (remain) {\n\t\t\tresult = -EFAULT;\n\n\t\t\t \n\t\t\tdev->used += this_time - remain;\n\t\t\tmutex_unlock(&dev->lock);\n\t\t\tgoto bail;\n\t\t}\n\n\t\tcount -= this_time;\n\t\tread_count += this_time;\n\t\tbuffer += this_time;\n\t\tdev->used += this_time;\n\t\tmutex_unlock(&dev->lock);\n\t}\nbail:\n\tif (read_count) {\n\t\tusb_dbg(dev->interface, \"read %zu bytes\", read_count);\n\t\treturn read_count;\n\t}\n\tusb_dbg(dev->interface, \"empty read, result %d\", result);\n\tif (result == -ETIMEDOUT)\n\t\tresult = -EAGAIN;\n\treturn result;\n}\n\nstatic int chaoskey_rng_read(struct hwrng *rng, void *data,\n\t\t\t     size_t max, bool wait)\n{\n\tstruct chaoskey *dev = container_of(rng, struct chaoskey, hwrng);\n\tint this_time;\n\n\tusb_dbg(dev->interface, \"rng_read max %zu wait %d\", max, wait);\n\n\tif (!dev->present) {\n\t\tusb_dbg(dev->interface, \"device not present\");\n\t\treturn 0;\n\t}\n\n\t \n\tmutex_lock(&dev->rng_lock);\n\n\tmutex_lock(&dev->lock);\n\n\tmutex_unlock(&dev->rng_lock);\n\n\t \n\tif (dev->valid == dev->used)\n\t\t(void) _chaoskey_fill(dev);\n\n\tthis_time = dev->valid - dev->used;\n\tif (this_time > max)\n\t\tthis_time = max;\n\n\tmemcpy(data, dev->buf + dev->used, this_time);\n\n\tdev->used += this_time;\n\n\tmutex_unlock(&dev->lock);\n\n\tusb_dbg(dev->interface, \"rng_read this_time %d\\n\", this_time);\n\treturn this_time;\n}\n\n#ifdef CONFIG_PM\nstatic int chaoskey_suspend(struct usb_interface *interface,\n\t\t\t    pm_message_t message)\n{\n\tusb_dbg(interface, \"suspend\");\n\treturn 0;\n}\n\nstatic int chaoskey_resume(struct usb_interface *interface)\n{\n\tstruct chaoskey *dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\n\tusb_dbg(interface, \"resume\");\n\tdev = usb_get_intfdata(interface);\n\n\t \n\tif (le16_to_cpu(udev->descriptor.idVendor) == ALEA_VENDOR_ID)\n\t\tdev->reads_started = false;\n\n\treturn 0;\n}\n#else\n#define chaoskey_suspend NULL\n#define chaoskey_resume NULL\n#endif\n\n \nstatic const struct file_operations chaoskey_fops = {\n\t.owner = THIS_MODULE,\n\t.read = chaoskey_read,\n\t.open = chaoskey_open,\n\t.release = chaoskey_release,\n\t.llseek = default_llseek,\n};\n\n \nstatic struct usb_class_driver chaoskey_class = {\n\t.name = \"chaoskey%d\",\n\t.fops = &chaoskey_fops,\n\t.minor_base = USB_CHAOSKEY_MINOR_BASE,\n};\n\n \nstatic struct usb_driver chaoskey_driver = {\n\t.name = DRIVER_SHORT,\n\t.probe = chaoskey_probe,\n\t.disconnect = chaoskey_disconnect,\n\t.suspend = chaoskey_suspend,\n\t.resume = chaoskey_resume,\n\t.reset_resume = chaoskey_resume,\n\t.id_table = chaoskey_table,\n\t.supports_autosuspend = 1,\n};\n\nmodule_usb_driver(chaoskey_driver);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}