{
  "module_name": "idmouse.c",
  "hash_id": "efc879b5dea0244e57e95d32a279c853839643c5bf28c84a23060b1776808df9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/idmouse.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/sched/signal.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n\n \n#define WIDTH 225\n#define HEIGHT 289\n#define HEADER \"P5 225 289 255 \"\n#define IMGSIZE ((WIDTH * HEIGHT) + sizeof(HEADER)-1)\n\n#define DRIVER_SHORT   \"idmouse\"\n#define DRIVER_AUTHOR  \"Florian 'Floe' Echtler <echtler@fs.tum.de>\"\n#define DRIVER_DESC    \"Siemens ID Mouse FingerTIP Sensor Driver\"\n\n \n#define USB_IDMOUSE_MINOR_BASE 132\n\n \n#define ID_SIEMENS 0x0681\n#define ID_IDMOUSE 0x0005\n#define ID_CHERRY  0x0010\n\n \nstatic const struct usb_device_id idmouse_table[] = {\n\t{USB_DEVICE(ID_SIEMENS, ID_IDMOUSE)},  \n\t{USB_DEVICE(ID_SIEMENS, ID_CHERRY )},  \n\t{}                                     \n};\n\n \n#define FTIP_RESET   0x20\n#define FTIP_ACQUIRE 0x21\n#define FTIP_RELEASE 0x22\n#define FTIP_BLINK   0x23   \n#define FTIP_SCROLL  0x24\n\n#define ftip_command(dev, command, value, index) \\\n\tusb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0), command, \\\n\tUSB_TYPE_VENDOR | USB_RECIP_ENDPOINT | USB_DIR_OUT, value, index, NULL, 0, 1000)\n\nMODULE_DEVICE_TABLE(usb, idmouse_table);\n\n \nstruct usb_idmouse {\n\n\tstruct usb_device *udev;  \n\tstruct usb_interface *interface;  \n\n\tunsigned char *bulk_in_buffer;  \n\tsize_t bulk_in_size;  \n\tsize_t orig_bi_size;  \n\t__u8 bulk_in_endpointAddr;  \n\n\tint open;  \n\tint present;  \n\tstruct mutex lock;  \n\n};\n\n \nstatic ssize_t idmouse_read(struct file *file, char __user *buffer,\n\t\t\t\tsize_t count, loff_t * ppos);\n\nstatic int idmouse_open(struct inode *inode, struct file *file);\nstatic int idmouse_release(struct inode *inode, struct file *file);\n\nstatic int idmouse_probe(struct usb_interface *interface,\n\t\t\t\tconst struct usb_device_id *id);\n\nstatic void idmouse_disconnect(struct usb_interface *interface);\nstatic int idmouse_suspend(struct usb_interface *intf, pm_message_t message);\nstatic int idmouse_resume(struct usb_interface *intf);\n\n \nstatic const struct file_operations idmouse_fops = {\n\t.owner = THIS_MODULE,\n\t.read = idmouse_read,\n\t.open = idmouse_open,\n\t.release = idmouse_release,\n\t.llseek = default_llseek,\n};\n\n \nstatic struct usb_class_driver idmouse_class = {\n\t.name = \"idmouse%d\",\n\t.fops = &idmouse_fops,\n\t.minor_base = USB_IDMOUSE_MINOR_BASE,\n};\n\n \nstatic struct usb_driver idmouse_driver = {\n\t.name = DRIVER_SHORT,\n\t.probe = idmouse_probe,\n\t.disconnect = idmouse_disconnect,\n\t.suspend = idmouse_suspend,\n\t.resume = idmouse_resume,\n\t.reset_resume = idmouse_resume,\n\t.id_table = idmouse_table,\n\t.supports_autosuspend = 1,\n};\n\nstatic int idmouse_create_image(struct usb_idmouse *dev)\n{\n\tint bytes_read;\n\tint bulk_read;\n\tint result;\n\n\tmemcpy(dev->bulk_in_buffer, HEADER, sizeof(HEADER)-1);\n\tbytes_read = sizeof(HEADER)-1;\n\n\t \n\tresult = ftip_command(dev, FTIP_RELEASE, 0, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\tresult = ftip_command(dev, FTIP_BLINK,   1, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\n\t \n\t \n\tresult = ftip_command(dev, FTIP_ACQUIRE, 0, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\tresult = ftip_command(dev, FTIP_ACQUIRE, 0, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\n\t \n\t \n\tresult = ftip_command(dev, FTIP_RESET,   0, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\tresult = ftip_command(dev, FTIP_RESET,   0, 0);\n\tif (result < 0)\n\t\tgoto reset;\n\n\t \n\twhile (bytes_read < IMGSIZE) {\n\t\tresult = usb_bulk_msg(dev->udev,\n\t\t\t\tusb_rcvbulkpipe(dev->udev, dev->bulk_in_endpointAddr),\n\t\t\t\tdev->bulk_in_buffer + bytes_read,\n\t\t\t\tdev->bulk_in_size, &bulk_read, 5000);\n\t\tif (result < 0) {\n\t\t\t \n\t\t\t \n\t\t\tif (dev->bulk_in_size != dev->orig_bi_size) {\n\t\t\t\tdev->bulk_in_size = dev->orig_bi_size;\n\t\t\t\tresult = -EAGAIN;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (signal_pending(current)) {\n\t\t\tresult = -EINTR;\n\t\t\tbreak;\n\t\t}\n\t\tbytes_read += bulk_read;\n\t}\n\n\t \n\t \n\tfor (bytes_read = sizeof(HEADER)-1 + WIDTH-1; bytes_read < IMGSIZE; bytes_read += WIDTH)\n\t\tif (dev->bulk_in_buffer[bytes_read] != 0x00)\n\t\t\treturn -EAGAIN;\n\n\t \n\tfor (bytes_read = IMGSIZE-WIDTH; bytes_read < IMGSIZE-1; bytes_read++)\n\t\tif (dev->bulk_in_buffer[bytes_read] != 0xFF)\n\t\t\treturn -EAGAIN;\n\n\t \nreset:\n\tftip_command(dev, FTIP_RELEASE, 0, 0);\n\n\t \n\tdev_dbg(&dev->interface->dev, \"read %d bytes fingerprint data\\n\",\n\t\tbytes_read);\n\treturn result;\n}\n\n \nstatic int idmouse_suspend(struct usb_interface *intf, pm_message_t message)\n{\n\treturn 0;\n}\n\nstatic int idmouse_resume(struct usb_interface *intf)\n{\n\treturn 0;\n}\n\nstatic inline void idmouse_delete(struct usb_idmouse *dev)\n{\n\tkfree(dev->bulk_in_buffer);\n\tkfree(dev);\n}\n\nstatic int idmouse_open(struct inode *inode, struct file *file)\n{\n\tstruct usb_idmouse *dev;\n\tstruct usb_interface *interface;\n\tint result;\n\n\t \n\tinterface = usb_find_interface(&idmouse_driver, iminor(inode));\n\tif (!interface)\n\t\treturn -ENODEV;\n\n\t \n\tdev = usb_get_intfdata(interface);\n\tif (!dev)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&dev->lock);\n\n\t \n\tif (dev->open) {\n\n\t\t \n\t\tresult = -EBUSY;\n\n\t} else {\n\n\t\t \n\t\tresult = usb_autopm_get_interface(interface);\n\t\tif (result)\n\t\t\tgoto error;\n\t\tresult = idmouse_create_image(dev);\n\t\tusb_autopm_put_interface(interface);\n\t\tif (result)\n\t\t\tgoto error;\n\n\t\t \n\t\t++dev->open;\n\n\t\t \n\t\tfile->private_data = dev;\n\n\t} \n\nerror:\n\n\t \n\tmutex_unlock(&dev->lock);\n\treturn result;\n}\n\nstatic int idmouse_release(struct inode *inode, struct file *file)\n{\n\tstruct usb_idmouse *dev;\n\n\tdev = file->private_data;\n\n\tif (dev == NULL)\n\t\treturn -ENODEV;\n\n\t \n\tmutex_lock(&dev->lock);\n\n\t--dev->open;\n\n\tif (!dev->present) {\n\t\t \n\t\tmutex_unlock(&dev->lock);\n\t\tidmouse_delete(dev);\n\t} else {\n\t\tmutex_unlock(&dev->lock);\n\t}\n\treturn 0;\n}\n\nstatic ssize_t idmouse_read(struct file *file, char __user *buffer, size_t count,\n\t\t\t\tloff_t * ppos)\n{\n\tstruct usb_idmouse *dev = file->private_data;\n\tint result;\n\n\t \n\tmutex_lock(&dev->lock);\n\n\t \n\tif (!dev->present) {\n\t\tmutex_unlock(&dev->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tresult = simple_read_from_buffer(buffer, count, ppos,\n\t\t\t\t\tdev->bulk_in_buffer, IMGSIZE);\n\t \n\tmutex_unlock(&dev->lock);\n\treturn result;\n}\n\nstatic int idmouse_probe(struct usb_interface *interface,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_idmouse *dev;\n\tstruct usb_host_interface *iface_desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tint result;\n\n\t \n\tiface_desc = interface->cur_altsetting;\n\tif (iface_desc->desc.bInterfaceClass != 0x0A)\n\t\treturn -ENODEV;\n\n\tif (iface_desc->desc.bNumEndpoints < 1)\n\t\treturn -ENODEV;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tmutex_init(&dev->lock);\n\tdev->udev = udev;\n\tdev->interface = interface;\n\n\t \n\tresult = usb_find_bulk_in_endpoint(iface_desc, &endpoint);\n\tif (result) {\n\t\tdev_err(&interface->dev, \"Unable to find bulk-in endpoint.\\n\");\n\t\tidmouse_delete(dev);\n\t\treturn result;\n\t}\n\n\tdev->orig_bi_size = usb_endpoint_maxp(endpoint);\n\tdev->bulk_in_size = 0x200;  \n\tdev->bulk_in_endpointAddr = endpoint->bEndpointAddress;\n\tdev->bulk_in_buffer = kmalloc(IMGSIZE + dev->bulk_in_size, GFP_KERNEL);\n\tif (!dev->bulk_in_buffer) {\n\t\tidmouse_delete(dev);\n\t\treturn -ENOMEM;\n\t}\n\n\t \n\tdev->present = 1;\n\n\t \n\tusb_set_intfdata(interface, dev);\n\tresult = usb_register_dev(interface, &idmouse_class);\n\tif (result) {\n\t\t \n\t\tdev_err(&interface->dev, \"Unable to allocate minor number.\\n\");\n\t\tidmouse_delete(dev);\n\t\treturn result;\n\t}\n\n\t \n\tdev_info(&interface->dev,\"%s now attached\\n\",DRIVER_DESC);\n\n\treturn 0;\n}\n\nstatic void idmouse_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_idmouse *dev = usb_get_intfdata(interface);\n\n\t \n\tusb_deregister_dev(interface, &idmouse_class);\n\n\t \n\tmutex_lock(&dev->lock);\n\n\t \n\tdev->present = 0;\n\n\t \n\tif (!dev->open) {\n\t\tmutex_unlock(&dev->lock);\n\t\tidmouse_delete(dev);\n\t} else {\n\t\t \n\t\tmutex_unlock(&dev->lock);\n\t}\n\n\tdev_info(&interface->dev, \"disconnected\\n\");\n}\n\nmodule_usb_driver(idmouse_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}