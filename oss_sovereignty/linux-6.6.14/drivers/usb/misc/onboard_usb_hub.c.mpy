{
  "module_name": "onboard_usb_hub.c",
  "hash_id": "17a53d7d3429501b32fa12b3b79675bd15dacbbdd341580e25e33835a955e3fa",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/onboard_usb_hub.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/export.h>\n#include <linux/gpio/consumer.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/slab.h>\n#include <linux/suspend.h>\n#include <linux/sysfs.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/onboard_hub.h>\n#include <linux/workqueue.h>\n\n#include \"onboard_usb_hub.h\"\n\n \nstatic const char * const supply_names[] = {\n\t\"vdd\",\n\t\"vdd2\",\n};\n\n#define MAX_SUPPLIES ARRAY_SIZE(supply_names)\n\nstatic void onboard_hub_attach_usb_driver(struct work_struct *work);\n\nstatic struct usb_device_driver onboard_hub_usbdev_driver;\nstatic DECLARE_WORK(attach_usb_driver_work, onboard_hub_attach_usb_driver);\n\n \n\nstruct usbdev_node {\n\tstruct usb_device *udev;\n\tstruct list_head list;\n};\n\nstruct onboard_hub {\n\tstruct regulator_bulk_data supplies[MAX_SUPPLIES];\n\tstruct device *dev;\n\tconst struct onboard_hub_pdata *pdata;\n\tstruct gpio_desc *reset_gpio;\n\tbool always_powered_in_suspend;\n\tbool is_powered_on;\n\tbool going_away;\n\tstruct list_head udev_list;\n\tstruct mutex lock;\n};\n\nstatic int onboard_hub_power_on(struct onboard_hub *hub)\n{\n\tint err;\n\n\terr = regulator_bulk_enable(hub->pdata->num_supplies, hub->supplies);\n\tif (err) {\n\t\tdev_err(hub->dev, \"failed to enable supplies: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\tfsleep(hub->pdata->reset_us);\n\tgpiod_set_value_cansleep(hub->reset_gpio, 0);\n\n\thub->is_powered_on = true;\n\n\treturn 0;\n}\n\nstatic int onboard_hub_power_off(struct onboard_hub *hub)\n{\n\tint err;\n\n\tgpiod_set_value_cansleep(hub->reset_gpio, 1);\n\n\terr = regulator_bulk_disable(hub->pdata->num_supplies, hub->supplies);\n\tif (err) {\n\t\tdev_err(hub->dev, \"failed to disable supplies: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thub->is_powered_on = false;\n\n\treturn 0;\n}\n\nstatic int __maybe_unused onboard_hub_suspend(struct device *dev)\n{\n\tstruct onboard_hub *hub = dev_get_drvdata(dev);\n\tstruct usbdev_node *node;\n\tbool power_off = true;\n\n\tif (hub->always_powered_in_suspend)\n\t\treturn 0;\n\n\tmutex_lock(&hub->lock);\n\n\tlist_for_each_entry(node, &hub->udev_list, list) {\n\t\tif (!device_may_wakeup(node->udev->bus->controller))\n\t\t\tcontinue;\n\n\t\tif (usb_wakeup_enabled_descendants(node->udev)) {\n\t\t\tpower_off = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&hub->lock);\n\n\tif (!power_off)\n\t\treturn 0;\n\n\treturn onboard_hub_power_off(hub);\n}\n\nstatic int __maybe_unused onboard_hub_resume(struct device *dev)\n{\n\tstruct onboard_hub *hub = dev_get_drvdata(dev);\n\n\tif (hub->is_powered_on)\n\t\treturn 0;\n\n\treturn onboard_hub_power_on(hub);\n}\n\nstatic inline void get_udev_link_name(const struct usb_device *udev, char *buf, size_t size)\n{\n\tsnprintf(buf, size, \"usb_dev.%s\", dev_name(&udev->dev));\n}\n\nstatic int onboard_hub_add_usbdev(struct onboard_hub *hub, struct usb_device *udev)\n{\n\tstruct usbdev_node *node;\n\tchar link_name[64];\n\tint err;\n\n\tmutex_lock(&hub->lock);\n\n\tif (hub->going_away) {\n\t\terr = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tnode = kzalloc(sizeof(*node), GFP_KERNEL);\n\tif (!node) {\n\t\terr = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tnode->udev = udev;\n\n\tlist_add(&node->list, &hub->udev_list);\n\n\tmutex_unlock(&hub->lock);\n\n\tget_udev_link_name(udev, link_name, sizeof(link_name));\n\tWARN_ON(sysfs_create_link(&hub->dev->kobj, &udev->dev.kobj, link_name));\n\n\treturn 0;\n\nerror:\n\tmutex_unlock(&hub->lock);\n\n\treturn err;\n}\n\nstatic void onboard_hub_remove_usbdev(struct onboard_hub *hub, const struct usb_device *udev)\n{\n\tstruct usbdev_node *node;\n\tchar link_name[64];\n\n\tget_udev_link_name(udev, link_name, sizeof(link_name));\n\tsysfs_remove_link(&hub->dev->kobj, link_name);\n\n\tmutex_lock(&hub->lock);\n\n\tlist_for_each_entry(node, &hub->udev_list, list) {\n\t\tif (node->udev == udev) {\n\t\t\tlist_del(&node->list);\n\t\t\tkfree(node);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&hub->lock);\n}\n\nstatic ssize_t always_powered_in_suspend_show(struct device *dev, struct device_attribute *attr,\n\t\t\t   char *buf)\n{\n\tconst struct onboard_hub *hub = dev_get_drvdata(dev);\n\n\treturn sysfs_emit(buf, \"%d\\n\", hub->always_powered_in_suspend);\n}\n\nstatic ssize_t always_powered_in_suspend_store(struct device *dev, struct device_attribute *attr,\n\t\t\t    const char *buf, size_t count)\n{\n\tstruct onboard_hub *hub = dev_get_drvdata(dev);\n\tbool val;\n\tint ret;\n\n\tret = kstrtobool(buf, &val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\thub->always_powered_in_suspend = val;\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(always_powered_in_suspend);\n\nstatic struct attribute *onboard_hub_attrs[] = {\n\t&dev_attr_always_powered_in_suspend.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(onboard_hub);\n\nstatic void onboard_hub_attach_usb_driver(struct work_struct *work)\n{\n\tint err;\n\n\terr = driver_attach(&onboard_hub_usbdev_driver.drvwrap.driver);\n\tif (err)\n\t\tpr_err(\"Failed to attach USB driver: %d\\n\", err);\n}\n\nstatic int onboard_hub_probe(struct platform_device *pdev)\n{\n\tconst struct of_device_id *of_id;\n\tstruct device *dev = &pdev->dev;\n\tstruct onboard_hub *hub;\n\tunsigned int i;\n\tint err;\n\n\thub = devm_kzalloc(dev, sizeof(*hub), GFP_KERNEL);\n\tif (!hub)\n\t\treturn -ENOMEM;\n\n\tof_id = of_match_device(onboard_hub_match, &pdev->dev);\n\tif (!of_id)\n\t\treturn -ENODEV;\n\n\thub->pdata = of_id->data;\n\tif (!hub->pdata)\n\t\treturn -EINVAL;\n\n\tif (hub->pdata->num_supplies > MAX_SUPPLIES)\n\t\treturn dev_err_probe(dev, -EINVAL, \"max %zu supplies supported!\\n\",\n\t\t\t\t     MAX_SUPPLIES);\n\n\tfor (i = 0; i < hub->pdata->num_supplies; i++)\n\t\thub->supplies[i].supply = supply_names[i];\n\n\terr = devm_regulator_bulk_get(dev, hub->pdata->num_supplies, hub->supplies);\n\tif (err) {\n\t\tdev_err(dev, \"Failed to get regulator supplies: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\thub->reset_gpio = devm_gpiod_get_optional(dev, \"reset\",\n\t\t\t\t\t\t  GPIOD_OUT_HIGH);\n\tif (IS_ERR(hub->reset_gpio))\n\t\treturn dev_err_probe(dev, PTR_ERR(hub->reset_gpio), \"failed to get reset GPIO\\n\");\n\n\thub->dev = dev;\n\tmutex_init(&hub->lock);\n\tINIT_LIST_HEAD(&hub->udev_list);\n\n\tdev_set_drvdata(dev, hub);\n\n\terr = onboard_hub_power_on(hub);\n\tif (err)\n\t\treturn err;\n\n\t \n\tschedule_work(&attach_usb_driver_work);\n\n\treturn 0;\n}\n\nstatic void onboard_hub_remove(struct platform_device *pdev)\n{\n\tstruct onboard_hub *hub = dev_get_drvdata(&pdev->dev);\n\tstruct usbdev_node *node;\n\tstruct usb_device *udev;\n\n\thub->going_away = true;\n\n\tmutex_lock(&hub->lock);\n\n\t \n\twhile (!list_empty(&hub->udev_list)) {\n\t\tnode = list_first_entry(&hub->udev_list, struct usbdev_node, list);\n\t\tudev = node->udev;\n\n\t\t \n\t\tget_device(&udev->dev);\n\t\tmutex_unlock(&hub->lock);\n\t\tdevice_release_driver(&udev->dev);\n\t\tput_device(&udev->dev);\n\t\tmutex_lock(&hub->lock);\n\t}\n\n\tmutex_unlock(&hub->lock);\n\n\tonboard_hub_power_off(hub);\n}\n\nMODULE_DEVICE_TABLE(of, onboard_hub_match);\n\nstatic const struct dev_pm_ops __maybe_unused onboard_hub_pm_ops = {\n\tSET_LATE_SYSTEM_SLEEP_PM_OPS(onboard_hub_suspend, onboard_hub_resume)\n};\n\nstatic struct platform_driver onboard_hub_driver = {\n\t.probe = onboard_hub_probe,\n\t.remove_new = onboard_hub_remove,\n\n\t.driver = {\n\t\t.name = \"onboard-usb-hub\",\n\t\t.of_match_table = onboard_hub_match,\n\t\t.pm = pm_ptr(&onboard_hub_pm_ops),\n\t\t.dev_groups = onboard_hub_groups,\n\t},\n};\n\n \n\n#define VENDOR_ID_CYPRESS\t0x04b4\n#define VENDOR_ID_GENESYS\t0x05e3\n#define VENDOR_ID_MICROCHIP\t0x0424\n#define VENDOR_ID_REALTEK\t0x0bda\n#define VENDOR_ID_TI\t\t0x0451\n#define VENDOR_ID_VIA\t\t0x2109\n\n \nstatic struct onboard_hub *_find_onboard_hub(struct device *dev)\n{\n\tstruct platform_device *pdev;\n\tstruct device_node *np;\n\tstruct onboard_hub *hub;\n\n\tpdev = of_find_device_by_node(dev->of_node);\n\tif (!pdev) {\n\t\tnp = of_parse_phandle(dev->of_node, \"peer-hub\", 0);\n\t\tif (!np) {\n\t\t\tdev_err(dev, \"failed to find device node for peer hub\\n\");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\n\t\tpdev = of_find_device_by_node(np);\n\t\tof_node_put(np);\n\n\t\tif (!pdev)\n\t\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\thub = dev_get_drvdata(&pdev->dev);\n\tput_device(&pdev->dev);\n\n\t \n\tif (!hub)\n\t\treturn ERR_PTR(-EPROBE_DEFER);\n\n\treturn hub;\n}\n\nstatic int onboard_hub_usbdev_probe(struct usb_device *udev)\n{\n\tstruct device *dev = &udev->dev;\n\tstruct onboard_hub *hub;\n\tint err;\n\n\t \n\tif (!dev->of_node)\n\t\treturn -ENODEV;\n\n\thub = _find_onboard_hub(dev);\n\tif (IS_ERR(hub))\n\t\treturn PTR_ERR(hub);\n\n\tdev_set_drvdata(dev, hub);\n\n\terr = onboard_hub_add_usbdev(hub, udev);\n\tif (err)\n\t\treturn err;\n\n\treturn 0;\n}\n\nstatic void onboard_hub_usbdev_disconnect(struct usb_device *udev)\n{\n\tstruct onboard_hub *hub = dev_get_drvdata(&udev->dev);\n\n\tonboard_hub_remove_usbdev(hub, udev);\n}\n\nstatic const struct usb_device_id onboard_hub_id_table[] = {\n\t{ USB_DEVICE(VENDOR_ID_CYPRESS, 0x6504) },  \n\t{ USB_DEVICE(VENDOR_ID_CYPRESS, 0x6506) },  \n\t{ USB_DEVICE(VENDOR_ID_GENESYS, 0x0608) },  \n\t{ USB_DEVICE(VENDOR_ID_GENESYS, 0x0610) },  \n\t{ USB_DEVICE(VENDOR_ID_GENESYS, 0x0620) },  \n\t{ USB_DEVICE(VENDOR_ID_MICROCHIP, 0x2412) },  \n\t{ USB_DEVICE(VENDOR_ID_MICROCHIP, 0x2514) },  \n\t{ USB_DEVICE(VENDOR_ID_MICROCHIP, 0x2517) },  \n\t{ USB_DEVICE(VENDOR_ID_MICROCHIP, 0x2744) },  \n\t{ USB_DEVICE(VENDOR_ID_MICROCHIP, 0x5744) },  \n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x0411) },  \n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x5411) },  \n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x0414) },  \n\t{ USB_DEVICE(VENDOR_ID_REALTEK, 0x5414) },  \n\t{ USB_DEVICE(VENDOR_ID_TI, 0x8140) },  \n\t{ USB_DEVICE(VENDOR_ID_TI, 0x8142) },  \n\t{ USB_DEVICE(VENDOR_ID_VIA, 0x0817) },  \n\t{ USB_DEVICE(VENDOR_ID_VIA, 0x2817) },  \n\t{}\n};\nMODULE_DEVICE_TABLE(usb, onboard_hub_id_table);\n\nstatic struct usb_device_driver onboard_hub_usbdev_driver = {\n\t.name = \"onboard-usb-hub\",\n\t.probe = onboard_hub_usbdev_probe,\n\t.disconnect = onboard_hub_usbdev_disconnect,\n\t.generic_subclass = 1,\n\t.supports_autosuspend =\t1,\n\t.id_table = onboard_hub_id_table,\n};\n\nstatic int __init onboard_hub_init(void)\n{\n\tint ret;\n\n\tret = usb_register_device_driver(&onboard_hub_usbdev_driver, THIS_MODULE);\n\tif (ret)\n\t\treturn ret;\n\n\tret = platform_driver_register(&onboard_hub_driver);\n\tif (ret)\n\t\tusb_deregister_device_driver(&onboard_hub_usbdev_driver);\n\n\treturn ret;\n}\nmodule_init(onboard_hub_init);\n\nstatic void __exit onboard_hub_exit(void)\n{\n\tusb_deregister_device_driver(&onboard_hub_usbdev_driver);\n\tplatform_driver_unregister(&onboard_hub_driver);\n\n\tcancel_work_sync(&attach_usb_driver_work);\n}\nmodule_exit(onboard_hub_exit);\n\nMODULE_AUTHOR(\"Matthias Kaehlcke <mka@chromium.org>\");\nMODULE_DESCRIPTION(\"Driver for discrete onboard USB hubs\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}