{
  "module_name": "cypress_cy7c63.c",
  "hash_id": "06d342aa8659ac1839ead370451e3d491f923b4a6eced691cdfbfe397f7efcdd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/cypress_cy7c63.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n\n#define DRIVER_AUTHOR\t\t\"Oliver Bock (bock@tfh-berlin.de)\"\n#define DRIVER_DESC\t\t\"Cypress CY7C63xxx USB driver\"\n\n#define CYPRESS_VENDOR_ID\t0xa2c\n#define CYPRESS_PRODUCT_ID\t0x8\n\n#define CYPRESS_READ_PORT\t0x4\n#define CYPRESS_WRITE_PORT\t0x5\n\n#define CYPRESS_READ_RAM\t0x2\n#define CYPRESS_WRITE_RAM\t0x3\n#define CYPRESS_READ_ROM\t0x1\n\n#define CYPRESS_READ_PORT_ID0\t0\n#define CYPRESS_WRITE_PORT_ID0\t0\n#define CYPRESS_READ_PORT_ID1\t0x2\n#define CYPRESS_WRITE_PORT_ID1\t1\n\n#define CYPRESS_MAX_REQSIZE\t8\n\n\n \nstatic const struct usb_device_id cypress_table[] = {\n\t{ USB_DEVICE(CYPRESS_VENDOR_ID, CYPRESS_PRODUCT_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE(usb, cypress_table);\n\n \nstruct cypress {\n\tstruct usb_device *\tudev;\n\tunsigned char\t\tport[2];\n};\n\n \nstatic int vendor_command(struct cypress *dev, unsigned char request,\n\t\t\t  unsigned char address, unsigned char data)\n{\n\tint retval = 0;\n\tunsigned int pipe;\n\tunsigned char *iobuf;\n\n\t \n\tiobuf = kzalloc(CYPRESS_MAX_REQSIZE, GFP_KERNEL);\n\tif (!iobuf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tdev_dbg(&dev->udev->dev, \"Sending usb_control_msg (data: %d)\\n\", data);\n\n\t \n\tpipe = usb_rcvctrlpipe(dev->udev, 0);\n\tretval = usb_control_msg(dev->udev, pipe, request,\n\t\t\t\t USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t\t address, data, iobuf, CYPRESS_MAX_REQSIZE,\n\t\t\t\t USB_CTRL_GET_TIMEOUT);\n\n\t \n\tswitch (request) {\n\t\tcase CYPRESS_READ_PORT:\n\t\t\tif (address == CYPRESS_READ_PORT_ID0) {\n\t\t\t\tdev->port[0] = iobuf[1];\n\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\"READ_PORT0 returned: %d\\n\",\n\t\t\t\t\tdev->port[0]);\n\t\t\t}\n\t\t\telse if (address == CYPRESS_READ_PORT_ID1) {\n\t\t\t\tdev->port[1] = iobuf[1];\n\t\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\t\"READ_PORT1 returned: %d\\n\",\n\t\t\t\t\tdev->port[1]);\n\t\t\t}\n\t\t\tbreak;\n\t}\n\n\tkfree(iobuf);\nerror:\n\treturn retval;\n}\n\n \nstatic ssize_t write_port(struct device *dev, struct device_attribute *attr,\n\t\t\t  const char *buf, size_t count,\n\t\t\t  int port_num, int write_id)\n{\n\tint value = -1;\n\tint result = 0;\n\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct cypress *cyp = usb_get_intfdata(intf);\n\n\tdev_dbg(&cyp->udev->dev, \"WRITE_PORT%d called\\n\", port_num);\n\n\t \n\tif (sscanf(buf, \"%d\", &value) < 1) {\n\t\tresult = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (value < 0 || value > 255) {\n\t\tresult = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tresult = vendor_command(cyp, CYPRESS_WRITE_PORT, write_id,\n\t\t\t\t(unsigned char)value);\n\n\tdev_dbg(&cyp->udev->dev, \"Result of vendor_command: %d\\n\\n\", result);\nerror:\n\treturn result < 0 ? result : count;\n}\n\n \nstatic ssize_t port0_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\treturn write_port(dev, attr, buf, count, 0, CYPRESS_WRITE_PORT_ID0);\n}\n\n \nstatic ssize_t port1_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\treturn write_port(dev, attr, buf, count, 1, CYPRESS_WRITE_PORT_ID1);\n}\n\n \nstatic ssize_t read_port(struct device *dev, struct device_attribute *attr,\n\t\t\t char *buf, int port_num, int read_id)\n{\n\tint result = 0;\n\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct cypress *cyp = usb_get_intfdata(intf);\n\n\tdev_dbg(&cyp->udev->dev, \"READ_PORT%d called\\n\", port_num);\n\n\tresult = vendor_command(cyp, CYPRESS_READ_PORT, read_id, 0);\n\n\tdev_dbg(&cyp->udev->dev, \"Result of vendor_command: %d\\n\\n\", result);\n\n\treturn sprintf(buf, \"%d\", cyp->port[port_num]);\n}\n\n \nstatic ssize_t port0_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn read_port(dev, attr, buf, 0, CYPRESS_READ_PORT_ID0);\n}\nstatic DEVICE_ATTR_RW(port0);\n\n \nstatic ssize_t port1_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\treturn read_port(dev, attr, buf, 1, CYPRESS_READ_PORT_ID1);\n}\nstatic DEVICE_ATTR_RW(port1);\n\nstatic struct attribute *cypress_attrs[] = {\n\t&dev_attr_port0.attr,\n\t&dev_attr_port1.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cypress);\n\nstatic int cypress_probe(struct usb_interface *interface,\n\t\t\t const struct usb_device_id *id)\n{\n\tstruct cypress *dev;\n\tint retval = -ENOMEM;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error_mem;\n\n\tdev->udev = usb_get_dev(interface_to_usbdev(interface));\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\t \n\tdev_info(&interface->dev,\n\t\t \"Cypress CY7C63xxx device now attached\\n\");\n\treturn 0;\n\nerror_mem:\n\treturn retval;\n}\n\nstatic void cypress_disconnect(struct usb_interface *interface)\n{\n\tstruct cypress *dev;\n\n\tdev = usb_get_intfdata(interface);\n\n\t \n\tusb_set_intfdata(interface, NULL);\n\n\tusb_put_dev(dev->udev);\n\n\tdev_info(&interface->dev,\n\t\t \"Cypress CY7C63xxx device now disconnected\\n\");\n\n\tkfree(dev);\n}\n\nstatic struct usb_driver cypress_driver = {\n\t.name = \"cypress_cy7c63\",\n\t.probe = cypress_probe,\n\t.disconnect = cypress_disconnect,\n\t.id_table = cypress_table,\n\t.dev_groups = cypress_groups,\n};\n\nmodule_usb_driver(cypress_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}