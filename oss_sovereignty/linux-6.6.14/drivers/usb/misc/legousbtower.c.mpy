{
  "module_name": "legousbtower.c",
  "hash_id": "e40105edba4e69b6db548221ce0804ab2693490dd9713b5020dce88b2dbb55dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/legousbtower.c",
  "human_readable_source": "\n \n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/completion.h>\n#include <linux/mutex.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/poll.h>\n\n\n#define DRIVER_AUTHOR \"Juergen Stuber <starblue@sourceforge.net>\"\n#define DRIVER_DESC \"LEGO USB Tower Driver\"\n\n\n \n\n \nstatic int read_buffer_size = 480;\nmodule_param(read_buffer_size, int, 0);\nMODULE_PARM_DESC(read_buffer_size, \"Read buffer size\");\n\n \nstatic int write_buffer_size = 480;\nmodule_param(write_buffer_size, int, 0);\nMODULE_PARM_DESC(write_buffer_size, \"Write buffer size\");\n\n \nstatic int packet_timeout = 50;\nmodule_param(packet_timeout, int, 0);\nMODULE_PARM_DESC(packet_timeout, \"Packet timeout in ms\");\n\n \nstatic int read_timeout = 200;\nmodule_param(read_timeout, int, 0);\nMODULE_PARM_DESC(read_timeout, \"Read timeout in ms\");\n\n \nstatic int interrupt_in_interval = 2;\nmodule_param(interrupt_in_interval, int, 0);\nMODULE_PARM_DESC(interrupt_in_interval, \"Interrupt in interval in ms\");\n\nstatic int interrupt_out_interval = 8;\nmodule_param(interrupt_out_interval, int, 0);\nMODULE_PARM_DESC(interrupt_out_interval, \"Interrupt out interval in ms\");\n\n \n#define LEGO_USB_TOWER_VENDOR_ID\t0x0694\n#define LEGO_USB_TOWER_PRODUCT_ID\t0x0001\n\n \n#define LEGO_USB_TOWER_REQUEST_RESET\t\t0x04\n#define LEGO_USB_TOWER_REQUEST_GET_VERSION\t0xFD\n\nstruct tower_reset_reply {\n\t__le16 size;\n\t__u8 err_code;\n\t__u8 spare;\n};\n\nstruct tower_get_version_reply {\n\t__le16 size;\n\t__u8 err_code;\n\t__u8 spare;\n\t__u8 major;\n\t__u8 minor;\n\t__le16 build_no;\n};\n\n\n \nstatic const struct usb_device_id tower_table[] = {\n\t{ USB_DEVICE(LEGO_USB_TOWER_VENDOR_ID, LEGO_USB_TOWER_PRODUCT_ID) },\n\t{ }\t\t\t\t\t \n};\n\nMODULE_DEVICE_TABLE(usb, tower_table);\n\n#define LEGO_USB_TOWER_MINOR_BASE\t160\n\n\n \nstruct lego_usb_tower {\n\tstruct mutex\t\tlock;\t\t \n\tstruct usb_device\t*udev;\t\t \n\tunsigned char\t\tminor;\t\t \n\n\tint\t\t\topen_count;\t \n\tunsigned long\t\tdisconnected:1;\n\n\tchar\t\t\t*read_buffer;\n\tsize_t\t\t\tread_buffer_length;  \n\tsize_t\t\t\tread_packet_length;  \n\tspinlock_t\t\tread_buffer_lock;\n\tint\t\t\tpacket_timeout_jiffies;\n\tunsigned long\t\tread_last_arrival;\n\n\twait_queue_head_t\tread_wait;\n\twait_queue_head_t\twrite_wait;\n\n\tchar\t\t\t*interrupt_in_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_in_endpoint;\n\tstruct urb\t\t*interrupt_in_urb;\n\tint\t\t\tinterrupt_in_interval;\n\tint\t\t\tinterrupt_in_done;\n\n\tchar\t\t\t*interrupt_out_buffer;\n\tstruct usb_endpoint_descriptor *interrupt_out_endpoint;\n\tstruct urb\t\t*interrupt_out_urb;\n\tint\t\t\tinterrupt_out_interval;\n\tint\t\t\tinterrupt_out_busy;\n\n};\n\n\n \nstatic ssize_t tower_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos);\nstatic ssize_t tower_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos);\nstatic inline void tower_delete(struct lego_usb_tower *dev);\nstatic int tower_open(struct inode *inode, struct file *file);\nstatic int tower_release(struct inode *inode, struct file *file);\nstatic __poll_t tower_poll(struct file *file, poll_table *wait);\nstatic loff_t tower_llseek(struct file *file, loff_t off, int whence);\n\nstatic void tower_check_for_read_packet(struct lego_usb_tower *dev);\nstatic void tower_interrupt_in_callback(struct urb *urb);\nstatic void tower_interrupt_out_callback(struct urb *urb);\n\nstatic int  tower_probe(struct usb_interface *interface, const struct usb_device_id *id);\nstatic void tower_disconnect(struct usb_interface *interface);\n\n\n \nstatic const struct file_operations tower_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.read  =\ttower_read,\n\t.write =\ttower_write,\n\t.open =\t\ttower_open,\n\t.release =\ttower_release,\n\t.poll =\t\ttower_poll,\n\t.llseek =\ttower_llseek,\n};\n\nstatic char *legousbtower_devnode(const struct device *dev, umode_t *mode)\n{\n\treturn kasprintf(GFP_KERNEL, \"usb/%s\", dev_name(dev));\n}\n\n \nstatic struct usb_class_driver tower_class = {\n\t.name =\t\t\"legousbtower%d\",\n\t.devnode = \tlegousbtower_devnode,\n\t.fops =\t\t&tower_fops,\n\t.minor_base =\tLEGO_USB_TOWER_MINOR_BASE,\n};\n\n\n \nstatic struct usb_driver tower_driver = {\n\t.name =\t\t\"legousbtower\",\n\t.probe =\ttower_probe,\n\t.disconnect =\ttower_disconnect,\n\t.id_table =\ttower_table,\n};\n\n\n \nstatic inline void lego_usb_tower_debug_data(struct device *dev,\n\t\t\t\t\t     const char *function, int size,\n\t\t\t\t\t     const unsigned char *data)\n{\n\tdev_dbg(dev, \"%s - length = %d, data = %*ph\\n\",\n\t\tfunction, size, size, data);\n}\n\n\n \nstatic inline void tower_delete(struct lego_usb_tower *dev)\n{\n\t \n\tusb_free_urb(dev->interrupt_in_urb);\n\tusb_free_urb(dev->interrupt_out_urb);\n\tkfree(dev->read_buffer);\n\tkfree(dev->interrupt_in_buffer);\n\tkfree(dev->interrupt_out_buffer);\n\tusb_put_dev(dev->udev);\n\tkfree(dev);\n}\n\n\n \nstatic int tower_open(struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev = NULL;\n\tint subminor;\n\tint retval = 0;\n\tstruct usb_interface *interface;\n\tstruct tower_reset_reply reset_reply;\n\tint result;\n\n\tnonseekable_open(inode, file);\n\tsubminor = iminor(inode);\n\n\tinterface = usb_find_interface(&tower_driver, subminor);\n\tif (!interface) {\n\t\tpr_err(\"error, can't find device for minor %d\\n\", subminor);\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tdev = usb_get_intfdata(interface);\n\tif (!dev) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t        retval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\n\t \n\tif (dev->open_count) {\n\t\tretval = -EBUSY;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tresult = usb_control_msg_recv(dev->udev, 0,\n\t\t\t\t      LEGO_USB_TOWER_REQUEST_RESET,\n\t\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t      0, 0,\n\t\t\t\t      &reset_reply, sizeof(reset_reply), 1000,\n\t\t\t\t      GFP_KERNEL);\n\tif (result < 0) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"LEGO USB Tower reset control request failed\\n\");\n\t\tretval = result;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tdev->read_buffer_length = 0;\n\tdev->read_packet_length = 0;\n\tusb_fill_int_urb(dev->interrupt_in_urb,\n\t\t\t dev->udev,\n\t\t\t usb_rcvintpipe(dev->udev, dev->interrupt_in_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_in_buffer,\n\t\t\t usb_endpoint_maxp(dev->interrupt_in_endpoint),\n\t\t\t tower_interrupt_in_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_in_interval);\n\n\tdev->interrupt_in_done = 0;\n\tmb();\n\n\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_in_urb %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tfile->private_data = dev;\n\n\tdev->open_count = 1;\n\nunlock_exit:\n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n \nstatic int tower_release(struct inode *inode, struct file *file)\n{\n\tstruct lego_usb_tower *dev;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\tif (dev == NULL) {\n\t\tretval = -ENODEV;\n\t\tgoto exit;\n\t}\n\n\tmutex_lock(&dev->lock);\n\n\tif (dev->disconnected) {\n\t\t \n\n\t\t \n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete(dev);\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->interrupt_out_busy) {\n\t\twait_event_interruptible_timeout(dev->write_wait, !dev->interrupt_out_busy,\n\t\t\t\t\t\t 2 * HZ);\n\t}\n\n\t \n\tusb_kill_urb(dev->interrupt_in_urb);\n\tusb_kill_urb(dev->interrupt_out_urb);\n\n\tdev->open_count = 0;\n\n\tmutex_unlock(&dev->lock);\nexit:\n\treturn retval;\n}\n\n \nstatic void tower_check_for_read_packet(struct lego_usb_tower *dev)\n{\n\tspin_lock_irq(&dev->read_buffer_lock);\n\tif (!packet_timeout\n\t    || time_after(jiffies, dev->read_last_arrival + dev->packet_timeout_jiffies)\n\t    || dev->read_buffer_length == read_buffer_size) {\n\t\tdev->read_packet_length = dev->read_buffer_length;\n\t}\n\tdev->interrupt_in_done = 0;\n\tspin_unlock_irq(&dev->read_buffer_lock);\n}\n\n\n \nstatic __poll_t tower_poll(struct file *file, poll_table *wait)\n{\n\tstruct lego_usb_tower *dev;\n\t__poll_t mask = 0;\n\n\tdev = file->private_data;\n\n\tif (dev->disconnected)\n\t\treturn EPOLLERR | EPOLLHUP;\n\n\tpoll_wait(file, &dev->read_wait, wait);\n\tpoll_wait(file, &dev->write_wait, wait);\n\n\ttower_check_for_read_packet(dev);\n\tif (dev->read_packet_length > 0)\n\t\tmask |= EPOLLIN | EPOLLRDNORM;\n\tif (!dev->interrupt_out_busy)\n\t\tmask |= EPOLLOUT | EPOLLWRNORM;\n\n\treturn mask;\n}\n\n\n \nstatic loff_t tower_llseek(struct file *file, loff_t off, int whence)\n{\n\treturn -ESPIPE;\t\t \n}\n\n\n \nstatic ssize_t tower_read(struct file *file, char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_read;\n\tint i;\n\tint retval = 0;\n\tunsigned long timeout = 0;\n\n\tdev = file->private_data;\n\n\t \n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"read request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\tif (read_timeout)\n\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\n\t \n\ttower_check_for_read_packet(dev);\n\twhile (dev->read_packet_length == 0) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible_timeout(dev->read_wait, dev->interrupt_in_done, dev->packet_timeout_jiffies);\n\t\tif (retval < 0)\n\t\t\tgoto unlock_exit;\n\n\t\t \n\t\tif (read_timeout\n\t\t    && (dev->read_buffer_length || dev->interrupt_out_busy)) {\n\t\t\ttimeout = jiffies + msecs_to_jiffies(read_timeout);\n\t\t}\n\t\t \n\t\tif (read_timeout && time_after(jiffies, timeout)) {\n\t\t\tretval = -ETIMEDOUT;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\ttower_check_for_read_packet(dev);\n\t}\n\n\t \n\tbytes_to_read = min(count, dev->read_packet_length);\n\n\tif (copy_to_user(buffer, dev->read_buffer, bytes_to_read)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\tspin_lock_irq(&dev->read_buffer_lock);\n\tdev->read_buffer_length -= bytes_to_read;\n\tdev->read_packet_length -= bytes_to_read;\n\tfor (i = 0; i < dev->read_buffer_length; i++)\n\t\tdev->read_buffer[i] = dev->read_buffer[i+bytes_to_read];\n\tspin_unlock_irq(&dev->read_buffer_lock);\n\n\tretval = bytes_to_read;\n\nunlock_exit:\n\t \n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n \nstatic ssize_t tower_write(struct file *file, const char __user *buffer, size_t count, loff_t *ppos)\n{\n\tstruct lego_usb_tower *dev;\n\tsize_t bytes_to_write;\n\tint retval = 0;\n\n\tdev = file->private_data;\n\n\t \n\tif (mutex_lock_interruptible(&dev->lock)) {\n\t\tretval = -ERESTARTSYS;\n\t\tgoto exit;\n\t}\n\n\t \n\tif (dev->disconnected) {\n\t\tretval = -ENODEV;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tif (count == 0) {\n\t\tdev_dbg(&dev->udev->dev, \"write request of 0 bytes\\n\");\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\twhile (dev->interrupt_out_busy) {\n\t\tif (file->f_flags & O_NONBLOCK) {\n\t\t\tretval = -EAGAIN;\n\t\t\tgoto unlock_exit;\n\t\t}\n\t\tretval = wait_event_interruptible(dev->write_wait,\n\t\t\t\t\t\t  !dev->interrupt_out_busy);\n\t\tif (retval)\n\t\t\tgoto unlock_exit;\n\t}\n\n\t \n\tbytes_to_write = min_t(int, count, write_buffer_size);\n\tdev_dbg(&dev->udev->dev, \"%s: count = %zd, bytes_to_write = %zd\\n\",\n\t\t__func__, count, bytes_to_write);\n\n\tif (copy_from_user(dev->interrupt_out_buffer, buffer, bytes_to_write)) {\n\t\tretval = -EFAULT;\n\t\tgoto unlock_exit;\n\t}\n\n\t \n\tusb_fill_int_urb(dev->interrupt_out_urb,\n\t\t\t dev->udev,\n\t\t\t usb_sndintpipe(dev->udev, dev->interrupt_out_endpoint->bEndpointAddress),\n\t\t\t dev->interrupt_out_buffer,\n\t\t\t bytes_to_write,\n\t\t\t tower_interrupt_out_callback,\n\t\t\t dev,\n\t\t\t dev->interrupt_out_interval);\n\n\tdev->interrupt_out_busy = 1;\n\twmb();\n\n\tretval = usb_submit_urb(dev->interrupt_out_urb, GFP_KERNEL);\n\tif (retval) {\n\t\tdev->interrupt_out_busy = 0;\n\t\tdev_err(&dev->udev->dev,\n\t\t\t\"Couldn't submit interrupt_out_urb %d\\n\", retval);\n\t\tgoto unlock_exit;\n\t}\n\tretval = bytes_to_write;\n\nunlock_exit:\n\t \n\tmutex_unlock(&dev->lock);\n\nexit:\n\treturn retval;\n}\n\n\n \nstatic void tower_interrupt_in_callback(struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\tint retval;\n\tunsigned long flags;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\tif (status) {\n\t\tif (status == -ENOENT ||\n\t\t    status == -ECONNRESET ||\n\t\t    status == -ESHUTDOWN) {\n\t\t\tgoto exit;\n\t\t} else {\n\t\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\t\"%s: nonzero status received: %d\\n\", __func__,\n\t\t\t\tstatus);\n\t\t\tgoto resubmit;  \n\t\t}\n\t}\n\n\tif (urb->actual_length > 0) {\n\t\tspin_lock_irqsave(&dev->read_buffer_lock, flags);\n\t\tif (dev->read_buffer_length + urb->actual_length < read_buffer_size) {\n\t\t\tmemcpy(dev->read_buffer + dev->read_buffer_length,\n\t\t\t       dev->interrupt_in_buffer,\n\t\t\t       urb->actual_length);\n\t\t\tdev->read_buffer_length += urb->actual_length;\n\t\t\tdev->read_last_arrival = jiffies;\n\t\t\tdev_dbg(&dev->udev->dev, \"%s: received %d bytes\\n\",\n\t\t\t\t__func__, urb->actual_length);\n\t\t} else {\n\t\t\tpr_warn(\"read_buffer overflow, %d bytes dropped\\n\",\n\t\t\t\turb->actual_length);\n\t\t}\n\t\tspin_unlock_irqrestore(&dev->read_buffer_lock, flags);\n\t}\n\nresubmit:\n\tretval = usb_submit_urb(dev->interrupt_in_urb, GFP_ATOMIC);\n\tif (retval) {\n\t\tdev_err(&dev->udev->dev, \"%s: usb_submit_urb failed (%d)\\n\",\n\t\t\t__func__, retval);\n\t}\nexit:\n\tdev->interrupt_in_done = 1;\n\twake_up_interruptible(&dev->read_wait);\n}\n\n\n \nstatic void tower_interrupt_out_callback(struct urb *urb)\n{\n\tstruct lego_usb_tower *dev = urb->context;\n\tint status = urb->status;\n\n\tlego_usb_tower_debug_data(&dev->udev->dev, __func__,\n\t\t\t\t  urb->actual_length, urb->transfer_buffer);\n\n\t \n\tif (status && !(status == -ENOENT ||\n\t\t\tstatus == -ECONNRESET ||\n\t\t\tstatus == -ESHUTDOWN)) {\n\t\tdev_dbg(&dev->udev->dev,\n\t\t\t\"%s: nonzero write bulk status received: %d\\n\", __func__,\n\t\t\tstatus);\n\t}\n\n\tdev->interrupt_out_busy = 0;\n\twake_up_interruptible(&dev->write_wait);\n}\n\n\n \nstatic int tower_probe(struct usb_interface *interface, const struct usb_device_id *id)\n{\n\tstruct device *idev = &interface->dev;\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct lego_usb_tower *dev;\n\tstruct tower_get_version_reply get_version_reply;\n\tint retval = -ENOMEM;\n\tint result;\n\n\t \n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto exit;\n\n\tmutex_init(&dev->lock);\n\tdev->udev = usb_get_dev(udev);\n\tspin_lock_init(&dev->read_buffer_lock);\n\tdev->packet_timeout_jiffies = msecs_to_jiffies(packet_timeout);\n\tdev->read_last_arrival = jiffies;\n\tinit_waitqueue_head(&dev->read_wait);\n\tinit_waitqueue_head(&dev->write_wait);\n\n\tresult = usb_find_common_endpoints_reverse(interface->cur_altsetting,\n\t\t\tNULL, NULL,\n\t\t\t&dev->interrupt_in_endpoint,\n\t\t\t&dev->interrupt_out_endpoint);\n\tif (result) {\n\t\tdev_err(idev, \"interrupt endpoints not found\\n\");\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\n\tdev->read_buffer = kmalloc(read_buffer_size, GFP_KERNEL);\n\tif (!dev->read_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_buffer = kmalloc(usb_endpoint_maxp(dev->interrupt_in_endpoint), GFP_KERNEL);\n\tif (!dev->interrupt_in_buffer)\n\t\tgoto error;\n\tdev->interrupt_in_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_in_urb)\n\t\tgoto error;\n\tdev->interrupt_out_buffer = kmalloc(write_buffer_size, GFP_KERNEL);\n\tif (!dev->interrupt_out_buffer)\n\t\tgoto error;\n\tdev->interrupt_out_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!dev->interrupt_out_urb)\n\t\tgoto error;\n\tdev->interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev->interrupt_in_endpoint->bInterval;\n\tdev->interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev->interrupt_out_endpoint->bInterval;\n\n\t \n\tresult = usb_control_msg_recv(udev, 0,\n\t\t\t\t      LEGO_USB_TOWER_REQUEST_GET_VERSION,\n\t\t\t\t      USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t      0,\n\t\t\t\t      0,\n\t\t\t\t      &get_version_reply,\n\t\t\t\t      sizeof(get_version_reply),\n\t\t\t\t      1000, GFP_KERNEL);\n\tif (result) {\n\t\tdev_err(idev, \"get version request failed: %d\\n\", result);\n\t\tretval = result;\n\t\tgoto error;\n\t}\n\tdev_info(&interface->dev,\n\t\t \"LEGO USB Tower firmware version is %d.%d build %d\\n\",\n\t\t get_version_reply.major,\n\t\t get_version_reply.minor,\n\t\t le16_to_cpu(get_version_reply.build_no));\n\n\t \n\tusb_set_intfdata(interface, dev);\n\n\tretval = usb_register_dev(interface, &tower_class);\n\tif (retval) {\n\t\t \n\t\tdev_err(idev, \"Not able to get a minor for this device.\\n\");\n\t\tgoto error;\n\t}\n\tdev->minor = interface->minor;\n\n\t \n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now attached to major \"\n\t\t \"%d minor %d\\n\", (dev->minor - LEGO_USB_TOWER_MINOR_BASE),\n\t\t USB_MAJOR, dev->minor);\n\nexit:\n\treturn retval;\n\nerror:\n\ttower_delete(dev);\n\treturn retval;\n}\n\n\n \nstatic void tower_disconnect(struct usb_interface *interface)\n{\n\tstruct lego_usb_tower *dev;\n\tint minor;\n\n\tdev = usb_get_intfdata(interface);\n\n\tminor = dev->minor;\n\n\t \n\tusb_deregister_dev(interface, &tower_class);\n\n\t \n\tusb_poison_urb(dev->interrupt_in_urb);\n\tusb_poison_urb(dev->interrupt_out_urb);\n\n\tmutex_lock(&dev->lock);\n\n\t \n\tif (!dev->open_count) {\n\t\tmutex_unlock(&dev->lock);\n\t\ttower_delete(dev);\n\t} else {\n\t\tdev->disconnected = 1;\n\t\t \n\t\twake_up_interruptible_all(&dev->read_wait);\n\t\twake_up_interruptible_all(&dev->write_wait);\n\t\tmutex_unlock(&dev->lock);\n\t}\n\n\tdev_info(&interface->dev, \"LEGO USB Tower #%d now disconnected\\n\",\n\t\t (minor - LEGO_USB_TOWER_MINOR_BASE));\n}\n\nmodule_usb_driver(tower_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}