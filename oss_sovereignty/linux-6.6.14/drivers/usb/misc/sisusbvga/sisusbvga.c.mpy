{
  "module_name": "sisusbvga.c",
  "hash_id": "f4dab4f4005fd162b8808fde54cd5150f3fde9321c5105174cfe46d7d41509fc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/sisusbvga/sisusbvga.c",
  "human_readable_source": "\n \n\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/signal.h>\n#include <linux/errno.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/spinlock.h>\n#include <linux/kref.h>\n#include <linux/usb.h>\n#include <linux/vmalloc.h>\n\n#include \"sisusb.h\"\n\n#define SISUSB_DONTSYNC\n\n \n\nstatic struct usb_driver sisusb_driver;\n\nstatic void sisusb_free_buffers(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tfor (i = 0; i < NUMOBUFS; i++) {\n\t\tkfree(sisusb->obuf[i]);\n\t\tsisusb->obuf[i] = NULL;\n\t}\n\tkfree(sisusb->ibuf);\n\tsisusb->ibuf = NULL;\n}\n\nstatic void sisusb_free_urbs(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tfor (i = 0; i < NUMOBUFS; i++) {\n\t\tusb_free_urb(sisusb->sisurbout[i]);\n\t\tsisusb->sisurbout[i] = NULL;\n\t}\n\tusb_free_urb(sisusb->sisurbin);\n\tsisusb->sisurbin = NULL;\n}\n\n \n\n \n\n \n\n \nstatic int sisusb_all_free(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\n\t\tif (sisusb->urbstatus[i] & SU_URB_BUSY)\n\t\t\treturn 0;\n\n\t}\n\n\treturn 1;\n}\n\n \nstatic void sisusb_kill_all_busy(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tif (sisusb_all_free(sisusb))\n\t\treturn;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\n\t\tif (sisusb->urbstatus[i] & SU_URB_BUSY)\n\t\t\tusb_kill_urb(sisusb->sisurbout[i]);\n\n\t}\n}\n\n \nstatic int sisusb_wait_all_out_complete(struct sisusb_usb_data *sisusb)\n{\n\tint timeout = 5 * HZ, i = 1;\n\n\twait_event_timeout(sisusb->wait_q, (i = sisusb_all_free(sisusb)),\n\t\t\ttimeout);\n\n\treturn i;\n}\n\nstatic int sisusb_outurb_available(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\n\t\tif ((sisusb->urbstatus[i] & (SU_URB_BUSY|SU_URB_ALLOC)) == 0)\n\t\t\treturn i;\n\n\t}\n\n\treturn -1;\n}\n\nstatic int sisusb_get_free_outbuf(struct sisusb_usb_data *sisusb)\n{\n\tint i, timeout = 5 * HZ;\n\n\twait_event_timeout(sisusb->wait_q,\n\t\t\t((i = sisusb_outurb_available(sisusb)) >= 0), timeout);\n\n\treturn i;\n}\n\nstatic int sisusb_alloc_outbuf(struct sisusb_usb_data *sisusb)\n{\n\tint i;\n\n\ti = sisusb_outurb_available(sisusb);\n\n\tif (i >= 0)\n\t\tsisusb->urbstatus[i] |= SU_URB_ALLOC;\n\n\treturn i;\n}\n\nstatic void sisusb_free_outbuf(struct sisusb_usb_data *sisusb, int index)\n{\n\tif ((index >= 0) && (index < sisusb->numobufs))\n\t\tsisusb->urbstatus[index] &= ~SU_URB_ALLOC;\n}\n\n \n\nstatic void sisusb_bulk_completeout(struct urb *urb)\n{\n\tstruct sisusb_urb_context *context = urb->context;\n\tstruct sisusb_usb_data *sisusb;\n\n\tif (!context)\n\t\treturn;\n\n\tsisusb = context->sisusb;\n\n\tif (!sisusb || !sisusb->sisusb_dev || !sisusb->present)\n\t\treturn;\n\n#ifndef SISUSB_DONTSYNC\n\tif (context->actual_length)\n\t\t*(context->actual_length) += urb->actual_length;\n#endif\n\n\tsisusb->urbstatus[context->urbindex] &= ~SU_URB_BUSY;\n\twake_up(&sisusb->wait_q);\n}\n\nstatic int sisusb_bulkout_msg(struct sisusb_usb_data *sisusb, int index,\n\t\tunsigned int pipe, void *data, int len, int *actual_length,\n\t\tint timeout, unsigned int tflags)\n{\n\tstruct urb *urb = sisusb->sisurbout[index];\n\tint retval, byteswritten = 0;\n\n\t \n\turb->transfer_flags = 0;\n\n\tusb_fill_bulk_urb(urb, sisusb->sisusb_dev, pipe, data, len,\n\t\t\tsisusb_bulk_completeout,\n\t\t\t&sisusb->urbout_context[index]);\n\n\turb->transfer_flags |= tflags;\n\turb->actual_length = 0;\n\n\t \n\tsisusb->urbout_context[index].actual_length = (timeout) ?\n\t\t\tNULL : actual_length;\n\n\t \n\tsisusb->urbstatus[index] |= SU_URB_BUSY;\n\n\t \n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\n\t \n\tif ((retval == 0) && timeout) {\n\t\twait_event_timeout(sisusb->wait_q,\n\t\t\t\t(!(sisusb->urbstatus[index] & SU_URB_BUSY)),\n\t\t\t\ttimeout);\n\t\tif (sisusb->urbstatus[index] & SU_URB_BUSY) {\n\t\t\t \n\t\t\tusb_kill_urb(urb);\n\t\t\tretval = -ETIMEDOUT;\n\t\t} else {\n\t\t\t \n\t\t\tretval = urb->status;\n\t\t\tbyteswritten = urb->actual_length;\n\t\t}\n\t}\n\n\tif (actual_length)\n\t\t*actual_length = byteswritten;\n\n\treturn retval;\n}\n\n \n\n \n\nstatic void sisusb_bulk_completein(struct urb *urb)\n{\n\tstruct sisusb_usb_data *sisusb = urb->context;\n\n\tif (!sisusb || !sisusb->sisusb_dev || !sisusb->present)\n\t\treturn;\n\n\tsisusb->completein = 1;\n\twake_up(&sisusb->wait_q);\n}\n\nstatic int sisusb_bulkin_msg(struct sisusb_usb_data *sisusb,\n\t\tunsigned int pipe, void *data, int len,\n\t\tint *actual_length, int timeout, unsigned int tflags)\n{\n\tstruct urb *urb = sisusb->sisurbin;\n\tint retval, readbytes = 0;\n\n\turb->transfer_flags = 0;\n\n\tusb_fill_bulk_urb(urb, sisusb->sisusb_dev, pipe, data, len,\n\t\t\tsisusb_bulk_completein, sisusb);\n\n\turb->transfer_flags |= tflags;\n\turb->actual_length = 0;\n\n\tsisusb->completein = 0;\n\tretval = usb_submit_urb(urb, GFP_KERNEL);\n\tif (retval == 0) {\n\t\twait_event_timeout(sisusb->wait_q, sisusb->completein, timeout);\n\t\tif (!sisusb->completein) {\n\t\t\t \n\t\t\tusb_kill_urb(urb);\n\t\t\tretval = -ETIMEDOUT;\n\t\t} else {\n\t\t\t \n\t\t\tretval = urb->status;\n\t\t\treadbytes = urb->actual_length;\n\t\t}\n\t}\n\n\tif (actual_length)\n\t\t*actual_length = readbytes;\n\n\treturn retval;\n}\n\n\n \n\n \n\nstatic int sisusb_send_bulk_msg(struct sisusb_usb_data *sisusb, int ep, int len,\n\t\tchar *kernbuffer, const char __user *userbuffer, int index,\n\t\tssize_t *bytes_written, unsigned int tflags, int async)\n{\n\tint result = 0, retry, count = len;\n\tint passsize, thispass, transferred_len = 0;\n\tint fromuser = (userbuffer != NULL) ? 1 : 0;\n\tint fromkern = (kernbuffer != NULL) ? 1 : 0;\n\tunsigned int pipe;\n\tchar *buffer;\n\n\t(*bytes_written) = 0;\n\n\t \n\tif (!sisusb || !sisusb->present || !sisusb->sisusb_dev)\n\t\treturn -ENODEV;\n\n\t \n\tif (fromuser || fromkern)\n\t\tindex = -1;\n\telse if (len > sisusb->obufsize)\n\t\tasync = 0;\n\n\tpipe = usb_sndbulkpipe(sisusb->sisusb_dev, ep);\n\n\tdo {\n\t\tpasssize = thispass = (sisusb->obufsize < count) ?\n\t\t\t\tsisusb->obufsize : count;\n\n\t\tif (index < 0)\n\t\t\tindex = sisusb_get_free_outbuf(sisusb);\n\n\t\tif (index < 0)\n\t\t\treturn -EIO;\n\n\t\tbuffer = sisusb->obuf[index];\n\n\t\tif (fromuser) {\n\n\t\t\tif (copy_from_user(buffer, userbuffer, passsize))\n\t\t\t\treturn -EFAULT;\n\n\t\t\tuserbuffer += passsize;\n\n\t\t} else if (fromkern) {\n\n\t\t\tmemcpy(buffer, kernbuffer, passsize);\n\t\t\tkernbuffer += passsize;\n\n\t\t}\n\n\t\tretry = 5;\n\t\twhile (thispass) {\n\n\t\t\tif (!sisusb->sisusb_dev)\n\t\t\t\treturn -ENODEV;\n\n\t\t\tresult = sisusb_bulkout_msg(sisusb, index, pipe,\n\t\t\t\t\tbuffer, thispass, &transferred_len,\n\t\t\t\t\tasync ? 0 : 5 * HZ, tflags);\n\n\t\t\tif (result == -ETIMEDOUT) {\n\n\t\t\t\t \n\t\t\t\tif (!retry--)\n\t\t\t\t\treturn -ETIME;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((result == 0) && !async && transferred_len) {\n\n\t\t\t\tthispass -= transferred_len;\n\t\t\t\tbuffer += transferred_len;\n\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (result)\n\t\t\treturn result;\n\n\t\t(*bytes_written) += passsize;\n\t\tcount            -= passsize;\n\n\t\t \n\t\tif (fromuser || fromkern)\n\t\t\tindex = -1;\n\n\t} while (count > 0);\n\n\tif (async) {\n#ifdef SISUSB_DONTSYNC\n\t\t(*bytes_written) = len;\n\t\t \n#else\n\t\tsisusb_wait_all_out_complete(sisusb);\n\t\t(*bytes_written) = transferred_len;\n\t\t \n#endif\n\t}\n\n\treturn ((*bytes_written) == len) ? 0 : -EIO;\n}\n\n \n\nstatic int sisusb_recv_bulk_msg(struct sisusb_usb_data *sisusb, int ep, int len,\n\t\tvoid *kernbuffer, char __user *userbuffer, ssize_t *bytes_read,\n\t\tunsigned int tflags)\n{\n\tint result = 0, retry, count = len;\n\tint bufsize, thispass, transferred_len;\n\tunsigned int pipe;\n\tchar *buffer;\n\n\t(*bytes_read) = 0;\n\n\t \n\tif (!sisusb || !sisusb->present || !sisusb->sisusb_dev)\n\t\treturn -ENODEV;\n\n\tpipe = usb_rcvbulkpipe(sisusb->sisusb_dev, ep);\n\tbuffer = sisusb->ibuf;\n\tbufsize = sisusb->ibufsize;\n\n\tretry = 5;\n\n#ifdef SISUSB_DONTSYNC\n\tif (!(sisusb_wait_all_out_complete(sisusb)))\n\t\treturn -EIO;\n#endif\n\n\twhile (count > 0) {\n\n\t\tif (!sisusb->sisusb_dev)\n\t\t\treturn -ENODEV;\n\n\t\tthispass = (bufsize < count) ? bufsize : count;\n\n\t\tresult = sisusb_bulkin_msg(sisusb, pipe, buffer, thispass,\n\t\t\t\t&transferred_len, 5 * HZ, tflags);\n\n\t\tif (transferred_len)\n\t\t\tthispass = transferred_len;\n\n\t\telse if (result == -ETIMEDOUT) {\n\n\t\t\tif (!retry--)\n\t\t\t\treturn -ETIME;\n\n\t\t\tcontinue;\n\n\t\t} else\n\t\t\treturn -EIO;\n\n\n\t\tif (thispass) {\n\n\t\t\t(*bytes_read) += thispass;\n\t\t\tcount         -= thispass;\n\n\t\t\tif (userbuffer) {\n\n\t\t\t\tif (copy_to_user(userbuffer, buffer, thispass))\n\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\tuserbuffer += thispass;\n\n\t\t\t} else {\n\n\t\t\t\tmemcpy(kernbuffer, buffer, thispass);\n\t\t\t\tkernbuffer += thispass;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn ((*bytes_read) == len) ? 0 : -EIO;\n}\n\nstatic int sisusb_send_packet(struct sisusb_usb_data *sisusb, int len,\n\t\tstruct sisusb_packet *packet)\n{\n\tint ret;\n\tssize_t bytes_transferred = 0;\n\t__le32 tmp;\n\n\tif (len == 6)\n\t\tpacket->data = 0;\n\n#ifdef SISUSB_DONTSYNC\n\tif (!(sisusb_wait_all_out_complete(sisusb)))\n\t\treturn 1;\n#endif\n\n\t \n\tSISUSB_CORRECT_ENDIANNESS_PACKET(packet);\n\n\t \n\tret = sisusb_send_bulk_msg(sisusb, SISUSB_EP_GFX_OUT, len,\n\t\t\t(char *)packet, NULL, 0, &bytes_transferred, 0, 0);\n\n\tif ((ret == 0) && (len == 6)) {\n\n\t\t \n\t\tret = sisusb_recv_bulk_msg(sisusb, SISUSB_EP_GFX_IN, 4,\n\t\t\t\t(char *)&tmp, NULL, &bytes_transferred, 0);\n\n\t\tpacket->data = le32_to_cpu(tmp);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_send_bridge_packet(struct sisusb_usb_data *sisusb, int len,\n\t\tstruct sisusb_packet *packet, unsigned int tflags)\n{\n\tint ret;\n\tssize_t bytes_transferred = 0;\n\t__le32 tmp;\n\n\tif (len == 6)\n\t\tpacket->data = 0;\n\n#ifdef SISUSB_DONTSYNC\n\tif (!(sisusb_wait_all_out_complete(sisusb)))\n\t\treturn 1;\n#endif\n\n\t \n\tSISUSB_CORRECT_ENDIANNESS_PACKET(packet);\n\n\t \n\tret = sisusb_send_bulk_msg(sisusb, SISUSB_EP_BRIDGE_OUT, len,\n\t\t\t(char *)packet, NULL, 0, &bytes_transferred, tflags, 0);\n\n\tif ((ret == 0) && (len == 6)) {\n\n\t\t \n\t\tret = sisusb_recv_bulk_msg(sisusb, SISUSB_EP_BRIDGE_IN, 4,\n\t\t\t\t(char *)&tmp, NULL, &bytes_transferred, 0);\n\n\t\tpacket->data = le32_to_cpu(tmp);\n\t}\n\n\treturn ret;\n}\n\n \n\n \n\n \n\nstatic int sisusb_write_memio_byte(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u8 data)\n{\n\tstruct sisusb_packet packet;\n\n\tpacket.header  = (1 << (addr & 3)) | (type << 6);\n\tpacket.address = addr & ~3;\n\tpacket.data    = data << ((addr & 3) << 3);\n\treturn sisusb_send_packet(sisusb, 10, &packet);\n}\n\nstatic int sisusb_write_memio_word(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u16 data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header = (type << 6) | 0x0003;\n\t\tpacket.data   = (u32)data;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header = (type << 6) | 0x0006;\n\t\tpacket.data   = (u32)data << 8;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header = (type << 6) | 0x000c;\n\t\tpacket.data   = (u32)data << 16;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header = (type << 6) | 0x0008;\n\t\tpacket.data   = (u32)data << 24;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data   = (u32)data >> 8;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_write_memio_24bit(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u32 data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header  = (type << 6) | 0x0007;\n\t\tpacket.data    = data & 0x00ffffff;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header  = (type << 6) | 0x000e;\n\t\tpacket.data    = data << 8;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header  = (type << 6) | 0x000c;\n\t\tpacket.data    = data << 16;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header  = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data    = (data >> 16) & 0x00ff;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header  = (type << 6) | 0x0008;\n\t\tpacket.data    = data << 24;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header  = (type << 6) | 0x0003;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data    = (data >> 8) & 0xffff;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_write_memio_long(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u32 data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header  = (type << 6) | 0x000f;\n\t\tpacket.data    = data;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header  = (type << 6) | 0x000e;\n\t\tpacket.data    = data << 8;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header  = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data    = data >> 24;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header  = (type << 6) | 0x000c;\n\t\tpacket.data    = data << 16;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header  = (type << 6) | 0x0003;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data    = data >> 16;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header  = (type << 6) | 0x0008;\n\t\tpacket.data    = data << 24;\n\t\tret = sisusb_send_packet(sisusb, 10, &packet);\n\t\tpacket.header  = (type << 6) | 0x0007;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tpacket.data    = data >> 8;\n\t\tret |= sisusb_send_packet(sisusb, 10, &packet);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int sisusb_write_mem_bulk(struct sisusb_usb_data *sisusb, u32 addr,\n\t\tchar *kernbuffer, int length, const char __user *userbuffer,\n\t\tint index, ssize_t *bytes_written)\n{\n\tstruct sisusb_packet packet;\n\tint  ret = 0;\n\tstatic int msgcount;\n\tu8   swap8, fromkern = kernbuffer ? 1 : 0;\n\tu16  swap16;\n\tu32  swap32, flag = (length >> 28) & 1;\n\tu8 buf[4];\n\n\t \n\tif (!fromkern && !userbuffer)\n\t\tkernbuffer = sisusb->obuf[index];\n\n\t(*bytes_written = 0);\n\n\tlength &= 0x00ffffff;\n\n\twhile (length) {\n\t\tswitch (length) {\n\t\tcase 1:\n\t\t\tif (userbuffer) {\n\t\t\t\tif (get_user(swap8, (u8 __user *)userbuffer))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\tswap8 = kernbuffer[0];\n\n\t\t\tret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, swap8);\n\n\t\t\tif (!ret)\n\t\t\t\t(*bytes_written)++;\n\n\t\t\treturn ret;\n\n\t\tcase 2:\n\t\t\tif (userbuffer) {\n\t\t\t\tif (get_user(swap16, (u16 __user *)userbuffer))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\tswap16 = *((u16 *)kernbuffer);\n\n\t\t\tret = sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, swap16);\n\n\t\t\tif (!ret)\n\t\t\t\t(*bytes_written) += 2;\n\n\t\t\treturn ret;\n\n\t\tcase 3:\n\t\t\tif (userbuffer) {\n\t\t\t\tif (copy_from_user(&buf, userbuffer, 3))\n\t\t\t\t\treturn -EFAULT;\n#ifdef __BIG_ENDIAN\n\t\t\t\tswap32 = (buf[0] << 16) |\n\t\t\t\t\t (buf[1] <<  8) |\n\t\t\t\t\t buf[2];\n#else\n\t\t\t\tswap32 = (buf[2] << 16) |\n\t\t\t\t\t (buf[1] <<  8) |\n\t\t\t\t\t buf[0];\n#endif\n\t\t\t} else\n#ifdef __BIG_ENDIAN\n\t\t\t\tswap32 = (kernbuffer[0] << 16) |\n\t\t\t\t\t (kernbuffer[1] <<  8) |\n\t\t\t\t\t kernbuffer[2];\n#else\n\t\t\t\tswap32 = (kernbuffer[2] << 16) |\n\t\t\t\t\t (kernbuffer[1] <<  8) |\n\t\t\t\t\t kernbuffer[0];\n#endif\n\n\t\t\tret = sisusb_write_memio_24bit(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, swap32);\n\n\t\t\tif (!ret)\n\t\t\t\t(*bytes_written) += 3;\n\n\t\t\treturn ret;\n\n\t\tcase 4:\n\t\t\tif (userbuffer) {\n\t\t\t\tif (get_user(swap32, (u32 __user *)userbuffer))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\tswap32 = *((u32 *)kernbuffer);\n\n\t\t\tret = sisusb_write_memio_long(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, swap32);\n\t\t\tif (!ret)\n\t\t\t\t(*bytes_written) += 4;\n\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\tif ((length & ~3) > 0x10000) {\n\n\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\tpacket.address = 0x000001d4;\n\t\t\t\tpacket.data    = addr;\n\t\t\t\tret = sisusb_send_bridge_packet(sisusb, 10,\n\t\t\t\t\t\t&packet, 0);\n\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\tpacket.address = 0x000001d0;\n\t\t\t\tpacket.data    = (length & ~3);\n\t\t\t\tret |= sisusb_send_bridge_packet(sisusb, 10,\n\t\t\t\t\t\t&packet, 0);\n\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\tpacket.address = 0x000001c0;\n\t\t\t\tpacket.data    = flag | 0x16;\n\t\t\t\tret |= sisusb_send_bridge_packet(sisusb, 10,\n\t\t\t\t\t\t&packet, 0);\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_LBULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tNULL, userbuffer, 0,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tuserbuffer += (*bytes_written);\n\t\t\t\t} else if (fromkern) {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_LBULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tkernbuffer, NULL, 0,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tkernbuffer += (*bytes_written);\n\t\t\t\t} else {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_LBULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tNULL, NULL, index,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tkernbuffer += ((*bytes_written) &\n\t\t\t\t\t\t\t(sisusb->obufsize-1));\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\tpacket.address = 0x00000194;\n\t\t\t\tpacket.data    = addr;\n\t\t\t\tret = sisusb_send_bridge_packet(sisusb, 10,\n\t\t\t\t\t\t&packet, 0);\n\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\tpacket.address = 0x00000190;\n\t\t\t\tpacket.data    = (length & ~3);\n\t\t\t\tret |= sisusb_send_bridge_packet(sisusb, 10,\n\t\t\t\t\t\t&packet, 0);\n\t\t\t\tif (sisusb->flagb0 != 0x16) {\n\t\t\t\t\tpacket.header  = 0x001f;\n\t\t\t\t\tpacket.address = 0x00000180;\n\t\t\t\t\tpacket.data    = flag | 0x16;\n\t\t\t\t\tret |= sisusb_send_bridge_packet(sisusb,\n\t\t\t\t\t\t\t10, &packet, 0);\n\t\t\t\t\tsisusb->flagb0 = 0x16;\n\t\t\t\t}\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_BULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tNULL, userbuffer, 0,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tuserbuffer += (*bytes_written);\n\t\t\t\t} else if (fromkern) {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_BULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tkernbuffer, NULL, 0,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tkernbuffer += (*bytes_written);\n\t\t\t\t} else {\n\t\t\t\t\tret |= sisusb_send_bulk_msg(sisusb,\n\t\t\t\t\t\t\tSISUSB_EP_GFX_BULK_OUT,\n\t\t\t\t\t\t\t(length & ~3),\n\t\t\t\t\t\t\tNULL, NULL, index,\n\t\t\t\t\t\t\tbytes_written, 0, 1);\n\t\t\t\t\tkernbuffer += ((*bytes_written) &\n\t\t\t\t\t\t\t(sisusb->obufsize-1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ret) {\n\t\t\t\tmsgcount++;\n\t\t\t\tif (msgcount < 500)\n\t\t\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\t\t\"Wrote %zd of %d bytes, error %d\\n\",\n\t\t\t\t\t\t\t*bytes_written, length,\n\t\t\t\t\t\t\tret);\n\t\t\t\telse if (msgcount == 500)\n\t\t\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\t\t\"Too many errors, logging stopped\\n\");\n\t\t\t}\n\t\t\taddr += (*bytes_written);\n\t\t\tlength -= (*bytes_written);\n\t\t}\n\n\t\tif (ret)\n\t\t\tbreak;\n\n\t}\n\n\treturn ret ? -EIO : 0;\n}\n\n \n\nstatic int sisusb_read_memio_byte(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u8 *data)\n{\n\tstruct sisusb_packet packet;\n\tint ret;\n\n\tCLEARPACKET(&packet);\n\tpacket.header  = (1 << (addr & 3)) | (type << 6);\n\tpacket.address = addr & ~3;\n\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t*data = (u8)(packet.data >> ((addr & 3) << 3));\n\treturn ret;\n}\n\nstatic int sisusb_read_memio_word(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u16 *data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tCLEARPACKET(&packet);\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header = (type << 6) | 0x0003;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = (u16)(packet.data);\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header = (type << 6) | 0x0006;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = (u16)(packet.data >> 8);\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header = (type << 6) | 0x000c;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = (u16)(packet.data >> 16);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header = (type << 6) | 0x0008;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = (u16)(packet.data >> 24);\n\t\tpacket.header = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= (u16)(packet.data << 8);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_read_memio_24bit(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u32 *data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header  = (type << 6) | 0x0007;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data & 0x00ffffff;\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header  = (type << 6) | 0x000e;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 8;\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header  = (type << 6) | 0x000c;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 16;\n\t\tpacket.header  = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= ((packet.data & 0xff) << 16);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header  = (type << 6) | 0x0008;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 24;\n\t\tpacket.header  = (type << 6) | 0x0003;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= ((packet.data & 0xffff) << 8);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_read_memio_long(struct sisusb_usb_data *sisusb, int type,\n\t\tu32 addr, u32 *data)\n{\n\tstruct sisusb_packet packet;\n\tint ret = 0;\n\n\tpacket.address = addr & ~3;\n\n\tswitch (addr & 3) {\n\tcase 0:\n\t\tpacket.header  = (type << 6) | 0x000f;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data;\n\t\tbreak;\n\tcase 1:\n\t\tpacket.header  = (type << 6) | 0x000e;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 8;\n\t\tpacket.header  = (type << 6) | 0x0001;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= (packet.data << 24);\n\t\tbreak;\n\tcase 2:\n\t\tpacket.header  = (type << 6) | 0x000c;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 16;\n\t\tpacket.header  = (type << 6) | 0x0003;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= (packet.data << 16);\n\t\tbreak;\n\tcase 3:\n\t\tpacket.header  = (type << 6) | 0x0008;\n\t\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data = packet.data >> 24;\n\t\tpacket.header  = (type << 6) | 0x0007;\n\t\tpacket.address = (addr & ~3) + 4;\n\t\tret |= sisusb_send_packet(sisusb, 6, &packet);\n\t\t*data |= (packet.data << 8);\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_read_mem_bulk(struct sisusb_usb_data *sisusb, u32 addr,\n\t\tchar *kernbuffer, int length, char __user *userbuffer,\n\t\tssize_t *bytes_read)\n{\n\tint ret = 0;\n\tchar buf[4];\n\tu16 swap16;\n\tu32 swap32;\n\n\t(*bytes_read = 0);\n\n\tlength &= 0x00ffffff;\n\n\twhile (length) {\n\t\tswitch (length) {\n\t\tcase 1:\n\t\t\tret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, &buf[0]);\n\t\t\tif (!ret) {\n\t\t\t\t(*bytes_read)++;\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tif (put_user(buf[0], (u8 __user *)userbuffer))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else\n\t\t\t\t\tkernbuffer[0] = buf[0];\n\t\t\t}\n\t\t\treturn ret;\n\n\t\tcase 2:\n\t\t\tret |= sisusb_read_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, &swap16);\n\t\t\tif (!ret) {\n\t\t\t\t(*bytes_read) += 2;\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tif (put_user(swap16, (u16 __user *)userbuffer))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\t*((u16 *)kernbuffer) = swap16;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\n\t\tcase 3:\n\t\t\tret |= sisusb_read_memio_24bit(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, &swap32);\n\t\t\tif (!ret) {\n\t\t\t\t(*bytes_read) += 3;\n#ifdef __BIG_ENDIAN\n\t\t\t\tbuf[0] = (swap32 >> 16) & 0xff;\n\t\t\t\tbuf[1] = (swap32 >> 8) & 0xff;\n\t\t\t\tbuf[2] = swap32 & 0xff;\n#else\n\t\t\t\tbuf[2] = (swap32 >> 16) & 0xff;\n\t\t\t\tbuf[1] = (swap32 >> 8) & 0xff;\n\t\t\t\tbuf[0] = swap32 & 0xff;\n#endif\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tif (copy_to_user(userbuffer,\n\t\t\t\t\t\t\t&buf[0], 3))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tkernbuffer[0] = buf[0];\n\t\t\t\t\tkernbuffer[1] = buf[1];\n\t\t\t\t\tkernbuffer[2] = buf[2];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\n\t\tdefault:\n\t\t\tret |= sisusb_read_memio_long(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddr, &swap32);\n\t\t\tif (!ret) {\n\t\t\t\t(*bytes_read) += 4;\n\t\t\t\tif (userbuffer) {\n\t\t\t\t\tif (put_user(swap32, (u32 __user *)userbuffer))\n\t\t\t\t\t\treturn -EFAULT;\n\n\t\t\t\t\tuserbuffer += 4;\n\t\t\t\t} else {\n\t\t\t\t\t*((u32 *)kernbuffer) = swap32;\n\t\t\t\t\tkernbuffer += 4;\n\t\t\t\t}\n\t\t\t\taddr += 4;\n\t\t\t\tlength -= 4;\n\t\t\t}\n\t\t}\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int sisusb_setidxreg(struct sisusb_usb_data *sisusb, u32 port,\n\t\tu8 index, u8 data)\n{\n\tint ret;\n\n\tret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, index);\n\tret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, data);\n\treturn ret;\n}\n\nstatic int sisusb_getidxreg(struct sisusb_usb_data *sisusb, u32 port,\n\t\tu8 index, u8 *data)\n{\n\tint ret;\n\n\tret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, index);\n\tret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, data);\n\treturn ret;\n}\n\nstatic int sisusb_setidxregandor(struct sisusb_usb_data *sisusb, u32 port, u8 idx,\n\t\tu8 myand, u8 myor)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, idx);\n\tret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, &tmp);\n\ttmp &= myand;\n\ttmp |= myor;\n\tret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, tmp);\n\treturn ret;\n}\n\nstatic int sisusb_setidxregmask(struct sisusb_usb_data *sisusb,\n\t\tu32 port, u8 idx, u8 data, u8 mask)\n{\n\tint ret;\n\tu8 tmp;\n\n\tret = sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port, idx);\n\tret |= sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, &tmp);\n\ttmp &= ~(mask);\n\ttmp |= (data & mask);\n\tret |= sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, port + 1, tmp);\n\treturn ret;\n}\n\nstatic int sisusb_setidxregor(struct sisusb_usb_data *sisusb, u32 port,\n\t\tu8 index, u8 myor)\n{\n\treturn sisusb_setidxregandor(sisusb, port, index, 0xff, myor);\n}\n\nstatic int sisusb_setidxregand(struct sisusb_usb_data *sisusb, u32 port,\n\t\tu8 idx, u8 myand)\n{\n\treturn sisusb_setidxregandor(sisusb, port, idx, myand, 0x00);\n}\n\n \n\n#ifdef SISUSBENDIANTEST\nstatic void sisusb_testreadwrite(struct sisusb_usb_data *sisusb)\n{\n\tstatic u8 srcbuffer[] = { 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77 };\n\tchar destbuffer[10];\n\tint i, j;\n\n\tsisusb_copy_memory(sisusb, srcbuffer, sisusb->vrambase, 7);\n\n\tfor (i = 1; i <= 7; i++) {\n\t\tdev_dbg(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"sisusb: rwtest %d bytes\\n\", i);\n\t\tsisusb_read_memory(sisusb, destbuffer, sisusb->vrambase, i);\n\t\tfor (j = 0; j < i; j++) {\n\t\t\tdev_dbg(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"rwtest read[%d] = %x\\n\",\n\t\t\t\t\tj, destbuffer[j]);\n\t\t}\n\t}\n}\n#endif\n\n \n\nstatic int sisusb_write_pci_config(struct sisusb_usb_data *sisusb,\n\t\tint regnum, u32 data)\n{\n\tstruct sisusb_packet packet;\n\n\tpacket.header = 0x008f;\n\tpacket.address = regnum | 0x10000;\n\tpacket.data = data;\n\treturn sisusb_send_packet(sisusb, 10, &packet);\n}\n\nstatic int sisusb_read_pci_config(struct sisusb_usb_data *sisusb,\n\t\tint regnum, u32 *data)\n{\n\tstruct sisusb_packet packet;\n\tint ret;\n\n\tpacket.header = 0x008f;\n\tpacket.address = (u32)regnum | 0x10000;\n\tret = sisusb_send_packet(sisusb, 6, &packet);\n\t*data = packet.data;\n\treturn ret;\n}\n\n \n\nstatic int sisusb_clear_vram(struct sisusb_usb_data *sisusb,\n\t\tu32 address, int length)\n{\n\tint ret, i;\n\tssize_t j;\n\n\tif (address < sisusb->vrambase)\n\t\treturn 1;\n\n\tif (address >= sisusb->vrambase + sisusb->vramsize)\n\t\treturn 1;\n\n\tif (address + length > sisusb->vrambase + sisusb->vramsize)\n\t\tlength = sisusb->vrambase + sisusb->vramsize - address;\n\n\tif (length <= 0)\n\t\treturn 0;\n\n\t \n\ti = sisusb_alloc_outbuf(sisusb);\n\tif (i < 0)\n\t\treturn -EBUSY;\n\n\tmemset(sisusb->obuf[i], 0, sisusb->obufsize);\n\n\t \n\tret = sisusb_write_mem_bulk(sisusb, address, NULL, length, NULL, i, &j);\n\n\t \n\tsisusb_free_outbuf(sisusb, i);\n\n\treturn ret;\n}\n\n \n\n#define GETREG(r, d) sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO, r, d)\n#define SETREG(r, d) sisusb_write_memio_byte(sisusb, SISUSB_TYPE_IO, r, d)\n#define SETIREG(r, i, d) sisusb_setidxreg(sisusb, r, i, d)\n#define GETIREG(r, i, d) sisusb_getidxreg(sisusb, r, i, d)\n#define SETIREGOR(r, i, o) sisusb_setidxregor(sisusb, r, i, o)\n#define SETIREGAND(r, i, a) sisusb_setidxregand(sisusb, r, i, a)\n#define SETIREGANDOR(r, i, a, o) sisusb_setidxregandor(sisusb, r, i, a, o)\n#define READL(a, d) sisusb_read_memio_long(sisusb, SISUSB_TYPE_MEM, a, d)\n#define WRITEL(a, d) sisusb_write_memio_long(sisusb, SISUSB_TYPE_MEM, a, d)\n#define READB(a, d) sisusb_read_memio_byte(sisusb, SISUSB_TYPE_MEM, a, d)\n#define WRITEB(a, d) sisusb_write_memio_byte(sisusb, SISUSB_TYPE_MEM, a, d)\n\nstatic int sisusb_triggersr16(struct sisusb_usb_data *sisusb, u8 ramtype)\n{\n\tint ret;\n\tu8 tmp8;\n\n\tret = GETIREG(SISSR, 0x16, &tmp8);\n\tif (ramtype <= 1) {\n\t\ttmp8 &= 0x3f;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 |= 0x80;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t} else {\n\t\ttmp8 |= 0xc0;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 &= 0x0f;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 |= 0x80;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 &= 0x0f;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 |= 0xd0;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 &= 0x0f;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t\ttmp8 |= 0xa0;\n\t\tret |= SETIREG(SISSR, 0x16, tmp8);\n\t}\n\treturn ret;\n}\n\nstatic int sisusb_getbuswidth(struct sisusb_usb_data *sisusb,\n\t\tint *bw, int *chab)\n{\n\tint ret;\n\tu8  ramtype, done = 0;\n\tu32 t0, t1, t2, t3;\n\tu32 ramptr = SISUSB_PCI_MEMBASE;\n\n\tret = GETIREG(SISSR, 0x3a, &ramtype);\n\tramtype &= 3;\n\n\tret |= SETIREG(SISSR, 0x13, 0x00);\n\n\tif (ramtype <= 1) {\n\t\tret |= SETIREG(SISSR, 0x14, 0x12);\n\t\tret |= SETIREGAND(SISSR, 0x15, 0xef);\n\t} else {\n\t\tret |= SETIREG(SISSR, 0x14, 0x02);\n\t}\n\n\tret |= sisusb_triggersr16(sisusb, ramtype);\n\tret |= WRITEL(ramptr +  0, 0x01234567);\n\tret |= WRITEL(ramptr +  4, 0x456789ab);\n\tret |= WRITEL(ramptr +  8, 0x89abcdef);\n\tret |= WRITEL(ramptr + 12, 0xcdef0123);\n\tret |= WRITEL(ramptr + 16, 0x55555555);\n\tret |= WRITEL(ramptr + 20, 0x55555555);\n\tret |= WRITEL(ramptr + 24, 0xffffffff);\n\tret |= WRITEL(ramptr + 28, 0xffffffff);\n\tret |= READL(ramptr +  0, &t0);\n\tret |= READL(ramptr +  4, &t1);\n\tret |= READL(ramptr +  8, &t2);\n\tret |= READL(ramptr + 12, &t3);\n\n\tif (ramtype <= 1) {\n\n\t\t*chab = 0; *bw = 64;\n\n\t\tif ((t3 != 0xcdef0123) || (t2 != 0x89abcdef)) {\n\t\t\tif ((t1 == 0x456789ab) && (t0 == 0x01234567)) {\n\t\t\t\t*chab = 0; *bw = 64;\n\t\t\t\tret |= SETIREGAND(SISSR, 0x14, 0xfd);\n\t\t\t}\n\t\t}\n\t\tif ((t1 != 0x456789ab) || (t0 != 0x01234567)) {\n\t\t\t*chab = 1; *bw = 64;\n\t\t\tret |= SETIREGANDOR(SISSR, 0x14, 0xfc, 0x01);\n\n\t\t\tret |= sisusb_triggersr16(sisusb, ramtype);\n\t\t\tret |= WRITEL(ramptr +  0, 0x89abcdef);\n\t\t\tret |= WRITEL(ramptr +  4, 0xcdef0123);\n\t\t\tret |= WRITEL(ramptr +  8, 0x55555555);\n\t\t\tret |= WRITEL(ramptr + 12, 0x55555555);\n\t\t\tret |= WRITEL(ramptr + 16, 0xaaaaaaaa);\n\t\t\tret |= WRITEL(ramptr + 20, 0xaaaaaaaa);\n\t\t\tret |= READL(ramptr +  4, &t1);\n\n\t\t\tif (t1 != 0xcdef0123) {\n\t\t\t\t*bw = 32;\n\t\t\t\tret |= SETIREGOR(SISSR, 0x15, 0x10);\n\t\t\t}\n\t\t}\n\n\t} else {\n\n\t\t*chab = 0; *bw = 64;\t \n\n\t\tdone = 0;\n\n\t\tif (t1 == 0x456789ab) {\n\t\t\tif (t0 == 0x01234567) {\n\t\t\t\t*chab = 0; *bw = 64;\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (t0 == 0x01234567) {\n\t\t\t\t*chab = 0; *bw = 32;\n\t\t\t\tret |= SETIREG(SISSR, 0x14, 0x00);\n\t\t\t\tdone = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!done) {\n\t\t\tret |= SETIREG(SISSR, 0x14, 0x03);\n\t\t\tret |= sisusb_triggersr16(sisusb, ramtype);\n\n\t\t\tret |= WRITEL(ramptr +  0, 0x01234567);\n\t\t\tret |= WRITEL(ramptr +  4, 0x456789ab);\n\t\t\tret |= WRITEL(ramptr +  8, 0x89abcdef);\n\t\t\tret |= WRITEL(ramptr + 12, 0xcdef0123);\n\t\t\tret |= WRITEL(ramptr + 16, 0x55555555);\n\t\t\tret |= WRITEL(ramptr + 20, 0x55555555);\n\t\t\tret |= WRITEL(ramptr + 24, 0xffffffff);\n\t\t\tret |= WRITEL(ramptr + 28, 0xffffffff);\n\t\t\tret |= READL(ramptr +  0, &t0);\n\t\t\tret |= READL(ramptr +  4, &t1);\n\n\t\t\tif (t1 == 0x456789ab) {\n\t\t\t\tif (t0 == 0x01234567) {\n\t\t\t\t\t*chab = 1; *bw = 64;\n\t\t\t\t\treturn ret;\n\t\t\t\t}  \n\t\t\t} else {\n\t\t\t\tif (t0 == 0x01234567) {\n\t\t\t\t\t*chab = 1; *bw = 32;\n\t\t\t\t\tret |= SETIREG(SISSR, 0x14, 0x01);\n\t\t\t\t}  \n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int sisusb_verify_mclk(struct sisusb_usb_data *sisusb)\n{\n\tint ret = 0;\n\tu32 ramptr = SISUSB_PCI_MEMBASE;\n\tu8 tmp1, tmp2, i, j;\n\n\tret |= WRITEB(ramptr, 0xaa);\n\tret |= WRITEB(ramptr + 16, 0x55);\n\tret |= READB(ramptr, &tmp1);\n\tret |= READB(ramptr + 16, &tmp2);\n\tif ((tmp1 != 0xaa) || (tmp2 != 0x55)) {\n\t\tfor (i = 0, j = 16; i < 2; i++, j += 16) {\n\t\t\tret |= GETIREG(SISSR, 0x21, &tmp1);\n\t\t\tret |= SETIREGAND(SISSR, 0x21, (tmp1 & 0xfb));\n\t\t\tret |= SETIREGOR(SISSR, 0x3c, 0x01);   \n\t\t\tret |= SETIREGAND(SISSR, 0x3c, 0xfe);  \n\t\t\tret |= SETIREG(SISSR, 0x21, tmp1);\n\t\t\tret |= WRITEB(ramptr + 16 + j, j);\n\t\t\tret |= READB(ramptr + 16 + j, &tmp1);\n\t\t\tif (tmp1 == j) {\n\t\t\t\tret |= WRITEB(ramptr + j, j);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic int sisusb_set_rank(struct sisusb_usb_data *sisusb, int *iret,\n\t\tint index, u8 rankno, u8 chab, const u8 dramtype[][5], int bw)\n{\n\tint ret = 0, ranksize;\n\tu8 tmp;\n\n\t*iret = 0;\n\n\tif ((rankno == 2) && (dramtype[index][0] == 2))\n\t\treturn ret;\n\n\tranksize = dramtype[index][3] / 2 * bw / 32;\n\n\tif ((ranksize * rankno) > 128)\n\t\treturn ret;\n\n\ttmp = 0;\n\twhile ((ranksize >>= 1) > 0)\n\t\ttmp += 0x10;\n\n\ttmp |= ((rankno - 1) << 2);\n\ttmp |= ((bw / 64) & 0x02);\n\ttmp |= (chab & 0x01);\n\n\tret = SETIREG(SISSR, 0x14, tmp);\n\tret |= sisusb_triggersr16(sisusb, 0);  \n\n\t*iret = 1;\n\n\treturn ret;\n}\n\nstatic int sisusb_check_rbc(struct sisusb_usb_data *sisusb, int *iret,\n\t\tu32 inc, int testn)\n{\n\tint ret = 0, i;\n\tu32 j, tmp;\n\n\t*iret = 0;\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= WRITEL(sisusb->vrambase + j, j);\n\t\tj += inc;\n\t}\n\n\tfor (i = 0, j = 0; i < testn; i++) {\n\t\tret |= READL(sisusb->vrambase + j, &tmp);\n\t\tif (tmp != j)\n\t\t\treturn ret;\n\n\t\tj += inc;\n\t}\n\n\t*iret = 1;\n\treturn ret;\n}\n\nstatic int sisusb_check_ranks(struct sisusb_usb_data *sisusb,\n\t\tint *iret, int rankno, int idx, int bw, const u8 rtype[][5])\n{\n\tint ret = 0, i, i2ret;\n\tu32 inc;\n\n\t*iret = 0;\n\n\tfor (i = rankno; i >= 1; i--) {\n\t\tinc = 1 << (rtype[idx][2] + rtype[idx][1] + rtype[idx][0] +\n\t\t\t\tbw / 64 + i);\n\t\tret |= sisusb_check_rbc(sisusb, &i2ret, inc, 2);\n\t\tif (!i2ret)\n\t\t\treturn ret;\n\t}\n\n\tinc = 1 << (rtype[idx][2] + bw / 64 + 2);\n\tret |= sisusb_check_rbc(sisusb, &i2ret, inc, 4);\n\tif (!i2ret)\n\t\treturn ret;\n\n\tinc = 1 << (10 + bw / 64);\n\tret |= sisusb_check_rbc(sisusb, &i2ret, inc, 2);\n\tif (!i2ret)\n\t\treturn ret;\n\n\t*iret = 1;\n\treturn ret;\n}\n\nstatic int sisusb_get_sdram_size(struct sisusb_usb_data *sisusb, int *iret,\n\t\tint bw, int chab)\n{\n\tint ret = 0, i2ret = 0, i, j;\n\tstatic const u8 sdramtype[13][5] = {\n\t\t{ 2, 12, 9, 64, 0x35 },\n\t\t{ 1, 13, 9, 64, 0x44 },\n\t\t{ 2, 12, 8, 32, 0x31 },\n\t\t{ 2, 11, 9, 32, 0x25 },\n\t\t{ 1, 12, 9, 32, 0x34 },\n\t\t{ 1, 13, 8, 32, 0x40 },\n\t\t{ 2, 11, 8, 16, 0x21 },\n\t\t{ 1, 12, 8, 16, 0x30 },\n\t\t{ 1, 11, 9, 16, 0x24 },\n\t\t{ 1, 11, 8,  8, 0x20 },\n\t\t{ 2,  9, 8,  4, 0x01 },\n\t\t{ 1, 10, 8,  4, 0x10 },\n\t\t{ 1,  9, 8,  2, 0x00 }\n\t};\n\n\t*iret = 1;  \n\n\tfor (i = 0; i < 13; i++) {\n\t\tret |= SETIREGANDOR(SISSR, 0x13, 0x80, sdramtype[i][4]);\n\t\tfor (j = 2; j > 0; j--) {\n\t\t\tret |= sisusb_set_rank(sisusb, &i2ret, i, j, chab,\n\t\t\t\t\tsdramtype, bw);\n\t\t\tif (!i2ret)\n\t\t\t\tcontinue;\n\n\t\t\tret |= sisusb_check_ranks(sisusb, &i2ret, j, i, bw,\n\t\t\t\t\tsdramtype);\n\t\t\tif (i2ret) {\n\t\t\t\t*iret = 0;\t \n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic int sisusb_setup_screen(struct sisusb_usb_data *sisusb,\n\t\tint clrall, int drwfr)\n{\n\tint ret = 0;\n\tu32 address;\n\tint i, length, modex, modey, bpp;\n\n\tmodex = 640; modey = 480; bpp = 2;\n\n\taddress = sisusb->vrambase;\t \n\n\tif (clrall)\n\t\tlength = sisusb->vramsize;\n\telse\n\t\tlength = modex * bpp * modey;\n\n\tret = sisusb_clear_vram(sisusb, address, length);\n\n\tif (!ret && drwfr) {\n\t\tfor (i = 0; i < modex; i++) {\n\t\t\taddress = sisusb->vrambase + (i * bpp);\n\t\t\tret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddress, 0xf100);\n\t\t\taddress += (modex * (modey-1) * bpp);\n\t\t\tret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddress, 0xf100);\n\t\t}\n\t\tfor (i = 0; i < modey; i++) {\n\t\t\taddress = sisusb->vrambase + ((i * modex) * bpp);\n\t\t\tret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddress, 0xf100);\n\t\t\taddress += ((modex - 1) * bpp);\n\t\t\tret |= sisusb_write_memio_word(sisusb, SISUSB_TYPE_MEM,\n\t\t\t\t\taddress, 0xf100);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic void sisusb_set_default_mode(struct sisusb_usb_data *sisusb,\n\t\tint touchengines)\n{\n\tint i, j, modex, bpp, du;\n\tu8 sr31, cr63, tmp8;\n\tstatic const char attrdata[] = {\n\t\t0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n\t\t0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n\t\t0x01, 0x00, 0x00, 0x00\n\t};\n\tstatic const char crtcrdata[] = {\n\t\t0x5f, 0x4f, 0x50, 0x82, 0x54, 0x80, 0x0b, 0x3e,\n\t\t0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t0xea, 0x8c, 0xdf, 0x28, 0x40, 0xe7, 0x04, 0xa3,\n\t\t0xff\n\t};\n\tstatic const char grcdata[] = {\n\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0f,\n\t\t0xff\n\t};\n\tstatic const char crtcdata[] = {\n\t\t0x5f, 0x4f, 0x4f, 0x83, 0x55, 0x81, 0x0b, 0x3e,\n\t\t0xe9, 0x8b, 0xdf, 0xe8, 0x0c, 0x00, 0x00, 0x05,\n\t\t0x00\n\t};\n\n\tmodex = 640; bpp = 2;\n\n\tGETIREG(SISSR, 0x31, &sr31);\n\tGETIREG(SISCR, 0x63, &cr63);\n\tSETIREGOR(SISSR, 0x01, 0x20);\n\tSETIREG(SISCR, 0x63, cr63 & 0xbf);\n\tSETIREGOR(SISCR, 0x17, 0x80);\n\tSETIREGOR(SISSR, 0x1f, 0x04);\n\tSETIREGAND(SISSR, 0x07, 0xfb);\n\tSETIREG(SISSR, 0x00, 0x03);\t \n\tSETIREG(SISSR, 0x01, 0x21);\n\tSETIREG(SISSR, 0x02, 0x0f);\n\tSETIREG(SISSR, 0x03, 0x00);\n\tSETIREG(SISSR, 0x04, 0x0e);\n\tSETREG(SISMISCW, 0x23);\t\t \n\tfor (i = 0; i <= 0x18; i++) {\t \n\t\tSETIREG(SISCR, i, crtcrdata[i]);\n\t}\n\tfor (i = 0; i <= 0x13; i++) {\t \n\t\tGETREG(SISINPSTAT, &tmp8);\n\t\tSETREG(SISAR, i);\n\t\tSETREG(SISAR, attrdata[i]);\n\t}\n\tGETREG(SISINPSTAT, &tmp8);\n\tSETREG(SISAR, 0x14);\n\tSETREG(SISAR, 0x00);\n\tGETREG(SISINPSTAT, &tmp8);\n\tSETREG(SISAR, 0x20);\n\tGETREG(SISINPSTAT, &tmp8);\n\tfor (i = 0; i <= 0x08; i++) {\t \n\t\tSETIREG(SISGR, i, grcdata[i]);\n\t}\n\tSETIREGAND(SISGR, 0x05, 0xbf);\n\tfor (i = 0x0A; i <= 0x0E; i++) {\t \n\t\tSETIREG(SISSR, i, 0x00);\n\t}\n\tSETIREGAND(SISSR, 0x37, 0xfe);\n\tSETREG(SISMISCW, 0xef);\t\t \n\tSETIREG(SISCR, 0x11, 0x00);\t \n\tfor (j = 0x00, i = 0; i <= 7; i++, j++)\n\t\tSETIREG(SISCR, j, crtcdata[i]);\n\n\tfor (j = 0x10; i <= 10; i++, j++)\n\t\tSETIREG(SISCR, j, crtcdata[i]);\n\n\tfor (j = 0x15; i <= 12; i++, j++)\n\t\tSETIREG(SISCR, j, crtcdata[i]);\n\n\tfor (j = 0x0A; i <= 15; i++, j++)\n\t\tSETIREG(SISSR, j, crtcdata[i]);\n\n\tSETIREG(SISSR, 0x0E, (crtcdata[16] & 0xE0));\n\tSETIREGANDOR(SISCR, 0x09, 0x5f, ((crtcdata[16] & 0x01) << 5));\n\tSETIREG(SISCR, 0x14, 0x4f);\n\tdu = (modex / 16) * (bpp * 2);\t \n\tSETIREGANDOR(SISSR, 0x0e, 0xf0, ((du >> 8) & 0x0f));\n\tSETIREG(SISCR, 0x13, (du & 0xff));\n\tdu <<= 5;\n\ttmp8 = du >> 8;\n\tSETIREG(SISSR, 0x10, tmp8);\n\tSETIREG(SISSR, 0x31, 0x00);\t \n\tSETIREG(SISSR, 0x2b, 0x1b);\n\tSETIREG(SISSR, 0x2c, 0xe1);\n\tSETIREG(SISSR, 0x2d, 0x01);\n\tSETIREGAND(SISSR, 0x3d, 0xfe);\t \n\tSETIREG(SISSR, 0x08, 0xae);\n\tSETIREGAND(SISSR, 0x09, 0xf0);\n\tSETIREG(SISSR, 0x08, 0x34);\n\tSETIREGOR(SISSR, 0x3d, 0x01);\n\tSETIREGAND(SISSR, 0x1f, 0x3f);\t \n\tSETIREGANDOR(SISSR, 0x06, 0xc0, 0x0a);\n\tSETIREG(SISCR, 0x19, 0x00);\n\tSETIREGAND(SISCR, 0x1a, 0xfc);\n\tSETIREGAND(SISSR, 0x0f, 0xb7);\n\tSETIREGAND(SISSR, 0x31, 0xfb);\n\tSETIREGANDOR(SISSR, 0x21, 0x1f, 0xa0);\n\tSETIREGAND(SISSR, 0x32, 0xf3);\n\tSETIREGANDOR(SISSR, 0x07, 0xf8, 0x03);\n\tSETIREG(SISCR, 0x52, 0x6c);\n\n\tSETIREG(SISCR, 0x0d, 0x00);\t \n\tSETIREG(SISCR, 0x0c, 0x00);\n\tSETIREG(SISSR, 0x0d, 0x00);\n\tSETIREGAND(SISSR, 0x37, 0xfe);\n\n\tSETIREG(SISCR, 0x32, 0x20);\n\tSETIREGAND(SISSR, 0x01, 0xdf);\t \n\tSETIREG(SISCR, 0x63, (cr63 & 0xbf));\n\tSETIREG(SISSR, 0x31, (sr31 & 0xfb));\n\n\tif (touchengines) {\n\t\tSETIREG(SISSR, 0x20, 0xa1);\t \n\t\tSETIREGOR(SISSR, 0x1e, 0x5a);\n\n\t\tSETIREG(SISSR, 0x26, 0x01);\t \n\t\tSETIREG(SISSR, 0x27, 0x1f);\n\t\tSETIREG(SISSR, 0x26, 0x00);\n\t}\n\n\tSETIREG(SISCR, 0x34, 0x44);\t \n}\n\nstatic int sisusb_init_gfxcore(struct sisusb_usb_data *sisusb)\n{\n\tint ret = 0, i, j, bw, chab, iret, retry = 3;\n\tu8 tmp8, ramtype;\n\tu32 tmp32;\n\tstatic const char mclktable[] = {\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143\n\t};\n\tstatic const char eclktable[] = {\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143,\n\t\t0x3b, 0x22, 0x01, 143\n\t};\n\tstatic const char ramtypetable1[] = {\n\t\t0x00, 0x04, 0x60, 0x60,\n\t\t0x0f, 0x0f, 0x1f, 0x1f,\n\t\t0xba, 0xba, 0xba, 0xba,\n\t\t0xa9, 0xa9, 0xac, 0xac,\n\t\t0xa0, 0xa0, 0xa0, 0xa8,\n\t\t0x00, 0x00, 0x02, 0x02,\n\t\t0x30, 0x30, 0x40, 0x40\n\t};\n\tstatic const char ramtypetable2[] = {\n\t\t0x77, 0x77, 0x44, 0x44,\n\t\t0x77, 0x77, 0x44, 0x44,\n\t\t0x00, 0x00, 0x00, 0x00,\n\t\t0x5b, 0x5b, 0xab, 0xab,\n\t\t0x00, 0x00, 0xf0, 0xf8\n\t};\n\n\twhile (retry--) {\n\n\t\t \n\t\tret = GETREG(SISVGAEN, &tmp8);\n\t\tret |= SETREG(SISVGAEN, (tmp8 | 0x01));\n\n\t\t \n\t\tret |= GETREG(SISMISCR, &tmp8);\n\t\tret |= SETREG(SISMISCW, (tmp8 | 0x01));\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\t \n\t\tret |= SETIREGAND(SISCR, 0x5b, 0xdf);\n\t\tret |= SETIREG(SISSR, 0x05, 0x86);\n\t\tret |= SETIREGOR(SISSR, 0x20, 0x01);\n\n\t\tret |= SETREG(SISMISCW, 0x67);\n\n\t\tfor (i = 0x06; i <= 0x1f; i++)\n\t\t\tret |= SETIREG(SISSR, i, 0x00);\n\n\t\tfor (i = 0x21; i <= 0x27; i++)\n\t\t\tret |= SETIREG(SISSR, i, 0x00);\n\n\t\tfor (i = 0x31; i <= 0x3d; i++)\n\t\t\tret |= SETIREG(SISSR, i, 0x00);\n\n\t\tfor (i = 0x12; i <= 0x1b; i++)\n\t\t\tret |= SETIREG(SISSR, i, 0x00);\n\n\t\tfor (i = 0x79; i <= 0x7c; i++)\n\t\t\tret |= SETIREG(SISCR, i, 0x00);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret |= SETIREG(SISCR, 0x63, 0x80);\n\n\t\tret |= GETIREG(SISSR, 0x3a, &ramtype);\n\t\tramtype &= 0x03;\n\n\t\tret |= SETIREG(SISSR, 0x28, mclktable[ramtype * 4]);\n\t\tret |= SETIREG(SISSR, 0x29, mclktable[(ramtype * 4) + 1]);\n\t\tret |= SETIREG(SISSR, 0x2a, mclktable[(ramtype * 4) + 2]);\n\n\t\tret |= SETIREG(SISSR, 0x2e, eclktable[ramtype * 4]);\n\t\tret |= SETIREG(SISSR, 0x2f, eclktable[(ramtype * 4) + 1]);\n\t\tret |= SETIREG(SISSR, 0x30, eclktable[(ramtype * 4) + 2]);\n\n\t\tret |= SETIREG(SISSR, 0x07, 0x18);\n\t\tret |= SETIREG(SISSR, 0x11, 0x0f);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tfor (i = 0x15, j = 0; i <= 0x1b; i++, j++) {\n\t\t\tret |= SETIREG(SISSR, i,\n\t\t\t\t\tramtypetable1[(j*4) + ramtype]);\n\t\t}\n\t\tfor (i = 0x40, j = 0; i <= 0x44; i++, j++) {\n\t\t\tret |= SETIREG(SISCR, i,\n\t\t\t\t\tramtypetable2[(j*4) + ramtype]);\n\t\t}\n\n\t\tret |= SETIREG(SISCR, 0x49, 0xaa);\n\n\t\tret |= SETIREG(SISSR, 0x1f, 0x00);\n\t\tret |= SETIREG(SISSR, 0x20, 0xa0);\n\t\tret |= SETIREG(SISSR, 0x23, 0xf6);\n\t\tret |= SETIREG(SISSR, 0x24, 0x0d);\n\t\tret |= SETIREG(SISSR, 0x25, 0x33);\n\n\t\tret |= SETIREG(SISSR, 0x11, 0x0f);\n\n\t\tret |= SETIREGOR(SISPART1, 0x2f, 0x01);\n\n\t\tret |= SETIREGAND(SISCAP, 0x3f, 0xef);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret |= SETIREG(SISPART1, 0x00, 0x00);\n\n\t\tret |= GETIREG(SISSR, 0x13, &tmp8);\n\t\ttmp8 >>= 4;\n\n\t\tret |= SETIREG(SISPART1, 0x02, 0x00);\n\t\tret |= SETIREG(SISPART1, 0x2e, 0x08);\n\n\t\tret |= sisusb_read_pci_config(sisusb, 0x50, &tmp32);\n\t\ttmp32 &= 0x00f00000;\n\t\ttmp8 = (tmp32 == 0x100000) ? 0x33 : 0x03;\n\t\tret |= SETIREG(SISSR, 0x25, tmp8);\n\t\ttmp8 = (tmp32 == 0x100000) ? 0xaa : 0x88;\n\t\tret |= SETIREG(SISCR, 0x49, tmp8);\n\n\t\tret |= SETIREG(SISSR, 0x27, 0x1f);\n\t\tret |= SETIREG(SISSR, 0x31, 0x00);\n\t\tret |= SETIREG(SISSR, 0x32, 0x11);\n\t\tret |= SETIREG(SISSR, 0x33, 0x00);\n\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tret |= SETIREG(SISCR, 0x83, 0x00);\n\n\t\tsisusb_set_default_mode(sisusb, 0);\n\n\t\tret |= SETIREGAND(SISSR, 0x21, 0xdf);\n\t\tret |= SETIREGOR(SISSR, 0x01, 0x20);\n\t\tret |= SETIREGOR(SISSR, 0x16, 0x0f);\n\n\t\tret |= sisusb_triggersr16(sisusb, ramtype);\n\n\t\t \n\t\tret |= SETIREGAND(SISSR, 0x17, 0xf8);\n\t\tret |= SETIREGOR(SISSR, 0x19, 0x03);\n\n\t\tret |= sisusb_getbuswidth(sisusb, &bw, &chab);\n\t\tret |= sisusb_verify_mclk(sisusb);\n\n\t\tif (ramtype <= 1) {\n\t\t\tret |= sisusb_get_sdram_size(sisusb, &iret, bw, chab);\n\t\t\tif (iret) {\n\t\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\t\"RAM size detection failed, assuming 8MB video RAM\\n\");\n\t\t\t\tret |= SETIREG(SISSR, 0x14, 0x31);\n\t\t\t\t \n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"DDR RAM device found, assuming 8MB video RAM\\n\");\n\t\t\tret |= SETIREG(SISSR, 0x14, 0x31);\n\t\t\t \n\t\t}\n\n\t\t \n\t\tret |= SETIREG(SISSR, 0x16, ramtypetable1[4 + ramtype]);\n\t\tret |= SETIREG(SISSR, 0x17, ramtypetable1[8 + ramtype]);\n\t\tret |= SETIREG(SISSR, 0x19, ramtypetable1[16 + ramtype]);\n\n\t\tret |= SETIREGOR(SISSR, 0x21, 0x20);\n\n\t\tret |= SETIREG(SISSR, 0x22, 0xfb);\n\t\tret |= SETIREG(SISSR, 0x21, 0xa5);\n\n\t\tif (ret == 0)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\n#undef SETREG\n#undef GETREG\n#undef SETIREG\n#undef GETIREG\n#undef SETIREGOR\n#undef SETIREGAND\n#undef SETIREGANDOR\n#undef READL\n#undef WRITEL\n\nstatic void sisusb_get_ramconfig(struct sisusb_usb_data *sisusb)\n{\n\tu8 tmp8, tmp82, ramtype;\n\tint bw = 0;\n\tchar *ramtypetext1 = NULL;\n\tstatic const char ram_datarate[4] = {'S', 'S', 'D', 'D'};\n\tstatic const char ram_dynamictype[4] = {'D', 'G', 'D', 'G'};\n\tstatic const int busSDR[4]  = {64, 64, 128, 128};\n\tstatic const int busDDR[4]  = {32, 32,  64,  64};\n\tstatic const int busDDRA[4] = {64+32, 64+32, (64+32)*2, (64+32)*2};\n\n\tsisusb_getidxreg(sisusb, SISSR, 0x14, &tmp8);\n\tsisusb_getidxreg(sisusb, SISSR, 0x15, &tmp82);\n\tsisusb_getidxreg(sisusb, SISSR, 0x3a, &ramtype);\n\tsisusb->vramsize = (1 << ((tmp8 & 0xf0) >> 4)) * 1024 * 1024;\n\tramtype &= 0x03;\n\tswitch ((tmp8 >> 2) & 0x03) {\n\tcase 0:\n\t\tramtypetext1 = \"1 ch/1 r\";\n\t\tif (tmp82 & 0x10)\n\t\t\tbw = 32;\n\t\telse\n\t\t\tbw = busSDR[(tmp8 & 0x03)];\n\n\t\tbreak;\n\tcase 1:\n\t\tramtypetext1 = \"1 ch/2 r\";\n\t\tsisusb->vramsize <<= 1;\n\t\tbw = busSDR[(tmp8 & 0x03)];\n\t\tbreak;\n\tcase 2:\n\t\tramtypetext1 = \"asymmetric\";\n\t\tsisusb->vramsize += sisusb->vramsize/2;\n\t\tbw = busDDRA[(tmp8 & 0x03)];\n\t\tbreak;\n\tcase 3:\n\t\tramtypetext1 = \"2 channel\";\n\t\tsisusb->vramsize <<= 1;\n\t\tbw = busDDR[(tmp8 & 0x03)];\n\t\tbreak;\n\t}\n\n\tdev_info(&sisusb->sisusb_dev->dev,\n\t\t\t\"%dMB %s %cDR S%cRAM, bus width %d\\n\",\n\t\t\tsisusb->vramsize >> 20, ramtypetext1,\n\t\t\tram_datarate[ramtype], ram_dynamictype[ramtype], bw);\n}\n\nstatic int sisusb_do_init_gfxdevice(struct sisusb_usb_data *sisusb)\n{\n\tstruct sisusb_packet packet;\n\tint ret;\n\tu32 tmp32;\n\n\t \n\tpacket.header  = 0x001f;\n\tpacket.address = 0x00000324;\n\tpacket.data    = 0x00000004;\n\tret = sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\n\tpacket.header  = 0x001f;\n\tpacket.address = 0x00000364;\n\tpacket.data    = 0x00000004;\n\tret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\n\tpacket.header  = 0x001f;\n\tpacket.address = 0x00000384;\n\tpacket.data    = 0x00000004;\n\tret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\n\tpacket.header  = 0x001f;\n\tpacket.address = 0x00000100;\n\tpacket.data    = 0x00000700;\n\tret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\n\tpacket.header  = 0x000f;\n\tpacket.address = 0x00000004;\n\tret |= sisusb_send_bridge_packet(sisusb, 6, &packet, 0);\n\tpacket.data |= 0x17;\n\tret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\n\t \n\tret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\n\tret |= sisusb_write_pci_config(sisusb, 0x10, 0xfffffff0);\n\tret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\n\ttmp32 &= 0x0f;\n\ttmp32 |= SISUSB_PCI_MEMBASE;\n\tret |= sisusb_write_pci_config(sisusb, 0x10, tmp32);\n\n\t \n\tret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\n\tret |= sisusb_write_pci_config(sisusb, 0x14, 0xfffffff0);\n\tret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\n\ttmp32 &= 0x0f;\n\ttmp32 |= SISUSB_PCI_MMIOBASE;\n\tret |= sisusb_write_pci_config(sisusb, 0x14, tmp32);\n\n\t \n\tret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\n\tret |= sisusb_write_pci_config(sisusb, 0x18, 0xfffffff0);\n\tret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\n\ttmp32 &= 0x0f;\n\ttmp32 |= SISUSB_PCI_IOPORTBASE;\n\tret |= sisusb_write_pci_config(sisusb, 0x18, tmp32);\n\n\t \n\tret |= sisusb_read_pci_config(sisusb, 0x04, &tmp32);\n\ttmp32 |= 0x3;\n\tret |= sisusb_write_pci_config(sisusb, 0x04, tmp32);\n\n\tif (ret == 0) {\n\t\t \n\t\tpacket.header  = 0x001f;\n\t\tpacket.address = 0x00000050;\n\t\tpacket.data    = 0x000000ff;\n\t\tret |= sisusb_send_bridge_packet(sisusb, 10, &packet, 0);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int sisusb_init_gfxdevice(struct sisusb_usb_data *sisusb, int initscreen)\n{\n\tint ret = 0, test = 0;\n\tu32 tmp32;\n\n\tif (sisusb->devinit == 1) {\n\t\t \n\t\tret |= sisusb_read_pci_config(sisusb, 0x10, &tmp32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((tmp32 & 0xfffffff0) == SISUSB_PCI_MEMBASE)\n\t\t\ttest++;\n\n\t\tret |= sisusb_read_pci_config(sisusb, 0x14, &tmp32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((tmp32 & 0xfffffff0) == SISUSB_PCI_MMIOBASE)\n\t\t\ttest++;\n\n\t\tret |= sisusb_read_pci_config(sisusb, 0x18, &tmp32);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((tmp32 & 0xfffffff0) == SISUSB_PCI_IOPORTBASE)\n\t\t\ttest++;\n\t}\n\n\t \n\tif ((sisusb->devinit == 0) || (test != 3)) {\n\n\t\tret |= sisusb_do_init_gfxdevice(sisusb);\n\n\t\tif (ret == 0)\n\t\t\tsisusb->devinit = 1;\n\n\t}\n\n\tif (sisusb->devinit) {\n\t\t \n\t\tif (sisusb_init_gfxcore(sisusb) == 0) {\n\t\t\tsisusb->gfxinit = 1;\n\t\t\tsisusb_get_ramconfig(sisusb);\n\t\t\tsisusb_set_default_mode(sisusb, 1);\n\t\t\tret |= sisusb_setup_screen(sisusb, 1, initscreen);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic int sisusb_open(struct inode *inode, struct file *file)\n{\n\tstruct sisusb_usb_data *sisusb;\n\tstruct usb_interface *interface;\n\tint subminor = iminor(inode);\n\n\tinterface = usb_find_interface(&sisusb_driver, subminor);\n\tif (!interface)\n\t\treturn -ENODEV;\n\n\tsisusb = usb_get_intfdata(interface);\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\tif (!sisusb->present || !sisusb->ready) {\n\t\tmutex_unlock(&sisusb->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tif (sisusb->isopen) {\n\t\tmutex_unlock(&sisusb->lock);\n\t\treturn -EBUSY;\n\t}\n\n\tif (!sisusb->devinit) {\n\t\tif (sisusb->sisusb_dev->speed == USB_SPEED_HIGH ||\n\t\t\t\tsisusb->sisusb_dev->speed >= USB_SPEED_SUPER) {\n\t\t\tif (sisusb_init_gfxdevice(sisusb, 0)) {\n\t\t\t\tmutex_unlock(&sisusb->lock);\n\t\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\t\"Failed to initialize device\\n\");\n\t\t\t\treturn -EIO;\n\t\t\t}\n\t\t} else {\n\t\t\tmutex_unlock(&sisusb->lock);\n\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"Device not attached to USB 2.0 hub\\n\");\n\t\t\treturn -EIO;\n\t\t}\n\t}\n\n\t \n\tkref_get(&sisusb->kref);\n\n\tsisusb->isopen = 1;\n\n\tfile->private_data = sisusb;\n\n\tmutex_unlock(&sisusb->lock);\n\n\treturn 0;\n}\n\nstatic void sisusb_delete(struct kref *kref)\n{\n\tstruct sisusb_usb_data *sisusb = to_sisusb_dev(kref);\n\n\tif (!sisusb)\n\t\treturn;\n\n\tusb_put_dev(sisusb->sisusb_dev);\n\n\tsisusb->sisusb_dev = NULL;\n\tsisusb_free_buffers(sisusb);\n\tsisusb_free_urbs(sisusb);\n\tkfree(sisusb);\n}\n\nstatic int sisusb_release(struct inode *inode, struct file *file)\n{\n\tstruct sisusb_usb_data *sisusb;\n\n\tsisusb = file->private_data;\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\tif (sisusb->present) {\n\t\t \n\t\tif (!sisusb_wait_all_out_complete(sisusb))\n\t\t\tsisusb_kill_all_busy(sisusb);\n\t}\n\n\tsisusb->isopen = 0;\n\tfile->private_data = NULL;\n\n\tmutex_unlock(&sisusb->lock);\n\n\t \n\tkref_put(&sisusb->kref, sisusb_delete);\n\n\treturn 0;\n}\n\nstatic ssize_t sisusb_read(struct file *file, char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sisusb_usb_data *sisusb;\n\tssize_t bytes_read = 0;\n\tint errno = 0;\n\tu8 buf8;\n\tu16 buf16;\n\tu32 buf32, address;\n\n\tsisusb = file->private_data;\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\t \n\tif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\n\t\tmutex_unlock(&sisusb->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((*ppos) >= SISUSB_PCI_PSEUDO_IOPORTBASE &&\n\t\t\t(*ppos) <  SISUSB_PCI_PSEUDO_IOPORTBASE + 128) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_IOPORTBASE +\n\t\t\t\tSISUSB_PCI_IOPORTBASE;\n\n\t\t \n\t\tswitch (count) {\n\t\tcase 1:\n\t\t\tif (sisusb_read_memio_byte(sisusb, SISUSB_TYPE_IO,\n\t\t\t\t\taddress, &buf8))\n\t\t\t\terrno = -EIO;\n\t\t\telse if (put_user(buf8, (u8 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse\n\t\t\t\tbytes_read = 1;\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (sisusb_read_memio_word(sisusb, SISUSB_TYPE_IO,\n\t\t\t\t\taddress, &buf16))\n\t\t\t\terrno = -EIO;\n\t\t\telse if (put_user(buf16, (u16 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse\n\t\t\t\tbytes_read = 2;\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (sisusb_read_memio_long(sisusb, SISUSB_TYPE_IO,\n\t\t\t\t\taddress, &buf32))\n\t\t\t\terrno = -EIO;\n\t\t\telse if (put_user(buf32, (u32 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse\n\t\t\t\tbytes_read = 4;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terrno = -EIO;\n\n\t\t}\n\n\t} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MEMBASE && (*ppos) <\n\t\t\tSISUSB_PCI_PSEUDO_MEMBASE + sisusb->vramsize) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_MEMBASE +\n\t\t\t\tSISUSB_PCI_MEMBASE;\n\n\t\t \n\t\terrno = sisusb_read_mem_bulk(sisusb, address,\n\t\t\t\tNULL, count, buffer, &bytes_read);\n\n\t\tif (bytes_read)\n\t\t\terrno = bytes_read;\n\n\t} else  if ((*ppos) >= SISUSB_PCI_PSEUDO_MMIOBASE &&\n\t\t\t\t(*ppos) <  SISUSB_PCI_PSEUDO_MMIOBASE +\n\t\t\t\tSISUSB_PCI_MMIOSIZE) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_MMIOBASE +\n\t\t\t\tSISUSB_PCI_MMIOBASE;\n\n\t\t \n\t\terrno = sisusb_read_mem_bulk(sisusb, address,\n\t\t\t\tNULL, count, buffer, &bytes_read);\n\n\t\tif (bytes_read)\n\t\t\terrno = bytes_read;\n\n\t} else  if ((*ppos) >= SISUSB_PCI_PSEUDO_PCIBASE &&\n\t\t\t(*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE + 0x5c) {\n\n\t\tif (count != 4) {\n\t\t\tmutex_unlock(&sisusb->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_PCIBASE;\n\n\t\t \n\t\tif (sisusb_read_pci_config(sisusb, address, &buf32))\n\t\t\terrno = -EIO;\n\t\telse if (put_user(buf32, (u32 __user *)buffer))\n\t\t\terrno = -EFAULT;\n\t\telse\n\t\t\tbytes_read = 4;\n\n\t} else {\n\n\t\terrno = -EBADFD;\n\n\t}\n\n\t(*ppos) += bytes_read;\n\n\tmutex_unlock(&sisusb->lock);\n\n\treturn errno ? errno : bytes_read;\n}\n\nstatic ssize_t sisusb_write(struct file *file, const char __user *buffer,\n\t\tsize_t count, loff_t *ppos)\n{\n\tstruct sisusb_usb_data *sisusb;\n\tint errno = 0;\n\tssize_t bytes_written = 0;\n\tu8 buf8;\n\tu16 buf16;\n\tu32 buf32, address;\n\n\tsisusb = file->private_data;\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\t \n\tif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\n\t\tmutex_unlock(&sisusb->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tif ((*ppos) >= SISUSB_PCI_PSEUDO_IOPORTBASE &&\n\t\t\t(*ppos) <  SISUSB_PCI_PSEUDO_IOPORTBASE + 128) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_IOPORTBASE +\n\t\t\t\tSISUSB_PCI_IOPORTBASE;\n\n\t\t \n\t\tswitch (count) {\n\t\tcase 1:\n\t\t\tif (get_user(buf8, (u8 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse if (sisusb_write_memio_byte(sisusb,\n\t\t\t\t\tSISUSB_TYPE_IO, address, buf8))\n\t\t\t\terrno = -EIO;\n\t\t\telse\n\t\t\t\tbytes_written = 1;\n\n\t\t\tbreak;\n\n\t\tcase 2:\n\t\t\tif (get_user(buf16, (u16 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse if (sisusb_write_memio_word(sisusb,\n\t\t\t\t\tSISUSB_TYPE_IO, address, buf16))\n\t\t\t\terrno = -EIO;\n\t\t\telse\n\t\t\t\tbytes_written = 2;\n\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (get_user(buf32, (u32 __user *)buffer))\n\t\t\t\terrno = -EFAULT;\n\t\t\telse if (sisusb_write_memio_long(sisusb,\n\t\t\t\t\tSISUSB_TYPE_IO, address, buf32))\n\t\t\t\terrno = -EIO;\n\t\t\telse\n\t\t\t\tbytes_written = 4;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\terrno = -EIO;\n\t\t}\n\n\t} else if ((*ppos) >= SISUSB_PCI_PSEUDO_MEMBASE &&\n\t\t\t(*ppos) <  SISUSB_PCI_PSEUDO_MEMBASE +\n\t\t\tsisusb->vramsize) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_MEMBASE +\n\t\t\t\tSISUSB_PCI_MEMBASE;\n\n\t\t \n\t\terrno = sisusb_write_mem_bulk(sisusb, address, NULL,\n\t\t\t\tcount, buffer, 0, &bytes_written);\n\n\t\tif (bytes_written)\n\t\t\terrno = bytes_written;\n\n\t} else  if ((*ppos) >= SISUSB_PCI_PSEUDO_MMIOBASE &&\n\t\t\t(*ppos) <  SISUSB_PCI_PSEUDO_MMIOBASE +\n\t\t\tSISUSB_PCI_MMIOSIZE) {\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_MMIOBASE +\n\t\t\t\tSISUSB_PCI_MMIOBASE;\n\n\t\t \n\t\terrno = sisusb_write_mem_bulk(sisusb, address, NULL,\n\t\t\t\tcount, buffer, 0, &bytes_written);\n\n\t\tif (bytes_written)\n\t\t\terrno = bytes_written;\n\n\t} else  if ((*ppos) >= SISUSB_PCI_PSEUDO_PCIBASE &&\n\t\t\t\t(*ppos) <= SISUSB_PCI_PSEUDO_PCIBASE +\n\t\t\t\tSISUSB_PCI_PCONFSIZE) {\n\n\t\tif (count != 4) {\n\t\t\tmutex_unlock(&sisusb->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\taddress = (*ppos) - SISUSB_PCI_PSEUDO_PCIBASE;\n\n\t\t \n\t\tif (get_user(buf32, (u32 __user *)buffer))\n\t\t\terrno = -EFAULT;\n\t\telse if (sisusb_write_pci_config(sisusb, address, buf32))\n\t\t\terrno = -EIO;\n\t\telse\n\t\t\tbytes_written = 4;\n\n\n\t} else {\n\n\t\t \n\t\terrno = -EBADFD;\n\n\t}\n\n\t(*ppos) += bytes_written;\n\n\tmutex_unlock(&sisusb->lock);\n\n\treturn errno ? errno : bytes_written;\n}\n\nstatic loff_t sisusb_lseek(struct file *file, loff_t offset, int orig)\n{\n\tstruct sisusb_usb_data *sisusb;\n\tloff_t ret;\n\n\tsisusb = file->private_data;\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\t \n\tif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\n\t\tmutex_unlock(&sisusb->lock);\n\t\treturn -ENODEV;\n\t}\n\n\tret = no_seek_end_llseek(file, offset, orig);\n\n\tmutex_unlock(&sisusb->lock);\n\treturn ret;\n}\n\nstatic int sisusb_handle_command(struct sisusb_usb_data *sisusb,\n\t\tstruct sisusb_command *y, unsigned long arg)\n{\n\tint\tretval, length;\n\tu32\tport, address;\n\n\t \n\tif (!sisusb->devinit)\n\t\treturn -ENODEV;\n\n\tport = y->data3 -\n\t\tSISUSB_PCI_PSEUDO_IOPORTBASE +\n\t\tSISUSB_PCI_IOPORTBASE;\n\n\tswitch (y->operation) {\n\tcase SUCMD_GET:\n\t\tretval = sisusb_getidxreg(sisusb, port, y->data0, &y->data1);\n\t\tif (!retval) {\n\t\t\tif (copy_to_user((void __user *)arg, y, sizeof(*y)))\n\t\t\t\tretval = -EFAULT;\n\t\t}\n\t\tbreak;\n\n\tcase SUCMD_SET:\n\t\tretval = sisusb_setidxreg(sisusb, port, y->data0, y->data1);\n\t\tbreak;\n\n\tcase SUCMD_SETOR:\n\t\tretval = sisusb_setidxregor(sisusb, port, y->data0, y->data1);\n\t\tbreak;\n\n\tcase SUCMD_SETAND:\n\t\tretval = sisusb_setidxregand(sisusb, port, y->data0, y->data1);\n\t\tbreak;\n\n\tcase SUCMD_SETANDOR:\n\t\tretval = sisusb_setidxregandor(sisusb, port, y->data0,\n\t\t\t\ty->data1, y->data2);\n\t\tbreak;\n\n\tcase SUCMD_SETMASK:\n\t\tretval = sisusb_setidxregmask(sisusb, port, y->data0,\n\t\t\t\ty->data1, y->data2);\n\t\tbreak;\n\n\tcase SUCMD_CLRSCR:\n\t\t \n\t\tif (!sisusb->gfxinit)\n\t\t\treturn -ENODEV;\n\n\t\tlength = (y->data0 << 16) | (y->data1 << 8) | y->data2;\n\t\taddress = y->data3 - SISUSB_PCI_PSEUDO_MEMBASE +\n\t\t\t\tSISUSB_PCI_MEMBASE;\n\t\tretval = sisusb_clear_vram(sisusb, address, length);\n\t\tbreak;\n\n\tcase SUCMD_HANDLETEXTMODE:\n\t\tretval = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -EINVAL;\n\t}\n\n\tif (retval > 0)\n\t\tretval = -EIO;\n\n\treturn retval;\n}\n\nstatic long sisusb_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tstruct sisusb_usb_data *sisusb;\n\tstruct sisusb_info x;\n\tstruct sisusb_command y;\n\tlong retval = 0;\n\tu32 __user *argp = (u32 __user *)arg;\n\n\tsisusb = file->private_data;\n\tif (!sisusb)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&sisusb->lock);\n\n\t \n\tif (!sisusb->present || !sisusb->ready || !sisusb->sisusb_dev) {\n\t\tretval = -ENODEV;\n\t\tgoto err_out;\n\t}\n\n\tswitch (cmd) {\n\tcase SISUSB_GET_CONFIG_SIZE:\n\n\t\tif (put_user(sizeof(x), argp))\n\t\t\tretval = -EFAULT;\n\n\t\tbreak;\n\n\tcase SISUSB_GET_CONFIG:\n\n\t\tx.sisusb_id = SISUSB_ID;\n\t\tx.sisusb_version = SISUSB_VERSION;\n\t\tx.sisusb_revision = SISUSB_REVISION;\n\t\tx.sisusb_patchlevel = SISUSB_PATCHLEVEL;\n\t\tx.sisusb_gfxinit = sisusb->gfxinit;\n\t\tx.sisusb_vrambase = SISUSB_PCI_PSEUDO_MEMBASE;\n\t\tx.sisusb_mmiobase = SISUSB_PCI_PSEUDO_MMIOBASE;\n\t\tx.sisusb_iobase = SISUSB_PCI_PSEUDO_IOPORTBASE;\n\t\tx.sisusb_pcibase = SISUSB_PCI_PSEUDO_PCIBASE;\n\t\tx.sisusb_vramsize = sisusb->vramsize;\n\t\tx.sisusb_minor = sisusb->minor;\n\t\tx.sisusb_fbdevactive = 0;\n\t\tx.sisusb_conactive  = 0;\n\t\tmemset(x.sisusb_reserved, 0, sizeof(x.sisusb_reserved));\n\n\t\tif (copy_to_user((void __user *)arg, &x, sizeof(x)))\n\t\t\tretval = -EFAULT;\n\n\t\tbreak;\n\n\tcase SISUSB_COMMAND:\n\n\t\tif (copy_from_user(&y, (void __user *)arg, sizeof(y)))\n\t\t\tretval = -EFAULT;\n\t\telse\n\t\t\tretval = sisusb_handle_command(sisusb, &y, arg);\n\n\t\tbreak;\n\n\tdefault:\n\t\tretval = -ENOTTY;\n\t\tbreak;\n\t}\n\nerr_out:\n\tmutex_unlock(&sisusb->lock);\n\treturn retval;\n}\n\n#ifdef CONFIG_COMPAT\nstatic long sisusb_compat_ioctl(struct file *f, unsigned int cmd,\n\t\tunsigned long arg)\n{\n\tswitch (cmd) {\n\tcase SISUSB_GET_CONFIG_SIZE:\n\tcase SISUSB_GET_CONFIG:\n\tcase SISUSB_COMMAND:\n\t\treturn sisusb_ioctl(f, cmd, arg);\n\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n}\n#endif\n\nstatic const struct file_operations usb_sisusb_fops = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tsisusb_open,\n\t.release =\tsisusb_release,\n\t.read =\t\tsisusb_read,\n\t.write =\tsisusb_write,\n\t.llseek =\tsisusb_lseek,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = sisusb_compat_ioctl,\n#endif\n\t.unlocked_ioctl = sisusb_ioctl\n};\n\nstatic struct usb_class_driver usb_sisusb_class = {\n\t.name =\t\t\"sisusbvga%d\",\n\t.fops =\t\t&usb_sisusb_fops,\n\t.minor_base =\tSISUSB_MINOR\n};\n\nstatic int sisusb_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct sisusb_usb_data *sisusb;\n\tint retval = 0, i;\n\tstatic const u8 ep_addresses[] = {\n\t\tSISUSB_EP_GFX_IN | USB_DIR_IN,\n\t\tSISUSB_EP_GFX_OUT | USB_DIR_OUT,\n\t\tSISUSB_EP_GFX_BULK_OUT | USB_DIR_OUT,\n\t\tSISUSB_EP_GFX_LBULK_OUT | USB_DIR_OUT,\n\t\tSISUSB_EP_BRIDGE_IN | USB_DIR_IN,\n\t\tSISUSB_EP_BRIDGE_OUT | USB_DIR_OUT,\n\t\t0};\n\n\t \n\tif (!usb_check_bulk_endpoints(intf, ep_addresses)) {\n\t\tdev_err(&intf->dev, \"Invalid USB2VGA device\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tdev_info(&dev->dev, \"USB2VGA dongle found at address %d\\n\",\n\t\t\tdev->devnum);\n\n\t \n\tsisusb = kzalloc(sizeof(*sisusb), GFP_KERNEL);\n\tif (!sisusb)\n\t\treturn -ENOMEM;\n\n\tkref_init(&sisusb->kref);\n\n\tmutex_init(&(sisusb->lock));\n\n\tsisusb->sisusb_dev = dev;\n\tsisusb->vrambase   = SISUSB_PCI_MEMBASE;\n\tsisusb->mmiobase   = SISUSB_PCI_MMIOBASE;\n\tsisusb->mmiosize   = SISUSB_PCI_MMIOSIZE;\n\tsisusb->ioportbase = SISUSB_PCI_IOPORTBASE;\n\t \n\n\t \n\tretval = usb_register_dev(intf, &usb_sisusb_class);\n\tif (retval) {\n\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Failed to get a minor for device %d\\n\",\n\t\t\t\tdev->devnum);\n\t\tretval = -ENODEV;\n\t\tgoto error_1;\n\t}\n\n\tsisusb->minor = intf->minor;\n\n\t \n\tsisusb->ibufsize = SISUSB_IBUF_SIZE;\n\tsisusb->ibuf = kmalloc(SISUSB_IBUF_SIZE, GFP_KERNEL);\n\tif (!sisusb->ibuf) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_2;\n\t}\n\n\tsisusb->numobufs = 0;\n\tsisusb->obufsize = SISUSB_OBUF_SIZE;\n\tfor (i = 0; i < NUMOBUFS; i++) {\n\t\tsisusb->obuf[i] = kmalloc(SISUSB_OBUF_SIZE, GFP_KERNEL);\n\t\tif (!sisusb->obuf[i]) {\n\t\t\tif (i == 0) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto error_3;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tsisusb->numobufs++;\n\t}\n\n\t \n\tsisusb->sisurbin = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!sisusb->sisurbin) {\n\t\tretval = -ENOMEM;\n\t\tgoto error_3;\n\t}\n\tsisusb->completein = 1;\n\n\tfor (i = 0; i < sisusb->numobufs; i++) {\n\t\tsisusb->sisurbout[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!sisusb->sisurbout[i]) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error_4;\n\t\t}\n\t\tsisusb->urbout_context[i].sisusb = (void *)sisusb;\n\t\tsisusb->urbout_context[i].urbindex = i;\n\t\tsisusb->urbstatus[i] = 0;\n\t}\n\n\tdev_info(&sisusb->sisusb_dev->dev, \"Allocated %d output buffers\\n\",\n\t\t\tsisusb->numobufs);\n\n\t \n\n\tinit_waitqueue_head(&sisusb->wait_q);\n\n\tusb_set_intfdata(intf, sisusb);\n\n\tusb_get_dev(sisusb->sisusb_dev);\n\n\tsisusb->present = 1;\n\n\tif (dev->speed == USB_SPEED_HIGH || dev->speed >= USB_SPEED_SUPER) {\n\t\tint initscreen = 1;\n\t\tif (sisusb_init_gfxdevice(sisusb, initscreen))\n\t\t\tdev_err(&sisusb->sisusb_dev->dev,\n\t\t\t\t\t\"Failed to early initialize device\\n\");\n\n\t} else\n\t\tdev_info(&sisusb->sisusb_dev->dev,\n\t\t\t\t\"Not attached to USB 2.0 hub, deferring init\\n\");\n\n\tsisusb->ready = 1;\n\n#ifdef SISUSBENDIANTEST\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST ***\\n\");\n\tsisusb_testreadwrite(sisusb);\n\tdev_dbg(&sisusb->sisusb_dev->dev, \"*** RWTEST END ***\\n\");\n#endif\n\n\treturn 0;\n\nerror_4:\n\tsisusb_free_urbs(sisusb);\nerror_3:\n\tsisusb_free_buffers(sisusb);\nerror_2:\n\tusb_deregister_dev(intf, &usb_sisusb_class);\nerror_1:\n\tkfree(sisusb);\n\treturn retval;\n}\n\nstatic void sisusb_disconnect(struct usb_interface *intf)\n{\n\tstruct sisusb_usb_data *sisusb;\n\n\t \n\tsisusb = usb_get_intfdata(intf);\n\tif (!sisusb)\n\t\treturn;\n\n\tusb_deregister_dev(intf, &usb_sisusb_class);\n\n\tmutex_lock(&sisusb->lock);\n\n\t \n\tif (!sisusb_wait_all_out_complete(sisusb))\n\t\tsisusb_kill_all_busy(sisusb);\n\n\tusb_set_intfdata(intf, NULL);\n\n\tsisusb->present = 0;\n\tsisusb->ready = 0;\n\n\tmutex_unlock(&sisusb->lock);\n\n\t \n\tkref_put(&sisusb->kref, sisusb_delete);\n}\n\nstatic const struct usb_device_id sisusb_table[] = {\n\t{ USB_DEVICE(0x0711, 0x0550) },\n\t{ USB_DEVICE(0x0711, 0x0900) },\n\t{ USB_DEVICE(0x0711, 0x0901) },\n\t{ USB_DEVICE(0x0711, 0x0902) },\n\t{ USB_DEVICE(0x0711, 0x0903) },\n\t{ USB_DEVICE(0x0711, 0x0918) },\n\t{ USB_DEVICE(0x0711, 0x0920) },\n\t{ USB_DEVICE(0x0711, 0x0950) },\n\t{ USB_DEVICE(0x0711, 0x5200) },\n\t{ USB_DEVICE(0x182d, 0x021c) },\n\t{ USB_DEVICE(0x182d, 0x0269) },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(usb, sisusb_table);\n\nstatic struct usb_driver sisusb_driver = {\n\t.name =\t\t\"sisusb\",\n\t.probe =\tsisusb_probe,\n\t.disconnect =\tsisusb_disconnect,\n\t.id_table =\tsisusb_table,\n};\n\nmodule_usb_driver(sisusb_driver);\n\nMODULE_AUTHOR(\"Thomas Winischhofer <thomas@winischhofer.net>\");\nMODULE_DESCRIPTION(\"sisusbvga - Driver for Net2280/SiS315-based USB2VGA dongles\");\nMODULE_LICENSE(\"GPL\");\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}