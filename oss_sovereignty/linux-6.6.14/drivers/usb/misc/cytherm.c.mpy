{
  "module_name": "cytherm.c",
  "hash_id": "444c33fad49f598f84b892ff92455fc9b8f2144dcfe1c95bcddaf204eb5a77a8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/misc/cytherm.c",
  "human_readable_source": "\n \n\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb.h>\n\n#define DRIVER_AUTHOR \"Erik Rigtorp\"\n#define DRIVER_DESC \"Cypress USB Thermometer driver\"\n\n#define USB_SKEL_VENDOR_ID\t0x04b4\n#define USB_SKEL_PRODUCT_ID\t0x0002\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(USB_SKEL_VENDOR_ID, USB_SKEL_PRODUCT_ID) },\n\t{ }\n};\nMODULE_DEVICE_TABLE (usb, id_table);\n\n \nstruct usb_cytherm {\n\tstruct usb_device    *udev;\t  \n\tstruct usb_interface *interface;  \n\tint brightness;\n};\n\n\n \n \n#define PING       0x00\n#define READ_ROM   0x01  \n#define READ_RAM   0x02  \n#define WRITE_RAM  0x03  \n#define READ_PORT  0x04  \n#define WRITE_PORT 0x05   \n\n\n \nstatic int vendor_command(struct usb_device *dev, unsigned char request, \n\t\t\t  unsigned char value, unsigned char index,\n\t\t\t  void *buf, int size)\n{\n\treturn usb_control_msg(dev, usb_rcvctrlpipe(dev, 0),\n\t\t\t       request, \n\t\t\t       USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_OTHER,\n\t\t\t       value, \n\t\t\t       index, buf, size,\n\t\t\t       USB_CTRL_GET_TIMEOUT);\n}\n\n\n\n#define BRIGHTNESS 0x2c      \n#define BRIGHTNESS_SEM 0x2b  \n\nstatic ssize_t brightness_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);    \n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);     \n\n\treturn sprintf(buf, \"%i\", cytherm->brightness);\n}\n\nstatic ssize_t brightness_store(struct device *dev, struct device_attribute *attr, const char *buf,\n\t\t\t      size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tunsigned char *buffer;\n\tint retval;\n   \n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\tcytherm->brightness = simple_strtoul(buf, NULL, 10);\n   \n\tif (cytherm->brightness > 0xFF)\n\t\tcytherm->brightness = 0xFF;\n\telse if (cytherm->brightness < 0)\n\t\tcytherm->brightness = 0;\n   \n\t \n\tretval = vendor_command(cytherm->udev, WRITE_RAM, BRIGHTNESS, \n\t\t\t\tcytherm->brightness, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\t \n\tretval = vendor_command(cytherm->udev, WRITE_RAM, BRIGHTNESS_SEM,\n\t\t\t\t0x01, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n   \n\tkfree(buffer);\n   \n\treturn count;\n}\nstatic DEVICE_ATTR_RW(brightness);\n\n\n#define TEMP 0x33  \n#define SIGN 0x34  \n\nstatic ssize_t temp_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tint retval;\n\tunsigned char *buffer;\n\n\tint temp, sign;\n   \n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\t \n\tretval = vendor_command(cytherm->udev, READ_RAM, TEMP, 0, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\ttemp = buffer[1];\n   \n\t \n\tretval = vendor_command(cytherm->udev, READ_RAM, SIGN, 0, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\tsign = buffer[1];\n\n\tkfree(buffer);\n   \n\treturn sprintf(buf, \"%c%i.%i\", sign ? '-' : '+', temp >> 1,\n\t\t       5*(temp - ((temp >> 1) << 1)));\n}\nstatic DEVICE_ATTR_RO(temp);\n\n\n#define BUTTON 0x7a\n\nstatic ssize_t button_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tint retval;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\t \n\tretval = vendor_command(cytherm->udev, READ_RAM, BUTTON, 0, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n   \n\tretval = buffer[1];\n\n\tkfree(buffer);\n\n\tif (retval)\n\t\treturn sprintf(buf, \"1\");\n\telse\n\t\treturn sprintf(buf, \"0\");\n}\nstatic DEVICE_ATTR_RO(button);\n\n\nstatic ssize_t port0_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tint retval;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\tretval = vendor_command(cytherm->udev, READ_PORT, 0, 0, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\n\tretval = buffer[1];\n\n\tkfree(buffer);\n\n\treturn sprintf(buf, \"%d\", retval);\n}\n\n\nstatic ssize_t port0_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tunsigned char *buffer;\n\tint retval;\n\tint tmp;\n   \n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\ttmp = simple_strtoul(buf, NULL, 10);\n   \n\tif (tmp > 0xFF)\n\t\ttmp = 0xFF;\n\telse if (tmp < 0)\n\t\ttmp = 0;\n   \n\tretval = vendor_command(cytherm->udev, WRITE_PORT, 0,\n\t\t\t\ttmp, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\n\tkfree(buffer);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(port0);\n\nstatic ssize_t port1_show(struct device *dev, struct device_attribute *attr, char *buf)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tint retval;\n\tunsigned char *buffer;\n\n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\tretval = vendor_command(cytherm->udev, READ_PORT, 1, 0, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n   \n\tretval = buffer[1];\n\n\tkfree(buffer);\n\n\treturn sprintf(buf, \"%d\", retval);\n}\n\n\nstatic ssize_t port1_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct usb_interface *intf = to_usb_interface(dev);\n\tstruct usb_cytherm *cytherm = usb_get_intfdata(intf);\n\n\tunsigned char *buffer;\n\tint retval;\n\tint tmp;\n   \n\tbuffer = kmalloc(8, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn 0;\n\n\ttmp = simple_strtoul(buf, NULL, 10);\n   \n\tif (tmp > 0xFF)\n\t\ttmp = 0xFF;\n\telse if (tmp < 0)\n\t\ttmp = 0;\n   \n\tretval = vendor_command(cytherm->udev, WRITE_PORT, 1,\n\t\t\t\ttmp, buffer, 8);\n\tif (retval)\n\t\tdev_dbg(&cytherm->udev->dev, \"retval = %d\\n\", retval);\n\n\tkfree(buffer);\n\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(port1);\n\nstatic struct attribute *cytherm_attrs[] = {\n\t&dev_attr_brightness.attr,\n\t&dev_attr_temp.attr,\n\t&dev_attr_button.attr,\n\t&dev_attr_port0.attr,\n\t&dev_attr_port1.attr,\n\tNULL,\n};\nATTRIBUTE_GROUPS(cytherm);\n\nstatic int cytherm_probe(struct usb_interface *interface, \n\t\t\t const struct usb_device_id *id)\n{\n\tstruct usb_device *udev = interface_to_usbdev(interface);\n\tstruct usb_cytherm *dev;\n\tint retval = -ENOMEM;\n\n\tdev = kzalloc(sizeof(struct usb_cytherm), GFP_KERNEL);\n\tif (!dev)\n\t\tgoto error_mem;\n\n\tdev->udev = usb_get_dev(udev);\n\n\tusb_set_intfdata(interface, dev);\n\n\tdev->brightness = 0xFF;\n\n\tdev_info(&interface->dev,\n\t\t  \"Cypress thermometer device now attached\\n\");\n\treturn 0;\n\nerror_mem:\n\treturn retval;\n}\n\nstatic void cytherm_disconnect(struct usb_interface *interface)\n{\n\tstruct usb_cytherm *dev;\n\n\tdev = usb_get_intfdata(interface);\n\n\t \n\tusb_set_intfdata(interface, NULL);\n\n\tusb_put_dev(dev->udev);\n\n\tkfree(dev);\n\n\tdev_info(&interface->dev, \"Cypress thermometer now disconnected\\n\");\n}\n\n \nstatic struct usb_driver cytherm_driver = {\n\t.name =\t\t\"cytherm\",\n\t.probe =\tcytherm_probe,\n\t.disconnect =\tcytherm_disconnect,\n\t.id_table =\tid_table,\n\t.dev_groups =\tcytherm_groups,\n};\n\nmodule_usb_driver(cytherm_driver);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}