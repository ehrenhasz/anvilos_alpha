{
  "module_name": "usb-otg-fsm.c",
  "hash_id": "dfeacc16189e72fe13117c9f2a40f4dea751f148f75b9a2a4f3343942c231ed5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/common/usb-otg-fsm.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/usb.h>\n#include <linux/usb/gadget.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/otg-fsm.h>\n\n#ifdef VERBOSE\n#define VDBG(fmt, args...) pr_debug(\"[%s]  \" fmt, \\\n\t\t\t\t __func__, ## args)\n#else\n#define VDBG(stuff...)\tdo {} while (0)\n#endif\n\n \nstatic int otg_set_protocol(struct otg_fsm *fsm, int protocol)\n{\n\tint ret = 0;\n\n\tif (fsm->protocol != protocol) {\n\t\tVDBG(\"Changing role fsm->protocol= %d; new protocol= %d\\n\",\n\t\t\tfsm->protocol, protocol);\n\t\t \n\t\tif (fsm->protocol == PROTO_HOST)\n\t\t\tret = otg_start_host(fsm, 0);\n\t\telse if (fsm->protocol == PROTO_GADGET)\n\t\t\tret = otg_start_gadget(fsm, 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\t \n\t\tif (protocol == PROTO_HOST)\n\t\t\tret = otg_start_host(fsm, 1);\n\t\telse if (protocol == PROTO_GADGET)\n\t\t\tret = otg_start_gadget(fsm, 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tfsm->protocol = protocol;\n\t\treturn 0;\n\t}\n\n\treturn 0;\n}\n\n \nstatic void otg_leave_state(struct otg_fsm *fsm, enum usb_otg_state old_state)\n{\n\tswitch (old_state) {\n\tcase OTG_STATE_B_IDLE:\n\t\totg_del_timer(fsm, B_SE0_SRP);\n\t\tfsm->b_se0_srp = 0;\n\t\tfsm->adp_sns = 0;\n\t\tfsm->adp_prb = 0;\n\t\tbreak;\n\tcase OTG_STATE_B_SRP_INIT:\n\t\tfsm->data_pulse = 0;\n\t\tfsm->b_srp_done = 0;\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif (fsm->otg->gadget)\n\t\t\tfsm->otg->gadget->host_request_flag = 0;\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\totg_del_timer(fsm, B_ASE0_BRST);\n\t\tfsm->b_ase0_brst_tmout = 0;\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\tbreak;\n\tcase OTG_STATE_A_IDLE:\n\t\tfsm->adp_prb = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\totg_del_timer(fsm, A_WAIT_VRISE);\n\t\tfsm->a_wait_vrise_tmout = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\totg_del_timer(fsm, A_WAIT_BCON);\n\t\tfsm->a_wait_bcon_tmout = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\totg_del_timer(fsm, A_WAIT_ENUM);\n\t\tbreak;\n\tcase OTG_STATE_A_SUSPEND:\n\t\totg_del_timer(fsm, A_AIDL_BDIS);\n\t\tfsm->a_aidl_bdis_tmout = 0;\n\t\tfsm->a_suspend_req_inf = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\totg_del_timer(fsm, A_BIDL_ADIS);\n\t\tfsm->a_bidl_adis_tmout = 0;\n\t\tif (fsm->otg->gadget)\n\t\t\tfsm->otg->gadget->host_request_flag = 0;\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\totg_del_timer(fsm, A_WAIT_VFALL);\n\t\tfsm->a_wait_vfall_tmout = 0;\n\t\totg_del_timer(fsm, A_WAIT_VRISE);\n\t\tbreak;\n\tcase OTG_STATE_A_VBUS_ERR:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void otg_hnp_polling_work(struct work_struct *work)\n{\n\tstruct otg_fsm *fsm = container_of(to_delayed_work(work),\n\t\t\t\tstruct otg_fsm, hnp_polling_work);\n\tstruct usb_device *udev;\n\tenum usb_otg_state state = fsm->otg->state;\n\tu8 flag;\n\tint retval;\n\n\tif (state != OTG_STATE_A_HOST && state != OTG_STATE_B_HOST)\n\t\treturn;\n\n\tudev = usb_hub_find_child(fsm->otg->host->root_hub, 1);\n\tif (!udev) {\n\t\tdev_err(fsm->otg->host->controller,\n\t\t\t\"no usb dev connected, can't start HNP polling\\n\");\n\t\treturn;\n\t}\n\n\t*fsm->host_req_flag = 0;\n\t \n\tretval = usb_control_msg(udev,\n\t\t\t\tusb_rcvctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_GET_STATUS,\n\t\t\t\tUSB_DIR_IN | USB_RECIP_DEVICE,\n\t\t\t\t0,\n\t\t\t\tOTG_STS_SELECTOR,\n\t\t\t\tfsm->host_req_flag,\n\t\t\t\t1,\n\t\t\t\tUSB_CTRL_GET_TIMEOUT);\n\tif (retval != 1) {\n\t\tdev_err(&udev->dev, \"Get one byte OTG status failed\\n\");\n\t\treturn;\n\t}\n\n\tflag = *fsm->host_req_flag;\n\tif (flag == 0) {\n\t\t \n\t\tschedule_delayed_work(&fsm->hnp_polling_work,\n\t\t\t\t\tmsecs_to_jiffies(T_HOST_REQ_POLL));\n\t\treturn;\n\t} else if (flag != HOST_REQUEST_FLAG) {\n\t\tdev_err(&udev->dev, \"host request flag %d is invalid\\n\", flag);\n\t\treturn;\n\t}\n\n\t \n\tif (state == OTG_STATE_A_HOST) {\n\t\t \n\t\tif (!fsm->otg->host->b_hnp_enable) {\n\t\t\tretval = usb_control_msg(udev,\n\t\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t\t0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (retval >= 0)\n\t\t\t\tfsm->otg->host->b_hnp_enable = 1;\n\t\t}\n\t\tfsm->a_bus_req = 0;\n\t} else if (state == OTG_STATE_B_HOST) {\n\t\tfsm->b_bus_req = 0;\n\t}\n\n\totg_statemachine(fsm);\n}\n\nstatic void otg_start_hnp_polling(struct otg_fsm *fsm)\n{\n\t \n\tif (!fsm->host_req_flag)\n\t\treturn;\n\n\tif (!fsm->hnp_work_inited) {\n\t\tINIT_DELAYED_WORK(&fsm->hnp_polling_work, otg_hnp_polling_work);\n\t\tfsm->hnp_work_inited = true;\n\t}\n\n\tschedule_delayed_work(&fsm->hnp_polling_work,\n\t\t\t\t\tmsecs_to_jiffies(T_HOST_REQ_POLL));\n}\n\n \nstatic int otg_set_state(struct otg_fsm *fsm, enum usb_otg_state new_state)\n{\n\tif (fsm->otg->state == new_state)\n\t\treturn 0;\n\tVDBG(\"Set state: %s\\n\", usb_otg_state_string(new_state));\n\totg_leave_state(fsm, fsm->otg->state);\n\tswitch (new_state) {\n\tcase OTG_STATE_B_IDLE:\n\t\totg_drv_vbus(fsm, 0);\n\t\totg_chrg_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\t \n\t\totg_start_adp_sns(fsm);\n\t\totg_set_protocol(fsm, PROTO_UNDEF);\n\t\totg_add_timer(fsm, B_SE0_SRP);\n\t\tbreak;\n\tcase OTG_STATE_B_SRP_INIT:\n\t\totg_start_pulse(fsm);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_UNDEF);\n\t\totg_add_timer(fsm, B_SRP_FAIL);\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\totg_chrg_vbus(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_GADGET);\n\t\totg_loc_conn(fsm, 1);\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\totg_chrg_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\totg_add_timer(fsm, B_ASE0_BRST);\n\t\tfsm->a_bus_suspend = 0;\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\totg_chrg_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 1);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\tusb_bus_start_enum(fsm->otg->host,\n\t\t\t\tfsm->otg->host->otg_port);\n\t\totg_start_hnp_polling(fsm);\n\t\tbreak;\n\tcase OTG_STATE_A_IDLE:\n\t\totg_drv_vbus(fsm, 0);\n\t\totg_chrg_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_start_adp_prb(fsm);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\totg_drv_vbus(fsm, 1);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\totg_add_timer(fsm, A_WAIT_VRISE);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\totg_drv_vbus(fsm, 1);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\totg_add_timer(fsm, A_WAIT_BCON);\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\totg_drv_vbus(fsm, 1);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 1);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\t \n\t\tif (!fsm->a_bus_req || fsm->a_suspend_req_inf)\n\t\t\totg_add_timer(fsm, A_WAIT_ENUM);\n\t\totg_start_hnp_polling(fsm);\n\t\tbreak;\n\tcase OTG_STATE_A_SUSPEND:\n\t\totg_drv_vbus(fsm, 1);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\totg_add_timer(fsm, A_AIDL_BDIS);\n\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_GADGET);\n\t\totg_drv_vbus(fsm, 1);\n\t\totg_loc_conn(fsm, 1);\n\t\totg_add_timer(fsm, A_BIDL_ADIS);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\totg_drv_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_HOST);\n\t\totg_add_timer(fsm, A_WAIT_VFALL);\n\t\tbreak;\n\tcase OTG_STATE_A_VBUS_ERR:\n\t\totg_drv_vbus(fsm, 0);\n\t\totg_loc_conn(fsm, 0);\n\t\totg_loc_sof(fsm, 0);\n\t\totg_set_protocol(fsm, PROTO_UNDEF);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tfsm->otg->state = new_state;\n\tfsm->state_changed = 1;\n\treturn 0;\n}\n\n \nint otg_statemachine(struct otg_fsm *fsm)\n{\n\tenum usb_otg_state state;\n\n\tmutex_lock(&fsm->lock);\n\n\tstate = fsm->otg->state;\n\tfsm->state_changed = 0;\n\t \n\n\tswitch (state) {\n\tcase OTG_STATE_UNDEFINED:\n\t\tVDBG(\"fsm->id = %d\\n\", fsm->id);\n\t\tif (fsm->id)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\telse\n\t\t\totg_set_state(fsm, OTG_STATE_A_IDLE);\n\t\tbreak;\n\tcase OTG_STATE_B_IDLE:\n\t\tif (!fsm->id)\n\t\t\totg_set_state(fsm, OTG_STATE_A_IDLE);\n\t\telse if (fsm->b_sess_vld && fsm->otg->gadget)\n\t\t\totg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\n\t\telse if ((fsm->b_bus_req || fsm->adp_change || fsm->power_up) &&\n\t\t\t\tfsm->b_ssend_srp && fsm->b_se0_srp)\n\t\t\totg_set_state(fsm, OTG_STATE_B_SRP_INIT);\n\t\tbreak;\n\tcase OTG_STATE_B_SRP_INIT:\n\t\tif (!fsm->id || fsm->b_srp_done)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\tbreak;\n\tcase OTG_STATE_B_PERIPHERAL:\n\t\tif (!fsm->id || !fsm->b_sess_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\telse if (fsm->b_bus_req && fsm->otg->\n\t\t\t\tgadget->b_hnp_enable && fsm->a_bus_suspend)\n\t\t\totg_set_state(fsm, OTG_STATE_B_WAIT_ACON);\n\t\tbreak;\n\tcase OTG_STATE_B_WAIT_ACON:\n\t\tif (fsm->a_conn)\n\t\t\totg_set_state(fsm, OTG_STATE_B_HOST);\n\t\telse if (!fsm->id || !fsm->b_sess_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\telse if (fsm->a_bus_resume || fsm->b_ase0_brst_tmout) {\n\t\t\tfsm->b_ase0_brst_tmout = 0;\n\t\t\totg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\n\t\t}\n\t\tbreak;\n\tcase OTG_STATE_B_HOST:\n\t\tif (!fsm->id || !fsm->b_sess_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\telse if (!fsm->b_bus_req || !fsm->a_conn || fsm->test_device)\n\t\t\totg_set_state(fsm, OTG_STATE_B_PERIPHERAL);\n\t\tbreak;\n\tcase OTG_STATE_A_IDLE:\n\t\tif (fsm->id)\n\t\t\totg_set_state(fsm, OTG_STATE_B_IDLE);\n\t\telse if (!fsm->a_bus_drop && (fsm->a_bus_req ||\n\t\t\t  fsm->a_srp_det || fsm->adp_change || fsm->power_up))\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VRISE);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VRISE:\n\t\tif (fsm->a_vbus_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\n\t\telse if (fsm->id || fsm->a_bus_drop ||\n\t\t\t\tfsm->a_wait_vrise_tmout)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_BCON:\n\t\tif (!fsm->a_vbus_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\n\t\telse if (fsm->b_conn)\n\t\t\totg_set_state(fsm, OTG_STATE_A_HOST);\n\t\telse if (fsm->id || fsm->a_bus_drop || fsm->a_wait_bcon_tmout)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\tbreak;\n\tcase OTG_STATE_A_HOST:\n\t\tif (fsm->id || fsm->a_bus_drop)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\telse if ((!fsm->a_bus_req || fsm->a_suspend_req_inf) &&\n\t\t\t\tfsm->otg->host->b_hnp_enable)\n\t\t\totg_set_state(fsm, OTG_STATE_A_SUSPEND);\n\t\telse if (!fsm->b_conn)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\n\t\telse if (!fsm->a_vbus_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\n\t\tbreak;\n\tcase OTG_STATE_A_SUSPEND:\n\t\tif (!fsm->b_conn && fsm->otg->host->b_hnp_enable)\n\t\t\totg_set_state(fsm, OTG_STATE_A_PERIPHERAL);\n\t\telse if (!fsm->b_conn && !fsm->otg->host->b_hnp_enable)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\n\t\telse if (fsm->a_bus_req || fsm->b_bus_resume)\n\t\t\totg_set_state(fsm, OTG_STATE_A_HOST);\n\t\telse if (fsm->id || fsm->a_bus_drop || fsm->a_aidl_bdis_tmout)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\telse if (!fsm->a_vbus_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\n\t\tbreak;\n\tcase OTG_STATE_A_PERIPHERAL:\n\t\tif (fsm->id || fsm->a_bus_drop)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\telse if (fsm->a_bidl_adis_tmout || fsm->b_bus_suspend)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_BCON);\n\t\telse if (!fsm->a_vbus_vld)\n\t\t\totg_set_state(fsm, OTG_STATE_A_VBUS_ERR);\n\t\tbreak;\n\tcase OTG_STATE_A_WAIT_VFALL:\n\t\tif (fsm->a_wait_vfall_tmout)\n\t\t\totg_set_state(fsm, OTG_STATE_A_IDLE);\n\t\tbreak;\n\tcase OTG_STATE_A_VBUS_ERR:\n\t\tif (fsm->id || fsm->a_bus_drop || fsm->a_clr_err)\n\t\t\totg_set_state(fsm, OTG_STATE_A_WAIT_VFALL);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tmutex_unlock(&fsm->lock);\n\n\tVDBG(\"quit statemachine, changed = %d\\n\", fsm->state_changed);\n\treturn fsm->state_changed;\n}\nEXPORT_SYMBOL_GPL(otg_statemachine);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}