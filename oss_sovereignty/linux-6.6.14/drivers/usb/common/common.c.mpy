{
  "module_name": "common.c",
  "hash_id": "3f45b426e8816c7524b00876ae54dada8a25695b278c70668dc194fa8727c03a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/common/common.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/usb/of.h>\n#include <linux/usb/otg.h>\n#include <linux/of_platform.h>\n#include <linux/debugfs.h>\n#include \"common.h\"\n\nstatic const char *const ep_type_names[] = {\n\t[USB_ENDPOINT_XFER_CONTROL] = \"ctrl\",\n\t[USB_ENDPOINT_XFER_ISOC] = \"isoc\",\n\t[USB_ENDPOINT_XFER_BULK] = \"bulk\",\n\t[USB_ENDPOINT_XFER_INT] = \"intr\",\n};\n\n \nconst char *usb_ep_type_string(int ep_type)\n{\n\tif (ep_type < 0 || ep_type >= ARRAY_SIZE(ep_type_names))\n\t\treturn \"unknown\";\n\n\treturn ep_type_names[ep_type];\n}\nEXPORT_SYMBOL_GPL(usb_ep_type_string);\n\nconst char *usb_otg_state_string(enum usb_otg_state state)\n{\n\tstatic const char *const names[] = {\n\t\t[OTG_STATE_A_IDLE] = \"a_idle\",\n\t\t[OTG_STATE_A_WAIT_VRISE] = \"a_wait_vrise\",\n\t\t[OTG_STATE_A_WAIT_BCON] = \"a_wait_bcon\",\n\t\t[OTG_STATE_A_HOST] = \"a_host\",\n\t\t[OTG_STATE_A_SUSPEND] = \"a_suspend\",\n\t\t[OTG_STATE_A_PERIPHERAL] = \"a_peripheral\",\n\t\t[OTG_STATE_A_WAIT_VFALL] = \"a_wait_vfall\",\n\t\t[OTG_STATE_A_VBUS_ERR] = \"a_vbus_err\",\n\t\t[OTG_STATE_B_IDLE] = \"b_idle\",\n\t\t[OTG_STATE_B_SRP_INIT] = \"b_srp_init\",\n\t\t[OTG_STATE_B_PERIPHERAL] = \"b_peripheral\",\n\t\t[OTG_STATE_B_WAIT_ACON] = \"b_wait_acon\",\n\t\t[OTG_STATE_B_HOST] = \"b_host\",\n\t};\n\n\tif (state < 0 || state >= ARRAY_SIZE(names))\n\t\treturn \"UNDEFINED\";\n\n\treturn names[state];\n}\nEXPORT_SYMBOL_GPL(usb_otg_state_string);\n\nstatic const char *const speed_names[] = {\n\t[USB_SPEED_UNKNOWN] = \"UNKNOWN\",\n\t[USB_SPEED_LOW] = \"low-speed\",\n\t[USB_SPEED_FULL] = \"full-speed\",\n\t[USB_SPEED_HIGH] = \"high-speed\",\n\t[USB_SPEED_WIRELESS] = \"wireless\",\n\t[USB_SPEED_SUPER] = \"super-speed\",\n\t[USB_SPEED_SUPER_PLUS] = \"super-speed-plus\",\n};\n\nstatic const char *const ssp_rate[] = {\n\t[USB_SSP_GEN_UNKNOWN] = \"UNKNOWN\",\n\t[USB_SSP_GEN_2x1] = \"super-speed-plus-gen2x1\",\n\t[USB_SSP_GEN_1x2] = \"super-speed-plus-gen1x2\",\n\t[USB_SSP_GEN_2x2] = \"super-speed-plus-gen2x2\",\n};\n\n \nconst char *usb_speed_string(enum usb_device_speed speed)\n{\n\tif (speed < 0 || speed >= ARRAY_SIZE(speed_names))\n\t\tspeed = USB_SPEED_UNKNOWN;\n\treturn speed_names[speed];\n}\nEXPORT_SYMBOL_GPL(usb_speed_string);\n\n \nenum usb_device_speed usb_get_maximum_speed(struct device *dev)\n{\n\tconst char *maximum_speed;\n\tint ret;\n\n\tret = device_property_read_string(dev, \"maximum-speed\", &maximum_speed);\n\tif (ret < 0)\n\t\treturn USB_SPEED_UNKNOWN;\n\n\tret = match_string(ssp_rate, ARRAY_SIZE(ssp_rate), maximum_speed);\n\tif (ret > 0)\n\t\treturn USB_SPEED_SUPER_PLUS;\n\n\tret = match_string(speed_names, ARRAY_SIZE(speed_names), maximum_speed);\n\treturn (ret < 0) ? USB_SPEED_UNKNOWN : ret;\n}\nEXPORT_SYMBOL_GPL(usb_get_maximum_speed);\n\n \nenum usb_ssp_rate usb_get_maximum_ssp_rate(struct device *dev)\n{\n\tconst char *maximum_speed;\n\tint ret;\n\n\tret = device_property_read_string(dev, \"maximum-speed\", &maximum_speed);\n\tif (ret < 0)\n\t\treturn USB_SSP_GEN_UNKNOWN;\n\n\tret = match_string(ssp_rate, ARRAY_SIZE(ssp_rate), maximum_speed);\n\treturn (ret < 0) ? USB_SSP_GEN_UNKNOWN : ret;\n}\nEXPORT_SYMBOL_GPL(usb_get_maximum_ssp_rate);\n\n \nconst char *usb_state_string(enum usb_device_state state)\n{\n\tstatic const char *const names[] = {\n\t\t[USB_STATE_NOTATTACHED] = \"not attached\",\n\t\t[USB_STATE_ATTACHED] = \"attached\",\n\t\t[USB_STATE_POWERED] = \"powered\",\n\t\t[USB_STATE_RECONNECTING] = \"reconnecting\",\n\t\t[USB_STATE_UNAUTHENTICATED] = \"unauthenticated\",\n\t\t[USB_STATE_DEFAULT] = \"default\",\n\t\t[USB_STATE_ADDRESS] = \"addressed\",\n\t\t[USB_STATE_CONFIGURED] = \"configured\",\n\t\t[USB_STATE_SUSPENDED] = \"suspended\",\n\t};\n\n\tif (state < 0 || state >= ARRAY_SIZE(names))\n\t\treturn \"UNKNOWN\";\n\n\treturn names[state];\n}\nEXPORT_SYMBOL_GPL(usb_state_string);\n\nstatic const char *const usb_dr_modes[] = {\n\t[USB_DR_MODE_UNKNOWN]\t\t= \"\",\n\t[USB_DR_MODE_HOST]\t\t= \"host\",\n\t[USB_DR_MODE_PERIPHERAL]\t= \"peripheral\",\n\t[USB_DR_MODE_OTG]\t\t= \"otg\",\n};\n\nstatic enum usb_dr_mode usb_get_dr_mode_from_string(const char *str)\n{\n\tint ret;\n\n\tret = match_string(usb_dr_modes, ARRAY_SIZE(usb_dr_modes), str);\n\treturn (ret < 0) ? USB_DR_MODE_UNKNOWN : ret;\n}\n\nenum usb_dr_mode usb_get_dr_mode(struct device *dev)\n{\n\tconst char *dr_mode;\n\tint err;\n\n\terr = device_property_read_string(dev, \"dr_mode\", &dr_mode);\n\tif (err < 0)\n\t\treturn USB_DR_MODE_UNKNOWN;\n\n\treturn usb_get_dr_mode_from_string(dr_mode);\n}\nEXPORT_SYMBOL_GPL(usb_get_dr_mode);\n\n \nenum usb_dr_mode usb_get_role_switch_default_mode(struct device *dev)\n{\n\tconst char *str;\n\tint ret;\n\n\tret = device_property_read_string(dev, \"role-switch-default-mode\", &str);\n\tif (ret < 0)\n\t\treturn USB_DR_MODE_UNKNOWN;\n\n\treturn usb_get_dr_mode_from_string(str);\n}\nEXPORT_SYMBOL_GPL(usb_get_role_switch_default_mode);\n\n \nunsigned int usb_decode_interval(const struct usb_endpoint_descriptor *epd,\n\t\t\t\t enum usb_device_speed speed)\n{\n\tunsigned int interval = 0;\n\n\tswitch (usb_endpoint_type(epd)) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t \n\t\tif (speed == USB_SPEED_HIGH)\n\t\t\tinterval = epd->bInterval;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tinterval = 1 << (epd->bInterval - 1);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\t \n\t\tif (speed == USB_SPEED_HIGH && usb_endpoint_dir_out(epd))\n\t\t\tinterval = epd->bInterval;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (speed >= USB_SPEED_HIGH)\n\t\t\tinterval = 1 << (epd->bInterval - 1);\n\t\telse\n\t\t\tinterval = epd->bInterval;\n\t\tbreak;\n\t}\n\n\tinterval *= (speed >= USB_SPEED_HIGH) ? 125 : 1000;\n\n\treturn interval;\n}\nEXPORT_SYMBOL_GPL(usb_decode_interval);\n\n#ifdef CONFIG_OF\n \nenum usb_dr_mode of_usb_get_dr_mode_by_phy(struct device_node *np, int arg0)\n{\n\tstruct device_node *controller = NULL;\n\tstruct of_phandle_args args;\n\tconst char *dr_mode;\n\tint index;\n\tint err;\n\n\tdo {\n\t\tcontroller = of_find_node_with_property(controller, \"phys\");\n\t\tif (!of_device_is_available(controller))\n\t\t\tcontinue;\n\t\tindex = 0;\n\t\tdo {\n\t\t\tif (arg0 == -1) {\n\t\t\t\targs.np = of_parse_phandle(controller, \"phys\",\n\t\t\t\t\t\t\tindex);\n\t\t\t\targs.args_count = 0;\n\t\t\t} else {\n\t\t\t\terr = of_parse_phandle_with_args(controller,\n\t\t\t\t\t\t\t\"phys\", \"#phy-cells\",\n\t\t\t\t\t\t\tindex, &args);\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tof_node_put(args.np);\n\t\t\tif (args.np == np && (args.args_count == 0 ||\n\t\t\t\t\t      args.args[0] == arg0))\n\t\t\t\tgoto finish;\n\t\t\tindex++;\n\t\t} while (args.np);\n\t} while (controller);\n\nfinish:\n\terr = of_property_read_string(controller, \"dr_mode\", &dr_mode);\n\tof_node_put(controller);\n\n\tif (err < 0)\n\t\treturn USB_DR_MODE_UNKNOWN;\n\n\treturn usb_get_dr_mode_from_string(dr_mode);\n}\nEXPORT_SYMBOL_GPL(of_usb_get_dr_mode_by_phy);\n\n \nbool of_usb_host_tpl_support(struct device_node *np)\n{\n\treturn of_property_read_bool(np, \"tpl-support\");\n}\nEXPORT_SYMBOL_GPL(of_usb_host_tpl_support);\n\n \nint of_usb_update_otg_caps(struct device_node *np,\n\t\t\tstruct usb_otg_caps *otg_caps)\n{\n\tu32 otg_rev;\n\n\tif (!otg_caps)\n\t\treturn -EINVAL;\n\n\tif (!of_property_read_u32(np, \"otg-rev\", &otg_rev)) {\n\t\tswitch (otg_rev) {\n\t\tcase 0x0100:\n\t\tcase 0x0120:\n\t\tcase 0x0130:\n\t\tcase 0x0200:\n\t\t\t \n\t\t\tif (otg_caps->otg_rev)\n\t\t\t\totg_caps->otg_rev = min_t(u16, otg_rev,\n\t\t\t\t\t\t\totg_caps->otg_rev);\n\t\t\telse\n\t\t\t\totg_caps->otg_rev = otg_rev;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_err(\"%pOF: unsupported otg-rev: 0x%x\\n\",\n\t\t\t\t\t\tnp, otg_rev);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\t \n\t\totg_caps->otg_rev = 0;\n\t}\n\n\tif (of_property_read_bool(np, \"hnp-disable\"))\n\t\totg_caps->hnp_support = false;\n\tif (of_property_read_bool(np, \"srp-disable\"))\n\t\totg_caps->srp_support = false;\n\tif (of_property_read_bool(np, \"adp-disable\") ||\n\t\t\t\t(otg_caps->otg_rev < 0x0200))\n\t\totg_caps->adp_support = false;\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(of_usb_update_otg_caps);\n\n \nstruct device *usb_of_get_companion_dev(struct device *dev)\n{\n\tstruct device_node *node;\n\tstruct platform_device *pdev = NULL;\n\n\tnode = of_parse_phandle(dev->of_node, \"companion\", 0);\n\tif (node)\n\t\tpdev = of_find_device_by_node(node);\n\n\tof_node_put(node);\n\n\treturn pdev ? &pdev->dev : NULL;\n}\nEXPORT_SYMBOL_GPL(usb_of_get_companion_dev);\n#endif\n\nstruct dentry *usb_debug_root;\nEXPORT_SYMBOL_GPL(usb_debug_root);\n\nstatic int __init usb_common_init(void)\n{\n\tusb_debug_root = debugfs_create_dir(\"usb\", NULL);\n\tledtrig_usb_init();\n\treturn 0;\n}\n\nstatic void __exit usb_common_exit(void)\n{\n\tledtrig_usb_exit();\n\tdebugfs_remove_recursive(usb_debug_root);\n}\n\nsubsys_initcall(usb_common_init);\nmodule_exit(usb_common_exit);\n\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}