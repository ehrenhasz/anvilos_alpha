{
  "module_name": "usb-conn-gpio.c",
  "hash_id": "f5d2faf7515c422e23e86a0b759df3cb54f78b614669b2c79814df37ff5e662d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/common/usb-conn-gpio.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/gpio/consumer.h>\n#include <linux/interrupt.h>\n#include <linux/irq.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/pinctrl/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/power_supply.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb/role.h>\n\n#define USB_GPIO_DEB_MS\t\t20\t \n#define USB_GPIO_DEB_US\t\t((USB_GPIO_DEB_MS) * 1000)\t \n\n#define USB_CONN_IRQF\t\\\n\t(IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING | IRQF_ONESHOT)\n\nstruct usb_conn_info {\n\tstruct device *dev;\n\tstruct usb_role_switch *role_sw;\n\tenum usb_role last_role;\n\tstruct regulator *vbus;\n\tstruct delayed_work dw_det;\n\tunsigned long debounce_jiffies;\n\n\tstruct gpio_desc *id_gpiod;\n\tstruct gpio_desc *vbus_gpiod;\n\tint id_irq;\n\tint vbus_irq;\n\n\tstruct power_supply_desc desc;\n\tstruct power_supply *charger;\n\tbool initial_detection;\n};\n\n \nstatic void usb_conn_detect_cable(struct work_struct *work)\n{\n\tstruct usb_conn_info *info;\n\tenum usb_role role;\n\tint id, vbus, ret;\n\n\tinfo = container_of(to_delayed_work(work),\n\t\t\t    struct usb_conn_info, dw_det);\n\n\t \n\tid = info->id_gpiod ?\n\t\tgpiod_get_value_cansleep(info->id_gpiod) : 1;\n\tvbus = info->vbus_gpiod ?\n\t\tgpiod_get_value_cansleep(info->vbus_gpiod) : id;\n\n\tif (!id)\n\t\trole = USB_ROLE_HOST;\n\telse if (vbus)\n\t\trole = USB_ROLE_DEVICE;\n\telse\n\t\trole = USB_ROLE_NONE;\n\n\tdev_dbg(info->dev, \"role %s -> %s, gpios: id %d, vbus %d\\n\",\n\t\tusb_role_string(info->last_role), usb_role_string(role), id, vbus);\n\n\tif (!info->initial_detection && info->last_role == role) {\n\t\tdev_warn(info->dev, \"repeated role: %s\\n\", usb_role_string(role));\n\t\treturn;\n\t}\n\n\tinfo->initial_detection = false;\n\n\tif (info->last_role == USB_ROLE_HOST && info->vbus)\n\t\tregulator_disable(info->vbus);\n\n\tret = usb_role_switch_set_role(info->role_sw, role);\n\tif (ret)\n\t\tdev_err(info->dev, \"failed to set role: %d\\n\", ret);\n\n\tif (role == USB_ROLE_HOST && info->vbus) {\n\t\tret = regulator_enable(info->vbus);\n\t\tif (ret)\n\t\t\tdev_err(info->dev, \"enable vbus regulator failed\\n\");\n\t}\n\n\tinfo->last_role = role;\n\n\tif (info->vbus)\n\t\tdev_dbg(info->dev, \"vbus regulator is %s\\n\",\n\t\t\tregulator_is_enabled(info->vbus) ? \"enabled\" : \"disabled\");\n\n\tpower_supply_changed(info->charger);\n}\n\nstatic void usb_conn_queue_dwork(struct usb_conn_info *info,\n\t\t\t\t unsigned long delay)\n{\n\tqueue_delayed_work(system_power_efficient_wq, &info->dw_det, delay);\n}\n\nstatic irqreturn_t usb_conn_isr(int irq, void *dev_id)\n{\n\tstruct usb_conn_info *info = dev_id;\n\n\tusb_conn_queue_dwork(info, info->debounce_jiffies);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic enum power_supply_property usb_charger_properties[] = {\n\tPOWER_SUPPLY_PROP_ONLINE,\n};\n\nstatic int usb_charger_get_property(struct power_supply *psy,\n\t\t\t\t    enum power_supply_property psp,\n\t\t\t\t    union power_supply_propval *val)\n{\n\tstruct usb_conn_info *info = power_supply_get_drvdata(psy);\n\n\tswitch (psp) {\n\tcase POWER_SUPPLY_PROP_ONLINE:\n\t\tval->intval = info->last_role == USB_ROLE_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int usb_conn_psy_register(struct usb_conn_info *info)\n{\n\tstruct device *dev = info->dev;\n\tstruct power_supply_desc *desc = &info->desc;\n\tstruct power_supply_config cfg = {\n\t\t.of_node = dev->of_node,\n\t};\n\n\tdesc->name = \"usb-charger\";\n\tdesc->properties = usb_charger_properties;\n\tdesc->num_properties = ARRAY_SIZE(usb_charger_properties);\n\tdesc->get_property = usb_charger_get_property;\n\tdesc->type = POWER_SUPPLY_TYPE_USB;\n\tcfg.drv_data = info;\n\n\tinfo->charger = devm_power_supply_register(dev, desc, &cfg);\n\tif (IS_ERR(info->charger))\n\t\tdev_err(dev, \"Unable to register charger\\n\");\n\n\treturn PTR_ERR_OR_ZERO(info->charger);\n}\n\nstatic int usb_conn_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_conn_info *info;\n\tint ret = 0;\n\n\tinfo = devm_kzalloc(dev, sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tinfo->dev = dev;\n\tinfo->id_gpiod = devm_gpiod_get_optional(dev, \"id\", GPIOD_IN);\n\tif (IS_ERR(info->id_gpiod))\n\t\treturn PTR_ERR(info->id_gpiod);\n\n\tinfo->vbus_gpiod = devm_gpiod_get_optional(dev, \"vbus\", GPIOD_IN);\n\tif (IS_ERR(info->vbus_gpiod))\n\t\treturn PTR_ERR(info->vbus_gpiod);\n\n\tif (!info->id_gpiod && !info->vbus_gpiod) {\n\t\tdev_err(dev, \"failed to get gpios\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tif (info->id_gpiod)\n\t\tret = gpiod_set_debounce(info->id_gpiod, USB_GPIO_DEB_US);\n\tif (!ret && info->vbus_gpiod)\n\t\tret = gpiod_set_debounce(info->vbus_gpiod, USB_GPIO_DEB_US);\n\tif (ret < 0)\n\t\tinfo->debounce_jiffies = msecs_to_jiffies(USB_GPIO_DEB_MS);\n\n\tINIT_DELAYED_WORK(&info->dw_det, usb_conn_detect_cable);\n\n\tinfo->vbus = devm_regulator_get_optional(dev, \"vbus\");\n\tif (PTR_ERR(info->vbus) == -ENODEV)\n\t\tinfo->vbus = NULL;\n\n\tif (IS_ERR(info->vbus))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->vbus), \"failed to get vbus\\n\");\n\n\tinfo->role_sw = usb_role_switch_get(dev);\n\tif (IS_ERR(info->role_sw))\n\t\treturn dev_err_probe(dev, PTR_ERR(info->role_sw),\n\t\t\t\t     \"failed to get role switch\\n\");\n\n\tret = usb_conn_psy_register(info);\n\tif (ret)\n\t\tgoto put_role_sw;\n\n\tif (info->id_gpiod) {\n\t\tinfo->id_irq = gpiod_to_irq(info->id_gpiod);\n\t\tif (info->id_irq < 0) {\n\t\t\tdev_err(dev, \"failed to get ID IRQ\\n\");\n\t\t\tret = info->id_irq;\n\t\t\tgoto put_role_sw;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, info->id_irq, NULL,\n\t\t\t\t\t\tusb_conn_isr, USB_CONN_IRQF,\n\t\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request ID IRQ\\n\");\n\t\t\tgoto put_role_sw;\n\t\t}\n\t}\n\n\tif (info->vbus_gpiod) {\n\t\tinfo->vbus_irq = gpiod_to_irq(info->vbus_gpiod);\n\t\tif (info->vbus_irq < 0) {\n\t\t\tdev_err(dev, \"failed to get VBUS IRQ\\n\");\n\t\t\tret = info->vbus_irq;\n\t\t\tgoto put_role_sw;\n\t\t}\n\n\t\tret = devm_request_threaded_irq(dev, info->vbus_irq, NULL,\n\t\t\t\t\t\tusb_conn_isr, USB_CONN_IRQF,\n\t\t\t\t\t\tpdev->name, info);\n\t\tif (ret < 0) {\n\t\t\tdev_err(dev, \"failed to request VBUS IRQ\\n\");\n\t\t\tgoto put_role_sw;\n\t\t}\n\t}\n\n\tplatform_set_drvdata(pdev, info);\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\t \n\tinfo->initial_detection = true;\n\tusb_conn_queue_dwork(info, 0);\n\n\treturn 0;\n\nput_role_sw:\n\tusb_role_switch_put(info->role_sw);\n\treturn ret;\n}\n\nstatic void usb_conn_remove(struct platform_device *pdev)\n{\n\tstruct usb_conn_info *info = platform_get_drvdata(pdev);\n\n\tcancel_delayed_work_sync(&info->dw_det);\n\n\tif (info->last_role == USB_ROLE_HOST && info->vbus)\n\t\tregulator_disable(info->vbus);\n\n\tusb_role_switch_put(info->role_sw);\n}\n\nstatic int __maybe_unused usb_conn_suspend(struct device *dev)\n{\n\tstruct usb_conn_info *info = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_gpiod)\n\t\t\tenable_irq_wake(info->id_irq);\n\t\tif (info->vbus_gpiod)\n\t\t\tenable_irq_wake(info->vbus_irq);\n\t\treturn 0;\n\t}\n\n\tif (info->id_gpiod)\n\t\tdisable_irq(info->id_irq);\n\tif (info->vbus_gpiod)\n\t\tdisable_irq(info->vbus_irq);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn 0;\n}\n\nstatic int __maybe_unused usb_conn_resume(struct device *dev)\n{\n\tstruct usb_conn_info *info = dev_get_drvdata(dev);\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (info->id_gpiod)\n\t\t\tdisable_irq_wake(info->id_irq);\n\t\tif (info->vbus_gpiod)\n\t\t\tdisable_irq_wake(info->vbus_irq);\n\t\treturn 0;\n\t}\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (info->id_gpiod)\n\t\tenable_irq(info->id_irq);\n\tif (info->vbus_gpiod)\n\t\tenable_irq(info->vbus_irq);\n\n\tusb_conn_queue_dwork(info, 0);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(usb_conn_pm_ops,\n\t\t\t usb_conn_suspend, usb_conn_resume);\n\nstatic const struct of_device_id usb_conn_dt_match[] = {\n\t{ .compatible = \"gpio-usb-b-connector\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, usb_conn_dt_match);\n\nstatic struct platform_driver usb_conn_driver = {\n\t.probe\t\t= usb_conn_probe,\n\t.remove_new\t= usb_conn_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"usb-conn-gpio\",\n\t\t.pm\t= &usb_conn_pm_ops,\n\t\t.of_match_table = usb_conn_dt_match,\n\t},\n};\n\nmodule_platform_driver(usb_conn_driver);\n\nMODULE_AUTHOR(\"Chunfeng Yun <chunfeng.yun@mediatek.com>\");\nMODULE_DESCRIPTION(\"USB GPIO based connection detection driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}