{
  "module_name": "ulpi.c",
  "hash_id": "ad83a88ec89fd1282b8fbd191f76710630852511c7343f6bfb3b46b94c286918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/common/ulpi.c",
  "human_readable_source": "\n \n\n#include <linux/ulpi/interface.h>\n#include <linux/ulpi/driver.h>\n#include <linux/ulpi/regs.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/debugfs.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/clk/clk-conf.h>\n\n \n\nint ulpi_read(struct ulpi *ulpi, u8 addr)\n{\n\treturn ulpi->ops->read(ulpi->dev.parent, addr);\n}\nEXPORT_SYMBOL_GPL(ulpi_read);\n\nint ulpi_write(struct ulpi *ulpi, u8 addr, u8 val)\n{\n\treturn ulpi->ops->write(ulpi->dev.parent, addr, val);\n}\nEXPORT_SYMBOL_GPL(ulpi_write);\n\n \n\nstatic int ulpi_match(struct device *dev, struct device_driver *driver)\n{\n\tstruct ulpi_driver *drv = to_ulpi_driver(driver);\n\tstruct ulpi *ulpi = to_ulpi_dev(dev);\n\tconst struct ulpi_device_id *id;\n\n\t \n\tif (ulpi->id.vendor == 0 || !drv->id_table)\n\t\treturn of_driver_match_device(dev, driver);\n\n\tfor (id = drv->id_table; id->vendor; id++)\n\t\tif (id->vendor == ulpi->id.vendor &&\n\t\t    id->product == ulpi->id.product)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ulpi_uevent(const struct device *dev, struct kobj_uevent_env *env)\n{\n\tconst struct ulpi *ulpi = to_ulpi_dev(dev);\n\tint ret;\n\n\tret = of_device_uevent_modalias(dev, env);\n\tif (ret != -ENODEV)\n\t\treturn ret;\n\n\tif (add_uevent_var(env, \"MODALIAS=ulpi:v%04xp%04x\",\n\t\t\t   ulpi->id.vendor, ulpi->id.product))\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic int ulpi_probe(struct device *dev)\n{\n\tstruct ulpi_driver *drv = to_ulpi_driver(dev->driver);\n\tint ret;\n\n\tret = of_clk_set_defaults(dev->of_node, false);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn drv->probe(to_ulpi_dev(dev));\n}\n\nstatic void ulpi_remove(struct device *dev)\n{\n\tstruct ulpi_driver *drv = to_ulpi_driver(dev->driver);\n\n\tif (drv->remove)\n\t\tdrv->remove(to_ulpi_dev(dev));\n}\n\nstatic const struct bus_type ulpi_bus = {\n\t.name = \"ulpi\",\n\t.match = ulpi_match,\n\t.uevent = ulpi_uevent,\n\t.probe = ulpi_probe,\n\t.remove = ulpi_remove,\n};\n\n \n\nstatic ssize_t modalias_show(struct device *dev, struct device_attribute *attr,\n\t\t\t     char *buf)\n{\n\tint len;\n\tstruct ulpi *ulpi = to_ulpi_dev(dev);\n\n\tlen = of_device_modalias(dev, buf, PAGE_SIZE);\n\tif (len != -ENODEV)\n\t\treturn len;\n\n\treturn sprintf(buf, \"ulpi:v%04xp%04x\\n\",\n\t\t       ulpi->id.vendor, ulpi->id.product);\n}\nstatic DEVICE_ATTR_RO(modalias);\n\nstatic struct attribute *ulpi_dev_attrs[] = {\n\t&dev_attr_modalias.attr,\n\tNULL\n};\n\nstatic const struct attribute_group ulpi_dev_attr_group = {\n\t.attrs = ulpi_dev_attrs,\n};\n\nstatic const struct attribute_group *ulpi_dev_attr_groups[] = {\n\t&ulpi_dev_attr_group,\n\tNULL\n};\n\nstatic void ulpi_dev_release(struct device *dev)\n{\n\tof_node_put(dev->of_node);\n\tkfree(to_ulpi_dev(dev));\n}\n\nstatic const struct device_type ulpi_dev_type = {\n\t.name = \"ulpi_device\",\n\t.groups = ulpi_dev_attr_groups,\n\t.release = ulpi_dev_release,\n};\n\n \n\n \nint __ulpi_register_driver(struct ulpi_driver *drv, struct module *module)\n{\n\tif (!drv->probe)\n\t\treturn -EINVAL;\n\n\tdrv->driver.owner = module;\n\tdrv->driver.bus = &ulpi_bus;\n\n\treturn driver_register(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(__ulpi_register_driver);\n\n \nvoid ulpi_unregister_driver(struct ulpi_driver *drv)\n{\n\tdriver_unregister(&drv->driver);\n}\nEXPORT_SYMBOL_GPL(ulpi_unregister_driver);\n\n \n\nstatic int ulpi_of_register(struct ulpi *ulpi)\n{\n\tstruct device_node *np = NULL, *child;\n\tstruct device *parent;\n\n\t \n\tparent = ulpi->dev.parent;\n\tif (parent->of_node)\n\t\tnp = of_get_child_by_name(parent->of_node, \"ulpi\");\n\telse if (parent->parent && parent->parent->of_node)\n\t\tnp = of_get_child_by_name(parent->parent->of_node, \"ulpi\");\n\tif (!np)\n\t\treturn 0;\n\n\tchild = of_get_next_available_child(np, NULL);\n\tof_node_put(np);\n\tif (!child)\n\t\treturn -EINVAL;\n\n\tulpi->dev.of_node = child;\n\n\treturn 0;\n}\n\nstatic int ulpi_read_id(struct ulpi *ulpi)\n{\n\tint ret;\n\n\t \n\tret = ulpi_write(ulpi, ULPI_SCRATCH, 0xaa);\n\tif (ret < 0)\n\t\tgoto err;\n\n\tret = ulpi_read(ulpi, ULPI_SCRATCH);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (ret != 0xaa)\n\t\tgoto err;\n\n\tulpi->id.vendor = ulpi_read(ulpi, ULPI_VENDOR_ID_LOW);\n\tulpi->id.vendor |= ulpi_read(ulpi, ULPI_VENDOR_ID_HIGH) << 8;\n\n\tulpi->id.product = ulpi_read(ulpi, ULPI_PRODUCT_ID_LOW);\n\tulpi->id.product |= ulpi_read(ulpi, ULPI_PRODUCT_ID_HIGH) << 8;\n\n\t \n\tif (ulpi->id.vendor == 0)\n\t\tgoto err;\n\n\trequest_module(\"ulpi:v%04xp%04x\", ulpi->id.vendor, ulpi->id.product);\n\treturn 0;\nerr:\n\tof_request_module(ulpi->dev.of_node);\n\treturn 0;\n}\n\nstatic int ulpi_regs_show(struct seq_file *seq, void *data)\n{\n\tstruct ulpi *ulpi = seq->private;\n\n#define ulpi_print(name, reg) do { \\\n\tint ret = ulpi_read(ulpi, reg); \\\n\tif (ret < 0) \\\n\t\treturn ret; \\\n\tseq_printf(seq, name \" %.02x\\n\", ret); \\\n} while (0)\n\n\tulpi_print(\"Vendor ID Low               \", ULPI_VENDOR_ID_LOW);\n\tulpi_print(\"Vendor ID High              \", ULPI_VENDOR_ID_HIGH);\n\tulpi_print(\"Product ID Low              \", ULPI_PRODUCT_ID_LOW);\n\tulpi_print(\"Product ID High             \", ULPI_PRODUCT_ID_HIGH);\n\tulpi_print(\"Function Control            \", ULPI_FUNC_CTRL);\n\tulpi_print(\"Interface Control           \", ULPI_IFC_CTRL);\n\tulpi_print(\"OTG Control                 \", ULPI_OTG_CTRL);\n\tulpi_print(\"USB Interrupt Enable Rising \", ULPI_USB_INT_EN_RISE);\n\tulpi_print(\"USB Interrupt Enable Falling\", ULPI_USB_INT_EN_FALL);\n\tulpi_print(\"USB Interrupt Status        \", ULPI_USB_INT_STS);\n\tulpi_print(\"USB Interrupt Latch         \", ULPI_USB_INT_LATCH);\n\tulpi_print(\"Debug                       \", ULPI_DEBUG);\n\tulpi_print(\"Scratch Register            \", ULPI_SCRATCH);\n\tulpi_print(\"Carkit Control              \", ULPI_CARKIT_CTRL);\n\tulpi_print(\"Carkit Interrupt Delay      \", ULPI_CARKIT_INT_DELAY);\n\tulpi_print(\"Carkit Interrupt Enable     \", ULPI_CARKIT_INT_EN);\n\tulpi_print(\"Carkit Interrupt Status     \", ULPI_CARKIT_INT_STS);\n\tulpi_print(\"Carkit Interrupt Latch      \", ULPI_CARKIT_INT_LATCH);\n\tulpi_print(\"Carkit Pulse Control        \", ULPI_CARKIT_PLS_CTRL);\n\tulpi_print(\"Transmit Positive Width     \", ULPI_TX_POS_WIDTH);\n\tulpi_print(\"Transmit Negative Width     \", ULPI_TX_NEG_WIDTH);\n\tulpi_print(\"Receive Polarity Recovery   \", ULPI_POLARITY_RECOVERY);\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(ulpi_regs);\n\nstatic struct dentry *ulpi_root;\n\nstatic int ulpi_register(struct device *dev, struct ulpi *ulpi)\n{\n\tint ret;\n\tstruct dentry *root;\n\n\tulpi->dev.parent = dev;  \n\tulpi->dev.bus = &ulpi_bus;\n\tulpi->dev.type = &ulpi_dev_type;\n\tdev_set_name(&ulpi->dev, \"%s.ulpi\", dev_name(dev));\n\n\tACPI_COMPANION_SET(&ulpi->dev, ACPI_COMPANION(dev));\n\n\tret = ulpi_of_register(ulpi);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ulpi_read_id(ulpi);\n\tif (ret) {\n\t\tof_node_put(ulpi->dev.of_node);\n\t\treturn ret;\n\t}\n\n\tret = device_register(&ulpi->dev);\n\tif (ret) {\n\t\tput_device(&ulpi->dev);\n\t\treturn ret;\n\t}\n\n\troot = debugfs_create_dir(dev_name(dev), ulpi_root);\n\tdebugfs_create_file(\"regs\", 0444, root, ulpi, &ulpi_regs_fops);\n\n\tdev_dbg(&ulpi->dev, \"registered ULPI PHY: vendor %04x, product %04x\\n\",\n\t\tulpi->id.vendor, ulpi->id.product);\n\n\treturn 0;\n}\n\n \nstruct ulpi *ulpi_register_interface(struct device *dev,\n\t\t\t\t     const struct ulpi_ops *ops)\n{\n\tstruct ulpi *ulpi;\n\tint ret;\n\n\tulpi = kzalloc(sizeof(*ulpi), GFP_KERNEL);\n\tif (!ulpi)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tulpi->ops = ops;\n\n\tret = ulpi_register(dev, ulpi);\n\tif (ret) {\n\t\tkfree(ulpi);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treturn ulpi;\n}\nEXPORT_SYMBOL_GPL(ulpi_register_interface);\n\n \nvoid ulpi_unregister_interface(struct ulpi *ulpi)\n{\n\tdebugfs_lookup_and_remove(dev_name(&ulpi->dev), ulpi_root);\n\tdevice_unregister(&ulpi->dev);\n}\nEXPORT_SYMBOL_GPL(ulpi_unregister_interface);\n\n \n\nstatic int __init ulpi_init(void)\n{\n\tint ret;\n\n\tulpi_root = debugfs_create_dir(KBUILD_MODNAME, NULL);\n\tret = bus_register(&ulpi_bus);\n\tif (ret)\n\t\tdebugfs_remove(ulpi_root);\n\treturn ret;\n}\nsubsys_initcall(ulpi_init);\n\nstatic void __exit ulpi_exit(void)\n{\n\tbus_unregister(&ulpi_bus);\n\tdebugfs_remove(ulpi_root);\n}\nmodule_exit(ulpi_exit);\n\nMODULE_AUTHOR(\"Intel Corporation\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_DESCRIPTION(\"USB ULPI PHY bus\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}