{
  "module_name": "fhci-hcd.c",
  "hash_id": "24c1749acfddc9a8f12ca583c2c1a5122391824be19a36b82413897f1c20469e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/fhci-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/gpio/consumer.h>\n#include <soc/fsl/qe/qe.h>\n#include <asm/fsl_gtm.h>\n#include \"fhci.h\"\n\nvoid fhci_start_sof_timer(struct fhci_hcd *fhci)\n{\n\tfhci_dbg(fhci, \"-> %s\\n\", __func__);\n\n\t \n\tout_be16(&fhci->pram->frame_num, 0);\n\n\tout_be16(&fhci->regs->usb_ussft, 0);\n\tsetbits8(&fhci->regs->usb_usmod, USB_MODE_SFTE);\n\n\tfhci_dbg(fhci, \"<- %s\\n\", __func__);\n}\n\nvoid fhci_stop_sof_timer(struct fhci_hcd *fhci)\n{\n\tfhci_dbg(fhci, \"-> %s\\n\", __func__);\n\n\tclrbits8(&fhci->regs->usb_usmod, USB_MODE_SFTE);\n\tgtm_stop_timer16(fhci->timer);\n\n\tfhci_dbg(fhci, \"<- %s\\n\", __func__);\n}\n\nu16 fhci_get_sof_timer_count(struct fhci_usb *usb)\n{\n\treturn be16_to_cpu(in_be16(&usb->fhci->regs->usb_ussft) / 12);\n}\n\n \nstatic u32 endpoint_zero_init(struct fhci_usb *usb,\n\t\t\t      enum fhci_mem_alloc data_mem,\n\t\t\t      u32 ring_len)\n{\n\tu32 rc;\n\n\trc = fhci_create_ep(usb, data_mem, ring_len);\n\tif (rc)\n\t\treturn rc;\n\n\t \n\tfhci_init_ep_registers(usb, usb->ep0, data_mem);\n\n\treturn 0;\n}\n\n \nvoid fhci_usb_enable_interrupt(struct fhci_usb *usb)\n{\n\tstruct fhci_hcd *fhci = usb->fhci;\n\n\tif (usb->intr_nesting_cnt == 1) {\n\t\t \n\t\tenable_irq(fhci_to_hcd(fhci)->irq);\n\n\t\t \n\t\tout_be16(&usb->fhci->regs->usb_usber, 0xffff);\n\t\tout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\n\n\t\t \n\t\tenable_irq(fhci->timer->irq);\n\t} else if (usb->intr_nesting_cnt > 1)\n\t\tfhci_info(fhci, \"unbalanced USB interrupts nesting\\n\");\n\tusb->intr_nesting_cnt--;\n}\n\n \nvoid fhci_usb_disable_interrupt(struct fhci_usb *usb)\n{\n\tstruct fhci_hcd *fhci = usb->fhci;\n\n\tif (usb->intr_nesting_cnt == 0) {\n\t\t \n\t\tdisable_irq_nosync(fhci->timer->irq);\n\n\t\t \n\t\tdisable_irq_nosync(fhci_to_hcd(fhci)->irq);\n\t\tout_be16(&usb->fhci->regs->usb_usbmr, 0);\n\t}\n\tusb->intr_nesting_cnt++;\n}\n\n \nstatic u32 fhci_usb_enable(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tout_be16(&usb->fhci->regs->usb_usber, 0xffff);\n\tout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\n\tsetbits8(&usb->fhci->regs->usb_usmod, USB_MODE_EN);\n\n\tmdelay(100);\n\n\treturn 0;\n}\n\n \nstatic u32 fhci_usb_disable(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tfhci_usb_disable_interrupt(usb);\n\tfhci_port_disable(fhci);\n\n\t \n\tif (usb->port_status == FHCI_PORT_FULL ||\n\t\t\tusb->port_status == FHCI_PORT_LOW)\n\t\tfhci_device_disconnected_interrupt(fhci);\n\n\tclrbits8(&usb->fhci->regs->usb_usmod, USB_MODE_EN);\n\n\treturn 0;\n}\n\n \nint fhci_ioports_check_bus_state(struct fhci_hcd *fhci)\n{\n\tu8 bits = 0;\n\n\t \n\tif (!gpiod_get_value(fhci->gpiods[GPIO_USBOE]))\n\t\treturn -1;\n\n\t \n\tif (gpiod_get_value(fhci->gpiods[GPIO_USBRP]))\n\t\tbits |= 0x2;\n\n\t \n\tif (gpiod_get_value(fhci->gpiods[GPIO_USBRN]))\n\t\tbits |= 0x1;\n\n\treturn bits;\n}\n\nstatic void fhci_mem_free(struct fhci_hcd *fhci)\n{\n\tstruct ed *ed;\n\tstruct ed *next_ed;\n\tstruct td *td;\n\tstruct td *next_td;\n\n\tlist_for_each_entry_safe(ed, next_ed, &fhci->empty_eds, node) {\n\t\tlist_del(&ed->node);\n\t\tkfree(ed);\n\t}\n\n\tlist_for_each_entry_safe(td, next_td, &fhci->empty_tds, node) {\n\t\tlist_del(&td->node);\n\t\tkfree(td);\n\t}\n\n\tkfree(fhci->vroot_hub);\n\tfhci->vroot_hub = NULL;\n\n\tkfree(fhci->hc_list);\n\tfhci->hc_list = NULL;\n}\n\nstatic int fhci_mem_init(struct fhci_hcd *fhci)\n{\n\tint i;\n\n\tfhci->hc_list = kzalloc(sizeof(*fhci->hc_list), GFP_KERNEL);\n\tif (!fhci->hc_list)\n\t\tgoto err;\n\n\tINIT_LIST_HEAD(&fhci->hc_list->ctrl_list);\n\tINIT_LIST_HEAD(&fhci->hc_list->bulk_list);\n\tINIT_LIST_HEAD(&fhci->hc_list->iso_list);\n\tINIT_LIST_HEAD(&fhci->hc_list->intr_list);\n\tINIT_LIST_HEAD(&fhci->hc_list->done_list);\n\n\tfhci->vroot_hub = kzalloc(sizeof(*fhci->vroot_hub), GFP_KERNEL);\n\tif (!fhci->vroot_hub)\n\t\tgoto err;\n\n\tINIT_LIST_HEAD(&fhci->empty_eds);\n\tINIT_LIST_HEAD(&fhci->empty_tds);\n\n\t \n\tfhci_tasklet.data = (unsigned long)fhci;\n\tfhci->process_done_task = &fhci_tasklet;\n\n\tfor (i = 0; i < MAX_TDS; i++) {\n\t\tstruct td *td;\n\n\t\ttd = kmalloc(sizeof(*td), GFP_KERNEL);\n\t\tif (!td)\n\t\t\tgoto err;\n\t\tfhci_recycle_empty_td(fhci, td);\n\t}\n\tfor (i = 0; i < MAX_EDS; i++) {\n\t\tstruct ed *ed;\n\n\t\ted = kmalloc(sizeof(*ed), GFP_KERNEL);\n\t\tif (!ed)\n\t\t\tgoto err;\n\t\tfhci_recycle_empty_ed(fhci, ed);\n\t}\n\n\tfhci->active_urbs = 0;\n\treturn 0;\nerr:\n\tfhci_mem_free(fhci);\n\treturn -ENOMEM;\n}\n\n \nstatic void fhci_usb_free(void *lld)\n{\n\tstruct fhci_usb *usb = lld;\n\tstruct fhci_hcd *fhci;\n\n\tif (usb) {\n\t\tfhci = usb->fhci;\n\t\tfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\n\t\tfhci_ep0_free(usb);\n\t\tkfree(usb->actual_frame);\n\t\tkfree(usb);\n\t}\n}\n\n \nstatic int fhci_usb_init(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tmemset_io(usb->fhci->pram, 0, FHCI_PRAM_SIZE);\n\n\tusb->port_status = FHCI_PORT_DISABLED;\n\tusb->max_frame_usage = FRAME_TIME_USAGE;\n\tusb->sw_transaction_time = SW_FIX_TIME_BETWEEN_TRANSACTION;\n\n\tusb->actual_frame = kzalloc(sizeof(*usb->actual_frame), GFP_KERNEL);\n\tif (!usb->actual_frame) {\n\t\tfhci_usb_free(usb);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&usb->actual_frame->tds_list);\n\n\t \n\tout_be16(&fhci->pram->frame_num, 0);\n\n\t \n\tout_be32(&fhci->pram->rx_state, 0);\n\n\t \n\tusb->saved_msk = (USB_E_TXB_MASK |\n\t\t\t  USB_E_TXE1_MASK |\n\t\t\t  USB_E_IDLE_MASK |\n\t\t\t  USB_E_RESET_MASK | USB_E_SFT_MASK | USB_E_MSF_MASK);\n\n\tout_8(&usb->fhci->regs->usb_usmod, USB_MODE_HOST | USB_MODE_EN);\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usbmr, 0);\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usber, 0xffff);\n\n\tif (endpoint_zero_init(usb, DEFAULT_DATA_MEM, DEFAULT_RING_LEN) != 0) {\n\t\tfhci_usb_free(usb);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n \nstatic struct fhci_usb *fhci_create_lld(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb;\n\n\t \n\tusb = kzalloc(sizeof(*usb), GFP_KERNEL);\n\tif (!usb)\n\t\treturn NULL;\n\n\tusb->fhci = fhci;\n\tusb->hc_list = fhci->hc_list;\n\tusb->vroot_hub = fhci->vroot_hub;\n\n\tusb->transfer_confirm = fhci_transfer_confirm_callback;\n\n\treturn usb;\n}\n\nstatic int fhci_start(struct usb_hcd *hcd)\n{\n\tint ret;\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\n\tret = fhci_mem_init(fhci);\n\tif (ret) {\n\t\tfhci_err(fhci, \"failed to allocate memory\\n\");\n\t\tgoto err;\n\t}\n\n\tfhci->usb_lld = fhci_create_lld(fhci);\n\tif (!fhci->usb_lld) {\n\t\tfhci_err(fhci, \"low level driver config failed\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = fhci_usb_init(fhci);\n\tif (ret) {\n\t\tfhci_err(fhci, \"low level driver initialize failed\\n\");\n\t\tgoto err;\n\t}\n\n\tspin_lock_init(&fhci->lock);\n\n\t \n\tfhci->vroot_hub->dev_num = 1;\t \n\tfhci->vroot_hub->hub.wHubStatus = 0;\n\tfhci->vroot_hub->hub.wHubChange = 0;\n\tfhci->vroot_hub->port.wPortStatus = 0;\n\tfhci->vroot_hub->port.wPortChange = 0;\n\n\thcd->state = HC_STATE_RUNNING;\n\n\t \n\tfhci_usb_enable(fhci);\n\treturn 0;\nerr:\n\tfhci_mem_free(fhci);\n\treturn ret;\n}\n\nstatic void fhci_stop(struct usb_hcd *hcd)\n{\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\n\tfhci_usb_disable_interrupt(fhci->usb_lld);\n\tfhci_usb_disable(fhci);\n\n\tfhci_usb_free(fhci->usb_lld);\n\tfhci->usb_lld = NULL;\n\tfhci_mem_free(fhci);\n}\n\nstatic int fhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t    gfp_t mem_flags)\n{\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\tu32 pipe = urb->pipe;\n\tint ret;\n\tint i;\n\tint size = 0;\n\tstruct urb_priv *urb_priv;\n\tunsigned long flags;\n\n\tswitch (usb_pipetype(pipe)) {\n\tcase PIPE_CONTROL:\n\t\t \n\t\tsize = 2;\n\t\tfallthrough;\n\tcase PIPE_BULK:\n\t\t \n\t\tsize += urb->transfer_buffer_length / 4096;\n\t\t \n\t\tif ((urb->transfer_buffer_length % 4096) != 0)\n\t\t\tsize++;\n\t\t \n\t\tif (size == 0)\n\t\t\tsize++;\n\t\telse if ((urb->transfer_flags & URB_ZERO_PACKET) != 0\n\t\t\t && (urb->transfer_buffer_length\n\t\t\t     % usb_maxpacket(urb->dev, pipe)) != 0)\n\t\t\tsize++;\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tsize = urb->number_of_packets;\n\t\tif (size <= 0)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\turb->iso_frame_desc[i].actual_length = 0;\n\t\t\turb->iso_frame_desc[i].status = (u32) (-EXDEV);\n\t\t}\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tsize = 1;\n\t}\n\n\t \n\turb_priv = kzalloc(sizeof(*urb_priv), mem_flags);\n\tif (!urb_priv)\n\t\treturn -ENOMEM;\n\n\t \n\turb_priv->tds = kcalloc(size, sizeof(*urb_priv->tds), mem_flags);\n\tif (!urb_priv->tds) {\n\t\tkfree(urb_priv);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&fhci->lock, flags);\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret)\n\t\tgoto err;\n\n\t \n\turb_priv->num_of_tds = size;\n\n\turb->status = -EINPROGRESS;\n\turb->actual_length = 0;\n\turb->error_count = 0;\n\turb->hcpriv = urb_priv;\n\n\tfhci_queue_urb(fhci, urb);\nerr:\n\tif (ret) {\n\t\tkfree(urb_priv->tds);\n\t\tkfree(urb_priv);\n\t}\n\tspin_unlock_irqrestore(&fhci->lock, flags);\n\treturn ret;\n}\n\n \nstatic int fhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\tint ret = -EINVAL;\n\tunsigned long flags;\n\n\tif (!urb || !urb->dev || !urb->dev->bus)\n\t\tgoto out;\n\n\tspin_lock_irqsave(&fhci->lock, flags);\n\n\tret = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (ret)\n\t\tgoto out2;\n\n\tif (usb->port_status != FHCI_PORT_DISABLED) {\n\t\tstruct urb_priv *urb_priv;\n\n\t\t \n\t\turb_priv = urb->hcpriv;\n\n\t\tif (!urb_priv || (urb_priv->state == URB_DEL))\n\t\t\tgoto out2;\n\n\t\turb_priv->state = URB_DEL;\n\n\t\t \n\t\turb_priv->ed->state = FHCI_ED_URB_DEL;\n\t} else {\n\t\tfhci_urb_complete_free(fhci, urb);\n\t}\n\nout2:\n\tspin_unlock_irqrestore(&fhci->lock, flags);\nout:\n\treturn ret;\n}\n\nstatic void fhci_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t  struct usb_host_endpoint *ep)\n{\n\tstruct fhci_hcd *fhci;\n\tstruct ed *ed;\n\tunsigned long flags;\n\n\tfhci = hcd_to_fhci(hcd);\n\tspin_lock_irqsave(&fhci->lock, flags);\n\ted = ep->hcpriv;\n\tif (ed) {\n\t\twhile (ed->td_head != NULL) {\n\t\t\tstruct td *td = fhci_remove_td_from_ed(ed);\n\t\t\tfhci_urb_complete_free(fhci, td->urb);\n\t\t}\n\t\tfhci_recycle_empty_ed(fhci, ed);\n\t\tep->hcpriv = NULL;\n\t}\n\tspin_unlock_irqrestore(&fhci->lock, flags);\n}\n\nstatic int fhci_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\n\treturn get_frame_num(fhci);\n}\n\nstatic const struct hc_driver fhci_driver = {\n\t.description = \"fsl,usb-fhci\",\n\t.product_desc = \"FHCI HOST Controller\",\n\t.hcd_priv_size = sizeof(struct fhci_hcd),\n\n\t \n\t.irq = fhci_irq,\n\t.flags = HCD_DMA | HCD_USB11 | HCD_MEMORY,\n\n\t \n\t.start = fhci_start,\n\t.stop = fhci_stop,\n\n\t \n\t.urb_enqueue = fhci_urb_enqueue,\n\t.urb_dequeue = fhci_urb_dequeue,\n\t.endpoint_disable = fhci_endpoint_disable,\n\n\t \n\t.get_frame_number = fhci_get_frame_number,\n\n\t \n\t.hub_status_data = fhci_hub_status_data,\n\t.hub_control = fhci_hub_control,\n};\n\nstatic int of_fhci_probe(struct platform_device *ofdev)\n{\n\tstruct device *dev = &ofdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct usb_hcd *hcd;\n\tstruct fhci_hcd *fhci;\n\tstruct resource usb_regs;\n\tunsigned long pram_addr;\n\tunsigned int usb_irq;\n\tconst char *sprop;\n\tconst u32 *iprop;\n\tint size;\n\tint ret;\n\tint i;\n\tint j;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tsprop = of_get_property(node, \"mode\", NULL);\n\tif (sprop && strcmp(sprop, \"host\"))\n\t\treturn -ENODEV;\n\n\thcd = usb_create_hcd(&fhci_driver, dev, dev_name(dev));\n\tif (!hcd) {\n\t\tdev_err(dev, \"could not create hcd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tfhci = hcd_to_fhci(hcd);\n\thcd->self.controller = dev;\n\tdev_set_drvdata(dev, hcd);\n\n\tiprop = of_get_property(node, \"hub-power-budget\", &size);\n\tif (iprop && size == sizeof(*iprop))\n\t\thcd->power_budget = *iprop;\n\n\t \n\tret = of_address_to_resource(node, 0, &usb_regs);\n\tif (ret) {\n\t\tdev_err(dev, \"could not get regs\\n\");\n\t\tgoto err_regs;\n\t}\n\n\thcd->regs = ioremap(usb_regs.start, resource_size(&usb_regs));\n\tif (!hcd->regs) {\n\t\tdev_err(dev, \"could not ioremap regs\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_regs;\n\t}\n\tfhci->regs = hcd->regs;\n\n\t \n\tiprop = of_get_property(node, \"reg\", &size);\n\tif (!iprop || size < sizeof(*iprop) * 4) {\n\t\tdev_err(dev, \"can't get pram offset\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_pram;\n\t}\n\n\tpram_addr = cpm_muram_alloc(FHCI_PRAM_SIZE, 64);\n\tif (IS_ERR_VALUE(pram_addr)) {\n\t\tdev_err(dev, \"failed to allocate usb pram\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto err_pram;\n\t}\n\n\tqe_issue_cmd(QE_ASSIGN_PAGE_TO_DEVICE, QE_CR_SUBBLOCK_USB,\n\t\t     QE_CR_PROTOCOL_UNSPECIFIED, pram_addr);\n\tfhci->pram = cpm_muram_addr(pram_addr);\n\n\t \n\tfor (i = 0; i < NUM_GPIOS; i++) {\n\t\tif (i < GPIO_SPEED)\n\t\t\tfhci->gpiods[i] = devm_gpiod_get_index(dev,\n\t\t\t\t\tNULL, i, GPIOD_IN);\n\n\t\telse\n\t\t\tfhci->gpiods[i] = devm_gpiod_get_index_optional(dev,\n\t\t\t\t\tNULL, i, GPIOD_OUT_LOW);\n\n\t\tif (IS_ERR(fhci->gpiods[i])) {\n\t\t\tdev_err(dev, \"incorrect GPIO%d: %ld\\n\",\n\t\t\t\ti, PTR_ERR(fhci->gpiods[i]));\n\t\t\tgoto err_gpios;\n\t\t}\n\t\tif (!fhci->gpiods[i]) {\n\t\t\tdev_info(dev, \"assuming board doesn't have \"\n\t\t\t\t \"%s gpio\\n\", i == GPIO_SPEED ?\n\t\t\t\t \"speed\" : \"power\");\n\t\t}\n\t}\n\n\tfor (j = 0; j < NUM_PINS; j++) {\n\t\tfhci->pins[j] = qe_pin_request(dev, j);\n\t\tif (IS_ERR(fhci->pins[j])) {\n\t\t\tret = PTR_ERR(fhci->pins[j]);\n\t\t\tdev_err(dev, \"can't get pin %d: %d\\n\", j, ret);\n\t\t\tgoto err_pins;\n\t\t}\n\t}\n\n\t \n\tfhci->timer = gtm_get_timer16();\n\tif (IS_ERR(fhci->timer)) {\n\t\tret = PTR_ERR(fhci->timer);\n\t\tdev_err(dev, \"failed to request qe timer: %i\", ret);\n\t\tgoto err_get_timer;\n\t}\n\n\tret = request_irq(fhci->timer->irq, fhci_frame_limit_timer_irq,\n\t\t\t  0, \"qe timer (usb)\", hcd);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to request timer irq\");\n\t\tgoto err_timer_irq;\n\t}\n\n\t \n\tusb_irq = irq_of_parse_and_map(node, 0);\n\tif (!usb_irq) {\n\t\tdev_err(dev, \"could not get usb irq\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_usb_irq;\n\t}\n\n\t \n\tsprop = of_get_property(node, \"fsl,fullspeed-clock\", NULL);\n\tif (sprop) {\n\t\tfhci->fullspeed_clk = qe_clock_source(sprop);\n\t\tif (fhci->fullspeed_clk == QE_CLK_DUMMY) {\n\t\t\tdev_err(dev, \"wrong fullspeed-clock\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_clocks;\n\t\t}\n\t}\n\n\tsprop = of_get_property(node, \"fsl,lowspeed-clock\", NULL);\n\tif (sprop) {\n\t\tfhci->lowspeed_clk = qe_clock_source(sprop);\n\t\tif (fhci->lowspeed_clk == QE_CLK_DUMMY) {\n\t\t\tdev_err(dev, \"wrong lowspeed-clock\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tgoto err_clocks;\n\t\t}\n\t}\n\n\tif (fhci->fullspeed_clk == QE_CLK_NONE &&\n\t\t\tfhci->lowspeed_clk == QE_CLK_NONE) {\n\t\tdev_err(dev, \"no clocks specified\\n\");\n\t\tret = -EINVAL;\n\t\tgoto err_clocks;\n\t}\n\n\tdev_info(dev, \"at 0x%p, irq %d\\n\", hcd->regs, usb_irq);\n\n\tfhci_config_transceiver(fhci, FHCI_PORT_POWER_OFF);\n\n\t \n\tif (fhci->fullspeed_clk != QE_CLK_NONE) {\n\t\tfhci_config_transceiver(fhci, FHCI_PORT_FULL);\n\t\tqe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);\n\t} else {\n\t\tfhci_config_transceiver(fhci, FHCI_PORT_LOW);\n\t\tqe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);\n\t}\n\n\t \n\tout_be16(&fhci->regs->usb_usber, 0xffff);\n\tout_be16(&fhci->regs->usb_usbmr, 0);\n\n\tret = usb_add_hcd(hcd, usb_irq, 0);\n\tif (ret < 0)\n\t\tgoto err_add_hcd;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tfhci_dfs_create(fhci);\n\n\treturn 0;\n\nerr_add_hcd:\nerr_clocks:\n\tirq_dispose_mapping(usb_irq);\nerr_usb_irq:\n\tfree_irq(fhci->timer->irq, hcd);\nerr_timer_irq:\n\tgtm_put_timer16(fhci->timer);\nerr_get_timer:\nerr_pins:\n\twhile (--j >= 0)\n\t\tqe_pin_free(fhci->pins[j]);\nerr_gpios:\n\tcpm_muram_free(pram_addr);\nerr_pram:\n\tiounmap(hcd->regs);\nerr_regs:\n\tusb_put_hcd(hcd);\n\treturn ret;\n}\n\nstatic void fhci_remove(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\tint j;\n\n\tusb_remove_hcd(hcd);\n\tfree_irq(fhci->timer->irq, hcd);\n\tgtm_put_timer16(fhci->timer);\n\tcpm_muram_free(cpm_muram_offset(fhci->pram));\n\tfor (j = 0; j < NUM_PINS; j++)\n\t\tqe_pin_free(fhci->pins[j]);\n\tfhci_dfs_destroy(fhci);\n\tusb_put_hcd(hcd);\n}\n\nstatic void of_fhci_remove(struct platform_device *ofdev)\n{\n\tfhci_remove(&ofdev->dev);\n}\n\nstatic const struct of_device_id of_fhci_match[] = {\n\t{ .compatible = \"fsl,mpc8323-qe-usb\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, of_fhci_match);\n\nstatic struct platform_driver of_fhci_driver = {\n\t.driver = {\n\t\t.name = \"fsl,usb-fhci\",\n\t\t.of_match_table = of_fhci_match,\n\t},\n\t.probe\t\t= of_fhci_probe,\n\t.remove_new\t= of_fhci_remove,\n};\n\nmodule_platform_driver(of_fhci_driver);\n\nMODULE_DESCRIPTION(\"USB Freescale Host Controller Interface Driver\");\nMODULE_AUTHOR(\"Shlomi Gridish <gridish@freescale.com>, \"\n\t      \"Jerry Huang <Chang-Ming.Huang@freescale.com>, \"\n\t      \"Anton Vorontsov <avorontsov@ru.mvista.com>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}