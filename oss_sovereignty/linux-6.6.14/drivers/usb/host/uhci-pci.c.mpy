{
  "module_name": "uhci-pci.c",
  "hash_id": "c04741595bfbf2c54bcc4ee8a5470e3ddba59e5c01694b6e2485259f2f698254",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-pci.c",
  "human_readable_source": "\n \n\n#include \"pci-quirks.h\"\n\n \nstatic void uhci_pci_reset_hc(struct uhci_hcd *uhci)\n{\n\tuhci_reset_hc(to_pci_dev(uhci_dev(uhci)), uhci->io_addr);\n}\n\n \nstatic int uhci_pci_check_and_reset_hc(struct uhci_hcd *uhci)\n{\n\treturn uhci_check_and_reset_hc(to_pci_dev(uhci_dev(uhci)),\n\t\t\t\tuhci->io_addr);\n}\n\n \nstatic void uhci_pci_configure_hc(struct uhci_hcd *uhci)\n{\n\tstruct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));\n\n\t \n\tpci_write_config_word(pdev, USBLEGSUP, USBLEGSUP_DEFAULT);\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\tpci_write_config_byte(pdev, USBRES_INTEL, 0);\n}\n\nstatic int uhci_pci_resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)\n{\n\tint port;\n\n\tswitch (to_pci_dev(uhci_dev(uhci))->vendor) {\n\tdefault:\n\t\tbreak;\n\n\tcase PCI_VENDOR_ID_GENESYS:\n\t\t \n\t\treturn 1;\n\n\tcase PCI_VENDOR_ID_INTEL:\n\t\t \n\t\tfor (port = 0; port < uhci->rh_numports; ++port) {\n\t\t\tif (inw(uhci->io_addr + USBPORTSC1 + port * 2) &\n\t\t\t\t\tUSBPORTSC_OC)\n\t\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int uhci_pci_global_suspend_mode_is_broken(struct uhci_hcd *uhci)\n{\n\tint port;\n\tconst char *sys_info;\n\tstatic const char bad_Asus_board[] = \"A7V8X\";\n\n\t \n\tsys_info = dmi_get_system_info(DMI_BOARD_NAME);\n\tif (sys_info && !strcmp(sys_info, bad_Asus_board)) {\n\t\tfor (port = 0; port < uhci->rh_numports; ++port) {\n\t\t\tif (inw(uhci->io_addr + USBPORTSC1 + port * 2) &\n\t\t\t\t\tUSBPORTSC_CCS)\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int uhci_pci_init(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\n\tuhci->io_addr = (unsigned long) hcd->rsrc_start;\n\n\tuhci->rh_numports = uhci_count_ports(hcd);\n\n\t \n\tif (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_VIA ||\n\t\t\tto_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_ZHAOXIN)\n\t\tuhci->oc_low = 1;\n\n\t \n\tif (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_HP)\n\t\tuhci->wait_for_hp = 1;\n\n\t \n\tif (to_pci_dev(uhci_dev(uhci))->vendor == PCI_VENDOR_ID_INTEL)\n\t\tdevice_set_wakeup_capable(uhci_dev(uhci), true);\n\n\t \n\tuhci->reset_hc = uhci_pci_reset_hc;\n\tuhci->check_and_reset_hc = uhci_pci_check_and_reset_hc;\n\tuhci->configure_hc = uhci_pci_configure_hc;\n\tuhci->resume_detect_interrupts_are_broken =\n\t\tuhci_pci_resume_detect_interrupts_are_broken;\n\tuhci->global_suspend_mode_is_broken =\n\t\tuhci_pci_global_suspend_mode_is_broken;\n\n\n\t \n\tcheck_and_reset_hc(uhci);\n\treturn 0;\n}\n\n \nstatic void uhci_shutdown(struct pci_dev *pdev)\n{\n\tstruct usb_hcd *hcd = pci_get_drvdata(pdev);\n\n\tuhci_hc_died(hcd_to_uhci(hcd));\n}\n\n#ifdef CONFIG_PM\n\nstatic int uhci_pci_resume(struct usb_hcd *hcd, pm_message_t state);\n\nstatic int uhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tstruct pci_dev *pdev = to_pci_dev(uhci_dev(uhci));\n\tint rc = 0;\n\n\tdev_dbg(uhci_dev(uhci), \"%s\\n\", __func__);\n\n\tspin_lock_irq(&uhci->lock);\n\tif (!HCD_HW_ACCESSIBLE(hcd) || uhci->dead)\n\t\tgoto done_okay;\t\t \n\n\t \n\tpci_write_config_word(pdev, USBLEGSUP, 0);\n\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\t \n\tif (do_wakeup) {\n\t\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\t\tpci_write_config_byte(pdev, USBRES_INTEL,\n\t\t\t\t\tUSBPORT1EN | USBPORT2EN);\n\t}\n\ndone_okay:\n\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tspin_unlock_irq(&uhci->lock);\n\n\tsynchronize_irq(hcd->irq);\n\n\t \n\tif (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {\n\t\tuhci_pci_resume(hcd, PMSG_SUSPEND);\n\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}\n\nstatic int uhci_pci_resume(struct usb_hcd *hcd, pm_message_t msg)\n{\n\tbool hibernated = (msg.event == PM_EVENT_RESTORE);\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\n\tdev_dbg(uhci_dev(uhci), \"%s\\n\", __func__);\n\n\t \n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\tspin_lock_irq(&uhci->lock);\n\n\t \n\tif (hibernated) {\n\t\tuhci->reset_hc(uhci);\n\t\tfinish_reset(uhci);\n\t}\n\n\t \n\telse {\n\t\tcheck_and_reset_hc(uhci);\n\t}\n\tconfigure_hc(uhci);\n\n\t \n\tif (uhci->rh_state == UHCI_RH_RESET)\n\t\tusb_root_hub_lost_power(hcd->self.root_hub);\n\n\tspin_unlock_irq(&uhci->lock);\n\n\t \n\tif (!uhci->RD_enable && hcd->self.root_hub->do_remote_wakeup)\n\t\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\t \n\tusb_hcd_poll_rh_status(hcd);\n\treturn 0;\n}\n\n#endif\n\nstatic const struct hc_driver uhci_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"UHCI Host Controller\",\n\t.hcd_priv_size =\tsizeof(struct uhci_hcd),\n\n\t \n\t.irq =\t\t\tuhci_irq,\n\t.flags =\t\tHCD_DMA | HCD_USB11,\n\n\t \n\t.reset =\t\tuhci_pci_init,\n\t.start =\t\tuhci_start,\n#ifdef CONFIG_PM\n\t.pci_suspend =\t\tuhci_pci_suspend,\n\t.pci_resume =\t\tuhci_pci_resume,\n\t.bus_suspend =\t\tuhci_rh_suspend,\n\t.bus_resume =\t\tuhci_rh_resume,\n#endif\n\t.stop =\t\t\tuhci_stop,\n\n\t.urb_enqueue =\t\tuhci_urb_enqueue,\n\t.urb_dequeue =\t\tuhci_urb_dequeue,\n\n\t.endpoint_disable =\tuhci_hcd_endpoint_disable,\n\t.get_frame_number =\tuhci_hcd_get_frame_number,\n\n\t.hub_status_data =\tuhci_hub_status_data,\n\t.hub_control =\t\tuhci_hub_control,\n};\n\nstatic const struct pci_device_id uhci_pci_ids[] = { {\n\t \n\tPCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_UHCI, ~0),\n\t}, {   }\n};\n\nMODULE_DEVICE_TABLE(pci, uhci_pci_ids);\n\nstatic int uhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\treturn usb_hcd_pci_probe(dev, &uhci_driver);\n}\n\nstatic struct pci_driver uhci_pci_driver = {\n\t.name =\t\thcd_name,\n\t.id_table =\tuhci_pci_ids,\n\n\t.probe =\tuhci_pci_probe,\n\t.remove =\tusb_hcd_pci_remove,\n\t.shutdown =\tuhci_shutdown,\n\n#ifdef CONFIG_PM\n\t.driver =\t{\n\t\t.pm =\t&usb_hcd_pci_pm_ops\n\t},\n#endif\n};\n\nMODULE_SOFTDEP(\"pre: ehci_pci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}