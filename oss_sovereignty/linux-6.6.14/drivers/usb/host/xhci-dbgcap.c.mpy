{
  "module_name": "xhci-dbgcap.c",
  "hash_id": "f7836fb45ae8b82277f34052b7d1dac5eb8cf4fad09b1f209c349a1e08f00d20",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-dbgcap.c",
  "human_readable_source": "\n \n#include <linux/dma-mapping.h>\n#include <linux/slab.h>\n#include <linux/nls.h>\n\n#include \"xhci.h\"\n#include \"xhci-trace.h\"\n#include \"xhci-dbgcap.h\"\n\nstatic void dbc_free_ctx(struct device *dev, struct xhci_container_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\tdma_free_coherent(dev, ctx->size, ctx->bytes, ctx->dma);\n\tkfree(ctx);\n}\n\n \nstatic void dbc_ring_free(struct device *dev, struct xhci_ring *ring)\n{\n\tif (!ring)\n\t\treturn;\n\n\tif (ring->first_seg && ring->first_seg->trbs) {\n\t\tdma_free_coherent(dev, TRB_SEGMENT_SIZE,\n\t\t\t\t  ring->first_seg->trbs,\n\t\t\t\t  ring->first_seg->dma);\n\t\tkfree(ring->first_seg);\n\t}\n\tkfree(ring);\n}\n\nstatic u32 xhci_dbc_populate_strings(struct dbc_str_descs *strings)\n{\n\tstruct usb_string_descriptor\t*s_desc;\n\tu32\t\t\t\tstring_length;\n\n\t \n\ts_desc = (struct usb_string_descriptor *)strings->serial;\n\tutf8s_to_utf16s(DBC_STRING_SERIAL, strlen(DBC_STRING_SERIAL),\n\t\t\tUTF16_LITTLE_ENDIAN, (wchar_t *)s_desc->wData,\n\t\t\tDBC_MAX_STRING_LENGTH);\n\n\ts_desc->bLength\t\t= (strlen(DBC_STRING_SERIAL) + 1) * 2;\n\ts_desc->bDescriptorType\t= USB_DT_STRING;\n\tstring_length\t\t= s_desc->bLength;\n\tstring_length\t\t<<= 8;\n\n\t \n\ts_desc = (struct usb_string_descriptor *)strings->product;\n\tutf8s_to_utf16s(DBC_STRING_PRODUCT, strlen(DBC_STRING_PRODUCT),\n\t\t\tUTF16_LITTLE_ENDIAN, (wchar_t *)s_desc->wData,\n\t\t\tDBC_MAX_STRING_LENGTH);\n\n\ts_desc->bLength\t\t= (strlen(DBC_STRING_PRODUCT) + 1) * 2;\n\ts_desc->bDescriptorType\t= USB_DT_STRING;\n\tstring_length\t\t+= s_desc->bLength;\n\tstring_length\t\t<<= 8;\n\n\t \n\ts_desc = (struct usb_string_descriptor *)strings->manufacturer;\n\tutf8s_to_utf16s(DBC_STRING_MANUFACTURER,\n\t\t\tstrlen(DBC_STRING_MANUFACTURER),\n\t\t\tUTF16_LITTLE_ENDIAN, (wchar_t *)s_desc->wData,\n\t\t\tDBC_MAX_STRING_LENGTH);\n\n\ts_desc->bLength\t\t= (strlen(DBC_STRING_MANUFACTURER) + 1) * 2;\n\ts_desc->bDescriptorType\t= USB_DT_STRING;\n\tstring_length\t\t+= s_desc->bLength;\n\tstring_length\t\t<<= 8;\n\n\t \n\tstrings->string0[0]\t= 4;\n\tstrings->string0[1]\t= USB_DT_STRING;\n\tstrings->string0[2]\t= 0x09;\n\tstrings->string0[3]\t= 0x04;\n\tstring_length\t\t+= 4;\n\n\treturn string_length;\n}\n\nstatic void xhci_dbc_init_contexts(struct xhci_dbc *dbc, u32 string_length)\n{\n\tstruct dbc_info_context\t*info;\n\tstruct xhci_ep_ctx\t*ep_ctx;\n\tu32\t\t\tdev_info;\n\tdma_addr_t\t\tdeq, dma;\n\tunsigned int\t\tmax_burst;\n\n\tif (!dbc)\n\t\treturn;\n\n\t \n\tinfo\t\t\t= (struct dbc_info_context *)dbc->ctx->bytes;\n\tdma\t\t\t= dbc->string_dma;\n\tinfo->string0\t\t= cpu_to_le64(dma);\n\tinfo->manufacturer\t= cpu_to_le64(dma + DBC_MAX_STRING_LENGTH);\n\tinfo->product\t\t= cpu_to_le64(dma + DBC_MAX_STRING_LENGTH * 2);\n\tinfo->serial\t\t= cpu_to_le64(dma + DBC_MAX_STRING_LENGTH * 3);\n\tinfo->length\t\t= cpu_to_le32(string_length);\n\n\t \n\tep_ctx\t\t\t= dbc_bulkout_ctx(dbc);\n\tmax_burst\t\t= DBC_CTRL_MAXBURST(readl(&dbc->regs->control));\n\tdeq\t\t\t= dbc_bulkout_enq(dbc);\n\tep_ctx->ep_info\t\t= 0;\n\tep_ctx->ep_info2\t= dbc_epctx_info2(BULK_OUT_EP, 1024, max_burst);\n\tep_ctx->deq\t\t= cpu_to_le64(deq | dbc->ring_out->cycle_state);\n\n\t \n\tep_ctx\t\t\t= dbc_bulkin_ctx(dbc);\n\tdeq\t\t\t= dbc_bulkin_enq(dbc);\n\tep_ctx->ep_info\t\t= 0;\n\tep_ctx->ep_info2\t= dbc_epctx_info2(BULK_IN_EP, 1024, max_burst);\n\tep_ctx->deq\t\t= cpu_to_le64(deq | dbc->ring_in->cycle_state);\n\n\t \n\tlo_hi_writeq(dbc->ctx->dma, &dbc->regs->dccp);\n\n\tdev_info = (dbc->idVendor << 16) | dbc->bInterfaceProtocol;\n\twritel(dev_info, &dbc->regs->devinfo1);\n\n\tdev_info = (dbc->bcdDevice << 16) | dbc->idProduct;\n\twritel(dev_info, &dbc->regs->devinfo2);\n}\n\nstatic void xhci_dbc_giveback(struct dbc_request *req, int status)\n\t__releases(&dbc->lock)\n\t__acquires(&dbc->lock)\n{\n\tstruct xhci_dbc\t\t*dbc = req->dbc;\n\tstruct device\t\t*dev = dbc->dev;\n\n\tlist_del_init(&req->list_pending);\n\treq->trb_dma = 0;\n\treq->trb = NULL;\n\n\tif (req->status == -EINPROGRESS)\n\t\treq->status = status;\n\n\ttrace_xhci_dbc_giveback_request(req);\n\n\tdma_unmap_single(dev,\n\t\t\t req->dma,\n\t\t\t req->length,\n\t\t\t dbc_ep_dma_direction(req));\n\n\t \n\tspin_unlock(&dbc->lock);\n\treq->complete(dbc, req);\n\tspin_lock(&dbc->lock);\n}\n\nstatic void xhci_dbc_flush_single_request(struct dbc_request *req)\n{\n\tunion xhci_trb\t*trb = req->trb;\n\n\ttrb->generic.field[0]\t= 0;\n\ttrb->generic.field[1]\t= 0;\n\ttrb->generic.field[2]\t= 0;\n\ttrb->generic.field[3]\t&= cpu_to_le32(TRB_CYCLE);\n\ttrb->generic.field[3]\t|= cpu_to_le32(TRB_TYPE(TRB_TR_NOOP));\n\n\txhci_dbc_giveback(req, -ESHUTDOWN);\n}\n\nstatic void xhci_dbc_flush_endpoint_requests(struct dbc_ep *dep)\n{\n\tstruct dbc_request\t*req, *tmp;\n\n\tlist_for_each_entry_safe(req, tmp, &dep->list_pending, list_pending)\n\t\txhci_dbc_flush_single_request(req);\n}\n\nstatic void xhci_dbc_flush_requests(struct xhci_dbc *dbc)\n{\n\txhci_dbc_flush_endpoint_requests(&dbc->eps[BULK_OUT]);\n\txhci_dbc_flush_endpoint_requests(&dbc->eps[BULK_IN]);\n}\n\nstruct dbc_request *\ndbc_alloc_request(struct xhci_dbc *dbc, unsigned int direction, gfp_t flags)\n{\n\tstruct dbc_request\t*req;\n\n\tif (direction != BULK_IN &&\n\t    direction != BULK_OUT)\n\t\treturn NULL;\n\n\tif (!dbc)\n\t\treturn NULL;\n\n\treq = kzalloc(sizeof(*req), flags);\n\tif (!req)\n\t\treturn NULL;\n\n\treq->dbc = dbc;\n\tINIT_LIST_HEAD(&req->list_pending);\n\tINIT_LIST_HEAD(&req->list_pool);\n\treq->direction = direction;\n\n\ttrace_xhci_dbc_alloc_request(req);\n\n\treturn req;\n}\n\nvoid\ndbc_free_request(struct dbc_request *req)\n{\n\ttrace_xhci_dbc_free_request(req);\n\n\tkfree(req);\n}\n\nstatic void\nxhci_dbc_queue_trb(struct xhci_ring *ring, u32 field1,\n\t\t   u32 field2, u32 field3, u32 field4)\n{\n\tunion xhci_trb\t\t*trb, *next;\n\n\ttrb = ring->enqueue;\n\ttrb->generic.field[0]\t= cpu_to_le32(field1);\n\ttrb->generic.field[1]\t= cpu_to_le32(field2);\n\ttrb->generic.field[2]\t= cpu_to_le32(field3);\n\ttrb->generic.field[3]\t= cpu_to_le32(field4);\n\n\ttrace_xhci_dbc_gadget_ep_queue(ring, &trb->generic);\n\n\tring->num_trbs_free--;\n\tnext = ++(ring->enqueue);\n\tif (TRB_TYPE_LINK_LE32(next->link.control)) {\n\t\tnext->link.control ^= cpu_to_le32(TRB_CYCLE);\n\t\tring->enqueue = ring->enq_seg->trbs;\n\t\tring->cycle_state ^= 1;\n\t}\n}\n\nstatic int xhci_dbc_queue_bulk_tx(struct dbc_ep *dep,\n\t\t\t\t  struct dbc_request *req)\n{\n\tu64\t\t\taddr;\n\tunion xhci_trb\t\t*trb;\n\tunsigned int\t\tnum_trbs;\n\tstruct xhci_dbc\t\t*dbc = req->dbc;\n\tstruct xhci_ring\t*ring = dep->ring;\n\tu32\t\t\tlength, control, cycle;\n\n\tnum_trbs = count_trbs(req->dma, req->length);\n\tWARN_ON(num_trbs != 1);\n\tif (ring->num_trbs_free < num_trbs)\n\t\treturn -EBUSY;\n\n\taddr\t= req->dma;\n\ttrb\t= ring->enqueue;\n\tcycle\t= ring->cycle_state;\n\tlength\t= TRB_LEN(req->length);\n\tcontrol\t= TRB_TYPE(TRB_NORMAL) | TRB_IOC;\n\n\tif (cycle)\n\t\tcontrol &= cpu_to_le32(~TRB_CYCLE);\n\telse\n\t\tcontrol |= cpu_to_le32(TRB_CYCLE);\n\n\treq->trb = ring->enqueue;\n\treq->trb_dma = xhci_trb_virt_to_dma(ring->enq_seg, ring->enqueue);\n\txhci_dbc_queue_trb(ring,\n\t\t\t   lower_32_bits(addr),\n\t\t\t   upper_32_bits(addr),\n\t\t\t   length, control);\n\n\t \n\twmb();\n\n\tif (cycle)\n\t\ttrb->generic.field[3] |= cpu_to_le32(TRB_CYCLE);\n\telse\n\t\ttrb->generic.field[3] &= cpu_to_le32(~TRB_CYCLE);\n\n\twritel(DBC_DOOR_BELL_TARGET(dep->direction), &dbc->regs->doorbell);\n\n\treturn 0;\n}\n\nstatic int\ndbc_ep_do_queue(struct dbc_request *req)\n{\n\tint\t\t\tret;\n\tstruct xhci_dbc\t\t*dbc = req->dbc;\n\tstruct device\t\t*dev = dbc->dev;\n\tstruct dbc_ep\t\t*dep = &dbc->eps[req->direction];\n\n\tif (!req->length || !req->buf)\n\t\treturn -EINVAL;\n\n\treq->actual\t\t= 0;\n\treq->status\t\t= -EINPROGRESS;\n\n\treq->dma = dma_map_single(dev,\n\t\t\t\t  req->buf,\n\t\t\t\t  req->length,\n\t\t\t\t  dbc_ep_dma_direction(dep));\n\tif (dma_mapping_error(dev, req->dma)) {\n\t\tdev_err(dbc->dev, \"failed to map buffer\\n\");\n\t\treturn -EFAULT;\n\t}\n\n\tret = xhci_dbc_queue_bulk_tx(dep, req);\n\tif (ret) {\n\t\tdev_err(dbc->dev, \"failed to queue trbs\\n\");\n\t\tdma_unmap_single(dev,\n\t\t\t\t req->dma,\n\t\t\t\t req->length,\n\t\t\t\t dbc_ep_dma_direction(dep));\n\t\treturn -EFAULT;\n\t}\n\n\tlist_add_tail(&req->list_pending, &dep->list_pending);\n\n\treturn 0;\n}\n\nint dbc_ep_queue(struct dbc_request *req)\n{\n\tunsigned long\t\tflags;\n\tstruct xhci_dbc\t\t*dbc = req->dbc;\n\tint\t\t\tret = -ESHUTDOWN;\n\n\tif (!dbc)\n\t\treturn -ENODEV;\n\n\tif (req->direction != BULK_IN &&\n\t    req->direction != BULK_OUT)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&dbc->lock, flags);\n\tif (dbc->state == DS_CONFIGURED)\n\t\tret = dbc_ep_do_queue(req);\n\tspin_unlock_irqrestore(&dbc->lock, flags);\n\n\tmod_delayed_work(system_wq, &dbc->event_work, 0);\n\n\ttrace_xhci_dbc_queue_request(req);\n\n\treturn ret;\n}\n\nstatic inline void xhci_dbc_do_eps_init(struct xhci_dbc *dbc, bool direction)\n{\n\tstruct dbc_ep\t\t*dep;\n\n\tdep\t\t\t= &dbc->eps[direction];\n\tdep->dbc\t\t= dbc;\n\tdep->direction\t\t= direction;\n\tdep->ring\t\t= direction ? dbc->ring_in : dbc->ring_out;\n\n\tINIT_LIST_HEAD(&dep->list_pending);\n}\n\nstatic void xhci_dbc_eps_init(struct xhci_dbc *dbc)\n{\n\txhci_dbc_do_eps_init(dbc, BULK_OUT);\n\txhci_dbc_do_eps_init(dbc, BULK_IN);\n}\n\nstatic void xhci_dbc_eps_exit(struct xhci_dbc *dbc)\n{\n\tmemset(dbc->eps, 0, sizeof(struct dbc_ep) * ARRAY_SIZE(dbc->eps));\n}\n\nstatic int dbc_erst_alloc(struct device *dev, struct xhci_ring *evt_ring,\n\t\t    struct xhci_erst *erst, gfp_t flags)\n{\n\terst->entries = dma_alloc_coherent(dev, sizeof(struct xhci_erst_entry),\n\t\t\t\t\t   &erst->erst_dma_addr, flags);\n\tif (!erst->entries)\n\t\treturn -ENOMEM;\n\n\terst->num_entries = 1;\n\terst->entries[0].seg_addr = cpu_to_le64(evt_ring->first_seg->dma);\n\terst->entries[0].seg_size = cpu_to_le32(TRBS_PER_SEGMENT);\n\terst->entries[0].rsvd = 0;\n\treturn 0;\n}\n\nstatic void dbc_erst_free(struct device *dev, struct xhci_erst *erst)\n{\n\tif (erst->entries)\n\t\tdma_free_coherent(dev, sizeof(struct xhci_erst_entry),\n\t\t\t\t  erst->entries, erst->erst_dma_addr);\n\terst->entries = NULL;\n}\n\nstatic struct xhci_container_ctx *\ndbc_alloc_ctx(struct device *dev, gfp_t flags)\n{\n\tstruct xhci_container_ctx *ctx;\n\n\tctx = kzalloc(sizeof(*ctx), flags);\n\tif (!ctx)\n\t\treturn NULL;\n\n\t \n\tctx->size = 3 * DBC_CONTEXT_SIZE;\n\tctx->bytes = dma_alloc_coherent(dev, ctx->size, &ctx->dma, flags);\n\tif (!ctx->bytes) {\n\t\tkfree(ctx);\n\t\treturn NULL;\n\t}\n\treturn ctx;\n}\n\nstatic struct xhci_ring *\nxhci_dbc_ring_alloc(struct device *dev, enum xhci_ring_type type, gfp_t flags)\n{\n\tstruct xhci_ring *ring;\n\tstruct xhci_segment *seg;\n\tdma_addr_t dma;\n\n\tring = kzalloc(sizeof(*ring), flags);\n\tif (!ring)\n\t\treturn NULL;\n\n\tring->num_segs = 1;\n\tring->type = type;\n\n\tseg = kzalloc(sizeof(*seg), flags);\n\tif (!seg)\n\t\tgoto seg_fail;\n\n\tring->first_seg = seg;\n\tring->last_seg = seg;\n\tseg->next = seg;\n\n\tseg->trbs = dma_alloc_coherent(dev, TRB_SEGMENT_SIZE, &dma, flags);\n\tif (!seg->trbs)\n\t\tgoto dma_fail;\n\n\tseg->dma = dma;\n\n\t \n\tif (type != TYPE_EVENT) {\n\t\tunion xhci_trb *trb = &seg->trbs[TRBS_PER_SEGMENT - 1];\n\n\t\ttrb->link.segment_ptr = cpu_to_le64(dma);\n\t\ttrb->link.control = cpu_to_le32(LINK_TOGGLE | TRB_TYPE(TRB_LINK));\n\t}\n\tINIT_LIST_HEAD(&ring->td_list);\n\txhci_initialize_ring_info(ring, 1);\n\treturn ring;\ndma_fail:\n\tkfree(seg);\nseg_fail:\n\tkfree(ring);\n\treturn NULL;\n}\n\nstatic int xhci_dbc_mem_init(struct xhci_dbc *dbc, gfp_t flags)\n{\n\tint\t\t\tret;\n\tdma_addr_t\t\tdeq;\n\tu32\t\t\tstring_length;\n\tstruct device\t\t*dev = dbc->dev;\n\n\t \n\tdbc->ring_evt = xhci_dbc_ring_alloc(dev, TYPE_EVENT, flags);\n\tif (!dbc->ring_evt)\n\t\tgoto evt_fail;\n\n\tdbc->ring_in = xhci_dbc_ring_alloc(dev, TYPE_BULK, flags);\n\tif (!dbc->ring_in)\n\t\tgoto in_fail;\n\n\tdbc->ring_out = xhci_dbc_ring_alloc(dev, TYPE_BULK, flags);\n\tif (!dbc->ring_out)\n\t\tgoto out_fail;\n\n\t \n\tret = dbc_erst_alloc(dev, dbc->ring_evt, &dbc->erst, flags);\n\tif (ret)\n\t\tgoto erst_fail;\n\n\t \n\tdbc->ctx = dbc_alloc_ctx(dev, flags);  \n\tif (!dbc->ctx)\n\t\tgoto ctx_fail;\n\n\t \n\tdbc->string_size = sizeof(struct dbc_str_descs);\n\tdbc->string = dma_alloc_coherent(dev, dbc->string_size,\n\t\t\t\t\t &dbc->string_dma, flags);\n\tif (!dbc->string)\n\t\tgoto string_fail;\n\n\t \n\twritel(dbc->erst.erst_size, &dbc->regs->ersts);\n\n\tlo_hi_writeq(dbc->erst.erst_dma_addr, &dbc->regs->erstba);\n\tdeq = xhci_trb_virt_to_dma(dbc->ring_evt->deq_seg,\n\t\t\t\t   dbc->ring_evt->dequeue);\n\tlo_hi_writeq(deq, &dbc->regs->erdp);\n\n\t \n\tstring_length = xhci_dbc_populate_strings(dbc->string);\n\txhci_dbc_init_contexts(dbc, string_length);\n\n\txhci_dbc_eps_init(dbc);\n\tdbc->state = DS_INITIALIZED;\n\n\treturn 0;\n\nstring_fail:\n\tdbc_free_ctx(dev, dbc->ctx);\n\tdbc->ctx = NULL;\nctx_fail:\n\tdbc_erst_free(dev, &dbc->erst);\nerst_fail:\n\tdbc_ring_free(dev, dbc->ring_out);\n\tdbc->ring_out = NULL;\nout_fail:\n\tdbc_ring_free(dev, dbc->ring_in);\n\tdbc->ring_in = NULL;\nin_fail:\n\tdbc_ring_free(dev, dbc->ring_evt);\n\tdbc->ring_evt = NULL;\nevt_fail:\n\treturn -ENOMEM;\n}\n\nstatic void xhci_dbc_mem_cleanup(struct xhci_dbc *dbc)\n{\n\tif (!dbc)\n\t\treturn;\n\n\txhci_dbc_eps_exit(dbc);\n\n\tif (dbc->string) {\n\t\tdma_free_coherent(dbc->dev, dbc->string_size,\n\t\t\t\t  dbc->string, dbc->string_dma);\n\t\tdbc->string = NULL;\n\t}\n\n\tdbc_free_ctx(dbc->dev, dbc->ctx);\n\tdbc->ctx = NULL;\n\n\tdbc_erst_free(dbc->dev, &dbc->erst);\n\tdbc_ring_free(dbc->dev, dbc->ring_out);\n\tdbc_ring_free(dbc->dev, dbc->ring_in);\n\tdbc_ring_free(dbc->dev, dbc->ring_evt);\n\tdbc->ring_in = NULL;\n\tdbc->ring_out = NULL;\n\tdbc->ring_evt = NULL;\n}\n\nstatic int xhci_do_dbc_start(struct xhci_dbc *dbc)\n{\n\tint\t\t\tret;\n\tu32\t\t\tctrl;\n\n\tif (dbc->state != DS_DISABLED)\n\t\treturn -EINVAL;\n\n\twritel(0, &dbc->regs->control);\n\tret = xhci_handshake(&dbc->regs->control,\n\t\t\t     DBC_CTRL_DBC_ENABLE,\n\t\t\t     0, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tret = xhci_dbc_mem_init(dbc, GFP_ATOMIC);\n\tif (ret)\n\t\treturn ret;\n\n\tctrl = readl(&dbc->regs->control);\n\twritel(ctrl | DBC_CTRL_DBC_ENABLE | DBC_CTRL_PORT_ENABLE,\n\t       &dbc->regs->control);\n\tret = xhci_handshake(&dbc->regs->control,\n\t\t\t     DBC_CTRL_DBC_ENABLE,\n\t\t\t     DBC_CTRL_DBC_ENABLE, 1000);\n\tif (ret)\n\t\treturn ret;\n\n\tdbc->state = DS_ENABLED;\n\n\treturn 0;\n}\n\nstatic int xhci_do_dbc_stop(struct xhci_dbc *dbc)\n{\n\tif (dbc->state == DS_DISABLED)\n\t\treturn -1;\n\n\twritel(0, &dbc->regs->control);\n\tdbc->state = DS_DISABLED;\n\n\treturn 0;\n}\n\nstatic int xhci_dbc_start(struct xhci_dbc *dbc)\n{\n\tint\t\t\tret;\n\tunsigned long\t\tflags;\n\n\tWARN_ON(!dbc);\n\n\tpm_runtime_get_sync(dbc->dev);  \n\n\tspin_lock_irqsave(&dbc->lock, flags);\n\tret = xhci_do_dbc_start(dbc);\n\tspin_unlock_irqrestore(&dbc->lock, flags);\n\n\tif (ret) {\n\t\tpm_runtime_put(dbc->dev);  \n\t\treturn ret;\n\t}\n\n\treturn mod_delayed_work(system_wq, &dbc->event_work, 1);\n}\n\nstatic void xhci_dbc_stop(struct xhci_dbc *dbc)\n{\n\tint ret;\n\tunsigned long\t\tflags;\n\n\tWARN_ON(!dbc);\n\n\tswitch (dbc->state) {\n\tcase DS_DISABLED:\n\t\treturn;\n\tcase DS_CONFIGURED:\n\tcase DS_STALLED:\n\t\tif (dbc->driver->disconnect)\n\t\t\tdbc->driver->disconnect(dbc);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tcancel_delayed_work_sync(&dbc->event_work);\n\n\tspin_lock_irqsave(&dbc->lock, flags);\n\tret = xhci_do_dbc_stop(dbc);\n\tspin_unlock_irqrestore(&dbc->lock, flags);\n\n\tif (!ret) {\n\t\txhci_dbc_mem_cleanup(dbc);\n\t\tpm_runtime_put_sync(dbc->dev);  \n\t}\n}\n\nstatic void\ndbc_handle_port_status(struct xhci_dbc *dbc, union xhci_trb *event)\n{\n\tu32\t\t\tportsc;\n\n\tportsc = readl(&dbc->regs->portsc);\n\tif (portsc & DBC_PORTSC_CONN_CHANGE)\n\t\tdev_info(dbc->dev, \"DbC port connect change\\n\");\n\n\tif (portsc & DBC_PORTSC_RESET_CHANGE)\n\t\tdev_info(dbc->dev, \"DbC port reset change\\n\");\n\n\tif (portsc & DBC_PORTSC_LINK_CHANGE)\n\t\tdev_info(dbc->dev, \"DbC port link status change\\n\");\n\n\tif (portsc & DBC_PORTSC_CONFIG_CHANGE)\n\t\tdev_info(dbc->dev, \"DbC config error change\\n\");\n\n\t \n\twritel(portsc & ~DBC_PORTSC_RESET_CHANGE, &dbc->regs->portsc);\n}\n\nstatic void dbc_handle_xfer_event(struct xhci_dbc *dbc, union xhci_trb *event)\n{\n\tstruct dbc_ep\t\t*dep;\n\tstruct xhci_ring\t*ring;\n\tint\t\t\tep_id;\n\tint\t\t\tstatus;\n\tu32\t\t\tcomp_code;\n\tsize_t\t\t\tremain_length;\n\tstruct dbc_request\t*req = NULL, *r;\n\n\tcomp_code\t= GET_COMP_CODE(le32_to_cpu(event->generic.field[2]));\n\tremain_length\t= EVENT_TRB_LEN(le32_to_cpu(event->generic.field[2]));\n\tep_id\t\t= TRB_TO_EP_ID(le32_to_cpu(event->generic.field[3]));\n\tdep\t\t= (ep_id == EPID_OUT) ?\n\t\t\t\tget_out_ep(dbc) : get_in_ep(dbc);\n\tring\t\t= dep->ring;\n\n\tswitch (comp_code) {\n\tcase COMP_SUCCESS:\n\t\tremain_length = 0;\n\t\tfallthrough;\n\tcase COMP_SHORT_PACKET:\n\t\tstatus = 0;\n\t\tbreak;\n\tcase COMP_TRB_ERROR:\n\tcase COMP_BABBLE_DETECTED_ERROR:\n\tcase COMP_USB_TRANSACTION_ERROR:\n\tcase COMP_STALL_ERROR:\n\t\tdev_warn(dbc->dev, \"tx error %d detected\\n\", comp_code);\n\t\tstatus = -comp_code;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dbc->dev, \"unknown tx error %d\\n\", comp_code);\n\t\tstatus = -comp_code;\n\t\tbreak;\n\t}\n\n\t \n\tlist_for_each_entry(r, &dep->list_pending, list_pending) {\n\t\tif (r->trb_dma == event->trans_event.buffer) {\n\t\t\treq = r;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!req) {\n\t\tdev_warn(dbc->dev, \"no matched request\\n\");\n\t\treturn;\n\t}\n\n\ttrace_xhci_dbc_handle_transfer(ring, &req->trb->generic);\n\n\tring->num_trbs_free++;\n\treq->actual = req->length - remain_length;\n\txhci_dbc_giveback(req, status);\n}\n\nstatic void inc_evt_deq(struct xhci_ring *ring)\n{\n\t \n\tif (ring->dequeue == &ring->deq_seg->trbs[TRBS_PER_SEGMENT - 1]) {\n\t\tring->cycle_state ^= 1;\n\t\tring->dequeue = ring->deq_seg->trbs;\n\t\treturn;\n\t}\n\tring->dequeue++;\n}\n\nstatic enum evtreturn xhci_dbc_do_handle_events(struct xhci_dbc *dbc)\n{\n\tdma_addr_t\t\tdeq;\n\tstruct dbc_ep\t\t*dep;\n\tunion xhci_trb\t\t*evt;\n\tu32\t\t\tctrl, portsc;\n\tbool\t\t\tupdate_erdp = false;\n\n\t \n\tswitch (dbc->state) {\n\tcase DS_DISABLED:\n\tcase DS_INITIALIZED:\n\n\t\treturn EVT_ERR;\n\tcase DS_ENABLED:\n\t\tportsc = readl(&dbc->regs->portsc);\n\t\tif (portsc & DBC_PORTSC_CONN_STATUS) {\n\t\t\tdbc->state = DS_CONNECTED;\n\t\t\tdev_info(dbc->dev, \"DbC connected\\n\");\n\t\t}\n\n\t\treturn EVT_DONE;\n\tcase DS_CONNECTED:\n\t\tctrl = readl(&dbc->regs->control);\n\t\tif (ctrl & DBC_CTRL_DBC_RUN) {\n\t\t\tdbc->state = DS_CONFIGURED;\n\t\t\tdev_info(dbc->dev, \"DbC configured\\n\");\n\t\t\tportsc = readl(&dbc->regs->portsc);\n\t\t\twritel(portsc, &dbc->regs->portsc);\n\t\t\treturn EVT_GSER;\n\t\t}\n\n\t\treturn EVT_DONE;\n\tcase DS_CONFIGURED:\n\t\t \n\t\tportsc = readl(&dbc->regs->portsc);\n\t\tif (!(portsc & DBC_PORTSC_PORT_ENABLED) &&\n\t\t    !(portsc & DBC_PORTSC_CONN_STATUS)) {\n\t\t\tdev_info(dbc->dev, \"DbC cable unplugged\\n\");\n\t\t\tdbc->state = DS_ENABLED;\n\t\t\txhci_dbc_flush_requests(dbc);\n\n\t\t\treturn EVT_DISC;\n\t\t}\n\n\t\t \n\t\tif (portsc & DBC_PORTSC_RESET_CHANGE) {\n\t\t\tdev_info(dbc->dev, \"DbC port reset\\n\");\n\t\t\twritel(portsc, &dbc->regs->portsc);\n\t\t\tdbc->state = DS_ENABLED;\n\t\t\txhci_dbc_flush_requests(dbc);\n\n\t\t\treturn EVT_DISC;\n\t\t}\n\n\t\t \n\t\tctrl = readl(&dbc->regs->control);\n\t\tif ((ctrl & DBC_CTRL_HALT_IN_TR) ||\n\t\t    (ctrl & DBC_CTRL_HALT_OUT_TR)) {\n\t\t\tdev_info(dbc->dev, \"DbC Endpoint stall\\n\");\n\t\t\tdbc->state = DS_STALLED;\n\n\t\t\tif (ctrl & DBC_CTRL_HALT_IN_TR) {\n\t\t\t\tdep = get_in_ep(dbc);\n\t\t\t\txhci_dbc_flush_endpoint_requests(dep);\n\t\t\t}\n\n\t\t\tif (ctrl & DBC_CTRL_HALT_OUT_TR) {\n\t\t\t\tdep = get_out_ep(dbc);\n\t\t\t\txhci_dbc_flush_endpoint_requests(dep);\n\t\t\t}\n\n\t\t\treturn EVT_DONE;\n\t\t}\n\n\t\t \n\t\tif (ctrl & DBC_CTRL_DBC_RUN_CHANGE) {\n\t\t\twritel(ctrl, &dbc->regs->control);\n\t\t\tctrl = readl(&dbc->regs->control);\n\t\t}\n\n\t\tbreak;\n\tcase DS_STALLED:\n\t\tctrl = readl(&dbc->regs->control);\n\t\tif (!(ctrl & DBC_CTRL_HALT_IN_TR) &&\n\t\t    !(ctrl & DBC_CTRL_HALT_OUT_TR) &&\n\t\t    (ctrl & DBC_CTRL_DBC_RUN)) {\n\t\t\tdbc->state = DS_CONFIGURED;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn EVT_DONE;\n\tdefault:\n\t\tdev_err(dbc->dev, \"Unknown DbC state %d\\n\", dbc->state);\n\t\tbreak;\n\t}\n\n\t \n\tevt = dbc->ring_evt->dequeue;\n\twhile ((le32_to_cpu(evt->event_cmd.flags) & TRB_CYCLE) ==\n\t\t\tdbc->ring_evt->cycle_state) {\n\t\t \n\t\trmb();\n\n\t\ttrace_xhci_dbc_handle_event(dbc->ring_evt, &evt->generic);\n\n\t\tswitch (le32_to_cpu(evt->event_cmd.flags) & TRB_TYPE_BITMASK) {\n\t\tcase TRB_TYPE(TRB_PORT_STATUS):\n\t\t\tdbc_handle_port_status(dbc, evt);\n\t\t\tbreak;\n\t\tcase TRB_TYPE(TRB_TRANSFER):\n\t\t\tdbc_handle_xfer_event(dbc, evt);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tinc_evt_deq(dbc->ring_evt);\n\n\t\tevt = dbc->ring_evt->dequeue;\n\t\tupdate_erdp = true;\n\t}\n\n\t \n\tif (update_erdp) {\n\t\tdeq = xhci_trb_virt_to_dma(dbc->ring_evt->deq_seg,\n\t\t\t\t\t   dbc->ring_evt->dequeue);\n\t\tlo_hi_writeq(deq, &dbc->regs->erdp);\n\t}\n\n\treturn EVT_DONE;\n}\n\nstatic void xhci_dbc_handle_events(struct work_struct *work)\n{\n\tenum evtreturn\t\tevtr;\n\tstruct xhci_dbc\t\t*dbc;\n\tunsigned long\t\tflags;\n\n\tdbc = container_of(to_delayed_work(work), struct xhci_dbc, event_work);\n\n\tspin_lock_irqsave(&dbc->lock, flags);\n\tevtr = xhci_dbc_do_handle_events(dbc);\n\tspin_unlock_irqrestore(&dbc->lock, flags);\n\n\tswitch (evtr) {\n\tcase EVT_GSER:\n\t\tif (dbc->driver->configure)\n\t\t\tdbc->driver->configure(dbc);\n\t\tbreak;\n\tcase EVT_DISC:\n\t\tif (dbc->driver->disconnect)\n\t\t\tdbc->driver->disconnect(dbc);\n\t\tbreak;\n\tcase EVT_DONE:\n\t\tbreak;\n\tdefault:\n\t\tdev_info(dbc->dev, \"stop handling dbc events\\n\");\n\t\treturn;\n\t}\n\n\tmod_delayed_work(system_wq, &dbc->event_work, 1);\n}\n\nstatic ssize_t dbc_show(struct device *dev,\n\t\t\tstruct device_attribute *attr,\n\t\t\tchar *buf)\n{\n\tconst char\t\t*p;\n\tstruct xhci_dbc\t\t*dbc;\n\tstruct xhci_hcd\t\t*xhci;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\tswitch (dbc->state) {\n\tcase DS_DISABLED:\n\t\tp = \"disabled\";\n\t\tbreak;\n\tcase DS_INITIALIZED:\n\t\tp = \"initialized\";\n\t\tbreak;\n\tcase DS_ENABLED:\n\t\tp = \"enabled\";\n\t\tbreak;\n\tcase DS_CONNECTED:\n\t\tp = \"connected\";\n\t\tbreak;\n\tcase DS_CONFIGURED:\n\t\tp = \"configured\";\n\t\tbreak;\n\tcase DS_STALLED:\n\t\tp = \"stalled\";\n\t\tbreak;\n\tdefault:\n\t\tp = \"unknown\";\n\t}\n\n\treturn sprintf(buf, \"%s\\n\", p);\n}\n\nstatic ssize_t dbc_store(struct device *dev,\n\t\t\t struct device_attribute *attr,\n\t\t\t const char *buf, size_t count)\n{\n\tstruct xhci_hcd\t\t*xhci;\n\tstruct xhci_dbc\t\t*dbc;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\tif (!strncmp(buf, \"enable\", 6))\n\t\txhci_dbc_start(dbc);\n\telse if (!strncmp(buf, \"disable\", 7))\n\t\txhci_dbc_stop(dbc);\n\telse\n\t\treturn -EINVAL;\n\n\treturn count;\n}\n\nstatic ssize_t dbc_idVendor_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct xhci_dbc\t\t*dbc;\n\tstruct xhci_hcd\t\t*xhci;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\treturn sprintf(buf, \"%04x\\n\", dbc->idVendor);\n}\n\nstatic ssize_t dbc_idVendor_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tstruct xhci_dbc\t\t*dbc;\n\tstruct xhci_hcd\t\t*xhci;\n\tvoid __iomem\t\t*ptr;\n\tu16\t\t\tvalue;\n\tu32\t\t\tdev_info;\n\n\tif (kstrtou16(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\tif (dbc->state != DS_DISABLED)\n\t\treturn -EBUSY;\n\n\tdbc->idVendor = value;\n\tptr = &dbc->regs->devinfo1;\n\tdev_info = readl(ptr);\n\tdev_info = (dev_info & ~(0xffffu << 16)) | (value << 16);\n\twritel(dev_info, ptr);\n\n\treturn size;\n}\n\nstatic ssize_t dbc_idProduct_show(struct device *dev,\n\t\t\t    struct device_attribute *attr,\n\t\t\t    char *buf)\n{\n\tstruct xhci_dbc         *dbc;\n\tstruct xhci_hcd         *xhci;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\treturn sprintf(buf, \"%04x\\n\", dbc->idProduct);\n}\n\nstatic ssize_t dbc_idProduct_store(struct device *dev,\n\t\t\t     struct device_attribute *attr,\n\t\t\t     const char *buf, size_t size)\n{\n\tstruct xhci_dbc         *dbc;\n\tstruct xhci_hcd         *xhci;\n\tvoid __iomem\t\t*ptr;\n\tu32\t\t\tdev_info;\n\tu16\t\t\tvalue;\n\n\tif (kstrtou16(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\tif (dbc->state != DS_DISABLED)\n\t\treturn -EBUSY;\n\n\tdbc->idProduct = value;\n\tptr = &dbc->regs->devinfo2;\n\tdev_info = readl(ptr);\n\tdev_info = (dev_info & ~(0xffffu)) | value;\n\twritel(dev_info, ptr);\n\treturn size;\n}\n\nstatic ssize_t dbc_bcdDevice_show(struct device *dev,\n\t\t\t\t   struct device_attribute *attr,\n\t\t\t\t   char *buf)\n{\n\tstruct xhci_dbc\t*dbc;\n\tstruct xhci_hcd\t*xhci;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\treturn sprintf(buf, \"%04x\\n\", dbc->bcdDevice);\n}\n\nstatic ssize_t dbc_bcdDevice_store(struct device *dev,\n\t\t\t\t    struct device_attribute *attr,\n\t\t\t\t    const char *buf, size_t size)\n{\n\tstruct xhci_dbc\t*dbc;\n\tstruct xhci_hcd\t*xhci;\n\tvoid __iomem *ptr;\n\tu32 dev_info;\n\tu16 value;\n\n\tif (kstrtou16(buf, 0, &value))\n\t\treturn -EINVAL;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\tif (dbc->state != DS_DISABLED)\n\t\treturn -EBUSY;\n\n\tdbc->bcdDevice = value;\n\tptr = &dbc->regs->devinfo2;\n\tdev_info = readl(ptr);\n\tdev_info = (dev_info & ~(0xffffu << 16)) | (value << 16);\n\twritel(dev_info, ptr);\n\n\treturn size;\n}\n\nstatic ssize_t dbc_bInterfaceProtocol_show(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t char *buf)\n{\n\tstruct xhci_dbc\t*dbc;\n\tstruct xhci_hcd\t*xhci;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\n\treturn sprintf(buf, \"%02x\\n\", dbc->bInterfaceProtocol);\n}\n\nstatic ssize_t dbc_bInterfaceProtocol_store(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  const char *buf, size_t size)\n{\n\tstruct xhci_dbc *dbc;\n\tstruct xhci_hcd *xhci;\n\tvoid __iomem *ptr;\n\tu32 dev_info;\n\tu8 value;\n\tint ret;\n\n\t \n\tret = kstrtou8(buf, 0, &value);\n\tif (ret || value > 1)\n\t\treturn -EINVAL;\n\n\txhci = hcd_to_xhci(dev_get_drvdata(dev));\n\tdbc = xhci->dbc;\n\tif (dbc->state != DS_DISABLED)\n\t\treturn -EBUSY;\n\n\tdbc->bInterfaceProtocol = value;\n\tptr = &dbc->regs->devinfo1;\n\tdev_info = readl(ptr);\n\tdev_info = (dev_info & ~(0xffu)) | value;\n\twritel(dev_info, ptr);\n\n\treturn size;\n}\n\nstatic DEVICE_ATTR_RW(dbc);\nstatic DEVICE_ATTR_RW(dbc_idVendor);\nstatic DEVICE_ATTR_RW(dbc_idProduct);\nstatic DEVICE_ATTR_RW(dbc_bcdDevice);\nstatic DEVICE_ATTR_RW(dbc_bInterfaceProtocol);\n\nstatic struct attribute *dbc_dev_attributes[] = {\n\t&dev_attr_dbc.attr,\n\t&dev_attr_dbc_idVendor.attr,\n\t&dev_attr_dbc_idProduct.attr,\n\t&dev_attr_dbc_bcdDevice.attr,\n\t&dev_attr_dbc_bInterfaceProtocol.attr,\n\tNULL\n};\n\nstatic const struct attribute_group dbc_dev_attrib_grp = {\n\t.attrs = dbc_dev_attributes,\n};\n\nstruct xhci_dbc *\nxhci_alloc_dbc(struct device *dev, void __iomem *base, const struct dbc_driver *driver)\n{\n\tstruct xhci_dbc\t\t*dbc;\n\tint\t\t\tret;\n\n\tdbc = kzalloc(sizeof(*dbc), GFP_KERNEL);\n\tif (!dbc)\n\t\treturn NULL;\n\n\tdbc->regs = base;\n\tdbc->dev = dev;\n\tdbc->driver = driver;\n\tdbc->idProduct = DBC_PRODUCT_ID;\n\tdbc->idVendor = DBC_VENDOR_ID;\n\tdbc->bcdDevice = DBC_DEVICE_REV;\n\tdbc->bInterfaceProtocol = DBC_PROTOCOL;\n\n\tif (readl(&dbc->regs->control) & DBC_CTRL_DBC_ENABLE)\n\t\tgoto err;\n\n\tINIT_DELAYED_WORK(&dbc->event_work, xhci_dbc_handle_events);\n\tspin_lock_init(&dbc->lock);\n\n\tret = sysfs_create_group(&dev->kobj, &dbc_dev_attrib_grp);\n\tif (ret)\n\t\tgoto err;\n\n\treturn dbc;\nerr:\n\tkfree(dbc);\n\treturn NULL;\n}\n\n \nvoid xhci_dbc_remove(struct xhci_dbc *dbc)\n{\n\tif (!dbc)\n\t\treturn;\n\t \n\txhci_dbc_stop(dbc);\n\n\t \n\tsysfs_remove_group(&dbc->dev->kobj, &dbc_dev_attrib_grp);\n\n\tkfree(dbc);\n}\n\n\nint xhci_create_dbc_dev(struct xhci_hcd *xhci)\n{\n\tstruct device\t\t*dev;\n\tvoid __iomem\t\t*base;\n\tint\t\t\tret;\n\tint\t\t\tdbc_cap_offs;\n\n\t \n\tdev = xhci_to_hcd(xhci)->self.controller;\n\tbase = &xhci->cap_regs->hc_capbase;\n\n\tdbc_cap_offs = xhci_find_next_ext_cap(base, 0, XHCI_EXT_CAPS_DEBUG);\n\tif (!dbc_cap_offs)\n\t\treturn -ENODEV;\n\n\t \n\tif (xhci->dbc)\n\t\treturn -EBUSY;\n\n\tret = xhci_dbc_tty_probe(dev, base + dbc_cap_offs, xhci);\n\n\treturn ret;\n}\n\nvoid xhci_remove_dbc_dev(struct xhci_hcd *xhci)\n{\n\tunsigned long\t\tflags;\n\n\tif (!xhci->dbc)\n\t\treturn;\n\n\txhci_dbc_tty_remove(xhci->dbc);\n\tspin_lock_irqsave(&xhci->lock, flags);\n\txhci->dbc = NULL;\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n}\n\n#ifdef CONFIG_PM\nint xhci_dbc_suspend(struct xhci_hcd *xhci)\n{\n\tstruct xhci_dbc\t\t*dbc = xhci->dbc;\n\n\tif (!dbc)\n\t\treturn 0;\n\n\tif (dbc->state == DS_CONFIGURED)\n\t\tdbc->resume_required = 1;\n\n\txhci_dbc_stop(dbc);\n\n\treturn 0;\n}\n\nint xhci_dbc_resume(struct xhci_hcd *xhci)\n{\n\tint\t\t\tret = 0;\n\tstruct xhci_dbc\t\t*dbc = xhci->dbc;\n\n\tif (!dbc)\n\t\treturn 0;\n\n\tif (dbc->resume_required) {\n\t\tdbc->resume_required = 0;\n\t\txhci_dbc_start(dbc);\n\t}\n\n\treturn ret;\n}\n#endif  \n\nint xhci_dbc_init(void)\n{\n\treturn dbc_tty_init();\n}\n\nvoid xhci_dbc_exit(void)\n{\n\tdbc_tty_exit();\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}