{
  "module_name": "sl811_cs.c",
  "hash_id": "bbe659dfed17f6c725d99daf8068e6d645411ba0602ef66e51d674b36194d911",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/sl811_cs.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/ioport.h>\n#include <linux/platform_device.h>\n\n#include <pcmcia/cistpl.h>\n#include <pcmcia/cisreg.h>\n#include <pcmcia/ds.h>\n\n#include <linux/usb/sl811.h>\n\nMODULE_AUTHOR(\"Botond Botyanszki\");\nMODULE_DESCRIPTION(\"REX-CFU1U PCMCIA driver for 2.6\");\nMODULE_LICENSE(\"GPL\");\n\n\n \n \n \n\n#define INFO(args...) printk(KERN_INFO \"sl811_cs: \" args)\n\n \n \n \n\ntypedef struct local_info_t {\n\tstruct pcmcia_device\t*p_dev;\n} local_info_t;\n\nstatic void sl811_cs_release(struct pcmcia_device * link);\n\n \n\nstatic void release_platform_dev(struct device * dev)\n{\n\tdev_dbg(dev, \"sl811_cs platform_dev release\\n\");\n\tdev->parent = NULL;\n}\n\nstatic struct sl811_platform_data platform_data = {\n\t.potpg\t\t= 100,\n\t.power\t\t= 50,\t\t \n\t\n};\n\nstatic struct resource resources[] = {\n\t[0] = {\n\t\t.flags\t= IORESOURCE_IRQ,\n\t},\n\t[1] = {\n\t\t\n\t\t.flags\t= IORESOURCE_IO,\n\t},\n\t[2] = {\n\t\t\n\t\t.flags\t= IORESOURCE_IO,\n\t},\n};\n\nextern struct platform_driver sl811h_driver;\n\nstatic struct platform_device platform_dev = {\n\t.id\t\t\t= -1,\n\t.dev = {\n\t\t.platform_data = &platform_data,\n\t\t.release       = release_platform_dev,\n\t},\n\t.resource\t\t= resources,\n\t.num_resources\t\t= ARRAY_SIZE(resources),\n};\n\nstatic int sl811_hc_init(struct device *parent, resource_size_t base_addr,\n\t\t\t int irq)\n{\n\tif (platform_dev.dev.parent)\n\t\treturn -EBUSY;\n\tplatform_dev.dev.parent = parent;\n\n\t \n\tresources[0].start = irq;\n\n\tresources[1].start = base_addr;\n\tresources[1].end = base_addr;\n\n\tresources[2].start = base_addr + 1;\n\tresources[2].end   = base_addr + 1;\n\n\t \n\tplatform_dev.name = sl811h_driver.driver.name;\n\treturn platform_device_register(&platform_dev);\n}\n\n \n\nstatic void sl811_cs_detach(struct pcmcia_device *link)\n{\n\tdev_dbg(&link->dev, \"sl811_cs_detach\\n\");\n\n\tsl811_cs_release(link);\n\n\t \n\tkfree(link->priv);\n}\n\nstatic void sl811_cs_release(struct pcmcia_device * link)\n{\n\tdev_dbg(&link->dev, \"sl811_cs_release\\n\");\n\n\tpcmcia_disable_device(link);\n\tplatform_device_unregister(&platform_dev);\n}\n\nstatic int sl811_cs_config_check(struct pcmcia_device *p_dev, void *priv_data)\n{\n\tif (p_dev->config_index == 0)\n\t\treturn -EINVAL;\n\n\treturn pcmcia_request_io(p_dev);\n}\n\n\nstatic int sl811_cs_config(struct pcmcia_device *link)\n{\n\tstruct device\t\t*parent = &link->dev;\n\tint\t\t\tret;\n\n\tdev_dbg(&link->dev, \"sl811_cs_config\\n\");\n\n\tlink->config_flags |= CONF_ENABLE_IRQ |\tCONF_AUTO_SET_VPP |\n\t\tCONF_AUTO_CHECK_VCC | CONF_AUTO_SET_IO;\n\n\tif (pcmcia_loop_config(link, sl811_cs_config_check, NULL))\n\t\tgoto failed;\n\n\t \n\tif (resource_size(link->resource[0]) < 2)\n\t\tgoto failed;\n\n\tif (!link->irq)\n\t\tgoto failed;\n\n\tret = pcmcia_enable_device(link);\n\tif (ret)\n\t\tgoto failed;\n\n\tif (sl811_hc_init(parent, link->resource[0]->start, link->irq)\n\t\t\t< 0) {\nfailed:\n\t\tprintk(KERN_WARNING \"sl811_cs_config failed\\n\");\n\t\tsl811_cs_release(link);\n\t\treturn  -ENODEV;\n\t}\n\treturn 0;\n}\n\nstatic int sl811_cs_probe(struct pcmcia_device *link)\n{\n\tlocal_info_t *local;\n\n\tlocal = kzalloc(sizeof(local_info_t), GFP_KERNEL);\n\tif (!local)\n\t\treturn -ENOMEM;\n\tlocal->p_dev = link;\n\tlink->priv = local;\n\n\treturn sl811_cs_config(link);\n}\n\nstatic const struct pcmcia_device_id sl811_ids[] = {\n\tPCMCIA_DEVICE_MANF_CARD(0xc015, 0x0001),  \n\tPCMCIA_DEVICE_NULL,\n};\nMODULE_DEVICE_TABLE(pcmcia, sl811_ids);\n\nstatic struct pcmcia_driver sl811_cs_driver = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"sl811_cs\",\n\t.probe\t\t= sl811_cs_probe,\n\t.remove\t\t= sl811_cs_detach,\n\t.id_table\t= sl811_ids,\n};\nmodule_pcmcia_driver(sl811_cs_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}