{
  "module_name": "xhci-pci.c",
  "hash_id": "a9ff72fb0cb5bb707e9d29e7a8624b74ae86e8edcc3d2ccb841583313d771397",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-pci.c",
  "human_readable_source": "\n \n\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/acpi.h>\n#include <linux/reset.h>\n#include <linux/suspend.h>\n\n#include \"xhci.h\"\n#include \"xhci-trace.h\"\n#include \"xhci-pci.h\"\n\n#define SSIC_PORT_NUM\t\t2\n#define SSIC_PORT_CFG2\t\t0x880c\n#define SSIC_PORT_CFG2_OFFSET\t0x30\n#define PROG_DONE\t\t(1 << 30)\n#define SSIC_PORT_UNUSED\t(1 << 31)\n#define SPARSE_DISABLE_BIT\t17\n#define SPARSE_CNTL_ENABLE\t0xC12C\n\n \n#define PCI_VENDOR_ID_FRESCO_LOGIC\t0x1b73\n#define PCI_DEVICE_ID_FRESCO_LOGIC_PDK\t0x1000\n#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1009\t0x1009\n#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1100\t0x1100\n#define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400\t0x1400\n\n#define PCI_VENDOR_ID_ETRON\t\t0x1b6f\n#define PCI_DEVICE_ID_EJ168\t\t0x7023\n\n#define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI\t0x8c31\n#define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI\t0x9c31\n#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI\t0x9cb1\n#define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI\t\t0x22b5\n#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI\t\t0xa12f\n#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI\t0x9d2f\n#define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI\t\t0x0aa8\n#define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI\t\t0x1aa8\n#define PCI_DEVICE_ID_INTEL_APL_XHCI\t\t\t0x5aa8\n#define PCI_DEVICE_ID_INTEL_DNV_XHCI\t\t\t0x19d0\n#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_XHCI\t0x15b5\n#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_XHCI\t0x15b6\n#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_LP_XHCI\t0x15c1\n#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_XHCI\t0x15db\n#define PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_XHCI\t0x15d4\n#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI\t\t0x15e9\n#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI\t\t0x15ec\n#define PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI\t\t0x15f0\n#define PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI\t\t0x8a13\n#define PCI_DEVICE_ID_INTEL_CML_XHCI\t\t\t0xa3af\n#define PCI_DEVICE_ID_INTEL_TIGER_LAKE_XHCI\t\t0x9a13\n#define PCI_DEVICE_ID_INTEL_MAPLE_RIDGE_XHCI\t\t0x1138\n#define PCI_DEVICE_ID_INTEL_ALDER_LAKE_PCH_XHCI\t\t0x51ed\n#define PCI_DEVICE_ID_INTEL_ALDER_LAKE_N_PCH_XHCI\t0x54ed\n\n#define PCI_DEVICE_ID_AMD_RENOIR_XHCI\t\t\t0x1639\n#define PCI_DEVICE_ID_AMD_PROMONTORYA_4\t\t\t0x43b9\n#define PCI_DEVICE_ID_AMD_PROMONTORYA_3\t\t\t0x43ba\n#define PCI_DEVICE_ID_AMD_PROMONTORYA_2\t\t\t0x43bb\n#define PCI_DEVICE_ID_AMD_PROMONTORYA_1\t\t\t0x43bc\n\n#define PCI_DEVICE_ID_ASMEDIA_1042_XHCI\t\t\t0x1042\n#define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI\t\t0x1142\n#define PCI_DEVICE_ID_ASMEDIA_1142_XHCI\t\t\t0x1242\n#define PCI_DEVICE_ID_ASMEDIA_2142_XHCI\t\t\t0x2142\n#define PCI_DEVICE_ID_ASMEDIA_3242_XHCI\t\t\t0x3242\n\nstatic const char hcd_name[] = \"xhci_hcd\";\n\nstatic struct hc_driver __read_mostly xhci_pci_hc_driver;\n\nstatic int xhci_pci_setup(struct usb_hcd *hcd);\nstatic int xhci_pci_run(struct usb_hcd *hcd);\nstatic int xhci_pci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,\n\t\t\t\t      struct usb_tt *tt, gfp_t mem_flags);\n\nstatic const struct xhci_driver_overrides xhci_pci_overrides __initconst = {\n\t.reset = xhci_pci_setup,\n\t.start = xhci_pci_run,\n\t.update_hub_device = xhci_pci_update_hub_device,\n};\n\nstatic void xhci_msix_sync_irqs(struct xhci_hcd *xhci)\n{\n\tstruct usb_hcd *hcd = xhci_to_hcd(xhci);\n\n\tif (hcd->msix_enabled) {\n\t\tstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\n\t\tint i;\n\n\t\tfor (i = 0; i < xhci->msix_count; i++)\n\t\t\tsynchronize_irq(pci_irq_vector(pdev, i));\n\t}\n}\n\n \nstatic void xhci_cleanup_msix(struct xhci_hcd *xhci)\n{\n\tstruct usb_hcd *hcd = xhci_to_hcd(xhci);\n\tstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\n\n\t \n\tif (hcd->irq > 0)\n\t\treturn;\n\n\tif (hcd->msix_enabled) {\n\t\tint i;\n\n\t\tfor (i = 0; i < xhci->msix_count; i++)\n\t\t\tfree_irq(pci_irq_vector(pdev, i), xhci_to_hcd(xhci));\n\t} else {\n\t\tfree_irq(pci_irq_vector(pdev, 0), xhci_to_hcd(xhci));\n\t}\n\n\tpci_free_irq_vectors(pdev);\n\thcd->msix_enabled = 0;\n}\n\n \nstatic int xhci_setup_msi(struct xhci_hcd *xhci)\n{\n\tint ret;\n\t \n\tstruct pci_dev  *pdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);\n\n\tret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_MSI);\n\tif (ret < 0) {\n\t\txhci_dbg_trace(xhci, trace_xhci_dbg_init,\n\t\t\t\t\"failed to allocate MSI entry\");\n\t\treturn ret;\n\t}\n\n\tret = request_irq(pdev->irq, xhci_msi_irq,\n\t\t\t\t0, \"xhci_hcd\", xhci_to_hcd(xhci));\n\tif (ret) {\n\t\txhci_dbg_trace(xhci, trace_xhci_dbg_init,\n\t\t\t\t\"disable MSI interrupt\");\n\t\tpci_free_irq_vectors(pdev);\n\t}\n\n\treturn ret;\n}\n\n \nstatic int xhci_setup_msix(struct xhci_hcd *xhci)\n{\n\tint i, ret;\n\tstruct usb_hcd *hcd = xhci_to_hcd(xhci);\n\tstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\n\n\t \n\txhci->msix_count = min(num_online_cpus() + 1,\n\t\t\t\tHCS_MAX_INTRS(xhci->hcs_params1));\n\n\tret = pci_alloc_irq_vectors(pdev, xhci->msix_count, xhci->msix_count,\n\t\t\tPCI_IRQ_MSIX);\n\tif (ret < 0) {\n\t\txhci_dbg_trace(xhci, trace_xhci_dbg_init,\n\t\t\t\t\"Failed to enable MSI-X\");\n\t\treturn ret;\n\t}\n\n\tfor (i = 0; i < xhci->msix_count; i++) {\n\t\tret = request_irq(pci_irq_vector(pdev, i), xhci_msi_irq, 0,\n\t\t\t\t\"xhci_hcd\", xhci_to_hcd(xhci));\n\t\tif (ret)\n\t\t\tgoto disable_msix;\n\t}\n\n\thcd->msix_enabled = 1;\n\treturn ret;\n\ndisable_msix:\n\txhci_dbg_trace(xhci, trace_xhci_dbg_init, \"disable MSI-X interrupt\");\n\twhile (--i >= 0)\n\t\tfree_irq(pci_irq_vector(pdev, i), xhci_to_hcd(xhci));\n\tpci_free_irq_vectors(pdev);\n\treturn ret;\n}\n\nstatic int xhci_try_enable_msi(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct pci_dev  *pdev;\n\tint ret;\n\n\tpdev = to_pci_dev(xhci_to_hcd(xhci)->self.controller);\n\t \n\tif (xhci->quirks & XHCI_BROKEN_MSI)\n\t\tgoto legacy_irq;\n\n\t \n\tif (hcd->irq)\n\t\tfree_irq(hcd->irq, hcd);\n\thcd->irq = 0;\n\n\tret = xhci_setup_msix(xhci);\n\tif (ret)\n\t\t \n\t\tret = xhci_setup_msi(xhci);\n\n\tif (!ret) {\n\t\thcd->msi_enabled = 1;\n\t\treturn 0;\n\t}\n\n\tif (!pdev->irq) {\n\t\txhci_err(xhci, \"No msi-x/msi found and no IRQ in BIOS\\n\");\n\t\treturn -EINVAL;\n\t}\n\n legacy_irq:\n\tif (!strlen(hcd->irq_descr))\n\t\tsnprintf(hcd->irq_descr, sizeof(hcd->irq_descr), \"%s:usb%d\",\n\t\t\t hcd->driver->description, hcd->self.busnum);\n\n\t \n\tret = request_irq(pdev->irq, &usb_hcd_irq, IRQF_SHARED,\n\t\t\thcd->irq_descr, hcd);\n\tif (ret) {\n\t\txhci_err(xhci, \"request interrupt %d failed\\n\",\n\t\t\t\tpdev->irq);\n\t\treturn ret;\n\t}\n\thcd->irq = pdev->irq;\n\treturn 0;\n}\n\nstatic int xhci_pci_run(struct usb_hcd *hcd)\n{\n\tint ret;\n\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tret = xhci_try_enable_msi(hcd);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn xhci_run(hcd);\n}\n\nstatic void xhci_pci_stop(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\n\txhci_stop(hcd);\n\n\tif (usb_hcd_is_primary_hcd(hcd))\n\t\txhci_cleanup_msix(xhci);\n}\n\n \nstatic int xhci_pci_reinit(struct xhci_hcd *xhci, struct pci_dev *pdev)\n{\n\t \n\n\t \n\tif (!pci_set_mwi(pdev))\n\t\txhci_dbg(xhci, \"MWI active\\n\");\n\n\txhci_dbg(xhci, \"Finished xhci_pci_reinit\\n\");\n\treturn 0;\n}\n\nstatic void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)\n{\n\tstruct pci_dev                  *pdev = to_pci_dev(dev);\n\tstruct xhci_driver_data         *driver_data;\n\tconst struct pci_device_id      *id;\n\n\tid = pci_match_id(to_pci_driver(pdev->dev.driver)->id_table, pdev);\n\n\tif (id && id->driver_data) {\n\t\tdriver_data = (struct xhci_driver_data *)id->driver_data;\n\t\txhci->quirks |= driver_data->quirks;\n\t}\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&\n\t\t\t(pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK ||\n\t\t\t pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1400)) {\n\t\tif (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&\n\t\t\t\tpdev->revision == 0x0) {\n\t\t\txhci->quirks |= XHCI_RESET_EP_QUIRK;\n\t\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"XHCI_RESET_EP_QUIRK for this evaluation HW is deprecated\");\n\t\t}\n\t\tif (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&\n\t\t\t\tpdev->revision == 0x4) {\n\t\t\txhci->quirks |= XHCI_SLOW_SUSPEND;\n\t\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"QUIRK: Fresco Logic xHC revision %u\"\n\t\t\t\t\"must be suspended extra slowly\",\n\t\t\t\tpdev->revision);\n\t\t}\n\t\tif (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK)\n\t\t\txhci->quirks |= XHCI_BROKEN_STREAMS;\n\t\t \n\t\txhci->quirks |= XHCI_BROKEN_MSI;\n\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"QUIRK: Fresco Logic revision %u \"\n\t\t\t\t\"has broken MSI implementation\",\n\t\t\t\tpdev->revision);\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\t}\n\n\tif (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&\n\t\t\tpdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1009)\n\t\txhci->quirks |= XHCI_BROKEN_STREAMS;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_FRESCO_LOGIC &&\n\t\t\tpdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1100)\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_NEC)\n\t\txhci->quirks |= XHCI_NEC_HOST;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD && xhci->hci_version == 0x96)\n\t\txhci->quirks |= XHCI_AMD_0x96_HOST;\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_AMD && usb_amd_quirk_pll_check())\n\t\txhci->quirks |= XHCI_AMD_PLL_FIX;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t\t(pdev->device == 0x145c ||\n\t\t pdev->device == 0x15e0 ||\n\t\t pdev->device == 0x15e1 ||\n\t\t pdev->device == 0x43bb))\n\t\txhci->quirks |= XHCI_SUSPEND_DELAY;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t    (pdev->device == 0x15e0 || pdev->device == 0x15e1))\n\t\txhci->quirks |= XHCI_SNPS_BROKEN_SUSPEND;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x15e5) {\n\t\txhci->quirks |= XHCI_DISABLE_SPARSE;\n\t\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\t}\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD)\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\n\tif ((pdev->vendor == PCI_VENDOR_ID_AMD) &&\n\t\t((pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_4) ||\n\t\t(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_3) ||\n\t\t(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_2) ||\n\t\t(pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_1)))\n\t\txhci->quirks |= XHCI_U2_DISABLE_WAKE;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t\tpdev->device == PCI_DEVICE_ID_AMD_RENOIR_XHCI)\n\t\txhci->quirks |= XHCI_BROKEN_D3COLD_S2I;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL) {\n\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n\t\txhci->quirks |= XHCI_INTEL_HOST;\n\t\txhci->quirks |= XHCI_AVOID_BEI;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t\t\tpdev->device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {\n\t\txhci->quirks |= XHCI_EP_LIMIT_QUIRK;\n\t\txhci->limit_active_eps = 64;\n\t\txhci->quirks |= XHCI_SW_BW_CHECKING;\n\t\t \n\t\txhci->quirks |= XHCI_SPURIOUS_REBOOT;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI)) {\n\t\txhci->quirks |= XHCI_SPURIOUS_REBOOT;\n\t\txhci->quirks |= XHCI_SPURIOUS_WAKEUP;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t\t(pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI ||\n\t\t pdev->device == PCI_DEVICE_ID_INTEL_CML_XHCI)) {\n\t\txhci->quirks |= XHCI_PME_STUCK_QUIRK;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)\n\t\txhci->quirks |= XHCI_SSIC_PORT_UNUSED;\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI))\n\t\txhci->quirks |= XHCI_INTEL_USB_ROLE_SW;\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    (pdev->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_APL_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_DNV_XHCI))\n\t\txhci->quirks |= XHCI_MISSING_CAS;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    (pdev->device == PCI_DEVICE_ID_INTEL_ALDER_LAKE_PCH_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ALDER_LAKE_N_PCH_XHCI))\n\t\txhci->quirks |= XHCI_RESET_TO_DEFAULT;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t    (pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_2C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_4C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_LP_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_2C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ALPINE_RIDGE_C_4C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_2C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_4C_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_TITAN_RIDGE_DD_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_ICE_LAKE_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_TIGER_LAKE_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_INTEL_MAPLE_RIDGE_XHCI))\n\t\txhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_ETRON &&\n\t\t\tpdev->device == PCI_DEVICE_ID_EJ168) {\n\t\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\t\txhci->quirks |= XHCI_BROKEN_STREAMS;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_RENESAS &&\n\t    pdev->device == 0x0014) {\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\t\txhci->quirks |= XHCI_ZERO_64B_REGS;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_RENESAS &&\n\t    pdev->device == 0x0015) {\n\t\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\t\txhci->quirks |= XHCI_ZERO_64B_REGS;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_VIA)\n\t\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\n\t \n\t\txhci->quirks |= XHCI_SPURIOUS_SUCCESS;\n\t\txhci->quirks |= XHCI_BROKEN_STREAMS;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&\n\t\tpdev->device == PCI_DEVICE_ID_ASMEDIA_1042A_XHCI) {\n\t\txhci->quirks |= XHCI_TRUST_TX_LENGTH;\n\t\txhci->quirks |= XHCI_NO_64BIT_SUPPORT;\n\t}\n\tif (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&\n\t    (pdev->device == PCI_DEVICE_ID_ASMEDIA_1142_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_ASMEDIA_2142_XHCI ||\n\t     pdev->device == PCI_DEVICE_ID_ASMEDIA_3242_XHCI))\n\t\txhci->quirks |= XHCI_NO_64BIT_SUPPORT;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_ASMEDIA &&\n\t\tpdev->device == PCI_DEVICE_ID_ASMEDIA_1042A_XHCI)\n\t\txhci->quirks |= XHCI_ASMEDIA_MODIFY_FLOWCONTROL;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241)\n\t\txhci->quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;\n\n\tif ((pdev->vendor == PCI_VENDOR_ID_BROADCOM ||\n\t     pdev->vendor == PCI_VENDOR_ID_CAVIUM) &&\n\t     pdev->device == 0x9026)\n\t\txhci->quirks |= XHCI_RESET_PLL_ON_DISCONNECT;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_AMD &&\n\t    (pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_2 ||\n\t     pdev->device == PCI_DEVICE_ID_AMD_PROMONTORYA_4))\n\t\txhci->quirks |= XHCI_NO_SOFT_RETRY;\n\n\tif (pdev->vendor == PCI_VENDOR_ID_ZHAOXIN) {\n\t\txhci->quirks |= XHCI_ZHAOXIN_HOST;\n\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n\n\t\tif (pdev->device == 0x9202) {\n\t\t\txhci->quirks |= XHCI_RESET_ON_RESUME;\n\t\t\txhci->quirks |= XHCI_ZHAOXIN_TRB_FETCH;\n\t\t}\n\n\t\tif (pdev->device == 0x9203)\n\t\t\txhci->quirks |= XHCI_ZHAOXIN_TRB_FETCH;\n\t}\n\n\t \n\tif (xhci->hci_version >= 0x120)\n\t\txhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;\n\n\tif (xhci->quirks & XHCI_RESET_ON_RESUME)\n\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"QUIRK: Resetting on resume\");\n}\n\n#ifdef CONFIG_ACPI\nstatic void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev)\n{\n\tstatic const guid_t intel_dsm_guid =\n\t\tGUID_INIT(0xac340cb7, 0xe901, 0x45bf,\n\t\t\t  0xb7, 0xe6, 0x2b, 0x34, 0xec, 0x93, 0x1e, 0x23);\n\tunion acpi_object *obj;\n\n\tobj = acpi_evaluate_dsm(ACPI_HANDLE(&dev->dev), &intel_dsm_guid, 3, 1,\n\t\t\t\tNULL);\n\tACPI_FREE(obj);\n}\n\nstatic void xhci_find_lpm_incapable_ports(struct usb_hcd *hcd, struct usb_device *hdev)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct xhci_hub *rhub = &xhci->usb3_rhub;\n\tint ret;\n\tint i;\n\n\t \n\tif (hcd != rhub->hcd)\n\t\treturn;\n\n\tif (hdev->maxchild > rhub->num_ports) {\n\t\tdev_err(&hdev->dev, \"USB3 roothub port number mismatch\\n\");\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tret = usb_acpi_port_lpm_incapable(hdev, i);\n\n\t\tdev_dbg(&hdev->dev, \"port-%d disable U1/U2 _DSM: %d\\n\", i + 1, ret);\n\n\t\tif (ret >= 0) {\n\t\t\trhub->ports[i]->lpm_incapable = ret;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\n#else\nstatic void xhci_pme_acpi_rtd3_enable(struct pci_dev *dev) { }\nstatic void xhci_find_lpm_incapable_ports(struct usb_hcd *hcd, struct usb_device *hdev) { }\n#endif  \n\n \nstatic int xhci_pci_setup(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t\t*xhci;\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\tint\t\t\tretval;\n\n\txhci = hcd_to_xhci(hcd);\n\tif (!xhci->sbrn)\n\t\tpci_read_config_byte(pdev, XHCI_SBRN_OFFSET, &xhci->sbrn);\n\n\t \n\txhci->imod_interval = 40000;\n\n\tretval = xhci_gen_setup(hcd, xhci_pci_quirks);\n\tif (retval)\n\t\treturn retval;\n\n\tif (!usb_hcd_is_primary_hcd(hcd))\n\t\treturn 0;\n\n\tif (xhci->quirks & XHCI_PME_STUCK_QUIRK)\n\t\txhci_pme_acpi_rtd3_enable(pdev);\n\n\txhci_dbg(xhci, \"Got SBRN %u\\n\", (unsigned int) xhci->sbrn);\n\n\t \n\treturn xhci_pci_reinit(xhci, pdev);\n}\n\nstatic int xhci_pci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,\n\t\t\t\t      struct usb_tt *tt, gfp_t mem_flags)\n{\n\t \n\tif (!hdev->parent)\n\t\txhci_find_lpm_incapable_ports(hcd, hdev);\n\n\treturn xhci_update_hub_device(hcd, hdev, tt, mem_flags);\n}\n\n \nstatic int xhci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\tint retval;\n\tstruct xhci_hcd *xhci;\n\tstruct usb_hcd *hcd;\n\tstruct xhci_driver_data *driver_data;\n\tstruct reset_control *reset;\n\n\tdriver_data = (struct xhci_driver_data *)id->driver_data;\n\tif (driver_data && driver_data->quirks & XHCI_RENESAS_FW_QUIRK) {\n\t\tretval = renesas_xhci_check_request_fw(dev, id);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\n\treset = devm_reset_control_get_optional_exclusive(&dev->dev, NULL);\n\tif (IS_ERR(reset))\n\t\treturn PTR_ERR(reset);\n\treset_control_reset(reset);\n\n\t \n\tpm_runtime_get_noresume(&dev->dev);\n\n\t \n\tretval = usb_hcd_pci_probe(dev, &xhci_pci_hc_driver);\n\n\tif (retval)\n\t\tgoto put_runtime_pm;\n\n\t \n\thcd = dev_get_drvdata(&dev->dev);\n\txhci = hcd_to_xhci(hcd);\n\txhci->reset = reset;\n\txhci->shared_hcd = usb_create_shared_hcd(&xhci_pci_hc_driver, &dev->dev,\n\t\t\t\t\t\t pci_name(dev), hcd);\n\tif (!xhci->shared_hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto dealloc_usb2_hcd;\n\t}\n\n\tretval = xhci_ext_cap_init(xhci);\n\tif (retval)\n\t\tgoto put_usb3_hcd;\n\n\tretval = usb_add_hcd(xhci->shared_hcd, dev->irq,\n\t\t\tIRQF_SHARED);\n\tif (retval)\n\t\tgoto put_usb3_hcd;\n\t \n\n\tif (!(xhci->quirks & XHCI_BROKEN_STREAMS) &&\n\t\t\tHCC_MAX_PSA(xhci->hcc_params) >= 4)\n\t\txhci->shared_hcd->can_do_streams = 1;\n\n\t \n\tpm_runtime_put_noidle(&dev->dev);\n\n\tif (pci_choose_state(dev, PMSG_SUSPEND) == PCI_D0)\n\t\tpm_runtime_forbid(&dev->dev);\n\telse if (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)\n\t\tpm_runtime_allow(&dev->dev);\n\n\tdma_set_max_seg_size(&dev->dev, UINT_MAX);\n\n\treturn 0;\n\nput_usb3_hcd:\n\tusb_put_hcd(xhci->shared_hcd);\ndealloc_usb2_hcd:\n\tusb_hcd_pci_remove(dev);\nput_runtime_pm:\n\tpm_runtime_put_noidle(&dev->dev);\n\treturn retval;\n}\n\nstatic void xhci_pci_remove(struct pci_dev *dev)\n{\n\tstruct xhci_hcd *xhci;\n\n\txhci = hcd_to_xhci(pci_get_drvdata(dev));\n\n\txhci->xhc_state |= XHCI_STATE_REMOVING;\n\n\tif (xhci->quirks & XHCI_DEFAULT_PM_RUNTIME_ALLOW)\n\t\tpm_runtime_forbid(&dev->dev);\n\n\tif (xhci->shared_hcd) {\n\t\tusb_remove_hcd(xhci->shared_hcd);\n\t\tusb_put_hcd(xhci->shared_hcd);\n\t\txhci->shared_hcd = NULL;\n\t}\n\n\t \n\tif (xhci->quirks & XHCI_SPURIOUS_WAKEUP)\n\t\tpci_set_power_state(dev, PCI_D3hot);\n\n\tusb_hcd_pci_remove(dev);\n}\n\n \nstatic void xhci_ssic_port_unused_quirk(struct usb_hcd *hcd, bool suspend)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tu32 val;\n\tvoid __iomem *reg;\n\tint i;\n\n\tfor (i = 0; i < SSIC_PORT_NUM; i++) {\n\t\treg = (void __iomem *) xhci->cap_regs +\n\t\t\t\tSSIC_PORT_CFG2 +\n\t\t\t\ti * SSIC_PORT_CFG2_OFFSET;\n\n\t\t \n\t\tval = readl(reg) & ~PROG_DONE;\n\t\twritel(val, reg);\n\n\t\t \n\t\tval = readl(reg);\n\t\tif (suspend)\n\t\t\tval |= SSIC_PORT_UNUSED;\n\t\telse\n\t\t\tval &= ~SSIC_PORT_UNUSED;\n\t\twritel(val, reg);\n\n\t\t \n\t\tval = readl(reg) | PROG_DONE;\n\t\twritel(val, reg);\n\t\treadl(reg);\n\t}\n}\n\n \nstatic void xhci_pme_quirk(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tvoid __iomem *reg;\n\tu32 val;\n\n\treg = (void __iomem *) xhci->cap_regs + 0x80a4;\n\tval = readl(reg);\n\twritel(val | BIT(28), reg);\n\treadl(reg);\n}\n\nstatic void xhci_sparse_control_quirk(struct usb_hcd *hcd)\n{\n\tu32 reg;\n\n\treg = readl(hcd->regs + SPARSE_CNTL_ENABLE);\n\treg &= ~BIT(SPARSE_DISABLE_BIT);\n\twritel(reg, hcd->regs + SPARSE_CNTL_ENABLE);\n}\n\nstatic int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\tint\t\t\tret;\n\n\t \n\tif (xhci->quirks & XHCI_COMP_MODE_QUIRK)\n\t\tpci_d3cold_disable(pdev);\n\n#ifdef CONFIG_SUSPEND\n\t \n\tif (pm_suspend_target_state == PM_SUSPEND_TO_IDLE &&\n\t    xhci->quirks & (XHCI_BROKEN_D3COLD_S2I))\n\t\tpci_d3cold_disable(pdev);\n#endif\n\n\tif (xhci->quirks & XHCI_PME_STUCK_QUIRK)\n\t\txhci_pme_quirk(hcd);\n\n\tif (xhci->quirks & XHCI_SSIC_PORT_UNUSED)\n\t\txhci_ssic_port_unused_quirk(hcd, true);\n\n\tif (xhci->quirks & XHCI_DISABLE_SPARSE)\n\t\txhci_sparse_control_quirk(hcd);\n\n\tret = xhci_suspend(xhci, do_wakeup);\n\n\t \n\txhci_msix_sync_irqs(xhci);\n\n\tif (ret && (xhci->quirks & XHCI_SSIC_PORT_UNUSED))\n\t\txhci_ssic_port_unused_quirk(hcd, false);\n\n\treturn ret;\n}\n\nstatic int xhci_pci_resume(struct usb_hcd *hcd, pm_message_t msg)\n{\n\tstruct xhci_hcd\t\t*xhci = hcd_to_xhci(hcd);\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\tint\t\t\tretval = 0;\n\n\treset_control_reset(xhci->reset);\n\n\t \n\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\tusb_enable_intel_xhci_ports(pdev);\n\n\tif (xhci->quirks & XHCI_SSIC_PORT_UNUSED)\n\t\txhci_ssic_port_unused_quirk(hcd, false);\n\n\tif (xhci->quirks & XHCI_PME_STUCK_QUIRK)\n\t\txhci_pme_quirk(hcd);\n\n\tretval = xhci_resume(xhci, msg);\n\treturn retval;\n}\n\nstatic int xhci_pci_poweroff_late(struct usb_hcd *hcd, bool do_wakeup)\n{\n\tstruct xhci_hcd\t\t*xhci = hcd_to_xhci(hcd);\n\tstruct xhci_port\t*port;\n\tstruct usb_device\t*udev;\n\tunsigned int\t\tslot_id;\n\tu32\t\t\tportsc;\n\tint\t\t\ti;\n\n\t \n\n\tif (!(xhci->quirks & XHCI_RESET_TO_DEFAULT))\n\t\treturn 0;\n\n\tfor (i = 0; i < HCS_MAX_PORTS(xhci->hcs_params1); i++) {\n\t\tport = &xhci->hw_ports[i];\n\t\tportsc = readl(port->addr);\n\n\t\tif ((portsc & PORT_PLS_MASK) != XDEV_U3)\n\t\t\tcontinue;\n\n\t\tslot_id = xhci_find_slot_id_by_port(port->rhub->hcd, xhci,\n\t\t\t\t\t\t    port->hcd_portnum + 1);\n\t\tif (!slot_id || !xhci->devs[slot_id]) {\n\t\t\txhci_err(xhci, \"No dev for slot_id %d for port %d-%d in U3\\n\",\n\t\t\t\t slot_id, port->rhub->hcd->self.busnum, port->hcd_portnum + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tudev = xhci->devs[slot_id]->udev;\n\n\t\t \n\t\tif (udev->do_remote_wakeup && do_wakeup)\n\t\t\tcontinue;\n\n\t\txhci_dbg(xhci, \"port %d-%d in U3 without wakeup, disable it\\n\",\n\t\t\t port->rhub->hcd->self.busnum, port->hcd_portnum + 1);\n\t\tportsc = xhci_port_state_to_neutral(portsc);\n\t\twritel(portsc | PORT_PE, port->addr);\n\t}\n\n\treturn 0;\n}\n\nstatic void xhci_pci_shutdown(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t\t*xhci = hcd_to_xhci(hcd);\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\n\txhci_shutdown(hcd);\n\txhci_cleanup_msix(xhci);\n\n\t \n\tif (xhci->quirks & XHCI_SPURIOUS_WAKEUP)\n\t\tpci_set_power_state(pdev, PCI_D3hot);\n}\n\n \n\nstatic const struct xhci_driver_data reneses_data = {\n\t.quirks  = XHCI_RENESAS_FW_QUIRK,\n\t.firmware = \"renesas_usb_fw.mem\",\n};\n\n \nstatic const struct pci_device_id pci_ids[] = {\n\t{ PCI_DEVICE(0x1912, 0x0014),\n\t\t.driver_data =  (unsigned long)&reneses_data,\n\t},\n\t{ PCI_DEVICE(0x1912, 0x0015),\n\t\t.driver_data =  (unsigned long)&reneses_data,\n\t},\n\t \n\t{ PCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_XHCI, ~0),\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\n \n#if IS_ENABLED(CONFIG_USB_XHCI_PCI_RENESAS)\nMODULE_FIRMWARE(\"renesas_usb_fw.mem\");\n#endif\n\n \nstatic struct pci_driver xhci_pci_driver = {\n\t.name =\t\thcd_name,\n\t.id_table =\tpci_ids,\n\n\t.probe =\txhci_pci_probe,\n\t.remove =\txhci_pci_remove,\n\t \n\n\t.shutdown = \tusb_hcd_pci_shutdown,\n\t.driver = {\n\t\t.pm = pm_ptr(&usb_hcd_pci_pm_ops),\n\t},\n};\n\nstatic int __init xhci_pci_init(void)\n{\n\txhci_init_driver(&xhci_pci_hc_driver, &xhci_pci_overrides);\n\txhci_pci_hc_driver.pci_suspend = pm_ptr(xhci_pci_suspend);\n\txhci_pci_hc_driver.pci_resume = pm_ptr(xhci_pci_resume);\n\txhci_pci_hc_driver.pci_poweroff_late = pm_ptr(xhci_pci_poweroff_late);\n\txhci_pci_hc_driver.shutdown = pm_ptr(xhci_pci_shutdown);\n\txhci_pci_hc_driver.stop = xhci_pci_stop;\n\treturn pci_register_driver(&xhci_pci_driver);\n}\nmodule_init(xhci_pci_init);\n\nstatic void __exit xhci_pci_exit(void)\n{\n\tpci_unregister_driver(&xhci_pci_driver);\n}\nmodule_exit(xhci_pci_exit);\n\nMODULE_DESCRIPTION(\"xHCI PCI Host Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}