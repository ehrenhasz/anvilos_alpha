{
  "module_name": "max3421-hcd.c",
  "hash_id": "da6b1d304c9cda7389fa7975d78695d3b394c121d0817f8d5e326de0e20167dd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/max3421-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/jiffies.h>\n#include <linux/module.h>\n#include <linux/spi/spi.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/of.h>\n\n#include <linux/platform_data/max3421-hcd.h>\n\n#define DRIVER_DESC\t\"MAX3421 USB Host-Controller Driver\"\n#define DRIVER_VERSION\t\"1.0\"\n\n \n#define USB_MAX_FRAME_NUMBER\t0x7ff\n#define USB_MAX_RETRIES\t\t3  \n\n#define POWER_BUDGET\t500\t \n\n \n#define PORT_C_MASK\t((USB_PORT_STAT_C_CONNECTION |\t\\\n\t\t\t  USB_PORT_STAT_C_ENABLE |\t\\\n\t\t\t  USB_PORT_STAT_C_SUSPEND |\t\\\n\t\t\t  USB_PORT_STAT_C_OVERCURRENT | \\\n\t\t\t  USB_PORT_STAT_C_RESET) << 16)\n\n#define MAX3421_GPOUT_COUNT\t8\n\nenum max3421_rh_state {\n\tMAX3421_RH_RESET,\n\tMAX3421_RH_SUSPENDED,\n\tMAX3421_RH_RUNNING\n};\n\nenum pkt_state {\n\tPKT_STATE_SETUP,\t \n\tPKT_STATE_TRANSFER,\t \n\tPKT_STATE_TERMINATE\t \n};\n\nenum scheduling_pass {\n\tSCHED_PASS_PERIODIC,\n\tSCHED_PASS_NON_PERIODIC,\n\tSCHED_PASS_DONE\n};\n\n \nenum {\n\tENABLE_IRQ = 0,\n\tRESET_HCD,\n\tRESET_PORT,\n\tCHECK_UNLINK,\n\tIOPIN_UPDATE\n};\n\nstruct max3421_dma_buf {\n\tu8 data[2];\n};\n\nstruct max3421_hcd {\n\tspinlock_t lock;\n\n\tstruct task_struct *spi_thread;\n\n\tenum max3421_rh_state rh_state;\n\t \n\tu32 port_status;\n\n\tunsigned active:1;\n\n\tstruct list_head ep_list;\t \n\n\t \n\tu8 rev;\t\t\t\t \n\tu16 frame_number;\n\t \n\tstruct max3421_dma_buf *tx;\n\tstruct max3421_dma_buf *rx;\n\t \n\tstruct urb *curr_urb;\n\tenum scheduling_pass sched_pass;\n\tint urb_done;\t\t\t \n\tsize_t curr_len;\n\tu8 hien;\n\tu8 mode;\n\tu8 iopins[2];\n\tunsigned long todo;\n#ifdef DEBUG\n\tunsigned long err_stat[16];\n#endif\n};\n\nstruct max3421_ep {\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head ep_list;\n\tu32 naks;\n\tu16 last_active;\t\t \n\tenum pkt_state pkt_state;\n\tu8 retries;\n\tu8 retransmit;\t\t\t \n};\n\n#define MAX3421_FIFO_SIZE\t64\n\n#define MAX3421_SPI_DIR_RD\t0\t \n#define MAX3421_SPI_DIR_WR\t1\t \n\n \n#define MAX3421_SPI_DIR_SHIFT\t1\n#define MAX3421_SPI_REG_SHIFT\t3\n\n#define MAX3421_REG_RCVFIFO\t1\n#define MAX3421_REG_SNDFIFO\t2\n#define MAX3421_REG_SUDFIFO\t4\n#define MAX3421_REG_RCVBC\t6\n#define MAX3421_REG_SNDBC\t7\n#define MAX3421_REG_USBIRQ\t13\n#define MAX3421_REG_USBIEN\t14\n#define MAX3421_REG_USBCTL\t15\n#define MAX3421_REG_CPUCTL\t16\n#define MAX3421_REG_PINCTL\t17\n#define MAX3421_REG_REVISION\t18\n#define MAX3421_REG_IOPINS1\t20\n#define MAX3421_REG_IOPINS2\t21\n#define MAX3421_REG_GPINIRQ\t22\n#define MAX3421_REG_GPINIEN\t23\n#define MAX3421_REG_GPINPOL\t24\n#define MAX3421_REG_HIRQ\t25\n#define MAX3421_REG_HIEN\t26\n#define MAX3421_REG_MODE\t27\n#define MAX3421_REG_PERADDR\t28\n#define MAX3421_REG_HCTL\t29\n#define MAX3421_REG_HXFR\t30\n#define MAX3421_REG_HRSL\t31\n\nenum {\n\tMAX3421_USBIRQ_OSCOKIRQ_BIT = 0,\n\tMAX3421_USBIRQ_NOVBUSIRQ_BIT = 5,\n\tMAX3421_USBIRQ_VBUSIRQ_BIT\n};\n\nenum {\n\tMAX3421_CPUCTL_IE_BIT = 0,\n\tMAX3421_CPUCTL_PULSEWID0_BIT = 6,\n\tMAX3421_CPUCTL_PULSEWID1_BIT\n};\n\nenum {\n\tMAX3421_USBCTL_PWRDOWN_BIT = 4,\n\tMAX3421_USBCTL_CHIPRES_BIT\n};\n\nenum {\n\tMAX3421_PINCTL_GPXA_BIT\t= 0,\n\tMAX3421_PINCTL_GPXB_BIT,\n\tMAX3421_PINCTL_POSINT_BIT,\n\tMAX3421_PINCTL_INTLEVEL_BIT,\n\tMAX3421_PINCTL_FDUPSPI_BIT,\n\tMAX3421_PINCTL_EP0INAK_BIT,\n\tMAX3421_PINCTL_EP2INAK_BIT,\n\tMAX3421_PINCTL_EP3INAK_BIT,\n};\n\nenum {\n\tMAX3421_HI_BUSEVENT_BIT = 0,\t \n\tMAX3421_HI_RWU_BIT,\t\t \n\tMAX3421_HI_RCVDAV_BIT,\t\t \n\tMAX3421_HI_SNDBAV_BIT,\t\t \n\tMAX3421_HI_SUSDN_BIT,\t\t \n\tMAX3421_HI_CONDET_BIT,\t\t \n\tMAX3421_HI_FRAME_BIT,\t\t \n\tMAX3421_HI_HXFRDN_BIT,\t\t \n};\n\nenum {\n\tMAX3421_HCTL_BUSRST_BIT = 0,\n\tMAX3421_HCTL_FRMRST_BIT,\n\tMAX3421_HCTL_SAMPLEBUS_BIT,\n\tMAX3421_HCTL_SIGRSM_BIT,\n\tMAX3421_HCTL_RCVTOG0_BIT,\n\tMAX3421_HCTL_RCVTOG1_BIT,\n\tMAX3421_HCTL_SNDTOG0_BIT,\n\tMAX3421_HCTL_SNDTOG1_BIT\n};\n\nenum {\n\tMAX3421_MODE_HOST_BIT = 0,\n\tMAX3421_MODE_LOWSPEED_BIT,\n\tMAX3421_MODE_HUBPRE_BIT,\n\tMAX3421_MODE_SOFKAENAB_BIT,\n\tMAX3421_MODE_SEPIRQ_BIT,\n\tMAX3421_MODE_DELAYISO_BIT,\n\tMAX3421_MODE_DMPULLDN_BIT,\n\tMAX3421_MODE_DPPULLDN_BIT\n};\n\nenum {\n\tMAX3421_HRSL_OK = 0,\n\tMAX3421_HRSL_BUSY,\n\tMAX3421_HRSL_BADREQ,\n\tMAX3421_HRSL_UNDEF,\n\tMAX3421_HRSL_NAK,\n\tMAX3421_HRSL_STALL,\n\tMAX3421_HRSL_TOGERR,\n\tMAX3421_HRSL_WRONGPID,\n\tMAX3421_HRSL_BADBC,\n\tMAX3421_HRSL_PIDERR,\n\tMAX3421_HRSL_PKTERR,\n\tMAX3421_HRSL_CRCERR,\n\tMAX3421_HRSL_KERR,\n\tMAX3421_HRSL_JERR,\n\tMAX3421_HRSL_TIMEOUT,\n\tMAX3421_HRSL_BABBLE,\n\tMAX3421_HRSL_RESULT_MASK = 0xf,\n\tMAX3421_HRSL_RCVTOGRD_BIT = 4,\n\tMAX3421_HRSL_SNDTOGRD_BIT,\n\tMAX3421_HRSL_KSTATUS_BIT,\n\tMAX3421_HRSL_JSTATUS_BIT\n};\n\n \nstatic const int hrsl_to_error[] = {\n\t[MAX3421_HRSL_OK] =\t\t0,\n\t[MAX3421_HRSL_BUSY] =\t\t-EINVAL,\n\t[MAX3421_HRSL_BADREQ] =\t\t-EINVAL,\n\t[MAX3421_HRSL_UNDEF] =\t\t-EINVAL,\n\t[MAX3421_HRSL_NAK] =\t\t-EAGAIN,\n\t[MAX3421_HRSL_STALL] =\t\t-EPIPE,\n\t[MAX3421_HRSL_TOGERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_WRONGPID] =\t-EPROTO,\n\t[MAX3421_HRSL_BADBC] =\t\t-EREMOTEIO,\n\t[MAX3421_HRSL_PIDERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_PKTERR] =\t\t-EPROTO,\n\t[MAX3421_HRSL_CRCERR] =\t\t-EILSEQ,\n\t[MAX3421_HRSL_KERR] =\t\t-EIO,\n\t[MAX3421_HRSL_JERR] =\t\t-EIO,\n\t[MAX3421_HRSL_TIMEOUT] =\t-ETIME,\n\t[MAX3421_HRSL_BABBLE] =\t\t-EOVERFLOW\n};\n\n \n#define MAX3421_HXFR_BULK_IN(ep)\t(0x00 | (ep))\t \n#define MAX3421_HXFR_SETUP\t\t 0x10\n#define MAX3421_HXFR_BULK_OUT(ep)\t(0x20 | (ep))\t \n#define MAX3421_HXFR_ISO_IN(ep)\t\t(0x40 | (ep))\n#define MAX3421_HXFR_ISO_OUT(ep)\t(0x60 | (ep))\n#define MAX3421_HXFR_HS_IN\t\t 0x80\t\t \n#define MAX3421_HXFR_HS_OUT\t\t 0xa0\t\t \n\n#define field(val, bit)\t((val) << (bit))\n\nstatic inline s16\nframe_diff(u16 left, u16 right)\n{\n\treturn ((unsigned) (left - right)) % (USB_MAX_FRAME_NUMBER + 1);\n}\n\nstatic inline struct max3421_hcd *\nhcd_to_max3421(struct usb_hcd *hcd)\n{\n\treturn (struct max3421_hcd *) hcd->hcd_priv;\n}\n\nstatic inline struct usb_hcd *\nmax3421_to_hcd(struct max3421_hcd *max3421_hcd)\n{\n\treturn container_of((void *) max3421_hcd, struct usb_hcd, hcd_priv);\n}\n\nstatic u8\nspi_rd8(struct usb_hcd *hcd, unsigned int reg)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.rx_buf = max3421_hcd->rx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n\n\treturn max3421_hcd->rx->data[1];\n}\n\nstatic void\nspi_wr8(struct usb_hcd *hcd, unsigned int reg, u8 val)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer;\n\tstruct spi_message msg;\n\n\tmemset(&transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\tmax3421_hcd->tx->data[1] = val;\n\n\ttransfer.tx_buf = max3421_hcd->tx->data;\n\ttransfer.len = 2;\n\n\tspi_message_add_tail(&transfer, &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_rd_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_RD, MAX3421_SPI_DIR_SHIFT));\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].rx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\nstatic void\nspi_wr_buf(struct usb_hcd *hcd, unsigned int reg, void *buf, size_t len)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct spi_transfer transfer[2];\n\tstruct spi_message msg;\n\n\tmemset(transfer, 0, sizeof(transfer));\n\n\tspi_message_init(&msg);\n\n\tmax3421_hcd->tx->data[0] =\n\t\t(field(reg, MAX3421_SPI_REG_SHIFT) |\n\t\t field(MAX3421_SPI_DIR_WR, MAX3421_SPI_DIR_SHIFT));\n\n\ttransfer[0].tx_buf = max3421_hcd->tx->data;\n\ttransfer[0].len = 1;\n\n\ttransfer[1].tx_buf = buf;\n\ttransfer[1].len = len;\n\n\tspi_message_add_tail(&transfer[0], &msg);\n\tspi_message_add_tail(&transfer[1], &msg);\n\tspi_sync(spi, &msg);\n}\n\n \nstatic void\nmax3421_set_speed(struct usb_hcd *hcd, struct usb_device *dev)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mode_lowspeed, mode_hubpre, mode = max3421_hcd->mode;\n\n\tmode_lowspeed = BIT(MAX3421_MODE_LOWSPEED_BIT);\n\tmode_hubpre   = BIT(MAX3421_MODE_HUBPRE_BIT);\n\tif (max3421_hcd->port_status & USB_PORT_STAT_LOW_SPEED) {\n\t\tmode |=  mode_lowspeed;\n\t\tmode &= ~mode_hubpre;\n\t} else if (dev->speed == USB_SPEED_LOW) {\n\t\tmode |= mode_lowspeed | mode_hubpre;\n\t} else {\n\t\tmode &= ~(mode_lowspeed | mode_hubpre);\n\t}\n\tif (mode != max3421_hcd->mode) {\n\t\tmax3421_hcd->mode = mode;\n\t\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\t}\n\n}\n\n \nstatic void\nmax3421_set_address(struct usb_hcd *hcd, struct usb_device *dev, int epnum)\n{\n\tint rcvtog, sndtog;\n\tu8 hctl;\n\n\t \n\trcvtog = usb_gettoggle(dev, epnum, 0);\n\tsndtog = usb_gettoggle(dev, epnum, 1);\n\thctl = (BIT(rcvtog + MAX3421_HCTL_RCVTOG0_BIT) |\n\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\n\tspi_wr8(hcd, MAX3421_REG_HCTL, hctl);\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_PERADDR, dev->devnum);\n}\n\nstatic int\nmax3421_ctrl_setup(struct usb_hcd *hcd, struct urb *urb)\n{\n\tspi_wr_buf(hcd, MAX3421_REG_SUDFIFO, urb->setup_packet, 8);\n\treturn MAX3421_HXFR_SETUP;\n}\n\nstatic int\nmax3421_transfer_in(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\n\tmax3421_hcd->curr_len = 0;\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_RCVDAV_BIT);\n\treturn MAX3421_HXFR_BULK_IN(epnum);\n}\n\nstatic int\nmax3421_transfer_out(struct usb_hcd *hcd, struct urb *urb, int fast_retransmit)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint epnum = usb_pipeendpoint(urb->pipe);\n\tu32 max_packet;\n\tvoid *src;\n\n\tsrc = urb->transfer_buffer + urb->actual_length;\n\n\tif (fast_retransmit) {\n\t\tif (max3421_hcd->rev == 0x12) {\n\t\t\t \n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDFIFO, ((u8 *) src)[0]);\n\t\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\t\t}\n\t\treturn MAX3421_HXFR_BULK_OUT(epnum);\n\t}\n\n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe);\n\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t \n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\tmax3421_hcd->urb_done = -EMSGSIZE;\n\t\treturn -EMSGSIZE;\n\t}\n\tmax3421_hcd->curr_len = min((urb->transfer_buffer_length -\n\t\t\t\t     urb->actual_length), max_packet);\n\n\tspi_wr_buf(hcd, MAX3421_REG_SNDFIFO, src, max3421_hcd->curr_len);\n\tspi_wr8(hcd, MAX3421_REG_SNDBC, max3421_hcd->curr_len);\n\treturn MAX3421_HXFR_BULK_OUT(epnum);\n}\n\n \nstatic void\nmax3421_next_transfer(struct usb_hcd *hcd, int fast_retransmit)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tint cmd = -EINVAL;\n\n\tif (!urb)\n\t\treturn;\t \n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tswitch (max3421_ep->pkt_state) {\n\tcase PKT_STATE_SETUP:\n\t\tcmd = max3421_ctrl_setup(hcd, urb);\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = max3421_transfer_in(hcd, urb);\n\t\telse\n\t\t\tcmd = max3421_transfer_out(hcd, urb, fast_retransmit);\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\t \n\t\tif (usb_urb_dir_in(urb))\n\t\t\tcmd = MAX3421_HXFR_HS_OUT;\n\t\telse\n\t\t\tcmd = MAX3421_HXFR_HS_IN;\n\t\tbreak;\n\t}\n\n\tif (cmd < 0)\n\t\treturn;\n\n\t \n\n\tspi_wr8(hcd, MAX3421_REG_HXFR, cmd);\n\tmax3421_hcd->hien |= BIT(MAX3421_HI_HXFRDN_BIT);\n}\n\n \nstatic int\nmax3421_select_and_start_urb(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb, *curr_urb = NULL;\n\tstruct max3421_ep *max3421_ep;\n\tint epnum;\n\tstruct usb_host_endpoint *ep;\n\tstruct list_head *pos;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tfor (;\n\t     max3421_hcd->sched_pass < SCHED_PASS_DONE;\n\t     ++max3421_hcd->sched_pass)\n\t\tlist_for_each(pos, &max3421_hcd->ep_list) {\n\t\t\turb = NULL;\n\t\t\tmax3421_ep = container_of(pos, struct max3421_ep,\n\t\t\t\t\t\t  ep_list);\n\t\t\tep = max3421_ep->ep;\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_hcd->sched_pass !=\n\t\t\t\t    SCHED_PASS_NON_PERIODIC)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (list_empty(&ep->urb_list))\n\t\t\t\tcontinue;\t \n\t\t\turb = list_first_entry(&ep->urb_list, struct urb,\n\t\t\t\t\t       urb_list);\n\t\t\tif (urb->unlinked) {\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tmax3421_hcd->curr_urb = urb;\n\t\t\t\tmax3421_hcd->urb_done = 1;\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tswitch (usb_endpoint_type(&ep->desc)) {\n\t\t\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\t\t\t \n\t\t\t\tif (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t       max3421_hcd->frame_number) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_BULK:\n\t\t\t\tif (max3421_ep->retransmit\n\t\t\t\t    && (frame_diff(max3421_ep->last_active,\n\t\t\t\t\t\t   max3421_hcd->frame_number)\n\t\t\t\t\t== 0))\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\n\t\t\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t\tcase USB_ENDPOINT_XFER_INT:\n\t\t\t\tif (frame_diff(max3421_hcd->frame_number,\n\t\t\t\t\t       max3421_ep->last_active)\n\t\t\t\t    < urb->interval)\n\t\t\t\t\t \n\t\t\t\t\tcontinue;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tlist_move_tail(pos, &max3421_hcd->ep_list);\n\t\t\tcurr_urb = urb;\n\t\t\tgoto done;\n\t\t}\ndone:\n\tif (!curr_urb) {\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\t\treturn 0;\n\t}\n\n\turb = max3421_hcd->curr_urb = curr_urb;\n\tepnum = usb_endpoint_num(&urb->ep->desc);\n\tif (max3421_ep->retransmit)\n\t\t \n\t\tmax3421_ep->retransmit = 0;\n\telse {\n\t\t \n\t\tif (usb_endpoint_xfer_control(&ep->desc)) {\n\t\t\t \n\t\t\tusb_settoggle(urb->dev, epnum, 0, 1);\n\t\t\tusb_settoggle(urb->dev, epnum, 1, 1);\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_SETUP;\n\t\t} else\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\tmax3421_set_address(hcd, urb->dev, epnum);\n\tmax3421_set_speed(hcd, urb->dev);\n\tmax3421_next_transfer(hcd, 0);\n\treturn 1;\n}\n\n \nstatic int\nmax3421_check_unlink(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tstruct urb *urb, *next;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\t\tlist_for_each_entry_safe(urb, next, &ep->urb_list, urb_list) {\n\t\t\tif (urb->unlinked) {\n\t\t\t\tretval = 1;\n\t\t\t\tdev_dbg(&spi->dev, \"%s: URB %p unlinked=%d\",\n\t\t\t\t\t__func__, urb, urb->unlinked);\n\t\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\t\tspin_unlock_irqrestore(&max3421_hcd->lock,\n\t\t\t\t\t\t       flags);\n\t\t\t\tusb_hcd_giveback_urb(hcd, urb, 0);\n\t\t\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\n \nstatic void\nmax3421_slow_retransmit(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tmax3421_ep->retransmit = 1;\n\tmax3421_hcd->curr_urb = NULL;\n}\n\n \nstatic void\nmax3421_recv_data_available(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tsize_t remaining, transfer_size;\n\tu8 rcvbc;\n\n\trcvbc = spi_rd8(hcd, MAX3421_REG_RCVBC);\n\n\tif (rcvbc > MAX3421_FIFO_SIZE)\n\t\trcvbc = MAX3421_FIFO_SIZE;\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\tremaining = 0;\n\telse\n\t\tremaining = urb->transfer_buffer_length - urb->actual_length;\n\ttransfer_size = rcvbc;\n\tif (transfer_size > remaining)\n\t\ttransfer_size = remaining;\n\tif (transfer_size > 0) {\n\t\tvoid *dst = urb->transfer_buffer + urb->actual_length;\n\n\t\tspi_rd_buf(hcd, MAX3421_REG_RCVFIFO, dst, transfer_size);\n\t\turb->actual_length += transfer_size;\n\t\tmax3421_hcd->curr_len = transfer_size;\n\t}\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_HIRQ, BIT(MAX3421_HI_RCVDAV_BIT));\n}\n\nstatic void\nmax3421_handle_error(struct usb_hcd *hcd, u8 hrsl)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 result_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep = urb->ep->hcpriv;\n\tint switch_sndfifo;\n\n\t \n\tswitch_sndfifo = (max3421_ep->pkt_state == PKT_STATE_TRANSFER &&\n\t\t\t  usb_urb_dir_out(urb));\n\n\tswitch (result_code) {\n\tcase MAX3421_HRSL_OK:\n\t\treturn;\t\t\t \n\n\tcase MAX3421_HRSL_WRONGPID:\t \n\tcase MAX3421_HRSL_BUSY:\t\t \n\tcase MAX3421_HRSL_BADREQ:\t \n\tcase MAX3421_HRSL_UNDEF:\t \n\tcase MAX3421_HRSL_KERR:\t\t \n\tcase MAX3421_HRSL_JERR:\t\t \n\t\t \n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tbreak;\n\n\tcase MAX3421_HRSL_TOGERR:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\t;  \n\t\telse {\n\t\t\t \n\t\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\n\t\t\tsndtog ^= 1;\n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(sndtog + MAX3421_HCTL_SNDTOG0_BIT));\n\t\t}\n\t\tfallthrough;\n\tcase MAX3421_HRSL_BADBC:\t \n\tcase MAX3421_HRSL_PIDERR:\t \n\tcase MAX3421_HRSL_PKTERR:\t \n\tcase MAX3421_HRSL_CRCERR:\t \n\tcase MAX3421_HRSL_BABBLE:\t \n\tcase MAX3421_HRSL_TIMEOUT:\n\t\tif (max3421_ep->retries++ < USB_MAX_RETRIES)\n\t\t\t \n\t\t\tmax3421_slow_retransmit(hcd);\n\t\telse {\n\t\t\t \n\t\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t\t__func__, hrsl);\n\t\t}\n\t\tbreak;\n\n\tcase MAX3421_HRSL_STALL:\n\t\tdev_dbg(&spi->dev, \"%s: unexpected error HRSL=0x%02x\",\n\t\t\t__func__, hrsl);\n\t\tmax3421_hcd->urb_done = hrsl_to_error[result_code];\n\t\tbreak;\n\n\tcase MAX3421_HRSL_NAK:\n\t\t \n\t\tmax3421_next_transfer(hcd, 1);\n\t\tswitch_sndfifo = 0;\n\t\tbreak;\n\t}\n\tif (switch_sndfifo)\n\t\tspi_wr8(hcd, MAX3421_REG_SNDBC, 0);\n}\n\n \nstatic int\nmax3421_transfer_in_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 max_packet;\n\n\tif (urb->actual_length >= urb->transfer_buffer_length)\n\t\treturn 1;\t \n\n\t \n\tmax_packet = usb_maxpacket(urb->dev, urb->pipe);\n\tif (max_packet > MAX3421_FIFO_SIZE) {\n\t\t \n\t\tdev_err(&spi->dev,\n\t\t\t\"%s: packet-size of %u too big (limit is %u bytes)\",\n\t\t\t__func__, max_packet, MAX3421_FIFO_SIZE);\n\t\treturn -EINVAL;\n\t}\n\n\tif (max3421_hcd->curr_len < max_packet) {\n\t\tif (urb->transfer_flags & URB_SHORT_NOT_OK) {\n\t\t\t \n\t\t\treturn -EREMOTEIO;\n\t\t} else\n\t\t\t \n\t\t\treturn 1;\n\t}\n\treturn 0;\t \n}\n\n \nstatic int\nmax3421_transfer_out_done(struct usb_hcd *hcd, struct urb *urb)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\turb->actual_length += max3421_hcd->curr_len;\n\tif (urb->actual_length < urb->transfer_buffer_length)\n\t\treturn 0;\n\tif (urb->transfer_flags & URB_ZERO_PACKET) {\n\t\t \n\t\tu32 max_packet = usb_maxpacket(urb->dev, urb->pipe);\n\n\t\tif (max3421_hcd->curr_len == max_packet)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n \nstatic void\nmax3421_host_transfer_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct urb *urb = max3421_hcd->curr_urb;\n\tstruct max3421_ep *max3421_ep;\n\tu8 result_code, hrsl;\n\tint urb_done = 0;\n\n\tmax3421_hcd->hien &= ~(BIT(MAX3421_HI_HXFRDN_BIT) |\n\t\t\t       BIT(MAX3421_HI_RCVDAV_BIT));\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\tresult_code = hrsl & MAX3421_HRSL_RESULT_MASK;\n\n#ifdef DEBUG\n\t++max3421_hcd->err_stat[result_code];\n#endif\n\n\tmax3421_ep = urb->ep->hcpriv;\n\n\tif (unlikely(result_code != MAX3421_HRSL_OK)) {\n\t\tmax3421_handle_error(hcd, hrsl);\n\t\treturn;\n\t}\n\n\tmax3421_ep->naks = 0;\n\tmax3421_ep->retries = 0;\n\tswitch (max3421_ep->pkt_state) {\n\n\tcase PKT_STATE_SETUP:\n\t\tif (urb->transfer_buffer_length > 0)\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TRANSFER;\n\t\telse\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\tbreak;\n\n\tcase PKT_STATE_TRANSFER:\n\t\tif (usb_urb_dir_in(urb))\n\t\t\turb_done = max3421_transfer_in_done(hcd, urb);\n\t\telse\n\t\t\turb_done = max3421_transfer_out_done(hcd, urb);\n\t\tif (urb_done > 0 && usb_pipetype(urb->pipe) == PIPE_CONTROL) {\n\t\t\t \n\t\t\tmax3421_hcd->urb_done = urb_done = 0;\n\t\t\tmax3421_ep->pkt_state = PKT_STATE_TERMINATE;\n\t\t}\n\t\tbreak;\n\n\tcase PKT_STATE_TERMINATE:\n\t\turb_done = 1;\n\t\tbreak;\n\t}\n\n\tif (urb_done)\n\t\tmax3421_hcd->urb_done = urb_done;\n\telse\n\t\tmax3421_next_transfer(hcd, 0);\n}\n\n \nstatic void\nmax3421_detect_conn(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned int jk, have_conn = 0;\n\tu32 old_port_status, chg;\n\tunsigned long flags;\n\tu8 hrsl, mode;\n\n\thrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\n\tjk = ((((hrsl >> MAX3421_HRSL_JSTATUS_BIT) & 1) << 0) |\n\t      (((hrsl >> MAX3421_HRSL_KSTATUS_BIT) & 1) << 1));\n\n\tmode = max3421_hcd->mode;\n\n\tswitch (jk) {\n\tcase 0x0:  \n\t\t \n\t\tmode &= ~BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\tbreak;\n\n\tcase 0x1:  \n\tcase 0x2:  \n\t\tif (jk == 0x2)\n\t\t\t \n\t\t\tmode ^= BIT(MAX3421_MODE_LOWSPEED_BIT);\n\t\t \n\t\tmode |= BIT(MAX3421_MODE_SOFKAENAB_BIT);\n\t\thave_conn = 1;\n\t\tbreak;\n\n\tcase 0x3:  \n\t\tbreak;\n\t}\n\n\tmax3421_hcd->mode = mode;\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\told_port_status = max3421_hcd->port_status;\n\tif (have_conn)\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_CONNECTION;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_CONNECTION;\n\tif (mode & BIT(MAX3421_MODE_LOWSPEED_BIT))\n\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_LOW_SPEED;\n\telse\n\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_LOW_SPEED;\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic irqreturn_t\nmax3421_irq_handler(int irq, void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tif (max3421_hcd->spi_thread)\n\t\twake_up_process(max3421_hcd->spi_thread);\n\tif (!test_and_set_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\tdisable_irq_nosync(spi->irq);\n\treturn IRQ_HANDLED;\n}\n\n#ifdef DEBUG\n\nstatic void\ndump_eps(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tstruct usb_host_endpoint *ep;\n\tchar ubuf[512], *dp, *end;\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint epnum, ret;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tlist_for_each_entry(max3421_ep, &max3421_hcd->ep_list, ep_list) {\n\t\tep = max3421_ep->ep;\n\n\t\tdp = ubuf;\n\t\tend = dp + sizeof(ubuf);\n\t\t*dp = '\\0';\n\t\tlist_for_each_entry(urb, &ep->urb_list, urb_list) {\n\t\t\tret = snprintf(dp, end - dp, \" %p(%d.%s %d/%d)\", urb,\n\t\t\t\t       usb_pipetype(urb->pipe),\n\t\t\t\t       usb_urb_dir_in(urb) ? \"IN\" : \"OUT\",\n\t\t\t\t       urb->actual_length,\n\t\t\t\t       urb->transfer_buffer_length);\n\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\tbreak;\t \n\t\t\tdp += ret;\n\t\t}\n\n\t\tepnum = usb_endpoint_num(&ep->desc);\n\t\tpr_info(\"EP%0u %u lst %04u rtr %u nak %6u rxmt %u: %s\\n\",\n\t\t\tepnum, max3421_ep->pkt_state, max3421_ep->last_active,\n\t\t\tmax3421_ep->retries, max3421_ep->naks,\n\t\t\tmax3421_ep->retransmit, ubuf);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\n#endif  \n\n \nstatic int\nmax3421_handle_irqs(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu32 chg, old_port_status;\n\tunsigned long flags;\n\tu8 hirq;\n\n\t \n\thirq = spi_rd8(hcd, MAX3421_REG_HIRQ);\n\thirq &= max3421_hcd->hien;\n\tif (!hirq)\n\t\treturn 0;\n\n\tspi_wr8(hcd, MAX3421_REG_HIRQ,\n\t\thirq & ~(BIT(MAX3421_HI_SNDBAV_BIT) |\n\t\t\t BIT(MAX3421_HI_RCVDAV_BIT)));\n\n\tif (hirq & BIT(MAX3421_HI_FRAME_BIT)) {\n\t\tmax3421_hcd->frame_number = ((max3421_hcd->frame_number + 1)\n\t\t\t\t\t     & USB_MAX_FRAME_NUMBER);\n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t}\n\n\tif (hirq & BIT(MAX3421_HI_RCVDAV_BIT))\n\t\tmax3421_recv_data_available(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_HXFRDN_BIT))\n\t\tmax3421_host_transfer_done(hcd);\n\n\tif (hirq & BIT(MAX3421_HI_CONDET_BIT))\n\t\tmax3421_detect_conn(hcd);\n\n\t \n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\told_port_status = max3421_hcd->port_status;\n\tif (hirq & BIT(MAX3421_HI_BUSEVENT_BIT)) {\n\t\tif (max3421_hcd->port_status & USB_PORT_STAT_RESET) {\n\t\t\t \n\t\t\tmax3421_hcd->port_status &= ~USB_PORT_STAT_RESET;\n\t\t\tmax3421_hcd->port_status |=  USB_PORT_STAT_ENABLE;\n\t\t} else {\n\t\t\t \n\t\t\tpr_info(\"%s: BUSEVENT Bus Resume Done\\n\", __func__);\n\t\t}\n\t}\n\tif (hirq & BIT(MAX3421_HI_RWU_BIT))\n\t\tpr_info(\"%s: RWU\\n\", __func__);\n\tif (hirq & BIT(MAX3421_HI_SUSDN_BIT))\n\t\tpr_info(\"%s: SUSDN\\n\", __func__);\n\n\tchg = (old_port_status ^ max3421_hcd->port_status);\n\tmax3421_hcd->port_status |= chg << 16;\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n#ifdef DEBUG\n\t{\n\t\tstatic unsigned long last_time;\n\t\tchar sbuf[16 * 16], *dp, *end;\n\t\tint i;\n\n\t\tif (time_after(jiffies, last_time + 5*HZ)) {\n\t\t\tdp = sbuf;\n\t\t\tend = sbuf + sizeof(sbuf);\n\t\t\t*dp = '\\0';\n\t\t\tfor (i = 0; i < 16; ++i) {\n\t\t\t\tint ret = snprintf(dp, end - dp, \" %lu\",\n\t\t\t\t\t\t   max3421_hcd->err_stat[i]);\n\t\t\t\tif (ret < 0 || ret >= end - dp)\n\t\t\t\t\tbreak;\t \n\t\t\t\tdp += ret;\n\t\t\t}\n\t\t\tpr_info(\"%s: hrsl_stats %s\\n\", __func__, sbuf);\n\t\t\tmemset(max3421_hcd->err_stat, 0,\n\t\t\t       sizeof(max3421_hcd->err_stat));\n\t\t\tlast_time = jiffies;\n\n\t\t\tdump_eps(hcd);\n\t\t}\n\t}\n#endif\n\treturn 1;\n}\n\nstatic int\nmax3421_reset_hcd(struct usb_hcd *hcd)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint timeout;\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_USBCTL, BIT(MAX3421_USBCTL_CHIPRES_BIT));\n\t \n\tspi_wr8(hcd, MAX3421_REG_USBCTL, 0);\n\ttimeout = 1000;\n\twhile (1) {\n\t\tif (spi_rd8(hcd, MAX3421_REG_USBIRQ)\n\t\t    & BIT(MAX3421_USBIRQ_OSCOKIRQ_BIT))\n\t\t\tbreak;\n\t\tif (--timeout < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t\t\"timed out waiting for oscillator OK signal\");\n\t\t\treturn 1;\n\t\t}\n\t\tcond_resched();\n\t}\n\n\t \n\tmax3421_hcd->mode = (BIT(MAX3421_MODE_HOST_BIT) |\n\t\t\t     BIT(MAX3421_MODE_SOFKAENAB_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DMPULLDN_BIT) |\n\t\t\t     BIT(MAX3421_MODE_DPPULLDN_BIT));\n\tspi_wr8(hcd, MAX3421_REG_MODE, max3421_hcd->mode);\n\n\t \n\tmax3421_hcd->frame_number = USB_MAX_FRAME_NUMBER;\n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_FRMRST_BIT));\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_HCTL, BIT(MAX3421_HCTL_SAMPLEBUS_BIT));\n\tmax3421_detect_conn(hcd);\n\n\t \n\tmax3421_hcd->hien = (BIT(MAX3421_HI_FRAME_BIT) |\n\t\t\t     BIT(MAX3421_HI_CONDET_BIT) |\n\t\t\t     BIT(MAX3421_HI_BUSEVENT_BIT));\n\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_CPUCTL, BIT(MAX3421_CPUCTL_IE_BIT));\n\treturn 1;\n}\n\nstatic int\nmax3421_urb_done(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tstruct urb *urb;\n\tint status;\n\n\tstatus = max3421_hcd->urb_done;\n\tmax3421_hcd->urb_done = 0;\n\tif (status > 0)\n\t\tstatus = 0;\n\turb = max3421_hcd->curr_urb;\n\tif (urb) {\n\t\t \n\t\tu8 hrsl = spi_rd8(hcd, MAX3421_REG_HRSL);\n\t\tint rcvtog = (hrsl >> MAX3421_HRSL_RCVTOGRD_BIT) & 1;\n\t\tint sndtog = (hrsl >> MAX3421_HRSL_SNDTOGRD_BIT) & 1;\n\t\tint epnum = usb_endpoint_num(&urb->ep->desc);\n\n\t\t \n\t\tusb_settoggle(urb->dev, epnum, 0, rcvtog);\n\t\tusb_settoggle(urb->dev, epnum, 1, sndtog);\n\n\t\tmax3421_hcd->curr_urb = NULL;\n\t\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\t\t \n\t\tusb_hcd_giveback_urb(hcd, urb, status);\n\t}\n\treturn 1;\n}\n\nstatic int\nmax3421_spi_thread(void *dev_id)\n{\n\tstruct usb_hcd *hcd = dev_id;\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tint i, i_worked = 1;\n\n\t \n\tspi_wr8(hcd, MAX3421_REG_PINCTL,\n\t\t(BIT(MAX3421_PINCTL_FDUPSPI_BIT) |\t \n\t\t BIT(MAX3421_PINCTL_INTLEVEL_BIT)));\t \n\n\twhile (!kthread_should_stop()) {\n\t\tmax3421_hcd->rev = spi_rd8(hcd, MAX3421_REG_REVISION);\n\t\tif (max3421_hcd->rev == 0x12 || max3421_hcd->rev == 0x13)\n\t\t\tbreak;\n\t\tdev_err(&spi->dev, \"bad rev 0x%02x\", max3421_hcd->rev);\n\t\tmsleep(10000);\n\t}\n\tdev_info(&spi->dev, \"rev 0x%x, SPI clk %dHz, bpw %u, irq %d\\n\",\n\t\t max3421_hcd->rev, spi->max_speed_hz, spi->bits_per_word,\n\t\t spi->irq);\n\n\twhile (!kthread_should_stop()) {\n\t\tif (!i_worked) {\n\t\t\t \n\t\t\tspi_wr8(hcd, MAX3421_REG_HIEN, max3421_hcd->hien);\n\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\tif (test_and_clear_bit(ENABLE_IRQ, &max3421_hcd->todo))\n\t\t\t\tenable_irq(spi->irq);\n\t\t\tschedule();\n\t\t\t__set_current_state(TASK_RUNNING);\n\t\t}\n\n\t\ti_worked = 0;\n\n\t\tif (max3421_hcd->urb_done)\n\t\t\ti_worked |= max3421_urb_done(hcd);\n\t\telse if (max3421_handle_irqs(hcd))\n\t\t\ti_worked = 1;\n\t\telse if (!max3421_hcd->curr_urb)\n\t\t\ti_worked |= max3421_select_and_start_urb(hcd);\n\n\t\tif (test_and_clear_bit(RESET_HCD, &max3421_hcd->todo))\n\t\t\t \n\t\t\ti_worked |= max3421_reset_hcd(hcd);\n\t\tif (test_and_clear_bit(RESET_PORT, &max3421_hcd->todo)) {\n\t\t\t \n\t\t\tspi_wr8(hcd, MAX3421_REG_HCTL,\n\t\t\t\tBIT(MAX3421_HCTL_BUSRST_BIT));\n\t\t\ti_worked = 1;\n\t\t}\n\t\tif (test_and_clear_bit(CHECK_UNLINK, &max3421_hcd->todo))\n\t\t\ti_worked |= max3421_check_unlink(hcd);\n\t\tif (test_and_clear_bit(IOPIN_UPDATE, &max3421_hcd->todo)) {\n\t\t\t \n\t\t\tfor (i = 0; i < ARRAY_SIZE(max3421_hcd->iopins); ++i) {\n\t\t\t\tu8 val = spi_rd8(hcd, MAX3421_REG_IOPINS1 + i);\n\n\t\t\t\tval = ((val & 0xf0) |\n\t\t\t\t       (max3421_hcd->iopins[i] & 0x0f));\n\t\t\t\tspi_wr8(hcd, MAX3421_REG_IOPINS1 + i, val);\n\t\t\t\tmax3421_hcd->iopins[i] = val;\n\t\t\t}\n\t\t\ti_worked = 1;\n\t\t}\n\t}\n\tset_current_state(TASK_RUNNING);\n\tdev_info(&spi->dev, \"SPI thread exiting\");\n\treturn 0;\n}\n\nstatic int\nmax3421_reset_port(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tmax3421_hcd->port_status &= ~(USB_PORT_STAT_ENABLE |\n\t\t\t\t      USB_PORT_STAT_LOW_SPEED);\n\tmax3421_hcd->port_status |= USB_PORT_STAT_RESET;\n\tset_bit(RESET_PORT, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_reset(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\thcd->self.sg_tablesize = 0;\n\thcd->speed = HCD_USB2;\n\thcd->self.root_hub->speed = USB_SPEED_FULL;\n\tset_bit(RESET_HCD, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n\treturn 0;\n}\n\nstatic int\nmax3421_start(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\n\tspin_lock_init(&max3421_hcd->lock);\n\tmax3421_hcd->rh_state = MAX3421_RH_RUNNING;\n\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\n\thcd->power_budget = POWER_BUDGET;\n\thcd->state = HC_STATE_RUNNING;\n\thcd->uses_new_polling = 1;\n\treturn 0;\n}\n\nstatic void\nmax3421_stop(struct usb_hcd *hcd)\n{\n}\n\nstatic int\nmax3421_urb_enqueue(struct usb_hcd *hcd, struct urb *urb, gfp_t mem_flags)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_ep *max3421_ep;\n\tunsigned long flags;\n\tint retval;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_INTERRUPT:\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (urb->interval < 0) {\n\t\t\tdev_err(&spi->dev,\n\t\t\t  \"%s: interval=%d for intr-/iso-pipe; expected > 0\\n\",\n\t\t\t\t__func__, urb->interval);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tmax3421_ep = urb->ep->hcpriv;\n\tif (!max3421_ep) {\n\t\t \n\t\tmax3421_ep = kzalloc(sizeof(struct max3421_ep), GFP_ATOMIC);\n\t\tif (!max3421_ep) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tmax3421_ep->ep = urb->ep;\n\t\tmax3421_ep->last_active = max3421_hcd->frame_number;\n\t\turb->ep->hcpriv = max3421_ep;\n\n\t\tlist_add_tail(&max3421_ep->ep_list, &max3421_hcd->ep_list);\n\t}\n\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval == 0) {\n\t\t \n\t\tmax3421_hcd->sched_pass = SCHED_PASS_PERIODIC;\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\nout:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\t \n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval == 0) {\n\t\tset_bit(CHECK_UNLINK, &max3421_hcd->todo);\n\t\twake_up_process(max3421_hcd->spi_thread);\n\t}\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic void\nmax3421_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tif (ep->hcpriv) {\n\t\tstruct max3421_ep *max3421_ep = ep->hcpriv;\n\n\t\t \n\t\tif (!list_empty(&max3421_ep->ep_list))\n\t\t\tlist_del(&max3421_ep->ep_list);\n\t\tkfree(max3421_ep);\n\t\tep->hcpriv = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n}\n\nstatic int\nmax3421_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\treturn max3421_hcd->frame_number;\n}\n\n \nstatic int\nmax3421_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto done;\n\n\t*buf = 0;\n\tif ((max3421_hcd->port_status & PORT_C_MASK) != 0) {\n\t\t*buf = (1 << 1);  \n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"port status 0x%08x has changes\\n\",\n\t\t\tmax3421_hcd->port_status);\n\t\tretval = 1;\n\t\tif (max3421_hcd->rh_state == MAX3421_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t}\ndone:\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic inline void\nhub_descriptor(struct usb_hub_descriptor *desc)\n{\n\tmemset(desc, 0, sizeof(*desc));\n\t \n\tdesc->bDescriptorType = USB_DT_HUB;  \n\tdesc->bDescLength = 9;\n\tdesc->wHubCharacteristics = cpu_to_le16(HUB_CHAR_INDV_PORT_LPSM |\n\t\t\t\t\t\tHUB_CHAR_COMMON_OCPM);\n\tdesc->bNbrPorts = 1;\n}\n\n \nstatic void\nmax3421_gpout_set_value(struct usb_hcd *hcd, u8 pin_number, u8 value)\n{\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tu8 mask, idx;\n\n\t--pin_number;\n\tif (pin_number >= MAX3421_GPOUT_COUNT)\n\t\treturn;\n\n\tmask = 1u << (pin_number % 4);\n\tidx = pin_number / 4;\n\n\tif (value)\n\t\tmax3421_hcd->iopins[idx] |=  mask;\n\telse\n\t\tmax3421_hcd->iopins[idx] &= ~mask;\n\tset_bit(IOPIN_UPDATE, &max3421_hcd->todo);\n\twake_up_process(max3421_hcd->spi_thread);\n}\n\nstatic int\nmax3421_hub_control(struct usb_hcd *hcd, u16 type_req, u16 value, u16 index,\n\t\t    char *buf, u16 length)\n{\n\tstruct spi_device *spi = to_spi_device(hcd->self.controller);\n\tstruct max3421_hcd *max3421_hcd = hcd_to_max3421(hcd);\n\tstruct max3421_hcd_platform_data *pdata;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tpdata = spi->dev.platform_data;\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tswitch (type_req) {\n\tcase ClearHubFeature:\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-off\\n\");\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\t!pdata->vbus_active_level);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tmax3421_hcd->port_status &= ~(1 << value);\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\thub_descriptor((struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\tcase GetPortErrorCount:\n\tcase SetHubDepth:\n\t\t \n\t\tgoto error;\n\n\tcase GetHubStatus:\n\t\t*(__le32 *) buf = cpu_to_le32(0);\n\t\tbreak;\n\n\tcase GetPortStatus:\n\t\tif (index != 1) {\n\t\t\tretval = -EPIPE;\n\t\t\tgoto error;\n\t\t}\n\t\t((__le16 *) buf)[0] = cpu_to_le16(max3421_hcd->port_status);\n\t\t((__le16 *) buf)[1] =\n\t\t\tcpu_to_le16(max3421_hcd->port_status >> 16);\n\t\tbreak;\n\n\tcase SetHubFeature:\n\t\tretval = -EPIPE;\n\t\tbreak;\n\n\tcase SetPortFeature:\n\t\tswitch (value) {\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\tgoto error;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (max3421_hcd->active)\n\t\t\t\tmax3421_hcd->port_status |=\n\t\t\t\t\tUSB_PORT_STAT_SUSPEND;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"power-on\\n\");\n\t\t\tmax3421_hcd->port_status |= USB_PORT_STAT_POWER;\n\t\t\tmax3421_gpout_set_value(hcd, pdata->vbus_gpout,\n\t\t\t\t\t\tpdata->vbus_active_level);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tmax3421_reset_port(hcd);\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tif ((max3421_hcd->port_status & USB_PORT_STAT_POWER)\n\t\t\t    != 0)\n\t\t\t\tmax3421_hcd->port_status |= (1 << value);\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tdev_dbg(hcd->self.controller,\n\t\t\t\"hub control req%04x v%04x i%04x l%d\\n\",\n\t\t\ttype_req, value, index, length);\nerror:\t\t \n\t\tretval = -EPIPE;\n\t}\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\treturn retval;\n}\n\nstatic int\nmax3421_bus_suspend(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic int\nmax3421_bus_resume(struct usb_hcd *hcd)\n{\n\treturn -1;\n}\n\nstatic const struct hc_driver max3421_hcd_desc = {\n\t.description =\t\t\"max3421\",\n\t.product_desc =\t\tDRIVER_DESC,\n\t.hcd_priv_size =\tsizeof(struct max3421_hcd),\n\t.flags =\t\tHCD_USB11,\n\t.reset =\t\tmax3421_reset,\n\t.start =\t\tmax3421_start,\n\t.stop =\t\t\tmax3421_stop,\n\t.get_frame_number =\tmax3421_get_frame_number,\n\t.urb_enqueue =\t\tmax3421_urb_enqueue,\n\t.urb_dequeue =\t\tmax3421_urb_dequeue,\n\t.endpoint_disable =\tmax3421_endpoint_disable,\n\t.hub_status_data =\tmax3421_hub_status_data,\n\t.hub_control =\t\tmax3421_hub_control,\n\t.bus_suspend =\t\tmax3421_bus_suspend,\n\t.bus_resume =\t\tmax3421_bus_resume,\n};\n\nstatic int\nmax3421_of_vbus_en_pin(struct device *dev, struct max3421_hcd_platform_data *pdata)\n{\n\tint retval;\n\tuint32_t value[2];\n\n\tif (!pdata)\n\t\treturn -EINVAL;\n\n\tretval = of_property_read_u32_array(dev->of_node, \"maxim,vbus-en-pin\", value, 2);\n\tif (retval) {\n\t\tdev_err(dev, \"device tree node property 'maxim,vbus-en-pin' is missing\\n\");\n\t\treturn retval;\n\t}\n\tdev_info(dev, \"property 'maxim,vbus-en-pin' value is <%d %d>\\n\", value[0], value[1]);\n\n\tpdata->vbus_gpout = value[0];\n\tpdata->vbus_active_level = value[1];\n\n\treturn 0;\n}\n\nstatic int\nmax3421_probe(struct spi_device *spi)\n{\n\tstruct device *dev = &spi->dev;\n\tstruct max3421_hcd *max3421_hcd;\n\tstruct usb_hcd *hcd = NULL;\n\tstruct max3421_hcd_platform_data *pdata = NULL;\n\tint retval;\n\n\tif (spi_setup(spi) < 0) {\n\t\tdev_err(&spi->dev, \"Unable to setup SPI bus\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (!spi->irq) {\n\t\tdev_err(dev, \"Failed to get SPI IRQ\");\n\t\treturn -EFAULT;\n\t}\n\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node) {\n\t\tpdata = devm_kzalloc(&spi->dev, sizeof(*pdata), GFP_KERNEL);\n\t\tif (!pdata) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tretval = max3421_of_vbus_en_pin(dev, pdata);\n\t\tif (retval)\n\t\t\tgoto error;\n\n\t\tspi->dev.platform_data = pdata;\n\t}\n\n\tpdata = spi->dev.platform_data;\n\tif (!pdata) {\n\t\tdev_err(&spi->dev, \"driver configuration data is not provided\\n\");\n\t\tretval = -EFAULT;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_active_level > 1) {\n\t\tdev_err(&spi->dev, \"vbus active level value %d is out of range (0/1)\\n\", pdata->vbus_active_level);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\tif (pdata->vbus_gpout < 1 || pdata->vbus_gpout > MAX3421_GPOUT_COUNT) {\n\t\tdev_err(&spi->dev, \"vbus gpout value %d is out of range (1..8)\\n\", pdata->vbus_gpout);\n\t\tretval = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tretval = -ENOMEM;\n\thcd = usb_create_hcd(&max3421_hcd_desc, &spi->dev,\n\t\t\t     dev_name(&spi->dev));\n\tif (!hcd) {\n\t\tdev_err(&spi->dev, \"failed to create HCD structure\\n\");\n\t\tgoto error;\n\t}\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tmax3421_hcd = hcd_to_max3421(hcd);\n\tINIT_LIST_HEAD(&max3421_hcd->ep_list);\n\tspi_set_drvdata(spi, max3421_hcd);\n\n\tmax3421_hcd->tx = kmalloc(sizeof(*max3421_hcd->tx), GFP_KERNEL);\n\tif (!max3421_hcd->tx)\n\t\tgoto error;\n\tmax3421_hcd->rx = kmalloc(sizeof(*max3421_hcd->rx), GFP_KERNEL);\n\tif (!max3421_hcd->rx)\n\t\tgoto error;\n\n\tmax3421_hcd->spi_thread = kthread_run(max3421_spi_thread, hcd,\n\t\t\t\t\t      \"max3421_spi_thread\");\n\tif (max3421_hcd->spi_thread == ERR_PTR(-ENOMEM)) {\n\t\tdev_err(&spi->dev,\n\t\t\t\"failed to create SPI thread (out of memory)\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = usb_add_hcd(hcd, 0, 0);\n\tif (retval) {\n\t\tdev_err(&spi->dev, \"failed to add HCD\\n\");\n\t\tgoto error;\n\t}\n\n\tretval = request_irq(spi->irq, max3421_irq_handler,\n\t\t\t     IRQF_TRIGGER_LOW, \"max3421\", hcd);\n\tif (retval < 0) {\n\t\tdev_err(&spi->dev, \"failed to request irq %d\\n\", spi->irq);\n\t\tgoto error;\n\t}\n\treturn 0;\n\nerror:\n\tif (IS_ENABLED(CONFIG_OF) && dev->of_node && pdata) {\n\t\tdevm_kfree(&spi->dev, pdata);\n\t\tspi->dev.platform_data = NULL;\n\t}\n\n\tif (hcd) {\n\t\tkfree(max3421_hcd->tx);\n\t\tkfree(max3421_hcd->rx);\n\t\tif (max3421_hcd->spi_thread)\n\t\t\tkthread_stop(max3421_hcd->spi_thread);\n\t\tusb_put_hcd(hcd);\n\t}\n\treturn retval;\n}\n\nstatic void\nmax3421_remove(struct spi_device *spi)\n{\n\tstruct max3421_hcd *max3421_hcd;\n\tstruct usb_hcd *hcd;\n\tunsigned long flags;\n\n\tmax3421_hcd = spi_get_drvdata(spi);\n\thcd = max3421_to_hcd(max3421_hcd);\n\n\tusb_remove_hcd(hcd);\n\n\tspin_lock_irqsave(&max3421_hcd->lock, flags);\n\n\tkthread_stop(max3421_hcd->spi_thread);\n\n\tspin_unlock_irqrestore(&max3421_hcd->lock, flags);\n\n\tfree_irq(spi->irq, hcd);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct of_device_id max3421_of_match_table[] = {\n\t{ .compatible = \"maxim,max3421\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, max3421_of_match_table);\n\nstatic struct spi_driver max3421_driver = {\n\t.probe\t\t= max3421_probe,\n\t.remove\t\t= max3421_remove,\n\t.driver\t\t= {\n\t\t.name\t= \"max3421-hcd\",\n\t\t.of_match_table = max3421_of_match_table,\n\t},\n};\n\nmodule_spi_driver(max3421_driver);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Mosberger <davidm@egauge.net>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}