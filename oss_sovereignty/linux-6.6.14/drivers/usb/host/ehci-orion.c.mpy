{
  "module_name": "ehci-orion.c",
  "hash_id": "0b94c61a47b750256103662e2247ae58bcd20f3455f15cbe3c8334e790178ecc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-orion.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/mbus.h>\n#include <linux/clk.h>\n#include <linux/platform_data/usb-ehci-orion.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/io.h>\n#include <linux/dma-mapping.h>\n\n#include \"ehci.h\"\n\n#define rdl(off)\treadl_relaxed(hcd->regs + (off))\n#define wrl(off, val)\twritel_relaxed((val), hcd->regs + (off))\n\n#define USB_CMD\t\t\t0x140\n#define   USB_CMD_RUN\t\tBIT(0)\n#define   USB_CMD_RESET\t\tBIT(1)\n#define USB_MODE\t\t0x1a8\n#define   USB_MODE_MASK\t\tGENMASK(1, 0)\n#define   USB_MODE_DEVICE\t0x2\n#define   USB_MODE_HOST\t\t0x3\n#define   USB_MODE_SDIS\t\tBIT(4)\n#define USB_CAUSE\t\t0x310\n#define USB_MASK\t\t0x314\n#define USB_WINDOW_CTRL(i)\t(0x320 + ((i) << 4))\n#define USB_WINDOW_BASE(i)\t(0x324 + ((i) << 4))\n#define USB_IPG\t\t\t0x360\n#define USB_PHY_PWR_CTRL\t0x400\n#define USB_PHY_TX_CTRL\t\t0x420\n#define USB_PHY_RX_CTRL\t\t0x430\n#define USB_PHY_IVREF_CTRL\t0x440\n#define USB_PHY_TST_GRP_CTRL\t0x450\n\n#define USB_SBUSCFG\t\t0x90\n\n \n#define USB_SBUSCFG_BAWR_ALIGN_128B\t(0x3 << 6)\n#define USB_SBUSCFG_BARD_ALIGN_128B\t(0x3 << 3)\n \n#define USB_SBUSCFG_AHBBRST_INCR16\t(0x3 << 0)\n\n#define USB_SBUSCFG_DEF_VAL (USB_SBUSCFG_BAWR_ALIGN_128B\t\\\n\t\t\t     | USB_SBUSCFG_BARD_ALIGN_128B\t\\\n\t\t\t     | USB_SBUSCFG_AHBBRST_INCR16)\n\n#define DRIVER_DESC \"EHCI orion driver\"\n\n#define hcd_to_orion_priv(h) ((struct orion_ehci_hcd *)hcd_to_ehci(h)->priv)\n\nstruct orion_ehci_hcd {\n\tstruct clk *clk;\n\tstruct phy *phy;\n};\n\nstatic struct hc_driver __read_mostly ehci_orion_hc_driver;\n\n \nstatic void orion_usb_phy_v1_setup(struct usb_hcd *hcd)\n{\n\t \n\t \n\twrl(USB_CAUSE, 0);\n\twrl(USB_MASK, 0);\n\n\t \n\twrl(USB_CMD, rdl(USB_CMD) | USB_CMD_RESET);\n\twhile (rdl(USB_CMD) & USB_CMD_RESET);\n\n\t \n\twrl(USB_IPG, (rdl(USB_IPG) & ~0x7f00) | 0xc00);\n\n\t \n\twrl(USB_PHY_PWR_CTRL, (rdl(USB_PHY_PWR_CTRL) & ~0xc0)| 0x40);\n\n\t \n\twrl(USB_PHY_TX_CTRL, (rdl(USB_PHY_TX_CTRL) & ~0x78) | 0x202040);\n\n\t \n\twrl(USB_PHY_RX_CTRL, (rdl(USB_PHY_RX_CTRL) & ~0xc2003f0) | 0xc0000010);\n\n\t \n\twrl(USB_PHY_IVREF_CTRL, (rdl(USB_PHY_IVREF_CTRL) & ~0x80003 ) | 0x32);\n\n\t \n\twrl(USB_PHY_TST_GRP_CTRL, rdl(USB_PHY_TST_GRP_CTRL) & ~0x8000);\n\n\t \n\twrl(USB_CMD, rdl(USB_CMD) & ~USB_CMD_RUN);\n\twrl(USB_CMD, rdl(USB_CMD) | USB_CMD_RESET);\n\twhile (rdl(USB_CMD) & USB_CMD_RESET);\n\n\t \n\twrl(USB_MODE, USB_MODE_SDIS | USB_MODE_HOST);\n}\n\nstatic void\nehci_orion_conf_mbus_windows(struct usb_hcd *hcd,\n\t\t\t     const struct mbus_dram_target_info *dram)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++) {\n\t\twrl(USB_WINDOW_CTRL(i), 0);\n\t\twrl(USB_WINDOW_BASE(i), 0);\n\t}\n\n\tfor (i = 0; i < dram->num_cs; i++) {\n\t\tconst struct mbus_dram_window *cs = dram->cs + i;\n\n\t\twrl(USB_WINDOW_CTRL(i), ((cs->size - 1) & 0xffff0000) |\n\t\t\t\t\t(cs->mbus_attr << 8) |\n\t\t\t\t\t(dram->mbus_dram_target_id << 4) | 1);\n\t\twrl(USB_WINDOW_BASE(i), cs->base);\n\t}\n}\n\nstatic int ehci_orion_drv_reset(struct usb_hcd *hcd)\n{\n\tstruct device *dev = hcd->self.controller;\n\tint ret;\n\n\tret = ehci_setup(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tif (of_device_is_compatible(dev->of_node, \"marvell,armada-3700-ehci\"))\n\t\twrl(USB_SBUSCFG, USB_SBUSCFG_DEF_VAL);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused ehci_orion_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\n\treturn ehci_suspend(hcd, device_may_wakeup(dev));\n}\n\nstatic int __maybe_unused ehci_orion_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\n\treturn ehci_resume(hcd, false);\n}\n\nstatic SIMPLE_DEV_PM_OPS(ehci_orion_pm_ops, ehci_orion_drv_suspend,\n\t\t\t ehci_orion_drv_resume);\n\nstatic const struct ehci_driver_overrides orion_overrides __initconst = {\n\t.extra_priv_size =\tsizeof(struct orion_ehci_hcd),\n\t.reset = ehci_orion_drv_reset,\n};\n\nstatic int ehci_orion_drv_probe(struct platform_device *pdev)\n{\n\tstruct orion_ehci_data *pd = dev_get_platdata(&pdev->dev);\n\tconst struct mbus_dram_target_info *dram;\n\tstruct resource *res;\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tvoid __iomem *regs;\n\tint irq, err;\n\tenum orion_ehci_phy_ver phy_version;\n\tstruct orion_ehci_hcd *priv;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tpr_debug(\"Initializing Orion-SoC USB Host Controller\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto err;\n\t}\n\n\t \n\terr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\tgoto err;\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs)) {\n\t\terr = PTR_ERR(regs);\n\t\tgoto err;\n\t}\n\n\thcd = usb_create_hcd(&ehci_orion_hc_driver,\n\t\t\t&pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\terr = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\thcd->regs = regs;\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = hcd->regs + 0x100;\n\thcd->has_tt = 1;\n\n\tpriv = hcd_to_orion_priv(hcd);\n\t \n\tpriv->clk = devm_clk_get(&pdev->dev, NULL);\n\tif (!IS_ERR(priv->clk)) {\n\t\terr = clk_prepare_enable(priv->clk);\n\t\tif (err)\n\t\t\tgoto err_put_hcd;\n\t}\n\n\tpriv->phy = devm_phy_optional_get(&pdev->dev, \"usb\");\n\tif (IS_ERR(priv->phy)) {\n\t\terr = PTR_ERR(priv->phy);\n\t\tif (err != -ENOSYS)\n\t\t\tgoto err_dis_clk;\n\t}\n\n\t \n\tdram = mv_mbus_dram_info();\n\tif (dram)\n\t\tehci_orion_conf_mbus_windows(hcd, dram);\n\n\t \n\tif (pdev->dev.of_node)\n\t\tphy_version = EHCI_PHY_NA;\n\telse\n\t\tphy_version = pd->phy_version;\n\n\tswitch (phy_version) {\n\tcase EHCI_PHY_NA:\t \n\t\tbreak;\n\tcase EHCI_PHY_ORION:\n\t\torion_usb_phy_v1_setup(hcd);\n\t\tbreak;\n\tcase EHCI_PHY_DD:\n\tcase EHCI_PHY_KW:\n\tdefault:\n\t\tdev_warn(&pdev->dev, \"USB phy version isn't supported.\\n\");\n\t}\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err)\n\t\tgoto err_dis_clk;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\nerr_dis_clk:\n\tif (!IS_ERR(priv->clk))\n\t\tclk_disable_unprepare(priv->clk);\nerr_put_hcd:\n\tusb_put_hcd(hcd);\nerr:\n\tdev_err(&pdev->dev, \"init %s fail, %d\\n\",\n\t\tdev_name(&pdev->dev), err);\n\n\treturn err;\n}\n\nstatic void ehci_orion_drv_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct orion_ehci_hcd *priv = hcd_to_orion_priv(hcd);\n\n\tusb_remove_hcd(hcd);\n\n\tif (!IS_ERR(priv->clk))\n\t\tclk_disable_unprepare(priv->clk);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct of_device_id ehci_orion_dt_ids[] = {\n\t{ .compatible = \"marvell,orion-ehci\", },\n\t{ .compatible = \"marvell,armada-3700-ehci\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehci_orion_dt_ids);\n\nstatic struct platform_driver ehci_orion_driver = {\n\t.probe\t\t= ehci_orion_drv_probe,\n\t.remove_new\t= ehci_orion_drv_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name\t= \"orion-ehci\",\n\t\t.of_match_table = ehci_orion_dt_ids,\n\t\t.pm = &ehci_orion_pm_ops,\n\t},\n};\n\nstatic int __init ehci_orion_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_orion_hc_driver, &orion_overrides);\n\treturn platform_driver_register(&ehci_orion_driver);\n}\nmodule_init(ehci_orion_init);\n\nstatic void __exit ehci_orion_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_orion_driver);\n}\nmodule_exit(ehci_orion_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_ALIAS(\"platform:orion-ehci\");\nMODULE_AUTHOR(\"Tzachi Perelstein\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}