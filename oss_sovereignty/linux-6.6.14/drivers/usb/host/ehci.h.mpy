{
  "module_name": "ehci.h",
  "hash_id": "8209087bc3b6e06a221b33993da66151de528f5aa29333239938503506523f61",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci.h",
  "human_readable_source": " \n \n\n#ifndef __LINUX_EHCI_HCD_H\n#define __LINUX_EHCI_HCD_H\n\n \n\n \n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC\ntypedef __u32 __bitwise __hc32;\ntypedef __u16 __bitwise __hc16;\n#else\n#define __hc32\t__le32\n#define __hc16\t__le16\n#endif\n\n \n#ifdef CONFIG_DYNAMIC_DEBUG\n#define EHCI_STATS\n#endif\n\nstruct ehci_stats {\n\t \n\tunsigned long\t\tnormal;\n\tunsigned long\t\terror;\n\tunsigned long\t\tiaa;\n\tunsigned long\t\tlost_iaa;\n\n\t \n\tunsigned long\t\tcomplete;\n\tunsigned long\t\tunlink;\n};\n\n \nstruct ehci_per_sched {\n\tstruct usb_device\t*udev;\t\t \n\tstruct usb_host_endpoint *ep;\n\tstruct list_head\tps_list;\t \n\tu16\t\t\ttt_usecs;\t \n\tu16\t\t\tcs_mask;\t \n\tu16\t\t\tperiod;\t\t \n\tu16\t\t\tphase;\t\t \n\tu8\t\t\tbw_phase;\t \n\tu8\t\t\tphase_uf;\t \n\tu8\t\t\tusecs, c_usecs;\t \n\tu8\t\t\tbw_uperiod;\t \n\tu8\t\t\tbw_period;\t \n};\n#define NO_FRAME\t29999\t\t\t \n\n \n\n#define\tEHCI_MAX_ROOT_PORTS\t15\t\t \n\n \nenum ehci_rh_state {\n\tEHCI_RH_HALTED,\n\tEHCI_RH_SUSPENDED,\n\tEHCI_RH_RUNNING,\n\tEHCI_RH_STOPPING\n};\n\n \nenum ehci_hrtimer_event {\n\tEHCI_HRTIMER_POLL_ASS,\t\t \n\tEHCI_HRTIMER_POLL_PSS,\t\t \n\tEHCI_HRTIMER_POLL_DEAD,\t\t \n\tEHCI_HRTIMER_UNLINK_INTR,\t \n\tEHCI_HRTIMER_FREE_ITDS,\t\t \n\tEHCI_HRTIMER_ACTIVE_UNLINK,\t \n\tEHCI_HRTIMER_START_UNLINK_INTR,  \n\tEHCI_HRTIMER_ASYNC_UNLINKS,\t \n\tEHCI_HRTIMER_IAA_WATCHDOG,\t \n\tEHCI_HRTIMER_DISABLE_PERIODIC,\t \n\tEHCI_HRTIMER_DISABLE_ASYNC,\t \n\tEHCI_HRTIMER_IO_WATCHDOG,\t \n\tEHCI_HRTIMER_NUM_EVENTS\t\t \n};\n#define EHCI_HRTIMER_NO_EVENT\t99\n\nstruct ehci_hcd {\t\t\t \n\t \n\tenum ehci_hrtimer_event\tnext_hrtimer_event;\n\tunsigned\t\tenabled_hrtimer_events;\n\tktime_t\t\t\thr_timeouts[EHCI_HRTIMER_NUM_EVENTS];\n\tstruct hrtimer\t\thrtimer;\n\n\tint\t\t\tPSS_poll_count;\n\tint\t\t\tASS_poll_count;\n\tint\t\t\tdied_poll_count;\n\n\t \n\tstruct ehci_caps __iomem *caps;\n\tstruct ehci_regs __iomem *regs;\n\tstruct ehci_dbg_port __iomem *debug;\n\n\t__u32\t\t\thcs_params;\t \n\tspinlock_t\t\tlock;\n\tenum ehci_rh_state\trh_state;\n\n\t \n\tbool\t\t\tscanning:1;\n\tbool\t\t\tneed_rescan:1;\n\tbool\t\t\tintr_unlinking:1;\n\tbool\t\t\tiaa_in_progress:1;\n\tbool\t\t\tasync_unlinking:1;\n\tbool\t\t\tshutdown:1;\n\tstruct ehci_qh\t\t*qh_scan_next;\n\n\t \n\tstruct ehci_qh\t\t*async;\n\tstruct ehci_qh\t\t*dummy;\t\t \n\tstruct list_head\tasync_unlink;\n\tstruct list_head\tasync_idle;\n\tunsigned\t\tasync_unlink_cycle;\n\tunsigned\t\tasync_count;\t \n\t__hc32\t\t\told_current;\t \n\t__hc32\t\t\told_token;\t \n\n\t \n#define\tDEFAULT_I_TDPS\t\t1024\t\t \n\tunsigned\t\tperiodic_size;\n\t__hc32\t\t\t*periodic;\t \n\tdma_addr_t\t\tperiodic_dma;\n\tstruct list_head\tintr_qh_list;\n\tunsigned\t\ti_thresh;\t \n\n\tunion ehci_shadow\t*pshadow;\t \n\tstruct list_head\tintr_unlink_wait;\n\tstruct list_head\tintr_unlink;\n\tunsigned\t\tintr_unlink_wait_cycle;\n\tunsigned\t\tintr_unlink_cycle;\n\tunsigned\t\tnow_frame;\t \n\tunsigned\t\tlast_iso_frame;\t \n\tunsigned\t\tintr_count;\t \n\tunsigned\t\tisoc_count;\t \n\tunsigned\t\tperiodic_count;\t \n\tunsigned\t\tuframe_periodic_max;  \n\n\n\t \n\tstruct list_head\tcached_itd_list;\n\tstruct ehci_itd\t\t*last_itd_to_free;\n\tstruct list_head\tcached_sitd_list;\n\tstruct ehci_sitd\t*last_sitd_to_free;\n\n\t \n\tunsigned long\t\treset_done[EHCI_MAX_ROOT_PORTS];\n\n\t \n\tunsigned long\t\tbus_suspended;\t\t \n\tunsigned long\t\tcompanion_ports;\t \n\tunsigned long\t\towned_ports;\t\t \n\tunsigned long\t\tport_c_suspend;\t\t \n\tunsigned long\t\tsuspended_ports;\t \n\tunsigned long\t\tresuming_ports;\t\t \n\n\t \n\tstruct dma_pool\t\t*qh_pool;\t \n\tstruct dma_pool\t\t*qtd_pool;\t \n\tstruct dma_pool\t\t*itd_pool;\t \n\tstruct dma_pool\t\t*sitd_pool;\t \n\n\tunsigned\t\trandom_frame;\n\tunsigned long\t\tnext_statechange;\n\tktime_t\t\t\tlast_periodic_enable;\n\tu32\t\t\tcommand;\n\n\t \n\tunsigned\t\tno_selective_suspend:1;\n\tunsigned\t\thas_fsl_port_bug:1;  \n\tunsigned\t\thas_fsl_hs_errata:1;\t \n\tunsigned\t\thas_fsl_susp_errata:1;\t \n\tunsigned\t\thas_ci_pec_bug:1;\t \n\tunsigned\t\tbig_endian_mmio:1;\n\tunsigned\t\tbig_endian_desc:1;\n\tunsigned\t\tbig_endian_capbase:1;\n\tunsigned\t\thas_amcc_usb23:1;\n\tunsigned\t\tneed_io_watchdog:1;\n\tunsigned\t\tamd_pll_fix:1;\n\tunsigned\t\tuse_dummy_qh:1;\t \n\tunsigned\t\thas_synopsys_hc_bug:1;  \n\tunsigned\t\tframe_index_bug:1;  \n\tunsigned\t\tneed_oc_pp_cycle:1;  \n\tunsigned\t\timx28_write_fix:1;  \n\tunsigned\t\tspurious_oc:1;\n\tunsigned\t\tis_aspeed:1;\n\tunsigned\t\tzx_wakeup_clear_needed:1;\n\n\t \n\t#define OHCI_CTRL_HCFS          (3 << 6)\n\t#define OHCI_USB_OPER           (2 << 6)\n\t#define OHCI_USB_SUSPEND        (3 << 6)\n\n\t#define OHCI_HCCTRL_OFFSET      0x4\n\t#define OHCI_HCCTRL_LEN         0x4\n\t__hc32\t\t\t*ohci_hcctrl_reg;\n\tunsigned\t\thas_hostpc:1;\n\tunsigned\t\thas_tdi_phy_lpm:1;\n\tunsigned\t\thas_ppcd:1;  \n\tu8\t\t\tsbrn;\t\t \n\n\t \n#ifdef EHCI_STATS\n\tstruct ehci_stats\tstats;\n#\tdefine INCR(x) ((x)++)\n#else\n#\tdefine INCR(x) do {} while (0)\n#endif\n\n\t \n#ifdef CONFIG_DYNAMIC_DEBUG\n\tstruct dentry\t\t*debug_dir;\n#endif\n\n\t \n#define EHCI_BANDWIDTH_SIZE\t64\n#define EHCI_BANDWIDTH_FRAMES\t(EHCI_BANDWIDTH_SIZE >> 3)\n\tu8\t\t\tbandwidth[EHCI_BANDWIDTH_SIZE];\n\t\t\t\t\t\t \n\tu8\t\t\ttt_budget[EHCI_BANDWIDTH_SIZE];\n\t\t\t\t\t\t \n\tstruct list_head\ttt_list;\n\n\t \n\tunsigned long\t\tpriv[] __aligned(sizeof(s64));\n};\n\n \nstatic inline struct ehci_hcd *hcd_to_ehci(struct usb_hcd *hcd)\n{\n\treturn (struct ehci_hcd *) (hcd->hcd_priv);\n}\nstatic inline struct usb_hcd *ehci_to_hcd(struct ehci_hcd *ehci)\n{\n\treturn container_of((void *) ehci, struct usb_hcd, hcd_priv);\n}\n\n \n\n#include <linux/usb/ehci_def.h>\n\n \n\n#define\tQTD_NEXT(ehci, dma)\tcpu_to_hc32(ehci, (u32)dma)\n\n \nstruct ehci_qtd {\n\t \n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_alt_next;     \n\t__hc32\t\t\thw_token;        \n#define\tQTD_TOGGLE\t(1 << 31)\t \n#define\tQTD_LENGTH(tok)\t(((tok)>>16) & 0x7fff)\n#define\tQTD_IOC\t\t(1 << 15)\t \n#define\tQTD_CERR(tok)\t(((tok)>>10) & 0x3)\n#define\tQTD_PID(tok)\t(((tok)>>8) & 0x3)\n#define\tQTD_STS_ACTIVE\t(1 << 7)\t \n#define\tQTD_STS_HALT\t(1 << 6)\t \n#define\tQTD_STS_DBE\t(1 << 5)\t \n#define\tQTD_STS_BABBLE\t(1 << 4)\t \n#define\tQTD_STS_XACT\t(1 << 3)\t \n#define\tQTD_STS_MMF\t(1 << 2)\t \n#define\tQTD_STS_STS\t(1 << 1)\t \n#define\tQTD_STS_PING\t(1 << 0)\t \n\n#define ACTIVE_BIT(ehci)\tcpu_to_hc32(ehci, QTD_STS_ACTIVE)\n#define HALT_BIT(ehci)\t\tcpu_to_hc32(ehci, QTD_STS_HALT)\n#define STATUS_BIT(ehci)\tcpu_to_hc32(ehci, QTD_STS_STS)\n\n\t__hc32\t\t\thw_buf[5];         \n\t__hc32\t\t\thw_buf_hi[5];         \n\n\t \n\tdma_addr_t\t\tqtd_dma;\t\t \n\tstruct list_head\tqtd_list;\t\t \n\tstruct urb\t\t*urb;\t\t\t \n\tsize_t\t\t\tlength;\t\t\t \n} __aligned(32);\n\n \n#define QTD_MASK(ehci)\tcpu_to_hc32(ehci, ~0x1f)\n\n#define IS_SHORT_READ(token) (QTD_LENGTH(token) != 0 && QTD_PID(token) == 1)\n\n \n\n \n#define Q_NEXT_TYPE(ehci, dma)\t((dma) & cpu_to_hc32(ehci, 3 << 1))\n\n \n \n#define Q_TYPE_ITD\t(0 << 1)\n#define Q_TYPE_QH\t(1 << 1)\n#define Q_TYPE_SITD\t(2 << 1)\n#define Q_TYPE_FSTN\t(3 << 1)\n\n \n#define QH_NEXT(ehci, dma) \\\n\t\t(cpu_to_hc32(ehci, (((u32) dma) & ~0x01f) | Q_TYPE_QH))\n\n \n#define EHCI_LIST_END(ehci)\tcpu_to_hc32(ehci, 1)  \n\n \nunion ehci_shadow {\n\tstruct ehci_qh\t\t*qh;\t\t \n\tstruct ehci_itd\t\t*itd;\t\t \n\tstruct ehci_sitd\t*sitd;\t\t \n\tstruct ehci_fstn\t*fstn;\t\t \n\t__hc32\t\t\t*hw_next;\t \n\tvoid\t\t\t*ptr;\n};\n\n \n\n \n\n \nstruct ehci_qh_hw {\n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_info1;        \n#define\tQH_CONTROL_EP\t(1 << 27)\t \n#define\tQH_HEAD\t\t(1 << 15)\t \n#define\tQH_TOGGLE_CTL\t(1 << 14)\t \n#define\tQH_HIGH_SPEED\t(2 << 12)\t \n#define\tQH_LOW_SPEED\t(1 << 12)\n#define\tQH_FULL_SPEED\t(0 << 12)\n#define\tQH_INACTIVATE\t(1 << 7)\t \n\t__hc32\t\t\thw_info2;         \n#define\tQH_SMASK\t0x000000ff\n#define\tQH_CMASK\t0x0000ff00\n#define\tQH_HUBADDR\t0x007f0000\n#define\tQH_HUBPORT\t0x3f800000\n#define\tQH_MULT\t\t0xc0000000\n\t__hc32\t\t\thw_current;\t \n\n\t \n\t__hc32\t\t\thw_qtd_next;\n\t__hc32\t\t\thw_alt_next;\n\t__hc32\t\t\thw_token;\n\t__hc32\t\t\thw_buf[5];\n\t__hc32\t\t\thw_buf_hi[5];\n} __aligned(32);\n\nstruct ehci_qh {\n\tstruct ehci_qh_hw\t*hw;\t\t \n\t \n\tdma_addr_t\t\tqh_dma;\t\t \n\tunion ehci_shadow\tqh_next;\t \n\tstruct list_head\tqtd_list;\t \n\tstruct list_head\tintr_node;\t \n\tstruct ehci_qtd\t\t*dummy;\n\tstruct list_head\tunlink_node;\n\tstruct ehci_per_sched\tps;\t\t \n\n\tunsigned\t\tunlink_cycle;\n\n\tu8\t\t\tqh_state;\n#define\tQH_STATE_LINKED\t\t1\t\t \n#define\tQH_STATE_UNLINK\t\t2\t\t \n#define\tQH_STATE_IDLE\t\t3\t\t \n#define\tQH_STATE_UNLINK_WAIT\t4\t\t \n#define\tQH_STATE_COMPLETING\t5\t\t \n\n\tu8\t\t\txacterrs;\t \n#define\tQH_XACTERR_MAX\t\t32\t\t \n\n\tu8\t\t\tunlink_reason;\n#define QH_UNLINK_HALTED\t0x01\t\t \n#define QH_UNLINK_SHORT_READ\t0x02\t\t \n#define QH_UNLINK_DUMMY_OVERLAY\t0x04\t\t \n#define QH_UNLINK_SHUTDOWN\t0x08\t\t \n#define QH_UNLINK_QUEUE_EMPTY\t0x10\t\t \n#define QH_UNLINK_REQUESTED\t0x20\t\t \n\n\tu8\t\t\tgap_uf;\t\t \n\n\tunsigned\t\tis_out:1;\t \n\tunsigned\t\tclearing_tt:1;\t \n\tunsigned\t\tdequeue_during_giveback:1;\n\tunsigned\t\tshould_be_inactive:1;\n};\n\n \n\n \nstruct ehci_iso_packet {\n\t \n\tu64\t\t\tbufp;\t\t \n\t__hc32\t\t\ttransaction;\t \n\tu8\t\t\tcross;\t\t \n\t \n\tu32\t\t\tbuf1;\n};\n\n \nstruct ehci_iso_sched {\n\tstruct list_head\ttd_list;\n\tunsigned\t\tspan;\n\tunsigned\t\tfirst_packet;\n\tstruct ehci_iso_packet\tpacket[];\n};\n\n \nstruct ehci_iso_stream {\n\t \n\tstruct ehci_qh_hw\t*hw;\n\n\tu8\t\t\tbEndpointAddress;\n\tu8\t\t\thighspeed;\n\tstruct list_head\ttd_list;\t \n\tstruct list_head\tfree_list;\t \n\n\t \n\tstruct ehci_per_sched\tps;\t\t \n\tunsigned\t\tnext_uframe;\n\t__hc32\t\t\tsplits;\n\n\t \n\tu16\t\t\tuperiod;\t \n\tu16\t\t\tmaxp;\n\tunsigned\t\tbandwidth;\n\n\t \n\t__hc32\t\t\tbuf0;\n\t__hc32\t\t\tbuf1;\n\t__hc32\t\t\tbuf2;\n\n\t \n\t__hc32\t\t\taddress;\n};\n\n \n\n \nstruct ehci_itd {\n\t \n\t__hc32\t\t\thw_next;            \n\t__hc32\t\t\thw_transaction[8];  \n#define EHCI_ISOC_ACTIVE        (1<<31)         \n#define EHCI_ISOC_BUF_ERR       (1<<30)         \n#define EHCI_ISOC_BABBLE        (1<<29)         \n#define EHCI_ISOC_XACTERR       (1<<28)         \n#define\tEHCI_ITD_LENGTH(tok)\t(((tok)>>16) & 0x0fff)\n#define\tEHCI_ITD_IOC\t\t(1 << 15)\t \n\n#define ITD_ACTIVE(ehci)\tcpu_to_hc32(ehci, EHCI_ISOC_ACTIVE)\n\n\t__hc32\t\t\thw_bufp[7];\t \n\t__hc32\t\t\thw_bufp_hi[7];\t \n\n\t \n\tdma_addr_t\t\titd_dma;\t \n\tunion ehci_shadow\titd_next;\t \n\n\tstruct urb\t\t*urb;\n\tstruct ehci_iso_stream\t*stream;\t \n\tstruct list_head\titd_list;\t \n\n\t \n\tunsigned\t\tframe;\t\t \n\tunsigned\t\tpg;\n\tunsigned\t\tindex[8];\t \n} __aligned(32);\n\n \n\n \nstruct ehci_sitd {\n\t \n\t__hc32\t\t\thw_next;\n \n\t__hc32\t\t\thw_fullspeed_ep;\t \n\t__hc32\t\t\thw_uframe;\t\t \n\t__hc32\t\t\thw_results;\t\t \n#define\tSITD_IOC\t(1 << 31)\t \n#define\tSITD_PAGE\t(1 << 30)\t \n#define\tSITD_LENGTH(x)\t(((x) >> 16) & 0x3ff)\n#define\tSITD_STS_ACTIVE\t(1 << 7)\t \n#define\tSITD_STS_ERR\t(1 << 6)\t \n#define\tSITD_STS_DBE\t(1 << 5)\t \n#define\tSITD_STS_BABBLE\t(1 << 4)\t \n#define\tSITD_STS_XACT\t(1 << 3)\t \n#define\tSITD_STS_MMF\t(1 << 2)\t \n#define\tSITD_STS_STS\t(1 << 1)\t \n\n#define SITD_ACTIVE(ehci)\tcpu_to_hc32(ehci, SITD_STS_ACTIVE)\n\n\t__hc32\t\t\thw_buf[2];\t\t \n\t__hc32\t\t\thw_backpointer;\t\t \n\t__hc32\t\t\thw_buf_hi[2];\t\t \n\n\t \n\tdma_addr_t\t\tsitd_dma;\n\tunion ehci_shadow\tsitd_next;\t \n\n\tstruct urb\t\t*urb;\n\tstruct ehci_iso_stream\t*stream;\t \n\tstruct list_head\tsitd_list;\t \n\tunsigned\t\tframe;\n\tunsigned\t\tindex;\n} __aligned(32);\n\n \n\n \nstruct ehci_fstn {\n\t__hc32\t\t\thw_next;\t \n\t__hc32\t\t\thw_prev;\t \n\n\t \n\tdma_addr_t\t\tfstn_dma;\n\tunion ehci_shadow\tfstn_next;\t \n} __aligned(32);\n\n \n\n \n\nstruct ehci_tt {\n\tu16\t\t\tbandwidth[EHCI_BANDWIDTH_FRAMES];\n\n\tstruct list_head\ttt_list;\t \n\tstruct list_head\tps_list;\t \n\tstruct usb_tt\t\t*usb_tt;\n\tint\t\t\ttt_port;\t \n};\n\n \n\n \n\n#define ehci_prepare_ports_for_controller_suspend(ehci, do_wakeup)\t\\\n\t\tehci_adjust_port_wakeup_flags(ehci, true, do_wakeup)\n\n#define ehci_prepare_ports_for_controller_resume(ehci)\t\t\t\\\n\t\tehci_adjust_port_wakeup_flags(ehci, false, false)\n\n \n\n#ifdef CONFIG_USB_EHCI_ROOT_HUB_TT\n\n \n\n#define\tehci_is_TDI(e)\t\t\t(ehci_to_hcd(e)->has_tt)\n\n \nstatic inline unsigned int\nehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)\n{\n\tif (ehci_is_TDI(ehci)) {\n\t\tswitch ((portsc >> (ehci->has_hostpc ? 25 : 26)) & 3) {\n\t\tcase 0:\n\t\t\treturn 0;\n\t\tcase 1:\n\t\t\treturn USB_PORT_STAT_LOW_SPEED;\n\t\tcase 2:\n\t\tdefault:\n\t\t\treturn USB_PORT_STAT_HIGH_SPEED;\n\t\t}\n\t}\n\treturn USB_PORT_STAT_HIGH_SPEED;\n}\n\n#else\n\n#define\tehci_is_TDI(e)\t\t\t(0)\n\n#define\tehci_port_speed(ehci, portsc)\tUSB_PORT_STAT_HIGH_SPEED\n#endif\n\n \n\n#ifdef CONFIG_PPC_83xx\n \n#define\tehci_has_fsl_portno_bug(e)\t\t((e)->has_fsl_port_bug)\n#else\n#define\tehci_has_fsl_portno_bug(e)\t\t(0)\n#endif\n\n#define PORTSC_FSL_PFSC\t24\t \n\n#if defined(CONFIG_PPC_85xx)\n \n#define ehci_has_fsl_hs_errata(e)\t((e)->has_fsl_hs_errata)\n#else\n#define ehci_has_fsl_hs_errata(e)\t(0)\n#endif\n\n \n#define ehci_has_fsl_susp_errata(e)\t((e)->has_fsl_susp_errata)\n\n \n#define ehci_has_ci_pec_bug(e, portsc) \\\n\t((e)->has_ci_pec_bug && ((e)->command & CMD_PSE) \\\n\t && !(portsc & PORT_PEC) && !(portsc & PORT_PE))\n\n \n\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\n#define ehci_big_endian_mmio(e)\t\t((e)->big_endian_mmio)\n#define ehci_big_endian_capbase(e)\t((e)->big_endian_capbase)\n#else\n#define ehci_big_endian_mmio(e)\t\t0\n#define ehci_big_endian_capbase(e)\t0\n#endif\n\n \n#if defined(CONFIG_ARM) && defined(CONFIG_ARCH_IXP4XX)\n#define readl_be(addr)\t\t__raw_readl((__force unsigned *)addr)\n#define writel_be(val, addr)\t__raw_writel(val, (__force unsigned *)addr)\n#endif\n\nstatic inline unsigned int ehci_readl(const struct ehci_hcd *ehci,\n\t\t__u32 __iomem *regs)\n{\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\n\treturn ehci_big_endian_mmio(ehci) ?\n\t\treadl_be(regs) :\n\t\treadl(regs);\n#else\n\treturn readl(regs);\n#endif\n}\n\n#ifdef CONFIG_SOC_IMX28\nstatic inline void imx28_ehci_writel(const unsigned int val,\n\t\tvolatile __u32 __iomem *addr)\n{\n\t__asm__ (\"swp %0, %0, [%1]\" : : \"r\"(val), \"r\"(addr));\n}\n#else\nstatic inline void imx28_ehci_writel(const unsigned int val,\n\t\tvolatile __u32 __iomem *addr)\n{\n}\n#endif\nstatic inline void ehci_writel(const struct ehci_hcd *ehci,\n\t\tconst unsigned int val, __u32 __iomem *regs)\n{\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\n\tehci_big_endian_mmio(ehci) ?\n\t\twritel_be(val, regs) :\n\t\twritel(val, regs);\n#else\n\tif (ehci->imx28_write_fix)\n\t\timx28_ehci_writel(val, regs);\n\telse\n\t\twritel(val, regs);\n#endif\n}\n\n \n#ifdef CONFIG_44x\nstatic inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)\n{\n\tu32 hc_control;\n\n\thc_control = (readl_be(ehci->ohci_hcctrl_reg) & ~OHCI_CTRL_HCFS);\n\tif (operational)\n\t\thc_control |= OHCI_USB_OPER;\n\telse\n\t\thc_control |= OHCI_USB_SUSPEND;\n\n\twritel_be(hc_control, ehci->ohci_hcctrl_reg);\n\t(void) readl_be(ehci->ohci_hcctrl_reg);\n}\n#else\nstatic inline void set_ohci_hcfs(struct ehci_hcd *ehci, int operational)\n{ }\n#endif\n\n \n\n \n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_DESC\n#define ehci_big_endian_desc(e)\t\t((e)->big_endian_desc)\n\n \nstatic inline __hc32 cpu_to_hc32(const struct ehci_hcd *ehci, const u32 x)\n{\n\treturn ehci_big_endian_desc(ehci)\n\t\t? (__force __hc32)cpu_to_be32(x)\n\t\t: (__force __hc32)cpu_to_le32(x);\n}\n\n \nstatic inline u32 hc32_to_cpu(const struct ehci_hcd *ehci, const __hc32 x)\n{\n\treturn ehci_big_endian_desc(ehci)\n\t\t? be32_to_cpu((__force __be32)x)\n\t\t: le32_to_cpu((__force __le32)x);\n}\n\nstatic inline u32 hc32_to_cpup(const struct ehci_hcd *ehci, const __hc32 *x)\n{\n\treturn ehci_big_endian_desc(ehci)\n\t\t? be32_to_cpup((__force __be32 *)x)\n\t\t: le32_to_cpup((__force __le32 *)x);\n}\n\n#else\n\n \nstatic inline __hc32 cpu_to_hc32(const struct ehci_hcd *ehci, const u32 x)\n{\n\treturn cpu_to_le32(x);\n}\n\n \nstatic inline u32 hc32_to_cpu(const struct ehci_hcd *ehci, const __hc32 x)\n{\n\treturn le32_to_cpu(x);\n}\n\nstatic inline u32 hc32_to_cpup(const struct ehci_hcd *ehci, const __hc32 *x)\n{\n\treturn le32_to_cpup(x);\n}\n\n#endif\n\n \n\n#define ehci_dbg(ehci, fmt, args...) \\\n\tdev_dbg(ehci_to_hcd(ehci)->self.controller, fmt, ## args)\n#define ehci_err(ehci, fmt, args...) \\\n\tdev_err(ehci_to_hcd(ehci)->self.controller, fmt, ## args)\n#define ehci_info(ehci, fmt, args...) \\\n\tdev_info(ehci_to_hcd(ehci)->self.controller, fmt, ## args)\n#define ehci_warn(ehci, fmt, args...) \\\n\tdev_warn(ehci_to_hcd(ehci)->self.controller, fmt, ## args)\n\n \n\n \n\nstruct ehci_driver_overrides {\n\tsize_t\t\textra_priv_size;\n\tint\t\t(*reset)(struct usb_hcd *hcd);\n\tint\t\t(*port_power)(struct usb_hcd *hcd,\n\t\t\t\tint portnum, bool enable);\n};\n\nextern void\tehci_init_driver(struct hc_driver *drv,\n\t\t\t\tconst struct ehci_driver_overrides *over);\nextern int\tehci_setup(struct usb_hcd *hcd);\nextern int\tehci_handshake(struct ehci_hcd *ehci, void __iomem *ptr,\n\t\t\t\tu32 mask, u32 done, int usec);\nextern int\tehci_reset(struct ehci_hcd *ehci);\n\nextern int\tehci_suspend(struct usb_hcd *hcd, bool do_wakeup);\nextern int\tehci_resume(struct usb_hcd *hcd, bool force_reset);\nextern void\tehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,\n\t\t\tbool suspending, bool do_wakeup);\n\nextern int\tehci_hub_control(struct usb_hcd\t*hcd, u16 typeReq, u16 wValue,\n\t\t\t\t u16 wIndex, char *buf, u16 wLength);\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}