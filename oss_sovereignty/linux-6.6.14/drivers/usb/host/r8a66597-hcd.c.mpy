{
  "module_name": "r8a66597-hcd.c",
  "hash_id": "72e9ceb7e14ca40026d480ecc058d918cf507accba03c25eecba7a2aa4a450c0",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/r8a66597-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/delay.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/platform_device.h>\n#include <linux/io.h>\n#include <linux/mm.h>\n#include <linux/irq.h>\n#include <linux/slab.h>\n#include <asm/cacheflush.h>\n\n#include \"r8a66597.h\"\n\nMODULE_DESCRIPTION(\"R8A66597 USB Host Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Yoshihiro Shimoda\");\nMODULE_ALIAS(\"platform:r8a66597_hcd\");\n\n#define DRIVER_VERSION\t\"2009-05-26\"\n\nstatic const char hcd_name[] = \"r8a66597_hcd\";\n\nstatic void packet_write(struct r8a66597 *r8a66597, u16 pipenum);\nstatic int r8a66597_get_frame(struct usb_hcd *hcd);\n\n \nstatic void enable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t    unsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, INTENB0);\n\tr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\n\tr8a66597_bset(r8a66597, 1 << pipenum, reg);\n\tr8a66597_write(r8a66597, tmp, INTENB0);\n}\n\n \nstatic void disable_pipe_irq(struct r8a66597 *r8a66597, u16 pipenum,\n\t\t\t     unsigned long reg)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, INTENB0);\n\tr8a66597_bclr(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\n\tr8a66597_bclr(r8a66597, 1 << pipenum, reg);\n\tr8a66597_write(r8a66597, tmp, INTENB0);\n}\n\nstatic void set_devadd_reg(struct r8a66597 *r8a66597, u8 r8a66597_address,\n\t\t\t   u16 usbspd, u8 upphub, u8 hubport, int port)\n{\n\tu16 val;\n\tunsigned long devadd_reg = get_devadd_addr(r8a66597_address);\n\n\tval = (upphub << 11) | (hubport << 8) | (usbspd << 6) | (port & 0x0001);\n\tr8a66597_write(r8a66597, val, devadd_reg);\n}\n\nstatic int r8a66597_clock_enable(struct r8a66597 *r8a66597)\n{\n\tu16 tmp;\n\tint i = 0;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tclk_prepare_enable(r8a66597->clk);\n\t\tdo {\n\t\t\tr8a66597_write(r8a66597, SCKE, SYSCFG0);\n\t\t\ttmp = r8a66597_read(r8a66597, SYSCFG0);\n\t\t\tif (i++ > 1000) {\n\t\t\t\tprintk(KERN_ERR \"r8a66597: reg access fail.\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t} while ((tmp & SCKE) != SCKE);\n\t\tr8a66597_write(r8a66597, 0x04, 0x02);\n\t} else {\n\t\tdo {\n\t\t\tr8a66597_write(r8a66597, USBE, SYSCFG0);\n\t\t\ttmp = r8a66597_read(r8a66597, SYSCFG0);\n\t\t\tif (i++ > 1000) {\n\t\t\t\tprintk(KERN_ERR \"r8a66597: reg access fail.\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t} while ((tmp & USBE) != USBE);\n\t\tr8a66597_bclr(r8a66597, USBE, SYSCFG0);\n\t\tr8a66597_mdfy(r8a66597, get_xtal_from_pdata(r8a66597->pdata),\n\t\t\t      XTAL, SYSCFG0);\n\n\t\ti = 0;\n\t\tr8a66597_bset(r8a66597, XCKE, SYSCFG0);\n\t\tdo {\n\t\t\tmsleep(1);\n\t\t\ttmp = r8a66597_read(r8a66597, SYSCFG0);\n\t\t\tif (i++ > 500) {\n\t\t\t\tprintk(KERN_ERR \"r8a66597: reg access fail.\\n\");\n\t\t\t\treturn -ENXIO;\n\t\t\t}\n\t\t} while ((tmp & SCKE) != SCKE);\n\t}\n\n\treturn 0;\n}\n\nstatic void r8a66597_clock_disable(struct r8a66597 *r8a66597)\n{\n\tr8a66597_bclr(r8a66597, SCKE, SYSCFG0);\n\tudelay(1);\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tclk_disable_unprepare(r8a66597->clk);\n\t} else {\n\t\tr8a66597_bclr(r8a66597, PLLC, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, XCKE, SYSCFG0);\n\t\tr8a66597_bclr(r8a66597, USBE, SYSCFG0);\n\t}\n}\n\nstatic void r8a66597_enable_port(struct r8a66597 *r8a66597, int port)\n{\n\tu16 val;\n\n\tval = port ? DRPD : DCFM | DRPD;\n\tr8a66597_bset(r8a66597, val, get_syscfg_reg(port));\n\tr8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));\n\n\tr8a66597_write(r8a66597, BURST | CPU_ADR_RD_WR, get_dmacfg_reg(port));\n\tr8a66597_bclr(r8a66597, DTCHE, get_intenb_reg(port));\n\tr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\n}\n\nstatic void r8a66597_disable_port(struct r8a66597 *r8a66597, int port)\n{\n\tu16 val, tmp;\n\n\tr8a66597_write(r8a66597, 0, get_intenb_reg(port));\n\tr8a66597_write(r8a66597, 0, get_intsts_reg(port));\n\n\tr8a66597_port_power(r8a66597, port, 0);\n\n\tdo {\n\t\ttmp = r8a66597_read(r8a66597, SOFCFG) & EDGESTS;\n\t\tudelay(640);\n\t} while (tmp == EDGESTS);\n\n\tval = port ? DRPD : DCFM | DRPD;\n\tr8a66597_bclr(r8a66597, val, get_syscfg_reg(port));\n\tr8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));\n}\n\nstatic int enable_controller(struct r8a66597 *r8a66597)\n{\n\tint ret, port;\n\tu16 vif = r8a66597->pdata->vif ? LDRV : 0;\n\tu16 irq_sense = r8a66597->irq_sense_low ? INTL : 0;\n\tu16 endian = r8a66597->pdata->endian ? BIGEND : 0;\n\n\tret = r8a66597_clock_enable(r8a66597);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tr8a66597_bset(r8a66597, vif & LDRV, PINCFG);\n\tr8a66597_bset(r8a66597, USBE, SYSCFG0);\n\n\tr8a66597_bset(r8a66597, BEMPE | NRDYE | BRDYE, INTENB0);\n\tr8a66597_bset(r8a66597, irq_sense & INTL, SOFCFG);\n\tr8a66597_bset(r8a66597, BRDY0, BRDYENB);\n\tr8a66597_bset(r8a66597, BEMP0, BEMPENB);\n\n\tr8a66597_bset(r8a66597, endian & BIGEND, CFIFOSEL);\n\tr8a66597_bset(r8a66597, endian & BIGEND, D0FIFOSEL);\n\tr8a66597_bset(r8a66597, endian & BIGEND, D1FIFOSEL);\n\tr8a66597_bset(r8a66597, TRNENSEL, SOFCFG);\n\n\tr8a66597_bset(r8a66597, SIGNE | SACKE, INTENB1);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++)\n\t\tr8a66597_enable_port(r8a66597, port);\n\n\treturn 0;\n}\n\nstatic void disable_controller(struct r8a66597 *r8a66597)\n{\n\tint port;\n\n\t \n\tr8a66597_write(r8a66597, 0, INTENB0);\n\tr8a66597_write(r8a66597, 0, INTENB1);\n\tr8a66597_write(r8a66597, 0, BRDYENB);\n\tr8a66597_write(r8a66597, 0, BEMPENB);\n\tr8a66597_write(r8a66597, 0, NRDYENB);\n\n\t \n\tr8a66597_write(r8a66597, 0, BRDYSTS);\n\tr8a66597_write(r8a66597, 0, NRDYSTS);\n\tr8a66597_write(r8a66597, 0, BEMPSTS);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++)\n\t\tr8a66597_disable_port(r8a66597, port);\n\n\tr8a66597_clock_disable(r8a66597);\n}\n\nstatic int get_parent_r8a66597_address(struct r8a66597 *r8a66597,\n\t\t\t\t       struct usb_device *udev)\n{\n\tstruct r8a66597_device *dev;\n\n\tif (udev->parent && udev->parent->devnum != 1)\n\t\tudev = udev->parent;\n\n\tdev = dev_get_drvdata(&udev->dev);\n\tif (dev)\n\t\treturn dev->address;\n\telse\n\t\treturn 0;\n}\n\nstatic int is_child_device(char *devpath)\n{\n\treturn (devpath[2] ? 1 : 0);\n}\n\nstatic int is_hub_limit(char *devpath)\n{\n\treturn ((strlen(devpath) >= 4) ? 1 : 0);\n}\n\nstatic void get_port_number(struct r8a66597 *r8a66597,\n\t\t\t    char *devpath, u16 *root_port, u16 *hub_port)\n{\n\tif (root_port) {\n\t\t*root_port = (devpath[0] & 0x0F) - 1;\n\t\tif (*root_port >= r8a66597->max_root_hub)\n\t\t\tprintk(KERN_ERR \"r8a66597: Illegal root port number.\\n\");\n\t}\n\tif (hub_port)\n\t\t*hub_port = devpath[2] & 0x0F;\n}\n\nstatic u16 get_r8a66597_usb_speed(enum usb_device_speed speed)\n{\n\tu16 usbspd = 0;\n\n\tswitch (speed) {\n\tcase USB_SPEED_LOW:\n\t\tusbspd = LSMODE;\n\t\tbreak;\n\tcase USB_SPEED_FULL:\n\t\tusbspd = FSMODE;\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\n\t\tusbspd = HSMODE;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"r8a66597: unknown speed\\n\");\n\t\tbreak;\n\t}\n\n\treturn usbspd;\n}\n\nstatic void set_child_connect_map(struct r8a66597 *r8a66597, int address)\n{\n\tint idx;\n\n\tidx = address / 32;\n\tr8a66597->child_connect_map[idx] |= 1 << (address % 32);\n}\n\nstatic void put_child_connect_map(struct r8a66597 *r8a66597, int address)\n{\n\tint idx;\n\n\tidx = address / 32;\n\tr8a66597->child_connect_map[idx] &= ~(1 << (address % 32));\n}\n\nstatic void set_pipe_reg_addr(struct r8a66597_pipe *pipe, u8 dma_ch)\n{\n\tu16 pipenum = pipe->info.pipenum;\n\tconst unsigned long fifoaddr[] = {D0FIFO, D1FIFO, CFIFO};\n\tconst unsigned long fifosel[] = {D0FIFOSEL, D1FIFOSEL, CFIFOSEL};\n\tconst unsigned long fifoctr[] = {D0FIFOCTR, D1FIFOCTR, CFIFOCTR};\n\n\tif (dma_ch > R8A66597_PIPE_NO_DMA)\t \n\t\tdma_ch = R8A66597_PIPE_NO_DMA;\n\n\tpipe->fifoaddr = fifoaddr[dma_ch];\n\tpipe->fifosel = fifosel[dma_ch];\n\tpipe->fifoctr = fifoctr[dma_ch];\n\n\tif (pipenum == 0)\n\t\tpipe->pipectr = DCPCTR;\n\telse\n\t\tpipe->pipectr = get_pipectr_addr(pipenum);\n\n\tif (check_bulk_or_isoc(pipenum)) {\n\t\tpipe->pipetre = get_pipetre_addr(pipenum);\n\t\tpipe->pipetrn = get_pipetrn_addr(pipenum);\n\t} else {\n\t\tpipe->pipetre = 0;\n\t\tpipe->pipetrn = 0;\n\t}\n}\n\nstatic struct r8a66597_device *\nget_urb_to_r8a66597_dev(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tif (usb_pipedevice(urb->pipe) == 0)\n\t\treturn &r8a66597->device0;\n\n\treturn dev_get_drvdata(&urb->dev->dev);\n}\n\nstatic int make_r8a66597_device(struct r8a66597 *r8a66597,\n\t\t\t\tstruct urb *urb, u8 addr)\n{\n\tstruct r8a66597_device *dev;\n\tint usb_address = urb->setup_packet[2];\t \n\n\tdev = kzalloc(sizeof(struct r8a66597_device), GFP_ATOMIC);\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tdev_set_drvdata(&urb->dev->dev, dev);\n\tdev->udev = urb->dev;\n\tdev->address = addr;\n\tdev->usb_address = usb_address;\n\tdev->state = USB_STATE_ADDRESS;\n\tdev->ep_in_toggle = 0;\n\tdev->ep_out_toggle = 0;\n\tINIT_LIST_HEAD(&dev->device_list);\n\tlist_add_tail(&dev->device_list, &r8a66597->child_device);\n\n\tget_port_number(r8a66597, urb->dev->devpath,\n\t\t\t&dev->root_port, &dev->hub_port);\n\tif (!is_child_device(urb->dev->devpath))\n\t\tr8a66597->root_hub[dev->root_port].dev = dev;\n\n\tset_devadd_reg(r8a66597, dev->address,\n\t\t       get_r8a66597_usb_speed(urb->dev->speed),\n\t\t       get_parent_r8a66597_address(r8a66597, urb->dev),\n\t\t       dev->hub_port, dev->root_port);\n\n\treturn 0;\n}\n\n \nstatic u8 alloc_usb_address(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tu8 addr;\t \n\tstruct r8a66597_device *dev;\n\n\tif (is_hub_limit(urb->dev->devpath)) {\n\t\tdev_err(&urb->dev->dev, \"External hub limit reached.\\n\");\n\t\treturn 0;\n\t}\n\n\tdev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\tif (dev && dev->state >= USB_STATE_ADDRESS)\n\t\treturn dev->address;\n\n\tfor (addr = 1; addr <= R8A66597_MAX_DEVICE; addr++) {\n\t\tif (r8a66597->address_map & (1 << addr))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&urb->dev->dev, \"alloc_address: r8a66597_addr=%d\\n\", addr);\n\t\tr8a66597->address_map |= 1 << addr;\n\n\t\tif (make_r8a66597_device(r8a66597, urb, addr) < 0)\n\t\t\treturn 0;\n\n\t\treturn addr;\n\t}\n\n\tdev_err(&urb->dev->dev,\n\t\t\"cannot communicate with a USB device more than 10.(%x)\\n\",\n\t\tr8a66597->address_map);\n\n\treturn 0;\n}\n\n \nstatic void free_usb_address(struct r8a66597 *r8a66597,\n\t\t\t     struct r8a66597_device *dev, int reset)\n{\n\tint port;\n\n\tif (!dev)\n\t\treturn;\n\n\tdev_dbg(&dev->udev->dev, \"free_addr: addr=%d\\n\", dev->address);\n\n\tdev->state = USB_STATE_DEFAULT;\n\tr8a66597->address_map &= ~(1 << dev->address);\n\tdev->address = 0;\n\t \n\tif (reset)\n\t\tdev_set_drvdata(&dev->udev->dev, NULL);\n\tlist_del(&dev->device_list);\n\tkfree(dev);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++) {\n\t\tif (r8a66597->root_hub[port].dev == dev) {\n\t\t\tr8a66597->root_hub[port].dev = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void r8a66597_reg_wait(struct r8a66597 *r8a66597, unsigned long reg,\n\t\t\t      u16 mask, u16 loop)\n{\n\tu16 tmp;\n\tint i = 0;\n\n\tdo {\n\t\ttmp = r8a66597_read(r8a66597, reg);\n\t\tif (i++ > 1000000) {\n\t\t\tprintk(KERN_ERR \"r8a66597: register%lx, loop %x \"\n\t\t\t       \"is timeout\\n\", reg, loop);\n\t\t\tbreak;\n\t\t}\n\t\tndelay(1);\n\t} while ((tmp & mask) != loop);\n}\n\n \nstatic void pipe_start(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;\n\tif ((pipe->info.pipenum != 0) & ((tmp & PID_STALL) != 0))  \n\t\tr8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);\n\tr8a66597_mdfy(r8a66597, PID_BUF, PID, pipe->pipectr);\n}\n\n \nstatic void pipe_stop(struct r8a66597 *r8a66597, struct r8a66597_pipe *pipe)\n{\n\tu16 tmp;\n\n\ttmp = r8a66597_read(r8a66597, pipe->pipectr) & PID;\n\tif ((tmp & PID_STALL11) != PID_STALL11)\t \n\t\tr8a66597_mdfy(r8a66597, PID_STALL, PID, pipe->pipectr);\n\tr8a66597_mdfy(r8a66597, PID_NAK, PID, pipe->pipectr);\n\tr8a66597_reg_wait(r8a66597, pipe->pipectr, PBUSY, 0);\n}\n\n \nstatic void clear_all_buffer(struct r8a66597 *r8a66597,\n\t\t\t     struct r8a66597_pipe *pipe)\n{\n\tif (!pipe || pipe->info.pipenum == 0)\n\t\treturn;\n\n\tpipe_stop(r8a66597, pipe);\n\tr8a66597_bset(r8a66597, ACLRM, pipe->pipectr);\n\tr8a66597_read(r8a66597, pipe->pipectr);\n\tr8a66597_read(r8a66597, pipe->pipectr);\n\tr8a66597_read(r8a66597, pipe->pipectr);\n\tr8a66597_bclr(r8a66597, ACLRM, pipe->pipectr);\n}\n\n \nstatic void r8a66597_pipe_toggle(struct r8a66597 *r8a66597,\n\t\t\t\t struct r8a66597_pipe *pipe, int toggle)\n{\n\tif (toggle)\n\t\tr8a66597_bset(r8a66597, SQSET, pipe->pipectr);\n\telse\n\t\tr8a66597_bset(r8a66597, SQCLR, pipe->pipectr);\n}\n\nstatic inline unsigned short mbw_value(struct r8a66597 *r8a66597)\n{\n\tif (r8a66597->pdata->on_chip)\n\t\treturn MBW_32;\n\telse\n\t\treturn MBW_16;\n}\n\n \nstatic inline void cfifo_change(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tunsigned short mbw = mbw_value(r8a66597);\n\n\tr8a66597_mdfy(r8a66597, mbw | pipenum, mbw | CURPIPE, CFIFOSEL);\n\tr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, pipenum);\n}\n\n \nstatic inline void fifo_change_from_pipe(struct r8a66597 *r8a66597,\n\t\t\t\t\t struct r8a66597_pipe *pipe)\n{\n\tunsigned short mbw = mbw_value(r8a66597);\n\n\tcfifo_change(r8a66597, 0);\n\tr8a66597_mdfy(r8a66597, mbw | 0, mbw | CURPIPE, D0FIFOSEL);\n\tr8a66597_mdfy(r8a66597, mbw | 0, mbw | CURPIPE, D1FIFOSEL);\n\n\tr8a66597_mdfy(r8a66597, mbw | pipe->info.pipenum, mbw | CURPIPE,\n\t\t      pipe->fifosel);\n\tr8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE, pipe->info.pipenum);\n}\n\nstatic u16 r8a66597_get_pipenum(struct urb *urb, struct usb_host_endpoint *hep)\n{\n\tstruct r8a66597_pipe *pipe = hep->hcpriv;\n\n\tif (usb_pipeendpoint(urb->pipe) == 0)\n\t\treturn 0;\n\telse\n\t\treturn pipe->info.pipenum;\n}\n\nstatic u16 get_urb_to_r8a66597_addr(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\n\treturn (usb_pipedevice(urb->pipe) == 0) ? 0 : dev->address;\n}\n\nstatic unsigned short *get_toggle_pointer(struct r8a66597_device *dev,\n\t\t\t\t\t  int urb_pipe)\n{\n\tif (!dev)\n\t\treturn NULL;\n\n\treturn usb_pipein(urb_pipe) ? &dev->ep_in_toggle : &dev->ep_out_toggle;\n}\n\n \nstatic void pipe_toggle_set(struct r8a66597 *r8a66597,\n\t\t\t    struct r8a66597_pipe *pipe,\n\t\t\t    struct urb *urb, int set)\n{\n\tstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\tunsigned char endpoint = usb_pipeendpoint(urb->pipe);\n\tunsigned short *toggle = get_toggle_pointer(dev, urb->pipe);\n\n\tif (!toggle)\n\t\treturn;\n\n\tif (set)\n\t\t*toggle |= 1 << endpoint;\n\telse\n\t\t*toggle &= ~(1 << endpoint);\n}\n\n \nstatic void pipe_toggle_save(struct r8a66597 *r8a66597,\n\t\t\t     struct r8a66597_pipe *pipe,\n\t\t\t     struct urb *urb)\n{\n\tif (r8a66597_read(r8a66597, pipe->pipectr) & SQMON)\n\t\tpipe_toggle_set(r8a66597, pipe, urb, 1);\n\telse\n\t\tpipe_toggle_set(r8a66597, pipe, urb, 0);\n}\n\n \nstatic void pipe_toggle_restore(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_pipe *pipe,\n\t\t\t\tstruct urb *urb)\n{\n\tstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\tunsigned char endpoint = usb_pipeendpoint(urb->pipe);\n\tunsigned short *toggle = get_toggle_pointer(dev, urb->pipe);\n\n\tif (!toggle)\n\t\treturn;\n\n\tr8a66597_pipe_toggle(r8a66597, pipe, *toggle & (1 << endpoint));\n}\n\n \nstatic void pipe_buffer_setting(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_pipe_info *info)\n{\n\tu16 val = 0;\n\n\tif (info->pipenum == 0)\n\t\treturn;\n\n\tr8a66597_bset(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));\n\tr8a66597_bclr(r8a66597, ACLRM, get_pipectr_addr(info->pipenum));\n\tr8a66597_write(r8a66597, info->pipenum, PIPESEL);\n\tif (!info->dir_in)\n\t\tval |= R8A66597_DIR;\n\tif (info->type == R8A66597_BULK && info->dir_in)\n\t\tval |= R8A66597_DBLB | R8A66597_SHTNAK;\n\tval |= info->type | info->epnum;\n\tr8a66597_write(r8a66597, val, PIPECFG);\n\n\tr8a66597_write(r8a66597, (info->buf_bsize << 10) | (info->bufnum),\n\t\t       PIPEBUF);\n\tr8a66597_write(r8a66597, make_devsel(info->address) | info->maxpacket,\n\t\t       PIPEMAXP);\n\tr8a66597_write(r8a66597, info->interval, PIPEPERI);\n}\n\n \nstatic void pipe_setting(struct r8a66597 *r8a66597, struct r8a66597_td *td)\n{\n\tstruct r8a66597_pipe_info *info;\n\tstruct urb *urb = td->urb;\n\n\tif (td->pipenum > 0) {\n\t\tinfo = &td->pipe->info;\n\t\tcfifo_change(r8a66597, 0);\n\t\tpipe_buffer_setting(r8a66597, info);\n\n\t\tif (!usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t\t   usb_pipeout(urb->pipe)) &&\n\t\t    !usb_pipecontrol(urb->pipe)) {\n\t\t\tr8a66597_pipe_toggle(r8a66597, td->pipe, 0);\n\t\t\tpipe_toggle_set(r8a66597, td->pipe, urb, 0);\n\t\t\tclear_all_buffer(r8a66597, td->pipe);\n\t\t\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t\t      usb_pipeout(urb->pipe), 1);\n\t\t}\n\t\tpipe_toggle_restore(r8a66597, td->pipe, urb);\n\t}\n}\n\n \nstatic u16 get_empty_pipenum(struct r8a66597 *r8a66597,\n\t\t\t     struct usb_endpoint_descriptor *ep)\n{\n\tu16 array[R8A66597_MAX_NUM_PIPE], i = 0, min;\n\n\tmemset(array, 0, sizeof(array));\n\tswitch (usb_endpoint_type(ep)) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tif (usb_endpoint_dir_in(ep))\n\t\t\tarray[i++] = 4;\n\t\telse {\n\t\t\tarray[i++] = 3;\n\t\t\tarray[i++] = 5;\n\t\t}\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tif (usb_endpoint_dir_in(ep)) {\n\t\t\tarray[i++] = 6;\n\t\t\tarray[i++] = 7;\n\t\t\tarray[i++] = 8;\n\t\t} else\n\t\t\tarray[i++] = 9;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tif (usb_endpoint_dir_in(ep))\n\t\t\tarray[i++] = 2;\n\t\telse\n\t\t\tarray[i++] = 1;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"r8a66597: Illegal type\\n\");\n\t\treturn 0;\n\t}\n\n\ti = 1;\n\tmin = array[0];\n\twhile (array[i] != 0) {\n\t\tif (r8a66597->pipe_cnt[min] > r8a66597->pipe_cnt[array[i]])\n\t\t\tmin = array[i];\n\t\ti++;\n\t}\n\n\treturn min;\n}\n\nstatic u16 get_r8a66597_type(__u8 type)\n{\n\tu16 r8a66597_type;\n\n\tswitch (type) {\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tr8a66597_type = R8A66597_BULK;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tr8a66597_type = R8A66597_INT;\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\tr8a66597_type = R8A66597_ISO;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"r8a66597: Illegal type\\n\");\n\t\tr8a66597_type = 0x0000;\n\t\tbreak;\n\t}\n\n\treturn r8a66597_type;\n}\n\nstatic u16 get_bufnum(u16 pipenum)\n{\n\tu16 bufnum = 0;\n\n\tif (pipenum == 0)\n\t\tbufnum = 0;\n\telse if (check_bulk_or_isoc(pipenum))\n\t\tbufnum = 8 + (pipenum - 1) * R8A66597_BUF_BSIZE*2;\n\telse if (check_interrupt(pipenum))\n\t\tbufnum = 4 + (pipenum - 6);\n\telse\n\t\tprintk(KERN_ERR \"r8a66597: Illegal pipenum (%d)\\n\", pipenum);\n\n\treturn bufnum;\n}\n\nstatic u16 get_buf_bsize(u16 pipenum)\n{\n\tu16 buf_bsize = 0;\n\n\tif (pipenum == 0)\n\t\tbuf_bsize = 3;\n\telse if (check_bulk_or_isoc(pipenum))\n\t\tbuf_bsize = R8A66597_BUF_BSIZE - 1;\n\telse if (check_interrupt(pipenum))\n\t\tbuf_bsize = 0;\n\telse\n\t\tprintk(KERN_ERR \"r8a66597: Illegal pipenum (%d)\\n\", pipenum);\n\n\treturn buf_bsize;\n}\n\n \nstatic void enable_r8a66597_pipe_dma(struct r8a66597 *r8a66597,\n\t\t\t\t     struct r8a66597_device *dev,\n\t\t\t\t     struct r8a66597_pipe *pipe,\n\t\t\t\t     struct urb *urb)\n{\n\tint i;\n\tstruct r8a66597_pipe_info *info = &pipe->info;\n\tunsigned short mbw = mbw_value(r8a66597);\n\n\t \n\tif (r8a66597->pdata->on_chip)\n\t\treturn;\n\n\tif ((pipe->info.pipenum != 0) && (info->type != R8A66597_INT)) {\n\t\tfor (i = 0; i < R8A66597_MAX_DMA_CHANNEL; i++) {\n\t\t\tif ((r8a66597->dma_map & (1 << i)) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tdev_info(&dev->udev->dev,\n\t\t\t\t \"address %d, EndpointAddress 0x%02x use \"\n\t\t\t\t \"DMA FIFO\\n\", usb_pipedevice(urb->pipe),\n\t\t\t\t info->dir_in ?\n\t\t\t\t \tUSB_ENDPOINT_DIR_MASK + info->epnum\n\t\t\t\t\t: info->epnum);\n\n\t\t\tr8a66597->dma_map |= 1 << i;\n\t\t\tdev->dma_map |= 1 << i;\n\t\t\tset_pipe_reg_addr(pipe, i);\n\n\t\t\tcfifo_change(r8a66597, 0);\n\t\t\tr8a66597_mdfy(r8a66597, mbw | pipe->info.pipenum,\n\t\t\t\t      mbw | CURPIPE, pipe->fifosel);\n\n\t\t\tr8a66597_reg_wait(r8a66597, pipe->fifosel, CURPIPE,\n\t\t\t\t\t  pipe->info.pipenum);\n\t\t\tr8a66597_bset(r8a66597, BCLR, pipe->fifoctr);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n \nstatic void enable_r8a66597_pipe(struct r8a66597 *r8a66597, struct urb *urb,\n\t\t\t\t struct usb_host_endpoint *hep,\n\t\t\t\t struct r8a66597_pipe_info *info)\n{\n\tstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\tstruct r8a66597_pipe *pipe = hep->hcpriv;\n\n\tdev_dbg(&dev->udev->dev, \"enable_pipe:\\n\");\n\n\tpipe->info = *info;\n\tset_pipe_reg_addr(pipe, R8A66597_PIPE_NO_DMA);\n\tr8a66597->pipe_cnt[pipe->info.pipenum]++;\n\tdev->pipe_cnt[pipe->info.pipenum]++;\n\n\tenable_r8a66597_pipe_dma(r8a66597, dev, pipe, urb);\n}\n\nstatic void r8a66597_urb_done(struct r8a66597 *r8a66597, struct urb *urb,\n\t\t\t      int status)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tif (usb_pipein(urb->pipe) && usb_pipetype(urb->pipe) != PIPE_CONTROL) {\n\t\tvoid *ptr;\n\n\t\tfor (ptr = urb->transfer_buffer;\n\t\t     ptr < urb->transfer_buffer + urb->transfer_buffer_length;\n\t\t     ptr += PAGE_SIZE)\n\t\t\tflush_dcache_page(virt_to_page(ptr));\n\t}\n\n\tusb_hcd_unlink_urb_from_ep(r8a66597_to_hcd(r8a66597), urb);\n\tspin_unlock(&r8a66597->lock);\n\tusb_hcd_giveback_urb(r8a66597_to_hcd(r8a66597), urb, status);\n\tspin_lock(&r8a66597->lock);\n}\n\n \nstatic void force_dequeue(struct r8a66597 *r8a66597, u16 pipenum, u16 address)\n{\n\tstruct r8a66597_td *td, *next;\n\tstruct urb *urb;\n\tstruct list_head *list = &r8a66597->pipe_queue[pipenum];\n\n\tif (list_empty(list))\n\t\treturn;\n\n\tlist_for_each_entry_safe(td, next, list, queue) {\n\t\tif (td->address != address)\n\t\t\tcontinue;\n\n\t\turb = td->urb;\n\t\tlist_del(&td->queue);\n\t\tkfree(td);\n\n\t\tif (urb)\n\t\t\tr8a66597_urb_done(r8a66597, urb, -ENODEV);\n\n\t\tbreak;\n\t}\n}\n\n \nstatic void disable_r8a66597_pipe_all(struct r8a66597 *r8a66597,\n\t\t\t\t      struct r8a66597_device *dev)\n{\n\tint check_ep0 = 0;\n\tu16 pipenum;\n\n\tif (!dev)\n\t\treturn;\n\n\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tif (!dev->pipe_cnt[pipenum])\n\t\t\tcontinue;\n\n\t\tif (!check_ep0) {\n\t\t\tcheck_ep0 = 1;\n\t\t\tforce_dequeue(r8a66597, 0, dev->address);\n\t\t}\n\n\t\tr8a66597->pipe_cnt[pipenum] -= dev->pipe_cnt[pipenum];\n\t\tdev->pipe_cnt[pipenum] = 0;\n\t\tforce_dequeue(r8a66597, pipenum, dev->address);\n\t}\n\n\tdev_dbg(&dev->udev->dev, \"disable_pipe\\n\");\n\n\tr8a66597->dma_map &= ~(dev->dma_map);\n\tdev->dma_map = 0;\n}\n\nstatic u16 get_interval(struct urb *urb, __u8 interval)\n{\n\tu16 time = 1;\n\tint i;\n\n\tif (urb->dev->speed == USB_SPEED_HIGH) {\n\t\tif (interval > IITV)\n\t\t\ttime = IITV;\n\t\telse\n\t\t\ttime = interval ? interval - 1 : 0;\n\t} else {\n\t\tif (interval > 128) {\n\t\t\ttime = IITV;\n\t\t} else {\n\t\t\t \n\t\t\tfor (i = 0; i < 7; i++) {\n\t\t\t\tif ((1 << i) < interval &&\n\t\t\t\t    (1 << (i + 1) > interval))\n\t\t\t\t\ttime = 1 << i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn time;\n}\n\nstatic unsigned long get_timer_interval(struct urb *urb, __u8 interval)\n{\n\t__u8 i;\n\tunsigned long time = 1;\n\n\tif (usb_pipeisoc(urb->pipe))\n\t\treturn 0;\n\n\tif (get_r8a66597_usb_speed(urb->dev->speed) == HSMODE) {\n\t\tfor (i = 0; i < (interval - 1); i++)\n\t\t\ttime *= 2;\n\t\ttime = time * 125 / 1000;\t \n\t} else {\n\t\ttime = interval;\n\t}\n\n\treturn time;\n}\n\n \nstatic void init_pipe_info(struct r8a66597 *r8a66597, struct urb *urb,\n\t\t\t   struct usb_host_endpoint *hep,\n\t\t\t   struct usb_endpoint_descriptor *ep)\n{\n\tstruct r8a66597_pipe_info info;\n\n\tinfo.pipenum = get_empty_pipenum(r8a66597, ep);\n\tinfo.address = get_urb_to_r8a66597_addr(r8a66597, urb);\n\tinfo.epnum = usb_endpoint_num(ep);\n\tinfo.maxpacket = usb_endpoint_maxp(ep);\n\tinfo.type = get_r8a66597_type(usb_endpoint_type(ep));\n\tinfo.bufnum = get_bufnum(info.pipenum);\n\tinfo.buf_bsize = get_buf_bsize(info.pipenum);\n\tif (info.type == R8A66597_BULK) {\n\t\tinfo.interval = 0;\n\t\tinfo.timer_interval = 0;\n\t} else {\n\t\tinfo.interval = get_interval(urb, ep->bInterval);\n\t\tinfo.timer_interval = get_timer_interval(urb, ep->bInterval);\n\t}\n\tif (usb_endpoint_dir_in(ep))\n\t\tinfo.dir_in = 1;\n\telse\n\t\tinfo.dir_in = 0;\n\n\tenable_r8a66597_pipe(r8a66597, urb, hep, &info);\n}\n\nstatic void init_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tstruct r8a66597_device *dev;\n\n\tdev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\tdev->state = USB_STATE_CONFIGURED;\n}\n\nstatic void pipe_irq_enable(struct r8a66597 *r8a66597, struct urb *urb,\n\t\t\t    u16 pipenum)\n{\n\tif (pipenum == 0 && usb_pipeout(urb->pipe))\n\t\tenable_irq_empty(r8a66597, pipenum);\n\telse\n\t\tenable_irq_ready(r8a66597, pipenum);\n\n\tif (!usb_pipeisoc(urb->pipe))\n\t\tenable_irq_nrdy(r8a66597, pipenum);\n}\n\nstatic void pipe_irq_disable(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tdisable_irq_ready(r8a66597, pipenum);\n\tdisable_irq_nrdy(r8a66597, pipenum);\n}\n\nstatic void r8a66597_root_hub_start_polling(struct r8a66597 *r8a66597)\n{\n\tmod_timer(&r8a66597->rh_timer,\n\t\t\tjiffies + msecs_to_jiffies(R8A66597_RH_POLL_TIME));\n}\n\nstatic void start_root_hub_sampling(struct r8a66597 *r8a66597, int port,\n\t\t\t\t\tint connect)\n{\n\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\n\trh->old_syssts = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;\n\trh->scount = R8A66597_MAX_SAMPLING;\n\tif (connect)\n\t\trh->port |= USB_PORT_STAT_CONNECTION;\n\telse\n\t\trh->port &= ~USB_PORT_STAT_CONNECTION;\n\trh->port |= USB_PORT_STAT_C_CONNECTION << 16;\n\n\tr8a66597_root_hub_start_polling(r8a66597);\n}\n\n \nstatic void r8a66597_check_syssts(struct r8a66597 *r8a66597, int port,\n\t\t\t\t\tu16 syssts)\n__releases(r8a66597->lock)\n__acquires(r8a66597->lock)\n{\n\tif (syssts == SE0) {\n\t\tr8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));\n\t\tr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\n\t} else {\n\t\tif (syssts == FS_JSTS)\n\t\t\tr8a66597_bset(r8a66597, HSE, get_syscfg_reg(port));\n\t\telse if (syssts == LS_JSTS)\n\t\t\tr8a66597_bclr(r8a66597, HSE, get_syscfg_reg(port));\n\n\t\tr8a66597_write(r8a66597, ~DTCH, get_intsts_reg(port));\n\t\tr8a66597_bset(r8a66597, DTCHE, get_intenb_reg(port));\n\n\t\tif (r8a66597->bus_suspended)\n\t\t\tusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\n\t}\n\n\tspin_unlock(&r8a66597->lock);\n\tusb_hcd_poll_rh_status(r8a66597_to_hcd(r8a66597));\n\tspin_lock(&r8a66597->lock);\n}\n\n \nstatic void r8a66597_usb_connect(struct r8a66597 *r8a66597, int port)\n{\n\tu16 speed = get_rh_usb_speed(r8a66597, port);\n\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\n\trh->port &= ~(USB_PORT_STAT_HIGH_SPEED | USB_PORT_STAT_LOW_SPEED);\n\tif (speed == HSMODE)\n\t\trh->port |= USB_PORT_STAT_HIGH_SPEED;\n\telse if (speed == LSMODE)\n\t\trh->port |= USB_PORT_STAT_LOW_SPEED;\n\n\trh->port &= ~USB_PORT_STAT_RESET;\n\trh->port |= USB_PORT_STAT_ENABLE;\n}\n\n \nstatic void r8a66597_usb_disconnect(struct r8a66597 *r8a66597, int port)\n{\n\tstruct r8a66597_device *dev = r8a66597->root_hub[port].dev;\n\n\tdisable_r8a66597_pipe_all(r8a66597, dev);\n\tfree_usb_address(r8a66597, dev, 0);\n\n\tstart_root_hub_sampling(r8a66597, port, 0);\n}\n\n \nstatic void prepare_setup_packet(struct r8a66597 *r8a66597,\n\t\t\t\t struct r8a66597_td *td)\n{\n\tint i;\n\t__le16 *p = (__le16 *)td->urb->setup_packet;\n\tunsigned long setup_addr = USBREQ;\n\n\tr8a66597_write(r8a66597, make_devsel(td->address) | td->maxpacket,\n\t\t       DCPMAXP);\n\tr8a66597_write(r8a66597, ~(SIGN | SACK), INTSTS1);\n\n\tfor (i = 0; i < 4; i++) {\n\t\tr8a66597_write(r8a66597, le16_to_cpu(p[i]), setup_addr);\n\t\tsetup_addr += 2;\n\t}\n\tr8a66597_write(r8a66597, SUREQ, DCPCTR);\n}\n\n \nstatic void prepare_packet_read(struct r8a66597 *r8a66597,\n\t\t\t\tstruct r8a66597_td *td)\n{\n\tstruct urb *urb = td->urb;\n\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\tr8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);\n\t\tr8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);\n\t\tr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\n\t\tif (urb->actual_length == 0) {\n\t\t\tr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\n\t\t\tr8a66597_write(r8a66597, BCLR, CFIFOCTR);\n\t\t}\n\t\tpipe_irq_disable(r8a66597, td->pipenum);\n\t\tpipe_start(r8a66597, td->pipe);\n\t\tpipe_irq_enable(r8a66597, urb, td->pipenum);\n\t} else {\n\t\tif (urb->actual_length == 0) {\n\t\t\tpipe_irq_disable(r8a66597, td->pipenum);\n\t\t\tpipe_setting(r8a66597, td);\n\t\t\tpipe_stop(r8a66597, td->pipe);\n\t\t\tr8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);\n\n\t\t\tif (td->pipe->pipetre) {\n\t\t\t\tr8a66597_write(r8a66597, TRCLR,\n\t\t\t\t\t\ttd->pipe->pipetre);\n\t\t\t\tr8a66597_write(r8a66597,\n\t\t\t\t\t\tDIV_ROUND_UP\n\t\t\t\t\t\t  (urb->transfer_buffer_length,\n\t\t\t\t\t\t   td->maxpacket),\n\t\t\t\t\t\ttd->pipe->pipetrn);\n\t\t\t\tr8a66597_bset(r8a66597, TRENB,\n\t\t\t\t\t\ttd->pipe->pipetre);\n\t\t\t}\n\n\t\t\tpipe_start(r8a66597, td->pipe);\n\t\t\tpipe_irq_enable(r8a66597, urb, td->pipenum);\n\t\t}\n\t}\n}\n\n \nstatic void prepare_packet_write(struct r8a66597 *r8a66597,\n\t\t\t\t struct r8a66597_td *td)\n{\n\tu16 tmp;\n\tstruct urb *urb = td->urb;\n\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\tpipe_stop(r8a66597, td->pipe);\n\t\tr8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);\n\t\tr8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);\n\t\tr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\n\t\tif (urb->actual_length == 0) {\n\t\t\tr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\n\t\t\tr8a66597_write(r8a66597, BCLR, CFIFOCTR);\n\t\t}\n\t} else {\n\t\tif (urb->actual_length == 0)\n\t\t\tpipe_setting(r8a66597, td);\n\t\tif (td->pipe->pipetre)\n\t\t\tr8a66597_bclr(r8a66597, TRENB, td->pipe->pipetre);\n\t}\n\tr8a66597_write(r8a66597, ~(1 << td->pipenum), BRDYSTS);\n\n\tfifo_change_from_pipe(r8a66597, td->pipe);\n\ttmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\n\tif (unlikely((tmp & FRDY) == 0))\n\t\tpipe_irq_enable(r8a66597, urb, td->pipenum);\n\telse\n\t\tpacket_write(r8a66597, td->pipenum);\n\tpipe_start(r8a66597, td->pipe);\n}\n\n \nstatic void prepare_status_packet(struct r8a66597 *r8a66597,\n\t\t\t\t  struct r8a66597_td *td)\n{\n\tstruct urb *urb = td->urb;\n\n\tr8a66597_pipe_toggle(r8a66597, td->pipe, 1);\n\tpipe_stop(r8a66597, td->pipe);\n\n\tif (urb->setup_packet[0] & USB_ENDPOINT_DIR_MASK) {\n\t\tr8a66597_bset(r8a66597, R8A66597_DIR, DCPCFG);\n\t\tr8a66597_mdfy(r8a66597, ISEL, ISEL | CURPIPE, CFIFOSEL);\n\t\tr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\n\t\tr8a66597_write(r8a66597, ~BEMP0, BEMPSTS);\n\t\tr8a66597_write(r8a66597, BCLR | BVAL, CFIFOCTR);\n\t\tenable_irq_empty(r8a66597, 0);\n\t} else {\n\t\tr8a66597_bclr(r8a66597, R8A66597_DIR, DCPCFG);\n\t\tr8a66597_mdfy(r8a66597, 0, ISEL | CURPIPE, CFIFOSEL);\n\t\tr8a66597_reg_wait(r8a66597, CFIFOSEL, CURPIPE, 0);\n\t\tr8a66597_write(r8a66597, BCLR, CFIFOCTR);\n\t\tenable_irq_ready(r8a66597, 0);\n\t}\n\tenable_irq_nrdy(r8a66597, 0);\n\tpipe_start(r8a66597, td->pipe);\n}\n\nstatic int is_set_address(unsigned char *setup_packet)\n{\n\tif (((setup_packet[0] & USB_TYPE_MASK) == USB_TYPE_STANDARD) &&\n\t\t\tsetup_packet[1] == USB_REQ_SET_ADDRESS)\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\n \nstatic int start_transfer(struct r8a66597 *r8a66597, struct r8a66597_td *td)\n{\n\tBUG_ON(!td);\n\n\tswitch (td->type) {\n\tcase USB_PID_SETUP:\n\t\tif (is_set_address(td->urb->setup_packet)) {\n\t\t\ttd->set_address = 1;\n\t\t\ttd->urb->setup_packet[2] = alloc_usb_address(r8a66597,\n\t\t\t\t\t\t\t\t     td->urb);\n\t\t\tif (td->urb->setup_packet[2] == 0)\n\t\t\t\treturn -EPIPE;\n\t\t}\n\t\tprepare_setup_packet(r8a66597, td);\n\t\tbreak;\n\tcase USB_PID_IN:\n\t\tprepare_packet_read(r8a66597, td);\n\t\tbreak;\n\tcase USB_PID_OUT:\n\t\tprepare_packet_write(r8a66597, td);\n\t\tbreak;\n\tcase USB_PID_ACK:\n\t\tprepare_status_packet(r8a66597, td);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"r8a66597: invalid type.\\n\");\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int check_transfer_finish(struct r8a66597_td *td, struct urb *urb)\n{\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\tif (urb->number_of_packets == td->iso_cnt)\n\t\t\treturn 1;\n\t}\n\n\t \n\tif ((urb->transfer_buffer_length <= urb->actual_length) ||\n\t    (td->short_packet) || (td->zero_packet))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n \nstatic void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)\n{\n\tunsigned long time;\n\n\tBUG_ON(!td);\n\n\tif (!list_empty(&r8a66597->pipe_queue[td->pipenum]) &&\n\t    !usb_pipecontrol(td->urb->pipe) && usb_pipein(td->urb->pipe)) {\n\t\tr8a66597->timeout_map |= 1 << td->pipenum;\n\t\tswitch (usb_pipetype(td->urb->pipe)) {\n\t\tcase PIPE_INTERRUPT:\n\t\tcase PIPE_ISOCHRONOUS:\n\t\t\ttime = 30;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttime = 50;\n\t\t\tbreak;\n\t\t}\n\n\t\tmod_timer(&r8a66597->timers[td->pipenum].td,\n\t\t\t  jiffies + msecs_to_jiffies(time));\n\t}\n}\n\n \nstatic void finish_request(struct r8a66597 *r8a66597, struct r8a66597_td *td,\n\t\tu16 pipenum, struct urb *urb, int status)\n__releases(r8a66597->lock) __acquires(r8a66597->lock)\n{\n\tint restart = 0;\n\tstruct usb_hcd *hcd = r8a66597_to_hcd(r8a66597);\n\n\tr8a66597->timeout_map &= ~(1 << pipenum);\n\n\tif (likely(td)) {\n\t\tif (td->set_address && (status != 0 || urb->unlinked))\n\t\t\tr8a66597->address_map &= ~(1 << urb->setup_packet[2]);\n\n\t\tpipe_toggle_save(r8a66597, td->pipe, urb);\n\t\tlist_del(&td->queue);\n\t\tkfree(td);\n\t}\n\n\tif (!list_empty(&r8a66597->pipe_queue[pipenum]))\n\t\trestart = 1;\n\n\tif (likely(urb)) {\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\turb->start_frame = r8a66597_get_frame(hcd);\n\n\t\tr8a66597_urb_done(r8a66597, urb, status);\n\t}\n\n\tif (restart) {\n\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\tif (unlikely(!td))\n\t\t\treturn;\n\n\t\tstart_transfer(r8a66597, td);\n\t\tset_td_timer(r8a66597, td);\n\t}\n}\n\nstatic void packet_read(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tu16 tmp;\n\tint rcv_len, bufsize, urb_len, size;\n\tu16 *buf;\n\tstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\n\tstruct urb *urb;\n\tint finish = 0;\n\tint status = 0;\n\n\tif (unlikely(!td))\n\t\treturn;\n\turb = td->urb;\n\n\tfifo_change_from_pipe(r8a66597, td->pipe);\n\ttmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\n\tif (unlikely((tmp & FRDY) == 0)) {\n\t\tpipe_stop(r8a66597, td->pipe);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tprintk(KERN_ERR \"r8a66597: in fifo not ready (%d)\\n\", pipenum);\n\t\tfinish_request(r8a66597, td, pipenum, td->urb, -EPIPE);\n\t\treturn;\n\t}\n\n\t \n\trcv_len = tmp & DTLN;\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\tbuf = (u16 *)(urb->transfer_buffer +\n\t\t\t\turb->iso_frame_desc[td->iso_cnt].offset);\n\t\turb_len = urb->iso_frame_desc[td->iso_cnt].length;\n\t} else {\n\t\tbuf = (void *)urb->transfer_buffer + urb->actual_length;\n\t\turb_len = urb->transfer_buffer_length - urb->actual_length;\n\t}\n\tbufsize = min(urb_len, (int) td->maxpacket);\n\tif (rcv_len <= bufsize) {\n\t\tsize = rcv_len;\n\t} else {\n\t\tsize = bufsize;\n\t\tstatus = -EOVERFLOW;\n\t\tfinish = 1;\n\t}\n\n\t \n\turb->actual_length += size;\n\tif (rcv_len == 0)\n\t\ttd->zero_packet = 1;\n\tif (rcv_len < bufsize) {\n\t\ttd->short_packet = 1;\n\t}\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\turb->iso_frame_desc[td->iso_cnt].actual_length = size;\n\t\turb->iso_frame_desc[td->iso_cnt].status = status;\n\t\ttd->iso_cnt++;\n\t\tfinish = 0;\n\t}\n\n\t \n\tif (finish || check_transfer_finish(td, urb)) {\n\t\tpipe_stop(r8a66597, td->pipe);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tfinish = 1;\n\t}\n\n\t \n\tif (urb->transfer_buffer) {\n\t\tif (size == 0)\n\t\t\tr8a66597_write(r8a66597, BCLR, td->pipe->fifoctr);\n\t\telse\n\t\t\tr8a66597_read_fifo(r8a66597, td->pipe->fifoaddr,\n\t\t\t\t\t   buf, size);\n\t}\n\n\tif (finish && pipenum != 0)\n\t\tfinish_request(r8a66597, td, pipenum, urb, status);\n}\n\nstatic void packet_write(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tu16 tmp;\n\tint bufsize, size;\n\tu16 *buf;\n\tstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\n\tstruct urb *urb;\n\n\tif (unlikely(!td))\n\t\treturn;\n\turb = td->urb;\n\n\tfifo_change_from_pipe(r8a66597, td->pipe);\n\ttmp = r8a66597_read(r8a66597, td->pipe->fifoctr);\n\tif (unlikely((tmp & FRDY) == 0)) {\n\t\tpipe_stop(r8a66597, td->pipe);\n\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\tprintk(KERN_ERR \"r8a66597: out fifo not ready (%d)\\n\", pipenum);\n\t\tfinish_request(r8a66597, td, pipenum, urb, -EPIPE);\n\t\treturn;\n\t}\n\n\t \n\tbufsize = td->maxpacket;\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\tbuf = (u16 *)(urb->transfer_buffer +\n\t\t\t\turb->iso_frame_desc[td->iso_cnt].offset);\n\t\tsize = min(bufsize,\n\t\t\t   (int)urb->iso_frame_desc[td->iso_cnt].length);\n\t} else {\n\t\tbuf = (u16 *)(urb->transfer_buffer + urb->actual_length);\n\t\tsize = min_t(u32, bufsize,\n\t\t\t   urb->transfer_buffer_length - urb->actual_length);\n\t}\n\n\t \n\tif (pipenum > 0)\n\t\tr8a66597_write(r8a66597, ~(1 << pipenum), BEMPSTS);\n\tif (urb->transfer_buffer) {\n\t\tr8a66597_write_fifo(r8a66597, td->pipe, buf, size);\n\t\tif (!usb_pipebulk(urb->pipe) || td->maxpacket != size)\n\t\t\tr8a66597_write(r8a66597, BVAL, td->pipe->fifoctr);\n\t}\n\n\t \n\turb->actual_length += size;\n\tif (usb_pipeisoc(urb->pipe)) {\n\t\turb->iso_frame_desc[td->iso_cnt].actual_length = size;\n\t\turb->iso_frame_desc[td->iso_cnt].status = 0;\n\t\ttd->iso_cnt++;\n\t}\n\n\t \n\tif (check_transfer_finish(td, urb)) {\n\t\tdisable_irq_ready(r8a66597, pipenum);\n\t\tenable_irq_empty(r8a66597, pipenum);\n\t\tif (!usb_pipeisoc(urb->pipe))\n\t\t\tenable_irq_nrdy(r8a66597, pipenum);\n\t} else\n\t\tpipe_irq_enable(r8a66597, urb, pipenum);\n}\n\n\nstatic void check_next_phase(struct r8a66597 *r8a66597, int status)\n{\n\tstruct r8a66597_td *td = r8a66597_get_td(r8a66597, 0);\n\tstruct urb *urb;\n\tu8 finish = 0;\n\n\tif (unlikely(!td))\n\t\treturn;\n\turb = td->urb;\n\n\tswitch (td->type) {\n\tcase USB_PID_IN:\n\tcase USB_PID_OUT:\n\t\tif (check_transfer_finish(td, urb))\n\t\t\ttd->type = USB_PID_ACK;\n\t\tbreak;\n\tcase USB_PID_SETUP:\n\t\tif (urb->transfer_buffer_length == urb->actual_length)\n\t\t\ttd->type = USB_PID_ACK;\n\t\telse if (usb_pipeout(urb->pipe))\n\t\t\ttd->type = USB_PID_OUT;\n\t\telse\n\t\t\ttd->type = USB_PID_IN;\n\t\tbreak;\n\tcase USB_PID_ACK:\n\t\tfinish = 1;\n\t\tbreak;\n\t}\n\n\tif (finish || status != 0 || urb->unlinked)\n\t\tfinish_request(r8a66597, td, 0, urb, status);\n\telse\n\t\tstart_transfer(r8a66597, td);\n}\n\nstatic int get_urb_error(struct r8a66597 *r8a66597, u16 pipenum)\n{\n\tstruct r8a66597_td *td = r8a66597_get_td(r8a66597, pipenum);\n\n\tif (td) {\n\t\tu16 pid = r8a66597_read(r8a66597, td->pipe->pipectr) & PID;\n\n\t\tif (pid == PID_NAK)\n\t\t\treturn -ECONNRESET;\n\t\telse\n\t\t\treturn -EPIPE;\n\t}\n\treturn 0;\n}\n\nstatic void irq_pipe_ready(struct r8a66597 *r8a66597)\n{\n\tu16 check;\n\tu16 pipenum;\n\tu16 mask;\n\tstruct r8a66597_td *td;\n\n\tmask = r8a66597_read(r8a66597, BRDYSTS)\n\t       & r8a66597_read(r8a66597, BRDYENB);\n\tr8a66597_write(r8a66597, ~mask, BRDYSTS);\n\tif (mask & BRDY0) {\n\t\ttd = r8a66597_get_td(r8a66597, 0);\n\t\tif (td && td->type == USB_PID_IN)\n\t\t\tpacket_read(r8a66597, 0);\n\t\telse\n\t\t\tpipe_irq_disable(r8a66597, 0);\n\t\tcheck_next_phase(r8a66597, 0);\n\t}\n\n\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tcheck = 1 << pipenum;\n\t\tif (mask & check) {\n\t\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\t\tif (unlikely(!td))\n\t\t\t\tcontinue;\n\n\t\t\tif (td->type == USB_PID_IN)\n\t\t\t\tpacket_read(r8a66597, pipenum);\n\t\t\telse if (td->type == USB_PID_OUT)\n\t\t\t\tpacket_write(r8a66597, pipenum);\n\t\t}\n\t}\n}\n\nstatic void irq_pipe_empty(struct r8a66597 *r8a66597)\n{\n\tu16 tmp;\n\tu16 check;\n\tu16 pipenum;\n\tu16 mask;\n\tstruct r8a66597_td *td;\n\n\tmask = r8a66597_read(r8a66597, BEMPSTS)\n\t       & r8a66597_read(r8a66597, BEMPENB);\n\tr8a66597_write(r8a66597, ~mask, BEMPSTS);\n\tif (mask & BEMP0) {\n\t\tcfifo_change(r8a66597, 0);\n\t\ttd = r8a66597_get_td(r8a66597, 0);\n\t\tif (td && td->type != USB_PID_OUT)\n\t\t\tdisable_irq_empty(r8a66597, 0);\n\t\tcheck_next_phase(r8a66597, 0);\n\t}\n\n\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tcheck = 1 << pipenum;\n\t\tif (mask &  check) {\n\t\t\tstruct r8a66597_td *td;\n\t\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\t\tif (unlikely(!td))\n\t\t\t\tcontinue;\n\n\t\t\ttmp = r8a66597_read(r8a66597, td->pipe->pipectr);\n\t\t\tif ((tmp & INBUFM) == 0) {\n\t\t\t\tdisable_irq_empty(r8a66597, pipenum);\n\t\t\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\t\t\tfinish_request(r8a66597, td, pipenum, td->urb,\n\t\t\t\t\t\t0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void irq_pipe_nrdy(struct r8a66597 *r8a66597)\n{\n\tu16 check;\n\tu16 pipenum;\n\tu16 mask;\n\tint status;\n\n\tmask = r8a66597_read(r8a66597, NRDYSTS)\n\t       & r8a66597_read(r8a66597, NRDYENB);\n\tr8a66597_write(r8a66597, ~mask, NRDYSTS);\n\tif (mask & NRDY0) {\n\t\tcfifo_change(r8a66597, 0);\n\t\tstatus = get_urb_error(r8a66597, 0);\n\t\tpipe_irq_disable(r8a66597, 0);\n\t\tcheck_next_phase(r8a66597, status);\n\t}\n\n\tfor (pipenum = 1; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tcheck = 1 << pipenum;\n\t\tif (mask & check) {\n\t\t\tstruct r8a66597_td *td;\n\t\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\t\tif (unlikely(!td))\n\t\t\t\tcontinue;\n\n\t\t\tstatus = get_urb_error(r8a66597, pipenum);\n\t\t\tpipe_irq_disable(r8a66597, pipenum);\n\t\t\tpipe_stop(r8a66597, td->pipe);\n\t\t\tfinish_request(r8a66597, td, pipenum, td->urb, status);\n\t\t}\n\t}\n}\n\nstatic irqreturn_t r8a66597_irq(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tu16 intsts0, intsts1, intsts2;\n\tu16 intenb0, intenb1, intenb2;\n\tu16 mask0, mask1, mask2;\n\tint status;\n\n\tspin_lock(&r8a66597->lock);\n\n\tintsts0 = r8a66597_read(r8a66597, INTSTS0);\n\tintsts1 = r8a66597_read(r8a66597, INTSTS1);\n\tintsts2 = r8a66597_read(r8a66597, INTSTS2);\n\tintenb0 = r8a66597_read(r8a66597, INTENB0);\n\tintenb1 = r8a66597_read(r8a66597, INTENB1);\n\tintenb2 = r8a66597_read(r8a66597, INTENB2);\n\n\tmask2 = intsts2 & intenb2;\n\tmask1 = intsts1 & intenb1;\n\tmask0 = intsts0 & intenb0 & (BEMP | NRDY | BRDY);\n\tif (mask2) {\n\t\tif (mask2 & ATTCH) {\n\t\t\tr8a66597_write(r8a66597, ~ATTCH, INTSTS2);\n\t\t\tr8a66597_bclr(r8a66597, ATTCHE, INTENB2);\n\n\t\t\t \n\t\t\tstart_root_hub_sampling(r8a66597, 1, 1);\n\t\t}\n\t\tif (mask2 & DTCH) {\n\t\t\tr8a66597_write(r8a66597, ~DTCH, INTSTS2);\n\t\t\tr8a66597_bclr(r8a66597, DTCHE, INTENB2);\n\t\t\tr8a66597_usb_disconnect(r8a66597, 1);\n\t\t}\n\t\tif (mask2 & BCHG) {\n\t\t\tr8a66597_write(r8a66597, ~BCHG, INTSTS2);\n\t\t\tr8a66597_bclr(r8a66597, BCHGE, INTENB2);\n\t\t\tusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\n\t\t}\n\t}\n\n\tif (mask1) {\n\t\tif (mask1 & ATTCH) {\n\t\t\tr8a66597_write(r8a66597, ~ATTCH, INTSTS1);\n\t\t\tr8a66597_bclr(r8a66597, ATTCHE, INTENB1);\n\n\t\t\t \n\t\t\tstart_root_hub_sampling(r8a66597, 0, 1);\n\t\t}\n\t\tif (mask1 & DTCH) {\n\t\t\tr8a66597_write(r8a66597, ~DTCH, INTSTS1);\n\t\t\tr8a66597_bclr(r8a66597, DTCHE, INTENB1);\n\t\t\tr8a66597_usb_disconnect(r8a66597, 0);\n\t\t}\n\t\tif (mask1 & BCHG) {\n\t\t\tr8a66597_write(r8a66597, ~BCHG, INTSTS1);\n\t\t\tr8a66597_bclr(r8a66597, BCHGE, INTENB1);\n\t\t\tusb_hcd_resume_root_hub(r8a66597_to_hcd(r8a66597));\n\t\t}\n\n\t\tif (mask1 & SIGN) {\n\t\t\tr8a66597_write(r8a66597, ~SIGN, INTSTS1);\n\t\t\tstatus = get_urb_error(r8a66597, 0);\n\t\t\tcheck_next_phase(r8a66597, status);\n\t\t}\n\t\tif (mask1 & SACK) {\n\t\t\tr8a66597_write(r8a66597, ~SACK, INTSTS1);\n\t\t\tcheck_next_phase(r8a66597, 0);\n\t\t}\n\t}\n\tif (mask0) {\n\t\tif (mask0 & BRDY)\n\t\t\tirq_pipe_ready(r8a66597);\n\t\tif (mask0 & BEMP)\n\t\t\tirq_pipe_empty(r8a66597);\n\t\tif (mask0 & NRDY)\n\t\t\tirq_pipe_nrdy(r8a66597);\n\t}\n\n\tspin_unlock(&r8a66597->lock);\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void r8a66597_root_hub_control(struct r8a66597 *r8a66597, int port)\n{\n\tu16 tmp;\n\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\n\tif (rh->port & USB_PORT_STAT_RESET) {\n\t\tunsigned long dvstctr_reg = get_dvstctr_reg(port);\n\n\t\ttmp = r8a66597_read(r8a66597, dvstctr_reg);\n\t\tif ((tmp & USBRST) == USBRST) {\n\t\t\tr8a66597_mdfy(r8a66597, UACT, USBRST | UACT,\n\t\t\t\t      dvstctr_reg);\n\t\t\tr8a66597_root_hub_start_polling(r8a66597);\n\t\t} else\n\t\t\tr8a66597_usb_connect(r8a66597, port);\n\t}\n\n\tif (!(rh->port & USB_PORT_STAT_CONNECTION)) {\n\t\tr8a66597_write(r8a66597, ~ATTCH, get_intsts_reg(port));\n\t\tr8a66597_bset(r8a66597, ATTCHE, get_intenb_reg(port));\n\t}\n\n\tif (rh->scount > 0) {\n\t\ttmp = r8a66597_read(r8a66597, get_syssts_reg(port)) & LNST;\n\t\tif (tmp == rh->old_syssts) {\n\t\t\trh->scount--;\n\t\t\tif (rh->scount == 0)\n\t\t\t\tr8a66597_check_syssts(r8a66597, port, tmp);\n\t\t\telse\n\t\t\t\tr8a66597_root_hub_start_polling(r8a66597);\n\t\t} else {\n\t\t\trh->scount = R8A66597_MAX_SAMPLING;\n\t\t\trh->old_syssts = tmp;\n\t\t\tr8a66597_root_hub_start_polling(r8a66597);\n\t\t}\n\t}\n}\n\nstatic void r8a66597_interval_timer(struct timer_list *t)\n{\n\tstruct r8a66597_timers *timers = from_timer(timers, t, interval);\n\tstruct r8a66597 *r8a66597 = timers->r8a66597;\n\tunsigned long flags;\n\tu16 pipenum;\n\tstruct r8a66597_td *td;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\n\tfor (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tif (!(r8a66597->interval_map & (1 << pipenum)))\n\t\t\tcontinue;\n\t\tif (timer_pending(&r8a66597->timers[pipenum].interval))\n\t\t\tcontinue;\n\n\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\tif (td)\n\t\t\tstart_transfer(r8a66597, td);\n\t}\n\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n}\n\nstatic void r8a66597_td_timer(struct timer_list *t)\n{\n\tstruct r8a66597_timers *timers = from_timer(timers, t, td);\n\tstruct r8a66597 *r8a66597 = timers->r8a66597;\n\tunsigned long flags;\n\tu16 pipenum;\n\tstruct r8a66597_td *td, *new_td = NULL;\n\tstruct r8a66597_pipe *pipe;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tfor (pipenum = 0; pipenum < R8A66597_MAX_NUM_PIPE; pipenum++) {\n\t\tif (!(r8a66597->timeout_map & (1 << pipenum)))\n\t\t\tcontinue;\n\t\tif (timer_pending(&r8a66597->timers[pipenum].td))\n\t\t\tcontinue;\n\n\t\ttd = r8a66597_get_td(r8a66597, pipenum);\n\t\tif (!td) {\n\t\t\tr8a66597->timeout_map &= ~(1 << pipenum);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (td->urb->actual_length) {\n\t\t\tset_td_timer(r8a66597, td);\n\t\t\tbreak;\n\t\t}\n\n\t\tpipe = td->pipe;\n\t\tpipe_stop(r8a66597, pipe);\n\n\t\t \n\t\tnew_td = td;\n\t\tdo {\n\t\t\tlist_move_tail(&new_td->queue,\n\t\t\t\t       &r8a66597->pipe_queue[pipenum]);\n\t\t\tnew_td = r8a66597_get_td(r8a66597, pipenum);\n\t\t\tif (!new_td) {\n\t\t\t\tnew_td = td;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (td != new_td && td->address == new_td->address &&\n\t\t\ttd->pipe->info.epnum == new_td->pipe->info.epnum);\n\n\t\tstart_transfer(r8a66597, new_td);\n\n\t\tif (td == new_td)\n\t\t\tr8a66597->timeout_map &= ~(1 << pipenum);\n\t\telse\n\t\t\tset_td_timer(r8a66597, new_td);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n}\n\nstatic void r8a66597_timer(struct timer_list *t)\n{\n\tstruct r8a66597 *r8a66597 = from_timer(r8a66597, t, rh_timer);\n\tunsigned long flags;\n\tint port;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++)\n\t\tr8a66597_root_hub_control(r8a66597, port);\n\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n}\n\nstatic int check_pipe_config(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tstruct r8a66597_device *dev = get_urb_to_r8a66597_dev(r8a66597, urb);\n\n\tif (dev && dev->address && dev->state != USB_STATE_CONFIGURED &&\n\t    (urb->dev->state == USB_STATE_CONFIGURED))\n\t\treturn 1;\n\telse\n\t\treturn 0;\n}\n\nstatic int r8a66597_start(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\n\thcd->state = HC_STATE_RUNNING;\n\treturn enable_controller(r8a66597);\n}\n\nstatic void r8a66597_stop(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\n\tdisable_controller(r8a66597);\n}\n\nstatic void set_address_zero(struct r8a66597 *r8a66597, struct urb *urb)\n{\n\tunsigned int usb_address = usb_pipedevice(urb->pipe);\n\tu16 root_port, hub_port;\n\n\tif (usb_address == 0) {\n\t\tget_port_number(r8a66597, urb->dev->devpath,\n\t\t\t\t&root_port, &hub_port);\n\t\tset_devadd_reg(r8a66597, 0,\n\t\t\t       get_r8a66597_usb_speed(urb->dev->speed),\n\t\t\t       get_parent_r8a66597_address(r8a66597, urb->dev),\n\t\t\t       hub_port, root_port);\n\t}\n}\n\nstatic struct r8a66597_td *r8a66597_make_td(struct r8a66597 *r8a66597,\n\t\t\t\t\t    struct urb *urb,\n\t\t\t\t\t    struct usb_host_endpoint *hep)\n{\n\tstruct r8a66597_td *td;\n\tu16 pipenum;\n\n\ttd = kzalloc(sizeof(struct r8a66597_td), GFP_ATOMIC);\n\tif (td == NULL)\n\t\treturn NULL;\n\n\tpipenum = r8a66597_get_pipenum(urb, hep);\n\ttd->pipenum = pipenum;\n\ttd->pipe = hep->hcpriv;\n\ttd->urb = urb;\n\ttd->address = get_urb_to_r8a66597_addr(r8a66597, urb);\n\ttd->maxpacket = usb_maxpacket(urb->dev, urb->pipe);\n\tif (usb_pipecontrol(urb->pipe))\n\t\ttd->type = USB_PID_SETUP;\n\telse if (usb_pipein(urb->pipe))\n\t\ttd->type = USB_PID_IN;\n\telse\n\t\ttd->type = USB_PID_OUT;\n\tINIT_LIST_HEAD(&td->queue);\n\n\treturn td;\n}\n\nstatic int r8a66597_urb_enqueue(struct usb_hcd *hcd,\n\t\t\t\tstruct urb *urb,\n\t\t\t\tgfp_t mem_flags)\n{\n\tstruct usb_host_endpoint *hep = urb->ep;\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tstruct r8a66597_td *td = NULL;\n\tint ret, request = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tif (!get_urb_to_r8a66597_dev(r8a66597, urb)) {\n\t\tret = -ENODEV;\n\t\tgoto error_not_linked;\n\t}\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret)\n\t\tgoto error_not_linked;\n\n\tif (!hep->hcpriv) {\n\t\thep->hcpriv = kzalloc(sizeof(struct r8a66597_pipe),\n\t\t\t\tGFP_ATOMIC);\n\t\tif (!hep->hcpriv) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tset_pipe_reg_addr(hep->hcpriv, R8A66597_PIPE_NO_DMA);\n\t\tif (usb_pipeendpoint(urb->pipe))\n\t\t\tinit_pipe_info(r8a66597, urb, hep, &hep->desc);\n\t}\n\n\tif (unlikely(check_pipe_config(r8a66597, urb)))\n\t\tinit_pipe_config(r8a66597, urb);\n\n\tset_address_zero(r8a66597, urb);\n\ttd = r8a66597_make_td(r8a66597, urb, hep);\n\tif (td == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\tif (list_empty(&r8a66597->pipe_queue[td->pipenum]))\n\t\trequest = 1;\n\tlist_add_tail(&td->queue, &r8a66597->pipe_queue[td->pipenum]);\n\turb->hcpriv = td;\n\n\tif (request) {\n\t\tif (td->pipe->info.timer_interval) {\n\t\t\tr8a66597->interval_map |= 1 << td->pipenum;\n\t\t\tmod_timer(&r8a66597->timers[td->pipenum].interval,\n\t\t\t\t  jiffies + msecs_to_jiffies(\n\t\t\t\t\ttd->pipe->info.timer_interval));\n\t\t} else {\n\t\t\tret = start_transfer(r8a66597, td);\n\t\t\tif (ret < 0) {\n\t\t\t\tlist_del(&td->queue);\n\t\t\t\tkfree(td);\n\t\t\t}\n\t\t}\n\t} else\n\t\tset_td_timer(r8a66597, td);\n\nerror:\n\tif (ret)\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\nerror_not_linked:\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\treturn ret;\n}\n\nstatic int r8a66597_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\n\t\tint status)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tstruct r8a66597_td *td;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tif (urb->hcpriv) {\n\t\ttd = urb->hcpriv;\n\t\tpipe_stop(r8a66597, td->pipe);\n\t\tpipe_irq_disable(r8a66597, td->pipenum);\n\t\tdisable_irq_empty(r8a66597, td->pipenum);\n\t\tfinish_request(r8a66597, td, td->pipenum, urb, status);\n\t}\n done:\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\treturn rc;\n}\n\nstatic void r8a66597_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t      struct usb_host_endpoint *hep)\n__acquires(r8a66597->lock)\n__releases(r8a66597->lock)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tstruct r8a66597_pipe *pipe = (struct r8a66597_pipe *)hep->hcpriv;\n\tstruct r8a66597_td *td;\n\tstruct urb *urb = NULL;\n\tu16 pipenum;\n\tunsigned long flags;\n\n\tif (pipe == NULL)\n\t\treturn;\n\tpipenum = pipe->info.pipenum;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tif (pipenum == 0) {\n\t\tkfree(hep->hcpriv);\n\t\thep->hcpriv = NULL;\n\t\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\t\treturn;\n\t}\n\n\tpipe_stop(r8a66597, pipe);\n\tpipe_irq_disable(r8a66597, pipenum);\n\tdisable_irq_empty(r8a66597, pipenum);\n\ttd = r8a66597_get_td(r8a66597, pipenum);\n\tif (td)\n\t\turb = td->urb;\n\tfinish_request(r8a66597, td, pipenum, urb, -ESHUTDOWN);\n\tkfree(hep->hcpriv);\n\thep->hcpriv = NULL;\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n}\n\nstatic int r8a66597_get_frame(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\treturn r8a66597_read(r8a66597, FRMNUM) & 0x03FF;\n}\n\nstatic void collect_usb_address_map(struct usb_device *udev, unsigned long *map)\n{\n\tint chix;\n\tstruct usb_device *childdev;\n\n\tif (udev->state == USB_STATE_CONFIGURED &&\n\t    udev->parent && udev->parent->devnum > 1 &&\n\t    udev->parent->descriptor.bDeviceClass == USB_CLASS_HUB)\n\t\tmap[udev->devnum/32] |= (1 << (udev->devnum % 32));\n\n\tusb_hub_for_each_child(udev, chix, childdev)\n\t\tcollect_usb_address_map(childdev, map);\n}\n\n \nstatic struct r8a66597_device *get_r8a66597_device(struct r8a66597 *r8a66597,\n\t\t\t\t\t\t   int addr)\n{\n\tstruct r8a66597_device *dev;\n\tstruct list_head *list = &r8a66597->child_device;\n\n\tlist_for_each_entry(dev, list, device_list) {\n\t\tif (dev->usb_address != addr)\n\t\t\tcontinue;\n\n\t\treturn dev;\n\t}\n\n\tprintk(KERN_ERR \"r8a66597: get_r8a66597_device fail.(%d)\\n\", addr);\n\treturn NULL;\n}\n\nstatic void update_usb_address_map(struct r8a66597 *r8a66597,\n\t\t\t\t   struct usb_device *root_hub,\n\t\t\t\t   unsigned long *map)\n{\n\tint i, j, addr;\n\tunsigned long diff;\n\tunsigned long flags;\n\n\tfor (i = 0; i < 4; i++) {\n\t\tdiff = r8a66597->child_connect_map[i] ^ map[i];\n\t\tif (!diff)\n\t\t\tcontinue;\n\n\t\tfor (j = 0; j < 32; j++) {\n\t\t\tif (!(diff & (1 << j)))\n\t\t\t\tcontinue;\n\n\t\t\taddr = i * 32 + j;\n\t\t\tif (map[i] & (1 << j))\n\t\t\t\tset_child_connect_map(r8a66597, addr);\n\t\t\telse {\n\t\t\t\tstruct r8a66597_device *dev;\n\n\t\t\t\tspin_lock_irqsave(&r8a66597->lock, flags);\n\t\t\t\tdev = get_r8a66597_device(r8a66597, addr);\n\t\t\t\tdisable_r8a66597_pipe_all(r8a66597, dev);\n\t\t\t\tfree_usb_address(r8a66597, dev, 0);\n\t\t\t\tput_child_connect_map(r8a66597, addr);\n\t\t\t\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void r8a66597_check_detect_child(struct r8a66597 *r8a66597,\n\t\t\t\t\tstruct usb_hcd *hcd)\n{\n\tstruct usb_bus *bus;\n\tunsigned long now_map[4];\n\n\tmemset(now_map, 0, sizeof(now_map));\n\n\tmutex_lock(&usb_bus_idr_lock);\n\tbus = idr_find(&usb_bus_idr, hcd->self.busnum);\n\tif (bus && bus->root_hub) {\n\t\tcollect_usb_address_map(bus->root_hub, now_map);\n\t\tupdate_usb_address_map(r8a66597, bus->root_hub, now_map);\n\t}\n\tmutex_unlock(&usb_bus_idr_lock);\n}\n\nstatic int r8a66597_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tunsigned long flags;\n\tint i;\n\n\tr8a66597_check_detect_child(r8a66597, hcd);\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\n\t*buf = 0;\t \n\n\tfor (i = 0; i < r8a66597->max_root_hub; i++) {\n\t\tif (r8a66597->root_hub[i].port & 0xffff0000)\n\t\t\t*buf |= 1 << (i + 1);\n\t}\n\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\n\treturn (*buf != 0);\n}\n\nstatic void r8a66597_hub_descriptor(struct r8a66597 *r8a66597,\n\t\t\t\t    struct usb_hub_descriptor *desc)\n{\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bHubContrCurrent = 0;\n\tdesc->bNbrPorts = r8a66597->max_root_hub;\n\tdesc->bDescLength = 9;\n\tdesc->bPwrOn2PwrGood = 0;\n\tdesc->wHubCharacteristics =\n\t\tcpu_to_le16(HUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_NO_OCPM);\n\tdesc->u.hs.DeviceRemovable[0] =\n\t\t((1 << r8a66597->max_root_hub) - 1) << 1;\n\tdesc->u.hs.DeviceRemovable[1] = ~0;\n}\n\nstatic int r8a66597_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t\tu16 wIndex, char *buf, u16 wLength)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tint ret;\n\tint port = (wIndex & 0x00FF) - 1;\n\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\tunsigned long flags;\n\n\tret = 0;\n\n\tspin_lock_irqsave(&r8a66597->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (wIndex > r8a66597->max_root_hub)\n\t\t\tgoto error;\n\t\tif (wLength != 0)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\trh->port &= ~USB_PORT_STAT_POWER;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tr8a66597_port_power(r8a66597, port, 0);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\trh->port &= ~(1 << wValue);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tr8a66597_hub_descriptor(r8a66597,\n\t\t\t\t\t(struct usb_hub_descriptor *)buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t*buf = 0x00;\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (wIndex > r8a66597->max_root_hub)\n\t\t\tgoto error;\n\t\t*(__le32 *)buf = cpu_to_le32(rh->port);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (wIndex > r8a66597->max_root_hub)\n\t\t\tgoto error;\n\t\tif (wLength != 0)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tr8a66597_port_power(r8a66597, port, 1);\n\t\t\trh->port |= USB_PORT_STAT_POWER;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET: {\n\t\t\tstruct r8a66597_device *dev = rh->dev;\n\n\t\t\trh->port |= USB_PORT_STAT_RESET;\n\n\t\t\tdisable_r8a66597_pipe_all(r8a66597, dev);\n\t\t\tfree_usb_address(r8a66597, dev, 1);\n\n\t\t\tr8a66597_mdfy(r8a66597, USBRST, USBRST | UACT,\n\t\t\t\t      get_dvstctr_reg(port));\n\t\t\tmod_timer(&r8a66597->rh_timer,\n\t\t\t\t  jiffies + msecs_to_jiffies(50));\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\trh->port |= 1 << wValue;\n\t\tbreak;\n\tdefault:\nerror:\n\t\tret = -EPIPE;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irqrestore(&r8a66597->lock, flags);\n\treturn ret;\n}\n\n#if defined(CONFIG_PM)\nstatic int r8a66597_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tint port;\n\n\tdev_dbg(&r8a66597->device0.udev->dev, \"%s\\n\", __func__);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++) {\n\t\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\t\tunsigned long dvstctr_reg = get_dvstctr_reg(port);\n\n\t\tif (!(rh->port & USB_PORT_STAT_ENABLE))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&rh->dev->udev->dev, \"suspend port = %d\\n\", port);\n\t\tr8a66597_bclr(r8a66597, UACT, dvstctr_reg);\t \n\t\trh->port |= USB_PORT_STAT_SUSPEND;\n\n\t\tif (rh->dev->udev->do_remote_wakeup) {\n\t\t\tmsleep(3);\t \n\t\t\tr8a66597_bset(r8a66597, RWUPE, dvstctr_reg);\n\t\t\tr8a66597_write(r8a66597, ~BCHG, get_intsts_reg(port));\n\t\t\tr8a66597_bset(r8a66597, BCHGE, get_intenb_reg(port));\n\t\t}\n\t}\n\n\tr8a66597->bus_suspended = 1;\n\n\treturn 0;\n}\n\nstatic int r8a66597_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct r8a66597 *r8a66597 = hcd_to_r8a66597(hcd);\n\tint port;\n\n\tdev_dbg(&r8a66597->device0.udev->dev, \"%s\\n\", __func__);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++) {\n\t\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\t\tunsigned long dvstctr_reg = get_dvstctr_reg(port);\n\n\t\tif (!(rh->port & USB_PORT_STAT_SUSPEND))\n\t\t\tcontinue;\n\n\t\tdev_dbg(&rh->dev->udev->dev, \"resume port = %d\\n\", port);\n\t\trh->port &= ~USB_PORT_STAT_SUSPEND;\n\t\trh->port |= USB_PORT_STAT_C_SUSPEND << 16;\n\t\tr8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\tr8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);\n\t}\n\n\treturn 0;\n\n}\n#else\n#define\tr8a66597_bus_suspend\tNULL\n#define\tr8a66597_bus_resume\tNULL\n#endif\n\nstatic const struct hc_driver r8a66597_hc_driver = {\n\t.description =\t\thcd_name,\n\t.hcd_priv_size =\tsizeof(struct r8a66597),\n\t.irq =\t\t\tr8a66597_irq,\n\n\t \n\t.flags =\t\tHCD_USB2,\n\n\t.start =\t\tr8a66597_start,\n\t.stop =\t\t\tr8a66597_stop,\n\n\t \n\t.urb_enqueue =\t\tr8a66597_urb_enqueue,\n\t.urb_dequeue =\t\tr8a66597_urb_dequeue,\n\t.endpoint_disable =\tr8a66597_endpoint_disable,\n\n\t \n\t.get_frame_number =\tr8a66597_get_frame,\n\n\t \n\t.hub_status_data =\tr8a66597_hub_status_data,\n\t.hub_control =\t\tr8a66597_hub_control,\n\t.bus_suspend =\t\tr8a66597_bus_suspend,\n\t.bus_resume =\t\tr8a66597_bus_resume,\n};\n\n#if defined(CONFIG_PM)\nstatic int r8a66597_suspend(struct device *dev)\n{\n\tstruct r8a66597\t\t*r8a66597 = dev_get_drvdata(dev);\n\tint port;\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tdisable_controller(r8a66597);\n\n\tfor (port = 0; port < r8a66597->max_root_hub; port++) {\n\t\tstruct r8a66597_root_hub *rh = &r8a66597->root_hub[port];\n\n\t\trh->port = 0x00000000;\n\t}\n\n\treturn 0;\n}\n\nstatic int r8a66597_resume(struct device *dev)\n{\n\tstruct r8a66597\t\t*r8a66597 = dev_get_drvdata(dev);\n\tstruct usb_hcd\t\t*hcd = r8a66597_to_hcd(r8a66597);\n\n\tdev_dbg(dev, \"%s\\n\", __func__);\n\n\tenable_controller(r8a66597);\n\tusb_root_hub_lost_power(hcd->self.root_hub);\n\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops r8a66597_dev_pm_ops = {\n\t.suspend = r8a66597_suspend,\n\t.resume = r8a66597_resume,\n\t.poweroff = r8a66597_suspend,\n\t.restore = r8a66597_resume,\n};\n\n#define R8A66597_DEV_PM_OPS\t(&r8a66597_dev_pm_ops)\n#else\t \n#define R8A66597_DEV_PM_OPS\tNULL\n#endif\n\nstatic void r8a66597_remove(struct platform_device *pdev)\n{\n\tstruct r8a66597\t\t*r8a66597 = platform_get_drvdata(pdev);\n\tstruct usb_hcd\t\t*hcd = r8a66597_to_hcd(r8a66597);\n\n\tdel_timer_sync(&r8a66597->rh_timer);\n\tusb_remove_hcd(hcd);\n\tiounmap(r8a66597->reg);\n\tif (r8a66597->pdata->on_chip)\n\t\tclk_put(r8a66597->clk);\n\tusb_put_hcd(hcd);\n}\n\nstatic int r8a66597_probe(struct platform_device *pdev)\n{\n\tchar clk_name[8];\n\tstruct resource *res = NULL, *ires;\n\tint irq = -1;\n\tvoid __iomem *reg = NULL;\n\tstruct usb_hcd *hcd = NULL;\n\tstruct r8a66597 *r8a66597;\n\tint ret = 0;\n\tint i;\n\tunsigned long irq_trigger;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev, \"platform_get_resource error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!ires) {\n\t\tret = -ENODEV;\n\t\tdev_err(&pdev->dev,\n\t\t\t\"platform_get_resource IORESOURCE_IRQ error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tirq = ires->start;\n\tirq_trigger = ires->flags & IRQF_TRIGGER_MASK;\n\n\treg = ioremap(res->start, resource_size(res));\n\tif (reg == NULL) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"ioremap error.\\n\");\n\t\tgoto clean_up;\n\t}\n\n\tif (pdev->dev.platform_data == NULL) {\n\t\tdev_err(&pdev->dev, \"no platform data\\n\");\n\t\tret = -ENODEV;\n\t\tgoto clean_up;\n\t}\n\n\t \n\thcd = usb_create_hcd(&r8a66597_hc_driver, &pdev->dev, (char *)hcd_name);\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tdev_err(&pdev->dev, \"Failed to create hcd\\n\");\n\t\tgoto clean_up;\n\t}\n\tr8a66597 = hcd_to_r8a66597(hcd);\n\tmemset(r8a66597, 0, sizeof(struct r8a66597));\n\tplatform_set_drvdata(pdev, r8a66597);\n\tr8a66597->pdata = dev_get_platdata(&pdev->dev);\n\tr8a66597->irq_sense_low = irq_trigger == IRQF_TRIGGER_LOW;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tsnprintf(clk_name, sizeof(clk_name), \"usb%d\", pdev->id);\n\t\tr8a66597->clk = clk_get(&pdev->dev, clk_name);\n\t\tif (IS_ERR(r8a66597->clk)) {\n\t\t\tdev_err(&pdev->dev, \"cannot get clock \\\"%s\\\"\\n\",\n\t\t\t\tclk_name);\n\t\t\tret = PTR_ERR(r8a66597->clk);\n\t\t\tgoto clean_up2;\n\t\t}\n\t\tr8a66597->max_root_hub = 1;\n\t} else\n\t\tr8a66597->max_root_hub = 2;\n\n\tspin_lock_init(&r8a66597->lock);\n\ttimer_setup(&r8a66597->rh_timer, r8a66597_timer, 0);\n\tr8a66597->reg = reg;\n\n\t \n\tret = r8a66597_clock_enable(r8a66597);\n\tif (ret < 0)\n\t\tgoto clean_up3;\n\tdisable_controller(r8a66597);\n\n\tfor (i = 0; i < R8A66597_MAX_NUM_PIPE; i++) {\n\t\tINIT_LIST_HEAD(&r8a66597->pipe_queue[i]);\n\t\tr8a66597->timers[i].r8a66597 = r8a66597;\n\t\ttimer_setup(&r8a66597->timers[i].td, r8a66597_td_timer, 0);\n\t\ttimer_setup(&r8a66597->timers[i].interval,\n\t\t\t    r8a66597_interval_timer, 0);\n\t}\n\tINIT_LIST_HEAD(&r8a66597->child_device);\n\n\thcd->rsrc_start = res->start;\n\thcd->has_tt = 1;\n\n\tret = usb_add_hcd(hcd, irq, irq_trigger);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to add hcd\\n\");\n\t\tgoto clean_up3;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\treturn 0;\n\nclean_up3:\n\tif (r8a66597->pdata->on_chip)\n\t\tclk_put(r8a66597->clk);\nclean_up2:\n\tusb_put_hcd(hcd);\n\nclean_up:\n\tif (reg)\n\t\tiounmap(reg);\n\n\treturn ret;\n}\n\nstatic struct platform_driver r8a66597_driver = {\n\t.probe =\tr8a66597_probe,\n\t.remove_new =\tr8a66597_remove,\n\t.driver\t\t= {\n\t\t.name = hcd_name,\n\t\t.pm\t= R8A66597_DEV_PM_OPS,\n\t},\n};\n\nmodule_platform_driver(r8a66597_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}