{
  "module_name": "bcma-hcd.c",
  "hash_id": "c1257dd525570b9f8d375c7ff21c8f598fe45e15c28477e1db04cf8fb7ab8918",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/bcma-hcd.c",
  "human_readable_source": "\n \n#include <linux/bcma/bcma.h>\n#include <linux/delay.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/of.h>\n#include <linux/of_gpio.h>\n#include <linux/of_platform.h>\n#include <linux/usb/ehci_pdriver.h>\n#include <linux/usb/ohci_pdriver.h>\n\nMODULE_AUTHOR(\"Hauke Mehrtens\");\nMODULE_DESCRIPTION(\"Common USB driver for BCMA Bus\");\nMODULE_LICENSE(\"GPL\");\n\n \n#define USB_BCMA_CLKCTLST_USB_CLK_REQ\t\t\t0x00000100\n\nstruct bcma_hcd_device {\n\tstruct bcma_device *core;\n\tstruct platform_device *ehci_dev;\n\tstruct platform_device *ohci_dev;\n\tstruct gpio_desc *gpio_desc;\n};\n\n \nstatic int bcma_wait_bits(struct bcma_device *dev, u16 reg, u32 bitmask,\n\t\t\t  int timeout)\n{\n\tint i;\n\tu32 val;\n\n\tfor (i = 0; i < timeout; i++) {\n\t\tval = bcma_read32(dev, reg);\n\t\tif ((val & bitmask) == bitmask)\n\t\t\treturn 0;\n\t\tudelay(10);\n\t}\n\n\treturn -ETIMEDOUT;\n}\n\nstatic void bcma_hcd_4716wa(struct bcma_device *dev)\n{\n#ifdef CONFIG_BCMA_DRIVER_MIPS\n\t \n\tif (dev->bus->chipinfo.id == 0x4716) {\n\t\tu32 tmp;\n\n\t\ttmp = bcma_cpu_clock(&dev->bus->drv_mips);\n\t\tif (tmp >= 480000000)\n\t\t\ttmp = 0x1846b;  \n\t\telse if (tmp == 453000000)\n\t\t\ttmp = 0x1046b;  \n\t\telse\n\t\t\ttmp = 0;\n\n\t\t \n\t\tif (tmp) {\n\t\t\tbcma_write32(dev, 0x524, 0x1);  \n\t\t\tudelay(500);\n\n\t\t\tbcma_write32(dev, 0x524, tmp);\n\t\t\tudelay(500);\n\t\t\tbcma_write32(dev, 0x524, 0x4ab);\n\t\t\tudelay(500);\n\t\t\tbcma_read32(dev, 0x528);\n\t\t\tbcma_write32(dev, 0x528, 0x80000000);\n\t\t}\n\t}\n#endif  \n}\n\n \nstatic void bcma_hcd_init_chip_mips(struct bcma_device *dev)\n{\n\tu32 tmp;\n\n\t \n\tif (!bcma_core_is_enabled(dev)) {\n\t\tbcma_core_enable(dev, 0);\n\t\tmdelay(10);\n\t\tif (dev->id.rev >= 5) {\n\t\t\t \n\t\t\ttmp = bcma_read32(dev, 0x1e0);\n\t\t\ttmp |= 0x100;\n\t\t\tbcma_write32(dev, 0x1e0, tmp);\n\t\t\tif (bcma_wait_bits(dev, 0x1e0, 1 << 24, 100))\n\t\t\t\tprintk(KERN_EMERG \"Failed to enable misc PPL!\\n\");\n\n\t\t\t \n\t\t\tbcma_write32(dev, 0x200, 0x4ff);\n\t\t\tudelay(25);\n\t\t\tbcma_write32(dev, 0x200, 0x6ff);\n\t\t\tudelay(25);\n\n\t\t\t \n\t\t\tbcma_write32(dev, 0x524, 0x6b);\n\t\t\tudelay(50);\n\t\t\ttmp = bcma_read32(dev, 0x524);\n\t\t\tudelay(50);\n\t\t\tbcma_write32(dev, 0x524, 0xab);\n\t\t\tudelay(50);\n\t\t\ttmp = bcma_read32(dev, 0x524);\n\t\t\tudelay(50);\n\t\t\tbcma_write32(dev, 0x524, 0x2b);\n\t\t\tudelay(50);\n\t\t\ttmp = bcma_read32(dev, 0x524);\n\t\t\tudelay(50);\n\t\t\tbcma_write32(dev, 0x524, 0x10ab);\n\t\t\tudelay(50);\n\t\t\ttmp = bcma_read32(dev, 0x524);\n\n\t\t\tif (bcma_wait_bits(dev, 0x528, 0xc000, 10000)) {\n\t\t\t\ttmp = bcma_read32(dev, 0x528);\n\t\t\t\tprintk(KERN_EMERG\n\t\t\t\t       \"USB20H mdio_rddata 0x%08x\\n\", tmp);\n\t\t\t}\n\t\t\tbcma_write32(dev, 0x528, 0x80000000);\n\t\t\ttmp = bcma_read32(dev, 0x314);\n\t\t\tudelay(265);\n\t\t\tbcma_write32(dev, 0x200, 0x7ff);\n\t\t\tudelay(10);\n\n\t\t\t \n\t\t\tbcma_write32(dev, 0x510, 0);\n\t\t} else {\n\t\t\tbcma_write32(dev, 0x200, 0x7ff);\n\n\t\t\tudelay(1);\n\t\t}\n\n\t\tbcma_hcd_4716wa(dev);\n\t}\n}\n\n \nstatic int bcma_hcd_usb20_old_arm_init(struct bcma_hcd_device *usb_dev)\n{\n\tstruct bcma_device *core = usb_dev->core;\n\tstruct device *dev = &core->dev;\n\tstruct bcma_device *pmu_core;\n\n\tusleep_range(10000, 20000);\n\tif (core->id.rev < 5)\n\t\treturn 0;\n\n\tpmu_core = bcma_find_core(core->bus, BCMA_CORE_PMU);\n\tif (!pmu_core) {\n\t\tdev_err(dev, \"Could not find PMU core\\n\");\n\t\treturn -ENOENT;\n\t}\n\n\t \n\tbcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK | BCMA_IOCTL_FGC);\n\tusleep_range(100, 200);\n\tbcma_awrite32(core, BCMA_RESET_CTL, BCMA_RESET_CTL_RESET);\n\tusleep_range(100, 200);\n\tbcma_awrite32(core, BCMA_RESET_CTL, 0);\n\tusleep_range(100, 200);\n\tbcma_awrite32(core, BCMA_IOCTL, BCMA_IOCTL_CLK);\n\tusleep_range(100, 200);\n\n\t \n\tbcma_write32(core, BCMA_CLKCTLST, BCMA_CLKCTLST_FORCEHT |\n\t\t\t\t\t  BCMA_CLKCTLST_HQCLKREQ |\n\t\t\t\t\t  USB_BCMA_CLKCTLST_USB_CLK_REQ);\n\tusleep_range(100, 200);\n\n\tbcma_write32(core, 0x510, 0xc7f85000);\n\tbcma_write32(core, 0x510, 0xc7f85003);\n\tusleep_range(300, 600);\n\n\t \n\tbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x6);\n\tbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x005360c1);\n\tusleep_range(100, 200);\n\tbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_ADDR, 0x7);\n\tbcma_write32(pmu_core, BCMA_CC_PMU_PLLCTL_DATA, 0x0);\n\tusleep_range(100, 200);\n\tbcma_set32(pmu_core, BCMA_CC_PMU_CTL, BCMA_CC_PMU_CTL_PLL_UPD);\n\tusleep_range(100, 200);\n\n\tbcma_write32(core, 0x510, 0x7f8d007);\n\tudelay(1000);\n\n\t \n\tbcma_write32(core, 0x200, 0x4ff);\n\tusleep_range(25, 50);\n\tbcma_write32(core, 0x200, 0x6ff);\n\tusleep_range(25, 50);\n\tbcma_write32(core, 0x200, 0x7ff);\n\tusleep_range(25, 50);\n\n\tof_platform_default_populate(dev->of_node, NULL, dev);\n\n\treturn 0;\n}\n\nstatic void bcma_hcd_usb20_ns_init_hc(struct bcma_device *dev)\n{\n\tu32 val;\n\n\t \n\tval = bcma_read32(dev, 0x94);\n\tval &= 0xffff;\n\tval |= 0x80 << 16;\n\tbcma_write32(dev, 0x94, val);\n\n\t \n\tval = bcma_read32(dev, 0x9c);\n\tval |= 1;\n\tbcma_write32(dev, 0x9c, val);\n\n\t \n\tusleep_range(1000, 2000);\n}\n\n \nstatic int bcma_hcd_usb20_ns_init(struct bcma_hcd_device *bcma_hcd)\n{\n\tstruct bcma_device *core = bcma_hcd->core;\n\tstruct bcma_chipinfo *ci = &core->bus->chipinfo;\n\tstruct device *dev = &core->dev;\n\n\tbcma_core_enable(core, 0);\n\n\tif (ci->id == BCMA_CHIP_ID_BCM4707 ||\n\t    ci->id == BCMA_CHIP_ID_BCM53018)\n\t\tbcma_hcd_usb20_ns_init_hc(core);\n\n\tof_platform_default_populate(dev->of_node, NULL, dev);\n\n\treturn 0;\n}\n\nstatic void bcma_hci_platform_power_gpio(struct bcma_device *dev, bool val)\n{\n\tstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\n\n\tif (!usb_dev->gpio_desc)\n\t\treturn;\n\n\tgpiod_set_value(usb_dev->gpio_desc, val);\n}\n\nstatic const struct usb_ehci_pdata ehci_pdata = {\n};\n\nstatic const struct usb_ohci_pdata ohci_pdata = {\n};\n\nstatic struct platform_device *bcma_hcd_create_pdev(struct bcma_device *dev,\n\t\t\t\t\t\t    const char *name, u32 addr,\n\t\t\t\t\t\t    const void *data,\n\t\t\t\t\t\t    size_t size)\n{\n\tstruct platform_device *hci_dev;\n\tstruct resource hci_res[2];\n\tint ret;\n\n\tmemset(hci_res, 0, sizeof(hci_res));\n\n\thci_res[0].start = addr;\n\thci_res[0].end = hci_res[0].start + 0x1000 - 1;\n\thci_res[0].flags = IORESOURCE_MEM;\n\n\thci_res[1].start = dev->irq;\n\thci_res[1].flags = IORESOURCE_IRQ;\n\n\thci_dev = platform_device_alloc(name, 0);\n\tif (!hci_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thci_dev->dev.parent = &dev->dev;\n\thci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;\n\n\tret = platform_device_add_resources(hci_dev, hci_res,\n\t\t\t\t\t    ARRAY_SIZE(hci_res));\n\tif (ret)\n\t\tgoto err_alloc;\n\tif (data)\n\t\tret = platform_device_add_data(hci_dev, data, size);\n\tif (ret)\n\t\tgoto err_alloc;\n\tret = platform_device_add(hci_dev);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\treturn hci_dev;\n\nerr_alloc:\n\tplatform_device_put(hci_dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic int bcma_hcd_usb20_init(struct bcma_hcd_device *usb_dev)\n{\n\tstruct bcma_device *dev = usb_dev->core;\n\tstruct bcma_chipinfo *chipinfo = &dev->bus->chipinfo;\n\tu32 ohci_addr;\n\tint err;\n\n\tif (dma_set_mask_and_coherent(dev->dma_dev, DMA_BIT_MASK(32)))\n\t\treturn -EOPNOTSUPP;\n\n\tbcma_hcd_init_chip_mips(dev);\n\n\t \n\tohci_addr = dev->addr_s[0];\n\tif ((chipinfo->id == BCMA_CHIP_ID_BCM5357 ||\n\t     chipinfo->id == BCMA_CHIP_ID_BCM4749)\n\t    && chipinfo->rev == 0)\n\t\tohci_addr = 0x18009000;\n\n\tusb_dev->ohci_dev = bcma_hcd_create_pdev(dev, \"ohci-platform\",\n\t\t\t\t\t\t ohci_addr, &ohci_pdata,\n\t\t\t\t\t\t sizeof(ohci_pdata));\n\tif (IS_ERR(usb_dev->ohci_dev))\n\t\treturn PTR_ERR(usb_dev->ohci_dev);\n\n\tusb_dev->ehci_dev = bcma_hcd_create_pdev(dev, \"ehci-platform\",\n\t\t\t\t\t\t dev->addr, &ehci_pdata,\n\t\t\t\t\t\t sizeof(ehci_pdata));\n\tif (IS_ERR(usb_dev->ehci_dev)) {\n\t\terr = PTR_ERR(usb_dev->ehci_dev);\n\t\tgoto err_unregister_ohci_dev;\n\t}\n\n\treturn 0;\n\nerr_unregister_ohci_dev:\n\tplatform_device_unregister(usb_dev->ohci_dev);\n\treturn err;\n}\n\nstatic int bcma_hcd_usb30_init(struct bcma_hcd_device *bcma_hcd)\n{\n\tstruct bcma_device *core = bcma_hcd->core;\n\tstruct device *dev = &core->dev;\n\n\tbcma_core_enable(core, 0);\n\n\tof_platform_default_populate(dev->of_node, NULL, dev);\n\n\treturn 0;\n}\n\nstatic int bcma_hcd_probe(struct bcma_device *core)\n{\n\tint err;\n\tstruct bcma_hcd_device *usb_dev;\n\n\t \n\n\tusb_dev = devm_kzalloc(&core->dev, sizeof(struct bcma_hcd_device),\n\t\t\t       GFP_KERNEL);\n\tif (!usb_dev)\n\t\treturn -ENOMEM;\n\tusb_dev->core = core;\n\n\tusb_dev->gpio_desc = devm_gpiod_get_optional(&core->dev, \"vcc\",\n\t\t\t\t\t\t     GPIOD_OUT_HIGH);\n\tif (IS_ERR(usb_dev->gpio_desc))\n\t\treturn dev_err_probe(&core->dev, PTR_ERR(usb_dev->gpio_desc),\n\t\t\t\t     \"error obtaining VCC GPIO\");\n\n\tswitch (core->id.id) {\n\tcase BCMA_CORE_USB20_HOST:\n\t\tif (IS_ENABLED(CONFIG_ARM))\n\t\t\terr = bcma_hcd_usb20_old_arm_init(usb_dev);\n\t\telse if (IS_ENABLED(CONFIG_MIPS))\n\t\t\terr = bcma_hcd_usb20_init(usb_dev);\n\t\telse\n\t\t\terr = -ENOTSUPP;\n\t\tbreak;\n\tcase BCMA_CORE_NS_USB20:\n\t\terr = bcma_hcd_usb20_ns_init(usb_dev);\n\t\tbreak;\n\tcase BCMA_CORE_NS_USB30:\n\t\terr = bcma_hcd_usb30_init(usb_dev);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENODEV;\n\t}\n\tif (err)\n\t\treturn err;\n\n\tbcma_set_drvdata(core, usb_dev);\n\treturn 0;\n}\n\nstatic void bcma_hcd_remove(struct bcma_device *dev)\n{\n\tstruct bcma_hcd_device *usb_dev = bcma_get_drvdata(dev);\n\tstruct platform_device *ohci_dev = usb_dev->ohci_dev;\n\tstruct platform_device *ehci_dev = usb_dev->ehci_dev;\n\n\tif (ohci_dev)\n\t\tplatform_device_unregister(ohci_dev);\n\tif (ehci_dev)\n\t\tplatform_device_unregister(ehci_dev);\n\n\tbcma_core_disable(dev, 0);\n}\n\nstatic void bcma_hcd_shutdown(struct bcma_device *dev)\n{\n\tbcma_hci_platform_power_gpio(dev, false);\n\tbcma_core_disable(dev, 0);\n}\n\n#ifdef CONFIG_PM\n\nstatic int bcma_hcd_suspend(struct bcma_device *dev)\n{\n\tbcma_hci_platform_power_gpio(dev, false);\n\tbcma_core_disable(dev, 0);\n\n\treturn 0;\n}\n\nstatic int bcma_hcd_resume(struct bcma_device *dev)\n{\n\tbcma_hci_platform_power_gpio(dev, true);\n\tbcma_core_enable(dev, 0);\n\n\treturn 0;\n}\n\n#else  \n#define bcma_hcd_suspend\tNULL\n#define bcma_hcd_resume\tNULL\n#endif  \n\nstatic const struct bcma_device_id bcma_hcd_table[] = {\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_USB20_HOST, BCMA_ANY_REV, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_NS_USB20, BCMA_ANY_REV, BCMA_ANY_CLASS),\n\tBCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_NS_USB30, BCMA_ANY_REV, BCMA_ANY_CLASS),\n\t{},\n};\nMODULE_DEVICE_TABLE(bcma, bcma_hcd_table);\n\nstatic struct bcma_driver bcma_hcd_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= bcma_hcd_table,\n\t.probe\t\t= bcma_hcd_probe,\n\t.remove\t\t= bcma_hcd_remove,\n\t.shutdown\t= bcma_hcd_shutdown,\n\t.suspend\t= bcma_hcd_suspend,\n\t.resume\t\t= bcma_hcd_resume,\n};\nmodule_bcma_driver(bcma_hcd_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}