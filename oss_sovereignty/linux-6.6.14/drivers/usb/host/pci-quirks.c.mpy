{
  "module_name": "pci-quirks.c",
  "hash_id": "d18b2d54858027b98ff8031c4069ba96e9b6e3f7e90db79fd577538db6cc2942",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/pci-quirks.c",
  "human_readable_source": "\n \n\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/export.h>\n#include <linux/acpi.h>\n#include <linux/dmi.h>\n#include <linux/of.h>\n#include <linux/iopoll.h>\n\n#include \"pci-quirks.h\"\n#include \"xhci-ext-caps.h\"\n\n\n#define UHCI_USBLEGSUP\t\t0xc0\t\t \n#define UHCI_USBCMD\t\t0\t\t \n#define UHCI_USBINTR\t\t4\t\t \n#define UHCI_USBLEGSUP_RWC\t0x8f00\t\t \n#define UHCI_USBLEGSUP_RO\t0x5040\t\t \n#define UHCI_USBCMD_RUN\t\t0x0001\t\t \n#define UHCI_USBCMD_HCRESET\t0x0002\t\t \n#define UHCI_USBCMD_EGSM\t0x0008\t\t \n#define UHCI_USBCMD_CONFIGURE\t0x0040\t\t \n#define UHCI_USBINTR_RESUME\t0x0002\t\t \n\n#define OHCI_CONTROL\t\t0x04\n#define OHCI_CMDSTATUS\t\t0x08\n#define OHCI_INTRSTATUS\t\t0x0c\n#define OHCI_INTRENABLE\t\t0x10\n#define OHCI_INTRDISABLE\t0x14\n#define OHCI_FMINTERVAL\t\t0x34\n#define OHCI_HCFS\t\t(3 << 6)\t \n#define OHCI_HCR\t\t(1 << 0)\t \n#define OHCI_OCR\t\t(1 << 3)\t \n#define OHCI_CTRL_RWC\t\t(1 << 9)\t \n#define OHCI_CTRL_IR\t\t(1 << 8)\t \n#define OHCI_INTR_OC\t\t(1 << 30)\t \n\n#define EHCI_HCC_PARAMS\t\t0x08\t\t \n#define EHCI_USBCMD\t\t0\t\t \n#define EHCI_USBCMD_RUN\t\t(1 << 0)\t \n#define EHCI_USBSTS\t\t4\t\t \n#define EHCI_USBSTS_HALTED\t(1 << 12)\t \n#define EHCI_USBINTR\t\t8\t\t \n#define EHCI_CONFIGFLAG\t\t0x40\t\t \n#define EHCI_USBLEGSUP\t\t0\t\t \n#define EHCI_USBLEGSUP_BIOS\t(1 << 16)\t \n#define EHCI_USBLEGSUP_OS\t(1 << 24)\t \n#define EHCI_USBLEGCTLSTS\t4\t\t \n#define EHCI_USBLEGCTLSTS_SOOE\t(1 << 13)\t \n\n \n#define\tAB_REG_BAR_LOW\t\t0xe0\n#define\tAB_REG_BAR_HIGH\t\t0xe1\n#define\tAB_REG_BAR_SB700\t0xf0\n#define\tAB_INDX(addr)\t\t((addr) + 0x00)\n#define\tAB_DATA(addr)\t\t((addr) + 0x04)\n#define\tAX_INDXC\t\t0x30\n#define\tAX_DATAC\t\t0x34\n\n#define PT_ADDR_INDX\t\t0xE8\n#define PT_READ_INDX\t\t0xE4\n#define PT_SIG_1_ADDR\t\t0xA520\n#define PT_SIG_2_ADDR\t\t0xA521\n#define PT_SIG_3_ADDR\t\t0xA522\n#define PT_SIG_4_ADDR\t\t0xA523\n#define PT_SIG_1_DATA\t\t0x78\n#define PT_SIG_2_DATA\t\t0x56\n#define PT_SIG_3_DATA\t\t0x34\n#define PT_SIG_4_DATA\t\t0x12\n#define PT4_P1_REG\t\t0xB521\n#define PT4_P2_REG\t\t0xB522\n#define PT2_P1_REG\t\t0xD520\n#define PT2_P2_REG\t\t0xD521\n#define PT1_P1_REG\t\t0xD522\n#define PT1_P2_REG\t\t0xD523\n\n#define\tNB_PCIE_INDX_ADDR\t0xe0\n#define\tNB_PCIE_INDX_DATA\t0xe4\n#define\tPCIE_P_CNTL\t\t0x10040\n#define\tBIF_NB\t\t\t0x10002\n#define\tNB_PIF0_PWRDOWN_0\t0x01100012\n#define\tNB_PIF0_PWRDOWN_1\t0x01100013\n\n#define USB_INTEL_XUSB2PR      0xD0\n#define USB_INTEL_USB2PRM      0xD4\n#define USB_INTEL_USB3_PSSEN   0xD8\n#define USB_INTEL_USB3PRM      0xDC\n\n \n#define ASMT_DATA_WRITE0_REG\t0xF8\n#define ASMT_DATA_WRITE1_REG\t0xFC\n#define ASMT_CONTROL_REG\t0xE0\n#define ASMT_CONTROL_WRITE_BIT\t0x02\n#define ASMT_WRITEREG_CMD\t0x10423\n#define ASMT_FLOWCTL_ADDR\t0xFA30\n#define ASMT_FLOWCTL_DATA\t0xBA\n#define ASMT_PSEUDO_DATA\t0\n\n \nenum amd_chipset_gen {\n\tNOT_AMD_CHIPSET = 0,\n\tAMD_CHIPSET_SB600,\n\tAMD_CHIPSET_SB700,\n\tAMD_CHIPSET_SB800,\n\tAMD_CHIPSET_HUDSON2,\n\tAMD_CHIPSET_BOLTON,\n\tAMD_CHIPSET_YANGTZE,\n\tAMD_CHIPSET_TAISHAN,\n\tAMD_CHIPSET_UNKNOWN,\n};\n\nstruct amd_chipset_type {\n\tenum amd_chipset_gen gen;\n\tu8 rev;\n};\n\nstatic struct amd_chipset_info {\n\tstruct pci_dev\t*nb_dev;\n\tstruct pci_dev\t*smbus_dev;\n\tint nb_type;\n\tstruct amd_chipset_type sb_type;\n\tint isoc_reqs;\n\tint probe_count;\n\tbool need_pll_quirk;\n} amd_chipset;\n\nstatic DEFINE_SPINLOCK(amd_lock);\n\n \nstatic int amd_chipset_sb_type_init(struct amd_chipset_info *pinfo)\n{\n\tu8 rev = 0;\n\tpinfo->sb_type.gen = AMD_CHIPSET_UNKNOWN;\n\n\tpinfo->smbus_dev = pci_get_device(PCI_VENDOR_ID_ATI,\n\t\t\tPCI_DEVICE_ID_ATI_SBX00_SMBUS, NULL);\n\tif (pinfo->smbus_dev) {\n\t\trev = pinfo->smbus_dev->revision;\n\t\tif (rev >= 0x10 && rev <= 0x1f)\n\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_SB600;\n\t\telse if (rev >= 0x30 && rev <= 0x3f)\n\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_SB700;\n\t\telse if (rev >= 0x40 && rev <= 0x4f)\n\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_SB800;\n\t} else {\n\t\tpinfo->smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\tPCI_DEVICE_ID_AMD_HUDSON2_SMBUS, NULL);\n\n\t\tif (pinfo->smbus_dev) {\n\t\t\trev = pinfo->smbus_dev->revision;\n\t\t\tif (rev >= 0x11 && rev <= 0x14)\n\t\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_HUDSON2;\n\t\t\telse if (rev >= 0x15 && rev <= 0x18)\n\t\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_BOLTON;\n\t\t\telse if (rev >= 0x39 && rev <= 0x3a)\n\t\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_YANGTZE;\n\t\t} else {\n\t\t\tpinfo->smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\t\t\t  0x145c, NULL);\n\t\t\tif (pinfo->smbus_dev) {\n\t\t\t\trev = pinfo->smbus_dev->revision;\n\t\t\t\tpinfo->sb_type.gen = AMD_CHIPSET_TAISHAN;\n\t\t\t} else {\n\t\t\t\tpinfo->sb_type.gen = NOT_AMD_CHIPSET;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tpinfo->sb_type.rev = rev;\n\treturn 1;\n}\n\nvoid sb800_prefetch(struct device *dev, int on)\n{\n\tu16 misc;\n\tstruct pci_dev *pdev = to_pci_dev(dev);\n\n\tpci_read_config_word(pdev, 0x50, &misc);\n\tif (on == 0)\n\t\tpci_write_config_word(pdev, 0x50, misc & 0xfcff);\n\telse\n\t\tpci_write_config_word(pdev, 0x50, misc | 0x0300);\n}\nEXPORT_SYMBOL_GPL(sb800_prefetch);\n\nstatic void usb_amd_find_chipset_info(void)\n{\n\tunsigned long flags;\n\tstruct amd_chipset_info info = { };\n\n\tspin_lock_irqsave(&amd_lock, flags);\n\n\t \n\tif (amd_chipset.probe_count > 0) {\n\t\tamd_chipset.probe_count++;\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\treturn;\n\t}\n\tspin_unlock_irqrestore(&amd_lock, flags);\n\n\tif (!amd_chipset_sb_type_init(&info)) {\n\t\tgoto commit;\n\t}\n\n\tswitch (info.sb_type.gen) {\n\tcase AMD_CHIPSET_SB700:\n\t\tinfo.need_pll_quirk = info.sb_type.rev <= 0x3B;\n\t\tbreak;\n\tcase AMD_CHIPSET_SB800:\n\tcase AMD_CHIPSET_HUDSON2:\n\tcase AMD_CHIPSET_BOLTON:\n\t\tinfo.need_pll_quirk = true;\n\t\tbreak;\n\tdefault:\n\t\tinfo.need_pll_quirk = false;\n\t\tbreak;\n\t}\n\n\tif (!info.need_pll_quirk) {\n\t\tif (info.smbus_dev) {\n\t\t\tpci_dev_put(info.smbus_dev);\n\t\t\tinfo.smbus_dev = NULL;\n\t\t}\n\t\tgoto commit;\n\t}\n\n\tinfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x9601, NULL);\n\tif (info.nb_dev) {\n\t\tinfo.nb_type = 1;\n\t} else {\n\t\tinfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD, 0x1510, NULL);\n\t\tif (info.nb_dev) {\n\t\t\tinfo.nb_type = 2;\n\t\t} else {\n\t\t\tinfo.nb_dev = pci_get_device(PCI_VENDOR_ID_AMD,\n\t\t\t\t\t\t     0x9600, NULL);\n\t\t\tif (info.nb_dev)\n\t\t\t\tinfo.nb_type = 3;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"QUIRK: Enable AMD PLL fix\\n\");\n\ncommit:\n\n\tspin_lock_irqsave(&amd_lock, flags);\n\tif (amd_chipset.probe_count > 0) {\n\t\t \n\n\t\t \n\t\tamd_chipset.probe_count++;\n\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\n\t\tpci_dev_put(info.nb_dev);\n\t\tpci_dev_put(info.smbus_dev);\n\n\t} else {\n\t\t \n\t\tinfo.probe_count++;\n\t\tamd_chipset = info;\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t}\n}\n\nint usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev)\n{\n\t \n\tusb_amd_find_chipset_info();\n\tif (amd_chipset.sb_type.gen == AMD_CHIPSET_YANGTZE ||\n\t    amd_chipset.sb_type.gen == AMD_CHIPSET_TAISHAN) {\n\t\tdev_dbg(&pdev->dev, \"QUIRK: Enable AMD remote wakeup fix\\n\");\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hcd_amd_remote_wakeup_quirk);\n\nbool usb_amd_hang_symptom_quirk(void)\n{\n\tu8 rev;\n\n\tusb_amd_find_chipset_info();\n\trev = amd_chipset.sb_type.rev;\n\t \n\treturn amd_chipset.sb_type.gen == AMD_CHIPSET_SB600 ||\n\t\t\t(amd_chipset.sb_type.gen == AMD_CHIPSET_SB700 &&\n\t\t\t rev >= 0x3a && rev <= 0x3b);\n}\nEXPORT_SYMBOL_GPL(usb_amd_hang_symptom_quirk);\n\nbool usb_amd_prefetch_quirk(void)\n{\n\tusb_amd_find_chipset_info();\n\t \n\treturn amd_chipset.sb_type.gen == AMD_CHIPSET_SB800;\n}\nEXPORT_SYMBOL_GPL(usb_amd_prefetch_quirk);\n\nbool usb_amd_quirk_pll_check(void)\n{\n\tusb_amd_find_chipset_info();\n\treturn amd_chipset.need_pll_quirk;\n}\nEXPORT_SYMBOL_GPL(usb_amd_quirk_pll_check);\n\n \nstatic void usb_amd_quirk_pll(int disable)\n{\n\tu32 addr, addr_low, addr_high, val;\n\tu32 bit = disable ? 0 : 1;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&amd_lock, flags);\n\n\tif (disable) {\n\t\tamd_chipset.isoc_reqs++;\n\t\tif (amd_chipset.isoc_reqs > 1) {\n\t\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tamd_chipset.isoc_reqs--;\n\t\tif (amd_chipset.isoc_reqs > 0) {\n\t\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (amd_chipset.sb_type.gen == AMD_CHIPSET_SB800 ||\n\t\t\tamd_chipset.sb_type.gen == AMD_CHIPSET_HUDSON2 ||\n\t\t\tamd_chipset.sb_type.gen == AMD_CHIPSET_BOLTON) {\n\t\toutb_p(AB_REG_BAR_LOW, 0xcd6);\n\t\taddr_low = inb_p(0xcd7);\n\t\toutb_p(AB_REG_BAR_HIGH, 0xcd6);\n\t\taddr_high = inb_p(0xcd7);\n\t\taddr = addr_high << 8 | addr_low;\n\n\t\toutl_p(0x30, AB_INDX(addr));\n\t\toutl_p(0x40, AB_DATA(addr));\n\t\toutl_p(0x34, AB_INDX(addr));\n\t\tval = inl_p(AB_DATA(addr));\n\t} else if (amd_chipset.sb_type.gen == AMD_CHIPSET_SB700 &&\n\t\t\tamd_chipset.sb_type.rev <= 0x3b) {\n\t\tpci_read_config_dword(amd_chipset.smbus_dev,\n\t\t\t\t\tAB_REG_BAR_SB700, &addr);\n\t\toutl(AX_INDXC, AB_INDX(addr));\n\t\toutl(0x40, AB_DATA(addr));\n\t\toutl(AX_DATAC, AB_INDX(addr));\n\t\tval = inl(AB_DATA(addr));\n\t} else {\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\treturn;\n\t}\n\n\tif (disable) {\n\t\tval &= ~0x08;\n\t\tval |= (1 << 4) | (1 << 9);\n\t} else {\n\t\tval |= 0x08;\n\t\tval &= ~((1 << 4) | (1 << 9));\n\t}\n\toutl_p(val, AB_DATA(addr));\n\n\tif (!amd_chipset.nb_dev) {\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\treturn;\n\t}\n\n\tif (amd_chipset.nb_type == 1 || amd_chipset.nb_type == 3) {\n\t\taddr = PCIE_P_CNTL;\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_ADDR, addr);\n\t\tpci_read_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, &val);\n\n\t\tval &= ~(1 | (1 << 3) | (1 << 4) | (1 << 9) | (1 << 12));\n\t\tval |= bit | (bit << 3) | (bit << 12);\n\t\tval |= ((!bit) << 4) | ((!bit) << 9);\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, val);\n\n\t\taddr = BIF_NB;\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_ADDR, addr);\n\t\tpci_read_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, &val);\n\t\tval &= ~(1 << 8);\n\t\tval |= bit << 8;\n\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, val);\n\t} else if (amd_chipset.nb_type == 2) {\n\t\taddr = NB_PIF0_PWRDOWN_0;\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_ADDR, addr);\n\t\tpci_read_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, &val);\n\t\tif (disable)\n\t\t\tval &= ~(0x3f << 7);\n\t\telse\n\t\t\tval |= 0x3f << 7;\n\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, val);\n\n\t\taddr = NB_PIF0_PWRDOWN_1;\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_ADDR, addr);\n\t\tpci_read_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, &val);\n\t\tif (disable)\n\t\t\tval &= ~(0x3f << 7);\n\t\telse\n\t\t\tval |= 0x3f << 7;\n\n\t\tpci_write_config_dword(amd_chipset.nb_dev,\n\t\t\t\t\tNB_PCIE_INDX_DATA, val);\n\t}\n\n\tspin_unlock_irqrestore(&amd_lock, flags);\n\treturn;\n}\n\nvoid usb_amd_quirk_pll_disable(void)\n{\n\tusb_amd_quirk_pll(1);\n}\nEXPORT_SYMBOL_GPL(usb_amd_quirk_pll_disable);\n\nstatic int usb_asmedia_wait_write(struct pci_dev *pdev)\n{\n\tunsigned long retry_count;\n\tunsigned char value;\n\n\tfor (retry_count = 1000; retry_count > 0; --retry_count) {\n\n\t\tpci_read_config_byte(pdev, ASMT_CONTROL_REG, &value);\n\n\t\tif (value == 0xff) {\n\t\t\tdev_err(&pdev->dev, \"%s: check_ready ERROR\", __func__);\n\t\t\treturn -EIO;\n\t\t}\n\n\t\tif ((value & ASMT_CONTROL_WRITE_BIT) == 0)\n\t\t\treturn 0;\n\n\t\tudelay(50);\n\t}\n\n\tdev_warn(&pdev->dev, \"%s: check_write_ready timeout\", __func__);\n\treturn -ETIMEDOUT;\n}\n\nvoid usb_asmedia_modifyflowcontrol(struct pci_dev *pdev)\n{\n\tif (usb_asmedia_wait_write(pdev) != 0)\n\t\treturn;\n\n\t \n\tpci_write_config_dword(pdev, ASMT_DATA_WRITE0_REG, ASMT_WRITEREG_CMD);\n\tpci_write_config_dword(pdev, ASMT_DATA_WRITE1_REG, ASMT_FLOWCTL_ADDR);\n\tpci_write_config_byte(pdev, ASMT_CONTROL_REG, ASMT_CONTROL_WRITE_BIT);\n\n\tif (usb_asmedia_wait_write(pdev) != 0)\n\t\treturn;\n\n\t \n\tpci_write_config_dword(pdev, ASMT_DATA_WRITE0_REG, ASMT_FLOWCTL_DATA);\n\tpci_write_config_dword(pdev, ASMT_DATA_WRITE1_REG, ASMT_PSEUDO_DATA);\n\tpci_write_config_byte(pdev, ASMT_CONTROL_REG, ASMT_CONTROL_WRITE_BIT);\n}\nEXPORT_SYMBOL_GPL(usb_asmedia_modifyflowcontrol);\n\nvoid usb_amd_quirk_pll_enable(void)\n{\n\tusb_amd_quirk_pll(0);\n}\nEXPORT_SYMBOL_GPL(usb_amd_quirk_pll_enable);\n\nvoid usb_amd_dev_put(void)\n{\n\tstruct pci_dev *nb, *smbus;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&amd_lock, flags);\n\n\tamd_chipset.probe_count--;\n\tif (amd_chipset.probe_count > 0) {\n\t\tspin_unlock_irqrestore(&amd_lock, flags);\n\t\treturn;\n\t}\n\n\t \n\tnb    = amd_chipset.nb_dev;\n\tsmbus = amd_chipset.smbus_dev;\n\n\tamd_chipset.nb_dev = NULL;\n\tamd_chipset.smbus_dev = NULL;\n\tamd_chipset.nb_type = 0;\n\tmemset(&amd_chipset.sb_type, 0, sizeof(amd_chipset.sb_type));\n\tamd_chipset.isoc_reqs = 0;\n\tamd_chipset.need_pll_quirk = false;\n\n\tspin_unlock_irqrestore(&amd_lock, flags);\n\n\tpci_dev_put(nb);\n\tpci_dev_put(smbus);\n}\nEXPORT_SYMBOL_GPL(usb_amd_dev_put);\n\n \nbool usb_amd_pt_check_port(struct device *device, int port)\n{\n\tunsigned char value, port_shift;\n\tstruct pci_dev *pdev;\n\tu16 reg;\n\n\tpdev = to_pci_dev(device);\n\tpci_write_config_word(pdev, PT_ADDR_INDX, PT_SIG_1_ADDR);\n\n\tpci_read_config_byte(pdev, PT_READ_INDX, &value);\n\tif (value != PT_SIG_1_DATA)\n\t\treturn false;\n\n\tpci_write_config_word(pdev, PT_ADDR_INDX, PT_SIG_2_ADDR);\n\n\tpci_read_config_byte(pdev, PT_READ_INDX, &value);\n\tif (value != PT_SIG_2_DATA)\n\t\treturn false;\n\n\tpci_write_config_word(pdev, PT_ADDR_INDX, PT_SIG_3_ADDR);\n\n\tpci_read_config_byte(pdev, PT_READ_INDX, &value);\n\tif (value != PT_SIG_3_DATA)\n\t\treturn false;\n\n\tpci_write_config_word(pdev, PT_ADDR_INDX, PT_SIG_4_ADDR);\n\n\tpci_read_config_byte(pdev, PT_READ_INDX, &value);\n\tif (value != PT_SIG_4_DATA)\n\t\treturn false;\n\n\t \n\tswitch (pdev->device) {\n\tcase 0x43b9:\n\tcase 0x43ba:\n\t \n\t\tif (port > 6) {\n\t\t\treg = PT4_P2_REG;\n\t\t\tport_shift = port - 7;\n\t\t} else {\n\t\t\treg = PT4_P1_REG;\n\t\t\tport_shift = port + 1;\n\t\t}\n\t\tbreak;\n\tcase 0x43bb:\n\t \n\t\tif (port > 2) {\n\t\t\treg = PT2_P2_REG;\n\t\t\tport_shift = port - 3;\n\t\t} else {\n\t\t\treg = PT2_P1_REG;\n\t\t\tport_shift = port + 5;\n\t\t}\n\t\tbreak;\n\tcase 0x43bc:\n\t \n\t\tif (port > 3) {\n\t\t\treg = PT1_P2_REG;\n\t\t\tport_shift = port - 4;\n\t\t} else {\n\t\t\treg = PT1_P1_REG;\n\t\t\tport_shift = port + 4;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\tpci_write_config_word(pdev, PT_ADDR_INDX, reg);\n\tpci_read_config_byte(pdev, PT_READ_INDX, &value);\n\n\treturn !(value & BIT(port_shift));\n}\nEXPORT_SYMBOL_GPL(usb_amd_pt_check_port);\n\n \nvoid uhci_reset_hc(struct pci_dev *pdev, unsigned long base)\n{\n\t \n\tpci_write_config_word(pdev, UHCI_USBLEGSUP, UHCI_USBLEGSUP_RWC);\n\n\t \n\toutw(UHCI_USBCMD_HCRESET, base + UHCI_USBCMD);\n\tmb();\n\tudelay(5);\n\tif (inw(base + UHCI_USBCMD) & UHCI_USBCMD_HCRESET)\n\t\tdev_warn(&pdev->dev, \"HCRESET not completed yet!\\n\");\n\n\t \n\toutw(0, base + UHCI_USBINTR);\n\toutw(0, base + UHCI_USBCMD);\n}\nEXPORT_SYMBOL_GPL(uhci_reset_hc);\n\n \nint uhci_check_and_reset_hc(struct pci_dev *pdev, unsigned long base)\n{\n\tu16 legsup;\n\tunsigned int cmd, intr;\n\n\t \n\tpci_read_config_word(pdev, UHCI_USBLEGSUP, &legsup);\n\tif (legsup & ~(UHCI_USBLEGSUP_RO | UHCI_USBLEGSUP_RWC)) {\n\t\tdev_dbg(&pdev->dev, \"%s: legsup = 0x%04x\\n\",\n\t\t\t\t__func__, legsup);\n\t\tgoto reset_needed;\n\t}\n\n\tcmd = inw(base + UHCI_USBCMD);\n\tif ((cmd & UHCI_USBCMD_RUN) || !(cmd & UHCI_USBCMD_CONFIGURE) ||\n\t\t\t!(cmd & UHCI_USBCMD_EGSM)) {\n\t\tdev_dbg(&pdev->dev, \"%s: cmd = 0x%04x\\n\",\n\t\t\t\t__func__, cmd);\n\t\tgoto reset_needed;\n\t}\n\n\tintr = inw(base + UHCI_USBINTR);\n\tif (intr & (~UHCI_USBINTR_RESUME)) {\n\t\tdev_dbg(&pdev->dev, \"%s: intr = 0x%04x\\n\",\n\t\t\t\t__func__, intr);\n\t\tgoto reset_needed;\n\t}\n\treturn 0;\n\nreset_needed:\n\tdev_dbg(&pdev->dev, \"Performing full reset\\n\");\n\tuhci_reset_hc(pdev, base);\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(uhci_check_and_reset_hc);\n\nstatic inline int io_type_enabled(struct pci_dev *pdev, unsigned int mask)\n{\n\tu16 cmd;\n\treturn !pci_read_config_word(pdev, PCI_COMMAND, &cmd) && (cmd & mask);\n}\n\n#define pio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_IO)\n#define mmio_enabled(dev) io_type_enabled(dev, PCI_COMMAND_MEMORY)\n\nstatic void quirk_usb_handoff_uhci(struct pci_dev *pdev)\n{\n\tunsigned long base = 0;\n\tint i;\n\n\tif (!pio_enabled(pdev))\n\t\treturn;\n\n\tfor (i = 0; i < PCI_STD_NUM_BARS; i++)\n\t\tif ((pci_resource_flags(pdev, i) & IORESOURCE_IO)) {\n\t\t\tbase = pci_resource_start(pdev, i);\n\t\t\tbreak;\n\t\t}\n\n\tif (base)\n\t\tuhci_check_and_reset_hc(pdev, base);\n}\n\nstatic int mmio_resource_enabled(struct pci_dev *pdev, int idx)\n{\n\treturn pci_resource_start(pdev, idx) && mmio_enabled(pdev);\n}\n\nstatic void quirk_usb_handoff_ohci(struct pci_dev *pdev)\n{\n\tvoid __iomem *base;\n\tu32 control;\n\tu32 fminterval = 0;\n\tbool no_fminterval = false;\n\tint cnt;\n\n\tif (!mmio_resource_enabled(pdev, 0))\n\t\treturn;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (base == NULL)\n\t\treturn;\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_AL && pdev->device == 0x5237)\n\t\tno_fminterval = true;\n\n\tcontrol = readl(base + OHCI_CONTROL);\n\n \n#ifdef __hppa__\n#define\tOHCI_CTRL_MASK\t\t(OHCI_CTRL_RWC | OHCI_CTRL_IR)\n#else\n#define\tOHCI_CTRL_MASK\t\tOHCI_CTRL_RWC\n\n\tif (control & OHCI_CTRL_IR) {\n\t\tint wait_time = 500;  \n\t\twritel(OHCI_INTR_OC, base + OHCI_INTRENABLE);\n\t\twritel(OHCI_OCR, base + OHCI_CMDSTATUS);\n\t\twhile (wait_time > 0 &&\n\t\t\t\treadl(base + OHCI_CONTROL) & OHCI_CTRL_IR) {\n\t\t\twait_time -= 10;\n\t\t\tmsleep(10);\n\t\t}\n\t\tif (wait_time <= 0)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"OHCI: BIOS handoff failed (BIOS bug?) %08x\\n\",\n\t\t\t\t readl(base + OHCI_CONTROL));\n\t}\n#endif\n\n\t \n\twritel((u32) ~0, base + OHCI_INTRDISABLE);\n\n\t \n\twritel(control & OHCI_CTRL_MASK, base + OHCI_CONTROL);\n\treadl(base + OHCI_CONTROL);\n\n\t \n\tif (!no_fminterval)\n\t\tfminterval = readl(base + OHCI_FMINTERVAL);\n\n\twritel(OHCI_HCR, base + OHCI_CMDSTATUS);\n\n\t \n\tfor (cnt = 30; cnt > 0; --cnt) {\t \n\t\tif ((readl(base + OHCI_CMDSTATUS) & OHCI_HCR) == 0)\n\t\t\tbreak;\n\t\tudelay(1);\n\t}\n\n\tif (!no_fminterval)\n\t\twritel(fminterval, base + OHCI_FMINTERVAL);\n\n\t \n\tiounmap(base);\n}\n\nstatic const struct dmi_system_id ehci_dmi_nohandoff_table[] = {\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"EXOPG06411\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Lucid-CE-133\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"M11JB\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Lucid-\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"Ordissimo\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"Lucid-\"),\n\t\t},\n\t},\n\t{\n\t\t \n\t\t.matches = {\n\t\t\tDMI_MATCH(DMI_BOARD_VENDOR, \"HASEE\"),\n\t\t\tDMI_MATCH(DMI_BOARD_NAME, \"E210\"),\n\t\t\tDMI_MATCH(DMI_BIOS_VERSION, \"6.00\"),\n\t\t},\n\t},\n\t{ }\n};\n\nstatic void ehci_bios_handoff(struct pci_dev *pdev,\n\t\t\t\t\tvoid __iomem *op_reg_base,\n\t\t\t\t\tu32 cap, u8 offset)\n{\n\tint try_handoff = 1, tried_handoff = 0;\n\n\t \n\tif (pdev->vendor == 0x8086 && (pdev->device == 0x283a ||\n\t\t\tpdev->device == 0x27cc)) {\n\t\tif (dmi_check_system(ehci_dmi_nohandoff_table))\n\t\t\ttry_handoff = 0;\n\t}\n\n\tif (try_handoff && (cap & EHCI_USBLEGSUP_BIOS)) {\n\t\tdev_dbg(&pdev->dev, \"EHCI: BIOS handoff\\n\");\n\n#if 0\n \n\t\t \n\t\tpci_read_config_dword(pdev, offset + EHCI_USBLEGCTLSTS, &val);\n\t\tpci_write_config_dword(pdev, offset + EHCI_USBLEGCTLSTS,\n\t\t\t\t       val | EHCI_USBLEGCTLSTS_SOOE);\n#endif\n\n\t\t \n\t\tpci_write_config_byte(pdev, offset + 3, 1);\n\t}\n\n\t \n\tif (try_handoff) {\n\t\tint msec = 1000;\n\t\twhile ((cap & EHCI_USBLEGSUP_BIOS) && (msec > 0)) {\n\t\t\ttried_handoff = 1;\n\t\t\tmsleep(10);\n\t\t\tmsec -= 10;\n\t\t\tpci_read_config_dword(pdev, offset, &cap);\n\t\t}\n\t}\n\n\tif (cap & EHCI_USBLEGSUP_BIOS) {\n\t\t \n\t\tif (try_handoff)\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"EHCI: BIOS handoff failed (BIOS bug?) %08x\\n\",\n\t\t\t\t cap);\n\t\tpci_write_config_byte(pdev, offset + 2, 0);\n\t}\n\n\t \n\tpci_write_config_dword(pdev, offset + EHCI_USBLEGCTLSTS, 0);\n\n\t \n\tif (tried_handoff)\n\t\twritel(0, op_reg_base + EHCI_CONFIGFLAG);\n}\n\nstatic void quirk_usb_disable_ehci(struct pci_dev *pdev)\n{\n\tvoid __iomem *base, *op_reg_base;\n\tu32\thcc_params, cap, val;\n\tu8\toffset, cap_length;\n\tint\twait_time, count = 256/4;\n\n\tif (!mmio_resource_enabled(pdev, 0))\n\t\treturn;\n\n\tbase = pci_ioremap_bar(pdev, 0);\n\tif (base == NULL)\n\t\treturn;\n\n\tcap_length = readb(base);\n\top_reg_base = base + cap_length;\n\n\t \n\thcc_params = readl(base + EHCI_HCC_PARAMS);\n\toffset = (hcc_params >> 8) & 0xff;\n\twhile (offset && --count) {\n\t\tpci_read_config_dword(pdev, offset, &cap);\n\n\t\tswitch (cap & 0xff) {\n\t\tcase 1:\n\t\t\tehci_bios_handoff(pdev, op_reg_base, cap, offset);\n\t\t\tbreak;\n\t\tcase 0:  \n\t\t\tcap = 0;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"EHCI: unrecognized capability %02x\\n\",\n\t\t\t\t cap & 0xff);\n\t\t}\n\t\toffset = (cap >> 8) & 0xff;\n\t}\n\tif (!count)\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"EHCI: capability loop?\\n\");\n\n\t \n\tval = readl(op_reg_base + EHCI_USBSTS);\n\tif ((val & EHCI_USBSTS_HALTED) == 0) {\n\t\tval = readl(op_reg_base + EHCI_USBCMD);\n\t\tval &= ~EHCI_USBCMD_RUN;\n\t\twritel(val, op_reg_base + EHCI_USBCMD);\n\n\t\twait_time = 2000;\n\t\tdo {\n\t\t\twritel(0x3f, op_reg_base + EHCI_USBSTS);\n\t\t\tudelay(100);\n\t\t\twait_time -= 100;\n\t\t\tval = readl(op_reg_base + EHCI_USBSTS);\n\t\t\tif ((val == ~(u32)0) || (val & EHCI_USBSTS_HALTED)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (wait_time > 0);\n\t}\n\twritel(0, op_reg_base + EHCI_USBINTR);\n\twritel(0x3f, op_reg_base + EHCI_USBSTS);\n\n\tiounmap(base);\n}\n\n \nstatic int handshake(void __iomem *ptr, u32 mask, u32 done,\n\t\tint wait_usec, int delay_usec)\n{\n\tu32\tresult;\n\n\treturn readl_poll_timeout_atomic(ptr, result,\n\t\t\t\t\t ((result & mask) == done),\n\t\t\t\t\t delay_usec, wait_usec);\n}\n\n \nvoid usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev)\n{\n\tu32\t\tports_available;\n\tbool\t\tehci_found = false;\n\tstruct pci_dev\t*companion = NULL;\n\n\t \n\tif (xhci_pdev->subsystem_vendor == PCI_VENDOR_ID_SONY &&\n\t    xhci_pdev->subsystem_device == 0x90a8)\n\t\treturn;\n\n\t \n\tfor_each_pci_dev(companion) {\n\t\tif (companion->class == PCI_CLASS_SERIAL_USB_EHCI &&\n\t\t    companion->vendor == PCI_VENDOR_ID_INTEL) {\n\t\t\tehci_found = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ehci_found)\n\t\treturn;\n\n\t \n\tif (!IS_ENABLED(CONFIG_USB_XHCI_HCD)) {\n\t\tdev_warn(&xhci_pdev->dev,\n\t\t\t \"CONFIG_USB_XHCI_HCD is turned off, defaulting to EHCI.\\n\");\n\t\tdev_warn(&xhci_pdev->dev,\n\t\t\t\t\"USB 3.0 devices will work at USB 2.0 speeds.\\n\");\n\t\tusb_disable_xhci_ports(xhci_pdev);\n\t\treturn;\n\t}\n\n\t \n\tpci_read_config_dword(xhci_pdev, USB_INTEL_USB3PRM,\n\t\t\t&ports_available);\n\n\tdev_dbg(&xhci_pdev->dev, \"Configurable ports to enable SuperSpeed: 0x%x\\n\",\n\t\t\tports_available);\n\n\t \n\tpci_write_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN,\n\t\t\tports_available);\n\n\tpci_read_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN,\n\t\t\t&ports_available);\n\tdev_dbg(&xhci_pdev->dev,\n\t\t\"USB 3.0 ports that are now enabled under xHCI: 0x%x\\n\",\n\t\tports_available);\n\n\t \n\n\tpci_read_config_dword(xhci_pdev, USB_INTEL_USB2PRM,\n\t\t\t&ports_available);\n\n\tdev_dbg(&xhci_pdev->dev, \"Configurable USB 2.0 ports to hand over to xCHI: 0x%x\\n\",\n\t\t\tports_available);\n\n\t \n\tpci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\tports_available);\n\n\tpci_read_config_dword(xhci_pdev, USB_INTEL_XUSB2PR,\n\t\t\t&ports_available);\n\tdev_dbg(&xhci_pdev->dev,\n\t\t\"USB 2.0 ports that are now switched over to xHCI: 0x%x\\n\",\n\t\tports_available);\n}\nEXPORT_SYMBOL_GPL(usb_enable_intel_xhci_ports);\n\nvoid usb_disable_xhci_ports(struct pci_dev *xhci_pdev)\n{\n\tpci_write_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN, 0x0);\n\tpci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR, 0x0);\n}\nEXPORT_SYMBOL_GPL(usb_disable_xhci_ports);\n\n \nstatic void quirk_usb_handoff_xhci(struct pci_dev *pdev)\n{\n\tvoid __iomem *base;\n\tint ext_cap_offset;\n\tvoid __iomem *op_reg_base;\n\tu32 val;\n\tint timeout;\n\tint len = pci_resource_len(pdev, 0);\n\n\tif (!mmio_resource_enabled(pdev, 0))\n\t\treturn;\n\n\tbase = ioremap(pci_resource_start(pdev, 0), len);\n\tif (base == NULL)\n\t\treturn;\n\n\t \n\text_cap_offset = xhci_find_next_ext_cap(base, 0, XHCI_EXT_CAPS_LEGACY);\n\n\tif (!ext_cap_offset)\n\t\tgoto hc_init;\n\n\tif ((ext_cap_offset + sizeof(val)) > len) {\n\t\t \n\t\tdev_warn(&pdev->dev, \"xHCI controller failing to respond\");\n\t\tgoto iounmap;\n\t}\n\tval = readl(base + ext_cap_offset);\n\n\t \n\tif ((pdev->vendor == PCI_VENDOR_ID_TI && pdev->device == 0x8241) ||\n\t\t\t(pdev->vendor == PCI_VENDOR_ID_RENESAS\n\t\t\t && pdev->device == 0x0014)) {\n\t\tval = (val | XHCI_HC_OS_OWNED) & ~XHCI_HC_BIOS_OWNED;\n\t\twritel(val, base + ext_cap_offset);\n\t}\n\n\t \n\tif (val & XHCI_HC_BIOS_OWNED) {\n\t\twritel(val | XHCI_HC_OS_OWNED, base + ext_cap_offset);\n\n\t\t \n\t\ttimeout = handshake(base + ext_cap_offset, XHCI_HC_BIOS_OWNED,\n\t\t\t\t0, 1000000, 10);\n\n\t\t \n\t\tif (timeout) {\n\t\t\tdev_warn(&pdev->dev,\n\t\t\t\t \"xHCI BIOS handoff failed (BIOS bug ?) %08x\\n\",\n\t\t\t\t val);\n\t\t\twritel(val & ~XHCI_HC_BIOS_OWNED, base + ext_cap_offset);\n\t\t}\n\t}\n\n\tval = readl(base + ext_cap_offset + XHCI_LEGACY_CONTROL_OFFSET);\n\t \n\tval &= XHCI_LEGACY_DISABLE_SMI;\n\t \n\tval |= XHCI_LEGACY_SMI_EVENTS;\n\t \n\twritel(val, base + ext_cap_offset + XHCI_LEGACY_CONTROL_OFFSET);\n\nhc_init:\n\tif (pdev->vendor == PCI_VENDOR_ID_INTEL)\n\t\tusb_enable_intel_xhci_ports(pdev);\n\n\top_reg_base = base + XHCI_HC_LENGTH(readl(base));\n\n\t \n\ttimeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,\n\t\t\t5000000, 10);\n\t \n\tif (timeout) {\n\t\tval = readl(op_reg_base + XHCI_STS_OFFSET);\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"xHCI HW not ready after 5 sec (HC bug?) status = 0x%x\\n\",\n\t\t\t val);\n\t}\n\n\t \n\tval = readl(op_reg_base + XHCI_CMD_OFFSET);\n\tval &= ~(XHCI_CMD_RUN | XHCI_IRQS);\n\twritel(val, op_reg_base + XHCI_CMD_OFFSET);\n\n\t \n\ttimeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_HALT, 1,\n\t\t\tXHCI_MAX_HALT_USEC, 125);\n\tif (timeout) {\n\t\tval = readl(op_reg_base + XHCI_STS_OFFSET);\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"xHCI HW did not halt within %d usec status = 0x%x\\n\",\n\t\t\t XHCI_MAX_HALT_USEC, val);\n\t}\n\niounmap:\n\tiounmap(base);\n}\n\nstatic void quirk_usb_early_handoff(struct pci_dev *pdev)\n{\n\tstruct device_node *parent;\n\tbool is_rpi;\n\n\t \n\tif (pdev->vendor == 0x184e)\t \n\t\treturn;\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_VIA && pdev->device == 0x3483) {\n\t\tparent = of_get_parent(pdev->bus->dev.of_node);\n\t\tis_rpi = of_device_is_compatible(parent, \"brcm,bcm2711-pcie\");\n\t\tof_node_put(parent);\n\t\tif (is_rpi)\n\t\t\treturn;\n\t}\n\n\tif (pdev->class != PCI_CLASS_SERIAL_USB_UHCI &&\n\t\t\tpdev->class != PCI_CLASS_SERIAL_USB_OHCI &&\n\t\t\tpdev->class != PCI_CLASS_SERIAL_USB_EHCI &&\n\t\t\tpdev->class != PCI_CLASS_SERIAL_USB_XHCI)\n\t\treturn;\n\n\tif (pci_enable_device(pdev) < 0) {\n\t\tdev_warn(&pdev->dev,\n\t\t\t \"Can't enable PCI device, BIOS handoff failed.\\n\");\n\t\treturn;\n\t}\n\tif (pdev->class == PCI_CLASS_SERIAL_USB_UHCI)\n\t\tquirk_usb_handoff_uhci(pdev);\n\telse if (pdev->class == PCI_CLASS_SERIAL_USB_OHCI)\n\t\tquirk_usb_handoff_ohci(pdev);\n\telse if (pdev->class == PCI_CLASS_SERIAL_USB_EHCI)\n\t\tquirk_usb_disable_ehci(pdev);\n\telse if (pdev->class == PCI_CLASS_SERIAL_USB_XHCI)\n\t\tquirk_usb_handoff_xhci(pdev);\n\tpci_disable_device(pdev);\n}\nDECLARE_PCI_FIXUP_CLASS_FINAL(PCI_ANY_ID, PCI_ANY_ID,\n\t\t\tPCI_CLASS_SERIAL_USB, 8, quirk_usb_early_handoff);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}