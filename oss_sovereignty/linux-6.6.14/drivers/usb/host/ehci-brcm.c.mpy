{
  "module_name": "ehci-brcm.c",
  "hash_id": "fd292f974c97b23c58392317cb23b98e11c312cbe13a66dbbb17ea68c6be7e98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-brcm.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/iopoll.h>\n\n#include \"ehci.h\"\n\n#define hcd_to_ehci_priv(h) ((struct brcm_priv *)hcd_to_ehci(h)->priv)\n\nstruct brcm_priv {\n\tstruct clk *clk;\n};\n\n \nstatic inline void ehci_brcm_wait_for_sof(struct ehci_hcd *ehci, u32 delay)\n{\n\tu32 frame_idx = ehci_readl(ehci, &ehci->regs->frame_index);\n\tu32 val;\n\tint res;\n\n\t \n\tres = readl_relaxed_poll_timeout(&ehci->regs->frame_index, val,\n\t\t\t\t\t val != frame_idx, 1, 130);\n\tif (res)\n\t\tehci_err(ehci, \"Error waiting for SOF\\n\");\n\tudelay(delay);\n}\n\n \nstatic int ehci_brcm_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength)\n{\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci(hcd);\n\tint\t\tports = HCS_N_PORTS(ehci->hcs_params);\n\tu32 __iomem\t*status_reg;\n\tunsigned long flags;\n\tint retval, irq_disabled = 0;\n\tu32 temp;\n\n\ttemp = (wIndex & 0xff) - 1;\n\tif (temp >= HCS_N_PORTS_MAX)\t \n\t\ttemp = 0;\n\tstatus_reg = &ehci->regs->port_status[temp];\n\n\t \n\tif ((typeReq == GetPortStatus) &&\n\t    (wIndex && wIndex <= ports) &&\n\t    ehci->reset_done[wIndex-1] &&\n\t    time_after_eq(jiffies, ehci->reset_done[wIndex-1]) &&\n\t    (ehci_readl(ehci, status_reg) & PORT_RESUME)) {\n\n\t\t \n\t\tehci_dbg(ehci, \"SOF alignment workaround\\n\");\n\t\tirq_disabled = 1;\n\t\tlocal_irq_save(flags);\n\t\tehci_brcm_wait_for_sof(ehci, 5);\n\t}\n\tretval = ehci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\n\tif (irq_disabled)\n\t\tlocal_irq_restore(flags);\n\treturn retval;\n}\n\nstatic int ehci_brcm_reset(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tint len;\n\n\tehci->big_endian_mmio = 1;\n\n\tehci->caps = (void __iomem *)hcd->regs;\n\tlen = HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\n\tehci->regs = (void __iomem *)(hcd->regs + len);\n\n\t \n\tehci_writel(ehci, CMD_RESET, &ehci->regs->command);\n\tmdelay(10);\n\n\t \n\tehci_writel(ehci, 0x00800040, &ehci->regs->brcm_insnreg[1]);\n\tehci_writel(ehci, 0x00000001, &ehci->regs->brcm_insnreg[3]);\n\n\treturn ehci_setup(hcd);\n}\n\nstatic struct hc_driver __read_mostly ehci_brcm_hc_driver;\n\nstatic const struct ehci_driver_overrides brcm_overrides __initconst = {\n\t.reset = ehci_brcm_reset,\n\t.extra_priv_size = sizeof(struct brcm_priv),\n};\n\nstatic int ehci_brcm_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res_mem;\n\tstruct brcm_priv *priv;\n\tstruct usb_hcd *hcd;\n\tint irq;\n\tint err;\n\n\terr = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\t \n\tehci_brcm_hc_driver.hub_control = ehci_brcm_hub_control;\n\n\t \n\thcd = usb_create_hcd(&ehci_brcm_hc_driver, dev, dev_name(dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(pdev, hcd);\n\tpriv = hcd_to_ehci_priv(hcd);\n\n\tpriv->clk = devm_clk_get_optional(dev, NULL);\n\tif (IS_ERR(priv->clk)) {\n\t\terr = PTR_ERR(priv->clk);\n\t\tgoto err_hcd;\n\t}\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\tgoto err_hcd;\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res_mem);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto err_clk;\n\t}\n\thcd->rsrc_start = res_mem->start;\n\thcd->rsrc_len = resource_size(res_mem);\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err)\n\t\tgoto err_clk;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\tdevice_enable_async_suspend(hcd->self.controller);\n\n\treturn 0;\n\nerr_clk:\n\tclk_disable_unprepare(priv->clk);\nerr_hcd:\n\tusb_put_hcd(hcd);\n\n\treturn err;\n}\n\nstatic void ehci_brcm_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct brcm_priv *priv = hcd_to_ehci_priv(hcd);\n\n\tusb_remove_hcd(hcd);\n\tclk_disable_unprepare(priv->clk);\n\tusb_put_hcd(hcd);\n}\n\nstatic int __maybe_unused ehci_brcm_suspend(struct device *dev)\n{\n\tint ret;\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct brcm_priv *priv = hcd_to_ehci_priv(hcd);\n\tbool do_wakeup = device_may_wakeup(dev);\n\n\tret = ehci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\tclk_disable_unprepare(priv->clk);\n\treturn 0;\n}\n\nstatic int __maybe_unused ehci_brcm_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tstruct brcm_priv *priv = hcd_to_ehci_priv(hcd);\n\tint err;\n\n\terr = clk_prepare_enable(priv->clk);\n\tif (err)\n\t\treturn err;\n\t \n\tehci_writel(ehci, 0x00800040, &ehci->regs->brcm_insnreg[1]);\n\tehci_writel(ehci, 0x00000001, &ehci->regs->brcm_insnreg[3]);\n\n\tehci_resume(hcd, false);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ehci_brcm_pm_ops, ehci_brcm_suspend,\n\t\tehci_brcm_resume);\n\nstatic const struct of_device_id brcm_ehci_of_match[] = {\n\t{ .compatible = \"brcm,ehci-brcm-v2\", },\n\t{ .compatible = \"brcm,bcm7445-ehci\", },\n\t{}\n};\n\nstatic struct platform_driver ehci_brcm_driver = {\n\t.probe\t\t= ehci_brcm_probe,\n\t.remove_new\t= ehci_brcm_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"ehci-brcm\",\n\t\t.pm\t= &ehci_brcm_pm_ops,\n\t\t.of_match_table = brcm_ehci_of_match,\n\t}\n};\n\nstatic int __init ehci_brcm_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_brcm_hc_driver, &brcm_overrides);\n\treturn platform_driver_register(&ehci_brcm_driver);\n}\nmodule_init(ehci_brcm_init);\n\nstatic void __exit ehci_brcm_exit(void)\n{\n\tplatform_driver_unregister(&ehci_brcm_driver);\n}\nmodule_exit(ehci_brcm_exit);\n\nMODULE_ALIAS(\"platform:ehci-brcm\");\nMODULE_DESCRIPTION(\"EHCI Broadcom STB driver\");\nMODULE_AUTHOR(\"Al Cooper\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}