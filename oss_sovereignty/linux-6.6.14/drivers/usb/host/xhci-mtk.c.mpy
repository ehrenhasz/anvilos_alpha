{
  "module_name": "xhci-mtk.c",
  "hash_id": "7c909b234c12b2b241e74e2d7db82eff22786fad8d289382d6006c40c8e29cd9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-mtk.c",
  "human_readable_source": "\n \n\n#include <linux/bitfield.h>\n#include <linux/dma-mapping.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/mfd/syscon.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/pm_wakeirq.h>\n#include <linux/regmap.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n\n#include \"xhci.h\"\n#include \"xhci-mtk.h\"\n\n \n#define CTRL0_IP_SW_RST\tBIT(0)\n\n \n#define CTRL1_IP_HOST_PDN\tBIT(0)\n\n \n#define CTRL2_IP_DEV_PDN\tBIT(0)\n\n \n#define STS1_IP_SLEEP_STS\tBIT(30)\n#define STS1_U3_MAC_RST\tBIT(16)\n#define STS1_XHCI_RST\t\tBIT(11)\n#define STS1_SYS125_RST\tBIT(10)\n#define STS1_REF_RST\t\tBIT(8)\n#define STS1_SYSPLL_STABLE\tBIT(0)\n\n \n#define CAP_U3_PORT_NUM(p)\t((p) & 0xff)\n#define CAP_U2_PORT_NUM(p)\t(((p) >> 8) & 0xff)\n\n \n#define CTRL_U3_PORT_HOST_SEL\tBIT(2)\n#define CTRL_U3_PORT_PDN\tBIT(1)\n#define CTRL_U3_PORT_DIS\tBIT(0)\n\n \n#define CTRL_U2_PORT_HOST_SEL\tBIT(2)\n#define CTRL_U2_PORT_PDN\tBIT(1)\n#define CTRL_U2_PORT_DIS\tBIT(0)\n\n \n#define CTRL_U2_FORCE_PLL_STB\tBIT(28)\n\n \n#define LS_EOF_CFG\t\t0x930\n#define LSEOF_OFFSET\t\t0x89\n\n#define FS_EOF_CFG\t\t0x934\n#define FSEOF_OFFSET\t\t0x2e\n\n#define SS_GEN1_EOF_CFG\t\t0x93c\n#define SSG1EOF_OFFSET\t\t0x78\n\n#define HFCNTR_CFG\t\t0x944\n#define ITP_DELTA_CLK\t\t(0xa << 1)\n#define ITP_DELTA_CLK_MASK\tGENMASK(5, 1)\n#define FRMCNT_LEV1_RANG\t(0x12b << 8)\n#define FRMCNT_LEV1_RANG_MASK\tGENMASK(19, 8)\n\n#define HSCH_CFG1\t\t0x960\n#define SCH3_RXFIFO_DEPTH_MASK\tGENMASK(21, 20)\n\n#define SS_GEN2_EOF_CFG\t\t0x990\n#define SSG2EOF_OFFSET\t\t0x3c\n\n#define XSEOF_OFFSET_MASK\tGENMASK(11, 0)\n\n \n\n \n#define PERI_WK_CTRL1\t0x4\n#define WC1_IS_C(x)\t(((x) & 0xf) << 26)   \n#define WC1_IS_EN\tBIT(25)\n#define WC1_IS_P\tBIT(6)   \n\n \n#define PERI_WK_CTRL0\t0x0\n#define WC0_IS_C(x)\t((u32)(((x) & 0xf) << 28))   \n#define WC0_IS_P\tBIT(12)\t \n#define WC0_IS_EN\tBIT(6)\n\n \n#define WC0_SSUSB0_CDEN\t\tBIT(6)\n#define WC0_IS_SPM_EN\t\tBIT(1)\n\n \n#define PERI_WK_CTRL0_8195\t0x04\n#define WC0_IS_P_95\t\tBIT(30)\t \n#define WC0_IS_C_95(x)\t\t((u32)(((x) & 0x7) << 27))\n#define WC0_IS_EN_P3_95\t\tBIT(26)\n#define WC0_IS_EN_P2_95\t\tBIT(25)\n#define WC0_IS_EN_P1_95\t\tBIT(24)\n\n#define PERI_WK_CTRL1_8195\t0x20\n#define WC1_IS_C_95(x)\t\t((u32)(((x) & 0xf) << 28))\n#define WC1_IS_P_95\t\tBIT(12)\n#define WC1_IS_EN_P0_95\t\tBIT(6)\n\n \n#define PERI_SSUSB_SPM_CTRL\t0x0\n#define SSC_IP_SLEEP_EN\tBIT(4)\n#define SSC_SPM_INT_EN\t\tBIT(1)\n\n#define SCH_FIFO_TO_KB(x)\t((x) >> 10)\n\nenum ssusb_uwk_vers {\n\tSSUSB_UWK_V1 = 1,\n\tSSUSB_UWK_V2,\n\tSSUSB_UWK_V1_1 = 101,\t \n\tSSUSB_UWK_V1_2,\t\t \n\tSSUSB_UWK_V1_3,\t\t \n\tSSUSB_UWK_V1_4,\t\t \n\tSSUSB_UWK_V1_5,\t\t \n\tSSUSB_UWK_V1_6,\t\t \n};\n\n \nstatic void xhci_mtk_set_frame_interval(struct xhci_hcd_mtk *mtk)\n{\n\tstruct device *dev = mtk->dev;\n\tstruct usb_hcd *hcd = mtk->hcd;\n\tu32 value;\n\n\tif (!of_device_is_compatible(dev->of_node, \"mediatek,mt8195-xhci\"))\n\t\treturn;\n\n\tvalue = readl(hcd->regs + HFCNTR_CFG);\n\tvalue &= ~(ITP_DELTA_CLK_MASK | FRMCNT_LEV1_RANG_MASK);\n\tvalue |= (ITP_DELTA_CLK | FRMCNT_LEV1_RANG);\n\twritel(value, hcd->regs + HFCNTR_CFG);\n\n\tvalue = readl(hcd->regs + LS_EOF_CFG);\n\tvalue &= ~XSEOF_OFFSET_MASK;\n\tvalue |= LSEOF_OFFSET;\n\twritel(value, hcd->regs + LS_EOF_CFG);\n\n\tvalue = readl(hcd->regs + FS_EOF_CFG);\n\tvalue &= ~XSEOF_OFFSET_MASK;\n\tvalue |= FSEOF_OFFSET;\n\twritel(value, hcd->regs + FS_EOF_CFG);\n\n\tvalue = readl(hcd->regs + SS_GEN1_EOF_CFG);\n\tvalue &= ~XSEOF_OFFSET_MASK;\n\tvalue |= SSG1EOF_OFFSET;\n\twritel(value, hcd->regs + SS_GEN1_EOF_CFG);\n\n\tvalue = readl(hcd->regs + SS_GEN2_EOF_CFG);\n\tvalue &= ~XSEOF_OFFSET_MASK;\n\tvalue |= SSG2EOF_OFFSET;\n\twritel(value, hcd->regs + SS_GEN2_EOF_CFG);\n}\n\n \nstatic void xhci_mtk_rxfifo_depth_set(struct xhci_hcd_mtk *mtk)\n{\n\tstruct usb_hcd *hcd = mtk->hcd;\n\tu32 value;\n\n\tif (!mtk->rxfifo_depth)\n\t\treturn;\n\n\tvalue = readl(hcd->regs + HSCH_CFG1);\n\tvalue &= ~SCH3_RXFIFO_DEPTH_MASK;\n\tvalue |= FIELD_PREP(SCH3_RXFIFO_DEPTH_MASK,\n\t\t\t    SCH_FIFO_TO_KB(mtk->rxfifo_depth) - 1);\n\twritel(value, hcd->regs + HSCH_CFG1);\n}\n\nstatic void xhci_mtk_init_quirk(struct xhci_hcd_mtk *mtk)\n{\n\t \n\txhci_mtk_set_frame_interval(mtk);\n\n\t \n\txhci_mtk_rxfifo_depth_set(mtk);\n}\n\nstatic int xhci_mtk_host_enable(struct xhci_hcd_mtk *mtk)\n{\n\tstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\n\tu32 value, check_val;\n\tint u3_ports_disabled = 0;\n\tint ret;\n\tint i;\n\n\tif (!mtk->has_ippc)\n\t\treturn 0;\n\n\t \n\tvalue = readl(&ippc->ip_pw_ctr1);\n\tvalue &= ~CTRL1_IP_HOST_PDN;\n\twritel(value, &ippc->ip_pw_ctr1);\n\n\t \n\tfor (i = 0; i < mtk->num_u3_ports; i++) {\n\t\tif ((0x1 << i) & mtk->u3p_dis_msk) {\n\t\t\tu3_ports_disabled++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvalue = readl(&ippc->u3_ctrl_p[i]);\n\t\tvalue &= ~(CTRL_U3_PORT_PDN | CTRL_U3_PORT_DIS);\n\t\tvalue |= CTRL_U3_PORT_HOST_SEL;\n\t\twritel(value, &ippc->u3_ctrl_p[i]);\n\t}\n\n\t \n\tfor (i = 0; i < mtk->num_u2_ports; i++) {\n\t\tif (BIT(i) & mtk->u2p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = readl(&ippc->u2_ctrl_p[i]);\n\t\tvalue &= ~(CTRL_U2_PORT_PDN | CTRL_U2_PORT_DIS);\n\t\tvalue |= CTRL_U2_PORT_HOST_SEL;\n\t\twritel(value, &ippc->u2_ctrl_p[i]);\n\t}\n\n\t \n\tcheck_val = STS1_SYSPLL_STABLE | STS1_REF_RST |\n\t\t\tSTS1_SYS125_RST | STS1_XHCI_RST;\n\n\tif (mtk->num_u3_ports > u3_ports_disabled)\n\t\tcheck_val |= STS1_U3_MAC_RST;\n\n\tret = readl_poll_timeout(&ippc->ip_pw_sts1, value,\n\t\t\t  (check_val == (value & check_val)), 100, 20000);\n\tif (ret) {\n\t\tdev_err(mtk->dev, \"clocks are not stable (0x%x)\\n\", value);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int xhci_mtk_host_disable(struct xhci_hcd_mtk *mtk)\n{\n\tstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\n\tu32 value;\n\tint ret;\n\tint i;\n\n\tif (!mtk->has_ippc)\n\t\treturn 0;\n\n\t \n\tfor (i = 0; i < mtk->num_u3_ports; i++) {\n\t\tif ((0x1 << i) & mtk->u3p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = readl(&ippc->u3_ctrl_p[i]);\n\t\tvalue |= CTRL_U3_PORT_PDN;\n\t\twritel(value, &ippc->u3_ctrl_p[i]);\n\t}\n\n\t \n\tfor (i = 0; i < mtk->num_u2_ports; i++) {\n\t\tif (BIT(i) & mtk->u2p_dis_msk)\n\t\t\tcontinue;\n\n\t\tvalue = readl(&ippc->u2_ctrl_p[i]);\n\t\tvalue |= CTRL_U2_PORT_PDN;\n\t\twritel(value, &ippc->u2_ctrl_p[i]);\n\t}\n\n\t \n\tvalue = readl(&ippc->ip_pw_ctr1);\n\tvalue |= CTRL1_IP_HOST_PDN;\n\twritel(value, &ippc->ip_pw_ctr1);\n\n\t \n\tret = readl_poll_timeout(&ippc->ip_pw_sts1, value,\n\t\t\t  (value & STS1_IP_SLEEP_STS), 100, 100000);\n\tif (ret)\n\t\tdev_err(mtk->dev, \"ip sleep failed!!!\\n\");\n\telse  \n\t\tusleep_range(100, 200);\n\n\treturn ret;\n}\n\nstatic int xhci_mtk_ssusb_config(struct xhci_hcd_mtk *mtk)\n{\n\tstruct mu3c_ippc_regs __iomem *ippc = mtk->ippc_regs;\n\tu32 value;\n\n\tif (!mtk->has_ippc)\n\t\treturn 0;\n\n\t \n\tvalue = readl(&ippc->ip_pw_ctr0);\n\tvalue |= CTRL0_IP_SW_RST;\n\twritel(value, &ippc->ip_pw_ctr0);\n\tudelay(1);\n\tvalue = readl(&ippc->ip_pw_ctr0);\n\tvalue &= ~CTRL0_IP_SW_RST;\n\twritel(value, &ippc->ip_pw_ctr0);\n\n\t \n\tvalue = readl(&ippc->ip_pw_ctr2);\n\tvalue |= CTRL2_IP_DEV_PDN;\n\twritel(value, &ippc->ip_pw_ctr2);\n\n\tvalue = readl(&ippc->ip_xhci_cap);\n\tmtk->num_u3_ports = CAP_U3_PORT_NUM(value);\n\tmtk->num_u2_ports = CAP_U2_PORT_NUM(value);\n\tdev_dbg(mtk->dev, \"%s u2p:%d, u3p:%d\\n\", __func__,\n\t\t\tmtk->num_u2_ports, mtk->num_u3_ports);\n\n\treturn xhci_mtk_host_enable(mtk);\n}\n\n \nstatic void usb_wakeup_ip_sleep_set(struct xhci_hcd_mtk *mtk, bool enable)\n{\n\tu32 reg, msk, val;\n\n\tswitch (mtk->uwk_vers) {\n\tcase SSUSB_UWK_V1:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL1;\n\t\tmsk = WC1_IS_EN | WC1_IS_C(0xf) | WC1_IS_P;\n\t\tval = enable ? (WC1_IS_EN | WC1_IS_C(0x8)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_1:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL0;\n\t\tmsk = WC0_IS_EN | WC0_IS_C(0xf) | WC0_IS_P;\n\t\tval = enable ? (WC0_IS_EN | WC0_IS_C(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_2:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL0;\n\t\tmsk = WC0_SSUSB0_CDEN | WC0_IS_SPM_EN;\n\t\tval = enable ? msk : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_3:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL1_8195;\n\t\tmsk = WC1_IS_EN_P0_95 | WC1_IS_C_95(0xf) | WC1_IS_P_95;\n\t\tval = enable ? (WC1_IS_EN_P0_95 | WC1_IS_C_95(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_4:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL0_8195;\n\t\tmsk = WC0_IS_EN_P1_95 | WC0_IS_C_95(0x7) | WC0_IS_P_95;\n\t\tval = enable ? (WC0_IS_EN_P1_95 | WC0_IS_C_95(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_5:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL0_8195;\n\t\tmsk = WC0_IS_EN_P2_95 | WC0_IS_C_95(0x7) | WC0_IS_P_95;\n\t\tval = enable ? (WC0_IS_EN_P2_95 | WC0_IS_C_95(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V1_6:\n\t\treg = mtk->uwk_reg_base + PERI_WK_CTRL0_8195;\n\t\tmsk = WC0_IS_EN_P3_95 | WC0_IS_C_95(0x7) | WC0_IS_P_95;\n\t\tval = enable ? (WC0_IS_EN_P3_95 | WC0_IS_C_95(0x1)) : 0;\n\t\tbreak;\n\tcase SSUSB_UWK_V2:\n\t\treg = mtk->uwk_reg_base + PERI_SSUSB_SPM_CTRL;\n\t\tmsk = SSC_IP_SLEEP_EN | SSC_SPM_INT_EN;\n\t\tval = enable ? msk : 0;\n\t\tbreak;\n\tdefault:\n\t\treturn;\n\t}\n\tregmap_update_bits(mtk->uwk, reg, msk, val);\n}\n\nstatic int usb_wakeup_of_property_parse(struct xhci_hcd_mtk *mtk,\n\t\t\t\tstruct device_node *dn)\n{\n\tstruct of_phandle_args args;\n\tint ret;\n\n\t \n\tmtk->uwk_en = of_property_read_bool(dn, \"wakeup-source\");\n\tif (!mtk->uwk_en)\n\t\treturn 0;\n\n\tret = of_parse_phandle_with_fixed_args(dn,\n\t\t\t\t\"mediatek,syscon-wakeup\", 2, 0, &args);\n\tif (ret)\n\t\treturn ret;\n\n\tmtk->uwk_reg_base = args.args[0];\n\tmtk->uwk_vers = args.args[1];\n\tmtk->uwk = syscon_node_to_regmap(args.np);\n\tof_node_put(args.np);\n\tdev_info(mtk->dev, \"uwk - reg:0x%x, version:%d\\n\",\n\t\t\tmtk->uwk_reg_base, mtk->uwk_vers);\n\n\treturn PTR_ERR_OR_ZERO(mtk->uwk);\n}\n\nstatic void usb_wakeup_set(struct xhci_hcd_mtk *mtk, bool enable)\n{\n\tif (mtk->uwk_en)\n\t\tusb_wakeup_ip_sleep_set(mtk, enable);\n}\n\nstatic int xhci_mtk_clks_get(struct xhci_hcd_mtk *mtk)\n{\n\tstruct clk_bulk_data *clks = mtk->clks;\n\n\tclks[0].id = \"sys_ck\";\n\tclks[1].id = \"xhci_ck\";\n\tclks[2].id = \"ref_ck\";\n\tclks[3].id = \"mcu_ck\";\n\tclks[4].id = \"dma_ck\";\n\tclks[5].id = \"frmcnt_ck\";\n\n\treturn devm_clk_bulk_get_optional(mtk->dev, BULK_CLKS_NUM, clks);\n}\n\nstatic int xhci_mtk_vregs_get(struct xhci_hcd_mtk *mtk)\n{\n\tstruct regulator_bulk_data *supplies = mtk->supplies;\n\n\tsupplies[0].supply = \"vbus\";\n\tsupplies[1].supply = \"vusb33\";\n\n\treturn devm_regulator_bulk_get(mtk->dev, BULK_VREGS_NUM, supplies);\n}\n\nstatic void xhci_mtk_quirks(struct device *dev, struct xhci_hcd *xhci)\n{\n\tstruct usb_hcd *hcd = xhci_to_hcd(xhci);\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\n\txhci->quirks |= XHCI_MTK_HOST;\n\t \n\txhci->quirks |= XHCI_SPURIOUS_SUCCESS;\n\tif (mtk->lpm_support)\n\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n\tif (mtk->u2_lpm_disable)\n\t\txhci->quirks |= XHCI_HW_LPM_DISABLE;\n\n\t \n\tif (xhci->hci_version < 0x100 && HCC_MAX_PSA(xhci->hcc_params) == 4)\n\t\txhci->quirks |= XHCI_BROKEN_STREAMS;\n}\n\n \nstatic int xhci_mtk_setup(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\tint ret;\n\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tret = xhci_mtk_ssusb_config(mtk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\txhci_mtk_init_quirk(mtk);\n\t}\n\n\tret = xhci_gen_setup(hcd, xhci_mtk_quirks);\n\tif (ret)\n\t\treturn ret;\n\n\tif (usb_hcd_is_primary_hcd(hcd))\n\t\tret = xhci_mtk_sch_init(mtk);\n\n\treturn ret;\n}\n\nstatic const struct xhci_driver_overrides xhci_mtk_overrides __initconst = {\n\t.reset = xhci_mtk_setup,\n\t.add_endpoint = xhci_mtk_add_ep,\n\t.drop_endpoint = xhci_mtk_drop_ep,\n\t.check_bandwidth = xhci_mtk_check_bandwidth,\n\t.reset_bandwidth = xhci_mtk_reset_bandwidth,\n};\n\nstatic struct hc_driver __read_mostly xhci_mtk_hc_driver;\n\nstatic int xhci_mtk_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct device_node *node = dev->of_node;\n\tstruct xhci_hcd_mtk *mtk;\n\tconst struct hc_driver *driver;\n\tstruct xhci_hcd *xhci;\n\tstruct resource *res;\n\tstruct usb_hcd *usb3_hcd;\n\tstruct usb_hcd *hcd;\n\tint ret = -ENODEV;\n\tint wakeup_irq;\n\tint irq;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdriver = &xhci_mtk_hc_driver;\n\tmtk = devm_kzalloc(dev, sizeof(*mtk), GFP_KERNEL);\n\tif (!mtk)\n\t\treturn -ENOMEM;\n\n\tmtk->dev = dev;\n\n\tret = xhci_mtk_vregs_get(mtk);\n\tif (ret)\n\t\treturn dev_err_probe(dev, ret, \"Failed to get regulators\\n\");\n\n\tret = xhci_mtk_clks_get(mtk);\n\tif (ret)\n\t\treturn ret;\n\n\tirq = platform_get_irq_byname_optional(pdev, \"host\");\n\tif (irq < 0) {\n\t\tif (irq == -EPROBE_DEFER)\n\t\t\treturn irq;\n\n\t\t \n\t\tirq = platform_get_irq(pdev, 0);\n\t\tif (irq < 0)\n\t\t\treturn irq;\n\t}\n\n\twakeup_irq = platform_get_irq_byname_optional(pdev, \"wakeup\");\n\tif (wakeup_irq == -EPROBE_DEFER)\n\t\treturn wakeup_irq;\n\n\tmtk->lpm_support = of_property_read_bool(node, \"usb3-lpm-capable\");\n\tmtk->u2_lpm_disable = of_property_read_bool(node, \"usb2-lpm-disable\");\n\t \n\tof_property_read_u32(node, \"mediatek,u3p-dis-msk\",\n\t\t\t     &mtk->u3p_dis_msk);\n\tof_property_read_u32(node, \"mediatek,u2p-dis-msk\",\n\t\t\t     &mtk->u2p_dis_msk);\n\n\tof_property_read_u32(node, \"rx-fifo-depth\", &mtk->rxfifo_depth);\n\n\tret = usb_wakeup_of_property_parse(mtk, node);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to parse uwk property\\n\");\n\t\treturn ret;\n\t}\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_use_autosuspend(dev);\n\tpm_runtime_set_autosuspend_delay(dev, 4000);\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\tret = regulator_bulk_enable(BULK_VREGS_NUM, mtk->supplies);\n\tif (ret)\n\t\tgoto disable_pm;\n\n\tret = clk_bulk_prepare_enable(BULK_CLKS_NUM, mtk->clks);\n\tif (ret)\n\t\tgoto disable_ldos;\n\n\tret = device_reset_optional(dev);\n\tif (ret) {\n\t\tdev_err_probe(dev, ret, \"failed to reset controller\\n\");\n\t\tgoto disable_clk;\n\t}\n\n\thcd = usb_create_hcd(driver, dev, dev_name(dev));\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_clk;\n\t}\n\n\t \n\tmtk->hcd = platform_get_drvdata(pdev);\n\tplatform_set_drvdata(pdev, mtk);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"mac\");\n\thcd->regs = devm_ioremap_resource(dev, res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tret = PTR_ERR(hcd->regs);\n\t\tgoto put_usb2_hcd;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tres = platform_get_resource_byname(pdev, IORESOURCE_MEM, \"ippc\");\n\tif (res) {\t \n\t\tmtk->ippc_regs = devm_ioremap_resource(dev, res);\n\t\tif (IS_ERR(mtk->ippc_regs)) {\n\t\t\tret = PTR_ERR(mtk->ippc_regs);\n\t\t\tgoto put_usb2_hcd;\n\t\t}\n\t\tmtk->has_ippc = true;\n\t}\n\n\tdevice_init_wakeup(dev, true);\n\tdma_set_max_seg_size(dev, UINT_MAX);\n\n\txhci = hcd_to_xhci(hcd);\n\txhci->main_hcd = hcd;\n\txhci->allow_single_roothub = 1;\n\n\t \n\txhci->imod_interval = 5000;\n\tdevice_property_read_u32(dev, \"imod-interval-ns\", &xhci->imod_interval);\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret)\n\t\tgoto disable_device_wakeup;\n\n\tif (!xhci_has_one_roothub(xhci)) {\n\t\txhci->shared_hcd = usb_create_shared_hcd(driver, dev,\n\t\t\t\t\t\t\t dev_name(dev), hcd);\n\t\tif (!xhci->shared_hcd) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dealloc_usb2_hcd;\n\t\t}\n\t}\n\n\tusb3_hcd = xhci_get_usb3_hcd(xhci);\n\tif (usb3_hcd && HCC_MAX_PSA(xhci->hcc_params) >= 4 &&\n\t    !(xhci->quirks & XHCI_BROKEN_STREAMS))\n\t\tusb3_hcd->can_do_streams = 1;\n\n\tif (xhci->shared_hcd) {\n\t\tret = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);\n\t\tif (ret)\n\t\t\tgoto put_usb3_hcd;\n\t}\n\n\tif (wakeup_irq > 0) {\n\t\tret = dev_pm_set_dedicated_wake_irq_reverse(dev, wakeup_irq);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"set wakeup irq %d failed\\n\", wakeup_irq);\n\t\t\tgoto dealloc_usb3_hcd;\n\t\t}\n\t\tdev_info(dev, \"wakeup irq %d\\n\", wakeup_irq);\n\t}\n\n\tdevice_enable_async_suspend(dev);\n\tpm_runtime_mark_last_busy(dev);\n\tpm_runtime_put_autosuspend(dev);\n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ndealloc_usb3_hcd:\n\tusb_remove_hcd(xhci->shared_hcd);\n\nput_usb3_hcd:\n\tusb_put_hcd(xhci->shared_hcd);\n\ndealloc_usb2_hcd:\n\txhci_mtk_sch_exit(mtk);\n\tusb_remove_hcd(hcd);\n\ndisable_device_wakeup:\n\tdevice_init_wakeup(dev, false);\n\nput_usb2_hcd:\n\tusb_put_hcd(hcd);\n\ndisable_clk:\n\tclk_bulk_disable_unprepare(BULK_CLKS_NUM, mtk->clks);\n\ndisable_ldos:\n\tregulator_bulk_disable(BULK_VREGS_NUM, mtk->supplies);\n\ndisable_pm:\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_disable(dev);\n\treturn ret;\n}\n\nstatic void xhci_mtk_remove(struct platform_device *pdev)\n{\n\tstruct xhci_hcd_mtk *mtk = platform_get_drvdata(pdev);\n\tstruct usb_hcd\t*hcd = mtk->hcd;\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct usb_hcd  *shared_hcd = xhci->shared_hcd;\n\tstruct device *dev = &pdev->dev;\n\n\tpm_runtime_get_sync(dev);\n\txhci->xhc_state |= XHCI_STATE_REMOVING;\n\tdev_pm_clear_wake_irq(dev);\n\tdevice_init_wakeup(dev, false);\n\n\tif (shared_hcd) {\n\t\tusb_remove_hcd(shared_hcd);\n\t\txhci->shared_hcd = NULL;\n\t}\n\tusb_remove_hcd(hcd);\n\n\tif (shared_hcd)\n\t\tusb_put_hcd(shared_hcd);\n\n\tusb_put_hcd(hcd);\n\txhci_mtk_sch_exit(mtk);\n\tclk_bulk_disable_unprepare(BULK_CLKS_NUM, mtk->clks);\n\tregulator_bulk_disable(BULK_VREGS_NUM, mtk->supplies);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_put_noidle(dev);\n\tpm_runtime_set_suspended(dev);\n}\n\nstatic int __maybe_unused xhci_mtk_suspend(struct device *dev)\n{\n\tstruct xhci_hcd_mtk *mtk = dev_get_drvdata(dev);\n\tstruct usb_hcd *hcd = mtk->hcd;\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct usb_hcd *shared_hcd = xhci->shared_hcd;\n\tint ret;\n\n\txhci_dbg(xhci, \"%s: stop port polling\\n\", __func__);\n\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tdel_timer_sync(&hcd->rh_timer);\n\tif (shared_hcd) {\n\t\tclear_bit(HCD_FLAG_POLL_RH, &shared_hcd->flags);\n\t\tdel_timer_sync(&shared_hcd->rh_timer);\n\t}\n\n\tret = xhci_mtk_host_disable(mtk);\n\tif (ret)\n\t\tgoto restart_poll_rh;\n\n\tclk_bulk_disable_unprepare(BULK_CLKS_NUM, mtk->clks);\n\tusb_wakeup_set(mtk, true);\n\treturn 0;\n\nrestart_poll_rh:\n\txhci_dbg(xhci, \"%s: restart port polling\\n\", __func__);\n\tif (shared_hcd) {\n\t\tset_bit(HCD_FLAG_POLL_RH, &shared_hcd->flags);\n\t\tusb_hcd_poll_rh_status(shared_hcd);\n\t}\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tusb_hcd_poll_rh_status(hcd);\n\treturn ret;\n}\n\nstatic int __maybe_unused xhci_mtk_resume(struct device *dev)\n{\n\tstruct xhci_hcd_mtk *mtk = dev_get_drvdata(dev);\n\tstruct usb_hcd *hcd = mtk->hcd;\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct usb_hcd *shared_hcd = xhci->shared_hcd;\n\tint ret;\n\n\tusb_wakeup_set(mtk, false);\n\tret = clk_bulk_prepare_enable(BULK_CLKS_NUM, mtk->clks);\n\tif (ret)\n\t\tgoto enable_wakeup;\n\n\tret = xhci_mtk_host_enable(mtk);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\txhci_dbg(xhci, \"%s: restart port polling\\n\", __func__);\n\tif (shared_hcd) {\n\t\tset_bit(HCD_FLAG_POLL_RH, &shared_hcd->flags);\n\t\tusb_hcd_poll_rh_status(shared_hcd);\n\t}\n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\tusb_hcd_poll_rh_status(hcd);\n\treturn 0;\n\ndisable_clks:\n\tclk_bulk_disable_unprepare(BULK_CLKS_NUM, mtk->clks);\nenable_wakeup:\n\tusb_wakeup_set(mtk, true);\n\treturn ret;\n}\n\nstatic int __maybe_unused xhci_mtk_runtime_suspend(struct device *dev)\n{\n\tstruct xhci_hcd_mtk  *mtk = dev_get_drvdata(dev);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(mtk->hcd);\n\tint ret = 0;\n\n\tif (xhci->xhc_state)\n\t\treturn -ESHUTDOWN;\n\n\tif (device_may_wakeup(dev))\n\t\tret = xhci_mtk_suspend(dev);\n\n\t \n\treturn ret ? -EBUSY : 0;\n}\n\nstatic int __maybe_unused xhci_mtk_runtime_resume(struct device *dev)\n{\n\tstruct xhci_hcd_mtk  *mtk = dev_get_drvdata(dev);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(mtk->hcd);\n\tint ret = 0;\n\n\tif (xhci->xhc_state)\n\t\treturn -ESHUTDOWN;\n\n\tif (device_may_wakeup(dev))\n\t\tret = xhci_mtk_resume(dev);\n\n\treturn ret;\n}\n\nstatic const struct dev_pm_ops xhci_mtk_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xhci_mtk_suspend, xhci_mtk_resume)\n\tSET_RUNTIME_PM_OPS(xhci_mtk_runtime_suspend,\n\t\t\t   xhci_mtk_runtime_resume, NULL)\n};\n\n#define DEV_PM_OPS (IS_ENABLED(CONFIG_PM) ? &xhci_mtk_pm_ops : NULL)\n\nstatic const struct of_device_id mtk_xhci_of_match[] = {\n\t{ .compatible = \"mediatek,mt8173-xhci\"},\n\t{ .compatible = \"mediatek,mt8195-xhci\"},\n\t{ .compatible = \"mediatek,mtk-xhci\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, mtk_xhci_of_match);\n\nstatic struct platform_driver mtk_xhci_driver = {\n\t.probe\t= xhci_mtk_probe,\n\t.remove_new = xhci_mtk_remove,\n\t.driver\t= {\n\t\t.name = \"xhci-mtk\",\n\t\t.pm = DEV_PM_OPS,\n\t\t.of_match_table = mtk_xhci_of_match,\n\t},\n};\n\nstatic int __init xhci_mtk_init(void)\n{\n\txhci_init_driver(&xhci_mtk_hc_driver, &xhci_mtk_overrides);\n\treturn platform_driver_register(&mtk_xhci_driver);\n}\nmodule_init(xhci_mtk_init);\n\nstatic void __exit xhci_mtk_exit(void)\n{\n\tplatform_driver_unregister(&mtk_xhci_driver);\n}\nmodule_exit(xhci_mtk_exit);\n\nMODULE_AUTHOR(\"Chunfeng Yun <chunfeng.yun@mediatek.com>\");\nMODULE_DESCRIPTION(\"MediaTek xHCI Host Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}