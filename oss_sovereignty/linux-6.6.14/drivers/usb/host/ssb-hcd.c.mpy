{
  "module_name": "ssb-hcd.c",
  "hash_id": "1daeb573718be740785b2b5736202c90cf49808c83df59036c94f0ac8fc7ff98",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ssb-hcd.c",
  "human_readable_source": "\n \n#include <linux/ssb/ssb.h>\n#include <linux/delay.h>\n#include <linux/platform_device.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/usb/ehci_pdriver.h>\n#include <linux/usb/ohci_pdriver.h>\n\nMODULE_AUTHOR(\"Hauke Mehrtens\");\nMODULE_DESCRIPTION(\"Common USB driver for SSB Bus\");\nMODULE_LICENSE(\"GPL\");\n\n#define SSB_HCD_TMSLOW_HOSTMODE\t(1 << 29)\n\nstruct ssb_hcd_device {\n\tstruct platform_device *ehci_dev;\n\tstruct platform_device *ohci_dev;\n\n\tu32 enable_flags;\n};\n\nstatic void ssb_hcd_5354wa(struct ssb_device *dev)\n{\n#ifdef CONFIG_SSB_DRIVER_MIPS\n\t \n\tif (dev->id.revision == 2 && dev->bus->chip_id == 0x5354) {\n\t\t \n\t\tssb_write32(dev, 0x894, 0x00fe00fe);\n\n\t\t \n\t\tssb_write32(dev, 0x89c, ssb_read32(dev, 0x89c) | 0x1);\n\t}\n#endif\n}\n\nstatic void ssb_hcd_usb20wa(struct ssb_device *dev)\n{\n\tif (dev->id.coreid == SSB_DEV_USB20_HOST) {\n\t\t \n\t\tssb_write32(dev, 0x200, 0x7ff);\n\n\t\t \n\t\tssb_write32(dev, 0x400, ssb_read32(dev, 0x400) & ~8);\n\t\tssb_read32(dev, 0x400);\n\n\t\t \n\t\tssb_write32(dev, 0x304, ssb_read32(dev, 0x304) & ~0x100);\n\t\tssb_read32(dev, 0x304);\n\n\t\tudelay(1);\n\n\t\tssb_hcd_5354wa(dev);\n\t}\n}\n\n \nstatic u32 ssb_hcd_init_chip(struct ssb_device *dev)\n{\n\tu32 flags = 0;\n\n\tif (dev->id.coreid == SSB_DEV_USB11_HOSTDEV)\n\t\t \n\t\tflags |= SSB_HCD_TMSLOW_HOSTMODE;\n\n\tssb_device_enable(dev, flags);\n\n\tssb_hcd_usb20wa(dev);\n\n\treturn flags;\n}\n\nstatic const struct usb_ehci_pdata ehci_pdata = {\n};\n\nstatic const struct usb_ohci_pdata ohci_pdata = {\n};\n\nstatic struct platform_device *ssb_hcd_create_pdev(struct ssb_device *dev, bool ohci, u32 addr, u32 len)\n{\n\tstruct platform_device *hci_dev;\n\tstruct resource hci_res[2];\n\tint ret;\n\n\tmemset(hci_res, 0, sizeof(hci_res));\n\n\thci_res[0].start = addr;\n\thci_res[0].end = hci_res[0].start + len - 1;\n\thci_res[0].flags = IORESOURCE_MEM;\n\n\thci_res[1].start = dev->irq;\n\thci_res[1].flags = IORESOURCE_IRQ;\n\n\thci_dev = platform_device_alloc(ohci ? \"ohci-platform\" :\n\t\t\t\t\t\"ehci-platform\" , 0);\n\tif (!hci_dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thci_dev->dev.parent = dev->dev;\n\thci_dev->dev.dma_mask = &hci_dev->dev.coherent_dma_mask;\n\n\tret = platform_device_add_resources(hci_dev, hci_res,\n\t\t\t\t\t    ARRAY_SIZE(hci_res));\n\tif (ret)\n\t\tgoto err_alloc;\n\tif (ohci)\n\t\tret = platform_device_add_data(hci_dev, &ohci_pdata,\n\t\t\t\t\t       sizeof(ohci_pdata));\n\telse\n\t\tret = platform_device_add_data(hci_dev, &ehci_pdata,\n\t\t\t\t\t       sizeof(ehci_pdata));\n\tif (ret)\n\t\tgoto err_alloc;\n\tret = platform_device_add(hci_dev);\n\tif (ret)\n\t\tgoto err_alloc;\n\n\treturn hci_dev;\n\nerr_alloc:\n\tplatform_device_put(hci_dev);\n\treturn ERR_PTR(ret);\n}\n\nstatic int ssb_hcd_probe(struct ssb_device *dev,\n\t\t\t\t   const struct ssb_device_id *id)\n{\n\tint err, tmp;\n\tint start, len;\n\tu16 chipid_top;\n\tu16 coreid = dev->id.coreid;\n\tstruct ssb_hcd_device *usb_dev;\n\n\t \n\tchipid_top = (dev->bus->chip_id & 0xFF00);\n\tif (chipid_top != 0x4700 && chipid_top != 0x5300)\n\t\treturn -ENODEV;\n\n\t \n\n\tif (dma_set_mask_and_coherent(dev->dma_dev, DMA_BIT_MASK(32)))\n\t\treturn -EOPNOTSUPP;\n\n\tusb_dev = devm_kzalloc(dev->dev, sizeof(struct ssb_hcd_device),\n\t\t\t       GFP_KERNEL);\n\tif (!usb_dev)\n\t\treturn -ENOMEM;\n\n\t \n\tusb_dev->enable_flags = ssb_hcd_init_chip(dev);\n\n\ttmp = ssb_read32(dev, SSB_ADMATCH0);\n\n\tstart = ssb_admatch_base(tmp);\n\tlen = (coreid == SSB_DEV_USB20_HOST) ? 0x800 : ssb_admatch_size(tmp);\n\tusb_dev->ohci_dev = ssb_hcd_create_pdev(dev, true, start, len);\n\tif (IS_ERR(usb_dev->ohci_dev))\n\t\treturn PTR_ERR(usb_dev->ohci_dev);\n\n\tif (coreid == SSB_DEV_USB20_HOST) {\n\t\tstart = ssb_admatch_base(tmp) + 0x800;  \n\t\tusb_dev->ehci_dev = ssb_hcd_create_pdev(dev, false, start, len);\n\t\tif (IS_ERR(usb_dev->ehci_dev)) {\n\t\t\terr = PTR_ERR(usb_dev->ehci_dev);\n\t\t\tgoto err_unregister_ohci_dev;\n\t\t}\n\t}\n\n\tssb_set_drvdata(dev, usb_dev);\n\treturn 0;\n\nerr_unregister_ohci_dev:\n\tplatform_device_unregister(usb_dev->ohci_dev);\n\treturn err;\n}\n\nstatic void ssb_hcd_remove(struct ssb_device *dev)\n{\n\tstruct ssb_hcd_device *usb_dev = ssb_get_drvdata(dev);\n\tstruct platform_device *ohci_dev = usb_dev->ohci_dev;\n\tstruct platform_device *ehci_dev = usb_dev->ehci_dev;\n\n\tif (ohci_dev)\n\t\tplatform_device_unregister(ohci_dev);\n\tif (ehci_dev)\n\t\tplatform_device_unregister(ehci_dev);\n\n\tssb_device_disable(dev, 0);\n}\n\nstatic void ssb_hcd_shutdown(struct ssb_device *dev)\n{\n\tssb_device_disable(dev, 0);\n}\n\n#ifdef CONFIG_PM\n\nstatic int ssb_hcd_suspend(struct ssb_device *dev, pm_message_t state)\n{\n\tssb_device_disable(dev, 0);\n\n\treturn 0;\n}\n\nstatic int ssb_hcd_resume(struct ssb_device *dev)\n{\n\tstruct ssb_hcd_device *usb_dev = ssb_get_drvdata(dev);\n\n\tssb_device_enable(dev, usb_dev->enable_flags);\n\n\treturn 0;\n}\n\n#else  \n#define ssb_hcd_suspend\tNULL\n#define ssb_hcd_resume\tNULL\n#endif  \n\nstatic const struct ssb_device_id ssb_hcd_table[] = {\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOSTDEV, SSB_ANY_REV),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB11_HOST, SSB_ANY_REV),\n\tSSB_DEVICE(SSB_VENDOR_BROADCOM, SSB_DEV_USB20_HOST, SSB_ANY_REV),\n\t{},\n};\nMODULE_DEVICE_TABLE(ssb, ssb_hcd_table);\n\nstatic struct ssb_driver ssb_hcd_driver = {\n\t.name\t\t= KBUILD_MODNAME,\n\t.id_table\t= ssb_hcd_table,\n\t.probe\t\t= ssb_hcd_probe,\n\t.remove\t\t= ssb_hcd_remove,\n\t.shutdown\t= ssb_hcd_shutdown,\n\t.suspend\t= ssb_hcd_suspend,\n\t.resume\t\t= ssb_hcd_resume,\n};\n\nstatic int __init ssb_hcd_init(void)\n{\n\treturn ssb_driver_register(&ssb_hcd_driver);\n}\nmodule_init(ssb_hcd_init);\n\nstatic void __exit ssb_hcd_exit(void)\n{\n\tssb_driver_unregister(&ssb_hcd_driver);\n}\nmodule_exit(ssb_hcd_exit);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}