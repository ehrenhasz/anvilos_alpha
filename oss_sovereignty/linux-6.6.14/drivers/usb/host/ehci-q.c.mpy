{
  "module_name": "ehci-q.c",
  "hash_id": "ed35718bdfedc4e8b0e0aaac899151e143368b45c200e658b4e303164c240aea",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-q.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n\n \n#define PID_CODE_IN    1\n#define PID_CODE_SETUP 2\n\n \n\nstatic unsigned int\nqtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,\n\t\t  size_t len, int token, int maxpacket)\n{\n\tunsigned int count;\n\tu64\taddr = buf;\n\tint\ti;\n\n\t \n\tqtd->hw_buf[0] = cpu_to_hc32(ehci, (u32)addr);\n\tqtd->hw_buf_hi[0] = cpu_to_hc32(ehci, (u32)(addr >> 32));\n\tcount = 0x1000 - (buf & 0x0fff);\t \n\tif (likely (len < count))\t\t \n\t\tcount = len;\n\telse {\n\t\tbuf +=  0x1000;\n\t\tbuf &= ~0x0fff;\n\n\t\t \n\t\tfor (i = 1; count < len && i < 5; i++) {\n\t\t\taddr = buf;\n\t\t\tqtd->hw_buf[i] = cpu_to_hc32(ehci, (u32)addr);\n\t\t\tqtd->hw_buf_hi[i] = cpu_to_hc32(ehci,\n\t\t\t\t\t(u32)(addr >> 32));\n\t\t\tbuf += 0x1000;\n\t\t\tif ((count + 0x1000) < len)\n\t\t\t\tcount += 0x1000;\n\t\t\telse\n\t\t\t\tcount = len;\n\t\t}\n\n\t\t \n\t\tif (count != len)\n\t\t\tcount -= (count % maxpacket);\n\t}\n\tqtd->hw_token = cpu_to_hc32(ehci, (count << 16) | token);\n\tqtd->length = count;\n\n\treturn count;\n}\n\n \n\nstatic inline void\nqh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)\n{\n\tstruct ehci_qh_hw *hw = qh->hw;\n\n\t \n\tWARN_ON(qh->qh_state != QH_STATE_IDLE);\n\n\thw->hw_qtd_next = QTD_NEXT(ehci, qtd->qtd_dma);\n\thw->hw_alt_next = EHCI_LIST_END(ehci);\n\n\t \n\tif (!(hw->hw_info1 & cpu_to_hc32(ehci, QH_TOGGLE_CTL))) {\n\t\tunsigned\tis_out, epnum;\n\n\t\tis_out = qh->is_out;\n\t\tepnum = (hc32_to_cpup(ehci, &hw->hw_info1) >> 8) & 0x0f;\n\t\tif (unlikely(!usb_gettoggle(qh->ps.udev, epnum, is_out))) {\n\t\t\thw->hw_token &= ~cpu_to_hc32(ehci, QTD_TOGGLE);\n\t\t\tusb_settoggle(qh->ps.udev, epnum, is_out, 1);\n\t\t}\n\t}\n\n\thw->hw_token &= cpu_to_hc32(ehci, QTD_TOGGLE | QTD_STS_PING);\n}\n\n \nstatic void\nqh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tstruct ehci_qtd *qtd;\n\n\tqtd = list_entry(qh->qtd_list.next, struct ehci_qtd, qtd_list);\n\n\t \n\tif (qh->hw->hw_token & ACTIVE_BIT(ehci)) {\n\t\tqh->hw->hw_qtd_next = qtd->hw_next;\n\t\tif (qh->should_be_inactive)\n\t\t\tehci_warn(ehci, \"qh %p should be inactive!\\n\", qh);\n\t} else {\n\t\tqh_update(ehci, qh, qtd);\n\t}\n\tqh->should_be_inactive = 0;\n}\n\n \n\nstatic void qh_link_async(struct ehci_hcd *ehci, struct ehci_qh *qh);\n\nstatic void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct ehci_qh\t\t*qh = ep->hcpriv;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\tqh->clearing_tt = 0;\n\tif (qh->qh_state == QH_STATE_IDLE && !list_empty(&qh->qtd_list)\n\t\t\t&& ehci->rh_state == EHCI_RH_RUNNING)\n\t\tqh_link_async(ehci, qh);\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n}\n\nstatic void ehci_clear_tt_buffer(struct ehci_hcd *ehci, struct ehci_qh *qh,\n\t\tstruct urb *urb, u32 token)\n{\n\n\t \n\tif (urb->dev->tt && !usb_pipeint(urb->pipe) && !qh->clearing_tt) {\n#ifdef CONFIG_DYNAMIC_DEBUG\n\t\tstruct usb_device *tt = urb->dev->tt->hub;\n\t\tdev_dbg(&tt->dev,\n\t\t\t\"clear tt buffer port %d, a%d ep%d t%08x\\n\",\n\t\t\turb->dev->ttport, urb->dev->devnum,\n\t\t\tusb_pipeendpoint(urb->pipe), token);\n#endif  \n\t\tif (!ehci_is_TDI(ehci)\n\t\t\t\t|| urb->dev->tt->hub !=\n\t\t\t\t   ehci_to_hcd(ehci)->self.root_hub) {\n\t\t\tif (usb_hub_clear_tt_buffer(urb) == 0)\n\t\t\t\tqh->clearing_tt = 1;\n\t\t} else {\n\n\t\t\t \n\t\t}\n\t}\n}\n\nstatic int qtd_copy_status (\n\tstruct ehci_hcd *ehci,\n\tstruct urb *urb,\n\tsize_t length,\n\tu32 token\n)\n{\n\tint\tstatus = -EINPROGRESS;\n\n\t \n\tif (likely(QTD_PID(token) != PID_CODE_SETUP))\n\t\turb->actual_length += length - QTD_LENGTH (token);\n\n\t \n\tif (unlikely(urb->unlinked))\n\t\treturn status;\n\n\t \n\tif (unlikely (IS_SHORT_READ (token)))\n\t\tstatus = -EREMOTEIO;\n\n\t \n\tif (token & QTD_STS_HALT) {\n\t\tif (token & QTD_STS_BABBLE) {\n\t\t\t \n\t\t\tstatus = -EOVERFLOW;\n\t\t \n\t\t} else if ((token & QTD_STS_MMF) &&\n\t\t\t\t\t(QTD_PID(token) == PID_CODE_IN)) {\n\t\t\tstatus = -EPROTO;\n\t\t \n\t\t} else if (QTD_CERR(token)) {\n\t\t\tstatus = -EPIPE;\n\n\t\t \n\t\t} else if (token & QTD_STS_MMF) {\n\t\t\t \n\t\t\tstatus = -EPROTO;\n\t\t} else if (token & QTD_STS_DBE) {\n\t\t\tstatus = (QTD_PID (token) == 1)  \n\t\t\t\t? -ENOSR   \n\t\t\t\t: -ECOMM;  \n\t\t} else if (token & QTD_STS_XACT) {\n\t\t\t \n\t\t\tehci_dbg(ehci, \"devpath %s ep%d%s 3strikes\\n\",\n\t\t\t\turb->dev->devpath,\n\t\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\");\n\t\t\tstatus = -EPROTO;\n\t\t} else {\t \n\t\t\tstatus = -EPROTO;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic void\nehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)\n{\n\tif (usb_pipetype(urb->pipe) == PIPE_INTERRUPT) {\n\t\t \n\t\tehci_to_hcd(ehci)->self.bandwidth_int_reqs--;\n\t}\n\n\tif (unlikely(urb->unlinked)) {\n\t\tINCR(ehci->stats.unlink);\n\t} else {\n\t\t \n\t\tif (status == -EINPROGRESS || status == -EREMOTEIO)\n\t\t\tstatus = 0;\n\t\tINCR(ehci->stats.complete);\n\t}\n\n#ifdef EHCI_URB_TRACE\n\tehci_dbg (ehci,\n\t\t\"%s %s urb %p ep%d%s status %d len %d/%d\\n\",\n\t\t__func__, urb->dev->devpath, urb,\n\t\tusb_pipeendpoint (urb->pipe),\n\t\tusb_pipein (urb->pipe) ? \"in\" : \"out\",\n\t\tstatus,\n\t\turb->actual_length, urb->transfer_buffer_length);\n#endif\n\n\tusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\n\tusb_hcd_giveback_urb(ehci_to_hcd(ehci), urb, status);\n}\n\nstatic int qh_schedule (struct ehci_hcd *ehci, struct ehci_qh *qh);\n\n \nstatic unsigned\nqh_completions (struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tstruct ehci_qtd\t\t*last, *end = qh->dummy;\n\tstruct list_head\t*entry, *tmp;\n\tint\t\t\tlast_status;\n\tint\t\t\tstopped;\n\tu8\t\t\tstate;\n\tstruct ehci_qh_hw\t*hw = qh->hw;\n\n\t \n\tstate = qh->qh_state;\n\tqh->qh_state = QH_STATE_COMPLETING;\n\tstopped = (state == QH_STATE_IDLE);\n\n rescan:\n\tlast = NULL;\n\tlast_status = -EINPROGRESS;\n\tqh->dequeue_during_giveback = 0;\n\n\t \n\tlist_for_each_safe (entry, tmp, &qh->qtd_list) {\n\t\tstruct ehci_qtd\t*qtd;\n\t\tstruct urb\t*urb;\n\t\tu32\t\ttoken = 0;\n\n\t\tqtd = list_entry (entry, struct ehci_qtd, qtd_list);\n\t\turb = qtd->urb;\n\n\t\t \n\t\tif (last) {\n\t\t\tif (likely (last->urb != urb)) {\n\t\t\t\tehci_urb_done(ehci, last->urb, last_status);\n\t\t\t\tlast_status = -EINPROGRESS;\n\t\t\t}\n\t\t\tehci_qtd_free (ehci, last);\n\t\t\tlast = NULL;\n\t\t}\n\n\t\t \n\t\tif (qtd == end)\n\t\t\tbreak;\n\n\t\t \n\t\trmb ();\n\t\ttoken = hc32_to_cpu(ehci, qtd->hw_token);\n\n\t\t \n retry_xacterr:\n\t\tif ((token & QTD_STS_ACTIVE) == 0) {\n\n\t\t\t \n\t\t\tif (token & QTD_STS_DBE)\n\t\t\t\tehci_dbg(ehci,\n\t\t\t\t\t\"detected DataBufferErr for urb %p ep%d%s len %d, qtd %p [qh %p]\\n\",\n\t\t\t\t\turb,\n\t\t\t\t\tusb_endpoint_num(&urb->ep->desc),\n\t\t\t\t\tusb_endpoint_dir_in(&urb->ep->desc) ? \"in\" : \"out\",\n\t\t\t\t\turb->transfer_buffer_length,\n\t\t\t\t\tqtd,\n\t\t\t\t\tqh);\n\n\t\t\t \n\t\t\tif ((token & QTD_STS_HALT) != 0) {\n\n\t\t\t\t \n\t\t\t\tif ((token & QTD_STS_XACT) &&\n\t\t\t\t\t\tQTD_CERR(token) == 0 &&\n\t\t\t\t\t\t++qh->xacterrs < QH_XACTERR_MAX &&\n\t\t\t\t\t\t!urb->unlinked) {\n\t\t\t\t\tehci_dbg(ehci,\n\t\"detected XactErr len %zu/%zu retry %d\\n\",\n\tqtd->length - QTD_LENGTH(token), qtd->length, qh->xacterrs);\n\n\t\t\t\t\t \n\t\t\t\t\ttoken &= ~QTD_STS_HALT;\n\t\t\t\t\ttoken |= QTD_STS_ACTIVE |\n\t\t\t\t\t\t\t(EHCI_TUNE_CERR << 10);\n\t\t\t\t\tqtd->hw_token = cpu_to_hc32(ehci,\n\t\t\t\t\t\t\ttoken);\n\t\t\t\t\twmb();\n\t\t\t\t\thw->hw_token = cpu_to_hc32(ehci,\n\t\t\t\t\t\t\ttoken);\n\t\t\t\t\tgoto retry_xacterr;\n\t\t\t\t}\n\t\t\t\tstopped = 1;\n\t\t\t\tqh->unlink_reason |= QH_UNLINK_HALTED;\n\n\t\t\t \n\t\t\t} else if (IS_SHORT_READ (token)\n\t\t\t\t\t&& !(qtd->hw_alt_next\n\t\t\t\t\t\t& EHCI_LIST_END(ehci))) {\n\t\t\t\tstopped = 1;\n\t\t\t\tqh->unlink_reason |= QH_UNLINK_SHORT_READ;\n\t\t\t}\n\n\t\t \n\t\t} else if (likely (!stopped\n\t\t\t\t&& ehci->rh_state >= EHCI_RH_RUNNING)) {\n\t\t\tbreak;\n\n\t\t \n\t\t} else {\n\t\t\tstopped = 1;\n\n\t\t\t \n\t\t\tif (ehci->rh_state < EHCI_RH_RUNNING) {\n\t\t\t\tlast_status = -ESHUTDOWN;\n\t\t\t\tqh->unlink_reason |= QH_UNLINK_SHUTDOWN;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (last_status == -EINPROGRESS && !urb->unlinked)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (state == QH_STATE_IDLE &&\n\t\t\t\t\tqh->qtd_list.next == &qtd->qtd_list &&\n\t\t\t\t\t(hw->hw_token & ACTIVE_BIT(ehci))) {\n\t\t\t\ttoken = hc32_to_cpu(ehci, hw->hw_token);\n\t\t\t\thw->hw_token &= ~ACTIVE_BIT(ehci);\n\t\t\t\tqh->should_be_inactive = 1;\n\n\t\t\t\t \n\t\t\t\tehci_clear_tt_buffer(ehci, qh, urb, token);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (last_status == -EINPROGRESS) {\n\t\t\tlast_status = qtd_copy_status(ehci, urb,\n\t\t\t\t\tqtd->length, token);\n\t\t\tif (last_status == -EREMOTEIO\n\t\t\t\t\t&& (qtd->hw_alt_next\n\t\t\t\t\t\t& EHCI_LIST_END(ehci)))\n\t\t\t\tlast_status = -EINPROGRESS;\n\n\t\t\t \n\t\t\tif (unlikely(last_status != -EINPROGRESS &&\n\t\t\t\t\tlast_status != -EREMOTEIO)) {\n\t\t\t\t \n\t\t\t\tif (last_status != -EPIPE)\n\t\t\t\t\tehci_clear_tt_buffer(ehci, qh, urb,\n\t\t\t\t\t\t\ttoken);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\n\t\t\tlast = list_entry (qtd->qtd_list.prev,\n\t\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t\tlast->hw_next = qtd->hw_next;\n\t\t}\n\n\t\t \n\t\tlist_del (&qtd->qtd_list);\n\t\tlast = qtd;\n\n\t\t \n\t\tqh->xacterrs = 0;\n\t}\n\n\t \n\tif (likely (last != NULL)) {\n\t\tehci_urb_done(ehci, last->urb, last_status);\n\t\tehci_qtd_free (ehci, last);\n\t}\n\n\t \n\tif (unlikely(qh->dequeue_during_giveback)) {\n\t\t \n\t\tif (state == QH_STATE_IDLE)\n\t\t\tgoto rescan;\n\n\t\t \n\t}\n\n\t \n\tqh->qh_state = state;\n\n\t \n\tif (stopped != 0 || hw->hw_qtd_next == EHCI_LIST_END(ehci))\n\t\tqh->unlink_reason |= QH_UNLINK_DUMMY_OVERLAY;\n\n\t \n\treturn qh->unlink_reason;\n}\n\n \n\n \nstatic void qtd_list_free (\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct list_head\t*qtd_list\n) {\n\tstruct list_head\t*entry, *temp;\n\n\tlist_for_each_safe (entry, temp, qtd_list) {\n\t\tstruct ehci_qtd\t*qtd;\n\n\t\tqtd = list_entry (entry, struct ehci_qtd, qtd_list);\n\t\tlist_del (&qtd->qtd_list);\n\t\tehci_qtd_free (ehci, qtd);\n\t}\n}\n\n \nstatic struct list_head *\nqh_urb_transaction (\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct list_head\t*head,\n\tgfp_t\t\t\tflags\n) {\n\tstruct ehci_qtd\t\t*qtd, *qtd_prev;\n\tdma_addr_t\t\tbuf;\n\tint\t\t\tlen, this_sg_len, maxpacket;\n\tint\t\t\tis_input;\n\tu32\t\t\ttoken;\n\tint\t\t\ti;\n\tstruct scatterlist\t*sg;\n\n\t \n\tqtd = ehci_qtd_alloc (ehci, flags);\n\tif (unlikely (!qtd))\n\t\treturn NULL;\n\tlist_add_tail (&qtd->qtd_list, head);\n\tqtd->urb = urb;\n\n\ttoken = QTD_STS_ACTIVE;\n\ttoken |= (EHCI_TUNE_CERR << 10);\n\t \n\n\tlen = urb->transfer_buffer_length;\n\tis_input = usb_pipein (urb->pipe);\n\tif (usb_pipecontrol (urb->pipe)) {\n\t\t \n\t\tqtd_fill(ehci, qtd, urb->setup_dma,\n\t\t\t\tsizeof (struct usb_ctrlrequest),\n\t\t\t\ttoken | (2   << 8), 8);\n\n\t\t \n\t\ttoken ^= QTD_TOGGLE;\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc (ehci, flags);\n\t\tif (unlikely (!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\n\t\tlist_add_tail (&qtd->qtd_list, head);\n\n\t\t \n\t\tif (len == 0)\n\t\t\ttoken |= (1   << 8);\n\t}\n\n\t \n\ti = urb->num_mapped_sgs;\n\tif (len > 0 && i > 0) {\n\t\tsg = urb->sg;\n\t\tbuf = sg_dma_address(sg);\n\n\t\t \n\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t} else {\n\t\tsg = NULL;\n\t\tbuf = urb->transfer_dma;\n\t\tthis_sg_len = len;\n\t}\n\n\tif (is_input)\n\t\ttoken |= (1   << 8);\n\t \n\n\tmaxpacket = usb_endpoint_maxp(&urb->ep->desc);\n\n\t \n\tfor (;;) {\n\t\tunsigned int this_qtd_len;\n\n\t\tthis_qtd_len = qtd_fill(ehci, qtd, buf, this_sg_len, token,\n\t\t\t\tmaxpacket);\n\t\tthis_sg_len -= this_qtd_len;\n\t\tlen -= this_qtd_len;\n\t\tbuf += this_qtd_len;\n\n\t\t \n\t\tif (is_input)\n\t\t\tqtd->hw_alt_next = ehci->async->hw->hw_alt_next;\n\n\t\t \n\t\tif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\n\t\t\ttoken ^= QTD_TOGGLE;\n\n\t\tif (likely(this_sg_len <= 0)) {\n\t\t\tif (--i <= 0 || len <= 0)\n\t\t\t\tbreak;\n\t\t\tsg = sg_next(sg);\n\t\t\tbuf = sg_dma_address(sg);\n\t\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t\t}\n\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc (ehci, flags);\n\t\tif (unlikely (!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\n\t\tlist_add_tail (&qtd->qtd_list, head);\n\t}\n\n\t \n\tif (likely ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\n\t\t\t\t|| usb_pipecontrol (urb->pipe)))\n\t\tqtd->hw_alt_next = EHCI_LIST_END(ehci);\n\n\t \n\tif (likely (urb->transfer_buffer_length != 0)) {\n\t\tint\tone_more = 0;\n\n\t\tif (usb_pipecontrol (urb->pipe)) {\n\t\t\tone_more = 1;\n\t\t\ttoken ^= 0x0100;\t \n\t\t\ttoken |= QTD_TOGGLE;\t \n\t\t} else if (usb_pipeout(urb->pipe)\n\t\t\t\t&& (urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& !(urb->transfer_buffer_length % maxpacket)) {\n\t\t\tone_more = 1;\n\t\t}\n\t\tif (one_more) {\n\t\t\tqtd_prev = qtd;\n\t\t\tqtd = ehci_qtd_alloc (ehci, flags);\n\t\t\tif (unlikely (!qtd))\n\t\t\t\tgoto cleanup;\n\t\t\tqtd->urb = urb;\n\t\t\tqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\n\t\t\tlist_add_tail (&qtd->qtd_list, head);\n\n\t\t\t \n\t\t\tqtd_fill(ehci, qtd, 0, 0, token, 0);\n\t\t}\n\t}\n\n\t \n\tif (likely (!(urb->transfer_flags & URB_NO_INTERRUPT)))\n\t\tqtd->hw_token |= cpu_to_hc32(ehci, QTD_IOC);\n\treturn head;\n\ncleanup:\n\tqtd_list_free (ehci, urb, head);\n\treturn NULL;\n}\n\n \n\n\n\n\n\n\n\n\n \nstatic struct ehci_qh *\nqh_make (\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tgfp_t\t\t\tflags\n) {\n\tstruct ehci_qh\t\t*qh = ehci_qh_alloc (ehci, flags);\n\tstruct usb_host_endpoint *ep;\n\tu32\t\t\tinfo1 = 0, info2 = 0;\n\tint\t\t\tis_input, type;\n\tint\t\t\tmaxp = 0;\n\tint\t\t\tmult;\n\tstruct usb_tt\t\t*tt = urb->dev->tt;\n\tstruct ehci_qh_hw\t*hw;\n\n\tif (!qh)\n\t\treturn qh;\n\n\t \n\tinfo1 |= usb_pipeendpoint (urb->pipe) << 8;\n\tinfo1 |= usb_pipedevice (urb->pipe) << 0;\n\n\tis_input = usb_pipein (urb->pipe);\n\ttype = usb_pipetype (urb->pipe);\n\tep = usb_pipe_endpoint (urb->dev, urb->pipe);\n\tmaxp = usb_endpoint_maxp (&ep->desc);\n\tmult = usb_endpoint_maxp_mult (&ep->desc);\n\n\t \n\tif (maxp > 1024) {\n\t\tehci_dbg(ehci, \"bogus qh maxpacket %d\\n\", maxp);\n\t\tgoto done;\n\t}\n\n\t \n\tif (type == PIPE_INTERRUPT) {\n\t\tunsigned\ttmp;\n\n\t\tqh->ps.usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\n\t\t\t\tis_input, 0, mult * maxp));\n\t\tqh->ps.phase = NO_FRAME;\n\n\t\tif (urb->dev->speed == USB_SPEED_HIGH) {\n\t\t\tqh->ps.c_usecs = 0;\n\t\t\tqh->gap_uf = 0;\n\n\t\t\tif (urb->interval > 1 && urb->interval < 8) {\n\t\t\t\t \n\t\t\t\turb->interval = 1;\n\t\t\t} else if (urb->interval > ehci->periodic_size << 3) {\n\t\t\t\turb->interval = ehci->periodic_size << 3;\n\t\t\t}\n\t\t\tqh->ps.period = urb->interval >> 3;\n\n\t\t\t \n\t\t\ttmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,\n\t\t\t\t\t1 << (urb->ep->desc.bInterval - 1));\n\n\t\t\t \n\t\t\tqh->ps.bw_uperiod = min_t(unsigned, tmp, urb->interval);\n\t\t\tqh->ps.bw_period = qh->ps.bw_uperiod >> 3;\n\t\t} else {\n\t\t\tint\t\tthink_time;\n\n\t\t\t \n\t\t\tqh->gap_uf = 1 + usb_calc_bus_time (urb->dev->speed,\n\t\t\t\t\tis_input, 0, maxp) / (125 * 1000);\n\n\t\t\t \n\t\t\tif (is_input) {\t\t \n\t\t\t\tqh->ps.c_usecs = qh->ps.usecs + HS_USECS(0);\n\t\t\t\tqh->ps.usecs = HS_USECS(1);\n\t\t\t} else {\t\t \n\t\t\t\tqh->ps.usecs += HS_USECS(1);\n\t\t\t\tqh->ps.c_usecs = HS_USECS(0);\n\t\t\t}\n\n\t\t\tthink_time = tt ? tt->think_time : 0;\n\t\t\tqh->ps.tt_usecs = NS_TO_US(think_time +\n\t\t\t\t\tusb_calc_bus_time (urb->dev->speed,\n\t\t\t\t\tis_input, 0, maxp));\n\t\t\tif (urb->interval > ehci->periodic_size)\n\t\t\t\turb->interval = ehci->periodic_size;\n\t\t\tqh->ps.period = urb->interval;\n\n\t\t\t \n\t\t\ttmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,\n\t\t\t\t\turb->ep->desc.bInterval);\n\t\t\ttmp = rounddown_pow_of_two(tmp);\n\n\t\t\t \n\t\t\tqh->ps.bw_period = min_t(unsigned, tmp, urb->interval);\n\t\t\tqh->ps.bw_uperiod = qh->ps.bw_period << 3;\n\t\t}\n\t}\n\n\t \n\tqh->ps.udev = urb->dev;\n\tqh->ps.ep = urb->ep;\n\n\t \n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tinfo1 |= QH_LOW_SPEED;\n\t\tfallthrough;\n\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tif (type != PIPE_INTERRUPT)\n\t\t\tinfo1 |= (EHCI_TUNE_RL_TT << 28);\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= QH_CONTROL_EP;\t\t \n\t\t\tinfo1 |= QH_TOGGLE_CTL;\t\t \n\t\t}\n\t\tinfo1 |= maxp << 16;\n\n\t\tinfo2 |= (EHCI_TUNE_MULT_TT << 30);\n\n\t\t \n\t\tif (ehci_has_fsl_portno_bug(ehci))\n\t\t\tinfo2 |= (urb->dev->ttport-1) << 23;\n\t\telse\n\t\t\tinfo2 |= urb->dev->ttport << 23;\n\n\t\t \n\t\tif (tt && tt->hub != ehci_to_hcd(ehci)->self.root_hub)\n\t\t\tinfo2 |= tt->hub->devnum << 16;\n\n\t\t \n\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\t\t \n\t\tinfo1 |= QH_HIGH_SPEED;\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= (EHCI_TUNE_RL_HS << 28);\n\t\t\tinfo1 |= 64 << 16;\t \n\t\t\tinfo1 |= QH_TOGGLE_CTL;\t \n\t\t\tinfo2 |= (EHCI_TUNE_MULT_HS << 30);\n\t\t} else if (type == PIPE_BULK) {\n\t\t\tinfo1 |= (EHCI_TUNE_RL_HS << 28);\n\t\t\t \n\t\t\tinfo1 |= maxp << 16;\n\t\t\tinfo2 |= (EHCI_TUNE_MULT_HS << 30);\n\t\t} else {\t\t \n\t\t\tinfo1 |= maxp << 16;\n\t\t\tinfo2 |= mult << 30;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tehci_dbg(ehci, \"bogus dev %p speed %d\\n\", urb->dev,\n\t\t\turb->dev->speed);\ndone:\n\t\tqh_destroy(ehci, qh);\n\t\treturn NULL;\n\t}\n\n\t \n\n\t \n\tqh->qh_state = QH_STATE_IDLE;\n\thw = qh->hw;\n\thw->hw_info1 = cpu_to_hc32(ehci, info1);\n\thw->hw_info2 = cpu_to_hc32(ehci, info2);\n\tqh->is_out = !is_input;\n\tusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe), !is_input, 1);\n\treturn qh;\n}\n\n \n\nstatic void enable_async(struct ehci_hcd *ehci)\n{\n\tif (ehci->async_count++)\n\t\treturn;\n\n\t \n\tehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_DISABLE_ASYNC);\n\n\t \n\tehci_poll_ASS(ehci);\n\tturn_on_io_watchdog(ehci);\n}\n\nstatic void disable_async(struct ehci_hcd *ehci)\n{\n\tif (--ehci->async_count)\n\t\treturn;\n\n\t \n\tWARN_ON(ehci->async->qh_next.qh || !list_empty(&ehci->async_unlink) ||\n\t\t\t!list_empty(&ehci->async_idle));\n\n\t \n\tehci_poll_ASS(ehci);\n}\n\n \n\nstatic void qh_link_async (struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\t__hc32\t\tdma = QH_NEXT(ehci, qh->qh_dma);\n\tstruct ehci_qh\t*head;\n\n\t \n\tif (unlikely(qh->clearing_tt))\n\t\treturn;\n\n\tWARN_ON(qh->qh_state != QH_STATE_IDLE);\n\n\t \n\tqh_refresh(ehci, qh);\n\n\t \n\thead = ehci->async;\n\tqh->qh_next = head->qh_next;\n\tqh->hw->hw_next = head->hw->hw_next;\n\twmb ();\n\n\thead->qh_next.qh = qh;\n\thead->hw->hw_next = dma;\n\n\tqh->qh_state = QH_STATE_LINKED;\n\tqh->xacterrs = 0;\n\tqh->unlink_reason = 0;\n\t \n\n\tenable_async(ehci);\n}\n\n \n\n \nstatic struct ehci_qh *qh_append_tds (\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct list_head\t*qtd_list,\n\tint\t\t\tepnum,\n\tvoid\t\t\t**ptr\n)\n{\n\tstruct ehci_qh\t\t*qh = NULL;\n\t__hc32\t\t\tqh_addr_mask = cpu_to_hc32(ehci, 0x7f);\n\n\tqh = (struct ehci_qh *) *ptr;\n\tif (unlikely (qh == NULL)) {\n\t\t \n\t\tqh = qh_make (ehci, urb, GFP_ATOMIC);\n\t\t*ptr = qh;\n\t}\n\tif (likely (qh != NULL)) {\n\t\tstruct ehci_qtd\t*qtd;\n\n\t\tif (unlikely (list_empty (qtd_list)))\n\t\t\tqtd = NULL;\n\t\telse\n\t\t\tqtd = list_entry (qtd_list->next, struct ehci_qtd,\n\t\t\t\t\tqtd_list);\n\n\t\t \n\t\tif (unlikely (epnum == 0)) {\n\n                         \n                        if (usb_pipedevice (urb->pipe) == 0)\n\t\t\t\tqh->hw->hw_info1 &= ~qh_addr_mask;\n\t\t}\n\n\t\t \n\t\tif (likely (qtd != NULL)) {\n\t\t\tstruct ehci_qtd\t\t*dummy;\n\t\t\tdma_addr_t\t\tdma;\n\t\t\t__hc32\t\t\ttoken;\n\n\t\t\t \n\t\t\ttoken = qtd->hw_token;\n\t\t\tqtd->hw_token = HALT_BIT(ehci);\n\n\t\t\tdummy = qh->dummy;\n\n\t\t\tdma = dummy->qtd_dma;\n\t\t\t*dummy = *qtd;\n\t\t\tdummy->qtd_dma = dma;\n\n\t\t\tlist_del (&qtd->qtd_list);\n\t\t\tlist_add (&dummy->qtd_list, qtd_list);\n\t\t\tlist_splice_tail(qtd_list, &qh->qtd_list);\n\n\t\t\tehci_qtd_init(ehci, qtd, qtd->qtd_dma);\n\t\t\tqh->dummy = qtd;\n\n\t\t\t \n\t\t\tdma = qtd->qtd_dma;\n\t\t\tqtd = list_entry (qh->qtd_list.prev,\n\t\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t\tqtd->hw_next = QTD_NEXT(ehci, dma);\n\n\t\t\t \n\t\t\twmb ();\n\t\t\tdummy->hw_token = token;\n\n\t\t\turb->hcpriv = qh;\n\t\t}\n\t}\n\treturn qh;\n}\n\n \n\nstatic int\nsubmit_async (\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct list_head\t*qtd_list,\n\tgfp_t\t\t\tmem_flags\n) {\n\tint\t\t\tepnum;\n\tunsigned long\t\tflags;\n\tstruct ehci_qh\t\t*qh = NULL;\n\tint\t\t\trc;\n\n\tepnum = urb->ep->desc.bEndpointAddress;\n\n#ifdef EHCI_URB_TRACE\n\t{\n\t\tstruct ehci_qtd *qtd;\n\t\tqtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);\n\t\tehci_dbg(ehci,\n\t\t\t \"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\\n\",\n\t\t\t __func__, urb->dev->devpath, urb,\n\t\t\t epnum & 0x0f, (epnum & USB_DIR_IN) ? \"in\" : \"out\",\n\t\t\t urb->transfer_buffer_length,\n\t\t\t qtd, urb->ep->hcpriv);\n\t}\n#endif\n\n\tspin_lock_irqsave (&ehci->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\n\t\trc = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n\trc = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\n\tif (unlikely(rc))\n\t\tgoto done;\n\n\tqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tif (unlikely(qh == NULL)) {\n\t\tusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\n\t\trc = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (likely (qh->qh_state == QH_STATE_IDLE))\n\t\tqh_link_async(ehci, qh);\n done:\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n\tif (unlikely (qh == NULL))\n\t\tqtd_list_free (ehci, urb, qtd_list);\n\treturn rc;\n}\n\n \n#ifdef CONFIG_USB_HCD_TEST_MODE\n \nstatic int ehci_submit_single_step_set_feature(\n\tstruct usb_hcd  *hcd,\n\tstruct urb      *urb,\n\tint             is_setup\n) {\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct list_head\tqtd_list;\n\tstruct list_head\t*head;\n\n\tstruct ehci_qtd\t\t*qtd, *qtd_prev;\n\tdma_addr_t\t\tbuf;\n\tint\t\t\tlen, maxpacket;\n\tu32\t\t\ttoken;\n\n\tINIT_LIST_HEAD(&qtd_list);\n\thead = &qtd_list;\n\n\t \n\tqtd = ehci_qtd_alloc(ehci, GFP_KERNEL);\n\tif (unlikely(!qtd))\n\t\treturn -1;\n\tlist_add_tail(&qtd->qtd_list, head);\n\tqtd->urb = urb;\n\n\ttoken = QTD_STS_ACTIVE;\n\ttoken |= (EHCI_TUNE_CERR << 10);\n\n\tlen = urb->transfer_buffer_length;\n\t \n\tif (is_setup) {\n\t\t \n\t\tqtd_fill(ehci, qtd, urb->setup_dma,\n\t\t\t\tsizeof(struct usb_ctrlrequest),\n\t\t\t\tQTD_IOC | token | (2   << 8), 8);\n\n\t\tsubmit_async(ehci, urb, &qtd_list, GFP_ATOMIC);\n\t\treturn 0;  \n\t}\n\n\t \n\ttoken ^= QTD_TOGGLE;    \n\tbuf = urb->transfer_dma;\n\n\ttoken |= (1   << 8);   \n\n\tmaxpacket = usb_endpoint_maxp(&urb->ep->desc);\n\n\tqtd_fill(ehci, qtd, buf, len, token, maxpacket);\n\n\t \n\tqtd->hw_alt_next = EHCI_LIST_END(ehci);\n\n\t \n\ttoken ^= 0x0100;         \n\ttoken |= QTD_TOGGLE;     \n\n\tqtd_prev = qtd;\n\tqtd = ehci_qtd_alloc(ehci, GFP_ATOMIC);\n\tif (unlikely(!qtd))\n\t\tgoto cleanup;\n\tqtd->urb = urb;\n\tqtd_prev->hw_next = QTD_NEXT(ehci, qtd->qtd_dma);\n\tlist_add_tail(&qtd->qtd_list, head);\n\n\t \n\tqtd_fill(ehci, qtd, 0, 0, token | QTD_IOC, 0);\n\n\tsubmit_async(ehci, urb, &qtd_list, GFP_KERNEL);\n\n\treturn 0;\n\ncleanup:\n\tqtd_list_free(ehci, urb, head);\n\treturn -1;\n}\n#endif  \n\n \n\nstatic void single_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tstruct ehci_qh\t\t*prev;\n\n\t \n\tqh->qh_state = QH_STATE_UNLINK_WAIT;\n\tlist_add_tail(&qh->unlink_node, &ehci->async_unlink);\n\n\t \n\tprev = ehci->async;\n\twhile (prev->qh_next.qh != qh)\n\t\tprev = prev->qh_next.qh;\n\n\tprev->hw->hw_next = qh->hw->hw_next;\n\tprev->qh_next = qh->qh_next;\n\tif (ehci->qh_scan_next == qh)\n\t\tehci->qh_scan_next = qh->qh_next.qh;\n}\n\nstatic void start_iaa_cycle(struct ehci_hcd *ehci)\n{\n\t \n\tif (unlikely(ehci->rh_state < EHCI_RH_RUNNING)) {\n\t\tend_unlink_async(ehci);\n\n\t \n\t} else if (ehci->rh_state == EHCI_RH_RUNNING &&\n\t\t\t!ehci->iaa_in_progress) {\n\n\t\t \n\t\twmb();\n\n\t\tehci_writel(ehci, ehci->command | CMD_IAAD,\n\t\t\t\t&ehci->regs->command);\n\t\tehci_readl(ehci, &ehci->regs->command);\n\t\tehci->iaa_in_progress = true;\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_IAA_WATCHDOG, true);\n\t}\n}\n\nstatic void end_iaa_cycle(struct ehci_hcd *ehci)\n{\n\tif (ehci->has_synopsys_hc_bug)\n\t\tehci_writel(ehci, (u32) ehci->async->qh_dma,\n\t\t\t    &ehci->regs->async_next);\n\n\t \n\tehci->iaa_in_progress = false;\n\n\tend_unlink_async(ehci);\n}\n\n \n\nstatic void end_unlink_async(struct ehci_hcd *ehci)\n{\n\tstruct ehci_qh\t\t*qh;\n\tbool\t\t\tearly_exit;\n\n\tif (list_empty(&ehci->async_unlink))\n\t\treturn;\n\tqh = list_first_entry(&ehci->async_unlink, struct ehci_qh,\n\t\t\tunlink_node);\t \n\n\t \n\tearly_exit = ehci->async_unlinking;\n\n\t \n\tif (ehci->rh_state < EHCI_RH_RUNNING)\n\t\tlist_splice_tail_init(&ehci->async_unlink, &ehci->async_idle);\n\n\t \n\telse if (qh->qh_state == QH_STATE_UNLINK) {\n\t\t \n\t\tlist_move_tail(&qh->unlink_node, &ehci->async_idle);\n\t}\n\n\t \n\n\t \n\telse if (qh->unlink_reason & (QH_UNLINK_HALTED |\n\t\t\tQH_UNLINK_SHORT_READ | QH_UNLINK_DUMMY_OVERLAY))\n\t\tgoto DelayDone;\n\n\t \n\telse if\t((qh->unlink_reason & QH_UNLINK_QUEUE_EMPTY) &&\n\t\t\tlist_empty(&qh->qtd_list))\n\t\tgoto DelayDone;\n\n\t \n\telse if\t(qh->hw->hw_token & cpu_to_hc32(ehci, QTD_STS_HALT))\n\t\tgoto DelayDone;\n\n\t \n\telse {\n\t\t__hc32\t\tqh_current, qh_token;\n\n\t\tqh_current = qh->hw->hw_current;\n\t\tqh_token = qh->hw->hw_token;\n\t\tif (qh_current != ehci->old_current ||\n\t\t\t\tqh_token != ehci->old_token) {\n\t\t\tehci->old_current = qh_current;\n\t\t\tehci->old_token = qh_token;\n\t\t\tehci_enable_event(ehci,\n\t\t\t\t\tEHCI_HRTIMER_ACTIVE_UNLINK, true);\n\t\t\treturn;\n\t\t}\n DelayDone:\n\t\tqh->qh_state = QH_STATE_UNLINK;\n\t\tearly_exit = true;\n\t}\n\tehci->old_current = ~0;\t\t \n\n\t \n\tif (!list_empty(&ehci->async_unlink))\n\t\tstart_iaa_cycle(ehci);\n\n\t \n\tif (early_exit)\n\t\treturn;\n\n\t \n\tehci->async_unlinking = true;\n\twhile (!list_empty(&ehci->async_idle)) {\n\t\tqh = list_first_entry(&ehci->async_idle, struct ehci_qh,\n\t\t\t\tunlink_node);\n\t\tlist_del(&qh->unlink_node);\n\n\t\tqh->qh_state = QH_STATE_IDLE;\n\t\tqh->qh_next.qh = NULL;\n\n\t\tif (!list_empty(&qh->qtd_list))\n\t\t\tqh_completions(ehci, qh);\n\t\tif (!list_empty(&qh->qtd_list) &&\n\t\t\t\tehci->rh_state == EHCI_RH_RUNNING)\n\t\t\tqh_link_async(ehci, qh);\n\t\tdisable_async(ehci);\n\t}\n\tehci->async_unlinking = false;\n}\n\nstatic void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh);\n\nstatic void unlink_empty_async(struct ehci_hcd *ehci)\n{\n\tstruct ehci_qh\t\t*qh;\n\tstruct ehci_qh\t\t*qh_to_unlink = NULL;\n\tint\t\t\tcount = 0;\n\n\t \n\tfor (qh = ehci->async->qh_next.qh; qh; qh = qh->qh_next.qh) {\n\t\tif (list_empty(&qh->qtd_list) &&\n\t\t\t\tqh->qh_state == QH_STATE_LINKED) {\n\t\t\t++count;\n\t\t\tif (qh->unlink_cycle != ehci->async_unlink_cycle)\n\t\t\t\tqh_to_unlink = qh;\n\t\t}\n\t}\n\n\t \n\tif (list_empty(&ehci->async_unlink) && qh_to_unlink) {\n\t\tqh_to_unlink->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;\n\t\tstart_unlink_async(ehci, qh_to_unlink);\n\t\t--count;\n\t}\n\n\t \n\tif (count > 0) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);\n\t\t++ehci->async_unlink_cycle;\n\t}\n}\n\n#ifdef\tCONFIG_PM\n\n \nstatic void unlink_empty_async_suspended(struct ehci_hcd *ehci)\n{\n\tstruct ehci_qh\t\t*qh;\n\n\twhile (ehci->async->qh_next.qh) {\n\t\tqh = ehci->async->qh_next.qh;\n\t\tWARN_ON(!list_empty(&qh->qtd_list));\n\t\tsingle_unlink_async(ehci, qh);\n\t}\n}\n\n#endif\n\n \n \n\nstatic void start_unlink_async(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\t \n\tif (qh->qh_state != QH_STATE_LINKED)\n\t\treturn;\n\n\tsingle_unlink_async(ehci, qh);\n\tstart_iaa_cycle(ehci);\n}\n\n \n\nstatic void scan_async (struct ehci_hcd *ehci)\n{\n\tstruct ehci_qh\t\t*qh;\n\tbool\t\t\tcheck_unlinks_later = false;\n\n\tehci->qh_scan_next = ehci->async->qh_next.qh;\n\twhile (ehci->qh_scan_next) {\n\t\tqh = ehci->qh_scan_next;\n\t\tehci->qh_scan_next = qh->qh_next.qh;\n\n\t\t \n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tint temp;\n\n\t\t\t \n\t\t\ttemp = qh_completions(ehci, qh);\n\t\t\tif (unlikely(temp)) {\n\t\t\t\tstart_unlink_async(ehci, qh);\n\t\t\t} else if (list_empty(&qh->qtd_list)\n\t\t\t\t\t&& qh->qh_state == QH_STATE_LINKED) {\n\t\t\t\tqh->unlink_cycle = ehci->async_unlink_cycle;\n\t\t\t\tcheck_unlinks_later = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (check_unlinks_later && ehci->rh_state == EHCI_RH_RUNNING &&\n\t\t\t!(ehci->enabled_hrtimer_events &\n\t\t\t\tBIT(EHCI_HRTIMER_ASYNC_UNLINKS))) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_ASYNC_UNLINKS, true);\n\t\t++ehci->async_unlink_cycle;\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}