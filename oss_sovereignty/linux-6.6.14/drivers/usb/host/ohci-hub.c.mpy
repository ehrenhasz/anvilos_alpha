{
  "module_name": "ohci-hub.c",
  "hash_id": "6f15fe2078ac02a18cc1cc0ae5240c2c5d2078ff04a489b4d92c0cdc6eece692",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-hub.c",
  "human_readable_source": "\n \n\n \n\n \n\n#define dbg_port(hc,label,num,value) \\\n\tohci_dbg (hc, \\\n\t\t\"%s roothub.portstatus [%d] \" \\\n\t\t\"= 0x%08x%s%s%s%s%s%s%s%s%s%s%s%s\\n\", \\\n\t\tlabel, num, value, \\\n\t\t(value & RH_PS_PRSC) ? \" PRSC\" : \"\", \\\n\t\t(value & RH_PS_OCIC) ? \" OCIC\" : \"\", \\\n\t\t(value & RH_PS_PSSC) ? \" PSSC\" : \"\", \\\n\t\t(value & RH_PS_PESC) ? \" PESC\" : \"\", \\\n\t\t(value & RH_PS_CSC) ? \" CSC\" : \"\", \\\n\t\t\\\n\t\t(value & RH_PS_LSDA) ? \" LSDA\" : \"\", \\\n\t\t(value & RH_PS_PPS) ? \" PPS\" : \"\", \\\n\t\t(value & RH_PS_PRS) ? \" PRS\" : \"\", \\\n\t\t(value & RH_PS_POCI) ? \" POCI\" : \"\", \\\n\t\t(value & RH_PS_PSS) ? \" PSS\" : \"\", \\\n\t\t\\\n\t\t(value & RH_PS_PES) ? \" PES\" : \"\", \\\n\t\t(value & RH_PS_CCS) ? \" CCS\" : \"\" \\\n\t\t);\n\n \n\n#define OHCI_SCHED_ENABLES \\\n\t(OHCI_CTRL_CLE|OHCI_CTRL_BLE|OHCI_CTRL_PLE|OHCI_CTRL_IE)\n\nstatic void update_done_list(struct ohci_hcd *);\nstatic void ohci_work(struct ohci_hcd *);\n\n#ifdef\tCONFIG_PM\nstatic int ohci_rh_suspend (struct ohci_hcd *ohci, int autostop)\n__releases(ohci->lock)\n__acquires(ohci->lock)\n{\n\tint\t\t\tstatus = 0;\n\n\tohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\n\tswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_RESUME:\n\t\tohci_dbg (ohci, \"resume/suspend?\\n\");\n\t\tohci->hc_control &= ~OHCI_CTRL_HCFS;\n\t\tohci->hc_control |= OHCI_USB_RESET;\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t\tfallthrough;\n\tcase OHCI_USB_RESET:\n\t\tstatus = -EBUSY;\n\t\tohci_dbg (ohci, \"needs reinit!\\n\");\n\t\tgoto done;\n\tcase OHCI_USB_SUSPEND:\n\t\tif (!ohci->autostop) {\n\t\t\tohci_dbg (ohci, \"already suspended\\n\");\n\t\t\tgoto done;\n\t\t}\n\t}\n\tohci_dbg (ohci, \"%s root hub\\n\",\n\t\t\tautostop ? \"auto-stop\" : \"suspend\");\n\n\t \n\tif (!autostop && (ohci->hc_control & OHCI_SCHED_ENABLES)) {\n\t\tohci->hc_control &= ~OHCI_SCHED_ENABLES;\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\tohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\n\t\tohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);\n\n\t\t \n\t\tohci_dbg (ohci, \"stopping schedules ...\\n\");\n\t\tohci->autostop = 0;\n\t\tspin_unlock_irq (&ohci->lock);\n\t\tmsleep (8);\n\t\tspin_lock_irq (&ohci->lock);\n\t}\n\tupdate_done_list(ohci);\n\tohci_work(ohci);\n\n\t \n\tohci_writel(ohci, OHCI_INTR_SF, &ohci->regs->intrdisable);\n\n\t \n\tif (ohci->flags & OHCI_QUIRK_GLOBAL_SUSPEND) {\n\t\t__hc32 __iomem\t*portstat = ohci->regs->roothub.portstatus;\n\t\tint\t\ti;\n\t\tunsigned\ttemp;\n\n\t\tfor (i = 0; i < ohci->num_ports; (++i, ++portstat)) {\n\t\t\ttemp = ohci_readl(ohci, portstat);\n\t\t\tif ((temp & (RH_PS_PES | RH_PS_PSS)) ==\n\t\t\t\t\tRH_PS_PES)\n\t\t\t\tohci_writel(ohci, RH_PS_PSS, portstat);\n\t\t}\n\t}\n\n\t \n\tif (ohci_to_hcd(ohci)->self.root_hub->do_remote_wakeup || autostop) {\n\t\tohci->hc_control |= OHCI_CTRL_RWE;\n\t} else {\n\t\tohci_writel(ohci, OHCI_INTR_RHSC | OHCI_INTR_RD,\n\t\t\t\t&ohci->regs->intrdisable);\n\t\tohci->hc_control &= ~OHCI_CTRL_RWE;\n\t}\n\n\t \n\tohci->hc_control &= ~OHCI_CTRL_HCFS;\n\tohci->hc_control |= OHCI_USB_SUSPEND;\n\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\n\t \n\tif (!autostop) {\n\t\tohci->next_statechange = jiffies + msecs_to_jiffies (5);\n\t\tohci->autostop = 0;\n\t\tohci->rh_state = OHCI_RH_SUSPENDED;\n\t}\n\ndone:\n\treturn status;\n}\n\nstatic inline struct ed *find_head (struct ed *ed)\n{\n\t \n\twhile (ed->ed_prev)\n\t\ted = ed->ed_prev;\n\treturn ed;\n}\n\n \nstatic int ohci_rh_resume (struct ohci_hcd *ohci)\n__releases(ohci->lock)\n__acquires(ohci->lock)\n{\n\tstruct usb_hcd\t\t*hcd = ohci_to_hcd (ohci);\n\tu32\t\t\ttemp, enables;\n\tint\t\t\tstatus = -EINPROGRESS;\n\tint\t\t\tautostopped = ohci->autostop;\n\n\tohci->autostop = 0;\n\tohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\n\n\tif (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {\n\t\t \n\t\tif (ohci->rh_state != OHCI_RH_RUNNING) {\n\t\t\tohci_dbg (ohci, \"BIOS/SMM active, control %03x\\n\",\n\t\t\t\t\tohci->hc_control);\n\t\t\tstatus = -EBUSY;\n\t\t \n\t\t} else {\n\t\t\tohci_dbg (ohci, \"duplicate resume\\n\");\n\t\t\tstatus = 0;\n\t\t}\n\t} else switch (ohci->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_SUSPEND:\n\t\tohci->hc_control &= ~(OHCI_CTRL_HCFS|OHCI_SCHED_ENABLES);\n\t\tohci->hc_control |= OHCI_USB_RESUME;\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t\tohci_dbg (ohci, \"%s root hub\\n\",\n\t\t\t\tautostopped ? \"auto-start\" : \"resume\");\n\t\tbreak;\n\tcase OHCI_USB_RESUME:\n\t\t \n\t\tohci_dbg(ohci, \"%swakeup root hub\\n\",\n\t\t\t\tautostopped ? \"auto-\" : \"\");\n\t\tbreak;\n\tcase OHCI_USB_OPER:\n\t\t \n\t\tohci_dbg (ohci, \"snapshot resume? reinit\\n\");\n\t\tstatus = -EBUSY;\n\t\tbreak;\n\tdefault:\t\t \n\t\tohci_dbg (ohci, \"lost power\\n\");\n\t\tstatus = -EBUSY;\n\t}\n\tif (status == -EBUSY) {\n\t\tif (!autostopped) {\n\t\t\tspin_unlock_irq (&ohci->lock);\n\t\t\tstatus = ohci_restart (ohci);\n\n\t\t\tusb_root_hub_lost_power(hcd->self.root_hub);\n\n\t\t\tspin_lock_irq (&ohci->lock);\n\t\t}\n\t\treturn status;\n\t}\n\tif (status != -EINPROGRESS)\n\t\treturn status;\n\tif (autostopped)\n\t\tgoto skip_resume;\n\tspin_unlock_irq (&ohci->lock);\n\n\t \n\tmsleep (20   + 12   + 1);\n\n\ttemp = ohci_readl (ohci, &ohci->regs->control);\n\ttemp &= OHCI_CTRL_HCFS;\n\tif (temp != OHCI_USB_RESUME) {\n\t\tohci_err (ohci, \"controller won't resume\\n\");\n\t\tspin_lock_irq(&ohci->lock);\n\t\treturn -EBUSY;\n\t}\n\n\t \n\tohci_writel (ohci, 0, &ohci->regs->ed_controlhead);\n\tohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);\n\tohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);\n\tohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);\n\tohci_writel (ohci, 0, &ohci->regs->ed_periodcurrent);\n\tohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);\n\n\t \n\tperiodic_reinit (ohci);\n\n\t \nskip_resume:\n\t \n\tohci_writel (ohci, OHCI_INTR_INIT, &ohci->regs->intrenable);\n\tif (ohci->ed_rm_list)\n\t\tohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);\n\n\t \n\tohci_writel (ohci, OHCI_USB_OPER, &ohci->regs->control);\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\tif (!autostopped)\n\t\tmsleep (3);\n\n\ttemp = ohci->hc_control;\n\ttemp &= OHCI_CTRL_RWC;\n\ttemp |= OHCI_CONTROL_INIT | OHCI_USB_OPER;\n\tohci->hc_control = temp;\n\tohci_writel (ohci, temp, &ohci->regs->control);\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\n\t \n\tif (!autostopped) {\n\t\tmsleep (10);\n\t\tspin_lock_irq (&ohci->lock);\n\t}\n\t \n\n\t \n\tohci->next_statechange = jiffies + STATECHANGE_DELAY;\n\n\t \n\tenables = 0;\n\ttemp = 0;\n\tif (!ohci->ed_rm_list) {\n\t\tif (ohci->ed_controltail) {\n\t\t\tohci_writel (ohci,\n\t\t\t\t\tfind_head (ohci->ed_controltail)->dma,\n\t\t\t\t\t&ohci->regs->ed_controlhead);\n\t\t\tenables |= OHCI_CTRL_CLE;\n\t\t\ttemp |= OHCI_CLF;\n\t\t}\n\t\tif (ohci->ed_bulktail) {\n\t\t\tohci_writel (ohci, find_head (ohci->ed_bulktail)->dma,\n\t\t\t\t&ohci->regs->ed_bulkhead);\n\t\t\tenables |= OHCI_CTRL_BLE;\n\t\t\ttemp |= OHCI_BLF;\n\t\t}\n\t}\n\tif (hcd->self.bandwidth_isoc_reqs || hcd->self.bandwidth_int_reqs)\n\t\tenables |= OHCI_CTRL_PLE|OHCI_CTRL_IE;\n\tif (enables) {\n\t\tohci_dbg (ohci, \"restarting schedules ... %08x\\n\", enables);\n\t\tohci->hc_control |= enables;\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\tif (temp)\n\t\t\tohci_writel (ohci, temp, &ohci->regs->cmdstatus);\n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t}\n\n\tohci->rh_state = OHCI_RH_RUNNING;\n\treturn 0;\n}\n\nstatic int ohci_bus_suspend (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\tint\t\t\trc;\n\n\tspin_lock_irq (&ohci->lock);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\n\t\trc = -ESHUTDOWN;\n\telse\n\t\trc = ohci_rh_suspend (ohci, 0);\n\tspin_unlock_irq (&ohci->lock);\n\n\tif (rc == 0) {\n\t\tdel_timer_sync(&ohci->io_watchdog);\n\t\tohci->prev_frame_no = IO_WATCHDOG_OFF;\n\t}\n\treturn rc;\n}\n\nstatic int ohci_bus_resume (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\tint\t\t\trc;\n\n\tif (time_before (jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\n\tspin_lock_irq (&ohci->lock);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\n\t\trc = -ESHUTDOWN;\n\telse\n\t\trc = ohci_rh_resume (ohci);\n\tspin_unlock_irq (&ohci->lock);\n\n\t \n\tif (rc == 0)\n\t\tusb_hcd_poll_rh_status(hcd);\n\treturn rc;\n}\n\n \nstatic int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,\n\t\tint any_connected, int rhsc_status)\n{\n\tint\tpoll_rh = 1;\n\tint\trhsc_enable;\n\n\t \n\trhsc_enable = ohci_readl(ohci, &ohci->regs->intrenable) &\n\t\t\tOHCI_INTR_RHSC;\n\n\tswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_OPER:\n\t\t \n\t\tif (!rhsc_enable && !rhsc_status && !changed) {\n\t\t\trhsc_enable = OHCI_INTR_RHSC;\n\t\t\tohci_writel(ohci, rhsc_enable, &ohci->regs->intrenable);\n\t\t}\n\n\t\t \n\t\tif (!ohci->autostop) {\n\t\t\tif (any_connected ||\n\t\t\t\t\t!device_may_wakeup(&ohci_to_hcd(ohci)\n\t\t\t\t\t\t->self.root_hub->dev)) {\n\t\t\t\tif (rhsc_enable)\n\t\t\t\t\tpoll_rh = 0;\n\t\t\t} else {\n\t\t\t\tohci->autostop = 1;\n\t\t\t\tohci->next_statechange = jiffies + HZ;\n\t\t\t}\n\n\t\t \n\t\t} else {\n\t\t\tif (changed || any_connected) {\n\t\t\t\tohci->autostop = 0;\n\t\t\t\tohci->next_statechange = jiffies +\n\t\t\t\t\t\tSTATECHANGE_DELAY;\n\t\t\t} else if (time_after_eq(jiffies,\n\t\t\t\t\t\tohci->next_statechange)\n\t\t\t\t\t&& !ohci->ed_rm_list\n\t\t\t\t\t&& !(ohci->hc_control &\n\t\t\t\t\t\tOHCI_SCHED_ENABLES)) {\n\t\t\t\tohci_rh_suspend(ohci, 1);\n\t\t\t\tif (rhsc_enable)\n\t\t\t\t\tpoll_rh = 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\n\tcase OHCI_USB_SUSPEND:\n\tcase OHCI_USB_RESUME:\n\t\t \n\t\tif (changed) {\n\t\t\tif (ohci->autostop)\n\t\t\t\tohci_rh_resume(ohci);\n\t\t\telse\n\t\t\t\tusb_hcd_resume_root_hub(ohci_to_hcd(ohci));\n\n\t\t \n\t\t} else if (!ohci->autostop &&\n\t\t\t\t!ohci_to_hcd(ohci)->self.root_hub->\n\t\t\t\t\tdo_remote_wakeup) {\n\t\t\tpoll_rh = 0;\n\n\t\t} else {\n\t\t\t \n\t\t\tif (!rhsc_enable && !rhsc_status) {\n\t\t\t\trhsc_enable = OHCI_INTR_RHSC;\n\t\t\t\tohci_writel(ohci, rhsc_enable,\n\t\t\t\t\t\t&ohci->regs->intrenable);\n\t\t\t}\n\t\t\t \n\t\t\tif (rhsc_enable)\n\t\t\t\tpoll_rh = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn poll_rh;\n}\n\n#else\t \n\nstatic inline int ohci_rh_resume(struct ohci_hcd *ohci)\n{\n\treturn 0;\n}\n\n \nstatic int ohci_root_hub_state_changes(struct ohci_hcd *ohci, int changed,\n\t\tint any_connected, int rhsc_status)\n{\n\t \n\tif (ohci_readl(ohci, &ohci->regs->intrenable) & OHCI_INTR_RHSC)\n\t\treturn 0;\n\n\t \n\tif (changed || rhsc_status)\n\t\treturn 1;\n\n\t \n\tohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrenable);\n\treturn 0;\n}\n\n#endif\t \n\n \n\n \n\nint ohci_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tint\t\ti, changed = 0, length = 1;\n\tint\t\tany_connected = 0;\n\tint\t\trhsc_status;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave (&ohci->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\tgoto done;\n\n\t \n\tif ((ohci->flags & OHCI_QUIRK_AMD756)\n\t\t\t&& (roothub_a (ohci) & RH_A_NDP) > MAX_ROOT_PORTS) {\n\t\tohci_warn (ohci, \"bogus NDP, rereads as NDP=%d\\n\",\n\t\t\t  ohci_readl (ohci, &ohci->regs->roothub.a) & RH_A_NDP);\n\t\t \n\t\tgoto done;\n\t}\n\n\t \n\tif (roothub_status (ohci) & (RH_HS_LPSC | RH_HS_OCIC))\n\t\tbuf [0] = changed = 1;\n\telse\n\t\tbuf [0] = 0;\n\tif (ohci->num_ports > 7) {\n\t\tbuf [1] = 0;\n\t\tlength++;\n\t}\n\n\t \n\tohci_writel(ohci, OHCI_INTR_RHSC, &ohci->regs->intrstatus);\n\trhsc_status = ohci_readl(ohci, &ohci->regs->intrstatus) &\n\t\t\tOHCI_INTR_RHSC;\n\n\t \n\tfor (i = 0; i < ohci->num_ports; i++) {\n\t\tu32\tstatus = roothub_portstatus (ohci, i);\n\n\t\t \n\t\tany_connected |= (status & RH_PS_CCS);\n\n\t\tif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC\n\t\t\t\t| RH_PS_OCIC | RH_PS_PRSC)) {\n\t\t\tchanged = 1;\n\t\t\tif (i < 7)\n\t\t\t    buf [0] |= 1 << (i + 1);\n\t\t\telse\n\t\t\t    buf [1] |= 1 << (i - 7);\n\t\t}\n\t}\n\n\tif (ohci_root_hub_state_changes(ohci, changed,\n\t\t\tany_connected, rhsc_status))\n\t\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\telse\n\t\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\n\ndone:\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\n\treturn changed ? length : 0;\n}\nEXPORT_SYMBOL_GPL(ohci_hub_status_data);\n\n \n\nstatic void\nohci_hub_descriptor (\n\tstruct ohci_hcd\t\t\t*ohci,\n\tstruct usb_hub_descriptor\t*desc\n) {\n\tu32\t\trh = roothub_a (ohci);\n\tu16\t\ttemp;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bPwrOn2PwrGood = (rh & RH_A_POTPGT) >> 24;\n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ohci->num_ports;\n\ttemp = 1 + (ohci->num_ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\ttemp = HUB_CHAR_COMMON_LPSM | HUB_CHAR_COMMON_OCPM;\n\tif (rh & RH_A_NPS)\t\t \n\t\ttemp |= HUB_CHAR_NO_LPSM;\n\tif (rh & RH_A_PSM)\t\t \n\t\ttemp |= HUB_CHAR_INDV_PORT_LPSM;\n\tif (rh & RH_A_NOCP)\t\t \n\t\ttemp |= HUB_CHAR_NO_OCPM;\n\telse if (rh & RH_A_OCPM)\t \n\t\ttemp |= HUB_CHAR_INDV_PORT_OCPM;\n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n\n\t \n\trh = roothub_b (ohci);\n\tmemset(desc->u.hs.DeviceRemovable, 0xff,\n\t\t\tsizeof(desc->u.hs.DeviceRemovable));\n\tdesc->u.hs.DeviceRemovable[0] = rh & RH_B_DR;\n\tif (ohci->num_ports > 7) {\n\t\tdesc->u.hs.DeviceRemovable[1] = (rh & RH_B_DR) >> 8;\n\t\tdesc->u.hs.DeviceRemovable[2] = 0xff;\n\t} else\n\t\tdesc->u.hs.DeviceRemovable[1] = 0xff;\n}\n\n \n\n#ifdef\tCONFIG_USB_OTG\n\nstatic int ohci_start_port_reset (struct usb_hcd *hcd, unsigned port)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tu32\t\t\tstatus;\n\n\tif (!port)\n\t\treturn -EINVAL;\n\tport--;\n\n\t \n\tstatus = ohci_readl(ohci, &ohci->regs->roothub.portstatus [port]);\n\tif (!(status & RH_PS_CCS))\n\t\treturn -ENODEV;\n\n\t \n\tohci_writel(ohci, RH_PS_PRS, &ohci->regs->roothub.portstatus [port]);\n\treturn 0;\n}\n\n#else\n\n#define\tohci_start_port_reset\t\tNULL\n\n#endif\n\n \n\n\n \n#define\tPORT_RESET_MSEC\t\t50\n\n \n#define\tPORT_RESET_HW_MSEC\t10\n\n \n#define tick_before(t1,t2) ((s16)(((s16)(t1))-((s16)(t2))) < 0)\n\n \nstatic inline int root_port_reset (struct ohci_hcd *ohci, unsigned port)\n{\n\t__hc32 __iomem *portstat = &ohci->regs->roothub.portstatus [port];\n\tu32\ttemp = 0;\n\tu16\tnow = ohci_readl(ohci, &ohci->regs->fmnumber);\n\tu16\treset_done = now + PORT_RESET_MSEC;\n\tint\tlimit_1 = DIV_ROUND_UP(PORT_RESET_MSEC, PORT_RESET_HW_MSEC);\n\n\t \n\tdo {\n\t\tint limit_2;\n\n\t\t \n\t\tlimit_2 = PORT_RESET_HW_MSEC * 2;\n\t\twhile (--limit_2 >= 0) {\n\t\t\ttemp = ohci_readl (ohci, portstat);\n\t\t\t \n\t\t\tif (temp == ~(u32)0)\n\t\t\t\treturn -ESHUTDOWN;\n\t\t\tif (!(temp & RH_PS_PRS))\n\t\t\t\tbreak;\n\t\t\tudelay (500);\n\t\t}\n\n\t\t \n\t\tif (limit_2 < 0) {\n\t\t\tohci_dbg(ohci,\n\t\t\t\t\"port[%d] reset timeout, stat %08x\\n\",\n\t\t\t\tport, temp);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!(temp & RH_PS_CCS))\n\t\t\tbreak;\n\t\tif (temp & RH_PS_PRSC)\n\t\t\tohci_writel (ohci, RH_PS_PRSC, portstat);\n\n\t\t \n\t\tohci_writel (ohci, RH_PS_PRS, portstat);\n\t\tmsleep(PORT_RESET_HW_MSEC);\n\t\tnow = ohci_readl(ohci, &ohci->regs->fmnumber);\n\t} while (tick_before(now, reset_done) && --limit_1 >= 0);\n\n\t \n\n\treturn 0;\n}\n\nint ohci_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength\n) {\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tint\t\tports = ohci->num_ports;\n\tu32\t\ttemp;\n\tint\t\tretval = 0;\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(hcd)))\n\t\treturn -ESHUTDOWN;\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\tohci_writel (ohci, RH_HS_OCIC,\n\t\t\t\t\t&ohci->regs->roothub.status);\n\t\t\tbreak;\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\ttemp = RH_PS_CCS;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\ttemp = RH_PS_PESC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\ttemp = RH_PS_POCI;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\ttemp = RH_PS_PSSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\ttemp = RH_PS_LSDA;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\ttemp = RH_PS_CSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\ttemp = RH_PS_OCIC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\ttemp = RH_PS_PRSC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tohci_writel (ohci, temp,\n\t\t\t\t&ohci->regs->roothub.portstatus [wIndex]);\n\t\t\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tohci_hub_descriptor (ohci, (struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\ttemp = roothub_status (ohci) & ~(RH_HS_CRWE | RH_HS_DRWE);\n\t\tput_unaligned_le32(temp, buf);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = roothub_portstatus (ohci, wIndex);\n\t\tput_unaligned_le32(temp, buf);\n\n\t\tif (*(u16*)(buf+2))\t \n\t\t\tdbg_port(ohci, \"GetStatus\", wIndex, temp);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n#ifdef\tCONFIG_USB_OTG\n\t\t\tif (hcd->self.otg_port == (wIndex + 1)\n\t\t\t\t\t&& hcd->self.b_hnp_enable)\n\t\t\t\tohci->start_hnp(ohci);\n\t\t\telse\n#endif\n\t\t\tohci_writel (ohci, RH_PS_PSS,\n\t\t\t\t&ohci->regs->roothub.portstatus [wIndex]);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tohci_writel (ohci, RH_PS_PPS,\n\t\t\t\t&ohci->regs->roothub.portstatus [wIndex]);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tretval = root_port_reset (ohci, wIndex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(ohci_hub_control);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}