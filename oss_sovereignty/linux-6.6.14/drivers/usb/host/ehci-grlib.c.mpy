{
  "module_name": "ehci-grlib.c",
  "hash_id": "a0bd96cf512a121a4c3fc06e1fa6d1920767e02c0ac0901e586d01e51713afc6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-grlib.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/signal.h>\n\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\n#define GRUSBHC_HCIVERSION 0x0100  \n\nstatic const struct hc_driver ehci_grlib_hc_driver = {\n\t.description\t\t= hcd_name,\n\t.product_desc\t\t= \"GRLIB GRUSBHC EHCI\",\n\t.hcd_priv_size\t\t= sizeof(struct ehci_hcd),\n\n\t \n\t.irq\t\t\t= ehci_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n\t \n\t.reset\t\t\t= ehci_setup,\n\t.start\t\t\t= ehci_run,\n\t.stop\t\t\t= ehci_stop,\n\t.shutdown\t\t= ehci_shutdown,\n\n\t \n\t.urb_enqueue\t\t= ehci_urb_enqueue,\n\t.urb_dequeue\t\t= ehci_urb_dequeue,\n\t.endpoint_disable\t= ehci_endpoint_disable,\n\t.endpoint_reset\t\t= ehci_endpoint_reset,\n\n\t \n\t.get_frame_number\t= ehci_get_frame,\n\n\t \n\t.hub_status_data\t= ehci_hub_status_data,\n\t.hub_control\t\t= ehci_hub_control,\n#ifdef\tCONFIG_PM\n\t.bus_suspend\t\t= ehci_bus_suspend,\n\t.bus_resume\t\t= ehci_bus_resume,\n#endif\n\t.relinquish_port\t= ehci_relinquish_port,\n\t.port_handed_over\t= ehci_port_handed_over,\n\n\t.clear_tt_buffer_complete\t= ehci_clear_tt_buffer_complete,\n};\n\n\nstatic int ehci_hcd_grlib_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd\t*ehci = NULL;\n\tstruct resource res;\n\tu32 hc_capbase;\n\tint irq;\n\tint rv;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdev_dbg(&op->dev, \"initializing GRUSBHC EHCI USB Controller\\n\");\n\n\trv = of_address_to_resource(dn, 0, &res);\n\tif (rv)\n\t\treturn rv;\n\n\t \n\top->dev.dma_mask = &op->dev.coherent_dma_mask;\n\thcd = usb_create_hcd(&ehci_grlib_hc_driver, &op->dev,\n\t\t\t\"GRUSBHC EHCI USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = res.start;\n\thcd->rsrc_len = resource_size(&res);\n\n\tirq = irq_of_parse_and_map(dn, 0);\n\tif (!irq) {\n\t\tdev_err(&op->dev, \"%s: irq_of_parse_and_map failed\\n\",\n\t\t\t__FILE__);\n\t\trv = -EBUSY;\n\t\tgoto err_irq;\n\t}\n\n\thcd->regs = devm_ioremap_resource(&op->dev, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\trv = PTR_ERR(hcd->regs);\n\t\tgoto err_ioremap;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\n\tehci->caps = hcd->regs;\n\n\t \n\thc_capbase = ehci_readl(ehci, &ehci->caps->hc_capbase);\n\tif (HC_VERSION(ehci, hc_capbase) != GRUSBHC_HCIVERSION) {\n\t\tehci->big_endian_mmio = 1;\n\t\tehci->big_endian_desc = 1;\n\t\tehci->big_endian_capbase = 1;\n\t}\n\n\trv = usb_add_hcd(hcd, irq, 0);\n\tif (rv)\n\t\tgoto err_ioremap;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\nerr_ioremap:\n\tirq_dispose_mapping(irq);\nerr_irq:\n\tusb_put_hcd(hcd);\n\n\treturn rv;\n}\n\n\nstatic void ehci_hcd_grlib_remove(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\n\tdev_dbg(&op->dev, \"stopping GRLIB GRUSBHC EHCI USB Controller\\n\");\n\n\tusb_remove_hcd(hcd);\n\n\tirq_dispose_mapping(hcd->irq);\n\n\tusb_put_hcd(hcd);\n}\n\n\nstatic const struct of_device_id ehci_hcd_grlib_of_match[] = {\n\t{\n\t\t.name = \"GAISLER_EHCI\",\n\t },\n\t{\n\t\t.name = \"01_026\",\n\t },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehci_hcd_grlib_of_match);\n\n\nstatic struct platform_driver ehci_grlib_driver = {\n\t.probe\t\t= ehci_hcd_grlib_probe,\n\t.remove_new\t= ehci_hcd_grlib_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name = \"grlib-ehci\",\n\t\t.of_match_table = ehci_hcd_grlib_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}