{
  "module_name": "xhci-dbgtty.c",
  "hash_id": "4ea5af1903b8a1f8b4a7bf630101750ee026adf1e94855edcb5fc93a136ee328",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-dbgtty.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_flip.h>\n#include <linux/idr.h>\n\n#include \"xhci.h\"\n#include \"xhci-dbgcap.h\"\n\nstatic struct tty_driver *dbc_tty_driver;\nstatic struct idr dbc_tty_minors;\nstatic DEFINE_MUTEX(dbc_tty_minors_lock);\n\nstatic inline struct dbc_port *dbc_to_port(struct xhci_dbc *dbc)\n{\n\treturn dbc->priv;\n}\n\nstatic unsigned int\ndbc_send_packet(struct dbc_port *port, char *packet, unsigned int size)\n{\n\tunsigned int\t\tlen;\n\n\tlen = kfifo_len(&port->write_fifo);\n\tif (len < size)\n\t\tsize = len;\n\tif (size != 0)\n\t\tsize = kfifo_out(&port->write_fifo, packet, size);\n\treturn size;\n}\n\nstatic int dbc_start_tx(struct dbc_port *port)\n\t__releases(&port->port_lock)\n\t__acquires(&port->port_lock)\n{\n\tint\t\t\tlen;\n\tstruct dbc_request\t*req;\n\tint\t\t\tstatus = 0;\n\tbool\t\t\tdo_tty_wake = false;\n\tstruct list_head\t*pool = &port->write_pool;\n\n\twhile (!list_empty(pool)) {\n\t\treq = list_entry(pool->next, struct dbc_request, list_pool);\n\t\tlen = dbc_send_packet(port, req->buf, DBC_MAX_PACKET);\n\t\tif (len == 0)\n\t\t\tbreak;\n\t\tdo_tty_wake = true;\n\n\t\treq->length = len;\n\t\tlist_del(&req->list_pool);\n\n\t\tspin_unlock(&port->port_lock);\n\t\tstatus = dbc_ep_queue(req);\n\t\tspin_lock(&port->port_lock);\n\n\t\tif (status) {\n\t\t\tlist_add(&req->list_pool, pool);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (do_tty_wake && port->port.tty)\n\t\ttty_wakeup(port->port.tty);\n\n\treturn status;\n}\n\nstatic void dbc_start_rx(struct dbc_port *port)\n\t__releases(&port->port_lock)\n\t__acquires(&port->port_lock)\n{\n\tstruct dbc_request\t*req;\n\tint\t\t\tstatus;\n\tstruct list_head\t*pool = &port->read_pool;\n\n\twhile (!list_empty(pool)) {\n\t\tif (!port->port.tty)\n\t\t\tbreak;\n\n\t\treq = list_entry(pool->next, struct dbc_request, list_pool);\n\t\tlist_del(&req->list_pool);\n\t\treq->length = DBC_MAX_PACKET;\n\n\t\tspin_unlock(&port->port_lock);\n\t\tstatus = dbc_ep_queue(req);\n\t\tspin_lock(&port->port_lock);\n\n\t\tif (status) {\n\t\t\tlist_add(&req->list_pool, pool);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void\ndbc_read_complete(struct xhci_dbc *dbc, struct dbc_request *req)\n{\n\tunsigned long\t\tflags;\n\tstruct dbc_port\t\t*port = dbc_to_port(dbc);\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tlist_add_tail(&req->list_pool, &port->read_queue);\n\ttasklet_schedule(&port->push);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic void dbc_write_complete(struct xhci_dbc *dbc, struct dbc_request *req)\n{\n\tunsigned long\t\tflags;\n\tstruct dbc_port\t\t*port = dbc_to_port(dbc);\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tlist_add(&req->list_pool, &port->write_pool);\n\tswitch (req->status) {\n\tcase 0:\n\t\tdbc_start_tx(port);\n\t\tbreak;\n\tcase -ESHUTDOWN:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dbc->dev, \"unexpected write complete status %d\\n\",\n\t\t\t  req->status);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic void xhci_dbc_free_req(struct dbc_request *req)\n{\n\tkfree(req->buf);\n\tdbc_free_request(req);\n}\n\nstatic int\nxhci_dbc_alloc_requests(struct xhci_dbc *dbc, unsigned int direction,\n\t\t\tstruct list_head *head,\n\t\t\tvoid (*fn)(struct xhci_dbc *, struct dbc_request *))\n{\n\tint\t\t\ti;\n\tstruct dbc_request\t*req;\n\n\tfor (i = 0; i < DBC_QUEUE_SIZE; i++) {\n\t\treq = dbc_alloc_request(dbc, direction, GFP_KERNEL);\n\t\tif (!req)\n\t\t\tbreak;\n\n\t\treq->length = DBC_MAX_PACKET;\n\t\treq->buf = kmalloc(req->length, GFP_KERNEL);\n\t\tif (!req->buf) {\n\t\t\tdbc_free_request(req);\n\t\t\tbreak;\n\t\t}\n\n\t\treq->complete = fn;\n\t\tlist_add_tail(&req->list_pool, head);\n\t}\n\n\treturn list_empty(head) ? -ENOMEM : 0;\n}\n\nstatic void\nxhci_dbc_free_requests(struct list_head *head)\n{\n\tstruct dbc_request\t*req;\n\n\twhile (!list_empty(head)) {\n\t\treq = list_entry(head->next, struct dbc_request, list_pool);\n\t\tlist_del(&req->list_pool);\n\t\txhci_dbc_free_req(req);\n\t}\n}\n\nstatic int dbc_tty_install(struct tty_driver *driver, struct tty_struct *tty)\n{\n\tstruct dbc_port\t\t*port;\n\n\tmutex_lock(&dbc_tty_minors_lock);\n\tport = idr_find(&dbc_tty_minors, tty->index);\n\tmutex_unlock(&dbc_tty_minors_lock);\n\n\tif (!port)\n\t\treturn -ENXIO;\n\n\ttty->driver_data = port;\n\n\treturn tty_port_install(&port->port, driver, tty);\n}\n\nstatic int dbc_tty_open(struct tty_struct *tty, struct file *file)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\n\treturn tty_port_open(&port->port, tty, file);\n}\n\nstatic void dbc_tty_close(struct tty_struct *tty, struct file *file)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\n\ttty_port_close(&port->port, tty, file);\n}\n\nstatic ssize_t dbc_tty_write(struct tty_struct *tty, const u8 *buf,\n\t\t\t     size_t count)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tif (count)\n\t\tcount = kfifo_in(&port->write_fifo, buf, count);\n\tdbc_start_tx(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn count;\n}\n\nstatic int dbc_tty_put_char(struct tty_struct *tty, u8 ch)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\tint\t\t\tstatus;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tstatus = kfifo_put(&port->write_fifo, ch);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn status;\n}\n\nstatic void dbc_tty_flush_chars(struct tty_struct *tty)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tdbc_start_tx(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic unsigned int dbc_tty_write_room(struct tty_struct *tty)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\tunsigned int\t\troom;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\troom = kfifo_avail(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn room;\n}\n\nstatic unsigned int dbc_tty_chars_in_buffer(struct tty_struct *tty)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\tunsigned int\t\tchars;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tchars = kfifo_len(&port->write_fifo);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn chars;\n}\n\nstatic void dbc_tty_unthrottle(struct tty_struct *tty)\n{\n\tstruct dbc_port\t\t*port = tty->driver_data;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\ttasklet_schedule(&port->push);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic const struct tty_operations dbc_tty_ops = {\n\t.install\t\t= dbc_tty_install,\n\t.open\t\t\t= dbc_tty_open,\n\t.close\t\t\t= dbc_tty_close,\n\t.write\t\t\t= dbc_tty_write,\n\t.put_char\t\t= dbc_tty_put_char,\n\t.flush_chars\t\t= dbc_tty_flush_chars,\n\t.write_room\t\t= dbc_tty_write_room,\n\t.chars_in_buffer\t= dbc_tty_chars_in_buffer,\n\t.unthrottle\t\t= dbc_tty_unthrottle,\n};\n\nstatic void dbc_rx_push(struct tasklet_struct *t)\n{\n\tstruct dbc_request\t*req;\n\tstruct tty_struct\t*tty;\n\tunsigned long\t\tflags;\n\tbool\t\t\tdo_push = false;\n\tbool\t\t\tdisconnect = false;\n\tstruct dbc_port\t\t*port = from_tasklet(port, t, push);\n\tstruct list_head\t*queue = &port->read_queue;\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\ttty = port->port.tty;\n\twhile (!list_empty(queue)) {\n\t\treq = list_first_entry(queue, struct dbc_request, list_pool);\n\n\t\tif (tty && tty_throttled(tty))\n\t\t\tbreak;\n\n\t\tswitch (req->status) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -ESHUTDOWN:\n\t\t\tdisconnect = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_warn(\"ttyDBC0: unexpected RX status %d\\n\",\n\t\t\t\treq->status);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (req->actual) {\n\t\t\tchar\t\t*packet = req->buf;\n\t\t\tunsigned int\tn, size = req->actual;\n\t\t\tint\t\tcount;\n\n\t\t\tn = port->n_read;\n\t\t\tif (n) {\n\t\t\t\tpacket += n;\n\t\t\t\tsize -= n;\n\t\t\t}\n\n\t\t\tcount = tty_insert_flip_string(&port->port, packet,\n\t\t\t\t\t\t       size);\n\t\t\tif (count)\n\t\t\t\tdo_push = true;\n\t\t\tif (count != size) {\n\t\t\t\tport->n_read += count;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport->n_read = 0;\n\t\t}\n\n\t\tlist_move(&req->list_pool, &port->read_pool);\n\t}\n\n\tif (do_push)\n\t\ttty_flip_buffer_push(&port->port);\n\n\tif (!list_empty(queue) && tty) {\n\t\tif (!tty_throttled(tty)) {\n\t\t\tif (do_push)\n\t\t\t\ttasklet_schedule(&port->push);\n\t\t\telse\n\t\t\t\tpr_warn(\"ttyDBC0: RX not scheduled?\\n\");\n\t\t}\n\t}\n\n\tif (!disconnect)\n\t\tdbc_start_rx(port);\n\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n}\n\nstatic int dbc_port_activate(struct tty_port *_port, struct tty_struct *tty)\n{\n\tunsigned long\tflags;\n\tstruct dbc_port\t*port = container_of(_port, struct dbc_port, port);\n\n\tspin_lock_irqsave(&port->port_lock, flags);\n\tdbc_start_rx(port);\n\tspin_unlock_irqrestore(&port->port_lock, flags);\n\n\treturn 0;\n}\n\nstatic const struct tty_port_operations dbc_port_ops = {\n\t.activate =\tdbc_port_activate,\n};\n\nstatic void\nxhci_dbc_tty_init_port(struct xhci_dbc *dbc, struct dbc_port *port)\n{\n\ttty_port_init(&port->port);\n\tspin_lock_init(&port->port_lock);\n\ttasklet_setup(&port->push, dbc_rx_push);\n\tINIT_LIST_HEAD(&port->read_pool);\n\tINIT_LIST_HEAD(&port->read_queue);\n\tINIT_LIST_HEAD(&port->write_pool);\n\n\tport->port.ops =\t&dbc_port_ops;\n\tport->n_read =\t\t0;\n}\n\nstatic void\nxhci_dbc_tty_exit_port(struct dbc_port *port)\n{\n\ttasklet_kill(&port->push);\n\ttty_port_destroy(&port->port);\n}\n\nstatic int xhci_dbc_tty_register_device(struct xhci_dbc *dbc)\n{\n\tint\t\t\tret;\n\tstruct device\t\t*tty_dev;\n\tstruct dbc_port\t\t*port = dbc_to_port(dbc);\n\n\tif (port->registered)\n\t\treturn -EBUSY;\n\n\txhci_dbc_tty_init_port(dbc, port);\n\n\tmutex_lock(&dbc_tty_minors_lock);\n\tport->minor = idr_alloc(&dbc_tty_minors, port, 0, 64, GFP_KERNEL);\n\tmutex_unlock(&dbc_tty_minors_lock);\n\n\tif (port->minor < 0) {\n\t\tret = port->minor;\n\t\tgoto err_idr;\n\t}\n\n\tret = kfifo_alloc(&port->write_fifo, DBC_WRITE_BUF_SIZE, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err_exit_port;\n\n\tret = xhci_dbc_alloc_requests(dbc, BULK_IN, &port->read_pool,\n\t\t\t\t      dbc_read_complete);\n\tif (ret)\n\t\tgoto err_free_fifo;\n\n\tret = xhci_dbc_alloc_requests(dbc, BULK_OUT, &port->write_pool,\n\t\t\t\t      dbc_write_complete);\n\tif (ret)\n\t\tgoto err_free_requests;\n\n\ttty_dev = tty_port_register_device(&port->port,\n\t\t\t\t\t   dbc_tty_driver, port->minor, NULL);\n\tif (IS_ERR(tty_dev)) {\n\t\tret = PTR_ERR(tty_dev);\n\t\tgoto err_free_requests;\n\t}\n\n\tport->registered = true;\n\n\treturn 0;\n\nerr_free_requests:\n\txhci_dbc_free_requests(&port->read_pool);\n\txhci_dbc_free_requests(&port->write_pool);\nerr_free_fifo:\n\tkfifo_free(&port->write_fifo);\nerr_exit_port:\n\tidr_remove(&dbc_tty_minors, port->minor);\nerr_idr:\n\txhci_dbc_tty_exit_port(port);\n\n\tdev_err(dbc->dev, \"can't register tty port, err %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void xhci_dbc_tty_unregister_device(struct xhci_dbc *dbc)\n{\n\tstruct dbc_port\t\t*port = dbc_to_port(dbc);\n\n\tif (!port->registered)\n\t\treturn;\n\ttty_unregister_device(dbc_tty_driver, port->minor);\n\txhci_dbc_tty_exit_port(port);\n\tport->registered = false;\n\n\tmutex_lock(&dbc_tty_minors_lock);\n\tidr_remove(&dbc_tty_minors, port->minor);\n\tmutex_unlock(&dbc_tty_minors_lock);\n\n\tkfifo_free(&port->write_fifo);\n\txhci_dbc_free_requests(&port->read_pool);\n\txhci_dbc_free_requests(&port->read_queue);\n\txhci_dbc_free_requests(&port->write_pool);\n}\n\nstatic const struct dbc_driver dbc_driver = {\n\t.configure\t\t= xhci_dbc_tty_register_device,\n\t.disconnect\t\t= xhci_dbc_tty_unregister_device,\n};\n\nint xhci_dbc_tty_probe(struct device *dev, void __iomem *base, struct xhci_hcd *xhci)\n{\n\tstruct xhci_dbc\t\t*dbc;\n\tstruct dbc_port\t\t*port;\n\tint\t\t\tstatus;\n\n\tif (!dbc_tty_driver)\n\t\treturn -ENODEV;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (!port)\n\t\treturn -ENOMEM;\n\n\tdbc = xhci_alloc_dbc(dev, base, &dbc_driver);\n\n\tif (!dbc) {\n\t\tstatus = -ENOMEM;\n\t\tgoto out2;\n\t}\n\n\tdbc->priv = port;\n\n\t \n\txhci->dbc = dbc;\n\n\treturn 0;\nout2:\n\tkfree(port);\n\n\treturn status;\n}\n\n \nvoid xhci_dbc_tty_remove(struct xhci_dbc *dbc)\n{\n\tstruct dbc_port         *port = dbc_to_port(dbc);\n\n\txhci_dbc_remove(dbc);\n\tkfree(port);\n}\n\nint dbc_tty_init(void)\n{\n\tint\t\tret;\n\n\tidr_init(&dbc_tty_minors);\n\n\tdbc_tty_driver = tty_alloc_driver(64, TTY_DRIVER_REAL_RAW |\n\t\t\t\t\t  TTY_DRIVER_DYNAMIC_DEV);\n\tif (IS_ERR(dbc_tty_driver)) {\n\t\tidr_destroy(&dbc_tty_minors);\n\t\treturn PTR_ERR(dbc_tty_driver);\n\t}\n\n\tdbc_tty_driver->driver_name = \"dbc_serial\";\n\tdbc_tty_driver->name = \"ttyDBC\";\n\n\tdbc_tty_driver->type = TTY_DRIVER_TYPE_SERIAL;\n\tdbc_tty_driver->subtype = SERIAL_TYPE_NORMAL;\n\tdbc_tty_driver->init_termios = tty_std_termios;\n\tdbc_tty_driver->init_termios.c_cflag =\n\t\t\tB9600 | CS8 | CREAD | HUPCL | CLOCAL;\n\tdbc_tty_driver->init_termios.c_ispeed = 9600;\n\tdbc_tty_driver->init_termios.c_ospeed = 9600;\n\n\ttty_set_operations(dbc_tty_driver, &dbc_tty_ops);\n\n\tret = tty_register_driver(dbc_tty_driver);\n\tif (ret) {\n\t\tpr_err(\"Can't register dbc tty driver\\n\");\n\t\ttty_driver_kref_put(dbc_tty_driver);\n\t\tidr_destroy(&dbc_tty_minors);\n\t}\n\n\treturn ret;\n}\n\nvoid dbc_tty_exit(void)\n{\n\tif (dbc_tty_driver) {\n\t\ttty_unregister_driver(dbc_tty_driver);\n\t\ttty_driver_kref_put(dbc_tty_driver);\n\t\tdbc_tty_driver = NULL;\n\t}\n\n\tidr_destroy(&dbc_tty_minors);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}