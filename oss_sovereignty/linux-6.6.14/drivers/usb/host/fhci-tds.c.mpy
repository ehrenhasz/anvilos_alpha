{
  "module_name": "fhci-tds.c",
  "hash_id": "752ee1ad65f55a05d8597ef008795e9bb8fc7b94ccdd318b94dbb7c87d7f193b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/fhci-tds.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/io.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"fhci.h\"\n\n#define DUMMY_BD_BUFFER  0xdeadbeef\n#define DUMMY2_BD_BUFFER 0xbaadf00d\n\n \n#define TD_R\t\t0x8000  \n#define TD_W\t\t0x2000  \n#define TD_I\t\t0x1000  \n#define TD_L\t\t0x0800  \n#define TD_TC\t\t0x0400  \n#define TD_CNF\t\t0x0200  \n#define TD_LSP\t\t0x0100  \n#define TD_PID\t\t0x00c0  \n#define TD_RXER\t\t0x0020  \n\n#define TD_NAK\t\t0x0010  \n#define TD_STAL\t\t0x0008  \n#define TD_TO\t\t0x0004  \n#define TD_UN\t\t0x0002  \n#define TD_NO\t\t0x0010  \n#define TD_AB\t\t0x0008  \n#define TD_CR\t\t0x0004  \n#define TD_OV\t\t0x0002  \n#define TD_BOV\t\t0x0001  \n\n#define TD_ERRORS\t(TD_NAK | TD_STAL | TD_TO | TD_UN | \\\n\t\t\t TD_NO | TD_AB | TD_CR | TD_OV | TD_BOV)\n\n#define TD_PID_DATA0\t0x0080  \n#define TD_PID_DATA1\t0x00c0  \n#define TD_PID_TOGGLE\t0x00c0  \n\n#define TD_TOK_SETUP\t0x0000\n#define TD_TOK_OUT\t0x4000\n#define TD_TOK_IN\t0x8000\n#define TD_ISO\t\t0x1000\n#define TD_ENDP\t\t0x0780\n#define TD_ADDR\t\t0x007f\n\n#define TD_ENDP_SHIFT 7\n\nstruct usb_td {\n\t__be16 status;\n\t__be16 length;\n\t__be32 buf_ptr;\n\t__be16 extra;\n\t__be16 reserved;\n};\n\nstatic struct usb_td __iomem *next_bd(struct usb_td __iomem *base,\n\t\t\t\t      struct usb_td __iomem *td,\n\t\t\t\t      u16 status)\n{\n\tif (status & TD_W)\n\t\treturn base;\n\telse\n\t\treturn ++td;\n}\n\nvoid fhci_push_dummy_bd(struct endpoint *ep)\n{\n\tif (!ep->already_pushed_dummy_bd) {\n\t\tu16 td_status = in_be16(&ep->empty_td->status);\n\n\t\tout_be32(&ep->empty_td->buf_ptr, DUMMY_BD_BUFFER);\n\t\t \n\t\tep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);\n\t\tep->already_pushed_dummy_bd = true;\n\t}\n}\n\n \nvoid fhci_ep0_free(struct fhci_usb *usb)\n{\n\tstruct endpoint *ep;\n\tint size;\n\n\tep = usb->ep0;\n\tif (ep) {\n\t\tif (ep->td_base)\n\t\t\tcpm_muram_free(cpm_muram_offset(ep->td_base));\n\n\t\tif (kfifo_initialized(&ep->conf_frame_Q)) {\n\t\t\tsize = cq_howmany(&ep->conf_frame_Q);\n\t\t\tfor (; size; size--) {\n\t\t\t\tstruct packet *pkt = cq_get(&ep->conf_frame_Q);\n\n\t\t\t\tkfree(pkt);\n\t\t\t}\n\t\t\tcq_delete(&ep->conf_frame_Q);\n\t\t}\n\n\t\tif (kfifo_initialized(&ep->empty_frame_Q)) {\n\t\t\tsize = cq_howmany(&ep->empty_frame_Q);\n\t\t\tfor (; size; size--) {\n\t\t\t\tstruct packet *pkt = cq_get(&ep->empty_frame_Q);\n\n\t\t\t\tkfree(pkt);\n\t\t\t}\n\t\t\tcq_delete(&ep->empty_frame_Q);\n\t\t}\n\n\t\tif (kfifo_initialized(&ep->dummy_packets_Q)) {\n\t\t\tsize = cq_howmany(&ep->dummy_packets_Q);\n\t\t\tfor (; size; size--) {\n\t\t\t\tu8 *buff = cq_get(&ep->dummy_packets_Q);\n\n\t\t\t\tkfree(buff);\n\t\t\t}\n\t\t\tcq_delete(&ep->dummy_packets_Q);\n\t\t}\n\n\t\tkfree(ep);\n\t\tusb->ep0 = NULL;\n\t}\n}\n\n \nu32 fhci_create_ep(struct fhci_usb *usb, enum fhci_mem_alloc data_mem,\n\t\t\t   u32 ring_len)\n{\n\tstruct endpoint *ep;\n\tstruct usb_td __iomem *td;\n\tunsigned long ep_offset;\n\tchar *err_for = \"endpoint PRAM\";\n\tint ep_mem_size;\n\tu32 i;\n\n\t \n\tif (!(ring_len > 2)) {\n\t\tfhci_err(usb->fhci, \"illegal TD ring length parameters\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tep = kzalloc(sizeof(*ep), GFP_KERNEL);\n\tif (!ep)\n\t\treturn -ENOMEM;\n\n\tep_mem_size = ring_len * sizeof(*td) + sizeof(struct fhci_ep_pram);\n\tep_offset = cpm_muram_alloc(ep_mem_size, 32);\n\tif (IS_ERR_VALUE(ep_offset))\n\t\tgoto err;\n\tep->td_base = cpm_muram_addr(ep_offset);\n\n\t \n\tif (cq_new(&ep->conf_frame_Q, ring_len + 2) ||\n\t    cq_new(&ep->empty_frame_Q, ring_len + 2) ||\n\t    cq_new(&ep->dummy_packets_Q, ring_len + 2)) {\n\t\terr_for = \"frame_queues\";\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < (ring_len + 1); i++) {\n\t\tstruct packet *pkt;\n\t\tu8 *buff;\n\n\t\tpkt = kmalloc(sizeof(*pkt), GFP_KERNEL);\n\t\tif (!pkt) {\n\t\t\terr_for = \"frame\";\n\t\t\tgoto err;\n\t\t}\n\n\t\tbuff = kmalloc_array(1028, sizeof(*buff), GFP_KERNEL);\n\t\tif (!buff) {\n\t\t\tkfree(pkt);\n\t\t\terr_for = \"buffer\";\n\t\t\tgoto err;\n\t\t}\n\t\tcq_put(&ep->empty_frame_Q, pkt);\n\t\tcq_put(&ep->dummy_packets_Q, buff);\n\t}\n\n\t \n\tep->ep_pram_ptr = (void __iomem *)ep->td_base + sizeof(*td) * ring_len;\n\n\tep->conf_td = ep->td_base;\n\tep->empty_td = ep->td_base;\n\n\tep->already_pushed_dummy_bd = false;\n\n\t \n\ttd = ep->td_base;\n\tfor (i = 0; i < ring_len; i++) {\n\t\tout_be32(&td->buf_ptr, 0);\n\t\tout_be16(&td->status, 0);\n\t\tout_be16(&td->length, 0);\n\t\tout_be16(&td->extra, 0);\n\t\ttd++;\n\t}\n\ttd--;\n\tout_be16(&td->status, TD_W);  \n\tout_be16(&td->length, 0);\n\n\t \n\tusb->ep0 = ep;\n\n\treturn 0;\nerr:\n\tfhci_ep0_free(usb);\n\tkfree(ep);\n\tfhci_err(usb->fhci, \"no memory for the %s\\n\", err_for);\n\treturn -ENOMEM;\n}\n\n \nvoid fhci_init_ep_registers(struct fhci_usb *usb, struct endpoint *ep,\n\t\t\t    enum fhci_mem_alloc data_mem)\n{\n\tu8 rt;\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usep[0],\n\t\t USB_TRANS_CTR | USB_EP_MF | USB_EP_RTE);\n\tout_be16(&usb->fhci->pram->ep_ptr[0],\n\t\t cpm_muram_offset(ep->ep_pram_ptr));\n\n\trt = (BUS_MODE_BO_BE | BUS_MODE_GBL);\n#ifdef MULTI_DATA_BUS\n\tif (data_mem == MEM_SECONDARY)\n\t\trt |= BUS_MODE_DTB;\n#endif\n\tout_8(&ep->ep_pram_ptr->rx_func_code, rt);\n\tout_8(&ep->ep_pram_ptr->tx_func_code, rt);\n\tout_be16(&ep->ep_pram_ptr->rx_buff_len, 1028);\n\tout_be16(&ep->ep_pram_ptr->rx_base, 0);\n\tout_be16(&ep->ep_pram_ptr->tx_base, cpm_muram_offset(ep->td_base));\n\tout_be16(&ep->ep_pram_ptr->rx_bd_ptr, 0);\n\tout_be16(&ep->ep_pram_ptr->tx_bd_ptr, cpm_muram_offset(ep->td_base));\n\tout_be32(&ep->ep_pram_ptr->tx_state, 0);\n}\n\n \nstatic void fhci_td_transaction_confirm(struct fhci_usb *usb)\n{\n\tstruct endpoint *ep = usb->ep0;\n\tstruct packet *pkt;\n\tstruct usb_td __iomem *td;\n\tu16 extra_data;\n\tu16 td_status;\n\tu16 td_length;\n\tu32 buf;\n\n\t \n\twhile (1) {\n\t\ttd = ep->conf_td;\n\t\ttd_status = in_be16(&td->status);\n\t\ttd_length = in_be16(&td->length);\n\t\tbuf = in_be32(&td->buf_ptr);\n\t\textra_data = in_be16(&td->extra);\n\n\t\t \n\t\tif (!(!(td_status & TD_R) && ((td_status & ~TD_W) || buf)))\n\t\t\tbreak;\n\t\t \n\t\telse if ((buf == DUMMY_BD_BUFFER) && !(td_status & ~TD_W))\n\t\t\tbreak;\n\n\t\t \n\t\tclrbits16(&td->status, ~TD_W);\n\t\tout_be16(&td->length, 0);\n\t\tout_be32(&td->buf_ptr, 0);\n\t\tout_be16(&td->extra, 0);\n\t\t \n\t\tep->conf_td = next_bd(ep->td_base, ep->conf_td, td_status);\n\n\t\t \n\t\tif ((buf == DUMMY2_BD_BUFFER) && !(td_status & ~TD_W))\n\t\t\tcontinue;\n\n\t\tpkt = cq_get(&ep->conf_frame_Q);\n\t\tif (!pkt)\n\t\t\tfhci_err(usb->fhci, \"no frame to confirm\\n\");\n\n\t\tif (td_status & TD_ERRORS) {\n\t\t\tif (td_status & TD_RXER) {\n\t\t\t\tif (td_status & TD_CR)\n\t\t\t\t\tpkt->status = USB_TD_RX_ER_CRC;\n\t\t\t\telse if (td_status & TD_AB)\n\t\t\t\t\tpkt->status = USB_TD_RX_ER_BITSTUFF;\n\t\t\t\telse if (td_status & TD_OV)\n\t\t\t\t\tpkt->status = USB_TD_RX_ER_OVERUN;\n\t\t\t\telse if (td_status & TD_BOV)\n\t\t\t\t\tpkt->status = USB_TD_RX_DATA_OVERUN;\n\t\t\t\telse if (td_status & TD_NO)\n\t\t\t\t\tpkt->status = USB_TD_RX_ER_NONOCT;\n\t\t\t\telse\n\t\t\t\t\tfhci_err(usb->fhci, \"illegal error \"\n\t\t\t\t\t\t \"occurred\\n\");\n\t\t\t} else if (td_status & TD_NAK)\n\t\t\t\tpkt->status = USB_TD_TX_ER_NAK;\n\t\t\telse if (td_status & TD_TO)\n\t\t\t\tpkt->status = USB_TD_TX_ER_TIMEOUT;\n\t\t\telse if (td_status & TD_UN)\n\t\t\t\tpkt->status = USB_TD_TX_ER_UNDERUN;\n\t\t\telse if (td_status & TD_STAL)\n\t\t\t\tpkt->status = USB_TD_TX_ER_STALL;\n\t\t\telse\n\t\t\t\tfhci_err(usb->fhci, \"illegal error occurred\\n\");\n\t\t} else if ((extra_data & TD_TOK_IN) &&\n\t\t\t\tpkt->len > td_length - CRC_SIZE) {\n\t\t\tpkt->status = USB_TD_RX_DATA_UNDERUN;\n\t\t}\n\n\t\tif (extra_data & TD_TOK_IN)\n\t\t\tpkt->len = td_length - CRC_SIZE;\n\t\telse if (pkt->info & PKT_ZLP)\n\t\t\tpkt->len = 0;\n\t\telse\n\t\t\tpkt->len = td_length;\n\n\t\tfhci_transaction_confirm(usb, pkt);\n\t}\n}\n\n \nu32 fhci_host_transaction(struct fhci_usb *usb,\n\t\t\t  struct packet *pkt,\n\t\t\t  enum fhci_ta_type trans_type,\n\t\t\t  u8 dest_addr,\n\t\t\t  u8 dest_ep,\n\t\t\t  enum fhci_tf_mode trans_mode,\n\t\t\t  enum fhci_speed dest_speed, u8 data_toggle)\n{\n\tstruct endpoint *ep = usb->ep0;\n\tstruct usb_td __iomem *td;\n\tu16 extra_data;\n\tu16 td_status;\n\n\tfhci_usb_disable_interrupt(usb);\n\t \n\ttd = ep->empty_td;\n\ttd_status = in_be16(&td->status);\n\n\tif (td_status & TD_R && in_be16(&td->length)) {\n\t\t \n\t\tfhci_usb_enable_interrupt(usb);\n\t\treturn -1;\n\t}\n\n\t \n\tep->empty_td = next_bd(ep->td_base, ep->empty_td, td_status);\n\tfhci_usb_enable_interrupt(usb);\n\tpkt->priv_data = td;\n\tout_be32(&td->buf_ptr, virt_to_phys(pkt->data));\n\t \n\textra_data = (dest_ep << TD_ENDP_SHIFT) | dest_addr;\n\tswitch (trans_type) {\n\tcase FHCI_TA_IN:\n\t\textra_data |= TD_TOK_IN;\n\t\tbreak;\n\tcase FHCI_TA_OUT:\n\t\textra_data |= TD_TOK_OUT;\n\t\tbreak;\n\tcase FHCI_TA_SETUP:\n\t\textra_data |= TD_TOK_SETUP;\n\t\tbreak;\n\t}\n\tif (trans_mode == FHCI_TF_ISO)\n\t\textra_data |= TD_ISO;\n\tout_be16(&td->extra, extra_data);\n\n\t \n\ttd_status = ((td_status & TD_W) | TD_R | TD_L | TD_I | TD_CNF);\n\tif (!(pkt->info & PKT_NO_CRC))\n\t\ttd_status |= TD_TC;\n\n\tswitch (trans_type) {\n\tcase FHCI_TA_IN:\n\t\tif (data_toggle)\n\t\t\tpkt->info |= PKT_PID_DATA1;\n\t\telse\n\t\t\tpkt->info |= PKT_PID_DATA0;\n\t\tbreak;\n\tdefault:\n\t\tif (data_toggle) {\n\t\t\ttd_status |= TD_PID_DATA1;\n\t\t\tpkt->info |= PKT_PID_DATA1;\n\t\t} else {\n\t\t\ttd_status |= TD_PID_DATA0;\n\t\t\tpkt->info |= PKT_PID_DATA0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif ((dest_speed == FHCI_LOW_SPEED) &&\n\t    (usb->port_status == FHCI_PORT_FULL))\n\t\ttd_status |= TD_LSP;\n\n\tout_be16(&td->status, td_status);\n\n\t \n\tif (trans_type == FHCI_TA_IN)\n\t\tout_be16(&td->length, pkt->len + CRC_SIZE);\n\telse\n\t\tout_be16(&td->length, pkt->len);\n\n\t \n\tcq_put(&ep->conf_frame_Q, pkt);\n\n\tif (cq_howmany(&ep->conf_frame_Q) == 1)\n\t\tout_8(&usb->fhci->regs->usb_uscom, USB_CMD_STR_FIFO);\n\n\treturn 0;\n}\n\n \nvoid fhci_flush_bds(struct fhci_usb *usb)\n{\n\tu16 td_status;\n\tstruct usb_td __iomem *td;\n\tstruct endpoint *ep = usb->ep0;\n\n\ttd = ep->td_base;\n\twhile (1) {\n\t\ttd_status = in_be16(&td->status);\n\t\tin_be32(&td->buf_ptr);\n\t\tin_be16(&td->extra);\n\n\t\t \n\t\tif (td_status & TD_R)\n\t\t\tout_be16(&td->status, (td_status & ~TD_R) | TD_TO);\n\t\t \n\t\telse if (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER)\n\t\t\tout_be32(&td->buf_ptr, DUMMY2_BD_BUFFER);\n\t\t \n\t\tif (td_status & TD_W)\n\t\t\tbreak;\n\n\t\ttd++;\n\t}\n\n\tfhci_td_transaction_confirm(usb);\n\n\ttd = ep->td_base;\n\tdo {\n\t\tout_be16(&td->status, 0);\n\t\tout_be16(&td->length, 0);\n\t\tout_be32(&td->buf_ptr, 0);\n\t\tout_be16(&td->extra, 0);\n\t\ttd++;\n\t} while (!(in_be16(&td->status) & TD_W));\n\tout_be16(&td->status, TD_W);  \n\tout_be16(&td->length, 0);\n\tout_be32(&td->buf_ptr, 0);\n\tout_be16(&td->extra, 0);\n\n\tout_be16(&ep->ep_pram_ptr->tx_bd_ptr,\n\t\t in_be16(&ep->ep_pram_ptr->tx_base));\n\tout_be32(&ep->ep_pram_ptr->tx_state, 0);\n\tout_be16(&ep->ep_pram_ptr->tx_cnt, 0);\n\tep->empty_td = ep->td_base;\n\tep->conf_td = ep->td_base;\n}\n\n \nvoid fhci_flush_actual_frame(struct fhci_usb *usb)\n{\n\tu8 mode;\n\tu16 tb_ptr;\n\tu16 td_status;\n\tu32 buf_ptr;\n\tstruct usb_td __iomem *td;\n\tstruct endpoint *ep = usb->ep0;\n\n\t \n\tmode = in_8(&usb->fhci->regs->usb_usmod);\n\tout_8(&usb->fhci->regs->usb_usmod, mode & ~USB_MODE_EN);\n\n\ttb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);\n\ttd = cpm_muram_addr(tb_ptr);\n\ttd_status = in_be16(&td->status);\n\tbuf_ptr = in_be32(&td->buf_ptr);\n\tin_be16(&td->extra);\n\tdo {\n\t\tif (td_status & TD_R) {\n\t\t\tout_be16(&td->status, (td_status & ~TD_R) | TD_TO);\n\t\t} else {\n\t\t\tout_be32(&td->buf_ptr, 0);\n\t\t\tep->already_pushed_dummy_bd = false;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\ttd = next_bd(ep->td_base, td, td_status);\n\t\ttd_status = in_be16(&td->status);\n\t\tbuf_ptr = in_be32(&td->buf_ptr);\n\t\tin_be16(&td->extra);\n\t} while ((td_status & TD_R) || buf_ptr);\n\n\tfhci_td_transaction_confirm(usb);\n\n\tout_be16(&ep->ep_pram_ptr->tx_bd_ptr,\n\t\t in_be16(&ep->ep_pram_ptr->tx_base));\n\tout_be32(&ep->ep_pram_ptr->tx_state, 0);\n\tout_be16(&ep->ep_pram_ptr->tx_cnt, 0);\n\tep->empty_td = ep->td_base;\n\tep->conf_td = ep->td_base;\n\n\tusb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usber, 0xffff);\n\t \n\tout_8(&usb->fhci->regs->usb_usmod, mode | USB_MODE_EN);\n}\n\n \nvoid fhci_tx_conf_interrupt(struct fhci_usb *usb)\n{\n\tfhci_td_transaction_confirm(usb);\n\n\t \n\tif (((fhci_get_sof_timer_count(usb) < usb->max_frame_usage) ||\n\t     (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)) &&\n\t    (list_empty(&usb->actual_frame->tds_list)))\n\t\tfhci_schedule_transactions(usb);\n}\n\nvoid fhci_host_transmit_actual_frame(struct fhci_usb *usb)\n{\n\tu16 tb_ptr;\n\tu16 td_status;\n\tstruct usb_td __iomem *td;\n\tstruct endpoint *ep = usb->ep0;\n\n\ttb_ptr = in_be16(&ep->ep_pram_ptr->tx_bd_ptr);\n\ttd = cpm_muram_addr(tb_ptr);\n\n\tif (in_be32(&td->buf_ptr) == DUMMY_BD_BUFFER) {\n\t\tstruct usb_td __iomem *old_td = td;\n\n\t\tep->already_pushed_dummy_bd = false;\n\t\ttd_status = in_be16(&td->status);\n\t\t \n\t\ttd = next_bd(ep->td_base, td, td_status);\n\t\ttb_ptr = cpm_muram_offset(td);\n\t\tout_be16(&ep->ep_pram_ptr->tx_bd_ptr, tb_ptr);\n\n\t\t \n\t\tif (in_be16(&td->status) & TD_R)\n\t\t\tout_8(&usb->fhci->regs->usb_uscom, USB_CMD_STR_FIFO);\n\n\t\tif (in_be32(&ep->conf_td->buf_ptr) == DUMMY_BD_BUFFER) {\n\t\t\tout_be32(&old_td->buf_ptr, 0);\n\t\t\tep->conf_td = next_bd(ep->td_base, ep->conf_td,\n\t\t\t\t\t      td_status);\n\t\t} else {\n\t\t\tout_be32(&old_td->buf_ptr, DUMMY2_BD_BUFFER);\n\t\t}\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}