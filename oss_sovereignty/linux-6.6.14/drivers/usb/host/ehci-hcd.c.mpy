{
  "module_name": "ehci-hcd.c",
  "hash_id": "05419bb2c7ebff22523f919cedbe83f9cce41499fc520eef9862e52e94060715",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/vmalloc.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <linux/debugfs.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n\n#include <asm/byteorder.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n#if defined(CONFIG_PPC_PS3)\n#include <asm/firmware.h>\n#endif\n\n \n\n \n\n#define DRIVER_AUTHOR \"David Brownell\"\n#define DRIVER_DESC \"USB 2.0 'Enhanced' Host Controller (EHCI) Driver\"\n\nstatic const char\thcd_name [] = \"ehci_hcd\";\n\n\n#undef EHCI_URB_TRACE\n\n \n#define\tEHCI_TUNE_CERR\t\t3\t \n#define\tEHCI_TUNE_RL_HS\t\t4\t \n#define\tEHCI_TUNE_RL_TT\t\t0\n#define\tEHCI_TUNE_MULT_HS\t1\t \n#define\tEHCI_TUNE_MULT_TT\t1\n \n#define\tEHCI_TUNE_FLS\t\t1\t \n\n \nstatic int log2_irq_thresh;\t\t\nmodule_param (log2_irq_thresh, int, S_IRUGO);\nMODULE_PARM_DESC (log2_irq_thresh, \"log2 IRQ latency, 1-64 microframes\");\n\n \nstatic unsigned park;\nmodule_param (park, uint, S_IRUGO);\nMODULE_PARM_DESC (park, \"park setting; 1-3 back-to-back async packets\");\n\n \nstatic bool ignore_oc;\nmodule_param (ignore_oc, bool, S_IRUGO);\nMODULE_PARM_DESC (ignore_oc, \"ignore bogus hardware overcurrent indications\");\n\n#define\tINTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)\n\n \n\n#include \"ehci.h\"\n#include \"pci-quirks.h\"\n\nstatic void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],\n\t\tstruct ehci_tt *tt);\n\n \nstatic unsigned ehci_moschip_read_frame_index(struct ehci_hcd *ehci)\n{\n\tunsigned uf;\n\n\tuf = ehci_readl(ehci, &ehci->regs->frame_index);\n\tif (unlikely((uf & 7) == 0))\n\t\tuf = ehci_readl(ehci, &ehci->regs->frame_index);\n\treturn uf;\n}\n\nstatic inline unsigned ehci_read_frame_index(struct ehci_hcd *ehci)\n{\n\tif (ehci->frame_index_bug)\n\t\treturn ehci_moschip_read_frame_index(ehci);\n\treturn ehci_readl(ehci, &ehci->regs->frame_index);\n}\n\n#include \"ehci-dbg.c\"\n\n \n\n \nint ehci_handshake(struct ehci_hcd *ehci, void __iomem *ptr,\n\t\t   u32 mask, u32 done, int usec)\n{\n\tu32\tresult;\n\n\tdo {\n\t\tresult = ehci_readl(ehci, ptr);\n\t\tif (result == ~(u32)0)\t\t \n\t\t\treturn -ENODEV;\n\t\tresult &= mask;\n\t\tif (result == done)\n\t\t\treturn 0;\n\t\tudelay (1);\n\t\tusec--;\n\t} while (usec > 0);\n\treturn -ETIMEDOUT;\n}\nEXPORT_SYMBOL_GPL(ehci_handshake);\n\n \nstatic int tdi_in_host_mode (struct ehci_hcd *ehci)\n{\n\tu32\t\ttmp;\n\n\ttmp = ehci_readl(ehci, &ehci->regs->usbmode);\n\treturn (tmp & 3) == USBMODE_CM_HC;\n}\n\n \nstatic int ehci_halt (struct ehci_hcd *ehci)\n{\n\tu32\ttemp;\n\n\tspin_lock_irq(&ehci->lock);\n\n\t \n\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\n\tif (ehci_is_TDI(ehci) && !tdi_in_host_mode(ehci)) {\n\t\tspin_unlock_irq(&ehci->lock);\n\t\treturn 0;\n\t}\n\n\t \n\tehci->command &= ~CMD_RUN;\n\ttemp = ehci_readl(ehci, &ehci->regs->command);\n\ttemp &= ~(CMD_RUN | CMD_IAAD);\n\tehci_writel(ehci, temp, &ehci->regs->command);\n\n\tspin_unlock_irq(&ehci->lock);\n\tsynchronize_irq(ehci_to_hcd(ehci)->irq);\n\n\treturn ehci_handshake(ehci, &ehci->regs->status,\n\t\t\t  STS_HALT, STS_HALT, 16 * 125);\n}\n\n \nstatic void tdi_reset (struct ehci_hcd *ehci)\n{\n\tu32\t\ttmp;\n\n\ttmp = ehci_readl(ehci, &ehci->regs->usbmode);\n\ttmp |= USBMODE_CM_HC;\n\t \n\tif (ehci_big_endian_mmio(ehci))\n\t\ttmp |= USBMODE_BE;\n\tehci_writel(ehci, tmp, &ehci->regs->usbmode);\n}\n\n \nint ehci_reset(struct ehci_hcd *ehci)\n{\n\tint\tretval;\n\tu32\tcommand = ehci_readl(ehci, &ehci->regs->command);\n\n\t \n\tif (ehci->debug && !dbgp_reset_prep(ehci_to_hcd(ehci)))\n\t\tehci->debug = NULL;\n\n\tcommand |= CMD_RESET;\n\tdbg_cmd (ehci, \"reset\", command);\n\tehci_writel(ehci, command, &ehci->regs->command);\n\tehci->rh_state = EHCI_RH_HALTED;\n\tehci->next_statechange = jiffies;\n\tretval = ehci_handshake(ehci, &ehci->regs->command,\n\t\t\t    CMD_RESET, 0, 250 * 1000);\n\n\tif (ehci->has_hostpc) {\n\t\tehci_writel(ehci, USBMODE_EX_HC | USBMODE_EX_VBPS,\n\t\t\t\t&ehci->regs->usbmode_ex);\n\t\tehci_writel(ehci, TXFIFO_DEFAULT, &ehci->regs->txfill_tuning);\n\t}\n\tif (retval)\n\t\treturn retval;\n\n\tif (ehci_is_TDI(ehci))\n\t\ttdi_reset (ehci);\n\n\tif (ehci->debug)\n\t\tdbgp_external_startup(ehci_to_hcd(ehci));\n\n\tehci->port_c_suspend = ehci->suspended_ports =\n\t\t\tehci->resuming_ports = 0;\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(ehci_reset);\n\n \nstatic void ehci_quiesce (struct ehci_hcd *ehci)\n{\n\tu32\ttemp;\n\n\tif (ehci->rh_state != EHCI_RH_RUNNING)\n\t\treturn;\n\n\t \n\ttemp = (ehci->command << 10) & (STS_ASS | STS_PSS);\n\tehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, temp,\n\t\t\t16 * 125);\n\n\t \n\tspin_lock_irq(&ehci->lock);\n\tehci->command &= ~(CMD_ASE | CMD_PSE);\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\tspin_unlock_irq(&ehci->lock);\n\n\t \n\tehci_handshake(ehci, &ehci->regs->status, STS_ASS | STS_PSS, 0,\n\t\t\t16 * 125);\n}\n\n \n\nstatic void end_iaa_cycle(struct ehci_hcd *ehci);\nstatic void end_unlink_async(struct ehci_hcd *ehci);\nstatic void unlink_empty_async(struct ehci_hcd *ehci);\nstatic void ehci_work(struct ehci_hcd *ehci);\nstatic void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);\nstatic void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh);\nstatic int ehci_port_power(struct ehci_hcd *ehci, int portnum, bool enable);\n\n#include \"ehci-timer.c\"\n#include \"ehci-hub.c\"\n#include \"ehci-mem.c\"\n#include \"ehci-q.c\"\n#include \"ehci-sched.c\"\n#include \"ehci-sysfs.c\"\n\n \n\n \nstatic void ehci_turn_off_all_ports(struct ehci_hcd *ehci)\n{\n\tint\tport = HCS_N_PORTS(ehci->hcs_params);\n\n\twhile (port--) {\n\t\tspin_unlock_irq(&ehci->lock);\n\t\tehci_port_power(ehci, port, false);\n\t\tspin_lock_irq(&ehci->lock);\n\t\tehci_writel(ehci, PORT_RWC_BITS,\n\t\t\t\t&ehci->regs->port_status[port]);\n\t}\n}\n\n \nstatic void ehci_silence_controller(struct ehci_hcd *ehci)\n{\n\tehci_halt(ehci);\n\n\tspin_lock_irq(&ehci->lock);\n\tehci->rh_state = EHCI_RH_HALTED;\n\tehci_turn_off_all_ports(ehci);\n\n\t \n\tehci_writel(ehci, 0, &ehci->regs->configured_flag);\n\n\t \n\tehci_readl(ehci, &ehci->regs->configured_flag);\n\tspin_unlock_irq(&ehci->lock);\n}\n\n \nstatic void ehci_shutdown(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci(hcd);\n\n\t \n\tif (!ehci->sbrn)\n\t\treturn;\n\n\tspin_lock_irq(&ehci->lock);\n\tehci->shutdown = true;\n\tehci->rh_state = EHCI_RH_STOPPING;\n\tehci->enabled_hrtimer_events = 0;\n\tspin_unlock_irq(&ehci->lock);\n\n\tehci_silence_controller(ehci);\n\n\thrtimer_cancel(&ehci->hrtimer);\n}\n\n \n\n \nstatic void ehci_work (struct ehci_hcd *ehci)\n{\n\t \n\tif (ehci->scanning) {\n\t\tehci->need_rescan = true;\n\t\treturn;\n\t}\n\tehci->scanning = true;\n\n rescan:\n\tehci->need_rescan = false;\n\tif (ehci->async_count)\n\t\tscan_async(ehci);\n\tif (ehci->intr_count > 0)\n\t\tscan_intr(ehci);\n\tif (ehci->isoc_count > 0)\n\t\tscan_isoc(ehci);\n\tif (ehci->need_rescan)\n\t\tgoto rescan;\n\tehci->scanning = false;\n\n\t \n\tturn_on_io_watchdog(ehci);\n}\n\n \nstatic void ehci_stop (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\n\tehci_dbg (ehci, \"stop\\n\");\n\n\t \n\n\tspin_lock_irq(&ehci->lock);\n\tehci->enabled_hrtimer_events = 0;\n\tspin_unlock_irq(&ehci->lock);\n\n\tehci_quiesce(ehci);\n\tehci_silence_controller(ehci);\n\tehci_reset (ehci);\n\n\thrtimer_cancel(&ehci->hrtimer);\n\tremove_sysfs_files(ehci);\n\tremove_debug_files (ehci);\n\n\t \n\tspin_lock_irq (&ehci->lock);\n\tend_free_itds(ehci);\n\tspin_unlock_irq (&ehci->lock);\n\tehci_mem_cleanup (ehci);\n\n\tif (ehci->amd_pll_fix == 1)\n\t\tusb_amd_dev_put();\n\n\tdbg_status (ehci, \"ehci_stop completed\",\n\t\t    ehci_readl(ehci, &ehci->regs->status));\n}\n\n \nstatic int ehci_init(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tu32\t\t\ttemp;\n\tint\t\t\tretval;\n\tu32\t\t\thcc_params;\n\tstruct ehci_qh_hw\t*hw;\n\n\tspin_lock_init(&ehci->lock);\n\n\t \n\tehci->need_io_watchdog = 1;\n\n\thrtimer_init(&ehci->hrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tehci->hrtimer.function = ehci_hrtimer_func;\n\tehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\n\n\thcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);\n\n\t \n\tehci->uframe_periodic_max = 100;\n\n\t \n\tehci->periodic_size = DEFAULT_I_TDPS;\n\tINIT_LIST_HEAD(&ehci->async_unlink);\n\tINIT_LIST_HEAD(&ehci->async_idle);\n\tINIT_LIST_HEAD(&ehci->intr_unlink_wait);\n\tINIT_LIST_HEAD(&ehci->intr_unlink);\n\tINIT_LIST_HEAD(&ehci->intr_qh_list);\n\tINIT_LIST_HEAD(&ehci->cached_itd_list);\n\tINIT_LIST_HEAD(&ehci->cached_sitd_list);\n\tINIT_LIST_HEAD(&ehci->tt_list);\n\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t \n\t\tswitch (EHCI_TUNE_FLS) {\n\t\tcase 0: ehci->periodic_size = 1024; break;\n\t\tcase 1: ehci->periodic_size = 512; break;\n\t\tcase 2: ehci->periodic_size = 256; break;\n\t\tdefault:\tBUG();\n\t\t}\n\t}\n\tif ((retval = ehci_mem_init(ehci, GFP_KERNEL)) < 0)\n\t\treturn retval;\n\n\t \n\tif (HCC_ISOC_CACHE(hcc_params))\t\t\n\t\tehci->i_thresh = 0;\n\telse\t\t\t\t\t\n\t\tehci->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\n\n\t \n\tehci->async->qh_next.qh = NULL;\n\thw = ehci->async->hw;\n\thw->hw_next = QH_NEXT(ehci, ehci->async->qh_dma);\n\thw->hw_info1 = cpu_to_hc32(ehci, QH_HEAD);\n#if defined(CONFIG_PPC_PS3)\n\thw->hw_info1 |= cpu_to_hc32(ehci, QH_INACTIVATE);\n#endif\n\thw->hw_token = cpu_to_hc32(ehci, QTD_STS_HALT);\n\thw->hw_qtd_next = EHCI_LIST_END(ehci);\n\tehci->async->qh_state = QH_STATE_LINKED;\n\thw->hw_alt_next = QTD_NEXT(ehci, ehci->async->dummy->qtd_dma);\n\n\t \n\tif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\n\t\tlog2_irq_thresh = 0;\n\ttemp = 1 << (16 + log2_irq_thresh);\n\tif (HCC_PER_PORT_CHANGE_EVENT(hcc_params)) {\n\t\tehci->has_ppcd = 1;\n\t\tehci_dbg(ehci, \"enable per-port change event\\n\");\n\t\ttemp |= CMD_PPCEE;\n\t}\n\tif (HCC_CANPARK(hcc_params)) {\n\t\t \n\t\tif (park) {\n\t\t\tpark = min(park, (unsigned) 3);\n\t\t\ttemp |= CMD_PARK;\n\t\t\ttemp |= park << 8;\n\t\t}\n\t\tehci_dbg(ehci, \"park %d\\n\", park);\n\t}\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t \n\t\ttemp &= ~(3 << 2);\n\t\ttemp |= (EHCI_TUNE_FLS << 2);\n\t}\n\tehci->command = temp;\n\n\t \n\tif (!hcd->localmem_pool)\n\t\thcd->self.sg_tablesize = ~0;\n\n\t \n\tehci->old_current = ~0;\n\treturn 0;\n}\n\n \nstatic int ehci_run (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tu32\t\t\ttemp;\n\tu32\t\t\thcc_params;\n\tint\t\t\trc;\n\n\thcd->uses_new_polling = 1;\n\n\t \n\n\tehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\n\tehci_writel(ehci, (u32)ehci->async->qh_dma, &ehci->regs->async_next);\n\n\t \n\thcc_params = ehci_readl(ehci, &ehci->caps->hcc_params);\n\tif (HCC_64BIT_ADDR(hcc_params)) {\n\t\tehci_writel(ehci, 0, &ehci->regs->segment);\n#if 0\n \n\t\tif (!dma_set_mask(hcd->self.controller, DMA_BIT_MASK(64)))\n\t\t\tehci_info(ehci, \"enabled 64bit DMA\\n\");\n#endif\n\t}\n\n\n\t \n\t \n\tehci->command &= ~(CMD_LRESET|CMD_IAAD|CMD_PSE|CMD_ASE|CMD_RESET);\n\tehci->command |= CMD_RUN;\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\tdbg_cmd (ehci, \"init\", ehci->command);\n\n\t \n\tdown_write(&ehci_cf_port_reset_rwsem);\n\tehci->rh_state = EHCI_RH_RUNNING;\n\tehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\n\n\t \n\tehci_readl(ehci, &ehci->regs->command);\t \n\tmsleep(5);\n\n\t \n\tif (ehci->is_aspeed)\n\t\trc = ehci_handshake(ehci, &ehci->regs->command, CMD_RUN,\n\t\t\t\t    1, 100 * 1000);\n\telse\n\t\trc = ehci_handshake(ehci, &ehci->regs->status, STS_HALT,\n\t\t\t\t    0, 100 * 1000);\n\n\tup_write(&ehci_cf_port_reset_rwsem);\n\n\tif (rc) {\n\t\tehci_err(ehci, \"USB %x.%x, controller refused to start: %d\\n\",\n\t\t\t ((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f), rc);\n\t\treturn rc;\n\t}\n\n\tehci->last_periodic_enable = ktime_get_real();\n\n\ttemp = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\n\tehci_info (ehci,\n\t\t\"USB %x.%x started, EHCI %x.%02x%s\\n\",\n\t\t((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),\n\t\ttemp >> 8, temp & 0xff,\n\t\t(ignore_oc || ehci->spurious_oc) ? \", overcurrent ignored\" : \"\");\n\n\tehci_writel(ehci, INTR_MASK,\n\t\t    &ehci->regs->intr_enable);  \n\n\t \n\tcreate_debug_files(ehci);\n\tcreate_sysfs_files(ehci);\n\n\treturn 0;\n}\n\nint ehci_setup(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tint retval;\n\n\tehci->regs = (void __iomem *)ehci->caps +\n\t    HC_LENGTH(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\n\tdbg_hcs_params(ehci, \"reset\");\n\tdbg_hcc_params(ehci, \"reset\");\n\n\t \n\tehci->hcs_params = ehci_readl(ehci, &ehci->caps->hcs_params);\n\n\tehci->sbrn = HCD_USB2;\n\n\t \n\tretval = ehci_init(hcd);\n\tif (retval)\n\t\treturn retval;\n\n\tretval = ehci_halt(ehci);\n\tif (retval) {\n\t\tehci_mem_cleanup(ehci);\n\t\treturn retval;\n\t}\n\n\tehci_reset(ehci);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ehci_setup);\n\n \n\nstatic irqreturn_t ehci_irq (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tu32\t\t\tstatus, current_status, masked_status, pcd_status = 0;\n\tu32\t\t\tcmd;\n\tint\t\t\tbh;\n\n\tspin_lock(&ehci->lock);\n\n\tstatus = 0;\n\tcurrent_status = ehci_readl(ehci, &ehci->regs->status);\nrestart:\n\n\t \n\tif (current_status == ~(u32) 0) {\n\t\tehci_dbg (ehci, \"device removed\\n\");\n\t\tgoto dead;\n\t}\n\tstatus |= current_status;\n\n\t \n\tmasked_status = current_status & (INTR_MASK | STS_FLR);\n\n\t \n\tif (!masked_status || unlikely(ehci->rh_state == EHCI_RH_HALTED)) {\n\t\tspin_unlock(&ehci->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\tehci_writel(ehci, masked_status, &ehci->regs->status);\n\n\t \n\tcurrent_status = ehci_readl(ehci, &ehci->regs->status);\n\tif (current_status & INTR_MASK)\n\t\tgoto restart;\n\n\tcmd = ehci_readl(ehci, &ehci->regs->command);\n\tbh = 0;\n\n\t \n\tif (likely ((status & (STS_INT|STS_ERR)) != 0)) {\n\t\tif (likely ((status & STS_ERR) == 0)) {\n\t\t\tINCR(ehci->stats.normal);\n\t\t} else {\n\t\t\t \n\t\t\tif (ehci->has_ci_pec_bug)\n\t\t\t\tstatus |= STS_PCD;\n\t\t\tINCR(ehci->stats.error);\n\t\t}\n\t\tbh = 1;\n\t}\n\n\t \n\tif (status & STS_IAA) {\n\n\t\t \n\t\tehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_IAA_WATCHDOG);\n\n\t\t \n\t\tif (ehci->next_hrtimer_event == EHCI_HRTIMER_IAA_WATCHDOG)\n\t\t\t++ehci->next_hrtimer_event;\n\n\t\t \n\t\tif (cmd & CMD_IAAD)\n\t\t\tehci_dbg(ehci, \"IAA with IAAD still set?\\n\");\n\t\tif (ehci->iaa_in_progress)\n\t\t\tINCR(ehci->stats.iaa);\n\t\tend_iaa_cycle(ehci);\n\t}\n\n\t \n\tif (status & STS_PCD) {\n\t\tunsigned\ti = HCS_N_PORTS (ehci->hcs_params);\n\t\tu32\t\tppcd = ~0;\n\n\t\t \n\t\tpcd_status = status;\n\n\t\t \n\t\tif (ehci->rh_state == EHCI_RH_SUSPENDED)\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\n\t\t \n\t\tif (ehci->has_ppcd)\n\t\t\tppcd = status >> 16;\n\n\t\twhile (i--) {\n\t\t\tint pstatus;\n\n\t\t\t \n\t\t\tif (!(ppcd & (1 << i)))\n\t\t\t\tcontinue;\n\t\t\tpstatus = ehci_readl(ehci,\n\t\t\t\t\t &ehci->regs->port_status[i]);\n\n\t\t\tif (pstatus & PORT_OWNER)\n\t\t\t\tcontinue;\n\t\t\tif (!(test_bit(i, &ehci->suspended_ports) &&\n\t\t\t\t\t((pstatus & PORT_RESUME) ||\n\t\t\t\t\t\t!(pstatus & PORT_SUSPEND)) &&\n\t\t\t\t\t(pstatus & PORT_PE) &&\n\t\t\t\t\tehci->reset_done[i] == 0))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tehci->reset_done[i] = jiffies +\n\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\tset_bit(i, &ehci->resuming_ports);\n\t\t\tehci_dbg (ehci, \"port %d remote wakeup\\n\", i + 1);\n\t\t\tusb_hcd_start_port_resume(&hcd->self, i);\n\t\t\tmod_timer(&hcd->rh_timer, ehci->reset_done[i]);\n\t\t}\n\t}\n\n\t \n\tif (unlikely ((status & STS_FATAL) != 0)) {\n\t\tehci_err(ehci, \"fatal error\\n\");\n\t\tdbg_cmd(ehci, \"fatal\", cmd);\n\t\tdbg_status(ehci, \"fatal\", status);\ndead:\n\t\tusb_hc_died(hcd);\n\n\t\t \n\t\tehci->shutdown = true;\n\t\tehci->rh_state = EHCI_RH_STOPPING;\n\t\tehci->command &= ~(CMD_RUN | CMD_ASE | CMD_PSE);\n\t\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\t\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\t\tehci_handle_controller_death(ehci);\n\n\t\t \n\t\tbh = 0;\n\t}\n\n\tif (bh)\n\t\tehci_work (ehci);\n\tspin_unlock(&ehci->lock);\n\tif (pcd_status)\n\t\tusb_hcd_poll_rh_status(hcd);\n\treturn IRQ_HANDLED;\n}\n\n \n\n \nstatic int ehci_urb_enqueue (\n\tstruct usb_hcd\t*hcd,\n\tstruct urb\t*urb,\n\tgfp_t\t\tmem_flags\n) {\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tstruct list_head\tqtd_list;\n\n\tINIT_LIST_HEAD (&qtd_list);\n\n\tswitch (usb_pipetype (urb->pipe)) {\n\tcase PIPE_CONTROL:\n\t\t \n\t\tif (urb->transfer_buffer_length > (16 * 1024))\n\t\t\treturn -EMSGSIZE;\n\t\tfallthrough;\n\t \n\tdefault:\n\t\tif (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn submit_async(ehci, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_INTERRUPT:\n\t\tif (!qh_urb_transaction (ehci, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn intr_submit(ehci, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (urb->dev->speed == USB_SPEED_HIGH)\n\t\t\treturn itd_submit (ehci, urb, mem_flags);\n\t\telse\n\t\t\treturn sitd_submit (ehci, urb, mem_flags);\n\t}\n}\n\n \n\nstatic int ehci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tstruct ehci_qh\t\t*qh;\n\tunsigned long\t\tflags;\n\tint\t\t\trc;\n\n\tspin_lock_irqsave (&ehci->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\t \n\t} else {\n\t\tqh = (struct ehci_qh *) urb->hcpriv;\n\t\tqh->unlink_reason |= QH_UNLINK_REQUESTED;\n\t\tswitch (qh->qh_state) {\n\t\tcase QH_STATE_LINKED:\n\t\t\tif (usb_pipetype(urb->pipe) == PIPE_INTERRUPT)\n\t\t\t\tstart_unlink_intr(ehci, qh);\n\t\t\telse\n\t\t\t\tstart_unlink_async(ehci, qh);\n\t\t\tbreak;\n\t\tcase QH_STATE_COMPLETING:\n\t\t\tqh->dequeue_during_giveback = 1;\n\t\t\tbreak;\n\t\tcase QH_STATE_UNLINK:\n\t\tcase QH_STATE_UNLINK_WAIT:\n\t\t\t \n\t\t\tbreak;\n\t\tcase QH_STATE_IDLE:\n\t\t\t \n\t\t\tqh_completions(ehci, qh);\n\t\t\tbreak;\n\t\t}\n\t}\ndone:\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n\treturn rc;\n}\n\n \n\n \n\nstatic void\nehci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tunsigned long\t\tflags;\n\tstruct ehci_qh\t\t*qh;\n\n\t \n\t \n\nrescan:\n\tspin_lock_irqsave (&ehci->lock, flags);\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\tgoto done;\n\n\t \n\tif (qh->hw == NULL) {\n\t\tstruct ehci_iso_stream\t*stream = ep->hcpriv;\n\n\t\tif (!list_empty(&stream->td_list))\n\t\t\tgoto idle_timeout;\n\n\t\t \n\t\treserve_release_iso_bandwidth(ehci, stream, -1);\n\t\tkfree(stream);\n\t\tgoto done;\n\t}\n\n\tqh->unlink_reason |= QH_UNLINK_REQUESTED;\n\tswitch (qh->qh_state) {\n\tcase QH_STATE_LINKED:\n\t\tif (list_empty(&qh->qtd_list))\n\t\t\tqh->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;\n\t\telse\n\t\t\tWARN_ON(1);\n\t\tif (usb_endpoint_type(&ep->desc) != USB_ENDPOINT_XFER_INT)\n\t\t\tstart_unlink_async(ehci, qh);\n\t\telse\n\t\t\tstart_unlink_intr(ehci, qh);\n\t\tfallthrough;\n\tcase QH_STATE_COMPLETING:\t \n\tcase QH_STATE_UNLINK:\t\t \n\tcase QH_STATE_UNLINK_WAIT:\nidle_timeout:\n\t\tspin_unlock_irqrestore (&ehci->lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tgoto rescan;\n\tcase QH_STATE_IDLE:\t\t \n\t\tif (qh->clearing_tt)\n\t\t\tgoto idle_timeout;\n\t\tif (list_empty (&qh->qtd_list)) {\n\t\t\tif (qh->ps.bw_uperiod)\n\t\t\t\treserve_release_intr_bandwidth(ehci, qh, -1);\n\t\t\tqh_destroy(ehci, qh);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tehci_err (ehci, \"qh %p (#%02x) state %d%s\\n\",\n\t\t\tqh, ep->desc.bEndpointAddress, qh->qh_state,\n\t\t\tlist_empty (&qh->qtd_list) ? \"\" : \"(has tds)\");\n\t\tbreak;\n\t}\n done:\n\tep->hcpriv = NULL;\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n}\n\nstatic void\nehci_endpoint_reset(struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct ehci_qh\t\t*qh;\n\tint\t\t\teptype = usb_endpoint_type(&ep->desc);\n\tint\t\t\tepnum = usb_endpoint_num(&ep->desc);\n\tint\t\t\tis_out = usb_endpoint_dir_out(&ep->desc);\n\tunsigned long\t\tflags;\n\n\tif (eptype != USB_ENDPOINT_XFER_BULK && eptype != USB_ENDPOINT_XFER_INT)\n\t\treturn;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\tqh = ep->hcpriv;\n\n\t \n\tif (qh) {\n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tWARN_ONCE(1, \"clear_halt for a busy endpoint\\n\");\n\t\t} else {\n\t\t\t \n\t\t\tusb_settoggle(qh->ps.udev, epnum, is_out, 0);\n\t\t\tqh->unlink_reason |= QH_UNLINK_REQUESTED;\n\t\t\tif (eptype == USB_ENDPOINT_XFER_BULK)\n\t\t\t\tstart_unlink_async(ehci, qh);\n\t\t\telse\n\t\t\t\tstart_unlink_intr(ehci, qh);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n}\n\nstatic int ehci_get_frame (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\treturn (ehci_read_frame_index(ehci) >> 3) % ehci->periodic_size;\n}\n\n \n\n \n\nstatic void ehci_remove_device(struct usb_hcd *hcd, struct usb_device *udev)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\n\tspin_lock_irq(&ehci->lock);\n\tdrop_tt(udev);\n\tspin_unlock_irq(&ehci->lock);\n}\n\n \n\n#ifdef\tCONFIG_PM\n\n \nstatic void ehci_zx_wakeup_clear(struct ehci_hcd *ehci)\n{\n\tu32 __iomem\t*reg = &ehci->regs->port_status[4];\n\tu32 \t\tt1 = ehci_readl(ehci, reg);\n\n\tt1 &= (u32)~0xf0000;\n\tt1 |= PORT_TEST_FORCE;\n\tehci_writel(ehci, t1, reg);\n\tt1 = ehci_readl(ehci, reg);\n\tmsleep(1);\n\tt1 &= (u32)~0xf0000;\n\tehci_writel(ehci, t1, reg);\n\tehci_readl(ehci, reg);\n\tmsleep(1);\n\tt1 = ehci_readl(ehci, reg);\n\tehci_writel(ehci, t1 | PORT_CSC, reg);\n\tehci_readl(ehci, reg);\n}\n\n \n\n \n\nint ehci_suspend(struct usb_hcd *hcd, bool do_wakeup)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\n\tif (time_before(jiffies, ehci->next_statechange))\n\t\tmsleep(10);\n\n\t \n\tehci_prepare_ports_for_controller_suspend(ehci, do_wakeup);\n\n\tspin_lock_irq(&ehci->lock);\n\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\t(void) ehci_readl(ehci, &ehci->regs->intr_enable);\n\n\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tspin_unlock_irq(&ehci->lock);\n\n\tsynchronize_irq(hcd->irq);\n\n\t \n\tif (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {\n\t\tehci_resume(hcd, false);\n\t\treturn -EBUSY;\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ehci_suspend);\n\n \nint ehci_resume(struct usb_hcd *hcd, bool force_reset)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\n\tif (time_before(jiffies, ehci->next_statechange))\n\t\tmsleep(100);\n\n\t \n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\tif (ehci->shutdown)\n\t\treturn 0;\t\t \n\n\tif (ehci->zx_wakeup_clear_needed)\n\t\tehci_zx_wakeup_clear(ehci);\n\n\t \n\tif (ehci_readl(ehci, &ehci->regs->configured_flag) == FLAG_CF &&\n\t\t\t!force_reset) {\n\t\tint\tmask = INTR_MASK;\n\n\t\tehci_prepare_ports_for_controller_resume(ehci);\n\n\t\tspin_lock_irq(&ehci->lock);\n\t\tif (ehci->shutdown)\n\t\t\tgoto skip;\n\n\t\tif (!hcd->self.root_hub->do_remote_wakeup)\n\t\t\tmask &= ~STS_PCD;\n\t\tehci_writel(ehci, mask, &ehci->regs->intr_enable);\n\t\tehci_readl(ehci, &ehci->regs->intr_enable);\n skip:\n\t\tspin_unlock_irq(&ehci->lock);\n\t\treturn 0;\n\t}\n\n\t \n\tusb_root_hub_lost_power(hcd->self.root_hub);\n\t(void) ehci_halt(ehci);\n\t(void) ehci_reset(ehci);\n\n\tspin_lock_irq(&ehci->lock);\n\tif (ehci->shutdown)\n\t\tgoto skip;\n\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\tehci_writel(ehci, FLAG_CF, &ehci->regs->configured_flag);\n\tehci_readl(ehci, &ehci->regs->command);\t \n\n\tehci->rh_state = EHCI_RH_SUSPENDED;\n\tspin_unlock_irq(&ehci->lock);\n\n\treturn 1;\n}\nEXPORT_SYMBOL_GPL(ehci_resume);\n\n#endif\n\n \n\n \n\nstatic const struct hc_driver ehci_hc_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"EHCI Host Controller\",\n\t.hcd_priv_size =\tsizeof(struct ehci_hcd),\n\n\t \n\t.irq =\t\t\tehci_irq,\n\t.flags =\t\tHCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n\t \n\t.reset =\t\tehci_setup,\n\t.start =\t\tehci_run,\n\t.stop =\t\t\tehci_stop,\n\t.shutdown =\t\tehci_shutdown,\n\n\t \n\t.urb_enqueue =\t\tehci_urb_enqueue,\n\t.urb_dequeue =\t\tehci_urb_dequeue,\n\t.endpoint_disable =\tehci_endpoint_disable,\n\t.endpoint_reset =\tehci_endpoint_reset,\n\t.clear_tt_buffer_complete =\tehci_clear_tt_buffer_complete,\n\n\t \n\t.get_frame_number =\tehci_get_frame,\n\n\t \n\t.hub_status_data =\tehci_hub_status_data,\n\t.hub_control =\t\tehci_hub_control,\n\t.bus_suspend =\t\tehci_bus_suspend,\n\t.bus_resume =\t\tehci_bus_resume,\n\t.relinquish_port =\tehci_relinquish_port,\n\t.port_handed_over =\tehci_port_handed_over,\n\t.get_resuming_ports =\tehci_get_resuming_ports,\n\n\t \n\t.free_dev =\t\tehci_remove_device,\n#ifdef CONFIG_USB_HCD_TEST_MODE\n\t \n\t.submit_single_step_set_feature\t= ehci_submit_single_step_set_feature,\n#endif\n};\n\nvoid ehci_init_driver(struct hc_driver *drv,\n\t\tconst struct ehci_driver_overrides *over)\n{\n\t \n\t*drv = ehci_hc_driver;\n\n\tif (over) {\n\t\tdrv->hcd_priv_size += over->extra_priv_size;\n\t\tif (over->reset)\n\t\t\tdrv->reset = over->reset;\n\t\tif (over->port_power)\n\t\t\tdrv->port_power = over->port_power;\n\t}\n}\nEXPORT_SYMBOL_GPL(ehci_init_driver);\n\n \n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR (DRIVER_AUTHOR);\nMODULE_LICENSE (\"GPL\");\n\n#ifdef CONFIG_USB_EHCI_SH\n#include \"ehci-sh.c\"\n#endif\n\n#ifdef CONFIG_PPC_PS3\n#include \"ehci-ps3.c\"\n#endif\n\n#ifdef CONFIG_USB_EHCI_HCD_PPC_OF\n#include \"ehci-ppc-of.c\"\n#endif\n\n#ifdef CONFIG_XPS_USB_HCD_XILINX\n#include \"ehci-xilinx-of.c\"\n#endif\n\n#ifdef CONFIG_SPARC_LEON\n#include \"ehci-grlib.c\"\n#endif\n\nstatic struct platform_driver * const platform_drivers[] = {\n#ifdef CONFIG_USB_EHCI_SH\n\t&ehci_hcd_sh_driver,\n#endif\n#ifdef CONFIG_USB_EHCI_HCD_PPC_OF\n\t&ehci_hcd_ppc_of_driver,\n#endif\n#ifdef CONFIG_XPS_USB_HCD_XILINX\n\t&ehci_hcd_xilinx_of_driver,\n#endif\n#ifdef CONFIG_SPARC_LEON\n\t&ehci_grlib_driver,\n#endif\n};\n\nstatic int __init ehci_hcd_init(void)\n{\n\tint retval = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tset_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\n\tif (test_bit(USB_UHCI_LOADED, &usb_hcds_loaded) ||\n\t\t\ttest_bit(USB_OHCI_LOADED, &usb_hcds_loaded))\n\t\tprintk(KERN_WARNING \"Warning! ehci_hcd should always be loaded\"\n\t\t\t\t\" before uhci_hcd and ohci_hcd, not after\\n\");\n\n\tpr_debug(\"%s: block sizes: qh %zd qtd %zd itd %zd sitd %zd\\n\",\n\t\t hcd_name,\n\t\t sizeof(struct ehci_qh), sizeof(struct ehci_qtd),\n\t\t sizeof(struct ehci_itd), sizeof(struct ehci_sitd));\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\tehci_debug_root = debugfs_create_dir(\"ehci\", usb_debug_root);\n#endif\n\n\tretval = platform_register_drivers(platform_drivers, ARRAY_SIZE(platform_drivers));\n\tif (retval < 0)\n\t\tgoto clean0;\n\n#ifdef CONFIG_PPC_PS3\n\tretval = ps3_ehci_driver_register(&ps3_ehci_driver);\n\tif (retval < 0)\n\t\tgoto clean1;\n#endif\n\n\treturn 0;\n\n#ifdef CONFIG_PPC_PS3\nclean1:\n#endif\n\tplatform_unregister_drivers(platform_drivers, ARRAY_SIZE(platform_drivers));\nclean0:\n#ifdef CONFIG_DYNAMIC_DEBUG\n\tdebugfs_remove(ehci_debug_root);\n\tehci_debug_root = NULL;\n#endif\n\tclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\n\treturn retval;\n}\nmodule_init(ehci_hcd_init);\n\nstatic void __exit ehci_hcd_cleanup(void)\n{\n#ifdef CONFIG_PPC_PS3\n\tps3_ehci_driver_unregister(&ps3_ehci_driver);\n#endif\n\tplatform_unregister_drivers(platform_drivers, ARRAY_SIZE(platform_drivers));\n#ifdef CONFIG_DYNAMIC_DEBUG\n\tdebugfs_remove(ehci_debug_root);\n#endif\n\tclear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);\n}\nmodule_exit(ehci_hcd_cleanup);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}