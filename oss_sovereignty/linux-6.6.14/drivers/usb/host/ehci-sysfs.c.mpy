{
  "module_name": "ehci-sysfs.c",
  "hash_id": "c1bac2abf1e7f0581b3be0bfc2edb6bfdfbdbc132edfcaa89d073421fc2e63f1",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-sysfs.c",
  "human_readable_source": "\n \n\n \n\n\n \nstatic ssize_t companion_show(struct device *dev,\n\t\t\t      struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct ehci_hcd\t\t*ehci;\n\tint\t\t\tnports, index, n;\n\tint\t\t\tcount = PAGE_SIZE;\n\tchar\t\t\t*ptr = buf;\n\n\tehci = hcd_to_ehci(dev_get_drvdata(dev));\n\tnports = HCS_N_PORTS(ehci->hcs_params);\n\n\tfor (index = 0; index < nports; ++index) {\n\t\tif (test_bit(index, &ehci->companion_ports)) {\n\t\t\tn = scnprintf(ptr, count, \"%d\\n\", index + 1);\n\t\t\tptr += n;\n\t\t\tcount -= n;\n\t\t}\n\t}\n\treturn ptr - buf;\n}\n\n \nstatic ssize_t companion_store(struct device *dev,\n\t\t\t       struct device_attribute *attr,\n\t\t\t       const char *buf, size_t count)\n{\n\tstruct ehci_hcd\t\t*ehci;\n\tint\t\t\tportnum, new_owner;\n\n\tehci = hcd_to_ehci(dev_get_drvdata(dev));\n\tnew_owner = PORT_OWNER;\t\t \n\tif (sscanf(buf, \"%d\", &portnum) != 1)\n\t\treturn -EINVAL;\n\tif (portnum < 0) {\n\t\tportnum = - portnum;\n\t\tnew_owner = 0;\t\t \n\t}\n\tif (portnum <= 0 || portnum > HCS_N_PORTS(ehci->hcs_params))\n\t\treturn -ENOENT;\n\tportnum--;\n\tif (new_owner)\n\t\tset_bit(portnum, &ehci->companion_ports);\n\telse\n\t\tclear_bit(portnum, &ehci->companion_ports);\n\tset_owner(ehci, portnum, new_owner);\n\treturn count;\n}\nstatic DEVICE_ATTR_RW(companion);\n\n\n \nstatic ssize_t uframe_periodic_max_show(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\tstruct ehci_hcd\t\t*ehci;\n\tint\t\t\tn;\n\n\tehci = hcd_to_ehci(dev_get_drvdata(dev));\n\tn = scnprintf(buf, PAGE_SIZE, \"%d\\n\", ehci->uframe_periodic_max);\n\treturn n;\n}\n\n\nstatic ssize_t uframe_periodic_max_store(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct ehci_hcd\t\t*ehci;\n\tunsigned\t\tuframe_periodic_max;\n\tunsigned\t\tuframe;\n\tunsigned long\t\tflags;\n\tssize_t\t\t\tret;\n\n\tehci = hcd_to_ehci(dev_get_drvdata(dev));\n\tif (kstrtouint(buf, 0, &uframe_periodic_max) < 0)\n\t\treturn -EINVAL;\n\n\tif (uframe_periodic_max < 100 || uframe_periodic_max >= 125) {\n\t\tehci_info(ehci, \"rejecting invalid request for \"\n\t\t\t\t\"uframe_periodic_max=%u\\n\", uframe_periodic_max);\n\t\treturn -EINVAL;\n\t}\n\n\tret = -EINVAL;\n\n\t \n\tspin_lock_irqsave (&ehci->lock, flags);\n\n\t \n\tif (uframe_periodic_max < ehci->uframe_periodic_max) {\n\t\tu8\t\tallocated_max = 0;\n\n\t\tfor (uframe = 0; uframe < EHCI_BANDWIDTH_SIZE; ++uframe)\n\t\t\tallocated_max = max(allocated_max,\n\t\t\t\t\tehci->bandwidth[uframe]);\n\n\t\tif (allocated_max > uframe_periodic_max) {\n\t\t\tehci_info(ehci,\n\t\t\t\t\"cannot decrease uframe_periodic_max because \"\n\t\t\t\t\"periodic bandwidth is already allocated \"\n\t\t\t\t\"(%u > %u)\\n\",\n\t\t\t\tallocated_max, uframe_periodic_max);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\t \n\n\tehci_info(ehci, \"setting max periodic bandwidth to %u%% \"\n\t\t\t\"(== %u usec/uframe)\\n\",\n\t\t\t100*uframe_periodic_max/125, uframe_periodic_max);\n\n\tif (uframe_periodic_max != 100)\n\t\tehci_warn(ehci, \"max periodic bandwidth set is non-standard\\n\");\n\n\tehci->uframe_periodic_max = uframe_periodic_max;\n\tret = count;\n\nout_unlock:\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n\treturn ret;\n}\nstatic DEVICE_ATTR_RW(uframe_periodic_max);\n\n\nstatic inline int create_sysfs_files(struct ehci_hcd *ehci)\n{\n\tstruct device\t*controller = ehci_to_hcd(ehci)->self.controller;\n\tint\ti = 0;\n\n\t \n\tif (!ehci_is_TDI(ehci))\n\t\ti = device_create_file(controller, &dev_attr_companion);\n\tif (i)\n\t\tgoto out;\n\n\ti = device_create_file(controller, &dev_attr_uframe_periodic_max);\nout:\n\treturn i;\n}\n\nstatic inline void remove_sysfs_files(struct ehci_hcd *ehci)\n{\n\tstruct device\t*controller = ehci_to_hcd(ehci)->self.controller;\n\n\t \n\tif (!ehci_is_TDI(ehci))\n\t\tdevice_remove_file(controller, &dev_attr_companion);\n\n\tdevice_remove_file(controller, &dev_attr_uframe_periodic_max);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}