{
  "module_name": "sl811-hcd.c",
  "hash_id": "6c557d1a11e8eba5fd24b047ead7ccc30362619bdb98a97bcb507873b2feae95",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/sl811-hcd.c",
  "human_readable_source": "\n \n\n \n\n#undef\tVERBOSE\n#undef\tPACKET_TRACE\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/sl811.h>\n#include <linux/usb/hcd.h>\n#include <linux/platform_device.h>\n#include <linux/prefetch.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\n#include \"sl811.h\"\n\n\nMODULE_DESCRIPTION(\"SL811HS USB Host Controller Driver\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:sl811-hcd\");\n\n#define DRIVER_VERSION\t\"19 May 2005\"\n\n \n#undef\tUSE_B\n\n \n#define\tQUIRK3\n\nstatic const char hcd_name[] = \"sl811-hcd\";\n\n \n\nstatic void port_power(struct sl811 *sl811, int is_on)\n{\n\tstruct usb_hcd\t*hcd = sl811_to_hcd(sl811);\n\n\t \n\tif (is_on) {\n\t\tif (sl811->port1 & USB_PORT_STAT_POWER)\n\t\t\treturn;\n\n\t\tsl811->port1 = USB_PORT_STAT_POWER;\n\t\tsl811->irq_enable = SL11H_INTMASK_INSRMV;\n\t} else {\n\t\tsl811->port1 = 0;\n\t\tsl811->irq_enable = 0;\n\t\thcd->state = HC_STATE_HALT;\n\t}\n\tsl811->ctrl1 = 0;\n\tsl811_write(sl811, SL11H_IRQ_ENABLE, 0);\n\tsl811_write(sl811, SL11H_IRQ_STATUS, ~0);\n\n\tif (sl811->board && sl811->board->port_power) {\n\t\t \n\t\tdev_dbg(hcd->self.controller, \"power %s\\n\",\n\t\t\tis_on ? \"on\" : \"off\");\n\t\tsl811->board->port_power(hcd->self.controller, is_on);\n\t}\n\n\t \n\tif (sl811->board && sl811->board->reset)\n\t\tsl811->board->reset(hcd->self.controller);\n\telse {\n\t\tsl811_write(sl811, SL11H_CTLREG1, SL11H_CTL1MASK_SE0);\n\t\tmdelay(20);\n\t}\n\n\tsl811_write(sl811, SL11H_IRQ_ENABLE, 0);\n\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\tsl811_write(sl811, SL811HS_CTLREG2, SL811HS_CTL2_INIT);\n\tsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\n\n\t \n}\n\n \n\n \n\n \nstatic void setup_packet(\n\tstruct sl811\t\t*sl811,\n\tstruct sl811h_ep\t*ep,\n\tstruct urb\t\t*urb,\n\tu8\t\t\tbank,\n\tu8\t\t\tcontrol\n)\n{\n\tu8\t\t\taddr;\n\tu8\t\t\tlen;\n\tvoid __iomem\t\t*data_reg;\n\n\taddr = SL811HS_PACKET_BUF(bank == 0);\n\tlen = sizeof(struct usb_ctrlrequest);\n\tdata_reg = sl811->data_reg;\n\tsl811_write_buf(sl811, addr, urb->setup_packet, len);\n\n\t \n\tsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\n\twriteb(len, data_reg);\n\twriteb(SL_SETUP  , data_reg);\n\twriteb(usb_pipedevice(urb->pipe), data_reg);\n\n\t \n\tsl811_write(sl811, bank + SL11H_HOSTCTLREG,\n\t\t\tcontrol | SL11H_HCTLMASK_OUT);\n\tep->length = 0;\n\tPACKET(\"SETUP qh%p\\n\", ep);\n}\n\n \nstatic void status_packet(\n\tstruct sl811\t\t*sl811,\n\tstruct sl811h_ep\t*ep,\n\tstruct urb\t\t*urb,\n\tu8\t\t\tbank,\n\tu8\t\t\tcontrol\n)\n{\n\tint\t\t\tdo_out;\n\tvoid __iomem\t\t*data_reg;\n\n\tdo_out = urb->transfer_buffer_length && usb_pipein(urb->pipe);\n\tdata_reg = sl811->data_reg;\n\n\t \n\tsl811_write(sl811, bank + SL11H_BUFADDRREG, 0);\n\twriteb(0, data_reg);\n\twriteb((do_out ? SL_OUT : SL_IN)  , data_reg);\n\twriteb(usb_pipedevice(urb->pipe), data_reg);\n\n\t \n\tcontrol |= SL11H_HCTLMASK_TOGGLE;\n\tif (do_out)\n\t\tcontrol |= SL11H_HCTLMASK_OUT;\n\tsl811_write(sl811, bank + SL11H_HOSTCTLREG, control);\n\tep->length = 0;\n\tPACKET(\"STATUS%s/%s qh%p\\n\", ep->nak_count ? \"/retry\" : \"\",\n\t\t\tdo_out ? \"out\" : \"in\", ep);\n}\n\n \nstatic void in_packet(\n\tstruct sl811\t\t*sl811,\n\tstruct sl811h_ep\t*ep,\n\tstruct urb\t\t*urb,\n\tu8\t\t\tbank,\n\tu8\t\t\tcontrol\n)\n{\n\tu8\t\t\taddr;\n\tu8\t\t\tlen;\n\tvoid __iomem\t\t*data_reg;\n\n\t \n\tlen = ep->maxpacket;\n\taddr = SL811HS_PACKET_BUF(bank == 0);\n\tif (!(control & SL11H_HCTLMASK_ISOCH)\n\t\t\t&& usb_gettoggle(urb->dev, ep->epnum, 0))\n\t\tcontrol |= SL11H_HCTLMASK_TOGGLE;\n\tdata_reg = sl811->data_reg;\n\n\t \n\tsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\n\twriteb(len, data_reg);\n\twriteb(SL_IN | ep->epnum, data_reg);\n\twriteb(usb_pipedevice(urb->pipe), data_reg);\n\n\tsl811_write(sl811, bank + SL11H_HOSTCTLREG, control);\n\tep->length = min_t(u32, len,\n\t\t\turb->transfer_buffer_length - urb->actual_length);\n\tPACKET(\"IN%s/%d qh%p len%d\\n\", ep->nak_count ? \"/retry\" : \"\",\n\t\t\t!!usb_gettoggle(urb->dev, ep->epnum, 0), ep, len);\n}\n\n \nstatic void out_packet(\n\tstruct sl811\t\t*sl811,\n\tstruct sl811h_ep\t*ep,\n\tstruct urb\t\t*urb,\n\tu8\t\t\tbank,\n\tu8\t\t\tcontrol\n)\n{\n\tvoid\t\t\t*buf;\n\tu8\t\t\taddr;\n\tu8\t\t\tlen;\n\tvoid __iomem\t\t*data_reg;\n\n\tbuf = urb->transfer_buffer + urb->actual_length;\n\tprefetch(buf);\n\n\tlen = min_t(u32, ep->maxpacket,\n\t\t\turb->transfer_buffer_length - urb->actual_length);\n\n\tif (!(control & SL11H_HCTLMASK_ISOCH)\n\t\t\t&& usb_gettoggle(urb->dev, ep->epnum, 1))\n\t\tcontrol |= SL11H_HCTLMASK_TOGGLE;\n\taddr = SL811HS_PACKET_BUF(bank == 0);\n\tdata_reg = sl811->data_reg;\n\n\tsl811_write_buf(sl811, addr, buf, len);\n\n\t \n\tsl811_write(sl811, bank + SL11H_BUFADDRREG, addr);\n\twriteb(len, data_reg);\n\twriteb(SL_OUT | ep->epnum, data_reg);\n\twriteb(usb_pipedevice(urb->pipe), data_reg);\n\n\tsl811_write(sl811, bank + SL11H_HOSTCTLREG,\n\t\t\tcontrol | SL11H_HCTLMASK_OUT);\n\tep->length = len;\n\tPACKET(\"OUT%s/%d qh%p len%d\\n\", ep->nak_count ? \"/retry\" : \"\",\n\t\t\t!!usb_gettoggle(urb->dev, ep->epnum, 1), ep, len);\n}\n\n \n\n \n\nstatic inline void sofirq_on(struct sl811 *sl811)\n{\n\tif (sl811->irq_enable & SL11H_INTMASK_SOFINTR)\n\t\treturn;\n\tdev_dbg(sl811_to_hcd(sl811)->self.controller, \"sof irq on\\n\");\n\tsl811->irq_enable |= SL11H_INTMASK_SOFINTR;\n}\n\nstatic inline void sofirq_off(struct sl811 *sl811)\n{\n\tif (!(sl811->irq_enable & SL11H_INTMASK_SOFINTR))\n\t\treturn;\n\tdev_dbg(sl811_to_hcd(sl811)->self.controller, \"sof irq off\\n\");\n\tsl811->irq_enable &= ~SL11H_INTMASK_SOFINTR;\n}\n\n \n\n \nstatic struct sl811h_ep\t*start(struct sl811 *sl811, u8 bank)\n{\n\tstruct sl811h_ep\t*ep;\n\tstruct urb\t\t*urb;\n\tint\t\t\tfclock;\n\tu8\t\t\tcontrol;\n\n\t \n\tif (sl811->next_periodic) {\n\t\tep = sl811->next_periodic;\n\t\tsl811->next_periodic = ep->next;\n\t} else {\n\t\tif (sl811->next_async)\n\t\t\tep = sl811->next_async;\n\t\telse if (!list_empty(&sl811->async))\n\t\t\tep = container_of(sl811->async.next,\n\t\t\t\t\tstruct sl811h_ep, schedule);\n\t\telse {\n\t\t\t \n\t\t\treturn NULL;\n\t\t}\n\n#ifdef USE_B\n\t\tif ((bank && sl811->active_b == ep) || sl811->active_a == ep)\n\t\t\treturn NULL;\n#endif\n\n\t\tif (ep->schedule.next == &sl811->async)\n\t\t\tsl811->next_async = NULL;\n\t\telse\n\t\t\tsl811->next_async = container_of(ep->schedule.next,\n\t\t\t\t\tstruct sl811h_ep, schedule);\n\t}\n\n\tif (unlikely(list_empty(&ep->hep->urb_list))) {\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\"empty %p queue?\\n\", ep);\n\t\treturn NULL;\n\t}\n\n\turb = container_of(ep->hep->urb_list.next, struct urb, urb_list);\n\tcontrol = ep->defctrl;\n\n\t \n\tfclock = sl811_read(sl811, SL11H_SOFTMRREG) << 6;\n\tfclock -= 100;\t\t \n\tif (urb->dev->speed == USB_SPEED_LOW) {\n\t\tif (control & SL11H_HCTLMASK_PREAMBLE) {\n\t\t\t \n\t\t\tfclock -= 800;\n\t\t}\n\t\tfclock -= ep->maxpacket << 8;\n\n\t\t \n\t\tif (fclock < 0) {\n\t\t\tif (ep->period)\n\t\t\t\tsl811->stat_overrun++;\n\t\t\tsofirq_on(sl811);\n\t\t\treturn NULL;\n\t\t}\n\t} else {\n\t\tfclock -= 12000 / 19;\t \n\t\tif (fclock < 0) {\n\t\t\tif (ep->period)\n\t\t\t\tsl811->stat_overrun++;\n\t\t\tcontrol |= SL11H_HCTLMASK_AFTERSOF;\n\n\t\t \n\t\t} else if (ep->nak_count)\n\t\t\tcontrol |= SL11H_HCTLMASK_AFTERSOF;\n\t}\n\n\n\tswitch (ep->nextpid) {\n\tcase USB_PID_IN:\n\t\tin_packet(sl811, ep, urb, bank, control);\n\t\tbreak;\n\tcase USB_PID_OUT:\n\t\tout_packet(sl811, ep, urb, bank, control);\n\t\tbreak;\n\tcase USB_PID_SETUP:\n\t\tsetup_packet(sl811, ep, urb, bank, control);\n\t\tbreak;\n\tcase USB_PID_ACK:\t\t \n\t\tstatus_packet(sl811, ep, urb, bank, control);\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\"bad ep%p pid %02x\\n\", ep, ep->nextpid);\n\t\tep = NULL;\n\t}\n\treturn ep;\n}\n\n#define MIN_JIFFIES\t((msecs_to_jiffies(2) > 1) ? msecs_to_jiffies(2) : 2)\n\nstatic inline void start_transfer(struct sl811 *sl811)\n{\n\tif (sl811->port1 & USB_PORT_STAT_SUSPEND)\n\t\treturn;\n\tif (sl811->active_a == NULL) {\n\t\tsl811->active_a = start(sl811, SL811_EP_A(SL811_HOST_BUF));\n\t\tif (sl811->active_a != NULL)\n\t\t\tsl811->jiffies_a = jiffies + MIN_JIFFIES;\n\t}\n#ifdef USE_B\n\tif (sl811->active_b == NULL) {\n\t\tsl811->active_b = start(sl811, SL811_EP_B(SL811_HOST_BUF));\n\t\tif (sl811->active_b != NULL)\n\t\t\tsl811->jiffies_b = jiffies + MIN_JIFFIES;\n\t}\n#endif\n}\n\nstatic void finish_request(\n\tstruct sl811\t\t*sl811,\n\tstruct sl811h_ep\t*ep,\n\tstruct urb\t\t*urb,\n\tint\t\t\tstatus\n) __releases(sl811->lock) __acquires(sl811->lock)\n{\n\tunsigned\t\ti;\n\n\tif (usb_pipecontrol(urb->pipe))\n\t\tep->nextpid = USB_PID_SETUP;\n\n\tusb_hcd_unlink_urb_from_ep(sl811_to_hcd(sl811), urb);\n\tspin_unlock(&sl811->lock);\n\tusb_hcd_giveback_urb(sl811_to_hcd(sl811), urb, status);\n\tspin_lock(&sl811->lock);\n\n\t \n\tif (!list_empty(&ep->hep->urb_list))\n\t\treturn;\n\n\t \n\tif (!list_empty(&ep->schedule)) {\n\t\tlist_del_init(&ep->schedule);\n\t\tif (ep == sl811->next_async)\n\t\t\tsl811->next_async = NULL;\n\t\treturn;\n\t}\n\n\t \n\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\"deschedule qh%d/%p branch %d\\n\", ep->period, ep, ep->branch);\n\tfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\n\t\tstruct sl811h_ep\t*temp;\n\t\tstruct sl811h_ep\t**prev = &sl811->periodic[i];\n\n\t\twhile (*prev && ((temp = *prev) != ep))\n\t\t\tprev = &temp->next;\n\t\tif (*prev)\n\t\t\t*prev = ep->next;\n\t\tsl811->load[i] -= ep->load;\n\t}\n\tep->branch = PERIODIC_SIZE;\n\tsl811->periodic_count--;\n\tsl811_to_hcd(sl811)->self.bandwidth_allocated\n\t\t-= ep->load / ep->period;\n\tif (ep == sl811->next_periodic)\n\t\tsl811->next_periodic = ep->next;\n\n\t \n\tif (sl811->periodic_count == 0)\n\t\tsofirq_off(sl811);\n}\n\nstatic void\ndone(struct sl811 *sl811, struct sl811h_ep *ep, u8 bank)\n{\n\tu8\t\t\tstatus;\n\tstruct urb\t\t*urb;\n\tint\t\t\turbstat = -EINPROGRESS;\n\n\tif (unlikely(!ep))\n\t\treturn;\n\n\tstatus = sl811_read(sl811, bank + SL11H_PKTSTATREG);\n\n\turb = container_of(ep->hep->urb_list.next, struct urb, urb_list);\n\n\t \n\tif (status & SL11H_STATMASK_NAK) {\n\t\t\n\t\tif (!ep->period)\n\t\t\tep->nak_count++;\n\t\tep->error_count = 0;\n\n\t \n\t} else if (status & SL11H_STATMASK_ACK) {\n\t\tstruct usb_device\t*udev = urb->dev;\n\t\tint\t\t\tlen;\n\t\tunsigned char\t\t*buf;\n\n\t\t \n\n\t\tep->nak_count = ep->error_count = 0;\n\t\tswitch (ep->nextpid) {\n\t\tcase USB_PID_OUT:\n\t\t\t\n\t\t\turb->actual_length += ep->length;\n\t\t\tusb_dotoggle(udev, ep->epnum, 1);\n\t\t\tif (urb->actual_length\n\t\t\t\t\t== urb->transfer_buffer_length) {\n\t\t\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\t\t\tep->nextpid = USB_PID_ACK;\n\n\t\t\t\t \n\t\t\t\telse if (ep->length < ep->maxpacket\n\t\t\t\t\t\t|| !(urb->transfer_flags\n\t\t\t\t\t\t\t& URB_ZERO_PACKET))\n\t\t\t\t\turbstat = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PID_IN:\n\t\t\t\n\t\t\tbuf = urb->transfer_buffer + urb->actual_length;\n\t\t\tprefetchw(buf);\n\t\t\tlen = ep->maxpacket - sl811_read(sl811,\n\t\t\t\t\t\tbank + SL11H_XFERCNTREG);\n\t\t\tif (len > ep->length) {\n\t\t\t\tlen = ep->length;\n\t\t\t\turbstat = -EOVERFLOW;\n\t\t\t}\n\t\t\turb->actual_length += len;\n\t\t\tsl811_read_buf(sl811, SL811HS_PACKET_BUF(bank == 0),\n\t\t\t\t\tbuf, len);\n\t\t\tusb_dotoggle(udev, ep->epnum, 0);\n\t\t\tif (urbstat == -EINPROGRESS &&\n\t\t\t\t\t(len < ep->maxpacket ||\n\t\t\t\t\t\turb->actual_length ==\n\t\t\t\t\t\turb->transfer_buffer_length)) {\n\t\t\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\t\telse\n\t\t\t\t\turbstat = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PID_SETUP:\n\t\t\t\n\t\t\tif (urb->transfer_buffer_length == urb->actual_length)\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\telse if (usb_pipeout(urb->pipe)) {\n\t\t\t\tusb_settoggle(udev, 0, 1, 1);\n\t\t\t\tep->nextpid = USB_PID_OUT;\n\t\t\t} else {\n\t\t\t\tusb_settoggle(udev, 0, 0, 1);\n\t\t\t\tep->nextpid = USB_PID_IN;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PID_ACK:\n\t\t\t\n\t\t\turbstat = 0;\n\t\t\tbreak;\n\t\t}\n\n\t \n\t} else if (status & SL11H_STATMASK_STALL) {\n\t\tPACKET(\"...STALL_%02x qh%p\\n\", bank, ep);\n\t\tep->nak_count = ep->error_count = 0;\n\t\turbstat = -EPIPE;\n\n\t \n\t} else if (++ep->error_count >= 3) {\n\t\tif (status & SL11H_STATMASK_TMOUT)\n\t\t\turbstat = -ETIME;\n\t\telse if (status & SL11H_STATMASK_OVF)\n\t\t\turbstat = -EOVERFLOW;\n\t\telse\n\t\t\turbstat = -EPROTO;\n\t\tep->error_count = 0;\n\t\tPACKET(\"...3STRIKES_%02x %02x qh%p stat %d\\n\",\n\t\t\t\tbank, status, ep, urbstat);\n\t}\n\n\tif (urbstat != -EINPROGRESS || urb->unlinked)\n\t\tfinish_request(sl811, ep, urb, urbstat);\n}\n\nstatic inline u8 checkdone(struct sl811 *sl811)\n{\n\tu8\tctl;\n\tu8\tirqstat = 0;\n\n\tif (sl811->active_a && time_before_eq(sl811->jiffies_a, jiffies)) {\n\t\tctl = sl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG));\n\t\tif (ctl & SL11H_HCTLMASK_ARM)\n\t\t\tsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\"%s DONE_A: ctrl %02x sts %02x\\n\",\n\t\t\t(ctl & SL11H_HCTLMASK_ARM) ? \"timeout\" : \"lost\",\n\t\t\tctl,\n\t\t\tsl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));\n\t\tirqstat |= SL11H_INTMASK_DONE_A;\n\t}\n#ifdef\tUSE_B\n\tif (sl811->active_b && time_before_eq(sl811->jiffies_b, jiffies)) {\n\t\tctl = sl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG));\n\t\tif (ctl & SL11H_HCTLMASK_ARM)\n\t\t\tsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\"%s DONE_B: ctrl %02x sts %02x\\n\",\n\t\t\t(ctl & SL11H_HCTLMASK_ARM) ? \"timeout\" : \"lost\",\n\t\t\tctl,\n\t\t\tsl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));\n\t\tirqstat |= SL11H_INTMASK_DONE_A;\n\t}\n#endif\n\treturn irqstat;\n}\n\nstatic irqreturn_t sl811h_irq(struct usb_hcd *hcd)\n{\n\tstruct sl811\t*sl811 = hcd_to_sl811(hcd);\n\tu8\t\tirqstat;\n\tirqreturn_t\tret = IRQ_NONE;\n\tunsigned\tretries = 5;\n\n\tspin_lock(&sl811->lock);\n\nretry:\n\tirqstat = sl811_read(sl811, SL11H_IRQ_STATUS) & ~SL11H_INTMASK_DP;\n\tif (irqstat) {\n\t\tsl811_write(sl811, SL11H_IRQ_STATUS, irqstat);\n\t\tirqstat &= sl811->irq_enable;\n\t}\n\n#ifdef\tQUIRK2\n\t \n\tif (irqstat == 0) {\n\t\tirqstat = checkdone(sl811);\n\t\tif (irqstat)\n\t\t\tsl811->stat_lost++;\n\t}\n#endif\n\n\t \n\tif (irqstat & SL11H_INTMASK_DONE_A) {\n\t\tdone(sl811, sl811->active_a, SL811_EP_A(SL811_HOST_BUF));\n\t\tsl811->active_a = NULL;\n\t\tsl811->stat_a++;\n\t}\n#ifdef USE_B\n\tif (irqstat & SL11H_INTMASK_DONE_B) {\n\t\tdone(sl811, sl811->active_b, SL811_EP_B(SL811_HOST_BUF));\n\t\tsl811->active_b = NULL;\n\t\tsl811->stat_b++;\n\t}\n#endif\n\tif (irqstat & SL11H_INTMASK_SOFINTR) {\n\t\tunsigned index;\n\n\t\tindex = sl811->frame++ % (PERIODIC_SIZE - 1);\n\t\tsl811->stat_sof++;\n\n\t\t \n\t\tif (sl811->next_periodic) {\n\t\t\t\n\t\t\tsl811->stat_overrun++;\n\t\t}\n\t\tif (sl811->periodic[index])\n\t\t\tsl811->next_periodic = sl811->periodic[index];\n\t}\n\n\t \n\tif (irqstat & SL11H_INTMASK_INSRMV) {\n\t\tsl811->stat_insrmv++;\n\n\t\t \n\t\tsl811->stat_wake = 0;\n\t\tsl811->stat_sof = 0;\n\t\tsl811->stat_a = 0;\n\t\tsl811->stat_b = 0;\n\t\tsl811->stat_lost = 0;\n\n\t\tsl811->ctrl1 = 0;\n\t\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\n\t\tsl811->irq_enable = SL11H_INTMASK_INSRMV;\n\t\tsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\n\n\t\t \n\t\tif (sl811->active_a) {\n\t\t\tsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG), 0);\n\t\t\tfinish_request(sl811, sl811->active_a,\n\t\t\t\tcontainer_of(sl811->active_a\n\t\t\t\t\t\t->hep->urb_list.next,\n\t\t\t\t\tstruct urb, urb_list),\n\t\t\t\t-ESHUTDOWN);\n\t\t\tsl811->active_a = NULL;\n\t\t}\n#ifdef\tUSE_B\n\t\tif (sl811->active_b) {\n\t\t\tsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG), 0);\n\t\t\tfinish_request(sl811, sl811->active_b,\n\t\t\t\tcontainer_of(sl811->active_b\n\t\t\t\t\t\t->hep->urb_list.next,\n\t\t\t\t\tstruct urb, urb_list),\n\t\t\t\tNULL, -ESHUTDOWN);\n\t\t\tsl811->active_b = NULL;\n\t\t}\n#endif\n\n\t\t \n\t\tif (irqstat & SL11H_INTMASK_RD)\n\t\t\tsl811->port1 &= ~USB_PORT_STAT_CONNECTION;\n\t\telse\n\t\t\tsl811->port1 |= USB_PORT_STAT_CONNECTION;\n\n\t\tsl811->port1 |= USB_PORT_STAT_C_CONNECTION << 16;\n\n\t} else if (irqstat & SL11H_INTMASK_RD) {\n\t\tif (sl811->port1 & USB_PORT_STAT_SUSPEND) {\n\t\t\tdev_dbg(hcd->self.controller, \"wakeup\\n\");\n\t\t\tsl811->port1 |= USB_PORT_STAT_C_SUSPEND << 16;\n\t\t\tsl811->stat_wake++;\n\t\t} else\n\t\t\tirqstat &= ~SL11H_INTMASK_RD;\n\t}\n\n\tif (irqstat) {\n\t\tif (sl811->port1 & USB_PORT_STAT_ENABLE)\n\t\t\tstart_transfer(sl811);\n\t\tret = IRQ_HANDLED;\n\t\tif (retries--)\n\t\t\tgoto retry;\n\t}\n\n\tif (sl811->periodic_count == 0 && list_empty(&sl811->async))\n\t\tsofirq_off(sl811);\n\tsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\n\n\tspin_unlock(&sl811->lock);\n\n\treturn ret;\n}\n\n \n\n \n#define\tMAX_PERIODIC_LOAD\t500\t \n\nstatic int balance(struct sl811 *sl811, u16 period, u16 load)\n{\n\tint\ti, branch = -ENOSPC;\n\n\t \n\tfor (i = 0; i < period ; i++) {\n\t\tif (branch < 0 || sl811->load[branch] > sl811->load[i]) {\n\t\t\tint\tj;\n\n\t\t\tfor (j = i; j < PERIODIC_SIZE; j += period) {\n\t\t\t\tif ((sl811->load[j] + load)\n\t\t\t\t\t\t> MAX_PERIODIC_LOAD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < PERIODIC_SIZE)\n\t\t\t\tcontinue;\n\t\t\tbranch = i;\n\t\t}\n\t}\n\treturn branch;\n}\n\n \n\nstatic int sl811h_urb_enqueue(\n\tstruct usb_hcd\t\t*hcd,\n\tstruct urb\t\t*urb,\n\tgfp_t\t\t\tmem_flags\n) {\n\tstruct sl811\t\t*sl811 = hcd_to_sl811(hcd);\n\tstruct usb_device\t*udev = urb->dev;\n\tunsigned int\t\tpipe = urb->pipe;\n\tint\t\t\tis_out = !usb_pipein(pipe);\n\tint\t\t\ttype = usb_pipetype(pipe);\n\tint\t\t\tepnum = usb_pipeendpoint(pipe);\n\tstruct sl811h_ep\t*ep = NULL;\n\tunsigned long\t\tflags;\n\tint\t\t\ti;\n\tint\t\t\tretval;\n\tstruct usb_host_endpoint\t*hep = urb->ep;\n\n#ifndef CONFIG_USB_SL811_HCD_ISO\n\tif (type == PIPE_ISOCHRONOUS)\n\t\treturn -ENOSPC;\n#endif\n\n\t \n\tif (!hep->hcpriv) {\n\t\tep = kzalloc(sizeof *ep, mem_flags);\n\t\tif (ep == NULL)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&sl811->lock, flags);\n\n\t \n\tif (!(sl811->port1 & USB_PORT_STAT_ENABLE)\n\t\t\t|| !HC_IS_RUNNING(hcd->state)) {\n\t\tretval = -ENODEV;\n\t\tkfree(ep);\n\t\tgoto fail_not_linked;\n\t}\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval) {\n\t\tkfree(ep);\n\t\tgoto fail_not_linked;\n\t}\n\n\tif (hep->hcpriv) {\n\t\tkfree(ep);\n\t\tep = hep->hcpriv;\n\t} else if (!ep) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail;\n\n\t} else {\n\t\tINIT_LIST_HEAD(&ep->schedule);\n\t\tep->udev = udev;\n\t\tep->epnum = epnum;\n\t\tep->maxpacket = usb_maxpacket(udev, urb->pipe);\n\t\tep->defctrl = SL11H_HCTLMASK_ARM | SL11H_HCTLMASK_ENABLE;\n\t\tusb_settoggle(udev, epnum, is_out, 0);\n\n\t\tif (type == PIPE_CONTROL)\n\t\t\tep->nextpid = USB_PID_SETUP;\n\t\telse if (is_out)\n\t\t\tep->nextpid = USB_PID_OUT;\n\t\telse\n\t\t\tep->nextpid = USB_PID_IN;\n\n\t\tif (ep->maxpacket > H_MAXPACKET) {\n\t\t\t \n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"dev %d ep%d maxpacket %d\\n\", udev->devnum,\n\t\t\t\tepnum, ep->maxpacket);\n\t\t\tretval = -EINVAL;\n\t\t\tkfree(ep);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (udev->speed == USB_SPEED_LOW) {\n\t\t\t \n\t\t\tif (!(sl811->ctrl1 & SL11H_CTL1MASK_LSPD))\n\t\t\t\tep->defctrl |= SL11H_HCTLMASK_PREAMBLE;\n\t\t}\n\t\tswitch (type) {\n\t\tcase PIPE_ISOCHRONOUS:\n\t\tcase PIPE_INTERRUPT:\n\t\t\tif (urb->interval > PERIODIC_SIZE)\n\t\t\t\turb->interval = PERIODIC_SIZE;\n\t\t\tep->period = urb->interval;\n\t\t\tep->branch = PERIODIC_SIZE;\n\t\t\tif (type == PIPE_ISOCHRONOUS)\n\t\t\t\tep->defctrl |= SL11H_HCTLMASK_ISOCH;\n\t\t\tep->load = usb_calc_bus_time(udev->speed, !is_out,\n\t\t\t\t\t\t     type == PIPE_ISOCHRONOUS,\n\t\t\t\t\t\t     usb_maxpacket(udev, pipe))\n\t\t\t\t\t/ 1000;\n\t\t\tbreak;\n\t\t}\n\n\t\tep->hep = hep;\n\t\thep->hcpriv = ep;\n\t}\n\n\t \n\tswitch (type) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\t\tif (list_empty(&ep->schedule))\n\t\t\tlist_add_tail(&ep->schedule, &sl811->async);\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\tcase PIPE_INTERRUPT:\n\t\turb->interval = ep->period;\n\t\tif (ep->branch < PERIODIC_SIZE) {\n\t\t\t \n\t\t\turb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))\n\t\t\t\t\t\t+ ep->branch;\n\t\t\tbreak;\n\t\t}\n\n\t\tretval = balance(sl811, ep->period, ep->load);\n\t\tif (retval < 0)\n\t\t\tgoto fail;\n\t\tep->branch = retval;\n\t\tretval = 0;\n\t\turb->start_frame = (sl811->frame & (PERIODIC_SIZE - 1))\n\t\t\t\t\t+ ep->branch;\n\n\t\t \n\t\tdev_dbg(hcd->self.controller, \"schedule qh%d/%p branch %d\\n\",\n\t\t\tep->period, ep, ep->branch);\n\t\tfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\n\t\t\tstruct sl811h_ep\t**prev = &sl811->periodic[i];\n\t\t\tstruct sl811h_ep\t*here = *prev;\n\n\t\t\twhile (here && ep != here) {\n\t\t\t\tif (ep->period > here->period)\n\t\t\t\t\tbreak;\n\t\t\t\tprev = &here->next;\n\t\t\t\there = *prev;\n\t\t\t}\n\t\t\tif (ep != here) {\n\t\t\t\tep->next = here;\n\t\t\t\t*prev = ep;\n\t\t\t}\n\t\t\tsl811->load[i] += ep->load;\n\t\t}\n\t\tsl811->periodic_count++;\n\t\thcd->self.bandwidth_allocated += ep->load / ep->period;\n\t\tsofirq_on(sl811);\n\t}\n\n\turb->hcpriv = hep;\n\tstart_transfer(sl811);\n\tsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\nfail:\n\tif (retval)\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\nfail_not_linked:\n\tspin_unlock_irqrestore(&sl811->lock, flags);\n\treturn retval;\n}\n\nstatic int sl811h_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct sl811\t\t*sl811 = hcd_to_sl811(hcd);\n\tstruct usb_host_endpoint *hep;\n\tunsigned long\t\tflags;\n\tstruct sl811h_ep\t*ep;\n\tint\t\t\tretval;\n\n\tspin_lock_irqsave(&sl811->lock, flags);\n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval)\n\t\tgoto fail;\n\n\thep = urb->hcpriv;\n\tep = hep->hcpriv;\n\tif (ep) {\n\t\t \n\t\tif (ep->hep->urb_list.next != &urb->urb_list) {\n\t\t\t \n\n\t\t \n\t\t} else if (sl811->active_a == ep) {\n\t\t\tif (time_before_eq(sl811->jiffies_a, jiffies)) {\n\t\t\t\t \n\t\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\t\"giveup on DONE_A: ctrl %02x sts %02x\\n\",\n\t\t\t\t\tsl811_read(sl811,\n\t\t\t\t\t\tSL811_EP_A(SL11H_HOSTCTLREG)),\n\t\t\t\t\tsl811_read(sl811,\n\t\t\t\t\t\tSL811_EP_A(SL11H_PKTSTATREG)));\n\t\t\t\tsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),\n\t\t\t\t\t\t0);\n\t\t\t\tsl811->active_a = NULL;\n\t\t\t} else\n\t\t\t\turb = NULL;\n#ifdef\tUSE_B\n\t\t} else if (sl811->active_b == ep) {\n\t\t\tif (time_before_eq(sl811->jiffies_a, jiffies)) {\n\t\t\t\t \n\t\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\t\"giveup on DONE_B: ctrl %02x sts %02x\\n\",\n\t\t\t\t\tsl811_read(sl811,\n\t\t\t\t\t\tSL811_EP_B(SL11H_HOSTCTLREG)),\n\t\t\t\t\tsl811_read(sl811,\n\t\t\t\t\t\tSL811_EP_B(SL11H_PKTSTATREG)));\n\t\t\t\tsl811_write(sl811, SL811_EP_B(SL11H_HOSTCTLREG),\n\t\t\t\t\t\t0);\n\t\t\t\tsl811->active_b = NULL;\n\t\t\t} else\n\t\t\t\turb = NULL;\n#endif\n\t\t} else {\n\t\t\t \n\t\t}\n\n\t\tif (urb)\n\t\t\tfinish_request(sl811, ep, urb, 0);\n\t\telse\n\t\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\t\"dequeue, urb %p active %s; wait4irq\\n\", urb,\n\t\t\t\t(sl811->active_a == ep) ? \"A\" : \"B\");\n\t} else\n\t\tretval = -EINVAL;\n fail:\n\tspin_unlock_irqrestore(&sl811->lock, flags);\n\treturn retval;\n}\n\nstatic void\nsl811h_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\n{\n\tstruct sl811h_ep\t*ep = hep->hcpriv;\n\n\tif (!ep)\n\t\treturn;\n\n\t \n\tif (!list_empty(&hep->urb_list))\n\t\tmsleep(3);\n\tif (!list_empty(&hep->urb_list))\n\t\tdev_warn(hcd->self.controller, \"ep %p not empty?\\n\", ep);\n\n\tkfree(ep);\n\thep->hcpriv = NULL;\n}\n\nstatic int\nsl811h_get_frame(struct usb_hcd *hcd)\n{\n\tstruct sl811 *sl811 = hcd_to_sl811(hcd);\n\n\t \n\treturn sl811->frame;\n}\n\n\n \n\n \nstatic int\nsl811h_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct sl811 *sl811 = hcd_to_sl811(hcd);\n#ifdef\tQUIRK3\n\tunsigned long flags;\n\n\t \n\tlocal_irq_save(flags);\n\tif (!timer_pending(&sl811->timer)) {\n\t\tif (sl811h_irq(   hcd) != IRQ_NONE)\n\t\t\tsl811->stat_lost++;\n\t}\n\tlocal_irq_restore(flags);\n#endif\n\n\tif (!(sl811->port1 & (0xffff << 16)))\n\t\treturn 0;\n\n\t \n\t*buf = (1 << 1);\n\treturn 1;\n}\n\nstatic void\nsl811h_hub_descriptor (\n\tstruct sl811\t\t\t*sl811,\n\tstruct usb_hub_descriptor\t*desc\n) {\n\tu16\t\ttemp = 0;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = 1;\n\tdesc->bDescLength = 9;\n\n\t \n\tdesc->bPwrOn2PwrGood = 0;\n\tif (sl811->board && sl811->board->port_power) {\n\t\tdesc->bPwrOn2PwrGood = sl811->board->potpg;\n\t\tif (!desc->bPwrOn2PwrGood)\n\t\t\tdesc->bPwrOn2PwrGood = 10;\n\t\ttemp = HUB_CHAR_INDV_PORT_LPSM;\n\t} else\n\t\ttemp = HUB_CHAR_NO_LPSM;\n\n\t \n\ttemp |= HUB_CHAR_NO_OCPM;\n\n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n\n\t \n\tdesc->u.hs.DeviceRemovable[0] = 0 << 1;\n\tdesc->u.hs.DeviceRemovable[1] = ~0;\n}\n\nstatic void\nsl811h_timer(struct timer_list *t)\n{\n\tstruct sl811 \t*sl811 = from_timer(sl811, t, timer);\n\tunsigned long\tflags;\n\tu8\t\tirqstat;\n\tu8\t\tsignaling = sl811->ctrl1 & SL11H_CTL1MASK_FORCE;\n\tconst u32\tmask = USB_PORT_STAT_CONNECTION\n\t\t\t\t| USB_PORT_STAT_ENABLE\n\t\t\t\t| USB_PORT_STAT_LOW_SPEED;\n\n\tspin_lock_irqsave(&sl811->lock, flags);\n\n\t \n\tsl811->ctrl1 &= ~SL11H_CTL1MASK_FORCE;\n\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\tudelay(3);\n\n\tirqstat = sl811_read(sl811, SL11H_IRQ_STATUS);\n\n\tswitch (signaling) {\n\tcase SL11H_CTL1MASK_SE0:\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller, \"end reset\\n\");\n\t\tsl811->port1 = (USB_PORT_STAT_C_RESET << 16)\n\t\t\t\t | USB_PORT_STAT_POWER;\n\t\tsl811->ctrl1 = 0;\n\t\t \n\t\tif (irqstat & SL11H_INTMASK_INSRMV)\n\t\t\tirqstat &= ~SL11H_INTMASK_RD;\n\t\tbreak;\n\tcase SL11H_CTL1MASK_K:\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller, \"end resume\\n\");\n\t\tsl811->port1 &= ~USB_PORT_STAT_SUSPEND;\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(sl811_to_hcd(sl811)->self.controller,\n\t\t\t\"odd timer signaling: %02x\\n\", signaling);\n\t\tbreak;\n\t}\n\tsl811_write(sl811, SL11H_IRQ_STATUS, irqstat);\n\n\tif (irqstat & SL11H_INTMASK_RD) {\n\t\t \n\t\tif (sl811->port1 & USB_PORT_STAT_CONNECTION)\n\t\t\tsl811->port1 |= (USB_PORT_STAT_C_CONNECTION << 16)\n\t\t\t\t\t| (USB_PORT_STAT_C_ENABLE << 16);\n\t\tsl811->port1 &= ~mask;\n\t\tsl811->irq_enable = SL11H_INTMASK_INSRMV;\n\t} else {\n\t\tsl811->port1 |= mask;\n\t\tif (irqstat & SL11H_INTMASK_DP)\n\t\t\tsl811->port1 &= ~USB_PORT_STAT_LOW_SPEED;\n\t\tsl811->irq_enable = SL11H_INTMASK_INSRMV | SL11H_INTMASK_RD;\n\t}\n\n\tif (sl811->port1 & USB_PORT_STAT_CONNECTION) {\n\t\tu8\tctrl2 = SL811HS_CTL2_INIT;\n\n\t\tsl811->irq_enable |= SL11H_INTMASK_DONE_A;\n#ifdef USE_B\n\t\tsl811->irq_enable |= SL11H_INTMASK_DONE_B;\n#endif\n\t\tif (sl811->port1 & USB_PORT_STAT_LOW_SPEED) {\n\t\t\tsl811->ctrl1 |= SL11H_CTL1MASK_LSPD;\n\t\t\tctrl2 |= SL811HS_CTL2MASK_DSWAP;\n\t\t}\n\n\t\t \n\t\tsl811->ctrl1 |= SL11H_CTL1MASK_SOF_ENA;\n\t\tsl811_write(sl811, SL11H_SOFLOWREG, 0xe0);\n\t\tsl811_write(sl811, SL811HS_CTLREG2, ctrl2);\n\n\t\t \n\t\tsl811_write(sl811, SL811_EP_A(SL11H_BUFLNTHREG), 0);\n\t\twriteb(SL_SOF, sl811->data_reg);\n\t\twriteb(0, sl811->data_reg);\n\t\tsl811_write(sl811, SL811_EP_A(SL11H_HOSTCTLREG),\n\t\t\t\tSL11H_HCTLMASK_ARM);\n\n\t\t \n\t} else {\n\t\tsl811->ctrl1 = 0;\n\t}\n\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\n\t \n\tsl811_write(sl811, SL11H_IRQ_ENABLE, sl811->irq_enable);\n\tspin_unlock_irqrestore(&sl811->lock, flags);\n}\n\nstatic int\nsl811h_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength\n) {\n\tstruct sl811\t*sl811 = hcd_to_sl811(hcd);\n\tint\t\tretval = 0;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&sl811->lock, flags);\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (wIndex != 1 || wLength != 0)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tsl811->port1 &= USB_PORT_STAT_POWER;\n\t\t\tsl811->ctrl1 = 0;\n\t\t\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\t\t\tsl811->irq_enable = SL11H_INTMASK_INSRMV;\n\t\t\tsl811_write(sl811, SL11H_IRQ_ENABLE,\n\t\t\t\t\t\tsl811->irq_enable);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (!(sl811->port1 & USB_PORT_STAT_SUSPEND))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tdev_dbg(hcd->self.controller, \"start resume...\\n\");\n\t\t\tsl811->irq_enable = 0;\n\t\t\tsl811_write(sl811, SL11H_IRQ_ENABLE,\n\t\t\t\t\t\tsl811->irq_enable);\n\t\t\tsl811->ctrl1 |= SL11H_CTL1MASK_K;\n\t\t\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\n\t\t\tmod_timer(&sl811->timer, jiffies\n\t\t\t\t\t+ msecs_to_jiffies(USB_RESUME_TIMEOUT));\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tport_power(sl811, 0);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tsl811->port1 &= ~(1 << wValue);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tsl811h_hub_descriptor(sl811, (struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\tput_unaligned_le32(0, buf);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (wIndex != 1)\n\t\t\tgoto error;\n\t\tput_unaligned_le32(sl811->port1, buf);\n\n\t\tif (__is_defined(VERBOSE) ||\n\t\t    *(u16*)(buf+2))  \n\t\t\tdev_dbg(hcd->self.controller, \"GetPortStatus %08x\\n\",\n\t\t\t\tsl811->port1);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (wIndex != 1 || wLength != 0)\n\t\t\tgoto error;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (sl811->port1 & USB_PORT_STAT_RESET)\n\t\t\t\tgoto error;\n\t\t\tif (!(sl811->port1 & USB_PORT_STAT_ENABLE))\n\t\t\t\tgoto error;\n\n\t\t\tdev_dbg(hcd->self.controller,\"suspend...\\n\");\n\t\t\tsl811->ctrl1 &= ~SL11H_CTL1MASK_SOF_ENA;\n\t\t\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tport_power(sl811, 1);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (sl811->port1 & USB_PORT_STAT_SUSPEND)\n\t\t\t\tgoto error;\n\t\t\tif (!(sl811->port1 & USB_PORT_STAT_POWER))\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tsl811->irq_enable = 0;\n\t\t\tsl811_write(sl811, SL11H_IRQ_ENABLE,\n\t\t\t\t\t\tsl811->irq_enable);\n\t\t\tsl811->ctrl1 = SL11H_CTL1MASK_SE0;\n\t\t\tsl811_write(sl811, SL11H_CTLREG1, sl811->ctrl1);\n\t\t\tsl811->port1 |= USB_PORT_STAT_RESET;\n\t\t\tmod_timer(&sl811->timer, jiffies\n\t\t\t\t\t+ msecs_to_jiffies(50));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tsl811->port1 |= 1 << wValue;\n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\n\tspin_unlock_irqrestore(&sl811->lock, flags);\n\treturn retval;\n}\n\n#ifdef\tCONFIG_PM\n\nstatic int\nsl811h_bus_suspend(struct usb_hcd *hcd)\n{\n\t \n\tdev_dbg(hcd->self.controller, \"%s\\n\", __func__);\n\treturn 0;\n}\n\nstatic int\nsl811h_bus_resume(struct usb_hcd *hcd)\n{\n\t \n\tdev_dbg(hcd->self.controller, \"%s\\n\", __func__);\n\treturn 0;\n}\n\n#else\n\n#define\tsl811h_bus_suspend\tNULL\n#define\tsl811h_bus_resume\tNULL\n\n#endif\n\n\n \n\nstatic void dump_irq(struct seq_file *s, char *label, u8 mask)\n{\n\tseq_printf(s, \"%s %02x%s%s%s%s%s%s\\n\", label, mask,\n\t\t(mask & SL11H_INTMASK_DONE_A) ? \" done_a\" : \"\",\n\t\t(mask & SL11H_INTMASK_DONE_B) ? \" done_b\" : \"\",\n\t\t(mask & SL11H_INTMASK_SOFINTR) ? \" sof\" : \"\",\n\t\t(mask & SL11H_INTMASK_INSRMV) ? \" ins/rmv\" : \"\",\n\t\t(mask & SL11H_INTMASK_RD) ? \" rd\" : \"\",\n\t\t(mask & SL11H_INTMASK_DP) ? \" dp\" : \"\");\n}\n\nstatic int sl811h_debug_show(struct seq_file *s, void *unused)\n{\n\tstruct sl811\t\t*sl811 = s->private;\n\tstruct sl811h_ep\t*ep;\n\tunsigned\t\ti;\n\n\tseq_printf(s, \"%s\\n%s version %s\\nportstatus[1] = %08x\\n\",\n\t\tsl811_to_hcd(sl811)->product_desc,\n\t\thcd_name, DRIVER_VERSION,\n\t\tsl811->port1);\n\n\tseq_printf(s, \"insert/remove: %ld\\n\", sl811->stat_insrmv);\n\tseq_printf(s, \"current session:  done_a %ld done_b %ld \"\n\t\t\t\"wake %ld sof %ld overrun %ld lost %ld\\n\\n\",\n\t\tsl811->stat_a, sl811->stat_b,\n\t\tsl811->stat_wake, sl811->stat_sof,\n\t\tsl811->stat_overrun, sl811->stat_lost);\n\n\tspin_lock_irq(&sl811->lock);\n\n\tif (sl811->ctrl1 & SL11H_CTL1MASK_SUSPEND)\n\t\tseq_printf(s, \"(suspended)\\n\\n\");\n\telse {\n\t\tu8\tt = sl811_read(sl811, SL11H_CTLREG1);\n\n\t\tseq_printf(s, \"ctrl1 %02x%s%s%s%s\\n\", t,\n\t\t\t(t & SL11H_CTL1MASK_SOF_ENA) ? \" sofgen\" : \"\",\n\t\t\t({char *s; switch (t & SL11H_CTL1MASK_FORCE) {\n\t\t\tcase SL11H_CTL1MASK_NORMAL: s = \"\"; break;\n\t\t\tcase SL11H_CTL1MASK_SE0: s = \" se0/reset\"; break;\n\t\t\tcase SL11H_CTL1MASK_K: s = \" k/resume\"; break;\n\t\t\tdefault: s = \"j\"; break;\n\t\t\t} s; }),\n\t\t\t(t & SL11H_CTL1MASK_LSPD) ? \" lowspeed\" : \"\",\n\t\t\t(t & SL11H_CTL1MASK_SUSPEND) ? \" suspend\" : \"\");\n\n\t\tdump_irq(s, \"irq_enable\",\n\t\t\t\tsl811_read(sl811, SL11H_IRQ_ENABLE));\n\t\tdump_irq(s, \"irq_status\",\n\t\t\t\tsl811_read(sl811, SL11H_IRQ_STATUS));\n\t\tseq_printf(s, \"frame clocks remaining:  %d\\n\",\n\t\t\t\tsl811_read(sl811, SL11H_SOFTMRREG) << 6);\n\t}\n\n\tseq_printf(s, \"A: qh%p ctl %02x sts %02x\\n\", sl811->active_a,\n\t\tsl811_read(sl811, SL811_EP_A(SL11H_HOSTCTLREG)),\n\t\tsl811_read(sl811, SL811_EP_A(SL11H_PKTSTATREG)));\n\tseq_printf(s, \"B: qh%p ctl %02x sts %02x\\n\", sl811->active_b,\n\t\tsl811_read(sl811, SL811_EP_B(SL11H_HOSTCTLREG)),\n\t\tsl811_read(sl811, SL811_EP_B(SL11H_PKTSTATREG)));\n\tseq_printf(s, \"\\n\");\n\tlist_for_each_entry (ep, &sl811->async, schedule) {\n\t\tstruct urb\t\t*urb;\n\n\t\tseq_printf(s, \"%s%sqh%p, ep%d%s, maxpacket %d\"\n\t\t\t\t\t\" nak %d err %d\\n\",\n\t\t\t(ep == sl811->active_a) ? \"(A) \" : \"\",\n\t\t\t(ep == sl811->active_b) ? \"(B) \" : \"\",\n\t\t\tep, ep->epnum,\n\t\t\t({ char *s; switch (ep->nextpid) {\n\t\t\tcase USB_PID_IN: s = \"in\"; break;\n\t\t\tcase USB_PID_OUT: s = \"out\"; break;\n\t\t\tcase USB_PID_SETUP: s = \"setup\"; break;\n\t\t\tcase USB_PID_ACK: s = \"status\"; break;\n\t\t\tdefault: s = \"?\"; break;\n\t\t\t} s;}),\n\t\t\tep->maxpacket,\n\t\t\tep->nak_count, ep->error_count);\n\t\tlist_for_each_entry (urb, &ep->hep->urb_list, urb_list) {\n\t\t\tseq_printf(s, \"  urb%p, %d/%d\\n\", urb,\n\t\t\t\turb->actual_length,\n\t\t\t\turb->transfer_buffer_length);\n\t\t}\n\t}\n\tif (!list_empty(&sl811->async))\n\t\tseq_printf(s, \"\\n\");\n\n\tseq_printf(s, \"periodic size= %d\\n\", PERIODIC_SIZE);\n\n\tfor (i = 0; i < PERIODIC_SIZE; i++) {\n\t\tep = sl811->periodic[i];\n\t\tif (!ep)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%2d [%3d]:\\n\", i, sl811->load[i]);\n\n\t\t \n\t\tdo {\n\t\t\tseq_printf(s,\n\t\t\t\t\"   %s%sqh%d/%p (%sdev%d ep%d%s max %d) \"\n\t\t\t\t\t\"err %d\\n\",\n\t\t\t\t(ep == sl811->active_a) ? \"(A) \" : \"\",\n\t\t\t\t(ep == sl811->active_b) ? \"(B) \" : \"\",\n\t\t\t\tep->period, ep,\n\t\t\t\t(ep->udev->speed == USB_SPEED_FULL)\n\t\t\t\t\t? \"\" : \"ls \",\n\t\t\t\tep->udev->devnum, ep->epnum,\n\t\t\t\t(ep->epnum == 0) ? \"\"\n\t\t\t\t\t: ((ep->nextpid == USB_PID_IN)\n\t\t\t\t\t\t? \"in\"\n\t\t\t\t\t\t: \"out\"),\n\t\t\t\tep->maxpacket, ep->error_count);\n\t\t\tep = ep->next;\n\t\t} while (ep);\n\t}\n\n\tspin_unlock_irq(&sl811->lock);\n\tseq_printf(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(sl811h_debug);\n\n \nstatic void create_debug_file(struct sl811 *sl811)\n{\n\tdebugfs_create_file(\"sl811h\", S_IRUGO, usb_debug_root, sl811,\n\t\t\t    &sl811h_debug_fops);\n}\n\nstatic void remove_debug_file(struct sl811 *sl811)\n{\n\tdebugfs_lookup_and_remove(\"sl811h\", usb_debug_root);\n}\n\n \n\nstatic void\nsl811h_stop(struct usb_hcd *hcd)\n{\n\tstruct sl811\t*sl811 = hcd_to_sl811(hcd);\n\tunsigned long\tflags;\n\n\tdel_timer_sync(&hcd->rh_timer);\n\n\tspin_lock_irqsave(&sl811->lock, flags);\n\tport_power(sl811, 0);\n\tspin_unlock_irqrestore(&sl811->lock, flags);\n}\n\nstatic int\nsl811h_start(struct usb_hcd *hcd)\n{\n\tstruct sl811\t\t*sl811 = hcd_to_sl811(hcd);\n\n\t \n\thcd->state = HC_STATE_RUNNING;\n\n\tif (sl811->board) {\n\t\tif (!device_can_wakeup(hcd->self.controller))\n\t\t\tdevice_init_wakeup(hcd->self.controller,\n\t\t\t\tsl811->board->can_wakeup);\n\t\thcd->power_budget = sl811->board->power * 2;\n\t}\n\n\t \n\tport_power(sl811, 1);\n\n\treturn 0;\n}\n\n \n\nstatic const struct hc_driver sl811h_hc_driver = {\n\t.description =\t\thcd_name,\n\t.hcd_priv_size =\tsizeof(struct sl811),\n\n\t \n\t.irq =\t\t\tsl811h_irq,\n\t.flags =\t\tHCD_USB11 | HCD_MEMORY,\n\n\t \n\t.start =\t\tsl811h_start,\n\t.stop =\t\t\tsl811h_stop,\n\n\t \n\t.urb_enqueue =\t\tsl811h_urb_enqueue,\n\t.urb_dequeue =\t\tsl811h_urb_dequeue,\n\t.endpoint_disable =\tsl811h_endpoint_disable,\n\n\t \n\t.get_frame_number =\tsl811h_get_frame,\n\n\t \n\t.hub_status_data =\tsl811h_hub_status_data,\n\t.hub_control =\t\tsl811h_hub_control,\n\t.bus_suspend =\t\tsl811h_bus_suspend,\n\t.bus_resume =\t\tsl811h_bus_resume,\n};\n\n \n\nstatic void\nsl811h_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd\t\t*hcd = platform_get_drvdata(dev);\n\tstruct sl811\t\t*sl811 = hcd_to_sl811(hcd);\n\tstruct resource\t\t*res;\n\n\tremove_debug_file(sl811);\n\tusb_remove_hcd(hcd);\n\n\t \n\tres = platform_get_resource(dev, IORESOURCE_MEM, 1);\n\tif (res)\n\t\tiounmap(sl811->data_reg);\n\n\tres = platform_get_resource(dev, IORESOURCE_MEM, 0);\n\tif (res)\n\t\tiounmap(sl811->addr_reg);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic int\nsl811h_probe(struct platform_device *dev)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct sl811\t\t*sl811;\n\tstruct resource\t\t*addr, *data, *ires;\n\tint\t\t\tirq;\n\tvoid __iomem\t\t*addr_reg;\n\tvoid __iomem\t\t*data_reg;\n\tint\t\t\tretval;\n\tu8\t\t\ttmp, ioaddr;\n\tunsigned long\t\tirqflags;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t \n\taddr = platform_get_mem_or_io(dev, 0);\n\tdata = platform_get_mem_or_io(dev, 1);\n\tif (!addr || !data || resource_type(addr) != resource_type(data))\n\t\treturn -ENODEV;\n\n\t \n\tires = platform_get_resource(dev, IORESOURCE_IRQ, 0);\n\tif (dev->num_resources < 3 || !ires)\n\t\treturn -ENODEV;\n\n\tirq = ires->start;\n\tirqflags = ires->flags & IRQF_TRIGGER_MASK;\n\n\tioaddr = resource_type(addr) == IORESOURCE_IO;\n\tif (ioaddr) {\n\t\t \n\t\taddr_reg = (void __iomem *) (unsigned long) addr->start;\n\t\tdata_reg = (void __iomem *) (unsigned long) data->start;\n\t} else {\n\t\taddr_reg = ioremap(addr->start, 1);\n\t\tif (addr_reg == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err2;\n\t\t}\n\n\t\tdata_reg = ioremap(data->start, 1);\n\t\tif (data_reg == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto err4;\n\t\t}\n\t}\n\n\t \n\thcd = usb_create_hcd(&sl811h_hc_driver, &dev->dev, dev_name(&dev->dev));\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto err5;\n\t}\n\thcd->rsrc_start = addr->start;\n\tsl811 = hcd_to_sl811(hcd);\n\n\tspin_lock_init(&sl811->lock);\n\tINIT_LIST_HEAD(&sl811->async);\n\tsl811->board = dev_get_platdata(&dev->dev);\n\ttimer_setup(&sl811->timer, sl811h_timer, 0);\n\tsl811->addr_reg = addr_reg;\n\tsl811->data_reg = data_reg;\n\n\tspin_lock_irq(&sl811->lock);\n\tport_power(sl811, 0);\n\tspin_unlock_irq(&sl811->lock);\n\tmsleep(200);\n\n\ttmp = sl811_read(sl811, SL11H_HWREVREG);\n\tswitch (tmp >> 4) {\n\tcase 1:\n\t\thcd->product_desc = \"SL811HS v1.2\";\n\t\tbreak;\n\tcase 2:\n\t\thcd->product_desc = \"SL811HS v1.5\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\tdev_dbg(&dev->dev, \"chiprev %02x\\n\", tmp);\n\t\tretval = -ENXIO;\n\t\tgoto err6;\n\t}\n\n\t \n\tirqflags |= IRQF_SHARED;\n\tretval = usb_add_hcd(hcd, irq, irqflags);\n\tif (retval != 0)\n\t\tgoto err6;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tcreate_debug_file(sl811);\n\treturn retval;\n\n err6:\n\tusb_put_hcd(hcd);\n err5:\n\tif (!ioaddr)\n\t\tiounmap(data_reg);\n err4:\n\tif (!ioaddr)\n\t\tiounmap(addr_reg);\n err2:\n\tdev_dbg(&dev->dev, \"init error, %d\\n\", retval);\n\treturn retval;\n}\n\n#ifdef\tCONFIG_PM\n\n \n\nstatic int\nsl811h_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(dev);\n\tstruct sl811\t*sl811 = hcd_to_sl811(hcd);\n\tint\t\tretval = 0;\n\n\tswitch (state.event) {\n\tcase PM_EVENT_FREEZE:\n\t\tretval = sl811h_bus_suspend(hcd);\n\t\tbreak;\n\tcase PM_EVENT_SUSPEND:\n\tcase PM_EVENT_HIBERNATE:\n\tcase PM_EVENT_PRETHAW:\t\t \n\t\tport_power(sl811, 0);\n\t\tbreak;\n\t}\n\treturn retval;\n}\n\nstatic int\nsl811h_resume(struct platform_device *dev)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(dev);\n\tstruct sl811\t*sl811 = hcd_to_sl811(hcd);\n\n\t \n\tif (!sl811->port1 || !device_can_wakeup(&hcd->self.root_hub->dev)) {\n\t\tsl811->port1 = 0;\n\t\tport_power(sl811, 1);\n\t\tusb_root_hub_lost_power(hcd->self.root_hub);\n\t\treturn 0;\n\t}\n\n\treturn sl811h_bus_resume(hcd);\n}\n\n#else\n\n#define\tsl811h_suspend\tNULL\n#define\tsl811h_resume\tNULL\n\n#endif\n\n\n \nstruct platform_driver sl811h_driver = {\n\t.probe =\tsl811h_probe,\n\t.remove_new =\tsl811h_remove,\n\n\t.suspend =\tsl811h_suspend,\n\t.resume =\tsl811h_resume,\n\t.driver = {\n\t\t.name =\thcd_name,\n\t},\n};\nEXPORT_SYMBOL(sl811h_driver);\n\nmodule_platform_driver(sl811h_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}