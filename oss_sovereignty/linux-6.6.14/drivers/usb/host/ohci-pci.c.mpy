{
  "module_name": "ohci-pci.c",
  "hash_id": "28def74194a5033b8f7a703c070dc81b56c9da1730f936b3eea73de75504e922",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-pci.c",
  "human_readable_source": "\n \n\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ohci.h\"\n#include \"pci-quirks.h\"\n\n#define DRIVER_DESC \"OHCI PCI platform driver\"\n\nstatic const char hcd_name[] = \"ohci-pci\";\n\n\n \n\nstatic int broken_suspend(struct usb_hcd *hcd)\n{\n\tdevice_init_wakeup(&hcd->self.root_hub->dev, 0);\n\treturn 0;\n}\n\n \nstatic int ohci_quirk_amd756(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\tohci->flags = OHCI_QUIRK_AMD756;\n\tohci_dbg (ohci, \"AMD756 erratum 4 workaround\\n\");\n\n\t \n\treturn broken_suspend(hcd);\n}\n\n \nstatic int ohci_quirk_opti(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\tohci_dbg (ohci, \"WARNING: OPTi workarounds unavailable\\n\");\n\n\treturn 0;\n}\n\n \nstatic int ohci_quirk_ns(struct usb_hcd *hcd)\n{\n\tstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\n\tstruct pci_dev\t*b;\n\n\tb  = pci_get_slot (pdev->bus, PCI_DEVFN (PCI_SLOT (pdev->devfn), 1));\n\tif (b && b->device == PCI_DEVICE_ID_NS_87560_LIO\n\t    && b->vendor == PCI_VENDOR_ID_NS) {\n\t\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\t\tohci->flags |= OHCI_QUIRK_SUPERIO;\n\t\tohci_dbg (ohci, \"Using NSC SuperIO setup\\n\");\n\t}\n\tpci_dev_put(b);\n\n\treturn 0;\n}\n\n \nstatic int ohci_quirk_zfmicro(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\tohci->flags |= OHCI_QUIRK_ZFMICRO;\n\tohci_dbg(ohci, \"enabled Compaq ZFMicro chipset quirks\\n\");\n\n\treturn 0;\n}\n\n \nstatic int ohci_quirk_toshiba_scc(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\t \n#ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\n\tohci->flags |= OHCI_QUIRK_BE_MMIO;\n\tohci_dbg (ohci, \"enabled big endian Toshiba quirk\\n\");\n\treturn 0;\n#else\n\tohci_err (ohci, \"unsupported big endian Toshiba quirk\\n\");\n\treturn -ENXIO;\n#endif\n}\n\n \n\nstatic void ohci_quirk_nec_worker(struct work_struct *work)\n{\n\tstruct ohci_hcd *ohci = container_of(work, struct ohci_hcd, nec_work);\n\tint status;\n\n\tstatus = ohci_restart(ohci);\n\tif (status != 0)\n\t\tohci_err(ohci, \"Restarting NEC controller failed in %s, %d\\n\",\n\t\t\t \"ohci_restart\", status);\n}\n\nstatic int ohci_quirk_nec(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\n\tohci->flags |= OHCI_QUIRK_NEC;\n\tINIT_WORK(&ohci->nec_work, ohci_quirk_nec_worker);\n\tohci_dbg (ohci, \"enabled NEC chipset lost interrupt quirk\\n\");\n\n\treturn 0;\n}\n\nstatic int ohci_quirk_amd700(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\n\n\tif (usb_amd_quirk_pll_check())\n\t\tohci->flags |= OHCI_QUIRK_AMD_PLL;\n\n\t \n\tif (usb_amd_prefetch_quirk()) {\n\t\tohci->flags |= OHCI_QUIRK_AMD_PREFETCH;\n\t\tohci_dbg(ohci, \"enabled AMD prefetch quirk\\n\");\n\t}\n\n\tohci->flags |= OHCI_QUIRK_GLOBAL_SUSPEND;\n\treturn 0;\n}\n\nstatic int ohci_quirk_qemu(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\n\n\tohci->flags |= OHCI_QUIRK_QEMU;\n\tohci_dbg(ohci, \"enabled qemu quirk\\n\");\n\treturn 0;\n}\n\n \nstatic const struct pci_device_id ohci_pci_quirks[] = {\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_AMD, 0x740c),\n\t\t.driver_data = (unsigned long)ohci_quirk_amd756,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_OPTI, 0xc861),\n\t\t.driver_data = (unsigned long)ohci_quirk_opti,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_NS, PCI_ANY_ID),\n\t\t.driver_data = (unsigned long)ohci_quirk_ns,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_COMPAQ, 0xa0f8),\n\t\t.driver_data = (unsigned long)ohci_quirk_zfmicro,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_TOSHIBA_2, 0x01b6),\n\t\t.driver_data = (unsigned long)ohci_quirk_toshiba_scc,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_USB),\n\t\t.driver_data = (unsigned long)ohci_quirk_nec,\n\t},\n\t{\n\t\t \n\t\t.vendor\t\t= PCI_VENDOR_ID_AL,\n\t\t.device\t\t= 0x5237,\n\t\t.subvendor\t= PCI_VENDOR_ID_TOSHIBA,\n\t\t.subdevice\t= 0x0004,\n\t\t.driver_data\t= (unsigned long) broken_suspend,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ITE, 0x8152),\n\t\t.driver_data = (unsigned long) broken_suspend,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4397),\n\t\t.driver_data = (unsigned long)ohci_quirk_amd700,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4398),\n\t\t.driver_data = (unsigned long)ohci_quirk_amd700,\n\t},\n\t{\n\t\tPCI_DEVICE(PCI_VENDOR_ID_ATI, 0x4399),\n\t\t.driver_data = (unsigned long)ohci_quirk_amd700,\n\t},\n\t{\n\t\t.vendor\t\t= PCI_VENDOR_ID_APPLE,\n\t\t.device\t\t= 0x003f,\n\t\t.subvendor\t= PCI_SUBVENDOR_ID_REDHAT_QUMRANET,\n\t\t.subdevice\t= PCI_SUBDEVICE_ID_QEMU,\n\t\t.driver_data\t= (unsigned long)ohci_quirk_qemu,\n\t},\n\n\t{},\n};\n\nstatic int ohci_pci_reset (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tstruct pci_dev *pdev = to_pci_dev(hcd->self.controller);\n\tint ret = 0;\n\n\tif (hcd->self.controller) {\n\t\tconst struct pci_device_id *quirk_id;\n\n\t\tquirk_id = pci_match_id(ohci_pci_quirks, pdev);\n\t\tif (quirk_id != NULL) {\n\t\t\tint (*quirk)(struct usb_hcd *ohci);\n\t\t\tquirk = (void *)quirk_id->driver_data;\n\t\t\tret = quirk(hcd);\n\t\t}\n\t}\n\n\tif (ret == 0)\n\t\tret = ohci_setup(hcd);\n\t \n\tif (device_can_wakeup(&pdev->dev))\n\t\tohci->hc_control |= OHCI_CTRL_RWC;\n\treturn ret;\n}\n\nstatic struct hc_driver __read_mostly ohci_pci_hc_driver;\n\nstatic const struct ohci_driver_overrides pci_overrides __initconst = {\n\t.product_desc =\t\t\"OHCI PCI host controller\",\n\t.reset =\t\tohci_pci_reset,\n};\n\nstatic const struct pci_device_id pci_ids[] = { {\n\t \n\tPCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_OHCI, ~0),\n\t}, {\n\t \n\tPCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_OHCI),\n\t}, {   }\n};\nMODULE_DEVICE_TABLE (pci, pci_ids);\n\nstatic int ohci_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)\n{\n\treturn usb_hcd_pci_probe(dev, &ohci_pci_hc_driver);\n}\n\n \nstatic struct pci_driver ohci_pci_driver = {\n\t.name =\t\thcd_name,\n\t.id_table =\tpci_ids,\n\n\t.probe =\tohci_pci_probe,\n\t.remove =\tusb_hcd_pci_remove,\n\t.shutdown =\tusb_hcd_pci_shutdown,\n\n#ifdef CONFIG_PM\n\t.driver =\t{\n\t\t.pm =\t&usb_hcd_pci_pm_ops\n\t},\n#endif\n};\n\n#ifdef CONFIG_PM\nstatic int ohci_pci_resume(struct usb_hcd *hcd, pm_message_t msg)\n{\n\treturn ohci_resume(hcd, msg.event == PM_EVENT_RESTORE);\n}\n#endif\nstatic int __init ohci_pci_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_pci_hc_driver, &pci_overrides);\n\n#ifdef\tCONFIG_PM\n\t \n\tohci_pci_hc_driver.pci_suspend = ohci_suspend;\n\tohci_pci_hc_driver.pci_resume = ohci_pci_resume;\n#endif\n\n\treturn pci_register_driver(&ohci_pci_driver);\n}\nmodule_init(ohci_pci_init);\n\nstatic void __exit ohci_pci_cleanup(void)\n{\n\tpci_unregister_driver(&ohci_pci_driver);\n}\nmodule_exit(ohci_pci_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_SOFTDEP(\"pre: ehci_pci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}