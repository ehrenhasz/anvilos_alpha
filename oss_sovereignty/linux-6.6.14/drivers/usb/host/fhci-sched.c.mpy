{
  "module_name": "fhci-sched.c",
  "hash_id": "d3821f57e08aa6fd1fd7a56f1a9f3b836d4aa93160b45aaf54987508ea442564",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/fhci-sched.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/io.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <soc/fsl/qe/qe.h>\n#include <asm/fsl_gtm.h>\n#include \"fhci.h\"\n\nstatic void recycle_frame(struct fhci_usb *usb, struct packet *pkt)\n{\n\tpkt->data = NULL;\n\tpkt->len = 0;\n\tpkt->status = USB_TD_OK;\n\tpkt->info = 0;\n\tpkt->priv_data = NULL;\n\n\tcq_put(&usb->ep0->empty_frame_Q, pkt);\n}\n\n \nvoid fhci_transaction_confirm(struct fhci_usb *usb, struct packet *pkt)\n{\n\tstruct td *td;\n\tstruct packet *td_pkt;\n\tstruct ed *ed;\n\tu32 trans_len;\n\tbool td_done = false;\n\n\ttd = fhci_remove_td_from_frame(usb->actual_frame);\n\ttd_pkt = td->pkt;\n\ttrans_len = pkt->len;\n\ttd->status = pkt->status;\n\tif (td->type == FHCI_TA_IN && td_pkt->info & PKT_DUMMY_PACKET) {\n\t\tif ((td->data + td->actual_len) && trans_len)\n\t\t\tmemcpy(td->data + td->actual_len, pkt->data,\n\t\t\t       trans_len);\n\t\tcq_put(&usb->ep0->dummy_packets_Q, pkt->data);\n\t}\n\n\trecycle_frame(usb, pkt);\n\n\ted = td->ed;\n\tif (ed->mode == FHCI_TF_ISO) {\n\t\tif (ed->td_list.next->next != &ed->td_list) {\n\t\t\tstruct td *td_next =\n\t\t\t    list_entry(ed->td_list.next->next, struct td,\n\t\t\t\t       node);\n\n\t\t\ttd_next->start_frame = usb->actual_frame->frame_num;\n\t\t}\n\t\ttd->actual_len = trans_len;\n\t\ttd_done = true;\n\t} else if ((td->status & USB_TD_ERROR) &&\n\t\t\t!(td->status & USB_TD_TX_ER_NAK)) {\n\t\t \n\t\tif ((td->status & USB_TD_RX_DATA_UNDERUN) ||\n\t\t\t\t(td->status & USB_TD_TX_ER_STALL) ||\n\t\t\t\t(td->status & USB_TD_RX_ER_PID) ||\n\t\t\t\t(++td->error_cnt >= 3)) {\n\t\t\ted->state = FHCI_ED_HALTED;\n\t\t\ttd_done = true;\n\n\t\t\tif (td->status & USB_TD_RX_DATA_UNDERUN) {\n\t\t\t\tfhci_dbg(usb->fhci, \"td err fu\\n\");\n\t\t\t\ttd->toggle = !td->toggle;\n\t\t\t\ttd->actual_len += trans_len;\n\t\t\t} else {\n\t\t\t\tfhci_dbg(usb->fhci, \"td err f!u\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tfhci_dbg(usb->fhci, \"td err !f\\n\");\n\t\t\t \n\t\t\ttd->nak_cnt = 0;\n\t\t\ttd->error_cnt++;\n\t\t\ttd->status = USB_TD_OK;\n\t\t}\n\t} else if (td->status & USB_TD_TX_ER_NAK) {\n\t\t \n\t\tfhci_vdbg(usb->fhci, \"td nack\\n\");\n\t\ttd->nak_cnt++;\n\t\ttd->error_cnt = 0;\n\t\ttd->status = USB_TD_OK;\n\t} else {\n\t\t \n\t\ttd->error_cnt = 0;\n\t\ttd->nak_cnt = 0;\n\t\ttd->toggle = !td->toggle;\n\t\ttd->actual_len += trans_len;\n\n\t\tif (td->len == td->actual_len)\n\t\t\ttd_done = true;\n\t}\n\n\tif (td_done)\n\t\tfhci_move_td_from_ed_to_done_list(usb, ed);\n}\n\n \nvoid fhci_flush_all_transmissions(struct fhci_usb *usb)\n{\n\tu8 mode;\n\tstruct td *td;\n\n\tmode = in_8(&usb->fhci->regs->usb_usmod);\n\tclrbits8(&usb->fhci->regs->usb_usmod, USB_MODE_EN);\n\n\tfhci_flush_bds(usb);\n\n\twhile ((td = fhci_peek_td_from_frame(usb->actual_frame)) != NULL) {\n\t\tstruct packet *pkt = td->pkt;\n\n\t\tpkt->status = USB_TD_TX_ER_TIMEOUT;\n\t\tfhci_transaction_confirm(usb, pkt);\n\t}\n\n\tusb->actual_frame->frame_status = FRAME_END_TRANSMISSION;\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usber, 0xffff);\n\t \n\tout_8(&usb->fhci->regs->usb_usmod, mode | USB_MODE_EN);\n}\n\n \nstatic int add_packet(struct fhci_usb *usb, struct ed *ed, struct td *td)\n{\n\tu32 fw_transaction_time, len = 0;\n\tstruct packet *pkt;\n\tu8 *data = NULL;\n\n\t \n\tif (td->toggle == USB_TD_TOGGLE_CARRY)\n\t\ttd->toggle = ed->toggle_carry;\n\n\tswitch (ed->mode) {\n\tcase FHCI_TF_ISO:\n\t\tlen = td->len;\n\t\tif (td->type != FHCI_TA_IN)\n\t\t\tdata = td->data;\n\t\tbreak;\n\tcase FHCI_TF_CTRL:\n\tcase FHCI_TF_BULK:\n\t\tlen = min(td->len - td->actual_len, ed->max_pkt_size);\n\t\tif (!((td->type == FHCI_TA_IN) &&\n\t\t      ((len + td->actual_len) == td->len)))\n\t\t\tdata = td->data + td->actual_len;\n\t\tbreak;\n\tcase FHCI_TF_INTR:\n\t\tlen = min(td->len, ed->max_pkt_size);\n\t\tif (!((td->type == FHCI_TA_IN) &&\n\t\t      ((td->len + CRC_SIZE) >= ed->max_pkt_size)))\n\t\t\tdata = td->data;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (usb->port_status == FHCI_PORT_FULL)\n\t\tfw_transaction_time = (((len + PROTOCOL_OVERHEAD) * 11) >> 4);\n\telse\n\t\tfw_transaction_time = ((len + PROTOCOL_OVERHEAD) * 6);\n\n\t \n\tif (usb->actual_frame->total_bytes + len + PROTOCOL_OVERHEAD >=\n\t\t\tusb->max_bytes_per_frame) {\n\t\tfhci_vdbg(usb->fhci, \"not enough space in this frame: \"\n\t\t\t  \"%d %d %d\\n\", usb->actual_frame->total_bytes, len,\n\t\t\t  usb->max_bytes_per_frame);\n\t\treturn -1;\n\t}\n\n\t \n\tif (usb->actual_frame->frame_status != FRAME_IS_PREPARED &&\n\t    (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION ||\n\t     (fw_transaction_time + usb->sw_transaction_time >=\n\t      1000 - fhci_get_sof_timer_count(usb)))) {\n\t\tfhci_dbg(usb->fhci, \"not enough time in this frame\\n\");\n\t\treturn -1;\n\t}\n\n\t \n\tpkt = cq_get(&usb->ep0->empty_frame_Q);\n\tif (!pkt) {\n\t\tfhci_dbg(usb->fhci, \"there is no empty frame\\n\");\n\t\treturn -1;\n\t}\n\ttd->pkt = pkt;\n\n\tpkt->info = 0;\n\tif (data == NULL) {\n\t\tdata = cq_get(&usb->ep0->dummy_packets_Q);\n\t\tBUG_ON(!data);\n\t\tpkt->info = PKT_DUMMY_PACKET;\n\t}\n\tpkt->data = data;\n\tpkt->len = len;\n\tpkt->status = USB_TD_OK;\n\t \n\ttd->status = USB_TD_INPROGRESS;\n\t \n\tusb->actual_frame->total_bytes += (len + PROTOCOL_OVERHEAD);\n\tfhci_add_td_to_frame(usb->actual_frame, td);\n\n\tif (usb->port_status != FHCI_PORT_FULL &&\n\t\t\tusb->port_status != FHCI_PORT_LOW) {\n\t\tpkt->status = USB_TD_TX_ER_TIMEOUT;\n\t\tpkt->len = 0;\n\t\tfhci_transaction_confirm(usb, pkt);\n\t} else if (fhci_host_transaction(usb, pkt, td->type, ed->dev_addr,\n\t\t\ted->ep_addr, ed->mode, ed->speed, td->toggle)) {\n\t\t \n\t\tlist_del_init(&td->frame_lh);\n\t\ttd->status = USB_TD_OK;\n\t\tif (pkt->info & PKT_DUMMY_PACKET)\n\t\t\tcq_put(&usb->ep0->dummy_packets_Q, pkt->data);\n\t\trecycle_frame(usb, pkt);\n\t\tusb->actual_frame->total_bytes -= (len + PROTOCOL_OVERHEAD);\n\t\tfhci_err(usb->fhci, \"host transaction failed\\n\");\n\t\treturn -1;\n\t}\n\n\treturn len;\n}\n\nstatic void move_head_to_tail(struct list_head *list)\n{\n\tstruct list_head *node = list->next;\n\n\tif (!list_empty(list)) {\n\t\tlist_move_tail(node, list);\n\t}\n}\n\n \nstatic int scan_ed_list(struct fhci_usb *usb,\n\t\t\tstruct list_head *list, enum fhci_tf_mode list_type)\n{\n\tstatic const int frame_part[4] = {\n\t\t[FHCI_TF_CTRL] = MAX_BYTES_PER_FRAME,\n\t\t[FHCI_TF_ISO] = (MAX_BYTES_PER_FRAME *\n\t\t\t\t MAX_PERIODIC_FRAME_USAGE) / 100,\n\t\t[FHCI_TF_BULK] = MAX_BYTES_PER_FRAME,\n\t\t[FHCI_TF_INTR] = (MAX_BYTES_PER_FRAME *\n\t\t\t\t  MAX_PERIODIC_FRAME_USAGE) / 100\n\t};\n\tstruct ed *ed;\n\tstruct td *td;\n\tint ans = 1;\n\tu32 save_transaction_time = usb->sw_transaction_time;\n\n\tlist_for_each_entry(ed, list, node) {\n\t\ttd = ed->td_head;\n\n\t\tif (!td || td->status == USB_TD_INPROGRESS)\n\t\t\tcontinue;\n\n\t\tif (ed->state != FHCI_ED_OPER) {\n\t\t\tif (ed->state == FHCI_ED_URB_DEL) {\n\t\t\t\ttd->status = USB_TD_OK;\n\t\t\t\tfhci_move_td_from_ed_to_done_list(usb, ed);\n\t\t\t\ted->state = FHCI_ED_SKIP;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t \n\t\tif ((list_type == FHCI_TF_INTR || list_type == FHCI_TF_ISO) &&\n\t\t\t\t(((usb->actual_frame->frame_num -\n\t\t\t\t   td->start_frame) & 0x7ff) < td->interval))\n\t\t\tcontinue;\n\n\t\tif (add_packet(usb, ed, td) < 0)\n\t\t\tcontinue;\n\n\t\t \n\t\ttd->start_frame = usb->actual_frame->frame_num;\n\t\tusb->sw_transaction_time += save_transaction_time;\n\n\t\tif (usb->actual_frame->total_bytes >=\n\t\t\t\t\tusb->max_bytes_per_frame) {\n\t\t\tusb->actual_frame->frame_status =\n\t\t\t\tFRAME_DATA_END_TRANSMISSION;\n\t\t\tfhci_push_dummy_bd(usb->ep0);\n\t\t\tans = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (usb->actual_frame->total_bytes >= frame_part[list_type])\n\t\t\tbreak;\n\t}\n\n\t \n\tmove_head_to_tail(list);\n\tusb->sw_transaction_time = save_transaction_time;\n\n\treturn ans;\n}\n\nstatic u32 rotate_frames(struct fhci_usb *usb)\n{\n\tstruct fhci_hcd *fhci = usb->fhci;\n\n\tif (!list_empty(&usb->actual_frame->tds_list)) {\n\t\tif ((((in_be16(&fhci->pram->frame_num) & 0x07ff) -\n\t\t      usb->actual_frame->frame_num) & 0x7ff) > 5)\n\t\t\tfhci_flush_actual_frame(usb);\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\tusb->actual_frame->frame_status = FRAME_IS_PREPARED;\n\tusb->actual_frame->frame_num = in_be16(&fhci->pram->frame_num) & 0x7ff;\n\tusb->actual_frame->total_bytes = 0;\n\n\treturn 0;\n}\n\n \nvoid fhci_schedule_transactions(struct fhci_usb *usb)\n{\n\tint left = 1;\n\n\tif (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)\n\t\tif (rotate_frames(usb) != 0)\n\t\t\treturn;\n\n\tif (usb->actual_frame->frame_status & FRAME_END_TRANSMISSION)\n\t\treturn;\n\n\tif (usb->actual_frame->total_bytes == 0) {\n\t\t \n\t\tscan_ed_list(usb, &usb->hc_list->iso_list, FHCI_TF_ISO);\n\n\t\t \n\t\tscan_ed_list(usb, &usb->hc_list->intr_list, FHCI_TF_INTR);\n\n\t\t \n\t\tleft = scan_ed_list(usb, &usb->hc_list->ctrl_list,\n\t\t\t\t    FHCI_TF_CTRL);\n\t}\n\n\t \n\tif (left > 0)\n\t\tscan_ed_list(usb, &usb->hc_list->bulk_list, FHCI_TF_BULK);\n}\n\n \nstatic void sof_interrupt(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tif ((usb->port_status == FHCI_PORT_DISABLED) &&\n\t    (usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_CONNECTION) &&\n\t    !(usb->vroot_hub->port.wPortChange & USB_PORT_STAT_C_CONNECTION)) {\n\t\tif (usb->vroot_hub->port.wPortStatus & USB_PORT_STAT_LOW_SPEED)\n\t\t\tusb->port_status = FHCI_PORT_LOW;\n\t\telse\n\t\t\tusb->port_status = FHCI_PORT_FULL;\n\t\t \n\t\tusb->saved_msk &= ~USB_E_IDLE_MASK;\n\t\tout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\n\t}\n\n\tgtm_set_exact_timer16(fhci->timer, usb->max_frame_usage, false);\n\n\tfhci_host_transmit_actual_frame(usb);\n\tusb->actual_frame->frame_status = FRAME_IS_TRANSMITTED;\n\n\tfhci_schedule_transactions(usb);\n}\n\n \nvoid fhci_device_disconnected_interrupt(struct fhci_hcd *fhci)\n{\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tfhci_dbg(fhci, \"-> %s\\n\", __func__);\n\n\tfhci_usb_disable_interrupt(usb);\n\tclrbits8(&usb->fhci->regs->usb_usmod, USB_MODE_LSS);\n\tusb->port_status = FHCI_PORT_DISABLED;\n\n\tfhci_stop_sof_timer(fhci);\n\n\t \n\tusb->saved_msk |= USB_E_IDLE_MASK;\n\tout_be16(&usb->fhci->regs->usb_usbmr, usb->saved_msk);\n\n\tusb->vroot_hub->port.wPortStatus &= ~USB_PORT_STAT_CONNECTION;\n\tusb->vroot_hub->port.wPortChange |= USB_PORT_STAT_C_CONNECTION;\n\tusb->max_bytes_per_frame = 0;\n\tfhci_usb_enable_interrupt(usb);\n\n\tfhci_dbg(fhci, \"<- %s\\n\", __func__);\n}\n\n \nvoid fhci_device_connected_interrupt(struct fhci_hcd *fhci)\n{\n\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\tint state;\n\tint ret;\n\n\tfhci_dbg(fhci, \"-> %s\\n\", __func__);\n\n\tfhci_usb_disable_interrupt(usb);\n\tstate = fhci_ioports_check_bus_state(fhci);\n\n\t \n\tif (state == 1) {\n\t\tret = qe_usb_clock_set(fhci->lowspeed_clk, USB_CLOCK >> 3);\n\t\tif (ret) {\n\t\t\tfhci_warn(fhci, \"Low-Speed device is not supported, \"\n\t\t\t\t  \"try use BRGx\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tusb->port_status = FHCI_PORT_LOW;\n\t\tsetbits8(&usb->fhci->regs->usb_usmod, USB_MODE_LSS);\n\t\tusb->vroot_hub->port.wPortStatus |=\n\t\t    (USB_PORT_STAT_LOW_SPEED |\n\t\t     USB_PORT_STAT_CONNECTION);\n\t\tusb->vroot_hub->port.wPortChange |=\n\t\t    USB_PORT_STAT_C_CONNECTION;\n\t\tusb->max_bytes_per_frame =\n\t\t    (MAX_BYTES_PER_FRAME >> 3) - 7;\n\t\tfhci_port_enable(usb);\n\t} else if (state == 2) {\n\t\tret = qe_usb_clock_set(fhci->fullspeed_clk, USB_CLOCK);\n\t\tif (ret) {\n\t\t\tfhci_warn(fhci, \"Full-Speed device is not supported, \"\n\t\t\t\t  \"try use CLKx\\n\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tusb->port_status = FHCI_PORT_FULL;\n\t\tclrbits8(&usb->fhci->regs->usb_usmod, USB_MODE_LSS);\n\t\tusb->vroot_hub->port.wPortStatus &=\n\t\t    ~USB_PORT_STAT_LOW_SPEED;\n\t\tusb->vroot_hub->port.wPortStatus |=\n\t\t    USB_PORT_STAT_CONNECTION;\n\t\tusb->vroot_hub->port.wPortChange |=\n\t\t    USB_PORT_STAT_C_CONNECTION;\n\t\tusb->max_bytes_per_frame = (MAX_BYTES_PER_FRAME - 15);\n\t\tfhci_port_enable(usb);\n\t}\nout:\n\tfhci_usb_enable_interrupt(usb);\n\tfhci_dbg(fhci, \"<- %s\\n\", __func__);\n}\n\nirqreturn_t fhci_frame_limit_timer_irq(int irq, void *_hcd)\n{\n\tstruct usb_hcd *hcd = _hcd;\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\tstruct fhci_usb *usb = fhci->usb_lld;\n\n\tspin_lock(&fhci->lock);\n\n\tgtm_set_exact_timer16(fhci->timer, 1000, false);\n\n\tif (usb->actual_frame->frame_status == FRAME_IS_TRANSMITTED) {\n\t\tusb->actual_frame->frame_status = FRAME_TIMER_END_TRANSMISSION;\n\t\tfhci_push_dummy_bd(usb->ep0);\n\t}\n\n\tfhci_schedule_transactions(usb);\n\n\tspin_unlock(&fhci->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void abort_transmission(struct fhci_usb *usb)\n{\n\tfhci_dbg(usb->fhci, \"-> %s\\n\", __func__);\n\t \n\tqe_issue_cmd(QE_USB_STOP_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);\n\t \n\tout_8(&usb->fhci->regs->usb_uscom, USB_CMD_FLUSH_FIFO | EP_ZERO);\n\tudelay(1000);\n\t \n\tfhci_flush_bds(usb);\n\t \n\tqe_issue_cmd(QE_USB_RESTART_TX, QE_CR_SUBBLOCK_USB, EP_ZERO, 0);\n\tfhci_dbg(usb->fhci, \"<- %s\\n\", __func__);\n}\n\nirqreturn_t fhci_irq(struct usb_hcd *hcd)\n{\n\tstruct fhci_hcd *fhci = hcd_to_fhci(hcd);\n\tstruct fhci_usb *usb;\n\tu16 usb_er = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&fhci->lock, flags);\n\n\tusb = fhci->usb_lld;\n\n\tusb_er |= in_be16(&usb->fhci->regs->usb_usber) &\n\t\t  in_be16(&usb->fhci->regs->usb_usbmr);\n\n\t \n\tout_be16(&usb->fhci->regs->usb_usber, usb_er);\n\n\tfhci_dbg_isr(fhci, usb_er);\n\n\tif (usb_er & USB_E_RESET_MASK) {\n\t\tif ((usb->port_status == FHCI_PORT_FULL) ||\n\t\t\t\t(usb->port_status == FHCI_PORT_LOW)) {\n\t\t\tfhci_device_disconnected_interrupt(fhci);\n\t\t\tusb_er &= ~USB_E_IDLE_MASK;\n\t\t} else if (usb->port_status == FHCI_PORT_WAITING) {\n\t\t\tusb->port_status = FHCI_PORT_DISCONNECTING;\n\n\t\t\t \n\t\t\tusb->saved_msk |= USB_E_IDLE_MASK;\n\t\t\tout_be16(&usb->fhci->regs->usb_usber,\n\t\t\t\t usb->saved_msk);\n\t\t} else if (usb->port_status == FHCI_PORT_DISABLED) {\n\t\t\tif (fhci_ioports_check_bus_state(fhci) == 1)\n\t\t\t\tfhci_device_connected_interrupt(fhci);\n\t\t}\n\t\tusb_er &= ~USB_E_RESET_MASK;\n\t}\n\n\tif (usb_er & USB_E_MSF_MASK) {\n\t\tabort_transmission(fhci->usb_lld);\n\t\tusb_er &= ~USB_E_MSF_MASK;\n\t}\n\n\tif (usb_er & (USB_E_SOF_MASK | USB_E_SFT_MASK)) {\n\t\tsof_interrupt(fhci);\n\t\tusb_er &= ~(USB_E_SOF_MASK | USB_E_SFT_MASK);\n\t}\n\n\tif (usb_er & USB_E_TXB_MASK) {\n\t\tfhci_tx_conf_interrupt(fhci->usb_lld);\n\t\tusb_er &= ~USB_E_TXB_MASK;\n\t}\n\n\tif (usb_er & USB_E_TXE1_MASK) {\n\t\tfhci_tx_conf_interrupt(fhci->usb_lld);\n\t\tusb_er &= ~USB_E_TXE1_MASK;\n\t}\n\n\tif (usb_er & USB_E_IDLE_MASK) {\n\t\tif (usb->port_status == FHCI_PORT_DISABLED) {\n\t\t\tusb_er &= ~USB_E_RESET_MASK;\n\t\t\tfhci_device_connected_interrupt(fhci);\n\t\t} else if (usb->port_status ==\n\t\t\t\tFHCI_PORT_DISCONNECTING) {\n\t\t\t \n\t\t\t \n\t\t\tusb->saved_msk &= ~USB_E_IDLE_MASK;\n\t\t\tout_be16(&usb->fhci->regs->usb_usbmr,\n\t\t\t\t usb->saved_msk);\n\t\t} else {\n\t\t\tfhci_dbg_isr(fhci, -1);\n\t\t}\n\n\t\tusb_er &= ~USB_E_IDLE_MASK;\n\t}\n\n\tspin_unlock_irqrestore(&fhci->lock, flags);\n\n\treturn IRQ_HANDLED;\n}\n\n\n \nstatic void process_done_list(unsigned long data)\n{\n\tstruct urb *urb;\n\tstruct ed *ed;\n\tstruct td *td;\n\tstruct urb_priv *urb_priv;\n\tstruct fhci_hcd *fhci = (struct fhci_hcd *)data;\n\n\tdisable_irq(fhci->timer->irq);\n\tdisable_irq(fhci_to_hcd(fhci)->irq);\n\tspin_lock(&fhci->lock);\n\n\ttd = fhci_remove_td_from_done_list(fhci->hc_list);\n\twhile (td != NULL) {\n\t\turb = td->urb;\n\t\turb_priv = urb->hcpriv;\n\t\ted = td->ed;\n\n\t\t \n\t\tfhci_done_td(urb, td);\n\t\turb_priv->tds_cnt++;\n\n\t\t \n\t\tif (urb_priv->tds_cnt == urb_priv->num_of_tds) {\n\t\t\tfhci_urb_complete_free(fhci, urb);\n\t\t} else if (urb_priv->state == URB_DEL &&\n\t\t\t\ted->state == FHCI_ED_SKIP) {\n\t\t\tfhci_del_ed_list(fhci, ed);\n\t\t\ted->state = FHCI_ED_OPER;\n\t\t} else if (ed->state == FHCI_ED_HALTED) {\n\t\t\turb_priv->state = URB_DEL;\n\t\t\ted->state = FHCI_ED_URB_DEL;\n\t\t\tfhci_del_ed_list(fhci, ed);\n\t\t\ted->state = FHCI_ED_OPER;\n\t\t}\n\n\t\ttd = fhci_remove_td_from_done_list(fhci->hc_list);\n\t}\n\n\tspin_unlock(&fhci->lock);\n\tenable_irq(fhci->timer->irq);\n\tenable_irq(fhci_to_hcd(fhci)->irq);\n}\n\nDECLARE_TASKLET_OLD(fhci_tasklet, process_done_list);\n\n \nu32 fhci_transfer_confirm_callback(struct fhci_hcd *fhci)\n{\n\tif (!fhci->process_done_task->state)\n\t\ttasklet_schedule(fhci->process_done_task);\n\treturn 0;\n}\n\n \nvoid fhci_queue_urb(struct fhci_hcd *fhci, struct urb *urb)\n{\n\tstruct ed *ed = urb->ep->hcpriv;\n\tstruct urb_priv *urb_priv = urb->hcpriv;\n\tu32 data_len = urb->transfer_buffer_length;\n\tint urb_state = 0;\n\tint toggle = 0;\n\tu8 *data;\n\tu16 cnt = 0;\n\n\tif (ed == NULL) {\n\t\ted = fhci_get_empty_ed(fhci);\n\t\ted->dev_addr = usb_pipedevice(urb->pipe);\n\t\ted->ep_addr = usb_pipeendpoint(urb->pipe);\n\t\tswitch (usb_pipetype(urb->pipe)) {\n\t\tcase PIPE_CONTROL:\n\t\t\ted->mode = FHCI_TF_CTRL;\n\t\t\tbreak;\n\t\tcase PIPE_BULK:\n\t\t\ted->mode = FHCI_TF_BULK;\n\t\t\tbreak;\n\t\tcase PIPE_INTERRUPT:\n\t\t\ted->mode = FHCI_TF_INTR;\n\t\t\tbreak;\n\t\tcase PIPE_ISOCHRONOUS:\n\t\t\ted->mode = FHCI_TF_ISO;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\ted->speed = (urb->dev->speed == USB_SPEED_LOW) ?\n\t\t\tFHCI_LOW_SPEED : FHCI_FULL_SPEED;\n\t\ted->max_pkt_size = usb_endpoint_maxp(&urb->ep->desc);\n\t\turb->ep->hcpriv = ed;\n\t\tfhci_dbg(fhci, \"new ep speed=%d max_pkt_size=%d\\n\",\n\t\t\t ed->speed, ed->max_pkt_size);\n\t}\n\n\t \n\tif (ed->mode == FHCI_TF_ISO) {\n\t\t \n\t\turb->start_frame = ed->td_head ? ed->next_iso :\n\t\t\t\t\t\t get_frame_num(fhci);\n\t\ted->next_iso = (urb->start_frame + urb->interval *\n\t\t\t\turb->number_of_packets) & 0x07ff;\n\t}\n\n\t \n\tif (usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t  usb_pipeout(urb->pipe)))\n\t\ttoggle = USB_TD_TOGGLE_CARRY;\n\telse {\n\t\ttoggle = USB_TD_TOGGLE_DATA0;\n\t\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t      usb_pipeout(urb->pipe), 1);\n\t}\n\n\turb_priv->tds_cnt = 0;\n\turb_priv->ed = ed;\n\tif (data_len > 0)\n\t\tdata = urb->transfer_buffer;\n\telse\n\t\tdata = NULL;\n\n\tswitch (ed->mode) {\n\tcase FHCI_TF_BULK:\n\t\tif (urb->transfer_flags & URB_ZERO_PACKET &&\n\t\t\t\turb->transfer_buffer_length > 0 &&\n\t\t\t\t((urb->transfer_buffer_length %\n\t\t\t\tusb_endpoint_maxp(&urb->ep->desc)) == 0))\n\t\t\turb_state = US_BULK0;\n\t\twhile (data_len > 4096) {\n\t\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt,\n\t\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\n\t\t\t\t\t\t\t FHCI_TA_IN,\n\t\t\t\tcnt ? USB_TD_TOGGLE_CARRY :\n\t\t\t\t      toggle,\n\t\t\t\tdata, 4096, 0, 0, true);\n\t\t\tdata += 4096;\n\t\t\tdata_len -= 4096;\n\t\t\tcnt++;\n\t\t}\n\n\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt,\n\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,\n\t\t\tcnt ? USB_TD_TOGGLE_CARRY : toggle,\n\t\t\tdata, data_len, 0, 0, true);\n\t\tcnt++;\n\n\t\tif (urb->transfer_flags & URB_ZERO_PACKET &&\n\t\t\t\tcnt < urb_priv->num_of_tds) {\n\t\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt,\n\t\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\n\t\t\t\t\t\t\t FHCI_TA_IN,\n\t\t\t\tUSB_TD_TOGGLE_CARRY, NULL, 0, 0, 0, true);\n\t\t\tcnt++;\n\t\t}\n\t\tbreak;\n\tcase FHCI_TF_INTR:\n\t\turb->start_frame = get_frame_num(fhci) + 1;\n\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\n\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT : FHCI_TA_IN,\n\t\t\tUSB_TD_TOGGLE_DATA0, data, data_len,\n\t\t\turb->interval, urb->start_frame, true);\n\t\tbreak;\n\tcase FHCI_TF_CTRL:\n\t\ted->dev_addr = usb_pipedevice(urb->pipe);\n\t\ted->max_pkt_size = usb_endpoint_maxp(&urb->ep->desc);\n\n\t\t \n\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt++, FHCI_TA_SETUP,\n\t\t\tUSB_TD_TOGGLE_DATA0, urb->setup_packet, 8, 0, 0, true);\n\n\t\t \n\t\tif (data_len > 0) {\n\t\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\n\t\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\n\t\t\t\t\t\t\t FHCI_TA_IN,\n\t\t\t\tUSB_TD_TOGGLE_DATA1, data, data_len, 0, 0,\n\t\t\t\ttrue);\n\t\t}\n\n\t\t \n\t\tif (data_len > 0)\n\t\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\n\t\t\t\t(usb_pipeout(urb->pipe) ? FHCI_TA_IN :\n\t\t\t\t\t\t\t  FHCI_TA_OUT),\n\t\t\t\tUSB_TD_TOGGLE_DATA1, data, 0, 0, 0, true);\n\t\telse\n\t\t\t fhci_td_fill(fhci, urb, urb_priv, ed, cnt++,\n\t\t\t\tFHCI_TA_IN,\n\t\t\t\tUSB_TD_TOGGLE_DATA1, data, 0, 0, 0, true);\n\n\t\turb_state = US_CTRL_SETUP;\n\t\tbreak;\n\tcase FHCI_TF_ISO:\n\t\tfor (cnt = 0; cnt < urb->number_of_packets; cnt++) {\n\t\t\tu16 frame = urb->start_frame;\n\n\t\t\t \n\t\t\tframe += cnt * urb->interval;\n\t\t\tframe &= 0x07ff;\n\t\t\tfhci_td_fill(fhci, urb, urb_priv, ed, cnt,\n\t\t\t\tusb_pipeout(urb->pipe) ? FHCI_TA_OUT :\n\t\t\t\t\t\t\t FHCI_TA_IN,\n\t\t\t\tUSB_TD_TOGGLE_DATA0,\n\t\t\t\tdata + urb->iso_frame_desc[cnt].offset,\n\t\t\t\turb->iso_frame_desc[cnt].length,\n\t\t\t\turb->interval, frame, true);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t \n\turb->pipe &= ~0x1f;\n\turb->pipe |= urb_state & 0x1f;\n\n\turb_priv->state = URB_INPROGRESS;\n\n\tif (!ed->td_head) {\n\t\ted->state = FHCI_ED_OPER;\n\t\tswitch (ed->mode) {\n\t\tcase FHCI_TF_CTRL:\n\t\t\tlist_add(&ed->node, &fhci->hc_list->ctrl_list);\n\t\t\tbreak;\n\t\tcase FHCI_TF_BULK:\n\t\t\tlist_add(&ed->node, &fhci->hc_list->bulk_list);\n\t\t\tbreak;\n\t\tcase FHCI_TF_INTR:\n\t\t\tlist_add(&ed->node, &fhci->hc_list->intr_list);\n\t\t\tbreak;\n\t\tcase FHCI_TF_ISO:\n\t\t\tlist_add(&ed->node, &fhci->hc_list->iso_list);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfhci_add_tds_to_ed(ed, urb_priv->tds, urb_priv->num_of_tds);\n\tfhci->active_urbs++;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}