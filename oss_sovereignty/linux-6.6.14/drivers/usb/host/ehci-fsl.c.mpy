{
  "module_name": "ehci-fsl.c",
  "hash_id": "911d673491cac8da6c407624e946940440011891a0f548faaeea629266af2669",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-fsl.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/delay.h>\n#include <linux/pm.h>\n#include <linux/err.h>\n#include <linux/usb.h>\n#include <linux/usb/ehci_def.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/platform_device.h>\n#include <linux/fsl_devices.h>\n#include <linux/of.h>\n#include <linux/io.h>\n\n#include \"ehci.h\"\n#include \"ehci-fsl.h\"\n\n#define DRIVER_DESC \"Freescale EHCI Host controller driver\"\n#define DRV_NAME \"fsl-ehci\"\n\nstatic struct hc_driver __read_mostly fsl_ehci_hc_driver;\n\n \n \n\n \nstatic int fsl_ehci_drv_probe(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata;\n\tstruct usb_hcd *hcd;\n\tstruct resource *res;\n\tint irq;\n\tint retval;\n\tu32 tmp;\n\n\tpr_debug(\"initializing FSL-SOC USB Controller\\n\");\n\n\t \n\tpdata = dev_get_platdata(&pdev->dev);\n\tif (!pdata) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"No platform data for %s.\\n\", dev_name(&pdev->dev));\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (!((pdata->operating_mode == FSL_USB2_DR_HOST) ||\n\t      (pdata->operating_mode == FSL_USB2_MPH_HOST) ||\n\t      (pdata->operating_mode == FSL_USB2_DR_OTG))) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Non Host Mode configured for %s. Wrong driver linked.\\n\",\n\t\t\tdev_name(&pdev->dev));\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = __usb_create_hcd(&fsl_ehci_hc_driver, pdev->dev.parent,\n\t\t\t       &pdev->dev, dev_name(&pdev->dev), NULL);\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tretval = PTR_ERR(hcd->regs);\n\t\tgoto err2;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tpdata->regs = hcd->regs;\n\n\tif (pdata->power_budget)\n\t\thcd->power_budget = pdata->power_budget;\n\n\t \n\tif (pdata->init && pdata->init(pdev)) {\n\t\tretval = -ENODEV;\n\t\tgoto err2;\n\t}\n\n\t \n\tif (pdata->have_sysif_regs && pdata->controller_ver < FSL_USB_VER_1_6) {\n\t\ttmp = ioread32be(hcd->regs + FSL_SOC_USB_CTRL);\n\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\ttmp |= 0x4;\n\t\tiowrite32be(tmp, hcd->regs + FSL_SOC_USB_CTRL);\n\t}\n\n\t \n\tif (pdata->controller_ver == FSL_USB_VER_2_5 &&\n\t    pdata->phy_mode == FSL_USB2_PHY_ULPI)\n\t\tiowrite32be(USB_CTRL_USB_EN, hcd->regs + FSL_SOC_USB_CTRL);\n\n\t \n\tif (pdata->has_fsl_erratum_a007792) {\n\t\ttmp = ioread32be(hcd->regs + FSL_SOC_USB_CTRL);\n\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\ttmp |= CTRL_UTMI_PHY_EN;\n\t\tiowrite32be(tmp, hcd->regs + FSL_SOC_USB_CTRL);\n\n\t\twritel(PORT_PTS_UTMI, hcd->regs + FSL_SOC_USB_PORTSC1);\n\t}\n\n\t \n\n\tretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (retval != 0)\n\t\tgoto err2;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n#ifdef CONFIG_USB_OTG\n\tif (pdata->operating_mode == FSL_USB2_DR_OTG) {\n\t\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\n\t\thcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);\n\t\tdev_dbg(&pdev->dev, \"hcd=0x%p  ehci=0x%p, phy=0x%p\\n\",\n\t\t\thcd, ehci, hcd->usb_phy);\n\n\t\tif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\n\t\t\tretval = otg_set_host(hcd->usb_phy->otg,\n\t\t\t\t\t      &ehci_to_hcd(ehci)->self);\n\t\t\tif (retval) {\n\t\t\t\tusb_put_phy(hcd->usb_phy);\n\t\t\t\tgoto err2;\n\t\t\t}\n\t\t} else {\n\t\t\tdev_err(&pdev->dev, \"can't find phy\\n\");\n\t\t\tretval = -ENODEV;\n\t\t\tgoto err2;\n\t\t}\n\n\t\thcd->skip_phy_initialization = 1;\n\t}\n#endif\n\treturn retval;\n\n      err2:\n\tusb_put_hcd(hcd);\n      err1:\n\tdev_err(&pdev->dev, \"init %s fail, %d\\n\", dev_name(&pdev->dev), retval);\n\tif (pdata->exit)\n\t\tpdata->exit(pdev);\n\treturn retval;\n}\n\nstatic bool usb_phy_clk_valid(struct usb_hcd *hcd)\n{\n\tvoid __iomem *non_ehci = hcd->regs;\n\tbool ret = true;\n\n\tif (!(ioread32be(non_ehci + FSL_SOC_USB_CTRL) & PHY_CLK_VALID))\n\t\tret = false;\n\n\treturn ret;\n}\n\nstatic int ehci_fsl_setup_phy(struct usb_hcd *hcd,\n\t\t\t       enum fsl_usb2_phy_modes phy_mode,\n\t\t\t       unsigned int port_offset)\n{\n\tu32 portsc, tmp;\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tvoid __iomem *non_ehci = hcd->regs;\n\tstruct device *dev = hcd->self.controller;\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\n\n\tif (pdata->controller_ver < 0) {\n\t\tdev_warn(hcd->self.controller, \"Could not get controller version\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tportsc = ehci_readl(ehci, &ehci->regs->port_status[port_offset]);\n\tportsc &= ~(PORT_PTS_MSK | PORT_PTS_PTW);\n\n\tswitch (phy_mode) {\n\tcase FSL_USB2_PHY_ULPI:\n\t\tif (pdata->have_sysif_regs && pdata->controller_ver) {\n\t\t\t \n\t\t\t \n\t\t\ttmp = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\t\t\ttmp &= ~(CONTROL_REGISTER_W1C_MASK | UTMI_PHY_EN);\n\t\t\tiowrite32be(tmp, non_ehci + FSL_SOC_USB_CTRL);\n\n\t\t\t \n\t\t\ttmp = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\t\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\t\ttmp |= ULPI_PHY_CLK_SEL | USB_CTRL_USB_EN;\n\t\t\tiowrite32be(tmp, non_ehci + FSL_SOC_USB_CTRL);\n\t\t}\n\t\tportsc |= PORT_PTS_ULPI;\n\t\tbreak;\n\tcase FSL_USB2_PHY_SERIAL:\n\t\tportsc |= PORT_PTS_SERIAL;\n\t\tbreak;\n\tcase FSL_USB2_PHY_UTMI_WIDE:\n\t\tportsc |= PORT_PTS_PTW;\n\t\tfallthrough;\n\tcase FSL_USB2_PHY_UTMI:\n\t\t \n\t\tif (pdata->has_fsl_erratum_a006918) {\n\t\t\tdev_warn(dev, \"USB PHY clock invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tfallthrough;\n\tcase FSL_USB2_PHY_UTMI_DUAL:\n\t\t \n\t\tif (pdata->controller_ver > FSL_USB_VER_2_4 &&\n\t\t    pdata->have_sysif_regs && !usb_phy_clk_valid(hcd)) {\n\t\t\tdev_err(dev, \"USB PHY clock invalid\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (pdata->have_sysif_regs && pdata->controller_ver) {\n\t\t\t \n\t\t\ttmp = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\t\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\t\ttmp |= UTMI_PHY_EN;\n\t\t\tiowrite32be(tmp, non_ehci + FSL_SOC_USB_CTRL);\n\n\t\t\tmdelay(FSL_UTMI_PHY_DLY);   \n\t\t}\n\t\t \n\t\tif (pdata->have_sysif_regs) {\n\t\t\ttmp = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\t\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\t\ttmp |= CTRL_UTMI_PHY_EN;\n\t\t\tiowrite32be(tmp, non_ehci + FSL_SOC_USB_CTRL);\n\t\t}\n\t\tportsc |= PORT_PTS_UTMI;\n\t\tbreak;\n\tcase FSL_USB2_PHY_NONE:\n\t\tbreak;\n\t}\n\n\tif (pdata->have_sysif_regs &&\n\t    pdata->controller_ver > FSL_USB_VER_1_6 &&\n\t    !usb_phy_clk_valid(hcd)) {\n\t\tdev_warn(hcd->self.controller, \"USB PHY clock invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tehci_writel(ehci, portsc, &ehci->regs->port_status[port_offset]);\n\n\tif (phy_mode != FSL_USB2_PHY_ULPI && pdata->have_sysif_regs) {\n\t\ttmp = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\t\ttmp &= ~CONTROL_REGISTER_W1C_MASK;\n\t\ttmp |= USB_CTRL_USB_EN;\n\t\tiowrite32be(tmp, non_ehci + FSL_SOC_USB_CTRL);\n\t}\n\n\treturn 0;\n}\n\nstatic int ehci_fsl_usb_setup(struct ehci_hcd *ehci)\n{\n\tstruct usb_hcd *hcd = ehci_to_hcd(ehci);\n\tstruct fsl_usb2_platform_data *pdata;\n\tvoid __iomem *non_ehci = hcd->regs;\n\n\tpdata = dev_get_platdata(hcd->self.controller);\n\n\tif (pdata->have_sysif_regs) {\n\t\t \n\n\t\t \n\t\t \n\t\tiowrite32be(0x0 | SNOOP_SIZE_2GB,\n\t\t\t    non_ehci + FSL_SOC_USB_SNOOP1);\n\t\t \n\t\tiowrite32be(0x80000000 | SNOOP_SIZE_2GB,\n\t\t\t    non_ehci + FSL_SOC_USB_SNOOP2);\n\t}\n\n\t \n\tif (pdata->has_fsl_erratum_a005275 == 1)\n\t\tehci->has_fsl_hs_errata = 1;\n\n\tif (pdata->has_fsl_erratum_a005697 == 1)\n\t\tehci->has_fsl_susp_errata = 1;\n\n\tif ((pdata->operating_mode == FSL_USB2_DR_HOST) ||\n\t\t\t(pdata->operating_mode == FSL_USB2_DR_OTG))\n\t\tif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 0))\n\t\t\treturn -EINVAL;\n\n\tif (pdata->operating_mode == FSL_USB2_MPH_HOST) {\n\n\t\t \n\t\tif (pdata->has_fsl_erratum_14 == 1)\n\t\t\tehci->has_fsl_port_bug = 1;\n\n\t\tif (pdata->port_enables & FSL_USB2_PORT0_ENABLED)\n\t\t\tif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 0))\n\t\t\t\treturn -EINVAL;\n\n\t\tif (pdata->port_enables & FSL_USB2_PORT1_ENABLED)\n\t\t\tif (ehci_fsl_setup_phy(hcd, pdata->phy_mode, 1))\n\t\t\t\treturn -EINVAL;\n\t}\n\n\tif (pdata->have_sysif_regs) {\n#ifdef CONFIG_FSL_SOC_BOOKE\n\t\tiowrite32be(0x00000008, non_ehci + FSL_SOC_USB_PRICTRL);\n\t\tiowrite32be(0x00000080, non_ehci + FSL_SOC_USB_AGECNTTHRSH);\n#else\n\t\tiowrite32be(0x0000000c, non_ehci + FSL_SOC_USB_PRICTRL);\n\t\tiowrite32be(0x00000040, non_ehci + FSL_SOC_USB_AGECNTTHRSH);\n#endif\n\t\tiowrite32be(0x00000001, non_ehci + FSL_SOC_USB_SICTRL);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ehci_fsl_reinit(struct ehci_hcd *ehci)\n{\n\tif (ehci_fsl_usb_setup(ehci))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n \nstatic int ehci_fsl_setup(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tint retval;\n\tstruct fsl_usb2_platform_data *pdata;\n\tstruct device *dev;\n\n\tdev = hcd->self.controller;\n\tpdata = dev_get_platdata(hcd->self.controller);\n\tehci->big_endian_desc = pdata->big_endian_desc;\n\tehci->big_endian_mmio = pdata->big_endian_mmio;\n\n\t \n\tehci->caps = hcd->regs + 0x100;\n\n#if defined(CONFIG_PPC_83xx) || defined(CONFIG_PPC_85xx)\n\t \n\tehci->need_oc_pp_cycle = 1;\n#endif\n\n\thcd->has_tt = 1;\n\n\tretval = ehci_setup(hcd);\n\tif (retval)\n\t\treturn retval;\n\n\tif (of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t    \"fsl,mpc5121-usb2-dr\")) {\n\t\t \n\t\tehci_writel(ehci, SBUSCFG_INCR8,\n\t\t\t    hcd->regs + FSL_SOC_USB_SBUSCFG);\n\t}\n\n\tretval = ehci_fsl_reinit(ehci);\n\treturn retval;\n}\n\nstruct ehci_fsl {\n\tstruct ehci_hcd\tehci;\n\n#ifdef CONFIG_PM\n\t \n\tu32 usb_ctrl;\n#endif\n};\n\n#ifdef CONFIG_PM\n\n#ifdef CONFIG_PPC_MPC512x\nstatic int ehci_fsl_mpc512x_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\n\tu32 tmp;\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\tu32 mode = ehci_readl(ehci, hcd->regs + FSL_SOC_USB_USBMODE);\n\tmode &= USBMODE_CM_MASK;\n\ttmp = ehci_readl(ehci, hcd->regs + 0x140);\t \n\n\tdev_dbg(dev, \"suspend=%d already_suspended=%d \"\n\t\t\"mode=%d  usbcmd %08x\\n\", pdata->suspended,\n\t\tpdata->already_suspended, mode, tmp);\n#endif\n\n\t \n\tif (pdata->suspended) {\n\t\tdev_dbg(dev, \"already suspended, leaving early\\n\");\n\t\tpdata->already_suspended = 1;\n\t\treturn 0;\n\t}\n\n\tdev_dbg(dev, \"suspending...\\n\");\n\n\tehci->rh_state = EHCI_RH_SUSPENDED;\n\tdev->power.power_state = PMSG_SUSPEND;\n\n\t \n\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\t \n\ttmp = ehci_readl(ehci, &ehci->regs->command);\n\ttmp &= ~CMD_RUN;\n\tehci_writel(ehci, tmp, &ehci->regs->command);\n\n\t \n\tpdata->pm_command = ehci_readl(ehci, &ehci->regs->command);\n\tpdata->pm_command &= ~CMD_RUN;\n\tpdata->pm_status  = ehci_readl(ehci, &ehci->regs->status);\n\tpdata->pm_intr_enable  = ehci_readl(ehci, &ehci->regs->intr_enable);\n\tpdata->pm_frame_index  = ehci_readl(ehci, &ehci->regs->frame_index);\n\tpdata->pm_segment  = ehci_readl(ehci, &ehci->regs->segment);\n\tpdata->pm_frame_list  = ehci_readl(ehci, &ehci->regs->frame_list);\n\tpdata->pm_async_next  = ehci_readl(ehci, &ehci->regs->async_next);\n\tpdata->pm_configured_flag  =\n\t\tehci_readl(ehci, &ehci->regs->configured_flag);\n\tpdata->pm_portsc = ehci_readl(ehci, &ehci->regs->port_status[0]);\n\tpdata->pm_usbgenctrl = ehci_readl(ehci,\n\t\t\t\t\t  hcd->regs + FSL_SOC_USB_USBGENCTRL);\n\n\t \n\tpdata->pm_portsc &= cpu_to_hc32(ehci, ~PORT_RWC_BITS);\n\n\tpdata->suspended = 1;\n\n\t \n\ttmp = ehci_readl(ehci, &ehci->regs->port_status[0]);\n\ttmp &= ~PORT_POWER;\n\tehci_writel(ehci, tmp, &ehci->regs->port_status[0]);\n\n\treturn 0;\n}\n\nstatic int ehci_fsl_mpc512x_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(dev);\n\tu32 tmp;\n\n\tdev_dbg(dev, \"suspend=%d already_suspended=%d\\n\",\n\t\tpdata->suspended, pdata->already_suspended);\n\n\t \n\tif (pdata->already_suspended) {\n\t\tdev_dbg(dev, \"already suspended, leaving early\\n\");\n\t\tpdata->already_suspended = 0;\n\t\treturn 0;\n\t}\n\n\tif (!pdata->suspended) {\n\t\tdev_dbg(dev, \"not suspended, leaving early\\n\");\n\t\treturn 0;\n\t}\n\n\tpdata->suspended = 0;\n\n\tdev_dbg(dev, \"resuming...\\n\");\n\n\t \n\ttmp = USBMODE_CM_HOST | (pdata->es ? USBMODE_ES : 0);\n\tehci_writel(ehci, tmp, hcd->regs + FSL_SOC_USB_USBMODE);\n\n\tehci_writel(ehci, pdata->pm_usbgenctrl,\n\t\t    hcd->regs + FSL_SOC_USB_USBGENCTRL);\n\tehci_writel(ehci, ISIPHYCTRL_PXE | ISIPHYCTRL_PHYE,\n\t\t    hcd->regs + FSL_SOC_USB_ISIPHYCTRL);\n\n\tehci_writel(ehci, SBUSCFG_INCR8, hcd->regs + FSL_SOC_USB_SBUSCFG);\n\n\t \n\tehci_writel(ehci, pdata->pm_command, &ehci->regs->command);\n\tehci_writel(ehci, pdata->pm_intr_enable, &ehci->regs->intr_enable);\n\tehci_writel(ehci, pdata->pm_frame_index, &ehci->regs->frame_index);\n\tehci_writel(ehci, pdata->pm_segment, &ehci->regs->segment);\n\tehci_writel(ehci, pdata->pm_frame_list, &ehci->regs->frame_list);\n\tehci_writel(ehci, pdata->pm_async_next, &ehci->regs->async_next);\n\tehci_writel(ehci, pdata->pm_configured_flag,\n\t\t    &ehci->regs->configured_flag);\n\tehci_writel(ehci, pdata->pm_portsc, &ehci->regs->port_status[0]);\n\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tehci->rh_state = EHCI_RH_RUNNING;\n\tdev->power.power_state = PMSG_ON;\n\n\ttmp = ehci_readl(ehci, &ehci->regs->command);\n\ttmp |= CMD_RUN;\n\tehci_writel(ehci, tmp, &ehci->regs->command);\n\n\tusb_hcd_resume_root_hub(hcd);\n\n\treturn 0;\n}\n#else\nstatic inline int ehci_fsl_mpc512x_drv_suspend(struct device *dev)\n{\n\treturn 0;\n}\n\nstatic inline int ehci_fsl_mpc512x_drv_resume(struct device *dev)\n{\n\treturn 0;\n}\n#endif  \n\nstatic struct ehci_fsl *hcd_to_ehci_fsl(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\n\treturn container_of(ehci, struct ehci_fsl, ehci);\n}\n\nstatic int ehci_fsl_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);\n\tvoid __iomem *non_ehci = hcd->regs;\n\n\tif (of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t    \"fsl,mpc5121-usb2-dr\")) {\n\t\treturn ehci_fsl_mpc512x_drv_suspend(dev);\n\t}\n\n\tehci_prepare_ports_for_controller_suspend(hcd_to_ehci(hcd),\n\t\t\tdevice_may_wakeup(dev));\n\tif (!fsl_deep_sleep())\n\t\treturn 0;\n\n\tehci_fsl->usb_ctrl = ioread32be(non_ehci + FSL_SOC_USB_CTRL);\n\treturn 0;\n}\n\nstatic int ehci_fsl_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct ehci_fsl *ehci_fsl = hcd_to_ehci_fsl(hcd);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tvoid __iomem *non_ehci = hcd->regs;\n\n\tif (of_device_is_compatible(dev->parent->of_node,\n\t\t\t\t    \"fsl,mpc5121-usb2-dr\")) {\n\t\treturn ehci_fsl_mpc512x_drv_resume(dev);\n\t}\n\n\tehci_prepare_ports_for_controller_resume(ehci);\n\tif (!fsl_deep_sleep())\n\t\treturn 0;\n\n\tusb_root_hub_lost_power(hcd->self.root_hub);\n\n\t \n\tiowrite32be(ehci_fsl->usb_ctrl, non_ehci + FSL_SOC_USB_CTRL);\n\n\tehci_reset(ehci);\n\tehci_fsl_reinit(ehci);\n\n\treturn 0;\n}\n\nstatic int ehci_fsl_drv_restore(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\n\tusb_root_hub_lost_power(hcd->self.root_hub);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ehci_fsl_pm_ops = {\n\t.suspend = ehci_fsl_drv_suspend,\n\t.resume = ehci_fsl_drv_resume,\n\t.restore = ehci_fsl_drv_restore,\n};\n\n#define EHCI_FSL_PM_OPS\t\t(&ehci_fsl_pm_ops)\n#else\n#define EHCI_FSL_PM_OPS\t\tNULL\n#endif  \n\n#ifdef CONFIG_USB_OTG\nstatic int ehci_start_port_reset(struct usb_hcd *hcd, unsigned port)\n{\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tu32 status;\n\n\tif (!port)\n\t\treturn -EINVAL;\n\n\tport--;\n\n\t \n\tstatus = readl(&ehci->regs->port_status[port]);\n\tif (!(status & PORT_CONNECT))\n\t\treturn -ENODEV;\n\n\t \n\tif (ehci_is_TDI(ehci)) {\n\t\twritel(PORT_RESET |\n\t\t       (status & ~(PORT_CSC | PORT_PEC | PORT_OCC)),\n\t\t       &ehci->regs->port_status[port]);\n\t} else {\n\t\twritel(PORT_RESET, &ehci->regs->port_status[port]);\n\t}\n\n\treturn 0;\n}\n#else\n#define ehci_start_port_reset\tNULL\n#endif  \n\nstatic const struct ehci_driver_overrides ehci_fsl_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct ehci_fsl),\n\t.reset = ehci_fsl_setup,\n};\n\n \nstatic void fsl_ehci_drv_remove(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\n\t\totg_set_host(hcd->usb_phy->otg, NULL);\n\t\tusb_put_phy(hcd->usb_phy);\n\t}\n\n\tusb_remove_hcd(hcd);\n\n\t \n\tif (pdata->exit)\n\t\tpdata->exit(pdev);\n\tusb_put_hcd(hcd);\n}\n\nstatic struct platform_driver ehci_fsl_driver = {\n\t.probe = fsl_ehci_drv_probe,\n\t.remove_new = fsl_ehci_drv_remove,\n\t.shutdown = usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name = DRV_NAME,\n\t\t.pm = EHCI_FSL_PM_OPS,\n\t},\n};\n\nstatic int __init ehci_fsl_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&fsl_ehci_hc_driver, &ehci_fsl_overrides);\n\n\tfsl_ehci_hc_driver.product_desc =\n\t\t\t\"Freescale On-Chip EHCI Host Controller\";\n\tfsl_ehci_hc_driver.start_port_reset = ehci_start_port_reset;\n\n\n\treturn platform_driver_register(&ehci_fsl_driver);\n}\nmodule_init(ehci_fsl_init);\n\nstatic void __exit ehci_fsl_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_fsl_driver);\n}\nmodule_exit(ehci_fsl_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}