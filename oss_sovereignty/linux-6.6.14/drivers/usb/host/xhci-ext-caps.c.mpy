{
  "module_name": "xhci-ext-caps.c",
  "hash_id": "9ef14aa592add3c30ead8c757a014afc71b24d026d176c232727e6f3a8797529",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-ext-caps.c",
  "human_readable_source": "\n \n\n#include <linux/platform_device.h>\n#include <linux/property.h>\n#include <linux/pci.h>\n#include \"xhci.h\"\n\n#define USB_SW_DRV_NAME\t\t\"intel_xhci_usb_sw\"\n#define USB_SW_RESOURCE_SIZE\t0x400\n\n#define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI\t0x22b5\n\nstatic const struct property_entry role_switch_props[] = {\n\tPROPERTY_ENTRY_BOOL(\"sw_switch_disable\"),\n\t{},\n};\n\nstatic void xhci_intel_unregister_pdev(void *arg)\n{\n\tplatform_device_unregister(arg);\n}\n\nstatic int xhci_create_intel_xhci_sw_pdev(struct xhci_hcd *xhci, u32 cap_offset)\n{\n\tstruct usb_hcd *hcd = xhci_to_hcd(xhci);\n\tstruct device *dev = hcd->self.controller;\n\tstruct platform_device *pdev;\n\tstruct pci_dev *pci = to_pci_dev(dev);\n\tstruct resource\tres = { 0, };\n\tint ret;\n\n\tpdev = platform_device_alloc(USB_SW_DRV_NAME, PLATFORM_DEVID_NONE);\n\tif (!pdev) {\n\t\txhci_err(xhci, \"couldn't allocate %s platform device\\n\",\n\t\t\t USB_SW_DRV_NAME);\n\t\treturn -ENOMEM;\n\t}\n\n\tres.start = hcd->rsrc_start + cap_offset;\n\tres.end\t  = res.start + USB_SW_RESOURCE_SIZE - 1;\n\tres.name  = USB_SW_DRV_NAME;\n\tres.flags = IORESOURCE_MEM;\n\n\tret = platform_device_add_resources(pdev, &res, 1);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add resources to intel_xhci_usb_sw pdev\\n\");\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tif (pci->device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {\n\t\tret = device_create_managed_software_node(&pdev->dev, role_switch_props,\n\t\t\t\t\t\t\t  NULL);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"failed to register device properties\\n\");\n\t\t\tplatform_device_put(pdev);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tpdev->dev.parent = dev;\n\n\tret = platform_device_add(pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't register intel_xhci_usb_sw pdev\\n\");\n\t\tplatform_device_put(pdev);\n\t\treturn ret;\n\t}\n\n\tret = devm_add_action_or_reset(dev, xhci_intel_unregister_pdev, pdev);\n\tif (ret) {\n\t\tdev_err(dev, \"couldn't add unregister action for intel_xhci_usb_sw pdev\\n\");\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nint xhci_ext_cap_init(struct xhci_hcd *xhci)\n{\n\tvoid __iomem *base = &xhci->cap_regs->hc_capbase;\n\tu32 offset, val;\n\tint ret;\n\n\toffset = xhci_find_next_ext_cap(base, 0, 0);\n\n\twhile (offset) {\n\t\tval = readl(base + offset);\n\n\t\tswitch (XHCI_EXT_CAPS_ID(val)) {\n\t\tcase XHCI_EXT_CAPS_VENDOR_INTEL:\n\t\t\tif (xhci->quirks & XHCI_INTEL_USB_ROLE_SW) {\n\t\t\t\tret = xhci_create_intel_xhci_sw_pdev(xhci,\n\t\t\t\t\t\t\t\t     offset);\n\t\t\t\tif (ret)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\toffset = xhci_find_next_ext_cap(base, offset, 0);\n\t}\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(xhci_ext_cap_init);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}