{
  "module_name": "xen-hcd.c",
  "hash_id": "41cc5ef802f17b57e6389d89583ef22bf02a6ed4f8a458dd456aadc93eddd9bd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xen-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/usb.h>\n#include <linux/list.h>\n#include <linux/usb/hcd.h>\n#include <linux/io.h>\n\n#include <xen/xen.h>\n#include <xen/xenbus.h>\n#include <xen/grant_table.h>\n#include <xen/events.h>\n#include <xen/page.h>\n\n#include <xen/interface/io/usbif.h>\n\n \nstruct urb_priv {\n\tstruct list_head list;\n\tstruct urb *urb;\n\tint req_id;\t\t \n\tint unlink_req_id;\t \n\tint status;\n\tbool unlinked;\t\t \n};\n\n \nstruct rhport_status {\n\t__u32 status;\n\tbool resuming;\t\t \n\tbool c_connection;\t \n\tunsigned long timeout;\n};\n\n \nstruct vdevice_status {\n\tint devnum;\n\tenum usb_device_state status;\n\tenum usb_device_speed speed;\n};\n\n \nstruct usb_shadow {\n\tstruct xenusb_urb_request req;\n\tstruct urb *urb;\n\tbool in_flight;\n};\n\nstruct xenhcd_info {\n\t \n\tstruct list_head pending_submit_list;\n\tstruct list_head pending_unlink_list;\n\tstruct list_head in_progress_list;\n\tstruct list_head giveback_waiting_list;\n\n\tspinlock_t lock;\n\n\t \n\tstruct timer_list watchdog;\n\tunsigned long actions;\n\n\t \n\tint rh_numports;\n\tstruct rhport_status ports[XENUSB_MAX_PORTNR];\n\tstruct vdevice_status devices[XENUSB_MAX_PORTNR];\n\n\t \n\tstruct xenbus_device *xbdev;\n\tint urb_ring_ref;\n\tint conn_ring_ref;\n\tstruct xenusb_urb_front_ring urb_ring;\n\tstruct xenusb_conn_front_ring conn_ring;\n\n\tunsigned int evtchn;\n\tunsigned int irq;\n\tstruct usb_shadow shadow[XENUSB_URB_RING_SIZE];\n\tunsigned int shadow_free;\n\n\tbool error;\n};\n\n#define XENHCD_RING_JIFFIES (HZ/200)\n#define XENHCD_SCAN_JIFFIES 1\n\nenum xenhcd_timer_action {\n\tTIMER_RING_WATCHDOG,\n\tTIMER_SCAN_PENDING_URBS,\n};\n\nstatic struct kmem_cache *xenhcd_urbp_cachep;\n\nstatic inline struct xenhcd_info *xenhcd_hcd_to_info(struct usb_hcd *hcd)\n{\n\treturn (struct xenhcd_info *)hcd->hcd_priv;\n}\n\nstatic inline struct usb_hcd *xenhcd_info_to_hcd(struct xenhcd_info *info)\n{\n\treturn container_of((void *)info, struct usb_hcd, hcd_priv);\n}\n\nstatic void xenhcd_set_error(struct xenhcd_info *info, const char *msg)\n{\n\tinfo->error = true;\n\n\tpr_alert(\"xen-hcd: protocol error: %s!\\n\", msg);\n}\n\nstatic inline void xenhcd_timer_action_done(struct xenhcd_info *info,\n\t\t\t\t\t    enum xenhcd_timer_action action)\n{\n\tclear_bit(action, &info->actions);\n}\n\nstatic void xenhcd_timer_action(struct xenhcd_info *info,\n\t\t\t\tenum xenhcd_timer_action action)\n{\n\tif (timer_pending(&info->watchdog) &&\n\t    test_bit(TIMER_SCAN_PENDING_URBS, &info->actions))\n\t\treturn;\n\n\tif (!test_and_set_bit(action, &info->actions)) {\n\t\tunsigned long t;\n\n\t\tswitch (action) {\n\t\tcase TIMER_RING_WATCHDOG:\n\t\t\tt = XENHCD_RING_JIFFIES;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tt = XENHCD_SCAN_JIFFIES;\n\t\t\tbreak;\n\t\t}\n\t\tmod_timer(&info->watchdog, t + jiffies);\n\t}\n}\n\n \nstatic void xenhcd_set_connect_state(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tif (info->ports[port].status & USB_PORT_STAT_POWER) {\n\t\tswitch (info->devices[port].speed) {\n\t\tcase XENUSB_SPEED_NONE:\n\t\t\tinfo->ports[port].status &=\n\t\t\t\t~(USB_PORT_STAT_CONNECTION |\n\t\t\t\t  USB_PORT_STAT_ENABLE |\n\t\t\t\t  USB_PORT_STAT_LOW_SPEED |\n\t\t\t\t  USB_PORT_STAT_HIGH_SPEED |\n\t\t\t\t  USB_PORT_STAT_SUSPEND);\n\t\t\tbreak;\n\t\tcase XENUSB_SPEED_LOW:\n\t\t\tinfo->ports[port].status |= USB_PORT_STAT_CONNECTION;\n\t\t\tinfo->ports[port].status |= USB_PORT_STAT_LOW_SPEED;\n\t\t\tbreak;\n\t\tcase XENUSB_SPEED_FULL:\n\t\t\tinfo->ports[port].status |= USB_PORT_STAT_CONNECTION;\n\t\t\tbreak;\n\t\tcase XENUSB_SPEED_HIGH:\n\t\t\tinfo->ports[port].status |= USB_PORT_STAT_CONNECTION;\n\t\t\tinfo->ports[port].status |= USB_PORT_STAT_HIGH_SPEED;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\treturn;\n\t\t}\n\t\tinfo->ports[port].status |= (USB_PORT_STAT_C_CONNECTION << 16);\n\t}\n}\n\n \nstatic int xenhcd_rhport_connect(struct xenhcd_info *info, __u8 portnum,\n\t\t\t\t __u8 speed)\n{\n\tint port;\n\n\tif (portnum < 1 || portnum > info->rh_numports)\n\t\treturn -EINVAL;  \n\n\tport = portnum - 1;\n\tif (info->devices[port].speed != speed) {\n\t\tswitch (speed) {\n\t\tcase XENUSB_SPEED_NONE:  \n\t\t\tinfo->devices[port].status = USB_STATE_NOTATTACHED;\n\t\t\tbreak;\n\t\tcase XENUSB_SPEED_LOW:\n\t\tcase XENUSB_SPEED_FULL:\n\t\tcase XENUSB_SPEED_HIGH:\n\t\t\tinfo->devices[port].status = USB_STATE_ATTACHED;\n\t\t\tbreak;\n\t\tdefault:  \n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo->devices[port].speed = speed;\n\t\tinfo->ports[port].c_connection = true;\n\n\t\txenhcd_set_connect_state(info, portnum);\n\t}\n\n\treturn 0;\n}\n\n \nstatic void xenhcd_rhport_suspend(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tinfo->ports[port].status |= USB_PORT_STAT_SUSPEND;\n\tinfo->devices[port].status = USB_STATE_SUSPENDED;\n}\n\n \nstatic void xenhcd_rhport_resume(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tif (info->ports[port].status & USB_PORT_STAT_SUSPEND) {\n\t\tinfo->ports[port].resuming = true;\n\t\tinfo->ports[port].timeout = jiffies + msecs_to_jiffies(20);\n\t}\n}\n\n \nstatic void xenhcd_rhport_power_on(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tif ((info->ports[port].status & USB_PORT_STAT_POWER) == 0) {\n\t\tinfo->ports[port].status |= USB_PORT_STAT_POWER;\n\t\tif (info->devices[port].status != USB_STATE_NOTATTACHED)\n\t\t\tinfo->devices[port].status = USB_STATE_POWERED;\n\t\tif (info->ports[port].c_connection)\n\t\t\txenhcd_set_connect_state(info, portnum);\n\t}\n}\n\n \nstatic void xenhcd_rhport_power_off(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tif (info->ports[port].status & USB_PORT_STAT_POWER) {\n\t\tinfo->ports[port].status = 0;\n\t\tif (info->devices[port].status != USB_STATE_NOTATTACHED)\n\t\t\tinfo->devices[port].status = USB_STATE_ATTACHED;\n\t}\n}\n\n \nstatic void xenhcd_rhport_disable(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tinfo->ports[port].status &= ~USB_PORT_STAT_ENABLE;\n\tinfo->ports[port].status &= ~USB_PORT_STAT_SUSPEND;\n\tinfo->ports[port].resuming = false;\n\tif (info->devices[port].status != USB_STATE_NOTATTACHED)\n\t\tinfo->devices[port].status = USB_STATE_POWERED;\n}\n\n \nstatic void xenhcd_rhport_reset(struct xenhcd_info *info, int portnum)\n{\n\tint port;\n\n\tport = portnum - 1;\n\tinfo->ports[port].status &= ~(USB_PORT_STAT_ENABLE |\n\t\t\t\t      USB_PORT_STAT_LOW_SPEED |\n\t\t\t\t      USB_PORT_STAT_HIGH_SPEED);\n\tinfo->ports[port].status |= USB_PORT_STAT_RESET;\n\n\tif (info->devices[port].status != USB_STATE_NOTATTACHED)\n\t\tinfo->devices[port].status = USB_STATE_ATTACHED;\n\n\t \n\tinfo->ports[port].timeout = jiffies + msecs_to_jiffies(10);\n}\n\n#ifdef CONFIG_PM\nstatic int xenhcd_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tint ret = 0;\n\tint i, ports;\n\n\tports = info->rh_numports;\n\n\tspin_lock_irq(&info->lock);\n\tif (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {\n\t\tret = -ESHUTDOWN;\n\t} else {\n\t\t \n\t\tfor (i = 1; i <= ports; i++)\n\t\t\txenhcd_rhport_suspend(info, i);\n\t}\n\tspin_unlock_irq(&info->lock);\n\n\tdel_timer_sync(&info->watchdog);\n\n\treturn ret;\n}\n\nstatic int xenhcd_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tint ret = 0;\n\tint i, ports;\n\n\tports = info->rh_numports;\n\n\tspin_lock_irq(&info->lock);\n\tif (!test_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags)) {\n\t\tret = -ESHUTDOWN;\n\t} else {\n\t\t \n\t\tfor (i = 1; i <= ports; i++)\n\t\t\txenhcd_rhport_resume(info, i);\n\t}\n\tspin_unlock_irq(&info->lock);\n\n\treturn ret;\n}\n#endif\n\nstatic void xenhcd_hub_descriptor(struct xenhcd_info *info,\n\t\t\t\t  struct usb_hub_descriptor *desc)\n{\n\t__u16 temp;\n\tint ports = info->rh_numports;\n\n\tdesc->bDescriptorType = 0x29;\n\tdesc->bPwrOn2PwrGood = 10;  \n\tdesc->bHubContrCurrent = 0;\n\tdesc->bNbrPorts = ports;\n\n\t \n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\t \n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\n\tmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\n\n\t \n\ttemp = 0x000a;\n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n}\n\n \n#define PORT_C_MASK\t((USB_PORT_STAT_C_CONNECTION |\t\t\\\n\t\t\t  USB_PORT_STAT_C_ENABLE |\t\t\\\n\t\t\t  USB_PORT_STAT_C_SUSPEND |\t\t\\\n\t\t\t  USB_PORT_STAT_C_OVERCURRENT |\t\t\\\n\t\t\t  USB_PORT_STAT_C_RESET) << 16)\n\n \nstatic int xenhcd_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tint ports;\n\tint i;\n\tunsigned long flags;\n\tint ret;\n\tint changed = 0;\n\n\t \n\tports = info->rh_numports;\n\tret = 1 + (ports / 8);\n\tmemset(buf, 0, ret);\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\tfor (i = 0; i < ports; i++) {\n\t\t \n\t\tif (info->ports[i].status & PORT_C_MASK) {\n\t\t\tbuf[(i + 1) / 8] |= 1 << (i + 1) % 8;\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tif ((hcd->state == HC_STATE_SUSPENDED) && (changed == 1))\n\t\tusb_hcd_resume_root_hub(hcd);\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\treturn changed ? ret : 0;\n}\n\nstatic int xenhcd_hub_control(struct usb_hcd *hcd, __u16 typeReq, __u16 wValue,\n\t\t\t      __u16 wIndex, char *buf, __u16 wLength)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tint ports = info->rh_numports;\n\tunsigned long flags;\n\tint ret = 0;\n\tint i;\n\tint changed = 0;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\t \n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\txenhcd_rhport_resume(info, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\txenhcd_rhport_power_off(info, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\txenhcd_rhport_disable(info, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tinfo->ports[wIndex - 1].c_connection = false;\n\t\t\tfallthrough;\n\t\tdefault:\n\t\t\tinfo->ports[wIndex - 1].status &= ~(1 << wValue);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\txenhcd_hub_descriptor(info, (struct usb_hub_descriptor *)buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t \n\t\t*(__le32 *)buf = cpu_to_le32(0);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\n\t\twIndex--;\n\n\t\t \n\t\tif (info->ports[wIndex].resuming &&\n\t\t    time_after_eq(jiffies, info->ports[wIndex].timeout)) {\n\t\t\tinfo->ports[wIndex].status |=\n\t\t\t\tUSB_PORT_STAT_C_SUSPEND << 16;\n\t\t\tinfo->ports[wIndex].status &= ~USB_PORT_STAT_SUSPEND;\n\t\t}\n\n\t\t \n\t\tif ((info->ports[wIndex].status & USB_PORT_STAT_RESET) != 0 &&\n\t\t    time_after_eq(jiffies, info->ports[wIndex].timeout)) {\n\t\t\tinfo->ports[wIndex].status |=\n\t\t\t\tUSB_PORT_STAT_C_RESET << 16;\n\t\t\tinfo->ports[wIndex].status &= ~USB_PORT_STAT_RESET;\n\n\t\t\tif (info->devices[wIndex].status !=\n\t\t\t    USB_STATE_NOTATTACHED) {\n\t\t\t\tinfo->ports[wIndex].status |=\n\t\t\t\t\tUSB_PORT_STAT_ENABLE;\n\t\t\t\tinfo->devices[wIndex].status =\n\t\t\t\t\tUSB_STATE_DEFAULT;\n\t\t\t}\n\n\t\t\tswitch (info->devices[wIndex].speed) {\n\t\t\tcase XENUSB_SPEED_LOW:\n\t\t\t\tinfo->ports[wIndex].status |=\n\t\t\t\t\tUSB_PORT_STAT_LOW_SPEED;\n\t\t\t\tbreak;\n\t\t\tcase XENUSB_SPEED_HIGH:\n\t\t\t\tinfo->ports[wIndex].status |=\n\t\t\t\t\tUSB_PORT_STAT_HIGH_SPEED;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t*(__le32 *)buf = cpu_to_le32(info->ports[wIndex].status);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\txenhcd_rhport_power_on(info, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\txenhcd_rhport_reset(info, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\txenhcd_rhport_suspend(info, wIndex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (info->ports[wIndex-1].status & USB_PORT_STAT_POWER)\n\t\t\t\tinfo->ports[wIndex-1].status |= (1 << wValue);\n\t\t}\n\t\tbreak;\n\n\tcase SetHubFeature:\n\t\t \n\tdefault:\nerror:\n\t\tret = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\t \n\tfor (i = 0; i < ports; i++) {\n\t\tif (info->ports[i].status & PORT_C_MASK)\n\t\t\tchanged = 1;\n\t}\n\tif (changed)\n\t\tusb_hcd_poll_rh_status(hcd);\n\n\treturn ret;\n}\n\nstatic void xenhcd_free_urb_priv(struct urb_priv *urbp)\n{\n\turbp->urb->hcpriv = NULL;\n\tkmem_cache_free(xenhcd_urbp_cachep, urbp);\n}\n\nstatic inline unsigned int xenhcd_get_id_from_freelist(struct xenhcd_info *info)\n{\n\tunsigned int free;\n\n\tfree = info->shadow_free;\n\tinfo->shadow_free = info->shadow[free].req.id;\n\tinfo->shadow[free].req.id = 0x0fff;  \n\treturn free;\n}\n\nstatic inline void xenhcd_add_id_to_freelist(struct xenhcd_info *info,\n\t\t\t\t\t     unsigned int id)\n{\n\tinfo->shadow[id].req.id\t= info->shadow_free;\n\tinfo->shadow[id].urb = NULL;\n\tinfo->shadow_free = id;\n}\n\nstatic inline int xenhcd_count_pages(void *addr, int length)\n{\n\tunsigned long vaddr = (unsigned long)addr;\n\n\treturn PFN_UP(vaddr + length) - PFN_DOWN(vaddr);\n}\n\nstatic void xenhcd_gnttab_map(struct xenhcd_info *info, void *addr, int length,\n\t\t\t      grant_ref_t *gref_head,\n\t\t\t      struct xenusb_request_segment *seg,\n\t\t\t      int nr_pages, int flags)\n{\n\tgrant_ref_t ref;\n\tunsigned int offset;\n\tunsigned int len = length;\n\tunsigned int bytes;\n\tint i;\n\n\tfor (i = 0; i < nr_pages; i++) {\n\t\toffset = offset_in_page(addr);\n\n\t\tbytes = PAGE_SIZE - offset;\n\t\tif (bytes > len)\n\t\t\tbytes = len;\n\n\t\tref = gnttab_claim_grant_reference(gref_head);\n\t\tgnttab_grant_foreign_access_ref(ref, info->xbdev->otherend_id,\n\t\t\t\t\t\tvirt_to_gfn(addr), flags);\n\t\tseg[i].gref = ref;\n\t\tseg[i].offset = (__u16)offset;\n\t\tseg[i].length = (__u16)bytes;\n\n\t\taddr += bytes;\n\t\tlen -= bytes;\n\t}\n}\n\nstatic __u32 xenhcd_pipe_urb_to_xenusb(__u32 urb_pipe, __u8 port)\n{\n\tstatic __u32 pipe;\n\n\tpipe = usb_pipedevice(urb_pipe) << XENUSB_PIPE_DEV_SHIFT;\n\tpipe |= usb_pipeendpoint(urb_pipe) << XENUSB_PIPE_EP_SHIFT;\n\tif (usb_pipein(urb_pipe))\n\t\tpipe |= XENUSB_PIPE_DIR;\n\tswitch (usb_pipetype(urb_pipe)) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tpipe |= XENUSB_PIPE_TYPE_ISOC << XENUSB_PIPE_TYPE_SHIFT;\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tpipe |= XENUSB_PIPE_TYPE_INT << XENUSB_PIPE_TYPE_SHIFT;\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\tpipe |= XENUSB_PIPE_TYPE_CTRL << XENUSB_PIPE_TYPE_SHIFT;\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tpipe |= XENUSB_PIPE_TYPE_BULK << XENUSB_PIPE_TYPE_SHIFT;\n\t\tbreak;\n\t}\n\tpipe = xenusb_setportnum_pipe(pipe, port);\n\n\treturn pipe;\n}\n\nstatic int xenhcd_map_urb_for_request(struct xenhcd_info *info, struct urb *urb,\n\t\t\t\t      struct xenusb_urb_request *req)\n{\n\tgrant_ref_t gref_head;\n\tint nr_buff_pages = 0;\n\tint nr_isodesc_pages = 0;\n\tint nr_grants = 0;\n\n\tif (urb->transfer_buffer_length) {\n\t\tnr_buff_pages = xenhcd_count_pages(urb->transfer_buffer,\n\t\t\t\t\t\turb->transfer_buffer_length);\n\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tnr_isodesc_pages = xenhcd_count_pages(\n\t\t\t\t&urb->iso_frame_desc[0],\n\t\t\t\tsizeof(struct usb_iso_packet_descriptor) *\n\t\t\t\turb->number_of_packets);\n\n\t\tnr_grants = nr_buff_pages + nr_isodesc_pages;\n\t\tif (nr_grants > XENUSB_MAX_SEGMENTS_PER_REQUEST) {\n\t\t\tpr_err(\"xenhcd: error: %d grants\\n\", nr_grants);\n\t\t\treturn -E2BIG;\n\t\t}\n\n\t\tif (gnttab_alloc_grant_references(nr_grants, &gref_head)) {\n\t\t\tpr_err(\"xenhcd: gnttab_alloc_grant_references() error\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\txenhcd_gnttab_map(info, urb->transfer_buffer,\n\t\t\t\t  urb->transfer_buffer_length, &gref_head,\n\t\t\t\t  &req->seg[0], nr_buff_pages,\n\t\t\t\t  usb_pipein(urb->pipe) ? 0 : GTF_readonly);\n\t}\n\n\treq->pipe = xenhcd_pipe_urb_to_xenusb(urb->pipe, urb->dev->portnum);\n\treq->transfer_flags = 0;\n\tif (urb->transfer_flags & URB_SHORT_NOT_OK)\n\t\treq->transfer_flags |= XENUSB_SHORT_NOT_OK;\n\treq->buffer_length = urb->transfer_buffer_length;\n\treq->nr_buffer_segs = nr_buff_pages;\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_ISOCHRONOUS:\n\t\treq->u.isoc.interval = urb->interval;\n\t\treq->u.isoc.start_frame = urb->start_frame;\n\t\treq->u.isoc.number_of_packets = urb->number_of_packets;\n\t\treq->u.isoc.nr_frame_desc_segs = nr_isodesc_pages;\n\n\t\txenhcd_gnttab_map(info, &urb->iso_frame_desc[0],\n\t\t\t\t  sizeof(struct usb_iso_packet_descriptor) *\n\t\t\t\t  urb->number_of_packets,\n\t\t\t\t  &gref_head, &req->seg[nr_buff_pages],\n\t\t\t\t  nr_isodesc_pages, 0);\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\treq->u.intr.interval = urb->interval;\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\tif (urb->setup_packet)\n\t\t\tmemcpy(req->u.ctrl, urb->setup_packet, 8);\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (nr_grants)\n\t\tgnttab_free_grant_references(gref_head);\n\n\treturn 0;\n}\n\nstatic void xenhcd_gnttab_done(struct xenhcd_info *info, unsigned int id)\n{\n\tstruct usb_shadow *shadow = info->shadow + id;\n\tint nr_segs = 0;\n\tint i;\n\n\tif (!shadow->in_flight) {\n\t\txenhcd_set_error(info, \"Illegal request id\");\n\t\treturn;\n\t}\n\tshadow->in_flight = false;\n\n\tnr_segs = shadow->req.nr_buffer_segs;\n\n\tif (xenusb_pipeisoc(shadow->req.pipe))\n\t\tnr_segs += shadow->req.u.isoc.nr_frame_desc_segs;\n\n\tfor (i = 0; i < nr_segs; i++) {\n\t\tif (!gnttab_try_end_foreign_access(shadow->req.seg[i].gref))\n\t\t\txenhcd_set_error(info, \"backend didn't release grant\");\n\t}\n\n\tshadow->req.nr_buffer_segs = 0;\n\tshadow->req.u.isoc.nr_frame_desc_segs = 0;\n}\n\nstatic int xenhcd_translate_status(int status)\n{\n\tswitch (status) {\n\tcase XENUSB_STATUS_OK:\n\t\treturn 0;\n\tcase XENUSB_STATUS_NODEV:\n\t\treturn -ENODEV;\n\tcase XENUSB_STATUS_INVAL:\n\t\treturn -EINVAL;\n\tcase XENUSB_STATUS_STALL:\n\t\treturn -EPIPE;\n\tcase XENUSB_STATUS_IOERROR:\n\t\treturn -EPROTO;\n\tcase XENUSB_STATUS_BABBLE:\n\t\treturn -EOVERFLOW;\n\tdefault:\n\t\treturn -ESHUTDOWN;\n\t}\n}\n\nstatic void xenhcd_giveback_urb(struct xenhcd_info *info, struct urb *urb,\n\t\t\t\tint status)\n{\n\tstruct urb_priv *urbp = (struct urb_priv *)urb->hcpriv;\n\tint priv_status = urbp->status;\n\n\tlist_del_init(&urbp->list);\n\txenhcd_free_urb_priv(urbp);\n\n\tif (urb->status == -EINPROGRESS)\n\t\turb->status = xenhcd_translate_status(status);\n\n\tspin_unlock(&info->lock);\n\tusb_hcd_giveback_urb(xenhcd_info_to_hcd(info), urb,\n\t\t\t     priv_status <= 0 ? priv_status : urb->status);\n\tspin_lock(&info->lock);\n}\n\nstatic int xenhcd_do_request(struct xenhcd_info *info, struct urb_priv *urbp)\n{\n\tstruct xenusb_urb_request *req;\n\tstruct urb *urb = urbp->urb;\n\tunsigned int id;\n\tint notify;\n\tint ret;\n\n\tid = xenhcd_get_id_from_freelist(info);\n\treq = &info->shadow[id].req;\n\treq->id = id;\n\n\tif (unlikely(urbp->unlinked)) {\n\t\treq->u.unlink.unlink_id = urbp->req_id;\n\t\treq->pipe = xenusb_setunlink_pipe(xenhcd_pipe_urb_to_xenusb(\n\t\t\t\t\t\t urb->pipe, urb->dev->portnum));\n\t\turbp->unlink_req_id = id;\n\t} else {\n\t\tret = xenhcd_map_urb_for_request(info, urb, req);\n\t\tif (ret) {\n\t\t\txenhcd_add_id_to_freelist(info, id);\n\t\t\treturn ret;\n\t\t}\n\t\turbp->req_id = id;\n\t}\n\n\treq = RING_GET_REQUEST(&info->urb_ring, info->urb_ring.req_prod_pvt);\n\t*req = info->shadow[id].req;\n\n\tinfo->urb_ring.req_prod_pvt++;\n\tinfo->shadow[id].urb = urb;\n\tinfo->shadow[id].in_flight = true;\n\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->urb_ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(info->irq);\n\n\treturn 0;\n}\n\nstatic void xenhcd_kick_pending_urbs(struct xenhcd_info *info)\n{\n\tstruct urb_priv *urbp;\n\n\twhile (!list_empty(&info->pending_submit_list)) {\n\t\tif (RING_FULL(&info->urb_ring)) {\n\t\t\txenhcd_timer_action(info, TIMER_RING_WATCHDOG);\n\t\t\treturn;\n\t\t}\n\n\t\turbp = list_entry(info->pending_submit_list.next,\n\t\t\t\t  struct urb_priv, list);\n\t\tif (!xenhcd_do_request(info, urbp))\n\t\t\tlist_move_tail(&urbp->list, &info->in_progress_list);\n\t\telse\n\t\t\txenhcd_giveback_urb(info, urbp->urb, -ESHUTDOWN);\n\t}\n\txenhcd_timer_action_done(info, TIMER_SCAN_PENDING_URBS);\n}\n\n \nstatic void xenhcd_cancel_all_enqueued_urbs(struct xenhcd_info *info)\n{\n\tstruct urb_priv *urbp, *tmp;\n\tint req_id;\n\n\tlist_for_each_entry_safe(urbp, tmp, &info->in_progress_list, list) {\n\t\treq_id = urbp->req_id;\n\t\tif (!urbp->unlinked) {\n\t\t\txenhcd_gnttab_done(info, req_id);\n\t\t\tif (info->error)\n\t\t\t\treturn;\n\t\t\tif (urbp->urb->status == -EINPROGRESS)\n\t\t\t\t \n\t\t\t\txenhcd_giveback_urb(info, urbp->urb,\n\t\t\t\t\t\t    -ESHUTDOWN);\n\t\t\telse\t \n\t\t\t\txenhcd_giveback_urb(info, urbp->urb,\n\t\t\t\t\t\t    urbp->urb->status);\n\t\t}\n\t\tinfo->shadow[req_id].urb = NULL;\n\t}\n\n\tlist_for_each_entry_safe(urbp, tmp, &info->pending_submit_list, list)\n\t\txenhcd_giveback_urb(info, urbp->urb, -ESHUTDOWN);\n}\n\n \nstatic void xenhcd_giveback_unlinked_urbs(struct xenhcd_info *info)\n{\n\tstruct urb_priv *urbp, *tmp;\n\n\tlist_for_each_entry_safe(urbp, tmp, &info->giveback_waiting_list, list)\n\t\txenhcd_giveback_urb(info, urbp->urb, urbp->urb->status);\n}\n\nstatic int xenhcd_submit_urb(struct xenhcd_info *info, struct urb_priv *urbp)\n{\n\tint ret;\n\n\tif (RING_FULL(&info->urb_ring)) {\n\t\tlist_add_tail(&urbp->list, &info->pending_submit_list);\n\t\txenhcd_timer_action(info, TIMER_RING_WATCHDOG);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&info->pending_submit_list)) {\n\t\tlist_add_tail(&urbp->list, &info->pending_submit_list);\n\t\txenhcd_timer_action(info, TIMER_SCAN_PENDING_URBS);\n\t\treturn 0;\n\t}\n\n\tret = xenhcd_do_request(info, urbp);\n\tif (ret == 0)\n\t\tlist_add_tail(&urbp->list, &info->in_progress_list);\n\n\treturn ret;\n}\n\nstatic int xenhcd_unlink_urb(struct xenhcd_info *info, struct urb_priv *urbp)\n{\n\tint ret;\n\n\t \n\tif (urbp->unlinked)\n\t\treturn -EBUSY;\n\n\turbp->unlinked = true;\n\n\t \n\tif (urbp->req_id == ~0) {\n\t\tlist_move_tail(&urbp->list, &info->giveback_waiting_list);\n\t\txenhcd_timer_action(info, TIMER_SCAN_PENDING_URBS);\n\t\treturn 0;\n\t}\n\n\t \n\tif (RING_FULL(&info->urb_ring)) {\n\t\tlist_move_tail(&urbp->list, &info->pending_unlink_list);\n\t\txenhcd_timer_action(info, TIMER_RING_WATCHDOG);\n\t\treturn 0;\n\t}\n\n\tif (!list_empty(&info->pending_unlink_list)) {\n\t\tlist_move_tail(&urbp->list, &info->pending_unlink_list);\n\t\txenhcd_timer_action(info, TIMER_SCAN_PENDING_URBS);\n\t\treturn 0;\n\t}\n\n\tret = xenhcd_do_request(info, urbp);\n\tif (ret == 0)\n\t\tlist_move_tail(&urbp->list, &info->in_progress_list);\n\n\treturn ret;\n}\n\nstatic void xenhcd_res_to_urb(struct xenhcd_info *info,\n\t\t\t      struct xenusb_urb_response *res, struct urb *urb)\n{\n\tif (unlikely(!urb))\n\t\treturn;\n\n\tif (res->actual_length > urb->transfer_buffer_length)\n\t\turb->actual_length = urb->transfer_buffer_length;\n\telse if (res->actual_length < 0)\n\t\turb->actual_length = 0;\n\telse\n\t\turb->actual_length = res->actual_length;\n\turb->error_count = res->error_count;\n\turb->start_frame = res->start_frame;\n\txenhcd_giveback_urb(info, urb, res->status);\n}\n\nstatic int xenhcd_urb_request_done(struct xenhcd_info *info,\n\t\t\t\t   unsigned int *eoiflag)\n{\n\tstruct xenusb_urb_response res;\n\tRING_IDX i, rp;\n\t__u16 id;\n\tint more_to_do = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\trp = info->urb_ring.sring->rsp_prod;\n\tif (RING_RESPONSE_PROD_OVERFLOW(&info->urb_ring, rp)) {\n\t\txenhcd_set_error(info, \"Illegal index on urb-ring\");\n\t\tgoto err;\n\t}\n\trmb();  \n\n\tfor (i = info->urb_ring.rsp_cons; i != rp; i++) {\n\t\tRING_COPY_RESPONSE(&info->urb_ring, i, &res);\n\t\tid = res.id;\n\t\tif (id >= XENUSB_URB_RING_SIZE) {\n\t\t\txenhcd_set_error(info, \"Illegal data on urb-ring\");\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (likely(xenusb_pipesubmit(info->shadow[id].req.pipe))) {\n\t\t\txenhcd_gnttab_done(info, id);\n\t\t\tif (info->error)\n\t\t\t\tgoto err;\n\t\t\txenhcd_res_to_urb(info, &res, info->shadow[id].urb);\n\t\t}\n\n\t\txenhcd_add_id_to_freelist(info, id);\n\n\t\t*eoiflag = 0;\n\t}\n\tinfo->urb_ring.rsp_cons = i;\n\n\tif (i != info->urb_ring.req_prod_pvt)\n\t\tRING_FINAL_CHECK_FOR_RESPONSES(&info->urb_ring, more_to_do);\n\telse\n\t\tinfo->urb_ring.sring->rsp_event = i + 1;\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\treturn more_to_do;\n\n err:\n\tspin_unlock_irqrestore(&info->lock, flags);\n\treturn 0;\n}\n\nstatic int xenhcd_conn_notify(struct xenhcd_info *info, unsigned int *eoiflag)\n{\n\tstruct xenusb_conn_response res;\n\tstruct xenusb_conn_request *req;\n\tRING_IDX rc, rp;\n\t__u16 id;\n\t__u8 portnum, speed;\n\tint more_to_do = 0;\n\tint notify;\n\tint port_changed = 0;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\trc = info->conn_ring.rsp_cons;\n\trp = info->conn_ring.sring->rsp_prod;\n\tif (RING_RESPONSE_PROD_OVERFLOW(&info->conn_ring, rp)) {\n\t\txenhcd_set_error(info, \"Illegal index on conn-ring\");\n\t\tspin_unlock_irqrestore(&info->lock, flags);\n\t\treturn 0;\n\t}\n\trmb();  \n\n\twhile (rc != rp) {\n\t\tRING_COPY_RESPONSE(&info->conn_ring, rc, &res);\n\t\tid = res.id;\n\t\tportnum = res.portnum;\n\t\tspeed = res.speed;\n\t\tinfo->conn_ring.rsp_cons = ++rc;\n\n\t\tif (xenhcd_rhport_connect(info, portnum, speed)) {\n\t\t\txenhcd_set_error(info, \"Illegal data on conn-ring\");\n\t\t\tspin_unlock_irqrestore(&info->lock, flags);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (info->ports[portnum - 1].c_connection)\n\t\t\tport_changed = 1;\n\n\t\tbarrier();\n\n\t\treq = RING_GET_REQUEST(&info->conn_ring,\n\t\t\t\t       info->conn_ring.req_prod_pvt);\n\t\treq->id = id;\n\t\tinfo->conn_ring.req_prod_pvt++;\n\n\t\t*eoiflag = 0;\n\t}\n\n\tif (rc != info->conn_ring.req_prod_pvt)\n\t\tRING_FINAL_CHECK_FOR_RESPONSES(&info->conn_ring, more_to_do);\n\telse\n\t\tinfo->conn_ring.sring->rsp_event = rc + 1;\n\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->conn_ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(info->irq);\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\tif (port_changed)\n\t\tusb_hcd_poll_rh_status(xenhcd_info_to_hcd(info));\n\n\treturn more_to_do;\n}\n\nstatic irqreturn_t xenhcd_int(int irq, void *dev_id)\n{\n\tstruct xenhcd_info *info = (struct xenhcd_info *)dev_id;\n\tunsigned int eoiflag = XEN_EOI_FLAG_SPURIOUS;\n\n\tif (unlikely(info->error)) {\n\t\txen_irq_lateeoi(irq, XEN_EOI_FLAG_SPURIOUS);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\twhile (xenhcd_urb_request_done(info, &eoiflag) |\n\t       xenhcd_conn_notify(info, &eoiflag))\n\t\t \n\t\tcond_resched();\n\n\txen_irq_lateeoi(irq, eoiflag);\n\treturn IRQ_HANDLED;\n}\n\nstatic void xenhcd_destroy_rings(struct xenhcd_info *info)\n{\n\tif (info->irq)\n\t\tunbind_from_irqhandler(info->irq, info);\n\tinfo->irq = 0;\n\n\txenbus_teardown_ring((void **)&info->urb_ring.sring, 1,\n\t\t\t     &info->urb_ring_ref);\n\txenbus_teardown_ring((void **)&info->conn_ring.sring, 1,\n\t\t\t     &info->conn_ring_ref);\n}\n\nstatic int xenhcd_setup_rings(struct xenbus_device *dev,\n\t\t\t      struct xenhcd_info *info)\n{\n\tstruct xenusb_urb_sring *urb_sring;\n\tstruct xenusb_conn_sring *conn_sring;\n\tint err;\n\n\tinfo->conn_ring_ref = INVALID_GRANT_REF;\n\terr = xenbus_setup_ring(dev, GFP_NOIO | __GFP_HIGH,\n\t\t\t\t(void **)&urb_sring, 1, &info->urb_ring_ref);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"allocating urb ring\");\n\t\treturn err;\n\t}\n\tXEN_FRONT_RING_INIT(&info->urb_ring, urb_sring, PAGE_SIZE);\n\n\terr = xenbus_setup_ring(dev, GFP_NOIO | __GFP_HIGH,\n\t\t\t\t(void **)&conn_sring, 1, &info->conn_ring_ref);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"allocating conn ring\");\n\t\tgoto fail;\n\t}\n\tXEN_FRONT_RING_INIT(&info->conn_ring, conn_sring, PAGE_SIZE);\n\n\terr = xenbus_alloc_evtchn(dev, &info->evtchn);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"xenbus_alloc_evtchn\");\n\t\tgoto fail;\n\t}\n\n\terr = bind_evtchn_to_irq_lateeoi(info->evtchn);\n\tif (err <= 0) {\n\t\txenbus_dev_fatal(dev, err, \"bind_evtchn_to_irq_lateeoi\");\n\t\tgoto fail;\n\t}\n\n\tinfo->irq = err;\n\n\terr = request_threaded_irq(info->irq, NULL, xenhcd_int,\n\t\t\t\t   IRQF_ONESHOT, \"xenhcd\", info);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"request_threaded_irq\");\n\t\tgoto free_irq;\n\t}\n\n\treturn 0;\n\nfree_irq:\n\tunbind_from_irqhandler(info->irq, info);\nfail:\n\txenhcd_destroy_rings(info);\n\treturn err;\n}\n\nstatic int xenhcd_talk_to_backend(struct xenbus_device *dev,\n\t\t\t\t  struct xenhcd_info *info)\n{\n\tconst char *message;\n\tstruct xenbus_transaction xbt;\n\tint err;\n\n\terr = xenhcd_setup_rings(dev, info);\n\tif (err)\n\t\treturn err;\n\nagain:\n\terr = xenbus_transaction_start(&xbt);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"starting transaction\");\n\t\tgoto destroy_ring;\n\t}\n\n\terr = xenbus_printf(xbt, dev->nodename, \"urb-ring-ref\", \"%u\",\n\t\t\t    info->urb_ring_ref);\n\tif (err) {\n\t\tmessage = \"writing urb-ring-ref\";\n\t\tgoto abort_transaction;\n\t}\n\n\terr = xenbus_printf(xbt, dev->nodename, \"conn-ring-ref\", \"%u\",\n\t\t\t    info->conn_ring_ref);\n\tif (err) {\n\t\tmessage = \"writing conn-ring-ref\";\n\t\tgoto abort_transaction;\n\t}\n\n\terr = xenbus_printf(xbt, dev->nodename, \"event-channel\", \"%u\",\n\t\t\t    info->evtchn);\n\tif (err) {\n\t\tmessage = \"writing event-channel\";\n\t\tgoto abort_transaction;\n\t}\n\n\terr = xenbus_transaction_end(xbt, 0);\n\tif (err) {\n\t\tif (err == -EAGAIN)\n\t\t\tgoto again;\n\t\txenbus_dev_fatal(dev, err, \"completing transaction\");\n\t\tgoto destroy_ring;\n\t}\n\n\treturn 0;\n\nabort_transaction:\n\txenbus_transaction_end(xbt, 1);\n\txenbus_dev_fatal(dev, err, \"%s\", message);\n\ndestroy_ring:\n\txenhcd_destroy_rings(info);\n\n\treturn err;\n}\n\nstatic int xenhcd_connect(struct xenbus_device *dev)\n{\n\tstruct xenhcd_info *info = dev_get_drvdata(&dev->dev);\n\tstruct xenusb_conn_request *req;\n\tint idx, err;\n\tint notify;\n\tchar name[TASK_COMM_LEN];\n\tstruct usb_hcd *hcd;\n\n\thcd = xenhcd_info_to_hcd(info);\n\tsnprintf(name, TASK_COMM_LEN, \"xenhcd.%d\", hcd->self.busnum);\n\n\terr = xenhcd_talk_to_backend(dev, info);\n\tif (err)\n\t\treturn err;\n\n\t \n\tfor (idx = 0; idx < XENUSB_CONN_RING_SIZE; idx++) {\n\t\treq = RING_GET_REQUEST(&info->conn_ring, idx);\n\t\treq->id = idx;\n\t}\n\tinfo->conn_ring.req_prod_pvt = idx;\n\n\tRING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->conn_ring, notify);\n\tif (notify)\n\t\tnotify_remote_via_irq(info->irq);\n\n\treturn 0;\n}\n\nstatic void xenhcd_disconnect(struct xenbus_device *dev)\n{\n\tstruct xenhcd_info *info = dev_get_drvdata(&dev->dev);\n\tstruct usb_hcd *hcd = xenhcd_info_to_hcd(info);\n\n\tusb_remove_hcd(hcd);\n\txenbus_frontend_closed(dev);\n}\n\nstatic void xenhcd_watchdog(struct timer_list *timer)\n{\n\tstruct xenhcd_info *info = from_timer(info, timer, watchdog);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\tif (likely(HC_IS_RUNNING(xenhcd_info_to_hcd(info)->state))) {\n\t\txenhcd_timer_action_done(info, TIMER_RING_WATCHDOG);\n\t\txenhcd_giveback_unlinked_urbs(info);\n\t\txenhcd_kick_pending_urbs(info);\n\t}\n\tspin_unlock_irqrestore(&info->lock, flags);\n}\n\n \nstatic int xenhcd_setup(struct usb_hcd *hcd)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\n\tspin_lock_init(&info->lock);\n\tINIT_LIST_HEAD(&info->pending_submit_list);\n\tINIT_LIST_HEAD(&info->pending_unlink_list);\n\tINIT_LIST_HEAD(&info->in_progress_list);\n\tINIT_LIST_HEAD(&info->giveback_waiting_list);\n\ttimer_setup(&info->watchdog, xenhcd_watchdog, 0);\n\n\thcd->has_tt = (hcd->driver->flags & HCD_MASK) != HCD_USB11;\n\n\treturn 0;\n}\n\n \nstatic int xenhcd_run(struct usb_hcd *hcd)\n{\n\thcd->uses_new_polling = 1;\n\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\thcd->state = HC_STATE_RUNNING;\n\treturn 0;\n}\n\n \nstatic void xenhcd_stop(struct usb_hcd *hcd)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\n\tdel_timer_sync(&info->watchdog);\n\tspin_lock_irq(&info->lock);\n\t \n\thcd->state = HC_STATE_HALT;\n\txenhcd_cancel_all_enqueued_urbs(info);\n\txenhcd_giveback_unlinked_urbs(info);\n\tspin_unlock_irq(&info->lock);\n}\n\n \nstatic int xenhcd_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t      gfp_t mem_flags)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tstruct urb_priv *urbp;\n\tunsigned long flags;\n\tint ret;\n\n\tif (unlikely(info->error))\n\t\treturn -ESHUTDOWN;\n\n\turbp = kmem_cache_zalloc(xenhcd_urbp_cachep, mem_flags);\n\tif (!urbp)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\turbp->urb = urb;\n\turb->hcpriv = urbp;\n\turbp->req_id = ~0;\n\turbp->unlink_req_id = ~0;\n\tINIT_LIST_HEAD(&urbp->list);\n\turbp->status = 1;\n\turb->unlinked = false;\n\n\tret = xenhcd_submit_urb(info, urbp);\n\n\tif (ret)\n\t\txenhcd_free_urb_priv(urbp);\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int xenhcd_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct xenhcd_info *info = xenhcd_hcd_to_info(hcd);\n\tstruct urb_priv *urbp;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&info->lock, flags);\n\n\turbp = urb->hcpriv;\n\tif (urbp) {\n\t\turbp->status = status;\n\t\tret = xenhcd_unlink_urb(info, urbp);\n\t}\n\n\tspin_unlock_irqrestore(&info->lock, flags);\n\n\treturn ret;\n}\n\n \nstatic int xenhcd_get_frame(struct usb_hcd *hcd)\n{\n\t \n\treturn 0;\n}\n\nstatic struct hc_driver xenhcd_usb20_hc_driver = {\n\t.description = \"xen-hcd\",\n\t.product_desc = \"Xen USB2.0 Virtual Host Controller\",\n\t.hcd_priv_size = sizeof(struct xenhcd_info),\n\t.flags = HCD_USB2,\n\n\t \n\t.reset = xenhcd_setup,\n\t.start = xenhcd_run,\n\t.stop = xenhcd_stop,\n\n\t \n\t.urb_enqueue = xenhcd_urb_enqueue,\n\t.urb_dequeue = xenhcd_urb_dequeue,\n\t.get_frame_number = xenhcd_get_frame,\n\n\t \n\t.hub_status_data = xenhcd_hub_status_data,\n\t.hub_control = xenhcd_hub_control,\n#ifdef CONFIG_PM\n\t.bus_suspend = xenhcd_bus_suspend,\n\t.bus_resume = xenhcd_bus_resume,\n#endif\n};\n\nstatic struct hc_driver xenhcd_usb11_hc_driver = {\n\t.description = \"xen-hcd\",\n\t.product_desc = \"Xen USB1.1 Virtual Host Controller\",\n\t.hcd_priv_size = sizeof(struct xenhcd_info),\n\t.flags = HCD_USB11,\n\n\t \n\t.reset = xenhcd_setup,\n\t.start = xenhcd_run,\n\t.stop = xenhcd_stop,\n\n\t \n\t.urb_enqueue = xenhcd_urb_enqueue,\n\t.urb_dequeue = xenhcd_urb_dequeue,\n\t.get_frame_number = xenhcd_get_frame,\n\n\t \n\t.hub_status_data = xenhcd_hub_status_data,\n\t.hub_control = xenhcd_hub_control,\n#ifdef CONFIG_PM\n\t.bus_suspend = xenhcd_bus_suspend,\n\t.bus_resume = xenhcd_bus_resume,\n#endif\n};\n\nstatic struct usb_hcd *xenhcd_create_hcd(struct xenbus_device *dev)\n{\n\tint i;\n\tint err = 0;\n\tint num_ports;\n\tint usb_ver;\n\tstruct usb_hcd *hcd = NULL;\n\tstruct xenhcd_info *info;\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend, \"num-ports\", \"%d\",\n\t\t\t   &num_ports);\n\tif (err != 1) {\n\t\txenbus_dev_fatal(dev, err, \"reading num-ports\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (num_ports < 1 || num_ports > XENUSB_MAX_PORTNR) {\n\t\txenbus_dev_fatal(dev, err, \"invalid num-ports\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\terr = xenbus_scanf(XBT_NIL, dev->otherend, \"usb-ver\", \"%d\", &usb_ver);\n\tif (err != 1) {\n\t\txenbus_dev_fatal(dev, err, \"reading usb-ver\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tswitch (usb_ver) {\n\tcase XENUSB_VER_USB11:\n\t\thcd = usb_create_hcd(&xenhcd_usb11_hc_driver, &dev->dev,\n\t\t\t\t     dev_name(&dev->dev));\n\t\tbreak;\n\tcase XENUSB_VER_USB20:\n\t\thcd = usb_create_hcd(&xenhcd_usb20_hc_driver, &dev->dev,\n\t\t\t\t     dev_name(&dev->dev));\n\t\tbreak;\n\tdefault:\n\t\txenbus_dev_fatal(dev, err, \"invalid usb-ver\");\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\tif (!hcd) {\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"fail to allocate USB host controller\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tinfo = xenhcd_hcd_to_info(hcd);\n\tinfo->xbdev = dev;\n\tinfo->rh_numports = num_ports;\n\n\tfor (i = 0; i < XENUSB_URB_RING_SIZE; i++) {\n\t\tinfo->shadow[i].req.id = i + 1;\n\t\tinfo->shadow[i].urb = NULL;\n\t\tinfo->shadow[i].in_flight = false;\n\t}\n\tinfo->shadow[XENUSB_URB_RING_SIZE - 1].req.id = 0x0fff;\n\n\treturn hcd;\n}\n\nstatic void xenhcd_backend_changed(struct xenbus_device *dev,\n\t\t\t\t   enum xenbus_state backend_state)\n{\n\tswitch (backend_state) {\n\tcase XenbusStateInitialising:\n\tcase XenbusStateReconfiguring:\n\tcase XenbusStateReconfigured:\n\tcase XenbusStateUnknown:\n\t\tbreak;\n\n\tcase XenbusStateInitWait:\n\tcase XenbusStateInitialised:\n\tcase XenbusStateConnected:\n\t\tif (dev->state != XenbusStateInitialising)\n\t\t\tbreak;\n\t\tif (!xenhcd_connect(dev))\n\t\t\txenbus_switch_state(dev, XenbusStateConnected);\n\t\tbreak;\n\n\tcase XenbusStateClosed:\n\t\tif (dev->state == XenbusStateClosed)\n\t\t\tbreak;\n\t\tfallthrough;\t \n\tcase XenbusStateClosing:\n\t\txenhcd_disconnect(dev);\n\t\tbreak;\n\n\tdefault:\n\t\txenbus_dev_fatal(dev, -EINVAL, \"saw state %d at frontend\",\n\t\t\t\t backend_state);\n\t\tbreak;\n\t}\n}\n\nstatic void xenhcd_remove(struct xenbus_device *dev)\n{\n\tstruct xenhcd_info *info = dev_get_drvdata(&dev->dev);\n\tstruct usb_hcd *hcd = xenhcd_info_to_hcd(info);\n\n\txenhcd_destroy_rings(info);\n\tusb_put_hcd(hcd);\n}\n\nstatic int xenhcd_probe(struct xenbus_device *dev,\n\t\t\tconst struct xenbus_device_id *id)\n{\n\tint err;\n\tstruct usb_hcd *hcd;\n\tstruct xenhcd_info *info;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\thcd = xenhcd_create_hcd(dev);\n\tif (IS_ERR(hcd)) {\n\t\terr = PTR_ERR(hcd);\n\t\txenbus_dev_fatal(dev, err,\n\t\t\t\t \"fail to create usb host controller\");\n\t\treturn err;\n\t}\n\n\tinfo = xenhcd_hcd_to_info(hcd);\n\tdev_set_drvdata(&dev->dev, info);\n\n\terr = usb_add_hcd(hcd, 0, 0);\n\tif (err) {\n\t\txenbus_dev_fatal(dev, err, \"fail to add USB host controller\");\n\t\tusb_put_hcd(hcd);\n\t\tdev_set_drvdata(&dev->dev, NULL);\n\t}\n\n\treturn err;\n}\n\nstatic const struct xenbus_device_id xenhcd_ids[] = {\n\t{ \"vusb\" },\n\t{ \"\" },\n};\n\nstatic struct xenbus_driver xenhcd_driver = {\n\t.ids\t\t\t= xenhcd_ids,\n\t.probe\t\t\t= xenhcd_probe,\n\t.otherend_changed\t= xenhcd_backend_changed,\n\t.remove\t\t\t= xenhcd_remove,\n};\n\nstatic int __init xenhcd_init(void)\n{\n\tif (!xen_domain())\n\t\treturn -ENODEV;\n\n\txenhcd_urbp_cachep = kmem_cache_create(\"xenhcd_urb_priv\",\n\t\t\t\t\tsizeof(struct urb_priv), 0, 0, NULL);\n\tif (!xenhcd_urbp_cachep) {\n\t\tpr_err(\"xenhcd failed to create kmem cache\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn xenbus_register_frontend(&xenhcd_driver);\n}\nmodule_init(xenhcd_init);\n\nstatic void __exit xenhcd_exit(void)\n{\n\tkmem_cache_destroy(xenhcd_urbp_cachep);\n\txenbus_unregister_driver(&xenhcd_driver);\n}\nmodule_exit(xenhcd_exit);\n\nMODULE_ALIAS(\"xen:vusb\");\nMODULE_AUTHOR(\"Juergen Gross <jgross@suse.com>\");\nMODULE_DESCRIPTION(\"Xen USB Virtual Host Controller driver (xen-hcd)\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}