{
  "module_name": "ehci-xilinx-of.c",
  "hash_id": "9fccdc9d6d8680b30e50d2d11592a5d18bf0ad3b3a8e7be24acb2e5dda56f8f2",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-xilinx-of.c",
  "human_readable_source": "\n \n\n#include <linux/err.h>\n#include <linux/signal.h>\n\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n\n \nstatic int ehci_xilinx_port_handed_over(struct usb_hcd *hcd, int portnum)\n{\n\tdev_warn(hcd->self.controller, \"port %d cannot be enabled\\n\", portnum);\n\tif (hcd->has_tt) {\n\t\tdev_warn(hcd->self.controller,\n\t\t\t\"Maybe you have connected a low speed device?\\n\");\n\n\t\tdev_warn(hcd->self.controller,\n\t\t\t\"We do not support low speed devices\\n\");\n\t} else {\n\t\tdev_warn(hcd->self.controller,\n\t\t\t\"Maybe your device is not a high speed device?\\n\");\n\t\tdev_warn(hcd->self.controller,\n\t\t\t\"The USB host controller does not support full speed nor low speed devices\\n\");\n\t\tdev_warn(hcd->self.controller,\n\t\t\t\"You can reconfigure the host controller to have full speed support\\n\");\n\t}\n\n\treturn 0;\n}\n\n\nstatic const struct hc_driver ehci_xilinx_of_hc_driver = {\n\t.description\t\t= hcd_name,\n\t.product_desc\t\t= \"OF EHCI\",\n\t.hcd_priv_size\t\t= sizeof(struct ehci_hcd),\n\n\t \n\t.irq\t\t\t= ehci_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_DMA | HCD_USB2 | HCD_BH,\n\n\t \n\t.reset\t\t\t= ehci_setup,\n\t.start\t\t\t= ehci_run,\n\t.stop\t\t\t= ehci_stop,\n\t.shutdown\t\t= ehci_shutdown,\n\n\t \n\t.urb_enqueue\t\t= ehci_urb_enqueue,\n\t.urb_dequeue\t\t= ehci_urb_dequeue,\n\t.endpoint_disable\t= ehci_endpoint_disable,\n\t.endpoint_reset\t\t= ehci_endpoint_reset,\n\n\t \n\t.get_frame_number\t= ehci_get_frame,\n\n\t \n\t.hub_status_data\t= ehci_hub_status_data,\n\t.hub_control\t\t= ehci_hub_control,\n#ifdef\tCONFIG_PM\n\t.bus_suspend\t\t= ehci_bus_suspend,\n\t.bus_resume\t\t= ehci_bus_resume,\n#endif\n\t.relinquish_port\t= NULL,\n\t.port_handed_over\t= ehci_xilinx_port_handed_over,\n\n\t.clear_tt_buffer_complete = ehci_clear_tt_buffer_complete,\n};\n\n \nstatic int ehci_hcd_xilinx_of_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd\t*ehci;\n\tstruct resource res;\n\tint irq;\n\tint rv;\n\tint *value;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdev_dbg(&op->dev, \"initializing XILINX-OF USB Controller\\n\");\n\n\trv = of_address_to_resource(dn, 0, &res);\n\tif (rv)\n\t\treturn rv;\n\n\thcd = usb_create_hcd(&ehci_xilinx_of_hc_driver, &op->dev,\n\t\t\t\t\"XILINX-OF USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = res.start;\n\thcd->rsrc_len = resource_size(&res);\n\n\tirq = irq_of_parse_and_map(dn, 0);\n\tif (!irq) {\n\t\tdev_err(&op->dev, \"%s: irq_of_parse_and_map failed\\n\",\n\t\t\t__FILE__);\n\t\trv = -EBUSY;\n\t\tgoto err_irq;\n\t}\n\n\thcd->regs = devm_ioremap_resource(&op->dev, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\trv = PTR_ERR(hcd->regs);\n\t\tgoto err_irq;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\n\t \n\tehci->big_endian_mmio = 1;\n\tehci->big_endian_desc = 1;\n\n\t \n\tvalue = (int *)of_get_property(dn, \"xlnx,support-usb-fs\", NULL);\n\tif (value && (*value == 1)) {\n\t\tehci_dbg(ehci, \"USB host controller supports FS devices\\n\");\n\t\thcd->has_tt = 1;\n\t} else {\n\t\tehci_dbg(ehci,\n\t\t\t\"USB host controller is HS only\\n\");\n\t\thcd->has_tt = 0;\n\t}\n\n\t \n\tehci->caps = hcd->regs + 0x100;\n\n\trv = usb_add_hcd(hcd, irq, 0);\n\tif (rv == 0) {\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t\treturn 0;\n\t}\n\nerr_irq:\n\tusb_put_hcd(hcd);\n\n\treturn rv;\n}\n\n \nstatic void ehci_hcd_xilinx_of_remove(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\n\tdev_dbg(&op->dev, \"stopping XILINX-OF USB Controller\\n\");\n\n\tusb_remove_hcd(hcd);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct of_device_id ehci_hcd_xilinx_of_match[] = {\n\t\t{.compatible = \"xlnx,xps-usb-host-1.00.a\",},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ehci_hcd_xilinx_of_match);\n\nstatic struct platform_driver ehci_hcd_xilinx_of_driver = {\n\t.probe\t\t= ehci_hcd_xilinx_of_probe,\n\t.remove_new\t= ehci_hcd_xilinx_of_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name = \"xilinx-of-ehci\",\n\t\t.of_match_table = ehci_hcd_xilinx_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}