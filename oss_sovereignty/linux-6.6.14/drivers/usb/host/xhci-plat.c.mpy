{
  "module_name": "xhci-plat.c",
  "hash_id": "1945cf113d7c07036a0898c315a1a5d5b85cadb1bacc30d165f88e997f55a393",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-plat.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/platform_device.h>\n#include <linux/usb/phy.h>\n#include <linux/slab.h>\n#include <linux/acpi.h>\n#include <linux/usb/of.h>\n#include <linux/reset.h>\n\n#include \"xhci.h\"\n#include \"xhci-plat.h\"\n#include \"xhci-mvebu.h\"\n\nstatic struct hc_driver __read_mostly xhci_plat_hc_driver;\n\nstatic int xhci_plat_setup(struct usb_hcd *hcd);\nstatic int xhci_plat_start(struct usb_hcd *hcd);\n\nstatic const struct xhci_driver_overrides xhci_plat_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct xhci_plat_priv),\n\t.reset = xhci_plat_setup,\n\t.start = xhci_plat_start,\n};\n\nstatic void xhci_priv_plat_start(struct usb_hcd *hcd)\n{\n\tstruct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);\n\n\tif (priv->plat_start)\n\t\tpriv->plat_start(hcd);\n}\n\nstatic int xhci_priv_init_quirk(struct usb_hcd *hcd)\n{\n\tstruct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);\n\n\tif (!priv->init_quirk)\n\t\treturn 0;\n\n\treturn priv->init_quirk(hcd);\n}\n\nstatic int xhci_priv_suspend_quirk(struct usb_hcd *hcd)\n{\n\tstruct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);\n\n\tif (!priv->suspend_quirk)\n\t\treturn 0;\n\n\treturn priv->suspend_quirk(hcd);\n}\n\nstatic int xhci_priv_resume_quirk(struct usb_hcd *hcd)\n{\n\tstruct xhci_plat_priv *priv = hcd_to_xhci_priv(hcd);\n\n\tif (!priv->resume_quirk)\n\t\treturn 0;\n\n\treturn priv->resume_quirk(hcd);\n}\n\nstatic void xhci_plat_quirks(struct device *dev, struct xhci_hcd *xhci)\n{\n\tstruct xhci_plat_priv *priv = xhci_to_priv(xhci);\n\n\txhci->quirks |= priv->quirks;\n}\n\n \nstatic int xhci_plat_setup(struct usb_hcd *hcd)\n{\n\tint ret;\n\n\n\tret = xhci_priv_init_quirk(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn xhci_gen_setup(hcd, xhci_plat_quirks);\n}\n\nstatic int xhci_plat_start(struct usb_hcd *hcd)\n{\n\txhci_priv_plat_start(hcd);\n\treturn xhci_run(hcd);\n}\n\n#ifdef CONFIG_OF\nstatic const struct xhci_plat_priv xhci_plat_marvell_armada = {\n\t.init_quirk = xhci_mvebu_mbus_init_quirk,\n};\n\nstatic const struct xhci_plat_priv xhci_plat_marvell_armada3700 = {\n\t.init_quirk = xhci_mvebu_a3700_init_quirk,\n};\n\nstatic const struct xhci_plat_priv xhci_plat_brcm = {\n\t.quirks = XHCI_RESET_ON_RESUME | XHCI_SUSPEND_RESUME_CLKS,\n};\n\nstatic const struct of_device_id usb_xhci_of_match[] = {\n\t{\n\t\t.compatible = \"generic-xhci\",\n\t}, {\n\t\t.compatible = \"xhci-platform\",\n\t}, {\n\t\t.compatible = \"marvell,armada-375-xhci\",\n\t\t.data = &xhci_plat_marvell_armada,\n\t}, {\n\t\t.compatible = \"marvell,armada-380-xhci\",\n\t\t.data = &xhci_plat_marvell_armada,\n\t}, {\n\t\t.compatible = \"marvell,armada3700-xhci\",\n\t\t.data = &xhci_plat_marvell_armada3700,\n\t}, {\n\t\t.compatible = \"brcm,xhci-brcm-v2\",\n\t\t.data = &xhci_plat_brcm,\n\t}, {\n\t\t.compatible = \"brcm,bcm7445-xhci\",\n\t\t.data = &xhci_plat_brcm,\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, usb_xhci_of_match);\n#endif\n\nint xhci_plat_probe(struct platform_device *pdev, struct device *sysdev, const struct xhci_plat_priv *priv_match)\n{\n\tconst struct hc_driver\t*driver;\n\tstruct device\t\t*tmpdev;\n\tstruct xhci_hcd\t\t*xhci;\n\tstruct resource         *res;\n\tstruct usb_hcd\t\t*hcd, *usb3_hcd;\n\tint\t\t\tret;\n\tint\t\t\tirq;\n\tstruct xhci_plat_priv\t*priv = NULL;\n\tbool\t\t\tof_match;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdriver = &xhci_plat_hc_driver;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tif (!sysdev)\n\t\tsysdev = &pdev->dev;\n\n\tret = dma_set_mask_and_coherent(sysdev, DMA_BIT_MASK(64));\n\tif (ret)\n\t\treturn ret;\n\n\tpm_runtime_set_active(&pdev->dev);\n\tpm_runtime_enable(&pdev->dev);\n\tpm_runtime_get_noresume(&pdev->dev);\n\n\thcd = __usb_create_hcd(driver, sysdev, &pdev->dev,\n\t\t\t       dev_name(&pdev->dev), NULL);\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_runtime;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tret = PTR_ERR(hcd->regs);\n\t\tgoto put_hcd;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\txhci = hcd_to_xhci(hcd);\n\n\txhci->allow_single_roothub = 1;\n\n\t \n\txhci->reg_clk = devm_clk_get_optional(&pdev->dev, \"reg\");\n\tif (IS_ERR(xhci->reg_clk)) {\n\t\tret = PTR_ERR(xhci->reg_clk);\n\t\tgoto put_hcd;\n\t}\n\n\txhci->clk = devm_clk_get_optional(&pdev->dev, NULL);\n\tif (IS_ERR(xhci->clk)) {\n\t\tret = PTR_ERR(xhci->clk);\n\t\tgoto put_hcd;\n\t}\n\n\txhci->reset = devm_reset_control_array_get_optional_shared(&pdev->dev);\n\tif (IS_ERR(xhci->reset)) {\n\t\tret = PTR_ERR(xhci->reset);\n\t\tgoto put_hcd;\n\t}\n\n\tret = reset_control_deassert(xhci->reset);\n\tif (ret)\n\t\tgoto put_hcd;\n\n\tret = clk_prepare_enable(xhci->reg_clk);\n\tif (ret)\n\t\tgoto err_reset;\n\n\tret = clk_prepare_enable(xhci->clk);\n\tif (ret)\n\t\tgoto disable_reg_clk;\n\n\tif (priv_match) {\n\t\tpriv = hcd_to_xhci_priv(hcd);\n\t\t \n\t\t*priv = *priv_match;\n\t}\n\n\tdevice_set_wakeup_capable(&pdev->dev, true);\n\n\txhci->main_hcd = hcd;\n\n\t \n\txhci->imod_interval = 40000;\n\n\t \n\tfor (tmpdev = &pdev->dev; tmpdev; tmpdev = tmpdev->parent) {\n\n\t\tif (device_property_read_bool(tmpdev, \"usb2-lpm-disable\"))\n\t\t\txhci->quirks |= XHCI_HW_LPM_DISABLE;\n\n\t\tif (device_property_read_bool(tmpdev, \"usb3-lpm-capable\"))\n\t\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n\n\t\tif (device_property_read_bool(tmpdev, \"quirk-broken-port-ped\"))\n\t\t\txhci->quirks |= XHCI_BROKEN_PORT_PED;\n\n\t\tdevice_property_read_u32(tmpdev, \"imod-interval-ns\",\n\t\t\t\t\t &xhci->imod_interval);\n\t}\n\n\t \n\tof_match = of_match_device(pdev->dev.driver->of_match_table, &pdev->dev);\n\tif (of_match) {\n\t\thcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev, \"usb-phy\", 0);\n\t\tif (IS_ERR(hcd->usb_phy)) {\n\t\t\tret = PTR_ERR(hcd->usb_phy);\n\t\t\tif (ret == -EPROBE_DEFER)\n\t\t\t\tgoto disable_clk;\n\t\t\thcd->usb_phy = NULL;\n\t\t} else {\n\t\t\tret = usb_phy_init(hcd->usb_phy);\n\t\t\tif (ret)\n\t\t\t\tgoto disable_clk;\n\t\t}\n\t}\n\n\thcd->tpl_support = of_usb_host_tpl_support(sysdev->of_node);\n\n\tif (priv && (priv->quirks & XHCI_SKIP_PHY_INIT))\n\t\thcd->skip_phy_initialization = 1;\n\n\tif (priv && (priv->quirks & XHCI_SG_TRB_CACHE_SIZE_QUIRK))\n\t\txhci->quirks |= XHCI_SG_TRB_CACHE_SIZE_QUIRK;\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret)\n\t\tgoto disable_usb_phy;\n\n\tif (!xhci_has_one_roothub(xhci)) {\n\t\txhci->shared_hcd = __usb_create_hcd(driver, sysdev, &pdev->dev,\n\t\t\t\t\t\t    dev_name(&pdev->dev), hcd);\n\t\tif (!xhci->shared_hcd) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto dealloc_usb2_hcd;\n\t\t}\n\n\t\tif (of_match) {\n\t\t\txhci->shared_hcd->usb_phy = devm_usb_get_phy_by_phandle(sysdev,\n\t\t\t\t\t\t\t\t\t\t\"usb-phy\", 1);\n\t\t\tif (IS_ERR(xhci->shared_hcd->usb_phy)) {\n\t\t\t\txhci->shared_hcd->usb_phy = NULL;\n\t\t\t} else {\n\t\t\t\tret = usb_phy_init(xhci->shared_hcd->usb_phy);\n\t\t\t\tif (ret)\n\t\t\t\t\tdev_err(sysdev, \"%s init usb3phy fail (ret=%d)\\n\",\n\t\t\t\t\t\t__func__, ret);\n\t\t\t}\n\t\t}\n\n\t\txhci->shared_hcd->tpl_support = hcd->tpl_support;\n\t}\n\n\tusb3_hcd = xhci_get_usb3_hcd(xhci);\n\tif (usb3_hcd && HCC_MAX_PSA(xhci->hcc_params) >= 4)\n\t\tusb3_hcd->can_do_streams = 1;\n\n\tif (xhci->shared_hcd) {\n\t\tret = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);\n\t\tif (ret)\n\t\t\tgoto put_usb3_hcd;\n\t}\n\n\tdevice_enable_async_suspend(&pdev->dev);\n\tpm_runtime_put_noidle(&pdev->dev);\n\n\t \n\tpm_runtime_forbid(&pdev->dev);\n\n\treturn 0;\n\n\nput_usb3_hcd:\n\tusb_put_hcd(xhci->shared_hcd);\n\ndealloc_usb2_hcd:\n\tusb_remove_hcd(hcd);\n\ndisable_usb_phy:\n\tusb_phy_shutdown(hcd->usb_phy);\n\ndisable_clk:\n\tclk_disable_unprepare(xhci->clk);\n\ndisable_reg_clk:\n\tclk_disable_unprepare(xhci->reg_clk);\n\nerr_reset:\n\treset_control_assert(xhci->reset);\n\nput_hcd:\n\tusb_put_hcd(hcd);\n\ndisable_runtime:\n\tpm_runtime_put_noidle(&pdev->dev);\n\tpm_runtime_disable(&pdev->dev);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(xhci_plat_probe);\n\nstatic int xhci_generic_plat_probe(struct platform_device *pdev)\n{\n\tconst struct xhci_plat_priv *priv_match;\n\tstruct device *sysdev;\n\tint ret;\n\n\t \n\tfor (sysdev = &pdev->dev; sysdev; sysdev = sysdev->parent) {\n\t\tif (is_of_node(sysdev->fwnode) ||\n\t\t\tis_acpi_device_node(sysdev->fwnode))\n\t\t\tbreak;\n\t\telse if (dev_is_pci(sysdev))\n\t\t\tbreak;\n\t}\n\n\tif (!sysdev)\n\t\tsysdev = &pdev->dev;\n\n\tif (WARN_ON(!sysdev->dma_mask)) {\n\t\t \n\t\tret = dma_coerce_mask_and_coherent(sysdev, DMA_BIT_MASK(64));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (pdev->dev.of_node)\n\t\tpriv_match = of_device_get_match_data(&pdev->dev);\n\telse\n\t\tpriv_match = dev_get_platdata(&pdev->dev);\n\n\treturn xhci_plat_probe(pdev, sysdev, priv_match);\n}\n\nvoid xhci_plat_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(dev);\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct clk *clk = xhci->clk;\n\tstruct clk *reg_clk = xhci->reg_clk;\n\tstruct usb_hcd *shared_hcd = xhci->shared_hcd;\n\n\txhci->xhc_state |= XHCI_STATE_REMOVING;\n\tpm_runtime_get_sync(&dev->dev);\n\n\tif (shared_hcd) {\n\t\tusb_remove_hcd(shared_hcd);\n\t\txhci->shared_hcd = NULL;\n\t}\n\n\tusb_phy_shutdown(hcd->usb_phy);\n\n\tusb_remove_hcd(hcd);\n\n\tif (shared_hcd)\n\t\tusb_put_hcd(shared_hcd);\n\n\tclk_disable_unprepare(clk);\n\tclk_disable_unprepare(reg_clk);\n\treset_control_assert(xhci->reset);\n\tusb_put_hcd(hcd);\n\n\tpm_runtime_disable(&dev->dev);\n\tpm_runtime_put_noidle(&dev->dev);\n\tpm_runtime_set_suspended(&dev->dev);\n}\nEXPORT_SYMBOL_GPL(xhci_plat_remove);\n\nstatic int __maybe_unused xhci_plat_suspend(struct device *dev)\n{\n\tstruct usb_hcd\t*hcd = dev_get_drvdata(dev);\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint ret;\n\n\tif (pm_runtime_suspended(dev))\n\t\tpm_runtime_resume(dev);\n\n\tret = xhci_priv_suspend_quirk(hcd);\n\tif (ret)\n\t\treturn ret;\n\t \n\tret = xhci_suspend(xhci, device_may_wakeup(dev));\n\tif (ret)\n\t\treturn ret;\n\n\tif (!device_may_wakeup(dev) && (xhci->quirks & XHCI_SUSPEND_RESUME_CLKS)) {\n\t\tclk_disable_unprepare(xhci->clk);\n\t\tclk_disable_unprepare(xhci->reg_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int __maybe_unused xhci_plat_resume(struct device *dev)\n{\n\tstruct usb_hcd\t*hcd = dev_get_drvdata(dev);\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint ret;\n\n\tif (!device_may_wakeup(dev) && (xhci->quirks & XHCI_SUSPEND_RESUME_CLKS)) {\n\t\tret = clk_prepare_enable(xhci->clk);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = clk_prepare_enable(xhci->reg_clk);\n\t\tif (ret) {\n\t\t\tclk_disable_unprepare(xhci->clk);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = xhci_priv_resume_quirk(hcd);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\tret = xhci_resume(xhci, PMSG_RESUME);\n\tif (ret)\n\t\tgoto disable_clks;\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n\ndisable_clks:\n\tif (!device_may_wakeup(dev) && (xhci->quirks & XHCI_SUSPEND_RESUME_CLKS)) {\n\t\tclk_disable_unprepare(xhci->clk);\n\t\tclk_disable_unprepare(xhci->reg_clk);\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused xhci_plat_runtime_suspend(struct device *dev)\n{\n\tstruct usb_hcd  *hcd = dev_get_drvdata(dev);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tint ret;\n\n\tret = xhci_priv_suspend_quirk(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\treturn xhci_suspend(xhci, true);\n}\n\nstatic int __maybe_unused xhci_plat_runtime_resume(struct device *dev)\n{\n\tstruct usb_hcd  *hcd = dev_get_drvdata(dev);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\n\treturn xhci_resume(xhci, PMSG_AUTO_RESUME);\n}\n\nconst struct dev_pm_ops xhci_plat_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xhci_plat_suspend, xhci_plat_resume)\n\n\tSET_RUNTIME_PM_OPS(xhci_plat_runtime_suspend,\n\t\t\t   xhci_plat_runtime_resume,\n\t\t\t   NULL)\n};\nEXPORT_SYMBOL_GPL(xhci_plat_pm_ops);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id usb_xhci_acpi_match[] = {\n\t \n\t{ \"PNP0D10\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, usb_xhci_acpi_match);\n#endif\n\nstatic struct platform_driver usb_generic_xhci_driver = {\n\t.probe\t= xhci_generic_plat_probe,\n\t.remove_new = xhci_plat_remove,\n\t.shutdown = usb_hcd_platform_shutdown,\n\t.driver\t= {\n\t\t.name = \"xhci-hcd\",\n\t\t.pm = &xhci_plat_pm_ops,\n\t\t.of_match_table = of_match_ptr(usb_xhci_of_match),\n\t\t.acpi_match_table = ACPI_PTR(usb_xhci_acpi_match),\n\t},\n};\nMODULE_ALIAS(\"platform:xhci-hcd\");\n\nstatic int __init xhci_plat_init(void)\n{\n\txhci_init_driver(&xhci_plat_hc_driver, &xhci_plat_overrides);\n\treturn platform_driver_register(&usb_generic_xhci_driver);\n}\nmodule_init(xhci_plat_init);\n\nstatic void __exit xhci_plat_exit(void)\n{\n\tplatform_driver_unregister(&usb_generic_xhci_driver);\n}\nmodule_exit(xhci_plat_exit);\n\nMODULE_DESCRIPTION(\"xHCI Platform Host Controller Driver\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}