{
  "module_name": "xhci-debugfs.c",
  "hash_id": "f75eecb0738487f1488d96e1da942a874b2874a14158614c75055c7c34b483b7",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-debugfs.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\n#include \"xhci.h\"\n#include \"xhci-debugfs.h\"\n\nstatic const struct debugfs_reg32 xhci_cap_regs[] = {\n\tdump_register(CAPLENGTH),\n\tdump_register(HCSPARAMS1),\n\tdump_register(HCSPARAMS2),\n\tdump_register(HCSPARAMS3),\n\tdump_register(HCCPARAMS1),\n\tdump_register(DOORBELLOFF),\n\tdump_register(RUNTIMEOFF),\n\tdump_register(HCCPARAMS2),\n};\n\nstatic const struct debugfs_reg32 xhci_op_regs[] = {\n\tdump_register(USBCMD),\n\tdump_register(USBSTS),\n\tdump_register(PAGESIZE),\n\tdump_register(DNCTRL),\n\tdump_register(CRCR),\n\tdump_register(DCBAAP_LOW),\n\tdump_register(DCBAAP_HIGH),\n\tdump_register(CONFIG),\n};\n\nstatic const struct debugfs_reg32 xhci_runtime_regs[] = {\n\tdump_register(MFINDEX),\n\tdump_register(IR0_IMAN),\n\tdump_register(IR0_IMOD),\n\tdump_register(IR0_ERSTSZ),\n\tdump_register(IR0_ERSTBA_LOW),\n\tdump_register(IR0_ERSTBA_HIGH),\n\tdump_register(IR0_ERDP_LOW),\n\tdump_register(IR0_ERDP_HIGH),\n};\n\nstatic const struct debugfs_reg32 xhci_extcap_legsup[] = {\n\tdump_register(EXTCAP_USBLEGSUP),\n\tdump_register(EXTCAP_USBLEGCTLSTS),\n};\n\nstatic const struct debugfs_reg32 xhci_extcap_protocol[] = {\n\tdump_register(EXTCAP_REVISION),\n\tdump_register(EXTCAP_NAME),\n\tdump_register(EXTCAP_PORTINFO),\n\tdump_register(EXTCAP_PORTTYPE),\n\tdump_register(EXTCAP_MANTISSA1),\n\tdump_register(EXTCAP_MANTISSA2),\n\tdump_register(EXTCAP_MANTISSA3),\n\tdump_register(EXTCAP_MANTISSA4),\n\tdump_register(EXTCAP_MANTISSA5),\n\tdump_register(EXTCAP_MANTISSA6),\n};\n\nstatic const struct debugfs_reg32 xhci_extcap_dbc[] = {\n\tdump_register(EXTCAP_DBC_CAPABILITY),\n\tdump_register(EXTCAP_DBC_DOORBELL),\n\tdump_register(EXTCAP_DBC_ERSTSIZE),\n\tdump_register(EXTCAP_DBC_ERST_LOW),\n\tdump_register(EXTCAP_DBC_ERST_HIGH),\n\tdump_register(EXTCAP_DBC_ERDP_LOW),\n\tdump_register(EXTCAP_DBC_ERDP_HIGH),\n\tdump_register(EXTCAP_DBC_CONTROL),\n\tdump_register(EXTCAP_DBC_STATUS),\n\tdump_register(EXTCAP_DBC_PORTSC),\n\tdump_register(EXTCAP_DBC_CONT_LOW),\n\tdump_register(EXTCAP_DBC_CONT_HIGH),\n\tdump_register(EXTCAP_DBC_DEVINFO1),\n\tdump_register(EXTCAP_DBC_DEVINFO2),\n};\n\nstatic struct dentry *xhci_debugfs_root;\n\nstatic struct xhci_regset *xhci_debugfs_alloc_regset(struct xhci_hcd *xhci)\n{\n\tstruct xhci_regset\t*regset;\n\n\tregset = kzalloc(sizeof(*regset), GFP_KERNEL);\n\tif (!regset)\n\t\treturn NULL;\n\n\t \n\tINIT_LIST_HEAD(&regset->list);\n\tlist_add_tail(&regset->list, &xhci->regset_list);\n\n\treturn regset;\n}\n\nstatic void xhci_debugfs_free_regset(struct xhci_regset *regset)\n{\n\tif (!regset)\n\t\treturn;\n\n\tlist_del(&regset->list);\n\tkfree(regset);\n}\n\n__printf(6, 7)\nstatic void xhci_debugfs_regset(struct xhci_hcd *xhci, u32 base,\n\t\t\t\tconst struct debugfs_reg32 *regs,\n\t\t\t\tsize_t nregs, struct dentry *parent,\n\t\t\t\tconst char *fmt, ...)\n{\n\tstruct xhci_regset\t*rgs;\n\tva_list\t\t\targs;\n\tstruct debugfs_regset32\t*regset;\n\tstruct usb_hcd\t\t*hcd = xhci_to_hcd(xhci);\n\n\trgs = xhci_debugfs_alloc_regset(xhci);\n\tif (!rgs)\n\t\treturn;\n\n\tva_start(args, fmt);\n\tvsnprintf(rgs->name, sizeof(rgs->name), fmt, args);\n\tva_end(args);\n\n\tregset = &rgs->regset;\n\tregset->regs = regs;\n\tregset->nregs = nregs;\n\tregset->base = hcd->regs + base;\n\tregset->dev = hcd->self.controller;\n\n\tdebugfs_create_regset32((const char *)rgs->name, 0444, parent, regset);\n}\n\nstatic void xhci_debugfs_extcap_regset(struct xhci_hcd *xhci, int cap_id,\n\t\t\t\t       const struct debugfs_reg32 *regs,\n\t\t\t\t       size_t n, const char *cap_name)\n{\n\tu32\t\t\toffset;\n\tint\t\t\tindex = 0;\n\tsize_t\t\t\tpsic, nregs = n;\n\tvoid __iomem\t\t*base = &xhci->cap_regs->hc_capbase;\n\n\toffset = xhci_find_next_ext_cap(base, 0, cap_id);\n\twhile (offset) {\n\t\tif (cap_id == XHCI_EXT_CAPS_PROTOCOL) {\n\t\t\tpsic = XHCI_EXT_PORT_PSIC(readl(base + offset + 8));\n\t\t\tnregs = min(4 + psic, n);\n\t\t}\n\n\t\txhci_debugfs_regset(xhci, offset, regs, nregs,\n\t\t\t\t    xhci->debugfs_root, \"%s:%02d\",\n\t\t\t\t    cap_name, index);\n\t\toffset = xhci_find_next_ext_cap(base, offset, cap_id);\n\t\tindex++;\n\t}\n}\n\nstatic int xhci_ring_enqueue_show(struct seq_file *s, void *unused)\n{\n\tdma_addr_t\t\tdma;\n\tstruct xhci_ring\t*ring = *(struct xhci_ring **)s->private;\n\n\tdma = xhci_trb_virt_to_dma(ring->enq_seg, ring->enqueue);\n\tseq_printf(s, \"%pad\\n\", &dma);\n\n\treturn 0;\n}\n\nstatic int xhci_ring_dequeue_show(struct seq_file *s, void *unused)\n{\n\tdma_addr_t\t\tdma;\n\tstruct xhci_ring\t*ring = *(struct xhci_ring **)s->private;\n\n\tdma = xhci_trb_virt_to_dma(ring->deq_seg, ring->dequeue);\n\tseq_printf(s, \"%pad\\n\", &dma);\n\n\treturn 0;\n}\n\nstatic int xhci_ring_cycle_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_ring\t*ring = *(struct xhci_ring **)s->private;\n\n\tseq_printf(s, \"%d\\n\", ring->cycle_state);\n\n\treturn 0;\n}\n\nstatic void xhci_ring_dump_segment(struct seq_file *s,\n\t\t\t\t   struct xhci_segment *seg)\n{\n\tint\t\t\ti;\n\tdma_addr_t\t\tdma;\n\tunion xhci_trb\t\t*trb;\n\tchar\t\t\tstr[XHCI_MSG_MAX];\n\n\tfor (i = 0; i < TRBS_PER_SEGMENT; i++) {\n\t\ttrb = &seg->trbs[i];\n\t\tdma = seg->dma + i * sizeof(*trb);\n\t\tseq_printf(s, \"%pad: %s\\n\", &dma,\n\t\t\t   xhci_decode_trb(str, XHCI_MSG_MAX, le32_to_cpu(trb->generic.field[0]),\n\t\t\t\t\t   le32_to_cpu(trb->generic.field[1]),\n\t\t\t\t\t   le32_to_cpu(trb->generic.field[2]),\n\t\t\t\t\t   le32_to_cpu(trb->generic.field[3])));\n\t}\n}\n\nstatic int xhci_ring_trb_show(struct seq_file *s, void *unused)\n{\n\tint\t\t\ti;\n\tstruct xhci_ring\t*ring = *(struct xhci_ring **)s->private;\n\tstruct xhci_segment\t*seg = ring->first_seg;\n\n\tfor (i = 0; i < ring->num_segs; i++) {\n\t\txhci_ring_dump_segment(s, seg);\n\t\tseg = seg->next;\n\t}\n\n\treturn 0;\n}\n\nstatic struct xhci_file_map ring_files[] = {\n\t{\"enqueue\",\t\txhci_ring_enqueue_show, },\n\t{\"dequeue\",\t\txhci_ring_dequeue_show, },\n\t{\"cycle\",\t\txhci_ring_cycle_show, },\n\t{\"trbs\",\t\txhci_ring_trb_show, },\n};\n\nstatic int xhci_ring_open(struct inode *inode, struct file *file)\n{\n\tint\t\t\ti;\n\tstruct xhci_file_map\t*f_map;\n\tconst char\t\t*file_name = file_dentry(file)->d_iname;\n\n\tfor (i = 0; i < ARRAY_SIZE(ring_files); i++) {\n\t\tf_map = &ring_files[i];\n\n\t\tif (strcmp(f_map->name, file_name) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn single_open(file, f_map->show, inode->i_private);\n}\n\nstatic const struct file_operations xhci_ring_fops = {\n\t.open\t\t\t= xhci_ring_open,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\nstatic int xhci_slot_context_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_hcd\t\t*xhci;\n\tstruct xhci_slot_ctx\t*slot_ctx;\n\tstruct xhci_slot_priv\t*priv = s->private;\n\tstruct xhci_virt_device\t*dev = priv->dev;\n\tchar\t\t\tstr[XHCI_MSG_MAX];\n\n\txhci = hcd_to_xhci(bus_to_hcd(dev->udev->bus));\n\tslot_ctx = xhci_get_slot_ctx(xhci, dev->out_ctx);\n\tseq_printf(s, \"%pad: %s\\n\", &dev->out_ctx->dma,\n\t\t   xhci_decode_slot_context(str,\n\t\t\t\t\t    le32_to_cpu(slot_ctx->dev_info),\n\t\t\t\t\t    le32_to_cpu(slot_ctx->dev_info2),\n\t\t\t\t\t    le32_to_cpu(slot_ctx->tt_info),\n\t\t\t\t\t    le32_to_cpu(slot_ctx->dev_state)));\n\n\treturn 0;\n}\n\nstatic int xhci_endpoint_context_show(struct seq_file *s, void *unused)\n{\n\tint\t\t\tep_index;\n\tdma_addr_t\t\tdma;\n\tstruct xhci_hcd\t\t*xhci;\n\tstruct xhci_ep_ctx\t*ep_ctx;\n\tstruct xhci_slot_priv\t*priv = s->private;\n\tstruct xhci_virt_device\t*dev = priv->dev;\n\tchar\t\t\tstr[XHCI_MSG_MAX];\n\n\txhci = hcd_to_xhci(bus_to_hcd(dev->udev->bus));\n\n\tfor (ep_index = 0; ep_index < 31; ep_index++) {\n\t\tep_ctx = xhci_get_ep_ctx(xhci, dev->out_ctx, ep_index);\n\t\tdma = dev->out_ctx->dma + (ep_index + 1) * CTX_SIZE(xhci->hcc_params);\n\t\tseq_printf(s, \"%pad: %s\\n\", &dma,\n\t\t\t   xhci_decode_ep_context(str,\n\t\t\t\t\t\t  le32_to_cpu(ep_ctx->ep_info),\n\t\t\t\t\t\t  le32_to_cpu(ep_ctx->ep_info2),\n\t\t\t\t\t\t  le64_to_cpu(ep_ctx->deq),\n\t\t\t\t\t\t  le32_to_cpu(ep_ctx->tx_info)));\n\t}\n\n\treturn 0;\n}\n\nstatic int xhci_device_name_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_slot_priv\t*priv = s->private;\n\tstruct xhci_virt_device\t*dev = priv->dev;\n\n\tseq_printf(s, \"%s\\n\", dev_name(&dev->udev->dev));\n\n\treturn 0;\n}\n\nstatic struct xhci_file_map context_files[] = {\n\t{\"name\",\t\txhci_device_name_show, },\n\t{\"slot-context\",\txhci_slot_context_show, },\n\t{\"ep-context\",\t\txhci_endpoint_context_show, },\n};\n\nstatic int xhci_context_open(struct inode *inode, struct file *file)\n{\n\tint\t\t\ti;\n\tstruct xhci_file_map\t*f_map;\n\tconst char\t\t*file_name = file_dentry(file)->d_iname;\n\n\tfor (i = 0; i < ARRAY_SIZE(context_files); i++) {\n\t\tf_map = &context_files[i];\n\n\t\tif (strcmp(f_map->name, file_name) == 0)\n\t\t\tbreak;\n\t}\n\n\treturn single_open(file, f_map->show, inode->i_private);\n}\n\nstatic const struct file_operations xhci_context_fops = {\n\t.open\t\t\t= xhci_context_open,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\n\n\nstatic int xhci_portsc_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_port\t*port = s->private;\n\tu32\t\t\tportsc;\n\tchar\t\t\tstr[XHCI_MSG_MAX];\n\n\tportsc = readl(port->addr);\n\tseq_printf(s, \"%s\\n\", xhci_decode_portsc(str, portsc));\n\n\treturn 0;\n}\n\nstatic int xhci_port_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xhci_portsc_show, inode->i_private);\n}\n\nstatic ssize_t xhci_port_write(struct file *file,  const char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct seq_file         *s = file->private_data;\n\tstruct xhci_port\t*port = s->private;\n\tstruct xhci_hcd\t\t*xhci = hcd_to_xhci(port->rhub->hcd);\n\tchar                    buf[32];\n\tu32\t\t\tportsc;\n\tunsigned long\t\tflags;\n\n\tif (copy_from_user(&buf, ubuf, min_t(size_t, sizeof(buf) - 1, count)))\n\t\treturn -EFAULT;\n\n\tif (!strncmp(buf, \"compliance\", 10)) {\n\t\t \n\t\tif (!HCC2_CTC(xhci->hcc_params2))\n\t\t\treturn count;\n\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t \n\t\tportsc = readl(port->addr);\n\t\tif ((portsc & PORT_PLS_MASK) != XDEV_RXDETECT) {\n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\treturn -EPERM;\n\t\t}\n\t\tportsc = xhci_port_state_to_neutral(portsc);\n\t\tportsc &= ~PORT_PLS_MASK;\n\t\tportsc |= PORT_LINK_STROBE | XDEV_COMP_MODE;\n\t\twritel(portsc, port->addr);\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t} else {\n\t\treturn -EINVAL;\n\t}\n\treturn count;\n}\n\nstatic const struct file_operations port_fops = {\n\t.open\t\t\t= xhci_port_open,\n\t.write                  = xhci_port_write,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\nstatic void xhci_debugfs_create_files(struct xhci_hcd *xhci,\n\t\t\t\t      struct xhci_file_map *files,\n\t\t\t\t      size_t nentries, void *data,\n\t\t\t\t      struct dentry *parent,\n\t\t\t\t      const struct file_operations *fops)\n{\n\tint\t\t\ti;\n\n\tfor (i = 0; i < nentries; i++)\n\t\tdebugfs_create_file(files[i].name, 0444, parent, data, fops);\n}\n\nstatic struct dentry *xhci_debugfs_create_ring_dir(struct xhci_hcd *xhci,\n\t\t\t\t\t\t   struct xhci_ring **ring,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   struct dentry *parent)\n{\n\tstruct dentry\t\t*dir;\n\n\tdir = debugfs_create_dir(name, parent);\n\txhci_debugfs_create_files(xhci, ring_files, ARRAY_SIZE(ring_files),\n\t\t\t\t  ring, dir, &xhci_ring_fops);\n\n\treturn dir;\n}\n\nstatic void xhci_debugfs_create_context_files(struct xhci_hcd *xhci,\n\t\t\t\t\t      struct dentry *parent,\n\t\t\t\t\t      int slot_id)\n{\n\tstruct xhci_virt_device\t*dev = xhci->devs[slot_id];\n\n\txhci_debugfs_create_files(xhci, context_files,\n\t\t\t\t  ARRAY_SIZE(context_files),\n\t\t\t\t  dev->debugfs_private,\n\t\t\t\t  parent, &xhci_context_fops);\n}\n\nvoid xhci_debugfs_create_endpoint(struct xhci_hcd *xhci,\n\t\t\t\t  struct xhci_virt_device *dev,\n\t\t\t\t  int ep_index)\n{\n\tstruct xhci_ep_priv\t*epriv;\n\tstruct xhci_slot_priv\t*spriv = dev->debugfs_private;\n\n\tif (!spriv)\n\t\treturn;\n\n\tif (spriv->eps[ep_index])\n\t\treturn;\n\n\tepriv = kzalloc(sizeof(*epriv), GFP_KERNEL);\n\tif (!epriv)\n\t\treturn;\n\n\tepriv->show_ring = dev->eps[ep_index].ring;\n\n\tsnprintf(epriv->name, sizeof(epriv->name), \"ep%02d\", ep_index);\n\tepriv->root = xhci_debugfs_create_ring_dir(xhci,\n\t\t\t\t\t\t   &epriv->show_ring,\n\t\t\t\t\t\t   epriv->name,\n\t\t\t\t\t\t   spriv->root);\n\tspriv->eps[ep_index] = epriv;\n}\n\nvoid xhci_debugfs_remove_endpoint(struct xhci_hcd *xhci,\n\t\t\t\t  struct xhci_virt_device *dev,\n\t\t\t\t  int ep_index)\n{\n\tstruct xhci_ep_priv\t*epriv;\n\tstruct xhci_slot_priv\t*spriv = dev->debugfs_private;\n\n\tif (!spriv || !spriv->eps[ep_index])\n\t\treturn;\n\n\tepriv = spriv->eps[ep_index];\n\tdebugfs_remove_recursive(epriv->root);\n\tspriv->eps[ep_index] = NULL;\n\tkfree(epriv);\n}\n\nstatic int xhci_stream_id_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_ep_priv\t*epriv = s->private;\n\n\tif (!epriv->stream_info)\n\t\treturn -EPERM;\n\n\tseq_printf(s, \"Show stream ID %d trb ring, supported [1 - %d]\\n\",\n\t\t   epriv->stream_id, epriv->stream_info->num_streams - 1);\n\n\treturn 0;\n}\n\nstatic int xhci_stream_id_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, xhci_stream_id_show, inode->i_private);\n}\n\nstatic ssize_t xhci_stream_id_write(struct file *file,  const char __user *ubuf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tstruct seq_file         *s = file->private_data;\n\tstruct xhci_ep_priv\t*epriv = s->private;\n\tint\t\t\tret;\n\tu16\t\t\tstream_id;  \n\n\tif (!epriv->stream_info)\n\t\treturn -EPERM;\n\n\t \n\tret = kstrtou16_from_user(ubuf, count, 10, &stream_id);\n\tif (ret)\n\t\treturn ret;\n\n\tif (stream_id == 0 || stream_id >= epriv->stream_info->num_streams)\n\t\treturn -EINVAL;\n\n\tepriv->stream_id = stream_id;\n\tepriv->show_ring = epriv->stream_info->stream_rings[stream_id];\n\n\treturn count;\n}\n\nstatic const struct file_operations stream_id_fops = {\n\t.open\t\t\t= xhci_stream_id_open,\n\t.write                  = xhci_stream_id_write,\n\t.read\t\t\t= seq_read,\n\t.llseek\t\t\t= seq_lseek,\n\t.release\t\t= single_release,\n};\n\nstatic int xhci_stream_context_array_show(struct seq_file *s, void *unused)\n{\n\tstruct xhci_ep_priv\t*epriv = s->private;\n\tstruct xhci_stream_ctx\t*stream_ctx;\n\tdma_addr_t\t\tdma;\n\tint\t\t\tid;\n\n\tif (!epriv->stream_info)\n\t\treturn -EPERM;\n\n\tseq_printf(s, \"Allocated %d streams and %d stream context array entries\\n\",\n\t\t\tepriv->stream_info->num_streams,\n\t\t\tepriv->stream_info->num_stream_ctxs);\n\n\tfor (id = 0; id < epriv->stream_info->num_stream_ctxs; id++) {\n\t\tstream_ctx = epriv->stream_info->stream_ctx_array + id;\n\t\tdma = epriv->stream_info->ctx_array_dma + id * 16;\n\t\tif (id < epriv->stream_info->num_streams)\n\t\t\tseq_printf(s, \"%pad stream id %d deq %016llx\\n\", &dma,\n\t\t\t\t   id, le64_to_cpu(stream_ctx->stream_ring));\n\t\telse\n\t\t\tseq_printf(s, \"%pad stream context entry not used deq %016llx\\n\",\n\t\t\t\t   &dma, le64_to_cpu(stream_ctx->stream_ring));\n\t}\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(xhci_stream_context_array);\n\nvoid xhci_debugfs_create_stream_files(struct xhci_hcd *xhci,\n\t\t\t\t      struct xhci_virt_device *dev,\n\t\t\t\t      int ep_index)\n{\n\tstruct xhci_slot_priv\t*spriv = dev->debugfs_private;\n\tstruct xhci_ep_priv\t*epriv;\n\n\tif (!spriv || !spriv->eps[ep_index] ||\n\t    !dev->eps[ep_index].stream_info)\n\t\treturn;\n\n\tepriv = spriv->eps[ep_index];\n\tepriv->stream_info = dev->eps[ep_index].stream_info;\n\n\t \n\tepriv->stream_id = 1;\n\tepriv->show_ring = epriv->stream_info->stream_rings[1];\n\tdebugfs_create_file(\"stream_id\", 0644,\n\t\t\t    epriv->root, epriv,\n\t\t\t    &stream_id_fops);\n\tdebugfs_create_file(\"stream_context_array\", 0444,\n\t\t\t    epriv->root, epriv,\n\t\t\t    &xhci_stream_context_array_fops);\n}\n\nvoid xhci_debugfs_create_slot(struct xhci_hcd *xhci, int slot_id)\n{\n\tstruct xhci_slot_priv\t*priv;\n\tstruct xhci_virt_device\t*dev = xhci->devs[slot_id];\n\n\tpriv = kzalloc(sizeof(*priv), GFP_KERNEL);\n\tif (!priv)\n\t\treturn;\n\n\tsnprintf(priv->name, sizeof(priv->name), \"%02d\", slot_id);\n\tpriv->root = debugfs_create_dir(priv->name, xhci->debugfs_slots);\n\tpriv->dev = dev;\n\tdev->debugfs_private = priv;\n\n\txhci_debugfs_create_ring_dir(xhci, &dev->eps[0].ring,\n\t\t\t\t     \"ep00\", priv->root);\n\n\txhci_debugfs_create_context_files(xhci, priv->root, slot_id);\n}\n\nvoid xhci_debugfs_remove_slot(struct xhci_hcd *xhci, int slot_id)\n{\n\tint\t\t\ti;\n\tstruct xhci_slot_priv\t*priv;\n\tstruct xhci_virt_device\t*dev = xhci->devs[slot_id];\n\n\tif (!dev || !dev->debugfs_private)\n\t\treturn;\n\n\tpriv = dev->debugfs_private;\n\n\tdebugfs_remove_recursive(priv->root);\n\n\tfor (i = 0; i < 31; i++)\n\t\tkfree(priv->eps[i]);\n\n\tkfree(priv);\n\tdev->debugfs_private = NULL;\n}\n\nstatic void xhci_debugfs_create_ports(struct xhci_hcd *xhci,\n\t\t\t\t      struct dentry *parent)\n{\n\tunsigned int\t\tnum_ports;\n\tchar\t\t\tport_name[8];\n\tstruct xhci_port\t*port;\n\tstruct dentry\t\t*dir;\n\n\tnum_ports = HCS_MAX_PORTS(xhci->hcs_params1);\n\n\tparent = debugfs_create_dir(\"ports\", parent);\n\n\twhile (num_ports--) {\n\t\tscnprintf(port_name, sizeof(port_name), \"port%02d\",\n\t\t\t  num_ports + 1);\n\t\tdir = debugfs_create_dir(port_name, parent);\n\t\tport = &xhci->hw_ports[num_ports];\n\t\tdebugfs_create_file(\"portsc\", 0644, dir, port, &port_fops);\n\t}\n}\n\nvoid xhci_debugfs_init(struct xhci_hcd *xhci)\n{\n\tstruct device\t\t*dev = xhci_to_hcd(xhci)->self.controller;\n\n\txhci->debugfs_root = debugfs_create_dir(dev_name(dev),\n\t\t\t\t\t\txhci_debugfs_root);\n\n\tINIT_LIST_HEAD(&xhci->regset_list);\n\n\txhci_debugfs_regset(xhci,\n\t\t\t    0,\n\t\t\t    xhci_cap_regs, ARRAY_SIZE(xhci_cap_regs),\n\t\t\t    xhci->debugfs_root, \"reg-cap\");\n\n\txhci_debugfs_regset(xhci,\n\t\t\t    HC_LENGTH(readl(&xhci->cap_regs->hc_capbase)),\n\t\t\t    xhci_op_regs, ARRAY_SIZE(xhci_op_regs),\n\t\t\t    xhci->debugfs_root, \"reg-op\");\n\n\txhci_debugfs_regset(xhci,\n\t\t\t    readl(&xhci->cap_regs->run_regs_off) & RTSOFF_MASK,\n\t\t\t    xhci_runtime_regs, ARRAY_SIZE(xhci_runtime_regs),\n\t\t\t    xhci->debugfs_root, \"reg-runtime\");\n\n\txhci_debugfs_extcap_regset(xhci, XHCI_EXT_CAPS_LEGACY,\n\t\t\t\t   xhci_extcap_legsup,\n\t\t\t\t   ARRAY_SIZE(xhci_extcap_legsup),\n\t\t\t\t   \"reg-ext-legsup\");\n\n\txhci_debugfs_extcap_regset(xhci, XHCI_EXT_CAPS_PROTOCOL,\n\t\t\t\t   xhci_extcap_protocol,\n\t\t\t\t   ARRAY_SIZE(xhci_extcap_protocol),\n\t\t\t\t   \"reg-ext-protocol\");\n\n\txhci_debugfs_extcap_regset(xhci, XHCI_EXT_CAPS_DEBUG,\n\t\t\t\t   xhci_extcap_dbc,\n\t\t\t\t   ARRAY_SIZE(xhci_extcap_dbc),\n\t\t\t\t   \"reg-ext-dbc\");\n\n\txhci_debugfs_create_ring_dir(xhci, &xhci->cmd_ring,\n\t\t\t\t     \"command-ring\",\n\t\t\t\t     xhci->debugfs_root);\n\n\txhci_debugfs_create_ring_dir(xhci, &xhci->interrupter->event_ring,\n\t\t\t\t     \"event-ring\",\n\t\t\t\t     xhci->debugfs_root);\n\n\txhci->debugfs_slots = debugfs_create_dir(\"devices\", xhci->debugfs_root);\n\n\txhci_debugfs_create_ports(xhci, xhci->debugfs_root);\n}\n\nvoid xhci_debugfs_exit(struct xhci_hcd *xhci)\n{\n\tstruct xhci_regset\t*rgs, *tmp;\n\n\tdebugfs_remove_recursive(xhci->debugfs_root);\n\txhci->debugfs_root = NULL;\n\txhci->debugfs_slots = NULL;\n\n\tlist_for_each_entry_safe(rgs, tmp, &xhci->regset_list, list)\n\t\txhci_debugfs_free_regset(rgs);\n}\n\nvoid __init xhci_debugfs_create_root(void)\n{\n\txhci_debugfs_root = debugfs_create_dir(\"xhci\", usb_debug_root);\n}\n\nvoid __exit xhci_debugfs_remove_root(void)\n{\n\tdebugfs_remove_recursive(xhci_debugfs_root);\n\txhci_debugfs_root = NULL;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}