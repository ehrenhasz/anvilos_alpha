{
  "module_name": "ehci-sched.c",
  "hash_id": "6480f8ca75cc08bcbc07a489e6786442cff056df6269c5a7f82447125f50a381",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-sched.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\nstatic int ehci_get_frame(struct usb_hcd *hcd);\n\n \nstatic union ehci_shadow *\nperiodic_next_shadow(struct ehci_hcd *ehci, union ehci_shadow *periodic,\n\t\t__hc32 tag)\n{\n\tswitch (hc32_to_cpu(ehci, tag)) {\n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->qh_next;\n\tcase Q_TYPE_FSTN:\n\t\treturn &periodic->fstn->fstn_next;\n\tcase Q_TYPE_ITD:\n\t\treturn &periodic->itd->itd_next;\n\t \n\tdefault:\n\t\treturn &periodic->sitd->sitd_next;\n\t}\n}\n\nstatic __hc32 *\nshadow_next_periodic(struct ehci_hcd *ehci, union ehci_shadow *periodic,\n\t\t__hc32 tag)\n{\n\tswitch (hc32_to_cpu(ehci, tag)) {\n\t \n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->hw->hw_next;\n\t \n\tdefault:\n\t\treturn periodic->hw_next;\n\t}\n}\n\n \nstatic void periodic_unlink(struct ehci_hcd *ehci, unsigned frame, void *ptr)\n{\n\tunion ehci_shadow\t*prev_p = &ehci->pshadow[frame];\n\t__hc32\t\t\t*hw_p = &ehci->periodic[frame];\n\tunion ehci_shadow\there = *prev_p;\n\n\t \n\twhile (here.ptr && here.ptr != ptr) {\n\t\tprev_p = periodic_next_shadow(ehci, prev_p,\n\t\t\t\tQ_NEXT_TYPE(ehci, *hw_p));\n\t\thw_p = shadow_next_periodic(ehci, &here,\n\t\t\t\tQ_NEXT_TYPE(ehci, *hw_p));\n\t\there = *prev_p;\n\t}\n\t \n\tif (!here.ptr)\n\t\treturn;\n\n\t \n\t*prev_p = *periodic_next_shadow(ehci, &here,\n\t\t\tQ_NEXT_TYPE(ehci, *hw_p));\n\n\tif (!ehci->use_dummy_qh ||\n\t    *shadow_next_periodic(ehci, &here, Q_NEXT_TYPE(ehci, *hw_p))\n\t\t\t!= EHCI_LIST_END(ehci))\n\t\t*hw_p = *shadow_next_periodic(ehci, &here,\n\t\t\t\tQ_NEXT_TYPE(ehci, *hw_p));\n\telse\n\t\t*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\n}\n\n \n\n \n\n \nstatic struct ehci_tt *find_tt(struct usb_device *udev)\n{\n\tstruct usb_tt\t\t*utt = udev->tt;\n\tstruct ehci_tt\t\t*tt, **tt_index, **ptt;\n\tunsigned\t\tport;\n\tbool\t\t\tallocated_index = false;\n\n\tif (!utt)\n\t\treturn NULL;\t\t \n\n\t \n\ttt_index = NULL;\n\tif (utt->multi) {\n\t\ttt_index = utt->hcpriv;\n\t\tif (!tt_index) {\t\t \n\t\t\ttt_index = kcalloc(utt->hub->maxchild,\n\t\t\t\t\t   sizeof(*tt_index),\n\t\t\t\t\t   GFP_ATOMIC);\n\t\t\tif (!tt_index)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\tutt->hcpriv = tt_index;\n\t\t\tallocated_index = true;\n\t\t}\n\t\tport = udev->ttport - 1;\n\t\tptt = &tt_index[port];\n\t} else {\n\t\tport = 0;\n\t\tptt = (struct ehci_tt **) &utt->hcpriv;\n\t}\n\n\ttt = *ptt;\n\tif (!tt) {\t\t\t\t \n\t\tstruct ehci_hcd\t\t*ehci =\n\t\t\t\thcd_to_ehci(bus_to_hcd(udev->bus));\n\n\t\ttt = kzalloc(sizeof(*tt), GFP_ATOMIC);\n\t\tif (!tt) {\n\t\t\tif (allocated_index) {\n\t\t\t\tutt->hcpriv = NULL;\n\t\t\t\tkfree(tt_index);\n\t\t\t}\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tlist_add_tail(&tt->tt_list, &ehci->tt_list);\n\t\tINIT_LIST_HEAD(&tt->ps_list);\n\t\ttt->usb_tt = utt;\n\t\ttt->tt_port = port;\n\t\t*ptt = tt;\n\t}\n\n\treturn tt;\n}\n\n \nstatic void drop_tt(struct usb_device *udev)\n{\n\tstruct usb_tt\t\t*utt = udev->tt;\n\tstruct ehci_tt\t\t*tt, **tt_index, **ptt;\n\tint\t\t\tcnt, i;\n\n\tif (!utt || !utt->hcpriv)\n\t\treturn;\t\t \n\n\tcnt = 0;\n\tif (utt->multi) {\n\t\ttt_index = utt->hcpriv;\n\t\tptt = &tt_index[udev->ttport - 1];\n\n\t\t \n\t\tfor (i = 0; i < utt->hub->maxchild; ++i)\n\t\t\tcnt += !!tt_index[i];\n\t} else {\n\t\ttt_index = NULL;\n\t\tptt = (struct ehci_tt **) &utt->hcpriv;\n\t}\n\n\ttt = *ptt;\n\tif (!tt || !list_empty(&tt->ps_list))\n\t\treturn;\t\t \n\n\tlist_del(&tt->tt_list);\n\t*ptt = NULL;\n\tkfree(tt);\n\tif (cnt == 1) {\n\t\tutt->hcpriv = NULL;\n\t\tkfree(tt_index);\n\t}\n}\n\nstatic void bandwidth_dbg(struct ehci_hcd *ehci, int sign, char *type,\n\t\tstruct ehci_per_sched *ps)\n{\n\tdev_dbg(&ps->udev->dev,\n\t\t\t\"ep %02x: %s %s @ %u+%u (%u.%u+%u) [%u/%u us] mask %04x\\n\",\n\t\t\tps->ep->desc.bEndpointAddress,\n\t\t\t(sign >= 0 ? \"reserve\" : \"release\"), type,\n\t\t\t(ps->bw_phase << 3) + ps->phase_uf, ps->bw_uperiod,\n\t\t\tps->phase, ps->phase_uf, ps->period,\n\t\t\tps->usecs, ps->c_usecs, ps->cs_mask);\n}\n\nstatic void reserve_release_intr_bandwidth(struct ehci_hcd *ehci,\n\t\tstruct ehci_qh *qh, int sign)\n{\n\tunsigned\t\tstart_uf;\n\tunsigned\t\ti, j, m;\n\tint\t\t\tusecs = qh->ps.usecs;\n\tint\t\t\tc_usecs = qh->ps.c_usecs;\n\tint\t\t\ttt_usecs = qh->ps.tt_usecs;\n\tstruct ehci_tt\t\t*tt;\n\n\tif (qh->ps.phase == NO_FRAME)\t \n\t\treturn;\n\tstart_uf = qh->ps.bw_phase << 3;\n\n\tbandwidth_dbg(ehci, sign, \"intr\", &qh->ps);\n\n\tif (sign < 0) {\t\t \n\t\tusecs = -usecs;\n\t\tc_usecs = -c_usecs;\n\t\ttt_usecs = -tt_usecs;\n\t}\n\n\t \n\tfor (i = start_uf + qh->ps.phase_uf; i < EHCI_BANDWIDTH_SIZE;\n\t\t\ti += qh->ps.bw_uperiod)\n\t\tehci->bandwidth[i] += usecs;\n\n\t \n\tif (qh->ps.c_usecs) {\n\t\t \n\t\tfor (i = start_uf; i < EHCI_BANDWIDTH_SIZE;\n\t\t\t\ti += qh->ps.bw_uperiod) {\n\t\t\tfor ((j = 2, m = 1 << (j+8)); j < 8; (++j, m <<= 1)) {\n\t\t\t\tif (qh->ps.cs_mask & m)\n\t\t\t\t\tehci->bandwidth[i+j] += c_usecs;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (tt_usecs) {\n\t\t \n\t\ttt = find_tt(qh->ps.udev);\n\t\tif (sign > 0)\n\t\t\tlist_add_tail(&qh->ps.ps_list, &tt->ps_list);\n\t\telse\n\t\t\tlist_del(&qh->ps.ps_list);\n\n\t\tfor (i = start_uf >> 3; i < EHCI_BANDWIDTH_FRAMES;\n\t\t\t\ti += qh->ps.bw_period)\n\t\t\ttt->bandwidth[i] += tt_usecs;\n\t}\n}\n\n \n\nstatic void compute_tt_budget(u8 budget_table[EHCI_BANDWIDTH_SIZE],\n\t\tstruct ehci_tt *tt)\n{\n\tstruct ehci_per_sched\t*ps;\n\tunsigned\t\tuframe, uf, x;\n\tu8\t\t\t*budget_line;\n\n\tif (!tt)\n\t\treturn;\n\tmemset(budget_table, 0, EHCI_BANDWIDTH_SIZE);\n\n\t \n\tlist_for_each_entry(ps, &tt->ps_list, ps_list) {\n\t\tfor (uframe = ps->bw_phase << 3; uframe < EHCI_BANDWIDTH_SIZE;\n\t\t\t\tuframe += ps->bw_uperiod) {\n\t\t\tbudget_line = &budget_table[uframe];\n\t\t\tx = ps->tt_usecs;\n\n\t\t\t \n\t\t\tfor (uf = ps->phase_uf; uf < 8; ++uf) {\n\t\t\t\tx += budget_line[uf];\n\n\t\t\t\t \n\t\t\t\tif (x <= 125) {\n\t\t\t\t\tbudget_line[uf] = x;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbudget_line[uf] = 125;\n\t\t\t\tx -= 125;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int __maybe_unused same_tt(struct usb_device *dev1,\n\t\tstruct usb_device *dev2)\n{\n\tif (!dev1->tt || !dev2->tt)\n\t\treturn 0;\n\tif (dev1->tt != dev2->tt)\n\t\treturn 0;\n\tif (dev1->tt->multi)\n\t\treturn dev1->ttport == dev2->ttport;\n\telse\n\t\treturn 1;\n}\n\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\n\nstatic const unsigned char\nmax_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };\n\n \nstatic inline void carryover_tt_bandwidth(unsigned short tt_usecs[8])\n{\n\tint i;\n\n\tfor (i = 0; i < 7; i++) {\n\t\tif (max_tt_usecs[i] < tt_usecs[i]) {\n\t\t\ttt_usecs[i+1] += tt_usecs[i] - max_tt_usecs[i];\n\t\t\ttt_usecs[i] = max_tt_usecs[i];\n\t\t}\n\t}\n}\n\n \nstatic int tt_available(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_per_sched\t*ps,\n\tstruct ehci_tt\t\t*tt,\n\tunsigned\t\tframe,\n\tunsigned\t\tuframe\n)\n{\n\tunsigned\t\tperiod = ps->bw_period;\n\tunsigned\t\tusecs = ps->tt_usecs;\n\n\tif ((period == 0) || (uframe >= 7))\t \n\t\treturn 0;\n\n\tfor (frame &= period - 1; frame < EHCI_BANDWIDTH_FRAMES;\n\t\t\tframe += period) {\n\t\tunsigned\ti, uf;\n\t\tunsigned short\ttt_usecs[8];\n\n\t\tif (tt->bandwidth[frame] + usecs > 900)\n\t\t\treturn 0;\n\n\t\tuf = frame << 3;\n\t\tfor (i = 0; i < 8; (++i, ++uf))\n\t\t\ttt_usecs[i] = ehci->tt_budget[uf];\n\n\t\tif (max_tt_usecs[uframe] <= tt_usecs[uframe])\n\t\t\treturn 0;\n\n\t\t \n\t\tif (usecs > 125) {\n\t\t\tint ufs = (usecs / 125);\n\n\t\t\tfor (i = uframe; i < (uframe + ufs) && i < 8; i++)\n\t\t\t\tif (tt_usecs[i] > 0)\n\t\t\t\t\treturn 0;\n\t\t}\n\n\t\ttt_usecs[uframe] += usecs;\n\n\t\tcarryover_tt_bandwidth(tt_usecs);\n\n\t\t \n\t\tif (max_tt_usecs[7] < tt_usecs[7])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n#else\n\n \nstatic int tt_no_collision(\n\tstruct ehci_hcd\t\t*ehci,\n\tunsigned\t\tperiod,\n\tstruct usb_device\t*dev,\n\tunsigned\t\tframe,\n\tu32\t\t\tuf_mask\n)\n{\n\tif (period == 0)\t \n\t\treturn 0;\n\n\t \n\tfor (; frame < ehci->periodic_size; frame += period) {\n\t\tunion ehci_shadow\there;\n\t\t__hc32\t\t\ttype;\n\t\tstruct ehci_qh_hw\t*hw;\n\n\t\there = ehci->pshadow[frame];\n\t\ttype = Q_NEXT_TYPE(ehci, ehci->periodic[frame]);\n\t\twhile (here.ptr) {\n\t\t\tswitch (hc32_to_cpu(ehci, type)) {\n\t\t\tcase Q_TYPE_ITD:\n\t\t\t\ttype = Q_NEXT_TYPE(ehci, here.itd->hw_next);\n\t\t\t\there = here.itd->itd_next;\n\t\t\t\tcontinue;\n\t\t\tcase Q_TYPE_QH:\n\t\t\t\thw = here.qh->hw;\n\t\t\t\tif (same_tt(dev, here.qh->ps.udev)) {\n\t\t\t\t\tu32\t\tmask;\n\n\t\t\t\t\tmask = hc32_to_cpu(ehci,\n\t\t\t\t\t\t\thw->hw_info2);\n\t\t\t\t\t \n\t\t\t\t\tmask |= mask >> 8;\n\t\t\t\t\tif (mask & uf_mask)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttype = Q_NEXT_TYPE(ehci, hw->hw_next);\n\t\t\t\there = here.qh->qh_next;\n\t\t\t\tcontinue;\n\t\t\tcase Q_TYPE_SITD:\n\t\t\t\tif (same_tt(dev, here.sitd->urb->dev)) {\n\t\t\t\t\tu16\t\tmask;\n\n\t\t\t\t\tmask = hc32_to_cpu(ehci, here.sitd\n\t\t\t\t\t\t\t\t->hw_uframe);\n\t\t\t\t\t \n\t\t\t\t\tmask |= mask >> 8;\n\t\t\t\t\tif (mask & uf_mask)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttype = Q_NEXT_TYPE(ehci, here.sitd->hw_next);\n\t\t\t\there = here.sitd->sitd_next;\n\t\t\t\tcontinue;\n\t\t\t \n\t\t\tdefault:\n\t\t\t\tehci_dbg(ehci,\n\t\t\t\t\t\"periodic frame %d bogus type %d\\n\",\n\t\t\t\t\tframe, type);\n\t\t\t}\n\n\t\t\t \n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t \n\treturn 1;\n}\n\n#endif  \n\n \n\nstatic void enable_periodic(struct ehci_hcd *ehci)\n{\n\tif (ehci->periodic_count++)\n\t\tgoto out;\n\n\t \n\tehci->enabled_hrtimer_events &= ~BIT(EHCI_HRTIMER_DISABLE_PERIODIC);\n\n\t \n\tehci_poll_PSS(ehci);\nout:\n\tturn_on_io_watchdog(ehci);\n}\n\nstatic void disable_periodic(struct ehci_hcd *ehci)\n{\n\tif (--ehci->periodic_count)\n\t\treturn;\n\n\t \n\tehci_poll_PSS(ehci);\n}\n\n \n\n \nstatic void qh_link_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tunsigned\ti;\n\tunsigned\tperiod = qh->ps.period;\n\n\tdev_dbg(&qh->ps.udev->dev,\n\t\t\"link qh%d-%04x/%p start %d [%d/%d us]\\n\",\n\t\tperiod, hc32_to_cpup(ehci, &qh->hw->hw_info2)\n\t\t\t& (QH_CMASK | QH_SMASK),\n\t\tqh, qh->ps.phase, qh->ps.usecs, qh->ps.c_usecs);\n\n\t \n\tif (period == 0)\n\t\tperiod = 1;\n\n\tfor (i = qh->ps.phase; i < ehci->periodic_size; i += period) {\n\t\tunion ehci_shadow\t*prev = &ehci->pshadow[i];\n\t\t__hc32\t\t\t*hw_p = &ehci->periodic[i];\n\t\tunion ehci_shadow\there = *prev;\n\t\t__hc32\t\t\ttype = 0;\n\n\t\t \n\t\twhile (here.ptr) {\n\t\t\ttype = Q_NEXT_TYPE(ehci, *hw_p);\n\t\t\tif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\n\t\t\t\tbreak;\n\t\t\tprev = periodic_next_shadow(ehci, prev, type);\n\t\t\thw_p = shadow_next_periodic(ehci, &here, type);\n\t\t\there = *prev;\n\t\t}\n\n\t\t \n\t\twhile (here.ptr && qh != here.qh) {\n\t\t\tif (qh->ps.period > here.qh->ps.period)\n\t\t\t\tbreak;\n\t\t\tprev = &here.qh->qh_next;\n\t\t\thw_p = &here.qh->hw->hw_next;\n\t\t\there = *prev;\n\t\t}\n\t\t \n\t\tif (qh != here.qh) {\n\t\t\tqh->qh_next = here;\n\t\t\tif (here.qh)\n\t\t\t\tqh->hw->hw_next = *hw_p;\n\t\t\twmb();\n\t\t\tprev->qh = qh;\n\t\t\t*hw_p = QH_NEXT(ehci, qh->qh_dma);\n\t\t}\n\t}\n\tqh->qh_state = QH_STATE_LINKED;\n\tqh->xacterrs = 0;\n\tqh->unlink_reason = 0;\n\n\t \n\tehci_to_hcd(ehci)->self.bandwidth_allocated += qh->ps.bw_period\n\t\t? ((qh->ps.usecs + qh->ps.c_usecs) / qh->ps.bw_period)\n\t\t: (qh->ps.usecs * 8);\n\n\tlist_add(&qh->intr_node, &ehci->intr_qh_list);\n\n\t \n\t++ehci->intr_count;\n\tenable_periodic(ehci);\n}\n\nstatic void qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tunsigned\ti;\n\tunsigned\tperiod;\n\n\t \n\n\t \n\tperiod = qh->ps.period ? : 1;\n\n\tfor (i = qh->ps.phase; i < ehci->periodic_size; i += period)\n\t\tperiodic_unlink(ehci, i, qh);\n\n\t \n\tehci_to_hcd(ehci)->self.bandwidth_allocated -= qh->ps.bw_period\n\t\t? ((qh->ps.usecs + qh->ps.c_usecs) / qh->ps.bw_period)\n\t\t: (qh->ps.usecs * 8);\n\n\tdev_dbg(&qh->ps.udev->dev,\n\t\t\"unlink qh%d-%04x/%p start %d [%d/%d us]\\n\",\n\t\tqh->ps.period,\n\t\thc32_to_cpup(ehci, &qh->hw->hw_info2) & (QH_CMASK | QH_SMASK),\n\t\tqh, qh->ps.phase, qh->ps.usecs, qh->ps.c_usecs);\n\n\t \n\tqh->qh_state = QH_STATE_UNLINK;\n\tqh->qh_next.ptr = NULL;\n\n\tif (ehci->qh_scan_next == qh)\n\t\tehci->qh_scan_next = list_entry(qh->intr_node.next,\n\t\t\t\tstruct ehci_qh, intr_node);\n\tlist_del(&qh->intr_node);\n}\n\nstatic void cancel_unlink_wait_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tif (qh->qh_state != QH_STATE_LINKED ||\n\t\t\tlist_empty(&qh->unlink_node))\n\t\treturn;\n\n\tlist_del_init(&qh->unlink_node);\n\n\t \n}\n\nstatic void start_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\t \n\tif (qh->qh_state != QH_STATE_LINKED)\n\t\treturn;\n\n\t \n\tcancel_unlink_wait_intr(ehci, qh);\n\n\tqh_unlink_periodic(ehci, qh);\n\n\t \n\twmb();\n\n\t \n\tqh->unlink_cycle = ehci->intr_unlink_cycle;\n\n\t \n\tlist_add_tail(&qh->unlink_node, &ehci->intr_unlink);\n\n\tif (ehci->intr_unlinking)\n\t\t;\t \n\telse if (ehci->rh_state < EHCI_RH_RUNNING)\n\t\tehci_handle_intr_unlinks(ehci);\n\telse if (ehci->intr_unlink.next == &qh->unlink_node) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);\n\t\t++ehci->intr_unlink_cycle;\n\t}\n}\n\n \nstatic void start_unlink_intr_wait(struct ehci_hcd *ehci,\n\t\t\t\t   struct ehci_qh *qh)\n{\n\tqh->unlink_cycle = ehci->intr_unlink_wait_cycle;\n\n\t \n\tlist_add_tail(&qh->unlink_node, &ehci->intr_unlink_wait);\n\n\tif (ehci->rh_state < EHCI_RH_RUNNING)\n\t\tehci_handle_start_intr_unlinks(ehci);\n\telse if (ehci->intr_unlink_wait.next == &qh->unlink_node) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_START_UNLINK_INTR, true);\n\t\t++ehci->intr_unlink_wait_cycle;\n\t}\n}\n\nstatic void end_unlink_intr(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tstruct ehci_qh_hw\t*hw = qh->hw;\n\tint\t\t\trc;\n\n\tqh->qh_state = QH_STATE_IDLE;\n\thw->hw_next = EHCI_LIST_END(ehci);\n\n\tif (!list_empty(&qh->qtd_list))\n\t\tqh_completions(ehci, qh);\n\n\t \n\tif (!list_empty(&qh->qtd_list) && ehci->rh_state == EHCI_RH_RUNNING) {\n\t\trc = qh_schedule(ehci, qh);\n\t\tif (rc == 0) {\n\t\t\tqh_refresh(ehci, qh);\n\t\t\tqh_link_periodic(ehci, qh);\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tehci_err(ehci, \"can't reschedule qh %p, err %d\\n\",\n\t\t\t\t\tqh, rc);\n\t\t}\n\t}\n\n\t \n\t--ehci->intr_count;\n\tdisable_periodic(ehci);\n}\n\n \n\nstatic int check_period(\n\tstruct ehci_hcd *ehci,\n\tunsigned\tframe,\n\tunsigned\tuframe,\n\tunsigned\tuperiod,\n\tunsigned\tusecs\n) {\n\t \n\tif (uframe >= 8)\n\t\treturn 0;\n\n\t \n\tusecs = ehci->uframe_periodic_max - usecs;\n\n\tfor (uframe += frame << 3; uframe < EHCI_BANDWIDTH_SIZE;\n\t\t\tuframe += uperiod) {\n\t\tif (ehci->bandwidth[uframe] > usecs)\n\t\t\treturn 0;\n\t}\n\n\t \n\treturn 1;\n}\n\nstatic int check_intr_schedule(\n\tstruct ehci_hcd\t\t*ehci,\n\tunsigned\t\tframe,\n\tunsigned\t\tuframe,\n\tstruct ehci_qh\t\t*qh,\n\tunsigned\t\t*c_maskp,\n\tstruct ehci_tt\t\t*tt\n)\n{\n\tint\t\tretval = -ENOSPC;\n\tu8\t\tmask = 0;\n\n\tif (qh->ps.c_usecs && uframe >= 6)\t \n\t\tgoto done;\n\n\tif (!check_period(ehci, frame, uframe, qh->ps.bw_uperiod, qh->ps.usecs))\n\t\tgoto done;\n\tif (!qh->ps.c_usecs) {\n\t\tretval = 0;\n\t\t*c_maskp = 0;\n\t\tgoto done;\n\t}\n\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\n\tif (tt_available(ehci, &qh->ps, tt, frame, uframe)) {\n\t\tunsigned i;\n\n\t\t \n\t\tfor (i = uframe+2; i < 8 && i <= uframe+4; i++)\n\t\t\tif (!check_period(ehci, frame, i,\n\t\t\t\t\tqh->ps.bw_uperiod, qh->ps.c_usecs))\n\t\t\t\tgoto done;\n\t\t\telse\n\t\t\t\tmask |= 1 << i;\n\n\t\tretval = 0;\n\n\t\t*c_maskp = mask;\n\t}\n#else\n\t \n\tmask = 0x03 << (uframe + qh->gap_uf);\n\t*c_maskp = mask;\n\n\tmask |= 1 << uframe;\n\tif (tt_no_collision(ehci, qh->ps.bw_period, qh->ps.udev, frame, mask)) {\n\t\tif (!check_period(ehci, frame, uframe + qh->gap_uf + 1,\n\t\t\t\tqh->ps.bw_uperiod, qh->ps.c_usecs))\n\t\t\tgoto done;\n\t\tif (!check_period(ehci, frame, uframe + qh->gap_uf,\n\t\t\t\tqh->ps.bw_uperiod, qh->ps.c_usecs))\n\t\t\tgoto done;\n\t\tretval = 0;\n\t}\n#endif\ndone:\n\treturn retval;\n}\n\n \nstatic int qh_schedule(struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tint\t\tstatus = 0;\n\tunsigned\tuframe;\n\tunsigned\tc_mask;\n\tstruct ehci_qh_hw\t*hw = qh->hw;\n\tstruct ehci_tt\t\t*tt;\n\n\thw->hw_next = EHCI_LIST_END(ehci);\n\n\t \n\tif (qh->ps.phase != NO_FRAME) {\n\t\tehci_dbg(ehci, \"reused qh %p schedule\\n\", qh);\n\t\treturn 0;\n\t}\n\n\tuframe = 0;\n\tc_mask = 0;\n\ttt = find_tt(qh->ps.udev);\n\tif (IS_ERR(tt)) {\n\t\tstatus = PTR_ERR(tt);\n\t\tgoto done;\n\t}\n\tcompute_tt_budget(ehci->tt_budget, tt);\n\n\t \n\t \n\tif (qh->ps.bw_period) {\n\t\tint\t\ti;\n\t\tunsigned\tframe;\n\n\t\tfor (i = qh->ps.bw_period; i > 0; --i) {\n\t\t\tframe = ++ehci->random_frame & (qh->ps.bw_period - 1);\n\t\t\tfor (uframe = 0; uframe < 8; uframe++) {\n\t\t\t\tstatus = check_intr_schedule(ehci,\n\t\t\t\t\t\tframe, uframe, qh, &c_mask, tt);\n\t\t\t\tif (status == 0)\n\t\t\t\t\tgoto got_it;\n\t\t\t}\n\t\t}\n\n\t \n\t} else {\n\t\tstatus = check_intr_schedule(ehci, 0, 0, qh, &c_mask, tt);\n\t}\n\tif (status)\n\t\tgoto done;\n\n got_it:\n\tqh->ps.phase = (qh->ps.period ? ehci->random_frame &\n\t\t\t(qh->ps.period - 1) : 0);\n\tqh->ps.bw_phase = qh->ps.phase & (qh->ps.bw_period - 1);\n\tqh->ps.phase_uf = uframe;\n\tqh->ps.cs_mask = qh->ps.period ?\n\t\t\t(c_mask << 8) | (1 << uframe) :\n\t\t\tQH_SMASK;\n\n\t \n\thw->hw_info2 &= cpu_to_hc32(ehci, ~(QH_CMASK | QH_SMASK));\n\thw->hw_info2 |= cpu_to_hc32(ehci, qh->ps.cs_mask);\n\treserve_release_intr_bandwidth(ehci, qh, 1);\n\ndone:\n\treturn status;\n}\n\nstatic int intr_submit(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct list_head\t*qtd_list,\n\tgfp_t\t\t\tmem_flags\n) {\n\tunsigned\t\tepnum;\n\tunsigned long\t\tflags;\n\tstruct ehci_qh\t\t*qh;\n\tint\t\t\tstatus;\n\tstruct list_head\tempty;\n\n\t \n\tepnum = urb->ep->desc.bEndpointAddress;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done_not_linked;\n\t}\n\tstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\n\tif (unlikely(status))\n\t\tgoto done_not_linked;\n\n\t \n\tINIT_LIST_HEAD(&empty);\n\tqh = qh_append_tds(ehci, urb, &empty, epnum, &urb->ep->hcpriv);\n\tif (qh == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto done;\n\t}\n\tif (qh->qh_state == QH_STATE_IDLE) {\n\t\tstatus = qh_schedule(ehci, qh);\n\t\tif (status)\n\t\t\tgoto done;\n\t}\n\n\t \n\tqh = qh_append_tds(ehci, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tBUG_ON(qh == NULL);\n\n\t \n\tif (qh->qh_state == QH_STATE_IDLE) {\n\t\tqh_refresh(ehci, qh);\n\t\tqh_link_periodic(ehci, qh);\n\t} else {\n\t\t \n\t\tcancel_unlink_wait_intr(ehci, qh);\n\t}\n\n\t \n\tehci_to_hcd(ehci)->self.bandwidth_int_reqs++;\n\ndone:\n\tif (unlikely(status))\n\t\tusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\ndone_not_linked:\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\tif (status)\n\t\tqtd_list_free(ehci, urb, qtd_list);\n\n\treturn status;\n}\n\nstatic void scan_intr(struct ehci_hcd *ehci)\n{\n\tstruct ehci_qh\t\t*qh;\n\n\tlist_for_each_entry_safe(qh, ehci->qh_scan_next, &ehci->intr_qh_list,\n\t\t\tintr_node) {\n\n\t\t \n\t\tif (!list_empty(&qh->qtd_list)) {\n\t\t\tint temp;\n\n\t\t\t \n\t\t\ttemp = qh_completions(ehci, qh);\n\t\t\tif (unlikely(temp))\n\t\t\t\tstart_unlink_intr(ehci, qh);\n\t\t\telse if (unlikely(list_empty(&qh->qtd_list) &&\n\t\t\t\t\tqh->qh_state == QH_STATE_LINKED))\n\t\t\t\tstart_unlink_intr_wait(ehci, qh);\n\t\t}\n\t}\n}\n\n \n\n \n\nstatic struct ehci_iso_stream *\niso_stream_alloc(gfp_t mem_flags)\n{\n\tstruct ehci_iso_stream *stream;\n\n\tstream = kzalloc(sizeof(*stream), mem_flags);\n\tif (likely(stream != NULL)) {\n\t\tINIT_LIST_HEAD(&stream->td_list);\n\t\tINIT_LIST_HEAD(&stream->free_list);\n\t\tstream->next_uframe = NO_FRAME;\n\t\tstream->ps.phase = NO_FRAME;\n\t}\n\treturn stream;\n}\n\nstatic void\niso_stream_init(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_stream\t*stream,\n\tstruct urb\t\t*urb\n)\n{\n\tstatic const u8 smask_out[] = { 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f };\n\n\tstruct usb_device\t*dev = urb->dev;\n\tu32\t\t\tbuf1;\n\tunsigned\t\tepnum, maxp;\n\tint\t\t\tis_input;\n\tunsigned\t\ttmp;\n\n\t \n\tepnum = usb_pipeendpoint(urb->pipe);\n\tis_input = usb_pipein(urb->pipe) ? USB_DIR_IN : 0;\n\tmaxp = usb_endpoint_maxp(&urb->ep->desc);\n\tbuf1 = is_input ? 1 << 11 : 0;\n\n\t \n\tif (dev->speed == USB_SPEED_HIGH) {\n\t\tunsigned multi = usb_endpoint_maxp_mult(&urb->ep->desc);\n\n\t\tstream->highspeed = 1;\n\n\t\tbuf1 |= maxp;\n\t\tmaxp *= multi;\n\n\t\tstream->buf0 = cpu_to_hc32(ehci, (epnum << 8) | dev->devnum);\n\t\tstream->buf1 = cpu_to_hc32(ehci, buf1);\n\t\tstream->buf2 = cpu_to_hc32(ehci, multi);\n\n\t\t \n\t\tstream->ps.usecs = HS_USECS_ISO(maxp);\n\n\t\t \n\t\ttmp = min_t(unsigned, EHCI_BANDWIDTH_SIZE,\n\t\t\t\t1 << (urb->ep->desc.bInterval - 1));\n\n\t\t \n\t\tstream->ps.bw_uperiod = min_t(unsigned, tmp, urb->interval);\n\n\t\tstream->uperiod = urb->interval;\n\t\tstream->ps.period = urb->interval >> 3;\n\t\tstream->bandwidth = stream->ps.usecs * 8 /\n\t\t\t\tstream->ps.bw_uperiod;\n\n\t} else {\n\t\tu32\t\taddr;\n\t\tint\t\tthink_time;\n\t\tint\t\ths_transfers;\n\n\t\taddr = dev->ttport << 24;\n\t\tif (!ehci_is_TDI(ehci)\n\t\t\t\t|| (dev->tt->hub !=\n\t\t\t\t\tehci_to_hcd(ehci)->self.root_hub))\n\t\t\taddr |= dev->tt->hub->devnum << 16;\n\t\taddr |= epnum << 8;\n\t\taddr |= dev->devnum;\n\t\tstream->ps.usecs = HS_USECS_ISO(maxp);\n\t\tthink_time = dev->tt->think_time;\n\t\tstream->ps.tt_usecs = NS_TO_US(think_time + usb_calc_bus_time(\n\t\t\t\tdev->speed, is_input, 1, maxp));\n\t\ths_transfers = max(1u, (maxp + 187) / 188);\n\t\tif (is_input) {\n\t\t\tu32\ttmp;\n\n\t\t\taddr |= 1 << 31;\n\t\t\tstream->ps.c_usecs = stream->ps.usecs;\n\t\t\tstream->ps.usecs = HS_USECS_ISO(1);\n\t\t\tstream->ps.cs_mask = 1;\n\n\t\t\t \n\t\t\ttmp = (1 << (hs_transfers + 2)) - 1;\n\t\t\tstream->ps.cs_mask |= tmp << (8 + 2);\n\t\t} else\n\t\t\tstream->ps.cs_mask = smask_out[hs_transfers - 1];\n\n\t\t \n\t\ttmp = min_t(unsigned, EHCI_BANDWIDTH_FRAMES,\n\t\t\t\t1 << (urb->ep->desc.bInterval - 1));\n\n\t\t \n\t\tstream->ps.bw_period = min_t(unsigned, tmp, urb->interval);\n\t\tstream->ps.bw_uperiod = stream->ps.bw_period << 3;\n\n\t\tstream->ps.period = urb->interval;\n\t\tstream->uperiod = urb->interval << 3;\n\t\tstream->bandwidth = (stream->ps.usecs + stream->ps.c_usecs) /\n\t\t\t\tstream->ps.bw_period;\n\n\t\t \n\t\tstream->address = cpu_to_hc32(ehci, addr);\n\t}\n\n\tstream->ps.udev = dev;\n\tstream->ps.ep = urb->ep;\n\n\tstream->bEndpointAddress = is_input | epnum;\n\tstream->maxp = maxp;\n}\n\nstatic struct ehci_iso_stream *\niso_stream_find(struct ehci_hcd *ehci, struct urb *urb)\n{\n\tunsigned\t\tepnum;\n\tstruct ehci_iso_stream\t*stream;\n\tstruct usb_host_endpoint *ep;\n\tunsigned long\t\tflags;\n\n\tepnum = usb_pipeendpoint (urb->pipe);\n\tif (usb_pipein(urb->pipe))\n\t\tep = urb->dev->ep_in[epnum];\n\telse\n\t\tep = urb->dev->ep_out[epnum];\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\tstream = ep->hcpriv;\n\n\tif (unlikely(stream == NULL)) {\n\t\tstream = iso_stream_alloc(GFP_ATOMIC);\n\t\tif (likely(stream != NULL)) {\n\t\t\tep->hcpriv = stream;\n\t\t\tiso_stream_init(ehci, stream, urb);\n\t\t}\n\n\t \n\t} else if (unlikely(stream->hw != NULL)) {\n\t\tehci_dbg(ehci, \"dev %s ep%d%s, not iso??\\n\",\n\t\t\turb->dev->devpath, epnum,\n\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\");\n\t\tstream = NULL;\n\t}\n\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\treturn stream;\n}\n\n \n\n \n\nstatic struct ehci_iso_sched *\niso_sched_alloc(unsigned packets, gfp_t mem_flags)\n{\n\tstruct ehci_iso_sched\t*iso_sched;\n\n\tiso_sched = kzalloc(struct_size(iso_sched, packet, packets), mem_flags);\n\tif (likely(iso_sched != NULL))\n\t\tINIT_LIST_HEAD(&iso_sched->td_list);\n\n\treturn iso_sched;\n}\n\nstatic inline void\nitd_sched_init(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_sched\t*iso_sched,\n\tstruct ehci_iso_stream\t*stream,\n\tstruct urb\t\t*urb\n)\n{\n\tunsigned\ti;\n\tdma_addr_t\tdma = urb->transfer_dma;\n\n\t \n\tiso_sched->span = urb->number_of_packets * stream->uperiod;\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tstruct ehci_iso_packet\t*uframe = &iso_sched->packet[i];\n\t\tunsigned\t\tlength;\n\t\tdma_addr_t\t\tbuf;\n\t\tu32\t\t\ttrans;\n\n\t\tlength = urb->iso_frame_desc[i].length;\n\t\tbuf = dma + urb->iso_frame_desc[i].offset;\n\n\t\ttrans = EHCI_ISOC_ACTIVE;\n\t\ttrans |= buf & 0x0fff;\n\t\tif (unlikely(((i + 1) == urb->number_of_packets))\n\t\t\t\t&& !(urb->transfer_flags & URB_NO_INTERRUPT))\n\t\t\ttrans |= EHCI_ITD_IOC;\n\t\ttrans |= length << 16;\n\t\tuframe->transaction = cpu_to_hc32(ehci, trans);\n\n\t\t \n\t\tuframe->bufp = (buf & ~(u64)0x0fff);\n\t\tbuf += length;\n\t\tif (unlikely((uframe->bufp != (buf & ~(u64)0x0fff))))\n\t\t\tuframe->cross = 1;\n\t}\n}\n\nstatic void\niso_sched_free(\n\tstruct ehci_iso_stream\t*stream,\n\tstruct ehci_iso_sched\t*iso_sched\n)\n{\n\tif (!iso_sched)\n\t\treturn;\n\t \n\tlist_splice(&iso_sched->td_list, &stream->free_list);\n\tkfree(iso_sched);\n}\n\nstatic int\nitd_urb_transaction(\n\tstruct ehci_iso_stream\t*stream,\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tgfp_t\t\t\tmem_flags\n)\n{\n\tstruct ehci_itd\t\t*itd;\n\tdma_addr_t\t\titd_dma;\n\tint\t\t\ti;\n\tunsigned\t\tnum_itds;\n\tstruct ehci_iso_sched\t*sched;\n\tunsigned long\t\tflags;\n\n\tsched = iso_sched_alloc(urb->number_of_packets, mem_flags);\n\tif (unlikely(sched == NULL))\n\t\treturn -ENOMEM;\n\n\titd_sched_init(ehci, sched, stream, urb);\n\n\tif (urb->interval < 8)\n\t\tnum_itds = 1 + (sched->span + 7) / 8;\n\telse\n\t\tnum_itds = urb->number_of_packets;\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tfor (i = 0; i < num_itds; i++) {\n\n\t\t \n\t\tif (likely(!list_empty(&stream->free_list))) {\n\t\t\titd = list_first_entry(&stream->free_list,\n\t\t\t\t\tstruct ehci_itd, itd_list);\n\t\t\tif (itd->frame == ehci->now_frame)\n\t\t\t\tgoto alloc_itd;\n\t\t\tlist_del(&itd->itd_list);\n\t\t\titd_dma = itd->itd_dma;\n\t\t} else {\n alloc_itd:\n\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\titd = dma_pool_alloc(ehci->itd_pool, mem_flags,\n\t\t\t\t\t&itd_dma);\n\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\tif (!itd) {\n\t\t\t\tiso_sched_free(stream, sched);\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tmemset(itd, 0, sizeof(*itd));\n\t\titd->itd_dma = itd_dma;\n\t\titd->frame = NO_FRAME;\n\t\tlist_add(&itd->itd_list, &sched->td_list);\n\t}\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\n\t \n\turb->hcpriv = sched;\n\turb->error_count = 0;\n\treturn 0;\n}\n\n \n\nstatic void reserve_release_iso_bandwidth(struct ehci_hcd *ehci,\n\t\tstruct ehci_iso_stream *stream, int sign)\n{\n\tunsigned\t\tuframe;\n\tunsigned\t\ti, j;\n\tunsigned\t\ts_mask, c_mask, m;\n\tint\t\t\tusecs = stream->ps.usecs;\n\tint\t\t\tc_usecs = stream->ps.c_usecs;\n\tint\t\t\ttt_usecs = stream->ps.tt_usecs;\n\tstruct ehci_tt\t\t*tt;\n\n\tif (stream->ps.phase == NO_FRAME)\t \n\t\treturn;\n\tuframe = stream->ps.bw_phase << 3;\n\n\tbandwidth_dbg(ehci, sign, \"iso\", &stream->ps);\n\n\tif (sign < 0) {\t\t \n\t\tusecs = -usecs;\n\t\tc_usecs = -c_usecs;\n\t\ttt_usecs = -tt_usecs;\n\t}\n\n\tif (!stream->splits) {\t\t \n\t\tfor (i = uframe + stream->ps.phase_uf; i < EHCI_BANDWIDTH_SIZE;\n\t\t\t\ti += stream->ps.bw_uperiod)\n\t\t\tehci->bandwidth[i] += usecs;\n\n\t} else {\t\t\t \n\t\ts_mask = stream->ps.cs_mask;\n\t\tc_mask = s_mask >> 8;\n\n\t\t \n\t\tfor (i = uframe; i < EHCI_BANDWIDTH_SIZE;\n\t\t\t\ti += stream->ps.bw_uperiod) {\n\t\t\tfor ((j = stream->ps.phase_uf, m = 1 << j); j < 8;\n\t\t\t\t\t(++j, m <<= 1)) {\n\t\t\t\tif (s_mask & m)\n\t\t\t\t\tehci->bandwidth[i+j] += usecs;\n\t\t\t\telse if (c_mask & m)\n\t\t\t\t\tehci->bandwidth[i+j] += c_usecs;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttt = find_tt(stream->ps.udev);\n\t\tif (sign > 0)\n\t\t\tlist_add_tail(&stream->ps.ps_list, &tt->ps_list);\n\t\telse\n\t\t\tlist_del(&stream->ps.ps_list);\n\n\t\tfor (i = uframe >> 3; i < EHCI_BANDWIDTH_FRAMES;\n\t\t\t\ti += stream->ps.bw_period)\n\t\t\ttt->bandwidth[i] += tt_usecs;\n\t}\n}\n\nstatic inline int\nitd_slot_ok(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_stream\t*stream,\n\tunsigned\t\tuframe\n)\n{\n\tunsigned\t\tusecs;\n\n\t \n\tusecs = ehci->uframe_periodic_max - stream->ps.usecs;\n\n\tfor (uframe &= stream->ps.bw_uperiod - 1; uframe < EHCI_BANDWIDTH_SIZE;\n\t\t\tuframe += stream->ps.bw_uperiod) {\n\t\tif (ehci->bandwidth[uframe] > usecs)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic inline int\nsitd_slot_ok(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_stream\t*stream,\n\tunsigned\t\tuframe,\n\tstruct ehci_iso_sched\t*sched,\n\tstruct ehci_tt\t\t*tt\n)\n{\n\tunsigned\t\tmask, tmp;\n\tunsigned\t\tframe, uf;\n\n\tmask = stream->ps.cs_mask << (uframe & 7);\n\n\t \n\tif (((stream->ps.cs_mask & 0xff) << (uframe & 7)) >= (1 << 7))\n\t\treturn 0;\n\n\t \n\tif (mask & ~0xffff)\n\t\treturn 0;\n\n\t \n\tuframe &= stream->ps.bw_uperiod - 1;\n\tframe = uframe >> 3;\n\n#ifdef CONFIG_USB_EHCI_TT_NEWSCHED\n\t \n\tuf = uframe & 7;\n\tif (!tt_available(ehci, &stream->ps, tt, frame, uf))\n\t\treturn 0;\n#else\n\t \n\tif (!tt_no_collision(ehci, stream->ps.bw_period,\n\t\t\tstream->ps.udev, frame, mask))\n\t\treturn 0;\n#endif\n\n\tdo {\n\t\tunsigned\tmax_used;\n\t\tunsigned\ti;\n\n\t\t \n\t\tuf = uframe;\n\t\tmax_used = ehci->uframe_periodic_max - stream->ps.usecs;\n\t\tfor (tmp = stream->ps.cs_mask & 0xff; tmp; tmp >>= 1, uf++) {\n\t\t\tif (ehci->bandwidth[uf] > max_used)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (stream->ps.c_usecs) {\n\t\t\tmax_used = ehci->uframe_periodic_max -\n\t\t\t\t\tstream->ps.c_usecs;\n\t\t\tuf = uframe & ~7;\n\t\t\ttmp = 1 << (2+8);\n\t\t\tfor (i = (uframe & 7) + 2; i < 8; (++i, tmp <<= 1)) {\n\t\t\t\tif ((stream->ps.cs_mask & tmp) == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ehci->bandwidth[uf+i] > max_used)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\tuframe += stream->ps.bw_uperiod;\n\t} while (uframe < EHCI_BANDWIDTH_SIZE);\n\n\tstream->ps.cs_mask <<= uframe & 7;\n\tstream->splits = cpu_to_hc32(ehci, stream->ps.cs_mask);\n\treturn 1;\n}\n\n \n\nstatic int\niso_stream_schedule(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tstruct ehci_iso_stream\t*stream\n)\n{\n\tu32\t\t\tnow, base, next, start, period, span, now2;\n\tu32\t\t\twrap = 0, skip = 0;\n\tint\t\t\tstatus = 0;\n\tunsigned\t\tmod = ehci->periodic_size << 3;\n\tstruct ehci_iso_sched\t*sched = urb->hcpriv;\n\tbool\t\t\tempty = list_empty(&stream->td_list);\n\tbool\t\t\tnew_stream = false;\n\n\tperiod = stream->uperiod;\n\tspan = sched->span;\n\tif (!stream->highspeed)\n\t\tspan <<= 3;\n\n\t \n\tif (unlikely(empty && !hcd_periodic_completion_in_progress(\n\t\t\tehci_to_hcd(ehci), urb->ep))) {\n\n\t\t \n\t\tif (stream->ps.phase == NO_FRAME) {\n\t\t\tint\t\tdone = 0;\n\t\t\tstruct ehci_tt\t*tt = find_tt(stream->ps.udev);\n\n\t\t\tif (IS_ERR(tt)) {\n\t\t\t\tstatus = PTR_ERR(tt);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tcompute_tt_budget(ehci->tt_budget, tt);\n\n\t\t\tstart = ((-(++ehci->random_frame)) << 3) & (period - 1);\n\n\t\t\t \n\t\t\tnext = start;\n\t\t\tstart += period;\n\t\t\tdo {\n\t\t\t\tstart--;\n\t\t\t\t \n\t\t\t\tif (stream->highspeed) {\n\t\t\t\t\tif (itd_slot_ok(ehci, stream, start))\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t} else {\n\t\t\t\t\tif ((start % 8) >= 6)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (sitd_slot_ok(ehci, stream, start,\n\t\t\t\t\t\t\tsched, tt))\n\t\t\t\t\t\tdone = 1;\n\t\t\t\t}\n\t\t\t} while (start > next && !done);\n\n\t\t\t \n\t\t\tif (!done) {\n\t\t\t\tehci_dbg(ehci, \"iso sched full %p\", urb);\n\t\t\t\tstatus = -ENOSPC;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tstream->ps.phase = (start >> 3) &\n\t\t\t\t\t(stream->ps.period - 1);\n\t\t\tstream->ps.bw_phase = stream->ps.phase &\n\t\t\t\t\t(stream->ps.bw_period - 1);\n\t\t\tstream->ps.phase_uf = start & 7;\n\t\t\treserve_release_iso_bandwidth(ehci, stream, 1);\n\t\t}\n\n\t\t \n\t\telse {\n\t\t\tstart = (stream->ps.phase << 3) + stream->ps.phase_uf;\n\t\t}\n\n\t\tstream->next_uframe = start;\n\t\tnew_stream = true;\n\t}\n\n\tnow = ehci_read_frame_index(ehci) & (mod - 1);\n\n\t \n\tif (ehci->i_thresh)\n\t\tnext = now + ehci->i_thresh;\t \n\telse\n\t\tnext = (now + 2 + 7) & ~0x07;\t \n\n\t \n\tif (ehci->isoc_count == 0)\n\t\tehci->last_iso_frame = now >> 3;\n\n\t \n\tbase = ehci->last_iso_frame << 3;\n\tnext = (next - base) & (mod - 1);\n\tstart = (stream->next_uframe - base) & (mod - 1);\n\n\tif (unlikely(new_stream))\n\t\tgoto do_ASAP;\n\n\t \n\tnow2 = (now - base) & (mod - 1);\n\n\t \n\tif (unlikely(!empty && start < period)) {\n\t\tehci_dbg(ehci, \"request %p would overflow (%u-%u < %u mod %u)\\n\",\n\t\t\t\turb, stream->next_uframe, base, period, mod);\n\t\tstatus = -EFBIG;\n\t\tgoto fail;\n\t}\n\n\t \n\tif (likely(!empty || start <= now2 + period)) {\n\n\t\t \n\t\tif (unlikely(start < next &&\n\t\t\t\t(urb->transfer_flags & URB_ISO_ASAP)))\n\t\t\tgoto do_ASAP;\n\n\t\t \n\t\tif (likely(start >= now2))\n\t\t\tgoto use_start;\n\n\t \n\t} else {\n\t\tif (urb->transfer_flags & URB_ISO_ASAP)\n\t\t\tgoto do_ASAP;\n\t\twrap = mod;\n\t\tnow2 += mod;\n\t}\n\n\t \n\tskip = (now2 - start + period - 1) & -period;\n\tif (skip >= span) {\t\t \n\t\tehci_dbg(ehci, \"iso underrun %p (%u+%u < %u) [%u]\\n\",\n\t\t\t\turb, start + base, span - period, now2 + base,\n\t\t\t\tbase);\n\n\t\t \n\t\tskip = span - period;\n\n\t\t \n\t\tif (empty) {\n\t\t\tskip = span;\t \n\t\t\tstatus = 1;\t \n\t\t\tiso_sched_free(stream, sched);\n\t\t\tsched = NULL;\n\t\t}\n\t}\n\turb->error_count = skip / period;\n\tif (sched)\n\t\tsched->first_packet = urb->error_count;\n\tgoto use_start;\n\n do_ASAP:\n\t \n\tstart = next + ((start - next) & (period - 1));\n\n use_start:\n\t \n\tif (unlikely(start + span - period >= mod + wrap)) {\n\t\tehci_dbg(ehci, \"request %p would overflow (%u+%u >= %u)\\n\",\n\t\t\t\turb, start, span - period, mod + wrap);\n\t\tstatus = -EFBIG;\n\t\tgoto fail;\n\t}\n\n\tstart += base;\n\tstream->next_uframe = (start + skip) & (mod - 1);\n\n\t \n\turb->start_frame = start & (mod - 1);\n\tif (!stream->highspeed)\n\t\turb->start_frame >>= 3;\n\treturn status;\n\n fail:\n\tiso_sched_free(stream, sched);\n\turb->hcpriv = NULL;\n\treturn status;\n}\n\n \n\nstatic inline void\nitd_init(struct ehci_hcd *ehci, struct ehci_iso_stream *stream,\n\t\tstruct ehci_itd *itd)\n{\n\tint i;\n\n\t \n\titd->hw_next = EHCI_LIST_END(ehci);\n\titd->hw_bufp[0] = stream->buf0;\n\titd->hw_bufp[1] = stream->buf1;\n\titd->hw_bufp[2] = stream->buf2;\n\n\tfor (i = 0; i < 8; i++)\n\t\titd->index[i] = -1;\n\n\t \n}\n\nstatic inline void\nitd_patch(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_itd\t\t*itd,\n\tstruct ehci_iso_sched\t*iso_sched,\n\tunsigned\t\tindex,\n\tu16\t\t\tuframe\n)\n{\n\tstruct ehci_iso_packet\t*uf = &iso_sched->packet[index];\n\tunsigned\t\tpg = itd->pg;\n\n\t \n\n\tuframe &= 0x07;\n\titd->index[uframe] = index;\n\n\titd->hw_transaction[uframe] = uf->transaction;\n\titd->hw_transaction[uframe] |= cpu_to_hc32(ehci, pg << 12);\n\titd->hw_bufp[pg] |= cpu_to_hc32(ehci, uf->bufp & ~(u32)0);\n\titd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(uf->bufp >> 32));\n\n\t \n\tif (unlikely(uf->cross)) {\n\t\tu64\tbufp = uf->bufp + 4096;\n\n\t\titd->pg = ++pg;\n\t\titd->hw_bufp[pg] |= cpu_to_hc32(ehci, bufp & ~(u32)0);\n\t\titd->hw_bufp_hi[pg] |= cpu_to_hc32(ehci, (u32)(bufp >> 32));\n\t}\n}\n\nstatic inline void\nitd_link(struct ehci_hcd *ehci, unsigned frame, struct ehci_itd *itd)\n{\n\tunion ehci_shadow\t*prev = &ehci->pshadow[frame];\n\t__hc32\t\t\t*hw_p = &ehci->periodic[frame];\n\tunion ehci_shadow\there = *prev;\n\t__hc32\t\t\ttype = 0;\n\n\t \n\twhile (here.ptr) {\n\t\ttype = Q_NEXT_TYPE(ehci, *hw_p);\n\t\tif (type == cpu_to_hc32(ehci, Q_TYPE_QH))\n\t\t\tbreak;\n\t\tprev = periodic_next_shadow(ehci, prev, type);\n\t\thw_p = shadow_next_periodic(ehci, &here, type);\n\t\there = *prev;\n\t}\n\n\titd->itd_next = here;\n\titd->hw_next = *hw_p;\n\tprev->itd = itd;\n\titd->frame = frame;\n\twmb();\n\t*hw_p = cpu_to_hc32(ehci, itd->itd_dma | Q_TYPE_ITD);\n}\n\n \nstatic void itd_link_urb(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tunsigned\t\tmod,\n\tstruct ehci_iso_stream\t*stream\n)\n{\n\tint\t\t\tpacket;\n\tunsigned\t\tnext_uframe, uframe, frame;\n\tstruct ehci_iso_sched\t*iso_sched = urb->hcpriv;\n\tstruct ehci_itd\t\t*itd;\n\n\tnext_uframe = stream->next_uframe & (mod - 1);\n\n\tif (unlikely(list_empty(&stream->td_list)))\n\t\tehci_to_hcd(ehci)->self.bandwidth_allocated\n\t\t\t\t+= stream->bandwidth;\n\n\tif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\n\t\tif (ehci->amd_pll_fix == 1)\n\t\t\tusb_amd_quirk_pll_disable();\n\t}\n\n\tehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\n\n\t \n\tfor (packet = iso_sched->first_packet, itd = NULL;\n\t\t\tpacket < urb->number_of_packets;) {\n\t\tif (itd == NULL) {\n\t\t\t \n\t\t\t \n\n\t\t\t \n\n\t\t\titd = list_entry(iso_sched->td_list.next,\n\t\t\t\t\tstruct ehci_itd, itd_list);\n\t\t\tlist_move_tail(&itd->itd_list, &stream->td_list);\n\t\t\titd->stream = stream;\n\t\t\titd->urb = urb;\n\t\t\titd_init(ehci, stream, itd);\n\t\t}\n\n\t\tuframe = next_uframe & 0x07;\n\t\tframe = next_uframe >> 3;\n\n\t\titd_patch(ehci, itd, iso_sched, packet, uframe);\n\n\t\tnext_uframe += stream->uperiod;\n\t\tnext_uframe &= mod - 1;\n\t\tpacket++;\n\n\t\t \n\t\tif (((next_uframe >> 3) != frame)\n\t\t\t\t|| packet == urb->number_of_packets) {\n\t\t\titd_link(ehci, frame & (ehci->periodic_size - 1), itd);\n\t\t\titd = NULL;\n\t\t}\n\t}\n\tstream->next_uframe = next_uframe;\n\n\t \n\tiso_sched_free(stream, iso_sched);\n\turb->hcpriv = stream;\n\n\t++ehci->isoc_count;\n\tenable_periodic(ehci);\n}\n\n#define\tISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)\n\n \nstatic bool itd_complete(struct ehci_hcd *ehci, struct ehci_itd *itd)\n{\n\tstruct urb\t\t\t\t*urb = itd->urb;\n\tstruct usb_iso_packet_descriptor\t*desc;\n\tu32\t\t\t\t\tt;\n\tunsigned\t\t\t\tuframe;\n\tint\t\t\t\t\turb_index = -1;\n\tstruct ehci_iso_stream\t\t\t*stream = itd->stream;\n\tbool\t\t\t\t\tretval = false;\n\n\t \n\tfor (uframe = 0; uframe < 8; uframe++) {\n\t\tif (likely(itd->index[uframe] == -1))\n\t\t\tcontinue;\n\t\turb_index = itd->index[uframe];\n\t\tdesc = &urb->iso_frame_desc[urb_index];\n\n\t\tt = hc32_to_cpup(ehci, &itd->hw_transaction[uframe]);\n\t\titd->hw_transaction[uframe] = 0;\n\n\t\t \n\t\tif (unlikely(t & ISO_ERRS)) {\n\t\t\turb->error_count++;\n\t\t\tif (t & EHCI_ISOC_BUF_ERR)\n\t\t\t\tdesc->status = usb_pipein(urb->pipe)\n\t\t\t\t\t? -ENOSR   \n\t\t\t\t\t: -ECOMM;  \n\t\t\telse if (t & EHCI_ISOC_BABBLE)\n\t\t\t\tdesc->status = -EOVERFLOW;\n\t\t\telse  \n\t\t\t\tdesc->status = -EPROTO;\n\n\t\t\t \n\t\t\tif (!(t & EHCI_ISOC_BABBLE)) {\n\t\t\t\tdesc->actual_length = EHCI_ITD_LENGTH(t);\n\t\t\t\turb->actual_length += desc->actual_length;\n\t\t\t}\n\t\t} else if (likely((t & EHCI_ISOC_ACTIVE) == 0)) {\n\t\t\tdesc->status = 0;\n\t\t\tdesc->actual_length = EHCI_ITD_LENGTH(t);\n\t\t\turb->actual_length += desc->actual_length;\n\t\t} else {\n\t\t\t \n\t\t\turb->error_count++;\n\t\t}\n\t}\n\n\t \n\tif (likely((urb_index + 1) != urb->number_of_packets))\n\t\tgoto done;\n\n\t \n\n\t \n\tehci_urb_done(ehci, urb, 0);\n\tretval = true;\n\turb = NULL;\n\n\t--ehci->isoc_count;\n\tdisable_periodic(ehci);\n\n\tehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\n\tif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\n\t\tif (ehci->amd_pll_fix == 1)\n\t\t\tusb_amd_quirk_pll_enable();\n\t}\n\n\tif (unlikely(list_is_singular(&stream->td_list)))\n\t\tehci_to_hcd(ehci)->self.bandwidth_allocated\n\t\t\t\t-= stream->bandwidth;\n\ndone:\n\titd->urb = NULL;\n\n\t \n\tlist_move_tail(&itd->itd_list, &stream->free_list);\n\n\t \n\tif (list_empty(&stream->td_list)) {\n\t\tlist_splice_tail_init(&stream->free_list,\n\t\t\t\t&ehci->cached_itd_list);\n\t\tstart_free_itds(ehci);\n\t}\n\n\treturn retval;\n}\n\n \n\nstatic int itd_submit(struct ehci_hcd *ehci, struct urb *urb,\n\tgfp_t mem_flags)\n{\n\tint\t\t\tstatus = -EINVAL;\n\tunsigned long\t\tflags;\n\tstruct ehci_iso_stream\t*stream;\n\n\t \n\tstream = iso_stream_find(ehci, urb);\n\tif (unlikely(stream == NULL)) {\n\t\tehci_dbg(ehci, \"can't get iso stream\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (unlikely(urb->interval != stream->uperiod)) {\n\t\tehci_dbg(ehci, \"can't change iso interval %d --> %d\\n\",\n\t\t\tstream->uperiod, urb->interval);\n\t\tgoto done;\n\t}\n\n#ifdef EHCI_URB_TRACE\n\tehci_dbg(ehci,\n\t\t\"%s %s urb %p ep%d%s len %d, %d pkts %d uframes [%p]\\n\",\n\t\t__func__, urb->dev->devpath, urb,\n\t\tusb_pipeendpoint(urb->pipe),\n\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\turb->transfer_buffer_length,\n\t\turb->number_of_packets, urb->interval,\n\t\tstream);\n#endif\n\n\t \n\tstatus = itd_urb_transaction(stream, ehci, urb, mem_flags);\n\tif (unlikely(status < 0)) {\n\t\tehci_dbg(ehci, \"can't init itds\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done_not_linked;\n\t}\n\tstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\n\tif (unlikely(status))\n\t\tgoto done_not_linked;\n\tstatus = iso_stream_schedule(ehci, urb, stream);\n\tif (likely(status == 0)) {\n\t\titd_link_urb(ehci, urb, ehci->periodic_size << 3, stream);\n\t} else if (status > 0) {\n\t\tstatus = 0;\n\t\tehci_urb_done(ehci, urb, 0);\n\t} else {\n\t\tusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\n\t}\n done_not_linked:\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n done:\n\treturn status;\n}\n\n \n\n \n\nstatic inline void\nsitd_sched_init(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_sched\t*iso_sched,\n\tstruct ehci_iso_stream\t*stream,\n\tstruct urb\t\t*urb\n)\n{\n\tunsigned\ti;\n\tdma_addr_t\tdma = urb->transfer_dma;\n\n\t \n\tiso_sched->span = urb->number_of_packets * stream->ps.period;\n\n\t \n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\tstruct ehci_iso_packet\t*packet = &iso_sched->packet[i];\n\t\tunsigned\t\tlength;\n\t\tdma_addr_t\t\tbuf;\n\t\tu32\t\t\ttrans;\n\n\t\tlength = urb->iso_frame_desc[i].length & 0x03ff;\n\t\tbuf = dma + urb->iso_frame_desc[i].offset;\n\n\t\ttrans = SITD_STS_ACTIVE;\n\t\tif (((i + 1) == urb->number_of_packets)\n\t\t\t\t&& !(urb->transfer_flags & URB_NO_INTERRUPT))\n\t\t\ttrans |= SITD_IOC;\n\t\ttrans |= length << 16;\n\t\tpacket->transaction = cpu_to_hc32(ehci, trans);\n\n\t\t \n\t\tpacket->bufp = buf;\n\t\tpacket->buf1 = (buf + length) & ~0x0fff;\n\t\tif (packet->buf1 != (buf & ~(u64)0x0fff))\n\t\t\tpacket->cross = 1;\n\n\t\t \n\t\tif (stream->bEndpointAddress & USB_DIR_IN)\n\t\t\tcontinue;\n\t\tlength = (length + 187) / 188;\n\t\tif (length > 1)  \n\t\t\tlength |= 1 << 3;\n\t\tpacket->buf1 |= length;\n\t}\n}\n\nstatic int\nsitd_urb_transaction(\n\tstruct ehci_iso_stream\t*stream,\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tgfp_t\t\t\tmem_flags\n)\n{\n\tstruct ehci_sitd\t*sitd;\n\tdma_addr_t\t\tsitd_dma;\n\tint\t\t\ti;\n\tstruct ehci_iso_sched\t*iso_sched;\n\tunsigned long\t\tflags;\n\n\tiso_sched = iso_sched_alloc(urb->number_of_packets, mem_flags);\n\tif (iso_sched == NULL)\n\t\treturn -ENOMEM;\n\n\tsitd_sched_init(ehci, iso_sched, stream, urb);\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\n\t\t \n\n\t\t \n\t\tif (likely(!list_empty(&stream->free_list))) {\n\t\t\tsitd = list_first_entry(&stream->free_list,\n\t\t\t\t\t struct ehci_sitd, sitd_list);\n\t\t\tif (sitd->frame == ehci->now_frame)\n\t\t\t\tgoto alloc_sitd;\n\t\t\tlist_del(&sitd->sitd_list);\n\t\t\tsitd_dma = sitd->sitd_dma;\n\t\t} else {\n alloc_sitd:\n\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\tsitd = dma_pool_alloc(ehci->sitd_pool, mem_flags,\n\t\t\t\t\t&sitd_dma);\n\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\tif (!sitd) {\n\t\t\t\tiso_sched_free(stream, iso_sched);\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\tmemset(sitd, 0, sizeof(*sitd));\n\t\tsitd->sitd_dma = sitd_dma;\n\t\tsitd->frame = NO_FRAME;\n\t\tlist_add(&sitd->sitd_list, &iso_sched->td_list);\n\t}\n\n\t \n\turb->hcpriv = iso_sched;\n\turb->error_count = 0;\n\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\treturn 0;\n}\n\n \n\nstatic inline void\nsitd_patch(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct ehci_iso_stream\t*stream,\n\tstruct ehci_sitd\t*sitd,\n\tstruct ehci_iso_sched\t*iso_sched,\n\tunsigned\t\tindex\n)\n{\n\tstruct ehci_iso_packet\t*uf = &iso_sched->packet[index];\n\tu64\t\t\tbufp;\n\n\tsitd->hw_next = EHCI_LIST_END(ehci);\n\tsitd->hw_fullspeed_ep = stream->address;\n\tsitd->hw_uframe = stream->splits;\n\tsitd->hw_results = uf->transaction;\n\tsitd->hw_backpointer = EHCI_LIST_END(ehci);\n\n\tbufp = uf->bufp;\n\tsitd->hw_buf[0] = cpu_to_hc32(ehci, bufp);\n\tsitd->hw_buf_hi[0] = cpu_to_hc32(ehci, bufp >> 32);\n\n\tsitd->hw_buf[1] = cpu_to_hc32(ehci, uf->buf1);\n\tif (uf->cross)\n\t\tbufp += 4096;\n\tsitd->hw_buf_hi[1] = cpu_to_hc32(ehci, bufp >> 32);\n\tsitd->index = index;\n}\n\nstatic inline void\nsitd_link(struct ehci_hcd *ehci, unsigned frame, struct ehci_sitd *sitd)\n{\n\t \n\tsitd->sitd_next = ehci->pshadow[frame];\n\tsitd->hw_next = ehci->periodic[frame];\n\tehci->pshadow[frame].sitd = sitd;\n\tsitd->frame = frame;\n\twmb();\n\tehci->periodic[frame] = cpu_to_hc32(ehci, sitd->sitd_dma | Q_TYPE_SITD);\n}\n\n \nstatic void sitd_link_urb(\n\tstruct ehci_hcd\t\t*ehci,\n\tstruct urb\t\t*urb,\n\tunsigned\t\tmod,\n\tstruct ehci_iso_stream\t*stream\n)\n{\n\tint\t\t\tpacket;\n\tunsigned\t\tnext_uframe;\n\tstruct ehci_iso_sched\t*sched = urb->hcpriv;\n\tstruct ehci_sitd\t*sitd;\n\n\tnext_uframe = stream->next_uframe;\n\n\tif (list_empty(&stream->td_list))\n\t\t \n\t\tehci_to_hcd(ehci)->self.bandwidth_allocated\n\t\t\t\t+= stream->bandwidth;\n\n\tif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\n\t\tif (ehci->amd_pll_fix == 1)\n\t\t\tusb_amd_quirk_pll_disable();\n\t}\n\n\tehci_to_hcd(ehci)->self.bandwidth_isoc_reqs++;\n\n\t \n\tfor (packet = sched->first_packet, sitd = NULL;\n\t\t\tpacket < urb->number_of_packets;\n\t\t\tpacket++) {\n\n\t\t \n\t\tBUG_ON(list_empty(&sched->td_list));\n\n\t\t \n\n\t\tsitd = list_entry(sched->td_list.next,\n\t\t\t\tstruct ehci_sitd, sitd_list);\n\t\tlist_move_tail(&sitd->sitd_list, &stream->td_list);\n\t\tsitd->stream = stream;\n\t\tsitd->urb = urb;\n\n\t\tsitd_patch(ehci, stream, sitd, sched, packet);\n\t\tsitd_link(ehci, (next_uframe >> 3) & (ehci->periodic_size - 1),\n\t\t\t\tsitd);\n\n\t\tnext_uframe += stream->uperiod;\n\t}\n\tstream->next_uframe = next_uframe & (mod - 1);\n\n\t \n\tiso_sched_free(stream, sched);\n\turb->hcpriv = stream;\n\n\t++ehci->isoc_count;\n\tenable_periodic(ehci);\n}\n\n \n\n#define\tSITD_ERRS (SITD_STS_ERR | SITD_STS_DBE | SITD_STS_BABBLE \\\n\t\t\t\t| SITD_STS_XACT | SITD_STS_MMF)\n\n \nstatic bool sitd_complete(struct ehci_hcd *ehci, struct ehci_sitd *sitd)\n{\n\tstruct urb\t\t\t\t*urb = sitd->urb;\n\tstruct usb_iso_packet_descriptor\t*desc;\n\tu32\t\t\t\t\tt;\n\tint\t\t\t\t\turb_index;\n\tstruct ehci_iso_stream\t\t\t*stream = sitd->stream;\n\tbool\t\t\t\t\tretval = false;\n\n\turb_index = sitd->index;\n\tdesc = &urb->iso_frame_desc[urb_index];\n\tt = hc32_to_cpup(ehci, &sitd->hw_results);\n\n\t \n\tif (unlikely(t & SITD_ERRS)) {\n\t\turb->error_count++;\n\t\tif (t & SITD_STS_DBE)\n\t\t\tdesc->status = usb_pipein(urb->pipe)\n\t\t\t\t? -ENOSR   \n\t\t\t\t: -ECOMM;  \n\t\telse if (t & SITD_STS_BABBLE)\n\t\t\tdesc->status = -EOVERFLOW;\n\t\telse  \n\t\t\tdesc->status = -EPROTO;\n\t} else if (unlikely(t & SITD_STS_ACTIVE)) {\n\t\t \n\t\turb->error_count++;\n\t} else {\n\t\tdesc->status = 0;\n\t\tdesc->actual_length = desc->length - SITD_LENGTH(t);\n\t\turb->actual_length += desc->actual_length;\n\t}\n\n\t \n\tif ((urb_index + 1) != urb->number_of_packets)\n\t\tgoto done;\n\n\t \n\n\t \n\tehci_urb_done(ehci, urb, 0);\n\tretval = true;\n\turb = NULL;\n\n\t--ehci->isoc_count;\n\tdisable_periodic(ehci);\n\n\tehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;\n\tif (ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs == 0) {\n\t\tif (ehci->amd_pll_fix == 1)\n\t\t\tusb_amd_quirk_pll_enable();\n\t}\n\n\tif (list_is_singular(&stream->td_list))\n\t\tehci_to_hcd(ehci)->self.bandwidth_allocated\n\t\t\t\t-= stream->bandwidth;\n\ndone:\n\tsitd->urb = NULL;\n\n\t \n\tlist_move_tail(&sitd->sitd_list, &stream->free_list);\n\n\t \n\tif (list_empty(&stream->td_list)) {\n\t\tlist_splice_tail_init(&stream->free_list,\n\t\t\t\t&ehci->cached_sitd_list);\n\t\tstart_free_itds(ehci);\n\t}\n\n\treturn retval;\n}\n\n\nstatic int sitd_submit(struct ehci_hcd *ehci, struct urb *urb,\n\tgfp_t mem_flags)\n{\n\tint\t\t\tstatus = -EINVAL;\n\tunsigned long\t\tflags;\n\tstruct ehci_iso_stream\t*stream;\n\n\t \n\tstream = iso_stream_find(ehci, urb);\n\tif (stream == NULL) {\n\t\tehci_dbg(ehci, \"can't get iso stream\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tif (urb->interval != stream->ps.period) {\n\t\tehci_dbg(ehci, \"can't change iso interval %d --> %d\\n\",\n\t\t\tstream->ps.period, urb->interval);\n\t\tgoto done;\n\t}\n\n#ifdef EHCI_URB_TRACE\n\tehci_dbg(ehci,\n\t\t\"submit %p dev%s ep%d%s-iso len %d\\n\",\n\t\turb, urb->dev->devpath,\n\t\tusb_pipeendpoint(urb->pipe),\n\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\turb->transfer_buffer_length);\n#endif\n\n\t \n\tstatus = sitd_urb_transaction(stream, ehci, urb, mem_flags);\n\tif (status < 0) {\n\t\tehci_dbg(ehci, \"can't init sitds\\n\");\n\t\tgoto done;\n\t}\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(ehci_to_hcd(ehci)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done_not_linked;\n\t}\n\tstatus = usb_hcd_link_urb_to_ep(ehci_to_hcd(ehci), urb);\n\tif (unlikely(status))\n\t\tgoto done_not_linked;\n\tstatus = iso_stream_schedule(ehci, urb, stream);\n\tif (likely(status == 0)) {\n\t\tsitd_link_urb(ehci, urb, ehci->periodic_size << 3, stream);\n\t} else if (status > 0) {\n\t\tstatus = 0;\n\t\tehci_urb_done(ehci, urb, 0);\n\t} else {\n\t\tusb_hcd_unlink_urb_from_ep(ehci_to_hcd(ehci), urb);\n\t}\n done_not_linked:\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n done:\n\treturn status;\n}\n\n \n\nstatic void scan_isoc(struct ehci_hcd *ehci)\n{\n\tunsigned\t\tuf, now_frame, frame;\n\tunsigned\t\tfmask = ehci->periodic_size - 1;\n\tbool\t\t\tmodified, live;\n\tunion ehci_shadow\tq, *q_p;\n\t__hc32\t\t\ttype, *hw_p;\n\n\t \n\tif (ehci->rh_state >= EHCI_RH_RUNNING) {\n\t\tuf = ehci_read_frame_index(ehci);\n\t\tnow_frame = (uf >> 3) & fmask;\n\t\tlive = true;\n\t} else  {\n\t\tnow_frame = (ehci->last_iso_frame - 1) & fmask;\n\t\tlive = false;\n\t}\n\tehci->now_frame = now_frame;\n\n\tframe = ehci->last_iso_frame;\n\nrestart:\n\t \n\tq_p = &ehci->pshadow[frame];\n\thw_p = &ehci->periodic[frame];\n\tq.ptr = q_p->ptr;\n\ttype = Q_NEXT_TYPE(ehci, *hw_p);\n\tmodified = false;\n\n\twhile (q.ptr != NULL) {\n\t\tswitch (hc32_to_cpu(ehci, type)) {\n\t\tcase Q_TYPE_ITD:\n\t\t\t \n\t\t\tif (frame == now_frame && live) {\n\t\t\t\trmb();\n\t\t\t\tfor (uf = 0; uf < 8; uf++) {\n\t\t\t\t\tif (q.itd->hw_transaction[uf] &\n\t\t\t\t\t\t\tITD_ACTIVE(ehci))\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (uf < 8) {\n\t\t\t\t\tq_p = &q.itd->itd_next;\n\t\t\t\t\thw_p = &q.itd->hw_next;\n\t\t\t\t\ttype = Q_NEXT_TYPE(ehci,\n\t\t\t\t\t\t\tq.itd->hw_next);\n\t\t\t\t\tq = *q_p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t \n\t\t\t*q_p = q.itd->itd_next;\n\t\t\tif (!ehci->use_dummy_qh ||\n\t\t\t\t\tq.itd->hw_next != EHCI_LIST_END(ehci))\n\t\t\t\t*hw_p = q.itd->hw_next;\n\t\t\telse\n\t\t\t\t*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\n\t\t\ttype = Q_NEXT_TYPE(ehci, q.itd->hw_next);\n\t\t\twmb();\n\t\t\tmodified = itd_complete(ehci, q.itd);\n\t\t\tq = *q_p;\n\t\t\tbreak;\n\t\tcase Q_TYPE_SITD:\n\t\t\t \n\t\t\tif (((frame == now_frame) ||\n\t\t\t\t\t(((frame + 1) & fmask) == now_frame))\n\t\t\t\t&& live\n\t\t\t\t&& (q.sitd->hw_results & SITD_ACTIVE(ehci))) {\n\n\t\t\t\tq_p = &q.sitd->sitd_next;\n\t\t\t\thw_p = &q.sitd->hw_next;\n\t\t\t\ttype = Q_NEXT_TYPE(ehci, q.sitd->hw_next);\n\t\t\t\tq = *q_p;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\t*q_p = q.sitd->sitd_next;\n\t\t\tif (!ehci->use_dummy_qh ||\n\t\t\t\t\tq.sitd->hw_next != EHCI_LIST_END(ehci))\n\t\t\t\t*hw_p = q.sitd->hw_next;\n\t\t\telse\n\t\t\t\t*hw_p = cpu_to_hc32(ehci, ehci->dummy->qh_dma);\n\t\t\ttype = Q_NEXT_TYPE(ehci, q.sitd->hw_next);\n\t\t\twmb();\n\t\t\tmodified = sitd_complete(ehci, q.sitd);\n\t\t\tq = *q_p;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tehci_dbg(ehci, \"corrupt type %d frame %d shadow %p\\n\",\n\t\t\t\t\ttype, frame, q.ptr);\n\t\t\t \n\t\t\tfallthrough;\n\t\tcase Q_TYPE_QH:\n\t\tcase Q_TYPE_FSTN:\n\t\t\t \n\t\t\tq.ptr = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t \n\t\tif (unlikely(modified && ehci->isoc_count > 0))\n\t\t\tgoto restart;\n\t}\n\n\t \n\tif (frame == now_frame)\n\t\treturn;\n\n\t \n\tehci->last_iso_frame = frame;\n\tframe = (frame + 1) & fmask;\n\n\tgoto restart;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}