{
  "module_name": "ohci-hcd.c",
  "hash_id": "7f8dd508e61bfdee1be618e1ce000706f55615fc8c987fc032f22d8802c37983",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/hcd.h>\n#include <linux/dma-mapping.h>\n#include <linux/dmapool.h>\n#include <linux/workqueue.h>\n#include <linux/debugfs.h>\n#include <linux/genalloc.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n#include <asm/byteorder.h>\n\n\n#define DRIVER_AUTHOR \"Roman Weissgaerber, David Brownell\"\n#define DRIVER_DESC \"USB 1.1 'Open' Host Controller (OHCI) Driver\"\n\n \n\n \n#define\tOHCI_CONTROL_INIT\tOHCI_CTRL_CBSR\n#define\tOHCI_INTR_INIT \\\n\t\t(OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE \\\n\t\t| OHCI_INTR_RD | OHCI_INTR_WDH)\n\n#ifdef __hppa__\n \n#define\tIR_DISABLE\n#endif\n\n#ifdef CONFIG_ARCH_OMAP\n \n#define\tIR_DISABLE\n#endif\n\n \n\nstatic const char\thcd_name [] = \"ohci_hcd\";\n\n#define\tSTATECHANGE_DELAY\tmsecs_to_jiffies(300)\n#define\tIO_WATCHDOG_DELAY\tmsecs_to_jiffies(275)\n#define\tIO_WATCHDOG_OFF\t\t0xffffff00\n\n#include \"ohci.h\"\n#include \"pci-quirks.h\"\n\nstatic void ohci_dump(struct ohci_hcd *ohci);\nstatic void ohci_stop(struct usb_hcd *hcd);\nstatic void io_watchdog_func(struct timer_list *t);\n\n#include \"ohci-hub.c\"\n#include \"ohci-dbg.c\"\n#include \"ohci-mem.c\"\n#include \"ohci-q.c\"\n\n\n \n#if defined(CONFIG_SA1111)   \n#define IRQ_NOTMINE\tIRQ_HANDLED\n#else\n#define IRQ_NOTMINE\tIRQ_NONE\n#endif\n\n\n \nstatic bool distrust_firmware;\nmodule_param (distrust_firmware, bool, 0);\nMODULE_PARM_DESC (distrust_firmware,\n\t\"true to distrust firmware power/overcurrent setup\");\n\n \nstatic bool no_handshake;\nmodule_param (no_handshake, bool, 0);\nMODULE_PARM_DESC (no_handshake, \"true (not default) disables BIOS handshake\");\n\n \n\nstatic int number_of_tds(struct urb *urb)\n{\n\tint\t\t\tlen, i, num, this_sg_len;\n\tstruct scatterlist\t*sg;\n\n\tlen = urb->transfer_buffer_length;\n\ti = urb->num_mapped_sgs;\n\n\tif (len > 0 && i > 0) {\t\t \n\t\tnum = 0;\n\t\tsg = urb->sg;\n\t\tfor (;;) {\n\t\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t\t\tnum += DIV_ROUND_UP(this_sg_len, 4096);\n\t\t\tlen -= this_sg_len;\n\t\t\tif (--i <= 0 || len <= 0)\n\t\t\t\tbreak;\n\t\t\tsg = sg_next(sg);\n\t\t}\n\n\t} else {\t\t\t \n\t\t \n\t\tnum = DIV_ROUND_UP(len, 4096);\n\t}\n\treturn num;\n}\n\n \nstatic int ohci_urb_enqueue (\n\tstruct usb_hcd\t*hcd,\n\tstruct urb\t*urb,\n\tgfp_t\t\tmem_flags\n) {\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tstruct ed\t*ed;\n\turb_priv_t\t*urb_priv;\n\tunsigned int\tpipe = urb->pipe;\n\tint\t\ti, size = 0;\n\tunsigned long\tflags;\n\tint\t\tretval = 0;\n\n\t \n\ted = ed_get(ohci, urb->ep, urb->dev, pipe, urb->interval);\n\tif (! ed)\n\t\treturn -ENOMEM;\n\n\t \n\tswitch (ed->type) {\n\t\tcase PIPE_CONTROL:\n\t\t\t \n\t\t\tif (urb->transfer_buffer_length > 4096)\n\t\t\t\treturn -EMSGSIZE;\n\n\t\t\t \n\t\t\tsize = 2;\n\t\t\tfallthrough;\n\t\t\n\t\t\n\t\tdefault:\n\t\t\tsize += number_of_tds(urb);\n\t\t\t \n\t\t\tif (size == 0)\n\t\t\t\tsize++;\n\t\t\telse if ((urb->transfer_flags & URB_ZERO_PACKET) != 0\n\t\t\t\t&& (urb->transfer_buffer_length\n\t\t\t\t\t% usb_maxpacket(urb->dev, pipe)) == 0)\n\t\t\t\tsize++;\n\t\t\tbreak;\n\t\tcase PIPE_ISOCHRONOUS:  \n\t\t\tsize = urb->number_of_packets;\n\t\t\tbreak;\n\t}\n\n\t \n\turb_priv = kzalloc(struct_size(urb_priv, td, size), mem_flags);\n\tif (!urb_priv)\n\t\treturn -ENOMEM;\n\tINIT_LIST_HEAD (&urb_priv->pending);\n\turb_priv->length = size;\n\turb_priv->ed = ed;\n\n\t \n\tfor (i = 0; i < size; i++) {\n\t\turb_priv->td [i] = td_alloc (ohci, mem_flags);\n\t\tif (!urb_priv->td [i]) {\n\t\t\turb_priv->length = i;\n\t\t\turb_free_priv (ohci, urb_priv);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tspin_lock_irqsave (&ohci->lock, flags);\n\n\t \n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tretval = -ENODEV;\n\t\tgoto fail;\n\t}\n\tif (ohci->rh_state != OHCI_RH_RUNNING) {\n\t\tretval = -ENODEV;\n\t\tgoto fail;\n\t}\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval)\n\t\tgoto fail;\n\n\t \n\tif (ed->state == ED_IDLE) {\n\t\tretval = ed_schedule (ohci, ed);\n\t\tif (retval < 0) {\n\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\tgoto fail;\n\t\t}\n\n\t\t \n\t\tif (ohci->prev_frame_no == IO_WATCHDOG_OFF &&\n\t\t\t\tlist_empty(&ohci->eds_in_use) &&\n\t\t\t\t!(ohci->flags & OHCI_QUIRK_QEMU)) {\n\t\t\tohci->prev_frame_no = ohci_frame_no(ohci);\n\t\t\tmod_timer(&ohci->io_watchdog,\n\t\t\t\t\tjiffies + IO_WATCHDOG_DELAY);\n\t\t}\n\t\tlist_add(&ed->in_use_list, &ohci->eds_in_use);\n\n\t\tif (ed->type == PIPE_ISOCHRONOUS) {\n\t\t\tu16\tframe = ohci_frame_no(ohci);\n\n\t\t\t \n\t\t\tframe += max_t (u16, 8, ed->interval);\n\t\t\tframe &= ~(ed->interval - 1);\n\t\t\tframe |= ed->branch;\n\t\t\turb->start_frame = frame;\n\t\t\ted->last_iso = frame + ed->interval * (size - 1);\n\t\t}\n\t} else if (ed->type == PIPE_ISOCHRONOUS) {\n\t\tu16\tnext = ohci_frame_no(ohci) + 1;\n\t\tu16\tframe = ed->last_iso + ed->interval;\n\t\tu16\tlength = ed->interval * (size - 1);\n\n\t\t \n\t\tif (unlikely(tick_before(frame, next))) {\n\n\t\t\t \n\t\t\tif (urb->transfer_flags & URB_ISO_ASAP) {\n\t\t\t\tframe += (next - frame + ed->interval - 1) &\n\t\t\t\t\t\t-ed->interval;\n\n\t\t\t \n\t\t\t} else {\n\t\t\t\t \n\t\t\t\turb_priv->td_cnt = DIV_ROUND_UP(\n\t\t\t\t\t\t(u16) (next - frame),\n\t\t\t\t\t\ted->interval);\n\t\t\t\tif (urb_priv->td_cnt >= urb_priv->length) {\n\t\t\t\t\t++urb_priv->td_cnt;\t \n\t\t\t\t\tohci_dbg(ohci, \"iso underrun %p (%u+%u < %u)\\n\",\n\t\t\t\t\t\t\turb, frame, length,\n\t\t\t\t\t\t\tnext);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\turb->start_frame = frame;\n\t\ted->last_iso = frame + length;\n\t}\n\n\t \n\turb->hcpriv = urb_priv;\n\ttd_submit_urb (ohci, urb);\n\nfail:\n\tif (retval)\n\t\turb_free_priv (ohci, urb_priv);\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\treturn retval;\n}\n\n \nstatic int ohci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\tunsigned long\t\tflags;\n\tint\t\t\trc;\n\turb_priv_t\t\t*urb_priv;\n\n\tspin_lock_irqsave (&ohci->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc == 0) {\n\n\t\t \n\t\turb_priv = urb->hcpriv;\n\t\tif (urb_priv->ed->state == ED_OPER)\n\t\t\tstart_ed_unlink(ohci, urb_priv->ed);\n\n\t\tif (ohci->rh_state != OHCI_RH_RUNNING) {\n\t\t\t \n\t\t\tohci_work(ohci);\n\t\t}\n\t}\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\treturn rc;\n}\n\n \n\n \n\nstatic void\nohci_endpoint_disable (struct usb_hcd *hcd, struct usb_host_endpoint *ep)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\tunsigned long\t\tflags;\n\tstruct ed\t\t*ed = ep->hcpriv;\n\tunsigned\t\tlimit = 1000;\n\n\t \n\t \n\n\tif (!ed)\n\t\treturn;\n\nrescan:\n\tspin_lock_irqsave (&ohci->lock, flags);\n\n\tif (ohci->rh_state != OHCI_RH_RUNNING) {\nsanitize:\n\t\ted->state = ED_IDLE;\n\t\tohci_work(ohci);\n\t}\n\n\tswitch (ed->state) {\n\tcase ED_UNLINK:\t\t \n\t\t \n\t\tif (limit-- == 0) {\n\t\t\tohci_warn(ohci, \"ED unlink timeout\\n\");\n\t\t\tgoto sanitize;\n\t\t}\n\t\tspin_unlock_irqrestore (&ohci->lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tgoto rescan;\n\tcase ED_IDLE:\t\t \n\t\tif (list_empty (&ed->td_list)) {\n\t\t\ttd_free (ohci, ed->dummy);\n\t\t\ted_free (ohci, ed);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\n\t\t \n\t\tohci_err (ohci, \"leak ed %p (#%02x) state %d%s\\n\",\n\t\t\ted, ep->desc.bEndpointAddress, ed->state,\n\t\t\tlist_empty (&ed->td_list) ? \"\" : \" (has tds)\");\n\t\ttd_free (ohci, ed->dummy);\n\t\tbreak;\n\t}\n\tep->hcpriv = NULL;\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n}\n\nstatic int ohci_get_frame (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\n\treturn ohci_frame_no(ohci);\n}\n\nstatic void ohci_usb_reset (struct ohci_hcd *ohci)\n{\n\tohci->hc_control = ohci_readl (ohci, &ohci->regs->control);\n\tohci->hc_control &= OHCI_CTRL_RWC;\n\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\tohci->rh_state = OHCI_RH_HALTED;\n}\n\n \nstatic void _ohci_shutdown(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd *ohci;\n\n\tohci = hcd_to_ohci (hcd);\n\tohci_writel(ohci, (u32) ~0, &ohci->regs->intrdisable);\n\n\t \n\tohci_writel(ohci, OHCI_HCR, &ohci->regs->cmdstatus);\n\tohci_readl(ohci, &ohci->regs->cmdstatus);\t \n\tudelay(10);\n\n\tohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);\n\tohci->rh_state = OHCI_RH_HALTED;\n}\n\nstatic void ohci_shutdown(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ohci->lock, flags);\n\t_ohci_shutdown(hcd);\n\tspin_unlock_irqrestore(&ohci->lock, flags);\n}\n\n \n\n \n\nstatic int ohci_init (struct ohci_hcd *ohci)\n{\n\tint ret;\n\tstruct usb_hcd *hcd = ohci_to_hcd(ohci);\n\n\t \n\tif (!hcd->localmem_pool)\n\t\thcd->self.sg_tablesize = ~0;\n\n\tif (distrust_firmware)\n\t\tohci->flags |= OHCI_QUIRK_HUB_POWER;\n\n\tohci->rh_state = OHCI_RH_HALTED;\n\tohci->regs = hcd->regs;\n\n\t \n\n#ifndef IR_DISABLE\n\t \n\tif (!no_handshake && ohci_readl (ohci,\n\t\t\t\t\t&ohci->regs->control) & OHCI_CTRL_IR) {\n\t\tu32 temp;\n\n\t\tohci_dbg (ohci, \"USB HC TakeOver from BIOS/SMM\\n\");\n\n\t\t \n\t\ttemp = 500;\t \n\n\t\tohci_writel (ohci, OHCI_INTR_OC, &ohci->regs->intrenable);\n\t\tohci_writel (ohci, OHCI_OCR, &ohci->regs->cmdstatus);\n\t\twhile (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_IR) {\n\t\t\tmsleep (10);\n\t\t\tif (--temp == 0) {\n\t\t\t\tohci_err (ohci, \"USB HC takeover failed!\"\n\t\t\t\t\t\"  (BIOS/SMM bug)\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t}\n\t\tohci_usb_reset (ohci);\n\t}\n#endif\n\n\t \n\tohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\n\n\t \n\tif (ohci_readl (ohci, &ohci->regs->control) & OHCI_CTRL_RWC)\n\t\tohci->hc_control |= OHCI_CTRL_RWC;\n\n\t \n\tif (ohci->num_ports == 0)\n\t\tohci->num_ports = roothub_a(ohci) & RH_A_NDP;\n\n\tif (ohci->hcca)\n\t\treturn 0;\n\n\ttimer_setup(&ohci->io_watchdog, io_watchdog_func, 0);\n\tohci->prev_frame_no = IO_WATCHDOG_OFF;\n\n\tif (hcd->localmem_pool)\n\t\tohci->hcca = gen_pool_dma_alloc_align(hcd->localmem_pool,\n\t\t\t\t\t\tsizeof(*ohci->hcca),\n\t\t\t\t\t\t&ohci->hcca_dma, 256);\n\telse\n\t\tohci->hcca = dma_alloc_coherent(hcd->self.controller,\n\t\t\t\t\t\tsizeof(*ohci->hcca),\n\t\t\t\t\t\t&ohci->hcca_dma,\n\t\t\t\t\t\tGFP_KERNEL);\n\tif (!ohci->hcca)\n\t\treturn -ENOMEM;\n\n\tif ((ret = ohci_mem_init (ohci)) < 0)\n\t\tohci_stop (hcd);\n\telse {\n\t\tcreate_debug_files (ohci);\n\t}\n\n\treturn ret;\n}\n\n \n\n \nstatic int ohci_run (struct ohci_hcd *ohci)\n{\n\tu32\t\t\tmask, val;\n\tint\t\t\tfirst = ohci->fminterval == 0;\n\tstruct usb_hcd\t\t*hcd = ohci_to_hcd(ohci);\n\n\tohci->rh_state = OHCI_RH_HALTED;\n\n\t \n\tif (first) {\n\n\t\tval = ohci_readl (ohci, &ohci->regs->fminterval);\n\t\tohci->fminterval = val & 0x3fff;\n\t\tif (ohci->fminterval != FI)\n\t\t\tohci_dbg (ohci, \"fminterval delta %d\\n\",\n\t\t\t\tohci->fminterval - FI);\n\t\tohci->fminterval |= FSMP (ohci->fminterval) << 16;\n\t\t \n\t}\n\n\t \n\tif ((ohci->hc_control & OHCI_CTRL_RWC) != 0)\n\t\tdevice_set_wakeup_capable(hcd->self.controller, 1);\n\n\tswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_OPER:\n\t\tval = 0;\n\t\tbreak;\n\tcase OHCI_USB_SUSPEND:\n\tcase OHCI_USB_RESUME:\n\t\tohci->hc_control &= OHCI_CTRL_RWC;\n\t\tohci->hc_control |= OHCI_USB_RESUME;\n\t\tval = 10  ;\n\t\tbreak;\n\t\n\tdefault:\n\t\tohci->hc_control &= OHCI_CTRL_RWC;\n\t\tohci->hc_control |= OHCI_USB_RESET;\n\t\tval = 50  ;\n\t\tbreak;\n\t}\n\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\tmsleep(val);\n\n\tmemset (ohci->hcca, 0, sizeof (struct ohci_hcca));\n\n\t \n\tspin_lock_irq (&ohci->lock);\n\nretry:\n\t \n\tohci_writel (ohci, OHCI_HCR,  &ohci->regs->cmdstatus);\n\tval = 30;\t \n\twhile ((ohci_readl (ohci, &ohci->regs->cmdstatus) & OHCI_HCR) != 0) {\n\t\tif (--val == 0) {\n\t\t\tspin_unlock_irq (&ohci->lock);\n\t\t\tohci_err (ohci, \"USB HC reset timed out!\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tudelay (1);\n\t}\n\n\t \n\tif (ohci->flags & OHCI_QUIRK_INITRESET) {\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t\t\n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t}\n\n\t \n\tohci_writel (ohci, 0, &ohci->regs->ed_controlhead);\n\tohci_writel (ohci, 0, &ohci->regs->ed_bulkhead);\n\n\t \n\tohci_writel (ohci, (u32) ohci->hcca_dma, &ohci->regs->hcca);\n\n\tperiodic_reinit (ohci);\n\n\t \n\tif ((ohci_readl (ohci, &ohci->regs->fminterval) & 0x3fff0000) == 0\n\t\t\t|| !ohci_readl (ohci, &ohci->regs->periodicstart)) {\n\t\tif (!(ohci->flags & OHCI_QUIRK_INITRESET)) {\n\t\t\tohci->flags |= OHCI_QUIRK_INITRESET;\n\t\t\tohci_dbg (ohci, \"enabling initreset quirk\\n\");\n\t\t\tgoto retry;\n\t\t}\n\t\tspin_unlock_irq (&ohci->lock);\n\t\tohci_err (ohci, \"init err (%08x %04x)\\n\",\n\t\t\tohci_readl (ohci, &ohci->regs->fminterval),\n\t\t\tohci_readl (ohci, &ohci->regs->periodicstart));\n\t\treturn -EOVERFLOW;\n\t}\n\n\t \n\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\thcd->uses_new_polling = 1;\n\n\t \n\tohci->hc_control &= OHCI_CTRL_RWC;\n\tohci->hc_control |= OHCI_CONTROL_INIT | OHCI_USB_OPER;\n\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\tohci->rh_state = OHCI_RH_RUNNING;\n\n\t \n\tohci_writel (ohci, RH_HS_DRWE, &ohci->regs->roothub.status);\n\n\t \n\tmask = OHCI_INTR_INIT;\n\tohci_writel (ohci, ~0, &ohci->regs->intrstatus);\n\tohci_writel (ohci, mask, &ohci->regs->intrenable);\n\n\t \n\tval = roothub_a (ohci);\n\t \n\tval &= ~RH_A_NOCP;\n\tval |= RH_A_OCPM;\n\tif (ohci->flags & OHCI_QUIRK_SUPERIO) {\n\t\t \n\t\tval |= RH_A_NOCP;\n\t\tval &= ~(RH_A_POTPGT | RH_A_NPS | RH_A_PSM | RH_A_OCPM);\n\t} else if ((ohci->flags & OHCI_QUIRK_AMD756) ||\n\t\t\t(ohci->flags & OHCI_QUIRK_HUB_POWER)) {\n\t\t \n\t\tval |= RH_A_NPS;\n\t}\n\tohci_writel(ohci, val, &ohci->regs->roothub.a);\n\n\tohci_writel (ohci, RH_HS_LPSC, &ohci->regs->roothub.status);\n\tohci_writel (ohci, (val & RH_A_NPS) ? 0 : RH_B_PPCM,\n\t\t\t\t\t\t&ohci->regs->roothub.b);\n\t\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\n\tohci->next_statechange = jiffies + STATECHANGE_DELAY;\n\tspin_unlock_irq (&ohci->lock);\n\n\t\n\tmdelay ((val >> 23) & 0x1fe);\n\n\tohci_dump(ohci);\n\n\treturn 0;\n}\n\n \n\nint ohci_setup(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci(hcd);\n\n\tohci_hcd_init(ohci);\n\t\n\treturn ohci_init(ohci);\n}\nEXPORT_SYMBOL_GPL(ohci_setup);\n\n \nstatic int ohci_start(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci(hcd);\n\tint\tret;\n\n\tret = ohci_run(ohci);\n\tif (ret < 0) {\n\t\tohci_err(ohci, \"can't start\\n\");\n\t\tohci_stop(hcd);\n\t}\n\treturn ret;\n}\n\n \n\n \nstatic void io_watchdog_func(struct timer_list *t)\n{\n\tstruct ohci_hcd\t*ohci = from_timer(ohci, t, io_watchdog);\n\tbool\t\ttakeback_all_pending = false;\n\tu32\t\tstatus;\n\tu32\t\thead;\n\tstruct ed\t*ed;\n\tstruct td\t*td, *td_start, *td_next;\n\tunsigned\tframe_no, prev_frame_no = IO_WATCHDOG_OFF;\n\tunsigned long\tflags;\n\n\tspin_lock_irqsave(&ohci->lock, flags);\n\n\t \n\tstatus = ohci_readl(ohci, &ohci->regs->intrstatus);\n\tif (!(status & OHCI_INTR_WDH) && ohci->wdh_cnt == ohci->prev_wdh_cnt) {\n\t\tif (ohci->prev_donehead) {\n\t\t\tohci_err(ohci, \"HcDoneHead not written back; disabled\\n\");\n died:\n\t\t\tusb_hc_died(ohci_to_hcd(ohci));\n\t\t\tohci_dump(ohci);\n\t\t\t_ohci_shutdown(ohci_to_hcd(ohci));\n\t\t\tgoto done;\n\t\t} else {\n\t\t\t \n\t\t\ttakeback_all_pending = true;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(ed, &ohci->eds_in_use, in_use_list) {\n\t\tif (ed->pending_td) {\n\t\t\tif (takeback_all_pending ||\n\t\t\t\t\tOKAY_TO_TAKEBACK(ohci, ed)) {\n\t\t\t\tunsigned tmp = hc32_to_cpu(ohci, ed->hwINFO);\n\n\t\t\t\tohci_dbg(ohci, \"takeback pending TD for dev %d ep 0x%x\\n\",\n\t\t\t\t\t\t0x007f & tmp,\n\t\t\t\t\t\t(0x000f & (tmp >> 7)) +\n\t\t\t\t\t\t\t((tmp & ED_IN) >> 5));\n\t\t\t\tadd_to_done_list(ohci, ed->pending_td);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\ttd = ed->pending_td;\n\n\t\t \n\t\tif (!td) {\n\t\t\tlist_for_each_entry(td_next, &ed->td_list, td_list) {\n\t\t\t\tif (!td_next->next_dl_td)\n\t\t\t\t\tbreak;\n\t\t\t\ttd = td_next;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\thead = hc32_to_cpu(ohci, READ_ONCE(ed->hwHeadP)) & TD_MASK;\n\t\ttd_start = td;\n\t\ttd_next = list_prepare_entry(td, &ed->td_list, td_list);\n\t\tlist_for_each_entry_continue(td_next, &ed->td_list, td_list) {\n\t\t\tif (head == (u32) td_next->td_dma)\n\t\t\t\tbreak;\n\t\t\ttd = td_next;\t \n\t\t}\n\t\tif (td != td_start) {\n\t\t\t \n\t\t\ted->takeback_wdh_cnt = ohci->wdh_cnt + 2;\n\t\t\ted->pending_td = td;\n\t\t}\n\t}\n\n\tohci_work(ohci);\n\n\tif (ohci->rh_state == OHCI_RH_RUNNING) {\n\n\t\t \n\t\tframe_no = ohci_frame_no(ohci);\n\t\tif (frame_no == ohci->prev_frame_no) {\n\t\t\tint\t\tactive_cnt = 0;\n\t\t\tint\t\ti;\n\t\t\tunsigned\ttmp;\n\n\t\t\tfor (i = 0; i < ohci->num_ports; ++i) {\n\t\t\t\ttmp = roothub_portstatus(ohci, i);\n\t\t\t\t \n\t\t\t\tif ((tmp & RH_PS_PES) && !(tmp & RH_PS_PSS))\n\t\t\t\t\t++active_cnt;\n\t\t\t}\n\n\t\t\tif (active_cnt > 0) {\n\t\t\t\tohci_err(ohci, \"frame counter not updating; disabled\\n\");\n\t\t\t\tgoto died;\n\t\t\t}\n\t\t}\n\t\tif (!list_empty(&ohci->eds_in_use)) {\n\t\t\tprev_frame_no = frame_no;\n\t\t\tohci->prev_wdh_cnt = ohci->wdh_cnt;\n\t\t\tohci->prev_donehead = ohci_readl(ohci,\n\t\t\t\t\t&ohci->regs->donehead);\n\t\t\tmod_timer(&ohci->io_watchdog,\n\t\t\t\t\tjiffies + IO_WATCHDOG_DELAY);\n\t\t}\n\t}\n\n done:\n\tohci->prev_frame_no = prev_frame_no;\n\tspin_unlock_irqrestore(&ohci->lock, flags);\n}\n\n \n\nstatic irqreturn_t ohci_irq (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\tstruct ohci_regs __iomem *regs = ohci->regs;\n\tint\t\t\tints;\n\n\t \n\tints = ohci_readl(ohci, &regs->intrstatus);\n\n\t \n\tif (ints == ~(u32)0) {\n\t\tohci->rh_state = OHCI_RH_HALTED;\n\t\tohci_dbg (ohci, \"device removed!\\n\");\n\t\tusb_hc_died(hcd);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\t \n\tints &= ohci_readl(ohci, &regs->intrenable);\n\n\t \n\tif (ints == 0 || unlikely(ohci->rh_state == OHCI_RH_HALTED))\n\t\treturn IRQ_NOTMINE;\n\n\tif (ints & OHCI_INTR_UE) {\n\t\t\n\t\tif (quirk_nec(ohci)) {\n\t\t\t \n\t\t\tohci_err (ohci, \"OHCI Unrecoverable Error, scheduling NEC chip restart\\n\");\n\n\t\t\tohci_writel (ohci, OHCI_INTR_UE, &regs->intrdisable);\n\n\t\t\tschedule_work (&ohci->nec_work);\n\t\t} else {\n\t\t\tohci_err (ohci, \"OHCI Unrecoverable Error, disabled\\n\");\n\t\t\tohci->rh_state = OHCI_RH_HALTED;\n\t\t\tusb_hc_died(hcd);\n\t\t}\n\n\t\tohci_dump(ohci);\n\t\tohci_usb_reset (ohci);\n\t}\n\n\tif (ints & OHCI_INTR_RHSC) {\n\t\tohci_dbg(ohci, \"rhsc\\n\");\n\t\tohci->next_statechange = jiffies + STATECHANGE_DELAY;\n\t\tohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,\n\t\t\t\t&regs->intrstatus);\n\n\t\t \n\t\tohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);\n\t\tusb_hcd_poll_rh_status(hcd);\n\t}\n\n\t \n\telse if (ints & OHCI_INTR_RD) {\n\t\tohci_dbg(ohci, \"resume detect\\n\");\n\t\tohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);\n\t\tset_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\t\tif (ohci->autostop) {\n\t\t\tspin_lock (&ohci->lock);\n\t\t\tohci_rh_resume (ohci);\n\t\t\tspin_unlock (&ohci->lock);\n\t\t} else\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t}\n\n\tspin_lock(&ohci->lock);\n\tif (ints & OHCI_INTR_WDH)\n\t\tupdate_done_list(ohci);\n\n\t \n\n\t \n\tohci_work(ohci);\n\tif ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list\n\t\t\t&& ohci->rh_state == OHCI_RH_RUNNING)\n\t\tohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);\n\n\tif (ohci->rh_state == OHCI_RH_RUNNING) {\n\t\tohci_writel (ohci, ints, &regs->intrstatus);\n\t\tif (ints & OHCI_INTR_WDH)\n\t\t\t++ohci->wdh_cnt;\n\n\t\tohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);\n\t\t \n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t}\n\tspin_unlock(&ohci->lock);\n\n\treturn IRQ_HANDLED;\n}\n\n \n\nstatic void ohci_stop (struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci (hcd);\n\n\tohci_dump(ohci);\n\n\tif (quirk_nec(ohci))\n\t\tflush_work(&ohci->nec_work);\n\tdel_timer_sync(&ohci->io_watchdog);\n\tohci->prev_frame_no = IO_WATCHDOG_OFF;\n\n\tohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\n\tohci_usb_reset(ohci);\n\tfree_irq(hcd->irq, hcd);\n\thcd->irq = 0;\n\n\tif (quirk_amdiso(ohci))\n\t\tusb_amd_dev_put();\n\n\tremove_debug_files (ohci);\n\tohci_mem_cleanup (ohci);\n\tif (ohci->hcca) {\n\t\tif (hcd->localmem_pool)\n\t\t\tgen_pool_free(hcd->localmem_pool,\n\t\t\t\t      (unsigned long)ohci->hcca,\n\t\t\t\t      sizeof(*ohci->hcca));\n\t\telse\n\t\t\tdma_free_coherent(hcd->self.controller,\n\t\t\t\t\t  sizeof(*ohci->hcca),\n\t\t\t\t\t  ohci->hcca, ohci->hcca_dma);\n\t\tohci->hcca = NULL;\n\t\tohci->hcca_dma = 0;\n\t}\n}\n\n \n\n#if defined(CONFIG_PM) || defined(CONFIG_USB_PCI)\n\n \nint ohci_restart(struct ohci_hcd *ohci)\n{\n\tint temp;\n\tint i;\n\tstruct urb_priv *priv;\n\n\tohci_init(ohci);\n\tspin_lock_irq(&ohci->lock);\n\tohci->rh_state = OHCI_RH_HALTED;\n\n\t \n\tif (!list_empty (&ohci->pending))\n\t\tohci_dbg(ohci, \"abort schedule...\\n\");\n\tlist_for_each_entry (priv, &ohci->pending, pending) {\n\t\tstruct urb\t*urb = priv->td[0]->urb;\n\t\tstruct ed\t*ed = priv->ed;\n\n\t\tswitch (ed->state) {\n\t\tcase ED_OPER:\n\t\t\ted->state = ED_UNLINK;\n\t\t\ted->hwINFO |= cpu_to_hc32(ohci, ED_DEQUEUE);\n\t\t\ted_deschedule (ohci, ed);\n\n\t\t\ted->ed_next = ohci->ed_rm_list;\n\t\t\ted->ed_prev = NULL;\n\t\t\tohci->ed_rm_list = ed;\n\t\t\tfallthrough;\n\t\tcase ED_UNLINK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tohci_dbg(ohci, \"bogus ed %p state %d\\n\",\n\t\t\t\t\ted, ed->state);\n\t\t}\n\n\t\tif (!urb->unlinked)\n\t\t\turb->unlinked = -ESHUTDOWN;\n\t}\n\tohci_work(ohci);\n\tspin_unlock_irq(&ohci->lock);\n\n\t \n\n\t \n\tfor (i = 0; i < NUM_INTS; i++) ohci->load [i] = 0;\n\tfor (i = 0; i < NUM_INTS; i++) ohci->hcca->int_table [i] = 0;\n\n\t \n\tohci->ed_rm_list = NULL;\n\n\t \n\tohci->ed_controltail = NULL;\n\tohci->ed_bulktail    = NULL;\n\n\tif ((temp = ohci_run (ohci)) < 0) {\n\t\tohci_err (ohci, \"can't restart, %d\\n\", temp);\n\t\treturn temp;\n\t}\n\tohci_dbg(ohci, \"restart complete\\n\");\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ohci_restart);\n\n#endif\n\n#ifdef CONFIG_PM\n\nint ohci_suspend(struct usb_hcd *hcd, bool do_wakeup)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci (hcd);\n\tunsigned long\tflags;\n\tint\t\trc = 0;\n\n\t \n\tspin_lock_irqsave (&ohci->lock, flags);\n\tohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);\n\t(void)ohci_readl(ohci, &ohci->regs->intrdisable);\n\n\tclear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\n\tsynchronize_irq(hcd->irq);\n\n\tif (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {\n\t\tohci_resume(hcd, false);\n\t\trc = -EBUSY;\n\t}\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(ohci_suspend);\n\n\nint ohci_resume(struct usb_hcd *hcd, bool hibernated)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci(hcd);\n\tint\t\t\tport;\n\tbool\t\t\tneed_reinit = false;\n\n\tset_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);\n\n\t \n\tif (hibernated)\n\t\tohci_usb_reset(ohci);\n\n\t \n\tohci->hc_control = ohci_readl(ohci, &ohci->regs->control);\n\tif (ohci->hc_control & (OHCI_CTRL_IR | OHCI_SCHED_ENABLES)) {\n\t\tneed_reinit = true;\n\t} else {\n\t\tswitch (ohci->hc_control & OHCI_CTRL_HCFS) {\n\t\tcase OHCI_USB_OPER:\n\t\tcase OHCI_USB_RESET:\n\t\t\tneed_reinit = true;\n\t\t}\n\t}\n\n\t \n\tif (need_reinit) {\n\t\tspin_lock_irq(&ohci->lock);\n\t\tohci_rh_resume(ohci);\n\t\tohci_rh_suspend(ohci, 0);\n\t\tspin_unlock_irq(&ohci->lock);\n\t}\n\n\t \n\telse {\n\t\tohci_dbg(ohci, \"powerup ports\\n\");\n\t\tfor (port = 0; port < ohci->num_ports; port++)\n\t\t\tohci_writel(ohci, RH_PS_PPS,\n\t\t\t\t\t&ohci->regs->roothub.portstatus[port]);\n\n\t\tohci_writel(ohci, OHCI_INTR_MIE, &ohci->regs->intrenable);\n\t\tohci_readl(ohci, &ohci->regs->intrenable);\n\t\tmsleep(20);\n\t}\n\n\tusb_hcd_resume_root_hub(hcd);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(ohci_resume);\n\n#endif\n\n \n\n \n\nstatic const struct hc_driver ohci_hc_driver = {\n\t.description =          hcd_name,\n\t.product_desc =         \"OHCI Host Controller\",\n\t.hcd_priv_size =        sizeof(struct ohci_hcd),\n\n\t \n\t.irq =                  ohci_irq,\n\t.flags =                HCD_MEMORY | HCD_DMA | HCD_USB11,\n\n\t \n\t.reset =                ohci_setup,\n\t.start =                ohci_start,\n\t.stop =                 ohci_stop,\n\t.shutdown =             ohci_shutdown,\n\n\t \n\t.urb_enqueue =          ohci_urb_enqueue,\n\t.urb_dequeue =          ohci_urb_dequeue,\n\t.endpoint_disable =     ohci_endpoint_disable,\n\n\t \n\t.get_frame_number =     ohci_get_frame,\n\n\t \n\t.hub_status_data =      ohci_hub_status_data,\n\t.hub_control =          ohci_hub_control,\n#ifdef CONFIG_PM\n\t.bus_suspend =          ohci_bus_suspend,\n\t.bus_resume =           ohci_bus_resume,\n#endif\n\t.start_port_reset =\tohci_start_port_reset,\n};\n\nvoid ohci_init_driver(struct hc_driver *drv,\n\t\tconst struct ohci_driver_overrides *over)\n{\n\t \n\t*drv = ohci_hc_driver;\n\n\tif (over) {\n\t\tdrv->product_desc = over->product_desc;\n\t\tdrv->hcd_priv_size += over->extra_priv_size;\n\t\tif (over->reset)\n\t\t\tdrv->reset = over->reset;\n\t}\n}\nEXPORT_SYMBOL_GPL(ohci_init_driver);\n\n \n\nMODULE_AUTHOR (DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE (\"GPL\");\n\n#if defined(CONFIG_ARCH_SA1100) && defined(CONFIG_SA1111)\n#include \"ohci-sa1111.c\"\n#define SA1111_DRIVER\t\tohci_hcd_sa1111_driver\n#endif\n\n#ifdef CONFIG_USB_OHCI_HCD_PPC_OF\n#include \"ohci-ppc-of.c\"\n#define OF_PLATFORM_DRIVER\tohci_hcd_ppc_of_driver\n#endif\n\n#ifdef CONFIG_PPC_PS3\n#include \"ohci-ps3.c\"\n#define PS3_SYSTEM_BUS_DRIVER\tps3_ohci_driver\n#endif\n\n#ifdef CONFIG_MFD_SM501\n#include \"ohci-sm501.c\"\n#define SM501_OHCI_DRIVER\tohci_hcd_sm501_driver\n#endif\n\nstatic int __init ohci_hcd_mod_init(void)\n{\n\tint retval = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tpr_debug (\"%s: block sizes: ed %zd td %zd\\n\", hcd_name,\n\t\tsizeof (struct ed), sizeof (struct td));\n\tset_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\n\n\tohci_debug_root = debugfs_create_dir(\"ohci\", usb_debug_root);\n\n#ifdef PS3_SYSTEM_BUS_DRIVER\n\tretval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);\n\tif (retval < 0)\n\t\tgoto error_ps3;\n#endif\n\n#ifdef OF_PLATFORM_DRIVER\n\tretval = platform_driver_register(&OF_PLATFORM_DRIVER);\n\tif (retval < 0)\n\t\tgoto error_of_platform;\n#endif\n\n#ifdef SA1111_DRIVER\n\tretval = sa1111_driver_register(&SA1111_DRIVER);\n\tif (retval < 0)\n\t\tgoto error_sa1111;\n#endif\n\n#ifdef SM501_OHCI_DRIVER\n\tretval = platform_driver_register(&SM501_OHCI_DRIVER);\n\tif (retval < 0)\n\t\tgoto error_sm501;\n#endif\n\n\treturn retval;\n\n\t \n#ifdef SM501_OHCI_DRIVER\n\tplatform_driver_unregister(&SM501_OHCI_DRIVER);\n error_sm501:\n#endif\n#ifdef SA1111_DRIVER\n\tsa1111_driver_unregister(&SA1111_DRIVER);\n error_sa1111:\n#endif\n#ifdef OF_PLATFORM_DRIVER\n\tplatform_driver_unregister(&OF_PLATFORM_DRIVER);\n error_of_platform:\n#endif\n#ifdef PS3_SYSTEM_BUS_DRIVER\n\tps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\n error_ps3:\n#endif\n\tdebugfs_remove(ohci_debug_root);\n\tohci_debug_root = NULL;\n\n\tclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\n\treturn retval;\n}\nmodule_init(ohci_hcd_mod_init);\n\nstatic void __exit ohci_hcd_mod_exit(void)\n{\n#ifdef SM501_OHCI_DRIVER\n\tplatform_driver_unregister(&SM501_OHCI_DRIVER);\n#endif\n#ifdef SA1111_DRIVER\n\tsa1111_driver_unregister(&SA1111_DRIVER);\n#endif\n#ifdef OF_PLATFORM_DRIVER\n\tplatform_driver_unregister(&OF_PLATFORM_DRIVER);\n#endif\n#ifdef PS3_SYSTEM_BUS_DRIVER\n\tps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);\n#endif\n\tdebugfs_remove(ohci_debug_root);\n\tclear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);\n}\nmodule_exit(ohci_hcd_mod_exit);\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}