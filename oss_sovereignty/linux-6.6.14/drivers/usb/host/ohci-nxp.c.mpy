{
  "module_name": "ohci-nxp.c",
  "hash_id": "d6a01ffb02292f655a86d1fb4d7c08f9f09b7bde61a5fe4abcf419977956a8cd",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-nxp.c",
  "human_readable_source": "\n \n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/i2c.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/usb/isp1301.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ohci.h\"\n\n#define USB_CONFIG_BASE\t\t0x31020000\n\n \n#define TRANSPARENT_I2C_EN\t(1 << 7)\n#define HOST_EN\t\t\t(1 << 0)\n\n \n#ifndef start_int_set_falling_edge\n#define start_int_set_falling_edge(irq)\n#define start_int_set_rising_edge(irq)\n#define start_int_ack(irq)\n#define start_int_mask(irq)\n#define start_int_umask(irq)\n#endif\n\n#define DRIVER_DESC \"OHCI NXP driver\"\n\nstatic const char hcd_name[] = \"ohci-nxp\";\nstatic struct hc_driver __read_mostly ohci_nxp_hc_driver;\n\nstatic struct i2c_client *isp1301_i2c_client;\n\nstatic struct clk *usb_host_clk;\n\nstatic void isp1301_configure_lpc32xx(void)\n{\n\t \n\t \n\n\t \n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\tMC1_UART_EN);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t(ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\t~MC1_SPEED_REG);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t\t\t  ISP1301_I2C_MODE_CONTROL_1, MC1_SPEED_REG);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t  (ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\t  ~0);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_MODE_CONTROL_2,\n\t\t(MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL));\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR), ~0);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_MODE_CONTROL_1, MC1_DAT_SE0);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_OTG_CONTROL_1,\n\t\t(OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN));\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\t(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR),\n\t\t(OTG1_DM_PULLUP | OTG1_DP_PULLUP));\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\t~0);\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR, ~0);\n\n\tprintk(KERN_INFO \"ISP1301 Vendor ID  : 0x%04x\\n\",\n\t      i2c_smbus_read_word_data(isp1301_i2c_client, 0x00));\n\tprintk(KERN_INFO \"ISP1301 Product ID : 0x%04x\\n\",\n\t      i2c_smbus_read_word_data(isp1301_i2c_client, 0x02));\n\tprintk(KERN_INFO \"ISP1301 Version ID : 0x%04x\\n\",\n\t      i2c_smbus_read_word_data(isp1301_i2c_client, 0x14));\n}\n\nstatic void isp1301_configure(void)\n{\n\tisp1301_configure_lpc32xx();\n}\n\nstatic inline void isp1301_vbus_on(void)\n{\n\ti2c_smbus_write_byte_data(isp1301_i2c_client, ISP1301_I2C_OTG_CONTROL_1,\n\t\t\t\t  OTG1_VBUS_DRV);\n}\n\nstatic inline void isp1301_vbus_off(void)\n{\n\ti2c_smbus_write_byte_data(isp1301_i2c_client,\n\t\tISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR,\n\t\tOTG1_VBUS_DRV);\n}\n\nstatic void ohci_nxp_start_hc(void)\n{\n\tvoid __iomem *usb_otg_stat_control = ioremap(USB_CONFIG_BASE + 0x110, 4);\n\tunsigned long tmp;\n\n\tif (WARN_ON(!usb_otg_stat_control))\n\t\treturn;\n\n\ttmp = __raw_readl(usb_otg_stat_control) | HOST_EN;\n\n\t__raw_writel(tmp, usb_otg_stat_control);\n\tisp1301_vbus_on();\n\n\tiounmap(usb_otg_stat_control);\n}\n\nstatic void ohci_nxp_stop_hc(void)\n{\n\tvoid __iomem *usb_otg_stat_control = ioremap(USB_CONFIG_BASE + 0x110, 4);\n\tunsigned long tmp;\n\n\tif (WARN_ON(!usb_otg_stat_control))\n\t\treturn;\n\n\tisp1301_vbus_off();\n\ttmp = __raw_readl(usb_otg_stat_control) & ~HOST_EN;\n\t__raw_writel(tmp, usb_otg_stat_control);\n\n\tiounmap(usb_otg_stat_control);\n}\n\nstatic int ohci_hcd_nxp_probe(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = NULL;\n\tconst struct hc_driver *driver = &ohci_nxp_hc_driver;\n\tstruct resource *res;\n\tint ret = 0, irq;\n\tstruct device_node *isp1301_node;\n\n\tif (pdev->dev.of_node) {\n\t\tisp1301_node = of_parse_phandle(pdev->dev.of_node,\n\t\t\t\t\t\t\"transceiver\", 0);\n\t} else {\n\t\tisp1301_node = NULL;\n\t}\n\n\tisp1301_i2c_client = isp1301_get_client(isp1301_node);\n\tof_node_put(isp1301_node);\n\tif (!isp1301_i2c_client)\n\t\treturn -EPROBE_DEFER;\n\n\tret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto fail_disable;\n\n\tdev_dbg(&pdev->dev, \"%s: \" DRIVER_DESC \" (nxp)\\n\", hcd_name);\n\tif (usb_disabled()) {\n\t\tdev_err(&pdev->dev, \"USB is disabled\\n\");\n\t\tret = -ENODEV;\n\t\tgoto fail_disable;\n\t}\n\n\t \n\tusb_host_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(usb_host_clk)) {\n\t\tdev_err(&pdev->dev, \"failed to acquire USB OHCI clock\\n\");\n\t\tret = PTR_ERR(usb_host_clk);\n\t\tgoto fail_disable;\n\t}\n\n\tret = clk_prepare_enable(usb_host_clk);\n\tif (ret < 0) {\n\t\tdev_err(&pdev->dev, \"failed to start USB OHCI clock\\n\");\n\t\tgoto fail_disable;\n\t}\n\n\tisp1301_configure();\n\n\thcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate HC buffer\\n\");\n\t\tret = -ENOMEM;\n\t\tgoto fail_hcd;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tret = PTR_ERR(hcd->regs);\n\t\tgoto fail_resource;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = -ENXIO;\n\t\tgoto fail_resource;\n\t}\n\n\tohci_nxp_start_hc();\n\tplatform_set_drvdata(pdev, hcd);\n\n\tdev_info(&pdev->dev, \"at 0x%p, irq %d\\n\", hcd->regs, hcd->irq);\n\tret = usb_add_hcd(hcd, irq, 0);\n\tif (ret == 0) {\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t\treturn ret;\n\t}\n\n\tohci_nxp_stop_hc();\nfail_resource:\n\tusb_put_hcd(hcd);\nfail_hcd:\n\tclk_disable_unprepare(usb_host_clk);\nfail_disable:\n\tisp1301_i2c_client = NULL;\n\treturn ret;\n}\n\nstatic void ohci_hcd_nxp_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tusb_remove_hcd(hcd);\n\tohci_nxp_stop_hc();\n\tusb_put_hcd(hcd);\n\tclk_disable_unprepare(usb_host_clk);\n\tisp1301_i2c_client = NULL;\n}\n\n \nMODULE_ALIAS(\"platform:usb-ohci\");\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id ohci_hcd_nxp_match[] = {\n\t{ .compatible = \"nxp,ohci-nxp\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ohci_hcd_nxp_match);\n#endif\n\nstatic struct platform_driver ohci_hcd_nxp_driver = {\n\t.driver = {\n\t\t.name = \"usb-ohci\",\n\t\t.of_match_table = of_match_ptr(ohci_hcd_nxp_match),\n\t},\n\t.probe = ohci_hcd_nxp_probe,\n\t.remove_new = ohci_hcd_nxp_remove,\n};\n\nstatic int __init ohci_nxp_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_nxp_hc_driver, NULL);\n\treturn platform_driver_register(&ohci_hcd_nxp_driver);\n}\nmodule_init(ohci_nxp_init);\n\nstatic void __exit ohci_nxp_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_nxp_driver);\n}\nmodule_exit(ohci_nxp_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}