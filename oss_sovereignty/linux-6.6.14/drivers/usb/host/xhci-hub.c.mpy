{
  "module_name": "xhci-hub.c",
  "hash_id": "4eee9eb00cd5d48f3d798a6cb59c1d67901c4325b565024d1865e443f4fa0924",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-hub.c",
  "human_readable_source": "\n \n\n\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n#include <linux/bitfield.h>\n\n#include \"xhci.h\"\n#include \"xhci-trace.h\"\n\n#define\tPORT_WAKE_BITS\t(PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E)\n#define\tPORT_RWC_BITS\t(PORT_CSC | PORT_PEC | PORT_WRC | PORT_OCC | \\\n\t\t\t PORT_RC | PORT_PLC | PORT_PE)\n\n \nstatic u32 ssp_cap_default_ssa[] = {\n\t0x00050034,  \n\t0x000500b4,  \n\t0x000a4035,  \n\t0x000a40b5,  \n\t0x00054036,  \n\t0x000540b6,  \n\t0x000a4037,  \n\t0x000a40b7,  \n};\n\nstatic int xhci_create_usb3x_bos_desc(struct xhci_hcd *xhci, char *buf,\n\t\t\t\t      u16 wLength)\n{\n\tstruct usb_bos_descriptor\t*bos;\n\tstruct usb_ss_cap_descriptor\t*ss_cap;\n\tstruct usb_ssp_cap_descriptor\t*ssp_cap;\n\tstruct xhci_port_cap\t\t*port_cap = NULL;\n\tu16\t\t\t\tbcdUSB;\n\tu32\t\t\t\treg;\n\tu32\t\t\t\tmin_rate = 0;\n\tu8\t\t\t\tmin_ssid;\n\tu8\t\t\t\tssac;\n\tu8\t\t\t\tssic;\n\tint\t\t\t\toffset;\n\tint\t\t\t\ti;\n\n\t \n\tbos = (struct usb_bos_descriptor *)buf;\n\tbos->bLength = USB_DT_BOS_SIZE;\n\tbos->bDescriptorType = USB_DT_BOS;\n\tbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE +\n\t\t\t\t\tUSB_DT_USB_SS_CAP_SIZE);\n\tbos->bNumDeviceCaps = 1;\n\n\t \n\tfor (i = 0; i < xhci->num_port_caps; i++) {\n\t\tu8 major = xhci->port_caps[i].maj_rev;\n\t\tu8 minor = xhci->port_caps[i].min_rev;\n\t\tu16 rev = (major << 8) | minor;\n\n\t\tif (i == 0 || bcdUSB < rev) {\n\t\t\tbcdUSB = rev;\n\t\t\tport_cap = &xhci->port_caps[i];\n\t\t}\n\t}\n\n\tif (bcdUSB >= 0x0310) {\n\t\tif (port_cap->psi_count) {\n\t\t\tu8 num_sym_ssa = 0;\n\n\t\t\tfor (i = 0; i < port_cap->psi_count; i++) {\n\t\t\t\tif ((port_cap->psi[i] & PLT_MASK) == PLT_SYM)\n\t\t\t\t\tnum_sym_ssa++;\n\t\t\t}\n\n\t\t\tssac = port_cap->psi_count + num_sym_ssa - 1;\n\t\t\tssic = port_cap->psi_uid_count - 1;\n\t\t} else {\n\t\t\tif (bcdUSB >= 0x0320)\n\t\t\t\tssac = 7;\n\t\t\telse\n\t\t\t\tssac = 3;\n\n\t\t\tssic = (ssac + 1) / 2 - 1;\n\t\t}\n\n\t\tbos->bNumDeviceCaps++;\n\t\tbos->wTotalLength = cpu_to_le16(USB_DT_BOS_SIZE +\n\t\t\t\t\t\tUSB_DT_USB_SS_CAP_SIZE +\n\t\t\t\t\t\tUSB_DT_USB_SSP_CAP_SIZE(ssac));\n\t}\n\n\tif (wLength < USB_DT_BOS_SIZE + USB_DT_USB_SS_CAP_SIZE)\n\t\treturn wLength;\n\n\t \n\tss_cap = (struct usb_ss_cap_descriptor *)&buf[USB_DT_BOS_SIZE];\n\tss_cap->bLength = USB_DT_USB_SS_CAP_SIZE;\n\tss_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\tss_cap->bDevCapabilityType = USB_SS_CAP_TYPE;\n\tss_cap->bmAttributes = 0;  \n\tss_cap->wSpeedSupported = cpu_to_le16(USB_5GBPS_OPERATION);\n\tss_cap->bFunctionalitySupport = USB_LOW_SPEED_OPERATION;\n\tss_cap->bU1devExitLat = 0;  \n\tss_cap->bU2DevExitLat = 0;  \n\n\treg = readl(&xhci->cap_regs->hcc_params);\n\tif (HCC_LTC(reg))\n\t\tss_cap->bmAttributes |= USB_LTM_SUPPORT;\n\n\tif ((xhci->quirks & XHCI_LPM_SUPPORT)) {\n\t\treg = readl(&xhci->cap_regs->hcs_params3);\n\t\tss_cap->bU1devExitLat = HCS_U1_LATENCY(reg);\n\t\tss_cap->bU2DevExitLat = cpu_to_le16(HCS_U2_LATENCY(reg));\n\t}\n\n\tif (wLength < le16_to_cpu(bos->wTotalLength))\n\t\treturn wLength;\n\n\tif (bcdUSB < 0x0310)\n\t\treturn le16_to_cpu(bos->wTotalLength);\n\n\tssp_cap = (struct usb_ssp_cap_descriptor *)&buf[USB_DT_BOS_SIZE +\n\t\tUSB_DT_USB_SS_CAP_SIZE];\n\tssp_cap->bLength = USB_DT_USB_SSP_CAP_SIZE(ssac);\n\tssp_cap->bDescriptorType = USB_DT_DEVICE_CAPABILITY;\n\tssp_cap->bDevCapabilityType = USB_SSP_CAP_TYPE;\n\tssp_cap->bReserved = 0;\n\tssp_cap->wReserved = 0;\n\tssp_cap->bmAttributes =\n\t\tcpu_to_le32(FIELD_PREP(USB_SSP_SUBLINK_SPEED_ATTRIBS, ssac) |\n\t\t\t    FIELD_PREP(USB_SSP_SUBLINK_SPEED_IDS, ssic));\n\n\tif (!port_cap->psi_count) {\n\t\tfor (i = 0; i < ssac + 1; i++)\n\t\t\tssp_cap->bmSublinkSpeedAttr[i] =\n\t\t\t\tcpu_to_le32(ssp_cap_default_ssa[i]);\n\n\t\tmin_ssid = 4;\n\t\tgoto out;\n\t}\n\n\toffset = 0;\n\tfor (i = 0; i < port_cap->psi_count; i++) {\n\t\tu32 psi;\n\t\tu32 attr;\n\t\tu8 ssid;\n\t\tu8 lp;\n\t\tu8 lse;\n\t\tu8 psie;\n\t\tu16 lane_mantissa;\n\t\tu16 psim;\n\t\tu16 plt;\n\n\t\tpsi = port_cap->psi[i];\n\t\tssid = XHCI_EXT_PORT_PSIV(psi);\n\t\tlp = XHCI_EXT_PORT_LP(psi);\n\t\tpsie = XHCI_EXT_PORT_PSIE(psi);\n\t\tpsim = XHCI_EXT_PORT_PSIM(psi);\n\t\tplt = psi & PLT_MASK;\n\n\t\tlse = psie;\n\t\tlane_mantissa = psim;\n\n\t\t \n\t\tfor (; psie < USB_SSP_SUBLINK_SPEED_LSE_GBPS; psie++)\n\t\t\tpsim /= 1000;\n\n\t\tif (!min_rate || psim < min_rate) {\n\t\t\tmin_ssid = ssid;\n\t\t\tmin_rate = psim;\n\t\t}\n\n\t\t \n\t\tif (psim >= 10)\n\t\t\tlp = USB_SSP_SUBLINK_SPEED_LP_SSP;\n\n\t\t \n\t\tif (bcdUSB == 0x0320 && plt == PLT_SYM) {\n\t\t\t \n\t\t\tif (ssid == 6 && psie == 3 && psim == 10 && i) {\n\t\t\t\tu32 prev = port_cap->psi[i - 1];\n\n\t\t\t\tif ((prev & PLT_MASK) == PLT_SYM &&\n\t\t\t\t    XHCI_EXT_PORT_PSIV(prev) == 5 &&\n\t\t\t\t    XHCI_EXT_PORT_PSIE(prev) == 3 &&\n\t\t\t\t    XHCI_EXT_PORT_PSIM(prev) == 10) {\n\t\t\t\t\tlse = USB_SSP_SUBLINK_SPEED_LSE_GBPS;\n\t\t\t\t\tlane_mantissa = 5;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (psie == 3 && psim > 10) {\n\t\t\t\tlse = USB_SSP_SUBLINK_SPEED_LSE_GBPS;\n\t\t\t\tlane_mantissa = 10;\n\t\t\t}\n\t\t}\n\n\t\tattr = (FIELD_PREP(USB_SSP_SUBLINK_SPEED_SSID, ssid) |\n\t\t\tFIELD_PREP(USB_SSP_SUBLINK_SPEED_LP, lp) |\n\t\t\tFIELD_PREP(USB_SSP_SUBLINK_SPEED_LSE, lse) |\n\t\t\tFIELD_PREP(USB_SSP_SUBLINK_SPEED_LSM, lane_mantissa));\n\n\t\tswitch (plt) {\n\t\tcase PLT_SYM:\n\t\t\tattr |= FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST,\n\t\t\t\t\t   USB_SSP_SUBLINK_SPEED_ST_SYM_RX);\n\t\t\tssp_cap->bmSublinkSpeedAttr[offset++] = cpu_to_le32(attr);\n\n\t\t\tattr &= ~USB_SSP_SUBLINK_SPEED_ST;\n\t\t\tattr |= FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST,\n\t\t\t\t\t   USB_SSP_SUBLINK_SPEED_ST_SYM_TX);\n\t\t\tssp_cap->bmSublinkSpeedAttr[offset++] = cpu_to_le32(attr);\n\t\t\tbreak;\n\t\tcase PLT_ASYM_RX:\n\t\t\tattr |= FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST,\n\t\t\t\t\t   USB_SSP_SUBLINK_SPEED_ST_ASYM_RX);\n\t\t\tssp_cap->bmSublinkSpeedAttr[offset++] = cpu_to_le32(attr);\n\t\t\tbreak;\n\t\tcase PLT_ASYM_TX:\n\t\t\tattr |= FIELD_PREP(USB_SSP_SUBLINK_SPEED_ST,\n\t\t\t\t\t   USB_SSP_SUBLINK_SPEED_ST_ASYM_TX);\n\t\t\tssp_cap->bmSublinkSpeedAttr[offset++] = cpu_to_le32(attr);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tssp_cap->wFunctionalitySupport =\n\t\tcpu_to_le16(FIELD_PREP(USB_SSP_MIN_SUBLINK_SPEED_ATTRIBUTE_ID,\n\t\t\t\t       min_ssid) |\n\t\t\t    FIELD_PREP(USB_SSP_MIN_RX_LANE_COUNT, 1) |\n\t\t\t    FIELD_PREP(USB_SSP_MIN_TX_LANE_COUNT, 1));\n\n\treturn le16_to_cpu(bos->wTotalLength);\n}\n\nstatic void xhci_common_hub_descriptor(struct xhci_hcd *xhci,\n\t\tstruct usb_hub_descriptor *desc, int ports)\n{\n\tu16 temp;\n\n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ports;\n\ttemp = 0;\n\t \n\tif (HCC_PPC(xhci->hcc_params))\n\t\ttemp |= HUB_CHAR_INDV_PORT_LPSM;\n\telse\n\t\ttemp |= HUB_CHAR_NO_LPSM;\n\t \n\t \n\ttemp |= HUB_CHAR_INDV_PORT_OCPM;\n\t \n\t \n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n}\n\n \nstatic void xhci_usb2_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint ports;\n\tu16 temp;\n\t__u8 port_removable[(USB_MAXCHILDREN + 1 + 7) / 8];\n\tu32 portsc;\n\tunsigned int i;\n\tstruct xhci_hub *rhub;\n\n\trhub = &xhci->usb2_rhub;\n\tports = rhub->num_ports;\n\txhci_common_hub_descriptor(xhci, desc, ports);\n\tdesc->bDescriptorType = USB_DT_HUB;\n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = USB_DT_HUB_NONVAR_SIZE + 2 * temp;\n\tdesc->bPwrOn2PwrGood = 10;\t \n\n\t \n\tmemset(port_removable, 0, sizeof(port_removable));\n\tfor (i = 0; i < ports; i++) {\n\t\tportsc = readl(rhub->ports[i]->addr);\n\t\t \n\t\tif (portsc & PORT_DEV_REMOVE)\n\t\t\t \n\t\t\tport_removable[(i + 1) / 8] |= 1 << ((i + 1) % 8);\n\t}\n\n\t \n\tmemset(desc->u.hs.DeviceRemovable, 0xff,\n\t\t\tsizeof(desc->u.hs.DeviceRemovable));\n\tmemset(desc->u.hs.PortPwrCtrlMask, 0xff,\n\t\t\tsizeof(desc->u.hs.PortPwrCtrlMask));\n\n\tfor (i = 0; i < (ports + 1 + 7) / 8; i++)\n\t\tmemset(&desc->u.hs.DeviceRemovable[i], port_removable[i],\n\t\t\t\tsizeof(__u8));\n}\n\n \nstatic void xhci_usb3_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tint ports;\n\tu16 port_removable;\n\tu32 portsc;\n\tunsigned int i;\n\tstruct xhci_hub *rhub;\n\n\trhub = &xhci->usb3_rhub;\n\tports = rhub->num_ports;\n\txhci_common_hub_descriptor(xhci, desc, ports);\n\tdesc->bDescriptorType = USB_DT_SS_HUB;\n\tdesc->bDescLength = USB_DT_SS_HUB_SIZE;\n\tdesc->bPwrOn2PwrGood = 50;\t \n\n\t \n\tdesc->u.ss.bHubHdrDecLat = 0;\n\tdesc->u.ss.wHubDelay = 0;\n\n\tport_removable = 0;\n\t \n\tfor (i = 0; i < ports; i++) {\n\t\tportsc = readl(rhub->ports[i]->addr);\n\t\tif (portsc & PORT_DEV_REMOVE)\n\t\t\tport_removable |= 1 << (i + 1);\n\t}\n\n\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n}\n\nstatic void xhci_hub_descriptor(struct usb_hcd *hcd, struct xhci_hcd *xhci,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\n\tif (hcd->speed >= HCD_USB3)\n\t\txhci_usb3_hub_descriptor(hcd, xhci, desc);\n\telse\n\t\txhci_usb2_hub_descriptor(hcd, xhci, desc);\n\n}\n\nstatic unsigned int xhci_port_speed(unsigned int port_status)\n{\n\tif (DEV_LOWSPEED(port_status))\n\t\treturn USB_PORT_STAT_LOW_SPEED;\n\tif (DEV_HIGHSPEED(port_status))\n\t\treturn USB_PORT_STAT_HIGH_SPEED;\n\t \n\treturn 0;\n}\n\n \n#define\tXHCI_PORT_RO\t((1<<0) | (1<<3) | (0xf<<10) | (1<<30))\n \n#define XHCI_PORT_RWS\t((0xf<<5) | (1<<9) | (0x3<<14) | (0x7<<25))\n \n#define\tXHCI_PORT_RW1S\t((1<<4))\n \n#define XHCI_PORT_RW1CS\t((1<<1) | (0x7f<<17))\n \n#define\tXHCI_PORT_RW\t((1<<16))\n \n#define\tXHCI_PORT_RZ\t((1<<2) | (1<<24) | (0xf<<28))\n\n \n\nu32 xhci_port_state_to_neutral(u32 state)\n{\n\t \n\treturn (state & XHCI_PORT_RO) | (state & XHCI_PORT_RWS);\n}\nEXPORT_SYMBOL_GPL(xhci_port_state_to_neutral);\n\n \n\nint xhci_find_slot_id_by_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,\n\t\tu16 port)\n{\n\tint slot_id;\n\tint i;\n\tenum usb_device_speed speed;\n\n\tslot_id = 0;\n\tfor (i = 0; i < MAX_HC_SLOTS; i++) {\n\t\tif (!xhci->devs[i] || !xhci->devs[i]->udev)\n\t\t\tcontinue;\n\t\tspeed = xhci->devs[i]->udev->speed;\n\t\tif (((speed >= USB_SPEED_SUPER) == (hcd->speed >= HCD_USB3))\n\t\t\t\t&& xhci->devs[i]->fake_port == port) {\n\t\t\tslot_id = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn slot_id;\n}\nEXPORT_SYMBOL_GPL(xhci_find_slot_id_by_port);\n\n \nstatic int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)\n{\n\tstruct xhci_virt_device *virt_dev;\n\tstruct xhci_command *cmd;\n\tunsigned long flags;\n\tint ret;\n\tint i;\n\n\tret = 0;\n\tvirt_dev = xhci->devs[slot_id];\n\tif (!virt_dev)\n\t\treturn -ENODEV;\n\n\ttrace_xhci_stop_device(virt_dev);\n\n\tcmd = xhci_alloc_command(xhci, true, GFP_NOIO);\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\tfor (i = LAST_EP_INDEX; i > 0; i--) {\n\t\tif (virt_dev->eps[i].ring && virt_dev->eps[i].ring->dequeue) {\n\t\t\tstruct xhci_ep_ctx *ep_ctx;\n\t\t\tstruct xhci_command *command;\n\n\t\t\tep_ctx = xhci_get_ep_ctx(xhci, virt_dev->out_ctx, i);\n\n\t\t\t \n\t\t\tif (GET_EP_CTX_STATE(ep_ctx) != EP_STATE_RUNNING)\n\t\t\t\tcontinue;\n\n\t\t\tcommand = xhci_alloc_command(xhci, false, GFP_NOWAIT);\n\t\t\tif (!command) {\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cmd_cleanup;\n\t\t\t}\n\n\t\t\tret = xhci_queue_stop_endpoint(xhci, command, slot_id,\n\t\t\t\t\t\t       i, suspend);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\txhci_free_command(xhci, command);\n\t\t\t\tgoto cmd_cleanup;\n\t\t\t}\n\t\t}\n\t}\n\tret = xhci_queue_stop_endpoint(xhci, cmd, slot_id, 0, suspend);\n\tif (ret) {\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\tgoto cmd_cleanup;\n\t}\n\n\txhci_ring_cmd_db(xhci);\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\n\t \n\twait_for_completion(cmd->completion);\n\n\tif (cmd->status == COMP_COMMAND_ABORTED ||\n\t    cmd->status == COMP_COMMAND_RING_STOPPED) {\n\t\txhci_warn(xhci, \"Timeout while waiting for stop endpoint command\\n\");\n\t\tret = -ETIME;\n\t}\n\ncmd_cleanup:\n\txhci_free_command(xhci, cmd);\n\treturn ret;\n}\n\n \nvoid xhci_ring_device(struct xhci_hcd *xhci, int slot_id)\n{\n\tint i, s;\n\tstruct xhci_virt_ep *ep;\n\n\tfor (i = 0; i < LAST_EP_INDEX + 1; i++) {\n\t\tep = &xhci->devs[slot_id]->eps[i];\n\n\t\tif (ep->ep_state & EP_HAS_STREAMS) {\n\t\t\tfor (s = 1; s < ep->stream_info->num_streams; s++)\n\t\t\t\txhci_ring_ep_doorbell(xhci, slot_id, i, s);\n\t\t} else if (ep->ring && ep->ring->dequeue) {\n\t\t\txhci_ring_ep_doorbell(xhci, slot_id, i, 0);\n\t\t}\n\t}\n\n\treturn;\n}\n\nstatic void xhci_disable_port(struct xhci_hcd *xhci, struct xhci_port *port)\n{\n\tstruct usb_hcd *hcd;\n\tu32 portsc;\n\n\thcd = port->rhub->hcd;\n\n\t \n\tif (hcd->speed >= HCD_USB3) {\n\t\txhci_dbg(xhci, \"Ignoring request to disable SuperSpeed port.\\n\");\n\t\treturn;\n\t}\n\n\tif (xhci->quirks & XHCI_BROKEN_PORT_PED) {\n\t\txhci_dbg(xhci,\n\t\t\t \"Broken Port Enabled/Disabled, ignoring port disable request.\\n\");\n\t\treturn;\n\t}\n\n\tportsc = readl(port->addr);\n\tportsc = xhci_port_state_to_neutral(portsc);\n\n\t \n\twritel(portsc | PORT_PE, port->addr);\n\n\tportsc = readl(port->addr);\n\txhci_dbg(xhci, \"disable port %d-%d, portsc: 0x%x\\n\",\n\t\t hcd->self.busnum, port->hcd_portnum + 1, portsc);\n}\n\nstatic void xhci_clear_port_change_bit(struct xhci_hcd *xhci, u16 wValue,\n\t\tu16 wIndex, __le32 __iomem *addr, u32 port_status)\n{\n\tchar *port_change_bit;\n\tu32 status;\n\n\tswitch (wValue) {\n\tcase USB_PORT_FEAT_C_RESET:\n\t\tstatus = PORT_RC;\n\t\tport_change_bit = \"reset\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_BH_PORT_RESET:\n\t\tstatus = PORT_WRC;\n\t\tport_change_bit = \"warm(BH) reset\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tstatus = PORT_CSC;\n\t\tport_change_bit = \"connect\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\tstatus = PORT_OCC;\n\t\tport_change_bit = \"over-current\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tstatus = PORT_PEC;\n\t\tport_change_bit = \"enable/disable\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\tstatus = PORT_PLC;\n\t\tport_change_bit = \"suspend/resume\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_PORT_LINK_STATE:\n\t\tstatus = PORT_PLC;\n\t\tport_change_bit = \"link state\";\n\t\tbreak;\n\tcase USB_PORT_FEAT_C_PORT_CONFIG_ERROR:\n\t\tstatus = PORT_CEC;\n\t\tport_change_bit = \"config error\";\n\t\tbreak;\n\tdefault:\n\t\t \n\t\treturn;\n\t}\n\t \n\twritel(port_status | status, addr);\n\tport_status = readl(addr);\n\n\txhci_dbg(xhci, \"clear port%d %s change, portsc: 0x%x\\n\",\n\t\t wIndex + 1, port_change_bit, port_status);\n}\n\nstruct xhci_hub *xhci_get_rhub(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\n\tif (hcd->speed >= HCD_USB3)\n\t\treturn &xhci->usb3_rhub;\n\treturn &xhci->usb2_rhub;\n}\n\n \nstatic void xhci_set_port_power(struct xhci_hcd *xhci, struct xhci_port *port,\n\t\t\t\tbool on, unsigned long *flags)\n\t__must_hold(&xhci->lock)\n{\n\tstruct usb_hcd *hcd;\n\tu32 temp;\n\n\thcd = port->rhub->hcd;\n\ttemp = readl(port->addr);\n\n\txhci_dbg(xhci, \"set port power %d-%d %s, portsc: 0x%x\\n\",\n\t\t hcd->self.busnum, port->hcd_portnum + 1, on ? \"ON\" : \"OFF\", temp);\n\n\ttemp = xhci_port_state_to_neutral(temp);\n\n\tif (on) {\n\t\t \n\t\twritel(temp | PORT_POWER, port->addr);\n\t\treadl(port->addr);\n\t} else {\n\t\t \n\t\twritel(temp & ~PORT_POWER, port->addr);\n\t}\n\n\tspin_unlock_irqrestore(&xhci->lock, *flags);\n\ttemp = usb_acpi_power_manageable(hcd->self.root_hub,\n\t\t\t\t\t port->hcd_portnum);\n\tif (temp)\n\t\tusb_acpi_set_power_state(hcd->self.root_hub,\n\t\t\t\t\t port->hcd_portnum, on);\n\tspin_lock_irqsave(&xhci->lock, *flags);\n}\n\nstatic void xhci_port_set_test_mode(struct xhci_hcd *xhci,\n\tu16 test_mode, u16 wIndex)\n{\n\tu32 temp;\n\tstruct xhci_port *port;\n\n\t \n\tport = xhci->usb2_rhub.ports[wIndex];\n\ttemp = readl(port->addr + PORTPMSC);\n\ttemp |= test_mode << PORT_TEST_MODE_SHIFT;\n\twritel(temp, port->addr + PORTPMSC);\n\txhci->test_mode = test_mode;\n\tif (test_mode == USB_TEST_FORCE_ENABLE)\n\t\txhci_start(xhci);\n}\n\nstatic int xhci_enter_test_mode(struct xhci_hcd *xhci,\n\t\t\t\tu16 test_mode, u16 wIndex, unsigned long *flags)\n\t__must_hold(&xhci->lock)\n{\n\tint i, retval;\n\n\t \n\txhci_dbg(xhci, \"Disable all slots\\n\");\n\tspin_unlock_irqrestore(&xhci->lock, *flags);\n\tfor (i = 1; i <= HCS_MAX_SLOTS(xhci->hcs_params1); i++) {\n\t\tif (!xhci->devs[i])\n\t\t\tcontinue;\n\n\t\tretval = xhci_disable_slot(xhci, i);\n\t\txhci_free_virt_device(xhci, i);\n\t\tif (retval)\n\t\t\txhci_err(xhci, \"Failed to disable slot %d, %d. Enter test mode anyway\\n\",\n\t\t\t\t i, retval);\n\t}\n\tspin_lock_irqsave(&xhci->lock, *flags);\n\t \n\txhci_dbg(xhci, \"Disable all port (PP = 0)\\n\");\n\t \n\tfor (i = 0; i < xhci->usb3_rhub.num_ports; i++)\n\t\txhci_set_port_power(xhci, xhci->usb3_rhub.ports[i], false, flags);\n\t \n\tfor (i = 0; i < xhci->usb2_rhub.num_ports; i++)\n\t\txhci_set_port_power(xhci, xhci->usb2_rhub.ports[i], false, flags);\n\t \n\txhci_dbg(xhci, \"Stop controller\\n\");\n\tretval = xhci_halt(xhci);\n\tif (retval)\n\t\treturn retval;\n\t \n\tpm_runtime_forbid(xhci_to_hcd(xhci)->self.controller);\n\t \n\t \n\txhci_dbg(xhci, \"Enter Test Mode: %d, Port_id=%d\\n\",\n\t\t\t\t\ttest_mode, wIndex + 1);\n\txhci_port_set_test_mode(xhci, test_mode, wIndex);\n\treturn retval;\n}\n\nstatic int xhci_exit_test_mode(struct xhci_hcd *xhci)\n{\n\tint retval;\n\n\tif (!xhci->test_mode) {\n\t\txhci_err(xhci, \"Not in test mode, do nothing.\\n\");\n\t\treturn 0;\n\t}\n\tif (xhci->test_mode == USB_TEST_FORCE_ENABLE &&\n\t\t!(xhci->xhc_state & XHCI_STATE_HALTED)) {\n\t\tretval = xhci_halt(xhci);\n\t\tif (retval)\n\t\t\treturn retval;\n\t}\n\tpm_runtime_allow(xhci_to_hcd(xhci)->self.controller);\n\txhci->test_mode = 0;\n\treturn xhci_reset(xhci, XHCI_RESET_SHORT_USEC);\n}\n\nvoid xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,\n\t\t\t u32 link_state)\n{\n\tu32 temp;\n\tu32 portsc;\n\n\tportsc = readl(port->addr);\n\ttemp = xhci_port_state_to_neutral(portsc);\n\ttemp &= ~PORT_PLS_MASK;\n\ttemp |= PORT_LINK_STROBE | link_state;\n\twritel(temp, port->addr);\n\n\txhci_dbg(xhci, \"Set port %d-%d link state, portsc: 0x%x, write 0x%x\",\n\t\t port->rhub->hcd->self.busnum, port->hcd_portnum + 1,\n\t\t portsc, temp);\n}\n\nstatic void xhci_set_remote_wake_mask(struct xhci_hcd *xhci,\n\t\t\t\t      struct xhci_port *port, u16 wake_mask)\n{\n\tu32 temp;\n\n\ttemp = readl(port->addr);\n\ttemp = xhci_port_state_to_neutral(temp);\n\n\tif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_CONNECT)\n\t\ttemp |= PORT_WKCONN_E;\n\telse\n\t\ttemp &= ~PORT_WKCONN_E;\n\n\tif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_DISCONNECT)\n\t\ttemp |= PORT_WKDISC_E;\n\telse\n\t\ttemp &= ~PORT_WKDISC_E;\n\n\tif (wake_mask & USB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT)\n\t\ttemp |= PORT_WKOC_E;\n\telse\n\t\ttemp &= ~PORT_WKOC_E;\n\n\twritel(temp, port->addr);\n}\n\n \nvoid xhci_test_and_clear_bit(struct xhci_hcd *xhci, struct xhci_port *port,\n\t\t\t     u32 port_bit)\n{\n\tu32 temp;\n\n\ttemp = readl(port->addr);\n\tif (temp & port_bit) {\n\t\ttemp = xhci_port_state_to_neutral(temp);\n\t\ttemp |= port_bit;\n\t\twritel(temp, port->addr);\n\t}\n}\n\n \nstatic void xhci_hub_report_usb3_link_state(struct xhci_hcd *xhci,\n\t\tu32 *status, u32 status_reg)\n{\n\tu32 pls = status_reg & PORT_PLS_MASK;\n\n\t \n\tif (status_reg & PORT_CAS) {\n\t\t \n\t\tif (pls != USB_SS_PORT_LS_COMP_MOD &&\n\t\t    pls != USB_SS_PORT_LS_SS_INACTIVE) {\n\t\t\tpls = USB_SS_PORT_LS_COMP_MOD;\n\t\t}\n\t\t \n\t\tpls |= USB_PORT_STAT_CONNECTION;\n\t} else {\n\t\t \n\t\tif (pls == XDEV_RESUME) {\n\t\t\t*status |= USB_SS_PORT_LS_U3;\n\t\t\treturn;\n\t\t}\n\n\t\t \n\t\tif ((xhci->quirks & XHCI_COMP_MODE_QUIRK) &&\n\t\t\t\t(pls == USB_SS_PORT_LS_COMP_MOD))\n\t\t\tpls |= USB_PORT_STAT_CONNECTION;\n\t}\n\n\t \n\t*status |= pls;\n}\n\n \nstatic void xhci_del_comp_mod_timer(struct xhci_hcd *xhci, u32 status,\n\t\t\t\t    u16 wIndex)\n{\n\tu32 all_ports_seen_u0 = ((1 << xhci->usb3_rhub.num_ports) - 1);\n\tbool port_in_u0 = ((status & PORT_PLS_MASK) == XDEV_U0);\n\n\tif (!(xhci->quirks & XHCI_COMP_MODE_QUIRK))\n\t\treturn;\n\n\tif ((xhci->port_status_u0 != all_ports_seen_u0) && port_in_u0) {\n\t\txhci->port_status_u0 |= 1 << wIndex;\n\t\tif (xhci->port_status_u0 == all_ports_seen_u0) {\n\t\t\tdel_timer_sync(&xhci->comp_mode_recovery_timer);\n\t\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"All USB3 ports have entered U0 already!\");\n\t\t\txhci_dbg_trace(xhci, trace_xhci_dbg_quirks,\n\t\t\t\t\"Compliance Mode Recovery Timer Deleted.\");\n\t\t}\n\t}\n}\n\nstatic int xhci_handle_usb2_port_link_resume(struct xhci_port *port,\n\t\t\t\t\t     u32 portsc,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct xhci_bus_state *bus_state;\n\tstruct xhci_hcd\t*xhci;\n\tstruct usb_hcd *hcd;\n\tint slot_id;\n\tu32 wIndex;\n\n\thcd = port->rhub->hcd;\n\tbus_state = &port->rhub->bus_state;\n\txhci = hcd_to_xhci(hcd);\n\twIndex = port->hcd_portnum;\n\n\tif ((portsc & PORT_RESET) || !(portsc & PORT_PE)) {\n\t\treturn -EINVAL;\n\t}\n\t \n\tif (!port->resume_timestamp) {\n\t\t \n\t\tif (test_bit(wIndex, &bus_state->resuming_ports)) {\n\t\t\t \n\t\t} else {\n\t\t\t \n\t\t\tunsigned long timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\n\t\t\tset_bit(wIndex, &bus_state->resuming_ports);\n\t\t\tport->resume_timestamp = timeout;\n\t\t\tmod_timer(&hcd->rh_timer, timeout);\n\t\t\tusb_hcd_start_port_resume(&hcd->self, wIndex);\n\t\t}\n\t \n\t} else if (time_after_eq(jiffies, port->resume_timestamp)) {\n\t\tint time_left;\n\n\t\txhci_dbg(xhci, \"resume USB2 port %d-%d\\n\",\n\t\t\t hcd->self.busnum, wIndex + 1);\n\n\t\tport->resume_timestamp = 0;\n\t\tclear_bit(wIndex, &bus_state->resuming_ports);\n\n\t\treinit_completion(&port->rexit_done);\n\t\tport->rexit_active = true;\n\n\t\txhci_test_and_clear_bit(xhci, port, PORT_PLC);\n\t\txhci_set_link_state(xhci, port, XDEV_U0);\n\n\t\tspin_unlock_irqrestore(&xhci->lock, *flags);\n\t\ttime_left = wait_for_completion_timeout(\n\t\t\t&port->rexit_done,\n\t\t\tmsecs_to_jiffies(XHCI_MAX_REXIT_TIMEOUT_MS));\n\t\tspin_lock_irqsave(&xhci->lock, *flags);\n\n\t\tif (time_left) {\n\t\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci,\n\t\t\t\t\t\t\t    wIndex + 1);\n\t\t\tif (!slot_id) {\n\t\t\t\txhci_dbg(xhci, \"slot_id is zero\\n\");\n\t\t\t\treturn -ENODEV;\n\t\t\t}\n\t\t\txhci_ring_device(xhci, slot_id);\n\t\t} else {\n\t\t\tint port_status = readl(port->addr);\n\n\t\t\txhci_warn(xhci, \"Port resume timed out, port %d-%d: 0x%x\\n\",\n\t\t\t\t  hcd->self.busnum, wIndex + 1, port_status);\n\t\t\t \n\t\t}\n\n\t\tusb_hcd_end_port_resume(&hcd->self, wIndex);\n\t\tbus_state->port_c_suspend |= 1 << wIndex;\n\t\tbus_state->suspended_ports &= ~(1 << wIndex);\n\t}\n\n\treturn 0;\n}\n\nstatic u32 xhci_get_ext_port_status(u32 raw_port_status, u32 port_li)\n{\n\tu32 ext_stat = 0;\n\tint speed_id;\n\n\t \n\tspeed_id = DEV_PORT_SPEED(raw_port_status);\n\text_stat |= speed_id;\t\t \n\text_stat |= speed_id << 4;\t \n\n\text_stat |= PORT_RX_LANES(port_li) << 8;   \n\text_stat |= PORT_TX_LANES(port_li) << 12;  \n\n\treturn ext_stat;\n}\n\nstatic void xhci_get_usb3_port_status(struct xhci_port *port, u32 *status,\n\t\t\t\t      u32 portsc)\n{\n\tstruct xhci_bus_state *bus_state;\n\tstruct xhci_hcd\t*xhci;\n\tstruct usb_hcd *hcd;\n\tu32 link_state;\n\tu32 portnum;\n\n\tbus_state = &port->rhub->bus_state;\n\txhci = hcd_to_xhci(port->rhub->hcd);\n\thcd = port->rhub->hcd;\n\tlink_state = portsc & PORT_PLS_MASK;\n\tportnum = port->hcd_portnum;\n\n\t \n\n\tif (portsc & PORT_PLC && (link_state != XDEV_RESUME))\n\t\t*status |= USB_PORT_STAT_C_LINK_STATE << 16;\n\tif (portsc & PORT_WRC)\n\t\t*status |= USB_PORT_STAT_C_BH_RESET << 16;\n\tif (portsc & PORT_CEC)\n\t\t*status |= USB_PORT_STAT_C_CONFIG_ERROR << 16;\n\n\t \n\tif (portsc & PORT_POWER)\n\t\t*status |= USB_SS_PORT_STAT_POWER;\n\n\t \n\tif (link_state != XDEV_U3 &&\n\t    link_state != XDEV_RESUME &&\n\t    link_state != XDEV_RECOVERY) {\n\t\t \n\t\tif (bus_state->port_remote_wakeup & (1 << portnum)) {\n\t\t\tbus_state->port_remote_wakeup &= ~(1 << portnum);\n\t\t\tusb_hcd_end_port_resume(&hcd->self, portnum);\n\t\t}\n\t\tbus_state->suspended_ports &= ~(1 << portnum);\n\t}\n\n\txhci_hub_report_usb3_link_state(xhci, status, portsc);\n\txhci_del_comp_mod_timer(xhci, portsc, portnum);\n}\n\nstatic void xhci_get_usb2_port_status(struct xhci_port *port, u32 *status,\n\t\t\t\t      u32 portsc, unsigned long *flags)\n{\n\tstruct xhci_bus_state *bus_state;\n\tu32 link_state;\n\tu32 portnum;\n\tint err;\n\n\tbus_state = &port->rhub->bus_state;\n\tlink_state = portsc & PORT_PLS_MASK;\n\tportnum = port->hcd_portnum;\n\n\t \n\tif (portsc & PORT_POWER) {\n\t\t*status |= USB_PORT_STAT_POWER;\n\n\t\t \n\t\tif (link_state == XDEV_U3)\n\t\t\t*status |= USB_PORT_STAT_SUSPEND;\n\t\tif (link_state == XDEV_U2)\n\t\t\t*status |= USB_PORT_STAT_L1;\n\t\tif (link_state == XDEV_U0) {\n\t\t\tif (bus_state->suspended_ports & (1 << portnum)) {\n\t\t\t\tbus_state->suspended_ports &= ~(1 << portnum);\n\t\t\t\tbus_state->port_c_suspend |= 1 << portnum;\n\t\t\t}\n\t\t}\n\t\tif (link_state == XDEV_RESUME) {\n\t\t\terr = xhci_handle_usb2_port_link_resume(port, portsc,\n\t\t\t\t\t\t\t\tflags);\n\t\t\tif (err < 0)\n\t\t\t\t*status = 0xffffffff;\n\t\t\telse if (port->resume_timestamp || port->rexit_active)\n\t\t\t\t*status |= USB_PORT_STAT_SUSPEND;\n\t\t}\n\t}\n\n\t \n\tif (link_state != XDEV_U3 && link_state != XDEV_RESUME) {\n\t\tif (port->resume_timestamp ||\n\t\t    test_bit(portnum, &bus_state->resuming_ports)) {\n\t\t\tport->resume_timestamp = 0;\n\t\t\tclear_bit(portnum, &bus_state->resuming_ports);\n\t\t\tusb_hcd_end_port_resume(&port->rhub->hcd->self, portnum);\n\t\t}\n\t\tport->rexit_active = 0;\n\t\tbus_state->suspended_ports &= ~(1 << portnum);\n\t}\n}\n\n \nstatic u32 xhci_get_port_status(struct usb_hcd *hcd,\n\t\tstruct xhci_bus_state *bus_state,\n\tu16 wIndex, u32 raw_port_status,\n\t\tunsigned long *flags)\n\t__releases(&xhci->lock)\n\t__acquires(&xhci->lock)\n{\n\tu32 status = 0;\n\tstruct xhci_hub *rhub;\n\tstruct xhci_port *port;\n\n\trhub = xhci_get_rhub(hcd);\n\tport = rhub->ports[wIndex];\n\n\t \n\tif (raw_port_status & PORT_CSC)\n\t\tstatus |= USB_PORT_STAT_C_CONNECTION << 16;\n\tif (raw_port_status & PORT_PEC)\n\t\tstatus |= USB_PORT_STAT_C_ENABLE << 16;\n\tif ((raw_port_status & PORT_OCC))\n\t\tstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\n\tif ((raw_port_status & PORT_RC))\n\t\tstatus |= USB_PORT_STAT_C_RESET << 16;\n\n\t \n\tif (raw_port_status & PORT_CONNECT) {\n\t\tstatus |= USB_PORT_STAT_CONNECTION;\n\t\tstatus |= xhci_port_speed(raw_port_status);\n\t}\n\tif (raw_port_status & PORT_PE)\n\t\tstatus |= USB_PORT_STAT_ENABLE;\n\tif (raw_port_status & PORT_OC)\n\t\tstatus |= USB_PORT_STAT_OVERCURRENT;\n\tif (raw_port_status & PORT_RESET)\n\t\tstatus |= USB_PORT_STAT_RESET;\n\n\t \n\tif (hcd->speed >= HCD_USB3)\n\t\txhci_get_usb3_port_status(port, &status, raw_port_status);\n\telse\n\t\txhci_get_usb2_port_status(port, &status, raw_port_status,\n\t\t\t\t\t  flags);\n\n\tif (bus_state->port_c_suspend & (1 << wIndex))\n\t\tstatus |= USB_PORT_STAT_C_SUSPEND << 16;\n\n\treturn status;\n}\n\nint xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\tu16 wIndex, char *buf, u16 wLength)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint max_ports;\n\tunsigned long flags;\n\tu32 temp, status;\n\tint retval = 0;\n\tint slot_id;\n\tstruct xhci_bus_state *bus_state;\n\tu16 link_state = 0;\n\tu16 wake_mask = 0;\n\tu16 timeout = 0;\n\tu16 test_mode = 0;\n\tstruct xhci_hub *rhub;\n\tstruct xhci_port **ports;\n\tstruct xhci_port *port;\n\tint portnum1;\n\n\trhub = xhci_get_rhub(hcd);\n\tports = rhub->ports;\n\tmax_ports = rhub->num_ports;\n\tbus_state = &rhub->bus_state;\n\tportnum1 = wIndex & 0xff;\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\tswitch (typeReq) {\n\tcase GetHubStatus:\n\t\t \n\t\tmemset(buf, 0, 4);\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\t \n\t\tif (hcd->speed >= HCD_USB3 &&\n\t\t\t\t(wLength < USB_DT_SS_HUB_SIZE ||\n\t\t\t\t wValue != (USB_DT_SS_HUB << 8))) {\n\t\t\txhci_dbg(xhci, \"Wrong hub descriptor type for \"\n\t\t\t\t\t\"USB 3.0 roothub.\\n\");\n\t\t\tgoto error;\n\t\t}\n\t\txhci_hub_descriptor(hcd, xhci,\n\t\t\t\t(struct usb_hub_descriptor *) buf);\n\t\tbreak;\n\tcase DeviceRequest | USB_REQ_GET_DESCRIPTOR:\n\t\tif ((wValue & 0xff00) != (USB_DT_BOS << 8))\n\t\t\tgoto error;\n\n\t\tif (hcd->speed < HCD_USB3)\n\t\t\tgoto error;\n\n\t\tretval = xhci_create_usb3x_bos_desc(xhci, buf, wLength);\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\treturn retval;\n\tcase GetPortStatus:\n\t\tif (!portnum1 || portnum1 > max_ports)\n\t\t\tgoto error;\n\n\t\twIndex--;\n\t\tport = ports[portnum1 - 1];\n\t\ttemp = readl(port->addr);\n\t\tif (temp == ~(u32)0) {\n\t\t\txhci_hc_died(xhci);\n\t\t\tretval = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xhci_get_port_status(wIndex, temp);\n\t\tstatus = xhci_get_port_status(hcd, bus_state, wIndex, temp,\n\t\t\t\t\t      &flags);\n\t\tif (status == 0xffffffff)\n\t\t\tgoto error;\n\n\t\txhci_dbg(xhci, \"Get port status %d-%d read: 0x%x, return 0x%x\",\n\t\t\t hcd->self.busnum, portnum1, temp, status);\n\n\t\tput_unaligned(cpu_to_le32(status), (__le32 *) buf);\n\t\t \n\t\tif (wValue == 0x02) {\n\t\t\tu32 port_li;\n\n\t\t\tif (hcd->speed < HCD_USB31 || wLength != 8) {\n\t\t\t\txhci_err(xhci, \"get ext port status invalid parameter\\n\");\n\t\t\t\tretval = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tport_li = readl(port->addr + PORTLI);\n\t\t\tstatus = xhci_get_ext_port_status(temp, port_li);\n\t\t\tput_unaligned_le32(status, &buf[4]);\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (wValue == USB_PORT_FEAT_LINK_STATE)\n\t\t\tlink_state = (wIndex & 0xff00) >> 3;\n\t\tif (wValue == USB_PORT_FEAT_REMOTE_WAKE_MASK)\n\t\t\twake_mask = wIndex & 0xff00;\n\t\tif (wValue == USB_PORT_FEAT_TEST)\n\t\t\ttest_mode = (wIndex & 0xff00) >> 8;\n\t\t \n\t\ttimeout = (wIndex & 0xff00) >> 8;\n\n\t\twIndex &= 0xff;\n\t\tif (!portnum1 || portnum1 > max_ports)\n\t\t\tgoto error;\n\n\t\tport = ports[portnum1 - 1];\n\t\twIndex--;\n\t\ttemp = readl(port->addr);\n\t\tif (temp == ~(u32)0) {\n\t\t\txhci_hc_died(xhci);\n\t\t\tretval = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\ttemp = xhci_port_state_to_neutral(temp);\n\t\t \n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\ttemp = readl(port->addr);\n\t\t\tif ((temp & PORT_PLS_MASK) != XDEV_U0) {\n\t\t\t\t \n\t\t\t\txhci_set_link_state(xhci, port, XDEV_U0);\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\tmsleep(10);\n\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t}\n\t\t\t \n\t\t\ttemp = readl(port->addr);\n\t\t\tif ((temp & PORT_PE) == 0 || (temp & PORT_RESET)\n\t\t\t\t|| (temp & PORT_PLS_MASK) >= XDEV_U3) {\n\t\t\t\txhci_warn(xhci, \"USB core suspending port %d-%d not in U0/U1/U2\\n\",\n\t\t\t\t\t  hcd->self.busnum, portnum1);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci,\n\t\t\t\t\t\t\t    portnum1);\n\t\t\tif (!slot_id) {\n\t\t\t\txhci_warn(xhci, \"slot_id is zero\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\t \n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\txhci_stop_device(xhci, slot_id, 1);\n\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\n\t\t\txhci_set_link_state(xhci, port, XDEV_U3);\n\n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\tmsleep(10);  \n\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\n\t\t\ttemp = readl(port->addr);\n\t\t\tbus_state->suspended_ports |= 1 << wIndex;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_LINK_STATE:\n\t\t\ttemp = readl(port->addr);\n\t\t\t \n\t\t\tif (link_state == USB_SS_PORT_LS_SS_DISABLED) {\n\t\t\t\txhci_dbg(xhci, \"Disable port %d-%d\\n\",\n\t\t\t\t\t hcd->self.busnum, portnum1);\n\t\t\t\ttemp = xhci_port_state_to_neutral(temp);\n\t\t\t\t \n\t\t\t\ttemp |= PORT_CSC | PORT_PEC | PORT_WRC |\n\t\t\t\t\tPORT_OCC | PORT_RC | PORT_PLC |\n\t\t\t\t\tPORT_CEC;\n\t\t\t\twritel(temp | PORT_PE, port->addr);\n\t\t\t\ttemp = readl(port->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (link_state == USB_SS_PORT_LS_RX_DETECT) {\n\t\t\t\txhci_dbg(xhci, \"Enable port %d-%d\\n\",\n\t\t\t\t\t hcd->self.busnum, portnum1);\n\t\t\t\txhci_set_link_state(xhci, port,\tlink_state);\n\t\t\t\ttemp = readl(port->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (link_state == USB_SS_PORT_LS_COMP_MOD) {\n\t\t\t\tif (!HCC2_CTC(xhci->hcc_params2)) {\n\t\t\t\t\txhci_dbg(xhci, \"CTC flag is 0, port already supports entering compliance mode\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ((temp & PORT_CONNECT)) {\n\t\t\t\t\txhci_warn(xhci, \"Can't set compliance mode when port is connected\\n\");\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\n\t\t\t\txhci_dbg(xhci, \"Enable compliance mode transition for port %d-%d\\n\",\n\t\t\t\t\t hcd->self.busnum, portnum1);\n\t\t\t\txhci_set_link_state(xhci, port, link_state);\n\n\t\t\t\ttemp = readl(port->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (!(temp & PORT_PE)) {\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t \n\t\t\tif (link_state > USB_SS_PORT_LS_U3) {\n\t\t\t\txhci_warn(xhci, \"Cannot set port %d-%d link state %d\\n\",\n\t\t\t\t\t  hcd->self.busnum, portnum1, link_state);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (link_state == USB_SS_PORT_LS_U0) {\n\t\t\t\tu32 pls = temp & PORT_PLS_MASK;\n\t\t\t\tbool wait_u0 = false;\n\n\t\t\t\t \n\t\t\t\tif (pls == XDEV_U0)\n\t\t\t\t\tbreak;\n\t\t\t\tif (pls == XDEV_U3 ||\n\t\t\t\t    pls == XDEV_RESUME ||\n\t\t\t\t    pls == XDEV_RECOVERY) {\n\t\t\t\t\twait_u0 = true;\n\t\t\t\t\treinit_completion(&port->u3exit_done);\n\t\t\t\t}\n\t\t\t\tif (pls <= XDEV_U3)  \n\t\t\t\t\txhci_set_link_state(xhci, port, USB_SS_PORT_LS_U0);\n\t\t\t\tif (!wait_u0) {\n\t\t\t\t\tif (pls > XDEV_U3)\n\t\t\t\t\t\tgoto error;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\tif (!wait_for_completion_timeout(&port->u3exit_done,\n\t\t\t\t\t\t\t\t msecs_to_jiffies(500)))\n\t\t\t\t\txhci_dbg(xhci, \"missing U0 port change event for port %d-%d\\n\",\n\t\t\t\t\t\t hcd->self.busnum, portnum1);\n\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t\ttemp = readl(port->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (link_state == USB_SS_PORT_LS_U3) {\n\t\t\t\tint retries = 16;\n\t\t\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci,\n\t\t\t\t\t\t\t\t    portnum1);\n\t\t\t\tif (slot_id) {\n\t\t\t\t\t \n\t\t\t\t\tspin_unlock_irqrestore(&xhci->lock,\n\t\t\t\t\t\t\t\tflags);\n\t\t\t\t\txhci_stop_device(xhci, slot_id, 1);\n\t\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t\t}\n\t\t\t\txhci_set_link_state(xhci, port, USB_SS_PORT_LS_U3);\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\twhile (retries--) {\n\t\t\t\t\tusleep_range(4000, 8000);\n\t\t\t\t\ttemp = readl(port->addr);\n\t\t\t\t\tif ((temp & PORT_PLS_MASK) == XDEV_U3)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t\ttemp = readl(port->addr);\n\t\t\t\tbus_state->suspended_ports |= 1 << wIndex;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\t \n\t\t\txhci_set_port_power(xhci, port, true, &flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\ttemp = (temp | PORT_RESET);\n\t\t\twritel(temp, port->addr);\n\n\t\t\ttemp = readl(port->addr);\n\t\t\txhci_dbg(xhci, \"set port reset, actual port %d-%d status  = 0x%x\\n\",\n\t\t\t\t hcd->self.busnum, portnum1, temp);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_REMOTE_WAKE_MASK:\n\t\t\txhci_set_remote_wake_mask(xhci, port, wake_mask);\n\t\t\ttemp = readl(port->addr);\n\t\t\txhci_dbg(xhci, \"set port remote wake mask, actual port %d-%d status  = 0x%x\\n\",\n\t\t\t\t hcd->self.busnum, portnum1, temp);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_BH_PORT_RESET:\n\t\t\ttemp |= PORT_WR;\n\t\t\twritel(temp, port->addr);\n\t\t\ttemp = readl(port->addr);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_U1_TIMEOUT:\n\t\t\tif (hcd->speed < HCD_USB3)\n\t\t\t\tgoto error;\n\t\t\ttemp = readl(port->addr + PORTPMSC);\n\t\t\ttemp &= ~PORT_U1_TIMEOUT_MASK;\n\t\t\ttemp |= PORT_U1_TIMEOUT(timeout);\n\t\t\twritel(temp, port->addr + PORTPMSC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_U2_TIMEOUT:\n\t\t\tif (hcd->speed < HCD_USB3)\n\t\t\t\tgoto error;\n\t\t\ttemp = readl(port->addr + PORTPMSC);\n\t\t\ttemp &= ~PORT_U2_TIMEOUT_MASK;\n\t\t\ttemp |= PORT_U2_TIMEOUT(timeout);\n\t\t\twritel(temp, port->addr + PORTPMSC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\t \n\t\t\tif (hcd->speed != HCD_USB2)\n\t\t\t\tgoto error;\n\t\t\tif (test_mode > USB_TEST_FORCE_ENABLE ||\n\t\t\t    test_mode < USB_TEST_J)\n\t\t\t\tgoto error;\n\t\t\tretval = xhci_enter_test_mode(xhci, test_mode, wIndex,\n\t\t\t\t\t\t      &flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\t \n\t\ttemp = readl(port->addr);\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!portnum1 || portnum1 > max_ports)\n\t\t\tgoto error;\n\n\t\tport = ports[portnum1 - 1];\n\n\t\twIndex--;\n\t\ttemp = readl(port->addr);\n\t\tif (temp == ~(u32)0) {\n\t\t\txhci_hc_died(xhci);\n\t\t\tretval = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\ttemp = xhci_port_state_to_neutral(temp);\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\ttemp = readl(port->addr);\n\t\t\txhci_dbg(xhci, \"clear USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\txhci_dbg(xhci, \"PORTSC %04x\\n\", temp);\n\t\t\tif (temp & PORT_RESET)\n\t\t\t\tgoto error;\n\t\t\tif ((temp & PORT_PLS_MASK) == XDEV_U3) {\n\t\t\t\tif ((temp & PORT_PE) == 0)\n\t\t\t\t\tgoto error;\n\n\t\t\t\tset_bit(wIndex, &bus_state->resuming_ports);\n\t\t\t\tusb_hcd_start_port_resume(&hcd->self, wIndex);\n\t\t\t\txhci_set_link_state(xhci, port, XDEV_RESUME);\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t\txhci_set_link_state(xhci, port, XDEV_U0);\n\t\t\t\tclear_bit(wIndex, &bus_state->resuming_ports);\n\t\t\t\tusb_hcd_end_port_resume(&hcd->self, wIndex);\n\t\t\t}\n\t\t\tbus_state->port_c_suspend |= 1 << wIndex;\n\n\t\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci,\n\t\t\t\t\tportnum1);\n\t\t\tif (!slot_id) {\n\t\t\t\txhci_dbg(xhci, \"slot_id is zero\\n\");\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\txhci_ring_device(xhci, slot_id);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tbus_state->port_c_suspend &= ~(1 << wIndex);\n\t\t\tfallthrough;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\tcase USB_PORT_FEAT_C_BH_PORT_RESET:\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\tcase USB_PORT_FEAT_C_PORT_LINK_STATE:\n\t\tcase USB_PORT_FEAT_C_PORT_CONFIG_ERROR:\n\t\t\txhci_clear_port_change_bit(xhci, wValue, wIndex,\n\t\t\t\t\tport->addr, temp);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\txhci_disable_port(xhci, port);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\txhci_set_port_power(xhci, port, false, &flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\tretval = xhci_exit_test_mode(xhci);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(xhci_hub_control);\n\n \nint xhci_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tunsigned long flags;\n\tu32 temp, status;\n\tu32 mask;\n\tint i, retval;\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint max_ports;\n\tstruct xhci_bus_state *bus_state;\n\tbool reset_change = false;\n\tstruct xhci_hub *rhub;\n\tstruct xhci_port **ports;\n\n\trhub = xhci_get_rhub(hcd);\n\tports = rhub->ports;\n\tmax_ports = rhub->num_ports;\n\tbus_state = &rhub->bus_state;\n\n\t \n\tretval = (max_ports + 8) / 8;\n\tmemset(buf, 0, retval);\n\n\t \n\tspin_lock_irqsave(&xhci->lock, flags);\n\n\tstatus = bus_state->resuming_ports;\n\n\t \n\tif (xhci->run_graceperiod) {\n\t\tif (time_before(jiffies, xhci->run_graceperiod))\n\t\t\tstatus = 1;\n\t\telse\n\t\t\txhci->run_graceperiod = 0;\n\t}\n\n\tmask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC | PORT_CEC;\n\n\t \n\tfor (i = 0; i < max_ports; i++) {\n\t\ttemp = readl(ports[i]->addr);\n\t\tif (temp == ~(u32)0) {\n\t\t\txhci_hc_died(xhci);\n\t\t\tretval = -ENODEV;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_xhci_hub_status_data(i, temp);\n\n\t\tif ((temp & mask) != 0 ||\n\t\t\t(bus_state->port_c_suspend & 1 << i) ||\n\t\t\t(ports[i]->resume_timestamp && time_after_eq(\n\t\t\t    jiffies, ports[i]->resume_timestamp))) {\n\t\t\tbuf[(i + 1) / 8] |= 1 << (i + 1) % 8;\n\t\t\tstatus = 1;\n\t\t}\n\t\tif ((temp & PORT_RC))\n\t\t\treset_change = true;\n\t\tif (temp & PORT_OC)\n\t\t\tstatus = 1;\n\t}\n\tif (!status && !reset_change) {\n\t\txhci_dbg(xhci, \"%s: stopping usb%d port polling\\n\",\n\t\t\t __func__, hcd->self.busnum);\n\t\tclear_bit(HCD_FLAG_POLL_RH, &hcd->flags);\n\t}\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\treturn status ? retval : 0;\n}\n\n#ifdef CONFIG_PM\n\nint xhci_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint max_ports, port_index;\n\tstruct xhci_bus_state *bus_state;\n\tunsigned long flags;\n\tstruct xhci_hub *rhub;\n\tstruct xhci_port **ports;\n\tu32 portsc_buf[USB_MAXCHILDREN];\n\tbool wake_enabled;\n\n\trhub = xhci_get_rhub(hcd);\n\tports = rhub->ports;\n\tmax_ports = rhub->num_ports;\n\tbus_state = &rhub->bus_state;\n\twake_enabled = hcd->self.root_hub->do_remote_wakeup;\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\n\tif (wake_enabled) {\n\t\tif (bus_state->resuming_ports ||\t \n\t\t    bus_state->port_remote_wakeup) {\t \n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\txhci_dbg(xhci, \"usb%d bus suspend to fail because a port is resuming\\n\",\n\t\t\t\t hcd->self.busnum);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\t \n\tbus_state->bus_suspended = 0;\n\tport_index = max_ports;\n\twhile (port_index--) {\n\t\tu32 t1, t2;\n\t\tint retries = 10;\nretry:\n\t\tt1 = readl(ports[port_index]->addr);\n\t\tt2 = xhci_port_state_to_neutral(t1);\n\t\tportsc_buf[port_index] = 0;\n\n\t\t \n\t\tif ((hcd->speed >= HCD_USB3) && retries-- &&\n\t\t    (t1 & PORT_PLS_MASK) == XDEV_POLLING) {\n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\tmsleep(XHCI_PORT_POLLING_LFPS_TIME);\n\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\txhci_dbg(xhci, \"port %d-%d polling in bus suspend, waiting\\n\",\n\t\t\t\t hcd->self.busnum, port_index + 1);\n\t\t\tgoto retry;\n\t\t}\n\t\t \n\t\tif (t1 & PORT_OC) {\n\t\t\tbus_state->bus_suspended = 0;\n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\txhci_dbg(xhci, \"Bus suspend bailout, port over-current detected\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t\t \n\t\tif ((t1 & PORT_PE) && (t1 & PORT_PLS_MASK) == XDEV_U0) {\n\t\t\tif ((t1 & PORT_CSC) && wake_enabled) {\n\t\t\t\tbus_state->bus_suspended = 0;\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\txhci_dbg(xhci, \"Bus suspend bailout, port connect change\\n\");\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\txhci_dbg(xhci, \"port %d-%d not suspended\\n\",\n\t\t\t\t hcd->self.busnum, port_index + 1);\n\t\t\tt2 &= ~PORT_PLS_MASK;\n\t\t\tt2 |= PORT_LINK_STROBE | XDEV_U3;\n\t\t\tset_bit(port_index, &bus_state->bus_suspended);\n\t\t}\n\t\t \n\t\tif (wake_enabled) {\n\t\t\tif (t1 & PORT_CONNECT) {\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKDISC_E;\n\t\t\t\tt2 &= ~PORT_WKCONN_E;\n\t\t\t} else {\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKCONN_E;\n\t\t\t\tt2 &= ~PORT_WKDISC_E;\n\t\t\t}\n\n\t\t\tif ((xhci->quirks & XHCI_U2_DISABLE_WAKE) &&\n\t\t\t    (hcd->speed < HCD_USB3)) {\n\t\t\t\tif (usb_amd_pt_check_port(hcd->self.controller,\n\t\t\t\t\t\t\t  port_index))\n\t\t\t\t\tt2 &= ~PORT_WAKE_BITS;\n\t\t\t}\n\t\t} else\n\t\t\tt2 &= ~PORT_WAKE_BITS;\n\n\t\tt1 = xhci_port_state_to_neutral(t1);\n\t\tif (t1 != t2)\n\t\t\tportsc_buf[port_index] = t2;\n\t}\n\n\t \n\tport_index = max_ports;\n\twhile (port_index--) {\n\t\tif (!portsc_buf[port_index])\n\t\t\tcontinue;\n\t\tif (test_bit(port_index, &bus_state->bus_suspended)) {\n\t\t\tint slot_id;\n\n\t\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci,\n\t\t\t\t\t\t\t    port_index + 1);\n\t\t\tif (slot_id) {\n\t\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\t\txhci_stop_device(xhci, slot_id, 1);\n\t\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t\t}\n\t\t}\n\t\twritel(portsc_buf[port_index], ports[port_index]->addr);\n\t}\n\thcd->state = HC_STATE_SUSPENDED;\n\tbus_state->next_statechange = jiffies + msecs_to_jiffies(10);\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\n\tif (bus_state->bus_suspended)\n\t\tusleep_range(5000, 10000);\n\n\treturn 0;\n}\n\n \nstatic bool xhci_port_missing_cas_quirk(struct xhci_port *port)\n{\n\tu32 portsc;\n\n\tportsc = readl(port->addr);\n\n\t \n\tif (portsc & (PORT_CONNECT | PORT_CAS))\n\t\treturn false;\n\n\tif (((portsc & PORT_PLS_MASK) != XDEV_POLLING) &&\n\t    ((portsc & PORT_PLS_MASK) != XDEV_COMP_MODE))\n\t\treturn false;\n\n\t \n\tportsc &= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);\n\tportsc |= PORT_WR;\n\twritel(portsc, port->addr);\n\t \n\treadl(port->addr);\n\treturn true;\n}\n\nint xhci_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct xhci_bus_state *bus_state;\n\tunsigned long flags;\n\tint max_ports, port_index;\n\tint slot_id;\n\tint sret;\n\tu32 next_state;\n\tu32 temp, portsc;\n\tstruct xhci_hub *rhub;\n\tstruct xhci_port **ports;\n\n\trhub = xhci_get_rhub(hcd);\n\tports = rhub->ports;\n\tmax_ports = rhub->num_ports;\n\tbus_state = &rhub->bus_state;\n\n\tif (time_before(jiffies, bus_state->next_statechange))\n\t\tmsleep(5);\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\treturn -ESHUTDOWN;\n\t}\n\n\t \n\ttemp = readl(&xhci->op_regs->command);\n\ttemp &= ~CMD_EIE;\n\twritel(temp, &xhci->op_regs->command);\n\n\t \n\tif (hcd->speed >= HCD_USB3)\n\t\tnext_state = XDEV_U0;\n\telse\n\t\tnext_state = XDEV_RESUME;\n\n\tport_index = max_ports;\n\twhile (port_index--) {\n\t\tportsc = readl(ports[port_index]->addr);\n\n\t\t \n\t\tif ((xhci->quirks & XHCI_MISSING_CAS) &&\n\t\t    (hcd->speed >= HCD_USB3) &&\n\t\t    xhci_port_missing_cas_quirk(ports[port_index])) {\n\t\t\txhci_dbg(xhci, \"reset stuck port %d-%d\\n\",\n\t\t\t\t hcd->self.busnum, port_index + 1);\n\t\t\tclear_bit(port_index, &bus_state->bus_suspended);\n\t\t\tcontinue;\n\t\t}\n\t\t \n\t\tif (test_bit(port_index, &bus_state->bus_suspended))\n\t\t\tswitch (portsc & PORT_PLS_MASK) {\n\t\t\tcase XDEV_U3:\n\t\t\t\tportsc = xhci_port_state_to_neutral(portsc);\n\t\t\t\tportsc &= ~PORT_PLS_MASK;\n\t\t\t\tportsc |= PORT_LINK_STROBE | next_state;\n\t\t\t\tbreak;\n\t\t\tcase XDEV_RESUME:\n\t\t\t\t \n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t \n\t\t\t\tclear_bit(port_index,\n\t\t\t\t\t  &bus_state->bus_suspended);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t \n\t\tportsc &= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);\n\t\twritel(portsc, ports[port_index]->addr);\n\t}\n\n\t \n\tif (hcd->speed < HCD_USB3) {\n\t\tif (bus_state->bus_suspended) {\n\t\t\tspin_unlock_irqrestore(&xhci->lock, flags);\n\t\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\t\tspin_lock_irqsave(&xhci->lock, flags);\n\t\t}\n\t\tfor_each_set_bit(port_index, &bus_state->bus_suspended,\n\t\t\t\t BITS_PER_LONG) {\n\t\t\t \n\t\t\txhci_test_and_clear_bit(xhci, ports[port_index],\n\t\t\t\t\t\tPORT_PLC);\n\t\t\txhci_set_link_state(xhci, ports[port_index], XDEV_U0);\n\t\t}\n\t}\n\n\t \n\tfor_each_set_bit(port_index, &bus_state->bus_suspended, BITS_PER_LONG) {\n\t\tsret = xhci_handshake(ports[port_index]->addr, PORT_PLC,\n\t\t\t\t      PORT_PLC, 10 * 1000);\n\t\tif (sret) {\n\t\t\txhci_warn(xhci, \"port %d-%d resume PLC timeout\\n\",\n\t\t\t\t  hcd->self.busnum, port_index + 1);\n\t\t\tcontinue;\n\t\t}\n\t\txhci_test_and_clear_bit(xhci, ports[port_index], PORT_PLC);\n\t\tslot_id = xhci_find_slot_id_by_port(hcd, xhci, port_index + 1);\n\t\tif (slot_id)\n\t\t\txhci_ring_device(xhci, slot_id);\n\t}\n\t(void) readl(&xhci->op_regs->command);\n\n\tbus_state->next_statechange = jiffies + msecs_to_jiffies(5);\n\t \n\ttemp = readl(&xhci->op_regs->command);\n\ttemp |= CMD_EIE;\n\twritel(temp, &xhci->op_regs->command);\n\ttemp = readl(&xhci->op_regs->command);\n\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\treturn 0;\n}\n\nunsigned long xhci_get_resuming_ports(struct usb_hcd *hcd)\n{\n\tstruct xhci_hub *rhub = xhci_get_rhub(hcd);\n\n\t \n\treturn rhub->bus_state.resuming_ports;\t \n}\n\n#endif\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}