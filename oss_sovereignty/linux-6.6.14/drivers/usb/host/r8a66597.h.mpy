{
  "module_name": "r8a66597.h",
  "hash_id": "45643b3dfa9fd2fe49fda1e871ba9bfb38f11d3acb6ebbb6c97e41b8f2198df6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/r8a66597.h",
  "human_readable_source": " \n \n\n#ifndef __R8A66597_H__\n#define __R8A66597_H__\n\n#include <linux/clk.h>\n#include <linux/usb/r8a66597.h>\n\n#define R8A66597_MAX_NUM_PIPE\t\t10\n#define R8A66597_BUF_BSIZE\t\t8\n#define R8A66597_MAX_DEVICE\t\t10\n#define R8A66597_MAX_ROOT_HUB\t\t2\n#define R8A66597_MAX_SAMPLING\t\t5\n#define R8A66597_RH_POLL_TIME\t\t10\n#define R8A66597_MAX_DMA_CHANNEL\t2\n#define R8A66597_PIPE_NO_DMA\t\tR8A66597_MAX_DMA_CHANNEL\n#define check_bulk_or_isoc(pipenum)\t((pipenum >= 1 && pipenum <= 5))\n#define check_interrupt(pipenum)\t((pipenum >= 6 && pipenum <= 9))\n#define make_devsel(addr)\t\t(addr << 12)\n\nstruct r8a66597_pipe_info {\n\tunsigned long timer_interval;\n\tu16 pipenum;\n\tu16 address;\t \n\tu16 epnum;\n\tu16 maxpacket;\n\tu16 type;\n\tu16 bufnum;\n\tu16 buf_bsize;\n\tu16 interval;\n\tu16 dir_in;\n};\n\nstruct r8a66597_pipe {\n\tstruct r8a66597_pipe_info info;\n\n\tunsigned long fifoaddr;\n\tunsigned long fifosel;\n\tunsigned long fifoctr;\n\tunsigned long pipectr;\n\tunsigned long pipetre;\n\tunsigned long pipetrn;\n};\n\nstruct r8a66597_td {\n\tstruct r8a66597_pipe *pipe;\n\tstruct urb *urb;\n\tstruct list_head queue;\n\n\tu16 type;\n\tu16 pipenum;\n\tint iso_cnt;\n\n\tu16 address;\t\t \n\tu16 maxpacket;\n\n\tunsigned zero_packet:1;\n\tunsigned short_packet:1;\n\tunsigned set_address:1;\n};\n\nstruct r8a66597_device {\n\tu16\taddress;\t \n\tu16\thub_port;\n\tu16\troot_port;\n\n\tunsigned short ep_in_toggle;\n\tunsigned short ep_out_toggle;\n\tunsigned char pipe_cnt[R8A66597_MAX_NUM_PIPE];\n\tunsigned char dma_map;\n\n\tenum usb_device_state state;\n\n\tstruct usb_device *udev;\n\tint usb_address;\n\tstruct list_head device_list;\n};\n\nstruct r8a66597_root_hub {\n\tu32 port;\n\tu16 old_syssts;\n\tint scount;\n\n\tstruct r8a66597_device\t*dev;\n};\n\nstruct r8a66597;\n\nstruct r8a66597_timers {\n\tstruct timer_list td;\n\tstruct timer_list interval;\n\tstruct r8a66597 *r8a66597;\n};\n\nstruct r8a66597 {\n\tspinlock_t lock;\n\tvoid __iomem *reg;\n\tstruct clk *clk;\n\tstruct r8a66597_platdata\t*pdata;\n\tstruct r8a66597_device\t\tdevice0;\n\tstruct r8a66597_root_hub\troot_hub[R8A66597_MAX_ROOT_HUB];\n\tstruct list_head\t\tpipe_queue[R8A66597_MAX_NUM_PIPE];\n\n\tstruct timer_list rh_timer;\n\tstruct r8a66597_timers timers[R8A66597_MAX_NUM_PIPE];\n\n\tunsigned short address_map;\n\tunsigned short timeout_map;\n\tunsigned short interval_map;\n\tunsigned char pipe_cnt[R8A66597_MAX_NUM_PIPE];\n\tunsigned char dma_map;\n\tunsigned int max_root_hub;\n\n\tstruct list_head child_device;\n\tunsigned long child_connect_map[4];\n\n\tunsigned bus_suspended:1;\n\tunsigned irq_sense_low:1;\n};\n\nstatic inline struct r8a66597 *hcd_to_r8a66597(struct usb_hcd *hcd)\n{\n\treturn (struct r8a66597 *)(hcd->hcd_priv);\n}\n\nstatic inline struct usb_hcd *r8a66597_to_hcd(struct r8a66597 *r8a66597)\n{\n\treturn container_of((void *)r8a66597, struct usb_hcd, hcd_priv);\n}\n\nstatic inline struct r8a66597_td *r8a66597_get_td(struct r8a66597 *r8a66597,\n\t\t\t\t\t\t  u16 pipenum)\n{\n\tif (unlikely(list_empty(&r8a66597->pipe_queue[pipenum])))\n\t\treturn NULL;\n\n\treturn list_entry(r8a66597->pipe_queue[pipenum].next,\n\t\t\t  struct r8a66597_td, queue);\n}\n\nstatic inline struct urb *r8a66597_get_urb(struct r8a66597 *r8a66597,\n\t\t\t\t\t   u16 pipenum)\n{\n\tstruct r8a66597_td *td;\n\n\ttd = r8a66597_get_td(r8a66597, pipenum);\n\treturn (td ? td->urb : NULL);\n}\n\nstatic inline u16 r8a66597_read(struct r8a66597 *r8a66597, unsigned long offset)\n{\n\treturn ioread16(r8a66597->reg + offset);\n}\n\nstatic inline void r8a66597_read_fifo(struct r8a66597 *r8a66597,\n\t\t\t\t      unsigned long offset, u16 *buf,\n\t\t\t\t      int len)\n{\n\tvoid __iomem *fifoaddr = r8a66597->reg + offset;\n\tunsigned long count;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tcount = len / 4;\n\t\tioread32_rep(fifoaddr, buf, count);\n\n\t\tif (len & 0x00000003) {\n\t\t\tunsigned long tmp = ioread32(fifoaddr);\n\t\t\tmemcpy((unsigned char *)buf + count * 4, &tmp,\n\t\t\t       len & 0x03);\n\t\t}\n\t} else {\n\t\tlen = (len + 1) / 2;\n\t\tioread16_rep(fifoaddr, buf, len);\n\t}\n}\n\nstatic inline void r8a66597_write(struct r8a66597 *r8a66597, u16 val,\n\t\t\t\t  unsigned long offset)\n{\n\tiowrite16(val, r8a66597->reg + offset);\n}\n\nstatic inline void r8a66597_mdfy(struct r8a66597 *r8a66597,\n\t\t\t\t u16 val, u16 pat, unsigned long offset)\n{\n\tu16 tmp;\n\ttmp = r8a66597_read(r8a66597, offset);\n\ttmp = tmp & (~pat);\n\ttmp = tmp | val;\n\tr8a66597_write(r8a66597, tmp, offset);\n}\n\n#define r8a66597_bclr(r8a66597, val, offset)\t\\\n\t\t\tr8a66597_mdfy(r8a66597, 0, val, offset)\n#define r8a66597_bset(r8a66597, val, offset)\t\\\n\t\t\tr8a66597_mdfy(r8a66597, val, 0, offset)\n\nstatic inline void r8a66597_write_fifo(struct r8a66597 *r8a66597,\n\t\t\t\t       struct r8a66597_pipe *pipe, u16 *buf,\n\t\t\t\t       int len)\n{\n\tvoid __iomem *fifoaddr = r8a66597->reg + pipe->fifoaddr;\n\tunsigned long count;\n\tunsigned char *pb;\n\tint i;\n\n\tif (r8a66597->pdata->on_chip) {\n\t\tcount = len / 4;\n\t\tiowrite32_rep(fifoaddr, buf, count);\n\n\t\tif (len & 0x00000003) {\n\t\t\tpb = (unsigned char *)buf + count * 4;\n\t\t\tfor (i = 0; i < (len & 0x00000003); i++) {\n\t\t\t\tif (r8a66597_read(r8a66597, CFIFOSEL) & BIGEND)\n\t\t\t\t\tiowrite8(pb[i], fifoaddr + i);\n\t\t\t\telse\n\t\t\t\t\tiowrite8(pb[i], fifoaddr + 3 - i);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint odd = len & 0x0001;\n\n\t\tlen = len / 2;\n\t\tiowrite16_rep(fifoaddr, buf, len);\n\t\tif (unlikely(odd)) {\n\t\t\tbuf = &buf[len];\n\t\t\tif (r8a66597->pdata->wr0_shorted_to_wr1)\n\t\t\t\tr8a66597_bclr(r8a66597, MBW_16, pipe->fifosel);\n\t\t\tiowrite8((unsigned char)*buf, fifoaddr);\n\t\t\tif (r8a66597->pdata->wr0_shorted_to_wr1)\n\t\t\t\tr8a66597_bset(r8a66597, MBW_16, pipe->fifosel);\n\t\t}\n\t}\n}\n\nstatic inline unsigned long get_syscfg_reg(int port)\n{\n\treturn port == 0 ? SYSCFG0 : SYSCFG1;\n}\n\nstatic inline unsigned long get_syssts_reg(int port)\n{\n\treturn port == 0 ? SYSSTS0 : SYSSTS1;\n}\n\nstatic inline unsigned long get_dvstctr_reg(int port)\n{\n\treturn port == 0 ? DVSTCTR0 : DVSTCTR1;\n}\n\nstatic inline unsigned long get_dmacfg_reg(int port)\n{\n\treturn port == 0 ? DMA0CFG : DMA1CFG;\n}\n\nstatic inline unsigned long get_intenb_reg(int port)\n{\n\treturn port == 0 ? INTENB1 : INTENB2;\n}\n\nstatic inline unsigned long get_intsts_reg(int port)\n{\n\treturn port == 0 ? INTSTS1 : INTSTS2;\n}\n\nstatic inline u16 get_rh_usb_speed(struct r8a66597 *r8a66597, int port)\n{\n\tunsigned long dvstctr_reg = get_dvstctr_reg(port);\n\n\treturn r8a66597_read(r8a66597, dvstctr_reg) & RHST;\n}\n\nstatic inline void r8a66597_port_power(struct r8a66597 *r8a66597, int port,\n\t\t\t\t       int power)\n{\n\tunsigned long dvstctr_reg = get_dvstctr_reg(port);\n\n\tif (r8a66597->pdata->port_power) {\n\t\tr8a66597->pdata->port_power(port, power);\n\t} else {\n\t\tif (power)\n\t\t\tr8a66597_bset(r8a66597, VBOUT, dvstctr_reg);\n\t\telse\n\t\t\tr8a66597_bclr(r8a66597, VBOUT, dvstctr_reg);\n\t}\n}\n\nstatic inline u16 get_xtal_from_pdata(struct r8a66597_platdata *pdata)\n{\n\tu16 clock = 0;\n\n\tswitch (pdata->xtal) {\n\tcase R8A66597_PLATDATA_XTAL_12MHZ:\n\t\tclock = XTAL12;\n\t\tbreak;\n\tcase R8A66597_PLATDATA_XTAL_24MHZ:\n\t\tclock = XTAL24;\n\t\tbreak;\n\tcase R8A66597_PLATDATA_XTAL_48MHZ:\n\t\tclock = XTAL48;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_ERR \"r8a66597: platdata clock is wrong.\\n\");\n\t\tbreak;\n\t}\n\n\treturn clock;\n}\n\n#define get_pipectr_addr(pipenum)\t(PIPE1CTR + (pipenum - 1) * 2)\n#define get_pipetre_addr(pipenum)\t(PIPE1TRE + (pipenum - 1) * 4)\n#define get_pipetrn_addr(pipenum)\t(PIPE1TRN + (pipenum - 1) * 4)\n#define get_devadd_addr(address)\t(DEVADD0 + address * 2)\n\n#define enable_irq_ready(r8a66597, pipenum)\t\\\n\tenable_pipe_irq(r8a66597, pipenum, BRDYENB)\n#define disable_irq_ready(r8a66597, pipenum)\t\\\n\tdisable_pipe_irq(r8a66597, pipenum, BRDYENB)\n#define enable_irq_empty(r8a66597, pipenum)\t\\\n\tenable_pipe_irq(r8a66597, pipenum, BEMPENB)\n#define disable_irq_empty(r8a66597, pipenum)\t\\\n\tdisable_pipe_irq(r8a66597, pipenum, BEMPENB)\n#define enable_irq_nrdy(r8a66597, pipenum)\t\\\n\tenable_pipe_irq(r8a66597, pipenum, NRDYENB)\n#define disable_irq_nrdy(r8a66597, pipenum)\t\\\n\tdisable_pipe_irq(r8a66597, pipenum, NRDYENB)\n\n#endif\t \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}