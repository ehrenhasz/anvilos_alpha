{
  "module_name": "fhci-q.c",
  "hash_id": "3535d674f951f1dbb12dac91b686185b0878de2fd5b5f31bcf7b5f21323ee342",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/fhci-q.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/spinlock.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include \"fhci.h\"\n\n \nstatic int status_to_error(u32 status)\n{\n\tif (status == USB_TD_OK)\n\t\treturn 0;\n\telse if (status & USB_TD_RX_ER_CRC)\n\t\treturn -EILSEQ;\n\telse if (status & USB_TD_RX_ER_NONOCT)\n\t\treturn -EPROTO;\n\telse if (status & USB_TD_RX_ER_OVERUN)\n\t\treturn -ECOMM;\n\telse if (status & USB_TD_RX_ER_BITSTUFF)\n\t\treturn -EPROTO;\n\telse if (status & USB_TD_RX_ER_PID)\n\t\treturn -EILSEQ;\n\telse if (status & (USB_TD_TX_ER_NAK | USB_TD_TX_ER_TIMEOUT))\n\t\treturn -ETIMEDOUT;\n\telse if (status & USB_TD_TX_ER_STALL)\n\t\treturn -EPIPE;\n\telse if (status & USB_TD_TX_ER_UNDERUN)\n\t\treturn -ENOSR;\n\telse if (status & USB_TD_RX_DATA_UNDERUN)\n\t\treturn -EREMOTEIO;\n\telse if (status & USB_TD_RX_DATA_OVERUN)\n\t\treturn -EOVERFLOW;\n\telse\n\t\treturn -EINVAL;\n}\n\nvoid fhci_add_td_to_frame(struct fhci_time_frame *frame, struct td *td)\n{\n\tlist_add_tail(&td->frame_lh, &frame->tds_list);\n}\n\nvoid fhci_add_tds_to_ed(struct ed *ed, struct td **td_list, int number)\n{\n\tint i;\n\n\tfor (i = 0; i < number; i++) {\n\t\tstruct td *td = td_list[i];\n\t\tlist_add_tail(&td->node, &ed->td_list);\n\t}\n\tif (ed->td_head == NULL)\n\t\ted->td_head = td_list[0];\n}\n\nstatic struct td *peek_td_from_ed(struct ed *ed)\n{\n\tstruct td *td;\n\n\tif (!list_empty(&ed->td_list))\n\t\ttd = list_entry(ed->td_list.next, struct td, node);\n\telse\n\t\ttd = NULL;\n\n\treturn td;\n}\n\nstruct td *fhci_remove_td_from_frame(struct fhci_time_frame *frame)\n{\n\tstruct td *td;\n\n\tif (!list_empty(&frame->tds_list)) {\n\t\ttd = list_entry(frame->tds_list.next, struct td, frame_lh);\n\t\tlist_del_init(frame->tds_list.next);\n\t} else\n\t\ttd = NULL;\n\n\treturn td;\n}\n\nstruct td *fhci_peek_td_from_frame(struct fhci_time_frame *frame)\n{\n\tstruct td *td;\n\n\tif (!list_empty(&frame->tds_list))\n\t\ttd = list_entry(frame->tds_list.next, struct td, frame_lh);\n\telse\n\t\ttd = NULL;\n\n\treturn td;\n}\n\nstruct td *fhci_remove_td_from_ed(struct ed *ed)\n{\n\tstruct td *td;\n\n\tif (!list_empty(&ed->td_list)) {\n\t\ttd = list_entry(ed->td_list.next, struct td, node);\n\t\tlist_del_init(ed->td_list.next);\n\n\t\t \n\t\tif (!list_empty(&ed->td_list))\n\t\t\ted->td_head = list_entry(ed->td_list.next, struct td,\n\t\t\t\t\t\t node);\n\t\telse\n\t\t\ted->td_head = NULL;\n\t} else\n\t\ttd = NULL;\n\n\treturn td;\n}\n\nstruct td *fhci_remove_td_from_done_list(struct fhci_controller_list *p_list)\n{\n\tstruct td *td;\n\n\tif (!list_empty(&p_list->done_list)) {\n\t\ttd = list_entry(p_list->done_list.next, struct td, node);\n\t\tlist_del_init(p_list->done_list.next);\n\t} else\n\t\ttd = NULL;\n\n\treturn td;\n}\n\nvoid fhci_move_td_from_ed_to_done_list(struct fhci_usb *usb, struct ed *ed)\n{\n\tstruct td *td;\n\n\ttd = ed->td_head;\n\tlist_del_init(&td->node);\n\n\t \n\tif (!list_empty(&ed->td_list))\n\t\ted->td_head = list_entry(ed->td_list.next, struct td, node);\n\telse {\n\t\ted->td_head = NULL;\n\t\ted->state = FHCI_ED_SKIP;\n\t}\n\ted->toggle_carry = td->toggle;\n\tlist_add_tail(&td->node, &usb->hc_list->done_list);\n\tif (td->ioc)\n\t\tusb->transfer_confirm(usb->fhci);\n}\n\n \nstatic void free_urb_priv(struct fhci_hcd *fhci, struct urb *urb)\n{\n\tint i;\n\tstruct urb_priv *urb_priv = urb->hcpriv;\n\tstruct ed *ed = urb_priv->ed;\n\n\tfor (i = 0; i < urb_priv->num_of_tds; i++) {\n\t\tlist_del_init(&urb_priv->tds[i]->node);\n\t\tfhci_recycle_empty_td(fhci, urb_priv->tds[i]);\n\t}\n\n\t \n\tif (!list_empty(&ed->td_list))\n\t\ted->td_head = list_entry(ed->td_list.next, struct td, node);\n\telse\n\t\ted->td_head = NULL;\n\n\tkfree(urb_priv->tds);\n\tkfree(urb_priv);\n\turb->hcpriv = NULL;\n\n\t \n\tif (ed->td_head == NULL)\n\t\tlist_del_init(&ed->node);\n\tfhci->active_urbs--;\n}\n\n \nvoid fhci_urb_complete_free(struct fhci_hcd *fhci, struct urb *urb)\n{\n\tfree_urb_priv(fhci, urb);\n\n\tif (urb->status == -EINPROGRESS) {\n\t\tif (urb->actual_length != urb->transfer_buffer_length &&\n\t\t\t\turb->transfer_flags & URB_SHORT_NOT_OK)\n\t\t\turb->status = -EREMOTEIO;\n\t\telse\n\t\t\turb->status = 0;\n\t}\n\n\tusb_hcd_unlink_urb_from_ep(fhci_to_hcd(fhci), urb);\n\n\tspin_unlock(&fhci->lock);\n\n\tusb_hcd_giveback_urb(fhci_to_hcd(fhci), urb, urb->status);\n\n\tspin_lock(&fhci->lock);\n}\n\n \nvoid fhci_done_td(struct urb *urb, struct td *td)\n{\n\tstruct ed *ed = td->ed;\n\tu32 cc = td->status;\n\n\t \n\tif (ed->mode == FHCI_TF_ISO) {\n\t\tu32 len;\n\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK &&\n\t\t\t\tcc == USB_TD_RX_DATA_UNDERUN))\n\t\t\tcc = USB_TD_OK;\n\n\t\tif (usb_pipeout(urb->pipe))\n\t\t\tlen = urb->iso_frame_desc[td->iso_index].length;\n\t\telse\n\t\t\tlen = td->actual_len;\n\n\t\turb->actual_length += len;\n\t\turb->iso_frame_desc[td->iso_index].actual_length = len;\n\t\turb->iso_frame_desc[td->iso_index].status =\n\t\t\tstatus_to_error(cc);\n\t}\n\n\t \n\telse {\n\t\tif (td->error_cnt >= 3)\n\t\t\turb->error_count = 3;\n\n\t\t \n\n\t\t \n\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK) &&\n\t\t\t\tcc == USB_TD_RX_DATA_UNDERUN) {\n\t\t\ted->state = FHCI_ED_OPER;\n\t\t\tcc = USB_TD_OK;\n\t\t}\n\t\tif (cc != USB_TD_OK) {\n\t\t\tif (urb->status == -EINPROGRESS)\n\t\t\t\turb->status = status_to_error(cc);\n\t\t}\n\n\t\t \n\t\tif (td->type != FHCI_TA_SETUP || td->iso_index != 0)\n\t\t\turb->actual_length += td->actual_len;\n\t}\n}\n\n \nvoid fhci_del_ed_list(struct fhci_hcd *fhci, struct ed *ed)\n{\n\tstruct td *td = peek_td_from_ed(ed);\n\tstruct urb *urb = td->urb;\n\tstruct urb_priv *urb_priv = urb->hcpriv;\n\n\tif (urb_priv->state == URB_DEL) {\n\t\ttd = fhci_remove_td_from_ed(ed);\n\t\t \n\t\tif (td->status != USB_TD_INPROGRESS)\n\t\t\tfhci_done_td(urb, td);\n\n\t\t \n\t\tif (++(urb_priv->tds_cnt) == urb_priv->num_of_tds)\n\t\t\tfhci_urb_complete_free(fhci, urb);\n\t}\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}