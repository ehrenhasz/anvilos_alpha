{
  "module_name": "oxu210hp-hcd.c",
  "hash_id": "025d1e86fe9de027fc3779a50c63c93175a0be8ee7815c4159f118eff5e09eeb",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/oxu210hp-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/dmapool.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/timer.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/moduleparam.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/iopoll.h>\n\n#include <asm/irq.h>\n#include <asm/unaligned.h>\n\n#include <linux/irq.h>\n#include <linux/platform_device.h>\n\n#define DRIVER_VERSION \"0.0.50\"\n\n#define OXU_DEVICEID\t\t\t0x00\n\t#define OXU_REV_MASK\t\t0xffff0000\n\t#define OXU_REV_SHIFT\t\t16\n\t#define OXU_REV_2100\t\t0x2100\n\t#define OXU_BO_SHIFT\t\t8\n\t#define OXU_BO_MASK\t\t(0x3 << OXU_BO_SHIFT)\n\t#define OXU_MAJ_REV_SHIFT\t4\n\t#define OXU_MAJ_REV_MASK\t(0xf << OXU_MAJ_REV_SHIFT)\n\t#define OXU_MIN_REV_SHIFT\t0\n\t#define OXU_MIN_REV_MASK\t(0xf << OXU_MIN_REV_SHIFT)\n#define OXU_HOSTIFCONFIG\t\t0x04\n#define OXU_SOFTRESET\t\t\t0x08\n\t#define OXU_SRESET\t\t(1 << 0)\n\n#define OXU_PIOBURSTREADCTRL\t\t0x0C\n\n#define OXU_CHIPIRQSTATUS\t\t0x10\n#define OXU_CHIPIRQEN_SET\t\t0x14\n#define OXU_CHIPIRQEN_CLR\t\t0x18\n\t#define OXU_USBSPHLPWUI\t\t0x00000080\n\t#define OXU_USBOTGLPWUI\t\t0x00000040\n\t#define OXU_USBSPHI\t\t0x00000002\n\t#define OXU_USBOTGI\t\t0x00000001\n\n#define OXU_CLKCTRL_SET\t\t\t0x1C\n\t#define OXU_SYSCLKEN\t\t0x00000008\n\t#define OXU_USBSPHCLKEN\t\t0x00000002\n\t#define OXU_USBOTGCLKEN\t\t0x00000001\n\n#define OXU_ASO\t\t\t\t0x68\n\t#define OXU_SPHPOEN\t\t0x00000100\n\t#define OXU_OVRCCURPUPDEN\t0x00000800\n\t#define OXU_ASO_OP\t\t(1 << 10)\n\t#define OXU_COMPARATOR\t\t0x000004000\n\n#define OXU_USBMODE\t\t\t0x1A8\n\t#define OXU_VBPS\t\t0x00000020\n\t#define OXU_ES_LITTLE\t\t0x00000000\n\t#define OXU_CM_HOST_ONLY\t0x00000003\n\n \n\n \n#define EHCI_TUNE_CERR\t\t3\t \n#define EHCI_TUNE_RL_HS\t\t4\t \n#define EHCI_TUNE_RL_TT\t\t0\n#define EHCI_TUNE_MULT_HS\t1\t \n#define EHCI_TUNE_MULT_TT\t1\n#define EHCI_TUNE_FLS\t\t2\t \n\nstruct oxu_hcd;\n\n \n\n \nstruct ehci_caps {\n\t \n\tu32\t\thc_capbase;\n#define HC_LENGTH(p)\t\t(((p)>>00)&0x00ff)\t \n#define HC_VERSION(p)\t\t(((p)>>16)&0xffff)\t \n\tu32\t\thcs_params;      \n#define HCS_DEBUG_PORT(p)\t(((p)>>20)&0xf)\t \n#define HCS_INDICATOR(p)\t((p)&(1 << 16))\t \n#define HCS_N_CC(p)\t\t(((p)>>12)&0xf)\t \n#define HCS_N_PCC(p)\t\t(((p)>>8)&0xf)\t \n#define HCS_PORTROUTED(p)\t((p)&(1 << 7))\t \n#define HCS_PPC(p)\t\t((p)&(1 << 4))\t \n#define HCS_N_PORTS(p)\t\t(((p)>>0)&0xf)\t \n\n\tu32\t\thcc_params;       \n#define HCC_EXT_CAPS(p)\t\t(((p)>>8)&0xff)\t \n#define HCC_ISOC_CACHE(p)       ((p)&(1 << 7))   \n#define HCC_ISOC_THRES(p)       (((p)>>4)&0x7)   \n#define HCC_CANPARK(p)\t\t((p)&(1 << 2))   \n#define HCC_PGM_FRAMELISTLEN(p) ((p)&(1 << 1))   \n#define HCC_64BIT_ADDR(p)       ((p)&(1))        \n\tu8\t\tportroute[8];\t  \n} __packed;\n\n\n \nstruct ehci_regs {\n\t \n\tu32\t\tcommand;\n \n#define CMD_PARK\t(1<<11)\t\t \n#define CMD_PARK_CNT(c)\t(((c)>>8)&3)\t \n#define CMD_LRESET\t(1<<7)\t\t \n#define CMD_IAAD\t(1<<6)\t\t \n#define CMD_ASE\t\t(1<<5)\t\t \n#define CMD_PSE\t\t(1<<4)\t\t \n \n#define CMD_RESET\t(1<<1)\t\t \n#define CMD_RUN\t\t(1<<0)\t\t \n\n\t \n\tu32\t\tstatus;\n#define STS_ASS\t\t(1<<15)\t\t \n#define STS_PSS\t\t(1<<14)\t\t \n#define STS_RECL\t(1<<13)\t\t \n#define STS_HALT\t(1<<12)\t\t \n \n\t \n#define STS_IAA\t\t(1<<5)\t\t \n#define STS_FATAL\t(1<<4)\t\t \n#define STS_FLR\t\t(1<<3)\t\t \n#define STS_PCD\t\t(1<<2)\t\t \n#define STS_ERR\t\t(1<<1)\t\t \n#define STS_INT\t\t(1<<0)\t\t \n\n#define INTR_MASK (STS_IAA | STS_FATAL | STS_PCD | STS_ERR | STS_INT)\n\n\t \n\tu32\t\tintr_enable;\n\n\t \n\tu32\t\tframe_index;\t \n\t \n\tu32\t\tsegment;\t \n\t \n\tu32\t\tframe_list;\t \n\t \n\tu32\t\tasync_next;\t \n\n\tu32\t\treserved[9];\n\n\t \n\tu32\t\tconfigured_flag;\n#define FLAG_CF\t\t(1<<0)\t\t \n\n\t \n\tu32\t\tport_status[];\t \n \n#define PORT_WKOC_E\t(1<<22)\t\t \n#define PORT_WKDISC_E\t(1<<21)\t\t \n#define PORT_WKCONN_E\t(1<<20)\t\t \n \n#define PORT_LED_OFF\t(0<<14)\n#define PORT_LED_AMBER\t(1<<14)\n#define PORT_LED_GREEN\t(2<<14)\n#define PORT_LED_MASK\t(3<<14)\n#define PORT_OWNER\t(1<<13)\t\t \n#define PORT_POWER\t(1<<12)\t\t \n#define PORT_USB11(x) (((x)&(3<<10)) == (1<<10))\t \n \n \n#define PORT_RESET\t(1<<8)\t\t \n#define PORT_SUSPEND\t(1<<7)\t\t \n#define PORT_RESUME\t(1<<6)\t\t \n#define PORT_OCC\t(1<<5)\t\t \n#define PORT_OC\t\t(1<<4)\t\t \n#define PORT_PEC\t(1<<3)\t\t \n#define PORT_PE\t\t(1<<2)\t\t \n#define PORT_CSC\t(1<<1)\t\t \n#define PORT_CONNECT\t(1<<0)\t\t \n#define PORT_RWC_BITS   (PORT_CSC | PORT_PEC | PORT_OCC)\n} __packed;\n\n \nstruct ehci_dbg_port {\n\tu32\tcontrol;\n#define DBGP_OWNER\t(1<<30)\n#define DBGP_ENABLED\t(1<<28)\n#define DBGP_DONE\t(1<<16)\n#define DBGP_INUSE\t(1<<10)\n#define DBGP_ERRCODE(x)\t(((x)>>7)&0x07)\n#\tdefine DBGP_ERR_BAD\t1\n#\tdefine DBGP_ERR_SIGNAL\t2\n#define DBGP_ERROR\t(1<<6)\n#define DBGP_GO\t\t(1<<5)\n#define DBGP_OUT\t(1<<4)\n#define DBGP_LEN(x)\t(((x)>>0)&0x0f)\n\tu32\tpids;\n#define DBGP_PID_GET(x)\t\t(((x)>>16)&0xff)\n#define DBGP_PID_SET(data, tok)\t(((data)<<8)|(tok))\n\tu32\tdata03;\n\tu32\tdata47;\n\tu32\taddress;\n#define DBGP_EPADDR(dev, ep)\t(((dev)<<8)|(ep))\n} __packed;\n\n#define\tQTD_NEXT(dma)\tcpu_to_le32((u32)dma)\n\n \nstruct ehci_qtd {\n\t \n\t__le32\t\t\thw_next;\t\t \n\t__le32\t\t\thw_alt_next;\t\t \n\t__le32\t\t\thw_token;\t\t \n#define\tQTD_TOGGLE\t(1 << 31)\t \n#define\tQTD_LENGTH(tok)\t(((tok)>>16) & 0x7fff)\n#define\tQTD_IOC\t\t(1 << 15)\t \n#define\tQTD_CERR(tok)\t(((tok)>>10) & 0x3)\n#define\tQTD_PID(tok)\t(((tok)>>8) & 0x3)\n#define\tQTD_STS_ACTIVE\t(1 << 7)\t \n#define\tQTD_STS_HALT\t(1 << 6)\t \n#define\tQTD_STS_DBE\t(1 << 5)\t \n#define\tQTD_STS_BABBLE\t(1 << 4)\t \n#define\tQTD_STS_XACT\t(1 << 3)\t \n#define\tQTD_STS_MMF\t(1 << 2)\t \n#define\tQTD_STS_STS\t(1 << 1)\t \n#define\tQTD_STS_PING\t(1 << 0)\t \n\t__le32\t\t\thw_buf[5];\t\t \n\t__le32\t\t\thw_buf_hi[5];\t\t \n\n\t \n\tdma_addr_t\t\tqtd_dma;\t\t \n\tstruct list_head\tqtd_list;\t\t \n\tstruct urb\t\t*urb;\t\t\t \n\tsize_t\t\t\tlength;\t\t\t \n\n\tu32\t\t\tqtd_buffer_len;\n\tvoid\t\t\t*buffer;\n\tdma_addr_t\t\tbuffer_dma;\n\tvoid\t\t\t*transfer_buffer;\n\tvoid\t\t\t*transfer_dma;\n} __aligned(32);\n\n \n#define QTD_MASK cpu_to_le32 (~0x1f)\n\n#define IS_SHORT_READ(token) (QTD_LENGTH(token) != 0 && QTD_PID(token) == 1)\n\n \n#define Q_NEXT_TYPE(dma) ((dma) & cpu_to_le32 (3 << 1))\n\n \n#define Q_TYPE_QH\tcpu_to_le32 (1 << 1)\n\n \n#define\tQH_NEXT(dma)\t(cpu_to_le32(((u32)dma)&~0x01f)|Q_TYPE_QH)\n\n \n#define\tEHCI_LIST_END\tcpu_to_le32(1)  \n\n \nunion ehci_shadow {\n\tstruct ehci_qh\t\t*qh;\t\t \n\t__le32\t\t\t*hw_next;\t \n\tvoid\t\t\t*ptr;\n};\n\n \n\nstruct ehci_qh {\n\t \n\t__le32\t\t\thw_next;\t  \n\t__le32\t\t\thw_info1;\t \n#define\tQH_HEAD\t\t0x00008000\n\t__le32\t\t\thw_info2;\t \n#define\tQH_SMASK\t0x000000ff\n#define\tQH_CMASK\t0x0000ff00\n#define\tQH_HUBADDR\t0x007f0000\n#define\tQH_HUBPORT\t0x3f800000\n#define\tQH_MULT\t\t0xc0000000\n\t__le32\t\t\thw_current;\t  \n\n\t \n\t__le32\t\t\thw_qtd_next;\n\t__le32\t\t\thw_alt_next;\n\t__le32\t\t\thw_token;\n\t__le32\t\t\thw_buf[5];\n\t__le32\t\t\thw_buf_hi[5];\n\n\t \n\tdma_addr_t\t\tqh_dma;\t\t \n\tunion ehci_shadow\tqh_next;\t \n\tstruct list_head\tqtd_list;\t \n\tstruct ehci_qtd\t\t*dummy;\n\tstruct ehci_qh\t\t*reclaim;\t \n\n\tstruct oxu_hcd\t\t*oxu;\n\tstruct kref\t\tkref;\n\tunsigned int\t\tstamp;\n\n\tu8\t\t\tqh_state;\n#define\tQH_STATE_LINKED\t\t1\t\t \n#define\tQH_STATE_UNLINK\t\t2\t\t \n#define\tQH_STATE_IDLE\t\t3\t\t \n#define\tQH_STATE_UNLINK_WAIT\t4\t\t \n#define\tQH_STATE_COMPLETING\t5\t\t \n\n\t \n\tu8\t\t\tusecs;\t\t \n\tu8\t\t\tgap_uf;\t\t \n\tu8\t\t\tc_usecs;\t \n\tu16\t\t\ttt_usecs;\t \n\tunsigned short\t\tperiod;\t\t \n\tunsigned short\t\tstart;\t\t \n#define NO_FRAME ((unsigned short)~0)\t\t\t \n\tstruct usb_device\t*dev;\t\t \n} __aligned(32);\n\n \n\n#define OXU_OTG_CORE_OFFSET\t0x00400\n#define OXU_OTG_CAP_OFFSET\t(OXU_OTG_CORE_OFFSET + 0x100)\n#define OXU_SPH_CORE_OFFSET\t0x00800\n#define OXU_SPH_CAP_OFFSET\t(OXU_SPH_CORE_OFFSET + 0x100)\n\n#define OXU_OTG_MEM\t\t0xE000\n#define OXU_SPH_MEM\t\t0x16000\n\n \n \n#define\tDEFAULT_I_TDPS\t\t1024\n#define QHEAD_NUM\t\t16\n#define QTD_NUM\t\t\t32\n#define SITD_NUM\t\t8\n#define MURB_NUM\t\t8\n\n#define BUFFER_NUM\t\t8\n#define BUFFER_SIZE\t\t512\n\nstruct oxu_info {\n\tstruct usb_hcd *hcd[2];\n};\n\nstruct oxu_buf {\n\tu8\t\t\tbuffer[BUFFER_SIZE];\n} __aligned(BUFFER_SIZE);\n\nstruct oxu_onchip_mem {\n\tstruct oxu_buf\t\tdb_pool[BUFFER_NUM];\n\n\tu32\t\t\tframe_list[DEFAULT_I_TDPS];\n\tstruct ehci_qh\t\tqh_pool[QHEAD_NUM];\n\tstruct ehci_qtd\t\tqtd_pool[QTD_NUM];\n} __aligned(4 << 10);\n\n#define\tEHCI_MAX_ROOT_PORTS\t15\t\t \n\nstruct oxu_murb {\n\tstruct urb\t\turb;\n\tstruct urb\t\t*main;\n\tu8\t\t\tlast;\n};\n\nstruct oxu_hcd {\t\t\t\t \n\tunsigned int\t\tis_otg:1;\n\n\tu8\t\t\tqh_used[QHEAD_NUM];\n\tu8\t\t\tqtd_used[QTD_NUM];\n\tu8\t\t\tdb_used[BUFFER_NUM];\n\tu8\t\t\tmurb_used[MURB_NUM];\n\n\tstruct oxu_onchip_mem\t__iomem *mem;\n\tspinlock_t\t\tmem_lock;\n\n\tstruct timer_list\turb_timer;\n\n\tstruct ehci_caps __iomem *caps;\n\tstruct ehci_regs __iomem *regs;\n\n\tu32\t\t\thcs_params;\t \n\tspinlock_t\t\tlock;\n\n\t \n\tstruct ehci_qh\t\t*async;\n\tstruct ehci_qh\t\t*reclaim;\n\tunsigned int\t\treclaim_ready:1;\n\tunsigned int\t\tscanning:1;\n\n\t \n\tunsigned int\t\tperiodic_size;\n\t__le32\t\t\t*periodic;\t \n\tdma_addr_t\t\tperiodic_dma;\n\tunsigned int\t\ti_thresh;\t \n\n\tunion ehci_shadow\t*pshadow;\t \n\tint\t\t\tnext_uframe;\t \n\tunsigned int\t\tperiodic_sched;\t \n\n\t \n\tunsigned long\t\treset_done[EHCI_MAX_ROOT_PORTS];\n\t \n\tunsigned long\t\tbus_suspended;\t \n\tunsigned long\t\tcompanion_ports; \n\n\tstruct timer_list\twatchdog;\n\tunsigned long\t\tactions;\n\tunsigned int\t\tstamp;\n\tunsigned long\t\tnext_statechange;\n\tu32\t\t\tcommand;\n\n\t \n\tstruct list_head\turb_list;\t \n\tstruct oxu_murb\t\t*murb_pool;\t \n\tunsigned int\t\turb_len;\n\n\tu8\t\t\tsbrn;\t\t \n};\n\n#define EHCI_IAA_JIFFIES\t(HZ/100)\t \n#define EHCI_IO_JIFFIES\t\t(HZ/10)\t\t \n#define EHCI_ASYNC_JIFFIES      (HZ/20)\t\t \n#define EHCI_SHRINK_JIFFIES     (HZ/200)\t \n\nenum ehci_timer_action {\n\tTIMER_IO_WATCHDOG,\n\tTIMER_IAA_WATCHDOG,\n\tTIMER_ASYNC_SHRINK,\n\tTIMER_ASYNC_OFF,\n};\n\n \n\n#define oxu_dbg(oxu, fmt, args...) \\\n\t\tdev_dbg(oxu_to_hcd(oxu)->self.controller , fmt , ## args)\n#define oxu_err(oxu, fmt, args...) \\\n\t\tdev_err(oxu_to_hcd(oxu)->self.controller , fmt , ## args)\n#define oxu_info(oxu, fmt, args...) \\\n\t\tdev_info(oxu_to_hcd(oxu)->self.controller , fmt , ## args)\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n#define DEBUG\n#endif\n\nstatic inline struct usb_hcd *oxu_to_hcd(struct oxu_hcd *oxu)\n{\n\treturn container_of((void *) oxu, struct usb_hcd, hcd_priv);\n}\n\nstatic inline struct oxu_hcd *hcd_to_oxu(struct usb_hcd *hcd)\n{\n\treturn (struct oxu_hcd *) (hcd->hcd_priv);\n}\n\n \n\n#undef OXU_URB_TRACE\n#undef OXU_VERBOSE_DEBUG\n\n#ifdef OXU_VERBOSE_DEBUG\n#define oxu_vdbg\t\t\toxu_dbg\n#else\n#define oxu_vdbg(oxu, fmt, args...)\t \n#endif\n\n#ifdef DEBUG\n\nstatic int __attribute__((__unused__))\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\n{\n\treturn scnprintf(buf, len, \"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", status,\n\t\t(status & STS_ASS) ? \" Async\" : \"\",\n\t\t(status & STS_PSS) ? \" Periodic\" : \"\",\n\t\t(status & STS_RECL) ? \" Recl\" : \"\",\n\t\t(status & STS_HALT) ? \" Halt\" : \"\",\n\t\t(status & STS_IAA) ? \" IAA\" : \"\",\n\t\t(status & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t(status & STS_FLR) ? \" FLR\" : \"\",\n\t\t(status & STS_PCD) ? \" PCD\" : \"\",\n\t\t(status & STS_ERR) ? \" ERR\" : \"\",\n\t\t(status & STS_INT) ? \" INT\" : \"\"\n\t\t);\n}\n\nstatic int __attribute__((__unused__))\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\n{\n\treturn scnprintf(buf, len, \"%s%sintrenable %02x%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", enable,\n\t\t(enable & STS_IAA) ? \" IAA\" : \"\",\n\t\t(enable & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t(enable & STS_FLR) ? \" FLR\" : \"\",\n\t\t(enable & STS_PCD) ? \" PCD\" : \"\",\n\t\t(enable & STS_ERR) ? \" ERR\" : \"\",\n\t\t(enable & STS_INT) ? \" INT\" : \"\"\n\t\t);\n}\n\nstatic const char *const fls_strings[] =\n    { \"1024\", \"512\", \"256\", \"??\" };\n\nstatic int dbg_command_buf(char *buf, unsigned len,\n\t\t\t\tconst char *label, u32 command)\n{\n\treturn scnprintf(buf, len,\n\t\t\"%s%scommand %06x %s=%d ithresh=%d%s%s%s%s period=%s%s %s\",\n\t\tlabel, label[0] ? \" \" : \"\", command,\n\t\t(command & CMD_PARK) ? \"park\" : \"(park)\",\n\t\tCMD_PARK_CNT(command),\n\t\t(command >> 16) & 0x3f,\n\t\t(command & CMD_LRESET) ? \" LReset\" : \"\",\n\t\t(command & CMD_IAAD) ? \" IAAD\" : \"\",\n\t\t(command & CMD_ASE) ? \" Async\" : \"\",\n\t\t(command & CMD_PSE) ? \" Periodic\" : \"\",\n\t\tfls_strings[(command >> 2) & 0x3],\n\t\t(command & CMD_RESET) ? \" Reset\" : \"\",\n\t\t(command & CMD_RUN) ? \"RUN\" : \"HALT\"\n\t\t);\n}\n\nstatic int dbg_port_buf(char *buf, unsigned len, const char *label,\n\t\t\t\tint port, u32 status)\n{\n\tchar\t*sig;\n\n\t \n\tswitch (status & (3 << 10)) {\n\tcase 0 << 10:\n\t\tsig = \"se0\";\n\t\tbreak;\n\tcase 1 << 10:\n\t\tsig = \"k\";\t \n\t\tbreak;\n\tcase 2 << 10:\n\t\tsig = \"j\";\n\t\tbreak;\n\tdefault:\n\t\tsig = \"?\";\n\t\tbreak;\n\t}\n\n\treturn scnprintf(buf, len,\n\t\t\"%s%sport %d status %06x%s%s sig=%s%s%s%s%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", port, status,\n\t\t(status & PORT_POWER) ? \" POWER\" : \"\",\n\t\t(status & PORT_OWNER) ? \" OWNER\" : \"\",\n\t\tsig,\n\t\t(status & PORT_RESET) ? \" RESET\" : \"\",\n\t\t(status & PORT_SUSPEND) ? \" SUSPEND\" : \"\",\n\t\t(status & PORT_RESUME) ? \" RESUME\" : \"\",\n\t\t(status & PORT_OCC) ? \" OCC\" : \"\",\n\t\t(status & PORT_OC) ? \" OC\" : \"\",\n\t\t(status & PORT_PEC) ? \" PEC\" : \"\",\n\t\t(status & PORT_PE) ? \" PE\" : \"\",\n\t\t(status & PORT_CSC) ? \" CSC\" : \"\",\n\t\t(status & PORT_CONNECT) ? \" CONNECT\" : \"\"\n\t    );\n}\n\n#else\n\nstatic inline int __attribute__((__unused__))\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\n{ return 0; }\n\nstatic inline int __attribute__((__unused__))\ndbg_command_buf(char *buf, unsigned len, const char *label, u32 command)\n{ return 0; }\n\nstatic inline int __attribute__((__unused__))\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\n{ return 0; }\n\nstatic inline int __attribute__((__unused__))\ndbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)\n{ return 0; }\n\n#endif  \n\n \n#define dbg_status(oxu, label, status) { \\\n\tchar _buf[80]; \\\n\tdbg_status_buf(_buf, sizeof _buf, label, status); \\\n\toxu_dbg(oxu, \"%s\\n\", _buf); \\\n}\n\n#define dbg_cmd(oxu, label, command) { \\\n\tchar _buf[80]; \\\n\tdbg_command_buf(_buf, sizeof _buf, label, command); \\\n\toxu_dbg(oxu, \"%s\\n\", _buf); \\\n}\n\n#define dbg_port(oxu, label, port, status) { \\\n\tchar _buf[80]; \\\n\tdbg_port_buf(_buf, sizeof _buf, label, port, status); \\\n\toxu_dbg(oxu, \"%s\\n\", _buf); \\\n}\n\n \n\n \nstatic int log2_irq_thresh;\t\t\t \nmodule_param(log2_irq_thresh, int, S_IRUGO);\nMODULE_PARM_DESC(log2_irq_thresh, \"log2 IRQ latency, 1-64 microframes\");\n\n \nstatic unsigned park;\nmodule_param(park, uint, S_IRUGO);\nMODULE_PARM_DESC(park, \"park setting; 1-3 back-to-back async packets\");\n\n \nstatic bool ignore_oc;\nmodule_param(ignore_oc, bool, S_IRUGO);\nMODULE_PARM_DESC(ignore_oc, \"ignore bogus hardware overcurrent indications\");\n\n\nstatic void ehci_work(struct oxu_hcd *oxu);\nstatic int oxu_hub_control(struct usb_hcd *hcd,\n\t\t\t\tu16 typeReq, u16 wValue, u16 wIndex,\n\t\t\t\tchar *buf, u16 wLength);\n\n \n\n \nstatic inline u32 oxu_readl(void __iomem *base, u32 reg)\n{\n\treturn readl(base + reg);\n}\n\nstatic inline void oxu_writel(void __iomem *base, u32 reg, u32 val)\n{\n\twritel(val, base + reg);\n}\n\nstatic inline void timer_action_done(struct oxu_hcd *oxu,\n\t\t\t\t\tenum ehci_timer_action action)\n{\n\tclear_bit(action, &oxu->actions);\n}\n\nstatic inline void timer_action(struct oxu_hcd *oxu,\n\t\t\t\t\tenum ehci_timer_action action)\n{\n\tif (!test_and_set_bit(action, &oxu->actions)) {\n\t\tunsigned long t;\n\n\t\tswitch (action) {\n\t\tcase TIMER_IAA_WATCHDOG:\n\t\t\tt = EHCI_IAA_JIFFIES;\n\t\t\tbreak;\n\t\tcase TIMER_IO_WATCHDOG:\n\t\t\tt = EHCI_IO_JIFFIES;\n\t\t\tbreak;\n\t\tcase TIMER_ASYNC_OFF:\n\t\t\tt = EHCI_ASYNC_JIFFIES;\n\t\t\tbreak;\n\t\tcase TIMER_ASYNC_SHRINK:\n\t\tdefault:\n\t\t\tt = EHCI_SHRINK_JIFFIES;\n\t\t\tbreak;\n\t\t}\n\t\tt += jiffies;\n\t\t \n\t\tif (action != TIMER_IAA_WATCHDOG\n\t\t\t\t&& t > oxu->watchdog.expires\n\t\t\t\t&& timer_pending(&oxu->watchdog))\n\t\t\treturn;\n\t\tmod_timer(&oxu->watchdog, t);\n\t}\n}\n\n \nstatic int handshake(struct oxu_hcd *oxu, void __iomem *ptr,\n\t\t\t\t\tu32 mask, u32 done, int usec)\n{\n\tu32 result;\n\tint ret;\n\n\tret = readl_poll_timeout_atomic(ptr, result,\n\t\t\t\t\t((result & mask) == done ||\n\t\t\t\t\t result == U32_MAX),\n\t\t\t\t\t1, usec);\n\tif (result == U32_MAX)\t\t \n\t\treturn -ENODEV;\n\n\treturn ret;\n}\n\n \nstatic int ehci_halt(struct oxu_hcd *oxu)\n{\n\tu32\ttemp = readl(&oxu->regs->status);\n\n\t \n\twritel(0, &oxu->regs->intr_enable);\n\n\tif ((temp & STS_HALT) != 0)\n\t\treturn 0;\n\n\ttemp = readl(&oxu->regs->command);\n\ttemp &= ~CMD_RUN;\n\twritel(temp, &oxu->regs->command);\n\treturn handshake(oxu, &oxu->regs->status,\n\t\t\t  STS_HALT, STS_HALT, 16 * 125);\n}\n\n \nstatic void tdi_reset(struct oxu_hcd *oxu)\n{\n\tu32 __iomem *reg_ptr;\n\tu32 tmp;\n\n\treg_ptr = (u32 __iomem *)(((u8 __iomem *)oxu->regs) + 0x68);\n\ttmp = readl(reg_ptr);\n\ttmp |= 0x3;\n\twritel(tmp, reg_ptr);\n}\n\n \nstatic int ehci_reset(struct oxu_hcd *oxu)\n{\n\tint\tretval;\n\tu32\tcommand = readl(&oxu->regs->command);\n\n\tcommand |= CMD_RESET;\n\tdbg_cmd(oxu, \"reset\", command);\n\twritel(command, &oxu->regs->command);\n\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\toxu->next_statechange = jiffies;\n\tretval = handshake(oxu, &oxu->regs->command,\n\t\t\t    CMD_RESET, 0, 250 * 1000);\n\n\tif (retval)\n\t\treturn retval;\n\n\ttdi_reset(oxu);\n\n\treturn retval;\n}\n\n \nstatic void ehci_quiesce(struct oxu_hcd *oxu)\n{\n\tu32\ttemp;\n\n#ifdef DEBUG\n\tBUG_ON(!HC_IS_RUNNING(oxu_to_hcd(oxu)->state));\n#endif\n\n\t \n\ttemp = readl(&oxu->regs->command) << 10;\n\ttemp &= STS_ASS | STS_PSS;\n\tif (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,\n\t\t\t\ttemp, 16 * 125) != 0) {\n\t\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\t\treturn;\n\t}\n\n\t \n\ttemp = readl(&oxu->regs->command);\n\ttemp &= ~(CMD_ASE | CMD_IAAD | CMD_PSE);\n\twritel(temp, &oxu->regs->command);\n\n\t \n\tif (handshake(oxu, &oxu->regs->status, STS_ASS | STS_PSS,\n\t\t\t\t0, 16 * 125) != 0) {\n\t\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\t\treturn;\n\t}\n}\n\nstatic int check_reset_complete(struct oxu_hcd *oxu, int index,\n\t\t\t\tu32 __iomem *status_reg, int port_status)\n{\n\tif (!(port_status & PORT_CONNECT)) {\n\t\toxu->reset_done[index] = 0;\n\t\treturn port_status;\n\t}\n\n\t \n\tif (!(port_status & PORT_PE)) {\n\t\toxu_dbg(oxu, \"Failed to enable port %d on root hub TT\\n\",\n\t\t\t\tindex+1);\n\t\treturn port_status;\n\t} else\n\t\toxu_dbg(oxu, \"port %d high speed\\n\", index + 1);\n\n\treturn port_status;\n}\n\nstatic void ehci_hub_descriptor(struct oxu_hcd *oxu,\n\t\t\t\tstruct usb_hub_descriptor *desc)\n{\n\tint ports = HCS_N_PORTS(oxu->hcs_params);\n\tu16 temp;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bPwrOn2PwrGood = 10;\t \n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ports;\n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\t \n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\n\tmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\n\n\ttemp = HUB_CHAR_INDV_PORT_OCPM;\t \n\tif (HCS_PPC(oxu->hcs_params))\n\t\ttemp |= HUB_CHAR_INDV_PORT_LPSM;  \n\telse\n\t\ttemp |= HUB_CHAR_NO_LPSM;  \n\tdesc->wHubCharacteristics = (__force __u16)cpu_to_le16(temp);\n}\n\n\n \nstatic int oxu_buf_alloc(struct oxu_hcd *oxu, struct ehci_qtd *qtd, int len)\n{\n\tint n_blocks;\t \n\tint a_blocks;\t \n\tint i, j;\n\n\t \n\tif (len > BUFFER_SIZE * BUFFER_NUM) {\n\t\toxu_err(oxu, \"buffer too big (%d)\\n\", len);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock(&oxu->mem_lock);\n\n\t \n\tn_blocks = (len + BUFFER_SIZE - 1) / BUFFER_SIZE;\n\n\t \n\tfor (a_blocks = 1; a_blocks < n_blocks; a_blocks <<= 1)\n\t\t;\n\n\t \n\tfor (i = 0; i < BUFFER_NUM;\n\t\t\ti += max(a_blocks, (int)oxu->db_used[i])) {\n\n\t\t \n\t\tfor (j = 0; j < a_blocks; j++)\n\t\t\tif (oxu->db_used[i + j])\n\t\t\t\tbreak;\n\n\t\tif (j != a_blocks)\n\t\t\tcontinue;\n\n\t\t \n\t\tqtd->buffer = (void *) &oxu->mem->db_pool[i];\n\t\tqtd->buffer_dma = virt_to_phys(qtd->buffer);\n\n\t\tqtd->qtd_buffer_len = BUFFER_SIZE * a_blocks;\n\t\toxu->db_used[i] = a_blocks;\n\n\t\tspin_unlock(&oxu->mem_lock);\n\n\t\treturn 0;\n\t}\n\n\t \n\n\tspin_unlock(&oxu->mem_lock);\n\n\treturn -ENOMEM;\n}\n\nstatic void oxu_buf_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)\n{\n\tint index;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tindex = (qtd->buffer - (void *) &oxu->mem->db_pool[0])\n\t\t\t\t\t\t\t / BUFFER_SIZE;\n\toxu->db_used[index] = 0;\n\tqtd->qtd_buffer_len = 0;\n\tqtd->buffer_dma = 0;\n\tqtd->buffer = NULL;\n\n\tspin_unlock(&oxu->mem_lock);\n}\n\nstatic inline void ehci_qtd_init(struct ehci_qtd *qtd, dma_addr_t dma)\n{\n\tmemset(qtd, 0, sizeof *qtd);\n\tqtd->qtd_dma = dma;\n\tqtd->hw_token = cpu_to_le32(QTD_STS_HALT);\n\tqtd->hw_next = EHCI_LIST_END;\n\tqtd->hw_alt_next = EHCI_LIST_END;\n\tINIT_LIST_HEAD(&qtd->qtd_list);\n}\n\nstatic inline void oxu_qtd_free(struct oxu_hcd *oxu, struct ehci_qtd *qtd)\n{\n\tint index;\n\n\tif (qtd->buffer)\n\t\toxu_buf_free(oxu, qtd);\n\n\tspin_lock(&oxu->mem_lock);\n\n\tindex = qtd - &oxu->mem->qtd_pool[0];\n\toxu->qtd_used[index] = 0;\n\n\tspin_unlock(&oxu->mem_lock);\n}\n\nstatic struct ehci_qtd *ehci_qtd_alloc(struct oxu_hcd *oxu)\n{\n\tint i;\n\tstruct ehci_qtd *qtd = NULL;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tfor (i = 0; i < QTD_NUM; i++)\n\t\tif (!oxu->qtd_used[i])\n\t\t\tbreak;\n\n\tif (i < QTD_NUM) {\n\t\tqtd = (struct ehci_qtd *) &oxu->mem->qtd_pool[i];\n\t\tmemset(qtd, 0, sizeof *qtd);\n\n\t\tqtd->hw_token = cpu_to_le32(QTD_STS_HALT);\n\t\tqtd->hw_next = EHCI_LIST_END;\n\t\tqtd->hw_alt_next = EHCI_LIST_END;\n\t\tINIT_LIST_HEAD(&qtd->qtd_list);\n\n\t\tqtd->qtd_dma = virt_to_phys(qtd);\n\n\t\toxu->qtd_used[i] = 1;\n\t}\n\n\tspin_unlock(&oxu->mem_lock);\n\n\treturn qtd;\n}\n\nstatic void oxu_qh_free(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tint index;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tindex = qh - &oxu->mem->qh_pool[0];\n\toxu->qh_used[index] = 0;\n\n\tspin_unlock(&oxu->mem_lock);\n}\n\nstatic void qh_destroy(struct kref *kref)\n{\n\tstruct ehci_qh *qh = container_of(kref, struct ehci_qh, kref);\n\tstruct oxu_hcd *oxu = qh->oxu;\n\n\t \n\tif (!list_empty(&qh->qtd_list) || qh->qh_next.ptr) {\n\t\toxu_dbg(oxu, \"unused qh not empty!\\n\");\n\t\tBUG();\n\t}\n\tif (qh->dummy)\n\t\toxu_qtd_free(oxu, qh->dummy);\n\toxu_qh_free(oxu, qh);\n}\n\nstatic struct ehci_qh *oxu_qh_alloc(struct oxu_hcd *oxu)\n{\n\tint i;\n\tstruct ehci_qh *qh = NULL;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tfor (i = 0; i < QHEAD_NUM; i++)\n\t\tif (!oxu->qh_used[i])\n\t\t\tbreak;\n\n\tif (i < QHEAD_NUM) {\n\t\tqh = (struct ehci_qh *) &oxu->mem->qh_pool[i];\n\t\tmemset(qh, 0, sizeof *qh);\n\n\t\tkref_init(&qh->kref);\n\t\tqh->oxu = oxu;\n\t\tqh->qh_dma = virt_to_phys(qh);\n\t\tINIT_LIST_HEAD(&qh->qtd_list);\n\n\t\t \n\t\tqh->dummy = ehci_qtd_alloc(oxu);\n\t\tif (qh->dummy == NULL) {\n\t\t\toxu_dbg(oxu, \"no dummy td\\n\");\n\t\t\toxu->qh_used[i] = 0;\n\t\t\tqh = NULL;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\toxu->qh_used[i] = 1;\n\t}\nunlock:\n\tspin_unlock(&oxu->mem_lock);\n\n\treturn qh;\n}\n\n \nstatic inline struct ehci_qh *qh_get(struct ehci_qh *qh)\n{\n\tkref_get(&qh->kref);\n\treturn qh;\n}\n\nstatic inline void qh_put(struct ehci_qh *qh)\n{\n\tkref_put(&qh->kref, qh_destroy);\n}\n\nstatic void oxu_murb_free(struct oxu_hcd *oxu, struct oxu_murb *murb)\n{\n\tint index;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tindex = murb - &oxu->murb_pool[0];\n\toxu->murb_used[index] = 0;\n\n\tspin_unlock(&oxu->mem_lock);\n}\n\nstatic struct oxu_murb *oxu_murb_alloc(struct oxu_hcd *oxu)\n\n{\n\tint i;\n\tstruct oxu_murb *murb = NULL;\n\n\tspin_lock(&oxu->mem_lock);\n\n\tfor (i = 0; i < MURB_NUM; i++)\n\t\tif (!oxu->murb_used[i])\n\t\t\tbreak;\n\n\tif (i < MURB_NUM) {\n\t\tmurb = &(oxu->murb_pool)[i];\n\n\t\toxu->murb_used[i] = 1;\n\t}\n\n\tspin_unlock(&oxu->mem_lock);\n\n\treturn murb;\n}\n\n \nstatic void ehci_mem_cleanup(struct oxu_hcd *oxu)\n{\n\tkfree(oxu->murb_pool);\n\toxu->murb_pool = NULL;\n\n\tif (oxu->async)\n\t\tqh_put(oxu->async);\n\toxu->async = NULL;\n\n\tdel_timer(&oxu->urb_timer);\n\n\toxu->periodic = NULL;\n\n\t \n\tkfree(oxu->pshadow);\n\toxu->pshadow = NULL;\n}\n\n \nstatic int ehci_mem_init(struct oxu_hcd *oxu, gfp_t flags)\n{\n\tint i;\n\n\tfor (i = 0; i < oxu->periodic_size; i++)\n\t\toxu->mem->frame_list[i] = EHCI_LIST_END;\n\tfor (i = 0; i < QHEAD_NUM; i++)\n\t\toxu->qh_used[i] = 0;\n\tfor (i = 0; i < QTD_NUM; i++)\n\t\toxu->qtd_used[i] = 0;\n\n\toxu->murb_pool = kcalloc(MURB_NUM, sizeof(struct oxu_murb), flags);\n\tif (!oxu->murb_pool)\n\t\tgoto fail;\n\n\tfor (i = 0; i < MURB_NUM; i++)\n\t\toxu->murb_used[i] = 0;\n\n\toxu->async = oxu_qh_alloc(oxu);\n\tif (!oxu->async)\n\t\tgoto fail;\n\n\toxu->periodic = (__le32 *) &oxu->mem->frame_list;\n\toxu->periodic_dma = virt_to_phys(oxu->periodic);\n\n\tfor (i = 0; i < oxu->periodic_size; i++)\n\t\toxu->periodic[i] = EHCI_LIST_END;\n\n\t \n\toxu->pshadow = kcalloc(oxu->periodic_size, sizeof(void *), flags);\n\tif (oxu->pshadow != NULL)\n\t\treturn 0;\n\nfail:\n\toxu_dbg(oxu, \"couldn't init memory\\n\");\n\tehci_mem_cleanup(oxu);\n\treturn -ENOMEM;\n}\n\n \nstatic int qtd_fill(struct ehci_qtd *qtd, dma_addr_t buf, size_t len,\n\t\t\t\tint token, int maxpacket)\n{\n\tint i, count;\n\tu64 addr = buf;\n\n\t \n\tqtd->hw_buf[0] = cpu_to_le32((u32)addr);\n\tqtd->hw_buf_hi[0] = cpu_to_le32((u32)(addr >> 32));\n\tcount = 0x1000 - (buf & 0x0fff);\t \n\tif (likely(len < count))\t\t \n\t\tcount = len;\n\telse {\n\t\tbuf +=  0x1000;\n\t\tbuf &= ~0x0fff;\n\n\t\t \n\t\tfor (i = 1; count < len && i < 5; i++) {\n\t\t\taddr = buf;\n\t\t\tqtd->hw_buf[i] = cpu_to_le32((u32)addr);\n\t\t\tqtd->hw_buf_hi[i] = cpu_to_le32((u32)(addr >> 32));\n\t\t\tbuf += 0x1000;\n\t\t\tif ((count + 0x1000) < len)\n\t\t\t\tcount += 0x1000;\n\t\t\telse\n\t\t\t\tcount = len;\n\t\t}\n\n\t\t \n\t\tif (count != len)\n\t\t\tcount -= (count % maxpacket);\n\t}\n\tqtd->hw_token = cpu_to_le32((count << 16) | token);\n\tqtd->length = count;\n\n\treturn count;\n}\n\nstatic inline void qh_update(struct oxu_hcd *oxu,\n\t\t\t\tstruct ehci_qh *qh, struct ehci_qtd *qtd)\n{\n\t \n\tBUG_ON(qh->qh_state != QH_STATE_IDLE);\n\n\tqh->hw_qtd_next = QTD_NEXT(qtd->qtd_dma);\n\tqh->hw_alt_next = EHCI_LIST_END;\n\n\t \n\tif (!(qh->hw_info1 & cpu_to_le32(1 << 14))) {\n\t\tunsigned\tis_out, epnum;\n\n\t\tis_out = !(qtd->hw_token & cpu_to_le32(1 << 8));\n\t\tepnum = (le32_to_cpup(&qh->hw_info1) >> 8) & 0x0f;\n\t\tif (unlikely(!usb_gettoggle(qh->dev, epnum, is_out))) {\n\t\t\tqh->hw_token &= ~cpu_to_le32(QTD_TOGGLE);\n\t\t\tusb_settoggle(qh->dev, epnum, is_out, 1);\n\t\t}\n\t}\n\n\t \n\twmb();\n\tqh->hw_token &= cpu_to_le32(QTD_TOGGLE | QTD_STS_PING);\n}\n\n \nstatic void qh_refresh(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tstruct ehci_qtd *qtd;\n\n\tif (list_empty(&qh->qtd_list))\n\t\tqtd = qh->dummy;\n\telse {\n\t\tqtd = list_entry(qh->qtd_list.next,\n\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t \n\t\tif (cpu_to_le32(qtd->qtd_dma) == qh->hw_current)\n\t\t\tqtd = NULL;\n\t}\n\n\tif (qtd)\n\t\tqh_update(oxu, qh, qtd);\n}\n\nstatic void qtd_copy_status(struct oxu_hcd *oxu, struct urb *urb,\n\t\t\t\tsize_t length, u32 token)\n{\n\t \n\tif (likely(QTD_PID(token) != 2))\n\t\turb->actual_length += length - QTD_LENGTH(token);\n\n\t \n\tif (unlikely(urb->status != -EINPROGRESS))\n\t\treturn;\n\n\t \n\tif (unlikely(IS_SHORT_READ(token)))\n\t\turb->status = -EREMOTEIO;\n\n\t \n\tif (token & QTD_STS_HALT) {\n\t\tif (token & QTD_STS_BABBLE) {\n\t\t\t \n\t\t\turb->status = -EOVERFLOW;\n\t\t} else if (token & QTD_STS_MMF) {\n\t\t\t \n\t\t\turb->status = -EPROTO;\n\t\t} else if (token & QTD_STS_DBE) {\n\t\t\turb->status = (QTD_PID(token) == 1)  \n\t\t\t\t? -ENOSR   \n\t\t\t\t: -ECOMM;  \n\t\t} else if (token & QTD_STS_XACT) {\n\t\t\t \n\t\t\tif (QTD_CERR(token))\n\t\t\t\turb->status = -EPIPE;\n\t\t\telse {\n\t\t\t\toxu_dbg(oxu, \"devpath %s ep%d%s 3strikes\\n\",\n\t\t\t\t\turb->dev->devpath,\n\t\t\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\");\n\t\t\t\turb->status = -EPROTO;\n\t\t\t}\n\t\t \n\t\t} else if (QTD_CERR(token))\n\t\t\turb->status = -EPIPE;\n\t\telse\t \n\t\t\turb->status = -EPROTO;\n\n\t\toxu_vdbg(oxu, \"dev%d ep%d%s qtd token %08x --> status %d\\n\",\n\t\t\tusb_pipedevice(urb->pipe),\n\t\t\tusb_pipeendpoint(urb->pipe),\n\t\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\t\ttoken, urb->status);\n\t}\n}\n\nstatic void ehci_urb_done(struct oxu_hcd *oxu, struct urb *urb)\n__releases(oxu->lock)\n__acquires(oxu->lock)\n{\n\tif (likely(urb->hcpriv != NULL)) {\n\t\tstruct ehci_qh\t*qh = (struct ehci_qh *) urb->hcpriv;\n\n\t\t \n\t\tif ((qh->hw_info2 & cpu_to_le32(QH_SMASK)) != 0) {\n\n\t\t\t \n\t\t\toxu_to_hcd(oxu)->self.bandwidth_int_reqs--;\n\t\t}\n\t\tqh_put(qh);\n\t}\n\n\turb->hcpriv = NULL;\n\tswitch (urb->status) {\n\tcase -EINPROGRESS:\t\t \n\t\turb->status = 0;\n\t\tbreak;\n\tdefault:\t\t\t \n\t\tbreak;\n\tcase -EREMOTEIO:\t\t \n\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\n\t\t\turb->status = 0;\n\t\tbreak;\n\tcase -ECONNRESET:\t\t \n\tcase -ENOENT:\n\t\tbreak;\n\t}\n\n#ifdef OXU_URB_TRACE\n\toxu_dbg(oxu, \"%s %s urb %p ep%d%s status %d len %d/%d\\n\",\n\t\t__func__, urb->dev->devpath, urb,\n\t\tusb_pipeendpoint(urb->pipe),\n\t\tusb_pipein(urb->pipe) ? \"in\" : \"out\",\n\t\turb->status,\n\t\turb->actual_length, urb->transfer_buffer_length);\n#endif\n\n\t \n\tspin_unlock(&oxu->lock);\n\tusb_hcd_giveback_urb(oxu_to_hcd(oxu), urb, urb->status);\n\tspin_lock(&oxu->lock);\n}\n\nstatic void start_unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh);\nstatic void unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh);\n\nstatic void intr_deschedule(struct oxu_hcd *oxu, struct ehci_qh *qh);\nstatic int qh_schedule(struct oxu_hcd *oxu, struct ehci_qh *qh);\n\n#define HALT_BIT cpu_to_le32(QTD_STS_HALT)\n\n \nstatic unsigned qh_completions(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tstruct ehci_qtd *last = NULL, *end = qh->dummy;\n\tstruct ehci_qtd\t*qtd, *tmp;\n\tint stopped;\n\tunsigned count = 0;\n\tint do_status = 0;\n\tu8 state;\n\tstruct oxu_murb *murb = NULL;\n\n\tif (unlikely(list_empty(&qh->qtd_list)))\n\t\treturn count;\n\n\t \n\tstate = qh->qh_state;\n\tqh->qh_state = QH_STATE_COMPLETING;\n\tstopped = (state == QH_STATE_IDLE);\n\n\t \n\tlist_for_each_entry_safe(qtd, tmp, &qh->qtd_list, qtd_list) {\n\t\tstruct urb *urb;\n\t\tu32 token = 0;\n\n\t\turb = qtd->urb;\n\n\t\t \n\t\tif (last) {\n\t\t\tif (likely(last->urb != urb)) {\n\t\t\t\tif (last->urb->complete == NULL) {\n\t\t\t\t\tmurb = (struct oxu_murb *) last->urb;\n\t\t\t\t\tlast->urb = murb->main;\n\t\t\t\t\tif (murb->last) {\n\t\t\t\t\t\tehci_urb_done(oxu, last->urb);\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\toxu_murb_free(oxu, murb);\n\t\t\t\t} else {\n\t\t\t\t\tehci_urb_done(oxu, last->urb);\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\toxu_qtd_free(oxu, last);\n\t\t\tlast = NULL;\n\t\t}\n\n\t\t \n\t\tif (qtd == end)\n\t\t\tbreak;\n\n\t\t \n\t\trmb();\n\t\ttoken = le32_to_cpu(qtd->hw_token);\n\n\t\t \n\t\tif ((token & QTD_STS_ACTIVE) == 0) {\n\n\t\t\tif ((token & QTD_STS_HALT) != 0) {\n\t\t\t\tstopped = 1;\n\n\t\t\t \n\t\t\t} else if (IS_SHORT_READ(token) &&\n\t\t\t\t\t!(qtd->hw_alt_next & EHCI_LIST_END)) {\n\t\t\t\tstopped = 1;\n\t\t\t\tgoto halt;\n\t\t\t}\n\n\t\t \n\t\t} else if (likely(!stopped &&\n\t\t\t\tHC_IS_RUNNING(oxu_to_hcd(oxu)->state))) {\n\t\t\tbreak;\n\n\t\t} else {\n\t\t\tstopped = 1;\n\n\t\t\tif (unlikely(!HC_IS_RUNNING(oxu_to_hcd(oxu)->state)))\n\t\t\t\turb->status = -ESHUTDOWN;\n\n\t\t\t \n\t\t\tif (likely(urb->status == -EINPROGRESS))\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\tif (unlikely(do_status != 0)\n\t\t\t\t\t&& QTD_PID(token) == 0  ) {\n\t\t\t\tdo_status = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (state == QH_STATE_IDLE\n\t\t\t\t\t&& cpu_to_le32(qtd->qtd_dma)\n\t\t\t\t\t\t== qh->hw_current)\n\t\t\t\ttoken = le32_to_cpu(qh->hw_token);\n\n\t\t\t \n\t\t\tif ((HALT_BIT & qh->hw_token) == 0) {\nhalt:\n\t\t\t\tqh->hw_token |= HALT_BIT;\n\t\t\t\twmb();\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tqtd_copy_status(oxu, urb->complete ?\n\t\t\t\t\turb : ((struct oxu_murb *) urb)->main,\n\t\t\t\tqtd->length, token);\n\t\tif ((usb_pipein(qtd->urb->pipe)) &&\n\t\t\t\t(NULL != qtd->transfer_buffer))\n\t\t\tmemcpy(qtd->transfer_buffer, qtd->buffer, qtd->length);\n\t\tdo_status = (urb->status == -EREMOTEIO)\n\t\t\t\t&& usb_pipecontrol(urb->pipe);\n\n\t\tif (stopped && qtd->qtd_list.prev != &qh->qtd_list) {\n\t\t\tlast = list_entry(qtd->qtd_list.prev,\n\t\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t\tlast->hw_next = qtd->hw_next;\n\t\t}\n\t\tlist_del(&qtd->qtd_list);\n\t\tlast = qtd;\n\t}\n\n\t \n\tif (likely(last != NULL)) {\n\t\tif (last->urb->complete == NULL) {\n\t\t\tmurb = (struct oxu_murb *) last->urb;\n\t\t\tlast->urb = murb->main;\n\t\t\tif (murb->last) {\n\t\t\t\tehci_urb_done(oxu, last->urb);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\toxu_murb_free(oxu, murb);\n\t\t} else {\n\t\t\tehci_urb_done(oxu, last->urb);\n\t\t\tcount++;\n\t\t}\n\t\toxu_qtd_free(oxu, last);\n\t}\n\n\t \n\tqh->qh_state = state;\n\n\t \n\tif (stopped != 0 || qh->hw_qtd_next == EHCI_LIST_END) {\n\t\tswitch (state) {\n\t\tcase QH_STATE_IDLE:\n\t\t\tqh_refresh(oxu, qh);\n\t\t\tbreak;\n\t\tcase QH_STATE_LINKED:\n\t\t\t \n\t\t\tif ((cpu_to_le32(QH_SMASK)\n\t\t\t\t\t& qh->hw_info2) != 0) {\n\t\t\t\tintr_deschedule(oxu, qh);\n\t\t\t\t(void) qh_schedule(oxu, qh);\n\t\t\t} else\n\t\t\t\tunlink_async(oxu, qh);\n\t\t\tbreak;\n\t\t \n\t\t}\n\t}\n\n\treturn count;\n}\n\n \n#define hb_mult(wMaxPacketSize)\t\t(1 + (((wMaxPacketSize) >> 11) & 0x03))\n \n#define max_packet(wMaxPacketSize)\t((wMaxPacketSize) & 0x07ff)\n\n \nstatic void qtd_list_free(struct oxu_hcd *oxu,\n\t\t\t\tstruct urb *urb, struct list_head *head)\n{\n\tstruct ehci_qtd\t*qtd, *temp;\n\n\tlist_for_each_entry_safe(qtd, temp, head, qtd_list) {\n\t\tlist_del(&qtd->qtd_list);\n\t\toxu_qtd_free(oxu, qtd);\n\t}\n}\n\n \nstatic struct list_head *qh_urb_transaction(struct oxu_hcd *oxu,\n\t\t\t\t\t\tstruct urb *urb,\n\t\t\t\t\t\tstruct list_head *head,\n\t\t\t\t\t\tgfp_t flags)\n{\n\tstruct ehci_qtd\t*qtd, *qtd_prev;\n\tdma_addr_t buf;\n\tint len, maxpacket;\n\tint is_input;\n\tu32 token;\n\tvoid *transfer_buf = NULL;\n\tint ret;\n\n\t \n\tqtd = ehci_qtd_alloc(oxu);\n\tif (unlikely(!qtd))\n\t\treturn NULL;\n\tlist_add_tail(&qtd->qtd_list, head);\n\tqtd->urb = urb;\n\n\ttoken = QTD_STS_ACTIVE;\n\ttoken |= (EHCI_TUNE_CERR << 10);\n\t \n\n\tlen = urb->transfer_buffer_length;\n\tis_input = usb_pipein(urb->pipe);\n\tif (!urb->transfer_buffer && urb->transfer_buffer_length && is_input)\n\t\turb->transfer_buffer = phys_to_virt(urb->transfer_dma);\n\n\tif (usb_pipecontrol(urb->pipe)) {\n\t\t \n\t\tret = oxu_buf_alloc(oxu, qtd, sizeof(struct usb_ctrlrequest));\n\t\tif (ret)\n\t\t\tgoto cleanup;\n\n\t\tqtd_fill(qtd, qtd->buffer_dma, sizeof(struct usb_ctrlrequest),\n\t\t\t\ttoken | (2   << 8), 8);\n\t\tmemcpy(qtd->buffer, qtd->urb->setup_packet,\n\t\t\t\tsizeof(struct usb_ctrlrequest));\n\n\t\t \n\t\ttoken ^= QTD_TOGGLE;\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc(oxu);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t \n\t\tif (len == 0)\n\t\t\ttoken |= (1   << 8);\n\t}\n\n\t \n\n\tret = oxu_buf_alloc(oxu, qtd, len);\n\tif (ret)\n\t\tgoto cleanup;\n\n\tbuf = qtd->buffer_dma;\n\ttransfer_buf = urb->transfer_buffer;\n\n\tif (!is_input)\n\t\tmemcpy(qtd->buffer, qtd->urb->transfer_buffer, len);\n\n\tif (is_input)\n\t\ttoken |= (1   << 8);\n\t \n\n\tmaxpacket = usb_maxpacket(urb->dev, urb->pipe);\n\n\t \n\tfor (;;) {\n\t\tint this_qtd_len;\n\n\t\tthis_qtd_len = qtd_fill(qtd, buf, len, token, maxpacket);\n\t\tqtd->transfer_buffer = transfer_buf;\n\t\tlen -= this_qtd_len;\n\t\tbuf += this_qtd_len;\n\t\ttransfer_buf += this_qtd_len;\n\t\tif (is_input)\n\t\t\tqtd->hw_alt_next = oxu->async->hw_alt_next;\n\n\t\t \n\t\tif ((maxpacket & (this_qtd_len + (maxpacket - 1))) == 0)\n\t\t\ttoken ^= QTD_TOGGLE;\n\n\t\tif (likely(len <= 0))\n\t\t\tbreak;\n\n\t\tqtd_prev = qtd;\n\t\tqtd = ehci_qtd_alloc(oxu);\n\t\tif (unlikely(!qtd))\n\t\t\tgoto cleanup;\n\t\tif (likely(len > 0)) {\n\t\t\tret = oxu_buf_alloc(oxu, qtd, len);\n\t\t\tif (ret)\n\t\t\t\tgoto cleanup;\n\t\t}\n\t\tqtd->urb = urb;\n\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\tlist_add_tail(&qtd->qtd_list, head);\n\t}\n\n\t \n\tif (likely((urb->transfer_flags & URB_SHORT_NOT_OK) == 0\n\t\t\t\t|| usb_pipecontrol(urb->pipe)))\n\t\tqtd->hw_alt_next = EHCI_LIST_END;\n\n\t \n\tif (likely(urb->transfer_buffer_length != 0)) {\n\t\tint\tone_more = 0;\n\n\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\tone_more = 1;\n\t\t\ttoken ^= 0x0100;\t \n\t\t\ttoken |= QTD_TOGGLE;\t \n\t\t} else if (usb_pipebulk(urb->pipe)\n\t\t\t\t&& (urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& !(urb->transfer_buffer_length % maxpacket)) {\n\t\t\tone_more = 1;\n\t\t}\n\t\tif (one_more) {\n\t\t\tqtd_prev = qtd;\n\t\t\tqtd = ehci_qtd_alloc(oxu);\n\t\t\tif (unlikely(!qtd))\n\t\t\t\tgoto cleanup;\n\t\t\tqtd->urb = urb;\n\t\t\tqtd_prev->hw_next = QTD_NEXT(qtd->qtd_dma);\n\t\t\tlist_add_tail(&qtd->qtd_list, head);\n\n\t\t\t \n\t\t\tqtd_fill(qtd, 0, 0, token, 0);\n\t\t}\n\t}\n\n\t \n\tqtd->hw_token |= cpu_to_le32(QTD_IOC);\n\treturn head;\n\ncleanup:\n\tqtd_list_free(oxu, urb, head);\n\treturn NULL;\n}\n\n \nstatic struct ehci_qh *qh_make(struct oxu_hcd *oxu,\n\t\t\t\tstruct urb *urb, gfp_t flags)\n{\n\tstruct ehci_qh *qh = oxu_qh_alloc(oxu);\n\tu32 info1 = 0, info2 = 0;\n\tint is_input, type;\n\tint maxp = 0;\n\n\tif (!qh)\n\t\treturn qh;\n\n\t \n\tinfo1 |= usb_pipeendpoint(urb->pipe) << 8;\n\tinfo1 |= usb_pipedevice(urb->pipe) << 0;\n\n\tis_input = usb_pipein(urb->pipe);\n\ttype = usb_pipetype(urb->pipe);\n\tmaxp = usb_maxpacket(urb->dev, urb->pipe);\n\n\t \n\tif (type == PIPE_INTERRUPT) {\n\t\tqh->usecs = NS_TO_US(usb_calc_bus_time(USB_SPEED_HIGH,\n\t\t\t\t\t\t\t\tis_input, 0,\n\t\t\t\thb_mult(maxp) * max_packet(maxp)));\n\t\tqh->start = NO_FRAME;\n\n\t\tif (urb->dev->speed == USB_SPEED_HIGH) {\n\t\t\tqh->c_usecs = 0;\n\t\t\tqh->gap_uf = 0;\n\n\t\t\tqh->period = urb->interval >> 3;\n\t\t\tif (qh->period == 0 && urb->interval != 1) {\n\t\t\t\t \n\t\t\t\toxu_dbg(oxu, \"intr period %d uframes, NYET!\\n\",\n\t\t\t\t\turb->interval);\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t} else {\n\t\t\tstruct usb_tt\t*tt = urb->dev->tt;\n\t\t\tint\t\tthink_time;\n\n\t\t\t \n\t\t\tqh->gap_uf = 1 + usb_calc_bus_time(urb->dev->speed,\n\t\t\t\t\tis_input, 0, maxp) / (125 * 1000);\n\n\t\t\t \n\t\t\tif (is_input) {\t\t \n\t\t\t\tqh->c_usecs = qh->usecs + HS_USECS(0);\n\t\t\t\tqh->usecs = HS_USECS(1);\n\t\t\t} else {\t\t \n\t\t\t\tqh->usecs += HS_USECS(1);\n\t\t\t\tqh->c_usecs = HS_USECS(0);\n\t\t\t}\n\n\t\t\tthink_time = tt ? tt->think_time : 0;\n\t\t\tqh->tt_usecs = NS_TO_US(think_time +\n\t\t\t\t\tusb_calc_bus_time(urb->dev->speed,\n\t\t\t\t\tis_input, 0, max_packet(maxp)));\n\t\t\tqh->period = urb->interval;\n\t\t}\n\t}\n\n\t \n\tqh->dev = urb->dev;\n\n\t \n\tswitch (urb->dev->speed) {\n\tcase USB_SPEED_LOW:\n\t\tinfo1 |= (1 << 12);\t \n\t\tfallthrough;\n\n\tcase USB_SPEED_FULL:\n\t\t \n\t\tif (type != PIPE_INTERRUPT)\n\t\t\tinfo1 |= (EHCI_TUNE_RL_TT << 28);\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= (1 << 27);\t \n\t\t\tinfo1 |= 1 << 14;\t \n\t\t}\n\t\tinfo1 |= maxp << 16;\n\n\t\tinfo2 |= (EHCI_TUNE_MULT_TT << 30);\n\t\tinfo2 |= urb->dev->ttport << 23;\n\n\t\t \n\n\t\tbreak;\n\n\tcase USB_SPEED_HIGH:\t\t \n\t\tinfo1 |= (2 << 12);\t \n\t\tif (type == PIPE_CONTROL) {\n\t\t\tinfo1 |= (EHCI_TUNE_RL_HS << 28);\n\t\t\tinfo1 |= 64 << 16;\t \n\t\t\tinfo1 |= 1 << 14;\t \n\t\t\tinfo2 |= (EHCI_TUNE_MULT_HS << 30);\n\t\t} else if (type == PIPE_BULK) {\n\t\t\tinfo1 |= (EHCI_TUNE_RL_HS << 28);\n\t\t\tinfo1 |= 512 << 16;\t \n\t\t\tinfo2 |= (EHCI_TUNE_MULT_HS << 30);\n\t\t} else {\t\t \n\t\t\tinfo1 |= max_packet(maxp) << 16;\n\t\t\tinfo2 |= hb_mult(maxp) << 30;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\toxu_dbg(oxu, \"bogus dev %p speed %d\\n\", urb->dev, urb->dev->speed);\ndone:\n\t\tqh_put(qh);\n\t\treturn NULL;\n\t}\n\n\t \n\n\t \n\tqh->qh_state = QH_STATE_IDLE;\n\tqh->hw_info1 = cpu_to_le32(info1);\n\tqh->hw_info2 = cpu_to_le32(info2);\n\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe), !is_input, 1);\n\tqh_refresh(oxu, qh);\n\treturn qh;\n}\n\n \nstatic void qh_link_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\t__le32 dma = QH_NEXT(qh->qh_dma);\n\tstruct ehci_qh *head;\n\n\t \n\thead = oxu->async;\n\ttimer_action_done(oxu, TIMER_ASYNC_OFF);\n\tif (!head->qh_next.qh) {\n\t\tu32\tcmd = readl(&oxu->regs->command);\n\n\t\tif (!(cmd & CMD_ASE)) {\n\t\t\t \n\t\t\t(void)handshake(oxu, &oxu->regs->status,\n\t\t\t\t\tSTS_ASS, 0, 150);\n\t\t\tcmd |= CMD_ASE | CMD_RUN;\n\t\t\twritel(cmd, &oxu->regs->command);\n\t\t\toxu_to_hcd(oxu)->state = HC_STATE_RUNNING;\n\t\t\t \n\t\t}\n\t}\n\n\t \n\tif (qh->qh_state == QH_STATE_IDLE)\n\t\tqh_refresh(oxu, qh);\n\n\t \n\tqh->qh_next = head->qh_next;\n\tqh->hw_next = head->hw_next;\n\twmb();\n\n\thead->qh_next.qh = qh;\n\thead->hw_next = dma;\n\n\tqh->qh_state = QH_STATE_LINKED;\n\t \n}\n\n#define\tQH_ADDR_MASK\tcpu_to_le32(0x7f)\n\n \nstatic struct ehci_qh *qh_append_tds(struct oxu_hcd *oxu,\n\t\t\t\tstruct urb *urb, struct list_head *qtd_list,\n\t\t\t\tint epnum, void\t**ptr)\n{\n\tstruct ehci_qh *qh = NULL;\n\n\tqh = (struct ehci_qh *) *ptr;\n\tif (unlikely(qh == NULL)) {\n\t\t \n\t\tqh = qh_make(oxu, urb, GFP_ATOMIC);\n\t\t*ptr = qh;\n\t}\n\tif (likely(qh != NULL)) {\n\t\tstruct ehci_qtd\t*qtd;\n\n\t\tif (unlikely(list_empty(qtd_list)))\n\t\t\tqtd = NULL;\n\t\telse\n\t\t\tqtd = list_entry(qtd_list->next, struct ehci_qtd,\n\t\t\t\t\tqtd_list);\n\n\t\t \n\t\tif (unlikely(epnum == 0)) {\n\n\t\t\t \n\t\t\tif (usb_pipedevice(urb->pipe) == 0)\n\t\t\t\tqh->hw_info1 &= ~QH_ADDR_MASK;\n\t\t}\n\n\t\t \n\t\tif (likely(qtd != NULL)) {\n\t\t\tstruct ehci_qtd\t*dummy;\n\t\t\tdma_addr_t dma;\n\t\t\t__le32 token;\n\n\t\t\t \n\t\t\ttoken = qtd->hw_token;\n\t\t\tqtd->hw_token = HALT_BIT;\n\t\t\twmb();\n\t\t\tdummy = qh->dummy;\n\n\t\t\tdma = dummy->qtd_dma;\n\t\t\t*dummy = *qtd;\n\t\t\tdummy->qtd_dma = dma;\n\n\t\t\tlist_del(&qtd->qtd_list);\n\t\t\tlist_add(&dummy->qtd_list, qtd_list);\n\t\t\tlist_splice(qtd_list, qh->qtd_list.prev);\n\n\t\t\tehci_qtd_init(qtd, qtd->qtd_dma);\n\t\t\tqh->dummy = qtd;\n\n\t\t\t \n\t\t\tdma = qtd->qtd_dma;\n\t\t\tqtd = list_entry(qh->qtd_list.prev,\n\t\t\t\t\tstruct ehci_qtd, qtd_list);\n\t\t\tqtd->hw_next = QTD_NEXT(dma);\n\n\t\t\t \n\t\t\tdummy->hw_token = (token & ~(0x80));\n\t\t\twmb();\n\t\t\tdummy->hw_token = token;\n\n\t\t\turb->hcpriv = qh_get(qh);\n\t\t}\n\t}\n\treturn qh;\n}\n\nstatic int submit_async(struct oxu_hcd\t*oxu, struct urb *urb,\n\t\t\tstruct list_head *qtd_list, gfp_t mem_flags)\n{\n\tint epnum = urb->ep->desc.bEndpointAddress;\n\tunsigned long flags;\n\tstruct ehci_qh *qh = NULL;\n\tint rc = 0;\n#ifdef OXU_URB_TRACE\n\tstruct ehci_qtd\t*qtd;\n\n\tqtd = list_entry(qtd_list->next, struct ehci_qtd, qtd_list);\n\n\toxu_dbg(oxu, \"%s %s urb %p ep%d%s len %d, qtd %p [qh %p]\\n\",\n\t\t__func__, urb->dev->devpath, urb,\n\t\tepnum & 0x0f, (epnum & USB_DIR_IN) ? \"in\" : \"out\",\n\t\turb->transfer_buffer_length,\n\t\tqtd, urb->ep->hcpriv);\n#endif\n\n\tspin_lock_irqsave(&oxu->lock, flags);\n\tif (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {\n\t\trc = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n\n\tqh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tif (unlikely(qh == NULL)) {\n\t\trc = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\t \n\tif (likely(qh->qh_state == QH_STATE_IDLE))\n\t\tqh_link_async(oxu, qh_get(qh));\ndone:\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\tif (unlikely(qh == NULL))\n\t\tqtd_list_free(oxu, urb, qtd_list);\n\treturn rc;\n}\n\n \n\nstatic void end_unlink_async(struct oxu_hcd *oxu)\n{\n\tstruct ehci_qh *qh = oxu->reclaim;\n\tstruct ehci_qh *next;\n\n\ttimer_action_done(oxu, TIMER_IAA_WATCHDOG);\n\n\tqh->qh_state = QH_STATE_IDLE;\n\tqh->qh_next.qh = NULL;\n\tqh_put(qh);\t\t\t \n\n\t \n\tnext = qh->reclaim;\n\toxu->reclaim = next;\n\toxu->reclaim_ready = 0;\n\tqh->reclaim = NULL;\n\n\tqh_completions(oxu, qh);\n\n\tif (!list_empty(&qh->qtd_list)\n\t\t\t&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\n\t\tqh_link_async(oxu, qh);\n\telse {\n\t\tqh_put(qh);\t\t \n\n\t\t \n\t\tif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state)\n\t\t\t\t&& oxu->async->qh_next.qh == NULL)\n\t\t\ttimer_action(oxu, TIMER_ASYNC_OFF);\n\t}\n\n\tif (next) {\n\t\toxu->reclaim = NULL;\n\t\tstart_unlink_async(oxu, next);\n\t}\n}\n\n \n \n\nstatic void start_unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tint cmd = readl(&oxu->regs->command);\n\tstruct ehci_qh *prev;\n\n#ifdef DEBUG\n\tassert_spin_locked(&oxu->lock);\n\tBUG_ON(oxu->reclaim || (qh->qh_state != QH_STATE_LINKED\n\t\t\t\t&& qh->qh_state != QH_STATE_UNLINK_WAIT));\n#endif\n\n\t \n\tif (unlikely(qh == oxu->async)) {\n\t\t \n\t\tif (oxu_to_hcd(oxu)->state != HC_STATE_HALT\n\t\t\t\t&& !oxu->reclaim) {\n\t\t\t \n\t\t\twritel(cmd & ~CMD_ASE, &oxu->regs->command);\n\t\t\twmb();\n\t\t\t \n\t\t\ttimer_action_done(oxu, TIMER_ASYNC_OFF);\n\t\t}\n\t\treturn;\n\t}\n\n\tqh->qh_state = QH_STATE_UNLINK;\n\toxu->reclaim = qh = qh_get(qh);\n\n\tprev = oxu->async;\n\twhile (prev->qh_next.qh != qh)\n\t\tprev = prev->qh_next.qh;\n\n\tprev->hw_next = qh->hw_next;\n\tprev->qh_next = qh->qh_next;\n\twmb();\n\n\tif (unlikely(oxu_to_hcd(oxu)->state == HC_STATE_HALT)) {\n\t\t \n\t\tend_unlink_async(oxu);\n\t\treturn;\n\t}\n\n\toxu->reclaim_ready = 0;\n\tcmd |= CMD_IAAD;\n\twritel(cmd, &oxu->regs->command);\n\t(void) readl(&oxu->regs->command);\n\ttimer_action(oxu, TIMER_IAA_WATCHDOG);\n}\n\nstatic void scan_async(struct oxu_hcd *oxu)\n{\n\tstruct ehci_qh *qh;\n\tenum ehci_timer_action action = TIMER_IO_WATCHDOG;\n\n\tif (!++(oxu->stamp))\n\t\toxu->stamp++;\n\ttimer_action_done(oxu, TIMER_ASYNC_SHRINK);\nrescan:\n\tqh = oxu->async->qh_next.qh;\n\tif (likely(qh != NULL)) {\n\t\tdo {\n\t\t\t \n\t\t\tif (!list_empty(&qh->qtd_list)\n\t\t\t\t\t&& qh->stamp != oxu->stamp) {\n\t\t\t\tint temp;\n\n\t\t\t\t \n\t\t\t\tqh = qh_get(qh);\n\t\t\t\tqh->stamp = oxu->stamp;\n\t\t\t\ttemp = qh_completions(oxu, qh);\n\t\t\t\tqh_put(qh);\n\t\t\t\tif (temp != 0)\n\t\t\t\t\tgoto rescan;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (list_empty(&qh->qtd_list)) {\n\t\t\t\tif (qh->stamp == oxu->stamp)\n\t\t\t\t\taction = TIMER_ASYNC_SHRINK;\n\t\t\t\telse if (!oxu->reclaim\n\t\t\t\t\t    && qh->qh_state == QH_STATE_LINKED)\n\t\t\t\t\tstart_unlink_async(oxu, qh);\n\t\t\t}\n\n\t\t\tqh = qh->qh_next.qh;\n\t\t} while (qh);\n\t}\n\tif (action == TIMER_ASYNC_SHRINK)\n\t\ttimer_action(oxu, TIMER_ASYNC_SHRINK);\n}\n\n \nstatic union ehci_shadow *periodic_next_shadow(union ehci_shadow *periodic,\n\t\t\t\t\t\t__le32 tag)\n{\n\tswitch (tag) {\n\tdefault:\n\tcase Q_TYPE_QH:\n\t\treturn &periodic->qh->qh_next;\n\t}\n}\n\n \nstatic void periodic_unlink(struct oxu_hcd *oxu, unsigned frame, void *ptr)\n{\n\tunion ehci_shadow *prev_p = &oxu->pshadow[frame];\n\t__le32 *hw_p = &oxu->periodic[frame];\n\tunion ehci_shadow here = *prev_p;\n\n\t \n\twhile (here.ptr && here.ptr != ptr) {\n\t\tprev_p = periodic_next_shadow(prev_p, Q_NEXT_TYPE(*hw_p));\n\t\thw_p = here.hw_next;\n\t\there = *prev_p;\n\t}\n\t \n\tif (!here.ptr)\n\t\treturn;\n\n\t \n\t*prev_p = *periodic_next_shadow(&here, Q_NEXT_TYPE(*hw_p));\n\t*hw_p = *here.hw_next;\n}\n\n \nstatic unsigned short periodic_usecs(struct oxu_hcd *oxu,\n\t\t\t\t\tunsigned frame, unsigned uframe)\n{\n\t__le32 *hw_p = &oxu->periodic[frame];\n\tunion ehci_shadow *q = &oxu->pshadow[frame];\n\tunsigned usecs = 0;\n\n\twhile (q->ptr) {\n\t\tswitch (Q_NEXT_TYPE(*hw_p)) {\n\t\tcase Q_TYPE_QH:\n\t\tdefault:\n\t\t\t \n\t\t\tif (q->qh->hw_info2 & cpu_to_le32(1 << uframe))\n\t\t\t\tusecs += q->qh->usecs;\n\t\t\t \n\t\t\tif (q->qh->hw_info2 & cpu_to_le32(1 << (8 + uframe)))\n\t\t\t\tusecs += q->qh->c_usecs;\n\t\t\thw_p = &q->qh->hw_next;\n\t\t\tq = &q->qh->qh_next;\n\t\t\tbreak;\n\t\t}\n\t}\n#ifdef DEBUG\n\tif (usecs > 100)\n\t\toxu_err(oxu, \"uframe %d sched overrun: %d usecs\\n\",\n\t\t\t\t\t\tframe * 8 + uframe, usecs);\n#endif\n\treturn usecs;\n}\n\nstatic int enable_periodic(struct oxu_hcd *oxu)\n{\n\tu32 cmd;\n\tint status;\n\n\t \n\tstatus = handshake(oxu, &oxu->regs->status, STS_PSS, 0, 9 * 125);\n\tif (status != 0) {\n\t\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\t\tusb_hc_died(oxu_to_hcd(oxu));\n\t\treturn status;\n\t}\n\n\tcmd = readl(&oxu->regs->command) | CMD_PSE;\n\twritel(cmd, &oxu->regs->command);\n\t \n\toxu_to_hcd(oxu)->state = HC_STATE_RUNNING;\n\n\t \n\toxu->next_uframe = readl(&oxu->regs->frame_index)\n\t\t% (oxu->periodic_size << 3);\n\treturn 0;\n}\n\nstatic int disable_periodic(struct oxu_hcd *oxu)\n{\n\tu32 cmd;\n\tint status;\n\n\t \n\tstatus = handshake(oxu, &oxu->regs->status, STS_PSS, STS_PSS, 9 * 125);\n\tif (status != 0) {\n\t\toxu_to_hcd(oxu)->state = HC_STATE_HALT;\n\t\tusb_hc_died(oxu_to_hcd(oxu));\n\t\treturn status;\n\t}\n\n\tcmd = readl(&oxu->regs->command) & ~CMD_PSE;\n\twritel(cmd, &oxu->regs->command);\n\t \n\n\toxu->next_uframe = -1;\n\treturn 0;\n}\n\n \nstatic int qh_link_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tunsigned i;\n\tunsigned period = qh->period;\n\n\tdev_dbg(&qh->dev->dev,\n\t\t\"link qh%d-%04x/%p start %d [%d/%d us]\\n\",\n\t\tperiod, le32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),\n\t\tqh, qh->start, qh->usecs, qh->c_usecs);\n\n\t \n\tif (period == 0)\n\t\tperiod = 1;\n\n\tfor (i = qh->start; i < oxu->periodic_size; i += period) {\n\t\tunion ehci_shadow\t*prev = &oxu->pshadow[i];\n\t\t__le32\t\t\t*hw_p = &oxu->periodic[i];\n\t\tunion ehci_shadow\there = *prev;\n\t\t__le32\t\t\ttype = 0;\n\n\t\t \n\t\twhile (here.ptr) {\n\t\t\ttype = Q_NEXT_TYPE(*hw_p);\n\t\t\tif (type == Q_TYPE_QH)\n\t\t\t\tbreak;\n\t\t\tprev = periodic_next_shadow(prev, type);\n\t\t\thw_p = &here.qh->hw_next;\n\t\t\there = *prev;\n\t\t}\n\n\t\t \n\t\twhile (here.ptr && qh != here.qh) {\n\t\t\tif (qh->period > here.qh->period)\n\t\t\t\tbreak;\n\t\t\tprev = &here.qh->qh_next;\n\t\t\thw_p = &here.qh->hw_next;\n\t\t\there = *prev;\n\t\t}\n\t\t \n\t\tif (qh != here.qh) {\n\t\t\tqh->qh_next = here;\n\t\t\tif (here.qh)\n\t\t\t\tqh->hw_next = *hw_p;\n\t\t\twmb();\n\t\t\tprev->qh = qh;\n\t\t\t*hw_p = QH_NEXT(qh->qh_dma);\n\t\t}\n\t}\n\tqh->qh_state = QH_STATE_LINKED;\n\tqh_get(qh);\n\n\t \n\toxu_to_hcd(oxu)->self.bandwidth_allocated += qh->period\n\t\t? ((qh->usecs + qh->c_usecs) / qh->period)\n\t\t: (qh->usecs * 8);\n\n\t \n\tif (!oxu->periodic_sched++)\n\t\treturn enable_periodic(oxu);\n\n\treturn 0;\n}\n\nstatic void qh_unlink_periodic(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tunsigned i;\n\tunsigned period;\n\n\t \n\n\t \n\tperiod = qh->period;\n\tif (period == 0)\n\t\tperiod = 1;\n\n\tfor (i = qh->start; i < oxu->periodic_size; i += period)\n\t\tperiodic_unlink(oxu, i, qh);\n\n\t \n\toxu_to_hcd(oxu)->self.bandwidth_allocated -= qh->period\n\t\t? ((qh->usecs + qh->c_usecs) / qh->period)\n\t\t: (qh->usecs * 8);\n\n\tdev_dbg(&qh->dev->dev,\n\t\t\"unlink qh%d-%04x/%p start %d [%d/%d us]\\n\",\n\t\tqh->period,\n\t\tle32_to_cpup(&qh->hw_info2) & (QH_CMASK | QH_SMASK),\n\t\tqh, qh->start, qh->usecs, qh->c_usecs);\n\n\t \n\tqh->qh_state = QH_STATE_UNLINK;\n\tqh->qh_next.ptr = NULL;\n\tqh_put(qh);\n\n\t \n\toxu->periodic_sched--;\n\tif (!oxu->periodic_sched)\n\t\t(void) disable_periodic(oxu);\n}\n\nstatic void intr_deschedule(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tunsigned wait;\n\n\tqh_unlink_periodic(oxu, qh);\n\n\t \n\tif (list_empty(&qh->qtd_list)\n\t\t|| (cpu_to_le32(QH_CMASK) & qh->hw_info2) != 0)\n\t\twait = 2;\n\telse\n\t\twait = 55;\t \n\n\tudelay(wait);\n\tqh->qh_state = QH_STATE_IDLE;\n\tqh->hw_next = EHCI_LIST_END;\n\twmb();\n}\n\nstatic int check_period(struct oxu_hcd *oxu,\n\t\t\tunsigned frame, unsigned uframe,\n\t\t\tunsigned period, unsigned usecs)\n{\n\tint claimed;\n\n\t \n\tif (uframe >= 8)\n\t\treturn 0;\n\n\t \n\tusecs = 100 - usecs;\n\n\t \n\tif (unlikely(period == 0)) {\n\t\tdo {\n\t\t\tfor (uframe = 0; uframe < 7; uframe++) {\n\t\t\t\tclaimed = periodic_usecs(oxu, frame, uframe);\n\t\t\t\tif (claimed > usecs)\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t} while ((frame += 1) < oxu->periodic_size);\n\n\t \n\t} else {\n\t\tdo {\n\t\t\tclaimed = periodic_usecs(oxu, frame, uframe);\n\t\t\tif (claimed > usecs)\n\t\t\t\treturn 0;\n\t\t} while ((frame += period) < oxu->periodic_size);\n\t}\n\n\treturn 1;\n}\n\nstatic int check_intr_schedule(struct oxu_hcd\t*oxu,\n\t\t\t\tunsigned frame, unsigned uframe,\n\t\t\t\tconst struct ehci_qh *qh, __le32 *c_maskp)\n{\n\tint retval = -ENOSPC;\n\n\tif (qh->c_usecs && uframe >= 6)\t\t \n\t\tgoto done;\n\n\tif (!check_period(oxu, frame, uframe, qh->period, qh->usecs))\n\t\tgoto done;\n\tif (!qh->c_usecs) {\n\t\tretval = 0;\n\t\t*c_maskp = 0;\n\t\tgoto done;\n\t}\n\ndone:\n\treturn retval;\n}\n\n \nstatic int qh_schedule(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\tint\t\tstatus;\n\tunsigned\tuframe;\n\t__le32\t\tc_mask;\n\tunsigned\tframe;\t\t \n\n\tqh_refresh(oxu, qh);\n\tqh->hw_next = EHCI_LIST_END;\n\tframe = qh->start;\n\n\t \n\tif (frame < qh->period) {\n\t\tuframe = ffs(le32_to_cpup(&qh->hw_info2) & QH_SMASK);\n\t\tstatus = check_intr_schedule(oxu, frame, --uframe,\n\t\t\t\tqh, &c_mask);\n\t} else {\n\t\tuframe = 0;\n\t\tc_mask = 0;\n\t\tstatus = -ENOSPC;\n\t}\n\n\t \n\tif (status) {\n\t\t \n\t\tif (qh->period) {\n\t\t\tframe = qh->period - 1;\n\t\t\tdo {\n\t\t\t\tfor (uframe = 0; uframe < 8; uframe++) {\n\t\t\t\t\tstatus = check_intr_schedule(oxu,\n\t\t\t\t\t\t\tframe, uframe, qh,\n\t\t\t\t\t\t\t&c_mask);\n\t\t\t\t\tif (status == 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (status && frame--);\n\n\t\t \n\t\t} else {\n\t\t\tframe = 0;\n\t\t\tstatus = check_intr_schedule(oxu, 0, 0, qh, &c_mask);\n\t\t}\n\t\tif (status)\n\t\t\tgoto done;\n\t\tqh->start = frame;\n\n\t\t \n\t\tqh->hw_info2 &= cpu_to_le32(~(QH_CMASK | QH_SMASK));\n\t\tqh->hw_info2 |= qh->period\n\t\t\t? cpu_to_le32(1 << uframe)\n\t\t\t: cpu_to_le32(QH_SMASK);\n\t\tqh->hw_info2 |= c_mask;\n\t} else\n\t\toxu_dbg(oxu, \"reused qh %p schedule\\n\", qh);\n\n\t \n\tstatus = qh_link_periodic(oxu, qh);\ndone:\n\treturn status;\n}\n\nstatic int intr_submit(struct oxu_hcd *oxu, struct urb *urb,\n\t\t\tstruct list_head *qtd_list, gfp_t mem_flags)\n{\n\tunsigned epnum;\n\tunsigned long flags;\n\tstruct ehci_qh *qh;\n\tint status = 0;\n\tstruct list_head\tempty;\n\n\t \n\tepnum = urb->ep->desc.bEndpointAddress;\n\n\tspin_lock_irqsave(&oxu->lock, flags);\n\n\tif (unlikely(!HCD_HW_ACCESSIBLE(oxu_to_hcd(oxu)))) {\n\t\tstatus = -ESHUTDOWN;\n\t\tgoto done;\n\t}\n\n\t \n\tINIT_LIST_HEAD(&empty);\n\tqh = qh_append_tds(oxu, urb, &empty, epnum, &urb->ep->hcpriv);\n\tif (qh == NULL) {\n\t\tstatus = -ENOMEM;\n\t\tgoto done;\n\t}\n\tif (qh->qh_state == QH_STATE_IDLE) {\n\t\tstatus = qh_schedule(oxu, qh);\n\t\tif (status != 0)\n\t\t\tgoto done;\n\t}\n\n\t \n\tqh = qh_append_tds(oxu, urb, qtd_list, epnum, &urb->ep->hcpriv);\n\tBUG_ON(qh == NULL);\n\n\t \n\toxu_to_hcd(oxu)->self.bandwidth_int_reqs++;\n\ndone:\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\tif (status)\n\t\tqtd_list_free(oxu, urb, qtd_list);\n\n\treturn status;\n}\n\nstatic inline int itd_submit(struct oxu_hcd *oxu, struct urb *urb,\n\t\t\t\t\t\tgfp_t mem_flags)\n{\n\toxu_dbg(oxu, \"iso support is missing!\\n\");\n\treturn -ENOSYS;\n}\n\nstatic inline int sitd_submit(struct oxu_hcd *oxu, struct urb *urb,\n\t\t\t\t\t\tgfp_t mem_flags)\n{\n\toxu_dbg(oxu, \"split iso support is missing!\\n\");\n\treturn -ENOSYS;\n}\n\nstatic void scan_periodic(struct oxu_hcd *oxu)\n{\n\tunsigned frame, clock, now_uframe, mod;\n\tunsigned modified;\n\n\tmod = oxu->periodic_size << 3;\n\n\t \n\tnow_uframe = oxu->next_uframe;\n\tif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\n\t\tclock = readl(&oxu->regs->frame_index);\n\telse\n\t\tclock = now_uframe + mod - 1;\n\tclock %= mod;\n\n\tfor (;;) {\n\t\tunion ehci_shadow\tq, *q_p;\n\t\t__le32\t\t\ttype, *hw_p;\n\n\t\t \n\t\tframe = now_uframe >> 3;\n\t\tif (frame != (clock >> 3)) {\n\t\t\t \n\t\t\tnow_uframe |= 0x07;\n\t\t}\n\nrestart:\n\t\t \n\t\tq_p = &oxu->pshadow[frame];\n\t\thw_p = &oxu->periodic[frame];\n\t\tq.ptr = q_p->ptr;\n\t\ttype = Q_NEXT_TYPE(*hw_p);\n\t\tmodified = 0;\n\n\t\twhile (q.ptr != NULL) {\n\t\t\tunion ehci_shadow temp;\n\n\t\t\tswitch (type) {\n\t\t\tcase Q_TYPE_QH:\n\t\t\t\t \n\t\t\t\ttemp.qh = qh_get(q.qh);\n\t\t\t\ttype = Q_NEXT_TYPE(q.qh->hw_next);\n\t\t\t\tq = q.qh->qh_next;\n\t\t\t\tmodified = qh_completions(oxu, temp.qh);\n\t\t\t\tif (unlikely(list_empty(&temp.qh->qtd_list)))\n\t\t\t\t\tintr_deschedule(oxu, temp.qh);\n\t\t\t\tqh_put(temp.qh);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\toxu_dbg(oxu, \"corrupt type %d frame %d shadow %p\\n\",\n\t\t\t\t\ttype, frame, q.ptr);\n\t\t\t\tq.ptr = NULL;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (unlikely(modified))\n\t\t\t\tgoto restart;\n\t\t}\n\n\t\t \n\n\t\t \n\n\t\t \n\n\t\tif (now_uframe == clock) {\n\t\t\tunsigned\tnow;\n\n\t\t\tif (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state))\n\t\t\t\tbreak;\n\t\t\toxu->next_uframe = now_uframe;\n\t\t\tnow = readl(&oxu->regs->frame_index) % mod;\n\t\t\tif (now_uframe == now)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tclock = now;\n\t\t} else {\n\t\t\tnow_uframe++;\n\t\t\tnow_uframe %= mod;\n\t\t}\n\t}\n}\n\n \nstatic void ehci_turn_off_all_ports(struct oxu_hcd *oxu)\n{\n\tint port = HCS_N_PORTS(oxu->hcs_params);\n\n\twhile (port--)\n\t\twritel(PORT_RWC_BITS, &oxu->regs->port_status[port]);\n}\n\nstatic void ehci_port_power(struct oxu_hcd *oxu, int is_on)\n{\n\tunsigned port;\n\n\tif (!HCS_PPC(oxu->hcs_params))\n\t\treturn;\n\n\toxu_dbg(oxu, \"...power%s ports...\\n\", is_on ? \"up\" : \"down\");\n\tfor (port = HCS_N_PORTS(oxu->hcs_params); port > 0; ) {\n\t\tif (is_on)\n\t\t\toxu_hub_control(oxu_to_hcd(oxu), SetPortFeature,\n\t\t\t\tUSB_PORT_FEAT_POWER, port--, NULL, 0);\n\t\telse\n\t\t\toxu_hub_control(oxu_to_hcd(oxu), ClearPortFeature,\n\t\t\t\tUSB_PORT_FEAT_POWER, port--, NULL, 0);\n\t}\n\n\tmsleep(20);\n}\n\n \nstatic void ehci_work(struct oxu_hcd *oxu)\n{\n\ttimer_action_done(oxu, TIMER_IO_WATCHDOG);\n\tif (oxu->reclaim_ready)\n\t\tend_unlink_async(oxu);\n\n\t \n\tif (oxu->scanning)\n\t\treturn;\n\toxu->scanning = 1;\n\tscan_async(oxu);\n\tif (oxu->next_uframe != -1)\n\t\tscan_periodic(oxu);\n\toxu->scanning = 0;\n\n\t \n\tif (HC_IS_RUNNING(oxu_to_hcd(oxu)->state) &&\n\t\t\t(oxu->async->qh_next.ptr != NULL ||\n\t\t\t oxu->periodic_sched != 0))\n\t\ttimer_action(oxu, TIMER_IO_WATCHDOG);\n}\n\nstatic void unlink_async(struct oxu_hcd *oxu, struct ehci_qh *qh)\n{\n\t \n\tif (qh->qh_state == QH_STATE_LINKED\n\t\t\t&& oxu->reclaim\n\t\t\t&& HC_IS_RUNNING(oxu_to_hcd(oxu)->state)) {\n\t\tstruct ehci_qh\t\t*last;\n\n\t\tfor (last = oxu->reclaim;\n\t\t\t\tlast->reclaim;\n\t\t\t\tlast = last->reclaim)\n\t\t\tcontinue;\n\t\tqh->qh_state = QH_STATE_UNLINK_WAIT;\n\t\tlast->reclaim = qh;\n\n\t \n\t} else if (!HC_IS_RUNNING(oxu_to_hcd(oxu)->state) && oxu->reclaim)\n\t\tend_unlink_async(oxu);\n\n\t \n\tif (qh->qh_state == QH_STATE_LINKED)\n\t\tstart_unlink_async(oxu, qh);\n}\n\n \n\nstatic irqreturn_t oxu210_hcd_irq(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tu32 status, pcd_status = 0;\n\tint bh;\n\n\tspin_lock(&oxu->lock);\n\n\tstatus = readl(&oxu->regs->status);\n\n\t \n\tif (status == ~(u32) 0) {\n\t\toxu_dbg(oxu, \"device removed\\n\");\n\t\tgoto dead;\n\t}\n\n\t \n\tstatus &= INTR_MASK;\n\tif (!status || unlikely(hcd->state == HC_STATE_HALT)) {\n\t\tspin_unlock(&oxu->lock);\n\t\treturn IRQ_NONE;\n\t}\n\n\t \n\twritel(status, &oxu->regs->status);\n\treadl(&oxu->regs->command);\t \n\tbh = 0;\n\n#ifdef OXU_VERBOSE_DEBUG\n\t \n\tdbg_status(oxu, \"irq\", status);\n#endif\n\n\t \n\n\t \n\tif (likely((status & (STS_INT|STS_ERR)) != 0))\n\t\tbh = 1;\n\n\t \n\tif (status & STS_IAA) {\n\t\toxu->reclaim_ready = 1;\n\t\tbh = 1;\n\t}\n\n\t \n\tif (status & STS_PCD) {\n\t\tunsigned i = HCS_N_PORTS(oxu->hcs_params);\n\t\tpcd_status = status;\n\n\t\t \n\t\tif (!(readl(&oxu->regs->command) & CMD_RUN))\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\n\t\twhile (i--) {\n\t\t\tint pstatus = readl(&oxu->regs->port_status[i]);\n\n\t\t\tif (pstatus & PORT_OWNER)\n\t\t\t\tcontinue;\n\t\t\tif (!(pstatus & PORT_RESUME)\n\t\t\t\t\t|| oxu->reset_done[i] != 0)\n\t\t\t\tcontinue;\n\n\t\t\t \n\t\t\toxu->reset_done[i] = jiffies +\n\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\toxu_dbg(oxu, \"port %d remote wakeup\\n\", i + 1);\n\t\t\tmod_timer(&hcd->rh_timer, oxu->reset_done[i]);\n\t\t}\n\t}\n\n\t \n\tif (unlikely((status & STS_FATAL) != 0)) {\n\t\t \n\t\tstatus = readl(&oxu->regs->status);\n\t\tdbg_cmd(oxu, \"fatal\", readl(&oxu->regs->command));\n\t\tdbg_status(oxu, \"fatal\", status);\n\t\tif (status & STS_HALT) {\n\t\t\toxu_err(oxu, \"fatal error\\n\");\ndead:\n\t\t\tehci_reset(oxu);\n\t\t\twritel(0, &oxu->regs->configured_flag);\n\t\t\tusb_hc_died(hcd);\n\t\t\t \n\t\t\tbh = 1;\n\t\t}\n\t}\n\n\tif (bh)\n\t\tehci_work(oxu);\n\tspin_unlock(&oxu->lock);\n\tif (pcd_status & STS_PCD)\n\t\tusb_hcd_poll_rh_status(hcd);\n\treturn IRQ_HANDLED;\n}\n\nstatic irqreturn_t oxu_irq(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint ret = IRQ_HANDLED;\n\n\tu32 status = oxu_readl(hcd->regs, OXU_CHIPIRQSTATUS);\n\tu32 enable = oxu_readl(hcd->regs, OXU_CHIPIRQEN_SET);\n\n\t \n\toxu_writel(hcd->regs, OXU_CHIPIRQEN_CLR, enable);\n\n\tif ((oxu->is_otg && (status & OXU_USBOTGI)) ||\n\t\t(!oxu->is_otg && (status & OXU_USBSPHI)))\n\t\toxu210_hcd_irq(hcd);\n\telse\n\t\tret = IRQ_NONE;\n\n\t \n\toxu_writel(hcd->regs, OXU_CHIPIRQEN_SET, enable);\n\n\treturn ret;\n}\n\nstatic void oxu_watchdog(struct timer_list *t)\n{\n\tstruct oxu_hcd\t*oxu = from_timer(oxu, t, watchdog);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&oxu->lock, flags);\n\n\t \n\tif (oxu->reclaim) {\n\t\tu32 status = readl(&oxu->regs->status);\n\t\tif (status & STS_IAA) {\n\t\t\toxu_vdbg(oxu, \"lost IAA\\n\");\n\t\t\twritel(STS_IAA, &oxu->regs->status);\n\t\t\toxu->reclaim_ready = 1;\n\t\t}\n\t}\n\n\t \n\tif (test_bit(TIMER_ASYNC_OFF, &oxu->actions))\n\t\tstart_unlink_async(oxu, oxu->async);\n\n\t \n\tehci_work(oxu);\n\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n}\n\n \nstatic int oxu_hcd_init(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tu32 temp;\n\tint retval;\n\tu32 hcc_params;\n\n\tspin_lock_init(&oxu->lock);\n\n\ttimer_setup(&oxu->watchdog, oxu_watchdog, 0);\n\n\t \n\toxu->periodic_size = DEFAULT_I_TDPS;\n\tretval = ehci_mem_init(oxu, GFP_KERNEL);\n\tif (retval < 0)\n\t\treturn retval;\n\n\t \n\thcc_params = readl(&oxu->caps->hcc_params);\n\tif (HCC_ISOC_CACHE(hcc_params))\t\t \n\t\toxu->i_thresh = 8;\n\telse\t\t\t\t\t \n\t\toxu->i_thresh = 2 + HCC_ISOC_THRES(hcc_params);\n\n\toxu->reclaim = NULL;\n\toxu->reclaim_ready = 0;\n\toxu->next_uframe = -1;\n\n\t \n\toxu->async->qh_next.qh = NULL;\n\toxu->async->hw_next = QH_NEXT(oxu->async->qh_dma);\n\toxu->async->hw_info1 = cpu_to_le32(QH_HEAD);\n\toxu->async->hw_token = cpu_to_le32(QTD_STS_HALT);\n\toxu->async->hw_qtd_next = EHCI_LIST_END;\n\toxu->async->qh_state = QH_STATE_LINKED;\n\toxu->async->hw_alt_next = QTD_NEXT(oxu->async->dummy->qtd_dma);\n\n\t \n\tif (log2_irq_thresh < 0 || log2_irq_thresh > 6)\n\t\tlog2_irq_thresh = 0;\n\ttemp = 1 << (16 + log2_irq_thresh);\n\tif (HCC_CANPARK(hcc_params)) {\n\t\t \n\t\tif (park) {\n\t\t\tpark = min(park, (unsigned) 3);\n\t\t\ttemp |= CMD_PARK;\n\t\t\ttemp |= park << 8;\n\t\t}\n\t\toxu_dbg(oxu, \"park %d\\n\", park);\n\t}\n\tif (HCC_PGM_FRAMELISTLEN(hcc_params)) {\n\t\t \n\t\ttemp &= ~(3 << 2);\n\t\ttemp |= (EHCI_TUNE_FLS << 2);\n\t}\n\toxu->command = temp;\n\n\treturn 0;\n}\n\n \nstatic int oxu_reset(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\n\tspin_lock_init(&oxu->mem_lock);\n\tINIT_LIST_HEAD(&oxu->urb_list);\n\toxu->urb_len = 0;\n\n\tif (oxu->is_otg) {\n\t\toxu->caps = hcd->regs + OXU_OTG_CAP_OFFSET;\n\t\toxu->regs = hcd->regs + OXU_OTG_CAP_OFFSET + \\\n\t\t\tHC_LENGTH(readl(&oxu->caps->hc_capbase));\n\n\t\toxu->mem = hcd->regs + OXU_SPH_MEM;\n\t} else {\n\t\toxu->caps = hcd->regs + OXU_SPH_CAP_OFFSET;\n\t\toxu->regs = hcd->regs + OXU_SPH_CAP_OFFSET + \\\n\t\t\tHC_LENGTH(readl(&oxu->caps->hc_capbase));\n\n\t\toxu->mem = hcd->regs + OXU_OTG_MEM;\n\t}\n\n\toxu->hcs_params = readl(&oxu->caps->hcs_params);\n\toxu->sbrn = 0x20;\n\n\treturn oxu_hcd_init(hcd);\n}\n\nstatic int oxu_run(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint retval;\n\tu32 temp, hcc_params;\n\n\thcd->uses_new_polling = 1;\n\n\t \n\tretval = ehci_reset(oxu);\n\tif (retval != 0) {\n\t\tehci_mem_cleanup(oxu);\n\t\treturn retval;\n\t}\n\twritel(oxu->periodic_dma, &oxu->regs->frame_list);\n\twritel((u32) oxu->async->qh_dma, &oxu->regs->async_next);\n\n\t \n\thcc_params = readl(&oxu->caps->hcc_params);\n\tif (HCC_64BIT_ADDR(hcc_params))\n\t\twritel(0, &oxu->regs->segment);\n\n\toxu->command &= ~(CMD_LRESET | CMD_IAAD | CMD_PSE |\n\t\t\t\tCMD_ASE | CMD_RESET);\n\toxu->command |= CMD_RUN;\n\twritel(oxu->command, &oxu->regs->command);\n\tdbg_cmd(oxu, \"init\", oxu->command);\n\n\t \n\thcd->state = HC_STATE_RUNNING;\n\twritel(FLAG_CF, &oxu->regs->configured_flag);\n\treadl(&oxu->regs->command);\t \n\n\ttemp = HC_VERSION(readl(&oxu->caps->hc_capbase));\n\toxu_info(oxu, \"USB %x.%x started, quasi-EHCI %x.%02x, driver %s%s\\n\",\n\t\t((oxu->sbrn & 0xf0)>>4), (oxu->sbrn & 0x0f),\n\t\ttemp >> 8, temp & 0xff, DRIVER_VERSION,\n\t\tignore_oc ? \", overcurrent ignored\" : \"\");\n\n\twritel(INTR_MASK, &oxu->regs->intr_enable);  \n\n\treturn 0;\n}\n\nstatic void oxu_stop(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\n\t \n\tehci_port_power(oxu, 0);\n\n\t \n\tdel_timer_sync(&oxu->watchdog);\n\n\tspin_lock_irq(&oxu->lock);\n\tif (HC_IS_RUNNING(hcd->state))\n\t\tehci_quiesce(oxu);\n\n\tehci_reset(oxu);\n\twritel(0, &oxu->regs->intr_enable);\n\tspin_unlock_irq(&oxu->lock);\n\n\t \n\twritel(0, &oxu->regs->configured_flag);\n\n\t \n\tspin_lock_irq(&oxu->lock);\n\tif (oxu->async)\n\t\tehci_work(oxu);\n\tspin_unlock_irq(&oxu->lock);\n\tehci_mem_cleanup(oxu);\n\n\tdbg_status(oxu, \"oxu_stop completed\", readl(&oxu->regs->status));\n}\n\n \nstatic void oxu_shutdown(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\n\t(void) ehci_halt(oxu);\n\tehci_turn_off_all_ports(oxu);\n\n\t \n\twritel(0, &oxu->regs->configured_flag);\n\n\t \n\treadl(&oxu->regs->configured_flag);\n}\n\n \nstatic int __oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\tgfp_t mem_flags)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tstruct list_head qtd_list;\n\n\tINIT_LIST_HEAD(&qtd_list);\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\tdefault:\n\t\tif (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn submit_async(oxu, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_INTERRUPT:\n\t\tif (!qh_urb_transaction(oxu, urb, &qtd_list, mem_flags))\n\t\t\treturn -ENOMEM;\n\t\treturn intr_submit(oxu, urb, &qtd_list, mem_flags);\n\n\tcase PIPE_ISOCHRONOUS:\n\t\tif (urb->dev->speed == USB_SPEED_HIGH)\n\t\t\treturn itd_submit(oxu, urb, mem_flags);\n\t\telse\n\t\t\treturn sitd_submit(oxu, urb, mem_flags);\n\t}\n}\n\n \nstatic int oxu_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\tgfp_t mem_flags)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint num, rem;\n\tvoid *transfer_buffer;\n\tstruct urb *murb;\n\tint i, ret;\n\n\t \n\tif (!usb_pipebulk(urb->pipe))\n\t\treturn __oxu_urb_enqueue(hcd, urb, mem_flags);\n\n\t \n\ttransfer_buffer = urb->transfer_buffer;\n\n\tnum = urb->transfer_buffer_length / 4096;\n\trem = urb->transfer_buffer_length % 4096;\n\tif (rem != 0)\n\t\tnum++;\n\n\t \n\tif (num == 1)\n\t\treturn __oxu_urb_enqueue(hcd, urb, mem_flags);\n\n\t \n\n\tfor (i = 0; i < num - 1; i++) {\n\t\t \n\n\t\tdo {\n\t\t\tmurb = (struct urb *) oxu_murb_alloc(oxu);\n\t\t\tif (!murb)\n\t\t\t\tschedule();\n\t\t} while (!murb);\n\n\t\t \n\t\tmemcpy(murb, urb, sizeof(struct urb));\n\n\t\tmurb->transfer_buffer_length = 4096;\n\t\tmurb->transfer_buffer = transfer_buffer + i * 4096;\n\n\t\t \n\t\tmurb->complete = NULL;\n\n\t\t((struct oxu_murb *) murb)->main = urb;\n\t\t((struct oxu_murb *) murb)->last = 0;\n\n\t\t \n\t\tdo {\n\t\t\tret  = __oxu_urb_enqueue(hcd, murb, mem_flags);\n\t\t\tif (ret)\n\t\t\t\tschedule();\n\t\t} while (ret);\n\t}\n\n\t \n\n\t \n\tdo {\n\t\tmurb = (struct urb *) oxu_murb_alloc(oxu);\n\t\tif (!murb)\n\t\t\tschedule();\n\t} while (!murb);\n\n\t \n\tmemcpy(murb, urb, sizeof(struct urb));\n\n\tmurb->transfer_buffer_length = rem > 0 ? rem : 4096;\n\tmurb->transfer_buffer = transfer_buffer + (num - 1) * 4096;\n\n\t \n\tmurb->complete = NULL;\n\n\t((struct oxu_murb *) murb)->main = urb;\n\t((struct oxu_murb *) murb)->last = 1;\n\n\tdo {\n\t\tret = __oxu_urb_enqueue(hcd, murb, mem_flags);\n\t\tif (ret)\n\t\t\tschedule();\n\t} while (ret);\n\n\treturn ret;\n}\n\n \nstatic int oxu_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tstruct ehci_qh *qh;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&oxu->lock, flags);\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\tdefault:\n\t\tqh = (struct ehci_qh *) urb->hcpriv;\n\t\tif (!qh)\n\t\t\tbreak;\n\t\tunlink_async(oxu, qh);\n\t\tbreak;\n\n\tcase PIPE_INTERRUPT:\n\t\tqh = (struct ehci_qh *) urb->hcpriv;\n\t\tif (!qh)\n\t\t\tbreak;\n\t\tswitch (qh->qh_state) {\n\t\tcase QH_STATE_LINKED:\n\t\t\tintr_deschedule(oxu, qh);\n\t\t\tfallthrough;\n\t\tcase QH_STATE_IDLE:\n\t\t\tqh_completions(oxu, qh);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\toxu_dbg(oxu, \"bogus qh %p state %d\\n\",\n\t\t\t\t\tqh, qh->qh_state);\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (!list_empty(&qh->qtd_list)\n\t\t\t\t&& HC_IS_RUNNING(hcd->state)) {\n\t\t\tint status;\n\n\t\t\tstatus = qh_schedule(oxu, qh);\n\t\t\tspin_unlock_irqrestore(&oxu->lock, flags);\n\n\t\t\tif (status != 0) {\n\t\t\t\t \n\t\t\t\tdev_err(hcd->self.controller,\n\t\t\t\t\t\"can't reschedule qh %p, err %d\\n\", qh,\n\t\t\t\t\tstatus);\n\t\t\t}\n\t\t\treturn status;\n\t\t}\n\t\tbreak;\n\t}\ndone:\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\treturn 0;\n}\n\n \nstatic void oxu_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tunsigned long\t\tflags;\n\tstruct ehci_qh\t\t*qh, *tmp;\n\n\t \n\t \n\nrescan:\n\tspin_lock_irqsave(&oxu->lock, flags);\n\tqh = ep->hcpriv;\n\tif (!qh)\n\t\tgoto done;\n\n\t \n\tif (qh->hw_info1 == 0) {\n\t\toxu_vdbg(oxu, \"iso delay\\n\");\n\t\tgoto idle_timeout;\n\t}\n\n\tif (!HC_IS_RUNNING(hcd->state))\n\t\tqh->qh_state = QH_STATE_IDLE;\n\tswitch (qh->qh_state) {\n\tcase QH_STATE_LINKED:\n\t\tfor (tmp = oxu->async->qh_next.qh;\n\t\t\t\ttmp && tmp != qh;\n\t\t\t\ttmp = tmp->qh_next.qh)\n\t\t\tcontinue;\n\t\t \n\t\tif (!tmp)\n\t\t\tgoto nogood;\n\t\tunlink_async(oxu, qh);\n\t\tfallthrough;\n\tcase QH_STATE_UNLINK:\t\t \nidle_timeout:\n\t\tspin_unlock_irqrestore(&oxu->lock, flags);\n\t\tschedule_timeout_uninterruptible(1);\n\t\tgoto rescan;\n\tcase QH_STATE_IDLE:\t\t \n\t\tif (list_empty(&qh->qtd_list)) {\n\t\t\tqh_put(qh);\n\t\t\tbreak;\n\t\t}\n\t\tfallthrough;\n\tdefault:\nnogood:\n\t\t \n\t\toxu_err(oxu, \"qh %p (#%02x) state %d%s\\n\",\n\t\t\tqh, ep->desc.bEndpointAddress, qh->qh_state,\n\t\t\tlist_empty(&qh->qtd_list) ? \"\" : \"(has tds)\");\n\t\tbreak;\n\t}\n\tep->hcpriv = NULL;\ndone:\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n}\n\nstatic int oxu_get_frame(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\n\treturn (readl(&oxu->regs->frame_index) >> 3) %\n\t\toxu->periodic_size;\n}\n\n \nstatic int oxu_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tu32 temp, mask, status = 0;\n\tint ports, i, retval = 1;\n\tunsigned long flags;\n\n\t \n\tif (!HC_IS_RUNNING(hcd->state))\n\t\treturn 0;\n\n\t \n\tbuf[0] = 0;\n\tports = HCS_N_PORTS(oxu->hcs_params);\n\tif (ports > 7) {\n\t\tbuf[1] = 0;\n\t\tretval++;\n\t}\n\n\t \n\tif (!ignore_oc)\n\t\tmask = PORT_CSC | PORT_PEC | PORT_OCC;\n\telse\n\t\tmask = PORT_CSC | PORT_PEC;\n\n\t \n\n\t \n\tspin_lock_irqsave(&oxu->lock, flags);\n\tfor (i = 0; i < ports; i++) {\n\t\ttemp = readl(&oxu->regs->port_status[i]);\n\n\t\t \n\n\t\tif (!(temp & PORT_CONNECT))\n\t\t\toxu->reset_done[i] = 0;\n\t\tif ((temp & mask) != 0 || ((temp & PORT_RESUME) != 0 &&\n\t\t\t\ttime_after_eq(jiffies, oxu->reset_done[i]))) {\n\t\t\tif (i < 7)\n\t\t\t\tbuf[0] |= 1 << (i + 1);\n\t\t\telse\n\t\t\t\tbuf[1] |= 1 << (i - 7);\n\t\t\tstatus = STS_PCD;\n\t\t}\n\t}\n\t \n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\treturn status ? retval : 0;\n}\n\n \nstatic inline unsigned int oxu_port_speed(struct oxu_hcd *oxu,\n\t\t\t\t\t\tunsigned int portsc)\n{\n\tswitch ((portsc >> 26) & 3) {\n\tcase 0:\n\t\treturn 0;\n\tcase 1:\n\t\treturn USB_PORT_STAT_LOW_SPEED;\n\tcase 2:\n\tdefault:\n\t\treturn USB_PORT_STAT_HIGH_SPEED;\n\t}\n}\n\n#define\tPORT_WAKE_BITS\t(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)\nstatic int oxu_hub_control(struct usb_hcd *hcd, u16 typeReq,\n\t\t\t\tu16 wValue, u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint ports = HCS_N_PORTS(oxu->hcs_params);\n\tu32 __iomem *status_reg = &oxu->regs->port_status[wIndex - 1];\n\tu32 temp, status;\n\tunsigned long\tflags;\n\tint retval = 0;\n\tunsigned selector;\n\n\t \n\n\tspin_lock_irqsave(&oxu->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = readl(status_reg);\n\n\t\t \n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\twritel(temp & ~PORT_PE, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\twritel((temp & ~PORT_RWC_BITS) | PORT_PEC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (temp & PORT_RESET)\n\t\t\t\tgoto error;\n\t\t\tif (temp & PORT_SUSPEND) {\n\t\t\t\tif ((temp & PORT_PE) == 0)\n\t\t\t\t\tgoto error;\n\t\t\t\t \n\t\t\t\ttemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\n\t\t\t\twritel(temp | PORT_RESUME, status_reg);\n\t\t\t\toxu->reset_done[wIndex] = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies(20);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (HCS_PPC(oxu->hcs_params))\n\t\t\t\twritel(temp & ~(PORT_RWC_BITS | PORT_POWER),\n\t\t\t\t\t  status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\twritel((temp & ~PORT_RWC_BITS) | PORT_CSC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\twritel((temp & ~PORT_RWC_BITS) | PORT_OCC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\treadl(&oxu->regs->command);\t \n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tehci_hub_descriptor(oxu, (struct usb_hub_descriptor *)\n\t\t\tbuf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t \n\t\tmemset(buf, 0, 4);\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tstatus = 0;\n\t\ttemp = readl(status_reg);\n\n\t\t \n\t\tif (temp & PORT_CSC)\n\t\t\tstatus |= USB_PORT_STAT_C_CONNECTION << 16;\n\t\tif (temp & PORT_PEC)\n\t\t\tstatus |= USB_PORT_STAT_C_ENABLE << 16;\n\t\tif ((temp & PORT_OCC) && !ignore_oc)\n\t\t\tstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\n\n\t\t \n\t\tif (temp & PORT_RESUME) {\n\n\t\t\t \n\t\t\tif (!oxu->reset_done[wIndex]) {\n\t\t\t\t \n\t\t\t\toxu->reset_done[wIndex] = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies(20);\n\t\t\t\t \n\t\t\t\tmod_timer(&oxu_to_hcd(oxu)->rh_timer,\n\t\t\t\t\t\toxu->reset_done[wIndex]);\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (time_after_eq(jiffies,\n\t\t\t\t\toxu->reset_done[wIndex])) {\n\t\t\t\tstatus |= USB_PORT_STAT_C_SUSPEND << 16;\n\t\t\t\toxu->reset_done[wIndex] = 0;\n\n\t\t\t\t \n\t\t\t\ttemp = readl(status_reg);\n\t\t\t\twritel(temp & ~(PORT_RWC_BITS | PORT_RESUME),\n\t\t\t\t\tstatus_reg);\n\t\t\t\tretval = handshake(oxu, status_reg,\n\t\t\t\t\t   PORT_RESUME, 0, 2000  );\n\t\t\t\tif (retval != 0) {\n\t\t\t\t\toxu_err(oxu,\n\t\t\t\t\t\t\"port %d resume error %d\\n\",\n\t\t\t\t\t\twIndex + 1, retval);\n\t\t\t\t\tgoto error;\n\t\t\t\t}\n\t\t\t\ttemp &= ~(PORT_SUSPEND|PORT_RESUME|(3<<10));\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif ((temp & PORT_RESET)\n\t\t\t\t&& time_after_eq(jiffies,\n\t\t\t\t\toxu->reset_done[wIndex])) {\n\t\t\tstatus |= USB_PORT_STAT_C_RESET << 16;\n\t\t\toxu->reset_done[wIndex] = 0;\n\n\t\t\t \n\t\t\twritel(temp & ~(PORT_RWC_BITS | PORT_RESET),\n\t\t\t\t\tstatus_reg);\n\t\t\t \n\t\t\tretval = handshake(oxu, status_reg,\n\t\t\t\t\tPORT_RESET, 0, 750);\n\t\t\tif (retval != 0) {\n\t\t\t\toxu_err(oxu, \"port %d reset error %d\\n\",\n\t\t\t\t\twIndex + 1, retval);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = check_reset_complete(oxu, wIndex, status_reg,\n\t\t\t\t\treadl(status_reg));\n\t\t}\n\n\t\t \n\t\tif ((temp & PORT_CONNECT) &&\n\t\t\t\ttest_bit(wIndex, &oxu->companion_ports)) {\n\t\t\ttemp &= ~PORT_RWC_BITS;\n\t\t\ttemp |= PORT_OWNER;\n\t\t\twritel(temp, status_reg);\n\t\t\toxu_dbg(oxu, \"port %d --> companion\\n\", wIndex + 1);\n\t\t\ttemp = readl(status_reg);\n\t\t}\n\n\t\t \n\n\t\tif (temp & PORT_CONNECT) {\n\t\t\tstatus |= USB_PORT_STAT_CONNECTION;\n\t\t\t \n\t\t\tstatus |= oxu_port_speed(oxu, temp);\n\t\t}\n\t\tif (temp & PORT_PE)\n\t\t\tstatus |= USB_PORT_STAT_ENABLE;\n\t\tif (temp & (PORT_SUSPEND|PORT_RESUME))\n\t\t\tstatus |= USB_PORT_STAT_SUSPEND;\n\t\tif (temp & PORT_OC)\n\t\t\tstatus |= USB_PORT_STAT_OVERCURRENT;\n\t\tif (temp & PORT_RESET)\n\t\t\tstatus |= USB_PORT_STAT_RESET;\n\t\tif (temp & PORT_POWER)\n\t\t\tstatus |= USB_PORT_STAT_POWER;\n\n#ifndef\tOXU_VERBOSE_DEBUG\n\tif (status & ~0xffff)\t \n#endif\n\t\tdbg_port(oxu, \"GetStatus\", wIndex + 1, temp);\n\t\tput_unaligned(cpu_to_le32(status), (__le32 *) buf);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tselector = wIndex >> 8;\n\t\twIndex &= 0xff;\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = readl(status_reg);\n\t\tif (temp & PORT_OWNER)\n\t\t\tbreak;\n\n\t\ttemp &= ~PORT_RWC_BITS;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif ((temp & PORT_PE) == 0\n\t\t\t\t\t|| (temp & PORT_RESET) != 0)\n\t\t\t\tgoto error;\n\t\t\tif (device_may_wakeup(&hcd->self.root_hub->dev))\n\t\t\t\ttemp |= PORT_WAKE_BITS;\n\t\t\twritel(temp | PORT_SUSPEND, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (HCS_PPC(oxu->hcs_params))\n\t\t\t\twritel(temp | PORT_POWER, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (temp & PORT_RESUME)\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\toxu_vdbg(oxu, \"port %d reset\\n\", wIndex + 1);\n\t\t\ttemp |= PORT_RESET;\n\t\t\ttemp &= ~PORT_PE;\n\n\t\t\t \n\t\t\toxu->reset_done[wIndex] = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(50);\n\t\t\twritel(temp, status_reg);\n\t\t\tbreak;\n\n\t\t \n\t\tcase USB_PORT_FEAT_TEST:\n\t\t\tif (!selector || selector > 5)\n\t\t\t\tgoto error;\n\t\t\tehci_quiesce(oxu);\n\t\t\tehci_halt(oxu);\n\t\t\ttemp |= selector << 16;\n\t\t\twritel(temp, status_reg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\treadl(&oxu->regs->command);\t \n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&oxu->lock, flags);\n\treturn retval;\n}\n\n#ifdef CONFIG_PM\n\nstatic int oxu_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tint port;\n\tint mask;\n\n\toxu_dbg(oxu, \"suspend root hub\\n\");\n\n\tif (time_before(jiffies, oxu->next_statechange))\n\t\tmsleep(5);\n\n\tport = HCS_N_PORTS(oxu->hcs_params);\n\tspin_lock_irq(&oxu->lock);\n\n\t \n\tif (HC_IS_RUNNING(hcd->state)) {\n\t\tehci_quiesce(oxu);\n\t\thcd->state = HC_STATE_QUIESCING;\n\t}\n\toxu->command = readl(&oxu->regs->command);\n\tif (oxu->reclaim)\n\t\toxu->reclaim_ready = 1;\n\tehci_work(oxu);\n\n\t \n\toxu->bus_suspended = 0;\n\twhile (port--) {\n\t\tu32 __iomem *reg = &oxu->regs->port_status[port];\n\t\tu32 t1 = readl(reg) & ~PORT_RWC_BITS;\n\t\tu32 t2 = t1;\n\n\t\t \n\t\tif ((t1 & PORT_PE) && !(t1 & PORT_OWNER) &&\n\t\t\t\t!(t1 & PORT_SUSPEND)) {\n\t\t\tt2 |= PORT_SUSPEND;\n\t\t\tset_bit(port, &oxu->bus_suspended);\n\t\t}\n\n\t\t \n\t\tif (device_may_wakeup(&hcd->self.root_hub->dev))\n\t\t\tt2 |= PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E;\n\t\telse\n\t\t\tt2 &= ~(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E);\n\n\t\tif (t1 != t2) {\n\t\t\toxu_vdbg(oxu, \"port %d, %08x -> %08x\\n\",\n\t\t\t\tport + 1, t1, t2);\n\t\t\twritel(t2, reg);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&oxu->lock);\n\t \n\tdel_timer_sync(&oxu->watchdog);\n\tspin_lock_irq(&oxu->lock);\n\tehci_halt(oxu);\n\thcd->state = HC_STATE_SUSPENDED;\n\n\t \n\tmask = INTR_MASK;\n\tif (!device_may_wakeup(&hcd->self.root_hub->dev))\n\t\tmask &= ~STS_PCD;\n\twritel(mask, &oxu->regs->intr_enable);\n\treadl(&oxu->regs->intr_enable);\n\n\toxu->next_statechange = jiffies + msecs_to_jiffies(10);\n\tspin_unlock_irq(&oxu->lock);\n\treturn 0;\n}\n\n \nstatic int oxu_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct oxu_hcd *oxu = hcd_to_oxu(hcd);\n\tu32 temp;\n\tint i;\n\n\tif (time_before(jiffies, oxu->next_statechange))\n\t\tmsleep(5);\n\tspin_lock_irq(&oxu->lock);\n\n\t \n\ttemp = readl(&oxu->regs->intr_enable);\n\toxu_dbg(oxu, \"resume root hub%s\\n\", temp ? \"\" : \" after power loss\");\n\n\t \n\twritel(0, &oxu->regs->intr_enable);\n\n\t \n\twritel(0, &oxu->regs->segment);\n\twritel(oxu->periodic_dma, &oxu->regs->frame_list);\n\twritel((u32) oxu->async->qh_dma, &oxu->regs->async_next);\n\n\t \n\twritel(oxu->command, &oxu->regs->command);\n\n\t \n\tmdelay(8);\n\n\t \n\ti = HCS_N_PORTS(oxu->hcs_params);\n\twhile (i--) {\n\t\ttemp = readl(&oxu->regs->port_status[i]);\n\t\ttemp &= ~(PORT_RWC_BITS\n\t\t\t| PORT_WKOC_E | PORT_WKDISC_E | PORT_WKCONN_E);\n\t\tif (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {\n\t\t\toxu->reset_done[i] = jiffies + msecs_to_jiffies(20);\n\t\t\ttemp |= PORT_RESUME;\n\t\t}\n\t\twritel(temp, &oxu->regs->port_status[i]);\n\t}\n\ti = HCS_N_PORTS(oxu->hcs_params);\n\tmdelay(20);\n\twhile (i--) {\n\t\ttemp = readl(&oxu->regs->port_status[i]);\n\t\tif (test_bit(i, &oxu->bus_suspended) && (temp & PORT_SUSPEND)) {\n\t\t\ttemp &= ~(PORT_RWC_BITS | PORT_RESUME);\n\t\t\twritel(temp, &oxu->regs->port_status[i]);\n\t\t\toxu_vdbg(oxu, \"resumed port %d\\n\", i + 1);\n\t\t}\n\t}\n\t(void) readl(&oxu->regs->command);\n\n\t \n\ttemp = 0;\n\tif (oxu->async->qh_next.qh)\n\t\ttemp |= CMD_ASE;\n\tif (oxu->periodic_sched)\n\t\ttemp |= CMD_PSE;\n\tif (temp) {\n\t\toxu->command |= temp;\n\t\twritel(oxu->command, &oxu->regs->command);\n\t}\n\n\toxu->next_statechange = jiffies + msecs_to_jiffies(5);\n\thcd->state = HC_STATE_RUNNING;\n\n\t \n\twritel(INTR_MASK, &oxu->regs->intr_enable);\n\n\tspin_unlock_irq(&oxu->lock);\n\treturn 0;\n}\n\n#else\n\nstatic int oxu_bus_suspend(struct usb_hcd *hcd)\n{\n\treturn 0;\n}\n\nstatic int oxu_bus_resume(struct usb_hcd *hcd)\n{\n\treturn 0;\n}\n\n#endif\t \n\nstatic const struct hc_driver oxu_hc_driver = {\n\t.description =\t\t\"oxu210hp_hcd\",\n\t.product_desc =\t\t\"oxu210hp HCD\",\n\t.hcd_priv_size =\tsizeof(struct oxu_hcd),\n\n\t \n\t.irq =\t\t\toxu_irq,\n\t.flags =\t\tHCD_MEMORY | HCD_USB2,\n\n\t \n\t.reset =\t\toxu_reset,\n\t.start =\t\toxu_run,\n\t.stop =\t\t\toxu_stop,\n\t.shutdown =\t\toxu_shutdown,\n\n\t \n\t.urb_enqueue =\t\toxu_urb_enqueue,\n\t.urb_dequeue =\t\toxu_urb_dequeue,\n\t.endpoint_disable =\toxu_endpoint_disable,\n\n\t \n\t.get_frame_number =\toxu_get_frame,\n\n\t \n\t.hub_status_data =\toxu_hub_status_data,\n\t.hub_control =\t\toxu_hub_control,\n\t.bus_suspend =\t\toxu_bus_suspend,\n\t.bus_resume =\t\toxu_bus_resume,\n};\n\n \n\nstatic void oxu_configuration(struct platform_device *pdev, void __iomem *base)\n{\n\tu32 tmp;\n\n\t \n\toxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);\n\toxu_writel(base, OXU_SOFTRESET, OXU_SRESET);\n\toxu_writel(base, OXU_HOSTIFCONFIG, 0x0000037D);\n\n\ttmp = oxu_readl(base, OXU_PIOBURSTREADCTRL);\n\toxu_writel(base, OXU_PIOBURSTREADCTRL, tmp | 0x0040);\n\n\toxu_writel(base, OXU_ASO, OXU_SPHPOEN | OXU_OVRCCURPUPDEN |\n\t\t\t\t\tOXU_COMPARATOR | OXU_ASO_OP);\n\n\ttmp = oxu_readl(base, OXU_CLKCTRL_SET);\n\toxu_writel(base, OXU_CLKCTRL_SET, tmp | OXU_SYSCLKEN | OXU_USBOTGCLKEN);\n\n\t \n\toxu_writel(base, OXU_CHIPIRQEN_CLR, 0xff);\n\n\t \n\toxu_writel(base, OXU_CHIPIRQSTATUS, 0xff);\n\n\t \n\toxu_writel(base, OXU_CHIPIRQEN_SET, OXU_USBSPHLPWUI | OXU_USBOTGLPWUI);\n}\n\nstatic int oxu_verify_id(struct platform_device *pdev, void __iomem *base)\n{\n\tu32 id;\n\tstatic const char * const bo[] = {\n\t\t\"reserved\",\n\t\t\"128-pin LQFP\",\n\t\t\"84-pin TFBGA\",\n\t\t\"reserved\",\n\t};\n\n\t \n\tid = oxu_readl(base, OXU_DEVICEID);\n\tdev_info(&pdev->dev, \"device ID %x\\n\", id);\n\tif ((id & OXU_REV_MASK) != (OXU_REV_2100 << OXU_REV_SHIFT))\n\t\treturn -1;\n\n\tdev_info(&pdev->dev, \"found device %x %s (%04x:%04x)\\n\",\n\t\tid >> OXU_REV_SHIFT,\n\t\tbo[(id & OXU_BO_MASK) >> OXU_BO_SHIFT],\n\t\t(id & OXU_MAJ_REV_MASK) >> OXU_MAJ_REV_SHIFT,\n\t\t(id & OXU_MIN_REV_MASK) >> OXU_MIN_REV_SHIFT);\n\n\treturn 0;\n}\n\nstatic const struct hc_driver oxu_hc_driver;\nstatic struct usb_hcd *oxu_create(struct platform_device *pdev,\n\t\t\t\tunsigned long memstart, unsigned long memlen,\n\t\t\t\tvoid __iomem *base, int irq, int otg)\n{\n\tstruct device *dev = &pdev->dev;\n\n\tstruct usb_hcd *hcd;\n\tstruct oxu_hcd *oxu;\n\tint ret;\n\n\t \n\toxu_writel(base + (otg ? OXU_OTG_CORE_OFFSET : OXU_SPH_CORE_OFFSET),\n\t\t\t\tOXU_USBMODE,\n\t\t\t\tOXU_CM_HOST_ONLY | OXU_ES_LITTLE | OXU_VBPS);\n\n\thcd = usb_create_hcd(&oxu_hc_driver, dev,\n\t\t\t\totg ? \"oxu210hp_otg\" : \"oxu210hp_sph\");\n\tif (!hcd)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thcd->rsrc_start = memstart;\n\thcd->rsrc_len = memlen;\n\thcd->regs = base;\n\thcd->irq = irq;\n\thcd->state = HC_STATE_HALT;\n\n\toxu = hcd_to_oxu(hcd);\n\toxu->is_otg = otg;\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret < 0) {\n\t\tusb_put_hcd(hcd);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn hcd;\n}\n\nstatic int oxu_init(struct platform_device *pdev,\n\t\t\t\tunsigned long memstart, unsigned long memlen,\n\t\t\t\tvoid __iomem *base, int irq)\n{\n\tstruct oxu_info *info = platform_get_drvdata(pdev);\n\tstruct usb_hcd *hcd;\n\tint ret;\n\n\t \n\toxu_configuration(pdev, base);\n\n\tret = oxu_verify_id(pdev, base);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"no devices found!\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thcd = oxu_create(pdev, memstart, memlen, base, irq, 1);\n\tif (IS_ERR(hcd)) {\n\t\tdev_err(&pdev->dev, \"cannot create OTG controller!\\n\");\n\t\tret = PTR_ERR(hcd);\n\t\tgoto error_create_otg;\n\t}\n\tinfo->hcd[0] = hcd;\n\n\t \n\thcd = oxu_create(pdev, memstart, memlen, base, irq, 0);\n\tif (IS_ERR(hcd)) {\n\t\tdev_err(&pdev->dev, \"cannot create SPH controller!\\n\");\n\t\tret = PTR_ERR(hcd);\n\t\tgoto error_create_sph;\n\t}\n\tinfo->hcd[1] = hcd;\n\n\toxu_writel(base, OXU_CHIPIRQEN_SET,\n\t\toxu_readl(base, OXU_CHIPIRQEN_SET) | 3);\n\n\treturn 0;\n\nerror_create_sph:\n\tusb_remove_hcd(info->hcd[0]);\n\tusb_put_hcd(info->hcd[0]);\n\nerror_create_otg:\n\treturn ret;\n}\n\nstatic int oxu_drv_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tvoid __iomem *base;\n\tunsigned long memstart, memlen;\n\tint irq, ret;\n\tstruct oxu_info *info;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t \n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\tdev_dbg(&pdev->dev, \"IRQ resource %d\\n\", irq);\n\n\tbase = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(base)) {\n\t\tret = PTR_ERR(base);\n\t\tgoto error;\n\t}\n\tmemstart = res->start;\n\tmemlen = resource_size(res);\n\n\tret = irq_set_irq_type(irq, IRQF_TRIGGER_FALLING);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"error setting irq type\\n\");\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\n\t \n\tinfo = devm_kzalloc(&pdev->dev, sizeof(struct oxu_info), GFP_KERNEL);\n\tif (!info) {\n\t\tret = -EFAULT;\n\t\tgoto error;\n\t}\n\tplatform_set_drvdata(pdev, info);\n\n\tret = oxu_init(pdev, memstart, memlen, base, irq);\n\tif (ret < 0) {\n\t\tdev_dbg(&pdev->dev, \"cannot init USB devices\\n\");\n\t\tgoto error;\n\t}\n\n\tdev_info(&pdev->dev, \"devices enabled and running\\n\");\n\tplatform_set_drvdata(pdev, info);\n\n\treturn 0;\n\nerror:\n\tdev_err(&pdev->dev, \"init %s fail, %d\\n\", dev_name(&pdev->dev), ret);\n\treturn ret;\n}\n\nstatic void oxu_remove(struct platform_device *pdev, struct usb_hcd *hcd)\n{\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n}\n\nstatic void oxu_drv_remove(struct platform_device *pdev)\n{\n\tstruct oxu_info *info = platform_get_drvdata(pdev);\n\n\toxu_remove(pdev, info->hcd[0]);\n\toxu_remove(pdev, info->hcd[1]);\n}\n\nstatic void oxu_drv_shutdown(struct platform_device *pdev)\n{\n\toxu_drv_remove(pdev);\n}\n\n#if 0\n \nstatic int oxu_drv_suspend(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\n\treturn 0;\n}\n\nstatic int oxu_drv_resume(struct device *dev)\n{\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\n\treturn 0;\n}\n#else\n#define oxu_drv_suspend\tNULL\n#define oxu_drv_resume\tNULL\n#endif\n\nstatic struct platform_driver oxu_driver = {\n\t.probe\t\t= oxu_drv_probe,\n\t.remove_new\t= oxu_drv_remove,\n\t.shutdown\t= oxu_drv_shutdown,\n\t.suspend\t= oxu_drv_suspend,\n\t.resume\t\t= oxu_drv_resume,\n\t.driver = {\n\t\t.name = \"oxu210hp-hcd\",\n\t\t.bus = &platform_bus_type\n\t}\n};\n\nmodule_platform_driver(oxu_driver);\n\nMODULE_DESCRIPTION(\"Oxford OXU210HP HCD driver - ver. \" DRIVER_VERSION);\nMODULE_AUTHOR(\"Rodolfo Giometti <giometti@linux.it>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}