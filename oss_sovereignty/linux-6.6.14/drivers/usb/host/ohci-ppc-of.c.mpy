{
  "module_name": "ohci-ppc-of.c",
  "hash_id": "038cc23092de9fc62e0e9848f19f521d037bd8cabec5c22594c57e76effb0ccc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-ppc-of.c",
  "human_readable_source": "\n \n\n#include <linux/signal.h>\n#include <linux/of.h>\n#include <linux/of_address.h>\n#include <linux/of_irq.h>\n#include <linux/platform_device.h>\n\nstatic int\nohci_ppc_of_start(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\tint\t\tret;\n\n\tif ((ret = ohci_init(ohci)) < 0)\n\t\treturn ret;\n\n\tif ((ret = ohci_run(ohci)) < 0) {\n\t\tdev_err(hcd->self.controller, \"can't start %s\\n\",\n\t\t\thcd->self.bus_name);\n\t\tohci_stop(hcd);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic const struct hc_driver ohci_ppc_of_hc_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"OF OHCI\",\n\t.hcd_priv_size =\tsizeof(struct ohci_hcd),\n\n\t \n\t.irq =\t\t\tohci_irq,\n\t.flags =\t\tHCD_USB11 | HCD_DMA | HCD_MEMORY,\n\n\t \n\t.start =\t\tohci_ppc_of_start,\n\t.stop =\t\t\tohci_stop,\n\t.shutdown = \t\tohci_shutdown,\n\n\t \n\t.urb_enqueue =\t\tohci_urb_enqueue,\n\t.urb_dequeue =\t\tohci_urb_dequeue,\n\t.endpoint_disable =\tohci_endpoint_disable,\n\n\t \n\t.get_frame_number =\tohci_get_frame,\n\n\t \n\t.hub_status_data =\tohci_hub_status_data,\n\t.hub_control =\t\tohci_hub_control,\n#ifdef\tCONFIG_PM\n\t.bus_suspend =\t\tohci_bus_suspend,\n\t.bus_resume =\t\tohci_bus_resume,\n#endif\n\t.start_port_reset =\tohci_start_port_reset,\n};\n\n\nstatic int ohci_hcd_ppc_of_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct usb_hcd *hcd;\n\tstruct ohci_hcd\t*ohci;\n\tstruct resource res;\n\tint irq;\n\n\tint rv;\n\tint is_bigendian;\n\tstruct device_node *np;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tis_bigendian =\n\t\tof_device_is_compatible(dn, \"ohci-bigendian\") ||\n\t\tof_device_is_compatible(dn, \"ohci-be\");\n\n\tdev_dbg(&op->dev, \"initializing PPC-OF USB Controller\\n\");\n\n\trv = of_address_to_resource(dn, 0, &res);\n\tif (rv)\n\t\treturn rv;\n\n\thcd = usb_create_hcd(&ohci_ppc_of_hc_driver, &op->dev, \"PPC-OF USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = res.start;\n\thcd->rsrc_len = resource_size(&res);\n\n\thcd->regs = devm_ioremap_resource(&op->dev, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\trv = PTR_ERR(hcd->regs);\n\t\tgoto err_rmr;\n\t}\n\n\tirq = irq_of_parse_and_map(dn, 0);\n\tif (!irq) {\n\t\tdev_err(&op->dev, \"%s: irq_of_parse_and_map failed\\n\",\n\t\t\t__FILE__);\n\t\trv = -EBUSY;\n\t\tgoto err_rmr;\n\t}\n\n\tohci = hcd_to_ohci(hcd);\n\tif (is_bigendian) {\n\t\tohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;\n\t\tif (of_device_is_compatible(dn, \"fsl,mpc5200-ohci\"))\n\t\t\tohci->flags |= OHCI_QUIRK_FRAME_NO;\n\t\tif (of_device_is_compatible(dn, \"mpc5200-ohci\"))\n\t\t\tohci->flags |= OHCI_QUIRK_FRAME_NO;\n\t}\n\n\tohci_hcd_init(ohci);\n\n\trv = usb_add_hcd(hcd, irq, 0);\n\tif (rv == 0) {\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t\treturn 0;\n\t}\n\n\t \n\tnp = of_find_compatible_node(NULL, NULL, \"ibm,usb-ehci-440epx\");\n\n\t \n\tif (np !=  NULL) {\n\t\tif (!of_address_to_resource(np, 0, &res)) {\n\t\t\tif (!request_mem_region(res.start, 0x4, hcd_name)) {\n\t\t\t\twritel_be((readl_be(&ohci->regs->control) |\n\t\t\t\t\tOHCI_USB_SUSPEND), &ohci->regs->control);\n\t\t\t\t\t(void) readl_be(&ohci->regs->control);\n\t\t\t} else\n\t\t\t\trelease_mem_region(res.start, 0x4);\n\t\t} else\n\t\t\tpr_debug(\"%s: cannot get ehci offset from fdt\\n\", __FILE__);\n\t\tof_node_put(np);\n\t}\n\n\tirq_dispose_mapping(irq);\nerr_rmr:\n \tusb_put_hcd(hcd);\n\n\treturn rv;\n}\n\nstatic void ohci_hcd_ppc_of_remove(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\n\tdev_dbg(&op->dev, \"stopping PPC-OF USB Controller\\n\");\n\n\tusb_remove_hcd(hcd);\n\n\tirq_dispose_mapping(hcd->irq);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct of_device_id ohci_hcd_ppc_of_match[] = {\n#ifdef CONFIG_USB_OHCI_HCD_PPC_OF_BE\n\t{\n\t\t.name = \"usb\",\n\t\t.compatible = \"ohci-bigendian\",\n\t},\n\t{\n\t\t.name = \"usb\",\n\t\t.compatible = \"ohci-be\",\n\t},\n#endif\n#ifdef CONFIG_USB_OHCI_HCD_PPC_OF_LE\n\t{\n\t\t.name = \"usb\",\n\t\t.compatible = \"ohci-littledian\",\n\t},\n\t{\n\t\t.name = \"usb\",\n\t\t.compatible = \"ohci-le\",\n\t},\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, ohci_hcd_ppc_of_match);\n\n#if\t!defined(CONFIG_USB_OHCI_HCD_PPC_OF_BE) && \\\n\t!defined(CONFIG_USB_OHCI_HCD_PPC_OF_LE)\n#error \"No endianness selected for ppc-of-ohci\"\n#endif\n\n\nstatic struct platform_driver ohci_hcd_ppc_of_driver = {\n\t.probe\t\t= ohci_hcd_ppc_of_probe,\n\t.remove_new\t= ohci_hcd_ppc_of_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name = \"ppc-of-ohci\",\n\t\t.of_match_table = ohci_hcd_ppc_of_match,\n\t},\n};\n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}