{
  "module_name": "uhci-q.c",
  "hash_id": "3b66fbe463c3b268add5faff8c68798efcbd13d5b2ae24af4b05963cb6601607",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-q.c",
  "human_readable_source": "\n \n\n\n \nstatic void uhci_set_next_interrupt(struct uhci_hcd *uhci)\n{\n\tif (uhci->is_stopped)\n\t\tmod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);\n\tuhci->term_td->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\n}\n\nstatic inline void uhci_clear_next_interrupt(struct uhci_hcd *uhci)\n{\n\tuhci->term_td->status &= ~cpu_to_hc32(uhci, TD_CTRL_IOC);\n}\n\n\n \nstatic void uhci_fsbr_on(struct uhci_hcd *uhci)\n{\n\tstruct uhci_qh *lqh;\n\n\t \n\tuhci->fsbr_is_on = 1;\n\tlqh = list_entry(uhci->skel_async_qh->node.prev,\n\t\t\tstruct uhci_qh, node);\n\tlqh->link = LINK_TO_QH(uhci, uhci->skel_term_qh);\n}\n\nstatic void uhci_fsbr_off(struct uhci_hcd *uhci)\n{\n\tstruct uhci_qh *lqh;\n\n\t \n\tuhci->fsbr_is_on = 0;\n\tlqh = list_entry(uhci->skel_async_qh->node.prev,\n\t\t\tstruct uhci_qh, node);\n\tlqh->link = UHCI_PTR_TERM(uhci);\n}\n\nstatic void uhci_add_fsbr(struct uhci_hcd *uhci, struct urb *urb)\n{\n\tstruct urb_priv *urbp = urb->hcpriv;\n\n\turbp->fsbr = 1;\n}\n\nstatic void uhci_urbp_wants_fsbr(struct uhci_hcd *uhci, struct urb_priv *urbp)\n{\n\tif (urbp->fsbr) {\n\t\tuhci->fsbr_is_wanted = 1;\n\t\tif (!uhci->fsbr_is_on)\n\t\t\tuhci_fsbr_on(uhci);\n\t\telse if (uhci->fsbr_expiring) {\n\t\t\tuhci->fsbr_expiring = 0;\n\t\t\tdel_timer(&uhci->fsbr_timer);\n\t\t}\n\t}\n}\n\nstatic void uhci_fsbr_timeout(struct timer_list *t)\n{\n\tstruct uhci_hcd *uhci = from_timer(uhci, t, fsbr_timer);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&uhci->lock, flags);\n\tif (uhci->fsbr_expiring) {\n\t\tuhci->fsbr_expiring = 0;\n\t\tuhci_fsbr_off(uhci);\n\t}\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n}\n\n\nstatic struct uhci_td *uhci_alloc_td(struct uhci_hcd *uhci)\n{\n\tdma_addr_t dma_handle;\n\tstruct uhci_td *td;\n\n\ttd = dma_pool_alloc(uhci->td_pool, GFP_ATOMIC, &dma_handle);\n\tif (!td)\n\t\treturn NULL;\n\n\ttd->dma_handle = dma_handle;\n\ttd->frame = -1;\n\n\tINIT_LIST_HEAD(&td->list);\n\tINIT_LIST_HEAD(&td->fl_list);\n\n\treturn td;\n}\n\nstatic void uhci_free_td(struct uhci_hcd *uhci, struct uhci_td *td)\n{\n\tif (!list_empty(&td->list))\n\t\tdev_WARN(uhci_dev(uhci), \"td %p still in list!\\n\", td);\n\tif (!list_empty(&td->fl_list))\n\t\tdev_WARN(uhci_dev(uhci), \"td %p still in fl_list!\\n\", td);\n\n\tdma_pool_free(uhci->td_pool, td, td->dma_handle);\n}\n\nstatic inline void uhci_fill_td(struct uhci_hcd *uhci, struct uhci_td *td,\n\t\tu32 status, u32 token, u32 buffer)\n{\n\ttd->status = cpu_to_hc32(uhci, status);\n\ttd->token = cpu_to_hc32(uhci, token);\n\ttd->buffer = cpu_to_hc32(uhci, buffer);\n}\n\nstatic void uhci_add_td_to_urbp(struct uhci_td *td, struct urb_priv *urbp)\n{\n\tlist_add_tail(&td->list, &urbp->td_list);\n}\n\nstatic void uhci_remove_td_from_urbp(struct uhci_td *td)\n{\n\tlist_del_init(&td->list);\n}\n\n \nstatic inline void uhci_insert_td_in_frame_list(struct uhci_hcd *uhci,\n\t\tstruct uhci_td *td, unsigned framenum)\n{\n\tframenum &= (UHCI_NUMFRAMES - 1);\n\n\ttd->frame = framenum;\n\n\t \n\tif (uhci->frame_cpu[framenum]) {\n\t\tstruct uhci_td *ftd, *ltd;\n\n\t\tftd = uhci->frame_cpu[framenum];\n\t\tltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);\n\n\t\tlist_add_tail(&td->fl_list, &ftd->fl_list);\n\n\t\ttd->link = ltd->link;\n\t\twmb();\n\t\tltd->link = LINK_TO_TD(uhci, td);\n\t} else {\n\t\ttd->link = uhci->frame[framenum];\n\t\twmb();\n\t\tuhci->frame[framenum] = LINK_TO_TD(uhci, td);\n\t\tuhci->frame_cpu[framenum] = td;\n\t}\n}\n\nstatic inline void uhci_remove_td_from_frame_list(struct uhci_hcd *uhci,\n\t\tstruct uhci_td *td)\n{\n\t \n\tif (td->frame == -1) {\n\t\tWARN_ON(!list_empty(&td->fl_list));\n\t\treturn;\n\t}\n\n\tif (uhci->frame_cpu[td->frame] == td) {\n\t\tif (list_empty(&td->fl_list)) {\n\t\t\tuhci->frame[td->frame] = td->link;\n\t\t\tuhci->frame_cpu[td->frame] = NULL;\n\t\t} else {\n\t\t\tstruct uhci_td *ntd;\n\n\t\t\tntd = list_entry(td->fl_list.next,\n\t\t\t\t\t struct uhci_td,\n\t\t\t\t\t fl_list);\n\t\t\tuhci->frame[td->frame] = LINK_TO_TD(uhci, ntd);\n\t\t\tuhci->frame_cpu[td->frame] = ntd;\n\t\t}\n\t} else {\n\t\tstruct uhci_td *ptd;\n\n\t\tptd = list_entry(td->fl_list.prev, struct uhci_td, fl_list);\n\t\tptd->link = td->link;\n\t}\n\n\tlist_del_init(&td->fl_list);\n\ttd->frame = -1;\n}\n\nstatic inline void uhci_remove_tds_from_frame(struct uhci_hcd *uhci,\n\t\tunsigned int framenum)\n{\n\tstruct uhci_td *ftd, *ltd;\n\n\tframenum &= (UHCI_NUMFRAMES - 1);\n\n\tftd = uhci->frame_cpu[framenum];\n\tif (ftd) {\n\t\tltd = list_entry(ftd->fl_list.prev, struct uhci_td, fl_list);\n\t\tuhci->frame[framenum] = ltd->link;\n\t\tuhci->frame_cpu[framenum] = NULL;\n\n\t\twhile (!list_empty(&ftd->fl_list))\n\t\t\tlist_del_init(ftd->fl_list.prev);\n\t}\n}\n\n \nstatic void uhci_unlink_isochronous_tds(struct uhci_hcd *uhci, struct urb *urb)\n{\n\tstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\n\tstruct uhci_td *td;\n\n\tlist_for_each_entry(td, &urbp->td_list, list)\n\t\tuhci_remove_td_from_frame_list(uhci, td);\n}\n\nstatic struct uhci_qh *uhci_alloc_qh(struct uhci_hcd *uhci,\n\t\tstruct usb_device *udev, struct usb_host_endpoint *hep)\n{\n\tdma_addr_t dma_handle;\n\tstruct uhci_qh *qh;\n\n\tqh = dma_pool_zalloc(uhci->qh_pool, GFP_ATOMIC, &dma_handle);\n\tif (!qh)\n\t\treturn NULL;\n\n\tqh->dma_handle = dma_handle;\n\n\tqh->element = UHCI_PTR_TERM(uhci);\n\tqh->link = UHCI_PTR_TERM(uhci);\n\n\tINIT_LIST_HEAD(&qh->queue);\n\tINIT_LIST_HEAD(&qh->node);\n\n\tif (udev) {\t\t \n\t\tqh->type = usb_endpoint_type(&hep->desc);\n\t\tif (qh->type != USB_ENDPOINT_XFER_ISOC) {\n\t\t\tqh->dummy_td = uhci_alloc_td(uhci);\n\t\t\tif (!qh->dummy_td) {\n\t\t\t\tdma_pool_free(uhci->qh_pool, qh, dma_handle);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tqh->state = QH_STATE_IDLE;\n\t\tqh->hep = hep;\n\t\tqh->udev = udev;\n\t\thep->hcpriv = qh;\n\n\t\tif (qh->type == USB_ENDPOINT_XFER_INT ||\n\t\t\t\tqh->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tqh->load = usb_calc_bus_time(udev->speed,\n\t\t\t\t\tusb_endpoint_dir_in(&hep->desc),\n\t\t\t\t\tqh->type == USB_ENDPOINT_XFER_ISOC,\n\t\t\t\t\tusb_endpoint_maxp(&hep->desc))\n\t\t\t\t/ 1000 + 1;\n\n\t} else {\t\t \n\t\tqh->state = QH_STATE_ACTIVE;\n\t\tqh->type = -1;\n\t}\n\treturn qh;\n}\n\nstatic void uhci_free_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tWARN_ON(qh->state != QH_STATE_IDLE && qh->udev);\n\tif (!list_empty(&qh->queue))\n\t\tdev_WARN(uhci_dev(uhci), \"qh %p list not empty!\\n\", qh);\n\n\tlist_del(&qh->node);\n\tif (qh->udev) {\n\t\tqh->hep->hcpriv = NULL;\n\t\tif (qh->dummy_td)\n\t\t\tuhci_free_td(uhci, qh->dummy_td);\n\t}\n\tdma_pool_free(uhci->qh_pool, qh, qh->dma_handle);\n}\n\n \nstatic int uhci_cleanup_queue(struct uhci_hcd *uhci, struct uhci_qh *qh,\n\t\tstruct urb *urb)\n{\n\tstruct urb_priv *urbp = urb->hcpriv;\n\tstruct uhci_td *td;\n\tint ret = 1;\n\n\t \n\tif (qh->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tret = (uhci->frame_number + uhci->is_stopped !=\n\t\t\t\tqh->unlink_frame);\n\t\tgoto done;\n\t}\n\n\t \n\tif (qh->queue.next != &urbp->node) {\n\t\tstruct urb_priv *purbp;\n\t\tstruct uhci_td *ptd;\n\n\t\tpurbp = list_entry(urbp->node.prev, struct urb_priv, node);\n\t\tWARN_ON(list_empty(&purbp->td_list));\n\t\tptd = list_entry(purbp->td_list.prev, struct uhci_td,\n\t\t\t\tlist);\n\t\ttd = list_entry(urbp->td_list.prev, struct uhci_td,\n\t\t\t\tlist);\n\t\tptd->link = td->link;\n\t\tgoto done;\n\t}\n\n\t \n\tif (qh_element(qh) == UHCI_PTR_TERM(uhci))\n\t\tgoto done;\n\tqh->element = UHCI_PTR_TERM(uhci);\n\n\t \n\tif (qh->type == USB_ENDPOINT_XFER_CONTROL)\n\t\tgoto done;\n\n\t \n\tWARN_ON(list_empty(&urbp->td_list));\n\ttd = list_entry(urbp->td_list.next, struct uhci_td, list);\n\tqh->needs_fixup = 1;\n\tqh->initial_toggle = uhci_toggle(td_token(uhci, td));\n\ndone:\n\treturn ret;\n}\n\n \nstatic void uhci_fixup_toggles(struct uhci_hcd *uhci, struct uhci_qh *qh,\n\t\t\tint skip_first)\n{\n\tstruct urb_priv *urbp = NULL;\n\tstruct uhci_td *td;\n\tunsigned int toggle = qh->initial_toggle;\n\tunsigned int pipe;\n\n\t \n\tif (skip_first)\n\t\turbp = list_entry(qh->queue.next, struct urb_priv, node);\n\n\t \n\telse if (qh_element(qh) != UHCI_PTR_TERM(uhci))\n\t\ttoggle = 2;\n\n\t \n\turbp = list_prepare_entry(urbp, &qh->queue, node);\n\tlist_for_each_entry_continue(urbp, &qh->queue, node) {\n\n\t\t \n\t\ttd = list_entry(urbp->td_list.next, struct uhci_td, list);\n\t\tif (toggle > 1 || uhci_toggle(td_token(uhci, td)) == toggle) {\n\t\t\ttd = list_entry(urbp->td_list.prev, struct uhci_td,\n\t\t\t\t\tlist);\n\t\t\ttoggle = uhci_toggle(td_token(uhci, td)) ^ 1;\n\n\t\t \n\t\t} else {\n\t\t\tlist_for_each_entry(td, &urbp->td_list, list) {\n\t\t\t\ttd->token ^= cpu_to_hc32(uhci,\n\t\t\t\t\t\t\tTD_TOKEN_TOGGLE);\n\t\t\t\ttoggle ^= 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twmb();\n\tpipe = list_entry(qh->queue.next, struct urb_priv, node)->urb->pipe;\n\tusb_settoggle(qh->udev, usb_pipeendpoint(pipe),\n\t\t\tusb_pipeout(pipe), toggle);\n\tqh->needs_fixup = 0;\n}\n\n \nstatic inline void link_iso(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tlist_add_tail(&qh->node, &uhci->skel_iso_qh->node);\n\n\t \n}\n\n \nstatic void link_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct uhci_qh *pqh;\n\n\tlist_add_tail(&qh->node, &uhci->skelqh[qh->skel]->node);\n\n\tpqh = list_entry(qh->node.prev, struct uhci_qh, node);\n\tqh->link = pqh->link;\n\twmb();\n\tpqh->link = LINK_TO_QH(uhci, qh);\n}\n\n \nstatic void link_async(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct uhci_qh *pqh;\n\t__hc32 link_to_new_qh;\n\n\t \n\tlist_for_each_entry_reverse(pqh, &uhci->skel_async_qh->node, node) {\n\t\tif (pqh->skel <= qh->skel)\n\t\t\tbreak;\n\t}\n\tlist_add(&qh->node, &pqh->node);\n\n\t \n\tqh->link = pqh->link;\n\twmb();\n\tlink_to_new_qh = LINK_TO_QH(uhci, qh);\n\tpqh->link = link_to_new_qh;\n\n\t \n\tif (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)\n\t\tuhci->skel_term_qh->link = link_to_new_qh;\n}\n\n \nstatic void uhci_activate_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tWARN_ON(list_empty(&qh->queue));\n\n\t \n\tif (qh_element(qh) == UHCI_PTR_TERM(uhci)) {\n\t\tstruct urb_priv *urbp = list_entry(qh->queue.next,\n\t\t\t\tstruct urb_priv, node);\n\t\tstruct uhci_td *td = list_entry(urbp->td_list.next,\n\t\t\t\tstruct uhci_td, list);\n\n\t\tqh->element = LINK_TO_TD(uhci, td);\n\t}\n\n\t \n\tqh->wait_expired = 0;\n\tqh->advance_jiffies = jiffies;\n\n\tif (qh->state == QH_STATE_ACTIVE)\n\t\treturn;\n\tqh->state = QH_STATE_ACTIVE;\n\n\t \n\tif (qh == uhci->next_qh)\n\t\tuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\n\t\t\t\tnode);\n\tlist_del(&qh->node);\n\n\tif (qh->skel == SKEL_ISO)\n\t\tlink_iso(uhci, qh);\n\telse if (qh->skel < SKEL_ASYNC)\n\t\tlink_interrupt(uhci, qh);\n\telse\n\t\tlink_async(uhci, qh);\n}\n\n \nstatic void unlink_interrupt(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct uhci_qh *pqh;\n\n\tpqh = list_entry(qh->node.prev, struct uhci_qh, node);\n\tpqh->link = qh->link;\n\tmb();\n}\n\n \nstatic void unlink_async(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct uhci_qh *pqh;\n\t__hc32 link_to_next_qh = qh->link;\n\n\tpqh = list_entry(qh->node.prev, struct uhci_qh, node);\n\tpqh->link = link_to_next_qh;\n\n\t \n\tif (pqh->skel < SKEL_FSBR && qh->skel >= SKEL_FSBR)\n\t\tuhci->skel_term_qh->link = link_to_next_qh;\n\tmb();\n}\n\n \nstatic void uhci_unlink_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tif (qh->state == QH_STATE_UNLINKING)\n\t\treturn;\n\tWARN_ON(qh->state != QH_STATE_ACTIVE || !qh->udev);\n\tqh->state = QH_STATE_UNLINKING;\n\n\t \n\tif (qh->skel == SKEL_ISO)\n\t\t;\n\telse if (qh->skel < SKEL_ASYNC)\n\t\tunlink_interrupt(uhci, qh);\n\telse\n\t\tunlink_async(uhci, qh);\n\n\tuhci_get_current_frame_number(uhci);\n\tqh->unlink_frame = uhci->frame_number;\n\n\t \n\tif (list_empty(&uhci->skel_unlink_qh->node) || uhci->is_stopped)\n\t\tuhci_set_next_interrupt(uhci);\n\n\t \n\tif (qh == uhci->next_qh)\n\t\tuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\n\t\t\t\tnode);\n\tlist_move_tail(&qh->node, &uhci->skel_unlink_qh->node);\n}\n\n \nstatic void uhci_make_qh_idle(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tWARN_ON(qh->state == QH_STATE_ACTIVE);\n\n\tif (qh == uhci->next_qh)\n\t\tuhci->next_qh = list_entry(qh->node.next, struct uhci_qh,\n\t\t\t\tnode);\n\tlist_move(&qh->node, &uhci->idle_qh_list);\n\tqh->state = QH_STATE_IDLE;\n\n\t \n\tif (qh->post_td) {\n\t\tuhci_free_td(uhci, qh->post_td);\n\t\tqh->post_td = NULL;\n\t}\n\n\t \n\tif (uhci->num_waiting)\n\t\twake_up_all(&uhci->waitqh);\n}\n\n \nstatic int uhci_highest_load(struct uhci_hcd *uhci, int phase, int period)\n{\n\tint highest_load = uhci->load[phase];\n\n\tfor (phase += period; phase < MAX_PHASE; phase += period)\n\t\thighest_load = max_t(int, highest_load, uhci->load[phase]);\n\treturn highest_load;\n}\n\n \nstatic int uhci_check_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tint minimax_load;\n\n\t \n\tif (qh->phase >= 0)\n\t\tminimax_load = uhci_highest_load(uhci, qh->phase, qh->period);\n\telse {\n\t\tint phase, load;\n\t\tint max_phase = min_t(int, MAX_PHASE, qh->period);\n\n\t\tqh->phase = 0;\n\t\tminimax_load = uhci_highest_load(uhci, qh->phase, qh->period);\n\t\tfor (phase = 1; phase < max_phase; ++phase) {\n\t\t\tload = uhci_highest_load(uhci, phase, qh->period);\n\t\t\tif (load < minimax_load) {\n\t\t\t\tminimax_load = load;\n\t\t\t\tqh->phase = phase;\n\t\t\t}\n\t\t}\n\t}\n\n\t \n\tif (minimax_load + qh->load > 900) {\n\t\tdev_dbg(uhci_dev(uhci), \"bandwidth allocation failed: \"\n\t\t\t\t\"period %d, phase %d, %d + %d us\\n\",\n\t\t\t\tqh->period, qh->phase, minimax_load, qh->load);\n\t\treturn -ENOSPC;\n\t}\n\treturn 0;\n}\n\n \nstatic void uhci_reserve_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tint i;\n\tint load = qh->load;\n\tchar *p = \"??\";\n\n\tfor (i = qh->phase; i < MAX_PHASE; i += qh->period) {\n\t\tuhci->load[i] += load;\n\t\tuhci->total_load += load;\n\t}\n\tuhci_to_hcd(uhci)->self.bandwidth_allocated =\n\t\t\tuhci->total_load / MAX_PHASE;\n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t++uhci_to_hcd(uhci)->self.bandwidth_int_reqs;\n\t\tp = \"INT\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t++uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;\n\t\tp = \"ISO\";\n\t\tbreak;\n\t}\n\tqh->bandwidth_reserved = 1;\n\tdev_dbg(uhci_dev(uhci),\n\t\t\t\"%s dev %d ep%02x-%s, period %d, phase %d, %d us\\n\",\n\t\t\t\"reserve\", qh->udev->devnum,\n\t\t\tqh->hep->desc.bEndpointAddress, p,\n\t\t\tqh->period, qh->phase, load);\n}\n\n \nstatic void uhci_release_bandwidth(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tint i;\n\tint load = qh->load;\n\tchar *p = \"??\";\n\n\tfor (i = qh->phase; i < MAX_PHASE; i += qh->period) {\n\t\tuhci->load[i] -= load;\n\t\tuhci->total_load -= load;\n\t}\n\tuhci_to_hcd(uhci)->self.bandwidth_allocated =\n\t\t\tuhci->total_load / MAX_PHASE;\n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_INT:\n\t\t--uhci_to_hcd(uhci)->self.bandwidth_int_reqs;\n\t\tp = \"INT\";\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\t--uhci_to_hcd(uhci)->self.bandwidth_isoc_reqs;\n\t\tp = \"ISO\";\n\t\tbreak;\n\t}\n\tqh->bandwidth_reserved = 0;\n\tdev_dbg(uhci_dev(uhci),\n\t\t\t\"%s dev %d ep%02x-%s, period %d, phase %d, %d us\\n\",\n\t\t\t\"release\", qh->udev->devnum,\n\t\t\tqh->hep->desc.bEndpointAddress, p,\n\t\t\tqh->period, qh->phase, load);\n}\n\nstatic inline struct urb_priv *uhci_alloc_urb_priv(struct uhci_hcd *uhci,\n\t\tstruct urb *urb)\n{\n\tstruct urb_priv *urbp;\n\n\turbp = kmem_cache_zalloc(uhci_up_cachep, GFP_ATOMIC);\n\tif (!urbp)\n\t\treturn NULL;\n\n\turbp->urb = urb;\n\turb->hcpriv = urbp;\n\n\tINIT_LIST_HEAD(&urbp->node);\n\tINIT_LIST_HEAD(&urbp->td_list);\n\n\treturn urbp;\n}\n\nstatic void uhci_free_urb_priv(struct uhci_hcd *uhci,\n\t\tstruct urb_priv *urbp)\n{\n\tstruct uhci_td *td, *tmp;\n\n\tif (!list_empty(&urbp->node))\n\t\tdev_WARN(uhci_dev(uhci), \"urb %p still on QH's list!\\n\",\n\t\t\t\turbp->urb);\n\n\tlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\n\t\tuhci_remove_td_from_urbp(td);\n\t\tuhci_free_td(uhci, td);\n\t}\n\n\tkmem_cache_free(uhci_up_cachep, urbp);\n}\n\n \nstatic int uhci_map_status(int status, int dir_out)\n{\n\tif (!status)\n\t\treturn 0;\n\tif (status & TD_CTRL_BITSTUFF)\t\t\t \n\t\treturn -EPROTO;\n\tif (status & TD_CTRL_CRCTIMEO) {\t\t \n\t\tif (dir_out)\n\t\t\treturn -EPROTO;\n\t\telse\n\t\t\treturn -EILSEQ;\n\t}\n\tif (status & TD_CTRL_BABBLE)\t\t\t \n\t\treturn -EOVERFLOW;\n\tif (status & TD_CTRL_DBUFERR)\t\t\t \n\t\treturn -ENOSR;\n\tif (status & TD_CTRL_STALLED)\t\t\t \n\t\treturn -EPIPE;\n\treturn 0;\n}\n\n \nstatic int uhci_submit_control(struct uhci_hcd *uhci, struct urb *urb,\n\t\tstruct uhci_qh *qh)\n{\n\tstruct uhci_td *td;\n\tunsigned long destination, status;\n\tint maxsze = usb_endpoint_maxp(&qh->hep->desc);\n\tint len = urb->transfer_buffer_length;\n\tdma_addr_t data = urb->transfer_dma;\n\t__hc32 *plink;\n\tstruct urb_priv *urbp = urb->hcpriv;\n\tint skel;\n\n\t \n\tdestination = (urb->pipe & PIPE_DEVEP_MASK) | USB_PID_SETUP;\n\n\t \n\tstatus = uhci_maxerr(3);\n\tif (urb->dev->speed == USB_SPEED_LOW)\n\t\tstatus |= TD_CTRL_LS;\n\n\t \n\ttd = qh->dummy_td;\n\tuhci_add_td_to_urbp(td, urbp);\n\tuhci_fill_td(uhci, td, status, destination | uhci_explen(8),\n\t\t\turb->setup_dma);\n\tplink = &td->link;\n\tstatus |= TD_CTRL_ACTIVE;\n\n\t \n\tif (usb_pipeout(urb->pipe) || len == 0)\n\t\tdestination ^= (USB_PID_SETUP ^ USB_PID_OUT);\n\telse {\n\t\tdestination ^= (USB_PID_SETUP ^ USB_PID_IN);\n\t\tstatus |= TD_CTRL_SPD;\n\t}\n\n\t \n\twhile (len > 0) {\n\t\tint pktsze = maxsze;\n\n\t\tif (len <= pktsze) {\t\t \n\t\t\tpktsze = len;\n\t\t\tstatus &= ~TD_CTRL_SPD;\n\t\t}\n\n\t\ttd = uhci_alloc_td(uhci);\n\t\tif (!td)\n\t\t\tgoto nomem;\n\t\t*plink = LINK_TO_TD(uhci, td);\n\n\t\t \n\t\tdestination ^= TD_TOKEN_TOGGLE;\n\n\t\tuhci_add_td_to_urbp(td, urbp);\n\t\tuhci_fill_td(uhci, td, status,\n\t\t\tdestination | uhci_explen(pktsze), data);\n\t\tplink = &td->link;\n\n\t\tdata += pktsze;\n\t\tlen -= pktsze;\n\t}\n\n\t \n\ttd = uhci_alloc_td(uhci);\n\tif (!td)\n\t\tgoto nomem;\n\t*plink = LINK_TO_TD(uhci, td);\n\n\t \n\tdestination ^= (USB_PID_IN ^ USB_PID_OUT);\n\tdestination |= TD_TOKEN_TOGGLE;\t\t \n\n\tuhci_add_td_to_urbp(td, urbp);\n\tuhci_fill_td(uhci, td, status | TD_CTRL_IOC,\n\t\t\tdestination | uhci_explen(0), 0);\n\tplink = &td->link;\n\n\t \n\ttd = uhci_alloc_td(uhci);\n\tif (!td)\n\t\tgoto nomem;\n\t*plink = LINK_TO_TD(uhci, td);\n\n\tuhci_fill_td(uhci, td, 0, USB_PID_OUT | uhci_explen(0), 0);\n\twmb();\n\tqh->dummy_td->status |= cpu_to_hc32(uhci, TD_CTRL_ACTIVE);\n\tqh->dummy_td = td;\n\n\t \n\tif (urb->dev->speed == USB_SPEED_LOW ||\n\t\t\turb->dev->state != USB_STATE_CONFIGURED)\n\t\tskel = SKEL_LS_CONTROL;\n\telse {\n\t\tskel = SKEL_FS_CONTROL;\n\t\tuhci_add_fsbr(uhci, urb);\n\t}\n\tif (qh->state != QH_STATE_ACTIVE)\n\t\tqh->skel = skel;\n\treturn 0;\n\nnomem:\n\t \n\tuhci_remove_td_from_urbp(qh->dummy_td);\n\treturn -ENOMEM;\n}\n\n \nstatic int uhci_submit_common(struct uhci_hcd *uhci, struct urb *urb,\n\t\tstruct uhci_qh *qh)\n{\n\tstruct uhci_td *td;\n\tunsigned long destination, status;\n\tint maxsze = usb_endpoint_maxp(&qh->hep->desc);\n\tint len = urb->transfer_buffer_length;\n\tint this_sg_len;\n\tdma_addr_t data;\n\t__hc32 *plink;\n\tstruct urb_priv *urbp = urb->hcpriv;\n\tunsigned int toggle;\n\tstruct scatterlist  *sg;\n\tint i;\n\n\tif (len < 0)\n\t\treturn -EINVAL;\n\n\t \n\tdestination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);\n\ttoggle = usb_gettoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t usb_pipeout(urb->pipe));\n\n\t \n\tstatus = uhci_maxerr(3);\n\tif (urb->dev->speed == USB_SPEED_LOW)\n\t\tstatus |= TD_CTRL_LS;\n\tif (usb_pipein(urb->pipe))\n\t\tstatus |= TD_CTRL_SPD;\n\n\ti = urb->num_mapped_sgs;\n\tif (len > 0 && i > 0) {\n\t\tsg = urb->sg;\n\t\tdata = sg_dma_address(sg);\n\n\t\t \n\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t} else {\n\t\tsg = NULL;\n\t\tdata = urb->transfer_dma;\n\t\tthis_sg_len = len;\n\t}\n\t \n\tplink = NULL;\n\ttd = qh->dummy_td;\n\tfor (;;) {\t \n\t\tint pktsze = maxsze;\n\n\t\tif (len <= pktsze) {\t\t \n\t\t\tpktsze = len;\n\t\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\n\t\t\t\tstatus &= ~TD_CTRL_SPD;\n\t\t}\n\n\t\tif (plink) {\n\t\t\ttd = uhci_alloc_td(uhci);\n\t\t\tif (!td)\n\t\t\t\tgoto nomem;\n\t\t\t*plink = LINK_TO_TD(uhci, td);\n\t\t}\n\t\tuhci_add_td_to_urbp(td, urbp);\n\t\tuhci_fill_td(uhci, td, status,\n\t\t\t\tdestination | uhci_explen(pktsze) |\n\t\t\t\t\t(toggle << TD_TOKEN_TOGGLE_SHIFT),\n\t\t\t\tdata);\n\t\tplink = &td->link;\n\t\tstatus |= TD_CTRL_ACTIVE;\n\n\t\ttoggle ^= 1;\n\t\tdata += pktsze;\n\t\tthis_sg_len -= pktsze;\n\t\tlen -= maxsze;\n\t\tif (this_sg_len <= 0) {\n\t\t\tif (--i <= 0 || len <= 0)\n\t\t\t\tbreak;\n\t\t\tsg = sg_next(sg);\n\t\t\tdata = sg_dma_address(sg);\n\t\t\tthis_sg_len = min_t(int, sg_dma_len(sg), len);\n\t\t}\n\t}\n\n\t \n\tif ((urb->transfer_flags & URB_ZERO_PACKET) &&\n\t\t\tusb_pipeout(urb->pipe) && len == 0 &&\n\t\t\turb->transfer_buffer_length > 0) {\n\t\ttd = uhci_alloc_td(uhci);\n\t\tif (!td)\n\t\t\tgoto nomem;\n\t\t*plink = LINK_TO_TD(uhci, td);\n\n\t\tuhci_add_td_to_urbp(td, urbp);\n\t\tuhci_fill_td(uhci, td, status,\n\t\t\t\tdestination | uhci_explen(0) |\n\t\t\t\t\t(toggle << TD_TOKEN_TOGGLE_SHIFT),\n\t\t\t\tdata);\n\t\tplink = &td->link;\n\n\t\ttoggle ^= 1;\n\t}\n\n\t \n\ttd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\n\n\t \n\ttd = uhci_alloc_td(uhci);\n\tif (!td)\n\t\tgoto nomem;\n\t*plink = LINK_TO_TD(uhci, td);\n\n\tuhci_fill_td(uhci, td, 0, USB_PID_OUT | uhci_explen(0), 0);\n\twmb();\n\tqh->dummy_td->status |= cpu_to_hc32(uhci, TD_CTRL_ACTIVE);\n\tqh->dummy_td = td;\n\n\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\tusb_pipeout(urb->pipe), toggle);\n\treturn 0;\n\nnomem:\n\t \n\tuhci_remove_td_from_urbp(qh->dummy_td);\n\treturn -ENOMEM;\n}\n\nstatic int uhci_submit_bulk(struct uhci_hcd *uhci, struct urb *urb,\n\t\tstruct uhci_qh *qh)\n{\n\tint ret;\n\n\t \n\tif (urb->dev->speed == USB_SPEED_LOW)\n\t\treturn -EINVAL;\n\n\tif (qh->state != QH_STATE_ACTIVE)\n\t\tqh->skel = SKEL_BULK;\n\tret = uhci_submit_common(uhci, urb, qh);\n\tif (ret == 0)\n\t\tuhci_add_fsbr(uhci, urb);\n\treturn ret;\n}\n\nstatic int uhci_submit_interrupt(struct uhci_hcd *uhci, struct urb *urb,\n\t\tstruct uhci_qh *qh)\n{\n\tint ret;\n\n\t \n\n\tif (!qh->bandwidth_reserved) {\n\t\tint exponent;\n\n\t\t \n\t\tfor (exponent = 7; exponent >= 0; --exponent) {\n\t\t\tif ((1 << exponent) <= urb->interval)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (exponent < 0)\n\t\t\treturn -EINVAL;\n\n\t\t \n\t\tdo {\n\t\t\tqh->period = 1 << exponent;\n\t\t\tqh->skel = SKEL_INDEX(exponent);\n\n\t\t\t \n\t\t\tqh->phase = (qh->period / 2) & (MAX_PHASE - 1);\n\t\t\tret = uhci_check_bandwidth(uhci, qh);\n\t\t} while (ret != 0 && --exponent >= 0);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else if (qh->period > urb->interval)\n\t\treturn -EINVAL;\t\t \n\n\tret = uhci_submit_common(uhci, urb, qh);\n\tif (ret == 0) {\n\t\turb->interval = qh->period;\n\t\tif (!qh->bandwidth_reserved)\n\t\t\tuhci_reserve_bandwidth(uhci, qh);\n\t}\n\treturn ret;\n}\n\n \nstatic int uhci_fixup_short_transfer(struct uhci_hcd *uhci,\n\t\tstruct uhci_qh *qh, struct urb_priv *urbp)\n{\n\tstruct uhci_td *td;\n\tstruct list_head *tmp;\n\tint ret;\n\n\ttd = list_entry(urbp->td_list.prev, struct uhci_td, list);\n\tif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\n\n\t\t \n\t\tWARN_ON(list_empty(&urbp->td_list));\n\t\tqh->element = LINK_TO_TD(uhci, td);\n\t\ttmp = td->list.prev;\n\t\tret = -EINPROGRESS;\n\n\t} else {\n\n\t\t \n\t\tqh->initial_toggle =\n\t\t\tuhci_toggle(td_token(uhci, qh->post_td)) ^ 1;\n\t\tuhci_fixup_toggles(uhci, qh, 1);\n\n\t\tif (list_empty(&urbp->td_list))\n\t\t\ttd = qh->post_td;\n\t\tqh->element = td->link;\n\t\ttmp = urbp->td_list.prev;\n\t\tret = 0;\n\t}\n\n\t \n\twhile (tmp != &urbp->td_list) {\n\t\ttd = list_entry(tmp, struct uhci_td, list);\n\t\ttmp = tmp->prev;\n\n\t\tuhci_remove_td_from_urbp(td);\n\t\tuhci_free_td(uhci, td);\n\t}\n\treturn ret;\n}\n\n \nstatic int uhci_result_common(struct uhci_hcd *uhci, struct urb *urb)\n{\n\tstruct urb_priv *urbp = urb->hcpriv;\n\tstruct uhci_qh *qh = urbp->qh;\n\tstruct uhci_td *td, *tmp;\n\tunsigned status;\n\tint ret = 0;\n\n\tlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\n\t\tunsigned int ctrlstat;\n\t\tint len;\n\n\t\tctrlstat = td_status(uhci, td);\n\t\tstatus = uhci_status_bits(ctrlstat);\n\t\tif (status & TD_CTRL_ACTIVE)\n\t\t\treturn -EINPROGRESS;\n\n\t\tlen = uhci_actual_length(ctrlstat);\n\t\turb->actual_length += len;\n\n\t\tif (status) {\n\t\t\tret = uhci_map_status(status,\n\t\t\t\t\tuhci_packetout(td_token(uhci, td)));\n\t\t\tif ((debug == 1 && ret != -EPIPE) || debug > 1) {\n\t\t\t\t \n\t\t\t\tdev_dbg(&urb->dev->dev,\n\t\t\t\t\t\t\"%s: failed with status %x\\n\",\n\t\t\t\t\t\t__func__, status);\n\n\t\t\t\tif (debug > 1 && errbuf) {\n\t\t\t\t\t \n\t\t\t\t\tuhci_show_qh(uhci, urbp->qh, errbuf,\n\t\t\t\t\t\tERRBUF_LEN - EXTRA_SPACE, 0);\n\t\t\t\t\tlprintk(errbuf);\n\t\t\t\t}\n\t\t\t}\n\n\t\t \n\t\t} else if (len < uhci_expected_length(td_token(uhci, td))) {\n\n\t\t\t \n\t\t\tif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\n\t\t\t\tif (td->list.next != urbp->td_list.prev)\n\t\t\t\t\tret = 1;\n\t\t\t}\n\n\t\t\t \n\t\t\telse if (urb->transfer_flags & URB_SHORT_NOT_OK)\n\t\t\t\tret = -EREMOTEIO;\n\n\t\t\t \n\t\t\telse if (&td->list != urbp->td_list.prev)\n\t\t\t\tret = 1;\n\t\t}\n\n\t\tuhci_remove_td_from_urbp(td);\n\t\tif (qh->post_td)\n\t\t\tuhci_free_td(uhci, qh->post_td);\n\t\tqh->post_td = td;\n\n\t\tif (ret != 0)\n\t\t\tgoto err;\n\t}\n\treturn ret;\n\nerr:\n\tif (ret < 0) {\n\t\t \n\t\tqh->element = UHCI_PTR_TERM(uhci);\n\t\tqh->is_stopped = 1;\n\t\tqh->needs_fixup = (qh->type != USB_ENDPOINT_XFER_CONTROL);\n\t\tqh->initial_toggle = uhci_toggle(td_token(uhci, td)) ^\n\t\t\t\t(ret == -EREMOTEIO);\n\n\t} else\t\t \n\t\tret = uhci_fixup_short_transfer(uhci, qh, urbp);\n\treturn ret;\n}\n\n \nstatic int uhci_submit_isochronous(struct uhci_hcd *uhci, struct urb *urb,\n\t\tstruct uhci_qh *qh)\n{\n\tstruct uhci_td *td = NULL;\t \n\tint i;\n\tunsigned frame, next;\n\tunsigned long destination, status;\n\tstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\n\n\t \n\tif (urb->interval >= UHCI_NUMFRAMES ||\n\t\t\turb->number_of_packets >= UHCI_NUMFRAMES)\n\t\treturn -EFBIG;\n\n\tuhci_get_current_frame_number(uhci);\n\n\t \n\tif (!qh->bandwidth_reserved) {\n\t\tqh->period = urb->interval;\n\t\tqh->phase = -1;\t\t \n\t\ti = uhci_check_bandwidth(uhci, qh);\n\t\tif (i)\n\t\t\treturn i;\n\n\t\t \n\t\tnext = uhci->frame_number + 10;\n\t\tframe = qh->phase;\n\n\t\t \n\t\tframe += (next - frame + qh->period - 1) & -qh->period;\n\n\t} else if (qh->period != urb->interval) {\n\t\treturn -EINVAL;\t\t \n\n\t} else {\n\t\tnext = uhci->frame_number + 1;\n\n\t\t \n\t\tif (list_empty(&qh->queue)) {\n\t\t\tframe = qh->iso_frame;\n\t\t} else {\n\t\t\tstruct urb *lurb;\n\n\t\t\tlurb = list_entry(qh->queue.prev,\n\t\t\t\t\tstruct urb_priv, node)->urb;\n\t\t\tframe = lurb->start_frame +\n\t\t\t\t\tlurb->number_of_packets *\n\t\t\t\t\tlurb->interval;\n\t\t}\n\n\t\t \n\t\tif (!uhci_frame_before_eq(next, frame)) {\n\n\t\t\t \n\t\t\tif (urb->transfer_flags & URB_ISO_ASAP)\n\t\t\t\tframe += (next - frame + qh->period - 1) &\n\t\t\t\t\t\t-qh->period;\n\n\t\t\t \n\t\t\telse if (!uhci_frame_before_eq(next,\n\t\t\t\t\tframe + (urb->number_of_packets - 1) *\n\t\t\t\t\t\tqh->period))\n\t\t\t\tdev_dbg(uhci_dev(uhci), \"iso underrun %p (%u+%u < %u)\\n\",\n\t\t\t\t\t\turb, frame,\n\t\t\t\t\t\t(urb->number_of_packets - 1) *\n\t\t\t\t\t\t\tqh->period,\n\t\t\t\t\t\tnext);\n\t\t}\n\t}\n\n\t \n\tif (uhci_frame_before_eq(uhci->last_iso_frame + UHCI_NUMFRAMES,\n\t\t\tframe + urb->number_of_packets * urb->interval))\n\t\treturn -EFBIG;\n\turb->start_frame = frame;\n\n\tstatus = TD_CTRL_ACTIVE | TD_CTRL_IOS;\n\tdestination = (urb->pipe & PIPE_DEVEP_MASK) | usb_packetid(urb->pipe);\n\n\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\ttd = uhci_alloc_td(uhci);\n\t\tif (!td)\n\t\t\treturn -ENOMEM;\n\n\t\tuhci_add_td_to_urbp(td, urbp);\n\t\tuhci_fill_td(uhci, td, status, destination |\n\t\t\t\tuhci_explen(urb->iso_frame_desc[i].length),\n\t\t\t\turb->transfer_dma +\n\t\t\t\t\turb->iso_frame_desc[i].offset);\n\t}\n\n\t \n\ttd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\n\n\t \n\tframe = urb->start_frame;\n\tlist_for_each_entry(td, &urbp->td_list, list) {\n\t\tuhci_insert_td_in_frame_list(uhci, td, frame);\n\t\tframe += qh->period;\n\t}\n\n\tif (list_empty(&qh->queue)) {\n\t\tqh->iso_packet_desc = &urb->iso_frame_desc[0];\n\t\tqh->iso_frame = urb->start_frame;\n\t}\n\n\tqh->skel = SKEL_ISO;\n\tif (!qh->bandwidth_reserved)\n\t\tuhci_reserve_bandwidth(uhci, qh);\n\treturn 0;\n}\n\nstatic int uhci_result_isochronous(struct uhci_hcd *uhci, struct urb *urb)\n{\n\tstruct uhci_td *td, *tmp;\n\tstruct urb_priv *urbp = urb->hcpriv;\n\tstruct uhci_qh *qh = urbp->qh;\n\n\tlist_for_each_entry_safe(td, tmp, &urbp->td_list, list) {\n\t\tunsigned int ctrlstat;\n\t\tint status;\n\t\tint actlength;\n\n\t\tif (uhci_frame_before_eq(uhci->cur_iso_frame, qh->iso_frame))\n\t\t\treturn -EINPROGRESS;\n\n\t\tuhci_remove_tds_from_frame(uhci, qh->iso_frame);\n\n\t\tctrlstat = td_status(uhci, td);\n\t\tif (ctrlstat & TD_CTRL_ACTIVE) {\n\t\t\tstatus = -EXDEV;\t \n\t\t} else {\n\t\t\tstatus = uhci_map_status(uhci_status_bits(ctrlstat),\n\t\t\t\t\tusb_pipeout(urb->pipe));\n\t\t\tactlength = uhci_actual_length(ctrlstat);\n\n\t\t\turb->actual_length += actlength;\n\t\t\tqh->iso_packet_desc->actual_length = actlength;\n\t\t\tqh->iso_packet_desc->status = status;\n\t\t}\n\t\tif (status)\n\t\t\turb->error_count++;\n\n\t\tuhci_remove_td_from_urbp(td);\n\t\tuhci_free_td(uhci, td);\n\t\tqh->iso_frame += qh->period;\n\t\t++qh->iso_packet_desc;\n\t}\n\treturn 0;\n}\n\nstatic int uhci_urb_enqueue(struct usb_hcd *hcd,\n\t\tstruct urb *urb, gfp_t mem_flags)\n{\n\tint ret;\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned long flags;\n\tstruct urb_priv *urbp;\n\tstruct uhci_qh *qh;\n\n\tspin_lock_irqsave(&uhci->lock, flags);\n\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret)\n\t\tgoto done_not_linked;\n\n\tret = -ENOMEM;\n\turbp = uhci_alloc_urb_priv(uhci, urb);\n\tif (!urbp)\n\t\tgoto done;\n\n\tif (urb->ep->hcpriv)\n\t\tqh = urb->ep->hcpriv;\n\telse {\n\t\tqh = uhci_alloc_qh(uhci, urb->dev, urb->ep);\n\t\tif (!qh)\n\t\t\tgoto err_no_qh;\n\t}\n\turbp->qh = qh;\n\n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_CONTROL:\n\t\tret = uhci_submit_control(uhci, urb, qh);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_BULK:\n\t\tret = uhci_submit_bulk(uhci, urb, qh);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_INT:\n\t\tret = uhci_submit_interrupt(uhci, urb, qh);\n\t\tbreak;\n\tcase USB_ENDPOINT_XFER_ISOC:\n\t\turb->error_count = 0;\n\t\tret = uhci_submit_isochronous(uhci, urb, qh);\n\t\tbreak;\n\t}\n\tif (ret != 0)\n\t\tgoto err_submit_failed;\n\n\t \n\tlist_add_tail(&urbp->node, &qh->queue);\n\n\t \n\tif (qh->queue.next == &urbp->node && !qh->is_stopped) {\n\t\tuhci_activate_qh(uhci, qh);\n\t\tuhci_urbp_wants_fsbr(uhci, urbp);\n\t}\n\tgoto done;\n\nerr_submit_failed:\n\tif (qh->state == QH_STATE_IDLE)\n\t\tuhci_make_qh_idle(uhci, qh);\t \nerr_no_qh:\n\tuhci_free_urb_priv(uhci, urbp);\ndone:\n\tif (ret)\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\ndone_not_linked:\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n\treturn ret;\n}\n\nstatic int uhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned long flags;\n\tstruct uhci_qh *qh;\n\tint rc;\n\n\tspin_lock_irqsave(&uhci->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\tqh = ((struct urb_priv *) urb->hcpriv)->qh;\n\n\t \n\tif (qh->type == USB_ENDPOINT_XFER_ISOC) {\n\t\tuhci_unlink_isochronous_tds(uhci, urb);\n\t\tmb();\n\n\t\t \n\t\tuhci_get_current_frame_number(uhci);\n\t\tif (uhci_frame_before_eq(urb->start_frame, uhci->frame_number))\n\t\t\tqh->unlink_frame = uhci->frame_number;\n\t}\n\n\tuhci_unlink_qh(uhci, qh);\n\ndone:\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n\treturn rc;\n}\n\n \nstatic void uhci_giveback_urb(struct uhci_hcd *uhci, struct uhci_qh *qh,\n\t\tstruct urb *urb, int status)\n__releases(uhci->lock)\n__acquires(uhci->lock)\n{\n\tstruct urb_priv *urbp = (struct urb_priv *) urb->hcpriv;\n\n\tif (qh->type == USB_ENDPOINT_XFER_CONTROL) {\n\n\t\t \n\t\turb->actual_length -= min_t(u32, 8, urb->actual_length);\n\t}\n\n\t \n\telse if (qh->type == USB_ENDPOINT_XFER_ISOC &&\n\t\t\turbp->node.prev == &qh->queue &&\n\t\t\turbp->node.next != &qh->queue) {\n\t\tstruct urb *nurb = list_entry(urbp->node.next,\n\t\t\t\tstruct urb_priv, node)->urb;\n\n\t\tqh->iso_packet_desc = &nurb->iso_frame_desc[0];\n\t\tqh->iso_frame = nurb->start_frame;\n\t}\n\n\t \n\tlist_del_init(&urbp->node);\n\tif (list_empty(&qh->queue) && qh->needs_fixup) {\n\t\tusb_settoggle(urb->dev, usb_pipeendpoint(urb->pipe),\n\t\t\t\tusb_pipeout(urb->pipe), qh->initial_toggle);\n\t\tqh->needs_fixup = 0;\n\t}\n\n\tuhci_free_urb_priv(uhci, urbp);\n\tusb_hcd_unlink_urb_from_ep(uhci_to_hcd(uhci), urb);\n\n\tspin_unlock(&uhci->lock);\n\tusb_hcd_giveback_urb(uhci_to_hcd(uhci), urb, status);\n\tspin_lock(&uhci->lock);\n\n\t \n\tif (list_empty(&qh->queue)) {\n\t\tuhci_unlink_qh(uhci, qh);\n\t\tif (qh->bandwidth_reserved)\n\t\t\tuhci_release_bandwidth(uhci, qh);\n\t}\n}\n\n \n#define QH_FINISHED_UNLINKING(qh)\t\t\t\\\n\t\t(qh->state == QH_STATE_UNLINKING &&\t\\\n\t\tuhci->frame_number + uhci->is_stopped != qh->unlink_frame)\n\nstatic void uhci_scan_qh(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct urb_priv *urbp;\n\tstruct urb *urb;\n\tint status;\n\n\twhile (!list_empty(&qh->queue)) {\n\t\turbp = list_entry(qh->queue.next, struct urb_priv, node);\n\t\turb = urbp->urb;\n\n\t\tif (qh->type == USB_ENDPOINT_XFER_ISOC)\n\t\t\tstatus = uhci_result_isochronous(uhci, urb);\n\t\telse\n\t\t\tstatus = uhci_result_common(uhci, urb);\n\t\tif (status == -EINPROGRESS)\n\t\t\tbreak;\n\n\t\t \n\t\tif (urb->unlinked) {\n\t\t\tif (QH_FINISHED_UNLINKING(qh))\n\t\t\t\tqh->is_stopped = 1;\n\t\t\telse if (!qh->is_stopped)\n\t\t\t\treturn;\n\t\t}\n\n\t\tuhci_giveback_urb(uhci, qh, urb, status);\n\t\tif (status < 0)\n\t\t\tbreak;\n\t}\n\n\t \n\tif (QH_FINISHED_UNLINKING(qh))\n\t\tqh->is_stopped = 1;\n\telse if (!qh->is_stopped)\n\t\treturn;\n\n\t \nrestart:\n\tlist_for_each_entry(urbp, &qh->queue, node) {\n\t\turb = urbp->urb;\n\t\tif (urb->unlinked) {\n\n\t\t\t \n\t\t\tif (!uhci_cleanup_queue(uhci, qh, urb)) {\n\t\t\t\tqh->is_stopped = 0;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tuhci_giveback_urb(uhci, qh, urb, 0);\n\t\t\tgoto restart;\n\t\t}\n\t}\n\tqh->is_stopped = 0;\n\n\t \n\tif (!list_empty(&qh->queue)) {\n\t\tif (qh->needs_fixup)\n\t\t\tuhci_fixup_toggles(uhci, qh, 0);\n\n\t\t \n\t\turbp = list_entry(qh->queue.next, struct urb_priv, node);\n\t\tif (urbp->fsbr && qh->wait_expired) {\n\t\t\tstruct uhci_td *td = list_entry(urbp->td_list.next,\n\t\t\t\t\tstruct uhci_td, list);\n\n\t\t\ttd->status |= cpu_to_hc32(uhci, TD_CTRL_IOC);\n\t\t}\n\n\t\tuhci_activate_qh(uhci, qh);\n\t}\n\n\t \n\telse if (QH_FINISHED_UNLINKING(qh))\n\t\tuhci_make_qh_idle(uhci, qh);\n}\n\n \nstatic int uhci_advance_check(struct uhci_hcd *uhci, struct uhci_qh *qh)\n{\n\tstruct urb_priv *urbp = NULL;\n\tstruct uhci_td *td;\n\tint ret = 1;\n\tunsigned status;\n\n\tif (qh->type == USB_ENDPOINT_XFER_ISOC)\n\t\tgoto done;\n\n\t \n\tif (qh->state != QH_STATE_ACTIVE) {\n\t\turbp = NULL;\n\t\tstatus = 0;\n\n\t} else {\n\t\turbp = list_entry(qh->queue.next, struct urb_priv, node);\n\t\ttd = list_entry(urbp->td_list.next, struct uhci_td, list);\n\t\tstatus = td_status(uhci, td);\n\t\tif (!(status & TD_CTRL_ACTIVE)) {\n\n\t\t\t \n\t\t\tqh->wait_expired = 0;\n\t\t\tqh->advance_jiffies = jiffies;\n\t\t\tgoto done;\n\t\t}\n\t\tret = uhci->is_stopped;\n\t}\n\n\t \n\tif (qh->wait_expired)\n\t\tgoto done;\n\n\tif (time_after(jiffies, qh->advance_jiffies + QH_WAIT_TIMEOUT)) {\n\n\t\t \n\t\tif (qh->post_td && qh_element(qh) ==\n\t\t\tLINK_TO_TD(uhci, qh->post_td)) {\n\t\t\tqh->element = qh->post_td->link;\n\t\t\tqh->advance_jiffies = jiffies;\n\t\t\tret = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\tqh->wait_expired = 1;\n\n\t\t \n\t\tif (urbp && urbp->fsbr && !(status & TD_CTRL_IOC))\n\t\t\tuhci_unlink_qh(uhci, qh);\n\n\t} else {\n\t\t \n\t\tif (urbp)\n\t\t\tuhci_urbp_wants_fsbr(uhci, urbp);\n\t}\n\ndone:\n\treturn ret;\n}\n\n \nstatic void uhci_scan_schedule(struct uhci_hcd *uhci)\n{\n\tint i;\n\tstruct uhci_qh *qh;\n\n\t \n\tif (uhci->scan_in_progress) {\n\t\tuhci->need_rescan = 1;\n\t\treturn;\n\t}\n\tuhci->scan_in_progress = 1;\nrescan:\n\tuhci->need_rescan = 0;\n\tuhci->fsbr_is_wanted = 0;\n\n\tuhci_clear_next_interrupt(uhci);\n\tuhci_get_current_frame_number(uhci);\n\tuhci->cur_iso_frame = uhci->frame_number;\n\n\t \n\tfor (i = 0; i < UHCI_NUM_SKELQH - 1; ++i) {\n\t\tuhci->next_qh = list_entry(uhci->skelqh[i]->node.next,\n\t\t\t\tstruct uhci_qh, node);\n\t\twhile ((qh = uhci->next_qh) != uhci->skelqh[i]) {\n\t\t\tuhci->next_qh = list_entry(qh->node.next,\n\t\t\t\t\tstruct uhci_qh, node);\n\n\t\t\tif (uhci_advance_check(uhci, qh)) {\n\t\t\t\tuhci_scan_qh(uhci, qh);\n\t\t\t\tif (qh->state == QH_STATE_ACTIVE) {\n\t\t\t\t\tuhci_urbp_wants_fsbr(uhci,\n\tlist_entry(qh->queue.next, struct urb_priv, node));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tuhci->last_iso_frame = uhci->cur_iso_frame;\n\tif (uhci->need_rescan)\n\t\tgoto rescan;\n\tuhci->scan_in_progress = 0;\n\n\tif (uhci->fsbr_is_on && !uhci->fsbr_is_wanted &&\n\t\t\t!uhci->fsbr_expiring) {\n\t\tuhci->fsbr_expiring = 1;\n\t\tmod_timer(&uhci->fsbr_timer, jiffies + FSBR_OFF_DELAY);\n\t}\n\n\tif (list_empty(&uhci->skel_unlink_qh->node))\n\t\tuhci_clear_next_interrupt(uhci);\n\telse\n\t\tuhci_set_next_interrupt(uhci);\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}