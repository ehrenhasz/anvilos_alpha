{
  "module_name": "isp116x-hcd.c",
  "hash_id": "f4c14ca5cd8065973357ab1b636e401deb4e19dc09598abedb767ed5ac123ae8",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/isp116x-hcd.c",
  "human_readable_source": "\n \n\n \n\n \n#define USE_PLATFORM_DELAY\n \n\n \n \n \n \n \n \n\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/usb.h>\n#include <linux/usb/isp116x.h>\n#include <linux/usb/hcd.h>\n#include <linux/platform_device.h>\n\n#include <asm/io.h>\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n\n#include \"isp116x.h\"\n\n#define DRIVER_VERSION\t\"03 Nov 2005\"\n#define DRIVER_DESC\t\"ISP116x USB Host Controller Driver\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char hcd_name[] = \"isp116x-hcd\";\n\n \n\n \nstatic void write_ptddata_to_fifo(struct isp116x *isp116x, void *buf, int len)\n{\n\tu8 *dp = (u8 *) buf;\n\tu16 *dp2 = (u16 *) buf;\n\tu16 w;\n\tint quot = len % 4;\n\n\t \n\t \n\t \n\n\tif ((unsigned long)dp2 & 1) {\n\t\t \n\t\tfor (; len > 1; len -= 2) {\n\t\t\tw = *dp++;\n\t\t\tw |= *dp++ << 8;\n\t\t\tisp116x_raw_write_data16(isp116x, w);\n\t\t}\n\t\tif (len)\n\t\t\tisp116x_write_data16(isp116x, (u16) * dp);\n\t} else {\n\t\t \n\t\tfor (; len > 1; len -= 2) {\n\t\t\t \n\t\t\tisp116x_raw_write_data16(isp116x, cpu_to_le16(*dp2++));\n\t\t}\n\n\t\tif (len)\n\t\t\tisp116x_write_data16(isp116x, 0xff & *((u8 *) dp2));\n\t}\n\tif (quot == 1 || quot == 2)\n\t\tisp116x_raw_write_data16(isp116x, 0);\n}\n\n \nstatic void read_ptddata_from_fifo(struct isp116x *isp116x, void *buf, int len)\n{\n\tu8 *dp = (u8 *) buf;\n\tu16 *dp2 = (u16 *) buf;\n\tu16 w;\n\tint quot = len % 4;\n\n\t \n\t \n\t \n\n\tif ((unsigned long)dp2 & 1) {\n\t\t \n\t\tfor (; len > 1; len -= 2) {\n\t\t\tw = isp116x_raw_read_data16(isp116x);\n\t\t\t*dp++ = w & 0xff;\n\t\t\t*dp++ = (w >> 8) & 0xff;\n\t\t}\n\n\t\tif (len)\n\t\t\t*dp = 0xff & isp116x_read_data16(isp116x);\n\t} else {\n\t\t \n\t\tfor (; len > 1; len -= 2) {\n\t\t\t \n\t\t\t*dp2++ = le16_to_cpu(isp116x_raw_read_data16(isp116x));\n\t\t}\n\n\t\tif (len)\n\t\t\t*(u8 *) dp2 = 0xff & isp116x_read_data16(isp116x);\n\t}\n\tif (quot == 1 || quot == 2)\n\t\tisp116x_raw_read_data16(isp116x);\n}\n\n \nstatic void pack_fifo(struct isp116x *isp116x)\n{\n\tstruct isp116x_ep *ep;\n\tstruct ptd *ptd;\n\tint buflen = isp116x->atl_last_dir == PTD_DIR_IN\n\t    ? isp116x->atl_bufshrt : isp116x->atl_buflen;\n\n\tisp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);\n\tisp116x_write_reg16(isp116x, HCXFERCTR, buflen);\n\tisp116x_write_addr(isp116x, HCATLPORT | ISP116x_WRITE_OFFSET);\n\tfor (ep = isp116x->atl_active; ep; ep = ep->active) {\n\t\tptd = &ep->ptd;\n\t\tdump_ptd(ptd);\n\t\tdump_ptd_out_data(ptd, ep->data);\n\t\tisp116x_write_data16(isp116x, ptd->count);\n\t\tisp116x_write_data16(isp116x, ptd->mps);\n\t\tisp116x_write_data16(isp116x, ptd->len);\n\t\tisp116x_write_data16(isp116x, ptd->faddr);\n\t\tbuflen -= sizeof(struct ptd);\n\t\t \n\t\tif (ep->active || (isp116x->atl_last_dir != PTD_DIR_IN)) {\n\t\t\twrite_ptddata_to_fifo(isp116x, ep->data, ep->length);\n\t\t\tbuflen -= ALIGN(ep->length, 4);\n\t\t}\n\t}\n\tBUG_ON(buflen);\n}\n\n \nstatic void unpack_fifo(struct isp116x *isp116x)\n{\n\tstruct isp116x_ep *ep;\n\tstruct ptd *ptd;\n\tint buflen = isp116x->atl_last_dir == PTD_DIR_IN\n\t    ? isp116x->atl_buflen : isp116x->atl_bufshrt;\n\n\tisp116x_write_reg16(isp116x, HCuPINT, HCuPINT_AIIEOT);\n\tisp116x_write_reg16(isp116x, HCXFERCTR, buflen);\n\tisp116x_write_addr(isp116x, HCATLPORT);\n\tfor (ep = isp116x->atl_active; ep; ep = ep->active) {\n\t\tptd = &ep->ptd;\n\t\tptd->count = isp116x_read_data16(isp116x);\n\t\tptd->mps = isp116x_read_data16(isp116x);\n\t\tptd->len = isp116x_read_data16(isp116x);\n\t\tptd->faddr = isp116x_read_data16(isp116x);\n\t\tbuflen -= sizeof(struct ptd);\n\t\t \n\t\tif (ep->active || (isp116x->atl_last_dir == PTD_DIR_IN)) {\n\t\t\tread_ptddata_from_fifo(isp116x, ep->data, ep->length);\n\t\t\tbuflen -= ALIGN(ep->length, 4);\n\t\t}\n\t\tdump_ptd(ptd);\n\t\tdump_ptd_in_data(ptd, ep->data);\n\t}\n\tBUG_ON(buflen);\n}\n\n \n\n \nstatic void preproc_atl_queue(struct isp116x *isp116x)\n{\n\tstruct isp116x_ep *ep;\n\tstruct urb *urb;\n\tstruct ptd *ptd;\n\tu16 len;\n\n\tfor (ep = isp116x->atl_active; ep; ep = ep->active) {\n\t\tu16 toggle = 0, dir = PTD_DIR_SETUP;\n\n\t\tBUG_ON(list_empty(&ep->hep->urb_list));\n\t\turb = container_of(ep->hep->urb_list.next,\n\t\t\t\t   struct urb, urb_list);\n\t\tptd = &ep->ptd;\n\t\tlen = ep->length;\n\t\tep->data = (unsigned char *)urb->transfer_buffer\n\t\t    + urb->actual_length;\n\n\t\tswitch (ep->nextpid) {\n\t\tcase USB_PID_IN:\n\t\t\ttoggle = usb_gettoggle(urb->dev, ep->epnum, 0);\n\t\t\tdir = PTD_DIR_IN;\n\t\t\tbreak;\n\t\tcase USB_PID_OUT:\n\t\t\ttoggle = usb_gettoggle(urb->dev, ep->epnum, 1);\n\t\t\tdir = PTD_DIR_OUT;\n\t\t\tbreak;\n\t\tcase USB_PID_SETUP:\n\t\t\tlen = sizeof(struct usb_ctrlrequest);\n\t\t\tep->data = urb->setup_packet;\n\t\t\tbreak;\n\t\tcase USB_PID_ACK:\n\t\t\ttoggle = 1;\n\t\t\tlen = 0;\n\t\t\tdir = (urb->transfer_buffer_length\n\t\t\t       && usb_pipein(urb->pipe))\n\t\t\t    ? PTD_DIR_OUT : PTD_DIR_IN;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tERR(\"%s %d: ep->nextpid %d\\n\", __func__, __LINE__,\n\t\t\t    ep->nextpid);\n\t\t\tBUG();\n\t\t}\n\n\t\tptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK | PTD_TOGGLE(toggle);\n\t\tptd->mps = PTD_MPS(ep->maxpacket)\n\t\t    | PTD_SPD(urb->dev->speed == USB_SPEED_LOW)\n\t\t    | PTD_EP(ep->epnum);\n\t\tptd->len = PTD_LEN(len) | PTD_DIR(dir);\n\t\tptd->faddr = PTD_FA(usb_pipedevice(urb->pipe));\n\t\tif (!ep->active) {\n\t\t\tptd->mps |= PTD_LAST_MSK;\n\t\t\tisp116x->atl_last_dir = dir;\n\t\t}\n\t\tisp116x->atl_bufshrt = sizeof(struct ptd) + isp116x->atl_buflen;\n\t\tisp116x->atl_buflen = isp116x->atl_bufshrt + ALIGN(len, 4);\n\t}\n}\n\n \nstatic void finish_request(struct isp116x *isp116x, struct isp116x_ep *ep,\n\t\t\t   struct urb *urb, int status)\n__releases(isp116x->lock) __acquires(isp116x->lock)\n{\n\tunsigned i;\n\n\tep->error_count = 0;\n\n\tif (usb_pipecontrol(urb->pipe))\n\t\tep->nextpid = USB_PID_SETUP;\n\n\turb_dbg(urb, \"Finish\");\n\n\tusb_hcd_unlink_urb_from_ep(isp116x_to_hcd(isp116x), urb);\n\tspin_unlock(&isp116x->lock);\n\tusb_hcd_giveback_urb(isp116x_to_hcd(isp116x), urb, status);\n\tspin_lock(&isp116x->lock);\n\n\t \n\tif (!list_empty(&ep->hep->urb_list))\n\t\treturn;\n\n\t \n\tif (!list_empty(&ep->schedule)) {\n\t\tlist_del_init(&ep->schedule);\n\t\treturn;\n\t}\n\n\t \n\tDBG(\"deschedule qh%d/%p branch %d\\n\", ep->period, ep, ep->branch);\n\tfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\n\t\tstruct isp116x_ep *temp;\n\t\tstruct isp116x_ep **prev = &isp116x->periodic[i];\n\n\t\twhile (*prev && ((temp = *prev) != ep))\n\t\t\tprev = &temp->next;\n\t\tif (*prev)\n\t\t\t*prev = ep->next;\n\t\tisp116x->load[i] -= ep->load;\n\t}\n\tep->branch = PERIODIC_SIZE;\n\tisp116x_to_hcd(isp116x)->self.bandwidth_allocated -=\n\t    ep->load / ep->period;\n\n\t \n\tif (!--isp116x->periodic_count) {\n\t\tisp116x->irqenb &= ~HCuPINT_SOF;\n\t\tisp116x->irqenb |= HCuPINT_ATL;\n\t}\n}\n\n \nstatic void postproc_atl_queue(struct isp116x *isp116x)\n{\n\tstruct isp116x_ep *ep;\n\tstruct urb *urb;\n\tstruct usb_device *udev;\n\tstruct ptd *ptd;\n\tint short_not_ok;\n\tint status;\n\tu8 cc;\n\n\tfor (ep = isp116x->atl_active; ep; ep = ep->active) {\n\t\tBUG_ON(list_empty(&ep->hep->urb_list));\n\t\turb =\n\t\t    container_of(ep->hep->urb_list.next, struct urb, urb_list);\n\t\tudev = urb->dev;\n\t\tptd = &ep->ptd;\n\t\tcc = PTD_GET_CC(ptd);\n\t\tshort_not_ok = 1;\n\t\tstatus = -EINPROGRESS;\n\n\t\t \n\t\tif (cc == TD_DATAUNDERRUN) {\n\t\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK) ||\n\t\t\t\t\tusb_pipecontrol(urb->pipe)) {\n\t\t\t\tDBG(\"Allowed or control data underrun\\n\");\n\t\t\t\tcc = TD_CC_NOERROR;\n\t\t\t\tshort_not_ok = 0;\n\t\t\t} else {\n\t\t\t\tep->error_count = 1;\n\t\t\t\tusb_settoggle(udev, ep->epnum,\n\t\t\t\t\t      ep->nextpid == USB_PID_OUT,\n\t\t\t\t\t      PTD_GET_TOGGLE(ptd));\n\t\t\t\turb->actual_length += PTD_GET_COUNT(ptd);\n\t\t\t\tstatus = cc_to_error[TD_DATAUNDERRUN];\n\t\t\t\tgoto done;\n\t\t\t}\n\t\t}\n\n\t\tif (cc != TD_CC_NOERROR && cc != TD_NOTACCESSED\n\t\t    && (++ep->error_count >= 3 || cc == TD_CC_STALL\n\t\t\t|| cc == TD_DATAOVERRUN)) {\n\t\t\tstatus = cc_to_error[cc];\n\t\t\tif (ep->nextpid == USB_PID_ACK)\n\t\t\t\tep->nextpid = 0;\n\t\t\tgoto done;\n\t\t}\n\t\t \n\t\tif (usb_pipeint(urb->pipe) && !PTD_GET_LEN(ptd)) {\n\t\t\tstatus = 0;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (ep->error_count\n\t\t    && (cc == TD_CC_NOERROR || cc == TD_NOTACCESSED))\n\t\t\tep->error_count = 0;\n\n\t\t \n\t\tif (ep->nextpid == USB_PID_OUT)\n\t\t\tusb_settoggle(udev, ep->epnum, 1, PTD_GET_TOGGLE(ptd)\n\t\t\t\t      ^ (ep->error_count > 0));\n\t\telse if (ep->nextpid == USB_PID_IN)\n\t\t\tusb_settoggle(udev, ep->epnum, 0, PTD_GET_TOGGLE(ptd)\n\t\t\t\t      ^ (ep->error_count > 0));\n\n\t\tswitch (ep->nextpid) {\n\t\tcase USB_PID_IN:\n\t\tcase USB_PID_OUT:\n\t\t\turb->actual_length += PTD_GET_COUNT(ptd);\n\t\t\tif (PTD_GET_ACTIVE(ptd)\n\t\t\t    || (cc != TD_CC_NOERROR && cc < 0x0E))\n\t\t\t\tbreak;\n\t\t\tif (urb->transfer_buffer_length != urb->actual_length) {\n\t\t\t\tif (short_not_ok)\n\t\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tif (urb->transfer_flags & URB_ZERO_PACKET\n\t\t\t\t    && ep->nextpid == USB_PID_OUT\n\t\t\t\t    && !(PTD_GET_COUNT(ptd) % ep->maxpacket)) {\n\t\t\t\t\tDBG(\"Zero packet requested\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t \n\t\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\telse\n\t\t\t\tstatus = 0;\n\t\t\tbreak;\n\t\tcase USB_PID_SETUP:\n\t\t\tif (PTD_GET_ACTIVE(ptd)\n\t\t\t    || (cc != TD_CC_NOERROR && cc < 0x0E))\n\t\t\t\tbreak;\n\t\t\tif (urb->transfer_buffer_length == urb->actual_length)\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\telse if (usb_pipeout(urb->pipe)) {\n\t\t\t\tusb_settoggle(udev, 0, 1, 1);\n\t\t\t\tep->nextpid = USB_PID_OUT;\n\t\t\t} else {\n\t\t\t\tusb_settoggle(udev, 0, 0, 1);\n\t\t\t\tep->nextpid = USB_PID_IN;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PID_ACK:\n\t\t\tif (PTD_GET_ACTIVE(ptd)\n\t\t\t    || (cc != TD_CC_NOERROR && cc < 0x0E))\n\t\t\t\tbreak;\n\t\t\tstatus = 0;\n\t\t\tep->nextpid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n done:\n\t\tif (status != -EINPROGRESS || urb->unlinked)\n\t\t\tfinish_request(isp116x, ep, urb, status);\n\t}\n}\n\n \nstatic void start_atl_transfers(struct isp116x *isp116x)\n{\n\tstruct isp116x_ep *last_ep = NULL, *ep;\n\tstruct urb *urb;\n\tu16 load = 0;\n\tint len, index, speed, byte_time;\n\n\tif (atomic_read(&isp116x->atl_finishing))\n\t\treturn;\n\n\tif (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state))\n\t\treturn;\n\n\t \n\tif (isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_FULL)\n\t\treturn;\n\n\tisp116x->atl_active = NULL;\n\tisp116x->atl_buflen = isp116x->atl_bufshrt = 0;\n\n\t \n\tif (isp116x->periodic_count) {\n\t\tisp116x->fmindex = index =\n\t\t    (isp116x->fmindex + 1) & (PERIODIC_SIZE - 1);\n\t\tload = isp116x->load[index];\n\t\tif (load) {\n\t\t\t \n\t\t\tisp116x->atl_active = last_ep =\n\t\t\t    isp116x->periodic[index];\n\t\t\twhile (last_ep->next)\n\t\t\t\tlast_ep = (last_ep->active = last_ep->next);\n\t\t\tlast_ep->active = NULL;\n\t\t}\n\t}\n\n\t \n\tlist_for_each_entry(ep, &isp116x->async, schedule) {\n\t\turb = container_of(ep->hep->urb_list.next,\n\t\t\t\t   struct urb, urb_list);\n\t\tspeed = urb->dev->speed;\n\t\tbyte_time = speed == USB_SPEED_LOW\n\t\t    ? BYTE_TIME_LOWSPEED : BYTE_TIME_FULLSPEED;\n\n\t\tif (ep->nextpid == USB_PID_SETUP) {\n\t\t\tlen = sizeof(struct usb_ctrlrequest);\n\t\t} else if (ep->nextpid == USB_PID_ACK) {\n\t\t\tlen = 0;\n\t\t} else {\n\t\t\t \n\t\t\tlen = (MAX_LOAD_LIMIT - load) / byte_time;\n\n\t\t\t \n\t\t\tlen = min(len, speed == USB_SPEED_LOW ?\n\t\t\t\t  MAX_TRANSFER_SIZE_LOWSPEED :\n\t\t\t\t  MAX_TRANSFER_SIZE_FULLSPEED);\n\n\t\t\t \n\t\t\tif (len <\n\t\t\t    (urb->transfer_buffer_length -\n\t\t\t     urb->actual_length)) {\n\t\t\t\tlen -= len % ep->maxpacket;\n\t\t\t\tif (!len)\n\t\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\tlen = urb->transfer_buffer_length -\n\t\t\t\t    urb->actual_length;\n\t\t\tBUG_ON(len < 0);\n\t\t}\n\n\t\tload += len * byte_time;\n\t\tif (load > MAX_LOAD_LIMIT)\n\t\t\tbreak;\n\n\t\tep->active = NULL;\n\t\tep->length = len;\n\t\tif (last_ep)\n\t\t\tlast_ep->active = ep;\n\t\telse\n\t\t\tisp116x->atl_active = ep;\n\t\tlast_ep = ep;\n\t}\n\n\t \n\tif ((&isp116x->async)->next != (&isp116x->async)->prev)\n\t\tlist_move(&isp116x->async, (&isp116x->async)->next);\n\n\tif (isp116x->atl_active) {\n\t\tpreproc_atl_queue(isp116x);\n\t\tpack_fifo(isp116x);\n\t}\n}\n\n \nstatic void finish_atl_transfers(struct isp116x *isp116x)\n{\n\tif (!isp116x->atl_active)\n\t\treturn;\n\t \n\tif (!(isp116x_read_reg16(isp116x, HCBUFSTAT) & HCBUFSTAT_ATL_DONE))\n\t\treturn;\n\n\tatomic_inc(&isp116x->atl_finishing);\n\tunpack_fifo(isp116x);\n\tpostproc_atl_queue(isp116x);\n\tatomic_dec(&isp116x->atl_finishing);\n}\n\nstatic irqreturn_t isp116x_irq(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tu16 irqstat;\n\tirqreturn_t ret = IRQ_NONE;\n\n\tspin_lock(&isp116x->lock);\n\tisp116x_write_reg16(isp116x, HCuPINTENB, 0);\n\tirqstat = isp116x_read_reg16(isp116x, HCuPINT);\n\tisp116x_write_reg16(isp116x, HCuPINT, irqstat);\n\n\tif (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {\n\t\tret = IRQ_HANDLED;\n\t\tfinish_atl_transfers(isp116x);\n\t}\n\n\tif (irqstat & HCuPINT_OPR) {\n\t\tu32 intstat = isp116x_read_reg32(isp116x, HCINTSTAT);\n\t\tisp116x_write_reg32(isp116x, HCINTSTAT, intstat);\n\t\tif (intstat & HCINT_UE) {\n\t\t\tERR(\"Unrecoverable error, HC is dead!\\n\");\n\t\t\t \n\t\t\thcd->state = HC_STATE_HALT;\n\t\t\tusb_hc_died(hcd);\n\t\t\tret = IRQ_HANDLED;\n\t\t\tgoto done;\n\t\t}\n\t\tif (intstat & HCINT_RHSC)\n\t\t\t \n\t\t\tmod_timer(&hcd->rh_timer, jiffies\n\t\t\t\t  + msecs_to_jiffies(20) + 1);\n\t\tif (intstat & HCINT_RD) {\n\t\t\tDBG(\"---- remote wakeup\\n\");\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t\t}\n\t\tirqstat &= ~HCuPINT_OPR;\n\t\tret = IRQ_HANDLED;\n\t}\n\n\tif (irqstat & (HCuPINT_ATL | HCuPINT_SOF)) {\n\t\tstart_atl_transfers(isp116x);\n\t}\n\n\tisp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);\n      done:\n\tspin_unlock(&isp116x->lock);\n\treturn ret;\n}\n\n \n\n \n\n \n#define\tMAX_PERIODIC_LOAD\t600\nstatic int balance(struct isp116x *isp116x, u16 period, u16 load)\n{\n\tint i, branch = -ENOSPC;\n\n\t \n\tfor (i = 0; i < period; i++) {\n\t\tif (branch < 0 || isp116x->load[branch] > isp116x->load[i]) {\n\t\t\tint j;\n\n\t\t\tfor (j = i; j < PERIODIC_SIZE; j += period) {\n\t\t\t\tif ((isp116x->load[j] + load)\n\t\t\t\t    > MAX_PERIODIC_LOAD)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < PERIODIC_SIZE)\n\t\t\t\tcontinue;\n\t\t\tbranch = i;\n\t\t}\n\t}\n\treturn branch;\n}\n\n \n\n \n\nstatic int isp116x_urb_enqueue(struct usb_hcd *hcd,\n\t\t\t       struct urb *urb,\n\t\t\t       gfp_t mem_flags)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tstruct usb_device *udev = urb->dev;\n\tunsigned int pipe = urb->pipe;\n\tint is_out = !usb_pipein(pipe);\n\tint type = usb_pipetype(pipe);\n\tint epnum = usb_pipeendpoint(pipe);\n\tstruct usb_host_endpoint *hep = urb->ep;\n\tstruct isp116x_ep *ep = NULL;\n\tunsigned long flags;\n\tint i;\n\tint ret = 0;\n\n\turb_dbg(urb, \"Enqueue\");\n\n\tif (type == PIPE_ISOCHRONOUS) {\n\t\tERR(\"Isochronous transfers not supported\\n\");\n\t\turb_dbg(urb, \"Refused to enqueue\");\n\t\treturn -ENXIO;\n\t}\n\t \n\tif (!hep->hcpriv) {\n\t\tep = kzalloc(sizeof *ep, mem_flags);\n\t\tif (!ep)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tif (!HC_IS_RUNNING(hcd->state)) {\n\t\tkfree(ep);\n\t\tret = -ENODEV;\n\t\tgoto fail_not_linked;\n\t}\n\tret = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (ret) {\n\t\tkfree(ep);\n\t\tgoto fail_not_linked;\n\t}\n\n\tif (hep->hcpriv)\n\t\tep = hep->hcpriv;\n\telse {\n\t\tINIT_LIST_HEAD(&ep->schedule);\n\t\tep->udev = udev;\n\t\tep->epnum = epnum;\n\t\tep->maxpacket = usb_maxpacket(udev, urb->pipe);\n\t\tusb_settoggle(udev, epnum, is_out, 0);\n\n\t\tif (type == PIPE_CONTROL) {\n\t\t\tep->nextpid = USB_PID_SETUP;\n\t\t} else if (is_out) {\n\t\t\tep->nextpid = USB_PID_OUT;\n\t\t} else {\n\t\t\tep->nextpid = USB_PID_IN;\n\t\t}\n\n\t\tif (urb->interval) {\n\t\t\t \n\t\t\tif (urb->interval < 2)\n\t\t\t\turb->interval = 2;\n\t\t\tif (urb->interval > 2 * PERIODIC_SIZE)\n\t\t\t\turb->interval = 2 * PERIODIC_SIZE;\n\t\t\tep->period = urb->interval >> 1;\n\t\t\tep->branch = PERIODIC_SIZE;\n\t\t\tep->load = usb_calc_bus_time(udev->speed,\n\t\t\t\t\t\t     !is_out,\n\t\t\t\t\t\t     (type == PIPE_ISOCHRONOUS),\n\t\t\t\t\t\t     usb_maxpacket(udev, pipe)) /\n\t\t\t    1000;\n\t\t}\n\t\thep->hcpriv = ep;\n\t\tep->hep = hep;\n\t}\n\n\t \n\tswitch (type) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\t\tif (list_empty(&ep->schedule))\n\t\t\tlist_add_tail(&ep->schedule, &isp116x->async);\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\turb->interval = ep->period;\n\t\tep->length = min_t(u32, ep->maxpacket,\n\t\t\t\t urb->transfer_buffer_length);\n\n\t\t \n\t\tif (ep->branch < PERIODIC_SIZE)\n\t\t\tbreak;\n\n\t\tep->branch = ret = balance(isp116x, ep->period, ep->load);\n\t\tif (ret < 0)\n\t\t\tgoto fail;\n\t\tret = 0;\n\n\t\turb->start_frame = (isp116x->fmindex & (PERIODIC_SIZE - 1))\n\t\t    + ep->branch;\n\n\t\t \n\t\tDBG(\"schedule qh%d/%p branch %d\\n\", ep->period, ep, ep->branch);\n\t\tfor (i = ep->branch; i < PERIODIC_SIZE; i += ep->period) {\n\t\t\tstruct isp116x_ep **prev = &isp116x->periodic[i];\n\t\t\tstruct isp116x_ep *here = *prev;\n\n\t\t\twhile (here && ep != here) {\n\t\t\t\tif (ep->period > here->period)\n\t\t\t\t\tbreak;\n\t\t\t\tprev = &here->next;\n\t\t\t\there = *prev;\n\t\t\t}\n\t\t\tif (ep != here) {\n\t\t\t\tep->next = here;\n\t\t\t\t*prev = ep;\n\t\t\t}\n\t\t\tisp116x->load[i] += ep->load;\n\t\t}\n\t\thcd->self.bandwidth_allocated += ep->load / ep->period;\n\n\t\t \n\t\tif (!isp116x->periodic_count++) {\n\t\t\tisp116x->irqenb &= ~HCuPINT_ATL;\n\t\t\tisp116x->irqenb |= HCuPINT_SOF;\n\t\t\tisp116x_write_reg16(isp116x, HCuPINTENB,\n\t\t\t\t\t    isp116x->irqenb);\n\t\t}\n\t}\n\n\turb->hcpriv = hep;\n\tstart_atl_transfers(isp116x);\n\n      fail:\n\tif (ret)\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n      fail_not_linked:\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn ret;\n}\n\n \nstatic int isp116x_urb_dequeue(struct usb_hcd *hcd, struct urb *urb,\n\t\tint status)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tstruct usb_host_endpoint *hep;\n\tstruct isp116x_ep *ep, *ep_act;\n\tunsigned long flags;\n\tint rc;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto done;\n\n\thep = urb->hcpriv;\n\tep = hep->hcpriv;\n\tWARN_ON(hep != ep->hep);\n\n\t \n\tif (ep->hep->urb_list.next == &urb->urb_list)\n\t\t \n\t\tfor (ep_act = isp116x->atl_active; ep_act;\n\t\t     ep_act = ep_act->active)\n\t\t\tif (ep_act == ep) {\n\t\t\t\tVDBG(\"dequeue, urb %p active; wait for irq\\n\",\n\t\t\t\t     urb);\n\t\t\t\turb = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\tif (urb)\n\t\tfinish_request(isp116x, ep, urb, status);\n done:\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn rc;\n}\n\nstatic void isp116x_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t     struct usb_host_endpoint *hep)\n{\n\tint i;\n\tstruct isp116x_ep *ep = hep->hcpriv;\n\n\tif (!ep)\n\t\treturn;\n\n\t \n\tfor (i = 0; i < 100 && !list_empty(&hep->urb_list); i++)\n\t\tmsleep(3);\n\tif (!list_empty(&hep->urb_list))\n\t\tWARNING(\"ep %p not empty?\\n\", ep);\n\n\tkfree(ep);\n\thep->hcpriv = NULL;\n}\n\nstatic int isp116x_get_frame(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tu32 fmnum;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tfmnum = isp116x_read_reg32(isp116x, HCFMNUM);\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn (int)fmnum;\n}\n\n \nstatic int isp116x_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tint ports, i, changed = 0;\n\tunsigned long flags;\n\n\tif (!HC_IS_RUNNING(hcd->state))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (timer_pending(&hcd->rh_timer))\n\t\treturn 0;\n\n\tports = isp116x->rhdesca & RH_A_NDP;\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tisp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);\n\tif (isp116x->rhstatus & (RH_HS_LPSC | RH_HS_OCIC))\n\t\tbuf[0] = changed = 1;\n\telse\n\t\tbuf[0] = 0;\n\n\tfor (i = 0; i < ports; i++) {\n\t\tu32 status = isp116x_read_reg32(isp116x, i ? HCRHPORT2 : HCRHPORT1);\n\n\t\tif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC\n\t\t\t      | RH_PS_OCIC | RH_PS_PRSC)) {\n\t\t\tchanged = 1;\n\t\t\tbuf[0] |= 1 << (i + 1);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn changed;\n}\n\nstatic void isp116x_hub_descriptor(struct isp116x *isp116x,\n\t\t\t\t   struct usb_hub_descriptor *desc)\n{\n\tu32 reg = isp116x->rhdesca;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bDescLength = 9;\n\tdesc->bHubContrCurrent = 0;\n\tdesc->bNbrPorts = (u8) (reg & 0x3);\n\t \n\tdesc->wHubCharacteristics = cpu_to_le16((u16) ((reg >> 8) &\n\t\t\t\t\t\t       (HUB_CHAR_LPSM |\n\t\t\t\t\t\t\tHUB_CHAR_COMPOUND |\n\t\t\t\t\t\t\tHUB_CHAR_OCPM)));\n\tdesc->bPwrOn2PwrGood = (u8) ((reg >> 24) & 0xff);\n\t \n\tdesc->u.hs.DeviceRemovable[0] = 0;\n\tdesc->u.hs.DeviceRemovable[1] = ~0;\n}\n\n \nstatic inline void root_port_reset(struct isp116x *isp116x, unsigned port)\n{\n\tu32 tmp;\n\tunsigned long flags, t;\n\n\t \n\tt = jiffies + msecs_to_jiffies(100);\n\n\twhile (time_before(jiffies, t)) {\n\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\t \n\t\tfor (;;) {\n\t\t\ttmp = isp116x_read_reg32(isp116x, port ?\n\t\t\t\t\t\t HCRHPORT2 : HCRHPORT1);\n\t\t\tif (!(tmp & RH_PS_PRS))\n\t\t\t\tbreak;\n\t\t\tudelay(500);\n\t\t}\n\t\t \n\t\tif (!(tmp & RH_PS_CCS)) {\n\t\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tisp116x_write_reg32(isp116x, port ? HCRHPORT2 :\n\t\t\t\t    HCRHPORT1, (RH_PS_PRS));\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\tmsleep(10);\n\t}\n}\n\n \nstatic int isp116x_hub_control(struct usb_hcd *hcd,\n\t\t\t       u16 typeReq,\n\t\t\t       u16 wValue, u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tint ret = 0;\n\tunsigned long flags;\n\tint ports = isp116x->rhdesca & RH_A_NDP;\n\tu32 tmp = 0;\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tDBG(\"ClearHubFeature: \");\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\tDBG(\"C_HUB_OVER_CURRENT\\n\");\n\t\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\t\tisp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_OCIC);\n\t\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t\tfallthrough;\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tDBG(\"C_HUB_LOCAL_POWER\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tDBG(\"SetHubFeature: \");\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tDBG(\"C_HUB_OVER_CURRENT or C_HUB_LOCAL_POWER\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tDBG(\"GetHubDescriptor\\n\");\n\t\tisp116x_hub_descriptor(isp116x,\n\t\t\t\t       (struct usb_hub_descriptor *)buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\tDBG(\"GetHubStatus\\n\");\n\t\t*(__le32 *) buf = 0;\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tDBG(\"GetPortStatus\\n\");\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\ttmp = isp116x_read_reg32(isp116x, (--wIndex) ? HCRHPORT2 : HCRHPORT1);\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t*(__le32 *) buf = cpu_to_le32(tmp);\n\t\tDBG(\"GetPortStatus: port[%d]  %08x\\n\", wIndex + 1, tmp);\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tDBG(\"ClearPortFeature: \");\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tDBG(\"USB_PORT_FEAT_ENABLE\\n\");\n\t\t\ttmp = RH_PS_CCS;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tDBG(\"USB_PORT_FEAT_C_ENABLE\\n\");\n\t\t\ttmp = RH_PS_PESC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tDBG(\"USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\ttmp = RH_PS_POCI;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tDBG(\"USB_PORT_FEAT_C_SUSPEND\\n\");\n\t\t\ttmp = RH_PS_PSSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tDBG(\"USB_PORT_FEAT_POWER\\n\");\n\t\t\ttmp = RH_PS_LSDA;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tDBG(\"USB_PORT_FEAT_C_CONNECTION\\n\");\n\t\t\ttmp = RH_PS_CSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tDBG(\"USB_PORT_FEAT_C_OVER_CURRENT\\n\");\n\t\t\ttmp = RH_PS_OCIC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tDBG(\"USB_PORT_FEAT_C_RESET\\n\");\n\t\t\ttmp = RH_PS_PRSC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\tisp116x_write_reg32(isp116x, wIndex\n\t\t\t\t    ? HCRHPORT2 : HCRHPORT1, tmp);\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tDBG(\"SetPortFeature: \");\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tDBG(\"USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\t\tisp116x_write_reg32(isp116x, wIndex\n\t\t\t\t\t    ? HCRHPORT2 : HCRHPORT1, RH_PS_PSS);\n\t\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tDBG(\"USB_PORT_FEAT_POWER\\n\");\n\t\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\t\tisp116x_write_reg32(isp116x, wIndex\n\t\t\t\t\t    ? HCRHPORT2 : HCRHPORT1, RH_PS_PPS);\n\t\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tDBG(\"USB_PORT_FEAT_RESET\\n\");\n\t\t\troot_port_reset(isp116x, wIndex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t      error:\n\t\t \n\t\tDBG(\"PROTOCOL STALL\\n\");\n\t\tret = -EPIPE;\n\t}\n\treturn ret;\n}\n\n \n\n#ifdef CONFIG_DEBUG_FS\n\nstatic void dump_irq(struct seq_file *s, char *label, u16 mask)\n{\n\tseq_printf(s, \"%s %04x%s%s%s%s%s%s\\n\", label, mask,\n\t\t   mask & HCuPINT_CLKRDY ? \" clkrdy\" : \"\",\n\t\t   mask & HCuPINT_SUSP ? \" susp\" : \"\",\n\t\t   mask & HCuPINT_OPR ? \" opr\" : \"\",\n\t\t   mask & HCuPINT_AIIEOT ? \" eot\" : \"\",\n\t\t   mask & HCuPINT_ATL ? \" atl\" : \"\",\n\t\t   mask & HCuPINT_SOF ? \" sof\" : \"\");\n}\n\nstatic void dump_int(struct seq_file *s, char *label, u32 mask)\n{\n\tseq_printf(s, \"%s %08x%s%s%s%s%s%s%s\\n\", label, mask,\n\t\t   mask & HCINT_MIE ? \" MIE\" : \"\",\n\t\t   mask & HCINT_RHSC ? \" rhsc\" : \"\",\n\t\t   mask & HCINT_FNO ? \" fno\" : \"\",\n\t\t   mask & HCINT_UE ? \" ue\" : \"\",\n\t\t   mask & HCINT_RD ? \" rd\" : \"\",\n\t\t   mask & HCINT_SF ? \" sof\" : \"\", mask & HCINT_SO ? \" so\" : \"\");\n}\n\nstatic int isp116x_debug_show(struct seq_file *s, void *unused)\n{\n\tstruct isp116x *isp116x = s->private;\n\n\tseq_printf(s, \"%s\\n%s version %s\\n\",\n\t\t   isp116x_to_hcd(isp116x)->product_desc, hcd_name,\n\t\t   DRIVER_VERSION);\n\n\tif (HC_IS_SUSPENDED(isp116x_to_hcd(isp116x)->state)) {\n\t\tseq_printf(s, \"HCD is suspended\\n\");\n\t\treturn 0;\n\t}\n\tif (!HC_IS_RUNNING(isp116x_to_hcd(isp116x)->state)) {\n\t\tseq_printf(s, \"HCD not running\\n\");\n\t\treturn 0;\n\t}\n\n\tspin_lock_irq(&isp116x->lock);\n\tdump_irq(s, \"hc_irq_enable\", isp116x_read_reg16(isp116x, HCuPINTENB));\n\tdump_irq(s, \"hc_irq_status\", isp116x_read_reg16(isp116x, HCuPINT));\n\tdump_int(s, \"hc_int_enable\", isp116x_read_reg32(isp116x, HCINTENB));\n\tdump_int(s, \"hc_int_status\", isp116x_read_reg32(isp116x, HCINTSTAT));\n\tisp116x_show_regs_seq(isp116x, s);\n\tspin_unlock_irq(&isp116x->lock);\n\tseq_printf(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(isp116x_debug);\n\nstatic void create_debug_file(struct isp116x *isp116x)\n{\n\tdebugfs_create_file(hcd_name, S_IRUGO, usb_debug_root, isp116x,\n\t\t\t    &isp116x_debug_fops);\n}\n\nstatic void remove_debug_file(struct isp116x *isp116x)\n{\n\tdebugfs_lookup_and_remove(hcd_name, usb_debug_root);\n}\n\n#else\n\nstatic inline void create_debug_file(struct isp116x *isp116x) { }\nstatic inline void remove_debug_file(struct isp116x *isp116x) { }\n\n#endif\t\t\t\t \n\n \n\n \nstatic int isp116x_sw_reset(struct isp116x *isp116x)\n{\n\tint retries = 15;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tisp116x_write_reg16(isp116x, HCSWRES, HCSWRES_MAGIC);\n\tisp116x_write_reg32(isp116x, HCCMDSTAT, HCCMDSTAT_HCR);\n\twhile (--retries) {\n\t\t \n\t\tmdelay(1);\n\t\tif (!(isp116x_read_reg32(isp116x, HCCMDSTAT) & HCCMDSTAT_HCR))\n\t\t\tbreak;\n\t}\n\tif (!retries) {\n\t\tERR(\"Software reset timeout\\n\");\n\t\tret = -ETIME;\n\t}\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn ret;\n}\n\nstatic int isp116x_reset(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tunsigned long t;\n\tu16 clkrdy = 0;\n\tint ret, timeout = 15   ;\n\n\tret = isp116x_sw_reset(isp116x);\n\tif (ret)\n\t\treturn ret;\n\n\tt = jiffies + msecs_to_jiffies(timeout);\n\twhile (time_before_eq(jiffies, t)) {\n\t\tmsleep(4);\n\t\tspin_lock_irq(&isp116x->lock);\n\t\tclkrdy = isp116x_read_reg16(isp116x, HCuPINT) & HCuPINT_CLKRDY;\n\t\tspin_unlock_irq(&isp116x->lock);\n\t\tif (clkrdy)\n\t\t\tbreak;\n\t}\n\tif (!clkrdy) {\n\t\tERR(\"Clock not ready after %dms\\n\", timeout);\n\t\t \n\t\tERR(\"Please make sure that the H_WAKEUP pin is pulled low!\\n\");\n\t\tret = -ENODEV;\n\t}\n\treturn ret;\n}\n\nstatic void isp116x_stop(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tunsigned long flags;\n\tu32 val;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tisp116x_write_reg16(isp116x, HCuPINTENB, 0);\n\n\t \n\tval = isp116x_read_reg32(isp116x, HCRHDESCA);\n\tval &= ~(RH_A_NPS | RH_A_PSM);\n\tisp116x_write_reg32(isp116x, HCRHDESCA, val);\n\tisp116x_write_reg32(isp116x, HCRHSTATUS, RH_HS_LPS);\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\n\tisp116x_sw_reset(isp116x);\n}\n\n \nstatic int isp116x_start(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tstruct isp116x_platform_data *board = isp116x->board;\n\tu32 val;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\n\t \n\tisp116x_write_reg16(isp116x, HCuPINT, 0xff);\n\tisp116x_write_reg16(isp116x, HCuPINTENB, 0);\n\n\tval = isp116x_read_reg16(isp116x, HCCHIPID);\n\tif ((val & HCCHIPID_MASK) != HCCHIPID_MAGIC) {\n\t\tERR(\"Invalid chip ID %04x\\n\", val);\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\treturn -ENODEV;\n\t}\n\n\t \n\thcd->uses_new_polling = 1;\n\n\tisp116x_write_reg16(isp116x, HCITLBUFLEN, ISP116x_ITL_BUFSIZE);\n\tisp116x_write_reg16(isp116x, HCATLBUFLEN, ISP116x_ATL_BUFSIZE);\n\n\t \n\tval = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);\n\tif (board->sel15Kres)\n\t\tval |= HCHWCFG_15KRSEL;\n\t \n\tif (board->remote_wakeup_enable)\n\t\tval |= HCHWCFG_CLKNOTSTOP;\n\tif (board->oc_enable)\n\t\tval |= HCHWCFG_ANALOG_OC;\n\tif (board->int_act_high)\n\t\tval |= HCHWCFG_INT_POL;\n\tif (board->int_edge_triggered)\n\t\tval |= HCHWCFG_INT_TRIGGER;\n\tisp116x_write_reg16(isp116x, HCHWCFG, val);\n\n\t \n\tval = (25 << 24) & RH_A_POTPGT;\n\t \n\tval |= RH_A_PSM;\n\t \n\tval |= RH_A_OCPM;\n\tisp116x_write_reg32(isp116x, HCRHDESCA, val);\n\tisp116x->rhdesca = isp116x_read_reg32(isp116x, HCRHDESCA);\n\n\tval = RH_B_PPCM;\n\tisp116x_write_reg32(isp116x, HCRHDESCB, val);\n\tisp116x->rhdescb = isp116x_read_reg32(isp116x, HCRHDESCB);\n\n\tval = 0;\n\tif (board->remote_wakeup_enable) {\n\t\tif (!device_can_wakeup(hcd->self.controller))\n\t\t\tdevice_init_wakeup(hcd->self.controller, 1);\n\t\tval |= RH_HS_DRWE;\n\t}\n\tisp116x_write_reg32(isp116x, HCRHSTATUS, val);\n\tisp116x->rhstatus = isp116x_read_reg32(isp116x, HCRHSTATUS);\n\n\tisp116x_write_reg32(isp116x, HCFMINTVL, 0x27782edf);\n\n\thcd->state = HC_STATE_RUNNING;\n\n\t \n\tisp116x->intenb = HCINT_MIE | HCINT_RHSC | HCINT_UE;\n\tif (board->remote_wakeup_enable)\n\t\tisp116x->intenb |= HCINT_RD;\n\tisp116x->irqenb = HCuPINT_ATL | HCuPINT_OPR;\t \n\tisp116x_write_reg32(isp116x, HCINTENB, isp116x->intenb);\n\tisp116x_write_reg16(isp116x, HCuPINTENB, isp116x->irqenb);\n\n\t \n\tval = HCCONTROL_USB_OPER;\n\tif (board->remote_wakeup_enable)\n\t\tval |= HCCONTROL_RWE;\n\tisp116x_write_reg32(isp116x, HCCONTROL, val);\n\n\t \n\tisp116x_write_reg32(isp116x, HCRHPORT1, RH_PS_CCS);\n\tisp116x_write_reg32(isp116x, HCRHPORT2, RH_PS_CCS);\n\n\tisp116x_show_regs_log(isp116x);\n\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\treturn 0;\n}\n\n#ifdef\tCONFIG_PM\n\nstatic int isp116x_bus_suspend(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tunsigned long flags;\n\tu32 val;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&isp116x->lock, flags);\n\tval = isp116x_read_reg32(isp116x, HCCONTROL);\n\n\tswitch (val & HCCONTROL_HCFS) {\n\tcase HCCONTROL_USB_OPER:\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\tval &= (~HCCONTROL_HCFS & ~HCCONTROL_RWE);\n\t\tval |= HCCONTROL_USB_SUSPEND;\n\t\tif (hcd->self.root_hub->do_remote_wakeup)\n\t\t\tval |= HCCONTROL_RWE;\n\t\t \n\t\tmsleep(2);\n\t\tspin_lock_irqsave(&isp116x->lock, flags);\n\t\tisp116x_write_reg32(isp116x, HCCONTROL, val);\n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\t \n\t\tmsleep(5);\n\t\tbreak;\n\tcase HCCONTROL_USB_RESUME:\n\t\tisp116x_write_reg32(isp116x, HCCONTROL,\n\t\t\t\t    (val & ~HCCONTROL_HCFS) |\n\t\t\t\t    HCCONTROL_USB_RESET);\n\t\tfallthrough;\n\tcase HCCONTROL_USB_RESET:\n\t\tret = -EBUSY;\n\t\tfallthrough;\n\tdefault:\t\t \n\t\tspin_unlock_irqrestore(&isp116x->lock, flags);\n\t\tbreak;\n\t}\n\n\treturn ret;\n}\n\nstatic int isp116x_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct isp116x *isp116x = hcd_to_isp116x(hcd);\n\tu32 val;\n\n\tmsleep(5);\n\tspin_lock_irq(&isp116x->lock);\n\n\tval = isp116x_read_reg32(isp116x, HCCONTROL);\n\tswitch (val & HCCONTROL_HCFS) {\n\tcase HCCONTROL_USB_SUSPEND:\n\t\tval &= ~HCCONTROL_HCFS;\n\t\tval |= HCCONTROL_USB_RESUME;\n\t\tisp116x_write_reg32(isp116x, HCCONTROL, val);\n\t\tbreak;\n\tcase HCCONTROL_USB_RESUME:\n\t\tbreak;\n\tcase HCCONTROL_USB_OPER:\n\t\tspin_unlock_irq(&isp116x->lock);\n\t\treturn 0;\n\tdefault:\n\t\t \n\t\tspin_unlock_irq(&isp116x->lock);\n\t\tDBG(\"Chip has been reset while suspended. Reinit from scratch.\\n\");\n\t\tisp116x_reset(hcd);\n\t\tisp116x_start(hcd);\n\t\tisp116x_hub_control(hcd, SetPortFeature,\n\t\t\t\t    USB_PORT_FEAT_POWER, 1, NULL, 0);\n\t\tif ((isp116x->rhdesca & RH_A_NDP) == 2)\n\t\t\tisp116x_hub_control(hcd, SetPortFeature,\n\t\t\t\t\t    USB_PORT_FEAT_POWER, 2, NULL, 0);\n\t\treturn 0;\n\t}\n\n\tval = isp116x->rhdesca & RH_A_NDP;\n\twhile (val--) {\n\t\tu32 stat =\n\t\t    isp116x_read_reg32(isp116x, val ? HCRHPORT2 : HCRHPORT1);\n\t\t \n\t\tif (!(stat & RH_PS_PSS))\n\t\t\tcontinue;\n\t\tDBG(\"%s: Resuming port %d\\n\", __func__, val);\n\t\tisp116x_write_reg32(isp116x, RH_PS_POCI, val\n\t\t\t\t    ? HCRHPORT2 : HCRHPORT1);\n\t}\n\tspin_unlock_irq(&isp116x->lock);\n\n\thcd->state = HC_STATE_RESUMING;\n\tmsleep(USB_RESUME_TIMEOUT);\n\n\t \n\tspin_lock_irq(&isp116x->lock);\n\tval = isp116x_read_reg32(isp116x, HCCONTROL);\n\tisp116x_write_reg32(isp116x, HCCONTROL,\n\t\t\t    (val & ~HCCONTROL_HCFS) | HCCONTROL_USB_OPER);\n\tspin_unlock_irq(&isp116x->lock);\n\thcd->state = HC_STATE_RUNNING;\n\n\treturn 0;\n}\n\n#else\n\n#define\tisp116x_bus_suspend\tNULL\n#define\tisp116x_bus_resume\tNULL\n\n#endif\n\nstatic const struct hc_driver isp116x_hc_driver = {\n\t.description = hcd_name,\n\t.product_desc = \"ISP116x Host Controller\",\n\t.hcd_priv_size = sizeof(struct isp116x),\n\n\t.irq = isp116x_irq,\n\t.flags = HCD_USB11,\n\n\t.reset = isp116x_reset,\n\t.start = isp116x_start,\n\t.stop = isp116x_stop,\n\n\t.urb_enqueue = isp116x_urb_enqueue,\n\t.urb_dequeue = isp116x_urb_dequeue,\n\t.endpoint_disable = isp116x_endpoint_disable,\n\n\t.get_frame_number = isp116x_get_frame,\n\n\t.hub_status_data = isp116x_hub_status_data,\n\t.hub_control = isp116x_hub_control,\n\t.bus_suspend = isp116x_bus_suspend,\n\t.bus_resume = isp116x_bus_resume,\n};\n\n \n\nstatic void isp116x_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct isp116x *isp116x;\n\tstruct resource *res;\n\n\tif (!hcd)\n\t\treturn;\n\tisp116x = hcd_to_isp116x(hcd);\n\tremove_debug_file(isp116x);\n\tusb_remove_hcd(hcd);\n\n\tiounmap(isp116x->data_reg);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (res)\n\t\trelease_mem_region(res->start, 2);\n\tiounmap(isp116x->addr_reg);\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res)\n\t\trelease_mem_region(res->start, 2);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic int isp116x_probe(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct isp116x *isp116x;\n\tstruct resource *addr, *data, *ires;\n\tvoid __iomem *addr_reg;\n\tvoid __iomem *data_reg;\n\tint irq;\n\tint ret = 0;\n\tunsigned long irqflags;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (pdev->num_resources < 3) {\n\t\tret = -ENODEV;\n\t\tgoto err1;\n\t}\n\n\tdata = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\taddr = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tires = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\n\tif (!addr || !data || !ires) {\n\t\tret = -ENODEV;\n\t\tgoto err1;\n\t}\n\n\tirq = ires->start;\n\tirqflags = ires->flags & IRQF_TRIGGER_MASK;\n\n\tif (!request_mem_region(addr->start, 2, hcd_name)) {\n\t\tret = -EBUSY;\n\t\tgoto err1;\n\t}\n\taddr_reg = ioremap(addr->start, resource_size(addr));\n\tif (addr_reg == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err2;\n\t}\n\tif (!request_mem_region(data->start, 2, hcd_name)) {\n\t\tret = -EBUSY;\n\t\tgoto err3;\n\t}\n\tdata_reg = ioremap(data->start, resource_size(data));\n\tif (data_reg == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto err4;\n\t}\n\n\t \n\thcd = usb_create_hcd(&isp116x_hc_driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto err5;\n\t}\n\t \n\thcd->rsrc_start = addr->start;\n\tisp116x = hcd_to_isp116x(hcd);\n\tisp116x->data_reg = data_reg;\n\tisp116x->addr_reg = addr_reg;\n\tspin_lock_init(&isp116x->lock);\n\tINIT_LIST_HEAD(&isp116x->async);\n\tisp116x->board = dev_get_platdata(&pdev->dev);\n\n\tif (!isp116x->board) {\n\t\tERR(\"Platform data structure not initialized\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err6;\n\t}\n\tif (isp116x_check_platform_delay(isp116x)) {\n\t\tERR(\"USE_PLATFORM_DELAY defined, but delay function not \"\n\t\t    \"implemented.\\n\");\n\t\tERR(\"See comments in drivers/usb/host/isp116x-hcd.c\\n\");\n\t\tret = -ENODEV;\n\t\tgoto err6;\n\t}\n\n\tret = usb_add_hcd(hcd, irq, irqflags);\n\tif (ret)\n\t\tgoto err6;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tcreate_debug_file(isp116x);\n\n\treturn 0;\n\n      err6:\n\tusb_put_hcd(hcd);\n      err5:\n\tiounmap(data_reg);\n      err4:\n\trelease_mem_region(data->start, 2);\n      err3:\n\tiounmap(addr_reg);\n      err2:\n\trelease_mem_region(addr->start, 2);\n      err1:\n\tERR(\"init error, %d\\n\", ret);\n\treturn ret;\n}\n\n#ifdef\tCONFIG_PM\n \nstatic int isp116x_suspend(struct platform_device *dev, pm_message_t state)\n{\n\tVDBG(\"%s: state %x\\n\", __func__, state.event);\n\treturn 0;\n}\n\n \nstatic int isp116x_resume(struct platform_device *dev)\n{\n\tVDBG(\"%s\\n\", __func__);\n\treturn 0;\n}\n\n#else\n\n#define\tisp116x_suspend    NULL\n#define\tisp116x_resume     NULL\n\n#endif\n\n \nMODULE_ALIAS(\"platform:isp116x-hcd\");\n\nstatic struct platform_driver isp116x_driver = {\n\t.probe = isp116x_probe,\n\t.remove_new = isp116x_remove,\n\t.suspend = isp116x_suspend,\n\t.resume = isp116x_resume,\n\t.driver = {\n\t\t.name = hcd_name,\n\t},\n};\n\nmodule_platform_driver(isp116x_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}