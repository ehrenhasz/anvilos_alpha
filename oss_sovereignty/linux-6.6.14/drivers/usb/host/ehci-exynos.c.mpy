{
  "module_name": "ehci-exynos.c",
  "hash_id": "b75478ea381f8b3bd0945e6689fdf7af50d4593ab9ac6523a6a3c5e729ac59df",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-exynos.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/gpio/consumer.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ehci.h\"\n\n#define DRIVER_DESC \"EHCI Exynos driver\"\n\n#define EHCI_INSNREG00(base)\t\t\t(base + 0x90)\n#define EHCI_INSNREG00_ENA_INCR16\t\t(0x1 << 25)\n#define EHCI_INSNREG00_ENA_INCR8\t\t(0x1 << 24)\n#define EHCI_INSNREG00_ENA_INCR4\t\t(0x1 << 23)\n#define EHCI_INSNREG00_ENA_INCRX_ALIGN\t\t(0x1 << 22)\n#define EHCI_INSNREG00_ENABLE_DMA_BURST\t\\\n\t(EHCI_INSNREG00_ENA_INCR16 | EHCI_INSNREG00_ENA_INCR8 |\t\\\n\t EHCI_INSNREG00_ENA_INCR4 | EHCI_INSNREG00_ENA_INCRX_ALIGN)\n\nstatic struct hc_driver __read_mostly exynos_ehci_hc_driver;\n\n#define PHY_NUMBER 3\n\nstruct exynos_ehci_hcd {\n\tstruct clk *clk;\n\tstruct device_node *of_node;\n\tstruct phy *phy[PHY_NUMBER];\n\tbool legacy_phy;\n};\n\n#define to_exynos_ehci(hcd) (struct exynos_ehci_hcd *)(hcd_to_ehci(hcd)->priv)\n\nstatic int exynos_ehci_get_phy(struct device *dev,\n\t\t\t\tstruct exynos_ehci_hcd *exynos_ehci)\n{\n\tstruct device_node *child;\n\tstruct phy *phy;\n\tint phy_number, num_phys;\n\tint ret;\n\n\t \n\tnum_phys = of_count_phandle_with_args(dev->of_node, \"phys\",\n\t\t\t\t\t      \"#phy-cells\");\n\tfor (phy_number = 0; phy_number < num_phys; phy_number++) {\n\t\tphy = devm_of_phy_get_by_index(dev, dev->of_node, phy_number);\n\t\tif (IS_ERR(phy))\n\t\t\treturn PTR_ERR(phy);\n\t\texynos_ehci->phy[phy_number] = phy;\n\t}\n\tif (num_phys > 0)\n\t\treturn 0;\n\n\t \n\tfor_each_available_child_of_node(dev->of_node, child) {\n\t\tret = of_property_read_u32(child, \"reg\", &phy_number);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to parse device tree\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (phy_number >= PHY_NUMBER) {\n\t\t\tdev_err(dev, \"Invalid number of PHYs\\n\");\n\t\t\tof_node_put(child);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tphy = devm_of_phy_optional_get(dev, child, NULL);\n\t\texynos_ehci->phy[phy_number] = phy;\n\t\tif (IS_ERR(phy)) {\n\t\t\tof_node_put(child);\n\t\t\treturn PTR_ERR(phy);\n\t\t}\n\t}\n\n\texynos_ehci->legacy_phy = true;\n\treturn 0;\n}\n\nstatic int exynos_ehci_phy_enable(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\n\tint i;\n\tint ret = 0;\n\n\tfor (i = 0; ret == 0 && i < PHY_NUMBER; i++)\n\t\tret = phy_power_on(exynos_ehci->phy[i]);\n\tif (ret)\n\t\tfor (i--; i >= 0; i--)\n\t\t\tphy_power_off(exynos_ehci->phy[i]);\n\n\treturn ret;\n}\n\nstatic void exynos_ehci_phy_disable(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\n\tint i;\n\n\tfor (i = 0; i < PHY_NUMBER; i++)\n\t\tphy_power_off(exynos_ehci->phy[i]);\n}\n\nstatic void exynos_setup_vbus_gpio(struct device *dev)\n{\n\tstruct gpio_desc *gpio;\n\tint err;\n\n\tgpio = devm_gpiod_get_optional(dev, \"samsung,vbus\", GPIOD_OUT_HIGH);\n\terr = PTR_ERR_OR_ZERO(gpio);\n\tif (err)\n\t\tdev_err(dev, \"can't request ehci vbus gpio: %d\\n\", err);\n}\n\nstatic int exynos_ehci_probe(struct platform_device *pdev)\n{\n\tstruct exynos_ehci_hcd *exynos_ehci;\n\tstruct usb_hcd *hcd;\n\tstruct ehci_hcd *ehci;\n\tstruct resource *res;\n\tint irq;\n\tint err;\n\n\t \n\terr = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\texynos_setup_vbus_gpio(&pdev->dev);\n\n\thcd = usb_create_hcd(&exynos_ehci_hc_driver,\n\t\t\t     &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tdev_err(&pdev->dev, \"Unable to create HCD\\n\");\n\t\treturn -ENOMEM;\n\t}\n\texynos_ehci = to_exynos_ehci(hcd);\n\n\terr = exynos_ehci_get_phy(&pdev->dev, exynos_ehci);\n\tif (err)\n\t\tgoto fail_clk;\n\n\texynos_ehci->clk = devm_clk_get(&pdev->dev, \"usbhost\");\n\n\tif (IS_ERR(exynos_ehci->clk)) {\n\t\tdev_err(&pdev->dev, \"Failed to get usbhost clock\\n\");\n\t\terr = PTR_ERR(exynos_ehci->clk);\n\t\tgoto fail_clk;\n\t}\n\n\terr = clk_prepare_enable(exynos_ehci->clk);\n\tif (err)\n\t\tgoto fail_clk;\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto fail_io;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\terr = irq;\n\t\tgoto fail_io;\n\t}\n\n\terr = exynos_ehci_phy_enable(&pdev->dev);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to enable USB phy\\n\");\n\t\tgoto fail_io;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\tehci->caps = hcd->regs;\n\n\t \n\texynos_ehci->of_node = pdev->dev.of_node;\n\tif (exynos_ehci->legacy_phy)\n\t\tpdev->dev.of_node = NULL;\n\n\t \n\twritel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Failed to add USB HCD\\n\");\n\t\tgoto fail_add_hcd;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tplatform_set_drvdata(pdev, hcd);\n\n\treturn 0;\n\nfail_add_hcd:\n\texynos_ehci_phy_disable(&pdev->dev);\n\tpdev->dev.of_node = exynos_ehci->of_node;\nfail_io:\n\tclk_disable_unprepare(exynos_ehci->clk);\nfail_clk:\n\tusb_put_hcd(hcd);\n\treturn err;\n}\n\nstatic void exynos_ehci_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\n\n\tpdev->dev.of_node = exynos_ehci->of_node;\n\n\tusb_remove_hcd(hcd);\n\n\texynos_ehci_phy_disable(&pdev->dev);\n\n\tclk_disable_unprepare(exynos_ehci->clk);\n\n\tusb_put_hcd(hcd);\n}\n\n#ifdef CONFIG_PM\nstatic int exynos_ehci_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\n\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint rc;\n\n\trc = ehci_suspend(hcd, do_wakeup);\n\tif (rc)\n\t\treturn rc;\n\n\texynos_ehci_phy_disable(dev);\n\n\tclk_disable_unprepare(exynos_ehci->clk);\n\n\treturn rc;\n}\n\nstatic int exynos_ehci_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);\n\tint ret;\n\n\tret = clk_prepare_enable(exynos_ehci->clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = exynos_ehci_phy_enable(dev);\n\tif (ret) {\n\t\tdev_err(dev, \"Failed to enable USB phy\\n\");\n\t\tclk_disable_unprepare(exynos_ehci->clk);\n\t\treturn ret;\n\t}\n\n\t \n\twritel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));\n\n\tehci_resume(hcd, false);\n\treturn 0;\n}\n#else\n#define exynos_ehci_suspend\tNULL\n#define exynos_ehci_resume\tNULL\n#endif\n\nstatic const struct dev_pm_ops exynos_ehci_pm_ops = {\n\t.suspend\t= exynos_ehci_suspend,\n\t.resume\t\t= exynos_ehci_resume,\n};\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id exynos_ehci_match[] = {\n\t{ .compatible = \"samsung,exynos4210-ehci\" },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, exynos_ehci_match);\n#endif\n\nstatic struct platform_driver exynos_ehci_driver = {\n\t.probe\t\t= exynos_ehci_probe,\n\t.remove_new\t= exynos_ehci_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver = {\n\t\t.name\t= \"exynos-ehci\",\n\t\t.pm\t= &exynos_ehci_pm_ops,\n\t\t.of_match_table = of_match_ptr(exynos_ehci_match),\n\t}\n};\nstatic const struct ehci_driver_overrides exynos_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct exynos_ehci_hcd),\n};\n\nstatic int __init ehci_exynos_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&exynos_ehci_hc_driver, &exynos_overrides);\n\treturn platform_driver_register(&exynos_ehci_driver);\n}\nmodule_init(ehci_exynos_init);\n\nstatic void __exit ehci_exynos_cleanup(void)\n{\n\tplatform_driver_unregister(&exynos_ehci_driver);\n}\nmodule_exit(ehci_exynos_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_ALIAS(\"platform:exynos-ehci\");\nMODULE_AUTHOR(\"Jingoo Han\");\nMODULE_AUTHOR(\"Joonyoung Shim\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}