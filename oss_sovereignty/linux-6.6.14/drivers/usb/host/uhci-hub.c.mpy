{
  "module_name": "uhci-hub.c",
  "hash_id": "f419498a74e60255eb41d78c530925c8a8aee7b3e3d5e31ce42a11f4d9db8585",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-hub.c",
  "human_readable_source": "\n \n\nstatic const __u8 root_hub_hub_des[] =\n{\n\t0x09,\t\t\t \n\tUSB_DT_HUB,\t\t \n\t0x02,\t\t\t \n\tHUB_CHAR_NO_LPSM |\t \n\t\tHUB_CHAR_INDV_PORT_OCPM,  \n\t0x00,\n\t0x01,\t\t\t \n\t0x00,\t\t\t \n\t0x00,\t\t\t \n\t0xff\t\t\t \n};\n\n#define\tUHCI_RH_MAXCHILD\t7\n\n \n#define WZ_BITS\t\t(USBPORTSC_RES2 | USBPORTSC_RES3 | USBPORTSC_RES4)\n\n \n#define RWC_BITS\t(USBPORTSC_OCC | USBPORTSC_PEC | USBPORTSC_CSC)\n\n \n#define SUSPEND_BITS\t(USBPORTSC_SUSP | USBPORTSC_RD)\n\n \nstatic int any_ports_active(struct uhci_hcd *uhci)\n{\n\tint port;\n\n\tfor (port = 0; port < uhci->rh_numports; ++port) {\n\t\tif ((uhci_readw(uhci, USBPORTSC1 + port * 2) &\n\t\t\t\t(USBPORTSC_CCS | RWC_BITS)) ||\n\t\t\t\ttest_bit(port, &uhci->port_c_suspend))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic inline int get_hub_status_data(struct uhci_hcd *uhci, char *buf)\n{\n\tint port;\n\tint mask = RWC_BITS;\n\n\t \n\tif (ignore_oc)\n\t\tmask &= ~USBPORTSC_OCC;\n\n\t*buf = 0;\n\tfor (port = 0; port < uhci->rh_numports; ++port) {\n\t\tif ((uhci_readw(uhci, USBPORTSC1 + port * 2) & mask) ||\n\t\t\t\ttest_bit(port, &uhci->port_c_suspend))\n\t\t\t*buf |= (1 << (port + 1));\n\t}\n\treturn !!*buf;\n}\n\n#define CLR_RH_PORTSTAT(x) \\\n\tstatus = uhci_readw(uhci, port_addr);\t\\\n\tstatus &= ~(RWC_BITS|WZ_BITS); \\\n\tstatus &= ~(x); \\\n\tstatus |= RWC_BITS & (x); \\\n\tuhci_writew(uhci, status, port_addr)\n\n#define SET_RH_PORTSTAT(x) \\\n\tstatus = uhci_readw(uhci, port_addr);\t\\\n\tstatus |= (x); \\\n\tstatus &= ~(RWC_BITS|WZ_BITS); \\\n\tuhci_writew(uhci, status, port_addr)\n\n \nstatic void uhci_finish_suspend(struct uhci_hcd *uhci, int port,\n\t\tunsigned long port_addr)\n{\n\tint status;\n\tint i;\n\n\tif (uhci_readw(uhci, port_addr) & SUSPEND_BITS) {\n\t\tCLR_RH_PORTSTAT(SUSPEND_BITS);\n\t\tif (test_bit(port, &uhci->resuming_ports))\n\t\t\tset_bit(port, &uhci->port_c_suspend);\n\n\t\t \n\t\tfor (i = 0; i < 10; ++i) {\n\t\t\tif (!(uhci_readw(uhci, port_addr) & SUSPEND_BITS))\n\t\t\t\tbreak;\n\t\t\tudelay(1);\n\t\t}\n\t}\n\tclear_bit(port, &uhci->resuming_ports);\n\tusb_hcd_end_port_resume(&uhci_to_hcd(uhci)->self, port);\n}\n\n \nstatic void wait_for_HP(struct uhci_hcd *uhci, unsigned long port_addr)\n{\n\tint i;\n\n\tfor (i = 10; i < 250; i += 10) {\n\t\tif (uhci_readw(uhci, port_addr) & USBPORTSC_CSC)\n\t\t\treturn;\n\t\tudelay(10);\n\t}\n\t \n}\n\nstatic void uhci_check_ports(struct uhci_hcd *uhci)\n{\n\tunsigned int port;\n\tunsigned long port_addr;\n\tint status;\n\n\tfor (port = 0; port < uhci->rh_numports; ++port) {\n\t\tport_addr = USBPORTSC1 + 2 * port;\n\t\tstatus = uhci_readw(uhci, port_addr);\n\t\tif (unlikely(status & USBPORTSC_PR)) {\n\t\t\tif (time_after_eq(jiffies, uhci->ports_timeout)) {\n\t\t\t\tCLR_RH_PORTSTAT(USBPORTSC_PR);\n\t\t\t\tudelay(10);\n\n\t\t\t\t \n\t\t\t\tif (uhci->wait_for_hp)\n\t\t\t\t\twait_for_HP(uhci, port_addr);\n\n\t\t\t\t \n\t\t\t\tCLR_RH_PORTSTAT(USBPORTSC_CSC | USBPORTSC_PEC);\n\t\t\t\tSET_RH_PORTSTAT(USBPORTSC_PE);\n\t\t\t}\n\t\t}\n\t\tif (unlikely(status & USBPORTSC_RD)) {\n\t\t\tif (!test_bit(port, &uhci->resuming_ports)) {\n\n\t\t\t\t \n\t\t\t\tset_bit(port, &uhci->resuming_ports);\n\t\t\t\tuhci->ports_timeout = jiffies +\n\t\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\t\tusb_hcd_start_port_resume(\n\t\t\t\t\t\t&uhci_to_hcd(uhci)->self, port);\n\n\t\t\t\t \n\t\t\t\tmod_timer(&uhci_to_hcd(uhci)->rh_timer,\n\t\t\t\t\t\tuhci->ports_timeout);\n\t\t\t} else if (time_after_eq(jiffies,\n\t\t\t\t\t\tuhci->ports_timeout)) {\n\t\t\t\tuhci_finish_suspend(uhci, port, port_addr);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int uhci_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned long flags;\n\tint status = 0;\n\n\tspin_lock_irqsave(&uhci->lock, flags);\n\n\tuhci_scan_schedule(uhci);\n\tif (!HCD_HW_ACCESSIBLE(hcd) || uhci->dead)\n\t\tgoto done;\n\tuhci_check_ports(uhci);\n\n\tstatus = get_hub_status_data(uhci, buf);\n\n\tswitch (uhci->rh_state) {\n\t    case UHCI_RH_SUSPENDED:\n\t\t \n\t\tif (status || uhci->resuming_ports) {\n\t\t\tstatus = 1;\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t\t}\n\t\tbreak;\n\n\t    case UHCI_RH_AUTO_STOPPED:\n\t\t \n\t\tif (status)\n\t\t\twakeup_rh(uhci);\n\t\tbreak;\n\n\t    case UHCI_RH_RUNNING:\n\t\t \n\t\tif (!any_ports_active(uhci)) {\n\t\t\tuhci->rh_state = UHCI_RH_RUNNING_NODEVS;\n\t\t\tuhci->auto_stop_time = jiffies + HZ;\n\t\t}\n\t\tbreak;\n\n\t    case UHCI_RH_RUNNING_NODEVS:\n\t\t \n\t\tif (any_ports_active(uhci))\n\t\t\tuhci->rh_state = UHCI_RH_RUNNING;\n\t\telse if (time_after_eq(jiffies, uhci->auto_stop_time) &&\n\t\t\t\t!uhci->wait_for_hp)\n\t\t\tsuspend_rh(uhci, UHCI_RH_AUTO_STOPPED);\n\t\tbreak;\n\n\t    default:\n\t\tbreak;\n\t}\n\ndone:\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n\treturn status;\n}\n\n \nstatic int uhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\tu16 wIndex, char *buf, u16 wLength)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tint status, lstatus, retval = 0;\n\tunsigned int port = wIndex - 1;\n\tunsigned long port_addr = USBPORTSC1 + 2 * port;\n\tu16 wPortChange, wPortStatus;\n\tunsigned long flags;\n\n\tif (!HCD_HW_ACCESSIBLE(hcd) || uhci->dead)\n\t\treturn -ETIMEDOUT;\n\n\tspin_lock_irqsave(&uhci->lock, flags);\n\tswitch (typeReq) {\n\n\tcase GetHubStatus:\n\t\t*(__le32 *)buf = cpu_to_le32(0);\n\t\tretval = 4;  \n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (port >= uhci->rh_numports)\n\t\t\tgoto err;\n\n\t\tuhci_check_ports(uhci);\n\t\tstatus = uhci_readw(uhci, port_addr);\n\n\t\t \n\t\tif (uhci->oc_low)\n\t\t\tstatus ^= USBPORTSC_OC;\n\n\t\t \n\t\twPortChange = lstatus = 0;\n\t\tif (status & USBPORTSC_CSC)\n\t\t\twPortChange |= USB_PORT_STAT_C_CONNECTION;\n\t\tif (status & USBPORTSC_PEC)\n\t\t\twPortChange |= USB_PORT_STAT_C_ENABLE;\n\t\tif ((status & USBPORTSC_OCC) && !ignore_oc)\n\t\t\twPortChange |= USB_PORT_STAT_C_OVERCURRENT;\n\n\t\tif (test_bit(port, &uhci->port_c_suspend)) {\n\t\t\twPortChange |= USB_PORT_STAT_C_SUSPEND;\n\t\t\tlstatus |= 1;\n\t\t}\n\t\tif (test_bit(port, &uhci->resuming_ports))\n\t\t\tlstatus |= 4;\n\n\t\t \n\t\twPortStatus = USB_PORT_STAT_POWER;\n\t\tif (status & USBPORTSC_CCS)\n\t\t\twPortStatus |= USB_PORT_STAT_CONNECTION;\n\t\tif (status & USBPORTSC_PE) {\n\t\t\twPortStatus |= USB_PORT_STAT_ENABLE;\n\t\t\tif (status & SUSPEND_BITS)\n\t\t\t\twPortStatus |= USB_PORT_STAT_SUSPEND;\n\t\t}\n\t\tif (status & USBPORTSC_OC)\n\t\t\twPortStatus |= USB_PORT_STAT_OVERCURRENT;\n\t\tif (status & USBPORTSC_PR)\n\t\t\twPortStatus |= USB_PORT_STAT_RESET;\n\t\tif (status & USBPORTSC_LSDA)\n\t\t\twPortStatus |= USB_PORT_STAT_LOW_SPEED;\n\n\t\tif (wPortChange)\n\t\t\tdev_dbg(uhci_dev(uhci), \"port %d portsc %04x,%02x\\n\",\n\t\t\t\t\twIndex, status, lstatus);\n\n\t\t*(__le16 *)buf = cpu_to_le16(wPortStatus);\n\t\t*(__le16 *)(buf + 2) = cpu_to_le16(wPortChange);\n\t\tretval = 4;\n\t\tbreak;\n\tcase SetHubFeature:\t\t \n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tif (port >= uhci->rh_numports)\n\t\t\tgoto err;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tSET_RH_PORTSTAT(USBPORTSC_SUSP);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tSET_RH_PORTSTAT(USBPORTSC_PR);\n\n\t\t\t \n\t\t\tuhci_finish_suspend(uhci, port, port_addr);\n\n\t\t\t \n\t\t\tuhci->ports_timeout = jiffies +\n\t\t\t\tmsecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (port >= uhci->rh_numports)\n\t\t\tgoto err;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tCLR_RH_PORTSTAT(USBPORTSC_PE);\n\n\t\t\t \n\t\t\tuhci_finish_suspend(uhci, port, port_addr);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tCLR_RH_PORTSTAT(USBPORTSC_PEC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (!(uhci_readw(uhci, port_addr) & USBPORTSC_SUSP)) {\n\n\t\t\t\t \n\t\t\t\tuhci_finish_suspend(uhci, port, port_addr);\n\t\t\t} else if (!test_and_set_bit(port,\n\t\t\t\t\t\t&uhci->resuming_ports)) {\n\t\t\t\tSET_RH_PORTSTAT(USBPORTSC_RD);\n\n\t\t\t\t \n\t\t\t\tif (!(uhci_readw(uhci, port_addr) &\n\t\t\t\t\t\tUSBPORTSC_RD))\n\t\t\t\t\tuhci_finish_suspend(uhci, port,\n\t\t\t\t\t\t\tport_addr);\n\t\t\t\telse\n\t\t\t\t\t \n\t\t\t\t\tuhci->ports_timeout = jiffies +\n\t\t\t\t\t\tmsecs_to_jiffies(20);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tclear_bit(port, &uhci->port_c_suspend);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\t \n\t\t\tgoto err;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tCLR_RH_PORTSTAT(USBPORTSC_CSC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tCLR_RH_PORTSTAT(USBPORTSC_OCC);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto err;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tretval = min_t(unsigned int, sizeof(root_hub_hub_des), wLength);\n\t\tmemcpy(buf, root_hub_hub_des, retval);\n\t\tif (retval > 2)\n\t\t\tbuf[2] = uhci->rh_numports;\n\t\tbreak;\n\tdefault:\nerr:\n\t\tretval = -EPIPE;\n\t}\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n\n\treturn retval;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}