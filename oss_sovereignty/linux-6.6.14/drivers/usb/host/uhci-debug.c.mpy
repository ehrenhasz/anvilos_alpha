{
  "module_name": "uhci-debug.c",
  "hash_id": "1ec023ee49fc133276e0ee83e9b953e65fdc00e378174a2483246de57f733dcc",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-debug.c",
  "human_readable_source": "\n \n\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/debugfs.h>\n#include <asm/io.h>\n\n#include \"uhci-hcd.h\"\n\n#define EXTRA_SPACE\t1024\n\nstatic struct dentry *uhci_debugfs_root;\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\n \nstatic void lprintk(char *buf)\n{\n\tchar *p;\n\n\t \n\twhile (buf) {\n\t\tp = strchr(buf, '\\n');\n\t\tif (p)\n\t\t\t*p = 0;\n\t\tprintk(KERN_DEBUG \"%s\\n\", buf);\n\t\tbuf = p;\n\t\tif (buf)\n\t\t\tbuf++;\n\t}\n}\n\nstatic int uhci_show_td(struct uhci_hcd *uhci, struct uhci_td *td, char *buf,\n\t\t\tint len, int space)\n{\n\tchar *out = buf;\n\tchar *spid;\n\tu32 status, token;\n\n\tstatus = td_status(uhci, td);\n\tout += sprintf(out, \"%*s[%p] link (%08x) \", space, \"\", td,\n\t\thc32_to_cpu(uhci, td->link));\n\tout += sprintf(out, \"e%d %s%s%s%s%s%s%s%s%s%sLength=%x \",\n\t\t((status >> 27) & 3),\n\t\t(status & TD_CTRL_SPD) ?      \"SPD \" : \"\",\n\t\t(status & TD_CTRL_LS) ?       \"LS \" : \"\",\n\t\t(status & TD_CTRL_IOC) ?      \"IOC \" : \"\",\n\t\t(status & TD_CTRL_ACTIVE) ?   \"Active \" : \"\",\n\t\t(status & TD_CTRL_STALLED) ?  \"Stalled \" : \"\",\n\t\t(status & TD_CTRL_DBUFERR) ?  \"DataBufErr \" : \"\",\n\t\t(status & TD_CTRL_BABBLE) ?   \"Babble \" : \"\",\n\t\t(status & TD_CTRL_NAK) ?      \"NAK \" : \"\",\n\t\t(status & TD_CTRL_CRCTIMEO) ? \"CRC/Timeo \" : \"\",\n\t\t(status & TD_CTRL_BITSTUFF) ? \"BitStuff \" : \"\",\n\t\tstatus & 0x7ff);\n\tif (out - buf > len)\n\t\tgoto done;\n\n\ttoken = td_token(uhci, td);\n\tswitch (uhci_packetid(token)) {\n\t\tcase USB_PID_SETUP:\n\t\t\tspid = \"SETUP\";\n\t\t\tbreak;\n\t\tcase USB_PID_OUT:\n\t\t\tspid = \"OUT\";\n\t\t\tbreak;\n\t\tcase USB_PID_IN:\n\t\t\tspid = \"IN\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspid = \"?\";\n\t\t\tbreak;\n\t}\n\n\tout += sprintf(out, \"MaxLen=%x DT%d EndPt=%x Dev=%x, PID=%x(%s) \",\n\t\ttoken >> 21,\n\t\t((token >> 19) & 1),\n\t\t(token >> 15) & 15,\n\t\t(token >> 8) & 127,\n\t\t(token & 0xff),\n\t\tspid);\n\tout += sprintf(out, \"(buf=%08x)\\n\", hc32_to_cpu(uhci, td->buffer));\n\ndone:\n\tif (out - buf > len)\n\t\tout += sprintf(out, \" ...\\n\");\n\treturn out - buf;\n}\n\nstatic int uhci_show_urbp(struct uhci_hcd *uhci, struct urb_priv *urbp,\n\t\t\tchar *buf, int len, int space)\n{\n\tchar *out = buf;\n\tstruct uhci_td *td;\n\tint i, nactive, ninactive;\n\tchar *ptype;\n\n\n\tout += sprintf(out, \"urb_priv [%p] \", urbp);\n\tout += sprintf(out, \"urb [%p] \", urbp->urb);\n\tout += sprintf(out, \"qh [%p] \", urbp->qh);\n\tout += sprintf(out, \"Dev=%d \", usb_pipedevice(urbp->urb->pipe));\n\tout += sprintf(out, \"EP=%x(%s) \", usb_pipeendpoint(urbp->urb->pipe),\n\t\t\t(usb_pipein(urbp->urb->pipe) ? \"IN\" : \"OUT\"));\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tswitch (usb_pipetype(urbp->urb->pipe)) {\n\tcase PIPE_ISOCHRONOUS: ptype = \"ISO\"; break;\n\tcase PIPE_INTERRUPT: ptype = \"INT\"; break;\n\tcase PIPE_BULK: ptype = \"BLK\"; break;\n\tdefault:\n\tcase PIPE_CONTROL: ptype = \"CTL\"; break;\n\t}\n\n\tout += sprintf(out, \"%s%s\", ptype, (urbp->fsbr ? \" FSBR\" : \"\"));\n\tout += sprintf(out, \" Actlen=%d%s\", urbp->urb->actual_length,\n\t\t\t(urbp->qh->type == USB_ENDPOINT_XFER_CONTROL ?\n\t\t\t\t\"-8\" : \"\"));\n\n\tif (urbp->urb->unlinked)\n\t\tout += sprintf(out, \" Unlinked=%d\", urbp->urb->unlinked);\n\tout += sprintf(out, \"\\n\");\n\n\tif (out - buf > len)\n\t\tgoto done;\n\n\ti = nactive = ninactive = 0;\n\tlist_for_each_entry(td, &urbp->td_list, list) {\n\t\tif (urbp->qh->type != USB_ENDPOINT_XFER_ISOC &&\n\t\t\t\t(++i <= 10 || debug > 2)) {\n\t\t\tout += sprintf(out, \"%*s%d: \", space + 2, \"\", i);\n\t\t\tout += uhci_show_td(uhci, td, out,\n\t\t\t\t\tlen - (out - buf), 0);\n\t\t\tif (out - buf > len)\n\t\t\t\tgoto tail;\n\t\t} else {\n\t\t\tif (td_status(uhci, td) & TD_CTRL_ACTIVE)\n\t\t\t\t++nactive;\n\t\t\telse\n\t\t\t\t++ninactive;\n\t\t}\n\t}\n\tif (nactive + ninactive > 0)\n\t\tout += sprintf(out,\n\t\t\t\t\"%*s[skipped %d inactive and %d active TDs]\\n\",\n\t\t\t\tspace, \"\", ninactive, nactive);\ndone:\n\tif (out - buf > len)\n\t\tout += sprintf(out, \" ...\\n\");\ntail:\n\treturn out - buf;\n}\n\nstatic int uhci_show_qh(struct uhci_hcd *uhci,\n\t\tstruct uhci_qh *qh, char *buf, int len, int space)\n{\n\tchar *out = buf;\n\tint i, nurbs;\n\t__hc32 element = qh_element(qh);\n\tchar *qtype;\n\n\tswitch (qh->type) {\n\tcase USB_ENDPOINT_XFER_ISOC: qtype = \"ISO\"; break;\n\tcase USB_ENDPOINT_XFER_INT: qtype = \"INT\"; break;\n\tcase USB_ENDPOINT_XFER_BULK: qtype = \"BLK\"; break;\n\tcase USB_ENDPOINT_XFER_CONTROL: qtype = \"CTL\"; break;\n\tdefault: qtype = \"Skel\" ; break;\n\t}\n\n\tout += sprintf(out, \"%*s[%p] %s QH link (%08x) element (%08x)\\n\",\n\t\t\tspace, \"\", qh, qtype,\n\t\t\thc32_to_cpu(uhci, qh->link),\n\t\t\thc32_to_cpu(uhci, element));\n\tif (qh->type == USB_ENDPOINT_XFER_ISOC)\n\t\tout += sprintf(out,\n\t\t\t\t\"%*s    period %d phase %d load %d us, frame %x desc [%p]\\n\",\n\t\t\t\tspace, \"\", qh->period, qh->phase, qh->load,\n\t\t\t\tqh->iso_frame, qh->iso_packet_desc);\n\telse if (qh->type == USB_ENDPOINT_XFER_INT)\n\t\tout += sprintf(out, \"%*s    period %d phase %d load %d us\\n\",\n\t\t\t\tspace, \"\", qh->period, qh->phase, qh->load);\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tif (element & UHCI_PTR_QH(uhci))\n\t\tout += sprintf(out, \"%*s  Element points to QH (bug?)\\n\", space, \"\");\n\n\tif (element & UHCI_PTR_DEPTH(uhci))\n\t\tout += sprintf(out, \"%*s  Depth traverse\\n\", space, \"\");\n\n\tif (element & cpu_to_hc32(uhci, 8))\n\t\tout += sprintf(out, \"%*s  Bit 3 set (bug?)\\n\", space, \"\");\n\n\tif (!(element & ~(UHCI_PTR_QH(uhci) | UHCI_PTR_DEPTH(uhci))))\n\t\tout += sprintf(out, \"%*s  Element is NULL (bug?)\\n\", space, \"\");\n\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tif (list_empty(&qh->queue)) {\n\t\tout += sprintf(out, \"%*s  queue is empty\\n\", space, \"\");\n\t\tif (qh == uhci->skel_async_qh) {\n\t\t\tout += uhci_show_td(uhci, uhci->term_td, out,\n\t\t\t\t\tlen - (out - buf), 0);\n\t\t\tif (out - buf > len)\n\t\t\t\tgoto tail;\n\t\t}\n\t} else {\n\t\tstruct urb_priv *urbp = list_entry(qh->queue.next,\n\t\t\t\tstruct urb_priv, node);\n\t\tstruct uhci_td *td = list_entry(urbp->td_list.next,\n\t\t\t\tstruct uhci_td, list);\n\n\t\tif (element != LINK_TO_TD(uhci, td))\n\t\t\tout += sprintf(out, \"%*s Element != First TD\\n\",\n\t\t\t\t\tspace, \"\");\n\t\ti = nurbs = 0;\n\t\tlist_for_each_entry(urbp, &qh->queue, node) {\n\t\t\tif (++i <= 10) {\n\t\t\t\tout += uhci_show_urbp(uhci, urbp, out,\n\t\t\t\t\t\tlen - (out - buf), space + 2);\n\t\t\t\tif (out - buf > len)\n\t\t\t\t\tgoto tail;\n\t\t\t}\n\t\t\telse\n\t\t\t\t++nurbs;\n\t\t}\n\t\tif (nurbs > 0)\n\t\t\tout += sprintf(out, \"%*s Skipped %d URBs\\n\",\n\t\t\t\t\tspace, \"\", nurbs);\n\t}\n\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tif (qh->dummy_td) {\n\t\tout += sprintf(out, \"%*s  Dummy TD\\n\", space, \"\");\n\t\tout += uhci_show_td(uhci, qh->dummy_td, out,\n\t\t\t\tlen - (out - buf), 0);\n\t\tif (out - buf > len)\n\t\t\tgoto tail;\n\t}\n\ndone:\n\tif (out - buf > len)\n\t\tout += sprintf(out, \" ...\\n\");\ntail:\n\treturn out - buf;\n}\n\nstatic int uhci_show_sc(int port, unsigned short status, char *buf)\n{\n\treturn sprintf(buf, \"  stat%d     =     %04x  %s%s%s%s%s%s%s%s%s%s\\n\",\n\t\tport,\n\t\tstatus,\n\t\t(status & USBPORTSC_SUSP) ?\t\" Suspend\" : \"\",\n\t\t(status & USBPORTSC_OCC) ?\t\" OverCurrentChange\" : \"\",\n\t\t(status & USBPORTSC_OC) ?\t\" OverCurrent\" : \"\",\n\t\t(status & USBPORTSC_PR) ?\t\" Reset\" : \"\",\n\t\t(status & USBPORTSC_LSDA) ?\t\" LowSpeed\" : \"\",\n\t\t(status & USBPORTSC_RD) ?\t\" ResumeDetect\" : \"\",\n\t\t(status & USBPORTSC_PEC) ?\t\" EnableChange\" : \"\",\n\t\t(status & USBPORTSC_PE) ?\t\" Enabled\" : \"\",\n\t\t(status & USBPORTSC_CSC) ?\t\" ConnectChange\" : \"\",\n\t\t(status & USBPORTSC_CCS) ?\t\" Connected\" : \"\");\n}\n\nstatic int uhci_show_root_hub_state(struct uhci_hcd *uhci, char *buf)\n{\n\tchar *rh_state;\n\n\tswitch (uhci->rh_state) {\n\t    case UHCI_RH_RESET:\n\t\trh_state = \"reset\";\t\tbreak;\n\t    case UHCI_RH_SUSPENDED:\n\t\trh_state = \"suspended\";\t\tbreak;\n\t    case UHCI_RH_AUTO_STOPPED:\n\t\trh_state = \"auto-stopped\";\tbreak;\n\t    case UHCI_RH_RESUMING:\n\t\trh_state = \"resuming\";\t\tbreak;\n\t    case UHCI_RH_SUSPENDING:\n\t\trh_state = \"suspending\";\tbreak;\n\t    case UHCI_RH_RUNNING:\n\t\trh_state = \"running\";\t\tbreak;\n\t    case UHCI_RH_RUNNING_NODEVS:\n\t\trh_state = \"running, no devs\";\tbreak;\n\t    default:\n\t\trh_state = \"?\";\t\t\tbreak;\n\t}\n\treturn sprintf(buf, \"Root-hub state: %s   FSBR: %d\\n\",\n\t\t\trh_state, uhci->fsbr_is_on);\n}\n\nstatic int uhci_show_status(struct uhci_hcd *uhci, char *buf, int len)\n{\n\tchar *out = buf;\n\tunsigned short usbcmd, usbstat, usbint, usbfrnum;\n\tunsigned int flbaseadd;\n\tunsigned char sof;\n\tunsigned short portsc1, portsc2;\n\n\n\tusbcmd    = uhci_readw(uhci, USBCMD);\n\tusbstat   = uhci_readw(uhci, USBSTS);\n\tusbint    = uhci_readw(uhci, USBINTR);\n\tusbfrnum  = uhci_readw(uhci, USBFRNUM);\n\tflbaseadd = uhci_readl(uhci, USBFLBASEADD);\n\tsof       = uhci_readb(uhci, USBSOF);\n\tportsc1   = uhci_readw(uhci, USBPORTSC1);\n\tportsc2   = uhci_readw(uhci, USBPORTSC2);\n\n\tout += sprintf(out, \"  usbcmd    =     %04x   %s%s%s%s%s%s%s%s\\n\",\n\t\tusbcmd,\n\t\t(usbcmd & USBCMD_MAXP) ?    \"Maxp64 \" : \"Maxp32 \",\n\t\t(usbcmd & USBCMD_CF) ?      \"CF \" : \"\",\n\t\t(usbcmd & USBCMD_SWDBG) ?   \"SWDBG \" : \"\",\n\t\t(usbcmd & USBCMD_FGR) ?     \"FGR \" : \"\",\n\t\t(usbcmd & USBCMD_EGSM) ?    \"EGSM \" : \"\",\n\t\t(usbcmd & USBCMD_GRESET) ?  \"GRESET \" : \"\",\n\t\t(usbcmd & USBCMD_HCRESET) ? \"HCRESET \" : \"\",\n\t\t(usbcmd & USBCMD_RS) ?      \"RS \" : \"\");\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tout += sprintf(out, \"  usbstat   =     %04x   %s%s%s%s%s%s\\n\",\n\t\tusbstat,\n\t\t(usbstat & USBSTS_HCH) ?    \"HCHalted \" : \"\",\n\t\t(usbstat & USBSTS_HCPE) ?   \"HostControllerProcessError \" : \"\",\n\t\t(usbstat & USBSTS_HSE) ?    \"HostSystemError \" : \"\",\n\t\t(usbstat & USBSTS_RD) ?     \"ResumeDetect \" : \"\",\n\t\t(usbstat & USBSTS_ERROR) ?  \"USBError \" : \"\",\n\t\t(usbstat & USBSTS_USBINT) ? \"USBINT \" : \"\");\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tout += sprintf(out, \"  usbint    =     %04x\\n\", usbint);\n\tout += sprintf(out, \"  usbfrnum  =   (%d)%03x\\n\", (usbfrnum >> 10) & 1,\n\t\t0xfff & (4*(unsigned int)usbfrnum));\n\tout += sprintf(out, \"  flbaseadd = %08x\\n\", flbaseadd);\n\tout += sprintf(out, \"  sof       =       %02x\\n\", sof);\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tout += uhci_show_sc(1, portsc1, out);\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tout += uhci_show_sc(2, portsc2, out);\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tout += sprintf(out,\n\t\t\t\"Most recent frame: %x (%d)   Last ISO frame: %x (%d)\\n\",\n\t\t\tuhci->frame_number, uhci->frame_number & 1023,\n\t\t\tuhci->last_iso_frame, uhci->last_iso_frame & 1023);\n\ndone:\n\tif (out - buf > len)\n\t\tout += sprintf(out, \" ...\\n\");\n\treturn out - buf;\n}\n\nstatic int uhci_sprint_schedule(struct uhci_hcd *uhci, char *buf, int len)\n{\n\tchar *out = buf;\n\tint i, j;\n\tstruct uhci_qh *qh;\n\tstruct uhci_td *td;\n\tstruct list_head *tmp, *head;\n\tint nframes, nerrs;\n\t__hc32 link;\n\t__hc32 fsbr_link;\n\n\tstatic const char * const qh_names[] = {\n\t\t\"unlink\", \"iso\", \"int128\", \"int64\", \"int32\", \"int16\",\n\t\t\"int8\", \"int4\", \"int2\", \"async\", \"term\"\n\t};\n\n\tout += uhci_show_root_hub_state(uhci, out);\n\tif (out - buf > len)\n\t\tgoto done;\n\tout += sprintf(out, \"HC status\\n\");\n\tout += uhci_show_status(uhci, out, len - (out - buf));\n\tif (out - buf > len)\n\t\tgoto tail;\n\n\tout += sprintf(out, \"Periodic load table\\n\");\n\tfor (i = 0; i < MAX_PHASE; ++i) {\n\t\tout += sprintf(out, \"\\t%d\", uhci->load[i]);\n\t\tif (i % 8 == 7)\n\t\t\t*out++ = '\\n';\n\t}\n\tout += sprintf(out, \"Total: %d, #INT: %d, #ISO: %d\\n\",\n\t\t\tuhci->total_load,\n\t\t\tuhci_to_hcd(uhci)->self.bandwidth_int_reqs,\n\t\t\tuhci_to_hcd(uhci)->self.bandwidth_isoc_reqs);\n\tif (debug <= 1)\n\t\tgoto tail;\n\n\tout += sprintf(out, \"Frame List\\n\");\n\tnframes = 10;\n\tnerrs = 0;\n\tfor (i = 0; i < UHCI_NUMFRAMES; ++i) {\n\t\t__hc32 qh_dma;\n\n\t\tif (out - buf > len)\n\t\t\tgoto done;\n\t\tj = 0;\n\t\ttd = uhci->frame_cpu[i];\n\t\tlink = uhci->frame[i];\n\t\tif (!td)\n\t\t\tgoto check_link;\n\n\t\tif (nframes > 0) {\n\t\t\tout += sprintf(out, \"- Frame %d -> (%08x)\\n\",\n\t\t\t\t\ti, hc32_to_cpu(uhci, link));\n\t\t\tj = 1;\n\t\t}\n\n\t\thead = &td->fl_list;\n\t\ttmp = head;\n\t\tdo {\n\t\t\ttd = list_entry(tmp, struct uhci_td, fl_list);\n\t\t\ttmp = tmp->next;\n\t\t\tif (link != LINK_TO_TD(uhci, td)) {\n\t\t\t\tif (nframes > 0) {\n\t\t\t\t\tout += sprintf(out,\n\t\t\t\t\t\t\"    link does not match list entry!\\n\");\n\t\t\t\t\tif (out - buf > len)\n\t\t\t\t\t\tgoto done;\n\t\t\t\t} else\n\t\t\t\t\t++nerrs;\n\t\t\t}\n\t\t\tif (nframes > 0) {\n\t\t\t\tout += uhci_show_td(uhci, td, out,\n\t\t\t\t\t\tlen - (out - buf), 4);\n\t\t\t\tif (out - buf > len)\n\t\t\t\t\tgoto tail;\n\t\t\t}\n\t\t\tlink = td->link;\n\t\t} while (tmp != head);\n\ncheck_link:\n\t\tqh_dma = uhci_frame_skel_link(uhci, i);\n\t\tif (link != qh_dma) {\n\t\t\tif (nframes > 0) {\n\t\t\t\tif (!j) {\n\t\t\t\t\tout += sprintf(out,\n\t\t\t\t\t\t\"- Frame %d -> (%08x)\\n\",\n\t\t\t\t\t\ti, hc32_to_cpu(uhci, link));\n\t\t\t\t\tj = 1;\n\t\t\t\t}\n\t\t\t\tout += sprintf(out,\n\t\t\t\t\t\"   link does not match QH (%08x)!\\n\",\n\t\t\t\t\thc32_to_cpu(uhci, qh_dma));\n\t\t\t\tif (out - buf > len)\n\t\t\t\t\tgoto done;\n\t\t\t} else\n\t\t\t\t++nerrs;\n\t\t}\n\t\tnframes -= j;\n\t}\n\tif (nerrs > 0)\n\t\tout += sprintf(out, \"Skipped %d bad links\\n\", nerrs);\n\n\tout += sprintf(out, \"Skeleton QHs\\n\");\n\n\tif (out - buf > len)\n\t\tgoto done;\n\n\tfsbr_link = 0;\n\tfor (i = 0; i < UHCI_NUM_SKELQH; ++i) {\n\t\tint cnt = 0;\n\n\t\tqh = uhci->skelqh[i];\n\t\tout += sprintf(out, \"- skel_%s_qh\\n\", qh_names[i]);\n\t\tout += uhci_show_qh(uhci, qh, out, len - (out - buf), 4);\n\t\tif (out - buf > len)\n\t\t\tgoto tail;\n\n\t\t \n\t\tif (i == SKEL_TERM) {\n\t\t\tif (qh_element(qh) != LINK_TO_TD(uhci, uhci->term_td)) {\n\t\t\t\tout += sprintf(out,\n\t\t\t\t\t\"    skel_term_qh element is not set to term_td!\\n\");\n\t\t\t\tif (out - buf > len)\n\t\t\t\t\tgoto done;\n\t\t\t}\n\t\t\tlink = fsbr_link;\n\t\t\tif (!link)\n\t\t\t\tlink = LINK_TO_QH(uhci, uhci->skel_term_qh);\n\t\t\tgoto check_qh_link;\n\t\t}\n\n\t\thead = &qh->node;\n\t\ttmp = head->next;\n\n\t\twhile (tmp != head) {\n\t\t\tqh = list_entry(tmp, struct uhci_qh, node);\n\t\t\ttmp = tmp->next;\n\t\t\tif (++cnt <= 10) {\n\t\t\t\tout += uhci_show_qh(uhci, qh, out,\n\t\t\t\t\t\tlen - (out - buf), 4);\n\t\t\t\tif (out - buf > len)\n\t\t\t\t\tgoto tail;\n\t\t\t}\n\t\t\tif (!fsbr_link && qh->skel >= SKEL_FSBR)\n\t\t\t\tfsbr_link = LINK_TO_QH(uhci, qh);\n\t\t}\n\t\tif ((cnt -= 10) > 0)\n\t\t\tout += sprintf(out, \"    Skipped %d QHs\\n\", cnt);\n\n\t\tlink = UHCI_PTR_TERM(uhci);\n\t\tif (i <= SKEL_ISO)\n\t\t\t;\n\t\telse if (i < SKEL_ASYNC)\n\t\t\tlink = LINK_TO_QH(uhci, uhci->skel_async_qh);\n\t\telse if (!uhci->fsbr_is_on)\n\t\t\t;\n\t\telse\n\t\t\tlink = LINK_TO_QH(uhci, uhci->skel_term_qh);\ncheck_qh_link:\n\t\tif (qh->link != link)\n\t\t\tout += sprintf(out,\n\t\t\t\t\"    last QH not linked to next skeleton!\\n\");\n\n\t\tif (out - buf > len)\n\t\t\tgoto done;\n\t}\n\ndone:\n\tif (out - buf > len)\n\t\tout += sprintf(out, \" ...\\n\");\ntail:\n\treturn out - buf;\n}\n\n#ifdef CONFIG_DEBUG_FS\n\n#define MAX_OUTPUT\t(64 * 1024)\n\nstruct uhci_debug {\n\tint size;\n\tchar *data;\n};\n\nstatic int uhci_debug_open(struct inode *inode, struct file *file)\n{\n\tstruct uhci_hcd *uhci = inode->i_private;\n\tstruct uhci_debug *up;\n\tunsigned long flags;\n\n\tup = kmalloc(sizeof(*up), GFP_KERNEL);\n\tif (!up)\n\t\treturn -ENOMEM;\n\n\tup->data = kmalloc(MAX_OUTPUT, GFP_KERNEL);\n\tif (!up->data) {\n\t\tkfree(up);\n\t\treturn -ENOMEM;\n\t}\n\n\tup->size = 0;\n\tspin_lock_irqsave(&uhci->lock, flags);\n\tif (uhci->is_initialized)\n\t\tup->size = uhci_sprint_schedule(uhci, up->data,\n\t\t\t\t\tMAX_OUTPUT - EXTRA_SPACE);\n\tspin_unlock_irqrestore(&uhci->lock, flags);\n\n\tfile->private_data = up;\n\n\treturn 0;\n}\n\nstatic loff_t uhci_debug_lseek(struct file *file, loff_t off, int whence)\n{\n\tstruct uhci_debug *up = file->private_data;\n\treturn no_seek_end_llseek_size(file, off, whence, up->size);\n}\n\nstatic ssize_t uhci_debug_read(struct file *file, char __user *buf,\n\t\t\t\tsize_t nbytes, loff_t *ppos)\n{\n\tstruct uhci_debug *up = file->private_data;\n\treturn simple_read_from_buffer(buf, nbytes, ppos, up->data, up->size);\n}\n\nstatic int uhci_debug_release(struct inode *inode, struct file *file)\n{\n\tstruct uhci_debug *up = file->private_data;\n\n\tkfree(up->data);\n\tkfree(up);\n\n\treturn 0;\n}\n\nstatic const struct file_operations uhci_debug_operations = {\n\t.owner =\tTHIS_MODULE,\n\t.open =\t\tuhci_debug_open,\n\t.llseek =\tuhci_debug_lseek,\n\t.read =\t\tuhci_debug_read,\n\t.release =\tuhci_debug_release,\n};\n#define UHCI_DEBUG_OPS\n\n#endif\t \n\n#else\t \n\nstatic inline void lprintk(char *buf)\n{}\n\nstatic inline int uhci_show_qh(struct uhci_hcd *uhci,\n\t\tstruct uhci_qh *qh, char *buf, int len, int space)\n{\n\treturn 0;\n}\n\nstatic inline int uhci_sprint_schedule(struct uhci_hcd *uhci,\n\t\tchar *buf, int len)\n{\n\treturn 0;\n}\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}