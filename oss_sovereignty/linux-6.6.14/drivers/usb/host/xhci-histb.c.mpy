{
  "module_name": "xhci-histb.c",
  "hash_id": "b97c45ed614d8dba7637a6999763d887338c25e3413dc514f2d1f747fc5e2bcf",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-histb.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n\n#include \"xhci.h\"\n\n#define GTXTHRCFG\t\t0xc108\n#define GRXTHRCFG\t\t0xc10c\n#define REG_GUSB2PHYCFG0\t0xc200\n#define BIT_UTMI_8_16\t\tBIT(3)\n#define BIT_UTMI_ULPI\t\tBIT(4)\n#define BIT_FREECLK_EXIST\tBIT(30)\n\n#define REG_GUSB3PIPECTL0\t0xc2c0\n#define USB3_DEEMPHASIS_MASK\tGENMASK(2, 1)\n#define USB3_DEEMPHASIS0\tBIT(1)\n#define USB3_TX_MARGIN1\t\tBIT(4)\n\nstruct xhci_hcd_histb {\n\tstruct device\t\t*dev;\n\tstruct usb_hcd\t\t*hcd;\n\tvoid __iomem\t\t*ctrl;\n\tstruct clk\t\t*bus_clk;\n\tstruct clk\t\t*utmi_clk;\n\tstruct clk\t\t*pipe_clk;\n\tstruct clk\t\t*suspend_clk;\n\tstruct reset_control\t*soft_reset;\n};\n\nstatic inline struct xhci_hcd_histb *hcd_to_histb(struct usb_hcd *hcd)\n{\n\treturn dev_get_drvdata(hcd->self.controller);\n}\n\nstatic int xhci_histb_config(struct xhci_hcd_histb *histb)\n{\n\tstruct device_node *np = histb->dev->of_node;\n\tu32 regval;\n\n\tif (of_property_match_string(np, \"phys-names\", \"inno\") >= 0) {\n\t\t \n\t\tregval = readl(histb->ctrl + REG_GUSB2PHYCFG0);\n\t\tregval &= ~BIT_UTMI_ULPI;\n\t\tregval &= ~(BIT_UTMI_8_16);\n\t\tregval &= ~BIT_FREECLK_EXIST;\n\t\twritel(regval, histb->ctrl + REG_GUSB2PHYCFG0);\n\t}\n\n\tif (of_property_match_string(np, \"phys-names\", \"combo\") >= 0) {\n\t\t \n\t\tregval = readl(histb->ctrl + REG_GUSB3PIPECTL0);\n\t\tregval &= ~USB3_DEEMPHASIS_MASK;\n\t\tregval |= USB3_DEEMPHASIS0;\n\t\tregval |= USB3_TX_MARGIN1;\n\t\twritel(regval, histb->ctrl + REG_GUSB3PIPECTL0);\n\t}\n\n\twritel(0x23100000, histb->ctrl + GTXTHRCFG);\n\twritel(0x23100000, histb->ctrl + GRXTHRCFG);\n\n\treturn 0;\n}\n\nstatic int xhci_histb_clks_get(struct xhci_hcd_histb *histb)\n{\n\tstruct device *dev = histb->dev;\n\n\thistb->bus_clk = devm_clk_get(dev, \"bus\");\n\tif (IS_ERR(histb->bus_clk)) {\n\t\tdev_err(dev, \"fail to get bus clk\\n\");\n\t\treturn PTR_ERR(histb->bus_clk);\n\t}\n\n\thistb->utmi_clk = devm_clk_get(dev, \"utmi\");\n\tif (IS_ERR(histb->utmi_clk)) {\n\t\tdev_err(dev, \"fail to get utmi clk\\n\");\n\t\treturn PTR_ERR(histb->utmi_clk);\n\t}\n\n\thistb->pipe_clk = devm_clk_get(dev, \"pipe\");\n\tif (IS_ERR(histb->pipe_clk)) {\n\t\tdev_err(dev, \"fail to get pipe clk\\n\");\n\t\treturn PTR_ERR(histb->pipe_clk);\n\t}\n\n\thistb->suspend_clk = devm_clk_get(dev, \"suspend\");\n\tif (IS_ERR(histb->suspend_clk)) {\n\t\tdev_err(dev, \"fail to get suspend clk\\n\");\n\t\treturn PTR_ERR(histb->suspend_clk);\n\t}\n\n\treturn 0;\n}\n\nstatic int xhci_histb_host_enable(struct xhci_hcd_histb *histb)\n{\n\tint ret;\n\n\tret = clk_prepare_enable(histb->bus_clk);\n\tif (ret) {\n\t\tdev_err(histb->dev, \"failed to enable bus clk\\n\");\n\t\treturn ret;\n\t}\n\n\tret = clk_prepare_enable(histb->utmi_clk);\n\tif (ret) {\n\t\tdev_err(histb->dev, \"failed to enable utmi clk\\n\");\n\t\tgoto err_utmi_clk;\n\t}\n\n\tret = clk_prepare_enable(histb->pipe_clk);\n\tif (ret) {\n\t\tdev_err(histb->dev, \"failed to enable pipe clk\\n\");\n\t\tgoto err_pipe_clk;\n\t}\n\n\tret = clk_prepare_enable(histb->suspend_clk);\n\tif (ret) {\n\t\tdev_err(histb->dev, \"failed to enable suspend clk\\n\");\n\t\tgoto err_suspend_clk;\n\t}\n\n\treset_control_deassert(histb->soft_reset);\n\n\treturn 0;\n\nerr_suspend_clk:\n\tclk_disable_unprepare(histb->pipe_clk);\nerr_pipe_clk:\n\tclk_disable_unprepare(histb->utmi_clk);\nerr_utmi_clk:\n\tclk_disable_unprepare(histb->bus_clk);\n\n\treturn ret;\n}\n\nstatic void xhci_histb_host_disable(struct xhci_hcd_histb *histb)\n{\n\treset_control_assert(histb->soft_reset);\n\n\tclk_disable_unprepare(histb->suspend_clk);\n\tclk_disable_unprepare(histb->pipe_clk);\n\tclk_disable_unprepare(histb->utmi_clk);\n\tclk_disable_unprepare(histb->bus_clk);\n}\n\n \nstatic int xhci_histb_setup(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd_histb *histb = hcd_to_histb(hcd);\n\tint ret;\n\n\tif (usb_hcd_is_primary_hcd(hcd)) {\n\t\tret = xhci_histb_config(histb);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn xhci_gen_setup(hcd, NULL);\n}\n\nstatic const struct xhci_driver_overrides xhci_histb_overrides __initconst = {\n\t.reset = xhci_histb_setup,\n};\n\nstatic struct hc_driver __read_mostly xhci_histb_hc_driver;\nstatic int xhci_histb_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct xhci_hcd_histb *histb;\n\tconst struct hc_driver *driver;\n\tstruct usb_hcd *hcd;\n\tstruct xhci_hcd *xhci;\n\tstruct resource *res;\n\tint irq;\n\tint ret = -ENODEV;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdriver = &xhci_histb_hc_driver;\n\thistb = devm_kzalloc(dev, sizeof(*histb), GFP_KERNEL);\n\tif (!histb)\n\t\treturn -ENOMEM;\n\n\thistb->dev = dev;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thistb->ctrl = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(histb->ctrl))\n\t\treturn PTR_ERR(histb->ctrl);\n\n\tret = xhci_histb_clks_get(histb);\n\tif (ret)\n\t\treturn ret;\n\n\thistb->soft_reset = devm_reset_control_get(dev, \"soft\");\n\tif (IS_ERR(histb->soft_reset)) {\n\t\tdev_err(dev, \"failed to get soft reset\\n\");\n\t\treturn PTR_ERR(histb->soft_reset);\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\tdevice_enable_async_suspend(dev);\n\n\t \n\tret = dma_set_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\tgoto disable_pm;\n\n\thcd = usb_create_hcd(driver, dev, dev_name(dev));\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_pm;\n\t}\n\n\thcd->regs = histb->ctrl;\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\thistb->hcd = hcd;\n\tdev_set_drvdata(hcd->self.controller, histb);\n\n\tret = xhci_histb_host_enable(histb);\n\tif (ret)\n\t\tgoto put_hcd;\n\n\txhci = hcd_to_xhci(hcd);\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\txhci->main_hcd = hcd;\n\txhci->shared_hcd = usb_create_shared_hcd(driver, dev, dev_name(dev),\n\t\t\t\t\t\t hcd);\n\tif (!xhci->shared_hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_host;\n\t}\n\n\tif (device_property_read_bool(dev, \"usb2-lpm-disable\"))\n\t\txhci->quirks |= XHCI_HW_LPM_DISABLE;\n\n\tif (device_property_read_bool(dev, \"usb3-lpm-capable\"))\n\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n\n\t \n\txhci->imod_interval = 40000;\n\tdevice_property_read_u32(dev, \"imod-interval-ns\",\n\t\t\t\t &xhci->imod_interval);\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret)\n\t\tgoto put_usb3_hcd;\n\n\tif (HCC_MAX_PSA(xhci->hcc_params) >= 4)\n\t\txhci->shared_hcd->can_do_streams = 1;\n\n\tret = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);\n\tif (ret)\n\t\tgoto dealloc_usb2_hcd;\n\n\tdevice_enable_async_suspend(dev);\n\tpm_runtime_put_noidle(dev);\n\n\t \n\tpm_runtime_forbid(dev);\n\n\treturn 0;\n\ndealloc_usb2_hcd:\n\tusb_remove_hcd(hcd);\nput_usb3_hcd:\n\tusb_put_hcd(xhci->shared_hcd);\ndisable_host:\n\txhci_histb_host_disable(histb);\nput_hcd:\n\tusb_put_hcd(hcd);\ndisable_pm:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\n\treturn ret;\n}\n\nstatic void xhci_histb_remove(struct platform_device *dev)\n{\n\tstruct xhci_hcd_histb *histb = platform_get_drvdata(dev);\n\tstruct usb_hcd *hcd = histb->hcd;\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tstruct usb_hcd *shared_hcd = xhci->shared_hcd;\n\n\txhci->xhc_state |= XHCI_STATE_REMOVING;\n\n\tusb_remove_hcd(shared_hcd);\n\txhci->shared_hcd = NULL;\n\tdevice_wakeup_disable(&dev->dev);\n\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(shared_hcd);\n\n\txhci_histb_host_disable(histb);\n\tusb_put_hcd(hcd);\n\tpm_runtime_put_sync(&dev->dev);\n\tpm_runtime_disable(&dev->dev);\n}\n\nstatic int __maybe_unused xhci_histb_suspend(struct device *dev)\n{\n\tstruct xhci_hcd_histb *histb = dev_get_drvdata(dev);\n\tstruct usb_hcd *hcd = histb->hcd;\n\tstruct xhci_hcd\t*xhci = hcd_to_xhci(hcd);\n\tint ret;\n\n\tret = xhci_suspend(xhci, device_may_wakeup(dev));\n\n\tif (!device_may_wakeup(dev))\n\t\txhci_histb_host_disable(histb);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused xhci_histb_resume(struct device *dev)\n{\n\tstruct xhci_hcd_histb *histb = dev_get_drvdata(dev);\n\tstruct usb_hcd *hcd = histb->hcd;\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\n\tif (!device_may_wakeup(dev))\n\t\txhci_histb_host_enable(histb);\n\n\treturn xhci_resume(xhci, PMSG_RESUME);\n}\n\nstatic const struct dev_pm_ops xhci_histb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(xhci_histb_suspend, xhci_histb_resume)\n};\n#define DEV_PM_OPS (IS_ENABLED(CONFIG_PM) ? &xhci_histb_pm_ops : NULL)\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id histb_xhci_of_match[] = {\n\t{ .compatible = \"hisilicon,hi3798cv200-xhci\"},\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, histb_xhci_of_match);\n#endif\n\nstatic struct platform_driver histb_xhci_driver = {\n\t.probe\t= xhci_histb_probe,\n\t.remove_new = xhci_histb_remove,\n\t.driver\t= {\n\t\t.name = \"xhci-histb\",\n\t\t.pm = DEV_PM_OPS,\n\t\t.of_match_table = of_match_ptr(histb_xhci_of_match),\n\t},\n};\nMODULE_ALIAS(\"platform:xhci-histb\");\n\nstatic int __init xhci_histb_init(void)\n{\n\txhci_init_driver(&xhci_histb_hc_driver, &xhci_histb_overrides);\n\treturn platform_driver_register(&histb_xhci_driver);\n}\nmodule_init(xhci_histb_init);\n\nstatic void __exit xhci_histb_exit(void)\n{\n\tplatform_driver_unregister(&histb_xhci_driver);\n}\nmodule_exit(xhci_histb_exit);\n\nMODULE_DESCRIPTION(\"HiSilicon STB xHCI Host Controller Driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}