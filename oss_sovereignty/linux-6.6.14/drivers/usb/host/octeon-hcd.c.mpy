{
  "module_name": "octeon-hcd.c",
  "hash_id": "9cd543e31ce9e7e87a0aedd52f944d4c067e41d972f71293ee21d8646177ddc3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/octeon-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/usb.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/usb/hcd.h>\n#include <linux/prefetch.h>\n#include <linux/irqdomain.h>\n#include <linux/dma-mapping.h>\n#include <linux/platform_device.h>\n#include <linux/of.h>\n\n#include <asm/octeon/octeon.h>\n\n#include \"octeon-hcd.h\"\n\n \nenum cvmx_usb_speed {\n\tCVMX_USB_SPEED_HIGH = 0,\n\tCVMX_USB_SPEED_FULL = 1,\n\tCVMX_USB_SPEED_LOW = 2,\n};\n\n \nenum cvmx_usb_transfer {\n\tCVMX_USB_TRANSFER_CONTROL = 0,\n\tCVMX_USB_TRANSFER_ISOCHRONOUS = 1,\n\tCVMX_USB_TRANSFER_BULK = 2,\n\tCVMX_USB_TRANSFER_INTERRUPT = 3,\n};\n\n \nenum cvmx_usb_direction {\n\tCVMX_USB_DIRECTION_OUT,\n\tCVMX_USB_DIRECTION_IN,\n};\n\n \nenum cvmx_usb_status {\n\tCVMX_USB_STATUS_OK,\n\tCVMX_USB_STATUS_SHORT,\n\tCVMX_USB_STATUS_CANCEL,\n\tCVMX_USB_STATUS_ERROR,\n\tCVMX_USB_STATUS_STALL,\n\tCVMX_USB_STATUS_XACTERR,\n\tCVMX_USB_STATUS_DATATGLERR,\n\tCVMX_USB_STATUS_BABBLEERR,\n\tCVMX_USB_STATUS_FRAMEERR,\n};\n\n \nstruct cvmx_usb_port_status {\n\tu32 reserved\t\t\t: 25;\n\tu32 port_enabled\t\t: 1;\n\tu32 port_over_current\t\t: 1;\n\tu32 port_powered\t\t: 1;\n\tenum cvmx_usb_speed port_speed\t: 2;\n\tu32 connected\t\t\t: 1;\n\tu32 connect_change\t\t: 1;\n};\n\n \nstruct cvmx_usb_iso_packet {\n\tint offset;\n\tint length;\n\tenum cvmx_usb_status status;\n};\n\n \nenum cvmx_usb_initialize_flags {\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI\t\t= 1 << 0,\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND\t\t= 1 << 1,\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK\t= 3 << 3,\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ\t\t= 1 << 3,\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ\t\t= 2 << 3,\n\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ\t\t= 3 << 3,\n\t \n\tCVMX_USB_INITIALIZE_FLAGS_NO_DMA\t\t= 1 << 5,\n};\n\n \nenum cvmx_usb_pipe_flags {\n\tCVMX_USB_PIPE_FLAGS_SCHEDULED\t= 1 << 17,\n\tCVMX_USB_PIPE_FLAGS_NEED_PING\t= 1 << 18,\n};\n\n \n#define MAX_RETRIES\t\t3\n\n \n#define MAX_CHANNELS\t\t8\n\n \n#define MAX_TRANSFER_BYTES\t((1 << 19) - 1)\n\n \n#define MAX_TRANSFER_PACKETS\t((1 << 10) - 1)\n\n \nenum cvmx_usb_stage {\n\tCVMX_USB_STAGE_NON_CONTROL,\n\tCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE,\n\tCVMX_USB_STAGE_SETUP,\n\tCVMX_USB_STAGE_SETUP_SPLIT_COMPLETE,\n\tCVMX_USB_STAGE_DATA,\n\tCVMX_USB_STAGE_DATA_SPLIT_COMPLETE,\n\tCVMX_USB_STAGE_STATUS,\n\tCVMX_USB_STAGE_STATUS_SPLIT_COMPLETE,\n};\n\n \nstruct cvmx_usb_transaction {\n\tstruct list_head node;\n\tenum cvmx_usb_transfer type;\n\tu64 buffer;\n\tint buffer_length;\n\tu64 control_header;\n\tint iso_start_frame;\n\tint iso_number_packets;\n\tstruct cvmx_usb_iso_packet *iso_packets;\n\tint xfersize;\n\tint pktcnt;\n\tint retries;\n\tint actual_bytes;\n\tenum cvmx_usb_stage stage;\n\tstruct urb *urb;\n};\n\n \nstruct cvmx_usb_pipe {\n\tstruct list_head node;\n\tstruct list_head transactions;\n\tu64 interval;\n\tu64 next_tx_frame;\n\tenum cvmx_usb_pipe_flags flags;\n\tenum cvmx_usb_speed device_speed;\n\tenum cvmx_usb_transfer transfer_type;\n\tenum cvmx_usb_direction transfer_dir;\n\tint multi_count;\n\tu16 max_packet;\n\tu8 device_addr;\n\tu8 endpoint_num;\n\tu8 hub_device_addr;\n\tu8 hub_port;\n\tu8 pid_toggle;\n\tu8 channel;\n\ts8 split_sc_frame;\n};\n\nstruct cvmx_usb_tx_fifo {\n\tstruct {\n\t\tint channel;\n\t\tint size;\n\t\tu64 address;\n\t} entry[MAX_CHANNELS + 1];\n\tint head;\n\tint tail;\n};\n\n \nstruct octeon_hcd {\n\tspinlock_t lock;  \n\tint init_flags;\n\tint index;\n\tint idle_hardware_channels;\n\tunion cvmx_usbcx_hprt usbcx_hprt;\n\tstruct cvmx_usb_pipe *pipe_for_channel[MAX_CHANNELS];\n\tint indent;\n\tstruct cvmx_usb_port_status port_status;\n\tstruct list_head idle_pipes;\n\tstruct list_head active_pipes[4];\n\tu64 frame_number;\n\tstruct cvmx_usb_transaction *active_split;\n\tstruct cvmx_usb_tx_fifo periodic;\n\tstruct cvmx_usb_tx_fifo nonperiodic;\n};\n\n \n#define USB_SET_FIELD32(address, _union, field, value)\t\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tunion _union c;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\\\n\t\tc.u32 = cvmx_usb_read_csr32(usb, address);\t\\\n\t\tc.s.field = value;\t\t\t\t\\\n\t\tcvmx_usb_write_csr32(usb, address, c.u32);\t\\\n\t} while (0)\n\n \n#define USB_FIFO_ADDRESS(channel, usb_index) \\\n\t(CVMX_USBCX_GOTGCTL(usb_index) + ((channel) + 1) * 0x1000)\n\n \nstruct octeon_temp_buffer {\n\tvoid *orig_buffer;\n\tu8 data[];\n};\n\nstatic inline struct usb_hcd *octeon_to_hcd(struct octeon_hcd *p)\n{\n\treturn container_of((void *)p, struct usb_hcd, hcd_priv);\n}\n\n \nstatic int octeon_alloc_temp_buffer(struct urb *urb, gfp_t mem_flags)\n{\n\tstruct octeon_temp_buffer *temp;\n\n\tif (urb->num_sgs || urb->sg ||\n\t    (urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) ||\n\t    !(urb->transfer_buffer_length % sizeof(u32)))\n\t\treturn 0;\n\n\ttemp = kmalloc(ALIGN(urb->transfer_buffer_length, sizeof(u32)) +\n\t\t       sizeof(*temp), mem_flags);\n\tif (!temp)\n\t\treturn -ENOMEM;\n\n\ttemp->orig_buffer = urb->transfer_buffer;\n\tif (usb_urb_dir_out(urb))\n\t\tmemcpy(temp->data, urb->transfer_buffer,\n\t\t       urb->transfer_buffer_length);\n\turb->transfer_buffer = temp->data;\n\turb->transfer_flags |= URB_ALIGNED_TEMP_BUFFER;\n\n\treturn 0;\n}\n\n \nstatic void octeon_free_temp_buffer(struct urb *urb)\n{\n\tstruct octeon_temp_buffer *temp;\n\tsize_t length;\n\n\tif (!(urb->transfer_flags & URB_ALIGNED_TEMP_BUFFER))\n\t\treturn;\n\n\ttemp = container_of(urb->transfer_buffer, struct octeon_temp_buffer,\n\t\t\t    data);\n\tif (usb_urb_dir_in(urb)) {\n\t\tif (usb_pipeisoc(urb->pipe))\n\t\t\tlength = urb->transfer_buffer_length;\n\t\telse\n\t\t\tlength = urb->actual_length;\n\n\t\tmemcpy(temp->orig_buffer, urb->transfer_buffer, length);\n\t}\n\turb->transfer_buffer = temp->orig_buffer;\n\turb->transfer_flags &= ~URB_ALIGNED_TEMP_BUFFER;\n\tkfree(temp);\n}\n\n \nstatic int octeon_map_urb_for_dma(struct usb_hcd *hcd, struct urb *urb,\n\t\t\t\t  gfp_t mem_flags)\n{\n\tint ret;\n\n\tret = octeon_alloc_temp_buffer(urb, mem_flags);\n\tif (ret)\n\t\treturn ret;\n\n\tret = usb_hcd_map_urb_for_dma(hcd, urb, mem_flags);\n\tif (ret)\n\t\tocteon_free_temp_buffer(urb);\n\n\treturn ret;\n}\n\n \nstatic void octeon_unmap_urb_for_dma(struct usb_hcd *hcd, struct urb *urb)\n{\n\tusb_hcd_unmap_urb_for_dma(hcd, urb);\n\tocteon_free_temp_buffer(urb);\n}\n\n \nstatic inline u32 cvmx_usb_read_csr32(struct octeon_hcd *usb, u64 address)\n{\n\treturn cvmx_read64_uint32(address ^ 4);\n}\n\n \nstatic inline void cvmx_usb_write_csr32(struct octeon_hcd *usb,\n\t\t\t\t\tu64 address, u32 value)\n{\n\tcvmx_write64_uint32(address ^ 4, value);\n\tcvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));\n}\n\n \nstatic inline int cvmx_usb_pipe_needs_split(struct octeon_hcd *usb,\n\t\t\t\t\t    struct cvmx_usb_pipe *pipe)\n{\n\treturn pipe->device_speed != CVMX_USB_SPEED_HIGH &&\n\t       usb->usbcx_hprt.s.prtspd == CVMX_USB_SPEED_HIGH;\n}\n\n \nstatic inline int cvmx_usb_get_data_pid(struct cvmx_usb_pipe *pipe)\n{\n\tif (pipe->pid_toggle)\n\t\treturn 2;  \n\treturn 0;  \n}\n\n \nstatic int cvmx_wait_tx_rx(struct octeon_hcd *usb, int fflsh_type)\n{\n\tint result;\n\tu64 address = CVMX_USBCX_GRSTCTL(usb->index);\n\tu64 done = cvmx_get_cycle() + 100 *\n\t\t   (u64)octeon_get_clock_rate / 1000000;\n\tunion cvmx_usbcx_grstctl c;\n\n\twhile (1) {\n\t\tc.u32 = cvmx_usb_read_csr32(usb, address);\n\t\tif (fflsh_type == 0 && c.s.txfflsh == 0) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t} else if (fflsh_type == 1 && c.s.rxfflsh == 0) {\n\t\t\tresult = 0;\n\t\t\tbreak;\n\t\t} else if (cvmx_get_cycle() > done) {\n\t\t\tresult = -1;\n\t\t\tbreak;\n\t\t}\n\n\t\t__delay(100);\n\t}\n\treturn result;\n}\n\nstatic void cvmx_fifo_setup(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbcx_ghwcfg3 usbcx_ghwcfg3;\n\tunion cvmx_usbcx_gnptxfsiz npsiz;\n\tunion cvmx_usbcx_hptxfsiz psiz;\n\n\tusbcx_ghwcfg3.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\tCVMX_USBCX_GHWCFG3(usb->index));\n\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_GRXFSIZ(usb->index), cvmx_usbcx_grxfsiz,\n\t\t\trxfdep, usbcx_ghwcfg3.s.dfifodepth / 4);\n\n\t \n\tnpsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index));\n\tnpsiz.s.nptxfdep = usbcx_ghwcfg3.s.dfifodepth / 2;\n\tnpsiz.s.nptxfstaddr = usbcx_ghwcfg3.s.dfifodepth / 4;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GNPTXFSIZ(usb->index), npsiz.u32);\n\n\t \n\tpsiz.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index));\n\tpsiz.s.ptxfsize = usbcx_ghwcfg3.s.dfifodepth / 4;\n\tpsiz.s.ptxfstaddr = 3 * usbcx_ghwcfg3.s.dfifodepth / 4;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HPTXFSIZ(usb->index), psiz.u32);\n\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\n\t\t\tcvmx_usbcx_grstctl, txfnum, 0x10);\n\tUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\n\t\t\tcvmx_usbcx_grstctl, txfflsh, 1);\n\tcvmx_wait_tx_rx(usb, 0);\n\tUSB_SET_FIELD32(CVMX_USBCX_GRSTCTL(usb->index),\n\t\t\tcvmx_usbcx_grstctl, rxfflsh, 1);\n\tcvmx_wait_tx_rx(usb, 1);\n}\n\n \nstatic int cvmx_usb_shutdown(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbnx_clk_ctl usbn_clk_ctl;\n\n\t \n\tif (!list_empty(&usb->idle_pipes) ||\n\t    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_ISOCHRONOUS]) ||\n\t    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_INTERRUPT]) ||\n\t    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_CONTROL]) ||\n\t    !list_empty(&usb->active_pipes[CVMX_USB_TRANSFER_BULK]))\n\t\treturn -EBUSY;\n\n\t \n\tusbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));\n\tusbn_clk_ctl.s.enable = 1;\n\tusbn_clk_ctl.s.por = 1;\n\tusbn_clk_ctl.s.hclk_rst = 1;\n\tusbn_clk_ctl.s.prst = 0;\n\tusbn_clk_ctl.s.hrst = 0;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\treturn 0;\n}\n\n \nstatic int cvmx_usb_initialize(struct device *dev,\n\t\t\t       struct octeon_hcd *usb)\n{\n\tint channel;\n\tint divisor;\n\tint retries = 0;\n\tunion cvmx_usbcx_hcfg usbcx_hcfg;\n\tunion cvmx_usbnx_clk_ctl usbn_clk_ctl;\n\tunion cvmx_usbcx_gintsts usbc_gintsts;\n\tunion cvmx_usbcx_gahbcfg usbcx_gahbcfg;\n\tunion cvmx_usbcx_gintmsk usbcx_gintmsk;\n\tunion cvmx_usbcx_gusbcfg usbcx_gusbcfg;\n\tunion cvmx_usbnx_usbp_ctl_status usbn_usbp_ctl_status;\n\nretry:\n\t \n\tusbn_clk_ctl.u64 = cvmx_read64_uint64(CVMX_USBNX_CLK_CTL(usb->index));\n\tusbn_clk_ctl.s.por = 1;\n\tusbn_clk_ctl.s.hrst = 0;\n\tusbn_clk_ctl.s.prst = 0;\n\tusbn_clk_ctl.s.hclk_rst = 0;\n\tusbn_clk_ctl.s.enable = 0;\n\t \n\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND) {\n\t\t \n\t\tif (OCTEON_IS_MODEL(OCTEON_CN3XXX) ||\n\t\t    OCTEON_IS_MODEL(OCTEON_CN56XX) ||\n\t\t    OCTEON_IS_MODEL(OCTEON_CN50XX))\n\t\t\t \n\t\t\tusbn_clk_ctl.s.p_rtype = 2;  \n\t\telse\n\t\t\t \n\t\t\tusbn_clk_ctl.s.p_rtype = 1;\n\n\t\tswitch (usb->init_flags &\n\t\t\tCVMX_USB_INITIALIZE_FLAGS_CLOCK_MHZ_MASK) {\n\t\tcase CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ:\n\t\t\tusbn_clk_ctl.s.p_c_sel = 0;\n\t\t\tbreak;\n\t\tcase CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ:\n\t\t\tusbn_clk_ctl.s.p_c_sel = 1;\n\t\t\tbreak;\n\t\tcase CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ:\n\t\t\tusbn_clk_ctl.s.p_c_sel = 2;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t \n\t\tif (OCTEON_IS_MODEL(OCTEON_CN3XXX))\n\t\t\t \n\t\t\tusbn_clk_ctl.s.p_rtype = 3;  \n\t\telse\n\t\t\t \n\t\t\tusbn_clk_ctl.s.p_rtype = 0;\n\n\t\tusbn_clk_ctl.s.p_c_sel = 0;\n\t}\n\t \n\tdivisor = DIV_ROUND_UP(octeon_get_clock_rate(), 125000000);\n\t \n\tif (divisor < 4)\n\t\tdivisor = 4;\n\tusbn_clk_ctl.s.divide = divisor;\n\tusbn_clk_ctl.s.divide2 = 0;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\n\t \n\tusbn_clk_ctl.s.hclk_rst = 1;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\t \n\t__delay(64);\n\t \n\tusbn_clk_ctl.s.por = 0;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\t \n\tmdelay(1);\n\t \n\tusbn_usbp_ctl_status.u64 =\n\t\tcvmx_read64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index));\n\tusbn_usbp_ctl_status.s.ate_reset = 1;\n\tcvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\n\t\t\t    usbn_usbp_ctl_status.u64);\n\t \n\t__delay(10);\n\t \n\tusbn_usbp_ctl_status.s.ate_reset = 0;\n\tcvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\n\t\t\t    usbn_usbp_ctl_status.u64);\n\t \n\tusbn_clk_ctl.s.prst = 1;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\t \n\tusbn_usbp_ctl_status.s.hst_mode = 0;\n\tcvmx_write64_uint64(CVMX_USBNX_USBP_CTL_STATUS(usb->index),\n\t\t\t    usbn_usbp_ctl_status.u64);\n\t \n\tudelay(1);\n\t \n\tusbn_clk_ctl.s.hrst = 1;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\t \n\tusbn_clk_ctl.s.enable = 1;\n\tcvmx_write64_uint64(CVMX_USBNX_CLK_CTL(usb->index), usbn_clk_ctl.u64);\n\tudelay(1);\n\n\t \n\tusbcx_gahbcfg.u32 = 0;\n\tusbcx_gahbcfg.s.dmaen = !(usb->init_flags &\n\t\t\t\t  CVMX_USB_INITIALIZE_FLAGS_NO_DMA);\n\tusbcx_gahbcfg.s.hbstlen = 0;\n\tusbcx_gahbcfg.s.nptxfemplvl = 1;\n\tusbcx_gahbcfg.s.ptxfemplvl = 1;\n\tusbcx_gahbcfg.s.glblintrmsk = 1;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GAHBCFG(usb->index),\n\t\t\t     usbcx_gahbcfg.u32);\n\n\t \n\tusbcx_gusbcfg.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\tCVMX_USBCX_GUSBCFG(usb->index));\n\tusbcx_gusbcfg.s.toutcal = 0;\n\tusbcx_gusbcfg.s.ddrsel = 0;\n\tusbcx_gusbcfg.s.usbtrdtim = 0x5;\n\tusbcx_gusbcfg.s.phylpwrclksel = 0;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GUSBCFG(usb->index),\n\t\t\t     usbcx_gusbcfg.u32);\n\n\t \n\tusbcx_gintmsk.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\tCVMX_USBCX_GINTMSK(usb->index));\n\tusbcx_gintmsk.s.otgintmsk = 1;\n\tusbcx_gintmsk.s.modemismsk = 1;\n\tusbcx_gintmsk.s.hchintmsk = 1;\n\tusbcx_gintmsk.s.sofmsk = 0;\n\t \n\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\n\t\tusbcx_gintmsk.s.rxflvlmsk = 1;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GINTMSK(usb->index),\n\t\t\t     usbcx_gintmsk.u32);\n\n\t \n\tfor (channel = 0; channel < 8; channel++)\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCINTMSKX(channel, usb->index),\n\t\t\t\t     0);\n\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\tcvmx_usbcx_gintmsk, prtintmsk, 1);\n\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\tcvmx_usbcx_gintmsk, disconnintmsk, 1);\n\n\t \n\tusbcx_hcfg.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HCFG(usb->index));\n\tusbcx_hcfg.s.fslssupp = 0;\n\tusbcx_hcfg.s.fslspclksel = 0;\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HCFG(usb->index), usbcx_hcfg.u32);\n\n\tcvmx_fifo_setup(usb);\n\n\t \n\tusbc_gintsts.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t       CVMX_USBCX_GINTSTS(usb->index));\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),\n\t\t\t     usbc_gintsts.u32);\n\tdev_dbg(dev, \"gintsts after reset: 0x%x\\n\", (int)usbc_gintsts.u32);\n\tif (!usbc_gintsts.s.disconnint && !usbc_gintsts.s.prtint)\n\t\treturn 0;\n\tif (retries++ >= 5)\n\t\treturn -EAGAIN;\n\tdev_info(dev, \"controller reset failed (gintsts=0x%x) - retrying\\n\",\n\t\t (int)usbc_gintsts.u32);\n\tmsleep(50);\n\tcvmx_usb_shutdown(usb);\n\tmsleep(50);\n\tgoto retry;\n}\n\n \nstatic void cvmx_usb_reset_port(struct octeon_hcd *usb)\n{\n\tusb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t  CVMX_USBCX_HPRT(usb->index));\n\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\n\t\t\tprtrst, 1);\n\n\t \n\tmdelay(50);\n\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\n\t\t\tprtrst, 0);\n\n\t \n\tusb->usbcx_hprt.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t  CVMX_USBCX_HPRT(usb->index));\n}\n\n \nstatic int cvmx_usb_disable(struct octeon_hcd *usb)\n{\n\t \n\tUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index), cvmx_usbcx_hprt,\n\t\t\tprtena, 1);\n\treturn 0;\n}\n\n \nstatic struct cvmx_usb_port_status cvmx_usb_get_status(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbcx_hprt usbc_hprt;\n\tstruct cvmx_usb_port_status result;\n\n\tmemset(&result, 0, sizeof(result));\n\n\tusbc_hprt.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));\n\tresult.port_enabled = usbc_hprt.s.prtena;\n\tresult.port_over_current = usbc_hprt.s.prtovrcurract;\n\tresult.port_powered = usbc_hprt.s.prtpwr;\n\tresult.port_speed = usbc_hprt.s.prtspd;\n\tresult.connected = usbc_hprt.s.prtconnsts;\n\tresult.connect_change =\n\t\tresult.connected != usb->port_status.connected;\n\n\treturn result;\n}\n\n \nstatic struct cvmx_usb_pipe *cvmx_usb_open_pipe(struct octeon_hcd *usb,\n\t\t\t\t\t\tint device_addr,\n\t\t\t\t\t\tint endpoint_num,\n\t\t\t\t\t\tenum cvmx_usb_speed\n\t\t\t\t\t\t\tdevice_speed,\n\t\t\t\t\t\tint max_packet,\n\t\t\t\t\t\tenum cvmx_usb_transfer\n\t\t\t\t\t\t\ttransfer_type,\n\t\t\t\t\t\tenum cvmx_usb_direction\n\t\t\t\t\t\t\ttransfer_dir,\n\t\t\t\t\t\tint interval, int multi_count,\n\t\t\t\t\t\tint hub_device_addr,\n\t\t\t\t\t\tint hub_port)\n{\n\tstruct cvmx_usb_pipe *pipe;\n\n\tpipe = kzalloc(sizeof(*pipe), GFP_ATOMIC);\n\tif (!pipe)\n\t\treturn NULL;\n\tif ((device_speed == CVMX_USB_SPEED_HIGH) &&\n\t    (transfer_dir == CVMX_USB_DIRECTION_OUT) &&\n\t    (transfer_type == CVMX_USB_TRANSFER_BULK))\n\t\tpipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;\n\tpipe->device_addr = device_addr;\n\tpipe->endpoint_num = endpoint_num;\n\tpipe->device_speed = device_speed;\n\tpipe->max_packet = max_packet;\n\tpipe->transfer_type = transfer_type;\n\tpipe->transfer_dir = transfer_dir;\n\tINIT_LIST_HEAD(&pipe->transactions);\n\n\t \n\tif (!interval)\n\t\tinterval = 1;\n\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\tpipe->interval = interval * 8;\n\t\t \n\t\tpipe->next_tx_frame = ((usb->frame_number + 7) & ~7) +\n\t\t\t\t\tpipe->interval;\n\t} else {\n\t\tpipe->interval = interval;\n\t\tpipe->next_tx_frame = usb->frame_number + pipe->interval;\n\t}\n\tpipe->multi_count = multi_count;\n\tpipe->hub_device_addr = hub_device_addr;\n\tpipe->hub_port = hub_port;\n\tpipe->pid_toggle = 0;\n\tpipe->split_sc_frame = -1;\n\tlist_add_tail(&pipe->node, &usb->idle_pipes);\n\n\t \n\n\treturn pipe;\n}\n\n \nstatic void cvmx_usb_poll_rx_fifo(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbcx_grxstsph rx_status;\n\tint channel;\n\tint bytes;\n\tu64 address;\n\tu32 *ptr;\n\n\trx_status.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t    CVMX_USBCX_GRXSTSPH(usb->index));\n\t \n\tif (rx_status.s.pktsts != 2)\n\t\treturn;\n\t \n\tif (!rx_status.s.bcnt)\n\t\treturn;\n\n\tchannel = rx_status.s.chnum;\n\tbytes = rx_status.s.bcnt;\n\tif (!bytes)\n\t\treturn;\n\n\t \n\taddress = cvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) +\n\t\t\t\t     channel * 8);\n\n\tptr = cvmx_phys_to_ptr(address);\n\tcvmx_write64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index) + channel * 8,\n\t\t\t    address + bytes);\n\n\t \n\twhile (bytes > 0) {\n\t\t*ptr++ = cvmx_usb_read_csr32(usb,\n\t\t\t\t\tUSB_FIFO_ADDRESS(channel, usb->index));\n\t\tbytes -= 4;\n\t}\n\tCVMX_SYNCW;\n}\n\n \nstatic int cvmx_usb_fill_tx_hw(struct octeon_hcd *usb,\n\t\t\t       struct cvmx_usb_tx_fifo *fifo, int available)\n{\n\t \n\twhile (available && (fifo->head != fifo->tail)) {\n\t\tint i = fifo->tail;\n\t\tconst u32 *ptr = cvmx_phys_to_ptr(fifo->entry[i].address);\n\t\tu64 csr_address = USB_FIFO_ADDRESS(fifo->entry[i].channel,\n\t\t\t\t\t\t   usb->index) ^ 4;\n\t\tint words = available;\n\n\t\t \n\t\tif (fifo->entry[i].size <= available) {\n\t\t\twords = fifo->entry[i].size;\n\t\t\tfifo->tail++;\n\t\t\tif (fifo->tail > MAX_CHANNELS)\n\t\t\t\tfifo->tail = 0;\n\t\t}\n\n\t\t \n\t\tavailable -= words;\n\t\tfifo->entry[i].address += words * 4;\n\t\tfifo->entry[i].size -= words;\n\n\t\t \n\t\twhile (words > 3) {\n\t\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\t\tcvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));\n\t\t\twords -= 3;\n\t\t}\n\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\tif (--words) {\n\t\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\t\tif (--words)\n\t\t\t\tcvmx_write64_uint32(csr_address, *ptr++);\n\t\t}\n\t\tcvmx_read64_uint64(CVMX_USBNX_DMA0_INB_CHN0(usb->index));\n\t}\n\treturn fifo->head != fifo->tail;\n}\n\n \nstatic void cvmx_usb_poll_tx_fifo(struct octeon_hcd *usb)\n{\n\tif (usb->periodic.head != usb->periodic.tail) {\n\t\tunion cvmx_usbcx_hptxsts tx_status;\n\n\t\ttx_status.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t    CVMX_USBCX_HPTXSTS(usb->index));\n\t\tif (cvmx_usb_fill_tx_hw(usb, &usb->periodic,\n\t\t\t\t\ttx_status.s.ptxfspcavail))\n\t\t\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\t\t\tcvmx_usbcx_gintmsk, ptxfempmsk, 1);\n\t\telse\n\t\t\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\t\t\tcvmx_usbcx_gintmsk, ptxfempmsk, 0);\n\t}\n\n\tif (usb->nonperiodic.head != usb->nonperiodic.tail) {\n\t\tunion cvmx_usbcx_gnptxsts tx_status;\n\n\t\ttx_status.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t    CVMX_USBCX_GNPTXSTS(usb->index));\n\t\tif (cvmx_usb_fill_tx_hw(usb, &usb->nonperiodic,\n\t\t\t\t\ttx_status.s.nptxfspcavail))\n\t\t\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\t\t\tcvmx_usbcx_gintmsk, nptxfempmsk, 1);\n\t\telse\n\t\t\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\t\t\tcvmx_usbcx_gintmsk, nptxfempmsk, 0);\n\t}\n}\n\n \nstatic void cvmx_usb_fill_tx_fifo(struct octeon_hcd *usb, int channel)\n{\n\tunion cvmx_usbcx_hccharx hcchar;\n\tunion cvmx_usbcx_hcspltx usbc_hcsplt;\n\tunion cvmx_usbcx_hctsizx usbc_hctsiz;\n\tstruct cvmx_usb_tx_fifo *fifo;\n\n\t \n\thcchar.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t CVMX_USBCX_HCCHARX(channel, usb->index));\n\tif (hcchar.s.epdir != CVMX_USB_DIRECTION_OUT)\n\t\treturn;\n\n\t \n\tusbc_hcsplt.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t      CVMX_USBCX_HCSPLTX(channel, usb->index));\n\tif (usbc_hcsplt.s.spltena && usbc_hcsplt.s.compsplt)\n\t\treturn;\n\n\t \n\tusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t      CVMX_USBCX_HCTSIZX(channel, usb->index));\n\tif (!usbc_hctsiz.s.xfersize)\n\t\treturn;\n\n\tif ((hcchar.s.eptype == CVMX_USB_TRANSFER_INTERRUPT) ||\n\t    (hcchar.s.eptype == CVMX_USB_TRANSFER_ISOCHRONOUS))\n\t\tfifo = &usb->periodic;\n\telse\n\t\tfifo = &usb->nonperiodic;\n\n\tfifo->entry[fifo->head].channel = channel;\n\tfifo->entry[fifo->head].address =\n\t\tcvmx_read64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +\n\t\t\t\t   channel * 8);\n\tfifo->entry[fifo->head].size = (usbc_hctsiz.s.xfersize + 3) >> 2;\n\tfifo->head++;\n\tif (fifo->head > MAX_CHANNELS)\n\t\tfifo->head = 0;\n\n\tcvmx_usb_poll_tx_fifo(usb);\n}\n\n \nstatic void cvmx_usb_start_channel_control(struct octeon_hcd *usb,\n\t\t\t\t\t   int channel,\n\t\t\t\t\t   struct cvmx_usb_pipe *pipe)\n{\n\tstruct usb_hcd *hcd = octeon_to_hcd(usb);\n\tstruct device *dev = hcd->self.controller;\n\tstruct cvmx_usb_transaction *transaction =\n\t\tlist_first_entry(&pipe->transactions, typeof(*transaction),\n\t\t\t\t node);\n\tstruct usb_ctrlrequest *header =\n\t\tcvmx_phys_to_ptr(transaction->control_header);\n\tint bytes_to_transfer = transaction->buffer_length -\n\t\ttransaction->actual_bytes;\n\tint packets_to_transfer;\n\tunion cvmx_usbcx_hctsizx usbc_hctsiz;\n\n\tusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t      CVMX_USBCX_HCTSIZX(channel, usb->index));\n\n\tswitch (transaction->stage) {\n\tcase CVMX_USB_STAGE_NON_CONTROL:\n\tcase CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:\n\t\tdev_err(dev, \"%s: ERROR - Non control stage\\n\", __func__);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_SETUP:\n\t\tusbc_hctsiz.s.pid = 3;  \n\t\tbytes_to_transfer = sizeof(*header);\n\t\t \n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\tCVMX_USB_DIRECTION_OUT);\n\t\t \n\t\tcvmx_write64_uint64(CVMX_USBNX_DMA0_OUTB_CHN0(usb->index) +\n\t\t\t\t\tchannel * 8,\n\t\t\t\t    transaction->control_header);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:\n\t\tusbc_hctsiz.s.pid = 3;  \n\t\tbytes_to_transfer = 0;\n\t\t \n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\tCVMX_USB_DIRECTION_OUT);\n\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hcspltx, compsplt, 1);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_DATA:\n\t\tusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\tif (header->bRequestType & USB_DIR_IN)\n\t\t\t\tbytes_to_transfer = 0;\n\t\t\telse if (bytes_to_transfer > pipe->max_packet)\n\t\t\t\tbytes_to_transfer = pipe->max_packet;\n\t\t}\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\t((header->bRequestType & USB_DIR_IN) ?\n\t\t\t\t\tCVMX_USB_DIRECTION_IN :\n\t\t\t\t\tCVMX_USB_DIRECTION_OUT));\n\t\tbreak;\n\tcase CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:\n\t\tusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\n\t\tif (!(header->bRequestType & USB_DIR_IN))\n\t\t\tbytes_to_transfer = 0;\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\t((header->bRequestType & USB_DIR_IN) ?\n\t\t\t\t\tCVMX_USB_DIRECTION_IN :\n\t\t\t\t\tCVMX_USB_DIRECTION_OUT));\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hcspltx, compsplt, 1);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_STATUS:\n\t\tusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\n\t\tbytes_to_transfer = 0;\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\t((header->bRequestType & USB_DIR_IN) ?\n\t\t\t\t\tCVMX_USB_DIRECTION_OUT :\n\t\t\t\t\tCVMX_USB_DIRECTION_IN));\n\t\tbreak;\n\tcase CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:\n\t\tusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\n\t\tbytes_to_transfer = 0;\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hccharx, epdir,\n\t\t\t\t((header->bRequestType & USB_DIR_IN) ?\n\t\t\t\t\tCVMX_USB_DIRECTION_OUT :\n\t\t\t\t\tCVMX_USB_DIRECTION_IN));\n\t\tUSB_SET_FIELD32(CVMX_USBCX_HCSPLTX(channel, usb->index),\n\t\t\t\tcvmx_usbcx_hcspltx, compsplt, 1);\n\t\tbreak;\n\t}\n\n\t \n\tif (bytes_to_transfer > MAX_TRANSFER_BYTES) {\n\t\t \n\t\tbytes_to_transfer = MAX_TRANSFER_BYTES / pipe->max_packet;\n\t\tbytes_to_transfer *= pipe->max_packet;\n\t}\n\n\t \n\tpackets_to_transfer = DIV_ROUND_UP(bytes_to_transfer,\n\t\t\t\t\t   pipe->max_packet);\n\tif (packets_to_transfer == 0) {\n\t\tpackets_to_transfer = 1;\n\t} else if ((packets_to_transfer > 1) &&\n\t\t\t(usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {\n\t\t \n\t\tpackets_to_transfer = 1;\n\t\tbytes_to_transfer = packets_to_transfer * pipe->max_packet;\n\t} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {\n\t\t \n\t\tpackets_to_transfer = MAX_TRANSFER_PACKETS;\n\t\tbytes_to_transfer = packets_to_transfer * pipe->max_packet;\n\t}\n\n\tusbc_hctsiz.s.xfersize = bytes_to_transfer;\n\tusbc_hctsiz.s.pktcnt = packets_to_transfer;\n\n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HCTSIZX(channel, usb->index),\n\t\t\t     usbc_hctsiz.u32);\n}\n\n \nstatic void cvmx_usb_start_channel(struct octeon_hcd *usb, int channel,\n\t\t\t\t   struct cvmx_usb_pipe *pipe)\n{\n\tstruct cvmx_usb_transaction *transaction =\n\t\tlist_first_entry(&pipe->transactions, typeof(*transaction),\n\t\t\t\t node);\n\n\t \n\tCVMX_SYNCW;\n\n\t \n\tusb->pipe_for_channel[channel] = pipe;\n\tpipe->channel = channel;\n\tpipe->flags |= CVMX_USB_PIPE_FLAGS_SCHEDULED;\n\n\t \n\tusb->idle_hardware_channels &= ~(1 << channel);\n\n\t \n\t{\n\t\tunion cvmx_usbcx_hcintx usbc_hcint;\n\t\tunion cvmx_usbcx_hcintmskx usbc_hcintmsk;\n\t\tunion cvmx_usbcx_haintmsk usbc_haintmsk;\n\n\t\t \n\t\tusbc_hcint.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t     CVMX_USBCX_HCINTX(channel, usb->index));\n\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCINTX(channel, usb->index),\n\t\t\t\t     usbc_hcint.u32);\n\n\t\tusbc_hcintmsk.u32 = 0;\n\t\tusbc_hcintmsk.s.chhltdmsk = 1;\n\t\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\n\t\t\t \n\t\t\tusbc_hcintmsk.s.datatglerrmsk = 1;\n\t\t\tusbc_hcintmsk.s.frmovrunmsk = 1;\n\t\t\tusbc_hcintmsk.s.bblerrmsk = 1;\n\t\t\tusbc_hcintmsk.s.xacterrmsk = 1;\n\t\t\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\t\t \n\t\t\t\tusbc_hcintmsk.s.nyetmsk = 1;\n\t\t\t\tusbc_hcintmsk.s.ackmsk = 1;\n\t\t\t}\n\t\t\tusbc_hcintmsk.s.nakmsk = 1;\n\t\t\tusbc_hcintmsk.s.stallmsk = 1;\n\t\t\tusbc_hcintmsk.s.xfercomplmsk = 1;\n\t\t}\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCINTMSKX(channel, usb->index),\n\t\t\t\t     usbc_hcintmsk.u32);\n\n\t\t \n\t\tusbc_haintmsk.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t\tCVMX_USBCX_HAINTMSK(usb->index));\n\t\tusbc_haintmsk.s.haintmsk |= 1 << channel;\n\t\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HAINTMSK(usb->index),\n\t\t\t\t     usbc_haintmsk.u32);\n\t}\n\n\t \n\t{\n\t\tu64 reg;\n\t\tu64 dma_address = transaction->buffer +\n\t\t\t\t  transaction->actual_bytes;\n\n\t\tif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\n\t\t\tdma_address = transaction->buffer +\n\t\t\t\t\ttransaction->iso_packets[0].offset +\n\t\t\t\t\ttransaction->actual_bytes;\n\n\t\tif (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT)\n\t\t\treg = CVMX_USBNX_DMA0_OUTB_CHN0(usb->index);\n\t\telse\n\t\t\treg = CVMX_USBNX_DMA0_INB_CHN0(usb->index);\n\t\tcvmx_write64_uint64(reg + channel * 8, dma_address);\n\t}\n\n\t \n\t{\n\t\tunion cvmx_usbcx_hcspltx usbc_hcsplt = {.u32 = 0};\n\t\tunion cvmx_usbcx_hctsizx usbc_hctsiz = {.u32 = 0};\n\t\tint packets_to_transfer;\n\t\tint bytes_to_transfer = transaction->buffer_length -\n\t\t\ttransaction->actual_bytes;\n\n\t\t \n\t\tif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\n\t\t\tbytes_to_transfer =\n\t\t\t\ttransaction->iso_packets[0].length -\n\t\t\t\ttransaction->actual_bytes;\n\n\t\t \n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\t \n\t\t\tif ((transaction->stage & 1) == 0) {\n\t\t\t\tif (transaction->type == CVMX_USB_TRANSFER_BULK)\n\t\t\t\t\tpipe->split_sc_frame =\n\t\t\t\t\t\t(usb->frame_number + 1) & 0x7f;\n\t\t\t\telse\n\t\t\t\t\tpipe->split_sc_frame =\n\t\t\t\t\t\t(usb->frame_number + 2) & 0x7f;\n\t\t\t} else {\n\t\t\t\tpipe->split_sc_frame = -1;\n\t\t\t}\n\n\t\t\tusbc_hcsplt.s.spltena = 1;\n\t\t\tusbc_hcsplt.s.hubaddr = pipe->hub_device_addr;\n\t\t\tusbc_hcsplt.s.prtaddr = pipe->hub_port;\n\t\t\tusbc_hcsplt.s.compsplt = (transaction->stage ==\n\t\t\t\tCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE);\n\n\t\t\t \n\t\t\tif (bytes_to_transfer > pipe->max_packet)\n\t\t\t\tbytes_to_transfer = pipe->max_packet;\n\n\t\t\t \n\t\t\tif (!usbc_hcsplt.s.compsplt &&\n\t\t\t    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&\n\t\t\t    (pipe->transfer_type ==\n\t\t\t     CVMX_USB_TRANSFER_ISOCHRONOUS)) {\n\t\t\t\t \n\t\t\t\tpipe->split_sc_frame = -1;\n\t\t\t\t \n\t\t\t\tif (transaction->actual_bytes == 0) {\n\t\t\t\t\t \n\t\t\t\t\tif (bytes_to_transfer <= 188)\n\t\t\t\t\t\t \n\t\t\t\t\t\tusbc_hcsplt.s.xactpos = 3;\n\t\t\t\t\telse\n\t\t\t\t\t\t \n\t\t\t\t\t\tusbc_hcsplt.s.xactpos = 2;\n\t\t\t\t} else {\n\t\t\t\t\t \n\t\t\t\t\tif (bytes_to_transfer <= 188)\n\t\t\t\t\t\t \n\t\t\t\t\t\tusbc_hcsplt.s.xactpos = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\t \n\t\t\t\t\t\tusbc_hcsplt.s.xactpos = 0;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (bytes_to_transfer > 188)\n\t\t\t\t\tbytes_to_transfer = 188;\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (bytes_to_transfer > MAX_TRANSFER_BYTES) {\n\t\t\t \n\t\t\tbytes_to_transfer = MAX_TRANSFER_BYTES /\n\t\t\t\tpipe->max_packet;\n\t\t\tbytes_to_transfer *= pipe->max_packet;\n\t\t}\n\n\t\t \n\t\tpackets_to_transfer =\n\t\t\tDIV_ROUND_UP(bytes_to_transfer, pipe->max_packet);\n\t\tif (packets_to_transfer == 0) {\n\t\t\tpackets_to_transfer = 1;\n\t\t} else if ((packets_to_transfer > 1) &&\n\t\t\t   (usb->init_flags &\n\t\t\t    CVMX_USB_INITIALIZE_FLAGS_NO_DMA)) {\n\t\t\t \n\t\t\tpackets_to_transfer = 1;\n\t\t\tbytes_to_transfer = packets_to_transfer *\n\t\t\t\tpipe->max_packet;\n\t\t} else if (packets_to_transfer > MAX_TRANSFER_PACKETS) {\n\t\t\t \n\t\t\tpackets_to_transfer = MAX_TRANSFER_PACKETS;\n\t\t\tbytes_to_transfer = packets_to_transfer *\n\t\t\t\tpipe->max_packet;\n\t\t}\n\n\t\tusbc_hctsiz.s.xfersize = bytes_to_transfer;\n\t\tusbc_hctsiz.s.pktcnt = packets_to_transfer;\n\n\t\t \n\t\tusbc_hctsiz.s.pid = cvmx_usb_get_data_pid(pipe);\n\t\t \n\t\tif (pipe->flags & CVMX_USB_PIPE_FLAGS_NEED_PING)\n\t\t\tusbc_hctsiz.s.dopng = 1;\n\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCSPLTX(channel, usb->index),\n\t\t\t\t     usbc_hcsplt.u32);\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCTSIZX(channel, usb->index),\n\t\t\t\t     usbc_hctsiz.u32);\n\t}\n\n\t \n\t{\n\t\tunion cvmx_usbcx_hccharx usbc_hcchar = {.u32 = 0};\n\n\t\t \n\t\tusbc_hcchar.s.oddfrm = usb->frame_number & 1;\n\n\t\t \n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe))\n\t\t\tusbc_hcchar.s.ec = 1;\n\t\telse if (pipe->multi_count < 1)\n\t\t\tusbc_hcchar.s.ec = 1;\n\t\telse if (pipe->multi_count > 3)\n\t\t\tusbc_hcchar.s.ec = 3;\n\t\telse\n\t\t\tusbc_hcchar.s.ec = pipe->multi_count;\n\n\t\t \n\t\tusbc_hcchar.s.devaddr = pipe->device_addr;\n\t\tusbc_hcchar.s.eptype = transaction->type;\n\t\tusbc_hcchar.s.lspddev =\n\t\t\t(pipe->device_speed == CVMX_USB_SPEED_LOW);\n\t\tusbc_hcchar.s.epdir = pipe->transfer_dir;\n\t\tusbc_hcchar.s.epnum = pipe->endpoint_num;\n\t\tusbc_hcchar.s.mps = pipe->max_packet;\n\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t     CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\t     usbc_hcchar.u32);\n\t}\n\n\t \n\tswitch (transaction->type) {\n\tcase CVMX_USB_TRANSFER_CONTROL:\n\t\tcvmx_usb_start_channel_control(usb, channel, pipe);\n\t\tbreak;\n\tcase CVMX_USB_TRANSFER_BULK:\n\tcase CVMX_USB_TRANSFER_INTERRUPT:\n\t\tbreak;\n\tcase CVMX_USB_TRANSFER_ISOCHRONOUS:\n\t\tif (!cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\t \n\t\t\tif (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {\n\t\t\t\tif (pipe->multi_count < 2)  \n\t\t\t\t\tUSB_SET_FIELD32(\n\t\t\t\t\t\tCVMX_USBCX_HCTSIZX(channel,\n\t\t\t\t\t\t\t\t   usb->index),\n\t\t\t\t\t\tcvmx_usbcx_hctsizx, pid, 0);\n\t\t\t\telse  \n\t\t\t\t\tUSB_SET_FIELD32(\n\t\t\t\t\t\tCVMX_USBCX_HCTSIZX(channel,\n\t\t\t\t\t\t\t\t   usb->index),\n\t\t\t\t\t\tcvmx_usbcx_hctsizx, pid, 3);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\t{\n\t\tunion cvmx_usbcx_hctsizx usbc_hctsiz = { .u32 =\n\t\t\tcvmx_usb_read_csr32(usb,\n\t\t\t\t\t    CVMX_USBCX_HCTSIZX(channel,\n\t\t\t\t\t\t\t       usb->index))\n\t\t};\n\t\ttransaction->xfersize = usbc_hctsiz.s.xfersize;\n\t\ttransaction->pktcnt = usbc_hctsiz.s.pktcnt;\n\t}\n\t \n\tif (cvmx_usb_pipe_needs_split(usb, pipe))\n\t\tusb->active_split = transaction;\n\tUSB_SET_FIELD32(CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\tcvmx_usbcx_hccharx, chena, 1);\n\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\n\t\tcvmx_usb_fill_tx_fifo(usb, channel);\n}\n\n \nstatic struct cvmx_usb_pipe *cvmx_usb_find_ready_pipe(struct octeon_hcd *usb,\n\t\t\t\t\t\t      enum cvmx_usb_transfer xfer_type)\n{\n\tstruct list_head *list = usb->active_pipes + xfer_type;\n\tu64 current_frame = usb->frame_number;\n\tstruct cvmx_usb_pipe *pipe;\n\n\tlist_for_each_entry(pipe, list, node) {\n\t\tstruct cvmx_usb_transaction *t =\n\t\t\tlist_first_entry(&pipe->transactions, typeof(*t),\n\t\t\t\t\t node);\n\t\tif (!(pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED) && t &&\n\t\t    (pipe->next_tx_frame <= current_frame) &&\n\t\t    ((pipe->split_sc_frame == -1) ||\n\t\t     ((((int)current_frame - pipe->split_sc_frame) & 0x7f) <\n\t\t      0x40)) &&\n\t\t    (!usb->active_split || (usb->active_split == t))) {\n\t\t\tprefetch(t);\n\t\t\treturn pipe;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic struct cvmx_usb_pipe *cvmx_usb_next_pipe(struct octeon_hcd *usb,\n\t\t\t\t\t\tint is_sof)\n{\n\tstruct cvmx_usb_pipe *pipe;\n\n\t \n\tif (is_sof) {\n\t\t \n\t\tpipe = cvmx_usb_find_ready_pipe(usb,\n\t\t\t\t\t\tCVMX_USB_TRANSFER_ISOCHRONOUS);\n\t\tif (pipe)\n\t\t\treturn pipe;\n\t\tpipe = cvmx_usb_find_ready_pipe(usb,\n\t\t\t\t\t\tCVMX_USB_TRANSFER_INTERRUPT);\n\t\tif (pipe)\n\t\t\treturn pipe;\n\t}\n\tpipe = cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_CONTROL);\n\tif (pipe)\n\t\treturn pipe;\n\treturn cvmx_usb_find_ready_pipe(usb, CVMX_USB_TRANSFER_BULK);\n}\n\n \nstatic void cvmx_usb_schedule(struct octeon_hcd *usb, int is_sof)\n{\n\tint channel;\n\tstruct cvmx_usb_pipe *pipe;\n\tint need_sof;\n\tenum cvmx_usb_transfer ttype;\n\n\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\n\t\t \n\t\tunion cvmx_usbcx_hfnum hfnum = {\n\t\t\t.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\tCVMX_USBCX_HFNUM(usb->index))\n\t\t};\n\n\t\tunion cvmx_usbcx_hfir hfir = {\n\t\t\t.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\tCVMX_USBCX_HFIR(usb->index))\n\t\t};\n\n\t\tif (hfnum.s.frrem < hfir.s.frint / 4)\n\t\t\tgoto done;\n\t}\n\n\twhile (usb->idle_hardware_channels) {\n\t\t \n\t\tchannel = __fls(usb->idle_hardware_channels);\n\t\tif (unlikely(channel > 7))\n\t\t\tbreak;\n\n\t\tpipe = cvmx_usb_next_pipe(usb, is_sof);\n\t\tif (!pipe)\n\t\t\tbreak;\n\n\t\tcvmx_usb_start_channel(usb, channel, pipe);\n\t}\n\ndone:\n\t \n\tneed_sof = 0;\n\tfor (ttype = CVMX_USB_TRANSFER_CONTROL;\n\t     ttype <= CVMX_USB_TRANSFER_INTERRUPT; ttype++) {\n\t\tlist_for_each_entry(pipe, &usb->active_pipes[ttype], node) {\n\t\t\tif (pipe->next_tx_frame > usb->frame_number) {\n\t\t\t\tneed_sof = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tUSB_SET_FIELD32(CVMX_USBCX_GINTMSK(usb->index),\n\t\t\tcvmx_usbcx_gintmsk, sofmsk, need_sof);\n}\n\nstatic void octeon_usb_urb_complete_callback(struct octeon_hcd *usb,\n\t\t\t\t\t     enum cvmx_usb_status status,\n\t\t\t\t\t     struct cvmx_usb_pipe *pipe,\n\t\t\t\t\t     struct cvmx_usb_transaction\n\t\t\t\t\t\t*transaction,\n\t\t\t\t\t     int bytes_transferred,\n\t\t\t\t\t     struct urb *urb)\n{\n\tstruct usb_hcd *hcd = octeon_to_hcd(usb);\n\tstruct device *dev = hcd->self.controller;\n\n\tif (likely(status == CVMX_USB_STATUS_OK))\n\t\turb->actual_length = bytes_transferred;\n\telse\n\t\turb->actual_length = 0;\n\n\turb->hcpriv = NULL;\n\n\t \n\tif (usb_pipetype(urb->pipe) == PIPE_ISOCHRONOUS) {\n\t\tint i;\n\t\t \n\t\tstruct cvmx_usb_iso_packet *iso_packet =\n\t\t\t(struct cvmx_usb_iso_packet *)urb->setup_packet;\n\t\t \n\t\turb->actual_length = 0;\n\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\tif (iso_packet[i].status == CVMX_USB_STATUS_OK) {\n\t\t\t\turb->iso_frame_desc[i].status = 0;\n\t\t\t\turb->iso_frame_desc[i].actual_length =\n\t\t\t\t\tiso_packet[i].length;\n\t\t\t\turb->actual_length +=\n\t\t\t\t\turb->iso_frame_desc[i].actual_length;\n\t\t\t} else {\n\t\t\t\tdev_dbg(dev, \"ISOCHRONOUS packet=%d of %d status=%d pipe=%p transaction=%p size=%d\\n\",\n\t\t\t\t\ti, urb->number_of_packets,\n\t\t\t\t\tiso_packet[i].status, pipe,\n\t\t\t\t\ttransaction, iso_packet[i].length);\n\t\t\t\turb->iso_frame_desc[i].status = -EREMOTEIO;\n\t\t\t}\n\t\t}\n\t\t \n\t\tkfree(iso_packet);\n\t\turb->setup_packet = NULL;\n\t}\n\n\tswitch (status) {\n\tcase CVMX_USB_STATUS_OK:\n\t\turb->status = 0;\n\t\tbreak;\n\tcase CVMX_USB_STATUS_CANCEL:\n\t\tif (urb->status == 0)\n\t\t\turb->status = -ENOENT;\n\t\tbreak;\n\tcase CVMX_USB_STATUS_STALL:\n\t\tdev_dbg(dev, \"status=stall pipe=%p transaction=%p size=%d\\n\",\n\t\t\tpipe, transaction, bytes_transferred);\n\t\turb->status = -EPIPE;\n\t\tbreak;\n\tcase CVMX_USB_STATUS_BABBLEERR:\n\t\tdev_dbg(dev, \"status=babble pipe=%p transaction=%p size=%d\\n\",\n\t\t\tpipe, transaction, bytes_transferred);\n\t\turb->status = -EPIPE;\n\t\tbreak;\n\tcase CVMX_USB_STATUS_SHORT:\n\t\tdev_dbg(dev, \"status=short pipe=%p transaction=%p size=%d\\n\",\n\t\t\tpipe, transaction, bytes_transferred);\n\t\turb->status = -EREMOTEIO;\n\t\tbreak;\n\tcase CVMX_USB_STATUS_ERROR:\n\tcase CVMX_USB_STATUS_XACTERR:\n\tcase CVMX_USB_STATUS_DATATGLERR:\n\tcase CVMX_USB_STATUS_FRAMEERR:\n\t\tdev_dbg(dev, \"status=%d pipe=%p transaction=%p size=%d\\n\",\n\t\t\tstatus, pipe, transaction, bytes_transferred);\n\t\turb->status = -EPROTO;\n\t\tbreak;\n\t}\n\tusb_hcd_unlink_urb_from_ep(octeon_to_hcd(usb), urb);\n\tspin_unlock(&usb->lock);\n\tusb_hcd_giveback_urb(octeon_to_hcd(usb), urb, urb->status);\n\tspin_lock(&usb->lock);\n}\n\n \nstatic void cvmx_usb_complete(struct octeon_hcd *usb,\n\t\t\t      struct cvmx_usb_pipe *pipe,\n\t\t\t      struct cvmx_usb_transaction *transaction,\n\t\t\t      enum cvmx_usb_status complete_code)\n{\n\t \n\tif (usb->active_split == transaction)\n\t\tusb->active_split = NULL;\n\n\t \n\tif (unlikely(transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)) {\n\t\t \n\t\ttransaction->iso_packets[0].length = transaction->actual_bytes;\n\t\ttransaction->iso_packets[0].status = complete_code;\n\n\t\t \n\t\tif ((transaction->iso_number_packets > 1) &&\n\t\t    (complete_code == CVMX_USB_STATUS_OK)) {\n\t\t\t \n\t\t\ttransaction->actual_bytes = 0;\n\t\t\t \n\t\t\ttransaction->iso_number_packets--;\n\t\t\t \n\t\t\ttransaction->iso_packets++;\n\t\t\ttransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t \n\tlist_del(&transaction->node);\n\tif (list_empty(&pipe->transactions))\n\t\tlist_move_tail(&pipe->node, &usb->idle_pipes);\n\tocteon_usb_urb_complete_callback(usb, complete_code, pipe,\n\t\t\t\t\t transaction,\n\t\t\t\t\t transaction->actual_bytes,\n\t\t\t\t\t transaction->urb);\n\tkfree(transaction);\n}\n\n \nstatic struct cvmx_usb_transaction *cvmx_usb_submit_transaction(\n\t\t\t\tstruct octeon_hcd *usb,\n\t\t\t\tstruct cvmx_usb_pipe *pipe,\n\t\t\t\tenum cvmx_usb_transfer type,\n\t\t\t\tu64 buffer,\n\t\t\t\tint buffer_length,\n\t\t\t\tu64 control_header,\n\t\t\t\tint iso_start_frame,\n\t\t\t\tint iso_number_packets,\n\t\t\t\tstruct cvmx_usb_iso_packet *iso_packets,\n\t\t\t\tstruct urb *urb)\n{\n\tstruct cvmx_usb_transaction *transaction;\n\n\tif (unlikely(pipe->transfer_type != type))\n\t\treturn NULL;\n\n\ttransaction = kzalloc(sizeof(*transaction), GFP_ATOMIC);\n\tif (unlikely(!transaction))\n\t\treturn NULL;\n\n\ttransaction->type = type;\n\ttransaction->buffer = buffer;\n\ttransaction->buffer_length = buffer_length;\n\ttransaction->control_header = control_header;\n\t \n\ttransaction->iso_start_frame = iso_start_frame;\n\ttransaction->iso_number_packets = iso_number_packets;\n\ttransaction->iso_packets = iso_packets;\n\ttransaction->urb = urb;\n\tif (transaction->type == CVMX_USB_TRANSFER_CONTROL)\n\t\ttransaction->stage = CVMX_USB_STAGE_SETUP;\n\telse\n\t\ttransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\n\n\tif (!list_empty(&pipe->transactions)) {\n\t\tlist_add_tail(&transaction->node, &pipe->transactions);\n\t} else {\n\t\tlist_add_tail(&transaction->node, &pipe->transactions);\n\t\tlist_move_tail(&pipe->node,\n\t\t\t       &usb->active_pipes[pipe->transfer_type]);\n\n\t\t \n\t\tcvmx_usb_schedule(usb, 0);\n\t}\n\n\treturn transaction;\n}\n\n \nstatic struct cvmx_usb_transaction *cvmx_usb_submit_bulk(\n\t\t\t\t\t\tstruct octeon_hcd *usb,\n\t\t\t\t\t\tstruct cvmx_usb_pipe *pipe,\n\t\t\t\t\t\tstruct urb *urb)\n{\n\treturn cvmx_usb_submit_transaction(usb, pipe, CVMX_USB_TRANSFER_BULK,\n\t\t\t\t\t   urb->transfer_dma,\n\t\t\t\t\t   urb->transfer_buffer_length,\n\t\t\t\t\t   0,  \n\t\t\t\t\t   0,  \n\t\t\t\t\t   0,  \n\t\t\t\t\t   NULL,  \n\t\t\t\t\t   urb);\n}\n\n \nstatic struct cvmx_usb_transaction *cvmx_usb_submit_interrupt(\n\t\t\t\t\t\tstruct octeon_hcd *usb,\n\t\t\t\t\t\tstruct cvmx_usb_pipe *pipe,\n\t\t\t\t\t\tstruct urb *urb)\n{\n\treturn cvmx_usb_submit_transaction(usb, pipe,\n\t\t\t\t\t   CVMX_USB_TRANSFER_INTERRUPT,\n\t\t\t\t\t   urb->transfer_dma,\n\t\t\t\t\t   urb->transfer_buffer_length,\n\t\t\t\t\t   0,  \n\t\t\t\t\t   0,  \n\t\t\t\t\t   0,  \n\t\t\t\t\t   NULL,  \n\t\t\t\t\t   urb);\n}\n\n \nstatic struct cvmx_usb_transaction *cvmx_usb_submit_control(\n\t\t\t\t\t\tstruct octeon_hcd *usb,\n\t\t\t\t\t\tstruct cvmx_usb_pipe *pipe,\n\t\t\t\t\t\tstruct urb *urb)\n{\n\tint buffer_length = urb->transfer_buffer_length;\n\tu64 control_header = urb->setup_dma;\n\tstruct usb_ctrlrequest *header = cvmx_phys_to_ptr(control_header);\n\n\tif ((header->bRequestType & USB_DIR_IN) == 0)\n\t\tbuffer_length = le16_to_cpu(header->wLength);\n\n\treturn cvmx_usb_submit_transaction(usb, pipe,\n\t\t\t\t\t   CVMX_USB_TRANSFER_CONTROL,\n\t\t\t\t\t   urb->transfer_dma, buffer_length,\n\t\t\t\t\t   control_header,\n\t\t\t\t\t   0,  \n\t\t\t\t\t   0,  \n\t\t\t\t\t   NULL,  \n\t\t\t\t\t   urb);\n}\n\n \nstatic struct cvmx_usb_transaction *cvmx_usb_submit_isochronous(\n\t\t\t\t\t\tstruct octeon_hcd *usb,\n\t\t\t\t\t\tstruct cvmx_usb_pipe *pipe,\n\t\t\t\t\t\tstruct urb *urb)\n{\n\tstruct cvmx_usb_iso_packet *packets;\n\n\tpackets = (struct cvmx_usb_iso_packet *)urb->setup_packet;\n\treturn cvmx_usb_submit_transaction(usb, pipe,\n\t\t\t\t\t   CVMX_USB_TRANSFER_ISOCHRONOUS,\n\t\t\t\t\t   urb->transfer_dma,\n\t\t\t\t\t   urb->transfer_buffer_length,\n\t\t\t\t\t   0,  \n\t\t\t\t\t   urb->start_frame,\n\t\t\t\t\t   urb->number_of_packets,\n\t\t\t\t\t   packets, urb);\n}\n\n \nstatic int cvmx_usb_cancel(struct octeon_hcd *usb,\n\t\t\t   struct cvmx_usb_pipe *pipe,\n\t\t\t   struct cvmx_usb_transaction *transaction)\n{\n\t \n\tif (list_first_entry(&pipe->transactions, typeof(*transaction), node) ==\n\t    transaction && (pipe->flags & CVMX_USB_PIPE_FLAGS_SCHEDULED)) {\n\t\tunion cvmx_usbcx_hccharx usbc_hcchar;\n\n\t\tusb->pipe_for_channel[pipe->channel] = NULL;\n\t\tpipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;\n\n\t\tCVMX_SYNCW;\n\n\t\tusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t      CVMX_USBCX_HCCHARX(pipe->channel,\n\t\t\t\t\t\t\t\t\t usb->index));\n\t\t \n\t\tif (usbc_hcchar.s.chena) {\n\t\t\tusbc_hcchar.s.chdis = 1;\n\t\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t\t     CVMX_USBCX_HCCHARX(pipe->channel,\n\t\t\t\t\t\t\t\tusb->index),\n\t\t\t\t\t     usbc_hcchar.u32);\n\t\t}\n\t}\n\tcvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_CANCEL);\n\treturn 0;\n}\n\n \nstatic int cvmx_usb_cancel_all(struct octeon_hcd *usb,\n\t\t\t       struct cvmx_usb_pipe *pipe)\n{\n\tstruct cvmx_usb_transaction *transaction, *next;\n\n\t \n\tlist_for_each_entry_safe(transaction, next, &pipe->transactions, node) {\n\t\tint result = cvmx_usb_cancel(usb, pipe, transaction);\n\n\t\tif (unlikely(result != 0))\n\t\t\treturn result;\n\t}\n\treturn 0;\n}\n\n \nstatic int cvmx_usb_close_pipe(struct octeon_hcd *usb,\n\t\t\t       struct cvmx_usb_pipe *pipe)\n{\n\t \n\tif (!list_empty(&pipe->transactions))\n\t\treturn -EBUSY;\n\n\tlist_del(&pipe->node);\n\tkfree(pipe);\n\n\treturn 0;\n}\n\n \nstatic int cvmx_usb_get_frame_number(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbcx_hfnum usbc_hfnum;\n\n\tusbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));\n\n\treturn usbc_hfnum.s.frnum;\n}\n\nstatic void cvmx_usb_transfer_control(struct octeon_hcd *usb,\n\t\t\t\t      struct cvmx_usb_pipe *pipe,\n\t\t\t\t      struct cvmx_usb_transaction *transaction,\n\t\t\t\t      union cvmx_usbcx_hccharx usbc_hcchar,\n\t\t\t\t      int buffer_space_left,\n\t\t\t\t      int bytes_in_last_packet)\n{\n\tswitch (transaction->stage) {\n\tcase CVMX_USB_STAGE_NON_CONTROL:\n\tcase CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE:\n\t\t \n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_ERROR);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_SETUP:\n\t\tpipe->pid_toggle = 1;\n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\ttransaction->stage =\n\t\t\t\tCVMX_USB_STAGE_SETUP_SPLIT_COMPLETE;\n\t\t} else {\n\t\t\tstruct usb_ctrlrequest *header =\n\t\t\t\tcvmx_phys_to_ptr(transaction->control_header);\n\t\t\tif (header->wLength)\n\t\t\t\ttransaction->stage = CVMX_USB_STAGE_DATA;\n\t\t\telse\n\t\t\t\ttransaction->stage = CVMX_USB_STAGE_STATUS;\n\t\t}\n\t\tbreak;\n\tcase CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE:\n\t\t{\n\t\t\tstruct usb_ctrlrequest *header =\n\t\t\t\tcvmx_phys_to_ptr(transaction->control_header);\n\t\t\tif (header->wLength)\n\t\t\t\ttransaction->stage = CVMX_USB_STAGE_DATA;\n\t\t\telse\n\t\t\t\ttransaction->stage = CVMX_USB_STAGE_STATUS;\n\t\t}\n\t\tbreak;\n\tcase CVMX_USB_STAGE_DATA:\n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\ttransaction->stage = CVMX_USB_STAGE_DATA_SPLIT_COMPLETE;\n\t\t\t \n\t\t\tif (!usbc_hcchar.s.epdir) {\n\t\t\t\tif (buffer_space_left < pipe->max_packet)\n\t\t\t\t\ttransaction->actual_bytes +=\n\t\t\t\t\t\tbuffer_space_left;\n\t\t\t\telse\n\t\t\t\t\ttransaction->actual_bytes +=\n\t\t\t\t\t\tpipe->max_packet;\n\t\t\t}\n\t\t} else if ((buffer_space_left == 0) ||\n\t\t\t   (bytes_in_last_packet < pipe->max_packet)) {\n\t\t\tpipe->pid_toggle = 1;\n\t\t\ttransaction->stage = CVMX_USB_STAGE_STATUS;\n\t\t}\n\t\tbreak;\n\tcase CVMX_USB_STAGE_DATA_SPLIT_COMPLETE:\n\t\tif ((buffer_space_left == 0) ||\n\t\t    (bytes_in_last_packet < pipe->max_packet)) {\n\t\t\tpipe->pid_toggle = 1;\n\t\t\ttransaction->stage = CVMX_USB_STAGE_STATUS;\n\t\t} else {\n\t\t\ttransaction->stage = CVMX_USB_STAGE_DATA;\n\t\t}\n\t\tbreak;\n\tcase CVMX_USB_STAGE_STATUS:\n\t\tif (cvmx_usb_pipe_needs_split(usb, pipe))\n\t\t\ttransaction->stage =\n\t\t\t\tCVMX_USB_STAGE_STATUS_SPLIT_COMPLETE;\n\t\telse\n\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t\tbreak;\n\tcase CVMX_USB_STAGE_STATUS_SPLIT_COMPLETE:\n\t\tcvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);\n\t\tbreak;\n\t}\n}\n\nstatic void cvmx_usb_transfer_bulk(struct octeon_hcd *usb,\n\t\t\t\t   struct cvmx_usb_pipe *pipe,\n\t\t\t\t   struct cvmx_usb_transaction *transaction,\n\t\t\t\t   union cvmx_usbcx_hcintx usbc_hcint,\n\t\t\t\t   int buffer_space_left,\n\t\t\t\t   int bytes_in_last_packet)\n{\n\t \n\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\tif (transaction->stage == CVMX_USB_STAGE_NON_CONTROL)\n\t\t\ttransaction->stage =\n\t\t\t\tCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;\n\t\telse if (buffer_space_left &&\n\t\t\t (bytes_in_last_packet == pipe->max_packet))\n\t\t\ttransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\n\t\telse\n\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t} else {\n\t\tif ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&\n\t\t    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) &&\n\t\t    (usbc_hcint.s.nak))\n\t\t\tpipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;\n\t\tif (!buffer_space_left ||\n\t\t    (bytes_in_last_packet < pipe->max_packet))\n\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t}\n}\n\nstatic void cvmx_usb_transfer_intr(struct octeon_hcd *usb,\n\t\t\t\t   struct cvmx_usb_pipe *pipe,\n\t\t\t\t   struct cvmx_usb_transaction *transaction,\n\t\t\t\t   int buffer_space_left,\n\t\t\t\t   int bytes_in_last_packet)\n{\n\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\tif (transaction->stage == CVMX_USB_STAGE_NON_CONTROL) {\n\t\t\ttransaction->stage =\n\t\t\t\tCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;\n\t\t} else if (buffer_space_left &&\n\t\t\t   (bytes_in_last_packet == pipe->max_packet)) {\n\t\t\ttransaction->stage = CVMX_USB_STAGE_NON_CONTROL;\n\t\t} else {\n\t\t\tpipe->next_tx_frame += pipe->interval;\n\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t\t}\n\t} else if (!buffer_space_left ||\n\t\t   (bytes_in_last_packet < pipe->max_packet)) {\n\t\tpipe->next_tx_frame += pipe->interval;\n\t\tcvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);\n\t}\n}\n\nstatic void cvmx_usb_transfer_isoc(struct octeon_hcd *usb,\n\t\t\t\t   struct cvmx_usb_pipe *pipe,\n\t\t\t\t   struct cvmx_usb_transaction *transaction,\n\t\t\t\t   int buffer_space_left,\n\t\t\t\t   int bytes_in_last_packet,\n\t\t\t\t   int bytes_this_transfer)\n{\n\tif (cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t \n\t\tif (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT) {\n\t\t\t \n\t\t\tif (!buffer_space_left || (bytes_this_transfer < 188)) {\n\t\t\t\tpipe->next_tx_frame += pipe->interval;\n\t\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (transaction->stage ==\n\t\t    CVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE) {\n\t\t\t \n\t\t\tif ((buffer_space_left == 0) ||\n\t\t\t    (bytes_in_last_packet < pipe->max_packet)) {\n\t\t\t\tpipe->next_tx_frame += pipe->interval;\n\t\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t\t\t}\n\t\t} else {\n\t\t\ttransaction->stage =\n\t\t\t\tCVMX_USB_STAGE_NON_CONTROL_SPLIT_COMPLETE;\n\t\t}\n\t} else {\n\t\tpipe->next_tx_frame += pipe->interval;\n\t\tcvmx_usb_complete(usb, pipe, transaction, CVMX_USB_STATUS_OK);\n\t}\n}\n\n \nstatic int cvmx_usb_poll_channel(struct octeon_hcd *usb, int channel)\n{\n\tstruct usb_hcd *hcd = octeon_to_hcd(usb);\n\tstruct device *dev = hcd->self.controller;\n\tunion cvmx_usbcx_hcintx usbc_hcint;\n\tunion cvmx_usbcx_hctsizx usbc_hctsiz;\n\tunion cvmx_usbcx_hccharx usbc_hcchar;\n\tstruct cvmx_usb_pipe *pipe;\n\tstruct cvmx_usb_transaction *transaction;\n\tint bytes_this_transfer;\n\tint bytes_in_last_packet;\n\tint packets_processed;\n\tint buffer_space_left;\n\n\t \n\tusbc_hcint.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t     CVMX_USBCX_HCINTX(channel, usb->index));\n\n\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA) {\n\t\tusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t      CVMX_USBCX_HCCHARX(channel,\n\t\t\t\t\t\t\t\t\t usb->index));\n\n\t\tif (usbc_hcchar.s.chena && usbc_hcchar.s.chdis) {\n\t\t\t \n\t\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t\t     CVMX_USBCX_HCCHARX(channel,\n\t\t\t\t\t\t\t\tusb->index),\n\t\t\t\t\t     usbc_hcchar.u32);\n\t\t\treturn 0;\n\t\t}\n\n\t\t \n\t\tif (!usbc_hcint.s.chhltd) {\n\t\t\tif (usbc_hcchar.s.chena) {\n\t\t\t\tunion cvmx_usbcx_hcintmskx hcintmsk;\n\t\t\t\t \n\t\t\t\thcintmsk.u32 = 0;\n\t\t\t\thcintmsk.s.chhltdmsk = 1;\n\t\t\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t\t\t     CVMX_USBCX_HCINTMSKX(channel, usb->index),\n\t\t\t\t\t\t     hcintmsk.u32);\n\t\t\t\tusbc_hcchar.s.chdis = 1;\n\t\t\t\tcvmx_usb_write_csr32(usb,\n\t\t\t\t\t\t     CVMX_USBCX_HCCHARX(channel, usb->index),\n\t\t\t\t\t\t     usbc_hcchar.u32);\n\t\t\t\treturn 0;\n\t\t\t} else if (usbc_hcint.s.xfercompl) {\n\t\t\t\t \n\t\t\t} else {\n\t\t\t\tdev_err(dev, \"USB%d: Channel %d interrupt without halt\\n\",\n\t\t\t\t\tusb->index, channel);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t \n\t\tif (!usbc_hcint.s.chhltd)\n\t\t\treturn 0;\n\t}\n\n\t \n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HCINTMSKX(channel, usb->index), 0);\n\tusb->idle_hardware_channels |= (1 << channel);\n\n\t \n\tpipe = usb->pipe_for_channel[channel];\n\tprefetch(pipe);\n\tif (!pipe)\n\t\treturn 0;\n\ttransaction = list_first_entry(&pipe->transactions,\n\t\t\t\t       typeof(*transaction),\n\t\t\t\t       node);\n\tprefetch(transaction);\n\n\t \n\tusb->pipe_for_channel[channel] = NULL;\n\tpipe->flags &= ~CVMX_USB_PIPE_FLAGS_SCHEDULED;\n\n\t \n\tusbc_hcchar.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t      CVMX_USBCX_HCCHARX(channel, usb->index));\n\tusbc_hctsiz.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t      CVMX_USBCX_HCTSIZX(channel, usb->index));\n\n\t \n\tpackets_processed = transaction->pktcnt - usbc_hctsiz.s.pktcnt;\n\tif (usbc_hcchar.s.epdir) {\n\t\t \n\t\tbytes_this_transfer = transaction->xfersize -\n\t\t\tusbc_hctsiz.s.xfersize;\n\t} else {\n\t\t \n\t\tbytes_this_transfer = packets_processed * usbc_hcchar.s.mps;\n\t\t \n\t\tif (bytes_this_transfer > transaction->xfersize)\n\t\t\tbytes_this_transfer = transaction->xfersize;\n\t}\n\t \n\tif (packets_processed)\n\t\tbytes_in_last_packet = bytes_this_transfer -\n\t\t\t(packets_processed - 1) * usbc_hcchar.s.mps;\n\telse\n\t\tbytes_in_last_packet = bytes_this_transfer;\n\n\t \n\tif ((transaction->stage == CVMX_USB_STAGE_SETUP) ||\n\t    (transaction->stage == CVMX_USB_STAGE_SETUP_SPLIT_COMPLETE))\n\t\tbytes_this_transfer = 0;\n\n\t \n\ttransaction->actual_bytes += bytes_this_transfer;\n\tif (transaction->type == CVMX_USB_TRANSFER_ISOCHRONOUS)\n\t\tbuffer_space_left = transaction->iso_packets[0].length -\n\t\t\ttransaction->actual_bytes;\n\telse\n\t\tbuffer_space_left = transaction->buffer_length -\n\t\t\ttransaction->actual_bytes;\n\n\t \n\tpipe->pid_toggle = !(usbc_hctsiz.s.pid == 0);\n\n\t \n\tif ((pipe->device_speed == CVMX_USB_SPEED_HIGH) &&\n\t    (pipe->transfer_type == CVMX_USB_TRANSFER_BULK) &&\n\t    (pipe->transfer_dir == CVMX_USB_DIRECTION_OUT))\n\t\tpipe->flags |= CVMX_USB_PIPE_FLAGS_NEED_PING;\n\n\tif (WARN_ON_ONCE(bytes_this_transfer < 0)) {\n\t\t \n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_ERROR);\n\t\treturn 0;\n\t}\n\n\tif (usbc_hcint.s.stall) {\n\t\t \n\t\tpipe->pid_toggle = 0;\n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_STALL);\n\t} else if (usbc_hcint.s.xacterr) {\n\t\t \n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_XACTERR);\n\t} else if (usbc_hcint.s.bblerr) {\n\t\t \n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_BABBLEERR);\n\t} else if (usbc_hcint.s.datatglerr) {\n\t\t \n\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t  CVMX_USB_STATUS_DATATGLERR);\n\t} else if (usbc_hcint.s.nyet) {\n\t\t \n\t\tif (!cvmx_usb_pipe_needs_split(usb, pipe)) {\n\t\t\ttransaction->retries = 0;\n\t\t\t \n\t\t\tif ((buffer_space_left == 0) ||\n\t\t\t    (bytes_in_last_packet < pipe->max_packet))\n\t\t\t\tcvmx_usb_complete(usb, pipe,\n\t\t\t\t\t\t  transaction,\n\t\t\t\t\t\t  CVMX_USB_STATUS_OK);\n\t\t} else {\n\t\t\t \n\t\t\ttransaction->retries++;\n\t\t\tif ((transaction->retries & 0x3) == 0) {\n\t\t\t\t \n\t\t\t\ttransaction->stage &= ~1;\n\t\t\t\tpipe->split_sc_frame = -1;\n\t\t\t}\n\t\t}\n\t} else if (usbc_hcint.s.ack) {\n\t\ttransaction->retries = 0;\n\t\t \n\t\tpipe->flags &= ~CVMX_USB_PIPE_FLAGS_NEED_PING;\n\n\t\tswitch (transaction->type) {\n\t\tcase CVMX_USB_TRANSFER_CONTROL:\n\t\t\tcvmx_usb_transfer_control(usb, pipe, transaction,\n\t\t\t\t\t\t  usbc_hcchar,\n\t\t\t\t\t\t  buffer_space_left,\n\t\t\t\t\t\t  bytes_in_last_packet);\n\t\t\tbreak;\n\t\tcase CVMX_USB_TRANSFER_BULK:\n\t\t\tcvmx_usb_transfer_bulk(usb, pipe, transaction,\n\t\t\t\t\t       usbc_hcint, buffer_space_left,\n\t\t\t\t\t       bytes_in_last_packet);\n\t\t\tbreak;\n\t\tcase CVMX_USB_TRANSFER_INTERRUPT:\n\t\t\tcvmx_usb_transfer_intr(usb, pipe, transaction,\n\t\t\t\t\t       buffer_space_left,\n\t\t\t\t\t       bytes_in_last_packet);\n\t\t\tbreak;\n\t\tcase CVMX_USB_TRANSFER_ISOCHRONOUS:\n\t\t\tcvmx_usb_transfer_isoc(usb, pipe, transaction,\n\t\t\t\t\t       buffer_space_left,\n\t\t\t\t\t       bytes_in_last_packet,\n\t\t\t\t\t       bytes_this_transfer);\n\t\t\tbreak;\n\t\t}\n\t} else if (usbc_hcint.s.nak) {\n\t\t \n\t\tif (usb->active_split == transaction)\n\t\t\tusb->active_split = NULL;\n\t\t \n\t\ttransaction->retries = 0;\n\t\ttransaction->stage &= ~1;\n\t\tpipe->next_tx_frame += pipe->interval;\n\t\tif (pipe->next_tx_frame < usb->frame_number)\n\t\t\tpipe->next_tx_frame = usb->frame_number +\n\t\t\t\tpipe->interval -\n\t\t\t\t(usb->frame_number - pipe->next_tx_frame) %\n\t\t\t\tpipe->interval;\n\t} else {\n\t\tstruct cvmx_usb_port_status port;\n\n\t\tport = cvmx_usb_get_status(usb);\n\t\tif (port.port_enabled) {\n\t\t\t \n\t\t\ttransaction->retries++;\n\t\t} else {\n\t\t\t \n\t\t\tcvmx_usb_complete(usb, pipe, transaction,\n\t\t\t\t\t  CVMX_USB_STATUS_ERROR);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void octeon_usb_port_callback(struct octeon_hcd *usb)\n{\n\tspin_unlock(&usb->lock);\n\tusb_hcd_poll_rh_status(octeon_to_hcd(usb));\n\tspin_lock(&usb->lock);\n}\n\n \nstatic int cvmx_usb_poll(struct octeon_hcd *usb)\n{\n\tunion cvmx_usbcx_hfnum usbc_hfnum;\n\tunion cvmx_usbcx_gintsts usbc_gintsts;\n\n\tprefetch_range(usb, sizeof(*usb));\n\n\t \n\tusbc_hfnum.u32 = cvmx_usb_read_csr32(usb, CVMX_USBCX_HFNUM(usb->index));\n\tif ((usb->frame_number & 0x3fff) > usbc_hfnum.s.frnum)\n\t\tusb->frame_number += 0x4000;\n\tusb->frame_number &= ~0x3fffull;\n\tusb->frame_number |= usbc_hfnum.s.frnum;\n\n\t \n\tusbc_gintsts.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t       CVMX_USBCX_GINTSTS(usb->index));\n\n\t \n\tcvmx_usb_write_csr32(usb, CVMX_USBCX_GINTSTS(usb->index),\n\t\t\t     usbc_gintsts.u32);\n\n\tif (usbc_gintsts.s.rxflvl) {\n\t\t \n\t\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\n\t\t\tcvmx_usb_poll_rx_fifo(usb);\n\t}\n\tif (usbc_gintsts.s.ptxfemp || usbc_gintsts.s.nptxfemp) {\n\t\t \n\t\tif (usb->init_flags & CVMX_USB_INITIALIZE_FLAGS_NO_DMA)\n\t\t\tcvmx_usb_poll_tx_fifo(usb);\n\t}\n\tif (usbc_gintsts.s.disconnint || usbc_gintsts.s.prtint) {\n\t\tunion cvmx_usbcx_hprt usbc_hprt;\n\t\t \n\t\tocteon_usb_port_callback(usb);\n\t\t \n\t\tusbc_hprt.u32 =\n\t\t\tcvmx_usb_read_csr32(usb, CVMX_USBCX_HPRT(usb->index));\n\t\tusbc_hprt.s.prtena = 0;\n\t\tcvmx_usb_write_csr32(usb, CVMX_USBCX_HPRT(usb->index),\n\t\t\t\t     usbc_hprt.u32);\n\t}\n\tif (usbc_gintsts.s.hchint) {\n\t\t \n\t\tunion cvmx_usbcx_haint usbc_haint;\n\n\t\tusbc_haint.u32 = cvmx_usb_read_csr32(usb,\n\t\t\t\t\t\t     CVMX_USBCX_HAINT(usb->index));\n\t\twhile (usbc_haint.u32) {\n\t\t\tint channel;\n\n\t\t\tchannel = __fls(usbc_haint.u32);\n\t\t\tcvmx_usb_poll_channel(usb, channel);\n\t\t\tusbc_haint.u32 ^= 1 << channel;\n\t\t}\n\t}\n\n\tcvmx_usb_schedule(usb, usbc_gintsts.s.sof);\n\n\treturn 0;\n}\n\n \nstatic inline struct octeon_hcd *hcd_to_octeon(struct usb_hcd *hcd)\n{\n\treturn (struct octeon_hcd *)(hcd->hcd_priv);\n}\n\nstatic irqreturn_t octeon_usb_irq(struct usb_hcd *hcd)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb->lock, flags);\n\tcvmx_usb_poll(usb);\n\tspin_unlock_irqrestore(&usb->lock, flags);\n\treturn IRQ_HANDLED;\n}\n\nstatic int octeon_usb_start(struct usb_hcd *hcd)\n{\n\thcd->state = HC_STATE_RUNNING;\n\treturn 0;\n}\n\nstatic void octeon_usb_stop(struct usb_hcd *hcd)\n{\n\thcd->state = HC_STATE_HALT;\n}\n\nstatic int octeon_usb_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\n\treturn cvmx_usb_get_frame_number(usb);\n}\n\nstatic int octeon_usb_urb_enqueue(struct usb_hcd *hcd,\n\t\t\t\t  struct urb *urb,\n\t\t\t\t  gfp_t mem_flags)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tstruct device *dev = hcd->self.controller;\n\tstruct cvmx_usb_transaction *transaction = NULL;\n\tstruct cvmx_usb_pipe *pipe;\n\tunsigned long flags;\n\tstruct cvmx_usb_iso_packet *iso_packet;\n\tstruct usb_host_endpoint *ep = urb->ep;\n\tint rc;\n\n\turb->status = 0;\n\tspin_lock_irqsave(&usb->lock, flags);\n\n\trc = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (rc) {\n\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\treturn rc;\n\t}\n\n\tif (!ep->hcpriv) {\n\t\tenum cvmx_usb_transfer transfer_type;\n\t\tenum cvmx_usb_speed speed;\n\t\tint split_device = 0;\n\t\tint split_port = 0;\n\n\t\tswitch (usb_pipetype(urb->pipe)) {\n\t\tcase PIPE_ISOCHRONOUS:\n\t\t\ttransfer_type = CVMX_USB_TRANSFER_ISOCHRONOUS;\n\t\t\tbreak;\n\t\tcase PIPE_INTERRUPT:\n\t\t\ttransfer_type = CVMX_USB_TRANSFER_INTERRUPT;\n\t\t\tbreak;\n\t\tcase PIPE_CONTROL:\n\t\t\ttransfer_type = CVMX_USB_TRANSFER_CONTROL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttransfer_type = CVMX_USB_TRANSFER_BULK;\n\t\t\tbreak;\n\t\t}\n\t\tswitch (urb->dev->speed) {\n\t\tcase USB_SPEED_LOW:\n\t\t\tspeed = CVMX_USB_SPEED_LOW;\n\t\t\tbreak;\n\t\tcase USB_SPEED_FULL:\n\t\t\tspeed = CVMX_USB_SPEED_FULL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspeed = CVMX_USB_SPEED_HIGH;\n\t\t\tbreak;\n\t\t}\n\t\t \n\t\tif (speed != CVMX_USB_SPEED_HIGH) {\n\t\t\t \n\t\t\tstruct usb_device *dev = urb->dev;\n\n\t\t\twhile (dev->parent) {\n\t\t\t\t \n\t\t\t\tif (dev->parent->speed == USB_SPEED_HIGH) {\n\t\t\t\t\tsplit_device = dev->parent->devnum;\n\t\t\t\t\tsplit_port = dev->portnum;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tdev = dev->parent;\n\t\t\t}\n\t\t}\n\t\tpipe = cvmx_usb_open_pipe(usb, usb_pipedevice(urb->pipe),\n\t\t\t\t\t  usb_pipeendpoint(urb->pipe), speed,\n\t\t\t\t\t  le16_to_cpu(ep->desc.wMaxPacketSize)\n\t\t\t\t\t  & 0x7ff,\n\t\t\t\t\t  transfer_type,\n\t\t\t\t\t  usb_pipein(urb->pipe) ?\n\t\t\t\t\t\tCVMX_USB_DIRECTION_IN :\n\t\t\t\t\t\tCVMX_USB_DIRECTION_OUT,\n\t\t\t\t\t  urb->interval,\n\t\t\t\t\t  (le16_to_cpu(ep->desc.wMaxPacketSize)\n\t\t\t\t\t   >> 11) & 0x3,\n\t\t\t\t\t  split_device, split_port);\n\t\tif (!pipe) {\n\t\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tdev_dbg(dev, \"Failed to create pipe\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tep->hcpriv = pipe;\n\t} else {\n\t\tpipe = ep->hcpriv;\n\t}\n\n\tswitch (usb_pipetype(urb->pipe)) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tdev_dbg(dev, \"Submit isochronous to %d.%d\\n\",\n\t\t\tusb_pipedevice(urb->pipe),\n\t\t\tusb_pipeendpoint(urb->pipe));\n\t\t \n\t\tiso_packet = kmalloc_array(urb->number_of_packets,\n\t\t\t\t\t   sizeof(struct cvmx_usb_iso_packet),\n\t\t\t\t\t   GFP_ATOMIC);\n\t\tif (iso_packet) {\n\t\t\tint i;\n\t\t\t \n\t\t\tfor (i = 0; i < urb->number_of_packets; i++) {\n\t\t\t\tiso_packet[i].offset =\n\t\t\t\t\turb->iso_frame_desc[i].offset;\n\t\t\t\tiso_packet[i].length =\n\t\t\t\t\turb->iso_frame_desc[i].length;\n\t\t\t\tiso_packet[i].status = CVMX_USB_STATUS_ERROR;\n\t\t\t}\n\t\t\t \n\t\t\turb->setup_packet = (char *)iso_packet;\n\t\t\ttransaction = cvmx_usb_submit_isochronous(usb,\n\t\t\t\t\t\t\t\t  pipe, urb);\n\t\t\t \n\t\t\tif (!transaction) {\n\t\t\t\turb->setup_packet = NULL;\n\t\t\t\tkfree(iso_packet);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tdev_dbg(dev, \"Submit interrupt to %d.%d\\n\",\n\t\t\tusb_pipedevice(urb->pipe),\n\t\t\tusb_pipeendpoint(urb->pipe));\n\t\ttransaction = cvmx_usb_submit_interrupt(usb, pipe, urb);\n\t\tbreak;\n\tcase PIPE_CONTROL:\n\t\tdev_dbg(dev, \"Submit control to %d.%d\\n\",\n\t\t\tusb_pipedevice(urb->pipe),\n\t\t\tusb_pipeendpoint(urb->pipe));\n\t\ttransaction = cvmx_usb_submit_control(usb, pipe, urb);\n\t\tbreak;\n\tcase PIPE_BULK:\n\t\tdev_dbg(dev, \"Submit bulk to %d.%d\\n\",\n\t\t\tusb_pipedevice(urb->pipe),\n\t\t\tusb_pipeendpoint(urb->pipe));\n\t\ttransaction = cvmx_usb_submit_bulk(usb, pipe, urb);\n\t\tbreak;\n\t}\n\tif (!transaction) {\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\tdev_dbg(dev, \"Failed to submit\\n\");\n\t\treturn -ENOMEM;\n\t}\n\turb->hcpriv = transaction;\n\tspin_unlock_irqrestore(&usb->lock, flags);\n\treturn 0;\n}\n\nstatic int octeon_usb_urb_dequeue(struct usb_hcd *hcd,\n\t\t\t\t  struct urb *urb,\n\t\t\t\t  int status)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tunsigned long flags;\n\tint rc;\n\n\tif (!urb->dev)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&usb->lock, flags);\n\n\trc = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (rc)\n\t\tgoto out;\n\n\turb->status = status;\n\tcvmx_usb_cancel(usb, urb->ep->hcpriv, urb->hcpriv);\n\nout:\n\tspin_unlock_irqrestore(&usb->lock, flags);\n\n\treturn rc;\n}\n\nstatic void octeon_usb_endpoint_disable(struct usb_hcd *hcd,\n\t\t\t\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct device *dev = hcd->self.controller;\n\n\tif (ep->hcpriv) {\n\t\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\t\tstruct cvmx_usb_pipe *pipe = ep->hcpriv;\n\t\tunsigned long flags;\n\n\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\tcvmx_usb_cancel_all(usb, pipe);\n\t\tif (cvmx_usb_close_pipe(usb, pipe))\n\t\t\tdev_dbg(dev, \"Closing pipe %p failed\\n\", pipe);\n\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\tep->hcpriv = NULL;\n\t}\n}\n\nstatic int octeon_usb_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tstruct cvmx_usb_port_status port_status;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&usb->lock, flags);\n\tport_status = cvmx_usb_get_status(usb);\n\tspin_unlock_irqrestore(&usb->lock, flags);\n\tbuf[0] = port_status.connect_change << 1;\n\n\treturn buf[0] != 0;\n}\n\nstatic int octeon_usb_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t\t  u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tstruct device *dev = hcd->self.controller;\n\tstruct cvmx_usb_port_status usb_port_status;\n\tint port_status;\n\tstruct usb_hub_descriptor *desc;\n\tunsigned long flags;\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tdev_dbg(dev, \"ClearHubFeature\\n\");\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tdev_dbg(dev, \"ClearPortFeature\\n\");\n\t\tif (wIndex != 1) {\n\t\t\tdev_dbg(dev, \" INVALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tdev_dbg(dev, \" ENABLE\\n\");\n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tcvmx_usb_disable(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(dev, \" SUSPEND\\n\");\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(dev, \" POWER\\n\");\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_INDICATOR:\n\t\t\tdev_dbg(dev, \" INDICATOR\\n\");\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tdev_dbg(dev, \" C_CONNECTION\\n\");\n\t\t\t \n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tusb->port_status = cvmx_usb_get_status(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tdev_dbg(dev, \" C_RESET\\n\");\n\t\t\t \n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tusb->port_status = cvmx_usb_get_status(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tdev_dbg(dev, \" C_ENABLE\\n\");\n\t\t\t \n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tusb->port_status = cvmx_usb_get_status(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tdev_dbg(dev, \" C_SUSPEND\\n\");\n\t\t\t \n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(dev, \" C_OVER_CURRENT\\n\");\n\t\t\t \n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tusb->port_status = cvmx_usb_get_status(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \" UNKNOWN\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tdev_dbg(dev, \"GetHubDescriptor\\n\");\n\t\tdesc = (struct usb_hub_descriptor *)buf;\n\t\tdesc->bDescLength = 9;\n\t\tdesc->bDescriptorType = 0x29;\n\t\tdesc->bNbrPorts = 1;\n\t\tdesc->wHubCharacteristics = cpu_to_le16(0x08);\n\t\tdesc->bPwrOn2PwrGood = 1;\n\t\tdesc->bHubContrCurrent = 0;\n\t\tdesc->u.hs.DeviceRemovable[0] = 0;\n\t\tdesc->u.hs.DeviceRemovable[1] = 0xff;\n\t\tbreak;\n\tcase GetHubStatus:\n\t\tdev_dbg(dev, \"GetHubStatus\\n\");\n\t\t*(__le32 *)buf = 0;\n\t\tbreak;\n\tcase GetPortStatus:\n\t\tdev_dbg(dev, \"GetPortStatus\\n\");\n\t\tif (wIndex != 1) {\n\t\t\tdev_dbg(dev, \" INVALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\tusb_port_status = cvmx_usb_get_status(usb);\n\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\tport_status = 0;\n\n\t\tif (usb_port_status.connect_change) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_C_CONNECTION);\n\t\t\tdev_dbg(dev, \" C_CONNECTION\\n\");\n\t\t}\n\n\t\tif (usb_port_status.port_enabled) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_C_ENABLE);\n\t\t\tdev_dbg(dev, \" C_ENABLE\\n\");\n\t\t}\n\n\t\tif (usb_port_status.connected) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_CONNECTION);\n\t\t\tdev_dbg(dev, \" CONNECTION\\n\");\n\t\t}\n\n\t\tif (usb_port_status.port_enabled) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_ENABLE);\n\t\t\tdev_dbg(dev, \" ENABLE\\n\");\n\t\t}\n\n\t\tif (usb_port_status.port_over_current) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_OVER_CURRENT);\n\t\t\tdev_dbg(dev, \" OVER_CURRENT\\n\");\n\t\t}\n\n\t\tif (usb_port_status.port_powered) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_POWER);\n\t\t\tdev_dbg(dev, \" POWER\\n\");\n\t\t}\n\n\t\tif (usb_port_status.port_speed == CVMX_USB_SPEED_HIGH) {\n\t\t\tport_status |= USB_PORT_STAT_HIGH_SPEED;\n\t\t\tdev_dbg(dev, \" HIGHSPEED\\n\");\n\t\t} else if (usb_port_status.port_speed == CVMX_USB_SPEED_LOW) {\n\t\t\tport_status |= (1 << USB_PORT_FEAT_LOWSPEED);\n\t\t\tdev_dbg(dev, \" LOWSPEED\\n\");\n\t\t}\n\n\t\t*((__le32 *)buf) = cpu_to_le32(port_status);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tdev_dbg(dev, \"SetHubFeature\\n\");\n\t\t \n\t\tbreak;\n\tcase SetPortFeature:\n\t\tdev_dbg(dev, \"SetPortFeature\\n\");\n\t\tif (wIndex != 1) {\n\t\t\tdev_dbg(dev, \" INVALID\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(dev, \" SUSPEND\\n\");\n\t\t\treturn -EINVAL;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(dev, \" POWER\\n\");\n\t\t\t \n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tUSB_SET_FIELD32(CVMX_USBCX_HPRT(usb->index),\n\t\t\t\t\tcvmx_usbcx_hprt, prtpwr, 1);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\treturn 0;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tdev_dbg(dev, \" RESET\\n\");\n\t\t\tspin_lock_irqsave(&usb->lock, flags);\n\t\t\tcvmx_usb_reset_port(usb);\n\t\t\tspin_unlock_irqrestore(&usb->lock, flags);\n\t\t\treturn 0;\n\t\tcase USB_PORT_FEAT_INDICATOR:\n\t\t\tdev_dbg(dev, \" INDICATOR\\n\");\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdev_dbg(dev, \" UNKNOWN\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(dev, \"Unknown root hub request\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic const struct hc_driver octeon_hc_driver = {\n\t.description\t\t= \"Octeon USB\",\n\t.product_desc\t\t= \"Octeon Host Controller\",\n\t.hcd_priv_size\t\t= sizeof(struct octeon_hcd),\n\t.irq\t\t\t= octeon_usb_irq,\n\t.flags\t\t\t= HCD_MEMORY | HCD_DMA | HCD_USB2,\n\t.start\t\t\t= octeon_usb_start,\n\t.stop\t\t\t= octeon_usb_stop,\n\t.urb_enqueue\t\t= octeon_usb_urb_enqueue,\n\t.urb_dequeue\t\t= octeon_usb_urb_dequeue,\n\t.endpoint_disable\t= octeon_usb_endpoint_disable,\n\t.get_frame_number\t= octeon_usb_get_frame_number,\n\t.hub_status_data\t= octeon_usb_hub_status_data,\n\t.hub_control\t\t= octeon_usb_hub_control,\n\t.map_urb_for_dma\t= octeon_map_urb_for_dma,\n\t.unmap_urb_for_dma\t= octeon_unmap_urb_for_dma,\n};\n\nstatic int octeon_usb_probe(struct platform_device *pdev)\n{\n\tint status;\n\tint initialize_flags;\n\tint usb_num;\n\tstruct resource *res_mem;\n\tstruct device_node *usbn_node;\n\tint irq = platform_get_irq(pdev, 0);\n\tstruct device *dev = &pdev->dev;\n\tstruct octeon_hcd *usb;\n\tstruct usb_hcd *hcd;\n\tu32 clock_rate = 48000000;\n\tbool is_crystal_clock = false;\n\tconst char *clock_type;\n\tint i;\n\n\tif (!dev->of_node) {\n\t\tdev_err(dev, \"Error: empty of_node\\n\");\n\t\treturn -ENXIO;\n\t}\n\tusbn_node = dev->of_node->parent;\n\n\ti = of_property_read_u32(usbn_node,\n\t\t\t\t \"clock-frequency\", &clock_rate);\n\tif (i)\n\t\ti = of_property_read_u32(usbn_node,\n\t\t\t\t\t \"refclk-frequency\", &clock_rate);\n\tif (i) {\n\t\tdev_err(dev, \"No USBN \\\"clock-frequency\\\"\\n\");\n\t\treturn -ENXIO;\n\t}\n\tswitch (clock_rate) {\n\tcase 12000000:\n\t\tinitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_12MHZ;\n\t\tbreak;\n\tcase 24000000:\n\t\tinitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_24MHZ;\n\t\tbreak;\n\tcase 48000000:\n\t\tinitialize_flags = CVMX_USB_INITIALIZE_FLAGS_CLOCK_48MHZ;\n\t\tbreak;\n\tdefault:\n\t\tdev_err(dev, \"Illegal USBN \\\"clock-frequency\\\" %u\\n\",\n\t\t\tclock_rate);\n\t\treturn -ENXIO;\n\t}\n\n\ti = of_property_read_string(usbn_node,\n\t\t\t\t    \"cavium,refclk-type\", &clock_type);\n\tif (i)\n\t\ti = of_property_read_string(usbn_node,\n\t\t\t\t\t    \"refclk-type\", &clock_type);\n\n\tif (!i && strcmp(\"crystal\", clock_type) == 0)\n\t\tis_crystal_clock = true;\n\n\tif (is_crystal_clock)\n\t\tinitialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_XI;\n\telse\n\t\tinitialize_flags |= CVMX_USB_INITIALIZE_FLAGS_CLOCK_XO_GND;\n\n\tres_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res_mem) {\n\t\tdev_err(dev, \"found no memory resource\\n\");\n\t\treturn -ENXIO;\n\t}\n\tusb_num = (res_mem->start >> 44) & 1;\n\n\tif (irq < 0) {\n\t\t \n\t\tirq_hw_number_t hwirq = usb_num ? (1 << 6) + 17 : 56;\n\n\t\tirq = irq_create_mapping(NULL, hwirq);\n\t}\n\n\t \n\ti = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(64));\n\tif (i)\n\t\treturn i;\n\n\t \n\tif (OCTEON_IS_MODEL(OCTEON_CN52XX) || OCTEON_IS_MODEL(OCTEON_CN56XX)) {\n\t\tunion cvmx_iob_n2c_l2c_pri_cnt pri_cnt;\n\n\t\tpri_cnt.u64 = 0;\n\t\tpri_cnt.s.cnt_enb = 1;\n\t\tpri_cnt.s.cnt_val = 400;\n\t\tcvmx_write_csr(CVMX_IOB_N2C_L2C_PRI_CNT, pri_cnt.u64);\n\t}\n\n\thcd = usb_create_hcd(&octeon_hc_driver, dev, dev_name(dev));\n\tif (!hcd) {\n\t\tdev_dbg(dev, \"Failed to allocate memory for HCD\\n\");\n\t\treturn -1;\n\t}\n\thcd->uses_new_polling = 1;\n\tusb = (struct octeon_hcd *)hcd->hcd_priv;\n\n\tspin_lock_init(&usb->lock);\n\n\tusb->init_flags = initialize_flags;\n\n\t \n\tusb->index = usb_num;\n\tINIT_LIST_HEAD(&usb->idle_pipes);\n\tfor (i = 0; i < ARRAY_SIZE(usb->active_pipes); i++)\n\t\tINIT_LIST_HEAD(&usb->active_pipes[i]);\n\n\t \n\tif (OCTEON_IS_MODEL(OCTEON_CN31XX)) {\n\t\tusb->init_flags |= CVMX_USB_INITIALIZE_FLAGS_NO_DMA;\n\t\t \n\t\tusb->idle_hardware_channels = 0x1;\n\t} else if (OCTEON_IS_MODEL(OCTEON_CN5XXX)) {\n\t\t \n\t\tusb->idle_hardware_channels = 0xf7;\n\t} else {\n\t\tusb->idle_hardware_channels = 0xff;\n\t}\n\n\tstatus = cvmx_usb_initialize(dev, usb);\n\tif (status) {\n\t\tdev_dbg(dev, \"USB initialization failed with %d\\n\", status);\n\t\tusb_put_hcd(hcd);\n\t\treturn -1;\n\t}\n\n\tstatus = usb_add_hcd(hcd, irq, 0);\n\tif (status) {\n\t\tdev_dbg(dev, \"USB add HCD failed with %d\\n\", status);\n\t\tusb_put_hcd(hcd);\n\t\treturn -1;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tdev_info(dev, \"Registered HCD for port %d on irq %d\\n\", usb_num, irq);\n\n\treturn 0;\n}\n\nstatic void octeon_usb_remove(struct platform_device *pdev)\n{\n\tint status;\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct octeon_hcd *usb = hcd_to_octeon(hcd);\n\tunsigned long flags;\n\n\tusb_remove_hcd(hcd);\n\tspin_lock_irqsave(&usb->lock, flags);\n\tstatus = cvmx_usb_shutdown(usb);\n\tspin_unlock_irqrestore(&usb->lock, flags);\n\tif (status)\n\t\tdev_dbg(dev, \"USB shutdown failed with %d\\n\", status);\n\n\tusb_put_hcd(hcd);\n}\n\nstatic const struct of_device_id octeon_usb_match[] = {\n\t{\n\t\t.compatible = \"cavium,octeon-5750-usbc\",\n\t},\n\t{},\n};\nMODULE_DEVICE_TABLE(of, octeon_usb_match);\n\nstatic struct platform_driver octeon_usb_driver = {\n\t.driver = {\n\t\t.name\t\t= \"octeon-hcd\",\n\t\t.of_match_table = octeon_usb_match,\n\t},\n\t.probe      = octeon_usb_probe,\n\t.remove_new = octeon_usb_remove,\n};\n\nstatic int __init octeon_usb_driver_init(void)\n{\n\tif (usb_disabled())\n\t\treturn 0;\n\n\treturn platform_driver_register(&octeon_usb_driver);\n}\nmodule_init(octeon_usb_driver_init);\n\nstatic void __exit octeon_usb_driver_exit(void)\n{\n\tif (usb_disabled())\n\t\treturn;\n\n\tplatform_driver_unregister(&octeon_usb_driver);\n}\nmodule_exit(octeon_usb_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Cavium, Inc. <support@cavium.com>\");\nMODULE_DESCRIPTION(\"Cavium Inc. OCTEON USB Host driver.\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}