{
  "module_name": "ohci-dbg.c",
  "hash_id": "a44fea84b4c6200f60729caab4c2163a237e06fe483ec1552a957a0a4647e2e3",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-dbg.c",
  "human_readable_source": "\n \n\n \n\n#define edstring(ed_type) ({ char *temp; \\\n\tswitch (ed_type) { \\\n\tcase PIPE_CONTROL:\ttemp = \"ctrl\"; break; \\\n\tcase PIPE_BULK:\t\ttemp = \"bulk\"; break; \\\n\tcase PIPE_INTERRUPT:\ttemp = \"intr\"; break; \\\n\tdefault:\t\ttemp = \"isoc\"; break; \\\n\t} temp;})\n#define pipestring(pipe) edstring(usb_pipetype(pipe))\n\n\n#define ohci_dbg_sw(ohci, next, size, format, arg...) \\\n\tdo { \\\n\tif (next != NULL) { \\\n\t\tunsigned s_len; \\\n\t\ts_len = scnprintf (*next, *size, format, ## arg ); \\\n\t\t*size -= s_len; *next += s_len; \\\n\t} else \\\n\t\tohci_dbg(ohci,format, ## arg ); \\\n\t} while (0);\n\n \n#define ohci_dbg_nosw(ohci, next, size, format, arg...) \\\n\tdo { \\\n\t\tunsigned s_len; \\\n\t\ts_len = scnprintf(*next, *size, format, ## arg); \\\n\t\t*size -= s_len; *next += s_len; \\\n\t} while (0);\n\n\nstatic void ohci_dump_intr_mask (\n\tstruct ohci_hcd *ohci,\n\tchar *label,\n\tu32 mask,\n\tchar **next,\n\tunsigned *size)\n{\n\tohci_dbg_sw (ohci, next, size, \"%s 0x%08x%s%s%s%s%s%s%s%s%s\\n\",\n\t\tlabel,\n\t\tmask,\n\t\t(mask & OHCI_INTR_MIE) ? \" MIE\" : \"\",\n\t\t(mask & OHCI_INTR_OC) ? \" OC\" : \"\",\n\t\t(mask & OHCI_INTR_RHSC) ? \" RHSC\" : \"\",\n\t\t(mask & OHCI_INTR_FNO) ? \" FNO\" : \"\",\n\t\t(mask & OHCI_INTR_UE) ? \" UE\" : \"\",\n\t\t(mask & OHCI_INTR_RD) ? \" RD\" : \"\",\n\t\t(mask & OHCI_INTR_SF) ? \" SF\" : \"\",\n\t\t(mask & OHCI_INTR_WDH) ? \" WDH\" : \"\",\n\t\t(mask & OHCI_INTR_SO) ? \" SO\" : \"\"\n\t\t);\n}\n\nstatic void maybe_print_eds (\n\tstruct ohci_hcd *ohci,\n\tchar *label,\n\tu32 value,\n\tchar **next,\n\tunsigned *size)\n{\n\tif (value)\n\t\tohci_dbg_sw (ohci, next, size, \"%s %08x\\n\", label, value);\n}\n\nstatic char *hcfs2string (int state)\n{\n\tswitch (state) {\n\t\tcase OHCI_USB_RESET:\treturn \"reset\";\n\t\tcase OHCI_USB_RESUME:\treturn \"resume\";\n\t\tcase OHCI_USB_OPER:\treturn \"operational\";\n\t\tcase OHCI_USB_SUSPEND:\treturn \"suspend\";\n\t}\n\treturn \"?\";\n}\n\nstatic const char *rh_state_string(struct ohci_hcd *ohci)\n{\n\tswitch (ohci->rh_state) {\n\tcase OHCI_RH_HALTED:\n\t\treturn \"halted\";\n\tcase OHCI_RH_SUSPENDED:\n\t\treturn \"suspended\";\n\tcase OHCI_RH_RUNNING:\n\t\treturn \"running\";\n\t}\n\treturn \"?\";\n}\n\n\nstatic void\nohci_dump_status (struct ohci_hcd *controller, char **next, unsigned *size)\n{\n\tstruct ohci_regs __iomem *regs = controller->regs;\n\tu32\t\t\ttemp;\n\n\ttemp = ohci_readl (controller, &regs->revision) & 0xff;\n\tohci_dbg_sw (controller, next, size,\n\t\t\"OHCI %d.%d, %s legacy support registers, rh state %s\\n\",\n\t\t0x03 & (temp >> 4), (temp & 0x0f),\n\t\t(temp & 0x0100) ? \"with\" : \"NO\",\n\t\trh_state_string(controller));\n\n\ttemp = ohci_readl (controller, &regs->control);\n\tohci_dbg_sw (controller, next, size,\n\t\t\"control 0x%03x%s%s%s HCFS=%s%s%s%s%s CBSR=%d\\n\",\n\t\ttemp,\n\t\t(temp & OHCI_CTRL_RWE) ? \" RWE\" : \"\",\n\t\t(temp & OHCI_CTRL_RWC) ? \" RWC\" : \"\",\n\t\t(temp & OHCI_CTRL_IR) ? \" IR\" : \"\",\n\t\thcfs2string (temp & OHCI_CTRL_HCFS),\n\t\t(temp & OHCI_CTRL_BLE) ? \" BLE\" : \"\",\n\t\t(temp & OHCI_CTRL_CLE) ? \" CLE\" : \"\",\n\t\t(temp & OHCI_CTRL_IE) ? \" IE\" : \"\",\n\t\t(temp & OHCI_CTRL_PLE) ? \" PLE\" : \"\",\n\t\ttemp & OHCI_CTRL_CBSR\n\t\t);\n\n\ttemp = ohci_readl (controller, &regs->cmdstatus);\n\tohci_dbg_sw (controller, next, size,\n\t\t\"cmdstatus 0x%05x SOC=%d%s%s%s%s\\n\", temp,\n\t\t(temp & OHCI_SOC) >> 16,\n\t\t(temp & OHCI_OCR) ? \" OCR\" : \"\",\n\t\t(temp & OHCI_BLF) ? \" BLF\" : \"\",\n\t\t(temp & OHCI_CLF) ? \" CLF\" : \"\",\n\t\t(temp & OHCI_HCR) ? \" HCR\" : \"\"\n\t\t);\n\n\tohci_dump_intr_mask (controller, \"intrstatus\",\n\t\t\tohci_readl (controller, &regs->intrstatus),\n\t\t\tnext, size);\n\tohci_dump_intr_mask (controller, \"intrenable\",\n\t\t\tohci_readl (controller, &regs->intrenable),\n\t\t\tnext, size);\n\t\n\n\tmaybe_print_eds (controller, \"ed_periodcurrent\",\n\t\t\tohci_readl (controller, &regs->ed_periodcurrent),\n\t\t\tnext, size);\n\n\tmaybe_print_eds (controller, \"ed_controlhead\",\n\t\t\tohci_readl (controller, &regs->ed_controlhead),\n\t\t\tnext, size);\n\tmaybe_print_eds (controller, \"ed_controlcurrent\",\n\t\t\tohci_readl (controller, &regs->ed_controlcurrent),\n\t\t\tnext, size);\n\n\tmaybe_print_eds (controller, \"ed_bulkhead\",\n\t\t\tohci_readl (controller, &regs->ed_bulkhead),\n\t\t\tnext, size);\n\tmaybe_print_eds (controller, \"ed_bulkcurrent\",\n\t\t\tohci_readl (controller, &regs->ed_bulkcurrent),\n\t\t\tnext, size);\n\n\tmaybe_print_eds (controller, \"donehead\",\n\t\t\tohci_readl (controller, &regs->donehead), next, size);\n}\n\n#define dbg_port_sw(hc,num,value,next,size) \\\n\tohci_dbg_sw (hc, next, size, \\\n\t\t\"roothub.portstatus [%d] \" \\\n\t\t\"0x%08x%s%s%s%s%s%s%s%s%s%s%s%s\\n\", \\\n\t\tnum, temp, \\\n\t\t(temp & RH_PS_PRSC) ? \" PRSC\" : \"\", \\\n\t\t(temp & RH_PS_OCIC) ? \" OCIC\" : \"\", \\\n\t\t(temp & RH_PS_PSSC) ? \" PSSC\" : \"\", \\\n\t\t(temp & RH_PS_PESC) ? \" PESC\" : \"\", \\\n\t\t(temp & RH_PS_CSC) ? \" CSC\" : \"\", \\\n\t\t\\\n\t\t(temp & RH_PS_LSDA) ? \" LSDA\" : \"\", \\\n\t\t(temp & RH_PS_PPS) ? \" PPS\" : \"\", \\\n\t\t(temp & RH_PS_PRS) ? \" PRS\" : \"\", \\\n\t\t(temp & RH_PS_POCI) ? \" POCI\" : \"\", \\\n\t\t(temp & RH_PS_PSS) ? \" PSS\" : \"\", \\\n\t\t\\\n\t\t(temp & RH_PS_PES) ? \" PES\" : \"\", \\\n\t\t(temp & RH_PS_CCS) ? \" CCS\" : \"\" \\\n\t\t);\n\n\nstatic void\nohci_dump_roothub (\n\tstruct ohci_hcd *controller,\n\tint verbose,\n\tchar **next,\n\tunsigned *size)\n{\n\tu32\t\t\ttemp, i;\n\n\ttemp = roothub_a (controller);\n\tif (temp == ~(u32)0)\n\t\treturn;\n\n\tif (verbose) {\n\t\tohci_dbg_sw (controller, next, size,\n\t\t\t\"roothub.a %08x POTPGT=%d%s%s%s%s%s NDP=%d(%d)\\n\", temp,\n\t\t\t((temp & RH_A_POTPGT) >> 24) & 0xff,\n\t\t\t(temp & RH_A_NOCP) ? \" NOCP\" : \"\",\n\t\t\t(temp & RH_A_OCPM) ? \" OCPM\" : \"\",\n\t\t\t(temp & RH_A_DT) ? \" DT\" : \"\",\n\t\t\t(temp & RH_A_NPS) ? \" NPS\" : \"\",\n\t\t\t(temp & RH_A_PSM) ? \" PSM\" : \"\",\n\t\t\t(temp & RH_A_NDP), controller->num_ports\n\t\t\t);\n\t\ttemp = roothub_b (controller);\n\t\tohci_dbg_sw (controller, next, size,\n\t\t\t\"roothub.b %08x PPCM=%04x DR=%04x\\n\",\n\t\t\ttemp,\n\t\t\t(temp & RH_B_PPCM) >> 16,\n\t\t\t(temp & RH_B_DR)\n\t\t\t);\n\t\ttemp = roothub_status (controller);\n\t\tohci_dbg_sw (controller, next, size,\n\t\t\t\"roothub.status %08x%s%s%s%s%s%s\\n\",\n\t\t\ttemp,\n\t\t\t(temp & RH_HS_CRWE) ? \" CRWE\" : \"\",\n\t\t\t(temp & RH_HS_OCIC) ? \" OCIC\" : \"\",\n\t\t\t(temp & RH_HS_LPSC) ? \" LPSC\" : \"\",\n\t\t\t(temp & RH_HS_DRWE) ? \" DRWE\" : \"\",\n\t\t\t(temp & RH_HS_OCI) ? \" OCI\" : \"\",\n\t\t\t(temp & RH_HS_LPS) ? \" LPS\" : \"\"\n\t\t\t);\n\t}\n\n\tfor (i = 0; i < controller->num_ports; i++) {\n\t\ttemp = roothub_portstatus (controller, i);\n\t\tdbg_port_sw (controller, i, temp, next, size);\n\t}\n}\n\nstatic void ohci_dump(struct ohci_hcd *controller)\n{\n\tohci_dbg (controller, \"OHCI controller state\\n\");\n\n\t\n\tohci_dump_status (controller, NULL, NULL);\n\tif (controller->hcca)\n\t\tohci_dbg (controller,\n\t\t\t\"hcca frame #%04x\\n\", ohci_frame_no(controller));\n\tohci_dump_roothub (controller, 1, NULL, NULL);\n}\n\nstatic const char data0 [] = \"DATA0\";\nstatic const char data1 [] = \"DATA1\";\n\nstatic void ohci_dump_td (const struct ohci_hcd *ohci, const char *label,\n\t\tconst struct td *td)\n{\n\tu32\ttmp = hc32_to_cpup (ohci, &td->hwINFO);\n\n\tohci_dbg (ohci, \"%s td %p%s; urb %p index %d; hw next td %08x\\n\",\n\t\tlabel, td,\n\t\t(tmp & TD_DONE) ? \" (DONE)\" : \"\",\n\t\ttd->urb, td->index,\n\t\thc32_to_cpup (ohci, &td->hwNextTD));\n\tif ((tmp & TD_ISO) == 0) {\n\t\tconst char\t*toggle, *pid;\n\t\tu32\tcbp, be;\n\n\t\tswitch (tmp & TD_T) {\n\t\tcase TD_T_DATA0: toggle = data0; break;\n\t\tcase TD_T_DATA1: toggle = data1; break;\n\t\tcase TD_T_TOGGLE: toggle = \"(CARRY)\"; break;\n\t\tdefault: toggle = \"(?)\"; break;\n\t\t}\n\t\tswitch (tmp & TD_DP) {\n\t\tcase TD_DP_SETUP: pid = \"SETUP\"; break;\n\t\tcase TD_DP_IN: pid = \"IN\"; break;\n\t\tcase TD_DP_OUT: pid = \"OUT\"; break;\n\t\tdefault: pid = \"(bad pid)\"; break;\n\t\t}\n\t\tohci_dbg (ohci, \"     info %08x CC=%x %s DI=%d %s %s\\n\", tmp,\n\t\t\tTD_CC_GET(tmp),   toggle,\n\t\t\t(tmp & TD_DI) >> 21, pid,\n\t\t\t(tmp & TD_R) ? \"R\" : \"\");\n\t\tcbp = hc32_to_cpup (ohci, &td->hwCBP);\n\t\tbe = hc32_to_cpup (ohci, &td->hwBE);\n\t\tohci_dbg (ohci, \"     cbp %08x be %08x (len %d)\\n\", cbp, be,\n\t\t\tcbp ? (be + 1 - cbp) : 0);\n\t} else {\n\t\tunsigned\ti;\n\t\tohci_dbg (ohci, \"  info %08x CC=%x FC=%d DI=%d SF=%04x\\n\", tmp,\n\t\t\tTD_CC_GET(tmp),\n\t\t\t(tmp >> 24) & 0x07,\n\t\t\t(tmp & TD_DI) >> 21,\n\t\t\ttmp & 0x0000ffff);\n\t\tohci_dbg (ohci, \"  bp0 %08x be %08x\\n\",\n\t\t\thc32_to_cpup (ohci, &td->hwCBP) & ~0x0fff,\n\t\t\thc32_to_cpup (ohci, &td->hwBE));\n\t\tfor (i = 0; i < MAXPSW; i++) {\n\t\t\tu16\tpsw = ohci_hwPSW (ohci, td, i);\n\t\t\tint\tcc = (psw >> 12) & 0x0f;\n\t\t\tohci_dbg (ohci, \"    psw [%d] = %2x, CC=%x %s=%d\\n\", i,\n\t\t\t\tpsw, cc,\n\t\t\t\t(cc >= 0x0e) ? \"OFFSET\" : \"SIZE\",\n\t\t\t\tpsw & 0x0fff);\n\t\t}\n\t}\n}\n\n \nstatic void __maybe_unused\nohci_dump_ed (const struct ohci_hcd *ohci, const char *label,\n\t\tconst struct ed *ed, int verbose)\n{\n\tu32\ttmp = hc32_to_cpu (ohci, ed->hwINFO);\n\tchar\t*type = \"\";\n\n\tohci_dbg (ohci, \"%s, ed %p state 0x%x type %s; next ed %08x\\n\",\n\t\tlabel,\n\t\ted, ed->state, edstring (ed->type),\n\t\thc32_to_cpup (ohci, &ed->hwNextED));\n\tswitch (tmp & (ED_IN|ED_OUT)) {\n\tcase ED_OUT: type = \"-OUT\"; break;\n\tcase ED_IN: type = \"-IN\"; break;\n\t \n\t}\n\tohci_dbg (ohci,\n\t\t\"  info %08x MAX=%d%s%s%s%s EP=%d%s DEV=%d\\n\", tmp,\n\t\t0x03ff & (tmp >> 16),\n\t\t(tmp & ED_DEQUEUE) ? \" DQ\" : \"\",\n\t\t(tmp & ED_ISO) ? \" ISO\" : \"\",\n\t\t(tmp & ED_SKIP) ? \" SKIP\" : \"\",\n\t\t(tmp & ED_LOWSPEED) ? \" LOW\" : \"\",\n\t\t0x000f & (tmp >> 7),\n\t\ttype,\n\t\t0x007f & tmp);\n\ttmp = hc32_to_cpup (ohci, &ed->hwHeadP);\n\tohci_dbg (ohci, \"  tds: head %08x %s%s tail %08x%s\\n\",\n\t\ttmp,\n\t\t(tmp & ED_C) ? data1 : data0,\n\t\t(tmp & ED_H) ? \" HALT\" : \"\",\n\t\thc32_to_cpup (ohci, &ed->hwTailP),\n\t\tverbose ? \"\" : \" (not listing)\");\n\tif (verbose) {\n\t\tstruct list_head\t*tmp;\n\n\t\t \n\t\tlist_for_each (tmp, &ed->td_list) {\n\t\t\tstruct td\t\t*td;\n\t\t\ttd = list_entry (tmp, struct td, td_list);\n\t\t\tohci_dump_td (ohci, \"  ->\", td);\n\t\t}\n\t}\n}\n\n \n\nstatic int debug_async_open(struct inode *, struct file *);\nstatic int debug_periodic_open(struct inode *, struct file *);\nstatic int debug_registers_open(struct inode *, struct file *);\nstatic int debug_async_open(struct inode *, struct file *);\nstatic ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);\nstatic int debug_close(struct inode *, struct file *);\n\nstatic const struct file_operations debug_async_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_async_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations debug_periodic_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_periodic_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations debug_registers_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_registers_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *ohci_debug_root;\n\nstruct debug_buffer {\n\tssize_t (*fill_func)(struct debug_buffer *);\t \n\tstruct ohci_hcd *ohci;\n\tstruct mutex mutex;\t \n\tsize_t count;\t\t \n\tchar *page;\n};\n\nstatic ssize_t\nshow_list (struct ohci_hcd *ohci, char *buf, size_t count, struct ed *ed)\n{\n\tunsigned\t\ttemp, size = count;\n\n\tif (!ed)\n\t\treturn 0;\n\n\t \n\twhile (ed->ed_prev)\n\t\ted = ed->ed_prev;\n\n\t \n\twhile (ed) {\n\t\tu32\t\tinfo = hc32_to_cpu (ohci, ed->hwINFO);\n\t\tu32\t\theadp = hc32_to_cpu (ohci, ed->hwHeadP);\n\t\tstruct list_head *entry;\n\t\tstruct td\t*td;\n\n\t\ttemp = scnprintf (buf, size,\n\t\t\t\"ed/%p %cs dev%d ep%d%s max %d %08x%s%s %s\",\n\t\t\ted,\n\t\t\t(info & ED_LOWSPEED) ? 'l' : 'f',\n\t\t\tinfo & 0x7f,\n\t\t\t(info >> 7) & 0xf,\n\t\t\t(info & ED_IN) ? \"in\" : \"out\",\n\t\t\t0x03ff & (info >> 16),\n\t\t\tinfo,\n\t\t\t(info & ED_SKIP) ? \" s\" : \"\",\n\t\t\t(headp & ED_H) ? \" H\" : \"\",\n\t\t\t(headp & ED_C) ? data1 : data0);\n\t\tsize -= temp;\n\t\tbuf += temp;\n\n\t\tlist_for_each (entry, &ed->td_list) {\n\t\t\tu32\t\tcbp, be;\n\n\t\t\ttd = list_entry (entry, struct td, td_list);\n\t\t\tinfo = hc32_to_cpup (ohci, &td->hwINFO);\n\t\t\tcbp = hc32_to_cpup (ohci, &td->hwCBP);\n\t\t\tbe = hc32_to_cpup (ohci, &td->hwBE);\n\t\t\ttemp = scnprintf (buf, size,\n\t\t\t\t\t\"\\n\\ttd %p %s %d cc=%x urb %p (%08x)\",\n\t\t\t\t\ttd,\n\t\t\t\t\t({ char *pid;\n\t\t\t\t\tswitch (info & TD_DP) {\n\t\t\t\t\tcase TD_DP_SETUP: pid = \"setup\"; break;\n\t\t\t\t\tcase TD_DP_IN: pid = \"in\"; break;\n\t\t\t\t\tcase TD_DP_OUT: pid = \"out\"; break;\n\t\t\t\t\tdefault: pid = \"(?)\"; break;\n\t\t\t\t\t } pid;}),\n\t\t\t\t\tcbp ? (be + 1 - cbp) : 0,\n\t\t\t\t\tTD_CC_GET (info), td->urb, info);\n\t\t\tsize -= temp;\n\t\t\tbuf += temp;\n\t\t}\n\n\t\ttemp = scnprintf (buf, size, \"\\n\");\n\t\tsize -= temp;\n\t\tbuf += temp;\n\n\t\ted = ed->ed_next;\n\t}\n\treturn count - size;\n}\n\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\n{\n\tstruct ohci_hcd\t\t*ohci;\n\tsize_t\t\t\ttemp, size;\n\tunsigned long\t\tflags;\n\n\tohci = buf->ohci;\n\tsize = PAGE_SIZE;\n\n\t \n\tspin_lock_irqsave (&ohci->lock, flags);\n\ttemp = show_list(ohci, buf->page, size, ohci->ed_controltail);\n\ttemp += show_list(ohci, buf->page + temp, size - temp,\n\t\t\t  ohci->ed_bulktail);\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\n\treturn temp;\n}\n\n#define DBG_SCHED_LIMIT 64\n\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\n{\n\tstruct ohci_hcd\t\t*ohci;\n\tstruct ed\t\t**seen, *ed;\n\tunsigned long\t\tflags;\n\tunsigned\t\ttemp, size, seen_count;\n\tchar\t\t\t*next;\n\tunsigned\t\ti;\n\n\tseen = kmalloc_array(DBG_SCHED_LIMIT, sizeof(*seen), GFP_ATOMIC);\n\tif (!seen)\n\t\treturn 0;\n\tseen_count = 0;\n\n\tohci = buf->ohci;\n\tnext = buf->page;\n\tsize = PAGE_SIZE;\n\n\ttemp = scnprintf (next, size, \"size = %d\\n\", NUM_INTS);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tspin_lock_irqsave (&ohci->lock, flags);\n\tfor (i = 0; i < NUM_INTS; i++) {\n\t\ted = ohci->periodic[i];\n\t\tif (!ed)\n\t\t\tcontinue;\n\n\t\ttemp = scnprintf (next, size, \"%2d [%3d]:\", i, ohci->load [i]);\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tdo {\n\t\t\ttemp = scnprintf (next, size, \" ed%d/%p\",\n\t\t\t\ted->interval, ed);\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t\tfor (temp = 0; temp < seen_count; temp++) {\n\t\t\t\tif (seen [temp] == ed)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t \n\t\t\tif (temp == seen_count) {\n\t\t\t\tu32\tinfo = hc32_to_cpu (ohci, ed->hwINFO);\n\t\t\t\tstruct list_head\t*entry;\n\t\t\t\tunsigned\t\tqlen = 0;\n\n\t\t\t\t \n\t\t\t\tlist_for_each (entry, &ed->td_list)\n\t\t\t\t\tqlen++;\n\n\t\t\t\ttemp = scnprintf (next, size,\n\t\t\t\t\t\" (%cs dev%d ep%d%s-%s qlen %u\"\n\t\t\t\t\t\" max %d %08x%s%s)\",\n\t\t\t\t\t(info & ED_LOWSPEED) ? 'l' : 'f',\n\t\t\t\t\tinfo & 0x7f,\n\t\t\t\t\t(info >> 7) & 0xf,\n\t\t\t\t\t(info & ED_IN) ? \"in\" : \"out\",\n\t\t\t\t\t(info & ED_ISO) ? \"iso\" : \"int\",\n\t\t\t\t\tqlen,\n\t\t\t\t\t0x03ff & (info >> 16),\n\t\t\t\t\tinfo,\n\t\t\t\t\t(info & ED_SKIP) ? \" K\" : \"\",\n\t\t\t\t\t(ed->hwHeadP &\n\t\t\t\t\t\tcpu_to_hc32(ohci, ED_H)) ?\n\t\t\t\t\t\t\t\" H\" : \"\");\n\t\t\t\tsize -= temp;\n\t\t\t\tnext += temp;\n\n\t\t\t\tif (seen_count < DBG_SCHED_LIMIT)\n\t\t\t\t\tseen [seen_count++] = ed;\n\n\t\t\t\ted = ed->ed_next;\n\n\t\t\t} else {\n\t\t\t\t \n\t\t\t\ttemp = 0;\n\t\t\t\ted = NULL;\n\t\t\t}\n\n\t\t} while (ed);\n\n\t\ttemp = scnprintf (next, size, \"\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\tkfree (seen);\n\n\treturn PAGE_SIZE - size;\n}\n#undef DBG_SCHED_LIMIT\n\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct ohci_hcd\t\t*ohci;\n\tstruct ohci_regs __iomem *regs;\n\tunsigned long\t\tflags;\n\tunsigned\t\ttemp, size;\n\tchar\t\t\t*next;\n\tu32\t\t\trdata;\n\n\tohci = buf->ohci;\n\thcd = ohci_to_hcd(ohci);\n\tregs = ohci->regs;\n\tnext = buf->page;\n\tsize = PAGE_SIZE;\n\n\tspin_lock_irqsave (&ohci->lock, flags);\n\n\t \n\n\tohci_dbg_nosw(ohci, &next, &size,\n\t\t\"bus %s, device %s\\n\"\n\t\t\"%s\\n\"\n\t\t\"%s\\n\",\n\t\thcd->self.controller->bus->name,\n\t\tdev_name(hcd->self.controller),\n\t\thcd->product_desc,\n\t\thcd_name);\n\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tsize -= scnprintf (next, size,\n\t\t\t\"SUSPENDED (no register access)\\n\");\n\t\tgoto done;\n\t}\n\n\tohci_dump_status(ohci, &next, &size);\n\n\t \n\tif (ohci->hcca)\n\t\tohci_dbg_nosw(ohci, &next, &size,\n\t\t\t\"hcca frame 0x%04x\\n\", ohci_frame_no(ohci));\n\n\t \n\trdata = ohci_readl (ohci, &regs->fminterval);\n\ttemp = scnprintf (next, size,\n\t\t\t\"fmintvl 0x%08x %sFSMPS=0x%04x FI=0x%04x\\n\",\n\t\t\trdata, (rdata >> 31) ? \"FIT \" : \"\",\n\t\t\t(rdata >> 16) & 0xefff, rdata & 0xffff);\n\tsize -= temp;\n\tnext += temp;\n\n\trdata = ohci_readl (ohci, &regs->fmremaining);\n\ttemp = scnprintf (next, size, \"fmremaining 0x%08x %sFR=0x%04x\\n\",\n\t\t\trdata, (rdata >> 31) ? \"FRT \" : \"\",\n\t\t\trdata & 0x3fff);\n\tsize -= temp;\n\tnext += temp;\n\n\trdata = ohci_readl (ohci, &regs->periodicstart);\n\ttemp = scnprintf (next, size, \"periodicstart 0x%04x\\n\",\n\t\t\trdata & 0x3fff);\n\tsize -= temp;\n\tnext += temp;\n\n\trdata = ohci_readl (ohci, &regs->lsthresh);\n\ttemp = scnprintf (next, size, \"lsthresh 0x%04x\\n\",\n\t\t\trdata & 0x3fff);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = scnprintf (next, size, \"hub poll timer %s\\n\",\n\t\t\tHCD_POLL_RH(ohci_to_hcd(ohci)) ? \"ON\" : \"off\");\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tohci_dump_roothub (ohci, 1, &next, &size);\n\ndone:\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\n\treturn PAGE_SIZE - size;\n}\n\nstatic struct debug_buffer *alloc_buffer(struct ohci_hcd *ohci,\n\t\t\t\tssize_t (*fill_func)(struct debug_buffer *))\n{\n\tstruct debug_buffer *buf;\n\n\tbuf = kzalloc(sizeof(struct debug_buffer), GFP_KERNEL);\n\n\tif (buf) {\n\t\tbuf->ohci = ohci;\n\t\tbuf->fill_func = fill_func;\n\t\tmutex_init(&buf->mutex);\n\t}\n\n\treturn buf;\n}\n\nstatic int fill_buffer(struct debug_buffer *buf)\n{\n\tint ret;\n\n\tif (!buf->page)\n\t\tbuf->page = (char *)get_zeroed_page(GFP_KERNEL);\n\n\tif (!buf->page) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = buf->fill_func(buf);\n\n\tif (ret >= 0) {\n\t\tbuf->count = ret;\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\n\t\t\tsize_t len, loff_t *offset)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\tint ret;\n\n\tmutex_lock(&buf->mutex);\n\tif (buf->count == 0) {\n\t\tret = fill_buffer(buf);\n\t\tif (ret != 0) {\n\t\t\tmutex_unlock(&buf->mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&buf->mutex);\n\n\tret = simple_read_from_buffer(user_buf, len, offset,\n\t\t\t\t      buf->page, buf->count);\n\nout:\n\treturn ret;\n\n}\n\nstatic int debug_close(struct inode *inode, struct file *file)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\n\tif (buf) {\n\t\tif (buf->page)\n\t\t\tfree_page((unsigned long)buf->page);\n\t\tkfree(buf);\n\t}\n\n\treturn 0;\n}\nstatic int debug_async_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private,\n\t\t\t\t\t  fill_periodic_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic int debug_registers_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private,\n\t\t\t\t\t  fill_registers_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\nstatic inline void create_debug_files (struct ohci_hcd *ohci)\n{\n\tstruct usb_bus *bus = &ohci_to_hcd(ohci)->self;\n\tstruct dentry *root;\n\n\troot = debugfs_create_dir(bus->bus_name, ohci_debug_root);\n\tohci->debug_dir = root;\n\n\tdebugfs_create_file(\"async\", S_IRUGO, root, ohci, &debug_async_fops);\n\tdebugfs_create_file(\"periodic\", S_IRUGO, root, ohci,\n\t\t\t    &debug_periodic_fops);\n\tdebugfs_create_file(\"registers\", S_IRUGO, root, ohci,\n\t\t\t    &debug_registers_fops);\n\n\tohci_dbg (ohci, \"created debug files\\n\");\n}\n\nstatic inline void remove_debug_files (struct ohci_hcd *ohci)\n{\n\tdebugfs_remove_recursive(ohci->debug_dir);\n}\n\n \n\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}