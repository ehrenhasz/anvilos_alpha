{
  "module_name": "ehci-hub.c",
  "hash_id": "a36a5947a7103cdec343ab88269cb4f788ded006f4365bb6eac79fd45427bc43",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-hub.c",
  "human_readable_source": "\n \n\n \n\n \n\n \n\n \n\n#define\tPORT_WAKE_BITS\t(PORT_WKOC_E|PORT_WKDISC_E|PORT_WKCONN_E)\n\n#ifdef\tCONFIG_PM\n\nstatic void unlink_empty_async_suspended(struct ehci_hcd *ehci);\n\nstatic int persist_enabled_on_companion(struct usb_device *udev, void *unused)\n{\n\treturn !udev->maxchild && udev->persist_enabled &&\n\t\tudev->bus->root_hub->speed < USB_SPEED_HIGH;\n}\n\n \nstatic void ehci_handover_companion_ports(struct ehci_hcd *ehci)\n{\n\tu32 __iomem\t*reg;\n\tu32\t\tstatus;\n\tint\t\tport;\n\t__le32\t\tbuf;\n\tstruct usb_hcd\t*hcd = ehci_to_hcd(ehci);\n\n\tif (!ehci->owned_ports)\n\t\treturn;\n\n\t \n\tif (!usb_for_each_dev(NULL, persist_enabled_on_companion))\n\t\treturn;\n\n\t \n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tif (test_bit(port, &ehci->owned_ports)) {\n\t\t\treg = &ehci->regs->port_status[port];\n\t\t\tstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\n\t\t\tif (!(status & PORT_POWER))\n\t\t\t\tehci_port_power(ehci, port, true);\n\t\t}\n\t}\n\n\t \n\tmsleep(20);\n\n\tspin_lock_irq(&ehci->lock);\n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tif (test_bit(port, &ehci->owned_ports)) {\n\t\t\treg = &ehci->regs->port_status[port];\n\t\t\tstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\n\n\t\t\t \n\t\t\tif (status & PORT_OWNER)\n\t\t\t\tclear_bit(port, &ehci->owned_ports);\n\t\t\telse if (test_bit(port, &ehci->companion_ports))\n\t\t\t\tehci_writel(ehci, status & ~PORT_PE, reg);\n\t\t\telse {\n\t\t\t\tspin_unlock_irq(&ehci->lock);\n\t\t\t\tehci_hub_control(hcd, SetPortFeature,\n\t\t\t\t\t\tUSB_PORT_FEAT_RESET, port + 1,\n\t\t\t\t\t\tNULL, 0);\n\t\t\t\tspin_lock_irq(&ehci->lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irq(&ehci->lock);\n\n\tif (!ehci->owned_ports)\n\t\treturn;\n\tmsleep(90);\t\t \n\n\tspin_lock_irq(&ehci->lock);\n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tif (test_bit(port, &ehci->owned_ports)) {\n\t\t\tspin_unlock_irq(&ehci->lock);\n\t\t\tehci_hub_control(hcd, GetPortStatus,\n\t\t\t\t\t0, port + 1,\n\t\t\t\t\t(char *) &buf, sizeof(buf));\n\t\t\tspin_lock_irq(&ehci->lock);\n\n\t\t\t \n\t\t\treg = &ehci->regs->port_status[port];\n\t\t\tstatus = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\n\t\t\tif (status & PORT_OWNER)\n\t\t\t\tehci_writel(ehci, status | PORT_CSC, reg);\n\t\t\telse {\n\t\t\t\tehci_dbg(ehci, \"failed handover port %d: %x\\n\",\n\t\t\t\t\t\tport + 1, status);\n\t\t\t\tehci_writel(ehci, status & ~PORT_PE, reg);\n\t\t\t}\n\t\t}\n\t}\n\n\tehci->owned_ports = 0;\n\tspin_unlock_irq(&ehci->lock);\n}\n\nstatic int ehci_port_change(struct ehci_hcd *ehci)\n{\n\tint i = HCS_N_PORTS(ehci->hcs_params);\n\n\t \n\n\tif (ehci_readl(ehci, &ehci->regs->status) & STS_PCD)\n\t\treturn 1;\n\n\t \n\n\twhile (i--)\n\t\tif (ehci_readl(ehci, &ehci->regs->port_status[i]) & PORT_CSC)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid ehci_adjust_port_wakeup_flags(struct ehci_hcd *ehci,\n\t\tbool suspending, bool do_wakeup)\n{\n\tint\t\tport;\n\tu32\t\ttemp;\n\n\t \n\tif (!ehci_to_hcd(ehci)->self.root_hub->do_remote_wakeup || do_wakeup)\n\t\treturn;\n\n\tspin_lock_irq(&ehci->lock);\n\n\t \n\tif (ehci->has_tdi_phy_lpm) {\n\t\tport = HCS_N_PORTS(ehci->hcs_params);\n\t\twhile (port--) {\n\t\t\tu32 __iomem\t*hostpc_reg = &ehci->regs->hostpc[port];\n\n\t\t\ttemp = ehci_readl(ehci, hostpc_reg);\n\t\t\tehci_writel(ehci, temp & ~HOSTPC_PHCD, hostpc_reg);\n\t\t}\n\t\tspin_unlock_irq(&ehci->lock);\n\t\tmsleep(5);\n\t\tspin_lock_irq(&ehci->lock);\n\t}\n\n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tu32 __iomem\t*reg = &ehci->regs->port_status[port];\n\t\tu32\t\tt1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\n\t\tu32\t\tt2 = t1 & ~PORT_WAKE_BITS;\n\n\t\t \n\t\tif (!suspending) {\n\t\t\tif (t1 & PORT_CONNECT)\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKDISC_E;\n\t\t\telse\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKCONN_E;\n\t\t}\n\t\tehci_writel(ehci, t2, reg);\n\t}\n\n\t \n\tif (ehci->has_tdi_phy_lpm) {\n\t\tport = HCS_N_PORTS(ehci->hcs_params);\n\t\twhile (port--) {\n\t\t\tu32 __iomem\t*hostpc_reg = &ehci->regs->hostpc[port];\n\n\t\t\ttemp = ehci_readl(ehci, hostpc_reg);\n\t\t\tehci_writel(ehci, temp | HOSTPC_PHCD, hostpc_reg);\n\t\t}\n\t}\n\n\t \n\tif (!suspending && ehci_port_change(ehci))\n\t\tusb_hcd_resume_root_hub(ehci_to_hcd(ehci));\n\n\tspin_unlock_irq(&ehci->lock);\n}\nEXPORT_SYMBOL_GPL(ehci_adjust_port_wakeup_flags);\n\nstatic int ehci_bus_suspend (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tint\t\t\tport;\n\tint\t\t\tmask;\n\tint\t\t\tchanged;\n\tbool\t\t\tfs_idle_delay;\n\n\tehci_dbg(ehci, \"suspend root hub\\n\");\n\n\tif (time_before (jiffies, ehci->next_statechange))\n\t\tmsleep(5);\n\n\t \n\tehci_quiesce(ehci);\n\n\tspin_lock_irq (&ehci->lock);\n\tif (ehci->rh_state < EHCI_RH_RUNNING)\n\t\tgoto done;\n\n\t \n\tif (hcd->self.root_hub->do_remote_wakeup) {\n\t\tif (ehci->resuming_ports) {\n\t\t\tspin_unlock_irq(&ehci->lock);\n\t\t\tehci_dbg(ehci, \"suspend failed because a port is resuming\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\t \n\tehci->bus_suspended = 0;\n\tehci->owned_ports = 0;\n\tchanged = 0;\n\tfs_idle_delay = false;\n\tport = HCS_N_PORTS(ehci->hcs_params);\n\twhile (port--) {\n\t\tu32 __iomem\t*reg = &ehci->regs->port_status [port];\n\t\tu32\t\tt1 = ehci_readl(ehci, reg) & ~PORT_RWC_BITS;\n\t\tu32\t\tt2 = t1 & ~PORT_WAKE_BITS;\n\n\t\t \n\t\tif (t1 & PORT_OWNER)\n\t\t\tset_bit(port, &ehci->owned_ports);\n\t\telse if ((t1 & PORT_PE) && !(t1 & PORT_SUSPEND)) {\n\t\t\tt2 |= PORT_SUSPEND;\n\t\t\tset_bit(port, &ehci->bus_suspended);\n\t\t}\n\n\t\t \n\t\tif (hcd->self.root_hub->do_remote_wakeup) {\n\t\t\t \n\t\t\tif (t1 & PORT_CONNECT)\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKDISC_E;\n\t\t\telse\n\t\t\t\tt2 |= PORT_WKOC_E | PORT_WKCONN_E;\n\t\t}\n\n\t\tif (t1 != t2) {\n\t\t\t \n\t\t\tif ((t2 & PORT_WKDISC_E) &&\n\t\t\t\t\tehci_port_speed(ehci, t2) ==\n\t\t\t\t\t\tUSB_PORT_STAT_HIGH_SPEED)\n\t\t\t\tfs_idle_delay = true;\n\t\t\tehci_writel(ehci, t2, reg);\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\tspin_unlock_irq(&ehci->lock);\n\n\tif (changed && ehci_has_fsl_susp_errata(ehci))\n\t\t \n\t\tusleep_range(10000, 20000);\n\n\tif ((changed && ehci->has_tdi_phy_lpm) || fs_idle_delay) {\n\t\t \n\t\tusleep_range(5000, 5500);\n\t}\n\n\tif (changed && ehci->has_tdi_phy_lpm) {\n\t\tspin_lock_irq(&ehci->lock);\n\t\tport = HCS_N_PORTS(ehci->hcs_params);\n\t\twhile (port--) {\n\t\t\tu32 __iomem\t*hostpc_reg = &ehci->regs->hostpc[port];\n\t\t\tu32\t\tt3;\n\n\t\t\tt3 = ehci_readl(ehci, hostpc_reg);\n\t\t\tehci_writel(ehci, t3 | HOSTPC_PHCD, hostpc_reg);\n\t\t\tt3 = ehci_readl(ehci, hostpc_reg);\n\t\t\tehci_dbg(ehci, \"Port %d phy low-power mode %s\\n\",\n\t\t\t\t\tport, (t3 & HOSTPC_PHCD) ?\n\t\t\t\t\t\"succeeded\" : \"failed\");\n\t\t}\n\t\tspin_unlock_irq(&ehci->lock);\n\t}\n\n\t \n\tif (ehci->bus_suspended)\n\t\tudelay(150);\n\n\t \n\tehci_halt (ehci);\n\n\tspin_lock_irq(&ehci->lock);\n\tif (ehci->enabled_hrtimer_events & BIT(EHCI_HRTIMER_POLL_DEAD))\n\t\tehci_handle_controller_death(ehci);\n\tif (ehci->rh_state != EHCI_RH_RUNNING)\n\t\tgoto done;\n\tehci->rh_state = EHCI_RH_SUSPENDED;\n\n\tunlink_empty_async_suspended(ehci);\n\n\t \n\tehci_writel(ehci, STS_IAA, &ehci->regs->status);\n\n\t \n\tend_iaa_cycle(ehci);\n\tehci_handle_start_intr_unlinks(ehci);\n\tehci_handle_intr_unlinks(ehci);\n\tend_free_itds(ehci);\n\n\t \n\tmask = INTR_MASK;\n\tif (!hcd->self.root_hub->do_remote_wakeup)\n\t\tmask &= ~STS_PCD;\n\tehci_writel(ehci, mask, &ehci->regs->intr_enable);\n\tehci_readl(ehci, &ehci->regs->intr_enable);\n\n done:\n\tehci->next_statechange = jiffies + msecs_to_jiffies(10);\n\tehci->enabled_hrtimer_events = 0;\n\tehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\n\tspin_unlock_irq (&ehci->lock);\n\n\thrtimer_cancel(&ehci->hrtimer);\n\treturn 0;\n}\n\n\n \nstatic int ehci_bus_resume (struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci (hcd);\n\tu32\t\t\ttemp;\n\tu32\t\t\tpower_okay;\n\tint\t\t\ti;\n\tunsigned long\t\tresume_needed = 0;\n\n\tif (time_before (jiffies, ehci->next_statechange))\n\t\tmsleep(5);\n\tspin_lock_irq (&ehci->lock);\n\tif (!HCD_HW_ACCESSIBLE(hcd) || ehci->shutdown)\n\t\tgoto shutdown;\n\n\tif (unlikely(ehci->debug)) {\n\t\tif (!dbgp_reset_prep(hcd))\n\t\t\tehci->debug = NULL;\n\t\telse\n\t\t\tdbgp_external_startup(hcd);\n\t}\n\n\t \n\tpower_okay = ehci_readl(ehci, &ehci->regs->intr_enable);\n\tehci_dbg(ehci, \"resume root hub%s\\n\",\n\t\t\tpower_okay ? \"\" : \" after power loss\");\n\n\t \n\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\n\t \n\tehci_writel(ehci, 0, &ehci->regs->segment);\n\tehci_writel(ehci, ehci->periodic_dma, &ehci->regs->frame_list);\n\tehci_writel(ehci, (u32) ehci->async->qh_dma, &ehci->regs->async_next);\n\n\t \n\tehci->command |= CMD_RUN;\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\tehci->rh_state = EHCI_RH_RUNNING;\n\n\t \n\ti = HCS_N_PORTS(ehci->hcs_params);\n\twhile (i--) {\n\t\ttemp = ehci_readl(ehci, &ehci->regs->port_status[i]);\n\t\tif ((temp & PORT_PE) &&\n\t\t\t\t!(temp & (PORT_SUSPEND | PORT_RESUME))) {\n\t\t\tehci_dbg(ehci, \"Port status(0x%x) is wrong\\n\", temp);\n\t\t\tspin_unlock_irq(&ehci->lock);\n\t\t\tmsleep(8);\n\t\t\tspin_lock_irq(&ehci->lock);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ehci->shutdown)\n\t\tgoto shutdown;\n\n\t \n\tif (ehci->bus_suspended && ehci->has_tdi_phy_lpm) {\n\t\ti = HCS_N_PORTS(ehci->hcs_params);\n\t\twhile (i--) {\n\t\t\tif (test_bit(i, &ehci->bus_suspended)) {\n\t\t\t\tu32 __iomem\t*hostpc_reg =\n\t\t\t\t\t\t\t&ehci->regs->hostpc[i];\n\n\t\t\t\ttemp = ehci_readl(ehci, hostpc_reg);\n\t\t\t\tehci_writel(ehci, temp & ~HOSTPC_PHCD,\n\t\t\t\t\t\thostpc_reg);\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&ehci->lock);\n\t\tmsleep(5);\n\t\tspin_lock_irq(&ehci->lock);\n\t\tif (ehci->shutdown)\n\t\t\tgoto shutdown;\n\t}\n\n\t \n\ti = HCS_N_PORTS (ehci->hcs_params);\n\twhile (i--) {\n\t\ttemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\n\t\ttemp &= ~(PORT_RWC_BITS | PORT_WAKE_BITS);\n\t\tif (test_bit(i, &ehci->bus_suspended) &&\n\t\t\t\t(temp & PORT_SUSPEND)) {\n\t\t\ttemp |= PORT_RESUME;\n\t\t\tset_bit(i, &resume_needed);\n\t\t}\n\t\tehci_writel(ehci, temp, &ehci->regs->port_status [i]);\n\t}\n\n\t \n\tif (resume_needed) {\n\t\tspin_unlock_irq(&ehci->lock);\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\t\tspin_lock_irq(&ehci->lock);\n\t\tif (ehci->shutdown)\n\t\t\tgoto shutdown;\n\t}\n\n\ti = HCS_N_PORTS (ehci->hcs_params);\n\twhile (i--) {\n\t\ttemp = ehci_readl(ehci, &ehci->regs->port_status [i]);\n\t\tif (test_bit(i, &resume_needed)) {\n\t\t\ttemp &= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);\n\t\t\tehci_writel(ehci, temp, &ehci->regs->port_status [i]);\n\t\t}\n\t}\n\n\tehci->next_statechange = jiffies + msecs_to_jiffies(5);\n\tspin_unlock_irq(&ehci->lock);\n\n\tehci_handover_companion_ports(ehci);\n\n\t \n\tspin_lock_irq(&ehci->lock);\n\tif (ehci->shutdown)\n\t\tgoto shutdown;\n\tehci_writel(ehci, INTR_MASK, &ehci->regs->intr_enable);\n\t(void) ehci_readl(ehci, &ehci->regs->intr_enable);\n\tspin_unlock_irq(&ehci->lock);\n\n\treturn 0;\n\n shutdown:\n\tspin_unlock_irq(&ehci->lock);\n\treturn -ESHUTDOWN;\n}\n\nstatic unsigned long ehci_get_resuming_ports(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\n\treturn ehci->resuming_ports;\n}\n\n#else\n\n#define ehci_bus_suspend\tNULL\n#define ehci_bus_resume\t\tNULL\n#define ehci_get_resuming_ports\tNULL\n\n#endif\t \n\n \n\n \nstatic void set_owner(struct ehci_hcd *ehci, int portnum, int new_owner)\n{\n\tu32 __iomem\t\t*status_reg;\n\tu32\t\t\tport_status;\n\tint \t\t\ttry;\n\n\tstatus_reg = &ehci->regs->port_status[portnum];\n\n\t \n\tfor (try = 4; try > 0; --try) {\n\t\tspin_lock_irq(&ehci->lock);\n\t\tport_status = ehci_readl(ehci, status_reg);\n\t\tif ((port_status & PORT_OWNER) == new_owner\n\t\t\t\t|| (port_status & (PORT_OWNER | PORT_CONNECT))\n\t\t\t\t\t== 0)\n\t\t\ttry = 0;\n\t\telse {\n\t\t\tport_status ^= PORT_OWNER;\n\t\t\tport_status &= ~(PORT_PE | PORT_RWC_BITS);\n\t\t\tehci_writel(ehci, port_status, status_reg);\n\t\t}\n\t\tspin_unlock_irq(&ehci->lock);\n\t\tif (try > 1)\n\t\t\tmsleep(5);\n\t}\n}\n\n \n\nstatic int check_reset_complete (\n\tstruct ehci_hcd\t*ehci,\n\tint\t\tindex,\n\tu32 __iomem\t*status_reg,\n\tint\t\tport_status\n) {\n\tif (!(port_status & PORT_CONNECT))\n\t\treturn port_status;\n\n\t \n\tif (!(port_status & PORT_PE)) {\n\n\t\t \n\t\tif (ehci_is_TDI(ehci)) {\n\t\t\tehci_dbg (ehci,\n\t\t\t\t\"Failed to enable port %d on root hub TT\\n\",\n\t\t\t\tindex+1);\n\t\t\treturn port_status;\n\t\t}\n\n\t\tehci_dbg (ehci, \"port %d full speed --> companion\\n\",\n\t\t\tindex + 1);\n\n\t\t\n\t\tport_status |= PORT_OWNER;\n\t\tport_status &= ~PORT_RWC_BITS;\n\t\tehci_writel(ehci, port_status, status_reg);\n\n\t\t \n\t\tif (ehci->has_amcc_usb23)\n\t\t\tset_ohci_hcfs(ehci, 1);\n\t} else {\n\t\tehci_dbg(ehci, \"port %d reset complete, port enabled\\n\",\n\t\t\tindex + 1);\n\t\t \n\t\tif (ehci->has_amcc_usb23)\n\t\t\tset_ohci_hcfs(ehci, 0);\n\t}\n\n\treturn port_status;\n}\n\n \n\n\n \n\nstatic int\nehci_hub_status_data (struct usb_hcd *hcd, char *buf)\n{\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci (hcd);\n\tu32\t\ttemp, status;\n\tu32\t\tmask;\n\tint\t\tports, i, retval = 1;\n\tunsigned long\tflags;\n\tu32\t\tppcd = ~0;\n\n\t \n\tbuf [0] = 0;\n\tports = HCS_N_PORTS (ehci->hcs_params);\n\tif (ports > 7) {\n\t\tbuf [1] = 0;\n\t\tretval++;\n\t}\n\n\t \n\tstatus = ehci->resuming_ports;\n\n\t \n\tif (!ignore_oc && !ehci->spurious_oc)\n\t\tmask = PORT_CSC | PORT_PEC | PORT_OCC;\n\telse\n\t\tmask = PORT_CSC | PORT_PEC;\n\t \n\n\t \n\n\t \n\tspin_lock_irqsave (&ehci->lock, flags);\n\n\t \n\tif (ehci->has_ppcd)\n\t\tppcd = ehci_readl(ehci, &ehci->regs->status) >> 16;\n\n\tfor (i = 0; i < ports; i++) {\n\t\t \n\t\tif (ppcd & (1 << i))\n\t\t\ttemp = ehci_readl(ehci, &ehci->regs->port_status[i]);\n\t\telse\n\t\t\ttemp = 0;\n\n\t\t \n\n\t\tif ((temp & mask) != 0 || test_bit(i, &ehci->port_c_suspend)\n\t\t\t\t|| (ehci->reset_done[i] && time_after_eq(\n\t\t\t\t\tjiffies, ehci->reset_done[i]))\n\t\t\t\t|| ehci_has_ci_pec_bug(ehci, temp)) {\n\t\t\tif (i < 7)\n\t\t\t    buf [0] |= 1 << (i + 1);\n\t\t\telse\n\t\t\t    buf [1] |= 1 << (i - 7);\n\t\t\tstatus = STS_PCD;\n\t\t}\n\t}\n\n\t \n\tif (ehci->resuming_ports)\n\t\tmod_timer(&hcd->rh_timer, jiffies + msecs_to_jiffies(25));\n\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n\treturn status ? retval : 0;\n}\n\n \n\nstatic void\nehci_hub_descriptor (\n\tstruct ehci_hcd\t\t\t*ehci,\n\tstruct usb_hub_descriptor\t*desc\n) {\n\tint\t\tports = HCS_N_PORTS (ehci->hcs_params);\n\tu16\t\ttemp;\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bPwrOn2PwrGood = 10;\t \n\tdesc->bHubContrCurrent = 0;\n\n\tdesc->bNbrPorts = ports;\n\ttemp = 1 + (ports / 8);\n\tdesc->bDescLength = 7 + 2 * temp;\n\n\t \n\tmemset(&desc->u.hs.DeviceRemovable[0], 0, temp);\n\tmemset(&desc->u.hs.DeviceRemovable[temp], 0xff, temp);\n\n\ttemp = HUB_CHAR_INDV_PORT_OCPM;\t \n\tif (HCS_PPC (ehci->hcs_params))\n\t\ttemp |= HUB_CHAR_INDV_PORT_LPSM;  \n\telse\n\t\ttemp |= HUB_CHAR_NO_LPSM;  \n#if 0\n\n\tif (HCS_INDICATOR (ehci->hcs_params))\n\t\ttemp |= HUB_CHAR_PORTIND;  \n#endif\n\tdesc->wHubCharacteristics = cpu_to_le16(temp);\n}\n\n \n\nint ehci_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength\n) {\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci (hcd);\n\tint\t\tports = HCS_N_PORTS (ehci->hcs_params);\n\tu32 __iomem\t*status_reg, *hostpc_reg;\n\tu32\t\ttemp, temp1, status;\n\tunsigned long\tflags;\n\tint\t\tretval = 0;\n\tunsigned\tselector;\n\n\t \n\ttemp = (wIndex - 1) & 0xff;\n\tif (temp >= HCS_N_PORTS_MAX)\n\t\ttemp = 0;\n\tstatus_reg = &ehci->regs->port_status[temp];\n\thostpc_reg = &ehci->regs->hostpc[temp];\n\n\t \n\n\tspin_lock_irqsave (&ehci->lock, flags);\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = ehci_readl(ehci, status_reg);\n\t\ttemp &= ~PORT_RWC_BITS;\n\n\t\t \n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tehci_writel(ehci, temp & ~PORT_PE, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tehci_writel(ehci, temp | PORT_PEC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (temp & PORT_RESET)\n\t\t\t\tgoto error;\n\t\t\tif (ehci->no_selective_suspend)\n\t\t\t\tbreak;\n#ifdef CONFIG_USB_OTG\n\t\t\tif ((hcd->self.otg_port == (wIndex + 1))\n\t\t\t    && hcd->self.b_hnp_enable) {\n\t\t\t\totg_start_hnp(hcd->usb_phy->otg);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (!(temp & PORT_SUSPEND))\n\t\t\t\tbreak;\n\t\t\tif ((temp & PORT_PE) == 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\tif (ehci->has_tdi_phy_lpm) {\n\t\t\t\ttemp1 = ehci_readl(ehci, hostpc_reg);\n\t\t\t\tehci_writel(ehci, temp1 & ~HOSTPC_PHCD,\n\t\t\t\t\t\thostpc_reg);\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tmsleep(5); \n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t}\n\t\t\t \n\t\t\ttemp &= ~PORT_WAKE_BITS;\n\t\t\tehci_writel(ehci, temp | PORT_RESUME, status_reg);\n\t\t\tehci->reset_done[wIndex] = jiffies\n\t\t\t\t\t+ msecs_to_jiffies(USB_RESUME_TIMEOUT);\n\t\t\tset_bit(wIndex, &ehci->resuming_ports);\n\t\t\tusb_hcd_start_port_resume(&hcd->self, wIndex);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tclear_bit(wIndex, &ehci->port_c_suspend);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (HCS_PPC(ehci->hcs_params)) {\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tehci_port_power(ehci, wIndex, false);\n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tehci_writel(ehci, temp | PORT_CSC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tehci_writel(ehci, temp | PORT_OCC, status_reg);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tehci_readl(ehci, &ehci->regs->command);\t \n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tehci_hub_descriptor (ehci, (struct usb_hub_descriptor *)\n\t\t\tbuf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\t \n\t\tmemset (buf, 0, 4);\n\t\t \n\t\tbreak;\n\tcase GetPortStatus:\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tstatus = 0;\n\t\ttemp = ehci_readl(ehci, status_reg);\n\n\t\t \n\t\tif (temp & PORT_CSC)\n\t\t\tstatus |= USB_PORT_STAT_C_CONNECTION << 16;\n\t\tif (temp & PORT_PEC)\n\t\t\tstatus |= USB_PORT_STAT_C_ENABLE << 16;\n\n\t\tif (ehci_has_ci_pec_bug(ehci, temp)) {\n\t\t\tstatus |= USB_PORT_STAT_C_ENABLE << 16;\n\t\t\tehci_info(ehci,\n\t\t\t\t\"PE is cleared by HW port:%d PORTSC:%08x\\n\",\n\t\t\t\twIndex + 1, temp);\n\t\t}\n\n\t\tif ((temp & PORT_OCC) && (!ignore_oc && !ehci->spurious_oc)){\n\t\t\tstatus |= USB_PORT_STAT_C_OVERCURRENT << 16;\n\n\t\t\t \n\t\t\tif (((temp & PORT_OC) || (ehci->need_oc_pp_cycle))\n\t\t\t\t\t&& HCS_PPC(ehci->hcs_params)) {\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tehci_port_power(ehci, wIndex, false);\n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t\ttemp = ehci_readl(ehci, status_reg);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (!ehci->reset_done[wIndex]) {\n\n\t\t\t \n\t\t\tif (temp & PORT_RESUME) {\n\t\t\t\t \n\t\t\t\tehci->reset_done[wIndex] = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies(20);\n\t\t\t\tusb_hcd_start_port_resume(&hcd->self, wIndex);\n\t\t\t\tset_bit(wIndex, &ehci->resuming_ports);\n\t\t\t\t \n\t\t\t\tmod_timer(&ehci_to_hcd(ehci)->rh_timer,\n\t\t\t\t\t\tehci->reset_done[wIndex]);\n\t\t\t}\n\n\t\t \n\t\t} else if (!time_after_eq(jiffies, ehci->reset_done[wIndex])) {\n\t\t\t;\t \n\n\t\t \n\t\t} else if (test_bit(wIndex, &ehci->resuming_ports)) {\n\t\t\tclear_bit(wIndex, &ehci->suspended_ports);\n\t\t\tset_bit(wIndex, &ehci->port_c_suspend);\n\t\t\tehci->reset_done[wIndex] = 0;\n\t\t\tusb_hcd_end_port_resume(&hcd->self, wIndex);\n\n\t\t\t \n\t\t\ttemp &= ~(PORT_RWC_BITS | PORT_SUSPEND | PORT_RESUME);\n\t\t\tehci_writel(ehci, temp, status_reg);\n\t\t\tclear_bit(wIndex, &ehci->resuming_ports);\n\t\t\tretval = ehci_handshake(ehci, status_reg,\n\t\t\t\t\tPORT_RESUME, 0, 2000  );\n\t\t\tif (retval != 0) {\n\t\t\t\tehci_err(ehci, \"port %d resume error %d\\n\",\n\t\t\t\t\t\twIndex + 1, retval);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\ttemp = ehci_readl(ehci, status_reg);\n\n\t\t \n\t\t} else {\n\t\t\tstatus |= USB_PORT_STAT_C_RESET << 16;\n\t\t\tehci->reset_done [wIndex] = 0;\n\n\t\t\t \n\t\t\tehci_writel(ehci, temp & ~(PORT_RWC_BITS | PORT_RESET),\n\t\t\t\t\tstatus_reg);\n\t\t\t \n\t\t\tretval = ehci_handshake(ehci, status_reg,\n\t\t\t\t\tPORT_RESET, 0, 1000);\n\t\t\tif (retval != 0) {\n\t\t\t\tehci_err (ehci, \"port %d reset error %d\\n\",\n\t\t\t\t\twIndex + 1, retval);\n\t\t\t\tgoto error;\n\t\t\t}\n\n\t\t\t \n\t\t\ttemp = check_reset_complete (ehci, wIndex, status_reg,\n\t\t\t\t\tehci_readl(ehci, status_reg));\n\t\t}\n\n\t\t \n\t\tif ((temp & PORT_CONNECT) &&\n\t\t\t\ttest_bit(wIndex, &ehci->companion_ports)) {\n\t\t\ttemp &= ~PORT_RWC_BITS;\n\t\t\ttemp |= PORT_OWNER;\n\t\t\tehci_writel(ehci, temp, status_reg);\n\t\t\tehci_dbg(ehci, \"port %d --> companion\\n\", wIndex + 1);\n\t\t\ttemp = ehci_readl(ehci, status_reg);\n\t\t}\n\n\t\t \n\n\t\tif (temp & PORT_CONNECT) {\n\t\t\tstatus |= USB_PORT_STAT_CONNECTION;\n\t\t\t\n\t\t\tif (ehci->has_hostpc) {\n\t\t\t\ttemp1 = ehci_readl(ehci, hostpc_reg);\n\t\t\t\tstatus |= ehci_port_speed(ehci, temp1);\n\t\t\t} else\n\t\t\t\tstatus |= ehci_port_speed(ehci, temp);\n\t\t}\n\t\tif (temp & PORT_PE)\n\t\t\tstatus |= USB_PORT_STAT_ENABLE;\n\n\t\t \n\t\tif (temp & (PORT_SUSPEND|PORT_RESUME)) {\n\t\t\tstatus |= USB_PORT_STAT_SUSPEND;\n\t\t} else if (test_bit(wIndex, &ehci->suspended_ports)) {\n\t\t\tclear_bit(wIndex, &ehci->suspended_ports);\n\t\t\tclear_bit(wIndex, &ehci->resuming_ports);\n\t\t\tehci->reset_done[wIndex] = 0;\n\t\t\tif (temp & PORT_PE)\n\t\t\t\tset_bit(wIndex, &ehci->port_c_suspend);\n\t\t\tusb_hcd_end_port_resume(&hcd->self, wIndex);\n\t\t}\n\n\t\tif (temp & PORT_OC)\n\t\t\tstatus |= USB_PORT_STAT_OVERCURRENT;\n\t\tif (temp & PORT_RESET)\n\t\t\tstatus |= USB_PORT_STAT_RESET;\n\t\tif (temp & PORT_POWER)\n\t\t\tstatus |= USB_PORT_STAT_POWER;\n\t\tif (test_bit(wIndex, &ehci->port_c_suspend))\n\t\t\tstatus |= USB_PORT_STAT_C_SUSPEND << 16;\n\n\t\tif (status & ~0xffff)\t \n\t\t\tdbg_port(ehci, \"GetStatus\", wIndex + 1, temp);\n\t\tput_unaligned_le32(status, buf);\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tswitch (wValue) {\n\t\tcase C_HUB_LOCAL_POWER:\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\t \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tselector = wIndex >> 8;\n\t\twIndex &= 0xff;\n\t\tif (unlikely(ehci->debug)) {\n\t\t\t \n\t\t\tif (wIndex == HCS_DEBUG_PORT(ehci->hcs_params) &&\n\t\t\t    (readl(&ehci->debug->control) & DBGP_ENABLED)) {\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto error_exit;\n\t\t\t}\n\t\t}\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\ttemp = ehci_readl(ehci, status_reg);\n\t\tif (temp & PORT_OWNER)\n\t\t\tbreak;\n\n\t\ttemp &= ~PORT_RWC_BITS;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tif (ehci->no_selective_suspend)\n\t\t\t\tbreak;\n\t\t\tif ((temp & PORT_PE) == 0\n\t\t\t\t\t|| (temp & PORT_RESET) != 0)\n\t\t\t\tgoto error;\n\n\t\t\t \n\t\t\ttemp &= ~PORT_WKCONN_E;\n\t\t\ttemp |= PORT_WKDISC_E | PORT_WKOC_E;\n\t\t\tehci_writel(ehci, temp | PORT_SUSPEND, status_reg);\n\t\t\tif (ehci->has_tdi_phy_lpm) {\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tmsleep(5); \n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t\ttemp1 = ehci_readl(ehci, hostpc_reg);\n\t\t\t\tehci_writel(ehci, temp1 | HOSTPC_PHCD,\n\t\t\t\t\thostpc_reg);\n\t\t\t\ttemp1 = ehci_readl(ehci, hostpc_reg);\n\t\t\t\tehci_dbg(ehci, \"Port%d phy low pwr mode %s\\n\",\n\t\t\t\t\twIndex, (temp1 & HOSTPC_PHCD) ?\n\t\t\t\t\t\"succeeded\" : \"failed\");\n\t\t\t}\n\t\t\tif (ehci_has_fsl_susp_errata(ehci)) {\n\t\t\t\t \n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tusleep_range(10000, 20000);\n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t}\n\t\t\tset_bit(wIndex, &ehci->suspended_ports);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tif (HCS_PPC(ehci->hcs_params)) {\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tehci_port_power(ehci, wIndex, true);\n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tif (temp & (PORT_SUSPEND|PORT_RESUME))\n\t\t\t\tgoto error;\n\t\t\t \n\t\t\tif ((temp & (PORT_PE|PORT_CONNECT)) == PORT_CONNECT\n\t\t\t\t\t&& !ehci_is_TDI(ehci)\n\t\t\t\t\t&& PORT_USB11 (temp)) {\n\t\t\t\tehci_dbg (ehci,\n\t\t\t\t\t\"port %d low speed --> companion\\n\",\n\t\t\t\t\twIndex + 1);\n\t\t\t\ttemp |= PORT_OWNER;\n\t\t\t} else {\n\t\t\t\ttemp |= PORT_RESET;\n\t\t\t\ttemp &= ~PORT_PE;\n\n\t\t\t\t \n\t\t\t\tehci->reset_done [wIndex] = jiffies\n\t\t\t\t\t\t+ msecs_to_jiffies (50);\n\n\t\t\t\t \n\t\t\t\tif (ehci_has_fsl_hs_errata(ehci))\n\t\t\t\t\ttemp |= (1 << PORTSC_FSL_PFSC);\n\t\t\t}\n\t\t\tehci_writel(ehci, temp, status_reg);\n\t\t\tbreak;\n\n\t\t \n\t\tcase USB_PORT_FEAT_TEST:\n#ifdef CONFIG_USB_HCD_TEST_MODE\n\t\t\tif (selector == EHSET_TEST_SINGLE_STEP_SET_FEATURE) {\n\t\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\t\tretval = ehset_single_step_set_feature(hcd,\n\t\t\t\t\t\t\t\twIndex + 1);\n\t\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\tif (!selector || selector > 5)\n\t\t\t\tgoto error;\n\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\tehci_quiesce(ehci);\n\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\n\t\t\t \n\t\t\twhile (ports--) {\n\t\t\t\tu32 __iomem *sreg =\n\t\t\t\t\t\t&ehci->regs->port_status[ports];\n\n\t\t\t\ttemp = ehci_readl(ehci, sreg) & ~PORT_RWC_BITS;\n\t\t\t\tif (temp & PORT_PE)\n\t\t\t\t\tehci_writel(ehci, temp | PORT_SUSPEND,\n\t\t\t\t\t\t\tsreg);\n\t\t\t}\n\n\t\t\tspin_unlock_irqrestore(&ehci->lock, flags);\n\t\t\tehci_halt(ehci);\n\t\t\tspin_lock_irqsave(&ehci->lock, flags);\n\n\t\t\ttemp = ehci_readl(ehci, status_reg);\n\t\t\ttemp |= selector << 16;\n\t\t\tehci_writel(ehci, temp, status_reg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tehci_readl(ehci, &ehci->regs->command);\t \n\t\tbreak;\n\n\tdefault:\nerror:\n\t\t \n\t\tretval = -EPIPE;\n\t}\nerror_exit:\n\tspin_unlock_irqrestore (&ehci->lock, flags);\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(ehci_hub_control);\n\nstatic void ehci_relinquish_port(struct usb_hcd *hcd, int portnum)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\n\tif (ehci_is_TDI(ehci))\n\t\treturn;\n\tset_owner(ehci, --portnum, PORT_OWNER);\n}\n\nstatic int ehci_port_handed_over(struct usb_hcd *hcd, int portnum)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tu32 __iomem\t\t*reg;\n\n\tif (ehci_is_TDI(ehci))\n\t\treturn 0;\n\treg = &ehci->regs->port_status[portnum - 1];\n\treturn ehci_readl(ehci, reg) & PORT_OWNER;\n}\n\nstatic int ehci_port_power(struct ehci_hcd *ehci, int portnum, bool enable)\n{\n\tstruct usb_hcd *hcd = ehci_to_hcd(ehci);\n\tu32 __iomem *status_reg = &ehci->regs->port_status[portnum];\n\tu32 temp = ehci_readl(ehci, status_reg) & ~PORT_RWC_BITS;\n\n\tif (enable)\n\t\tehci_writel(ehci, temp | PORT_POWER, status_reg);\n\telse\n\t\tehci_writel(ehci, temp & ~PORT_POWER, status_reg);\n\n\tif (hcd->driver->port_power)\n\t\thcd->driver->port_power(hcd, portnum, enable);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}