{
  "module_name": "ohci-sm501.c",
  "hash_id": "9ba4d54a3cc49c901df6de96f385242e46f194e56d495e7df63e5181d4afa45b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-sm501.c",
  "human_readable_source": "\n \n\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/platform_device.h>\n#include <linux/dma-mapping.h>\n#include <linux/sm501.h>\n#include <linux/sm501-regs.h>\n\nstatic int ohci_sm501_init(struct usb_hcd *hcd)\n{\n\treturn ohci_init(hcd_to_ohci(hcd));\n}\n\nstatic int ohci_sm501_start(struct usb_hcd *hcd)\n{\n\tstruct device *dev = hcd->self.controller;\n\tint ret;\n\n\tret = ohci_run(hcd_to_ohci(hcd));\n\tif (ret < 0) {\n\t\tdev_err(dev, \"can't start %s\", hcd->self.bus_name);\n\t\tohci_stop(hcd);\n\t}\n\n\treturn ret;\n}\n\n \n\nstatic const struct hc_driver ohci_sm501_hc_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"SM501 OHCI\",\n\t.hcd_priv_size =\tsizeof(struct ohci_hcd),\n\n\t \n\t.irq =\t\t\tohci_irq,\n\t.flags =\t\tHCD_USB11 | HCD_MEMORY,\n\n\t \n\t.reset =\t\tohci_sm501_init,\n\t.start =\t\tohci_sm501_start,\n\t.stop =\t\t\tohci_stop,\n\t.shutdown =\t\tohci_shutdown,\n\n\t \n\t.urb_enqueue =\t\tohci_urb_enqueue,\n\t.urb_dequeue =\t\tohci_urb_dequeue,\n\t.endpoint_disable =\tohci_endpoint_disable,\n\n\t \n\t.get_frame_number =\tohci_get_frame,\n\n\t \n\t.hub_status_data =\tohci_hub_status_data,\n\t.hub_control =\t\tohci_hub_control,\n#ifdef\tCONFIG_PM\n\t.bus_suspend =\t\tohci_bus_suspend,\n\t.bus_resume =\t\tohci_bus_resume,\n#endif\n\t.start_port_reset =\tohci_start_port_reset,\n};\n\n \n\nstatic int ohci_hcd_sm501_drv_probe(struct platform_device *pdev)\n{\n\tconst struct hc_driver *driver = &ohci_sm501_hc_driver;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource\t*res, *mem;\n\tint retval, irq;\n\tstruct usb_hcd *hcd = NULL;\n\n\tirq = retval = platform_get_irq(pdev, 0);\n\tif (retval < 0)\n\t\tgoto err0;\n\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\tif (mem == NULL) {\n\t\tdev_err(dev, \"no resource definition for memory\\n\");\n\t\tretval = -ENOENT;\n\t\tgoto err0;\n\t}\n\n\tif (!request_mem_region(mem->start, resource_size(mem), pdev->name)) {\n\t\tdev_err(dev, \"request_mem_region failed\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err0;\n\t}\n\n\t \n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (res == NULL) {\n\t\tdev_err(dev, \"no resource definition for registers\\n\");\n\t\tretval = -ENOENT;\n\t\tgoto err1;\n\t}\n\n\thcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto err1;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,\tpdev->name)) {\n\t\tdev_err(dev, \"request_mem_region failed\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err3;\n\t}\n\n\thcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\n\tif (hcd->regs == NULL) {\n\t\tdev_err(dev, \"cannot remap registers\\n\");\n\t\tretval = -ENXIO;\n\t\tgoto err4;\n\t}\n\n\tohci_hcd_init(hcd_to_ohci(hcd));\n\n\t \n\n\tretval = usb_hcd_setup_local_mem(hcd, mem->start,\n\t\t\t\t\t mem->start - mem->parent->start,\n\t\t\t\t\t resource_size(mem));\n\tif (retval < 0)\n\t\tgoto err5;\n\tretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (retval)\n\t\tgoto err5;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\t \n\n\tsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);\n\tsm501_modify_reg(dev->parent, SM501_IRQ_MASK, 1 << 6, 0);\n\n\treturn 0;\nerr5:\n\tiounmap(hcd->regs);\nerr4:\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\nerr3:\n\tusb_put_hcd(hcd);\nerr1:\n\trelease_mem_region(mem->start, resource_size(mem));\nerr0:\n\treturn retval;\n}\n\nstatic void ohci_hcd_sm501_drv_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct resource\t*mem;\n\n\tusb_remove_hcd(hcd);\n\tiounmap(hcd->regs);\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\n\tusb_put_hcd(hcd);\n\tmem = platform_get_resource(pdev, IORESOURCE_MEM, 1);\n\trelease_mem_region(mem->start, resource_size(mem));\n\n\t \n\n\tsm501_modify_reg(pdev->dev.parent, SM501_IRQ_MASK, 0, 1 << 6);\n\tsm501_unit_power(pdev->dev.parent, SM501_GATE_USB_HOST, 0);\n}\n\n \n\n#ifdef CONFIG_PM\nstatic int ohci_sm501_suspend(struct platform_device *pdev, pm_message_t msg)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_hcd  *hcd = platform_get_drvdata(pdev);\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint ret;\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tret = ohci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 0);\n\treturn ret;\n}\n\nstatic int ohci_sm501_resume(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(pdev);\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tsm501_unit_power(dev->parent, SM501_GATE_USB_HOST, 1);\n\tohci_resume(hcd, false);\n\treturn 0;\n}\n#else\n#define ohci_sm501_suspend NULL\n#define ohci_sm501_resume NULL\n#endif\n\n \n\n \nstatic struct platform_driver ohci_hcd_sm501_driver = {\n\t.probe\t\t= ohci_hcd_sm501_drv_probe,\n\t.remove_new\t= ohci_hcd_sm501_drv_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.suspend\t= ohci_sm501_suspend,\n\t.resume\t\t= ohci_sm501_resume,\n\t.driver\t\t= {\n\t\t.name\t= \"sm501-usb\",\n\t},\n};\nMODULE_ALIAS(\"platform:sm501-usb\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}