{
  "module_name": "ehci-platform.c",
  "hash_id": "1ab03eae29fa5af94eaf1f32e97765d4ca26389c4a0a69b3f00d1c6ef8e3742f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-platform.c",
  "human_readable_source": "\n \n#include <linux/acpi.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/sys_soc.h>\n#include <linux/timer.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/ehci_pdriver.h>\n#include <linux/usb/of.h>\n\n#include \"ehci.h\"\n\n#define DRIVER_DESC \"EHCI generic platform driver\"\n#define EHCI_MAX_CLKS 4\n#define hcd_to_ehci_priv(h) ((struct ehci_platform_priv *)hcd_to_ehci(h)->priv)\n\n#define BCM_USB_FIFO_THRESHOLD\t0x00800040\n\nstruct ehci_platform_priv {\n\tstruct clk *clks[EHCI_MAX_CLKS];\n\tstruct reset_control *rsts;\n\tbool reset_on_resume;\n\tbool quirk_poll;\n\tstruct timer_list poll_timer;\n\tstruct delayed_work poll_work;\n};\n\nstatic int ehci_platform_reset(struct usb_hcd *hcd)\n{\n\tstruct platform_device *pdev = to_platform_device(hcd->self.controller);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tint retval;\n\n\tehci->has_synopsys_hc_bug = pdata->has_synopsys_hc_bug;\n\n\tif (pdata->pre_setup) {\n\t\tretval = pdata->pre_setup(hcd);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\t}\n\n\tehci->caps = hcd->regs + pdata->caps_offset;\n\tretval = ehci_setup(hcd);\n\tif (retval)\n\t\treturn retval;\n\n\tif (pdata->no_io_watchdog)\n\t\tehci->need_io_watchdog = 0;\n\n\tif (of_device_is_compatible(pdev->dev.of_node, \"brcm,xgs-iproc-ehci\"))\n\t\tehci_writel(ehci, BCM_USB_FIFO_THRESHOLD,\n\t\t\t    &ehci->regs->brcm_insnreg[1]);\n\n\treturn 0;\n}\n\nstatic int ehci_platform_power_on(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk, ret;\n\n\tfor (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++) {\n\t\tret = clk_prepare_enable(priv->clks[clk]);\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\treturn 0;\n\nerr_disable_clks:\n\twhile (--clk >= 0)\n\t\tclk_disable_unprepare(priv->clks[clk]);\n\n\treturn ret;\n}\n\nstatic void ehci_platform_power_off(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk;\n\n\tfor (clk = EHCI_MAX_CLKS - 1; clk >= 0; clk--)\n\t\tif (priv->clks[clk])\n\t\t\tclk_disable_unprepare(priv->clks[clk]);\n}\n\nstatic struct hc_driver __read_mostly ehci_platform_hc_driver;\n\nstatic const struct ehci_driver_overrides platform_overrides __initconst = {\n\t.reset =\t\tehci_platform_reset,\n\t.extra_priv_size =\tsizeof(struct ehci_platform_priv),\n};\n\nstatic struct usb_ehci_pdata ehci_platform_defaults = {\n\t.power_on =\t\tehci_platform_power_on,\n\t.power_suspend =\tehci_platform_power_off,\n\t.power_off =\t\tehci_platform_power_off,\n};\n\n \nstatic bool quirk_poll_check_port_status(struct ehci_hcd *ehci)\n{\n\tu32 port_status = ehci_readl(ehci, &ehci->regs->port_status[0]);\n\n\tif (!(port_status & PORT_OWNER) &&\n\t     (port_status & PORT_POWER) &&\n\t    !(port_status & PORT_CONNECT) &&\n\t     (port_status & PORT_LS_MASK))\n\t\treturn true;\n\n\treturn false;\n}\n\n \nstatic void quirk_poll_rebind_companion(struct ehci_hcd *ehci)\n{\n\tstruct device *companion_dev;\n\tstruct usb_hcd *hcd = ehci_to_hcd(ehci);\n\n\tcompanion_dev = usb_of_get_companion_dev(hcd->self.controller);\n\tif (!companion_dev)\n\t\treturn;\n\n\tdevice_release_driver(companion_dev);\n\tif (device_attach(companion_dev) < 0)\n\t\tehci_err(ehci, \"%s: failed\\n\", __func__);\n\n\tput_device(companion_dev);\n}\n\nstatic void quirk_poll_work(struct work_struct *work)\n{\n\tstruct ehci_platform_priv *priv =\n\t\tcontainer_of(to_delayed_work(work), struct ehci_platform_priv,\n\t\t\t     poll_work);\n\tstruct ehci_hcd *ehci = container_of((void *)priv, struct ehci_hcd,\n\t\t\t\t\t     priv);\n\n\t \n\tif (!quirk_poll_check_port_status(ehci))\n\t\treturn;\n\tudelay(10);\n\tif (!quirk_poll_check_port_status(ehci))\n\t\treturn;\n\n\tehci_dbg(ehci, \"%s: detected getting stuck. rebind now!\\n\", __func__);\n\tquirk_poll_rebind_companion(ehci);\n}\n\nstatic void quirk_poll_timer(struct timer_list *t)\n{\n\tstruct ehci_platform_priv *priv = from_timer(priv, t, poll_timer);\n\tstruct ehci_hcd *ehci = container_of((void *)priv, struct ehci_hcd,\n\t\t\t\t\t     priv);\n\n\tif (quirk_poll_check_port_status(ehci)) {\n\t\t \n\t\tschedule_delayed_work(&priv->poll_work, msecs_to_jiffies(5));\n\t}\n\n\tmod_timer(&priv->poll_timer, jiffies + HZ);\n}\n\nstatic void quirk_poll_init(struct ehci_platform_priv *priv)\n{\n\tINIT_DELAYED_WORK(&priv->poll_work, quirk_poll_work);\n\ttimer_setup(&priv->poll_timer, quirk_poll_timer, 0);\n\tmod_timer(&priv->poll_timer, jiffies + HZ);\n}\n\nstatic void quirk_poll_end(struct ehci_platform_priv *priv)\n{\n\tdel_timer_sync(&priv->poll_timer);\n\tcancel_delayed_work(&priv->poll_work);\n}\n\nstatic const struct soc_device_attribute quirk_poll_match[] = {\n\t{ .family = \"R-Car Gen3\" },\n\t{   }\n};\n\nstatic int ehci_platform_probe(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct resource *res_mem;\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\n\tstruct ehci_platform_priv *priv;\n\tstruct ehci_hcd *ehci;\n\tint err, irq, clk = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t \n\tif (!pdata)\n\t\tpdata = &ehci_platform_defaults;\n\n\terr = dma_coerce_mask_and_coherent(&dev->dev,\n\t\tpdata->dma_mask_64 ? DMA_BIT_MASK(64) : DMA_BIT_MASK(32));\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Error: DMA mask configuration failed\\n\");\n\t\treturn err;\n\t}\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,\n\t\t\t     dev_name(&dev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(dev, hcd);\n\tdev->dev.platform_data = pdata;\n\tpriv = hcd_to_ehci_priv(hcd);\n\tehci = hcd_to_ehci(hcd);\n\n\tif (pdata == &ehci_platform_defaults && dev->dev.of_node) {\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian-regs\"))\n\t\t\tehci->big_endian_mmio = 1;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian-desc\"))\n\t\t\tehci->big_endian_desc = 1;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian\"))\n\t\t\tehci->big_endian_mmio = ehci->big_endian_desc = 1;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"spurious-oc\"))\n\t\t\tehci->spurious_oc = 1;\n\n\t\tif (of_property_read_bool(dev->dev.of_node,\n\t\t\t\t\t  \"needs-reset-on-resume\"))\n\t\t\tpriv->reset_on_resume = true;\n\n\t\tif (of_property_read_bool(dev->dev.of_node,\n\t\t\t\t\t  \"has-transaction-translator\"))\n\t\t\thcd->has_tt = 1;\n\n\t\tif (of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t    \"aspeed,ast2500-ehci\") ||\n\t\t    of_device_is_compatible(dev->dev.of_node,\n\t\t\t\t\t    \"aspeed,ast2600-ehci\"))\n\t\t\tehci->is_aspeed = 1;\n\n\t\tif (soc_device_match(quirk_poll_match))\n\t\t\tpriv->quirk_poll = true;\n\n\t\tfor (clk = 0; clk < EHCI_MAX_CLKS; clk++) {\n\t\t\tpriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\n\t\t\tif (IS_ERR(priv->clks[clk])) {\n\t\t\t\terr = PTR_ERR(priv->clks[clk]);\n\t\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\t\tgoto err_put_clks;\n\t\t\t\tpriv->clks[clk] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpriv->rsts = devm_reset_control_array_get_optional_shared(&dev->dev);\n\tif (IS_ERR(priv->rsts)) {\n\t\terr = PTR_ERR(priv->rsts);\n\t\tgoto err_put_clks;\n\t}\n\n\terr = reset_control_deassert(priv->rsts);\n\tif (err)\n\t\tgoto err_put_clks;\n\n\tif (pdata->big_endian_desc)\n\t\tehci->big_endian_desc = 1;\n\tif (pdata->big_endian_mmio)\n\t\tehci->big_endian_mmio = 1;\n\tif (pdata->has_tt)\n\t\thcd->has_tt = 1;\n\tif (pdata->reset_on_resume)\n\t\tpriv->reset_on_resume = true;\n\tif (pdata->spurious_oc)\n\t\tehci->spurious_oc = 1;\n\n#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\n\tif (ehci->big_endian_mmio) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Error: CONFIG_USB_EHCI_BIG_ENDIAN_MMIO not set\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_reset;\n\t}\n#endif\n#ifndef CONFIG_USB_EHCI_BIG_ENDIAN_DESC\n\tif (ehci->big_endian_desc) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Error: CONFIG_USB_EHCI_BIG_ENDIAN_DESC not set\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_reset;\n\t}\n#endif\n\n\tif (pdata->power_on) {\n\t\terr = pdata->power_on(dev);\n\t\tif (err < 0)\n\t\t\tgoto err_reset;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(dev, 0, &res_mem);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto err_power;\n\t}\n\thcd->rsrc_start = res_mem->start;\n\thcd->rsrc_len = resource_size(res_mem);\n\n\thcd->tpl_support = of_usb_host_tpl_support(dev->dev.of_node);\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err)\n\t\tgoto err_power;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\tdevice_enable_async_suspend(hcd->self.controller);\n\tplatform_set_drvdata(dev, hcd);\n\n\tif (priv->quirk_poll)\n\t\tquirk_poll_init(priv);\n\n\treturn err;\n\nerr_power:\n\tif (pdata->power_off)\n\t\tpdata->power_off(dev);\nerr_reset:\n\treset_control_assert(priv->rsts);\nerr_put_clks:\n\twhile (--clk >= 0)\n\t\tclk_put(priv->clks[clk]);\n\n\tif (pdata == &ehci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n\n\tusb_put_hcd(hcd);\n\n\treturn err;\n}\n\nstatic void ehci_platform_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\n\tstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk;\n\n\tif (priv->quirk_poll)\n\t\tquirk_poll_end(priv);\n\n\tusb_remove_hcd(hcd);\n\n\tif (pdata->power_off)\n\t\tpdata->power_off(dev);\n\n\treset_control_assert(priv->rsts);\n\n\tfor (clk = 0; clk < EHCI_MAX_CLKS && priv->clks[clk]; clk++)\n\t\tclk_put(priv->clks[clk]);\n\n\tusb_put_hcd(hcd);\n\n\tif (pdata == &ehci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n}\n\nstatic int __maybe_unused ehci_platform_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint ret;\n\n\tif (priv->quirk_poll)\n\t\tquirk_poll_end(priv);\n\n\tret = ehci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata->power_suspend)\n\t\tpdata->power_suspend(pdev);\n\n\treturn ret;\n}\n\nstatic int __maybe_unused ehci_platform_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tstruct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tstruct device *companion_dev;\n\n\tif (pdata->power_on) {\n\t\tint err = pdata->power_on(pdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tcompanion_dev = usb_of_get_companion_dev(hcd->self.controller);\n\tif (companion_dev) {\n\t\tdevice_pm_wait_for_dev(hcd->self.controller, companion_dev);\n\t\tput_device(companion_dev);\n\t}\n\n\tehci_resume(hcd, priv->reset_on_resume);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\tif (priv->quirk_poll)\n\t\tquirk_poll_init(priv);\n\n\treturn 0;\n}\n\nstatic const struct of_device_id vt8500_ehci_ids[] = {\n\t{ .compatible = \"via,vt8500-ehci\", },\n\t{ .compatible = \"wm,prizm-ehci\", },\n\t{ .compatible = \"generic-ehci\", },\n\t{ .compatible = \"cavium,octeon-6335-ehci\", },\n\t{}\n};\nMODULE_DEVICE_TABLE(of, vt8500_ehci_ids);\n\n#ifdef CONFIG_ACPI\nstatic const struct acpi_device_id ehci_acpi_match[] = {\n\t{ \"PNP0D20\", 0 },  \n\t{ }\n};\nMODULE_DEVICE_TABLE(acpi, ehci_acpi_match);\n#endif\n\nstatic const struct platform_device_id ehci_platform_table[] = {\n\t{ \"ehci-platform\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, ehci_platform_table);\n\nstatic SIMPLE_DEV_PM_OPS(ehci_platform_pm_ops, ehci_platform_suspend,\n\tehci_platform_resume);\n\nstatic struct platform_driver ehci_platform_driver = {\n\t.id_table\t= ehci_platform_table,\n\t.probe\t\t= ehci_platform_probe,\n\t.remove_new\t= ehci_platform_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"ehci-platform\",\n\t\t.pm\t= pm_ptr(&ehci_platform_pm_ops),\n\t\t.of_match_table = vt8500_ehci_ids,\n\t\t.acpi_match_table = ACPI_PTR(ehci_acpi_match),\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t}\n};\n\nstatic int __init ehci_platform_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\n\treturn platform_driver_register(&ehci_platform_driver);\n}\nmodule_init(ehci_platform_init);\n\nstatic void __exit ehci_platform_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_platform_driver);\n}\nmodule_exit(ehci_platform_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Hauke Mehrtens\");\nMODULE_AUTHOR(\"Alan Stern\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}