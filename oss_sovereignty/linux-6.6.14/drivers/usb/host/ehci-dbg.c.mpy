{
  "module_name": "ehci-dbg.c",
  "hash_id": "f94f1de8d1e3c164464e04da9e1d691f8aba6beabb4967ac89f5382c3efa93b5",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-dbg.c",
  "human_readable_source": "\n \n\n \n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\n \nstatic void dbg_hcs_params(struct ehci_hcd *ehci, char *label)\n{\n\tu32\tparams = ehci_readl(ehci, &ehci->caps->hcs_params);\n\n\tehci_dbg(ehci,\n\t\t\"%s hcs_params 0x%x dbg=%d%s cc=%d pcc=%d%s%s ports=%d\\n\",\n\t\tlabel, params,\n\t\tHCS_DEBUG_PORT(params),\n\t\tHCS_INDICATOR(params) ? \" ind\" : \"\",\n\t\tHCS_N_CC(params),\n\t\tHCS_N_PCC(params),\n\t\tHCS_PORTROUTED(params) ? \"\" : \" ordered\",\n\t\tHCS_PPC(params) ? \"\" : \" !ppc\",\n\t\tHCS_N_PORTS(params));\n\t \n\tif (HCS_PORTROUTED(params)) {\n\t\tint i;\n\t\tchar buf[46], tmp[7], byte;\n\n\t\tbuf[0] = 0;\n\t\tfor (i = 0; i < HCS_N_PORTS(params); i++) {\n\t\t\t \n\t\t\tbyte = readb(&ehci->caps->portroute[(i >> 1)]);\n\t\t\tsprintf(tmp, \"%d \",\n\t\t\t\t(i & 0x1) ? byte & 0xf : (byte >> 4) & 0xf);\n\t\t\tstrcat(buf, tmp);\n\t\t}\n\t\tehci_dbg(ehci, \"%s portroute %s\\n\", label, buf);\n\t}\n}\n\n \nstatic void dbg_hcc_params(struct ehci_hcd *ehci, char *label)\n{\n\tu32\tparams = ehci_readl(ehci, &ehci->caps->hcc_params);\n\n\tif (HCC_ISOC_CACHE(params)) {\n\t\tehci_dbg(ehci,\n\t\t\t\"%s hcc_params %04x caching frame %s%s%s\\n\",\n\t\t\tlabel, params,\n\t\t\tHCC_PGM_FRAMELISTLEN(params) ? \"256/512/1024\" : \"1024\",\n\t\t\tHCC_CANPARK(params) ? \" park\" : \"\",\n\t\t\tHCC_64BIT_ADDR(params) ? \" 64 bit addr\" : \"\");\n\t} else {\n\t\tehci_dbg(ehci,\n\t\t\t\"%s hcc_params %04x thresh %d uframes %s%s%s%s%s%s%s\\n\",\n\t\t\tlabel,\n\t\t\tparams,\n\t\t\tHCC_ISOC_THRES(params),\n\t\t\tHCC_PGM_FRAMELISTLEN(params) ? \"256/512/1024\" : \"1024\",\n\t\t\tHCC_CANPARK(params) ? \" park\" : \"\",\n\t\t\tHCC_64BIT_ADDR(params) ? \" 64 bit addr\" : \"\",\n\t\t\tHCC_LPM(params) ? \" LPM\" : \"\",\n\t\t\tHCC_PER_PORT_CHANGE_EVENT(params) ? \" ppce\" : \"\",\n\t\t\tHCC_HW_PREFETCH(params) ? \" hw prefetch\" : \"\",\n\t\t\tHCC_32FRAME_PERIODIC_LIST(params) ?\n\t\t\t\t\" 32 periodic list\" : \"\");\n\t}\n}\n\nstatic void __maybe_unused\ndbg_qtd(const char *label, struct ehci_hcd *ehci, struct ehci_qtd *qtd)\n{\n\tehci_dbg(ehci, \"%s td %p n%08x %08x t%08x p0=%08x\\n\", label, qtd,\n\t\thc32_to_cpup(ehci, &qtd->hw_next),\n\t\thc32_to_cpup(ehci, &qtd->hw_alt_next),\n\t\thc32_to_cpup(ehci, &qtd->hw_token),\n\t\thc32_to_cpup(ehci, &qtd->hw_buf[0]));\n\tif (qtd->hw_buf[1])\n\t\tehci_dbg(ehci, \"  p1=%08x p2=%08x p3=%08x p4=%08x\\n\",\n\t\t\thc32_to_cpup(ehci, &qtd->hw_buf[1]),\n\t\t\thc32_to_cpup(ehci, &qtd->hw_buf[2]),\n\t\t\thc32_to_cpup(ehci, &qtd->hw_buf[3]),\n\t\t\thc32_to_cpup(ehci, &qtd->hw_buf[4]));\n}\n\nstatic void __maybe_unused\ndbg_qh(const char *label, struct ehci_hcd *ehci, struct ehci_qh *qh)\n{\n\tstruct ehci_qh_hw *hw = qh->hw;\n\n\tehci_dbg(ehci, \"%s qh %p n%08x info %x %x qtd %x\\n\", label,\n\t\tqh, hw->hw_next, hw->hw_info1, hw->hw_info2, hw->hw_current);\n\tdbg_qtd(\"overlay\", ehci, (struct ehci_qtd *) &hw->hw_qtd_next);\n}\n\nstatic void __maybe_unused\ndbg_itd(const char *label, struct ehci_hcd *ehci, struct ehci_itd *itd)\n{\n\tehci_dbg(ehci, \"%s [%d] itd %p, next %08x, urb %p\\n\",\n\t\tlabel, itd->frame, itd, hc32_to_cpu(ehci, itd->hw_next),\n\t\titd->urb);\n\tehci_dbg(ehci,\n\t\t\"  trans: %08x %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\thc32_to_cpu(ehci, itd->hw_transaction[0]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[1]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[2]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[3]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[4]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[5]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[6]),\n\t\thc32_to_cpu(ehci, itd->hw_transaction[7]));\n\tehci_dbg(ehci,\n\t\t\"  buf:   %08x %08x %08x %08x %08x %08x %08x\\n\",\n\t\thc32_to_cpu(ehci, itd->hw_bufp[0]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[1]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[2]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[3]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[4]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[5]),\n\t\thc32_to_cpu(ehci, itd->hw_bufp[6]));\n\tehci_dbg(ehci, \"  index: %d %d %d %d %d %d %d %d\\n\",\n\t\titd->index[0], itd->index[1], itd->index[2],\n\t\titd->index[3], itd->index[4], itd->index[5],\n\t\titd->index[6], itd->index[7]);\n}\n\nstatic void __maybe_unused\ndbg_sitd(const char *label, struct ehci_hcd *ehci, struct ehci_sitd *sitd)\n{\n\tehci_dbg(ehci, \"%s [%d] sitd %p, next %08x, urb %p\\n\",\n\t\tlabel, sitd->frame, sitd, hc32_to_cpu(ehci, sitd->hw_next),\n\t\tsitd->urb);\n\tehci_dbg(ehci,\n\t\t\"  addr %08x sched %04x result %08x buf %08x %08x\\n\",\n\t\thc32_to_cpu(ehci, sitd->hw_fullspeed_ep),\n\t\thc32_to_cpu(ehci, sitd->hw_uframe),\n\t\thc32_to_cpu(ehci, sitd->hw_results),\n\t\thc32_to_cpu(ehci, sitd->hw_buf[0]),\n\t\thc32_to_cpu(ehci, sitd->hw_buf[1]));\n}\n\nstatic int __maybe_unused\ndbg_status_buf(char *buf, unsigned len, const char *label, u32 status)\n{\n\treturn scnprintf(buf, len,\n\t\t\"%s%sstatus %04x%s%s%s%s%s%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", status,\n\t\t(status & STS_PPCE_MASK) ? \" PPCE\" : \"\",\n\t\t(status & STS_ASS) ? \" Async\" : \"\",\n\t\t(status & STS_PSS) ? \" Periodic\" : \"\",\n\t\t(status & STS_RECL) ? \" Recl\" : \"\",\n\t\t(status & STS_HALT) ? \" Halt\" : \"\",\n\t\t(status & STS_IAA) ? \" IAA\" : \"\",\n\t\t(status & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t(status & STS_FLR) ? \" FLR\" : \"\",\n\t\t(status & STS_PCD) ? \" PCD\" : \"\",\n\t\t(status & STS_ERR) ? \" ERR\" : \"\",\n\t\t(status & STS_INT) ? \" INT\" : \"\");\n}\n\nstatic int __maybe_unused\ndbg_intr_buf(char *buf, unsigned len, const char *label, u32 enable)\n{\n\treturn scnprintf(buf, len,\n\t\t\"%s%sintrenable %02x%s%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", enable,\n\t\t(enable & STS_PPCE_MASK) ? \" PPCE\" : \"\",\n\t\t(enable & STS_IAA) ? \" IAA\" : \"\",\n\t\t(enable & STS_FATAL) ? \" FATAL\" : \"\",\n\t\t(enable & STS_FLR) ? \" FLR\" : \"\",\n\t\t(enable & STS_PCD) ? \" PCD\" : \"\",\n\t\t(enable & STS_ERR) ? \" ERR\" : \"\",\n\t\t(enable & STS_INT) ? \" INT\" : \"\");\n}\n\nstatic const char *const fls_strings[] = { \"1024\", \"512\", \"256\", \"??\" };\n\nstatic int\ndbg_command_buf(char *buf, unsigned len, const char *label, u32 command)\n{\n\treturn scnprintf(buf, len,\n\t\t\"%s%scommand %07x %s%s%s%s%s%s=%d ithresh=%d%s%s%s%s \"\n\t\t\"period=%s%s %s\",\n\t\tlabel, label[0] ? \" \" : \"\", command,\n\t\t(command & CMD_HIRD) ? \" HIRD\" : \"\",\n\t\t(command & CMD_PPCEE) ? \" PPCEE\" : \"\",\n\t\t(command & CMD_FSP) ? \" FSP\" : \"\",\n\t\t(command & CMD_ASPE) ? \" ASPE\" : \"\",\n\t\t(command & CMD_PSPE) ? \" PSPE\" : \"\",\n\t\t(command & CMD_PARK) ? \" park\" : \"(park)\",\n\t\tCMD_PARK_CNT(command),\n\t\t(command >> 16) & 0x3f,\n\t\t(command & CMD_LRESET) ? \" LReset\" : \"\",\n\t\t(command & CMD_IAAD) ? \" IAAD\" : \"\",\n\t\t(command & CMD_ASE) ? \" Async\" : \"\",\n\t\t(command & CMD_PSE) ? \" Periodic\" : \"\",\n\t\tfls_strings[(command >> 2) & 0x3],\n\t\t(command & CMD_RESET) ? \" Reset\" : \"\",\n\t\t(command & CMD_RUN) ? \"RUN\" : \"HALT\");\n}\n\nstatic int\ndbg_port_buf(char *buf, unsigned len, const char *label, int port, u32 status)\n{\n\tchar\t*sig;\n\n\t \n\tswitch (status & (3 << 10)) {\n\tcase 0 << 10:\n\t\tsig = \"se0\";\n\t\tbreak;\n\tcase 1 << 10:  \n\t\tsig = \"k\";\n\t\tbreak;\n\tcase 2 << 10:\n\t\tsig = \"j\";\n\t\tbreak;\n\tdefault:\n\t\tsig = \"?\";\n\t\tbreak;\n\t}\n\n\treturn scnprintf(buf, len,\n\t\t\"%s%sport:%d status %06x %d %s%s%s%s%s%s \"\n\t\t\"sig=%s%s%s%s%s%s%s%s%s%s%s\",\n\t\tlabel, label[0] ? \" \" : \"\", port, status,\n\t\tstatus >> 25,  \n\t\t(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_ACK ?\n\t\t\t\t\t\t\" ACK\" : \"\",\n\t\t(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_NYET ?\n\t\t\t\t\t\t\" NYET\" : \"\",\n\t\t(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_STALL ?\n\t\t\t\t\t\t\" STALL\" : \"\",\n\t\t(status & PORT_SSTS) >> 23 == PORTSC_SUSPEND_STS_ERR ?\n\t\t\t\t\t\t\" ERR\" : \"\",\n\t\t(status & PORT_POWER) ? \" POWER\" : \"\",\n\t\t(status & PORT_OWNER) ? \" OWNER\" : \"\",\n\t\tsig,\n\t\t(status & PORT_LPM) ? \" LPM\" : \"\",\n\t\t(status & PORT_RESET) ? \" RESET\" : \"\",\n\t\t(status & PORT_SUSPEND) ? \" SUSPEND\" : \"\",\n\t\t(status & PORT_RESUME) ? \" RESUME\" : \"\",\n\t\t(status & PORT_OCC) ? \" OCC\" : \"\",\n\t\t(status & PORT_OC) ? \" OC\" : \"\",\n\t\t(status & PORT_PEC) ? \" PEC\" : \"\",\n\t\t(status & PORT_PE) ? \" PE\" : \"\",\n\t\t(status & PORT_CSC) ? \" CSC\" : \"\",\n\t\t(status & PORT_CONNECT) ? \" CONNECT\" : \"\");\n}\n\nstatic inline void\ndbg_status(struct ehci_hcd *ehci, const char *label, u32 status)\n{\n\tchar buf[80];\n\n\tdbg_status_buf(buf, sizeof(buf), label, status);\n\tehci_dbg(ehci, \"%s\\n\", buf);\n}\n\nstatic inline void\ndbg_cmd(struct ehci_hcd *ehci, const char *label, u32 command)\n{\n\tchar buf[80];\n\n\tdbg_command_buf(buf, sizeof(buf), label, command);\n\tehci_dbg(ehci, \"%s\\n\", buf);\n}\n\nstatic inline void\ndbg_port(struct ehci_hcd *ehci, const char *label, int port, u32 status)\n{\n\tchar buf[80];\n\n\tdbg_port_buf(buf, sizeof(buf), label, port, status);\n\tehci_dbg(ehci, \"%s\\n\", buf);\n}\n\n \n\n \n\nstatic int debug_async_open(struct inode *, struct file *);\nstatic int debug_bandwidth_open(struct inode *, struct file *);\nstatic int debug_periodic_open(struct inode *, struct file *);\nstatic int debug_registers_open(struct inode *, struct file *);\n\nstatic ssize_t debug_output(struct file*, char __user*, size_t, loff_t*);\nstatic int debug_close(struct inode *, struct file *);\n\nstatic const struct file_operations debug_async_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_async_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations debug_bandwidth_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_bandwidth_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations debug_periodic_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_periodic_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations debug_registers_fops = {\n\t.owner\t\t= THIS_MODULE,\n\t.open\t\t= debug_registers_open,\n\t.read\t\t= debug_output,\n\t.release\t= debug_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct dentry *ehci_debug_root;\n\nstruct debug_buffer {\n\tssize_t (*fill_func)(struct debug_buffer *);\t \n\tstruct usb_bus *bus;\n\tstruct mutex mutex;\t \n\tsize_t count;\t\t \n\tchar *output_buf;\n\tsize_t alloc_size;\n};\n\nstatic inline char speed_char(u32 info1)\n{\n\tswitch (info1 & (3 << 12)) {\n\tcase QH_FULL_SPEED:\n\t\treturn 'f';\n\tcase QH_LOW_SPEED:\n\t\treturn 'l';\n\tcase QH_HIGH_SPEED:\n\t\treturn 'h';\n\tdefault:\n\t\treturn '?';\n\t}\n}\n\nstatic inline char token_mark(struct ehci_hcd *ehci, __hc32 token)\n{\n\t__u32 v = hc32_to_cpu(ehci, token);\n\n\tif (v & QTD_STS_ACTIVE)\n\t\treturn '*';\n\tif (v & QTD_STS_HALT)\n\t\treturn '-';\n\tif (!IS_SHORT_READ(v))\n\t\treturn ' ';\n\t \n\treturn '/';\n}\n\nstatic void qh_lines(struct ehci_hcd *ehci, struct ehci_qh *qh,\n\t\tchar **nextp, unsigned *sizep)\n{\n\tu32\t\t\tscratch;\n\tu32\t\t\thw_curr;\n\tstruct list_head\t*entry;\n\tstruct ehci_qtd\t\t*td;\n\tunsigned\t\ttemp;\n\tunsigned\t\tsize = *sizep;\n\tchar\t\t\t*next = *nextp;\n\tchar\t\t\tmark;\n\t__le32\t\t\tlist_end = EHCI_LIST_END(ehci);\n\tstruct ehci_qh_hw\t*hw = qh->hw;\n\n\tif (hw->hw_qtd_next == list_end)\t \n\t\tmark = '@';\n\telse\n\t\tmark = token_mark(ehci, hw->hw_token);\n\tif (mark == '/') {\t \n\t\tif ((hw->hw_alt_next & QTD_MASK(ehci))\n\t\t\t\t== ehci->async->hw->hw_alt_next)\n\t\t\tmark = '#';\t \n\t\telse if (hw->hw_alt_next == list_end)\n\t\t\tmark = '.';\t \n\t\t \n\t}\n\tscratch = hc32_to_cpup(ehci, &hw->hw_info1);\n\thw_curr = (mark == '*') ? hc32_to_cpup(ehci, &hw->hw_current) : 0;\n\ttemp = scnprintf(next, size,\n\t\t\t\"qh/%p dev%d %cs ep%d %08x %08x (%08x%c %s nak%d)\"\n\t\t\t\" [cur %08x next %08x buf[0] %08x]\",\n\t\t\tqh, scratch & 0x007f,\n\t\t\tspeed_char (scratch),\n\t\t\t(scratch >> 8) & 0x000f,\n\t\t\tscratch, hc32_to_cpup(ehci, &hw->hw_info2),\n\t\t\thc32_to_cpup(ehci, &hw->hw_token), mark,\n\t\t\t(cpu_to_hc32(ehci, QTD_TOGGLE) & hw->hw_token)\n\t\t\t\t? \"data1\" : \"data0\",\n\t\t\t(hc32_to_cpup(ehci, &hw->hw_alt_next) >> 1) & 0x0f,\n\t\t\thc32_to_cpup(ehci, &hw->hw_current),\n\t\t\thc32_to_cpup(ehci, &hw->hw_qtd_next),\n\t\t\thc32_to_cpup(ehci, &hw->hw_buf[0]));\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tlist_for_each(entry, &qh->qtd_list) {\n\t\tchar *type;\n\n\t\ttd = list_entry(entry, struct ehci_qtd, qtd_list);\n\t\tscratch = hc32_to_cpup(ehci, &td->hw_token);\n\t\tmark = ' ';\n\t\tif (hw_curr == td->qtd_dma) {\n\t\t\tmark = '*';\n\t\t} else if (hw->hw_qtd_next == cpu_to_hc32(ehci, td->qtd_dma)) {\n\t\t\tmark = '+';\n\t\t} else if (QTD_LENGTH(scratch)) {\n\t\t\tif (td->hw_alt_next == ehci->async->hw->hw_alt_next)\n\t\t\t\tmark = '#';\n\t\t\telse if (td->hw_alt_next != list_end)\n\t\t\t\tmark = '/';\n\t\t}\n\t\tswitch ((scratch >> 8) & 0x03) {\n\t\tcase 0:\n\t\t\ttype = \"out\";\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\ttype = \"in\";\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttype = \"setup\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttype = \"?\";\n\t\t\tbreak;\n\t\t}\n\t\ttemp = scnprintf(next, size,\n\t\t\t\t\"\\n\\t%p%c%s len=%d %08x urb %p\"\n\t\t\t\t\" [td %08x buf[0] %08x]\",\n\t\t\t\ttd, mark, type,\n\t\t\t\t(scratch >> 16) & 0x7fff,\n\t\t\t\tscratch,\n\t\t\t\ttd->urb,\n\t\t\t\t(u32) td->qtd_dma,\n\t\t\t\thc32_to_cpup(ehci, &td->hw_buf[0]));\n\t\tsize -= temp;\n\t\tnext += temp;\n\t\tif (temp == size)\n\t\t\tgoto done;\n\t}\n\n\ttemp = scnprintf(next, size, \"\\n\");\n\tsize -= temp;\n\tnext += temp;\n\ndone:\n\t*sizep = size;\n\t*nextp = next;\n}\n\nstatic ssize_t fill_async_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct ehci_hcd\t\t*ehci;\n\tunsigned long\t\tflags;\n\tunsigned\t\ttemp, size;\n\tchar\t\t\t*next;\n\tstruct ehci_qh\t\t*qh;\n\n\thcd = bus_to_hcd(buf->bus);\n\tehci = hcd_to_ehci(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\t*next = 0;\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tfor (qh = ehci->async->qh_next.qh; size > 0 && qh; qh = qh->qh_next.qh)\n\t\tqh_lines(ehci, qh, &next, &size);\n\tif (!list_empty(&ehci->async_unlink) && size > 0) {\n\t\ttemp = scnprintf(next, size, \"\\nunlink =\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tlist_for_each_entry(qh, &ehci->async_unlink, unlink_node) {\n\t\t\tif (size <= 0)\n\t\t\t\tbreak;\n\t\t\tqh_lines(ehci, qh, &next, &size);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\n\treturn strlen(buf->output_buf);\n}\n\nstatic ssize_t fill_bandwidth_buffer(struct debug_buffer *buf)\n{\n\tstruct ehci_hcd\t\t*ehci;\n\tstruct ehci_tt\t\t*tt;\n\tstruct ehci_per_sched\t*ps;\n\tunsigned\t\ttemp, size;\n\tchar\t\t\t*next;\n\tunsigned\t\ti;\n\tu8\t\t\t*bw;\n\tu16\t\t\t*bf;\n\tu8\t\t\tbudget[EHCI_BANDWIDTH_SIZE];\n\n\tehci = hcd_to_ehci(bus_to_hcd(buf->bus));\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\t*next = 0;\n\n\tspin_lock_irq(&ehci->lock);\n\n\t \n\ttemp = scnprintf(next, size,\n\t\t\t\"HS bandwidth allocation (us per microframe)\\n\");\n\tsize -= temp;\n\tnext += temp;\n\tfor (i = 0; i < EHCI_BANDWIDTH_SIZE; i += 8) {\n\t\tbw = &ehci->bandwidth[i];\n\t\ttemp = scnprintf(next, size,\n\t\t\t\t\"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\\n\",\n\t\t\t\ti, bw[0], bw[1], bw[2], bw[3],\n\t\t\t\t\tbw[4], bw[5], bw[6], bw[7]);\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\n\t \n\tlist_for_each_entry(tt, &ehci->tt_list, tt_list) {\n\t\ttemp = scnprintf(next, size,\n\t\t\t\t\"\\nTT %s port %d  FS/LS bandwidth allocation (us per frame)\\n\",\n\t\t\t\tdev_name(&tt->usb_tt->hub->dev),\n\t\t\t\ttt->tt_port + !!tt->usb_tt->multi);\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tbf = tt->bandwidth;\n\t\ttemp = scnprintf(next, size,\n\t\t\t\t\"  %5u%5u%5u%5u%5u%5u%5u%5u\\n\",\n\t\t\t\tbf[0], bf[1], bf[2], bf[3],\n\t\t\t\t\tbf[4], bf[5], bf[6], bf[7]);\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\ttemp = scnprintf(next, size,\n\t\t\t\t\"FS/LS budget (us per microframe)\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\t\tcompute_tt_budget(budget, tt);\n\t\tfor (i = 0; i < EHCI_BANDWIDTH_SIZE; i += 8) {\n\t\t\tbw = &budget[i];\n\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\"%2u: %4u%4u%4u%4u%4u%4u%4u%4u\\n\",\n\t\t\t\t\ti, bw[0], bw[1], bw[2], bw[3],\n\t\t\t\t\t\tbw[4], bw[5], bw[6], bw[7]);\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t}\n\t\tlist_for_each_entry(ps, &tt->ps_list, ps_list) {\n\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\"%s ep %02x:  %4u @ %2u.%u+%u mask %04x\\n\",\n\t\t\t\t\tdev_name(&ps->udev->dev),\n\t\t\t\t\tps->ep->desc.bEndpointAddress,\n\t\t\t\t\tps->tt_usecs,\n\t\t\t\t\tps->bw_phase, ps->phase_uf,\n\t\t\t\t\tps->bw_period, ps->cs_mask);\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t}\n\t}\n\tspin_unlock_irq(&ehci->lock);\n\n\treturn next - buf->output_buf;\n}\n\nstatic unsigned output_buf_tds_dir(char *buf, struct ehci_hcd *ehci,\n\t\tstruct ehci_qh_hw *hw, struct ehci_qh *qh, unsigned size)\n{\n\tu32\t\t\tscratch = hc32_to_cpup(ehci, &hw->hw_info1);\n\tstruct ehci_qtd\t\t*qtd;\n\tchar\t\t\t*type = \"\";\n\tunsigned\t\ttemp = 0;\n\n\t \n\tlist_for_each_entry(qtd, &qh->qtd_list, qtd_list) {\n\t\ttemp++;\n\t\tswitch ((hc32_to_cpu(ehci, qtd->hw_token) >> 8)\t& 0x03) {\n\t\tcase 0:\n\t\t\ttype = \"out\";\n\t\t\tcontinue;\n\t\tcase 1:\n\t\t\ttype = \"in\";\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn scnprintf(buf, size, \" (%c%d ep%d%s [%d/%d] q%d p%d)\",\n\t\t\tspeed_char(scratch), scratch & 0x007f,\n\t\t\t(scratch >> 8) & 0x000f, type, qh->ps.usecs,\n\t\t\tqh->ps.c_usecs, temp, 0x7ff & (scratch >> 16));\n}\n\n#define DBG_SCHED_LIMIT 64\nstatic ssize_t fill_periodic_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct ehci_hcd\t\t*ehci;\n\tunsigned long\t\tflags;\n\tunion ehci_shadow\tp, *seen;\n\tunsigned\t\ttemp, size, seen_count;\n\tchar\t\t\t*next;\n\tunsigned\t\ti;\n\t__hc32\t\t\ttag;\n\n\tseen = kmalloc_array(DBG_SCHED_LIMIT, sizeof(*seen), GFP_ATOMIC);\n\tif (!seen)\n\t\treturn 0;\n\tseen_count = 0;\n\n\thcd = bus_to_hcd(buf->bus);\n\tehci = hcd_to_ehci(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\ttemp = scnprintf(next, size, \"size = %d\\n\", ehci->periodic_size);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\tspin_lock_irqsave(&ehci->lock, flags);\n\tfor (i = 0; i < ehci->periodic_size; i++) {\n\t\tp = ehci->pshadow[i];\n\t\tif (likely(!p.ptr))\n\t\t\tcontinue;\n\t\ttag = Q_NEXT_TYPE(ehci, ehci->periodic[i]);\n\n\t\ttemp = scnprintf(next, size, \"%4d: \", i);\n\t\tsize -= temp;\n\t\tnext += temp;\n\n\t\tdo {\n\t\t\tstruct ehci_qh_hw *hw;\n\n\t\t\tswitch (hc32_to_cpu(ehci, tag)) {\n\t\t\tcase Q_TYPE_QH:\n\t\t\t\thw = p.qh->hw;\n\t\t\t\ttemp = scnprintf(next, size, \" qh%d-%04x/%p\",\n\t\t\t\t\t\tp.qh->ps.period,\n\t\t\t\t\t\thc32_to_cpup(ehci,\n\t\t\t\t\t\t\t&hw->hw_info2)\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t& (QH_CMASK | QH_SMASK),\n\t\t\t\t\t\tp.qh);\n\t\t\t\tsize -= temp;\n\t\t\t\tnext += temp;\n\t\t\t\t \n\t\t\t\tfor (temp = 0; temp < seen_count; temp++) {\n\t\t\t\t\tif (seen[temp].ptr != p.ptr)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (p.qh->qh_next.ptr) {\n\t\t\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\t\t\" ...\");\n\t\t\t\t\t\tsize -= temp;\n\t\t\t\t\t\tnext += temp;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t \n\t\t\t\tif (temp == seen_count) {\n\t\t\t\t\ttemp = output_buf_tds_dir(next, ehci,\n\t\t\t\t\t\thw, p.qh, size);\n\n\t\t\t\t\tif (seen_count < DBG_SCHED_LIMIT)\n\t\t\t\t\t\tseen[seen_count++].qh = p.qh;\n\t\t\t\t} else {\n\t\t\t\t\ttemp = 0;\n\t\t\t\t}\n\t\t\t\ttag = Q_NEXT_TYPE(ehci, hw->hw_next);\n\t\t\t\tp = p.qh->qh_next;\n\t\t\t\tbreak;\n\t\t\tcase Q_TYPE_FSTN:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\" fstn-%8x/%p\", p.fstn->hw_prev,\n\t\t\t\t\tp.fstn);\n\t\t\t\ttag = Q_NEXT_TYPE(ehci, p.fstn->hw_next);\n\t\t\t\tp = p.fstn->fstn_next;\n\t\t\t\tbreak;\n\t\t\tcase Q_TYPE_ITD:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\" itd/%p\", p.itd);\n\t\t\t\ttag = Q_NEXT_TYPE(ehci, p.itd->hw_next);\n\t\t\t\tp = p.itd->itd_next;\n\t\t\t\tbreak;\n\t\t\tcase Q_TYPE_SITD:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\" sitd%d-%04x/%p\",\n\t\t\t\t\tp.sitd->stream->ps.period,\n\t\t\t\t\thc32_to_cpup(ehci, &p.sitd->hw_uframe)\n\t\t\t\t\t\t& 0x0000ffff,\n\t\t\t\t\tp.sitd);\n\t\t\t\ttag = Q_NEXT_TYPE(ehci, p.sitd->hw_next);\n\t\t\t\tp = p.sitd->sitd_next;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t} while (p.ptr);\n\n\t\ttemp = scnprintf(next, size, \"\\n\");\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\tkfree(seen);\n\n\treturn buf->alloc_size - size;\n}\n#undef DBG_SCHED_LIMIT\n\nstatic const char *rh_state_string(struct ehci_hcd *ehci)\n{\n\tswitch (ehci->rh_state) {\n\tcase EHCI_RH_HALTED:\n\t\treturn \"halted\";\n\tcase EHCI_RH_SUSPENDED:\n\t\treturn \"suspended\";\n\tcase EHCI_RH_RUNNING:\n\t\treturn \"running\";\n\tcase EHCI_RH_STOPPING:\n\t\treturn \"stopping\";\n\t}\n\treturn \"?\";\n}\n\nstatic ssize_t fill_registers_buffer(struct debug_buffer *buf)\n{\n\tstruct usb_hcd\t\t*hcd;\n\tstruct ehci_hcd\t\t*ehci;\n\tunsigned long\t\tflags;\n\tunsigned\t\ttemp, size, i;\n\tchar\t\t\t*next, scratch[80];\n\tstatic char\t\tfmt[] = \"%*s\\n\";\n\tstatic char\t\tlabel[] = \"\";\n\n\thcd = bus_to_hcd(buf->bus);\n\tehci = hcd_to_ehci(hcd);\n\tnext = buf->output_buf;\n\tsize = buf->alloc_size;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\n\tif (!HCD_HW_ACCESSIBLE(hcd)) {\n\t\tsize = scnprintf(next, size,\n\t\t\t\"bus %s, device %s\\n\"\n\t\t\t\"%s\\n\"\n\t\t\t\"SUSPENDED (no register access)\\n\",\n\t\t\thcd->self.controller->bus->name,\n\t\t\tdev_name(hcd->self.controller),\n\t\t\thcd->product_desc);\n\t\tgoto done;\n\t}\n\n\t \n\ti = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));\n\ttemp = scnprintf(next, size,\n\t\t\"bus %s, device %s\\n\"\n\t\t\"%s\\n\"\n\t\t\"EHCI %x.%02x, rh state %s\\n\",\n\t\thcd->self.controller->bus->name,\n\t\tdev_name(hcd->self.controller),\n\t\thcd->product_desc,\n\t\ti >> 8, i & 0x0ff, rh_state_string(ehci));\n\tsize -= temp;\n\tnext += temp;\n\n#ifdef\tCONFIG_USB_PCI\n\t \n\tif (dev_is_pci(hcd->self.controller)) {\n\t\tstruct pci_dev\t*pdev;\n\t\tu32\t\toffset, cap, cap2;\n\t\tunsigned\tcount = 256 / 4;\n\n\t\tpdev = to_pci_dev(ehci_to_hcd(ehci)->self.controller);\n\t\toffset = HCC_EXT_CAPS(ehci_readl(ehci,\n\t\t\t\t&ehci->caps->hcc_params));\n\t\twhile (offset && count--) {\n\t\t\tpci_read_config_dword(pdev, offset, &cap);\n\t\t\tswitch (cap & 0xff) {\n\t\t\tcase 1:\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\"ownership %08x%s%s\\n\", cap,\n\t\t\t\t\t(cap & (1 << 24)) ? \" linux\" : \"\",\n\t\t\t\t\t(cap & (1 << 16)) ? \" firmware\" : \"\");\n\t\t\t\tsize -= temp;\n\t\t\t\tnext += temp;\n\n\t\t\t\toffset += 4;\n\t\t\t\tpci_read_config_dword(pdev, offset, &cap2);\n\t\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\"SMI sts/enable 0x%08x\\n\", cap2);\n\t\t\t\tsize -= temp;\n\t\t\t\tnext += temp;\n\t\t\t\tbreak;\n\t\t\tcase 0:\t\t \n\t\t\t\tcap = 0;\n\t\t\t\tfallthrough;\n\t\t\tdefault:\t\t \n\t\t\t\tbreak;\n\t\t\t}\n\t\t\toffset = (cap >> 8) & 0xff;\n\t\t}\n\t}\n#endif\n\n\t \n\ti = ehci_readl(ehci, &ehci->caps->hcs_params);\n\ttemp = scnprintf(next, size, \"structural params 0x%08x\\n\", i);\n\tsize -= temp;\n\tnext += temp;\n\n\ti = ehci_readl(ehci, &ehci->caps->hcc_params);\n\ttemp = scnprintf(next, size, \"capability params 0x%08x\\n\", i);\n\tsize -= temp;\n\tnext += temp;\n\n\t \n\ttemp = dbg_status_buf(scratch, sizeof(scratch), label,\n\t\t\tehci_readl(ehci, &ehci->regs->status));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = dbg_command_buf(scratch, sizeof(scratch), label,\n\t\t\tehci_readl(ehci, &ehci->regs->command));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = dbg_intr_buf(scratch, sizeof(scratch), label,\n\t\t\tehci_readl(ehci, &ehci->regs->intr_enable));\n\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = scnprintf(next, size, \"uframe %04x\\n\",\n\t\t\tehci_read_frame_index(ehci));\n\tsize -= temp;\n\tnext += temp;\n\n\tfor (i = 1; i <= HCS_N_PORTS(ehci->hcs_params); i++) {\n\t\ttemp = dbg_port_buf(scratch, sizeof(scratch), label, i,\n\t\t\t\tehci_readl(ehci,\n\t\t\t\t\t&ehci->regs->port_status[i - 1]));\n\t\ttemp = scnprintf(next, size, fmt, temp, scratch);\n\t\tsize -= temp;\n\t\tnext += temp;\n\t\tif (i == HCS_DEBUG_PORT(ehci->hcs_params) && ehci->debug) {\n\t\t\ttemp = scnprintf(next, size,\n\t\t\t\t\t\"    debug control %08x\\n\",\n\t\t\t\t\tehci_readl(ehci,\n\t\t\t\t\t\t&ehci->debug->control));\n\t\t\tsize -= temp;\n\t\t\tnext += temp;\n\t\t}\n\t}\n\n\tif (!list_empty(&ehci->async_unlink)) {\n\t\ttemp = scnprintf(next, size, \"async unlink qh %p\\n\",\n\t\t\t\tlist_first_entry(&ehci->async_unlink,\n\t\t\t\t\t\tstruct ehci_qh, unlink_node));\n\t\tsize -= temp;\n\t\tnext += temp;\n\t}\n\n#ifdef EHCI_STATS\n\ttemp = scnprintf(next, size,\n\t\t\"irq normal %ld err %ld iaa %ld (lost %ld)\\n\",\n\t\tehci->stats.normal, ehci->stats.error, ehci->stats.iaa,\n\t\tehci->stats.lost_iaa);\n\tsize -= temp;\n\tnext += temp;\n\n\ttemp = scnprintf(next, size, \"complete %ld unlink %ld\\n\",\n\t\tehci->stats.complete, ehci->stats.unlink);\n\tsize -= temp;\n\tnext += temp;\n#endif\n\ndone:\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\n\treturn buf->alloc_size - size;\n}\n\nstatic struct debug_buffer *alloc_buffer(struct usb_bus *bus,\n\t\tssize_t (*fill_func)(struct debug_buffer *))\n{\n\tstruct debug_buffer *buf;\n\n\tbuf = kzalloc(sizeof(*buf), GFP_KERNEL);\n\n\tif (buf) {\n\t\tbuf->bus = bus;\n\t\tbuf->fill_func = fill_func;\n\t\tmutex_init(&buf->mutex);\n\t\tbuf->alloc_size = PAGE_SIZE;\n\t}\n\n\treturn buf;\n}\n\nstatic int fill_buffer(struct debug_buffer *buf)\n{\n\tint ret;\n\n\tif (!buf->output_buf)\n\t\tbuf->output_buf = vmalloc(buf->alloc_size);\n\n\tif (!buf->output_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tret = buf->fill_func(buf);\n\n\tif (ret >= 0) {\n\t\tbuf->count = ret;\n\t\tret = 0;\n\t}\n\nout:\n\treturn ret;\n}\n\nstatic ssize_t debug_output(struct file *file, char __user *user_buf,\n\t\tsize_t len, loff_t *offset)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\tint ret;\n\n\tmutex_lock(&buf->mutex);\n\tif (buf->count == 0) {\n\t\tret = fill_buffer(buf);\n\t\tif (ret != 0) {\n\t\t\tmutex_unlock(&buf->mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&buf->mutex);\n\n\tret = simple_read_from_buffer(user_buf, len, offset,\n\t\t\t\t      buf->output_buf, buf->count);\n\nout:\n\treturn ret;\n}\n\nstatic int debug_close(struct inode *inode, struct file *file)\n{\n\tstruct debug_buffer *buf = file->private_data;\n\n\tif (buf) {\n\t\tvfree(buf->output_buf);\n\t\tkfree(buf);\n\t}\n\n\treturn 0;\n}\n\nstatic int debug_async_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private, fill_async_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic int debug_bandwidth_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private,\n\t\t\tfill_bandwidth_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic int debug_periodic_open(struct inode *inode, struct file *file)\n{\n\tstruct debug_buffer *buf;\n\n\tbuf = alloc_buffer(inode->i_private, fill_periodic_buffer);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf->alloc_size = (sizeof(void *) == 4 ? 6 : 8) * PAGE_SIZE;\n\tfile->private_data = buf;\n\treturn 0;\n}\n\nstatic int debug_registers_open(struct inode *inode, struct file *file)\n{\n\tfile->private_data = alloc_buffer(inode->i_private,\n\t\t\t\t\t  fill_registers_buffer);\n\n\treturn file->private_data ? 0 : -ENOMEM;\n}\n\nstatic inline void create_debug_files(struct ehci_hcd *ehci)\n{\n\tstruct usb_bus *bus = &ehci_to_hcd(ehci)->self;\n\n\tehci->debug_dir = debugfs_create_dir(bus->bus_name, ehci_debug_root);\n\n\tdebugfs_create_file(\"async\", S_IRUGO, ehci->debug_dir, bus,\n\t\t\t    &debug_async_fops);\n\tdebugfs_create_file(\"bandwidth\", S_IRUGO, ehci->debug_dir, bus,\n\t\t\t    &debug_bandwidth_fops);\n\tdebugfs_create_file(\"periodic\", S_IRUGO, ehci->debug_dir, bus,\n\t\t\t    &debug_periodic_fops);\n\tdebugfs_create_file(\"registers\", S_IRUGO, ehci->debug_dir, bus,\n\t\t\t    &debug_registers_fops);\n}\n\nstatic inline void remove_debug_files(struct ehci_hcd *ehci)\n{\n\tdebugfs_remove_recursive(ehci->debug_dir);\n}\n\n#else  \n\nstatic inline void dbg_hcs_params(struct ehci_hcd *ehci, char *label) { }\nstatic inline void dbg_hcc_params(struct ehci_hcd *ehci, char *label) { }\n\nstatic inline void __maybe_unused dbg_qh(const char *label,\n\t\tstruct ehci_hcd *ehci, struct ehci_qh *qh) { }\n\nstatic inline int __maybe_unused dbg_status_buf(const char *buf,\n\t\tunsigned int len, const char *label, u32 status)\n{ return 0; }\n\nstatic inline int __maybe_unused dbg_command_buf(const char *buf,\n\t\tunsigned int len, const char *label, u32 command)\n{ return 0; }\n\nstatic inline int __maybe_unused dbg_intr_buf(const char *buf,\n\t\tunsigned int len, const char *label, u32 enable)\n{ return 0; }\n\nstatic inline int __maybe_unused dbg_port_buf(char *buf,\n\t\tunsigned int len, const char *label, int port, u32 status)\n{ return 0; }\n\nstatic inline void dbg_status(struct ehci_hcd *ehci, const char *label,\n\t\tu32 status) { }\nstatic inline void dbg_cmd(struct ehci_hcd *ehci, const char *label,\n\t\tu32 command) { }\nstatic inline void dbg_port(struct ehci_hcd *ehci, const char *label,\n\t\tint port, u32 status) { }\n\nstatic inline void create_debug_files(struct ehci_hcd *bus) { }\nstatic inline void remove_debug_files(struct ehci_hcd *bus) { }\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}