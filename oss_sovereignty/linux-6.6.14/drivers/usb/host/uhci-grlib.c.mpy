{
  "module_name": "uhci-grlib.c",
  "hash_id": "b6127e029d9f7fa218bcc40d1aec1bc27f8a9f65dc4b3d8a11f93538b7211f75",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-grlib.c",
  "human_readable_source": "\n \n\n#include <linux/device.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of_platform.h>\n\nstatic int uhci_grlib_init(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\n\t \n\tif (!(uhci_readw(uhci, USBPORTSC1) & 0x80)) {\n\t\tuhci->big_endian_mmio = 1;\n\t\tuhci->big_endian_desc = 1;\n\t}\n\n\tuhci->rh_numports = uhci_count_ports(hcd);\n\n\t \n\tuhci->reset_hc = uhci_generic_reset_hc;\n\tuhci->check_and_reset_hc = uhci_generic_check_and_reset_hc;\n\t \n\tuhci->configure_hc = NULL;\n\tuhci->resume_detect_interrupts_are_broken = NULL;\n\tuhci->global_suspend_mode_is_broken = NULL;\n\n\t \n\tcheck_and_reset_hc(uhci);\n\treturn 0;\n}\n\nstatic const struct hc_driver uhci_grlib_hc_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"GRLIB GRUSBHC UHCI Host Controller\",\n\t.hcd_priv_size =\tsizeof(struct uhci_hcd),\n\n\t \n\t.irq =\t\t\tuhci_irq,\n\t.flags =\t\tHCD_MEMORY | HCD_DMA | HCD_USB11,\n\n\t \n\t.reset =\t\tuhci_grlib_init,\n\t.start =\t\tuhci_start,\n#ifdef CONFIG_PM\n\t.pci_suspend =\t\tNULL,\n\t.pci_resume =\t\tNULL,\n\t.bus_suspend =\t\tuhci_rh_suspend,\n\t.bus_resume =\t\tuhci_rh_resume,\n#endif\n\t.stop =\t\t\tuhci_stop,\n\n\t.urb_enqueue =\t\tuhci_urb_enqueue,\n\t.urb_dequeue =\t\tuhci_urb_dequeue,\n\n\t.endpoint_disable =\tuhci_hcd_endpoint_disable,\n\t.get_frame_number =\tuhci_hcd_get_frame_number,\n\n\t.hub_status_data =\tuhci_hub_status_data,\n\t.hub_control =\t\tuhci_hub_control,\n};\n\n\nstatic int uhci_hcd_grlib_probe(struct platform_device *op)\n{\n\tstruct device_node *dn = op->dev.of_node;\n\tstruct usb_hcd *hcd;\n\tstruct uhci_hcd\t*uhci = NULL;\n\tstruct resource res;\n\tint irq;\n\tint rv;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tdev_dbg(&op->dev, \"initializing GRUSBHC UHCI USB Controller\\n\");\n\n\trv = of_address_to_resource(dn, 0, &res);\n\tif (rv)\n\t\treturn rv;\n\n\t \n\top->dev.dma_mask = &op->dev.coherent_dma_mask;\n\thcd = usb_create_hcd(&uhci_grlib_hc_driver, &op->dev,\n\t\t\t\"GRUSBHC UHCI USB\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = res.start;\n\thcd->rsrc_len = resource_size(&res);\n\n\tirq = irq_of_parse_and_map(dn, 0);\n\tif (!irq) {\n\t\tprintk(KERN_ERR \"%s: irq_of_parse_and_map failed\\n\", __FILE__);\n\t\trv = -EBUSY;\n\t\tgoto err_usb;\n\t}\n\n\thcd->regs = devm_ioremap_resource(&op->dev, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\trv = PTR_ERR(hcd->regs);\n\t\tgoto err_irq;\n\t}\n\n\tuhci = hcd_to_uhci(hcd);\n\n\tuhci->regs = hcd->regs;\n\n\trv = usb_add_hcd(hcd, irq, 0);\n\tif (rv)\n\t\tgoto err_irq;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\nerr_irq:\n\tirq_dispose_mapping(irq);\nerr_usb:\n\tusb_put_hcd(hcd);\n\n\treturn rv;\n}\n\nstatic void uhci_hcd_grlib_remove(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\n\tdev_dbg(&op->dev, \"stopping GRLIB GRUSBHC UHCI USB Controller\\n\");\n\n\tusb_remove_hcd(hcd);\n\n\tirq_dispose_mapping(hcd->irq);\n\tusb_put_hcd(hcd);\n}\n\n \nstatic void uhci_hcd_grlib_shutdown(struct platform_device *op)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(op);\n\n\tuhci_hc_died(hcd_to_uhci(hcd));\n}\n\nstatic const struct of_device_id uhci_hcd_grlib_of_match[] = {\n\t{ .name = \"GAISLER_UHCI\", },\n\t{ .name = \"01_027\", },\n\t{},\n};\nMODULE_DEVICE_TABLE(of, uhci_hcd_grlib_of_match);\n\n\nstatic struct platform_driver uhci_grlib_driver = {\n\t.probe\t\t= uhci_hcd_grlib_probe,\n\t.remove_new\t= uhci_hcd_grlib_remove,\n\t.shutdown\t= uhci_hcd_grlib_shutdown,\n\t.driver = {\n\t\t.name = \"grlib-uhci\",\n\t\t.of_match_table = uhci_hcd_grlib_of_match,\n\t},\n};\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}