{
  "module_name": "ohci-s3c2410.c",
  "hash_id": "f7fe0bd87369fe390591ac08740944a5e9fe8abfa8997738ac76b5d396c4c841",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-s3c2410.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/usb-ohci-s3c2410.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ohci.h\"\n\n\n#define valid_port(idx) ((idx) == 1 || (idx) == 2)\n\n \n\n\n#define DRIVER_DESC \"OHCI S3C2410 driver\"\n\nstatic struct clk *clk;\nstatic struct clk *usb_clk;\n\nstatic struct hc_driver __read_mostly ohci_s3c2410_hc_driver;\n\n \n\nstatic void s3c2410_hcd_oc(struct s3c2410_hcd_info *info, int port_oc);\n\n \n\nstatic struct s3c2410_hcd_info *to_s3c2410_info(struct usb_hcd *hcd)\n{\n\treturn dev_get_platdata(hcd->self.controller);\n}\n\nstatic void s3c2410_start_hc(struct platform_device *dev, struct usb_hcd *hcd)\n{\n\tstruct s3c2410_hcd_info *info = dev_get_platdata(&dev->dev);\n\n\tdev_dbg(&dev->dev, \"s3c2410_start_hc:\\n\");\n\n\tclk_prepare_enable(usb_clk);\n\tmdelay(2);\t\t\t \n\n\tclk_prepare_enable(clk);\n\n\tif (info != NULL) {\n\t\tinfo->hcd\t= hcd;\n\t\tinfo->report_oc = s3c2410_hcd_oc;\n\n\t\tif (info->enable_oc != NULL)\n\t\t\t(info->enable_oc)(info, 1);\n\t}\n}\n\nstatic void s3c2410_stop_hc(struct platform_device *dev)\n{\n\tstruct s3c2410_hcd_info *info = dev_get_platdata(&dev->dev);\n\n\tdev_dbg(&dev->dev, \"s3c2410_stop_hc:\\n\");\n\n\tif (info != NULL) {\n\t\tinfo->report_oc = NULL;\n\t\tinfo->hcd\t= NULL;\n\n\t\tif (info->enable_oc != NULL)\n\t\t\t(info->enable_oc)(info, 0);\n\t}\n\n\tclk_disable_unprepare(clk);\n\tclk_disable_unprepare(usb_clk);\n}\n\n \n\nstatic int\nohci_s3c2410_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct s3c2410_hcd_info *info = to_s3c2410_info(hcd);\n\tstruct s3c2410_hcd_port *port;\n\tint orig;\n\tint portno;\n\n\torig = ohci_hub_status_data(hcd, buf);\n\n\tif (info == NULL)\n\t\treturn orig;\n\n\tport = &info->port[0];\n\n\t \n\n\tfor (portno = 0; portno < 2; port++, portno++) {\n\t\tif (port->oc_changed == 1 &&\n\t\t    port->flags & S3C_HCDFLG_USED) {\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"oc change on port %d\\n\", portno);\n\n\t\t\tif (orig < 1)\n\t\t\t\torig = 1;\n\n\t\t\tbuf[0] |= 1<<(portno+1);\n\t\t}\n\t}\n\n\treturn orig;\n}\n\n \n\nstatic void s3c2410_usb_set_power(struct s3c2410_hcd_info *info,\n\t\t\t\t  int port, int to)\n{\n\tif (info == NULL)\n\t\treturn;\n\n\tif (info->power_control != NULL) {\n\t\tinfo->port[port-1].power = to;\n\t\t(info->power_control)(port-1, to);\n\t}\n}\n\n \n\nstatic int ohci_s3c2410_hub_control(\n\tstruct usb_hcd\t*hcd,\n\tu16\t\ttypeReq,\n\tu16\t\twValue,\n\tu16\t\twIndex,\n\tchar\t\t*buf,\n\tu16\t\twLength)\n{\n\tstruct s3c2410_hcd_info *info = to_s3c2410_info(hcd);\n\tstruct usb_hub_descriptor *desc;\n\tint ret = -EINVAL;\n\tu32 *data = (u32 *)buf;\n\n\tdev_dbg(hcd->self.controller,\n\t\t\"s3c2410_hub_control(%p,0x%04x,0x%04x,0x%04x,%p,%04x)\\n\",\n\t\thcd, typeReq, wValue, wIndex, buf, wLength);\n\n\t \n\n\tif (info == NULL) {\n\t\tret = ohci_hub_control(hcd, typeReq, wValue,\n\t\t\t\t       wIndex, buf, wLength);\n\t\tgoto out;\n\t}\n\n\t \n\n\tswitch (typeReq) {\n\tcase SetPortFeature:\n\t\tif (wValue == USB_PORT_FEAT_POWER) {\n\t\t\tdev_dbg(hcd->self.controller, \"SetPortFeat: POWER\\n\");\n\t\t\ts3c2410_usb_set_power(info, wIndex, 1);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\n\tcase ClearPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: C_OVER_CURRENT\\n\");\n\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tinfo->port[wIndex-1].oc_changed = 0;\n\t\t\t\tinfo->port[wIndex-1].oc_status = 0;\n\t\t\t}\n\n\t\t\tgoto out;\n\n\t\tcase USB_PORT_FEAT_OVER_CURRENT:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: OVER_CURRENT\\n\");\n\n\t\t\tif (valid_port(wIndex))\n\t\t\t\tinfo->port[wIndex-1].oc_status = 0;\n\n\t\t\tgoto out;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: POWER\\n\");\n\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\ts3c2410_usb_set_power(info, wIndex, 0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = ohci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (typeReq) {\n\tcase GetHubDescriptor:\n\n\t\t \n\n\t\tdesc = (struct usb_hub_descriptor *)buf;\n\n\t\tif (info->power_control == NULL)\n\t\t\treturn ret;\n\n\t\tdev_dbg(hcd->self.controller, \"wHubCharacteristics 0x%04x\\n\",\n\t\t\tdesc->wHubCharacteristics);\n\n\t\t \n\n\t\tdesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_LPSM);\n\t\tdesc->wHubCharacteristics |= cpu_to_le16(\n\t\t\tHUB_CHAR_INDV_PORT_LPSM);\n\n\t\tif (info->enable_oc) {\n\t\t\tdesc->wHubCharacteristics &= ~cpu_to_le16(\n\t\t\t\tHUB_CHAR_OCPM);\n\t\t\tdesc->wHubCharacteristics |=  cpu_to_le16(\n\t\t\t\tHUB_CHAR_INDV_PORT_OCPM);\n\t\t}\n\n\t\tdev_dbg(hcd->self.controller, \"wHubCharacteristics after 0x%04x\\n\",\n\t\t\tdesc->wHubCharacteristics);\n\n\t\treturn ret;\n\n\tcase GetPortStatus:\n\t\t \n\n\t\tdev_dbg(hcd->self.controller, \"GetPortStatus(%d)\\n\", wIndex);\n\n\t\tif (valid_port(wIndex)) {\n\t\t\tif (info->port[wIndex-1].oc_changed)\n\t\t\t\t*data |= cpu_to_le32(RH_PS_OCIC);\n\n\t\t\tif (info->port[wIndex-1].oc_status)\n\t\t\t\t*data |= cpu_to_le32(RH_PS_POCI);\n\t\t}\n\t}\n\n out:\n\treturn ret;\n}\n\n \n\nstatic void s3c2410_hcd_oc(struct s3c2410_hcd_info *info, int port_oc)\n{\n\tstruct s3c2410_hcd_port *port;\n\tunsigned long flags;\n\tint portno;\n\n\tif (info == NULL)\n\t\treturn;\n\n\tport = &info->port[0];\n\n\tlocal_irq_save(flags);\n\n\tfor (portno = 0; portno < 2; port++, portno++) {\n\t\tif (port_oc & (1<<portno) &&\n\t\t    port->flags & S3C_HCDFLG_USED) {\n\t\t\tport->oc_status = 1;\n\t\t\tport->oc_changed = 1;\n\n\t\t\t \n\t\t\ts3c2410_usb_set_power(info, portno+1, 0);\n\t\t}\n\t}\n\n\tlocal_irq_restore(flags);\n}\n\n \n \n\n \nstatic void\nohci_hcd_s3c2410_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\n\tusb_remove_hcd(hcd);\n\ts3c2410_stop_hc(dev);\n\tusb_put_hcd(hcd);\n}\n\n \nstatic int ohci_hcd_s3c2410_probe(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = NULL;\n\tstruct s3c2410_hcd_info *info = dev_get_platdata(&dev->dev);\n\tint retval, irq;\n\n\ts3c2410_usb_set_power(info, 1, 1);\n\ts3c2410_usb_set_power(info, 2, 1);\n\n\thcd = usb_create_hcd(&ohci_s3c2410_hc_driver, &dev->dev, \"s3c24xx\");\n\tif (hcd == NULL)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = dev->resource[0].start;\n\thcd->rsrc_len\t= resource_size(&dev->resource[0]);\n\n\thcd->regs = devm_ioremap_resource(&dev->dev, &dev->resource[0]);\n\tif (IS_ERR(hcd->regs)) {\n\t\tretval = PTR_ERR(hcd->regs);\n\t\tgoto err_put;\n\t}\n\n\tclk = devm_clk_get(&dev->dev, \"usb-host\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&dev->dev, \"cannot get usb-host clock\\n\");\n\t\tretval = PTR_ERR(clk);\n\t\tgoto err_put;\n\t}\n\n\tusb_clk = devm_clk_get(&dev->dev, \"usb-bus-host\");\n\tif (IS_ERR(usb_clk)) {\n\t\tdev_err(&dev->dev, \"cannot get usb-bus-host clock\\n\");\n\t\tretval = PTR_ERR(usb_clk);\n\t\tgoto err_put;\n\t}\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0) {\n\t\tretval = irq;\n\t\tgoto err_put;\n\t}\n\n\ts3c2410_start_hc(dev, hcd);\n\n\tretval = usb_add_hcd(hcd, irq, 0);\n\tif (retval != 0)\n\t\tgoto err_ioremap;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\n\n err_ioremap:\n\ts3c2410_stop_hc(dev);\n\n err_put:\n\tusb_put_hcd(hcd);\n\treturn retval;\n}\n\n \n\n#ifdef CONFIG_PM\nstatic int ohci_hcd_s3c2410_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint rc = 0;\n\n\trc = ohci_suspend(hcd, do_wakeup);\n\tif (rc)\n\t\treturn rc;\n\n\ts3c2410_stop_hc(pdev);\n\n\treturn rc;\n}\n\nstatic int ohci_hcd_s3c2410_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\ts3c2410_start_hc(pdev, hcd);\n\n\tohci_resume(hcd, false);\n\n\treturn 0;\n}\n#else\n#define ohci_hcd_s3c2410_drv_suspend\tNULL\n#define ohci_hcd_s3c2410_drv_resume\tNULL\n#endif\n\nstatic const struct dev_pm_ops ohci_hcd_s3c2410_pm_ops = {\n\t.suspend\t= ohci_hcd_s3c2410_drv_suspend,\n\t.resume\t\t= ohci_hcd_s3c2410_drv_resume,\n};\n\nstatic const struct of_device_id ohci_hcd_s3c2410_dt_ids[] = {\n\t{ .compatible = \"samsung,s3c2410-ohci\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, ohci_hcd_s3c2410_dt_ids);\n\nstatic struct platform_driver ohci_hcd_s3c2410_driver = {\n\t.probe\t\t= ohci_hcd_s3c2410_probe,\n\t.remove_new\t= ohci_hcd_s3c2410_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"s3c2410-ohci\",\n\t\t.pm\t= &ohci_hcd_s3c2410_pm_ops,\n\t\t.of_match_table\t= ohci_hcd_s3c2410_dt_ids,\n\t},\n};\n\nstatic int __init ohci_s3c2410_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_s3c2410_hc_driver, NULL);\n\n\t \n\n\tohci_s3c2410_hc_driver.hub_status_data\t= ohci_s3c2410_hub_status_data;\n\tohci_s3c2410_hc_driver.hub_control\t= ohci_s3c2410_hub_control;\n\n\treturn platform_driver_register(&ohci_hcd_s3c2410_driver);\n}\nmodule_init(ohci_s3c2410_init);\n\nstatic void __exit ohci_s3c2410_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_s3c2410_driver);\n}\nmodule_exit(ohci_s3c2410_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:s3c2410-ohci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}