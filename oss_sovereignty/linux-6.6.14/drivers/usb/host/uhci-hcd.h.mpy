{
  "module_name": "uhci-hcd.h",
  "hash_id": "498f45452cd57a70cfa8e718ee00dfe024ff04e9a0e106475bfd03fba290c337",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-hcd.h",
  "human_readable_source": " \n#ifndef __LINUX_UHCI_HCD_H\n#define __LINUX_UHCI_HCD_H\n\n#include <linux/list.h>\n#include <linux/usb.h>\n#include <linux/clk.h>\n\n#define usb_packetid(pipe)\t(usb_pipein(pipe) ? USB_PID_IN : USB_PID_OUT)\n#define PIPE_DEVEP_MASK\t\t0x0007ff00\n\n\n \n\n \n#define USBCMD\t\t0\n#define   USBCMD_RS\t\t0x0001\t \n#define   USBCMD_HCRESET\t0x0002\t \n#define   USBCMD_GRESET\t\t0x0004\t \n#define   USBCMD_EGSM\t\t0x0008\t \n#define   USBCMD_FGR\t\t0x0010\t \n#define   USBCMD_SWDBG\t\t0x0020\t \n#define   USBCMD_CF\t\t0x0040\t \n#define   USBCMD_MAXP\t\t0x0080\t \n\n \n#define USBSTS\t\t2\n#define   USBSTS_USBINT\t\t0x0001\t \n#define   USBSTS_ERROR\t\t0x0002\t \n#define   USBSTS_RD\t\t0x0004\t \n#define   USBSTS_HSE\t\t0x0008\t \n#define   USBSTS_HCPE\t\t0x0010\t \n#define   USBSTS_HCH\t\t0x0020\t \n\n \n#define USBINTR\t\t4\n#define   USBINTR_TIMEOUT\t0x0001\t \n#define   USBINTR_RESUME\t0x0002\t \n#define   USBINTR_IOC\t\t0x0004\t \n#define   USBINTR_SP\t\t0x0008\t \n\n#define USBFRNUM\t6\n#define USBFLBASEADD\t8\n#define USBSOF\t\t12\n#define   USBSOF_DEFAULT\t64\t \n\n \n#define USBPORTSC1\t16\n#define USBPORTSC2\t18\n#define USBPORTSC3\t20\n#define USBPORTSC4\t22\n#define   USBPORTSC_CCS\t\t0x0001\t \n#define   USBPORTSC_CSC\t\t0x0002\t \n#define   USBPORTSC_PE\t\t0x0004\t \n#define   USBPORTSC_PEC\t\t0x0008\t \n#define   USBPORTSC_DPLUS\t0x0010\t \n#define   USBPORTSC_DMINUS\t0x0020\t \n#define   USBPORTSC_RD\t\t0x0040\t \n#define   USBPORTSC_RES1\t0x0080\t \n#define   USBPORTSC_LSDA\t0x0100\t \n#define   USBPORTSC_PR\t\t0x0200\t \n \n#define   USBPORTSC_OC\t\t0x0400\t \n#define   USBPORTSC_OCC\t\t0x0800\t \n#define   USBPORTSC_SUSP\t0x1000\t \n#define   USBPORTSC_RES2\t0x2000\t \n#define   USBPORTSC_RES3\t0x4000\t \n#define   USBPORTSC_RES4\t0x8000\t \n\n \n#define USBLEGSUP\t\t0xc0\n#define   USBLEGSUP_DEFAULT\t0x2000\t \n#define   USBLEGSUP_RWC\t\t0x8f00\t \n#define   USBLEGSUP_RO\t\t0x5040\t \n\n \n#define USBRES_INTEL\t\t0xc4\n#define   USBPORT1EN\t\t0x01\n#define   USBPORT2EN\t\t0x02\n\n#define UHCI_PTR_BITS(uhci)\tcpu_to_hc32((uhci), 0x000F)\n#define UHCI_PTR_TERM(uhci)\tcpu_to_hc32((uhci), 0x0001)\n#define UHCI_PTR_QH(uhci)\tcpu_to_hc32((uhci), 0x0002)\n#define UHCI_PTR_DEPTH(uhci)\tcpu_to_hc32((uhci), 0x0004)\n#define UHCI_PTR_BREADTH(uhci)\tcpu_to_hc32((uhci), 0x0000)\n\n#define UHCI_NUMFRAMES\t\t1024\t \n#define UHCI_MAX_SOF_NUMBER\t2047\t \n#define CAN_SCHEDULE_FRAMES\t1000\t \n#define MAX_PHASE\t\t32\t \n\n \n#define FSBR_OFF_DELAY\t\tmsecs_to_jiffies(10)\n\n \n#define QH_WAIT_TIMEOUT\t\tmsecs_to_jiffies(200)\n\n\n \n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_DESC\ntypedef __u32 __bitwise __hc32;\ntypedef __u16 __bitwise __hc16;\n#else\n#define __hc32\t__le32\n#define __hc16\t__le16\n#endif\n\n \n\n \n#define QH_STATE_IDLE\t\t1\t \n#define QH_STATE_UNLINKING\t2\t \n#define QH_STATE_ACTIVE\t\t3\t \n\nstruct uhci_qh {\n\t \n\t__hc32 link;\t\t\t \n\t__hc32 element;\t\t\t \n\n\t \n\tdma_addr_t dma_handle;\n\n\tstruct list_head node;\t\t \n\tstruct usb_host_endpoint *hep;\t \n\tstruct usb_device *udev;\n\tstruct list_head queue;\t\t \n\tstruct uhci_td *dummy_td;\t \n\tstruct uhci_td *post_td;\t \n\n\tstruct usb_iso_packet_descriptor *iso_packet_desc;\n\t\t\t\t\t \n\tunsigned long advance_jiffies;\t \n\tunsigned int unlink_frame;\t \n\tunsigned int period;\t\t \n\tshort phase;\t\t\t \n\tshort load;\t\t\t \n\tunsigned int iso_frame;\t\t \n\n\tint state;\t\t\t \n\tint type;\t\t\t \n\tint skel;\t\t\t \n\n\tunsigned int initial_toggle:1;\t \n\tunsigned int needs_fixup:1;\t \n\tunsigned int is_stopped:1;\t \n\tunsigned int wait_expired:1;\t \n\tunsigned int bandwidth_reserved:1;\t \n} __attribute__((aligned(16)));\n\n \n#define qh_element(qh)\t\tREAD_ONCE((qh)->element)\n\n#define LINK_TO_QH(uhci, qh)\t(UHCI_PTR_QH((uhci)) | \\\n\t\t\t\tcpu_to_hc32((uhci), (qh)->dma_handle))\n\n\n \n\n \n#define TD_CTRL_SPD\t\t(1 << 29)\t \n#define TD_CTRL_C_ERR_MASK\t(3 << 27)\t \n#define TD_CTRL_C_ERR_SHIFT\t27\n#define TD_CTRL_LS\t\t(1 << 26)\t \n#define TD_CTRL_IOS\t\t(1 << 25)\t \n#define TD_CTRL_IOC\t\t(1 << 24)\t \n#define TD_CTRL_ACTIVE\t\t(1 << 23)\t \n#define TD_CTRL_STALLED\t\t(1 << 22)\t \n#define TD_CTRL_DBUFERR\t\t(1 << 21)\t \n#define TD_CTRL_BABBLE\t\t(1 << 20)\t \n#define TD_CTRL_NAK\t\t(1 << 19)\t \n#define TD_CTRL_CRCTIMEO\t(1 << 18)\t \n#define TD_CTRL_BITSTUFF\t(1 << 17)\t \n#define TD_CTRL_ACTLEN_MASK\t0x7FF\t \n\n#define uhci_maxerr(err)\t\t((err) << TD_CTRL_C_ERR_SHIFT)\n#define uhci_status_bits(ctrl_sts)\t((ctrl_sts) & 0xF60000)\n#define uhci_actual_length(ctrl_sts)\t(((ctrl_sts) + 1) & \\\n\t\t\tTD_CTRL_ACTLEN_MASK)\t \n\n \n#define td_token(uhci, td)\thc32_to_cpu((uhci), (td)->token)\n#define TD_TOKEN_DEVADDR_SHIFT\t8\n#define TD_TOKEN_TOGGLE_SHIFT\t19\n#define TD_TOKEN_TOGGLE\t\t(1 << 19)\n#define TD_TOKEN_EXPLEN_SHIFT\t21\n#define TD_TOKEN_EXPLEN_MASK\t0x7FF\t \n#define TD_TOKEN_PID_MASK\t0xFF\n\n#define uhci_explen(len)\t((((len) - 1) & TD_TOKEN_EXPLEN_MASK) << \\\n\t\t\t\t\tTD_TOKEN_EXPLEN_SHIFT)\n\n#define uhci_expected_length(token) ((((token) >> TD_TOKEN_EXPLEN_SHIFT) + \\\n\t\t\t\t\t1) & TD_TOKEN_EXPLEN_MASK)\n#define uhci_toggle(token)\t(((token) >> TD_TOKEN_TOGGLE_SHIFT) & 1)\n#define uhci_endpoint(token)\t(((token) >> 15) & 0xf)\n#define uhci_devaddr(token)\t(((token) >> TD_TOKEN_DEVADDR_SHIFT) & 0x7f)\n#define uhci_devep(token)\t(((token) >> TD_TOKEN_DEVADDR_SHIFT) & 0x7ff)\n#define uhci_packetid(token)\t((token) & TD_TOKEN_PID_MASK)\n#define uhci_packetout(token)\t(uhci_packetid(token) != USB_PID_IN)\n#define uhci_packetin(token)\t(uhci_packetid(token) == USB_PID_IN)\n\n \nstruct uhci_td {\n\t \n\t__hc32 link;\n\t__hc32 status;\n\t__hc32 token;\n\t__hc32 buffer;\n\n\t \n\tdma_addr_t dma_handle;\n\n\tstruct list_head list;\n\n\tint frame;\t\t\t \n\tstruct list_head fl_list;\n} __attribute__((aligned(16)));\n\n \n#define td_status(uhci, td)\t\thc32_to_cpu((uhci), \\\n\t\t\t\t\t\tREAD_ONCE((td)->status))\n\n#define LINK_TO_TD(uhci, td)\t\t(cpu_to_hc32((uhci), (td)->dma_handle))\n\n\n \n\n \n\n#define UHCI_NUM_SKELQH\t\t11\n#define SKEL_UNLINK\t\t0\n#define skel_unlink_qh\t\tskelqh[SKEL_UNLINK]\n#define SKEL_ISO\t\t1\n#define skel_iso_qh\t\tskelqh[SKEL_ISO]\n\t \n#define SKEL_INDEX(exponent)\t(9 - exponent)\n#define SKEL_ASYNC\t\t9\n#define skel_async_qh\t\tskelqh[SKEL_ASYNC]\n#define SKEL_TERM\t\t10\n#define skel_term_qh\t\tskelqh[SKEL_TERM]\n\n \n#define SKEL_LS_CONTROL\t\t20\n#define SKEL_FS_CONTROL\t\t21\n#define SKEL_FSBR\t\tSKEL_FS_CONTROL\n#define SKEL_BULK\t\t22\n\n \n\n \nenum uhci_rh_state {\n\t \n\tUHCI_RH_RESET,\n\tUHCI_RH_SUSPENDED,\n\n\tUHCI_RH_AUTO_STOPPED,\n\tUHCI_RH_RESUMING,\n\n\t \n\tUHCI_RH_SUSPENDING,\n\n\t \n\tUHCI_RH_RUNNING,\t\t \n\tUHCI_RH_RUNNING_NODEVS,\t\t \n};\n\n \nstruct uhci_hcd {\n\t \n\tunsigned long io_addr;\n\n\t \n\tvoid __iomem *regs;\n\n\tstruct dma_pool *qh_pool;\n\tstruct dma_pool *td_pool;\n\n\tstruct uhci_td *term_td;\t \n\tstruct uhci_qh *skelqh[UHCI_NUM_SKELQH];\t \n\tstruct uhci_qh *next_qh;\t \n\n\tspinlock_t lock;\n\n\tdma_addr_t frame_dma_handle;\t \n\t__hc32 *frame;\n\tvoid **frame_cpu;\t\t \n\n\tenum uhci_rh_state rh_state;\n\tunsigned long auto_stop_time;\t\t \n\n\tunsigned int frame_number;\t\t \n\tunsigned int is_stopped;\n#define UHCI_IS_STOPPED\t\t9999\t\t \n\tunsigned int last_iso_frame;\t\t \n\tunsigned int cur_iso_frame;\t\t \n\n\tunsigned int scan_in_progress:1;\t \n\tunsigned int need_rescan:1;\t\t \n\tunsigned int dead:1;\t\t\t \n\tunsigned int RD_enable:1;\t\t \n\tunsigned int is_initialized:1;\t\t \n\tunsigned int fsbr_is_on:1;\t\t \n\tunsigned int fsbr_is_wanted:1;\t\t \n\tunsigned int fsbr_expiring:1;\t\t \n\n\tstruct timer_list fsbr_timer;\t\t \n\n\t \n\tunsigned int oc_low:1;\t\t\t \n\tunsigned int wait_for_hp:1;\t\t \n\tunsigned int big_endian_mmio:1;\t\t \n\tunsigned int big_endian_desc:1;\t\t \n\tunsigned int is_aspeed:1;\t\t \n\n\t \n\tunsigned long port_c_suspend;\t\t \n\tunsigned long resuming_ports;\n\tunsigned long ports_timeout;\t\t \n\n\tstruct list_head idle_qh_list;\t\t \n\n\tint rh_numports;\t\t\t \n\n\twait_queue_head_t waitqh;\t\t \n\tint num_waiting;\t\t\t \n\n\tint total_load;\t\t\t\t \n\tshort load[MAX_PHASE];\t\t\t \n\n\tstruct clk *clk;\t\t\t \n\n\t \n\tvoid\t(*reset_hc) (struct uhci_hcd *uhci);\n\tint\t(*check_and_reset_hc) (struct uhci_hcd *uhci);\n\t \n\tvoid\t(*configure_hc) (struct uhci_hcd *uhci);\n\t \n\tint\t(*resume_detect_interrupts_are_broken) (struct uhci_hcd *uhci);\n\t \n\tint\t(*global_suspend_mode_is_broken) (struct uhci_hcd *uhci);\n};\n\n \nstatic inline struct uhci_hcd *hcd_to_uhci(struct usb_hcd *hcd)\n{\n\treturn (struct uhci_hcd *) (hcd->hcd_priv);\n}\nstatic inline struct usb_hcd *uhci_to_hcd(struct uhci_hcd *uhci)\n{\n\treturn container_of((void *) uhci, struct usb_hcd, hcd_priv);\n}\n\n#define uhci_dev(u)\t(uhci_to_hcd(u)->self.controller)\n\n \n#define uhci_frame_before_eq(f1, f2)\t(0 <= (int) ((f2) - (f1)))\n\n\n \nstruct urb_priv {\n\tstruct list_head node;\t\t \n\n\tstruct urb *urb;\n\n\tstruct uhci_qh *qh;\t\t \n\tstruct list_head td_list;\n\n\tunsigned fsbr:1;\t\t \n};\n\n\n \n\n#define PCI_VENDOR_ID_GENESYS\t\t0x17a0\n#define PCI_DEVICE_ID_GL880S_UHCI\t0x8083\n\n \nstatic inline bool uhci_is_aspeed(const struct uhci_hcd *uhci)\n{\n\treturn IS_ENABLED(CONFIG_USB_UHCI_ASPEED) && uhci->is_aspeed;\n}\n\n \n\n#ifdef CONFIG_HAS_IOPORT\n#define UHCI_IN(x)\tx\n#define UHCI_OUT(x)\tx\n#else\n#define UHCI_IN(x)\t0\n#define UHCI_OUT(x)\tdo { } while (0)\n#endif\n\n#ifndef CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC\n \nstatic inline u32 uhci_readl(const struct uhci_hcd *uhci, int reg)\n{\n\treturn inl(uhci->io_addr + reg);\n}\n\nstatic inline void uhci_writel(const struct uhci_hcd *uhci, u32 val, int reg)\n{\n\toutl(val, uhci->io_addr + reg);\n}\n\nstatic inline u16 uhci_readw(const struct uhci_hcd *uhci, int reg)\n{\n\treturn inw(uhci->io_addr + reg);\n}\n\nstatic inline void uhci_writew(const struct uhci_hcd *uhci, u16 val, int reg)\n{\n\toutw(val, uhci->io_addr + reg);\n}\n\nstatic inline u8 uhci_readb(const struct uhci_hcd *uhci, int reg)\n{\n\treturn inb(uhci->io_addr + reg);\n}\n\nstatic inline void uhci_writeb(const struct uhci_hcd *uhci, u8 val, int reg)\n{\n\toutb(val, uhci->io_addr + reg);\n}\n\n#else\n \n#if defined(CONFIG_USB_PCI) && defined(HAS_IOPORT)\n \n#define uhci_has_pci_registers(u)\t((u)->io_addr != 0)\n#else\n \n#define uhci_has_pci_registers(u)\t0\n#endif\n\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n \n#define uhci_big_endian_mmio(u)\t\t((u)->big_endian_mmio)\n#else\n#define uhci_big_endian_mmio(u)\t\t0\n#endif\n\nstatic inline int uhci_aspeed_reg(unsigned int reg)\n{\n\tswitch (reg) {\n\tcase USBCMD:\n\t\treturn 00;\n\tcase USBSTS:\n\t\treturn 0x04;\n\tcase USBINTR:\n\t\treturn 0x08;\n\tcase USBFRNUM:\n\t\treturn 0x80;\n\tcase USBFLBASEADD:\n\t\treturn 0x0c;\n\tcase USBSOF:\n\t\treturn 0x84;\n\tcase USBPORTSC1:\n\t\treturn 0x88;\n\tcase USBPORTSC2:\n\t\treturn 0x8c;\n\tcase USBPORTSC3:\n\t\treturn 0x90;\n\tcase USBPORTSC4:\n\t\treturn 0x94;\n\tdefault:\n\t\tpr_warn(\"UHCI: Unsupported register 0x%02x on Aspeed\\n\", reg);\n\t\t \n\t\treturn 0x10;\n\t}\n}\n\nstatic inline u32 uhci_readl(const struct uhci_hcd *uhci, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\treturn UHCI_IN(inl(uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\treturn readl(uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\treturn readl_be(uhci->regs + reg);\n#endif\n\telse\n\t\treturn readl(uhci->regs + reg);\n}\n\nstatic inline void uhci_writel(const struct uhci_hcd *uhci, u32 val, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\tUHCI_OUT(outl(val, uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\twritel(val, uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\twritel_be(val, uhci->regs + reg);\n#endif\n\telse\n\t\twritel(val, uhci->regs + reg);\n}\n\nstatic inline u16 uhci_readw(const struct uhci_hcd *uhci, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\treturn UHCI_IN(inw(uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\treturn readl(uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\treturn readw_be(uhci->regs + reg);\n#endif\n\telse\n\t\treturn readw(uhci->regs + reg);\n}\n\nstatic inline void uhci_writew(const struct uhci_hcd *uhci, u16 val, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\tUHCI_OUT(outw(val, uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\twritel(val, uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\twritew_be(val, uhci->regs + reg);\n#endif\n\telse\n\t\twritew(val, uhci->regs + reg);\n}\n\nstatic inline u8 uhci_readb(const struct uhci_hcd *uhci, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\treturn UHCI_IN(inb(uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\treturn readl(uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\treturn readb_be(uhci->regs + reg);\n#endif\n\telse\n\t\treturn readb(uhci->regs + reg);\n}\n\nstatic inline void uhci_writeb(const struct uhci_hcd *uhci, u8 val, int reg)\n{\n\tif (uhci_has_pci_registers(uhci))\n\t\tUHCI_OUT(outb(val, uhci->io_addr + reg));\n\telse if (uhci_is_aspeed(uhci))\n\t\twritel(val, uhci->regs + uhci_aspeed_reg(reg));\n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_MMIO\n\telse if (uhci_big_endian_mmio(uhci))\n\t\twriteb_be(val, uhci->regs + reg);\n#endif\n\telse\n\t\twriteb(val, uhci->regs + reg);\n}\n#endif  \n#undef UHCI_IN\n#undef UHCI_OUT\n\n \n#ifdef CONFIG_USB_UHCI_BIG_ENDIAN_DESC\n#define uhci_big_endian_desc(u)\t\t((u)->big_endian_desc)\n\n \nstatic inline __hc32 cpu_to_hc32(const struct uhci_hcd *uhci, const u32 x)\n{\n\treturn uhci_big_endian_desc(uhci)\n\t\t? (__force __hc32)cpu_to_be32(x)\n\t\t: (__force __hc32)cpu_to_le32(x);\n}\n\n \nstatic inline u32 hc32_to_cpu(const struct uhci_hcd *uhci, const __hc32 x)\n{\n\treturn uhci_big_endian_desc(uhci)\n\t\t? be32_to_cpu((__force __be32)x)\n\t\t: le32_to_cpu((__force __le32)x);\n}\n\n#else\n \nstatic inline __hc32 cpu_to_hc32(const struct uhci_hcd *uhci, const u32 x)\n{\n\treturn cpu_to_le32(x);\n}\n\n \nstatic inline u32 hc32_to_cpu(const struct uhci_hcd *uhci, const __hc32 x)\n{\n\treturn le32_to_cpu(x);\n}\n#endif\n\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}