{
  "module_name": "ehci-sh.c",
  "hash_id": "ef6c381235f4e152111884336a56246958a35a8df5cfd56576b1431f12f2a310",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-sh.c",
  "human_readable_source": "\n \n#include <linux/platform_device.h>\n#include <linux/clk.h>\n\nstruct ehci_sh_priv {\n\tstruct clk *iclk, *fclk;\n\tstruct usb_hcd *hcd;\n};\n\nstatic int ehci_sh_reset(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t*ehci = hcd_to_ehci(hcd);\n\n\tehci->caps = hcd->regs;\n\n\treturn ehci_setup(hcd);\n}\n\nstatic const struct hc_driver ehci_sh_hc_driver = {\n\t.description\t\t\t= hcd_name,\n\t.product_desc\t\t\t= \"SuperH EHCI\",\n\t.hcd_priv_size\t\t\t= sizeof(struct ehci_hcd),\n\n\t \n\t.irq\t\t\t\t= ehci_irq,\n\t.flags\t\t\t\t= HCD_USB2 | HCD_DMA | HCD_MEMORY | HCD_BH,\n\n\t \n\t.reset\t\t\t\t= ehci_sh_reset,\n\t.start\t\t\t\t= ehci_run,\n\t.stop\t\t\t\t= ehci_stop,\n\t.shutdown\t\t\t= ehci_shutdown,\n\n\t \n\t.urb_enqueue\t\t\t= ehci_urb_enqueue,\n\t.urb_dequeue\t\t\t= ehci_urb_dequeue,\n\t.endpoint_disable\t\t= ehci_endpoint_disable,\n\t.endpoint_reset\t\t\t= ehci_endpoint_reset,\n\n\t \n\t.get_frame_number\t\t= ehci_get_frame,\n\n\t \n\t.hub_status_data\t\t= ehci_hub_status_data,\n\t.hub_control\t\t\t= ehci_hub_control,\n\n#ifdef CONFIG_PM\n\t.bus_suspend\t\t\t= ehci_bus_suspend,\n\t.bus_resume\t\t\t= ehci_bus_resume,\n#endif\n\n\t.relinquish_port\t\t= ehci_relinquish_port,\n\t.port_handed_over\t\t= ehci_port_handed_over,\n\t.clear_tt_buffer_complete\t= ehci_clear_tt_buffer_complete,\n};\n\nstatic int ehci_hcd_sh_probe(struct platform_device *pdev)\n{\n\tstruct resource *res;\n\tstruct ehci_sh_priv *priv;\n\tstruct usb_hcd *hcd;\n\tint irq, ret;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tret = irq;\n\t\tgoto fail_create_hcd;\n\t}\n\n\t \n\thcd = usb_create_hcd(&ehci_sh_hc_driver, &pdev->dev,\n\t\t\t     dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_create_hcd;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tret = PTR_ERR(hcd->regs);\n\t\tgoto fail_request_resource;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tpriv = devm_kzalloc(&pdev->dev, sizeof(struct ehci_sh_priv),\n\t\t\t    GFP_KERNEL);\n\tif (!priv) {\n\t\tret = -ENOMEM;\n\t\tgoto fail_request_resource;\n\t}\n\n\t \n\tpriv->fclk = devm_clk_get(&pdev->dev, \"usb_fck\");\n\tif (IS_ERR(priv->fclk))\n\t\tpriv->fclk = NULL;\n\n\tpriv->iclk = devm_clk_get(&pdev->dev, \"usb_ick\");\n\tif (IS_ERR(priv->iclk))\n\t\tpriv->iclk = NULL;\n\n\tclk_enable(priv->fclk);\n\tclk_enable(priv->iclk);\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret != 0) {\n\t\tdev_err(&pdev->dev, \"Failed to add hcd\");\n\t\tgoto fail_add_hcd;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tpriv->hcd = hcd;\n\tplatform_set_drvdata(pdev, priv);\n\n\treturn ret;\n\nfail_add_hcd:\n\tclk_disable(priv->iclk);\n\tclk_disable(priv->fclk);\n\nfail_request_resource:\n\tusb_put_hcd(hcd);\nfail_create_hcd:\n\tdev_err(&pdev->dev, \"init %s fail, %d\\n\", dev_name(&pdev->dev), ret);\n\n\treturn ret;\n}\n\nstatic void ehci_hcd_sh_remove(struct platform_device *pdev)\n{\n\tstruct ehci_sh_priv *priv = platform_get_drvdata(pdev);\n\tstruct usb_hcd *hcd = priv->hcd;\n\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n\n\tclk_disable(priv->fclk);\n\tclk_disable(priv->iclk);\n}\n\nstatic void ehci_hcd_sh_shutdown(struct platform_device *pdev)\n{\n\tstruct ehci_sh_priv *priv = platform_get_drvdata(pdev);\n\tstruct usb_hcd *hcd = priv->hcd;\n\n\tif (hcd->driver->shutdown)\n\t\thcd->driver->shutdown(hcd);\n}\n\nstatic struct platform_driver ehci_hcd_sh_driver = {\n\t.probe\t\t= ehci_hcd_sh_probe,\n\t.remove_new\t= ehci_hcd_sh_remove,\n\t.shutdown\t= ehci_hcd_sh_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"sh_ehci\",\n\t},\n};\n\nMODULE_ALIAS(\"platform:sh_ehci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}