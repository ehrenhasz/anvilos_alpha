{
  "module_name": "xhci-pci-renesas.c",
  "hash_id": "4173fa9adfb7d15717f76cf1d2bc2e58c29cf6e13438afb147e218c1dfe32699",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-pci-renesas.c",
  "human_readable_source": "\n \n\n#include <linux/acpi.h>\n#include <linux/firmware.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/slab.h>\n#include <asm/unaligned.h>\n\n#include \"xhci.h\"\n#include \"xhci-trace.h\"\n#include \"xhci-pci.h\"\n\n#define RENESAS_FW_VERSION\t\t\t\t0x6C\n#define RENESAS_ROM_CONFIG\t\t\t\t0xF0\n#define RENESAS_FW_STATUS\t\t\t\t0xF4\n#define RENESAS_FW_STATUS_MSB\t\t\t\t0xF5\n#define RENESAS_ROM_STATUS\t\t\t\t0xF6\n#define RENESAS_ROM_STATUS_MSB\t\t\t\t0xF7\n#define RENESAS_DATA0\t\t\t\t\t0xF8\n#define RENESAS_DATA1\t\t\t\t\t0xFC\n\n#define RENESAS_FW_VERSION_FIELD\t\t\tGENMASK(23, 7)\n#define RENESAS_FW_VERSION_OFFSET\t\t\t8\n\n#define RENESAS_FW_STATUS_DOWNLOAD_ENABLE\t\tBIT(0)\n#define RENESAS_FW_STATUS_LOCK\t\t\t\tBIT(1)\n#define RENESAS_FW_STATUS_RESULT\t\t\tGENMASK(6, 4)\n  #define RENESAS_FW_STATUS_INVALID\t\t\t0\n  #define RENESAS_FW_STATUS_SUCCESS\t\t\tBIT(4)\n  #define RENESAS_FW_STATUS_ERROR\t\t\tBIT(5)\n#define RENESAS_FW_STATUS_SET_DATA0\t\t\tBIT(8)\n#define RENESAS_FW_STATUS_SET_DATA1\t\t\tBIT(9)\n\n#define RENESAS_ROM_STATUS_ACCESS\t\t\tBIT(0)\n#define RENESAS_ROM_STATUS_ERASE\t\t\tBIT(1)\n#define RENESAS_ROM_STATUS_RELOAD\t\t\tBIT(2)\n#define RENESAS_ROM_STATUS_RESULT\t\t\tGENMASK(6, 4)\n  #define RENESAS_ROM_STATUS_NO_RESULT\t\t\t0\n  #define RENESAS_ROM_STATUS_SUCCESS\t\t\tBIT(4)\n  #define RENESAS_ROM_STATUS_ERROR\t\t\tBIT(5)\n#define RENESAS_ROM_STATUS_SET_DATA0\t\t\tBIT(8)\n#define RENESAS_ROM_STATUS_SET_DATA1\t\t\tBIT(9)\n#define RENESAS_ROM_STATUS_ROM_EXISTS\t\t\tBIT(15)\n\n#define RENESAS_ROM_ERASE_MAGIC\t\t\t\t0x5A65726F\n#define RENESAS_ROM_WRITE_MAGIC\t\t\t\t0x53524F4D\n\n#define RENESAS_RETRY\t10000\n#define RENESAS_DELAY\t10\n\nstatic int renesas_fw_download_image(struct pci_dev *dev,\n\t\t\t\t     const u32 *fw, size_t step, bool rom)\n{\n\tsize_t i;\n\tint err;\n\tu8 fw_status;\n\tbool data0_or_data1;\n\tu32 status_reg;\n\n\tif (rom)\n\t\tstatus_reg = RENESAS_ROM_STATUS_MSB;\n\telse\n\t\tstatus_reg = RENESAS_FW_STATUS_MSB;\n\n\t \n\tdata0_or_data1 = (step & 1) == 1;\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(dev, status_reg, &fw_status);\n\t\tif (err) {\n\t\t\tdev_err(&dev->dev, \"Read Status failed: %d\\n\",\n\t\t\t\tpcibios_err_to_errno(err));\n\t\t\treturn pcibios_err_to_errno(err);\n\t\t}\n\t\tif (!(fw_status & BIT(data0_or_data1)))\n\t\t\tbreak;\n\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY) {\n\t\tdev_err(&dev->dev, \"Timeout for Set DATAX step: %zd\\n\", step);\n\t\treturn -ETIMEDOUT;\n\t}\n\n\t \n\terr = pci_write_config_dword(dev, data0_or_data1 ?\n\t\t\t\t     RENESAS_DATA1 : RENESAS_DATA0,\n\t\t\t\t     (__force u32)cpu_to_le32(fw[step]));\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Write to DATAX failed: %d\\n\",\n\t\t\tpcibios_err_to_errno(err));\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\tudelay(100);\n\n\t \n\terr = pci_write_config_byte(dev, status_reg, BIT(data0_or_data1));\n\tif (err) {\n\t\tdev_err(&dev->dev, \"Write config for DATAX failed: %d\\n\",\n\t\t\tpcibios_err_to_errno(err));\n\t\treturn pcibios_err_to_errno(err);\n\t}\n\n\treturn 0;\n}\n\nstatic int renesas_fw_verify(const void *fw_data,\n\t\t\t     size_t length)\n{\n\tu16 fw_version_pointer;\n\n\t \n\n\t \n\tif (length < 0x1000 || length >= 0x10000) {\n\t\tpr_err(\"firmware is size %zd is not (4k - 64k).\",\n\t\t\tlength);\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tif (get_unaligned_le16(fw_data) != 0x55aa) {\n\t\tpr_err(\"no valid firmware header found.\");\n\t\treturn -EINVAL;\n\t}\n\n\t \n\tfw_version_pointer = get_unaligned_le16(fw_data + 4);\n\tif (fw_version_pointer + 2 >= length) {\n\t\tpr_err(\"fw ver pointer is outside of the firmware image\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic bool renesas_check_rom(struct pci_dev *pdev)\n{\n\tu16 rom_status;\n\tint retval;\n\n\t \n\tretval = pci_read_config_word(pdev, RENESAS_ROM_STATUS, &rom_status);\n\tif (retval)\n\t\treturn false;\n\n\trom_status &= RENESAS_ROM_STATUS_ROM_EXISTS;\n\tif (rom_status) {\n\t\tdev_dbg(&pdev->dev, \"External ROM exists\\n\");\n\t\treturn true;  \n\t}\n\n\treturn false;\n}\n\nstatic int renesas_check_rom_state(struct pci_dev *pdev)\n{\n\tu16 rom_state;\n\tu32 version;\n\tint err;\n\n\t \n\terr = pci_read_config_dword(pdev, RENESAS_FW_VERSION, &version);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\tversion &= RENESAS_FW_VERSION_FIELD;\n\tversion = version >> RENESAS_FW_VERSION_OFFSET;\n\tdev_dbg(&pdev->dev, \"Found ROM version: %x\\n\", version);\n\n\t \n\terr = pci_read_config_word(pdev, RENESAS_ROM_STATUS, &rom_state);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\tif (rom_state & RENESAS_ROM_STATUS_ROM_EXISTS) {\n\t\t \n\t\tdev_dbg(&pdev->dev, \"ROM exists\\n\");\n\n\t\t \n\t\tswitch (rom_state & RENESAS_ROM_STATUS_RESULT) {\n\t\tcase RENESAS_ROM_STATUS_SUCCESS:\n\t\t\treturn 0;\n\n\t\tcase RENESAS_ROM_STATUS_NO_RESULT:  \n\t\t\tdev_dbg(&pdev->dev, \"Unknown ROM status ...\\n\");\n\t\t\treturn -ENOENT;\n\n\t\tcase RENESAS_ROM_STATUS_ERROR:  \n\t\tdefault:  \n\t\t\tdev_err(&pdev->dev, \"Invalid ROM..\");\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn -EIO;\n}\n\nstatic int renesas_fw_check_running(struct pci_dev *pdev)\n{\n\tu8 fw_state;\n\tint err;\n\n\t \n\terr = pci_read_config_byte(pdev, RENESAS_FW_STATUS, &fw_state);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\t \n\tif (fw_state & RENESAS_FW_STATUS_LOCK) {\n\t\tdev_dbg(&pdev->dev, \"FW Download Lock is engaged.\");\n\n\t\tif (fw_state & RENESAS_FW_STATUS_SUCCESS)\n\t\t\treturn 0;\n\n\t\tdev_err(&pdev->dev,\n\t\t\t\"FW Download Lock is set and FW is not ready. Giving Up.\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tif (fw_state & RENESAS_FW_STATUS_DOWNLOAD_ENABLE) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"FW Download Enable is stale. Giving Up (poweroff/reboot needed).\");\n\t\treturn -EIO;\n\t}\n\n\t \n\tswitch (fw_state & RENESAS_FW_STATUS_RESULT) {\n\tcase 0:  \n\t\tdev_dbg(&pdev->dev, \"FW is not ready/loaded yet.\");\n\n\t\t \n\t\treturn 1;\n\n\tcase RENESAS_FW_STATUS_SUCCESS:  \n\t\tdev_dbg(&pdev->dev, \"FW is ready.\");\n\t\treturn 0;\n\n\tcase RENESAS_FW_STATUS_ERROR:  \n\t\tdev_err(&pdev->dev,\n\t\t\t\"hardware is in an error state. Giving up (poweroff/reboot needed).\");\n\t\treturn -ENODEV;\n\n\tdefault:  \n\t\tdev_err(&pdev->dev,\n\t\t\t\"hardware is in an invalid state %lx. Giving up (poweroff/reboot needed).\",\n\t\t\t(fw_state & RENESAS_FW_STATUS_RESULT) >> 4);\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int renesas_fw_download(struct pci_dev *pdev,\n\t\t\t       const struct firmware *fw)\n{\n\tconst u32 *fw_data = (const u32 *)fw->data;\n\tsize_t i;\n\tint err;\n\tu8 fw_status;\n\n\t \n\n\t \n\terr = pci_write_config_byte(pdev, RENESAS_FW_STATUS,\n\t\t\t\t    RENESAS_FW_STATUS_DOWNLOAD_ENABLE);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\t \n\tfor (i = 0; i < fw->size / 4; i++) {\n\t\terr = renesas_fw_download_image(pdev, fw_data, i, false);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Firmware Download Step %zd failed at position %zd bytes with (%d).\",\n\t\t\t\ti, i * 4, err);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(pdev, RENESAS_FW_STATUS_MSB,\n\t\t\t\t\t   &fw_status);\n\t\tif (err)\n\t\t\treturn pcibios_err_to_errno(err);\n\t\tif (!(fw_status & (BIT(0) | BIT(1))))\n\t\t\tbreak;\n\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY)\n\t\tdev_warn(&pdev->dev, \"Final Firmware Download step timed out.\");\n\n\t \n\terr = pci_write_config_byte(pdev, RENESAS_FW_STATUS, 0);\n\tif (err)\n\t\treturn pcibios_err_to_errno(err);\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(pdev, RENESAS_FW_STATUS, &fw_status);\n\t\tif (err)\n\t\t\treturn pcibios_err_to_errno(err);\n\t\tif (fw_status & RENESAS_FW_STATUS_SUCCESS)\n\t\t\tbreak;\n\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY) {\n\t\t \n\t\terr = renesas_fw_check_running(pdev);\n\t\tswitch (err) {\n\t\tcase 0:  \n\t\t\tbreak;\n\n\t\tcase 1:  \n\t\t\tdev_err(&pdev->dev, \"FW Load timedout\");\n\t\t\treturn -ETIMEDOUT;\n\n\t\tdefault:\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void renesas_rom_erase(struct pci_dev *pdev)\n{\n\tint retval, i;\n\tu8 status;\n\n\tdev_dbg(&pdev->dev, \"Performing ROM Erase...\\n\");\n\tretval = pci_write_config_dword(pdev, RENESAS_DATA0,\n\t\t\t\t\tRENESAS_ROM_ERASE_MAGIC);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"ROM erase, magic word write failed: %d\\n\",\n\t\t\tpcibios_err_to_errno(retval));\n\t\treturn;\n\t}\n\n\tretval = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"ROM status read failed: %d\\n\",\n\t\t\tpcibios_err_to_errno(retval));\n\t\treturn;\n\t}\n\tstatus |= RENESAS_ROM_STATUS_ERASE;\n\tretval = pci_write_config_byte(pdev, RENESAS_ROM_STATUS, status);\n\tif (retval) {\n\t\tdev_err(&pdev->dev, \"ROM erase set word write failed\\n\");\n\t\treturn;\n\t}\n\n\t \n\tmsleep(20);\n\n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\tretval = pci_read_config_byte(pdev, RENESAS_ROM_STATUS,\n\t\t\t\t\t      &status);\n\t\tstatus &= RENESAS_ROM_STATUS_ERASE;\n\t\tif (!status)\n\t\t\tbreak;\n\n\t\tmdelay(RENESAS_DELAY);\n\t}\n\n\tif (i == RENESAS_RETRY)\n\t\tdev_dbg(&pdev->dev, \"Chip erase timedout: %x\\n\", status);\n\n\tdev_dbg(&pdev->dev, \"ROM Erase... Done success\\n\");\n}\n\nstatic bool renesas_setup_rom(struct pci_dev *pdev, const struct firmware *fw)\n{\n\tconst u32 *fw_data = (const u32 *)fw->data;\n\tint err, i;\n\tu8 status;\n\n\t \n\terr = pci_write_config_dword(pdev, RENESAS_DATA0,\n\t\t\t\t     RENESAS_ROM_WRITE_MAGIC);\n\tif (err)\n\t\treturn false;\n\n\t \n\terr = pci_write_config_byte(pdev, RENESAS_ROM_STATUS,\n\t\t\t\t    RENESAS_ROM_STATUS_ACCESS);\n\tif (err)\n\t\tgoto remove_bypass;\n\n\t \n\terr = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);\n\tif (err)\n\t\tgoto remove_bypass;\n\tstatus &= GENMASK(6, 4);\n\tif (status) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"setting external rom failed: %x\\n\", status);\n\t\tgoto remove_bypass;\n\t}\n\n\t \n\tfor (i = 0; i < fw->size / 4; i++) {\n\t\terr = renesas_fw_download_image(pdev, fw_data, i, true);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"ROM Download Step %d failed at position %d bytes with (%d)\\n\",\n\t\t\t\t i, i * 4, err);\n\t\t\tgoto remove_bypass;\n\t\t}\n\t}\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(pdev, RENESAS_ROM_STATUS_MSB,\n\t\t\t\t\t   &status);\n\t\tif (err)\n\t\t\tgoto remove_bypass;\n\t\tif (!(status & (BIT(0) | BIT(1))))\n\t\t\tbreak;\n\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY) {\n\t\tdev_err(&pdev->dev, \"Final Firmware ROM Download step timed out\\n\");\n\t\tgoto remove_bypass;\n\t}\n\n\t \n\terr = pci_write_config_byte(pdev, RENESAS_ROM_STATUS, 0);\n\tif (err)\n\t\treturn false;\n\n\tudelay(10);\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);\n\t\tif (err) {\n\t\t\tdev_err(&pdev->dev, \"Read ROM status failed:%d\\n\",\n\t\t\t\tpcibios_err_to_errno(err));\n\t\t\treturn false;\n\t\t}\n\t\tstatus &= RENESAS_ROM_STATUS_RESULT;\n\t\tif (status ==  RENESAS_ROM_STATUS_SUCCESS) {\n\t\t\tdev_dbg(&pdev->dev, \"Download ROM success\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY) {  \n\t\tdev_err(&pdev->dev,\n\t\t\t\"Download to external ROM TO: %x\\n\", status);\n\t\treturn false;\n\t}\n\n\tdev_dbg(&pdev->dev, \"Download to external ROM succeeded\\n\");\n\n\t \n\terr = pci_write_config_byte(pdev, RENESAS_ROM_STATUS,\n\t\t\t\t    RENESAS_ROM_STATUS_RELOAD);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"Set ROM execute failed: %d\\n\",\n\t\t\tpcibios_err_to_errno(err));\n\t\treturn false;\n\t}\n\n\t \n\tfor (i = 0; i < RENESAS_RETRY; i++) {\n\t\terr = pci_read_config_byte(pdev, RENESAS_ROM_STATUS, &status);\n\t\tif (err)\n\t\t\treturn false;\n\t\tif (!(status & RENESAS_ROM_STATUS_RELOAD))\n\t\t\tbreak;\n\n\t\tudelay(RENESAS_DELAY);\n\t}\n\tif (i == RENESAS_RETRY) {\n\t\tdev_err(&pdev->dev, \"ROM Exec timed out: %x\\n\", status);\n\t\treturn false;\n\t}\n\n\treturn true;\n\nremove_bypass:\n\tpci_write_config_byte(pdev, RENESAS_ROM_STATUS, 0);\n\treturn false;\n}\n\nstatic int renesas_load_fw(struct pci_dev *pdev, const struct firmware *fw)\n{\n\tint err = 0;\n\tbool rom;\n\n\t \n\trom = renesas_check_rom(pdev);\n\tif (rom) {\n\t\t \n\t\trenesas_rom_erase(pdev);\n\n\t\t \n\t\trom = renesas_setup_rom(pdev, fw);\n\t\tif (!rom) {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"ROM load failed, falling back on FW load\\n\");\n\t\t} else {\n\t\t\tdev_dbg(&pdev->dev,\n\t\t\t\t\"ROM load success\\n\");\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\terr = renesas_fw_download(pdev, fw);\n\nexit:\n\tif (err)\n\t\tdev_err(&pdev->dev, \"firmware failed to download (%d).\", err);\n\treturn err;\n}\n\nint renesas_xhci_check_request_fw(struct pci_dev *pdev,\n\t\t\t\t  const struct pci_device_id *id)\n{\n\tstruct xhci_driver_data *driver_data =\n\t\t\t(struct xhci_driver_data *)id->driver_data;\n\tconst char *fw_name = driver_data->firmware;\n\tconst struct firmware *fw;\n\tbool has_rom;\n\tint err;\n\n\t \n\thas_rom = renesas_check_rom(pdev);\n\tif (has_rom) {\n\t\terr = renesas_check_rom_state(pdev);\n\t\tif (!err)\n\t\t\treturn 0;\n\t\telse if (err != -ENOENT)\n\t\t\thas_rom = false;\n\t}\n\n\terr = renesas_fw_check_running(pdev);\n\t \n\tif (!err)\n\t\treturn 0;\n\n\t \n\tif (err != 1)\n\t\treturn has_rom ? 0 : err;\n\n\tpci_dev_get(pdev);\n\terr = firmware_request_nowarn(&fw, fw_name, &pdev->dev);\n\tpci_dev_put(pdev);\n\tif (err) {\n\t\tif (has_rom) {\n\t\t\tdev_info(&pdev->dev, \"failed to load firmware %s, fallback to ROM\\n\",\n\t\t\t\t fw_name);\n\t\t\treturn 0;\n\t\t}\n\t\tdev_err(&pdev->dev, \"failed to load firmware %s: %d\\n\",\n\t\t\tfw_name, err);\n\t\treturn err;\n\t}\n\n\terr = renesas_fw_verify(fw->data, fw->size);\n\tif (err)\n\t\tgoto exit;\n\n\terr = renesas_load_fw(pdev, fw);\nexit:\n\trelease_firmware(fw);\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(renesas_xhci_check_request_fw);\n\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}