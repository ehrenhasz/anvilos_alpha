{
  "module_name": "fsl-mph-dr-of.c",
  "hash_id": "ae4f7685599adb9f0334d10432d4c61c8058f130554de2c28a25c36eba292871",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/fsl-mph-dr-of.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/platform_device.h>\n#include <linux/fsl_devices.h>\n#include <linux/err.h>\n#include <linux/io.h>\n#include <linux/of.h>\n#include <linux/of_device.h>\n#include <linux/clk.h>\n#include <linux/module.h>\n#include <linux/dma-mapping.h>\n\nstruct fsl_usb2_dev_data {\n\tchar *dr_mode;\t\t \n\tchar *drivers[3];\t \n\tenum fsl_usb2_operating_modes op_mode;\t \n};\n\nstatic struct fsl_usb2_dev_data dr_mode_data[] = {\n\t{\n\t\t.dr_mode = \"host\",\n\t\t.drivers = { \"fsl-ehci\", NULL, NULL, },\n\t\t.op_mode = FSL_USB2_DR_HOST,\n\t},\n\t{\n\t\t.dr_mode = \"otg\",\n\t\t.drivers = { \"fsl-usb2-otg\", \"fsl-ehci\", \"fsl-usb2-udc\", },\n\t\t.op_mode = FSL_USB2_DR_OTG,\n\t},\n\t{\n\t\t.dr_mode = \"peripheral\",\n\t\t.drivers = { \"fsl-usb2-udc\", NULL, NULL, },\n\t\t.op_mode = FSL_USB2_DR_DEVICE,\n\t},\n};\n\nstatic struct fsl_usb2_dev_data *get_dr_mode_data(struct device_node *np)\n{\n\tconst unsigned char *prop;\n\tint i;\n\n\tprop = of_get_property(np, \"dr_mode\", NULL);\n\tif (prop) {\n\t\tfor (i = 0; i < ARRAY_SIZE(dr_mode_data); i++) {\n\t\t\tif (!strcmp(prop, dr_mode_data[i].dr_mode))\n\t\t\t\treturn &dr_mode_data[i];\n\t\t}\n\t}\n\tpr_warn(\"%pOF: Invalid 'dr_mode' property, fallback to host mode\\n\",\n\t\tnp);\n\treturn &dr_mode_data[0];  \n}\n\nstatic enum fsl_usb2_phy_modes determine_usb_phy(const char *phy_type)\n{\n\tif (!phy_type)\n\t\treturn FSL_USB2_PHY_NONE;\n\tif (!strcasecmp(phy_type, \"ulpi\"))\n\t\treturn FSL_USB2_PHY_ULPI;\n\tif (!strcasecmp(phy_type, \"utmi\"))\n\t\treturn FSL_USB2_PHY_UTMI;\n\tif (!strcasecmp(phy_type, \"utmi_wide\"))\n\t\treturn FSL_USB2_PHY_UTMI_WIDE;\n\tif (!strcasecmp(phy_type, \"utmi_dual\"))\n\t\treturn FSL_USB2_PHY_UTMI_DUAL;\n\tif (!strcasecmp(phy_type, \"serial\"))\n\t\treturn FSL_USB2_PHY_SERIAL;\n\n\treturn FSL_USB2_PHY_NONE;\n}\n\nstatic struct platform_device *fsl_usb2_device_register(\n\t\t\t\t\tstruct platform_device *ofdev,\n\t\t\t\t\tstruct fsl_usb2_platform_data *pdata,\n\t\t\t\t\tconst char *name, int id)\n{\n\tstruct platform_device *pdev;\n\tconst struct resource *res = ofdev->resource;\n\tunsigned int num = ofdev->num_resources;\n\tint retval;\n\n\tpdev = platform_device_alloc(name, id);\n\tif (!pdev) {\n\t\tretval = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tpdev->dev.parent = &ofdev->dev;\n\n\tpdev->dev.coherent_dma_mask = ofdev->dev.coherent_dma_mask;\n\n\tif (!pdev->dev.dma_mask) {\n\t\tpdev->dev.dma_mask = &ofdev->dev.coherent_dma_mask;\n\t} else {\n\t\tretval = dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));\n\t\tif (retval)\n\t\t\tgoto error;\n\t}\n\n\tretval = platform_device_add_data(pdev, pdata, sizeof(*pdata));\n\tif (retval)\n\t\tgoto error;\n\n\tif (num) {\n\t\tretval = platform_device_add_resources(pdev, res, num);\n\t\tif (retval)\n\t\t\tgoto error;\n\t}\n\n\tdevice_set_of_node_from_dev(&pdev->dev, &ofdev->dev);\n\n\tretval = platform_device_add(pdev);\n\tif (retval)\n\t\tgoto error;\n\n\treturn pdev;\n\nerror:\n\tplatform_device_put(pdev);\n\treturn ERR_PTR(retval);\n}\n\nstatic const struct of_device_id fsl_usb2_mph_dr_of_match[];\n\nstatic enum fsl_usb2_controller_ver usb_get_ver_info(struct device_node *np)\n{\n\tenum fsl_usb2_controller_ver ver = FSL_USB_VER_NONE;\n\n\t \n\tif (of_device_is_compatible(np, \"fsl-usb2-dr\")) {\n\t\tif (of_device_is_compatible(np, \"fsl-usb2-dr-v1.6\"))\n\t\t\tver = FSL_USB_VER_1_6;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-dr-v2.2\"))\n\t\t\tver = FSL_USB_VER_2_2;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-dr-v2.4\"))\n\t\t\tver = FSL_USB_VER_2_4;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-dr-v2.5\"))\n\t\t\tver = FSL_USB_VER_2_5;\n\t\telse  \n\t\t\tver = FSL_USB_VER_OLD;\n\n\t\tif (ver > FSL_USB_VER_NONE)\n\t\t\treturn ver;\n\t}\n\n\tif (of_device_is_compatible(np, \"fsl,mpc5121-usb2-dr\"))\n\t\treturn FSL_USB_VER_OLD;\n\n\tif (of_device_is_compatible(np, \"fsl-usb2-mph\")) {\n\t\tif (of_device_is_compatible(np, \"fsl-usb2-mph-v1.6\"))\n\t\t\tver = FSL_USB_VER_1_6;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-mph-v2.2\"))\n\t\t\tver = FSL_USB_VER_2_2;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-mph-v2.4\"))\n\t\t\tver = FSL_USB_VER_2_4;\n\t\telse if (of_device_is_compatible(np, \"fsl-usb2-mph-v2.5\"))\n\t\t\tver = FSL_USB_VER_2_5;\n\t\telse  \n\t\t\tver = FSL_USB_VER_OLD;\n\t}\n\n\treturn ver;\n}\n\nstatic int fsl_usb2_mph_dr_of_probe(struct platform_device *ofdev)\n{\n\tstruct device_node *np = ofdev->dev.of_node;\n\tstruct platform_device *usb_dev;\n\tstruct fsl_usb2_platform_data data, *pdata;\n\tstruct fsl_usb2_dev_data *dev_data;\n\tconst struct of_device_id *match;\n\tconst unsigned char *prop;\n\tstatic unsigned int idx;\n\tint i;\n\n\tif (!of_device_is_available(np))\n\t\treturn -ENODEV;\n\n\tmatch = of_match_device(fsl_usb2_mph_dr_of_match, &ofdev->dev);\n\tif (!match)\n\t\treturn -ENODEV;\n\n\tpdata = &data;\n\tif (match->data)\n\t\tmemcpy(pdata, match->data, sizeof(data));\n\telse\n\t\tmemset(pdata, 0, sizeof(data));\n\n\tdev_data = get_dr_mode_data(np);\n\n\tif (of_device_is_compatible(np, \"fsl-usb2-mph\")) {\n\t\tif (of_property_present(np, \"port0\"))\n\t\t\tpdata->port_enables |= FSL_USB2_PORT0_ENABLED;\n\n\t\tif (of_property_present(np, \"port1\"))\n\t\t\tpdata->port_enables |= FSL_USB2_PORT1_ENABLED;\n\n\t\tpdata->operating_mode = FSL_USB2_MPH_HOST;\n\t} else {\n\t\tpdata->invert_drvvbus = of_property_read_bool(np, \"fsl,invert-drvvbus\");\n\t\tpdata->invert_pwr_fault = of_property_read_bool(np, \"fsl,invert-pwr-fault\");\n\n\t\t \n\t\tpdata->operating_mode = dev_data->op_mode;\n\t}\n\n\tprop = of_get_property(np, \"phy_type\", NULL);\n\tpdata->phy_mode = determine_usb_phy(prop);\n\tpdata->controller_ver = usb_get_ver_info(np);\n\n\t \n\tpdata->has_fsl_erratum_a007792 =\n\t\tof_property_read_bool(np, \"fsl,usb-erratum-a007792\");\n\tpdata->has_fsl_erratum_a005275 =\n\t\tof_property_read_bool(np, \"fsl,usb-erratum-a005275\");\n\tpdata->has_fsl_erratum_a005697 =\n\t\tof_property_read_bool(np, \"fsl,usb_erratum-a005697\");\n\tpdata->has_fsl_erratum_a006918 =\n\t\tof_property_read_bool(np, \"fsl,usb_erratum-a006918\");\n\tpdata->has_fsl_erratum_14 =\n\t\tof_property_read_bool(np, \"fsl,usb_erratum-14\");\n\n\t \n\tpdata->check_phy_clk_valid =\n\t\tof_property_read_bool(np, \"phy-clk-valid\");\n\n\tif (pdata->have_sysif_regs) {\n\t\tif (pdata->controller_ver == FSL_USB_VER_NONE) {\n\t\t\tdev_warn(&ofdev->dev, \"Could not get controller version\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\n\tfor (i = 0; i < ARRAY_SIZE(dev_data->drivers); i++) {\n\t\tif (!dev_data->drivers[i])\n\t\t\tcontinue;\n\t\tusb_dev = fsl_usb2_device_register(ofdev, pdata,\n\t\t\t\t\tdev_data->drivers[i], idx);\n\t\tif (IS_ERR(usb_dev)) {\n\t\t\tdev_err(&ofdev->dev, \"Can't register usb device\\n\");\n\t\t\treturn PTR_ERR(usb_dev);\n\t\t}\n\t}\n\tidx++;\n\treturn 0;\n}\n\nstatic int __unregister_subdev(struct device *dev, void *d)\n{\n\tplatform_device_unregister(to_platform_device(dev));\n\treturn 0;\n}\n\nstatic void fsl_usb2_mph_dr_of_remove(struct platform_device *ofdev)\n{\n\tdevice_for_each_child(&ofdev->dev, NULL, __unregister_subdev);\n}\n\n#ifdef CONFIG_PPC_MPC512x\n\n#define USBGENCTRL\t\t0x200\t\t \n#define GC_WU_INT_CLR\t\t(1 << 5)\t \n#define GC_ULPI_SEL\t\t(1 << 4)\t \n#define GC_PPP\t\t\t(1 << 3)\t \n#define GC_PFP\t\t\t(1 << 2)\t \n#define GC_WU_ULPI_EN\t\t(1 << 1)\t \n#define GC_WU_IE\t\t(1 << 1)\t \n\n#define ISIPHYCTRL\t\t0x204\t\t \n#define PHYCTRL_PHYE\t\t(1 << 4)\t \n#define PHYCTRL_BSENH\t\t(1 << 3)\t \n#define PHYCTRL_BSEN\t\t(1 << 2)\t \n#define PHYCTRL_LSFE\t\t(1 << 1)\t \n#define PHYCTRL_PXE\t\t(1 << 0)\t \n\nint fsl_usb2_mpc5121_init(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\tstruct clk *clk;\n\tint err;\n\n\tclk = devm_clk_get(pdev->dev.parent, \"ipg\");\n\tif (IS_ERR(clk)) {\n\t\tdev_err(&pdev->dev, \"failed to get clk\\n\");\n\t\treturn PTR_ERR(clk);\n\t}\n\terr = clk_prepare_enable(clk);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to enable clk\\n\");\n\t\treturn err;\n\t}\n\tpdata->clk = clk;\n\n\tif (pdata->phy_mode == FSL_USB2_PHY_UTMI_WIDE) {\n\t\tu32 reg = 0;\n\n\t\tif (pdata->invert_drvvbus)\n\t\t\treg |= GC_PPP;\n\n\t\tif (pdata->invert_pwr_fault)\n\t\t\treg |= GC_PFP;\n\n\t\tout_be32(pdata->regs + ISIPHYCTRL, PHYCTRL_PHYE | PHYCTRL_PXE);\n\t\tout_be32(pdata->regs + USBGENCTRL, reg);\n\t}\n\treturn 0;\n}\n\nstatic void fsl_usb2_mpc5121_exit(struct platform_device *pdev)\n{\n\tstruct fsl_usb2_platform_data *pdata = dev_get_platdata(&pdev->dev);\n\n\tpdata->regs = NULL;\n\n\tif (pdata->clk)\n\t\tclk_disable_unprepare(pdata->clk);\n}\n\nstatic struct fsl_usb2_platform_data fsl_usb2_mpc5121_pd = {\n\t.big_endian_desc = 1,\n\t.big_endian_mmio = 1,\n\t.es = 1,\n\t.have_sysif_regs = 0,\n\t.le_setup_buf = 1,\n\t.init = fsl_usb2_mpc5121_init,\n\t.exit = fsl_usb2_mpc5121_exit,\n};\n#endif  \n\nstatic struct fsl_usb2_platform_data fsl_usb2_mpc8xxx_pd = {\n\t.have_sysif_regs = 1,\n};\n\nstatic const struct of_device_id fsl_usb2_mph_dr_of_match[] = {\n\t{ .compatible = \"fsl-usb2-mph\", .data = &fsl_usb2_mpc8xxx_pd, },\n\t{ .compatible = \"fsl-usb2-dr\", .data = &fsl_usb2_mpc8xxx_pd, },\n#ifdef CONFIG_PPC_MPC512x\n\t{ .compatible = \"fsl,mpc5121-usb2-dr\", .data = &fsl_usb2_mpc5121_pd, },\n#endif\n\t{},\n};\nMODULE_DEVICE_TABLE(of, fsl_usb2_mph_dr_of_match);\n\nstatic struct platform_driver fsl_usb2_mph_dr_driver = {\n\t.driver = {\n\t\t.name = \"fsl-usb2-mph-dr\",\n\t\t.of_match_table = fsl_usb2_mph_dr_of_match,\n\t},\n\t.probe\t= fsl_usb2_mph_dr_of_probe,\n\t.remove_new = fsl_usb2_mph_dr_of_remove,\n};\n\nmodule_platform_driver(fsl_usb2_mph_dr_driver);\n\nMODULE_DESCRIPTION(\"FSL MPH DR OF devices driver\");\nMODULE_AUTHOR(\"Anatolij Gustschin <agust@denx.de>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}