{
  "module_name": "xhci-tegra.c",
  "hash_id": "a09317568496065f1894e6292122c86353c1c87815a5292a0665063114638e0c",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-tegra.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/delay.h>\n#include <linux/dma-mapping.h>\n#include <linux/firmware.h>\n#include <linux/interrupt.h>\n#include <linux/iopoll.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_irq.h>\n#include <linux/phy/phy.h>\n#include <linux/phy/tegra/xusb.h>\n#include <linux/platform_device.h>\n#include <linux/usb/ch9.h>\n#include <linux/pm.h>\n#include <linux/pm_domain.h>\n#include <linux/pm_runtime.h>\n#include <linux/regulator/consumer.h>\n#include <linux/reset.h>\n#include <linux/slab.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/phy.h>\n#include <linux/usb/role.h>\n#include <soc/tegra/pmc.h>\n\n#include \"xhci.h\"\n\n#define TEGRA_XHCI_SS_HIGH_SPEED 120000000\n#define TEGRA_XHCI_SS_LOW_SPEED   12000000\n\n \n#define XUSB_CFG_1\t\t\t\t0x004\n#define  XUSB_IO_SPACE_EN\t\t\tBIT(0)\n#define  XUSB_MEM_SPACE_EN\t\t\tBIT(1)\n#define  XUSB_BUS_MASTER_EN\t\t\tBIT(2)\n#define XUSB_CFG_4\t\t\t\t0x010\n#define  XUSB_BASE_ADDR_SHIFT\t\t\t15\n#define  XUSB_BASE_ADDR_MASK\t\t\t0x1ffff\n#define XUSB_CFG_7\t\t\t\t0x01c\n#define  XUSB_BASE2_ADDR_SHIFT\t\t\t16\n#define  XUSB_BASE2_ADDR_MASK\t\t\t0xffff\n#define XUSB_CFG_16\t\t\t\t0x040\n#define XUSB_CFG_24\t\t\t\t0x060\n#define XUSB_CFG_AXI_CFG\t\t\t0x0f8\n#define XUSB_CFG_ARU_C11_CSBRANGE\t\t0x41c\n#define XUSB_CFG_ARU_CONTEXT\t\t\t0x43c\n#define XUSB_CFG_ARU_CONTEXT_HS_PLS\t\t0x478\n#define XUSB_CFG_ARU_CONTEXT_FS_PLS\t\t0x47c\n#define XUSB_CFG_ARU_CONTEXT_HSFS_SPEED\t\t0x480\n#define XUSB_CFG_ARU_CONTEXT_HSFS_PP\t\t0x484\n#define XUSB_CFG_CSB_BASE_ADDR\t\t\t0x800\n\n \n \n#define  MBOX_DEST_FALC\t\t\t\tBIT(27)\n#define  MBOX_DEST_PME\t\t\t\tBIT(28)\n#define  MBOX_DEST_SMI\t\t\t\tBIT(29)\n#define  MBOX_DEST_XHCI\t\t\t\tBIT(30)\n#define  MBOX_INT_EN\t\t\t\tBIT(31)\n \n#define  CMD_DATA_SHIFT\t\t\t\t0\n#define  CMD_DATA_MASK\t\t\t\t0xffffff\n#define  CMD_TYPE_SHIFT\t\t\t\t24\n#define  CMD_TYPE_MASK\t\t\t\t0xff\n \n#define  MBOX_OWNER_NONE\t\t\t0\n#define  MBOX_OWNER_FW\t\t\t\t1\n#define  MBOX_OWNER_SW\t\t\t\t2\n#define XUSB_CFG_ARU_SMI_INTR\t\t\t0x428\n#define  MBOX_SMI_INTR_FW_HANG\t\t\tBIT(1)\n#define  MBOX_SMI_INTR_EN\t\t\tBIT(3)\n\n \n#define XUSB_BAR2_ARU_MBOX_CMD\t\t\t0x004\n#define XUSB_BAR2_ARU_MBOX_DATA_IN\t\t0x008\n#define XUSB_BAR2_ARU_MBOX_DATA_OUT\t\t0x00c\n#define XUSB_BAR2_ARU_MBOX_OWNER\t\t0x010\n#define XUSB_BAR2_ARU_SMI_INTR\t\t\t0x014\n#define XUSB_BAR2_ARU_SMI_ARU_FW_SCRATCH_DATA0\t0x01c\n#define XUSB_BAR2_ARU_IFRDMA_CFG0\t\t0x0e0\n#define XUSB_BAR2_ARU_IFRDMA_CFG1\t\t0x0e4\n#define XUSB_BAR2_ARU_IFRDMA_STREAMID_FIELD\t0x0e8\n#define XUSB_BAR2_ARU_C11_CSBRANGE\t\t0x9c\n#define XUSB_BAR2_ARU_FW_SCRATCH\t\t0x1000\n#define XUSB_BAR2_CSB_BASE_ADDR\t\t\t0x2000\n\n \n#define IPFS_XUSB_HOST_MSI_BAR_SZ_0\t\t0x0c0\n#define IPFS_XUSB_HOST_MSI_AXI_BAR_ST_0\t\t0x0c4\n#define IPFS_XUSB_HOST_MSI_FPCI_BAR_ST_0\t0x0c8\n#define IPFS_XUSB_HOST_MSI_VEC0_0\t\t0x100\n#define IPFS_XUSB_HOST_MSI_EN_VEC0_0\t\t0x140\n#define IPFS_XUSB_HOST_CONFIGURATION_0\t\t0x180\n#define  IPFS_EN_FPCI\t\t\t\tBIT(0)\n#define IPFS_XUSB_HOST_FPCI_ERROR_MASKS_0\t0x184\n#define IPFS_XUSB_HOST_INTR_MASK_0\t\t0x188\n#define  IPFS_IP_INT_MASK\t\t\tBIT(16)\n#define IPFS_XUSB_HOST_INTR_ENABLE_0\t\t0x198\n#define IPFS_XUSB_HOST_UFPCI_CONFIG_0\t\t0x19c\n#define IPFS_XUSB_HOST_CLKGATE_HYSTERESIS_0\t0x1bc\n#define IPFS_XUSB_HOST_MCCIF_FIFOCTRL_0\t\t0x1dc\n\n#define CSB_PAGE_SELECT_MASK\t\t\t0x7fffff\n#define CSB_PAGE_SELECT_SHIFT\t\t\t9\n#define CSB_PAGE_OFFSET_MASK\t\t\t0x1ff\n#define CSB_PAGE_SELECT(addr)\t((addr) >> (CSB_PAGE_SELECT_SHIFT) &\t\\\n\t\t\t\t CSB_PAGE_SELECT_MASK)\n#define CSB_PAGE_OFFSET(addr)\t((addr) & CSB_PAGE_OFFSET_MASK)\n\n \n#define XUSB_FALC_CPUCTL\t\t\t0x100\n#define  CPUCTL_STARTCPU\t\t\tBIT(1)\n#define  CPUCTL_STATE_HALTED\t\t\tBIT(4)\n#define  CPUCTL_STATE_STOPPED\t\t\tBIT(5)\n#define XUSB_FALC_BOOTVEC\t\t\t0x104\n#define XUSB_FALC_DMACTL\t\t\t0x10c\n#define XUSB_FALC_IMFILLRNG1\t\t\t0x154\n#define  IMFILLRNG1_TAG_MASK\t\t\t0xffff\n#define  IMFILLRNG1_TAG_LO_SHIFT\t\t0\n#define  IMFILLRNG1_TAG_HI_SHIFT\t\t16\n#define XUSB_FALC_IMFILLCTL\t\t\t0x158\n\n \n#define XUSB_CSB_ARU_SCRATCH0\t\t\t0x100100\n\n \n#define XUSB_CSB_MP_ILOAD_ATTR\t\t\t0x101a00\n#define XUSB_CSB_MP_ILOAD_BASE_LO\t\t0x101a04\n#define XUSB_CSB_MP_ILOAD_BASE_HI\t\t0x101a08\n#define XUSB_CSB_MP_L2IMEMOP_SIZE\t\t0x101a10\n#define  L2IMEMOP_SIZE_SRC_OFFSET_SHIFT\t\t8\n#define  L2IMEMOP_SIZE_SRC_OFFSET_MASK\t\t0x3ff\n#define  L2IMEMOP_SIZE_SRC_COUNT_SHIFT\t\t24\n#define  L2IMEMOP_SIZE_SRC_COUNT_MASK\t\t0xff\n#define XUSB_CSB_MP_L2IMEMOP_TRIG\t\t0x101a14\n#define  L2IMEMOP_ACTION_SHIFT\t\t\t24\n#define  L2IMEMOP_INVALIDATE_ALL\t\t(0x40 << L2IMEMOP_ACTION_SHIFT)\n#define  L2IMEMOP_LOAD_LOCKED_RESULT\t\t(0x11 << L2IMEMOP_ACTION_SHIFT)\n#define XUSB_CSB_MEMPOOL_L2IMEMOP_RESULT\t0x101a18\n#define  L2IMEMOP_RESULT_VLD\t\t\tBIT(31)\n#define XUSB_CSB_MP_APMAP\t\t\t0x10181c\n#define  APMAP_BOOTPATH\t\t\t\tBIT(31)\n\n#define IMEM_BLOCK_SIZE\t\t\t\t256\n\n#define FW_IOCTL_TYPE_SHIFT\t\t\t24\n#define FW_IOCTL_CFGTBL_READ\t\t17\n\nstruct tegra_xusb_fw_header {\n\t__le32 boot_loadaddr_in_imem;\n\t__le32 boot_codedfi_offset;\n\t__le32 boot_codetag;\n\t__le32 boot_codesize;\n\t__le32 phys_memaddr;\n\t__le16 reqphys_memsize;\n\t__le16 alloc_phys_memsize;\n\t__le32 rodata_img_offset;\n\t__le32 rodata_section_start;\n\t__le32 rodata_section_end;\n\t__le32 main_fnaddr;\n\t__le32 fwimg_cksum;\n\t__le32 fwimg_created_time;\n\t__le32 imem_resident_start;\n\t__le32 imem_resident_end;\n\t__le32 idirect_start;\n\t__le32 idirect_end;\n\t__le32 l2_imem_start;\n\t__le32 l2_imem_end;\n\t__le32 version_id;\n\tu8 init_ddirect;\n\tu8 reserved[3];\n\t__le32 phys_addr_log_buffer;\n\t__le32 total_log_entries;\n\t__le32 dequeue_ptr;\n\t__le32 dummy_var[2];\n\t__le32 fwimg_len;\n\tu8 magic[8];\n\t__le32 ss_low_power_entry_timeout;\n\tu8 num_hsic_port;\n\tu8 padding[139];  \n};\n\nstruct tegra_xusb_phy_type {\n\tconst char *name;\n\tunsigned int num;\n};\n\nstruct tegra_xusb_mbox_regs {\n\tu16 cmd;\n\tu16 data_in;\n\tu16 data_out;\n\tu16 owner;\n\tu16 smi_intr;\n};\n\nstruct tegra_xusb_context_soc {\n\tstruct {\n\t\tconst unsigned int *offsets;\n\t\tunsigned int num_offsets;\n\t} ipfs;\n\n\tstruct {\n\t\tconst unsigned int *offsets;\n\t\tunsigned int num_offsets;\n\t} fpci;\n};\n\nstruct tegra_xusb;\nstruct tegra_xusb_soc_ops {\n\tu32 (*mbox_reg_readl)(struct tegra_xusb *tegra, unsigned int offset);\n\tvoid (*mbox_reg_writel)(struct tegra_xusb *tegra, u32 value, unsigned int offset);\n\tu32 (*csb_reg_readl)(struct tegra_xusb *tegra, unsigned int offset);\n\tvoid (*csb_reg_writel)(struct tegra_xusb *tegra, u32 value, unsigned int offset);\n};\n\nstruct tegra_xusb_soc {\n\tconst char *firmware;\n\tconst char * const *supply_names;\n\tunsigned int num_supplies;\n\tconst struct tegra_xusb_phy_type *phy_types;\n\tunsigned int num_types;\n\tconst struct tegra_xusb_context_soc *context;\n\n\tstruct {\n\t\tstruct {\n\t\t\tunsigned int offset;\n\t\t\tunsigned int count;\n\t\t} usb2, ulpi, hsic, usb3;\n\t} ports;\n\n\tstruct tegra_xusb_mbox_regs mbox;\n\tconst struct tegra_xusb_soc_ops *ops;\n\n\tbool scale_ss_clock;\n\tbool has_ipfs;\n\tbool lpm_support;\n\tbool otg_reset_sspi;\n\n\tbool has_bar2;\n};\n\nstruct tegra_xusb_context {\n\tu32 *ipfs;\n\tu32 *fpci;\n};\n\nstruct tegra_xusb {\n\tstruct device *dev;\n\tvoid __iomem *regs;\n\tstruct usb_hcd *hcd;\n\n\tstruct mutex lock;\n\n\tint xhci_irq;\n\tint mbox_irq;\n\tint padctl_irq;\n\n\tvoid __iomem *ipfs_base;\n\tvoid __iomem *fpci_base;\n\tvoid __iomem *bar2_base;\n\tstruct resource *bar2;\n\n\tconst struct tegra_xusb_soc *soc;\n\n\tstruct regulator_bulk_data *supplies;\n\n\tstruct tegra_xusb_padctl *padctl;\n\n\tstruct clk *host_clk;\n\tstruct clk *falcon_clk;\n\tstruct clk *ss_clk;\n\tstruct clk *ss_src_clk;\n\tstruct clk *hs_src_clk;\n\tstruct clk *fs_src_clk;\n\tstruct clk *pll_u_480m;\n\tstruct clk *clk_m;\n\tstruct clk *pll_e;\n\n\tstruct reset_control *host_rst;\n\tstruct reset_control *ss_rst;\n\n\tstruct device *genpd_dev_host;\n\tstruct device *genpd_dev_ss;\n\tbool use_genpd;\n\n\tstruct phy **phys;\n\tunsigned int num_phys;\n\n\tstruct usb_phy **usbphy;\n\tunsigned int num_usb_phys;\n\tint otg_usb2_port;\n\tint otg_usb3_port;\n\tbool host_mode;\n\tstruct notifier_block id_nb;\n\tstruct work_struct id_work;\n\n\t \n\tstruct {\n\t\tsize_t size;\n\t\tvoid *virt;\n\t\tdma_addr_t phys;\n\t} fw;\n\n\tbool suspended;\n\tstruct tegra_xusb_context context;\n\tu8 lp0_utmi_pad_mask;\n};\n\nstatic struct hc_driver __read_mostly tegra_xhci_hc_driver;\n\nstatic inline u32 fpci_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\treturn readl(tegra->fpci_base + offset);\n}\n\nstatic inline void fpci_writel(struct tegra_xusb *tegra, u32 value,\n\t\t\t       unsigned int offset)\n{\n\twritel(value, tegra->fpci_base + offset);\n}\n\nstatic inline u32 ipfs_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\treturn readl(tegra->ipfs_base + offset);\n}\n\nstatic inline void ipfs_writel(struct tegra_xusb *tegra, u32 value,\n\t\t\t       unsigned int offset)\n{\n\twritel(value, tegra->ipfs_base + offset);\n}\n\nstatic inline u32 bar2_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\treturn readl(tegra->bar2_base + offset);\n}\n\nstatic inline void bar2_writel(struct tegra_xusb *tegra, u32 value,\n\t\t\t       unsigned int offset)\n{\n\twritel(value, tegra->bar2_base + offset);\n}\n\nstatic u32 csb_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\tconst struct tegra_xusb_soc_ops *ops = tegra->soc->ops;\n\n\treturn ops->csb_reg_readl(tegra, offset);\n}\n\nstatic void csb_writel(struct tegra_xusb *tegra, u32 value,\n\t\t       unsigned int offset)\n{\n\tconst struct tegra_xusb_soc_ops *ops = tegra->soc->ops;\n\n\tops->csb_reg_writel(tegra, value, offset);\n}\n\nstatic u32 fpci_csb_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\tu32 page = CSB_PAGE_SELECT(offset);\n\tu32 ofs = CSB_PAGE_OFFSET(offset);\n\n\tfpci_writel(tegra, page, XUSB_CFG_ARU_C11_CSBRANGE);\n\n\treturn fpci_readl(tegra, XUSB_CFG_CSB_BASE_ADDR + ofs);\n}\n\nstatic void fpci_csb_writel(struct tegra_xusb *tegra, u32 value,\n\t\t\t    unsigned int offset)\n{\n\tu32 page = CSB_PAGE_SELECT(offset);\n\tu32 ofs = CSB_PAGE_OFFSET(offset);\n\n\tfpci_writel(tegra, page, XUSB_CFG_ARU_C11_CSBRANGE);\n\tfpci_writel(tegra, value, XUSB_CFG_CSB_BASE_ADDR + ofs);\n}\n\nstatic u32 bar2_csb_readl(struct tegra_xusb *tegra, unsigned int offset)\n{\n\tu32 page = CSB_PAGE_SELECT(offset);\n\tu32 ofs = CSB_PAGE_OFFSET(offset);\n\n\tbar2_writel(tegra, page, XUSB_BAR2_ARU_C11_CSBRANGE);\n\n\treturn bar2_readl(tegra, XUSB_BAR2_CSB_BASE_ADDR + ofs);\n}\n\nstatic void bar2_csb_writel(struct tegra_xusb *tegra, u32 value,\n\t\t\t    unsigned int offset)\n{\n\tu32 page = CSB_PAGE_SELECT(offset);\n\tu32 ofs = CSB_PAGE_OFFSET(offset);\n\n\tbar2_writel(tegra, page, XUSB_BAR2_ARU_C11_CSBRANGE);\n\tbar2_writel(tegra, value, XUSB_BAR2_CSB_BASE_ADDR + ofs);\n}\n\nstatic int tegra_xusb_set_ss_clk(struct tegra_xusb *tegra,\n\t\t\t\t unsigned long rate)\n{\n\tunsigned long new_parent_rate, old_parent_rate;\n\tstruct clk *clk = tegra->ss_src_clk;\n\tunsigned int div;\n\tint err;\n\n\tif (clk_get_rate(clk) == rate)\n\t\treturn 0;\n\n\tswitch (rate) {\n\tcase TEGRA_XHCI_SS_HIGH_SPEED:\n\t\t \n\t\told_parent_rate = clk_get_rate(clk_get_parent(clk));\n\t\tnew_parent_rate = clk_get_rate(tegra->pll_u_480m);\n\t\tdiv = new_parent_rate / rate;\n\n\t\terr = clk_set_rate(clk, old_parent_rate / div);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = clk_set_parent(clk, tegra->pll_u_480m);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\t \n\t\terr = clk_set_rate(clk, rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbreak;\n\n\tcase TEGRA_XHCI_SS_LOW_SPEED:\n\t\t \n\t\terr = clk_set_parent(clk, tegra->clk_m);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\terr = clk_set_rate(clk, rate);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tbreak;\n\n\tdefault:\n\t\tdev_err(tegra->dev, \"Invalid SS rate: %lu Hz\\n\", rate);\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_get_rate(clk) != rate) {\n\t\tdev_err(tegra->dev, \"SS clock doesn't match requested rate\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic unsigned long extract_field(u32 value, unsigned int start,\n\t\t\t\t   unsigned int count)\n{\n\treturn (value >> start) & ((1 << count) - 1);\n}\n\n \nenum tegra_xusb_mbox_cmd {\n\tMBOX_CMD_MSG_ENABLED = 1,\n\tMBOX_CMD_INC_FALC_CLOCK,\n\tMBOX_CMD_DEC_FALC_CLOCK,\n\tMBOX_CMD_INC_SSPI_CLOCK,\n\tMBOX_CMD_DEC_SSPI_CLOCK,\n\tMBOX_CMD_SET_BW,  \n\tMBOX_CMD_SET_SS_PWR_GATING,\n\tMBOX_CMD_SET_SS_PWR_UNGATING,\n\tMBOX_CMD_SAVE_DFE_CTLE_CTX,\n\tMBOX_CMD_AIRPLANE_MODE_ENABLED,  \n\tMBOX_CMD_AIRPLANE_MODE_DISABLED,  \n\tMBOX_CMD_START_HSIC_IDLE,\n\tMBOX_CMD_STOP_HSIC_IDLE,\n\tMBOX_CMD_DBC_WAKE_STACK,  \n\tMBOX_CMD_HSIC_PRETEND_CONNECT,\n\tMBOX_CMD_RESET_SSPI,\n\tMBOX_CMD_DISABLE_SS_LFPS_DETECTION,\n\tMBOX_CMD_ENABLE_SS_LFPS_DETECTION,\n\n\tMBOX_CMD_MAX,\n\n\t \n\tMBOX_CMD_ACK = 128,\n\tMBOX_CMD_NAK\n};\n\nstruct tegra_xusb_mbox_msg {\n\tu32 cmd;\n\tu32 data;\n};\n\nstatic inline u32 tegra_xusb_mbox_pack(const struct tegra_xusb_mbox_msg *msg)\n{\n\treturn (msg->cmd & CMD_TYPE_MASK) << CMD_TYPE_SHIFT |\n\t       (msg->data & CMD_DATA_MASK) << CMD_DATA_SHIFT;\n}\nstatic inline void tegra_xusb_mbox_unpack(struct tegra_xusb_mbox_msg *msg,\n\t\t\t\t\t  u32 value)\n{\n\tmsg->cmd = (value >> CMD_TYPE_SHIFT) & CMD_TYPE_MASK;\n\tmsg->data = (value >> CMD_DATA_SHIFT) & CMD_DATA_MASK;\n}\n\nstatic bool tegra_xusb_mbox_cmd_requires_ack(enum tegra_xusb_mbox_cmd cmd)\n{\n\tswitch (cmd) {\n\tcase MBOX_CMD_SET_BW:\n\tcase MBOX_CMD_ACK:\n\tcase MBOX_CMD_NAK:\n\t\treturn false;\n\n\tdefault:\n\t\treturn true;\n\t}\n}\n\nstatic int tegra_xusb_mbox_send(struct tegra_xusb *tegra,\n\t\t\t\tconst struct tegra_xusb_mbox_msg *msg)\n{\n\tconst struct tegra_xusb_soc_ops *ops = tegra->soc->ops;\n\tbool wait_for_idle = false;\n\tu32 value;\n\n\t \n\tif (!(msg->cmd == MBOX_CMD_ACK || msg->cmd == MBOX_CMD_NAK)) {\n\t\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.owner);\n\t\tif (value != MBOX_OWNER_NONE) {\n\t\t\tdev_err(tegra->dev, \"mailbox is busy\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\tops->mbox_reg_writel(tegra, MBOX_OWNER_SW, tegra->soc->mbox.owner);\n\n\t\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.owner);\n\t\tif (value != MBOX_OWNER_SW) {\n\t\t\tdev_err(tegra->dev, \"failed to acquire mailbox\\n\");\n\t\t\treturn -EBUSY;\n\t\t}\n\n\t\twait_for_idle = true;\n\t}\n\n\tvalue = tegra_xusb_mbox_pack(msg);\n\tops->mbox_reg_writel(tegra, value, tegra->soc->mbox.data_in);\n\n\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.cmd);\n\tvalue |= MBOX_INT_EN | MBOX_DEST_FALC;\n\tops->mbox_reg_writel(tegra, value, tegra->soc->mbox.cmd);\n\n\tif (wait_for_idle) {\n\t\tunsigned long timeout = jiffies + msecs_to_jiffies(250);\n\n\t\twhile (time_before(jiffies, timeout)) {\n\t\t\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.owner);\n\t\t\tif (value == MBOX_OWNER_NONE)\n\t\t\t\tbreak;\n\n\t\t\tusleep_range(10, 20);\n\t\t}\n\n\t\tif (time_after(jiffies, timeout))\n\t\t\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.owner);\n\n\t\tif (value != MBOX_OWNER_NONE)\n\t\t\treturn -ETIMEDOUT;\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t tegra_xusb_mbox_irq(int irq, void *data)\n{\n\tstruct tegra_xusb *tegra = data;\n\tconst struct tegra_xusb_soc_ops *ops = tegra->soc->ops;\n\tu32 value;\n\n\t \n\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.smi_intr);\n\tops->mbox_reg_writel(tegra, value, tegra->soc->mbox.smi_intr);\n\n\tif (value & MBOX_SMI_INTR_FW_HANG)\n\t\tdev_err(tegra->dev, \"controller firmware hang\\n\");\n\n\treturn IRQ_WAKE_THREAD;\n}\n\nstatic void tegra_xusb_mbox_handle(struct tegra_xusb *tegra,\n\t\t\t\t   const struct tegra_xusb_mbox_msg *msg)\n{\n\tstruct tegra_xusb_padctl *padctl = tegra->padctl;\n\tconst struct tegra_xusb_soc *soc = tegra->soc;\n\tstruct device *dev = tegra->dev;\n\tstruct tegra_xusb_mbox_msg rsp;\n\tunsigned long mask;\n\tunsigned int port;\n\tbool idle, enable;\n\tint err = 0;\n\n\tmemset(&rsp, 0, sizeof(rsp));\n\n\tswitch (msg->cmd) {\n\tcase MBOX_CMD_INC_FALC_CLOCK:\n\tcase MBOX_CMD_DEC_FALC_CLOCK:\n\t\trsp.data = clk_get_rate(tegra->falcon_clk) / 1000;\n\t\tif (rsp.data != msg->data)\n\t\t\trsp.cmd = MBOX_CMD_NAK;\n\t\telse\n\t\t\trsp.cmd = MBOX_CMD_ACK;\n\n\t\tbreak;\n\n\tcase MBOX_CMD_INC_SSPI_CLOCK:\n\tcase MBOX_CMD_DEC_SSPI_CLOCK:\n\t\tif (tegra->soc->scale_ss_clock) {\n\t\t\terr = tegra_xusb_set_ss_clk(tegra, msg->data * 1000);\n\t\t\tif (err < 0)\n\t\t\t\trsp.cmd = MBOX_CMD_NAK;\n\t\t\telse\n\t\t\t\trsp.cmd = MBOX_CMD_ACK;\n\n\t\t\trsp.data = clk_get_rate(tegra->ss_src_clk) / 1000;\n\t\t} else {\n\t\t\trsp.cmd = MBOX_CMD_ACK;\n\t\t\trsp.data = msg->data;\n\t\t}\n\n\t\tbreak;\n\n\tcase MBOX_CMD_SET_BW:\n\t\t \n\t\tbreak;\n\n\tcase MBOX_CMD_SAVE_DFE_CTLE_CTX:\n\t\terr = tegra_xusb_padctl_usb3_save_context(padctl, msg->data);\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to save context for USB3#%u: %d\\n\",\n\t\t\t\tmsg->data, err);\n\t\t\trsp.cmd = MBOX_CMD_NAK;\n\t\t} else {\n\t\t\trsp.cmd = MBOX_CMD_ACK;\n\t\t}\n\n\t\trsp.data = msg->data;\n\t\tbreak;\n\n\tcase MBOX_CMD_START_HSIC_IDLE:\n\tcase MBOX_CMD_STOP_HSIC_IDLE:\n\t\tif (msg->cmd == MBOX_CMD_STOP_HSIC_IDLE)\n\t\t\tidle = false;\n\t\telse\n\t\t\tidle = true;\n\n\t\tmask = extract_field(msg->data, 1 + soc->ports.hsic.offset,\n\t\t\t\t     soc->ports.hsic.count);\n\n\t\tfor_each_set_bit(port, &mask, 32) {\n\t\t\terr = tegra_xusb_padctl_hsic_set_idle(padctl, port,\n\t\t\t\t\t\t\t      idle);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (err < 0) {\n\t\t\tdev_err(dev, \"failed to set HSIC#%u %s: %d\\n\", port,\n\t\t\t\tidle ? \"idle\" : \"busy\", err);\n\t\t\trsp.cmd = MBOX_CMD_NAK;\n\t\t} else {\n\t\t\trsp.cmd = MBOX_CMD_ACK;\n\t\t}\n\n\t\trsp.data = msg->data;\n\t\tbreak;\n\n\tcase MBOX_CMD_DISABLE_SS_LFPS_DETECTION:\n\tcase MBOX_CMD_ENABLE_SS_LFPS_DETECTION:\n\t\tif (msg->cmd == MBOX_CMD_DISABLE_SS_LFPS_DETECTION)\n\t\t\tenable = false;\n\t\telse\n\t\t\tenable = true;\n\n\t\tmask = extract_field(msg->data, 1 + soc->ports.usb3.offset,\n\t\t\t\t     soc->ports.usb3.count);\n\n\t\tfor_each_set_bit(port, &mask, soc->ports.usb3.count) {\n\t\t\terr = tegra_xusb_padctl_usb3_set_lfps_detect(padctl,\n\t\t\t\t\t\t\t\t     port,\n\t\t\t\t\t\t\t\t     enable);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\n\t\t\t \n\t\t\tif (!enable)\n\t\t\t\tusleep_range(500, 1000);\n\t\t}\n\n\t\tif (err < 0) {\n\t\t\tdev_err(dev,\n\t\t\t\t\"failed to %s LFPS detection on USB3#%u: %d\\n\",\n\t\t\t\tenable ? \"enable\" : \"disable\", port, err);\n\t\t\trsp.cmd = MBOX_CMD_NAK;\n\t\t} else {\n\t\t\trsp.cmd = MBOX_CMD_ACK;\n\t\t}\n\n\t\trsp.data = msg->data;\n\t\tbreak;\n\n\tdefault:\n\t\tdev_warn(dev, \"unknown message: %#x\\n\", msg->cmd);\n\t\tbreak;\n\t}\n\n\tif (rsp.cmd) {\n\t\tconst char *cmd = (rsp.cmd == MBOX_CMD_ACK) ? \"ACK\" : \"NAK\";\n\n\t\terr = tegra_xusb_mbox_send(tegra, &rsp);\n\t\tif (err < 0)\n\t\t\tdev_err(dev, \"failed to send %s: %d\\n\", cmd, err);\n\t}\n}\n\nstatic irqreturn_t tegra_xusb_mbox_thread(int irq, void *data)\n{\n\tstruct tegra_xusb *tegra = data;\n\tconst struct tegra_xusb_soc_ops *ops = tegra->soc->ops;\n\tstruct tegra_xusb_mbox_msg msg;\n\tu32 value;\n\n\tmutex_lock(&tegra->lock);\n\n\tif (pm_runtime_suspended(tegra->dev) || tegra->suspended)\n\t\tgoto out;\n\n\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.data_out);\n\ttegra_xusb_mbox_unpack(&msg, value);\n\n\tvalue = ops->mbox_reg_readl(tegra, tegra->soc->mbox.cmd);\n\tvalue &= ~MBOX_DEST_SMI;\n\tops->mbox_reg_writel(tegra, value, tegra->soc->mbox.cmd);\n\n\t \n\tif (!tegra_xusb_mbox_cmd_requires_ack(msg.cmd))\n\t\tops->mbox_reg_writel(tegra, MBOX_OWNER_NONE, tegra->soc->mbox.owner);\n\n\ttegra_xusb_mbox_handle(tegra, &msg);\n\nout:\n\tmutex_unlock(&tegra->lock);\n\treturn IRQ_HANDLED;\n}\n\nstatic void tegra_xusb_config(struct tegra_xusb *tegra)\n{\n\tu32 regs = tegra->hcd->rsrc_start;\n\tu32 value;\n\n\tif (tegra->soc->has_ipfs) {\n\t\tvalue = ipfs_readl(tegra, IPFS_XUSB_HOST_CONFIGURATION_0);\n\t\tvalue |= IPFS_EN_FPCI;\n\t\tipfs_writel(tegra, value, IPFS_XUSB_HOST_CONFIGURATION_0);\n\n\t\tusleep_range(10, 20);\n\t}\n\n\t \n\tvalue = fpci_readl(tegra, XUSB_CFG_4);\n\tvalue &= ~(XUSB_BASE_ADDR_MASK << XUSB_BASE_ADDR_SHIFT);\n\tvalue |= regs & (XUSB_BASE_ADDR_MASK << XUSB_BASE_ADDR_SHIFT);\n\tfpci_writel(tegra, value, XUSB_CFG_4);\n\n\t \n\tif (tegra->bar2) {\n\t\tvalue = fpci_readl(tegra, XUSB_CFG_7);\n\t\tvalue &= ~(XUSB_BASE2_ADDR_MASK << XUSB_BASE2_ADDR_SHIFT);\n\t\tvalue |= tegra->bar2->start &\n\t\t\t(XUSB_BASE2_ADDR_MASK << XUSB_BASE2_ADDR_SHIFT);\n\t\tfpci_writel(tegra, value, XUSB_CFG_7);\n\t}\n\n\tusleep_range(100, 200);\n\n\t \n\tvalue = fpci_readl(tegra, XUSB_CFG_1);\n\tvalue |= XUSB_IO_SPACE_EN | XUSB_MEM_SPACE_EN | XUSB_BUS_MASTER_EN;\n\tfpci_writel(tegra, value, XUSB_CFG_1);\n\n\tif (tegra->soc->has_ipfs) {\n\t\t \n\t\tvalue = ipfs_readl(tegra, IPFS_XUSB_HOST_INTR_MASK_0);\n\t\tvalue |= IPFS_IP_INT_MASK;\n\t\tipfs_writel(tegra, value, IPFS_XUSB_HOST_INTR_MASK_0);\n\n\t\t \n\t\tipfs_writel(tegra, 0x80, IPFS_XUSB_HOST_CLKGATE_HYSTERESIS_0);\n\t}\n}\n\nstatic int tegra_xusb_clk_enable(struct tegra_xusb *tegra)\n{\n\tint err;\n\n\terr = clk_prepare_enable(tegra->pll_e);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = clk_prepare_enable(tegra->host_clk);\n\tif (err < 0)\n\t\tgoto disable_plle;\n\n\terr = clk_prepare_enable(tegra->ss_clk);\n\tif (err < 0)\n\t\tgoto disable_host;\n\n\terr = clk_prepare_enable(tegra->falcon_clk);\n\tif (err < 0)\n\t\tgoto disable_ss;\n\n\terr = clk_prepare_enable(tegra->fs_src_clk);\n\tif (err < 0)\n\t\tgoto disable_falc;\n\n\terr = clk_prepare_enable(tegra->hs_src_clk);\n\tif (err < 0)\n\t\tgoto disable_fs_src;\n\n\tif (tegra->soc->scale_ss_clock) {\n\t\terr = tegra_xusb_set_ss_clk(tegra, TEGRA_XHCI_SS_HIGH_SPEED);\n\t\tif (err < 0)\n\t\t\tgoto disable_hs_src;\n\t}\n\n\treturn 0;\n\ndisable_hs_src:\n\tclk_disable_unprepare(tegra->hs_src_clk);\ndisable_fs_src:\n\tclk_disable_unprepare(tegra->fs_src_clk);\ndisable_falc:\n\tclk_disable_unprepare(tegra->falcon_clk);\ndisable_ss:\n\tclk_disable_unprepare(tegra->ss_clk);\ndisable_host:\n\tclk_disable_unprepare(tegra->host_clk);\ndisable_plle:\n\tclk_disable_unprepare(tegra->pll_e);\n\treturn err;\n}\n\nstatic void tegra_xusb_clk_disable(struct tegra_xusb *tegra)\n{\n\tclk_disable_unprepare(tegra->pll_e);\n\tclk_disable_unprepare(tegra->host_clk);\n\tclk_disable_unprepare(tegra->ss_clk);\n\tclk_disable_unprepare(tegra->falcon_clk);\n\tclk_disable_unprepare(tegra->fs_src_clk);\n\tclk_disable_unprepare(tegra->hs_src_clk);\n}\n\nstatic int tegra_xusb_phy_enable(struct tegra_xusb *tegra)\n{\n\tunsigned int i;\n\tint err;\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\terr = phy_init(tegra->phys[i]);\n\t\tif (err)\n\t\t\tgoto disable_phy;\n\n\t\terr = phy_power_on(tegra->phys[i]);\n\t\tif (err) {\n\t\t\tphy_exit(tegra->phys[i]);\n\t\t\tgoto disable_phy;\n\t\t}\n\t}\n\n\treturn 0;\n\ndisable_phy:\n\twhile (i--) {\n\t\tphy_power_off(tegra->phys[i]);\n\t\tphy_exit(tegra->phys[i]);\n\t}\n\n\treturn err;\n}\n\nstatic void tegra_xusb_phy_disable(struct tegra_xusb *tegra)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tphy_power_off(tegra->phys[i]);\n\t\tphy_exit(tegra->phys[i]);\n\t}\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int tegra_xusb_init_context(struct tegra_xusb *tegra)\n{\n\tconst struct tegra_xusb_context_soc *soc = tegra->soc->context;\n\n\ttegra->context.ipfs = devm_kcalloc(tegra->dev, soc->ipfs.num_offsets,\n\t\t\t\t\t   sizeof(u32), GFP_KERNEL);\n\tif (!tegra->context.ipfs)\n\t\treturn -ENOMEM;\n\n\ttegra->context.fpci = devm_kcalloc(tegra->dev, soc->fpci.num_offsets,\n\t\t\t\t\t   sizeof(u32), GFP_KERNEL);\n\tif (!tegra->context.fpci)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n#else\nstatic inline int tegra_xusb_init_context(struct tegra_xusb *tegra)\n{\n\treturn 0;\n}\n#endif\n\nstatic int tegra_xusb_request_firmware(struct tegra_xusb *tegra)\n{\n\tstruct tegra_xusb_fw_header *header;\n\tconst struct firmware *fw;\n\tint err;\n\n\terr = request_firmware(&fw, tegra->soc->firmware, tegra->dev);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to request firmware: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\t \n\theader = (struct tegra_xusb_fw_header *)fw->data;\n\ttegra->fw.size = le32_to_cpu(header->fwimg_len);\n\n\ttegra->fw.virt = dma_alloc_coherent(tegra->dev, tegra->fw.size,\n\t\t\t\t\t    &tegra->fw.phys, GFP_KERNEL);\n\tif (!tegra->fw.virt) {\n\t\tdev_err(tegra->dev, \"failed to allocate memory for firmware\\n\");\n\t\trelease_firmware(fw);\n\t\treturn -ENOMEM;\n\t}\n\n\theader = (struct tegra_xusb_fw_header *)tegra->fw.virt;\n\tmemcpy(tegra->fw.virt, fw->data, tegra->fw.size);\n\trelease_firmware(fw);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_wait_for_falcon(struct tegra_xusb *tegra)\n{\n\tstruct xhci_cap_regs __iomem *cap_regs;\n\tstruct xhci_op_regs __iomem *op_regs;\n\tint ret;\n\tu32 value;\n\n\tcap_regs = tegra->regs;\n\top_regs = tegra->regs + HC_LENGTH(readl(&cap_regs->hc_capbase));\n\n\tret = readl_poll_timeout(&op_regs->status, value, !(value & STS_CNR), 1000, 200000);\n\n\tif (ret)\n\t\tdev_err(tegra->dev, \"XHCI Controller not ready. Falcon state: 0x%x\\n\",\n\t\t\tcsb_readl(tegra, XUSB_FALC_CPUCTL));\n\n\treturn ret;\n}\n\nstatic int tegra_xusb_load_firmware_rom(struct tegra_xusb *tegra)\n{\n\tunsigned int code_tag_blocks, code_size_blocks, code_blocks;\n\tstruct tegra_xusb_fw_header *header;\n\tstruct device *dev = tegra->dev;\n\ttime64_t timestamp;\n\tu64 address;\n\tu32 value;\n\tint err;\n\n\theader = (struct tegra_xusb_fw_header *)tegra->fw.virt;\n\n\tif (csb_readl(tegra, XUSB_CSB_MP_ILOAD_BASE_LO) != 0) {\n\t\tdev_info(dev, \"Firmware already loaded, Falcon state %#x\\n\",\n\t\t\t csb_readl(tegra, XUSB_FALC_CPUCTL));\n\t\treturn 0;\n\t}\n\n\t \n\tcsb_writel(tegra, tegra->fw.size, XUSB_CSB_MP_ILOAD_ATTR);\n\n\t \n\taddress = tegra->fw.phys + sizeof(*header);\n\tcsb_writel(tegra, address >> 32, XUSB_CSB_MP_ILOAD_BASE_HI);\n\tcsb_writel(tegra, address, XUSB_CSB_MP_ILOAD_BASE_LO);\n\n\t \n\tcsb_writel(tegra, APMAP_BOOTPATH, XUSB_CSB_MP_APMAP);\n\n\t \n\tcsb_writel(tegra, L2IMEMOP_INVALIDATE_ALL, XUSB_CSB_MP_L2IMEMOP_TRIG);\n\n\t \n\tcode_tag_blocks = DIV_ROUND_UP(le32_to_cpu(header->boot_codetag),\n\t\t\t\t       IMEM_BLOCK_SIZE);\n\tcode_size_blocks = DIV_ROUND_UP(le32_to_cpu(header->boot_codesize),\n\t\t\t\t\tIMEM_BLOCK_SIZE);\n\tcode_blocks = code_tag_blocks + code_size_blocks;\n\n\tvalue = ((code_tag_blocks & L2IMEMOP_SIZE_SRC_OFFSET_MASK) <<\n\t\t\tL2IMEMOP_SIZE_SRC_OFFSET_SHIFT) |\n\t\t((code_size_blocks & L2IMEMOP_SIZE_SRC_COUNT_MASK) <<\n\t\t\tL2IMEMOP_SIZE_SRC_COUNT_SHIFT);\n\tcsb_writel(tegra, value, XUSB_CSB_MP_L2IMEMOP_SIZE);\n\n\t \n\tcsb_writel(tegra, L2IMEMOP_LOAD_LOCKED_RESULT,\n\t\t   XUSB_CSB_MP_L2IMEMOP_TRIG);\n\n\t \n\tcsb_writel(tegra, code_size_blocks, XUSB_FALC_IMFILLCTL);\n\n\tvalue = ((code_tag_blocks & IMFILLRNG1_TAG_MASK) <<\n\t\t\tIMFILLRNG1_TAG_LO_SHIFT) |\n\t\t((code_blocks & IMFILLRNG1_TAG_MASK) <<\n\t\t\tIMFILLRNG1_TAG_HI_SHIFT);\n\tcsb_writel(tegra, value, XUSB_FALC_IMFILLRNG1);\n\n\tcsb_writel(tegra, 0, XUSB_FALC_DMACTL);\n\n\t \n#define tegra_csb_readl(offset) csb_readl(tegra, offset)\n\terr = readx_poll_timeout(tegra_csb_readl,\n\t\t\t\t XUSB_CSB_MEMPOOL_L2IMEMOP_RESULT, value,\n\t\t\t\t value & L2IMEMOP_RESULT_VLD, 100, 10000);\n\tif (err < 0) {\n\t\tdev_err(dev, \"DMA controller not ready %#010x\\n\", value);\n\t\treturn err;\n\t}\n#undef tegra_csb_readl\n\n\tcsb_writel(tegra, le32_to_cpu(header->boot_codetag),\n\t\t   XUSB_FALC_BOOTVEC);\n\n\t \n\tcsb_writel(tegra, CPUCTL_STARTCPU, XUSB_FALC_CPUCTL);\n\n\tif (tegra_xusb_wait_for_falcon(tegra))\n\t\treturn -EIO;\n\n\ttimestamp = le32_to_cpu(header->fwimg_created_time);\n\n\tdev_info(dev, \"Firmware timestamp: %ptTs UTC\\n\", &timestamp);\n\n\treturn 0;\n}\n\nstatic u32 tegra_xusb_read_firmware_header(struct tegra_xusb *tegra, u32 offset)\n{\n\t \n\tif (offset >= sizeof(struct tegra_xusb_fw_header))\n\t\treturn 0;\n\n\tbar2_writel(tegra, (FW_IOCTL_CFGTBL_READ << FW_IOCTL_TYPE_SHIFT) | offset,\n\t\t    XUSB_BAR2_ARU_FW_SCRATCH);\n\treturn bar2_readl(tegra, XUSB_BAR2_ARU_SMI_ARU_FW_SCRATCH_DATA0);\n}\n\nstatic int tegra_xusb_init_ifr_firmware(struct tegra_xusb *tegra)\n{\n\ttime64_t timestamp;\n\n\tif (tegra_xusb_wait_for_falcon(tegra))\n\t\treturn -EIO;\n\n#define offsetof_32(X, Y) ((u8)(offsetof(X, Y) / sizeof(__le32)))\n\ttimestamp = tegra_xusb_read_firmware_header(tegra, offsetof_32(struct tegra_xusb_fw_header,\n\t\t\t\t\t\t\t\t       fwimg_created_time) << 2);\n\n\tdev_info(tegra->dev, \"Firmware timestamp: %ptTs UTC\\n\", &timestamp);\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_load_firmware(struct tegra_xusb *tegra)\n{\n\tif (!tegra->soc->firmware)\n\t\treturn tegra_xusb_init_ifr_firmware(tegra);\n\telse\n\t\treturn tegra_xusb_load_firmware_rom(tegra);\n}\n\nstatic void tegra_xusb_powerdomain_remove(struct device *dev,\n\t\t\t\t\t  struct tegra_xusb *tegra)\n{\n\tif (!tegra->use_genpd)\n\t\treturn;\n\n\tif (!IS_ERR_OR_NULL(tegra->genpd_dev_ss))\n\t\tdev_pm_domain_detach(tegra->genpd_dev_ss, true);\n\tif (!IS_ERR_OR_NULL(tegra->genpd_dev_host))\n\t\tdev_pm_domain_detach(tegra->genpd_dev_host, true);\n}\n\nstatic int tegra_xusb_powerdomain_init(struct device *dev,\n\t\t\t\t       struct tegra_xusb *tegra)\n{\n\tint err;\n\n\ttegra->genpd_dev_host = dev_pm_domain_attach_by_name(dev, \"xusb_host\");\n\tif (IS_ERR(tegra->genpd_dev_host)) {\n\t\terr = PTR_ERR(tegra->genpd_dev_host);\n\t\tdev_err(dev, \"failed to get host pm-domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra->genpd_dev_ss = dev_pm_domain_attach_by_name(dev, \"xusb_ss\");\n\tif (IS_ERR(tegra->genpd_dev_ss)) {\n\t\terr = PTR_ERR(tegra->genpd_dev_ss);\n\t\tdev_err(dev, \"failed to get superspeed pm-domain: %d\\n\", err);\n\t\treturn err;\n\t}\n\n\ttegra->use_genpd = true;\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_unpowergate_partitions(struct tegra_xusb *tegra)\n{\n\tstruct device *dev = tegra->dev;\n\tint rc;\n\n\tif (tegra->use_genpd) {\n\t\trc = pm_runtime_resume_and_get(tegra->genpd_dev_ss);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to enable XUSB SS partition\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = pm_runtime_resume_and_get(tegra->genpd_dev_host);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to enable XUSB Host partition\\n\");\n\t\t\tpm_runtime_put_sync(tegra->genpd_dev_ss);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\trc = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_XUSBA,\n\t\t\t\t\t\t\ttegra->ss_clk,\n\t\t\t\t\t\t\ttegra->ss_rst);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to enable XUSB SS partition\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = tegra_powergate_sequence_power_up(TEGRA_POWERGATE_XUSBC,\n\t\t\t\t\t\t\ttegra->host_clk,\n\t\t\t\t\t\t\ttegra->host_rst);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to enable XUSB Host partition\\n\");\n\t\t\ttegra_powergate_power_off(TEGRA_POWERGATE_XUSBA);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int tegra_xusb_powergate_partitions(struct tegra_xusb *tegra)\n{\n\tstruct device *dev = tegra->dev;\n\tint rc;\n\n\tif (tegra->use_genpd) {\n\t\trc = pm_runtime_put_sync(tegra->genpd_dev_host);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to disable XUSB Host partition\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = pm_runtime_put_sync(tegra->genpd_dev_ss);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to disable XUSB SS partition\\n\");\n\t\t\tpm_runtime_get_sync(tegra->genpd_dev_host);\n\t\t\treturn rc;\n\t\t}\n\t} else {\n\t\trc = tegra_powergate_power_off(TEGRA_POWERGATE_XUSBC);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to disable XUSB Host partition\\n\");\n\t\t\treturn rc;\n\t\t}\n\n\t\trc = tegra_powergate_power_off(TEGRA_POWERGATE_XUSBA);\n\t\tif (rc < 0) {\n\t\t\tdev_err(dev, \"failed to disable XUSB SS partition\\n\");\n\t\t\ttegra_powergate_sequence_power_up(TEGRA_POWERGATE_XUSBC,\n\t\t\t\t\t\t\t  tegra->host_clk,\n\t\t\t\t\t\t\t  tegra->host_rst);\n\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int __tegra_xusb_enable_firmware_messages(struct tegra_xusb *tegra)\n{\n\tstruct tegra_xusb_mbox_msg msg;\n\tint err;\n\n\t \n\tmsg.cmd = MBOX_CMD_MSG_ENABLED;\n\tmsg.data = 0;\n\n\terr = tegra_xusb_mbox_send(tegra, &msg);\n\tif (err < 0)\n\t\tdev_err(tegra->dev, \"failed to enable messages: %d\\n\", err);\n\n\treturn err;\n}\n\nstatic irqreturn_t tegra_xusb_padctl_irq(int irq, void *data)\n{\n\tstruct tegra_xusb *tegra = data;\n\n\tmutex_lock(&tegra->lock);\n\n\tif (tegra->suspended) {\n\t\tmutex_unlock(&tegra->lock);\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmutex_unlock(&tegra->lock);\n\n\tpm_runtime_resume(tegra->dev);\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int tegra_xusb_enable_firmware_messages(struct tegra_xusb *tegra)\n{\n\tint err;\n\n\tmutex_lock(&tegra->lock);\n\terr = __tegra_xusb_enable_firmware_messages(tegra);\n\tmutex_unlock(&tegra->lock);\n\n\treturn err;\n}\n\nstatic void tegra_xhci_set_port_power(struct tegra_xusb *tegra, bool main,\n\t\t\t\t\t\t bool set)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tstruct usb_hcd *hcd = main ?  xhci->main_hcd : xhci->shared_hcd;\n\tunsigned int wait = (!main && !set) ? 1000 : 10;\n\tu16 typeReq = set ? SetPortFeature : ClearPortFeature;\n\tu16 wIndex = main ? tegra->otg_usb2_port + 1 : tegra->otg_usb3_port + 1;\n\tu32 status;\n\tu32 stat_power = main ? USB_PORT_STAT_POWER : USB_SS_PORT_STAT_POWER;\n\tu32 status_val = set ? stat_power : 0;\n\n\tdev_dbg(tegra->dev, \"%s():%s %s port power\\n\", __func__,\n\t\tset ? \"set\" : \"clear\", main ? \"HS\" : \"SS\");\n\n\thcd->driver->hub_control(hcd, typeReq, USB_PORT_FEAT_POWER, wIndex,\n\t\t\t\t NULL, 0);\n\n\tdo {\n\t\ttegra_xhci_hc_driver.hub_control(hcd, GetPortStatus, 0, wIndex,\n\t\t\t\t\t(char *) &status, sizeof(status));\n\t\tif (status_val == (status & stat_power))\n\t\t\tbreak;\n\n\t\tif (!main && !set)\n\t\t\tusleep_range(600, 700);\n\t\telse\n\t\t\tusleep_range(10, 20);\n\t} while (--wait > 0);\n\n\tif (status_val != (status & stat_power))\n\t\tdev_info(tegra->dev, \"failed to %s %s PP %d\\n\",\n\t\t\t\t\t\tset ? \"set\" : \"clear\",\n\t\t\t\t\t\tmain ? \"HS\" : \"SS\", status);\n}\n\nstatic struct phy *tegra_xusb_get_phy(struct tegra_xusb *tegra, char *name,\n\t\t\t\t\t\t\t\tint port)\n{\n\tunsigned int i, phy_count = 0;\n\n\tfor (i = 0; i < tegra->soc->num_types; i++) {\n\t\tif (!strncmp(tegra->soc->phy_types[i].name, name,\n\t\t\t\t\t\t\t    strlen(name)))\n\t\t\treturn tegra->phys[phy_count+port];\n\n\t\tphy_count += tegra->soc->phy_types[i].num;\n\t}\n\n\treturn NULL;\n}\n\nstatic void tegra_xhci_id_work(struct work_struct *work)\n{\n\tstruct tegra_xusb *tegra = container_of(work, struct tegra_xusb,\n\t\t\t\t\t\tid_work);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tstruct tegra_xusb_mbox_msg msg;\n\tstruct phy *phy = tegra_xusb_get_phy(tegra, \"usb2\",\n\t\t\t\t\t\t    tegra->otg_usb2_port);\n\tu32 status;\n\tint ret;\n\n\tdev_dbg(tegra->dev, \"host mode %s\\n\", tegra->host_mode ? \"on\" : \"off\");\n\n\tmutex_lock(&tegra->lock);\n\n\tif (tegra->host_mode)\n\t\tphy_set_mode_ext(phy, PHY_MODE_USB_OTG, USB_ROLE_HOST);\n\telse\n\t\tphy_set_mode_ext(phy, PHY_MODE_USB_OTG, USB_ROLE_NONE);\n\n\tmutex_unlock(&tegra->lock);\n\n\ttegra->otg_usb3_port = tegra_xusb_padctl_get_usb3_companion(tegra->padctl,\n\t\t\t\t\t\t\t\t    tegra->otg_usb2_port);\n\n\tif (tegra->host_mode) {\n\t\t \n\t\tif (tegra->otg_usb3_port >= 0) {\n\t\t\tif (tegra->soc->otg_reset_sspi) {\n\t\t\t\t \n\t\t\t\ttegra_xhci_hc_driver.hub_control(\n\t\t\t\t\txhci->shared_hcd, GetPortStatus,\n\t\t\t\t\t0, tegra->otg_usb3_port+1,\n\t\t\t\t\t(char *) &status, sizeof(status));\n\t\t\t\tif (status & USB_SS_PORT_STAT_POWER)\n\t\t\t\t\ttegra_xhci_set_port_power(tegra, false,\n\t\t\t\t\t\t\t\t  false);\n\n\t\t\t\t \n\t\t\t\tmsg.cmd = MBOX_CMD_RESET_SSPI;\n\t\t\t\tmsg.data = tegra->otg_usb3_port+1;\n\n\t\t\t\tret = tegra_xusb_mbox_send(tegra, &msg);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_info(tegra->dev,\n\t\t\t\t\t\t\"failed to RESET_SSPI %d\\n\",\n\t\t\t\t\t\tret);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttegra_xhci_set_port_power(tegra, false, true);\n\t\t}\n\n\t\ttegra_xhci_set_port_power(tegra, true, true);\n\n\t} else {\n\t\tif (tegra->otg_usb3_port >= 0)\n\t\t\ttegra_xhci_set_port_power(tegra, false, false);\n\n\t\ttegra_xhci_set_port_power(tegra, true, false);\n\t}\n}\n\n#if IS_ENABLED(CONFIG_PM) || IS_ENABLED(CONFIG_PM_SLEEP)\nstatic bool is_usb2_otg_phy(struct tegra_xusb *tegra, unsigned int index)\n{\n\treturn (tegra->usbphy[index] != NULL);\n}\n\nstatic bool is_usb3_otg_phy(struct tegra_xusb *tegra, unsigned int index)\n{\n\tstruct tegra_xusb_padctl *padctl = tegra->padctl;\n\tunsigned int i;\n\tint port;\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tif (is_usb2_otg_phy(tegra, i)) {\n\t\t\tport = tegra_xusb_padctl_get_usb3_companion(padctl, i);\n\t\t\tif ((port >= 0) && (index == (unsigned int)port))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nstatic bool is_host_mode_phy(struct tegra_xusb *tegra, unsigned int phy_type, unsigned int index)\n{\n\tif (strcmp(tegra->soc->phy_types[phy_type].name, \"hsic\") == 0)\n\t\treturn true;\n\n\tif (strcmp(tegra->soc->phy_types[phy_type].name, \"usb2\") == 0) {\n\t\tif (is_usb2_otg_phy(tegra, index))\n\t\t\treturn ((index == tegra->otg_usb2_port) && tegra->host_mode);\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tif (strcmp(tegra->soc->phy_types[phy_type].name, \"usb3\") == 0) {\n\t\tif (is_usb3_otg_phy(tegra, index))\n\t\t\treturn ((index == tegra->otg_usb3_port) && tegra->host_mode);\n\t\telse\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n#endif\n\nstatic int tegra_xusb_get_usb2_port(struct tegra_xusb *tegra,\n\t\t\t\t\t      struct usb_phy *usbphy)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tif (tegra->usbphy[i] && usbphy == tegra->usbphy[i])\n\t\t\treturn i;\n\t}\n\n\treturn -1;\n}\n\nstatic int tegra_xhci_id_notify(struct notifier_block *nb,\n\t\t\t\t\t unsigned long action, void *data)\n{\n\tstruct tegra_xusb *tegra = container_of(nb, struct tegra_xusb,\n\t\t\t\t\t\t    id_nb);\n\tstruct usb_phy *usbphy = (struct usb_phy *)data;\n\n\tdev_dbg(tegra->dev, \"%s(): action is %d\", __func__, usbphy->last_event);\n\n\tif ((tegra->host_mode && usbphy->last_event == USB_EVENT_ID) ||\n\t\t(!tegra->host_mode && usbphy->last_event != USB_EVENT_ID)) {\n\t\tdev_dbg(tegra->dev, \"Same role(%d) received. Ignore\",\n\t\t\ttegra->host_mode);\n\t\treturn NOTIFY_OK;\n\t}\n\n\ttegra->otg_usb2_port = tegra_xusb_get_usb2_port(tegra, usbphy);\n\n\ttegra->host_mode = (usbphy->last_event == USB_EVENT_ID) ? true : false;\n\n\tschedule_work(&tegra->id_work);\n\n\treturn NOTIFY_OK;\n}\n\nstatic int tegra_xusb_init_usb_phy(struct tegra_xusb *tegra)\n{\n\tunsigned int i;\n\n\ttegra->usbphy = devm_kcalloc(tegra->dev, tegra->num_usb_phys,\n\t\t\t\t   sizeof(*tegra->usbphy), GFP_KERNEL);\n\tif (!tegra->usbphy)\n\t\treturn -ENOMEM;\n\n\tINIT_WORK(&tegra->id_work, tegra_xhci_id_work);\n\ttegra->id_nb.notifier_call = tegra_xhci_id_notify;\n\ttegra->otg_usb2_port = -EINVAL;\n\ttegra->otg_usb3_port = -EINVAL;\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tstruct phy *phy = tegra_xusb_get_phy(tegra, \"usb2\", i);\n\n\t\tif (!phy)\n\t\t\tcontinue;\n\n\t\ttegra->usbphy[i] = devm_usb_get_phy_by_node(tegra->dev,\n\t\t\t\t\t\t\tphy->dev.of_node,\n\t\t\t\t\t\t\t&tegra->id_nb);\n\t\tif (!IS_ERR(tegra->usbphy[i])) {\n\t\t\tdev_dbg(tegra->dev, \"usbphy-%d registered\", i);\n\t\t\totg_set_host(tegra->usbphy[i]->otg, &tegra->hcd->self);\n\t\t} else {\n\t\t\t \n\t\t\ttegra->usbphy[i] = NULL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void tegra_xusb_deinit_usb_phy(struct tegra_xusb *tegra)\n{\n\tunsigned int i;\n\n\tcancel_work_sync(&tegra->id_work);\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++)\n\t\tif (tegra->usbphy[i])\n\t\t\totg_set_host(tegra->usbphy[i]->otg, NULL);\n}\n\nstatic int tegra_xusb_probe(struct platform_device *pdev)\n{\n\tstruct tegra_xusb *tegra;\n\tstruct device_node *np;\n\tstruct resource *regs;\n\tstruct xhci_hcd *xhci;\n\tunsigned int i, j, k;\n\tstruct phy *phy;\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct tegra_xusb_fw_header) != 256);\n\n\ttegra = devm_kzalloc(&pdev->dev, sizeof(*tegra), GFP_KERNEL);\n\tif (!tegra)\n\t\treturn -ENOMEM;\n\n\ttegra->soc = of_device_get_match_data(&pdev->dev);\n\tmutex_init(&tegra->lock);\n\ttegra->dev = &pdev->dev;\n\n\terr = tegra_xusb_init_context(tegra);\n\tif (err < 0)\n\t\treturn err;\n\n\ttegra->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &regs);\n\tif (IS_ERR(tegra->regs))\n\t\treturn PTR_ERR(tegra->regs);\n\n\ttegra->fpci_base = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(tegra->fpci_base))\n\t\treturn PTR_ERR(tegra->fpci_base);\n\n\tif (tegra->soc->has_ipfs) {\n\t\ttegra->ipfs_base = devm_platform_ioremap_resource(pdev, 2);\n\t\tif (IS_ERR(tegra->ipfs_base))\n\t\t\treturn PTR_ERR(tegra->ipfs_base);\n\t} else if (tegra->soc->has_bar2) {\n\t\ttegra->bar2_base = devm_platform_get_and_ioremap_resource(pdev, 2, &tegra->bar2);\n\t\tif (IS_ERR(tegra->bar2_base))\n\t\t\treturn PTR_ERR(tegra->bar2_base);\n\t}\n\n\ttegra->xhci_irq = platform_get_irq(pdev, 0);\n\tif (tegra->xhci_irq < 0)\n\t\treturn tegra->xhci_irq;\n\n\ttegra->mbox_irq = platform_get_irq(pdev, 1);\n\tif (tegra->mbox_irq < 0)\n\t\treturn tegra->mbox_irq;\n\n\ttegra->padctl = tegra_xusb_padctl_get(&pdev->dev);\n\tif (IS_ERR(tegra->padctl))\n\t\treturn PTR_ERR(tegra->padctl);\n\n\tnp = of_parse_phandle(pdev->dev.of_node, \"nvidia,xusb-padctl\", 0);\n\tif (!np) {\n\t\terr = -ENODEV;\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->padctl_irq = of_irq_get(np, 0);\n\tif (tegra->padctl_irq == -EPROBE_DEFER) {\n\t\terr = tegra->padctl_irq;\n\t\tgoto put_padctl;\n\t} else if (tegra->padctl_irq <= 0) {\n\t\t \n\t\ttegra->padctl_irq = 0;\n\t\tdev_dbg(&pdev->dev,\n\t\t\t\"%pOF is missing an interrupt, disabling PM support\\n\", np);\n\t}\n\n\ttegra->host_clk = devm_clk_get(&pdev->dev, \"xusb_host\");\n\tif (IS_ERR(tegra->host_clk)) {\n\t\terr = PTR_ERR(tegra->host_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_host: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->falcon_clk = devm_clk_get(&pdev->dev, \"xusb_falcon_src\");\n\tif (IS_ERR(tegra->falcon_clk)) {\n\t\terr = PTR_ERR(tegra->falcon_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_falcon_src: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->ss_clk = devm_clk_get(&pdev->dev, \"xusb_ss\");\n\tif (IS_ERR(tegra->ss_clk)) {\n\t\terr = PTR_ERR(tegra->ss_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_ss: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->ss_src_clk = devm_clk_get(&pdev->dev, \"xusb_ss_src\");\n\tif (IS_ERR(tegra->ss_src_clk)) {\n\t\terr = PTR_ERR(tegra->ss_src_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_ss_src: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->hs_src_clk = devm_clk_get(&pdev->dev, \"xusb_hs_src\");\n\tif (IS_ERR(tegra->hs_src_clk)) {\n\t\terr = PTR_ERR(tegra->hs_src_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_hs_src: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->fs_src_clk = devm_clk_get(&pdev->dev, \"xusb_fs_src\");\n\tif (IS_ERR(tegra->fs_src_clk)) {\n\t\terr = PTR_ERR(tegra->fs_src_clk);\n\t\tdev_err(&pdev->dev, \"failed to get xusb_fs_src: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->pll_u_480m = devm_clk_get(&pdev->dev, \"pll_u_480m\");\n\tif (IS_ERR(tegra->pll_u_480m)) {\n\t\terr = PTR_ERR(tegra->pll_u_480m);\n\t\tdev_err(&pdev->dev, \"failed to get pll_u_480m: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->clk_m = devm_clk_get(&pdev->dev, \"clk_m\");\n\tif (IS_ERR(tegra->clk_m)) {\n\t\terr = PTR_ERR(tegra->clk_m);\n\t\tdev_err(&pdev->dev, \"failed to get clk_m: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\ttegra->pll_e = devm_clk_get(&pdev->dev, \"pll_e\");\n\tif (IS_ERR(tegra->pll_e)) {\n\t\terr = PTR_ERR(tegra->pll_e);\n\t\tdev_err(&pdev->dev, \"failed to get pll_e: %d\\n\", err);\n\t\tgoto put_padctl;\n\t}\n\n\tif (!of_property_read_bool(pdev->dev.of_node, \"power-domains\")) {\n\t\ttegra->host_rst = devm_reset_control_get(&pdev->dev,\n\t\t\t\t\t\t\t \"xusb_host\");\n\t\tif (IS_ERR(tegra->host_rst)) {\n\t\t\terr = PTR_ERR(tegra->host_rst);\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to get xusb_host reset: %d\\n\", err);\n\t\t\tgoto put_padctl;\n\t\t}\n\n\t\ttegra->ss_rst = devm_reset_control_get(&pdev->dev, \"xusb_ss\");\n\t\tif (IS_ERR(tegra->ss_rst)) {\n\t\t\terr = PTR_ERR(tegra->ss_rst);\n\t\t\tdev_err(&pdev->dev, \"failed to get xusb_ss reset: %d\\n\",\n\t\t\t\terr);\n\t\t\tgoto put_padctl;\n\t\t}\n\t} else {\n\t\terr = tegra_xusb_powerdomain_init(&pdev->dev, tegra);\n\t\tif (err)\n\t\t\tgoto put_powerdomains;\n\t}\n\n\ttegra->supplies = devm_kcalloc(&pdev->dev, tegra->soc->num_supplies,\n\t\t\t\t       sizeof(*tegra->supplies), GFP_KERNEL);\n\tif (!tegra->supplies) {\n\t\terr = -ENOMEM;\n\t\tgoto put_powerdomains;\n\t}\n\n\tregulator_bulk_set_supply_names(tegra->supplies,\n\t\t\t\t\ttegra->soc->supply_names,\n\t\t\t\t\ttegra->soc->num_supplies);\n\n\terr = devm_regulator_bulk_get(&pdev->dev, tegra->soc->num_supplies,\n\t\t\t\t      tegra->supplies);\n\tif (err) {\n\t\tdev_err(&pdev->dev, \"failed to get regulators: %d\\n\", err);\n\t\tgoto put_powerdomains;\n\t}\n\n\tfor (i = 0; i < tegra->soc->num_types; i++) {\n\t\tif (!strncmp(tegra->soc->phy_types[i].name, \"usb2\", 4))\n\t\t\ttegra->num_usb_phys = tegra->soc->phy_types[i].num;\n\t\ttegra->num_phys += tegra->soc->phy_types[i].num;\n\t}\n\n\ttegra->phys = devm_kcalloc(&pdev->dev, tegra->num_phys,\n\t\t\t\t   sizeof(*tegra->phys), GFP_KERNEL);\n\tif (!tegra->phys) {\n\t\terr = -ENOMEM;\n\t\tgoto put_powerdomains;\n\t}\n\n\tfor (i = 0, k = 0; i < tegra->soc->num_types; i++) {\n\t\tchar prop[8];\n\n\t\tfor (j = 0; j < tegra->soc->phy_types[i].num; j++) {\n\t\t\tsnprintf(prop, sizeof(prop), \"%s-%d\",\n\t\t\t\t tegra->soc->phy_types[i].name, j);\n\n\t\t\tphy = devm_phy_optional_get(&pdev->dev, prop);\n\t\t\tif (IS_ERR(phy)) {\n\t\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\t\"failed to get PHY %s: %ld\\n\", prop,\n\t\t\t\t\tPTR_ERR(phy));\n\t\t\t\terr = PTR_ERR(phy);\n\t\t\t\tgoto put_powerdomains;\n\t\t\t}\n\n\t\t\ttegra->phys[k++] = phy;\n\t\t}\n\t}\n\n\ttegra->hcd = usb_create_hcd(&tegra_xhci_hc_driver, &pdev->dev,\n\t\t\t\t    dev_name(&pdev->dev));\n\tif (!tegra->hcd) {\n\t\terr = -ENOMEM;\n\t\tgoto put_powerdomains;\n\t}\n\n\ttegra->hcd->skip_phy_initialization = 1;\n\ttegra->hcd->regs = tegra->regs;\n\ttegra->hcd->rsrc_start = regs->start;\n\ttegra->hcd->rsrc_len = resource_size(regs);\n\n\t \n\tplatform_set_drvdata(pdev, tegra);\n\n\terr = tegra_xusb_clk_enable(tegra);\n\tif (err) {\n\t\tdev_err(tegra->dev, \"failed to enable clocks: %d\\n\", err);\n\t\tgoto put_hcd;\n\t}\n\n\terr = regulator_bulk_enable(tegra->soc->num_supplies, tegra->supplies);\n\tif (err) {\n\t\tdev_err(tegra->dev, \"failed to enable regulators: %d\\n\", err);\n\t\tgoto disable_clk;\n\t}\n\n\terr = tegra_xusb_phy_enable(tegra);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable PHYs: %d\\n\", err);\n\t\tgoto disable_regulator;\n\t}\n\n\t \n\terr = dma_set_mask_and_coherent(tegra->dev, DMA_BIT_MASK(40));\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to set DMA mask: %d\\n\", err);\n\t\tgoto disable_phy;\n\t}\n\n\tif (tegra->soc->firmware) {\n\t\terr = tegra_xusb_request_firmware(tegra);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"failed to request firmware: %d\\n\", err);\n\t\t\tgoto disable_phy;\n\t\t}\n\t}\n\n\terr = tegra_xusb_unpowergate_partitions(tegra);\n\tif (err)\n\t\tgoto free_firmware;\n\n\ttegra_xusb_config(tegra);\n\n\terr = tegra_xusb_load_firmware(tegra);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to load firmware: %d\\n\", err);\n\t\tgoto powergate;\n\t}\n\n\terr = usb_add_hcd(tegra->hcd, tegra->xhci_irq, IRQF_SHARED);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add USB HCD: %d\\n\", err);\n\t\tgoto powergate;\n\t}\n\n\tdevice_wakeup_enable(tegra->hcd->self.controller);\n\n\txhci = hcd_to_xhci(tegra->hcd);\n\n\txhci->shared_hcd = usb_create_shared_hcd(&tegra_xhci_hc_driver,\n\t\t\t\t\t\t &pdev->dev,\n\t\t\t\t\t\t dev_name(&pdev->dev),\n\t\t\t\t\t\t tegra->hcd);\n\tif (!xhci->shared_hcd) {\n\t\tdev_err(&pdev->dev, \"failed to create shared HCD\\n\");\n\t\terr = -ENOMEM;\n\t\tgoto remove_usb2;\n\t}\n\n\tif (HCC_MAX_PSA(xhci->hcc_params) >= 4)\n\t\txhci->shared_hcd->can_do_streams = 1;\n\n\terr = usb_add_hcd(xhci->shared_hcd, tegra->xhci_irq, IRQF_SHARED);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to add shared HCD: %d\\n\", err);\n\t\tgoto put_usb3;\n\t}\n\n\terr = devm_request_threaded_irq(&pdev->dev, tegra->mbox_irq,\n\t\t\t\t\ttegra_xusb_mbox_irq,\n\t\t\t\t\ttegra_xusb_mbox_thread, 0,\n\t\t\t\t\tdev_name(&pdev->dev), tegra);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to request IRQ: %d\\n\", err);\n\t\tgoto remove_usb3;\n\t}\n\n\tif (tegra->padctl_irq) {\n\t\terr = devm_request_threaded_irq(&pdev->dev, tegra->padctl_irq,\n\t\t\t\t\t\tNULL, tegra_xusb_padctl_irq,\n\t\t\t\t\t\tIRQF_ONESHOT, dev_name(&pdev->dev),\n\t\t\t\t\t\ttegra);\n\t\tif (err < 0) {\n\t\t\tdev_err(&pdev->dev, \"failed to request padctl IRQ: %d\\n\", err);\n\t\t\tgoto remove_usb3;\n\t\t}\n\t}\n\n\terr = tegra_xusb_enable_firmware_messages(tegra);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to enable messages: %d\\n\", err);\n\t\tgoto remove_usb3;\n\t}\n\n\terr = tegra_xusb_init_usb_phy(tegra);\n\tif (err < 0) {\n\t\tdev_err(&pdev->dev, \"failed to init USB PHY: %d\\n\", err);\n\t\tgoto remove_usb3;\n\t}\n\n\t \n\tdevice_init_wakeup(&tegra->hcd->self.root_hub->dev, true);\n\tdevice_init_wakeup(&xhci->shared_hcd->self.root_hub->dev, true);\n\n\tpm_runtime_use_autosuspend(tegra->dev);\n\tpm_runtime_set_autosuspend_delay(tegra->dev, 2000);\n\tpm_runtime_mark_last_busy(tegra->dev);\n\tpm_runtime_set_active(tegra->dev);\n\n\tif (tegra->padctl_irq) {\n\t\tdevice_init_wakeup(tegra->dev, true);\n\t\tpm_runtime_enable(tegra->dev);\n\t}\n\n\treturn 0;\n\nremove_usb3:\n\tusb_remove_hcd(xhci->shared_hcd);\nput_usb3:\n\tusb_put_hcd(xhci->shared_hcd);\nremove_usb2:\n\tusb_remove_hcd(tegra->hcd);\npowergate:\n\ttegra_xusb_powergate_partitions(tegra);\nfree_firmware:\n\tdma_free_coherent(&pdev->dev, tegra->fw.size, tegra->fw.virt,\n\t\t\t  tegra->fw.phys);\ndisable_phy:\n\ttegra_xusb_phy_disable(tegra);\ndisable_regulator:\n\tregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\ndisable_clk:\n\ttegra_xusb_clk_disable(tegra);\nput_hcd:\n\tusb_put_hcd(tegra->hcd);\nput_powerdomains:\n\ttegra_xusb_powerdomain_remove(&pdev->dev, tegra);\nput_padctl:\n\tof_node_put(np);\n\ttegra_xusb_padctl_put(tegra->padctl);\n\treturn err;\n}\n\nstatic void tegra_xusb_disable(struct tegra_xusb *tegra)\n{\n\ttegra_xusb_powergate_partitions(tegra);\n\ttegra_xusb_powerdomain_remove(tegra->dev, tegra);\n\ttegra_xusb_phy_disable(tegra);\n\ttegra_xusb_clk_disable(tegra);\n\tregulator_bulk_disable(tegra->soc->num_supplies, tegra->supplies);\n}\n\nstatic void tegra_xusb_remove(struct platform_device *pdev)\n{\n\tstruct tegra_xusb *tegra = platform_get_drvdata(pdev);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\n\ttegra_xusb_deinit_usb_phy(tegra);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tusb_remove_hcd(xhci->shared_hcd);\n\tusb_put_hcd(xhci->shared_hcd);\n\txhci->shared_hcd = NULL;\n\tusb_remove_hcd(tegra->hcd);\n\tusb_put_hcd(tegra->hcd);\n\n\tdma_free_coherent(&pdev->dev, tegra->fw.size, tegra->fw.virt,\n\t\t\t  tegra->fw.phys);\n\n\tif (tegra->padctl_irq)\n\t\tpm_runtime_disable(&pdev->dev);\n\n\tpm_runtime_put(&pdev->dev);\n\n\ttegra_xusb_disable(tegra);\n\ttegra_xusb_padctl_put(tegra->padctl);\n}\n\nstatic void tegra_xusb_shutdown(struct platform_device *pdev)\n{\n\tstruct tegra_xusb *tegra = platform_get_drvdata(pdev);\n\n\tpm_runtime_get_sync(&pdev->dev);\n\tdisable_irq(tegra->xhci_irq);\n\txhci_shutdown(tegra->hcd);\n\ttegra_xusb_disable(tegra);\n}\n\nstatic bool xhci_hub_ports_suspended(struct xhci_hub *hub)\n{\n\tstruct device *dev = hub->hcd->self.controller;\n\tbool status = true;\n\tunsigned int i;\n\tu32 value;\n\n\tfor (i = 0; i < hub->num_ports; i++) {\n\t\tvalue = readl(hub->ports[i]->addr);\n\t\tif ((value & PORT_PE) == 0)\n\t\t\tcontinue;\n\n\t\tif ((value & PORT_PLS_MASK) != XDEV_U3) {\n\t\t\tdev_info(dev, \"%u-%u isn't suspended: %#010x\\n\",\n\t\t\t\t hub->hcd->self.busnum, i + 1, value);\n\t\t\tstatus = false;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic int tegra_xusb_check_ports(struct tegra_xusb *tegra)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tstruct xhci_bus_state *bus_state = &xhci->usb2_rhub.bus_state;\n\tunsigned long flags;\n\tint err = 0;\n\n\tif (bus_state->bus_suspended) {\n\t\t \n\t\tusleep_range(3000, 4000);\n\t}\n\n\tspin_lock_irqsave(&xhci->lock, flags);\n\n\tif (!xhci_hub_ports_suspended(&xhci->usb2_rhub) ||\n\t    !xhci_hub_ports_suspended(&xhci->usb3_rhub))\n\t\terr = -EBUSY;\n\n\tspin_unlock_irqrestore(&xhci->lock, flags);\n\n\treturn err;\n}\n\nstatic void tegra_xusb_save_context(struct tegra_xusb *tegra)\n{\n\tconst struct tegra_xusb_context_soc *soc = tegra->soc->context;\n\tstruct tegra_xusb_context *ctx = &tegra->context;\n\tunsigned int i;\n\n\tif (soc->ipfs.num_offsets > 0) {\n\t\tfor (i = 0; i < soc->ipfs.num_offsets; i++)\n\t\t\tctx->ipfs[i] = ipfs_readl(tegra, soc->ipfs.offsets[i]);\n\t}\n\n\tif (soc->fpci.num_offsets > 0) {\n\t\tfor (i = 0; i < soc->fpci.num_offsets; i++)\n\t\t\tctx->fpci[i] = fpci_readl(tegra, soc->fpci.offsets[i]);\n\t}\n}\n\nstatic void tegra_xusb_restore_context(struct tegra_xusb *tegra)\n{\n\tconst struct tegra_xusb_context_soc *soc = tegra->soc->context;\n\tstruct tegra_xusb_context *ctx = &tegra->context;\n\tunsigned int i;\n\n\tif (soc->fpci.num_offsets > 0) {\n\t\tfor (i = 0; i < soc->fpci.num_offsets; i++)\n\t\t\tfpci_writel(tegra, ctx->fpci[i], soc->fpci.offsets[i]);\n\t}\n\n\tif (soc->ipfs.num_offsets > 0) {\n\t\tfor (i = 0; i < soc->ipfs.num_offsets; i++)\n\t\t\tipfs_writel(tegra, ctx->ipfs[i], soc->ipfs.offsets[i]);\n\t}\n}\n\nstatic enum usb_device_speed tegra_xhci_portsc_to_speed(struct tegra_xusb *tegra, u32 portsc)\n{\n\tif (DEV_LOWSPEED(portsc))\n\t\treturn USB_SPEED_LOW;\n\n\tif (DEV_HIGHSPEED(portsc))\n\t\treturn USB_SPEED_HIGH;\n\n\tif (DEV_FULLSPEED(portsc))\n\t\treturn USB_SPEED_FULL;\n\n\tif (DEV_SUPERSPEED_ANY(portsc))\n\t\treturn USB_SPEED_SUPER;\n\n\treturn USB_SPEED_UNKNOWN;\n}\n\nstatic void tegra_xhci_enable_phy_sleepwalk_wake(struct tegra_xusb *tegra)\n{\n\tstruct tegra_xusb_padctl *padctl = tegra->padctl;\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tenum usb_device_speed speed;\n\tstruct phy *phy;\n\tunsigned int index, offset;\n\tunsigned int i, j, k;\n\tstruct xhci_hub *rhub;\n\tu32 portsc;\n\n\tfor (i = 0, k = 0; i < tegra->soc->num_types; i++) {\n\t\tif (strcmp(tegra->soc->phy_types[i].name, \"usb3\") == 0)\n\t\t\trhub = &xhci->usb3_rhub;\n\t\telse\n\t\t\trhub = &xhci->usb2_rhub;\n\n\t\tif (strcmp(tegra->soc->phy_types[i].name, \"hsic\") == 0)\n\t\t\toffset = tegra->soc->ports.usb2.count;\n\t\telse\n\t\t\toffset = 0;\n\n\t\tfor (j = 0; j < tegra->soc->phy_types[i].num; j++) {\n\t\t\tphy = tegra->phys[k++];\n\n\t\t\tif (!phy)\n\t\t\t\tcontinue;\n\n\t\t\tindex = j + offset;\n\n\t\t\tif (index >= rhub->num_ports)\n\t\t\t\tcontinue;\n\n\t\t\tif (!is_host_mode_phy(tegra, i, j))\n\t\t\t\tcontinue;\n\n\t\t\tportsc = readl(rhub->ports[index]->addr);\n\t\t\tspeed = tegra_xhci_portsc_to_speed(tegra, portsc);\n\t\t\ttegra_xusb_padctl_enable_phy_sleepwalk(padctl, phy, speed);\n\t\t\ttegra_xusb_padctl_enable_phy_wake(padctl, phy);\n\t\t}\n\t}\n}\n\nstatic void tegra_xhci_disable_phy_wake(struct tegra_xusb *tegra)\n{\n\tstruct tegra_xusb_padctl *padctl = tegra->padctl;\n\tunsigned int i;\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tstruct phy *phy = tegra_xusb_get_phy(tegra, \"usb2\", i);\n\n\t\tif (!phy)\n\t\t\tcontinue;\n\n\t\tif (tegra_xusb_padctl_remote_wake_detected(padctl, phy))\n\t\t\ttegra_phy_xusb_utmi_pad_power_on(phy);\n\t}\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tif (!tegra->phys[i])\n\t\t\tcontinue;\n\n\t\tif (tegra_xusb_padctl_remote_wake_detected(padctl, tegra->phys[i]))\n\t\t\tdev_dbg(tegra->dev, \"%pOF remote wake detected\\n\",\n\t\t\t\ttegra->phys[i]->dev.of_node);\n\n\t\ttegra_xusb_padctl_disable_phy_wake(padctl, tegra->phys[i]);\n\t}\n}\n\nstatic void tegra_xhci_disable_phy_sleepwalk(struct tegra_xusb *tegra)\n{\n\tstruct tegra_xusb_padctl *padctl = tegra->padctl;\n\tunsigned int i;\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tif (!tegra->phys[i])\n\t\t\tcontinue;\n\n\t\ttegra_xusb_padctl_disable_phy_sleepwalk(padctl, tegra->phys[i]);\n\t}\n}\n\nstatic void tegra_xhci_program_utmi_power_lp0_exit(struct tegra_xusb *tegra)\n{\n\tunsigned int i, index_to_usb2;\n\tstruct phy *phy;\n\n\tfor (i = 0; i < tegra->soc->num_types; i++) {\n\t\tif (strcmp(tegra->soc->phy_types[i].name, \"usb2\") == 0)\n\t\t\tindex_to_usb2 = i;\n\t}\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tif (!is_host_mode_phy(tegra, index_to_usb2, i))\n\t\t\tcontinue;\n\n\t\tphy = tegra_xusb_get_phy(tegra, \"usb2\", i);\n\t\tif (tegra->lp0_utmi_pad_mask & BIT(i))\n\t\t\ttegra_phy_xusb_utmi_pad_power_on(phy);\n\t\telse\n\t\t\ttegra_phy_xusb_utmi_pad_power_down(phy);\n\t}\n}\n\nstatic int tegra_xusb_enter_elpg(struct tegra_xusb *tegra, bool runtime)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tstruct device *dev = tegra->dev;\n\tbool wakeup = runtime ? true : device_may_wakeup(dev);\n\tunsigned int i;\n\tint err;\n\tu32 usbcmd;\n\tu32 portsc;\n\n\tdev_dbg(dev, \"entering ELPG\\n\");\n\n\tusbcmd = readl(&xhci->op_regs->command);\n\tusbcmd &= ~CMD_EIE;\n\twritel(usbcmd, &xhci->op_regs->command);\n\n\terr = tegra_xusb_check_ports(tegra);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"not all ports suspended: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < tegra->num_usb_phys; i++) {\n\t\tif (!xhci->usb2_rhub.ports[i])\n\t\t\tcontinue;\n\t\tportsc = readl(xhci->usb2_rhub.ports[i]->addr);\n\t\ttegra->lp0_utmi_pad_mask &= ~BIT(i);\n\t\tif (((portsc & PORT_PLS_MASK) == XDEV_U3) || ((portsc & DEV_SPEED_MASK) == XDEV_FS))\n\t\t\ttegra->lp0_utmi_pad_mask |= BIT(i);\n\t}\n\n\terr = xhci_suspend(xhci, wakeup);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to suspend XHCI: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\ttegra_xusb_save_context(tegra);\n\n\tif (wakeup)\n\t\ttegra_xhci_enable_phy_sleepwalk_wake(tegra);\n\n\ttegra_xusb_powergate_partitions(tegra);\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tif (!tegra->phys[i])\n\t\t\tcontinue;\n\n\t\tphy_power_off(tegra->phys[i]);\n\t\tif (!wakeup)\n\t\t\tphy_exit(tegra->phys[i]);\n\t}\n\n\ttegra_xusb_clk_disable(tegra);\n\nout:\n\tif (!err)\n\t\tdev_dbg(tegra->dev, \"entering ELPG done\\n\");\n\telse {\n\t\tusbcmd = readl(&xhci->op_regs->command);\n\t\tusbcmd |= CMD_EIE;\n\t\twritel(usbcmd, &xhci->op_regs->command);\n\n\t\tdev_dbg(tegra->dev, \"entering ELPG failed\\n\");\n\t\tpm_runtime_mark_last_busy(tegra->dev);\n\t}\n\n\treturn err;\n}\n\nstatic int tegra_xusb_exit_elpg(struct tegra_xusb *tegra, bool runtime)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(tegra->hcd);\n\tstruct device *dev = tegra->dev;\n\tbool wakeup = runtime ? true : device_may_wakeup(dev);\n\tunsigned int i;\n\tu32 usbcmd;\n\tint err;\n\n\tdev_dbg(dev, \"exiting ELPG\\n\");\n\tpm_runtime_mark_last_busy(tegra->dev);\n\n\terr = tegra_xusb_clk_enable(tegra);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to enable clocks: %d\\n\", err);\n\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_unpowergate_partitions(tegra);\n\tif (err)\n\t\tgoto disable_clks;\n\n\tif (wakeup)\n\t\ttegra_xhci_disable_phy_wake(tegra);\n\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tif (!tegra->phys[i])\n\t\t\tcontinue;\n\n\t\tif (!wakeup)\n\t\t\tphy_init(tegra->phys[i]);\n\n\t\tphy_power_on(tegra->phys[i]);\n\t}\n\tif (tegra->suspended)\n\t\ttegra_xhci_program_utmi_power_lp0_exit(tegra);\n\n\ttegra_xusb_config(tegra);\n\ttegra_xusb_restore_context(tegra);\n\n\terr = tegra_xusb_load_firmware(tegra);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to load firmware: %d\\n\", err);\n\t\tgoto disable_phy;\n\t}\n\n\terr = __tegra_xusb_enable_firmware_messages(tegra);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to enable messages: %d\\n\", err);\n\t\tgoto disable_phy;\n\t}\n\n\tif (wakeup)\n\t\ttegra_xhci_disable_phy_sleepwalk(tegra);\n\n\terr = xhci_resume(xhci, runtime ? PMSG_AUTO_RESUME : PMSG_RESUME);\n\tif (err < 0) {\n\t\tdev_err(tegra->dev, \"failed to resume XHCI: %d\\n\", err);\n\t\tgoto disable_phy;\n\t}\n\n\tusbcmd = readl(&xhci->op_regs->command);\n\tusbcmd |= CMD_EIE;\n\twritel(usbcmd, &xhci->op_regs->command);\n\n\tgoto out;\n\ndisable_phy:\n\tfor (i = 0; i < tegra->num_phys; i++) {\n\t\tif (!tegra->phys[i])\n\t\t\tcontinue;\n\n\t\tphy_power_off(tegra->phys[i]);\n\t\tif (!wakeup)\n\t\t\tphy_exit(tegra->phys[i]);\n\t}\n\ttegra_xusb_powergate_partitions(tegra);\ndisable_clks:\n\ttegra_xusb_clk_disable(tegra);\nout:\n\tif (!err)\n\t\tdev_dbg(dev, \"exiting ELPG done\\n\");\n\telse\n\t\tdev_dbg(dev, \"exiting ELPG failed\\n\");\n\n\treturn err;\n}\n\nstatic __maybe_unused int tegra_xusb_suspend(struct device *dev)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(dev);\n\tint err;\n\n\tsynchronize_irq(tegra->mbox_irq);\n\n\tmutex_lock(&tegra->lock);\n\n\tif (pm_runtime_suspended(dev)) {\n\t\terr = tegra_xusb_exit_elpg(tegra, true);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\terr = tegra_xusb_enter_elpg(tegra, false);\n\tif (err < 0) {\n\t\tif (pm_runtime_suspended(dev)) {\n\t\t\tpm_runtime_disable(dev);\n\t\t\tpm_runtime_set_active(dev);\n\t\t\tpm_runtime_enable(dev);\n\t\t}\n\n\t\tgoto out;\n\t}\n\nout:\n\tif (!err) {\n\t\ttegra->suspended = true;\n\t\tpm_runtime_disable(dev);\n\n\t\tif (device_may_wakeup(dev)) {\n\t\t\tif (enable_irq_wake(tegra->padctl_irq))\n\t\t\t\tdev_err(dev, \"failed to enable padctl wakes\\n\");\n\t\t}\n\t}\n\n\tmutex_unlock(&tegra->lock);\n\n\treturn err;\n}\n\nstatic __maybe_unused int tegra_xusb_resume(struct device *dev)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&tegra->lock);\n\n\tif (!tegra->suspended) {\n\t\tmutex_unlock(&tegra->lock);\n\t\treturn 0;\n\t}\n\n\terr = tegra_xusb_exit_elpg(tegra, false);\n\tif (err < 0) {\n\t\tmutex_unlock(&tegra->lock);\n\t\treturn err;\n\t}\n\n\tif (device_may_wakeup(dev)) {\n\t\tif (disable_irq_wake(tegra->padctl_irq))\n\t\t\tdev_err(dev, \"failed to disable padctl wakes\\n\");\n\t}\n\ttegra->suspended = false;\n\tmutex_unlock(&tegra->lock);\n\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic __maybe_unused int tegra_xusb_runtime_suspend(struct device *dev)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(dev);\n\tint ret;\n\n\tsynchronize_irq(tegra->mbox_irq);\n\tmutex_lock(&tegra->lock);\n\tret = tegra_xusb_enter_elpg(tegra, true);\n\tmutex_unlock(&tegra->lock);\n\n\treturn ret;\n}\n\nstatic __maybe_unused int tegra_xusb_runtime_resume(struct device *dev)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(dev);\n\tint err;\n\n\tmutex_lock(&tegra->lock);\n\terr = tegra_xusb_exit_elpg(tegra, true);\n\tmutex_unlock(&tegra->lock);\n\n\treturn err;\n}\n\nstatic const struct dev_pm_ops tegra_xusb_pm_ops = {\n\tSET_RUNTIME_PM_OPS(tegra_xusb_runtime_suspend,\n\t\t\t   tegra_xusb_runtime_resume, NULL)\n\tSET_SYSTEM_SLEEP_PM_OPS(tegra_xusb_suspend, tegra_xusb_resume)\n};\n\nstatic const char * const tegra124_supply_names[] = {\n\t\"avddio-pex\",\n\t\"dvddio-pex\",\n\t\"avdd-usb\",\n\t\"hvdd-usb-ss\",\n};\n\nstatic const struct tegra_xusb_phy_type tegra124_phy_types[] = {\n\t{ .name = \"usb3\", .num = 2, },\n\t{ .name = \"usb2\", .num = 3, },\n\t{ .name = \"hsic\", .num = 2, },\n};\n\nstatic const unsigned int tegra124_xusb_context_ipfs[] = {\n\tIPFS_XUSB_HOST_MSI_BAR_SZ_0,\n\tIPFS_XUSB_HOST_MSI_AXI_BAR_ST_0,\n\tIPFS_XUSB_HOST_MSI_FPCI_BAR_ST_0,\n\tIPFS_XUSB_HOST_MSI_VEC0_0,\n\tIPFS_XUSB_HOST_MSI_EN_VEC0_0,\n\tIPFS_XUSB_HOST_FPCI_ERROR_MASKS_0,\n\tIPFS_XUSB_HOST_INTR_MASK_0,\n\tIPFS_XUSB_HOST_INTR_ENABLE_0,\n\tIPFS_XUSB_HOST_UFPCI_CONFIG_0,\n\tIPFS_XUSB_HOST_CLKGATE_HYSTERESIS_0,\n\tIPFS_XUSB_HOST_MCCIF_FIFOCTRL_0,\n};\n\nstatic const unsigned int tegra124_xusb_context_fpci[] = {\n\tXUSB_CFG_ARU_CONTEXT_HS_PLS,\n\tXUSB_CFG_ARU_CONTEXT_FS_PLS,\n\tXUSB_CFG_ARU_CONTEXT_HSFS_SPEED,\n\tXUSB_CFG_ARU_CONTEXT_HSFS_PP,\n\tXUSB_CFG_ARU_CONTEXT,\n\tXUSB_CFG_AXI_CFG,\n\tXUSB_CFG_24,\n\tXUSB_CFG_16,\n};\n\nstatic const struct tegra_xusb_context_soc tegra124_xusb_context = {\n\t.ipfs = {\n\t\t.num_offsets = ARRAY_SIZE(tegra124_xusb_context_ipfs),\n\t\t.offsets = tegra124_xusb_context_ipfs,\n\t},\n\t.fpci = {\n\t\t.num_offsets = ARRAY_SIZE(tegra124_xusb_context_fpci),\n\t\t.offsets = tegra124_xusb_context_fpci,\n\t},\n};\n\nstatic const struct tegra_xusb_soc_ops tegra124_ops = {\n\t.mbox_reg_readl = &fpci_readl,\n\t.mbox_reg_writel = &fpci_writel,\n\t.csb_reg_readl = &fpci_csb_readl,\n\t.csb_reg_writel = &fpci_csb_writel,\n};\n\nstatic const struct tegra_xusb_soc tegra124_soc = {\n\t.firmware = \"nvidia/tegra124/xusb.bin\",\n\t.supply_names = tegra124_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra124_supply_names),\n\t.phy_types = tegra124_phy_types,\n\t.num_types = ARRAY_SIZE(tegra124_phy_types),\n\t.context = &tegra124_xusb_context,\n\t.ports = {\n\t\t.usb2 = { .offset = 4, .count = 4, },\n\t\t.hsic = { .offset = 6, .count = 2, },\n\t\t.usb3 = { .offset = 0, .count = 2, },\n\t},\n\t.scale_ss_clock = true,\n\t.has_ipfs = true,\n\t.otg_reset_sspi = false,\n\t.ops = &tegra124_ops,\n\t.mbox = {\n\t\t.cmd = 0xe4,\n\t\t.data_in = 0xe8,\n\t\t.data_out = 0xec,\n\t\t.owner = 0xf0,\n\t\t.smi_intr = XUSB_CFG_ARU_SMI_INTR,\n\t},\n};\nMODULE_FIRMWARE(\"nvidia/tegra124/xusb.bin\");\n\nstatic const char * const tegra210_supply_names[] = {\n\t\"dvddio-pex\",\n\t\"hvddio-pex\",\n\t\"avdd-usb\",\n};\n\nstatic const struct tegra_xusb_phy_type tegra210_phy_types[] = {\n\t{ .name = \"usb3\", .num = 4, },\n\t{ .name = \"usb2\", .num = 4, },\n\t{ .name = \"hsic\", .num = 1, },\n};\n\nstatic const struct tegra_xusb_soc tegra210_soc = {\n\t.firmware = \"nvidia/tegra210/xusb.bin\",\n\t.supply_names = tegra210_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra210_supply_names),\n\t.phy_types = tegra210_phy_types,\n\t.num_types = ARRAY_SIZE(tegra210_phy_types),\n\t.context = &tegra124_xusb_context,\n\t.ports = {\n\t\t.usb2 = { .offset = 4, .count = 4, },\n\t\t.hsic = { .offset = 8, .count = 1, },\n\t\t.usb3 = { .offset = 0, .count = 4, },\n\t},\n\t.scale_ss_clock = false,\n\t.has_ipfs = true,\n\t.otg_reset_sspi = true,\n\t.ops = &tegra124_ops,\n\t.mbox = {\n\t\t.cmd = 0xe4,\n\t\t.data_in = 0xe8,\n\t\t.data_out = 0xec,\n\t\t.owner = 0xf0,\n\t\t.smi_intr = XUSB_CFG_ARU_SMI_INTR,\n\t},\n};\nMODULE_FIRMWARE(\"nvidia/tegra210/xusb.bin\");\n\nstatic const char * const tegra186_supply_names[] = {\n};\nMODULE_FIRMWARE(\"nvidia/tegra186/xusb.bin\");\n\nstatic const struct tegra_xusb_phy_type tegra186_phy_types[] = {\n\t{ .name = \"usb3\", .num = 3, },\n\t{ .name = \"usb2\", .num = 3, },\n\t{ .name = \"hsic\", .num = 1, },\n};\n\nstatic const struct tegra_xusb_context_soc tegra186_xusb_context = {\n\t.fpci = {\n\t\t.num_offsets = ARRAY_SIZE(tegra124_xusb_context_fpci),\n\t\t.offsets = tegra124_xusb_context_fpci,\n\t},\n};\n\nstatic const struct tegra_xusb_soc tegra186_soc = {\n\t.firmware = \"nvidia/tegra186/xusb.bin\",\n\t.supply_names = tegra186_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra186_supply_names),\n\t.phy_types = tegra186_phy_types,\n\t.num_types = ARRAY_SIZE(tegra186_phy_types),\n\t.context = &tegra186_xusb_context,\n\t.ports = {\n\t\t.usb3 = { .offset = 0, .count = 3, },\n\t\t.usb2 = { .offset = 3, .count = 3, },\n\t\t.hsic = { .offset = 6, .count = 1, },\n\t},\n\t.scale_ss_clock = false,\n\t.has_ipfs = false,\n\t.otg_reset_sspi = false,\n\t.ops = &tegra124_ops,\n\t.mbox = {\n\t\t.cmd = 0xe4,\n\t\t.data_in = 0xe8,\n\t\t.data_out = 0xec,\n\t\t.owner = 0xf0,\n\t\t.smi_intr = XUSB_CFG_ARU_SMI_INTR,\n\t},\n\t.lpm_support = true,\n};\n\nstatic const char * const tegra194_supply_names[] = {\n};\n\nstatic const struct tegra_xusb_phy_type tegra194_phy_types[] = {\n\t{ .name = \"usb3\", .num = 4, },\n\t{ .name = \"usb2\", .num = 4, },\n};\n\nstatic const struct tegra_xusb_soc tegra194_soc = {\n\t.firmware = \"nvidia/tegra194/xusb.bin\",\n\t.supply_names = tegra194_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra194_supply_names),\n\t.phy_types = tegra194_phy_types,\n\t.num_types = ARRAY_SIZE(tegra194_phy_types),\n\t.context = &tegra186_xusb_context,\n\t.ports = {\n\t\t.usb3 = { .offset = 0, .count = 4, },\n\t\t.usb2 = { .offset = 4, .count = 4, },\n\t},\n\t.scale_ss_clock = false,\n\t.has_ipfs = false,\n\t.otg_reset_sspi = false,\n\t.ops = &tegra124_ops,\n\t.mbox = {\n\t\t.cmd = 0x68,\n\t\t.data_in = 0x6c,\n\t\t.data_out = 0x70,\n\t\t.owner = 0x74,\n\t\t.smi_intr = XUSB_CFG_ARU_SMI_INTR,\n\t},\n\t.lpm_support = true,\n};\nMODULE_FIRMWARE(\"nvidia/tegra194/xusb.bin\");\n\nstatic const struct tegra_xusb_soc_ops tegra234_ops = {\n\t.mbox_reg_readl = &bar2_readl,\n\t.mbox_reg_writel = &bar2_writel,\n\t.csb_reg_readl = &bar2_csb_readl,\n\t.csb_reg_writel = &bar2_csb_writel,\n};\n\nstatic const struct tegra_xusb_soc tegra234_soc = {\n\t.supply_names = tegra194_supply_names,\n\t.num_supplies = ARRAY_SIZE(tegra194_supply_names),\n\t.phy_types = tegra194_phy_types,\n\t.num_types = ARRAY_SIZE(tegra194_phy_types),\n\t.context = &tegra186_xusb_context,\n\t.ports = {\n\t\t.usb3 = { .offset = 0, .count = 4, },\n\t\t.usb2 = { .offset = 4, .count = 4, },\n\t},\n\t.scale_ss_clock = false,\n\t.has_ipfs = false,\n\t.otg_reset_sspi = false,\n\t.ops = &tegra234_ops,\n\t.mbox = {\n\t\t.cmd = XUSB_BAR2_ARU_MBOX_CMD,\n\t\t.data_in = XUSB_BAR2_ARU_MBOX_DATA_IN,\n\t\t.data_out = XUSB_BAR2_ARU_MBOX_DATA_OUT,\n\t\t.owner = XUSB_BAR2_ARU_MBOX_OWNER,\n\t\t.smi_intr = XUSB_BAR2_ARU_SMI_INTR,\n\t},\n\t.lpm_support = true,\n\t.has_bar2 = true,\n};\n\nstatic const struct of_device_id tegra_xusb_of_match[] = {\n\t{ .compatible = \"nvidia,tegra124-xusb\", .data = &tegra124_soc },\n\t{ .compatible = \"nvidia,tegra210-xusb\", .data = &tegra210_soc },\n\t{ .compatible = \"nvidia,tegra186-xusb\", .data = &tegra186_soc },\n\t{ .compatible = \"nvidia,tegra194-xusb\", .data = &tegra194_soc },\n\t{ .compatible = \"nvidia,tegra234-xusb\", .data = &tegra234_soc },\n\t{ },\n};\nMODULE_DEVICE_TABLE(of, tegra_xusb_of_match);\n\nstatic struct platform_driver tegra_xusb_driver = {\n\t.probe = tegra_xusb_probe,\n\t.remove_new = tegra_xusb_remove,\n\t.shutdown = tegra_xusb_shutdown,\n\t.driver = {\n\t\t.name = \"tegra-xusb\",\n\t\t.pm = &tegra_xusb_pm_ops,\n\t\t.of_match_table = tegra_xusb_of_match,\n\t},\n};\n\nstatic void tegra_xhci_quirks(struct device *dev, struct xhci_hcd *xhci)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(dev);\n\n\tif (tegra && tegra->soc->lpm_support)\n\t\txhci->quirks |= XHCI_LPM_SUPPORT;\n}\n\nstatic int tegra_xhci_setup(struct usb_hcd *hcd)\n{\n\treturn xhci_gen_setup(hcd, tegra_xhci_quirks);\n}\n\nstatic int tegra_xhci_hub_control(struct usb_hcd *hcd, u16 type_req, u16 value, u16 index,\n\t\t\t\t  char *buf, u16 length)\n{\n\tstruct tegra_xusb *tegra = dev_get_drvdata(hcd->self.controller);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct xhci_hub *rhub;\n\tstruct xhci_bus_state *bus_state;\n\tint port = (index & 0xff) - 1;\n\tunsigned int i;\n\tstruct xhci_port **ports;\n\tu32 portsc;\n\tint ret;\n\tstruct phy *phy;\n\n\trhub = &xhci->usb2_rhub;\n\tbus_state = &rhub->bus_state;\n\tif (bus_state->resuming_ports && hcd->speed == HCD_USB2) {\n\t\tports = rhub->ports;\n\t\ti = rhub->num_ports;\n\t\twhile (i--) {\n\t\t\tif (!test_bit(i, &bus_state->resuming_ports))\n\t\t\t\tcontinue;\n\t\t\tportsc = readl(ports[i]->addr);\n\t\t\tif ((portsc & PORT_PLS_MASK) == XDEV_RESUME)\n\t\t\t\ttegra_phy_xusb_utmi_pad_power_on(\n\t\t\t\t\ttegra_xusb_get_phy(tegra, \"usb2\", (int) i));\n\t\t}\n\t}\n\n\tif (hcd->speed == HCD_USB2) {\n\t\tphy = tegra_xusb_get_phy(tegra, \"usb2\", port);\n\t\tif ((type_req == ClearPortFeature) && (value == USB_PORT_FEAT_SUSPEND)) {\n\t\t\tif (!index || index > rhub->num_ports)\n\t\t\t\treturn -EPIPE;\n\t\t\ttegra_phy_xusb_utmi_pad_power_on(phy);\n\t\t}\n\t\tif ((type_req == SetPortFeature) && (value == USB_PORT_FEAT_RESET)) {\n\t\t\tif (!index || index > rhub->num_ports)\n\t\t\t\treturn -EPIPE;\n\t\t\tports = rhub->ports;\n\t\t\tportsc = readl(ports[port]->addr);\n\t\t\tif (portsc & PORT_CONNECT)\n\t\t\t\ttegra_phy_xusb_utmi_pad_power_on(phy);\n\t\t}\n\t}\n\n\tret = xhci_hub_control(hcd, type_req, value, index, buf, length);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (hcd->speed == HCD_USB2) {\n\t\t \n\t\tif ((type_req == SetPortFeature) && (value == USB_PORT_FEAT_SUSPEND))\n\t\t\t \n\t\t\tif (!((hcd->self.otg_port == (port + 1)) && hcd->self.b_hnp_enable))\n\t\t\t\ttegra_phy_xusb_utmi_pad_power_down(phy);\n\n\t\tif ((type_req == ClearPortFeature) && (value == USB_PORT_FEAT_C_CONNECTION)) {\n\t\t\tports = rhub->ports;\n\t\t\tportsc = readl(ports[port]->addr);\n\t\t\tif (!(portsc & PORT_CONNECT)) {\n\t\t\t\t \n\t\t\t\tif (!((hcd->self.otg_port == (port + 1)) && hcd->self.b_hnp_enable))\n\t\t\t\t\ttegra_phy_xusb_utmi_pad_power_down(phy);\n\t\t\t}\n\t\t}\n\t\tif ((type_req == SetPortFeature) && (value == USB_PORT_FEAT_TEST))\n\t\t\ttegra_phy_xusb_utmi_pad_power_on(phy);\n\t}\n\n\treturn ret;\n}\n\nstatic const struct xhci_driver_overrides tegra_xhci_overrides __initconst = {\n\t.reset = tegra_xhci_setup,\n\t.hub_control = tegra_xhci_hub_control,\n};\n\nstatic int __init tegra_xusb_init(void)\n{\n\txhci_init_driver(&tegra_xhci_hc_driver, &tegra_xhci_overrides);\n\n\treturn platform_driver_register(&tegra_xusb_driver);\n}\nmodule_init(tegra_xusb_init);\n\nstatic void __exit tegra_xusb_exit(void)\n{\n\tplatform_driver_unregister(&tegra_xusb_driver);\n}\nmodule_exit(tegra_xusb_exit);\n\nMODULE_AUTHOR(\"Andrew Bresticker <abrestic@chromium.org>\");\nMODULE_DESCRIPTION(\"NVIDIA Tegra XUSB xHCI host-controller driver\");\nMODULE_LICENSE(\"GPL v2\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}