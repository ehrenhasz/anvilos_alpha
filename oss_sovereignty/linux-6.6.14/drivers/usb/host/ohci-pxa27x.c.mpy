{
  "module_name": "ohci-pxa27x.c",
  "hash_id": "3ed4ca89eb83dcb5a4ba2fdd5618ecb471a4b309d20cd20f42cf4f06b72bd93d",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-pxa27x.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/device.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of_platform.h>\n#include <linux/of_gpio.h>\n#include <linux/platform_data/usb-ohci-pxa27x.h>\n#include <linux/platform_data/pxa2xx_udc.h>\n#include <linux/platform_device.h>\n#include <linux/regulator/consumer.h>\n#include <linux/signal.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/soc/pxa/cpu.h>\n\n#include \"ohci.h\"\n\n#define DRIVER_DESC \"OHCI PXA27x/PXA3x driver\"\n\n \n#define UHCREV\t\t(0x0000)  \n#define UHCHCON\t\t(0x0004)  \n#define UHCCOMS\t\t(0x0008)  \n#define UHCINTS\t\t(0x000C)  \n#define UHCINTE\t\t(0x0010)  \n#define UHCINTD\t\t(0x0014)  \n#define UHCHCCA\t\t(0x0018)  \n#define UHCPCED\t\t(0x001C)  \n#define UHCCHED\t\t(0x0020)  \n#define UHCCCED\t\t(0x0024)  \n#define UHCBHED\t\t(0x0028)  \n#define UHCBCED\t\t(0x002C)  \n#define UHCDHEAD\t(0x0030)  \n#define UHCFMI\t\t(0x0034)  \n#define UHCFMR\t\t(0x0038)  \n#define UHCFMN\t\t(0x003C)  \n#define UHCPERS\t\t(0x0040)  \n#define UHCLS\t\t(0x0044)  \n\n#define UHCRHDA\t\t(0x0048)  \n#define UHCRHDA_NOCP\t(1 << 12)\t \n#define UHCRHDA_OCPM\t(1 << 11)\t \n#define UHCRHDA_POTPGT(x) \\\n\t\t\t(((x) & 0xff) << 24)  \n\n#define UHCRHDB\t\t(0x004C)  \n#define UHCRHS\t\t(0x0050)  \n#define UHCRHPS1\t(0x0054)  \n#define UHCRHPS2\t(0x0058)  \n#define UHCRHPS3\t(0x005C)  \n\n#define UHCSTAT\t\t(0x0060)  \n#define UHCSTAT_UPS3\t(1 << 16)\t \n#define UHCSTAT_SBMAI\t(1 << 15)\t \n#define UHCSTAT_SBTAI\t(1 << 14)\t \n#define UHCSTAT_UPRI\t(1 << 13)\t \n#define UHCSTAT_UPS2\t(1 << 12)\t \n#define UHCSTAT_UPS1\t(1 << 11)\t \n#define UHCSTAT_HTA\t(1 << 10)\t \n#define UHCSTAT_HBA\t(1 << 8)\t \n#define UHCSTAT_RWUE\t(1 << 7)\t \n\n#define UHCHR           (0x0064)  \n#define UHCHR_SSEP3\t(1 << 11)\t \n#define UHCHR_SSEP2\t(1 << 10)\t \n#define UHCHR_SSEP1\t(1 << 9)\t \n#define UHCHR_PCPL\t(1 << 7)\t \n#define UHCHR_PSPL\t(1 << 6)\t \n#define UHCHR_SSE\t(1 << 5)\t \n#define UHCHR_UIT\t(1 << 4)\t \n#define UHCHR_SSDC\t(1 << 3)\t \n#define UHCHR_CGR\t(1 << 2)\t \n#define UHCHR_FHR\t(1 << 1)\t \n#define UHCHR_FSBIR\t(1 << 0)\t \n\n#define UHCHIE          (0x0068)  \n#define UHCHIE_UPS3IE\t(1 << 14)\t \n#define UHCHIE_UPRIE\t(1 << 13)\t \n#define UHCHIE_UPS2IE\t(1 << 12)\t \n#define UHCHIE_UPS1IE\t(1 << 11)\t \n#define UHCHIE_TAIE\t(1 << 10)\t \n#define UHCHIE_HBAIE\t(1 << 8)\t \n#define UHCHIE_RWIE\t(1 << 7)\t \n\n#define UHCHIT          (0x006C)  \n\n#define PXA_UHC_MAX_PORTNUM    3\n\nstatic struct hc_driver __read_mostly ohci_pxa27x_hc_driver;\n\nstruct pxa27x_ohci {\n\tstruct clk\t*clk;\n\tvoid __iomem\t*mmio_base;\n\tstruct regulator *vbus[3];\n\tbool\t\tvbus_enabled[3];\n};\n\n#define to_pxa27x_ohci(hcd)\t(struct pxa27x_ohci *)(hcd_to_ohci(hcd)->priv)\n\n \nstatic int pxa27x_ohci_select_pmm(struct pxa27x_ohci *pxa_ohci, int mode)\n{\n\tuint32_t uhcrhda = __raw_readl(pxa_ohci->mmio_base + UHCRHDA);\n\tuint32_t uhcrhdb = __raw_readl(pxa_ohci->mmio_base + UHCRHDB);\n\n\tswitch (mode) {\n\tcase PMM_NPS_MODE:\n\t\tuhcrhda |= RH_A_NPS;\n\t\tbreak;\n\tcase PMM_GLOBAL_MODE:\n\t\tuhcrhda &= ~(RH_A_NPS | RH_A_PSM);\n\t\tbreak;\n\tcase PMM_PERPORT_MODE:\n\t\tuhcrhda &= ~(RH_A_NPS);\n\t\tuhcrhda |= RH_A_PSM;\n\n\t\t \n\t\tuhcrhdb |= (0x7<<17);\n\t\tbreak;\n\tdefault:\n\t\tprintk( KERN_ERR\n\t\t\t\"Invalid mode %d, set to non-power switch mode.\\n\",\n\t\t\tmode );\n\n\t\tuhcrhda |= RH_A_NPS;\n\t}\n\n\t__raw_writel(uhcrhda, pxa_ohci->mmio_base + UHCRHDA);\n\t__raw_writel(uhcrhdb, pxa_ohci->mmio_base + UHCRHDB);\n\treturn 0;\n}\n\nstatic int pxa27x_ohci_set_vbus_power(struct pxa27x_ohci *pxa_ohci,\n\t\t\t\t      unsigned int port, bool enable)\n{\n\tstruct regulator *vbus = pxa_ohci->vbus[port];\n\tint ret = 0;\n\n\tif (IS_ERR_OR_NULL(vbus))\n\t\treturn 0;\n\n\tif (enable && !pxa_ohci->vbus_enabled[port])\n\t\tret = regulator_enable(vbus);\n\telse if (!enable && pxa_ohci->vbus_enabled[port])\n\t\tret = regulator_disable(vbus);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\tpxa_ohci->vbus_enabled[port] = enable;\n\n\treturn 0;\n}\n\nstatic int pxa27x_ohci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t\t   u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\n\tint ret;\n\n\tswitch (typeReq) {\n\tcase SetPortFeature:\n\tcase ClearPortFeature:\n\t\tif (!wIndex || wIndex > 3)\n\t\t\treturn -EPIPE;\n\n\t\tif (wValue != USB_PORT_FEAT_POWER)\n\t\t\tbreak;\n\n\t\tret = pxa27x_ohci_set_vbus_power(pxa_ohci, wIndex - 1,\n\t\t\t\t\t\t typeReq == SetPortFeature);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\treturn ohci_hub_control(hcd, typeReq, wValue, wIndex, buf, wLength);\n}\n \n\nstatic inline void pxa27x_setup_hc(struct pxa27x_ohci *pxa_ohci,\n\t\t\t\t   struct pxaohci_platform_data *inf)\n{\n\tuint32_t uhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR);\n\tuint32_t uhcrhda = __raw_readl(pxa_ohci->mmio_base + UHCRHDA);\n\n\tif (inf->flags & ENABLE_PORT1)\n\t\tuhchr &= ~UHCHR_SSEP1;\n\n\tif (inf->flags & ENABLE_PORT2)\n\t\tuhchr &= ~UHCHR_SSEP2;\n\n\tif (inf->flags & ENABLE_PORT3)\n\t\tuhchr &= ~UHCHR_SSEP3;\n\n\tif (inf->flags & POWER_CONTROL_LOW)\n\t\tuhchr |= UHCHR_PCPL;\n\n\tif (inf->flags & POWER_SENSE_LOW)\n\t\tuhchr |= UHCHR_PSPL;\n\n\tif (inf->flags & NO_OC_PROTECTION)\n\t\tuhcrhda |= UHCRHDA_NOCP;\n\telse\n\t\tuhcrhda &= ~UHCRHDA_NOCP;\n\n\tif (inf->flags & OC_MODE_PERPORT)\n\t\tuhcrhda |= UHCRHDA_OCPM;\n\telse\n\t\tuhcrhda &= ~UHCRHDA_OCPM;\n\n\tif (inf->power_on_delay) {\n\t\tuhcrhda &= ~UHCRHDA_POTPGT(0xff);\n\t\tuhcrhda |= UHCRHDA_POTPGT(inf->power_on_delay / 2);\n\t}\n\n\t__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\n\t__raw_writel(uhcrhda, pxa_ohci->mmio_base + UHCRHDA);\n}\n\nstatic inline void pxa27x_reset_hc(struct pxa27x_ohci *pxa_ohci)\n{\n\tuint32_t uhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR);\n\n\t__raw_writel(uhchr | UHCHR_FHR, pxa_ohci->mmio_base + UHCHR);\n\tudelay(11);\n\t__raw_writel(uhchr & ~UHCHR_FHR, pxa_ohci->mmio_base + UHCHR);\n}\n\nstatic int pxa27x_start_hc(struct pxa27x_ohci *pxa_ohci, struct device *dev)\n{\n\tint retval;\n\tstruct pxaohci_platform_data *inf;\n\tuint32_t uhchr;\n\n\tinf = dev_get_platdata(dev);\n\n\tretval = clk_prepare_enable(pxa_ohci->clk);\n\tif (retval)\n\t\treturn retval;\n\n\tpxa27x_reset_hc(pxa_ohci);\n\n\tuhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR) | UHCHR_FSBIR;\n\t__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\n\n\twhile (__raw_readl(pxa_ohci->mmio_base + UHCHR) & UHCHR_FSBIR)\n\t\tcpu_relax();\n\n\tpxa27x_setup_hc(pxa_ohci, inf);\n\n\tif (inf->init)\n\t\tretval = inf->init(dev);\n\n\tif (retval < 0) {\n\t\tclk_disable_unprepare(pxa_ohci->clk);\n\t\treturn retval;\n\t}\n\n\tuhchr = __raw_readl(pxa_ohci->mmio_base + UHCHR) & ~UHCHR_SSE;\n\t__raw_writel(uhchr, pxa_ohci->mmio_base + UHCHR);\n\t__raw_writel(UHCHIE_UPRIE | UHCHIE_RWIE, pxa_ohci->mmio_base + UHCHIE);\n\n\t \n\tpxa27x_clear_otgph();\n\treturn 0;\n}\n\nstatic void pxa27x_stop_hc(struct pxa27x_ohci *pxa_ohci, struct device *dev)\n{\n\tstruct pxaohci_platform_data *inf;\n\tuint32_t uhccoms;\n\n\tinf = dev_get_platdata(dev);\n\n\tif (inf->exit)\n\t\tinf->exit(dev);\n\n\tpxa27x_reset_hc(pxa_ohci);\n\n\t \n\tuhccoms = __raw_readl(pxa_ohci->mmio_base + UHCCOMS) | 0x01;\n\t__raw_writel(uhccoms, pxa_ohci->mmio_base + UHCCOMS);\n\tudelay(10);\n\n\tclk_disable_unprepare(pxa_ohci->clk);\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id pxa_ohci_dt_ids[] = {\n\t{ .compatible = \"marvell,pxa-ohci\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, pxa_ohci_dt_ids);\n\nstatic int ohci_pxa_of_init(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct pxaohci_platform_data *pdata;\n\tu32 tmp;\n\tint ret;\n\n\tif (!np)\n\t\treturn 0;\n\n\t \n\tret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tif (of_property_read_bool(np, \"marvell,enable-port1\"))\n\t\tpdata->flags |= ENABLE_PORT1;\n\tif (of_property_read_bool(np, \"marvell,enable-port2\"))\n\t\tpdata->flags |= ENABLE_PORT2;\n\tif (of_property_read_bool(np, \"marvell,enable-port3\"))\n\t\tpdata->flags |= ENABLE_PORT3;\n\tif (of_property_read_bool(np, \"marvell,port-sense-low\"))\n\t\tpdata->flags |= POWER_SENSE_LOW;\n\tif (of_property_read_bool(np, \"marvell,power-control-low\"))\n\t\tpdata->flags |= POWER_CONTROL_LOW;\n\tif (of_property_read_bool(np, \"marvell,no-oc-protection\"))\n\t\tpdata->flags |= NO_OC_PROTECTION;\n\tif (of_property_read_bool(np, \"marvell,oc-mode-perport\"))\n\t\tpdata->flags |= OC_MODE_PERPORT;\n\tif (!of_property_read_u32(np, \"marvell,power-on-delay\", &tmp))\n\t\tpdata->power_on_delay = tmp;\n\tif (!of_property_read_u32(np, \"marvell,port-mode\", &tmp))\n\t\tpdata->port_mode = tmp;\n\tif (!of_property_read_u32(np, \"marvell,power-budget\", &tmp))\n\t\tpdata->power_budget = tmp;\n\n\tpdev->dev.platform_data = pdata;\n\n\treturn 0;\n}\n#else\nstatic int ohci_pxa_of_init(struct platform_device *pdev)\n{\n\treturn 0;\n}\n#endif\n\n \n\n \n \n\n\n \nstatic int ohci_hcd_pxa27x_probe(struct platform_device *pdev)\n{\n\tint retval, irq;\n\tstruct usb_hcd *hcd;\n\tstruct pxaohci_platform_data *inf;\n\tstruct pxa27x_ohci *pxa_ohci;\n\tstruct ohci_hcd *ohci;\n\tstruct resource *r;\n\tstruct clk *usb_clk;\n\tunsigned int i;\n\n\tretval = ohci_pxa_of_init(pdev);\n\tif (retval)\n\t\treturn retval;\n\n\tinf = dev_get_platdata(&pdev->dev);\n\n\tif (!inf)\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tpr_err(\"no resource of IORESOURCE_IRQ\");\n\t\treturn irq;\n\t}\n\n\tusb_clk = devm_clk_get(&pdev->dev, NULL);\n\tif (IS_ERR(usb_clk))\n\t\treturn PTR_ERR(usb_clk);\n\n\thcd = usb_create_hcd(&ohci_pxa27x_hc_driver, &pdev->dev, \"pxa27x\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &r);\n\tif (IS_ERR(hcd->regs)) {\n\t\tretval = PTR_ERR(hcd->regs);\n\t\tgoto err;\n\t}\n\thcd->rsrc_start = r->start;\n\thcd->rsrc_len = resource_size(r);\n\n\t \n\tpxa_ohci = to_pxa27x_ohci(hcd);\n\tpxa_ohci->clk = usb_clk;\n\tpxa_ohci->mmio_base = (void __iomem *)hcd->regs;\n\n\tfor (i = 0; i < 3; ++i) {\n\t\tchar name[6];\n\n\t\tif (!(inf->flags & (ENABLE_PORT1 << i)))\n\t\t\tcontinue;\n\n\t\tsprintf(name, \"vbus%u\", i + 1);\n\t\tpxa_ohci->vbus[i] = devm_regulator_get(&pdev->dev, name);\n\t}\n\n\tretval = pxa27x_start_hc(pxa_ohci, &pdev->dev);\n\tif (retval < 0) {\n\t\tpr_debug(\"pxa27x_start_hc failed\");\n\t\tgoto err;\n\t}\n\n\t \n\tpxa27x_ohci_select_pmm(pxa_ohci, inf->port_mode);\n\n\tif (inf->power_budget)\n\t\thcd->power_budget = inf->power_budget;\n\n\t \n\tohci = hcd_to_ohci(hcd);\n\tohci->num_ports = 3;\n\n\tretval = usb_add_hcd(hcd, irq, 0);\n\tif (retval == 0) {\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t\treturn retval;\n\t}\n\n\tpxa27x_stop_hc(pxa_ohci, &pdev->dev);\n err:\n\tusb_put_hcd(hcd);\n\treturn retval;\n}\n\n\n \n \n\n \nstatic void ohci_hcd_pxa27x_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\n\tunsigned int i;\n\n\tusb_remove_hcd(hcd);\n\tpxa27x_stop_hc(pxa_ohci, &pdev->dev);\n\n\tfor (i = 0; i < 3; ++i)\n\t\tpxa27x_ohci_set_vbus_power(pxa_ohci, i, false);\n\n\tusb_put_hcd(hcd);\n}\n\n \n\n#ifdef CONFIG_PM\nstatic int ohci_hcd_pxa27x_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\n\tstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint ret;\n\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tret = ohci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tpxa27x_stop_hc(pxa_ohci, dev);\n\treturn ret;\n}\n\nstatic int ohci_hcd_pxa27x_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct pxa27x_ohci *pxa_ohci = to_pxa27x_ohci(hcd);\n\tstruct pxaohci_platform_data *inf = dev_get_platdata(dev);\n\tstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\n\tint status;\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tstatus = pxa27x_start_hc(pxa_ohci, dev);\n\tif (status < 0)\n\t\treturn status;\n\n\t \n\tpxa27x_ohci_select_pmm(pxa_ohci, inf->port_mode);\n\n\tohci_resume(hcd, false);\n\treturn 0;\n}\n\nstatic const struct dev_pm_ops ohci_hcd_pxa27x_pm_ops = {\n\t.suspend\t= ohci_hcd_pxa27x_drv_suspend,\n\t.resume\t\t= ohci_hcd_pxa27x_drv_resume,\n};\n#endif\n\nstatic struct platform_driver ohci_hcd_pxa27x_driver = {\n\t.probe\t\t= ohci_hcd_pxa27x_probe,\n\t.remove_new\t= ohci_hcd_pxa27x_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"pxa27x-ohci\",\n\t\t.of_match_table = of_match_ptr(pxa_ohci_dt_ids),\n#ifdef CONFIG_PM\n\t\t.pm\t= &ohci_hcd_pxa27x_pm_ops,\n#endif\n\t},\n};\n\nstatic const struct ohci_driver_overrides pxa27x_overrides __initconst = {\n\t.extra_priv_size =      sizeof(struct pxa27x_ohci),\n};\n\nstatic int __init ohci_pxa27x_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_pxa27x_hc_driver, &pxa27x_overrides);\n\tohci_pxa27x_hc_driver.hub_control = pxa27x_ohci_hub_control;\n\n\treturn platform_driver_register(&ohci_hcd_pxa27x_driver);\n}\nmodule_init(ohci_pxa27x_init);\n\nstatic void __exit ohci_pxa27x_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_pxa27x_driver);\n}\nmodule_exit(ohci_pxa27x_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:pxa27x-ohci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}