{
  "module_name": "ehci-omap.c",
  "hash_id": "fb33693a351001040246acec9fea7e7c6eb84599f8847c75e46e07f3cfbd8f97",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-omap.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/io.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/usb/ulpi.h>\n#include <linux/pm_runtime.h>\n#include <linux/clk.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/of.h>\n#include <linux/dma-mapping.h>\n\n#include \"ehci.h\"\n\n#include <linux/platform_data/usb-omap.h>\n\n \n#define EHCI_INSNREG04\t\t\t\t\t(0xA0)\n#define EHCI_INSNREG04_DISABLE_UNSUSPEND\t\t(1 << 5)\n#define\tEHCI_INSNREG05_ULPI\t\t\t\t(0xA4)\n#define\tEHCI_INSNREG05_ULPI_CONTROL_SHIFT\t\t31\n#define\tEHCI_INSNREG05_ULPI_PORTSEL_SHIFT\t\t24\n#define\tEHCI_INSNREG05_ULPI_OPSEL_SHIFT\t\t\t22\n#define\tEHCI_INSNREG05_ULPI_REGADD_SHIFT\t\t16\n#define\tEHCI_INSNREG05_ULPI_EXTREGADD_SHIFT\t\t8\n#define\tEHCI_INSNREG05_ULPI_WRDATA_SHIFT\t\t0\n\n#define DRIVER_DESC \"OMAP-EHCI Host Controller driver\"\n\nstatic const char hcd_name[] = \"ehci-omap\";\n\n \n\nstruct omap_hcd {\n\tstruct usb_phy *phy[OMAP3_HS_USB_PORTS];  \n\tint nports;\n};\n\nstatic inline void ehci_write(void __iomem *base, u32 reg, u32 val)\n{\n\t__raw_writel(val, base + reg);\n}\n\n \n \n\nstatic struct hc_driver __read_mostly ehci_omap_hc_driver;\n\nstatic const struct ehci_driver_overrides ehci_omap_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct omap_hcd),\n};\n\n \nstatic int ehci_hcd_omap_probe(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usbhs_omap_platform_data *pdata = dev_get_platdata(dev);\n\tstruct resource\t*res;\n\tstruct usb_hcd\t*hcd;\n\tvoid __iomem *regs;\n\tint ret;\n\tint irq;\n\tint i;\n\tstruct omap_hcd\t*omap;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tif (!dev->parent) {\n\t\tdev_err(dev, \"Missing parent device\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\t \n\tif (dev->of_node) {\n\t\tpdata = dev_get_platdata(dev->parent);\n\t\tdev->platform_data = pdata;\n\t}\n\n\tif (!pdata) {\n\t\tdev_err(dev, \"Missing platform data\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\tregs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(regs))\n\t\treturn PTR_ERR(regs);\n\n\t \n\tret = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tret = -ENODEV;\n\thcd = usb_create_hcd(&ehci_omap_hc_driver, dev,\n\t\t\tdev_name(dev));\n\tif (!hcd) {\n\t\tdev_err(dev, \"Failed to create HCD\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\thcd->regs = regs;\n\thcd_to_ehci(hcd)->caps = regs;\n\n\tomap = (struct omap_hcd *)hcd_to_ehci(hcd)->priv;\n\tomap->nports = pdata->nports;\n\n\tplatform_set_drvdata(pdev, hcd);\n\n\t \n\tfor (i = 0 ; i < omap->nports ; i++) {\n\t\tstruct usb_phy *phy;\n\n\t\t \n\t\tphy = devm_usb_get_phy_by_phandle(dev, \"phys\", i);\n\t\tif (IS_ERR(phy)) {\n\t\t\tret = PTR_ERR(phy);\n\t\t\tif (ret == -ENODEV) {  \n\t\t\t\tphy = NULL;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ret != -EPROBE_DEFER)\n\t\t\t\tdev_err(dev, \"Can't get PHY for port %d: %d\\n\",\n\t\t\t\t\ti, ret);\n\t\t\tgoto err_phy;\n\t\t}\n\n\t\tomap->phy[i] = phy;\n\n\t\tif (pdata->port_mode[i] == OMAP_EHCI_PORT_MODE_PHY) {\n\t\t\tusb_phy_init(omap->phy[i]);\n\t\t\t \n\t\t\tusb_phy_set_suspend(omap->phy[i], 0);\n\t\t}\n\t}\n\n\tpm_runtime_enable(dev);\n\tpm_runtime_get_sync(dev);\n\n\t \n\tehci_write(regs, EHCI_INSNREG04,\n\t\t\t\tEHCI_INSNREG04_DISABLE_UNSUSPEND);\n\n\tret = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (ret) {\n\t\tdev_err(dev, \"failed to add hcd with err %d\\n\", ret);\n\t\tgoto err_pm_runtime;\n\t}\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\t \n\tfor (i = 0; i < omap->nports; i++) {\n\t\tif (!omap->phy[i] ||\n\t\t     pdata->port_mode[i] == OMAP_EHCI_PORT_MODE_PHY)\n\t\t\tcontinue;\n\n\t\tusb_phy_init(omap->phy[i]);\n\t\t \n\t\tusb_phy_set_suspend(omap->phy[i], 0);\n\t}\n\n\treturn 0;\n\nerr_pm_runtime:\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n\nerr_phy:\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tif (omap->phy[i])\n\t\t\tusb_phy_shutdown(omap->phy[i]);\n\t}\n\n\tusb_put_hcd(hcd);\n\n\treturn ret;\n}\n\n\n \nstatic void ehci_hcd_omap_remove(struct platform_device *pdev)\n{\n\tstruct device *dev = &pdev->dev;\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct omap_hcd *omap = (struct omap_hcd *)hcd_to_ehci(hcd)->priv;\n\tint i;\n\n\tusb_remove_hcd(hcd);\n\n\tfor (i = 0; i < omap->nports; i++) {\n\t\tif (omap->phy[i])\n\t\t\tusb_phy_shutdown(omap->phy[i]);\n\t}\n\n\tusb_put_hcd(hcd);\n\tpm_runtime_put_sync(dev);\n\tpm_runtime_disable(dev);\n}\n\nstatic const struct of_device_id omap_ehci_dt_ids[] = {\n\t{ .compatible = \"ti,ehci-omap\" },\n\t{ }\n};\n\nMODULE_DEVICE_TABLE(of, omap_ehci_dt_ids);\n\nstatic struct platform_driver ehci_hcd_omap_driver = {\n\t.probe\t\t\t= ehci_hcd_omap_probe,\n\t.remove_new\t\t= ehci_hcd_omap_remove,\n\t.shutdown\t\t= usb_hcd_platform_shutdown,\n\t \n\t \n\t.driver = {\n\t\t.name\t\t= hcd_name,\n\t\t.of_match_table = omap_ehci_dt_ids,\n\t}\n};\n\n \n\nstatic int __init ehci_omap_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_omap_hc_driver, &ehci_omap_overrides);\n\treturn platform_driver_register(&ehci_hcd_omap_driver);\n}\nmodule_init(ehci_omap_init);\n\nstatic void __exit ehci_omap_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_hcd_omap_driver);\n}\nmodule_exit(ehci_omap_cleanup);\n\nMODULE_ALIAS(\"platform:ehci-omap\");\nMODULE_AUTHOR(\"Texas Instruments, Inc.\");\nMODULE_AUTHOR(\"Felipe Balbi <felipe.balbi@nokia.com>\");\nMODULE_AUTHOR(\"Roger Quadros <rogerq@ti.com>\");\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}