{
  "module_name": "ohci-platform.c",
  "hash_id": "aa82abbfc171757558d41a5c14089f800b1217de3c495a0a1fc15741fbbe07d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-platform.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/err.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/pm_runtime.h>\n#include <linux/reset.h>\n#include <linux/usb/ohci_pdriver.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/of.h>\n\n#include \"ohci.h\"\n\n#define DRIVER_DESC \"OHCI generic platform driver\"\n#define OHCI_MAX_CLKS 4\n#define hcd_to_ohci_priv(h) ((struct ohci_platform_priv *)hcd_to_ohci(h)->priv)\n\nstruct ohci_platform_priv {\n\tstruct clk *clks[OHCI_MAX_CLKS];\n\tstruct reset_control *resets;\n};\n\nstatic int ohci_platform_power_on(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\n\tint clk, ret;\n\n\tfor (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++) {\n\t\tret = clk_prepare_enable(priv->clks[clk]);\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\treturn 0;\n\nerr_disable_clks:\n\twhile (--clk >= 0)\n\t\tclk_disable_unprepare(priv->clks[clk]);\n\n\treturn ret;\n}\n\nstatic void ohci_platform_power_off(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\n\tint clk;\n\n\tfor (clk = OHCI_MAX_CLKS - 1; clk >= 0; clk--)\n\t\tif (priv->clks[clk])\n\t\t\tclk_disable_unprepare(priv->clks[clk]);\n}\n\nstatic struct hc_driver __read_mostly ohci_platform_hc_driver;\n\nstatic const struct ohci_driver_overrides platform_overrides __initconst = {\n\t.product_desc =\t\t\"Generic Platform OHCI controller\",\n\t.extra_priv_size =\tsizeof(struct ohci_platform_priv),\n};\n\nstatic struct usb_ohci_pdata ohci_platform_defaults = {\n\t.power_on =\t\tohci_platform_power_on,\n\t.power_suspend =\tohci_platform_power_off,\n\t.power_off =\t\tohci_platform_power_off,\n};\n\nstatic int ohci_platform_probe(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct resource *res_mem;\n\tstruct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);\n\tstruct ohci_platform_priv *priv;\n\tstruct ohci_hcd *ohci;\n\tint err, irq, clk = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t \n\tif (!pdata)\n\t\tpdata = &ohci_platform_defaults;\n\n\terr = dma_coerce_mask_and_coherent(&dev->dev, DMA_BIT_MASK(32));\n\tif (err)\n\t\treturn err;\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = usb_create_hcd(&ohci_platform_hc_driver, &dev->dev,\n\t\t\tdev_name(&dev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(dev, hcd);\n\tdev->dev.platform_data = pdata;\n\tpriv = hcd_to_ohci_priv(hcd);\n\tohci = hcd_to_ohci(hcd);\n\n\tif (pdata == &ohci_platform_defaults && dev->dev.of_node) {\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian-regs\"))\n\t\t\tohci->flags |= OHCI_QUIRK_BE_MMIO;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian-desc\"))\n\t\t\tohci->flags |= OHCI_QUIRK_BE_DESC;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"big-endian\"))\n\t\t\tohci->flags |= OHCI_QUIRK_BE_MMIO | OHCI_QUIRK_BE_DESC;\n\n\t\tif (of_property_read_bool(dev->dev.of_node, \"no-big-frame-no\"))\n\t\t\tohci->flags |= OHCI_QUIRK_FRAME_NO;\n\n\t\tif (of_property_read_bool(dev->dev.of_node,\n\t\t\t\t\t  \"remote-wakeup-connected\"))\n\t\t\tohci->hc_control = OHCI_CTRL_RWC;\n\n\t\tof_property_read_u32(dev->dev.of_node, \"num-ports\",\n\t\t\t\t     &ohci->num_ports);\n\n\t\tfor (clk = 0; clk < OHCI_MAX_CLKS; clk++) {\n\t\t\tpriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\n\t\t\tif (IS_ERR(priv->clks[clk])) {\n\t\t\t\terr = PTR_ERR(priv->clks[clk]);\n\t\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\t\tgoto err_put_clks;\n\t\t\t\tpriv->clks[clk] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpriv->resets = devm_reset_control_array_get_optional_shared(\n\t\t\t\t\t\t\t\t&dev->dev);\n\t\tif (IS_ERR(priv->resets)) {\n\t\t\terr = PTR_ERR(priv->resets);\n\t\t\tgoto err_put_clks;\n\t\t}\n\n\t\terr = reset_control_deassert(priv->resets);\n\t\tif (err)\n\t\t\tgoto err_put_clks;\n\t}\n\n\tif (pdata->big_endian_desc)\n\t\tohci->flags |= OHCI_QUIRK_BE_DESC;\n\tif (pdata->big_endian_mmio)\n\t\tohci->flags |= OHCI_QUIRK_BE_MMIO;\n\tif (pdata->no_big_frame_no)\n\t\tohci->flags |= OHCI_QUIRK_FRAME_NO;\n\tif (pdata->num_ports)\n\t\tohci->num_ports = pdata->num_ports;\n\n#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO\n\tif (ohci->flags & OHCI_QUIRK_BE_MMIO) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Error: CONFIG_USB_OHCI_BIG_ENDIAN_MMIO not set\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_reset;\n\t}\n#endif\n#ifndef CONFIG_USB_OHCI_BIG_ENDIAN_DESC\n\tif (ohci->flags & OHCI_QUIRK_BE_DESC) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Error: CONFIG_USB_OHCI_BIG_ENDIAN_DESC not set\\n\");\n\t\terr = -EINVAL;\n\t\tgoto err_reset;\n\t}\n#endif\n\n\tpm_runtime_set_active(&dev->dev);\n\tpm_runtime_enable(&dev->dev);\n\tif (pdata->power_on) {\n\t\terr = pdata->power_on(dev);\n\t\tif (err < 0)\n\t\t\tgoto err_reset;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(dev, 0, &res_mem);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto err_power;\n\t}\n\thcd->rsrc_start = res_mem->start;\n\thcd->rsrc_len = resource_size(res_mem);\n\n\thcd->tpl_support = of_usb_host_tpl_support(dev->dev.of_node);\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err)\n\t\tgoto err_power;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tplatform_set_drvdata(dev, hcd);\n\n\treturn err;\n\nerr_power:\n\tif (pdata->power_off)\n\t\tpdata->power_off(dev);\nerr_reset:\n\tpm_runtime_disable(&dev->dev);\n\treset_control_assert(priv->resets);\nerr_put_clks:\n\twhile (--clk >= 0)\n\t\tclk_put(priv->clks[clk]);\n\n\tif (pdata == &ohci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n\n\tusb_put_hcd(hcd);\n\n\treturn err;\n}\n\nstatic void ohci_platform_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct usb_ohci_pdata *pdata = dev_get_platdata(&dev->dev);\n\tstruct ohci_platform_priv *priv = hcd_to_ohci_priv(hcd);\n\tint clk;\n\n\tpm_runtime_get_sync(&dev->dev);\n\tusb_remove_hcd(hcd);\n\n\tif (pdata->power_off)\n\t\tpdata->power_off(dev);\n\n\treset_control_assert(priv->resets);\n\n\tfor (clk = 0; clk < OHCI_MAX_CLKS && priv->clks[clk]; clk++)\n\t\tclk_put(priv->clks[clk]);\n\n\tusb_put_hcd(hcd);\n\n\tpm_runtime_put_sync(&dev->dev);\n\tpm_runtime_disable(&dev->dev);\n\n\tif (pdata == &ohci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\nstatic int ohci_platform_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ohci_pdata *pdata = dev->platform_data;\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint ret;\n\n\tret = ohci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata->power_suspend)\n\t\tpdata->power_suspend(pdev);\n\n\treturn ret;\n}\n\nstatic int ohci_platform_resume_common(struct device *dev, bool hibernated)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ohci_pdata *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\n\tif (pdata->power_on) {\n\t\tint err = pdata->power_on(pdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tohci_resume(hcd, hibernated);\n\n\tpm_runtime_disable(dev);\n\tpm_runtime_set_active(dev);\n\tpm_runtime_enable(dev);\n\n\treturn 0;\n}\n\nstatic int ohci_platform_resume(struct device *dev)\n{\n\treturn ohci_platform_resume_common(dev, false);\n}\n\nstatic int ohci_platform_restore(struct device *dev)\n{\n\treturn ohci_platform_resume_common(dev, true);\n}\n#endif  \n\nstatic const struct of_device_id ohci_platform_ids[] = {\n\t{ .compatible = \"generic-ohci\", },\n\t{ .compatible = \"cavium,octeon-6335-ohci\", },\n\t{ .compatible = \"ti,ohci-omap3\", },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, ohci_platform_ids);\n\nstatic const struct platform_device_id ohci_platform_table[] = {\n\t{ \"ohci-platform\", 0 },\n\t{ }\n};\nMODULE_DEVICE_TABLE(platform, ohci_platform_table);\n\n#ifdef CONFIG_PM_SLEEP\nstatic const struct dev_pm_ops ohci_platform_pm_ops = {\n\t.suspend = ohci_platform_suspend,\n\t.resume = ohci_platform_resume,\n\t.freeze = ohci_platform_suspend,\n\t.thaw = ohci_platform_resume,\n\t.poweroff = ohci_platform_suspend,\n\t.restore = ohci_platform_restore,\n};\n#endif\n\nstatic struct platform_driver ohci_platform_driver = {\n\t.id_table\t= ohci_platform_table,\n\t.probe\t\t= ohci_platform_probe,\n\t.remove_new\t= ohci_platform_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"ohci-platform\",\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &ohci_platform_pm_ops,\n#endif\n\t\t.of_match_table = ohci_platform_ids,\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t}\n};\n\nstatic int __init ohci_platform_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_platform_hc_driver, &platform_overrides);\n\treturn platform_driver_register(&ohci_platform_driver);\n}\nmodule_init(ohci_platform_init);\n\nstatic void __exit ohci_platform_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_platform_driver);\n}\nmodule_exit(ohci_platform_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Hauke Mehrtens\");\nMODULE_AUTHOR(\"Alan Stern\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}