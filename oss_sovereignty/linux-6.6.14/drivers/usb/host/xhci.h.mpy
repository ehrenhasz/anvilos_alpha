{
  "module_name": "xhci.h",
  "hash_id": "783814b5d2f07db21b6a2b5d5776767d16379889fef45056dda57884591a298e",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci.h",
  "human_readable_source": " \n\n \n\n#ifndef __LINUX_XHCI_HCD_H\n#define __LINUX_XHCI_HCD_H\n\n#include <linux/usb.h>\n#include <linux/timer.h>\n#include <linux/kernel.h>\n#include <linux/usb/hcd.h>\n#include <linux/io-64-nonatomic-lo-hi.h>\n\n \n#include\t\"xhci-ext-caps.h\"\n#include \"pci-quirks.h\"\n\n \n#define XHCI_MSG_MAX\t\t500\n\n \n#define XHCI_SBRN_OFFSET\t(0x60)\n\n \n#define MAX_HC_SLOTS\t\t256\n \n#define MAX_HC_PORTS\t\t127\n\n \n\n \nstruct xhci_cap_regs {\n\t__le32\thc_capbase;\n\t__le32\thcs_params1;\n\t__le32\thcs_params2;\n\t__le32\thcs_params3;\n\t__le32\thcc_params;\n\t__le32\tdb_off;\n\t__le32\trun_regs_off;\n\t__le32\thcc_params2;  \n\t \n};\n\n \n \n#define HC_LENGTH(p)\t\tXHCI_HC_LENGTH(p)\n \n#define HC_VERSION(p)\t\t(((p) >> 16) & 0xffff)\n\n \n \n#define HCS_MAX_SLOTS(p)\t(((p) >> 0) & 0xff)\n#define HCS_SLOTS_MASK\t\t0xff\n \n#define HCS_MAX_INTRS(p)\t(((p) >> 8) & 0x7ff)\n \n#define HCS_MAX_PORTS(p)\t(((p) >> 24) & 0x7f)\n\n \n \n#define HCS_IST(p)\t\t(((p) >> 0) & 0xf)\n \n#define HCS_ERST_MAX(p)\t\t(((p) >> 4) & 0xf)\n \n \n \n#define HCS_MAX_SCRATCHPAD(p)   ((((p) >> 16) & 0x3e0) | (((p) >> 27) & 0x1f))\n\n \n \n#define HCS_U1_LATENCY(p)\t(((p) >> 0) & 0xff)\n \n#define HCS_U2_LATENCY(p)\t(((p) >> 16) & 0xffff)\n\n \n \n#define HCC_64BIT_ADDR(p)\t((p) & (1 << 0))\n \n#define HCC_BANDWIDTH_NEG(p)\t((p) & (1 << 1))\n \n#define HCC_64BYTE_CONTEXT(p)\t((p) & (1 << 2))\n \n#define HCC_PPC(p)\t\t((p) & (1 << 3))\n \n#define HCS_INDICATOR(p)\t((p) & (1 << 4))\n \n#define HCC_LIGHT_RESET(p)\t((p) & (1 << 5))\n \n#define HCC_LTC(p)\t\t((p) & (1 << 6))\n \n#define HCC_NSS(p)\t\t((p) & (1 << 7))\n \n#define HCC_SPC(p)\t\t((p) & (1 << 9))\n \n#define HCC_CFC(p)\t\t((p) & (1 << 11))\n \n#define HCC_MAX_PSA(p)\t\t(1 << ((((p) >> 12) & 0xf) + 1))\n \n#define HCC_EXT_CAPS(p)\t\tXHCI_HCC_EXT_CAPS(p)\n\n#define CTX_SIZE(_hcc)\t\t(HCC_64BYTE_CONTEXT(_hcc) ? 64 : 32)\n\n \n#define\tDBOFF_MASK\t(~0x3)\n\n \n#define\tRTSOFF_MASK\t(~0x1f)\n\n \n \n#define\tHCC2_U3C(p)\t\t((p) & (1 << 0))\n \n#define\tHCC2_CMC(p)\t\t((p) & (1 << 1))\n \n#define\tHCC2_FSC(p)\t\t((p) & (1 << 2))\n \n#define\tHCC2_CTC(p)\t\t((p) & (1 << 3))\n \n#define\tHCC2_LEC(p)\t\t((p) & (1 << 4))\n \n#define\tHCC2_CIC(p)\t\t((p) & (1 << 5))\n \n#define\tHCC2_ETC(p)\t\t((p) & (1 << 6))\n\n \n#define\tNUM_PORT_REGS\t4\n\n#define PORTSC\t\t0\n#define PORTPMSC\t1\n#define PORTLI\t\t2\n#define PORTHLPMC\t3\n\n \nstruct xhci_op_regs {\n\t__le32\tcommand;\n\t__le32\tstatus;\n\t__le32\tpage_size;\n\t__le32\treserved1;\n\t__le32\treserved2;\n\t__le32\tdev_notification;\n\t__le64\tcmd_ring;\n\t \n\t__le32\treserved3[4];\n\t__le64\tdcbaa_ptr;\n\t__le32\tconfig_reg;\n\t \n\t__le32\treserved4[241];\n\t \n\t__le32\tport_status_base;\n\t__le32\tport_power_base;\n\t__le32\tport_link_base;\n\t__le32\treserved5;\n\t \n\t__le32\treserved6[NUM_PORT_REGS*254];\n};\n\n \n \n#define CMD_RUN\t\tXHCI_CMD_RUN\n \n#define CMD_RESET\t(1 << 1)\n \n#define CMD_EIE\t\tXHCI_CMD_EIE\n \n#define CMD_HSEIE\tXHCI_CMD_HSEIE\n \n \n#define CMD_LRESET\t(1 << 7)\n \n#define CMD_CSS\t\t(1 << 8)\n#define CMD_CRS\t\t(1 << 9)\n \n#define CMD_EWE\t\tXHCI_CMD_EWE\n \n#define CMD_PM_INDEX\t(1 << 11)\n \n#define CMD_ETE\t\t(1 << 14)\n \n\n#define XHCI_RESET_LONG_USEC\t\t(10 * 1000 * 1000)\n#define XHCI_RESET_SHORT_USEC\t\t(250 * 1000)\n\n \n#define IMAN_IE\t\t(1 << 1)\n#define IMAN_IP\t\t(1 << 0)\n\n \n \n#define STS_HALT\tXHCI_STS_HALT\n \n#define STS_FATAL\t(1 << 2)\n \n#define STS_EINT\t(1 << 3)\n \n#define STS_PORT\t(1 << 4)\n \n \n#define STS_SAVE\t(1 << 8)\n \n#define STS_RESTORE\t(1 << 9)\n \n#define STS_SRE\t\t(1 << 10)\n \n#define STS_CNR\t\tXHCI_STS_CNR\n \n#define STS_HCE\t\t(1 << 12)\n \n\n \n#define\tDEV_NOTE_MASK\t\t(0xffff)\n#define ENABLE_DEV_NOTE(x)\t(1 << (x))\n \n#define\tDEV_NOTE_FWAKE\t\tENABLE_DEV_NOTE(1)\n\n \n \n \n#define CMD_RING_PAUSE\t\t(1 << 1)\n \n#define CMD_RING_ABORT\t\t(1 << 2)\n \n#define CMD_RING_RUNNING\t(1 << 3)\n \n \n#define CMD_RING_RSVD_BITS\t(0x3f)\n\n \n \n#define MAX_DEVS(p)\t((p) & 0xff)\n \n#define CONFIG_U3E\t\t(1 << 8)\n \n#define CONFIG_CIE\t\t(1 << 9)\n \n\n \n \n#define PORT_CONNECT\t(1 << 0)\n \n#define PORT_PE\t\t(1 << 1)\n \n \n#define PORT_OC\t\t(1 << 3)\n \n#define PORT_RESET\t(1 << 4)\n \n#define PORT_PLS_MASK\t(0xf << 5)\n#define XDEV_U0\t\t(0x0 << 5)\n#define XDEV_U1\t\t(0x1 << 5)\n#define XDEV_U2\t\t(0x2 << 5)\n#define XDEV_U3\t\t(0x3 << 5)\n#define XDEV_DISABLED\t(0x4 << 5)\n#define XDEV_RXDETECT\t(0x5 << 5)\n#define XDEV_INACTIVE\t(0x6 << 5)\n#define XDEV_POLLING\t(0x7 << 5)\n#define XDEV_RECOVERY\t(0x8 << 5)\n#define XDEV_HOT_RESET\t(0x9 << 5)\n#define XDEV_COMP_MODE\t(0xa << 5)\n#define XDEV_TEST_MODE\t(0xb << 5)\n#define XDEV_RESUME\t(0xf << 5)\n\n \n#define PORT_POWER\t(1 << 9)\n \n#define DEV_SPEED_MASK\t\t(0xf << 10)\n#define\tXDEV_FS\t\t\t(0x1 << 10)\n#define\tXDEV_LS\t\t\t(0x2 << 10)\n#define\tXDEV_HS\t\t\t(0x3 << 10)\n#define\tXDEV_SS\t\t\t(0x4 << 10)\n#define\tXDEV_SSP\t\t(0x5 << 10)\n#define DEV_UNDEFSPEED(p)\t(((p) & DEV_SPEED_MASK) == (0x0<<10))\n#define DEV_FULLSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_FS)\n#define DEV_LOWSPEED(p)\t\t(((p) & DEV_SPEED_MASK) == XDEV_LS)\n#define DEV_HIGHSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_HS)\n#define DEV_SUPERSPEED(p)\t(((p) & DEV_SPEED_MASK) == XDEV_SS)\n#define DEV_SUPERSPEEDPLUS(p)\t(((p) & DEV_SPEED_MASK) == XDEV_SSP)\n#define DEV_SUPERSPEED_ANY(p)\t(((p) & DEV_SPEED_MASK) >= XDEV_SS)\n#define DEV_PORT_SPEED(p)\t(((p) >> 10) & 0x0f)\n\n \n#define\tSLOT_SPEED_FS\t\t(XDEV_FS << 10)\n#define\tSLOT_SPEED_LS\t\t(XDEV_LS << 10)\n#define\tSLOT_SPEED_HS\t\t(XDEV_HS << 10)\n#define\tSLOT_SPEED_SS\t\t(XDEV_SS << 10)\n#define\tSLOT_SPEED_SSP\t\t(XDEV_SSP << 10)\n \n#define PORT_LED_OFF\t(0 << 14)\n#define PORT_LED_AMBER\t(1 << 14)\n#define PORT_LED_GREEN\t(2 << 14)\n#define PORT_LED_MASK\t(3 << 14)\n \n#define PORT_LINK_STROBE\t(1 << 16)\n \n#define PORT_CSC\t(1 << 17)\n \n#define PORT_PEC\t(1 << 18)\n \n#define PORT_WRC\t(1 << 19)\n \n#define PORT_OCC\t(1 << 20)\n \n#define PORT_RC\t\t(1 << 21)\n \n#define PORT_PLC\t(1 << 22)\n \n#define PORT_CEC\t(1 << 23)\n#define PORT_CHANGE_MASK\t(PORT_CSC | PORT_PEC | PORT_WRC | PORT_OCC | \\\n\t\t\t\t PORT_RC | PORT_PLC | PORT_CEC)\n\n\n \n#define PORT_CAS\t(1 << 24)\n \n#define PORT_WKCONN_E\t(1 << 25)\n \n#define PORT_WKDISC_E\t(1 << 26)\n \n#define PORT_WKOC_E\t(1 << 27)\n \n \n#define PORT_DEV_REMOVE\t(1 << 30)\n \n#define PORT_WR\t\t(1 << 31)\n\n \n#define DUPLICATE_ENTRY ((u8)(-1))\n\n \n \n#define PORT_U1_TIMEOUT(p)\t((p) & 0xff)\n#define PORT_U1_TIMEOUT_MASK\t0xff\n \n#define PORT_U2_TIMEOUT(p)\t(((p) & 0xff) << 8)\n#define PORT_U2_TIMEOUT_MASK\t(0xff << 8)\n \n\n \n#define\tPORT_L1S_MASK\t\t7\n#define\tPORT_L1S_SUCCESS\t1\n#define\tPORT_RWE\t\t(1 << 3)\n#define\tPORT_HIRD(p)\t\t(((p) & 0xf) << 4)\n#define\tPORT_HIRD_MASK\t\t(0xf << 4)\n#define\tPORT_L1DS_MASK\t\t(0xff << 8)\n#define\tPORT_L1DS(p)\t\t(((p) & 0xff) << 8)\n#define\tPORT_HLE\t\t(1 << 16)\n#define PORT_TEST_MODE_SHIFT\t28\n\n \n#define PORT_RX_LANES(p)\t(((p) >> 16) & 0xf)\n#define PORT_TX_LANES(p)\t(((p) >> 20) & 0xf)\n\n \n#define PORT_HIRDM(p)((p) & 3)\n#define PORT_L1_TIMEOUT(p)(((p) & 0xff) << 2)\n#define PORT_BESLD(p)(((p) & 0xf) << 10)\n\n \n#define XHCI_L1_TIMEOUT\t\t512\n\n \n#define XHCI_DEFAULT_BESL\t4\n\n \n#define XHCI_PORT_POLLING_LFPS_TIME  36\n\n \nstruct xhci_intr_reg {\n\t__le32\tirq_pending;\n\t__le32\tirq_control;\n\t__le32\terst_size;\n\t__le32\trsvd;\n\t__le64\terst_base;\n\t__le64\terst_dequeue;\n};\n\n \n#define\tER_IRQ_PENDING(p)\t((p) & 0x1)\n \n \n#define\tER_IRQ_CLEAR(p)\t\t((p) & 0xfffffffe)\n#define\tER_IRQ_ENABLE(p)\t((ER_IRQ_CLEAR(p)) | 0x2)\n#define\tER_IRQ_DISABLE(p)\t((ER_IRQ_CLEAR(p)) & ~(0x2))\n\n \n \n#define ER_IRQ_INTERVAL_MASK\t(0xffff)\n \n#define ER_IRQ_COUNTER_MASK\t(0xffff << 16)\n\n \n \n#define\tERST_SIZE_MASK\t\t(0xffff << 16)\n\n \n#define ERST_BASE_RSVDP\t\t(GENMASK_ULL(5, 0))\n\n \n \n#define ERST_DESI_MASK\t\t(0x7)\n \n#define ERST_EHB\t\t(1 << 3)\n#define ERST_PTR_MASK\t\t(0xf)\n\n \nstruct xhci_run_regs {\n\t__le32\t\t\tmicroframe_index;\n\t__le32\t\t\trsvd[7];\n\tstruct xhci_intr_reg\tir_set[128];\n};\n\n \nstruct xhci_doorbell_array {\n\t__le32\tdoorbell[256];\n};\n\n#define DB_VALUE(ep, stream)\t((((ep) + 1) & 0xff) | ((stream) << 16))\n#define DB_VALUE_HOST\t\t0x00000000\n\n \nstruct xhci_protocol_caps {\n\tu32\trevision;\n\tu32\tname_string;\n\tu32\tport_info;\n};\n\n#define\tXHCI_EXT_PORT_MAJOR(x)\t(((x) >> 24) & 0xff)\n#define\tXHCI_EXT_PORT_MINOR(x)\t(((x) >> 16) & 0xff)\n#define\tXHCI_EXT_PORT_PSIC(x)\t(((x) >> 28) & 0x0f)\n#define\tXHCI_EXT_PORT_OFF(x)\t((x) & 0xff)\n#define\tXHCI_EXT_PORT_COUNT(x)\t(((x) >> 8) & 0xff)\n\n#define\tXHCI_EXT_PORT_PSIV(x)\t(((x) >> 0) & 0x0f)\n#define\tXHCI_EXT_PORT_PSIE(x)\t(((x) >> 4) & 0x03)\n#define\tXHCI_EXT_PORT_PLT(x)\t(((x) >> 6) & 0x03)\n#define\tXHCI_EXT_PORT_PFD(x)\t(((x) >> 8) & 0x01)\n#define\tXHCI_EXT_PORT_LP(x)\t(((x) >> 14) & 0x03)\n#define\tXHCI_EXT_PORT_PSIM(x)\t(((x) >> 16) & 0xffff)\n\n#define PLT_MASK        (0x03 << 6)\n#define PLT_SYM         (0x00 << 6)\n#define PLT_ASYM_RX     (0x02 << 6)\n#define PLT_ASYM_TX     (0x03 << 6)\n\n \nstruct xhci_container_ctx {\n\tunsigned type;\n#define XHCI_CTX_TYPE_DEVICE  0x1\n#define XHCI_CTX_TYPE_INPUT   0x2\n\n\tint size;\n\n\tu8 *bytes;\n\tdma_addr_t dma;\n};\n\n \nstruct xhci_slot_ctx {\n\t__le32\tdev_info;\n\t__le32\tdev_info2;\n\t__le32\ttt_info;\n\t__le32\tdev_state;\n\t \n\t__le32\treserved[4];\n};\n\n \n \n#define ROUTE_STRING_MASK\t(0xfffff)\n \n#define DEV_SPEED\t(0xf << 20)\n#define GET_DEV_SPEED(n) (((n) & DEV_SPEED) >> 20)\n \n \n#define DEV_MTT\t\t(0x1 << 25)\n \n#define DEV_HUB\t\t(0x1 << 26)\n \n#define LAST_CTX_MASK\t(0x1f << 27)\n#define LAST_CTX(p)\t((p) << 27)\n#define LAST_CTX_TO_EP_NUM(p)\t(((p) >> 27) - 1)\n#define SLOT_FLAG\t(1 << 0)\n#define EP0_FLAG\t(1 << 1)\n\n \n \n#define MAX_EXIT\t(0xffff)\n \n#define ROOT_HUB_PORT(p)\t(((p) & 0xff) << 16)\n#define DEVINFO_TO_ROOT_HUB_PORT(p)\t(((p) >> 16) & 0xff)\n \n#define XHCI_MAX_PORTS(p)\t(((p) & 0xff) << 24)\n#define DEVINFO_TO_MAX_PORTS(p)\t(((p) & (0xff << 24)) >> 24)\n\n \n \n#define TT_SLOT\t\t(0xff)\n \n#define TT_PORT\t\t(0xff << 8)\n#define TT_THINK_TIME(p)\t(((p) & 0x3) << 16)\n#define GET_TT_THINK_TIME(p)\t(((p) & (0x3 << 16)) >> 16)\n\n \n \n#define DEV_ADDR_MASK\t(0xff)\n \n \n#define SLOT_STATE\t(0x1f << 27)\n#define GET_SLOT_STATE(p)\t(((p) & (0x1f << 27)) >> 27)\n\n#define SLOT_STATE_DISABLED\t0\n#define SLOT_STATE_ENABLED\tSLOT_STATE_DISABLED\n#define SLOT_STATE_DEFAULT\t1\n#define SLOT_STATE_ADDRESSED\t2\n#define SLOT_STATE_CONFIGURED\t3\n\n \nstruct xhci_ep_ctx {\n\t__le32\tep_info;\n\t__le32\tep_info2;\n\t__le64\tdeq;\n\t__le32\ttx_info;\n\t \n\t__le32\treserved[3];\n};\n\n \n \n#define EP_STATE_MASK\t\t(0x7)\n#define EP_STATE_DISABLED\t0\n#define EP_STATE_RUNNING\t1\n#define EP_STATE_HALTED\t\t2\n#define EP_STATE_STOPPED\t3\n#define EP_STATE_ERROR\t\t4\n#define GET_EP_CTX_STATE(ctx)\t(le32_to_cpu((ctx)->ep_info) & EP_STATE_MASK)\n\n \n#define EP_MULT(p)\t\t(((p) & 0x3) << 8)\n#define CTX_TO_EP_MULT(p)\t(((p) >> 8) & 0x3)\n \n \n \n#define EP_INTERVAL(p)\t\t\t(((p) & 0xff) << 16)\n#define EP_INTERVAL_TO_UFRAMES(p)\t(1 << (((p) >> 16) & 0xff))\n#define CTX_TO_EP_INTERVAL(p)\t\t(((p) >> 16) & 0xff)\n#define EP_MAXPSTREAMS_MASK\t\t(0x1f << 10)\n#define EP_MAXPSTREAMS(p)\t\t(((p) << 10) & EP_MAXPSTREAMS_MASK)\n#define CTX_TO_EP_MAXPSTREAMS(p)\t(((p) & EP_MAXPSTREAMS_MASK) >> 10)\n \n#define\tEP_HAS_LSA\t\t(1 << 15)\n \n#define CTX_TO_MAX_ESIT_PAYLOAD_HI(p)\t(((p) >> 24) & 0xff)\n\n \n \n#define\tFORCE_EVENT\t(0x1)\n#define ERROR_COUNT(p)\t(((p) & 0x3) << 1)\n#define CTX_TO_EP_TYPE(p)\t(((p) >> 3) & 0x7)\n#define EP_TYPE(p)\t((p) << 3)\n#define ISOC_OUT_EP\t1\n#define BULK_OUT_EP\t2\n#define INT_OUT_EP\t3\n#define CTRL_EP\t\t4\n#define ISOC_IN_EP\t5\n#define BULK_IN_EP\t6\n#define INT_IN_EP\t7\n \n \n#define MAX_BURST(p)\t(((p)&0xff) << 8)\n#define CTX_TO_MAX_BURST(p)\t(((p) >> 8) & 0xff)\n#define MAX_PACKET(p)\t(((p)&0xffff) << 16)\n#define MAX_PACKET_MASK\t\t(0xffff << 16)\n#define MAX_PACKET_DECODED(p)\t(((p) >> 16) & 0xffff)\n\n \n#define EP_AVG_TRB_LENGTH(p)\t\t((p) & 0xffff)\n#define EP_MAX_ESIT_PAYLOAD_LO(p)\t(((p) & 0xffff) << 16)\n#define EP_MAX_ESIT_PAYLOAD_HI(p)\t((((p) >> 16) & 0xff) << 24)\n#define CTX_TO_MAX_ESIT_PAYLOAD(p)\t(((p) >> 16) & 0xffff)\n\n \n#define EP_CTX_CYCLE_MASK\t\t(1 << 0)\n#define SCTX_DEQ_MASK\t\t\t(~0xfL)\n\n\n \nstruct xhci_input_control_ctx {\n\t__le32\tdrop_flags;\n\t__le32\tadd_flags;\n\t__le32\trsvd2[6];\n};\n\n#define\tEP_IS_ADDED(ctrl_ctx, i) \\\n\t(le32_to_cpu(ctrl_ctx->add_flags) & (1 << (i + 1)))\n#define\tEP_IS_DROPPED(ctrl_ctx, i)       \\\n\t(le32_to_cpu(ctrl_ctx->drop_flags) & (1 << (i + 1)))\n\n \nstruct xhci_command {\n\t \n\tstruct xhci_container_ctx\t*in_ctx;\n\tu32\t\t\t\tstatus;\n\tint\t\t\t\tslot_id;\n\t \n\tstruct completion\t\t*completion;\n\tunion xhci_trb\t\t\t*command_trb;\n\tstruct list_head\t\tcmd_list;\n};\n\n \n#define\tDROP_EP(x)\t(0x1 << x)\n \n#define\tADD_EP(x)\t(0x1 << x)\n\nstruct xhci_stream_ctx {\n\t \n\t__le64\tstream_ring;\n\t \n\t__le32\treserved[2];\n};\n\n \n#define\tSCT_FOR_CTX(p)\t\t(((p) & 0x7) << 1)\n \n#define\tSCT_SEC_TR\t\t0\n \n#define\tSCT_PRI_TR\t\t1\n \n#define SCT_SSA_8\t\t2\n#define SCT_SSA_16\t\t3\n#define SCT_SSA_32\t\t4\n#define SCT_SSA_64\t\t5\n#define SCT_SSA_128\t\t6\n#define SCT_SSA_256\t\t7\n\n \nstruct xhci_stream_info {\n\tstruct xhci_ring\t\t**stream_rings;\n\t \n\tunsigned int\t\t\tnum_streams;\n\t \n\tstruct xhci_stream_ctx\t\t*stream_ctx_array;\n\tunsigned int\t\t\tnum_stream_ctxs;\n\tdma_addr_t\t\t\tctx_array_dma;\n\t \n\tstruct radix_tree_root\t\ttrb_address_map;\n\tstruct xhci_command\t\t*free_streams_command;\n};\n\n#define\tSMALL_STREAM_ARRAY_SIZE\t\t256\n#define\tMEDIUM_STREAM_ARRAY_SIZE\t1024\n\n \nstruct xhci_bw_info {\n\t \n\tunsigned int\t\tep_interval;\n\t \n\tunsigned int\t\tmult;\n\tunsigned int\t\tnum_packets;\n\tunsigned int\t\tmax_packet_size;\n\tunsigned int\t\tmax_esit_payload;\n\tunsigned int\t\ttype;\n};\n\n \n#define\tFS_BLOCK\t1\n#define\tHS_BLOCK\t4\n#define\tSS_BLOCK\t16\n#define\tDMI_BLOCK\t32\n\n \n#define DMI_OVERHEAD 8\n#define DMI_OVERHEAD_BURST 4\n#define SS_OVERHEAD 8\n#define SS_OVERHEAD_BURST 32\n#define HS_OVERHEAD 26\n#define FS_OVERHEAD 20\n#define LS_OVERHEAD 128\n \n#define TT_HS_OVERHEAD (31 + 94)\n#define TT_DMI_OVERHEAD (25 + 12)\n\n \n#define FS_BW_LIMIT\t\t1285\n#define TT_BW_LIMIT\t\t1320\n#define HS_BW_LIMIT\t\t1607\n#define SS_BW_LIMIT_IN\t\t3906\n#define DMI_BW_LIMIT_IN\t\t3906\n#define SS_BW_LIMIT_OUT\t\t3906\n#define DMI_BW_LIMIT_OUT\t3906\n\n \n#define FS_BW_RESERVED\t\t10\n#define HS_BW_RESERVED\t\t20\n#define SS_BW_RESERVED\t\t10\n\nstruct xhci_virt_ep {\n\tstruct xhci_virt_device\t\t*vdev;\t \n\tunsigned int\t\t\tep_index;\n\tstruct xhci_ring\t\t*ring;\n\t \n\tstruct xhci_stream_info\t\t*stream_info;\n\t \n\tstruct xhci_ring\t\t*new_ring;\n\tunsigned int\t\t\terr_count;\n\tunsigned int\t\t\tep_state;\n#define SET_DEQ_PENDING\t\t(1 << 0)\n#define EP_HALTED\t\t(1 << 1)\t \n#define EP_STOP_CMD_PENDING\t(1 << 2)\t \n \n#define EP_GETTING_STREAMS\t(1 << 3)\n#define EP_HAS_STREAMS\t\t(1 << 4)\n \n#define EP_GETTING_NO_STREAMS\t(1 << 5)\n#define EP_HARD_CLEAR_TOGGLE\t(1 << 6)\n#define EP_SOFT_CLEAR_TOGGLE\t(1 << 7)\n \n#define EP_CLEARING_TT\t\t(1 << 8)\n\t \n\tstruct list_head\tcancelled_td_list;\n\tstruct xhci_hcd\t\t*xhci;\n\t \n\tstruct xhci_segment\t*queued_deq_seg;\n\tunion xhci_trb\t\t*queued_deq_ptr;\n\t \n\tbool\t\t\tskip;\n\t \n\tstruct xhci_bw_info\tbw_info;\n\tstruct list_head\tbw_endpoint_list;\n\t \n\tint\t\t\tnext_frame_id;\n\t \n\tbool\t\t\tuse_extended_tbc;\n};\n\nenum xhci_overhead_type {\n\tLS_OVERHEAD_TYPE = 0,\n\tFS_OVERHEAD_TYPE,\n\tHS_OVERHEAD_TYPE,\n};\n\nstruct xhci_interval_bw {\n\tunsigned int\t\tnum_packets;\n\t \n\tstruct list_head\tendpoints;\n\t \n\tunsigned int\t\toverhead[3];\n};\n\n#define\tXHCI_MAX_INTERVAL\t16\n\nstruct xhci_interval_bw_table {\n\tunsigned int\t\tinterval0_esit_payload;\n\tstruct xhci_interval_bw\tinterval_bw[XHCI_MAX_INTERVAL];\n\t \n\tunsigned int\t\tbw_used;\n\tunsigned int\t\tss_bw_in;\n\tunsigned int\t\tss_bw_out;\n};\n\n#define EP_CTX_PER_DEV\t\t31\n\nstruct xhci_virt_device {\n\tint\t\t\t\tslot_id;\n\tstruct usb_device\t\t*udev;\n\t \n\tstruct xhci_container_ctx       *out_ctx;\n\t \n\tstruct xhci_container_ctx       *in_ctx;\n\tstruct xhci_virt_ep\t\teps[EP_CTX_PER_DEV];\n\tu8\t\t\t\tfake_port;\n\tu8\t\t\t\treal_port;\n\tstruct xhci_interval_bw_table\t*bw_table;\n\tstruct xhci_tt_bw_info\t\t*tt_info;\n\t \n\tunsigned long\t\t\tflags;\n#define VDEV_PORT_ERROR\t\t\tBIT(0)  \n\n\t \n\tu16\t\t\t\tcurrent_mel;\n\t \n\tvoid\t\t\t\t*debugfs_private;\n};\n\n \nstruct xhci_root_port_bw_info {\n\tstruct list_head\t\ttts;\n\tunsigned int\t\t\tnum_active_tts;\n\tstruct xhci_interval_bw_table\tbw_table;\n};\n\nstruct xhci_tt_bw_info {\n\tstruct list_head\t\ttt_list;\n\tint\t\t\t\tslot_id;\n\tint\t\t\t\tttport;\n\tstruct xhci_interval_bw_table\tbw_table;\n\tint\t\t\t\tactive_eps;\n};\n\n\n \nstruct xhci_device_context_array {\n\t \n\t__le64\t\t\tdev_context_ptrs[MAX_HC_SLOTS];\n\t \n\tdma_addr_t\tdma;\n};\n \n \n\n\nstruct xhci_transfer_event {\n\t \n\t__le64\tbuffer;\n\t__le32\ttransfer_len;\n\t \n\t__le32\tflags;\n};\n\n \n \n#define\tEVENT_TRB_LEN(p)\t\t((p) & 0xffffff)\n\n \n#define\tTRB_TO_EP_ID(p)\t(((p) >> 16) & 0x1f)\n\n \n#define\tCOMP_CODE_MASK\t\t(0xff << 24)\n#define GET_COMP_CODE(p)\t(((p) & COMP_CODE_MASK) >> 24)\n#define COMP_INVALID\t\t\t\t0\n#define COMP_SUCCESS\t\t\t\t1\n#define COMP_DATA_BUFFER_ERROR\t\t\t2\n#define COMP_BABBLE_DETECTED_ERROR\t\t3\n#define COMP_USB_TRANSACTION_ERROR\t\t4\n#define COMP_TRB_ERROR\t\t\t\t5\n#define COMP_STALL_ERROR\t\t\t6\n#define COMP_RESOURCE_ERROR\t\t\t7\n#define COMP_BANDWIDTH_ERROR\t\t\t8\n#define COMP_NO_SLOTS_AVAILABLE_ERROR\t\t9\n#define COMP_INVALID_STREAM_TYPE_ERROR\t\t10\n#define COMP_SLOT_NOT_ENABLED_ERROR\t\t11\n#define COMP_ENDPOINT_NOT_ENABLED_ERROR\t\t12\n#define COMP_SHORT_PACKET\t\t\t13\n#define COMP_RING_UNDERRUN\t\t\t14\n#define COMP_RING_OVERRUN\t\t\t15\n#define COMP_VF_EVENT_RING_FULL_ERROR\t\t16\n#define COMP_PARAMETER_ERROR\t\t\t17\n#define COMP_BANDWIDTH_OVERRUN_ERROR\t\t18\n#define COMP_CONTEXT_STATE_ERROR\t\t19\n#define COMP_NO_PING_RESPONSE_ERROR\t\t20\n#define COMP_EVENT_RING_FULL_ERROR\t\t21\n#define COMP_INCOMPATIBLE_DEVICE_ERROR\t\t22\n#define COMP_MISSED_SERVICE_ERROR\t\t23\n#define COMP_COMMAND_RING_STOPPED\t\t24\n#define COMP_COMMAND_ABORTED\t\t\t25\n#define COMP_STOPPED\t\t\t\t26\n#define COMP_STOPPED_LENGTH_INVALID\t\t27\n#define COMP_STOPPED_SHORT_PACKET\t\t28\n#define COMP_MAX_EXIT_LATENCY_TOO_LARGE_ERROR\t29\n#define COMP_ISOCH_BUFFER_OVERRUN\t\t31\n#define COMP_EVENT_LOST_ERROR\t\t\t32\n#define COMP_UNDEFINED_ERROR\t\t\t33\n#define COMP_INVALID_STREAM_ID_ERROR\t\t34\n#define COMP_SECONDARY_BANDWIDTH_ERROR\t\t35\n#define COMP_SPLIT_TRANSACTION_ERROR\t\t36\n\nstatic inline const char *xhci_trb_comp_code_string(u8 status)\n{\n\tswitch (status) {\n\tcase COMP_INVALID:\n\t\treturn \"Invalid\";\n\tcase COMP_SUCCESS:\n\t\treturn \"Success\";\n\tcase COMP_DATA_BUFFER_ERROR:\n\t\treturn \"Data Buffer Error\";\n\tcase COMP_BABBLE_DETECTED_ERROR:\n\t\treturn \"Babble Detected\";\n\tcase COMP_USB_TRANSACTION_ERROR:\n\t\treturn \"USB Transaction Error\";\n\tcase COMP_TRB_ERROR:\n\t\treturn \"TRB Error\";\n\tcase COMP_STALL_ERROR:\n\t\treturn \"Stall Error\";\n\tcase COMP_RESOURCE_ERROR:\n\t\treturn \"Resource Error\";\n\tcase COMP_BANDWIDTH_ERROR:\n\t\treturn \"Bandwidth Error\";\n\tcase COMP_NO_SLOTS_AVAILABLE_ERROR:\n\t\treturn \"No Slots Available Error\";\n\tcase COMP_INVALID_STREAM_TYPE_ERROR:\n\t\treturn \"Invalid Stream Type Error\";\n\tcase COMP_SLOT_NOT_ENABLED_ERROR:\n\t\treturn \"Slot Not Enabled Error\";\n\tcase COMP_ENDPOINT_NOT_ENABLED_ERROR:\n\t\treturn \"Endpoint Not Enabled Error\";\n\tcase COMP_SHORT_PACKET:\n\t\treturn \"Short Packet\";\n\tcase COMP_RING_UNDERRUN:\n\t\treturn \"Ring Underrun\";\n\tcase COMP_RING_OVERRUN:\n\t\treturn \"Ring Overrun\";\n\tcase COMP_VF_EVENT_RING_FULL_ERROR:\n\t\treturn \"VF Event Ring Full Error\";\n\tcase COMP_PARAMETER_ERROR:\n\t\treturn \"Parameter Error\";\n\tcase COMP_BANDWIDTH_OVERRUN_ERROR:\n\t\treturn \"Bandwidth Overrun Error\";\n\tcase COMP_CONTEXT_STATE_ERROR:\n\t\treturn \"Context State Error\";\n\tcase COMP_NO_PING_RESPONSE_ERROR:\n\t\treturn \"No Ping Response Error\";\n\tcase COMP_EVENT_RING_FULL_ERROR:\n\t\treturn \"Event Ring Full Error\";\n\tcase COMP_INCOMPATIBLE_DEVICE_ERROR:\n\t\treturn \"Incompatible Device Error\";\n\tcase COMP_MISSED_SERVICE_ERROR:\n\t\treturn \"Missed Service Error\";\n\tcase COMP_COMMAND_RING_STOPPED:\n\t\treturn \"Command Ring Stopped\";\n\tcase COMP_COMMAND_ABORTED:\n\t\treturn \"Command Aborted\";\n\tcase COMP_STOPPED:\n\t\treturn \"Stopped\";\n\tcase COMP_STOPPED_LENGTH_INVALID:\n\t\treturn \"Stopped - Length Invalid\";\n\tcase COMP_STOPPED_SHORT_PACKET:\n\t\treturn \"Stopped - Short Packet\";\n\tcase COMP_MAX_EXIT_LATENCY_TOO_LARGE_ERROR:\n\t\treturn \"Max Exit Latency Too Large Error\";\n\tcase COMP_ISOCH_BUFFER_OVERRUN:\n\t\treturn \"Isoch Buffer Overrun\";\n\tcase COMP_EVENT_LOST_ERROR:\n\t\treturn \"Event Lost Error\";\n\tcase COMP_UNDEFINED_ERROR:\n\t\treturn \"Undefined Error\";\n\tcase COMP_INVALID_STREAM_ID_ERROR:\n\t\treturn \"Invalid Stream ID Error\";\n\tcase COMP_SECONDARY_BANDWIDTH_ERROR:\n\t\treturn \"Secondary Bandwidth Error\";\n\tcase COMP_SPLIT_TRANSACTION_ERROR:\n\t\treturn \"Split Transaction Error\";\n\tdefault:\n\t\treturn \"Unknown!!\";\n\t}\n}\n\nstruct xhci_link_trb {\n\t \n\t__le64 segment_ptr;\n\t__le32 intr_target;\n\t__le32 control;\n};\n\n \n#define LINK_TOGGLE\t(0x1<<1)\n\n \nstruct xhci_event_cmd {\n\t \n\t__le64 cmd_trb;\n\t__le32 status;\n\t__le32 flags;\n};\n\n \n\n \n#define TRB_BSR\t\t(1<<9)\n\n \n#define TRB_DC\t\t(1<<9)\n\n \n#define TRB_TSP\t\t(1<<9)\n\nenum xhci_ep_reset_type {\n\tEP_HARD_RESET,\n\tEP_SOFT_RESET,\n};\n\n \n#define TRB_TO_VF_INTR_TARGET(p)\t(((p) & (0x3ff << 22)) >> 22)\n#define TRB_TO_VF_ID(p)\t\t\t(((p) & (0xff << 16)) >> 16)\n\n \n#define TRB_TO_BELT(p)\t\t\t(((p) & (0xfff << 16)) >> 16)\n\n \n#define TRB_TO_DEV_SPEED(p)\t\t(((p) & (0xf << 16)) >> 16)\n\n \n#define TRB_TO_PACKET_TYPE(p)\t\t((p) & 0x1f)\n#define TRB_TO_ROOTHUB_PORT(p)\t\t(((p) & (0xff << 24)) >> 24)\n\nenum xhci_setup_dev {\n\tSETUP_CONTEXT_ONLY,\n\tSETUP_CONTEXT_ADDRESS,\n};\n\n \n \n#define TRB_TO_SLOT_ID(p)\t(((p) & (0xff<<24)) >> 24)\n#define SLOT_ID_FOR_TRB(p)\t(((p) & 0xff) << 24)\n\n \n#define TRB_TO_EP_INDEX(p)\t\t((((p) & (0x1f << 16)) >> 16) - 1)\n#define\tEP_ID_FOR_TRB(p)\t\t((((p) + 1) & 0x1f) << 16)\n\n#define SUSPEND_PORT_FOR_TRB(p)\t\t(((p) & 1) << 23)\n#define TRB_TO_SUSPEND_PORT(p)\t\t(((p) & (1 << 23)) >> 23)\n#define LAST_EP_INDEX\t\t\t30\n\n \n#define TRB_TO_STREAM_ID(p)\t\t((((p) & (0xffff << 16)) >> 16))\n#define STREAM_ID_FOR_TRB(p)\t\t((((p)) & 0xffff) << 16)\n#define SCT_FOR_TRB(p)\t\t\t(((p) << 1) & 0x7)\n\n \n#define TRB_TC\t\t\t(1<<1)\n\n \n \n#define GET_PORT_ID(p)\t\t(((p) & (0xff << 24)) >> 24)\n\n#define EVENT_DATA\t\t(1 << 2)\n\n \n \n#define\tTRB_LEN(p)\t\t((p) & 0x1ffff)\n \n#define TRB_TD_SIZE(p)          (min((p), (u32)31) << 17)\n#define GET_TD_SIZE(p)\t\t(((p) & 0x3e0000) >> 17)\n \n#define TRB_TD_SIZE_TBC(p)      (min((p), (u32)31) << 17)\n \n#define TRB_INTR_TARGET(p)\t(((p) & 0x3ff) << 22)\n#define GET_INTR_TARGET(p)\t(((p) >> 22) & 0x3ff)\n \n#define TRB_TBC(p)\t\t(((p) & 0x3) << 7)\n#define TRB_TLBPC(p)\t\t(((p) & 0xf) << 16)\n\n \n#define TRB_CYCLE\t\t(1<<0)\n \n#define TRB_ENT\t\t\t(1<<1)\n \n#define TRB_ISP\t\t\t(1<<2)\n \n#define TRB_NO_SNOOP\t\t(1<<3)\n \n#define TRB_CHAIN\t\t(1<<4)\n \n#define TRB_IOC\t\t\t(1<<5)\n \n#define TRB_IDT\t\t\t(1<<6)\n \n#define TRB_IDT_MAX_SIZE\t8\n\n \n#define\tTRB_BEI\t\t\t(1<<9)\n\n \n#define TRB_DIR_IN\t\t(1<<16)\n#define\tTRB_TX_TYPE(p)\t\t((p) << 16)\n#define\tTRB_DATA_OUT\t\t2\n#define\tTRB_DATA_IN\t\t3\n\n \n#define TRB_SIA\t\t\t(1<<31)\n#define TRB_FRAME_ID(p)\t\t(((p) & 0x7ff) << 20)\n\n \n#define TRB_CACHE_SIZE_HS\t8\n#define TRB_CACHE_SIZE_SS\t16\n\nstruct xhci_generic_trb {\n\t__le32 field[4];\n};\n\nunion xhci_trb {\n\tstruct xhci_link_trb\t\tlink;\n\tstruct xhci_transfer_event\ttrans_event;\n\tstruct xhci_event_cmd\t\tevent_cmd;\n\tstruct xhci_generic_trb\t\tgeneric;\n};\n\n \n#define\tTRB_TYPE_BITMASK\t(0xfc00)\n#define TRB_TYPE(p)\t\t((p) << 10)\n#define TRB_FIELD_TO_TYPE(p)\t(((p) & TRB_TYPE_BITMASK) >> 10)\n \n \n#define TRB_NORMAL\t\t1\n \n#define TRB_SETUP\t\t2\n \n#define TRB_DATA\t\t3\n \n#define TRB_STATUS\t\t4\n \n#define TRB_ISOC\t\t5\n \n#define TRB_LINK\t\t6\n#define TRB_EVENT_DATA\t\t7\n \n#define TRB_TR_NOOP\t\t8\n \n \n#define TRB_ENABLE_SLOT\t\t9\n \n#define TRB_DISABLE_SLOT\t10\n \n#define TRB_ADDR_DEV\t\t11\n \n#define TRB_CONFIG_EP\t\t12\n \n#define TRB_EVAL_CONTEXT\t13\n \n#define TRB_RESET_EP\t\t14\n \n#define TRB_STOP_RING\t\t15\n \n#define TRB_SET_DEQ\t\t16\n \n#define TRB_RESET_DEV\t\t17\n \n#define TRB_FORCE_EVENT\t\t18\n \n#define TRB_NEG_BANDWIDTH\t19\n \n#define TRB_SET_LT\t\t20\n \n#define TRB_GET_BW\t\t21\n \n#define TRB_FORCE_HEADER\t22\n \n#define TRB_CMD_NOOP\t\t23\n \n \n \n#define TRB_TRANSFER\t\t32\n \n#define TRB_COMPLETION\t\t33\n \n#define TRB_PORT_STATUS\t\t34\n \n#define TRB_BANDWIDTH_EVENT\t35\n \n#define TRB_DOORBELL\t\t36\n \n#define TRB_HC_EVENT\t\t37\n \n#define TRB_DEV_NOTE\t\t38\n \n#define TRB_MFINDEX_WRAP\t39\n \n#define TRB_VENDOR_DEFINED_LOW\t48\n \n#define\tTRB_NEC_CMD_COMP\t48\n \n#define\tTRB_NEC_GET_FW\t\t49\n\nstatic inline const char *xhci_trb_type_string(u8 type)\n{\n\tswitch (type) {\n\tcase TRB_NORMAL:\n\t\treturn \"Normal\";\n\tcase TRB_SETUP:\n\t\treturn \"Setup Stage\";\n\tcase TRB_DATA:\n\t\treturn \"Data Stage\";\n\tcase TRB_STATUS:\n\t\treturn \"Status Stage\";\n\tcase TRB_ISOC:\n\t\treturn \"Isoch\";\n\tcase TRB_LINK:\n\t\treturn \"Link\";\n\tcase TRB_EVENT_DATA:\n\t\treturn \"Event Data\";\n\tcase TRB_TR_NOOP:\n\t\treturn \"No-Op\";\n\tcase TRB_ENABLE_SLOT:\n\t\treturn \"Enable Slot Command\";\n\tcase TRB_DISABLE_SLOT:\n\t\treturn \"Disable Slot Command\";\n\tcase TRB_ADDR_DEV:\n\t\treturn \"Address Device Command\";\n\tcase TRB_CONFIG_EP:\n\t\treturn \"Configure Endpoint Command\";\n\tcase TRB_EVAL_CONTEXT:\n\t\treturn \"Evaluate Context Command\";\n\tcase TRB_RESET_EP:\n\t\treturn \"Reset Endpoint Command\";\n\tcase TRB_STOP_RING:\n\t\treturn \"Stop Ring Command\";\n\tcase TRB_SET_DEQ:\n\t\treturn \"Set TR Dequeue Pointer Command\";\n\tcase TRB_RESET_DEV:\n\t\treturn \"Reset Device Command\";\n\tcase TRB_FORCE_EVENT:\n\t\treturn \"Force Event Command\";\n\tcase TRB_NEG_BANDWIDTH:\n\t\treturn \"Negotiate Bandwidth Command\";\n\tcase TRB_SET_LT:\n\t\treturn \"Set Latency Tolerance Value Command\";\n\tcase TRB_GET_BW:\n\t\treturn \"Get Port Bandwidth Command\";\n\tcase TRB_FORCE_HEADER:\n\t\treturn \"Force Header Command\";\n\tcase TRB_CMD_NOOP:\n\t\treturn \"No-Op Command\";\n\tcase TRB_TRANSFER:\n\t\treturn \"Transfer Event\";\n\tcase TRB_COMPLETION:\n\t\treturn \"Command Completion Event\";\n\tcase TRB_PORT_STATUS:\n\t\treturn \"Port Status Change Event\";\n\tcase TRB_BANDWIDTH_EVENT:\n\t\treturn \"Bandwidth Request Event\";\n\tcase TRB_DOORBELL:\n\t\treturn \"Doorbell Event\";\n\tcase TRB_HC_EVENT:\n\t\treturn \"Host Controller Event\";\n\tcase TRB_DEV_NOTE:\n\t\treturn \"Device Notification Event\";\n\tcase TRB_MFINDEX_WRAP:\n\t\treturn \"MFINDEX Wrap Event\";\n\tcase TRB_NEC_CMD_COMP:\n\t\treturn \"NEC Command Completion Event\";\n\tcase TRB_NEC_GET_FW:\n\t\treturn \"NET Get Firmware Revision Command\";\n\tdefault:\n\t\treturn \"UNKNOWN\";\n\t}\n}\n\n#define TRB_TYPE_LINK(x)\t(((x) & TRB_TYPE_BITMASK) == TRB_TYPE(TRB_LINK))\n \n#define TRB_TYPE_LINK_LE32(x)\t(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \\\n\t\t\t\t cpu_to_le32(TRB_TYPE(TRB_LINK)))\n#define TRB_TYPE_NOOP_LE32(x)\t(((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \\\n\t\t\t\t cpu_to_le32(TRB_TYPE(TRB_TR_NOOP)))\n\n#define NEC_FW_MINOR(p)\t\t(((p) >> 0) & 0xff)\n#define NEC_FW_MAJOR(p)\t\t(((p) >> 8) & 0xff)\n\n \n#define TRBS_PER_SEGMENT\t256\n \n#define MAX_RSVD_CMD_TRBS\t(TRBS_PER_SEGMENT - 3)\n#define TRB_SEGMENT_SIZE\t(TRBS_PER_SEGMENT*16)\n#define TRB_SEGMENT_SHIFT\t(ilog2(TRB_SEGMENT_SIZE))\n \n#define TRB_MAX_BUFF_SHIFT\t\t16\n#define TRB_MAX_BUFF_SIZE\t(1 << TRB_MAX_BUFF_SHIFT)\n \n#define TRB_BUFF_LEN_UP_TO_BOUNDARY(addr)\t(TRB_MAX_BUFF_SIZE - \\\n\t\t\t\t\t(addr & (TRB_MAX_BUFF_SIZE - 1)))\n#define MAX_SOFT_RETRY\t\t3\n \n#define AVOID_BEI_INTERVAL_MIN\t8\n#define AVOID_BEI_INTERVAL_MAX\t32\n\nstruct xhci_segment {\n\tunion xhci_trb\t\t*trbs;\n\t \n\tstruct xhci_segment\t*next;\n\tdma_addr_t\t\tdma;\n\t \n\tdma_addr_t\t\tbounce_dma;\n\tvoid\t\t\t*bounce_buf;\n\tunsigned int\t\tbounce_offs;\n\tunsigned int\t\tbounce_len;\n};\n\nenum xhci_cancelled_td_status {\n\tTD_DIRTY = 0,\n\tTD_HALTED,\n\tTD_CLEARING_CACHE,\n\tTD_CLEARED,\n};\n\nstruct xhci_td {\n\tstruct list_head\ttd_list;\n\tstruct list_head\tcancelled_td_list;\n\tint\t\t\tstatus;\n\tenum xhci_cancelled_td_status\tcancel_status;\n\tstruct urb\t\t*urb;\n\tstruct xhci_segment\t*start_seg;\n\tunion xhci_trb\t\t*first_trb;\n\tunion xhci_trb\t\t*last_trb;\n\tstruct xhci_segment\t*last_trb_seg;\n\tstruct xhci_segment\t*bounce_seg;\n\t \n\tbool\t\t\turb_length_set;\n\tunsigned int\t\tnum_trbs;\n};\n\n \n#define XHCI_CMD_DEFAULT_TIMEOUT\t(5 * HZ)\n\n \nstruct xhci_cd {\n\tstruct xhci_command\t*command;\n\tunion xhci_trb\t\t*cmd_trb;\n};\n\nenum xhci_ring_type {\n\tTYPE_CTRL = 0,\n\tTYPE_ISOC,\n\tTYPE_BULK,\n\tTYPE_INTR,\n\tTYPE_STREAM,\n\tTYPE_COMMAND,\n\tTYPE_EVENT,\n};\n\nstatic inline const char *xhci_ring_type_string(enum xhci_ring_type type)\n{\n\tswitch (type) {\n\tcase TYPE_CTRL:\n\t\treturn \"CTRL\";\n\tcase TYPE_ISOC:\n\t\treturn \"ISOC\";\n\tcase TYPE_BULK:\n\t\treturn \"BULK\";\n\tcase TYPE_INTR:\n\t\treturn \"INTR\";\n\tcase TYPE_STREAM:\n\t\treturn \"STREAM\";\n\tcase TYPE_COMMAND:\n\t\treturn \"CMD\";\n\tcase TYPE_EVENT:\n\t\treturn \"EVENT\";\n\t}\n\n\treturn \"UNKNOWN\";\n}\n\nstruct xhci_ring {\n\tstruct xhci_segment\t*first_seg;\n\tstruct xhci_segment\t*last_seg;\n\tunion  xhci_trb\t\t*enqueue;\n\tstruct xhci_segment\t*enq_seg;\n\tunion  xhci_trb\t\t*dequeue;\n\tstruct xhci_segment\t*deq_seg;\n\tstruct list_head\ttd_list;\n\t \n\tu32\t\t\tcycle_state;\n\tunsigned int\t\tstream_id;\n\tunsigned int\t\tnum_segs;\n\tunsigned int\t\tnum_trbs_free;  \n\tunsigned int\t\tbounce_buf_len;\n\tenum xhci_ring_type\ttype;\n\tbool\t\t\tlast_td_was_short;\n\tstruct radix_tree_root\t*trb_address_map;\n};\n\nstruct xhci_erst_entry {\n\t \n\t__le64\tseg_addr;\n\t__le32\tseg_size;\n\t \n\t__le32\trsvd;\n};\n\nstruct xhci_erst {\n\tstruct xhci_erst_entry\t*entries;\n\tunsigned int\t\tnum_entries;\n\t \n\tdma_addr_t\t\terst_dma_addr;\n\t \n\tunsigned int\t\terst_size;\n};\n\nstruct xhci_scratchpad {\n\tu64 *sp_array;\n\tdma_addr_t sp_dma;\n\tvoid **sp_buffers;\n};\n\nstruct urb_priv {\n\tint\tnum_tds;\n\tint\tnum_tds_done;\n\tstruct\txhci_td\ttd[];\n};\n\n \n#define\tERST_NUM_SEGS\t1\n \n#define\tPOLL_TIMEOUT\t60\n \n#define XHCI_STOP_EP_CMD_TIMEOUT\t5\n \n\nstruct s3_save {\n\tu32\tcommand;\n\tu32\tdev_nt;\n\tu64\tdcbaa_ptr;\n\tu32\tconfig_reg;\n};\n\n \nstruct dev_info {\n\tu32\t\t\tdev_id;\n\tstruct\tlist_head\tlist;\n};\n\nstruct xhci_bus_state {\n\tunsigned long\t\tbus_suspended;\n\tunsigned long\t\tnext_statechange;\n\n\t \n\t \n\tu32\t\t\tport_c_suspend;\n\tu32\t\t\tsuspended_ports;\n\tu32\t\t\tport_remote_wakeup;\n\t \n\tunsigned long\t\tresuming_ports;\n};\n\nstruct xhci_interrupter {\n\tstruct xhci_ring\t*event_ring;\n\tstruct xhci_erst\terst;\n\tstruct xhci_intr_reg __iomem *ir_set;\n\tunsigned int\t\tintr_num;\n\t \n\tu32\ts3_irq_pending;\n\tu32\ts3_irq_control;\n\tu32\ts3_erst_size;\n\tu64\ts3_erst_base;\n\tu64\ts3_erst_dequeue;\n};\n \n#define\tXHCI_MAX_REXIT_TIMEOUT_MS\t20\nstruct xhci_port_cap {\n\tu32\t\t\t*psi;\t \n\tu8\t\t\tpsi_count;\n\tu8\t\t\tpsi_uid_count;\n\tu8\t\t\tmaj_rev;\n\tu8\t\t\tmin_rev;\n};\n\nstruct xhci_port {\n\t__le32 __iomem\t\t*addr;\n\tint\t\t\thw_portnum;\n\tint\t\t\thcd_portnum;\n\tstruct xhci_hub\t\t*rhub;\n\tstruct xhci_port_cap\t*port_cap;\n\tunsigned int\t\tlpm_incapable:1;\n\tunsigned long\t\tresume_timestamp;\n\tbool\t\t\trexit_active;\n\tstruct completion\trexit_done;\n\tstruct completion\tu3exit_done;\n};\n\nstruct xhci_hub {\n\tstruct xhci_port\t**ports;\n\tunsigned int\t\tnum_ports;\n\tstruct usb_hcd\t\t*hcd;\n\t \n\tstruct xhci_bus_state   bus_state;\n\t \n\tu8\t\t\tmaj_rev;\n\tu8\t\t\tmin_rev;\n};\n\n \nstruct xhci_hcd {\n\tstruct usb_hcd *main_hcd;\n\tstruct usb_hcd *shared_hcd;\n\t \n\tstruct xhci_cap_regs __iomem *cap_regs;\n\tstruct xhci_op_regs __iomem *op_regs;\n\tstruct xhci_run_regs __iomem *run_regs;\n\tstruct xhci_doorbell_array __iomem *dba;\n\n\t \n\t__u32\t\thcs_params1;\n\t__u32\t\thcs_params2;\n\t__u32\t\thcs_params3;\n\t__u32\t\thcc_params;\n\t__u32\t\thcc_params2;\n\n\tspinlock_t\tlock;\n\n\t \n\tu8\t\tsbrn;\n\tu16\t\thci_version;\n\tu8\t\tmax_slots;\n\tu16\t\tmax_interrupters;\n\tu8\t\tmax_ports;\n\tu8\t\tisoc_threshold;\n\t \n\tu32\t\timod_interval;\n\tu32\t\tisoc_bei_interval;\n\tint\t\tevent_ring_max;\n\t \n\tint\t\tpage_size;\n\t \n\tint\t\tpage_shift;\n\t \n\tint\t\tmsix_count;\n\t \n\tstruct clk\t\t*clk;\n\tstruct clk\t\t*reg_clk;\n\t \n\tstruct reset_control *reset;\n\t \n\tstruct xhci_device_context_array *dcbaa;\n\tstruct xhci_interrupter *interrupter;\n\tstruct xhci_ring\t*cmd_ring;\n\tunsigned int            cmd_ring_state;\n#define CMD_RING_STATE_RUNNING         (1 << 0)\n#define CMD_RING_STATE_ABORTED         (1 << 1)\n#define CMD_RING_STATE_STOPPED         (1 << 2)\n\tstruct list_head        cmd_list;\n\tunsigned int\t\tcmd_ring_reserved_trbs;\n\tstruct delayed_work\tcmd_timer;\n\tstruct completion\tcmd_ring_stop_completion;\n\tstruct xhci_command\t*current_cmd;\n\n\t \n\tstruct xhci_scratchpad  *scratchpad;\n\n\t \n\t \n\tstruct mutex mutex;\n\t \n\tstruct xhci_virt_device\t*devs[MAX_HC_SLOTS];\n\t \n\tstruct xhci_root_port_bw_info\t*rh_bw;\n\n\t \n\tstruct dma_pool\t*device_pool;\n\tstruct dma_pool\t*segment_pool;\n\tstruct dma_pool\t*small_streams_pool;\n\tstruct dma_pool\t*medium_streams_pool;\n\n\t \n\tunsigned int\t\txhc_state;\n\tunsigned long\t\trun_graceperiod;\n\tstruct s3_save\t\ts3;\n \n#define XHCI_STATE_DYING\t(1 << 0)\n#define XHCI_STATE_HALTED\t(1 << 1)\n#define XHCI_STATE_REMOVING\t(1 << 2)\n\tunsigned long long\tquirks;\n#define\tXHCI_LINK_TRB_QUIRK\tBIT_ULL(0)\n#define XHCI_RESET_EP_QUIRK\tBIT_ULL(1)  \n#define XHCI_NEC_HOST\t\tBIT_ULL(2)\n#define XHCI_AMD_PLL_FIX\tBIT_ULL(3)\n#define XHCI_SPURIOUS_SUCCESS\tBIT_ULL(4)\n \n#define XHCI_EP_LIMIT_QUIRK\tBIT_ULL(5)\n#define XHCI_BROKEN_MSI\t\tBIT_ULL(6)\n#define XHCI_RESET_ON_RESUME\tBIT_ULL(7)\n#define\tXHCI_SW_BW_CHECKING\tBIT_ULL(8)\n#define XHCI_AMD_0x96_HOST\tBIT_ULL(9)\n#define XHCI_TRUST_TX_LENGTH\tBIT_ULL(10)\n#define XHCI_LPM_SUPPORT\tBIT_ULL(11)\n#define XHCI_INTEL_HOST\t\tBIT_ULL(12)\n#define XHCI_SPURIOUS_REBOOT\tBIT_ULL(13)\n#define XHCI_COMP_MODE_QUIRK\tBIT_ULL(14)\n#define XHCI_AVOID_BEI\t\tBIT_ULL(15)\n#define XHCI_PLAT\t\tBIT_ULL(16)  \n#define XHCI_SLOW_SUSPEND\tBIT_ULL(17)\n#define XHCI_SPURIOUS_WAKEUP\tBIT_ULL(18)\n \n#define XHCI_BROKEN_STREAMS\tBIT_ULL(19)\n#define XHCI_PME_STUCK_QUIRK\tBIT_ULL(20)\n#define XHCI_MTK_HOST\t\tBIT_ULL(21)\n#define XHCI_SSIC_PORT_UNUSED\tBIT_ULL(22)\n#define XHCI_NO_64BIT_SUPPORT\tBIT_ULL(23)\n#define XHCI_MISSING_CAS\tBIT_ULL(24)\n \n#define XHCI_BROKEN_PORT_PED\tBIT_ULL(25)\n#define XHCI_LIMIT_ENDPOINT_INTERVAL_7\tBIT_ULL(26)\n#define XHCI_U2_DISABLE_WAKE\tBIT_ULL(27)\n#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL\tBIT_ULL(28)\n#define XHCI_HW_LPM_DISABLE\tBIT_ULL(29)\n#define XHCI_SUSPEND_DELAY\tBIT_ULL(30)\n#define XHCI_INTEL_USB_ROLE_SW\tBIT_ULL(31)\n#define XHCI_ZERO_64B_REGS\tBIT_ULL(32)\n#define XHCI_DEFAULT_PM_RUNTIME_ALLOW\tBIT_ULL(33)\n#define XHCI_RESET_PLL_ON_DISCONNECT\tBIT_ULL(34)\n#define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)\n#define XHCI_RENESAS_FW_QUIRK\tBIT_ULL(36)\n#define XHCI_SKIP_PHY_INIT\tBIT_ULL(37)\n#define XHCI_DISABLE_SPARSE\tBIT_ULL(38)\n#define XHCI_SG_TRB_CACHE_SIZE_QUIRK\tBIT_ULL(39)\n#define XHCI_NO_SOFT_RETRY\tBIT_ULL(40)\n#define XHCI_BROKEN_D3COLD_S2I\tBIT_ULL(41)\n#define XHCI_EP_CTX_BROKEN_DCS\tBIT_ULL(42)\n#define XHCI_SUSPEND_RESUME_CLKS\tBIT_ULL(43)\n#define XHCI_RESET_TO_DEFAULT\tBIT_ULL(44)\n#define XHCI_ZHAOXIN_TRB_FETCH\tBIT_ULL(45)\n#define XHCI_ZHAOXIN_HOST\tBIT_ULL(46)\n\n\tunsigned int\t\tnum_active_eps;\n\tunsigned int\t\tlimit_active_eps;\n\tstruct xhci_port\t*hw_ports;\n\tstruct xhci_hub\t\tusb2_rhub;\n\tstruct xhci_hub\t\tusb3_rhub;\n\t \n\tunsigned\t\thw_lpm_support:1;\n\t \n\tunsigned\t\tbroken_suspend:1;\n\t \n\tunsigned\t\tallow_single_roothub:1;\n\t \n\tu32                     *ext_caps;\n\tunsigned int            num_ext_caps;\n\t \n\tstruct xhci_port_cap\t*port_caps;\n\tunsigned int\t\tnum_port_caps;\n\t \n\tstruct timer_list\tcomp_mode_recovery_timer;\n\tu32\t\t\tport_status_u0;\n\tu16\t\t\ttest_mode;\n \n#define COMP_MODE_RCVRY_MSECS 2000\n\n\tstruct dentry\t\t*debugfs_root;\n\tstruct dentry\t\t*debugfs_slots;\n\tstruct list_head\tregset_list;\n\n\tvoid\t\t\t*dbc;\n\t \n\tunsigned long\t\tpriv[] __aligned(sizeof(s64));\n};\n\n \nstruct xhci_driver_overrides {\n\tsize_t extra_priv_size;\n\tint (*reset)(struct usb_hcd *hcd);\n\tint (*start)(struct usb_hcd *hcd);\n\tint (*add_endpoint)(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t\t    struct usb_host_endpoint *ep);\n\tint (*drop_endpoint)(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t\t     struct usb_host_endpoint *ep);\n\tint (*check_bandwidth)(struct usb_hcd *, struct usb_device *);\n\tvoid (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);\n\tint (*update_hub_device)(struct usb_hcd *hcd, struct usb_device *hdev,\n\t\t\t    struct usb_tt *tt, gfp_t mem_flags);\n\tint (*hub_control)(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t   u16 wIndex, char *buf, u16 wLength);\n};\n\n#define\tXHCI_CFC_DELAY\t\t10\n\n \nstatic inline struct xhci_hcd *hcd_to_xhci(struct usb_hcd *hcd)\n{\n\tstruct usb_hcd *primary_hcd;\n\n\tif (usb_hcd_is_primary_hcd(hcd))\n\t\tprimary_hcd = hcd;\n\telse\n\t\tprimary_hcd = hcd->primary_hcd;\n\n\treturn (struct xhci_hcd *) (primary_hcd->hcd_priv);\n}\n\nstatic inline struct usb_hcd *xhci_to_hcd(struct xhci_hcd *xhci)\n{\n\treturn xhci->main_hcd;\n}\n\nstatic inline struct usb_hcd *xhci_get_usb3_hcd(struct xhci_hcd *xhci)\n{\n\tif (xhci->shared_hcd)\n\t\treturn xhci->shared_hcd;\n\n\tif (!xhci->usb2_rhub.num_ports)\n\t\treturn xhci->main_hcd;\n\n\treturn NULL;\n}\n\nstatic inline bool xhci_hcd_is_usb3(struct usb_hcd *hcd)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\n\treturn hcd == xhci_get_usb3_hcd(xhci);\n}\n\nstatic inline bool xhci_has_one_roothub(struct xhci_hcd *xhci)\n{\n\treturn xhci->allow_single_roothub &&\n\t       (!xhci->usb2_rhub.num_ports || !xhci->usb3_rhub.num_ports);\n}\n\n#define xhci_dbg(xhci, fmt, args...) \\\n\tdev_dbg(xhci_to_hcd(xhci)->self.controller , fmt , ## args)\n#define xhci_err(xhci, fmt, args...) \\\n\tdev_err(xhci_to_hcd(xhci)->self.controller , fmt , ## args)\n#define xhci_warn(xhci, fmt, args...) \\\n\tdev_warn(xhci_to_hcd(xhci)->self.controller , fmt , ## args)\n#define xhci_warn_ratelimited(xhci, fmt, args...) \\\n\tdev_warn_ratelimited(xhci_to_hcd(xhci)->self.controller , fmt , ## args)\n#define xhci_info(xhci, fmt, args...) \\\n\tdev_info(xhci_to_hcd(xhci)->self.controller , fmt , ## args)\n\n \nstatic inline u64 xhci_read_64(const struct xhci_hcd *xhci,\n\t\t__le64 __iomem *regs)\n{\n\treturn lo_hi_readq(regs);\n}\nstatic inline void xhci_write_64(struct xhci_hcd *xhci,\n\t\t\t\t const u64 val, __le64 __iomem *regs)\n{\n\tlo_hi_writeq(val, regs);\n}\n\nstatic inline int xhci_link_trb_quirk(struct xhci_hcd *xhci)\n{\n\treturn xhci->quirks & XHCI_LINK_TRB_QUIRK;\n}\n\n \nchar *xhci_get_slot_state(struct xhci_hcd *xhci,\n\t\tstruct xhci_container_ctx *ctx);\nvoid xhci_dbg_trace(struct xhci_hcd *xhci, void (*trace)(struct va_format *),\n\t\t\tconst char *fmt, ...);\n\n \nvoid xhci_mem_cleanup(struct xhci_hcd *xhci);\nint xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags);\nvoid xhci_free_virt_device(struct xhci_hcd *xhci, int slot_id);\nint xhci_alloc_virt_device(struct xhci_hcd *xhci, int slot_id, struct usb_device *udev, gfp_t flags);\nint xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *udev);\nvoid xhci_copy_ep0_dequeue_into_input_ctx(struct xhci_hcd *xhci,\n\t\tstruct usb_device *udev);\nunsigned int xhci_get_endpoint_index(struct usb_endpoint_descriptor *desc);\nunsigned int xhci_last_valid_endpoint(u32 added_ctxs);\nvoid xhci_endpoint_zero(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev, struct usb_host_endpoint *ep);\nvoid xhci_update_tt_active_eps(struct xhci_hcd *xhci,\n\t\tstruct xhci_virt_device *virt_dev,\n\t\tint old_active_eps);\nvoid xhci_clear_endpoint_bw_info(struct xhci_bw_info *bw_info);\nvoid xhci_update_bw_info(struct xhci_hcd *xhci,\n\t\tstruct xhci_container_ctx *in_ctx,\n\t\tstruct xhci_input_control_ctx *ctrl_ctx,\n\t\tstruct xhci_virt_device *virt_dev);\nvoid xhci_endpoint_copy(struct xhci_hcd *xhci,\n\t\tstruct xhci_container_ctx *in_ctx,\n\t\tstruct xhci_container_ctx *out_ctx,\n\t\tunsigned int ep_index);\nvoid xhci_slot_copy(struct xhci_hcd *xhci,\n\t\tstruct xhci_container_ctx *in_ctx,\n\t\tstruct xhci_container_ctx *out_ctx);\nint xhci_endpoint_init(struct xhci_hcd *xhci, struct xhci_virt_device *virt_dev,\n\t\tstruct usb_device *udev, struct usb_host_endpoint *ep,\n\t\tgfp_t mem_flags);\nstruct xhci_ring *xhci_ring_alloc(struct xhci_hcd *xhci,\n\t\tunsigned int num_segs, unsigned int cycle_state,\n\t\tenum xhci_ring_type type, unsigned int max_packet, gfp_t flags);\nvoid xhci_ring_free(struct xhci_hcd *xhci, struct xhci_ring *ring);\nint xhci_ring_expansion(struct xhci_hcd *xhci, struct xhci_ring *ring,\n\t\tunsigned int num_trbs, gfp_t flags);\nint xhci_alloc_erst(struct xhci_hcd *xhci,\n\t\tstruct xhci_ring *evt_ring,\n\t\tstruct xhci_erst *erst,\n\t\tgfp_t flags);\nvoid xhci_initialize_ring_info(struct xhci_ring *ring,\n\t\t\tunsigned int cycle_state);\nvoid xhci_free_erst(struct xhci_hcd *xhci, struct xhci_erst *erst);\nvoid xhci_free_endpoint_ring(struct xhci_hcd *xhci,\n\t\tstruct xhci_virt_device *virt_dev,\n\t\tunsigned int ep_index);\nstruct xhci_stream_info *xhci_alloc_stream_info(struct xhci_hcd *xhci,\n\t\tunsigned int num_stream_ctxs,\n\t\tunsigned int num_streams,\n\t\tunsigned int max_packet, gfp_t flags);\nvoid xhci_free_stream_info(struct xhci_hcd *xhci,\n\t\tstruct xhci_stream_info *stream_info);\nvoid xhci_setup_streams_ep_input_ctx(struct xhci_hcd *xhci,\n\t\tstruct xhci_ep_ctx *ep_ctx,\n\t\tstruct xhci_stream_info *stream_info);\nvoid xhci_setup_no_streams_ep_input_ctx(struct xhci_ep_ctx *ep_ctx,\n\t\tstruct xhci_virt_ep *ep);\nvoid xhci_free_device_endpoint_resources(struct xhci_hcd *xhci,\n\tstruct xhci_virt_device *virt_dev, bool drop_control_ep);\nstruct xhci_ring *xhci_dma_to_transfer_ring(\n\t\tstruct xhci_virt_ep *ep,\n\t\tu64 address);\nstruct xhci_command *xhci_alloc_command(struct xhci_hcd *xhci,\n\t\tbool allocate_completion, gfp_t mem_flags);\nstruct xhci_command *xhci_alloc_command_with_ctx(struct xhci_hcd *xhci,\n\t\tbool allocate_completion, gfp_t mem_flags);\nvoid xhci_urb_free_priv(struct urb_priv *urb_priv);\nvoid xhci_free_command(struct xhci_hcd *xhci,\n\t\tstruct xhci_command *command);\nstruct xhci_container_ctx *xhci_alloc_container_ctx(struct xhci_hcd *xhci,\n\t\tint type, gfp_t flags);\nvoid xhci_free_container_ctx(struct xhci_hcd *xhci,\n\t\tstruct xhci_container_ctx *ctx);\n\n \ntypedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);\nint xhci_handshake(void __iomem *ptr, u32 mask, u32 done, u64 timeout_us);\nvoid xhci_quiesce(struct xhci_hcd *xhci);\nint xhci_halt(struct xhci_hcd *xhci);\nint xhci_start(struct xhci_hcd *xhci);\nint xhci_reset(struct xhci_hcd *xhci, u64 timeout_us);\nint xhci_run(struct usb_hcd *hcd);\nint xhci_gen_setup(struct usb_hcd *hcd, xhci_get_quirks_t get_quirks);\nvoid xhci_shutdown(struct usb_hcd *hcd);\nvoid xhci_stop(struct usb_hcd *hcd);\nvoid xhci_init_driver(struct hc_driver *drv,\n\t\t      const struct xhci_driver_overrides *over);\nint xhci_add_endpoint(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t      struct usb_host_endpoint *ep);\nint xhci_drop_endpoint(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t       struct usb_host_endpoint *ep);\nint xhci_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);\nvoid xhci_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev);\nint xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,\n\t\t\t   struct usb_tt *tt, gfp_t mem_flags);\nint xhci_disable_slot(struct xhci_hcd *xhci, u32 slot_id);\nint xhci_ext_cap_init(struct xhci_hcd *xhci);\n\nint xhci_suspend(struct xhci_hcd *xhci, bool do_wakeup);\nint xhci_resume(struct xhci_hcd *xhci, pm_message_t msg);\n\nirqreturn_t xhci_irq(struct usb_hcd *hcd);\nirqreturn_t xhci_msi_irq(int irq, void *hcd);\nint xhci_alloc_dev(struct usb_hcd *hcd, struct usb_device *udev);\nint xhci_alloc_tt_info(struct xhci_hcd *xhci,\n\t\tstruct xhci_virt_device *virt_dev,\n\t\tstruct usb_device *hdev,\n\t\tstruct usb_tt *tt, gfp_t mem_flags);\n\n \ndma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg, union xhci_trb *trb);\nstruct xhci_segment *trb_in_td(struct xhci_hcd *xhci,\n\t\tstruct xhci_segment *start_seg, union xhci_trb *start_trb,\n\t\tunion xhci_trb *end_trb, dma_addr_t suspect_dma, bool debug);\nint xhci_is_vendor_info_code(struct xhci_hcd *xhci, unsigned int trb_comp_code);\nvoid xhci_ring_cmd_db(struct xhci_hcd *xhci);\nint xhci_queue_slot_control(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tu32 trb_type, u32 slot_id);\nint xhci_queue_address_device(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tdma_addr_t in_ctx_ptr, u32 slot_id, enum xhci_setup_dev);\nint xhci_queue_vendor_command(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tu32 field1, u32 field2, u32 field3, u32 field4);\nint xhci_queue_stop_endpoint(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tint slot_id, unsigned int ep_index, int suspend);\nint xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,\n\t\tint slot_id, unsigned int ep_index);\nint xhci_queue_bulk_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,\n\t\tint slot_id, unsigned int ep_index);\nint xhci_queue_intr_tx(struct xhci_hcd *xhci, gfp_t mem_flags, struct urb *urb,\n\t\tint slot_id, unsigned int ep_index);\nint xhci_queue_isoc_tx_prepare(struct xhci_hcd *xhci, gfp_t mem_flags,\n\t\tstruct urb *urb, int slot_id, unsigned int ep_index);\nint xhci_queue_configure_endpoint(struct xhci_hcd *xhci,\n\t\tstruct xhci_command *cmd, dma_addr_t in_ctx_ptr, u32 slot_id,\n\t\tbool command_must_succeed);\nint xhci_queue_evaluate_context(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tdma_addr_t in_ctx_ptr, u32 slot_id, bool command_must_succeed);\nint xhci_queue_reset_ep(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tint slot_id, unsigned int ep_index,\n\t\tenum xhci_ep_reset_type reset_type);\nint xhci_queue_reset_device(struct xhci_hcd *xhci, struct xhci_command *cmd,\n\t\tu32 slot_id);\nvoid xhci_cleanup_stalled_ring(struct xhci_hcd *xhci, unsigned int slot_id,\n\t\t\t       unsigned int ep_index, unsigned int stream_id,\n\t\t\t       struct xhci_td *td);\nvoid xhci_stop_endpoint_command_watchdog(struct timer_list *t);\nvoid xhci_handle_command_timeout(struct work_struct *work);\n\nvoid xhci_ring_ep_doorbell(struct xhci_hcd *xhci, unsigned int slot_id,\n\t\tunsigned int ep_index, unsigned int stream_id);\nvoid xhci_ring_doorbell_for_active_rings(struct xhci_hcd *xhci,\n\t\tunsigned int slot_id,\n\t\tunsigned int ep_index);\nvoid xhci_cleanup_command_queue(struct xhci_hcd *xhci);\nvoid inc_deq(struct xhci_hcd *xhci, struct xhci_ring *ring);\nunsigned int count_trbs(u64 addr, u64 len);\n\n \nvoid xhci_set_link_state(struct xhci_hcd *xhci, struct xhci_port *port,\n\t\t\t\tu32 link_state);\nvoid xhci_test_and_clear_bit(struct xhci_hcd *xhci, struct xhci_port *port,\n\t\t\t\tu32 port_bit);\nint xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue, u16 wIndex,\n\t\tchar *buf, u16 wLength);\nint xhci_hub_status_data(struct usb_hcd *hcd, char *buf);\nint xhci_find_raw_port_number(struct usb_hcd *hcd, int port1);\nstruct xhci_hub *xhci_get_rhub(struct usb_hcd *hcd);\n\nvoid xhci_hc_died(struct xhci_hcd *xhci);\n\n#ifdef CONFIG_PM\nint xhci_bus_suspend(struct usb_hcd *hcd);\nint xhci_bus_resume(struct usb_hcd *hcd);\nunsigned long xhci_get_resuming_ports(struct usb_hcd *hcd);\n#else\n#define\txhci_bus_suspend\tNULL\n#define\txhci_bus_resume\t\tNULL\n#define\txhci_get_resuming_ports\tNULL\n#endif\t \n\nu32 xhci_port_state_to_neutral(u32 state);\nint xhci_find_slot_id_by_port(struct usb_hcd *hcd, struct xhci_hcd *xhci,\n\t\tu16 port);\nvoid xhci_ring_device(struct xhci_hcd *xhci, int slot_id);\n\n \nstruct xhci_input_control_ctx *xhci_get_input_control_ctx(struct xhci_container_ctx *ctx);\nstruct xhci_slot_ctx *xhci_get_slot_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx);\nstruct xhci_ep_ctx *xhci_get_ep_ctx(struct xhci_hcd *xhci, struct xhci_container_ctx *ctx, unsigned int ep_index);\n\nstruct xhci_ring *xhci_triad_to_transfer_ring(struct xhci_hcd *xhci,\n\t\tunsigned int slot_id, unsigned int ep_index,\n\t\tunsigned int stream_id);\n\nstatic inline struct xhci_ring *xhci_urb_to_transfer_ring(struct xhci_hcd *xhci,\n\t\t\t\t\t\t\t\tstruct urb *urb)\n{\n\treturn xhci_triad_to_transfer_ring(xhci, urb->dev->slot_id,\n\t\t\t\t\txhci_get_endpoint_index(&urb->ep->desc),\n\t\t\t\t\turb->stream_id);\n}\n\n \nstatic inline bool xhci_urb_suitable_for_idt(struct urb *urb)\n{\n\tif (!usb_endpoint_xfer_isoc(&urb->ep->desc) && usb_urb_dir_out(urb) &&\n\t    usb_endpoint_maxp(&urb->ep->desc) >= TRB_IDT_MAX_SIZE &&\n\t    urb->transfer_buffer_length <= TRB_IDT_MAX_SIZE &&\n\t    !(urb->transfer_flags & URB_NO_TRANSFER_DMA_MAP) &&\n\t    !urb->num_sgs)\n\t\treturn true;\n\n\treturn false;\n}\n\nstatic inline char *xhci_slot_state_string(u32 state)\n{\n\tswitch (state) {\n\tcase SLOT_STATE_ENABLED:\n\t\treturn \"enabled/disabled\";\n\tcase SLOT_STATE_DEFAULT:\n\t\treturn \"default\";\n\tcase SLOT_STATE_ADDRESSED:\n\t\treturn \"addressed\";\n\tcase SLOT_STATE_CONFIGURED:\n\t\treturn \"configured\";\n\tdefault:\n\t\treturn \"reserved\";\n\t}\n}\n\nstatic inline const char *xhci_decode_trb(char *str, size_t size,\n\t\t\t\t\t  u32 field0, u32 field1, u32 field2, u32 field3)\n{\n\tint type = TRB_FIELD_TO_TYPE(field3);\n\n\tswitch (type) {\n\tcase TRB_LINK:\n\t\tsnprintf(str, size,\n\t\t\t\"LINK %08x%08x intr %d type '%s' flags %c:%c:%c:%c\",\n\t\t\tfield1, field0, GET_INTR_TARGET(field2),\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield3 & TRB_IOC ? 'I' : 'i',\n\t\t\tfield3 & TRB_CHAIN ? 'C' : 'c',\n\t\t\tfield3 & TRB_TC ? 'T' : 't',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_TRANSFER:\n\tcase TRB_COMPLETION:\n\tcase TRB_PORT_STATUS:\n\tcase TRB_BANDWIDTH_EVENT:\n\tcase TRB_DOORBELL:\n\tcase TRB_HC_EVENT:\n\tcase TRB_DEV_NOTE:\n\tcase TRB_MFINDEX_WRAP:\n\t\tsnprintf(str, size,\n\t\t\t\"TRB %08x%08x status '%s' len %d slot %d ep %d type '%s' flags %c:%c\",\n\t\t\tfield1, field0,\n\t\t\txhci_trb_comp_code_string(GET_COMP_CODE(field2)),\n\t\t\tEVENT_TRB_LEN(field2), TRB_TO_SLOT_ID(field3),\n\t\t\t \n\t\t\tTRB_TO_EP_INDEX(field3) + 1,\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield3 & EVENT_DATA ? 'E' : 'e',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\n\t\tbreak;\n\tcase TRB_SETUP:\n\t\tsnprintf(str, size,\n\t\t\t\"bRequestType %02x bRequest %02x wValue %02x%02x wIndex %02x%02x wLength %d length %d TD size %d intr %d type '%s' flags %c:%c:%c\",\n\t\t\t\tfield0 & 0xff,\n\t\t\t\t(field0 & 0xff00) >> 8,\n\t\t\t\t(field0 & 0xff000000) >> 24,\n\t\t\t\t(field0 & 0xff0000) >> 16,\n\t\t\t\t(field1 & 0xff00) >> 8,\n\t\t\t\tfield1 & 0xff,\n\t\t\t\t(field1 & 0xff000000) >> 16 |\n\t\t\t\t(field1 & 0xff0000) >> 16,\n\t\t\t\tTRB_LEN(field2), GET_TD_SIZE(field2),\n\t\t\t\tGET_INTR_TARGET(field2),\n\t\t\t\txhci_trb_type_string(type),\n\t\t\t\tfield3 & TRB_IDT ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_IOC ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_DATA:\n\t\tsnprintf(str, size,\n\t\t\t \"Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c\",\n\t\t\t\tfield1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),\n\t\t\t\tGET_INTR_TARGET(field2),\n\t\t\t\txhci_trb_type_string(type),\n\t\t\t\tfield3 & TRB_IDT ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_IOC ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_CHAIN ? 'C' : 'c',\n\t\t\t\tfield3 & TRB_NO_SNOOP ? 'S' : 's',\n\t\t\t\tfield3 & TRB_ISP ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_ENT ? 'E' : 'e',\n\t\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_STATUS:\n\t\tsnprintf(str, size,\n\t\t\t \"Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c\",\n\t\t\t\tfield1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),\n\t\t\t\tGET_INTR_TARGET(field2),\n\t\t\t\txhci_trb_type_string(type),\n\t\t\t\tfield3 & TRB_IOC ? 'I' : 'i',\n\t\t\t\tfield3 & TRB_CHAIN ? 'C' : 'c',\n\t\t\t\tfield3 & TRB_ENT ? 'E' : 'e',\n\t\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_NORMAL:\n\tcase TRB_ISOC:\n\tcase TRB_EVENT_DATA:\n\tcase TRB_TR_NOOP:\n\t\tsnprintf(str, size,\n\t\t\t\"Buffer %08x%08x length %d TD size %d intr %d type '%s' flags %c:%c:%c:%c:%c:%c:%c:%c\",\n\t\t\tfield1, field0, TRB_LEN(field2), GET_TD_SIZE(field2),\n\t\t\tGET_INTR_TARGET(field2),\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield3 & TRB_BEI ? 'B' : 'b',\n\t\t\tfield3 & TRB_IDT ? 'I' : 'i',\n\t\t\tfield3 & TRB_IOC ? 'I' : 'i',\n\t\t\tfield3 & TRB_CHAIN ? 'C' : 'c',\n\t\t\tfield3 & TRB_NO_SNOOP ? 'S' : 's',\n\t\t\tfield3 & TRB_ISP ? 'I' : 'i',\n\t\t\tfield3 & TRB_ENT ? 'E' : 'e',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\n\tcase TRB_CMD_NOOP:\n\tcase TRB_ENABLE_SLOT:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_DISABLE_SLOT:\n\tcase TRB_NEG_BANDWIDTH:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: slot %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_ADDR_DEV:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: ctx %08x%08x slot %d flags %c:%c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tfield3 & TRB_BSR ? 'B' : 'b',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_CONFIG_EP:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: ctx %08x%08x slot %d flags %c:%c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tfield3 & TRB_DC ? 'D' : 'd',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_EVAL_CONTEXT:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: ctx %08x%08x slot %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_RESET_EP:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: ctx %08x%08x slot %d ep %d flags %c:%c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\t \n\t\t\tTRB_TO_EP_INDEX(field3) + 1,\n\t\t\tfield3 & TRB_TSP ? 'T' : 't',\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_STOP_RING:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: slot %d sp %d ep %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tTRB_TO_SUSPEND_PORT(field3),\n\t\t\t \n\t\t\tTRB_TO_EP_INDEX(field3) + 1,\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_SET_DEQ:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: deq %08x%08x stream %d slot %d ep %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_STREAM_ID(field2),\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\t \n\t\t\tTRB_TO_EP_INDEX(field3) + 1,\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_RESET_DEV:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: slot %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_FORCE_EVENT:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: event %08x%08x vf intr %d vf id %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_VF_INTR_TARGET(field2),\n\t\t\tTRB_TO_VF_ID(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_SET_LT:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: belt %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tTRB_TO_BELT(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_GET_BW:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: ctx %08x%08x slot %d speed %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield1, field0,\n\t\t\tTRB_TO_SLOT_ID(field3),\n\t\t\tTRB_TO_DEV_SPEED(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tcase TRB_FORCE_HEADER:\n\t\tsnprintf(str, size,\n\t\t\t\"%s: info %08x%08x%08x pkt type %d roothub port %d flags %c\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield2, field1, field0 & 0xffffffe0,\n\t\t\tTRB_TO_PACKET_TYPE(field0),\n\t\t\tTRB_TO_ROOTHUB_PORT(field3),\n\t\t\tfield3 & TRB_CYCLE ? 'C' : 'c');\n\t\tbreak;\n\tdefault:\n\t\tsnprintf(str, size,\n\t\t\t\"type '%s' -> raw %08x %08x %08x %08x\",\n\t\t\txhci_trb_type_string(type),\n\t\t\tfield0, field1, field2, field3);\n\t}\n\n\treturn str;\n}\n\nstatic inline const char *xhci_decode_ctrl_ctx(char *str,\n\t\tunsigned long drop, unsigned long add)\n{\n\tunsigned int\tbit;\n\tint\t\tret = 0;\n\n\tstr[0] = '\\0';\n\n\tif (drop) {\n\t\tret = sprintf(str, \"Drop:\");\n\t\tfor_each_set_bit(bit, &drop, 32)\n\t\t\tret += sprintf(str + ret, \" %d%s\",\n\t\t\t\t       bit / 2,\n\t\t\t\t       bit % 2 ? \"in\":\"out\");\n\t\tret += sprintf(str + ret, \", \");\n\t}\n\n\tif (add) {\n\t\tret += sprintf(str + ret, \"Add:%s%s\",\n\t\t\t       (add & SLOT_FLAG) ? \" slot\":\"\",\n\t\t\t       (add & EP0_FLAG) ? \" ep0\":\"\");\n\t\tadd &= ~(SLOT_FLAG | EP0_FLAG);\n\t\tfor_each_set_bit(bit, &add, 32)\n\t\t\tret += sprintf(str + ret, \" %d%s\",\n\t\t\t\t       bit / 2,\n\t\t\t\t       bit % 2 ? \"in\":\"out\");\n\t}\n\treturn str;\n}\n\nstatic inline const char *xhci_decode_slot_context(char *str,\n\t\tu32 info, u32 info2, u32 tt_info, u32 state)\n{\n\tu32 speed;\n\tu32 hub;\n\tu32 mtt;\n\tint ret = 0;\n\n\tspeed = info & DEV_SPEED;\n\thub = info & DEV_HUB;\n\tmtt = info & DEV_MTT;\n\n\tret = sprintf(str, \"RS %05x %s%s%s Ctx Entries %d MEL %d us Port# %d/%d\",\n\t\t\tinfo & ROUTE_STRING_MASK,\n\t\t\t({ char *s;\n\t\t\tswitch (speed) {\n\t\t\tcase SLOT_SPEED_FS:\n\t\t\t\ts = \"full-speed\";\n\t\t\t\tbreak;\n\t\t\tcase SLOT_SPEED_LS:\n\t\t\t\ts = \"low-speed\";\n\t\t\t\tbreak;\n\t\t\tcase SLOT_SPEED_HS:\n\t\t\t\ts = \"high-speed\";\n\t\t\t\tbreak;\n\t\t\tcase SLOT_SPEED_SS:\n\t\t\t\ts = \"super-speed\";\n\t\t\t\tbreak;\n\t\t\tcase SLOT_SPEED_SSP:\n\t\t\t\ts = \"super-speed plus\";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ts = \"UNKNOWN speed\";\n\t\t\t} s; }),\n\t\t\tmtt ? \" multi-TT\" : \"\",\n\t\t\thub ? \" Hub\" : \"\",\n\t\t\t(info & LAST_CTX_MASK) >> 27,\n\t\t\tinfo2 & MAX_EXIT,\n\t\t\tDEVINFO_TO_ROOT_HUB_PORT(info2),\n\t\t\tDEVINFO_TO_MAX_PORTS(info2));\n\n\tret += sprintf(str + ret, \" [TT Slot %d Port# %d TTT %d Intr %d] Addr %d State %s\",\n\t\t\ttt_info & TT_SLOT, (tt_info & TT_PORT) >> 8,\n\t\t\tGET_TT_THINK_TIME(tt_info), GET_INTR_TARGET(tt_info),\n\t\t\tstate & DEV_ADDR_MASK,\n\t\t\txhci_slot_state_string(GET_SLOT_STATE(state)));\n\n\treturn str;\n}\n\n\nstatic inline const char *xhci_portsc_link_state_string(u32 portsc)\n{\n\tswitch (portsc & PORT_PLS_MASK) {\n\tcase XDEV_U0:\n\t\treturn \"U0\";\n\tcase XDEV_U1:\n\t\treturn \"U1\";\n\tcase XDEV_U2:\n\t\treturn \"U2\";\n\tcase XDEV_U3:\n\t\treturn \"U3\";\n\tcase XDEV_DISABLED:\n\t\treturn \"Disabled\";\n\tcase XDEV_RXDETECT:\n\t\treturn \"RxDetect\";\n\tcase XDEV_INACTIVE:\n\t\treturn \"Inactive\";\n\tcase XDEV_POLLING:\n\t\treturn \"Polling\";\n\tcase XDEV_RECOVERY:\n\t\treturn \"Recovery\";\n\tcase XDEV_HOT_RESET:\n\t\treturn \"Hot Reset\";\n\tcase XDEV_COMP_MODE:\n\t\treturn \"Compliance mode\";\n\tcase XDEV_TEST_MODE:\n\t\treturn \"Test mode\";\n\tcase XDEV_RESUME:\n\t\treturn \"Resume\";\n\tdefault:\n\t\tbreak;\n\t}\n\treturn \"Unknown\";\n}\n\nstatic inline const char *xhci_decode_portsc(char *str, u32 portsc)\n{\n\tint ret;\n\n\tret = sprintf(str, \"%s %s %s Link:%s PortSpeed:%d \",\n\t\t      portsc & PORT_POWER\t? \"Powered\" : \"Powered-off\",\n\t\t      portsc & PORT_CONNECT\t? \"Connected\" : \"Not-connected\",\n\t\t      portsc & PORT_PE\t\t? \"Enabled\" : \"Disabled\",\n\t\t      xhci_portsc_link_state_string(portsc),\n\t\t      DEV_PORT_SPEED(portsc));\n\n\tif (portsc & PORT_OC)\n\t\tret += sprintf(str + ret, \"OverCurrent \");\n\tif (portsc & PORT_RESET)\n\t\tret += sprintf(str + ret, \"In-Reset \");\n\n\tret += sprintf(str + ret, \"Change: \");\n\tif (portsc & PORT_CSC)\n\t\tret += sprintf(str + ret, \"CSC \");\n\tif (portsc & PORT_PEC)\n\t\tret += sprintf(str + ret, \"PEC \");\n\tif (portsc & PORT_WRC)\n\t\tret += sprintf(str + ret, \"WRC \");\n\tif (portsc & PORT_OCC)\n\t\tret += sprintf(str + ret, \"OCC \");\n\tif (portsc & PORT_RC)\n\t\tret += sprintf(str + ret, \"PRC \");\n\tif (portsc & PORT_PLC)\n\t\tret += sprintf(str + ret, \"PLC \");\n\tif (portsc & PORT_CEC)\n\t\tret += sprintf(str + ret, \"CEC \");\n\tif (portsc & PORT_CAS)\n\t\tret += sprintf(str + ret, \"CAS \");\n\n\tret += sprintf(str + ret, \"Wake: \");\n\tif (portsc & PORT_WKCONN_E)\n\t\tret += sprintf(str + ret, \"WCE \");\n\tif (portsc & PORT_WKDISC_E)\n\t\tret += sprintf(str + ret, \"WDE \");\n\tif (portsc & PORT_WKOC_E)\n\t\tret += sprintf(str + ret, \"WOE \");\n\n\treturn str;\n}\n\nstatic inline const char *xhci_decode_usbsts(char *str, u32 usbsts)\n{\n\tint ret = 0;\n\n\tret = sprintf(str, \" 0x%08x\", usbsts);\n\n\tif (usbsts == ~(u32)0)\n\t\treturn str;\n\n\tif (usbsts & STS_HALT)\n\t\tret += sprintf(str + ret, \" HCHalted\");\n\tif (usbsts & STS_FATAL)\n\t\tret += sprintf(str + ret, \" HSE\");\n\tif (usbsts & STS_EINT)\n\t\tret += sprintf(str + ret, \" EINT\");\n\tif (usbsts & STS_PORT)\n\t\tret += sprintf(str + ret, \" PCD\");\n\tif (usbsts & STS_SAVE)\n\t\tret += sprintf(str + ret, \" SSS\");\n\tif (usbsts & STS_RESTORE)\n\t\tret += sprintf(str + ret, \" RSS\");\n\tif (usbsts & STS_SRE)\n\t\tret += sprintf(str + ret, \" SRE\");\n\tif (usbsts & STS_CNR)\n\t\tret += sprintf(str + ret, \" CNR\");\n\tif (usbsts & STS_HCE)\n\t\tret += sprintf(str + ret, \" HCE\");\n\n\treturn str;\n}\n\nstatic inline const char *xhci_decode_doorbell(char *str, u32 slot, u32 doorbell)\n{\n\tu8 ep;\n\tu16 stream;\n\tint ret;\n\n\tep = (doorbell & 0xff);\n\tstream = doorbell >> 16;\n\n\tif (slot == 0) {\n\t\tsprintf(str, \"Command Ring %d\", doorbell);\n\t\treturn str;\n\t}\n\tret = sprintf(str, \"Slot %d \", slot);\n\tif (ep > 0 && ep < 32)\n\t\tret = sprintf(str + ret, \"ep%d%s\",\n\t\t\t      ep / 2,\n\t\t\t      ep % 2 ? \"in\" : \"out\");\n\telse if (ep == 0 || ep < 248)\n\t\tret = sprintf(str + ret, \"Reserved %d\", ep);\n\telse\n\t\tret = sprintf(str + ret, \"Vendor Defined %d\", ep);\n\tif (stream)\n\t\tret = sprintf(str + ret, \" Stream %d\", stream);\n\n\treturn str;\n}\n\nstatic inline const char *xhci_ep_state_string(u8 state)\n{\n\tswitch (state) {\n\tcase EP_STATE_DISABLED:\n\t\treturn \"disabled\";\n\tcase EP_STATE_RUNNING:\n\t\treturn \"running\";\n\tcase EP_STATE_HALTED:\n\t\treturn \"halted\";\n\tcase EP_STATE_STOPPED:\n\t\treturn \"stopped\";\n\tcase EP_STATE_ERROR:\n\t\treturn \"error\";\n\tdefault:\n\t\treturn \"INVALID\";\n\t}\n}\n\nstatic inline const char *xhci_ep_type_string(u8 type)\n{\n\tswitch (type) {\n\tcase ISOC_OUT_EP:\n\t\treturn \"Isoc OUT\";\n\tcase BULK_OUT_EP:\n\t\treturn \"Bulk OUT\";\n\tcase INT_OUT_EP:\n\t\treturn \"Int OUT\";\n\tcase CTRL_EP:\n\t\treturn \"Ctrl\";\n\tcase ISOC_IN_EP:\n\t\treturn \"Isoc IN\";\n\tcase BULK_IN_EP:\n\t\treturn \"Bulk IN\";\n\tcase INT_IN_EP:\n\t\treturn \"Int IN\";\n\tdefault:\n\t\treturn \"INVALID\";\n\t}\n}\n\nstatic inline const char *xhci_decode_ep_context(char *str, u32 info,\n\t\tu32 info2, u64 deq, u32 tx_info)\n{\n\tint ret;\n\n\tu32 esit;\n\tu16 maxp;\n\tu16 avg;\n\n\tu8 max_pstr;\n\tu8 ep_state;\n\tu8 interval;\n\tu8 ep_type;\n\tu8 burst;\n\tu8 cerr;\n\tu8 mult;\n\n\tbool lsa;\n\tbool hid;\n\n\tesit = CTX_TO_MAX_ESIT_PAYLOAD_HI(info) << 16 |\n\t\tCTX_TO_MAX_ESIT_PAYLOAD(tx_info);\n\n\tep_state = info & EP_STATE_MASK;\n\tmax_pstr = CTX_TO_EP_MAXPSTREAMS(info);\n\tinterval = CTX_TO_EP_INTERVAL(info);\n\tmult = CTX_TO_EP_MULT(info) + 1;\n\tlsa = !!(info & EP_HAS_LSA);\n\n\tcerr = (info2 & (3 << 1)) >> 1;\n\tep_type = CTX_TO_EP_TYPE(info2);\n\thid = !!(info2 & (1 << 7));\n\tburst = CTX_TO_MAX_BURST(info2);\n\tmaxp = MAX_PACKET_DECODED(info2);\n\n\tavg = EP_AVG_TRB_LENGTH(tx_info);\n\n\tret = sprintf(str, \"State %s mult %d max P. Streams %d %s\",\n\t\t\txhci_ep_state_string(ep_state), mult,\n\t\t\tmax_pstr, lsa ? \"LSA \" : \"\");\n\n\tret += sprintf(str + ret, \"interval %d us max ESIT payload %d CErr %d \",\n\t\t\t(1 << interval) * 125, esit, cerr);\n\n\tret += sprintf(str + ret, \"Type %s %sburst %d maxp %d deq %016llx \",\n\t\t\txhci_ep_type_string(ep_type), hid ? \"HID\" : \"\",\n\t\t\tburst, maxp, deq);\n\n\tret += sprintf(str + ret, \"avg trb len %d\", avg);\n\n\treturn str;\n}\n\n#endif  \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}