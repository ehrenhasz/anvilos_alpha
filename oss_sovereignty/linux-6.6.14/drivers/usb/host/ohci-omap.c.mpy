{
  "module_name": "ohci-omap.c",
  "hash_id": "1a3016b098907b050b4656ec8cf135acf7f9671b65e67305954e5cb525821d0b",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-omap.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/usb/otg.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/usb-omap1.h>\n#include <linux/soc/ti/omap1-usb.h>\n#include <linux/soc/ti/omap1-mux.h>\n#include <linux/soc/ti/omap1-soc.h>\n#include <linux/soc/ti/omap1-io.h>\n#include <linux/signal.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ohci.h\"\n\n#include <asm/io.h>\n#include <asm/mach-types.h>\n\n#define DRIVER_DESC \"OHCI OMAP driver\"\n\nstruct ohci_omap_priv {\n\tstruct clk *usb_host_ck;\n\tstruct clk *usb_dc_ck;\n\tstruct gpio_desc *power;\n\tstruct gpio_desc *overcurrent;\n};\n\nstatic const char hcd_name[] = \"ohci-omap\";\nstatic struct hc_driver __read_mostly ohci_omap_hc_driver;\n\n#define hcd_to_ohci_omap_priv(h) \\\n\t((struct ohci_omap_priv *)hcd_to_ohci(h)->priv)\n\nstatic void omap_ohci_clock_power(struct ohci_omap_priv *priv, int on)\n{\n\tif (on) {\n\t\tclk_enable(priv->usb_dc_ck);\n\t\tclk_enable(priv->usb_host_ck);\n\t\t \n\t\tudelay(100);\n\t} else {\n\t\tclk_disable(priv->usb_host_ck);\n\t\tclk_disable(priv->usb_dc_ck);\n\t}\n}\n\nstatic void start_hnp(struct ohci_hcd *ohci)\n{\n\tstruct usb_hcd *hcd = ohci_to_hcd(ohci);\n\tconst unsigned\tport = hcd->self.otg_port - 1;\n\tunsigned long\tflags;\n\tu32 l;\n\n\totg_start_hnp(hcd->usb_phy->otg);\n\n\tlocal_irq_save(flags);\n\thcd->usb_phy->otg->state = OTG_STATE_A_SUSPEND;\n\twritel (RH_PS_PSS, &ohci->regs->roothub.portstatus [port]);\n\tl = omap_readl(OTG_CTRL);\n\tl &= ~OTG_A_BUSREQ;\n\tomap_writel(l, OTG_CTRL);\n\tlocal_irq_restore(flags);\n}\n\n \n\nstatic int ohci_omap_reset(struct usb_hcd *hcd)\n{\n\tstruct ohci_hcd\t\t*ohci = hcd_to_ohci(hcd);\n\tstruct omap_usb_config\t*config = dev_get_platdata(hcd->self.controller);\n\tstruct ohci_omap_priv\t*priv = hcd_to_ohci_omap_priv(hcd);\n\tint\t\t\tneed_transceiver = (config->otg != 0);\n\tint\t\t\tret;\n\n\tdev_dbg(hcd->self.controller, \"starting USB Controller\\n\");\n\n\tif (config->otg) {\n\t\thcd->self.otg_port = config->otg;\n\t\t \n\t\thcd->power_budget = 8;\n\t}\n\n\t \n\tif (config->ocpi_enable)\n\t\tconfig->ocpi_enable();\n\n\tif (IS_ENABLED(CONFIG_USB_OTG) && need_transceiver) {\n\t\thcd->usb_phy = usb_get_phy(USB_PHY_TYPE_USB2);\n\t\tif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\n\t\t\tint\tstatus = otg_set_host(hcd->usb_phy->otg,\n\t\t\t\t\t\t&ohci_to_hcd(ohci)->self);\n\t\t\tdev_dbg(hcd->self.controller, \"init %s phy, status %d\\n\",\n\t\t\t\t\thcd->usb_phy->label, status);\n\t\t\tif (status) {\n\t\t\t\tusb_put_phy(hcd->usb_phy);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t} else {\n\t\t\treturn -EPROBE_DEFER;\n\t\t}\n\t\thcd->skip_phy_initialization = 1;\n\t\tohci->start_hnp = start_hnp;\n\t}\n\n\tomap_ohci_clock_power(priv, 1);\n\n\tif (config->lb_reset)\n\t\tconfig->lb_reset();\n\n\tret = ohci_setup(hcd);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tif (config->otg || config->rwc) {\n\t\tohci->hc_control = OHCI_CTRL_RWC;\n\t\twritel(OHCI_CTRL_RWC, &ohci->regs->control);\n\t}\n\n\t \n\tif (machine_is_omap_osk()) {\n\t\tu32\trh = roothub_a (ohci);\n\n\t\t \n\t\trh &= ~RH_A_NPS;\n\n\t\t \n\t\tif (machine_is_omap_osk()) {\n\t\t\tohci_to_hcd(ohci)->power_budget = 250;\n\n\t\t\trh &= ~RH_A_NOCP;\n\n\t\t\t \n\t\t\tomap_cfg_reg(W8_1610_GPIO9);\n\n\t\t\t \n\t\t\tomap_cfg_reg(W4_USB_HIGHZ);\n\t\t}\n\t\tohci_writel(ohci, rh, &ohci->regs->roothub.a);\n\t\tohci->flags &= ~OHCI_QUIRK_HUB_POWER;\n\t} else if (machine_is_nokia770()) {\n\t\t \n\t\tohci_to_hcd(ohci)->power_budget = 0;\n\t}\n\n\t \n\tif (config->transceiver_power)\n\t\treturn config->transceiver_power(1);\n\n\tif (priv->power)\n\t\tgpiod_set_value_cansleep(priv->power, 0);\n\n\t \n\n\treturn 0;\n}\n\n \n\n \nstatic int ohci_hcd_omap_probe(struct platform_device *pdev)\n{\n\tint retval, irq;\n\tstruct usb_hcd *hcd = 0;\n\tstruct ohci_omap_priv *priv;\n\n\tif (pdev->num_resources != 2) {\n\t\tdev_err(&pdev->dev, \"invalid num_resources: %i\\n\",\n\t\t       pdev->num_resources);\n\t\treturn -ENODEV;\n\t}\n\n\tif (pdev->resource[0].flags != IORESOURCE_MEM\n\t\t\t|| pdev->resource[1].flags != IORESOURCE_IRQ) {\n\t\tdev_err(&pdev->dev, \"invalid resource type\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\thcd = usb_create_hcd(&ohci_omap_hc_driver, &pdev->dev,\n\t\t\tdev_name(&pdev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = pdev->resource[0].start;\n\thcd->rsrc_len = pdev->resource[0].end - pdev->resource[0].start + 1;\n\tpriv = hcd_to_ohci_omap_priv(hcd);\n\n\t \n\tpriv->power = devm_gpiod_get_optional(&pdev->dev, \"power\", GPIOD_ASIS);\n\tif (IS_ERR(priv->power)) {\n\t\tretval = PTR_ERR(priv->power);\n\t\tgoto err_put_hcd;\n\t}\n\tif (priv->power)\n\t\tgpiod_set_consumer_name(priv->power, \"OHCI power\");\n\n\t \n\tpriv->overcurrent = devm_gpiod_get_optional(&pdev->dev, \"overcurrent\",\n\t\t\t\t\t\t    GPIOD_IN);\n\tif (IS_ERR(priv->overcurrent)) {\n\t\tretval = PTR_ERR(priv->overcurrent);\n\t\tgoto err_put_hcd;\n\t}\n\tif (priv->overcurrent)\n\t\tgpiod_set_consumer_name(priv->overcurrent, \"OHCI overcurrent\");\n\n\tpriv->usb_host_ck = clk_get(&pdev->dev, \"usb_hhc_ck\");\n\tif (IS_ERR(priv->usb_host_ck)) {\n\t\tretval = PTR_ERR(priv->usb_host_ck);\n\t\tgoto err_put_hcd;\n\t}\n\n\tretval = clk_prepare(priv->usb_host_ck);\n\tif (retval)\n\t\tgoto err_put_host_ck;\n\n\tif (!cpu_is_omap15xx())\n\t\tpriv->usb_dc_ck = clk_get(&pdev->dev, \"usb_dc_ck\");\n\telse\n\t\tpriv->usb_dc_ck = clk_get(&pdev->dev, \"lb_ck\");\n\n\tif (IS_ERR(priv->usb_dc_ck)) {\n\t\tretval = PTR_ERR(priv->usb_dc_ck);\n\t\tgoto err_unprepare_host_ck;\n\t}\n\n\tretval = clk_prepare(priv->usb_dc_ck);\n\tif (retval)\n\t\tgoto err_put_dc_ck;\n\n\tif (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len, hcd_name)) {\n\t\tdev_dbg(&pdev->dev, \"request_mem_region failed\\n\");\n\t\tretval = -EBUSY;\n\t\tgoto err_unprepare_dc_ck;\n\t}\n\n\thcd->regs = ioremap(hcd->rsrc_start, hcd->rsrc_len);\n\tif (!hcd->regs) {\n\t\tdev_err(&pdev->dev, \"can't ioremap OHCI HCD\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto err2;\n\t}\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tretval = irq;\n\t\tgoto err3;\n\t}\n\tretval = usb_add_hcd(hcd, irq, 0);\n\tif (retval)\n\t\tgoto err3;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\treturn 0;\nerr3:\n\tiounmap(hcd->regs);\nerr2:\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\nerr_unprepare_dc_ck:\n\tclk_unprepare(priv->usb_dc_ck);\nerr_put_dc_ck:\n\tclk_put(priv->usb_dc_ck);\nerr_unprepare_host_ck:\n\tclk_unprepare(priv->usb_host_ck);\nerr_put_host_ck:\n\tclk_put(priv->usb_host_ck);\nerr_put_hcd:\n\tusb_put_hcd(hcd);\n\treturn retval;\n}\n\n\n \n\n \nstatic void ohci_hcd_omap_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(pdev);\n\tstruct ohci_omap_priv *priv = hcd_to_ohci_omap_priv(hcd);\n\n\tdev_dbg(hcd->self.controller, \"stopping USB Controller\\n\");\n\tusb_remove_hcd(hcd);\n\tomap_ohci_clock_power(priv, 0);\n\tif (!IS_ERR_OR_NULL(hcd->usb_phy)) {\n\t\t(void) otg_set_host(hcd->usb_phy->otg, 0);\n\t\tusb_put_phy(hcd->usb_phy);\n\t}\n\tiounmap(hcd->regs);\n\trelease_mem_region(hcd->rsrc_start, hcd->rsrc_len);\n\tclk_unprepare(priv->usb_dc_ck);\n\tclk_put(priv->usb_dc_ck);\n\tclk_unprepare(priv->usb_host_ck);\n\tclk_put(priv->usb_host_ck);\n\tusb_put_hcd(hcd);\n}\n\n \n\n#ifdef\tCONFIG_PM\n\nstatic int ohci_omap_suspend(struct platform_device *pdev, pm_message_t message)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct ohci_hcd *ohci = hcd_to_ohci(hcd);\n\tstruct ohci_omap_priv *priv = hcd_to_ohci_omap_priv(hcd);\n\tbool do_wakeup = device_may_wakeup(&pdev->dev);\n\tint ret;\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tret = ohci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tomap_ohci_clock_power(priv, 0);\n\treturn ret;\n}\n\nstatic int ohci_omap_resume(struct platform_device *dev)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(dev);\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\tstruct ohci_omap_priv *priv = hcd_to_ohci_omap_priv(hcd);\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tomap_ohci_clock_power(priv, 1);\n\tohci_resume(hcd, false);\n\treturn 0;\n}\n\n#endif\n\n \n\n \nstatic struct platform_driver ohci_hcd_omap_driver = {\n\t.probe\t\t= ohci_hcd_omap_probe,\n\t.remove_new\t= ohci_hcd_omap_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n#ifdef\tCONFIG_PM\n\t.suspend\t= ohci_omap_suspend,\n\t.resume\t\t= ohci_omap_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= \"ohci\",\n\t},\n};\n\nstatic const struct ohci_driver_overrides omap_overrides __initconst = {\n\t.product_desc\t= \"OMAP OHCI\",\n\t.reset\t\t= ohci_omap_reset,\n\t.extra_priv_size = sizeof(struct ohci_omap_priv),\n};\n\nstatic int __init ohci_omap_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_omap_hc_driver, &omap_overrides);\n\treturn platform_driver_register(&ohci_hcd_omap_driver);\n}\nmodule_init(ohci_omap_init);\n\nstatic void __exit ohci_omap_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_omap_driver);\n}\nmodule_exit(ohci_omap_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_ALIAS(\"platform:ohci\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}