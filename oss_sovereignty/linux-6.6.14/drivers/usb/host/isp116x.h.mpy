{
  "module_name": "isp116x.h",
  "hash_id": "992c7ebff89d5db99e0097f572f5ab66cc2d6eea12c058b86ac60d795c74a946",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/isp116x.h",
  "human_readable_source": " \n \n\n \n#define  MAX_LOAD_LIMIT\t\t850\n\n \n#define MAX_TRANSFER_SIZE_FULLSPEED\t832\n\n \n#define MAX_TRANSFER_SIZE_LOWSPEED\t64\n\n \n#define BYTE_TIME_FULLSPEED\t1\n#define BYTE_TIME_LOWSPEED\t20\n\n \n#define ISP116x_BUF_SIZE\t4096\n#define ISP116x_ITL_BUFSIZE\t0\n#define ISP116x_ATL_BUFSIZE\t((ISP116x_BUF_SIZE) - 2*(ISP116x_ITL_BUFSIZE))\n\n#define ISP116x_WRITE_OFFSET\t0x80\n\n \n#define\tHCREVISION\t0x00\n#define\tHCCONTROL\t0x01\n#define\t\tHCCONTROL_HCFS\t(3 << 6)\t \n#define\t\tHCCONTROL_USB_RESET\t(0 << 6)\n#define\t\tHCCONTROL_USB_RESUME\t(1 << 6)\n#define\t\tHCCONTROL_USB_OPER\t(2 << 6)\n#define\t\tHCCONTROL_USB_SUSPEND\t(3 << 6)\n#define\t\tHCCONTROL_RWC\t(1 << 9)\t \n#define\t\tHCCONTROL_RWE\t(1 << 10)\t \n#define\tHCCMDSTAT\t0x02\n#define\t\tHCCMDSTAT_HCR\t(1 << 0)\t \n#define\t\tHCCMDSTAT_SOC\t(3 << 16)\t \n#define\tHCINTSTAT\t0x03\n#define\t\tHCINT_SO\t(1 << 0)\t \n#define\t\tHCINT_WDH\t(1 << 1)\t \n#define\t\tHCINT_SF\t(1 << 2)\t \n#define\t\tHCINT_RD\t(1 << 3)\t \n#define\t\tHCINT_UE\t(1 << 4)\t \n#define\t\tHCINT_FNO\t(1 << 5)\t \n#define\t\tHCINT_RHSC\t(1 << 6)\t \n#define\t\tHCINT_OC\t(1 << 30)\t \n#define\t\tHCINT_MIE\t(1 << 31)\t \n#define\tHCINTENB\t0x04\n#define\tHCINTDIS\t0x05\n#define\tHCFMINTVL\t0x0d\n#define\tHCFMREM\t\t0x0e\n#define\tHCFMNUM\t\t0x0f\n#define\tHCLSTHRESH\t0x11\n#define\tHCRHDESCA\t0x12\n#define\t\tRH_A_NDP\t(0x3 << 0)\t \n#define\t\tRH_A_PSM\t(1 << 8)\t \n#define\t\tRH_A_NPS\t(1 << 9)\t \n#define\t\tRH_A_DT\t\t(1 << 10)\t \n#define\t\tRH_A_OCPM\t(1 << 11)\t \n#define\t\tRH_A_NOCP\t(1 << 12)\t \n#define\t\tRH_A_POTPGT\t(0xff << 24)\t \n#define\tHCRHDESCB\t0x13\n#define\t\tRH_B_DR\t\t(0xffff << 0)\t \n#define\t\tRH_B_PPCM\t(0xffff << 16)\t \n#define\tHCRHSTATUS\t0x14\n#define\t\tRH_HS_LPS\t(1 << 0)\t \n#define\t\tRH_HS_OCI\t(1 << 1)\t \n#define\t\tRH_HS_DRWE\t(1 << 15)\t \n#define\t\tRH_HS_LPSC\t(1 << 16)\t \n#define\t\tRH_HS_OCIC\t(1 << 17)\t \n#define\t\tRH_HS_CRWE\t(1 << 31)\t \n#define\tHCRHPORT1\t0x15\n#define\t\tRH_PS_CCS\t(1 << 0)\t \n#define\t\tRH_PS_PES\t(1 << 1)\t \n#define\t\tRH_PS_PSS\t(1 << 2)\t \n#define\t\tRH_PS_POCI\t(1 << 3)\t \n#define\t\tRH_PS_PRS\t(1 << 4)\t \n#define\t\tRH_PS_PPS\t(1 << 8)\t \n#define\t\tRH_PS_LSDA\t(1 << 9)\t \n#define\t\tRH_PS_CSC\t(1 << 16)\t \n#define\t\tRH_PS_PESC\t(1 << 17)\t \n#define\t\tRH_PS_PSSC\t(1 << 18)\t \n#define\t\tRH_PS_OCIC\t(1 << 19)\t \n#define\t\tRH_PS_PRSC\t(1 << 20)\t \n#define\t\tHCRHPORT_CLRMASK\t(0x1f << 16)\n#define\tHCRHPORT2\t0x16\n#define\tHCHWCFG\t\t0x20\n#define\t\tHCHWCFG_15KRSEL\t\t(1 << 12)\n#define\t\tHCHWCFG_CLKNOTSTOP\t(1 << 11)\n#define\t\tHCHWCFG_ANALOG_OC\t(1 << 10)\n#define\t\tHCHWCFG_DACK_MODE\t(1 << 8)\n#define\t\tHCHWCFG_EOT_POL\t\t(1 << 7)\n#define\t\tHCHWCFG_DACK_POL\t(1 << 6)\n#define\t\tHCHWCFG_DREQ_POL\t(1 << 5)\n#define\t\tHCHWCFG_DBWIDTH_MASK\t(0x03 << 3)\n#define\t\tHCHWCFG_DBWIDTH(n)\t(((n) << 3) & HCHWCFG_DBWIDTH_MASK)\n#define\t\tHCHWCFG_INT_POL\t\t(1 << 2)\n#define\t\tHCHWCFG_INT_TRIGGER\t(1 << 1)\n#define\t\tHCHWCFG_INT_ENABLE\t(1 << 0)\n#define\tHCDMACFG\t0x21\n#define\t\tHCDMACFG_BURST_LEN_MASK\t(0x03 << 5)\n#define\t\tHCDMACFG_BURST_LEN(n)\t(((n) << 5) & HCDMACFG_BURST_LEN_MASK)\n#define\t\tHCDMACFG_BURST_LEN_1\tHCDMACFG_BURST_LEN(0)\n#define\t\tHCDMACFG_BURST_LEN_4\tHCDMACFG_BURST_LEN(1)\n#define\t\tHCDMACFG_BURST_LEN_8\tHCDMACFG_BURST_LEN(2)\n#define\t\tHCDMACFG_DMA_ENABLE\t(1 << 4)\n#define\t\tHCDMACFG_BUF_TYPE_MASK\t(0x07 << 1)\n#define\t\tHCDMACFG_CTR_SEL\t(1 << 2)\n#define\t\tHCDMACFG_ITLATL_SEL\t(1 << 1)\n#define\t\tHCDMACFG_DMA_RW_SELECT\t(1 << 0)\n#define\tHCXFERCTR\t0x22\n#define\tHCuPINT\t\t0x24\n#define\t\tHCuPINT_SOF\t\t(1 << 0)\n#define\t\tHCuPINT_ATL\t\t(1 << 1)\n#define\t\tHCuPINT_AIIEOT\t\t(1 << 2)\n#define\t\tHCuPINT_OPR\t\t(1 << 4)\n#define\t\tHCuPINT_SUSP\t\t(1 << 5)\n#define\t\tHCuPINT_CLKRDY\t\t(1 << 6)\n#define\tHCuPINTENB\t0x25\n#define\tHCCHIPID\t0x27\n#define\t\tHCCHIPID_MASK\t\t0xff00\n#define\t\tHCCHIPID_MAGIC\t\t0x6100\n#define\tHCSCRATCH\t0x28\n#define\tHCSWRES\t\t0x29\n#define\t\tHCSWRES_MAGIC\t\t0x00f6\n#define\tHCITLBUFLEN\t0x2a\n#define\tHCATLBUFLEN\t0x2b\n#define\tHCBUFSTAT\t0x2c\n#define\t\tHCBUFSTAT_ITL0_FULL\t(1 << 0)\n#define\t\tHCBUFSTAT_ITL1_FULL\t(1 << 1)\n#define\t\tHCBUFSTAT_ATL_FULL\t(1 << 2)\n#define\t\tHCBUFSTAT_ITL0_DONE\t(1 << 3)\n#define\t\tHCBUFSTAT_ITL1_DONE\t(1 << 4)\n#define\t\tHCBUFSTAT_ATL_DONE\t(1 << 5)\n#define\tHCRDITL0LEN\t0x2d\n#define\tHCRDITL1LEN\t0x2e\n#define\tHCITLPORT\t0x40\n#define\tHCATLPORT\t0x41\n\n \nstruct ptd {\n\tu16 count;\n#define\tPTD_COUNT_MSK\t(0x3ff << 0)\n#define\tPTD_TOGGLE_MSK\t(1 << 10)\n#define\tPTD_ACTIVE_MSK\t(1 << 11)\n#define\tPTD_CC_MSK\t(0xf << 12)\n\tu16 mps;\n#define\tPTD_MPS_MSK\t(0x3ff << 0)\n#define\tPTD_SPD_MSK\t(1 << 10)\n#define\tPTD_LAST_MSK\t(1 << 11)\n#define\tPTD_EP_MSK\t(0xf << 12)\n\tu16 len;\n#define\tPTD_LEN_MSK\t(0x3ff << 0)\n#define\tPTD_DIR_MSK\t(3 << 10)\n#define\tPTD_DIR_SETUP\t(0)\n#define\tPTD_DIR_OUT\t(1)\n#define\tPTD_DIR_IN\t(2)\n#define\tPTD_B5_5_MSK\t(1 << 13)\n\tu16 faddr;\n#define\tPTD_FA_MSK\t(0x7f << 0)\n#define\tPTD_FMT_MSK\t(1 << 7)\n} __attribute__ ((packed, aligned(2)));\n\n \n#define PTD_GET_COUNT(p)\t(((p)->count & PTD_COUNT_MSK) >> 0)\n#define PTD_COUNT(v)\t\t(((v) << 0) & PTD_COUNT_MSK)\n#define PTD_GET_TOGGLE(p)\t(((p)->count & PTD_TOGGLE_MSK) >> 10)\n#define PTD_TOGGLE(v)\t\t(((v) << 10) & PTD_TOGGLE_MSK)\n#define PTD_GET_ACTIVE(p)\t(((p)->count & PTD_ACTIVE_MSK) >> 11)\n#define PTD_ACTIVE(v)\t\t(((v) << 11) & PTD_ACTIVE_MSK)\n#define PTD_GET_CC(p)\t\t(((p)->count & PTD_CC_MSK) >> 12)\n#define PTD_CC(v)\t\t(((v) << 12) & PTD_CC_MSK)\n#define PTD_GET_MPS(p)\t\t(((p)->mps & PTD_MPS_MSK) >> 0)\n#define PTD_MPS(v)\t\t(((v) << 0) & PTD_MPS_MSK)\n#define PTD_GET_SPD(p)\t\t(((p)->mps & PTD_SPD_MSK) >> 10)\n#define PTD_SPD(v)\t\t(((v) << 10) & PTD_SPD_MSK)\n#define PTD_GET_LAST(p)\t\t(((p)->mps & PTD_LAST_MSK) >> 11)\n#define PTD_LAST(v)\t\t(((v) << 11) & PTD_LAST_MSK)\n#define PTD_GET_EP(p)\t\t(((p)->mps & PTD_EP_MSK) >> 12)\n#define PTD_EP(v)\t\t(((v) << 12) & PTD_EP_MSK)\n#define PTD_GET_LEN(p)\t\t(((p)->len & PTD_LEN_MSK) >> 0)\n#define PTD_LEN(v)\t\t(((v) << 0) & PTD_LEN_MSK)\n#define PTD_GET_DIR(p)\t\t(((p)->len & PTD_DIR_MSK) >> 10)\n#define PTD_DIR(v)\t\t(((v) << 10) & PTD_DIR_MSK)\n#define PTD_GET_B5_5(p)\t\t(((p)->len & PTD_B5_5_MSK) >> 13)\n#define PTD_B5_5(v)\t\t(((v) << 13) & PTD_B5_5_MSK)\n#define PTD_GET_FA(p)\t\t(((p)->faddr & PTD_FA_MSK) >> 0)\n#define PTD_FA(v)\t\t(((v) << 0) & PTD_FA_MSK)\n#define PTD_GET_FMT(p)\t\t(((p)->faddr & PTD_FMT_MSK) >> 7)\n#define PTD_FMT(v)\t\t(((v) << 7) & PTD_FMT_MSK)\n\n \n#define TD_CC_NOERROR      0x00\n#define TD_CC_CRC          0x01\n#define TD_CC_BITSTUFFING  0x02\n#define TD_CC_DATATOGGLEM  0x03\n#define TD_CC_STALL        0x04\n#define TD_DEVNOTRESP      0x05\n#define TD_PIDCHECKFAIL    0x06\n#define TD_UNEXPECTEDPID   0x07\n#define TD_DATAOVERRUN     0x08\n#define TD_DATAUNDERRUN    0x09\n     \n#define TD_BUFFEROVERRUN   0x0C\n#define TD_BUFFERUNDERRUN  0x0D\n     \n#define TD_NOTACCESSED     0x0F\n\n \nstatic const int cc_to_error[16] = {\n\t  0,\n\t  -EILSEQ,\n\t  -EPROTO,\n\t  -EILSEQ,\n\t  -EPIPE,\n\t  -ETIME,\n\t  -EPROTO,\n\t  -EPROTO,\n\t  -EOVERFLOW,\n\t  -EREMOTEIO,\n\t  -EIO,\n\t  -EIO,\n\t  -ECOMM,\n\t  -ENOSR,\n\t  -EALREADY,\n\t  -EALREADY\n};\n\n \n\n#define\tLOG2_PERIODIC_SIZE\t5\t \n#define\tPERIODIC_SIZE\t\t(1 << LOG2_PERIODIC_SIZE)\n\nstruct isp116x {\n\tspinlock_t lock;\n\n\tvoid __iomem *addr_reg;\n\tvoid __iomem *data_reg;\n\n\tstruct isp116x_platform_data *board;\n\n\tunsigned long stat1, stat2, stat4, stat8, stat16;\n\n\t \n\tu32 intenb;\t\t \n\tu16 irqenb;\t\t \n\n\t \n\tu32 rhdesca;\n\tu32 rhdescb;\n\tu32 rhstatus;\n\n\t \n\tstruct list_head async;\n\n\t \n\tu16 load[PERIODIC_SIZE];\n\tstruct isp116x_ep *periodic[PERIODIC_SIZE];\n\tunsigned periodic_count;\n\tu16 fmindex;\n\n\t \n\tstruct isp116x_ep *atl_active;\n\tint atl_buflen;\n\tint atl_bufshrt;\n\tint atl_last_dir;\n\tatomic_t atl_finishing;\n};\n\nstatic inline struct isp116x *hcd_to_isp116x(struct usb_hcd *hcd)\n{\n\treturn (struct isp116x *)(hcd->hcd_priv);\n}\n\nstatic inline struct usb_hcd *isp116x_to_hcd(struct isp116x *isp116x)\n{\n\treturn container_of((void *)isp116x, struct usb_hcd, hcd_priv);\n}\n\nstruct isp116x_ep {\n\tstruct usb_host_endpoint *hep;\n\tstruct usb_device *udev;\n\tstruct ptd ptd;\n\n\tu8 maxpacket;\n\tu8 epnum;\n\tu8 nextpid;\n\tu16 error_count;\n\tu16 length;\t\t \n\tunsigned char *data;\t \n\t \n\tstruct isp116x_ep *active;\n\n\t \n\tu16 period;\n\tu16 branch;\n\tu16 load;\n\tstruct isp116x_ep *next;\n\n\t \n\tstruct list_head schedule;\n};\n\n \n\n#define DBG(stuff...)\t\tpr_debug(\"116x: \" stuff)\n\n#ifdef VERBOSE\n#    define VDBG\t\tDBG\n#else\n#    define VDBG(stuff...)\tdo{}while(0)\n#endif\n\n#define ERR(stuff...)\t\tprintk(KERN_ERR \"116x: \" stuff)\n#define WARNING(stuff...)\tprintk(KERN_WARNING \"116x: \" stuff)\n#define INFO(stuff...)\t\tprintk(KERN_INFO \"116x: \" stuff)\n\n \n\n#if defined(USE_PLATFORM_DELAY)\n#if defined(USE_NDELAY)\n#error USE_PLATFORM_DELAY and USE_NDELAY simultaneously defined.\n#endif\n#define\tisp116x_delay(h,d)\t(h)->board->delay(\t\\\n\t\t\t\tisp116x_to_hcd(h)->self.controller,d)\n#define isp116x_check_platform_delay(h)\t((h)->board->delay == NULL)\n#elif defined(USE_NDELAY)\n#define\tisp116x_delay(h,d)\tndelay(d)\n#define isp116x_check_platform_delay(h)\t0\n#else\n#define\tisp116x_delay(h,d)\tdo{}while(0)\n#define isp116x_check_platform_delay(h)\t0\n#endif\n\nstatic inline void isp116x_write_addr(struct isp116x *isp116x, unsigned reg)\n{\n\twritew(reg & 0xff, isp116x->addr_reg);\n\tisp116x_delay(isp116x, 300);\n}\n\nstatic inline void isp116x_write_data16(struct isp116x *isp116x, u16 val)\n{\n\twritew(val, isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n}\n\nstatic inline void isp116x_raw_write_data16(struct isp116x *isp116x, u16 val)\n{\n\t__raw_writew(val, isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n}\n\nstatic inline u16 isp116x_read_data16(struct isp116x *isp116x)\n{\n\tu16 val;\n\n\tval = readw(isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n\treturn val;\n}\n\nstatic inline u16 isp116x_raw_read_data16(struct isp116x *isp116x)\n{\n\tu16 val;\n\n\tval = __raw_readw(isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n\treturn val;\n}\n\nstatic inline void isp116x_write_data32(struct isp116x *isp116x, u32 val)\n{\n\twritew(val & 0xffff, isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n\twritew(val >> 16, isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n}\n\nstatic inline u32 isp116x_read_data32(struct isp116x *isp116x)\n{\n\tu32 val;\n\n\tval = (u32) readw(isp116x->data_reg);\n\tisp116x_delay(isp116x, 150);\n\tval |= ((u32) readw(isp116x->data_reg)) << 16;\n\tisp116x_delay(isp116x, 150);\n\treturn val;\n}\n\n \nstatic u16 isp116x_read_reg16(struct isp116x *isp116x, unsigned reg)\n{\n\tisp116x_write_addr(isp116x, reg);\n\treturn isp116x_read_data16(isp116x);\n}\n\nstatic u32 isp116x_read_reg32(struct isp116x *isp116x, unsigned reg)\n{\n\tisp116x_write_addr(isp116x, reg);\n\treturn isp116x_read_data32(isp116x);\n}\n\nstatic void isp116x_write_reg16(struct isp116x *isp116x, unsigned reg,\n\t\t\t\tunsigned val)\n{\n\tisp116x_write_addr(isp116x, reg | ISP116x_WRITE_OFFSET);\n\tisp116x_write_data16(isp116x, (u16) (val & 0xffff));\n}\n\nstatic void isp116x_write_reg32(struct isp116x *isp116x, unsigned reg,\n\t\t\t\tunsigned val)\n{\n\tisp116x_write_addr(isp116x, reg | ISP116x_WRITE_OFFSET);\n\tisp116x_write_data32(isp116x, (u32) val);\n}\n\n#define isp116x_show_reg_log(d,r,s) {\t\t\t\t\\\n\tif ((r) < 0x20) {\t\t\t                \\\n\t\tDBG(\"%-12s[%02x]: %08x\\n\", #r,\t\t\t\\\n\t\t\tr, isp116x_read_reg32(d, r));\t\t\\\n\t} else {\t\t\t\t\t\t\\\n\t\tDBG(\"%-12s[%02x]:     %04x\\n\", #r,\t\t\\\n\t\t\tr, isp116x_read_reg16(d, r));\t    \t\\\n\t}\t\t\t\t\t\t\t\\\n}\n#define isp116x_show_reg_seq(d,r,s) {\t\t\t\t\\\n\tif ((r) < 0x20) {\t\t\t\t\t\\\n\t\tseq_printf(s, \"%-12s[%02x]: %08x\\n\", #r,\t\\\n\t\t\tr, isp116x_read_reg32(d, r));\t\t\\\n\t} else {\t\t\t\t\t\t\\\n\t\tseq_printf(s, \"%-12s[%02x]:     %04x\\n\", #r,\t\\\n\t\t\tr, isp116x_read_reg16(d, r));\t\t\\\n\t}\t\t\t\t\t\t\t\\\n}\n\n#define isp116x_show_regs(d,type,s) {\t\t\t\\\n\tisp116x_show_reg_##type(d, HCREVISION, s);\t\\\n\tisp116x_show_reg_##type(d, HCCONTROL, s);\t\\\n\tisp116x_show_reg_##type(d, HCCMDSTAT, s);\t\\\n\tisp116x_show_reg_##type(d, HCINTSTAT, s);\t\\\n\tisp116x_show_reg_##type(d, HCINTENB, s);\t\\\n\tisp116x_show_reg_##type(d, HCFMINTVL, s);\t\\\n\tisp116x_show_reg_##type(d, HCFMREM, s);\t\t\\\n\tisp116x_show_reg_##type(d, HCFMNUM, s);\t\t\\\n\tisp116x_show_reg_##type(d, HCLSTHRESH, s);\t\\\n\tisp116x_show_reg_##type(d, HCRHDESCA, s);\t\\\n\tisp116x_show_reg_##type(d, HCRHDESCB, s);\t\\\n\tisp116x_show_reg_##type(d, HCRHSTATUS, s);\t\\\n\tisp116x_show_reg_##type(d, HCRHPORT1, s);\t\\\n\tisp116x_show_reg_##type(d, HCRHPORT2, s);\t\\\n\tisp116x_show_reg_##type(d, HCHWCFG, s);\t\t\\\n\tisp116x_show_reg_##type(d, HCDMACFG, s);\t\\\n\tisp116x_show_reg_##type(d, HCXFERCTR, s);\t\\\n\tisp116x_show_reg_##type(d, HCuPINT, s);\t\t\\\n\tisp116x_show_reg_##type(d, HCuPINTENB, s);\t\\\n\tisp116x_show_reg_##type(d, HCCHIPID, s);\t\\\n\tisp116x_show_reg_##type(d, HCSCRATCH, s);\t\\\n\tisp116x_show_reg_##type(d, HCITLBUFLEN, s);\t\\\n\tisp116x_show_reg_##type(d, HCATLBUFLEN, s);\t\\\n\tisp116x_show_reg_##type(d, HCBUFSTAT, s);\t\\\n\tisp116x_show_reg_##type(d, HCRDITL0LEN, s);\t\\\n\tisp116x_show_reg_##type(d, HCRDITL1LEN, s);\t\\\n}\n\n \nstatic inline void isp116x_show_regs_seq(struct isp116x *isp116x,\n\t\t\t\t\t  struct seq_file *s)\n{\n\tisp116x_show_regs(isp116x, seq, s);\n}\n\n \nstatic inline void isp116x_show_regs_log(struct isp116x *isp116x)\n{\n\tisp116x_show_regs(isp116x, log, NULL);\n}\n\n#if defined(URB_TRACE)\n\n#define PIPETYPE(pipe)  ({ char *__s;\t\t\t\\\n\tif (usb_pipecontrol(pipe))\t__s = \"ctrl\";\t\\\n\telse if (usb_pipeint(pipe))\t__s = \"int\";\t\\\n\telse if (usb_pipebulk(pipe))\t__s = \"bulk\";\t\\\n\telse\t\t\t\t__s = \"iso\";\t\\\n\t__s;})\n#define PIPEDIR(pipe)   ({ usb_pipein(pipe) ? \"in\" : \"out\"; })\n#define URB_NOTSHORT(urb) ({ (urb)->transfer_flags & URB_SHORT_NOT_OK ? \\\n\t\"short_not_ok\" : \"\"; })\n\n \nstatic void urb_dbg(struct urb *urb, char *msg)\n{\n\tunsigned int pipe;\n\n\tif (!urb) {\n\t\tDBG(\"%s: zero urb\\n\", msg);\n\t\treturn;\n\t}\n\tpipe = urb->pipe;\n\tDBG(\"%s: FA %d ep%d%s %s: len %d/%d %s\\n\", msg,\n\t    usb_pipedevice(pipe), usb_pipeendpoint(pipe),\n\t    PIPEDIR(pipe), PIPETYPE(pipe),\n\t    urb->transfer_buffer_length, urb->actual_length, URB_NOTSHORT(urb));\n}\n\n#else\n\n#define  urb_dbg(urb,msg)   do{}while(0)\n\n#endif\t\t\t\t \n\n#if defined(PTD_TRACE)\n\n#define PTD_DIR_STR(ptd)  ({char __c;\t\t\\\n\tswitch(PTD_GET_DIR(ptd)){\t\t\\\n\tcase 0:  __c = 's'; break;\t\t\\\n\tcase 1:  __c = 'o'; break;\t\t\\\n\tdefault: __c = 'i'; break;\t\t\\\n\t}; __c;})\n\n \nstatic inline void dump_ptd(struct ptd *ptd)\n{\n\tprintk(KERN_WARNING \"td: %x %d%c%d %d,%d,%d  %x %x%x%x\\n\",\n\t       PTD_GET_CC(ptd), PTD_GET_FA(ptd),\n\t       PTD_DIR_STR(ptd), PTD_GET_EP(ptd),\n\t       PTD_GET_COUNT(ptd), PTD_GET_LEN(ptd), PTD_GET_MPS(ptd),\n\t       PTD_GET_TOGGLE(ptd), PTD_GET_ACTIVE(ptd),\n\t       PTD_GET_SPD(ptd), PTD_GET_LAST(ptd));\n}\n\nstatic inline void dump_ptd_out_data(struct ptd *ptd, u8 * buf)\n{\n\tint k;\n\n\tif (PTD_GET_DIR(ptd) != PTD_DIR_IN && PTD_GET_LEN(ptd)) {\n\t\tprintk(KERN_WARNING \"-> \");\n\t\tfor (k = 0; k < PTD_GET_LEN(ptd); ++k)\n\t\t\tprintk(\"%02x \", ((u8 *) buf)[k]);\n\t\tprintk(\"\\n\");\n\t}\n}\n\nstatic inline void dump_ptd_in_data(struct ptd *ptd, u8 * buf)\n{\n\tint k;\n\n\tif (PTD_GET_DIR(ptd) == PTD_DIR_IN && PTD_GET_COUNT(ptd)) {\n\t\tprintk(KERN_WARNING \"<- \");\n\t\tfor (k = 0; k < PTD_GET_COUNT(ptd); ++k)\n\t\t\tprintk(\"%02x \", ((u8 *) buf)[k]);\n\t\tprintk(\"\\n\");\n\t}\n\tif (PTD_GET_LAST(ptd))\n\t\tprintk(KERN_WARNING \"-\\n\");\n}\n\n#else\n\n#define dump_ptd(ptd)               do{}while(0)\n#define dump_ptd_in_data(ptd,buf)   do{}while(0)\n#define dump_ptd_out_data(ptd,buf)  do{}while(0)\n\n#endif\t\t\t\t \n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}