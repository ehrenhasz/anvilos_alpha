{
  "module_name": "ehci-atmel.c",
  "hash_id": "3c8ed7902d8aa8f7e979e01da8d6b46869fe01af0515375f7445e772c2ef1612",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-atmel.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/of_platform.h>\n#include <linux/platform_device.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/phy.h>\n#include <linux/usb/of.h>\n\n#include \"ehci.h\"\n\n#define DRIVER_DESC \"EHCI Atmel driver\"\n\n#define EHCI_INSNREG(index)\t\t\t((index) * 4 + 0x90)\n#define EHCI_INSNREG08_HSIC_EN\t\t\tBIT(2)\n\n \n#define hcd_to_atmel_ehci_priv(h) \\\n\t((struct atmel_ehci_priv *)hcd_to_ehci(h)->priv)\n\nstruct atmel_ehci_priv {\n\tstruct clk *iclk;\n\tstruct clk *uclk;\n\tbool clocked;\n};\n\nstatic struct hc_driver __read_mostly ehci_atmel_hc_driver;\n\nstatic const struct ehci_driver_overrides ehci_atmel_drv_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct atmel_ehci_priv),\n};\n\n \n\nstatic void atmel_start_clock(struct atmel_ehci_priv *atmel_ehci)\n{\n\tif (atmel_ehci->clocked)\n\t\treturn;\n\n\tclk_prepare_enable(atmel_ehci->uclk);\n\tclk_prepare_enable(atmel_ehci->iclk);\n\tatmel_ehci->clocked = true;\n}\n\nstatic void atmel_stop_clock(struct atmel_ehci_priv *atmel_ehci)\n{\n\tif (!atmel_ehci->clocked)\n\t\treturn;\n\n\tclk_disable_unprepare(atmel_ehci->iclk);\n\tclk_disable_unprepare(atmel_ehci->uclk);\n\tatmel_ehci->clocked = false;\n}\n\nstatic void atmel_start_ehci(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct atmel_ehci_priv *atmel_ehci = hcd_to_atmel_ehci_priv(hcd);\n\n\tdev_dbg(&pdev->dev, \"start\\n\");\n\tatmel_start_clock(atmel_ehci);\n}\n\nstatic void atmel_stop_ehci(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct atmel_ehci_priv *atmel_ehci = hcd_to_atmel_ehci_priv(hcd);\n\n\tdev_dbg(&pdev->dev, \"stop\\n\");\n\tatmel_stop_clock(atmel_ehci);\n}\n\n \n\nstatic int ehci_atmel_drv_probe(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd;\n\tconst struct hc_driver *driver = &ehci_atmel_hc_driver;\n\tstruct resource *res;\n\tstruct ehci_hcd *ehci;\n\tstruct atmel_ehci_priv *atmel_ehci;\n\tint irq;\n\tint retval;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tpr_debug(\"Initializing Atmel-SoC USB Host Controller\\n\");\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0) {\n\t\tretval = irq;\n\t\tgoto fail_create_hcd;\n\t}\n\n\t \n\tretval = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (retval)\n\t\tgoto fail_create_hcd;\n\n\thcd = usb_create_hcd(driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd) {\n\t\tretval = -ENOMEM;\n\t\tgoto fail_create_hcd;\n\t}\n\tatmel_ehci = hcd_to_atmel_ehci_priv(hcd);\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tretval = PTR_ERR(hcd->regs);\n\t\tgoto fail_request_resource;\n\t}\n\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tatmel_ehci->iclk = devm_clk_get(&pdev->dev, \"ehci_clk\");\n\tif (IS_ERR(atmel_ehci->iclk)) {\n\t\tdev_err(&pdev->dev, \"Error getting interface clock\\n\");\n\t\tretval = -ENOENT;\n\t\tgoto fail_request_resource;\n\t}\n\n\tatmel_ehci->uclk = devm_clk_get(&pdev->dev, \"usb_clk\");\n\tif (IS_ERR(atmel_ehci->uclk)) {\n\t\tdev_err(&pdev->dev, \"failed to get uclk\\n\");\n\t\tretval = PTR_ERR(atmel_ehci->uclk);\n\t\tgoto fail_request_resource;\n\t}\n\n\tehci = hcd_to_ehci(hcd);\n\t \n\tehci->caps = hcd->regs;\n\n\tatmel_start_ehci(pdev);\n\n\tretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (retval)\n\t\tgoto fail_add_hcd;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tif (of_usb_get_phy_mode(pdev->dev.of_node) == USBPHY_INTERFACE_MODE_HSIC)\n\t\twritel(EHCI_INSNREG08_HSIC_EN, hcd->regs + EHCI_INSNREG(8));\n\n\treturn retval;\n\nfail_add_hcd:\n\tatmel_stop_ehci(pdev);\nfail_request_resource:\n\tusb_put_hcd(hcd);\nfail_create_hcd:\n\tdev_err(&pdev->dev, \"init %s fail, %d\\n\",\n\t\tdev_name(&pdev->dev), retval);\n\n\treturn retval;\n}\n\nstatic void ehci_atmel_drv_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n\n\tatmel_stop_ehci(pdev);\n}\n\nstatic int __maybe_unused ehci_atmel_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct atmel_ehci_priv *atmel_ehci = hcd_to_atmel_ehci_priv(hcd);\n\tint ret;\n\n\tret = ehci_suspend(hcd, false);\n\tif (ret)\n\t\treturn ret;\n\n\tatmel_stop_clock(atmel_ehci);\n\treturn 0;\n}\n\nstatic int __maybe_unused ehci_atmel_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct atmel_ehci_priv *atmel_ehci = hcd_to_atmel_ehci_priv(hcd);\n\n\tatmel_start_clock(atmel_ehci);\n\tehci_resume(hcd, false);\n\treturn 0;\n}\n\n#ifdef CONFIG_OF\nstatic const struct of_device_id atmel_ehci_dt_ids[] = {\n\t{ .compatible = \"atmel,at91sam9g45-ehci\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, atmel_ehci_dt_ids);\n#endif\n\nstatic SIMPLE_DEV_PM_OPS(ehci_atmel_pm_ops, ehci_atmel_drv_suspend,\n\t\t\t\t\tehci_atmel_drv_resume);\n\nstatic struct platform_driver ehci_atmel_driver = {\n\t.probe\t\t= ehci_atmel_drv_probe,\n\t.remove_new\t= ehci_atmel_drv_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"atmel-ehci\",\n\t\t.pm\t= &ehci_atmel_pm_ops,\n\t\t.of_match_table\t= of_match_ptr(atmel_ehci_dt_ids),\n\t},\n};\n\nstatic int __init ehci_atmel_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_atmel_hc_driver, &ehci_atmel_drv_overrides);\n\treturn platform_driver_register(&ehci_atmel_driver);\n}\nmodule_init(ehci_atmel_init);\n\nstatic void __exit ehci_atmel_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_atmel_driver);\n}\nmodule_exit(ehci_atmel_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_ALIAS(\"platform:atmel-ehci\");\nMODULE_AUTHOR(\"Nicolas Ferre\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}