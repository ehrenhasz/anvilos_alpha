{
  "module_name": "ehci-timer.c",
  "hash_id": "f0b4274f5b099b39526af58f9a5a1038cc338416722a7b81793a4869911126d4",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-timer.c",
  "human_readable_source": "\n \n\n \n\n \n\n \nstatic void ehci_set_command_bit(struct ehci_hcd *ehci, u32 bit)\n{\n\tehci->command |= bit;\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\n\t \n\tehci_readl(ehci, &ehci->regs->command);\n}\n\n \nstatic void ehci_clear_command_bit(struct ehci_hcd *ehci, u32 bit)\n{\n\tehci->command &= ~bit;\n\tehci_writel(ehci, ehci->command, &ehci->regs->command);\n\n\t \n\tehci_readl(ehci, &ehci->regs->command);\n}\n\n \n\n \n\n \nstatic unsigned event_delays_ns[] = {\n\t1 * NSEC_PER_MSEC,\t \n\t1 * NSEC_PER_MSEC,\t \n\t1 * NSEC_PER_MSEC,\t \n\t1125 * NSEC_PER_USEC,\t \n\t2 * NSEC_PER_MSEC,\t \n\t2 * NSEC_PER_MSEC,\t \n\t5 * NSEC_PER_MSEC,\t \n\t6 * NSEC_PER_MSEC,\t \n\t10 * NSEC_PER_MSEC,\t \n\t10 * NSEC_PER_MSEC,\t \n\t15 * NSEC_PER_MSEC,\t \n\t100 * NSEC_PER_MSEC,\t \n};\n\n \nstatic void ehci_enable_event(struct ehci_hcd *ehci, unsigned event,\n\t\tbool resched)\n{\n\tktime_t\t\t*timeout = &ehci->hr_timeouts[event];\n\n\tif (resched)\n\t\t*timeout = ktime_add(ktime_get(), event_delays_ns[event]);\n\tehci->enabled_hrtimer_events |= (1 << event);\n\n\t \n\tif (event < ehci->next_hrtimer_event) {\n\t\tehci->next_hrtimer_event = event;\n\t\thrtimer_start_range_ns(&ehci->hrtimer, *timeout,\n\t\t\t\tNSEC_PER_MSEC, HRTIMER_MODE_ABS);\n\t}\n}\n\n\n \nstatic void ehci_poll_ASS(struct ehci_hcd *ehci)\n{\n\tunsigned\tactual, want;\n\n\t \n\tif (ehci->rh_state != EHCI_RH_RUNNING)\n\t\treturn;\n\n\twant = (ehci->command & CMD_ASE) ? STS_ASS : 0;\n\tactual = ehci_readl(ehci, &ehci->regs->status) & STS_ASS;\n\n\tif (want != actual) {\n\n\t\t \n\t\tif (ehci->ASS_poll_count++ < 2) {\n\t\t\tehci_enable_event(ehci, EHCI_HRTIMER_POLL_ASS, true);\n\t\t\treturn;\n\t\t}\n\t\tehci_dbg(ehci, \"Waited too long for the async schedule status (%x/%x), giving up\\n\",\n\t\t\t\twant, actual);\n\t}\n\tehci->ASS_poll_count = 0;\n\n\t \n\tif (want == 0) {\t \n\t\tif (ehci->async_count > 0)\n\t\t\tehci_set_command_bit(ehci, CMD_ASE);\n\n\t} else {\t\t \n\t\tif (ehci->async_count == 0) {\n\n\t\t\t \n\t\t\tehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_ASYNC,\n\t\t\t\t\ttrue);\n\t\t}\n\t}\n}\n\n \nstatic void ehci_disable_ASE(struct ehci_hcd *ehci)\n{\n\tehci_clear_command_bit(ehci, CMD_ASE);\n}\n\n\n \nstatic void ehci_poll_PSS(struct ehci_hcd *ehci)\n{\n\tunsigned\tactual, want;\n\n\t \n\tif (ehci->rh_state != EHCI_RH_RUNNING)\n\t\treturn;\n\n\twant = (ehci->command & CMD_PSE) ? STS_PSS : 0;\n\tactual = ehci_readl(ehci, &ehci->regs->status) & STS_PSS;\n\n\tif (want != actual) {\n\n\t\t \n\t\tif (ehci->PSS_poll_count++ < 2) {\n\t\t\tehci_enable_event(ehci, EHCI_HRTIMER_POLL_PSS, true);\n\t\t\treturn;\n\t\t}\n\t\tehci_dbg(ehci, \"Waited too long for the periodic schedule status (%x/%x), giving up\\n\",\n\t\t\t\twant, actual);\n\t}\n\tehci->PSS_poll_count = 0;\n\n\t \n\tif (want == 0) {\t \n\t\tif (ehci->periodic_count > 0)\n\t\t\tehci_set_command_bit(ehci, CMD_PSE);\n\n\t} else {\t\t \n\t\tif (ehci->periodic_count == 0) {\n\n\t\t\t \n\t\t\tehci_enable_event(ehci, EHCI_HRTIMER_DISABLE_PERIODIC,\n\t\t\t\t\ttrue);\n\t\t}\n\t}\n}\n\n \nstatic void ehci_disable_PSE(struct ehci_hcd *ehci)\n{\n\tehci_clear_command_bit(ehci, CMD_PSE);\n}\n\n\n \nstatic void ehci_handle_controller_death(struct ehci_hcd *ehci)\n{\n\tif (!(ehci_readl(ehci, &ehci->regs->status) & STS_HALT)) {\n\n\t\t \n\t\tif (ehci->died_poll_count++ < 5) {\n\t\t\t \n\t\t\tehci_enable_event(ehci, EHCI_HRTIMER_POLL_DEAD, true);\n\t\t\treturn;\n\t\t}\n\t\tehci_warn(ehci, \"Waited too long for the controller to stop, giving up\\n\");\n\t}\n\n\t \n\tehci->rh_state = EHCI_RH_HALTED;\n\tehci_writel(ehci, 0, &ehci->regs->configured_flag);\n\tehci_writel(ehci, 0, &ehci->regs->intr_enable);\n\tehci_work(ehci);\n\tend_unlink_async(ehci);\n\n\t \n}\n\n \nstatic void ehci_handle_start_intr_unlinks(struct ehci_hcd *ehci)\n{\n\tbool\t\tstopped = (ehci->rh_state < EHCI_RH_RUNNING);\n\n\t \n\twhile (!list_empty(&ehci->intr_unlink_wait)) {\n\t\tstruct ehci_qh\t*qh;\n\n\t\tqh = list_first_entry(&ehci->intr_unlink_wait,\n\t\t\t\tstruct ehci_qh, unlink_node);\n\t\tif (!stopped && (qh->unlink_cycle ==\n\t\t\t\tehci->intr_unlink_wait_cycle))\n\t\t\tbreak;\n\t\tlist_del_init(&qh->unlink_node);\n\t\tqh->unlink_reason |= QH_UNLINK_QUEUE_EMPTY;\n\t\tstart_unlink_intr(ehci, qh);\n\t}\n\n\t \n\tif (!list_empty(&ehci->intr_unlink_wait)) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_START_UNLINK_INTR, true);\n\t\t++ehci->intr_unlink_wait_cycle;\n\t}\n}\n\n \nstatic void ehci_handle_intr_unlinks(struct ehci_hcd *ehci)\n{\n\tbool\t\tstopped = (ehci->rh_state < EHCI_RH_RUNNING);\n\n\t \n\tehci->intr_unlinking = true;\n\twhile (!list_empty(&ehci->intr_unlink)) {\n\t\tstruct ehci_qh\t*qh;\n\n\t\tqh = list_first_entry(&ehci->intr_unlink, struct ehci_qh,\n\t\t\t\tunlink_node);\n\t\tif (!stopped && qh->unlink_cycle == ehci->intr_unlink_cycle)\n\t\t\tbreak;\n\t\tlist_del_init(&qh->unlink_node);\n\t\tend_unlink_intr(ehci, qh);\n\t}\n\n\t \n\tif (!list_empty(&ehci->intr_unlink)) {\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_UNLINK_INTR, true);\n\t\t++ehci->intr_unlink_cycle;\n\t}\n\tehci->intr_unlinking = false;\n}\n\n\n \nstatic void start_free_itds(struct ehci_hcd *ehci)\n{\n\tif (!(ehci->enabled_hrtimer_events & BIT(EHCI_HRTIMER_FREE_ITDS))) {\n\t\tehci->last_itd_to_free = list_entry(\n\t\t\t\tehci->cached_itd_list.prev,\n\t\t\t\tstruct ehci_itd, itd_list);\n\t\tehci->last_sitd_to_free = list_entry(\n\t\t\t\tehci->cached_sitd_list.prev,\n\t\t\t\tstruct ehci_sitd, sitd_list);\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_FREE_ITDS, true);\n\t}\n}\n\n \nstatic void end_free_itds(struct ehci_hcd *ehci)\n{\n\tstruct ehci_itd\t\t*itd, *n;\n\tstruct ehci_sitd\t*sitd, *sn;\n\n\tif (ehci->rh_state < EHCI_RH_RUNNING) {\n\t\tehci->last_itd_to_free = NULL;\n\t\tehci->last_sitd_to_free = NULL;\n\t}\n\n\tlist_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {\n\t\tlist_del(&itd->itd_list);\n\t\tdma_pool_free(ehci->itd_pool, itd, itd->itd_dma);\n\t\tif (itd == ehci->last_itd_to_free)\n\t\t\tbreak;\n\t}\n\tlist_for_each_entry_safe(sitd, sn, &ehci->cached_sitd_list, sitd_list) {\n\t\tlist_del(&sitd->sitd_list);\n\t\tdma_pool_free(ehci->sitd_pool, sitd, sitd->sitd_dma);\n\t\tif (sitd == ehci->last_sitd_to_free)\n\t\t\tbreak;\n\t}\n\n\tif (!list_empty(&ehci->cached_itd_list) ||\n\t\t\t!list_empty(&ehci->cached_sitd_list))\n\t\tstart_free_itds(ehci);\n}\n\n\n \nstatic void ehci_iaa_watchdog(struct ehci_hcd *ehci)\n{\n\tu32 cmd, status;\n\n\t \n\tif (!ehci->iaa_in_progress || ehci->rh_state != EHCI_RH_RUNNING)\n\t\treturn;\n\n\t \n\tcmd = ehci_readl(ehci, &ehci->regs->command);\n\n\t \n\tstatus = ehci_readl(ehci, &ehci->regs->status);\n\tif ((status & STS_IAA) || !(cmd & CMD_IAAD)) {\n\t\tINCR(ehci->stats.lost_iaa);\n\t\tehci_writel(ehci, STS_IAA, &ehci->regs->status);\n\t}\n\n\tehci_dbg(ehci, \"IAA watchdog: status %x cmd %x\\n\", status, cmd);\n\tend_iaa_cycle(ehci);\n}\n\n\n \nstatic void turn_on_io_watchdog(struct ehci_hcd *ehci)\n{\n\t \n\tif (ehci->rh_state != EHCI_RH_RUNNING ||\n\t\t\t(ehci->enabled_hrtimer_events &\n\t\t\t\tBIT(EHCI_HRTIMER_IO_WATCHDOG)))\n\t\treturn;\n\n\t \n\tif (ehci->isoc_count > 0 || (ehci->need_io_watchdog &&\n\t\t\tehci->async_count + ehci->intr_count > 0))\n\t\tehci_enable_event(ehci, EHCI_HRTIMER_IO_WATCHDOG, true);\n}\n\n\n \nstatic void (*event_handlers[])(struct ehci_hcd *) = {\n\tehci_poll_ASS,\t\t\t \n\tehci_poll_PSS,\t\t\t \n\tehci_handle_controller_death,\t \n\tehci_handle_intr_unlinks,\t \n\tend_free_itds,\t\t\t \n\tend_unlink_async,\t\t \n\tehci_handle_start_intr_unlinks,\t \n\tunlink_empty_async,\t\t \n\tehci_iaa_watchdog,\t\t \n\tehci_disable_PSE,\t\t \n\tehci_disable_ASE,\t\t \n\tehci_work,\t\t\t \n};\n\nstatic enum hrtimer_restart ehci_hrtimer_func(struct hrtimer *t)\n{\n\tstruct ehci_hcd\t*ehci = container_of(t, struct ehci_hcd, hrtimer);\n\tktime_t\t\tnow;\n\tunsigned long\tevents;\n\tunsigned long\tflags;\n\tunsigned\te;\n\n\tspin_lock_irqsave(&ehci->lock, flags);\n\n\tevents = ehci->enabled_hrtimer_events;\n\tehci->enabled_hrtimer_events = 0;\n\tehci->next_hrtimer_event = EHCI_HRTIMER_NO_EVENT;\n\n\t \n\tnow = ktime_get();\n\tfor_each_set_bit(e, &events, EHCI_HRTIMER_NUM_EVENTS) {\n\t\tif (ktime_compare(now, ehci->hr_timeouts[e]) >= 0)\n\t\t\tevent_handlers[e](ehci);\n\t\telse\n\t\t\tehci_enable_event(ehci, e, false);\n\t}\n\n\tspin_unlock_irqrestore(&ehci->lock, flags);\n\treturn HRTIMER_NORESTART;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}