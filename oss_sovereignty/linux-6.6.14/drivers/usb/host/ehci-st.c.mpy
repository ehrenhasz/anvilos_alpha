{
  "module_name": "ehci-st.c",
  "hash_id": "270ac282e5782200bcf8f5dc447a653e2dc94782f57e452cd75593fa1f339519",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-st.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/err.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_device.h>\n#include <linux/reset.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/ehci_pdriver.h>\n#include <linux/pinctrl/consumer.h>\n\n#include \"ehci.h\"\n\n#define USB_MAX_CLKS 3\n\nstruct st_ehci_platform_priv {\n\tstruct clk *clks[USB_MAX_CLKS];\n\tstruct clk *clk48;\n\tstruct reset_control *rst;\n\tstruct reset_control *pwr;\n\tstruct phy *phy;\n};\n\n#define DRIVER_DESC \"EHCI STMicroelectronics driver\"\n\n#define hcd_to_ehci_priv(h) \\\n\t((struct st_ehci_platform_priv *)hcd_to_ehci(h)->priv)\n\n#define EHCI_CAPS_SIZE 0x10\n#define AHB2STBUS_INSREG01 (EHCI_CAPS_SIZE + 0x84)\n\nstatic int st_ehci_platform_reset(struct usb_hcd *hcd)\n{\n\tstruct platform_device *pdev = to_platform_device(hcd->self.controller);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(&pdev->dev);\n\tstruct ehci_hcd *ehci = hcd_to_ehci(hcd);\n\tu32 threshold;\n\n\t \n\tthreshold = 128 | (128 << 16);\n\twritel(threshold, hcd->regs + AHB2STBUS_INSREG01);\n\n\tehci->caps = hcd->regs + pdata->caps_offset;\n\treturn ehci_setup(hcd);\n}\n\nstatic int st_ehci_platform_power_on(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk, ret;\n\n\tret = reset_control_deassert(priv->pwr);\n\tif (ret)\n\t\treturn ret;\n\n\tret = reset_control_deassert(priv->rst);\n\tif (ret)\n\t\tgoto err_assert_power;\n\n\t \n\tif (priv->clk48) {\n\t\tret = clk_set_rate(priv->clk48, 48000000);\n\t\tif (ret)\n\t\t\tgoto err_assert_reset;\n\t}\n\n\tfor (clk = 0; clk < USB_MAX_CLKS && priv->clks[clk]; clk++) {\n\t\tret = clk_prepare_enable(priv->clks[clk]);\n\t\tif (ret)\n\t\t\tgoto err_disable_clks;\n\t}\n\n\tret = phy_init(priv->phy);\n\tif (ret)\n\t\tgoto err_disable_clks;\n\n\tret = phy_power_on(priv->phy);\n\tif (ret)\n\t\tgoto err_exit_phy;\n\n\treturn 0;\n\nerr_exit_phy:\n\tphy_exit(priv->phy);\nerr_disable_clks:\n\twhile (--clk >= 0)\n\t\tclk_disable_unprepare(priv->clks[clk]);\nerr_assert_reset:\n\treset_control_assert(priv->rst);\nerr_assert_power:\n\treset_control_assert(priv->pwr);\n\n\treturn ret;\n}\n\nstatic void st_ehci_platform_power_off(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk;\n\n\treset_control_assert(priv->pwr);\n\n\treset_control_assert(priv->rst);\n\n\tphy_power_off(priv->phy);\n\n\tphy_exit(priv->phy);\n\n\tfor (clk = USB_MAX_CLKS - 1; clk >= 0; clk--)\n\t\tif (priv->clks[clk])\n\t\t\tclk_disable_unprepare(priv->clks[clk]);\n\n}\n\nstatic struct hc_driver __read_mostly ehci_platform_hc_driver;\n\nstatic const struct ehci_driver_overrides platform_overrides __initconst = {\n\t.reset =\t\tst_ehci_platform_reset,\n\t.extra_priv_size =\tsizeof(struct st_ehci_platform_priv),\n};\n\nstatic struct usb_ehci_pdata ehci_platform_defaults = {\n\t.power_on =\t\tst_ehci_platform_power_on,\n\t.power_suspend =\tst_ehci_platform_power_off,\n\t.power_off =\t\tst_ehci_platform_power_off,\n};\n\nstatic int st_ehci_platform_probe(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct resource *res_mem;\n\tstruct usb_ehci_pdata *pdata = &ehci_platform_defaults;\n\tstruct st_ehci_platform_priv *priv;\n\tint err, irq, clk = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tirq = platform_get_irq(dev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = usb_create_hcd(&ehci_platform_hc_driver, &dev->dev,\n\t\t\t     dev_name(&dev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tplatform_set_drvdata(dev, hcd);\n\tdev->dev.platform_data = pdata;\n\tpriv = hcd_to_ehci_priv(hcd);\n\n\tpriv->phy = devm_phy_get(&dev->dev, \"usb\");\n\tif (IS_ERR(priv->phy)) {\n\t\terr = PTR_ERR(priv->phy);\n\t\tgoto err_put_hcd;\n\t}\n\n\tfor (clk = 0; clk < USB_MAX_CLKS; clk++) {\n\t\tpriv->clks[clk] = of_clk_get(dev->dev.of_node, clk);\n\t\tif (IS_ERR(priv->clks[clk])) {\n\t\t\terr = PTR_ERR(priv->clks[clk]);\n\t\t\tif (err == -EPROBE_DEFER)\n\t\t\t\tgoto err_put_clks;\n\t\t\tpriv->clks[clk] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tpriv->clk48 = devm_clk_get(&dev->dev, \"clk48\");\n\tif (IS_ERR(priv->clk48)) {\n\t\tdev_info(&dev->dev, \"48MHz clk not found\\n\");\n\t\tpriv->clk48 = NULL;\n\t}\n\n\tpriv->pwr =\n\t\tdevm_reset_control_get_optional_shared(&dev->dev, \"power\");\n\tif (IS_ERR(priv->pwr)) {\n\t\terr = PTR_ERR(priv->pwr);\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tgoto err_put_clks;\n\t\tpriv->pwr = NULL;\n\t}\n\n\tpriv->rst =\n\t\tdevm_reset_control_get_optional_shared(&dev->dev, \"softreset\");\n\tif (IS_ERR(priv->rst)) {\n\t\terr = PTR_ERR(priv->rst);\n\t\tif (err == -EPROBE_DEFER)\n\t\t\tgoto err_put_clks;\n\t\tpriv->rst = NULL;\n\t}\n\n\tif (pdata->power_on) {\n\t\terr = pdata->power_on(dev);\n\t\tif (err < 0)\n\t\t\tgoto err_put_clks;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(dev, 0, &res_mem);\n\tif (IS_ERR(hcd->regs)) {\n\t\terr = PTR_ERR(hcd->regs);\n\t\tgoto err_put_clks;\n\t}\n\thcd->rsrc_start = res_mem->start;\n\thcd->rsrc_len = resource_size(res_mem);\n\n\terr = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (err)\n\t\tgoto err_put_clks;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\tplatform_set_drvdata(dev, hcd);\n\n\treturn err;\n\nerr_put_clks:\n\twhile (--clk >= 0)\n\t\tclk_put(priv->clks[clk]);\nerr_put_hcd:\n\tif (pdata == &ehci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n\n\tusb_put_hcd(hcd);\n\n\treturn err;\n}\n\nstatic void st_ehci_platform_remove(struct platform_device *dev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);\n\tstruct st_ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);\n\tint clk;\n\n\tusb_remove_hcd(hcd);\n\n\tif (pdata->power_off)\n\t\tpdata->power_off(dev);\n\n\tfor (clk = 0; clk < USB_MAX_CLKS && priv->clks[clk]; clk++)\n\t\tclk_put(priv->clks[clk]);\n\n\tusb_put_hcd(hcd);\n\n\tif (pdata == &ehci_platform_defaults)\n\t\tdev->dev.platform_data = NULL;\n}\n\n#ifdef CONFIG_PM_SLEEP\n\nstatic int st_ehci_suspend(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tbool do_wakeup = device_may_wakeup(dev);\n\tint ret;\n\n\tret = ehci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tif (pdata->power_suspend)\n\t\tpdata->power_suspend(pdev);\n\n\tpinctrl_pm_select_sleep_state(dev);\n\n\treturn ret;\n}\n\nstatic int st_ehci_resume(struct device *dev)\n{\n\tstruct usb_hcd *hcd = dev_get_drvdata(dev);\n\tstruct usb_ehci_pdata *pdata = dev_get_platdata(dev);\n\tstruct platform_device *pdev = to_platform_device(dev);\n\tint err;\n\n\tpinctrl_pm_select_default_state(dev);\n\n\tif (pdata->power_on) {\n\t\terr = pdata->power_on(pdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tehci_resume(hcd, false);\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(st_ehci_pm_ops, st_ehci_suspend, st_ehci_resume);\n\n#endif  \n\nstatic const struct of_device_id st_ehci_ids[] = {\n\t{ .compatible = \"st,st-ehci-300x\", },\n\t{   }\n};\nMODULE_DEVICE_TABLE(of, st_ehci_ids);\n\nstatic struct platform_driver ehci_platform_driver = {\n\t.probe\t\t= st_ehci_platform_probe,\n\t.remove_new\t= st_ehci_platform_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"st-ehci\",\n#ifdef CONFIG_PM_SLEEP\n\t\t.pm\t= &st_ehci_pm_ops,\n#endif\n\t\t.of_match_table = st_ehci_ids,\n\t}\n};\n\nstatic int __init ehci_platform_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_platform_hc_driver, &platform_overrides);\n\treturn platform_driver_register(&ehci_platform_driver);\n}\nmodule_init(ehci_platform_init);\n\nstatic void __exit ehci_platform_cleanup(void)\n{\n\tplatform_driver_unregister(&ehci_platform_driver);\n}\nmodule_exit(ehci_platform_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"Peter Griffin <peter.griffin@linaro.org>\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}