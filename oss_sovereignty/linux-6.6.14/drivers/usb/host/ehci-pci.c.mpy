{
  "module_name": "ehci-pci.c",
  "hash_id": "414b8b21e814012063de6bd48f9c7e3bfdc929029b773b09743cf448720d9fd6",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ehci-pci.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n\n#include \"ehci.h\"\n#include \"pci-quirks.h\"\n\n#define DRIVER_DESC \"EHCI PCI platform driver\"\n\nstatic const char hcd_name[] = \"ehci-pci\";\n\n \n#define PCI_DEVICE_ID_INTEL_CE4100_USB\t0x2e70\n\n#define PCI_VENDOR_ID_ASPEED\t\t0x1a03\n#define PCI_DEVICE_ID_ASPEED_EHCI\t0x2603\n\n \n#define PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC\t\t0x0939\nstatic inline bool is_intel_quark_x1000(struct pci_dev *pdev)\n{\n\treturn pdev->vendor == PCI_VENDOR_ID_INTEL &&\n\t\tpdev->device == PCI_DEVICE_ID_INTEL_QUARK_X1000_SOC;\n}\n\n \nstatic const struct pci_device_id bypass_pci_id_table[] = {\n\t \n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0811), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x0829), },\n\t{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0xe006), },\n\t{}\n};\n\nstatic inline bool is_bypassed_id(struct pci_dev *pdev)\n{\n\treturn !!pci_match_id(bypass_pci_id_table, pdev);\n}\n\n \n#define\tintel_quark_x1000_insnreg01\thostpc\n\n \n#define INTEL_QUARK_X1000_EHCI_MAX_THRESHOLD\t0x007f007f\n\n \nstatic int ehci_pci_reinit(struct ehci_hcd *ehci, struct pci_dev *pdev)\n{\n\tint\t\t\tretval;\n\n\t \n\n\t \n\tretval = pci_set_mwi(pdev);\n\tif (!retval)\n\t\tehci_dbg(ehci, \"MWI active\\n\");\n\n\t \n\tif (is_intel_quark_x1000(pdev)) {\n\t\t \n\t\tehci_writel(ehci, INTEL_QUARK_X1000_EHCI_MAX_THRESHOLD,\n\t\t\tehci->regs->intel_quark_x1000_insnreg01);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ehci_pci_setup(struct usb_hcd *hcd)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\tu32\t\t\ttemp;\n\tint\t\t\tretval;\n\n\tehci->caps = hcd->regs;\n\n\t \n\tswitch (pdev->vendor) {\n\tcase PCI_VENDOR_ID_TOSHIBA_2:\n\t\t \n\t\tif (pdev->device == 0x01b5) {\n#ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO\n\t\t\tehci->big_endian_mmio = 1;\n#else\n\t\t\tehci_warn(ehci,\n\t\t\t\t  \"unsupported big endian Toshiba quirk\\n\");\n#endif\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_NVIDIA:\n\t\t \n\t\tswitch (pdev->device) {\n\t\tcase 0x003c:\t \n\t\tcase 0x005b:\t \n\t\tcase 0x00d8:\t \n\t\tcase 0x00e8:\t \n\t\t\tif (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(31)) < 0)\n\t\t\t\tehci_warn(ehci, \"can't enable NVidia \"\n\t\t\t\t\t\"workaround for >2GB RAM\\n\");\n\t\t\tbreak;\n\n\t\t \n\t\tcase 0x0068:\n\t\t\tif (pdev->revision < 0xa4)\n\t\t\t\tehci->no_selective_suspend = 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_INTEL:\n\t\tif (pdev->device == PCI_DEVICE_ID_INTEL_CE4100_USB)\n\t\t\thcd->has_tt = 1;\n\t\tbreak;\n\tcase PCI_VENDOR_ID_TDI:\n\t\tif (pdev->device == PCI_DEVICE_ID_TDI_EHCI)\n\t\t\thcd->has_tt = 1;\n\t\tbreak;\n\tcase PCI_VENDOR_ID_AMD:\n\t\t \n\t\tif (usb_amd_quirk_pll_check())\n\t\t\tehci->amd_pll_fix = 1;\n\t\t \n\t\tif (pdev->device == 0x7463) {\n\t\t\tehci_info(ehci, \"ignoring AMD8111 (errata)\\n\");\n\t\t\tretval = -EIO;\n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\tif (pdev->device == 0x7808) {\n\t\t\tehci->use_dummy_qh = 1;\n\t\t\tehci_info(ehci, \"applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\\n\");\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_VIA:\n\t\tif (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x60) {\n\t\t\tu8 tmp;\n\n\t\t\t \n\t\t\tpci_read_config_byte(pdev, 0x4b, &tmp);\n\t\t\tif (tmp & 0x20)\n\t\t\t\tbreak;\n\t\t\tpci_write_config_byte(pdev, 0x4b, tmp | 0x20);\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_ATI:\n\t\t \n\t\tif (usb_amd_quirk_pll_check())\n\t\t\tehci->amd_pll_fix = 1;\n\n\t\t \n\t\tif (pdev->device == 0x4396) {\n\t\t\tehci->use_dummy_qh = 1;\n\t\t\tehci_info(ehci, \"applying AMD SB700/SB800/Hudson-2/3 EHCI dummy qh workaround\\n\");\n\t\t}\n\t\t \n\t\tif ((pdev->device == 0x4386 || pdev->device == 0x4396) &&\n\t\t\t\tusb_amd_hang_symptom_quirk()) {\n\t\t\tu8 tmp;\n\t\t\tehci_info(ehci, \"applying AMD SB600/SB700 USB freeze workaround\\n\");\n\t\t\tpci_read_config_byte(pdev, 0x53, &tmp);\n\t\t\tpci_write_config_byte(pdev, 0x53, tmp | (1<<3));\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_NETMOS:\n\t\t \n\t\tehci_info(ehci, \"applying MosChip frame-index workaround\\n\");\n\t\tehci->frame_index_bug = 1;\n\t\tbreak;\n\tcase PCI_VENDOR_ID_HUAWEI:\n\t\t \n\t\tif (pdev->device == 0xa239) {\n\t\t\tehci_info(ehci, \"applying Synopsys HC workaround\\n\");\n\t\t\tehci->has_synopsys_hc_bug = 1;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_ASPEED:\n\t\tif (pdev->device == PCI_DEVICE_ID_ASPEED_EHCI) {\n\t\t\tehci_info(ehci, \"applying Aspeed HC workaround\\n\");\n\t\t\tehci->is_aspeed = 1;\n\t\t}\n\t\tbreak;\n\tcase PCI_VENDOR_ID_ZHAOXIN:\n\t\tif (pdev->device == 0x3104 && (pdev->revision & 0xf0) == 0x90)\n\t\t\tehci->zx_wakeup_clear_needed = 1;\n\t\tbreak;\n\t}\n\n\t \n\ttemp = pci_find_capability(pdev, PCI_CAP_ID_DBG);\n\tif (temp) {\n\t\tpci_read_config_dword(pdev, temp, &temp);\n\t\ttemp >>= 16;\n\t\tif (((temp >> 13) & 7) == 1) {\n\t\t\tu32 hcs_params = ehci_readl(ehci,\n\t\t\t\t\t\t    &ehci->caps->hcs_params);\n\n\t\t\ttemp &= 0x1fff;\n\t\t\tehci->debug = hcd->regs + temp;\n\t\t\ttemp = ehci_readl(ehci, &ehci->debug->control);\n\t\t\tehci_info(ehci, \"debug port %d%s\\n\",\n\t\t\t\t  HCS_DEBUG_PORT(hcs_params),\n\t\t\t\t  (temp & DBGP_ENABLED) ? \" IN USE\" : \"\");\n\t\t\tif (!(temp & DBGP_ENABLED))\n\t\t\t\tehci->debug = NULL;\n\t\t}\n\t}\n\n\tretval = ehci_setup(hcd);\n\tif (retval)\n\t\treturn retval;\n\n\t \n\tswitch (pdev->vendor) {\n\tcase PCI_VENDOR_ID_NEC:\n\tcase PCI_VENDOR_ID_INTEL:\n\tcase PCI_VENDOR_ID_AMD:\n\t\tehci->need_io_watchdog = 0;\n\t\tbreak;\n\tcase PCI_VENDOR_ID_NVIDIA:\n\t\tswitch (pdev->device) {\n\t\t \n\t\tcase 0x0d9d:\n\t\t\tehci_info(ehci, \"disable ppcd for nvidia mcp89\\n\");\n\t\t\tehci->has_ppcd = 0;\n\t\t\tehci->command &= ~CMD_PPCEE;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\t \n\ttemp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);\n\ttemp &= 0x0f;\n\tif (temp && HCS_N_PORTS(ehci->hcs_params) > temp) {\n\t\tehci_dbg(ehci, \"bogus port configuration: \"\n\t\t\t\"cc=%d x pcc=%d < ports=%d\\n\",\n\t\t\tHCS_N_CC(ehci->hcs_params),\n\t\t\tHCS_N_PCC(ehci->hcs_params),\n\t\t\tHCS_N_PORTS(ehci->hcs_params));\n\n\t\tswitch (pdev->vendor) {\n\t\tcase 0x17a0:\t\t \n\t\t\t \n\t\t\ttemp |= (ehci->hcs_params & ~0xf);\n\t\t\tehci->hcs_params = temp;\n\t\t\tbreak;\n\t\tcase PCI_VENDOR_ID_NVIDIA:\n\t\t\t \n\t\t\tbreak;\n\t\t}\n\t}\n\n\t \n\tif (pdev->vendor == PCI_VENDOR_ID_STMICRO\n\t    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)\n\t\t;\t \n\telse if (pdev->vendor == PCI_VENDOR_ID_HUAWEI\n\t\t\t && pdev->device == 0xa239)\n\t\t;\t \n\telse\n\t\tpci_read_config_byte(pdev, 0x60, &ehci->sbrn);\n\n\t \n\tif (!device_can_wakeup(&pdev->dev)) {\n\t\tu16\tport_wake;\n\n\t\tpci_read_config_word(pdev, 0x62, &port_wake);\n\t\tif (port_wake & 0x0001) {\n\t\t\tdev_warn(&pdev->dev, \"Enabling legacy PCI PM\\n\");\n\t\t\tdevice_set_wakeup_capable(&pdev->dev, 1);\n\t\t}\n\t}\n\n#ifdef\tCONFIG_PM\n\tif (ehci->no_selective_suspend && device_can_wakeup(&pdev->dev))\n\t\tehci_warn(ehci, \"selective suspend/wakeup unavailable\\n\");\n#endif\n\n\tretval = ehci_pci_reinit(ehci, pdev);\ndone:\n\treturn retval;\n}\n\n \n\n#ifdef\tCONFIG_PM\n\n \n\n \n\nstatic int ehci_pci_resume(struct usb_hcd *hcd, pm_message_t msg)\n{\n\tstruct ehci_hcd\t\t*ehci = hcd_to_ehci(hcd);\n\tstruct pci_dev\t\t*pdev = to_pci_dev(hcd->self.controller);\n\tbool\t\t\thibernated = (msg.event == PM_EVENT_RESTORE);\n\n\tif (ehci_resume(hcd, hibernated) != 0)\n\t\t(void) ehci_pci_reinit(ehci, pdev);\n\treturn 0;\n}\n\n#else\n\n#define ehci_suspend\t\tNULL\n#define ehci_pci_resume\t\tNULL\n#endif\t \n\nstatic struct hc_driver __read_mostly ehci_pci_hc_driver;\n\nstatic const struct ehci_driver_overrides pci_overrides __initconst = {\n\t.reset =\t\tehci_pci_setup,\n};\n\n \n\nstatic int ehci_pci_probe(struct pci_dev *pdev, const struct pci_device_id *id)\n{\n\tif (is_bypassed_id(pdev))\n\t\treturn -ENODEV;\n\treturn usb_hcd_pci_probe(pdev, &ehci_pci_hc_driver);\n}\n\nstatic void ehci_pci_remove(struct pci_dev *pdev)\n{\n\tpci_clear_mwi(pdev);\n\tusb_hcd_pci_remove(pdev);\n}\n\n \nstatic const struct pci_device_id pci_ids [] = { {\n\t \n\tPCI_DEVICE_CLASS(PCI_CLASS_SERIAL_USB_EHCI, ~0),\n\t}, {\n\tPCI_VDEVICE(STMICRO, PCI_DEVICE_ID_STMICRO_USB_HOST),\n\t},\n\t{   }\n};\nMODULE_DEVICE_TABLE(pci, pci_ids);\n\n \nstatic struct pci_driver ehci_pci_driver = {\n\t.name =\t\thcd_name,\n\t.id_table =\tpci_ids,\n\n\t.probe =\tehci_pci_probe,\n\t.remove =\tehci_pci_remove,\n\t.shutdown = \tusb_hcd_pci_shutdown,\n\n\t.driver =\t{\n#ifdef CONFIG_PM\n\t\t.pm =\t&usb_hcd_pci_pm_ops,\n#endif\n\t\t.probe_type = PROBE_PREFER_ASYNCHRONOUS,\n\t},\n};\n\nstatic int __init ehci_pci_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tehci_init_driver(&ehci_pci_hc_driver, &pci_overrides);\n\n\t \n\tehci_pci_hc_driver.pci_suspend = ehci_suspend;\n\tehci_pci_hc_driver.pci_resume = ehci_pci_resume;\n\n\treturn pci_register_driver(&ehci_pci_driver);\n}\nmodule_init(ehci_pci_init);\n\nstatic void __exit ehci_pci_cleanup(void)\n{\n\tpci_unregister_driver(&ehci_pci_driver);\n}\nmodule_exit(ehci_pci_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_AUTHOR(\"David Brownell\");\nMODULE_AUTHOR(\"Alan Stern\");\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}