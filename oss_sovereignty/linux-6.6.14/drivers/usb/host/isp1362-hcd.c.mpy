{
  "module_name": "isp1362-hcd.c",
  "hash_id": "129862cfb02eaba1342d24f1d6082a0ece713877b256f19ad508b56babc6922f",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/isp1362-hcd.c",
  "human_readable_source": "\n \n\n \n\n#undef ISP1362_DEBUG\n\n \n#undef BUGGY_PXA2XX_UDC_USBTEST\n\n#undef PTD_TRACE\n#undef URB_TRACE\n#undef VERBOSE\n#undef REGISTERS\n\n \n#undef CHIP_BUFFER_TEST\n\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/list.h>\n#include <linux/interrupt.h>\n#include <linux/usb.h>\n#include <linux/usb/isp1362.h>\n#include <linux/usb/hcd.h>\n#include <linux/platform_device.h>\n#include <linux/pm.h>\n#include <linux/io.h>\n#include <linux/bitmap.h>\n#include <linux/prefetch.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n#include <asm/irq.h>\n#include <asm/byteorder.h>\n#include <asm/unaligned.h>\n\nstatic int dbg_level;\n#ifdef ISP1362_DEBUG\nmodule_param(dbg_level, int, 0644);\n#else\nmodule_param(dbg_level, int, 0);\n#endif\n\n#include \"../core/usb.h\"\n#include \"isp1362.h\"\n\n\n#define DRIVER_VERSION\t\"2005-04-04\"\n#define DRIVER_DESC\t\"ISP1362 USB Host Controller Driver\"\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n\nstatic const char hcd_name[] = \"isp1362-hcd\";\n\nstatic void isp1362_hc_stop(struct usb_hcd *hcd);\nstatic int isp1362_hc_start(struct usb_hcd *hcd);\n\n \n\n \nstatic inline void isp1362_enable_int(struct isp1362_hcd *isp1362_hcd, u16 mask)\n{\n\tif ((isp1362_hcd->irqenb | mask) == isp1362_hcd->irqenb)\n\t\treturn;\n\tif (mask & ~isp1362_hcd->irqenb)\n\t\tisp1362_write_reg16(isp1362_hcd, HCuPINT, mask & ~isp1362_hcd->irqenb);\n\tisp1362_hcd->irqenb |= mask;\n\tif (isp1362_hcd->irq_active)\n\t\treturn;\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\n}\n\n \n\nstatic inline struct isp1362_ep_queue *get_ptd_queue(struct isp1362_hcd *isp1362_hcd,\n\t\t\t\t\t\t     u16 offset)\n{\n\tstruct isp1362_ep_queue *epq = NULL;\n\n\tif (offset < isp1362_hcd->istl_queue[1].buf_start)\n\t\tepq = &isp1362_hcd->istl_queue[0];\n\telse if (offset < isp1362_hcd->intl_queue.buf_start)\n\t\tepq = &isp1362_hcd->istl_queue[1];\n\telse if (offset < isp1362_hcd->atl_queue.buf_start)\n\t\tepq = &isp1362_hcd->intl_queue;\n\telse if (offset < isp1362_hcd->atl_queue.buf_start +\n\t\t   isp1362_hcd->atl_queue.buf_size)\n\t\tepq = &isp1362_hcd->atl_queue;\n\n\tif (epq)\n\t\tDBG(1, \"%s: PTD $%04x is on %s queue\\n\", __func__, offset, epq->name);\n\telse\n\t\tpr_warn(\"%s: invalid PTD $%04x\\n\", __func__, offset);\n\n\treturn epq;\n}\n\nstatic inline int get_ptd_offset(struct isp1362_ep_queue *epq, u8 index)\n{\n\tint offset;\n\n\tif (index * epq->blk_size > epq->buf_size) {\n\t\tpr_warn(\"%s: Bad %s index %d(%d)\\n\",\n\t\t\t__func__, epq->name, index,\n\t\t\tepq->buf_size / epq->blk_size);\n\t\treturn -EINVAL;\n\t}\n\toffset = epq->buf_start + index * epq->blk_size;\n\tDBG(3, \"%s: %s PTD[%02x] # %04x\\n\", __func__, epq->name, index, offset);\n\n\treturn offset;\n}\n\n \n\nstatic inline u16 max_transfer_size(struct isp1362_ep_queue *epq, size_t size,\n\t\t\t\t    int mps)\n{\n\tu16 xfer_size = min_t(size_t, MAX_XFER_SIZE, size);\n\n\txfer_size = min_t(size_t, xfer_size, epq->buf_avail * epq->blk_size - PTD_HEADER_SIZE);\n\tif (xfer_size < size && xfer_size % mps)\n\t\txfer_size -= xfer_size % mps;\n\n\treturn xfer_size;\n}\n\nstatic int claim_ptd_buffers(struct isp1362_ep_queue *epq,\n\t\t\t     struct isp1362_ep *ep, u16 len)\n{\n\tint ptd_offset = -EINVAL;\n\tint num_ptds = ((len + PTD_HEADER_SIZE - 1) / epq->blk_size) + 1;\n\tint found;\n\n\tBUG_ON(len > epq->buf_size);\n\n\tif (!epq->buf_avail)\n\t\treturn -ENOMEM;\n\n\tif (ep->num_ptds)\n\t\tpr_err(\"%s: %s len %d/%d num_ptds %d buf_map %08lx skip_map %08lx\\n\", __func__,\n\t\t    epq->name, len, epq->blk_size, num_ptds, epq->buf_map, epq->skip_map);\n\tBUG_ON(ep->num_ptds != 0);\n\n\tfound = bitmap_find_next_zero_area(&epq->buf_map, epq->buf_count, 0,\n\t\t\t\t\t\tnum_ptds, 0);\n\tif (found >= epq->buf_count)\n\t\treturn -EOVERFLOW;\n\n\tDBG(1, \"%s: Found %d PTDs[%d] for %d/%d byte\\n\", __func__,\n\t    num_ptds, found, len, (int)(epq->blk_size - PTD_HEADER_SIZE));\n\tptd_offset = get_ptd_offset(epq, found);\n\tWARN_ON(ptd_offset < 0);\n\tep->ptd_offset = ptd_offset;\n\tep->num_ptds += num_ptds;\n\tepq->buf_avail -= num_ptds;\n\tBUG_ON(epq->buf_avail > epq->buf_count);\n\tep->ptd_index = found;\n\tbitmap_set(&epq->buf_map, found, num_ptds);\n\tDBG(1, \"%s: Done %s PTD[%d] $%04x, avail %d count %d claimed %d %08lx:%08lx\\n\",\n\t    __func__, epq->name, ep->ptd_index, ep->ptd_offset,\n\t    epq->buf_avail, epq->buf_count, num_ptds, epq->buf_map, epq->skip_map);\n\n\treturn found;\n}\n\nstatic inline void release_ptd_buffers(struct isp1362_ep_queue *epq, struct isp1362_ep *ep)\n{\n\tint last = ep->ptd_index + ep->num_ptds;\n\n\tif (last > epq->buf_count)\n\t\tpr_err(\"%s: ep %p req %d len %d %s PTD[%d] $%04x num_ptds %d buf_count %d buf_avail %d buf_map %08lx skip_map %08lx\\n\",\n\t\t    __func__, ep, ep->num_req, ep->length, epq->name, ep->ptd_index,\n\t\t    ep->ptd_offset, ep->num_ptds, epq->buf_count, epq->buf_avail,\n\t\t    epq->buf_map, epq->skip_map);\n\tBUG_ON(last > epq->buf_count);\n\n\tbitmap_clear(&epq->buf_map, ep->ptd_index, ep->num_ptds);\n\tbitmap_set(&epq->skip_map, ep->ptd_index, ep->num_ptds);\n\tepq->buf_avail += ep->num_ptds;\n\tepq->ptd_count--;\n\n\tBUG_ON(epq->buf_avail > epq->buf_count);\n\tBUG_ON(epq->ptd_count > epq->buf_count);\n\n\tDBG(1, \"%s: Done %s PTDs $%04x released %d avail %d count %d\\n\",\n\t    __func__, epq->name,\n\t    ep->ptd_offset, ep->num_ptds, epq->buf_avail, epq->buf_count);\n\tDBG(1, \"%s: buf_map %08lx skip_map %08lx\\n\", __func__,\n\t    epq->buf_map, epq->skip_map);\n\n\tep->num_ptds = 0;\n\tep->ptd_offset = -EINVAL;\n\tep->ptd_index = -EINVAL;\n}\n\n \n\n \nstatic void prepare_ptd(struct isp1362_hcd *isp1362_hcd, struct urb *urb,\n\t\t\tstruct isp1362_ep *ep, struct isp1362_ep_queue *epq,\n\t\t\tu16 fno)\n{\n\tstruct ptd *ptd;\n\tint toggle;\n\tint dir;\n\tu16 len;\n\tsize_t buf_len = urb->transfer_buffer_length - urb->actual_length;\n\n\tDBG(3, \"%s: %s ep %p\\n\", __func__, epq->name, ep);\n\n\tptd = &ep->ptd;\n\n\tep->data = (unsigned char *)urb->transfer_buffer + urb->actual_length;\n\n\tswitch (ep->nextpid) {\n\tcase USB_PID_IN:\n\t\ttoggle = usb_gettoggle(urb->dev, ep->epnum, 0);\n\t\tdir = PTD_DIR_IN;\n\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\tlen = min_t(size_t, ep->maxpacket, buf_len);\n\t\t} else if (usb_pipeisoc(urb->pipe)) {\n\t\t\tlen = min_t(size_t, urb->iso_frame_desc[fno].length, MAX_XFER_SIZE);\n\t\t\tep->data = urb->transfer_buffer + urb->iso_frame_desc[fno].offset;\n\t\t} else\n\t\t\tlen = max_transfer_size(epq, buf_len, ep->maxpacket);\n\t\tDBG(1, \"%s: IN    len %d/%d/%d from URB\\n\", __func__, len, ep->maxpacket,\n\t\t    (int)buf_len);\n\t\tbreak;\n\tcase USB_PID_OUT:\n\t\ttoggle = usb_gettoggle(urb->dev, ep->epnum, 1);\n\t\tdir = PTD_DIR_OUT;\n\t\tif (usb_pipecontrol(urb->pipe))\n\t\t\tlen = min_t(size_t, ep->maxpacket, buf_len);\n\t\telse if (usb_pipeisoc(urb->pipe))\n\t\t\tlen = min_t(size_t, urb->iso_frame_desc[0].length, MAX_XFER_SIZE);\n\t\telse\n\t\t\tlen = max_transfer_size(epq, buf_len, ep->maxpacket);\n\t\tif (len == 0)\n\t\t\tpr_info(\"%s: Sending ZERO packet: %d\\n\", __func__,\n\t\t\t     urb->transfer_flags & URB_ZERO_PACKET);\n\t\tDBG(1, \"%s: OUT   len %d/%d/%d from URB\\n\", __func__, len, ep->maxpacket,\n\t\t    (int)buf_len);\n\t\tbreak;\n\tcase USB_PID_SETUP:\n\t\ttoggle = 0;\n\t\tdir = PTD_DIR_SETUP;\n\t\tlen = sizeof(struct usb_ctrlrequest);\n\t\tDBG(1, \"%s: SETUP len %d\\n\", __func__, len);\n\t\tep->data = urb->setup_packet;\n\t\tbreak;\n\tcase USB_PID_ACK:\n\t\ttoggle = 1;\n\t\tlen = 0;\n\t\tdir = (urb->transfer_buffer_length && usb_pipein(urb->pipe)) ?\n\t\t\tPTD_DIR_OUT : PTD_DIR_IN;\n\t\tDBG(1, \"%s: ACK   len %d\\n\", __func__, len);\n\t\tbreak;\n\tdefault:\n\t\ttoggle = dir = len = 0;\n\t\tpr_err(\"%s@%d: ep->nextpid %02x\\n\", __func__, __LINE__, ep->nextpid);\n\t\tBUG_ON(1);\n\t}\n\n\tep->length = len;\n\tif (!len)\n\t\tep->data = NULL;\n\n\tptd->count = PTD_CC_MSK | PTD_ACTIVE_MSK | PTD_TOGGLE(toggle);\n\tptd->mps = PTD_MPS(ep->maxpacket) | PTD_SPD(urb->dev->speed == USB_SPEED_LOW) |\n\t\tPTD_EP(ep->epnum);\n\tptd->len = PTD_LEN(len) | PTD_DIR(dir);\n\tptd->faddr = PTD_FA(usb_pipedevice(urb->pipe));\n\n\tif (usb_pipeint(urb->pipe)) {\n\t\tptd->faddr |= PTD_SF_INT(ep->branch);\n\t\tptd->faddr |= PTD_PR(ep->interval ? __ffs(ep->interval) : 0);\n\t}\n\tif (usb_pipeisoc(urb->pipe))\n\t\tptd->faddr |= PTD_SF_ISO(fno);\n\n\tDBG(1, \"%s: Finished\\n\", __func__);\n}\n\nstatic void isp1362_write_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\n\t\t\t      struct isp1362_ep_queue *epq)\n{\n\tstruct ptd *ptd = &ep->ptd;\n\tint len = PTD_GET_DIR(ptd) == PTD_DIR_IN ? 0 : ep->length;\n\n\tprefetch(ptd);\n\tisp1362_write_buffer(isp1362_hcd, ptd, ep->ptd_offset, PTD_HEADER_SIZE);\n\tif (len)\n\t\tisp1362_write_buffer(isp1362_hcd, ep->data,\n\t\t\t\t     ep->ptd_offset + PTD_HEADER_SIZE, len);\n\n\tdump_ptd(ptd);\n\tdump_ptd_out_data(ptd, ep->data);\n}\n\nstatic void isp1362_read_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\n\t\t\t     struct isp1362_ep_queue *epq)\n{\n\tstruct ptd *ptd = &ep->ptd;\n\tint act_len;\n\n\tWARN_ON(list_empty(&ep->active));\n\tBUG_ON(ep->ptd_offset < 0);\n\n\tlist_del_init(&ep->active);\n\tDBG(1, \"%s: ep %p removed from active list %p\\n\", __func__, ep, &epq->active);\n\n\tprefetchw(ptd);\n\tisp1362_read_buffer(isp1362_hcd, ptd, ep->ptd_offset, PTD_HEADER_SIZE);\n\tdump_ptd(ptd);\n\tact_len = PTD_GET_COUNT(ptd);\n\tif (PTD_GET_DIR(ptd) != PTD_DIR_IN || act_len == 0)\n\t\treturn;\n\tif (act_len > ep->length)\n\t\tpr_err(\"%s: ep %p PTD $%04x act_len %d ep->length %d\\n\", __func__, ep,\n\t\t\t ep->ptd_offset, act_len, ep->length);\n\tBUG_ON(act_len > ep->length);\n\t \n\tprefetchw(ep->data);\n\tisp1362_read_buffer(isp1362_hcd, ep->data,\n\t\t\t    ep->ptd_offset + PTD_HEADER_SIZE, act_len);\n\tdump_ptd_in_data(ptd, ep->data);\n}\n\n \nstatic void remove_ptd(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep)\n\n{\n\tint index;\n\tstruct isp1362_ep_queue *epq;\n\n\tDBG(1, \"%s: ep %p PTD[%d] $%04x\\n\", __func__, ep, ep->ptd_index, ep->ptd_offset);\n\tBUG_ON(ep->ptd_offset < 0);\n\n\tepq = get_ptd_queue(isp1362_hcd, ep->ptd_offset);\n\tBUG_ON(!epq);\n\n\t \n\tWARN_ON(!list_empty(&ep->remove_list));\n\tlist_add_tail(&ep->remove_list, &isp1362_hcd->remove_list);\n\t \n\tisp1362_enable_int(isp1362_hcd, HCuPINT_SOF);\n\n\tindex = ep->ptd_index;\n\tif (index < 0)\n\t\t \n\t\treturn;\n\n\tDBG(1, \"%s: Disabling PTD[%02x] $%04x %08lx|%08x\\n\", __func__,\n\t    index, ep->ptd_offset, epq->skip_map, 1 << index);\n\n\t \n\tepq->skip_map |= 1 << index;\n\tif (epq == &isp1362_hcd->atl_queue) {\n\t\tDBG(2, \"%s: ATLSKIP = %08x -> %08lx\\n\", __func__,\n\t\t    isp1362_read_reg32(isp1362_hcd, HCATLSKIP), epq->skip_map);\n\t\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP, epq->skip_map);\n\t\tif (~epq->skip_map == 0)\n\t\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\n\t} else if (epq == &isp1362_hcd->intl_queue) {\n\t\tDBG(2, \"%s: INTLSKIP = %08x -> %08lx\\n\", __func__,\n\t\t    isp1362_read_reg32(isp1362_hcd, HCINTLSKIP), epq->skip_map);\n\t\tisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, epq->skip_map);\n\t\tif (~epq->skip_map == 0)\n\t\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\n\t}\n}\n\n \nstatic void finish_request(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep,\n\t\t\t   struct urb *urb, int status)\n     __releases(isp1362_hcd->lock)\n     __acquires(isp1362_hcd->lock)\n{\n\turb->hcpriv = NULL;\n\tep->error_count = 0;\n\n\tif (usb_pipecontrol(urb->pipe))\n\t\tep->nextpid = USB_PID_SETUP;\n\n\tURB_DBG(\"%s: req %d FA %d ep%d%s %s: len %d/%d %s stat %d\\n\", __func__,\n\t\tep->num_req, usb_pipedevice(urb->pipe),\n\t\tusb_pipeendpoint(urb->pipe),\n\t\t!usb_pipein(urb->pipe) ? \"out\" : \"in\",\n\t\tusb_pipecontrol(urb->pipe) ? \"ctrl\" :\n\t\t\tusb_pipeint(urb->pipe) ? \"int\" :\n\t\t\tusb_pipebulk(urb->pipe) ? \"bulk\" :\n\t\t\t\"iso\",\n\t\turb->actual_length, urb->transfer_buffer_length,\n\t\t!(urb->transfer_flags & URB_SHORT_NOT_OK) ?\n\t\t\"short_ok\" : \"\", urb->status);\n\n\n\tusb_hcd_unlink_urb_from_ep(isp1362_hcd_to_hcd(isp1362_hcd), urb);\n\tspin_unlock(&isp1362_hcd->lock);\n\tusb_hcd_giveback_urb(isp1362_hcd_to_hcd(isp1362_hcd), urb, status);\n\tspin_lock(&isp1362_hcd->lock);\n\n\t \n\tif (!list_empty(&ep->hep->urb_list))\n\t\treturn;\n\n\t \n\tif (!list_empty(&ep->schedule)) {\n\t\tlist_del_init(&ep->schedule);\n\t\treturn;\n\t}\n\n\n\tif (ep->interval) {\n\t\t \n\t\tDBG(1, \"deschedule qh%d/%p branch %d load %d bandwidth %d -> %d\\n\", ep->interval,\n\t\t    ep, ep->branch, ep->load,\n\t\t    isp1362_hcd->load[ep->branch],\n\t\t    isp1362_hcd->load[ep->branch] - ep->load);\n\t\tisp1362_hcd->load[ep->branch] -= ep->load;\n\t\tep->branch = PERIODIC_SIZE;\n\t}\n}\n\n \nstatic void postproc_ep(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep *ep)\n{\n\tstruct urb *urb = get_urb(ep);\n\tstruct usb_device *udev;\n\tstruct ptd *ptd;\n\tint short_ok;\n\tu16 len;\n\tint urbstat = -EINPROGRESS;\n\tu8 cc;\n\n\tDBG(2, \"%s: ep %p req %d\\n\", __func__, ep, ep->num_req);\n\n\tudev = urb->dev;\n\tptd = &ep->ptd;\n\tcc = PTD_GET_CC(ptd);\n\tif (cc == PTD_NOTACCESSED) {\n\t\tpr_err(\"%s: req %d PTD %p Untouched by ISP1362\\n\", __func__,\n\t\t    ep->num_req, ptd);\n\t\tcc = PTD_DEVNOTRESP;\n\t}\n\n\tshort_ok = !(urb->transfer_flags & URB_SHORT_NOT_OK);\n\tlen = urb->transfer_buffer_length - urb->actual_length;\n\n\t \n\tif (cc == PTD_DATAUNDERRUN) {\n\t\tif (short_ok) {\n\t\t\tDBG(1, \"%s: req %d Allowed data underrun short_%sok %d/%d/%d byte\\n\",\n\t\t\t    __func__, ep->num_req, short_ok ? \"\" : \"not_\",\n\t\t\t    PTD_GET_COUNT(ptd), ep->maxpacket, len);\n\t\t\tcc = PTD_CC_NOERROR;\n\t\t\turbstat = 0;\n\t\t} else {\n\t\t\tDBG(1, \"%s: req %d Data Underrun %s nextpid %02x short_%sok %d/%d/%d byte\\n\",\n\t\t\t    __func__, ep->num_req,\n\t\t\t    usb_pipein(urb->pipe) ? \"IN\" : \"OUT\", ep->nextpid,\n\t\t\t    short_ok ? \"\" : \"not_\",\n\t\t\t    PTD_GET_COUNT(ptd), ep->maxpacket, len);\n\t\t\t \n\t\t\turb->actual_length += PTD_GET_COUNT(ptd);\n\t\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\t\tBUG_ON(urb->actual_length > urb->transfer_buffer_length);\n\n\t\t\t\tif (urb->status == -EINPROGRESS)\n\t\t\t\t\turb->status = cc_to_error[PTD_DATAUNDERRUN];\n\t\t\t} else {\n\t\t\t\tusb_settoggle(udev, ep->epnum, ep->nextpid == USB_PID_OUT,\n\t\t\t\t\t      PTD_GET_TOGGLE(ptd));\n\t\t\t\turbstat = cc_to_error[PTD_DATAUNDERRUN];\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (cc != PTD_CC_NOERROR) {\n\t\tif (++ep->error_count >= 3 || cc == PTD_CC_STALL || cc == PTD_DATAOVERRUN) {\n\t\t\turbstat = cc_to_error[cc];\n\t\t\tDBG(1, \"%s: req %d nextpid %02x, status %d, error %d, error_count %d\\n\",\n\t\t\t    __func__, ep->num_req, ep->nextpid, urbstat, cc,\n\t\t\t    ep->error_count);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tswitch (ep->nextpid) {\n\tcase USB_PID_OUT:\n\t\tif (PTD_GET_COUNT(ptd) != ep->length)\n\t\t\tpr_err(\"%s: count=%d len=%d\\n\", __func__,\n\t\t\t   PTD_GET_COUNT(ptd), ep->length);\n\t\tBUG_ON(PTD_GET_COUNT(ptd) != ep->length);\n\t\turb->actual_length += ep->length;\n\t\tBUG_ON(urb->actual_length > urb->transfer_buffer_length);\n\t\tusb_settoggle(udev, ep->epnum, 1, PTD_GET_TOGGLE(ptd));\n\t\tif (urb->actual_length == urb->transfer_buffer_length) {\n\t\t\tDBG(3, \"%s: req %d xfer complete %d/%d status %d -> 0\\n\", __func__,\n\t\t\t    ep->num_req, len, ep->maxpacket, urbstat);\n\t\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\t\tDBG(3, \"%s: req %d %s Wait for ACK\\n\", __func__,\n\t\t\t\t    ep->num_req,\n\t\t\t\t    usb_pipein(urb->pipe) ? \"IN\" : \"OUT\");\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\t} else {\n\t\t\t\tif (len % ep->maxpacket ||\n\t\t\t\t    !(urb->transfer_flags & URB_ZERO_PACKET)) {\n\t\t\t\t\turbstat = 0;\n\t\t\t\t\tDBG(3, \"%s: req %d URB %s status %d count %d/%d/%d\\n\",\n\t\t\t\t\t    __func__, ep->num_req, usb_pipein(urb->pipe) ? \"IN\" : \"OUT\",\n\t\t\t\t\t    urbstat, len, ep->maxpacket, urb->actual_length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase USB_PID_IN:\n\t\tlen = PTD_GET_COUNT(ptd);\n\t\tBUG_ON(len > ep->length);\n\t\turb->actual_length += len;\n\t\tBUG_ON(urb->actual_length > urb->transfer_buffer_length);\n\t\tusb_settoggle(udev, ep->epnum, 0, PTD_GET_TOGGLE(ptd));\n\t\t \n\t\tif ((urb->transfer_buffer_length == urb->actual_length) ||\n\t\t    len % ep->maxpacket) {\n\t\t\tDBG(3, \"%s: req %d xfer complete %d/%d status %d -> 0\\n\", __func__,\n\t\t\t    ep->num_req, len, ep->maxpacket, urbstat);\n\t\t\tif (usb_pipecontrol(urb->pipe)) {\n\t\t\t\tDBG(3, \"%s: req %d %s Wait for ACK\\n\", __func__,\n\t\t\t\t    ep->num_req,\n\t\t\t\t    usb_pipein(urb->pipe) ? \"IN\" : \"OUT\");\n\t\t\t\tep->nextpid = USB_PID_ACK;\n\t\t\t} else {\n\t\t\t\turbstat = 0;\n\t\t\t\tDBG(3, \"%s: req %d URB %s status %d count %d/%d/%d\\n\",\n\t\t\t\t    __func__, ep->num_req, usb_pipein(urb->pipe) ? \"IN\" : \"OUT\",\n\t\t\t\t    urbstat, len, ep->maxpacket, urb->actual_length);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase USB_PID_SETUP:\n\t\tif (urb->transfer_buffer_length == urb->actual_length) {\n\t\t\tep->nextpid = USB_PID_ACK;\n\t\t} else if (usb_pipeout(urb->pipe)) {\n\t\t\tusb_settoggle(udev, 0, 1, 1);\n\t\t\tep->nextpid = USB_PID_OUT;\n\t\t} else {\n\t\t\tusb_settoggle(udev, 0, 0, 1);\n\t\t\tep->nextpid = USB_PID_IN;\n\t\t}\n\t\tbreak;\n\tcase USB_PID_ACK:\n\t\tDBG(3, \"%s: req %d got ACK %d -> 0\\n\", __func__, ep->num_req,\n\t\t    urbstat);\n\t\tWARN_ON(urbstat != -EINPROGRESS);\n\t\turbstat = 0;\n\t\tep->nextpid = 0;\n\t\tbreak;\n\tdefault:\n\t\tBUG_ON(1);\n\t}\n\n out:\n\tif (urbstat != -EINPROGRESS) {\n\t\tDBG(2, \"%s: Finishing ep %p req %d urb %p status %d\\n\", __func__,\n\t\t    ep, ep->num_req, urb, urbstat);\n\t\tfinish_request(isp1362_hcd, ep, urb, urbstat);\n\t}\n}\n\nstatic void finish_unlinks(struct isp1362_hcd *isp1362_hcd)\n{\n\tstruct isp1362_ep *ep;\n\tstruct isp1362_ep *tmp;\n\n\tlist_for_each_entry_safe(ep, tmp, &isp1362_hcd->remove_list, remove_list) {\n\t\tstruct isp1362_ep_queue *epq =\n\t\t\tget_ptd_queue(isp1362_hcd, ep->ptd_offset);\n\t\tint index = ep->ptd_index;\n\n\t\tBUG_ON(epq == NULL);\n\t\tif (index >= 0) {\n\t\t\tDBG(1, \"%s: remove PTD[%d] $%04x\\n\", __func__, index, ep->ptd_offset);\n\t\t\tBUG_ON(ep->num_ptds == 0);\n\t\t\trelease_ptd_buffers(epq, ep);\n\t\t}\n\t\tif (!list_empty(&ep->hep->urb_list)) {\n\t\t\tstruct urb *urb = get_urb(ep);\n\n\t\t\tDBG(1, \"%s: Finishing req %d ep %p from remove_list\\n\", __func__,\n\t\t\t    ep->num_req, ep);\n\t\t\tfinish_request(isp1362_hcd, ep, urb, -ESHUTDOWN);\n\t\t}\n\t\tWARN_ON(list_empty(&ep->active));\n\t\tif (!list_empty(&ep->active)) {\n\t\t\tlist_del_init(&ep->active);\n\t\t\tDBG(1, \"%s: ep %p removed from active list\\n\", __func__, ep);\n\t\t}\n\t\tlist_del_init(&ep->remove_list);\n\t\tDBG(1, \"%s: ep %p removed from remove_list\\n\", __func__, ep);\n\t}\n\tDBG(1, \"%s: Done\\n\", __func__);\n}\n\nstatic inline void enable_atl_transfers(struct isp1362_hcd *isp1362_hcd, int count)\n{\n\tif (count > 0) {\n\t\tif (count < isp1362_hcd->atl_queue.ptd_count)\n\t\t\tisp1362_write_reg16(isp1362_hcd, HCATLDTC, count);\n\t\tisp1362_enable_int(isp1362_hcd, HCuPINT_ATL);\n\t\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP, isp1362_hcd->atl_queue.skip_map);\n\t\tisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\n\t} else\n\t\tisp1362_enable_int(isp1362_hcd, HCuPINT_SOF);\n}\n\nstatic inline void enable_intl_transfers(struct isp1362_hcd *isp1362_hcd)\n{\n\tisp1362_enable_int(isp1362_hcd, HCuPINT_INTL);\n\tisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\n\tisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, isp1362_hcd->intl_queue.skip_map);\n}\n\nstatic inline void enable_istl_transfers(struct isp1362_hcd *isp1362_hcd, int flip)\n{\n\tisp1362_enable_int(isp1362_hcd, flip ? HCuPINT_ISTL1 : HCuPINT_ISTL0);\n\tisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, flip ?\n\t\t\t   HCBUFSTAT_ISTL1_FULL : HCBUFSTAT_ISTL0_FULL);\n}\n\nstatic int submit_req(struct isp1362_hcd *isp1362_hcd, struct urb *urb,\n\t\t      struct isp1362_ep *ep, struct isp1362_ep_queue *epq)\n{\n\tint index;\n\n\tprepare_ptd(isp1362_hcd, urb, ep, epq, 0);\n\tindex = claim_ptd_buffers(epq, ep, ep->length);\n\tif (index == -ENOMEM) {\n\t\tDBG(1, \"%s: req %d No free %s PTD available: %d, %08lx:%08lx\\n\", __func__,\n\t\t    ep->num_req, epq->name, ep->num_ptds, epq->buf_map, epq->skip_map);\n\t\treturn index;\n\t} else if (index == -EOVERFLOW) {\n\t\tDBG(1, \"%s: req %d Not enough space for %d byte %s PTD %d %08lx:%08lx\\n\",\n\t\t    __func__, ep->num_req, ep->length, epq->name, ep->num_ptds,\n\t\t    epq->buf_map, epq->skip_map);\n\t\treturn index;\n\t} else\n\t\tBUG_ON(index < 0);\n\tlist_add_tail(&ep->active, &epq->active);\n\tDBG(1, \"%s: ep %p req %d len %d added to active list %p\\n\", __func__,\n\t    ep, ep->num_req, ep->length, &epq->active);\n\tDBG(1, \"%s: Submitting %s PTD $%04x for ep %p req %d\\n\", __func__, epq->name,\n\t    ep->ptd_offset, ep, ep->num_req);\n\tisp1362_write_ptd(isp1362_hcd, ep, epq);\n\t__clear_bit(ep->ptd_index, &epq->skip_map);\n\n\treturn 0;\n}\n\nstatic void start_atl_transfers(struct isp1362_hcd *isp1362_hcd)\n{\n\tint ptd_count = 0;\n\tstruct isp1362_ep_queue *epq = &isp1362_hcd->atl_queue;\n\tstruct isp1362_ep *ep;\n\tint defer = 0;\n\n\tif (atomic_read(&epq->finishing)) {\n\t\tDBG(1, \"%s: finish_transfers is active for %s\\n\", __func__, epq->name);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ep, &isp1362_hcd->async, schedule) {\n\t\tstruct urb *urb = get_urb(ep);\n\t\tint ret;\n\n\t\tif (!list_empty(&ep->active)) {\n\t\t\tDBG(2, \"%s: Skipping active %s ep %p\\n\", __func__, epq->name, ep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDBG(1, \"%s: Processing %s ep %p req %d\\n\", __func__, epq->name,\n\t\t    ep, ep->num_req);\n\n\t\tret = submit_req(isp1362_hcd, urb, ep, epq);\n\t\tif (ret == -ENOMEM) {\n\t\t\tdefer = 1;\n\t\t\tbreak;\n\t\t} else if (ret == -EOVERFLOW) {\n\t\t\tdefer = 1;\n\t\t\tcontinue;\n\t\t}\n#ifdef BUGGY_PXA2XX_UDC_USBTEST\n\t\tdefer = ep->nextpid == USB_PID_SETUP;\n#endif\n\t\tptd_count++;\n\t}\n\n\t \n\tif (isp1362_hcd->async.next != isp1362_hcd->async.prev) {\n\t\tDBG(2, \"%s: Cycling ASYNC schedule %d\\n\", __func__, ptd_count);\n\t\tlist_move(&isp1362_hcd->async, isp1362_hcd->async.next);\n\t}\n\tif (ptd_count || defer)\n\t\tenable_atl_transfers(isp1362_hcd, defer ? 0 : ptd_count);\n\n\tepq->ptd_count += ptd_count;\n\tif (epq->ptd_count > epq->stat_maxptds) {\n\t\tepq->stat_maxptds = epq->ptd_count;\n\t\tDBG(0, \"%s: max_ptds: %d\\n\", __func__, epq->stat_maxptds);\n\t}\n}\n\nstatic void start_intl_transfers(struct isp1362_hcd *isp1362_hcd)\n{\n\tint ptd_count = 0;\n\tstruct isp1362_ep_queue *epq = &isp1362_hcd->intl_queue;\n\tstruct isp1362_ep *ep;\n\n\tif (atomic_read(&epq->finishing)) {\n\t\tDBG(1, \"%s: finish_transfers is active for %s\\n\", __func__, epq->name);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry(ep, &isp1362_hcd->periodic, schedule) {\n\t\tstruct urb *urb = get_urb(ep);\n\t\tint ret;\n\n\t\tif (!list_empty(&ep->active)) {\n\t\t\tDBG(1, \"%s: Skipping active %s ep %p\\n\", __func__,\n\t\t\t    epq->name, ep);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDBG(1, \"%s: Processing %s ep %p req %d\\n\", __func__,\n\t\t    epq->name, ep, ep->num_req);\n\t\tret = submit_req(isp1362_hcd, urb, ep, epq);\n\t\tif (ret == -ENOMEM)\n\t\t\tbreak;\n\t\telse if (ret == -EOVERFLOW)\n\t\t\tcontinue;\n\t\tptd_count++;\n\t}\n\n\tif (ptd_count) {\n\t\tstatic int last_count;\n\n\t\tif (ptd_count != last_count) {\n\t\t\tDBG(0, \"%s: ptd_count: %d\\n\", __func__, ptd_count);\n\t\t\tlast_count = ptd_count;\n\t\t}\n\t\tenable_intl_transfers(isp1362_hcd);\n\t}\n\n\tepq->ptd_count += ptd_count;\n\tif (epq->ptd_count > epq->stat_maxptds)\n\t\tepq->stat_maxptds = epq->ptd_count;\n}\n\nstatic inline int next_ptd(struct isp1362_ep_queue *epq, struct isp1362_ep *ep)\n{\n\tu16 ptd_offset = ep->ptd_offset;\n\tint num_ptds = (ep->length + PTD_HEADER_SIZE + (epq->blk_size - 1)) / epq->blk_size;\n\n\tDBG(2, \"%s: PTD offset $%04x + %04x => %d * %04x -> $%04x\\n\", __func__, ptd_offset,\n\t    ep->length, num_ptds, epq->blk_size, ptd_offset + num_ptds * epq->blk_size);\n\n\tptd_offset += num_ptds * epq->blk_size;\n\tif (ptd_offset < epq->buf_start + epq->buf_size)\n\t\treturn ptd_offset;\n\telse\n\t\treturn -ENOMEM;\n}\n\nstatic void start_iso_transfers(struct isp1362_hcd *isp1362_hcd)\n{\n\tint ptd_count = 0;\n\tint flip = isp1362_hcd->istl_flip;\n\tstruct isp1362_ep_queue *epq;\n\tint ptd_offset;\n\tstruct isp1362_ep *ep;\n\tstruct isp1362_ep *tmp;\n\tu16 fno = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\n\n fill2:\n\tepq = &isp1362_hcd->istl_queue[flip];\n\tif (atomic_read(&epq->finishing)) {\n\t\tDBG(1, \"%s: finish_transfers is active for %s\\n\", __func__, epq->name);\n\t\treturn;\n\t}\n\n\tif (!list_empty(&epq->active))\n\t\treturn;\n\n\tptd_offset = epq->buf_start;\n\tlist_for_each_entry_safe(ep, tmp, &isp1362_hcd->isoc, schedule) {\n\t\tstruct urb *urb = get_urb(ep);\n\t\ts16 diff = fno - (u16)urb->start_frame;\n\n\t\tDBG(1, \"%s: Processing %s ep %p\\n\", __func__, epq->name, ep);\n\n\t\tif (diff > urb->number_of_packets) {\n\t\t\t \n\t\t\tfinish_request(isp1362_hcd, ep, urb, -EOVERFLOW);\n\t\t\tcontinue;\n\t\t} else if (diff < -1) {\n\t\t\t \n\t\t} else if (diff == -1) {\n\t\t\t \n\t\t\tprepare_ptd(isp1362_hcd, urb, ep, epq, fno);\n\t\t\tif (ptd_offset + PTD_HEADER_SIZE + ep->length >\n\t\t\t    epq->buf_start + epq->buf_size) {\n\t\t\t\tpr_err(\"%s: Not enough ISO buffer space for %d byte PTD\\n\",\n\t\t\t\t    __func__, ep->length);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tep->ptd_offset = ptd_offset;\n\t\t\tlist_add_tail(&ep->active, &epq->active);\n\n\t\t\tptd_offset = next_ptd(epq, ep);\n\t\t\tif (ptd_offset < 0) {\n\t\t\t\tpr_warn(\"%s: req %d No more %s PTD buffers available\\n\",\n\t\t\t\t\t__func__, ep->num_req, epq->name);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlist_for_each_entry(ep, &epq->active, active) {\n\t\tif (epq->active.next == &ep->active)\n\t\t\tep->ptd.mps |= PTD_LAST_MSK;\n\t\tisp1362_write_ptd(isp1362_hcd, ep, epq);\n\t\tptd_count++;\n\t}\n\n\tif (ptd_count)\n\t\tenable_istl_transfers(isp1362_hcd, flip);\n\n\tepq->ptd_count += ptd_count;\n\tif (epq->ptd_count > epq->stat_maxptds)\n\t\tepq->stat_maxptds = epq->ptd_count;\n\n\t \n\tif (!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\n\t      (flip ? HCBUFSTAT_ISTL0_FULL : HCBUFSTAT_ISTL1_FULL))) {\n\t\tfno++;\n\t\tptd_count = 0;\n\t\tflip = 1 - flip;\n\t\tgoto fill2;\n\t}\n}\n\nstatic void finish_transfers(struct isp1362_hcd *isp1362_hcd, unsigned long done_map,\n\t\t\t     struct isp1362_ep_queue *epq)\n{\n\tstruct isp1362_ep *ep;\n\tstruct isp1362_ep *tmp;\n\n\tif (list_empty(&epq->active)) {\n\t\tDBG(1, \"%s: Nothing to do for %s queue\\n\", __func__, epq->name);\n\t\treturn;\n\t}\n\n\tDBG(1, \"%s: Finishing %s transfers %08lx\\n\", __func__, epq->name, done_map);\n\n\tatomic_inc(&epq->finishing);\n\tlist_for_each_entry_safe(ep, tmp, &epq->active, active) {\n\t\tint index = ep->ptd_index;\n\n\t\tDBG(1, \"%s: Checking %s PTD[%02x] $%04x\\n\", __func__, epq->name,\n\t\t    index, ep->ptd_offset);\n\n\t\tBUG_ON(index < 0);\n\t\tif (__test_and_clear_bit(index, &done_map)) {\n\t\t\tisp1362_read_ptd(isp1362_hcd, ep, epq);\n\t\t\tepq->free_ptd = index;\n\t\t\tBUG_ON(ep->num_ptds == 0);\n\t\t\trelease_ptd_buffers(epq, ep);\n\n\t\t\tDBG(1, \"%s: ep %p req %d removed from active list\\n\", __func__,\n\t\t\t    ep, ep->num_req);\n\t\t\tif (!list_empty(&ep->remove_list)) {\n\t\t\t\tlist_del_init(&ep->remove_list);\n\t\t\t\tDBG(1, \"%s: ep %p removed from remove list\\n\", __func__, ep);\n\t\t\t}\n\t\t\tDBG(1, \"%s: Postprocessing %s ep %p req %d\\n\", __func__, epq->name,\n\t\t\t    ep, ep->num_req);\n\t\t\tpostproc_ep(isp1362_hcd, ep);\n\t\t}\n\t\tif (!done_map)\n\t\t\tbreak;\n\t}\n\tif (done_map)\n\t\tpr_warn(\"%s: done_map not clear: %08lx:%08lx\\n\",\n\t\t\t__func__, done_map, epq->skip_map);\n\tatomic_dec(&epq->finishing);\n}\n\nstatic void finish_iso_transfers(struct isp1362_hcd *isp1362_hcd, struct isp1362_ep_queue *epq)\n{\n\tstruct isp1362_ep *ep;\n\tstruct isp1362_ep *tmp;\n\n\tif (list_empty(&epq->active)) {\n\t\tDBG(1, \"%s: Nothing to do for %s queue\\n\", __func__, epq->name);\n\t\treturn;\n\t}\n\n\tDBG(1, \"%s: Finishing %s transfers\\n\", __func__, epq->name);\n\n\tatomic_inc(&epq->finishing);\n\tlist_for_each_entry_safe(ep, tmp, &epq->active, active) {\n\t\tDBG(1, \"%s: Checking PTD $%04x\\n\", __func__, ep->ptd_offset);\n\n\t\tisp1362_read_ptd(isp1362_hcd, ep, epq);\n\t\tDBG(1, \"%s: Postprocessing %s ep %p\\n\", __func__, epq->name, ep);\n\t\tpostproc_ep(isp1362_hcd, ep);\n\t}\n\tWARN_ON(epq->blk_size != 0);\n\tatomic_dec(&epq->finishing);\n}\n\nstatic irqreturn_t isp1362_irq(struct usb_hcd *hcd)\n{\n\tint handled = 0;\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tu16 irqstat;\n\tu16 svc_mask;\n\n\tspin_lock(&isp1362_hcd->lock);\n\n\tBUG_ON(isp1362_hcd->irq_active++);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\n\n\tirqstat = isp1362_read_reg16(isp1362_hcd, HCuPINT);\n\tDBG(3, \"%s: got IRQ %04x:%04x\\n\", __func__, irqstat, isp1362_hcd->irqenb);\n\n\t \n\tirqstat &= isp1362_hcd->irqenb;\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, irqstat);\n\tsvc_mask = irqstat;\n\n\tif (irqstat & HCuPINT_SOF) {\n\t\tisp1362_hcd->irqenb &= ~HCuPINT_SOF;\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_SOF]++;\n\t\thandled = 1;\n\t\tsvc_mask &= ~HCuPINT_SOF;\n\t\tDBG(3, \"%s: SOF\\n\", __func__);\n\t\tisp1362_hcd->fmindex = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\n\t\tif (!list_empty(&isp1362_hcd->remove_list))\n\t\t\tfinish_unlinks(isp1362_hcd);\n\t\tif (!list_empty(&isp1362_hcd->async) && !(irqstat & HCuPINT_ATL)) {\n\t\t\tif (list_empty(&isp1362_hcd->atl_queue.active)) {\n\t\t\t\tstart_atl_transfers(isp1362_hcd);\n\t\t\t} else {\n\t\t\t\tisp1362_enable_int(isp1362_hcd, HCuPINT_ATL);\n\t\t\t\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP,\n\t\t\t\t\t\t    isp1362_hcd->atl_queue.skip_map);\n\t\t\t\tisp1362_set_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (irqstat & HCuPINT_ISTL0) {\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_ISTL0]++;\n\t\thandled = 1;\n\t\tsvc_mask &= ~HCuPINT_ISTL0;\n\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ISTL0_FULL);\n\t\tDBG(1, \"%s: ISTL0\\n\", __func__);\n\t\tWARN_ON((int)!!isp1362_hcd->istl_flip);\n\t\tWARN_ON(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\n\t\t\tHCBUFSTAT_ISTL0_ACTIVE);\n\t\tWARN_ON(!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\n\t\t\tHCBUFSTAT_ISTL0_DONE));\n\t\tisp1362_hcd->irqenb &= ~HCuPINT_ISTL0;\n\t}\n\n\tif (irqstat & HCuPINT_ISTL1) {\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_ISTL1]++;\n\t\thandled = 1;\n\t\tsvc_mask &= ~HCuPINT_ISTL1;\n\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ISTL1_FULL);\n\t\tDBG(1, \"%s: ISTL1\\n\", __func__);\n\t\tWARN_ON(!(int)isp1362_hcd->istl_flip);\n\t\tWARN_ON(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\n\t\t\tHCBUFSTAT_ISTL1_ACTIVE);\n\t\tWARN_ON(!(isp1362_read_reg16(isp1362_hcd, HCBUFSTAT) &\n\t\t\tHCBUFSTAT_ISTL1_DONE));\n\t\tisp1362_hcd->irqenb &= ~HCuPINT_ISTL1;\n\t}\n\n\tif (irqstat & (HCuPINT_ISTL0 | HCuPINT_ISTL1)) {\n\t\tWARN_ON((irqstat & (HCuPINT_ISTL0 | HCuPINT_ISTL1)) ==\n\t\t\t(HCuPINT_ISTL0 | HCuPINT_ISTL1));\n\t\tfinish_iso_transfers(isp1362_hcd,\n\t\t\t\t     &isp1362_hcd->istl_queue[isp1362_hcd->istl_flip]);\n\t\tstart_iso_transfers(isp1362_hcd);\n\t\tisp1362_hcd->istl_flip = 1 - isp1362_hcd->istl_flip;\n\t}\n\n\tif (irqstat & HCuPINT_INTL) {\n\t\tu32 done_map = isp1362_read_reg32(isp1362_hcd, HCINTLDONE);\n\t\tu32 skip_map = isp1362_read_reg32(isp1362_hcd, HCINTLSKIP);\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_INTL]++;\n\n\t\tDBG(2, \"%s: INTL\\n\", __func__);\n\n\t\tsvc_mask &= ~HCuPINT_INTL;\n\n\t\tisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, skip_map | done_map);\n\t\tif (~(done_map | skip_map) == 0)\n\t\t\t \n\t\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_INTL_ACTIVE);\n\n\t\thandled = 1;\n\t\tWARN_ON(!done_map);\n\t\tif (done_map) {\n\t\t\tDBG(3, \"%s: INTL done_map %08x\\n\", __func__, done_map);\n\t\t\tfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->intl_queue);\n\t\t\tstart_intl_transfers(isp1362_hcd);\n\t\t}\n\t}\n\n\tif (irqstat & HCuPINT_ATL) {\n\t\tu32 done_map = isp1362_read_reg32(isp1362_hcd, HCATLDONE);\n\t\tu32 skip_map = isp1362_read_reg32(isp1362_hcd, HCATLSKIP);\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_ATL]++;\n\n\t\tDBG(2, \"%s: ATL\\n\", __func__);\n\n\t\tsvc_mask &= ~HCuPINT_ATL;\n\n\t\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP, skip_map | done_map);\n\t\tif (~(done_map | skip_map) == 0)\n\t\t\tisp1362_clr_mask16(isp1362_hcd, HCBUFSTAT, HCBUFSTAT_ATL_ACTIVE);\n\t\tif (done_map) {\n\t\t\tDBG(3, \"%s: ATL done_map %08x\\n\", __func__, done_map);\n\t\t\tfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->atl_queue);\n\t\t\tstart_atl_transfers(isp1362_hcd);\n\t\t}\n\t\thandled = 1;\n\t}\n\n\tif (irqstat & HCuPINT_OPR) {\n\t\tu32 intstat = isp1362_read_reg32(isp1362_hcd, HCINTSTAT);\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_OPR]++;\n\n\t\tsvc_mask &= ~HCuPINT_OPR;\n\t\tDBG(2, \"%s: OPR %08x:%08x\\n\", __func__, intstat, isp1362_hcd->intenb);\n\t\tintstat &= isp1362_hcd->intenb;\n\t\tif (intstat & OHCI_INTR_UE) {\n\t\t\tpr_err(\"Unrecoverable error\\n\");\n\t\t\t \n\t\t}\n\t\tif (intstat & OHCI_INTR_RHSC) {\n\t\t\tisp1362_hcd->rhstatus = isp1362_read_reg32(isp1362_hcd, HCRHSTATUS);\n\t\t\tisp1362_hcd->rhport[0] = isp1362_read_reg32(isp1362_hcd, HCRHPORT1);\n\t\t\tisp1362_hcd->rhport[1] = isp1362_read_reg32(isp1362_hcd, HCRHPORT2);\n\t\t}\n\t\tif (intstat & OHCI_INTR_RD) {\n\t\t\tpr_info(\"%s: RESUME DETECTED\\n\", __func__);\n\t\t\tisp1362_show_reg(isp1362_hcd, HCCONTROL);\n\t\t\tusb_hcd_resume_root_hub(hcd);\n\t\t}\n\t\tisp1362_write_reg32(isp1362_hcd, HCINTSTAT, intstat);\n\t\tirqstat &= ~HCuPINT_OPR;\n\t\thandled = 1;\n\t}\n\n\tif (irqstat & HCuPINT_SUSP) {\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_SUSP]++;\n\t\thandled = 1;\n\t\tsvc_mask &= ~HCuPINT_SUSP;\n\n\t\tpr_info(\"%s: SUSPEND IRQ\\n\", __func__);\n\t}\n\n\tif (irqstat & HCuPINT_CLKRDY) {\n\t\tisp1362_hcd->irq_stat[ISP1362_INT_CLKRDY]++;\n\t\thandled = 1;\n\t\tisp1362_hcd->irqenb &= ~HCuPINT_CLKRDY;\n\t\tsvc_mask &= ~HCuPINT_CLKRDY;\n\t\tpr_info(\"%s: CLKRDY IRQ\\n\", __func__);\n\t}\n\n\tif (svc_mask)\n\t\tpr_err(\"%s: Unserviced interrupt(s) %04x\\n\", __func__, svc_mask);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\n\tisp1362_hcd->irq_active--;\n\tspin_unlock(&isp1362_hcd->lock);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n \n\n#define\tMAX_PERIODIC_LOAD\t900\t \nstatic int balance(struct isp1362_hcd *isp1362_hcd, u16 interval, u16 load)\n{\n\tint i, branch = -ENOSPC;\n\n\t \n\tfor (i = 0; i < interval; i++) {\n\t\tif (branch < 0 || isp1362_hcd->load[branch] > isp1362_hcd->load[i]) {\n\t\t\tint j;\n\n\t\t\tfor (j = i; j < PERIODIC_SIZE; j += interval) {\n\t\t\t\tif ((isp1362_hcd->load[j] + load) > MAX_PERIODIC_LOAD) {\n\t\t\t\t\tpr_err(\"%s: new load %d load[%02x] %d max %d\\n\", __func__,\n\t\t\t\t\t    load, j, isp1362_hcd->load[j], MAX_PERIODIC_LOAD);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j < PERIODIC_SIZE)\n\t\t\t\tcontinue;\n\t\t\tbranch = i;\n\t\t}\n\t}\n\treturn branch;\n}\n\n \n\n \n\nstatic int isp1362_urb_enqueue(struct usb_hcd *hcd,\n\t\t\t       struct urb *urb,\n\t\t\t       gfp_t mem_flags)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tstruct usb_device *udev = urb->dev;\n\tunsigned int pipe = urb->pipe;\n\tint is_out = !usb_pipein(pipe);\n\tint type = usb_pipetype(pipe);\n\tint epnum = usb_pipeendpoint(pipe);\n\tstruct usb_host_endpoint *hep = urb->ep;\n\tstruct isp1362_ep *ep = NULL;\n\tunsigned long flags;\n\tint retval = 0;\n\n\tDBG(3, \"%s: urb %p\\n\", __func__, urb);\n\n\tif (type == PIPE_ISOCHRONOUS) {\n\t\tpr_err(\"Isochronous transfers not supported\\n\");\n\t\treturn -ENOSPC;\n\t}\n\n\tURB_DBG(\"%s: FA %d ep%d%s %s: len %d %s%s\\n\", __func__,\n\t\tusb_pipedevice(pipe), epnum,\n\t\tis_out ? \"out\" : \"in\",\n\t\tusb_pipecontrol(pipe) ? \"ctrl\" :\n\t\t\tusb_pipeint(pipe) ? \"int\" :\n\t\t\tusb_pipebulk(pipe) ? \"bulk\" :\n\t\t\t\"iso\",\n\t\turb->transfer_buffer_length,\n\t\t(urb->transfer_flags & URB_ZERO_PACKET) ? \"ZERO_PACKET \" : \"\",\n\t\t!(urb->transfer_flags & URB_SHORT_NOT_OK) ?\n\t\t\"short_ok\" : \"\");\n\n\t \n\tif (!hep->hcpriv) {\n\t\tep = kzalloc(sizeof *ep, mem_flags);\n\t\tif (!ep)\n\t\t\treturn -ENOMEM;\n\t}\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\t \n\tif (!((isp1362_hcd->rhport[0] | isp1362_hcd->rhport[1]) &\n\t      USB_PORT_STAT_ENABLE) ||\n\t    !HC_IS_RUNNING(hcd->state)) {\n\t\tkfree(ep);\n\t\tretval = -ENODEV;\n\t\tgoto fail_not_linked;\n\t}\n\n\tretval = usb_hcd_link_urb_to_ep(hcd, urb);\n\tif (retval) {\n\t\tkfree(ep);\n\t\tgoto fail_not_linked;\n\t}\n\n\tif (hep->hcpriv) {\n\t\tep = hep->hcpriv;\n\t} else {\n\t\tINIT_LIST_HEAD(&ep->schedule);\n\t\tINIT_LIST_HEAD(&ep->active);\n\t\tINIT_LIST_HEAD(&ep->remove_list);\n\t\tep->udev = usb_get_dev(udev);\n\t\tep->hep = hep;\n\t\tep->epnum = epnum;\n\t\tep->maxpacket = usb_maxpacket(udev, urb->pipe);\n\t\tep->ptd_offset = -EINVAL;\n\t\tep->ptd_index = -EINVAL;\n\t\tusb_settoggle(udev, epnum, is_out, 0);\n\n\t\tif (type == PIPE_CONTROL)\n\t\t\tep->nextpid = USB_PID_SETUP;\n\t\telse if (is_out)\n\t\t\tep->nextpid = USB_PID_OUT;\n\t\telse\n\t\t\tep->nextpid = USB_PID_IN;\n\n\t\tswitch (type) {\n\t\tcase PIPE_ISOCHRONOUS:\n\t\tcase PIPE_INTERRUPT:\n\t\t\tif (urb->interval > PERIODIC_SIZE)\n\t\t\t\turb->interval = PERIODIC_SIZE;\n\t\t\tep->interval = urb->interval;\n\t\t\tep->branch = PERIODIC_SIZE;\n\t\t\tep->load = usb_calc_bus_time(udev->speed, !is_out,\n\t\t\t\t\t\t     type == PIPE_ISOCHRONOUS,\n\t\t\t\t\t\t     usb_maxpacket(udev, pipe)) / 1000;\n\t\t\tbreak;\n\t\t}\n\t\thep->hcpriv = ep;\n\t}\n\tep->num_req = isp1362_hcd->req_serial++;\n\n\t \n\tswitch (type) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\t\tif (list_empty(&ep->schedule)) {\n\t\t\tDBG(1, \"%s: Adding ep %p req %d to async schedule\\n\",\n\t\t\t\t__func__, ep, ep->num_req);\n\t\t\tlist_add_tail(&ep->schedule, &isp1362_hcd->async);\n\t\t}\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\tcase PIPE_INTERRUPT:\n\t\turb->interval = ep->interval;\n\n\t\t \n\t\tif (ep->branch < PERIODIC_SIZE)\n\t\t\tbreak;\n\n\t\tretval = balance(isp1362_hcd, ep->interval, ep->load);\n\t\tif (retval < 0) {\n\t\t\tpr_err(\"%s: balance returned %d\\n\", __func__, retval);\n\t\t\tgoto fail;\n\t\t}\n\t\tep->branch = retval;\n\t\tretval = 0;\n\t\tisp1362_hcd->fmindex = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\n\t\tDBG(1, \"%s: Current frame %04x branch %02x start_frame %04x(%04x)\\n\",\n\t\t    __func__, isp1362_hcd->fmindex, ep->branch,\n\t\t    ((isp1362_hcd->fmindex + PERIODIC_SIZE - 1) &\n\t\t     ~(PERIODIC_SIZE - 1)) + ep->branch,\n\t\t    (isp1362_hcd->fmindex & (PERIODIC_SIZE - 1)) + ep->branch);\n\n\t\tif (list_empty(&ep->schedule)) {\n\t\t\tif (type == PIPE_ISOCHRONOUS) {\n\t\t\t\tu16 frame = isp1362_hcd->fmindex;\n\n\t\t\t\tframe += max_t(u16, 8, ep->interval);\n\t\t\t\tframe &= ~(ep->interval - 1);\n\t\t\t\tframe |= ep->branch;\n\t\t\t\tif (frame_before(frame, isp1362_hcd->fmindex))\n\t\t\t\t\tframe += ep->interval;\n\t\t\t\turb->start_frame = frame;\n\n\t\t\t\tDBG(1, \"%s: Adding ep %p to isoc schedule\\n\", __func__, ep);\n\t\t\t\tlist_add_tail(&ep->schedule, &isp1362_hcd->isoc);\n\t\t\t} else {\n\t\t\t\tDBG(1, \"%s: Adding ep %p to periodic schedule\\n\", __func__, ep);\n\t\t\t\tlist_add_tail(&ep->schedule, &isp1362_hcd->periodic);\n\t\t\t}\n\t\t} else\n\t\t\tDBG(1, \"%s: ep %p already scheduled\\n\", __func__, ep);\n\n\t\tDBG(2, \"%s: load %d bandwidth %d -> %d\\n\", __func__,\n\t\t    ep->load / ep->interval, isp1362_hcd->load[ep->branch],\n\t\t    isp1362_hcd->load[ep->branch] + ep->load);\n\t\tisp1362_hcd->load[ep->branch] += ep->load;\n\t}\n\n\turb->hcpriv = hep;\n\tALIGNSTAT(isp1362_hcd, urb->transfer_buffer);\n\n\tswitch (type) {\n\tcase PIPE_CONTROL:\n\tcase PIPE_BULK:\n\t\tstart_atl_transfers(isp1362_hcd);\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tstart_intl_transfers(isp1362_hcd);\n\t\tbreak;\n\tcase PIPE_ISOCHRONOUS:\n\t\tstart_iso_transfers(isp1362_hcd);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n fail:\n\tif (retval)\n\t\tusb_hcd_unlink_urb_from_ep(hcd, urb);\n\n\n fail_not_linked:\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\tif (retval)\n\t\tDBG(0, \"%s: urb %p failed with %d\\n\", __func__, urb, retval);\n\treturn retval;\n}\n\nstatic int isp1362_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tstruct usb_host_endpoint *hep;\n\tunsigned long flags;\n\tstruct isp1362_ep *ep;\n\tint retval = 0;\n\n\tDBG(3, \"%s: urb %p\\n\", __func__, urb);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tretval = usb_hcd_check_unlink_urb(hcd, urb, status);\n\tif (retval)\n\t\tgoto done;\n\n\thep = urb->hcpriv;\n\n\tif (!hep) {\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\treturn -EIDRM;\n\t}\n\n\tep = hep->hcpriv;\n\tif (ep) {\n\t\t \n\t\tif (ep->hep->urb_list.next == &urb->urb_list) {\n\t\t\tif (!list_empty(&ep->active)) {\n\t\t\t\tDBG(1, \"%s: urb %p ep %p req %d active PTD[%d] $%04x\\n\", __func__,\n\t\t\t\t    urb, ep, ep->num_req, ep->ptd_index, ep->ptd_offset);\n\t\t\t\t \n\t\t\t\tremove_ptd(isp1362_hcd, ep);\n\t\t\t\turb = NULL;\n\t\t\t}\n\t\t}\n\t\tif (urb) {\n\t\t\tDBG(1, \"%s: Finishing ep %p req %d\\n\", __func__, ep,\n\t\t\t    ep->num_req);\n\t\t\tfinish_request(isp1362_hcd, ep, urb, status);\n\t\t} else\n\t\t\tDBG(1, \"%s: urb %p active; wait4irq\\n\", __func__, urb);\n\t} else {\n\t\tpr_warn(\"%s: No EP in URB %p\\n\", __func__, urb);\n\t\tretval = -EINVAL;\n\t}\ndone:\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\tDBG(3, \"%s: exit\\n\", __func__);\n\n\treturn retval;\n}\n\nstatic void isp1362_endpoint_disable(struct usb_hcd *hcd, struct usb_host_endpoint *hep)\n{\n\tstruct isp1362_ep *ep = hep->hcpriv;\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\n\tDBG(1, \"%s: ep %p\\n\", __func__, ep);\n\tif (!ep)\n\t\treturn;\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tif (!list_empty(&hep->urb_list)) {\n\t\tif (!list_empty(&ep->active) && list_empty(&ep->remove_list)) {\n\t\t\tDBG(1, \"%s: Removing ep %p req %d PTD[%d] $%04x\\n\", __func__,\n\t\t\t    ep, ep->num_req, ep->ptd_index, ep->ptd_offset);\n\t\t\tremove_ptd(isp1362_hcd, ep);\n\t\t\tpr_info(\"%s: Waiting for Interrupt to clean up\\n\", __func__);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t \n\twhile (!list_empty(&ep->active))\n\t\tmsleep(1);\n\n\tDBG(1, \"%s: Freeing EP %p\\n\", __func__, ep);\n\n\tusb_put_dev(ep->udev);\n\tkfree(ep);\n\thep->hcpriv = NULL;\n}\n\nstatic int isp1362_get_frame(struct usb_hcd *hcd)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tu32 fmnum;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tfmnum = isp1362_read_reg32(isp1362_hcd, HCFMNUM);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\treturn (int)fmnum;\n}\n\n \n\n \nstatic int isp1362_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tint ports, i, changed = 0;\n\tunsigned long flags;\n\n\tif (!HC_IS_RUNNING(hcd->state))\n\t\treturn -ESHUTDOWN;\n\n\t \n\tif (timer_pending(&hcd->rh_timer))\n\t\treturn 0;\n\n\tports = isp1362_hcd->rhdesca & RH_A_NDP;\n\tBUG_ON(ports > 2);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t \n\tif (isp1362_hcd->rhstatus & (RH_HS_LPSC | RH_HS_OCIC))\n\t\tbuf[0] = changed = 1;\n\telse\n\t\tbuf[0] = 0;\n\n\tfor (i = 0; i < ports; i++) {\n\t\tu32 status = isp1362_hcd->rhport[i];\n\n\t\tif (status & (RH_PS_CSC | RH_PS_PESC | RH_PS_PSSC |\n\t\t\t      RH_PS_OCIC | RH_PS_PRSC)) {\n\t\t\tchanged = 1;\n\t\t\tbuf[0] |= 1 << (i + 1);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(status & RH_PS_CCS))\n\t\t\tcontinue;\n\t}\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\treturn changed;\n}\n\nstatic void isp1362_hub_descriptor(struct isp1362_hcd *isp1362_hcd,\n\t\t\t\t   struct usb_hub_descriptor *desc)\n{\n\tu32 reg = isp1362_hcd->rhdesca;\n\n\tDBG(3, \"%s: enter\\n\", __func__);\n\n\tdesc->bDescriptorType = USB_DT_HUB;\n\tdesc->bDescLength = 9;\n\tdesc->bHubContrCurrent = 0;\n\tdesc->bNbrPorts = reg & 0x3;\n\t \n\tdesc->wHubCharacteristics = cpu_to_le16((reg >> 8) &\n\t\t\t\t\t\t(HUB_CHAR_LPSM |\n\t\t\t\t\t\t HUB_CHAR_COMPOUND |\n\t\t\t\t\t\t HUB_CHAR_OCPM));\n\tDBG(0, \"%s: hubcharacteristics = %02x\\n\", __func__,\n\t\t\tdesc->wHubCharacteristics);\n\tdesc->bPwrOn2PwrGood = (reg >> 24) & 0xff;\n\t \n\tdesc->u.hs.DeviceRemovable[0] = desc->bNbrPorts == 1 ? 1 << 1 : 3 << 1;\n\tdesc->u.hs.DeviceRemovable[1] = ~0;\n\n\tDBG(3, \"%s: exit\\n\", __func__);\n}\n\n \nstatic int isp1362_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t       u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tint retval = 0;\n\tunsigned long flags;\n\tunsigned long t1;\n\tint ports = isp1362_hcd->rhdesca & RH_A_NDP;\n\tu32 tmp = 0;\n\n\tswitch (typeReq) {\n\tcase ClearHubFeature:\n\t\tDBG(0, \"ClearHubFeature: \");\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\t\tDBG(0, \"C_HUB_OVER_CURRENT\\n\");\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\tisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_OCIC);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tbreak;\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tDBG(0, \"C_HUB_LOCAL_POWER\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase SetHubFeature:\n\t\tDBG(0, \"SetHubFeature: \");\n\t\tswitch (wValue) {\n\t\tcase C_HUB_OVER_CURRENT:\n\t\tcase C_HUB_LOCAL_POWER:\n\t\t\tDBG(0, \"C_HUB_OVER_CURRENT or C_HUB_LOCAL_POWER\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\tcase GetHubDescriptor:\n\t\tDBG(0, \"GetHubDescriptor\\n\");\n\t\tisp1362_hub_descriptor(isp1362_hcd, (struct usb_hub_descriptor *)buf);\n\t\tbreak;\n\tcase GetHubStatus:\n\t\tDBG(0, \"GetHubStatus\\n\");\n\t\tput_unaligned(cpu_to_le32(0), (__le32 *) buf);\n\t\tbreak;\n\tcase GetPortStatus:\n#ifndef VERBOSE\n\t\tDBG(0, \"GetPortStatus\\n\");\n#endif\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\ttmp = isp1362_hcd->rhport[--wIndex];\n\t\tput_unaligned(cpu_to_le32(tmp), (__le32 *) buf);\n\t\tbreak;\n\tcase ClearPortFeature:\n\t\tDBG(0, \"ClearPortFeature: \");\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_ENABLE:\n\t\t\tDBG(0, \"USB_PORT_FEAT_ENABLE\\n\");\n\t\t\ttmp = RH_PS_CCS;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_ENABLE:\n\t\t\tDBG(0, \"USB_PORT_FEAT_C_ENABLE\\n\");\n\t\t\ttmp = RH_PS_PESC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tDBG(0, \"USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\ttmp = RH_PS_POCI;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_SUSPEND:\n\t\t\tDBG(0, \"USB_PORT_FEAT_C_SUSPEND\\n\");\n\t\t\ttmp = RH_PS_PSSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tDBG(0, \"USB_PORT_FEAT_POWER\\n\");\n\t\t\ttmp = RH_PS_LSDA;\n\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_CONNECTION:\n\t\t\tDBG(0, \"USB_PORT_FEAT_C_CONNECTION\\n\");\n\t\t\ttmp = RH_PS_CSC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tDBG(0, \"USB_PORT_FEAT_C_OVER_CURRENT\\n\");\n\t\t\ttmp = RH_PS_OCIC;\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_C_RESET:\n\t\t\tDBG(0, \"USB_PORT_FEAT_C_RESET\\n\");\n\t\t\ttmp = RH_PS_PRSC;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\n\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\tisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, tmp);\n\t\tisp1362_hcd->rhport[wIndex] =\n\t\t\tisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\tbreak;\n\tcase SetPortFeature:\n\t\tDBG(0, \"SetPortFeature: \");\n\t\tif (!wIndex || wIndex > ports)\n\t\t\tgoto error;\n\t\twIndex--;\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tDBG(0, \"USB_PORT_FEAT_SUSPEND\\n\");\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\tisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, RH_PS_PSS);\n\t\t\tisp1362_hcd->rhport[wIndex] =\n\t\t\t\tisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tDBG(0, \"USB_PORT_FEAT_POWER\\n\");\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\tisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, RH_PS_PPS);\n\t\t\tisp1362_hcd->rhport[wIndex] =\n\t\t\t\tisp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tbreak;\n\t\tcase USB_PORT_FEAT_RESET:\n\t\t\tDBG(0, \"USB_PORT_FEAT_RESET\\n\");\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\t\t\tt1 = jiffies + msecs_to_jiffies(USB_RESET_WIDTH);\n\t\t\twhile (time_before(jiffies, t1)) {\n\t\t\t\t \n\t\t\t\tfor (;;) {\n\t\t\t\t\ttmp = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + wIndex);\n\t\t\t\t\tif (!(tmp & RH_PS_PRS))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tudelay(500);\n\t\t\t\t}\n\t\t\t\tif (!(tmp & RH_PS_CCS))\n\t\t\t\t\tbreak;\n\t\t\t\t \n\t\t\t\tisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + wIndex, (RH_PS_PRS));\n\n\t\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\t\tmsleep(10);\n\t\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\t}\n\n\t\t\tisp1362_hcd->rhport[wIndex] = isp1362_read_reg32(isp1362_hcd,\n\t\t\t\t\t\t\t\t\t HCRHPORT1 + wIndex);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto error;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n error:\n\t\t \n\t\tDBG(0, \"PROTOCOL STALL\\n\");\n\t\tretval = -EPIPE;\n\t}\n\n\treturn retval;\n}\n\n#ifdef\tCONFIG_PM\nstatic int isp1362_bus_suspend(struct usb_hcd *hcd)\n{\n\tint status = 0;\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\n\tif (time_before(jiffies, isp1362_hcd->next_statechange))\n\t\tmsleep(5);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\tisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\n\tswitch (isp1362_hcd->hc_control & OHCI_CTRL_HCFS) {\n\tcase OHCI_USB_RESUME:\n\t\tDBG(0, \"%s: resume/suspend?\\n\", __func__);\n\t\tisp1362_hcd->hc_control &= ~OHCI_CTRL_HCFS;\n\t\tisp1362_hcd->hc_control |= OHCI_USB_RESET;\n\t\tisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\n\t\tfallthrough;\n\tcase OHCI_USB_RESET:\n\t\tstatus = -EBUSY;\n\t\tpr_warn(\"%s: needs reinit!\\n\", __func__);\n\t\tgoto done;\n\tcase OHCI_USB_SUSPEND:\n\t\tpr_warn(\"%s: already suspended?\\n\", __func__);\n\t\tgoto done;\n\t}\n\tDBG(0, \"%s: suspend root hub\\n\", __func__);\n\n\t \n\thcd->state = HC_STATE_QUIESCING;\n\tif (!list_empty(&isp1362_hcd->atl_queue.active) ||\n\t    !list_empty(&isp1362_hcd->intl_queue.active) ||\n\t    !list_empty(&isp1362_hcd->istl_queue[0] .active) ||\n\t    !list_empty(&isp1362_hcd->istl_queue[1] .active)) {\n\t\tint limit;\n\n\t\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP, ~0);\n\t\tisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, ~0);\n\t\tisp1362_write_reg16(isp1362_hcd, HCBUFSTAT, 0);\n\t\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\n\t\tisp1362_write_reg32(isp1362_hcd, HCINTSTAT, OHCI_INTR_SF);\n\n\t\tDBG(0, \"%s: stopping schedules ...\\n\", __func__);\n\t\tlimit = 2000;\n\t\twhile (limit > 0) {\n\t\t\tudelay(250);\n\t\t\tlimit -= 250;\n\t\t\tif (isp1362_read_reg32(isp1362_hcd, HCINTSTAT) & OHCI_INTR_SF)\n\t\t\t\tbreak;\n\t\t}\n\t\tmdelay(7);\n\t\tif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ATL) {\n\t\t\tu32 done_map = isp1362_read_reg32(isp1362_hcd, HCATLDONE);\n\t\t\tfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->atl_queue);\n\t\t}\n\t\tif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_INTL) {\n\t\t\tu32 done_map = isp1362_read_reg32(isp1362_hcd, HCINTLDONE);\n\t\t\tfinish_transfers(isp1362_hcd, done_map, &isp1362_hcd->intl_queue);\n\t\t}\n\t\tif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ISTL0)\n\t\t\tfinish_iso_transfers(isp1362_hcd, &isp1362_hcd->istl_queue[0]);\n\t\tif (isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_ISTL1)\n\t\t\tfinish_iso_transfers(isp1362_hcd, &isp1362_hcd->istl_queue[1]);\n\t}\n\tDBG(0, \"%s: HCINTSTAT: %08x\\n\", __func__,\n\t\t    isp1362_read_reg32(isp1362_hcd, HCINTSTAT));\n\tisp1362_write_reg32(isp1362_hcd, HCINTSTAT,\n\t\t\t    isp1362_read_reg32(isp1362_hcd, HCINTSTAT));\n\n\t \n\tisp1362_hcd->hc_control = OHCI_USB_SUSPEND;\n\tisp1362_show_reg(isp1362_hcd, HCCONTROL);\n\tisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\n\tisp1362_show_reg(isp1362_hcd, HCCONTROL);\n\n#if 1\n\tisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\n\tif ((isp1362_hcd->hc_control & OHCI_CTRL_HCFS) != OHCI_USB_SUSPEND) {\n\t\tpr_err(\"%s: controller won't suspend %08x\\n\", __func__,\n\t\t    isp1362_hcd->hc_control);\n\t\tstatus = -EBUSY;\n\t} else\n#endif\n\t{\n\t\t \n\t\tisp1362_hcd->next_statechange = jiffies + msecs_to_jiffies(5);\n\t}\ndone:\n\tif (status == 0) {\n\t\thcd->state = HC_STATE_SUSPENDED;\n\t\tDBG(0, \"%s: HCD suspended: %08x\\n\", __func__,\n\t\t    isp1362_read_reg32(isp1362_hcd, HCCONTROL));\n\t}\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\treturn status;\n}\n\nstatic int isp1362_bus_resume(struct usb_hcd *hcd)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tu32 port;\n\tunsigned long flags;\n\tint status = -EINPROGRESS;\n\n\tif (time_before(jiffies, isp1362_hcd->next_statechange))\n\t\tmsleep(5);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tisp1362_hcd->hc_control = isp1362_read_reg32(isp1362_hcd, HCCONTROL);\n\tpr_info(\"%s: HCCONTROL: %08x\\n\", __func__, isp1362_hcd->hc_control);\n\tif (hcd->state == HC_STATE_RESUMING) {\n\t\tpr_warn(\"%s: duplicate resume\\n\", __func__);\n\t\tstatus = 0;\n\t} else\n\t\tswitch (isp1362_hcd->hc_control & OHCI_CTRL_HCFS) {\n\t\tcase OHCI_USB_SUSPEND:\n\t\t\tDBG(0, \"%s: resume root hub\\n\", __func__);\n\t\t\tisp1362_hcd->hc_control &= ~OHCI_CTRL_HCFS;\n\t\t\tisp1362_hcd->hc_control |= OHCI_USB_RESUME;\n\t\t\tisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\n\t\t\tbreak;\n\t\tcase OHCI_USB_RESUME:\n\t\t\t \n\t\t\tDBG(0, \"%s: remote wakeup\\n\", __func__);\n\t\t\tbreak;\n\t\tcase OHCI_USB_OPER:\n\t\t\tDBG(0, \"%s: odd resume\\n\", __func__);\n\t\t\tstatus = 0;\n\t\t\thcd->self.root_hub->dev.power.power_state = PMSG_ON;\n\t\t\tbreak;\n\t\tdefault:\t\t \n\t\t\tDBG(0, \"%s: root hub hardware reset\\n\", __func__);\n\t\t\tstatus = -EBUSY;\n\t\t}\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\tif (status == -EBUSY) {\n\t\tDBG(0, \"%s: Restarting HC\\n\", __func__);\n\t\tisp1362_hc_stop(hcd);\n\t\treturn isp1362_hc_start(hcd);\n\t}\n\tif (status != -EINPROGRESS)\n\t\treturn status;\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tport = isp1362_read_reg32(isp1362_hcd, HCRHDESCA) & RH_A_NDP;\n\twhile (port--) {\n\t\tu32 stat = isp1362_read_reg32(isp1362_hcd, HCRHPORT1 + port);\n\n\t\t \n\t\tif (!(stat & RH_PS_PSS)) {\n\t\t\tDBG(0, \"%s: Not Resuming RH port %d\\n\", __func__, port);\n\t\t\tcontinue;\n\t\t}\n\t\tDBG(0, \"%s: Resuming RH port %d\\n\", __func__, port);\n\t\tisp1362_write_reg32(isp1362_hcd, HCRHPORT1 + port, RH_PS_POCI);\n\t}\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\t \n\thcd->state = HC_STATE_RESUMING;\n\tmdelay(20   + 15);\n\n\tisp1362_hcd->hc_control = OHCI_USB_OPER;\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tisp1362_show_reg(isp1362_hcd, HCCONTROL);\n\tisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t \n\tmsleep(10);\n\n\t \n\tisp1362_hcd->next_statechange = jiffies + msecs_to_jiffies(250);\n\n\thcd->self.root_hub->dev.power.power_state = PMSG_ON;\n\thcd->state = HC_STATE_RUNNING;\n\treturn 0;\n}\n#else\n#define\tisp1362_bus_suspend\tNULL\n#define\tisp1362_bus_resume\tNULL\n#endif\n\n \n\nstatic void dump_irq(struct seq_file *s, char *label, u16 mask)\n{\n\tseq_printf(s, \"%-15s %04x%s%s%s%s%s%s\\n\", label, mask,\n\t\t   mask & HCuPINT_CLKRDY ? \" clkrdy\" : \"\",\n\t\t   mask & HCuPINT_SUSP ? \" susp\" : \"\",\n\t\t   mask & HCuPINT_OPR ? \" opr\" : \"\",\n\t\t   mask & HCuPINT_EOT ? \" eot\" : \"\",\n\t\t   mask & HCuPINT_ATL ? \" atl\" : \"\",\n\t\t   mask & HCuPINT_SOF ? \" sof\" : \"\");\n}\n\nstatic void dump_int(struct seq_file *s, char *label, u32 mask)\n{\n\tseq_printf(s, \"%-15s %08x%s%s%s%s%s%s%s\\n\", label, mask,\n\t\t   mask & OHCI_INTR_MIE ? \" MIE\" : \"\",\n\t\t   mask & OHCI_INTR_RHSC ? \" rhsc\" : \"\",\n\t\t   mask & OHCI_INTR_FNO ? \" fno\" : \"\",\n\t\t   mask & OHCI_INTR_UE ? \" ue\" : \"\",\n\t\t   mask & OHCI_INTR_RD ? \" rd\" : \"\",\n\t\t   mask & OHCI_INTR_SF ? \" sof\" : \"\",\n\t\t   mask & OHCI_INTR_SO ? \" so\" : \"\");\n}\n\nstatic void dump_ctrl(struct seq_file *s, char *label, u32 mask)\n{\n\tseq_printf(s, \"%-15s %08x%s%s%s\\n\", label, mask,\n\t\t   mask & OHCI_CTRL_RWC ? \" rwc\" : \"\",\n\t\t   mask & OHCI_CTRL_RWE ? \" rwe\" : \"\",\n\t\t   ({\n\t\t\t   char *hcfs;\n\t\t\t   switch (mask & OHCI_CTRL_HCFS) {\n\t\t\t   case OHCI_USB_OPER:\n\t\t\t\t   hcfs = \" oper\";\n\t\t\t\t   break;\n\t\t\t   case OHCI_USB_RESET:\n\t\t\t\t   hcfs = \" reset\";\n\t\t\t\t   break;\n\t\t\t   case OHCI_USB_RESUME:\n\t\t\t\t   hcfs = \" resume\";\n\t\t\t\t   break;\n\t\t\t   case OHCI_USB_SUSPEND:\n\t\t\t\t   hcfs = \" suspend\";\n\t\t\t\t   break;\n\t\t\t   default:\n\t\t\t\t   hcfs = \" ?\";\n\t\t\t   }\n\t\t\t   hcfs;\n\t\t   }));\n}\n\nstatic void dump_regs(struct seq_file *s, struct isp1362_hcd *isp1362_hcd)\n{\n\tseq_printf(s, \"HCREVISION [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCREVISION),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCREVISION));\n\tseq_printf(s, \"HCCONTROL  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCCONTROL),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCCONTROL));\n\tseq_printf(s, \"HCCMDSTAT  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCCMDSTAT),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCCMDSTAT));\n\tseq_printf(s, \"HCINTSTAT  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTSTAT),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCINTSTAT));\n\tseq_printf(s, \"HCINTENB   [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTENB),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCINTENB));\n\tseq_printf(s, \"HCFMINTVL  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCFMINTVL),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCFMINTVL));\n\tseq_printf(s, \"HCFMREM    [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCFMREM),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCFMREM));\n\tseq_printf(s, \"HCFMNUM    [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCFMNUM),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCFMNUM));\n\tseq_printf(s, \"HCLSTHRESH [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCLSTHRESH),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCLSTHRESH));\n\tseq_printf(s, \"HCRHDESCA  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCRHDESCA),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCRHDESCA));\n\tseq_printf(s, \"HCRHDESCB  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCRHDESCB),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCRHDESCB));\n\tseq_printf(s, \"HCRHSTATUS [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCRHSTATUS),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCRHSTATUS));\n\tseq_printf(s, \"HCRHPORT1  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCRHPORT1),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCRHPORT1));\n\tseq_printf(s, \"HCRHPORT2  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCRHPORT2),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCRHPORT2));\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"HCHWCFG    [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCHWCFG),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCHWCFG));\n\tseq_printf(s, \"HCDMACFG   [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCDMACFG),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCDMACFG));\n\tseq_printf(s, \"HCXFERCTR  [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCXFERCTR),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCXFERCTR));\n\tseq_printf(s, \"HCuPINT    [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCuPINT),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCuPINT));\n\tseq_printf(s, \"HCuPINTENB [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCuPINTENB),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCuPINTENB));\n\tseq_printf(s, \"HCCHIPID   [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCCHIPID),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCCHIPID));\n\tseq_printf(s, \"HCSCRATCH  [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCSCRATCH),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCSCRATCH));\n\tseq_printf(s, \"HCBUFSTAT  [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCBUFSTAT),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCBUFSTAT));\n\tseq_printf(s, \"HCDIRADDR  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCDIRADDR),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCDIRADDR));\n#if 0\n\tseq_printf(s, \"HCDIRDATA  [%02x]     %04x\\n\", ISP1362_REG_NO(HCDIRDATA),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCDIRDATA));\n#endif\n\tseq_printf(s, \"HCISTLBUFSZ[%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCISTLBUFSZ),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCISTLBUFSZ));\n\tseq_printf(s, \"HCISTLRATE [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCISTLRATE),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCISTLRATE));\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"HCINTLBUFSZ[%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLBUFSZ),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCINTLBUFSZ));\n\tseq_printf(s, \"HCINTLBLKSZ[%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLBLKSZ),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCINTLBLKSZ));\n\tseq_printf(s, \"HCINTLDONE [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLDONE),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCINTLDONE));\n\tseq_printf(s, \"HCINTLSKIP [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLSKIP),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCINTLSKIP));\n\tseq_printf(s, \"HCINTLLAST [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLLAST),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCINTLLAST));\n\tseq_printf(s, \"HCINTLCURR [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCINTLCURR),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCINTLCURR));\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"HCATLBUFSZ [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLBUFSZ),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCATLBUFSZ));\n\tseq_printf(s, \"HCATLBLKSZ [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLBLKSZ),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCATLBLKSZ));\n#if 0\n\tseq_printf(s, \"HCATLDONE  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLDONE),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCATLDONE));\n#endif\n\tseq_printf(s, \"HCATLSKIP  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLSKIP),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCATLSKIP));\n\tseq_printf(s, \"HCATLLAST  [%02x] %08x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLLAST),\n\t\t   isp1362_read_reg32(isp1362_hcd, HCATLLAST));\n\tseq_printf(s, \"HCATLCURR  [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLCURR),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCATLCURR));\n\tseq_printf(s, \"\\n\");\n\tseq_printf(s, \"HCATLDTC   [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLDTC),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCATLDTC));\n\tseq_printf(s, \"HCATLDTCTO [%02x]     %04x\\n\", ISP1362_REG_NO(ISP1362_REG_HCATLDTCTO),\n\t\t   isp1362_read_reg16(isp1362_hcd, HCATLDTCTO));\n}\n\nstatic int isp1362_show(struct seq_file *s, void *unused)\n{\n\tstruct isp1362_hcd *isp1362_hcd = s->private;\n\tstruct isp1362_ep *ep;\n\tint i;\n\n\tseq_printf(s, \"%s\\n%s version %s\\n\",\n\t\t   isp1362_hcd_to_hcd(isp1362_hcd)->product_desc, hcd_name, DRIVER_VERSION);\n\n\t \n\tseq_printf(s, \"alignment:  16b/%ld 8b/%ld 4b/%ld 2b/%ld 1b/%ld\\n\",\n\t\t   isp1362_hcd->stat16, isp1362_hcd->stat8, isp1362_hcd->stat4,\n\t\t   isp1362_hcd->stat2, isp1362_hcd->stat1);\n\tseq_printf(s, \"max # ptds in ATL  fifo: %d\\n\", isp1362_hcd->atl_queue.stat_maxptds);\n\tseq_printf(s, \"max # ptds in INTL fifo: %d\\n\", isp1362_hcd->intl_queue.stat_maxptds);\n\tseq_printf(s, \"max # ptds in ISTL fifo: %d\\n\",\n\t\t   max(isp1362_hcd->istl_queue[0] .stat_maxptds,\n\t\t       isp1362_hcd->istl_queue[1] .stat_maxptds));\n\n\t \n\tspin_lock_irq(&isp1362_hcd->lock);\n\n\tdump_irq(s, \"hc_irq_enable\", isp1362_read_reg16(isp1362_hcd, HCuPINTENB));\n\tdump_irq(s, \"hc_irq_status\", isp1362_read_reg16(isp1362_hcd, HCuPINT));\n\tdump_int(s, \"ohci_int_enable\", isp1362_read_reg32(isp1362_hcd, HCINTENB));\n\tdump_int(s, \"ohci_int_status\", isp1362_read_reg32(isp1362_hcd, HCINTSTAT));\n\tdump_ctrl(s, \"ohci_control\", isp1362_read_reg32(isp1362_hcd, HCCONTROL));\n\n\tfor (i = 0; i < NUM_ISP1362_IRQS; i++)\n\t\tif (isp1362_hcd->irq_stat[i])\n\t\t\tseq_printf(s, \"%-15s: %d\\n\",\n\t\t\t\t   ISP1362_INT_NAME(i), isp1362_hcd->irq_stat[i]);\n\n\tdump_regs(s, isp1362_hcd);\n\tlist_for_each_entry(ep, &isp1362_hcd->async, schedule) {\n\t\tstruct urb *urb;\n\n\t\tseq_printf(s, \"%p, ep%d%s, maxpacket %d:\\n\", ep, ep->epnum,\n\t\t\t   ({\n\t\t\t\t   char *s;\n\t\t\t\t   switch (ep->nextpid) {\n\t\t\t\t   case USB_PID_IN:\n\t\t\t\t\t   s = \"in\";\n\t\t\t\t\t   break;\n\t\t\t\t   case USB_PID_OUT:\n\t\t\t\t\t   s = \"out\";\n\t\t\t\t\t   break;\n\t\t\t\t   case USB_PID_SETUP:\n\t\t\t\t\t   s = \"setup\";\n\t\t\t\t\t   break;\n\t\t\t\t   case USB_PID_ACK:\n\t\t\t\t\t   s = \"status\";\n\t\t\t\t\t   break;\n\t\t\t\t   default:\n\t\t\t\t\t   s = \"?\";\n\t\t\t\t\t   break;\n\t\t\t\t   }\n\t\t\t\t   s;}), ep->maxpacket) ;\n\t\tlist_for_each_entry(urb, &ep->hep->urb_list, urb_list) {\n\t\t\tseq_printf(s, \"  urb%p, %d/%d\\n\", urb,\n\t\t\t\t   urb->actual_length,\n\t\t\t\t   urb->transfer_buffer_length);\n\t\t}\n\t}\n\tif (!list_empty(&isp1362_hcd->async))\n\t\tseq_printf(s, \"\\n\");\n\tdump_ptd_queue(&isp1362_hcd->atl_queue);\n\n\tseq_printf(s, \"periodic size= %d\\n\", PERIODIC_SIZE);\n\n\tlist_for_each_entry(ep, &isp1362_hcd->periodic, schedule) {\n\t\tseq_printf(s, \"branch:%2d load:%3d PTD[%d] $%04x:\\n\", ep->branch,\n\t\t\t   isp1362_hcd->load[ep->branch], ep->ptd_index, ep->ptd_offset);\n\n\t\tseq_printf(s, \"   %d/%p (%sdev%d ep%d%s max %d)\\n\",\n\t\t\t   ep->interval, ep,\n\t\t\t   (ep->udev->speed == USB_SPEED_FULL) ? \"\" : \"ls \",\n\t\t\t   ep->udev->devnum, ep->epnum,\n\t\t\t   (ep->epnum == 0) ? \"\" :\n\t\t\t   ((ep->nextpid == USB_PID_IN) ?\n\t\t\t    \"in\" : \"out\"), ep->maxpacket);\n\t}\n\tdump_ptd_queue(&isp1362_hcd->intl_queue);\n\n\tseq_printf(s, \"ISO:\\n\");\n\n\tlist_for_each_entry(ep, &isp1362_hcd->isoc, schedule) {\n\t\tseq_printf(s, \"   %d/%p (%sdev%d ep%d%s max %d)\\n\",\n\t\t\t   ep->interval, ep,\n\t\t\t   (ep->udev->speed == USB_SPEED_FULL) ? \"\" : \"ls \",\n\t\t\t   ep->udev->devnum, ep->epnum,\n\t\t\t   (ep->epnum == 0) ? \"\" :\n\t\t\t   ((ep->nextpid == USB_PID_IN) ?\n\t\t\t    \"in\" : \"out\"), ep->maxpacket);\n\t}\n\n\tspin_unlock_irq(&isp1362_hcd->lock);\n\tseq_printf(s, \"\\n\");\n\n\treturn 0;\n}\nDEFINE_SHOW_ATTRIBUTE(isp1362);\n\n \nstatic void create_debug_file(struct isp1362_hcd *isp1362_hcd)\n{\n\tdebugfs_create_file(\"isp1362\", S_IRUGO, usb_debug_root, isp1362_hcd,\n\t\t\t    &isp1362_fops);\n}\n\nstatic void remove_debug_file(struct isp1362_hcd *isp1362_hcd)\n{\n\tdebugfs_lookup_and_remove(\"isp1362\", usb_debug_root);\n}\n\n \n\nstatic void __isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)\n{\n\tint tmp = 20;\n\n\tisp1362_write_reg16(isp1362_hcd, HCSWRES, HCSWRES_MAGIC);\n\tisp1362_write_reg32(isp1362_hcd, HCCMDSTAT, OHCI_HCR);\n\twhile (--tmp) {\n\t\tmdelay(1);\n\t\tif (!(isp1362_read_reg32(isp1362_hcd, HCCMDSTAT) & OHCI_HCR))\n\t\t\tbreak;\n\t}\n\tif (!tmp)\n\t\tpr_err(\"Software reset timeout\\n\");\n}\n\nstatic void isp1362_sw_reset(struct isp1362_hcd *isp1362_hcd)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t__isp1362_sw_reset(isp1362_hcd);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n}\n\nstatic int isp1362_mem_config(struct usb_hcd *hcd)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\tu32 total;\n\tu16 istl_size = ISP1362_ISTL_BUFSIZE;\n\tu16 intl_blksize = ISP1362_INTL_BLKSIZE + PTD_HEADER_SIZE;\n\tu16 intl_size = ISP1362_INTL_BUFFERS * intl_blksize;\n\tu16 atl_blksize = ISP1362_ATL_BLKSIZE + PTD_HEADER_SIZE;\n\tu16 atl_buffers = (ISP1362_BUF_SIZE - (istl_size + intl_size)) / atl_blksize;\n\tu16 atl_size;\n\tint i;\n\n\tWARN_ON(istl_size & 3);\n\tWARN_ON(atl_blksize & 3);\n\tWARN_ON(intl_blksize & 3);\n\tWARN_ON(atl_blksize < PTD_HEADER_SIZE);\n\tWARN_ON(intl_blksize < PTD_HEADER_SIZE);\n\n\tBUG_ON((unsigned)ISP1362_INTL_BUFFERS > 32);\n\tif (atl_buffers > 32)\n\t\tatl_buffers = 32;\n\tatl_size = atl_buffers * atl_blksize;\n\ttotal = atl_size + intl_size + istl_size;\n\tdev_info(hcd->self.controller, \"ISP1362 Memory usage:\\n\");\n\tdev_info(hcd->self.controller, \"  ISTL:    2 * %4d:     %4d @ $%04x:$%04x\\n\",\n\t\t istl_size / 2, istl_size, 0, istl_size / 2);\n\tdev_info(hcd->self.controller, \"  INTL: %4d * (%3zu+8):  %4d @ $%04x\\n\",\n\t\t ISP1362_INTL_BUFFERS, intl_blksize - PTD_HEADER_SIZE,\n\t\t intl_size, istl_size);\n\tdev_info(hcd->self.controller, \"  ATL : %4d * (%3zu+8):  %4d @ $%04x\\n\",\n\t\t atl_buffers, atl_blksize - PTD_HEADER_SIZE,\n\t\t atl_size, istl_size + intl_size);\n\tdev_info(hcd->self.controller, \"  USED/FREE:   %4d      %4d\\n\", total,\n\t\t ISP1362_BUF_SIZE - total);\n\n\tif (total > ISP1362_BUF_SIZE) {\n\t\tdev_err(hcd->self.controller, \"%s: Memory requested: %d, available %d\\n\",\n\t\t\t__func__, total, ISP1362_BUF_SIZE);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\tfor (i = 0; i < 2; i++) {\n\t\tisp1362_hcd->istl_queue[i].buf_start = i * istl_size / 2,\n\t\tisp1362_hcd->istl_queue[i].buf_size = istl_size / 2;\n\t\tisp1362_hcd->istl_queue[i].blk_size = 4;\n\t\tINIT_LIST_HEAD(&isp1362_hcd->istl_queue[i].active);\n\t\tsnprintf(isp1362_hcd->istl_queue[i].name,\n\t\t\t sizeof(isp1362_hcd->istl_queue[i].name), \"ISTL%d\", i);\n\t\tDBG(3, \"%s: %5s buf $%04x %d\\n\", __func__,\n\t\t     isp1362_hcd->istl_queue[i].name,\n\t\t     isp1362_hcd->istl_queue[i].buf_start,\n\t\t     isp1362_hcd->istl_queue[i].buf_size);\n\t}\n\tisp1362_write_reg16(isp1362_hcd, HCISTLBUFSZ, istl_size / 2);\n\n\tisp1362_hcd->intl_queue.buf_start = istl_size;\n\tisp1362_hcd->intl_queue.buf_size = intl_size;\n\tisp1362_hcd->intl_queue.buf_count = ISP1362_INTL_BUFFERS;\n\tisp1362_hcd->intl_queue.blk_size = intl_blksize;\n\tisp1362_hcd->intl_queue.buf_avail = isp1362_hcd->intl_queue.buf_count;\n\tisp1362_hcd->intl_queue.skip_map = ~0;\n\tINIT_LIST_HEAD(&isp1362_hcd->intl_queue.active);\n\n\tisp1362_write_reg16(isp1362_hcd, HCINTLBUFSZ,\n\t\t\t    isp1362_hcd->intl_queue.buf_size);\n\tisp1362_write_reg16(isp1362_hcd, HCINTLBLKSZ,\n\t\t\t    isp1362_hcd->intl_queue.blk_size - PTD_HEADER_SIZE);\n\tisp1362_write_reg32(isp1362_hcd, HCINTLSKIP, ~0);\n\tisp1362_write_reg32(isp1362_hcd, HCINTLLAST,\n\t\t\t    1 << (ISP1362_INTL_BUFFERS - 1));\n\n\tisp1362_hcd->atl_queue.buf_start = istl_size + intl_size;\n\tisp1362_hcd->atl_queue.buf_size = atl_size;\n\tisp1362_hcd->atl_queue.buf_count = atl_buffers;\n\tisp1362_hcd->atl_queue.blk_size = atl_blksize;\n\tisp1362_hcd->atl_queue.buf_avail = isp1362_hcd->atl_queue.buf_count;\n\tisp1362_hcd->atl_queue.skip_map = ~0;\n\tINIT_LIST_HEAD(&isp1362_hcd->atl_queue.active);\n\n\tisp1362_write_reg16(isp1362_hcd, HCATLBUFSZ,\n\t\t\t    isp1362_hcd->atl_queue.buf_size);\n\tisp1362_write_reg16(isp1362_hcd, HCATLBLKSZ,\n\t\t\t    isp1362_hcd->atl_queue.blk_size - PTD_HEADER_SIZE);\n\tisp1362_write_reg32(isp1362_hcd, HCATLSKIP, ~0);\n\tisp1362_write_reg32(isp1362_hcd, HCATLLAST,\n\t\t\t    1 << (atl_buffers - 1));\n\n\tsnprintf(isp1362_hcd->atl_queue.name,\n\t\t sizeof(isp1362_hcd->atl_queue.name), \"ATL\");\n\tsnprintf(isp1362_hcd->intl_queue.name,\n\t\t sizeof(isp1362_hcd->intl_queue.name), \"INTL\");\n\tDBG(3, \"%s: %5s buf $%04x %2d * %4d = %4d\\n\", __func__,\n\t     isp1362_hcd->intl_queue.name,\n\t     isp1362_hcd->intl_queue.buf_start,\n\t     ISP1362_INTL_BUFFERS, isp1362_hcd->intl_queue.blk_size,\n\t     isp1362_hcd->intl_queue.buf_size);\n\tDBG(3, \"%s: %5s buf $%04x %2d * %4d = %4d\\n\", __func__,\n\t     isp1362_hcd->atl_queue.name,\n\t     isp1362_hcd->atl_queue.buf_start,\n\t     atl_buffers, isp1362_hcd->atl_queue.blk_size,\n\t     isp1362_hcd->atl_queue.buf_size);\n\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\treturn 0;\n}\n\nstatic int isp1362_hc_reset(struct usb_hcd *hcd)\n{\n\tint ret = 0;\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long t;\n\tunsigned long timeout = 100;\n\tunsigned long flags;\n\tint clkrdy = 0;\n\n\tpr_debug(\"%s:\\n\", __func__);\n\n\tif (isp1362_hcd->board && isp1362_hcd->board->reset) {\n\t\tisp1362_hcd->board->reset(hcd->self.controller, 1);\n\t\tmsleep(20);\n\t\tif (isp1362_hcd->board->clock)\n\t\t\tisp1362_hcd->board->clock(hcd->self.controller, 1);\n\t\tisp1362_hcd->board->reset(hcd->self.controller, 0);\n\t} else\n\t\tisp1362_sw_reset(isp1362_hcd);\n\n\t \n\tt = jiffies + msecs_to_jiffies(timeout);\n\twhile (!clkrdy && time_before_eq(jiffies, t)) {\n\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\tclkrdy = isp1362_read_reg16(isp1362_hcd, HCuPINT) & HCuPINT_CLKRDY;\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\tif (!clkrdy)\n\t\t\tmsleep(4);\n\t}\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_CLKRDY);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\tif (!clkrdy) {\n\t\tpr_err(\"Clock not ready after %lums\\n\", timeout);\n\t\tret = -ENODEV;\n\t}\n\treturn ret;\n}\n\nstatic void isp1362_hc_stop(struct usb_hcd *hcd)\n{\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\tu32 tmp;\n\n\tpr_debug(\"%s:\\n\", __func__);\n\n\tdel_timer_sync(&hcd->rh_timer);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\n\n\t \n\ttmp = isp1362_read_reg32(isp1362_hcd, HCRHDESCA);\n\ttmp &= ~(RH_A_NPS | RH_A_PSM);\n\tisp1362_write_reg32(isp1362_hcd, HCRHDESCA, tmp);\n\tisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPS);\n\n\t \n\tif (isp1362_hcd->board && isp1362_hcd->board->reset)\n\t\tisp1362_hcd->board->reset(hcd->self.controller, 1);\n\telse\n\t\t__isp1362_sw_reset(isp1362_hcd);\n\n\tif (isp1362_hcd->board && isp1362_hcd->board->clock)\n\t\tisp1362_hcd->board->clock(hcd->self.controller, 0);\n\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n}\n\n#ifdef CHIP_BUFFER_TEST\nstatic int isp1362_chip_test(struct isp1362_hcd *isp1362_hcd)\n{\n\tint ret = 0;\n\tu16 *ref;\n\tunsigned long flags;\n\n\tref = kmalloc(2 * ISP1362_BUF_SIZE, GFP_KERNEL);\n\tif (ref) {\n\t\tint offset;\n\t\tu16 *tst = &ref[ISP1362_BUF_SIZE / 2];\n\n\t\tfor (offset = 0; offset < ISP1362_BUF_SIZE / 2; offset++) {\n\t\t\tref[offset] = ~offset;\n\t\t\ttst[offset] = offset;\n\t\t}\n\n\t\tfor (offset = 0; offset < 4; offset++) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0; j < 8; j++) {\n\t\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\t\tisp1362_write_buffer(isp1362_hcd, (u8 *)ref + offset, 0, j);\n\t\t\t\tisp1362_read_buffer(isp1362_hcd, (u8 *)tst + offset, 0, j);\n\t\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\t\t\t\tif (memcmp(ref, tst, j)) {\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\t\tpr_err(\"%s: memory check with %d byte offset %d failed\\n\",\n\t\t\t\t\t    __func__, j, offset);\n\t\t\t\t\tdump_data((u8 *)ref + offset, j);\n\t\t\t\t\tdump_data((u8 *)tst + offset, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\tisp1362_write_buffer(isp1362_hcd, ref, 0, ISP1362_BUF_SIZE);\n\t\tisp1362_read_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\t\tif (memcmp(ref, tst, ISP1362_BUF_SIZE)) {\n\t\t\tret = -ENODEV;\n\t\t\tpr_err(\"%s: memory check failed\\n\", __func__);\n\t\t\tdump_data((u8 *)tst, ISP1362_BUF_SIZE / 2);\n\t\t}\n\n\t\tfor (offset = 0; offset < 256; offset++) {\n\t\t\tint test_size = 0;\n\n\t\t\tyield();\n\n\t\t\tmemset(tst, 0, ISP1362_BUF_SIZE);\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\tisp1362_write_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\n\t\t\tisp1362_read_buffer(isp1362_hcd, tst, 0, ISP1362_BUF_SIZE);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tif (memcmp(tst, tst + (ISP1362_BUF_SIZE / (2 * sizeof(*tst))),\n\t\t\t\t   ISP1362_BUF_SIZE / 2)) {\n\t\t\t\tpr_err(\"%s: Failed to clear buffer\\n\", __func__);\n\t\t\t\tdump_data((u8 *)tst, ISP1362_BUF_SIZE);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\tisp1362_write_buffer(isp1362_hcd, ref, offset * 2, PTD_HEADER_SIZE);\n\t\t\tisp1362_write_buffer(isp1362_hcd, ref + PTD_HEADER_SIZE / sizeof(*ref),\n\t\t\t\t\t     offset * 2 + PTD_HEADER_SIZE, test_size);\n\t\t\tisp1362_read_buffer(isp1362_hcd, tst, offset * 2,\n\t\t\t\t\t    PTD_HEADER_SIZE + test_size);\n\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\tif (memcmp(ref, tst, PTD_HEADER_SIZE + test_size)) {\n\t\t\t\tdump_data(((u8 *)ref) + offset, PTD_HEADER_SIZE + test_size);\n\t\t\t\tdump_data((u8 *)tst, PTD_HEADER_SIZE + test_size);\n\t\t\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\t\t\tisp1362_read_buffer(isp1362_hcd, tst, offset * 2,\n\t\t\t\t\t\t    PTD_HEADER_SIZE + test_size);\n\t\t\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\t\t\tif (memcmp(ref, tst, PTD_HEADER_SIZE + test_size)) {\n\t\t\t\t\tret = -ENODEV;\n\t\t\t\t\tpr_err(\"%s: memory check with offset %02x failed\\n\",\n\t\t\t\t\t    __func__, offset);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpr_warn(\"%s: memory check with offset %02x ok after second read\\n\",\n\t\t\t\t\t__func__, offset);\n\t\t\t}\n\t\t}\n\t\tkfree(ref);\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int isp1362_hc_start(struct usb_hcd *hcd)\n{\n\tint ret;\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tstruct isp1362_platform_data *board = isp1362_hcd->board;\n\tu16 hwcfg;\n\tu16 chipid;\n\tunsigned long flags;\n\n\tpr_debug(\"%s:\\n\", __func__);\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\tchipid = isp1362_read_reg16(isp1362_hcd, HCCHIPID);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\tif ((chipid & HCCHIPID_MASK) != HCCHIPID_MAGIC) {\n\t\tpr_err(\"%s: Invalid chip ID %04x\\n\", __func__, chipid);\n\t\treturn -ENODEV;\n\t}\n\n#ifdef CHIP_BUFFER_TEST\n\tret = isp1362_chip_test(isp1362_hcd);\n\tif (ret)\n\t\treturn -ENODEV;\n#endif\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t \n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, 0xff);\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, 0);\n\n\t \n\thwcfg = HCHWCFG_INT_ENABLE | HCHWCFG_DBWIDTH(1);\n\tif (board->sel15Kres)\n\t\thwcfg |= HCHWCFG_PULLDOWN_DS2 |\n\t\t\t((MAX_ROOT_PORTS > 1) ? HCHWCFG_PULLDOWN_DS1 : 0);\n\tif (board->clknotstop)\n\t\thwcfg |= HCHWCFG_CLKNOTSTOP;\n\tif (board->oc_enable)\n\t\thwcfg |= HCHWCFG_ANALOG_OC;\n\tif (board->int_act_high)\n\t\thwcfg |= HCHWCFG_INT_POL;\n\tif (board->int_edge_triggered)\n\t\thwcfg |= HCHWCFG_INT_TRIGGER;\n\tif (board->dreq_act_high)\n\t\thwcfg |= HCHWCFG_DREQ_POL;\n\tif (board->dack_act_high)\n\t\thwcfg |= HCHWCFG_DACK_POL;\n\tisp1362_write_reg16(isp1362_hcd, HCHWCFG, hwcfg);\n\tisp1362_show_reg(isp1362_hcd, HCHWCFG);\n\tisp1362_write_reg16(isp1362_hcd, HCDMACFG, 0);\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\tret = isp1362_mem_config(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\n\t \n\tisp1362_hcd->rhdesca = 0;\n\tif (board->no_power_switching)\n\t\tisp1362_hcd->rhdesca |= RH_A_NPS;\n\tif (board->power_switching_mode)\n\t\tisp1362_hcd->rhdesca |= RH_A_PSM;\n\tif (board->potpg)\n\t\tisp1362_hcd->rhdesca |= (board->potpg << 24) & RH_A_POTPGT;\n\telse\n\t\tisp1362_hcd->rhdesca |= (25 << 24) & RH_A_POTPGT;\n\n\tisp1362_write_reg32(isp1362_hcd, HCRHDESCA, isp1362_hcd->rhdesca & ~RH_A_OCPM);\n\tisp1362_write_reg32(isp1362_hcd, HCRHDESCA, isp1362_hcd->rhdesca | RH_A_OCPM);\n\tisp1362_hcd->rhdesca = isp1362_read_reg32(isp1362_hcd, HCRHDESCA);\n\n\tisp1362_hcd->rhdescb = RH_B_PPCM;\n\tisp1362_write_reg32(isp1362_hcd, HCRHDESCB, isp1362_hcd->rhdescb);\n\tisp1362_hcd->rhdescb = isp1362_read_reg32(isp1362_hcd, HCRHDESCB);\n\n\tisp1362_read_reg32(isp1362_hcd, HCFMINTVL);\n\tisp1362_write_reg32(isp1362_hcd, HCFMINTVL, (FSMP(FI) << 16) | FI);\n\tisp1362_write_reg32(isp1362_hcd, HCLSTHRESH, LSTHRESH);\n\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\tisp1362_hcd->hc_control = OHCI_USB_OPER;\n\thcd->state = HC_STATE_RUNNING;\n\n\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t \n\tisp1362_hcd->intenb = OHCI_INTR_MIE | OHCI_INTR_RHSC | OHCI_INTR_UE;\n\tisp1362_hcd->intenb |= OHCI_INTR_RD;\n\tisp1362_hcd->irqenb = HCuPINT_OPR | HCuPINT_SUSP;\n\tisp1362_write_reg32(isp1362_hcd, HCINTENB, isp1362_hcd->intenb);\n\tisp1362_write_reg16(isp1362_hcd, HCuPINTENB, isp1362_hcd->irqenb);\n\n\t \n\tisp1362_write_reg32(isp1362_hcd, HCCONTROL, isp1362_hcd->hc_control);\n\t \n\tisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPSC | RH_HS_DRWE);\n\n\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\n\treturn 0;\n}\n\n \n\nstatic const struct hc_driver isp1362_hc_driver = {\n\t.description =\t\thcd_name,\n\t.product_desc =\t\t\"ISP1362 Host Controller\",\n\t.hcd_priv_size =\tsizeof(struct isp1362_hcd),\n\n\t.irq =\t\t\tisp1362_irq,\n\t.flags =\t\tHCD_USB11 | HCD_MEMORY,\n\n\t.reset =\t\tisp1362_hc_reset,\n\t.start =\t\tisp1362_hc_start,\n\t.stop =\t\t\tisp1362_hc_stop,\n\n\t.urb_enqueue =\t\tisp1362_urb_enqueue,\n\t.urb_dequeue =\t\tisp1362_urb_dequeue,\n\t.endpoint_disable =\tisp1362_endpoint_disable,\n\n\t.get_frame_number =\tisp1362_get_frame,\n\n\t.hub_status_data =\tisp1362_hub_status_data,\n\t.hub_control =\t\tisp1362_hub_control,\n\t.bus_suspend =\t\tisp1362_bus_suspend,\n\t.bus_resume =\t\tisp1362_bus_resume,\n};\n\n \n\nstatic void isp1362_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\n\tremove_debug_file(isp1362_hcd);\n\tDBG(0, \"%s: Removing HCD\\n\", __func__);\n\tusb_remove_hcd(hcd);\n\tDBG(0, \"%s: put_hcd\\n\", __func__);\n\tusb_put_hcd(hcd);\n\tDBG(0, \"%s: Done\\n\", __func__);\n}\n\nstatic int isp1362_probe(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd;\n\tstruct isp1362_hcd *isp1362_hcd;\n\tstruct resource *data, *irq_res;\n\tvoid __iomem *addr_reg;\n\tvoid __iomem *data_reg;\n\tint irq;\n\tint retval = 0;\n\tunsigned int irq_flags = 0;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\t \n\tif (pdev->num_resources < 3)\n\t\treturn -ENODEV;\n\n\tirq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n\tif (!irq_res)\n\t\treturn -ENODEV;\n\n\tirq = irq_res->start;\n\n\taddr_reg = devm_platform_ioremap_resource(pdev, 1);\n\tif (IS_ERR(addr_reg))\n\t\treturn PTR_ERR(addr_reg);\n\n\tdata_reg = devm_platform_get_and_ioremap_resource(pdev, 0, &data);\n\tif (IS_ERR(data_reg))\n\t\treturn PTR_ERR(data_reg);\n\n\t \n\thcd = usb_create_hcd(&isp1362_hc_driver, &pdev->dev, dev_name(&pdev->dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\thcd->rsrc_start = data->start;\n\tisp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tisp1362_hcd->data_reg = data_reg;\n\tisp1362_hcd->addr_reg = addr_reg;\n\n\tisp1362_hcd->next_statechange = jiffies;\n\tspin_lock_init(&isp1362_hcd->lock);\n\tINIT_LIST_HEAD(&isp1362_hcd->async);\n\tINIT_LIST_HEAD(&isp1362_hcd->periodic);\n\tINIT_LIST_HEAD(&isp1362_hcd->isoc);\n\tINIT_LIST_HEAD(&isp1362_hcd->remove_list);\n\tisp1362_hcd->board = dev_get_platdata(&pdev->dev);\n#if USE_PLATFORM_DELAY\n\tif (!isp1362_hcd->board->delay) {\n\t\tdev_err(hcd->self.controller, \"No platform delay function given\\n\");\n\t\tretval = -ENODEV;\n\t\tgoto err;\n\t}\n#endif\n\n\tif (irq_res->flags & IORESOURCE_IRQ_HIGHEDGE)\n\t\tirq_flags |= IRQF_TRIGGER_RISING;\n\tif (irq_res->flags & IORESOURCE_IRQ_LOWEDGE)\n\t\tirq_flags |= IRQF_TRIGGER_FALLING;\n\tif (irq_res->flags & IORESOURCE_IRQ_HIGHLEVEL)\n\t\tirq_flags |= IRQF_TRIGGER_HIGH;\n\tif (irq_res->flags & IORESOURCE_IRQ_LOWLEVEL)\n\t\tirq_flags |= IRQF_TRIGGER_LOW;\n\n\tretval = usb_add_hcd(hcd, irq, irq_flags | IRQF_SHARED);\n\tif (retval != 0)\n\t\tgoto err;\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\tdev_info(&pdev->dev, \"%s, irq %d\\n\", hcd->product_desc, irq);\n\n\tcreate_debug_file(isp1362_hcd);\n\n\treturn 0;\n\n err:\n\tusb_put_hcd(hcd);\n\n\treturn retval;\n}\n\n#ifdef\tCONFIG_PM\nstatic int isp1362_suspend(struct platform_device *pdev, pm_message_t state)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\tint retval = 0;\n\n\tDBG(0, \"%s: Suspending device\\n\", __func__);\n\n\tif (state.event == PM_EVENT_FREEZE) {\n\t\tDBG(0, \"%s: Suspending root hub\\n\", __func__);\n\t\tretval = isp1362_bus_suspend(hcd);\n\t} else {\n\t\tDBG(0, \"%s: Suspending RH ports\\n\", __func__);\n\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\tisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPS);\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t}\n\tif (retval == 0)\n\t\tpdev->dev.power.power_state = state;\n\treturn retval;\n}\n\nstatic int isp1362_resume(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct isp1362_hcd *isp1362_hcd = hcd_to_isp1362_hcd(hcd);\n\tunsigned long flags;\n\n\tDBG(0, \"%s: Resuming\\n\", __func__);\n\n\tif (pdev->dev.power.power_state.event == PM_EVENT_SUSPEND) {\n\t\tDBG(0, \"%s: Resume RH ports\\n\", __func__);\n\t\tspin_lock_irqsave(&isp1362_hcd->lock, flags);\n\t\tisp1362_write_reg32(isp1362_hcd, HCRHSTATUS, RH_HS_LPSC);\n\t\tspin_unlock_irqrestore(&isp1362_hcd->lock, flags);\n\t\treturn 0;\n\t}\n\n\tpdev->dev.power.power_state = PMSG_ON;\n\n\treturn isp1362_bus_resume(isp1362_hcd_to_hcd(isp1362_hcd));\n}\n#else\n#define\tisp1362_suspend\tNULL\n#define\tisp1362_resume\tNULL\n#endif\n\nstatic struct platform_driver isp1362_driver = {\n\t.probe = isp1362_probe,\n\t.remove_new = isp1362_remove,\n\n\t.suspend = isp1362_suspend,\n\t.resume = isp1362_resume,\n\t.driver = {\n\t\t.name = hcd_name,\n\t},\n};\n\nmodule_platform_driver(isp1362_driver);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}