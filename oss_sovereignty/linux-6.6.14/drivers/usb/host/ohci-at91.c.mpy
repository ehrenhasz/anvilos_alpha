{
  "module_name": "ohci-at91.c",
  "hash_id": "e9f0be69703d18b3a156f681098b76487d19cddfe79800795fb96ccf2f7aab77",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-at91.c",
  "human_readable_source": "\n \n\n#include <linux/arm-smccc.h>\n#include <linux/clk.h>\n#include <linux/dma-mapping.h>\n#include <linux/gpio/consumer.h>\n#include <linux/platform_device.h>\n#include <linux/platform_data/atmel.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/mfd/syscon.h>\n#include <linux/of.h>\n#include <linux/regmap.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <soc/at91/atmel-sfr.h>\n\n#include \"ohci.h\"\n\n#define valid_port(index)\t((index) >= 0 && (index) < AT91_MAX_USBH_PORTS)\n#define at91_for_each_port(index)\t\\\n\t\tfor ((index) = 0; (index) < AT91_MAX_USBH_PORTS; (index)++)\n\n \n#define hcd_to_ohci_at91_priv(h) \\\n\t((struct ohci_at91_priv *)hcd_to_ohci(h)->priv)\n\n#define AT91_MAX_USBH_PORTS\t3\nstruct at91_usbh_data {\n\tstruct gpio_desc *vbus_pin[AT91_MAX_USBH_PORTS];\n\tstruct gpio_desc *overcurrent_pin[AT91_MAX_USBH_PORTS];\n\tu8 ports;\t\t\t\t \n\tu8 overcurrent_supported;\n\tu8 overcurrent_status[AT91_MAX_USBH_PORTS];\n\tu8 overcurrent_changed[AT91_MAX_USBH_PORTS];\n};\n\nstruct ohci_at91_priv {\n\tstruct clk *iclk;\n\tstruct clk *fclk;\n\tstruct clk *hclk;\n\tbool clocked;\n\tbool wakeup;\t\t \n\tstruct regmap *sfr_regmap;\n\tu32 suspend_smc_id;\n};\n \n\n#define DRIVER_DESC \"OHCI Atmel driver\"\n\nstatic struct hc_driver __read_mostly ohci_at91_hc_driver;\n\nstatic const struct ohci_driver_overrides ohci_at91_drv_overrides __initconst = {\n\t.extra_priv_size = sizeof(struct ohci_at91_priv),\n};\n\n \n\nstatic void at91_start_clock(struct ohci_at91_priv *ohci_at91)\n{\n\tif (ohci_at91->clocked)\n\t\treturn;\n\n\tclk_set_rate(ohci_at91->fclk, 48000000);\n\tclk_prepare_enable(ohci_at91->hclk);\n\tclk_prepare_enable(ohci_at91->iclk);\n\tclk_prepare_enable(ohci_at91->fclk);\n\tohci_at91->clocked = true;\n}\n\nstatic void at91_stop_clock(struct ohci_at91_priv *ohci_at91)\n{\n\tif (!ohci_at91->clocked)\n\t\treturn;\n\n\tclk_disable_unprepare(ohci_at91->fclk);\n\tclk_disable_unprepare(ohci_at91->iclk);\n\tclk_disable_unprepare(ohci_at91->hclk);\n\tohci_at91->clocked = false;\n}\n\nstatic void at91_start_hc(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct ohci_regs __iomem *regs = hcd->regs;\n\tstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\n\tdev_dbg(&pdev->dev, \"start\\n\");\n\n\t \n\tat91_start_clock(ohci_at91);\n\n\t \n\twritel(0, &regs->control);\n}\n\nstatic void at91_stop_hc(struct platform_device *pdev)\n{\n\tstruct usb_hcd *hcd = platform_get_drvdata(pdev);\n\tstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\n\tdev_dbg(&pdev->dev, \"stop\\n\");\n\n\t \n\tusb_hcd_platform_shutdown(pdev);\n\n\t \n\tat91_stop_clock(ohci_at91);\n}\n\n\n \n\nstatic void usb_hcd_at91_remove (struct usb_hcd *, struct platform_device *);\n\nstatic u32 at91_dt_suspend_smc(struct device *dev)\n{\n\tu32 suspend_smc_id;\n\n\tif (!dev->of_node)\n\t\treturn 0;\n\n\tif (of_property_read_u32(dev->of_node, \"microchip,suspend-smc-id\", &suspend_smc_id))\n\t\treturn 0;\n\n\treturn suspend_smc_id;\n}\n\nstatic struct regmap *at91_dt_syscon_sfr(void)\n{\n\tstruct regmap *regmap;\n\n\tregmap = syscon_regmap_lookup_by_compatible(\"atmel,sama5d2-sfr\");\n\tif (IS_ERR(regmap)) {\n\t\tregmap = syscon_regmap_lookup_by_compatible(\"microchip,sam9x60-sfr\");\n\t\tif (IS_ERR(regmap))\n\t\t\tregmap = NULL;\n\t}\n\n\treturn regmap;\n}\n\n \n \n\n\n \nstatic int usb_hcd_at91_probe(const struct hc_driver *driver,\n\t\t\tstruct platform_device *pdev)\n{\n\tstruct at91_usbh_data *board;\n\tstruct ohci_hcd *ohci;\n\tint retval;\n\tstruct usb_hcd *hcd;\n\tstruct ohci_at91_priv *ohci_at91;\n\tstruct device *dev = &pdev->dev;\n\tstruct resource *res;\n\tint irq;\n\n\tirq = platform_get_irq(pdev, 0);\n\tif (irq < 0)\n\t\treturn irq;\n\n\thcd = usb_create_hcd(driver, dev, \"at91\");\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\tohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &res);\n\tif (IS_ERR(hcd->regs)) {\n\t\tretval = PTR_ERR(hcd->regs);\n\t\tgoto err;\n\t}\n\thcd->rsrc_start = res->start;\n\thcd->rsrc_len = resource_size(res);\n\n\tohci_at91->iclk = devm_clk_get(dev, \"ohci_clk\");\n\tif (IS_ERR(ohci_at91->iclk)) {\n\t\tdev_err(dev, \"failed to get ohci_clk\\n\");\n\t\tretval = PTR_ERR(ohci_at91->iclk);\n\t\tgoto err;\n\t}\n\tohci_at91->fclk = devm_clk_get(dev, \"uhpck\");\n\tif (IS_ERR(ohci_at91->fclk)) {\n\t\tdev_err(dev, \"failed to get uhpck\\n\");\n\t\tretval = PTR_ERR(ohci_at91->fclk);\n\t\tgoto err;\n\t}\n\tohci_at91->hclk = devm_clk_get(dev, \"hclk\");\n\tif (IS_ERR(ohci_at91->hclk)) {\n\t\tdev_err(dev, \"failed to get hclk\\n\");\n\t\tretval = PTR_ERR(ohci_at91->hclk);\n\t\tgoto err;\n\t}\n\n\tohci_at91->suspend_smc_id = at91_dt_suspend_smc(dev);\n\tif (!ohci_at91->suspend_smc_id)  {\n\t\tdev_dbg(dev, \"failed to find sfr suspend smc id, using regmap\\n\");\n\t\tohci_at91->sfr_regmap = at91_dt_syscon_sfr();\n\t\tif (!ohci_at91->sfr_regmap)\n\t\t\tdev_dbg(dev, \"failed to find sfr node\\n\");\n\t}\n\n\tboard = hcd->self.controller->platform_data;\n\tohci = hcd_to_ohci(hcd);\n\tohci->num_ports = board->ports;\n\tat91_start_hc(pdev);\n\n\t \n\tohci->hc_control = OHCI_CTRL_RWC;\n\n\tretval = usb_add_hcd(hcd, irq, IRQF_SHARED);\n\tif (retval == 0) {\n\t\tdevice_wakeup_enable(hcd->self.controller);\n\t\treturn retval;\n\t}\n\n\t \n\tat91_stop_hc(pdev);\n\n err:\n\tusb_put_hcd(hcd);\n\treturn retval;\n}\n\n\n \n\n \nstatic void usb_hcd_at91_remove(struct usb_hcd *hcd,\n\t\t\t\tstruct platform_device *pdev)\n{\n\tusb_remove_hcd(hcd);\n\tat91_stop_hc(pdev);\n\tusb_put_hcd(hcd);\n}\n\n \nstatic void ohci_at91_usb_set_power(struct at91_usbh_data *pdata, int port, int enable)\n{\n\tif (!valid_port(port))\n\t\treturn;\n\n\tgpiod_set_value(pdata->vbus_pin[port], enable);\n}\n\nstatic int ohci_at91_usb_get_power(struct at91_usbh_data *pdata, int port)\n{\n\tif (!valid_port(port))\n\t\treturn -EINVAL;\n\n\treturn gpiod_get_value(pdata->vbus_pin[port]);\n}\n\n \nstatic int ohci_at91_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tstruct at91_usbh_data *pdata = hcd->self.controller->platform_data;\n\tint length = ohci_hub_status_data(hcd, buf);\n\tint port;\n\n\tat91_for_each_port(port) {\n\t\tif (pdata->overcurrent_changed[port]) {\n\t\t\tif (!length)\n\t\t\t\tlength = 1;\n\t\t\tbuf[0] |= 1 << (port + 1);\n\t\t}\n\t}\n\n\treturn length;\n}\n\nstatic int ohci_at91_port_suspend(struct ohci_at91_priv *ohci_at91, u8 set)\n{\n\tstruct regmap *regmap = ohci_at91->sfr_regmap;\n\tu32 regval;\n\tint ret;\n\n\tif (ohci_at91->suspend_smc_id) {\n\t\tstruct arm_smccc_res res;\n\n\t\tarm_smccc_smc(ohci_at91->suspend_smc_id, set, 0, 0, 0, 0, 0, 0, &res);\n\t\tif (res.a0)\n\t\t\treturn -EINVAL;\n\t} else if (regmap) {\n\t\tret = regmap_read(regmap, AT91_SFR_OHCIICR, &regval);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif (set)\n\t\t\tregval |= AT91_OHCIICR_USB_SUSPEND;\n\t\telse\n\t\t\tregval &= ~AT91_OHCIICR_USB_SUSPEND;\n\n\t\tregmap_write(regmap, AT91_SFR_OHCIICR, regval);\n\t}\n\n\treturn 0;\n}\n\n \nstatic int ohci_at91_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t\t u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct at91_usbh_data *pdata = dev_get_platdata(hcd->self.controller);\n\tstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\tstruct usb_hub_descriptor *desc;\n\tint ret = -EINVAL;\n\tu32 *data = (u32 *)buf;\n\n\tdev_dbg(hcd->self.controller,\n\t\t\"ohci_at91_hub_control(%p,0x%04x,0x%04x,0x%04x,%p,%04x)\\n\",\n\t\thcd, typeReq, wValue, wIndex, buf, wLength);\n\n\twIndex--;\n\n\tswitch (typeReq) {\n\tcase SetPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller, \"SetPortFeat: POWER\\n\");\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tohci_at91_usb_set_power(pdata, wIndex, 1);\n\t\t\t\tret = 0;\n\t\t\t}\n\n\t\t\tgoto out;\n\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(hcd->self.controller, \"SetPortFeat: SUSPEND\\n\");\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tohci_at91_port_suspend(ohci_at91, 1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase ClearPortFeature:\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: C_OVER_CURRENT\\n\");\n\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tpdata->overcurrent_changed[wIndex] = 0;\n\t\t\t\tpdata->overcurrent_status[wIndex] = 0;\n\t\t\t}\n\n\t\t\tgoto out;\n\n\t\tcase USB_PORT_FEAT_OVER_CURRENT:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: OVER_CURRENT\\n\");\n\n\t\t\tif (valid_port(wIndex))\n\t\t\t\tpdata->overcurrent_status[wIndex] = 0;\n\n\t\t\tgoto out;\n\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(hcd->self.controller,\n\t\t\t\t\"ClearPortFeature: POWER\\n\");\n\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tohci_at91_usb_set_power(pdata, wIndex, 0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase USB_PORT_FEAT_SUSPEND:\n\t\t\tdev_dbg(hcd->self.controller, \"ClearPortFeature: SUSPEND\\n\");\n\t\t\tif (valid_port(wIndex)) {\n\t\t\t\tohci_at91_port_suspend(ohci_at91, 0);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = ohci_hub_control(hcd, typeReq, wValue, wIndex + 1, buf, wLength);\n\tif (ret)\n\t\tgoto out;\n\n\tswitch (typeReq) {\n\tcase GetHubDescriptor:\n\n\t\t \n\n\t\tdesc = (struct usb_hub_descriptor *)buf;\n\n\t\tdev_dbg(hcd->self.controller, \"wHubCharacteristics 0x%04x\\n\",\n\t\t\tdesc->wHubCharacteristics);\n\n\t\t \n\n\t\tdesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_LPSM);\n\t\tdesc->wHubCharacteristics |=\n\t\t\tcpu_to_le16(HUB_CHAR_INDV_PORT_LPSM);\n\n\t\tif (pdata->overcurrent_supported) {\n\t\t\tdesc->wHubCharacteristics &= ~cpu_to_le16(HUB_CHAR_OCPM);\n\t\t\tdesc->wHubCharacteristics |=\n\t\t\t\tcpu_to_le16(HUB_CHAR_INDV_PORT_OCPM);\n\t\t}\n\n\t\tdev_dbg(hcd->self.controller, \"wHubCharacteristics after 0x%04x\\n\",\n\t\t\tdesc->wHubCharacteristics);\n\n\t\treturn ret;\n\n\tcase GetPortStatus:\n\t\t \n\n\t\tdev_dbg(hcd->self.controller, \"GetPortStatus(%d)\\n\", wIndex);\n\n\t\tif (valid_port(wIndex)) {\n\t\t\tif (!ohci_at91_usb_get_power(pdata, wIndex))\n\t\t\t\t*data &= ~cpu_to_le32(RH_PS_PPS);\n\n\t\t\tif (pdata->overcurrent_changed[wIndex])\n\t\t\t\t*data |= cpu_to_le32(RH_PS_OCIC);\n\n\t\t\tif (pdata->overcurrent_status[wIndex])\n\t\t\t\t*data |= cpu_to_le32(RH_PS_POCI);\n\t\t}\n\t}\n\n out:\n\treturn ret;\n}\n\n \n\nstatic irqreturn_t ohci_hcd_at91_overcurrent_irq(int irq, void *data)\n{\n\tstruct platform_device *pdev = data;\n\tstruct at91_usbh_data *pdata = dev_get_platdata(&pdev->dev);\n\tint val, port;\n\n\t \n\tat91_for_each_port(port) {\n\t\tif (gpiod_to_irq(pdata->overcurrent_pin[port]) == irq)\n\t\t\tbreak;\n\t}\n\n\tif (port == AT91_MAX_USBH_PORTS) {\n\t\tdev_err(& pdev->dev, \"overcurrent interrupt from unknown GPIO\\n\");\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tval = gpiod_get_value(pdata->overcurrent_pin[port]);\n\n\t \n\tif (!val) {\n\t\tohci_at91_usb_set_power(pdata, port, 0);\n\t\tpdata->overcurrent_status[port]  = 1;\n\t\tpdata->overcurrent_changed[port] = 1;\n\t}\n\n\tdev_dbg(& pdev->dev, \"overcurrent situation %s\\n\",\n\t\tval ? \"exited\" : \"notified\");\n\n\treturn IRQ_HANDLED;\n}\n\nstatic const struct of_device_id at91_ohci_dt_ids[] = {\n\t{ .compatible = \"atmel,at91rm9200-ohci\" },\n\t{   }\n};\n\nMODULE_DEVICE_TABLE(of, at91_ohci_dt_ids);\n\n \n\nstatic int ohci_hcd_at91_drv_probe(struct platform_device *pdev)\n{\n\tstruct device_node *np = pdev->dev.of_node;\n\tstruct at91_usbh_data\t*pdata;\n\tint\t\t\ti;\n\tint\t\t\tret;\n\tint\t\t\terr;\n\tu32\t\t\tports;\n\n\t \n\tret = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));\n\tif (ret)\n\t\treturn ret;\n\n\tpdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);\n\tif (!pdata)\n\t\treturn -ENOMEM;\n\n\tpdev->dev.platform_data = pdata;\n\n\tif (!of_property_read_u32(np, \"num-ports\", &ports))\n\t\tpdata->ports = ports;\n\n\tat91_for_each_port(i) {\n\t\tif (i >= pdata->ports)\n\t\t\tbreak;\n\n\t\tpdata->vbus_pin[i] =\n\t\t\tdevm_gpiod_get_index_optional(&pdev->dev, \"atmel,vbus\",\n\t\t\t\t\t\t      i, GPIOD_OUT_HIGH);\n\t\tif (IS_ERR(pdata->vbus_pin[i])) {\n\t\t\terr = PTR_ERR(pdata->vbus_pin[i]);\n\t\t\tdev_err(&pdev->dev, \"unable to claim gpio \\\"vbus\\\": %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\tat91_for_each_port(i) {\n\t\tif (i >= pdata->ports)\n\t\t\tbreak;\n\n\t\tpdata->overcurrent_pin[i] =\n\t\t\tdevm_gpiod_get_index_optional(&pdev->dev, \"atmel,oc\",\n\t\t\t\t\t\t      i, GPIOD_IN);\n\t\tif (!pdata->overcurrent_pin[i])\n\t\t\tcontinue;\n\t\tif (IS_ERR(pdata->overcurrent_pin[i])) {\n\t\t\terr = PTR_ERR(pdata->overcurrent_pin[i]);\n\t\t\tdev_err(&pdev->dev, \"unable to claim gpio \\\"overcurrent\\\": %d\\n\", err);\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = devm_request_irq(&pdev->dev,\n\t\t\t\t       gpiod_to_irq(pdata->overcurrent_pin[i]),\n\t\t\t\t       ohci_hcd_at91_overcurrent_irq,\n\t\t\t\t       IRQF_SHARED,\n\t\t\t\t       \"ohci_overcurrent\", pdev);\n\t\tif (ret)\n\t\t\tdev_info(&pdev->dev, \"failed to request gpio \\\"overcurrent\\\" IRQ\\n\");\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 1);\n\treturn usb_hcd_at91_probe(&ohci_at91_hc_driver, pdev);\n}\n\nstatic void ohci_hcd_at91_drv_remove(struct platform_device *pdev)\n{\n\tstruct at91_usbh_data\t*pdata = dev_get_platdata(&pdev->dev);\n\tint\t\t\ti;\n\n\tif (pdata) {\n\t\tat91_for_each_port(i)\n\t\t\tohci_at91_usb_set_power(pdata, i, 0);\n\t}\n\n\tdevice_init_wakeup(&pdev->dev, 0);\n\tusb_hcd_at91_remove(platform_get_drvdata(pdev), pdev);\n}\n\nstatic int __maybe_unused\nohci_hcd_at91_drv_suspend(struct device *dev)\n{\n\tstruct usb_hcd\t*hcd = dev_get_drvdata(dev);\n\tstruct ohci_hcd\t*ohci = hcd_to_ohci(hcd);\n\tstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\tint\t\tret;\n\n\t \n\tohci_at91->wakeup = device_may_wakeup(dev)\n\t\t\t&& !at91_suspend_entering_slow_clock();\n\n\tif (ohci_at91->wakeup)\n\t\tenable_irq_wake(hcd->irq);\n\n\tret = ohci_suspend(hcd, ohci_at91->wakeup);\n\tif (ret) {\n\t\tif (ohci_at91->wakeup)\n\t\t\tdisable_irq_wake(hcd->irq);\n\t\treturn ret;\n\t}\n\t \n\tif (!ohci_at91->wakeup) {\n\t\tohci->rh_state = OHCI_RH_HALTED;\n\n\t\t \n\t\t(void) ohci_readl (ohci, &ohci->regs->control);\n\t\tmsleep(1);\n\t\tohci_at91_port_suspend(ohci_at91, 1);\n\t\tat91_stop_clock(ohci_at91);\n\t} else {\n\t\tohci_at91_port_suspend(ohci_at91, 1);\n\t}\n\n\treturn ret;\n}\n\nstatic int __maybe_unused\nohci_hcd_at91_drv_resume(struct device *dev)\n{\n\tstruct usb_hcd\t*hcd = dev_get_drvdata(dev);\n\tstruct ohci_at91_priv *ohci_at91 = hcd_to_ohci_at91_priv(hcd);\n\n\tohci_at91_port_suspend(ohci_at91, 0);\n\n\tif (ohci_at91->wakeup)\n\t\tdisable_irq_wake(hcd->irq);\n\telse\n\t\tat91_start_clock(ohci_at91);\n\n\t \n\tohci_resume(hcd, !ohci_at91->wakeup);\n\n\treturn 0;\n}\n\nstatic SIMPLE_DEV_PM_OPS(ohci_hcd_at91_pm_ops, ohci_hcd_at91_drv_suspend,\n\t\t\t\t\tohci_hcd_at91_drv_resume);\n\nstatic struct platform_driver ohci_hcd_at91_driver = {\n\t.probe\t\t= ohci_hcd_at91_drv_probe,\n\t.remove_new\t= ohci_hcd_at91_drv_remove,\n\t.shutdown\t= usb_hcd_platform_shutdown,\n\t.driver\t\t= {\n\t\t.name\t= \"at91_ohci\",\n\t\t.pm\t= &ohci_hcd_at91_pm_ops,\n\t\t.of_match_table\t= at91_ohci_dt_ids,\n\t},\n};\n\nstatic int __init ohci_at91_init(void)\n{\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_at91_hc_driver, &ohci_at91_drv_overrides);\n\n\t \n\n\tohci_at91_hc_driver.hub_status_data\t= ohci_at91_hub_status_data;\n\tohci_at91_hc_driver.hub_control\t\t= ohci_at91_hub_control;\n\n\treturn platform_driver_register(&ohci_hcd_at91_driver);\n}\nmodule_init(ohci_at91_init);\n\nstatic void __exit ohci_at91_cleanup(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_at91_driver);\n}\nmodule_exit(ohci_at91_cleanup);\n\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:at91_ohci\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}