{
  "module_name": "ohci-q.c",
  "hash_id": "0fe094756748962e8bd48a39e3b6f00a5e969dc014c24aa4dc1753015d2b0193",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-q.c",
  "human_readable_source": "\n \n\n#include <linux/irq.h>\n#include <linux/slab.h>\n\nstatic void urb_free_priv (struct ohci_hcd *hc, urb_priv_t *urb_priv)\n{\n\tint\t\tlast = urb_priv->length - 1;\n\n\tif (last >= 0) {\n\t\tint\t\ti;\n\t\tstruct td\t*td;\n\n\t\tfor (i = 0; i <= last; i++) {\n\t\t\ttd = urb_priv->td [i];\n\t\t\tif (td)\n\t\t\t\ttd_free (hc, td);\n\t\t}\n\t}\n\n\tlist_del (&urb_priv->pending);\n\tkfree (urb_priv);\n}\n\n \n\n \nstatic void\nfinish_urb(struct ohci_hcd *ohci, struct urb *urb, int status)\n__releases(ohci->lock)\n__acquires(ohci->lock)\n{\n\tstruct device *dev = ohci_to_hcd(ohci)->self.controller;\n\tstruct usb_host_endpoint *ep = urb->ep;\n\tstruct urb_priv *urb_priv;\n\n\t\n\n restart:\n\turb_free_priv (ohci, urb->hcpriv);\n\turb->hcpriv = NULL;\n\tif (likely(status == -EINPROGRESS))\n\t\tstatus = 0;\n\n\tswitch (usb_pipetype (urb->pipe)) {\n\tcase PIPE_ISOCHRONOUS:\n\t\tohci_to_hcd(ohci)->self.bandwidth_isoc_reqs--;\n\t\tif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0) {\n\t\t\tif (quirk_amdiso(ohci))\n\t\t\t\tusb_amd_quirk_pll_enable();\n\t\t\tif (quirk_amdprefetch(ohci))\n\t\t\t\tsb800_prefetch(dev, 0);\n\t\t}\n\t\tbreak;\n\tcase PIPE_INTERRUPT:\n\t\tohci_to_hcd(ohci)->self.bandwidth_int_reqs--;\n\t\tbreak;\n\t}\n\n\t \n\tusb_hcd_unlink_urb_from_ep(ohci_to_hcd(ohci), urb);\n\tspin_unlock (&ohci->lock);\n\tusb_hcd_giveback_urb(ohci_to_hcd(ohci), urb, status);\n\tspin_lock (&ohci->lock);\n\n\t \n\tif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0\n\t\t\t&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0) {\n\t\tohci->hc_control &= ~(OHCI_CTRL_PLE|OHCI_CTRL_IE);\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t}\n\n\t \n\tif (!list_empty(&ep->urb_list)) {\n\t\turb = list_first_entry(&ep->urb_list, struct urb, urb_list);\n\t\turb_priv = urb->hcpriv;\n\t\tif (urb_priv->td_cnt > urb_priv->length) {\n\t\t\tstatus = 0;\n\t\t\tgoto restart;\n\t\t}\n\t}\n}\n\n\n \n\n \nstatic int balance (struct ohci_hcd *ohci, int interval, int load)\n{\n\tint\ti, branch = -ENOSPC;\n\n\t \n\tif (interval > NUM_INTS)\n\t\tinterval = NUM_INTS;\n\n\t \n\tfor (i = 0; i < interval ; i++) {\n\t\tif (branch < 0 || ohci->load [branch] > ohci->load [i]) {\n\t\t\tint\tj;\n\n\t\t\t \n\t\t\tfor (j = i; j < NUM_INTS; j += interval) {\n\t\t\t\tif ((ohci->load [j] + load) > 900)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j < NUM_INTS)\n\t\t\t\tcontinue;\n\t\t\tbranch = i;\n\t\t}\n\t}\n\treturn branch;\n}\n\n \n\n \nstatic void periodic_link (struct ohci_hcd *ohci, struct ed *ed)\n{\n\tunsigned\ti;\n\n\tohci_dbg(ohci, \"link %sed %p branch %d [%dus.], interval %d\\n\",\n\t\t(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? \"iso \" : \"\",\n\t\ted, ed->branch, ed->load, ed->interval);\n\n\tfor (i = ed->branch; i < NUM_INTS; i += ed->interval) {\n\t\tstruct ed\t**prev = &ohci->periodic [i];\n\t\t__hc32\t\t*prev_p = &ohci->hcca->int_table [i];\n\t\tstruct ed\t*here = *prev;\n\n\t\t \n\t\twhile (here && ed != here) {\n\t\t\tif (ed->interval > here->interval)\n\t\t\t\tbreak;\n\t\t\tprev = &here->ed_next;\n\t\t\tprev_p = &here->hwNextED;\n\t\t\there = *prev;\n\t\t}\n\t\tif (ed != here) {\n\t\t\ted->ed_next = here;\n\t\t\tif (here)\n\t\t\t\ted->hwNextED = *prev_p;\n\t\t\twmb ();\n\t\t\t*prev = ed;\n\t\t\t*prev_p = cpu_to_hc32(ohci, ed->dma);\n\t\t\twmb();\n\t\t}\n\t\tohci->load [i] += ed->load;\n\t}\n\tohci_to_hcd(ohci)->self.bandwidth_allocated += ed->load / ed->interval;\n}\n\n \n\nstatic int ed_schedule (struct ohci_hcd *ohci, struct ed *ed)\n{\n\tint\tbranch;\n\n\ted->ed_prev = NULL;\n\ted->ed_next = NULL;\n\ted->hwNextED = 0;\n\twmb ();\n\n\t \n\tswitch (ed->type) {\n\tcase PIPE_CONTROL:\n\t\tif (ohci->ed_controltail == NULL) {\n\t\t\tWARN_ON (ohci->hc_control & OHCI_CTRL_CLE);\n\t\t\tohci_writel (ohci, ed->dma,\n\t\t\t\t\t&ohci->regs->ed_controlhead);\n\t\t} else {\n\t\t\tohci->ed_controltail->ed_next = ed;\n\t\t\tohci->ed_controltail->hwNextED = cpu_to_hc32 (ohci,\n\t\t\t\t\t\t\t\ted->dma);\n\t\t}\n\t\ted->ed_prev = ohci->ed_controltail;\n\t\tif (!ohci->ed_controltail && !ohci->ed_rm_list) {\n\t\t\twmb();\n\t\t\tohci->hc_control |= OHCI_CTRL_CLE;\n\t\t\tohci_writel (ohci, 0, &ohci->regs->ed_controlcurrent);\n\t\t\tohci_writel (ohci, ohci->hc_control,\n\t\t\t\t\t&ohci->regs->control);\n\t\t}\n\t\tohci->ed_controltail = ed;\n\t\tbreak;\n\n\tcase PIPE_BULK:\n\t\tif (ohci->ed_bulktail == NULL) {\n\t\t\tWARN_ON (ohci->hc_control & OHCI_CTRL_BLE);\n\t\t\tohci_writel (ohci, ed->dma, &ohci->regs->ed_bulkhead);\n\t\t} else {\n\t\t\tohci->ed_bulktail->ed_next = ed;\n\t\t\tohci->ed_bulktail->hwNextED = cpu_to_hc32 (ohci,\n\t\t\t\t\t\t\t\ted->dma);\n\t\t}\n\t\ted->ed_prev = ohci->ed_bulktail;\n\t\tif (!ohci->ed_bulktail && !ohci->ed_rm_list) {\n\t\t\twmb();\n\t\t\tohci->hc_control |= OHCI_CTRL_BLE;\n\t\t\tohci_writel (ohci, 0, &ohci->regs->ed_bulkcurrent);\n\t\t\tohci_writel (ohci, ohci->hc_control,\n\t\t\t\t\t&ohci->regs->control);\n\t\t}\n\t\tohci->ed_bulktail = ed;\n\t\tbreak;\n\n\t\n\t\n\tdefault:\n\t\tbranch = balance (ohci, ed->interval, ed->load);\n\t\tif (branch < 0) {\n\t\t\tohci_dbg (ohci,\n\t\t\t\t\"ERR %d, interval %d msecs, load %d\\n\",\n\t\t\t\tbranch, ed->interval, ed->load);\n\t\t\t\n\t\t\treturn branch;\n\t\t}\n\t\ted->branch = branch;\n\t\tperiodic_link (ohci, ed);\n\t}\n\n\t \n\n\ted->state = ED_OPER;\n\treturn 0;\n}\n\n \n\n \nstatic void periodic_unlink (struct ohci_hcd *ohci, struct ed *ed)\n{\n\tint\ti;\n\n\tfor (i = ed->branch; i < NUM_INTS; i += ed->interval) {\n\t\tstruct ed\t*temp;\n\t\tstruct ed\t**prev = &ohci->periodic [i];\n\t\t__hc32\t\t*prev_p = &ohci->hcca->int_table [i];\n\n\t\twhile (*prev && (temp = *prev) != ed) {\n\t\t\tprev_p = &temp->hwNextED;\n\t\t\tprev = &temp->ed_next;\n\t\t}\n\t\tif (*prev) {\n\t\t\t*prev_p = ed->hwNextED;\n\t\t\t*prev = ed->ed_next;\n\t\t}\n\t\tohci->load [i] -= ed->load;\n\t}\n\tohci_to_hcd(ohci)->self.bandwidth_allocated -= ed->load / ed->interval;\n\n\tohci_dbg(ohci, \"unlink %sed %p branch %d [%dus.], interval %d\\n\",\n\t\t(ed->hwINFO & cpu_to_hc32 (ohci, ED_ISO)) ? \"iso \" : \"\",\n\t\ted, ed->branch, ed->load, ed->interval);\n}\n\n \nstatic void ed_deschedule (struct ohci_hcd *ohci, struct ed *ed)\n{\n\ted->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);\n\twmb ();\n\ted->state = ED_UNLINK;\n\n\t \n\tswitch (ed->type) {\n\tcase PIPE_CONTROL:\n\t\t \n\t\tif (ed->ed_prev == NULL) {\n\t\t\tif (!ed->hwNextED) {\n\t\t\t\tohci->hc_control &= ~OHCI_CTRL_CLE;\n\t\t\t\tohci_writel (ohci, ohci->hc_control,\n\t\t\t\t\t\t&ohci->regs->control);\n\t\t\t\t\n\t\t\t} else\n\t\t\t\tohci_writel (ohci,\n\t\t\t\t\thc32_to_cpup (ohci, &ed->hwNextED),\n\t\t\t\t\t&ohci->regs->ed_controlhead);\n\t\t} else {\n\t\t\ted->ed_prev->ed_next = ed->ed_next;\n\t\t\ted->ed_prev->hwNextED = ed->hwNextED;\n\t\t}\n\t\t \n\t\tif (ohci->ed_controltail == ed) {\n\t\t\tohci->ed_controltail = ed->ed_prev;\n\t\t\tif (ohci->ed_controltail)\n\t\t\t\tohci->ed_controltail->ed_next = NULL;\n\t\t} else if (ed->ed_next) {\n\t\t\ted->ed_next->ed_prev = ed->ed_prev;\n\t\t}\n\t\tbreak;\n\n\tcase PIPE_BULK:\n\t\t \n\t\tif (ed->ed_prev == NULL) {\n\t\t\tif (!ed->hwNextED) {\n\t\t\t\tohci->hc_control &= ~OHCI_CTRL_BLE;\n\t\t\t\tohci_writel (ohci, ohci->hc_control,\n\t\t\t\t\t\t&ohci->regs->control);\n\t\t\t\t\n\t\t\t} else\n\t\t\t\tohci_writel (ohci,\n\t\t\t\t\thc32_to_cpup (ohci, &ed->hwNextED),\n\t\t\t\t\t&ohci->regs->ed_bulkhead);\n\t\t} else {\n\t\t\ted->ed_prev->ed_next = ed->ed_next;\n\t\t\ted->ed_prev->hwNextED = ed->hwNextED;\n\t\t}\n\t\t \n\t\tif (ohci->ed_bulktail == ed) {\n\t\t\tohci->ed_bulktail = ed->ed_prev;\n\t\t\tif (ohci->ed_bulktail)\n\t\t\t\tohci->ed_bulktail->ed_next = NULL;\n\t\t} else if (ed->ed_next) {\n\t\t\ted->ed_next->ed_prev = ed->ed_prev;\n\t\t}\n\t\tbreak;\n\n\t \n\t \n\tdefault:\n\t\tperiodic_unlink (ohci, ed);\n\t\tbreak;\n\t}\n}\n\n\n \n\n \nstatic struct ed *ed_get (\n\tstruct ohci_hcd\t\t*ohci,\n\tstruct usb_host_endpoint *ep,\n\tstruct usb_device\t*udev,\n\tunsigned int\t\tpipe,\n\tint\t\t\tinterval\n) {\n\tstruct ed\t\t*ed;\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave (&ohci->lock, flags);\n\n\ted = ep->hcpriv;\n\tif (!ed) {\n\t\tstruct td\t*td;\n\t\tint\t\tis_out;\n\t\tu32\t\tinfo;\n\n\t\ted = ed_alloc (ohci, GFP_ATOMIC);\n\t\tif (!ed) {\n\t\t\t \n\t\t\tgoto done;\n\t\t}\n\n\t\t \n\t\ttd = td_alloc (ohci, GFP_ATOMIC);\n\t\tif (!td) {\n\t\t\t \n\t\t\ted_free (ohci, ed);\n\t\t\ted = NULL;\n\t\t\tgoto done;\n\t\t}\n\t\ted->dummy = td;\n\t\ted->hwTailP = cpu_to_hc32 (ohci, td->td_dma);\n\t\ted->hwHeadP = ed->hwTailP;\t \n\t\ted->state = ED_IDLE;\n\n\t\tis_out = !(ep->desc.bEndpointAddress & USB_DIR_IN);\n\n\t\t \n\t\tinfo = usb_pipedevice (pipe);\n\t\ted->type = usb_pipetype(pipe);\n\n\t\tinfo |= (ep->desc.bEndpointAddress & ~USB_DIR_IN) << 7;\n\t\tinfo |= usb_endpoint_maxp(&ep->desc) << 16;\n\t\tif (udev->speed == USB_SPEED_LOW)\n\t\t\tinfo |= ED_LOWSPEED;\n\t\t \n\t\tif (ed->type != PIPE_CONTROL) {\n\t\t\tinfo |= is_out ? ED_OUT : ED_IN;\n\t\t\tif (ed->type != PIPE_BULK) {\n\t\t\t\t \n\t\t\t\tif (ed->type == PIPE_ISOCHRONOUS)\n\t\t\t\t\tinfo |= ED_ISO;\n\t\t\t\telse if (interval > 32)\t \n\t\t\t\t\tinterval = 32;\n\t\t\t\ted->interval = interval;\n\t\t\t\ted->load = usb_calc_bus_time (\n\t\t\t\t\tudev->speed, !is_out,\n\t\t\t\t\ted->type == PIPE_ISOCHRONOUS,\n\t\t\t\t\tusb_endpoint_maxp(&ep->desc))\n\t\t\t\t\t\t/ 1000;\n\t\t\t}\n\t\t}\n\t\ted->hwINFO = cpu_to_hc32(ohci, info);\n\n\t\tep->hcpriv = ed;\n\t}\n\ndone:\n\tspin_unlock_irqrestore (&ohci->lock, flags);\n\treturn ed;\n}\n\n \n\n \nstatic void start_ed_unlink (struct ohci_hcd *ohci, struct ed *ed)\n{\n\ted->hwINFO |= cpu_to_hc32 (ohci, ED_DEQUEUE);\n\ted_deschedule (ohci, ed);\n\n\t \n\ted->ed_next = ohci->ed_rm_list;\n\ted->ed_prev = NULL;\n\tohci->ed_rm_list = ed;\n\n\t \n\tohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrstatus);\n\tohci_writel (ohci, OHCI_INTR_SF, &ohci->regs->intrenable);\n\t\n\t(void) ohci_readl (ohci, &ohci->regs->control);\n\n\t \n\ted->tick = ohci_frame_no(ohci) + 1;\n\n}\n\n \n\n \n\nstatic void\ntd_fill (struct ohci_hcd *ohci, u32 info,\n\tdma_addr_t data, int len,\n\tstruct urb *urb, int index)\n{\n\tstruct td\t\t*td, *td_pt;\n\tstruct urb_priv\t\t*urb_priv = urb->hcpriv;\n\tint\t\t\tis_iso = info & TD_ISO;\n\tint\t\t\thash;\n\n\t \n\n\t \n\tif (index != (urb_priv->length - 1)\n\t\t\t|| (urb->transfer_flags & URB_NO_INTERRUPT))\n\t\tinfo |= TD_DI_SET (6);\n\n\t \n\ttd_pt = urb_priv->td [index];\n\n\t \n\ttd = urb_priv->td [index] = urb_priv->ed->dummy;\n\turb_priv->ed->dummy = td_pt;\n\n\ttd->ed = urb_priv->ed;\n\ttd->next_dl_td = NULL;\n\ttd->index = index;\n\ttd->urb = urb;\n\ttd->data_dma = data;\n\tif (!len)\n\t\tdata = 0;\n\n\ttd->hwINFO = cpu_to_hc32 (ohci, info);\n\tif (is_iso) {\n\t\ttd->hwCBP = cpu_to_hc32 (ohci, data & 0xFFFFF000);\n\t\t*ohci_hwPSWp(ohci, td, 0) = cpu_to_hc16 (ohci,\n\t\t\t\t\t\t(data & 0x0FFF) | 0xE000);\n\t} else {\n\t\ttd->hwCBP = cpu_to_hc32 (ohci, data);\n\t}\n\tif (data)\n\t\ttd->hwBE = cpu_to_hc32 (ohci, data + len - 1);\n\telse\n\t\ttd->hwBE = 0;\n\ttd->hwNextTD = cpu_to_hc32 (ohci, td_pt->td_dma);\n\n\t \n\tlist_add_tail (&td->td_list, &td->ed->td_list);\n\n\t \n\thash = TD_HASH_FUNC (td->td_dma);\n\ttd->td_hash = ohci->td_hash [hash];\n\tohci->td_hash [hash] = td;\n\n\t \n\twmb ();\n\ttd->ed->hwTailP = td->hwNextTD;\n}\n\n \n\n \nstatic void td_submit_urb (\n\tstruct ohci_hcd\t*ohci,\n\tstruct urb\t*urb\n) {\n\tstruct urb_priv\t*urb_priv = urb->hcpriv;\n\tstruct device *dev = ohci_to_hcd(ohci)->self.controller;\n\tdma_addr_t\tdata;\n\tint\t\tdata_len = urb->transfer_buffer_length;\n\tint\t\tcnt = 0;\n\tu32\t\tinfo = 0;\n\tint\t\tis_out = usb_pipeout (urb->pipe);\n\tint\t\tperiodic = 0;\n\tint\t\ti, this_sg_len, n;\n\tstruct scatterlist\t*sg;\n\n\t \n\tif (!usb_gettoggle (urb->dev, usb_pipeendpoint (urb->pipe), is_out)) {\n\t\tusb_settoggle (urb->dev, usb_pipeendpoint (urb->pipe),\n\t\t\tis_out, 1);\n\t\turb_priv->ed->hwHeadP &= ~cpu_to_hc32 (ohci, ED_C);\n\t}\n\n\tlist_add (&urb_priv->pending, &ohci->pending);\n\n\ti = urb->num_mapped_sgs;\n\tif (data_len > 0 && i > 0) {\n\t\tsg = urb->sg;\n\t\tdata = sg_dma_address(sg);\n\n\t\t \n\t\tthis_sg_len = min_t(int, sg_dma_len(sg), data_len);\n\t} else {\n\t\tsg = NULL;\n\t\tif (data_len)\n\t\t\tdata = urb->transfer_dma;\n\t\telse\n\t\t\tdata = 0;\n\t\tthis_sg_len = data_len;\n\t}\n\n\t \n\tswitch (urb_priv->ed->type) {\n\n\t \n\tcase PIPE_INTERRUPT:\n\t\t \n\t\tperiodic = ohci_to_hcd(ohci)->self.bandwidth_int_reqs++ == 0\n\t\t\t&& ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0;\n\t\tfallthrough;\n\tcase PIPE_BULK:\n\t\tinfo = is_out\n\t\t\t? TD_T_TOGGLE | TD_CC | TD_DP_OUT\n\t\t\t: TD_T_TOGGLE | TD_CC | TD_DP_IN;\n\t\t \n\t\tfor (;;) {\n\t\t\tn = min(this_sg_len, 4096);\n\n\t\t\t \n\t\t\tif (n >= data_len || (i == 1 && n >= this_sg_len)) {\n\t\t\t\tif (!(urb->transfer_flags & URB_SHORT_NOT_OK))\n\t\t\t\t\tinfo |= TD_R;\n\t\t\t}\n\t\t\ttd_fill(ohci, info, data, n, urb, cnt);\n\t\t\tthis_sg_len -= n;\n\t\t\tdata_len -= n;\n\t\t\tdata += n;\n\t\t\tcnt++;\n\n\t\t\tif (this_sg_len <= 0) {\n\t\t\t\tif (--i <= 0 || data_len <= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tsg = sg_next(sg);\n\t\t\t\tdata = sg_dma_address(sg);\n\t\t\t\tthis_sg_len = min_t(int, sg_dma_len(sg),\n\t\t\t\t\t\tdata_len);\n\t\t\t}\n\t\t}\n\t\tif ((urb->transfer_flags & URB_ZERO_PACKET)\n\t\t\t\t&& cnt < urb_priv->length) {\n\t\t\ttd_fill (ohci, info, 0, 0, urb, cnt);\n\t\t\tcnt++;\n\t\t}\n\t\t \n\t\tif (urb_priv->ed->type == PIPE_BULK) {\n\t\t\twmb ();\n\t\t\tohci_writel (ohci, OHCI_BLF, &ohci->regs->cmdstatus);\n\t\t}\n\t\tbreak;\n\n\t \n\tcase PIPE_CONTROL:\n\t\tinfo = TD_CC | TD_DP_SETUP | TD_T_DATA0;\n\t\ttd_fill (ohci, info, urb->setup_dma, 8, urb, cnt++);\n\t\tif (data_len > 0) {\n\t\t\tinfo = TD_CC | TD_R | TD_T_DATA1;\n\t\t\tinfo |= is_out ? TD_DP_OUT : TD_DP_IN;\n\t\t\t \n\t\t\ttd_fill (ohci, info, data, data_len, urb, cnt++);\n\t\t}\n\t\tinfo = (is_out || data_len == 0)\n\t\t\t? TD_CC | TD_DP_IN | TD_T_DATA1\n\t\t\t: TD_CC | TD_DP_OUT | TD_T_DATA1;\n\t\ttd_fill (ohci, info, data, 0, urb, cnt++);\n\t\t \n\t\twmb ();\n\t\tohci_writel (ohci, OHCI_CLF, &ohci->regs->cmdstatus);\n\t\tbreak;\n\n\t \n\tcase PIPE_ISOCHRONOUS:\n\t\tfor (cnt = urb_priv->td_cnt; cnt < urb->number_of_packets;\n\t\t\t\tcnt++) {\n\t\t\tint\tframe = urb->start_frame;\n\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tframe += cnt * urb->interval;\n\t\t\tframe &= 0xffff;\n\t\t\ttd_fill (ohci, TD_CC | TD_ISO | frame,\n\t\t\t\tdata + urb->iso_frame_desc [cnt].offset,\n\t\t\t\turb->iso_frame_desc [cnt].length, urb, cnt);\n\t\t}\n\t\tif (ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs == 0) {\n\t\t\tif (quirk_amdiso(ohci))\n\t\t\t\tusb_amd_quirk_pll_disable();\n\t\t\tif (quirk_amdprefetch(ohci))\n\t\t\t\tsb800_prefetch(dev, 1);\n\t\t}\n\t\tperiodic = ohci_to_hcd(ohci)->self.bandwidth_isoc_reqs++ == 0\n\t\t\t&& ohci_to_hcd(ohci)->self.bandwidth_int_reqs == 0;\n\t\tbreak;\n\t}\n\n\t \n\tif (periodic) {\n\t\twmb ();\n\t\tohci->hc_control |= OHCI_CTRL_PLE|OHCI_CTRL_IE;\n\t\tohci_writel (ohci, ohci->hc_control, &ohci->regs->control);\n\t}\n\n\t\n}\n\n \n\n \nstatic int td_done(struct ohci_hcd *ohci, struct urb *urb, struct td *td)\n{\n\tu32\ttdINFO = hc32_to_cpup (ohci, &td->hwINFO);\n\tint\tcc = 0;\n\tint\tstatus = -EINPROGRESS;\n\n\tlist_del (&td->td_list);\n\n\t \n\tif (tdINFO & TD_ISO) {\n\t\tu16\ttdPSW = ohci_hwPSW(ohci, td, 0);\n\t\tint\tdlen = 0;\n\n\t\t \n\n\t\tcc = (tdPSW >> 12) & 0xF;\n\t\tif (tdINFO & TD_CC)\t \n\t\t\treturn status;\n\n\t\tif (usb_pipeout (urb->pipe))\n\t\t\tdlen = urb->iso_frame_desc [td->index].length;\n\t\telse {\n\t\t\t \n\t\t\tif (cc == TD_DATAUNDERRUN)\n\t\t\t\tcc = TD_CC_NOERROR;\n\t\t\tdlen = tdPSW & 0x3ff;\n\t\t}\n\t\turb->actual_length += dlen;\n\t\turb->iso_frame_desc [td->index].actual_length = dlen;\n\t\turb->iso_frame_desc [td->index].status = cc_to_error [cc];\n\n\t\tif (cc != TD_CC_NOERROR)\n\t\t\tohci_dbg(ohci,\n\t\t\t\t\"urb %p iso td %p (%d) len %d cc %d\\n\",\n\t\t\t\turb, td, 1 + td->index, dlen, cc);\n\n\t \n\t} else {\n\t\tint\ttype = usb_pipetype (urb->pipe);\n\t\tu32\ttdBE = hc32_to_cpup (ohci, &td->hwBE);\n\n\t\tcc = TD_CC_GET (tdINFO);\n\n\t\t \n\t\tif (cc == TD_DATAUNDERRUN\n\t\t\t\t&& !(urb->transfer_flags & URB_SHORT_NOT_OK))\n\t\t\tcc = TD_CC_NOERROR;\n\t\tif (cc != TD_CC_NOERROR && cc < 0x0E)\n\t\t\tstatus = cc_to_error[cc];\n\n\t\t \n\t\tif ((type != PIPE_CONTROL || td->index != 0) && tdBE != 0) {\n\t\t\tif (td->hwCBP == 0)\n\t\t\t\turb->actual_length += tdBE - td->data_dma + 1;\n\t\t\telse\n\t\t\t\turb->actual_length +=\n\t\t\t\t\t  hc32_to_cpup (ohci, &td->hwCBP)\n\t\t\t\t\t- td->data_dma;\n\t\t}\n\n\t\tif (cc != TD_CC_NOERROR && cc < 0x0E)\n\t\t\tohci_dbg(ohci,\n\t\t\t\t\"urb %p td %p (%d) cc %d, len=%d/%d\\n\",\n\t\t\t\turb, td, 1 + td->index, cc,\n\t\t\t\turb->actual_length,\n\t\t\t\turb->transfer_buffer_length);\n\t}\n\treturn status;\n}\n\n \n\nstatic void ed_halted(struct ohci_hcd *ohci, struct td *td, int cc)\n{\n\tstruct urb\t\t*urb = td->urb;\n\turb_priv_t\t\t*urb_priv = urb->hcpriv;\n\tstruct ed\t\t*ed = td->ed;\n\tstruct list_head\t*tmp = td->td_list.next;\n\t__hc32\t\t\ttoggle = ed->hwHeadP & cpu_to_hc32 (ohci, ED_C);\n\n\t \n\ted->hwINFO |= cpu_to_hc32 (ohci, ED_SKIP);\n\twmb ();\n\ted->hwHeadP &= ~cpu_to_hc32 (ohci, ED_H);\n\n\t \n\twhile (tmp != &ed->td_list) {\n\t\tstruct td\t*next;\n\n\t\tnext = list_entry (tmp, struct td, td_list);\n\t\ttmp = next->td_list.next;\n\n\t\tif (next->urb != urb)\n\t\t\tbreak;\n\n\t\t \n\n\t\tlist_del(&next->td_list);\n\t\turb_priv->td_cnt++;\n\t\ted->hwHeadP = next->hwNextTD | toggle;\n\t}\n\n\t \n\tswitch (cc) {\n\tcase TD_DATAUNDERRUN:\n\t\tif ((urb->transfer_flags & URB_SHORT_NOT_OK) == 0)\n\t\t\tbreak;\n\t\tfallthrough;\n\tcase TD_CC_STALL:\n\t\tif (usb_pipecontrol (urb->pipe))\n\t\t\tbreak;\n\t\tfallthrough;\n\tdefault:\n\t\tohci_dbg (ohci,\n\t\t\t\"urb %p path %s ep%d%s %08x cc %d --> status %d\\n\",\n\t\t\turb, urb->dev->devpath,\n\t\t\tusb_pipeendpoint (urb->pipe),\n\t\t\tusb_pipein (urb->pipe) ? \"in\" : \"out\",\n\t\t\thc32_to_cpu (ohci, td->hwINFO),\n\t\t\tcc, cc_to_error [cc]);\n\t}\n}\n\n \nstatic void add_to_done_list(struct ohci_hcd *ohci, struct td *td)\n{\n\tstruct td\t*td2, *td_prev;\n\tstruct ed\t*ed;\n\n\tif (td->next_dl_td)\n\t\treturn;\t\t \n\n\t \n\ted = td->ed;\n\ttd2 = td_prev = td;\n\tlist_for_each_entry_continue_reverse(td2, &ed->td_list, td_list) {\n\t\tif (td2->next_dl_td)\n\t\t\tbreak;\n\t\ttd2->next_dl_td = td_prev;\n\t\ttd_prev = td2;\n\t}\n\n\tif (ohci->dl_end)\n\t\tohci->dl_end->next_dl_td = td_prev;\n\telse\n\t\tohci->dl_start = td_prev;\n\n\t \n\tohci->dl_end = td->next_dl_td = td;\n\n\t \n\ttd2 = ed->pending_td;\n\tif (td2 && td2->next_dl_td)\n\t\ted->pending_td = NULL;\n}\n\n \nstatic void update_done_list(struct ohci_hcd *ohci)\n{\n\tu32\t\ttd_dma;\n\tstruct td\t*td = NULL;\n\n\ttd_dma = hc32_to_cpup (ohci, &ohci->hcca->done_head);\n\tohci->hcca->done_head = 0;\n\twmb();\n\n\t \n\twhile (td_dma) {\n\t\tint\t\tcc;\n\n\t\ttd = dma_to_td (ohci, td_dma);\n\t\tif (!td) {\n\t\t\tohci_err (ohci, \"bad entry %8x\\n\", td_dma);\n\t\t\tbreak;\n\t\t}\n\n\t\ttd->hwINFO |= cpu_to_hc32 (ohci, TD_DONE);\n\t\tcc = TD_CC_GET (hc32_to_cpup (ohci, &td->hwINFO));\n\n\t\t \n\t\tif (cc != TD_CC_NOERROR\n\t\t\t\t&& (td->ed->hwHeadP & cpu_to_hc32 (ohci, ED_H)))\n\t\t\ted_halted(ohci, td, cc);\n\n\t\ttd_dma = hc32_to_cpup (ohci, &td->hwNextTD);\n\t\tadd_to_done_list(ohci, td);\n\t}\n}\n\n \n\n \nstatic void finish_unlinks(struct ohci_hcd *ohci)\n{\n\tunsigned\ttick = ohci_frame_no(ohci);\n\tstruct ed\t*ed, **last;\n\nrescan_all:\n\tfor (last = &ohci->ed_rm_list, ed = *last; ed != NULL; ed = *last) {\n\t\tstruct list_head\t*entry, *tmp;\n\t\tint\t\t\tcompleted, modified;\n\t\t__hc32\t\t\t*prev;\n\n\t\t \n\t\tif (likely(ohci->rh_state == OHCI_RH_RUNNING) &&\n\t\t\t\ttick_before(tick, ed->tick)) {\nskip_ed:\n\t\t\tlast = &ed->ed_next;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!list_empty(&ed->td_list)) {\n\t\t\tstruct td\t*td;\n\t\t\tu32\t\thead;\n\n\t\t\ttd = list_first_entry(&ed->td_list, struct td, td_list);\n\n\t\t\t \n\t\t\thead = hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK;\n\t\t\tif (td->td_dma != head &&\n\t\t\t\t\tohci->rh_state == OHCI_RH_RUNNING)\n\t\t\t\tgoto skip_ed;\n\n\t\t\t \n\t\t\tif (td->next_dl_td)\n\t\t\t\tgoto skip_ed;\n\t\t}\n\n\t\t \n\t\ted->hwHeadP &= ~cpu_to_hc32(ohci, ED_H);\n\t\ted->hwNextED = 0;\n\t\twmb();\n\t\ted->hwINFO &= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);\n\n\t\t \n\t\t*last = ed->ed_next;\n\t\ted->ed_next = NULL;\n\t\tmodified = 0;\n\n\t\t \nrescan_this:\n\t\tcompleted = 0;\n\t\tprev = &ed->hwHeadP;\n\t\tlist_for_each_safe (entry, tmp, &ed->td_list) {\n\t\t\tstruct td\t*td;\n\t\t\tstruct urb\t*urb;\n\t\t\turb_priv_t\t*urb_priv;\n\t\t\t__hc32\t\tsavebits;\n\t\t\tu32\t\ttdINFO;\n\n\t\t\ttd = list_entry (entry, struct td, td_list);\n\t\t\turb = td->urb;\n\t\t\turb_priv = td->urb->hcpriv;\n\n\t\t\tif (!urb->unlinked) {\n\t\t\t\tprev = &td->hwNextTD;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t \n\t\t\tsavebits = *prev & ~cpu_to_hc32 (ohci, TD_MASK);\n\t\t\t*prev = td->hwNextTD | savebits;\n\n\t\t\t \n\t\t\ttdINFO = hc32_to_cpup(ohci, &td->hwINFO);\n\t\t\tif ((tdINFO & TD_T) == TD_T_DATA0)\n\t\t\t\ted->hwHeadP &= ~cpu_to_hc32(ohci, ED_C);\n\t\t\telse if ((tdINFO & TD_T) == TD_T_DATA1)\n\t\t\t\ted->hwHeadP |= cpu_to_hc32(ohci, ED_C);\n\n\t\t\t \n\t\t\ttd_done (ohci, urb, td);\n\t\t\turb_priv->td_cnt++;\n\n\t\t\t \n\t\t\tif (urb_priv->td_cnt >= urb_priv->length) {\n\t\t\t\tmodified = completed = 1;\n\t\t\t\tfinish_urb(ohci, urb, 0);\n\t\t\t}\n\t\t}\n\t\tif (completed && !list_empty (&ed->td_list))\n\t\t\tgoto rescan_this;\n\n\t\t \n\t\tif (list_empty(&ed->td_list)) {\n\t\t\ted->state = ED_IDLE;\n\t\t\tlist_del(&ed->in_use_list);\n\t\t} else if (ohci->rh_state == OHCI_RH_RUNNING) {\n\t\t\ted_schedule(ohci, ed);\n\t\t} else {\n\t\t\ted->ed_next = ohci->ed_rm_list;\n\t\t\tohci->ed_rm_list = ed;\n\t\t\t \n\t\t\tif (last == &ohci->ed_rm_list)\n\t\t\t\tlast = &ed->ed_next;\n\t\t}\n\n\t\tif (modified)\n\t\t\tgoto rescan_all;\n\t}\n\n\t \n\tif (ohci->rh_state == OHCI_RH_RUNNING && !ohci->ed_rm_list) {\n\t\tu32\tcommand = 0, control = 0;\n\n\t\tif (ohci->ed_controltail) {\n\t\t\tcommand |= OHCI_CLF;\n\t\t\tif (quirk_zfmicro(ohci))\n\t\t\t\tmdelay(1);\n\t\t\tif (!(ohci->hc_control & OHCI_CTRL_CLE)) {\n\t\t\t\tcontrol |= OHCI_CTRL_CLE;\n\t\t\t\tohci_writel (ohci, 0,\n\t\t\t\t\t&ohci->regs->ed_controlcurrent);\n\t\t\t}\n\t\t}\n\t\tif (ohci->ed_bulktail) {\n\t\t\tcommand |= OHCI_BLF;\n\t\t\tif (quirk_zfmicro(ohci))\n\t\t\t\tmdelay(1);\n\t\t\tif (!(ohci->hc_control & OHCI_CTRL_BLE)) {\n\t\t\t\tcontrol |= OHCI_CTRL_BLE;\n\t\t\t\tohci_writel (ohci, 0,\n\t\t\t\t\t&ohci->regs->ed_bulkcurrent);\n\t\t\t}\n\t\t}\n\n\t\t \n\t\tif (control) {\n\t\t\tohci->hc_control |= control;\n\t\t\tif (quirk_zfmicro(ohci))\n\t\t\t\tmdelay(1);\n\t\t\tohci_writel (ohci, ohci->hc_control,\n\t\t\t\t\t&ohci->regs->control);\n\t\t}\n\t\tif (command) {\n\t\t\tif (quirk_zfmicro(ohci))\n\t\t\t\tmdelay(1);\n\t\t\tohci_writel (ohci, command, &ohci->regs->cmdstatus);\n\t\t}\n\t}\n}\n\n\n\n \n\n \nstatic void takeback_td(struct ohci_hcd *ohci, struct td *td)\n{\n\tstruct urb\t*urb = td->urb;\n\turb_priv_t\t*urb_priv = urb->hcpriv;\n\tstruct ed\t*ed = td->ed;\n\tint\t\tstatus;\n\n\t \n\tstatus = td_done(ohci, urb, td);\n\turb_priv->td_cnt++;\n\n\t \n\tif (urb_priv->td_cnt >= urb_priv->length)\n\t\tfinish_urb(ohci, urb, status);\n\n\t \n\tif (list_empty(&ed->td_list)) {\n\t\tif (ed->state == ED_OPER)\n\t\t\tstart_ed_unlink(ohci, ed);\n\n\t \n\t} else if ((ed->hwINFO & cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE))\n\t\t\t== cpu_to_hc32(ohci, ED_SKIP)) {\n\t\ttd = list_entry(ed->td_list.next, struct td, td_list);\n\t\tif (!(td->hwINFO & cpu_to_hc32(ohci, TD_DONE))) {\n\t\t\ted->hwINFO &= ~cpu_to_hc32(ohci, ED_SKIP);\n\t\t\t \n\t\t\tswitch (ed->type) {\n\t\t\tcase PIPE_CONTROL:\n\t\t\t\tohci_writel(ohci, OHCI_CLF,\n\t\t\t\t\t\t&ohci->regs->cmdstatus);\n\t\t\t\tbreak;\n\t\t\tcase PIPE_BULK:\n\t\t\t\tohci_writel(ohci, OHCI_BLF,\n\t\t\t\t\t\t&ohci->regs->cmdstatus);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n \nstatic void process_done_list(struct ohci_hcd *ohci)\n{\n\tstruct td\t*td;\n\n\twhile (ohci->dl_start) {\n\t\ttd = ohci->dl_start;\n\t\tif (td == ohci->dl_end)\n\t\t\tohci->dl_start = ohci->dl_end = NULL;\n\t\telse\n\t\t\tohci->dl_start = td->next_dl_td;\n\n\t\ttakeback_td(ohci, td);\n\t}\n}\n\n \nstatic void ohci_work(struct ohci_hcd *ohci)\n{\n\tif (ohci->working) {\n\t\tohci->restart_work = 1;\n\t\treturn;\n\t}\n\tohci->working = 1;\n\n restart:\n\tprocess_done_list(ohci);\n\tif (ohci->ed_rm_list)\n\t\tfinish_unlinks(ohci);\n\n\tif (ohci->restart_work) {\n\t\tohci->restart_work = 0;\n\t\tgoto restart;\n\t}\n\tohci->working = 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}