{
  "module_name": "ohci-da8xx.c",
  "hash_id": "da0dbec5c33c410d9c96246a81373de84f789364d3b7938978436b4f0cef6784",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/ohci-da8xx.c",
  "human_readable_source": "\n \n\n#include <linux/clk.h>\n#include <linux/gpio/consumer.h>\n#include <linux/io.h>\n#include <linux/interrupt.h>\n#include <linux/jiffies.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/of.h>\n#include <linux/platform_device.h>\n#include <linux/phy/phy.h>\n#include <linux/platform_data/usb-davinci.h>\n#include <linux/regulator/consumer.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <asm/unaligned.h>\n\n#include \"ohci.h\"\n\n#define DRIVER_DESC \"DA8XX\"\n#define DRV_NAME \"ohci-da8xx\"\n\nstatic struct hc_driver __read_mostly ohci_da8xx_hc_driver;\n\nstatic int (*orig_ohci_hub_control)(struct usb_hcd  *hcd, u16 typeReq,\n\t\t\tu16 wValue, u16 wIndex, char *buf, u16 wLength);\nstatic int (*orig_ohci_hub_status_data)(struct usb_hcd *hcd, char *buf);\n\nstruct da8xx_ohci_hcd {\n\tstruct usb_hcd *hcd;\n\tstruct clk *usb11_clk;\n\tstruct phy *usb11_phy;\n\tstruct regulator *vbus_reg;\n\tstruct notifier_block nb;\n\tstruct gpio_desc *oc_gpio;\n};\n\n#define to_da8xx_ohci(hcd) (struct da8xx_ohci_hcd *)(hcd_to_ohci(hcd)->priv)\n\n \nstatic volatile u16 ocic_mask;\n\nstatic int ohci_da8xx_enable(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\tint ret;\n\n\tret = clk_prepare_enable(da8xx_ohci->usb11_clk);\n\tif (ret)\n\t\treturn ret;\n\n\tret = phy_init(da8xx_ohci->usb11_phy);\n\tif (ret)\n\t\tgoto err_phy_init;\n\n\tret = phy_power_on(da8xx_ohci->usb11_phy);\n\tif (ret)\n\t\tgoto err_phy_power_on;\n\n\treturn 0;\n\nerr_phy_power_on:\n\tphy_exit(da8xx_ohci->usb11_phy);\nerr_phy_init:\n\tclk_disable_unprepare(da8xx_ohci->usb11_clk);\n\n\treturn ret;\n}\n\nstatic void ohci_da8xx_disable(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\n\tphy_power_off(da8xx_ohci->usb11_phy);\n\tphy_exit(da8xx_ohci->usb11_phy);\n\tclk_disable_unprepare(da8xx_ohci->usb11_clk);\n}\n\nstatic int ohci_da8xx_set_power(struct usb_hcd *hcd, int on)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\tstruct device *dev = hcd->self.controller;\n\tint ret;\n\n\tif (!da8xx_ohci->vbus_reg)\n\t\treturn 0;\n\n\tif (on) {\n\t\tret = regulator_enable(da8xx_ohci->vbus_reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed to enable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\tret = regulator_disable(da8xx_ohci->vbus_reg);\n\t\tif (ret) {\n\t\t\tdev_err(dev, \"Failed  to disable regulator: %d\\n\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int ohci_da8xx_get_power(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\n\tif (da8xx_ohci->vbus_reg)\n\t\treturn regulator_is_enabled(da8xx_ohci->vbus_reg);\n\n\treturn 1;\n}\n\nstatic int ohci_da8xx_get_oci(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\tunsigned int flags;\n\tint ret;\n\n\tif (da8xx_ohci->oc_gpio)\n\t\treturn gpiod_get_value_cansleep(da8xx_ohci->oc_gpio);\n\n\tif (!da8xx_ohci->vbus_reg)\n\t\treturn 0;\n\n\tret = regulator_get_error_flags(da8xx_ohci->vbus_reg, &flags);\n\tif (ret)\n\t\treturn ret;\n\n\tif (flags & REGULATOR_ERROR_OVER_CURRENT)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ohci_da8xx_has_set_power(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\n\tif (da8xx_ohci->vbus_reg)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ohci_da8xx_has_oci(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\n\tif (da8xx_ohci->oc_gpio)\n\t\treturn 1;\n\n\tif (da8xx_ohci->vbus_reg)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ohci_da8xx_has_potpgt(struct usb_hcd *hcd)\n{\n\tstruct device *dev\t\t= hcd->self.controller;\n\tstruct da8xx_ohci_root_hub *hub\t= dev_get_platdata(dev);\n\n\tif (hub && hub->potpgt)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int ohci_da8xx_regulator_event(struct notifier_block *nb,\n\t\t\t\tunsigned long event, void *data)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci =\n\t\t\t\tcontainer_of(nb, struct da8xx_ohci_hcd, nb);\n\n\tif (event & REGULATOR_EVENT_OVER_CURRENT) {\n\t\tocic_mask |= 1 << 1;\n\t\tohci_da8xx_set_power(da8xx_ohci->hcd, 0);\n\t}\n\n\treturn 0;\n}\n\nstatic irqreturn_t ohci_da8xx_oc_thread(int irq, void *data)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = data;\n\tstruct device *dev = da8xx_ohci->hcd->self.controller;\n\tint ret;\n\n\tif (gpiod_get_value_cansleep(da8xx_ohci->oc_gpio) &&\n\t    da8xx_ohci->vbus_reg) {\n\t\tret = regulator_disable(da8xx_ohci->vbus_reg);\n\t\tif (ret)\n\t\t\tdev_err(dev, \"Failed to disable regulator: %d\\n\", ret);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\nstatic int ohci_da8xx_register_notify(struct usb_hcd *hcd)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci = to_da8xx_ohci(hcd);\n\tstruct device *dev\t\t= hcd->self.controller;\n\tint ret = 0;\n\n\tif (!da8xx_ohci->oc_gpio && da8xx_ohci->vbus_reg) {\n\t\tda8xx_ohci->nb.notifier_call = ohci_da8xx_regulator_event;\n\t\tret = devm_regulator_register_notifier(da8xx_ohci->vbus_reg,\n\t\t\t\t\t\t&da8xx_ohci->nb);\n\t}\n\n\tif (ret)\n\t\tdev_err(dev, \"Failed to register notifier: %d\\n\", ret);\n\n\treturn ret;\n}\n\nstatic int ohci_da8xx_reset(struct usb_hcd *hcd)\n{\n\tstruct device *dev\t\t= hcd->self.controller;\n\tstruct da8xx_ohci_root_hub *hub\t= dev_get_platdata(dev);\n\tstruct ohci_hcd\t*ohci\t\t= hcd_to_ohci(hcd);\n\tint result;\n\tu32 rh_a;\n\n\tdev_dbg(dev, \"starting USB controller\\n\");\n\n\tresult = ohci_da8xx_enable(hcd);\n\tif (result < 0)\n\t\treturn result;\n\n\t \n\tohci->num_ports = 1;\n\n\tresult = ohci_setup(hcd);\n\tif (result < 0) {\n\t\tohci_da8xx_disable(hcd);\n\t\treturn result;\n\t}\n\n\t \n\trh_a = ohci_readl(ohci, &ohci->regs->roothub.a);\n\tif (ohci_da8xx_has_set_power(hcd)) {\n\t\trh_a &= ~RH_A_NPS;\n\t\trh_a |=  RH_A_PSM;\n\t}\n\tif (ohci_da8xx_has_oci(hcd)) {\n\t\trh_a &= ~RH_A_NOCP;\n\t\trh_a |=  RH_A_OCPM;\n\t}\n\tif (ohci_da8xx_has_potpgt(hcd)) {\n\t\trh_a &= ~RH_A_POTPGT;\n\t\trh_a |= hub->potpgt << 24;\n\t}\n\tohci_writel(ohci, rh_a, &ohci->regs->roothub.a);\n\n\treturn result;\n}\n\n \nstatic int ohci_da8xx_hub_status_data(struct usb_hcd *hcd, char *buf)\n{\n\tint length\t\t= orig_ohci_hub_status_data(hcd, buf);\n\n\t \n\tif (ocic_mask & (1 << 1)) {\n\t\tdev_dbg(hcd->self.controller, \"over-current indicator change \"\n\t\t\t\"on port 1\\n\");\n\n\t\tif (!length)\n\t\t\tlength = 1;\n\n\t\tbuf[0] |= 1 << 1;\n\t}\n\treturn length;\n}\n\n \nstatic int ohci_da8xx_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,\n\t\t\t\t  u16 wIndex, char *buf, u16 wLength)\n{\n\tstruct device *dev\t\t= hcd->self.controller;\n\tint temp;\n\n\tswitch (typeReq) {\n\tcase GetPortStatus:\n\t\t \n\t\tif (wIndex != 1)\n\t\t\tbreak;\n\n\t\tdev_dbg(dev, \"GetPortStatus(%u)\\n\", wIndex);\n\n\t\ttemp = roothub_portstatus(hcd_to_ohci(hcd), wIndex - 1);\n\n\t\t \n\t\tif (!ohci_da8xx_get_power(hcd))\n\t\t\ttemp &= ~RH_PS_PPS;\n\n\t\t \n\t\tif (ohci_da8xx_get_oci(hcd) > 0)\n\t\t\ttemp |=  RH_PS_POCI;\n\n\t\t \n\t\tif (ocic_mask & (1 << wIndex))\n\t\t\ttemp |=  RH_PS_OCIC;\n\n\t\tput_unaligned(cpu_to_le32(temp), (__le32 *)buf);\n\t\treturn 0;\n\tcase SetPortFeature:\n\t\ttemp = 1;\n\t\tgoto check_port;\n\tcase ClearPortFeature:\n\t\ttemp = 0;\n\ncheck_port:\n\t\t \n\t\tif (wIndex != 1)\n\t\t\tbreak;\n\n\t\tswitch (wValue) {\n\t\tcase USB_PORT_FEAT_POWER:\n\t\t\tdev_dbg(dev, \"%sPortFeature(%u): %s\\n\",\n\t\t\t\ttemp ? \"Set\" : \"Clear\", wIndex, \"POWER\");\n\n\t\t\treturn ohci_da8xx_set_power(hcd, temp) ? -EPIPE : 0;\n\t\tcase USB_PORT_FEAT_C_OVER_CURRENT:\n\t\t\tdev_dbg(dev, \"%sPortFeature(%u): %s\\n\",\n\t\t\t\ttemp ? \"Set\" : \"Clear\", wIndex,\n\t\t\t\t\"C_OVER_CURRENT\");\n\n\t\t\tif (temp)\n\t\t\t\tocic_mask |= 1 << wIndex;\n\t\t\telse\n\t\t\t\tocic_mask &= ~(1 << wIndex);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn orig_ohci_hub_control(hcd, typeReq, wValue,\n\t\t\twIndex, buf, wLength);\n}\n\n \n#ifdef CONFIG_OF\nstatic const struct of_device_id da8xx_ohci_ids[] = {\n\t{ .compatible = \"ti,da830-ohci\" },\n\t{ }\n};\nMODULE_DEVICE_TABLE(of, da8xx_ohci_ids);\n#endif\n\nstatic int ohci_da8xx_probe(struct platform_device *pdev)\n{\n\tstruct da8xx_ohci_hcd *da8xx_ohci;\n\tstruct device *dev = &pdev->dev;\n\tint error, hcd_irq, oc_irq;\n\tstruct usb_hcd\t*hcd;\n\tstruct resource *mem;\n\n\thcd = usb_create_hcd(&ohci_da8xx_hc_driver, dev, dev_name(dev));\n\tif (!hcd)\n\t\treturn -ENOMEM;\n\n\tda8xx_ohci = to_da8xx_ohci(hcd);\n\tda8xx_ohci->hcd = hcd;\n\n\tda8xx_ohci->usb11_clk = devm_clk_get(dev, NULL);\n\tif (IS_ERR(da8xx_ohci->usb11_clk)) {\n\t\terror = PTR_ERR(da8xx_ohci->usb11_clk);\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get clock.\\n\");\n\t\tgoto err;\n\t}\n\n\tda8xx_ohci->usb11_phy = devm_phy_get(dev, \"usb-phy\");\n\tif (IS_ERR(da8xx_ohci->usb11_phy)) {\n\t\terror = PTR_ERR(da8xx_ohci->usb11_phy);\n\t\tif (error != -EPROBE_DEFER)\n\t\t\tdev_err(dev, \"Failed to get phy.\\n\");\n\t\tgoto err;\n\t}\n\n\tda8xx_ohci->vbus_reg = devm_regulator_get_optional(dev, \"vbus\");\n\tif (IS_ERR(da8xx_ohci->vbus_reg)) {\n\t\terror = PTR_ERR(da8xx_ohci->vbus_reg);\n\t\tif (error == -ENODEV) {\n\t\t\tda8xx_ohci->vbus_reg = NULL;\n\t\t} else if (error == -EPROBE_DEFER) {\n\t\t\tgoto err;\n\t\t} else {\n\t\t\tdev_err(dev, \"Failed to get regulator\\n\");\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tda8xx_ohci->oc_gpio = devm_gpiod_get_optional(dev, \"oc\", GPIOD_IN);\n\tif (IS_ERR(da8xx_ohci->oc_gpio)) {\n\t\terror = PTR_ERR(da8xx_ohci->oc_gpio);\n\t\tgoto err;\n\t}\n\n\tif (da8xx_ohci->oc_gpio) {\n\t\toc_irq = gpiod_to_irq(da8xx_ohci->oc_gpio);\n\t\tif (oc_irq < 0) {\n\t\t\terror = oc_irq;\n\t\t\tgoto err;\n\t\t}\n\n\t\terror = devm_request_threaded_irq(dev, oc_irq, NULL,\n\t\t\t\tohci_da8xx_oc_thread, IRQF_TRIGGER_RISING |\n\t\t\t\tIRQF_TRIGGER_FALLING | IRQF_ONESHOT,\n\t\t\t\t\"OHCI over-current indicator\", da8xx_ohci);\n\t\tif (error)\n\t\t\tgoto err;\n\t}\n\n\thcd->regs = devm_platform_get_and_ioremap_resource(pdev, 0, &mem);\n\tif (IS_ERR(hcd->regs)) {\n\t\terror = PTR_ERR(hcd->regs);\n\t\tgoto err;\n\t}\n\thcd->rsrc_start = mem->start;\n\thcd->rsrc_len = resource_size(mem);\n\n\thcd_irq = platform_get_irq(pdev, 0);\n\tif (hcd_irq < 0) {\n\t\terror = -ENODEV;\n\t\tgoto err;\n\t}\n\n\terror = usb_add_hcd(hcd, hcd_irq, 0);\n\tif (error)\n\t\tgoto err;\n\n\tdevice_wakeup_enable(hcd->self.controller);\n\n\terror = ohci_da8xx_register_notify(hcd);\n\tif (error)\n\t\tgoto err_remove_hcd;\n\n\treturn 0;\n\nerr_remove_hcd:\n\tusb_remove_hcd(hcd);\nerr:\n\tusb_put_hcd(hcd);\n\treturn error;\n}\n\nstatic void ohci_da8xx_remove(struct platform_device *pdev)\n{\n\tstruct usb_hcd\t*hcd = platform_get_drvdata(pdev);\n\n\tusb_remove_hcd(hcd);\n\tusb_put_hcd(hcd);\n}\n\n#ifdef CONFIG_PM\nstatic int ohci_da8xx_suspend(struct platform_device *pdev,\n\t\t\t\tpm_message_t message)\n{\n\tstruct usb_hcd\t*hcd\t= platform_get_drvdata(pdev);\n\tstruct ohci_hcd\t*ohci\t= hcd_to_ohci(hcd);\n\tbool\t\tdo_wakeup\t= device_may_wakeup(&pdev->dev);\n\tint\t\tret;\n\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tret = ohci_suspend(hcd, do_wakeup);\n\tif (ret)\n\t\treturn ret;\n\n\tohci_da8xx_disable(hcd);\n\thcd->state = HC_STATE_SUSPENDED;\n\n\treturn ret;\n}\n\nstatic int ohci_da8xx_resume(struct platform_device *dev)\n{\n\tstruct usb_hcd\t*hcd\t= platform_get_drvdata(dev);\n\tstruct ohci_hcd\t*ohci\t= hcd_to_ohci(hcd);\n\tint ret;\n\n\tif (time_before(jiffies, ohci->next_statechange))\n\t\tmsleep(5);\n\tohci->next_statechange = jiffies;\n\n\tret = ohci_da8xx_enable(hcd);\n\tif (ret)\n\t\treturn ret;\n\n\tohci_resume(hcd, false);\n\n\treturn 0;\n}\n#endif\n\nstatic const struct ohci_driver_overrides da8xx_overrides __initconst = {\n\t.reset\t\t = ohci_da8xx_reset,\n\t.extra_priv_size = sizeof(struct da8xx_ohci_hcd),\n};\n\n \nstatic struct platform_driver ohci_hcd_da8xx_driver = {\n\t.probe\t\t= ohci_da8xx_probe,\n\t.remove_new\t= ohci_da8xx_remove,\n\t.shutdown \t= usb_hcd_platform_shutdown,\n#ifdef\tCONFIG_PM\n\t.suspend\t= ohci_da8xx_suspend,\n\t.resume\t\t= ohci_da8xx_resume,\n#endif\n\t.driver\t\t= {\n\t\t.name\t= DRV_NAME,\n\t\t.of_match_table = of_match_ptr(da8xx_ohci_ids),\n\t},\n};\n\nstatic int __init ohci_da8xx_init(void)\n{\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tohci_init_driver(&ohci_da8xx_hc_driver, &da8xx_overrides);\n\n\t \n\n\torig_ohci_hub_control = ohci_da8xx_hc_driver.hub_control;\n\torig_ohci_hub_status_data = ohci_da8xx_hc_driver.hub_status_data;\n\n\tohci_da8xx_hc_driver.hub_status_data     = ohci_da8xx_hub_status_data;\n\tohci_da8xx_hc_driver.hub_control         = ohci_da8xx_hub_control;\n\n\treturn platform_driver_register(&ohci_hcd_da8xx_driver);\n}\nmodule_init(ohci_da8xx_init);\n\nstatic void __exit ohci_da8xx_exit(void)\n{\n\tplatform_driver_unregister(&ohci_hcd_da8xx_driver);\n}\nmodule_exit(ohci_da8xx_exit);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"platform:\" DRV_NAME);\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}