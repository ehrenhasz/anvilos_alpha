{
  "module_name": "isp1362.h",
  "hash_id": "e155b94921b6d6d73a0e6f7af172df8fc634d1501997a10af759d8d18ee33c8a",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/isp1362.h",
  "human_readable_source": " \n \n\n \n\n#define MAX_ROOT_PORTS\t\t2\n\n#define USE_32BIT\t\t0\n\n \n#define USE_PLATFORM_DELAY\t0\n#define USE_NDELAY\t\t0\n\n#define DUMMY_DELAY_ACCESS do {} while (0)\n\n \n\n#define USB_RESET_WIDTH\t\t\t50\n#define MAX_XFER_SIZE\t\t\t1023\n\n \n#define ISP1362_BUF_SIZE\t\t4096\n#define ISP1362_ISTL_BUFSIZE\t\t512\n#define ISP1362_INTL_BLKSIZE\t\t64\n#define ISP1362_INTL_BUFFERS\t\t16\n#define ISP1362_ATL_BLKSIZE\t\t64\n\n#define ISP1362_REG_WRITE_OFFSET\t0x80\n\n#define REG_WIDTH_16\t\t\t0x000\n#define REG_WIDTH_32\t\t\t0x100\n#define REG_WIDTH_MASK\t\t\t0x100\n#define REG_NO_MASK\t\t\t0x0ff\n\n#ifdef ISP1362_DEBUG\ntypedef const unsigned int isp1362_reg_t;\n\n#define REG_ACCESS_R\t\t\t0x200\n#define REG_ACCESS_W\t\t\t0x400\n#define REG_ACCESS_RW\t\t\t0x600\n#define REG_ACCESS_MASK\t\t\t0x600\n\n#define ISP1362_REG_NO(r)\t\t((r) & REG_NO_MASK)\n\n#define ISP1362_REG(name, addr, width, rw) \\\nstatic isp1362_reg_t ISP1362_REG_##name = ((addr) | (width) | (rw))\n\n#define REG_ACCESS_TEST(r)   BUG_ON(((r) & ISP1362_REG_WRITE_OFFSET) && !((r) & REG_ACCESS_W))\n#define REG_WIDTH_TEST(r, w) BUG_ON(((r) & REG_WIDTH_MASK) != (w))\n#else\ntypedef const unsigned char isp1362_reg_t;\n#define ISP1362_REG_NO(r)\t\t(r)\n\n#define ISP1362_REG(name, addr, width, rw) \\\nstatic isp1362_reg_t __maybe_unused ISP1362_REG_##name = addr\n\n#define REG_ACCESS_TEST(r)\t\tdo {} while (0)\n#define REG_WIDTH_TEST(r, w)\t\tdo {} while (0)\n#endif\n\n \n \nISP1362_REG(HCREVISION,\t0x00,\tREG_WIDTH_32,\tREG_ACCESS_R);\nISP1362_REG(HCCONTROL,\t0x01,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCCMDSTAT,\t0x02,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCINTSTAT,\t0x03,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCINTENB,\t0x04,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCINTDIS,\t0x05,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCFMINTVL,\t0x0d,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCFMREM,\t0x0e,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCFMNUM,\t0x0f,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCLSTHRESH,\t0x11,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCRHDESCA,\t0x12,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCRHDESCB,\t0x13,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCRHSTATUS,\t0x14,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCRHPORT1,\t0x15,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCRHPORT2,\t0x16,\tREG_WIDTH_32,\tREG_ACCESS_RW);\n\n \nISP1362_REG(HCHWCFG,\t0x20,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n#define HCHWCFG_DISABLE_SUSPEND\t(1 << 15)\n#define HCHWCFG_GLOBAL_PWRDOWN\t(1 << 14)\n#define HCHWCFG_PULLDOWN_DS2\t(1 << 13)\n#define HCHWCFG_PULLDOWN_DS1\t(1 << 12)\n#define HCHWCFG_CLKNOTSTOP\t(1 << 11)\n#define HCHWCFG_ANALOG_OC\t(1 << 10)\n#define HCHWCFG_ONEINT\t\t(1 << 9)\n#define HCHWCFG_DACK_MODE\t(1 << 8)\n#define HCHWCFG_ONEDMA\t\t(1 << 7)\n#define HCHWCFG_DACK_POL\t(1 << 6)\n#define HCHWCFG_DREQ_POL\t(1 << 5)\n#define HCHWCFG_DBWIDTH_MASK\t(0x03 << 3)\n#define HCHWCFG_DBWIDTH(n)\t(((n) << 3) & HCHWCFG_DBWIDTH_MASK)\n#define HCHWCFG_INT_POL\t\t(1 << 2)\n#define HCHWCFG_INT_TRIGGER\t(1 << 1)\n#define HCHWCFG_INT_ENABLE\t(1 << 0)\n\nISP1362_REG(HCDMACFG,\t0x21,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n#define HCDMACFG_CTR_ENABLE\t(1 << 7)\n#define HCDMACFG_BURST_LEN_MASK\t(0x03 << 5)\n#define HCDMACFG_BURST_LEN(n)\t(((n) << 5) & HCDMACFG_BURST_LEN_MASK)\n#define HCDMACFG_BURST_LEN_1\tHCDMACFG_BURST_LEN(0)\n#define HCDMACFG_BURST_LEN_4\tHCDMACFG_BURST_LEN(1)\n#define HCDMACFG_BURST_LEN_8\tHCDMACFG_BURST_LEN(2)\n#define HCDMACFG_DMA_ENABLE\t(1 << 4)\n#define HCDMACFG_BUF_TYPE_MASK\t(0x07 << 1)\n#define HCDMACFG_BUF_TYPE(n)\t(((n) << 1) & HCDMACFG_BUF_TYPE_MASK)\n#define HCDMACFG_BUF_ISTL0\tHCDMACFG_BUF_TYPE(0)\n#define HCDMACFG_BUF_ISTL1\tHCDMACFG_BUF_TYPE(1)\n#define HCDMACFG_BUF_INTL\tHCDMACFG_BUF_TYPE(2)\n#define HCDMACFG_BUF_ATL\tHCDMACFG_BUF_TYPE(3)\n#define HCDMACFG_BUF_DIRECT\tHCDMACFG_BUF_TYPE(4)\n#define HCDMACFG_DMA_RW_SELECT\t(1 << 0)\n\nISP1362_REG(HCXFERCTR,\t0x22,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\nISP1362_REG(HCuPINT,\t0x24,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n#define HCuPINT_SOF\t\t(1 << 0)\n#define HCuPINT_ISTL0\t\t(1 << 1)\n#define HCuPINT_ISTL1\t\t(1 << 2)\n#define HCuPINT_EOT\t\t(1 << 3)\n#define HCuPINT_OPR\t\t(1 << 4)\n#define HCuPINT_SUSP\t\t(1 << 5)\n#define HCuPINT_CLKRDY\t\t(1 << 6)\n#define HCuPINT_INTL\t\t(1 << 7)\n#define HCuPINT_ATL\t\t(1 << 8)\n#define HCuPINT_OTG\t\t(1 << 9)\n\nISP1362_REG(HCuPINTENB,\t0x25,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n \n\nISP1362_REG(HCCHIPID,\t0x27,\tREG_WIDTH_16,\tREG_ACCESS_R);\n#define HCCHIPID_MASK\t\t0xff00\n#define HCCHIPID_MAGIC\t\t0x3600\n\nISP1362_REG(HCSCRATCH,\t0x28,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\nISP1362_REG(HCSWRES,\t0x29,\tREG_WIDTH_16,\tREG_ACCESS_W);\n#define HCSWRES_MAGIC\t\t0x00f6\n\nISP1362_REG(HCBUFSTAT,\t0x2c,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n#define HCBUFSTAT_ISTL0_FULL\t(1 << 0)\n#define HCBUFSTAT_ISTL1_FULL\t(1 << 1)\n#define HCBUFSTAT_INTL_ACTIVE\t(1 << 2)\n#define HCBUFSTAT_ATL_ACTIVE\t(1 << 3)\n#define HCBUFSTAT_RESET_HWPP\t(1 << 4)\n#define HCBUFSTAT_ISTL0_ACTIVE\t(1 << 5)\n#define HCBUFSTAT_ISTL1_ACTIVE\t(1 << 6)\n#define HCBUFSTAT_ISTL0_DONE\t(1 << 8)\n#define HCBUFSTAT_ISTL1_DONE\t(1 << 9)\n#define HCBUFSTAT_PAIRED_PTDPP\t(1 << 10)\n\nISP1362_REG(HCDIRADDR,\t0x32,\tREG_WIDTH_32,\tREG_ACCESS_RW);\n#define HCDIRADDR_ADDR_MASK\t0x0000ffff\n#define HCDIRADDR_ADDR(n)\t(((n) << 0) & HCDIRADDR_ADDR_MASK)\n#define HCDIRADDR_COUNT_MASK\t0xffff0000\n#define HCDIRADDR_COUNT(n)\t(((n) << 16) & HCDIRADDR_COUNT_MASK)\nISP1362_REG(HCDIRDATA,\t0x45,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\nISP1362_REG(HCISTLBUFSZ, 0x30,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCISTL0PORT, 0x40,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCISTL1PORT, 0x42,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCISTLRATE,\t0x47,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\nISP1362_REG(HCINTLBUFSZ, 0x33,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCINTLPORT,\t0x43,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCINTLBLKSZ, 0x53,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCINTLDONE,\t0x17,\tREG_WIDTH_32,\tREG_ACCESS_R);\nISP1362_REG(HCINTLSKIP,\t0x18,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCINTLLAST,\t0x19,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCINTLCURR,\t0x1a,\tREG_WIDTH_16,\tREG_ACCESS_R);\n\nISP1362_REG(HCATLBUFSZ, 0x34,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCATLPORT,\t0x44,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCATLBLKSZ, 0x54,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCATLDONE,\t0x1b,\tREG_WIDTH_32,\tREG_ACCESS_R);\nISP1362_REG(HCATLSKIP,\t0x1c,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCATLLAST,\t0x1d,\tREG_WIDTH_32,\tREG_ACCESS_RW);\nISP1362_REG(HCATLCURR,\t0x1e,\tREG_WIDTH_16,\tREG_ACCESS_R);\n\nISP1362_REG(HCATLDTC,\t0x51,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(HCATLDTCTO,\t0x52,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\n\nISP1362_REG(OTGCONTROL,\t0x62,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(OTGSTATUS,\t0x67,\tREG_WIDTH_16,\tREG_ACCESS_R);\nISP1362_REG(OTGINT,\t0x68,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(OTGINTENB,\t0x69,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(OTGTIMER,\t0x6A,\tREG_WIDTH_16,\tREG_ACCESS_RW);\nISP1362_REG(OTGALTTMR,\t0x6C,\tREG_WIDTH_16,\tREG_ACCESS_RW);\n\n \nstruct ptd {\n\tu16 count;\n#define\tPTD_COUNT_MSK\t(0x3ff << 0)\n#define\tPTD_TOGGLE_MSK\t(1 << 10)\n#define\tPTD_ACTIVE_MSK\t(1 << 11)\n#define\tPTD_CC_MSK\t(0xf << 12)\n\tu16 mps;\n#define\tPTD_MPS_MSK\t(0x3ff << 0)\n#define\tPTD_SPD_MSK\t(1 << 10)\n#define\tPTD_LAST_MSK\t(1 << 11)\n#define\tPTD_EP_MSK\t(0xf << 12)\n\tu16 len;\n#define\tPTD_LEN_MSK\t(0x3ff << 0)\n#define\tPTD_DIR_MSK\t(3 << 10)\n#define\tPTD_DIR_SETUP\t(0)\n#define\tPTD_DIR_OUT\t(1)\n#define\tPTD_DIR_IN\t(2)\n\tu16 faddr;\n#define\tPTD_FA_MSK\t(0x7f << 0)\n \n#define PTD_SF_ISO_MSK\t(0xff << 8)\n#define PTD_SF_INT_MSK\t(0x1f << 8)\n#define PTD_PR_MSK\t(0x07 << 13)\n} __attribute__ ((packed, aligned(2)));\n#define PTD_HEADER_SIZE sizeof(struct ptd)\n\n \n \n \n#define PTD_CC_NOERROR      0x00\n#define PTD_CC_CRC          0x01\n#define PTD_CC_BITSTUFFING  0x02\n#define PTD_CC_DATATOGGLEM  0x03\n#define PTD_CC_STALL        0x04\n#define PTD_DEVNOTRESP      0x05\n#define PTD_PIDCHECKFAIL    0x06\n#define PTD_UNEXPECTEDPID   0x07\n#define PTD_DATAOVERRUN     0x08\n#define PTD_DATAUNDERRUN    0x09\n     \n#define PTD_BUFFEROVERRUN   0x0C\n#define PTD_BUFFERUNDERRUN  0x0D\n     \n#define PTD_NOTACCESSED     0x0F\n\n\n \nstatic const int cc_to_error[16] = {\n\t                0,\n\t                -EILSEQ,\n\t                -EPROTO,\n\t                -EILSEQ,\n\t                -EPIPE,\n\t                -ETIMEDOUT,\n\t                -EPROTO,\n\t                -EPROTO,\n\t                -EOVERFLOW,\n\t                -EREMOTEIO,\n\t                -EIO,\n\t                -EIO,\n\t                -ECOMM,\n\t                -ENOSR,\n\t                -EALREADY,\n\t                -EALREADY\n};\n\n\n \n#define OHCI_CTRL_HCFS\t(3 << 6)\t \n#define OHCI_CTRL_RWC\t(1 << 9)\t \n#define OHCI_CTRL_RWE\t(1 << 10)\t \n\n \n#\tdefine OHCI_USB_RESET\t(0 << 6)\n#\tdefine OHCI_USB_RESUME\t(1 << 6)\n#\tdefine OHCI_USB_OPER\t(2 << 6)\n#\tdefine OHCI_USB_SUSPEND\t(3 << 6)\n\n \n#define OHCI_HCR\t(1 << 0)\t \n#define OHCI_SOC  \t(3 << 16)\t \n\n \n#define OHCI_INTR_SO\t(1 << 0)\t \n#define OHCI_INTR_WDH\t(1 << 1)\t \n#define OHCI_INTR_SF\t(1 << 2)\t \n#define OHCI_INTR_RD\t(1 << 3)\t \n#define OHCI_INTR_UE\t(1 << 4)\t \n#define OHCI_INTR_FNO\t(1 << 5)\t \n#define OHCI_INTR_RHSC\t(1 << 6)\t \n#define OHCI_INTR_OC\t(1 << 30)\t \n#define OHCI_INTR_MIE\t(1 << 31)\t \n\n \n#define RH_PS_CCS            0x00000001   \t \n#define RH_PS_PES            0x00000002   \t \n#define RH_PS_PSS            0x00000004   \t \n#define RH_PS_POCI           0x00000008   \t \n#define RH_PS_PRS            0x00000010  \t \n#define RH_PS_PPS            0x00000100   \t \n#define RH_PS_LSDA           0x00000200    \t \n#define RH_PS_CSC            0x00010000 \t \n#define RH_PS_PESC           0x00020000   \t \n#define RH_PS_PSSC           0x00040000    \t \n#define RH_PS_OCIC           0x00080000    \t \n#define RH_PS_PRSC           0x00100000   \t \n\n \n#define RH_HS_LPS\t     0x00000001\t\t \n#define RH_HS_OCI\t     0x00000002\t\t \n#define RH_HS_DRWE\t     0x00008000\t\t \n#define RH_HS_LPSC\t     0x00010000\t\t \n#define RH_HS_OCIC\t     0x00020000\t\t \n#define RH_HS_CRWE\t     0x80000000\t\t \n\n \n#define RH_B_DR\t\t0x0000ffff\t\t \n#define RH_B_PPCM\t0xffff0000\t\t \n\n \n#define\tRH_A_NDP\t(0xff << 0)\t\t \n#define\tRH_A_PSM\t(1 << 8)\t\t \n#define\tRH_A_NPS\t(1 << 9)\t\t \n#define\tRH_A_DT\t\t(1 << 10)\t\t \n#define\tRH_A_OCPM\t(1 << 11)\t\t \n#define\tRH_A_NOCP\t(1 << 12)\t\t \n#define\tRH_A_POTPGT\t(0xff << 24)\t\t \n\n#define\tFI\t\t\t0x2edf\t\t \n#define\tFSMP(fi) \t\t(0x7fff & ((6 * ((fi) - 210)) / 7))\n#define LSTHRESH\t\t0x628\t\t \n\n \n\n \n#define PTD_GET_COUNT(p)\t(((p)->count & PTD_COUNT_MSK) >> 0)\n#define PTD_COUNT(v)\t\t(((v) << 0) & PTD_COUNT_MSK)\n#define PTD_GET_TOGGLE(p)\t(((p)->count & PTD_TOGGLE_MSK) >> 10)\n#define PTD_TOGGLE(v)\t\t(((v) << 10) & PTD_TOGGLE_MSK)\n#define PTD_GET_ACTIVE(p)\t(((p)->count & PTD_ACTIVE_MSK) >> 11)\n#define PTD_ACTIVE(v)\t\t(((v) << 11) & PTD_ACTIVE_MSK)\n#define PTD_GET_CC(p)\t\t(((p)->count & PTD_CC_MSK) >> 12)\n#define PTD_CC(v)\t\t(((v) << 12) & PTD_CC_MSK)\n#define PTD_GET_MPS(p)\t\t(((p)->mps & PTD_MPS_MSK) >> 0)\n#define PTD_MPS(v)\t\t(((v) << 0) & PTD_MPS_MSK)\n#define PTD_GET_SPD(p)\t\t(((p)->mps & PTD_SPD_MSK) >> 10)\n#define PTD_SPD(v)\t\t(((v) << 10) & PTD_SPD_MSK)\n#define PTD_GET_LAST(p)\t\t(((p)->mps & PTD_LAST_MSK) >> 11)\n#define PTD_LAST(v)\t\t(((v) << 11) & PTD_LAST_MSK)\n#define PTD_GET_EP(p)\t\t(((p)->mps & PTD_EP_MSK) >> 12)\n#define PTD_EP(v)\t\t(((v) << 12) & PTD_EP_MSK)\n#define PTD_GET_LEN(p)\t\t(((p)->len & PTD_LEN_MSK) >> 0)\n#define PTD_LEN(v)\t\t(((v) << 0) & PTD_LEN_MSK)\n#define PTD_GET_DIR(p)\t\t(((p)->len & PTD_DIR_MSK) >> 10)\n#define PTD_DIR(v)\t\t(((v) << 10) & PTD_DIR_MSK)\n#define PTD_GET_FA(p)\t\t(((p)->faddr & PTD_FA_MSK) >> 0)\n#define PTD_FA(v)\t\t(((v) << 0) & PTD_FA_MSK)\n#define PTD_GET_SF_INT(p)\t(((p)->faddr & PTD_SF_INT_MSK) >> 8)\n#define PTD_SF_INT(v)\t\t(((v) << 8) & PTD_SF_INT_MSK)\n#define PTD_GET_SF_ISO(p)\t(((p)->faddr & PTD_SF_ISO_MSK) >> 8)\n#define PTD_SF_ISO(v)\t\t(((v) << 8) & PTD_SF_ISO_MSK)\n#define PTD_GET_PR(p)\t\t(((p)->faddr & PTD_PR_MSK) >> 13)\n#define PTD_PR(v)\t\t(((v) << 13) & PTD_PR_MSK)\n\n#define\tLOG2_PERIODIC_SIZE\t5\t \n#define\tPERIODIC_SIZE\t\t(1 << LOG2_PERIODIC_SIZE)\n\nstruct isp1362_ep {\n\tstruct usb_host_endpoint *hep;\n\tstruct usb_device\t*udev;\n\n\t \n\tstruct ptd\t\tptd;\n\n\tu8\t\t\tmaxpacket;\n\tu8\t\t\tepnum;\n\tu8\t\t\tnextpid;\n\tu16\t\t\terror_count;\n\tu16\t\t\tlength;\t\t \n\ts16\t\t\tptd_offset;\t \n\tint\t\t\tptd_index;\n\tint num_ptds;\n\tvoid \t\t\t*data;\t\t \n\t \n\tstruct list_head\tactive;\n\n\t \n\tu8\t\t\tbranch;\n\tu16\t\t\tinterval;\n\tu16\t\t\tload;\n\tu16\t\t\tlast_iso;\n\n\t \n\tstruct list_head\tschedule;\t \n\tstruct list_head\tremove_list;\n\tint\t\t\tnum_req;\n};\n\nstruct isp1362_ep_queue {\n\tstruct list_head\tactive;\t\t \n\tatomic_t\t\tfinishing;\n\tunsigned long\t\tbuf_map;\n\tunsigned long\t\tskip_map;\n\tint\t\t\tfree_ptd;\n\tu16\t\t\tbuf_start;\n\tu16\t\t\tbuf_size;\n\tu16\t\t\tblk_size;\t \n\tu8\t\t\tbuf_count;\n\tu8\t\t\tbuf_avail;\n\tchar\t\t\tname[16];\n\n\t \n\tu8\t\t\tstat_maxptds;\t \n\tu8\t\t\tptd_count;\t \n};\n\nstruct isp1362_hcd {\n\tspinlock_t\t\tlock;\n\tvoid __iomem\t\t*addr_reg;\n\tvoid __iomem\t\t*data_reg;\n\n\tstruct isp1362_platform_data *board;\n\n\tunsigned long\t\tstat1, stat2, stat4, stat8, stat16;\n\n\t \n\tu32\t\t\tintenb;\t\t \n\tu16\t\t\tirqenb;\t\t \n\n\t \n\tu32\t\t\trhdesca;\n\tu32\t\t\trhdescb;\n\tu32\t\t\trhstatus;\n\tu32\t\t\trhport[MAX_ROOT_PORTS];\n\tunsigned long\t\tnext_statechange;\n\n\t \n\tu32\t\t\thc_control;\n\n\t \n\tstruct list_head\tasync;\n\n\t \n\tu16\t\t\tload[PERIODIC_SIZE];\n\tstruct list_head\tperiodic;\n\tu16\t\t\tfmindex;\n\n\t \n\tstruct list_head\tisoc;\n\tunsigned int\t\tistl_flip:1;\n\tunsigned int\t\tirq_active:1;\n\n\t \n\tstruct isp1362_ep_queue atl_queue;\n\tstruct isp1362_ep_queue intl_queue;\n\tstruct isp1362_ep_queue istl_queue[2];\n\n\t \n\tstruct list_head\tremove_list;\n\tenum {\n\t\tISP1362_INT_SOF,\n\t\tISP1362_INT_ISTL0,\n\t\tISP1362_INT_ISTL1,\n\t\tISP1362_INT_EOT,\n\t\tISP1362_INT_OPR,\n\t\tISP1362_INT_SUSP,\n\t\tISP1362_INT_CLKRDY,\n\t\tISP1362_INT_INTL,\n\t\tISP1362_INT_ATL,\n\t\tISP1362_INT_OTG,\n\t\tNUM_ISP1362_IRQS\n\t} IRQ_NAMES;\n\tunsigned int\t\tirq_stat[NUM_ISP1362_IRQS];\n\tint\t\t\treq_serial;\n};\n\nstatic inline const char *ISP1362_INT_NAME(int n)\n{\n\tswitch (n) {\n\tcase ISP1362_INT_SOF:    return \"SOF\";\n\tcase ISP1362_INT_ISTL0:  return \"ISTL0\";\n\tcase ISP1362_INT_ISTL1:  return \"ISTL1\";\n\tcase ISP1362_INT_EOT:    return \"EOT\";\n\tcase ISP1362_INT_OPR:    return \"OPR\";\n\tcase ISP1362_INT_SUSP:   return \"SUSP\";\n\tcase ISP1362_INT_CLKRDY: return \"CLKRDY\";\n\tcase ISP1362_INT_INTL:   return \"INTL\";\n\tcase ISP1362_INT_ATL:    return \"ATL\";\n\tcase ISP1362_INT_OTG:    return \"OTG\";\n\tdefault:                 return \"unknown\";\n\t}\n}\n\nstatic inline void ALIGNSTAT(struct isp1362_hcd *isp1362_hcd, void *ptr)\n{\n\tunsigned long p = (unsigned long)ptr;\n\tif (!(p & 0xf))\n\t\tisp1362_hcd->stat16++;\n\telse if (!(p & 0x7))\n\t\tisp1362_hcd->stat8++;\n\telse if (!(p & 0x3))\n\t\tisp1362_hcd->stat4++;\n\telse if (!(p & 0x1))\n\t\tisp1362_hcd->stat2++;\n\telse\n\t\tisp1362_hcd->stat1++;\n}\n\nstatic inline struct isp1362_hcd *hcd_to_isp1362_hcd(struct usb_hcd *hcd)\n{\n\treturn (struct isp1362_hcd *) (hcd->hcd_priv);\n}\n\nstatic inline struct usb_hcd *isp1362_hcd_to_hcd(struct isp1362_hcd *isp1362_hcd)\n{\n\treturn container_of((void *)isp1362_hcd, struct usb_hcd, hcd_priv);\n}\n\n#define frame_before(f1, f2)\t((s16)((u16)f1 - (u16)f2) < 0)\n\n \n\n#define DBG(level, fmt...) \\\n\tdo { \\\n\t\tif (dbg_level > level) \\\n\t\t\tpr_debug(fmt); \\\n\t} while (0)\n\n#ifdef VERBOSE\n#    define VDBG(fmt...)\tDBG(3, fmt)\n#else\n#    define VDBG(fmt...)\tdo {} while (0)\n#endif\n\n#ifdef REGISTERS\n#    define RDBG(fmt...)\tDBG(1, fmt)\n#else\n#    define RDBG(fmt...)\tdo {} while (0)\n#endif\n\n#ifdef URB_TRACE\n#define URB_DBG(fmt...)\t\tDBG(0, fmt)\n#else\n#define URB_DBG(fmt...)\t\tdo {} while (0)\n#endif\n\n\n#if USE_PLATFORM_DELAY\n#if USE_NDELAY\n#error USE_PLATFORM_DELAY and USE_NDELAY defined simultaneously.\n#endif\n#define\tisp1362_delay(h, d)\t(h)->board->delay(isp1362_hcd_to_hcd(h)->self.controller, d)\n#elif USE_NDELAY\n#define\tisp1362_delay(h, d)\tndelay(d)\n#else\n#define\tisp1362_delay(h, d)\tdo {} while (0)\n#endif\n\n#define get_urb(ep) ({\t\t\t\t\t\t\t\\\n\tBUG_ON(list_empty(&ep->hep->urb_list));\t\t\t\t\\\n\tcontainer_of(ep->hep->urb_list.next, struct urb, urb_list);\t\\\n})\n\n \n \nstatic void isp1362_write_addr(struct isp1362_hcd *isp1362_hcd, isp1362_reg_t reg)\n{\n\tREG_ACCESS_TEST(reg);\n\tDUMMY_DELAY_ACCESS;\n\twritew(ISP1362_REG_NO(reg), isp1362_hcd->addr_reg);\n\tDUMMY_DELAY_ACCESS;\n\tisp1362_delay(isp1362_hcd, 1);\n}\n\nstatic void isp1362_write_data16(struct isp1362_hcd *isp1362_hcd, u16 val)\n{\n\tDUMMY_DELAY_ACCESS;\n\twritew(val, isp1362_hcd->data_reg);\n}\n\nstatic u16 isp1362_read_data16(struct isp1362_hcd *isp1362_hcd)\n{\n\tu16 val;\n\n\tDUMMY_DELAY_ACCESS;\n\tval = readw(isp1362_hcd->data_reg);\n\n\treturn val;\n}\n\nstatic void isp1362_write_data32(struct isp1362_hcd *isp1362_hcd, u32 val)\n{\n#if USE_32BIT\n\tDUMMY_DELAY_ACCESS;\n\twritel(val, isp1362_hcd->data_reg);\n#else\n\tDUMMY_DELAY_ACCESS;\n\twritew((u16)val, isp1362_hcd->data_reg);\n\tDUMMY_DELAY_ACCESS;\n\twritew(val >> 16, isp1362_hcd->data_reg);\n#endif\n}\n\nstatic u32 isp1362_read_data32(struct isp1362_hcd *isp1362_hcd)\n{\n\tu32 val;\n\n#if USE_32BIT\n\tDUMMY_DELAY_ACCESS;\n\tval = readl(isp1362_hcd->data_reg);\n#else\n\tDUMMY_DELAY_ACCESS;\n\tval = (u32)readw(isp1362_hcd->data_reg);\n\tDUMMY_DELAY_ACCESS;\n\tval |= (u32)readw(isp1362_hcd->data_reg) << 16;\n#endif\n\treturn val;\n}\n\n \n \nstatic void isp1362_read_fifo(struct isp1362_hcd *isp1362_hcd, void *buf, u16 len)\n{\n\tu8 *dp = buf;\n\tu16 data;\n\n\tif (!len)\n\t\treturn;\n\n\tRDBG(\"%s: Reading %d byte from fifo to mem @ %p\\n\", __func__, len, buf);\n#if USE_32BIT\n\tif (len >= 4) {\n\t\tRDBG(\"%s: Using readsl for %d dwords\\n\", __func__, len >> 2);\n\t\treadsl(isp1362_hcd->data_reg, dp, len >> 2);\n\t\tdp += len & ~3;\n\t\tlen &= 3;\n\t}\n#endif\n\tif (len >= 2) {\n\t\tRDBG(\"%s: Using readsw for %d words\\n\", __func__, len >> 1);\n\t\tinsw((unsigned long)isp1362_hcd->data_reg, dp, len >> 1);\n\t\tdp += len & ~1;\n\t\tlen &= 1;\n\t}\n\n\tBUG_ON(len & ~1);\n\tif (len > 0) {\n\t\tdata = isp1362_read_data16(isp1362_hcd);\n\t\tRDBG(\"%s: Reading trailing byte %02x to mem @ %08x\\n\", __func__,\n\t\t     (u8)data, (u32)dp);\n\t\t*dp = (u8)data;\n\t}\n}\n\nstatic void isp1362_write_fifo(struct isp1362_hcd *isp1362_hcd, void *buf, u16 len)\n{\n\tu8 *dp = buf;\n\tu16 data;\n\n\tif (!len)\n\t\treturn;\n\n\tif ((unsigned long)dp & 0x1) {\n\t\t \n\t\tfor (; len > 1; len -= 2) {\n\t\t\tdata = *dp++;\n\t\t\tdata |= *dp++ << 8;\n\t\t\tisp1362_write_data16(isp1362_hcd, data);\n\t\t}\n\t\tif (len)\n\t\t\tisp1362_write_data16(isp1362_hcd, *dp);\n\t\treturn;\n\t}\n\n\tRDBG(\"%s: Writing %d byte to fifo from memory @%p\\n\", __func__, len, buf);\n#if USE_32BIT\n\tif (len >= 4) {\n\t\tRDBG(\"%s: Using writesl for %d dwords\\n\", __func__, len >> 2);\n\t\twritesl(isp1362_hcd->data_reg, dp, len >> 2);\n\t\tdp += len & ~3;\n\t\tlen &= 3;\n\t}\n#endif\n\tif (len >= 2) {\n\t\tRDBG(\"%s: Using writesw for %d words\\n\", __func__, len >> 1);\n\t\toutsw((unsigned long)isp1362_hcd->data_reg, dp, len >> 1);\n\t\tdp += len & ~1;\n\t\tlen &= 1;\n\t}\n\n\tBUG_ON(len & ~1);\n\tif (len > 0) {\n\t\t \n\t\tdata = (u16)*dp;\n\t\tRDBG(\"%s: Sending trailing byte %02x from mem @ %08x\\n\", __func__,\n\t\t\tdata, (u32)dp);\n\t\tisp1362_write_data16(isp1362_hcd, data);\n\t}\n}\n\n#define isp1362_read_reg16(d, r)\t\t({\t\t\t\\\n\tu16 __v;\t\t\t\t\t\t\t\\\n\tREG_WIDTH_TEST(ISP1362_REG_##r, REG_WIDTH_16);\t\t\t\\\n\tisp1362_write_addr(d, ISP1362_REG_##r);\t\t\t\t\\\n\t__v = isp1362_read_data16(d);\t\t\t\t\t\\\n\tRDBG(\"%s: Read %04x from %s[%02x]\\n\", __func__, __v, #r,\t\\\n\t     ISP1362_REG_NO(ISP1362_REG_##r));\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#define isp1362_read_reg32(d, r)\t\t({\t\t\t\\\n\tu32 __v;\t\t\t\t\t\t\t\\\n\tREG_WIDTH_TEST(ISP1362_REG_##r, REG_WIDTH_32);\t\t\t\\\n\tisp1362_write_addr(d, ISP1362_REG_##r);\t\t\t\t\\\n\t__v = isp1362_read_data32(d);\t\t\t\t\t\\\n\tRDBG(\"%s: Read %08x from %s[%02x]\\n\", __func__, __v, #r,\t\\\n\t     ISP1362_REG_NO(ISP1362_REG_##r));\t\t\t\t\\\n\t__v;\t\t\t\t\t\t\t\t\\\n})\n\n#define isp1362_write_reg16(d, r, v)\t{\t\t\t\t\t\\\n\tREG_WIDTH_TEST(ISP1362_REG_##r, REG_WIDTH_16);\t\t\t\t\\\n\tisp1362_write_addr(d, (ISP1362_REG_##r) | ISP1362_REG_WRITE_OFFSET);\t\\\n\tisp1362_write_data16(d, (u16)(v));\t\t\t\t\t\\\n\tRDBG(\"%s: Wrote %04x to %s[%02x]\\n\", __func__, (u16)(v), #r,\t\\\n\t     ISP1362_REG_NO(ISP1362_REG_##r));\t\t\t\t\t\\\n}\n\n#define isp1362_write_reg32(d, r, v)\t{\t\t\t\t\t\\\n\tREG_WIDTH_TEST(ISP1362_REG_##r, REG_WIDTH_32);\t\t\t\t\\\n\tisp1362_write_addr(d, (ISP1362_REG_##r) | ISP1362_REG_WRITE_OFFSET);\t\\\n\tisp1362_write_data32(d, (u32)(v));\t\t\t\t\t\\\n\tRDBG(\"%s: Wrote %08x to %s[%02x]\\n\", __func__, (u32)(v), #r,\t\\\n\t     ISP1362_REG_NO(ISP1362_REG_##r));\t\t\t\t\t\\\n}\n\n#define isp1362_set_mask16(d, r, m) {\t\t\t\\\n\tu16 __v;\t\t\t\t\t\\\n\t__v = isp1362_read_reg16(d, r);\t\t\t\\\n\tif ((__v | m) != __v)\t\t\t\t\\\n\t\tisp1362_write_reg16(d, r, __v | m);\t\\\n}\n\n#define isp1362_clr_mask16(d, r, m) {\t\t\t\\\n\tu16 __v;\t\t\t\t\t\\\n\t__v = isp1362_read_reg16(d, r);\t\t\t\\\n\tif ((__v & ~m) != __v)\t\t\t\\\n\t\tisp1362_write_reg16(d, r, __v & ~m);\t\\\n}\n\n#define isp1362_set_mask32(d, r, m) {\t\t\t\\\n\tu32 __v;\t\t\t\t\t\\\n\t__v = isp1362_read_reg32(d, r);\t\t\t\\\n\tif ((__v | m) != __v)\t\t\t\t\\\n\t\tisp1362_write_reg32(d, r, __v | m);\t\\\n}\n\n#define isp1362_clr_mask32(d, r, m) {\t\t\t\\\n\tu32 __v;\t\t\t\t\t\\\n\t__v = isp1362_read_reg32(d, r);\t\t\t\\\n\tif ((__v & ~m) != __v)\t\t\t\\\n\t\tisp1362_write_reg32(d, r, __v & ~m);\t\\\n}\n\n#define isp1362_show_reg(d, r) {\t\t\t\t\t\t\t\t\\\n\tif ((ISP1362_REG_##r & REG_WIDTH_MASK) == REG_WIDTH_32)\t\t\t\\\n\t\tDBG(0, \"%-12s[%02x]: %08x\\n\", #r,\t\t\t\t\t\\\n\t\t\tISP1362_REG_NO(ISP1362_REG_##r), isp1362_read_reg32(d, r));\t\\\n\telse\t\t\t\t\t\t\t\t\t\\\n\t\tDBG(0, \"%-12s[%02x]:     %04x\\n\", #r,\t\t\t\t\t\\\n\t\t\tISP1362_REG_NO(ISP1362_REG_##r), isp1362_read_reg16(d, r));\t\\\n}\n\nstatic void isp1362_write_diraddr(struct isp1362_hcd *isp1362_hcd, u16 offset, u16 len)\n{\n\tlen = (len + 1) & ~1;\n\n\tisp1362_clr_mask16(isp1362_hcd, HCDMACFG, HCDMACFG_CTR_ENABLE);\n\tisp1362_write_reg32(isp1362_hcd, HCDIRADDR,\n\t\t\t    HCDIRADDR_ADDR(offset) | HCDIRADDR_COUNT(len));\n}\n\nstatic void isp1362_read_buffer(struct isp1362_hcd *isp1362_hcd, void *buf, u16 offset, int len)\n{\n\tisp1362_write_diraddr(isp1362_hcd, offset, len);\n\n\tDBG(3, \"%s: Reading %d byte from buffer @%04x to memory @ %p\\n\",\n\t    __func__, len, offset, buf);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_EOT);\n\n\tisp1362_write_addr(isp1362_hcd, ISP1362_REG_HCDIRDATA);\n\n\tisp1362_read_fifo(isp1362_hcd, buf, len);\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_EOT);\n}\n\nstatic void isp1362_write_buffer(struct isp1362_hcd *isp1362_hcd, void *buf, u16 offset, int len)\n{\n\tisp1362_write_diraddr(isp1362_hcd, offset, len);\n\n\tDBG(3, \"%s: Writing %d byte to buffer @%04x from memory @ %p\\n\",\n\t    __func__, len, offset, buf);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_EOT);\n\n\tisp1362_write_addr(isp1362_hcd, ISP1362_REG_HCDIRDATA | ISP1362_REG_WRITE_OFFSET);\n\tisp1362_write_fifo(isp1362_hcd, buf, len);\n\n\tisp1362_write_reg16(isp1362_hcd, HCuPINT, HCuPINT_EOT);\n}\n\nstatic void __attribute__((unused)) dump_data(char *buf, int len)\n{\n\tif (dbg_level > 0) {\n\t\tint k;\n\t\tint lf = 0;\n\n\t\tfor (k = 0; k < len; ++k) {\n\t\t\tif (!lf)\n\t\t\t\tDBG(0, \"%04x:\", k);\n\t\t\tprintk(\" %02x\", ((u8 *) buf)[k]);\n\t\t\tlf = 1;\n\t\t\tif (!k)\n\t\t\t\tcontinue;\n\t\t\tif (k % 16 == 15) {\n\t\t\t\tprintk(\"\\n\");\n\t\t\t\tlf = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (k % 8 == 7)\n\t\t\t\tprintk(\" \");\n\t\t\tif (k % 4 == 3)\n\t\t\t\tprintk(\" \");\n\t\t}\n\t\tif (lf)\n\t\t\tprintk(\"\\n\");\n\t}\n}\n\n#if defined(PTD_TRACE)\n\nstatic void dump_ptd(struct ptd *ptd)\n{\n\tDBG(0, \"EP %p: CC=%x EP=%d DIR=%x CNT=%d LEN=%d MPS=%d TGL=%x ACT=%x FA=%d SPD=%x SF=%x PR=%x LST=%x\\n\",\n\t    container_of(ptd, struct isp1362_ep, ptd),\n\t    PTD_GET_CC(ptd), PTD_GET_EP(ptd), PTD_GET_DIR(ptd),\n\t    PTD_GET_COUNT(ptd), PTD_GET_LEN(ptd), PTD_GET_MPS(ptd),\n\t    PTD_GET_TOGGLE(ptd), PTD_GET_ACTIVE(ptd), PTD_GET_FA(ptd),\n\t    PTD_GET_SPD(ptd), PTD_GET_SF_INT(ptd), PTD_GET_PR(ptd), PTD_GET_LAST(ptd));\n\tDBG(0, \"  %04x %04x %04x %04x\\n\", ptd->count, ptd->mps, ptd->len, ptd->faddr);\n}\n\nstatic void dump_ptd_out_data(struct ptd *ptd, u8 *buf)\n{\n\tif (dbg_level > 0) {\n\t\tif (PTD_GET_DIR(ptd) != PTD_DIR_IN && PTD_GET_LEN(ptd)) {\n\t\t\tDBG(0, \"--out->\\n\");\n\t\t\tdump_data(buf, PTD_GET_LEN(ptd));\n\t\t}\n\t}\n}\n\nstatic void dump_ptd_in_data(struct ptd *ptd, u8 *buf)\n{\n\tif (dbg_level > 0) {\n\t\tif (PTD_GET_DIR(ptd) == PTD_DIR_IN && PTD_GET_COUNT(ptd)) {\n\t\t\tDBG(0, \"<--in--\\n\");\n\t\t\tdump_data(buf, PTD_GET_COUNT(ptd));\n\t\t}\n\t\tDBG(0, \"-----\\n\");\n\t}\n}\n\nstatic void dump_ptd_queue(struct isp1362_ep_queue *epq)\n{\n\tstruct isp1362_ep *ep;\n\tint dbg = dbg_level;\n\n\tdbg_level = 1;\n\tlist_for_each_entry(ep, &epq->active, active) {\n\t\tdump_ptd(&ep->ptd);\n\t\tdump_data(ep->data, ep->length);\n\t}\n\tdbg_level = dbg;\n}\n#else\n#define dump_ptd(ptd)\t\t\tdo {} while (0)\n#define dump_ptd_in_data(ptd, buf)\tdo {} while (0)\n#define dump_ptd_out_data(ptd, buf)\tdo {} while (0)\n#define dump_ptd_data(ptd, buf)\t\tdo {} while (0)\n#define dump_ptd_queue(epq)\t\tdo {} while (0)\n#endif\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}