{
  "module_name": "xhci-mtk-sch.c",
  "hash_id": "1765d6e677aad08e860dbc7891dd9964d2209e6e5f36ca36af27fc4e5b40aec9",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/xhci-mtk-sch.c",
  "human_readable_source": "\n \n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include \"xhci.h\"\n#include \"xhci-mtk.h\"\n\n#define SSP_BW_BOUNDARY\t130000\n#define SS_BW_BOUNDARY\t51000\n \n#define HS_BW_BOUNDARY\t6144\n \n#define FS_PAYLOAD_MAX 188\n\n#define DBG_BUF_EN\t64\n\n \n#define ESCH_SS_Y6\t\t1001\n#define ESCH_SS_OVERLAP\t\t1002\n#define ESCH_CS_OVERFLOW\t1003\n#define ESCH_BW_OVERFLOW\t1004\n#define ESCH_FIXME\t\t1005\n\n \n#define EP_BPKTS(p)\t((p) & 0x7f)\n#define EP_BCSCOUNT(p)\t(((p) & 0x7) << 8)\n#define EP_BBM(p)\t((p) << 11)\n#define EP_BOFFSET(p)\t((p) & 0x3fff)\n#define EP_BREPEAT(p)\t(((p) & 0x7fff) << 16)\n\nstatic char *sch_error_string(int err_num)\n{\n\tswitch (err_num) {\n\tcase ESCH_SS_Y6:\n\t\treturn \"Can't schedule Start-Split in Y6\";\n\tcase ESCH_SS_OVERLAP:\n\t\treturn \"Can't find a suitable Start-Split location\";\n\tcase ESCH_CS_OVERFLOW:\n\t\treturn \"The last Complete-Split is greater than 7\";\n\tcase ESCH_BW_OVERFLOW:\n\t\treturn \"Bandwidth exceeds the maximum limit\";\n\tcase ESCH_FIXME:\n\t\treturn \"FIXME, to be resolved\";\n\tdefault:\n\t\treturn \"Unknown\";\n\t}\n}\n\nstatic int is_fs_or_ls(enum usb_device_speed speed)\n{\n\treturn speed == USB_SPEED_FULL || speed == USB_SPEED_LOW;\n}\n\nstatic const char *\ndecode_ep(struct usb_host_endpoint *ep, enum usb_device_speed speed)\n{\n\tstatic char buf[DBG_BUF_EN];\n\tstruct usb_endpoint_descriptor *epd = &ep->desc;\n\tunsigned int interval;\n\tconst char *unit;\n\n\tinterval = usb_decode_interval(epd, speed);\n\tif (interval % 1000) {\n\t\tunit = \"us\";\n\t} else {\n\t\tunit = \"ms\";\n\t\tinterval /= 1000;\n\t}\n\n\tsnprintf(buf, DBG_BUF_EN, \"%s ep%d%s %s, mpkt:%d, interval:%d/%d%s\",\n\t\t usb_speed_string(speed), usb_endpoint_num(epd),\n\t\t usb_endpoint_dir_in(epd) ? \"in\" : \"out\",\n\t\t usb_ep_type_string(usb_endpoint_type(epd)),\n\t\t usb_endpoint_maxp(epd), epd->bInterval, interval, unit);\n\n\treturn buf;\n}\n\nstatic u32 get_bw_boundary(enum usb_device_speed speed)\n{\n\tu32 boundary;\n\n\tswitch (speed) {\n\tcase USB_SPEED_SUPER_PLUS:\n\t\tboundary = SSP_BW_BOUNDARY;\n\t\tbreak;\n\tcase USB_SPEED_SUPER:\n\t\tboundary = SS_BW_BOUNDARY;\n\t\tbreak;\n\tdefault:\n\t\tboundary = HS_BW_BOUNDARY;\n\t\tbreak;\n\t}\n\n\treturn boundary;\n}\n\n \nstatic struct mu3h_sch_bw_info *\nget_bw_info(struct xhci_hcd_mtk *mtk, struct usb_device *udev,\n\t    struct usb_host_endpoint *ep)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(mtk->hcd);\n\tstruct xhci_virt_device *virt_dev;\n\tint bw_index;\n\n\tvirt_dev = xhci->devs[udev->slot_id];\n\tif (!virt_dev->real_port) {\n\t\tWARN_ONCE(1, \"%s invalid real_port\\n\", dev_name(&udev->dev));\n\t\treturn NULL;\n\t}\n\n\tif (udev->speed >= USB_SPEED_SUPER) {\n\t\tif (usb_endpoint_dir_out(&ep->desc))\n\t\t\tbw_index = (virt_dev->real_port - 1) * 2;\n\t\telse\n\t\t\tbw_index = (virt_dev->real_port - 1) * 2 + 1;\n\t} else {\n\t\t \n\t\tbw_index = virt_dev->real_port + xhci->usb3_rhub.num_ports - 1;\n\t}\n\n\treturn &mtk->sch_array[bw_index];\n}\n\nstatic u32 get_esit(struct xhci_ep_ctx *ep_ctx)\n{\n\tu32 esit;\n\n\tesit = 1 << CTX_TO_EP_INTERVAL(le32_to_cpu(ep_ctx->ep_info));\n\tif (esit > XHCI_MTK_MAX_ESIT)\n\t\tesit = XHCI_MTK_MAX_ESIT;\n\n\treturn esit;\n}\n\nstatic struct mu3h_sch_tt *find_tt(struct usb_device *udev)\n{\n\tstruct usb_tt *utt = udev->tt;\n\tstruct mu3h_sch_tt *tt, **tt_index, **ptt;\n\tbool allocated_index = false;\n\n\tif (!utt)\n\t\treturn NULL;\t \n\n\t \n\ttt_index = NULL;\n\tif (utt->multi) {\n\t\ttt_index = utt->hcpriv;\n\t\tif (!tt_index) {\t \n\t\t\ttt_index = kcalloc(utt->hub->maxchild,\n\t\t\t\t\tsizeof(*tt_index), GFP_KERNEL);\n\t\t\tif (!tt_index)\n\t\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t\tutt->hcpriv = tt_index;\n\t\t\tallocated_index = true;\n\t\t}\n\t\tptt = &tt_index[udev->ttport - 1];\n\t} else {\n\t\tptt = (struct mu3h_sch_tt **) &utt->hcpriv;\n\t}\n\n\ttt = *ptt;\n\tif (!tt) {\t \n\t\ttt = kzalloc(sizeof(*tt), GFP_KERNEL);\n\t\tif (!tt) {\n\t\t\tif (allocated_index) {\n\t\t\t\tutt->hcpriv = NULL;\n\t\t\t\tkfree(tt_index);\n\t\t\t}\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t\tINIT_LIST_HEAD(&tt->ep_list);\n\t\t*ptt = tt;\n\t}\n\n\treturn tt;\n}\n\n \nstatic void drop_tt(struct usb_device *udev)\n{\n\tstruct usb_tt *utt = udev->tt;\n\tstruct mu3h_sch_tt *tt, **tt_index, **ptt;\n\tint i, cnt;\n\n\tif (!utt || !utt->hcpriv)\n\t\treturn;\t\t \n\n\tcnt = 0;\n\tif (utt->multi) {\n\t\ttt_index = utt->hcpriv;\n\t\tptt = &tt_index[udev->ttport - 1];\n\t\t \n\t\tfor (i = 0; i < utt->hub->maxchild; ++i)\n\t\t\tcnt += !!tt_index[i];\n\t} else {\n\t\ttt_index = NULL;\n\t\tptt = (struct mu3h_sch_tt **)&utt->hcpriv;\n\t}\n\n\ttt = *ptt;\n\tif (!tt || !list_empty(&tt->ep_list))\n\t\treturn;\t\t \n\n\t*ptt = NULL;\n\tkfree(tt);\n\n\tif (cnt == 1) {\n\t\tutt->hcpriv = NULL;\n\t\tkfree(tt_index);\n\t}\n}\n\nstatic struct mu3h_sch_ep_info *\ncreate_sch_ep(struct xhci_hcd_mtk *mtk, struct usb_device *udev,\n\t      struct usb_host_endpoint *ep)\n{\n\tstruct mu3h_sch_ep_info *sch_ep;\n\tstruct mu3h_sch_bw_info *bw_info;\n\tstruct mu3h_sch_tt *tt = NULL;\n\n\tbw_info = get_bw_info(mtk, udev, ep);\n\tif (!bw_info)\n\t\treturn ERR_PTR(-ENODEV);\n\n\tsch_ep = kzalloc(sizeof(*sch_ep), GFP_KERNEL);\n\tif (!sch_ep)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (is_fs_or_ls(udev->speed)) {\n\t\ttt = find_tt(udev);\n\t\tif (IS_ERR(tt)) {\n\t\t\tkfree(sch_ep);\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\t}\n\t}\n\n\tsch_ep->bw_info = bw_info;\n\tsch_ep->sch_tt = tt;\n\tsch_ep->ep = ep;\n\tsch_ep->speed = udev->speed;\n\tINIT_LIST_HEAD(&sch_ep->endpoint);\n\tINIT_LIST_HEAD(&sch_ep->tt_endpoint);\n\tINIT_HLIST_NODE(&sch_ep->hentry);\n\n\treturn sch_ep;\n}\n\nstatic void setup_sch_info(struct xhci_ep_ctx *ep_ctx,\n\t\t\t   struct mu3h_sch_ep_info *sch_ep)\n{\n\tu32 ep_type;\n\tu32 maxpkt;\n\tu32 max_burst;\n\tu32 mult;\n\tu32 esit_pkts;\n\tu32 max_esit_payload;\n\n\tep_type = CTX_TO_EP_TYPE(le32_to_cpu(ep_ctx->ep_info2));\n\tmaxpkt = MAX_PACKET_DECODED(le32_to_cpu(ep_ctx->ep_info2));\n\tmax_burst = CTX_TO_MAX_BURST(le32_to_cpu(ep_ctx->ep_info2));\n\tmult = CTX_TO_EP_MULT(le32_to_cpu(ep_ctx->ep_info));\n\tmax_esit_payload =\n\t\t(CTX_TO_MAX_ESIT_PAYLOAD_HI(\n\t\t\tle32_to_cpu(ep_ctx->ep_info)) << 16) |\n\t\t CTX_TO_MAX_ESIT_PAYLOAD(le32_to_cpu(ep_ctx->tx_info));\n\n\tsch_ep->esit = get_esit(ep_ctx);\n\tsch_ep->num_esit = XHCI_MTK_MAX_ESIT / sch_ep->esit;\n\tsch_ep->ep_type = ep_type;\n\tsch_ep->maxpkt = maxpkt;\n\tsch_ep->offset = 0;\n\tsch_ep->burst_mode = 0;\n\tsch_ep->repeat = 0;\n\n\tif (sch_ep->speed == USB_SPEED_HIGH) {\n\t\tsch_ep->cs_count = 0;\n\n\t\t \n\t\tsch_ep->num_budget_microframes = 1;\n\n\t\t \n\t\tsch_ep->pkts = max_burst + 1;\n\t\tsch_ep->bw_cost_per_microframe = maxpkt * sch_ep->pkts;\n\t} else if (sch_ep->speed >= USB_SPEED_SUPER) {\n\t\t \n\t\tsch_ep->cs_count = 0;\n\t\tsch_ep->burst_mode = 1;\n\t\t \n\t\tesit_pkts = DIV_ROUND_UP(max_esit_payload, maxpkt);\n\t\tif (esit_pkts == 0)\n\t\t\tesit_pkts = (mult + 1) * (max_burst + 1);\n\n\t\tif (ep_type == INT_IN_EP || ep_type == INT_OUT_EP) {\n\t\t\tsch_ep->pkts = esit_pkts;\n\t\t\tsch_ep->num_budget_microframes = 1;\n\t\t}\n\n\t\tif (ep_type == ISOC_IN_EP || ep_type == ISOC_OUT_EP) {\n\n\t\t\tif (sch_ep->esit == 1)\n\t\t\t\tsch_ep->pkts = esit_pkts;\n\t\t\telse if (esit_pkts <= sch_ep->esit)\n\t\t\t\tsch_ep->pkts = 1;\n\t\t\telse\n\t\t\t\tsch_ep->pkts = roundup_pow_of_two(esit_pkts)\n\t\t\t\t\t/ sch_ep->esit;\n\n\t\t\tsch_ep->num_budget_microframes =\n\t\t\t\tDIV_ROUND_UP(esit_pkts, sch_ep->pkts);\n\n\t\t\tsch_ep->repeat = !!(sch_ep->num_budget_microframes > 1);\n\t\t}\n\t\tsch_ep->bw_cost_per_microframe = maxpkt * sch_ep->pkts;\n\t} else if (is_fs_or_ls(sch_ep->speed)) {\n\t\tsch_ep->pkts = 1;  \n\n\t\t \n\t\tsch_ep->cs_count = DIV_ROUND_UP(maxpkt, FS_PAYLOAD_MAX);\n\t\tsch_ep->num_budget_microframes = sch_ep->cs_count;\n\t\tsch_ep->bw_cost_per_microframe = min_t(u32, maxpkt, FS_PAYLOAD_MAX);\n\t}\n}\n\n \nstatic u32 get_max_bw(struct mu3h_sch_bw_info *sch_bw,\n\tstruct mu3h_sch_ep_info *sch_ep, u32 offset)\n{\n\tu32 max_bw = 0;\n\tu32 bw;\n\tint i, j, k;\n\n\tfor (i = 0; i < sch_ep->num_esit; i++) {\n\t\tu32 base = offset + i * sch_ep->esit;\n\n\t\tfor (j = 0; j < sch_ep->num_budget_microframes; j++) {\n\t\t\tk = XHCI_MTK_BW_INDEX(base + j);\n\t\t\tbw = sch_bw->bus_bw[k] + sch_ep->bw_cost_per_microframe;\n\t\t\tif (bw > max_bw)\n\t\t\t\tmax_bw = bw;\n\t\t}\n\t}\n\treturn max_bw;\n}\n\nstatic void update_bus_bw(struct mu3h_sch_bw_info *sch_bw,\n\tstruct mu3h_sch_ep_info *sch_ep, bool used)\n{\n\tint bw_updated;\n\tu32 base;\n\tint i, j;\n\n\tbw_updated = sch_ep->bw_cost_per_microframe * (used ? 1 : -1);\n\n\tfor (i = 0; i < sch_ep->num_esit; i++) {\n\t\tbase = sch_ep->offset + i * sch_ep->esit;\n\t\tfor (j = 0; j < sch_ep->num_budget_microframes; j++)\n\t\t\tsch_bw->bus_bw[XHCI_MTK_BW_INDEX(base + j)] += bw_updated;\n\t}\n}\n\nstatic int check_fs_bus_bw(struct mu3h_sch_ep_info *sch_ep, int offset)\n{\n\tstruct mu3h_sch_tt *tt = sch_ep->sch_tt;\n\tu32 tmp;\n\tint base;\n\tint i, j, k;\n\n\tfor (i = 0; i < sch_ep->num_esit; i++) {\n\t\tbase = offset + i * sch_ep->esit;\n\n\t\t \n\t\tfor (j = 0; j < sch_ep->num_budget_microframes; j++) {\n\t\t\tk = XHCI_MTK_BW_INDEX(base + j);\n\t\t\ttmp = tt->fs_bus_bw[k] + sch_ep->bw_cost_per_microframe;\n\t\t\tif (tmp > FS_PAYLOAD_MAX)\n\t\t\t\treturn -ESCH_BW_OVERFLOW;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int check_sch_tt(struct mu3h_sch_ep_info *sch_ep, u32 offset)\n{\n\tu32 start_ss, last_ss;\n\tu32 start_cs, last_cs;\n\n\tif (!sch_ep->sch_tt)\n\t\treturn 0;\n\n\tstart_ss = offset % 8;\n\n\tif (sch_ep->ep_type == ISOC_OUT_EP) {\n\t\tlast_ss = start_ss + sch_ep->cs_count - 1;\n\n\t\t \n\t\tif (!(start_ss == 7 || last_ss < 6))\n\t\t\treturn -ESCH_SS_Y6;\n\n\t} else {\n\t\tu32 cs_count = DIV_ROUND_UP(sch_ep->maxpkt, FS_PAYLOAD_MAX);\n\n\t\t \n\t\tif (start_ss == 6)\n\t\t\treturn -ESCH_SS_Y6;\n\n\t\t \n\t\tstart_cs = (start_ss + 2) % 8;\n\t\tlast_cs = start_cs + cs_count - 1;\n\n\t\tif (last_cs > 7)\n\t\t\treturn -ESCH_CS_OVERFLOW;\n\n\t\tif (cs_count > 7)\n\t\t\tcs_count = 7;  \n\n\t\tsch_ep->cs_count = cs_count;\n\t\t \n\t\tsch_ep->num_budget_microframes = cs_count;\n\n\t\t \n\t\tif (sch_ep->num_budget_microframes > sch_ep->esit)\n\t\t\tsch_ep->num_budget_microframes = sch_ep->esit;\n\t}\n\n\treturn check_fs_bus_bw(sch_ep, offset);\n}\n\nstatic void update_sch_tt(struct mu3h_sch_ep_info *sch_ep, bool used)\n{\n\tstruct mu3h_sch_tt *tt = sch_ep->sch_tt;\n\tint bw_updated;\n\tu32 base;\n\tint i, j;\n\n\tbw_updated = sch_ep->bw_cost_per_microframe * (used ? 1 : -1);\n\n\tfor (i = 0; i < sch_ep->num_esit; i++) {\n\t\tbase = sch_ep->offset + i * sch_ep->esit;\n\n\t\tfor (j = 0; j < sch_ep->num_budget_microframes; j++)\n\t\t\ttt->fs_bus_bw[XHCI_MTK_BW_INDEX(base + j)] += bw_updated;\n\t}\n\n\tif (used)\n\t\tlist_add_tail(&sch_ep->tt_endpoint, &tt->ep_list);\n\telse\n\t\tlist_del(&sch_ep->tt_endpoint);\n}\n\nstatic int load_ep_bw(struct mu3h_sch_bw_info *sch_bw,\n\t\t      struct mu3h_sch_ep_info *sch_ep, bool loaded)\n{\n\tif (sch_ep->sch_tt)\n\t\tupdate_sch_tt(sch_ep, loaded);\n\n\t \n\tupdate_bus_bw(sch_bw, sch_ep, loaded);\n\tsch_ep->allocated = loaded;\n\n\treturn 0;\n}\n\nstatic int check_sch_bw(struct mu3h_sch_ep_info *sch_ep)\n{\n\tstruct mu3h_sch_bw_info *sch_bw = sch_ep->bw_info;\n\tconst u32 bw_boundary = get_bw_boundary(sch_ep->speed);\n\tu32 offset;\n\tu32 worst_bw;\n\tu32 min_bw = ~0;\n\tint min_index = -1;\n\tint ret = 0;\n\n\t \n\tfor (offset = 0; offset < sch_ep->esit; offset++) {\n\t\tret = check_sch_tt(sch_ep, offset);\n\t\tif (ret)\n\t\t\tcontinue;\n\n\t\tworst_bw = get_max_bw(sch_bw, sch_ep, offset);\n\t\tif (worst_bw > bw_boundary)\n\t\t\tcontinue;\n\n\t\tif (min_bw > worst_bw) {\n\t\t\tmin_bw = worst_bw;\n\t\t\tmin_index = offset;\n\t\t}\n\n\t\t \n\t\tif (sch_ep->sch_tt && min_index >= 0)\n\t\t\tbreak;\n\n\t\tif (min_bw == 0)\n\t\t\tbreak;\n\t}\n\n\tif (min_index < 0)\n\t\treturn ret ? ret : -ESCH_BW_OVERFLOW;\n\n\tsch_ep->offset = min_index;\n\n\treturn load_ep_bw(sch_bw, sch_ep, true);\n}\n\nstatic void destroy_sch_ep(struct xhci_hcd_mtk *mtk, struct usb_device *udev,\n\t\t\t   struct mu3h_sch_ep_info *sch_ep)\n{\n\t \n\tif (sch_ep->allocated)\n\t\tload_ep_bw(sch_ep->bw_info, sch_ep, false);\n\n\tif (sch_ep->sch_tt)\n\t\tdrop_tt(udev);\n\n\tlist_del(&sch_ep->endpoint);\n\thlist_del(&sch_ep->hentry);\n\tkfree(sch_ep);\n}\n\nstatic bool need_bw_sch(struct usb_device *udev,\n\t\t\tstruct usb_host_endpoint *ep)\n{\n\tbool has_tt = udev->tt && udev->tt->hub->parent;\n\n\t \n\tif (usb_endpoint_xfer_control(&ep->desc)\n\t\t|| usb_endpoint_xfer_bulk(&ep->desc))\n\t\treturn false;\n\n\t \n\tif (is_fs_or_ls(udev->speed) && !has_tt)\n\t\treturn false;\n\n\t \n\tif (usb_endpoint_maxp(&ep->desc) == 0)\n\t\treturn false;\n\n\treturn true;\n}\n\nint xhci_mtk_sch_init(struct xhci_hcd_mtk *mtk)\n{\n\tstruct xhci_hcd *xhci = hcd_to_xhci(mtk->hcd);\n\tstruct mu3h_sch_bw_info *sch_array;\n\tint num_usb_bus;\n\n\t \n\tnum_usb_bus = xhci->usb3_rhub.num_ports * 2 + xhci->usb2_rhub.num_ports;\n\n\tsch_array = kcalloc(num_usb_bus, sizeof(*sch_array), GFP_KERNEL);\n\tif (sch_array == NULL)\n\t\treturn -ENOMEM;\n\n\tmtk->sch_array = sch_array;\n\n\tINIT_LIST_HEAD(&mtk->bw_ep_chk_list);\n\thash_init(mtk->sch_ep_hash);\n\n\treturn 0;\n}\n\nvoid xhci_mtk_sch_exit(struct xhci_hcd_mtk *mtk)\n{\n\tkfree(mtk->sch_array);\n}\n\nstatic int add_ep_quirk(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t\tstruct usb_host_endpoint *ep)\n{\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct xhci_ep_ctx *ep_ctx;\n\tstruct xhci_virt_device *virt_dev;\n\tstruct mu3h_sch_ep_info *sch_ep;\n\tunsigned int ep_index;\n\n\tvirt_dev = xhci->devs[udev->slot_id];\n\tep_index = xhci_get_endpoint_index(&ep->desc);\n\tep_ctx = xhci_get_ep_ctx(xhci, virt_dev->in_ctx, ep_index);\n\n\tif (!need_bw_sch(udev, ep)) {\n\t\t \n\t\tif (usb_endpoint_xfer_int(&ep->desc)\n\t\t\t|| usb_endpoint_xfer_isoc(&ep->desc))\n\t\t\tep_ctx->reserved[0] = cpu_to_le32(EP_BPKTS(1));\n\n\t\treturn 0;\n\t}\n\n\txhci_dbg(xhci, \"%s %s\\n\", __func__, decode_ep(ep, udev->speed));\n\n\tsch_ep = create_sch_ep(mtk, udev, ep);\n\tif (IS_ERR_OR_NULL(sch_ep))\n\t\treturn -ENOMEM;\n\n\tsetup_sch_info(ep_ctx, sch_ep);\n\n\tlist_add_tail(&sch_ep->endpoint, &mtk->bw_ep_chk_list);\n\thash_add(mtk->sch_ep_hash, &sch_ep->hentry, (unsigned long)ep);\n\n\treturn 0;\n}\n\nstatic void drop_ep_quirk(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t\t  struct usb_host_endpoint *ep)\n{\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct mu3h_sch_ep_info *sch_ep;\n\tstruct hlist_node *hn;\n\n\tif (!need_bw_sch(udev, ep))\n\t\treturn;\n\n\txhci_dbg(xhci, \"%s %s\\n\", __func__, decode_ep(ep, udev->speed));\n\n\thash_for_each_possible_safe(mtk->sch_ep_hash, sch_ep,\n\t\t\t\t    hn, hentry, (unsigned long)ep) {\n\t\tif (sch_ep->ep == ep) {\n\t\t\tdestroy_sch_ep(mtk, udev, sch_ep);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint xhci_mtk_check_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)\n{\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct xhci_virt_device *virt_dev = xhci->devs[udev->slot_id];\n\tstruct mu3h_sch_ep_info *sch_ep;\n\tint ret;\n\n\txhci_dbg(xhci, \"%s() udev %s\\n\", __func__, dev_name(&udev->dev));\n\n\tlist_for_each_entry(sch_ep, &mtk->bw_ep_chk_list, endpoint) {\n\t\tstruct xhci_ep_ctx *ep_ctx;\n\t\tstruct usb_host_endpoint *ep = sch_ep->ep;\n\t\tunsigned int ep_index = xhci_get_endpoint_index(&ep->desc);\n\n\t\tret = check_sch_bw(sch_ep);\n\t\tif (ret) {\n\t\t\txhci_err(xhci, \"Not enough bandwidth! (%s)\\n\",\n\t\t\t\t sch_error_string(-ret));\n\t\t\treturn -ENOSPC;\n\t\t}\n\n\t\tep_ctx = xhci_get_ep_ctx(xhci, virt_dev->in_ctx, ep_index);\n\t\tep_ctx->reserved[0] = cpu_to_le32(EP_BPKTS(sch_ep->pkts)\n\t\t\t| EP_BCSCOUNT(sch_ep->cs_count)\n\t\t\t| EP_BBM(sch_ep->burst_mode));\n\t\tep_ctx->reserved[1] = cpu_to_le32(EP_BOFFSET(sch_ep->offset)\n\t\t\t| EP_BREPEAT(sch_ep->repeat));\n\n\t\txhci_dbg(xhci, \" PKTS:%x, CSCOUNT:%x, BM:%x, OFFSET:%x, REPEAT:%x\\n\",\n\t\t\tsch_ep->pkts, sch_ep->cs_count, sch_ep->burst_mode,\n\t\t\tsch_ep->offset, sch_ep->repeat);\n\t}\n\n\tret = xhci_check_bandwidth(hcd, udev);\n\tif (!ret)\n\t\tlist_del_init(&mtk->bw_ep_chk_list);\n\n\treturn ret;\n}\n\nvoid xhci_mtk_reset_bandwidth(struct usb_hcd *hcd, struct usb_device *udev)\n{\n\tstruct xhci_hcd_mtk *mtk = hcd_to_mtk(hcd);\n\tstruct xhci_hcd *xhci = hcd_to_xhci(hcd);\n\tstruct mu3h_sch_ep_info *sch_ep, *tmp;\n\n\txhci_dbg(xhci, \"%s() udev %s\\n\", __func__, dev_name(&udev->dev));\n\n\tlist_for_each_entry_safe(sch_ep, tmp, &mtk->bw_ep_chk_list, endpoint)\n\t\tdestroy_sch_ep(mtk, udev, sch_ep);\n\n\txhci_reset_bandwidth(hcd, udev);\n}\n\nint xhci_mtk_add_ep(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t    struct usb_host_endpoint *ep)\n{\n\tint ret;\n\n\tret = xhci_add_endpoint(hcd, udev, ep);\n\tif (ret)\n\t\treturn ret;\n\n\tif (ep->hcpriv)\n\t\tret = add_ep_quirk(hcd, udev, ep);\n\n\treturn ret;\n}\n\nint xhci_mtk_drop_ep(struct usb_hcd *hcd, struct usb_device *udev,\n\t\t     struct usb_host_endpoint *ep)\n{\n\tint ret;\n\n\tret = xhci_drop_endpoint(hcd, udev, ep);\n\tif (ret)\n\t\treturn ret;\n\n\t \n\tdrop_ep_quirk(hcd, udev, ep);\n\n\treturn 0;\n}\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}