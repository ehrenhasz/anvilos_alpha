{
  "module_name": "uhci-hcd.c",
  "hash_id": "bb203c82073224cd58596e492cd0692268cdff53c588c47c40061db521423070",
  "original_prompt": "Ingested from linux-6.6.14/drivers/usb/host/uhci-hcd.c",
  "human_readable_source": "\n \n\n#include <linux/module.h>\n#include <linux/pci.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/delay.h>\n#include <linux/ioport.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/unistd.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/debugfs.h>\n#include <linux/pm.h>\n#include <linux/dmapool.h>\n#include <linux/dma-mapping.h>\n#include <linux/usb.h>\n#include <linux/usb/hcd.h>\n#include <linux/bitops.h>\n#include <linux/dmi.h>\n\n#include <linux/uaccess.h>\n#include <asm/io.h>\n#include <asm/irq.h>\n\n#include \"uhci-hcd.h\"\n\n \n#define DRIVER_AUTHOR\t\t\t\t\t\t\t\\\n\t\"Linus 'Frodo Rabbit' Torvalds, Johannes Erdfelt, \"\t\t\\\n\t\"Randy Dunlap, Georg Acher, Deti Fliegl, Thomas Sailer, \"\t\\\n\t\"Roman Weissgaerber, Alan Stern\"\n#define DRIVER_DESC \"USB Universal Host Controller Interface driver\"\n\n \nstatic bool ignore_oc;\nmodule_param(ignore_oc, bool, S_IRUGO);\nMODULE_PARM_DESC(ignore_oc, \"ignore hardware overcurrent indications\");\n\n \n#ifdef CONFIG_DYNAMIC_DEBUG\n\nstatic int debug = 1;\nmodule_param(debug, int, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(debug, \"Debug level\");\nstatic char *errbuf;\n\n#else\n\n#define debug 0\n#define errbuf NULL\n\n#endif\n\n\n#define ERRBUF_LEN    (32 * 1024)\n\nstatic struct kmem_cache *uhci_up_cachep;\t \n\nstatic void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state);\nstatic void wakeup_rh(struct uhci_hcd *uhci);\nstatic void uhci_get_current_frame_number(struct uhci_hcd *uhci);\n\n \nstatic __hc32 uhci_frame_skel_link(struct uhci_hcd *uhci, int frame)\n{\n\tint skelnum;\n\n\t \n\tskelnum = 8 - (int) __ffs(frame | UHCI_NUMFRAMES);\n\tif (skelnum <= 1)\n\t\tskelnum = 9;\n\treturn LINK_TO_QH(uhci, uhci->skelqh[skelnum]);\n}\n\n#include \"uhci-debug.c\"\n#include \"uhci-q.c\"\n#include \"uhci-hub.c\"\n\n \nstatic void finish_reset(struct uhci_hcd *uhci)\n{\n\tint port;\n\n\t \n\tfor (port = 0; port < uhci->rh_numports; ++port)\n\t\tuhci_writew(uhci, 0, USBPORTSC1 + (port * 2));\n\n\tuhci->port_c_suspend = uhci->resuming_ports = 0;\n\tuhci->rh_state = UHCI_RH_RESET;\n\tuhci->is_stopped = UHCI_IS_STOPPED;\n\tclear_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\n}\n\n \nstatic void uhci_hc_died(struct uhci_hcd *uhci)\n{\n\tuhci_get_current_frame_number(uhci);\n\tuhci->reset_hc(uhci);\n\tfinish_reset(uhci);\n\tuhci->dead = 1;\n\n\t \n\t++uhci->frame_number;\n}\n\n \nstatic void check_and_reset_hc(struct uhci_hcd *uhci)\n{\n\tif (uhci->check_and_reset_hc(uhci))\n\t\tfinish_reset(uhci);\n}\n\n#if defined(CONFIG_USB_UHCI_SUPPORT_NON_PCI_HC)\n \n\n \nstatic void uhci_generic_reset_hc(struct uhci_hcd *uhci)\n{\n\t \n\tuhci_writew(uhci, USBCMD_HCRESET, USBCMD);\n\tmb();\n\tudelay(5);\n\tif (uhci_readw(uhci, USBCMD) & USBCMD_HCRESET)\n\t\tdev_warn(uhci_dev(uhci), \"HCRESET not completed yet!\\n\");\n\n\t \n\tuhci_writew(uhci, 0, USBINTR);\n\tuhci_writew(uhci, 0, USBCMD);\n}\n\n \nstatic int uhci_generic_check_and_reset_hc(struct uhci_hcd *uhci)\n{\n\tunsigned int cmd, intr;\n\n\t \n\n\tcmd = uhci_readw(uhci, USBCMD);\n\tif ((cmd & USBCMD_RS) || !(cmd & USBCMD_CF) || !(cmd & USBCMD_EGSM)) {\n\t\tdev_dbg(uhci_dev(uhci), \"%s: cmd = 0x%04x\\n\",\n\t\t\t\t__func__, cmd);\n\t\tgoto reset_needed;\n\t}\n\n\tintr = uhci_readw(uhci, USBINTR);\n\tif (intr & (~USBINTR_RESUME)) {\n\t\tdev_dbg(uhci_dev(uhci), \"%s: intr = 0x%04x\\n\",\n\t\t\t\t__func__, intr);\n\t\tgoto reset_needed;\n\t}\n\treturn 0;\n\nreset_needed:\n\tdev_dbg(uhci_dev(uhci), \"Performing full reset\\n\");\n\tuhci_generic_reset_hc(uhci);\n\treturn 1;\n}\n#endif  \n\n \nstatic void configure_hc(struct uhci_hcd *uhci)\n{\n\t \n\tuhci_writeb(uhci, USBSOF_DEFAULT, USBSOF);\n\n\t \n\tuhci_writel(uhci, uhci->frame_dma_handle, USBFLBASEADD);\n\n\t \n\tuhci_writew(uhci, uhci->frame_number & UHCI_MAX_SOF_NUMBER,\n\t\t\tUSBFRNUM);\n\n\t \n\tif (uhci->configure_hc)\n\t\tuhci->configure_hc(uhci);\n}\n\nstatic int resume_detect_interrupts_are_broken(struct uhci_hcd *uhci)\n{\n\t \n\tif (ignore_oc || uhci_is_aspeed(uhci))\n\t\treturn 1;\n\n\treturn uhci->resume_detect_interrupts_are_broken ?\n\t\tuhci->resume_detect_interrupts_are_broken(uhci) : 0;\n}\n\nstatic int global_suspend_mode_is_broken(struct uhci_hcd *uhci)\n{\n\treturn uhci->global_suspend_mode_is_broken ?\n\t\tuhci->global_suspend_mode_is_broken(uhci) : 0;\n}\n\nstatic void suspend_rh(struct uhci_hcd *uhci, enum uhci_rh_state new_state)\n__releases(uhci->lock)\n__acquires(uhci->lock)\n{\n\tint auto_stop;\n\tint int_enable, egsm_enable, wakeup_enable;\n\tstruct usb_device *rhdev = uhci_to_hcd(uhci)->self.root_hub;\n\n\tauto_stop = (new_state == UHCI_RH_AUTO_STOPPED);\n\tdev_dbg(&rhdev->dev, \"%s%s\\n\", __func__,\n\t\t\t(auto_stop ? \" (auto-stop)\" : \"\"));\n\n\t \n\tegsm_enable = USBCMD_EGSM;\n\tint_enable = USBINTR_RESUME;\n\twakeup_enable = 1;\n\n\t \n\tif (auto_stop) {\n\t\tif (!device_may_wakeup(&rhdev->dev))\n\t\t\tegsm_enable = int_enable = 0;\n\t}\n\n#ifdef CONFIG_PM\n\t \n\telse {\n\t\tif (!rhdev->do_remote_wakeup)\n\t\t\twakeup_enable = 0;\n\t}\n#endif\n\n\t \n\tif (!wakeup_enable || global_suspend_mode_is_broken(uhci) ||\n\t\t\tresume_detect_interrupts_are_broken(uhci))\n\t\tegsm_enable = int_enable = 0;\n\n\tuhci->RD_enable = !!int_enable;\n\tuhci_writew(uhci, int_enable, USBINTR);\n\tuhci_writew(uhci, egsm_enable | USBCMD_CF, USBCMD);\n\tmb();\n\tudelay(5);\n\n\t \n\tif (!auto_stop && !(uhci_readw(uhci, USBSTS) & USBSTS_HCH)) {\n\t\tuhci->rh_state = UHCI_RH_SUSPENDING;\n\t\tspin_unlock_irq(&uhci->lock);\n\t\tmsleep(1);\n\t\tspin_lock_irq(&uhci->lock);\n\t\tif (uhci->dead)\n\t\t\treturn;\n\t}\n\tif (!(uhci_readw(uhci, USBSTS) & USBSTS_HCH))\n\t\tdev_warn(uhci_dev(uhci), \"Controller not stopped yet!\\n\");\n\n\tuhci_get_current_frame_number(uhci);\n\n\tuhci->rh_state = new_state;\n\tuhci->is_stopped = UHCI_IS_STOPPED;\n\n\t \n\tif (wakeup_enable && (!int_enable || !egsm_enable))\n\t\tset_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\n\telse\n\t\tclear_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\n\n\tuhci_scan_schedule(uhci);\n\tuhci_fsbr_off(uhci);\n}\n\nstatic void start_rh(struct uhci_hcd *uhci)\n{\n\tuhci->is_stopped = 0;\n\n\t \n\tif (uhci_is_aspeed(uhci))\n\t\tuhci_writew(uhci, uhci_readw(uhci, USBSTS), USBSTS);\n\n\t \n\tuhci_writew(uhci, USBCMD_RS | USBCMD_CF | USBCMD_MAXP, USBCMD);\n\tuhci_writew(uhci, USBINTR_TIMEOUT | USBINTR_RESUME |\n\t\tUSBINTR_IOC | USBINTR_SP, USBINTR);\n\tmb();\n\tuhci->rh_state = UHCI_RH_RUNNING;\n\tset_bit(HCD_FLAG_POLL_RH, &uhci_to_hcd(uhci)->flags);\n}\n\nstatic void wakeup_rh(struct uhci_hcd *uhci)\n__releases(uhci->lock)\n__acquires(uhci->lock)\n{\n\tdev_dbg(&uhci_to_hcd(uhci)->self.root_hub->dev,\n\t\t\t\"%s%s\\n\", __func__,\n\t\t\tuhci->rh_state == UHCI_RH_AUTO_STOPPED ?\n\t\t\t\t\" (auto-start)\" : \"\");\n\n\t \n\tif (uhci->rh_state == UHCI_RH_SUSPENDED) {\n\t\tunsigned egsm;\n\n\t\t \n\t\tegsm = uhci_readw(uhci, USBCMD) & USBCMD_EGSM;\n\t\tuhci->rh_state = UHCI_RH_RESUMING;\n\t\tuhci_writew(uhci, USBCMD_FGR | USBCMD_CF | egsm, USBCMD);\n\t\tspin_unlock_irq(&uhci->lock);\n\t\tmsleep(20);\n\t\tspin_lock_irq(&uhci->lock);\n\t\tif (uhci->dead)\n\t\t\treturn;\n\n\t\t \n\t\tuhci_writew(uhci, USBCMD_CF, USBCMD);\n\t\tmb();\n\t\tudelay(4);\n\t\tif (uhci_readw(uhci, USBCMD) & USBCMD_FGR)\n\t\t\tdev_warn(uhci_dev(uhci), \"FGR not stopped yet!\\n\");\n\t}\n\n\tstart_rh(uhci);\n\n\t \n\tmod_timer(&uhci_to_hcd(uhci)->rh_timer, jiffies);\n}\n\nstatic irqreturn_t uhci_irq(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned short status;\n\n\t \n\tstatus = uhci_readw(uhci, USBSTS);\n\tif (!(status & ~USBSTS_HCH))\t \n\t\treturn IRQ_NONE;\n\tuhci_writew(uhci, status, USBSTS);\t\t \n\n\tspin_lock(&uhci->lock);\n\tif (unlikely(!uhci->is_initialized))\t \n\t\tgoto done;\n\n\tif (status & ~(USBSTS_USBINT | USBSTS_ERROR | USBSTS_RD)) {\n\t\tif (status & USBSTS_HSE)\n\t\t\tdev_err(uhci_dev(uhci),\n\t\t\t\t\"host system error, PCI problems?\\n\");\n\t\tif (status & USBSTS_HCPE)\n\t\t\tdev_err(uhci_dev(uhci),\n\t\t\t\t\"host controller process error, something bad happened!\\n\");\n\t\tif (status & USBSTS_HCH) {\n\t\t\tif (uhci->rh_state >= UHCI_RH_RUNNING) {\n\t\t\t\tdev_err(uhci_dev(uhci),\n\t\t\t\t\t\"host controller halted, very bad!\\n\");\n\t\t\t\tif (debug > 1 && errbuf) {\n\t\t\t\t\t \n\t\t\t\t\tuhci_sprint_schedule(uhci, errbuf,\n\t\t\t\t\t\tERRBUF_LEN - EXTRA_SPACE);\n\t\t\t\t\tlprintk(errbuf);\n\t\t\t\t}\n\t\t\t\tuhci_hc_died(uhci);\n\t\t\t\tusb_hc_died(hcd);\n\n\t\t\t\t \n\t\t\t\tmod_timer(&hcd->rh_timer, jiffies);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (status & USBSTS_RD) {\n\t\tspin_unlock(&uhci->lock);\n\t\tusb_hcd_poll_rh_status(hcd);\n\t} else {\n\t\tuhci_scan_schedule(uhci);\n done:\n\t\tspin_unlock(&uhci->lock);\n\t}\n\n\treturn IRQ_HANDLED;\n}\n\n \nstatic void uhci_get_current_frame_number(struct uhci_hcd *uhci)\n{\n\tif (!uhci->is_stopped) {\n\t\tunsigned delta;\n\n\t\tdelta = (uhci_readw(uhci, USBFRNUM) - uhci->frame_number) &\n\t\t\t\t(UHCI_NUMFRAMES - 1);\n\t\tuhci->frame_number += delta;\n\t}\n}\n\n \nstatic void release_uhci(struct uhci_hcd *uhci)\n{\n\tint i;\n\n\n\tspin_lock_irq(&uhci->lock);\n\tuhci->is_initialized = 0;\n\tspin_unlock_irq(&uhci->lock);\n\n\tdebugfs_lookup_and_remove(uhci_to_hcd(uhci)->self.bus_name,\n\t\t\t\t  uhci_debugfs_root);\n\n\tfor (i = 0; i < UHCI_NUM_SKELQH; i++)\n\t\tuhci_free_qh(uhci, uhci->skelqh[i]);\n\n\tuhci_free_td(uhci, uhci->term_td);\n\n\tdma_pool_destroy(uhci->qh_pool);\n\n\tdma_pool_destroy(uhci->td_pool);\n\n\tkfree(uhci->frame_cpu);\n\n\tdma_free_coherent(uhci_dev(uhci),\n\t\t\tUHCI_NUMFRAMES * sizeof(*uhci->frame),\n\t\t\tuhci->frame, uhci->frame_dma_handle);\n}\n\n \nstatic int uhci_start(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tint retval = -EBUSY;\n\tint i;\n\n\thcd->uses_new_polling = 1;\n\t \n\tif (!hcd->localmem_pool)\n\t\thcd->self.sg_tablesize = ~0;\n\n\tspin_lock_init(&uhci->lock);\n\ttimer_setup(&uhci->fsbr_timer, uhci_fsbr_timeout, 0);\n\tINIT_LIST_HEAD(&uhci->idle_qh_list);\n\tinit_waitqueue_head(&uhci->waitqh);\n\n#ifdef UHCI_DEBUG_OPS\n\tdebugfs_create_file(hcd->self.bus_name, S_IFREG|S_IRUGO|S_IWUSR,\n\t\t\t    uhci_debugfs_root, uhci, &uhci_debug_operations);\n#endif\n\n\tuhci->frame = dma_alloc_coherent(uhci_dev(uhci),\n\t\t\t\t\t UHCI_NUMFRAMES * sizeof(*uhci->frame),\n\t\t\t\t\t &uhci->frame_dma_handle, GFP_KERNEL);\n\tif (!uhci->frame) {\n\t\tdev_err(uhci_dev(uhci),\n\t\t\t\"unable to allocate consistent memory for frame list\\n\");\n\t\tgoto err_alloc_frame;\n\t}\n\n\tuhci->frame_cpu = kcalloc(UHCI_NUMFRAMES, sizeof(*uhci->frame_cpu),\n\t\t\tGFP_KERNEL);\n\tif (!uhci->frame_cpu)\n\t\tgoto err_alloc_frame_cpu;\n\n\tuhci->td_pool = dma_pool_create(\"uhci_td\", uhci_dev(uhci),\n\t\t\tsizeof(struct uhci_td), 16, 0);\n\tif (!uhci->td_pool) {\n\t\tdev_err(uhci_dev(uhci), \"unable to create td dma_pool\\n\");\n\t\tgoto err_create_td_pool;\n\t}\n\n\tuhci->qh_pool = dma_pool_create(\"uhci_qh\", uhci_dev(uhci),\n\t\t\tsizeof(struct uhci_qh), 16, 0);\n\tif (!uhci->qh_pool) {\n\t\tdev_err(uhci_dev(uhci), \"unable to create qh dma_pool\\n\");\n\t\tgoto err_create_qh_pool;\n\t}\n\n\tuhci->term_td = uhci_alloc_td(uhci);\n\tif (!uhci->term_td) {\n\t\tdev_err(uhci_dev(uhci), \"unable to allocate terminating TD\\n\");\n\t\tgoto err_alloc_term_td;\n\t}\n\n\tfor (i = 0; i < UHCI_NUM_SKELQH; i++) {\n\t\tuhci->skelqh[i] = uhci_alloc_qh(uhci, NULL, NULL);\n\t\tif (!uhci->skelqh[i]) {\n\t\t\tdev_err(uhci_dev(uhci), \"unable to allocate QH\\n\");\n\t\t\tgoto err_alloc_skelqh;\n\t\t}\n\t}\n\n\t \n\tfor (i = SKEL_ISO + 1; i < SKEL_ASYNC; ++i)\n\t\tuhci->skelqh[i]->link = LINK_TO_QH(uhci, uhci->skel_async_qh);\n\tuhci->skel_async_qh->link = UHCI_PTR_TERM(uhci);\n\tuhci->skel_term_qh->link = LINK_TO_QH(uhci, uhci->skel_term_qh);\n\n\t \n\tuhci_fill_td(uhci, uhci->term_td, 0, uhci_explen(0) |\n\t\t\t(0x7f << TD_TOKEN_DEVADDR_SHIFT) | USB_PID_IN, 0);\n\tuhci->term_td->link = UHCI_PTR_TERM(uhci);\n\tuhci->skel_async_qh->element = uhci->skel_term_qh->element =\n\t\tLINK_TO_TD(uhci, uhci->term_td);\n\n\t \n\tfor (i = 0; i < UHCI_NUMFRAMES; i++) {\n\n\t\t \n\t\tuhci->frame[i] = uhci_frame_skel_link(uhci, i);\n\t}\n\n\t \n\tmb();\n\n\tspin_lock_irq(&uhci->lock);\n\tconfigure_hc(uhci);\n\tuhci->is_initialized = 1;\n\tstart_rh(uhci);\n\tspin_unlock_irq(&uhci->lock);\n\treturn 0;\n\n \nerr_alloc_skelqh:\n\tfor (i = 0; i < UHCI_NUM_SKELQH; i++) {\n\t\tif (uhci->skelqh[i])\n\t\t\tuhci_free_qh(uhci, uhci->skelqh[i]);\n\t}\n\n\tuhci_free_td(uhci, uhci->term_td);\n\nerr_alloc_term_td:\n\tdma_pool_destroy(uhci->qh_pool);\n\nerr_create_qh_pool:\n\tdma_pool_destroy(uhci->td_pool);\n\nerr_create_td_pool:\n\tkfree(uhci->frame_cpu);\n\nerr_alloc_frame_cpu:\n\tdma_free_coherent(uhci_dev(uhci),\n\t\t\tUHCI_NUMFRAMES * sizeof(*uhci->frame),\n\t\t\tuhci->frame, uhci->frame_dma_handle);\n\nerr_alloc_frame:\n\tdebugfs_lookup_and_remove(hcd->self.bus_name, uhci_debugfs_root);\n\n\treturn retval;\n}\n\nstatic void uhci_stop(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\n\tspin_lock_irq(&uhci->lock);\n\tif (HCD_HW_ACCESSIBLE(hcd) && !uhci->dead)\n\t\tuhci_hc_died(uhci);\n\tuhci_scan_schedule(uhci);\n\tspin_unlock_irq(&uhci->lock);\n\tsynchronize_irq(hcd->irq);\n\n\tdel_timer_sync(&uhci->fsbr_timer);\n\trelease_uhci(uhci);\n}\n\n#ifdef CONFIG_PM\nstatic int uhci_rh_suspend(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tint rc = 0;\n\n\tspin_lock_irq(&uhci->lock);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\trc = -ESHUTDOWN;\n\telse if (uhci->dead)\n\t\t;\t\t \n\n\t \n\telse if (hcd->self.root_hub->do_remote_wakeup &&\n\t\t\tuhci->resuming_ports) {\n\t\tdev_dbg(uhci_dev(uhci),\n\t\t\t\"suspend failed because a port is resuming\\n\");\n\t\trc = -EBUSY;\n\t} else\n\t\tsuspend_rh(uhci, UHCI_RH_SUSPENDED);\n\tspin_unlock_irq(&uhci->lock);\n\treturn rc;\n}\n\nstatic int uhci_rh_resume(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tint rc = 0;\n\n\tspin_lock_irq(&uhci->lock);\n\tif (!HCD_HW_ACCESSIBLE(hcd))\n\t\trc = -ESHUTDOWN;\n\telse if (!uhci->dead)\n\t\twakeup_rh(uhci);\n\tspin_unlock_irq(&uhci->lock);\n\treturn rc;\n}\n\n#endif\n\n \nstatic void uhci_hcd_endpoint_disable(struct usb_hcd *hcd,\n\t\tstruct usb_host_endpoint *hep)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tstruct uhci_qh *qh;\n\n\tspin_lock_irq(&uhci->lock);\n\tqh = (struct uhci_qh *) hep->hcpriv;\n\tif (qh == NULL)\n\t\tgoto done;\n\n\twhile (qh->state != QH_STATE_IDLE) {\n\t\t++uhci->num_waiting;\n\t\tspin_unlock_irq(&uhci->lock);\n\t\twait_event_interruptible(uhci->waitqh,\n\t\t\t\tqh->state == QH_STATE_IDLE);\n\t\tspin_lock_irq(&uhci->lock);\n\t\t--uhci->num_waiting;\n\t}\n\n\tuhci_free_qh(uhci, qh);\ndone:\n\tspin_unlock_irq(&uhci->lock);\n}\n\nstatic int uhci_hcd_get_frame_number(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned frame_number;\n\tunsigned delta;\n\n\t \n\tframe_number = uhci->frame_number;\n\tbarrier();\n\tdelta = (uhci_readw(uhci, USBFRNUM) - frame_number) &\n\t\t\t(UHCI_NUMFRAMES - 1);\n\treturn frame_number + delta;\n}\n\n \nstatic int uhci_count_ports(struct usb_hcd *hcd)\n{\n\tstruct uhci_hcd *uhci = hcd_to_uhci(hcd);\n\tunsigned io_size = (unsigned) hcd->rsrc_len;\n\tint port;\n\n\t \n\tfor (port = 0; port < (io_size - USBPORTSC1) / 2; port++) {\n\t\tunsigned int portstatus;\n\n\t\tportstatus = uhci_readw(uhci, USBPORTSC1 + (port * 2));\n\t\tif (!(portstatus & 0x0080) || portstatus == 0xffff)\n\t\t\tbreak;\n\t}\n\tif (debug)\n\t\tdev_info(uhci_dev(uhci), \"detected %d ports\\n\", port);\n\n\t \n\tif (port > UHCI_RH_MAXCHILD) {\n\t\tdev_info(uhci_dev(uhci),\n\t\t\t\"port count misdetected? forcing to 2 ports\\n\");\n\t\tport = 2;\n\t}\n\n\treturn port;\n}\n\nstatic const char hcd_name[] = \"uhci_hcd\";\n\n#if defined(CONFIG_USB_PCI) && defined(CONFIG_HAS_IOPORT)\n#include \"uhci-pci.c\"\n#define\tPCI_DRIVER\t\tuhci_pci_driver\n#endif\n\n#ifdef CONFIG_SPARC_LEON\n#include \"uhci-grlib.c\"\n#define PLATFORM_DRIVER\t\tuhci_grlib_driver\n#endif\n\n#ifdef CONFIG_USB_UHCI_PLATFORM\n#include \"uhci-platform.c\"\n#define PLATFORM_DRIVER\t\tuhci_platform_driver\n#endif\n\n#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)\n#error \"missing bus glue for uhci-hcd\"\n#endif\n\nstatic int __init uhci_hcd_init(void)\n{\n\tint retval = -ENOMEM;\n\n\tif (usb_disabled())\n\t\treturn -ENODEV;\n\n\tset_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\n\n#ifdef CONFIG_DYNAMIC_DEBUG\n\terrbuf = kmalloc(ERRBUF_LEN, GFP_KERNEL);\n\tif (!errbuf)\n\t\tgoto errbuf_failed;\n\tuhci_debugfs_root = debugfs_create_dir(\"uhci\", usb_debug_root);\n#endif\n\n\tuhci_up_cachep = kmem_cache_create(\"uhci_urb_priv\",\n\t\tsizeof(struct urb_priv), 0, 0, NULL);\n\tif (!uhci_up_cachep)\n\t\tgoto up_failed;\n\n#ifdef PLATFORM_DRIVER\n\tretval = platform_driver_register(&PLATFORM_DRIVER);\n\tif (retval < 0)\n\t\tgoto clean0;\n#endif\n\n#ifdef PCI_DRIVER\n\tretval = pci_register_driver(&PCI_DRIVER);\n\tif (retval < 0)\n\t\tgoto clean1;\n#endif\n\n\treturn 0;\n\n#ifdef PCI_DRIVER\nclean1:\n#endif\n#ifdef PLATFORM_DRIVER\n\tplatform_driver_unregister(&PLATFORM_DRIVER);\nclean0:\n#endif\n\tkmem_cache_destroy(uhci_up_cachep);\n\nup_failed:\n#if defined(DEBUG) || defined(CONFIG_DYNAMIC_DEBUG)\n\tdebugfs_remove(uhci_debugfs_root);\n\n\tkfree(errbuf);\n\nerrbuf_failed:\n#endif\n\n\tclear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\n\treturn retval;\n}\n\nstatic void __exit uhci_hcd_cleanup(void) \n{\n#ifdef PLATFORM_DRIVER\n\tplatform_driver_unregister(&PLATFORM_DRIVER);\n#endif\n#ifdef PCI_DRIVER\n\tpci_unregister_driver(&PCI_DRIVER);\n#endif\n\tkmem_cache_destroy(uhci_up_cachep);\n\tdebugfs_remove(uhci_debugfs_root);\n#ifdef CONFIG_DYNAMIC_DEBUG\n\tkfree(errbuf);\n#endif\n\tclear_bit(USB_UHCI_LOADED, &usb_hcds_loaded);\n}\n\nmodule_init(uhci_hcd_init);\nmodule_exit(uhci_hcd_cleanup);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n",
  "logic_map": {},
  "failure_modes": [],
  "crash_correlation_map": {}
}